static int daca_init_client(struct pmac_keywest *i2c)\r\n{\r\nunsigned short wdata = 0x00;\r\nif (i2c_smbus_write_byte_data(i2c->client, DACA_REG_SR, 0x08) < 0 ||\r\ni2c_smbus_write_byte_data(i2c->client, DACA_REG_GCFG, 0x05) < 0)\r\nreturn -EINVAL;\r\nreturn i2c_smbus_write_block_data(i2c->client, DACA_REG_AVOL,\r\n2, (unsigned char*)&wdata);\r\n}\r\nstatic int daca_set_volume(struct pmac_daca *mix)\r\n{\r\nunsigned char data[2];\r\nif (! mix->i2c.client)\r\nreturn -ENODEV;\r\nif (mix->left_vol > DACA_VOL_MAX)\r\ndata[0] = DACA_VOL_MAX;\r\nelse\r\ndata[0] = mix->left_vol;\r\nif (mix->right_vol > DACA_VOL_MAX)\r\ndata[1] = DACA_VOL_MAX;\r\nelse\r\ndata[1] = mix->right_vol;\r\ndata[1] |= mix->deemphasis ? 0x40 : 0;\r\nif (i2c_smbus_write_block_data(mix->i2c.client, DACA_REG_AVOL,\r\n2, data) < 0) {\r\nsnd_printk(KERN_ERR "failed to set volume \n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int daca_get_deemphasis(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_daca *mix;\r\nif (! (mix = chip->mixer_data))\r\nreturn -ENODEV;\r\nucontrol->value.integer.value[0] = mix->deemphasis ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int daca_put_deemphasis(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_daca *mix;\r\nint change;\r\nif (! (mix = chip->mixer_data))\r\nreturn -ENODEV;\r\nchange = mix->deemphasis != ucontrol->value.integer.value[0];\r\nif (change) {\r\nmix->deemphasis = !!ucontrol->value.integer.value[0];\r\ndaca_set_volume(mix);\r\n}\r\nreturn change;\r\n}\r\nstatic int daca_info_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = DACA_VOL_MAX;\r\nreturn 0;\r\n}\r\nstatic int daca_get_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_daca *mix;\r\nif (! (mix = chip->mixer_data))\r\nreturn -ENODEV;\r\nucontrol->value.integer.value[0] = mix->left_vol;\r\nucontrol->value.integer.value[1] = mix->right_vol;\r\nreturn 0;\r\n}\r\nstatic int daca_put_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_daca *mix;\r\nunsigned int vol[2];\r\nint change;\r\nif (! (mix = chip->mixer_data))\r\nreturn -ENODEV;\r\nvol[0] = ucontrol->value.integer.value[0];\r\nvol[1] = ucontrol->value.integer.value[1];\r\nif (vol[0] > DACA_VOL_MAX || vol[1] > DACA_VOL_MAX)\r\nreturn -EINVAL;\r\nchange = mix->left_vol != vol[0] ||\r\nmix->right_vol != vol[1];\r\nif (change) {\r\nmix->left_vol = vol[0];\r\nmix->right_vol = vol[1];\r\ndaca_set_volume(mix);\r\n}\r\nreturn change;\r\n}\r\nstatic int daca_get_amp(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_daca *mix;\r\nif (! (mix = chip->mixer_data))\r\nreturn -ENODEV;\r\nucontrol->value.integer.value[0] = mix->amp_on ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int daca_put_amp(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pmac *chip = snd_kcontrol_chip(kcontrol);\r\nstruct pmac_daca *mix;\r\nint change;\r\nif (! (mix = chip->mixer_data))\r\nreturn -ENODEV;\r\nchange = mix->amp_on != ucontrol->value.integer.value[0];\r\nif (change) {\r\nmix->amp_on = !!ucontrol->value.integer.value[0];\r\ni2c_smbus_write_byte_data(mix->i2c.client, DACA_REG_GCFG,\r\nmix->amp_on ? 0x05 : 0x04);\r\n}\r\nreturn change;\r\n}\r\nstatic void daca_resume(struct snd_pmac *chip)\r\n{\r\nstruct pmac_daca *mix = chip->mixer_data;\r\ni2c_smbus_write_byte_data(mix->i2c.client, DACA_REG_SR, 0x08);\r\ni2c_smbus_write_byte_data(mix->i2c.client, DACA_REG_GCFG,\r\nmix->amp_on ? 0x05 : 0x04);\r\ndaca_set_volume(mix);\r\n}\r\nstatic void daca_cleanup(struct snd_pmac *chip)\r\n{\r\nstruct pmac_daca *mix = chip->mixer_data;\r\nif (! mix)\r\nreturn;\r\nsnd_pmac_keywest_cleanup(&mix->i2c);\r\nkfree(mix);\r\nchip->mixer_data = NULL;\r\n}\r\nint snd_pmac_daca_init(struct snd_pmac *chip)\r\n{\r\nint i, err;\r\nstruct pmac_daca *mix;\r\nrequest_module("i2c-powermac");\r\nmix = kzalloc(sizeof(*mix), GFP_KERNEL);\r\nif (! mix)\r\nreturn -ENOMEM;\r\nchip->mixer_data = mix;\r\nchip->mixer_free = daca_cleanup;\r\nmix->amp_on = 1;\r\nmix->i2c.addr = DACA_I2C_ADDR;\r\nmix->i2c.init_client = daca_init_client;\r\nmix->i2c.name = "DACA";\r\nif ((err = snd_pmac_keywest_init(&mix->i2c)) < 0)\r\nreturn err;\r\nstrcpy(chip->card->mixername, "PowerMac DACA");\r\nfor (i = 0; i < ARRAY_SIZE(daca_mixers); i++) {\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&daca_mixers[i], chip))) < 0)\r\nreturn err;\r\n}\r\n#ifdef CONFIG_PM\r\nchip->resume = daca_resume;\r\n#endif\r\nreturn 0;\r\n}
