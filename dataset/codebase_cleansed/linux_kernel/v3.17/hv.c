static int query_hypervisor_info(void)\r\n{\r\nunsigned int eax;\r\nunsigned int ebx;\r\nunsigned int ecx;\r\nunsigned int edx;\r\nunsigned int max_leaf;\r\nunsigned int op;\r\neax = 0;\r\nebx = 0;\r\necx = 0;\r\nedx = 0;\r\nop = HVCPUID_VENDOR_MAXFUNCTION;\r\ncpuid(op, &eax, &ebx, &ecx, &edx);\r\nmax_leaf = eax;\r\nif (max_leaf >= HVCPUID_VERSION) {\r\neax = 0;\r\nebx = 0;\r\necx = 0;\r\nedx = 0;\r\nop = HVCPUID_VERSION;\r\ncpuid(op, &eax, &ebx, &ecx, &edx);\r\nhost_info_eax = eax;\r\nhost_info_ebx = ebx;\r\nhost_info_ecx = ecx;\r\nhost_info_edx = edx;\r\n}\r\nreturn max_leaf;\r\n}\r\nstatic u64 do_hypercall(u64 control, void *input, void *output)\r\n{\r\n#ifdef CONFIG_X86_64\r\nu64 hv_status = 0;\r\nu64 input_address = (input) ? virt_to_phys(input) : 0;\r\nu64 output_address = (output) ? virt_to_phys(output) : 0;\r\nvoid *hypercall_page = hv_context.hypercall_page;\r\n__asm__ __volatile__("mov %0, %%r8" : : "r" (output_address) : "r8");\r\n__asm__ __volatile__("call *%3" : "=a" (hv_status) :\r\n"c" (control), "d" (input_address),\r\n"m" (hypercall_page));\r\nreturn hv_status;\r\n#else\r\nu32 control_hi = control >> 32;\r\nu32 control_lo = control & 0xFFFFFFFF;\r\nu32 hv_status_hi = 1;\r\nu32 hv_status_lo = 1;\r\nu64 input_address = (input) ? virt_to_phys(input) : 0;\r\nu32 input_address_hi = input_address >> 32;\r\nu32 input_address_lo = input_address & 0xFFFFFFFF;\r\nu64 output_address = (output) ? virt_to_phys(output) : 0;\r\nu32 output_address_hi = output_address >> 32;\r\nu32 output_address_lo = output_address & 0xFFFFFFFF;\r\nvoid *hypercall_page = hv_context.hypercall_page;\r\n__asm__ __volatile__ ("call *%8" : "=d"(hv_status_hi),\r\n"=a"(hv_status_lo) : "d" (control_hi),\r\n"a" (control_lo), "b" (input_address_hi),\r\n"c" (input_address_lo), "D"(output_address_hi),\r\n"S"(output_address_lo), "m" (hypercall_page));\r\nreturn hv_status_lo | ((u64)hv_status_hi << 32);\r\n#endif\r\n}\r\nint hv_init(void)\r\n{\r\nint max_leaf;\r\nunion hv_x64_msr_hypercall_contents hypercall_msr;\r\nvoid *virtaddr = NULL;\r\nmemset(hv_context.synic_event_page, 0, sizeof(void *) * NR_CPUS);\r\nmemset(hv_context.synic_message_page, 0,\r\nsizeof(void *) * NR_CPUS);\r\nmemset(hv_context.vp_index, 0,\r\nsizeof(int) * NR_CPUS);\r\nmemset(hv_context.event_dpc, 0,\r\nsizeof(void *) * NR_CPUS);\r\nmax_leaf = query_hypervisor_info();\r\nhv_context.guestid = generate_guest_id(0, LINUX_VERSION_CODE, 0);\r\nwrmsrl(HV_X64_MSR_GUEST_OS_ID, hv_context.guestid);\r\nrdmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\r\nvirtaddr = __vmalloc(PAGE_SIZE, GFP_KERNEL, PAGE_KERNEL_EXEC);\r\nif (!virtaddr)\r\ngoto cleanup;\r\nhypercall_msr.enable = 1;\r\nhypercall_msr.guest_physical_address = vmalloc_to_pfn(virtaddr);\r\nwrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\r\nhypercall_msr.as_uint64 = 0;\r\nrdmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\r\nif (!hypercall_msr.enable)\r\ngoto cleanup;\r\nhv_context.hypercall_page = virtaddr;\r\nreturn 0;\r\ncleanup:\r\nif (virtaddr) {\r\nif (hypercall_msr.enable) {\r\nhypercall_msr.as_uint64 = 0;\r\nwrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\r\n}\r\nvfree(virtaddr);\r\n}\r\nreturn -ENOTSUPP;\r\n}\r\nvoid hv_cleanup(void)\r\n{\r\nunion hv_x64_msr_hypercall_contents hypercall_msr;\r\nwrmsrl(HV_X64_MSR_GUEST_OS_ID, 0);\r\nif (hv_context.hypercall_page) {\r\nhypercall_msr.as_uint64 = 0;\r\nwrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);\r\nvfree(hv_context.hypercall_page);\r\nhv_context.hypercall_page = NULL;\r\n}\r\n}\r\nint hv_post_message(union hv_connection_id connection_id,\r\nenum hv_message_type message_type,\r\nvoid *payload, size_t payload_size)\r\n{\r\nstruct aligned_input {\r\nu64 alignment8;\r\nstruct hv_input_post_message msg;\r\n};\r\nstruct hv_input_post_message *aligned_msg;\r\nu16 status;\r\nunsigned long addr;\r\nif (payload_size > HV_MESSAGE_PAYLOAD_BYTE_COUNT)\r\nreturn -EMSGSIZE;\r\naddr = (unsigned long)kmalloc(sizeof(struct aligned_input), GFP_ATOMIC);\r\nif (!addr)\r\nreturn -ENOMEM;\r\naligned_msg = (struct hv_input_post_message *)\r\n(ALIGN(addr, HV_HYPERCALL_PARAM_ALIGN));\r\naligned_msg->connectionid = connection_id;\r\naligned_msg->message_type = message_type;\r\naligned_msg->payload_size = payload_size;\r\nmemcpy((void *)aligned_msg->payload, payload, payload_size);\r\nstatus = do_hypercall(HVCALL_POST_MESSAGE, aligned_msg, NULL)\r\n& 0xFFFF;\r\nkfree((void *)addr);\r\nreturn status;\r\n}\r\nu16 hv_signal_event(void *con_id)\r\n{\r\nu16 status;\r\nstatus = (do_hypercall(HVCALL_SIGNAL_EVENT, con_id, NULL) & 0xFFFF);\r\nreturn status;\r\n}\r\nint hv_synic_alloc(void)\r\n{\r\nsize_t size = sizeof(struct tasklet_struct);\r\nint cpu;\r\nfor_each_online_cpu(cpu) {\r\nhv_context.event_dpc[cpu] = kmalloc(size, GFP_ATOMIC);\r\nif (hv_context.event_dpc[cpu] == NULL) {\r\npr_err("Unable to allocate event dpc\n");\r\ngoto err;\r\n}\r\ntasklet_init(hv_context.event_dpc[cpu], vmbus_on_event, cpu);\r\nhv_context.synic_message_page[cpu] =\r\n(void *)get_zeroed_page(GFP_ATOMIC);\r\nif (hv_context.synic_message_page[cpu] == NULL) {\r\npr_err("Unable to allocate SYNIC message page\n");\r\ngoto err;\r\n}\r\nhv_context.synic_event_page[cpu] =\r\n(void *)get_zeroed_page(GFP_ATOMIC);\r\nif (hv_context.synic_event_page[cpu] == NULL) {\r\npr_err("Unable to allocate SYNIC event page\n");\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nreturn -ENOMEM;\r\n}\r\nstatic void hv_synic_free_cpu(int cpu)\r\n{\r\nkfree(hv_context.event_dpc[cpu]);\r\nif (hv_context.synic_event_page[cpu])\r\nfree_page((unsigned long)hv_context.synic_event_page[cpu]);\r\nif (hv_context.synic_message_page[cpu])\r\nfree_page((unsigned long)hv_context.synic_message_page[cpu]);\r\n}\r\nvoid hv_synic_free(void)\r\n{\r\nint cpu;\r\nfor_each_online_cpu(cpu)\r\nhv_synic_free_cpu(cpu);\r\n}\r\nvoid hv_synic_init(void *arg)\r\n{\r\nu64 version;\r\nunion hv_synic_simp simp;\r\nunion hv_synic_siefp siefp;\r\nunion hv_synic_sint shared_sint;\r\nunion hv_synic_scontrol sctrl;\r\nu64 vp_index;\r\nint cpu = smp_processor_id();\r\nif (!hv_context.hypercall_page)\r\nreturn;\r\nrdmsrl(HV_X64_MSR_SVERSION, version);\r\nrdmsrl(HV_X64_MSR_SIMP, simp.as_uint64);\r\nsimp.simp_enabled = 1;\r\nsimp.base_simp_gpa = virt_to_phys(hv_context.synic_message_page[cpu])\r\n>> PAGE_SHIFT;\r\nwrmsrl(HV_X64_MSR_SIMP, simp.as_uint64);\r\nrdmsrl(HV_X64_MSR_SIEFP, siefp.as_uint64);\r\nsiefp.siefp_enabled = 1;\r\nsiefp.base_siefp_gpa = virt_to_phys(hv_context.synic_event_page[cpu])\r\n>> PAGE_SHIFT;\r\nwrmsrl(HV_X64_MSR_SIEFP, siefp.as_uint64);\r\nrdmsrl(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT, shared_sint.as_uint64);\r\nshared_sint.as_uint64 = 0;\r\nshared_sint.vector = HYPERVISOR_CALLBACK_VECTOR;\r\nshared_sint.masked = false;\r\nshared_sint.auto_eoi = true;\r\nwrmsrl(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT, shared_sint.as_uint64);\r\nrdmsrl(HV_X64_MSR_SCONTROL, sctrl.as_uint64);\r\nsctrl.enable = 1;\r\nwrmsrl(HV_X64_MSR_SCONTROL, sctrl.as_uint64);\r\nhv_context.synic_initialized = true;\r\nrdmsrl(HV_X64_MSR_VP_INDEX, vp_index);\r\nhv_context.vp_index[cpu] = (u32)vp_index;\r\nINIT_LIST_HEAD(&hv_context.percpu_list[cpu]);\r\nreturn;\r\n}\r\nvoid hv_synic_cleanup(void *arg)\r\n{\r\nunion hv_synic_sint shared_sint;\r\nunion hv_synic_simp simp;\r\nunion hv_synic_siefp siefp;\r\nint cpu = smp_processor_id();\r\nif (!hv_context.synic_initialized)\r\nreturn;\r\nrdmsrl(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT, shared_sint.as_uint64);\r\nshared_sint.masked = 1;\r\nwrmsrl(HV_X64_MSR_SINT0 + VMBUS_MESSAGE_SINT, shared_sint.as_uint64);\r\nrdmsrl(HV_X64_MSR_SIMP, simp.as_uint64);\r\nsimp.simp_enabled = 0;\r\nsimp.base_simp_gpa = 0;\r\nwrmsrl(HV_X64_MSR_SIMP, simp.as_uint64);\r\nrdmsrl(HV_X64_MSR_SIEFP, siefp.as_uint64);\r\nsiefp.siefp_enabled = 0;\r\nsiefp.base_siefp_gpa = 0;\r\nwrmsrl(HV_X64_MSR_SIEFP, siefp.as_uint64);\r\nfree_page((unsigned long)hv_context.synic_message_page[cpu]);\r\nfree_page((unsigned long)hv_context.synic_event_page[cpu]);\r\n}
