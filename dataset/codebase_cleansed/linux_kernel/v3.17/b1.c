avmcard *b1_alloc_card(int nr_controllers)\r\n{\r\navmcard *card;\r\navmctrl_info *cinfo;\r\nint i;\r\ncard = kzalloc(sizeof(*card), GFP_KERNEL);\r\nif (!card)\r\nreturn NULL;\r\ncinfo = kzalloc(sizeof(*cinfo) * nr_controllers, GFP_KERNEL);\r\nif (!cinfo) {\r\nkfree(card);\r\nreturn NULL;\r\n}\r\ncard->ctrlinfo = cinfo;\r\nfor (i = 0; i < nr_controllers; i++) {\r\nINIT_LIST_HEAD(&cinfo[i].ncci_head);\r\ncinfo[i].card = card;\r\n}\r\nspin_lock_init(&card->lock);\r\ncard->nr_controllers = nr_controllers;\r\nreturn card;\r\n}\r\nvoid b1_free_card(avmcard *card)\r\n{\r\nkfree(card->ctrlinfo);\r\nkfree(card);\r\n}\r\nint b1_detect(unsigned int base, enum avmcardtype cardtype)\r\n{\r\nint onoff, i;\r\nif ((inb(base + B1_INSTAT) & 0xfc)\r\n|| (inb(base + B1_OUTSTAT) & 0xfc))\r\nreturn 1;\r\nb1outp(base, B1_INSTAT, 0x2);\r\nif ((inb(base + B1_INSTAT) & 0xfe) != 0x2\r\n)\r\nreturn 2;\r\nb1outp(base, B1_INSTAT, 0x0);\r\nb1outp(base, B1_OUTSTAT, 0x0);\r\nif ((inb(base + B1_INSTAT) & 0xfe)\r\n|| (inb(base + B1_OUTSTAT) & 0xfe))\r\nreturn 3;\r\nfor (onoff = !0, i = 0; i < 10; i++) {\r\nb1_set_test_bit(base, cardtype, onoff);\r\nif (b1_get_test_bit(base, cardtype) != onoff)\r\nreturn 4;\r\nonoff = !onoff;\r\n}\r\nif (cardtype == avm_m1)\r\nreturn 0;\r\nif ((b1_rd_reg(base, B1_STAT1(cardtype)) & 0x0f) != 0x01)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nvoid b1_getrevision(avmcard *card)\r\n{\r\ncard->class = inb(card->port + B1_ANALYSE);\r\ncard->revision = inb(card->port + B1_REVISION);\r\n}\r\nint b1_load_t4file(avmcard *card, capiloaddatapart *t4file)\r\n{\r\nunsigned char buf[FWBUF_SIZE];\r\nunsigned char *dp;\r\nint i, left;\r\nunsigned int base = card->port;\r\ndp = t4file->data;\r\nleft = t4file->len;\r\nwhile (left > FWBUF_SIZE) {\r\nif (t4file->user) {\r\nif (copy_from_user(buf, dp, FWBUF_SIZE))\r\nreturn -EFAULT;\r\n} else {\r\nmemcpy(buf, dp, FWBUF_SIZE);\r\n}\r\nfor (i = 0; i < FWBUF_SIZE; i++)\r\nif (b1_save_put_byte(base, buf[i]) < 0) {\r\nprintk(KERN_ERR "%s: corrupted firmware file ?\n",\r\ncard->name);\r\nreturn -EIO;\r\n}\r\nleft -= FWBUF_SIZE;\r\ndp += FWBUF_SIZE;\r\n}\r\nif (left) {\r\nif (t4file->user) {\r\nif (copy_from_user(buf, dp, left))\r\nreturn -EFAULT;\r\n} else {\r\nmemcpy(buf, dp, left);\r\n}\r\nfor (i = 0; i < left; i++)\r\nif (b1_save_put_byte(base, buf[i]) < 0) {\r\nprintk(KERN_ERR "%s: corrupted firmware file ?\n",\r\ncard->name);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint b1_load_config(avmcard *card, capiloaddatapart *config)\r\n{\r\nunsigned char buf[FWBUF_SIZE];\r\nunsigned char *dp;\r\nunsigned int base = card->port;\r\nint i, j, left;\r\ndp = config->data;\r\nleft = config->len;\r\nif (left) {\r\nb1_put_byte(base, SEND_CONFIG);\r\nb1_put_word(base, 1);\r\nb1_put_byte(base, SEND_CONFIG);\r\nb1_put_word(base, left);\r\n}\r\nwhile (left > FWBUF_SIZE) {\r\nif (config->user) {\r\nif (copy_from_user(buf, dp, FWBUF_SIZE))\r\nreturn -EFAULT;\r\n} else {\r\nmemcpy(buf, dp, FWBUF_SIZE);\r\n}\r\nfor (i = 0; i < FWBUF_SIZE; ) {\r\nb1_put_byte(base, SEND_CONFIG);\r\nfor (j = 0; j < 4; j++) {\r\nb1_put_byte(base, buf[i++]);\r\n}\r\n}\r\nleft -= FWBUF_SIZE;\r\ndp += FWBUF_SIZE;\r\n}\r\nif (left) {\r\nif (config->user) {\r\nif (copy_from_user(buf, dp, left))\r\nreturn -EFAULT;\r\n} else {\r\nmemcpy(buf, dp, left);\r\n}\r\nfor (i = 0; i < left; ) {\r\nb1_put_byte(base, SEND_CONFIG);\r\nfor (j = 0; j < 4; j++) {\r\nif (i < left)\r\nb1_put_byte(base, buf[i++]);\r\nelse\r\nb1_put_byte(base, 0);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint b1_loaded(avmcard *card)\r\n{\r\nunsigned int base = card->port;\r\nunsigned long stop;\r\nunsigned char ans;\r\nunsigned long tout = 2;\r\nfor (stop = jiffies + tout * HZ; time_before(jiffies, stop);) {\r\nif (b1_tx_empty(base))\r\nbreak;\r\n}\r\nif (!b1_tx_empty(base)) {\r\nprintk(KERN_ERR "%s: b1_loaded: tx err, corrupted t4 file ?\n",\r\ncard->name);\r\nreturn 0;\r\n}\r\nb1_put_byte(base, SEND_POLL);\r\nfor (stop = jiffies + tout * HZ; time_before(jiffies, stop);) {\r\nif (b1_rx_full(base)) {\r\nif ((ans = b1_get_byte(base)) == RECEIVE_POLL) {\r\nreturn 1;\r\n}\r\nprintk(KERN_ERR "%s: b1_loaded: got 0x%x, firmware not running\n",\r\ncard->name, ans);\r\nreturn 0;\r\n}\r\n}\r\nprintk(KERN_ERR "%s: b1_loaded: firmware not running\n", card->name);\r\nreturn 0;\r\n}\r\nint b1_load_firmware(struct capi_ctr *ctrl, capiloaddata *data)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nunsigned int port = card->port;\r\nunsigned long flags;\r\nint retval;\r\nb1_reset(port);\r\nif ((retval = b1_load_t4file(card, &data->firmware))) {\r\nb1_reset(port);\r\nprintk(KERN_ERR "%s: failed to load t4file!!\n",\r\ncard->name);\r\nreturn retval;\r\n}\r\nb1_disable_irq(port);\r\nif (data->configuration.len > 0 && data->configuration.data) {\r\nif ((retval = b1_load_config(card, &data->configuration))) {\r\nb1_reset(port);\r\nprintk(KERN_ERR "%s: failed to load config!!\n",\r\ncard->name);\r\nreturn retval;\r\n}\r\n}\r\nif (!b1_loaded(card)) {\r\nprintk(KERN_ERR "%s: failed to load t4file.\n", card->name);\r\nreturn -EIO;\r\n}\r\nspin_lock_irqsave(&card->lock, flags);\r\nb1_setinterrupt(port, card->irq, card->cardtype);\r\nb1_put_byte(port, SEND_INIT);\r\nb1_put_word(port, CAPI_MAXAPPL);\r\nb1_put_word(port, AVM_NCCI_PER_CHANNEL * 2);\r\nb1_put_word(port, ctrl->cnr - 1);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nreturn 0;\r\n}\r\nvoid b1_reset_ctr(struct capi_ctr *ctrl)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nunsigned int port = card->port;\r\nunsigned long flags;\r\nb1_reset(port);\r\nb1_reset(port);\r\nmemset(cinfo->version, 0, sizeof(cinfo->version));\r\nspin_lock_irqsave(&card->lock, flags);\r\ncapilib_release(&cinfo->ncci_head);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncapi_ctr_down(ctrl);\r\n}\r\nvoid b1_register_appl(struct capi_ctr *ctrl,\r\nu16 appl,\r\ncapi_register_params *rp)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nunsigned int port = card->port;\r\nunsigned long flags;\r\nint nconn, want = rp->level3cnt;\r\nif (want > 0) nconn = want;\r\nelse nconn = ctrl->profile.nbchannel * -want;\r\nif (nconn == 0) nconn = ctrl->profile.nbchannel;\r\nspin_lock_irqsave(&card->lock, flags);\r\nb1_put_byte(port, SEND_REGISTER);\r\nb1_put_word(port, appl);\r\nb1_put_word(port, 1024 * (nconn + 1));\r\nb1_put_word(port, nconn);\r\nb1_put_word(port, rp->datablkcnt);\r\nb1_put_word(port, rp->datablklen);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\nvoid b1_release_appl(struct capi_ctr *ctrl, u16 appl)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nunsigned int port = card->port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\ncapilib_release_appl(&cinfo->ncci_head, appl);\r\nb1_put_byte(port, SEND_RELEASE);\r\nb1_put_word(port, appl);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\nu16 b1_send_message(struct capi_ctr *ctrl, struct sk_buff *skb)\r\n{\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nunsigned int port = card->port;\r\nunsigned long flags;\r\nu16 len = CAPIMSG_LEN(skb->data);\r\nu8 cmd = CAPIMSG_COMMAND(skb->data);\r\nu8 subcmd = CAPIMSG_SUBCOMMAND(skb->data);\r\nu16 dlen, retval;\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (CAPICMD(cmd, subcmd) == CAPI_DATA_B3_REQ) {\r\nretval = capilib_data_b3_req(&cinfo->ncci_head,\r\nCAPIMSG_APPID(skb->data),\r\nCAPIMSG_NCCI(skb->data),\r\nCAPIMSG_MSGID(skb->data));\r\nif (retval != CAPI_NOERROR) {\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nreturn retval;\r\n}\r\ndlen = CAPIMSG_DATALEN(skb->data);\r\nb1_put_byte(port, SEND_DATA_B3_REQ);\r\nb1_put_slice(port, skb->data, len);\r\nb1_put_slice(port, skb->data + len, dlen);\r\n} else {\r\nb1_put_byte(port, SEND_MESSAGE);\r\nb1_put_slice(port, skb->data, len);\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ndev_kfree_skb_any(skb);\r\nreturn CAPI_NOERROR;\r\n}\r\nvoid b1_parse_version(avmctrl_info *cinfo)\r\n{\r\nstruct capi_ctr *ctrl = &cinfo->capi_ctrl;\r\navmcard *card = cinfo->card;\r\ncapi_profile *profp;\r\nu8 *dversion;\r\nu8 flag;\r\nint i, j;\r\nfor (j = 0; j < AVM_MAXVERSION; j++)\r\ncinfo->version[j] = "\0\0" + 1;\r\nfor (i = 0, j = 0;\r\nj < AVM_MAXVERSION && i < cinfo->versionlen;\r\nj++, i += cinfo->versionbuf[i] + 1)\r\ncinfo->version[j] = &cinfo->versionbuf[i + 1];\r\nstrlcpy(ctrl->serial, cinfo->version[VER_SERIAL], sizeof(ctrl->serial));\r\nmemcpy(&ctrl->profile, cinfo->version[VER_PROFILE], sizeof(capi_profile));\r\nstrlcpy(ctrl->manu, "AVM GmbH", sizeof(ctrl->manu));\r\ndversion = cinfo->version[VER_DRIVER];\r\nctrl->version.majorversion = 2;\r\nctrl->version.minorversion = 0;\r\nctrl->version.majormanuversion = (((dversion[0] - '0') & 0xf) << 4);\r\nctrl->version.majormanuversion |= ((dversion[2] - '0') & 0xf);\r\nctrl->version.minormanuversion = (dversion[3] - '0') << 4;\r\nctrl->version.minormanuversion |=\r\n(dversion[5] - '0') * 10 + ((dversion[6] - '0') & 0xf);\r\nprofp = &ctrl->profile;\r\nflag = ((u8 *)(profp->manu))[1];\r\nswitch (flag) {\r\ncase 0: if (cinfo->version[VER_CARDTYPE])\r\nstrcpy(cinfo->cardname, cinfo->version[VER_CARDTYPE]);\r\nelse strcpy(cinfo->cardname, "B1");\r\nbreak;\r\ncase 3: strcpy(cinfo->cardname, "PCMCIA B"); break;\r\ncase 4: strcpy(cinfo->cardname, "PCMCIA M1"); break;\r\ncase 5: strcpy(cinfo->cardname, "PCMCIA M2"); break;\r\ncase 6: strcpy(cinfo->cardname, "B1 V3.0"); break;\r\ncase 7: strcpy(cinfo->cardname, "B1 PCI"); break;\r\ndefault: sprintf(cinfo->cardname, "AVM?%u", (unsigned int)flag); break;\r\n}\r\nprintk(KERN_NOTICE "%s: card %d \"%s\" ready.\n",\r\ncard->name, ctrl->cnr, cinfo->cardname);\r\nflag = ((u8 *)(profp->manu))[3];\r\nif (flag)\r\nprintk(KERN_NOTICE "%s: card %d Protocol:%s%s%s%s%s%s%s\n",\r\ncard->name,\r\nctrl->cnr,\r\n(flag & 0x01) ? " DSS1" : "",\r\n(flag & 0x02) ? " CT1" : "",\r\n(flag & 0x04) ? " VN3" : "",\r\n(flag & 0x08) ? " NI1" : "",\r\n(flag & 0x10) ? " AUSTEL" : "",\r\n(flag & 0x20) ? " ESS" : "",\r\n(flag & 0x40) ? " 1TR6" : ""\r\n);\r\nflag = ((u8 *)(profp->manu))[5];\r\nif (flag)\r\nprintk(KERN_NOTICE "%s: card %d Linetype:%s%s%s%s\n",\r\ncard->name,\r\nctrl->cnr,\r\n(flag & 0x01) ? " point to point" : "",\r\n(flag & 0x02) ? " point to multipoint" : "",\r\n(flag & 0x08) ? " leased line without D-channel" : "",\r\n(flag & 0x04) ? " leased line with D-channel" : ""\r\n);\r\n}\r\nirqreturn_t b1_interrupt(int interrupt, void *devptr)\r\n{\r\navmcard *card = devptr;\r\navmctrl_info *cinfo = &card->ctrlinfo[0];\r\nstruct capi_ctr *ctrl = &cinfo->capi_ctrl;\r\nunsigned char b1cmd;\r\nstruct sk_buff *skb;\r\nunsigned ApplId;\r\nunsigned MsgLen;\r\nunsigned DataB3Len;\r\nunsigned NCCI;\r\nunsigned WindowSize;\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (!b1_rx_full(card->port)) {\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nb1cmd = b1_get_byte(card->port);\r\nswitch (b1cmd) {\r\ncase RECEIVE_DATA_B3_IND:\r\nApplId = (unsigned) b1_get_word(card->port);\r\nMsgLen = b1_get_slice(card->port, card->msgbuf);\r\nDataB3Len = b1_get_slice(card->port, card->databuf);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nif (MsgLen < 30) {\r\nmemset(card->msgbuf + MsgLen, 0, 30-MsgLen);\r\nMsgLen = 30;\r\nCAPIMSG_SETLEN(card->msgbuf, 30);\r\n}\r\nif (!(skb = alloc_skb(DataB3Len + MsgLen, GFP_ATOMIC))) {\r\nprintk(KERN_ERR "%s: incoming packet dropped\n",\r\ncard->name);\r\n} else {\r\nmemcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);\r\nmemcpy(skb_put(skb, DataB3Len), card->databuf, DataB3Len);\r\ncapi_ctr_handle_message(ctrl, ApplId, skb);\r\n}\r\nbreak;\r\ncase RECEIVE_MESSAGE:\r\nApplId = (unsigned) b1_get_word(card->port);\r\nMsgLen = b1_get_slice(card->port, card->msgbuf);\r\nif (!(skb = alloc_skb(MsgLen, GFP_ATOMIC))) {\r\nprintk(KERN_ERR "%s: incoming packet dropped\n",\r\ncard->name);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n} else {\r\nmemcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);\r\nif (CAPIMSG_CMD(skb->data) == CAPI_DATA_B3_CONF)\r\ncapilib_data_b3_conf(&cinfo->ncci_head, ApplId,\r\nCAPIMSG_NCCI(skb->data),\r\nCAPIMSG_MSGID(skb->data));\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncapi_ctr_handle_message(ctrl, ApplId, skb);\r\n}\r\nbreak;\r\ncase RECEIVE_NEW_NCCI:\r\nApplId = b1_get_word(card->port);\r\nNCCI = b1_get_word(card->port);\r\nWindowSize = b1_get_word(card->port);\r\ncapilib_new_ncci(&cinfo->ncci_head, ApplId, NCCI, WindowSize);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nbreak;\r\ncase RECEIVE_FREE_NCCI:\r\nApplId = b1_get_word(card->port);\r\nNCCI = b1_get_word(card->port);\r\nif (NCCI != 0xffffffff)\r\ncapilib_free_ncci(&cinfo->ncci_head, ApplId, NCCI);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nbreak;\r\ncase RECEIVE_START:\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncapi_ctr_resume_output(ctrl);\r\nbreak;\r\ncase RECEIVE_STOP:\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncapi_ctr_suspend_output(ctrl);\r\nbreak;\r\ncase RECEIVE_INIT:\r\ncinfo->versionlen = b1_get_slice(card->port, cinfo->versionbuf);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nb1_parse_version(cinfo);\r\nprintk(KERN_INFO "%s: %s-card (%s) now active\n",\r\ncard->name,\r\ncinfo->version[VER_CARDTYPE],\r\ncinfo->version[VER_DRIVER]);\r\ncapi_ctr_ready(ctrl);\r\nbreak;\r\ncase RECEIVE_TASK_READY:\r\nApplId = (unsigned) b1_get_word(card->port);\r\nMsgLen = b1_get_slice(card->port, card->msgbuf);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncard->msgbuf[MsgLen] = 0;\r\nwhile (MsgLen > 0\r\n&& (card->msgbuf[MsgLen - 1] == '\n'\r\n|| card->msgbuf[MsgLen - 1] == '\r')) {\r\ncard->msgbuf[MsgLen - 1] = 0;\r\nMsgLen--;\r\n}\r\nprintk(KERN_INFO "%s: task %d \"%s\" ready.\n",\r\ncard->name, ApplId, card->msgbuf);\r\nbreak;\r\ncase RECEIVE_DEBUGMSG:\r\nMsgLen = b1_get_slice(card->port, card->msgbuf);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncard->msgbuf[MsgLen] = 0;\r\nwhile (MsgLen > 0\r\n&& (card->msgbuf[MsgLen - 1] == '\n'\r\n|| card->msgbuf[MsgLen - 1] == '\r')) {\r\ncard->msgbuf[MsgLen - 1] = 0;\r\nMsgLen--;\r\n}\r\nprintk(KERN_INFO "%s: DEBUG: %s\n", card->name, card->msgbuf);\r\nbreak;\r\ncase 0xff:\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nprintk(KERN_ERR "%s: card removed ?\n", card->name);\r\nreturn IRQ_NONE;\r\ndefault:\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nprintk(KERN_ERR "%s: b1_interrupt: 0x%x ???\n",\r\ncard->name, b1cmd);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int b1ctl_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct capi_ctr *ctrl = m->private;\r\navmctrl_info *cinfo = (avmctrl_info *)(ctrl->driverdata);\r\navmcard *card = cinfo->card;\r\nu8 flag;\r\nchar *s;\r\nseq_printf(m, "%-16s %s\n", "name", card->name);\r\nseq_printf(m, "%-16s 0x%x\n", "io", card->port);\r\nseq_printf(m, "%-16s %d\n", "irq", card->irq);\r\nswitch (card->cardtype) {\r\ncase avm_b1isa: s = "B1 ISA"; break;\r\ncase avm_b1pci: s = "B1 PCI"; break;\r\ncase avm_b1pcmcia: s = "B1 PCMCIA"; break;\r\ncase avm_m1: s = "M1"; break;\r\ncase avm_m2: s = "M2"; break;\r\ncase avm_t1isa: s = "T1 ISA (HEMA)"; break;\r\ncase avm_t1pci: s = "T1 PCI"; break;\r\ncase avm_c4: s = "C4"; break;\r\ncase avm_c2: s = "C2"; break;\r\ndefault: s = "???"; break;\r\n}\r\nseq_printf(m, "%-16s %s\n", "type", s);\r\nif (card->cardtype == avm_t1isa)\r\nseq_printf(m, "%-16s %d\n", "cardnr", card->cardnr);\r\nif ((s = cinfo->version[VER_DRIVER]) != NULL)\r\nseq_printf(m, "%-16s %s\n", "ver_driver", s);\r\nif ((s = cinfo->version[VER_CARDTYPE]) != NULL)\r\nseq_printf(m, "%-16s %s\n", "ver_cardtype", s);\r\nif ((s = cinfo->version[VER_SERIAL]) != NULL)\r\nseq_printf(m, "%-16s %s\n", "ver_serial", s);\r\nif (card->cardtype != avm_m1) {\r\nflag = ((u8 *)(ctrl->profile.manu))[3];\r\nif (flag)\r\nseq_printf(m, "%-16s%s%s%s%s%s%s%s\n",\r\n"protocol",\r\n(flag & 0x01) ? " DSS1" : "",\r\n(flag & 0x02) ? " CT1" : "",\r\n(flag & 0x04) ? " VN3" : "",\r\n(flag & 0x08) ? " NI1" : "",\r\n(flag & 0x10) ? " AUSTEL" : "",\r\n(flag & 0x20) ? " ESS" : "",\r\n(flag & 0x40) ? " 1TR6" : ""\r\n);\r\n}\r\nif (card->cardtype != avm_m1) {\r\nflag = ((u8 *)(ctrl->profile.manu))[5];\r\nif (flag)\r\nseq_printf(m, "%-16s%s%s%s%s\n",\r\n"linetype",\r\n(flag & 0x01) ? " point to point" : "",\r\n(flag & 0x02) ? " point to multipoint" : "",\r\n(flag & 0x08) ? " leased line without D-channel" : "",\r\n(flag & 0x04) ? " leased line with D-channel" : ""\r\n);\r\n}\r\nseq_printf(m, "%-16s %s\n", "cardname", cinfo->cardname);\r\nreturn 0;\r\n}\r\nstatic int b1ctl_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, b1ctl_proc_show, PDE_DATA(inode));\r\n}\r\navmcard_dmainfo *\r\navmcard_dma_alloc(char *name, struct pci_dev *pdev, long rsize, long ssize)\r\n{\r\navmcard_dmainfo *p;\r\nvoid *buf;\r\np = kzalloc(sizeof(avmcard_dmainfo), GFP_KERNEL);\r\nif (!p) {\r\nprintk(KERN_WARNING "%s: no memory.\n", name);\r\ngoto err;\r\n}\r\np->recvbuf.size = rsize;\r\nbuf = pci_alloc_consistent(pdev, rsize, &p->recvbuf.dmaaddr);\r\nif (!buf) {\r\nprintk(KERN_WARNING "%s: allocation of receive dma buffer failed.\n", name);\r\ngoto err_kfree;\r\n}\r\np->recvbuf.dmabuf = buf;\r\np->sendbuf.size = ssize;\r\nbuf = pci_alloc_consistent(pdev, ssize, &p->sendbuf.dmaaddr);\r\nif (!buf) {\r\nprintk(KERN_WARNING "%s: allocation of send dma buffer failed.\n", name);\r\ngoto err_free_consistent;\r\n}\r\np->sendbuf.dmabuf = buf;\r\nskb_queue_head_init(&p->send_queue);\r\nreturn p;\r\nerr_free_consistent:\r\npci_free_consistent(p->pcidev, p->recvbuf.size,\r\np->recvbuf.dmabuf, p->recvbuf.dmaaddr);\r\nerr_kfree:\r\nkfree(p);\r\nerr:\r\nreturn NULL;\r\n}\r\nvoid avmcard_dma_free(avmcard_dmainfo *p)\r\n{\r\npci_free_consistent(p->pcidev, p->recvbuf.size,\r\np->recvbuf.dmabuf, p->recvbuf.dmaaddr);\r\npci_free_consistent(p->pcidev, p->sendbuf.size,\r\np->sendbuf.dmabuf, p->sendbuf.dmaaddr);\r\nskb_queue_purge(&p->send_queue);\r\nkfree(p);\r\n}\r\nstatic int __init b1_init(void)\r\n{\r\nchar *p;\r\nchar rev[32];\r\nif ((p = strchr(revision, ':')) != NULL && p[1]) {\r\nstrlcpy(rev, p + 2, 32);\r\nif ((p = strchr(rev, '$')) != NULL && p > rev)\r\n*(p - 1) = 0;\r\n} else\r\nstrcpy(rev, "1.0");\r\nprintk(KERN_INFO "b1: revision %s\n", rev);\r\nreturn 0;\r\n}\r\nstatic void __exit b1_exit(void)\r\n{\r\n}
