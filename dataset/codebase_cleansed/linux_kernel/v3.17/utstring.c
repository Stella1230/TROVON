void acpi_ut_strlwr(char *src_string)\r\n{\r\nchar *string;\r\nACPI_FUNCTION_ENTRY();\r\nif (!src_string) {\r\nreturn;\r\n}\r\nfor (string = src_string; *string; string++) {\r\n*string = (char)ACPI_TOLOWER(*string);\r\n}\r\nreturn;\r\n}\r\nint acpi_ut_stricmp(char *string1, char *string2)\r\n{\r\nint c1;\r\nint c2;\r\ndo {\r\nc1 = tolower((int)*string1);\r\nc2 = tolower((int)*string2);\r\nstring1++;\r\nstring2++;\r\n}\r\nwhile ((c1 == c2) && (c1));\r\nreturn (c1 - c2);\r\n}\r\nvoid acpi_ut_strupr(char *src_string)\r\n{\r\nchar *string;\r\nACPI_FUNCTION_ENTRY();\r\nif (!src_string) {\r\nreturn;\r\n}\r\nfor (string = src_string; *string; string++) {\r\n*string = (char)ACPI_TOUPPER(*string);\r\n}\r\nreturn;\r\n}\r\nacpi_status acpi_ut_strtoul64(char *string, u32 base, u64 *ret_integer)\r\n{\r\nu32 this_digit = 0;\r\nu64 return_value = 0;\r\nu64 quotient;\r\nu64 dividend;\r\nu32 to_integer_op = (base == ACPI_ANY_BASE);\r\nu32 mode32 = (acpi_gbl_integer_byte_width == 4);\r\nu8 valid_digits = 0;\r\nu8 sign_of0x = 0;\r\nu8 term = 0;\r\nACPI_FUNCTION_TRACE_STR(ut_stroul64, string);\r\nswitch (base) {\r\ncase ACPI_ANY_BASE:\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nif (!string) {\r\ngoto error_exit;\r\n}\r\nwhile ((*string) && (ACPI_IS_SPACE(*string) || *string == '\t')) {\r\nstring++;\r\n}\r\nif (to_integer_op) {\r\nif ((*string == '0') && (ACPI_TOLOWER(*(string + 1)) == 'x')) {\r\nsign_of0x = 1;\r\nbase = 16;\r\nstring += 2;\r\n} else {\r\nbase = 10;\r\n}\r\n}\r\nif (!(*string) || ACPI_IS_SPACE(*string) || *string == '\t') {\r\nif (to_integer_op) {\r\ngoto error_exit;\r\n} else {\r\ngoto all_done;\r\n}\r\n}\r\ndividend = (mode32) ? ACPI_UINT32_MAX : ACPI_UINT64_MAX;\r\nwhile (*string) {\r\nif (ACPI_IS_DIGIT(*string)) {\r\nthis_digit = ((u8)*string) - '0';\r\n} else if (base == 10) {\r\nterm = 1;\r\n} else {\r\nthis_digit = (u8)ACPI_TOUPPER(*string);\r\nif (ACPI_IS_XDIGIT((char)this_digit)) {\r\nthis_digit = this_digit - 'A' + 10;\r\n} else {\r\nterm = 1;\r\n}\r\n}\r\nif (term) {\r\nif (to_integer_op) {\r\ngoto error_exit;\r\n} else {\r\nbreak;\r\n}\r\n} else if ((valid_digits == 0) && (this_digit == 0)\r\n&& !sign_of0x) {\r\nstring++;\r\ncontinue;\r\n}\r\nvalid_digits++;\r\nif (sign_of0x\r\n&& ((valid_digits > 16)\r\n|| ((valid_digits > 8) && mode32))) {\r\ngoto error_exit;\r\n}\r\n(void)acpi_ut_short_divide((dividend - (u64)this_digit),\r\nbase, &quotient, NULL);\r\nif (return_value > quotient) {\r\nif (to_integer_op) {\r\ngoto error_exit;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nreturn_value *= base;\r\nreturn_value += this_digit;\r\nstring++;\r\n}\r\nall_done:\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC, "Converted value: %8.8X%8.8X\n",\r\nACPI_FORMAT_UINT64(return_value)));\r\n*ret_integer = return_value;\r\nreturn_ACPI_STATUS(AE_OK);\r\nerror_exit:\r\nif (base == 10) {\r\nreturn_ACPI_STATUS(AE_BAD_DECIMAL_CONSTANT);\r\n} else {\r\nreturn_ACPI_STATUS(AE_BAD_HEX_CONSTANT);\r\n}\r\n}\r\nvoid acpi_ut_print_string(char *string, u16 max_length)\r\n{\r\nu32 i;\r\nif (!string) {\r\nacpi_os_printf("<\"NULL STRING PTR\">");\r\nreturn;\r\n}\r\nacpi_os_printf("\"");\r\nfor (i = 0; (i < max_length) && string[i]; i++) {\r\nswitch (string[i]) {\r\ncase 0x07:\r\nacpi_os_printf("\\a");\r\nbreak;\r\ncase 0x08:\r\nacpi_os_printf("\\b");\r\nbreak;\r\ncase 0x0C:\r\nacpi_os_printf("\\f");\r\nbreak;\r\ncase 0x0A:\r\nacpi_os_printf("\\n");\r\nbreak;\r\ncase 0x0D:\r\nacpi_os_printf("\\r");\r\nbreak;\r\ncase 0x09:\r\nacpi_os_printf("\\t");\r\nbreak;\r\ncase 0x0B:\r\nacpi_os_printf("\\v");\r\nbreak;\r\ncase '\'':\r\ncase '\"':\r\ncase '\\':\r\nacpi_os_printf("\\%c", (int)string[i]);\r\nbreak;\r\ndefault:\r\nif (ACPI_IS_PRINT(string[i])) {\r\nacpi_os_printf("%c", (int)string[i]);\r\n} else {\r\nacpi_os_printf("\\x%2.2X", (s32) string[i]);\r\n}\r\nbreak;\r\n}\r\n}\r\nacpi_os_printf("\"");\r\nif (i == max_length && string[i]) {\r\nacpi_os_printf("...");\r\n}\r\n}\r\nu8 acpi_ut_valid_acpi_char(char character, u32 position)\r\n{\r\nif (!((character >= 'A' && character <= 'Z') ||\r\n(character >= '0' && character <= '9') || (character == '_'))) {\r\nif (character == '!' && position == 3) {\r\nreturn (TRUE);\r\n}\r\nreturn (FALSE);\r\n}\r\nreturn (TRUE);\r\n}\r\nu8 acpi_ut_valid_acpi_name(char *name)\r\n{\r\nu32 i;\r\nACPI_FUNCTION_ENTRY();\r\nfor (i = 0; i < ACPI_NAME_SIZE; i++) {\r\nif (!acpi_ut_valid_acpi_char(name[i], i)) {\r\nreturn (FALSE);\r\n}\r\n}\r\nreturn (TRUE);\r\n}\r\nvoid acpi_ut_repair_name(char *name)\r\n{\r\nu32 i;\r\nu8 found_bad_char = FALSE;\r\nu32 original_name;\r\nACPI_FUNCTION_NAME(ut_repair_name);\r\nACPI_MOVE_NAME(&original_name, name);\r\nfor (i = 0; i < ACPI_NAME_SIZE; i++) {\r\nif (acpi_ut_valid_acpi_char(name[i], i)) {\r\ncontinue;\r\n}\r\nname[i] = '*';\r\nfound_bad_char = TRUE;\r\n}\r\nif (found_bad_char) {\r\nif (!acpi_gbl_enable_interpreter_slack) {\r\nACPI_WARNING((AE_INFO,\r\n"Invalid character(s) in name (0x%.8X), repaired: [%4.4s]",\r\noriginal_name, name));\r\n} else {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Invalid character(s) in name (0x%.8X), repaired: [%4.4s]",\r\noriginal_name, name));\r\n}\r\n}\r\n}\r\nvoid ut_convert_backslashes(char *pathname)\r\n{\r\nif (!pathname) {\r\nreturn;\r\n}\r\nwhile (*pathname) {\r\nif (*pathname == '\\') {\r\n*pathname = '/';\r\n}\r\npathname++;\r\n}\r\n}\r\nu8 acpi_ut_safe_strcpy(char *dest, acpi_size dest_size, char *source)\r\n{\r\nif (ACPI_STRLEN(source) >= dest_size) {\r\nreturn (TRUE);\r\n}\r\nACPI_STRCPY(dest, source);\r\nreturn (FALSE);\r\n}\r\nu8 acpi_ut_safe_strcat(char *dest, acpi_size dest_size, char *source)\r\n{\r\nif ((ACPI_STRLEN(dest) + ACPI_STRLEN(source)) >= dest_size) {\r\nreturn (TRUE);\r\n}\r\nACPI_STRCAT(dest, source);\r\nreturn (FALSE);\r\n}\r\nu8\r\nacpi_ut_safe_strncat(char *dest,\r\nacpi_size dest_size,\r\nchar *source, acpi_size max_transfer_length)\r\n{\r\nacpi_size actual_transfer_length;\r\nactual_transfer_length =\r\nACPI_MIN(max_transfer_length, ACPI_STRLEN(source));\r\nif ((ACPI_STRLEN(dest) + actual_transfer_length) >= dest_size) {\r\nreturn (TRUE);\r\n}\r\nACPI_STRNCAT(dest, source, max_transfer_length);\r\nreturn (FALSE);\r\n}
