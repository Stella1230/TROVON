static int bcm3510_writebytes (struct bcm3510_state *state, u8 reg, u8 *buf, u8 len)\r\n{\r\nu8 b[256];\r\nint err;\r\nstruct i2c_msg msg = { .addr = state->config->demod_address, .flags = 0, .buf = b, .len = len + 1 };\r\nb[0] = reg;\r\nmemcpy(&b[1],buf,len);\r\ndeb_i2c("i2c wr %02x: ",reg);\r\ndbufout(buf,len,deb_i2c);\r\ndeb_i2c("\n");\r\nif ((err = i2c_transfer (state->i2c, &msg, 1)) != 1) {\r\ndeb_info("%s: i2c write error (addr %02x, reg %02x, err == %i)\n",\r\n__func__, state->config->demod_address, reg, err);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm3510_readbytes (struct bcm3510_state *state, u8 reg, u8 *buf, u8 len)\r\n{\r\nstruct i2c_msg msg[] = {\r\n{ .addr = state->config->demod_address, .flags = 0, .buf = &reg, .len = 1 },\r\n{ .addr = state->config->demod_address, .flags = I2C_M_RD, .buf = buf, .len = len }\r\n};\r\nint err;\r\nmemset(buf,0,len);\r\nif ((err = i2c_transfer (state->i2c, msg, 2)) != 2) {\r\ndeb_info("%s: i2c read error (addr %02x, reg %02x, err == %i)\n",\r\n__func__, state->config->demod_address, reg, err);\r\nreturn -EREMOTEIO;\r\n}\r\ndeb_i2c("i2c rd %02x: ",reg);\r\ndbufout(buf,len,deb_i2c);\r\ndeb_i2c("\n");\r\nreturn 0;\r\n}\r\nstatic int bcm3510_writeB(struct bcm3510_state *state, u8 reg, bcm3510_register_value v)\r\n{\r\nreturn bcm3510_writebytes(state,reg,&v.raw,1);\r\n}\r\nstatic int bcm3510_readB(struct bcm3510_state *state, u8 reg, bcm3510_register_value *v)\r\n{\r\nreturn bcm3510_readbytes(state,reg,&v->raw,1);\r\n}\r\nstatic int bcm3510_hab_get_response(struct bcm3510_state *st, u8 *buf, int len)\r\n{\r\nbcm3510_register_value v;\r\nint ret,i;\r\nv.HABADR_a6.HABADR = 0;\r\nif ((ret = bcm3510_writeB(st,0xa6,v)) < 0)\r\nreturn ret;\r\nfor (i = 0; i < len; i++) {\r\nif ((ret = bcm3510_readB(st,0xa7,&v)) < 0)\r\nreturn ret;\r\nbuf[i] = v.HABDATA_a7;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm3510_hab_send_request(struct bcm3510_state *st, u8 *buf, int len)\r\n{\r\nbcm3510_register_value v,hab;\r\nint ret,i;\r\nunsigned long t;\r\nif ((ret = bcm3510_readB(st,0xa8,&v)) < 0)\r\nreturn ret;\r\nif (v.HABSTAT_a8.HABR) {\r\ndeb_info("HAB is running already - clearing it.\n");\r\nv.HABSTAT_a8.HABR = 0;\r\nbcm3510_writeB(st,0xa8,v);\r\n}\r\nhab.HABADR_a6.HABADR = 0;\r\nif ((ret = bcm3510_writeB(st,0xa6,hab)) < 0)\r\nreturn ret;\r\nfor (i = 0; i < len; i++) {\r\nhab.HABDATA_a7 = buf[i];\r\nif ((ret = bcm3510_writeB(st,0xa7,hab)) < 0)\r\nreturn ret;\r\n}\r\nv.raw = 0; v.HABSTAT_a8.HABR = 1; v.HABSTAT_a8.LDHABR = 1;\r\nif ((ret = bcm3510_writeB(st,0xa8,v)) < 0)\r\nreturn ret;\r\nt = jiffies + 1*HZ;\r\nwhile (time_before(jiffies, t)) {\r\ndeb_info("waiting for HAB to complete\n");\r\nmsleep(10);\r\nif ((ret = bcm3510_readB(st,0xa8,&v)) < 0)\r\nreturn ret;\r\nif (!v.HABSTAT_a8.HABR)\r\nreturn 0;\r\n}\r\ndeb_info("send_request execution timed out.\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int bcm3510_do_hab_cmd(struct bcm3510_state *st, u8 cmd, u8 msgid, u8 *obuf, u8 olen, u8 *ibuf, u8 ilen)\r\n{\r\nu8 ob[MAX_XFER_SIZE], ib[MAX_XFER_SIZE];\r\nint ret = 0;\r\nif (ilen + 2 > sizeof(ib)) {\r\ndeb_hab("do_hab_cmd: ilen=%d is too big!\n", ilen);\r\nreturn -EINVAL;\r\n}\r\nif (olen + 2 > sizeof(ob)) {\r\ndeb_hab("do_hab_cmd: olen=%d is too big!\n", olen);\r\nreturn -EINVAL;\r\n}\r\nob[0] = cmd;\r\nob[1] = msgid;\r\nmemcpy(&ob[2],obuf,olen);\r\ndeb_hab("hab snd: ");\r\ndbufout(ob,olen+2,deb_hab);\r\ndeb_hab("\n");\r\nif (mutex_lock_interruptible(&st->hab_mutex) < 0)\r\nreturn -EAGAIN;\r\nif ((ret = bcm3510_hab_send_request(st, ob, olen+2)) < 0 ||\r\n(ret = bcm3510_hab_get_response(st, ib, ilen+2)) < 0)\r\ngoto error;\r\ndeb_hab("hab get: ");\r\ndbufout(ib,ilen+2,deb_hab);\r\ndeb_hab("\n");\r\nmemcpy(ibuf,&ib[2],ilen);\r\nerror:\r\nmutex_unlock(&st->hab_mutex);\r\nreturn ret;\r\n}\r\nstatic int bcm3510_bert_reset(struct bcm3510_state *st)\r\n{\r\nbcm3510_register_value b;\r\nint ret;\r\nif ((ret = bcm3510_readB(st,0xfa,&b)) < 0)\r\nreturn ret;\r\nb.BERCTL_fa.RESYNC = 0; bcm3510_writeB(st,0xfa,b);\r\nb.BERCTL_fa.RESYNC = 1; bcm3510_writeB(st,0xfa,b);\r\nb.BERCTL_fa.RESYNC = 0; bcm3510_writeB(st,0xfa,b);\r\nb.BERCTL_fa.CNTCTL = 1; b.BERCTL_fa.BITCNT = 1; bcm3510_writeB(st,0xfa,b);\r\nreturn 0;\r\n}\r\nstatic int bcm3510_refresh_state(struct bcm3510_state *st)\r\n{\r\nif (time_after(jiffies,st->next_status_check)) {\r\nbcm3510_do_hab_cmd(st, CMD_STATUS, MSGID_STATUS1, NULL,0, (u8 *)&st->status1, sizeof(st->status1));\r\nbcm3510_do_hab_cmd(st, CMD_STATUS, MSGID_STATUS2, NULL,0, (u8 *)&st->status2, sizeof(st->status2));\r\nst->next_status_check = jiffies + (st->status_check_interval*HZ)/1000;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm3510_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct bcm3510_state* st = fe->demodulator_priv;\r\nbcm3510_refresh_state(st);\r\n*status = 0;\r\nif (st->status1.STATUS1.RECEIVER_LOCK)\r\n*status |= FE_HAS_LOCK | FE_HAS_SYNC;\r\nif (st->status1.STATUS1.FEC_LOCK)\r\n*status |= FE_HAS_VITERBI;\r\nif (st->status1.STATUS1.OUT_PLL_LOCK)\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER;\r\nif (*status & FE_HAS_LOCK)\r\nst->status_check_interval = 1500;\r\nelse\r\nst->status_check_interval = 500;\r\ndeb_info("real_status: %02x\n",*status);\r\nreturn 0;\r\n}\r\nstatic int bcm3510_read_ber(struct dvb_frontend* fe, u32* ber)\r\n{\r\nstruct bcm3510_state* st = fe->demodulator_priv;\r\nbcm3510_refresh_state(st);\r\n*ber = (st->status2.LDBER0 << 16) | (st->status2.LDBER1 << 8) | st->status2.LDBER2;\r\nreturn 0;\r\n}\r\nstatic int bcm3510_read_unc(struct dvb_frontend* fe, u32* unc)\r\n{\r\nstruct bcm3510_state* st = fe->demodulator_priv;\r\nbcm3510_refresh_state(st);\r\n*unc = (st->status2.LDUERC0 << 8) | st->status2.LDUERC1;\r\nreturn 0;\r\n}\r\nstatic int bcm3510_read_signal_strength(struct dvb_frontend* fe, u16* strength)\r\n{\r\nstruct bcm3510_state* st = fe->demodulator_priv;\r\ns32 t;\r\nbcm3510_refresh_state(st);\r\nt = st->status2.SIGNAL;\r\nif (t > 190)\r\nt = 190;\r\nif (t < 90)\r\nt = 90;\r\nt -= 90;\r\nt = t * 0xff / 100;\r\n*strength = (t << 8) | t;\r\nreturn 0;\r\n}\r\nstatic int bcm3510_read_snr(struct dvb_frontend* fe, u16* snr)\r\n{\r\nstruct bcm3510_state* st = fe->demodulator_priv;\r\nbcm3510_refresh_state(st);\r\n*snr = st->status1.SNR_EST0*1000 + ((st->status1.SNR_EST1*1000) >> 8);\r\nreturn 0;\r\n}\r\nstatic int bcm3510_tuner_cmd(struct bcm3510_state* st,u8 bc, u16 n, u8 a)\r\n{\r\nstruct bcm3510_hab_cmd_tune c;\r\nmemset(&c,0,sizeof(struct bcm3510_hab_cmd_tune));\r\nc.length = 0x10;\r\nc.clock_width = 0;\r\nc.misc = 0x10;\r\nc.TUNCTL_state = 0x40;\r\nc.ctl_dat[0].ctrl.size = BITS_8;\r\nc.ctl_dat[0].data = 0x80 | bc;\r\nc.ctl_dat[1].ctrl.size = BITS_8;\r\nc.ctl_dat[1].data = 4;\r\nc.ctl_dat[2].ctrl.size = BITS_3;\r\nc.ctl_dat[2].data = 0x20;\r\nc.ctl_dat[3].ctrl.size = BITS_3;\r\nc.ctl_dat[3].ctrl.clk_off = 1;\r\nc.ctl_dat[3].ctrl.cs0 = 1;\r\nc.ctl_dat[3].data = 0x40;\r\nc.ctl_dat[4].ctrl.size = BITS_8;\r\nc.ctl_dat[4].data = n >> 3;\r\nc.ctl_dat[5].ctrl.size = BITS_8;\r\nc.ctl_dat[5].data = ((n & 0x7) << 5) | (a >> 2);\r\nc.ctl_dat[6].ctrl.size = BITS_3;\r\nc.ctl_dat[6].data = (a << 6) & 0xdf;\r\nc.ctl_dat[7].ctrl.size = BITS_3;\r\nc.ctl_dat[7].ctrl.clk_off = 1;\r\nc.ctl_dat[7].ctrl.cs0 = 1;\r\nc.ctl_dat[7].data = 0x40;\r\nc.ctl_dat[8].ctrl.size = BITS_8;\r\nc.ctl_dat[8].data = 0x80;\r\nc.ctl_dat[9].ctrl.size = BITS_8;\r\nc.ctl_dat[9].data = 0x10;\r\nc.ctl_dat[10].ctrl.size = BITS_3;\r\nc.ctl_dat[10].data = 0x20;\r\nc.ctl_dat[11].ctrl.size = BITS_3;\r\nc.ctl_dat[11].ctrl.clk_off = 1;\r\nc.ctl_dat[11].ctrl.cs1 = 1;\r\nc.ctl_dat[11].data = 0x40;\r\nc.ctl_dat[12].ctrl.size = BITS_8;\r\nc.ctl_dat[12].data = 0x2a;\r\nc.ctl_dat[13].ctrl.size = BITS_8;\r\nc.ctl_dat[13].data = 0x8e;\r\nc.ctl_dat[14].ctrl.size = BITS_3;\r\nc.ctl_dat[14].data = 0;\r\nc.ctl_dat[15].ctrl.size = BITS_3;\r\nc.ctl_dat[15].ctrl.clk_off = 1;\r\nc.ctl_dat[15].ctrl.cs1 = 1;\r\nc.ctl_dat[15].data = 0x40;\r\nreturn bcm3510_do_hab_cmd(st,CMD_TUNE, MSGID_TUNE,(u8 *) &c,sizeof(c), NULL, 0);\r\n}\r\nstatic int bcm3510_set_freq(struct bcm3510_state* st,u32 freq)\r\n{\r\nu8 bc,a;\r\nu16 n;\r\ns32 YIntercept,Tfvco1;\r\nfreq /= 1000;\r\ndeb_info("%dkHz:",freq);\r\nif (freq <= 168000)\r\nbc = 0x1c;\r\nelse if (freq <= 378000)\r\nbc = 0x2c;\r\nelse\r\nbc = 0x30;\r\nif (freq >= 470000) {\r\nfreq -= 470001;\r\nYIntercept = 18805;\r\n} else if (freq >= 90000) {\r\nfreq -= 90001;\r\nYIntercept = 15005;\r\n} else if (freq >= 76000){\r\nfreq -= 76001;\r\nYIntercept = 14865;\r\n} else {\r\nfreq -= 54001;\r\nYIntercept = 14645;\r\n}\r\nTfvco1 = (((freq/6000)*60 + YIntercept)*4)/10;\r\nn = Tfvco1 >> 6;\r\na = Tfvco1 & 0x3f;\r\ndeb_info(" BC1_2_3_4: %x, N: %x A: %x\n", bc, n, a);\r\nif (n >= 16 && n <= 2047)\r\nreturn bcm3510_tuner_cmd(st,bc,n,a);\r\nreturn -EINVAL;\r\n}\r\nstatic int bcm3510_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct bcm3510_state* st = fe->demodulator_priv;\r\nstruct bcm3510_hab_cmd_ext_acquire cmd;\r\nstruct bcm3510_hab_cmd_bert_control bert;\r\nint ret;\r\nmemset(&cmd,0,sizeof(cmd));\r\nswitch (c->modulation) {\r\ncase QAM_256:\r\ncmd.ACQUIRE0.MODE = 0x1;\r\ncmd.ACQUIRE1.SYM_RATE = 0x1;\r\ncmd.ACQUIRE1.IF_FREQ = 0x1;\r\nbreak;\r\ncase QAM_64:\r\ncmd.ACQUIRE0.MODE = 0x2;\r\ncmd.ACQUIRE1.SYM_RATE = 0x2;\r\ncmd.ACQUIRE1.IF_FREQ = 0x1;\r\nbreak;\r\n#if 0\r\ncase QAM_256:\r\ncmd.ACQUIRE0.MODE = 0x3;\r\nbreak;\r\ncase QAM_128:\r\ncmd.ACQUIRE0.MODE = 0x4;\r\nbreak;\r\ncase QAM_64:\r\ncmd.ACQUIRE0.MODE = 0x5;\r\nbreak;\r\ncase QAM_32:\r\ncmd.ACQUIRE0.MODE = 0x6;\r\nbreak;\r\ncase QAM_16:\r\ncmd.ACQUIRE0.MODE = 0x7;\r\nbreak;\r\n#endif\r\ncase VSB_8:\r\ncmd.ACQUIRE0.MODE = 0x8;\r\ncmd.ACQUIRE1.SYM_RATE = 0x0;\r\ncmd.ACQUIRE1.IF_FREQ = 0x0;\r\nbreak;\r\ncase VSB_16:\r\ncmd.ACQUIRE0.MODE = 0x9;\r\ncmd.ACQUIRE1.SYM_RATE = 0x0;\r\ncmd.ACQUIRE1.IF_FREQ = 0x0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncmd.ACQUIRE0.OFFSET = 0;\r\ncmd.ACQUIRE0.NTSCSWEEP = 1;\r\ncmd.ACQUIRE0.FA = 1;\r\ncmd.ACQUIRE0.BW = 0;\r\nbcm3510_do_hab_cmd(st, CMD_ACQUIRE, MSGID_EXT_TUNER_ACQUIRE, (u8 *) &cmd, sizeof(cmd), NULL, 0);\r\nbert.BE = 0;\r\nbert.unused = 0;\r\nbcm3510_do_hab_cmd(st, CMD_STATE_CONTROL, MSGID_BERT_CONTROL, (u8 *) &bert, sizeof(bert), NULL, 0);\r\nbcm3510_do_hab_cmd(st, CMD_STATE_CONTROL, MSGID_BERT_SET, (u8 *) &bert, sizeof(bert), NULL, 0);\r\nbcm3510_bert_reset(st);\r\nret = bcm3510_set_freq(st, c->frequency);\r\nif (ret < 0)\r\nreturn ret;\r\nmemset(&st->status1,0,sizeof(st->status1));\r\nmemset(&st->status2,0,sizeof(st->status2));\r\nst->status_check_interval = 500;\r\nmsleep(200);\r\nreturn 0;\r\n}\r\nstatic int bcm3510_sleep(struct dvb_frontend* fe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bcm3510_get_tune_settings(struct dvb_frontend *fe, struct dvb_frontend_tune_settings *s)\r\n{\r\ns->min_delay_ms = 1000;\r\ns->step_size = 0;\r\ns->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic void bcm3510_release(struct dvb_frontend* fe)\r\n{\r\nstruct bcm3510_state* state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstatic int bcm3510_write_ram(struct bcm3510_state *st, u16 addr, const u8 *b,\r\nu16 len)\r\n{\r\nint ret = 0,i;\r\nbcm3510_register_value vH, vL,vD;\r\nvH.MADRH_a9 = addr >> 8;\r\nvL.MADRL_aa = addr;\r\nif ((ret = bcm3510_writeB(st,0xa9,vH)) < 0) return ret;\r\nif ((ret = bcm3510_writeB(st,0xaa,vL)) < 0) return ret;\r\nfor (i = 0; i < len; i++) {\r\nvD.MDATA_ab = b[i];\r\nif ((ret = bcm3510_writeB(st,0xab,vD)) < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm3510_download_firmware(struct dvb_frontend* fe)\r\n{\r\nstruct bcm3510_state* st = fe->demodulator_priv;\r\nconst struct firmware *fw;\r\nu16 addr,len;\r\nconst u8 *b;\r\nint ret,i;\r\ndeb_info("requesting firmware\n");\r\nif ((ret = st->config->request_firmware(fe, &fw, BCM3510_DEFAULT_FIRMWARE)) < 0) {\r\nerr("could not load firmware (%s): %d",BCM3510_DEFAULT_FIRMWARE,ret);\r\nreturn ret;\r\n}\r\ndeb_info("got firmware: %zd\n",fw->size);\r\nb = fw->data;\r\nfor (i = 0; i < fw->size;) {\r\naddr = le16_to_cpu( *( (u16 *)&b[i] ) );\r\nlen = le16_to_cpu( *( (u16 *)&b[i+2] ) );\r\ndeb_info("firmware chunk, addr: 0x%04x, len: 0x%04x, total length: 0x%04zx\n",addr,len,fw->size);\r\nif ((ret = bcm3510_write_ram(st,addr,&b[i+4],len)) < 0) {\r\nerr("firmware download failed: %d\n",ret);\r\nreturn ret;\r\n}\r\ni += 4 + len;\r\n}\r\nrelease_firmware(fw);\r\ndeb_info("firmware download successfully completed\n");\r\nreturn 0;\r\n}\r\nstatic int bcm3510_check_firmware_version(struct bcm3510_state *st)\r\n{\r\nstruct bcm3510_hab_cmd_get_version_info ver;\r\nbcm3510_do_hab_cmd(st,CMD_GET_VERSION_INFO,MSGID_GET_VERSION_INFO,NULL,0,(u8*)&ver,sizeof(ver));\r\ndeb_info("Version information: 0x%02x 0x%02x 0x%02x 0x%02x\n",\r\nver.microcode_version, ver.script_version, ver.config_version, ver.demod_version);\r\nif (ver.script_version == BCM3510_DEF_SCRIPT_VERSION &&\r\nver.config_version == BCM3510_DEF_CONFIG_VERSION &&\r\nver.demod_version == BCM3510_DEF_DEMOD_VERSION)\r\nreturn 0;\r\ndeb_info("version check failed\n");\r\nreturn -ENODEV;\r\n}\r\nstatic int bcm3510_reset(struct bcm3510_state *st)\r\n{\r\nint ret;\r\nunsigned long t;\r\nbcm3510_register_value v;\r\nbcm3510_readB(st,0xa0,&v); v.HCTL1_a0.RESET = 1;\r\nif ((ret = bcm3510_writeB(st,0xa0,v)) < 0)\r\nreturn ret;\r\nt = jiffies + 3*HZ;\r\nwhile (time_before(jiffies, t)) {\r\nmsleep(10);\r\nif ((ret = bcm3510_readB(st,0xa2,&v)) < 0)\r\nreturn ret;\r\nif (v.APSTAT1_a2.RESET)\r\nreturn 0;\r\n}\r\ndeb_info("reset timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int bcm3510_clear_reset(struct bcm3510_state *st)\r\n{\r\nbcm3510_register_value v;\r\nint ret;\r\nunsigned long t;\r\nv.raw = 0;\r\nif ((ret = bcm3510_writeB(st,0xa0,v)) < 0)\r\nreturn ret;\r\nt = jiffies + 3*HZ;\r\nwhile (time_before(jiffies, t)) {\r\nmsleep(10);\r\nif ((ret = bcm3510_readB(st,0xa2,&v)) < 0)\r\nreturn ret;\r\nif (!v.APSTAT1_a2.RESET)\r\nreturn 0;\r\n}\r\ndeb_info("reset clear timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int bcm3510_init_cold(struct bcm3510_state *st)\r\n{\r\nint ret;\r\nbcm3510_register_value v;\r\nif ((ret = bcm3510_readB(st,0xa2,&v)) < 0)\r\nreturn ret;\r\nif (v.APSTAT1_a2.RUN) {\r\ndeb_info("AP is already running - firmware already loaded.\n");\r\nreturn 0;\r\n}\r\ndeb_info("reset?\n");\r\nif ((ret = bcm3510_reset(st)) < 0)\r\nreturn ret;\r\ndeb_info("tristate?\n");\r\nv.TSTCTL_2e.CTL = 0;\r\nif ((ret = bcm3510_writeB(st,0x2e,v)) < 0)\r\nreturn ret;\r\ndeb_info("firmware?\n");\r\nif ((ret = bcm3510_download_firmware(&st->frontend)) < 0 ||\r\n(ret = bcm3510_clear_reset(st)) < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int bcm3510_init(struct dvb_frontend* fe)\r\n{\r\nstruct bcm3510_state* st = fe->demodulator_priv;\r\nbcm3510_register_value j;\r\nstruct bcm3510_hab_cmd_set_agc c;\r\nint ret;\r\nif ((ret = bcm3510_readB(st,0xca,&j)) < 0)\r\nreturn ret;\r\ndeb_info("JDEC: %02x\n",j.raw);\r\nswitch (j.JDEC_ca.JDEC) {\r\ncase JDEC_WAIT_AT_RAM:\r\ndeb_info("attempting to download firmware\n");\r\nif ((ret = bcm3510_init_cold(st)) < 0)\r\nreturn ret;\r\ncase JDEC_EEPROM_LOAD_WAIT:\r\ndeb_info("firmware is loaded\n");\r\nbcm3510_check_firmware_version(st);\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nmemset(&c,0,1);\r\nc.SEL = 1;\r\nbcm3510_do_hab_cmd(st,CMD_AUTO_PARAM,MSGID_SET_RF_AGC_SEL,(u8 *)&c,sizeof(c),NULL,0);\r\nreturn 0;\r\n}\r\nstruct dvb_frontend* bcm3510_attach(const struct bcm3510_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct bcm3510_state* state = NULL;\r\nint ret;\r\nbcm3510_register_value v;\r\nstate = kzalloc(sizeof(struct bcm3510_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nmemcpy(&state->frontend.ops, &bcm3510_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nmutex_init(&state->hab_mutex);\r\nif ((ret = bcm3510_readB(state,0xe0,&v)) < 0)\r\ngoto error;\r\ndeb_info("Revision: 0x%1x, Layer: 0x%1x.\n",v.REVID_e0.REV,v.REVID_e0.LAYER);\r\nif ((v.REVID_e0.REV != 0x1 && v.REVID_e0.LAYER != 0xb) &&\r\n(v.REVID_e0.REV != 0x8 && v.REVID_e0.LAYER != 0x0))\r\ngoto error;\r\ninfo("Revision: 0x%1x, Layer: 0x%1x.",v.REVID_e0.REV,v.REVID_e0.LAYER);\r\nbcm3510_reset(state);\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
