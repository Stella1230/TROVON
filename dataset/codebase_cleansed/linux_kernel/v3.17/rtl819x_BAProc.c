static void ActivateBAEntry(struct rtllib_device *ieee, struct ba_record *pBA,\r\nu16 Time)\r\n{\r\npBA->bValid = true;\r\nif (Time != 0)\r\nmod_timer(&pBA->Timer, jiffies + MSECS(Time));\r\n}\r\nstatic void DeActivateBAEntry(struct rtllib_device *ieee, struct ba_record *pBA)\r\n{\r\npBA->bValid = false;\r\ndel_timer_sync(&pBA->Timer);\r\n}\r\nstatic u8 TxTsDeleteBA(struct rtllib_device *ieee, struct tx_ts_record *pTxTs)\r\n{\r\nstruct ba_record *pAdmittedBa = &pTxTs->TxAdmittedBARecord;\r\nstruct ba_record *pPendingBa = &pTxTs->TxPendingBARecord;\r\nu8 bSendDELBA = false;\r\nif (pPendingBa->bValid) {\r\nDeActivateBAEntry(ieee, pPendingBa);\r\nbSendDELBA = true;\r\n}\r\nif (pAdmittedBa->bValid) {\r\nDeActivateBAEntry(ieee, pAdmittedBa);\r\nbSendDELBA = true;\r\n}\r\nreturn bSendDELBA;\r\n}\r\nstatic u8 RxTsDeleteBA(struct rtllib_device *ieee, struct rx_ts_record *pRxTs)\r\n{\r\nstruct ba_record *pBa = &pRxTs->RxAdmittedBARecord;\r\nu8 bSendDELBA = false;\r\nif (pBa->bValid) {\r\nDeActivateBAEntry(ieee, pBa);\r\nbSendDELBA = true;\r\n}\r\nreturn bSendDELBA;\r\n}\r\nvoid ResetBaEntry(struct ba_record *pBA)\r\n{\r\npBA->bValid = false;\r\npBA->BaParamSet.shortData = 0;\r\npBA->BaTimeoutValue = 0;\r\npBA->DialogToken = 0;\r\npBA->BaStartSeqCtrl.ShortData = 0;\r\n}\r\nstatic struct sk_buff *rtllib_ADDBA(struct rtllib_device *ieee, u8 *Dst,\r\nstruct ba_record *pBA,\r\nu16 StatusCode, u8 type)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nstruct rtllib_hdr_3addr *BAReq = NULL;\r\nu8 *tag = NULL;\r\nu16 tmp = 0;\r\nu16 len = ieee->tx_headroom + 9;\r\nRTLLIB_DEBUG(RTLLIB_DL_TRACE | RTLLIB_DL_BA, "========>%s(), frame(%d)"\r\n" sentd to: %pM, ieee->dev:%p\n", __func__,\r\ntype, Dst, ieee->dev);\r\nif (pBA == NULL) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "pBA is NULL\n");\r\nreturn NULL;\r\n}\r\nskb = dev_alloc_skb(len + sizeof(struct rtllib_hdr_3addr));\r\nif (skb == NULL) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "can't alloc skb for ADDBA_REQ\n");\r\nreturn NULL;\r\n}\r\nmemset(skb->data, 0, sizeof(struct rtllib_hdr_3addr));\r\nskb_reserve(skb, ieee->tx_headroom);\r\nBAReq = (struct rtllib_hdr_3addr *)skb_put(skb,\r\nsizeof(struct rtllib_hdr_3addr));\r\nmemcpy(BAReq->addr1, Dst, ETH_ALEN);\r\nmemcpy(BAReq->addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy(BAReq->addr3, ieee->current_network.bssid, ETH_ALEN);\r\nBAReq->frame_ctl = cpu_to_le16(RTLLIB_STYPE_MANAGE_ACT);\r\ntag = (u8 *)skb_put(skb, 9);\r\n*tag++ = ACT_CAT_BA;\r\n*tag++ = type;\r\n*tag++ = pBA->DialogToken;\r\nif (ACT_ADDBARSP == type) {\r\nRT_TRACE(COMP_DBG, "====>to send ADDBARSP\n");\r\ntmp = StatusCode;\r\nmemcpy(tag, (u8 *)&tmp, 2);\r\ntag += 2;\r\n}\r\ntmp = pBA->BaParamSet.shortData;\r\nmemcpy(tag, (u8 *)&tmp, 2);\r\ntag += 2;\r\ntmp = pBA->BaTimeoutValue;\r\nmemcpy(tag, (u8 *)&tmp, 2);\r\ntag += 2;\r\nif (ACT_ADDBAREQ == type) {\r\nmemcpy(tag, (u8 *)&(pBA->BaStartSeqCtrl), 2);\r\ntag += 2;\r\n}\r\nRTLLIB_DEBUG_DATA(RTLLIB_DL_DATA|RTLLIB_DL_BA, skb->data, skb->len);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *rtllib_DELBA(struct rtllib_device *ieee, u8 *dst,\r\nstruct ba_record *pBA,\r\nenum tr_select TxRxSelect, u16 ReasonCode)\r\n{\r\nunion delba_param_set DelbaParamSet;\r\nstruct sk_buff *skb = NULL;\r\nstruct rtllib_hdr_3addr *Delba = NULL;\r\nu8 *tag = NULL;\r\nu16 tmp = 0;\r\nu16 len = 6 + ieee->tx_headroom;\r\nif (net_ratelimit())\r\nRTLLIB_DEBUG(RTLLIB_DL_TRACE | RTLLIB_DL_BA,\r\n"========>%s(), Reason"\r\n"Code(%d) sentd to: %pM\n", __func__,\r\nReasonCode, dst);\r\nmemset(&DelbaParamSet, 0, 2);\r\nDelbaParamSet.field.Initiator = (TxRxSelect == TX_DIR) ? 1 : 0;\r\nDelbaParamSet.field.TID = pBA->BaParamSet.field.TID;\r\nskb = dev_alloc_skb(len + sizeof(struct rtllib_hdr_3addr));\r\nif (skb == NULL) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "can't alloc skb for ADDBA_REQ\n");\r\nreturn NULL;\r\n}\r\nskb_reserve(skb, ieee->tx_headroom);\r\nDelba = (struct rtllib_hdr_3addr *) skb_put(skb,\r\nsizeof(struct rtllib_hdr_3addr));\r\nmemcpy(Delba->addr1, dst, ETH_ALEN);\r\nmemcpy(Delba->addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy(Delba->addr3, ieee->current_network.bssid, ETH_ALEN);\r\nDelba->frame_ctl = cpu_to_le16(RTLLIB_STYPE_MANAGE_ACT);\r\ntag = (u8 *)skb_put(skb, 6);\r\n*tag++ = ACT_CAT_BA;\r\n*tag++ = ACT_DELBA;\r\ntmp = DelbaParamSet.shortData;\r\nmemcpy(tag, (u8 *)&tmp, 2);\r\ntag += 2;\r\ntmp = ReasonCode;\r\nmemcpy(tag, (u8 *)&tmp, 2);\r\ntag += 2;\r\nRTLLIB_DEBUG_DATA(RTLLIB_DL_DATA|RTLLIB_DL_BA, skb->data, skb->len);\r\nif (net_ratelimit())\r\nRTLLIB_DEBUG(RTLLIB_DL_TRACE | RTLLIB_DL_BA, "<=====%s()\n",\r\n__func__);\r\nreturn skb;\r\n}\r\nstatic void rtllib_send_ADDBAReq(struct rtllib_device *ieee, u8 *dst,\r\nstruct ba_record *pBA)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nskb = rtllib_ADDBA(ieee, dst, pBA, 0, ACT_ADDBAREQ);\r\nif (skb) {\r\nRT_TRACE(COMP_DBG, "====>to send ADDBAREQ!!!!!\n");\r\nsoftmac_mgmt_xmit(skb, ieee);\r\n} else {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "alloc skb error in function"\r\n" %s()\n", __func__);\r\n}\r\nreturn;\r\n}\r\nstatic void rtllib_send_ADDBARsp(struct rtllib_device *ieee, u8 *dst,\r\nstruct ba_record *pBA, u16 StatusCode)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nskb = rtllib_ADDBA(ieee, dst, pBA, StatusCode, ACT_ADDBARSP);\r\nif (skb)\r\nsoftmac_mgmt_xmit(skb, ieee);\r\nelse\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "alloc skb error in function"\r\n" %s()\n", __func__);\r\nreturn;\r\n}\r\nstatic void rtllib_send_DELBA(struct rtllib_device *ieee, u8 *dst,\r\nstruct ba_record *pBA, enum tr_select TxRxSelect,\r\nu16 ReasonCode)\r\n{\r\nstruct sk_buff *skb = NULL;\r\nskb = rtllib_DELBA(ieee, dst, pBA, TxRxSelect, ReasonCode);\r\nif (skb)\r\nsoftmac_mgmt_xmit(skb, ieee);\r\nelse\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "alloc skb error in function"\r\n" %s()\n", __func__);\r\nreturn ;\r\n}\r\nint rtllib_rx_ADDBAReq(struct rtllib_device *ieee, struct sk_buff *skb)\r\n{\r\nstruct rtllib_hdr_3addr *req = NULL;\r\nu16 rc = 0;\r\nu8 *dst = NULL, *pDialogToken = NULL, *tag = NULL;\r\nstruct ba_record *pBA = NULL;\r\nunion ba_param_set *pBaParamSet = NULL;\r\nu16 *pBaTimeoutVal = NULL;\r\nunion sequence_control *pBaStartSeqCtrl = NULL;\r\nstruct rx_ts_record *pTS = NULL;\r\nif (skb->len < sizeof(struct rtllib_hdr_3addr) + 9) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, " Invalid skb len in BAREQ(%d / "\r\n"%d)\n", (int)skb->len,\r\n(int)(sizeof(struct rtllib_hdr_3addr) + 9));\r\nreturn -1;\r\n}\r\nRTLLIB_DEBUG_DATA(RTLLIB_DL_DATA|RTLLIB_DL_BA, skb->data, skb->len);\r\nreq = (struct rtllib_hdr_3addr *) skb->data;\r\ntag = (u8 *)req;\r\ndst = (u8 *)(&req->addr2[0]);\r\ntag += sizeof(struct rtllib_hdr_3addr);\r\npDialogToken = tag + 2;\r\npBaParamSet = (union ba_param_set *)(tag + 3);\r\npBaTimeoutVal = (u16 *)(tag + 5);\r\npBaStartSeqCtrl = (union sequence_control *)(req + 7);\r\nRT_TRACE(COMP_DBG, "====>rx ADDBAREQ from : %pM\n", dst);\r\nif (ieee->current_network.qos_data.active == 0 ||\r\n(ieee->pHTInfo->bCurrentHTSupport == false) ||\r\n(ieee->pHTInfo->IOTAction & HT_IOT_ACT_REJECT_ADDBA_REQ)) {\r\nrc = ADDBA_STATUS_REFUSED;\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "Failed to reply on ADDBA_REQ as "\r\n"some capability is not ready(%d, %d)\n",\r\nieee->current_network.qos_data.active,\r\nieee->pHTInfo->bCurrentHTSupport);\r\ngoto OnADDBAReq_Fail;\r\n}\r\nif (!GetTs(ieee, (struct ts_common_info **)(&pTS), dst,\r\n(u8)(pBaParamSet->field.TID), RX_DIR, true)) {\r\nrc = ADDBA_STATUS_REFUSED;\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "can't get TS in %s()\n", __func__);\r\ngoto OnADDBAReq_Fail;\r\n}\r\npBA = &pTS->RxAdmittedBARecord;\r\nif (pBaParamSet->field.BAPolicy == BA_POLICY_DELAYED) {\r\nrc = ADDBA_STATUS_INVALID_PARAM;\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "BA Policy is not correct in "\r\n"%s()\n", __func__);\r\ngoto OnADDBAReq_Fail;\r\n}\r\nrtllib_FlushRxTsPendingPkts(ieee, pTS);\r\nDeActivateBAEntry(ieee, pBA);\r\npBA->DialogToken = *pDialogToken;\r\npBA->BaParamSet = *pBaParamSet;\r\npBA->BaTimeoutValue = *pBaTimeoutVal;\r\npBA->BaStartSeqCtrl = *pBaStartSeqCtrl;\r\nif (ieee->GetHalfNmodeSupportByAPsHandler(ieee->dev) ||\r\n(ieee->pHTInfo->IOTAction & HT_IOT_ACT_ALLOW_PEER_AGG_ONE_PKT))\r\npBA->BaParamSet.field.BufferSize = 1;\r\nelse\r\npBA->BaParamSet.field.BufferSize = 32;\r\nActivateBAEntry(ieee, pBA, 0);\r\nrtllib_send_ADDBARsp(ieee, dst, pBA, ADDBA_STATUS_SUCCESS);\r\nreturn 0;\r\nOnADDBAReq_Fail:\r\n{\r\nstruct ba_record BA;\r\nBA.BaParamSet = *pBaParamSet;\r\nBA.BaTimeoutValue = *pBaTimeoutVal;\r\nBA.DialogToken = *pDialogToken;\r\nBA.BaParamSet.field.BAPolicy = BA_POLICY_IMMEDIATE;\r\nrtllib_send_ADDBARsp(ieee, dst, &BA, rc);\r\nreturn 0;\r\n}\r\n}\r\nint rtllib_rx_ADDBARsp(struct rtllib_device *ieee, struct sk_buff *skb)\r\n{\r\nstruct rtllib_hdr_3addr *rsp = NULL;\r\nstruct ba_record *pPendingBA, *pAdmittedBA;\r\nstruct tx_ts_record *pTS = NULL;\r\nu8 *dst = NULL, *pDialogToken = NULL, *tag = NULL;\r\nu16 *pStatusCode = NULL, *pBaTimeoutVal = NULL;\r\nunion ba_param_set *pBaParamSet = NULL;\r\nu16 ReasonCode;\r\nif (skb->len < sizeof(struct rtllib_hdr_3addr) + 9) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, " Invalid skb len in BARSP(%d / "\r\n"%d)\n", (int)skb->len,\r\n(int)(sizeof(struct rtllib_hdr_3addr) + 9));\r\nreturn -1;\r\n}\r\nrsp = (struct rtllib_hdr_3addr *)skb->data;\r\ntag = (u8 *)rsp;\r\ndst = (u8 *)(&rsp->addr2[0]);\r\ntag += sizeof(struct rtllib_hdr_3addr);\r\npDialogToken = tag + 2;\r\npStatusCode = (u16 *)(tag + 3);\r\npBaParamSet = (union ba_param_set *)(tag + 5);\r\npBaTimeoutVal = (u16 *)(tag + 7);\r\nRT_TRACE(COMP_DBG, "====>rx ADDBARSP from : %pM\n", dst);\r\nif (ieee->current_network.qos_data.active == 0 ||\r\nieee->pHTInfo->bCurrentHTSupport == false ||\r\nieee->pHTInfo->bCurrentAMPDUEnable == false) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "reject to ADDBA_RSP as some capab"\r\n"ility is not ready(%d, %d, %d)\n",\r\nieee->current_network.qos_data.active,\r\nieee->pHTInfo->bCurrentHTSupport,\r\nieee->pHTInfo->bCurrentAMPDUEnable);\r\nReasonCode = DELBA_REASON_UNKNOWN_BA;\r\ngoto OnADDBARsp_Reject;\r\n}\r\nif (!GetTs(ieee, (struct ts_common_info **)(&pTS), dst,\r\n(u8)(pBaParamSet->field.TID), TX_DIR, false)) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "can't get TS in %s()\n", __func__);\r\nReasonCode = DELBA_REASON_UNKNOWN_BA;\r\ngoto OnADDBARsp_Reject;\r\n}\r\npTS->bAddBaReqInProgress = false;\r\npPendingBA = &pTS->TxPendingBARecord;\r\npAdmittedBA = &pTS->TxAdmittedBARecord;\r\nif ((pAdmittedBA->bValid == true)) {\r\nRTLLIB_DEBUG(RTLLIB_DL_BA, "OnADDBARsp(): Recv ADDBA Rsp."\r\n" Drop because already admit it!\n");\r\nreturn -1;\r\n} else if ((pPendingBA->bValid == false) ||\r\n(*pDialogToken != pPendingBA->DialogToken)) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "OnADDBARsp(): Recv ADDBA Rsp. "\r\n"BA invalid, DELBA!\n");\r\nReasonCode = DELBA_REASON_UNKNOWN_BA;\r\ngoto OnADDBARsp_Reject;\r\n} else {\r\nRTLLIB_DEBUG(RTLLIB_DL_BA, "OnADDBARsp(): Recv ADDBA Rsp. BA "\r\n"is admitted! Status code:%X\n", *pStatusCode);\r\nDeActivateBAEntry(ieee, pPendingBA);\r\n}\r\nif (*pStatusCode == ADDBA_STATUS_SUCCESS) {\r\nif (pBaParamSet->field.BAPolicy == BA_POLICY_DELAYED) {\r\npTS->bAddBaReqDelayed = true;\r\nDeActivateBAEntry(ieee, pAdmittedBA);\r\nReasonCode = DELBA_REASON_END_BA;\r\ngoto OnADDBARsp_Reject;\r\n}\r\npAdmittedBA->DialogToken = *pDialogToken;\r\npAdmittedBA->BaTimeoutValue = *pBaTimeoutVal;\r\npAdmittedBA->BaStartSeqCtrl = pPendingBA->BaStartSeqCtrl;\r\npAdmittedBA->BaParamSet = *pBaParamSet;\r\nDeActivateBAEntry(ieee, pAdmittedBA);\r\nActivateBAEntry(ieee, pAdmittedBA, *pBaTimeoutVal);\r\n} else {\r\npTS->bAddBaReqDelayed = true;\r\npTS->bDisable_AddBa = true;\r\nReasonCode = DELBA_REASON_END_BA;\r\ngoto OnADDBARsp_Reject;\r\n}\r\nreturn 0;\r\nOnADDBARsp_Reject:\r\n{\r\nstruct ba_record BA;\r\nBA.BaParamSet = *pBaParamSet;\r\nrtllib_send_DELBA(ieee, dst, &BA, TX_DIR, ReasonCode);\r\nreturn 0;\r\n}\r\n}\r\nint rtllib_rx_DELBA(struct rtllib_device *ieee, struct sk_buff *skb)\r\n{\r\nstruct rtllib_hdr_3addr *delba = NULL;\r\nunion delba_param_set *pDelBaParamSet = NULL;\r\nu16 *pReasonCode = NULL;\r\nu8 *dst = NULL;\r\nif (skb->len < sizeof(struct rtllib_hdr_3addr) + 6) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, " Invalid skb len in DELBA(%d /"\r\n" %d)\n", (int)skb->len,\r\n(int)(sizeof(struct rtllib_hdr_3addr) + 6));\r\nreturn -1;\r\n}\r\nif (ieee->current_network.qos_data.active == 0 ||\r\nieee->pHTInfo->bCurrentHTSupport == false) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "received DELBA while QOS or HT "\r\n"is not supported(%d, %d)\n",\r\nieee->current_network. qos_data.active,\r\nieee->pHTInfo->bCurrentHTSupport);\r\nreturn -1;\r\n}\r\nRTLLIB_DEBUG_DATA(RTLLIB_DL_DATA|RTLLIB_DL_BA, skb->data, skb->len);\r\ndelba = (struct rtllib_hdr_3addr *)skb->data;\r\ndst = (u8 *)(&delba->addr2[0]);\r\ndelba += sizeof(struct rtllib_hdr_3addr);\r\npDelBaParamSet = (union delba_param_set *)(delba+2);\r\npReasonCode = (u16 *)(delba+4);\r\nif (pDelBaParamSet->field.Initiator == 1) {\r\nstruct rx_ts_record *pRxTs;\r\nif (!GetTs(ieee, (struct ts_common_info **)&pRxTs, dst,\r\n(u8)pDelBaParamSet->field.TID, RX_DIR, false)) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "can't get TS for RXTS in "\r\n"%s().dst: %pM TID:%d\n", __func__, dst,\r\n(u8)pDelBaParamSet->field.TID);\r\nreturn -1;\r\n}\r\nRxTsDeleteBA(ieee, pRxTs);\r\n} else {\r\nstruct tx_ts_record *pTxTs;\r\nif (!GetTs(ieee, (struct ts_common_info **)&pTxTs, dst,\r\n(u8)pDelBaParamSet->field.TID, TX_DIR, false)) {\r\nRTLLIB_DEBUG(RTLLIB_DL_ERR, "can't get TS for TXTS in "\r\n"%s()\n", __func__);\r\nreturn -1;\r\n}\r\npTxTs->bUsingBa = false;\r\npTxTs->bAddBaReqInProgress = false;\r\npTxTs->bAddBaReqDelayed = false;\r\ndel_timer_sync(&pTxTs->TsAddBaTimer);\r\nTxTsDeleteBA(ieee, pTxTs);\r\n}\r\nreturn 0;\r\n}\r\nvoid TsInitAddBA(struct rtllib_device *ieee, struct tx_ts_record *pTS,\r\nu8 Policy, u8 bOverwritePending)\r\n{\r\nstruct ba_record *pBA = &pTS->TxPendingBARecord;\r\nif (pBA->bValid == true && bOverwritePending == false)\r\nreturn;\r\nDeActivateBAEntry(ieee, pBA);\r\npBA->DialogToken++;\r\npBA->BaParamSet.field.AMSDU_Support = 0;\r\npBA->BaParamSet.field.BAPolicy = Policy;\r\npBA->BaParamSet.field.TID =\r\npTS->TsCommonInfo.TSpec.f.TSInfo.field.ucTSID;\r\npBA->BaParamSet.field.BufferSize = 32;\r\npBA->BaTimeoutValue = 0;\r\npBA->BaStartSeqCtrl.field.SeqNum = (pTS->TxCurSeq + 3) % 4096;\r\nActivateBAEntry(ieee, pBA, BA_SETUP_TIMEOUT);\r\nrtllib_send_ADDBAReq(ieee, pTS->TsCommonInfo.Addr, pBA);\r\n}\r\nvoid TsInitDelBA(struct rtllib_device *ieee,\r\nstruct ts_common_info *pTsCommonInfo,\r\nenum tr_select TxRxSelect)\r\n{\r\nif (TxRxSelect == TX_DIR) {\r\nstruct tx_ts_record *pTxTs =\r\n(struct tx_ts_record *)pTsCommonInfo;\r\nif (TxTsDeleteBA(ieee, pTxTs))\r\nrtllib_send_DELBA(ieee, pTsCommonInfo->Addr,\r\n(pTxTs->TxAdmittedBARecord.bValid) ?\r\n(&pTxTs->TxAdmittedBARecord) :\r\n(&pTxTs->TxPendingBARecord),\r\nTxRxSelect, DELBA_REASON_END_BA);\r\n} else if (TxRxSelect == RX_DIR) {\r\nstruct rx_ts_record *pRxTs =\r\n(struct rx_ts_record *)pTsCommonInfo;\r\nif (RxTsDeleteBA(ieee, pRxTs))\r\nrtllib_send_DELBA(ieee, pTsCommonInfo->Addr,\r\n&pRxTs->RxAdmittedBARecord,\r\nTxRxSelect, DELBA_REASON_END_BA);\r\n}\r\n}\r\nvoid BaSetupTimeOut(unsigned long data)\r\n{\r\nstruct tx_ts_record *pTxTs = (struct tx_ts_record *)data;\r\npTxTs->bAddBaReqInProgress = false;\r\npTxTs->bAddBaReqDelayed = true;\r\npTxTs->TxPendingBARecord.bValid = false;\r\n}\r\nvoid TxBaInactTimeout(unsigned long data)\r\n{\r\nstruct tx_ts_record *pTxTs = (struct tx_ts_record *)data;\r\nstruct rtllib_device *ieee = container_of(pTxTs, struct rtllib_device,\r\nTxTsRecord[pTxTs->num]);\r\nTxTsDeleteBA(ieee, pTxTs);\r\nrtllib_send_DELBA(ieee, pTxTs->TsCommonInfo.Addr,\r\n&pTxTs->TxAdmittedBARecord, TX_DIR,\r\nDELBA_REASON_TIMEOUT);\r\n}\r\nvoid RxBaInactTimeout(unsigned long data)\r\n{\r\nstruct rx_ts_record *pRxTs = (struct rx_ts_record *)data;\r\nstruct rtllib_device *ieee = container_of(pRxTs, struct rtllib_device,\r\nRxTsRecord[pRxTs->num]);\r\nRxTsDeleteBA(ieee, pRxTs);\r\nrtllib_send_DELBA(ieee, pRxTs->TsCommonInfo.Addr,\r\n&pRxTs->RxAdmittedBARecord, RX_DIR,\r\nDELBA_REASON_TIMEOUT);\r\nreturn ;\r\n}
