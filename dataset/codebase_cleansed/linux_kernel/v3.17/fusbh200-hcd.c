static void dbg_hcs_params (struct fusbh200_hcd *fusbh200, char *label)\r\n{\r\nu32 params = fusbh200_readl(fusbh200, &fusbh200->caps->hcs_params);\r\nfusbh200_dbg (fusbh200,\r\n"%s hcs_params 0x%x ports=%d\n",\r\nlabel, params,\r\nHCS_N_PORTS (params)\r\n);\r\n}\r\nstatic void dbg_hcc_params (struct fusbh200_hcd *fusbh200, char *label)\r\n{\r\nu32 params = fusbh200_readl(fusbh200, &fusbh200->caps->hcc_params);\r\nfusbh200_dbg (fusbh200,\r\n"%s hcc_params %04x uframes %s%s\n",\r\nlabel,\r\nparams,\r\nHCC_PGM_FRAMELISTLEN(params) ? "256/512/1024" : "1024",\r\nHCC_CANPARK(params) ? " park" : "");\r\n}\r\nstatic void __maybe_unused\r\ndbg_qtd (const char *label, struct fusbh200_hcd *fusbh200, struct fusbh200_qtd *qtd)\r\n{\r\nfusbh200_dbg(fusbh200, "%s td %p n%08x %08x t%08x p0=%08x\n", label, qtd,\r\nhc32_to_cpup(fusbh200, &qtd->hw_next),\r\nhc32_to_cpup(fusbh200, &qtd->hw_alt_next),\r\nhc32_to_cpup(fusbh200, &qtd->hw_token),\r\nhc32_to_cpup(fusbh200, &qtd->hw_buf [0]));\r\nif (qtd->hw_buf [1])\r\nfusbh200_dbg(fusbh200, " p1=%08x p2=%08x p3=%08x p4=%08x\n",\r\nhc32_to_cpup(fusbh200, &qtd->hw_buf[1]),\r\nhc32_to_cpup(fusbh200, &qtd->hw_buf[2]),\r\nhc32_to_cpup(fusbh200, &qtd->hw_buf[3]),\r\nhc32_to_cpup(fusbh200, &qtd->hw_buf[4]));\r\n}\r\nstatic void __maybe_unused\r\ndbg_qh (const char *label, struct fusbh200_hcd *fusbh200, struct fusbh200_qh *qh)\r\n{\r\nstruct fusbh200_qh_hw *hw = qh->hw;\r\nfusbh200_dbg (fusbh200, "%s qh %p n%08x info %x %x qtd %x\n", label,\r\nqh, hw->hw_next, hw->hw_info1, hw->hw_info2, hw->hw_current);\r\ndbg_qtd("overlay", fusbh200, (struct fusbh200_qtd *) &hw->hw_qtd_next);\r\n}\r\nstatic void __maybe_unused\r\ndbg_itd (const char *label, struct fusbh200_hcd *fusbh200, struct fusbh200_itd *itd)\r\n{\r\nfusbh200_dbg (fusbh200, "%s [%d] itd %p, next %08x, urb %p\n",\r\nlabel, itd->frame, itd, hc32_to_cpu(fusbh200, itd->hw_next),\r\nitd->urb);\r\nfusbh200_dbg (fusbh200,\r\n" trans: %08x %08x %08x %08x %08x %08x %08x %08x\n",\r\nhc32_to_cpu(fusbh200, itd->hw_transaction[0]),\r\nhc32_to_cpu(fusbh200, itd->hw_transaction[1]),\r\nhc32_to_cpu(fusbh200, itd->hw_transaction[2]),\r\nhc32_to_cpu(fusbh200, itd->hw_transaction[3]),\r\nhc32_to_cpu(fusbh200, itd->hw_transaction[4]),\r\nhc32_to_cpu(fusbh200, itd->hw_transaction[5]),\r\nhc32_to_cpu(fusbh200, itd->hw_transaction[6]),\r\nhc32_to_cpu(fusbh200, itd->hw_transaction[7]));\r\nfusbh200_dbg (fusbh200,\r\n" buf: %08x %08x %08x %08x %08x %08x %08x\n",\r\nhc32_to_cpu(fusbh200, itd->hw_bufp[0]),\r\nhc32_to_cpu(fusbh200, itd->hw_bufp[1]),\r\nhc32_to_cpu(fusbh200, itd->hw_bufp[2]),\r\nhc32_to_cpu(fusbh200, itd->hw_bufp[3]),\r\nhc32_to_cpu(fusbh200, itd->hw_bufp[4]),\r\nhc32_to_cpu(fusbh200, itd->hw_bufp[5]),\r\nhc32_to_cpu(fusbh200, itd->hw_bufp[6]));\r\nfusbh200_dbg (fusbh200, " index: %d %d %d %d %d %d %d %d\n",\r\nitd->index[0], itd->index[1], itd->index[2],\r\nitd->index[3], itd->index[4], itd->index[5],\r\nitd->index[6], itd->index[7]);\r\n}\r\nstatic int __maybe_unused\r\ndbg_status_buf (char *buf, unsigned len, const char *label, u32 status)\r\n{\r\nreturn scnprintf (buf, len,\r\n"%s%sstatus %04x%s%s%s%s%s%s%s%s%s%s",\r\nlabel, label [0] ? " " : "", status,\r\n(status & STS_ASS) ? " Async" : "",\r\n(status & STS_PSS) ? " Periodic" : "",\r\n(status & STS_RECL) ? " Recl" : "",\r\n(status & STS_HALT) ? " Halt" : "",\r\n(status & STS_IAA) ? " IAA" : "",\r\n(status & STS_FATAL) ? " FATAL" : "",\r\n(status & STS_FLR) ? " FLR" : "",\r\n(status & STS_PCD) ? " PCD" : "",\r\n(status & STS_ERR) ? " ERR" : "",\r\n(status & STS_INT) ? " INT" : ""\r\n);\r\n}\r\nstatic int __maybe_unused\r\ndbg_intr_buf (char *buf, unsigned len, const char *label, u32 enable)\r\n{\r\nreturn scnprintf (buf, len,\r\n"%s%sintrenable %02x%s%s%s%s%s%s",\r\nlabel, label [0] ? " " : "", enable,\r\n(enable & STS_IAA) ? " IAA" : "",\r\n(enable & STS_FATAL) ? " FATAL" : "",\r\n(enable & STS_FLR) ? " FLR" : "",\r\n(enable & STS_PCD) ? " PCD" : "",\r\n(enable & STS_ERR) ? " ERR" : "",\r\n(enable & STS_INT) ? " INT" : ""\r\n);\r\n}\r\nstatic int\r\ndbg_command_buf (char *buf, unsigned len, const char *label, u32 command)\r\n{\r\nreturn scnprintf (buf, len,\r\n"%s%scommand %07x %s=%d ithresh=%d%s%s%s "\r\n"period=%s%s %s",\r\nlabel, label [0] ? " " : "", command,\r\n(command & CMD_PARK) ? " park" : "(park)",\r\nCMD_PARK_CNT (command),\r\n(command >> 16) & 0x3f,\r\n(command & CMD_IAAD) ? " IAAD" : "",\r\n(command & CMD_ASE) ? " Async" : "",\r\n(command & CMD_PSE) ? " Periodic" : "",\r\nfls_strings [(command >> 2) & 0x3],\r\n(command & CMD_RESET) ? " Reset" : "",\r\n(command & CMD_RUN) ? "RUN" : "HALT"\r\n);\r\n}\r\nstatic int\r\ndbg_port_buf (char *buf, unsigned len, const char *label, int port, u32 status)\r\n{\r\nchar *sig;\r\nswitch (status & (3 << 10)) {\r\ncase 0 << 10: sig = "se0"; break;\r\ncase 1 << 10: sig = "k"; break;\r\ncase 2 << 10: sig = "j"; break;\r\ndefault: sig = "?"; break;\r\n}\r\nreturn scnprintf (buf, len,\r\n"%s%sport:%d status %06x %d "\r\n"sig=%s%s%s%s%s%s%s%s",\r\nlabel, label [0] ? " " : "", port, status,\r\nstatus>>25,\r\nsig,\r\n(status & PORT_RESET) ? " RESET" : "",\r\n(status & PORT_SUSPEND) ? " SUSPEND" : "",\r\n(status & PORT_RESUME) ? " RESUME" : "",\r\n(status & PORT_PEC) ? " PEC" : "",\r\n(status & PORT_PE) ? " PE" : "",\r\n(status & PORT_CSC) ? " CSC" : "",\r\n(status & PORT_CONNECT) ? " CONNECT" : "");\r\n}\r\nstatic inline char token_mark(struct fusbh200_hcd *fusbh200, __hc32 token)\r\n{\r\n__u32 v = hc32_to_cpu(fusbh200, token);\r\nif (v & QTD_STS_ACTIVE)\r\nreturn '*';\r\nif (v & QTD_STS_HALT)\r\nreturn '-';\r\nif (!IS_SHORT_READ (v))\r\nreturn ' ';\r\nreturn '/';\r\n}\r\nstatic void qh_lines (\r\nstruct fusbh200_hcd *fusbh200,\r\nstruct fusbh200_qh *qh,\r\nchar **nextp,\r\nunsigned *sizep\r\n)\r\n{\r\nu32 scratch;\r\nu32 hw_curr;\r\nstruct fusbh200_qtd *td;\r\nunsigned temp;\r\nunsigned size = *sizep;\r\nchar *next = *nextp;\r\nchar mark;\r\n__le32 list_end = FUSBH200_LIST_END(fusbh200);\r\nstruct fusbh200_qh_hw *hw = qh->hw;\r\nif (hw->hw_qtd_next == list_end)\r\nmark = '@';\r\nelse\r\nmark = token_mark(fusbh200, hw->hw_token);\r\nif (mark == '/') {\r\nif ((hw->hw_alt_next & QTD_MASK(fusbh200))\r\n== fusbh200->async->hw->hw_alt_next)\r\nmark = '#';\r\nelse if (hw->hw_alt_next == list_end)\r\nmark = '.';\r\n}\r\nscratch = hc32_to_cpup(fusbh200, &hw->hw_info1);\r\nhw_curr = (mark == '*') ? hc32_to_cpup(fusbh200, &hw->hw_current) : 0;\r\ntemp = scnprintf (next, size,\r\n"qh/%p dev%d %cs ep%d %08x %08x (%08x%c %s nak%d)",\r\nqh, scratch & 0x007f,\r\nspeed_char (scratch),\r\n(scratch >> 8) & 0x000f,\r\nscratch, hc32_to_cpup(fusbh200, &hw->hw_info2),\r\nhc32_to_cpup(fusbh200, &hw->hw_token), mark,\r\n(cpu_to_hc32(fusbh200, QTD_TOGGLE) & hw->hw_token)\r\n? "data1" : "data0",\r\n(hc32_to_cpup(fusbh200, &hw->hw_alt_next) >> 1) & 0x0f);\r\nsize -= temp;\r\nnext += temp;\r\nlist_for_each_entry(td, &qh->qtd_list, qtd_list) {\r\nscratch = hc32_to_cpup(fusbh200, &td->hw_token);\r\nmark = ' ';\r\nif (hw_curr == td->qtd_dma)\r\nmark = '*';\r\nelse if (hw->hw_qtd_next == cpu_to_hc32(fusbh200, td->qtd_dma))\r\nmark = '+';\r\nelse if (QTD_LENGTH (scratch)) {\r\nif (td->hw_alt_next == fusbh200->async->hw->hw_alt_next)\r\nmark = '#';\r\nelse if (td->hw_alt_next != list_end)\r\nmark = '/';\r\n}\r\ntemp = snprintf (next, size,\r\n"\n\t%p%c%s len=%d %08x urb %p",\r\ntd, mark, ({ char *tmp;\r\nswitch ((scratch>>8)&0x03) {\r\ncase 0: tmp = "out"; break;\r\ncase 1: tmp = "in"; break;\r\ncase 2: tmp = "setup"; break;\r\ndefault: tmp = "?"; break;\r\n} tmp;}),\r\n(scratch >> 16) & 0x7fff,\r\nscratch,\r\ntd->urb);\r\nif (size < temp)\r\ntemp = size;\r\nsize -= temp;\r\nnext += temp;\r\nif (temp == size)\r\ngoto done;\r\n}\r\ntemp = snprintf (next, size, "\n");\r\nif (size < temp)\r\ntemp = size;\r\nsize -= temp;\r\nnext += temp;\r\ndone:\r\n*sizep = size;\r\n*nextp = next;\r\n}\r\nstatic ssize_t fill_async_buffer(struct debug_buffer *buf)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct fusbh200_hcd *fusbh200;\r\nunsigned long flags;\r\nunsigned temp, size;\r\nchar *next;\r\nstruct fusbh200_qh *qh;\r\nhcd = bus_to_hcd(buf->bus);\r\nfusbh200 = hcd_to_fusbh200 (hcd);\r\nnext = buf->output_buf;\r\nsize = buf->alloc_size;\r\n*next = 0;\r\nspin_lock_irqsave (&fusbh200->lock, flags);\r\nfor (qh = fusbh200->async->qh_next.qh; size > 0 && qh; qh = qh->qh_next.qh)\r\nqh_lines (fusbh200, qh, &next, &size);\r\nif (fusbh200->async_unlink && size > 0) {\r\ntemp = scnprintf(next, size, "\nunlink =\n");\r\nsize -= temp;\r\nnext += temp;\r\nfor (qh = fusbh200->async_unlink; size > 0 && qh;\r\nqh = qh->unlink_next)\r\nqh_lines (fusbh200, qh, &next, &size);\r\n}\r\nspin_unlock_irqrestore (&fusbh200->lock, flags);\r\nreturn strlen(buf->output_buf);\r\n}\r\nstatic ssize_t fill_periodic_buffer(struct debug_buffer *buf)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct fusbh200_hcd *fusbh200;\r\nunsigned long flags;\r\nunion fusbh200_shadow p, *seen;\r\nunsigned temp, size, seen_count;\r\nchar *next;\r\nunsigned i;\r\n__hc32 tag;\r\nif (!(seen = kmalloc (DBG_SCHED_LIMIT * sizeof *seen, GFP_ATOMIC)))\r\nreturn 0;\r\nseen_count = 0;\r\nhcd = bus_to_hcd(buf->bus);\r\nfusbh200 = hcd_to_fusbh200 (hcd);\r\nnext = buf->output_buf;\r\nsize = buf->alloc_size;\r\ntemp = scnprintf (next, size, "size = %d\n", fusbh200->periodic_size);\r\nsize -= temp;\r\nnext += temp;\r\nspin_lock_irqsave (&fusbh200->lock, flags);\r\nfor (i = 0; i < fusbh200->periodic_size; i++) {\r\np = fusbh200->pshadow [i];\r\nif (likely (!p.ptr))\r\ncontinue;\r\ntag = Q_NEXT_TYPE(fusbh200, fusbh200->periodic [i]);\r\ntemp = scnprintf (next, size, "%4d: ", i);\r\nsize -= temp;\r\nnext += temp;\r\ndo {\r\nstruct fusbh200_qh_hw *hw;\r\nswitch (hc32_to_cpu(fusbh200, tag)) {\r\ncase Q_TYPE_QH:\r\nhw = p.qh->hw;\r\ntemp = scnprintf (next, size, " qh%d-%04x/%p",\r\np.qh->period,\r\nhc32_to_cpup(fusbh200,\r\n&hw->hw_info2)\r\n& (QH_CMASK | QH_SMASK),\r\np.qh);\r\nsize -= temp;\r\nnext += temp;\r\nfor (temp = 0; temp < seen_count; temp++) {\r\nif (seen [temp].ptr != p.ptr)\r\ncontinue;\r\nif (p.qh->qh_next.ptr) {\r\ntemp = scnprintf (next, size,\r\n" ...");\r\nsize -= temp;\r\nnext += temp;\r\n}\r\nbreak;\r\n}\r\nif (temp == seen_count) {\r\nu32 scratch = hc32_to_cpup(fusbh200,\r\n&hw->hw_info1);\r\nstruct fusbh200_qtd *qtd;\r\nchar *type = "";\r\ntemp = 0;\r\nlist_for_each_entry (qtd,\r\n&p.qh->qtd_list,\r\nqtd_list) {\r\ntemp++;\r\nswitch (0x03 & (hc32_to_cpu(\r\nfusbh200,\r\nqtd->hw_token) >> 8)) {\r\ncase 0: type = "out"; continue;\r\ncase 1: type = "in"; continue;\r\n}\r\n}\r\ntemp = scnprintf (next, size,\r\n" (%c%d ep%d%s "\r\n"[%d/%d] q%d p%d)",\r\nspeed_char (scratch),\r\nscratch & 0x007f,\r\n(scratch >> 8) & 0x000f, type,\r\np.qh->usecs, p.qh->c_usecs,\r\ntemp,\r\n0x7ff & (scratch >> 16));\r\nif (seen_count < DBG_SCHED_LIMIT)\r\nseen [seen_count++].qh = p.qh;\r\n} else\r\ntemp = 0;\r\ntag = Q_NEXT_TYPE(fusbh200, hw->hw_next);\r\np = p.qh->qh_next;\r\nbreak;\r\ncase Q_TYPE_FSTN:\r\ntemp = scnprintf (next, size,\r\n" fstn-%8x/%p", p.fstn->hw_prev,\r\np.fstn);\r\ntag = Q_NEXT_TYPE(fusbh200, p.fstn->hw_next);\r\np = p.fstn->fstn_next;\r\nbreak;\r\ncase Q_TYPE_ITD:\r\ntemp = scnprintf (next, size,\r\n" itd/%p", p.itd);\r\ntag = Q_NEXT_TYPE(fusbh200, p.itd->hw_next);\r\np = p.itd->itd_next;\r\nbreak;\r\n}\r\nsize -= temp;\r\nnext += temp;\r\n} while (p.ptr);\r\ntemp = scnprintf (next, size, "\n");\r\nsize -= temp;\r\nnext += temp;\r\n}\r\nspin_unlock_irqrestore (&fusbh200->lock, flags);\r\nkfree (seen);\r\nreturn buf->alloc_size - size;\r\n}\r\nstatic const char *rh_state_string(struct fusbh200_hcd *fusbh200)\r\n{\r\nswitch (fusbh200->rh_state) {\r\ncase FUSBH200_RH_HALTED:\r\nreturn "halted";\r\ncase FUSBH200_RH_SUSPENDED:\r\nreturn "suspended";\r\ncase FUSBH200_RH_RUNNING:\r\nreturn "running";\r\ncase FUSBH200_RH_STOPPING:\r\nreturn "stopping";\r\n}\r\nreturn "?";\r\n}\r\nstatic ssize_t fill_registers_buffer(struct debug_buffer *buf)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct fusbh200_hcd *fusbh200;\r\nunsigned long flags;\r\nunsigned temp, size, i;\r\nchar *next, scratch [80];\r\nstatic char fmt [] = "%*s\n";\r\nstatic char label [] = "";\r\nhcd = bus_to_hcd(buf->bus);\r\nfusbh200 = hcd_to_fusbh200 (hcd);\r\nnext = buf->output_buf;\r\nsize = buf->alloc_size;\r\nspin_lock_irqsave (&fusbh200->lock, flags);\r\nif (!HCD_HW_ACCESSIBLE(hcd)) {\r\nsize = scnprintf (next, size,\r\n"bus %s, device %s\n"\r\n"%s\n"\r\n"SUSPENDED (no register access)\n",\r\nhcd->self.controller->bus->name,\r\ndev_name(hcd->self.controller),\r\nhcd->product_desc);\r\ngoto done;\r\n}\r\ni = HC_VERSION(fusbh200, fusbh200_readl(fusbh200, &fusbh200->caps->hc_capbase));\r\ntemp = scnprintf (next, size,\r\n"bus %s, device %s\n"\r\n"%s\n"\r\n"EHCI %x.%02x, rh state %s\n",\r\nhcd->self.controller->bus->name,\r\ndev_name(hcd->self.controller),\r\nhcd->product_desc,\r\ni >> 8, i & 0x0ff, rh_state_string(fusbh200));\r\nsize -= temp;\r\nnext += temp;\r\ni = fusbh200_readl(fusbh200, &fusbh200->caps->hcs_params);\r\ntemp = scnprintf (next, size, "structural params 0x%08x\n", i);\r\nsize -= temp;\r\nnext += temp;\r\ni = fusbh200_readl(fusbh200, &fusbh200->caps->hcc_params);\r\ntemp = scnprintf (next, size, "capability params 0x%08x\n", i);\r\nsize -= temp;\r\nnext += temp;\r\ntemp = dbg_status_buf (scratch, sizeof scratch, label,\r\nfusbh200_readl(fusbh200, &fusbh200->regs->status));\r\ntemp = scnprintf (next, size, fmt, temp, scratch);\r\nsize -= temp;\r\nnext += temp;\r\ntemp = dbg_command_buf (scratch, sizeof scratch, label,\r\nfusbh200_readl(fusbh200, &fusbh200->regs->command));\r\ntemp = scnprintf (next, size, fmt, temp, scratch);\r\nsize -= temp;\r\nnext += temp;\r\ntemp = dbg_intr_buf (scratch, sizeof scratch, label,\r\nfusbh200_readl(fusbh200, &fusbh200->regs->intr_enable));\r\ntemp = scnprintf (next, size, fmt, temp, scratch);\r\nsize -= temp;\r\nnext += temp;\r\ntemp = scnprintf (next, size, "uframe %04x\n",\r\nfusbh200_read_frame_index(fusbh200));\r\nsize -= temp;\r\nnext += temp;\r\nif (fusbh200->async_unlink) {\r\ntemp = scnprintf(next, size, "async unlink qh %p\n",\r\nfusbh200->async_unlink);\r\nsize -= temp;\r\nnext += temp;\r\n}\r\ntemp = scnprintf (next, size,\r\n"irq normal %ld err %ld iaa %ld (lost %ld)\n",\r\nfusbh200->stats.normal, fusbh200->stats.error, fusbh200->stats.iaa,\r\nfusbh200->stats.lost_iaa);\r\nsize -= temp;\r\nnext += temp;\r\ntemp = scnprintf (next, size, "complete %ld unlink %ld\n",\r\nfusbh200->stats.complete, fusbh200->stats.unlink);\r\nsize -= temp;\r\nnext += temp;\r\ndone:\r\nspin_unlock_irqrestore (&fusbh200->lock, flags);\r\nreturn buf->alloc_size - size;\r\n}\r\nstatic struct debug_buffer *alloc_buffer(struct usb_bus *bus,\r\nssize_t (*fill_func)(struct debug_buffer *))\r\n{\r\nstruct debug_buffer *buf;\r\nbuf = kzalloc(sizeof(struct debug_buffer), GFP_KERNEL);\r\nif (buf) {\r\nbuf->bus = bus;\r\nbuf->fill_func = fill_func;\r\nmutex_init(&buf->mutex);\r\nbuf->alloc_size = PAGE_SIZE;\r\n}\r\nreturn buf;\r\n}\r\nstatic int fill_buffer(struct debug_buffer *buf)\r\n{\r\nint ret = 0;\r\nif (!buf->output_buf)\r\nbuf->output_buf = vmalloc(buf->alloc_size);\r\nif (!buf->output_buf) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = buf->fill_func(buf);\r\nif (ret >= 0) {\r\nbuf->count = ret;\r\nret = 0;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t debug_output(struct file *file, char __user *user_buf,\r\nsize_t len, loff_t *offset)\r\n{\r\nstruct debug_buffer *buf = file->private_data;\r\nint ret = 0;\r\nmutex_lock(&buf->mutex);\r\nif (buf->count == 0) {\r\nret = fill_buffer(buf);\r\nif (ret != 0) {\r\nmutex_unlock(&buf->mutex);\r\ngoto out;\r\n}\r\n}\r\nmutex_unlock(&buf->mutex);\r\nret = simple_read_from_buffer(user_buf, len, offset,\r\nbuf->output_buf, buf->count);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int debug_close(struct inode *inode, struct file *file)\r\n{\r\nstruct debug_buffer *buf = file->private_data;\r\nif (buf) {\r\nvfree(buf->output_buf);\r\nkfree(buf);\r\n}\r\nreturn 0;\r\n}\r\nstatic int debug_async_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = alloc_buffer(inode->i_private, fill_async_buffer);\r\nreturn file->private_data ? 0 : -ENOMEM;\r\n}\r\nstatic int debug_periodic_open(struct inode *inode, struct file *file)\r\n{\r\nstruct debug_buffer *buf;\r\nbuf = alloc_buffer(inode->i_private, fill_periodic_buffer);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf->alloc_size = (sizeof(void *) == 4 ? 6 : 8)*PAGE_SIZE;\r\nfile->private_data = buf;\r\nreturn 0;\r\n}\r\nstatic int debug_registers_open(struct inode *inode, struct file *file)\r\n{\r\nfile->private_data = alloc_buffer(inode->i_private,\r\nfill_registers_buffer);\r\nreturn file->private_data ? 0 : -ENOMEM;\r\n}\r\nstatic inline void create_debug_files (struct fusbh200_hcd *fusbh200)\r\n{\r\nstruct usb_bus *bus = &fusbh200_to_hcd(fusbh200)->self;\r\nfusbh200->debug_dir = debugfs_create_dir(bus->bus_name, fusbh200_debug_root);\r\nif (!fusbh200->debug_dir)\r\nreturn;\r\nif (!debugfs_create_file("async", S_IRUGO, fusbh200->debug_dir, bus,\r\n&debug_async_fops))\r\ngoto file_error;\r\nif (!debugfs_create_file("periodic", S_IRUGO, fusbh200->debug_dir, bus,\r\n&debug_periodic_fops))\r\ngoto file_error;\r\nif (!debugfs_create_file("registers", S_IRUGO, fusbh200->debug_dir, bus,\r\n&debug_registers_fops))\r\ngoto file_error;\r\nreturn;\r\nfile_error:\r\ndebugfs_remove_recursive(fusbh200->debug_dir);\r\n}\r\nstatic inline void remove_debug_files (struct fusbh200_hcd *fusbh200)\r\n{\r\ndebugfs_remove_recursive(fusbh200->debug_dir);\r\n}\r\nstatic int handshake (struct fusbh200_hcd *fusbh200, void __iomem *ptr,\r\nu32 mask, u32 done, int usec)\r\n{\r\nu32 result;\r\ndo {\r\nresult = fusbh200_readl(fusbh200, ptr);\r\nif (result == ~(u32)0)\r\nreturn -ENODEV;\r\nresult &= mask;\r\nif (result == done)\r\nreturn 0;\r\nudelay (1);\r\nusec--;\r\n} while (usec > 0);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int fusbh200_halt (struct fusbh200_hcd *fusbh200)\r\n{\r\nu32 temp;\r\nspin_lock_irq(&fusbh200->lock);\r\nfusbh200_writel(fusbh200, 0, &fusbh200->regs->intr_enable);\r\nfusbh200->command &= ~CMD_RUN;\r\ntemp = fusbh200_readl(fusbh200, &fusbh200->regs->command);\r\ntemp &= ~(CMD_RUN | CMD_IAAD);\r\nfusbh200_writel(fusbh200, temp, &fusbh200->regs->command);\r\nspin_unlock_irq(&fusbh200->lock);\r\nsynchronize_irq(fusbh200_to_hcd(fusbh200)->irq);\r\nreturn handshake(fusbh200, &fusbh200->regs->status,\r\nSTS_HALT, STS_HALT, 16 * 125);\r\n}\r\nstatic int fusbh200_reset (struct fusbh200_hcd *fusbh200)\r\n{\r\nint retval;\r\nu32 command = fusbh200_readl(fusbh200, &fusbh200->regs->command);\r\nif (fusbh200->debug && !dbgp_reset_prep(fusbh200_to_hcd(fusbh200)))\r\nfusbh200->debug = NULL;\r\ncommand |= CMD_RESET;\r\ndbg_cmd (fusbh200, "reset", command);\r\nfusbh200_writel(fusbh200, command, &fusbh200->regs->command);\r\nfusbh200->rh_state = FUSBH200_RH_HALTED;\r\nfusbh200->next_statechange = jiffies;\r\nretval = handshake (fusbh200, &fusbh200->regs->command,\r\nCMD_RESET, 0, 250 * 1000);\r\nif (retval)\r\nreturn retval;\r\nif (fusbh200->debug)\r\ndbgp_external_startup(fusbh200_to_hcd(fusbh200));\r\nfusbh200->port_c_suspend = fusbh200->suspended_ports =\r\nfusbh200->resuming_ports = 0;\r\nreturn retval;\r\n}\r\nstatic void fusbh200_quiesce (struct fusbh200_hcd *fusbh200)\r\n{\r\nu32 temp;\r\nif (fusbh200->rh_state != FUSBH200_RH_RUNNING)\r\nreturn;\r\ntemp = (fusbh200->command << 10) & (STS_ASS | STS_PSS);\r\nhandshake(fusbh200, &fusbh200->regs->status, STS_ASS | STS_PSS, temp, 16 * 125);\r\nspin_lock_irq(&fusbh200->lock);\r\nfusbh200->command &= ~(CMD_ASE | CMD_PSE);\r\nfusbh200_writel(fusbh200, fusbh200->command, &fusbh200->regs->command);\r\nspin_unlock_irq(&fusbh200->lock);\r\nhandshake(fusbh200, &fusbh200->regs->status, STS_ASS | STS_PSS, 0, 16 * 125);\r\n}\r\nstatic void fusbh200_set_command_bit(struct fusbh200_hcd *fusbh200, u32 bit)\r\n{\r\nfusbh200->command |= bit;\r\nfusbh200_writel(fusbh200, fusbh200->command, &fusbh200->regs->command);\r\nfusbh200_readl(fusbh200, &fusbh200->regs->command);\r\n}\r\nstatic void fusbh200_clear_command_bit(struct fusbh200_hcd *fusbh200, u32 bit)\r\n{\r\nfusbh200->command &= ~bit;\r\nfusbh200_writel(fusbh200, fusbh200->command, &fusbh200->regs->command);\r\nfusbh200_readl(fusbh200, &fusbh200->regs->command);\r\n}\r\nstatic void fusbh200_enable_event(struct fusbh200_hcd *fusbh200, unsigned event,\r\nbool resched)\r\n{\r\nktime_t *timeout = &fusbh200->hr_timeouts[event];\r\nif (resched)\r\n*timeout = ktime_add(ktime_get(),\r\nktime_set(0, event_delays_ns[event]));\r\nfusbh200->enabled_hrtimer_events |= (1 << event);\r\nif (event < fusbh200->next_hrtimer_event) {\r\nfusbh200->next_hrtimer_event = event;\r\nhrtimer_start_range_ns(&fusbh200->hrtimer, *timeout,\r\nNSEC_PER_MSEC, HRTIMER_MODE_ABS);\r\n}\r\n}\r\nstatic void fusbh200_poll_ASS(struct fusbh200_hcd *fusbh200)\r\n{\r\nunsigned actual, want;\r\nif (fusbh200->rh_state != FUSBH200_RH_RUNNING)\r\nreturn;\r\nwant = (fusbh200->command & CMD_ASE) ? STS_ASS : 0;\r\nactual = fusbh200_readl(fusbh200, &fusbh200->regs->status) & STS_ASS;\r\nif (want != actual) {\r\nif (fusbh200->ASS_poll_count++ < 20) {\r\nfusbh200_enable_event(fusbh200, FUSBH200_HRTIMER_POLL_ASS, true);\r\nreturn;\r\n}\r\nfusbh200_dbg(fusbh200, "Waited too long for the async schedule status (%x/%x), giving up\n",\r\nwant, actual);\r\n}\r\nfusbh200->ASS_poll_count = 0;\r\nif (want == 0) {\r\nif (fusbh200->async_count > 0)\r\nfusbh200_set_command_bit(fusbh200, CMD_ASE);\r\n} else {\r\nif (fusbh200->async_count == 0) {\r\nfusbh200_enable_event(fusbh200, FUSBH200_HRTIMER_DISABLE_ASYNC,\r\ntrue);\r\n}\r\n}\r\n}\r\nstatic void fusbh200_disable_ASE(struct fusbh200_hcd *fusbh200)\r\n{\r\nfusbh200_clear_command_bit(fusbh200, CMD_ASE);\r\n}\r\nstatic void fusbh200_poll_PSS(struct fusbh200_hcd *fusbh200)\r\n{\r\nunsigned actual, want;\r\nif (fusbh200->rh_state != FUSBH200_RH_RUNNING)\r\nreturn;\r\nwant = (fusbh200->command & CMD_PSE) ? STS_PSS : 0;\r\nactual = fusbh200_readl(fusbh200, &fusbh200->regs->status) & STS_PSS;\r\nif (want != actual) {\r\nif (fusbh200->PSS_poll_count++ < 20) {\r\nfusbh200_enable_event(fusbh200, FUSBH200_HRTIMER_POLL_PSS, true);\r\nreturn;\r\n}\r\nfusbh200_dbg(fusbh200, "Waited too long for the periodic schedule status (%x/%x), giving up\n",\r\nwant, actual);\r\n}\r\nfusbh200->PSS_poll_count = 0;\r\nif (want == 0) {\r\nif (fusbh200->periodic_count > 0)\r\nfusbh200_set_command_bit(fusbh200, CMD_PSE);\r\n} else {\r\nif (fusbh200->periodic_count == 0) {\r\nfusbh200_enable_event(fusbh200, FUSBH200_HRTIMER_DISABLE_PERIODIC,\r\ntrue);\r\n}\r\n}\r\n}\r\nstatic void fusbh200_disable_PSE(struct fusbh200_hcd *fusbh200)\r\n{\r\nfusbh200_clear_command_bit(fusbh200, CMD_PSE);\r\n}\r\nstatic void fusbh200_handle_controller_death(struct fusbh200_hcd *fusbh200)\r\n{\r\nif (!(fusbh200_readl(fusbh200, &fusbh200->regs->status) & STS_HALT)) {\r\nif (fusbh200->died_poll_count++ < 5) {\r\nfusbh200_enable_event(fusbh200, FUSBH200_HRTIMER_POLL_DEAD, true);\r\nreturn;\r\n}\r\nfusbh200_warn(fusbh200, "Waited too long for the controller to stop, giving up\n");\r\n}\r\nfusbh200->rh_state = FUSBH200_RH_HALTED;\r\nfusbh200_writel(fusbh200, 0, &fusbh200->regs->intr_enable);\r\nfusbh200_work(fusbh200);\r\nend_unlink_async(fusbh200);\r\n}\r\nstatic void fusbh200_handle_intr_unlinks(struct fusbh200_hcd *fusbh200)\r\n{\r\nbool stopped = (fusbh200->rh_state < FUSBH200_RH_RUNNING);\r\nfusbh200->intr_unlinking = true;\r\nwhile (fusbh200->intr_unlink) {\r\nstruct fusbh200_qh *qh = fusbh200->intr_unlink;\r\nif (!stopped && qh->unlink_cycle == fusbh200->intr_unlink_cycle)\r\nbreak;\r\nfusbh200->intr_unlink = qh->unlink_next;\r\nqh->unlink_next = NULL;\r\nend_unlink_intr(fusbh200, qh);\r\n}\r\nif (fusbh200->intr_unlink) {\r\nfusbh200_enable_event(fusbh200, FUSBH200_HRTIMER_UNLINK_INTR, true);\r\n++fusbh200->intr_unlink_cycle;\r\n}\r\nfusbh200->intr_unlinking = false;\r\n}\r\nstatic void start_free_itds(struct fusbh200_hcd *fusbh200)\r\n{\r\nif (!(fusbh200->enabled_hrtimer_events & BIT(FUSBH200_HRTIMER_FREE_ITDS))) {\r\nfusbh200->last_itd_to_free = list_entry(\r\nfusbh200->cached_itd_list.prev,\r\nstruct fusbh200_itd, itd_list);\r\nfusbh200_enable_event(fusbh200, FUSBH200_HRTIMER_FREE_ITDS, true);\r\n}\r\n}\r\nstatic void end_free_itds(struct fusbh200_hcd *fusbh200)\r\n{\r\nstruct fusbh200_itd *itd, *n;\r\nif (fusbh200->rh_state < FUSBH200_RH_RUNNING) {\r\nfusbh200->last_itd_to_free = NULL;\r\n}\r\nlist_for_each_entry_safe(itd, n, &fusbh200->cached_itd_list, itd_list) {\r\nlist_del(&itd->itd_list);\r\ndma_pool_free(fusbh200->itd_pool, itd, itd->itd_dma);\r\nif (itd == fusbh200->last_itd_to_free)\r\nbreak;\r\n}\r\nif (!list_empty(&fusbh200->cached_itd_list))\r\nstart_free_itds(fusbh200);\r\n}\r\nstatic void fusbh200_iaa_watchdog(struct fusbh200_hcd *fusbh200)\r\n{\r\nif (fusbh200->rh_state != FUSBH200_RH_RUNNING)\r\nreturn;\r\nif (fusbh200->async_iaa) {\r\nu32 cmd, status;\r\ncmd = fusbh200_readl(fusbh200, &fusbh200->regs->command);\r\nstatus = fusbh200_readl(fusbh200, &fusbh200->regs->status);\r\nif ((status & STS_IAA) || !(cmd & CMD_IAAD)) {\r\nCOUNT(fusbh200->stats.lost_iaa);\r\nfusbh200_writel(fusbh200, STS_IAA, &fusbh200->regs->status);\r\n}\r\nfusbh200_dbg(fusbh200, "IAA watchdog: status %x cmd %x\n",\r\nstatus, cmd);\r\nend_unlink_async(fusbh200);\r\n}\r\n}\r\nstatic void turn_on_io_watchdog(struct fusbh200_hcd *fusbh200)\r\n{\r\nif (fusbh200->rh_state != FUSBH200_RH_RUNNING ||\r\n(fusbh200->enabled_hrtimer_events &\r\nBIT(FUSBH200_HRTIMER_IO_WATCHDOG)))\r\nreturn;\r\nif (fusbh200->isoc_count > 0 || (fusbh200->need_io_watchdog &&\r\nfusbh200->async_count + fusbh200->intr_count > 0))\r\nfusbh200_enable_event(fusbh200, FUSBH200_HRTIMER_IO_WATCHDOG, true);\r\n}\r\nstatic enum hrtimer_restart fusbh200_hrtimer_func(struct hrtimer *t)\r\n{\r\nstruct fusbh200_hcd *fusbh200 = container_of(t, struct fusbh200_hcd, hrtimer);\r\nktime_t now;\r\nunsigned long events;\r\nunsigned long flags;\r\nunsigned e;\r\nspin_lock_irqsave(&fusbh200->lock, flags);\r\nevents = fusbh200->enabled_hrtimer_events;\r\nfusbh200->enabled_hrtimer_events = 0;\r\nfusbh200->next_hrtimer_event = FUSBH200_HRTIMER_NO_EVENT;\r\nnow = ktime_get();\r\nfor_each_set_bit(e, &events, FUSBH200_HRTIMER_NUM_EVENTS) {\r\nif (now.tv64 >= fusbh200->hr_timeouts[e].tv64)\r\nevent_handlers[e](fusbh200);\r\nelse\r\nfusbh200_enable_event(fusbh200, e, false);\r\n}\r\nspin_unlock_irqrestore(&fusbh200->lock, flags);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic int check_reset_complete (\r\nstruct fusbh200_hcd *fusbh200,\r\nint index,\r\nu32 __iomem *status_reg,\r\nint port_status\r\n) {\r\nif (!(port_status & PORT_CONNECT))\r\nreturn port_status;\r\nif (!(port_status & PORT_PE)) {\r\nfusbh200_dbg (fusbh200,\r\n"Failed to enable port %d on root hub TT\n",\r\nindex+1);\r\nreturn port_status;\r\n} else {\r\nfusbh200_dbg(fusbh200, "port %d reset complete, port enabled\n",\r\nindex + 1);\r\n}\r\nreturn port_status;\r\n}\r\nstatic int\r\nfusbh200_hub_status_data (struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct fusbh200_hcd *fusbh200 = hcd_to_fusbh200 (hcd);\r\nu32 temp, status;\r\nu32 mask;\r\nint retval = 1;\r\nunsigned long flags;\r\nbuf [0] = 0;\r\nstatus = fusbh200->resuming_ports;\r\nmask = PORT_CSC | PORT_PEC;\r\nspin_lock_irqsave (&fusbh200->lock, flags);\r\ntemp = fusbh200_readl(fusbh200, &fusbh200->regs->port_status);\r\nif ((temp & mask) != 0 || test_bit(0, &fusbh200->port_c_suspend)\r\n|| (fusbh200->reset_done[0] && time_after_eq(\r\njiffies, fusbh200->reset_done[0]))) {\r\nbuf [0] |= 1 << 1;\r\nstatus = STS_PCD;\r\n}\r\nspin_unlock_irqrestore (&fusbh200->lock, flags);\r\nreturn status ? retval : 0;\r\n}\r\nstatic void\r\nfusbh200_hub_descriptor (\r\nstruct fusbh200_hcd *fusbh200,\r\nstruct usb_hub_descriptor *desc\r\n) {\r\nint ports = HCS_N_PORTS (fusbh200->hcs_params);\r\nu16 temp;\r\ndesc->bDescriptorType = 0x29;\r\ndesc->bPwrOn2PwrGood = 10;\r\ndesc->bHubContrCurrent = 0;\r\ndesc->bNbrPorts = ports;\r\ntemp = 1 + (ports / 8);\r\ndesc->bDescLength = 7 + 2 * temp;\r\nmemset(&desc->u.hs.DeviceRemovable[0], 0, temp);\r\nmemset(&desc->u.hs.DeviceRemovable[temp], 0xff, temp);\r\ntemp = 0x0008;\r\ntemp |= 0x0002;\r\ndesc->wHubCharacteristics = cpu_to_le16(temp);\r\n}\r\nstatic int fusbh200_hub_control (\r\nstruct usb_hcd *hcd,\r\nu16 typeReq,\r\nu16 wValue,\r\nu16 wIndex,\r\nchar *buf,\r\nu16 wLength\r\n) {\r\nstruct fusbh200_hcd *fusbh200 = hcd_to_fusbh200 (hcd);\r\nint ports = HCS_N_PORTS (fusbh200->hcs_params);\r\nu32 __iomem *status_reg = &fusbh200->regs->port_status;\r\nu32 temp, temp1, status;\r\nunsigned long flags;\r\nint retval = 0;\r\nunsigned selector;\r\nspin_lock_irqsave (&fusbh200->lock, flags);\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_LOCAL_POWER:\r\ncase C_HUB_OVER_CURRENT:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase ClearPortFeature:\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\ntemp = fusbh200_readl(fusbh200, status_reg);\r\ntemp &= ~PORT_RWC_BITS;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\nfusbh200_writel(fusbh200, temp & ~PORT_PE, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\nfusbh200_writel(fusbh200, temp | PORT_PEC, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\nif (temp & PORT_RESET)\r\ngoto error;\r\nif (!(temp & PORT_SUSPEND))\r\nbreak;\r\nif ((temp & PORT_PE) == 0)\r\ngoto error;\r\nfusbh200_writel(fusbh200, temp | PORT_RESUME, status_reg);\r\nfusbh200->reset_done[wIndex] = jiffies\r\n+ msecs_to_jiffies(20);\r\nbreak;\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\nclear_bit(wIndex, &fusbh200->port_c_suspend);\r\nbreak;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\nfusbh200_writel(fusbh200, temp | PORT_CSC, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\nfusbh200_writel(fusbh200, temp | BMISR_OVC, &fusbh200->regs->bmisr);\r\nbreak;\r\ncase USB_PORT_FEAT_C_RESET:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nfusbh200_readl(fusbh200, &fusbh200->regs->command);\r\nbreak;\r\ncase GetHubDescriptor:\r\nfusbh200_hub_descriptor (fusbh200, (struct usb_hub_descriptor *)\r\nbuf);\r\nbreak;\r\ncase GetHubStatus:\r\nmemset (buf, 0, 4);\r\nbreak;\r\ncase GetPortStatus:\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\nstatus = 0;\r\ntemp = fusbh200_readl(fusbh200, status_reg);\r\nif (temp & PORT_CSC)\r\nstatus |= USB_PORT_STAT_C_CONNECTION << 16;\r\nif (temp & PORT_PEC)\r\nstatus |= USB_PORT_STAT_C_ENABLE << 16;\r\ntemp1 = fusbh200_readl(fusbh200, &fusbh200->regs->bmisr);\r\nif (temp1 & BMISR_OVC)\r\nstatus |= USB_PORT_STAT_C_OVERCURRENT << 16;\r\nif (temp & PORT_RESUME) {\r\nif (!fusbh200->reset_done[wIndex]) {\r\nfusbh200->reset_done[wIndex] = jiffies\r\n+ msecs_to_jiffies(20);\r\nmod_timer(&fusbh200_to_hcd(fusbh200)->rh_timer,\r\nfusbh200->reset_done[wIndex]);\r\n}\r\nelse if (time_after_eq(jiffies,\r\nfusbh200->reset_done[wIndex])) {\r\nclear_bit(wIndex, &fusbh200->suspended_ports);\r\nset_bit(wIndex, &fusbh200->port_c_suspend);\r\nfusbh200->reset_done[wIndex] = 0;\r\ntemp = fusbh200_readl(fusbh200, status_reg);\r\nfusbh200_writel(fusbh200,\r\ntemp & ~(PORT_RWC_BITS | PORT_RESUME),\r\nstatus_reg);\r\nclear_bit(wIndex, &fusbh200->resuming_ports);\r\nretval = handshake(fusbh200, status_reg,\r\nPORT_RESUME, 0, 2000 );\r\nif (retval != 0) {\r\nfusbh200_err(fusbh200,\r\n"port %d resume error %d\n",\r\nwIndex + 1, retval);\r\ngoto error;\r\n}\r\ntemp &= ~(PORT_SUSPEND|PORT_RESUME|(3<<10));\r\n}\r\n}\r\nif ((temp & PORT_RESET)\r\n&& time_after_eq(jiffies,\r\nfusbh200->reset_done[wIndex])) {\r\nstatus |= USB_PORT_STAT_C_RESET << 16;\r\nfusbh200->reset_done [wIndex] = 0;\r\nclear_bit(wIndex, &fusbh200->resuming_ports);\r\nfusbh200_writel(fusbh200, temp & ~(PORT_RWC_BITS | PORT_RESET),\r\nstatus_reg);\r\nretval = handshake(fusbh200, status_reg,\r\nPORT_RESET, 0, 1000);\r\nif (retval != 0) {\r\nfusbh200_err (fusbh200, "port %d reset error %d\n",\r\nwIndex + 1, retval);\r\ngoto error;\r\n}\r\ntemp = check_reset_complete (fusbh200, wIndex, status_reg,\r\nfusbh200_readl(fusbh200, status_reg));\r\n}\r\nif (!(temp & (PORT_RESUME|PORT_RESET))) {\r\nfusbh200->reset_done[wIndex] = 0;\r\nclear_bit(wIndex, &fusbh200->resuming_ports);\r\n}\r\nif ((temp & PORT_CONNECT) &&\r\ntest_bit(wIndex, &fusbh200->companion_ports)) {\r\ntemp &= ~PORT_RWC_BITS;\r\nfusbh200_writel(fusbh200, temp, status_reg);\r\nfusbh200_dbg(fusbh200, "port %d --> companion\n", wIndex + 1);\r\ntemp = fusbh200_readl(fusbh200, status_reg);\r\n}\r\nif (temp & PORT_CONNECT) {\r\nstatus |= USB_PORT_STAT_CONNECTION;\r\nstatus |= fusbh200_port_speed(fusbh200, temp);\r\n}\r\nif (temp & PORT_PE)\r\nstatus |= USB_PORT_STAT_ENABLE;\r\nif (temp & (PORT_SUSPEND|PORT_RESUME)) {\r\nstatus |= USB_PORT_STAT_SUSPEND;\r\n} else if (test_bit(wIndex, &fusbh200->suspended_ports)) {\r\nclear_bit(wIndex, &fusbh200->suspended_ports);\r\nclear_bit(wIndex, &fusbh200->resuming_ports);\r\nfusbh200->reset_done[wIndex] = 0;\r\nif (temp & PORT_PE)\r\nset_bit(wIndex, &fusbh200->port_c_suspend);\r\n}\r\ntemp1 = fusbh200_readl(fusbh200, &fusbh200->regs->bmisr);\r\nif (temp1 & BMISR_OVC)\r\nstatus |= USB_PORT_STAT_OVERCURRENT;\r\nif (temp & PORT_RESET)\r\nstatus |= USB_PORT_STAT_RESET;\r\nif (test_bit(wIndex, &fusbh200->port_c_suspend))\r\nstatus |= USB_PORT_STAT_C_SUSPEND << 16;\r\nif (status & ~0xffff)\r\ndbg_port(fusbh200, "GetStatus", wIndex + 1, temp);\r\nput_unaligned_le32(status, buf);\r\nbreak;\r\ncase SetHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_LOCAL_POWER:\r\ncase C_HUB_OVER_CURRENT:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase SetPortFeature:\r\nselector = wIndex >> 8;\r\nwIndex &= 0xff;\r\nif (!wIndex || wIndex > ports)\r\ngoto error;\r\nwIndex--;\r\ntemp = fusbh200_readl(fusbh200, status_reg);\r\ntemp &= ~PORT_RWC_BITS;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\nif ((temp & PORT_PE) == 0\r\n|| (temp & PORT_RESET) != 0)\r\ngoto error;\r\nfusbh200_writel(fusbh200, temp | PORT_SUSPEND, status_reg);\r\nset_bit(wIndex, &fusbh200->suspended_ports);\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\nif (temp & PORT_RESUME)\r\ngoto error;\r\nfusbh200_dbg(fusbh200, "port %d reset\n", wIndex + 1);\r\ntemp |= PORT_RESET;\r\ntemp &= ~PORT_PE;\r\nfusbh200->reset_done [wIndex] = jiffies\r\n+ msecs_to_jiffies (50);\r\nfusbh200_writel(fusbh200, temp, status_reg);\r\nbreak;\r\ncase USB_PORT_FEAT_TEST:\r\nif (!selector || selector > 5)\r\ngoto error;\r\nspin_unlock_irqrestore(&fusbh200->lock, flags);\r\nfusbh200_quiesce(fusbh200);\r\nspin_lock_irqsave(&fusbh200->lock, flags);\r\ntemp = fusbh200_readl(fusbh200, status_reg) & ~PORT_RWC_BITS;\r\nif (temp & PORT_PE)\r\nfusbh200_writel(fusbh200, temp | PORT_SUSPEND,\r\nstatus_reg);\r\nspin_unlock_irqrestore(&fusbh200->lock, flags);\r\nfusbh200_halt(fusbh200);\r\nspin_lock_irqsave(&fusbh200->lock, flags);\r\ntemp = fusbh200_readl(fusbh200, status_reg);\r\ntemp |= selector << 16;\r\nfusbh200_writel(fusbh200, temp, status_reg);\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nfusbh200_readl(fusbh200, &fusbh200->regs->command);\r\nbreak;\r\ndefault:\r\nerror:\r\nretval = -EPIPE;\r\n}\r\nspin_unlock_irqrestore (&fusbh200->lock, flags);\r\nreturn retval;\r\n}\r\nstatic void __maybe_unused fusbh200_relinquish_port(struct usb_hcd *hcd,\r\nint portnum)\r\n{\r\nreturn;\r\n}\r\nstatic int __maybe_unused fusbh200_port_handed_over(struct usb_hcd *hcd,\r\nint portnum)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void fusbh200_qtd_init(struct fusbh200_hcd *fusbh200, struct fusbh200_qtd *qtd,\r\ndma_addr_t dma)\r\n{\r\nmemset (qtd, 0, sizeof *qtd);\r\nqtd->qtd_dma = dma;\r\nqtd->hw_token = cpu_to_hc32(fusbh200, QTD_STS_HALT);\r\nqtd->hw_next = FUSBH200_LIST_END(fusbh200);\r\nqtd->hw_alt_next = FUSBH200_LIST_END(fusbh200);\r\nINIT_LIST_HEAD (&qtd->qtd_list);\r\n}\r\nstatic struct fusbh200_qtd *fusbh200_qtd_alloc (struct fusbh200_hcd *fusbh200, gfp_t flags)\r\n{\r\nstruct fusbh200_qtd *qtd;\r\ndma_addr_t dma;\r\nqtd = dma_pool_alloc (fusbh200->qtd_pool, flags, &dma);\r\nif (qtd != NULL) {\r\nfusbh200_qtd_init(fusbh200, qtd, dma);\r\n}\r\nreturn qtd;\r\n}\r\nstatic inline void fusbh200_qtd_free (struct fusbh200_hcd *fusbh200, struct fusbh200_qtd *qtd)\r\n{\r\ndma_pool_free (fusbh200->qtd_pool, qtd, qtd->qtd_dma);\r\n}\r\nstatic void qh_destroy(struct fusbh200_hcd *fusbh200, struct fusbh200_qh *qh)\r\n{\r\nif (!list_empty (&qh->qtd_list) || qh->qh_next.ptr) {\r\nfusbh200_dbg (fusbh200, "unused qh not empty!\n");\r\nBUG ();\r\n}\r\nif (qh->dummy)\r\nfusbh200_qtd_free (fusbh200, qh->dummy);\r\ndma_pool_free(fusbh200->qh_pool, qh->hw, qh->qh_dma);\r\nkfree(qh);\r\n}\r\nstatic struct fusbh200_qh *fusbh200_qh_alloc (struct fusbh200_hcd *fusbh200, gfp_t flags)\r\n{\r\nstruct fusbh200_qh *qh;\r\ndma_addr_t dma;\r\nqh = kzalloc(sizeof *qh, GFP_ATOMIC);\r\nif (!qh)\r\ngoto done;\r\nqh->hw = (struct fusbh200_qh_hw *)\r\ndma_pool_alloc(fusbh200->qh_pool, flags, &dma);\r\nif (!qh->hw)\r\ngoto fail;\r\nmemset(qh->hw, 0, sizeof *qh->hw);\r\nqh->qh_dma = dma;\r\nINIT_LIST_HEAD (&qh->qtd_list);\r\nqh->dummy = fusbh200_qtd_alloc (fusbh200, flags);\r\nif (qh->dummy == NULL) {\r\nfusbh200_dbg (fusbh200, "no dummy td\n");\r\ngoto fail1;\r\n}\r\ndone:\r\nreturn qh;\r\nfail1:\r\ndma_pool_free(fusbh200->qh_pool, qh->hw, qh->qh_dma);\r\nfail:\r\nkfree(qh);\r\nreturn NULL;\r\n}\r\nstatic void fusbh200_mem_cleanup (struct fusbh200_hcd *fusbh200)\r\n{\r\nif (fusbh200->async)\r\nqh_destroy(fusbh200, fusbh200->async);\r\nfusbh200->async = NULL;\r\nif (fusbh200->dummy)\r\nqh_destroy(fusbh200, fusbh200->dummy);\r\nfusbh200->dummy = NULL;\r\nif (fusbh200->qtd_pool)\r\ndma_pool_destroy (fusbh200->qtd_pool);\r\nfusbh200->qtd_pool = NULL;\r\nif (fusbh200->qh_pool) {\r\ndma_pool_destroy (fusbh200->qh_pool);\r\nfusbh200->qh_pool = NULL;\r\n}\r\nif (fusbh200->itd_pool)\r\ndma_pool_destroy (fusbh200->itd_pool);\r\nfusbh200->itd_pool = NULL;\r\nif (fusbh200->periodic)\r\ndma_free_coherent (fusbh200_to_hcd(fusbh200)->self.controller,\r\nfusbh200->periodic_size * sizeof (u32),\r\nfusbh200->periodic, fusbh200->periodic_dma);\r\nfusbh200->periodic = NULL;\r\nkfree(fusbh200->pshadow);\r\nfusbh200->pshadow = NULL;\r\n}\r\nstatic int fusbh200_mem_init (struct fusbh200_hcd *fusbh200, gfp_t flags)\r\n{\r\nint i;\r\nfusbh200->qtd_pool = dma_pool_create ("fusbh200_qtd",\r\nfusbh200_to_hcd(fusbh200)->self.controller,\r\nsizeof (struct fusbh200_qtd),\r\n32 ,\r\n4096 );\r\nif (!fusbh200->qtd_pool) {\r\ngoto fail;\r\n}\r\nfusbh200->qh_pool = dma_pool_create ("fusbh200_qh",\r\nfusbh200_to_hcd(fusbh200)->self.controller,\r\nsizeof(struct fusbh200_qh_hw),\r\n32 ,\r\n4096 );\r\nif (!fusbh200->qh_pool) {\r\ngoto fail;\r\n}\r\nfusbh200->async = fusbh200_qh_alloc (fusbh200, flags);\r\nif (!fusbh200->async) {\r\ngoto fail;\r\n}\r\nfusbh200->itd_pool = dma_pool_create ("fusbh200_itd",\r\nfusbh200_to_hcd(fusbh200)->self.controller,\r\nsizeof (struct fusbh200_itd),\r\n64 ,\r\n4096 );\r\nif (!fusbh200->itd_pool) {\r\ngoto fail;\r\n}\r\nfusbh200->periodic = (__le32 *)\r\ndma_alloc_coherent (fusbh200_to_hcd(fusbh200)->self.controller,\r\nfusbh200->periodic_size * sizeof(__le32),\r\n&fusbh200->periodic_dma, 0);\r\nif (fusbh200->periodic == NULL) {\r\ngoto fail;\r\n}\r\nfor (i = 0; i < fusbh200->periodic_size; i++)\r\nfusbh200->periodic[i] = FUSBH200_LIST_END(fusbh200);\r\nfusbh200->pshadow = kcalloc(fusbh200->periodic_size, sizeof(void *), flags);\r\nif (fusbh200->pshadow != NULL)\r\nreturn 0;\r\nfail:\r\nfusbh200_dbg (fusbh200, "couldn't init memory\n");\r\nfusbh200_mem_cleanup (fusbh200);\r\nreturn -ENOMEM;\r\n}\r\nstatic int\r\nqtd_fill(struct fusbh200_hcd *fusbh200, struct fusbh200_qtd *qtd, dma_addr_t buf,\r\nsize_t len, int token, int maxpacket)\r\n{\r\nint i, count;\r\nu64 addr = buf;\r\nqtd->hw_buf[0] = cpu_to_hc32(fusbh200, (u32)addr);\r\nqtd->hw_buf_hi[0] = cpu_to_hc32(fusbh200, (u32)(addr >> 32));\r\ncount = 0x1000 - (buf & 0x0fff);\r\nif (likely (len < count))\r\ncount = len;\r\nelse {\r\nbuf += 0x1000;\r\nbuf &= ~0x0fff;\r\nfor (i = 1; count < len && i < 5; i++) {\r\naddr = buf;\r\nqtd->hw_buf[i] = cpu_to_hc32(fusbh200, (u32)addr);\r\nqtd->hw_buf_hi[i] = cpu_to_hc32(fusbh200,\r\n(u32)(addr >> 32));\r\nbuf += 0x1000;\r\nif ((count + 0x1000) < len)\r\ncount += 0x1000;\r\nelse\r\ncount = len;\r\n}\r\nif (count != len)\r\ncount -= (count % maxpacket);\r\n}\r\nqtd->hw_token = cpu_to_hc32(fusbh200, (count << 16) | token);\r\nqtd->length = count;\r\nreturn count;\r\n}\r\nstatic inline void\r\nqh_update (struct fusbh200_hcd *fusbh200, struct fusbh200_qh *qh, struct fusbh200_qtd *qtd)\r\n{\r\nstruct fusbh200_qh_hw *hw = qh->hw;\r\nBUG_ON(qh->qh_state != QH_STATE_IDLE);\r\nhw->hw_qtd_next = QTD_NEXT(fusbh200, qtd->qtd_dma);\r\nhw->hw_alt_next = FUSBH200_LIST_END(fusbh200);\r\nif (!(hw->hw_info1 & cpu_to_hc32(fusbh200, QH_TOGGLE_CTL))) {\r\nunsigned is_out, epnum;\r\nis_out = qh->is_out;\r\nepnum = (hc32_to_cpup(fusbh200, &hw->hw_info1) >> 8) & 0x0f;\r\nif (unlikely (!usb_gettoggle (qh->dev, epnum, is_out))) {\r\nhw->hw_token &= ~cpu_to_hc32(fusbh200, QTD_TOGGLE);\r\nusb_settoggle (qh->dev, epnum, is_out, 1);\r\n}\r\n}\r\nhw->hw_token &= cpu_to_hc32(fusbh200, QTD_TOGGLE | QTD_STS_PING);\r\n}\r\nstatic void\r\nqh_refresh (struct fusbh200_hcd *fusbh200, struct fusbh200_qh *qh)\r\n{\r\nstruct fusbh200_qtd *qtd;\r\nif (list_empty (&qh->qtd_list))\r\nqtd = qh->dummy;\r\nelse {\r\nqtd = list_entry (qh->qtd_list.next,\r\nstruct fusbh200_qtd, qtd_list);\r\nif (cpu_to_hc32(fusbh200, qtd->qtd_dma) == qh->hw->hw_current) {\r\nqh->hw->hw_qtd_next = qtd->hw_next;\r\nqtd = NULL;\r\n}\r\n}\r\nif (qtd)\r\nqh_update (fusbh200, qh, qtd);\r\n}\r\nstatic void fusbh200_clear_tt_buffer_complete(struct usb_hcd *hcd,\r\nstruct usb_host_endpoint *ep)\r\n{\r\nstruct fusbh200_hcd *fusbh200 = hcd_to_fusbh200(hcd);\r\nstruct fusbh200_qh *qh = ep->hcpriv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&fusbh200->lock, flags);\r\nqh->clearing_tt = 0;\r\nif (qh->qh_state == QH_STATE_IDLE && !list_empty(&qh->qtd_list)\r\n&& fusbh200->rh_state == FUSBH200_RH_RUNNING)\r\nqh_link_async(fusbh200, qh);\r\nspin_unlock_irqrestore(&fusbh200->lock, flags);\r\n}\r\nstatic void fusbh200_clear_tt_buffer(struct fusbh200_hcd *fusbh200, struct fusbh200_qh *qh,\r\nstruct urb *urb, u32 token)\r\n{\r\nif (urb->dev->tt && !usb_pipeint(urb->pipe) && !qh->clearing_tt) {\r\nstruct usb_device *tt = urb->dev->tt->hub;\r\ndev_dbg(&tt->dev,\r\n"clear tt buffer port %d, a%d ep%d t%08x\n",\r\nurb->dev->ttport, urb->dev->devnum,\r\nusb_pipeendpoint(urb->pipe), token);\r\nif (urb->dev->tt->hub !=\r\nfusbh200_to_hcd(fusbh200)->self.root_hub) {\r\nif (usb_hub_clear_tt_buffer(urb) == 0)\r\nqh->clearing_tt = 1;\r\n}\r\n}\r\n}\r\nstatic int qtd_copy_status (\r\nstruct fusbh200_hcd *fusbh200,\r\nstruct urb *urb,\r\nsize_t length,\r\nu32 token\r\n)\r\n{\r\nint status = -EINPROGRESS;\r\nif (likely (QTD_PID (token) != 2))\r\nurb->actual_length += length - QTD_LENGTH (token);\r\nif (unlikely(urb->unlinked))\r\nreturn status;\r\nif (unlikely (IS_SHORT_READ (token)))\r\nstatus = -EREMOTEIO;\r\nif (token & QTD_STS_HALT) {\r\nif (token & QTD_STS_BABBLE) {\r\nstatus = -EOVERFLOW;\r\n} else if (QTD_CERR(token)) {\r\nstatus = -EPIPE;\r\n} else if (token & QTD_STS_MMF) {\r\nstatus = -EPROTO;\r\n} else if (token & QTD_STS_DBE) {\r\nstatus = (QTD_PID (token) == 1)\r\n? -ENOSR\r\n: -ECOMM;\r\n} else if (token & QTD_STS_XACT) {\r\nfusbh200_dbg(fusbh200, "devpath %s ep%d%s 3strikes\n",\r\nurb->dev->devpath,\r\nusb_pipeendpoint(urb->pipe),\r\nusb_pipein(urb->pipe) ? "in" : "out");\r\nstatus = -EPROTO;\r\n} else {\r\nstatus = -EPROTO;\r\n}\r\nfusbh200_dbg(fusbh200,\r\n"dev%d ep%d%s qtd token %08x --> status %d\n",\r\nusb_pipedevice (urb->pipe),\r\nusb_pipeendpoint (urb->pipe),\r\nusb_pipein (urb->pipe) ? "in" : "out",\r\ntoken, status);\r\n}\r\nreturn status;\r\n}\r\nstatic void\r\nfusbh200_urb_done(struct fusbh200_hcd *fusbh200, struct urb *urb, int status)\r\n__releases(fusbh200->lock)\r\n__acquires(fusbh200->lock)\r\n{\r\nif (likely (urb->hcpriv != NULL)) {\r\nstruct fusbh200_qh *qh = (struct fusbh200_qh *) urb->hcpriv;\r\nif ((qh->hw->hw_info2 & cpu_to_hc32(fusbh200, QH_SMASK)) != 0) {\r\nfusbh200_to_hcd(fusbh200)->self.bandwidth_int_reqs--;\r\n}\r\n}\r\nif (unlikely(urb->unlinked)) {\r\nCOUNT(fusbh200->stats.unlink);\r\n} else {\r\nif (status == -EINPROGRESS || status == -EREMOTEIO)\r\nstatus = 0;\r\nCOUNT(fusbh200->stats.complete);\r\n}\r\n#ifdef FUSBH200_URB_TRACE\r\nfusbh200_dbg (fusbh200,\r\n"%s %s urb %p ep%d%s status %d len %d/%d\n",\r\n__func__, urb->dev->devpath, urb,\r\nusb_pipeendpoint (urb->pipe),\r\nusb_pipein (urb->pipe) ? "in" : "out",\r\nstatus,\r\nurb->actual_length, urb->transfer_buffer_length);\r\n#endif\r\nusb_hcd_unlink_urb_from_ep(fusbh200_to_hcd(fusbh200), urb);\r\nspin_unlock (&fusbh200->lock);\r\nusb_hcd_giveback_urb(fusbh200_to_hcd(fusbh200), urb, status);\r\nspin_lock (&fusbh200->lock);\r\n}\r\nstatic unsigned\r\nqh_completions (struct fusbh200_hcd *fusbh200, struct fusbh200_qh *qh)\r\n{\r\nstruct fusbh200_qtd *last, *end = qh->dummy;\r\nstruct list_head *entry, *tmp;\r\nint last_status;\r\nint stopped;\r\nunsigned count = 0;\r\nu8 state;\r\nstruct fusbh200_qh_hw *hw = qh->hw;\r\nif (unlikely (list_empty (&qh->qtd_list)))\r\nreturn count;\r\nstate = qh->qh_state;\r\nqh->qh_state = QH_STATE_COMPLETING;\r\nstopped = (state == QH_STATE_IDLE);\r\nrescan:\r\nlast = NULL;\r\nlast_status = -EINPROGRESS;\r\nqh->needs_rescan = 0;\r\nlist_for_each_safe (entry, tmp, &qh->qtd_list) {\r\nstruct fusbh200_qtd *qtd;\r\nstruct urb *urb;\r\nu32 token = 0;\r\nqtd = list_entry (entry, struct fusbh200_qtd, qtd_list);\r\nurb = qtd->urb;\r\nif (last) {\r\nif (likely (last->urb != urb)) {\r\nfusbh200_urb_done(fusbh200, last->urb, last_status);\r\ncount++;\r\nlast_status = -EINPROGRESS;\r\n}\r\nfusbh200_qtd_free (fusbh200, last);\r\nlast = NULL;\r\n}\r\nif (qtd == end)\r\nbreak;\r\nrmb ();\r\ntoken = hc32_to_cpu(fusbh200, qtd->hw_token);\r\nretry_xacterr:\r\nif ((token & QTD_STS_ACTIVE) == 0) {\r\nif (token & QTD_STS_DBE)\r\nfusbh200_dbg(fusbh200,\r\n"detected DataBufferErr for urb %p ep%d%s len %d, qtd %p [qh %p]\n",\r\nurb,\r\nusb_endpoint_num(&urb->ep->desc),\r\nusb_endpoint_dir_in(&urb->ep->desc) ? "in" : "out",\r\nurb->transfer_buffer_length,\r\nqtd,\r\nqh);\r\nif ((token & QTD_STS_HALT) != 0) {\r\nif ((token & QTD_STS_XACT) &&\r\nQTD_CERR(token) == 0 &&\r\n++qh->xacterrs < QH_XACTERR_MAX &&\r\n!urb->unlinked) {\r\nfusbh200_dbg(fusbh200,\r\n"detected XactErr len %zu/%zu retry %d\n",\r\nqtd->length - QTD_LENGTH(token), qtd->length, qh->xacterrs);\r\ntoken &= ~QTD_STS_HALT;\r\ntoken |= QTD_STS_ACTIVE |\r\n(FUSBH200_TUNE_CERR << 10);\r\nqtd->hw_token = cpu_to_hc32(fusbh200,\r\ntoken);\r\nwmb();\r\nhw->hw_token = cpu_to_hc32(fusbh200,\r\ntoken);\r\ngoto retry_xacterr;\r\n}\r\nstopped = 1;\r\n} else if (IS_SHORT_READ (token)\r\n&& !(qtd->hw_alt_next\r\n& FUSBH200_LIST_END(fusbh200))) {\r\nstopped = 1;\r\n}\r\n} else if (likely (!stopped\r\n&& fusbh200->rh_state >= FUSBH200_RH_RUNNING)) {\r\nbreak;\r\n} else {\r\nstopped = 1;\r\nif (fusbh200->rh_state < FUSBH200_RH_RUNNING)\r\nlast_status = -ESHUTDOWN;\r\nelse if (last_status == -EINPROGRESS && !urb->unlinked)\r\ncontinue;\r\nif (state == QH_STATE_IDLE\r\n&& cpu_to_hc32(fusbh200, qtd->qtd_dma)\r\n== hw->hw_current) {\r\ntoken = hc32_to_cpu(fusbh200, hw->hw_token);\r\nfusbh200_clear_tt_buffer(fusbh200, qh, urb, token);\r\n}\r\n}\r\nif (last_status == -EINPROGRESS) {\r\nlast_status = qtd_copy_status(fusbh200, urb,\r\nqtd->length, token);\r\nif (last_status == -EREMOTEIO\r\n&& (qtd->hw_alt_next\r\n& FUSBH200_LIST_END(fusbh200)))\r\nlast_status = -EINPROGRESS;\r\nif (unlikely(last_status != -EINPROGRESS &&\r\nlast_status != -EREMOTEIO)) {\r\nif (last_status != -EPIPE)\r\nfusbh200_clear_tt_buffer(fusbh200, qh, urb,\r\ntoken);\r\n}\r\n}\r\nif (stopped && qtd->qtd_list.prev != &qh->qtd_list) {\r\nlast = list_entry (qtd->qtd_list.prev,\r\nstruct fusbh200_qtd, qtd_list);\r\nlast->hw_next = qtd->hw_next;\r\n}\r\nlist_del (&qtd->qtd_list);\r\nlast = qtd;\r\nqh->xacterrs = 0;\r\n}\r\nif (likely (last != NULL)) {\r\nfusbh200_urb_done(fusbh200, last->urb, last_status);\r\ncount++;\r\nfusbh200_qtd_free (fusbh200, last);\r\n}\r\nif (unlikely(qh->needs_rescan)) {\r\nif (state == QH_STATE_IDLE)\r\ngoto rescan;\r\nif (state != QH_STATE_LINKED)\r\nqh->needs_rescan = 0;\r\n}\r\nqh->qh_state = state;\r\nif (stopped != 0 || hw->hw_qtd_next == FUSBH200_LIST_END(fusbh200)) {\r\nswitch (state) {\r\ncase QH_STATE_IDLE:\r\nqh_refresh(fusbh200, qh);\r\nbreak;\r\ncase QH_STATE_LINKED:\r\nqh->needs_rescan = 1;\r\nbreak;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic void qtd_list_free (\r\nstruct fusbh200_hcd *fusbh200,\r\nstruct urb *urb,\r\nstruct list_head *qtd_list\r\n) {\r\nstruct list_head *entry, *temp;\r\nlist_for_each_safe (entry, temp, qtd_list) {\r\nstruct fusbh200_qtd *qtd;\r\nqtd = list_entry (entry, struct fusbh200_qtd, qtd_list);\r\nlist_del (&qtd->qtd_list);\r\nfusbh200_qtd_free (fusbh200, qtd);\r\n}\r\n}\r\nstatic struct list_head *\r\nqh_urb_transaction (\r\nstruct fusbh200_hcd *fusbh200,\r\nstruct urb *urb,\r\nstruct list_head *head,\r\ngfp_t flags\r\n) {\r\nstruct fusbh200_qtd *qtd, *qtd_prev;\r\ndma_addr_t buf;\r\nint len, this_sg_len, maxpacket;\r\nint is_input;\r\nu32 token;\r\nint i;\r\nstruct scatterlist *sg;\r\nqtd = fusbh200_qtd_alloc (fusbh200, flags);\r\nif (unlikely (!qtd))\r\nreturn NULL;\r\nlist_add_tail (&qtd->qtd_list, head);\r\nqtd->urb = urb;\r\ntoken = QTD_STS_ACTIVE;\r\ntoken |= (FUSBH200_TUNE_CERR << 10);\r\nlen = urb->transfer_buffer_length;\r\nis_input = usb_pipein (urb->pipe);\r\nif (usb_pipecontrol (urb->pipe)) {\r\nqtd_fill(fusbh200, qtd, urb->setup_dma,\r\nsizeof (struct usb_ctrlrequest),\r\ntoken | (2 << 8), 8);\r\ntoken ^= QTD_TOGGLE;\r\nqtd_prev = qtd;\r\nqtd = fusbh200_qtd_alloc (fusbh200, flags);\r\nif (unlikely (!qtd))\r\ngoto cleanup;\r\nqtd->urb = urb;\r\nqtd_prev->hw_next = QTD_NEXT(fusbh200, qtd->qtd_dma);\r\nlist_add_tail (&qtd->qtd_list, head);\r\nif (len == 0)\r\ntoken |= (1 << 8);\r\n}\r\ni = urb->num_mapped_sgs;\r\nif (len > 0 && i > 0) {\r\nsg = urb->sg;\r\nbuf = sg_dma_address(sg);\r\nthis_sg_len = min_t(int, sg_dma_len(sg), len);\r\n} else {\r\nsg = NULL;\r\nbuf = urb->transfer_dma;\r\nthis_sg_len = len;\r\n}\r\nif (is_input)\r\ntoken |= (1 << 8);\r\nmaxpacket = max_packet(usb_maxpacket(urb->dev, urb->pipe, !is_input));\r\nfor (;;) {\r\nint this_qtd_len;\r\nthis_qtd_len = qtd_fill(fusbh200, qtd, buf, this_sg_len, token,\r\nmaxpacket);\r\nthis_sg_len -= this_qtd_len;\r\nlen -= this_qtd_len;\r\nbuf += this_qtd_len;\r\nif (is_input)\r\nqtd->hw_alt_next = fusbh200->async->hw->hw_alt_next;\r\nif ((maxpacket & (this_qtd_len + (maxpacket - 1))) == 0)\r\ntoken ^= QTD_TOGGLE;\r\nif (likely(this_sg_len <= 0)) {\r\nif (--i <= 0 || len <= 0)\r\nbreak;\r\nsg = sg_next(sg);\r\nbuf = sg_dma_address(sg);\r\nthis_sg_len = min_t(int, sg_dma_len(sg), len);\r\n}\r\nqtd_prev = qtd;\r\nqtd = fusbh200_qtd_alloc (fusbh200, flags);\r\nif (unlikely (!qtd))\r\ngoto cleanup;\r\nqtd->urb = urb;\r\nqtd_prev->hw_next = QTD_NEXT(fusbh200, qtd->qtd_dma);\r\nlist_add_tail (&qtd->qtd_list, head);\r\n}\r\nif (likely ((urb->transfer_flags & URB_SHORT_NOT_OK) == 0\r\n|| usb_pipecontrol (urb->pipe)))\r\nqtd->hw_alt_next = FUSBH200_LIST_END(fusbh200);\r\nif (likely (urb->transfer_buffer_length != 0)) {\r\nint one_more = 0;\r\nif (usb_pipecontrol (urb->pipe)) {\r\none_more = 1;\r\ntoken ^= 0x0100;\r\ntoken |= QTD_TOGGLE;\r\n} else if (usb_pipeout(urb->pipe)\r\n&& (urb->transfer_flags & URB_ZERO_PACKET)\r\n&& !(urb->transfer_buffer_length % maxpacket)) {\r\none_more = 1;\r\n}\r\nif (one_more) {\r\nqtd_prev = qtd;\r\nqtd = fusbh200_qtd_alloc (fusbh200, flags);\r\nif (unlikely (!qtd))\r\ngoto cleanup;\r\nqtd->urb = urb;\r\nqtd_prev->hw_next = QTD_NEXT(fusbh200, qtd->qtd_dma);\r\nlist_add_tail (&qtd->qtd_list, head);\r\nqtd_fill(fusbh200, qtd, 0, 0, token, 0);\r\n}\r\n}\r\nif (likely (!(urb->transfer_flags & URB_NO_INTERRUPT)))\r\nqtd->hw_token |= cpu_to_hc32(fusbh200, QTD_IOC);\r\nreturn head;\r\ncleanup:\r\nqtd_list_free (fusbh200, urb, head);\r\nreturn NULL;\r\n}\r\nstatic struct fusbh200_qh *\r\nqh_make (\r\nstruct fusbh200_hcd *fusbh200,\r\nstruct urb *urb,\r\ngfp_t flags\r\n) {\r\nstruct fusbh200_qh *qh = fusbh200_qh_alloc (fusbh200, flags);\r\nu32 info1 = 0, info2 = 0;\r\nint is_input, type;\r\nint maxp = 0;\r\nstruct usb_tt *tt = urb->dev->tt;\r\nstruct fusbh200_qh_hw *hw;\r\nif (!qh)\r\nreturn qh;\r\ninfo1 |= usb_pipeendpoint (urb->pipe) << 8;\r\ninfo1 |= usb_pipedevice (urb->pipe) << 0;\r\nis_input = usb_pipein (urb->pipe);\r\ntype = usb_pipetype (urb->pipe);\r\nmaxp = usb_maxpacket (urb->dev, urb->pipe, !is_input);\r\nif (max_packet(maxp) > 1024) {\r\nfusbh200_dbg(fusbh200, "bogus qh maxpacket %d\n", max_packet(maxp));\r\ngoto done;\r\n}\r\nif (type == PIPE_INTERRUPT) {\r\nqh->usecs = NS_TO_US(usb_calc_bus_time(USB_SPEED_HIGH,\r\nis_input, 0,\r\nhb_mult(maxp) * max_packet(maxp)));\r\nqh->start = NO_FRAME;\r\nif (urb->dev->speed == USB_SPEED_HIGH) {\r\nqh->c_usecs = 0;\r\nqh->gap_uf = 0;\r\nqh->period = urb->interval >> 3;\r\nif (qh->period == 0 && urb->interval != 1) {\r\nurb->interval = 1;\r\n} else if (qh->period > fusbh200->periodic_size) {\r\nqh->period = fusbh200->periodic_size;\r\nurb->interval = qh->period << 3;\r\n}\r\n} else {\r\nint think_time;\r\nqh->gap_uf = 1 + usb_calc_bus_time (urb->dev->speed,\r\nis_input, 0, maxp) / (125 * 1000);\r\nif (is_input) {\r\nqh->c_usecs = qh->usecs + HS_USECS (0);\r\nqh->usecs = HS_USECS (1);\r\n} else {\r\nqh->usecs += HS_USECS (1);\r\nqh->c_usecs = HS_USECS (0);\r\n}\r\nthink_time = tt ? tt->think_time : 0;\r\nqh->tt_usecs = NS_TO_US (think_time +\r\nusb_calc_bus_time (urb->dev->speed,\r\nis_input, 0, max_packet (maxp)));\r\nqh->period = urb->interval;\r\nif (qh->period > fusbh200->periodic_size) {\r\nqh->period = fusbh200->periodic_size;\r\nurb->interval = qh->period;\r\n}\r\n}\r\n}\r\nqh->dev = urb->dev;\r\nswitch (urb->dev->speed) {\r\ncase USB_SPEED_LOW:\r\ninfo1 |= QH_LOW_SPEED;\r\ncase USB_SPEED_FULL:\r\nif (type != PIPE_INTERRUPT)\r\ninfo1 |= (FUSBH200_TUNE_RL_TT << 28);\r\nif (type == PIPE_CONTROL) {\r\ninfo1 |= QH_CONTROL_EP;\r\ninfo1 |= QH_TOGGLE_CTL;\r\n}\r\ninfo1 |= maxp << 16;\r\ninfo2 |= (FUSBH200_TUNE_MULT_TT << 30);\r\nif (fusbh200_has_fsl_portno_bug(fusbh200))\r\ninfo2 |= (urb->dev->ttport-1) << 23;\r\nelse\r\ninfo2 |= urb->dev->ttport << 23;\r\nif (tt && tt->hub != fusbh200_to_hcd(fusbh200)->self.root_hub)\r\ninfo2 |= tt->hub->devnum << 16;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\ninfo1 |= QH_HIGH_SPEED;\r\nif (type == PIPE_CONTROL) {\r\ninfo1 |= (FUSBH200_TUNE_RL_HS << 28);\r\ninfo1 |= 64 << 16;\r\ninfo1 |= QH_TOGGLE_CTL;\r\ninfo2 |= (FUSBH200_TUNE_MULT_HS << 30);\r\n} else if (type == PIPE_BULK) {\r\ninfo1 |= (FUSBH200_TUNE_RL_HS << 28);\r\ninfo1 |= max_packet(maxp) << 16;\r\ninfo2 |= (FUSBH200_TUNE_MULT_HS << 30);\r\n} else {\r\ninfo1 |= max_packet (maxp) << 16;\r\ninfo2 |= hb_mult (maxp) << 30;\r\n}\r\nbreak;\r\ndefault:\r\nfusbh200_dbg(fusbh200, "bogus dev %p speed %d\n", urb->dev,\r\nurb->dev->speed);\r\ndone:\r\nqh_destroy(fusbh200, qh);\r\nreturn NULL;\r\n}\r\nqh->qh_state = QH_STATE_IDLE;\r\nhw = qh->hw;\r\nhw->hw_info1 = cpu_to_hc32(fusbh200, info1);\r\nhw->hw_info2 = cpu_to_hc32(fusbh200, info2);\r\nqh->is_out = !is_input;\r\nusb_settoggle (urb->dev, usb_pipeendpoint (urb->pipe), !is_input, 1);\r\nqh_refresh (fusbh200, qh);\r\nreturn qh;\r\n}\r\nstatic void enable_async(struct fusbh200_hcd *fusbh200)\r\n{\r\nif (fusbh200->async_count++)\r\nreturn;\r\nfusbh200->enabled_hrtimer_events &= ~BIT(FUSBH200_HRTIMER_DISABLE_ASYNC);\r\nfusbh200_poll_ASS(fusbh200);\r\nturn_on_io_watchdog(fusbh200);\r\n}\r\nstatic void disable_async(struct fusbh200_hcd *fusbh200)\r\n{\r\nif (--fusbh200->async_count)\r\nreturn;\r\nWARN_ON(fusbh200->async->qh_next.qh || fusbh200->async_unlink);\r\nfusbh200_poll_ASS(fusbh200);\r\n}\r\nstatic void qh_link_async (struct fusbh200_hcd *fusbh200, struct fusbh200_qh *qh)\r\n{\r\n__hc32 dma = QH_NEXT(fusbh200, qh->qh_dma);\r\nstruct fusbh200_qh *head;\r\nif (unlikely(qh->clearing_tt))\r\nreturn;\r\nWARN_ON(qh->qh_state != QH_STATE_IDLE);\r\nqh_refresh(fusbh200, qh);\r\nhead = fusbh200->async;\r\nqh->qh_next = head->qh_next;\r\nqh->hw->hw_next = head->hw->hw_next;\r\nwmb ();\r\nhead->qh_next.qh = qh;\r\nhead->hw->hw_next = dma;\r\nqh->xacterrs = 0;\r\nqh->qh_state = QH_STATE_LINKED;\r\nenable_async(fusbh200);\r\n}\r\nstatic struct fusbh200_qh *qh_append_tds (\r\nstruct fusbh200_hcd *fusbh200,\r\nstruct urb *urb,\r\nstruct list_head *qtd_list,\r\nint epnum,\r\nvoid **ptr\r\n)\r\n{\r\nstruct fusbh200_qh *qh = NULL;\r\n__hc32 qh_addr_mask = cpu_to_hc32(fusbh200, 0x7f);\r\nqh = (struct fusbh200_qh *) *ptr;\r\nif (unlikely (qh == NULL)) {\r\nqh = qh_make (fusbh200, urb, GFP_ATOMIC);\r\n*ptr = qh;\r\n}\r\nif (likely (qh != NULL)) {\r\nstruct fusbh200_qtd *qtd;\r\nif (unlikely (list_empty (qtd_list)))\r\nqtd = NULL;\r\nelse\r\nqtd = list_entry (qtd_list->next, struct fusbh200_qtd,\r\nqtd_list);\r\nif (unlikely (epnum == 0)) {\r\nif (usb_pipedevice (urb->pipe) == 0)\r\nqh->hw->hw_info1 &= ~qh_addr_mask;\r\n}\r\nif (likely (qtd != NULL)) {\r\nstruct fusbh200_qtd *dummy;\r\ndma_addr_t dma;\r\n__hc32 token;\r\ntoken = qtd->hw_token;\r\nqtd->hw_token = HALT_BIT(fusbh200);\r\ndummy = qh->dummy;\r\ndma = dummy->qtd_dma;\r\n*dummy = *qtd;\r\ndummy->qtd_dma = dma;\r\nlist_del (&qtd->qtd_list);\r\nlist_add (&dummy->qtd_list, qtd_list);\r\nlist_splice_tail(qtd_list, &qh->qtd_list);\r\nfusbh200_qtd_init(fusbh200, qtd, qtd->qtd_dma);\r\nqh->dummy = qtd;\r\ndma = qtd->qtd_dma;\r\nqtd = list_entry (qh->qtd_list.prev,\r\nstruct fusbh200_qtd, qtd_list);\r\nqtd->hw_next = QTD_NEXT(fusbh200, dma);\r\nwmb ();\r\ndummy->hw_token = token;\r\nurb->hcpriv = qh;\r\n}\r\n}\r\nreturn qh;\r\n}\r\nstatic int\r\nsubmit_async (\r\nstruct fusbh200_hcd *fusbh200,\r\nstruct urb *urb,\r\nstruct list_head *qtd_list,\r\ngfp_t mem_flags\r\n) {\r\nint epnum;\r\nunsigned long flags;\r\nstruct fusbh200_qh *qh = NULL;\r\nint rc;\r\nepnum = urb->ep->desc.bEndpointAddress;\r\n#ifdef FUSBH200_URB_TRACE\r\n{\r\nstruct fusbh200_qtd *qtd;\r\nqtd = list_entry(qtd_list->next, struct fusbh200_qtd, qtd_list);\r\nfusbh200_dbg(fusbh200,\r\n"%s %s urb %p ep%d%s len %d, qtd %p [qh %p]\n",\r\n__func__, urb->dev->devpath, urb,\r\nepnum & 0x0f, (epnum & USB_DIR_IN) ? "in" : "out",\r\nurb->transfer_buffer_length,\r\nqtd, urb->ep->hcpriv);\r\n}\r\n#endif\r\nspin_lock_irqsave (&fusbh200->lock, flags);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(fusbh200_to_hcd(fusbh200)))) {\r\nrc = -ESHUTDOWN;\r\ngoto done;\r\n}\r\nrc = usb_hcd_link_urb_to_ep(fusbh200_to_hcd(fusbh200), urb);\r\nif (unlikely(rc))\r\ngoto done;\r\nqh = qh_append_tds(fusbh200, urb, qtd_list, epnum, &urb->ep->hcpriv);\r\nif (unlikely(qh == NULL)) {\r\nusb_hcd_unlink_urb_from_ep(fusbh200_to_hcd(fusbh200), urb);\r\nrc = -ENOMEM;\r\ngoto done;\r\n}\r\nif (likely (qh->qh_state == QH_STATE_IDLE))\r\nqh_link_async(fusbh200, qh);\r\ndone:\r\nspin_unlock_irqrestore (&fusbh200->lock, flags);\r\nif (unlikely (qh == NULL))\r\nqtd_list_free (fusbh200, urb, qtd_list);\r\nreturn rc;\r\n}\r\nstatic void single_unlink_async(struct fusbh200_hcd *fusbh200, struct fusbh200_qh *qh)\r\n{\r\nstruct fusbh200_qh *prev;\r\nqh->qh_state = QH_STATE_UNLINK;\r\nif (fusbh200->async_unlink)\r\nfusbh200->async_unlink_last->unlink_next = qh;\r\nelse\r\nfusbh200->async_unlink = qh;\r\nfusbh200->async_unlink_last = qh;\r\nprev = fusbh200->async;\r\nwhile (prev->qh_next.qh != qh)\r\nprev = prev->qh_next.qh;\r\nprev->hw->hw_next = qh->hw->hw_next;\r\nprev->qh_next = qh->qh_next;\r\nif (fusbh200->qh_scan_next == qh)\r\nfusbh200->qh_scan_next = qh->qh_next.qh;\r\n}\r\nstatic void start_iaa_cycle(struct fusbh200_hcd *fusbh200, bool nested)\r\n{\r\nif (fusbh200->async_iaa || fusbh200->async_unlinking)\r\nreturn;\r\nfusbh200->async_iaa = fusbh200->async_unlink;\r\nfusbh200->async_unlink = NULL;\r\nif (unlikely(fusbh200->rh_state < FUSBH200_RH_RUNNING)) {\r\nif (!nested)\r\nend_unlink_async(fusbh200);\r\n} else if (likely(fusbh200->rh_state == FUSBH200_RH_RUNNING)) {\r\nwmb();\r\nfusbh200_writel(fusbh200, fusbh200->command | CMD_IAAD,\r\n&fusbh200->regs->command);\r\nfusbh200_readl(fusbh200, &fusbh200->regs->command);\r\nfusbh200_enable_event(fusbh200, FUSBH200_HRTIMER_IAA_WATCHDOG, true);\r\n}\r\n}\r\nstatic void end_unlink_async(struct fusbh200_hcd *fusbh200)\r\n{\r\nstruct fusbh200_qh *qh;\r\nrestart:\r\nfusbh200->async_unlinking = true;\r\nwhile (fusbh200->async_iaa) {\r\nqh = fusbh200->async_iaa;\r\nfusbh200->async_iaa = qh->unlink_next;\r\nqh->unlink_next = NULL;\r\nqh->qh_state = QH_STATE_IDLE;\r\nqh->qh_next.qh = NULL;\r\nqh_completions(fusbh200, qh);\r\nif (!list_empty(&qh->qtd_list) &&\r\nfusbh200->rh_state == FUSBH200_RH_RUNNING)\r\nqh_link_async(fusbh200, qh);\r\ndisable_async(fusbh200);\r\n}\r\nfusbh200->async_unlinking = false;\r\nif (fusbh200->async_unlink) {\r\nstart_iaa_cycle(fusbh200, true);\r\nif (unlikely(fusbh200->rh_state < FUSBH200_RH_RUNNING))\r\ngoto restart;\r\n}\r\n}\r\nstatic void unlink_empty_async(struct fusbh200_hcd *fusbh200)\r\n{\r\nstruct fusbh200_qh *qh, *next;\r\nbool stopped = (fusbh200->rh_state < FUSBH200_RH_RUNNING);\r\nbool check_unlinks_later = false;\r\nnext = fusbh200->async->qh_next.qh;\r\nwhile (next) {\r\nqh = next;\r\nnext = qh->qh_next.qh;\r\nif (list_empty(&qh->qtd_list) &&\r\nqh->qh_state == QH_STATE_LINKED) {\r\nif (!stopped && qh->unlink_cycle ==\r\nfusbh200->async_unlink_cycle)\r\ncheck_unlinks_later = true;\r\nelse\r\nsingle_unlink_async(fusbh200, qh);\r\n}\r\n}\r\nif (fusbh200->async_unlink)\r\nstart_iaa_cycle(fusbh200, false);\r\nif (check_unlinks_later) {\r\nfusbh200_enable_event(fusbh200, FUSBH200_HRTIMER_ASYNC_UNLINKS, true);\r\n++fusbh200->async_unlink_cycle;\r\n}\r\n}\r\nstatic void start_unlink_async(struct fusbh200_hcd *fusbh200, struct fusbh200_qh *qh)\r\n{\r\nif (qh->qh_state != QH_STATE_LINKED) {\r\nif (qh->qh_state == QH_STATE_COMPLETING)\r\nqh->needs_rescan = 1;\r\nreturn;\r\n}\r\nsingle_unlink_async(fusbh200, qh);\r\nstart_iaa_cycle(fusbh200, false);\r\n}\r\nstatic void scan_async (struct fusbh200_hcd *fusbh200)\r\n{\r\nstruct fusbh200_qh *qh;\r\nbool check_unlinks_later = false;\r\nfusbh200->qh_scan_next = fusbh200->async->qh_next.qh;\r\nwhile (fusbh200->qh_scan_next) {\r\nqh = fusbh200->qh_scan_next;\r\nfusbh200->qh_scan_next = qh->qh_next.qh;\r\nrescan:\r\nif (!list_empty(&qh->qtd_list)) {\r\nint temp;\r\ntemp = qh_completions(fusbh200, qh);\r\nif (qh->needs_rescan) {\r\nstart_unlink_async(fusbh200, qh);\r\n} else if (list_empty(&qh->qtd_list)\r\n&& qh->qh_state == QH_STATE_LINKED) {\r\nqh->unlink_cycle = fusbh200->async_unlink_cycle;\r\ncheck_unlinks_later = true;\r\n} else if (temp != 0)\r\ngoto rescan;\r\n}\r\n}\r\nif (check_unlinks_later && fusbh200->rh_state == FUSBH200_RH_RUNNING &&\r\n!(fusbh200->enabled_hrtimer_events &\r\nBIT(FUSBH200_HRTIMER_ASYNC_UNLINKS))) {\r\nfusbh200_enable_event(fusbh200, FUSBH200_HRTIMER_ASYNC_UNLINKS, true);\r\n++fusbh200->async_unlink_cycle;\r\n}\r\n}\r\nstatic union fusbh200_shadow *\r\nperiodic_next_shadow(struct fusbh200_hcd *fusbh200, union fusbh200_shadow *periodic,\r\n__hc32 tag)\r\n{\r\nswitch (hc32_to_cpu(fusbh200, tag)) {\r\ncase Q_TYPE_QH:\r\nreturn &periodic->qh->qh_next;\r\ncase Q_TYPE_FSTN:\r\nreturn &periodic->fstn->fstn_next;\r\ndefault:\r\nreturn &periodic->itd->itd_next;\r\n}\r\n}\r\nstatic __hc32 *\r\nshadow_next_periodic(struct fusbh200_hcd *fusbh200, union fusbh200_shadow *periodic,\r\n__hc32 tag)\r\n{\r\nswitch (hc32_to_cpu(fusbh200, tag)) {\r\ncase Q_TYPE_QH:\r\nreturn &periodic->qh->hw->hw_next;\r\ndefault:\r\nreturn periodic->hw_next;\r\n}\r\n}\r\nstatic void periodic_unlink (struct fusbh200_hcd *fusbh200, unsigned frame, void *ptr)\r\n{\r\nunion fusbh200_shadow *prev_p = &fusbh200->pshadow[frame];\r\n__hc32 *hw_p = &fusbh200->periodic[frame];\r\nunion fusbh200_shadow here = *prev_p;\r\nwhile (here.ptr && here.ptr != ptr) {\r\nprev_p = periodic_next_shadow(fusbh200, prev_p,\r\nQ_NEXT_TYPE(fusbh200, *hw_p));\r\nhw_p = shadow_next_periodic(fusbh200, &here,\r\nQ_NEXT_TYPE(fusbh200, *hw_p));\r\nhere = *prev_p;\r\n}\r\nif (!here.ptr)\r\nreturn;\r\n*prev_p = *periodic_next_shadow(fusbh200, &here,\r\nQ_NEXT_TYPE(fusbh200, *hw_p));\r\n*hw_p = *shadow_next_periodic(fusbh200, &here,\r\nQ_NEXT_TYPE(fusbh200, *hw_p));\r\n}\r\nstatic unsigned short\r\nperiodic_usecs (struct fusbh200_hcd *fusbh200, unsigned frame, unsigned uframe)\r\n{\r\n__hc32 *hw_p = &fusbh200->periodic [frame];\r\nunion fusbh200_shadow *q = &fusbh200->pshadow [frame];\r\nunsigned usecs = 0;\r\nstruct fusbh200_qh_hw *hw;\r\nwhile (q->ptr) {\r\nswitch (hc32_to_cpu(fusbh200, Q_NEXT_TYPE(fusbh200, *hw_p))) {\r\ncase Q_TYPE_QH:\r\nhw = q->qh->hw;\r\nif (hw->hw_info2 & cpu_to_hc32(fusbh200, 1 << uframe))\r\nusecs += q->qh->usecs;\r\nif (hw->hw_info2 & cpu_to_hc32(fusbh200,\r\n1 << (8 + uframe)))\r\nusecs += q->qh->c_usecs;\r\nhw_p = &hw->hw_next;\r\nq = &q->qh->qh_next;\r\nbreak;\r\ndefault:\r\nif (q->fstn->hw_prev != FUSBH200_LIST_END(fusbh200)) {\r\nfusbh200_dbg (fusbh200, "ignoring FSTN cost ...\n");\r\n}\r\nhw_p = &q->fstn->hw_next;\r\nq = &q->fstn->fstn_next;\r\nbreak;\r\ncase Q_TYPE_ITD:\r\nif (q->itd->hw_transaction[uframe])\r\nusecs += q->itd->stream->usecs;\r\nhw_p = &q->itd->hw_next;\r\nq = &q->itd->itd_next;\r\nbreak;\r\n}\r\n}\r\nif (usecs > fusbh200->uframe_periodic_max)\r\nfusbh200_err (fusbh200, "uframe %d sched overrun: %d usecs\n",\r\nframe * 8 + uframe, usecs);\r\nreturn usecs;\r\n}\r\nstatic int same_tt (struct usb_device *dev1, struct usb_device *dev2)\r\n{\r\nif (!dev1->tt || !dev2->tt)\r\nreturn 0;\r\nif (dev1->tt != dev2->tt)\r\nreturn 0;\r\nif (dev1->tt->multi)\r\nreturn dev1->ttport == dev2->ttport;\r\nelse\r\nreturn 1;\r\n}\r\nstatic int tt_no_collision (\r\nstruct fusbh200_hcd *fusbh200,\r\nunsigned period,\r\nstruct usb_device *dev,\r\nunsigned frame,\r\nu32 uf_mask\r\n)\r\n{\r\nif (period == 0)\r\nreturn 0;\r\nfor (; frame < fusbh200->periodic_size; frame += period) {\r\nunion fusbh200_shadow here;\r\n__hc32 type;\r\nstruct fusbh200_qh_hw *hw;\r\nhere = fusbh200->pshadow [frame];\r\ntype = Q_NEXT_TYPE(fusbh200, fusbh200->periodic [frame]);\r\nwhile (here.ptr) {\r\nswitch (hc32_to_cpu(fusbh200, type)) {\r\ncase Q_TYPE_ITD:\r\ntype = Q_NEXT_TYPE(fusbh200, here.itd->hw_next);\r\nhere = here.itd->itd_next;\r\ncontinue;\r\ncase Q_TYPE_QH:\r\nhw = here.qh->hw;\r\nif (same_tt (dev, here.qh->dev)) {\r\nu32 mask;\r\nmask = hc32_to_cpu(fusbh200,\r\nhw->hw_info2);\r\nmask |= mask >> 8;\r\nif (mask & uf_mask)\r\nbreak;\r\n}\r\ntype = Q_NEXT_TYPE(fusbh200, hw->hw_next);\r\nhere = here.qh->qh_next;\r\ncontinue;\r\ndefault:\r\nfusbh200_dbg (fusbh200,\r\n"periodic frame %d bogus type %d\n",\r\nframe, type);\r\n}\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void enable_periodic(struct fusbh200_hcd *fusbh200)\r\n{\r\nif (fusbh200->periodic_count++)\r\nreturn;\r\nfusbh200->enabled_hrtimer_events &= ~BIT(FUSBH200_HRTIMER_DISABLE_PERIODIC);\r\nfusbh200_poll_PSS(fusbh200);\r\nturn_on_io_watchdog(fusbh200);\r\n}\r\nstatic void disable_periodic(struct fusbh200_hcd *fusbh200)\r\n{\r\nif (--fusbh200->periodic_count)\r\nreturn;\r\nfusbh200_poll_PSS(fusbh200);\r\n}\r\nstatic void qh_link_periodic(struct fusbh200_hcd *fusbh200, struct fusbh200_qh *qh)\r\n{\r\nunsigned i;\r\nunsigned period = qh->period;\r\ndev_dbg (&qh->dev->dev,\r\n"link qh%d-%04x/%p start %d [%d/%d us]\n",\r\nperiod, hc32_to_cpup(fusbh200, &qh->hw->hw_info2)\r\n& (QH_CMASK | QH_SMASK),\r\nqh, qh->start, qh->usecs, qh->c_usecs);\r\nif (period == 0)\r\nperiod = 1;\r\nfor (i = qh->start; i < fusbh200->periodic_size; i += period) {\r\nunion fusbh200_shadow *prev = &fusbh200->pshadow[i];\r\n__hc32 *hw_p = &fusbh200->periodic[i];\r\nunion fusbh200_shadow here = *prev;\r\n__hc32 type = 0;\r\nwhile (here.ptr) {\r\ntype = Q_NEXT_TYPE(fusbh200, *hw_p);\r\nif (type == cpu_to_hc32(fusbh200, Q_TYPE_QH))\r\nbreak;\r\nprev = periodic_next_shadow(fusbh200, prev, type);\r\nhw_p = shadow_next_periodic(fusbh200, &here, type);\r\nhere = *prev;\r\n}\r\nwhile (here.ptr && qh != here.qh) {\r\nif (qh->period > here.qh->period)\r\nbreak;\r\nprev = &here.qh->qh_next;\r\nhw_p = &here.qh->hw->hw_next;\r\nhere = *prev;\r\n}\r\nif (qh != here.qh) {\r\nqh->qh_next = here;\r\nif (here.qh)\r\nqh->hw->hw_next = *hw_p;\r\nwmb ();\r\nprev->qh = qh;\r\n*hw_p = QH_NEXT (fusbh200, qh->qh_dma);\r\n}\r\n}\r\nqh->qh_state = QH_STATE_LINKED;\r\nqh->xacterrs = 0;\r\nfusbh200_to_hcd(fusbh200)->self.bandwidth_allocated += qh->period\r\n? ((qh->usecs + qh->c_usecs) / qh->period)\r\n: (qh->usecs * 8);\r\nlist_add(&qh->intr_node, &fusbh200->intr_qh_list);\r\n++fusbh200->intr_count;\r\nenable_periodic(fusbh200);\r\n}\r\nstatic void qh_unlink_periodic(struct fusbh200_hcd *fusbh200, struct fusbh200_qh *qh)\r\n{\r\nunsigned i;\r\nunsigned period;\r\nif ((period = qh->period) == 0)\r\nperiod = 1;\r\nfor (i = qh->start; i < fusbh200->periodic_size; i += period)\r\nperiodic_unlink (fusbh200, i, qh);\r\nfusbh200_to_hcd(fusbh200)->self.bandwidth_allocated -= qh->period\r\n? ((qh->usecs + qh->c_usecs) / qh->period)\r\n: (qh->usecs * 8);\r\ndev_dbg (&qh->dev->dev,\r\n"unlink qh%d-%04x/%p start %d [%d/%d us]\n",\r\nqh->period,\r\nhc32_to_cpup(fusbh200, &qh->hw->hw_info2) & (QH_CMASK | QH_SMASK),\r\nqh, qh->start, qh->usecs, qh->c_usecs);\r\nqh->qh_state = QH_STATE_UNLINK;\r\nqh->qh_next.ptr = NULL;\r\nif (fusbh200->qh_scan_next == qh)\r\nfusbh200->qh_scan_next = list_entry(qh->intr_node.next,\r\nstruct fusbh200_qh, intr_node);\r\nlist_del(&qh->intr_node);\r\n}\r\nstatic void start_unlink_intr(struct fusbh200_hcd *fusbh200, struct fusbh200_qh *qh)\r\n{\r\nif (qh->qh_state != QH_STATE_LINKED) {\r\nif (qh->qh_state == QH_STATE_COMPLETING)\r\nqh->needs_rescan = 1;\r\nreturn;\r\n}\r\nqh_unlink_periodic (fusbh200, qh);\r\nwmb();\r\nqh->unlink_cycle = fusbh200->intr_unlink_cycle;\r\nif (fusbh200->intr_unlink)\r\nfusbh200->intr_unlink_last->unlink_next = qh;\r\nelse\r\nfusbh200->intr_unlink = qh;\r\nfusbh200->intr_unlink_last = qh;\r\nif (fusbh200->intr_unlinking)\r\n;\r\nelse if (fusbh200->rh_state < FUSBH200_RH_RUNNING)\r\nfusbh200_handle_intr_unlinks(fusbh200);\r\nelse if (fusbh200->intr_unlink == qh) {\r\nfusbh200_enable_event(fusbh200, FUSBH200_HRTIMER_UNLINK_INTR, true);\r\n++fusbh200->intr_unlink_cycle;\r\n}\r\n}\r\nstatic void end_unlink_intr(struct fusbh200_hcd *fusbh200, struct fusbh200_qh *qh)\r\n{\r\nstruct fusbh200_qh_hw *hw = qh->hw;\r\nint rc;\r\nqh->qh_state = QH_STATE_IDLE;\r\nhw->hw_next = FUSBH200_LIST_END(fusbh200);\r\nqh_completions(fusbh200, qh);\r\nif (!list_empty(&qh->qtd_list) && fusbh200->rh_state == FUSBH200_RH_RUNNING) {\r\nrc = qh_schedule(fusbh200, qh);\r\nif (rc != 0)\r\nfusbh200_err(fusbh200, "can't reschedule qh %p, err %d\n",\r\nqh, rc);\r\n}\r\n--fusbh200->intr_count;\r\ndisable_periodic(fusbh200);\r\n}\r\nstatic int check_period (\r\nstruct fusbh200_hcd *fusbh200,\r\nunsigned frame,\r\nunsigned uframe,\r\nunsigned period,\r\nunsigned usecs\r\n) {\r\nint claimed;\r\nif (uframe >= 8)\r\nreturn 0;\r\nusecs = fusbh200->uframe_periodic_max - usecs;\r\nif (unlikely (period == 0)) {\r\ndo {\r\nfor (uframe = 0; uframe < 7; uframe++) {\r\nclaimed = periodic_usecs (fusbh200, frame, uframe);\r\nif (claimed > usecs)\r\nreturn 0;\r\n}\r\n} while ((frame += 1) < fusbh200->periodic_size);\r\n} else {\r\ndo {\r\nclaimed = periodic_usecs (fusbh200, frame, uframe);\r\nif (claimed > usecs)\r\nreturn 0;\r\n} while ((frame += period) < fusbh200->periodic_size);\r\n}\r\nreturn 1;\r\n}\r\nstatic int check_intr_schedule (\r\nstruct fusbh200_hcd *fusbh200,\r\nunsigned frame,\r\nunsigned uframe,\r\nconst struct fusbh200_qh *qh,\r\n__hc32 *c_maskp\r\n)\r\n{\r\nint retval = -ENOSPC;\r\nu8 mask = 0;\r\nif (qh->c_usecs && uframe >= 6)\r\ngoto done;\r\nif (!check_period (fusbh200, frame, uframe, qh->period, qh->usecs))\r\ngoto done;\r\nif (!qh->c_usecs) {\r\nretval = 0;\r\n*c_maskp = 0;\r\ngoto done;\r\n}\r\nmask = 0x03 << (uframe + qh->gap_uf);\r\n*c_maskp = cpu_to_hc32(fusbh200, mask << 8);\r\nmask |= 1 << uframe;\r\nif (tt_no_collision (fusbh200, qh->period, qh->dev, frame, mask)) {\r\nif (!check_period (fusbh200, frame, uframe + qh->gap_uf + 1,\r\nqh->period, qh->c_usecs))\r\ngoto done;\r\nif (!check_period (fusbh200, frame, uframe + qh->gap_uf,\r\nqh->period, qh->c_usecs))\r\ngoto done;\r\nretval = 0;\r\n}\r\ndone:\r\nreturn retval;\r\n}\r\nstatic int qh_schedule(struct fusbh200_hcd *fusbh200, struct fusbh200_qh *qh)\r\n{\r\nint status;\r\nunsigned uframe;\r\n__hc32 c_mask;\r\nunsigned frame;\r\nstruct fusbh200_qh_hw *hw = qh->hw;\r\nqh_refresh(fusbh200, qh);\r\nhw->hw_next = FUSBH200_LIST_END(fusbh200);\r\nframe = qh->start;\r\nif (frame < qh->period) {\r\nuframe = ffs(hc32_to_cpup(fusbh200, &hw->hw_info2) & QH_SMASK);\r\nstatus = check_intr_schedule (fusbh200, frame, --uframe,\r\nqh, &c_mask);\r\n} else {\r\nuframe = 0;\r\nc_mask = 0;\r\nstatus = -ENOSPC;\r\n}\r\nif (status) {\r\nif (qh->period) {\r\nint i;\r\nfor (i = qh->period; status && i > 0; --i) {\r\nframe = ++fusbh200->random_frame % qh->period;\r\nfor (uframe = 0; uframe < 8; uframe++) {\r\nstatus = check_intr_schedule (fusbh200,\r\nframe, uframe, qh,\r\n&c_mask);\r\nif (status == 0)\r\nbreak;\r\n}\r\n}\r\n} else {\r\nframe = 0;\r\nstatus = check_intr_schedule (fusbh200, 0, 0, qh, &c_mask);\r\n}\r\nif (status)\r\ngoto done;\r\nqh->start = frame;\r\nhw->hw_info2 &= cpu_to_hc32(fusbh200, ~(QH_CMASK | QH_SMASK));\r\nhw->hw_info2 |= qh->period\r\n? cpu_to_hc32(fusbh200, 1 << uframe)\r\n: cpu_to_hc32(fusbh200, QH_SMASK);\r\nhw->hw_info2 |= c_mask;\r\n} else\r\nfusbh200_dbg (fusbh200, "reused qh %p schedule\n", qh);\r\nqh_link_periodic(fusbh200, qh);\r\ndone:\r\nreturn status;\r\n}\r\nstatic int intr_submit (\r\nstruct fusbh200_hcd *fusbh200,\r\nstruct urb *urb,\r\nstruct list_head *qtd_list,\r\ngfp_t mem_flags\r\n) {\r\nunsigned epnum;\r\nunsigned long flags;\r\nstruct fusbh200_qh *qh;\r\nint status;\r\nstruct list_head empty;\r\nepnum = urb->ep->desc.bEndpointAddress;\r\nspin_lock_irqsave (&fusbh200->lock, flags);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(fusbh200_to_hcd(fusbh200)))) {\r\nstatus = -ESHUTDOWN;\r\ngoto done_not_linked;\r\n}\r\nstatus = usb_hcd_link_urb_to_ep(fusbh200_to_hcd(fusbh200), urb);\r\nif (unlikely(status))\r\ngoto done_not_linked;\r\nINIT_LIST_HEAD (&empty);\r\nqh = qh_append_tds(fusbh200, urb, &empty, epnum, &urb->ep->hcpriv);\r\nif (qh == NULL) {\r\nstatus = -ENOMEM;\r\ngoto done;\r\n}\r\nif (qh->qh_state == QH_STATE_IDLE) {\r\nif ((status = qh_schedule (fusbh200, qh)) != 0)\r\ngoto done;\r\n}\r\nqh = qh_append_tds(fusbh200, urb, qtd_list, epnum, &urb->ep->hcpriv);\r\nBUG_ON (qh == NULL);\r\nfusbh200_to_hcd(fusbh200)->self.bandwidth_int_reqs++;\r\ndone:\r\nif (unlikely(status))\r\nusb_hcd_unlink_urb_from_ep(fusbh200_to_hcd(fusbh200), urb);\r\ndone_not_linked:\r\nspin_unlock_irqrestore (&fusbh200->lock, flags);\r\nif (status)\r\nqtd_list_free (fusbh200, urb, qtd_list);\r\nreturn status;\r\n}\r\nstatic void scan_intr(struct fusbh200_hcd *fusbh200)\r\n{\r\nstruct fusbh200_qh *qh;\r\nlist_for_each_entry_safe(qh, fusbh200->qh_scan_next, &fusbh200->intr_qh_list,\r\nintr_node) {\r\nrescan:\r\nif (!list_empty(&qh->qtd_list)) {\r\nint temp;\r\ntemp = qh_completions(fusbh200, qh);\r\nif (unlikely(qh->needs_rescan ||\r\n(list_empty(&qh->qtd_list) &&\r\nqh->qh_state == QH_STATE_LINKED)))\r\nstart_unlink_intr(fusbh200, qh);\r\nelse if (temp != 0)\r\ngoto rescan;\r\n}\r\n}\r\n}\r\nstatic struct fusbh200_iso_stream *\r\niso_stream_alloc (gfp_t mem_flags)\r\n{\r\nstruct fusbh200_iso_stream *stream;\r\nstream = kzalloc(sizeof *stream, mem_flags);\r\nif (likely (stream != NULL)) {\r\nINIT_LIST_HEAD(&stream->td_list);\r\nINIT_LIST_HEAD(&stream->free_list);\r\nstream->next_uframe = -1;\r\n}\r\nreturn stream;\r\n}\r\nstatic void\r\niso_stream_init (\r\nstruct fusbh200_hcd *fusbh200,\r\nstruct fusbh200_iso_stream *stream,\r\nstruct usb_device *dev,\r\nint pipe,\r\nunsigned interval\r\n)\r\n{\r\nu32 buf1;\r\nunsigned epnum, maxp;\r\nint is_input;\r\nlong bandwidth;\r\nunsigned multi;\r\nepnum = usb_pipeendpoint (pipe);\r\nis_input = usb_pipein (pipe) ? USB_DIR_IN : 0;\r\nmaxp = usb_maxpacket(dev, pipe, !is_input);\r\nif (is_input) {\r\nbuf1 = (1 << 11);\r\n} else {\r\nbuf1 = 0;\r\n}\r\nmaxp = max_packet(maxp);\r\nmulti = hb_mult(maxp);\r\nbuf1 |= maxp;\r\nmaxp *= multi;\r\nstream->buf0 = cpu_to_hc32(fusbh200, (epnum << 8) | dev->devnum);\r\nstream->buf1 = cpu_to_hc32(fusbh200, buf1);\r\nstream->buf2 = cpu_to_hc32(fusbh200, multi);\r\nif (dev->speed == USB_SPEED_FULL) {\r\ninterval <<= 3;\r\nstream->usecs = NS_TO_US(usb_calc_bus_time(dev->speed,\r\nis_input, 1, maxp));\r\nstream->usecs /= 8;\r\n} else {\r\nstream->highspeed = 1;\r\nstream->usecs = HS_USECS_ISO (maxp);\r\n}\r\nbandwidth = stream->usecs * 8;\r\nbandwidth /= interval;\r\nstream->bandwidth = bandwidth;\r\nstream->udev = dev;\r\nstream->bEndpointAddress = is_input | epnum;\r\nstream->interval = interval;\r\nstream->maxp = maxp;\r\n}\r\nstatic struct fusbh200_iso_stream *\r\niso_stream_find (struct fusbh200_hcd *fusbh200, struct urb *urb)\r\n{\r\nunsigned epnum;\r\nstruct fusbh200_iso_stream *stream;\r\nstruct usb_host_endpoint *ep;\r\nunsigned long flags;\r\nepnum = usb_pipeendpoint (urb->pipe);\r\nif (usb_pipein(urb->pipe))\r\nep = urb->dev->ep_in[epnum];\r\nelse\r\nep = urb->dev->ep_out[epnum];\r\nspin_lock_irqsave (&fusbh200->lock, flags);\r\nstream = ep->hcpriv;\r\nif (unlikely (stream == NULL)) {\r\nstream = iso_stream_alloc(GFP_ATOMIC);\r\nif (likely (stream != NULL)) {\r\nep->hcpriv = stream;\r\nstream->ep = ep;\r\niso_stream_init(fusbh200, stream, urb->dev, urb->pipe,\r\nurb->interval);\r\n}\r\n} else if (unlikely (stream->hw != NULL)) {\r\nfusbh200_dbg (fusbh200, "dev %s ep%d%s, not iso??\n",\r\nurb->dev->devpath, epnum,\r\nusb_pipein(urb->pipe) ? "in" : "out");\r\nstream = NULL;\r\n}\r\nspin_unlock_irqrestore (&fusbh200->lock, flags);\r\nreturn stream;\r\n}\r\nstatic struct fusbh200_iso_sched *\r\niso_sched_alloc (unsigned packets, gfp_t mem_flags)\r\n{\r\nstruct fusbh200_iso_sched *iso_sched;\r\nint size = sizeof *iso_sched;\r\nsize += packets * sizeof (struct fusbh200_iso_packet);\r\niso_sched = kzalloc(size, mem_flags);\r\nif (likely (iso_sched != NULL)) {\r\nINIT_LIST_HEAD (&iso_sched->td_list);\r\n}\r\nreturn iso_sched;\r\n}\r\nstatic inline void\r\nitd_sched_init(\r\nstruct fusbh200_hcd *fusbh200,\r\nstruct fusbh200_iso_sched *iso_sched,\r\nstruct fusbh200_iso_stream *stream,\r\nstruct urb *urb\r\n)\r\n{\r\nunsigned i;\r\ndma_addr_t dma = urb->transfer_dma;\r\niso_sched->span = urb->number_of_packets * stream->interval;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nstruct fusbh200_iso_packet *uframe = &iso_sched->packet [i];\r\nunsigned length;\r\ndma_addr_t buf;\r\nu32 trans;\r\nlength = urb->iso_frame_desc [i].length;\r\nbuf = dma + urb->iso_frame_desc [i].offset;\r\ntrans = FUSBH200_ISOC_ACTIVE;\r\ntrans |= buf & 0x0fff;\r\nif (unlikely (((i + 1) == urb->number_of_packets))\r\n&& !(urb->transfer_flags & URB_NO_INTERRUPT))\r\ntrans |= FUSBH200_ITD_IOC;\r\ntrans |= length << 16;\r\nuframe->transaction = cpu_to_hc32(fusbh200, trans);\r\nuframe->bufp = (buf & ~(u64)0x0fff);\r\nbuf += length;\r\nif (unlikely ((uframe->bufp != (buf & ~(u64)0x0fff))))\r\nuframe->cross = 1;\r\n}\r\n}\r\nstatic void\r\niso_sched_free (\r\nstruct fusbh200_iso_stream *stream,\r\nstruct fusbh200_iso_sched *iso_sched\r\n)\r\n{\r\nif (!iso_sched)\r\nreturn;\r\nlist_splice (&iso_sched->td_list, &stream->free_list);\r\nkfree (iso_sched);\r\n}\r\nstatic int\r\nitd_urb_transaction (\r\nstruct fusbh200_iso_stream *stream,\r\nstruct fusbh200_hcd *fusbh200,\r\nstruct urb *urb,\r\ngfp_t mem_flags\r\n)\r\n{\r\nstruct fusbh200_itd *itd;\r\ndma_addr_t itd_dma;\r\nint i;\r\nunsigned num_itds;\r\nstruct fusbh200_iso_sched *sched;\r\nunsigned long flags;\r\nsched = iso_sched_alloc (urb->number_of_packets, mem_flags);\r\nif (unlikely (sched == NULL))\r\nreturn -ENOMEM;\r\nitd_sched_init(fusbh200, sched, stream, urb);\r\nif (urb->interval < 8)\r\nnum_itds = 1 + (sched->span + 7) / 8;\r\nelse\r\nnum_itds = urb->number_of_packets;\r\nspin_lock_irqsave (&fusbh200->lock, flags);\r\nfor (i = 0; i < num_itds; i++) {\r\nif (likely(!list_empty(&stream->free_list))) {\r\nitd = list_first_entry(&stream->free_list,\r\nstruct fusbh200_itd, itd_list);\r\nif (itd->frame == fusbh200->now_frame)\r\ngoto alloc_itd;\r\nlist_del (&itd->itd_list);\r\nitd_dma = itd->itd_dma;\r\n} else {\r\nalloc_itd:\r\nspin_unlock_irqrestore (&fusbh200->lock, flags);\r\nitd = dma_pool_alloc (fusbh200->itd_pool, mem_flags,\r\n&itd_dma);\r\nspin_lock_irqsave (&fusbh200->lock, flags);\r\nif (!itd) {\r\niso_sched_free(stream, sched);\r\nspin_unlock_irqrestore(&fusbh200->lock, flags);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nmemset (itd, 0, sizeof *itd);\r\nitd->itd_dma = itd_dma;\r\nlist_add (&itd->itd_list, &sched->td_list);\r\n}\r\nspin_unlock_irqrestore (&fusbh200->lock, flags);\r\nurb->hcpriv = sched;\r\nurb->error_count = 0;\r\nreturn 0;\r\n}\r\nstatic inline int\r\nitd_slot_ok (\r\nstruct fusbh200_hcd *fusbh200,\r\nu32 mod,\r\nu32 uframe,\r\nu8 usecs,\r\nu32 period\r\n)\r\n{\r\nuframe %= period;\r\ndo {\r\nif (periodic_usecs (fusbh200, uframe >> 3, uframe & 0x7)\r\n> (fusbh200->uframe_periodic_max - usecs))\r\nreturn 0;\r\nuframe += period;\r\n} while (uframe < mod);\r\nreturn 1;\r\n}\r\nstatic int\r\niso_stream_schedule (\r\nstruct fusbh200_hcd *fusbh200,\r\nstruct urb *urb,\r\nstruct fusbh200_iso_stream *stream\r\n)\r\n{\r\nu32 now, next, start, period, span;\r\nint status;\r\nunsigned mod = fusbh200->periodic_size << 3;\r\nstruct fusbh200_iso_sched *sched = urb->hcpriv;\r\nperiod = urb->interval;\r\nspan = sched->span;\r\nif (span > mod - SCHEDULE_SLOP) {\r\nfusbh200_dbg (fusbh200, "iso request %p too long\n", urb);\r\nstatus = -EFBIG;\r\ngoto fail;\r\n}\r\nnow = fusbh200_read_frame_index(fusbh200) & (mod - 1);\r\nif (likely (!list_empty (&stream->td_list))) {\r\nu32 excess;\r\nif (!stream->highspeed && fusbh200->fs_i_thresh)\r\nnext = now + fusbh200->i_thresh;\r\nelse\r\nnext = now;\r\nexcess = (stream->next_uframe - period - next) & (mod - 1);\r\nif (excess >= mod - 2 * SCHEDULE_SLOP)\r\nstart = next + excess - mod + period *\r\nDIV_ROUND_UP(mod - excess, period);\r\nelse\r\nstart = next + excess + period;\r\nif (start - now >= mod) {\r\nfusbh200_dbg(fusbh200, "request %p would overflow (%d+%d >= %d)\n",\r\nurb, start - now - period, period,\r\nmod);\r\nstatus = -EFBIG;\r\ngoto fail;\r\n}\r\n}\r\nelse {\r\nint done = 0;\r\nstart = SCHEDULE_SLOP + (now & ~0x07);\r\nnext = start;\r\nstart += period;\r\ndo {\r\nstart--;\r\nif (itd_slot_ok(fusbh200, mod, start,\r\nstream->usecs, period))\r\ndone = 1;\r\n} while (start > next && !done);\r\nif (!done) {\r\nfusbh200_dbg(fusbh200, "iso resched full %p (now %d max %d)\n",\r\nurb, now, now + mod);\r\nstatus = -ENOSPC;\r\ngoto fail;\r\n}\r\n}\r\nif (unlikely(start - now + span - period\r\n>= mod - 2 * SCHEDULE_SLOP)) {\r\nfusbh200_dbg(fusbh200, "request %p would overflow (%d+%d >= %d)\n",\r\nurb, start - now, span - period,\r\nmod - 2 * SCHEDULE_SLOP);\r\nstatus = -EFBIG;\r\ngoto fail;\r\n}\r\nstream->next_uframe = start & (mod - 1);\r\nurb->start_frame = stream->next_uframe;\r\nif (!stream->highspeed)\r\nurb->start_frame >>= 3;\r\nif (fusbh200->isoc_count == 0)\r\nfusbh200->next_frame = now >> 3;\r\nreturn 0;\r\nfail:\r\niso_sched_free(stream, sched);\r\nurb->hcpriv = NULL;\r\nreturn status;\r\n}\r\nstatic inline void\r\nitd_init(struct fusbh200_hcd *fusbh200, struct fusbh200_iso_stream *stream,\r\nstruct fusbh200_itd *itd)\r\n{\r\nint i;\r\nitd->hw_next = FUSBH200_LIST_END(fusbh200);\r\nitd->hw_bufp [0] = stream->buf0;\r\nitd->hw_bufp [1] = stream->buf1;\r\nitd->hw_bufp [2] = stream->buf2;\r\nfor (i = 0; i < 8; i++)\r\nitd->index[i] = -1;\r\n}\r\nstatic inline void\r\nitd_patch(\r\nstruct fusbh200_hcd *fusbh200,\r\nstruct fusbh200_itd *itd,\r\nstruct fusbh200_iso_sched *iso_sched,\r\nunsigned index,\r\nu16 uframe\r\n)\r\n{\r\nstruct fusbh200_iso_packet *uf = &iso_sched->packet [index];\r\nunsigned pg = itd->pg;\r\nuframe &= 0x07;\r\nitd->index [uframe] = index;\r\nitd->hw_transaction[uframe] = uf->transaction;\r\nitd->hw_transaction[uframe] |= cpu_to_hc32(fusbh200, pg << 12);\r\nitd->hw_bufp[pg] |= cpu_to_hc32(fusbh200, uf->bufp & ~(u32)0);\r\nitd->hw_bufp_hi[pg] |= cpu_to_hc32(fusbh200, (u32)(uf->bufp >> 32));\r\nif (unlikely (uf->cross)) {\r\nu64 bufp = uf->bufp + 4096;\r\nitd->pg = ++pg;\r\nitd->hw_bufp[pg] |= cpu_to_hc32(fusbh200, bufp & ~(u32)0);\r\nitd->hw_bufp_hi[pg] |= cpu_to_hc32(fusbh200, (u32)(bufp >> 32));\r\n}\r\n}\r\nstatic inline void\r\nitd_link (struct fusbh200_hcd *fusbh200, unsigned frame, struct fusbh200_itd *itd)\r\n{\r\nunion fusbh200_shadow *prev = &fusbh200->pshadow[frame];\r\n__hc32 *hw_p = &fusbh200->periodic[frame];\r\nunion fusbh200_shadow here = *prev;\r\n__hc32 type = 0;\r\nwhile (here.ptr) {\r\ntype = Q_NEXT_TYPE(fusbh200, *hw_p);\r\nif (type == cpu_to_hc32(fusbh200, Q_TYPE_QH))\r\nbreak;\r\nprev = periodic_next_shadow(fusbh200, prev, type);\r\nhw_p = shadow_next_periodic(fusbh200, &here, type);\r\nhere = *prev;\r\n}\r\nitd->itd_next = here;\r\nitd->hw_next = *hw_p;\r\nprev->itd = itd;\r\nitd->frame = frame;\r\nwmb ();\r\n*hw_p = cpu_to_hc32(fusbh200, itd->itd_dma | Q_TYPE_ITD);\r\n}\r\nstatic void itd_link_urb(\r\nstruct fusbh200_hcd *fusbh200,\r\nstruct urb *urb,\r\nunsigned mod,\r\nstruct fusbh200_iso_stream *stream\r\n)\r\n{\r\nint packet;\r\nunsigned next_uframe, uframe, frame;\r\nstruct fusbh200_iso_sched *iso_sched = urb->hcpriv;\r\nstruct fusbh200_itd *itd;\r\nnext_uframe = stream->next_uframe & (mod - 1);\r\nif (unlikely (list_empty(&stream->td_list))) {\r\nfusbh200_to_hcd(fusbh200)->self.bandwidth_allocated\r\n+= stream->bandwidth;\r\nfusbh200_dbg(fusbh200,\r\n"schedule devp %s ep%d%s-iso period %d start %d.%d\n",\r\nurb->dev->devpath, stream->bEndpointAddress & 0x0f,\r\n(stream->bEndpointAddress & USB_DIR_IN) ? "in" : "out",\r\nurb->interval,\r\nnext_uframe >> 3, next_uframe & 0x7);\r\n}\r\nfor (packet = 0, itd = NULL; packet < urb->number_of_packets; ) {\r\nif (itd == NULL) {\r\nitd = list_entry (iso_sched->td_list.next,\r\nstruct fusbh200_itd, itd_list);\r\nlist_move_tail (&itd->itd_list, &stream->td_list);\r\nitd->stream = stream;\r\nitd->urb = urb;\r\nitd_init (fusbh200, stream, itd);\r\n}\r\nuframe = next_uframe & 0x07;\r\nframe = next_uframe >> 3;\r\nitd_patch(fusbh200, itd, iso_sched, packet, uframe);\r\nnext_uframe += stream->interval;\r\nnext_uframe &= mod - 1;\r\npacket++;\r\nif (((next_uframe >> 3) != frame)\r\n|| packet == urb->number_of_packets) {\r\nitd_link(fusbh200, frame & (fusbh200->periodic_size - 1), itd);\r\nitd = NULL;\r\n}\r\n}\r\nstream->next_uframe = next_uframe;\r\niso_sched_free (stream, iso_sched);\r\nurb->hcpriv = NULL;\r\n++fusbh200->isoc_count;\r\nenable_periodic(fusbh200);\r\n}\r\nstatic bool itd_complete(struct fusbh200_hcd *fusbh200, struct fusbh200_itd *itd)\r\n{\r\nstruct urb *urb = itd->urb;\r\nstruct usb_iso_packet_descriptor *desc;\r\nu32 t;\r\nunsigned uframe;\r\nint urb_index = -1;\r\nstruct fusbh200_iso_stream *stream = itd->stream;\r\nstruct usb_device *dev;\r\nbool retval = false;\r\nfor (uframe = 0; uframe < 8; uframe++) {\r\nif (likely (itd->index[uframe] == -1))\r\ncontinue;\r\nurb_index = itd->index[uframe];\r\ndesc = &urb->iso_frame_desc [urb_index];\r\nt = hc32_to_cpup(fusbh200, &itd->hw_transaction [uframe]);\r\nitd->hw_transaction [uframe] = 0;\r\nif (unlikely (t & ISO_ERRS)) {\r\nurb->error_count++;\r\nif (t & FUSBH200_ISOC_BUF_ERR)\r\ndesc->status = usb_pipein (urb->pipe)\r\n? -ENOSR\r\n: -ECOMM;\r\nelse if (t & FUSBH200_ISOC_BABBLE)\r\ndesc->status = -EOVERFLOW;\r\nelse\r\ndesc->status = -EPROTO;\r\nif (!(t & FUSBH200_ISOC_BABBLE)) {\r\ndesc->actual_length = fusbh200_itdlen(urb, desc, t);\r\nurb->actual_length += desc->actual_length;\r\n}\r\n} else if (likely ((t & FUSBH200_ISOC_ACTIVE) == 0)) {\r\ndesc->status = 0;\r\ndesc->actual_length = fusbh200_itdlen(urb, desc, t);\r\nurb->actual_length += desc->actual_length;\r\n} else {\r\ndesc->status = -EXDEV;\r\n}\r\n}\r\nif (likely ((urb_index + 1) != urb->number_of_packets))\r\ngoto done;\r\ndev = urb->dev;\r\nfusbh200_urb_done(fusbh200, urb, 0);\r\nretval = true;\r\nurb = NULL;\r\n--fusbh200->isoc_count;\r\ndisable_periodic(fusbh200);\r\nif (unlikely(list_is_singular(&stream->td_list))) {\r\nfusbh200_to_hcd(fusbh200)->self.bandwidth_allocated\r\n-= stream->bandwidth;\r\nfusbh200_dbg(fusbh200,\r\n"deschedule devp %s ep%d%s-iso\n",\r\ndev->devpath, stream->bEndpointAddress & 0x0f,\r\n(stream->bEndpointAddress & USB_DIR_IN) ? "in" : "out");\r\n}\r\ndone:\r\nitd->urb = NULL;\r\nlist_move_tail(&itd->itd_list, &stream->free_list);\r\nif (list_empty(&stream->td_list)) {\r\nlist_splice_tail_init(&stream->free_list,\r\n&fusbh200->cached_itd_list);\r\nstart_free_itds(fusbh200);\r\n}\r\nreturn retval;\r\n}\r\nstatic int itd_submit (struct fusbh200_hcd *fusbh200, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nint status = -EINVAL;\r\nunsigned long flags;\r\nstruct fusbh200_iso_stream *stream;\r\nstream = iso_stream_find (fusbh200, urb);\r\nif (unlikely (stream == NULL)) {\r\nfusbh200_dbg (fusbh200, "can't get iso stream\n");\r\nreturn -ENOMEM;\r\n}\r\nif (unlikely (urb->interval != stream->interval &&\r\nfusbh200_port_speed(fusbh200, 0) == USB_PORT_STAT_HIGH_SPEED)) {\r\nfusbh200_dbg (fusbh200, "can't change iso interval %d --> %d\n",\r\nstream->interval, urb->interval);\r\ngoto done;\r\n}\r\n#ifdef FUSBH200_URB_TRACE\r\nfusbh200_dbg (fusbh200,\r\n"%s %s urb %p ep%d%s len %d, %d pkts %d uframes [%p]\n",\r\n__func__, urb->dev->devpath, urb,\r\nusb_pipeendpoint (urb->pipe),\r\nusb_pipein (urb->pipe) ? "in" : "out",\r\nurb->transfer_buffer_length,\r\nurb->number_of_packets, urb->interval,\r\nstream);\r\n#endif\r\nstatus = itd_urb_transaction (stream, fusbh200, urb, mem_flags);\r\nif (unlikely (status < 0)) {\r\nfusbh200_dbg (fusbh200, "can't init itds\n");\r\ngoto done;\r\n}\r\nspin_lock_irqsave (&fusbh200->lock, flags);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(fusbh200_to_hcd(fusbh200)))) {\r\nstatus = -ESHUTDOWN;\r\ngoto done_not_linked;\r\n}\r\nstatus = usb_hcd_link_urb_to_ep(fusbh200_to_hcd(fusbh200), urb);\r\nif (unlikely(status))\r\ngoto done_not_linked;\r\nstatus = iso_stream_schedule(fusbh200, urb, stream);\r\nif (likely (status == 0))\r\nitd_link_urb (fusbh200, urb, fusbh200->periodic_size << 3, stream);\r\nelse\r\nusb_hcd_unlink_urb_from_ep(fusbh200_to_hcd(fusbh200), urb);\r\ndone_not_linked:\r\nspin_unlock_irqrestore (&fusbh200->lock, flags);\r\ndone:\r\nreturn status;\r\n}\r\nstatic void scan_isoc(struct fusbh200_hcd *fusbh200)\r\n{\r\nunsigned uf, now_frame, frame;\r\nunsigned fmask = fusbh200->periodic_size - 1;\r\nbool modified, live;\r\nif (fusbh200->rh_state >= FUSBH200_RH_RUNNING) {\r\nuf = fusbh200_read_frame_index(fusbh200);\r\nnow_frame = (uf >> 3) & fmask;\r\nlive = true;\r\n} else {\r\nnow_frame = (fusbh200->next_frame - 1) & fmask;\r\nlive = false;\r\n}\r\nfusbh200->now_frame = now_frame;\r\nframe = fusbh200->next_frame;\r\nfor (;;) {\r\nunion fusbh200_shadow q, *q_p;\r\n__hc32 type, *hw_p;\r\nrestart:\r\nq_p = &fusbh200->pshadow [frame];\r\nhw_p = &fusbh200->periodic [frame];\r\nq.ptr = q_p->ptr;\r\ntype = Q_NEXT_TYPE(fusbh200, *hw_p);\r\nmodified = false;\r\nwhile (q.ptr != NULL) {\r\nswitch (hc32_to_cpu(fusbh200, type)) {\r\ncase Q_TYPE_ITD:\r\nif (frame == now_frame && live) {\r\nrmb();\r\nfor (uf = 0; uf < 8; uf++) {\r\nif (q.itd->hw_transaction[uf] &\r\nITD_ACTIVE(fusbh200))\r\nbreak;\r\n}\r\nif (uf < 8) {\r\nq_p = &q.itd->itd_next;\r\nhw_p = &q.itd->hw_next;\r\ntype = Q_NEXT_TYPE(fusbh200,\r\nq.itd->hw_next);\r\nq = *q_p;\r\nbreak;\r\n}\r\n}\r\n*q_p = q.itd->itd_next;\r\n*hw_p = q.itd->hw_next;\r\ntype = Q_NEXT_TYPE(fusbh200, q.itd->hw_next);\r\nwmb();\r\nmodified = itd_complete (fusbh200, q.itd);\r\nq = *q_p;\r\nbreak;\r\ndefault:\r\nfusbh200_dbg(fusbh200, "corrupt type %d frame %d shadow %p\n",\r\ntype, frame, q.ptr);\r\ncase Q_TYPE_QH:\r\ncase Q_TYPE_FSTN:\r\nq.ptr = NULL;\r\nbreak;\r\n}\r\nif (unlikely(modified && fusbh200->isoc_count > 0))\r\ngoto restart;\r\n}\r\nif (frame == now_frame)\r\nbreak;\r\nframe = (frame + 1) & fmask;\r\n}\r\nfusbh200->next_frame = now_frame;\r\n}\r\nstatic ssize_t show_uframe_periodic_max(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fusbh200_hcd *fusbh200;\r\nint n;\r\nfusbh200 = hcd_to_fusbh200(bus_to_hcd(dev_get_drvdata(dev)));\r\nn = scnprintf(buf, PAGE_SIZE, "%d\n", fusbh200->uframe_periodic_max);\r\nreturn n;\r\n}\r\nstatic ssize_t store_uframe_periodic_max(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fusbh200_hcd *fusbh200;\r\nunsigned uframe_periodic_max;\r\nunsigned frame, uframe;\r\nunsigned short allocated_max;\r\nunsigned long flags;\r\nssize_t ret;\r\nfusbh200 = hcd_to_fusbh200(bus_to_hcd(dev_get_drvdata(dev)));\r\nif (kstrtouint(buf, 0, &uframe_periodic_max) < 0)\r\nreturn -EINVAL;\r\nif (uframe_periodic_max < 100 || uframe_periodic_max >= 125) {\r\nfusbh200_info(fusbh200, "rejecting invalid request for "\r\n"uframe_periodic_max=%u\n", uframe_periodic_max);\r\nreturn -EINVAL;\r\n}\r\nret = -EINVAL;\r\nspin_lock_irqsave (&fusbh200->lock, flags);\r\nif (uframe_periodic_max < fusbh200->uframe_periodic_max) {\r\nallocated_max = 0;\r\nfor (frame = 0; frame < fusbh200->periodic_size; ++frame)\r\nfor (uframe = 0; uframe < 7; ++uframe)\r\nallocated_max = max(allocated_max,\r\nperiodic_usecs (fusbh200, frame, uframe));\r\nif (allocated_max > uframe_periodic_max) {\r\nfusbh200_info(fusbh200,\r\n"cannot decrease uframe_periodic_max becase "\r\n"periodic bandwidth is already allocated "\r\n"(%u > %u)\n",\r\nallocated_max, uframe_periodic_max);\r\ngoto out_unlock;\r\n}\r\n}\r\nfusbh200_info(fusbh200, "setting max periodic bandwidth to %u%% "\r\n"(== %u usec/uframe)\n",\r\n100*uframe_periodic_max/125, uframe_periodic_max);\r\nif (uframe_periodic_max != 100)\r\nfusbh200_warn(fusbh200, "max periodic bandwidth set is non-standard\n");\r\nfusbh200->uframe_periodic_max = uframe_periodic_max;\r\nret = count;\r\nout_unlock:\r\nspin_unlock_irqrestore (&fusbh200->lock, flags);\r\nreturn ret;\r\n}\r\nstatic inline int create_sysfs_files(struct fusbh200_hcd *fusbh200)\r\n{\r\nstruct device *controller = fusbh200_to_hcd(fusbh200)->self.controller;\r\nint i = 0;\r\nif (i)\r\ngoto out;\r\ni = device_create_file(controller, &dev_attr_uframe_periodic_max);\r\nout:\r\nreturn i;\r\n}\r\nstatic inline void remove_sysfs_files(struct fusbh200_hcd *fusbh200)\r\n{\r\nstruct device *controller = fusbh200_to_hcd(fusbh200)->self.controller;\r\ndevice_remove_file(controller, &dev_attr_uframe_periodic_max);\r\n}\r\nstatic void fusbh200_turn_off_all_ports(struct fusbh200_hcd *fusbh200)\r\n{\r\nu32 __iomem *status_reg = &fusbh200->regs->port_status;\r\nfusbh200_writel(fusbh200, PORT_RWC_BITS, status_reg);\r\n}\r\nstatic void fusbh200_silence_controller(struct fusbh200_hcd *fusbh200)\r\n{\r\nfusbh200_halt(fusbh200);\r\nspin_lock_irq(&fusbh200->lock);\r\nfusbh200->rh_state = FUSBH200_RH_HALTED;\r\nfusbh200_turn_off_all_ports(fusbh200);\r\nspin_unlock_irq(&fusbh200->lock);\r\n}\r\nstatic void fusbh200_shutdown(struct usb_hcd *hcd)\r\n{\r\nstruct fusbh200_hcd *fusbh200 = hcd_to_fusbh200(hcd);\r\nspin_lock_irq(&fusbh200->lock);\r\nfusbh200->shutdown = true;\r\nfusbh200->rh_state = FUSBH200_RH_STOPPING;\r\nfusbh200->enabled_hrtimer_events = 0;\r\nspin_unlock_irq(&fusbh200->lock);\r\nfusbh200_silence_controller(fusbh200);\r\nhrtimer_cancel(&fusbh200->hrtimer);\r\n}\r\nstatic void fusbh200_work (struct fusbh200_hcd *fusbh200)\r\n{\r\nif (fusbh200->scanning) {\r\nfusbh200->need_rescan = true;\r\nreturn;\r\n}\r\nfusbh200->scanning = true;\r\nrescan:\r\nfusbh200->need_rescan = false;\r\nif (fusbh200->async_count)\r\nscan_async(fusbh200);\r\nif (fusbh200->intr_count > 0)\r\nscan_intr(fusbh200);\r\nif (fusbh200->isoc_count > 0)\r\nscan_isoc(fusbh200);\r\nif (fusbh200->need_rescan)\r\ngoto rescan;\r\nfusbh200->scanning = false;\r\nturn_on_io_watchdog(fusbh200);\r\n}\r\nstatic void fusbh200_stop (struct usb_hcd *hcd)\r\n{\r\nstruct fusbh200_hcd *fusbh200 = hcd_to_fusbh200 (hcd);\r\nfusbh200_dbg (fusbh200, "stop\n");\r\nspin_lock_irq(&fusbh200->lock);\r\nfusbh200->enabled_hrtimer_events = 0;\r\nspin_unlock_irq(&fusbh200->lock);\r\nfusbh200_quiesce(fusbh200);\r\nfusbh200_silence_controller(fusbh200);\r\nfusbh200_reset (fusbh200);\r\nhrtimer_cancel(&fusbh200->hrtimer);\r\nremove_sysfs_files(fusbh200);\r\nremove_debug_files (fusbh200);\r\nspin_lock_irq (&fusbh200->lock);\r\nend_free_itds(fusbh200);\r\nspin_unlock_irq (&fusbh200->lock);\r\nfusbh200_mem_cleanup (fusbh200);\r\nfusbh200_dbg(fusbh200, "irq normal %ld err %ld iaa %ld (lost %ld)\n",\r\nfusbh200->stats.normal, fusbh200->stats.error, fusbh200->stats.iaa,\r\nfusbh200->stats.lost_iaa);\r\nfusbh200_dbg (fusbh200, "complete %ld unlink %ld\n",\r\nfusbh200->stats.complete, fusbh200->stats.unlink);\r\ndbg_status (fusbh200, "fusbh200_stop completed",\r\nfusbh200_readl(fusbh200, &fusbh200->regs->status));\r\n}\r\nstatic int hcd_fusbh200_init(struct usb_hcd *hcd)\r\n{\r\nstruct fusbh200_hcd *fusbh200 = hcd_to_fusbh200(hcd);\r\nu32 temp;\r\nint retval;\r\nu32 hcc_params;\r\nstruct fusbh200_qh_hw *hw;\r\nspin_lock_init(&fusbh200->lock);\r\nfusbh200->need_io_watchdog = 1;\r\nhrtimer_init(&fusbh200->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\r\nfusbh200->hrtimer.function = fusbh200_hrtimer_func;\r\nfusbh200->next_hrtimer_event = FUSBH200_HRTIMER_NO_EVENT;\r\nhcc_params = fusbh200_readl(fusbh200, &fusbh200->caps->hcc_params);\r\nfusbh200->uframe_periodic_max = 100;\r\nfusbh200->periodic_size = DEFAULT_I_TDPS;\r\nINIT_LIST_HEAD(&fusbh200->intr_qh_list);\r\nINIT_LIST_HEAD(&fusbh200->cached_itd_list);\r\nif (HCC_PGM_FRAMELISTLEN(hcc_params)) {\r\nswitch (FUSBH200_TUNE_FLS) {\r\ncase 0: fusbh200->periodic_size = 1024; break;\r\ncase 1: fusbh200->periodic_size = 512; break;\r\ncase 2: fusbh200->periodic_size = 256; break;\r\ndefault: BUG();\r\n}\r\n}\r\nif ((retval = fusbh200_mem_init(fusbh200, GFP_KERNEL)) < 0)\r\nreturn retval;\r\nfusbh200->i_thresh = 2;\r\nfusbh200->async->qh_next.qh = NULL;\r\nhw = fusbh200->async->hw;\r\nhw->hw_next = QH_NEXT(fusbh200, fusbh200->async->qh_dma);\r\nhw->hw_info1 = cpu_to_hc32(fusbh200, QH_HEAD);\r\nhw->hw_token = cpu_to_hc32(fusbh200, QTD_STS_HALT);\r\nhw->hw_qtd_next = FUSBH200_LIST_END(fusbh200);\r\nfusbh200->async->qh_state = QH_STATE_LINKED;\r\nhw->hw_alt_next = QTD_NEXT(fusbh200, fusbh200->async->dummy->qtd_dma);\r\nif (log2_irq_thresh < 0 || log2_irq_thresh > 6)\r\nlog2_irq_thresh = 0;\r\ntemp = 1 << (16 + log2_irq_thresh);\r\nif (HCC_CANPARK(hcc_params)) {\r\nif (park) {\r\npark = min(park, (unsigned) 3);\r\ntemp |= CMD_PARK;\r\ntemp |= park << 8;\r\n}\r\nfusbh200_dbg(fusbh200, "park %d\n", park);\r\n}\r\nif (HCC_PGM_FRAMELISTLEN(hcc_params)) {\r\ntemp &= ~(3 << 2);\r\ntemp |= (FUSBH200_TUNE_FLS << 2);\r\n}\r\nfusbh200->command = temp;\r\nif (!(hcd->driver->flags & HCD_LOCAL_MEM))\r\nhcd->self.sg_tablesize = ~0;\r\nreturn 0;\r\n}\r\nstatic int fusbh200_run (struct usb_hcd *hcd)\r\n{\r\nstruct fusbh200_hcd *fusbh200 = hcd_to_fusbh200 (hcd);\r\nu32 temp;\r\nu32 hcc_params;\r\nhcd->uses_new_polling = 1;\r\nfusbh200_writel(fusbh200, fusbh200->periodic_dma, &fusbh200->regs->frame_list);\r\nfusbh200_writel(fusbh200, (u32)fusbh200->async->qh_dma, &fusbh200->regs->async_next);\r\nhcc_params = fusbh200_readl(fusbh200, &fusbh200->caps->hcc_params);\r\nfusbh200->command &= ~(CMD_IAAD|CMD_PSE|CMD_ASE|CMD_RESET);\r\nfusbh200->command |= CMD_RUN;\r\nfusbh200_writel(fusbh200, fusbh200->command, &fusbh200->regs->command);\r\ndbg_cmd (fusbh200, "init", fusbh200->command);\r\ndown_write(&ehci_cf_port_reset_rwsem);\r\nfusbh200->rh_state = FUSBH200_RH_RUNNING;\r\nfusbh200_readl(fusbh200, &fusbh200->regs->command);\r\nmsleep(5);\r\nup_write(&ehci_cf_port_reset_rwsem);\r\nfusbh200->last_periodic_enable = ktime_get_real();\r\ntemp = HC_VERSION(fusbh200, fusbh200_readl(fusbh200, &fusbh200->caps->hc_capbase));\r\nfusbh200_info (fusbh200,\r\n"USB %x.%x started, EHCI %x.%02x\n",\r\n((fusbh200->sbrn & 0xf0)>>4), (fusbh200->sbrn & 0x0f),\r\ntemp >> 8, temp & 0xff);\r\nfusbh200_writel(fusbh200, INTR_MASK,\r\n&fusbh200->regs->intr_enable);\r\ncreate_debug_files(fusbh200);\r\ncreate_sysfs_files(fusbh200);\r\nreturn 0;\r\n}\r\nstatic int fusbh200_setup(struct usb_hcd *hcd)\r\n{\r\nstruct fusbh200_hcd *fusbh200 = hcd_to_fusbh200(hcd);\r\nint retval;\r\nfusbh200->regs = (void __iomem *)fusbh200->caps +\r\nHC_LENGTH(fusbh200, fusbh200_readl(fusbh200, &fusbh200->caps->hc_capbase));\r\ndbg_hcs_params(fusbh200, "reset");\r\ndbg_hcc_params(fusbh200, "reset");\r\nfusbh200->hcs_params = fusbh200_readl(fusbh200, &fusbh200->caps->hcs_params);\r\nfusbh200->sbrn = HCD_USB2;\r\nretval = hcd_fusbh200_init(hcd);\r\nif (retval)\r\nreturn retval;\r\nretval = fusbh200_halt(fusbh200);\r\nif (retval)\r\nreturn retval;\r\nfusbh200_reset(fusbh200);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t fusbh200_irq (struct usb_hcd *hcd)\r\n{\r\nstruct fusbh200_hcd *fusbh200 = hcd_to_fusbh200 (hcd);\r\nu32 status, masked_status, pcd_status = 0, cmd;\r\nint bh;\r\nspin_lock (&fusbh200->lock);\r\nstatus = fusbh200_readl(fusbh200, &fusbh200->regs->status);\r\nif (status == ~(u32) 0) {\r\nfusbh200_dbg (fusbh200, "device removed\n");\r\ngoto dead;\r\n}\r\nmasked_status = status & (INTR_MASK | STS_FLR);\r\nif (!masked_status || unlikely(fusbh200->rh_state == FUSBH200_RH_HALTED)) {\r\nspin_unlock(&fusbh200->lock);\r\nreturn IRQ_NONE;\r\n}\r\nfusbh200_writel(fusbh200, masked_status, &fusbh200->regs->status);\r\ncmd = fusbh200_readl(fusbh200, &fusbh200->regs->command);\r\nbh = 0;\r\nif (likely ((status & (STS_INT|STS_ERR)) != 0)) {\r\nif (likely ((status & STS_ERR) == 0))\r\nCOUNT (fusbh200->stats.normal);\r\nelse\r\nCOUNT (fusbh200->stats.error);\r\nbh = 1;\r\n}\r\nif (status & STS_IAA) {\r\nfusbh200->enabled_hrtimer_events &= ~BIT(FUSBH200_HRTIMER_IAA_WATCHDOG);\r\nif (fusbh200->next_hrtimer_event == FUSBH200_HRTIMER_IAA_WATCHDOG)\r\n++fusbh200->next_hrtimer_event;\r\nif (cmd & CMD_IAAD)\r\nfusbh200_dbg(fusbh200, "IAA with IAAD still set?\n");\r\nif (fusbh200->async_iaa) {\r\nCOUNT(fusbh200->stats.iaa);\r\nend_unlink_async(fusbh200);\r\n} else\r\nfusbh200_dbg(fusbh200, "IAA with nothing unlinked?\n");\r\n}\r\nif (status & STS_PCD) {\r\nint pstatus;\r\nu32 __iomem *status_reg = &fusbh200->regs->port_status;\r\npcd_status = status;\r\nif (fusbh200->rh_state == FUSBH200_RH_SUSPENDED)\r\nusb_hcd_resume_root_hub(hcd);\r\npstatus = fusbh200_readl(fusbh200, status_reg);\r\nif (test_bit(0, &fusbh200->suspended_ports) &&\r\n((pstatus & PORT_RESUME) ||\r\n!(pstatus & PORT_SUSPEND)) &&\r\n(pstatus & PORT_PE) &&\r\nfusbh200->reset_done[0] == 0) {\r\nfusbh200->reset_done[0] = jiffies + msecs_to_jiffies(25);\r\nset_bit(0, &fusbh200->resuming_ports);\r\nfusbh200_dbg (fusbh200, "port 1 remote wakeup\n");\r\nmod_timer(&hcd->rh_timer, fusbh200->reset_done[0]);\r\n}\r\n}\r\nif (unlikely ((status & STS_FATAL) != 0)) {\r\nfusbh200_err(fusbh200, "fatal error\n");\r\ndbg_cmd(fusbh200, "fatal", cmd);\r\ndbg_status(fusbh200, "fatal", status);\r\ndead:\r\nusb_hc_died(hcd);\r\nfusbh200->shutdown = true;\r\nfusbh200->rh_state = FUSBH200_RH_STOPPING;\r\nfusbh200->command &= ~(CMD_RUN | CMD_ASE | CMD_PSE);\r\nfusbh200_writel(fusbh200, fusbh200->command, &fusbh200->regs->command);\r\nfusbh200_writel(fusbh200, 0, &fusbh200->regs->intr_enable);\r\nfusbh200_handle_controller_death(fusbh200);\r\nbh = 0;\r\n}\r\nif (bh)\r\nfusbh200_work (fusbh200);\r\nspin_unlock (&fusbh200->lock);\r\nif (pcd_status)\r\nusb_hcd_poll_rh_status(hcd);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fusbh200_urb_enqueue (\r\nstruct usb_hcd *hcd,\r\nstruct urb *urb,\r\ngfp_t mem_flags\r\n) {\r\nstruct fusbh200_hcd *fusbh200 = hcd_to_fusbh200 (hcd);\r\nstruct list_head qtd_list;\r\nINIT_LIST_HEAD (&qtd_list);\r\nswitch (usb_pipetype (urb->pipe)) {\r\ncase PIPE_CONTROL:\r\nif (urb->transfer_buffer_length > (16 * 1024))\r\nreturn -EMSGSIZE;\r\ndefault:\r\nif (!qh_urb_transaction (fusbh200, urb, &qtd_list, mem_flags))\r\nreturn -ENOMEM;\r\nreturn submit_async(fusbh200, urb, &qtd_list, mem_flags);\r\ncase PIPE_INTERRUPT:\r\nif (!qh_urb_transaction (fusbh200, urb, &qtd_list, mem_flags))\r\nreturn -ENOMEM;\r\nreturn intr_submit(fusbh200, urb, &qtd_list, mem_flags);\r\ncase PIPE_ISOCHRONOUS:\r\nreturn itd_submit (fusbh200, urb, mem_flags);\r\n}\r\n}\r\nstatic int fusbh200_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct fusbh200_hcd *fusbh200 = hcd_to_fusbh200 (hcd);\r\nstruct fusbh200_qh *qh;\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave (&fusbh200->lock, flags);\r\nrc = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (rc)\r\ngoto done;\r\nswitch (usb_pipetype (urb->pipe)) {\r\ndefault:\r\nqh = (struct fusbh200_qh *) urb->hcpriv;\r\nif (!qh)\r\nbreak;\r\nswitch (qh->qh_state) {\r\ncase QH_STATE_LINKED:\r\ncase QH_STATE_COMPLETING:\r\nstart_unlink_async(fusbh200, qh);\r\nbreak;\r\ncase QH_STATE_UNLINK:\r\ncase QH_STATE_UNLINK_WAIT:\r\nbreak;\r\ncase QH_STATE_IDLE:\r\nqh_completions(fusbh200, qh);\r\nbreak;\r\n}\r\nbreak;\r\ncase PIPE_INTERRUPT:\r\nqh = (struct fusbh200_qh *) urb->hcpriv;\r\nif (!qh)\r\nbreak;\r\nswitch (qh->qh_state) {\r\ncase QH_STATE_LINKED:\r\ncase QH_STATE_COMPLETING:\r\nstart_unlink_intr(fusbh200, qh);\r\nbreak;\r\ncase QH_STATE_IDLE:\r\nqh_completions (fusbh200, qh);\r\nbreak;\r\ndefault:\r\nfusbh200_dbg (fusbh200, "bogus qh %p state %d\n",\r\nqh, qh->qh_state);\r\ngoto done;\r\n}\r\nbreak;\r\ncase PIPE_ISOCHRONOUS:\r\nbreak;\r\n}\r\ndone:\r\nspin_unlock_irqrestore (&fusbh200->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void\r\nfusbh200_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)\r\n{\r\nstruct fusbh200_hcd *fusbh200 = hcd_to_fusbh200 (hcd);\r\nunsigned long flags;\r\nstruct fusbh200_qh *qh, *tmp;\r\nrescan:\r\nspin_lock_irqsave (&fusbh200->lock, flags);\r\nqh = ep->hcpriv;\r\nif (!qh)\r\ngoto done;\r\nif (qh->hw == NULL) {\r\nstruct fusbh200_iso_stream *stream = ep->hcpriv;\r\nif (!list_empty(&stream->td_list))\r\ngoto idle_timeout;\r\nkfree(stream);\r\ngoto done;\r\n}\r\nif (fusbh200->rh_state < FUSBH200_RH_RUNNING)\r\nqh->qh_state = QH_STATE_IDLE;\r\nswitch (qh->qh_state) {\r\ncase QH_STATE_LINKED:\r\ncase QH_STATE_COMPLETING:\r\nfor (tmp = fusbh200->async->qh_next.qh;\r\ntmp && tmp != qh;\r\ntmp = tmp->qh_next.qh)\r\ncontinue;\r\nif (tmp)\r\nstart_unlink_async(fusbh200, qh);\r\ncase QH_STATE_UNLINK:\r\ncase QH_STATE_UNLINK_WAIT:\r\nidle_timeout:\r\nspin_unlock_irqrestore (&fusbh200->lock, flags);\r\nschedule_timeout_uninterruptible(1);\r\ngoto rescan;\r\ncase QH_STATE_IDLE:\r\nif (qh->clearing_tt)\r\ngoto idle_timeout;\r\nif (list_empty (&qh->qtd_list)) {\r\nqh_destroy(fusbh200, qh);\r\nbreak;\r\n}\r\ndefault:\r\nfusbh200_err (fusbh200, "qh %p (#%02x) state %d%s\n",\r\nqh, ep->desc.bEndpointAddress, qh->qh_state,\r\nlist_empty (&qh->qtd_list) ? "" : "(has tds)");\r\nbreak;\r\n}\r\ndone:\r\nep->hcpriv = NULL;\r\nspin_unlock_irqrestore (&fusbh200->lock, flags);\r\n}\r\nstatic void\r\nfusbh200_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)\r\n{\r\nstruct fusbh200_hcd *fusbh200 = hcd_to_fusbh200(hcd);\r\nstruct fusbh200_qh *qh;\r\nint eptype = usb_endpoint_type(&ep->desc);\r\nint epnum = usb_endpoint_num(&ep->desc);\r\nint is_out = usb_endpoint_dir_out(&ep->desc);\r\nunsigned long flags;\r\nif (eptype != USB_ENDPOINT_XFER_BULK && eptype != USB_ENDPOINT_XFER_INT)\r\nreturn;\r\nspin_lock_irqsave(&fusbh200->lock, flags);\r\nqh = ep->hcpriv;\r\nif (qh) {\r\nusb_settoggle(qh->dev, epnum, is_out, 0);\r\nif (!list_empty(&qh->qtd_list)) {\r\nWARN_ONCE(1, "clear_halt for a busy endpoint\n");\r\n} else if (qh->qh_state == QH_STATE_LINKED ||\r\nqh->qh_state == QH_STATE_COMPLETING) {\r\nif (eptype == USB_ENDPOINT_XFER_BULK)\r\nstart_unlink_async(fusbh200, qh);\r\nelse\r\nstart_unlink_intr(fusbh200, qh);\r\n}\r\n}\r\nspin_unlock_irqrestore(&fusbh200->lock, flags);\r\n}\r\nstatic int fusbh200_get_frame (struct usb_hcd *hcd)\r\n{\r\nstruct fusbh200_hcd *fusbh200 = hcd_to_fusbh200 (hcd);\r\nreturn (fusbh200_read_frame_index(fusbh200) >> 3) % fusbh200->periodic_size;\r\n}\r\nstatic void fusbh200_init(struct fusbh200_hcd *fusbh200)\r\n{\r\nu32 reg;\r\nreg = fusbh200_readl(fusbh200, &fusbh200->regs->bmcsr);\r\nreg |= BMCSR_INT_POLARITY;\r\nreg &= ~BMCSR_VBUS_OFF;\r\nfusbh200_writel(fusbh200, reg, &fusbh200->regs->bmcsr);\r\nreg = fusbh200_readl(fusbh200, &fusbh200->regs->bmier);\r\nfusbh200_writel(fusbh200, reg | BMIER_OVC_EN | BMIER_VBUS_ERR_EN,\r\n&fusbh200->regs->bmier);\r\n}\r\nstatic int fusbh200_hcd_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct usb_hcd *hcd;\r\nstruct resource *res;\r\nint irq;\r\nint retval = -ENODEV;\r\nstruct fusbh200_hcd *fusbh200;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npdev->dev.power.power_state = PMSG_ON;\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\ndev_err(dev,\r\n"Found HC with no IRQ. Check %s setup!\n",\r\ndev_name(dev));\r\nreturn -ENODEV;\r\n}\r\nirq = res->start;\r\nhcd = usb_create_hcd(&fusbh200_fusbh200_hc_driver, dev,\r\ndev_name(dev));\r\nif (!hcd) {\r\ndev_err(dev, "failed to create hcd with err %d\n", retval);\r\nretval = -ENOMEM;\r\ngoto fail_create_hcd;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev,\r\n"Found HC with no register addr. Check %s setup!\n",\r\ndev_name(dev));\r\nretval = -ENODEV;\r\ngoto fail_request_resource;\r\n}\r\nhcd->rsrc_start = res->start;\r\nhcd->rsrc_len = resource_size(res);\r\nhcd->has_tt = 1;\r\nif (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,\r\nfusbh200_fusbh200_hc_driver.description)) {\r\ndev_dbg(dev, "controller already in use\n");\r\nretval = -EBUSY;\r\ngoto fail_request_resource;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!res) {\r\ndev_err(dev,\r\n"Found HC with no register addr. Check %s setup!\n",\r\ndev_name(dev));\r\nretval = -ENODEV;\r\ngoto fail_request_resource;\r\n}\r\nhcd->regs = ioremap_nocache(res->start, resource_size(res));\r\nif (hcd->regs == NULL) {\r\ndev_dbg(dev, "error mapping memory\n");\r\nretval = -EFAULT;\r\ngoto fail_ioremap;\r\n}\r\nfusbh200 = hcd_to_fusbh200(hcd);\r\nfusbh200->caps = hcd->regs;\r\nretval = fusbh200_setup(hcd);\r\nif (retval)\r\ngoto fail_add_hcd;\r\nfusbh200_init(fusbh200);\r\nretval = usb_add_hcd(hcd, irq, IRQF_SHARED);\r\nif (retval) {\r\ndev_err(dev, "failed to add hcd with err %d\n", retval);\r\ngoto fail_add_hcd;\r\n}\r\ndevice_wakeup_enable(hcd->self.controller);\r\nreturn retval;\r\nfail_add_hcd:\r\niounmap(hcd->regs);\r\nfail_ioremap:\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nfail_request_resource:\r\nusb_put_hcd(hcd);\r\nfail_create_hcd:\r\ndev_err(dev, "init %s fail, %d\n", dev_name(dev), retval);\r\nreturn retval;\r\n}\r\nstatic int fusbh200_hcd_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct usb_hcd *hcd = dev_get_drvdata(dev);\r\nif (!hcd)\r\nreturn 0;\r\nusb_remove_hcd(hcd);\r\niounmap(hcd->regs);\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nusb_put_hcd(hcd);\r\nreturn 0;\r\n}\r\nstatic int __init fusbh200_hcd_init(void)\r\n{\r\nint retval = 0;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nprintk(KERN_INFO "%s: " DRIVER_DESC "\n", hcd_name);\r\nset_bit(USB_EHCI_LOADED, &usb_hcds_loaded);\r\nif (test_bit(USB_UHCI_LOADED, &usb_hcds_loaded) ||\r\ntest_bit(USB_OHCI_LOADED, &usb_hcds_loaded))\r\nprintk(KERN_WARNING "Warning! fusbh200_hcd should always be loaded"\r\n" before uhci_hcd and ohci_hcd, not after\n");\r\npr_debug("%s: block sizes: qh %Zd qtd %Zd itd %Zd\n",\r\nhcd_name,\r\nsizeof(struct fusbh200_qh), sizeof(struct fusbh200_qtd),\r\nsizeof(struct fusbh200_itd));\r\nfusbh200_debug_root = debugfs_create_dir("fusbh200", usb_debug_root);\r\nif (!fusbh200_debug_root) {\r\nretval = -ENOENT;\r\ngoto err_debug;\r\n}\r\nretval = platform_driver_register(&fusbh200_hcd_fusbh200_driver);\r\nif (retval < 0)\r\ngoto clean;\r\nreturn retval;\r\nplatform_driver_unregister(&fusbh200_hcd_fusbh200_driver);\r\nclean:\r\ndebugfs_remove(fusbh200_debug_root);\r\nfusbh200_debug_root = NULL;\r\nerr_debug:\r\nclear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);\r\nreturn retval;\r\n}\r\nstatic void __exit fusbh200_hcd_cleanup(void)\r\n{\r\nplatform_driver_unregister(&fusbh200_hcd_fusbh200_driver);\r\ndebugfs_remove(fusbh200_debug_root);\r\nclear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);\r\n}
