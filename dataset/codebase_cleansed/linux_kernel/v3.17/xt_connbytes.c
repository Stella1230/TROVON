static bool\r\nconnbytes_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_connbytes_info *sinfo = par->matchinfo;\r\nconst struct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\nu_int64_t what = 0;\r\nu_int64_t bytes = 0;\r\nu_int64_t pkts = 0;\r\nconst struct nf_conn_acct *acct;\r\nconst struct nf_conn_counter *counters;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (!ct)\r\nreturn false;\r\nacct = nf_conn_acct_find(ct);\r\nif (!acct)\r\nreturn false;\r\ncounters = acct->counter;\r\nswitch (sinfo->what) {\r\ncase XT_CONNBYTES_PKTS:\r\nswitch (sinfo->direction) {\r\ncase XT_CONNBYTES_DIR_ORIGINAL:\r\nwhat = atomic64_read(&counters[IP_CT_DIR_ORIGINAL].packets);\r\nbreak;\r\ncase XT_CONNBYTES_DIR_REPLY:\r\nwhat = atomic64_read(&counters[IP_CT_DIR_REPLY].packets);\r\nbreak;\r\ncase XT_CONNBYTES_DIR_BOTH:\r\nwhat = atomic64_read(&counters[IP_CT_DIR_ORIGINAL].packets);\r\nwhat += atomic64_read(&counters[IP_CT_DIR_REPLY].packets);\r\nbreak;\r\n}\r\nbreak;\r\ncase XT_CONNBYTES_BYTES:\r\nswitch (sinfo->direction) {\r\ncase XT_CONNBYTES_DIR_ORIGINAL:\r\nwhat = atomic64_read(&counters[IP_CT_DIR_ORIGINAL].bytes);\r\nbreak;\r\ncase XT_CONNBYTES_DIR_REPLY:\r\nwhat = atomic64_read(&counters[IP_CT_DIR_REPLY].bytes);\r\nbreak;\r\ncase XT_CONNBYTES_DIR_BOTH:\r\nwhat = atomic64_read(&counters[IP_CT_DIR_ORIGINAL].bytes);\r\nwhat += atomic64_read(&counters[IP_CT_DIR_REPLY].bytes);\r\nbreak;\r\n}\r\nbreak;\r\ncase XT_CONNBYTES_AVGPKT:\r\nswitch (sinfo->direction) {\r\ncase XT_CONNBYTES_DIR_ORIGINAL:\r\nbytes = atomic64_read(&counters[IP_CT_DIR_ORIGINAL].bytes);\r\npkts = atomic64_read(&counters[IP_CT_DIR_ORIGINAL].packets);\r\nbreak;\r\ncase XT_CONNBYTES_DIR_REPLY:\r\nbytes = atomic64_read(&counters[IP_CT_DIR_REPLY].bytes);\r\npkts = atomic64_read(&counters[IP_CT_DIR_REPLY].packets);\r\nbreak;\r\ncase XT_CONNBYTES_DIR_BOTH:\r\nbytes = atomic64_read(&counters[IP_CT_DIR_ORIGINAL].bytes) +\r\natomic64_read(&counters[IP_CT_DIR_REPLY].bytes);\r\npkts = atomic64_read(&counters[IP_CT_DIR_ORIGINAL].packets) +\r\natomic64_read(&counters[IP_CT_DIR_REPLY].packets);\r\nbreak;\r\n}\r\nif (pkts != 0)\r\nwhat = div64_u64(bytes, pkts);\r\nbreak;\r\n}\r\nif (sinfo->count.to >= sinfo->count.from)\r\nreturn what <= sinfo->count.to && what >= sinfo->count.from;\r\nelse\r\nreturn what < sinfo->count.to || what > sinfo->count.from;\r\n}\r\nstatic int connbytes_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_connbytes_info *sinfo = par->matchinfo;\r\nint ret;\r\nif (sinfo->what != XT_CONNBYTES_PKTS &&\r\nsinfo->what != XT_CONNBYTES_BYTES &&\r\nsinfo->what != XT_CONNBYTES_AVGPKT)\r\nreturn -EINVAL;\r\nif (sinfo->direction != XT_CONNBYTES_DIR_ORIGINAL &&\r\nsinfo->direction != XT_CONNBYTES_DIR_REPLY &&\r\nsinfo->direction != XT_CONNBYTES_DIR_BOTH)\r\nreturn -EINVAL;\r\nret = nf_ct_l3proto_try_module_get(par->family);\r\nif (ret < 0)\r\npr_info("cannot load conntrack support for proto=%u\n",\r\npar->family);\r\nif (!nf_ct_acct_enabled(par->net)) {\r\npr_warning("Forcing CT accounting to be enabled\n");\r\nnf_ct_set_acct(par->net, true);\r\n}\r\nreturn ret;\r\n}\r\nstatic void connbytes_mt_destroy(const struct xt_mtdtor_param *par)\r\n{\r\nnf_ct_l3proto_module_put(par->family);\r\n}\r\nstatic int __init connbytes_mt_init(void)\r\n{\r\nreturn xt_register_match(&connbytes_mt_reg);\r\n}\r\nstatic void __exit connbytes_mt_exit(void)\r\n{\r\nxt_unregister_match(&connbytes_mt_reg);\r\n}
