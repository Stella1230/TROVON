static struct parsed_partitions *allocate_partitions(struct gendisk *hd)\r\n{\r\nstruct parsed_partitions *state;\r\nint nr;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn NULL;\r\nnr = disk_max_parts(hd);\r\nstate->parts = vzalloc(nr * sizeof(state->parts[0]));\r\nif (!state->parts) {\r\nkfree(state);\r\nreturn NULL;\r\n}\r\nstate->limit = nr;\r\nreturn state;\r\n}\r\nvoid free_partitions(struct parsed_partitions *state)\r\n{\r\nvfree(state->parts);\r\nkfree(state);\r\n}\r\nstruct parsed_partitions *\r\ncheck_partition(struct gendisk *hd, struct block_device *bdev)\r\n{\r\nstruct parsed_partitions *state;\r\nint i, res, err;\r\nstate = allocate_partitions(hd);\r\nif (!state)\r\nreturn NULL;\r\nstate->pp_buf = (char *)__get_free_page(GFP_KERNEL);\r\nif (!state->pp_buf) {\r\nfree_partitions(state);\r\nreturn NULL;\r\n}\r\nstate->pp_buf[0] = '\0';\r\nstate->bdev = bdev;\r\ndisk_name(hd, 0, state->name);\r\nsnprintf(state->pp_buf, PAGE_SIZE, " %s:", state->name);\r\nif (isdigit(state->name[strlen(state->name)-1]))\r\nsprintf(state->name, "p");\r\ni = res = err = 0;\r\nwhile (!res && check_part[i]) {\r\nmemset(state->parts, 0, state->limit * sizeof(state->parts[0]));\r\nres = check_part[i++](state);\r\nif (res < 0) {\r\nerr = res;\r\nres = 0;\r\n}\r\n}\r\nif (res > 0) {\r\nprintk(KERN_INFO "%s", state->pp_buf);\r\nfree_page((unsigned long)state->pp_buf);\r\nreturn state;\r\n}\r\nif (state->access_beyond_eod)\r\nerr = -ENOSPC;\r\nif (err)\r\nres = err;\r\nif (!res)\r\nstrlcat(state->pp_buf, " unknown partition table\n", PAGE_SIZE);\r\nelse if (warn_no_part)\r\nstrlcat(state->pp_buf, " unable to read partition table\n", PAGE_SIZE);\r\nprintk(KERN_INFO "%s", state->pp_buf);\r\nfree_page((unsigned long)state->pp_buf);\r\nfree_partitions(state);\r\nreturn ERR_PTR(res);\r\n}
