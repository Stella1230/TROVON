static void\r\nvxfs_put_super(struct super_block *sbp)\r\n{\r\nstruct vxfs_sb_info *infp = VXFS_SBI(sbp);\r\nvxfs_put_fake_inode(infp->vsi_fship);\r\nvxfs_put_fake_inode(infp->vsi_ilist);\r\nvxfs_put_fake_inode(infp->vsi_stilist);\r\nbrelse(infp->vsi_bp);\r\nkfree(infp);\r\n}\r\nstatic int\r\nvxfs_statfs(struct dentry *dentry, struct kstatfs *bufp)\r\n{\r\nstruct vxfs_sb_info *infp = VXFS_SBI(dentry->d_sb);\r\nbufp->f_type = VXFS_SUPER_MAGIC;\r\nbufp->f_bsize = dentry->d_sb->s_blocksize;\r\nbufp->f_blocks = infp->vsi_raw->vs_dsize;\r\nbufp->f_bfree = infp->vsi_raw->vs_free;\r\nbufp->f_bavail = 0;\r\nbufp->f_files = 0;\r\nbufp->f_ffree = infp->vsi_raw->vs_ifree;\r\nbufp->f_namelen = VXFS_NAMELEN;\r\nreturn 0;\r\n}\r\nstatic int vxfs_remount(struct super_block *sb, int *flags, char *data)\r\n{\r\nsync_filesystem(sb);\r\n*flags |= MS_RDONLY;\r\nreturn 0;\r\n}\r\nstatic int vxfs_fill_super(struct super_block *sbp, void *dp, int silent)\r\n{\r\nstruct vxfs_sb_info *infp;\r\nstruct vxfs_sb *rsbp;\r\nstruct buffer_head *bp = NULL;\r\nu_long bsize;\r\nstruct inode *root;\r\nint ret = -EINVAL;\r\nsbp->s_flags |= MS_RDONLY;\r\ninfp = kzalloc(sizeof(*infp), GFP_KERNEL);\r\nif (!infp) {\r\nprintk(KERN_WARNING "vxfs: unable to allocate incore superblock\n");\r\nreturn -ENOMEM;\r\n}\r\nbsize = sb_min_blocksize(sbp, BLOCK_SIZE);\r\nif (!bsize) {\r\nprintk(KERN_WARNING "vxfs: unable to set blocksize\n");\r\ngoto out;\r\n}\r\nbp = sb_bread(sbp, 1);\r\nif (!bp || !buffer_mapped(bp)) {\r\nif (!silent) {\r\nprintk(KERN_WARNING\r\n"vxfs: unable to read disk superblock\n");\r\n}\r\ngoto out;\r\n}\r\nrsbp = (struct vxfs_sb *)bp->b_data;\r\nif (rsbp->vs_magic != VXFS_SUPER_MAGIC) {\r\nif (!silent)\r\nprintk(KERN_NOTICE "vxfs: WRONG superblock magic\n");\r\ngoto out;\r\n}\r\nif ((rsbp->vs_version < 2 || rsbp->vs_version > 4) && !silent) {\r\nprintk(KERN_NOTICE "vxfs: unsupported VxFS version (%d)\n",\r\nrsbp->vs_version);\r\ngoto out;\r\n}\r\n#ifdef DIAGNOSTIC\r\nprintk(KERN_DEBUG "vxfs: supported VxFS version (%d)\n", rsbp->vs_version);\r\nprintk(KERN_DEBUG "vxfs: blocksize: %d\n", rsbp->vs_bsize);\r\n#endif\r\nsbp->s_magic = rsbp->vs_magic;\r\nsbp->s_fs_info = infp;\r\ninfp->vsi_raw = rsbp;\r\ninfp->vsi_bp = bp;\r\ninfp->vsi_oltext = rsbp->vs_oltext[0];\r\ninfp->vsi_oltsize = rsbp->vs_oltsize;\r\nif (!sb_set_blocksize(sbp, rsbp->vs_bsize)) {\r\nprintk(KERN_WARNING "vxfs: unable to set final block size\n");\r\ngoto out;\r\n}\r\nif (vxfs_read_olt(sbp, bsize)) {\r\nprintk(KERN_WARNING "vxfs: unable to read olt\n");\r\ngoto out;\r\n}\r\nif (vxfs_read_fshead(sbp)) {\r\nprintk(KERN_WARNING "vxfs: unable to read fshead\n");\r\ngoto out;\r\n}\r\nsbp->s_op = &vxfs_super_ops;\r\nroot = vxfs_iget(sbp, VXFS_ROOT_INO);\r\nif (IS_ERR(root)) {\r\nret = PTR_ERR(root);\r\ngoto out;\r\n}\r\nsbp->s_root = d_make_root(root);\r\nif (!sbp->s_root) {\r\nprintk(KERN_WARNING "vxfs: unable to get root dentry.\n");\r\ngoto out_free_ilist;\r\n}\r\nreturn 0;\r\nout_free_ilist:\r\nvxfs_put_fake_inode(infp->vsi_fship);\r\nvxfs_put_fake_inode(infp->vsi_ilist);\r\nvxfs_put_fake_inode(infp->vsi_stilist);\r\nout:\r\nbrelse(bp);\r\nkfree(infp);\r\nreturn ret;\r\n}\r\nstatic struct dentry *vxfs_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nreturn mount_bdev(fs_type, flags, dev_name, data, vxfs_fill_super);\r\n}\r\nstatic int __init\r\nvxfs_init(void)\r\n{\r\nint rv;\r\nvxfs_inode_cachep = kmem_cache_create("vxfs_inode",\r\nsizeof(struct vxfs_inode_info), 0,\r\nSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\r\nif (!vxfs_inode_cachep)\r\nreturn -ENOMEM;\r\nrv = register_filesystem(&vxfs_fs_type);\r\nif (rv < 0)\r\nkmem_cache_destroy(vxfs_inode_cachep);\r\nreturn rv;\r\n}\r\nstatic void __exit\r\nvxfs_cleanup(void)\r\n{\r\nunregister_filesystem(&vxfs_fs_type);\r\nrcu_barrier();\r\nkmem_cache_destroy(vxfs_inode_cachep);\r\n}
