int ad7606_reset(struct ad7606_state *st)\r\n{\r\nif (gpio_is_valid(st->pdata->gpio_reset)) {\r\ngpio_set_value(st->pdata->gpio_reset, 1);\r\nndelay(100);\r\ngpio_set_value(st->pdata->gpio_reset, 0);\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int ad7606_scan_direct(struct iio_dev *indio_dev, unsigned ch)\r\n{\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nint ret;\r\nst->done = false;\r\ngpio_set_value(st->pdata->gpio_convst, 1);\r\nret = wait_event_interruptible(st->wq_data_avail, st->done);\r\nif (ret)\r\ngoto error_ret;\r\nif (gpio_is_valid(st->pdata->gpio_frstdata)) {\r\nret = st->bops->read_block(st->dev, 1, st->data);\r\nif (ret)\r\ngoto error_ret;\r\nif (!gpio_get_value(st->pdata->gpio_frstdata)) {\r\nad7606_reset(st);\r\nret = -EIO;\r\ngoto error_ret;\r\n}\r\nret = st->bops->read_block(st->dev,\r\nst->chip_info->num_channels - 1, &st->data[1]);\r\nif (ret)\r\ngoto error_ret;\r\n} else {\r\nret = st->bops->read_block(st->dev,\r\nst->chip_info->num_channels, st->data);\r\nif (ret)\r\ngoto error_ret;\r\n}\r\nret = st->data[ch];\r\nerror_ret:\r\ngpio_set_value(st->pdata->gpio_convst, 0);\r\nreturn ret;\r\n}\r\nstatic int ad7606_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong m)\r\n{\r\nint ret;\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nswitch (m) {\r\ncase IIO_CHAN_INFO_RAW:\r\nmutex_lock(&indio_dev->mlock);\r\nif (iio_buffer_enabled(indio_dev))\r\nret = -EBUSY;\r\nelse\r\nret = ad7606_scan_direct(indio_dev, chan->address);\r\nmutex_unlock(&indio_dev->mlock);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = (short) ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = st->range * 2;\r\n*val2 = st->chip_info->channels[0].scan_type.realbits;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t ad7606_show_range(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%u\n", st->range);\r\n}\r\nstatic ssize_t ad7606_store_range(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nunsigned long lval;\r\nint ret;\r\nret = kstrtoul(buf, 10, &lval);\r\nif (ret)\r\nreturn ret;\r\nif (!(lval == 5000 || lval == 10000)) {\r\ndev_err(dev, "range is not supported\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&indio_dev->mlock);\r\ngpio_set_value(st->pdata->gpio_range, lval == 10000);\r\nst->range = lval;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn count;\r\n}\r\nstatic ssize_t ad7606_show_oversampling_ratio(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%u\n", st->oversampling);\r\n}\r\nstatic int ad7606_oversampling_get_index(unsigned val)\r\n{\r\nunsigned char supported[] = {0, 2, 4, 8, 16, 32, 64};\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(supported); i++)\r\nif (val == supported[i])\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t ad7606_store_oversampling_ratio(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nunsigned long lval;\r\nint ret;\r\nret = kstrtoul(buf, 10, &lval);\r\nif (ret)\r\nreturn ret;\r\nret = ad7606_oversampling_get_index(lval);\r\nif (ret < 0) {\r\ndev_err(dev, "oversampling %lu is not supported\n", lval);\r\nreturn ret;\r\n}\r\nmutex_lock(&indio_dev->mlock);\r\ngpio_set_value(st->pdata->gpio_os0, (ret >> 0) & 1);\r\ngpio_set_value(st->pdata->gpio_os1, (ret >> 1) & 1);\r\ngpio_set_value(st->pdata->gpio_os1, (ret >> 2) & 1);\r\nst->oversampling = lval;\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn count;\r\n}\r\nstatic int ad7606_request_gpios(struct ad7606_state *st)\r\n{\r\nstruct gpio gpio_array[3] = {\r\n[0] = {\r\n.gpio = st->pdata->gpio_os0,\r\n.flags = GPIOF_DIR_OUT | ((st->oversampling & 1) ?\r\nGPIOF_INIT_HIGH : GPIOF_INIT_LOW),\r\n.label = "AD7606_OS0",\r\n},\r\n[1] = {\r\n.gpio = st->pdata->gpio_os1,\r\n.flags = GPIOF_DIR_OUT | ((st->oversampling & 2) ?\r\nGPIOF_INIT_HIGH : GPIOF_INIT_LOW),\r\n.label = "AD7606_OS1",\r\n},\r\n[2] = {\r\n.gpio = st->pdata->gpio_os2,\r\n.flags = GPIOF_DIR_OUT | ((st->oversampling & 4) ?\r\nGPIOF_INIT_HIGH : GPIOF_INIT_LOW),\r\n.label = "AD7606_OS2",\r\n},\r\n};\r\nint ret;\r\nif (gpio_is_valid(st->pdata->gpio_convst)) {\r\nret = gpio_request_one(st->pdata->gpio_convst,\r\nGPIOF_OUT_INIT_LOW,\r\n"AD7606_CONVST");\r\nif (ret) {\r\ndev_err(st->dev, "failed to request GPIO CONVST\n");\r\ngoto error_ret;\r\n}\r\n} else {\r\nret = -EIO;\r\ngoto error_ret;\r\n}\r\nif (gpio_is_valid(st->pdata->gpio_os0) &&\r\ngpio_is_valid(st->pdata->gpio_os1) &&\r\ngpio_is_valid(st->pdata->gpio_os2)) {\r\nret = gpio_request_array(gpio_array, ARRAY_SIZE(gpio_array));\r\nif (ret < 0)\r\ngoto error_free_convst;\r\n}\r\nif (gpio_is_valid(st->pdata->gpio_reset)) {\r\nret = gpio_request_one(st->pdata->gpio_reset,\r\nGPIOF_OUT_INIT_LOW,\r\n"AD7606_RESET");\r\nif (ret < 0)\r\ngoto error_free_os;\r\n}\r\nif (gpio_is_valid(st->pdata->gpio_range)) {\r\nret = gpio_request_one(st->pdata->gpio_range, GPIOF_DIR_OUT |\r\n((st->range == 10000) ? GPIOF_INIT_HIGH :\r\nGPIOF_INIT_LOW), "AD7606_RANGE");\r\nif (ret < 0)\r\ngoto error_free_reset;\r\n}\r\nif (gpio_is_valid(st->pdata->gpio_stby)) {\r\nret = gpio_request_one(st->pdata->gpio_stby,\r\nGPIOF_OUT_INIT_HIGH,\r\n"AD7606_STBY");\r\nif (ret < 0)\r\ngoto error_free_range;\r\n}\r\nif (gpio_is_valid(st->pdata->gpio_frstdata)) {\r\nret = gpio_request_one(st->pdata->gpio_frstdata, GPIOF_IN,\r\n"AD7606_FRSTDATA");\r\nif (ret < 0)\r\ngoto error_free_stby;\r\n}\r\nreturn 0;\r\nerror_free_stby:\r\nif (gpio_is_valid(st->pdata->gpio_stby))\r\ngpio_free(st->pdata->gpio_stby);\r\nerror_free_range:\r\nif (gpio_is_valid(st->pdata->gpio_range))\r\ngpio_free(st->pdata->gpio_range);\r\nerror_free_reset:\r\nif (gpio_is_valid(st->pdata->gpio_reset))\r\ngpio_free(st->pdata->gpio_reset);\r\nerror_free_os:\r\nif (gpio_is_valid(st->pdata->gpio_os0) &&\r\ngpio_is_valid(st->pdata->gpio_os1) &&\r\ngpio_is_valid(st->pdata->gpio_os2))\r\ngpio_free_array(gpio_array, ARRAY_SIZE(gpio_array));\r\nerror_free_convst:\r\ngpio_free(st->pdata->gpio_convst);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic void ad7606_free_gpios(struct ad7606_state *st)\r\n{\r\nif (gpio_is_valid(st->pdata->gpio_frstdata))\r\ngpio_free(st->pdata->gpio_frstdata);\r\nif (gpio_is_valid(st->pdata->gpio_stby))\r\ngpio_free(st->pdata->gpio_stby);\r\nif (gpio_is_valid(st->pdata->gpio_range))\r\ngpio_free(st->pdata->gpio_range);\r\nif (gpio_is_valid(st->pdata->gpio_reset))\r\ngpio_free(st->pdata->gpio_reset);\r\nif (gpio_is_valid(st->pdata->gpio_os0) &&\r\ngpio_is_valid(st->pdata->gpio_os1) &&\r\ngpio_is_valid(st->pdata->gpio_os2)) {\r\ngpio_free(st->pdata->gpio_os2);\r\ngpio_free(st->pdata->gpio_os1);\r\ngpio_free(st->pdata->gpio_os0);\r\n}\r\ngpio_free(st->pdata->gpio_convst);\r\n}\r\nstatic irqreturn_t ad7606_interrupt(int irq, void *dev_id)\r\n{\r\nstruct iio_dev *indio_dev = dev_id;\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nif (iio_buffer_enabled(indio_dev)) {\r\nschedule_work(&st->poll_work);\r\n} else {\r\nst->done = true;\r\nwake_up_interruptible(&st->wq_data_avail);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstruct iio_dev *ad7606_probe(struct device *dev, int irq,\r\nvoid __iomem *base_address,\r\nunsigned id,\r\nconst struct ad7606_bus_ops *bops)\r\n{\r\nstruct ad7606_platform_data *pdata = dev->platform_data;\r\nstruct ad7606_state *st;\r\nint ret;\r\nstruct iio_dev *indio_dev;\r\nindio_dev = devm_iio_device_alloc(dev, sizeof(*st));\r\nif (!indio_dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nst = iio_priv(indio_dev);\r\nst->dev = dev;\r\nst->bops = bops;\r\nst->base_address = base_address;\r\nst->range = pdata->default_range == 10000 ? 10000 : 5000;\r\nret = ad7606_oversampling_get_index(pdata->default_os);\r\nif (ret < 0) {\r\ndev_warn(dev, "oversampling %d is not supported\n",\r\npdata->default_os);\r\nst->oversampling = 0;\r\n} else {\r\nst->oversampling = pdata->default_os;\r\n}\r\nst->reg = devm_regulator_get(dev, "vcc");\r\nif (!IS_ERR(st->reg)) {\r\nret = regulator_enable(st->reg);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\n}\r\nst->pdata = pdata;\r\nst->chip_info = &ad7606_chip_info_tbl[id];\r\nindio_dev->dev.parent = dev;\r\nif (gpio_is_valid(st->pdata->gpio_os0) &&\r\ngpio_is_valid(st->pdata->gpio_os1) &&\r\ngpio_is_valid(st->pdata->gpio_os2)) {\r\nif (gpio_is_valid(st->pdata->gpio_range))\r\nindio_dev->info = &ad7606_info_os_and_range;\r\nelse\r\nindio_dev->info = &ad7606_info_os;\r\n} else {\r\nif (gpio_is_valid(st->pdata->gpio_range))\r\nindio_dev->info = &ad7606_info_range;\r\nelse\r\nindio_dev->info = &ad7606_info_no_os_or_range;\r\n}\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->name = st->chip_info->name;\r\nindio_dev->channels = st->chip_info->channels;\r\nindio_dev->num_channels = st->chip_info->num_channels;\r\ninit_waitqueue_head(&st->wq_data_avail);\r\nret = ad7606_request_gpios(st);\r\nif (ret)\r\ngoto error_disable_reg;\r\nret = ad7606_reset(st);\r\nif (ret)\r\ndev_warn(st->dev, "failed to RESET: no RESET GPIO specified\n");\r\nret = request_irq(irq, ad7606_interrupt,\r\nIRQF_TRIGGER_FALLING, st->chip_info->name, indio_dev);\r\nif (ret)\r\ngoto error_free_gpios;\r\nret = ad7606_register_ring_funcs_and_init(indio_dev);\r\nif (ret)\r\ngoto error_free_irq;\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_unregister_ring;\r\nreturn indio_dev;\r\nerror_unregister_ring:\r\nad7606_ring_cleanup(indio_dev);\r\nerror_free_irq:\r\nfree_irq(irq, indio_dev);\r\nerror_free_gpios:\r\nad7606_free_gpios(st);\r\nerror_disable_reg:\r\nif (!IS_ERR(st->reg))\r\nregulator_disable(st->reg);\r\nreturn ERR_PTR(ret);\r\n}\r\nint ad7606_remove(struct iio_dev *indio_dev, int irq)\r\n{\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nad7606_ring_cleanup(indio_dev);\r\nfree_irq(irq, indio_dev);\r\nif (!IS_ERR(st->reg))\r\nregulator_disable(st->reg);\r\nad7606_free_gpios(st);\r\nreturn 0;\r\n}\r\nvoid ad7606_suspend(struct iio_dev *indio_dev)\r\n{\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nif (gpio_is_valid(st->pdata->gpio_stby)) {\r\nif (gpio_is_valid(st->pdata->gpio_range))\r\ngpio_set_value(st->pdata->gpio_range, 1);\r\ngpio_set_value(st->pdata->gpio_stby, 0);\r\n}\r\n}\r\nvoid ad7606_resume(struct iio_dev *indio_dev)\r\n{\r\nstruct ad7606_state *st = iio_priv(indio_dev);\r\nif (gpio_is_valid(st->pdata->gpio_stby)) {\r\nif (gpio_is_valid(st->pdata->gpio_range))\r\ngpio_set_value(st->pdata->gpio_range,\r\nst->range == 10000);\r\ngpio_set_value(st->pdata->gpio_stby, 1);\r\nad7606_reset(st);\r\n}\r\n}
