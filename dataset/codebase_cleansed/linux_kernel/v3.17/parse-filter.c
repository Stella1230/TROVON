static void show_error(char *error_buf, const char *fmt, ...)\r\n{\r\nunsigned long long index;\r\nconst char *input;\r\nva_list ap;\r\nint len;\r\nint i;\r\ninput = pevent_get_input_buf();\r\nindex = pevent_get_input_buf_ptr();\r\nlen = input ? strlen(input) : 0;\r\nif (len) {\r\nstrcpy(error_buf, input);\r\nerror_buf[len] = '\n';\r\nfor (i = 1; i < len && i < index; i++)\r\nerror_buf[len+i] = ' ';\r\nerror_buf[len + i] = '^';\r\nerror_buf[len + i + 1] = '\n';\r\nlen += i+2;\r\n}\r\nva_start(ap, fmt);\r\nvsnprintf(error_buf + len, PEVENT_FILTER_ERROR_BUFSZ - len, fmt, ap);\r\nva_end(ap);\r\n}\r\nstatic void free_token(char *token)\r\n{\r\npevent_free_token(token);\r\n}\r\nstatic enum event_type read_token(char **tok)\r\n{\r\nenum event_type type;\r\nchar *token = NULL;\r\ndo {\r\nfree_token(token);\r\ntype = pevent_read_token(&token);\r\n} while (type == EVENT_NEWLINE || type == EVENT_SPACE);\r\nif (token &&\r\n(strcmp(token, "=") == 0 || strcmp(token, "!") == 0) &&\r\npevent_peek_char() == '~') {\r\n*tok = malloc(3);\r\nif (*tok == NULL) {\r\nfree_token(token);\r\nreturn EVENT_ERROR;\r\n}\r\nsprintf(*tok, "%c%c", *token, '~');\r\nfree_token(token);\r\npevent_read_token(&token);\r\nfree_token(token);\r\n} else\r\n*tok = token;\r\nreturn type;\r\n}\r\nstatic int filter_cmp(const void *a, const void *b)\r\n{\r\nconst struct filter_type *ea = a;\r\nconst struct filter_type *eb = b;\r\nif (ea->event_id < eb->event_id)\r\nreturn -1;\r\nif (ea->event_id > eb->event_id)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic struct filter_type *\r\nfind_filter_type(struct event_filter *filter, int id)\r\n{\r\nstruct filter_type *filter_type;\r\nstruct filter_type key;\r\nkey.event_id = id;\r\nfilter_type = bsearch(&key, filter->event_filters,\r\nfilter->filters,\r\nsizeof(*filter->event_filters),\r\nfilter_cmp);\r\nreturn filter_type;\r\n}\r\nstatic struct filter_type *\r\nadd_filter_type(struct event_filter *filter, int id)\r\n{\r\nstruct filter_type *filter_type;\r\nint i;\r\nfilter_type = find_filter_type(filter, id);\r\nif (filter_type)\r\nreturn filter_type;\r\nfilter_type = realloc(filter->event_filters,\r\nsizeof(*filter->event_filters) *\r\n(filter->filters + 1));\r\nif (!filter_type)\r\nreturn NULL;\r\nfilter->event_filters = filter_type;\r\nfor (i = 0; i < filter->filters; i++) {\r\nif (filter->event_filters[i].event_id > id)\r\nbreak;\r\n}\r\nif (i < filter->filters)\r\nmemmove(&filter->event_filters[i+1],\r\n&filter->event_filters[i],\r\nsizeof(*filter->event_filters) *\r\n(filter->filters - i));\r\nfilter_type = &filter->event_filters[i];\r\nfilter_type->event_id = id;\r\nfilter_type->event = pevent_find_event(filter->pevent, id);\r\nfilter_type->filter = NULL;\r\nfilter->filters++;\r\nreturn filter_type;\r\n}\r\nstruct event_filter *pevent_filter_alloc(struct pevent *pevent)\r\n{\r\nstruct event_filter *filter;\r\nfilter = malloc(sizeof(*filter));\r\nif (filter == NULL)\r\nreturn NULL;\r\nmemset(filter, 0, sizeof(*filter));\r\nfilter->pevent = pevent;\r\npevent_ref(pevent);\r\nreturn filter;\r\n}\r\nstatic struct filter_arg *allocate_arg(void)\r\n{\r\nreturn calloc(1, sizeof(struct filter_arg));\r\n}\r\nstatic void free_arg(struct filter_arg *arg)\r\n{\r\nif (!arg)\r\nreturn;\r\nswitch (arg->type) {\r\ncase FILTER_ARG_NONE:\r\ncase FILTER_ARG_BOOLEAN:\r\nbreak;\r\ncase FILTER_ARG_NUM:\r\nfree_arg(arg->num.left);\r\nfree_arg(arg->num.right);\r\nbreak;\r\ncase FILTER_ARG_EXP:\r\nfree_arg(arg->exp.left);\r\nfree_arg(arg->exp.right);\r\nbreak;\r\ncase FILTER_ARG_STR:\r\nfree(arg->str.val);\r\nregfree(&arg->str.reg);\r\nfree(arg->str.buffer);\r\nbreak;\r\ncase FILTER_ARG_VALUE:\r\nif (arg->value.type == FILTER_STRING ||\r\narg->value.type == FILTER_CHAR)\r\nfree(arg->value.str);\r\nbreak;\r\ncase FILTER_ARG_OP:\r\nfree_arg(arg->op.left);\r\nfree_arg(arg->op.right);\r\ndefault:\r\nbreak;\r\n}\r\nfree(arg);\r\n}\r\nstatic int add_event(struct event_list **events,\r\nstruct event_format *event)\r\n{\r\nstruct event_list *list;\r\nlist = malloc(sizeof(*list));\r\nif (list == NULL)\r\nreturn -1;\r\nlist->next = *events;\r\n*events = list;\r\nlist->event = event;\r\nreturn 0;\r\n}\r\nstatic int event_match(struct event_format *event,\r\nregex_t *sreg, regex_t *ereg)\r\n{\r\nif (sreg) {\r\nreturn !regexec(sreg, event->system, 0, NULL, 0) &&\r\n!regexec(ereg, event->name, 0, NULL, 0);\r\n}\r\nreturn !regexec(ereg, event->system, 0, NULL, 0) ||\r\n!regexec(ereg, event->name, 0, NULL, 0);\r\n}\r\nstatic enum pevent_errno\r\nfind_event(struct pevent *pevent, struct event_list **events,\r\nchar *sys_name, char *event_name)\r\n{\r\nstruct event_format *event;\r\nregex_t ereg;\r\nregex_t sreg;\r\nint match = 0;\r\nint fail = 0;\r\nchar *reg;\r\nint ret;\r\nint i;\r\nif (!event_name) {\r\nevent_name = sys_name;\r\nsys_name = NULL;\r\n}\r\nreg = malloc(strlen(event_name) + 3);\r\nif (reg == NULL)\r\nreturn PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\nsprintf(reg, "^%s$", event_name);\r\nret = regcomp(&ereg, reg, REG_ICASE|REG_NOSUB);\r\nfree(reg);\r\nif (ret)\r\nreturn PEVENT_ERRNO__INVALID_EVENT_NAME;\r\nif (sys_name) {\r\nreg = malloc(strlen(sys_name) + 3);\r\nif (reg == NULL) {\r\nregfree(&ereg);\r\nreturn PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\n}\r\nsprintf(reg, "^%s$", sys_name);\r\nret = regcomp(&sreg, reg, REG_ICASE|REG_NOSUB);\r\nfree(reg);\r\nif (ret) {\r\nregfree(&ereg);\r\nreturn PEVENT_ERRNO__INVALID_EVENT_NAME;\r\n}\r\n}\r\nfor (i = 0; i < pevent->nr_events; i++) {\r\nevent = pevent->events[i];\r\nif (event_match(event, sys_name ? &sreg : NULL, &ereg)) {\r\nmatch = 1;\r\nif (add_event(events, event) < 0) {\r\nfail = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nregfree(&ereg);\r\nif (sys_name)\r\nregfree(&sreg);\r\nif (!match)\r\nreturn PEVENT_ERRNO__EVENT_NOT_FOUND;\r\nif (fail)\r\nreturn PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\nreturn 0;\r\n}\r\nstatic void free_events(struct event_list *events)\r\n{\r\nstruct event_list *event;\r\nwhile (events) {\r\nevent = events;\r\nevents = events->next;\r\nfree(event);\r\n}\r\n}\r\nstatic enum pevent_errno\r\ncreate_arg_item(struct event_format *event, const char *token,\r\nenum event_type type, struct filter_arg **parg, char *error_str)\r\n{\r\nstruct format_field *field;\r\nstruct filter_arg *arg;\r\narg = allocate_arg();\r\nif (arg == NULL) {\r\nshow_error(error_str, "failed to allocate filter arg");\r\nreturn PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\n}\r\nswitch (type) {\r\ncase EVENT_SQUOTE:\r\ncase EVENT_DQUOTE:\r\narg->type = FILTER_ARG_VALUE;\r\narg->value.type =\r\ntype == EVENT_DQUOTE ? FILTER_STRING : FILTER_CHAR;\r\narg->value.str = strdup(token);\r\nif (!arg->value.str) {\r\nfree_arg(arg);\r\nshow_error(error_str, "failed to allocate string filter arg");\r\nreturn PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\n}\r\nbreak;\r\ncase EVENT_ITEM:\r\nif (isdigit(token[0])) {\r\narg->type = FILTER_ARG_VALUE;\r\narg->value.type = FILTER_NUMBER;\r\narg->value.val = strtoull(token, NULL, 0);\r\nbreak;\r\n}\r\nfield = pevent_find_any_field(event, token);\r\nif (!field) {\r\nif (strcmp(token, COMM) != 0) {\r\narg->type = FILTER_ARG_BOOLEAN;\r\narg->boolean.value = FILTER_FALSE;\r\nbreak;\r\n}\r\nfield = &comm;\r\n}\r\narg->type = FILTER_ARG_FIELD;\r\narg->field.field = field;\r\nbreak;\r\ndefault:\r\nfree_arg(arg);\r\nshow_error(error_str, "expected a value but found %s", token);\r\nreturn PEVENT_ERRNO__UNEXPECTED_TYPE;\r\n}\r\n*parg = arg;\r\nreturn 0;\r\n}\r\nstatic struct filter_arg *\r\ncreate_arg_op(enum filter_op_type btype)\r\n{\r\nstruct filter_arg *arg;\r\narg = allocate_arg();\r\nif (!arg)\r\nreturn NULL;\r\narg->type = FILTER_ARG_OP;\r\narg->op.type = btype;\r\nreturn arg;\r\n}\r\nstatic struct filter_arg *\r\ncreate_arg_exp(enum filter_exp_type etype)\r\n{\r\nstruct filter_arg *arg;\r\narg = allocate_arg();\r\nif (!arg)\r\nreturn NULL;\r\narg->type = FILTER_ARG_EXP;\r\narg->op.type = etype;\r\nreturn arg;\r\n}\r\nstatic struct filter_arg *\r\ncreate_arg_cmp(enum filter_exp_type etype)\r\n{\r\nstruct filter_arg *arg;\r\narg = allocate_arg();\r\nif (!arg)\r\nreturn NULL;\r\narg->type = FILTER_ARG_NUM;\r\narg->op.type = etype;\r\nreturn arg;\r\n}\r\nstatic enum pevent_errno\r\nadd_right(struct filter_arg *op, struct filter_arg *arg, char *error_str)\r\n{\r\nstruct filter_arg *left;\r\nchar *str;\r\nint op_type;\r\nint ret;\r\nswitch (op->type) {\r\ncase FILTER_ARG_EXP:\r\nif (op->exp.right)\r\ngoto out_fail;\r\nop->exp.right = arg;\r\nbreak;\r\ncase FILTER_ARG_OP:\r\nif (op->op.right)\r\ngoto out_fail;\r\nop->op.right = arg;\r\nbreak;\r\ncase FILTER_ARG_NUM:\r\nif (op->op.right)\r\ngoto out_fail;\r\nswitch (arg->type) {\r\ncase FILTER_ARG_VALUE:\r\ncase FILTER_ARG_FIELD:\r\nbreak;\r\ndefault:\r\nshow_error(error_str, "Illegal rvalue");\r\nreturn PEVENT_ERRNO__ILLEGAL_RVALUE;\r\n}\r\nswitch (arg->value.type) {\r\ncase FILTER_CHAR:\r\nif (strlen(arg->value.str) == 1 &&\r\nop->num.type != FILTER_CMP_REGEX &&\r\nop->num.type != FILTER_CMP_NOT_REGEX) {\r\narg->value.type = FILTER_NUMBER;\r\ngoto do_int;\r\n}\r\ncase FILTER_STRING:\r\nop_type = op->num.type;\r\nleft = op->num.left;\r\nstr = arg->value.str;\r\nmemset(op, 0, sizeof(*op));\r\nif (left->type == FILTER_ARG_BOOLEAN) {\r\nfree_arg(left);\r\nfree_arg(arg);\r\nop->type = FILTER_ARG_BOOLEAN;\r\nop->boolean.value = FILTER_FALSE;\r\nbreak;\r\n}\r\nif (left->type != FILTER_ARG_FIELD) {\r\nshow_error(error_str,\r\n"Illegal lvalue for string comparison");\r\nreturn PEVENT_ERRNO__ILLEGAL_LVALUE;\r\n}\r\nswitch (op_type) {\r\ncase FILTER_CMP_EQ:\r\nop_type = FILTER_CMP_MATCH;\r\nbreak;\r\ncase FILTER_CMP_NE:\r\nop_type = FILTER_CMP_NOT_MATCH;\r\nbreak;\r\ncase FILTER_CMP_REGEX:\r\ncase FILTER_CMP_NOT_REGEX:\r\nret = regcomp(&op->str.reg, str, REG_ICASE|REG_NOSUB);\r\nif (ret) {\r\nshow_error(error_str,\r\n"RegEx '%s' did not compute",\r\nstr);\r\nreturn PEVENT_ERRNO__INVALID_REGEX;\r\n}\r\nbreak;\r\ndefault:\r\nshow_error(error_str,\r\n"Illegal comparison for string");\r\nreturn PEVENT_ERRNO__ILLEGAL_STRING_CMP;\r\n}\r\nop->type = FILTER_ARG_STR;\r\nop->str.type = op_type;\r\nop->str.field = left->field.field;\r\nop->str.val = strdup(str);\r\nif (!op->str.val) {\r\nshow_error(error_str, "Failed to allocate string filter");\r\nreturn PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\n}\r\nop->str.buffer = malloc(op->str.field->size + 1);\r\nif (!op->str.buffer) {\r\nshow_error(error_str, "Failed to allocate string filter");\r\nreturn PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\n}\r\nop->str.buffer[op->str.field->size] = 0;\r\nfree_arg(arg);\r\nfree_arg(left);\r\nbreak;\r\ncase FILTER_NUMBER:\r\ndo_int:\r\nswitch (op->num.type) {\r\ncase FILTER_CMP_REGEX:\r\ncase FILTER_CMP_NOT_REGEX:\r\nshow_error(error_str,\r\n"Op not allowed with integers");\r\nreturn PEVENT_ERRNO__ILLEGAL_INTEGER_CMP;\r\ndefault:\r\nbreak;\r\n}\r\nop->num.right = arg;\r\nbreak;\r\ndefault:\r\ngoto out_fail;\r\n}\r\nbreak;\r\ndefault:\r\ngoto out_fail;\r\n}\r\nreturn 0;\r\nout_fail:\r\nshow_error(error_str, "Syntax error");\r\nreturn PEVENT_ERRNO__SYNTAX_ERROR;\r\n}\r\nstatic struct filter_arg *\r\nrotate_op_right(struct filter_arg *a, struct filter_arg *b)\r\n{\r\nstruct filter_arg *arg;\r\narg = a->op.right;\r\na->op.right = b;\r\nreturn arg;\r\n}\r\nstatic enum pevent_errno add_left(struct filter_arg *op, struct filter_arg *arg)\r\n{\r\nswitch (op->type) {\r\ncase FILTER_ARG_EXP:\r\nif (arg->type == FILTER_ARG_OP)\r\narg = rotate_op_right(arg, op);\r\nop->exp.left = arg;\r\nbreak;\r\ncase FILTER_ARG_OP:\r\nop->op.left = arg;\r\nbreak;\r\ncase FILTER_ARG_NUM:\r\nif (arg->type == FILTER_ARG_OP)\r\narg = rotate_op_right(arg, op);\r\nif (arg->type != FILTER_ARG_FIELD &&\r\narg->type != FILTER_ARG_BOOLEAN)\r\nreturn PEVENT_ERRNO__INVALID_ARG_TYPE;\r\nop->num.left = arg;\r\nbreak;\r\ndefault:\r\nreturn PEVENT_ERRNO__INVALID_ARG_TYPE;\r\n}\r\nreturn 0;\r\n}\r\nstatic enum op_type process_op(const char *token,\r\nenum filter_op_type *btype,\r\nenum filter_cmp_type *ctype,\r\nenum filter_exp_type *etype)\r\n{\r\n*btype = FILTER_OP_NOT;\r\n*etype = FILTER_EXP_NONE;\r\n*ctype = FILTER_CMP_NONE;\r\nif (strcmp(token, "&&") == 0)\r\n*btype = FILTER_OP_AND;\r\nelse if (strcmp(token, "||") == 0)\r\n*btype = FILTER_OP_OR;\r\nelse if (strcmp(token, "!") == 0)\r\nreturn OP_NOT;\r\nif (*btype != FILTER_OP_NOT)\r\nreturn OP_BOOL;\r\nif (strcmp(token, "+") == 0) {\r\n*etype = FILTER_EXP_ADD;\r\n} else if (strcmp(token, "-") == 0) {\r\n*etype = FILTER_EXP_SUB;\r\n} else if (strcmp(token, "*") == 0) {\r\n*etype = FILTER_EXP_MUL;\r\n} else if (strcmp(token, "/") == 0) {\r\n*etype = FILTER_EXP_DIV;\r\n} else if (strcmp(token, "%") == 0) {\r\n*etype = FILTER_EXP_MOD;\r\n} else if (strcmp(token, ">>") == 0) {\r\n*etype = FILTER_EXP_RSHIFT;\r\n} else if (strcmp(token, "<<") == 0) {\r\n*etype = FILTER_EXP_LSHIFT;\r\n} else if (strcmp(token, "&") == 0) {\r\n*etype = FILTER_EXP_AND;\r\n} else if (strcmp(token, "|") == 0) {\r\n*etype = FILTER_EXP_OR;\r\n} else if (strcmp(token, "^") == 0) {\r\n*etype = FILTER_EXP_XOR;\r\n} else if (strcmp(token, "~") == 0)\r\n*etype = FILTER_EXP_NOT;\r\nif (*etype != FILTER_EXP_NONE)\r\nreturn OP_EXP;\r\nif (strcmp(token, "==") == 0)\r\n*ctype = FILTER_CMP_EQ;\r\nelse if (strcmp(token, "!=") == 0)\r\n*ctype = FILTER_CMP_NE;\r\nelse if (strcmp(token, "<") == 0)\r\n*ctype = FILTER_CMP_LT;\r\nelse if (strcmp(token, ">") == 0)\r\n*ctype = FILTER_CMP_GT;\r\nelse if (strcmp(token, "<=") == 0)\r\n*ctype = FILTER_CMP_LE;\r\nelse if (strcmp(token, ">=") == 0)\r\n*ctype = FILTER_CMP_GE;\r\nelse if (strcmp(token, "=~") == 0)\r\n*ctype = FILTER_CMP_REGEX;\r\nelse if (strcmp(token, "!~") == 0)\r\n*ctype = FILTER_CMP_NOT_REGEX;\r\nelse\r\nreturn OP_NONE;\r\nreturn OP_CMP;\r\n}\r\nstatic int check_op_done(struct filter_arg *arg)\r\n{\r\nswitch (arg->type) {\r\ncase FILTER_ARG_EXP:\r\nreturn arg->exp.right != NULL;\r\ncase FILTER_ARG_OP:\r\nreturn arg->op.right != NULL;\r\ncase FILTER_ARG_NUM:\r\nreturn arg->num.right != NULL;\r\ncase FILTER_ARG_STR:\r\nreturn 1;\r\ncase FILTER_ARG_BOOLEAN:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic enum pevent_errno\r\nreparent_op_arg(struct filter_arg *parent, struct filter_arg *old_child,\r\nstruct filter_arg *arg, char *error_str)\r\n{\r\nstruct filter_arg *other_child;\r\nstruct filter_arg **ptr;\r\nif (parent->type != FILTER_ARG_OP &&\r\narg->type != FILTER_ARG_OP) {\r\nshow_error(error_str, "can not reparent other than OP");\r\nreturn PEVENT_ERRNO__REPARENT_NOT_OP;\r\n}\r\nif (old_child->op.right == arg) {\r\nptr = &old_child->op.right;\r\nother_child = old_child->op.left;\r\n} else if (old_child->op.left == arg) {\r\nptr = &old_child->op.left;\r\nother_child = old_child->op.right;\r\n} else {\r\nshow_error(error_str, "Error in reparent op, find other child");\r\nreturn PEVENT_ERRNO__REPARENT_FAILED;\r\n}\r\n*ptr = NULL;\r\nif (parent == old_child) {\r\nfree_arg(other_child);\r\n*parent = *arg;\r\nfree(arg);\r\nreturn 0;\r\n}\r\nif (parent->op.right == old_child)\r\nptr = &parent->op.right;\r\nelse if (parent->op.left == old_child)\r\nptr = &parent->op.left;\r\nelse {\r\nshow_error(error_str, "Error in reparent op");\r\nreturn PEVENT_ERRNO__REPARENT_FAILED;\r\n}\r\n*ptr = arg;\r\nfree_arg(old_child);\r\nreturn 0;\r\n}\r\nstatic int test_arg(struct filter_arg *parent, struct filter_arg *arg,\r\nchar *error_str)\r\n{\r\nint lval, rval;\r\nswitch (arg->type) {\r\ncase FILTER_ARG_BOOLEAN:\r\nreturn FILTER_VAL_FALSE + arg->boolean.value;\r\ncase FILTER_ARG_STR:\r\ncase FILTER_ARG_VALUE:\r\ncase FILTER_ARG_FIELD:\r\nreturn FILTER_VAL_NORM;\r\ncase FILTER_ARG_EXP:\r\nlval = test_arg(arg, arg->exp.left, error_str);\r\nif (lval != FILTER_VAL_NORM)\r\nreturn lval;\r\nrval = test_arg(arg, arg->exp.right, error_str);\r\nif (rval != FILTER_VAL_NORM)\r\nreturn rval;\r\nreturn FILTER_VAL_NORM;\r\ncase FILTER_ARG_NUM:\r\nlval = test_arg(arg, arg->num.left, error_str);\r\nif (lval != FILTER_VAL_NORM)\r\nreturn lval;\r\nrval = test_arg(arg, arg->num.right, error_str);\r\nif (rval != FILTER_VAL_NORM)\r\nreturn rval;\r\nreturn FILTER_VAL_NORM;\r\ncase FILTER_ARG_OP:\r\nif (arg->op.type != FILTER_OP_NOT) {\r\nlval = test_arg(arg, arg->op.left, error_str);\r\nswitch (lval) {\r\ncase FILTER_VAL_NORM:\r\nbreak;\r\ncase FILTER_VAL_TRUE:\r\nif (arg->op.type == FILTER_OP_OR)\r\nreturn FILTER_VAL_TRUE;\r\nrval = test_arg(arg, arg->op.right, error_str);\r\nif (rval != FILTER_VAL_NORM)\r\nreturn rval;\r\nreturn reparent_op_arg(parent, arg, arg->op.right,\r\nerror_str);\r\ncase FILTER_VAL_FALSE:\r\nif (arg->op.type == FILTER_OP_AND)\r\nreturn FILTER_VAL_FALSE;\r\nrval = test_arg(arg, arg->op.right, error_str);\r\nif (rval != FILTER_VAL_NORM)\r\nreturn rval;\r\nreturn reparent_op_arg(parent, arg, arg->op.right,\r\nerror_str);\r\ndefault:\r\nreturn lval;\r\n}\r\n}\r\nrval = test_arg(arg, arg->op.right, error_str);\r\nswitch (rval) {\r\ncase FILTER_VAL_NORM:\r\ndefault:\r\nbreak;\r\ncase FILTER_VAL_TRUE:\r\nif (arg->op.type == FILTER_OP_OR)\r\nreturn FILTER_VAL_TRUE;\r\nif (arg->op.type == FILTER_OP_NOT)\r\nreturn FILTER_VAL_FALSE;\r\nreturn reparent_op_arg(parent, arg, arg->op.left,\r\nerror_str);\r\ncase FILTER_VAL_FALSE:\r\nif (arg->op.type == FILTER_OP_AND)\r\nreturn FILTER_VAL_FALSE;\r\nif (arg->op.type == FILTER_OP_NOT)\r\nreturn FILTER_VAL_TRUE;\r\nreturn reparent_op_arg(parent, arg, arg->op.left,\r\nerror_str);\r\n}\r\nreturn rval;\r\ndefault:\r\nshow_error(error_str, "bad arg in filter tree");\r\nreturn PEVENT_ERRNO__BAD_FILTER_ARG;\r\n}\r\nreturn FILTER_VAL_NORM;\r\n}\r\nstatic int collapse_tree(struct filter_arg *arg,\r\nstruct filter_arg **arg_collapsed, char *error_str)\r\n{\r\nint ret;\r\nret = test_arg(arg, arg, error_str);\r\nswitch (ret) {\r\ncase FILTER_VAL_NORM:\r\nbreak;\r\ncase FILTER_VAL_TRUE:\r\ncase FILTER_VAL_FALSE:\r\nfree_arg(arg);\r\narg = allocate_arg();\r\nif (arg) {\r\narg->type = FILTER_ARG_BOOLEAN;\r\narg->boolean.value = ret == FILTER_VAL_TRUE;\r\n} else {\r\nshow_error(error_str, "Failed to allocate filter arg");\r\nret = PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\n}\r\nbreak;\r\ndefault:\r\nfree_arg(arg);\r\narg = NULL;\r\nbreak;\r\n}\r\n*arg_collapsed = arg;\r\nreturn ret;\r\n}\r\nstatic enum pevent_errno\r\nprocess_filter(struct event_format *event, struct filter_arg **parg,\r\nchar *error_str, int not)\r\n{\r\nenum event_type type;\r\nchar *token = NULL;\r\nstruct filter_arg *current_op = NULL;\r\nstruct filter_arg *current_exp = NULL;\r\nstruct filter_arg *left_item = NULL;\r\nstruct filter_arg *arg = NULL;\r\nenum op_type op_type;\r\nenum filter_op_type btype;\r\nenum filter_exp_type etype;\r\nenum filter_cmp_type ctype;\r\nenum pevent_errno ret;\r\n*parg = NULL;\r\ndo {\r\nfree(token);\r\ntype = read_token(&token);\r\nswitch (type) {\r\ncase EVENT_SQUOTE:\r\ncase EVENT_DQUOTE:\r\ncase EVENT_ITEM:\r\nret = create_arg_item(event, token, type, &arg, error_str);\r\nif (ret < 0)\r\ngoto fail;\r\nif (!left_item)\r\nleft_item = arg;\r\nelse if (current_exp) {\r\nret = add_right(current_exp, arg, error_str);\r\nif (ret < 0)\r\ngoto fail;\r\nleft_item = NULL;\r\nif (not) {\r\narg = NULL;\r\nif (current_op)\r\ngoto fail_syntax;\r\nfree(token);\r\n*parg = current_exp;\r\nreturn 0;\r\n}\r\n} else\r\ngoto fail_syntax;\r\narg = NULL;\r\nbreak;\r\ncase EVENT_DELIM:\r\nif (*token == ',') {\r\nshow_error(error_str, "Illegal token ','");\r\nret = PEVENT_ERRNO__ILLEGAL_TOKEN;\r\ngoto fail;\r\n}\r\nif (*token == '(') {\r\nif (left_item) {\r\nshow_error(error_str,\r\n"Open paren can not come after item");\r\nret = PEVENT_ERRNO__INVALID_PAREN;\r\ngoto fail;\r\n}\r\nif (current_exp) {\r\nshow_error(error_str,\r\n"Open paren can not come after expression");\r\nret = PEVENT_ERRNO__INVALID_PAREN;\r\ngoto fail;\r\n}\r\nret = process_filter(event, &arg, error_str, 0);\r\nif (ret != PEVENT_ERRNO__UNBALANCED_PAREN) {\r\nif (ret == 0) {\r\nshow_error(error_str,\r\n"Unbalanced number of '('");\r\nret = PEVENT_ERRNO__UNBALANCED_PAREN;\r\n}\r\ngoto fail;\r\n}\r\nret = 0;\r\nif (not) {\r\nif (current_op)\r\ngoto fail_syntax;\r\n*parg = arg;\r\nreturn 0;\r\n}\r\nif (current_op)\r\nret = add_right(current_op, arg, error_str);\r\nelse\r\ncurrent_exp = arg;\r\nif (ret < 0)\r\ngoto fail;\r\n} else {\r\nif (!current_op && !current_exp)\r\ngoto fail_syntax;\r\nif (current_exp && !check_op_done(current_exp))\r\ngoto fail_syntax;\r\nif (current_op && !check_op_done(current_op))\r\ngoto fail_syntax;\r\nif (current_op)\r\n*parg = current_op;\r\nelse\r\n*parg = current_exp;\r\nreturn PEVENT_ERRNO__UNBALANCED_PAREN;\r\n}\r\nbreak;\r\ncase EVENT_OP:\r\nop_type = process_op(token, &btype, &ctype, &etype);\r\nswitch (op_type) {\r\ncase OP_BOOL:\r\nif (!current_exp && !current_op)\r\ngoto fail_syntax;\r\ncase OP_NOT:\r\nif (left_item)\r\ngoto fail_syntax;\r\nbreak;\r\ncase OP_EXP:\r\ncase OP_CMP:\r\nif (!left_item)\r\ngoto fail_syntax;\r\nbreak;\r\ncase OP_NONE:\r\nshow_error(error_str,\r\n"Unknown op token %s", token);\r\nret = PEVENT_ERRNO__UNKNOWN_TOKEN;\r\ngoto fail;\r\n}\r\nret = 0;\r\nswitch (op_type) {\r\ncase OP_BOOL:\r\narg = create_arg_op(btype);\r\nif (arg == NULL)\r\ngoto fail_alloc;\r\nif (current_op)\r\nret = add_left(arg, current_op);\r\nelse\r\nret = add_left(arg, current_exp);\r\ncurrent_op = arg;\r\ncurrent_exp = NULL;\r\nbreak;\r\ncase OP_NOT:\r\narg = create_arg_op(btype);\r\nif (arg == NULL)\r\ngoto fail_alloc;\r\nif (current_op)\r\nret = add_right(current_op, arg, error_str);\r\nif (ret < 0)\r\ngoto fail;\r\ncurrent_exp = arg;\r\nret = process_filter(event, &arg, error_str, 1);\r\nif (ret < 0)\r\ngoto fail;\r\nret = add_right(current_exp, arg, error_str);\r\nif (ret < 0)\r\ngoto fail;\r\nbreak;\r\ncase OP_EXP:\r\ncase OP_CMP:\r\nif (op_type == OP_EXP)\r\narg = create_arg_exp(etype);\r\nelse\r\narg = create_arg_cmp(ctype);\r\nif (arg == NULL)\r\ngoto fail_alloc;\r\nif (current_op)\r\nret = add_right(current_op, arg, error_str);\r\nif (ret < 0)\r\ngoto fail;\r\nret = add_left(arg, left_item);\r\nif (ret < 0) {\r\narg = NULL;\r\ngoto fail_syntax;\r\n}\r\ncurrent_exp = arg;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\narg = NULL;\r\nif (ret < 0)\r\ngoto fail_syntax;\r\nbreak;\r\ncase EVENT_NONE:\r\nbreak;\r\ncase EVENT_ERROR:\r\ngoto fail_alloc;\r\ndefault:\r\ngoto fail_syntax;\r\n}\r\n} while (type != EVENT_NONE);\r\nif (!current_op && !current_exp)\r\ngoto fail_syntax;\r\nif (!current_op)\r\ncurrent_op = current_exp;\r\nret = collapse_tree(current_op, parg, error_str);\r\nif (ret < 0)\r\ngoto fail;\r\n*parg = current_op;\r\nreturn 0;\r\nfail_alloc:\r\nshow_error(error_str, "failed to allocate filter arg");\r\nret = PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\ngoto fail;\r\nfail_syntax:\r\nshow_error(error_str, "Syntax error");\r\nret = PEVENT_ERRNO__SYNTAX_ERROR;\r\nfail:\r\nfree_arg(current_op);\r\nfree_arg(current_exp);\r\nfree_arg(arg);\r\nfree(token);\r\nreturn ret;\r\n}\r\nstatic enum pevent_errno\r\nprocess_event(struct event_format *event, const char *filter_str,\r\nstruct filter_arg **parg, char *error_str)\r\n{\r\nint ret;\r\npevent_buffer_init(filter_str, strlen(filter_str));\r\nret = process_filter(event, parg, error_str, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!*parg) {\r\n*parg = allocate_arg();\r\nif (*parg == NULL)\r\nreturn PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\n(*parg)->type = FILTER_ARG_BOOLEAN;\r\n(*parg)->boolean.value = FILTER_FALSE;\r\n}\r\nreturn 0;\r\n}\r\nstatic enum pevent_errno\r\nfilter_event(struct event_filter *filter, struct event_format *event,\r\nconst char *filter_str, char *error_str)\r\n{\r\nstruct filter_type *filter_type;\r\nstruct filter_arg *arg;\r\nenum pevent_errno ret;\r\nif (filter_str) {\r\nret = process_event(event, filter_str, &arg, error_str);\r\nif (ret < 0)\r\nreturn ret;\r\n} else {\r\narg = allocate_arg();\r\nif (arg == NULL)\r\nreturn PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\narg->type = FILTER_ARG_BOOLEAN;\r\narg->boolean.value = FILTER_TRUE;\r\n}\r\nfilter_type = add_filter_type(filter, event->id);\r\nif (filter_type == NULL)\r\nreturn PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\nif (filter_type->filter)\r\nfree_arg(filter_type->filter);\r\nfilter_type->filter = arg;\r\nreturn 0;\r\n}\r\nstatic void filter_init_error_buf(struct event_filter *filter)\r\n{\r\npevent_buffer_init("", 0);\r\nfilter->error_buffer[0] = '\0';\r\n}\r\nenum pevent_errno pevent_filter_add_filter_str(struct event_filter *filter,\r\nconst char *filter_str)\r\n{\r\nstruct pevent *pevent = filter->pevent;\r\nstruct event_list *event;\r\nstruct event_list *events = NULL;\r\nconst char *filter_start;\r\nconst char *next_event;\r\nchar *this_event;\r\nchar *event_name = NULL;\r\nchar *sys_name = NULL;\r\nchar *sp;\r\nenum pevent_errno rtn = 0;\r\nint len;\r\nint ret;\r\nfilter_init_error_buf(filter);\r\nfilter_start = strchr(filter_str, ':');\r\nif (filter_start)\r\nlen = filter_start - filter_str;\r\nelse\r\nlen = strlen(filter_str);\r\ndo {\r\nnext_event = strchr(filter_str, ',');\r\nif (next_event &&\r\n(!filter_start || next_event < filter_start))\r\nlen = next_event - filter_str;\r\nelse if (filter_start)\r\nlen = filter_start - filter_str;\r\nelse\r\nlen = strlen(filter_str);\r\nthis_event = malloc(len + 1);\r\nif (this_event == NULL) {\r\nfree_events(events);\r\nreturn PEVENT_ERRNO__MEM_ALLOC_FAILED;\r\n}\r\nmemcpy(this_event, filter_str, len);\r\nthis_event[len] = 0;\r\nif (next_event)\r\nnext_event++;\r\nfilter_str = next_event;\r\nsys_name = strtok_r(this_event, "/", &sp);\r\nevent_name = strtok_r(NULL, "/", &sp);\r\nif (!sys_name) {\r\nfree_events(events);\r\nfree(this_event);\r\nreturn PEVENT_ERRNO__FILTER_NOT_FOUND;\r\n}\r\nret = find_event(pevent, &events, strim(sys_name), strim(event_name));\r\nif (ret < 0) {\r\nfree_events(events);\r\nfree(this_event);\r\nreturn ret;\r\n}\r\nfree(this_event);\r\n} while (filter_str);\r\nif (filter_start)\r\nfilter_start++;\r\nfor (event = events; event; event = event->next) {\r\nret = filter_event(filter, event->event, filter_start,\r\nfilter->error_buffer);\r\nif (ret < 0)\r\nrtn = ret;\r\nif (ret >= 0 && pevent->test_filters) {\r\nchar *test;\r\ntest = pevent_filter_make_string(filter, event->event->id);\r\nif (test) {\r\nprintf(" '%s: %s'\n", event->event->name, test);\r\nfree(test);\r\n}\r\n}\r\n}\r\nfree_events(events);\r\nif (rtn >= 0 && pevent->test_filters)\r\nexit(0);\r\nreturn rtn;\r\n}\r\nstatic void free_filter_type(struct filter_type *filter_type)\r\n{\r\nfree_arg(filter_type->filter);\r\n}\r\nint pevent_filter_strerror(struct event_filter *filter, enum pevent_errno err,\r\nchar *buf, size_t buflen)\r\n{\r\nif (err <= __PEVENT_ERRNO__START || err >= __PEVENT_ERRNO__END)\r\nreturn -1;\r\nif (strlen(filter->error_buffer) > 0) {\r\nsize_t len = snprintf(buf, buflen, "%s", filter->error_buffer);\r\nif (len > buflen)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nreturn pevent_strerror(filter->pevent, err, buf, buflen);\r\n}\r\nint pevent_filter_remove_event(struct event_filter *filter,\r\nint event_id)\r\n{\r\nstruct filter_type *filter_type;\r\nunsigned long len;\r\nif (!filter->filters)\r\nreturn 0;\r\nfilter_type = find_filter_type(filter, event_id);\r\nif (!filter_type)\r\nreturn 0;\r\nfree_filter_type(filter_type);\r\nlen = (unsigned long)(filter->event_filters + filter->filters) -\r\n(unsigned long)(filter_type + 1);\r\nmemmove(filter_type, filter_type + 1, len);\r\nfilter->filters--;\r\nmemset(&filter->event_filters[filter->filters], 0,\r\nsizeof(*filter_type));\r\nreturn 1;\r\n}\r\nvoid pevent_filter_reset(struct event_filter *filter)\r\n{\r\nint i;\r\nfor (i = 0; i < filter->filters; i++)\r\nfree_filter_type(&filter->event_filters[i]);\r\nfree(filter->event_filters);\r\nfilter->filters = 0;\r\nfilter->event_filters = NULL;\r\n}\r\nvoid pevent_filter_free(struct event_filter *filter)\r\n{\r\npevent_unref(filter->pevent);\r\npevent_filter_reset(filter);\r\nfree(filter);\r\n}\r\nstatic int copy_filter_type(struct event_filter *filter,\r\nstruct event_filter *source,\r\nstruct filter_type *filter_type)\r\n{\r\nstruct filter_arg *arg;\r\nstruct event_format *event;\r\nconst char *sys;\r\nconst char *name;\r\nchar *str;\r\nsys = filter_type->event->system;\r\nname = filter_type->event->name;\r\nevent = pevent_find_event_by_name(filter->pevent, sys, name);\r\nif (!event)\r\nreturn -1;\r\nstr = arg_to_str(source, filter_type->filter);\r\nif (!str)\r\nreturn -1;\r\nif (strcmp(str, "TRUE") == 0 || strcmp(str, "FALSE") == 0) {\r\narg = allocate_arg();\r\nif (arg == NULL)\r\nreturn -1;\r\narg->type = FILTER_ARG_BOOLEAN;\r\nif (strcmp(str, "TRUE") == 0)\r\narg->boolean.value = 1;\r\nelse\r\narg->boolean.value = 0;\r\nfilter_type = add_filter_type(filter, event->id);\r\nif (filter_type == NULL)\r\nreturn -1;\r\nfilter_type->filter = arg;\r\nfree(str);\r\nreturn 0;\r\n}\r\nfilter_event(filter, event, str, NULL);\r\nfree(str);\r\nreturn 0;\r\n}\r\nint pevent_filter_copy(struct event_filter *dest, struct event_filter *source)\r\n{\r\nint ret = 0;\r\nint i;\r\npevent_filter_reset(dest);\r\nfor (i = 0; i < source->filters; i++) {\r\nif (copy_filter_type(dest, source, &source->event_filters[i]))\r\nret = -1;\r\n}\r\nreturn ret;\r\n}\r\nint pevent_update_trivial(struct event_filter *dest, struct event_filter *source,\r\nenum filter_trivial_type type)\r\n{\r\nstruct pevent *src_pevent;\r\nstruct pevent *dest_pevent;\r\nstruct event_format *event;\r\nstruct filter_type *filter_type;\r\nstruct filter_arg *arg;\r\nchar *str;\r\nint i;\r\nsrc_pevent = source->pevent;\r\ndest_pevent = dest->pevent;\r\nif (!dest->filters || !source->filters)\r\nreturn 0;\r\nfor (i = 0; i < dest->filters; i++) {\r\nfilter_type = &dest->event_filters[i];\r\narg = filter_type->filter;\r\nif (arg->type != FILTER_ARG_BOOLEAN)\r\ncontinue;\r\nif ((arg->boolean.value && type == FILTER_TRIVIAL_FALSE) ||\r\n(!arg->boolean.value && type == FILTER_TRIVIAL_TRUE))\r\ncontinue;\r\nevent = filter_type->event;\r\nif (src_pevent != dest_pevent) {\r\nevent = pevent_find_event_by_name(src_pevent,\r\nevent->system,\r\nevent->name);\r\nif (!event)\r\nreturn -1;\r\n}\r\nstr = pevent_filter_make_string(source, event->id);\r\nif (!str)\r\ncontinue;\r\nif (strcmp(str, "TRUE") != 0 && strcmp(str, "FALSE") != 0)\r\nfilter_event(dest, event, str, NULL);\r\nfree(str);\r\n}\r\nreturn 0;\r\n}\r\nint pevent_filter_clear_trivial(struct event_filter *filter,\r\nenum filter_trivial_type type)\r\n{\r\nstruct filter_type *filter_type;\r\nint count = 0;\r\nint *ids = NULL;\r\nint i;\r\nif (!filter->filters)\r\nreturn 0;\r\nfor (i = 0; i < filter->filters; i++) {\r\nint *new_ids;\r\nfilter_type = &filter->event_filters[i];\r\nif (filter_type->filter->type != FILTER_ARG_BOOLEAN)\r\ncontinue;\r\nswitch (type) {\r\ncase FILTER_TRIVIAL_FALSE:\r\nif (filter_type->filter->boolean.value)\r\ncontinue;\r\ncase FILTER_TRIVIAL_TRUE:\r\nif (!filter_type->filter->boolean.value)\r\ncontinue;\r\ndefault:\r\nbreak;\r\n}\r\nnew_ids = realloc(ids, sizeof(*ids) * (count + 1));\r\nif (!new_ids) {\r\nfree(ids);\r\nreturn -1;\r\n}\r\nids = new_ids;\r\nids[count++] = filter_type->event_id;\r\n}\r\nif (!count)\r\nreturn 0;\r\nfor (i = 0; i < count; i++)\r\npevent_filter_remove_event(filter, ids[i]);\r\nfree(ids);\r\nreturn 0;\r\n}\r\nint pevent_filter_event_has_trivial(struct event_filter *filter,\r\nint event_id,\r\nenum filter_trivial_type type)\r\n{\r\nstruct filter_type *filter_type;\r\nif (!filter->filters)\r\nreturn 0;\r\nfilter_type = find_filter_type(filter, event_id);\r\nif (!filter_type)\r\nreturn 0;\r\nif (filter_type->filter->type != FILTER_ARG_BOOLEAN)\r\nreturn 0;\r\nswitch (type) {\r\ncase FILTER_TRIVIAL_FALSE:\r\nreturn !filter_type->filter->boolean.value;\r\ncase FILTER_TRIVIAL_TRUE:\r\nreturn filter_type->filter->boolean.value;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic const char *\r\nget_comm(struct event_format *event, struct pevent_record *record)\r\n{\r\nconst char *comm;\r\nint pid;\r\npid = pevent_data_pid(event->pevent, record);\r\ncomm = pevent_data_comm_from_pid(event->pevent, pid);\r\nreturn comm;\r\n}\r\nstatic unsigned long long\r\nget_value(struct event_format *event,\r\nstruct format_field *field, struct pevent_record *record)\r\n{\r\nunsigned long long val;\r\nif (field == &comm) {\r\nconst char *name;\r\nname = get_comm(event, record);\r\nreturn (unsigned long)name;\r\n}\r\npevent_read_number_field(field, record->data, &val);\r\nif (!(field->flags & FIELD_IS_SIGNED))\r\nreturn val;\r\nswitch (field->size) {\r\ncase 1:\r\nreturn (char)val;\r\ncase 2:\r\nreturn (short)val;\r\ncase 4:\r\nreturn (int)val;\r\ncase 8:\r\nreturn (long long)val;\r\n}\r\nreturn val;\r\n}\r\nstatic unsigned long long\r\nget_exp_value(struct event_format *event, struct filter_arg *arg,\r\nstruct pevent_record *record, enum pevent_errno *err)\r\n{\r\nunsigned long long lval, rval;\r\nlval = get_arg_value(event, arg->exp.left, record, err);\r\nrval = get_arg_value(event, arg->exp.right, record, err);\r\nif (*err) {\r\nreturn 0;\r\n}\r\nswitch (arg->exp.type) {\r\ncase FILTER_EXP_ADD:\r\nreturn lval + rval;\r\ncase FILTER_EXP_SUB:\r\nreturn lval - rval;\r\ncase FILTER_EXP_MUL:\r\nreturn lval * rval;\r\ncase FILTER_EXP_DIV:\r\nreturn lval / rval;\r\ncase FILTER_EXP_MOD:\r\nreturn lval % rval;\r\ncase FILTER_EXP_RSHIFT:\r\nreturn lval >> rval;\r\ncase FILTER_EXP_LSHIFT:\r\nreturn lval << rval;\r\ncase FILTER_EXP_AND:\r\nreturn lval & rval;\r\ncase FILTER_EXP_OR:\r\nreturn lval | rval;\r\ncase FILTER_EXP_XOR:\r\nreturn lval ^ rval;\r\ncase FILTER_EXP_NOT:\r\ndefault:\r\nif (!*err)\r\n*err = PEVENT_ERRNO__INVALID_EXP_TYPE;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long long\r\nget_arg_value(struct event_format *event, struct filter_arg *arg,\r\nstruct pevent_record *record, enum pevent_errno *err)\r\n{\r\nswitch (arg->type) {\r\ncase FILTER_ARG_FIELD:\r\nreturn get_value(event, arg->field.field, record);\r\ncase FILTER_ARG_VALUE:\r\nif (arg->value.type != FILTER_NUMBER) {\r\nif (!*err)\r\n*err = PEVENT_ERRNO__NOT_A_NUMBER;\r\n}\r\nreturn arg->value.val;\r\ncase FILTER_ARG_EXP:\r\nreturn get_exp_value(event, arg, record, err);\r\ndefault:\r\nif (!*err)\r\n*err = PEVENT_ERRNO__INVALID_ARG_TYPE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int test_num(struct event_format *event, struct filter_arg *arg,\r\nstruct pevent_record *record, enum pevent_errno *err)\r\n{\r\nunsigned long long lval, rval;\r\nlval = get_arg_value(event, arg->num.left, record, err);\r\nrval = get_arg_value(event, arg->num.right, record, err);\r\nif (*err) {\r\nreturn 0;\r\n}\r\nswitch (arg->num.type) {\r\ncase FILTER_CMP_EQ:\r\nreturn lval == rval;\r\ncase FILTER_CMP_NE:\r\nreturn lval != rval;\r\ncase FILTER_CMP_GT:\r\nreturn lval > rval;\r\ncase FILTER_CMP_LT:\r\nreturn lval < rval;\r\ncase FILTER_CMP_GE:\r\nreturn lval >= rval;\r\ncase FILTER_CMP_LE:\r\nreturn lval <= rval;\r\ndefault:\r\nif (!*err)\r\n*err = PEVENT_ERRNO__ILLEGAL_INTEGER_CMP;\r\nreturn 0;\r\n}\r\n}\r\nstatic const char *get_field_str(struct filter_arg *arg, struct pevent_record *record)\r\n{\r\nstruct event_format *event;\r\nstruct pevent *pevent;\r\nunsigned long long addr;\r\nconst char *val = NULL;\r\nchar hex[64];\r\nif (arg->str.field->flags & FIELD_IS_STRING) {\r\nval = record->data + arg->str.field->offset;\r\nif (*(val + arg->str.field->size - 1)) {\r\nmemcpy(arg->str.buffer, val, arg->str.field->size);\r\nval = arg->str.buffer;\r\n}\r\n} else {\r\nevent = arg->str.field->event;\r\npevent = event->pevent;\r\naddr = get_value(event, arg->str.field, record);\r\nif (arg->str.field->flags & (FIELD_IS_POINTER | FIELD_IS_LONG))\r\nval = pevent_find_function(pevent, addr);\r\nif (val == NULL) {\r\nsnprintf(hex, 64, "0x%llx", addr);\r\nval = hex;\r\n}\r\n}\r\nreturn val;\r\n}\r\nstatic int test_str(struct event_format *event, struct filter_arg *arg,\r\nstruct pevent_record *record, enum pevent_errno *err)\r\n{\r\nconst char *val;\r\nif (arg->str.field == &comm)\r\nval = get_comm(event, record);\r\nelse\r\nval = get_field_str(arg, record);\r\nswitch (arg->str.type) {\r\ncase FILTER_CMP_MATCH:\r\nreturn strcmp(val, arg->str.val) == 0;\r\ncase FILTER_CMP_NOT_MATCH:\r\nreturn strcmp(val, arg->str.val) != 0;\r\ncase FILTER_CMP_REGEX:\r\nreturn !regexec(&arg->str.reg, val, 0, NULL, 0);\r\ncase FILTER_CMP_NOT_REGEX:\r\nreturn regexec(&arg->str.reg, val, 0, NULL, 0);\r\ndefault:\r\nif (!*err)\r\n*err = PEVENT_ERRNO__ILLEGAL_STRING_CMP;\r\nreturn 0;\r\n}\r\n}\r\nstatic int test_op(struct event_format *event, struct filter_arg *arg,\r\nstruct pevent_record *record, enum pevent_errno *err)\r\n{\r\nswitch (arg->op.type) {\r\ncase FILTER_OP_AND:\r\nreturn test_filter(event, arg->op.left, record, err) &&\r\ntest_filter(event, arg->op.right, record, err);\r\ncase FILTER_OP_OR:\r\nreturn test_filter(event, arg->op.left, record, err) ||\r\ntest_filter(event, arg->op.right, record, err);\r\ncase FILTER_OP_NOT:\r\nreturn !test_filter(event, arg->op.right, record, err);\r\ndefault:\r\nif (!*err)\r\n*err = PEVENT_ERRNO__INVALID_OP_TYPE;\r\nreturn 0;\r\n}\r\n}\r\nstatic int test_filter(struct event_format *event, struct filter_arg *arg,\r\nstruct pevent_record *record, enum pevent_errno *err)\r\n{\r\nif (*err) {\r\nreturn 0;\r\n}\r\nswitch (arg->type) {\r\ncase FILTER_ARG_BOOLEAN:\r\nreturn arg->boolean.value;\r\ncase FILTER_ARG_OP:\r\nreturn test_op(event, arg, record, err);\r\ncase FILTER_ARG_NUM:\r\nreturn test_num(event, arg, record, err);\r\ncase FILTER_ARG_STR:\r\nreturn test_str(event, arg, record, err);\r\ncase FILTER_ARG_EXP:\r\ncase FILTER_ARG_VALUE:\r\ncase FILTER_ARG_FIELD:\r\nreturn !!get_arg_value(event, arg, record, err);\r\ndefault:\r\nif (!*err)\r\n*err = PEVENT_ERRNO__INVALID_ARG_TYPE;\r\nreturn 0;\r\n}\r\n}\r\nint pevent_event_filtered(struct event_filter *filter, int event_id)\r\n{\r\nstruct filter_type *filter_type;\r\nif (!filter->filters)\r\nreturn 0;\r\nfilter_type = find_filter_type(filter, event_id);\r\nreturn filter_type ? 1 : 0;\r\n}\r\nenum pevent_errno pevent_filter_match(struct event_filter *filter,\r\nstruct pevent_record *record)\r\n{\r\nstruct pevent *pevent = filter->pevent;\r\nstruct filter_type *filter_type;\r\nint event_id;\r\nint ret;\r\nenum pevent_errno err = 0;\r\nfilter_init_error_buf(filter);\r\nif (!filter->filters)\r\nreturn PEVENT_ERRNO__NO_FILTER;\r\nevent_id = pevent_data_type(pevent, record);\r\nfilter_type = find_filter_type(filter, event_id);\r\nif (!filter_type)\r\nreturn PEVENT_ERRNO__FILTER_NOT_FOUND;\r\nret = test_filter(filter_type->event, filter_type->filter, record, &err);\r\nif (err)\r\nreturn err;\r\nreturn ret ? PEVENT_ERRNO__FILTER_MATCH : PEVENT_ERRNO__FILTER_MISS;\r\n}\r\nstatic char *op_to_str(struct event_filter *filter, struct filter_arg *arg)\r\n{\r\nchar *str = NULL;\r\nchar *left = NULL;\r\nchar *right = NULL;\r\nchar *op = NULL;\r\nint left_val = -1;\r\nint right_val = -1;\r\nint val;\r\nswitch (arg->op.type) {\r\ncase FILTER_OP_AND:\r\nop = "&&";\r\ncase FILTER_OP_OR:\r\nif (!op)\r\nop = "||";\r\nleft = arg_to_str(filter, arg->op.left);\r\nright = arg_to_str(filter, arg->op.right);\r\nif (!left || !right)\r\nbreak;\r\nif (strcmp(left, "TRUE") == 0)\r\nleft_val = 1;\r\nelse if (strcmp(left, "FALSE") == 0)\r\nleft_val = 0;\r\nif (strcmp(right, "TRUE") == 0)\r\nright_val = 1;\r\nelse if (strcmp(right, "FALSE") == 0)\r\nright_val = 0;\r\nif (left_val >= 0) {\r\nif ((arg->op.type == FILTER_OP_AND && !left_val) ||\r\n(arg->op.type == FILTER_OP_OR && left_val)) {\r\nstr = left;\r\nleft = NULL;\r\nbreak;\r\n}\r\nif (right_val >= 0) {\r\nval = 0;\r\nswitch (arg->op.type) {\r\ncase FILTER_OP_AND:\r\nval = left_val && right_val;\r\nbreak;\r\ncase FILTER_OP_OR:\r\nval = left_val || right_val;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nasprintf(&str, val ? "TRUE" : "FALSE");\r\nbreak;\r\n}\r\n}\r\nif (right_val >= 0) {\r\nif ((arg->op.type == FILTER_OP_AND && !right_val) ||\r\n(arg->op.type == FILTER_OP_OR && right_val)) {\r\nstr = right;\r\nright = NULL;\r\nbreak;\r\n}\r\nstr = left;\r\nleft = NULL;\r\nbreak;\r\n}\r\nasprintf(&str, "(%s) %s (%s)", left, op, right);\r\nbreak;\r\ncase FILTER_OP_NOT:\r\nop = "!";\r\nright = arg_to_str(filter, arg->op.right);\r\nif (!right)\r\nbreak;\r\nif (strcmp(right, "TRUE") == 0)\r\nright_val = 1;\r\nelse if (strcmp(right, "FALSE") == 0)\r\nright_val = 0;\r\nif (right_val >= 0) {\r\nasprintf(&str, right_val ? "FALSE" : "TRUE");\r\nbreak;\r\n}\r\nasprintf(&str, "%s(%s)", op, right);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfree(left);\r\nfree(right);\r\nreturn str;\r\n}\r\nstatic char *val_to_str(struct event_filter *filter, struct filter_arg *arg)\r\n{\r\nchar *str = NULL;\r\nasprintf(&str, "%lld", arg->value.val);\r\nreturn str;\r\n}\r\nstatic char *field_to_str(struct event_filter *filter, struct filter_arg *arg)\r\n{\r\nreturn strdup(arg->field.field->name);\r\n}\r\nstatic char *exp_to_str(struct event_filter *filter, struct filter_arg *arg)\r\n{\r\nchar *lstr;\r\nchar *rstr;\r\nchar *op;\r\nchar *str = NULL;\r\nlstr = arg_to_str(filter, arg->exp.left);\r\nrstr = arg_to_str(filter, arg->exp.right);\r\nif (!lstr || !rstr)\r\ngoto out;\r\nswitch (arg->exp.type) {\r\ncase FILTER_EXP_ADD:\r\nop = "+";\r\nbreak;\r\ncase FILTER_EXP_SUB:\r\nop = "-";\r\nbreak;\r\ncase FILTER_EXP_MUL:\r\nop = "*";\r\nbreak;\r\ncase FILTER_EXP_DIV:\r\nop = "/";\r\nbreak;\r\ncase FILTER_EXP_MOD:\r\nop = "%";\r\nbreak;\r\ncase FILTER_EXP_RSHIFT:\r\nop = ">>";\r\nbreak;\r\ncase FILTER_EXP_LSHIFT:\r\nop = "<<";\r\nbreak;\r\ncase FILTER_EXP_AND:\r\nop = "&";\r\nbreak;\r\ncase FILTER_EXP_OR:\r\nop = "|";\r\nbreak;\r\ncase FILTER_EXP_XOR:\r\nop = "^";\r\nbreak;\r\ndefault:\r\nop = "[ERROR IN EXPRESSION TYPE]";\r\nbreak;\r\n}\r\nasprintf(&str, "%s %s %s", lstr, op, rstr);\r\nout:\r\nfree(lstr);\r\nfree(rstr);\r\nreturn str;\r\n}\r\nstatic char *num_to_str(struct event_filter *filter, struct filter_arg *arg)\r\n{\r\nchar *lstr;\r\nchar *rstr;\r\nchar *str = NULL;\r\nchar *op = NULL;\r\nlstr = arg_to_str(filter, arg->num.left);\r\nrstr = arg_to_str(filter, arg->num.right);\r\nif (!lstr || !rstr)\r\ngoto out;\r\nswitch (arg->num.type) {\r\ncase FILTER_CMP_EQ:\r\nop = "==";\r\ncase FILTER_CMP_NE:\r\nif (!op)\r\nop = "!=";\r\ncase FILTER_CMP_GT:\r\nif (!op)\r\nop = ">";\r\ncase FILTER_CMP_LT:\r\nif (!op)\r\nop = "<";\r\ncase FILTER_CMP_GE:\r\nif (!op)\r\nop = ">=";\r\ncase FILTER_CMP_LE:\r\nif (!op)\r\nop = "<=";\r\nasprintf(&str, "%s %s %s", lstr, op, rstr);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nfree(lstr);\r\nfree(rstr);\r\nreturn str;\r\n}\r\nstatic char *str_to_str(struct event_filter *filter, struct filter_arg *arg)\r\n{\r\nchar *str = NULL;\r\nchar *op = NULL;\r\nswitch (arg->str.type) {\r\ncase FILTER_CMP_MATCH:\r\nop = "==";\r\ncase FILTER_CMP_NOT_MATCH:\r\nif (!op)\r\nop = "!=";\r\ncase FILTER_CMP_REGEX:\r\nif (!op)\r\nop = "=~";\r\ncase FILTER_CMP_NOT_REGEX:\r\nif (!op)\r\nop = "!~";\r\nasprintf(&str, "%s %s \"%s\"",\r\narg->str.field->name, op, arg->str.val);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn str;\r\n}\r\nstatic char *arg_to_str(struct event_filter *filter, struct filter_arg *arg)\r\n{\r\nchar *str = NULL;\r\nswitch (arg->type) {\r\ncase FILTER_ARG_BOOLEAN:\r\nasprintf(&str, arg->boolean.value ? "TRUE" : "FALSE");\r\nreturn str;\r\ncase FILTER_ARG_OP:\r\nreturn op_to_str(filter, arg);\r\ncase FILTER_ARG_NUM:\r\nreturn num_to_str(filter, arg);\r\ncase FILTER_ARG_STR:\r\nreturn str_to_str(filter, arg);\r\ncase FILTER_ARG_VALUE:\r\nreturn val_to_str(filter, arg);\r\ncase FILTER_ARG_FIELD:\r\nreturn field_to_str(filter, arg);\r\ncase FILTER_ARG_EXP:\r\nreturn exp_to_str(filter, arg);\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nchar *\r\npevent_filter_make_string(struct event_filter *filter, int event_id)\r\n{\r\nstruct filter_type *filter_type;\r\nif (!filter->filters)\r\nreturn NULL;\r\nfilter_type = find_filter_type(filter, event_id);\r\nif (!filter_type)\r\nreturn NULL;\r\nreturn arg_to_str(filter, filter_type->filter);\r\n}\r\nint pevent_filter_compare(struct event_filter *filter1, struct event_filter *filter2)\r\n{\r\nstruct filter_type *filter_type1;\r\nstruct filter_type *filter_type2;\r\nchar *str1, *str2;\r\nint result;\r\nint i;\r\nif (filter1->filters != filter2->filters)\r\nreturn 0;\r\nif (!filter1->filters && !filter2->filters)\r\nreturn 1;\r\nfor (i = 0; i < filter1->filters; i++) {\r\nfilter_type1 = &filter1->event_filters[i];\r\nfilter_type2 = find_filter_type(filter2, filter_type1->event_id);\r\nif (!filter_type2)\r\nbreak;\r\nif (filter_type1->filter->type != filter_type2->filter->type)\r\nbreak;\r\nswitch (filter_type1->filter->type) {\r\ncase FILTER_TRIVIAL_FALSE:\r\ncase FILTER_TRIVIAL_TRUE:\r\ncontinue;\r\ndefault:\r\nbreak;\r\n}\r\nstr1 = arg_to_str(filter1, filter_type1->filter);\r\nstr2 = arg_to_str(filter2, filter_type2->filter);\r\nif (str1 && str2)\r\nresult = strcmp(str1, str2) != 0;\r\nelse\r\nresult = 1;\r\nfree(str1);\r\nfree(str2);\r\nif (result)\r\nbreak;\r\n}\r\nif (i < filter1->filters)\r\nreturn 0;\r\nreturn 1;\r\n}
