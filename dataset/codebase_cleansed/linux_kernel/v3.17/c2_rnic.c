static int c2_adapter_init(struct c2_dev *c2dev)\r\n{\r\nstruct c2wr_init_req wr;\r\nint err;\r\nmemset(&wr, 0, sizeof(wr));\r\nc2_wr_set_id(&wr, CCWR_INIT);\r\nwr.hdr.context = 0;\r\nwr.hint_count = cpu_to_be64(c2dev->hint_count_dma);\r\nwr.q0_host_shared = cpu_to_be64(c2dev->req_vq.shared_dma);\r\nwr.q1_host_shared = cpu_to_be64(c2dev->rep_vq.shared_dma);\r\nwr.q1_host_msg_pool = cpu_to_be64(c2dev->rep_vq.host_dma);\r\nwr.q2_host_shared = cpu_to_be64(c2dev->aeq.shared_dma);\r\nwr.q2_host_msg_pool = cpu_to_be64(c2dev->aeq.host_dma);\r\nerr = vq_send_wr(c2dev, (union c2wr *) & wr);\r\nreturn err;\r\n}\r\nstatic void c2_adapter_term(struct c2_dev *c2dev)\r\n{\r\nstruct c2wr_init_req wr;\r\nmemset(&wr, 0, sizeof(wr));\r\nc2_wr_set_id(&wr, CCWR_TERM);\r\nwr.hdr.context = 0;\r\nvq_send_wr(c2dev, (union c2wr *) & wr);\r\nc2dev->init = 0;\r\nreturn;\r\n}\r\nstatic int c2_rnic_query(struct c2_dev *c2dev, struct ib_device_attr *props)\r\n{\r\nstruct c2_vq_req *vq_req;\r\nstruct c2wr_rnic_query_req wr;\r\nstruct c2wr_rnic_query_rep *reply;\r\nint err;\r\nvq_req = vq_req_alloc(c2dev);\r\nif (!vq_req)\r\nreturn -ENOMEM;\r\nc2_wr_set_id(&wr, CCWR_RNIC_QUERY);\r\nwr.hdr.context = (unsigned long) vq_req;\r\nwr.rnic_handle = c2dev->adapter_handle;\r\nvq_req_get(c2dev, vq_req);\r\nerr = vq_send_wr(c2dev, (union c2wr *) &wr);\r\nif (err) {\r\nvq_req_put(c2dev, vq_req);\r\ngoto bail1;\r\n}\r\nerr = vq_wait_for_reply(c2dev, vq_req);\r\nif (err)\r\ngoto bail1;\r\nreply =\r\n(struct c2wr_rnic_query_rep *) (unsigned long) (vq_req->reply_msg);\r\nif (!reply)\r\nerr = -ENOMEM;\r\nelse\r\nerr = c2_errno(reply);\r\nif (err)\r\ngoto bail2;\r\nprops->fw_ver =\r\n((u64)be32_to_cpu(reply->fw_ver_major) << 32) |\r\n((be32_to_cpu(reply->fw_ver_minor) & 0xFFFF) << 16) |\r\n(be32_to_cpu(reply->fw_ver_patch) & 0xFFFF);\r\nmemcpy(&props->sys_image_guid, c2dev->netdev->dev_addr, 6);\r\nprops->max_mr_size = 0xFFFFFFFF;\r\nprops->page_size_cap = ~(C2_MIN_PAGESIZE-1);\r\nprops->vendor_id = be32_to_cpu(reply->vendor_id);\r\nprops->vendor_part_id = be32_to_cpu(reply->part_number);\r\nprops->hw_ver = be32_to_cpu(reply->hw_version);\r\nprops->max_qp = be32_to_cpu(reply->max_qps);\r\nprops->max_qp_wr = be32_to_cpu(reply->max_qp_depth);\r\nprops->device_cap_flags = c2dev->device_cap_flags;\r\nprops->max_sge = C2_MAX_SGES;\r\nprops->max_sge_rd = C2_MAX_SGE_RD;\r\nprops->max_cq = be32_to_cpu(reply->max_cqs);\r\nprops->max_cqe = be32_to_cpu(reply->max_cq_depth);\r\nprops->max_mr = be32_to_cpu(reply->max_mrs);\r\nprops->max_pd = be32_to_cpu(reply->max_pds);\r\nprops->max_qp_rd_atom = be32_to_cpu(reply->max_qp_ird);\r\nprops->max_ee_rd_atom = 0;\r\nprops->max_res_rd_atom = be32_to_cpu(reply->max_global_ird);\r\nprops->max_qp_init_rd_atom = be32_to_cpu(reply->max_qp_ord);\r\nprops->max_ee_init_rd_atom = 0;\r\nprops->atomic_cap = IB_ATOMIC_NONE;\r\nprops->max_ee = 0;\r\nprops->max_rdd = 0;\r\nprops->max_mw = be32_to_cpu(reply->max_mws);\r\nprops->max_raw_ipv6_qp = 0;\r\nprops->max_raw_ethy_qp = 0;\r\nprops->max_mcast_grp = 0;\r\nprops->max_mcast_qp_attach = 0;\r\nprops->max_total_mcast_qp_attach = 0;\r\nprops->max_ah = 0;\r\nprops->max_fmr = 0;\r\nprops->max_map_per_fmr = 0;\r\nprops->max_srq = 0;\r\nprops->max_srq_wr = 0;\r\nprops->max_srq_sge = 0;\r\nprops->max_pkeys = 0;\r\nprops->local_ca_ack_delay = 0;\r\nbail2:\r\nvq_repbuf_free(c2dev, reply);\r\nbail1:\r\nvq_req_free(c2dev, vq_req);\r\nreturn err;\r\n}\r\nint c2_add_addr(struct c2_dev *c2dev, __be32 inaddr, __be32 inmask)\r\n{\r\nstruct c2_vq_req *vq_req;\r\nstruct c2wr_rnic_setconfig_req *wr;\r\nstruct c2wr_rnic_setconfig_rep *reply;\r\nstruct c2_netaddr netaddr;\r\nint err, len;\r\nvq_req = vq_req_alloc(c2dev);\r\nif (!vq_req)\r\nreturn -ENOMEM;\r\nlen = sizeof(struct c2_netaddr);\r\nwr = kmalloc(c2dev->req_vq.msg_size, GFP_KERNEL);\r\nif (!wr) {\r\nerr = -ENOMEM;\r\ngoto bail0;\r\n}\r\nc2_wr_set_id(wr, CCWR_RNIC_SETCONFIG);\r\nwr->hdr.context = (unsigned long) vq_req;\r\nwr->rnic_handle = c2dev->adapter_handle;\r\nwr->option = cpu_to_be32(C2_CFG_ADD_ADDR);\r\nnetaddr.ip_addr = inaddr;\r\nnetaddr.netmask = inmask;\r\nnetaddr.mtu = 0;\r\nmemcpy(wr->data, &netaddr, len);\r\nvq_req_get(c2dev, vq_req);\r\nerr = vq_send_wr(c2dev, (union c2wr *) wr);\r\nif (err) {\r\nvq_req_put(c2dev, vq_req);\r\ngoto bail1;\r\n}\r\nerr = vq_wait_for_reply(c2dev, vq_req);\r\nif (err)\r\ngoto bail1;\r\nreply =\r\n(struct c2wr_rnic_setconfig_rep *) (unsigned long) (vq_req->reply_msg);\r\nif (!reply) {\r\nerr = -ENOMEM;\r\ngoto bail1;\r\n}\r\nerr = c2_errno(reply);\r\nvq_repbuf_free(c2dev, reply);\r\nbail1:\r\nkfree(wr);\r\nbail0:\r\nvq_req_free(c2dev, vq_req);\r\nreturn err;\r\n}\r\nint c2_del_addr(struct c2_dev *c2dev, __be32 inaddr, __be32 inmask)\r\n{\r\nstruct c2_vq_req *vq_req;\r\nstruct c2wr_rnic_setconfig_req *wr;\r\nstruct c2wr_rnic_setconfig_rep *reply;\r\nstruct c2_netaddr netaddr;\r\nint err, len;\r\nvq_req = vq_req_alloc(c2dev);\r\nif (!vq_req)\r\nreturn -ENOMEM;\r\nlen = sizeof(struct c2_netaddr);\r\nwr = kmalloc(c2dev->req_vq.msg_size, GFP_KERNEL);\r\nif (!wr) {\r\nerr = -ENOMEM;\r\ngoto bail0;\r\n}\r\nc2_wr_set_id(wr, CCWR_RNIC_SETCONFIG);\r\nwr->hdr.context = (unsigned long) vq_req;\r\nwr->rnic_handle = c2dev->adapter_handle;\r\nwr->option = cpu_to_be32(C2_CFG_DEL_ADDR);\r\nnetaddr.ip_addr = inaddr;\r\nnetaddr.netmask = inmask;\r\nnetaddr.mtu = 0;\r\nmemcpy(wr->data, &netaddr, len);\r\nvq_req_get(c2dev, vq_req);\r\nerr = vq_send_wr(c2dev, (union c2wr *) wr);\r\nif (err) {\r\nvq_req_put(c2dev, vq_req);\r\ngoto bail1;\r\n}\r\nerr = vq_wait_for_reply(c2dev, vq_req);\r\nif (err)\r\ngoto bail1;\r\nreply =\r\n(struct c2wr_rnic_setconfig_rep *) (unsigned long) (vq_req->reply_msg);\r\nif (!reply) {\r\nerr = -ENOMEM;\r\ngoto bail1;\r\n}\r\nerr = c2_errno(reply);\r\nvq_repbuf_free(c2dev, reply);\r\nbail1:\r\nkfree(wr);\r\nbail0:\r\nvq_req_free(c2dev, vq_req);\r\nreturn err;\r\n}\r\nstatic int c2_rnic_open(struct c2_dev *c2dev)\r\n{\r\nstruct c2_vq_req *vq_req;\r\nunion c2wr wr;\r\nstruct c2wr_rnic_open_rep *reply;\r\nint err;\r\nvq_req = vq_req_alloc(c2dev);\r\nif (vq_req == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nmemset(&wr, 0, sizeof(wr));\r\nc2_wr_set_id(&wr, CCWR_RNIC_OPEN);\r\nwr.rnic_open.req.hdr.context = (unsigned long) (vq_req);\r\nwr.rnic_open.req.flags = cpu_to_be16(RNIC_PRIV_MODE);\r\nwr.rnic_open.req.port_num = cpu_to_be16(0);\r\nwr.rnic_open.req.user_context = (unsigned long) c2dev;\r\nvq_req_get(c2dev, vq_req);\r\nerr = vq_send_wr(c2dev, &wr);\r\nif (err) {\r\nvq_req_put(c2dev, vq_req);\r\ngoto bail0;\r\n}\r\nerr = vq_wait_for_reply(c2dev, vq_req);\r\nif (err) {\r\ngoto bail0;\r\n}\r\nreply = (struct c2wr_rnic_open_rep *) (unsigned long) (vq_req->reply_msg);\r\nif (!reply) {\r\nerr = -ENOMEM;\r\ngoto bail0;\r\n}\r\nif ((err = c2_errno(reply)) != 0) {\r\ngoto bail1;\r\n}\r\nc2dev->adapter_handle = reply->rnic_handle;\r\nbail1:\r\nvq_repbuf_free(c2dev, reply);\r\nbail0:\r\nvq_req_free(c2dev, vq_req);\r\nreturn err;\r\n}\r\nstatic int c2_rnic_close(struct c2_dev *c2dev)\r\n{\r\nstruct c2_vq_req *vq_req;\r\nunion c2wr wr;\r\nstruct c2wr_rnic_close_rep *reply;\r\nint err;\r\nvq_req = vq_req_alloc(c2dev);\r\nif (vq_req == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nmemset(&wr, 0, sizeof(wr));\r\nc2_wr_set_id(&wr, CCWR_RNIC_CLOSE);\r\nwr.rnic_close.req.hdr.context = (unsigned long) vq_req;\r\nwr.rnic_close.req.rnic_handle = c2dev->adapter_handle;\r\nvq_req_get(c2dev, vq_req);\r\nerr = vq_send_wr(c2dev, &wr);\r\nif (err) {\r\nvq_req_put(c2dev, vq_req);\r\ngoto bail0;\r\n}\r\nerr = vq_wait_for_reply(c2dev, vq_req);\r\nif (err) {\r\ngoto bail0;\r\n}\r\nreply = (struct c2wr_rnic_close_rep *) (unsigned long) (vq_req->reply_msg);\r\nif (!reply) {\r\nerr = -ENOMEM;\r\ngoto bail0;\r\n}\r\nif ((err = c2_errno(reply)) != 0) {\r\ngoto bail1;\r\n}\r\nc2dev->adapter_handle = 0;\r\nbail1:\r\nvq_repbuf_free(c2dev, reply);\r\nbail0:\r\nvq_req_free(c2dev, vq_req);\r\nreturn err;\r\n}\r\nint c2_rnic_init(struct c2_dev *c2dev)\r\n{\r\nint err;\r\nu32 qsize, msgsize;\r\nvoid *q1_pages;\r\nvoid *q2_pages;\r\nvoid __iomem *mmio_regs;\r\nc2dev->device_cap_flags =\r\n(IB_DEVICE_RESIZE_MAX_WR |\r\nIB_DEVICE_CURR_QP_STATE_MOD |\r\nIB_DEVICE_SYS_IMAGE_GUID |\r\nIB_DEVICE_LOCAL_DMA_LKEY |\r\nIB_DEVICE_MEM_WINDOW);\r\nc2dev->qptr_array = vzalloc(C2_MAX_CQS * sizeof(void *));\r\nif (!c2dev->qptr_array) {\r\nreturn -ENOMEM;\r\n}\r\nc2dev->qptr_array[0] = (void *) &c2dev->req_vq;\r\nc2dev->qptr_array[1] = (void *) &c2dev->rep_vq;\r\nc2dev->qptr_array[2] = (void *) &c2dev->aeq;\r\ninit_waitqueue_head(&c2dev->req_vq_wo);\r\nspin_lock_init(&c2dev->vqlock);\r\nspin_lock_init(&c2dev->lock);\r\nerr = c2_init_mqsp_pool(c2dev, GFP_KERNEL, &c2dev->kern_mqsp_pool);\r\nif (err) {\r\ngoto bail0;\r\n}\r\nc2dev->hint_count = c2_alloc_mqsp(c2dev, c2dev->kern_mqsp_pool,\r\n&c2dev->hint_count_dma,\r\nGFP_KERNEL);\r\nc2dev->req_vq.shared = c2_alloc_mqsp(c2dev, c2dev->kern_mqsp_pool,\r\n&c2dev->req_vq.shared_dma,\r\nGFP_KERNEL);\r\nc2dev->rep_vq.shared = c2_alloc_mqsp(c2dev, c2dev->kern_mqsp_pool,\r\n&c2dev->rep_vq.shared_dma,\r\nGFP_KERNEL);\r\nc2dev->aeq.shared = c2_alloc_mqsp(c2dev, c2dev->kern_mqsp_pool,\r\n&c2dev->aeq.shared_dma, GFP_KERNEL);\r\nif (!c2dev->hint_count || !c2dev->req_vq.shared ||\r\n!c2dev->rep_vq.shared || !c2dev->aeq.shared) {\r\nerr = -ENOMEM;\r\ngoto bail1;\r\n}\r\nmmio_regs = c2dev->kva;\r\nc2_mq_req_init(&c2dev->req_vq, 0,\r\nbe32_to_cpu((__force __be32) readl(mmio_regs + C2_REGS_Q0_QSIZE)),\r\nbe32_to_cpu((__force __be32) readl(mmio_regs + C2_REGS_Q0_MSGSIZE)),\r\nmmio_regs +\r\nbe32_to_cpu((__force __be32) readl(mmio_regs + C2_REGS_Q0_POOLSTART)),\r\nmmio_regs +\r\nbe32_to_cpu((__force __be32) readl(mmio_regs + C2_REGS_Q0_SHARED)),\r\nC2_MQ_ADAPTER_TARGET);\r\nqsize = be32_to_cpu((__force __be32) readl(mmio_regs + C2_REGS_Q1_QSIZE));\r\nmsgsize = be32_to_cpu((__force __be32) readl(mmio_regs + C2_REGS_Q1_MSGSIZE));\r\nq1_pages = dma_alloc_coherent(&c2dev->pcidev->dev, qsize * msgsize,\r\n&c2dev->rep_vq.host_dma, GFP_KERNEL);\r\nif (!q1_pages) {\r\nerr = -ENOMEM;\r\ngoto bail1;\r\n}\r\ndma_unmap_addr_set(&c2dev->rep_vq, mapping, c2dev->rep_vq.host_dma);\r\npr_debug("%s rep_vq va %p dma %llx\n", __func__, q1_pages,\r\n(unsigned long long) c2dev->rep_vq.host_dma);\r\nc2_mq_rep_init(&c2dev->rep_vq,\r\n1,\r\nqsize,\r\nmsgsize,\r\nq1_pages,\r\nmmio_regs +\r\nbe32_to_cpu((__force __be32) readl(mmio_regs + C2_REGS_Q1_SHARED)),\r\nC2_MQ_HOST_TARGET);\r\nqsize = be32_to_cpu((__force __be32) readl(mmio_regs + C2_REGS_Q2_QSIZE));\r\nmsgsize = be32_to_cpu((__force __be32) readl(mmio_regs + C2_REGS_Q2_MSGSIZE));\r\nq2_pages = dma_alloc_coherent(&c2dev->pcidev->dev, qsize * msgsize,\r\n&c2dev->aeq.host_dma, GFP_KERNEL);\r\nif (!q2_pages) {\r\nerr = -ENOMEM;\r\ngoto bail2;\r\n}\r\ndma_unmap_addr_set(&c2dev->aeq, mapping, c2dev->aeq.host_dma);\r\npr_debug("%s aeq va %p dma %llx\n", __func__, q2_pages,\r\n(unsigned long long) c2dev->aeq.host_dma);\r\nc2_mq_rep_init(&c2dev->aeq,\r\n2,\r\nqsize,\r\nmsgsize,\r\nq2_pages,\r\nmmio_regs +\r\nbe32_to_cpu((__force __be32) readl(mmio_regs + C2_REGS_Q2_SHARED)),\r\nC2_MQ_HOST_TARGET);\r\nerr = vq_init(c2dev);\r\nif (err)\r\ngoto bail3;\r\nwritel(0, c2dev->regs + C2_IDIS);\r\nerr = c2_adapter_init(c2dev);\r\nif (err)\r\ngoto bail4;\r\nc2dev->init++;\r\nerr = c2_rnic_open(c2dev);\r\nif (err)\r\ngoto bail4;\r\nerr = c2_rnic_query(c2dev, &c2dev->props);\r\nif (err)\r\ngoto bail5;\r\nerr = c2_init_pd_table(c2dev);\r\nif (err)\r\ngoto bail5;\r\nc2_init_qp_table(c2dev);\r\nreturn 0;\r\nbail5:\r\nc2_rnic_close(c2dev);\r\nbail4:\r\nvq_term(c2dev);\r\nbail3:\r\ndma_free_coherent(&c2dev->pcidev->dev,\r\nc2dev->aeq.q_size * c2dev->aeq.msg_size,\r\nq2_pages, dma_unmap_addr(&c2dev->aeq, mapping));\r\nbail2:\r\ndma_free_coherent(&c2dev->pcidev->dev,\r\nc2dev->rep_vq.q_size * c2dev->rep_vq.msg_size,\r\nq1_pages, dma_unmap_addr(&c2dev->rep_vq, mapping));\r\nbail1:\r\nc2_free_mqsp_pool(c2dev, c2dev->kern_mqsp_pool);\r\nbail0:\r\nvfree(c2dev->qptr_array);\r\nreturn err;\r\n}\r\nvoid c2_rnic_term(struct c2_dev *c2dev)\r\n{\r\nc2_rnic_close(c2dev);\r\nc2_adapter_term(c2dev);\r\nwritel(1, c2dev->regs + C2_IDIS);\r\nc2_cleanup_qp_table(c2dev);\r\nc2_cleanup_pd_table(c2dev);\r\nvq_term(c2dev);\r\ndma_free_coherent(&c2dev->pcidev->dev,\r\nc2dev->aeq.q_size * c2dev->aeq.msg_size,\r\nc2dev->aeq.msg_pool.host,\r\ndma_unmap_addr(&c2dev->aeq, mapping));\r\ndma_free_coherent(&c2dev->pcidev->dev,\r\nc2dev->rep_vq.q_size * c2dev->rep_vq.msg_size,\r\nc2dev->rep_vq.msg_pool.host,\r\ndma_unmap_addr(&c2dev->rep_vq, mapping));\r\nc2_free_mqsp_pool(c2dev, c2dev->kern_mqsp_pool);\r\nvfree(c2dev->qptr_array);\r\nreturn;\r\n}
