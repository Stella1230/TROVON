void iwl_mvm_set_rekey_data(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct cfg80211_gtk_rekey_data *data)\r\n{\r\nstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nif (iwlwifi_mod_params.sw_crypto)\r\nreturn;\r\nmutex_lock(&mvm->mutex);\r\nmemcpy(mvmvif->rekey_data.kek, data->kek, NL80211_KEK_LEN);\r\nmemcpy(mvmvif->rekey_data.kck, data->kck, NL80211_KCK_LEN);\r\nmvmvif->rekey_data.replay_ctr =\r\ncpu_to_le64(be64_to_cpup((__be64 *)&data->replay_ctr));\r\nmvmvif->rekey_data.valid = true;\r\nmutex_unlock(&mvm->mutex);\r\n}\r\nvoid iwl_mvm_ipv6_addr_change(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct inet6_dev *idev)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct inet6_ifaddr *ifa;\r\nint idx = 0;\r\nread_lock_bh(&idev->lock);\r\nlist_for_each_entry(ifa, &idev->addr_list, if_list) {\r\nmvmvif->target_ipv6_addrs[idx] = ifa->addr;\r\nidx++;\r\nif (idx >= IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_MAX)\r\nbreak;\r\n}\r\nread_unlock_bh(&idev->lock);\r\nmvmvif->num_target_ipv6_addrs = idx;\r\n}\r\nvoid iwl_mvm_set_default_unicast_key(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, int idx)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nmvmvif->tx_key_idx = idx;\r\n}\r\nstatic void iwl_mvm_convert_p1k(u16 *p1k, __le16 *out)\r\n{\r\nint i;\r\nfor (i = 0; i < IWL_P1K_SIZE; i++)\r\nout[i] = cpu_to_le16(p1k[i]);\r\n}\r\nstatic void iwl_mvm_wowlan_program_keys(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta,\r\nstruct ieee80211_key_conf *key,\r\nvoid *_data)\r\n{\r\nstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct wowlan_key_data *data = _data;\r\nstruct aes_sc *aes_sc, *aes_tx_sc = NULL;\r\nstruct tkip_sc *tkip_sc, *tkip_tx_sc = NULL;\r\nstruct iwl_p1k_cache *rx_p1ks;\r\nu8 *rx_mic_key;\r\nstruct ieee80211_key_seq seq;\r\nu32 cur_rx_iv32 = 0;\r\nu16 p1k[IWL_P1K_SIZE];\r\nint ret, i;\r\nmutex_lock(&mvm->mutex);\r\nswitch (key->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104: {\r\nstruct {\r\nstruct iwl_mvm_wep_key_cmd wep_key_cmd;\r\nstruct iwl_mvm_wep_key wep_key;\r\n} __packed wkc = {\r\n.wep_key_cmd.mac_id_n_color =\r\ncpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,\r\nmvmvif->color)),\r\n.wep_key_cmd.num_keys = 1,\r\n.wep_key_cmd.decryption_type = STA_KEY_FLG_WEP,\r\n.wep_key.key_index = key->keyidx,\r\n.wep_key.key_size = key->keylen,\r\n};\r\nif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\r\nbreak;\r\nmemcpy(&wkc.wep_key.key[3], key->key, key->keylen);\r\nif (key->keyidx == mvmvif->tx_key_idx) {\r\nwkc.wep_key.key_offset = 0;\r\n} else {\r\ndata->wep_key_idx++;\r\nwkc.wep_key.key_offset = data->wep_key_idx;\r\n}\r\nret = iwl_mvm_send_cmd_pdu(mvm, WEP_KEY, 0, sizeof(wkc), &wkc);\r\ndata->error = ret != 0;\r\nmvm->ptk_ivlen = key->iv_len;\r\nmvm->ptk_icvlen = key->icv_len;\r\nmvm->gtk_ivlen = key->iv_len;\r\nmvm->gtk_icvlen = key->icv_len;\r\ngoto out_unlock;\r\n}\r\ndefault:\r\ndata->error = true;\r\ngoto out_unlock;\r\ncase WLAN_CIPHER_SUITE_AES_CMAC:\r\ngoto out_unlock;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nif (sta) {\r\ntkip_sc = data->rsc_tsc->all_tsc_rsc.tkip.unicast_rsc;\r\ntkip_tx_sc = &data->rsc_tsc->all_tsc_rsc.tkip.tsc;\r\nrx_p1ks = data->tkip->rx_uni;\r\nieee80211_get_key_tx_seq(key, &seq);\r\ntkip_tx_sc->iv16 = cpu_to_le16(seq.tkip.iv16);\r\ntkip_tx_sc->iv32 = cpu_to_le32(seq.tkip.iv32);\r\nieee80211_get_tkip_p1k_iv(key, seq.tkip.iv32, p1k);\r\niwl_mvm_convert_p1k(p1k, data->tkip->tx.p1k);\r\nmemcpy(data->tkip->mic_keys.tx,\r\n&key->key[NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY],\r\nIWL_MIC_KEY_SIZE);\r\nrx_mic_key = data->tkip->mic_keys.rx_unicast;\r\n} else {\r\ntkip_sc =\r\ndata->rsc_tsc->all_tsc_rsc.tkip.multicast_rsc;\r\nrx_p1ks = data->tkip->rx_multi;\r\nrx_mic_key = data->tkip->mic_keys.rx_mcast;\r\n}\r\nfor (i = 0; i < IWL_NUM_RSC; i++) {\r\nieee80211_get_key_rx_seq(key, i, &seq);\r\ntkip_sc[i].iv16 = cpu_to_le16(seq.tkip.iv16);\r\ntkip_sc[i].iv32 = cpu_to_le32(seq.tkip.iv32);\r\nif (seq.tkip.iv32 > cur_rx_iv32)\r\ncur_rx_iv32 = seq.tkip.iv32;\r\n}\r\nieee80211_get_tkip_rx_p1k(key, vif->bss_conf.bssid,\r\ncur_rx_iv32, p1k);\r\niwl_mvm_convert_p1k(p1k, rx_p1ks[0].p1k);\r\nieee80211_get_tkip_rx_p1k(key, vif->bss_conf.bssid,\r\ncur_rx_iv32 + 1, p1k);\r\niwl_mvm_convert_p1k(p1k, rx_p1ks[1].p1k);\r\nmemcpy(rx_mic_key,\r\n&key->key[NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY],\r\nIWL_MIC_KEY_SIZE);\r\ndata->use_tkip = true;\r\ndata->use_rsc_tsc = true;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nif (sta) {\r\nu8 *pn = seq.ccmp.pn;\r\naes_sc = data->rsc_tsc->all_tsc_rsc.aes.unicast_rsc;\r\naes_tx_sc = &data->rsc_tsc->all_tsc_rsc.aes.tsc;\r\nieee80211_get_key_tx_seq(key, &seq);\r\naes_tx_sc->pn = cpu_to_le64((u64)pn[5] |\r\n((u64)pn[4] << 8) |\r\n((u64)pn[3] << 16) |\r\n((u64)pn[2] << 24) |\r\n((u64)pn[1] << 32) |\r\n((u64)pn[0] << 40));\r\n} else {\r\naes_sc = data->rsc_tsc->all_tsc_rsc.aes.multicast_rsc;\r\n}\r\nfor (i = 0; i < IWL_NUM_RSC; i++) {\r\nu8 *pn = seq.ccmp.pn;\r\nieee80211_get_key_rx_seq(key, i, &seq);\r\naes_sc->pn = cpu_to_le64((u64)pn[5] |\r\n((u64)pn[4] << 8) |\r\n((u64)pn[3] << 16) |\r\n((u64)pn[2] << 24) |\r\n((u64)pn[1] << 32) |\r\n((u64)pn[0] << 40));\r\n}\r\ndata->use_rsc_tsc = true;\r\nbreak;\r\n}\r\nif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {\r\nkey->hw_key_idx = 0;\r\nmvm->ptk_ivlen = key->iv_len;\r\nmvm->ptk_icvlen = key->icv_len;\r\n} else {\r\nkey->hw_key_idx = 1;\r\nmvm->gtk_ivlen = key->iv_len;\r\nmvm->gtk_icvlen = key->icv_len;\r\n}\r\nret = iwl_mvm_set_sta_key(mvm, vif, sta, key, true);\r\ndata->error = ret != 0;\r\nout_unlock:\r\nmutex_unlock(&mvm->mutex);\r\n}\r\nstatic int iwl_mvm_send_patterns(struct iwl_mvm *mvm,\r\nstruct cfg80211_wowlan *wowlan)\r\n{\r\nstruct iwl_wowlan_patterns_cmd *pattern_cmd;\r\nstruct iwl_host_cmd cmd = {\r\n.id = WOWLAN_PATTERNS,\r\n.dataflags[0] = IWL_HCMD_DFL_NOCOPY,\r\n};\r\nint i, err;\r\nif (!wowlan->n_patterns)\r\nreturn 0;\r\ncmd.len[0] = sizeof(*pattern_cmd) +\r\nwowlan->n_patterns * sizeof(struct iwl_wowlan_pattern);\r\npattern_cmd = kmalloc(cmd.len[0], GFP_KERNEL);\r\nif (!pattern_cmd)\r\nreturn -ENOMEM;\r\npattern_cmd->n_patterns = cpu_to_le32(wowlan->n_patterns);\r\nfor (i = 0; i < wowlan->n_patterns; i++) {\r\nint mask_len = DIV_ROUND_UP(wowlan->patterns[i].pattern_len, 8);\r\nmemcpy(&pattern_cmd->patterns[i].mask,\r\nwowlan->patterns[i].mask, mask_len);\r\nmemcpy(&pattern_cmd->patterns[i].pattern,\r\nwowlan->patterns[i].pattern,\r\nwowlan->patterns[i].pattern_len);\r\npattern_cmd->patterns[i].mask_size = mask_len;\r\npattern_cmd->patterns[i].pattern_size =\r\nwowlan->patterns[i].pattern_len;\r\n}\r\ncmd.data[0] = pattern_cmd;\r\nerr = iwl_mvm_send_cmd(mvm, &cmd);\r\nkfree(pattern_cmd);\r\nreturn err;\r\n}\r\nstatic __le16 pseudo_hdr_check(int len, __be32 saddr, __be32 daddr)\r\n{\r\n__sum16 check = tcp_v4_check(len, saddr, daddr, 0);\r\nreturn cpu_to_le16(be16_to_cpu((__force __be16)check));\r\n}\r\nstatic void iwl_mvm_build_tcp_packet(struct ieee80211_vif *vif,\r\nstruct cfg80211_wowlan_tcp *tcp,\r\nvoid *_pkt, u8 *mask,\r\n__le16 *pseudo_hdr_csum,\r\nenum iwl_mvm_tcp_packet_type ptype)\r\n{\r\nstruct {\r\nstruct ethhdr eth;\r\nstruct iphdr ip;\r\nstruct tcphdr tcp;\r\nu8 data[];\r\n} __packed *pkt = _pkt;\r\nu16 ip_tot_len = sizeof(struct iphdr) + sizeof(struct tcphdr);\r\nint i;\r\npkt->eth.h_proto = cpu_to_be16(ETH_P_IP),\r\npkt->ip.version = 4;\r\npkt->ip.ihl = 5;\r\npkt->ip.protocol = IPPROTO_TCP;\r\nswitch (ptype) {\r\ncase MVM_TCP_TX_SYN:\r\ncase MVM_TCP_TX_DATA:\r\ncase MVM_TCP_TX_FIN:\r\nmemcpy(pkt->eth.h_dest, tcp->dst_mac, ETH_ALEN);\r\nmemcpy(pkt->eth.h_source, vif->addr, ETH_ALEN);\r\npkt->ip.ttl = 128;\r\npkt->ip.saddr = tcp->src;\r\npkt->ip.daddr = tcp->dst;\r\npkt->tcp.source = cpu_to_be16(tcp->src_port);\r\npkt->tcp.dest = cpu_to_be16(tcp->dst_port);\r\npkt->tcp.doff = sizeof(struct tcphdr) / 4;\r\npkt->tcp.window = cpu_to_be16(65000);\r\nbreak;\r\ncase MVM_TCP_RX_SYNACK:\r\ncase MVM_TCP_RX_ACK:\r\ncase MVM_TCP_RX_WAKE:\r\nmemcpy(pkt->eth.h_dest, vif->addr, ETH_ALEN);\r\nmemcpy(pkt->eth.h_source, tcp->dst_mac, ETH_ALEN);\r\npkt->ip.saddr = tcp->dst;\r\npkt->ip.daddr = tcp->src;\r\npkt->tcp.source = cpu_to_be16(tcp->dst_port);\r\npkt->tcp.dest = cpu_to_be16(tcp->src_port);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nswitch (ptype) {\r\ncase MVM_TCP_TX_SYN:\r\nmemset(pkt->data, 0x01, 8);\r\nip_tot_len += 8;\r\npkt->tcp.doff = (sizeof(struct tcphdr) + 8) / 4;\r\npkt->tcp.syn = 1;\r\nbreak;\r\ncase MVM_TCP_TX_DATA:\r\nip_tot_len += tcp->payload_len;\r\nmemcpy(pkt->data, tcp->payload, tcp->payload_len);\r\npkt->tcp.psh = 1;\r\npkt->tcp.ack = 1;\r\nbreak;\r\ncase MVM_TCP_TX_FIN:\r\npkt->tcp.fin = 1;\r\npkt->tcp.ack = 1;\r\nbreak;\r\ncase MVM_TCP_RX_SYNACK:\r\npkt->tcp.syn = 1;\r\npkt->tcp.ack = 1;\r\nbreak;\r\ncase MVM_TCP_RX_ACK:\r\npkt->tcp.ack = 1;\r\nbreak;\r\ncase MVM_TCP_RX_WAKE:\r\nip_tot_len += tcp->wake_len;\r\npkt->tcp.psh = 1;\r\npkt->tcp.ack = 1;\r\nmemcpy(pkt->data, tcp->wake_data, tcp->wake_len);\r\nbreak;\r\n}\r\nswitch (ptype) {\r\ncase MVM_TCP_TX_SYN:\r\ncase MVM_TCP_TX_DATA:\r\ncase MVM_TCP_TX_FIN:\r\npkt->ip.tot_len = cpu_to_be16(ip_tot_len);\r\npkt->ip.check = ip_fast_csum(&pkt->ip, pkt->ip.ihl);\r\nbreak;\r\ncase MVM_TCP_RX_WAKE:\r\nfor (i = 0; i < DIV_ROUND_UP(tcp->wake_len, 8); i++) {\r\nu8 tmp = tcp->wake_mask[i];\r\nmask[i + 6] |= tmp << 6;\r\nif (i + 1 < DIV_ROUND_UP(tcp->wake_len, 8))\r\nmask[i + 7] = tmp >> 2;\r\n}\r\ncase MVM_TCP_RX_SYNACK:\r\ncase MVM_TCP_RX_ACK:\r\nmask[0] = 0xff;\r\nmask[1] = 0x7f;\r\nmask[2] = 0x80;\r\nmask[3] = 0xfc;\r\nmask[4] = 0x3f;\r\nmask[5] = 0x80;\r\nbreak;\r\n};\r\n*pseudo_hdr_csum = pseudo_hdr_check(ip_tot_len - sizeof(struct iphdr),\r\npkt->ip.saddr, pkt->ip.daddr);\r\n}\r\nstatic int iwl_mvm_send_remote_wake_cfg(struct iwl_mvm *mvm,\r\nstruct ieee80211_vif *vif,\r\nstruct cfg80211_wowlan_tcp *tcp)\r\n{\r\nstruct iwl_wowlan_remote_wake_config *cfg;\r\nstruct iwl_host_cmd cmd = {\r\n.id = REMOTE_WAKE_CONFIG_CMD,\r\n.len = { sizeof(*cfg), },\r\n.dataflags = { IWL_HCMD_DFL_NOCOPY, },\r\n};\r\nint ret;\r\nif (!tcp)\r\nreturn 0;\r\ncfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\r\nif (!cfg)\r\nreturn -ENOMEM;\r\ncmd.data[0] = cfg;\r\ncfg->max_syn_retries = 10;\r\ncfg->max_data_retries = 10;\r\ncfg->tcp_syn_ack_timeout = 1;\r\ncfg->tcp_ack_timeout = 1;\r\niwl_mvm_build_tcp_packet(\r\nvif, tcp, cfg->syn_tx.data, NULL,\r\n&cfg->syn_tx.info.tcp_pseudo_header_checksum,\r\nMVM_TCP_TX_SYN);\r\ncfg->syn_tx.info.tcp_payload_length = 0;\r\niwl_mvm_build_tcp_packet(\r\nvif, tcp, cfg->synack_rx.data, cfg->synack_rx.rx_mask,\r\n&cfg->synack_rx.info.tcp_pseudo_header_checksum,\r\nMVM_TCP_RX_SYNACK);\r\ncfg->synack_rx.info.tcp_payload_length = 0;\r\niwl_mvm_build_tcp_packet(\r\nvif, tcp, cfg->keepalive_tx.data, NULL,\r\n&cfg->keepalive_tx.info.tcp_pseudo_header_checksum,\r\nMVM_TCP_TX_DATA);\r\ncfg->keepalive_tx.info.tcp_payload_length =\r\ncpu_to_le16(tcp->payload_len);\r\ncfg->sequence_number_offset = tcp->payload_seq.offset;\r\ncfg->sequence_number_length = tcp->payload_seq.len;\r\ncfg->initial_sequence_number = cpu_to_le32(tcp->payload_seq.start);\r\ncfg->keepalive_interval = cpu_to_le16(tcp->data_interval);\r\nif (tcp->payload_tok.len) {\r\ncfg->token_offset = tcp->payload_tok.offset;\r\ncfg->token_length = tcp->payload_tok.len;\r\ncfg->num_tokens =\r\ncpu_to_le16(tcp->tokens_size % tcp->payload_tok.len);\r\nmemcpy(cfg->tokens, tcp->payload_tok.token_stream,\r\ntcp->tokens_size);\r\n} else {\r\ncfg->num_tokens = cpu_to_le16(65535);\r\n}\r\niwl_mvm_build_tcp_packet(\r\nvif, tcp, cfg->keepalive_ack_rx.data,\r\ncfg->keepalive_ack_rx.rx_mask,\r\n&cfg->keepalive_ack_rx.info.tcp_pseudo_header_checksum,\r\nMVM_TCP_RX_ACK);\r\ncfg->keepalive_ack_rx.info.tcp_payload_length = 0;\r\niwl_mvm_build_tcp_packet(\r\nvif, tcp, cfg->wake_rx.data, cfg->wake_rx.rx_mask,\r\n&cfg->wake_rx.info.tcp_pseudo_header_checksum,\r\nMVM_TCP_RX_WAKE);\r\ncfg->wake_rx.info.tcp_payload_length =\r\ncpu_to_le16(tcp->wake_len);\r\niwl_mvm_build_tcp_packet(\r\nvif, tcp, cfg->fin_tx.data, NULL,\r\n&cfg->fin_tx.info.tcp_pseudo_header_checksum,\r\nMVM_TCP_TX_FIN);\r\ncfg->fin_tx.info.tcp_payload_length = 0;\r\nret = iwl_mvm_send_cmd(mvm, &cmd);\r\nkfree(cfg);\r\nreturn ret;\r\n}\r\nstatic void iwl_mvm_d3_iface_iterator(void *_data, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct iwl_d3_iter_data *data = _data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nif (vif->type != NL80211_IFTYPE_STATION || vif->p2p)\r\nreturn;\r\nif (mvmvif->ap_sta_id == IWL_MVM_STATION_COUNT)\r\nreturn;\r\nif (data->vif) {\r\nIWL_ERR(data->mvm, "More than one managed interface active!\n");\r\ndata->error = true;\r\nreturn;\r\n}\r\ndata->vif = vif;\r\n}\r\nstatic int iwl_mvm_d3_reprogram(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\r\nstruct ieee80211_sta *ap_sta)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct ieee80211_chanctx_conf *ctx;\r\nu8 chains_static, chains_dynamic;\r\nstruct cfg80211_chan_def chandef;\r\nint ret, i;\r\nstruct iwl_binding_cmd binding_cmd = {};\r\nstruct iwl_time_quota_cmd quota_cmd = {};\r\nu32 status;\r\nif (WARN_ON(!mvmvif->phy_ctxt))\r\nreturn -EINVAL;\r\nrcu_read_lock();\r\nctx = rcu_dereference(vif->chanctx_conf);\r\nif (WARN_ON(!ctx)) {\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\nchandef = ctx->def;\r\nchains_static = ctx->rx_chains_static;\r\nchains_dynamic = ctx->rx_chains_dynamic;\r\nrcu_read_unlock();\r\nret = iwl_mvm_phy_ctxt_add(mvm, mvmvif->phy_ctxt, &chandef,\r\nchains_static, chains_dynamic);\r\nif (ret)\r\nreturn ret;\r\nmvmvif->uploaded = false;\r\nif (WARN_ON(!vif->bss_conf.assoc))\r\nreturn -EINVAL;\r\nret = iwl_mvm_mac_ctxt_add(mvm, vif);\r\nif (ret)\r\nreturn ret;\r\nbinding_cmd.id_and_color =\r\ncpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->phy_ctxt->id,\r\nmvmvif->phy_ctxt->color));\r\nbinding_cmd.action = cpu_to_le32(FW_CTXT_ACTION_ADD);\r\nbinding_cmd.phy =\r\ncpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->phy_ctxt->id,\r\nmvmvif->phy_ctxt->color));\r\nbinding_cmd.macs[0] = cpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,\r\nmvmvif->color));\r\nfor (i = 1; i < MAX_MACS_IN_BINDING; i++)\r\nbinding_cmd.macs[i] = cpu_to_le32(FW_CTXT_INVALID);\r\nstatus = 0;\r\nret = iwl_mvm_send_cmd_pdu_status(mvm, BINDING_CONTEXT_CMD,\r\nsizeof(binding_cmd), &binding_cmd,\r\n&status);\r\nif (ret) {\r\nIWL_ERR(mvm, "Failed to add binding: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (status) {\r\nIWL_ERR(mvm, "Binding command failed: %u\n", status);\r\nreturn -EIO;\r\n}\r\nret = iwl_mvm_sta_send_to_fw(mvm, ap_sta, false);\r\nif (ret)\r\nreturn ret;\r\nrcu_assign_pointer(mvm->fw_id_to_mac_id[mvmvif->ap_sta_id], ap_sta);\r\nret = iwl_mvm_mac_ctxt_changed(mvm, vif, false);\r\nif (ret)\r\nreturn ret;\r\nquota_cmd.quotas[0].id_and_color =\r\ncpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->phy_ctxt->id,\r\nmvmvif->phy_ctxt->color));\r\nquota_cmd.quotas[0].quota = cpu_to_le32(IWL_MVM_MAX_QUOTA);\r\nquota_cmd.quotas[0].max_duration = cpu_to_le32(IWL_MVM_MAX_QUOTA);\r\nfor (i = 1; i < MAX_BINDINGS; i++)\r\nquota_cmd.quotas[i].id_and_color = cpu_to_le32(FW_CTXT_INVALID);\r\nret = iwl_mvm_send_cmd_pdu(mvm, TIME_QUOTA_CMD, 0,\r\nsizeof(quota_cmd), &quota_cmd);\r\nif (ret)\r\nIWL_ERR(mvm, "Failed to send quota: %d\n", ret);\r\nreturn 0;\r\n}\r\nstatic int iwl_mvm_get_last_nonqos_seq(struct iwl_mvm *mvm,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_nonqos_seq_query_cmd query_cmd = {\r\n.get_set_flag = cpu_to_le32(IWL_NONQOS_SEQ_GET),\r\n.mac_id_n_color =\r\ncpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,\r\nmvmvif->color)),\r\n};\r\nstruct iwl_host_cmd cmd = {\r\n.id = NON_QOS_TX_COUNTER_CMD,\r\n.flags = CMD_WANT_SKB,\r\n};\r\nint err;\r\nu32 size;\r\ncmd.data[0] = &query_cmd;\r\ncmd.len[0] = sizeof(query_cmd);\r\nerr = iwl_mvm_send_cmd(mvm, &cmd);\r\nif (err)\r\nreturn err;\r\nsize = iwl_rx_packet_payload_len(cmd.resp_pkt);\r\nif (size < sizeof(__le16)) {\r\nerr = -EINVAL;\r\n} else {\r\nerr = le16_to_cpup((__le16 *)cmd.resp_pkt->data);\r\nerr = (u16) (err - 0x10);\r\n}\r\niwl_free_resp(&cmd);\r\nreturn err;\r\n}\r\nvoid iwl_mvm_set_last_nonqos_seq(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_nonqos_seq_query_cmd query_cmd = {\r\n.get_set_flag = cpu_to_le32(IWL_NONQOS_SEQ_SET),\r\n.mac_id_n_color =\r\ncpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,\r\nmvmvif->color)),\r\n.value = cpu_to_le16(mvmvif->seqno),\r\n};\r\nif (!mvmvif->seqno_valid)\r\nreturn;\r\nmvmvif->seqno_valid = false;\r\nif (iwl_mvm_send_cmd_pdu(mvm, NON_QOS_TX_COUNTER_CMD, 0,\r\nsizeof(query_cmd), &query_cmd))\r\nIWL_ERR(mvm, "failed to set non-QoS seqno\n");\r\n}\r\nstatic int\r\niwl_mvm_send_wowlan_config_cmd(struct iwl_mvm *mvm,\r\nconst struct iwl_wowlan_config_cmd_v3 *cmd)\r\n{\r\nu16 cmd_len = sizeof(cmd->common);\r\nif (mvm->fw->ucode_capa.api[0] & IWL_UCODE_TLV_API_WOWLAN_CONFIG_TID)\r\ncmd_len = sizeof(*cmd);\r\nreturn iwl_mvm_send_cmd_pdu(mvm, WOWLAN_CONFIGURATION, 0,\r\ncmd_len, cmd);\r\n}\r\nstatic int __iwl_mvm_suspend(struct ieee80211_hw *hw,\r\nstruct cfg80211_wowlan *wowlan,\r\nbool test)\r\n{\r\nstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\r\nstruct iwl_d3_iter_data suspend_iter_data = {\r\n.mvm = mvm,\r\n};\r\nstruct ieee80211_vif *vif;\r\nstruct iwl_mvm_vif *mvmvif;\r\nstruct ieee80211_sta *ap_sta;\r\nstruct iwl_mvm_sta *mvm_ap_sta;\r\nstruct iwl_wowlan_config_cmd_v3 wowlan_config_cmd = {};\r\nstruct iwl_wowlan_kek_kck_material_cmd kek_kck_cmd = {};\r\nstruct iwl_wowlan_tkip_params_cmd tkip_cmd = {};\r\nstruct iwl_d3_manager_config d3_cfg_cmd_data = {\r\n.min_sleep_time = cpu_to_le32(10 * 1000 * 1000),\r\n};\r\nstruct iwl_host_cmd d3_cfg_cmd = {\r\n.id = D3_CONFIG_CMD,\r\n.flags = CMD_WANT_SKB,\r\n.data[0] = &d3_cfg_cmd_data,\r\n.len[0] = sizeof(d3_cfg_cmd_data),\r\n};\r\nstruct wowlan_key_data key_data = {\r\n.use_rsc_tsc = false,\r\n.tkip = &tkip_cmd,\r\n.use_tkip = false,\r\n};\r\nint ret;\r\nint len __maybe_unused;\r\nif (!wowlan) {\r\nWARN_ON(!test);\r\nreturn -EINVAL;\r\n}\r\nkey_data.rsc_tsc = kzalloc(sizeof(*key_data.rsc_tsc), GFP_KERNEL);\r\nif (!key_data.rsc_tsc)\r\nreturn -ENOMEM;\r\nmutex_lock(&mvm->mutex);\r\nieee80211_iterate_active_interfaces_atomic(\r\nmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\r\niwl_mvm_d3_iface_iterator, &suspend_iter_data);\r\nif (suspend_iter_data.error || !suspend_iter_data.vif) {\r\nret = 1;\r\ngoto out_noreset;\r\n}\r\nvif = suspend_iter_data.vif;\r\nmvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nap_sta = rcu_dereference_protected(\r\nmvm->fw_id_to_mac_id[mvmvif->ap_sta_id],\r\nlockdep_is_held(&mvm->mutex));\r\nif (IS_ERR_OR_NULL(ap_sta)) {\r\nret = -EINVAL;\r\ngoto out_noreset;\r\n}\r\nmvm_ap_sta = (struct iwl_mvm_sta *)ap_sta->drv_priv;\r\nwowlan_config_cmd.common.is_11n_connection =\r\nap_sta->ht_cap.ht_supported;\r\nret = iwl_mvm_get_last_nonqos_seq(mvm, vif);\r\nif (ret < 0)\r\ngoto out_noreset;\r\nwowlan_config_cmd.common.non_qos_seq = cpu_to_le16(ret);\r\niwl_mvm_set_wowlan_qos_seq(mvm_ap_sta, &wowlan_config_cmd.common);\r\nif (wowlan->disconnect)\r\nwowlan_config_cmd.common.wakeup_filter |=\r\ncpu_to_le32(IWL_WOWLAN_WAKEUP_BEACON_MISS |\r\nIWL_WOWLAN_WAKEUP_LINK_CHANGE);\r\nif (wowlan->magic_pkt)\r\nwowlan_config_cmd.common.wakeup_filter |=\r\ncpu_to_le32(IWL_WOWLAN_WAKEUP_MAGIC_PACKET);\r\nif (wowlan->gtk_rekey_failure)\r\nwowlan_config_cmd.common.wakeup_filter |=\r\ncpu_to_le32(IWL_WOWLAN_WAKEUP_GTK_REKEY_FAIL);\r\nif (wowlan->eap_identity_req)\r\nwowlan_config_cmd.common.wakeup_filter |=\r\ncpu_to_le32(IWL_WOWLAN_WAKEUP_EAP_IDENT_REQ);\r\nif (wowlan->four_way_handshake)\r\nwowlan_config_cmd.common.wakeup_filter |=\r\ncpu_to_le32(IWL_WOWLAN_WAKEUP_4WAY_HANDSHAKE);\r\nif (wowlan->n_patterns)\r\nwowlan_config_cmd.common.wakeup_filter |=\r\ncpu_to_le32(IWL_WOWLAN_WAKEUP_PATTERN_MATCH);\r\nif (wowlan->rfkill_release)\r\nwowlan_config_cmd.common.wakeup_filter |=\r\ncpu_to_le32(IWL_WOWLAN_WAKEUP_RF_KILL_DEASSERT);\r\nif (wowlan->tcp) {\r\nwowlan_config_cmd.common.wakeup_filter |=\r\ncpu_to_le32(IWL_WOWLAN_WAKEUP_REMOTE_LINK_LOSS |\r\nIWL_WOWLAN_WAKEUP_REMOTE_SIGNATURE_TABLE |\r\nIWL_WOWLAN_WAKEUP_REMOTE_WAKEUP_PACKET |\r\nIWL_WOWLAN_WAKEUP_LINK_CHANGE);\r\n}\r\niwl_mvm_cancel_scan(mvm);\r\niwl_trans_stop_device(mvm->trans);\r\nset_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status);\r\nmemset(mvm->fw_key_table, 0, sizeof(mvm->fw_key_table));\r\nmvm->ptk_ivlen = 0;\r\nmvm->ptk_icvlen = 0;\r\nmvm->ptk_ivlen = 0;\r\nmvm->ptk_icvlen = 0;\r\nret = iwl_mvm_load_d3_fw(mvm);\r\nif (ret)\r\ngoto out;\r\nret = iwl_mvm_d3_reprogram(mvm, vif, ap_sta);\r\nif (ret)\r\ngoto out;\r\nif (!iwlwifi_mod_params.sw_crypto) {\r\nmutex_unlock(&mvm->mutex);\r\nieee80211_iter_keys(mvm->hw, vif,\r\niwl_mvm_wowlan_program_keys,\r\n&key_data);\r\nmutex_lock(&mvm->mutex);\r\nif (key_data.error) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (key_data.use_rsc_tsc) {\r\nstruct iwl_host_cmd rsc_tsc_cmd = {\r\n.id = WOWLAN_TSC_RSC_PARAM,\r\n.data[0] = key_data.rsc_tsc,\r\n.dataflags[0] = IWL_HCMD_DFL_NOCOPY,\r\n.len[0] = sizeof(*key_data.rsc_tsc),\r\n};\r\nret = iwl_mvm_send_cmd(mvm, &rsc_tsc_cmd);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (key_data.use_tkip) {\r\nret = iwl_mvm_send_cmd_pdu(mvm,\r\nWOWLAN_TKIP_PARAM,\r\n0, sizeof(tkip_cmd),\r\n&tkip_cmd);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (mvmvif->rekey_data.valid) {\r\nmemset(&kek_kck_cmd, 0, sizeof(kek_kck_cmd));\r\nmemcpy(kek_kck_cmd.kck, mvmvif->rekey_data.kck,\r\nNL80211_KCK_LEN);\r\nkek_kck_cmd.kck_len = cpu_to_le16(NL80211_KCK_LEN);\r\nmemcpy(kek_kck_cmd.kek, mvmvif->rekey_data.kek,\r\nNL80211_KEK_LEN);\r\nkek_kck_cmd.kek_len = cpu_to_le16(NL80211_KEK_LEN);\r\nkek_kck_cmd.replay_ctr = mvmvif->rekey_data.replay_ctr;\r\nret = iwl_mvm_send_cmd_pdu(mvm,\r\nWOWLAN_KEK_KCK_MATERIAL, 0,\r\nsizeof(kek_kck_cmd),\r\n&kek_kck_cmd);\r\nif (ret)\r\ngoto out;\r\n}\r\n}\r\nret = iwl_mvm_send_wowlan_config_cmd(mvm, &wowlan_config_cmd);\r\nif (ret)\r\ngoto out;\r\nret = iwl_mvm_send_patterns(mvm, wowlan);\r\nif (ret)\r\ngoto out;\r\nret = iwl_mvm_send_proto_offload(mvm, vif, false, 0);\r\nif (ret)\r\ngoto out;\r\nret = iwl_mvm_send_remote_wake_cfg(mvm, vif, wowlan->tcp);\r\nif (ret)\r\ngoto out;\r\nret = iwl_mvm_power_update_device(mvm);\r\nif (ret)\r\ngoto out;\r\nret = iwl_mvm_power_update_mac(mvm);\r\nif (ret)\r\ngoto out;\r\n#ifdef CONFIG_IWLWIFI_DEBUGFS\r\nif (mvm->d3_wake_sysassert)\r\nd3_cfg_cmd_data.wakeup_flags |=\r\ncpu_to_le32(IWL_WAKEUP_D3_CONFIG_FW_ERROR);\r\n#endif\r\nret = iwl_mvm_send_cmd(mvm, &d3_cfg_cmd);\r\nif (ret)\r\ngoto out;\r\n#ifdef CONFIG_IWLWIFI_DEBUGFS\r\nlen = iwl_rx_packet_payload_len(d3_cfg_cmd.resp_pkt);\r\nif (len >= sizeof(u32)) {\r\nmvm->d3_test_pme_ptr =\r\nle32_to_cpup((__le32 *)d3_cfg_cmd.resp_pkt->data);\r\n}\r\n#endif\r\niwl_free_resp(&d3_cfg_cmd);\r\nclear_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status);\r\niwl_trans_d3_suspend(mvm->trans, test);\r\nout:\r\nif (ret < 0)\r\nieee80211_restart_hw(mvm->hw);\r\nout_noreset:\r\nkfree(key_data.rsc_tsc);\r\nmutex_unlock(&mvm->mutex);\r\nreturn ret;\r\n}\r\nint iwl_mvm_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)\r\n{\r\nstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\r\nif (iwl_mvm_is_d0i3_supported(mvm)) {\r\nmutex_lock(&mvm->d0i3_suspend_mutex);\r\n__set_bit(D0I3_DEFER_WAKEUP, &mvm->d0i3_suspend_flags);\r\nmutex_unlock(&mvm->d0i3_suspend_mutex);\r\nreturn 0;\r\n}\r\nreturn __iwl_mvm_suspend(hw, wowlan, false);\r\n}\r\nstatic void iwl_mvm_report_wakeup_reasons(struct iwl_mvm *mvm,\r\nstruct ieee80211_vif *vif,\r\nstruct iwl_wowlan_status_data *status)\r\n{\r\nstruct sk_buff *pkt = NULL;\r\nstruct cfg80211_wowlan_wakeup wakeup = {\r\n.pattern_idx = -1,\r\n};\r\nstruct cfg80211_wowlan_wakeup *wakeup_report = &wakeup;\r\nu32 reasons = status->wakeup_reasons;\r\nif (reasons == IWL_WOWLAN_WAKEUP_BY_NON_WIRELESS) {\r\nwakeup_report = NULL;\r\ngoto report;\r\n}\r\nif (reasons & IWL_WOWLAN_WAKEUP_BY_MAGIC_PACKET)\r\nwakeup.magic_pkt = true;\r\nif (reasons & IWL_WOWLAN_WAKEUP_BY_PATTERN)\r\nwakeup.pattern_idx =\r\nstatus->pattern_number;\r\nif (reasons & (IWL_WOWLAN_WAKEUP_BY_DISCONNECTION_ON_MISSED_BEACON |\r\nIWL_WOWLAN_WAKEUP_BY_DISCONNECTION_ON_DEAUTH))\r\nwakeup.disconnect = true;\r\nif (reasons & IWL_WOWLAN_WAKEUP_BY_GTK_REKEY_FAILURE)\r\nwakeup.gtk_rekey_failure = true;\r\nif (reasons & IWL_WOWLAN_WAKEUP_BY_RFKILL_DEASSERTED)\r\nwakeup.rfkill_release = true;\r\nif (reasons & IWL_WOWLAN_WAKEUP_BY_EAPOL_REQUEST)\r\nwakeup.eap_identity_req = true;\r\nif (reasons & IWL_WOWLAN_WAKEUP_BY_FOUR_WAY_HANDSHAKE)\r\nwakeup.four_way_handshake = true;\r\nif (reasons & IWL_WOWLAN_WAKEUP_BY_REM_WAKE_LINK_LOSS)\r\nwakeup.tcp_connlost = true;\r\nif (reasons & IWL_WOWLAN_WAKEUP_BY_REM_WAKE_SIGNATURE_TABLE)\r\nwakeup.tcp_nomoretokens = true;\r\nif (reasons & IWL_WOWLAN_WAKEUP_BY_REM_WAKE_WAKEUP_PACKET)\r\nwakeup.tcp_match = true;\r\nif (status->wake_packet_bufsize) {\r\nint pktsize = status->wake_packet_bufsize;\r\nint pktlen = status->wake_packet_length;\r\nconst u8 *pktdata = status->wake_packet;\r\nstruct ieee80211_hdr *hdr = (void *)pktdata;\r\nint truncated = pktlen - pktsize;\r\nif (WARN_ON_ONCE(truncated < 0))\r\ntruncated = 0;\r\nif (ieee80211_is_data(hdr->frame_control)) {\r\nint hdrlen = ieee80211_hdrlen(hdr->frame_control);\r\nint ivlen = 0, icvlen = 4;\r\npkt = alloc_skb(pktsize, GFP_KERNEL);\r\nif (!pkt)\r\ngoto report;\r\nmemcpy(skb_put(pkt, hdrlen), pktdata, hdrlen);\r\npktdata += hdrlen;\r\npktsize -= hdrlen;\r\nif (ieee80211_has_protected(hdr->frame_control)) {\r\nif (is_multicast_ether_addr(hdr->addr1)) {\r\nivlen = mvm->gtk_ivlen;\r\nicvlen += mvm->gtk_icvlen;\r\n} else {\r\nivlen = mvm->ptk_ivlen;\r\nicvlen += mvm->ptk_icvlen;\r\n}\r\n}\r\nif (truncated >= icvlen) {\r\nicvlen = 0;\r\ntruncated -= icvlen;\r\n} else {\r\nicvlen -= truncated;\r\ntruncated = 0;\r\n}\r\npktsize -= ivlen + icvlen;\r\npktdata += ivlen;\r\nmemcpy(skb_put(pkt, pktsize), pktdata, pktsize);\r\nif (ieee80211_data_to_8023(pkt, vif->addr, vif->type))\r\ngoto report;\r\nwakeup.packet = pkt->data;\r\nwakeup.packet_present_len = pkt->len;\r\nwakeup.packet_len = pkt->len - truncated;\r\nwakeup.packet_80211 = false;\r\n} else {\r\nint fcslen = 4;\r\nif (truncated >= 4) {\r\ntruncated -= 4;\r\nfcslen = 0;\r\n} else {\r\nfcslen -= truncated;\r\ntruncated = 0;\r\n}\r\npktsize -= fcslen;\r\nwakeup.packet = status->wake_packet;\r\nwakeup.packet_present_len = pktsize;\r\nwakeup.packet_len = pktlen - truncated;\r\nwakeup.packet_80211 = true;\r\n}\r\n}\r\nreport:\r\nieee80211_report_wowlan_wakeup(vif, wakeup_report, GFP_KERNEL);\r\nkfree_skb(pkt);\r\n}\r\nstatic void iwl_mvm_aes_sc_to_seq(struct aes_sc *sc,\r\nstruct ieee80211_key_seq *seq)\r\n{\r\nu64 pn;\r\npn = le64_to_cpu(sc->pn);\r\nseq->ccmp.pn[0] = pn >> 40;\r\nseq->ccmp.pn[1] = pn >> 32;\r\nseq->ccmp.pn[2] = pn >> 24;\r\nseq->ccmp.pn[3] = pn >> 16;\r\nseq->ccmp.pn[4] = pn >> 8;\r\nseq->ccmp.pn[5] = pn;\r\n}\r\nstatic void iwl_mvm_tkip_sc_to_seq(struct tkip_sc *sc,\r\nstruct ieee80211_key_seq *seq)\r\n{\r\nseq->tkip.iv32 = le32_to_cpu(sc->iv32);\r\nseq->tkip.iv16 = le16_to_cpu(sc->iv16);\r\n}\r\nstatic void iwl_mvm_set_aes_rx_seq(struct aes_sc *scs,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nint tid;\r\nBUILD_BUG_ON(IWL_NUM_RSC != IEEE80211_NUM_TIDS);\r\nfor (tid = 0; tid < IWL_NUM_RSC; tid++) {\r\nstruct ieee80211_key_seq seq = {};\r\niwl_mvm_aes_sc_to_seq(&scs[tid], &seq);\r\nieee80211_set_key_rx_seq(key, tid, &seq);\r\n}\r\n}\r\nstatic void iwl_mvm_set_tkip_rx_seq(struct tkip_sc *scs,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nint tid;\r\nBUILD_BUG_ON(IWL_NUM_RSC != IEEE80211_NUM_TIDS);\r\nfor (tid = 0; tid < IWL_NUM_RSC; tid++) {\r\nstruct ieee80211_key_seq seq = {};\r\niwl_mvm_tkip_sc_to_seq(&scs[tid], &seq);\r\nieee80211_set_key_rx_seq(key, tid, &seq);\r\n}\r\n}\r\nstatic void iwl_mvm_set_key_rx_seq(struct ieee80211_key_conf *key,\r\nstruct iwl_wowlan_status *status)\r\n{\r\nunion iwl_all_tsc_rsc *rsc = &status->gtk.rsc.all_tsc_rsc;\r\nswitch (key->cipher) {\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\niwl_mvm_set_aes_rx_seq(rsc->aes.multicast_rsc, key);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\niwl_mvm_set_tkip_rx_seq(rsc->tkip.multicast_rsc, key);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\n}\r\nstatic void iwl_mvm_d3_update_gtks(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta,\r\nstruct ieee80211_key_conf *key,\r\nvoid *_data)\r\n{\r\nstruct iwl_mvm_d3_gtk_iter_data *data = _data;\r\nif (data->unhandled_cipher)\r\nreturn;\r\nswitch (key->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nreturn;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nbreak;\r\ndefault:\r\ndata->unhandled_cipher = true;\r\nreturn;\r\n}\r\ndata->num_keys++;\r\nif (sta) {\r\nstruct ieee80211_key_seq seq = {};\r\nunion iwl_all_tsc_rsc *sc = &data->status->gtk.rsc.all_tsc_rsc;\r\nif (data->find_phase)\r\nreturn;\r\nswitch (key->cipher) {\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\niwl_mvm_aes_sc_to_seq(&sc->aes.tsc, &seq);\r\niwl_mvm_set_aes_rx_seq(sc->aes.unicast_rsc, key);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\niwl_mvm_tkip_sc_to_seq(&sc->tkip.tsc, &seq);\r\niwl_mvm_set_tkip_rx_seq(sc->tkip.unicast_rsc, key);\r\nbreak;\r\n}\r\nieee80211_set_key_tx_seq(key, &seq);\r\nreturn;\r\n}\r\nif (data->find_phase) {\r\ndata->last_gtk = key;\r\ndata->cipher = key->cipher;\r\nreturn;\r\n}\r\nif (data->status->num_of_gtk_rekeys)\r\nieee80211_remove_key(key);\r\nelse if (data->last_gtk == key)\r\niwl_mvm_set_key_rx_seq(key, data->status);\r\n}\r\nstatic bool iwl_mvm_setup_connection_keep(struct iwl_mvm *mvm,\r\nstruct ieee80211_vif *vif,\r\nstruct iwl_wowlan_status *status)\r\n{\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nstruct iwl_mvm_d3_gtk_iter_data gtkdata = {\r\n.status = status,\r\n};\r\nu32 disconnection_reasons =\r\nIWL_WOWLAN_WAKEUP_BY_DISCONNECTION_ON_MISSED_BEACON |\r\nIWL_WOWLAN_WAKEUP_BY_DISCONNECTION_ON_DEAUTH;\r\nif (!status || !vif->bss_conf.bssid)\r\nreturn false;\r\nif (le32_to_cpu(status->wakeup_reasons) & disconnection_reasons)\r\nreturn false;\r\ngtkdata.find_phase = true;\r\nieee80211_iter_keys(mvm->hw, vif,\r\niwl_mvm_d3_update_gtks, &gtkdata);\r\nif (gtkdata.unhandled_cipher)\r\nreturn false;\r\nif (!gtkdata.num_keys)\r\ngoto out;\r\nif (!gtkdata.last_gtk)\r\nreturn false;\r\ngtkdata.find_phase = false;\r\nieee80211_iter_keys(mvm->hw, vif,\r\niwl_mvm_d3_update_gtks, &gtkdata);\r\nif (status->num_of_gtk_rekeys) {\r\nstruct ieee80211_key_conf *key;\r\nstruct {\r\nstruct ieee80211_key_conf conf;\r\nu8 key[32];\r\n} conf = {\r\n.conf.cipher = gtkdata.cipher,\r\n.conf.keyidx = status->gtk.key_index,\r\n};\r\nswitch (gtkdata.cipher) {\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nconf.conf.keylen = WLAN_KEY_LEN_CCMP;\r\nmemcpy(conf.conf.key, status->gtk.decrypt_key,\r\nWLAN_KEY_LEN_CCMP);\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nconf.conf.keylen = WLAN_KEY_LEN_TKIP;\r\nmemcpy(conf.conf.key, status->gtk.decrypt_key, 16);\r\nmemcpy(conf.conf.key +\r\nNL80211_TKIP_DATA_OFFSET_RX_MIC_KEY,\r\nstatus->gtk.tkip_mic_key, 8);\r\nbreak;\r\n}\r\nkey = ieee80211_gtk_rekey_add(vif, &conf.conf);\r\nif (IS_ERR(key))\r\nreturn false;\r\niwl_mvm_set_key_rx_seq(key, status);\r\n}\r\nif (status->num_of_gtk_rekeys) {\r\n__be64 replay_ctr =\r\ncpu_to_be64(le64_to_cpu(status->replay_ctr));\r\nieee80211_gtk_rekey_notify(vif, vif->bss_conf.bssid,\r\n(void *)&replay_ctr, GFP_KERNEL);\r\n}\r\nout:\r\nmvmvif->seqno_valid = true;\r\nmvmvif->seqno = le16_to_cpu(status->non_qos_seq_ctr) + 0x10;\r\nreturn true;\r\n}\r\nstatic bool iwl_mvm_query_wakeup_reasons(struct iwl_mvm *mvm,\r\nstruct ieee80211_vif *vif)\r\n{\r\nu32 base = mvm->error_event_table;\r\nstruct error_table_start {\r\nu32 valid;\r\nu32 error_id;\r\n} err_info;\r\nstruct iwl_host_cmd cmd = {\r\n.id = WOWLAN_GET_STATUSES,\r\n.flags = CMD_WANT_SKB,\r\n};\r\nstruct iwl_wowlan_status_data status;\r\nstruct iwl_wowlan_status *fw_status;\r\nint ret, len, status_size, i;\r\nbool keep;\r\nstruct ieee80211_sta *ap_sta;\r\nstruct iwl_mvm_sta *mvm_ap_sta;\r\niwl_trans_read_mem_bytes(mvm->trans, base,\r\n&err_info, sizeof(err_info));\r\nif (err_info.valid) {\r\nIWL_INFO(mvm, "error table is valid (%d)\n",\r\nerr_info.valid);\r\nif (err_info.error_id == RF_KILL_INDICATOR_FOR_WOWLAN) {\r\nstruct cfg80211_wowlan_wakeup wakeup = {\r\n.rfkill_release = true,\r\n};\r\nieee80211_report_wowlan_wakeup(vif, &wakeup,\r\nGFP_KERNEL);\r\n}\r\ngoto out_unlock;\r\n}\r\nret = iwl_mvm_send_cmd_pdu(mvm, OFFLOADS_QUERY_CMD, 0, 0, NULL);\r\nif (ret)\r\nIWL_ERR(mvm, "failed to query offload statistics (%d)\n", ret);\r\nret = iwl_mvm_send_cmd(mvm, &cmd);\r\nif (ret) {\r\nIWL_ERR(mvm, "failed to query status (%d)\n", ret);\r\ngoto out_unlock;\r\n}\r\nif (!cmd.resp_pkt)\r\ngoto out_unlock;\r\nstatus_size = sizeof(*fw_status);\r\nlen = iwl_rx_packet_payload_len(cmd.resp_pkt);\r\nif (len < status_size) {\r\nIWL_ERR(mvm, "Invalid WoWLAN status response!\n");\r\ngoto out_free_resp;\r\n}\r\nfw_status = (void *)cmd.resp_pkt->data;\r\nstatus.pattern_number = le16_to_cpu(fw_status->pattern_number);\r\nfor (i = 0; i < 8; i++)\r\nstatus.qos_seq_ctr[i] =\r\nle16_to_cpu(fw_status->qos_seq_ctr[i]);\r\nstatus.wakeup_reasons = le32_to_cpu(fw_status->wakeup_reasons);\r\nstatus.wake_packet_length =\r\nle32_to_cpu(fw_status->wake_packet_length);\r\nstatus.wake_packet_bufsize =\r\nle32_to_cpu(fw_status->wake_packet_bufsize);\r\nstatus.wake_packet = fw_status->wake_packet;\r\nif (len != status_size + ALIGN(status.wake_packet_bufsize, 4)) {\r\nIWL_ERR(mvm, "Invalid WoWLAN status response!\n");\r\ngoto out_free_resp;\r\n}\r\nap_sta = rcu_dereference_protected(\r\nmvm->fw_id_to_mac_id[0],\r\nlockdep_is_held(&mvm->mutex));\r\nif (IS_ERR_OR_NULL(ap_sta))\r\ngoto out_free_resp;\r\nmvm_ap_sta = (struct iwl_mvm_sta *)ap_sta->drv_priv;\r\nfor (i = 0; i < IWL_MAX_TID_COUNT; i++) {\r\nu16 seq = status.qos_seq_ctr[i];\r\nseq += 0x10;\r\nmvm_ap_sta->tid_data[i].seq_number = seq;\r\n}\r\nmutex_unlock(&mvm->mutex);\r\niwl_mvm_report_wakeup_reasons(mvm, vif, &status);\r\nkeep = iwl_mvm_setup_connection_keep(mvm, vif, fw_status);\r\niwl_free_resp(&cmd);\r\nreturn keep;\r\nout_free_resp:\r\niwl_free_resp(&cmd);\r\nout_unlock:\r\nmutex_unlock(&mvm->mutex);\r\nreturn false;\r\n}\r\nstatic void iwl_mvm_read_d3_sram(struct iwl_mvm *mvm)\r\n{\r\n#ifdef CONFIG_IWLWIFI_DEBUGFS\r\nconst struct fw_img *img = &mvm->fw->img[IWL_UCODE_WOWLAN];\r\nu32 len = img->sec[IWL_UCODE_SECTION_DATA].len;\r\nu32 offs = img->sec[IWL_UCODE_SECTION_DATA].offset;\r\nif (!mvm->store_d3_resume_sram)\r\nreturn;\r\nif (!mvm->d3_resume_sram) {\r\nmvm->d3_resume_sram = kzalloc(len, GFP_KERNEL);\r\nif (!mvm->d3_resume_sram)\r\nreturn;\r\n}\r\niwl_trans_read_mem_bytes(mvm->trans, offs, mvm->d3_resume_sram, len);\r\n#endif\r\n}\r\nstatic void iwl_mvm_d3_disconnect_iter(void *data, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nif (data == vif)\r\nreturn;\r\nif (vif->type == NL80211_IFTYPE_STATION)\r\nieee80211_resume_disconnect(vif);\r\n}\r\nstatic int __iwl_mvm_resume(struct iwl_mvm *mvm, bool test)\r\n{\r\nstruct iwl_d3_iter_data resume_iter_data = {\r\n.mvm = mvm,\r\n};\r\nstruct ieee80211_vif *vif = NULL;\r\nint ret;\r\nenum iwl_d3_status d3_status;\r\nbool keep = false;\r\nmutex_lock(&mvm->mutex);\r\nieee80211_iterate_active_interfaces_atomic(\r\nmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\r\niwl_mvm_d3_iface_iterator, &resume_iter_data);\r\nif (WARN_ON(resume_iter_data.error || !resume_iter_data.vif))\r\ngoto out_unlock;\r\nvif = resume_iter_data.vif;\r\nret = iwl_trans_d3_resume(mvm->trans, &d3_status, test);\r\nif (ret)\r\ngoto out_unlock;\r\nif (d3_status != IWL_D3_STATUS_ALIVE) {\r\nIWL_INFO(mvm, "Device was reset during suspend\n");\r\ngoto out_unlock;\r\n}\r\niwl_mvm_read_d3_sram(mvm);\r\nkeep = iwl_mvm_query_wakeup_reasons(mvm, vif);\r\n#ifdef CONFIG_IWLWIFI_DEBUGFS\r\nif (keep)\r\nmvm->keep_vif = vif;\r\n#endif\r\ngoto out;\r\nout_unlock:\r\nmutex_unlock(&mvm->mutex);\r\nout:\r\nif (!test)\r\nieee80211_iterate_active_interfaces_rtnl(mvm->hw,\r\nIEEE80211_IFACE_ITER_NORMAL,\r\niwl_mvm_d3_disconnect_iter, keep ? vif : NULL);\r\nset_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status);\r\nreturn 1;\r\n}\r\nint iwl_mvm_resume(struct ieee80211_hw *hw)\r\n{\r\nstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\r\nif (iwl_mvm_is_d0i3_supported(mvm)) {\r\nbool exit_now;\r\nmutex_lock(&mvm->d0i3_suspend_mutex);\r\n__clear_bit(D0I3_DEFER_WAKEUP, &mvm->d0i3_suspend_flags);\r\nexit_now = __test_and_clear_bit(D0I3_PENDING_WAKEUP,\r\n&mvm->d0i3_suspend_flags);\r\nmutex_unlock(&mvm->d0i3_suspend_mutex);\r\nif (exit_now)\r\n_iwl_mvm_exit_d0i3(mvm);\r\nreturn 0;\r\n}\r\nreturn __iwl_mvm_resume(mvm, false);\r\n}\r\nvoid iwl_mvm_set_wakeup(struct ieee80211_hw *hw, bool enabled)\r\n{\r\nstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\r\ndevice_set_wakeup_enable(mvm->trans->dev, enabled);\r\n}\r\nstatic int iwl_mvm_d3_test_open(struct inode *inode, struct file *file)\r\n{\r\nstruct iwl_mvm *mvm = inode->i_private;\r\nint err;\r\nif (mvm->d3_test_active)\r\nreturn -EBUSY;\r\nfile->private_data = inode->i_private;\r\nieee80211_stop_queues(mvm->hw);\r\nsynchronize_net();\r\nrtnl_lock();\r\nerr = __iwl_mvm_suspend(mvm->hw, mvm->hw->wiphy->wowlan_config, true);\r\nrtnl_unlock();\r\nif (err > 0)\r\nerr = -EINVAL;\r\nif (err) {\r\nieee80211_wake_queues(mvm->hw);\r\nreturn err;\r\n}\r\nmvm->d3_test_active = true;\r\nmvm->keep_vif = NULL;\r\nreturn 0;\r\n}\r\nstatic ssize_t iwl_mvm_d3_test_read(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct iwl_mvm *mvm = file->private_data;\r\nu32 pme_asserted;\r\nwhile (true) {\r\nif (mvm->d3_test_pme_ptr) {\r\npme_asserted = iwl_trans_read_mem32(mvm->trans,\r\nmvm->d3_test_pme_ptr);\r\nif (pme_asserted)\r\nbreak;\r\n}\r\nif (msleep_interruptible(100))\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void iwl_mvm_d3_test_disconn_work_iter(void *_data, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nif (_data == vif)\r\nreturn;\r\nif (vif->type == NL80211_IFTYPE_STATION)\r\nieee80211_connection_loss(vif);\r\n}\r\nstatic int iwl_mvm_d3_test_release(struct inode *inode, struct file *file)\r\n{\r\nstruct iwl_mvm *mvm = inode->i_private;\r\nint remaining_time = 10;\r\nmvm->d3_test_active = false;\r\n__iwl_mvm_resume(mvm, true);\r\niwl_abort_notification_waits(&mvm->notif_wait);\r\nieee80211_restart_hw(mvm->hw);\r\nwhile (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status) &&\r\nremaining_time > 0) {\r\nremaining_time--;\r\nmsleep(1000);\r\n}\r\nif (remaining_time == 0)\r\nIWL_ERR(mvm, "Timed out waiting for HW restart to finish!\n");\r\nieee80211_iterate_active_interfaces_atomic(\r\nmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\r\niwl_mvm_d3_test_disconn_work_iter, mvm->keep_vif);\r\nieee80211_wake_queues(mvm->hw);\r\nreturn 0;\r\n}
