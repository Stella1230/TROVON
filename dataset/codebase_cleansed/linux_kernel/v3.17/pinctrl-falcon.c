static void lantiq_load_pin_desc(struct pinctrl_pin_desc *d, int bank, int len)\r\n{\r\nint base = bank * PINS;\r\nint i;\r\nfor (i = 0; i < len; i++) {\r\nchar *name = kzalloc(6, GFP_KERNEL);\r\nsnprintf(name, 6, "io%d", base + i);\r\nd[i].number = base + i;\r\nd[i].name = name;\r\n}\r\npad_count[bank] = len;\r\n}\r\nstatic int falcon_pinconf_group_get(struct pinctrl_dev *pctrldev,\r\nunsigned group, unsigned long *config)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int falcon_pinconf_group_set(struct pinctrl_dev *pctrldev,\r\nunsigned group, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int falcon_pinconf_get(struct pinctrl_dev *pctrldev,\r\nunsigned pin, unsigned long *config)\r\n{\r\nstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);\r\nenum ltq_pinconf_param param = LTQ_PINCONF_UNPACK_PARAM(*config);\r\nvoid __iomem *mem = info->membase[PORT(pin)];\r\nswitch (param) {\r\ncase LTQ_PINCONF_PARAM_DRIVE_CURRENT:\r\n*config = LTQ_PINCONF_PACK(param,\r\n!!pad_getbit(mem, LTQ_PADC_DCC, PORT_PIN(pin)));\r\nbreak;\r\ncase LTQ_PINCONF_PARAM_SLEW_RATE:\r\n*config = LTQ_PINCONF_PACK(param,\r\n!!pad_getbit(mem, LTQ_PADC_SRC, PORT_PIN(pin)));\r\nbreak;\r\ncase LTQ_PINCONF_PARAM_PULL:\r\nif (pad_getbit(mem, LTQ_PADC_PDEN, PORT_PIN(pin)))\r\n*config = LTQ_PINCONF_PACK(param, 1);\r\nelse if (pad_getbit(mem, LTQ_PADC_PUEN, PORT_PIN(pin)))\r\n*config = LTQ_PINCONF_PACK(param, 2);\r\nelse\r\n*config = LTQ_PINCONF_PACK(param, 0);\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int falcon_pinconf_set(struct pinctrl_dev *pctrldev,\r\nunsigned pin, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nenum ltq_pinconf_param param;\r\nint arg;\r\nstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);\r\nvoid __iomem *mem = info->membase[PORT(pin)];\r\nu32 reg;\r\nint i;\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = LTQ_PINCONF_UNPACK_PARAM(configs[i]);\r\narg = LTQ_PINCONF_UNPACK_ARG(configs[i]);\r\nswitch (param) {\r\ncase LTQ_PINCONF_PARAM_DRIVE_CURRENT:\r\nreg = LTQ_PADC_DCC;\r\nbreak;\r\ncase LTQ_PINCONF_PARAM_SLEW_RATE:\r\nreg = LTQ_PADC_SRC;\r\nbreak;\r\ncase LTQ_PINCONF_PARAM_PULL:\r\nif (arg == 1)\r\nreg = LTQ_PADC_PDEN;\r\nelse\r\nreg = LTQ_PADC_PUEN;\r\nbreak;\r\ndefault:\r\npr_err("%s: Invalid config param %04x\n",\r\npinctrl_dev_get_name(pctrldev), param);\r\nreturn -ENOTSUPP;\r\n}\r\npad_w32(mem, BIT(PORT_PIN(pin)), reg);\r\nif (!(pad_r32(mem, reg) & BIT(PORT_PIN(pin))))\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic void falcon_pinconf_dbg_show(struct pinctrl_dev *pctrldev,\r\nstruct seq_file *s, unsigned offset)\r\n{\r\nunsigned long config;\r\nstruct pin_desc *desc;\r\nstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);\r\nint port = PORT(offset);\r\nseq_printf(s, " (port %d) mux %d -- ", port,\r\npad_r32(info->membase[port], LTQ_PADC_MUX(PORT_PIN(offset))));\r\nconfig = LTQ_PINCONF_PACK(LTQ_PINCONF_PARAM_PULL, 0);\r\nif (!falcon_pinconf_get(pctrldev, offset, &config))\r\nseq_printf(s, "pull %d ",\r\n(int)LTQ_PINCONF_UNPACK_ARG(config));\r\nconfig = LTQ_PINCONF_PACK(LTQ_PINCONF_PARAM_DRIVE_CURRENT, 0);\r\nif (!falcon_pinconf_get(pctrldev, offset, &config))\r\nseq_printf(s, "drive-current %d ",\r\n(int)LTQ_PINCONF_UNPACK_ARG(config));\r\nconfig = LTQ_PINCONF_PACK(LTQ_PINCONF_PARAM_SLEW_RATE, 0);\r\nif (!falcon_pinconf_get(pctrldev, offset, &config))\r\nseq_printf(s, "slew-rate %d ",\r\n(int)LTQ_PINCONF_UNPACK_ARG(config));\r\ndesc = pin_desc_get(pctrldev, offset);\r\nif (desc) {\r\nif (desc->gpio_owner)\r\nseq_printf(s, " owner: %s", desc->gpio_owner);\r\n} else {\r\nseq_printf(s, " not registered");\r\n}\r\n}\r\nstatic void falcon_pinconf_group_dbg_show(struct pinctrl_dev *pctrldev,\r\nstruct seq_file *s, unsigned selector)\r\n{\r\n}\r\nstatic inline int falcon_mux_apply(struct pinctrl_dev *pctrldev,\r\nint mfp, int mux)\r\n{\r\nstruct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);\r\nint port = PORT(info->mfp[mfp].pin);\r\nif ((port >= PORTS) || (!info->membase[port]))\r\nreturn -ENODEV;\r\npad_w32(info->membase[port], mux,\r\nLTQ_PADC_MUX(PORT_PIN(info->mfp[mfp].pin)));\r\nreturn 0;\r\n}\r\nint pinctrl_falcon_get_range_size(int id)\r\n{\r\nu32 avail;\r\nif ((id >= PORTS) || (!falcon_info.membase[id]))\r\nreturn -EINVAL;\r\navail = pad_r32(falcon_info.membase[id], LTQ_PADC_AVAIL);\r\nreturn fls(avail);\r\n}\r\nvoid pinctrl_falcon_add_gpio_range(struct pinctrl_gpio_range *range)\r\n{\r\npinctrl_add_gpio_range(falcon_info.pctrl, range);\r\n}\r\nstatic int pinctrl_falcon_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np;\r\nint pad_count = 0;\r\nint ret = 0;\r\nfor_each_compatible_node(np, NULL, "lantiq,pad-falcon") {\r\nstruct platform_device *ppdev = of_find_device_by_node(np);\r\nconst __be32 *bank = of_get_property(np, "lantiq,bank", NULL);\r\nstruct resource res;\r\nu32 avail;\r\nint pins;\r\nif (!of_device_is_available(np))\r\ncontinue;\r\nif (!ppdev) {\r\ndev_err(&pdev->dev, "failed to find pad pdev\n");\r\ncontinue;\r\n}\r\nif (!bank || *bank >= PORTS)\r\ncontinue;\r\nif (of_address_to_resource(np, 0, &res))\r\ncontinue;\r\nfalcon_info.clk[*bank] = clk_get(&ppdev->dev, NULL);\r\nif (IS_ERR(falcon_info.clk[*bank])) {\r\ndev_err(&ppdev->dev, "failed to get clock\n");\r\nreturn PTR_ERR(falcon_info.clk[*bank]);\r\n}\r\nfalcon_info.membase[*bank] = devm_ioremap_resource(&pdev->dev,\r\n&res);\r\nif (IS_ERR(falcon_info.membase[*bank]))\r\nreturn PTR_ERR(falcon_info.membase[*bank]);\r\navail = pad_r32(falcon_info.membase[*bank],\r\nLTQ_PADC_AVAIL);\r\npins = fls(avail);\r\nlantiq_load_pin_desc(&falcon_pads[pad_count], *bank, pins);\r\npad_count += pins;\r\nclk_enable(falcon_info.clk[*bank]);\r\ndev_dbg(&pdev->dev, "found %s with %d pads\n",\r\nres.name, pins);\r\n}\r\ndev_dbg(&pdev->dev, "found a total of %d pads\n", pad_count);\r\nfalcon_pctrl_desc.name = dev_name(&pdev->dev);\r\nfalcon_pctrl_desc.npins = pad_count;\r\nfalcon_info.mfp = falcon_mfp;\r\nfalcon_info.num_mfp = ARRAY_SIZE(falcon_mfp);\r\nfalcon_info.grps = falcon_grps;\r\nfalcon_info.num_grps = ARRAY_SIZE(falcon_grps);\r\nfalcon_info.funcs = falcon_funcs;\r\nfalcon_info.num_funcs = ARRAY_SIZE(falcon_funcs);\r\nret = ltq_pinctrl_register(pdev, &falcon_info);\r\nif (!ret)\r\ndev_info(&pdev->dev, "Init done\n");\r\nreturn ret;\r\n}\r\nint __init pinctrl_falcon_init(void)\r\n{\r\nreturn platform_driver_register(&pinctrl_falcon_driver);\r\n}
