static int mxs_saif_set_dai_sysclk(struct snd_soc_dai *cpu_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);\r\nswitch (clk_id) {\r\ncase MXS_SAIF_MCLK:\r\nsaif->mclk = freq;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline struct mxs_saif *mxs_saif_get_master(struct mxs_saif * saif)\r\n{\r\nreturn mxs_saif[saif->master_id];\r\n}\r\nstatic int mxs_saif_set_clk(struct mxs_saif *saif,\r\nunsigned int mclk,\r\nunsigned int rate)\r\n{\r\nu32 scr;\r\nint ret;\r\nstruct mxs_saif *master_saif;\r\ndev_dbg(saif->dev, "mclk %d rate %d\n", mclk, rate);\r\nmaster_saif = mxs_saif_get_master(saif);\r\nif (!master_saif)\r\nreturn -EINVAL;\r\ndev_dbg(saif->dev, "master saif%d\n", master_saif->id);\r\nif (master_saif->ongoing && rate != master_saif->cur_rate) {\r\ndev_err(saif->dev,\r\n"can not change clock, master saif%d(rate %d) is ongoing\n",\r\nmaster_saif->id, master_saif->cur_rate);\r\nreturn -EINVAL;\r\n}\r\nscr = __raw_readl(master_saif->base + SAIF_CTRL);\r\nscr &= ~BM_SAIF_CTRL_BITCLK_MULT_RATE;\r\nscr &= ~BM_SAIF_CTRL_BITCLK_BASE_RATE;\r\nclk_prepare_enable(master_saif->clk);\r\nif (master_saif->mclk_in_use) {\r\nif (mclk % 32 == 0) {\r\nscr &= ~BM_SAIF_CTRL_BITCLK_BASE_RATE;\r\nret = clk_set_rate(master_saif->clk, 512 * rate);\r\n} else if (mclk % 48 == 0) {\r\nscr |= BM_SAIF_CTRL_BITCLK_BASE_RATE;\r\nret = clk_set_rate(master_saif->clk, 384 * rate);\r\n} else {\r\nclk_disable_unprepare(master_saif->clk);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nret = clk_set_rate(master_saif->clk, 512 * rate);\r\nscr &= ~BM_SAIF_CTRL_BITCLK_BASE_RATE;\r\n}\r\nclk_disable_unprepare(master_saif->clk);\r\nif (ret)\r\nreturn ret;\r\nmaster_saif->cur_rate = rate;\r\nif (!master_saif->mclk_in_use) {\r\n__raw_writel(scr, master_saif->base + SAIF_CTRL);\r\nreturn 0;\r\n}\r\nswitch (mclk / rate) {\r\ncase 32:\r\nscr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(4);\r\nbreak;\r\ncase 64:\r\nscr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(3);\r\nbreak;\r\ncase 128:\r\nscr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(2);\r\nbreak;\r\ncase 256:\r\nscr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(1);\r\nbreak;\r\ncase 512:\r\nscr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(0);\r\nbreak;\r\ncase 48:\r\nscr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(3);\r\nbreak;\r\ncase 96:\r\nscr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(2);\r\nbreak;\r\ncase 192:\r\nscr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(1);\r\nbreak;\r\ncase 384:\r\nscr |= BF_SAIF_CTRL_BITCLK_MULT_RATE(0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n__raw_writel(scr, master_saif->base + SAIF_CTRL);\r\nreturn 0;\r\n}\r\nint mxs_saif_put_mclk(unsigned int saif_id)\r\n{\r\nstruct mxs_saif *saif = mxs_saif[saif_id];\r\nu32 stat;\r\nif (!saif)\r\nreturn -EINVAL;\r\nstat = __raw_readl(saif->base + SAIF_STAT);\r\nif (stat & BM_SAIF_STAT_BUSY) {\r\ndev_err(saif->dev, "error: busy\n");\r\nreturn -EBUSY;\r\n}\r\nclk_disable_unprepare(saif->clk);\r\n__raw_writel(BM_SAIF_CTRL_CLKGATE,\r\nsaif->base + SAIF_CTRL + MXS_SET_ADDR);\r\n__raw_writel(BM_SAIF_CTRL_RUN,\r\nsaif->base + SAIF_CTRL + MXS_CLR_ADDR);\r\nsaif->mclk_in_use = 0;\r\nreturn 0;\r\n}\r\nint mxs_saif_get_mclk(unsigned int saif_id, unsigned int mclk,\r\nunsigned int rate)\r\n{\r\nstruct mxs_saif *saif = mxs_saif[saif_id];\r\nu32 stat;\r\nint ret;\r\nstruct mxs_saif *master_saif;\r\nif (!saif)\r\nreturn -EINVAL;\r\n__raw_writel(BM_SAIF_CTRL_SFTRST,\r\nsaif->base + SAIF_CTRL + MXS_CLR_ADDR);\r\n__raw_writel(BM_SAIF_CTRL_CLKGATE,\r\nsaif->base + SAIF_CTRL + MXS_CLR_ADDR);\r\nmaster_saif = mxs_saif_get_master(saif);\r\nif (saif != master_saif) {\r\ndev_err(saif->dev, "can not get mclk from a non-master saif\n");\r\nreturn -EINVAL;\r\n}\r\nstat = __raw_readl(saif->base + SAIF_STAT);\r\nif (stat & BM_SAIF_STAT_BUSY) {\r\ndev_err(saif->dev, "error: busy\n");\r\nreturn -EBUSY;\r\n}\r\nsaif->mclk_in_use = 1;\r\nret = mxs_saif_set_clk(saif, mclk, rate);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(saif->clk);\r\nif (ret)\r\nreturn ret;\r\n__raw_writel(BM_SAIF_CTRL_RUN,\r\nsaif->base + SAIF_CTRL + MXS_SET_ADDR);\r\nreturn 0;\r\n}\r\nstatic int mxs_saif_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)\r\n{\r\nu32 scr, stat;\r\nu32 scr0;\r\nstruct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);\r\nstat = __raw_readl(saif->base + SAIF_STAT);\r\nif (stat & BM_SAIF_STAT_BUSY) {\r\ndev_err(cpu_dai->dev, "error: busy\n");\r\nreturn -EBUSY;\r\n}\r\nscr0 = __raw_readl(saif->base + SAIF_CTRL);\r\nscr0 = scr0 & ~BM_SAIF_CTRL_BITCLK_EDGE & ~BM_SAIF_CTRL_LRCLK_POLARITY \\r\n& ~BM_SAIF_CTRL_JUSTIFY & ~BM_SAIF_CTRL_DELAY;\r\nscr = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nscr |= BM_SAIF_CTRL_DELAY;\r\nscr &= ~BM_SAIF_CTRL_LRCLK_POLARITY;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nscr &= ~BM_SAIF_CTRL_DELAY;\r\nscr &= ~BM_SAIF_CTRL_LRCLK_POLARITY;\r\nscr &= ~BM_SAIF_CTRL_JUSTIFY;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nscr |= BM_SAIF_CTRL_BITCLK_EDGE;\r\nscr |= BM_SAIF_CTRL_LRCLK_POLARITY;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nscr |= BM_SAIF_CTRL_BITCLK_EDGE;\r\nscr &= ~BM_SAIF_CTRL_LRCLK_POLARITY;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nscr &= ~BM_SAIF_CTRL_BITCLK_EDGE;\r\nscr |= BM_SAIF_CTRL_LRCLK_POLARITY;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nscr &= ~BM_SAIF_CTRL_BITCLK_EDGE;\r\nscr &= ~BM_SAIF_CTRL_LRCLK_POLARITY;\r\nbreak;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nif (saif->id == saif->master_id)\r\nscr &= ~BM_SAIF_CTRL_SLAVE_MODE;\r\nelse\r\nscr |= BM_SAIF_CTRL_SLAVE_MODE;\r\n__raw_writel(scr | scr0, saif->base + SAIF_CTRL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxs_saif_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);\r\nsaif->fifo_underrun = 0;\r\nsaif->fifo_overrun = 0;\r\n__raw_writel(BM_SAIF_CTRL_SFTRST,\r\nsaif->base + SAIF_CTRL + MXS_CLR_ADDR);\r\n__raw_writel(BM_SAIF_CTRL_CLKGATE,\r\nsaif->base + SAIF_CTRL + MXS_CLR_ADDR);\r\nreturn 0;\r\n}\r\nstatic int mxs_saif_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct mxs_saif *master_saif;\r\nu32 scr, stat;\r\nint ret;\r\nmaster_saif = mxs_saif_get_master(saif);\r\nif (!master_saif)\r\nreturn -EINVAL;\r\nif (!saif->mclk && saif->mclk_in_use) {\r\ndev_err(cpu_dai->dev, "set mclk first\n");\r\nreturn -EINVAL;\r\n}\r\nstat = __raw_readl(saif->base + SAIF_STAT);\r\nif (stat & BM_SAIF_STAT_BUSY) {\r\ndev_err(cpu_dai->dev, "error: busy\n");\r\nreturn -EBUSY;\r\n}\r\nret = mxs_saif_set_clk(saif, saif->mclk, params_rate(params));\r\nif (ret) {\r\ndev_err(cpu_dai->dev, "unable to get proper clk\n");\r\nreturn ret;\r\n}\r\nclk_prepare(saif->clk);\r\nif (saif != master_saif) {\r\nclk_enable(saif->clk);\r\nret = clk_set_rate(saif->clk, 24000000);\r\nclk_disable(saif->clk);\r\nif (ret)\r\nreturn ret;\r\nclk_prepare(master_saif->clk);\r\n}\r\nscr = __raw_readl(saif->base + SAIF_CTRL);\r\nscr &= ~BM_SAIF_CTRL_WORD_LENGTH;\r\nscr &= ~BM_SAIF_CTRL_BITCLK_48XFS_ENABLE;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nscr |= BF_SAIF_CTRL_WORD_LENGTH(0);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nscr |= BF_SAIF_CTRL_WORD_LENGTH(4);\r\nscr |= BM_SAIF_CTRL_BITCLK_48XFS_ENABLE;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nscr |= BF_SAIF_CTRL_WORD_LENGTH(8);\r\nscr |= BM_SAIF_CTRL_BITCLK_48XFS_ENABLE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nscr &= ~BM_SAIF_CTRL_READ_MODE;\r\n} else {\r\nscr |= BM_SAIF_CTRL_READ_MODE;\r\n}\r\n__raw_writel(scr, saif->base + SAIF_CTRL);\r\nreturn 0;\r\n}\r\nstatic int mxs_saif_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);\r\n__raw_writel(BM_SAIF_CTRL_FIFO_ERROR_IRQ_EN,\r\nsaif->base + SAIF_CTRL + MXS_SET_ADDR);\r\nreturn 0;\r\n}\r\nstatic int mxs_saif_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct mxs_saif *saif = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct mxs_saif *master_saif;\r\nu32 delay;\r\nint ret;\r\nmaster_saif = mxs_saif_get_master(saif);\r\nif (!master_saif)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (saif->state == MXS_SAIF_STATE_RUNNING)\r\nreturn 0;\r\ndev_dbg(cpu_dai->dev, "start\n");\r\nret = clk_enable(master_saif->clk);\r\nif (ret) {\r\ndev_err(saif->dev, "Failed to enable master clock\n");\r\nreturn ret;\r\n}\r\nif (saif != master_saif) {\r\nret = clk_enable(saif->clk);\r\nif (ret) {\r\ndev_err(saif->dev, "Failed to enable master clock\n");\r\nclk_disable(master_saif->clk);\r\nreturn ret;\r\n}\r\n__raw_writel(BM_SAIF_CTRL_RUN,\r\nsaif->base + SAIF_CTRL + MXS_SET_ADDR);\r\n}\r\nif (!master_saif->mclk_in_use)\r\n__raw_writel(BM_SAIF_CTRL_RUN,\r\nmaster_saif->base + SAIF_CTRL + MXS_SET_ADDR);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\n__raw_writel(0, saif->base + SAIF_DATA);\r\n__raw_writel(0, saif->base + SAIF_DATA);\r\n} else {\r\n__raw_readl(saif->base + SAIF_DATA);\r\n__raw_readl(saif->base + SAIF_DATA);\r\n}\r\nmaster_saif->ongoing = 1;\r\nsaif->state = MXS_SAIF_STATE_RUNNING;\r\ndev_dbg(saif->dev, "CTRL 0x%x STAT 0x%x\n",\r\n__raw_readl(saif->base + SAIF_CTRL),\r\n__raw_readl(saif->base + SAIF_STAT));\r\ndev_dbg(master_saif->dev, "CTRL 0x%x STAT 0x%x\n",\r\n__raw_readl(master_saif->base + SAIF_CTRL),\r\n__raw_readl(master_saif->base + SAIF_STAT));\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (saif->state == MXS_SAIF_STATE_STOPPED)\r\nreturn 0;\r\ndev_dbg(cpu_dai->dev, "stop\n");\r\ndelay = USEC_PER_SEC / master_saif->cur_rate;\r\nif (!master_saif->mclk_in_use) {\r\n__raw_writel(BM_SAIF_CTRL_RUN,\r\nmaster_saif->base + SAIF_CTRL + MXS_CLR_ADDR);\r\nudelay(delay);\r\n}\r\nclk_disable(master_saif->clk);\r\nif (saif != master_saif) {\r\n__raw_writel(BM_SAIF_CTRL_RUN,\r\nsaif->base + SAIF_CTRL + MXS_CLR_ADDR);\r\nudelay(delay);\r\nclk_disable(saif->clk);\r\n}\r\nmaster_saif->ongoing = 0;\r\nsaif->state = MXS_SAIF_STATE_STOPPED;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxs_saif_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct mxs_saif *saif = dev_get_drvdata(dai->dev);\r\nsnd_soc_dai_set_drvdata(dai, saif);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t mxs_saif_irq(int irq, void *dev_id)\r\n{\r\nstruct mxs_saif *saif = dev_id;\r\nunsigned int stat;\r\nstat = __raw_readl(saif->base + SAIF_STAT);\r\nif (!(stat & (BM_SAIF_STAT_FIFO_UNDERFLOW_IRQ |\r\nBM_SAIF_STAT_FIFO_OVERFLOW_IRQ)))\r\nreturn IRQ_NONE;\r\nif (stat & BM_SAIF_STAT_FIFO_UNDERFLOW_IRQ) {\r\ndev_dbg(saif->dev, "underrun!!! %d\n", ++saif->fifo_underrun);\r\n__raw_writel(BM_SAIF_STAT_FIFO_UNDERFLOW_IRQ,\r\nsaif->base + SAIF_STAT + MXS_CLR_ADDR);\r\n}\r\nif (stat & BM_SAIF_STAT_FIFO_OVERFLOW_IRQ) {\r\ndev_dbg(saif->dev, "overrun!!! %d\n", ++saif->fifo_overrun);\r\n__raw_writel(BM_SAIF_STAT_FIFO_OVERFLOW_IRQ,\r\nsaif->base + SAIF_STAT + MXS_CLR_ADDR);\r\n}\r\ndev_dbg(saif->dev, "SAIF_CTRL %x SAIF_STAT %x\n",\r\n__raw_readl(saif->base + SAIF_CTRL),\r\n__raw_readl(saif->base + SAIF_STAT));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mxs_saif_mclk_init(struct platform_device *pdev)\r\n{\r\nstruct mxs_saif *saif = platform_get_drvdata(pdev);\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct clk *clk;\r\nint ret;\r\nclk = clk_register_divider(&pdev->dev, "mxs_saif_mclk",\r\n__clk_get_name(saif->clk), 0,\r\nsaif->base + SAIF_CTRL,\r\nBP_SAIF_CTRL_BITCLK_MULT_RATE, 3,\r\n0, NULL);\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\nif (ret == -EEXIST)\r\nreturn 0;\r\ndev_err(&pdev->dev, "failed to register mclk: %d\n", ret);\r\nreturn PTR_ERR(clk);\r\n}\r\nret = of_clk_add_provider(np, of_clk_src_simple_get, clk);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int mxs_saif_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct resource *iores;\r\nstruct mxs_saif *saif;\r\nint ret = 0;\r\nstruct device_node *master;\r\nif (!np)\r\nreturn -EINVAL;\r\nsaif = devm_kzalloc(&pdev->dev, sizeof(*saif), GFP_KERNEL);\r\nif (!saif)\r\nreturn -ENOMEM;\r\nret = of_alias_get_id(np, "saif");\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nsaif->id = ret;\r\nmaster = of_parse_phandle(np, "fsl,saif-master", 0);\r\nif (!master) {\r\nsaif->master_id = saif->id;\r\n} else {\r\nret = of_alias_get_id(master, "saif");\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nsaif->master_id = ret;\r\n}\r\nif (saif->master_id >= ARRAY_SIZE(mxs_saif)) {\r\ndev_err(&pdev->dev, "get wrong master id\n");\r\nreturn -EINVAL;\r\n}\r\nmxs_saif[saif->id] = saif;\r\nsaif->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(saif->clk)) {\r\nret = PTR_ERR(saif->clk);\r\ndev_err(&pdev->dev, "Cannot get the clock: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\niores = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nsaif->base = devm_ioremap_resource(&pdev->dev, iores);\r\nif (IS_ERR(saif->base))\r\nreturn PTR_ERR(saif->base);\r\nsaif->irq = platform_get_irq(pdev, 0);\r\nif (saif->irq < 0) {\r\nret = saif->irq;\r\ndev_err(&pdev->dev, "failed to get irq resource: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nsaif->dev = &pdev->dev;\r\nret = devm_request_irq(&pdev->dev, saif->irq, mxs_saif_irq, 0,\r\n"mxs-saif", saif);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request irq\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, saif);\r\nif (saif->id == 0) {\r\nret = mxs_saif_mclk_init(pdev);\r\nif (ret)\r\ndev_warn(&pdev->dev, "failed to init clocks\n");\r\n}\r\nret = devm_snd_soc_register_component(&pdev->dev, &mxs_saif_component,\r\n&mxs_saif_dai, 1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "register DAI failed\n");\r\nreturn ret;\r\n}\r\nret = mxs_pcm_platform_register(&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "register PCM failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
