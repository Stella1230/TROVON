static void atao_select_reg_group(struct comedi_device *dev, int group)\r\n{\r\nstruct atao_private *devpriv = dev->private;\r\nif (group)\r\ndevpriv->cfg1 |= ATAO_CFG1_GRP2WR;\r\nelse\r\ndevpriv->cfg1 &= ~ATAO_CFG1_GRP2WR;\r\noutw(devpriv->cfg1, dev->iobase + ATAO_CFG1_REG);\r\n}\r\nstatic int atao_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct atao_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int val;\r\nint i;\r\nif (chan == 0)\r\natao_select_reg_group(dev, 1);\r\nfor (i = 0; i < insn->n; i++) {\r\nval = data[i];\r\ndevpriv->ao_readback[chan] = val;\r\nval = comedi_offset_munge(s, val);\r\noutw(val, dev->iobase + ATAO_AO_REG(chan));\r\n}\r\nif (chan == 0)\r\natao_select_reg_group(dev, 0);\r\nreturn insn->n;\r\n}\r\nstatic int atao_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct atao_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint i;\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = devpriv->ao_readback[chan];\r\nreturn insn->n;\r\n}\r\nstatic int atao_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data))\r\noutw(s->state, dev->iobase + ATAO_DIO_REG);\r\ndata[1] = inw(dev->iobase + ATAO_DIO_REG);\r\nreturn insn->n;\r\n}\r\nstatic int atao_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct atao_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int mask;\r\nint ret;\r\nif (chan < 4)\r\nmask = 0x0f;\r\nelse\r\nmask = 0xf0;\r\nret = comedi_dio_insn_config(dev, s, insn, data, mask);\r\nif (ret)\r\nreturn ret;\r\nif (s->io_bits & 0x0f)\r\ndevpriv->cfg3 |= ATAO_CFG3_DOUTEN1;\r\nelse\r\ndevpriv->cfg3 &= ~ATAO_CFG3_DOUTEN1;\r\nif (s->io_bits & 0xf0)\r\ndevpriv->cfg3 |= ATAO_CFG3_DOUTEN2;\r\nelse\r\ndevpriv->cfg3 &= ~ATAO_CFG3_DOUTEN2;\r\noutw(devpriv->cfg3, dev->iobase + ATAO_CFG3_REG);\r\nreturn insn->n;\r\n}\r\nstatic int atao_calib_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct atao_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int bitstring;\r\nunsigned int val;\r\nint bit;\r\nif (insn->n == 0)\r\nreturn 0;\r\ndevpriv->caldac[chan] = data[insn->n - 1] & s->maxdata;\r\nbitstring = ((chan & 0x7) << 8) | devpriv->caldac[chan];\r\nfor (bit = 1 << 10; bit; bit >>= 1) {\r\nval = (bit & bitstring) ? ATAO_CFG2_SDATA : 0;\r\noutw(val, dev->iobase + ATAO_CFG2_REG);\r\noutw(val | ATAO_CFG2_SCLK, dev->iobase + ATAO_CFG2_REG);\r\n}\r\noutw(ATAO_CFG2_CALLD(chan), dev->iobase + ATAO_CFG2_REG);\r\noutw(ATAO_CFG2_CALLD_NOP, dev->iobase + ATAO_CFG2_REG);\r\nreturn insn->n;\r\n}\r\nstatic int atao_calib_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct atao_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint i;\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = devpriv->caldac[chan];\r\nreturn insn->n;\r\n}\r\nstatic void atao_reset(struct comedi_device *dev)\r\n{\r\nstruct atao_private *devpriv = dev->private;\r\nunsigned long timer_base = dev->iobase + ATAO_82C53_BASE;\r\ndevpriv->cfg1 = 0;\r\noutw(devpriv->cfg1, dev->iobase + ATAO_CFG1_REG);\r\ni8254_set_mode(timer_base, 0, 0, I8254_MODE4 | I8254_BINARY);\r\ni8254_set_mode(timer_base, 0, 1, I8254_MODE4 | I8254_BINARY);\r\ni8254_write(timer_base, 0, 0, 0x0003);\r\noutw(ATAO_CFG2_CALLD_NOP, dev->iobase + ATAO_CFG2_REG);\r\ndevpriv->cfg3 = 0;\r\noutw(devpriv->cfg3, dev->iobase + ATAO_CFG3_REG);\r\ninw(dev->iobase + ATAO_FIFO_CLEAR_REG);\r\natao_select_reg_group(dev, 1);\r\noutw(0, dev->iobase + ATAO_2_INT1CLR_REG);\r\noutw(0, dev->iobase + ATAO_2_INT2CLR_REG);\r\noutw(0, dev->iobase + ATAO_2_DMATCCLR_REG);\r\natao_select_reg_group(dev, 0);\r\n}\r\nstatic int atao_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nconst struct atao_board *board = comedi_board(dev);\r\nstruct atao_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nret = comedi_request_region(dev, it->options[0], 0x20);\r\nif (ret)\r\nreturn ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = board->n_ao_chans;\r\ns->maxdata = 0x0fff;\r\ns->range_table = it->options[3] ? &range_unipolar10 : &range_bipolar10;\r\ns->insn_write = atao_ao_insn_write;\r\ns->insn_read = atao_ao_insn_read;\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = atao_dio_insn_bits;\r\ns->insn_config = atao_dio_insn_config;\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_CALIB;\r\ns->subdev_flags = SDF_WRITABLE | SDF_INTERNAL;\r\ns->n_chan = (board->n_ao_chans * 2) + 1;\r\ns->maxdata = 0xff;\r\ns->insn_read = atao_calib_insn_read;\r\ns->insn_write = atao_calib_insn_write;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_UNUSED;\r\natao_reset(dev);\r\nreturn 0;\r\n}
