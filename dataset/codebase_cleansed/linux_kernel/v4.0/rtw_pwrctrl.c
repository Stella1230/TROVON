static int rtw_hw_suspend(struct adapter *padapter)\r\n{\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\nstruct net_device *pnetdev = padapter->pnetdev;\r\nif ((!padapter->bup) || (padapter->bDriverStopped) ||\r\n(padapter->bSurpriseRemoved)) {\r\nDBG_88E("padapter->bup=%d bDriverStopped=%d bSurpriseRemoved = %d\n",\r\npadapter->bup, padapter->bDriverStopped,\r\npadapter->bSurpriseRemoved);\r\ngoto error_exit;\r\n}\r\nLeaveAllPowerSaveMode(padapter);\r\nDBG_88E("==> rtw_hw_suspend\n");\r\n_enter_pwrlock(&pwrpriv->lock);\r\npwrpriv->bips_processing = true;\r\nif (pnetdev) {\r\nnetif_carrier_off(pnetdev);\r\nnetif_tx_stop_all_queues(pnetdev);\r\n}\r\nrtw_disassoc_cmd(padapter, 500, false);\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED)) {\r\n_clr_fwstate_(pmlmepriv, _FW_LINKED);\r\nrtw_led_control(padapter, LED_CTL_NO_LINK);\r\nrtw_os_indicate_disconnect(padapter);\r\nrtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_DISCONNECT, 0);\r\n}\r\n}\r\nrtw_free_assoc_resources(padapter, 1);\r\nrtw_free_network_queue(padapter, true);\r\nrtw_ips_dev_unload(padapter);\r\npwrpriv->rf_pwrstate = rf_off;\r\npwrpriv->bips_processing = false;\r\n_exit_pwrlock(&pwrpriv->lock);\r\nreturn 0;\r\nerror_exit:\r\nDBG_88E("%s, failed\n", __func__);\r\nreturn -1;\r\n}\r\nstatic int rtw_hw_resume(struct adapter *padapter)\r\n{\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\nstruct net_device *pnetdev = padapter->pnetdev;\r\nDBG_88E("==> rtw_hw_resume\n");\r\n_enter_pwrlock(&pwrpriv->lock);\r\npwrpriv->bips_processing = true;\r\nrtw_reset_drv_sw(padapter);\r\nif (pm_netdev_open(pnetdev, false) != 0) {\r\n_exit_pwrlock(&pwrpriv->lock);\r\ngoto error_exit;\r\n}\r\nnetif_device_attach(pnetdev);\r\nnetif_carrier_on(pnetdev);\r\nif (!netif_queue_stopped(pnetdev))\r\nnetif_start_queue(pnetdev);\r\nelse\r\nnetif_wake_queue(pnetdev);\r\npwrpriv->bkeepfwalive = false;\r\npwrpriv->brfoffbyhw = false;\r\npwrpriv->rf_pwrstate = rf_on;\r\npwrpriv->bips_processing = false;\r\n_exit_pwrlock(&pwrpriv->lock);\r\nreturn 0;\r\nerror_exit:\r\nDBG_88E("%s, Open net dev failed\n", __func__);\r\nreturn -1;\r\n}\r\nvoid ips_enter(struct adapter *padapter)\r\n{\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\nstruct xmit_priv *pxmit_priv = &padapter->xmitpriv;\r\nif (padapter->registrypriv.mp_mode == 1)\r\nreturn;\r\nif (pxmit_priv->free_xmitbuf_cnt != NR_XMITBUFF ||\r\npxmit_priv->free_xmit_extbuf_cnt != NR_XMIT_EXTBUFF) {\r\nDBG_88E_LEVEL(_drv_info_, "There are some pkts to transmit\n");\r\nDBG_88E_LEVEL(_drv_info_, "free_xmitbuf_cnt: %d, free_xmit_extbuf_cnt: %d\n",\r\npxmit_priv->free_xmitbuf_cnt, pxmit_priv->free_xmit_extbuf_cnt);\r\nreturn;\r\n}\r\n_enter_pwrlock(&pwrpriv->lock);\r\npwrpriv->bips_processing = true;\r\npwrpriv->ips_mode = pwrpriv->ips_mode_req;\r\npwrpriv->ips_enter_cnts++;\r\nDBG_88E("==>ips_enter cnts:%d\n", pwrpriv->ips_enter_cnts);\r\nif (rf_off == pwrpriv->change_rfpwrstate) {\r\npwrpriv->bpower_saving = true;\r\nDBG_88E_LEVEL(_drv_info_, "nolinked power save enter\n");\r\nif (pwrpriv->ips_mode == IPS_LEVEL_2)\r\npwrpriv->bkeepfwalive = true;\r\nrtw_ips_pwr_down(padapter);\r\npwrpriv->rf_pwrstate = rf_off;\r\n}\r\npwrpriv->bips_processing = false;\r\n_exit_pwrlock(&pwrpriv->lock);\r\n}\r\nint ips_leave(struct adapter *padapter)\r\n{\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\nstruct security_priv *psecuritypriv = &(padapter->securitypriv);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nint result = _SUCCESS;\r\nint keyid;\r\n_enter_pwrlock(&pwrpriv->lock);\r\nif ((pwrpriv->rf_pwrstate == rf_off) && (!pwrpriv->bips_processing)) {\r\npwrpriv->bips_processing = true;\r\npwrpriv->change_rfpwrstate = rf_on;\r\npwrpriv->ips_leave_cnts++;\r\nDBG_88E("==>ips_leave cnts:%d\n", pwrpriv->ips_leave_cnts);\r\nresult = rtw_ips_pwr_up(padapter);\r\nif (result == _SUCCESS) {\r\npwrpriv->rf_pwrstate = rf_on;\r\n}\r\nDBG_88E_LEVEL(_drv_info_, "nolinked power save leave\n");\r\nif ((_WEP40_ == psecuritypriv->dot11PrivacyAlgrthm) || (_WEP104_ == psecuritypriv->dot11PrivacyAlgrthm)) {\r\nDBG_88E("==>%s, channel(%d), processing(%x)\n", __func__, padapter->mlmeextpriv.cur_channel, pwrpriv->bips_processing);\r\nset_channel_bwmode(padapter, padapter->mlmeextpriv.cur_channel, HAL_PRIME_CHNL_OFFSET_DONT_CARE, HT_CHANNEL_WIDTH_20);\r\nfor (keyid = 0; keyid < 4; keyid++) {\r\nif (pmlmepriv->key_mask & BIT(keyid)) {\r\nif (keyid == psecuritypriv->dot11PrivacyKeyIndex)\r\nresult = rtw_set_key(padapter, psecuritypriv, keyid, 1);\r\nelse\r\nresult = rtw_set_key(padapter, psecuritypriv, keyid, 0);\r\n}\r\n}\r\n}\r\nDBG_88E("==> ips_leave.....LED(0x%08x)...\n", usb_read32(padapter, 0x4c));\r\npwrpriv->bips_processing = false;\r\npwrpriv->bkeepfwalive = false;\r\npwrpriv->bpower_saving = false;\r\n}\r\n_exit_pwrlock(&pwrpriv->lock);\r\nreturn result;\r\n}\r\nstatic bool rtw_pwr_unassociated_idle(struct adapter *adapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\r\nbool ret = false;\r\nif (time_after_eq(adapter->pwrctrlpriv.ips_deny_time, jiffies))\r\ngoto exit;\r\nif (check_fwstate(pmlmepriv, WIFI_ASOC_STATE|WIFI_SITE_MONITOR) ||\r\ncheck_fwstate(pmlmepriv, WIFI_UNDER_LINKING|WIFI_UNDER_WPS) ||\r\ncheck_fwstate(pmlmepriv, WIFI_AP_STATE) ||\r\ncheck_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE|WIFI_ADHOC_STATE))\r\ngoto exit;\r\nret = true;\r\nexit:\r\nreturn ret;\r\n}\r\nvoid rtw_ps_processor(struct adapter *padapter)\r\n{\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nenum rt_rf_power_state rfpwrstate;\r\npwrpriv->ps_processing = true;\r\nif (pwrpriv->bips_processing)\r\ngoto exit;\r\nif (padapter->pwrctrlpriv.bHWPwrPindetect) {\r\nrfpwrstate = RfOnOffDetect(padapter);\r\nDBG_88E("@@@@- #2 %s==> rfstate:%s\n", __func__, (rfpwrstate == rf_on) ? "rf_on" : "rf_off");\r\nif (rfpwrstate != pwrpriv->rf_pwrstate) {\r\nif (rfpwrstate == rf_off) {\r\npwrpriv->change_rfpwrstate = rf_off;\r\npwrpriv->brfoffbyhw = true;\r\nrtw_hw_suspend(padapter);\r\n} else {\r\npwrpriv->change_rfpwrstate = rf_on;\r\nrtw_hw_resume(padapter);\r\n}\r\nDBG_88E("current rf_pwrstate(%s)\n", (pwrpriv->rf_pwrstate == rf_off) ? "rf_off" : "rf_on");\r\n}\r\npwrpriv->pwr_state_check_cnts++;\r\n}\r\nif (pwrpriv->ips_mode_req == IPS_NONE)\r\ngoto exit;\r\nif (!rtw_pwr_unassociated_idle(padapter))\r\ngoto exit;\r\nif ((pwrpriv->rf_pwrstate == rf_on) && ((pwrpriv->pwr_state_check_cnts%4) == 0)) {\r\nDBG_88E("==>%s .fw_state(%x)\n", __func__, get_fwstate(pmlmepriv));\r\npwrpriv->change_rfpwrstate = rf_off;\r\nips_enter(padapter);\r\n}\r\nexit:\r\nrtw_set_pwr_state_check_timer(&padapter->pwrctrlpriv);\r\npwrpriv->ps_processing = false;\r\n}\r\nstatic void pwr_state_check_handler(void *FunctionContext)\r\n{\r\nstruct adapter *padapter = FunctionContext;\r\nrtw_ps_cmd(padapter);\r\n}\r\nvoid rtw_set_rpwm(struct adapter *padapter, u8 pslv)\r\n{\r\nu8 rpwm;\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\npslv = PS_STATE(pslv);\r\nif (pwrpriv->btcoex_rfon) {\r\nif (pslv < PS_STATE_S4)\r\npslv = PS_STATE_S3;\r\n}\r\nif ((pwrpriv->rpwm == pslv)) {\r\nRT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_err_,\r\n("%s: Already set rpwm[0x%02X], new=0x%02X!\n", __func__, pwrpriv->rpwm, pslv));\r\nreturn;\r\n}\r\nif ((padapter->bSurpriseRemoved) ||\r\n(!padapter->hw_init_completed)) {\r\nRT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_err_,\r\n("%s: SurpriseRemoved(%d) hw_init_completed(%d)\n",\r\n__func__, padapter->bSurpriseRemoved, padapter->hw_init_completed));\r\npwrpriv->cpwm = PS_STATE_S4;\r\nreturn;\r\n}\r\nif (padapter->bDriverStopped) {\r\nRT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_err_,\r\n("%s: change power state(0x%02X) when DriverStopped\n", __func__, pslv));\r\nif (pslv < PS_STATE_S2) {\r\nRT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_err_,\r\n("%s: Reject to enter PS_STATE(0x%02X) lower than S2 when DriverStopped!!\n", __func__, pslv));\r\nreturn;\r\n}\r\n}\r\nrpwm = pslv | pwrpriv->tog;\r\nRT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,\r\n("rtw_set_rpwm: rpwm=0x%02x cpwm=0x%02x\n", rpwm, pwrpriv->cpwm));\r\npwrpriv->rpwm = pslv;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_SET_RPWM, (u8 *)(&rpwm));\r\npwrpriv->tog += 0x80;\r\npwrpriv->cpwm = pslv;\r\n}\r\nstatic u8 PS_RDY_CHECK(struct adapter *padapter)\r\n{\r\nu32 curr_time, delta_time;\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\ncurr_time = jiffies;\r\ndelta_time = curr_time - pwrpriv->DelayLPSLastTimeStamp;\r\nif (delta_time < LPS_DELAY_TIME)\r\nreturn false;\r\nif ((check_fwstate(pmlmepriv, _FW_LINKED) == false) ||\r\n(check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)) ||\r\n(check_fwstate(pmlmepriv, WIFI_AP_STATE)) ||\r\n(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) ||\r\n(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)))\r\nreturn false;\r\nif (pwrpriv->bInSuspend)\r\nreturn false;\r\nif ((padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) && (padapter->securitypriv.binstallGrpkey == false)) {\r\nDBG_88E("Group handshake still in progress !!!\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nvoid rtw_set_ps_mode(struct adapter *padapter, u8 ps_mode, u8 smart_ps, u8 bcn_ant_mode)\r\n{\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\nRT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_notice_,\r\n("%s: PowerMode=%d Smart_PS=%d\n",\r\n__func__, ps_mode, smart_ps));\r\nif (ps_mode > PM_Card_Disable) {\r\nRT_TRACE(_module_rtl871x_pwrctrl_c_, _drv_err_, ("ps_mode:%d error\n", ps_mode));\r\nreturn;\r\n}\r\nif (pwrpriv->pwr_mode == ps_mode) {\r\nif (PS_MODE_ACTIVE == ps_mode)\r\nreturn;\r\nif ((pwrpriv->smart_ps == smart_ps) &&\r\n(pwrpriv->bcn_ant_mode == bcn_ant_mode))\r\nreturn;\r\n}\r\nif (ps_mode == PS_MODE_ACTIVE) {\r\nif (PS_RDY_CHECK(padapter)) {\r\nDBG_88E("%s: Enter 802.11 power save\n", __func__);\r\npwrpriv->bFwCurrentInPSMode = true;\r\npwrpriv->pwr_mode = ps_mode;\r\npwrpriv->smart_ps = smart_ps;\r\npwrpriv->bcn_ant_mode = bcn_ant_mode;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_H2C_FW_PWRMODE, (u8 *)(&ps_mode));\r\nrtw_set_rpwm(padapter, PS_STATE_S2);\r\n}\r\n}\r\n}\r\ns32 LPS_RF_ON_check(struct adapter *padapter, u32 delay_ms)\r\n{\r\nu32 start_time;\r\nu8 bAwake = false;\r\ns32 err = 0;\r\nstart_time = jiffies;\r\nwhile (1) {\r\nrtw_hal_get_hwreg(padapter, HW_VAR_FWLPS_RF_ON, &bAwake);\r\nif (bAwake)\r\nbreak;\r\nif (padapter->bSurpriseRemoved) {\r\nerr = -2;\r\nDBG_88E("%s: device surprise removed!!\n", __func__);\r\nbreak;\r\n}\r\nif (rtw_get_passing_time_ms(start_time) > delay_ms) {\r\nerr = -1;\r\nDBG_88E("%s: Wait for FW LPS leave more than %u ms!!!\n", __func__, delay_ms);\r\nbreak;\r\n}\r\nmsleep(1);\r\n}\r\nreturn err;\r\n}\r\nvoid LPS_Enter(struct adapter *padapter)\r\n{\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\nif (PS_RDY_CHECK(padapter) == false)\r\nreturn;\r\nif (pwrpriv->bLeisurePs) {\r\nif (pwrpriv->LpsIdleCount >= 2) {\r\nif (pwrpriv->pwr_mode == PS_MODE_ACTIVE) {\r\npwrpriv->bpower_saving = true;\r\nDBG_88E("%s smart_ps:%d\n", __func__, pwrpriv->smart_ps);\r\nrtw_set_ps_mode(padapter, pwrpriv->power_mgnt, pwrpriv->smart_ps, 0);\r\n}\r\n} else {\r\npwrpriv->LpsIdleCount++;\r\n}\r\n}\r\n}\r\nvoid LPS_Leave(struct adapter *padapter)\r\n{\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\nif (pwrpriv->bLeisurePs) {\r\nif (pwrpriv->pwr_mode != PS_MODE_ACTIVE) {\r\nrtw_set_ps_mode(padapter, PS_MODE_ACTIVE, 0, 0);\r\nif (pwrpriv->pwr_mode == PS_MODE_ACTIVE)\r\nLPS_RF_ON_check(padapter, LPS_LEAVE_TIMEOUT_MS);\r\n}\r\n}\r\npwrpriv->bpower_saving = false;\r\n}\r\nvoid LeaveAllPowerSaveMode(struct adapter *Adapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &(Adapter->mlmepriv);\r\nu8 enqueue = 0;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED))\r\nrtw_lps_ctrl_wk_cmd(Adapter, LPS_CTRL_LEAVE, enqueue);\r\n}\r\nvoid rtw_init_pwrctrl_priv(struct adapter *padapter)\r\n{\r\nstruct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;\r\n_init_pwrlock(&pwrctrlpriv->lock);\r\npwrctrlpriv->rf_pwrstate = rf_on;\r\npwrctrlpriv->ips_enter_cnts = 0;\r\npwrctrlpriv->ips_leave_cnts = 0;\r\npwrctrlpriv->bips_processing = false;\r\npwrctrlpriv->ips_mode = padapter->registrypriv.ips_mode;\r\npwrctrlpriv->ips_mode_req = padapter->registrypriv.ips_mode;\r\npwrctrlpriv->pwr_state_check_interval = RTW_PWR_STATE_CHK_INTERVAL;\r\npwrctrlpriv->pwr_state_check_cnts = 0;\r\npwrctrlpriv->bInternalAutoSuspend = false;\r\npwrctrlpriv->bInSuspend = false;\r\npwrctrlpriv->bkeepfwalive = false;\r\npwrctrlpriv->LpsIdleCount = 0;\r\nif (padapter->registrypriv.mp_mode == 1)\r\npwrctrlpriv->power_mgnt = PS_MODE_ACTIVE;\r\nelse\r\npwrctrlpriv->power_mgnt = padapter->registrypriv.power_mgnt;\r\npwrctrlpriv->bLeisurePs = (PS_MODE_ACTIVE != pwrctrlpriv->power_mgnt) ? true : false;\r\npwrctrlpriv->bFwCurrentInPSMode = false;\r\npwrctrlpriv->rpwm = 0;\r\npwrctrlpriv->cpwm = PS_STATE_S4;\r\npwrctrlpriv->pwr_mode = PS_MODE_ACTIVE;\r\npwrctrlpriv->smart_ps = padapter->registrypriv.smart_ps;\r\npwrctrlpriv->bcn_ant_mode = 0;\r\npwrctrlpriv->tog = 0x80;\r\npwrctrlpriv->btcoex_rfon = false;\r\n_init_timer(&(pwrctrlpriv->pwr_state_check_timer), padapter->pnetdev, pwr_state_check_handler, (u8 *)padapter);\r\n}\r\ninline void rtw_set_ips_deny(struct adapter *padapter, u32 ms)\r\n{\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\npwrpriv->ips_deny_time = jiffies + msecs_to_jiffies(ms);\r\n}\r\nint _rtw_pwr_wakeup(struct adapter *padapter, u32 ips_deffer_ms, const char *caller)\r\n{\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nunsigned long expires;\r\nint ret = _SUCCESS;\r\nexpires = jiffies + msecs_to_jiffies(ips_deffer_ms);\r\nif (time_before(pwrpriv->ips_deny_time, expires))\r\npwrpriv->ips_deny_time = jiffies + msecs_to_jiffies(ips_deffer_ms);\r\n{\r\nu32 start = jiffies;\r\nif (pwrpriv->ps_processing) {\r\nDBG_88E("%s wait ps_processing...\n", __func__);\r\nwhile (pwrpriv->ps_processing && rtw_get_passing_time_ms(start) <= 3000)\r\nusleep_range(1000, 3000);\r\nif (pwrpriv->ps_processing)\r\nDBG_88E("%s wait ps_processing timeout\n", __func__);\r\nelse\r\nDBG_88E("%s wait ps_processing done\n", __func__);\r\n}\r\n}\r\nif ((!pwrpriv->bInternalAutoSuspend) && (pwrpriv->bInSuspend)) {\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nif ((pwrpriv->bInternalAutoSuspend) && (padapter->net_closed)) {\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nif (check_fwstate(pmlmepriv, _FW_LINKED)) {\r\nret = _SUCCESS;\r\ngoto exit;\r\n}\r\nif (rf_off == pwrpriv->rf_pwrstate) {\r\nDBG_88E("%s call ips_leave....\n", __func__);\r\nif (_FAIL == ips_leave(padapter)) {\r\nDBG_88E("======> ips_leave fail.............\n");\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\n}\r\nif (padapter->bDriverStopped || !padapter->bup ||\r\n!padapter->hw_init_completed) {\r\nDBG_88E("%s: bDriverStopped=%d, bup=%d, hw_init_completed =%u\n"\r\n, caller\r\n, padapter->bDriverStopped\r\n, padapter->bup\r\n, padapter->hw_init_completed);\r\nret = false;\r\ngoto exit;\r\n}\r\nexit:\r\nexpires = jiffies + msecs_to_jiffies(ips_deffer_ms);\r\nif (time_before(pwrpriv->ips_deny_time, expires))\r\npwrpriv->ips_deny_time = jiffies + msecs_to_jiffies(ips_deffer_ms);\r\nreturn ret;\r\n}\r\nint rtw_pm_set_lps(struct adapter *padapter, u8 mode)\r\n{\r\nint ret = 0;\r\nstruct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;\r\nif (mode < PS_MODE_NUM) {\r\nif (pwrctrlpriv->power_mgnt != mode) {\r\nif (PS_MODE_ACTIVE == mode)\r\nLeaveAllPowerSaveMode(padapter);\r\nelse\r\npwrctrlpriv->LpsIdleCount = 2;\r\npwrctrlpriv->power_mgnt = mode;\r\npwrctrlpriv->bLeisurePs = (PS_MODE_ACTIVE != pwrctrlpriv->power_mgnt) ? true : false;\r\n}\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nint rtw_pm_set_ips(struct adapter *padapter, u8 mode)\r\n{\r\nstruct pwrctrl_priv *pwrctrlpriv = &padapter->pwrctrlpriv;\r\nif (mode == IPS_NORMAL || mode == IPS_LEVEL_2) {\r\nrtw_ips_mode_req(pwrctrlpriv, mode);\r\nDBG_88E("%s %s\n", __func__, mode == IPS_NORMAL ? "IPS_NORMAL" : "IPS_LEVEL_2");\r\nreturn 0;\r\n} else if (mode == IPS_NONE) {\r\nrtw_ips_mode_req(pwrctrlpriv, mode);\r\nDBG_88E("%s %s\n", __func__, "IPS_NONE");\r\nif ((padapter->bSurpriseRemoved == 0) && (_FAIL == rtw_pwr_wakeup(padapter)))\r\nreturn -EFAULT;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}
