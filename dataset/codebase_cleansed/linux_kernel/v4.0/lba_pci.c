static void\r\nlba_dump_res(struct resource *r, int d)\r\n{\r\nint i;\r\nif (NULL == r)\r\nreturn;\r\nprintk(KERN_DEBUG "(%p)", r->parent);\r\nfor (i = d; i ; --i) printk(" ");\r\nprintk(KERN_DEBUG "%p [%lx,%lx]/%lx\n", r,\r\n(long)r->start, (long)r->end, r->flags);\r\nlba_dump_res(r->child, d+2);\r\nlba_dump_res(r->sibling, d);\r\n}\r\nstatic int lba_device_present(u8 bus, u8 dfn, struct lba_device *d)\r\n{\r\nu8 first_bus = d->hba.hba_bus->busn_res.start;\r\nu8 last_sub_bus = d->hba.hba_bus->busn_res.end;\r\nif ((bus < first_bus) ||\r\n(bus > last_sub_bus) ||\r\n((bus - first_bus) >= LBA_MAX_NUM_BUSES)) {\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic unsigned int\r\nlba_rd_cfg(struct lba_device *d, u32 tok, u8 reg, u32 size)\r\n{\r\nu32 data = ~0U;\r\nint error = 0;\r\nu32 arb_mask = 0;\r\nu32 error_config = 0;\r\nu32 status_control = 0;\r\nLBA_CFG_SETUP(d, tok);\r\nLBA_CFG_PROBE(d, tok);\r\nLBA_CFG_MASTER_ABORT_CHECK(d, d->hba.base_addr, tok, error);\r\nif (!error) {\r\nvoid __iomem *data_reg = d->hba.base_addr + LBA_PCI_CFG_DATA;\r\nLBA_CFG_ADDR_SETUP(d, tok | reg);\r\nswitch (size) {\r\ncase 1: data = (u32) READ_REG8(data_reg + (reg & 3)); break;\r\ncase 2: data = (u32) READ_REG16(data_reg+ (reg & 2)); break;\r\ncase 4: data = READ_REG32(data_reg); break;\r\n}\r\n}\r\nLBA_CFG_RESTORE(d, d->hba.base_addr);\r\nreturn(data);\r\n}\r\nstatic int elroy_cfg_read(struct pci_bus *bus, unsigned int devfn, int pos, int size, u32 *data)\r\n{\r\nstruct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));\r\nu32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;\r\nu32 tok = LBA_CFG_TOK(local_bus, devfn);\r\nvoid __iomem *data_reg = d->hba.base_addr + LBA_PCI_CFG_DATA;\r\nif ((pos > 255) || (devfn > 255))\r\nreturn -EINVAL;\r\n{\r\n*data = lba_rd_cfg(d, tok, pos, size);\r\nDBG_CFG("%s(%x+%2x) -> 0x%x (a)\n", __func__, tok, pos, *data);\r\nreturn 0;\r\n}\r\nif (LBA_SKIP_PROBE(d) && !lba_device_present(bus->busn_res.start, devfn, d)) {\r\nDBG_CFG("%s(%x+%2x) -> -1 (b)\n", __func__, tok, pos);\r\n*data = ~0U;\r\nreturn(0);\r\n}\r\nLBA_CFG_ADDR_SETUP(d, tok | pos);\r\nswitch(size) {\r\ncase 1: *data = READ_REG8 (data_reg + (pos & 3)); break;\r\ncase 2: *data = READ_REG16(data_reg + (pos & 2)); break;\r\ncase 4: *data = READ_REG32(data_reg); break;\r\n}\r\nDBG_CFG("%s(%x+%2x) -> 0x%x (c)\n", __func__, tok, pos, *data);\r\nreturn 0;\r\n}\r\nstatic void\r\nlba_wr_cfg(struct lba_device *d, u32 tok, u8 reg, u32 data, u32 size)\r\n{\r\nint error = 0;\r\nu32 arb_mask = 0;\r\nu32 error_config = 0;\r\nu32 status_control = 0;\r\nvoid __iomem *data_reg = d->hba.base_addr + LBA_PCI_CFG_DATA;\r\nLBA_CFG_SETUP(d, tok);\r\nLBA_CFG_ADDR_SETUP(d, tok | reg);\r\nswitch (size) {\r\ncase 1: WRITE_REG8 (data, data_reg + (reg & 3)); break;\r\ncase 2: WRITE_REG16(data, data_reg + (reg & 2)); break;\r\ncase 4: WRITE_REG32(data, data_reg); break;\r\n}\r\nLBA_CFG_MASTER_ABORT_CHECK(d, d->hba.base_addr, tok, error);\r\nLBA_CFG_RESTORE(d, d->hba.base_addr);\r\n}\r\nstatic int elroy_cfg_write(struct pci_bus *bus, unsigned int devfn, int pos, int size, u32 data)\r\n{\r\nstruct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));\r\nu32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;\r\nu32 tok = LBA_CFG_TOK(local_bus,devfn);\r\nif ((pos > 255) || (devfn > 255))\r\nreturn -EINVAL;\r\nif (!LBA_SKIP_PROBE(d)) {\r\nlba_wr_cfg(d, tok, pos, (u32) data, size);\r\nDBG_CFG("%s(%x+%2x) = 0x%x (a)\n", __func__, tok, pos,data);\r\nreturn 0;\r\n}\r\nif (LBA_SKIP_PROBE(d) && (!lba_device_present(bus->busn_res.start, devfn, d))) {\r\nDBG_CFG("%s(%x+%2x) = 0x%x (b)\n", __func__, tok, pos,data);\r\nreturn 1;\r\n}\r\nDBG_CFG("%s(%x+%2x) = 0x%x (c)\n", __func__, tok, pos, data);\r\nLBA_CFG_ADDR_SETUP(d, tok | pos);\r\nswitch(size) {\r\ncase 1: WRITE_REG8 (data, d->hba.base_addr + LBA_PCI_CFG_DATA + (pos & 3));\r\nbreak;\r\ncase 2: WRITE_REG16(data, d->hba.base_addr + LBA_PCI_CFG_DATA + (pos & 2));\r\nbreak;\r\ncase 4: WRITE_REG32(data, d->hba.base_addr + LBA_PCI_CFG_DATA);\r\nbreak;\r\n}\r\nlba_t32 = READ_REG32(d->hba.base_addr + LBA_PCI_CFG_ADDR);\r\nreturn 0;\r\n}\r\nstatic int mercury_cfg_read(struct pci_bus *bus, unsigned int devfn, int pos, int size, u32 *data)\r\n{\r\nstruct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));\r\nu32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;\r\nu32 tok = LBA_CFG_TOK(local_bus, devfn);\r\nvoid __iomem *data_reg = d->hba.base_addr + LBA_PCI_CFG_DATA;\r\nif ((pos > 255) || (devfn > 255))\r\nreturn -EINVAL;\r\nLBA_CFG_TR4_ADDR_SETUP(d, tok | pos);\r\nswitch(size) {\r\ncase 1:\r\n*data = READ_REG8(data_reg + (pos & 3));\r\nbreak;\r\ncase 2:\r\n*data = READ_REG16(data_reg + (pos & 2));\r\nbreak;\r\ncase 4:\r\n*data = READ_REG32(data_reg); break;\r\nbreak;\r\n}\r\nDBG_CFG("mercury_cfg_read(%x+%2x) -> 0x%x\n", tok, pos, *data);\r\nreturn 0;\r\n}\r\nstatic int mercury_cfg_write(struct pci_bus *bus, unsigned int devfn, int pos, int size, u32 data)\r\n{\r\nstruct lba_device *d = LBA_DEV(parisc_walk_tree(bus->bridge));\r\nvoid __iomem *data_reg = d->hba.base_addr + LBA_PCI_CFG_DATA;\r\nu32 local_bus = (bus->parent == NULL) ? 0 : bus->busn_res.start;\r\nu32 tok = LBA_CFG_TOK(local_bus,devfn);\r\nif ((pos > 255) || (devfn > 255))\r\nreturn -EINVAL;\r\nDBG_CFG("%s(%x+%2x) <- 0x%x (c)\n", __func__, tok, pos, data);\r\nLBA_CFG_TR4_ADDR_SETUP(d, tok | pos);\r\nswitch(size) {\r\ncase 1:\r\nWRITE_REG8 (data, data_reg + (pos & 3));\r\nbreak;\r\ncase 2:\r\nWRITE_REG16(data, data_reg + (pos & 2));\r\nbreak;\r\ncase 4:\r\nWRITE_REG32(data, data_reg);\r\nbreak;\r\n}\r\nlba_t32 = READ_U32(d->hba.base_addr + LBA_PCI_CFG_ADDR);\r\nreturn 0;\r\n}\r\nstatic void\r\nlba_bios_init(void)\r\n{\r\nDBG(MODULE_NAME ": lba_bios_init\n");\r\n}\r\nstatic unsigned long\r\ntruncate_pat_collision(struct resource *root, struct resource *new)\r\n{\r\nunsigned long start = new->start;\r\nunsigned long end = new->end;\r\nstruct resource *tmp = root->child;\r\nif (end <= start || start < root->start || !tmp)\r\nreturn 0;\r\nwhile (tmp && tmp->end < start)\r\ntmp = tmp->sibling;\r\nif (!tmp) return 0;\r\nif (tmp->start >= end) return 0;\r\nif (tmp->start <= start) {\r\nnew->start = tmp->end + 1;\r\nif (tmp->end >= end) {\r\nreturn 1;\r\n}\r\n}\r\nif (tmp->end < end ) {\r\nnew->end = tmp->start - 1;\r\n}\r\nprintk(KERN_WARNING "LBA: Truncating lmmio_space [%lx/%lx] "\r\n"to [%lx,%lx]\n",\r\nstart, end,\r\n(long)new->start, (long)new->end );\r\nreturn 0;\r\n}\r\nstatic unsigned long\r\nextend_lmmio_len(unsigned long start, unsigned long end, unsigned long lba_len)\r\n{\r\nstruct resource *tmp;\r\npr_debug("LMMIO mismatch: PAT length = 0x%lx, MASK register = 0x%lx\n",\r\nend - start, lba_len);\r\nlba_len = min(lba_len+1, 256UL*1024*1024);\r\npr_debug("LBA: lmmio_space [0x%lx-0x%lx] - original\n", start, end);\r\nif (boot_cpu_data.cpu_type < mako) {\r\npr_info("LBA: Not a C8000 system - not extending LMMIO range.\n");\r\nreturn end;\r\n}\r\nend += lba_len;\r\nif (end < start)\r\nend = -1ULL;\r\npr_debug("LBA: lmmio_space [0x%lx-0x%lx] - current\n", start, end);\r\nfor (tmp = iomem_resource.child; tmp; tmp = tmp->sibling) {\r\npr_debug("LBA: testing %pR\n", tmp);\r\nif (tmp->start == start)\r\ncontinue;\r\nif (tmp->end < start)\r\ncontinue;\r\nif (tmp->start > end)\r\ncontinue;\r\nif (end >= tmp->start)\r\nend = tmp->start - 1;\r\n}\r\npr_info("LBA: lmmio_space [0x%lx-0x%lx] - new\n", start, end);\r\nreturn end;\r\n}\r\nstatic void\r\nlba_fixup_bus(struct pci_bus *bus)\r\n{\r\nstruct pci_dev *dev;\r\n#ifdef FBB_SUPPORT\r\nu16 status;\r\n#endif\r\nstruct lba_device *ldev = LBA_DEV(parisc_walk_tree(bus->bridge));\r\nDBG("lba_fixup_bus(0x%p) bus %d platform_data 0x%p\n",\r\nbus, (int)bus->busn_res.start, bus->bridge->platform_data);\r\nif (bus->parent) {\r\nint i;\r\npci_read_bridge_bases(bus);\r\nfor (i = PCI_BRIDGE_RESOURCES; i < PCI_NUM_RESOURCES; i++)\r\npci_claim_bridge_resource(bus->self, i);\r\n} else {\r\nint err;\r\nDBG("lba_fixup_bus() %s [%lx/%lx]/%lx\n",\r\nldev->hba.io_space.name,\r\nldev->hba.io_space.start, ldev->hba.io_space.end,\r\nldev->hba.io_space.flags);\r\nDBG("lba_fixup_bus() %s [%lx/%lx]/%lx\n",\r\nldev->hba.lmmio_space.name,\r\nldev->hba.lmmio_space.start, ldev->hba.lmmio_space.end,\r\nldev->hba.lmmio_space.flags);\r\nerr = request_resource(&ioport_resource, &(ldev->hba.io_space));\r\nif (err < 0) {\r\nlba_dump_res(&ioport_resource, 2);\r\nBUG();\r\n}\r\nif (ldev->hba.elmmio_space.flags) {\r\nerr = request_resource(&iomem_resource,\r\n&(ldev->hba.elmmio_space));\r\nif (err < 0) {\r\nprintk("FAILED: lba_fixup_bus() request for "\r\n"elmmio_space [%lx/%lx]\n",\r\n(long)ldev->hba.elmmio_space.start,\r\n(long)ldev->hba.elmmio_space.end);\r\n}\r\n}\r\nif (ldev->hba.lmmio_space.flags) {\r\nerr = request_resource(&iomem_resource, &(ldev->hba.lmmio_space));\r\nif (err < 0) {\r\nprintk(KERN_ERR "FAILED: lba_fixup_bus() request for "\r\n"lmmio_space [%lx/%lx]\n",\r\n(long)ldev->hba.lmmio_space.start,\r\n(long)ldev->hba.lmmio_space.end);\r\n}\r\n}\r\n#ifdef CONFIG_64BIT\r\nif (ldev->hba.gmmio_space.flags) {\r\nerr = request_resource(&iomem_resource, &(ldev->hba.gmmio_space));\r\nif (err < 0) {\r\nprintk("FAILED: lba_fixup_bus() request for "\r\n"gmmio_space [%lx/%lx]\n",\r\n(long)ldev->hba.gmmio_space.start,\r\n(long)ldev->hba.gmmio_space.end);\r\nlba_dump_res(&iomem_resource, 2);\r\nBUG();\r\n}\r\n}\r\n#endif\r\n}\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nint i;\r\nDBG("lba_fixup_bus() %s\n", pci_name(dev));\r\nfor (i = 0; i < PCI_BRIDGE_RESOURCES; i++) {\r\nstruct resource *res = &dev->resource[i];\r\nif (!res->start)\r\ncontinue;\r\npci_claim_resource(dev, i);\r\n}\r\n#ifdef FBB_SUPPORT\r\n(void) pci_read_config_word(dev, PCI_STATUS, &status);\r\nbus->bridge_ctl &= ~(status & PCI_STATUS_FAST_BACK);\r\n#endif\r\nif ((dev->class >> 8) == PCI_CLASS_BRIDGE_PCI)\r\ncontinue;\r\niosapic_fixup_irq(ldev->iosapic_obj, dev);\r\n}\r\n#ifdef FBB_SUPPORT\r\nif (fbb_enable) {\r\nif (bus->parent) {\r\nu8 control;\r\n(void) pci_read_config_byte(bus->self, PCI_BRIDGE_CONTROL, &control);\r\n(void) pci_write_config_byte(bus->self, PCI_BRIDGE_CONTROL, control | PCI_STATUS_FAST_BACK);\r\n} else {\r\n}\r\nfbb_enable = PCI_COMMAND_FAST_BACK;\r\n}\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\n(void) pci_read_config_word(dev, PCI_COMMAND, &status);\r\nstatus |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR | fbb_enable;\r\n(void) pci_write_config_word(dev, PCI_COMMAND, status);\r\n}\r\n#endif\r\n}\r\nstatic void\r\nlba_pat_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)\r\n{\r\nunsigned long bytecnt;\r\nlong io_count;\r\nlong status;\r\nlong pa_count;\r\npdc_pat_cell_mod_maddr_block_t *pa_pdc_cell;\r\npdc_pat_cell_mod_maddr_block_t *io_pdc_cell;\r\nint i;\r\npa_pdc_cell = kzalloc(sizeof(pdc_pat_cell_mod_maddr_block_t), GFP_KERNEL);\r\nif (!pa_pdc_cell)\r\nreturn;\r\nio_pdc_cell = kzalloc(sizeof(pdc_pat_cell_mod_maddr_block_t), GFP_KERNEL);\r\nif (!io_pdc_cell) {\r\nkfree(pa_pdc_cell);\r\nreturn;\r\n}\r\nstatus = pdc_pat_cell_module(&bytecnt, pa_dev->pcell_loc, pa_dev->mod_index,\r\nPA_VIEW, pa_pdc_cell);\r\npa_count = pa_pdc_cell->mod[1];\r\nstatus |= pdc_pat_cell_module(&bytecnt, pa_dev->pcell_loc, pa_dev->mod_index,\r\nIO_VIEW, io_pdc_cell);\r\nio_count = io_pdc_cell->mod[1];\r\nif (status != PDC_OK) {\r\npanic("pdc_pat_cell_module() call failed for LBA!\n");\r\n}\r\nif (PAT_GET_ENTITY(pa_pdc_cell->mod_info) != PAT_ENTITY_LBA) {\r\npanic("pdc_pat_cell_module() entity returned != PAT_ENTITY_LBA!\n");\r\n}\r\nfor (i = 0; i < pa_count; i++) {\r\nstruct {\r\nunsigned long type;\r\nunsigned long start;\r\nunsigned long end;\r\n} *p, *io;\r\nstruct resource *r;\r\np = (void *) &(pa_pdc_cell->mod[2+i*3]);\r\nio = (void *) &(io_pdc_cell->mod[2+i*3]);\r\nswitch(p->type & 0xff) {\r\ncase PAT_PBNUM:\r\nlba_dev->hba.bus_num.start = p->start;\r\nlba_dev->hba.bus_num.end = p->end;\r\nlba_dev->hba.bus_num.flags = IORESOURCE_BUS;\r\nbreak;\r\ncase PAT_LMMIO:\r\nif (!lba_dev->hba.lmmio_space.flags) {\r\nunsigned long lba_len;\r\nlba_len = ~READ_REG32(lba_dev->hba.base_addr\r\n+ LBA_LMMIO_MASK);\r\nif ((p->end - p->start) != lba_len)\r\np->end = extend_lmmio_len(p->start,\r\np->end, lba_len);\r\nsprintf(lba_dev->hba.lmmio_name,\r\n"PCI%02x LMMIO",\r\n(int)lba_dev->hba.bus_num.start);\r\nlba_dev->hba.lmmio_space_offset = p->start -\r\nio->start;\r\nr = &lba_dev->hba.lmmio_space;\r\nr->name = lba_dev->hba.lmmio_name;\r\n} else if (!lba_dev->hba.elmmio_space.flags) {\r\nsprintf(lba_dev->hba.elmmio_name,\r\n"PCI%02x ELMMIO",\r\n(int)lba_dev->hba.bus_num.start);\r\nr = &lba_dev->hba.elmmio_space;\r\nr->name = lba_dev->hba.elmmio_name;\r\n} else {\r\nprintk(KERN_WARNING MODULE_NAME\r\n" only supports 2 LMMIO resources!\n");\r\nbreak;\r\n}\r\nr->start = p->start;\r\nr->end = p->end;\r\nr->flags = IORESOURCE_MEM;\r\nr->parent = r->sibling = r->child = NULL;\r\nbreak;\r\ncase PAT_GMMIO:\r\nsprintf(lba_dev->hba.gmmio_name, "PCI%02x GMMIO",\r\n(int)lba_dev->hba.bus_num.start);\r\nr = &lba_dev->hba.gmmio_space;\r\nr->name = lba_dev->hba.gmmio_name;\r\nr->start = p->start;\r\nr->end = p->end;\r\nr->flags = IORESOURCE_MEM;\r\nr->parent = r->sibling = r->child = NULL;\r\nbreak;\r\ncase PAT_NPIOP:\r\nprintk(KERN_WARNING MODULE_NAME\r\n" range[%d] : ignoring NPIOP (0x%lx)\n",\r\ni, p->start);\r\nbreak;\r\ncase PAT_PIOP:\r\nlba_dev->iop_base = ioremap_nocache(p->start, 64 * 1024 * 1024);\r\nsprintf(lba_dev->hba.io_name, "PCI%02x Ports",\r\n(int)lba_dev->hba.bus_num.start);\r\nr = &lba_dev->hba.io_space;\r\nr->name = lba_dev->hba.io_name;\r\nr->start = HBA_PORT_BASE(lba_dev->hba.hba_num);\r\nr->end = r->start + HBA_PORT_SPACE_SIZE - 1;\r\nr->flags = IORESOURCE_IO;\r\nr->parent = r->sibling = r->child = NULL;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING MODULE_NAME\r\n" range[%d] : unknown pat range type (0x%lx)\n",\r\ni, p->type & 0xff);\r\nbreak;\r\n}\r\n}\r\nkfree(pa_pdc_cell);\r\nkfree(io_pdc_cell);\r\n}\r\nstatic void\r\nlba_legacy_resources(struct parisc_device *pa_dev, struct lba_device *lba_dev)\r\n{\r\nstruct resource *r;\r\nint lba_num;\r\nlba_dev->hba.lmmio_space_offset = PCI_F_EXTEND;\r\nlba_num = READ_REG32(lba_dev->hba.base_addr + LBA_FW_SCRATCH);\r\nr = &(lba_dev->hba.bus_num);\r\nr->name = "LBA PCI Busses";\r\nr->start = lba_num & 0xff;\r\nr->end = (lba_num>>8) & 0xff;\r\nr->flags = IORESOURCE_BUS;\r\nr = &(lba_dev->hba.lmmio_space);\r\nsprintf(lba_dev->hba.lmmio_name, "PCI%02x LMMIO",\r\n(int)lba_dev->hba.bus_num.start);\r\nr->name = lba_dev->hba.lmmio_name;\r\n#if 1\r\nsba_distributed_lmmio(pa_dev, r);\r\n#else\r\nr->start = READ_REG32(lba_dev->hba.base_addr + LBA_LMMIO_BASE);\r\nif (r->start & 1) {\r\nunsigned long rsize;\r\nr->flags = IORESOURCE_MEM;\r\nr->start &= mmio_mask;\r\nr->start = PCI_HOST_ADDR(HBA_DATA(lba_dev), r->start);\r\nrsize = ~ READ_REG32(lba_dev->hba.base_addr + LBA_LMMIO_MASK);\r\nrsize /= ROPES_PER_IOC;\r\nr->start += (rsize + 1) * LBA_NUM(pa_dev->hpa.start);\r\nr->end = r->start + rsize;\r\n} else {\r\nr->end = r->start = 0;\r\n}\r\n#endif\r\nr = &(lba_dev->hba.elmmio_space);\r\nsprintf(lba_dev->hba.elmmio_name, "PCI%02x ELMMIO",\r\n(int)lba_dev->hba.bus_num.start);\r\nr->name = lba_dev->hba.elmmio_name;\r\n#if 1\r\nsba_directed_lmmio(pa_dev, r);\r\n#else\r\nr->start = READ_REG32(lba_dev->hba.base_addr + LBA_ELMMIO_BASE);\r\nif (r->start & 1) {\r\nunsigned long rsize;\r\nr->flags = IORESOURCE_MEM;\r\nr->start &= mmio_mask;\r\nr->start = PCI_HOST_ADDR(HBA_DATA(lba_dev), r->start);\r\nrsize = READ_REG32(lba_dev->hba.base_addr + LBA_ELMMIO_MASK);\r\nr->end = r->start + ~rsize;\r\n}\r\n#endif\r\nr = &(lba_dev->hba.io_space);\r\nsprintf(lba_dev->hba.io_name, "PCI%02x Ports",\r\n(int)lba_dev->hba.bus_num.start);\r\nr->name = lba_dev->hba.io_name;\r\nr->flags = IORESOURCE_IO;\r\nr->start = READ_REG32(lba_dev->hba.base_addr + LBA_IOS_BASE) & ~1L;\r\nr->end = r->start + (READ_REG32(lba_dev->hba.base_addr + LBA_IOS_MASK) ^ (HBA_PORT_SPACE_SIZE - 1));\r\nlba_num = HBA_PORT_BASE(lba_dev->hba.hba_num);\r\nr->start |= lba_num;\r\nr->end |= lba_num;\r\n}\r\nstatic int __init\r\nlba_hw_init(struct lba_device *d)\r\n{\r\nu32 stat;\r\nu32 bus_reset;\r\n#if 0\r\nprintk(KERN_DEBUG "LBA %lx STAT_CTL %Lx ERROR_CFG %Lx STATUS %Lx DMA_CTL %Lx\n",\r\nd->hba.base_addr,\r\nREAD_REG64(d->hba.base_addr + LBA_STAT_CTL),\r\nREAD_REG64(d->hba.base_addr + LBA_ERROR_CONFIG),\r\nREAD_REG64(d->hba.base_addr + LBA_ERROR_STATUS),\r\nREAD_REG64(d->hba.base_addr + LBA_DMA_CTL) );\r\nprintk(KERN_DEBUG " ARB mask %Lx pri %Lx mode %Lx mtlt %Lx\n",\r\nREAD_REG64(d->hba.base_addr + LBA_ARB_MASK),\r\nREAD_REG64(d->hba.base_addr + LBA_ARB_PRI),\r\nREAD_REG64(d->hba.base_addr + LBA_ARB_MODE),\r\nREAD_REG64(d->hba.base_addr + LBA_ARB_MTLT) );\r\nprintk(KERN_DEBUG " HINT cfg 0x%Lx\n",\r\nREAD_REG64(d->hba.base_addr + LBA_HINT_CFG));\r\nprintk(KERN_DEBUG " HINT reg ");\r\n{ int i;\r\nfor (i=LBA_HINT_BASE; i< (14*8 + LBA_HINT_BASE); i+=8)\r\nprintk(" %Lx", READ_REG64(d->hba.base_addr + i));\r\n}\r\nprintk("\n");\r\n#endif\r\n#ifdef CONFIG_64BIT\r\n#endif\r\nbus_reset = READ_REG32(d->hba.base_addr + LBA_STAT_CTL + 4) & 1;\r\nif (bus_reset) {\r\nprintk(KERN_DEBUG "NOTICE: PCI bus reset still asserted! (clearing)\n");\r\n}\r\nstat = READ_REG32(d->hba.base_addr + LBA_ERROR_CONFIG);\r\nif (stat & LBA_SMART_MODE) {\r\nprintk(KERN_DEBUG "NOTICE: LBA in SMART mode! (cleared)\n");\r\nstat &= ~LBA_SMART_MODE;\r\nWRITE_REG32(stat, d->hba.base_addr + LBA_ERROR_CONFIG);\r\n}\r\nstat = READ_REG32(d->hba.base_addr + LBA_STAT_CTL);\r\nWRITE_REG32(stat | HF_ENABLE, d->hba.base_addr + LBA_STAT_CTL);\r\nif (bus_reset)\r\nmdelay(pci_post_reset_delay);\r\nif (0 == READ_REG32(d->hba.base_addr + LBA_ARB_MASK)) {\r\nprintk(KERN_DEBUG "NOTICE: Enabling PCI Arbitration\n");\r\nWRITE_REG32(0x3, d->hba.base_addr + LBA_ARB_MASK);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init\r\nlba_driver_probe(struct parisc_device *dev)\r\n{\r\nstruct lba_device *lba_dev;\r\nLIST_HEAD(resources);\r\nstruct pci_bus *lba_bus;\r\nstruct pci_ops *cfg_ops;\r\nu32 func_class;\r\nvoid *tmp_obj;\r\nchar *version;\r\nvoid __iomem *addr = ioremap_nocache(dev->hpa.start, 4096);\r\nint max;\r\nfunc_class = READ_REG32(addr + LBA_FCLASS);\r\nif (IS_ELROY(dev)) {\r\nfunc_class &= 0xf;\r\nswitch (func_class) {\r\ncase 0: version = "TR1.0"; break;\r\ncase 1: version = "TR2.0"; break;\r\ncase 2: version = "TR2.1"; break;\r\ncase 3: version = "TR2.2"; break;\r\ncase 4: version = "TR3.0"; break;\r\ncase 5: version = "TR4.0"; break;\r\ndefault: version = "TR4+";\r\n}\r\nprintk(KERN_INFO "Elroy version %s (0x%x) found at 0x%lx\n",\r\nversion, func_class & 0xf, (long)dev->hpa.start);\r\nif (func_class < 2) {\r\nprintk(KERN_WARNING "Can't support LBA older than "\r\n"TR2.1 - continuing under adversity.\n");\r\n}\r\n#if 0\r\nif (func_class > 4) {\r\ncfg_ops = &mercury_cfg_ops;\r\n} else\r\n#endif\r\n{\r\ncfg_ops = &elroy_cfg_ops;\r\n}\r\n} else if (IS_MERCURY(dev) || IS_QUICKSILVER(dev)) {\r\nint major, minor;\r\nfunc_class &= 0xff;\r\nmajor = func_class >> 4, minor = func_class & 0xf;\r\nprintk(KERN_INFO "%s version TR%d.%d (0x%x) found at 0x%lx\n",\r\nIS_MERCURY(dev) ? "Mercury" : "Quicksilver", major,\r\nminor, func_class, (long)dev->hpa.start);\r\ncfg_ops = &mercury_cfg_ops;\r\n} else {\r\nprintk(KERN_ERR "Unknown LBA found at 0x%lx\n",\r\n(long)dev->hpa.start);\r\nreturn -ENODEV;\r\n}\r\ntmp_obj = iosapic_register(dev->hpa.start + LBA_IOSAPIC_BASE);\r\nlba_dev = kzalloc(sizeof(struct lba_device), GFP_KERNEL);\r\nif (!lba_dev) {\r\nprintk(KERN_ERR "lba_init_chip - couldn't alloc lba_device\n");\r\nreturn(1);\r\n}\r\nlba_dev->hw_rev = func_class;\r\nlba_dev->hba.base_addr = addr;\r\nlba_dev->hba.dev = dev;\r\nlba_dev->iosapic_obj = tmp_obj;\r\nlba_dev->hba.iommu = sba_get_iommu(dev);\r\nparisc_set_drvdata(dev, lba_dev);\r\npci_bios = &lba_bios_ops;\r\npcibios_register_hba(HBA_DATA(lba_dev));\r\nspin_lock_init(&lba_dev->lba_lock);\r\nif (lba_hw_init(lba_dev))\r\nreturn(1);\r\nif (is_pdc_pat()) {\r\npci_port = &lba_pat_port_ops;\r\nlba_pat_resources(dev, lba_dev);\r\n} else {\r\nif (!astro_iop_base) {\r\nastro_iop_base = ioremap_nocache(LBA_PORT_BASE, 64 * 1024);\r\npci_port = &lba_astro_port_ops;\r\n}\r\nlba_legacy_resources(dev, lba_dev);\r\n}\r\nif (lba_dev->hba.bus_num.start < lba_next_bus)\r\nlba_dev->hba.bus_num.start = lba_next_bus;\r\nif (truncate_pat_collision(&iomem_resource,\r\n&(lba_dev->hba.lmmio_space))) {\r\nprintk(KERN_WARNING "LBA: lmmio_space [%lx/%lx] duplicate!\n",\r\n(long)lba_dev->hba.lmmio_space.start,\r\n(long)lba_dev->hba.lmmio_space.end);\r\nlba_dev->hba.lmmio_space.flags = 0;\r\n}\r\npci_add_resource_offset(&resources, &lba_dev->hba.io_space,\r\nHBA_PORT_BASE(lba_dev->hba.hba_num));\r\nif (lba_dev->hba.elmmio_space.flags)\r\npci_add_resource_offset(&resources, &lba_dev->hba.elmmio_space,\r\nlba_dev->hba.lmmio_space_offset);\r\nif (lba_dev->hba.lmmio_space.flags)\r\npci_add_resource_offset(&resources, &lba_dev->hba.lmmio_space,\r\nlba_dev->hba.lmmio_space_offset);\r\nif (lba_dev->hba.gmmio_space.flags)\r\npci_add_resource(&resources, &lba_dev->hba.gmmio_space);\r\npci_add_resource(&resources, &lba_dev->hba.bus_num);\r\ndev->dev.platform_data = lba_dev;\r\nlba_bus = lba_dev->hba.hba_bus =\r\npci_create_root_bus(&dev->dev, lba_dev->hba.bus_num.start,\r\ncfg_ops, NULL, &resources);\r\nif (!lba_bus) {\r\npci_free_resource_list(&resources);\r\nreturn 0;\r\n}\r\nmax = pci_scan_child_bus(lba_bus);\r\nif (is_pdc_pat()) {\r\nDBG_PAT("LBA pci_bus_size_bridges()\n");\r\npci_bus_size_bridges(lba_bus);\r\nDBG_PAT("LBA pci_bus_assign_resources()\n");\r\npci_bus_assign_resources(lba_bus);\r\n#ifdef DEBUG_LBA_PAT\r\nDBG_PAT("\nLBA PIOP resource tree\n");\r\nlba_dump_res(&lba_dev->hba.io_space, 2);\r\nDBG_PAT("\nLBA LMMIO resource tree\n");\r\nlba_dump_res(&lba_dev->hba.lmmio_space, 2);\r\n#endif\r\n}\r\nif (cfg_ops == &elroy_cfg_ops) {\r\nlba_dev->flags |= LBA_FLAG_SKIP_PROBE;\r\n}\r\nlba_next_bus = max + 1;\r\npci_bus_add_devices(lba_bus);\r\nreturn 0;\r\n}\r\nvoid __init lba_init(void)\r\n{\r\nregister_parisc_driver(&lba_driver);\r\n}\r\nvoid lba_set_iregs(struct parisc_device *lba, u32 ibase, u32 imask)\r\n{\r\nvoid __iomem * base_addr = ioremap_nocache(lba->hpa.start, 4096);\r\nimask <<= 2;\r\nWARN_ON((ibase & 0x001fffff) != 0);\r\nWARN_ON((imask & 0x001fffff) != 0);\r\nDBG("%s() ibase 0x%x imask 0x%x\n", __func__, ibase, imask);\r\nWRITE_REG32( imask, base_addr + LBA_IMASK);\r\nWRITE_REG32( ibase, base_addr + LBA_IBASE);\r\niounmap(base_addr);\r\n}
