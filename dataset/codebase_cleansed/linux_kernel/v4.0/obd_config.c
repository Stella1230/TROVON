int class_find_param(char *buf, char *key, char **valp)\r\n{\r\nchar *ptr;\r\nif (!buf)\r\nreturn 1;\r\nptr = strstr(buf, key);\r\nif (ptr == NULL)\r\nreturn 1;\r\nif (valp)\r\n*valp = ptr + strlen(key);\r\nreturn 0;\r\n}\r\nstruct cfg_interop_param *class_find_old_param(const char *param,\r\nstruct cfg_interop_param *ptr)\r\n{\r\nchar *value = NULL;\r\nint name_len = 0;\r\nif (param == NULL || ptr == NULL)\r\nreturn NULL;\r\nvalue = strchr(param, '=');\r\nif (value == NULL)\r\nname_len = strlen(param);\r\nelse\r\nname_len = value - param;\r\nwhile (ptr->old_param != NULL) {\r\nif (strncmp(param, ptr->old_param, name_len) == 0 &&\r\nname_len == strlen(ptr->old_param))\r\nreturn ptr;\r\nptr++;\r\n}\r\nreturn NULL;\r\n}\r\nint class_get_next_param(char **params, char *copy)\r\n{\r\nchar *q1, *q2, *str;\r\nint len;\r\nstr = *params;\r\nwhile (*str == ' ')\r\nstr++;\r\nif (*str == '\0') {\r\n*params = NULL;\r\nreturn 1;\r\n}\r\nwhile (1) {\r\nq1 = strpbrk(str, " '\"");\r\nif (q1 == NULL) {\r\nlen = strlen(str);\r\nmemcpy(copy, str, len);\r\ncopy[len] = '\0';\r\n*params = NULL;\r\nreturn 0;\r\n}\r\nlen = q1 - str;\r\nif (*q1 == ' ') {\r\nmemcpy(copy, str, len);\r\ncopy[len] = '\0';\r\n*params = str + len;\r\nreturn 0;\r\n}\r\nmemcpy(copy, str, len);\r\ncopy += len;\r\nstr = q1 + 1;\r\nq2 = strchr(str, *q1);\r\nif (q2 == NULL) {\r\nCERROR("Unbalanced quota in parameters: \"%s\"\n",\r\n*params);\r\nreturn -EINVAL;\r\n}\r\nlen = q2 - str;\r\nmemcpy(copy, str, len);\r\ncopy += len;\r\nstr = q2 + 1;\r\n}\r\nreturn 1;\r\n}\r\nint class_match_param(char *buf, char *key, char **valp)\r\n{\r\nif (!buf)\r\nreturn 1;\r\nif (memcmp(buf, key, strlen(key)) != 0)\r\nreturn 1;\r\nif (valp)\r\n*valp = buf + strlen(key);\r\nreturn 0;\r\n}\r\nstatic int parse_nid(char *buf, void *value, int quiet)\r\n{\r\nlnet_nid_t *nid = (lnet_nid_t *)value;\r\n*nid = libcfs_str2nid(buf);\r\nif (*nid != LNET_NID_ANY)\r\nreturn 0;\r\nif (!quiet)\r\nLCONSOLE_ERROR_MSG(0x159, "Can't parse NID '%s'\n", buf);\r\nreturn -EINVAL;\r\n}\r\nstatic int parse_net(char *buf, void *value)\r\n{\r\n__u32 *net = (__u32 *)value;\r\n*net = libcfs_str2net(buf);\r\nCDEBUG(D_INFO, "Net %s\n", libcfs_net2str(*net));\r\nreturn 0;\r\n}\r\nstatic int class_parse_value(char *buf, int opc, void *value, char **endh,\r\nint quiet)\r\n{\r\nchar *endp;\r\nchar tmp;\r\nint rc = 0;\r\nif (!buf)\r\nreturn 1;\r\nwhile (*buf == ',' || *buf == ':')\r\nbuf++;\r\nif (*buf == ' ' || *buf == '/' || *buf == '\0')\r\nreturn 1;\r\nendp = strpbrk(buf, ",: /");\r\nif (endp == NULL)\r\nendp = buf + strlen(buf);\r\ntmp = *endp;\r\n*endp = '\0';\r\nswitch (opc) {\r\ndefault:\r\nLBUG();\r\ncase CLASS_PARSE_NID:\r\nrc = parse_nid(buf, value, quiet);\r\nbreak;\r\ncase CLASS_PARSE_NET:\r\nrc = parse_net(buf, value);\r\nbreak;\r\n}\r\n*endp = tmp;\r\nif (rc != 0)\r\nreturn rc;\r\nif (endh)\r\n*endh = endp;\r\nreturn 0;\r\n}\r\nint class_parse_nid(char *buf, lnet_nid_t *nid, char **endh)\r\n{\r\nreturn class_parse_value(buf, CLASS_PARSE_NID, (void *)nid, endh, 0);\r\n}\r\nint class_parse_nid_quiet(char *buf, lnet_nid_t *nid, char **endh)\r\n{\r\nreturn class_parse_value(buf, CLASS_PARSE_NID, (void *)nid, endh, 1);\r\n}\r\nint class_parse_net(char *buf, __u32 *net, char **endh)\r\n{\r\nreturn class_parse_value(buf, CLASS_PARSE_NET, (void *)net, endh, 0);\r\n}\r\nint class_match_nid(char *buf, char *key, lnet_nid_t nid)\r\n{\r\nlnet_nid_t tmp;\r\nint rc = -1;\r\nwhile (class_find_param(buf, key, &buf) == 0) {\r\nwhile (class_parse_nid(buf, &tmp, &buf) == 0) {\r\nif (tmp == nid)\r\nreturn 1;\r\n}\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nint class_match_net(char *buf, char *key, __u32 net)\r\n{\r\n__u32 tmp;\r\nint rc = -1;\r\nwhile (class_find_param(buf, key, &buf) == 0) {\r\nwhile (class_parse_net(buf, &tmp, &buf) == 0) {\r\nif (tmp == net)\r\nreturn 1;\r\n}\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nint class_attach(struct lustre_cfg *lcfg)\r\n{\r\nstruct obd_device *obd = NULL;\r\nchar *typename, *name, *uuid;\r\nint rc, len;\r\nif (!LUSTRE_CFG_BUFLEN(lcfg, 1)) {\r\nCERROR("No type passed!\n");\r\nreturn -EINVAL;\r\n}\r\ntypename = lustre_cfg_string(lcfg, 1);\r\nif (!LUSTRE_CFG_BUFLEN(lcfg, 0)) {\r\nCERROR("No name passed!\n");\r\nreturn -EINVAL;\r\n}\r\nname = lustre_cfg_string(lcfg, 0);\r\nif (!LUSTRE_CFG_BUFLEN(lcfg, 2)) {\r\nCERROR("No UUID passed!\n");\r\nreturn -EINVAL;\r\n}\r\nuuid = lustre_cfg_string(lcfg, 2);\r\nCDEBUG(D_IOCTL, "attach type %s name: %s uuid: %s\n",\r\nMKSTR(typename), MKSTR(name), MKSTR(uuid));\r\nobd = class_newdev(typename, name);\r\nif (IS_ERR(obd)) {\r\nrc = PTR_ERR(obd);\r\nobd = NULL;\r\nCERROR("Cannot create device %s of type %s : %d\n",\r\nname, typename, rc);\r\ngoto out;\r\n}\r\nLASSERTF(obd != NULL, "Cannot get obd device %s of type %s\n",\r\nname, typename);\r\nLASSERTF(obd->obd_magic == OBD_DEVICE_MAGIC,\r\n"obd %p obd_magic %08X != %08X\n",\r\nobd, obd->obd_magic, OBD_DEVICE_MAGIC);\r\nLASSERTF(strncmp(obd->obd_name, name, strlen(name)) == 0,\r\n"%p obd_name %s != %s\n", obd, obd->obd_name, name);\r\nrwlock_init(&obd->obd_pool_lock);\r\nobd->obd_pool_limit = 0;\r\nobd->obd_pool_slv = 0;\r\nINIT_LIST_HEAD(&obd->obd_exports);\r\nINIT_LIST_HEAD(&obd->obd_unlinked_exports);\r\nINIT_LIST_HEAD(&obd->obd_delayed_exports);\r\nINIT_LIST_HEAD(&obd->obd_exports_timed);\r\nINIT_LIST_HEAD(&obd->obd_nid_stats);\r\nspin_lock_init(&obd->obd_nid_lock);\r\nspin_lock_init(&obd->obd_dev_lock);\r\nmutex_init(&obd->obd_dev_mutex);\r\nspin_lock_init(&obd->obd_osfs_lock);\r\nobd->obd_osfs_age = cfs_time_shift_64(-1000);\r\ninit_rwsem(&obd->obd_observer_link_sem);\r\ncfs_init_timer(&obd->obd_recovery_timer);\r\nspin_lock_init(&obd->obd_recovery_task_lock);\r\ninit_waitqueue_head(&obd->obd_next_transno_waitq);\r\ninit_waitqueue_head(&obd->obd_evict_inprogress_waitq);\r\nINIT_LIST_HEAD(&obd->obd_req_replay_queue);\r\nINIT_LIST_HEAD(&obd->obd_lock_replay_queue);\r\nINIT_LIST_HEAD(&obd->obd_final_req_queue);\r\nINIT_LIST_HEAD(&obd->obd_evict_list);\r\nllog_group_init(&obd->obd_olg, FID_SEQ_LLOG);\r\nobd->obd_conn_inprogress = 0;\r\nlen = strlen(uuid);\r\nif (len >= sizeof(obd->obd_uuid)) {\r\nCERROR("uuid must be < %d bytes long\n",\r\n(int)sizeof(obd->obd_uuid));\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nmemcpy(obd->obd_uuid.uuid, uuid, len);\r\nif (OBP(obd, attach)) {\r\nrc = OBP(obd, attach)(obd, sizeof(*lcfg), lcfg);\r\nif (rc) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nspin_lock(&obd->obd_dev_lock);\r\natomic_set(&obd->obd_refcount, 1);\r\nspin_unlock(&obd->obd_dev_lock);\r\nlu_ref_init(&obd->obd_reference);\r\nlu_ref_add(&obd->obd_reference, "attach", obd);\r\nobd->obd_attached = 1;\r\nCDEBUG(D_IOCTL, "OBD: dev %d attached type %s with refcount %d\n",\r\nobd->obd_minor, typename, atomic_read(&obd->obd_refcount));\r\nreturn 0;\r\nout:\r\nif (obd != NULL) {\r\nclass_release_dev(obd);\r\n}\r\nreturn rc;\r\n}\r\nint class_setup(struct obd_device *obd, struct lustre_cfg *lcfg)\r\n{\r\nint err = 0;\r\nstruct obd_export *exp;\r\nLASSERT(obd != NULL);\r\nLASSERTF(obd == class_num2obd(obd->obd_minor),\r\n"obd %p != obd_devs[%d] %p\n",\r\nobd, obd->obd_minor, class_num2obd(obd->obd_minor));\r\nLASSERTF(obd->obd_magic == OBD_DEVICE_MAGIC,\r\n"obd %p obd_magic %08x != %08x\n",\r\nobd, obd->obd_magic, OBD_DEVICE_MAGIC);\r\nif (!obd->obd_attached) {\r\nCERROR("Device %d not attached\n", obd->obd_minor);\r\nreturn -ENODEV;\r\n}\r\nif (obd->obd_set_up) {\r\nCERROR("Device %d already setup (type %s)\n",\r\nobd->obd_minor, obd->obd_type->typ_name);\r\nreturn -EEXIST;\r\n}\r\nspin_lock(&obd->obd_dev_lock);\r\nif (obd->obd_starting) {\r\nspin_unlock(&obd->obd_dev_lock);\r\nCERROR("Device %d setup in progress (type %s)\n",\r\nobd->obd_minor, obd->obd_type->typ_name);\r\nreturn -EEXIST;\r\n}\r\nobd->obd_starting = 1;\r\nobd->obd_uuid_hash = NULL;\r\nobd->obd_nid_hash = NULL;\r\nobd->obd_nid_stats_hash = NULL;\r\nspin_unlock(&obd->obd_dev_lock);\r\nobd->obd_uuid_hash = cfs_hash_create("UUID_HASH",\r\nHASH_UUID_CUR_BITS,\r\nHASH_UUID_MAX_BITS,\r\nHASH_UUID_BKT_BITS, 0,\r\nCFS_HASH_MIN_THETA,\r\nCFS_HASH_MAX_THETA,\r\n&uuid_hash_ops, CFS_HASH_DEFAULT);\r\nif (!obd->obd_uuid_hash) {\r\nerr = -ENOMEM;\r\ngoto err_hash;\r\n}\r\nobd->obd_nid_hash = cfs_hash_create("NID_HASH",\r\nHASH_NID_CUR_BITS,\r\nHASH_NID_MAX_BITS,\r\nHASH_NID_BKT_BITS, 0,\r\nCFS_HASH_MIN_THETA,\r\nCFS_HASH_MAX_THETA,\r\n&nid_hash_ops, CFS_HASH_DEFAULT);\r\nif (!obd->obd_nid_hash) {\r\nerr = -ENOMEM;\r\ngoto err_hash;\r\n}\r\nobd->obd_nid_stats_hash = cfs_hash_create("NID_STATS",\r\nHASH_NID_STATS_CUR_BITS,\r\nHASH_NID_STATS_MAX_BITS,\r\nHASH_NID_STATS_BKT_BITS, 0,\r\nCFS_HASH_MIN_THETA,\r\nCFS_HASH_MAX_THETA,\r\n&nid_stat_hash_ops, CFS_HASH_DEFAULT);\r\nif (!obd->obd_nid_stats_hash) {\r\nerr = -ENOMEM;\r\ngoto err_hash;\r\n}\r\nexp = class_new_export(obd, &obd->obd_uuid);\r\nif (IS_ERR(exp)) {\r\nerr = PTR_ERR(exp);\r\ngoto err_hash;\r\n}\r\nobd->obd_self_export = exp;\r\nlist_del_init(&exp->exp_obd_chain_timed);\r\nclass_export_put(exp);\r\nerr = obd_setup(obd, lcfg);\r\nif (err)\r\ngoto err_exp;\r\nobd->obd_set_up = 1;\r\nspin_lock(&obd->obd_dev_lock);\r\nclass_incref(obd, "setup", obd);\r\nspin_unlock(&obd->obd_dev_lock);\r\nCDEBUG(D_IOCTL, "finished setup of obd %s (uuid %s)\n",\r\nobd->obd_name, obd->obd_uuid.uuid);\r\nreturn 0;\r\nerr_exp:\r\nif (obd->obd_self_export) {\r\nclass_unlink_export(obd->obd_self_export);\r\nobd->obd_self_export = NULL;\r\n}\r\nerr_hash:\r\nif (obd->obd_uuid_hash) {\r\ncfs_hash_putref(obd->obd_uuid_hash);\r\nobd->obd_uuid_hash = NULL;\r\n}\r\nif (obd->obd_nid_hash) {\r\ncfs_hash_putref(obd->obd_nid_hash);\r\nobd->obd_nid_hash = NULL;\r\n}\r\nif (obd->obd_nid_stats_hash) {\r\ncfs_hash_putref(obd->obd_nid_stats_hash);\r\nobd->obd_nid_stats_hash = NULL;\r\n}\r\nobd->obd_starting = 0;\r\nCERROR("setup %s failed (%d)\n", obd->obd_name, err);\r\nreturn err;\r\n}\r\nint class_detach(struct obd_device *obd, struct lustre_cfg *lcfg)\r\n{\r\nif (obd->obd_set_up) {\r\nCERROR("OBD device %d still set up\n", obd->obd_minor);\r\nreturn -EBUSY;\r\n}\r\nspin_lock(&obd->obd_dev_lock);\r\nif (!obd->obd_attached) {\r\nspin_unlock(&obd->obd_dev_lock);\r\nCERROR("OBD device %d not attached\n", obd->obd_minor);\r\nreturn -ENODEV;\r\n}\r\nobd->obd_attached = 0;\r\nspin_unlock(&obd->obd_dev_lock);\r\nCDEBUG(D_IOCTL, "detach on obd %s (uuid %s)\n",\r\nobd->obd_name, obd->obd_uuid.uuid);\r\nclass_decref(obd, "attach", obd);\r\nreturn 0;\r\n}\r\nint class_cleanup(struct obd_device *obd, struct lustre_cfg *lcfg)\r\n{\r\nint err = 0;\r\nchar *flag;\r\nOBD_RACE(OBD_FAIL_LDLM_RECOV_CLIENTS);\r\nif (!obd->obd_set_up) {\r\nCERROR("Device %d not setup\n", obd->obd_minor);\r\nreturn -ENODEV;\r\n}\r\nspin_lock(&obd->obd_dev_lock);\r\nif (obd->obd_stopping) {\r\nspin_unlock(&obd->obd_dev_lock);\r\nCERROR("OBD %d already stopping\n", obd->obd_minor);\r\nreturn -ENODEV;\r\n}\r\nobd->obd_stopping = 1;\r\nwhile (obd->obd_conn_inprogress > 0) {\r\nspin_unlock(&obd->obd_dev_lock);\r\ncond_resched();\r\nspin_lock(&obd->obd_dev_lock);\r\n}\r\nspin_unlock(&obd->obd_dev_lock);\r\nif (lcfg->lcfg_bufcount >= 2 && LUSTRE_CFG_BUFLEN(lcfg, 1) > 0) {\r\nfor (flag = lustre_cfg_string(lcfg, 1); *flag != 0; flag++)\r\nswitch (*flag) {\r\ncase 'F':\r\nobd->obd_force = 1;\r\nbreak;\r\ncase 'A':\r\nLCONSOLE_WARN("Failing over %s\n",\r\nobd->obd_name);\r\nobd->obd_fail = 1;\r\nobd->obd_no_transno = 1;\r\nobd->obd_no_recov = 1;\r\nif (OBP(obd, iocontrol)) {\r\nobd_iocontrol(OBD_IOC_SYNC,\r\nobd->obd_self_export,\r\n0, NULL, NULL);\r\n}\r\nbreak;\r\ndefault:\r\nCERROR("Unrecognised flag '%c'\n", *flag);\r\n}\r\n}\r\nLASSERT(obd->obd_self_export);\r\nif (atomic_read(&obd->obd_refcount) > 3) {\r\nCDEBUG(D_IOCTL, "%s: forcing exports to disconnect: %d\n",\r\nobd->obd_name, atomic_read(&obd->obd_refcount) - 3);\r\ndump_exports(obd, 0);\r\nclass_disconnect_exports(obd);\r\n}\r\nerr = obd_precleanup(obd, OBD_CLEANUP_EXPORTS);\r\nif (err)\r\nCERROR("Precleanup %s returned %d\n",\r\nobd->obd_name, err);\r\nif (obd->obd_uuid_hash) {\r\ncfs_hash_putref(obd->obd_uuid_hash);\r\nobd->obd_uuid_hash = NULL;\r\n}\r\nif (obd->obd_nid_hash) {\r\ncfs_hash_putref(obd->obd_nid_hash);\r\nobd->obd_nid_hash = NULL;\r\n}\r\nif (obd->obd_nid_stats_hash) {\r\ncfs_hash_putref(obd->obd_nid_stats_hash);\r\nobd->obd_nid_stats_hash = NULL;\r\n}\r\nclass_decref(obd, "setup", obd);\r\nobd->obd_set_up = 0;\r\nreturn 0;\r\n}\r\nstruct obd_device *class_incref(struct obd_device *obd,\r\nconst char *scope, const void *source)\r\n{\r\nlu_ref_add_atomic(&obd->obd_reference, scope, source);\r\natomic_inc(&obd->obd_refcount);\r\nCDEBUG(D_INFO, "incref %s (%p) now %d\n", obd->obd_name, obd,\r\natomic_read(&obd->obd_refcount));\r\nreturn obd;\r\n}\r\nvoid class_decref(struct obd_device *obd, const char *scope, const void *source)\r\n{\r\nint err;\r\nint refs;\r\nspin_lock(&obd->obd_dev_lock);\r\natomic_dec(&obd->obd_refcount);\r\nrefs = atomic_read(&obd->obd_refcount);\r\nspin_unlock(&obd->obd_dev_lock);\r\nlu_ref_del(&obd->obd_reference, scope, source);\r\nCDEBUG(D_INFO, "Decref %s (%p) now %d\n", obd->obd_name, obd, refs);\r\nif ((refs == 1) && obd->obd_stopping) {\r\nspin_lock(&obd->obd_self_export->exp_lock);\r\nobd->obd_self_export->exp_flags |= exp_flags_from_obd(obd);\r\nspin_unlock(&obd->obd_self_export->exp_lock);\r\nclass_unlink_export(obd->obd_self_export);\r\nreturn;\r\n}\r\nif (refs == 0) {\r\nCDEBUG(D_CONFIG, "finishing cleanup of obd %s (%s)\n",\r\nobd->obd_name, obd->obd_uuid.uuid);\r\nLASSERT(!obd->obd_attached);\r\nif (obd->obd_stopping) {\r\nerr = obd_cleanup(obd);\r\nif (err)\r\nCERROR("Cleanup %s returned %d\n",\r\nobd->obd_name, err);\r\n}\r\nif (OBP(obd, detach)) {\r\nerr = OBP(obd, detach)(obd);\r\nif (err)\r\nCERROR("Detach returned %d\n", err);\r\n}\r\nclass_release_dev(obd);\r\n}\r\n}\r\nint class_add_conn(struct obd_device *obd, struct lustre_cfg *lcfg)\r\n{\r\nstruct obd_import *imp;\r\nstruct obd_uuid uuid;\r\nint rc;\r\nif (LUSTRE_CFG_BUFLEN(lcfg, 1) < 1 ||\r\nLUSTRE_CFG_BUFLEN(lcfg, 1) > sizeof(struct obd_uuid)) {\r\nCERROR("invalid conn_uuid\n");\r\nreturn -EINVAL;\r\n}\r\nif (strcmp(obd->obd_type->typ_name, LUSTRE_MDC_NAME) &&\r\nstrcmp(obd->obd_type->typ_name, LUSTRE_OSC_NAME) &&\r\nstrcmp(obd->obd_type->typ_name, LUSTRE_OSP_NAME) &&\r\nstrcmp(obd->obd_type->typ_name, LUSTRE_LWP_NAME) &&\r\nstrcmp(obd->obd_type->typ_name, LUSTRE_MGC_NAME)) {\r\nCERROR("can't add connection on non-client dev\n");\r\nreturn -EINVAL;\r\n}\r\nimp = obd->u.cli.cl_import;\r\nif (!imp) {\r\nCERROR("try to add conn on immature client dev\n");\r\nreturn -EINVAL;\r\n}\r\nobd_str2uuid(&uuid, lustre_cfg_string(lcfg, 1));\r\nrc = obd_add_conn(imp, &uuid, lcfg->lcfg_num);\r\nreturn rc;\r\n}\r\nint class_del_conn(struct obd_device *obd, struct lustre_cfg *lcfg)\r\n{\r\nstruct obd_import *imp;\r\nstruct obd_uuid uuid;\r\nint rc;\r\nif (LUSTRE_CFG_BUFLEN(lcfg, 1) < 1 ||\r\nLUSTRE_CFG_BUFLEN(lcfg, 1) > sizeof(struct obd_uuid)) {\r\nCERROR("invalid conn_uuid\n");\r\nreturn -EINVAL;\r\n}\r\nif (strcmp(obd->obd_type->typ_name, LUSTRE_MDC_NAME) &&\r\nstrcmp(obd->obd_type->typ_name, LUSTRE_OSC_NAME)) {\r\nCERROR("can't del connection on non-client dev\n");\r\nreturn -EINVAL;\r\n}\r\nimp = obd->u.cli.cl_import;\r\nif (!imp) {\r\nCERROR("try to del conn on immature client dev\n");\r\nreturn -EINVAL;\r\n}\r\nobd_str2uuid(&uuid, lustre_cfg_string(lcfg, 1));\r\nrc = obd_del_conn(imp, &uuid);\r\nreturn rc;\r\n}\r\nstruct lustre_profile *class_get_profile(const char *prof)\r\n{\r\nstruct lustre_profile *lprof;\r\nlist_for_each_entry(lprof, &lustre_profile_list, lp_list) {\r\nif (!strcmp(lprof->lp_profile, prof)) {\r\nreturn lprof;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nint class_add_profile(int proflen, char *prof, int osclen, char *osc,\r\nint mdclen, char *mdc)\r\n{\r\nstruct lustre_profile *lprof;\r\nint err = 0;\r\nCDEBUG(D_CONFIG, "Add profile %s\n", prof);\r\nOBD_ALLOC(lprof, sizeof(*lprof));\r\nif (lprof == NULL)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&lprof->lp_list);\r\nLASSERT(proflen == (strlen(prof) + 1));\r\nOBD_ALLOC(lprof->lp_profile, proflen);\r\nif (lprof->lp_profile == NULL) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy(lprof->lp_profile, prof, proflen);\r\nLASSERT(osclen == (strlen(osc) + 1));\r\nOBD_ALLOC(lprof->lp_dt, osclen);\r\nif (lprof->lp_dt == NULL) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy(lprof->lp_dt, osc, osclen);\r\nif (mdclen > 0) {\r\nLASSERT(mdclen == (strlen(mdc) + 1));\r\nOBD_ALLOC(lprof->lp_md, mdclen);\r\nif (lprof->lp_md == NULL) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy(lprof->lp_md, mdc, mdclen);\r\n}\r\nlist_add(&lprof->lp_list, &lustre_profile_list);\r\nreturn err;\r\nout:\r\nif (lprof->lp_md)\r\nOBD_FREE(lprof->lp_md, mdclen);\r\nif (lprof->lp_dt)\r\nOBD_FREE(lprof->lp_dt, osclen);\r\nif (lprof->lp_profile)\r\nOBD_FREE(lprof->lp_profile, proflen);\r\nOBD_FREE(lprof, sizeof(*lprof));\r\nreturn err;\r\n}\r\nvoid class_del_profile(const char *prof)\r\n{\r\nstruct lustre_profile *lprof;\r\nCDEBUG(D_CONFIG, "Del profile %s\n", prof);\r\nlprof = class_get_profile(prof);\r\nif (lprof) {\r\nlist_del(&lprof->lp_list);\r\nOBD_FREE(lprof->lp_profile, strlen(lprof->lp_profile) + 1);\r\nOBD_FREE(lprof->lp_dt, strlen(lprof->lp_dt) + 1);\r\nif (lprof->lp_md)\r\nOBD_FREE(lprof->lp_md, strlen(lprof->lp_md) + 1);\r\nOBD_FREE(lprof, sizeof(*lprof));\r\n}\r\n}\r\nvoid class_del_profiles(void)\r\n{\r\nstruct lustre_profile *lprof, *n;\r\nlist_for_each_entry_safe(lprof, n, &lustre_profile_list, lp_list) {\r\nlist_del(&lprof->lp_list);\r\nOBD_FREE(lprof->lp_profile, strlen(lprof->lp_profile) + 1);\r\nOBD_FREE(lprof->lp_dt, strlen(lprof->lp_dt) + 1);\r\nif (lprof->lp_md)\r\nOBD_FREE(lprof->lp_md, strlen(lprof->lp_md) + 1);\r\nOBD_FREE(lprof, sizeof(*lprof));\r\n}\r\n}\r\nstatic int class_set_global(char *ptr, int val, struct lustre_cfg *lcfg)\r\n{\r\nif (class_match_param(ptr, PARAM_AT_MIN, NULL) == 0)\r\nat_min = val;\r\nelse if (class_match_param(ptr, PARAM_AT_MAX, NULL) == 0)\r\nat_max = val;\r\nelse if (class_match_param(ptr, PARAM_AT_EXTRA, NULL) == 0)\r\nat_extra = val;\r\nelse if (class_match_param(ptr, PARAM_AT_EARLY_MARGIN, NULL) == 0)\r\nat_early_margin = val;\r\nelse if (class_match_param(ptr, PARAM_AT_HISTORY, NULL) == 0)\r\nat_history = val;\r\nelse if (class_match_param(ptr, PARAM_JOBID_VAR, NULL) == 0)\r\nstrlcpy(obd_jobid_var, lustre_cfg_string(lcfg, 2),\r\nJOBSTATS_JOBID_VAR_MAX_LEN + 1);\r\nelse\r\nreturn -EINVAL;\r\nCDEBUG(D_IOCTL, "global %s = %d\n", ptr, val);\r\nreturn 0;\r\n}\r\nvoid lustre_register_client_process_config(int (*cpc)(struct lustre_cfg *lcfg))\r\n{\r\nclient_process_config = cpc;\r\n}\r\nstruct lustre_cfg *lustre_cfg_rename(struct lustre_cfg *cfg,\r\nconst char *new_name)\r\n{\r\nstruct lustre_cfg_bufs *bufs = NULL;\r\nstruct lustre_cfg *new_cfg = NULL;\r\nchar *param = NULL;\r\nchar *new_param = NULL;\r\nchar *value = NULL;\r\nint name_len = 0;\r\nint new_len = 0;\r\nif (cfg == NULL || new_name == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nparam = lustre_cfg_string(cfg, 1);\r\nif (param == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nvalue = strchr(param, '=');\r\nif (value == NULL)\r\nname_len = strlen(param);\r\nelse\r\nname_len = value - param;\r\nnew_len = LUSTRE_CFG_BUFLEN(cfg, 1) + strlen(new_name) - name_len;\r\nOBD_ALLOC(new_param, new_len);\r\nif (new_param == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nstrcpy(new_param, new_name);\r\nif (value != NULL)\r\nstrcat(new_param, value);\r\nOBD_ALLOC_PTR(bufs);\r\nif (bufs == NULL) {\r\nOBD_FREE(new_param, new_len);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nlustre_cfg_bufs_reset(bufs, NULL);\r\nlustre_cfg_bufs_init(bufs, cfg);\r\nlustre_cfg_bufs_set_string(bufs, 1, new_param);\r\nnew_cfg = lustre_cfg_new(cfg->lcfg_command, bufs);\r\nOBD_FREE(new_param, new_len);\r\nOBD_FREE_PTR(bufs);\r\nif (new_cfg == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nnew_cfg->lcfg_num = cfg->lcfg_num;\r\nnew_cfg->lcfg_flags = cfg->lcfg_flags;\r\nnew_cfg->lcfg_nid = cfg->lcfg_nid;\r\nnew_cfg->lcfg_nal = cfg->lcfg_nal;\r\nreturn new_cfg;\r\n}\r\nstatic int process_param2_config(struct lustre_cfg *lcfg)\r\n{\r\nchar *param = lustre_cfg_string(lcfg, 1);\r\nchar *upcall = lustre_cfg_string(lcfg, 2);\r\nchar *argv[] = {\r\n[0] = "/usr/sbin/lctl",\r\n[1] = "set_param",\r\n[2] = param,\r\n[3] = NULL\r\n};\r\nstruct timeval start;\r\nstruct timeval end;\r\nint rc;\r\nif (strcmp(upcall, LCTL_UPCALL) != 0) {\r\nCERROR("Unsupported upcall %s\n", upcall);\r\nreturn -EINVAL;\r\n}\r\ndo_gettimeofday(&start);\r\nrc = call_usermodehelper(argv[0], argv, NULL, 1);\r\ndo_gettimeofday(&end);\r\nif (rc < 0) {\r\nCERROR(\r\n"lctl: error invoking upcall %s %s %s: rc = %d; time %ldus\n",\r\nargv[0], argv[1], argv[2], rc,\r\ncfs_timeval_sub(&end, &start, NULL));\r\n} else {\r\nCDEBUG(D_HA, "lctl: invoked upcall %s %s %s, time %ldus\n",\r\nargv[0], argv[1], argv[2],\r\ncfs_timeval_sub(&end, &start, NULL));\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nvoid lustre_register_quota_process_config(int (*qpc)(struct lustre_cfg *lcfg))\r\n{\r\nquota_process_config = qpc;\r\n}\r\nint class_process_config(struct lustre_cfg *lcfg)\r\n{\r\nstruct obd_device *obd;\r\nint err;\r\nLASSERT(lcfg && !IS_ERR(lcfg));\r\nCDEBUG(D_IOCTL, "processing cmd: %x\n", lcfg->lcfg_command);\r\nswitch (lcfg->lcfg_command) {\r\ncase LCFG_ATTACH: {\r\nerr = class_attach(lcfg);\r\ngoto out;\r\n}\r\ncase LCFG_ADD_UUID: {\r\nCDEBUG(D_IOCTL, "adding mapping from uuid %s to nid %#llx (%s)\n",\r\nlustre_cfg_string(lcfg, 1), lcfg->lcfg_nid,\r\nlibcfs_nid2str(lcfg->lcfg_nid));\r\nerr = class_add_uuid(lustre_cfg_string(lcfg, 1), lcfg->lcfg_nid);\r\ngoto out;\r\n}\r\ncase LCFG_DEL_UUID: {\r\nCDEBUG(D_IOCTL, "removing mappings for uuid %s\n",\r\n(lcfg->lcfg_bufcount < 2 || LUSTRE_CFG_BUFLEN(lcfg, 1) == 0)\r\n? "<all uuids>" : lustre_cfg_string(lcfg, 1));\r\nerr = class_del_uuid(lustre_cfg_string(lcfg, 1));\r\ngoto out;\r\n}\r\ncase LCFG_MOUNTOPT: {\r\nCDEBUG(D_IOCTL, "mountopt: profile %s osc %s mdc %s\n",\r\nlustre_cfg_string(lcfg, 1),\r\nlustre_cfg_string(lcfg, 2),\r\nlustre_cfg_string(lcfg, 3));\r\nerr = class_add_profile(LUSTRE_CFG_BUFLEN(lcfg, 1),\r\nlustre_cfg_string(lcfg, 1),\r\nLUSTRE_CFG_BUFLEN(lcfg, 2),\r\nlustre_cfg_string(lcfg, 2),\r\nLUSTRE_CFG_BUFLEN(lcfg, 3),\r\nlustre_cfg_string(lcfg, 3));\r\ngoto out;\r\n}\r\ncase LCFG_DEL_MOUNTOPT: {\r\nCDEBUG(D_IOCTL, "mountopt: profile %s\n",\r\nlustre_cfg_string(lcfg, 1));\r\nclass_del_profile(lustre_cfg_string(lcfg, 1));\r\nerr = 0;\r\ngoto out;\r\n}\r\ncase LCFG_SET_TIMEOUT: {\r\nCDEBUG(D_IOCTL, "changing lustre timeout from %d to %d\n",\r\nobd_timeout, lcfg->lcfg_num);\r\nobd_timeout = max(lcfg->lcfg_num, 1U);\r\nobd_timeout_set = 1;\r\nerr = 0;\r\ngoto out;\r\n}\r\ncase LCFG_SET_LDLM_TIMEOUT: {\r\nCDEBUG(D_IOCTL, "changing lustre ldlm_timeout from %d to %d\n",\r\nldlm_timeout, lcfg->lcfg_num);\r\nldlm_timeout = max(lcfg->lcfg_num, 1U);\r\nif (ldlm_timeout >= obd_timeout)\r\nldlm_timeout = max(obd_timeout / 3, 1U);\r\nldlm_timeout_set = 1;\r\nerr = 0;\r\ngoto out;\r\n}\r\ncase LCFG_SET_UPCALL: {\r\nLCONSOLE_ERROR_MSG(0x15a, "recovery upcall is deprecated\n");\r\nerr = 0;\r\ngoto out;\r\n}\r\ncase LCFG_MARKER: {\r\nstruct cfg_marker *marker;\r\nmarker = lustre_cfg_buf(lcfg, 1);\r\nCDEBUG(D_IOCTL, "marker %d (%#x) %.16s %s\n", marker->cm_step,\r\nmarker->cm_flags, marker->cm_tgtname, marker->cm_comment);\r\nerr = 0;\r\ngoto out;\r\n}\r\ncase LCFG_PARAM: {\r\nchar *tmp;\r\nif ((class_match_param(lustre_cfg_string(lcfg, 1),\r\nPARAM_LLITE, NULL) == 0) &&\r\nclient_process_config) {\r\nerr = (*client_process_config)(lcfg);\r\ngoto out;\r\n} else if ((class_match_param(lustre_cfg_string(lcfg, 1),\r\nPARAM_SYS, &tmp) == 0)) {\r\nerr = class_set_global(tmp, lcfg->lcfg_num, lcfg);\r\nif (err != 0)\r\nCWARN("Ignoring unknown param %s\n", tmp);\r\nerr = 0;\r\ngoto out;\r\n} else if ((class_match_param(lustre_cfg_string(lcfg, 1),\r\nPARAM_QUOTA, &tmp) == 0) &&\r\nquota_process_config) {\r\nerr = (*quota_process_config)(lcfg);\r\ngoto out;\r\n}\r\nbreak;\r\n}\r\ncase LCFG_SET_PARAM: {\r\nerr = process_param2_config(lcfg);\r\ngoto out;\r\n}\r\n}\r\nobd = class_name2obd(lustre_cfg_string(lcfg, 0));\r\nif (obd == NULL) {\r\nif (!LUSTRE_CFG_BUFLEN(lcfg, 0))\r\nCERROR("this lcfg command requires a device name\n");\r\nelse\r\nCERROR("no device for: %s\n",\r\nlustre_cfg_string(lcfg, 0));\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (lcfg->lcfg_command) {\r\ncase LCFG_SETUP: {\r\nerr = class_setup(obd, lcfg);\r\ngoto out;\r\n}\r\ncase LCFG_DETACH: {\r\nerr = class_detach(obd, lcfg);\r\nerr = 0;\r\ngoto out;\r\n}\r\ncase LCFG_CLEANUP: {\r\nerr = class_cleanup(obd, lcfg);\r\nerr = 0;\r\ngoto out;\r\n}\r\ncase LCFG_ADD_CONN: {\r\nerr = class_add_conn(obd, lcfg);\r\nerr = 0;\r\ngoto out;\r\n}\r\ncase LCFG_DEL_CONN: {\r\nerr = class_del_conn(obd, lcfg);\r\nerr = 0;\r\ngoto out;\r\n}\r\ncase LCFG_POOL_NEW: {\r\nerr = obd_pool_new(obd, lustre_cfg_string(lcfg, 2));\r\nerr = 0;\r\ngoto out;\r\n}\r\ncase LCFG_POOL_ADD: {\r\nerr = obd_pool_add(obd, lustre_cfg_string(lcfg, 2),\r\nlustre_cfg_string(lcfg, 3));\r\nerr = 0;\r\ngoto out;\r\n}\r\ncase LCFG_POOL_REM: {\r\nerr = obd_pool_rem(obd, lustre_cfg_string(lcfg, 2),\r\nlustre_cfg_string(lcfg, 3));\r\nerr = 0;\r\ngoto out;\r\n}\r\ncase LCFG_POOL_DEL: {\r\nerr = obd_pool_del(obd, lustre_cfg_string(lcfg, 2));\r\nerr = 0;\r\ngoto out;\r\n}\r\ndefault: {\r\nerr = obd_process_config(obd, sizeof(*lcfg), lcfg);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nif ((err < 0) && !(lcfg->lcfg_command & LCFG_REQUIRED)) {\r\nCWARN("Ignoring error %d on optional command %#x\n", err,\r\nlcfg->lcfg_command);\r\nerr = 0;\r\n}\r\nreturn err;\r\n}\r\nint class_process_proc_param(char *prefix, struct lprocfs_vars *lvars,\r\nstruct lustre_cfg *lcfg, void *data)\r\n{\r\nstruct lprocfs_vars *var;\r\nstruct file fakefile;\r\nstruct seq_file fake_seqfile;\r\nchar *key, *sval;\r\nint i, keylen, vallen;\r\nint matched = 0, j = 0;\r\nint rc = 0;\r\nint skip = 0;\r\nif (lcfg->lcfg_command != LCFG_PARAM) {\r\nCERROR("Unknown command: %d\n", lcfg->lcfg_command);\r\nreturn -EINVAL;\r\n}\r\nfakefile.private_data = &fake_seqfile;\r\nfake_seqfile.private = data;\r\nfor (i = 1; i < lcfg->lcfg_bufcount; i++) {\r\nkey = lustre_cfg_buf(lcfg, i);\r\nclass_match_param(key, prefix, &key);\r\nsval = strchr(key, '=');\r\nif (!sval || (*(sval + 1) == 0)) {\r\nCERROR("Can't parse param %s (missing '=')\n", key);\r\ncontinue;\r\n}\r\nkeylen = sval - key;\r\nsval++;\r\nvallen = strlen(sval);\r\nmatched = 0;\r\nj = 0;\r\nwhile (lvars[j].name) {\r\nvar = &lvars[j];\r\nif (class_match_param(key, (char *)var->name, NULL) == 0\r\n&& keylen == strlen(var->name)) {\r\nmatched++;\r\nrc = -EROFS;\r\nif (var->fops && var->fops->write) {\r\nmm_segment_t oldfs;\r\noldfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nrc = (var->fops->write)(&fakefile, sval,\r\nvallen, NULL);\r\nset_fs(oldfs);\r\n}\r\nbreak;\r\n}\r\nj++;\r\n}\r\nif (!matched) {\r\nif (strnchr(key, keylen, '.'))\r\nreturn -ENOSYS;\r\nCERROR("%s: unknown param %s\n",\r\n(char *)lustre_cfg_string(lcfg, 0), key);\r\nskip++;\r\n} else if (rc < 0) {\r\nCERROR("writing proc entry %s err %d\n",\r\nvar->name, rc);\r\nrc = 0;\r\n} else {\r\nCDEBUG(D_CONFIG, "%s.%.*s: Set parameter %.*s=%s\n",\r\nlustre_cfg_string(lcfg, 0),\r\n(int)strlen(prefix) - 1, prefix,\r\n(int)(sval - key - 1), key, sval);\r\n}\r\n}\r\nif (rc > 0)\r\nrc = 0;\r\nif (!rc && skip)\r\nrc = skip;\r\nreturn rc;\r\n}\r\nint class_config_llog_handler(const struct lu_env *env,\r\nstruct llog_handle *handle,\r\nstruct llog_rec_hdr *rec, void *data)\r\n{\r\nstruct config_llog_instance *clli = data;\r\nint cfg_len = rec->lrh_len;\r\nchar *cfg_buf = (char *) (rec + 1);\r\nint rc = 0;\r\nswitch (rec->lrh_type) {\r\ncase OBD_CFG_REC: {\r\nstruct lustre_cfg *lcfg, *lcfg_new;\r\nstruct lustre_cfg_bufs bufs;\r\nchar *inst_name = NULL;\r\nint inst_len = 0;\r\nint inst = 0, swab = 0;\r\nlcfg = (struct lustre_cfg *)cfg_buf;\r\nif (lcfg->lcfg_version == __swab32(LUSTRE_CFG_VERSION)) {\r\nlustre_swab_lustre_cfg(lcfg);\r\nswab = 1;\r\n}\r\nrc = lustre_cfg_sanity_check(cfg_buf, cfg_len);\r\nif (rc)\r\ngoto out;\r\nif (lcfg->lcfg_command == LCFG_MARKER) {\r\nstruct cfg_marker *marker = lustre_cfg_buf(lcfg, 1);\r\nlustre_swab_cfg_marker(marker, swab,\r\nLUSTRE_CFG_BUFLEN(lcfg, 1));\r\nCDEBUG(D_CONFIG, "Marker, inst_flg=%#x mark_flg=%#x\n",\r\nclli->cfg_flags, marker->cm_flags);\r\nif (marker->cm_flags & CM_START) {\r\nclli->cfg_flags = CFG_F_MARKER;\r\nif (marker->cm_flags & CM_SKIP) {\r\nclli->cfg_flags |= CFG_F_SKIP;\r\nCDEBUG(D_CONFIG, "SKIP #%d\n",\r\nmarker->cm_step);\r\n} else if ((marker->cm_flags & CM_EXCLUDE) ||\r\n(clli->cfg_sb &&\r\nlustre_check_exclusion(clli->cfg_sb,\r\nmarker->cm_tgtname))) {\r\nclli->cfg_flags |= CFG_F_EXCLUDE;\r\nCDEBUG(D_CONFIG, "EXCLUDE %d\n",\r\nmarker->cm_step);\r\n}\r\n} else if (marker->cm_flags & CM_END) {\r\nclli->cfg_flags = 0;\r\n}\r\n}\r\nif (!(clli->cfg_flags & CFG_F_COMPAT146) &&\r\n!(clli->cfg_flags & CFG_F_MARKER) &&\r\n(lcfg->lcfg_command != LCFG_MARKER)) {\r\nCWARN("Config not inside markers, ignoring! (inst: %p, uuid: %s, flags: %#x)\n",\r\nclli->cfg_instance,\r\nclli->cfg_uuid.uuid, clli->cfg_flags);\r\nclli->cfg_flags |= CFG_F_SKIP;\r\n}\r\nif (clli->cfg_flags & CFG_F_SKIP) {\r\nCDEBUG(D_CONFIG, "skipping %#x\n",\r\nclli->cfg_flags);\r\nrc = 0;\r\nbreak;\r\n}\r\n{\r\nchar *typename = lustre_cfg_string(lcfg, 1);\r\nchar *index = lustre_cfg_string(lcfg, 2);\r\nif ((lcfg->lcfg_command == LCFG_ATTACH && typename &&\r\nstrcmp(typename, "mds") == 0)) {\r\nCWARN("For 1.8 interoperability, rename obd type from mds to mdt\n");\r\ntypename[2] = 't';\r\n}\r\nif ((lcfg->lcfg_command == LCFG_SETUP && index &&\r\nstrcmp(index, "type") == 0)) {\r\nCDEBUG(D_INFO, "For 1.8 interoperability, set this index to '0'\n");\r\nindex[0] = '0';\r\nindex[1] = 0;\r\n}\r\n}\r\nif (clli->cfg_flags & CFG_F_EXCLUDE) {\r\nCDEBUG(D_CONFIG, "cmd: %x marked EXCLUDED\n",\r\nlcfg->lcfg_command);\r\nif (lcfg->lcfg_command == LCFG_LOV_ADD_OBD)\r\nlcfg->lcfg_command = LCFG_LOV_ADD_INA;\r\n}\r\nlustre_cfg_bufs_init(&bufs, lcfg);\r\nif (clli && clli->cfg_instance &&\r\nLUSTRE_CFG_BUFLEN(lcfg, 0) > 0){\r\ninst = 1;\r\ninst_len = LUSTRE_CFG_BUFLEN(lcfg, 0) +\r\nsizeof(clli->cfg_instance) * 2 + 4;\r\nOBD_ALLOC(inst_name, inst_len);\r\nif (inst_name == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nsprintf(inst_name, "%s-%p",\r\nlustre_cfg_string(lcfg, 0),\r\nclli->cfg_instance);\r\nlustre_cfg_bufs_set_string(&bufs, 0, inst_name);\r\nCDEBUG(D_CONFIG, "cmd %x, instance name: %s\n",\r\nlcfg->lcfg_command, inst_name);\r\n}\r\nif (clli && clli->cfg_instance != NULL &&\r\nlcfg->lcfg_command == LCFG_ATTACH) {\r\nlustre_cfg_bufs_set_string(&bufs, 2,\r\nclli->cfg_uuid.uuid);\r\n}\r\nif (clli && clli->cfg_instance == NULL &&\r\nlcfg->lcfg_command == LCFG_SPTLRPC_CONF) {\r\nlustre_cfg_bufs_set(&bufs, 2, bufs.lcfg_buf[1],\r\nbufs.lcfg_buflen[1]);\r\nlustre_cfg_bufs_set(&bufs, 1, bufs.lcfg_buf[0],\r\nbufs.lcfg_buflen[0]);\r\nlustre_cfg_bufs_set_string(&bufs, 0,\r\nclli->cfg_obdname);\r\n}\r\nlcfg_new = lustre_cfg_new(lcfg->lcfg_command, &bufs);\r\nlcfg_new->lcfg_num = lcfg->lcfg_num;\r\nlcfg_new->lcfg_flags = lcfg->lcfg_flags;\r\nif (lcfg->lcfg_nal != 0 &&\r\n(lcfg->lcfg_nid >> 32) == 0) {\r\n__u32 addr = (__u32)(lcfg->lcfg_nid & 0xffffffff);\r\nlcfg_new->lcfg_nid =\r\nLNET_MKNID(LNET_MKNET(lcfg->lcfg_nal, 0), addr);\r\nCWARN("Converted pre-newconfig NAL %d NID %x to %s\n",\r\nlcfg->lcfg_nal, addr,\r\nlibcfs_nid2str(lcfg_new->lcfg_nid));\r\n} else {\r\nlcfg_new->lcfg_nid = lcfg->lcfg_nid;\r\n}\r\nlcfg_new->lcfg_nal = 0;\r\nrc = class_process_config(lcfg_new);\r\nlustre_cfg_free(lcfg_new);\r\nif (inst)\r\nOBD_FREE(inst_name, inst_len);\r\nbreak;\r\n}\r\ndefault:\r\nCERROR("Unknown llog record type %#x encountered\n",\r\nrec->lrh_type);\r\nbreak;\r\n}\r\nout:\r\nif (rc) {\r\nCERROR("%s: cfg command failed: rc = %d\n",\r\nhandle->lgh_ctxt->loc_obd->obd_name, rc);\r\nclass_config_dump_handler(NULL, handle, rec, data);\r\n}\r\nreturn rc;\r\n}\r\nint class_config_parse_llog(const struct lu_env *env, struct llog_ctxt *ctxt,\r\nchar *name, struct config_llog_instance *cfg)\r\n{\r\nstruct llog_process_cat_data cd = {0, 0};\r\nstruct llog_handle *llh;\r\nllog_cb_t callback;\r\nint rc;\r\nCDEBUG(D_INFO, "looking up llog %s\n", name);\r\nrc = llog_open(env, ctxt, &llh, NULL, name, LLOG_OPEN_EXISTS);\r\nif (rc)\r\nreturn rc;\r\nrc = llog_init_handle(env, llh, LLOG_F_IS_PLAIN, NULL);\r\nif (rc)\r\ngoto parse_out;\r\nif (cfg) {\r\ncd.lpcd_first_idx = cfg->cfg_last_idx;\r\ncallback = cfg->cfg_callback;\r\nLASSERT(callback != NULL);\r\n} else {\r\ncallback = class_config_llog_handler;\r\n}\r\ncd.lpcd_last_idx = 0;\r\nrc = llog_process(env, llh, callback, cfg, &cd);\r\nCDEBUG(D_CONFIG, "Processed log %s gen %d-%d (rc=%d)\n", name,\r\ncd.lpcd_first_idx + 1, cd.lpcd_last_idx, rc);\r\nif (cfg)\r\ncfg->cfg_last_idx = cd.lpcd_last_idx;\r\nparse_out:\r\nllog_close(env, llh);\r\nreturn rc;\r\n}\r\nint class_config_parse_rec(struct llog_rec_hdr *rec, char *buf, int size)\r\n{\r\nstruct lustre_cfg *lcfg = (struct lustre_cfg *)(rec + 1);\r\nchar *ptr = buf;\r\nchar *end = buf + size;\r\nint rc = 0;\r\nLASSERT(rec->lrh_type == OBD_CFG_REC);\r\nrc = lustre_cfg_sanity_check(lcfg, rec->lrh_len);\r\nif (rc < 0)\r\nreturn rc;\r\nptr += snprintf(ptr, end-ptr, "cmd=%05x ", lcfg->lcfg_command);\r\nif (lcfg->lcfg_flags)\r\nptr += snprintf(ptr, end-ptr, "flags=%#08x ",\r\nlcfg->lcfg_flags);\r\nif (lcfg->lcfg_num)\r\nptr += snprintf(ptr, end-ptr, "num=%#08x ", lcfg->lcfg_num);\r\nif (lcfg->lcfg_nid)\r\nptr += snprintf(ptr, end-ptr, "nid=%s(%#llx)\n ",\r\nlibcfs_nid2str(lcfg->lcfg_nid),\r\nlcfg->lcfg_nid);\r\nif (lcfg->lcfg_command == LCFG_MARKER) {\r\nstruct cfg_marker *marker = lustre_cfg_buf(lcfg, 1);\r\nptr += snprintf(ptr, end-ptr, "marker=%d(%#x)%s '%s'",\r\nmarker->cm_step, marker->cm_flags,\r\nmarker->cm_tgtname, marker->cm_comment);\r\n} else {\r\nint i;\r\nfor (i = 0; i < lcfg->lcfg_bufcount; i++) {\r\nptr += snprintf(ptr, end-ptr, "%d:%s ", i,\r\nlustre_cfg_string(lcfg, i));\r\n}\r\n}\r\nrc = ptr - buf;\r\nreturn rc;\r\n}\r\nint class_config_dump_handler(const struct lu_env *env,\r\nstruct llog_handle *handle,\r\nstruct llog_rec_hdr *rec, void *data)\r\n{\r\nchar *outstr;\r\nint rc = 0;\r\nOBD_ALLOC(outstr, 256);\r\nif (outstr == NULL)\r\nreturn -ENOMEM;\r\nif (rec->lrh_type == OBD_CFG_REC) {\r\nclass_config_parse_rec(rec, outstr, 256);\r\nLCONSOLE(D_WARNING, " %s\n", outstr);\r\n} else {\r\nLCONSOLE(D_WARNING, "unhandled lrh_type: %#x\n", rec->lrh_type);\r\nrc = -EINVAL;\r\n}\r\nOBD_FREE(outstr, 256);\r\nreturn rc;\r\n}\r\nint class_config_dump_llog(const struct lu_env *env, struct llog_ctxt *ctxt,\r\nchar *name, struct config_llog_instance *cfg)\r\n{\r\nstruct llog_handle *llh;\r\nint rc;\r\nLCONSOLE_INFO("Dumping config log %s\n", name);\r\nrc = llog_open(env, ctxt, &llh, NULL, name, LLOG_OPEN_EXISTS);\r\nif (rc)\r\nreturn rc;\r\nrc = llog_init_handle(env, llh, LLOG_F_IS_PLAIN, NULL);\r\nif (rc)\r\ngoto parse_out;\r\nrc = llog_process(env, llh, class_config_dump_handler, cfg, NULL);\r\nparse_out:\r\nllog_close(env, llh);\r\nLCONSOLE_INFO("End config log %s\n", name);\r\nreturn rc;\r\n}\r\nint class_manual_cleanup(struct obd_device *obd)\r\n{\r\nchar flags[3] = "";\r\nstruct lustre_cfg *lcfg;\r\nstruct lustre_cfg_bufs bufs;\r\nint rc;\r\nif (!obd) {\r\nCERROR("empty cleanup\n");\r\nreturn -EALREADY;\r\n}\r\nif (obd->obd_force)\r\nstrcat(flags, "F");\r\nif (obd->obd_fail)\r\nstrcat(flags, "A");\r\nCDEBUG(D_CONFIG, "Manual cleanup of %s (flags='%s')\n",\r\nobd->obd_name, flags);\r\nlustre_cfg_bufs_reset(&bufs, obd->obd_name);\r\nlustre_cfg_bufs_set_string(&bufs, 1, flags);\r\nlcfg = lustre_cfg_new(LCFG_CLEANUP, &bufs);\r\nif (!lcfg)\r\nreturn -ENOMEM;\r\nrc = class_process_config(lcfg);\r\nif (rc) {\r\nCERROR("cleanup failed %d: %s\n", rc, obd->obd_name);\r\ngoto out;\r\n}\r\nlcfg->lcfg_command = LCFG_DETACH;\r\nrc = class_process_config(lcfg);\r\nif (rc)\r\nCERROR("detach failed %d: %s\n", rc, obd->obd_name);\r\nout:\r\nlustre_cfg_free(lcfg);\r\nreturn rc;\r\n}\r\nstatic unsigned\r\nuuid_hash(struct cfs_hash *hs, const void *key, unsigned mask)\r\n{\r\nreturn cfs_hash_djb2_hash(((struct obd_uuid *)key)->uuid,\r\nsizeof(((struct obd_uuid *)key)->uuid), mask);\r\n}\r\nstatic void *\r\nuuid_key(struct hlist_node *hnode)\r\n{\r\nstruct obd_export *exp;\r\nexp = hlist_entry(hnode, struct obd_export, exp_uuid_hash);\r\nreturn &exp->exp_client_uuid;\r\n}\r\nstatic int\r\nuuid_keycmp(const void *key, struct hlist_node *hnode)\r\n{\r\nstruct obd_export *exp;\r\nLASSERT(key);\r\nexp = hlist_entry(hnode, struct obd_export, exp_uuid_hash);\r\nreturn obd_uuid_equals(key, &exp->exp_client_uuid) &&\r\n!exp->exp_failed;\r\n}\r\nstatic void *\r\nuuid_export_object(struct hlist_node *hnode)\r\n{\r\nreturn hlist_entry(hnode, struct obd_export, exp_uuid_hash);\r\n}\r\nstatic void\r\nuuid_export_get(struct cfs_hash *hs, struct hlist_node *hnode)\r\n{\r\nstruct obd_export *exp;\r\nexp = hlist_entry(hnode, struct obd_export, exp_uuid_hash);\r\nclass_export_get(exp);\r\n}\r\nstatic void\r\nuuid_export_put_locked(struct cfs_hash *hs, struct hlist_node *hnode)\r\n{\r\nstruct obd_export *exp;\r\nexp = hlist_entry(hnode, struct obd_export, exp_uuid_hash);\r\nclass_export_put(exp);\r\n}\r\nstatic unsigned\r\nnid_hash(struct cfs_hash *hs, const void *key, unsigned mask)\r\n{\r\nreturn cfs_hash_djb2_hash(key, sizeof(lnet_nid_t), mask);\r\n}\r\nstatic void *\r\nnid_key(struct hlist_node *hnode)\r\n{\r\nstruct obd_export *exp;\r\nexp = hlist_entry(hnode, struct obd_export, exp_nid_hash);\r\nreturn &exp->exp_connection->c_peer.nid;\r\n}\r\nstatic int\r\nnid_kepcmp(const void *key, struct hlist_node *hnode)\r\n{\r\nstruct obd_export *exp;\r\nLASSERT(key);\r\nexp = hlist_entry(hnode, struct obd_export, exp_nid_hash);\r\nreturn exp->exp_connection->c_peer.nid == *(lnet_nid_t *)key &&\r\n!exp->exp_failed;\r\n}\r\nstatic void *\r\nnid_export_object(struct hlist_node *hnode)\r\n{\r\nreturn hlist_entry(hnode, struct obd_export, exp_nid_hash);\r\n}\r\nstatic void\r\nnid_export_get(struct cfs_hash *hs, struct hlist_node *hnode)\r\n{\r\nstruct obd_export *exp;\r\nexp = hlist_entry(hnode, struct obd_export, exp_nid_hash);\r\nclass_export_get(exp);\r\n}\r\nstatic void\r\nnid_export_put_locked(struct cfs_hash *hs, struct hlist_node *hnode)\r\n{\r\nstruct obd_export *exp;\r\nexp = hlist_entry(hnode, struct obd_export, exp_nid_hash);\r\nclass_export_put(exp);\r\n}\r\nstatic void *\r\nnidstats_key(struct hlist_node *hnode)\r\n{\r\nstruct nid_stat *ns;\r\nns = hlist_entry(hnode, struct nid_stat, nid_hash);\r\nreturn &ns->nid;\r\n}\r\nstatic int\r\nnidstats_keycmp(const void *key, struct hlist_node *hnode)\r\n{\r\nreturn *(lnet_nid_t *)nidstats_key(hnode) == *(lnet_nid_t *)key;\r\n}\r\nstatic void *\r\nnidstats_object(struct hlist_node *hnode)\r\n{\r\nreturn hlist_entry(hnode, struct nid_stat, nid_hash);\r\n}\r\nstatic void\r\nnidstats_get(struct cfs_hash *hs, struct hlist_node *hnode)\r\n{\r\nstruct nid_stat *ns;\r\nns = hlist_entry(hnode, struct nid_stat, nid_hash);\r\nnidstat_getref(ns);\r\n}\r\nstatic void\r\nnidstats_put_locked(struct cfs_hash *hs, struct hlist_node *hnode)\r\n{\r\nstruct nid_stat *ns;\r\nns = hlist_entry(hnode, struct nid_stat, nid_hash);\r\nnidstat_putref(ns);\r\n}
