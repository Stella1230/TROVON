static void ipoib_mcast_free(struct ipoib_mcast *mcast)\r\n{\r\nstruct net_device *dev = mcast->dev;\r\nint tx_dropped = 0;\r\nipoib_dbg_mcast(netdev_priv(dev), "deleting multicast group %pI6\n",\r\nmcast->mcmember.mgid.raw);\r\nipoib_del_neighs_by_gid(dev, mcast->mcmember.mgid.raw);\r\nif (mcast->ah)\r\nipoib_put_ah(mcast->ah);\r\nwhile (!skb_queue_empty(&mcast->pkt_queue)) {\r\n++tx_dropped;\r\ndev_kfree_skb_any(skb_dequeue(&mcast->pkt_queue));\r\n}\r\nnetif_tx_lock_bh(dev);\r\ndev->stats.tx_dropped += tx_dropped;\r\nnetif_tx_unlock_bh(dev);\r\nkfree(mcast);\r\n}\r\nstatic struct ipoib_mcast *ipoib_mcast_alloc(struct net_device *dev,\r\nint can_sleep)\r\n{\r\nstruct ipoib_mcast *mcast;\r\nmcast = kzalloc(sizeof *mcast, can_sleep ? GFP_KERNEL : GFP_ATOMIC);\r\nif (!mcast)\r\nreturn NULL;\r\nmcast->dev = dev;\r\nmcast->created = jiffies;\r\nmcast->backoff = 1;\r\nINIT_LIST_HEAD(&mcast->list);\r\nINIT_LIST_HEAD(&mcast->neigh_list);\r\nskb_queue_head_init(&mcast->pkt_queue);\r\nreturn mcast;\r\n}\r\nstatic struct ipoib_mcast *__ipoib_mcast_find(struct net_device *dev, void *mgid)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct rb_node *n = priv->multicast_tree.rb_node;\r\nwhile (n) {\r\nstruct ipoib_mcast *mcast;\r\nint ret;\r\nmcast = rb_entry(n, struct ipoib_mcast, rb_node);\r\nret = memcmp(mgid, mcast->mcmember.mgid.raw,\r\nsizeof (union ib_gid));\r\nif (ret < 0)\r\nn = n->rb_left;\r\nelse if (ret > 0)\r\nn = n->rb_right;\r\nelse\r\nreturn mcast;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int __ipoib_mcast_add(struct net_device *dev, struct ipoib_mcast *mcast)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct rb_node **n = &priv->multicast_tree.rb_node, *pn = NULL;\r\nwhile (*n) {\r\nstruct ipoib_mcast *tmcast;\r\nint ret;\r\npn = *n;\r\ntmcast = rb_entry(pn, struct ipoib_mcast, rb_node);\r\nret = memcmp(mcast->mcmember.mgid.raw, tmcast->mcmember.mgid.raw,\r\nsizeof (union ib_gid));\r\nif (ret < 0)\r\nn = &pn->rb_left;\r\nelse if (ret > 0)\r\nn = &pn->rb_right;\r\nelse\r\nreturn -EEXIST;\r\n}\r\nrb_link_node(&mcast->rb_node, pn, n);\r\nrb_insert_color(&mcast->rb_node, &priv->multicast_tree);\r\nreturn 0;\r\n}\r\nstatic int ipoib_mcast_join_finish(struct ipoib_mcast *mcast,\r\nstruct ib_sa_mcmember_rec *mcmember)\r\n{\r\nstruct net_device *dev = mcast->dev;\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ipoib_ah *ah;\r\nint ret;\r\nint set_qkey = 0;\r\nmcast->mcmember = *mcmember;\r\nif (!memcmp(mcast->mcmember.mgid.raw, priv->dev->broadcast + 4,\r\nsizeof (union ib_gid))) {\r\nspin_lock_irq(&priv->lock);\r\nif (!priv->broadcast) {\r\nspin_unlock_irq(&priv->lock);\r\nreturn -EAGAIN;\r\n}\r\npriv->mcast_mtu = IPOIB_UD_MTU(ib_mtu_enum_to_int(priv->broadcast->mcmember.mtu));\r\npriv->qkey = be32_to_cpu(priv->broadcast->mcmember.qkey);\r\nspin_unlock_irq(&priv->lock);\r\npriv->tx_wr.wr.ud.remote_qkey = priv->qkey;\r\nset_qkey = 1;\r\nif (!ipoib_cm_admin_enabled(dev)) {\r\nrtnl_lock();\r\ndev_set_mtu(dev, min(priv->mcast_mtu, priv->admin_mtu));\r\nrtnl_unlock();\r\n}\r\n}\r\nif (!test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags)) {\r\nif (test_and_set_bit(IPOIB_MCAST_FLAG_ATTACHED, &mcast->flags)) {\r\nipoib_warn(priv, "multicast group %pI6 already attached\n",\r\nmcast->mcmember.mgid.raw);\r\nreturn 0;\r\n}\r\nret = ipoib_mcast_attach(dev, be16_to_cpu(mcast->mcmember.mlid),\r\n&mcast->mcmember.mgid, set_qkey);\r\nif (ret < 0) {\r\nipoib_warn(priv, "couldn't attach QP to multicast group %pI6\n",\r\nmcast->mcmember.mgid.raw);\r\nclear_bit(IPOIB_MCAST_FLAG_ATTACHED, &mcast->flags);\r\nreturn ret;\r\n}\r\n}\r\n{\r\nstruct ib_ah_attr av = {\r\n.dlid = be16_to_cpu(mcast->mcmember.mlid),\r\n.port_num = priv->port,\r\n.sl = mcast->mcmember.sl,\r\n.ah_flags = IB_AH_GRH,\r\n.static_rate = mcast->mcmember.rate,\r\n.grh = {\r\n.flow_label = be32_to_cpu(mcast->mcmember.flow_label),\r\n.hop_limit = mcast->mcmember.hop_limit,\r\n.sgid_index = 0,\r\n.traffic_class = mcast->mcmember.traffic_class\r\n}\r\n};\r\nav.grh.dgid = mcast->mcmember.mgid;\r\nah = ipoib_create_ah(dev, priv->pd, &av);\r\nif (IS_ERR(ah)) {\r\nipoib_warn(priv, "ib_address_create failed %ld\n",\r\n-PTR_ERR(ah));\r\nreturn PTR_ERR(ah);\r\n} else {\r\nspin_lock_irq(&priv->lock);\r\nmcast->ah = ah;\r\nspin_unlock_irq(&priv->lock);\r\nipoib_dbg_mcast(priv, "MGID %pI6 AV %p, LID 0x%04x, SL %d\n",\r\nmcast->mcmember.mgid.raw,\r\nmcast->ah->ah,\r\nbe16_to_cpu(mcast->mcmember.mlid),\r\nmcast->mcmember.sl);\r\n}\r\n}\r\nnetif_tx_lock_bh(dev);\r\nwhile (!skb_queue_empty(&mcast->pkt_queue)) {\r\nstruct sk_buff *skb = skb_dequeue(&mcast->pkt_queue);\r\nnetif_tx_unlock_bh(dev);\r\nskb->dev = dev;\r\nif (dev_queue_xmit(skb))\r\nipoib_warn(priv, "dev_queue_xmit failed to requeue packet\n");\r\nnetif_tx_lock_bh(dev);\r\n}\r\nnetif_tx_unlock_bh(dev);\r\nreturn 0;\r\n}\r\nstatic int\r\nipoib_mcast_sendonly_join_complete(int status,\r\nstruct ib_sa_multicast *multicast)\r\n{\r\nstruct ipoib_mcast *mcast = multicast->context;\r\nstruct net_device *dev = mcast->dev;\r\nif (status == -ENETRESET)\r\nreturn 0;\r\nif (!status)\r\nstatus = ipoib_mcast_join_finish(mcast, &multicast->rec);\r\nif (status) {\r\nif (mcast->logcount++ < 20)\r\nipoib_dbg_mcast(netdev_priv(dev), "multicast join failed for %pI6, status %d\n",\r\nmcast->mcmember.mgid.raw, status);\r\nnetif_tx_lock_bh(dev);\r\nwhile (!skb_queue_empty(&mcast->pkt_queue)) {\r\n++dev->stats.tx_dropped;\r\ndev_kfree_skb_any(skb_dequeue(&mcast->pkt_queue));\r\n}\r\nnetif_tx_unlock_bh(dev);\r\nstatus = test_and_clear_bit(IPOIB_MCAST_FLAG_BUSY,\r\n&mcast->flags);\r\n}\r\nreturn status;\r\n}\r\nstatic int ipoib_mcast_sendonly_join(struct ipoib_mcast *mcast)\r\n{\r\nstruct net_device *dev = mcast->dev;\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ib_sa_mcmember_rec rec = {\r\n#if 0\r\n.join_state = 4\r\n#else\r\n.join_state = 1\r\n#endif\r\n};\r\nint ret = 0;\r\nif (!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags)) {\r\nipoib_dbg_mcast(priv, "device shutting down, no multicast joins\n");\r\nreturn -ENODEV;\r\n}\r\nif (test_and_set_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags)) {\r\nipoib_dbg_mcast(priv, "multicast entry busy, skipping\n");\r\nreturn -EBUSY;\r\n}\r\nrec.mgid = mcast->mcmember.mgid;\r\nrec.port_gid = priv->local_gid;\r\nrec.pkey = cpu_to_be16(priv->pkey);\r\nmcast->mc = ib_sa_join_multicast(&ipoib_sa_client, priv->ca,\r\npriv->port, &rec,\r\nIB_SA_MCMEMBER_REC_MGID |\r\nIB_SA_MCMEMBER_REC_PORT_GID |\r\nIB_SA_MCMEMBER_REC_PKEY |\r\nIB_SA_MCMEMBER_REC_JOIN_STATE,\r\nGFP_ATOMIC,\r\nipoib_mcast_sendonly_join_complete,\r\nmcast);\r\nif (IS_ERR(mcast->mc)) {\r\nret = PTR_ERR(mcast->mc);\r\nclear_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags);\r\nipoib_warn(priv, "ib_sa_join_multicast failed (ret = %d)\n",\r\nret);\r\n} else {\r\nipoib_dbg_mcast(priv, "no multicast record for %pI6, starting join\n",\r\nmcast->mcmember.mgid.raw);\r\n}\r\nreturn ret;\r\n}\r\nvoid ipoib_mcast_carrier_on_task(struct work_struct *work)\r\n{\r\nstruct ipoib_dev_priv *priv = container_of(work, struct ipoib_dev_priv,\r\ncarrier_on_task);\r\nstruct ib_port_attr attr;\r\nif (ib_query_port(priv->ca, priv->port, &attr) ||\r\nattr.state != IB_PORT_ACTIVE) {\r\nipoib_dbg(priv, "Keeping carrier off until IB port is active\n");\r\nreturn;\r\n}\r\nrtnl_lock();\r\nnetif_carrier_on(priv->dev);\r\nrtnl_unlock();\r\n}\r\nstatic int ipoib_mcast_join_complete(int status,\r\nstruct ib_sa_multicast *multicast)\r\n{\r\nstruct ipoib_mcast *mcast = multicast->context;\r\nstruct net_device *dev = mcast->dev;\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nipoib_dbg_mcast(priv, "join completion for %pI6 (status %d)\n",\r\nmcast->mcmember.mgid.raw, status);\r\nif (status == -ENETRESET) {\r\nstatus = 0;\r\ngoto out;\r\n}\r\nif (!status)\r\nstatus = ipoib_mcast_join_finish(mcast, &multicast->rec);\r\nif (!status) {\r\nmcast->backoff = 1;\r\nmutex_lock(&mcast_mutex);\r\nif (test_bit(IPOIB_MCAST_RUN, &priv->flags))\r\nqueue_delayed_work(ipoib_workqueue,\r\n&priv->mcast_task, 0);\r\nmutex_unlock(&mcast_mutex);\r\nif (mcast == priv->broadcast)\r\nqueue_work(ipoib_workqueue, &priv->carrier_on_task);\r\nstatus = 0;\r\ngoto out;\r\n}\r\nif (mcast->logcount++ < 20) {\r\nif (status == -ETIMEDOUT || status == -EAGAIN) {\r\nipoib_dbg_mcast(priv, "multicast join failed for %pI6, status %d\n",\r\nmcast->mcmember.mgid.raw, status);\r\n} else {\r\nipoib_warn(priv, "multicast join failed for %pI6, status %d\n",\r\nmcast->mcmember.mgid.raw, status);\r\n}\r\n}\r\nmcast->backoff *= 2;\r\nif (mcast->backoff > IPOIB_MAX_BACKOFF_SECONDS)\r\nmcast->backoff = IPOIB_MAX_BACKOFF_SECONDS;\r\nstatus = test_and_clear_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags);\r\nmutex_lock(&mcast_mutex);\r\nspin_lock_irq(&priv->lock);\r\nif (test_bit(IPOIB_MCAST_RUN, &priv->flags))\r\nqueue_delayed_work(ipoib_workqueue, &priv->mcast_task,\r\nmcast->backoff * HZ);\r\nspin_unlock_irq(&priv->lock);\r\nmutex_unlock(&mcast_mutex);\r\nout:\r\ncomplete(&mcast->done);\r\nreturn status;\r\n}\r\nstatic void ipoib_mcast_join(struct net_device *dev, struct ipoib_mcast *mcast,\r\nint create)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ib_sa_mcmember_rec rec = {\r\n.join_state = 1\r\n};\r\nib_sa_comp_mask comp_mask;\r\nint ret = 0;\r\nipoib_dbg_mcast(priv, "joining MGID %pI6\n", mcast->mcmember.mgid.raw);\r\nrec.mgid = mcast->mcmember.mgid;\r\nrec.port_gid = priv->local_gid;\r\nrec.pkey = cpu_to_be16(priv->pkey);\r\ncomp_mask =\r\nIB_SA_MCMEMBER_REC_MGID |\r\nIB_SA_MCMEMBER_REC_PORT_GID |\r\nIB_SA_MCMEMBER_REC_PKEY |\r\nIB_SA_MCMEMBER_REC_JOIN_STATE;\r\nif (create) {\r\ncomp_mask |=\r\nIB_SA_MCMEMBER_REC_QKEY |\r\nIB_SA_MCMEMBER_REC_MTU_SELECTOR |\r\nIB_SA_MCMEMBER_REC_MTU |\r\nIB_SA_MCMEMBER_REC_TRAFFIC_CLASS |\r\nIB_SA_MCMEMBER_REC_RATE_SELECTOR |\r\nIB_SA_MCMEMBER_REC_RATE |\r\nIB_SA_MCMEMBER_REC_SL |\r\nIB_SA_MCMEMBER_REC_FLOW_LABEL |\r\nIB_SA_MCMEMBER_REC_HOP_LIMIT;\r\nrec.qkey = priv->broadcast->mcmember.qkey;\r\nrec.mtu_selector = IB_SA_EQ;\r\nrec.mtu = priv->broadcast->mcmember.mtu;\r\nrec.traffic_class = priv->broadcast->mcmember.traffic_class;\r\nrec.rate_selector = IB_SA_EQ;\r\nrec.rate = priv->broadcast->mcmember.rate;\r\nrec.sl = priv->broadcast->mcmember.sl;\r\nrec.flow_label = priv->broadcast->mcmember.flow_label;\r\nrec.hop_limit = priv->broadcast->mcmember.hop_limit;\r\n}\r\nset_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags);\r\ninit_completion(&mcast->done);\r\nset_bit(IPOIB_MCAST_JOIN_STARTED, &mcast->flags);\r\nmcast->mc = ib_sa_join_multicast(&ipoib_sa_client, priv->ca, priv->port,\r\n&rec, comp_mask, GFP_KERNEL,\r\nipoib_mcast_join_complete, mcast);\r\nif (IS_ERR(mcast->mc)) {\r\nclear_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags);\r\ncomplete(&mcast->done);\r\nret = PTR_ERR(mcast->mc);\r\nipoib_warn(priv, "ib_sa_join_multicast failed, status %d\n", ret);\r\nmcast->backoff *= 2;\r\nif (mcast->backoff > IPOIB_MAX_BACKOFF_SECONDS)\r\nmcast->backoff = IPOIB_MAX_BACKOFF_SECONDS;\r\nmutex_lock(&mcast_mutex);\r\nif (test_bit(IPOIB_MCAST_RUN, &priv->flags))\r\nqueue_delayed_work(ipoib_workqueue,\r\n&priv->mcast_task,\r\nmcast->backoff * HZ);\r\nmutex_unlock(&mcast_mutex);\r\n}\r\n}\r\nvoid ipoib_mcast_join_task(struct work_struct *work)\r\n{\r\nstruct ipoib_dev_priv *priv =\r\ncontainer_of(work, struct ipoib_dev_priv, mcast_task.work);\r\nstruct net_device *dev = priv->dev;\r\nstruct ib_port_attr port_attr;\r\nif (!test_bit(IPOIB_MCAST_RUN, &priv->flags))\r\nreturn;\r\nif (ib_query_port(priv->ca, priv->port, &port_attr) ||\r\nport_attr.state != IB_PORT_ACTIVE) {\r\nipoib_dbg(priv, "port state is not ACTIVE (state = %d) suspending join task\n",\r\nport_attr.state);\r\nreturn;\r\n}\r\npriv->local_lid = port_attr.lid;\r\nif (ib_query_gid(priv->ca, priv->port, 0, &priv->local_gid))\r\nipoib_warn(priv, "ib_query_gid() failed\n");\r\nelse\r\nmemcpy(priv->dev->dev_addr + 4, priv->local_gid.raw, sizeof (union ib_gid));\r\nif (!priv->broadcast) {\r\nstruct ipoib_mcast *broadcast;\r\nif (!test_bit(IPOIB_FLAG_ADMIN_UP, &priv->flags))\r\nreturn;\r\nbroadcast = ipoib_mcast_alloc(dev, 1);\r\nif (!broadcast) {\r\nipoib_warn(priv, "failed to allocate broadcast group\n");\r\nmutex_lock(&mcast_mutex);\r\nif (test_bit(IPOIB_MCAST_RUN, &priv->flags))\r\nqueue_delayed_work(ipoib_workqueue,\r\n&priv->mcast_task, HZ);\r\nmutex_unlock(&mcast_mutex);\r\nreturn;\r\n}\r\nspin_lock_irq(&priv->lock);\r\nmemcpy(broadcast->mcmember.mgid.raw, priv->dev->broadcast + 4,\r\nsizeof (union ib_gid));\r\npriv->broadcast = broadcast;\r\n__ipoib_mcast_add(dev, priv->broadcast);\r\nspin_unlock_irq(&priv->lock);\r\n}\r\nif (!test_bit(IPOIB_MCAST_FLAG_ATTACHED, &priv->broadcast->flags)) {\r\nif (!test_bit(IPOIB_MCAST_FLAG_BUSY, &priv->broadcast->flags))\r\nipoib_mcast_join(dev, priv->broadcast, 0);\r\nreturn;\r\n}\r\nwhile (1) {\r\nstruct ipoib_mcast *mcast = NULL;\r\nspin_lock_irq(&priv->lock);\r\nlist_for_each_entry(mcast, &priv->multicast_list, list) {\r\nif (!test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags)\r\n&& !test_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags)\r\n&& !test_bit(IPOIB_MCAST_FLAG_ATTACHED, &mcast->flags)) {\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irq(&priv->lock);\r\nif (&mcast->list == &priv->multicast_list) {\r\nbreak;\r\n}\r\nipoib_mcast_join(dev, mcast, 1);\r\nreturn;\r\n}\r\nipoib_dbg_mcast(priv, "successfully joined all multicast groups\n");\r\nclear_bit(IPOIB_MCAST_RUN, &priv->flags);\r\n}\r\nint ipoib_mcast_start_thread(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nipoib_dbg_mcast(priv, "starting multicast thread\n");\r\nmutex_lock(&mcast_mutex);\r\nif (!test_and_set_bit(IPOIB_MCAST_RUN, &priv->flags))\r\nqueue_delayed_work(ipoib_workqueue, &priv->mcast_task, 0);\r\nmutex_unlock(&mcast_mutex);\r\nreturn 0;\r\n}\r\nint ipoib_mcast_stop_thread(struct net_device *dev, int flush)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nipoib_dbg_mcast(priv, "stopping multicast thread\n");\r\nmutex_lock(&mcast_mutex);\r\nclear_bit(IPOIB_MCAST_RUN, &priv->flags);\r\ncancel_delayed_work(&priv->mcast_task);\r\nmutex_unlock(&mcast_mutex);\r\nif (flush)\r\nflush_workqueue(ipoib_workqueue);\r\nreturn 0;\r\n}\r\nstatic int ipoib_mcast_leave(struct net_device *dev, struct ipoib_mcast *mcast)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nint ret = 0;\r\nif (test_and_clear_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags))\r\nib_sa_free_multicast(mcast->mc);\r\nif (test_and_clear_bit(IPOIB_MCAST_FLAG_ATTACHED, &mcast->flags)) {\r\nipoib_dbg_mcast(priv, "leaving MGID %pI6\n",\r\nmcast->mcmember.mgid.raw);\r\nret = ib_detach_mcast(priv->qp, &mcast->mcmember.mgid,\r\nbe16_to_cpu(mcast->mcmember.mlid));\r\nif (ret)\r\nipoib_warn(priv, "ib_detach_mcast failed (result = %d)\n", ret);\r\n}\r\nreturn 0;\r\n}\r\nvoid ipoib_mcast_send(struct net_device *dev, u8 *daddr, struct sk_buff *skb)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nstruct ipoib_mcast *mcast;\r\nunsigned long flags;\r\nvoid *mgid = daddr + 4;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags) ||\r\n!priv->broadcast ||\r\n!test_bit(IPOIB_MCAST_FLAG_ATTACHED, &priv->broadcast->flags)) {\r\n++dev->stats.tx_dropped;\r\ndev_kfree_skb_any(skb);\r\ngoto unlock;\r\n}\r\nmcast = __ipoib_mcast_find(dev, mgid);\r\nif (!mcast) {\r\nipoib_dbg_mcast(priv, "setting up send only multicast group for %pI6\n",\r\nmgid);\r\nmcast = ipoib_mcast_alloc(dev, 0);\r\nif (!mcast) {\r\nipoib_warn(priv, "unable to allocate memory for "\r\n"multicast structure\n");\r\n++dev->stats.tx_dropped;\r\ndev_kfree_skb_any(skb);\r\ngoto out;\r\n}\r\nset_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags);\r\nmemcpy(mcast->mcmember.mgid.raw, mgid, sizeof (union ib_gid));\r\n__ipoib_mcast_add(dev, mcast);\r\nlist_add_tail(&mcast->list, &priv->multicast_list);\r\n}\r\nif (!mcast->ah) {\r\nif (skb_queue_len(&mcast->pkt_queue) < IPOIB_MAX_MCAST_QUEUE)\r\nskb_queue_tail(&mcast->pkt_queue, skb);\r\nelse {\r\n++dev->stats.tx_dropped;\r\ndev_kfree_skb_any(skb);\r\n}\r\nif (test_bit(IPOIB_MCAST_FLAG_BUSY, &mcast->flags))\r\nipoib_dbg_mcast(priv, "no address vector, "\r\n"but multicast join already started\n");\r\nelse if (test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags))\r\nipoib_mcast_sendonly_join(mcast);\r\nmcast = NULL;\r\n}\r\nout:\r\nif (mcast && mcast->ah) {\r\nstruct ipoib_neigh *neigh;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nneigh = ipoib_neigh_get(dev, daddr);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (!neigh) {\r\nneigh = ipoib_neigh_alloc(daddr, dev);\r\nif (neigh) {\r\nkref_get(&mcast->ah->ref);\r\nneigh->ah = mcast->ah;\r\nlist_add_tail(&neigh->list, &mcast->neigh_list);\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nipoib_send(dev, skb, mcast->ah, IB_MULTICAST_QPN);\r\nif (neigh)\r\nipoib_neigh_put(neigh);\r\nreturn;\r\n}\r\nunlock:\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nvoid ipoib_mcast_dev_flush(struct net_device *dev)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(dev);\r\nLIST_HEAD(remove_list);\r\nstruct ipoib_mcast *mcast, *tmcast;\r\nunsigned long flags;\r\nipoib_dbg_mcast(priv, "flushing multicast list\n");\r\nspin_lock_irqsave(&priv->lock, flags);\r\nlist_for_each_entry_safe(mcast, tmcast, &priv->multicast_list, list) {\r\nlist_del(&mcast->list);\r\nrb_erase(&mcast->rb_node, &priv->multicast_tree);\r\nlist_add_tail(&mcast->list, &remove_list);\r\n}\r\nif (priv->broadcast) {\r\nrb_erase(&priv->broadcast->rb_node, &priv->multicast_tree);\r\nlist_add_tail(&priv->broadcast->list, &remove_list);\r\npriv->broadcast = NULL;\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nlist_for_each_entry_safe(mcast, tmcast, &remove_list, list)\r\nif (test_bit(IPOIB_MCAST_JOIN_STARTED, &mcast->flags))\r\nwait_for_completion(&mcast->done);\r\nlist_for_each_entry_safe(mcast, tmcast, &remove_list, list) {\r\nipoib_mcast_leave(dev, mcast);\r\nipoib_mcast_free(mcast);\r\n}\r\n}\r\nstatic int ipoib_mcast_addr_is_valid(const u8 *addr, const u8 *broadcast)\r\n{\r\nif (memcmp(addr, broadcast, 6))\r\nreturn 0;\r\nif (memcmp(addr + 7, broadcast + 7, 3))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid ipoib_mcast_restart_task(struct work_struct *work)\r\n{\r\nstruct ipoib_dev_priv *priv =\r\ncontainer_of(work, struct ipoib_dev_priv, restart_task);\r\nstruct net_device *dev = priv->dev;\r\nstruct netdev_hw_addr *ha;\r\nstruct ipoib_mcast *mcast, *tmcast;\r\nLIST_HEAD(remove_list);\r\nunsigned long flags;\r\nstruct ib_sa_mcmember_rec rec;\r\nipoib_dbg_mcast(priv, "restarting multicast task\n");\r\nipoib_mcast_stop_thread(dev, 0);\r\nlocal_irq_save(flags);\r\nnetif_addr_lock(dev);\r\nspin_lock(&priv->lock);\r\nlist_for_each_entry(mcast, &priv->multicast_list, list)\r\nclear_bit(IPOIB_MCAST_FLAG_FOUND, &mcast->flags);\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nunion ib_gid mgid;\r\nif (!ipoib_mcast_addr_is_valid(ha->addr, dev->broadcast))\r\ncontinue;\r\nmemcpy(mgid.raw, ha->addr + 4, sizeof mgid);\r\nmcast = __ipoib_mcast_find(dev, &mgid);\r\nif (!mcast || test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags)) {\r\nstruct ipoib_mcast *nmcast;\r\nif (test_bit(IPOIB_FLAG_UMCAST, &priv->flags) &&\r\n!ib_sa_get_mcmember_rec(priv->ca, priv->port, &mgid, &rec)) {\r\nipoib_dbg_mcast(priv, "ignoring multicast entry for mgid %pI6\n",\r\nmgid.raw);\r\ncontinue;\r\n}\r\nipoib_dbg_mcast(priv, "adding multicast entry for mgid %pI6\n",\r\nmgid.raw);\r\nnmcast = ipoib_mcast_alloc(dev, 0);\r\nif (!nmcast) {\r\nipoib_warn(priv, "unable to allocate memory for multicast structure\n");\r\ncontinue;\r\n}\r\nset_bit(IPOIB_MCAST_FLAG_FOUND, &nmcast->flags);\r\nnmcast->mcmember.mgid = mgid;\r\nif (mcast) {\r\nlist_move_tail(&mcast->list, &remove_list);\r\nrb_replace_node(&mcast->rb_node,\r\n&nmcast->rb_node,\r\n&priv->multicast_tree);\r\n} else\r\n__ipoib_mcast_add(dev, nmcast);\r\nlist_add_tail(&nmcast->list, &priv->multicast_list);\r\n}\r\nif (mcast)\r\nset_bit(IPOIB_MCAST_FLAG_FOUND, &mcast->flags);\r\n}\r\nlist_for_each_entry_safe(mcast, tmcast, &priv->multicast_list, list) {\r\nif (!test_bit(IPOIB_MCAST_FLAG_FOUND, &mcast->flags) &&\r\n!test_bit(IPOIB_MCAST_FLAG_SENDONLY, &mcast->flags)) {\r\nipoib_dbg_mcast(priv, "deleting multicast group %pI6\n",\r\nmcast->mcmember.mgid.raw);\r\nrb_erase(&mcast->rb_node, &priv->multicast_tree);\r\nlist_move_tail(&mcast->list, &remove_list);\r\n}\r\n}\r\nspin_unlock(&priv->lock);\r\nnetif_addr_unlock(dev);\r\nlocal_irq_restore(flags);\r\nlist_for_each_entry_safe(mcast, tmcast, &remove_list, list) {\r\nipoib_mcast_leave(mcast->dev, mcast);\r\nipoib_mcast_free(mcast);\r\n}\r\nif (test_bit(IPOIB_FLAG_ADMIN_UP, &priv->flags))\r\nipoib_mcast_start_thread(dev);\r\n}\r\nstruct ipoib_mcast_iter *ipoib_mcast_iter_init(struct net_device *dev)\r\n{\r\nstruct ipoib_mcast_iter *iter;\r\niter = kmalloc(sizeof *iter, GFP_KERNEL);\r\nif (!iter)\r\nreturn NULL;\r\niter->dev = dev;\r\nmemset(iter->mgid.raw, 0, 16);\r\nif (ipoib_mcast_iter_next(iter)) {\r\nkfree(iter);\r\nreturn NULL;\r\n}\r\nreturn iter;\r\n}\r\nint ipoib_mcast_iter_next(struct ipoib_mcast_iter *iter)\r\n{\r\nstruct ipoib_dev_priv *priv = netdev_priv(iter->dev);\r\nstruct rb_node *n;\r\nstruct ipoib_mcast *mcast;\r\nint ret = 1;\r\nspin_lock_irq(&priv->lock);\r\nn = rb_first(&priv->multicast_tree);\r\nwhile (n) {\r\nmcast = rb_entry(n, struct ipoib_mcast, rb_node);\r\nif (memcmp(iter->mgid.raw, mcast->mcmember.mgid.raw,\r\nsizeof (union ib_gid)) < 0) {\r\niter->mgid = mcast->mcmember.mgid;\r\niter->created = mcast->created;\r\niter->queuelen = skb_queue_len(&mcast->pkt_queue);\r\niter->complete = !!mcast->ah;\r\niter->send_only = !!(mcast->flags & (1 << IPOIB_MCAST_FLAG_SENDONLY));\r\nret = 0;\r\nbreak;\r\n}\r\nn = rb_next(n);\r\n}\r\nspin_unlock_irq(&priv->lock);\r\nreturn ret;\r\n}\r\nvoid ipoib_mcast_iter_read(struct ipoib_mcast_iter *iter,\r\nunion ib_gid *mgid,\r\nunsigned long *created,\r\nunsigned int *queuelen,\r\nunsigned int *complete,\r\nunsigned int *send_only)\r\n{\r\n*mgid = iter->mgid;\r\n*created = iter->created;\r\n*queuelen = iter->queuelen;\r\n*complete = iter->complete;\r\n*send_only = iter->send_only;\r\n}
