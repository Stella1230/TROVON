static void _ConfigNormalChipOutEP_8188E(struct adapter *adapt, u8 NumOutPipe)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(adapt);\r\nswitch (NumOutPipe) {\r\ncase 3:\r\nhaldata->OutEpQueueSel = TX_SELE_HQ | TX_SELE_LQ | TX_SELE_NQ;\r\nhaldata->OutEpNumber = 3;\r\nbreak;\r\ncase 2:\r\nhaldata->OutEpQueueSel = TX_SELE_HQ | TX_SELE_NQ;\r\nhaldata->OutEpNumber = 2;\r\nbreak;\r\ncase 1:\r\nhaldata->OutEpQueueSel = TX_SELE_HQ;\r\nhaldata->OutEpNumber = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nDBG_88E("%s OutEpQueueSel(0x%02x), OutEpNumber(%d)\n", __func__, haldata->OutEpQueueSel, haldata->OutEpNumber);\r\n}\r\nstatic bool HalUsbSetQueuePipeMapping8188EUsb(struct adapter *adapt, u8 NumInPipe, u8 NumOutPipe)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(adapt);\r\nbool result = false;\r\n_ConfigNormalChipOutEP_8188E(adapt, NumOutPipe);\r\nif (1 == haldata->OutEpNumber) {\r\nif (1 != NumInPipe)\r\nreturn result;\r\n}\r\nresult = Hal_MappingOutPipe(adapt, NumOutPipe);\r\nreturn result;\r\n}\r\nstatic void rtl8188eu_interface_configure(struct adapter *adapt)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(adapt);\r\nstruct dvobj_priv *pdvobjpriv = adapter_to_dvobj(adapt);\r\nif (pdvobjpriv->ishighspeed)\r\nhaldata->UsbBulkOutSize = USB_HIGH_SPEED_BULK_SIZE;\r\nelse\r\nhaldata->UsbBulkOutSize = USB_FULL_SPEED_BULK_SIZE;\r\nhaldata->interfaceIndex = pdvobjpriv->InterfaceNumber;\r\nhaldata->UsbTxAggMode = 1;\r\nhaldata->UsbTxAggDescNum = 0x6;\r\nhaldata->UsbRxAggMode = USB_RX_AGG_DMA;\r\nhaldata->UsbRxAggBlockCount = 8;\r\nhaldata->UsbRxAggBlockTimeout = 0x6;\r\nhaldata->UsbRxAggPageCount = 48;\r\nhaldata->UsbRxAggPageTimeout = 0x4;\r\nHalUsbSetQueuePipeMapping8188EUsb(adapt,\r\npdvobjpriv->RtNumInPipes, pdvobjpriv->RtNumOutPipes);\r\n}\r\nstatic u32 rtl8188eu_InitPowerOn(struct adapter *adapt)\r\n{\r\nu16 value16;\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(adapt);\r\nif (haldata->bMacPwrCtrlOn)\r\nreturn _SUCCESS;\r\nif (!rtl88eu_pwrseqcmdparsing(adapt, PWR_CUT_ALL_MSK,\r\nPWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,\r\nRtl8188E_NIC_PWR_ON_FLOW)) {\r\nDBG_88E(KERN_ERR "%s: run power on flow fail\n", __func__);\r\nreturn _FAIL;\r\n}\r\nusb_write16(adapt, REG_CR, 0x00);\r\nvalue16 = usb_read16(adapt, REG_CR);\r\nvalue16 |= (HCI_TXDMA_EN | HCI_RXDMA_EN | TXDMA_EN | RXDMA_EN\r\n| PROTOCOL_EN | SCHEDULE_EN | ENSEC | CALTMR_EN);\r\nusb_write16(adapt, REG_CR, value16);\r\nhaldata->bMacPwrCtrlOn = true;\r\nreturn _SUCCESS;\r\n}\r\nstatic void _InitInterrupt(struct adapter *Adapter)\r\n{\r\nu32 imr, imr_ex;\r\nu8 usb_opt;\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(Adapter);\r\nusb_write32(Adapter, REG_HISR_88E, 0xFFFFFFFF);\r\nimr = IMR_PSTIMEOUT_88E | IMR_TBDER_88E | IMR_CPWM_88E | IMR_CPWM2_88E;\r\nusb_write32(Adapter, REG_HIMR_88E, imr);\r\nhaldata->IntrMask[0] = imr;\r\nimr_ex = IMR_TXERR_88E | IMR_RXERR_88E | IMR_TXFOVW_88E | IMR_RXFOVW_88E;\r\nusb_write32(Adapter, REG_HIMRE_88E, imr_ex);\r\nhaldata->IntrMask[1] = imr_ex;\r\nusb_opt = usb_read8(Adapter, REG_USB_SPECIAL_OPTION);\r\nif (!adapter_to_dvobj(Adapter)->ishighspeed)\r\nusb_opt = usb_opt & (~INT_BULK_SEL);\r\nelse\r\nusb_opt = usb_opt | (INT_BULK_SEL);\r\nusb_write8(Adapter, REG_USB_SPECIAL_OPTION, usb_opt);\r\n}\r\nstatic void _InitQueueReservedPage(struct adapter *Adapter)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(Adapter);\r\nstruct registry_priv *pregistrypriv = &Adapter->registrypriv;\r\nu32 numHQ = 0;\r\nu32 numLQ = 0;\r\nu32 numNQ = 0;\r\nu32 numPubQ;\r\nu32 value32;\r\nu8 value8;\r\nbool bWiFiConfig = pregistrypriv->wifi_spec;\r\nif (bWiFiConfig) {\r\nif (haldata->OutEpQueueSel & TX_SELE_HQ)\r\nnumHQ = 0x29;\r\nif (haldata->OutEpQueueSel & TX_SELE_LQ)\r\nnumLQ = 0x1C;\r\nif (haldata->OutEpQueueSel & TX_SELE_NQ)\r\nnumNQ = 0x1C;\r\nvalue8 = (u8)_NPQ(numNQ);\r\nusb_write8(Adapter, REG_RQPN_NPQ, value8);\r\nnumPubQ = 0xA8 - numHQ - numLQ - numNQ;\r\nvalue32 = _HPQ(numHQ) | _LPQ(numLQ) | _PUBQ(numPubQ) | LD_RQPN;\r\nusb_write32(Adapter, REG_RQPN, value32);\r\n} else {\r\nusb_write16(Adapter, REG_RQPN_NPQ, 0x0000);\r\nusb_write16(Adapter, REG_RQPN_NPQ, 0x0d);\r\nusb_write32(Adapter, REG_RQPN, 0x808E000d);\r\n}\r\n}\r\nstatic void _InitTxBufferBoundary(struct adapter *Adapter, u8 txpktbuf_bndy)\r\n{\r\nusb_write8(Adapter, REG_TXPKTBUF_BCNQ_BDNY, txpktbuf_bndy);\r\nusb_write8(Adapter, REG_TXPKTBUF_MGQ_BDNY, txpktbuf_bndy);\r\nusb_write8(Adapter, REG_TXPKTBUF_WMAC_LBK_BF_HD, txpktbuf_bndy);\r\nusb_write8(Adapter, REG_TRXFF_BNDY, txpktbuf_bndy);\r\nusb_write8(Adapter, REG_TDECTRL+1, txpktbuf_bndy);\r\n}\r\nstatic void _InitPageBoundary(struct adapter *Adapter)\r\n{\r\nu16 rxff_bndy = MAX_RX_DMA_BUFFER_SIZE_88E-1;\r\nusb_write16(Adapter, (REG_TRXFF_BNDY + 2), rxff_bndy);\r\n}\r\nstatic void _InitNormalChipRegPriority(struct adapter *Adapter, u16 beQ,\r\nu16 bkQ, u16 viQ, u16 voQ, u16 mgtQ,\r\nu16 hiQ)\r\n{\r\nu16 value16 = (usb_read16(Adapter, REG_TRXDMA_CTRL) & 0x7);\r\nvalue16 |= _TXDMA_BEQ_MAP(beQ) | _TXDMA_BKQ_MAP(bkQ) |\r\n_TXDMA_VIQ_MAP(viQ) | _TXDMA_VOQ_MAP(voQ) |\r\n_TXDMA_MGQ_MAP(mgtQ) | _TXDMA_HIQ_MAP(hiQ);\r\nusb_write16(Adapter, REG_TRXDMA_CTRL, value16);\r\n}\r\nstatic void _InitNormalChipOneOutEpPriority(struct adapter *Adapter)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(Adapter);\r\nu16 value = 0;\r\nswitch (haldata->OutEpQueueSel) {\r\ncase TX_SELE_HQ:\r\nvalue = QUEUE_HIGH;\r\nbreak;\r\ncase TX_SELE_LQ:\r\nvalue = QUEUE_LOW;\r\nbreak;\r\ncase TX_SELE_NQ:\r\nvalue = QUEUE_NORMAL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n_InitNormalChipRegPriority(Adapter, value, value, value, value,\r\nvalue, value);\r\n}\r\nstatic void _InitNormalChipTwoOutEpPriority(struct adapter *Adapter)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(Adapter);\r\nstruct registry_priv *pregistrypriv = &Adapter->registrypriv;\r\nu16 beQ, bkQ, viQ, voQ, mgtQ, hiQ;\r\nu16 valueHi = 0;\r\nu16 valueLow = 0;\r\nswitch (haldata->OutEpQueueSel) {\r\ncase (TX_SELE_HQ | TX_SELE_LQ):\r\nvalueHi = QUEUE_HIGH;\r\nvalueLow = QUEUE_LOW;\r\nbreak;\r\ncase (TX_SELE_NQ | TX_SELE_LQ):\r\nvalueHi = QUEUE_NORMAL;\r\nvalueLow = QUEUE_LOW;\r\nbreak;\r\ncase (TX_SELE_HQ | TX_SELE_NQ):\r\nvalueHi = QUEUE_HIGH;\r\nvalueLow = QUEUE_NORMAL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!pregistrypriv->wifi_spec) {\r\nbeQ = valueLow;\r\nbkQ = valueLow;\r\nviQ = valueHi;\r\nvoQ = valueHi;\r\nmgtQ = valueHi;\r\nhiQ = valueHi;\r\n} else {\r\nbeQ = valueLow;\r\nbkQ = valueHi;\r\nviQ = valueHi;\r\nvoQ = valueLow;\r\nmgtQ = valueHi;\r\nhiQ = valueHi;\r\n}\r\n_InitNormalChipRegPriority(Adapter, beQ, bkQ, viQ, voQ, mgtQ, hiQ);\r\n}\r\nstatic void _InitNormalChipThreeOutEpPriority(struct adapter *Adapter)\r\n{\r\nstruct registry_priv *pregistrypriv = &Adapter->registrypriv;\r\nu16 beQ, bkQ, viQ, voQ, mgtQ, hiQ;\r\nif (!pregistrypriv->wifi_spec) {\r\nbeQ = QUEUE_LOW;\r\nbkQ = QUEUE_LOW;\r\nviQ = QUEUE_NORMAL;\r\nvoQ = QUEUE_HIGH;\r\nmgtQ = QUEUE_HIGH;\r\nhiQ = QUEUE_HIGH;\r\n} else {\r\nbeQ = QUEUE_LOW;\r\nbkQ = QUEUE_NORMAL;\r\nviQ = QUEUE_NORMAL;\r\nvoQ = QUEUE_HIGH;\r\nmgtQ = QUEUE_HIGH;\r\nhiQ = QUEUE_HIGH;\r\n}\r\n_InitNormalChipRegPriority(Adapter, beQ, bkQ, viQ, voQ, mgtQ, hiQ);\r\n}\r\nstatic void _InitQueuePriority(struct adapter *Adapter)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(Adapter);\r\nswitch (haldata->OutEpNumber) {\r\ncase 1:\r\n_InitNormalChipOneOutEpPriority(Adapter);\r\nbreak;\r\ncase 2:\r\n_InitNormalChipTwoOutEpPriority(Adapter);\r\nbreak;\r\ncase 3:\r\n_InitNormalChipThreeOutEpPriority(Adapter);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void _InitNetworkType(struct adapter *Adapter)\r\n{\r\nu32 value32;\r\nvalue32 = usb_read32(Adapter, REG_CR);\r\nvalue32 = (value32 & ~MASK_NETTYPE) | _NETTYPE(NT_LINK_AP);\r\nusb_write32(Adapter, REG_CR, value32);\r\n}\r\nstatic void _InitTransferPageSize(struct adapter *Adapter)\r\n{\r\nu8 value8;\r\nvalue8 = _PSRX(PBP_128) | _PSTX(PBP_128);\r\nusb_write8(Adapter, REG_PBP, value8);\r\n}\r\nstatic void _InitDriverInfoSize(struct adapter *Adapter, u8 drvInfoSize)\r\n{\r\nusb_write8(Adapter, REG_RX_DRVINFO_SZ, drvInfoSize);\r\n}\r\nstatic void _InitWMACSetting(struct adapter *Adapter)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(Adapter);\r\nhaldata->ReceiveConfig = RCR_AAP | RCR_APM | RCR_AM | RCR_AB |\r\nRCR_CBSSID_DATA | RCR_CBSSID_BCN |\r\nRCR_APP_ICV | RCR_AMF | RCR_HTC_LOC_CTRL |\r\nRCR_APP_MIC | RCR_APP_PHYSTS;\r\nusb_write32(Adapter, REG_RCR, haldata->ReceiveConfig);\r\nusb_write32(Adapter, REG_MAR, 0xFFFFFFFF);\r\nusb_write32(Adapter, REG_MAR + 4, 0xFFFFFFFF);\r\n}\r\nstatic void _InitAdaptiveCtrl(struct adapter *Adapter)\r\n{\r\nu16 value16;\r\nu32 value32;\r\nvalue32 = usb_read32(Adapter, REG_RRSR);\r\nvalue32 &= ~RATE_BITMAP_ALL;\r\nvalue32 |= RATE_RRSR_CCK_ONLY_1M;\r\nusb_write32(Adapter, REG_RRSR, value32);\r\nvalue16 = _SPEC_SIFS_CCK(0x10) | _SPEC_SIFS_OFDM(0x10);\r\nusb_write16(Adapter, REG_SPEC_SIFS, value16);\r\nvalue16 = _LRL(0x30) | _SRL(0x30);\r\nusb_write16(Adapter, REG_RL, value16);\r\n}\r\nstatic void _InitEDCA(struct adapter *Adapter)\r\n{\r\nusb_write16(Adapter, REG_SPEC_SIFS, 0x100a);\r\nusb_write16(Adapter, REG_MAC_SPEC_SIFS, 0x100a);\r\nusb_write16(Adapter, REG_SIFS_CTX, 0x100a);\r\nusb_write16(Adapter, REG_SIFS_TRX, 0x100a);\r\nusb_write32(Adapter, REG_EDCA_BE_PARAM, 0x005EA42B);\r\nusb_write32(Adapter, REG_EDCA_BK_PARAM, 0x0000A44F);\r\nusb_write32(Adapter, REG_EDCA_VI_PARAM, 0x005EA324);\r\nusb_write32(Adapter, REG_EDCA_VO_PARAM, 0x002FA226);\r\n}\r\nstatic void _InitRDGSetting(struct adapter *Adapter)\r\n{\r\nusb_write8(Adapter, REG_RD_CTRL, 0xFF);\r\nusb_write16(Adapter, REG_RD_NAV_NXT, 0x200);\r\nusb_write8(Adapter, REG_RD_RESP_PKT_TH, 0x05);\r\n}\r\nstatic void _InitRxSetting(struct adapter *Adapter)\r\n{\r\nusb_write32(Adapter, REG_MACID, 0x87654321);\r\nusb_write32(Adapter, 0x0700, 0x87654321);\r\n}\r\nstatic void _InitRetryFunction(struct adapter *Adapter)\r\n{\r\nu8 value8;\r\nvalue8 = usb_read8(Adapter, REG_FWHW_TXQ_CTRL);\r\nvalue8 |= EN_AMPDU_RTY_NEW;\r\nusb_write8(Adapter, REG_FWHW_TXQ_CTRL, value8);\r\nusb_write8(Adapter, REG_ACKTO, 0x40);\r\n}\r\nstatic void usb_AggSettingTxUpdate(struct adapter *Adapter)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(Adapter);\r\nu32 value32;\r\nif (Adapter->registrypriv.wifi_spec)\r\nhaldata->UsbTxAggMode = false;\r\nif (haldata->UsbTxAggMode) {\r\nvalue32 = usb_read32(Adapter, REG_TDECTRL);\r\nvalue32 = value32 & ~(BLK_DESC_NUM_MASK << BLK_DESC_NUM_SHIFT);\r\nvalue32 |= ((haldata->UsbTxAggDescNum & BLK_DESC_NUM_MASK) << BLK_DESC_NUM_SHIFT);\r\nusb_write32(Adapter, REG_TDECTRL, value32);\r\n}\r\n}\r\nstatic void\r\nusb_AggSettingRxUpdate(\r\nstruct adapter *Adapter\r\n)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(Adapter);\r\nu8 valueDMA;\r\nu8 valueUSB;\r\nvalueDMA = usb_read8(Adapter, REG_TRXDMA_CTRL);\r\nvalueUSB = usb_read8(Adapter, REG_USB_SPECIAL_OPTION);\r\nswitch (haldata->UsbRxAggMode) {\r\ncase USB_RX_AGG_DMA:\r\nvalueDMA |= RXDMA_AGG_EN;\r\nvalueUSB &= ~USB_AGG_EN;\r\nbreak;\r\ncase USB_RX_AGG_USB:\r\nvalueDMA &= ~RXDMA_AGG_EN;\r\nvalueUSB |= USB_AGG_EN;\r\nbreak;\r\ncase USB_RX_AGG_MIX:\r\nvalueDMA |= RXDMA_AGG_EN;\r\nvalueUSB |= USB_AGG_EN;\r\nbreak;\r\ncase USB_RX_AGG_DISABLE:\r\ndefault:\r\nvalueDMA &= ~RXDMA_AGG_EN;\r\nvalueUSB &= ~USB_AGG_EN;\r\nbreak;\r\n}\r\nusb_write8(Adapter, REG_TRXDMA_CTRL, valueDMA);\r\nusb_write8(Adapter, REG_USB_SPECIAL_OPTION, valueUSB);\r\nswitch (haldata->UsbRxAggMode) {\r\ncase USB_RX_AGG_DMA:\r\nusb_write8(Adapter, REG_RXDMA_AGG_PG_TH, haldata->UsbRxAggPageCount);\r\nusb_write8(Adapter, REG_RXDMA_AGG_PG_TH+1, haldata->UsbRxAggPageTimeout);\r\nbreak;\r\ncase USB_RX_AGG_USB:\r\nusb_write8(Adapter, REG_USB_AGG_TH, haldata->UsbRxAggBlockCount);\r\nusb_write8(Adapter, REG_USB_AGG_TO, haldata->UsbRxAggBlockTimeout);\r\nbreak;\r\ncase USB_RX_AGG_MIX:\r\nusb_write8(Adapter, REG_RXDMA_AGG_PG_TH, haldata->UsbRxAggPageCount);\r\nusb_write8(Adapter, REG_RXDMA_AGG_PG_TH+1, (haldata->UsbRxAggPageTimeout & 0x1F));\r\nusb_write8(Adapter, REG_USB_AGG_TH, haldata->UsbRxAggBlockCount);\r\nusb_write8(Adapter, REG_USB_AGG_TO, haldata->UsbRxAggBlockTimeout);\r\nbreak;\r\ncase USB_RX_AGG_DISABLE:\r\ndefault:\r\nbreak;\r\n}\r\nswitch (PBP_128) {\r\ncase PBP_128:\r\nhaldata->HwRxPageSize = 128;\r\nbreak;\r\ncase PBP_64:\r\nhaldata->HwRxPageSize = 64;\r\nbreak;\r\ncase PBP_256:\r\nhaldata->HwRxPageSize = 256;\r\nbreak;\r\ncase PBP_512:\r\nhaldata->HwRxPageSize = 512;\r\nbreak;\r\ncase PBP_1024:\r\nhaldata->HwRxPageSize = 1024;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void InitUsbAggregationSetting(struct adapter *Adapter)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(Adapter);\r\nusb_AggSettingTxUpdate(Adapter);\r\nusb_AggSettingRxUpdate(Adapter);\r\nhaldata->UsbRxHighSpeedMode = false;\r\n}\r\nstatic void _InitBeaconParameters(struct adapter *Adapter)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(Adapter);\r\nusb_write16(Adapter, REG_BCN_CTRL, 0x1010);\r\nusb_write16(Adapter, REG_TBTT_PROHIBIT, 0x6404);\r\nusb_write8(Adapter, REG_DRVERLYINT, DRIVER_EARLY_INT_TIME);\r\nusb_write8(Adapter, REG_BCNDMATIM, BCN_DMA_ATIME_INT_TIME);\r\nusb_write16(Adapter, REG_BCNTCFG, 0x660F);\r\nhaldata->RegBcnCtrlVal = usb_read8(Adapter, REG_BCN_CTRL);\r\nhaldata->RegTxPause = usb_read8(Adapter, REG_TXPAUSE);\r\nhaldata->RegFwHwTxQCtrl = usb_read8(Adapter, REG_FWHW_TXQ_CTRL+2);\r\nhaldata->RegReg542 = usb_read8(Adapter, REG_TBTT_PROHIBIT+2);\r\nhaldata->RegCR_1 = usb_read8(Adapter, REG_CR+1);\r\n}\r\nstatic void _BeaconFunctionEnable(struct adapter *Adapter,\r\nbool Enable, bool Linked)\r\n{\r\nusb_write8(Adapter, REG_BCN_CTRL, (BIT4 | BIT3 | BIT1));\r\nusb_write8(Adapter, REG_RD_CTRL+1, 0x6F);\r\n}\r\nstatic void _BBTurnOnBlock(struct adapter *Adapter)\r\n{\r\nphy_set_bb_reg(Adapter, rFPGA0_RFMOD, bCCKEn, 0x1);\r\nphy_set_bb_reg(Adapter, rFPGA0_RFMOD, bOFDMEn, 0x1);\r\n}\r\nstatic void _InitAntenna_Selection(struct adapter *Adapter)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(Adapter);\r\nif (haldata->AntDivCfg == 0)\r\nreturn;\r\nDBG_88E("==> %s ....\n", __func__);\r\nusb_write32(Adapter, REG_LEDCFG0, usb_read32(Adapter, REG_LEDCFG0)|BIT23);\r\nphy_set_bb_reg(Adapter, rFPGA0_XAB_RFParameter, BIT13, 0x01);\r\nif (phy_query_bb_reg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300) == Antenna_A)\r\nhaldata->CurAntenna = Antenna_A;\r\nelse\r\nhaldata->CurAntenna = Antenna_B;\r\nDBG_88E("%s,Cur_ant:(%x)%s\n", __func__, haldata->CurAntenna, (haldata->CurAntenna == Antenna_A) ? "Antenna_A" : "Antenna_B");\r\n}\r\nenum rt_rf_power_state RfOnOffDetect(struct adapter *adapt)\r\n{\r\nu8 val8;\r\nenum rt_rf_power_state rfpowerstate = rf_off;\r\nif (adapt->pwrctrlpriv.bHWPowerdown) {\r\nval8 = usb_read8(adapt, REG_HSISR);\r\nDBG_88E("pwrdown, 0x5c(BIT7)=%02x\n", val8);\r\nrfpowerstate = (val8 & BIT7) ? rf_off : rf_on;\r\n} else {\r\nusb_write8(adapt, REG_MAC_PINMUX_CFG, usb_read8(adapt, REG_MAC_PINMUX_CFG)&~(BIT3));\r\nval8 = usb_read8(adapt, REG_GPIO_IO_SEL);\r\nDBG_88E("GPIO_IN=%02x\n", val8);\r\nrfpowerstate = (val8 & BIT3) ? rf_on : rf_off;\r\n}\r\nreturn rfpowerstate;\r\n}\r\nstatic u32 rtl8188eu_hal_init(struct adapter *Adapter)\r\n{\r\nu8 value8 = 0;\r\nu16 value16;\r\nu8 txpktbuf_bndy;\r\nu32 status = _SUCCESS;\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(Adapter);\r\nstruct pwrctrl_priv *pwrctrlpriv = &Adapter->pwrctrlpriv;\r\nstruct registry_priv *pregistrypriv = &Adapter->registrypriv;\r\nu32 init_start_time = jiffies;\r\n#define HAL_INIT_PROFILE_TAG(stage) do {} while (0)\r\nHAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_BEGIN);\r\nif (Adapter->pwrctrlpriv.bkeepfwalive) {\r\nif (haldata->odmpriv.RFCalibrateInfo.bIQKInitialized) {\r\nrtl88eu_phy_iq_calibrate(Adapter, true);\r\n} else {\r\nrtl88eu_phy_iq_calibrate(Adapter, false);\r\nhaldata->odmpriv.RFCalibrateInfo.bIQKInitialized = true;\r\n}\r\nODM_TXPowerTrackingCheck(&haldata->odmpriv);\r\nrtl88eu_phy_lc_calibrate(Adapter);\r\ngoto exit;\r\n}\r\nHAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_PW_ON);\r\nstatus = rtl8188eu_InitPowerOn(Adapter);\r\nif (status == _FAIL) {\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_err_, ("Failed to init power on!\n"));\r\ngoto exit;\r\n}\r\nhaldata->CurrentChannel = 6;\r\nif (pwrctrlpriv->reg_rfoff) {\r\npwrctrlpriv->rf_pwrstate = rf_off;\r\n}\r\nif (!pregistrypriv->wifi_spec) {\r\ntxpktbuf_bndy = TX_PAGE_BOUNDARY_88E;\r\n} else {\r\ntxpktbuf_bndy = WMM_NORMAL_TX_PAGE_BOUNDARY_88E;\r\n}\r\nHAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC01);\r\n_InitQueueReservedPage(Adapter);\r\n_InitQueuePriority(Adapter);\r\n_InitPageBoundary(Adapter);\r\n_InitTransferPageSize(Adapter);\r\n_InitTxBufferBoundary(Adapter, 0);\r\nHAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_DOWNLOAD_FW);\r\nif (Adapter->registrypriv.mp_mode == 1) {\r\n_InitRxSetting(Adapter);\r\nAdapter->bFWReady = false;\r\nhaldata->fw_ractrl = false;\r\n} else {\r\nstatus = rtl88eu_download_fw(Adapter);\r\nif (status) {\r\nDBG_88E("%s: Download Firmware failed!!\n", __func__);\r\nAdapter->bFWReady = false;\r\nhaldata->fw_ractrl = false;\r\nreturn status;\r\n} else {\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("Initializeadapt8192CSdio(): Download Firmware Success!!\n"));\r\nAdapter->bFWReady = true;\r\nhaldata->fw_ractrl = false;\r\n}\r\n}\r\nrtl8188e_InitializeFirmwareVars(Adapter);\r\nrtl88eu_phy_mac_config(Adapter);\r\nrtl88eu_phy_bb_config(Adapter);\r\nrtl88eu_phy_rf_config(Adapter);\r\nHAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_EFUSE_PATCH);\r\nstatus = rtl8188e_iol_efuse_patch(Adapter);\r\nif (status == _FAIL) {\r\nDBG_88E("%s rtl8188e_iol_efuse_patch failed\n", __func__);\r\ngoto exit;\r\n}\r\n_InitTxBufferBoundary(Adapter, txpktbuf_bndy);\r\nHAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_LLTT);\r\nstatus = InitLLTTable(Adapter, txpktbuf_bndy);\r\nif (status == _FAIL) {\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_err_, ("Failed to init LLT table\n"));\r\ngoto exit;\r\n}\r\nHAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC02);\r\n_InitDriverInfoSize(Adapter, DRVINFO_SZ);\r\n_InitInterrupt(Adapter);\r\nhal_init_macaddr(Adapter);\r\n_InitNetworkType(Adapter);\r\n_InitWMACSetting(Adapter);\r\n_InitAdaptiveCtrl(Adapter);\r\n_InitEDCA(Adapter);\r\n_InitRetryFunction(Adapter);\r\nInitUsbAggregationSetting(Adapter);\r\n_InitBeaconParameters(Adapter);\r\nvalue16 = usb_read16(Adapter, REG_CR);\r\nvalue16 |= (MACTXEN | MACRXEN);\r\nusb_write8(Adapter, REG_CR, value16);\r\nif (haldata->bRDGEnable)\r\n_InitRDGSetting(Adapter);\r\nvalue8 = usb_read8(Adapter, REG_TX_RPT_CTRL);\r\nusb_write8(Adapter, REG_TX_RPT_CTRL, (value8|BIT1|BIT0));\r\nusb_write8(Adapter, REG_TX_RPT_CTRL+1, 2);\r\nusb_write16(Adapter, REG_TX_RPT_TIME, 0xCdf0);\r\nusb_write8(Adapter, REG_EARLY_MODE_CONTROL, 0);\r\nusb_write16(Adapter, REG_PKT_VO_VI_LIFE_TIME, 0x0400);\r\nusb_write16(Adapter, REG_PKT_BE_BK_LIFE_TIME, 0x0400);\r\nhaldata->RfRegChnlVal[0] = phy_query_rf_reg(Adapter, (enum rf_radio_path)0, RF_CHNLBW, bRFRegOffsetMask);\r\nhaldata->RfRegChnlVal[1] = phy_query_rf_reg(Adapter, (enum rf_radio_path)1, RF_CHNLBW, bRFRegOffsetMask);\r\nHAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_TURN_ON_BLOCK);\r\n_BBTurnOnBlock(Adapter);\r\nHAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_SECURITY);\r\ninvalidate_cam_all(Adapter);\r\nHAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_MISC11);\r\nphy_set_tx_power_level(Adapter, haldata->CurrentChannel);\r\n_InitAntenna_Selection(Adapter);\r\nusb_write32(Adapter, REG_BAR_MODE_CTRL, 0x0201ffff);\r\nusb_write8(Adapter, REG_HWSEQ_CTRL, 0xFF);\r\nif (pregistrypriv->wifi_spec)\r\nusb_write16(Adapter, REG_FAST_EDCA_CTRL, 0);\r\nusb_write8(Adapter, 0x652, 0x0);\r\nHAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_INIT_HAL_DM);\r\nrtl8188e_InitHalDm(Adapter);\r\npwrctrlpriv->rf_pwrstate = rf_on;\r\nusb_write8(Adapter, REG_FWHW_TXQ_CTRL+1, 0x0F);\r\nusb_write8(Adapter, REG_EARLY_MODE_CONTROL+3, 0x01);\r\nusb_write16(Adapter, REG_TX_RPT_TIME, 0x3DF0);\r\nusb_write16(Adapter, REG_TXDMA_OFFSET_CHK, (usb_read16(Adapter, REG_TXDMA_OFFSET_CHK) | DROP_DATA_EN));\r\nHAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_IQK);\r\nif (pwrctrlpriv->rf_pwrstate == rf_on) {\r\nif (haldata->odmpriv.RFCalibrateInfo.bIQKInitialized) {\r\nrtl88eu_phy_iq_calibrate(Adapter, true);\r\n} else {\r\nrtl88eu_phy_iq_calibrate(Adapter, false);\r\nhaldata->odmpriv.RFCalibrateInfo.bIQKInitialized = true;\r\n}\r\nHAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_PW_TRACK);\r\nODM_TXPowerTrackingCheck(&haldata->odmpriv);\r\nHAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_LCK);\r\nrtl88eu_phy_lc_calibrate(Adapter);\r\n}\r\nusb_write8(Adapter, REG_USB_HRPWM, 0);\r\nusb_write32(Adapter, REG_FWHW_TXQ_CTRL, usb_read32(Adapter, REG_FWHW_TXQ_CTRL)|BIT(12));\r\nexit:\r\nHAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_END);\r\nDBG_88E("%s in %dms\n", __func__, rtw_get_passing_time_ms(init_start_time));\r\nreturn status;\r\n}\r\nstatic void CardDisableRTL8188EU(struct adapter *Adapter)\r\n{\r\nu8 val8;\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(Adapter);\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("CardDisableRTL8188EU\n"));\r\nval8 = usb_read8(Adapter, REG_TX_RPT_CTRL);\r\nusb_write8(Adapter, REG_TX_RPT_CTRL, val8&(~BIT1));\r\nusb_write8(Adapter, REG_CR, 0x0);\r\nrtl88eu_pwrseqcmdparsing(Adapter, PWR_CUT_ALL_MSK,\r\nPWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,\r\nRtl8188E_NIC_LPS_ENTER_FLOW);\r\nval8 = usb_read8(Adapter, REG_MCUFWDL);\r\nif ((val8 & RAM_DL_SEL) && Adapter->bFWReady) {\r\nval8 = usb_read8(Adapter, REG_SYS_FUNC_EN+1);\r\nval8 &= ~BIT(2);\r\nusb_write8(Adapter, REG_SYS_FUNC_EN+1, val8);\r\n}\r\nusb_write8(Adapter, REG_MCUFWDL, 0);\r\nval8 = usb_read8(Adapter, REG_32K_CTRL);\r\nusb_write8(Adapter, REG_32K_CTRL, val8&(~BIT0));\r\nrtl88eu_pwrseqcmdparsing(Adapter, PWR_CUT_ALL_MSK,\r\nPWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,\r\nRtl8188E_NIC_DISABLE_FLOW);\r\nval8 = usb_read8(Adapter, REG_RSV_CTRL+1);\r\nusb_write8(Adapter, REG_RSV_CTRL+1, (val8&(~BIT3)));\r\nval8 = usb_read8(Adapter, REG_RSV_CTRL+1);\r\nusb_write8(Adapter, REG_RSV_CTRL+1, val8|BIT3);\r\nval8 = usb_read8(Adapter, GPIO_IN);\r\nusb_write8(Adapter, GPIO_OUT, val8);\r\nusb_write8(Adapter, GPIO_IO_SEL, 0xFF);\r\nval8 = usb_read8(Adapter, REG_GPIO_IO_SEL);\r\nusb_write8(Adapter, REG_GPIO_IO_SEL, (val8<<4));\r\nval8 = usb_read8(Adapter, REG_GPIO_IO_SEL+1);\r\nusb_write8(Adapter, REG_GPIO_IO_SEL+1, val8|0x0F);\r\nusb_write32(Adapter, REG_BB_PAD_CTRL, 0x00080808);\r\nhaldata->bMacPwrCtrlOn = false;\r\nAdapter->bFWReady = false;\r\n}\r\nstatic void rtl8192cu_hw_power_down(struct adapter *adapt)\r\n{\r\nusb_write8(adapt, REG_RSV_CTRL, 0x0);\r\nusb_write16(adapt, REG_APS_FSMCO, 0x8812);\r\n}\r\nstatic u32 rtl8188eu_hal_deinit(struct adapter *Adapter)\r\n{\r\nDBG_88E("==> %s\n", __func__);\r\nusb_write32(Adapter, REG_HIMR_88E, IMR_DISABLED_88E);\r\nusb_write32(Adapter, REG_HIMRE_88E, IMR_DISABLED_88E);\r\nDBG_88E("bkeepfwalive(%x)\n", Adapter->pwrctrlpriv.bkeepfwalive);\r\nif (Adapter->pwrctrlpriv.bkeepfwalive) {\r\nif ((Adapter->pwrctrlpriv.bHWPwrPindetect) && (Adapter->pwrctrlpriv.bHWPowerdown))\r\nrtl8192cu_hw_power_down(Adapter);\r\n} else {\r\nif (Adapter->hw_init_completed) {\r\nCardDisableRTL8188EU(Adapter);\r\nif ((Adapter->pwrctrlpriv.bHWPwrPindetect) && (Adapter->pwrctrlpriv.bHWPowerdown))\r\nrtl8192cu_hw_power_down(Adapter);\r\n}\r\n}\r\nreturn _SUCCESS;\r\n}\r\nstatic unsigned int rtl8188eu_inirp_init(struct adapter *Adapter)\r\n{\r\nu8 i;\r\nstruct recv_buf *precvbuf;\r\nuint status;\r\nstruct recv_priv *precvpriv = &(Adapter->recvpriv);\r\nstatus = _SUCCESS;\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_,\r\n("===> usb_inirp_init\n"));\r\nprecvpriv->ff_hwaddr = RECV_BULK_IN_ADDR;\r\nprecvbuf = (struct recv_buf *)precvpriv->precv_buf;\r\nfor (i = 0; i < NR_RECVBUFF; i++) {\r\nif (usb_read_port(Adapter, precvpriv->ff_hwaddr, 0, (unsigned char *)precvbuf) == false) {\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_err_, ("usb_rx_init: usb_read_port error\n"));\r\nstatus = _FAIL;\r\ngoto exit;\r\n}\r\nprecvbuf++;\r\nprecvpriv->free_recv_buf_queue_cnt--;\r\n}\r\nexit:\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("<=== usb_inirp_init\n"));\r\nreturn status;\r\n}\r\nstatic unsigned int rtl8188eu_inirp_deinit(struct adapter *Adapter)\r\n{\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("\n ===> usb_rx_deinit\n"));\r\nusb_read_port_cancel(Adapter);\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("\n <=== usb_rx_deinit\n"));\r\nreturn _SUCCESS;\r\n}\r\nstatic void Hal_EfuseParsePIDVID_8188EU(struct adapter *adapt, u8 *hwinfo, bool AutoLoadFail)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(adapt);\r\nif (!AutoLoadFail) {\r\nhaldata->EEPROMVID = EF2BYTE(*(__le16 *)&hwinfo[EEPROM_VID_88EU]);\r\nhaldata->EEPROMPID = EF2BYTE(*(__le16 *)&hwinfo[EEPROM_PID_88EU]);\r\nhaldata->EEPROMCustomerID = *(u8 *)&hwinfo[EEPROM_CUSTOMERID_88E];\r\nhaldata->EEPROMSubCustomerID = EEPROM_Default_SubCustomerID;\r\n} else {\r\nhaldata->EEPROMVID = EEPROM_Default_VID;\r\nhaldata->EEPROMPID = EEPROM_Default_PID;\r\nhaldata->EEPROMCustomerID = EEPROM_Default_CustomerID;\r\nhaldata->EEPROMSubCustomerID = EEPROM_Default_SubCustomerID;\r\n}\r\nDBG_88E("VID = 0x%04X, PID = 0x%04X\n", haldata->EEPROMVID, haldata->EEPROMPID);\r\nDBG_88E("Customer ID: 0x%02X, SubCustomer ID: 0x%02X\n", haldata->EEPROMCustomerID, haldata->EEPROMSubCustomerID);\r\n}\r\nstatic void Hal_EfuseParseMACAddr_8188EU(struct adapter *adapt, u8 *hwinfo, bool AutoLoadFail)\r\n{\r\nu16 i;\r\nu8 sMacAddr[6] = {0x00, 0xE0, 0x4C, 0x81, 0x88, 0x02};\r\nstruct eeprom_priv *eeprom = GET_EEPROM_EFUSE_PRIV(adapt);\r\nif (AutoLoadFail) {\r\nfor (i = 0; i < 6; i++)\r\neeprom->mac_addr[i] = sMacAddr[i];\r\n} else {\r\nmemcpy(eeprom->mac_addr, &hwinfo[EEPROM_MAC_ADDR_88EU], ETH_ALEN);\r\n}\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_notice_,\r\n("Hal_EfuseParseMACAddr_8188EU: Permanent Address = %02x-%02x-%02x-%02x-%02x-%02x\n",\r\neeprom->mac_addr[0], eeprom->mac_addr[1],\r\neeprom->mac_addr[2], eeprom->mac_addr[3],\r\neeprom->mac_addr[4], eeprom->mac_addr[5]));\r\n}\r\nstatic void\r\nreadAdapterInfo_8188EU(\r\nstruct adapter *adapt\r\n)\r\n{\r\nstruct eeprom_priv *eeprom = GET_EEPROM_EFUSE_PRIV(adapt);\r\nHal_EfuseParseIDCode88E(adapt, eeprom->efuse_eeprom_data);\r\nHal_EfuseParsePIDVID_8188EU(adapt, eeprom->efuse_eeprom_data, eeprom->bautoload_fail_flag);\r\nHal_EfuseParseMACAddr_8188EU(adapt, eeprom->efuse_eeprom_data, eeprom->bautoload_fail_flag);\r\nHal_ReadPowerSavingMode88E(adapt, eeprom->efuse_eeprom_data, eeprom->bautoload_fail_flag);\r\nHal_ReadTxPowerInfo88E(adapt, eeprom->efuse_eeprom_data, eeprom->bautoload_fail_flag);\r\nHal_EfuseParseEEPROMVer88E(adapt, eeprom->efuse_eeprom_data, eeprom->bautoload_fail_flag);\r\nrtl8188e_EfuseParseChnlPlan(adapt, eeprom->efuse_eeprom_data, eeprom->bautoload_fail_flag);\r\nHal_EfuseParseXtal_8188E(adapt, eeprom->efuse_eeprom_data, eeprom->bautoload_fail_flag);\r\nHal_EfuseParseCustomerID88E(adapt, eeprom->efuse_eeprom_data, eeprom->bautoload_fail_flag);\r\nHal_ReadAntennaDiversity88E(adapt, eeprom->efuse_eeprom_data, eeprom->bautoload_fail_flag);\r\nHal_EfuseParseBoardType88E(adapt, eeprom->efuse_eeprom_data, eeprom->bautoload_fail_flag);\r\nHal_ReadThermalMeter_88E(adapt, eeprom->efuse_eeprom_data, eeprom->bautoload_fail_flag);\r\n}\r\nstatic void _ReadPROMContent(\r\nstruct adapter *Adapter\r\n)\r\n{\r\nstruct eeprom_priv *eeprom = GET_EEPROM_EFUSE_PRIV(Adapter);\r\nu8 eeValue;\r\neeValue = usb_read8(Adapter, REG_9346CR);\r\neeprom->EepromOrEfuse = (eeValue & BOOT_FROM_EEPROM) ? true : false;\r\neeprom->bautoload_fail_flag = (eeValue & EEPROM_EN) ? false : true;\r\nDBG_88E("Boot from %s, Autoload %s !\n", (eeprom->EepromOrEfuse ? "EEPROM" : "EFUSE"),\r\n(eeprom->bautoload_fail_flag ? "Fail" : "OK"));\r\nHal_InitPGData88E(Adapter);\r\nreadAdapterInfo_8188EU(Adapter);\r\n}\r\nstatic void _ReadRFType(struct adapter *Adapter)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(Adapter);\r\nhaldata->rf_chip = RF_6052;\r\n}\r\nstatic void _ReadAdapterInfo8188EU(struct adapter *Adapter)\r\n{\r\nu32 start = jiffies;\r\nMSG_88E("====> %s\n", __func__);\r\n_ReadRFType(Adapter);\r\n_ReadPROMContent(Adapter);\r\nMSG_88E("<==== %s in %d ms\n", __func__, rtw_get_passing_time_ms(start));\r\n}\r\nstatic void rtl8192cu_trigger_gpio_0(struct adapter *adapt)\r\n{\r\n}\r\nstatic void ResumeTxBeacon(struct adapter *adapt)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(adapt);\r\nusb_write8(adapt, REG_FWHW_TXQ_CTRL+2, (haldata->RegFwHwTxQCtrl) | BIT6);\r\nhaldata->RegFwHwTxQCtrl |= BIT6;\r\nusb_write8(adapt, REG_TBTT_PROHIBIT+1, 0xff);\r\nhaldata->RegReg542 |= BIT0;\r\nusb_write8(adapt, REG_TBTT_PROHIBIT+2, haldata->RegReg542);\r\n}\r\nstatic void StopTxBeacon(struct adapter *adapt)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(adapt);\r\nusb_write8(adapt, REG_FWHW_TXQ_CTRL+2, (haldata->RegFwHwTxQCtrl) & (~BIT6));\r\nhaldata->RegFwHwTxQCtrl &= (~BIT6);\r\nusb_write8(adapt, REG_TBTT_PROHIBIT+1, 0x64);\r\nhaldata->RegReg542 &= ~(BIT0);\r\nusb_write8(adapt, REG_TBTT_PROHIBIT+2, haldata->RegReg542);\r\n}\r\nstatic void hw_var_set_opmode(struct adapter *Adapter, u8 variable, u8 *val)\r\n{\r\nu8 val8;\r\nu8 mode = *((u8 *)val);\r\nusb_write8(Adapter, REG_BCN_CTRL, usb_read8(Adapter, REG_BCN_CTRL)|BIT(4));\r\nval8 = usb_read8(Adapter, MSR)&0x0c;\r\nval8 |= mode;\r\nusb_write8(Adapter, MSR, val8);\r\nDBG_88E("%s()-%d mode = %d\n", __func__, __LINE__, mode);\r\nif ((mode == _HW_STATE_STATION_) || (mode == _HW_STATE_NOLINK_)) {\r\nStopTxBeacon(Adapter);\r\nusb_write8(Adapter, REG_BCN_CTRL, 0x19);\r\n} else if ((mode == _HW_STATE_ADHOC_)) {\r\nResumeTxBeacon(Adapter);\r\nusb_write8(Adapter, REG_BCN_CTRL, 0x1a);\r\n} else if (mode == _HW_STATE_AP_) {\r\nResumeTxBeacon(Adapter);\r\nusb_write8(Adapter, REG_BCN_CTRL, 0x12);\r\nusb_write32(Adapter, REG_RCR, 0x7000208e);\r\nusb_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);\r\nusb_write16(Adapter, REG_RXFLTMAP1, 0x0400);\r\nusb_write8(Adapter, REG_BCNDMATIM, 0x02);\r\nusb_write8(Adapter, REG_ATIMWND, 0x0a);\r\nusb_write16(Adapter, REG_BCNTCFG, 0x00);\r\nusb_write16(Adapter, REG_TBTT_PROHIBIT, 0xff04);\r\nusb_write16(Adapter, REG_TSFTR_SYN_OFFSET, 0x7fff);\r\nusb_write8(Adapter, REG_DUAL_TSF_RST, BIT(0));\r\nusb_write8(Adapter, REG_MBID_NUM, usb_read8(Adapter, REG_MBID_NUM) | BIT(3) | BIT(4));\r\nusb_write8(Adapter, REG_BCN_CTRL, (DIS_TSF_UDT0_NORMAL_CHIP|EN_BCN_FUNCTION | BIT(1)));\r\nusb_write8(Adapter, REG_BCN_CTRL_1, usb_read8(Adapter, REG_BCN_CTRL_1) | BIT(0));\r\n}\r\n}\r\nstatic void hw_var_set_macaddr(struct adapter *Adapter, u8 variable, u8 *val)\r\n{\r\nu8 idx = 0;\r\nu32 reg_macid;\r\nreg_macid = REG_MACID;\r\nfor (idx = 0; idx < 6; idx++)\r\nusb_write8(Adapter, (reg_macid+idx), val[idx]);\r\n}\r\nstatic void hw_var_set_bssid(struct adapter *Adapter, u8 variable, u8 *val)\r\n{\r\nu8 idx = 0;\r\nu32 reg_bssid;\r\nreg_bssid = REG_BSSID;\r\nfor (idx = 0; idx < 6; idx++)\r\nusb_write8(Adapter, (reg_bssid+idx), val[idx]);\r\n}\r\nstatic void hw_var_set_bcn_func(struct adapter *Adapter, u8 variable, u8 *val)\r\n{\r\nu32 bcn_ctrl_reg;\r\nbcn_ctrl_reg = REG_BCN_CTRL;\r\nif (*((u8 *)val))\r\nusb_write8(Adapter, bcn_ctrl_reg, (EN_BCN_FUNCTION | EN_TXBCN_RPT));\r\nelse\r\nusb_write8(Adapter, bcn_ctrl_reg, usb_read8(Adapter, bcn_ctrl_reg)&(~(EN_BCN_FUNCTION | EN_TXBCN_RPT)));\r\n}\r\nstatic void SetHwReg8188EU(struct adapter *Adapter, u8 variable, u8 *val)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(Adapter);\r\nstruct dm_priv *pdmpriv = &haldata->dmpriv;\r\nstruct odm_dm_struct *podmpriv = &haldata->odmpriv;\r\nswitch (variable) {\r\ncase HW_VAR_MEDIA_STATUS:\r\n{\r\nu8 val8;\r\nval8 = usb_read8(Adapter, MSR)&0x0c;\r\nval8 |= *((u8 *)val);\r\nusb_write8(Adapter, MSR, val8);\r\n}\r\nbreak;\r\ncase HW_VAR_MEDIA_STATUS1:\r\n{\r\nu8 val8;\r\nval8 = usb_read8(Adapter, MSR) & 0x03;\r\nval8 |= *((u8 *)val) << 2;\r\nusb_write8(Adapter, MSR, val8);\r\n}\r\nbreak;\r\ncase HW_VAR_SET_OPMODE:\r\nhw_var_set_opmode(Adapter, variable, val);\r\nbreak;\r\ncase HW_VAR_MAC_ADDR:\r\nhw_var_set_macaddr(Adapter, variable, val);\r\nbreak;\r\ncase HW_VAR_BSSID:\r\nhw_var_set_bssid(Adapter, variable, val);\r\nbreak;\r\ncase HW_VAR_BASIC_RATE:\r\n{\r\nu16 BrateCfg = 0;\r\nu8 RateIndex = 0;\r\nHalSetBrateCfg(Adapter, val, &BrateCfg);\r\nDBG_88E("HW_VAR_BASIC_RATE: BrateCfg(%#x)\n", BrateCfg);\r\nBrateCfg = (BrateCfg | 0xd) & 0x15d;\r\nhaldata->BasicRateSet = BrateCfg;\r\nBrateCfg |= 0x01;\r\nusb_write8(Adapter, REG_RRSR, BrateCfg & 0xff);\r\nusb_write8(Adapter, REG_RRSR+1, (BrateCfg >> 8) & 0xff);\r\nusb_write8(Adapter, REG_RRSR+2, usb_read8(Adapter, REG_RRSR+2)&0xf0);\r\nwhile (BrateCfg > 0x1) {\r\nBrateCfg = (BrateCfg >> 1);\r\nRateIndex++;\r\n}\r\nusb_write8(Adapter, REG_INIRTS_RATE_SEL, RateIndex);\r\n}\r\nbreak;\r\ncase HW_VAR_TXPAUSE:\r\nusb_write8(Adapter, REG_TXPAUSE, *((u8 *)val));\r\nbreak;\r\ncase HW_VAR_BCN_FUNC:\r\nhw_var_set_bcn_func(Adapter, variable, val);\r\nbreak;\r\ncase HW_VAR_CORRECT_TSF:\r\n{\r\nu64 tsf;\r\nstruct mlme_ext_priv *pmlmeext = &Adapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\ntsf = pmlmeext->TSFValue - rtw_modular64(pmlmeext->TSFValue, (pmlmeinfo->bcn_interval*1024)) - 1024;\r\nif (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))\r\nStopTxBeacon(Adapter);\r\nusb_write8(Adapter, REG_BCN_CTRL, usb_read8(Adapter, REG_BCN_CTRL)&(~BIT(3)));\r\nusb_write32(Adapter, REG_TSFTR, tsf);\r\nusb_write32(Adapter, REG_TSFTR+4, tsf>>32);\r\nusb_write8(Adapter, REG_BCN_CTRL, usb_read8(Adapter, REG_BCN_CTRL)|BIT(3));\r\nif (((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE))\r\nResumeTxBeacon(Adapter);\r\n}\r\nbreak;\r\ncase HW_VAR_CHECK_BSSID:\r\nif (*((u8 *)val)) {\r\nusb_write32(Adapter, REG_RCR, usb_read32(Adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);\r\n} else {\r\nu32 val32;\r\nval32 = usb_read32(Adapter, REG_RCR);\r\nval32 &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN);\r\nusb_write32(Adapter, REG_RCR, val32);\r\n}\r\nbreak;\r\ncase HW_VAR_MLME_DISCONNECT:\r\nusb_write16(Adapter, REG_RXFLTMAP2, 0x00);\r\nusb_write8(Adapter, REG_DUAL_TSF_RST, (BIT(0)|BIT(1)));\r\nusb_write8(Adapter, REG_BCN_CTRL, usb_read8(Adapter, REG_BCN_CTRL)|BIT(4));\r\nbreak;\r\ncase HW_VAR_MLME_SITESURVEY:\r\nif (*((u8 *)val)) {\r\nu32 v = usb_read32(Adapter, REG_RCR);\r\nv &= ~(RCR_CBSSID_BCN);\r\nusb_write32(Adapter, REG_RCR, v);\r\nusb_write16(Adapter, REG_RXFLTMAP2, 0x00);\r\nusb_write8(Adapter, REG_BCN_CTRL, usb_read8(Adapter, REG_BCN_CTRL)|BIT(4));\r\n} else {\r\nstruct mlme_ext_priv *pmlmeext = &Adapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nif ((is_client_associated_to_ap(Adapter)) ||\r\n((pmlmeinfo->state&0x03) == WIFI_FW_ADHOC_STATE)) {\r\nusb_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);\r\nusb_write8(Adapter, REG_BCN_CTRL, usb_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));\r\n} else if ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) {\r\nusb_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);\r\nusb_write8(Adapter, REG_BCN_CTRL, usb_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));\r\n}\r\nif ((pmlmeinfo->state&0x03) == WIFI_FW_AP_STATE) {\r\nusb_write32(Adapter, REG_RCR, usb_read32(Adapter, REG_RCR)|RCR_CBSSID_BCN);\r\n} else {\r\nif (Adapter->in_cta_test) {\r\nu32 v = usb_read32(Adapter, REG_RCR);\r\nv &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN);\r\nusb_write32(Adapter, REG_RCR, v);\r\n} else {\r\nusb_write32(Adapter, REG_RCR, usb_read32(Adapter, REG_RCR)|RCR_CBSSID_BCN);\r\n}\r\n}\r\n}\r\nbreak;\r\ncase HW_VAR_MLME_JOIN:\r\n{\r\nu8 RetryLimit = 0x30;\r\nu8 type = *((u8 *)val);\r\nstruct mlme_priv *pmlmepriv = &Adapter->mlmepriv;\r\nif (type == 0) {\r\nusb_write16(Adapter, REG_RXFLTMAP2, 0xFFFF);\r\nif (Adapter->in_cta_test) {\r\nu32 v = usb_read32(Adapter, REG_RCR);\r\nv &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN);\r\nusb_write32(Adapter, REG_RCR, v);\r\n} else {\r\nusb_write32(Adapter, REG_RCR, usb_read32(Adapter, REG_RCR)|RCR_CBSSID_DATA|RCR_CBSSID_BCN);\r\n}\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE))\r\nRetryLimit = (haldata->CustomerID == RT_CID_CCX) ? 7 : 48;\r\nelse\r\nRetryLimit = 0x7;\r\n} else if (type == 1) {\r\nusb_write16(Adapter, REG_RXFLTMAP2, 0x00);\r\n} else if (type == 2) {\r\nusb_write8(Adapter, REG_BCN_CTRL, usb_read8(Adapter, REG_BCN_CTRL)&(~BIT(4)));\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE|WIFI_ADHOC_MASTER_STATE))\r\nRetryLimit = 0x7;\r\n}\r\nusb_write16(Adapter, REG_RL, RetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit << RETRY_LIMIT_LONG_SHIFT);\r\n}\r\nbreak;\r\ncase HW_VAR_BEACON_INTERVAL:\r\nusb_write16(Adapter, REG_BCN_INTERVAL, *((u16 *)val));\r\nbreak;\r\ncase HW_VAR_SLOT_TIME:\r\n{\r\nu8 u1bAIFS, aSifsTime;\r\nstruct mlme_ext_priv *pmlmeext = &Adapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nusb_write8(Adapter, REG_SLOT, val[0]);\r\nif (pmlmeinfo->WMM_enable == 0) {\r\nif (pmlmeext->cur_wireless_mode == WIRELESS_11B)\r\naSifsTime = 10;\r\nelse\r\naSifsTime = 16;\r\nu1bAIFS = aSifsTime + (2 * pmlmeinfo->slotTime);\r\nusb_write8(Adapter, REG_EDCA_VO_PARAM, u1bAIFS);\r\nusb_write8(Adapter, REG_EDCA_VI_PARAM, u1bAIFS);\r\nusb_write8(Adapter, REG_EDCA_BE_PARAM, u1bAIFS);\r\nusb_write8(Adapter, REG_EDCA_BK_PARAM, u1bAIFS);\r\n}\r\n}\r\nbreak;\r\ncase HW_VAR_RESP_SIFS:\r\nusb_write8(Adapter, REG_R2T_SIFS, val[0]);\r\nusb_write8(Adapter, REG_R2T_SIFS+1, val[1]);\r\nusb_write8(Adapter, REG_T2T_SIFS, val[2]);\r\nusb_write8(Adapter, REG_T2T_SIFS+1, val[3]);\r\nbreak;\r\ncase HW_VAR_ACK_PREAMBLE:\r\n{\r\nu8 regTmp;\r\nu8 bShortPreamble = *((bool *)val);\r\nregTmp = (haldata->nCur40MhzPrimeSC)<<5;\r\nif (bShortPreamble)\r\nregTmp |= 0x80;\r\nusb_write8(Adapter, REG_RRSR+2, regTmp);\r\n}\r\nbreak;\r\ncase HW_VAR_SEC_CFG:\r\nusb_write8(Adapter, REG_SECCFG, *((u8 *)val));\r\nbreak;\r\ncase HW_VAR_DM_FLAG:\r\npodmpriv->SupportAbility = *((u8 *)val);\r\nbreak;\r\ncase HW_VAR_DM_FUNC_OP:\r\nif (val[0])\r\npodmpriv->BK_SupportAbility = podmpriv->SupportAbility;\r\nelse\r\npodmpriv->SupportAbility = podmpriv->BK_SupportAbility;\r\nbreak;\r\ncase HW_VAR_DM_FUNC_SET:\r\nif (*((u32 *)val) == DYNAMIC_ALL_FUNC_ENABLE) {\r\npdmpriv->DMFlag = pdmpriv->InitDMFlag;\r\npodmpriv->SupportAbility = pdmpriv->InitODMFlag;\r\n} else {\r\npodmpriv->SupportAbility |= *((u32 *)val);\r\n}\r\nbreak;\r\ncase HW_VAR_DM_FUNC_CLR:\r\npodmpriv->SupportAbility &= *((u32 *)val);\r\nbreak;\r\ncase HW_VAR_CAM_EMPTY_ENTRY:\r\n{\r\nu8 ucIndex = *((u8 *)val);\r\nu8 i;\r\nu32 ulCommand = 0;\r\nu32 ulContent = 0;\r\nu32 ulEncAlgo = CAM_AES;\r\nfor (i = 0; i < CAM_CONTENT_COUNT; i++) {\r\nif (i == 0)\r\nulContent |= (ucIndex & 0x03) | ((u16)(ulEncAlgo)<<2);\r\nelse\r\nulContent = 0;\r\nulCommand = CAM_CONTENT_COUNT*ucIndex+i;\r\nulCommand = ulCommand | CAM_POLLINIG|CAM_WRITE;\r\nusb_write32(Adapter, WCAMI, ulContent);\r\nusb_write32(Adapter, RWCAM, ulCommand);\r\n}\r\n}\r\nbreak;\r\ncase HW_VAR_CAM_INVALID_ALL:\r\nusb_write32(Adapter, RWCAM, BIT(31)|BIT(30));\r\nbreak;\r\ncase HW_VAR_CAM_WRITE:\r\n{\r\nu32 cmd;\r\nu32 *cam_val = (u32 *)val;\r\nusb_write32(Adapter, WCAMI, cam_val[0]);\r\ncmd = CAM_POLLINIG | CAM_WRITE | cam_val[1];\r\nusb_write32(Adapter, RWCAM, cmd);\r\n}\r\nbreak;\r\ncase HW_VAR_AC_PARAM_VO:\r\nusb_write32(Adapter, REG_EDCA_VO_PARAM, ((u32 *)(val))[0]);\r\nbreak;\r\ncase HW_VAR_AC_PARAM_VI:\r\nusb_write32(Adapter, REG_EDCA_VI_PARAM, ((u32 *)(val))[0]);\r\nbreak;\r\ncase HW_VAR_AC_PARAM_BE:\r\nhaldata->AcParam_BE = ((u32 *)(val))[0];\r\nusb_write32(Adapter, REG_EDCA_BE_PARAM, ((u32 *)(val))[0]);\r\nbreak;\r\ncase HW_VAR_AC_PARAM_BK:\r\nusb_write32(Adapter, REG_EDCA_BK_PARAM, ((u32 *)(val))[0]);\r\nbreak;\r\ncase HW_VAR_ACM_CTRL:\r\n{\r\nu8 acm_ctrl = *((u8 *)val);\r\nu8 AcmCtrl = usb_read8(Adapter, REG_ACMHWCTRL);\r\nif (acm_ctrl > 1)\r\nAcmCtrl = AcmCtrl | 0x1;\r\nif (acm_ctrl & BIT(3))\r\nAcmCtrl |= AcmHw_VoqEn;\r\nelse\r\nAcmCtrl &= (~AcmHw_VoqEn);\r\nif (acm_ctrl & BIT(2))\r\nAcmCtrl |= AcmHw_ViqEn;\r\nelse\r\nAcmCtrl &= (~AcmHw_ViqEn);\r\nif (acm_ctrl & BIT(1))\r\nAcmCtrl |= AcmHw_BeqEn;\r\nelse\r\nAcmCtrl &= (~AcmHw_BeqEn);\r\nDBG_88E("[HW_VAR_ACM_CTRL] Write 0x%X\n", AcmCtrl);\r\nusb_write8(Adapter, REG_ACMHWCTRL, AcmCtrl);\r\n}\r\nbreak;\r\ncase HW_VAR_AMPDU_MIN_SPACE:\r\n{\r\nu8 MinSpacingToSet;\r\nu8 SecMinSpace;\r\nMinSpacingToSet = *((u8 *)val);\r\nif (MinSpacingToSet <= 7) {\r\nswitch (Adapter->securitypriv.dot11PrivacyAlgrthm) {\r\ncase _NO_PRIVACY_:\r\ncase _AES_:\r\nSecMinSpace = 0;\r\nbreak;\r\ncase _WEP40_:\r\ncase _WEP104_:\r\ncase _TKIP_:\r\ncase _TKIP_WTMIC_:\r\nSecMinSpace = 6;\r\nbreak;\r\ndefault:\r\nSecMinSpace = 7;\r\nbreak;\r\n}\r\nif (MinSpacingToSet < SecMinSpace)\r\nMinSpacingToSet = SecMinSpace;\r\nusb_write8(Adapter, REG_AMPDU_MIN_SPACE, (usb_read8(Adapter, REG_AMPDU_MIN_SPACE) & 0xf8) | MinSpacingToSet);\r\n}\r\n}\r\nbreak;\r\ncase HW_VAR_AMPDU_FACTOR:\r\n{\r\nu8 RegToSet_Normal[4] = {0x41, 0xa8, 0x72, 0xb9};\r\nu8 FactorToSet;\r\nu8 *pRegToSet;\r\nu8 index = 0;\r\npRegToSet = RegToSet_Normal;\r\nFactorToSet = *((u8 *)val);\r\nif (FactorToSet <= 3) {\r\nFactorToSet = 1 << (FactorToSet + 2);\r\nif (FactorToSet > 0xf)\r\nFactorToSet = 0xf;\r\nfor (index = 0; index < 4; index++) {\r\nif ((pRegToSet[index] & 0xf0) > (FactorToSet<<4))\r\npRegToSet[index] = (pRegToSet[index] & 0x0f) | (FactorToSet<<4);\r\nif ((pRegToSet[index] & 0x0f) > FactorToSet)\r\npRegToSet[index] = (pRegToSet[index] & 0xf0) | (FactorToSet);\r\nusb_write8(Adapter, (REG_AGGLEN_LMT+index), pRegToSet[index]);\r\n}\r\n}\r\n}\r\nbreak;\r\ncase HW_VAR_RXDMA_AGG_PG_TH:\r\n{\r\nu8 threshold = *((u8 *)val);\r\nif (threshold == 0)\r\nthreshold = haldata->UsbRxAggPageCount;\r\nusb_write8(Adapter, REG_RXDMA_AGG_PG_TH, threshold);\r\n}\r\nbreak;\r\ncase HW_VAR_SET_RPWM:\r\nbreak;\r\ncase HW_VAR_H2C_FW_PWRMODE:\r\n{\r\nu8 psmode = (*(u8 *)val);\r\nif ((psmode != PS_MODE_ACTIVE) && (!IS_92C_SERIAL(haldata->VersionID)))\r\nODM_RF_Saving(podmpriv, true);\r\nrtl8188e_set_FwPwrMode_cmd(Adapter, psmode);\r\n}\r\nbreak;\r\ncase HW_VAR_H2C_FW_JOINBSSRPT:\r\n{\r\nu8 mstatus = (*(u8 *)val);\r\nrtl8188e_set_FwJoinBssReport_cmd(Adapter, mstatus);\r\n}\r\nbreak;\r\ncase HW_VAR_INITIAL_GAIN:\r\n{\r\nstruct rtw_dig *pDigTable = &podmpriv->DM_DigTable;\r\nu32 rx_gain = ((u32 *)(val))[0];\r\nif (rx_gain == 0xff) {\r\nODM_Write_DIG(podmpriv, pDigTable->BackupIGValue);\r\n} else {\r\npDigTable->BackupIGValue = pDigTable->CurIGValue;\r\nODM_Write_DIG(podmpriv, rx_gain);\r\n}\r\n}\r\nbreak;\r\ncase HW_VAR_TRIGGER_GPIO_0:\r\nrtl8192cu_trigger_gpio_0(Adapter);\r\nbreak;\r\ncase HW_VAR_RPT_TIMER_SETTING:\r\n{\r\nu16 min_rpt_time = (*(u16 *)val);\r\nODM_RA_Set_TxRPT_Time(podmpriv, min_rpt_time);\r\n}\r\nbreak;\r\ncase HW_VAR_ANTENNA_DIVERSITY_SELECT:\r\n{\r\nu8 Optimum_antenna = (*(u8 *)val);\r\nu8 Ant;\r\nif (haldata->CurAntenna != Optimum_antenna) {\r\nAnt = (Optimum_antenna == 2) ? MAIN_ANT : AUX_ANT;\r\nrtl88eu_dm_update_rx_idle_ant(&haldata->odmpriv, Ant);\r\nhaldata->CurAntenna = Optimum_antenna;\r\n}\r\n}\r\nbreak;\r\ncase HW_VAR_EFUSE_BYTES:\r\nhaldata->EfuseUsedBytes = *((u16 *)val);\r\nbreak;\r\ncase HW_VAR_FIFO_CLEARN_UP:\r\n{\r\nstruct pwrctrl_priv *pwrpriv = &Adapter->pwrctrlpriv;\r\nu8 trycnt = 100;\r\nusb_write8(Adapter, REG_TXPAUSE, 0xff);\r\nAdapter->xmitpriv.nqos_ssn = usb_read16(Adapter, REG_NQOS_SEQ);\r\nif (!pwrpriv->bkeepfwalive) {\r\nusb_write32(Adapter, REG_RXPKT_NUM, (usb_read32(Adapter, REG_RXPKT_NUM)|RW_RELEASE_EN));\r\ndo {\r\nif (!(usb_read32(Adapter, REG_RXPKT_NUM)&RXDMA_IDLE))\r\nbreak;\r\n} while (trycnt--);\r\nif (trycnt == 0)\r\nDBG_88E("Stop RX DMA failed......\n");\r\nusb_write16(Adapter, REG_RQPN_NPQ, 0x0);\r\nusb_write32(Adapter, REG_RQPN, 0x80000000);\r\nmdelay(10);\r\n}\r\n}\r\nbreak;\r\ncase HW_VAR_CHECK_TXBUF:\r\nbreak;\r\ncase HW_VAR_APFM_ON_MAC:\r\nhaldata->bMacPwrCtrlOn = *val;\r\nDBG_88E("%s: bMacPwrCtrlOn=%d\n", __func__, haldata->bMacPwrCtrlOn);\r\nbreak;\r\ncase HW_VAR_TX_RPT_MAX_MACID:\r\n{\r\nu8 maxMacid = *val;\r\nDBG_88E("### MacID(%d),Set Max Tx RPT MID(%d)\n", maxMacid, maxMacid+1);\r\nusb_write8(Adapter, REG_TX_RPT_CTRL+1, maxMacid+1);\r\n}\r\nbreak;\r\ncase HW_VAR_H2C_MEDIA_STATUS_RPT:\r\nrtl8188e_set_FwMediaStatus_cmd(Adapter , (*(__le16 *)val));\r\nbreak;\r\ncase HW_VAR_BCN_VALID:\r\nusb_write8(Adapter, REG_TDECTRL+2, usb_read8(Adapter, REG_TDECTRL+2) | BIT0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void GetHwReg8188EU(struct adapter *Adapter, u8 variable, u8 *val)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(Adapter);\r\nstruct odm_dm_struct *podmpriv = &haldata->odmpriv;\r\nswitch (variable) {\r\ncase HW_VAR_BASIC_RATE:\r\n*((u16 *)(val)) = haldata->BasicRateSet;\r\ncase HW_VAR_TXPAUSE:\r\nval[0] = usb_read8(Adapter, REG_TXPAUSE);\r\nbreak;\r\ncase HW_VAR_BCN_VALID:\r\nval[0] = (BIT0 & usb_read8(Adapter, REG_TDECTRL+2)) ? true : false;\r\nbreak;\r\ncase HW_VAR_DM_FLAG:\r\nval[0] = podmpriv->SupportAbility;\r\nbreak;\r\ncase HW_VAR_RF_TYPE:\r\nval[0] = haldata->rf_type;\r\nbreak;\r\ncase HW_VAR_FWLPS_RF_ON:\r\n{\r\nif (Adapter->pwrctrlpriv.rf_pwrstate == rf_off) {\r\nval[0] = true;\r\n} else {\r\nu32 valRCR;\r\nvalRCR = usb_read32(Adapter, REG_RCR);\r\nvalRCR &= 0x00070000;\r\nif (valRCR)\r\nval[0] = false;\r\nelse\r\nval[0] = true;\r\n}\r\n}\r\nbreak;\r\ncase HW_VAR_CURRENT_ANTENNA:\r\nval[0] = haldata->CurAntenna;\r\nbreak;\r\ncase HW_VAR_EFUSE_BYTES:\r\n*((u16 *)(val)) = haldata->EfuseUsedBytes;\r\nbreak;\r\ncase HW_VAR_APFM_ON_MAC:\r\n*val = haldata->bMacPwrCtrlOn;\r\nbreak;\r\ncase HW_VAR_CHK_HI_QUEUE_EMPTY:\r\n*val = ((usb_read32(Adapter, REG_HGQ_INFORMATION)&0x0000ff00) == 0) ? true : false;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic u8\r\nGetHalDefVar8188EUsb(\r\nstruct adapter *Adapter,\r\nenum hal_def_variable eVariable,\r\nvoid *pValue\r\n)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(Adapter);\r\nu8 bResult = _SUCCESS;\r\nswitch (eVariable) {\r\ncase HAL_DEF_UNDERCORATEDSMOOTHEDPWDB:\r\n{\r\nstruct mlme_priv *pmlmepriv = &Adapter->mlmepriv;\r\nstruct sta_priv *pstapriv = &Adapter->stapriv;\r\nstruct sta_info *psta;\r\npsta = rtw_get_stainfo(pstapriv, pmlmepriv->cur_network.network.MacAddress);\r\nif (psta)\r\n*((int *)pValue) = psta->rssi_stat.UndecoratedSmoothedPWDB;\r\n}\r\nbreak;\r\ncase HAL_DEF_IS_SUPPORT_ANT_DIV:\r\n*((u8 *)pValue) = (haldata->AntDivCfg == 0) ? false : true;\r\nbreak;\r\ncase HAL_DEF_CURRENT_ANTENNA:\r\n*((u8 *)pValue) = haldata->CurAntenna;\r\nbreak;\r\ncase HAL_DEF_DRVINFO_SZ:\r\n*((u32 *)pValue) = DRVINFO_SZ;\r\nbreak;\r\ncase HAL_DEF_MAX_RECVBUF_SZ:\r\n*((u32 *)pValue) = MAX_RECVBUF_SZ;\r\nbreak;\r\ncase HAL_DEF_RX_PACKET_OFFSET:\r\n*((u32 *)pValue) = RXDESC_SIZE + DRVINFO_SZ;\r\nbreak;\r\ncase HAL_DEF_DBG_DM_FUNC:\r\n*((u32 *)pValue) = haldata->odmpriv.SupportAbility;\r\nbreak;\r\ncase HAL_DEF_RA_DECISION_RATE:\r\n{\r\nu8 MacID = *((u8 *)pValue);\r\n*((u8 *)pValue) = ODM_RA_GetDecisionRate_8188E(&(haldata->odmpriv), MacID);\r\n}\r\nbreak;\r\ncase HAL_DEF_RA_SGI:\r\n{\r\nu8 MacID = *((u8 *)pValue);\r\n*((u8 *)pValue) = ODM_RA_GetShortGI_8188E(&(haldata->odmpriv), MacID);\r\n}\r\nbreak;\r\ncase HAL_DEF_PT_PWR_STATUS:\r\n{\r\nu8 MacID = *((u8 *)pValue);\r\n*((u8 *)pValue) = ODM_RA_GetHwPwrStatus_8188E(&(haldata->odmpriv), MacID);\r\n}\r\nbreak;\r\ncase HW_VAR_MAX_RX_AMPDU_FACTOR:\r\n*((u32 *)pValue) = MAX_AMPDU_FACTOR_64K;\r\nbreak;\r\ncase HW_DEF_RA_INFO_DUMP:\r\n{\r\nu8 entry_id = *((u8 *)pValue);\r\nif (check_fwstate(&Adapter->mlmepriv, _FW_LINKED)) {\r\nDBG_88E("============ RA status check ===================\n");\r\nDBG_88E("Mac_id:%d , RateID = %d, RAUseRate = 0x%08x, RateSGI = %d, DecisionRate = 0x%02x ,PTStage = %d\n",\r\nentry_id,\r\nhaldata->odmpriv.RAInfo[entry_id].RateID,\r\nhaldata->odmpriv.RAInfo[entry_id].RAUseRate,\r\nhaldata->odmpriv.RAInfo[entry_id].RateSGI,\r\nhaldata->odmpriv.RAInfo[entry_id].DecisionRate,\r\nhaldata->odmpriv.RAInfo[entry_id].PTStage);\r\n}\r\n}\r\nbreak;\r\ncase HW_DEF_ODM_DBG_FLAG:\r\n{\r\nstruct odm_dm_struct *dm_ocm = &(haldata->odmpriv);\r\npr_info("dm_ocm->DebugComponents = 0x%llx\n", dm_ocm->DebugComponents);\r\n}\r\nbreak;\r\ncase HAL_DEF_DBG_DUMP_RXPKT:\r\n*((u8 *)pValue) = haldata->bDumpRxPkt;\r\nbreak;\r\ncase HAL_DEF_DBG_DUMP_TXPKT:\r\n*((u8 *)pValue) = haldata->bDumpTxPkt;\r\nbreak;\r\ndefault:\r\nbResult = _FAIL;\r\nbreak;\r\n}\r\nreturn bResult;\r\n}\r\nstatic u8 SetHalDefVar8188EUsb(struct adapter *Adapter, enum hal_def_variable eVariable, void *pValue)\r\n{\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(Adapter);\r\nu8 bResult = _SUCCESS;\r\nswitch (eVariable) {\r\ncase HAL_DEF_DBG_DM_FUNC:\r\n{\r\nu8 dm_func = *((u8 *)pValue);\r\nstruct odm_dm_struct *podmpriv = &haldata->odmpriv;\r\nif (dm_func == 0) {\r\npodmpriv->SupportAbility = DYNAMIC_FUNC_DISABLE;\r\nDBG_88E("==> Disable all dynamic function...\n");\r\n} else if (dm_func == 1) {\r\npodmpriv->SupportAbility &= (~DYNAMIC_BB_DIG);\r\nDBG_88E("==> Disable DIG...\n");\r\n} else if (dm_func == 2) {\r\npodmpriv->SupportAbility &= (~DYNAMIC_BB_DYNAMIC_TXPWR);\r\n} else if (dm_func == 3) {\r\npodmpriv->SupportAbility &= (~DYNAMIC_RF_CALIBRATION);\r\nDBG_88E("==> Disable tx power tracking...\n");\r\n} else if (dm_func == 5) {\r\npodmpriv->SupportAbility &= (~DYNAMIC_BB_ANT_DIV);\r\n} else if (dm_func == 6) {\r\nif (!(podmpriv->SupportAbility & DYNAMIC_BB_DIG)) {\r\nstruct rtw_dig *pDigTable = &podmpriv->DM_DigTable;\r\npDigTable->CurIGValue = usb_read8(Adapter, 0xc50);\r\n}\r\npodmpriv->SupportAbility = DYNAMIC_ALL_FUNC_ENABLE;\r\nDBG_88E("==> Turn on all dynamic function...\n");\r\n}\r\n}\r\nbreak;\r\ncase HAL_DEF_DBG_DUMP_RXPKT:\r\nhaldata->bDumpRxPkt = *((u8 *)pValue);\r\nbreak;\r\ncase HAL_DEF_DBG_DUMP_TXPKT:\r\nhaldata->bDumpTxPkt = *((u8 *)pValue);\r\nbreak;\r\ncase HW_DEF_FA_CNT_DUMP:\r\n{\r\nu8 bRSSIDump = *((u8 *)pValue);\r\nstruct odm_dm_struct *dm_ocm = &(haldata->odmpriv);\r\nif (bRSSIDump)\r\ndm_ocm->DebugComponents = ODM_COMP_DIG|ODM_COMP_FA_CNT;\r\nelse\r\ndm_ocm->DebugComponents = 0;\r\n}\r\nbreak;\r\ncase HW_DEF_ODM_DBG_FLAG:\r\n{\r\nu64 DebugComponents = *((u64 *)pValue);\r\nstruct odm_dm_struct *dm_ocm = &(haldata->odmpriv);\r\ndm_ocm->DebugComponents = DebugComponents;\r\n}\r\nbreak;\r\ndefault:\r\nbResult = _FAIL;\r\nbreak;\r\n}\r\nreturn bResult;\r\n}\r\nstatic void UpdateHalRAMask8188EUsb(struct adapter *adapt, u32 mac_id, u8 rssi_level)\r\n{\r\nu8 init_rate = 0;\r\nu8 networkType, raid;\r\nu32 mask, rate_bitmap;\r\nu8 shortGIrate = false;\r\nint supportRateNum = 0;\r\nstruct sta_info *psta;\r\nstruct hal_data_8188e *haldata = GET_HAL_DATA(adapt);\r\nstruct mlme_ext_priv *pmlmeext = &adapt->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct wlan_bssid_ex *cur_network = &(pmlmeinfo->network);\r\nif (mac_id >= NUM_STA)\r\nreturn;\r\npsta = pmlmeinfo->FW_sta_info[mac_id].psta;\r\nif (psta == NULL)\r\nreturn;\r\nswitch (mac_id) {\r\ncase 0:\r\nsupportRateNum = rtw_get_rateset_len(cur_network->SupportedRates);\r\nnetworkType = judge_network_type(adapt, cur_network->SupportedRates, supportRateNum) & 0xf;\r\nraid = networktype_to_raid(networkType);\r\nmask = update_supported_rate(cur_network->SupportedRates, supportRateNum);\r\nmask |= (pmlmeinfo->HT_enable) ? update_MSC_rate(&(pmlmeinfo->HT_caps)) : 0;\r\nif (support_short_GI(adapt, &(pmlmeinfo->HT_caps)))\r\nshortGIrate = true;\r\nbreak;\r\ncase 1:\r\nsupportRateNum = rtw_get_rateset_len(pmlmeinfo->FW_sta_info[mac_id].SupportedRates);\r\nif (pmlmeext->cur_wireless_mode & WIRELESS_11B)\r\nnetworkType = WIRELESS_11B;\r\nelse\r\nnetworkType = WIRELESS_11G;\r\nraid = networktype_to_raid(networkType);\r\nmask = update_basic_rate(cur_network->SupportedRates, supportRateNum);\r\nbreak;\r\ndefault:\r\nsupportRateNum = rtw_get_rateset_len(pmlmeinfo->FW_sta_info[mac_id].SupportedRates);\r\nnetworkType = judge_network_type(adapt, pmlmeinfo->FW_sta_info[mac_id].SupportedRates, supportRateNum) & 0xf;\r\nraid = networktype_to_raid(networkType);\r\nmask = update_supported_rate(cur_network->SupportedRates, supportRateNum);\r\nbreak;\r\n}\r\nrate_bitmap = 0x0fffffff;\r\nrate_bitmap = ODM_Get_Rate_Bitmap(&haldata->odmpriv, mac_id, mask, rssi_level);\r\nDBG_88E("%s => mac_id:%d, networkType:0x%02x, mask:0x%08x\n\t ==> rssi_level:%d, rate_bitmap:0x%08x\n",\r\n__func__, mac_id, networkType, mask, rssi_level, rate_bitmap);\r\nmask &= rate_bitmap;\r\ninit_rate = get_highest_rate_idx(mask)&0x3f;\r\nif (haldata->fw_ractrl) {\r\nu8 arg;\r\narg = mac_id & 0x1f;\r\narg |= BIT(7);\r\nif (shortGIrate)\r\narg |= BIT(5);\r\nmask |= ((raid << 28) & 0xf0000000);\r\nDBG_88E("update raid entry, mask=0x%x, arg=0x%x\n", mask, arg);\r\npsta->ra_mask = mask;\r\nmask |= ((raid << 28) & 0xf0000000);\r\nrtl8188e_set_raid_cmd(adapt, mask);\r\n} else {\r\nODM_RA_UpdateRateInfo_8188E(&(haldata->odmpriv),\r\nmac_id,\r\nraid,\r\nmask,\r\nshortGIrate\r\n);\r\n}\r\npsta->raid = raid;\r\npsta->init_rate = init_rate;\r\n}\r\nstatic void SetBeaconRelatedRegisters8188EUsb(struct adapter *adapt)\r\n{\r\nu32 value32;\r\nstruct mlme_ext_priv *pmlmeext = &(adapt->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nu32 bcn_ctrl_reg = REG_BCN_CTRL;\r\nusb_write16(adapt, REG_BCN_INTERVAL, pmlmeinfo->bcn_interval);\r\nusb_write8(adapt, REG_ATIMWND, 0x02);\r\n_InitBeaconParameters(adapt);\r\nusb_write8(adapt, REG_SLOT, 0x09);\r\nvalue32 = usb_read32(adapt, REG_TCR);\r\nvalue32 &= ~TSFRST;\r\nusb_write32(adapt, REG_TCR, value32);\r\nvalue32 |= TSFRST;\r\nusb_write32(adapt, REG_TCR, value32);\r\nusb_write8(adapt, REG_RXTSF_OFFSET_CCK, 0x50);\r\nusb_write8(adapt, REG_RXTSF_OFFSET_OFDM, 0x50);\r\n_BeaconFunctionEnable(adapt, true, true);\r\nResumeTxBeacon(adapt);\r\nusb_write8(adapt, bcn_ctrl_reg, usb_read8(adapt, bcn_ctrl_reg)|BIT(1));\r\n}\r\nstatic void rtl8188eu_init_default_value(struct adapter *adapt)\r\n{\r\nstruct hal_data_8188e *haldata;\r\nstruct pwrctrl_priv *pwrctrlpriv;\r\nu8 i;\r\nhaldata = GET_HAL_DATA(adapt);\r\npwrctrlpriv = &adapt->pwrctrlpriv;\r\nhaldata->fw_ractrl = false;\r\nif (!pwrctrlpriv->bkeepfwalive)\r\nhaldata->LastHMEBoxNum = 0;\r\nhaldata->odmpriv.RFCalibrateInfo.bIQKInitialized = false;\r\nhaldata->odmpriv.RFCalibrateInfo.TM_Trigger = 0;\r\nhaldata->pwrGroupCnt = 0;\r\nhaldata->PGMaxGroup = 13;\r\nhaldata->odmpriv.RFCalibrateInfo.ThermalValue_HP_index = 0;\r\nfor (i = 0; i < HP_THERMAL_NUM; i++)\r\nhaldata->odmpriv.RFCalibrateInfo.ThermalValue_HP[i] = 0;\r\n}\r\nvoid rtl8188eu_set_hal_ops(struct adapter *adapt)\r\n{\r\nstruct hal_ops *halfunc = &adapt->HalFunc;\r\nadapt->HalData = kzalloc(sizeof(struct hal_data_8188e), GFP_KERNEL);\r\nif (adapt->HalData == NULL)\r\nDBG_88E("cant not alloc memory for HAL DATA\n");\r\nhalfunc->hal_power_on = rtl8188eu_InitPowerOn;\r\nhalfunc->hal_init = &rtl8188eu_hal_init;\r\nhalfunc->hal_deinit = &rtl8188eu_hal_deinit;\r\nhalfunc->inirp_init = &rtl8188eu_inirp_init;\r\nhalfunc->inirp_deinit = &rtl8188eu_inirp_deinit;\r\nhalfunc->init_xmit_priv = &rtl8188eu_init_xmit_priv;\r\nhalfunc->init_recv_priv = &rtl8188eu_init_recv_priv;\r\nhalfunc->free_recv_priv = &rtl8188eu_free_recv_priv;\r\nhalfunc->InitSwLeds = &rtl8188eu_InitSwLeds;\r\nhalfunc->DeInitSwLeds = &rtl8188eu_DeInitSwLeds;\r\nhalfunc->init_default_value = &rtl8188eu_init_default_value;\r\nhalfunc->intf_chip_configure = &rtl8188eu_interface_configure;\r\nhalfunc->read_adapter_info = &_ReadAdapterInfo8188EU;\r\nhalfunc->SetHwRegHandler = &SetHwReg8188EU;\r\nhalfunc->GetHwRegHandler = &GetHwReg8188EU;\r\nhalfunc->GetHalDefVarHandler = &GetHalDefVar8188EUsb;\r\nhalfunc->SetHalDefVarHandler = &SetHalDefVar8188EUsb;\r\nhalfunc->UpdateRAMaskHandler = &UpdateHalRAMask8188EUsb;\r\nhalfunc->SetBeaconRelatedRegistersHandler = &SetBeaconRelatedRegisters8188EUsb;\r\nhalfunc->hal_xmit = &rtl8188eu_hal_xmit;\r\nhalfunc->mgnt_xmit = &rtl8188eu_mgnt_xmit;\r\nrtl8188e_set_hal_ops(halfunc);\r\n}
