static int\r\nefw_transaction(struct snd_efw *efw, unsigned int category,\r\nunsigned int command,\r\nconst __be32 *params, unsigned int param_bytes,\r\nconst __be32 *resp, unsigned int resp_bytes)\r\n{\r\nstruct snd_efw_transaction *header;\r\n__be32 *buf;\r\nu32 seqnum;\r\nunsigned int buf_bytes, cmd_bytes;\r\nint err;\r\nbuf_bytes = sizeof(struct snd_efw_transaction) +\r\nmax(param_bytes, resp_bytes);\r\nbuf = kzalloc(buf_bytes, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nspin_lock(&efw->lock);\r\nif ((efw->seqnum < KERNEL_SEQNUM_MIN) ||\r\n(efw->seqnum >= KERNEL_SEQNUM_MAX - 2))\r\nefw->seqnum = KERNEL_SEQNUM_MIN;\r\nelse\r\nefw->seqnum += 2;\r\nseqnum = efw->seqnum;\r\nspin_unlock(&efw->lock);\r\ncmd_bytes = sizeof(struct snd_efw_transaction) + param_bytes;\r\nheader = (struct snd_efw_transaction *)buf;\r\nheader->length = cpu_to_be32(cmd_bytes / sizeof(__be32));\r\nheader->version = cpu_to_be32(1);\r\nheader->seqnum = cpu_to_be32(seqnum);\r\nheader->category = cpu_to_be32(category);\r\nheader->command = cpu_to_be32(command);\r\nheader->status = 0;\r\nmemcpy(header->params, params, param_bytes);\r\nerr = snd_efw_transaction_run(efw->unit, buf, cmd_bytes,\r\nbuf, buf_bytes);\r\nif (err < 0)\r\ngoto end;\r\nif ((be32_to_cpu(header->version) < 1) ||\r\n(be32_to_cpu(header->category) != category) ||\r\n(be32_to_cpu(header->command) != command) ||\r\n(be32_to_cpu(header->status) != EFR_STATUS_OK)) {\r\ndev_err(&efw->unit->device, "EFW command failed [%u/%u]: %s\n",\r\nbe32_to_cpu(header->category),\r\nbe32_to_cpu(header->command),\r\nefr_status_names[be32_to_cpu(header->status)]);\r\nerr = -EIO;\r\ngoto end;\r\n}\r\nif (resp == NULL)\r\ngoto end;\r\nmemset((void *)resp, 0, resp_bytes);\r\nresp_bytes = min_t(unsigned int, resp_bytes,\r\nbe32_to_cpu(header->length) * sizeof(__be32) -\r\nsizeof(struct snd_efw_transaction));\r\nmemcpy((void *)resp, &buf[6], resp_bytes);\r\nend:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nint snd_efw_command_set_resp_addr(struct snd_efw *efw,\r\nu16 addr_high, u32 addr_low)\r\n{\r\n__be32 addr[2];\r\naddr[0] = cpu_to_be32(addr_high);\r\naddr[1] = cpu_to_be32(addr_low);\r\nif (!efw->resp_addr_changable)\r\nreturn -ENOSYS;\r\nreturn efw_transaction(efw, EFC_CAT_HWCTL,\r\nEFC_CMD_HWINFO_SET_RESP_ADDR,\r\naddr, sizeof(addr), NULL, 0);\r\n}\r\nint snd_efw_command_set_tx_mode(struct snd_efw *efw,\r\nenum snd_efw_transport_mode mode)\r\n{\r\n__be32 param = cpu_to_be32(mode);\r\nreturn efw_transaction(efw, EFC_CAT_TRANSPORT,\r\nEFC_CMD_TRANSPORT_SET_TX_MODE,\r\n&param, sizeof(param), NULL, 0);\r\n}\r\nint snd_efw_command_get_hwinfo(struct snd_efw *efw,\r\nstruct snd_efw_hwinfo *hwinfo)\r\n{\r\nint err;\r\nerr = efw_transaction(efw, EFC_CAT_HWINFO,\r\nEFC_CMD_HWINFO_GET_CAPS,\r\nNULL, 0, (__be32 *)hwinfo, sizeof(*hwinfo));\r\nif (err < 0)\r\ngoto end;\r\nbe32_to_cpus(&hwinfo->flags);\r\nbe32_to_cpus(&hwinfo->guid_hi);\r\nbe32_to_cpus(&hwinfo->guid_lo);\r\nbe32_to_cpus(&hwinfo->type);\r\nbe32_to_cpus(&hwinfo->version);\r\nbe32_to_cpus(&hwinfo->supported_clocks);\r\nbe32_to_cpus(&hwinfo->amdtp_rx_pcm_channels);\r\nbe32_to_cpus(&hwinfo->amdtp_tx_pcm_channels);\r\nbe32_to_cpus(&hwinfo->phys_out);\r\nbe32_to_cpus(&hwinfo->phys_in);\r\nbe32_to_cpus(&hwinfo->phys_out_grp_count);\r\nbe32_to_cpus(&hwinfo->phys_in_grp_count);\r\nbe32_to_cpus(&hwinfo->midi_out_ports);\r\nbe32_to_cpus(&hwinfo->midi_in_ports);\r\nbe32_to_cpus(&hwinfo->max_sample_rate);\r\nbe32_to_cpus(&hwinfo->min_sample_rate);\r\nbe32_to_cpus(&hwinfo->dsp_version);\r\nbe32_to_cpus(&hwinfo->arm_version);\r\nbe32_to_cpus(&hwinfo->mixer_playback_channels);\r\nbe32_to_cpus(&hwinfo->mixer_capture_channels);\r\nbe32_to_cpus(&hwinfo->fpga_version);\r\nbe32_to_cpus(&hwinfo->amdtp_rx_pcm_channels_2x);\r\nbe32_to_cpus(&hwinfo->amdtp_tx_pcm_channels_2x);\r\nbe32_to_cpus(&hwinfo->amdtp_rx_pcm_channels_4x);\r\nbe32_to_cpus(&hwinfo->amdtp_tx_pcm_channels_4x);\r\nhwinfo->vendor_name[HWINFO_NAME_SIZE_BYTES - 1] = '\0';\r\nhwinfo->model_name[HWINFO_NAME_SIZE_BYTES - 1] = '\0';\r\nend:\r\nreturn err;\r\n}\r\nint snd_efw_command_get_phys_meters(struct snd_efw *efw,\r\nstruct snd_efw_phys_meters *meters,\r\nunsigned int len)\r\n{\r\n__be32 *buf = (__be32 *)meters;\r\nunsigned int i;\r\nint err;\r\nerr = efw_transaction(efw, EFC_CAT_HWINFO,\r\nEFC_CMD_HWINFO_GET_POLLED,\r\nNULL, 0, (__be32 *)meters, len);\r\nif (err >= 0)\r\nfor (i = 0; i < len / sizeof(u32); i++)\r\nbe32_to_cpus(&buf[i]);\r\nreturn err;\r\n}\r\nstatic int\r\ncommand_get_clock(struct snd_efw *efw, struct efc_clock *clock)\r\n{\r\nint err;\r\nerr = efw_transaction(efw, EFC_CAT_HWCTL,\r\nEFC_CMD_HWCTL_GET_CLOCK,\r\nNULL, 0,\r\n(__be32 *)clock, sizeof(struct efc_clock));\r\nif (err >= 0) {\r\nbe32_to_cpus(&clock->source);\r\nbe32_to_cpus(&clock->sampling_rate);\r\nbe32_to_cpus(&clock->index);\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\ncommand_set_clock(struct snd_efw *efw,\r\nunsigned int source, unsigned int rate)\r\n{\r\nstruct efc_clock clock = {0};\r\nint err;\r\nif ((source == UINT_MAX) && (rate == UINT_MAX)) {\r\nerr = -EINVAL;\r\ngoto end;\r\n}\r\nerr = command_get_clock(efw, &clock);\r\nif (err < 0)\r\ngoto end;\r\nif ((clock.source == source) && (clock.sampling_rate == rate))\r\ngoto end;\r\nif ((source != UINT_MAX) && (clock.source != source))\r\nclock.source = source;\r\nif ((rate != UINT_MAX) && (clock.sampling_rate != rate))\r\nclock.sampling_rate = rate;\r\nclock.index = 0;\r\ncpu_to_be32s(&clock.source);\r\ncpu_to_be32s(&clock.sampling_rate);\r\ncpu_to_be32s(&clock.index);\r\nerr = efw_transaction(efw, EFC_CAT_HWCTL,\r\nEFC_CMD_HWCTL_SET_CLOCK,\r\n(__be32 *)&clock, sizeof(struct efc_clock),\r\nNULL, 0);\r\nif (err < 0)\r\ngoto end;\r\nmsleep(150);\r\nend:\r\nreturn err;\r\n}\r\nint snd_efw_command_get_clock_source(struct snd_efw *efw,\r\nenum snd_efw_clock_source *source)\r\n{\r\nint err;\r\nstruct efc_clock clock = {0};\r\nerr = command_get_clock(efw, &clock);\r\nif (err >= 0)\r\n*source = clock.source;\r\nreturn err;\r\n}\r\nint snd_efw_command_get_sampling_rate(struct snd_efw *efw, unsigned int *rate)\r\n{\r\nint err;\r\nstruct efc_clock clock = {0};\r\nerr = command_get_clock(efw, &clock);\r\nif (err >= 0)\r\n*rate = clock.sampling_rate;\r\nreturn err;\r\n}\r\nint snd_efw_command_set_sampling_rate(struct snd_efw *efw, unsigned int rate)\r\n{\r\nreturn command_set_clock(efw, UINT_MAX, rate);\r\n}
