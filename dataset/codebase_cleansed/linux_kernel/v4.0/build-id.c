int build_id__mark_dso_hit(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel __maybe_unused,\r\nstruct machine *machine)\r\n{\r\nstruct addr_location al;\r\nu8 cpumode = event->header.misc & PERF_RECORD_MISC_CPUMODE_MASK;\r\nstruct thread *thread = machine__findnew_thread(machine, sample->pid,\r\nsample->tid);\r\nif (thread == NULL) {\r\npr_err("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\nreturn -1;\r\n}\r\nthread__find_addr_map(thread, cpumode, MAP__FUNCTION, sample->ip, &al);\r\nif (al.map != NULL)\r\nal.map->dso->hit = 1;\r\nreturn 0;\r\n}\r\nstatic int perf_event__exit_del_thread(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event,\r\nstruct perf_sample *sample\r\n__maybe_unused,\r\nstruct machine *machine)\r\n{\r\nstruct thread *thread = machine__findnew_thread(machine,\r\nevent->fork.pid,\r\nevent->fork.tid);\r\ndump_printf("(%d:%d):(%d:%d)\n", event->fork.pid, event->fork.tid,\r\nevent->fork.ppid, event->fork.ptid);\r\nif (thread) {\r\nrb_erase(&thread->rb_node, &machine->threads);\r\nmachine->last_match = NULL;\r\nthread__delete(thread);\r\n}\r\nreturn 0;\r\n}\r\nint build_id__sprintf(const u8 *build_id, int len, char *bf)\r\n{\r\nchar *bid = bf;\r\nconst u8 *raw = build_id;\r\nint i;\r\nfor (i = 0; i < len; ++i) {\r\nsprintf(bid, "%02x", *raw);\r\n++raw;\r\nbid += 2;\r\n}\r\nreturn raw - build_id;\r\n}\r\nchar *dso__build_id_filename(const struct dso *dso, char *bf, size_t size)\r\n{\r\nchar build_id_hex[BUILD_ID_SIZE * 2 + 1];\r\nif (!dso->has_build_id)\r\nreturn NULL;\r\nbuild_id__sprintf(dso->build_id, sizeof(dso->build_id), build_id_hex);\r\nif (bf == NULL) {\r\nif (asprintf(&bf, "%s/.build-id/%.2s/%s", buildid_dir,\r\nbuild_id_hex, build_id_hex + 2) < 0)\r\nreturn NULL;\r\n} else\r\nsnprintf(bf, size, "%s/.build-id/%.2s/%s", buildid_dir,\r\nbuild_id_hex, build_id_hex + 2);\r\nreturn bf;\r\n}\r\nstatic int write_buildid(const char *name, size_t name_len, u8 *build_id,\r\npid_t pid, u16 misc, int fd)\r\n{\r\nint err;\r\nstruct build_id_event b;\r\nsize_t len;\r\nlen = name_len + 1;\r\nlen = PERF_ALIGN(len, NAME_ALIGN);\r\nmemset(&b, 0, sizeof(b));\r\nmemcpy(&b.build_id, build_id, BUILD_ID_SIZE);\r\nb.pid = pid;\r\nb.header.misc = misc;\r\nb.header.size = sizeof(b) + len;\r\nerr = writen(fd, &b, sizeof(b));\r\nif (err < 0)\r\nreturn err;\r\nreturn write_padded(fd, name, name_len + 1, len);\r\n}\r\nstatic int __dsos__write_buildid_table(struct list_head *head,\r\nstruct machine *machine,\r\npid_t pid, u16 misc, int fd)\r\n{\r\nchar nm[PATH_MAX];\r\nstruct dso *pos;\r\ndsos__for_each_with_build_id(pos, head) {\r\nint err;\r\nconst char *name;\r\nsize_t name_len;\r\nif (!pos->hit)\r\ncontinue;\r\nif (dso__is_vdso(pos)) {\r\nname = pos->short_name;\r\nname_len = pos->short_name_len + 1;\r\n} else if (dso__is_kcore(pos)) {\r\nmachine__mmap_name(machine, nm, sizeof(nm));\r\nname = nm;\r\nname_len = strlen(nm) + 1;\r\n} else {\r\nname = pos->long_name;\r\nname_len = pos->long_name_len + 1;\r\n}\r\nerr = write_buildid(name, name_len, pos->build_id,\r\npid, misc, fd);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int machine__write_buildid_table(struct machine *machine, int fd)\r\n{\r\nint err;\r\nu16 kmisc = PERF_RECORD_MISC_KERNEL,\r\numisc = PERF_RECORD_MISC_USER;\r\nif (!machine__is_host(machine)) {\r\nkmisc = PERF_RECORD_MISC_GUEST_KERNEL;\r\numisc = PERF_RECORD_MISC_GUEST_USER;\r\n}\r\nerr = __dsos__write_buildid_table(&machine->kernel_dsos.head, machine,\r\nmachine->pid, kmisc, fd);\r\nif (err == 0)\r\nerr = __dsos__write_buildid_table(&machine->user_dsos.head,\r\nmachine, machine->pid, umisc,\r\nfd);\r\nreturn err;\r\n}\r\nint perf_session__write_buildid_table(struct perf_session *session, int fd)\r\n{\r\nstruct rb_node *nd;\r\nint err = machine__write_buildid_table(&session->machines.host, fd);\r\nif (err)\r\nreturn err;\r\nfor (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nerr = machine__write_buildid_table(pos, fd);\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int __dsos__hit_all(struct list_head *head)\r\n{\r\nstruct dso *pos;\r\nlist_for_each_entry(pos, head, node)\r\npos->hit = true;\r\nreturn 0;\r\n}\r\nstatic int machine__hit_all_dsos(struct machine *machine)\r\n{\r\nint err;\r\nerr = __dsos__hit_all(&machine->kernel_dsos.head);\r\nif (err)\r\nreturn err;\r\nreturn __dsos__hit_all(&machine->user_dsos.head);\r\n}\r\nint dsos__hit_all(struct perf_session *session)\r\n{\r\nstruct rb_node *nd;\r\nint err;\r\nerr = machine__hit_all_dsos(&session->machines.host);\r\nif (err)\r\nreturn err;\r\nfor (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nerr = machine__hit_all_dsos(pos);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nvoid disable_buildid_cache(void)\r\n{\r\nno_buildid_cache = true;\r\n}\r\nint build_id_cache__add_s(const char *sbuild_id, const char *debugdir,\r\nconst char *name, bool is_kallsyms, bool is_vdso)\r\n{\r\nconst size_t size = PATH_MAX;\r\nchar *realname, *filename = zalloc(size),\r\n*linkname = zalloc(size), *targetname;\r\nint len, err = -1;\r\nbool slash = is_kallsyms || is_vdso;\r\nif (is_kallsyms) {\r\nif (symbol_conf.kptr_restrict) {\r\npr_debug("Not caching a kptr_restrict'ed /proc/kallsyms\n");\r\nerr = 0;\r\ngoto out_free;\r\n}\r\nrealname = (char *) name;\r\n} else\r\nrealname = realpath(name, NULL);\r\nif (realname == NULL || filename == NULL || linkname == NULL)\r\ngoto out_free;\r\nlen = scnprintf(filename, size, "%s%s%s",\r\ndebugdir, slash ? "/" : "",\r\nis_vdso ? DSO__NAME_VDSO : realname);\r\nif (mkdir_p(filename, 0755))\r\ngoto out_free;\r\nsnprintf(filename + len, size - len, "/%s", sbuild_id);\r\nif (access(filename, F_OK)) {\r\nif (is_kallsyms) {\r\nif (copyfile("/proc/kallsyms", filename))\r\ngoto out_free;\r\n} else if (link(realname, filename) && copyfile(name, filename))\r\ngoto out_free;\r\n}\r\nlen = scnprintf(linkname, size, "%s/.build-id/%.2s",\r\ndebugdir, sbuild_id);\r\nif (access(linkname, X_OK) && mkdir_p(linkname, 0755))\r\ngoto out_free;\r\nsnprintf(linkname + len, size - len, "/%s", sbuild_id + 2);\r\ntargetname = filename + strlen(debugdir) - 5;\r\nmemcpy(targetname, "../..", 5);\r\nif (symlink(targetname, linkname) == 0)\r\nerr = 0;\r\nout_free:\r\nif (!is_kallsyms)\r\nfree(realname);\r\nfree(filename);\r\nfree(linkname);\r\nreturn err;\r\n}\r\nstatic int build_id_cache__add_b(const u8 *build_id, size_t build_id_size,\r\nconst char *name, const char *debugdir,\r\nbool is_kallsyms, bool is_vdso)\r\n{\r\nchar sbuild_id[BUILD_ID_SIZE * 2 + 1];\r\nbuild_id__sprintf(build_id, build_id_size, sbuild_id);\r\nreturn build_id_cache__add_s(sbuild_id, debugdir, name,\r\nis_kallsyms, is_vdso);\r\n}\r\nint build_id_cache__remove_s(const char *sbuild_id, const char *debugdir)\r\n{\r\nconst size_t size = PATH_MAX;\r\nchar *filename = zalloc(size),\r\n*linkname = zalloc(size);\r\nint err = -1;\r\nif (filename == NULL || linkname == NULL)\r\ngoto out_free;\r\nsnprintf(linkname, size, "%s/.build-id/%.2s/%s",\r\ndebugdir, sbuild_id, sbuild_id + 2);\r\nif (access(linkname, F_OK))\r\ngoto out_free;\r\nif (readlink(linkname, filename, size - 1) < 0)\r\ngoto out_free;\r\nif (unlink(linkname))\r\ngoto out_free;\r\nsnprintf(linkname, size, "%s/.build-id/%.2s/%s",\r\ndebugdir, sbuild_id, filename);\r\nif (unlink(linkname))\r\ngoto out_free;\r\nerr = 0;\r\nout_free:\r\nfree(filename);\r\nfree(linkname);\r\nreturn err;\r\n}\r\nstatic int dso__cache_build_id(struct dso *dso, struct machine *machine,\r\nconst char *debugdir)\r\n{\r\nbool is_kallsyms = dso->kernel && dso->long_name[0] != '/';\r\nbool is_vdso = dso__is_vdso(dso);\r\nconst char *name = dso->long_name;\r\nchar nm[PATH_MAX];\r\nif (dso__is_kcore(dso)) {\r\nis_kallsyms = true;\r\nmachine__mmap_name(machine, nm, sizeof(nm));\r\nname = nm;\r\n}\r\nreturn build_id_cache__add_b(dso->build_id, sizeof(dso->build_id), name,\r\ndebugdir, is_kallsyms, is_vdso);\r\n}\r\nstatic int __dsos__cache_build_ids(struct list_head *head,\r\nstruct machine *machine, const char *debugdir)\r\n{\r\nstruct dso *pos;\r\nint err = 0;\r\ndsos__for_each_with_build_id(pos, head)\r\nif (dso__cache_build_id(pos, machine, debugdir))\r\nerr = -1;\r\nreturn err;\r\n}\r\nstatic int machine__cache_build_ids(struct machine *machine, const char *debugdir)\r\n{\r\nint ret = __dsos__cache_build_ids(&machine->kernel_dsos.head, machine,\r\ndebugdir);\r\nret |= __dsos__cache_build_ids(&machine->user_dsos.head, machine,\r\ndebugdir);\r\nreturn ret;\r\n}\r\nint perf_session__cache_build_ids(struct perf_session *session)\r\n{\r\nstruct rb_node *nd;\r\nint ret;\r\nif (no_buildid_cache)\r\nreturn 0;\r\nif (mkdir(buildid_dir, 0755) != 0 && errno != EEXIST)\r\nreturn -1;\r\nret = machine__cache_build_ids(&session->machines.host, buildid_dir);\r\nfor (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nret |= machine__cache_build_ids(pos, buildid_dir);\r\n}\r\nreturn ret ? -1 : 0;\r\n}\r\nstatic bool machine__read_build_ids(struct machine *machine, bool with_hits)\r\n{\r\nbool ret;\r\nret = __dsos__read_build_ids(&machine->kernel_dsos.head, with_hits);\r\nret |= __dsos__read_build_ids(&machine->user_dsos.head, with_hits);\r\nreturn ret;\r\n}\r\nbool perf_session__read_build_ids(struct perf_session *session, bool with_hits)\r\n{\r\nstruct rb_node *nd;\r\nbool ret = machine__read_build_ids(&session->machines.host, with_hits);\r\nfor (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nret |= machine__read_build_ids(pos, with_hits);\r\n}\r\nreturn ret;\r\n}
