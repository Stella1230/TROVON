static void omap2_sms_write_rot_control(u32 val, unsigned ctx)\r\n{\r\n__raw_writel(val, vrfb_base + SMS_ROT_CONTROL(ctx));\r\n}\r\nstatic void omap2_sms_write_rot_size(u32 val, unsigned ctx)\r\n{\r\n__raw_writel(val, vrfb_base + SMS_ROT_SIZE(ctx));\r\n}\r\nstatic void omap2_sms_write_rot_physical_ba(u32 val, unsigned ctx)\r\n{\r\n__raw_writel(val, vrfb_base + SMS_ROT_PHYSICAL_BA(ctx));\r\n}\r\nstatic inline void restore_hw_context(int ctx)\r\n{\r\nomap2_sms_write_rot_control(ctxs[ctx].control, ctx);\r\nomap2_sms_write_rot_size(ctxs[ctx].size, ctx);\r\nomap2_sms_write_rot_physical_ba(ctxs[ctx].physical_ba, ctx);\r\n}\r\nstatic u32 get_image_width_roundup(u16 width, u8 bytespp)\r\n{\r\nunsigned long stride = width * bytespp;\r\nunsigned long ceil_pages_per_stride = (stride / VRFB_PAGE_WIDTH) +\r\n(stride % VRFB_PAGE_WIDTH != 0);\r\nreturn ceil_pages_per_stride * VRFB_PAGE_WIDTH / bytespp;\r\n}\r\nstatic inline u32 get_extra_physical_size(u16 image_width_roundup, u8 bytespp)\r\n{\r\nreturn (OMAP_VRFB_LINE_LEN - image_width_roundup) * VRFB_PAGE_HEIGHT *\r\nbytespp;\r\n}\r\nvoid omap_vrfb_restore_context(void)\r\n{\r\nint i;\r\nunsigned long map = ctx_map;\r\nfor (i = ffs(map); i; i = ffs(map)) {\r\ni--;\r\nmap &= ~(1 << i);\r\nrestore_hw_context(i);\r\n}\r\n}\r\nvoid omap_vrfb_adjust_size(u16 *width, u16 *height,\r\nu8 bytespp)\r\n{\r\n*width = ALIGN(*width * bytespp, VRFB_PAGE_WIDTH) / bytespp;\r\n*height = ALIGN(*height, VRFB_PAGE_HEIGHT);\r\n}\r\nu32 omap_vrfb_min_phys_size(u16 width, u16 height, u8 bytespp)\r\n{\r\nunsigned long image_width_roundup = get_image_width_roundup(width,\r\nbytespp);\r\nif (image_width_roundup > OMAP_VRFB_LINE_LEN)\r\nreturn 0;\r\nreturn (width * height * bytespp) + get_extra_physical_size(\r\nimage_width_roundup, bytespp);\r\n}\r\nu16 omap_vrfb_max_height(u32 phys_size, u16 width, u8 bytespp)\r\n{\r\nunsigned long image_width_roundup = get_image_width_roundup(width,\r\nbytespp);\r\nunsigned long height;\r\nunsigned long extra;\r\nif (image_width_roundup > OMAP_VRFB_LINE_LEN)\r\nreturn 0;\r\nextra = get_extra_physical_size(image_width_roundup, bytespp);\r\nif (phys_size < extra)\r\nreturn 0;\r\nheight = (phys_size - extra) / (width * bytespp);\r\nreturn min_t(unsigned long, height, 2048);\r\n}\r\nvoid omap_vrfb_setup(struct vrfb *vrfb, unsigned long paddr,\r\nu16 width, u16 height,\r\nunsigned bytespp, bool yuv_mode)\r\n{\r\nunsigned pixel_size_exp;\r\nu16 vrfb_width;\r\nu16 vrfb_height;\r\nu8 ctx = vrfb->context;\r\nu32 size;\r\nu32 control;\r\nDBG("omapfb_set_vrfb(%d, %lx, %dx%d, %d, %d)\n", ctx, paddr,\r\nwidth, height, bytespp, yuv_mode);\r\nif (yuv_mode) {\r\nbytespp *= 2;\r\nwidth /= 2;\r\n}\r\nif (bytespp == 4)\r\npixel_size_exp = 2;\r\nelse if (bytespp == 2)\r\npixel_size_exp = 1;\r\nelse {\r\nBUG();\r\nreturn;\r\n}\r\nvrfb_width = ALIGN(width * bytespp, VRFB_PAGE_WIDTH) / bytespp;\r\nvrfb_height = ALIGN(height, VRFB_PAGE_HEIGHT);\r\nDBG("vrfb w %u, h %u bytespp %d\n", vrfb_width, vrfb_height, bytespp);\r\nsize = vrfb_width << SMS_IMAGEWIDTH_OFFSET;\r\nsize |= vrfb_height << SMS_IMAGEHEIGHT_OFFSET;\r\ncontrol = pixel_size_exp << SMS_PS_OFFSET;\r\ncontrol |= VRFB_PAGE_WIDTH_EXP << SMS_PW_OFFSET;\r\ncontrol |= VRFB_PAGE_HEIGHT_EXP << SMS_PH_OFFSET;\r\nctxs[ctx].physical_ba = paddr;\r\nctxs[ctx].size = size;\r\nctxs[ctx].control = control;\r\nomap2_sms_write_rot_physical_ba(paddr, ctx);\r\nomap2_sms_write_rot_size(size, ctx);\r\nomap2_sms_write_rot_control(control, ctx);\r\nDBG("vrfb offset pixels %d, %d\n",\r\nvrfb_width - width, vrfb_height - height);\r\nvrfb->xres = width;\r\nvrfb->yres = height;\r\nvrfb->xoffset = vrfb_width - width;\r\nvrfb->yoffset = vrfb_height - height;\r\nvrfb->bytespp = bytespp;\r\nvrfb->yuv_mode = yuv_mode;\r\n}\r\nint omap_vrfb_map_angle(struct vrfb *vrfb, u16 height, u8 rot)\r\n{\r\nunsigned long size = height * OMAP_VRFB_LINE_LEN * vrfb->bytespp;\r\nvrfb->vaddr[rot] = ioremap_wc(vrfb->paddr[rot], size);\r\nif (!vrfb->vaddr[rot]) {\r\nprintk(KERN_ERR "vrfb: ioremap failed\n");\r\nreturn -ENOMEM;\r\n}\r\nDBG("ioremapped vrfb area %d of size %lu into %p\n", rot, size,\r\nvrfb->vaddr[rot]);\r\nreturn 0;\r\n}\r\nvoid omap_vrfb_release_ctx(struct vrfb *vrfb)\r\n{\r\nint rot;\r\nint ctx = vrfb->context;\r\nif (ctx == 0xff)\r\nreturn;\r\nDBG("release ctx %d\n", ctx);\r\nmutex_lock(&ctx_lock);\r\nBUG_ON(!(ctx_map & (1 << ctx)));\r\nclear_bit(ctx, &ctx_map);\r\nfor (rot = 0; rot < 4; ++rot) {\r\nif (vrfb->paddr[rot]) {\r\nrelease_mem_region(vrfb->paddr[rot], OMAP_VRFB_SIZE);\r\nvrfb->paddr[rot] = 0;\r\n}\r\n}\r\nvrfb->context = 0xff;\r\nmutex_unlock(&ctx_lock);\r\n}\r\nint omap_vrfb_request_ctx(struct vrfb *vrfb)\r\n{\r\nint rot;\r\nu32 paddr;\r\nu8 ctx;\r\nint r;\r\nDBG("request ctx\n");\r\nmutex_lock(&ctx_lock);\r\nfor (ctx = 0; ctx < num_ctxs; ++ctx)\r\nif ((ctx_map & (1 << ctx)) == 0)\r\nbreak;\r\nif (ctx == num_ctxs) {\r\npr_err("vrfb: no free contexts\n");\r\nr = -EBUSY;\r\ngoto out;\r\n}\r\nDBG("found free ctx %d\n", ctx);\r\nset_bit(ctx, &ctx_map);\r\nmemset(vrfb, 0, sizeof(*vrfb));\r\nvrfb->context = ctx;\r\nfor (rot = 0; rot < 4; ++rot) {\r\npaddr = ctxs[ctx].base + SMS_ROT_VIRT_BASE(rot);\r\nif (!request_mem_region(paddr, OMAP_VRFB_SIZE, "vrfb")) {\r\npr_err("vrfb: failed to reserve VRFB "\r\n"area for ctx %d, rotation %d\n",\r\nctx, rot * 90);\r\nomap_vrfb_release_ctx(vrfb);\r\nr = -ENOMEM;\r\ngoto out;\r\n}\r\nvrfb->paddr[rot] = paddr;\r\nDBG("VRFB %d/%d: %lx\n", ctx, rot*90, vrfb->paddr[rot]);\r\n}\r\nr = 0;\r\nout:\r\nmutex_unlock(&ctx_lock);\r\nreturn r;\r\n}\r\nbool omap_vrfb_supported(void)\r\n{\r\nreturn vrfb_loaded;\r\n}\r\nstatic int __init vrfb_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *mem;\r\nint i;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nvrfb_base = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(vrfb_base))\r\nreturn PTR_ERR(vrfb_base);\r\nnum_ctxs = pdev->num_resources - 1;\r\nctxs = devm_kzalloc(&pdev->dev,\r\nsizeof(struct vrfb_ctx) * num_ctxs,\r\nGFP_KERNEL);\r\nif (!ctxs)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_ctxs; ++i) {\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 1 + i);\r\nif (!mem) {\r\ndev_err(&pdev->dev, "can't get vrfb ctx %d address\n",\r\ni);\r\nreturn -EINVAL;\r\n}\r\nctxs[i].base = mem->start;\r\n}\r\nvrfb_loaded = true;\r\nreturn 0;\r\n}\r\nstatic void __exit vrfb_remove(struct platform_device *pdev)\r\n{\r\nvrfb_loaded = false;\r\n}
