static void syscon_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct syscon_led *sled =\r\ncontainer_of(led_cdev, struct syscon_led, cdev);\r\nu32 val;\r\nint ret;\r\nif (value == LED_OFF) {\r\nval = 0;\r\nsled->state = false;\r\n} else {\r\nval = sled->mask;\r\nsled->state = true;\r\n}\r\nret = regmap_update_bits(sled->map, sled->offset, sled->mask, val);\r\nif (ret < 0)\r\ndev_err(sled->cdev.dev, "error updating LED status\n");\r\n}\r\nstatic int __init syscon_leds_spawn(struct device_node *np,\r\nstruct device *dev,\r\nstruct regmap *map)\r\n{\r\nstruct device_node *child;\r\nint ret;\r\nfor_each_available_child_of_node(np, child) {\r\nstruct syscon_led *sled;\r\nconst char *state;\r\nif (of_property_match_string(child, "compatible",\r\n"register-bit-led") < 0)\r\ncontinue;\r\nsled = devm_kzalloc(dev, sizeof(*sled), GFP_KERNEL);\r\nif (!sled)\r\nreturn -ENOMEM;\r\nsled->map = map;\r\nif (of_property_read_u32(child, "offset", &sled->offset))\r\nreturn -EINVAL;\r\nif (of_property_read_u32(child, "mask", &sled->mask))\r\nreturn -EINVAL;\r\nsled->cdev.name =\r\nof_get_property(child, "label", NULL) ? : child->name;\r\nsled->cdev.default_trigger =\r\nof_get_property(child, "linux,default-trigger", NULL);\r\nstate = of_get_property(child, "default-state", NULL);\r\nif (state) {\r\nif (!strcmp(state, "keep")) {\r\nu32 val;\r\nret = regmap_read(map, sled->offset, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nsled->state = !!(val & sled->mask);\r\n} else if (!strcmp(state, "on")) {\r\nsled->state = true;\r\nret = regmap_update_bits(map, sled->offset,\r\nsled->mask,\r\nsled->mask);\r\nif (ret < 0)\r\nreturn ret;\r\n} else {\r\nsled->state = false;\r\nret = regmap_update_bits(map, sled->offset,\r\nsled->mask, 0);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nsled->cdev.brightness_set = syscon_led_set;\r\nret = led_classdev_register(dev, &sled->cdev);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_info(dev, "registered LED %s\n", sled->cdev.name);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init syscon_leds_init(void)\r\n{\r\nstruct device_node *np;\r\nfor_each_of_allnodes(np) {\r\nstruct platform_device *pdev;\r\nstruct regmap *map;\r\nint ret;\r\nif (!of_device_is_compatible(np, "syscon"))\r\ncontinue;\r\nmap = syscon_node_to_regmap(np);\r\nif (IS_ERR(map)) {\r\npr_err("error getting regmap for syscon LEDs\n");\r\ncontinue;\r\n}\r\npdev = of_find_device_by_node(np);\r\nif (!pdev)\r\nreturn -ENODEV;\r\nret = syscon_leds_spawn(np, &pdev->dev, map);\r\nif (ret)\r\ndev_err(&pdev->dev, "could not spawn syscon LEDs\n");\r\n}\r\nreturn 0;\r\n}
