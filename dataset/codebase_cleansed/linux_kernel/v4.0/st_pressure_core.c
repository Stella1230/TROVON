static int st_press_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *ch,\r\nint val,\r\nint val2,\r\nlong mask)\r\n{\r\nint err;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nif (val2)\r\nreturn -EINVAL;\r\nmutex_lock(&indio_dev->mlock);\r\nerr = st_sensors_set_odr(indio_dev, val);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn err;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int st_press_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *ch, int *val,\r\nint *val2, long mask)\r\n{\r\nint err;\r\nstruct st_sensor_data *press_data = iio_priv(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nerr = st_sensors_read_info_raw(indio_dev, ch, val);\r\nif (err < 0)\r\ngoto read_error;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = 0;\r\nswitch (ch->type) {\r\ncase IIO_PRESSURE:\r\n*val2 = press_data->current_fullscale->gain;\r\nbreak;\r\ncase IIO_TEMP:\r\n*val2 = press_data->current_fullscale->gain2;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto read_error;\r\n}\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\ncase IIO_CHAN_INFO_OFFSET:\r\nswitch (ch->type) {\r\ncase IIO_TEMP:\r\n*val = 425;\r\n*val2 = 10;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto read_error;\r\n}\r\nreturn IIO_VAL_FRACTIONAL;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\n*val = press_data->odr;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nread_error:\r\nreturn err;\r\n}\r\nint st_press_common_probe(struct iio_dev *indio_dev)\r\n{\r\nstruct st_sensor_data *press_data = iio_priv(indio_dev);\r\nint irq = press_data->get_irq_data_ready(indio_dev);\r\nint err;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &press_info;\r\nst_sensors_power_enable(indio_dev);\r\nerr = st_sensors_check_device_support(indio_dev,\r\nARRAY_SIZE(st_press_sensors_settings),\r\nst_press_sensors_settings);\r\nif (err < 0)\r\nreturn err;\r\npress_data->num_data_channels = ST_PRESS_NUMBER_DATA_CHANNELS;\r\npress_data->multiread_bit = press_data->sensor_settings->multi_read_bit;\r\nindio_dev->channels = press_data->sensor_settings->ch;\r\nindio_dev->num_channels = press_data->sensor_settings->num_ch;\r\nif (press_data->sensor_settings->fs.addr != 0)\r\npress_data->current_fullscale =\r\n(struct st_sensor_fullscale_avl *)\r\n&press_data->sensor_settings->fs.fs_avl[0];\r\npress_data->odr = press_data->sensor_settings->odr.odr_avl[0].hz;\r\nif (!press_data->dev->platform_data &&\r\npress_data->sensor_settings->drdy_irq.addr)\r\npress_data->dev->platform_data =\r\n(struct st_sensors_platform_data *)&default_press_pdata;\r\nerr = st_sensors_init_sensor(indio_dev, press_data->dev->platform_data);\r\nif (err < 0)\r\nreturn err;\r\nerr = st_press_allocate_ring(indio_dev);\r\nif (err < 0)\r\nreturn err;\r\nif (irq > 0) {\r\nerr = st_sensors_allocate_trigger(indio_dev,\r\nST_PRESS_TRIGGER_OPS);\r\nif (err < 0)\r\ngoto st_press_probe_trigger_error;\r\n}\r\nerr = iio_device_register(indio_dev);\r\nif (err)\r\ngoto st_press_device_register_error;\r\ndev_info(&indio_dev->dev, "registered pressure sensor %s\n",\r\nindio_dev->name);\r\nreturn err;\r\nst_press_device_register_error:\r\nif (irq > 0)\r\nst_sensors_deallocate_trigger(indio_dev);\r\nst_press_probe_trigger_error:\r\nst_press_deallocate_ring(indio_dev);\r\nreturn err;\r\n}\r\nvoid st_press_common_remove(struct iio_dev *indio_dev)\r\n{\r\nstruct st_sensor_data *press_data = iio_priv(indio_dev);\r\nst_sensors_power_disable(indio_dev);\r\niio_device_unregister(indio_dev);\r\nif (press_data->get_irq_data_ready(indio_dev) > 0)\r\nst_sensors_deallocate_trigger(indio_dev);\r\nst_press_deallocate_ring(indio_dev);\r\n}
