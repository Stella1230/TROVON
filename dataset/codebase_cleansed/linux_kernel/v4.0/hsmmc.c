static void omap_hsmmc1_before_set_reg(struct device *dev,\r\nint power_on, int vdd)\r\n{\r\nu32 reg, prog_io;\r\nstruct omap_hsmmc_platform_data *mmc = dev->platform_data;\r\nif (mmc->remux)\r\nmmc->remux(dev, power_on);\r\nif (power_on) {\r\nif (cpu_is_omap2430()) {\r\nreg = omap_ctrl_readl(OMAP243X_CONTROL_DEVCONF1);\r\nif ((1 << vdd) >= MMC_VDD_30_31)\r\nreg |= OMAP243X_MMC1_ACTIVE_OVERWRITE;\r\nelse\r\nreg &= ~OMAP243X_MMC1_ACTIVE_OVERWRITE;\r\nomap_ctrl_writel(reg, OMAP243X_CONTROL_DEVCONF1);\r\n}\r\nif (mmc->internal_clock) {\r\nreg = omap_ctrl_readl(OMAP2_CONTROL_DEVCONF0);\r\nreg |= OMAP2_MMCSDIO1ADPCLKISEL;\r\nomap_ctrl_writel(reg, OMAP2_CONTROL_DEVCONF0);\r\n}\r\nreg = omap_ctrl_readl(control_pbias_offset);\r\nif (cpu_is_omap3630()) {\r\nprog_io = omap_ctrl_readl(OMAP343X_CONTROL_PROG_IO1);\r\nprog_io |= OMAP3630_PRG_SDMMC1_SPEEDCTRL;\r\nomap_ctrl_writel(prog_io, OMAP343X_CONTROL_PROG_IO1);\r\n} else {\r\nreg |= OMAP2_PBIASSPEEDCTRL0;\r\n}\r\nreg &= ~OMAP2_PBIASLITEPWRDNZ0;\r\nomap_ctrl_writel(reg, control_pbias_offset);\r\n} else {\r\nreg = omap_ctrl_readl(control_pbias_offset);\r\nreg &= ~OMAP2_PBIASLITEPWRDNZ0;\r\nomap_ctrl_writel(reg, control_pbias_offset);\r\n}\r\n}\r\nstatic void omap_hsmmc1_after_set_reg(struct device *dev, int power_on, int vdd)\r\n{\r\nu32 reg;\r\nmsleep(100);\r\nif (power_on) {\r\nreg = omap_ctrl_readl(control_pbias_offset);\r\nreg |= (OMAP2_PBIASLITEPWRDNZ0 | OMAP2_PBIASSPEEDCTRL0);\r\nif ((1 << vdd) <= MMC_VDD_165_195)\r\nreg &= ~OMAP2_PBIASLITEVMODE0;\r\nelse\r\nreg |= OMAP2_PBIASLITEVMODE0;\r\nomap_ctrl_writel(reg, control_pbias_offset);\r\n} else {\r\nreg = omap_ctrl_readl(control_pbias_offset);\r\nreg |= (OMAP2_PBIASSPEEDCTRL0 | OMAP2_PBIASLITEPWRDNZ0 |\r\nOMAP2_PBIASLITEVMODE0);\r\nomap_ctrl_writel(reg, control_pbias_offset);\r\n}\r\n}\r\nstatic void hsmmc2_select_input_clk_src(struct omap_hsmmc_platform_data *mmc)\r\n{\r\nu32 reg;\r\nreg = omap_ctrl_readl(control_devconf1_offset);\r\nif (mmc->internal_clock)\r\nreg |= OMAP2_MMCSDIO2ADPCLKISEL;\r\nelse\r\nreg &= ~OMAP2_MMCSDIO2ADPCLKISEL;\r\nomap_ctrl_writel(reg, control_devconf1_offset);\r\n}\r\nstatic void hsmmc2_before_set_reg(struct device *dev, int power_on, int vdd)\r\n{\r\nstruct omap_hsmmc_platform_data *mmc = dev->platform_data;\r\nif (mmc->remux)\r\nmmc->remux(dev, power_on);\r\nif (power_on)\r\nhsmmc2_select_input_clk_src(mmc);\r\n}\r\nstatic int am35x_hsmmc2_set_power(struct device *dev, int power_on, int vdd)\r\n{\r\nstruct omap_hsmmc_platform_data *mmc = dev->platform_data;\r\nif (power_on)\r\nhsmmc2_select_input_clk_src(mmc);\r\nreturn 0;\r\n}\r\nstatic int nop_mmc_set_power(struct device *dev, int power_on, int vdd)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void omap_hsmmc_mux(struct omap_hsmmc_platform_data\r\n*mmc_controller, int controller_nr)\r\n{\r\nif (gpio_is_valid(mmc_controller->switch_pin) &&\r\n(mmc_controller->switch_pin < OMAP_MAX_GPIO_LINES))\r\nomap_mux_init_gpio(mmc_controller->switch_pin,\r\nOMAP_PIN_INPUT_PULLUP);\r\nif (gpio_is_valid(mmc_controller->gpio_wp) &&\r\n(mmc_controller->gpio_wp < OMAP_MAX_GPIO_LINES))\r\nomap_mux_init_gpio(mmc_controller->gpio_wp,\r\nOMAP_PIN_INPUT_PULLUP);\r\nif (cpu_is_omap34xx()) {\r\nif (controller_nr == 0) {\r\nomap_mux_init_signal("sdmmc1_clk",\r\nOMAP_PIN_INPUT_PULLUP);\r\nomap_mux_init_signal("sdmmc1_cmd",\r\nOMAP_PIN_INPUT_PULLUP);\r\nomap_mux_init_signal("sdmmc1_dat0",\r\nOMAP_PIN_INPUT_PULLUP);\r\nif (mmc_controller->caps &\r\n(MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA)) {\r\nomap_mux_init_signal("sdmmc1_dat1",\r\nOMAP_PIN_INPUT_PULLUP);\r\nomap_mux_init_signal("sdmmc1_dat2",\r\nOMAP_PIN_INPUT_PULLUP);\r\nomap_mux_init_signal("sdmmc1_dat3",\r\nOMAP_PIN_INPUT_PULLUP);\r\n}\r\nif (mmc_controller->caps &\r\nMMC_CAP_8_BIT_DATA) {\r\nomap_mux_init_signal("sdmmc1_dat4",\r\nOMAP_PIN_INPUT_PULLUP);\r\nomap_mux_init_signal("sdmmc1_dat5",\r\nOMAP_PIN_INPUT_PULLUP);\r\nomap_mux_init_signal("sdmmc1_dat6",\r\nOMAP_PIN_INPUT_PULLUP);\r\nomap_mux_init_signal("sdmmc1_dat7",\r\nOMAP_PIN_INPUT_PULLUP);\r\n}\r\n}\r\nif (controller_nr == 1) {\r\nomap_mux_init_signal("sdmmc2_clk",\r\nOMAP_PIN_INPUT_PULLUP);\r\nomap_mux_init_signal("sdmmc2_cmd",\r\nOMAP_PIN_INPUT_PULLUP);\r\nomap_mux_init_signal("sdmmc2_dat0",\r\nOMAP_PIN_INPUT_PULLUP);\r\nif (mmc_controller->caps &\r\n(MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA)) {\r\nomap_mux_init_signal("sdmmc2_dat1",\r\nOMAP_PIN_INPUT_PULLUP);\r\nomap_mux_init_signal("sdmmc2_dat2",\r\nOMAP_PIN_INPUT_PULLUP);\r\nomap_mux_init_signal("sdmmc2_dat3",\r\nOMAP_PIN_INPUT_PULLUP);\r\n}\r\nif (mmc_controller->caps &\r\nMMC_CAP_8_BIT_DATA) {\r\nomap_mux_init_signal("sdmmc2_dat4.sdmmc2_dat4",\r\nOMAP_PIN_INPUT_PULLUP);\r\nomap_mux_init_signal("sdmmc2_dat5.sdmmc2_dat5",\r\nOMAP_PIN_INPUT_PULLUP);\r\nomap_mux_init_signal("sdmmc2_dat6.sdmmc2_dat6",\r\nOMAP_PIN_INPUT_PULLUP);\r\nomap_mux_init_signal("sdmmc2_dat7.sdmmc2_dat7",\r\nOMAP_PIN_INPUT_PULLUP);\r\n}\r\n}\r\n}\r\n}\r\nstatic int __init omap_hsmmc_pdata_init(struct omap2_hsmmc_info *c,\r\nstruct omap_hsmmc_platform_data *mmc)\r\n{\r\nchar *hc_name;\r\nhc_name = kzalloc(sizeof(char) * (HSMMC_NAME_LEN + 1), GFP_KERNEL);\r\nif (!hc_name) {\r\npr_err("Cannot allocate memory for controller slot name\n");\r\nkfree(hc_name);\r\nreturn -ENOMEM;\r\n}\r\nif (c->name)\r\nstrncpy(hc_name, c->name, HSMMC_NAME_LEN);\r\nelse\r\nsnprintf(hc_name, (HSMMC_NAME_LEN + 1), "mmc%islot%i",\r\nc->mmc, 1);\r\nmmc->name = hc_name;\r\nmmc->caps = c->caps;\r\nmmc->internal_clock = !c->ext_clock;\r\nmmc->reg_offset = 0;\r\nmmc->switch_pin = c->gpio_cd;\r\nmmc->gpio_wp = c->gpio_wp;\r\nmmc->remux = c->remux;\r\nmmc->init_card = c->init_card;\r\nif (c->cover_only)\r\nmmc->cover = 1;\r\nif (c->nonremovable)\r\nmmc->nonremovable = 1;\r\nif (soc_is_am35xx())\r\nmmc->ocr_mask = MMC_VDD_165_195 |\r\nMMC_VDD_26_27 |\r\nMMC_VDD_27_28 |\r\nMMC_VDD_29_30 |\r\nMMC_VDD_30_31 |\r\nMMC_VDD_31_32;\r\nelse\r\nmmc->ocr_mask = c->ocr_mask;\r\nif (!soc_is_am35xx())\r\nmmc->features |= HSMMC_HAS_PBIAS;\r\nswitch (c->mmc) {\r\ncase 1:\r\nif (mmc->features & HSMMC_HAS_PBIAS) {\r\nmmc->before_set_reg =\r\nomap_hsmmc1_before_set_reg;\r\nmmc->after_set_reg =\r\nomap_hsmmc1_after_set_reg;\r\n}\r\nif (soc_is_am35xx())\r\nmmc->set_power = nop_mmc_set_power;\r\nif (cpu_is_omap3630() &&\r\n(c->caps & MMC_CAP_8_BIT_DATA)) {\r\nc->caps &= ~MMC_CAP_8_BIT_DATA;\r\nc->caps |= MMC_CAP_4_BIT_DATA;\r\nmmc->caps = c->caps;\r\n}\r\nbreak;\r\ncase 2:\r\nif (soc_is_am35xx())\r\nmmc->set_power = am35x_hsmmc2_set_power;\r\nif (c->ext_clock)\r\nc->transceiver = 1;\r\nif (c->transceiver && (c->caps & MMC_CAP_8_BIT_DATA)) {\r\nc->caps &= ~MMC_CAP_8_BIT_DATA;\r\nc->caps |= MMC_CAP_4_BIT_DATA;\r\n}\r\nif (mmc->features & HSMMC_HAS_PBIAS) {\r\nmmc->before_set_reg = hsmmc2_before_set_reg;\r\nmmc->after_set_reg = NULL;\r\n}\r\nbreak;\r\ncase 3:\r\ncase 4:\r\ncase 5:\r\nmmc->before_set_reg = NULL;\r\nmmc->after_set_reg = NULL;\r\nbreak;\r\ndefault:\r\npr_err("MMC%d configuration not supported!\n", c->mmc);\r\nkfree(hc_name);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nvoid omap_hsmmc_late_init(struct omap2_hsmmc_info *c)\r\n{\r\nstruct platform_device *pdev;\r\nstruct omap_hsmmc_platform_data *mmc_pdata;\r\nint res;\r\nif (omap_hsmmc_done != 1)\r\nreturn;\r\nomap_hsmmc_done++;\r\nfor (; c->mmc; c++) {\r\nif (!c->deferred)\r\ncontinue;\r\npdev = c->pdev;\r\nif (!pdev)\r\ncontinue;\r\nmmc_pdata = pdev->dev.platform_data;\r\nif (!mmc_pdata)\r\ncontinue;\r\nmmc_pdata->switch_pin = c->gpio_cd;\r\nmmc_pdata->gpio_wp = c->gpio_wp;\r\nres = omap_device_register(pdev);\r\nif (res)\r\npr_err("Could not late init MMC %s\n",\r\nc->name);\r\n}\r\n}\r\nstatic void __init omap_hsmmc_init_one(struct omap2_hsmmc_info *hsmmcinfo,\r\nint ctrl_nr)\r\n{\r\nstruct omap_hwmod *oh;\r\nstruct omap_hwmod *ohs[1];\r\nstruct omap_device *od;\r\nstruct platform_device *pdev;\r\nchar oh_name[MAX_OMAP_MMC_HWMOD_NAME_LEN];\r\nstruct omap_hsmmc_platform_data *mmc_data;\r\nstruct omap_hsmmc_dev_attr *mmc_dev_attr;\r\nchar *name;\r\nint res;\r\nmmc_data = kzalloc(sizeof(*mmc_data), GFP_KERNEL);\r\nif (!mmc_data) {\r\npr_err("Cannot allocate memory for mmc device!\n");\r\nreturn;\r\n}\r\nres = omap_hsmmc_pdata_init(hsmmcinfo, mmc_data);\r\nif (res < 0)\r\ngoto free_mmc;\r\nomap_hsmmc_mux(mmc_data, (ctrl_nr - 1));\r\nname = "omap_hsmmc";\r\nres = snprintf(oh_name, MAX_OMAP_MMC_HWMOD_NAME_LEN,\r\n"mmc%d", ctrl_nr);\r\nWARN(res >= MAX_OMAP_MMC_HWMOD_NAME_LEN,\r\n"String buffer overflow in MMC%d device setup\n", ctrl_nr);\r\noh = omap_hwmod_lookup(oh_name);\r\nif (!oh) {\r\npr_err("Could not look up %s\n", oh_name);\r\ngoto free_name;\r\n}\r\nohs[0] = oh;\r\nif (oh->dev_attr != NULL) {\r\nmmc_dev_attr = oh->dev_attr;\r\nmmc_data->controller_flags = mmc_dev_attr->flags;\r\nif (hsmmcinfo->transceiver)\r\nmmc_data->controller_flags &=\r\n~OMAP_HSMMC_BROKEN_MULTIBLOCK_READ;\r\n}\r\npdev = platform_device_alloc(name, ctrl_nr - 1);\r\nif (!pdev) {\r\npr_err("Could not allocate pdev for %s\n", name);\r\ngoto free_name;\r\n}\r\ndev_set_name(&pdev->dev, "%s.%d", pdev->name, pdev->id);\r\nod = omap_device_alloc(pdev, ohs, 1);\r\nif (IS_ERR(od)) {\r\npr_err("Could not allocate od for %s\n", name);\r\ngoto put_pdev;\r\n}\r\nres = platform_device_add_data(pdev, mmc_data,\r\nsizeof(struct omap_hsmmc_platform_data));\r\nif (res) {\r\npr_err("Could not add pdata for %s\n", name);\r\ngoto put_pdev;\r\n}\r\nhsmmcinfo->pdev = pdev;\r\nif (hsmmcinfo->deferred)\r\ngoto free_mmc;\r\nres = omap_device_register(pdev);\r\nif (res) {\r\npr_err("Could not register od for %s\n", name);\r\ngoto free_od;\r\n}\r\ngoto free_mmc;\r\nfree_od:\r\nomap_device_delete(od);\r\nput_pdev:\r\nplatform_device_put(pdev);\r\nfree_name:\r\nkfree(mmc_data->name);\r\nfree_mmc:\r\nkfree(mmc_data);\r\n}\r\nvoid __init omap_hsmmc_init(struct omap2_hsmmc_info *controllers)\r\n{\r\nif (omap_hsmmc_done)\r\nreturn;\r\nomap_hsmmc_done = 1;\r\nif (cpu_is_omap2430()) {\r\ncontrol_pbias_offset = OMAP243X_CONTROL_PBIAS_LITE;\r\ncontrol_devconf1_offset = OMAP243X_CONTROL_DEVCONF1;\r\n} else {\r\ncontrol_pbias_offset = OMAP343X_CONTROL_PBIAS_LITE;\r\ncontrol_devconf1_offset = OMAP343X_CONTROL_DEVCONF1;\r\n}\r\nfor (; controllers->mmc; controllers++)\r\nomap_hsmmc_init_one(controllers, controllers->mmc);\r\n}
