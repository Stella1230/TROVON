static void __sdla_read(struct net_device *dev, int addr, void *buf, short len)\r\n{\r\nchar *temp;\r\nconst void *base;\r\nint offset, bytes;\r\ntemp = buf;\r\nwhile(len)\r\n{\r\noffset = addr & SDLA_ADDR_MASK;\r\nbytes = offset + len > SDLA_WINDOW_SIZE ? SDLA_WINDOW_SIZE - offset : len;\r\nbase = (const void *) (dev->mem_start + offset);\r\nSDLA_WINDOW(dev, addr);\r\nmemcpy(temp, base, bytes);\r\naddr += bytes;\r\ntemp += bytes;\r\nlen -= bytes;\r\n}\r\n}\r\nstatic void sdla_read(struct net_device *dev, int addr, void *buf, short len)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sdla_lock, flags);\r\n__sdla_read(dev, addr, buf, len);\r\nspin_unlock_irqrestore(&sdla_lock, flags);\r\n}\r\nstatic void __sdla_write(struct net_device *dev, int addr,\r\nconst void *buf, short len)\r\n{\r\nconst char *temp;\r\nvoid *base;\r\nint offset, bytes;\r\ntemp = buf;\r\nwhile(len)\r\n{\r\noffset = addr & SDLA_ADDR_MASK;\r\nbytes = offset + len > SDLA_WINDOW_SIZE ? SDLA_WINDOW_SIZE - offset : len;\r\nbase = (void *) (dev->mem_start + offset);\r\nSDLA_WINDOW(dev, addr);\r\nmemcpy(base, temp, bytes);\r\naddr += bytes;\r\ntemp += bytes;\r\nlen -= bytes;\r\n}\r\n}\r\nstatic void sdla_write(struct net_device *dev, int addr,\r\nconst void *buf, short len)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sdla_lock, flags);\r\n__sdla_write(dev, addr, buf, len);\r\nspin_unlock_irqrestore(&sdla_lock, flags);\r\n}\r\nstatic void sdla_clear(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nchar *base;\r\nint len, addr, bytes;\r\nlen = 65536;\r\naddr = 0;\r\nbytes = SDLA_WINDOW_SIZE;\r\nbase = (void *) dev->mem_start;\r\nspin_lock_irqsave(&sdla_lock, flags);\r\nwhile(len)\r\n{\r\nSDLA_WINDOW(dev, addr);\r\nmemset(base, 0, bytes);\r\naddr += bytes;\r\nlen -= bytes;\r\n}\r\nspin_unlock_irqrestore(&sdla_lock, flags);\r\n}\r\nstatic char sdla_byte(struct net_device *dev, int addr)\r\n{\r\nunsigned long flags;\r\nchar byte, *temp;\r\ntemp = (void *) (dev->mem_start + (addr & SDLA_ADDR_MASK));\r\nspin_lock_irqsave(&sdla_lock, flags);\r\nSDLA_WINDOW(dev, addr);\r\nbyte = *temp;\r\nspin_unlock_irqrestore(&sdla_lock, flags);\r\nreturn byte;\r\n}\r\nstatic void sdla_stop(struct net_device *dev)\r\n{\r\nstruct frad_local *flp;\r\nflp = netdev_priv(dev);\r\nswitch(flp->type)\r\n{\r\ncase SDLA_S502A:\r\noutb(SDLA_S502A_HALT, dev->base_addr + SDLA_REG_CONTROL);\r\nflp->state = SDLA_HALT;\r\nbreak;\r\ncase SDLA_S502E:\r\noutb(SDLA_HALT, dev->base_addr + SDLA_REG_Z80_CONTROL);\r\noutb(SDLA_S502E_ENABLE, dev->base_addr + SDLA_REG_CONTROL);\r\nflp->state = SDLA_S502E_ENABLE;\r\nbreak;\r\ncase SDLA_S507:\r\nflp->state &= ~SDLA_CPUEN;\r\noutb(flp->state, dev->base_addr + SDLA_REG_CONTROL);\r\nbreak;\r\ncase SDLA_S508:\r\nflp->state &= ~SDLA_CPUEN;\r\noutb(flp->state, dev->base_addr + SDLA_REG_CONTROL);\r\nbreak;\r\n}\r\n}\r\nstatic void sdla_start(struct net_device *dev)\r\n{\r\nstruct frad_local *flp;\r\nflp = netdev_priv(dev);\r\nswitch(flp->type)\r\n{\r\ncase SDLA_S502A:\r\noutb(SDLA_S502A_NMI, dev->base_addr + SDLA_REG_CONTROL);\r\noutb(SDLA_S502A_START, dev->base_addr + SDLA_REG_CONTROL);\r\nflp->state = SDLA_S502A_START;\r\nbreak;\r\ncase SDLA_S502E:\r\noutb(SDLA_S502E_CPUEN, dev->base_addr + SDLA_REG_Z80_CONTROL);\r\noutb(0x00, dev->base_addr + SDLA_REG_CONTROL);\r\nflp->state = 0;\r\nbreak;\r\ncase SDLA_S507:\r\nflp->state |= SDLA_CPUEN;\r\noutb(flp->state, dev->base_addr + SDLA_REG_CONTROL);\r\nbreak;\r\ncase SDLA_S508:\r\nflp->state |= SDLA_CPUEN;\r\noutb(flp->state, dev->base_addr + SDLA_REG_CONTROL);\r\nbreak;\r\n}\r\n}\r\nstatic int sdla_z80_poll(struct net_device *dev, int z80_addr, int jiffs, char resp1, char resp2)\r\n{\r\nunsigned long start, done, now;\r\nchar resp, *temp;\r\nstart = now = jiffies;\r\ndone = jiffies + jiffs;\r\ntemp = (void *)dev->mem_start;\r\ntemp += z80_addr & SDLA_ADDR_MASK;\r\nresp = ~resp1;\r\nwhile (time_before(jiffies, done) && (resp != resp1) && (!resp2 || (resp != resp2)))\r\n{\r\nif (jiffies != now)\r\n{\r\nSDLA_WINDOW(dev, z80_addr);\r\nnow = jiffies;\r\nresp = *temp;\r\n}\r\n}\r\nreturn time_before(jiffies, done) ? jiffies - start : -1;\r\n}\r\nstatic int sdla_cpuspeed(struct net_device *dev, struct ifreq *ifr)\r\n{\r\nint jiffs;\r\nchar data;\r\nsdla_start(dev);\r\nif (sdla_z80_poll(dev, 0, 3*HZ, Z80_READY, 0) < 0)\r\nreturn -EIO;\r\ndata = LOADER_READY;\r\nsdla_write(dev, 0, &data, 1);\r\nif ((jiffs = sdla_z80_poll(dev, 0, 8*HZ, Z80_SCC_OK, Z80_SCC_BAD)) < 0)\r\nreturn -EIO;\r\nsdla_stop(dev);\r\nsdla_read(dev, 0, &data, 1);\r\nif (data == Z80_SCC_BAD)\r\n{\r\nprintk("%s: SCC bad\n", dev->name);\r\nreturn -EIO;\r\n}\r\nif (data != Z80_SCC_OK)\r\nreturn -EINVAL;\r\nif (jiffs < 165)\r\nifr->ifr_mtu = SDLA_CPU_16M;\r\nelse if (jiffs < 220)\r\nifr->ifr_mtu = SDLA_CPU_10M;\r\nelse if (jiffs < 258)\r\nifr->ifr_mtu = SDLA_CPU_8M;\r\nelse if (jiffs < 357)\r\nifr->ifr_mtu = SDLA_CPU_7M;\r\nelse if (jiffs < 467)\r\nifr->ifr_mtu = SDLA_CPU_5M;\r\nelse\r\nifr->ifr_mtu = SDLA_CPU_3M;\r\nreturn 0;\r\n}\r\nstatic void sdla_errors(struct net_device *dev, int cmd, int dlci, int ret, int len, void *data)\r\n{\r\nstruct _dlci_stat *pstatus;\r\nshort *pdlci;\r\nint i;\r\nchar *state, line[30];\r\nswitch (ret)\r\n{\r\ncase SDLA_RET_MODEM:\r\nstate = data;\r\nif (*state & SDLA_MODEM_DCD_LOW)\r\nnetdev_info(dev, "Modem DCD unexpectedly low!\n");\r\nif (*state & SDLA_MODEM_CTS_LOW)\r\nnetdev_info(dev, "Modem CTS unexpectedly low!\n");\r\nbreak;\r\ncase SDLA_RET_CHANNEL_OFF:\r\nnetdev_info(dev, "Channel became inoperative!\n");\r\nbreak;\r\ncase SDLA_RET_CHANNEL_ON:\r\nnetdev_info(dev, "Channel became operative!\n");\r\nbreak;\r\ncase SDLA_RET_DLCI_STATUS:\r\nnetdev_info(dev, "Status change reported by Access Node\n");\r\nlen /= sizeof(struct _dlci_stat);\r\nfor(pstatus = data, i=0;i < len;i++,pstatus++)\r\n{\r\nif (pstatus->flags & SDLA_DLCI_NEW)\r\nstate = "new";\r\nelse if (pstatus->flags & SDLA_DLCI_DELETED)\r\nstate = "deleted";\r\nelse if (pstatus->flags & SDLA_DLCI_ACTIVE)\r\nstate = "active";\r\nelse\r\n{\r\nsprintf(line, "unknown status: %02X", pstatus->flags);\r\nstate = line;\r\n}\r\nnetdev_info(dev, "DLCI %i: %s\n",\r\npstatus->dlci, state);\r\n}\r\nbreak;\r\ncase SDLA_RET_DLCI_UNKNOWN:\r\nnetdev_info(dev, "Received unknown DLCIs:");\r\nlen /= sizeof(short);\r\nfor(pdlci = data,i=0;i < len;i++,pdlci++)\r\npr_cont(" %i", *pdlci);\r\npr_cont("\n");\r\nbreak;\r\ncase SDLA_RET_TIMEOUT:\r\nnetdev_err(dev, "Command timed out!\n");\r\nbreak;\r\ncase SDLA_RET_BUF_OVERSIZE:\r\nnetdev_info(dev, "Bc/CIR overflow, acceptable size is %i\n",\r\nlen);\r\nbreak;\r\ncase SDLA_RET_BUF_TOO_BIG:\r\nnetdev_info(dev, "Buffer size over specified max of %i\n",\r\nlen);\r\nbreak;\r\ncase SDLA_RET_CHANNEL_INACTIVE:\r\ncase SDLA_RET_DLCI_INACTIVE:\r\ncase SDLA_RET_CIR_OVERFLOW:\r\ncase SDLA_RET_NO_BUFS:\r\nif (cmd == SDLA_INFORMATION_WRITE)\r\nbreak;\r\ndefault:\r\nnetdev_dbg(dev, "Cmd 0x%02X generated return code 0x%02X\n",\r\ncmd, ret);\r\nbreak;\r\n}\r\n}\r\nstatic int sdla_cmd(struct net_device *dev, int cmd, short dlci, short flags,\r\nvoid *inbuf, short inlen, void *outbuf, short *outlen)\r\n{\r\nstatic struct _frad_stat status;\r\nstruct frad_local *flp;\r\nstruct sdla_cmd *cmd_buf;\r\nunsigned long pflags;\r\nunsigned long jiffs;\r\nint ret, waiting, len;\r\nlong window;\r\nflp = netdev_priv(dev);\r\nwindow = flp->type == SDLA_S508 ? SDLA_508_CMD_BUF : SDLA_502_CMD_BUF;\r\ncmd_buf = (struct sdla_cmd *)(dev->mem_start + (window & SDLA_ADDR_MASK));\r\nret = 0;\r\nlen = 0;\r\njiffs = jiffies + HZ;\r\nspin_lock_irqsave(&sdla_lock, pflags);\r\nSDLA_WINDOW(dev, window);\r\ncmd_buf->cmd = cmd;\r\ncmd_buf->dlci = dlci;\r\ncmd_buf->flags = flags;\r\nif (inbuf)\r\nmemcpy(cmd_buf->data, inbuf, inlen);\r\ncmd_buf->length = inlen;\r\ncmd_buf->opp_flag = 1;\r\nspin_unlock_irqrestore(&sdla_lock, pflags);\r\nwaiting = 1;\r\nlen = 0;\r\nwhile (waiting && time_before_eq(jiffies, jiffs))\r\n{\r\nif (waiting++ % 3)\r\n{\r\nspin_lock_irqsave(&sdla_lock, pflags);\r\nSDLA_WINDOW(dev, window);\r\nwaiting = ((volatile int)(cmd_buf->opp_flag));\r\nspin_unlock_irqrestore(&sdla_lock, pflags);\r\n}\r\n}\r\nif (!waiting)\r\n{\r\nspin_lock_irqsave(&sdla_lock, pflags);\r\nSDLA_WINDOW(dev, window);\r\nret = cmd_buf->retval;\r\nlen = cmd_buf->length;\r\nif (outbuf && outlen)\r\n{\r\n*outlen = *outlen >= len ? len : *outlen;\r\nif (*outlen)\r\nmemcpy(outbuf, cmd_buf->data, *outlen);\r\n}\r\nif (ret)\r\nmemcpy(&status, cmd_buf->data, len > sizeof(status) ? sizeof(status) : len);\r\nspin_unlock_irqrestore(&sdla_lock, pflags);\r\n}\r\nelse\r\nret = SDLA_RET_TIMEOUT;\r\nif (ret != SDLA_RET_OK)\r\nsdla_errors(dev, cmd, dlci, ret, len, &status);\r\nreturn ret;\r\n}\r\nstatic int sdla_activate(struct net_device *slave, struct net_device *master)\r\n{\r\nstruct frad_local *flp;\r\nint i;\r\nflp = netdev_priv(slave);\r\nfor(i=0;i<CONFIG_DLCI_MAX;i++)\r\nif (flp->master[i] == master)\r\nbreak;\r\nif (i == CONFIG_DLCI_MAX)\r\nreturn -ENODEV;\r\nflp->dlci[i] = abs(flp->dlci[i]);\r\nif (netif_running(slave) && (flp->config.station == FRAD_STATION_NODE))\r\nsdla_cmd(slave, SDLA_ACTIVATE_DLCI, 0, 0, &flp->dlci[i], sizeof(short), NULL, NULL);\r\nreturn 0;\r\n}\r\nstatic int sdla_deactivate(struct net_device *slave, struct net_device *master)\r\n{\r\nstruct frad_local *flp;\r\nint i;\r\nflp = netdev_priv(slave);\r\nfor(i=0;i<CONFIG_DLCI_MAX;i++)\r\nif (flp->master[i] == master)\r\nbreak;\r\nif (i == CONFIG_DLCI_MAX)\r\nreturn -ENODEV;\r\nflp->dlci[i] = -abs(flp->dlci[i]);\r\nif (netif_running(slave) && (flp->config.station == FRAD_STATION_NODE))\r\nsdla_cmd(slave, SDLA_DEACTIVATE_DLCI, 0, 0, &flp->dlci[i], sizeof(short), NULL, NULL);\r\nreturn 0;\r\n}\r\nstatic int sdla_assoc(struct net_device *slave, struct net_device *master)\r\n{\r\nstruct frad_local *flp;\r\nint i;\r\nif (master->type != ARPHRD_DLCI)\r\nreturn -EINVAL;\r\nflp = netdev_priv(slave);\r\nfor(i=0;i<CONFIG_DLCI_MAX;i++)\r\n{\r\nif (!flp->master[i])\r\nbreak;\r\nif (abs(flp->dlci[i]) == *(short *)(master->dev_addr))\r\nreturn -EADDRINUSE;\r\n}\r\nif (i == CONFIG_DLCI_MAX)\r\nreturn -EMLINK;\r\nflp->master[i] = master;\r\nflp->dlci[i] = -*(short *)(master->dev_addr);\r\nmaster->mtu = slave->mtu;\r\nif (netif_running(slave)) {\r\nif (flp->config.station == FRAD_STATION_CPE)\r\nsdla_reconfig(slave);\r\nelse\r\nsdla_cmd(slave, SDLA_ADD_DLCI, 0, 0, master->dev_addr, sizeof(short), NULL, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sdla_deassoc(struct net_device *slave, struct net_device *master)\r\n{\r\nstruct frad_local *flp;\r\nint i;\r\nflp = netdev_priv(slave);\r\nfor(i=0;i<CONFIG_DLCI_MAX;i++)\r\nif (flp->master[i] == master)\r\nbreak;\r\nif (i == CONFIG_DLCI_MAX)\r\nreturn -ENODEV;\r\nflp->master[i] = NULL;\r\nflp->dlci[i] = 0;\r\nif (netif_running(slave)) {\r\nif (flp->config.station == FRAD_STATION_CPE)\r\nsdla_reconfig(slave);\r\nelse\r\nsdla_cmd(slave, SDLA_DELETE_DLCI, 0, 0, master->dev_addr, sizeof(short), NULL, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sdla_dlci_conf(struct net_device *slave, struct net_device *master, int get)\r\n{\r\nstruct frad_local *flp;\r\nstruct dlci_local *dlp;\r\nint i;\r\nshort len, ret;\r\nflp = netdev_priv(slave);\r\nfor(i=0;i<CONFIG_DLCI_MAX;i++)\r\nif (flp->master[i] == master)\r\nbreak;\r\nif (i == CONFIG_DLCI_MAX)\r\nreturn -ENODEV;\r\ndlp = netdev_priv(master);\r\nret = SDLA_RET_OK;\r\nlen = sizeof(struct dlci_conf);\r\nif (netif_running(slave)) {\r\nif (get)\r\nret = sdla_cmd(slave, SDLA_READ_DLCI_CONFIGURATION, abs(flp->dlci[i]), 0,\r\nNULL, 0, &dlp->config, &len);\r\nelse\r\nret = sdla_cmd(slave, SDLA_SET_DLCI_CONFIGURATION, abs(flp->dlci[i]), 0,\r\n&dlp->config, sizeof(struct dlci_conf) - 4 * sizeof(short), NULL, NULL);\r\n}\r\nreturn ret == SDLA_RET_OK ? 0 : -EIO;\r\n}\r\nstatic netdev_tx_t sdla_transmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct frad_local *flp;\r\nint ret, addr, accept, i;\r\nshort size;\r\nunsigned long flags;\r\nstruct buf_entry *pbuf;\r\nflp = netdev_priv(dev);\r\nret = 0;\r\naccept = 1;\r\nnetif_stop_queue(dev);\r\naccept = 1;\r\nswitch (dev->type)\r\n{\r\ncase ARPHRD_FRAD:\r\nif (skb->dev->type != ARPHRD_DLCI)\r\n{\r\nnetdev_warn(dev, "Non DLCI device, type %i, tried to send on FRAD module\n",\r\nskb->dev->type);\r\naccept = 0;\r\n}\r\nbreak;\r\ndefault:\r\nnetdev_warn(dev, "unknown firmware type 0x%04X\n",\r\ndev->type);\r\naccept = 0;\r\nbreak;\r\n}\r\nif (accept)\r\n{\r\nswitch (flp->type)\r\n{\r\ncase SDLA_S502A:\r\ncase SDLA_S502E:\r\nret = sdla_cmd(dev, SDLA_INFORMATION_WRITE, *(short *)(skb->dev->dev_addr), 0, skb->data, skb->len, NULL, NULL);\r\nbreak;\r\ncase SDLA_S508:\r\nsize = sizeof(addr);\r\nret = sdla_cmd(dev, SDLA_INFORMATION_WRITE, *(short *)(skb->dev->dev_addr), 0, NULL, skb->len, &addr, &size);\r\nif (ret == SDLA_RET_OK)\r\n{\r\nspin_lock_irqsave(&sdla_lock, flags);\r\nSDLA_WINDOW(dev, addr);\r\npbuf = (void *)(((int) dev->mem_start) + (addr & SDLA_ADDR_MASK));\r\n__sdla_write(dev, pbuf->buf_addr, skb->data, skb->len);\r\nSDLA_WINDOW(dev, addr);\r\npbuf->opp_flag = 1;\r\nspin_unlock_irqrestore(&sdla_lock, flags);\r\n}\r\nbreak;\r\n}\r\nswitch (ret)\r\n{\r\ncase SDLA_RET_OK:\r\ndev->stats.tx_packets++;\r\nbreak;\r\ncase SDLA_RET_CIR_OVERFLOW:\r\ncase SDLA_RET_BUF_OVERSIZE:\r\ncase SDLA_RET_NO_BUFS:\r\ndev->stats.tx_dropped++;\r\nbreak;\r\ndefault:\r\ndev->stats.tx_errors++;\r\nbreak;\r\n}\r\n}\r\nnetif_wake_queue(dev);\r\nfor(i=0;i<CONFIG_DLCI_MAX;i++)\r\n{\r\nif(flp->master[i]!=NULL)\r\nnetif_wake_queue(flp->master[i]);\r\n}\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void sdla_receive(struct net_device *dev)\r\n{\r\nstruct net_device *master;\r\nstruct frad_local *flp;\r\nstruct dlci_local *dlp;\r\nstruct sk_buff *skb;\r\nstruct sdla_cmd *cmd;\r\nstruct buf_info *pbufi;\r\nstruct buf_entry *pbuf;\r\nunsigned long flags;\r\nint i=0, received, success, addr, buf_base, buf_top;\r\nshort dlci, len, len2, split;\r\nflp = netdev_priv(dev);\r\nsuccess = 1;\r\nreceived = addr = buf_top = buf_base = 0;\r\nlen = dlci = 0;\r\nskb = NULL;\r\nmaster = NULL;\r\ncmd = NULL;\r\npbufi = NULL;\r\npbuf = NULL;\r\nspin_lock_irqsave(&sdla_lock, flags);\r\nswitch (flp->type)\r\n{\r\ncase SDLA_S502A:\r\ncase SDLA_S502E:\r\ncmd = (void *) (dev->mem_start + (SDLA_502_RCV_BUF & SDLA_ADDR_MASK));\r\nSDLA_WINDOW(dev, SDLA_502_RCV_BUF);\r\nsuccess = cmd->opp_flag;\r\nif (!success)\r\nbreak;\r\ndlci = cmd->dlci;\r\nlen = cmd->length;\r\nbreak;\r\ncase SDLA_S508:\r\npbufi = (void *) (dev->mem_start + (SDLA_508_RXBUF_INFO & SDLA_ADDR_MASK));\r\nSDLA_WINDOW(dev, SDLA_508_RXBUF_INFO);\r\npbuf = (void *) (dev->mem_start + ((pbufi->rse_base + flp->buffer * sizeof(struct buf_entry)) & SDLA_ADDR_MASK));\r\nsuccess = pbuf->opp_flag;\r\nif (!success)\r\nbreak;\r\nbuf_top = pbufi->buf_top;\r\nbuf_base = pbufi->buf_base;\r\ndlci = pbuf->dlci;\r\nlen = pbuf->length;\r\naddr = pbuf->buf_addr;\r\nbreak;\r\n}\r\nif (success)\r\n{\r\nfor (i=0;i<CONFIG_DLCI_MAX;i++)\r\nif (flp->dlci[i] == dlci)\r\nbreak;\r\nif (i == CONFIG_DLCI_MAX)\r\n{\r\nnetdev_notice(dev, "Received packet from invalid DLCI %i, ignoring\n",\r\ndlci);\r\ndev->stats.rx_errors++;\r\nsuccess = 0;\r\n}\r\n}\r\nif (success)\r\n{\r\nmaster = flp->master[i];\r\nskb = dev_alloc_skb(len + sizeof(struct frhdr));\r\nif (skb == NULL)\r\n{\r\nnetdev_notice(dev, "Memory squeeze, dropping packet\n");\r\ndev->stats.rx_dropped++;\r\nsuccess = 0;\r\n}\r\nelse\r\nskb_reserve(skb, sizeof(struct frhdr));\r\n}\r\nswitch (flp->type)\r\n{\r\ncase SDLA_S502A:\r\ncase SDLA_S502E:\r\nif (success)\r\n__sdla_read(dev, SDLA_502_RCV_BUF + SDLA_502_DATA_OFS, skb_put(skb,len), len);\r\nSDLA_WINDOW(dev, SDLA_502_RCV_BUF);\r\ncmd->opp_flag = 0;\r\nbreak;\r\ncase SDLA_S508:\r\nif (success)\r\n{\r\nsplit = addr + len > buf_top + 1 ? len - (buf_top - addr + 1) : 0;\r\nlen2 = len - split;\r\n__sdla_read(dev, addr, skb_put(skb, len2), len2);\r\nif (split)\r\n__sdla_read(dev, buf_base, skb_put(skb, split), split);\r\n}\r\nSDLA_WINDOW(dev, SDLA_508_RXBUF_INFO);\r\nflp->buffer = (flp->buffer + 1) % pbufi->rse_num;\r\npbuf->opp_flag = 0;\r\nbreak;\r\n}\r\nif (success)\r\n{\r\ndev->stats.rx_packets++;\r\ndlp = netdev_priv(master);\r\n(*dlp->receive)(skb, master);\r\n}\r\nspin_unlock_irqrestore(&sdla_lock, flags);\r\n}\r\nstatic irqreturn_t sdla_isr(int dummy, void *dev_id)\r\n{\r\nstruct net_device *dev;\r\nstruct frad_local *flp;\r\nchar byte;\r\ndev = dev_id;\r\nflp = netdev_priv(dev);\r\nif (!flp->initialized)\r\n{\r\nnetdev_warn(dev, "irq %d for uninitialized device\n", dev->irq);\r\nreturn IRQ_NONE;\r\n}\r\nbyte = sdla_byte(dev, flp->type == SDLA_S508 ? SDLA_508_IRQ_INTERFACE : SDLA_502_IRQ_INTERFACE);\r\nswitch (byte)\r\n{\r\ncase SDLA_INTR_RX:\r\nsdla_receive(dev);\r\nbreak;\r\ncase SDLA_INTR_MODEM:\r\ncase SDLA_INTR_STATUS:\r\nsdla_cmd(dev, SDLA_READ_DLC_STATUS, 0, 0, NULL, 0, NULL, NULL);\r\nbreak;\r\ncase SDLA_INTR_TX:\r\ncase SDLA_INTR_COMPLETE:\r\ncase SDLA_INTR_TIMER:\r\nnetdev_warn(dev, "invalid irq flag 0x%02X\n", byte);\r\nbreak;\r\n}\r\nif (flp->type == SDLA_S502E)\r\n{\r\nflp->state &= ~SDLA_S502E_INTACK;\r\noutb(flp->state, dev->base_addr + SDLA_REG_CONTROL);\r\nflp->state |= SDLA_S502E_INTACK;\r\noutb(flp->state, dev->base_addr + SDLA_REG_CONTROL);\r\n}\r\nbyte = 0;\r\nsdla_write(dev, flp->type == SDLA_S508 ? SDLA_508_IRQ_INTERFACE : SDLA_502_IRQ_INTERFACE, &byte, sizeof(byte));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sdla_poll(unsigned long device)\r\n{\r\nstruct net_device *dev;\r\nstruct frad_local *flp;\r\ndev = (struct net_device *) device;\r\nflp = netdev_priv(dev);\r\nif (sdla_byte(dev, SDLA_502_RCV_BUF))\r\nsdla_receive(dev);\r\nflp->timer.expires = 1;\r\nadd_timer(&flp->timer);\r\n}\r\nstatic int sdla_close(struct net_device *dev)\r\n{\r\nstruct frad_local *flp;\r\nstruct intr_info intr;\r\nint len, i;\r\nshort dlcis[CONFIG_DLCI_MAX];\r\nflp = netdev_priv(dev);\r\nlen = 0;\r\nfor(i=0;i<CONFIG_DLCI_MAX;i++)\r\nif (flp->dlci[i])\r\ndlcis[len++] = abs(flp->dlci[i]);\r\nlen *= 2;\r\nif (flp->config.station == FRAD_STATION_NODE)\r\n{\r\nfor(i=0;i<CONFIG_DLCI_MAX;i++)\r\nif (flp->dlci[i] > 0)\r\nsdla_cmd(dev, SDLA_DEACTIVATE_DLCI, 0, 0, dlcis, len, NULL, NULL);\r\nsdla_cmd(dev, SDLA_DELETE_DLCI, 0, 0, &flp->dlci[i], sizeof(flp->dlci[i]), NULL, NULL);\r\n}\r\nmemset(&intr, 0, sizeof(intr));\r\nswitch(flp->type)\r\n{\r\ncase SDLA_S502A:\r\ndel_timer(&flp->timer);\r\nbreak;\r\ncase SDLA_S502E:\r\nsdla_cmd(dev, SDLA_SET_IRQ_TRIGGER, 0, 0, &intr, sizeof(char) + sizeof(short), NULL, NULL);\r\nflp->state &= ~SDLA_S502E_INTACK;\r\noutb(flp->state, dev->base_addr + SDLA_REG_CONTROL);\r\nbreak;\r\ncase SDLA_S507:\r\nbreak;\r\ncase SDLA_S508:\r\nsdla_cmd(dev, SDLA_SET_IRQ_TRIGGER, 0, 0, &intr, sizeof(struct intr_info), NULL, NULL);\r\nflp->state &= ~SDLA_S508_INTEN;\r\noutb(flp->state, dev->base_addr + SDLA_REG_CONTROL);\r\nbreak;\r\n}\r\nsdla_cmd(dev, SDLA_DISABLE_COMMUNICATIONS, 0, 0, NULL, 0, NULL, NULL);\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int sdla_open(struct net_device *dev)\r\n{\r\nstruct frad_local *flp;\r\nstruct dlci_local *dlp;\r\nstruct conf_data data;\r\nstruct intr_info intr;\r\nint len, i;\r\nchar byte;\r\nflp = netdev_priv(dev);\r\nif (!flp->initialized)\r\nreturn -EPERM;\r\nif (!flp->configured)\r\nreturn -EPERM;\r\nlen = 0;\r\nfor(i=0;i<CONFIG_DLCI_MAX;i++)\r\nif (flp->dlci[i])\r\ndata.dlci[len++] = abs(flp->dlci[i]);\r\nlen *= 2;\r\nmemcpy(&data.config, &flp->config, sizeof(struct frad_conf));\r\nlen += sizeof(struct frad_conf);\r\nsdla_cmd(dev, SDLA_DISABLE_COMMUNICATIONS, 0, 0, NULL, 0, NULL, NULL);\r\nsdla_cmd(dev, SDLA_SET_DLCI_CONFIGURATION, 0, 0, &data, len, NULL, NULL);\r\nif (flp->type == SDLA_S508)\r\nflp->buffer = 0;\r\nsdla_cmd(dev, SDLA_ENABLE_COMMUNICATIONS, 0, 0, NULL, 0, NULL, NULL);\r\nmemset(&intr, 0, sizeof(intr));\r\nswitch(flp->type)\r\n{\r\ncase SDLA_S502A:\r\nflp->timer.expires = 1;\r\nadd_timer(&flp->timer);\r\nbreak;\r\ncase SDLA_S502E:\r\nflp->state |= SDLA_S502E_ENABLE;\r\noutb(flp->state, dev->base_addr + SDLA_REG_CONTROL);\r\nflp->state |= SDLA_S502E_INTACK;\r\noutb(flp->state, dev->base_addr + SDLA_REG_CONTROL);\r\nbyte = 0;\r\nsdla_write(dev, SDLA_502_IRQ_INTERFACE, &byte, sizeof(byte));\r\nintr.flags = SDLA_INTR_RX | SDLA_INTR_STATUS | SDLA_INTR_MODEM;\r\nsdla_cmd(dev, SDLA_SET_IRQ_TRIGGER, 0, 0, &intr, sizeof(char) + sizeof(short), NULL, NULL);\r\nbreak;\r\ncase SDLA_S507:\r\nbreak;\r\ncase SDLA_S508:\r\nflp->state |= SDLA_S508_INTEN;\r\noutb(flp->state, dev->base_addr + SDLA_REG_CONTROL);\r\nbyte = 0;\r\nsdla_write(dev, SDLA_508_IRQ_INTERFACE, &byte, sizeof(byte));\r\nintr.flags = SDLA_INTR_RX | SDLA_INTR_STATUS | SDLA_INTR_MODEM;\r\nintr.irq = dev->irq;\r\nsdla_cmd(dev, SDLA_SET_IRQ_TRIGGER, 0, 0, &intr, sizeof(struct intr_info), NULL, NULL);\r\nbreak;\r\n}\r\nif (flp->config.station == FRAD_STATION_CPE)\r\n{\r\nbyte = SDLA_ICS_STATUS_ENQ;\r\nsdla_cmd(dev, SDLA_ISSUE_IN_CHANNEL_SIGNAL, 0, 0, &byte, sizeof(byte), NULL, NULL);\r\n}\r\nelse\r\n{\r\nsdla_cmd(dev, SDLA_ADD_DLCI, 0, 0, data.dlci, len - sizeof(struct frad_conf), NULL, NULL);\r\nfor(i=0;i<CONFIG_DLCI_MAX;i++)\r\nif (flp->dlci[i] > 0)\r\nsdla_cmd(dev, SDLA_ACTIVATE_DLCI, 0, 0, &flp->dlci[i], 2*sizeof(flp->dlci[i]), NULL, NULL);\r\n}\r\nfor(i=0;i<CONFIG_DLCI_MAX;i++)\r\nif (flp->dlci[i])\r\n{\r\ndlp = netdev_priv(flp->master[i]);\r\nif (dlp->configured)\r\nsdla_cmd(dev, SDLA_SET_DLCI_CONFIGURATION, abs(flp->dlci[i]), 0, &dlp->config, sizeof(struct dlci_conf), NULL, NULL);\r\n}\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int sdla_config(struct net_device *dev, struct frad_conf __user *conf, int get)\r\n{\r\nstruct frad_local *flp;\r\nstruct conf_data data;\r\nint i;\r\nshort size;\r\nif (dev->type == 0xFFFF)\r\nreturn -EUNATCH;\r\nflp = netdev_priv(dev);\r\nif (!get)\r\n{\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif(copy_from_user(&data.config, conf, sizeof(struct frad_conf)))\r\nreturn -EFAULT;\r\nif (data.config.station & ~FRAD_STATION_NODE)\r\nreturn -EINVAL;\r\nif (data.config.flags & ~FRAD_VALID_FLAGS)\r\nreturn -EINVAL;\r\nif ((data.config.kbaud < 0) ||\r\n((data.config.kbaud > 128) && (flp->type != SDLA_S508)))\r\nreturn -EINVAL;\r\nif (data.config.clocking & ~(FRAD_CLOCK_INT | SDLA_S508_PORT_RS232))\r\nreturn -EINVAL;\r\nif ((data.config.mtu < 0) || (data.config.mtu > SDLA_MAX_MTU))\r\nreturn -EINVAL;\r\nif ((data.config.T391 < 5) || (data.config.T391 > 30))\r\nreturn -EINVAL;\r\nif ((data.config.T392 < 5) || (data.config.T392 > 30))\r\nreturn -EINVAL;\r\nif ((data.config.N391 < 1) || (data.config.N391 > 255))\r\nreturn -EINVAL;\r\nif ((data.config.N392 < 1) || (data.config.N392 > 10))\r\nreturn -EINVAL;\r\nif ((data.config.N393 < 1) || (data.config.N393 > 10))\r\nreturn -EINVAL;\r\nmemcpy(&flp->config, &data.config, sizeof(struct frad_conf));\r\nflp->config.flags |= SDLA_DIRECT_RECV;\r\nif (flp->type == SDLA_S508)\r\nflp->config.flags |= SDLA_TX70_RX30;\r\nif (dev->mtu != flp->config.mtu)\r\n{\r\ndev->mtu = flp->config.mtu;\r\nfor(i=0;i<CONFIG_DLCI_MAX;i++)\r\nif (flp->master[i])\r\nflp->master[i]->mtu = flp->config.mtu;\r\n}\r\nflp->config.mtu += sizeof(struct frhdr);\r\nif (!flp->configured)\r\nsdla_start(dev);\r\nflp->configured = 1;\r\n}\r\nelse\r\n{\r\nif (netif_running(dev))\r\n{\r\nsize = sizeof(data);\r\nif (sdla_cmd(dev, SDLA_READ_DLCI_CONFIGURATION, 0, 0, NULL, 0, &data, &size) != SDLA_RET_OK)\r\nreturn -EIO;\r\n}\r\nelse\r\nif (flp->configured)\r\nmemcpy(&data.config, &flp->config, sizeof(struct frad_conf));\r\nelse\r\nmemset(&data.config, 0, sizeof(struct frad_conf));\r\nmemcpy(&flp->config, &data.config, sizeof(struct frad_conf));\r\ndata.config.flags &= FRAD_VALID_FLAGS;\r\ndata.config.mtu -= data.config.mtu > sizeof(struct frhdr) ? sizeof(struct frhdr) : data.config.mtu;\r\nreturn copy_to_user(conf, &data.config, sizeof(struct frad_conf))?-EFAULT:0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sdla_xfer(struct net_device *dev, struct sdla_mem __user *info, int read)\r\n{\r\nstruct sdla_mem mem;\r\nchar *temp;\r\nif(copy_from_user(&mem, info, sizeof(mem)))\r\nreturn -EFAULT;\r\nif (read)\r\n{\r\ntemp = kzalloc(mem.len, GFP_KERNEL);\r\nif (!temp)\r\nreturn -ENOMEM;\r\nsdla_read(dev, mem.addr, temp, mem.len);\r\nif(copy_to_user(mem.data, temp, mem.len))\r\n{\r\nkfree(temp);\r\nreturn -EFAULT;\r\n}\r\nkfree(temp);\r\n}\r\nelse\r\n{\r\ntemp = memdup_user(mem.data, mem.len);\r\nif (IS_ERR(temp))\r\nreturn PTR_ERR(temp);\r\nsdla_write(dev, mem.addr, temp, mem.len);\r\nkfree(temp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sdla_reconfig(struct net_device *dev)\r\n{\r\nstruct frad_local *flp;\r\nstruct conf_data data;\r\nint i, len;\r\nflp = netdev_priv(dev);\r\nlen = 0;\r\nfor(i=0;i<CONFIG_DLCI_MAX;i++)\r\nif (flp->dlci[i])\r\ndata.dlci[len++] = flp->dlci[i];\r\nlen *= 2;\r\nmemcpy(&data, &flp->config, sizeof(struct frad_conf));\r\nlen += sizeof(struct frad_conf);\r\nsdla_cmd(dev, SDLA_DISABLE_COMMUNICATIONS, 0, 0, NULL, 0, NULL, NULL);\r\nsdla_cmd(dev, SDLA_SET_DLCI_CONFIGURATION, 0, 0, &data, len, NULL, NULL);\r\nsdla_cmd(dev, SDLA_ENABLE_COMMUNICATIONS, 0, 0, NULL, 0, NULL, NULL);\r\nreturn 0;\r\n}\r\nstatic int sdla_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct frad_local *flp;\r\nif(!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nflp = netdev_priv(dev);\r\nif (!flp->initialized)\r\nreturn -EINVAL;\r\nswitch (cmd)\r\n{\r\ncase FRAD_GET_CONF:\r\ncase FRAD_SET_CONF:\r\nreturn sdla_config(dev, ifr->ifr_data, cmd == FRAD_GET_CONF);\r\ncase SDLA_IDENTIFY:\r\nifr->ifr_flags = flp->type;\r\nbreak;\r\ncase SDLA_CPUSPEED:\r\nreturn sdla_cpuspeed(dev, ifr);\r\ncase SDLA_PROTOCOL:\r\nif (flp->configured)\r\nreturn -EALREADY;\r\nswitch (ifr->ifr_flags)\r\n{\r\ncase ARPHRD_FRAD:\r\ndev->type = ifr->ifr_flags;\r\nbreak;\r\ndefault:\r\nreturn -ENOPROTOOPT;\r\n}\r\nbreak;\r\ncase SDLA_CLEARMEM:\r\nsdla_clear(dev);\r\nbreak;\r\ncase SDLA_WRITEMEM:\r\ncase SDLA_READMEM:\r\nif(!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nreturn sdla_xfer(dev, ifr->ifr_data, cmd == SDLA_READMEM);\r\ncase SDLA_START:\r\nsdla_start(dev);\r\nbreak;\r\ncase SDLA_STOP:\r\nsdla_stop(dev);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sdla_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int sdla_set_config(struct net_device *dev, struct ifmap *map)\r\n{\r\nstruct frad_local *flp;\r\nint i;\r\nchar byte;\r\nunsigned base;\r\nint err = -EINVAL;\r\nflp = netdev_priv(dev);\r\nif (flp->initialized)\r\nreturn -EINVAL;\r\nfor(i=0; i < ARRAY_SIZE(valid_port); i++)\r\nif (valid_port[i] == map->base_addr)\r\nbreak;\r\nif (i == ARRAY_SIZE(valid_port))\r\nreturn -EINVAL;\r\nif (!request_region(map->base_addr, SDLA_IO_EXTENTS, dev->name)){\r\npr_warn("io-port 0x%04lx in use\n", dev->base_addr);\r\nreturn -EINVAL;\r\n}\r\nbase = map->base_addr;\r\nflp->type = SDLA_UNKNOWN;\r\nflp->state = 0;\r\nfor(i=1;i<SDLA_IO_EXTENTS;i++)\r\nif (inb(base + i) != 0xFF)\r\nbreak;\r\nif (i == SDLA_IO_EXTENTS) {\r\noutb(SDLA_HALT, base + SDLA_REG_Z80_CONTROL);\r\nif ((inb(base + SDLA_S502_STS) & 0x0F) == 0x08) {\r\noutb(SDLA_S502E_INTACK, base + SDLA_REG_CONTROL);\r\nif ((inb(base + SDLA_S502_STS) & 0x0F) == 0x0C) {\r\noutb(SDLA_HALT, base + SDLA_REG_CONTROL);\r\nflp->type = SDLA_S502E;\r\ngoto got_type;\r\n}\r\n}\r\n}\r\nfor(byte=inb(base),i=0;i<SDLA_IO_EXTENTS;i++)\r\nif (inb(base + i) != byte)\r\nbreak;\r\nif (i == SDLA_IO_EXTENTS) {\r\noutb(SDLA_HALT, base + SDLA_REG_CONTROL);\r\nif ((inb(base + SDLA_S502_STS) & 0x7E) == 0x30) {\r\noutb(SDLA_S507_ENABLE, base + SDLA_REG_CONTROL);\r\nif ((inb(base + SDLA_S502_STS) & 0x7E) == 0x32) {\r\noutb(SDLA_HALT, base + SDLA_REG_CONTROL);\r\nflp->type = SDLA_S507;\r\ngoto got_type;\r\n}\r\n}\r\n}\r\noutb(SDLA_HALT, base + SDLA_REG_CONTROL);\r\nif ((inb(base + SDLA_S508_STS) & 0x3F) == 0x00) {\r\noutb(SDLA_S508_INTEN, base + SDLA_REG_CONTROL);\r\nif ((inb(base + SDLA_S508_STS) & 0x3F) == 0x10) {\r\noutb(SDLA_HALT, base + SDLA_REG_CONTROL);\r\nflp->type = SDLA_S508;\r\ngoto got_type;\r\n}\r\n}\r\noutb(SDLA_S502A_HALT, base + SDLA_REG_CONTROL);\r\nif (inb(base + SDLA_S502_STS) == 0x40) {\r\noutb(SDLA_S502A_START, base + SDLA_REG_CONTROL);\r\nif (inb(base + SDLA_S502_STS) == 0x40) {\r\noutb(SDLA_S502A_INTEN, base + SDLA_REG_CONTROL);\r\nif (inb(base + SDLA_S502_STS) == 0x44) {\r\noutb(SDLA_S502A_START, base + SDLA_REG_CONTROL);\r\nflp->type = SDLA_S502A;\r\ngoto got_type;\r\n}\r\n}\r\n}\r\nnetdev_notice(dev, "Unknown card type\n");\r\nerr = -ENODEV;\r\ngoto fail;\r\ngot_type:\r\nswitch(base) {\r\ncase 0x270:\r\ncase 0x280:\r\ncase 0x380:\r\ncase 0x390:\r\nif (flp->type != SDLA_S508 && flp->type != SDLA_S507)\r\ngoto fail;\r\n}\r\nswitch (map->irq) {\r\ncase 2:\r\nif (flp->type != SDLA_S502E)\r\ngoto fail;\r\nbreak;\r\ncase 10:\r\ncase 11:\r\ncase 12:\r\ncase 15:\r\ncase 4:\r\nif (flp->type != SDLA_S508 && flp->type != SDLA_S507)\r\ngoto fail;\r\nbreak;\r\ncase 3:\r\ncase 5:\r\ncase 7:\r\nif (flp->type == SDLA_S502A)\r\ngoto fail;\r\nbreak;\r\ndefault:\r\ngoto fail;\r\n}\r\nerr = -EAGAIN;\r\nif (request_irq(dev->irq, sdla_isr, 0, dev->name, dev))\r\ngoto fail;\r\nif (flp->type == SDLA_S507) {\r\nswitch(dev->irq) {\r\ncase 3:\r\nflp->state = SDLA_S507_IRQ3;\r\nbreak;\r\ncase 4:\r\nflp->state = SDLA_S507_IRQ4;\r\nbreak;\r\ncase 5:\r\nflp->state = SDLA_S507_IRQ5;\r\nbreak;\r\ncase 7:\r\nflp->state = SDLA_S507_IRQ7;\r\nbreak;\r\ncase 10:\r\nflp->state = SDLA_S507_IRQ10;\r\nbreak;\r\ncase 11:\r\nflp->state = SDLA_S507_IRQ11;\r\nbreak;\r\ncase 12:\r\nflp->state = SDLA_S507_IRQ12;\r\nbreak;\r\ncase 15:\r\nflp->state = SDLA_S507_IRQ15;\r\nbreak;\r\n}\r\n}\r\nfor(i=0; i < ARRAY_SIZE(valid_mem); i++)\r\nif (valid_mem[i] == map->mem_start)\r\nbreak;\r\nerr = -EINVAL;\r\nif (i == ARRAY_SIZE(valid_mem))\r\ngoto fail2;\r\nif (flp->type == SDLA_S502A && (map->mem_start & 0xF000) >> 12 == 0x0E)\r\ngoto fail2;\r\nif (flp->type != SDLA_S507 && map->mem_start >> 16 == 0x0B)\r\ngoto fail2;\r\nif (flp->type == SDLA_S507 && map->mem_start >> 16 == 0x0D)\r\ngoto fail2;\r\nbyte = flp->type != SDLA_S508 ? SDLA_8K_WINDOW : 0;\r\nbyte |= (map->mem_start & 0xF000) >> (12 + (flp->type == SDLA_S508 ? 1 : 0));\r\nswitch(flp->type) {\r\ncase SDLA_S502A:\r\ncase SDLA_S502E:\r\nswitch (map->mem_start >> 16) {\r\ncase 0x0A:\r\nbyte |= SDLA_S502_SEG_A;\r\nbreak;\r\ncase 0x0C:\r\nbyte |= SDLA_S502_SEG_C;\r\nbreak;\r\ncase 0x0D:\r\nbyte |= SDLA_S502_SEG_D;\r\nbreak;\r\ncase 0x0E:\r\nbyte |= SDLA_S502_SEG_E;\r\nbreak;\r\n}\r\nbreak;\r\ncase SDLA_S507:\r\nswitch (map->mem_start >> 16) {\r\ncase 0x0A:\r\nbyte |= SDLA_S507_SEG_A;\r\nbreak;\r\ncase 0x0B:\r\nbyte |= SDLA_S507_SEG_B;\r\nbreak;\r\ncase 0x0C:\r\nbyte |= SDLA_S507_SEG_C;\r\nbreak;\r\ncase 0x0E:\r\nbyte |= SDLA_S507_SEG_E;\r\nbreak;\r\n}\r\nbreak;\r\ncase SDLA_S508:\r\nswitch (map->mem_start >> 16) {\r\ncase 0x0A:\r\nbyte |= SDLA_S508_SEG_A;\r\nbreak;\r\ncase 0x0C:\r\nbyte |= SDLA_S508_SEG_C;\r\nbreak;\r\ncase 0x0D:\r\nbyte |= SDLA_S508_SEG_D;\r\nbreak;\r\ncase 0x0E:\r\nbyte |= SDLA_S508_SEG_E;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\noutb(byte, base + SDLA_REG_PC_WINDOW);\r\nswitch(flp->type)\r\n{\r\ncase SDLA_S502E:\r\nflp->state = SDLA_S502E_ENABLE;\r\nbreak;\r\ncase SDLA_S507:\r\nflp->state |= SDLA_MEMEN;\r\nbreak;\r\ncase SDLA_S508:\r\nflp->state = SDLA_MEMEN;\r\nbreak;\r\n}\r\noutb(flp->state, base + SDLA_REG_CONTROL);\r\ndev->irq = map->irq;\r\ndev->base_addr = base;\r\ndev->mem_start = map->mem_start;\r\ndev->mem_end = dev->mem_start + 0x2000;\r\nflp->initialized = 1;\r\nreturn 0;\r\nfail2:\r\nfree_irq(map->irq, dev);\r\nfail:\r\nrelease_region(base, SDLA_IO_EXTENTS);\r\nreturn err;\r\n}\r\nstatic void setup_sdla(struct net_device *dev)\r\n{\r\nstruct frad_local *flp = netdev_priv(dev);\r\nnetdev_boot_setup_check(dev);\r\ndev->netdev_ops = &sdla_netdev_ops;\r\ndev->flags = 0;\r\ndev->type = 0xFFFF;\r\ndev->hard_header_len = 0;\r\ndev->addr_len = 0;\r\ndev->mtu = SDLA_MAX_MTU;\r\nflp->activate = sdla_activate;\r\nflp->deactivate = sdla_deactivate;\r\nflp->assoc = sdla_assoc;\r\nflp->deassoc = sdla_deassoc;\r\nflp->dlci_conf = sdla_dlci_conf;\r\ninit_timer(&flp->timer);\r\nflp->timer.expires = 1;\r\nflp->timer.data = (unsigned long) dev;\r\nflp->timer.function = sdla_poll;\r\n}\r\nstatic int __init init_sdla(void)\r\n{\r\nint err;\r\nprintk("%s.\n", version);\r\nsdla = alloc_netdev(sizeof(struct frad_local), "sdla0",\r\nNET_NAME_UNKNOWN, setup_sdla);\r\nif (!sdla)\r\nreturn -ENOMEM;\r\nerr = register_netdev(sdla);\r\nif (err)\r\nfree_netdev(sdla);\r\nreturn err;\r\n}\r\nstatic void __exit exit_sdla(void)\r\n{\r\nstruct frad_local *flp = netdev_priv(sdla);\r\nunregister_netdev(sdla);\r\nif (flp->initialized) {\r\nfree_irq(sdla->irq, sdla);\r\nrelease_region(sdla->base_addr, SDLA_IO_EXTENTS);\r\n}\r\ndel_timer_sync(&flp->timer);\r\nfree_netdev(sdla);\r\n}
