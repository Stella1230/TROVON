static void vmw_ldu_destroy(struct vmw_legacy_display_unit *ldu)\r\n{\r\nlist_del_init(&ldu->active);\r\nvmw_display_unit_cleanup(&ldu->base);\r\nkfree(ldu);\r\n}\r\nstatic void vmw_ldu_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nvmw_ldu_destroy(vmw_crtc_to_ldu(crtc));\r\n}\r\nstatic int vmw_ldu_commit_list(struct vmw_private *dev_priv)\r\n{\r\nstruct vmw_legacy_display *lds = dev_priv->ldu_priv;\r\nstruct vmw_legacy_display_unit *entry;\r\nstruct vmw_display_unit *du = NULL;\r\nstruct drm_framebuffer *fb = NULL;\r\nstruct drm_crtc *crtc = NULL;\r\nint i = 0, ret;\r\nif (!(dev_priv->capabilities & SVGA_CAP_DISPLAY_TOPOLOGY)) {\r\nint w = 0, h = 0;\r\nlist_for_each_entry(entry, &lds->active, active) {\r\ncrtc = &entry->base.crtc;\r\nw = max(w, crtc->x + crtc->mode.hdisplay);\r\nh = max(h, crtc->y + crtc->mode.vdisplay);\r\ni++;\r\n}\r\nif (crtc == NULL)\r\nreturn 0;\r\nfb = entry->base.crtc.primary->fb;\r\nreturn vmw_kms_write_svga(dev_priv, w, h, fb->pitches[0],\r\nfb->bits_per_pixel, fb->depth);\r\n}\r\nif (!list_empty(&lds->active)) {\r\nentry = list_entry(lds->active.next, typeof(*entry), active);\r\nfb = entry->base.crtc.primary->fb;\r\nvmw_kms_write_svga(dev_priv, fb->width, fb->height, fb->pitches[0],\r\nfb->bits_per_pixel, fb->depth);\r\n}\r\nvmw_write(dev_priv, SVGA_REG_NUM_GUEST_DISPLAYS,\r\nlds->num_active ? lds->num_active : 1);\r\ni = 0;\r\nlist_for_each_entry(entry, &lds->active, active) {\r\ncrtc = &entry->base.crtc;\r\nvmw_write(dev_priv, SVGA_REG_DISPLAY_ID, i);\r\nvmw_write(dev_priv, SVGA_REG_DISPLAY_IS_PRIMARY, !i);\r\nvmw_write(dev_priv, SVGA_REG_DISPLAY_POSITION_X, crtc->x);\r\nvmw_write(dev_priv, SVGA_REG_DISPLAY_POSITION_Y, crtc->y);\r\nvmw_write(dev_priv, SVGA_REG_DISPLAY_WIDTH, crtc->mode.hdisplay);\r\nvmw_write(dev_priv, SVGA_REG_DISPLAY_HEIGHT, crtc->mode.vdisplay);\r\nvmw_write(dev_priv, SVGA_REG_DISPLAY_ID, SVGA_ID_INVALID);\r\ni++;\r\n}\r\nBUG_ON(i != lds->num_active);\r\nlds->last_num_active = lds->num_active;\r\nlist_for_each_entry(entry, &lds->active, active) {\r\ndu = &entry->base;\r\nif (!du->cursor_dmabuf)\r\ncontinue;\r\nret = vmw_cursor_update_dmabuf(dev_priv,\r\ndu->cursor_dmabuf,\r\n64, 64,\r\ndu->hotspot_x,\r\ndu->hotspot_y);\r\nif (ret == 0)\r\nbreak;\r\nDRM_ERROR("Could not update cursor image\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmw_ldu_del_active(struct vmw_private *vmw_priv,\r\nstruct vmw_legacy_display_unit *ldu)\r\n{\r\nstruct vmw_legacy_display *ld = vmw_priv->ldu_priv;\r\nif (list_empty(&ldu->active))\r\nreturn 0;\r\nlist_del_init(&ldu->active);\r\nif (--(ld->num_active) == 0) {\r\nBUG_ON(!ld->fb);\r\nif (ld->fb->unpin)\r\nld->fb->unpin(ld->fb);\r\nld->fb = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmw_ldu_add_active(struct vmw_private *vmw_priv,\r\nstruct vmw_legacy_display_unit *ldu,\r\nstruct vmw_framebuffer *vfb)\r\n{\r\nstruct vmw_legacy_display *ld = vmw_priv->ldu_priv;\r\nstruct vmw_legacy_display_unit *entry;\r\nstruct list_head *at;\r\nBUG_ON(!ld->num_active && ld->fb);\r\nif (vfb != ld->fb) {\r\nif (ld->fb && ld->fb->unpin)\r\nld->fb->unpin(ld->fb);\r\nif (vfb->pin)\r\nvfb->pin(vfb);\r\nld->fb = vfb;\r\n}\r\nif (!list_empty(&ldu->active))\r\nreturn 0;\r\nat = &ld->active;\r\nlist_for_each_entry(entry, &ld->active, active) {\r\nif (entry->base.unit > ldu->base.unit)\r\nbreak;\r\nat = &entry->active;\r\n}\r\nlist_add(&ldu->active, at);\r\nld->num_active++;\r\nreturn 0;\r\n}\r\nstatic int vmw_ldu_crtc_set_config(struct drm_mode_set *set)\r\n{\r\nstruct vmw_private *dev_priv;\r\nstruct vmw_legacy_display_unit *ldu;\r\nstruct drm_connector *connector;\r\nstruct drm_display_mode *mode;\r\nstruct drm_encoder *encoder;\r\nstruct vmw_framebuffer *vfb;\r\nstruct drm_framebuffer *fb;\r\nstruct drm_crtc *crtc;\r\nif (!set)\r\nreturn -EINVAL;\r\nif (!set->crtc)\r\nreturn -EINVAL;\r\ncrtc = set->crtc;\r\nldu = vmw_crtc_to_ldu(crtc);\r\nvfb = set->fb ? vmw_framebuffer_to_vfb(set->fb) : NULL;\r\ndev_priv = vmw_priv(crtc->dev);\r\nif (set->num_connectors > 1) {\r\nDRM_ERROR("to many connectors\n");\r\nreturn -EINVAL;\r\n}\r\nif (set->num_connectors == 1 &&\r\nset->connectors[0] != &ldu->base.connector) {\r\nDRM_ERROR("connector doesn't match %p %p\n",\r\nset->connectors[0], &ldu->base.connector);\r\nreturn -EINVAL;\r\n}\r\nif (dev_priv->ldu_priv->fb && vfb &&\r\n!(dev_priv->ldu_priv->num_active == 1 &&\r\n!list_empty(&ldu->active)) &&\r\ndev_priv->ldu_priv->fb != vfb) {\r\nDRM_ERROR("Multiple framebuffers not supported\n");\r\nreturn -EINVAL;\r\n}\r\nconnector = &ldu->base.connector;\r\nencoder = &ldu->base.encoder;\r\nif (set->num_connectors == 0 || !set->mode || !set->fb) {\r\nconnector->encoder = NULL;\r\nencoder->crtc = NULL;\r\ncrtc->primary->fb = NULL;\r\ncrtc->enabled = false;\r\nvmw_ldu_del_active(dev_priv, ldu);\r\nreturn vmw_ldu_commit_list(dev_priv);\r\n}\r\nmode = set->mode;\r\nfb = set->fb;\r\nif (set->x + mode->hdisplay > fb->width ||\r\nset->y + mode->vdisplay > fb->height) {\r\nDRM_ERROR("set outside of framebuffer\n");\r\nreturn -EINVAL;\r\n}\r\nvmw_fb_off(dev_priv);\r\ncrtc->primary->fb = fb;\r\nencoder->crtc = crtc;\r\nconnector->encoder = encoder;\r\ncrtc->x = set->x;\r\ncrtc->y = set->y;\r\ncrtc->mode = *mode;\r\ncrtc->enabled = true;\r\nvmw_ldu_add_active(dev_priv, ldu, vfb);\r\nreturn vmw_ldu_commit_list(dev_priv);\r\n}\r\nstatic void vmw_ldu_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nvmw_ldu_destroy(vmw_encoder_to_ldu(encoder));\r\n}\r\nstatic void vmw_ldu_connector_destroy(struct drm_connector *connector)\r\n{\r\nvmw_ldu_destroy(vmw_connector_to_ldu(connector));\r\n}\r\nstatic int vmw_ldu_init(struct vmw_private *dev_priv, unsigned unit)\r\n{\r\nstruct vmw_legacy_display_unit *ldu;\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct drm_connector *connector;\r\nstruct drm_encoder *encoder;\r\nstruct drm_crtc *crtc;\r\nldu = kzalloc(sizeof(*ldu), GFP_KERNEL);\r\nif (!ldu)\r\nreturn -ENOMEM;\r\nldu->base.unit = unit;\r\ncrtc = &ldu->base.crtc;\r\nencoder = &ldu->base.encoder;\r\nconnector = &ldu->base.connector;\r\nINIT_LIST_HEAD(&ldu->active);\r\nldu->base.pref_active = (unit == 0);\r\nldu->base.pref_width = dev_priv->initial_width;\r\nldu->base.pref_height = dev_priv->initial_height;\r\nldu->base.pref_mode = NULL;\r\nldu->base.is_implicit = true;\r\ndrm_connector_init(dev, connector, &vmw_legacy_connector_funcs,\r\nDRM_MODE_CONNECTOR_VIRTUAL);\r\nconnector->status = vmw_du_connector_detect(connector, true);\r\ndrm_encoder_init(dev, encoder, &vmw_legacy_encoder_funcs,\r\nDRM_MODE_ENCODER_VIRTUAL);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nencoder->possible_crtcs = (1 << unit);\r\nencoder->possible_clones = 0;\r\n(void) drm_connector_register(connector);\r\ndrm_crtc_init(dev, crtc, &vmw_legacy_crtc_funcs);\r\ndrm_mode_crtc_set_gamma_size(crtc, 256);\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.dirty_info_property,\r\n1);\r\nreturn 0;\r\n}\r\nint vmw_kms_init_legacy_display_system(struct vmw_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nint i, ret;\r\nif (dev_priv->ldu_priv) {\r\nDRM_INFO("ldu system already on\n");\r\nreturn -EINVAL;\r\n}\r\ndev_priv->ldu_priv = kmalloc(sizeof(*dev_priv->ldu_priv), GFP_KERNEL);\r\nif (!dev_priv->ldu_priv)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&dev_priv->ldu_priv->active);\r\ndev_priv->ldu_priv->num_active = 0;\r\ndev_priv->ldu_priv->last_num_active = 0;\r\ndev_priv->ldu_priv->fb = NULL;\r\nif (dev_priv->capabilities & SVGA_CAP_MULTIMON)\r\nret = drm_vblank_init(dev, VMWGFX_NUM_DISPLAY_UNITS);\r\nelse\r\nret = drm_vblank_init(dev, 1);\r\nif (ret != 0)\r\ngoto err_free;\r\nret = drm_mode_create_dirty_info_property(dev);\r\nif (ret != 0)\r\ngoto err_vblank_cleanup;\r\nif (dev_priv->capabilities & SVGA_CAP_MULTIMON)\r\nfor (i = 0; i < VMWGFX_NUM_DISPLAY_UNITS; ++i)\r\nvmw_ldu_init(dev_priv, i);\r\nelse\r\nvmw_ldu_init(dev_priv, 0);\r\nreturn 0;\r\nerr_vblank_cleanup:\r\ndrm_vblank_cleanup(dev);\r\nerr_free:\r\nkfree(dev_priv->ldu_priv);\r\ndev_priv->ldu_priv = NULL;\r\nreturn ret;\r\n}\r\nint vmw_kms_close_legacy_display_system(struct vmw_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nif (!dev_priv->ldu_priv)\r\nreturn -ENOSYS;\r\ndrm_vblank_cleanup(dev);\r\nBUG_ON(!list_empty(&dev_priv->ldu_priv->active));\r\nkfree(dev_priv->ldu_priv);\r\nreturn 0;\r\n}
