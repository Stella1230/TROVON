int exynos_platform_device_ipp_register(void)\r\n{\r\nstruct platform_device *pdev;\r\nif (exynos_drm_ipp_pdev)\r\nreturn -EEXIST;\r\npdev = platform_device_register_simple("exynos-drm-ipp", -1, NULL, 0);\r\nif (IS_ERR(pdev))\r\nreturn PTR_ERR(pdev);\r\nexynos_drm_ipp_pdev = pdev;\r\nreturn 0;\r\n}\r\nvoid exynos_platform_device_ipp_unregister(void)\r\n{\r\nif (exynos_drm_ipp_pdev) {\r\nplatform_device_unregister(exynos_drm_ipp_pdev);\r\nexynos_drm_ipp_pdev = NULL;\r\n}\r\n}\r\nint exynos_drm_ippdrv_register(struct exynos_drm_ippdrv *ippdrv)\r\n{\r\nmutex_lock(&exynos_drm_ippdrv_lock);\r\nlist_add_tail(&ippdrv->drv_list, &exynos_drm_ippdrv_list);\r\nmutex_unlock(&exynos_drm_ippdrv_lock);\r\nreturn 0;\r\n}\r\nint exynos_drm_ippdrv_unregister(struct exynos_drm_ippdrv *ippdrv)\r\n{\r\nmutex_lock(&exynos_drm_ippdrv_lock);\r\nlist_del(&ippdrv->drv_list);\r\nmutex_unlock(&exynos_drm_ippdrv_lock);\r\nreturn 0;\r\n}\r\nstatic int ipp_create_id(struct idr *id_idr, struct mutex *lock, void *obj)\r\n{\r\nint ret;\r\nmutex_lock(lock);\r\nret = idr_alloc(id_idr, obj, 1, 0, GFP_KERNEL);\r\nmutex_unlock(lock);\r\nreturn ret;\r\n}\r\nstatic void ipp_remove_id(struct idr *id_idr, struct mutex *lock, u32 id)\r\n{\r\nmutex_lock(lock);\r\nidr_remove(id_idr, id);\r\nmutex_unlock(lock);\r\n}\r\nstatic void *ipp_find_obj(struct idr *id_idr, struct mutex *lock, u32 id)\r\n{\r\nvoid *obj;\r\nmutex_lock(lock);\r\nobj = idr_find(id_idr, id);\r\nmutex_unlock(lock);\r\nreturn obj;\r\n}\r\nstatic int ipp_check_driver(struct exynos_drm_ippdrv *ippdrv,\r\nstruct drm_exynos_ipp_property *property)\r\n{\r\nif (ippdrv->dedicated || (!ipp_is_m2m_cmd(property->cmd) &&\r\n!pm_runtime_suspended(ippdrv->dev)))\r\nreturn -EBUSY;\r\nif (ippdrv->check_property &&\r\nippdrv->check_property(ippdrv->dev, property))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic struct exynos_drm_ippdrv *ipp_find_driver(struct ipp_context *ctx,\r\nstruct drm_exynos_ipp_property *property)\r\n{\r\nstruct exynos_drm_ippdrv *ippdrv;\r\nu32 ipp_id = property->ipp_id;\r\nint ret;\r\nif (ipp_id) {\r\nippdrv = ipp_find_obj(&ctx->ipp_idr, &ctx->ipp_lock, ipp_id);\r\nif (!ippdrv) {\r\nDRM_DEBUG("ipp%d driver not found\n", ipp_id);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nret = ipp_check_driver(ippdrv, property);\r\nif (ret < 0) {\r\nDRM_DEBUG("ipp%d driver check error %d\n", ipp_id, ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn ippdrv;\r\n} else {\r\nlist_for_each_entry(ippdrv, &exynos_drm_ippdrv_list, drv_list) {\r\nret = ipp_check_driver(ippdrv, property);\r\nif (ret == 0)\r\nreturn ippdrv;\r\n}\r\nDRM_DEBUG("cannot find driver suitable for given property.\n");\r\n}\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic struct exynos_drm_ippdrv *ipp_find_drv_by_handle(u32 prop_id)\r\n{\r\nstruct exynos_drm_ippdrv *ippdrv;\r\nstruct drm_exynos_ipp_cmd_node *c_node;\r\nint count = 0;\r\nDRM_DEBUG_KMS("prop_id[%d]\n", prop_id);\r\nlist_for_each_entry(ippdrv, &exynos_drm_ippdrv_list, drv_list) {\r\nDRM_DEBUG_KMS("count[%d]ippdrv[0x%x]\n", count++, (int)ippdrv);\r\nmutex_lock(&ippdrv->cmd_lock);\r\nlist_for_each_entry(c_node, &ippdrv->cmd_list, list) {\r\nif (c_node->property.prop_id == prop_id) {\r\nmutex_unlock(&ippdrv->cmd_lock);\r\nreturn ippdrv;\r\n}\r\n}\r\nmutex_unlock(&ippdrv->cmd_lock);\r\n}\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nint exynos_drm_ipp_get_property(struct drm_device *drm_dev, void *data,\r\nstruct drm_file *file)\r\n{\r\nstruct drm_exynos_file_private *file_priv = file->driver_priv;\r\nstruct device *dev = file_priv->ipp_dev;\r\nstruct ipp_context *ctx = get_ipp_context(dev);\r\nstruct drm_exynos_ipp_prop_list *prop_list = data;\r\nstruct exynos_drm_ippdrv *ippdrv;\r\nint count = 0;\r\nif (!ctx) {\r\nDRM_ERROR("invalid context.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!prop_list) {\r\nDRM_ERROR("invalid property parameter.\n");\r\nreturn -EINVAL;\r\n}\r\nDRM_DEBUG_KMS("ipp_id[%d]\n", prop_list->ipp_id);\r\nif (!prop_list->ipp_id) {\r\nlist_for_each_entry(ippdrv, &exynos_drm_ippdrv_list, drv_list)\r\ncount++;\r\nprop_list->count = count;\r\n} else {\r\nippdrv = ipp_find_obj(&ctx->ipp_idr, &ctx->ipp_lock,\r\nprop_list->ipp_id);\r\nif (!ippdrv) {\r\nDRM_ERROR("not found ipp%d driver.\n",\r\nprop_list->ipp_id);\r\nreturn -ENODEV;\r\n}\r\n*prop_list = ippdrv->prop_list;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ipp_print_property(struct drm_exynos_ipp_property *property,\r\nint idx)\r\n{\r\nstruct drm_exynos_ipp_config *config = &property->config[idx];\r\nstruct drm_exynos_pos *pos = &config->pos;\r\nstruct drm_exynos_sz *sz = &config->sz;\r\nDRM_DEBUG_KMS("prop_id[%d]ops[%s]fmt[0x%x]\n",\r\nproperty->prop_id, idx ? "dst" : "src", config->fmt);\r\nDRM_DEBUG_KMS("pos[%d %d %d %d]sz[%d %d]f[%d]r[%d]\n",\r\npos->x, pos->y, pos->w, pos->h,\r\nsz->hsize, sz->vsize, config->flip, config->degree);\r\n}\r\nstatic struct drm_exynos_ipp_cmd_work *ipp_create_cmd_work(void)\r\n{\r\nstruct drm_exynos_ipp_cmd_work *cmd_work;\r\ncmd_work = kzalloc(sizeof(*cmd_work), GFP_KERNEL);\r\nif (!cmd_work)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_WORK((struct work_struct *)cmd_work, ipp_sched_cmd);\r\nreturn cmd_work;\r\n}\r\nstatic struct drm_exynos_ipp_event_work *ipp_create_event_work(void)\r\n{\r\nstruct drm_exynos_ipp_event_work *event_work;\r\nevent_work = kzalloc(sizeof(*event_work), GFP_KERNEL);\r\nif (!event_work)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_WORK(&event_work->work, ipp_sched_event);\r\nreturn event_work;\r\n}\r\nint exynos_drm_ipp_set_property(struct drm_device *drm_dev, void *data,\r\nstruct drm_file *file)\r\n{\r\nstruct drm_exynos_file_private *file_priv = file->driver_priv;\r\nstruct device *dev = file_priv->ipp_dev;\r\nstruct ipp_context *ctx = get_ipp_context(dev);\r\nstruct drm_exynos_ipp_property *property = data;\r\nstruct exynos_drm_ippdrv *ippdrv;\r\nstruct drm_exynos_ipp_cmd_node *c_node;\r\nu32 prop_id;\r\nint ret, i;\r\nif (!ctx) {\r\nDRM_ERROR("invalid context.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!property) {\r\nDRM_ERROR("invalid property parameter.\n");\r\nreturn -EINVAL;\r\n}\r\nprop_id = property->prop_id;\r\nfor_each_ipp_ops(i)\r\nipp_print_property(property, i);\r\nif (prop_id) {\r\nc_node = ipp_find_obj(&ctx->prop_idr, &ctx->prop_lock, prop_id);\r\nif (!c_node || c_node->filp != file) {\r\nDRM_DEBUG_KMS("prop_id[%d] not found\n", prop_id);\r\nreturn -EINVAL;\r\n}\r\nif (c_node->state != IPP_STATE_STOP) {\r\nDRM_DEBUG_KMS("prop_id[%d] not stopped\n", prop_id);\r\nreturn -EINVAL;\r\n}\r\nc_node->property = *property;\r\nreturn 0;\r\n}\r\nippdrv = ipp_find_driver(ctx, property);\r\nif (IS_ERR(ippdrv)) {\r\nDRM_ERROR("failed to get ipp driver.\n");\r\nreturn -EINVAL;\r\n}\r\nc_node = kzalloc(sizeof(*c_node), GFP_KERNEL);\r\nif (!c_node)\r\nreturn -ENOMEM;\r\nret = ipp_create_id(&ctx->prop_idr, &ctx->prop_lock, c_node);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to create id.\n");\r\ngoto err_clear;\r\n}\r\nproperty->prop_id = ret;\r\nDRM_DEBUG_KMS("created prop_id[%d]cmd[%d]ippdrv[0x%x]\n",\r\nproperty->prop_id, property->cmd, (int)ippdrv);\r\nc_node->property = *property;\r\nc_node->state = IPP_STATE_IDLE;\r\nc_node->filp = file;\r\nc_node->start_work = ipp_create_cmd_work();\r\nif (IS_ERR(c_node->start_work)) {\r\nDRM_ERROR("failed to create start work.\n");\r\nret = PTR_ERR(c_node->start_work);\r\ngoto err_remove_id;\r\n}\r\nc_node->stop_work = ipp_create_cmd_work();\r\nif (IS_ERR(c_node->stop_work)) {\r\nDRM_ERROR("failed to create stop work.\n");\r\nret = PTR_ERR(c_node->stop_work);\r\ngoto err_free_start;\r\n}\r\nc_node->event_work = ipp_create_event_work();\r\nif (IS_ERR(c_node->event_work)) {\r\nDRM_ERROR("failed to create event work.\n");\r\nret = PTR_ERR(c_node->event_work);\r\ngoto err_free_stop;\r\n}\r\nmutex_init(&c_node->lock);\r\nmutex_init(&c_node->mem_lock);\r\nmutex_init(&c_node->event_lock);\r\ninit_completion(&c_node->start_complete);\r\ninit_completion(&c_node->stop_complete);\r\nfor_each_ipp_ops(i)\r\nINIT_LIST_HEAD(&c_node->mem_list[i]);\r\nINIT_LIST_HEAD(&c_node->event_list);\r\nmutex_lock(&ippdrv->cmd_lock);\r\nlist_add_tail(&c_node->list, &ippdrv->cmd_list);\r\nmutex_unlock(&ippdrv->cmd_lock);\r\nif (!ipp_is_m2m_cmd(property->cmd))\r\nippdrv->dedicated = true;\r\nreturn 0;\r\nerr_free_stop:\r\nkfree(c_node->stop_work);\r\nerr_free_start:\r\nkfree(c_node->start_work);\r\nerr_remove_id:\r\nipp_remove_id(&ctx->prop_idr, &ctx->prop_lock, property->prop_id);\r\nerr_clear:\r\nkfree(c_node);\r\nreturn ret;\r\n}\r\nstatic int ipp_put_mem_node(struct drm_device *drm_dev,\r\nstruct drm_exynos_ipp_cmd_node *c_node,\r\nstruct drm_exynos_ipp_mem_node *m_node)\r\n{\r\nint i;\r\nDRM_DEBUG_KMS("node[0x%x]\n", (int)m_node);\r\nif (!m_node) {\r\nDRM_ERROR("invalid dequeue node.\n");\r\nreturn -EFAULT;\r\n}\r\nDRM_DEBUG_KMS("ops_id[%d]\n", m_node->ops_id);\r\nfor_each_ipp_planar(i) {\r\nunsigned long handle = m_node->buf_info.handles[i];\r\nif (handle)\r\nexynos_drm_gem_put_dma_addr(drm_dev, handle,\r\nc_node->filp);\r\n}\r\nlist_del(&m_node->list);\r\nkfree(m_node);\r\nreturn 0;\r\n}\r\nstatic struct drm_exynos_ipp_mem_node\r\n*ipp_get_mem_node(struct drm_device *drm_dev,\r\nstruct drm_exynos_ipp_cmd_node *c_node,\r\nstruct drm_exynos_ipp_queue_buf *qbuf)\r\n{\r\nstruct drm_exynos_ipp_mem_node *m_node;\r\nstruct drm_exynos_ipp_buf_info *buf_info;\r\nint i;\r\nm_node = kzalloc(sizeof(*m_node), GFP_KERNEL);\r\nif (!m_node)\r\nreturn ERR_PTR(-ENOMEM);\r\nbuf_info = &m_node->buf_info;\r\nm_node->ops_id = qbuf->ops_id;\r\nm_node->prop_id = qbuf->prop_id;\r\nm_node->buf_id = qbuf->buf_id;\r\nINIT_LIST_HEAD(&m_node->list);\r\nDRM_DEBUG_KMS("m_node[0x%x]ops_id[%d]\n", (int)m_node, qbuf->ops_id);\r\nDRM_DEBUG_KMS("prop_id[%d]buf_id[%d]\n", qbuf->prop_id, m_node->buf_id);\r\nfor_each_ipp_planar(i) {\r\nDRM_DEBUG_KMS("i[%d]handle[0x%x]\n", i, qbuf->handle[i]);\r\nif (qbuf->handle[i]) {\r\ndma_addr_t *addr;\r\naddr = exynos_drm_gem_get_dma_addr(drm_dev,\r\nqbuf->handle[i], c_node->filp);\r\nif (IS_ERR(addr)) {\r\nDRM_ERROR("failed to get addr.\n");\r\nipp_put_mem_node(drm_dev, c_node, m_node);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\nbuf_info->handles[i] = qbuf->handle[i];\r\nbuf_info->base[i] = *addr;\r\nDRM_DEBUG_KMS("i[%d]base[0x%x]hd[0x%lx]\n", i,\r\nbuf_info->base[i], buf_info->handles[i]);\r\n}\r\n}\r\nmutex_lock(&c_node->mem_lock);\r\nlist_add_tail(&m_node->list, &c_node->mem_list[qbuf->ops_id]);\r\nmutex_unlock(&c_node->mem_lock);\r\nreturn m_node;\r\n}\r\nstatic void ipp_clean_mem_nodes(struct drm_device *drm_dev,\r\nstruct drm_exynos_ipp_cmd_node *c_node, int ops)\r\n{\r\nstruct drm_exynos_ipp_mem_node *m_node, *tm_node;\r\nstruct list_head *head = &c_node->mem_list[ops];\r\nmutex_lock(&c_node->mem_lock);\r\nlist_for_each_entry_safe(m_node, tm_node, head, list) {\r\nint ret;\r\nret = ipp_put_mem_node(drm_dev, c_node, m_node);\r\nif (ret)\r\nDRM_ERROR("failed to put m_node.\n");\r\n}\r\nmutex_unlock(&c_node->mem_lock);\r\n}\r\nstatic void ipp_free_event(struct drm_pending_event *event)\r\n{\r\nkfree(event);\r\n}\r\nstatic int ipp_get_event(struct drm_device *drm_dev,\r\nstruct drm_exynos_ipp_cmd_node *c_node,\r\nstruct drm_exynos_ipp_queue_buf *qbuf)\r\n{\r\nstruct drm_exynos_ipp_send_event *e;\r\nunsigned long flags;\r\nDRM_DEBUG_KMS("ops_id[%d]buf_id[%d]\n", qbuf->ops_id, qbuf->buf_id);\r\ne = kzalloc(sizeof(*e), GFP_KERNEL);\r\nif (!e) {\r\nspin_lock_irqsave(&drm_dev->event_lock, flags);\r\nc_node->filp->event_space += sizeof(e->event);\r\nspin_unlock_irqrestore(&drm_dev->event_lock, flags);\r\nreturn -ENOMEM;\r\n}\r\ne->event.base.type = DRM_EXYNOS_IPP_EVENT;\r\ne->event.base.length = sizeof(e->event);\r\ne->event.user_data = qbuf->user_data;\r\ne->event.prop_id = qbuf->prop_id;\r\ne->event.buf_id[EXYNOS_DRM_OPS_DST] = qbuf->buf_id;\r\ne->base.event = &e->event.base;\r\ne->base.file_priv = c_node->filp;\r\ne->base.destroy = ipp_free_event;\r\nmutex_lock(&c_node->event_lock);\r\nlist_add_tail(&e->base.link, &c_node->event_list);\r\nmutex_unlock(&c_node->event_lock);\r\nreturn 0;\r\n}\r\nstatic void ipp_put_event(struct drm_exynos_ipp_cmd_node *c_node,\r\nstruct drm_exynos_ipp_queue_buf *qbuf)\r\n{\r\nstruct drm_exynos_ipp_send_event *e, *te;\r\nint count = 0;\r\nmutex_lock(&c_node->event_lock);\r\nlist_for_each_entry_safe(e, te, &c_node->event_list, base.link) {\r\nDRM_DEBUG_KMS("count[%d]e[0x%x]\n", count++, (int)e);\r\nif (!qbuf) {\r\nlist_del(&e->base.link);\r\nkfree(e);\r\n}\r\nif (qbuf && (qbuf->buf_id ==\r\ne->event.buf_id[EXYNOS_DRM_OPS_DST])) {\r\nlist_del(&e->base.link);\r\nkfree(e);\r\ngoto out_unlock;\r\n}\r\n}\r\nout_unlock:\r\nmutex_unlock(&c_node->event_lock);\r\nreturn;\r\n}\r\nstatic void ipp_clean_cmd_node(struct ipp_context *ctx,\r\nstruct drm_exynos_ipp_cmd_node *c_node)\r\n{\r\nint i;\r\ncancel_work_sync(&c_node->start_work->work);\r\ncancel_work_sync(&c_node->stop_work->work);\r\ncancel_work_sync(&c_node->event_work->work);\r\nipp_put_event(c_node, NULL);\r\nfor_each_ipp_ops(i)\r\nipp_clean_mem_nodes(ctx->subdrv.drm_dev, c_node, i);\r\nlist_del(&c_node->list);\r\nipp_remove_id(&ctx->prop_idr, &ctx->prop_lock,\r\nc_node->property.prop_id);\r\nmutex_destroy(&c_node->lock);\r\nmutex_destroy(&c_node->mem_lock);\r\nmutex_destroy(&c_node->event_lock);\r\nkfree(c_node->start_work);\r\nkfree(c_node->stop_work);\r\nkfree(c_node->event_work);\r\nkfree(c_node);\r\n}\r\nstatic bool ipp_check_mem_list(struct drm_exynos_ipp_cmd_node *c_node)\r\n{\r\nswitch (c_node->property.cmd) {\r\ncase IPP_CMD_WB:\r\nreturn !list_empty(&c_node->mem_list[EXYNOS_DRM_OPS_DST]);\r\ncase IPP_CMD_OUTPUT:\r\nreturn !list_empty(&c_node->mem_list[EXYNOS_DRM_OPS_SRC]);\r\ncase IPP_CMD_M2M:\r\ndefault:\r\nreturn !list_empty(&c_node->mem_list[EXYNOS_DRM_OPS_SRC]) &&\r\n!list_empty(&c_node->mem_list[EXYNOS_DRM_OPS_DST]);\r\n}\r\n}\r\nstatic struct drm_exynos_ipp_mem_node\r\n*ipp_find_mem_node(struct drm_exynos_ipp_cmd_node *c_node,\r\nstruct drm_exynos_ipp_queue_buf *qbuf)\r\n{\r\nstruct drm_exynos_ipp_mem_node *m_node;\r\nstruct list_head *head;\r\nint count = 0;\r\nDRM_DEBUG_KMS("buf_id[%d]\n", qbuf->buf_id);\r\nhead = &c_node->mem_list[qbuf->ops_id];\r\nlist_for_each_entry(m_node, head, list) {\r\nDRM_DEBUG_KMS("count[%d]m_node[0x%x]\n", count++, (int)m_node);\r\nif (m_node->buf_id == qbuf->buf_id)\r\nreturn m_node;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int ipp_set_mem_node(struct exynos_drm_ippdrv *ippdrv,\r\nstruct drm_exynos_ipp_cmd_node *c_node,\r\nstruct drm_exynos_ipp_mem_node *m_node)\r\n{\r\nstruct exynos_drm_ipp_ops *ops = NULL;\r\nint ret = 0;\r\nDRM_DEBUG_KMS("node[0x%x]\n", (int)m_node);\r\nif (!m_node) {\r\nDRM_ERROR("invalid queue node.\n");\r\nreturn -EFAULT;\r\n}\r\nDRM_DEBUG_KMS("ops_id[%d]\n", m_node->ops_id);\r\nops = ippdrv->ops[m_node->ops_id];\r\nif (!ops) {\r\nDRM_ERROR("not support ops.\n");\r\nreturn -EFAULT;\r\n}\r\nif (ops->set_addr) {\r\nret = ops->set_addr(ippdrv->dev, &m_node->buf_info,\r\nm_node->buf_id, IPP_BUF_ENQUEUE);\r\nif (ret) {\r\nDRM_ERROR("failed to set addr.\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void ipp_handle_cmd_work(struct device *dev,\r\nstruct exynos_drm_ippdrv *ippdrv,\r\nstruct drm_exynos_ipp_cmd_work *cmd_work,\r\nstruct drm_exynos_ipp_cmd_node *c_node)\r\n{\r\nstruct ipp_context *ctx = get_ipp_context(dev);\r\ncmd_work->ippdrv = ippdrv;\r\ncmd_work->c_node = c_node;\r\nqueue_work(ctx->cmd_workq, &cmd_work->work);\r\n}\r\nstatic int ipp_queue_buf_with_run(struct device *dev,\r\nstruct drm_exynos_ipp_cmd_node *c_node,\r\nstruct drm_exynos_ipp_mem_node *m_node,\r\nstruct drm_exynos_ipp_queue_buf *qbuf)\r\n{\r\nstruct exynos_drm_ippdrv *ippdrv;\r\nstruct drm_exynos_ipp_property *property;\r\nstruct exynos_drm_ipp_ops *ops;\r\nint ret;\r\nippdrv = ipp_find_drv_by_handle(qbuf->prop_id);\r\nif (IS_ERR(ippdrv)) {\r\nDRM_ERROR("failed to get ipp driver.\n");\r\nreturn -EFAULT;\r\n}\r\nops = ippdrv->ops[qbuf->ops_id];\r\nif (!ops) {\r\nDRM_ERROR("failed to get ops.\n");\r\nreturn -EFAULT;\r\n}\r\nproperty = &c_node->property;\r\nif (c_node->state != IPP_STATE_START) {\r\nDRM_DEBUG_KMS("bypass for invalid state.\n");\r\nreturn 0;\r\n}\r\nmutex_lock(&c_node->mem_lock);\r\nif (!ipp_check_mem_list(c_node)) {\r\nmutex_unlock(&c_node->mem_lock);\r\nDRM_DEBUG_KMS("empty memory.\n");\r\nreturn 0;\r\n}\r\nif (ipp_is_m2m_cmd(property->cmd)) {\r\nstruct drm_exynos_ipp_cmd_work *cmd_work = c_node->start_work;\r\ncmd_work->ctrl = IPP_CTRL_PLAY;\r\nipp_handle_cmd_work(dev, ippdrv, cmd_work, c_node);\r\n} else {\r\nret = ipp_set_mem_node(ippdrv, c_node, m_node);\r\nif (ret) {\r\nmutex_unlock(&c_node->mem_lock);\r\nDRM_ERROR("failed to set m node.\n");\r\nreturn ret;\r\n}\r\n}\r\nmutex_unlock(&c_node->mem_lock);\r\nreturn 0;\r\n}\r\nstatic void ipp_clean_queue_buf(struct drm_device *drm_dev,\r\nstruct drm_exynos_ipp_cmd_node *c_node,\r\nstruct drm_exynos_ipp_queue_buf *qbuf)\r\n{\r\nstruct drm_exynos_ipp_mem_node *m_node, *tm_node;\r\nmutex_lock(&c_node->mem_lock);\r\nlist_for_each_entry_safe(m_node, tm_node,\r\n&c_node->mem_list[qbuf->ops_id], list) {\r\nif (m_node->buf_id == qbuf->buf_id &&\r\nm_node->ops_id == qbuf->ops_id)\r\nipp_put_mem_node(drm_dev, c_node, m_node);\r\n}\r\nmutex_unlock(&c_node->mem_lock);\r\n}\r\nint exynos_drm_ipp_queue_buf(struct drm_device *drm_dev, void *data,\r\nstruct drm_file *file)\r\n{\r\nstruct drm_exynos_file_private *file_priv = file->driver_priv;\r\nstruct device *dev = file_priv->ipp_dev;\r\nstruct ipp_context *ctx = get_ipp_context(dev);\r\nstruct drm_exynos_ipp_queue_buf *qbuf = data;\r\nstruct drm_exynos_ipp_cmd_node *c_node;\r\nstruct drm_exynos_ipp_mem_node *m_node;\r\nint ret;\r\nif (!qbuf) {\r\nDRM_ERROR("invalid buf parameter.\n");\r\nreturn -EINVAL;\r\n}\r\nif (qbuf->ops_id >= EXYNOS_DRM_OPS_MAX) {\r\nDRM_ERROR("invalid ops parameter.\n");\r\nreturn -EINVAL;\r\n}\r\nDRM_DEBUG_KMS("prop_id[%d]ops_id[%s]buf_id[%d]buf_type[%d]\n",\r\nqbuf->prop_id, qbuf->ops_id ? "dst" : "src",\r\nqbuf->buf_id, qbuf->buf_type);\r\nc_node = ipp_find_obj(&ctx->prop_idr, &ctx->prop_lock,\r\nqbuf->prop_id);\r\nif (!c_node || c_node->filp != file) {\r\nDRM_ERROR("failed to get command node.\n");\r\nreturn -ENODEV;\r\n}\r\nswitch (qbuf->buf_type) {\r\ncase IPP_BUF_ENQUEUE:\r\nm_node = ipp_get_mem_node(drm_dev, c_node, qbuf);\r\nif (IS_ERR(m_node)) {\r\nDRM_ERROR("failed to get m_node.\n");\r\nreturn PTR_ERR(m_node);\r\n}\r\nif (qbuf->ops_id == EXYNOS_DRM_OPS_DST) {\r\nret = ipp_get_event(drm_dev, c_node, qbuf);\r\nif (ret) {\r\nDRM_ERROR("failed to get event.\n");\r\ngoto err_clean_node;\r\n}\r\nret = ipp_queue_buf_with_run(dev, c_node, m_node, qbuf);\r\nif (ret) {\r\nDRM_ERROR("failed to run command.\n");\r\ngoto err_clean_node;\r\n}\r\n}\r\nbreak;\r\ncase IPP_BUF_DEQUEUE:\r\nmutex_lock(&c_node->lock);\r\nif (qbuf->ops_id == EXYNOS_DRM_OPS_DST)\r\nipp_put_event(c_node, qbuf);\r\nipp_clean_queue_buf(drm_dev, c_node, qbuf);\r\nmutex_unlock(&c_node->lock);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("invalid buffer control.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\nerr_clean_node:\r\nDRM_ERROR("clean memory nodes.\n");\r\nipp_clean_queue_buf(drm_dev, c_node, qbuf);\r\nreturn ret;\r\n}\r\nstatic bool exynos_drm_ipp_check_valid(struct device *dev,\r\nenum drm_exynos_ipp_ctrl ctrl, enum drm_exynos_ipp_state state)\r\n{\r\nif (ctrl != IPP_CTRL_PLAY) {\r\nif (pm_runtime_suspended(dev)) {\r\nDRM_ERROR("pm:runtime_suspended.\n");\r\ngoto err_status;\r\n}\r\n}\r\nswitch (ctrl) {\r\ncase IPP_CTRL_PLAY:\r\nif (state != IPP_STATE_IDLE)\r\ngoto err_status;\r\nbreak;\r\ncase IPP_CTRL_STOP:\r\nif (state == IPP_STATE_STOP)\r\ngoto err_status;\r\nbreak;\r\ncase IPP_CTRL_PAUSE:\r\nif (state != IPP_STATE_START)\r\ngoto err_status;\r\nbreak;\r\ncase IPP_CTRL_RESUME:\r\nif (state != IPP_STATE_STOP)\r\ngoto err_status;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("invalid state.\n");\r\ngoto err_status;\r\n}\r\nreturn true;\r\nerr_status:\r\nDRM_ERROR("invalid status:ctrl[%d]state[%d]\n", ctrl, state);\r\nreturn false;\r\n}\r\nint exynos_drm_ipp_cmd_ctrl(struct drm_device *drm_dev, void *data,\r\nstruct drm_file *file)\r\n{\r\nstruct drm_exynos_file_private *file_priv = file->driver_priv;\r\nstruct exynos_drm_ippdrv *ippdrv = NULL;\r\nstruct device *dev = file_priv->ipp_dev;\r\nstruct ipp_context *ctx = get_ipp_context(dev);\r\nstruct drm_exynos_ipp_cmd_ctrl *cmd_ctrl = data;\r\nstruct drm_exynos_ipp_cmd_work *cmd_work;\r\nstruct drm_exynos_ipp_cmd_node *c_node;\r\nif (!ctx) {\r\nDRM_ERROR("invalid context.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!cmd_ctrl) {\r\nDRM_ERROR("invalid control parameter.\n");\r\nreturn -EINVAL;\r\n}\r\nDRM_DEBUG_KMS("ctrl[%d]prop_id[%d]\n",\r\ncmd_ctrl->ctrl, cmd_ctrl->prop_id);\r\nippdrv = ipp_find_drv_by_handle(cmd_ctrl->prop_id);\r\nif (IS_ERR(ippdrv)) {\r\nDRM_ERROR("failed to get ipp driver.\n");\r\nreturn PTR_ERR(ippdrv);\r\n}\r\nc_node = ipp_find_obj(&ctx->prop_idr, &ctx->prop_lock,\r\ncmd_ctrl->prop_id);\r\nif (!c_node || c_node->filp != file) {\r\nDRM_ERROR("invalid command node list.\n");\r\nreturn -ENODEV;\r\n}\r\nif (!exynos_drm_ipp_check_valid(ippdrv->dev, cmd_ctrl->ctrl,\r\nc_node->state)) {\r\nDRM_ERROR("invalid state.\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (cmd_ctrl->ctrl) {\r\ncase IPP_CTRL_PLAY:\r\nif (pm_runtime_suspended(ippdrv->dev))\r\npm_runtime_get_sync(ippdrv->dev);\r\nc_node->state = IPP_STATE_START;\r\ncmd_work = c_node->start_work;\r\ncmd_work->ctrl = cmd_ctrl->ctrl;\r\nipp_handle_cmd_work(dev, ippdrv, cmd_work, c_node);\r\nbreak;\r\ncase IPP_CTRL_STOP:\r\ncmd_work = c_node->stop_work;\r\ncmd_work->ctrl = cmd_ctrl->ctrl;\r\nipp_handle_cmd_work(dev, ippdrv, cmd_work, c_node);\r\nif (!wait_for_completion_timeout(&c_node->stop_complete,\r\nmsecs_to_jiffies(300))) {\r\nDRM_ERROR("timeout stop:prop_id[%d]\n",\r\nc_node->property.prop_id);\r\n}\r\nc_node->state = IPP_STATE_STOP;\r\nippdrv->dedicated = false;\r\nmutex_lock(&ippdrv->cmd_lock);\r\nipp_clean_cmd_node(ctx, c_node);\r\nif (list_empty(&ippdrv->cmd_list))\r\npm_runtime_put_sync(ippdrv->dev);\r\nmutex_unlock(&ippdrv->cmd_lock);\r\nbreak;\r\ncase IPP_CTRL_PAUSE:\r\ncmd_work = c_node->stop_work;\r\ncmd_work->ctrl = cmd_ctrl->ctrl;\r\nipp_handle_cmd_work(dev, ippdrv, cmd_work, c_node);\r\nif (!wait_for_completion_timeout(&c_node->stop_complete,\r\nmsecs_to_jiffies(200))) {\r\nDRM_ERROR("timeout stop:prop_id[%d]\n",\r\nc_node->property.prop_id);\r\n}\r\nc_node->state = IPP_STATE_STOP;\r\nbreak;\r\ncase IPP_CTRL_RESUME:\r\nc_node->state = IPP_STATE_START;\r\ncmd_work = c_node->start_work;\r\ncmd_work->ctrl = cmd_ctrl->ctrl;\r\nipp_handle_cmd_work(dev, ippdrv, cmd_work, c_node);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("could not support this state currently.\n");\r\nreturn -EINVAL;\r\n}\r\nDRM_DEBUG_KMS("done ctrl[%d]prop_id[%d]\n",\r\ncmd_ctrl->ctrl, cmd_ctrl->prop_id);\r\nreturn 0;\r\n}\r\nint exynos_drm_ippnb_register(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_register(\r\n&exynos_drm_ippnb_list, nb);\r\n}\r\nint exynos_drm_ippnb_unregister(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_unregister(\r\n&exynos_drm_ippnb_list, nb);\r\n}\r\nint exynos_drm_ippnb_send_event(unsigned long val, void *v)\r\n{\r\nreturn blocking_notifier_call_chain(\r\n&exynos_drm_ippnb_list, val, v);\r\n}\r\nstatic int ipp_set_property(struct exynos_drm_ippdrv *ippdrv,\r\nstruct drm_exynos_ipp_property *property)\r\n{\r\nstruct exynos_drm_ipp_ops *ops = NULL;\r\nbool swap = false;\r\nint ret, i;\r\nif (!property) {\r\nDRM_ERROR("invalid property parameter.\n");\r\nreturn -EINVAL;\r\n}\r\nDRM_DEBUG_KMS("prop_id[%d]\n", property->prop_id);\r\nif (ippdrv->reset &&\r\nippdrv->reset(ippdrv->dev)) {\r\nreturn -EINVAL;\r\n}\r\nfor_each_ipp_ops(i) {\r\nstruct drm_exynos_ipp_config *config =\r\n&property->config[i];\r\nops = ippdrv->ops[i];\r\nif (!ops || !config) {\r\nDRM_ERROR("not support ops and config.\n");\r\nreturn -EINVAL;\r\n}\r\nif (ops->set_fmt) {\r\nret = ops->set_fmt(ippdrv->dev, config->fmt);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (ops->set_transf) {\r\nret = ops->set_transf(ippdrv->dev, config->degree,\r\nconfig->flip, &swap);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (ops->set_size) {\r\nret = ops->set_size(ippdrv->dev, swap, &config->pos,\r\n&config->sz);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ipp_start_property(struct exynos_drm_ippdrv *ippdrv,\r\nstruct drm_exynos_ipp_cmd_node *c_node)\r\n{\r\nstruct drm_exynos_ipp_mem_node *m_node;\r\nstruct drm_exynos_ipp_property *property = &c_node->property;\r\nstruct list_head *head;\r\nint ret, i;\r\nDRM_DEBUG_KMS("prop_id[%d]\n", property->prop_id);\r\nippdrv->c_node = c_node;\r\nmutex_lock(&c_node->mem_lock);\r\nif (!ipp_check_mem_list(c_node)) {\r\nDRM_DEBUG_KMS("empty memory.\n");\r\nret = -ENOMEM;\r\ngoto err_unlock;\r\n}\r\nret = ipp_set_property(ippdrv, property);\r\nif (ret) {\r\nDRM_ERROR("failed to set property.\n");\r\nippdrv->c_node = NULL;\r\ngoto err_unlock;\r\n}\r\nswitch (property->cmd) {\r\ncase IPP_CMD_M2M:\r\nfor_each_ipp_ops(i) {\r\nhead = &c_node->mem_list[i];\r\nm_node = list_first_entry(head,\r\nstruct drm_exynos_ipp_mem_node, list);\r\nDRM_DEBUG_KMS("m_node[0x%x]\n", (int)m_node);\r\nret = ipp_set_mem_node(ippdrv, c_node, m_node);\r\nif (ret) {\r\nDRM_ERROR("failed to set m node.\n");\r\ngoto err_unlock;\r\n}\r\n}\r\nbreak;\r\ncase IPP_CMD_WB:\r\nhead = &c_node->mem_list[EXYNOS_DRM_OPS_DST];\r\nlist_for_each_entry(m_node, head, list) {\r\nret = ipp_set_mem_node(ippdrv, c_node, m_node);\r\nif (ret) {\r\nDRM_ERROR("failed to set m node.\n");\r\ngoto err_unlock;\r\n}\r\n}\r\nbreak;\r\ncase IPP_CMD_OUTPUT:\r\nhead = &c_node->mem_list[EXYNOS_DRM_OPS_SRC];\r\nlist_for_each_entry(m_node, head, list) {\r\nret = ipp_set_mem_node(ippdrv, c_node, m_node);\r\nif (ret) {\r\nDRM_ERROR("failed to set m node.\n");\r\ngoto err_unlock;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nDRM_ERROR("invalid operations.\n");\r\nret = -EINVAL;\r\ngoto err_unlock;\r\n}\r\nmutex_unlock(&c_node->mem_lock);\r\nDRM_DEBUG_KMS("cmd[%d]\n", property->cmd);\r\nif (ippdrv->start) {\r\nret = ippdrv->start(ippdrv->dev, property->cmd);\r\nif (ret) {\r\nDRM_ERROR("failed to start ops.\n");\r\nippdrv->c_node = NULL;\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\nerr_unlock:\r\nmutex_unlock(&c_node->mem_lock);\r\nippdrv->c_node = NULL;\r\nreturn ret;\r\n}\r\nstatic int ipp_stop_property(struct drm_device *drm_dev,\r\nstruct exynos_drm_ippdrv *ippdrv,\r\nstruct drm_exynos_ipp_cmd_node *c_node)\r\n{\r\nstruct drm_exynos_ipp_property *property = &c_node->property;\r\nint i;\r\nDRM_DEBUG_KMS("prop_id[%d]\n", property->prop_id);\r\nif (ippdrv->stop)\r\nippdrv->stop(ippdrv->dev, property->cmd);\r\nswitch (property->cmd) {\r\ncase IPP_CMD_M2M:\r\nfor_each_ipp_ops(i)\r\nipp_clean_mem_nodes(drm_dev, c_node, i);\r\nbreak;\r\ncase IPP_CMD_WB:\r\nipp_clean_mem_nodes(drm_dev, c_node, EXYNOS_DRM_OPS_DST);\r\nbreak;\r\ncase IPP_CMD_OUTPUT:\r\nipp_clean_mem_nodes(drm_dev, c_node, EXYNOS_DRM_OPS_SRC);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("invalid operations.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid ipp_sched_cmd(struct work_struct *work)\r\n{\r\nstruct drm_exynos_ipp_cmd_work *cmd_work =\r\ncontainer_of(work, struct drm_exynos_ipp_cmd_work, work);\r\nstruct exynos_drm_ippdrv *ippdrv;\r\nstruct drm_exynos_ipp_cmd_node *c_node;\r\nstruct drm_exynos_ipp_property *property;\r\nint ret;\r\nippdrv = cmd_work->ippdrv;\r\nif (!ippdrv) {\r\nDRM_ERROR("invalid ippdrv list.\n");\r\nreturn;\r\n}\r\nc_node = cmd_work->c_node;\r\nif (!c_node) {\r\nDRM_ERROR("invalid command node list.\n");\r\nreturn;\r\n}\r\nmutex_lock(&c_node->lock);\r\nproperty = &c_node->property;\r\nswitch (cmd_work->ctrl) {\r\ncase IPP_CTRL_PLAY:\r\ncase IPP_CTRL_RESUME:\r\nret = ipp_start_property(ippdrv, c_node);\r\nif (ret) {\r\nDRM_ERROR("failed to start property:prop_id[%d]\n",\r\nc_node->property.prop_id);\r\ngoto err_unlock;\r\n}\r\nif (ipp_is_m2m_cmd(property->cmd)) {\r\nif (!wait_for_completion_timeout\r\n(&c_node->start_complete, msecs_to_jiffies(200))) {\r\nDRM_ERROR("timeout event:prop_id[%d]\n",\r\nc_node->property.prop_id);\r\ngoto err_unlock;\r\n}\r\n}\r\nbreak;\r\ncase IPP_CTRL_STOP:\r\ncase IPP_CTRL_PAUSE:\r\nret = ipp_stop_property(ippdrv->drm_dev, ippdrv,\r\nc_node);\r\nif (ret) {\r\nDRM_ERROR("failed to stop property.\n");\r\ngoto err_unlock;\r\n}\r\ncomplete(&c_node->stop_complete);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unknown control type\n");\r\nbreak;\r\n}\r\nDRM_DEBUG_KMS("ctrl[%d] done.\n", cmd_work->ctrl);\r\nerr_unlock:\r\nmutex_unlock(&c_node->lock);\r\n}\r\nstatic int ipp_send_event(struct exynos_drm_ippdrv *ippdrv,\r\nstruct drm_exynos_ipp_cmd_node *c_node, int *buf_id)\r\n{\r\nstruct drm_device *drm_dev = ippdrv->drm_dev;\r\nstruct drm_exynos_ipp_property *property = &c_node->property;\r\nstruct drm_exynos_ipp_mem_node *m_node;\r\nstruct drm_exynos_ipp_queue_buf qbuf;\r\nstruct drm_exynos_ipp_send_event *e;\r\nstruct list_head *head;\r\nstruct timeval now;\r\nunsigned long flags;\r\nu32 tbuf_id[EXYNOS_DRM_OPS_MAX] = {0, };\r\nint ret, i;\r\nfor_each_ipp_ops(i)\r\nDRM_DEBUG_KMS("%s buf_id[%d]\n", i ? "dst" : "src", buf_id[i]);\r\nif (!drm_dev) {\r\nDRM_ERROR("failed to get drm_dev.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!property) {\r\nDRM_ERROR("failed to get property.\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&c_node->event_lock);\r\nif (list_empty(&c_node->event_list)) {\r\nDRM_DEBUG_KMS("event list is empty.\n");\r\nret = 0;\r\ngoto err_event_unlock;\r\n}\r\nmutex_lock(&c_node->mem_lock);\r\nif (!ipp_check_mem_list(c_node)) {\r\nDRM_DEBUG_KMS("empty memory.\n");\r\nret = 0;\r\ngoto err_mem_unlock;\r\n}\r\nswitch (property->cmd) {\r\ncase IPP_CMD_M2M:\r\nfor_each_ipp_ops(i) {\r\nhead = &c_node->mem_list[i];\r\nm_node = list_first_entry(head,\r\nstruct drm_exynos_ipp_mem_node, list);\r\ntbuf_id[i] = m_node->buf_id;\r\nDRM_DEBUG_KMS("%s buf_id[%d]\n",\r\ni ? "dst" : "src", tbuf_id[i]);\r\nret = ipp_put_mem_node(drm_dev, c_node, m_node);\r\nif (ret)\r\nDRM_ERROR("failed to put m_node.\n");\r\n}\r\nbreak;\r\ncase IPP_CMD_WB:\r\nmemset(&qbuf, 0x0, sizeof(qbuf));\r\nqbuf.ops_id = EXYNOS_DRM_OPS_DST;\r\nqbuf.buf_id = buf_id[EXYNOS_DRM_OPS_DST];\r\nm_node = ipp_find_mem_node(c_node, &qbuf);\r\nif (!m_node) {\r\nDRM_ERROR("empty memory node.\n");\r\nret = -ENOMEM;\r\ngoto err_mem_unlock;\r\n}\r\ntbuf_id[EXYNOS_DRM_OPS_DST] = m_node->buf_id;\r\nret = ipp_put_mem_node(drm_dev, c_node, m_node);\r\nif (ret)\r\nDRM_ERROR("failed to put m_node.\n");\r\nbreak;\r\ncase IPP_CMD_OUTPUT:\r\nhead = &c_node->mem_list[EXYNOS_DRM_OPS_SRC];\r\nm_node = list_first_entry(head,\r\nstruct drm_exynos_ipp_mem_node, list);\r\ntbuf_id[EXYNOS_DRM_OPS_SRC] = m_node->buf_id;\r\nret = ipp_put_mem_node(drm_dev, c_node, m_node);\r\nif (ret)\r\nDRM_ERROR("failed to put m_node.\n");\r\nbreak;\r\ndefault:\r\nDRM_ERROR("invalid operations.\n");\r\nret = -EINVAL;\r\ngoto err_mem_unlock;\r\n}\r\nmutex_unlock(&c_node->mem_lock);\r\nif (tbuf_id[EXYNOS_DRM_OPS_DST] != buf_id[EXYNOS_DRM_OPS_DST])\r\nDRM_ERROR("failed to match buf_id[%d %d]prop_id[%d]\n",\r\ntbuf_id[1], buf_id[1], property->prop_id);\r\ne = list_first_entry(&c_node->event_list,\r\nstruct drm_exynos_ipp_send_event, base.link);\r\ndo_gettimeofday(&now);\r\nDRM_DEBUG_KMS("tv_sec[%ld]tv_usec[%ld]\n", now.tv_sec, now.tv_usec);\r\ne->event.tv_sec = now.tv_sec;\r\ne->event.tv_usec = now.tv_usec;\r\ne->event.prop_id = property->prop_id;\r\nfor_each_ipp_ops(i)\r\ne->event.buf_id[i] = tbuf_id[i];\r\nspin_lock_irqsave(&drm_dev->event_lock, flags);\r\nlist_move_tail(&e->base.link, &e->base.file_priv->event_list);\r\nwake_up_interruptible(&e->base.file_priv->event_wait);\r\nspin_unlock_irqrestore(&drm_dev->event_lock, flags);\r\nmutex_unlock(&c_node->event_lock);\r\nDRM_DEBUG_KMS("done cmd[%d]prop_id[%d]buf_id[%d]\n",\r\nproperty->cmd, property->prop_id, tbuf_id[EXYNOS_DRM_OPS_DST]);\r\nreturn 0;\r\nerr_mem_unlock:\r\nmutex_unlock(&c_node->mem_lock);\r\nerr_event_unlock:\r\nmutex_unlock(&c_node->event_lock);\r\nreturn ret;\r\n}\r\nvoid ipp_sched_event(struct work_struct *work)\r\n{\r\nstruct drm_exynos_ipp_event_work *event_work =\r\ncontainer_of(work, struct drm_exynos_ipp_event_work, work);\r\nstruct exynos_drm_ippdrv *ippdrv;\r\nstruct drm_exynos_ipp_cmd_node *c_node;\r\nint ret;\r\nif (!event_work) {\r\nDRM_ERROR("failed to get event_work.\n");\r\nreturn;\r\n}\r\nDRM_DEBUG_KMS("buf_id[%d]\n", event_work->buf_id[EXYNOS_DRM_OPS_DST]);\r\nippdrv = event_work->ippdrv;\r\nif (!ippdrv) {\r\nDRM_ERROR("failed to get ipp driver.\n");\r\nreturn;\r\n}\r\nc_node = ippdrv->c_node;\r\nif (!c_node) {\r\nDRM_ERROR("failed to get command node.\n");\r\nreturn;\r\n}\r\nif (c_node->state != IPP_STATE_START) {\r\nDRM_DEBUG_KMS("bypass state[%d]prop_id[%d]\n",\r\nc_node->state, c_node->property.prop_id);\r\ngoto err_completion;\r\n}\r\nret = ipp_send_event(ippdrv, c_node, event_work->buf_id);\r\nif (ret) {\r\nDRM_ERROR("failed to send event.\n");\r\ngoto err_completion;\r\n}\r\nerr_completion:\r\nif (ipp_is_m2m_cmd(c_node->property.cmd))\r\ncomplete(&c_node->start_complete);\r\n}\r\nstatic int ipp_subdrv_probe(struct drm_device *drm_dev, struct device *dev)\r\n{\r\nstruct ipp_context *ctx = get_ipp_context(dev);\r\nstruct exynos_drm_ippdrv *ippdrv;\r\nint ret, count = 0;\r\nlist_for_each_entry(ippdrv, &exynos_drm_ippdrv_list, drv_list) {\r\nippdrv->drm_dev = drm_dev;\r\nret = ipp_create_id(&ctx->ipp_idr, &ctx->ipp_lock, ippdrv);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to create id.\n");\r\ngoto err;\r\n}\r\nippdrv->prop_list.ipp_id = ret;\r\nDRM_DEBUG_KMS("count[%d]ippdrv[0x%x]ipp_id[%d]\n",\r\ncount++, (int)ippdrv, ret);\r\nippdrv->parent_dev = dev;\r\nippdrv->event_workq = ctx->event_workq;\r\nippdrv->sched_event = ipp_sched_event;\r\nINIT_LIST_HEAD(&ippdrv->cmd_list);\r\nmutex_init(&ippdrv->cmd_lock);\r\nif (is_drm_iommu_supported(drm_dev)) {\r\nret = drm_iommu_attach_device(drm_dev, ippdrv->dev);\r\nif (ret) {\r\nDRM_ERROR("failed to activate iommu\n");\r\ngoto err;\r\n}\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nlist_for_each_entry_continue_reverse(ippdrv, &exynos_drm_ippdrv_list,\r\ndrv_list) {\r\nif (is_drm_iommu_supported(drm_dev))\r\ndrm_iommu_detach_device(drm_dev, ippdrv->dev);\r\nipp_remove_id(&ctx->ipp_idr, &ctx->ipp_lock,\r\nippdrv->prop_list.ipp_id);\r\n}\r\nreturn ret;\r\n}\r\nstatic void ipp_subdrv_remove(struct drm_device *drm_dev, struct device *dev)\r\n{\r\nstruct exynos_drm_ippdrv *ippdrv, *t;\r\nstruct ipp_context *ctx = get_ipp_context(dev);\r\nlist_for_each_entry_safe(ippdrv, t, &exynos_drm_ippdrv_list, drv_list) {\r\nif (is_drm_iommu_supported(drm_dev))\r\ndrm_iommu_detach_device(drm_dev, ippdrv->dev);\r\nipp_remove_id(&ctx->ipp_idr, &ctx->ipp_lock,\r\nippdrv->prop_list.ipp_id);\r\nippdrv->drm_dev = NULL;\r\nexynos_drm_ippdrv_unregister(ippdrv);\r\n}\r\n}\r\nstatic int ipp_subdrv_open(struct drm_device *drm_dev, struct device *dev,\r\nstruct drm_file *file)\r\n{\r\nstruct drm_exynos_file_private *file_priv = file->driver_priv;\r\nfile_priv->ipp_dev = dev;\r\nDRM_DEBUG_KMS("done priv[0x%x]\n", (int)dev);\r\nreturn 0;\r\n}\r\nstatic void ipp_subdrv_close(struct drm_device *drm_dev, struct device *dev,\r\nstruct drm_file *file)\r\n{\r\nstruct exynos_drm_ippdrv *ippdrv = NULL;\r\nstruct ipp_context *ctx = get_ipp_context(dev);\r\nstruct drm_exynos_ipp_cmd_node *c_node, *tc_node;\r\nint count = 0;\r\nlist_for_each_entry(ippdrv, &exynos_drm_ippdrv_list, drv_list) {\r\nmutex_lock(&ippdrv->cmd_lock);\r\nlist_for_each_entry_safe(c_node, tc_node,\r\n&ippdrv->cmd_list, list) {\r\nDRM_DEBUG_KMS("count[%d]ippdrv[0x%x]\n",\r\ncount++, (int)ippdrv);\r\nif (c_node->filp == file) {\r\nif (c_node->state == IPP_STATE_START) {\r\nipp_stop_property(drm_dev, ippdrv,\r\nc_node);\r\nc_node->state = IPP_STATE_STOP;\r\n}\r\nippdrv->dedicated = false;\r\nipp_clean_cmd_node(ctx, c_node);\r\nif (list_empty(&ippdrv->cmd_list))\r\npm_runtime_put_sync(ippdrv->dev);\r\n}\r\n}\r\nmutex_unlock(&ippdrv->cmd_lock);\r\n}\r\nreturn;\r\n}\r\nstatic int ipp_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ipp_context *ctx;\r\nstruct exynos_drm_subdrv *subdrv;\r\nint ret;\r\nctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nmutex_init(&ctx->ipp_lock);\r\nmutex_init(&ctx->prop_lock);\r\nidr_init(&ctx->ipp_idr);\r\nidr_init(&ctx->prop_idr);\r\nctx->event_workq = create_singlethread_workqueue("ipp_event");\r\nif (!ctx->event_workq) {\r\ndev_err(dev, "failed to create event workqueue\n");\r\nreturn -EINVAL;\r\n}\r\nctx->cmd_workq = create_singlethread_workqueue("ipp_cmd");\r\nif (!ctx->cmd_workq) {\r\ndev_err(dev, "failed to create cmd workqueue\n");\r\nret = -EINVAL;\r\ngoto err_event_workq;\r\n}\r\nsubdrv = &ctx->subdrv;\r\nsubdrv->dev = dev;\r\nsubdrv->probe = ipp_subdrv_probe;\r\nsubdrv->remove = ipp_subdrv_remove;\r\nsubdrv->open = ipp_subdrv_open;\r\nsubdrv->close = ipp_subdrv_close;\r\nplatform_set_drvdata(pdev, ctx);\r\nret = exynos_drm_subdrv_register(subdrv);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to register drm ipp device.\n");\r\ngoto err_cmd_workq;\r\n}\r\ndev_info(dev, "drm ipp registered successfully.\n");\r\nreturn 0;\r\nerr_cmd_workq:\r\ndestroy_workqueue(ctx->cmd_workq);\r\nerr_event_workq:\r\ndestroy_workqueue(ctx->event_workq);\r\nreturn ret;\r\n}\r\nstatic int ipp_remove(struct platform_device *pdev)\r\n{\r\nstruct ipp_context *ctx = platform_get_drvdata(pdev);\r\nexynos_drm_subdrv_unregister(&ctx->subdrv);\r\nidr_destroy(&ctx->ipp_idr);\r\nidr_destroy(&ctx->prop_idr);\r\nmutex_destroy(&ctx->ipp_lock);\r\nmutex_destroy(&ctx->prop_lock);\r\ndestroy_workqueue(ctx->cmd_workq);\r\ndestroy_workqueue(ctx->event_workq);\r\nreturn 0;\r\n}
