PRINTF void fatal(const char *fmt, ...)\r\n{\r\nva_list arglist;\r\nfprintf(stderr, "FATAL: ");\r\nva_start(arglist, fmt);\r\nvfprintf(stderr, fmt, arglist);\r\nva_end(arglist);\r\nexit(1);\r\n}\r\nPRINTF void warn(const char *fmt, ...)\r\n{\r\nva_list arglist;\r\nfprintf(stderr, "WARNING: ");\r\nva_start(arglist, fmt);\r\nvfprintf(stderr, fmt, arglist);\r\nva_end(arglist);\r\n}\r\nPRINTF void merror(const char *fmt, ...)\r\n{\r\nva_list arglist;\r\nfprintf(stderr, "ERROR: ");\r\nva_start(arglist, fmt);\r\nvfprintf(stderr, fmt, arglist);\r\nva_end(arglist);\r\n}\r\nstatic inline bool strends(const char *str, const char *postfix)\r\n{\r\nif (strlen(str) < strlen(postfix))\r\nreturn false;\r\nreturn strcmp(str + strlen(str) - strlen(postfix), postfix) == 0;\r\n}\r\nstatic int is_vmlinux(const char *modname)\r\n{\r\nconst char *myname;\r\nmyname = strrchr(modname, '/');\r\nif (myname)\r\nmyname++;\r\nelse\r\nmyname = modname;\r\nreturn (strcmp(myname, "vmlinux") == 0) ||\r\n(strcmp(myname, "vmlinux.o") == 0);\r\n}\r\nvoid *do_nofail(void *ptr, const char *expr)\r\n{\r\nif (!ptr)\r\nfatal("modpost: Memory allocation failure: %s.\n", expr);\r\nreturn ptr;\r\n}\r\nstatic struct module *find_module(char *modname)\r\n{\r\nstruct module *mod;\r\nfor (mod = modules; mod; mod = mod->next)\r\nif (strcmp(mod->name, modname) == 0)\r\nbreak;\r\nreturn mod;\r\n}\r\nstatic struct module *new_module(const char *modname)\r\n{\r\nstruct module *mod;\r\nchar *p;\r\nmod = NOFAIL(malloc(sizeof(*mod)));\r\nmemset(mod, 0, sizeof(*mod));\r\np = NOFAIL(strdup(modname));\r\nif (strends(p, ".o")) {\r\np[strlen(p) - 2] = '\0';\r\nmod->is_dot_o = 1;\r\n}\r\nmod->name = p;\r\nmod->gpl_compatible = -1;\r\nmod->next = modules;\r\nmodules = mod;\r\nreturn mod;\r\n}\r\nstatic inline unsigned int tdb_hash(const char *name)\r\n{\r\nunsigned value;\r\nunsigned i;\r\nfor (value = 0x238F13AF * strlen(name), i = 0; name[i]; i++)\r\nvalue = (value + (((unsigned char *)name)[i] << (i*5 % 24)));\r\nreturn (1103515243 * value + 12345);\r\n}\r\nstatic struct symbol *alloc_symbol(const char *name, unsigned int weak,\r\nstruct symbol *next)\r\n{\r\nstruct symbol *s = NOFAIL(malloc(sizeof(*s) + strlen(name) + 1));\r\nmemset(s, 0, sizeof(*s));\r\nstrcpy(s->name, name);\r\ns->weak = weak;\r\ns->next = next;\r\nreturn s;\r\n}\r\nstatic struct symbol *new_symbol(const char *name, struct module *module,\r\nenum export export)\r\n{\r\nunsigned int hash;\r\nstruct symbol *new;\r\nhash = tdb_hash(name) % SYMBOL_HASH_SIZE;\r\nnew = symbolhash[hash] = alloc_symbol(name, 0, symbolhash[hash]);\r\nnew->module = module;\r\nnew->export = export;\r\nreturn new;\r\n}\r\nstatic struct symbol *find_symbol(const char *name)\r\n{\r\nstruct symbol *s;\r\nif (name[0] == '.')\r\nname++;\r\nfor (s = symbolhash[tdb_hash(name) % SYMBOL_HASH_SIZE]; s; s = s->next) {\r\nif (strcmp(s->name, name) == 0)\r\nreturn s;\r\n}\r\nreturn NULL;\r\n}\r\nstatic const char *export_str(enum export ex)\r\n{\r\nreturn export_list[ex].str;\r\n}\r\nstatic enum export export_no(const char *s)\r\n{\r\nint i;\r\nif (!s)\r\nreturn export_unknown;\r\nfor (i = 0; export_list[i].export != export_unknown; i++) {\r\nif (strcmp(export_list[i].str, s) == 0)\r\nreturn export_list[i].export;\r\n}\r\nreturn export_unknown;\r\n}\r\nstatic enum export export_from_secname(struct elf_info *elf, unsigned int sec)\r\n{\r\nconst char *secname = sec_name(elf, sec);\r\nif (strstarts(secname, "___ksymtab+"))\r\nreturn export_plain;\r\nelse if (strstarts(secname, "___ksymtab_unused+"))\r\nreturn export_unused;\r\nelse if (strstarts(secname, "___ksymtab_gpl+"))\r\nreturn export_gpl;\r\nelse if (strstarts(secname, "___ksymtab_unused_gpl+"))\r\nreturn export_unused_gpl;\r\nelse if (strstarts(secname, "___ksymtab_gpl_future+"))\r\nreturn export_gpl_future;\r\nelse\r\nreturn export_unknown;\r\n}\r\nstatic enum export export_from_sec(struct elf_info *elf, unsigned int sec)\r\n{\r\nif (sec == elf->export_sec)\r\nreturn export_plain;\r\nelse if (sec == elf->export_unused_sec)\r\nreturn export_unused;\r\nelse if (sec == elf->export_gpl_sec)\r\nreturn export_gpl;\r\nelse if (sec == elf->export_unused_gpl_sec)\r\nreturn export_unused_gpl;\r\nelse if (sec == elf->export_gpl_future_sec)\r\nreturn export_gpl_future;\r\nelse\r\nreturn export_unknown;\r\n}\r\nstatic struct symbol *sym_add_exported(const char *name, struct module *mod,\r\nenum export export)\r\n{\r\nstruct symbol *s = find_symbol(name);\r\nif (!s) {\r\ns = new_symbol(name, mod, export);\r\n} else {\r\nif (!s->preloaded) {\r\nwarn("%s: '%s' exported twice. Previous export "\r\n"was in %s%s\n", mod->name, name,\r\ns->module->name,\r\nis_vmlinux(s->module->name) ?"":".ko");\r\n} else {\r\ns->module = mod;\r\n}\r\n}\r\ns->preloaded = 0;\r\ns->vmlinux = is_vmlinux(mod->name);\r\ns->kernel = 0;\r\ns->export = export;\r\nreturn s;\r\n}\r\nstatic void sym_update_crc(const char *name, struct module *mod,\r\nunsigned int crc, enum export export)\r\n{\r\nstruct symbol *s = find_symbol(name);\r\nif (!s) {\r\ns = new_symbol(name, mod, export);\r\ns->preloaded = 1;\r\n}\r\ns->crc = crc;\r\ns->crc_valid = 1;\r\n}\r\nvoid *grab_file(const char *filename, unsigned long *size)\r\n{\r\nstruct stat st;\r\nvoid *map = MAP_FAILED;\r\nint fd;\r\nfd = open(filename, O_RDONLY);\r\nif (fd < 0)\r\nreturn NULL;\r\nif (fstat(fd, &st))\r\ngoto failed;\r\n*size = st.st_size;\r\nmap = mmap(NULL, *size, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);\r\nfailed:\r\nclose(fd);\r\nif (map == MAP_FAILED)\r\nreturn NULL;\r\nreturn map;\r\n}\r\nchar *get_next_line(unsigned long *pos, void *file, unsigned long size)\r\n{\r\nstatic char line[4096];\r\nint skip = 1;\r\nsize_t len = 0;\r\nsigned char *p = (signed char *)file + *pos;\r\nchar *s = line;\r\nfor (; *pos < size ; (*pos)++) {\r\nif (skip && isspace(*p)) {\r\np++;\r\ncontinue;\r\n}\r\nskip = 0;\r\nif (*p != '\n' && (*pos < size)) {\r\nlen++;\r\n*s++ = *p++;\r\nif (len > 4095)\r\nbreak;\r\n} else {\r\n*s = '\0';\r\nreturn line;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nvoid release_file(void *file, unsigned long size)\r\n{\r\nmunmap(file, size);\r\n}\r\nstatic int parse_elf(struct elf_info *info, const char *filename)\r\n{\r\nunsigned int i;\r\nElf_Ehdr *hdr;\r\nElf_Shdr *sechdrs;\r\nElf_Sym *sym;\r\nconst char *secstrings;\r\nunsigned int symtab_idx = ~0U, symtab_shndx_idx = ~0U;\r\nhdr = grab_file(filename, &info->size);\r\nif (!hdr) {\r\nif (ignore_missing_files) {\r\nfprintf(stderr, "%s: %s (ignored)\n", filename,\r\nstrerror(errno));\r\nreturn 0;\r\n}\r\nperror(filename);\r\nexit(1);\r\n}\r\ninfo->hdr = hdr;\r\nif (info->size < sizeof(*hdr)) {\r\nreturn 0;\r\n}\r\nif ((hdr->e_ident[EI_MAG0] != ELFMAG0) ||\r\n(hdr->e_ident[EI_MAG1] != ELFMAG1) ||\r\n(hdr->e_ident[EI_MAG2] != ELFMAG2) ||\r\n(hdr->e_ident[EI_MAG3] != ELFMAG3)) {\r\nreturn 0;\r\n}\r\nhdr->e_type = TO_NATIVE(hdr->e_type);\r\nhdr->e_machine = TO_NATIVE(hdr->e_machine);\r\nhdr->e_version = TO_NATIVE(hdr->e_version);\r\nhdr->e_entry = TO_NATIVE(hdr->e_entry);\r\nhdr->e_phoff = TO_NATIVE(hdr->e_phoff);\r\nhdr->e_shoff = TO_NATIVE(hdr->e_shoff);\r\nhdr->e_flags = TO_NATIVE(hdr->e_flags);\r\nhdr->e_ehsize = TO_NATIVE(hdr->e_ehsize);\r\nhdr->e_phentsize = TO_NATIVE(hdr->e_phentsize);\r\nhdr->e_phnum = TO_NATIVE(hdr->e_phnum);\r\nhdr->e_shentsize = TO_NATIVE(hdr->e_shentsize);\r\nhdr->e_shnum = TO_NATIVE(hdr->e_shnum);\r\nhdr->e_shstrndx = TO_NATIVE(hdr->e_shstrndx);\r\nsechdrs = (void *)hdr + hdr->e_shoff;\r\ninfo->sechdrs = sechdrs;\r\nif (hdr->e_shoff > info->size) {\r\nfatal("section header offset=%lu in file '%s' is bigger than "\r\n"filesize=%lu\n", (unsigned long)hdr->e_shoff,\r\nfilename, info->size);\r\nreturn 0;\r\n}\r\nif (hdr->e_shnum == SHN_UNDEF) {\r\ninfo->num_sections = TO_NATIVE(sechdrs[0].sh_size);\r\n}\r\nelse {\r\ninfo->num_sections = hdr->e_shnum;\r\n}\r\nif (hdr->e_shstrndx == SHN_XINDEX) {\r\ninfo->secindex_strings = TO_NATIVE(sechdrs[0].sh_link);\r\n}\r\nelse {\r\ninfo->secindex_strings = hdr->e_shstrndx;\r\n}\r\nfor (i = 0; i < info->num_sections; i++) {\r\nsechdrs[i].sh_name = TO_NATIVE(sechdrs[i].sh_name);\r\nsechdrs[i].sh_type = TO_NATIVE(sechdrs[i].sh_type);\r\nsechdrs[i].sh_flags = TO_NATIVE(sechdrs[i].sh_flags);\r\nsechdrs[i].sh_addr = TO_NATIVE(sechdrs[i].sh_addr);\r\nsechdrs[i].sh_offset = TO_NATIVE(sechdrs[i].sh_offset);\r\nsechdrs[i].sh_size = TO_NATIVE(sechdrs[i].sh_size);\r\nsechdrs[i].sh_link = TO_NATIVE(sechdrs[i].sh_link);\r\nsechdrs[i].sh_info = TO_NATIVE(sechdrs[i].sh_info);\r\nsechdrs[i].sh_addralign = TO_NATIVE(sechdrs[i].sh_addralign);\r\nsechdrs[i].sh_entsize = TO_NATIVE(sechdrs[i].sh_entsize);\r\n}\r\nsecstrings = (void *)hdr + sechdrs[info->secindex_strings].sh_offset;\r\nfor (i = 1; i < info->num_sections; i++) {\r\nconst char *secname;\r\nint nobits = sechdrs[i].sh_type == SHT_NOBITS;\r\nif (!nobits && sechdrs[i].sh_offset > info->size) {\r\nfatal("%s is truncated. sechdrs[i].sh_offset=%lu > "\r\n"sizeof(*hrd)=%zu\n", filename,\r\n(unsigned long)sechdrs[i].sh_offset,\r\nsizeof(*hdr));\r\nreturn 0;\r\n}\r\nsecname = secstrings + sechdrs[i].sh_name;\r\nif (strcmp(secname, ".modinfo") == 0) {\r\nif (nobits)\r\nfatal("%s has NOBITS .modinfo\n", filename);\r\ninfo->modinfo = (void *)hdr + sechdrs[i].sh_offset;\r\ninfo->modinfo_len = sechdrs[i].sh_size;\r\n} else if (strcmp(secname, "__ksymtab") == 0)\r\ninfo->export_sec = i;\r\nelse if (strcmp(secname, "__ksymtab_unused") == 0)\r\ninfo->export_unused_sec = i;\r\nelse if (strcmp(secname, "__ksymtab_gpl") == 0)\r\ninfo->export_gpl_sec = i;\r\nelse if (strcmp(secname, "__ksymtab_unused_gpl") == 0)\r\ninfo->export_unused_gpl_sec = i;\r\nelse if (strcmp(secname, "__ksymtab_gpl_future") == 0)\r\ninfo->export_gpl_future_sec = i;\r\nif (sechdrs[i].sh_type == SHT_SYMTAB) {\r\nunsigned int sh_link_idx;\r\nsymtab_idx = i;\r\ninfo->symtab_start = (void *)hdr +\r\nsechdrs[i].sh_offset;\r\ninfo->symtab_stop = (void *)hdr +\r\nsechdrs[i].sh_offset + sechdrs[i].sh_size;\r\nsh_link_idx = sechdrs[i].sh_link;\r\ninfo->strtab = (void *)hdr +\r\nsechdrs[sh_link_idx].sh_offset;\r\n}\r\nif (sechdrs[i].sh_type == SHT_SYMTAB_SHNDX) {\r\nsymtab_shndx_idx = i;\r\ninfo->symtab_shndx_start = (void *)hdr +\r\nsechdrs[i].sh_offset;\r\ninfo->symtab_shndx_stop = (void *)hdr +\r\nsechdrs[i].sh_offset + sechdrs[i].sh_size;\r\n}\r\n}\r\nif (!info->symtab_start)\r\nfatal("%s has no symtab?\n", filename);\r\nfor (sym = info->symtab_start; sym < info->symtab_stop; sym++) {\r\nsym->st_shndx = TO_NATIVE(sym->st_shndx);\r\nsym->st_name = TO_NATIVE(sym->st_name);\r\nsym->st_value = TO_NATIVE(sym->st_value);\r\nsym->st_size = TO_NATIVE(sym->st_size);\r\n}\r\nif (symtab_shndx_idx != ~0U) {\r\nElf32_Word *p;\r\nif (symtab_idx != sechdrs[symtab_shndx_idx].sh_link)\r\nfatal("%s: SYMTAB_SHNDX has bad sh_link: %u!=%u\n",\r\nfilename, sechdrs[symtab_shndx_idx].sh_link,\r\nsymtab_idx);\r\nfor (p = info->symtab_shndx_start; p < info->symtab_shndx_stop;\r\np++)\r\n*p = TO_NATIVE(*p);\r\n}\r\nreturn 1;\r\n}\r\nstatic void parse_elf_finish(struct elf_info *info)\r\n{\r\nrelease_file(info->hdr, info->size);\r\n}\r\nstatic int ignore_undef_symbol(struct elf_info *info, const char *symname)\r\n{\r\nif (strcmp(symname, VMLINUX_SYMBOL_STR(__this_module)) == 0)\r\nreturn 1;\r\nif (strcmp(symname, "_GLOBAL_OFFSET_TABLE_") == 0)\r\nreturn 1;\r\nif (info->hdr->e_machine == EM_PPC)\r\nif (strncmp(symname, "_restgpr_", sizeof("_restgpr_") - 1) == 0 ||\r\nstrncmp(symname, "_savegpr_", sizeof("_savegpr_") - 1) == 0 ||\r\nstrncmp(symname, "_rest32gpr_", sizeof("_rest32gpr_") - 1) == 0 ||\r\nstrncmp(symname, "_save32gpr_", sizeof("_save32gpr_") - 1) == 0 ||\r\nstrncmp(symname, "_restvr_", sizeof("_restvr_") - 1) == 0 ||\r\nstrncmp(symname, "_savevr_", sizeof("_savevr_") - 1) == 0)\r\nreturn 1;\r\nif (info->hdr->e_machine == EM_PPC64)\r\nif (strncmp(symname, "_restgpr0_", sizeof("_restgpr0_") - 1) == 0 ||\r\nstrncmp(symname, "_savegpr0_", sizeof("_savegpr0_") - 1) == 0 ||\r\nstrncmp(symname, "_restvr_", sizeof("_restvr_") - 1) == 0 ||\r\nstrncmp(symname, "_savevr_", sizeof("_savevr_") - 1) == 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void handle_modversions(struct module *mod, struct elf_info *info,\r\nElf_Sym *sym, const char *symname)\r\n{\r\nunsigned int crc;\r\nenum export export;\r\nif ((!is_vmlinux(mod->name) || mod->is_dot_o) &&\r\nstrncmp(symname, "__ksymtab", 9) == 0)\r\nexport = export_from_secname(info, get_secindex(info, sym));\r\nelse\r\nexport = export_from_sec(info, get_secindex(info, sym));\r\nif (strncmp(symname, CRC_PFX, strlen(CRC_PFX)) == 0) {\r\ncrc = (unsigned int) sym->st_value;\r\nsym_update_crc(symname + strlen(CRC_PFX), mod, crc,\r\nexport);\r\n}\r\nswitch (sym->st_shndx) {\r\ncase SHN_COMMON:\r\nif (!strncmp(symname, "__gnu_lto_", sizeof("__gnu_lto_")-1)) {\r\n} else\r\nwarn("\"%s\" [%s] is COMMON symbol\n", symname, mod->name);\r\nbreak;\r\ncase SHN_UNDEF:\r\nif (ELF_ST_BIND(sym->st_info) != STB_GLOBAL &&\r\nELF_ST_BIND(sym->st_info) != STB_WEAK)\r\nbreak;\r\nif (ignore_undef_symbol(info, symname))\r\nbreak;\r\n#if defined(STT_REGISTER) || defined(STT_SPARC_REGISTER)\r\n#ifndef STT_SPARC_REGISTER\r\n#define STT_SPARC_REGISTER STT_REGISTER\r\n#endif\r\nif (info->hdr->e_machine == EM_SPARC ||\r\ninfo->hdr->e_machine == EM_SPARCV9) {\r\nif (ELF_ST_TYPE(sym->st_info) == STT_SPARC_REGISTER)\r\nbreak;\r\nif (symname[0] == '.') {\r\nchar *munged = strdup(symname);\r\nmunged[0] = '_';\r\nmunged[1] = toupper(munged[1]);\r\nsymname = munged;\r\n}\r\n}\r\n#endif\r\n#ifdef CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX\r\nif (symname[0] != '_')\r\nbreak;\r\nelse\r\nsymname++;\r\n#endif\r\nmod->unres = alloc_symbol(symname,\r\nELF_ST_BIND(sym->st_info) == STB_WEAK,\r\nmod->unres);\r\nbreak;\r\ndefault:\r\nif (strncmp(symname, KSYMTAB_PFX, strlen(KSYMTAB_PFX)) == 0) {\r\nsym_add_exported(symname + strlen(KSYMTAB_PFX), mod,\r\nexport);\r\n}\r\nif (strcmp(symname, VMLINUX_SYMBOL_STR(init_module)) == 0)\r\nmod->has_init = 1;\r\nif (strcmp(symname, VMLINUX_SYMBOL_STR(cleanup_module)) == 0)\r\nmod->has_cleanup = 1;\r\nbreak;\r\n}\r\n}\r\nstatic char *next_string(char *string, unsigned long *secsize)\r\n{\r\nwhile (string[0]) {\r\nstring++;\r\nif ((*secsize)-- <= 1)\r\nreturn NULL;\r\n}\r\nwhile (!string[0]) {\r\nstring++;\r\nif ((*secsize)-- <= 1)\r\nreturn NULL;\r\n}\r\nreturn string;\r\n}\r\nstatic char *get_next_modinfo(void *modinfo, unsigned long modinfo_len,\r\nconst char *tag, char *info)\r\n{\r\nchar *p;\r\nunsigned int taglen = strlen(tag);\r\nunsigned long size = modinfo_len;\r\nif (info) {\r\nsize -= info - (char *)modinfo;\r\nmodinfo = next_string(info, &size);\r\n}\r\nfor (p = modinfo; p; p = next_string(p, &size)) {\r\nif (strncmp(p, tag, taglen) == 0 && p[taglen] == '=')\r\nreturn p + taglen + 1;\r\n}\r\nreturn NULL;\r\n}\r\nstatic char *get_modinfo(void *modinfo, unsigned long modinfo_len,\r\nconst char *tag)\r\n{\r\nreturn get_next_modinfo(modinfo, modinfo_len, tag, NULL);\r\n}\r\nstatic int strrcmp(const char *s, const char *sub)\r\n{\r\nint slen, sublen;\r\nif (!s || !sub)\r\nreturn 1;\r\nslen = strlen(s);\r\nsublen = strlen(sub);\r\nif ((slen == 0) || (sublen == 0))\r\nreturn 1;\r\nif (sublen > slen)\r\nreturn 1;\r\nreturn memcmp(s + slen - sublen, sub, sublen);\r\n}\r\nstatic const char *sym_name(struct elf_info *elf, Elf_Sym *sym)\r\n{\r\nif (sym)\r\nreturn elf->strtab + sym->st_name;\r\nelse\r\nreturn "(unknown)";\r\n}\r\nstatic const char *sec_name(struct elf_info *elf, int secindex)\r\n{\r\nElf_Shdr *sechdrs = elf->sechdrs;\r\nreturn (void *)elf->hdr +\r\nelf->sechdrs[elf->secindex_strings].sh_offset +\r\nsechdrs[secindex].sh_name;\r\n}\r\nstatic const char *sech_name(struct elf_info *elf, Elf_Shdr *sechdr)\r\n{\r\nreturn (void *)elf->hdr +\r\nelf->sechdrs[elf->secindex_strings].sh_offset +\r\nsechdr->sh_name;\r\n}\r\nstatic int match(const char *sym, const char * const pat[])\r\n{\r\nconst char *p;\r\nwhile (*pat) {\r\np = *pat++;\r\nconst char *endp = p + strlen(p) - 1;\r\nif (*p == '*') {\r\nif (strrcmp(sym, p + 1) == 0)\r\nreturn 1;\r\n}\r\nelse if (*endp == '*') {\r\nif (strncmp(sym, p, strlen(p) - 1) == 0)\r\nreturn 1;\r\n}\r\nelse {\r\nif (strcmp(p, sym) == 0)\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void check_section(const char *modname, struct elf_info *elf,\r\nElf_Shdr *sechdr)\r\n{\r\nconst char *sec = sech_name(elf, sechdr);\r\nif (sechdr->sh_type == SHT_PROGBITS &&\r\n!(sechdr->sh_flags & SHF_ALLOC) &&\r\n!match(sec, section_white_list)) {\r\nwarn("%s (%s): unexpected non-allocatable section.\n"\r\n"Did you forget to use \"ax\"/\"aw\" in a .S file?\n"\r\n"Note that for example <linux/init.h> contains\n"\r\n"section definitions for use in .S files.\n\n",\r\nmodname, sec);\r\n}\r\n}\r\nstatic const struct sectioncheck *section_mismatch(\r\nconst char *fromsec, const char *tosec)\r\n{\r\nint i;\r\nint elems = sizeof(sectioncheck) / sizeof(struct sectioncheck);\r\nconst struct sectioncheck *check = &sectioncheck[0];\r\nfor (i = 0; i < elems; i++) {\r\nif (match(fromsec, check->fromsec) &&\r\nmatch(tosec, check->tosec))\r\nreturn check;\r\ncheck++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int secref_whitelist(const struct sectioncheck *mismatch,\r\nconst char *fromsec, const char *fromsym,\r\nconst char *tosec, const char *tosym)\r\n{\r\nif (match(tosec, init_data_sections) &&\r\nmatch(fromsec, data_sections) &&\r\n(strncmp(fromsym, "__param", strlen("__param")) == 0))\r\nreturn 0;\r\nif (strcmp(tosec, ".init.text") == 0 &&\r\nmatch(fromsec, data_sections) &&\r\n(strncmp(fromsym, "__param_ops_", strlen("__param_ops_")) == 0))\r\nreturn 0;\r\nif (match(tosec, init_exit_sections) &&\r\nmatch(fromsec, data_sections) &&\r\nmatch(fromsym, mismatch->symbol_white_list))\r\nreturn 0;\r\nif (match(fromsec, head_sections) &&\r\nmatch(tosec, init_sections))\r\nreturn 0;\r\nif (match(tosym, linker_symbols))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic Elf_Sym *find_elf_symbol(struct elf_info *elf, Elf64_Sword addr,\r\nElf_Sym *relsym)\r\n{\r\nElf_Sym *sym;\r\nElf_Sym *near = NULL;\r\nElf64_Sword distance = 20;\r\nElf64_Sword d;\r\nunsigned int relsym_secindex;\r\nif (relsym->st_name != 0)\r\nreturn relsym;\r\nrelsym_secindex = get_secindex(elf, relsym);\r\nfor (sym = elf->symtab_start; sym < elf->symtab_stop; sym++) {\r\nif (get_secindex(elf, sym) != relsym_secindex)\r\ncontinue;\r\nif (ELF_ST_TYPE(sym->st_info) == STT_SECTION)\r\ncontinue;\r\nif (sym->st_value == addr)\r\nreturn sym;\r\nd = sym->st_value - addr;\r\nif (d < 0)\r\nd = addr - sym->st_value;\r\nif (d < distance) {\r\ndistance = d;\r\nnear = sym;\r\n}\r\n}\r\nif (distance < 20)\r\nreturn near;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic inline int is_arm_mapping_symbol(const char *str)\r\n{\r\nreturn str[0] == '$' && strchr("axtd", str[1])\r\n&& (str[2] == '\0' || str[2] == '.');\r\n}\r\nstatic inline int is_valid_name(struct elf_info *elf, Elf_Sym *sym)\r\n{\r\nconst char *name = elf->strtab + sym->st_name;\r\nif (!name || !strlen(name))\r\nreturn 0;\r\nreturn !is_arm_mapping_symbol(name);\r\n}\r\nstatic Elf_Sym *find_elf_symbol2(struct elf_info *elf, Elf_Addr addr,\r\nconst char *sec)\r\n{\r\nElf_Sym *sym;\r\nElf_Sym *near = NULL;\r\nElf_Addr distance = ~0;\r\nfor (sym = elf->symtab_start; sym < elf->symtab_stop; sym++) {\r\nconst char *symsec;\r\nif (is_shndx_special(sym->st_shndx))\r\ncontinue;\r\nsymsec = sec_name(elf, get_secindex(elf, sym));\r\nif (strcmp(symsec, sec) != 0)\r\ncontinue;\r\nif (!is_valid_name(elf, sym))\r\ncontinue;\r\nif (sym->st_value <= addr) {\r\nif ((addr - sym->st_value) < distance) {\r\ndistance = addr - sym->st_value;\r\nnear = sym;\r\n} else if ((addr - sym->st_value) == distance) {\r\nnear = sym;\r\n}\r\n}\r\n}\r\nreturn near;\r\n}\r\nstatic char *sec2annotation(const char *s)\r\n{\r\nif (match(s, init_exit_sections)) {\r\nchar *p = malloc(20);\r\nchar *r = p;\r\n*p++ = '_';\r\n*p++ = '_';\r\nif (*s == '.')\r\ns++;\r\nwhile (*s && *s != '.')\r\n*p++ = *s++;\r\n*p = '\0';\r\nif (*s == '.')\r\ns++;\r\nif (strstr(s, "rodata") != NULL)\r\nstrcat(p, "const ");\r\nelse if (strstr(s, "data") != NULL)\r\nstrcat(p, "data ");\r\nelse\r\nstrcat(p, " ");\r\nreturn r;\r\n} else {\r\nreturn strdup("");\r\n}\r\n}\r\nstatic int is_function(Elf_Sym *sym)\r\n{\r\nif (sym)\r\nreturn ELF_ST_TYPE(sym->st_info) == STT_FUNC;\r\nelse\r\nreturn -1;\r\n}\r\nstatic void print_section_list(const char * const list[20])\r\n{\r\nconst char *const *s = list;\r\nwhile (*s) {\r\nfprintf(stderr, "%s", *s);\r\ns++;\r\nif (*s)\r\nfprintf(stderr, ", ");\r\n}\r\nfprintf(stderr, "\n");\r\n}\r\nstatic void report_sec_mismatch(const char *modname,\r\nconst struct sectioncheck *mismatch,\r\nconst char *fromsec,\r\nunsigned long long fromaddr,\r\nconst char *fromsym,\r\nint from_is_func,\r\nconst char *tosec, const char *tosym,\r\nint to_is_func)\r\n{\r\nconst char *from, *from_p;\r\nconst char *to, *to_p;\r\nchar *prl_from;\r\nchar *prl_to;\r\nswitch (from_is_func) {\r\ncase 0: from = "variable"; from_p = ""; break;\r\ncase 1: from = "function"; from_p = "()"; break;\r\ndefault: from = "(unknown reference)"; from_p = ""; break;\r\n}\r\nswitch (to_is_func) {\r\ncase 0: to = "variable"; to_p = ""; break;\r\ncase 1: to = "function"; to_p = "()"; break;\r\ndefault: to = "(unknown reference)"; to_p = ""; break;\r\n}\r\nsec_mismatch_count++;\r\nif (!sec_mismatch_verbose)\r\nreturn;\r\nwarn("%s(%s+0x%llx): Section mismatch in reference from the %s %s%s "\r\n"to the %s %s:%s%s\n",\r\nmodname, fromsec, fromaddr, from, fromsym, from_p, to, tosec,\r\ntosym, to_p);\r\nswitch (mismatch->mismatch) {\r\ncase TEXT_TO_ANY_INIT:\r\nprl_from = sec2annotation(fromsec);\r\nprl_to = sec2annotation(tosec);\r\nfprintf(stderr,\r\n"The function %s%s() references\n"\r\n"the %s %s%s%s.\n"\r\n"This is often because %s lacks a %s\n"\r\n"annotation or the annotation of %s is wrong.\n",\r\nprl_from, fromsym,\r\nto, prl_to, tosym, to_p,\r\nfromsym, prl_to, tosym);\r\nfree(prl_from);\r\nfree(prl_to);\r\nbreak;\r\ncase DATA_TO_ANY_INIT: {\r\nprl_to = sec2annotation(tosec);\r\nfprintf(stderr,\r\n"The variable %s references\n"\r\n"the %s %s%s%s\n"\r\n"If the reference is valid then annotate the\n"\r\n"variable with __init* or __refdata (see linux/init.h) "\r\n"or name the variable:\n",\r\nfromsym, to, prl_to, tosym, to_p);\r\nprint_section_list(mismatch->symbol_white_list);\r\nfree(prl_to);\r\nbreak;\r\n}\r\ncase TEXT_TO_ANY_EXIT:\r\nprl_to = sec2annotation(tosec);\r\nfprintf(stderr,\r\n"The function %s() references a %s in an exit section.\n"\r\n"Often the %s %s%s has valid usage outside the exit section\n"\r\n"and the fix is to remove the %sannotation of %s.\n",\r\nfromsym, to, to, tosym, to_p, prl_to, tosym);\r\nfree(prl_to);\r\nbreak;\r\ncase DATA_TO_ANY_EXIT: {\r\nprl_to = sec2annotation(tosec);\r\nfprintf(stderr,\r\n"The variable %s references\n"\r\n"the %s %s%s%s\n"\r\n"If the reference is valid then annotate the\n"\r\n"variable with __exit* (see linux/init.h) or "\r\n"name the variable:\n",\r\nfromsym, to, prl_to, tosym, to_p);\r\nprint_section_list(mismatch->symbol_white_list);\r\nfree(prl_to);\r\nbreak;\r\n}\r\ncase XXXINIT_TO_SOME_INIT:\r\ncase XXXEXIT_TO_SOME_EXIT:\r\nprl_from = sec2annotation(fromsec);\r\nprl_to = sec2annotation(tosec);\r\nfprintf(stderr,\r\n"The %s %s%s%s references\n"\r\n"a %s %s%s%s.\n"\r\n"If %s is only used by %s then\n"\r\n"annotate %s with a matching annotation.\n",\r\nfrom, prl_from, fromsym, from_p,\r\nto, prl_to, tosym, to_p,\r\ntosym, fromsym, tosym);\r\nfree(prl_from);\r\nfree(prl_to);\r\nbreak;\r\ncase ANY_INIT_TO_ANY_EXIT:\r\nprl_from = sec2annotation(fromsec);\r\nprl_to = sec2annotation(tosec);\r\nfprintf(stderr,\r\n"The %s %s%s%s references\n"\r\n"a %s %s%s%s.\n"\r\n"This is often seen when error handling "\r\n"in the init function\n"\r\n"uses functionality in the exit path.\n"\r\n"The fix is often to remove the %sannotation of\n"\r\n"%s%s so it may be used outside an exit section.\n",\r\nfrom, prl_from, fromsym, from_p,\r\nto, prl_to, tosym, to_p,\r\nprl_to, tosym, to_p);\r\nfree(prl_from);\r\nfree(prl_to);\r\nbreak;\r\ncase ANY_EXIT_TO_ANY_INIT:\r\nprl_from = sec2annotation(fromsec);\r\nprl_to = sec2annotation(tosec);\r\nfprintf(stderr,\r\n"The %s %s%s%s references\n"\r\n"a %s %s%s%s.\n"\r\n"This is often seen when error handling "\r\n"in the exit function\n"\r\n"uses functionality in the init path.\n"\r\n"The fix is often to remove the %sannotation of\n"\r\n"%s%s so it may be used outside an init section.\n",\r\nfrom, prl_from, fromsym, from_p,\r\nto, prl_to, tosym, to_p,\r\nprl_to, tosym, to_p);\r\nfree(prl_from);\r\nfree(prl_to);\r\nbreak;\r\ncase EXPORT_TO_INIT_EXIT:\r\nprl_to = sec2annotation(tosec);\r\nfprintf(stderr,\r\n"The symbol %s is exported and annotated %s\n"\r\n"Fix this by removing the %sannotation of %s "\r\n"or drop the export.\n",\r\ntosym, prl_to, prl_to, tosym);\r\nfree(prl_to);\r\nbreak;\r\n}\r\nfprintf(stderr, "\n");\r\n}\r\nstatic void check_section_mismatch(const char *modname, struct elf_info *elf,\r\nElf_Rela *r, Elf_Sym *sym, const char *fromsec)\r\n{\r\nconst char *tosec;\r\nconst struct sectioncheck *mismatch;\r\ntosec = sec_name(elf, get_secindex(elf, sym));\r\nmismatch = section_mismatch(fromsec, tosec);\r\nif (mismatch) {\r\nElf_Sym *to;\r\nElf_Sym *from;\r\nconst char *tosym;\r\nconst char *fromsym;\r\nfrom = find_elf_symbol2(elf, r->r_offset, fromsec);\r\nfromsym = sym_name(elf, from);\r\nto = find_elf_symbol(elf, r->r_addend, sym);\r\ntosym = sym_name(elf, to);\r\nif (!strncmp(fromsym, "reference___initcall",\r\nsizeof("reference___initcall")-1))\r\nreturn;\r\nif (secref_whitelist(mismatch,\r\nfromsec, fromsym, tosec, tosym)) {\r\nreport_sec_mismatch(modname, mismatch,\r\nfromsec, r->r_offset, fromsym,\r\nis_function(from), tosec, tosym,\r\nis_function(to));\r\n}\r\n}\r\n}\r\nstatic unsigned int *reloc_location(struct elf_info *elf,\r\nElf_Shdr *sechdr, Elf_Rela *r)\r\n{\r\nElf_Shdr *sechdrs = elf->sechdrs;\r\nint section = sechdr->sh_info;\r\nreturn (void *)elf->hdr + sechdrs[section].sh_offset +\r\nr->r_offset;\r\n}\r\nstatic int addend_386_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)\r\n{\r\nunsigned int r_typ = ELF_R_TYPE(r->r_info);\r\nunsigned int *location = reloc_location(elf, sechdr, r);\r\nswitch (r_typ) {\r\ncase R_386_32:\r\nr->r_addend = TO_NATIVE(*location);\r\nbreak;\r\ncase R_386_PC32:\r\nr->r_addend = TO_NATIVE(*location) + 4;\r\nif (elf->hdr->e_type == ET_EXEC)\r\nr->r_addend += r->r_offset;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int addend_arm_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)\r\n{\r\nunsigned int r_typ = ELF_R_TYPE(r->r_info);\r\nswitch (r_typ) {\r\ncase R_ARM_ABS32:\r\nr->r_addend = (int)(long)\r\n(elf->symtab_start + ELF_R_SYM(r->r_info));\r\nbreak;\r\ncase R_ARM_PC24:\r\ncase R_ARM_CALL:\r\ncase R_ARM_JUMP24:\r\ncase R_ARM_THM_CALL:\r\ncase R_ARM_THM_JUMP24:\r\ncase R_ARM_THM_JUMP19:\r\nr->r_addend = (int)(long)(elf->hdr +\r\nsechdr->sh_offset +\r\n(r->r_offset - sechdr->sh_addr));\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int addend_mips_rel(struct elf_info *elf, Elf_Shdr *sechdr, Elf_Rela *r)\r\n{\r\nunsigned int r_typ = ELF_R_TYPE(r->r_info);\r\nunsigned int *location = reloc_location(elf, sechdr, r);\r\nunsigned int inst;\r\nif (r_typ == R_MIPS_HI16)\r\nreturn 1;\r\ninst = TO_NATIVE(*location);\r\nswitch (r_typ) {\r\ncase R_MIPS_LO16:\r\nr->r_addend = inst & 0xffff;\r\nbreak;\r\ncase R_MIPS_26:\r\nr->r_addend = (inst & 0x03ffffff) << 2;\r\nbreak;\r\ncase R_MIPS_32:\r\nr->r_addend = inst;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void section_rela(const char *modname, struct elf_info *elf,\r\nElf_Shdr *sechdr)\r\n{\r\nElf_Sym *sym;\r\nElf_Rela *rela;\r\nElf_Rela r;\r\nunsigned int r_sym;\r\nconst char *fromsec;\r\nElf_Rela *start = (void *)elf->hdr + sechdr->sh_offset;\r\nElf_Rela *stop = (void *)start + sechdr->sh_size;\r\nfromsec = sech_name(elf, sechdr);\r\nfromsec += strlen(".rela");\r\nif (match(fromsec, section_white_list))\r\nreturn;\r\nfor (rela = start; rela < stop; rela++) {\r\nr.r_offset = TO_NATIVE(rela->r_offset);\r\n#if KERNEL_ELFCLASS == ELFCLASS64\r\nif (elf->hdr->e_machine == EM_MIPS) {\r\nunsigned int r_typ;\r\nr_sym = ELF64_MIPS_R_SYM(rela->r_info);\r\nr_sym = TO_NATIVE(r_sym);\r\nr_typ = ELF64_MIPS_R_TYPE(rela->r_info);\r\nr.r_info = ELF64_R_INFO(r_sym, r_typ);\r\n} else {\r\nr.r_info = TO_NATIVE(rela->r_info);\r\nr_sym = ELF_R_SYM(r.r_info);\r\n}\r\n#else\r\nr.r_info = TO_NATIVE(rela->r_info);\r\nr_sym = ELF_R_SYM(r.r_info);\r\n#endif\r\nr.r_addend = TO_NATIVE(rela->r_addend);\r\nsym = elf->symtab_start + r_sym;\r\nif (is_shndx_special(sym->st_shndx))\r\ncontinue;\r\ncheck_section_mismatch(modname, elf, &r, sym, fromsec);\r\n}\r\n}\r\nstatic void section_rel(const char *modname, struct elf_info *elf,\r\nElf_Shdr *sechdr)\r\n{\r\nElf_Sym *sym;\r\nElf_Rel *rel;\r\nElf_Rela r;\r\nunsigned int r_sym;\r\nconst char *fromsec;\r\nElf_Rel *start = (void *)elf->hdr + sechdr->sh_offset;\r\nElf_Rel *stop = (void *)start + sechdr->sh_size;\r\nfromsec = sech_name(elf, sechdr);\r\nfromsec += strlen(".rel");\r\nif (match(fromsec, section_white_list))\r\nreturn;\r\nfor (rel = start; rel < stop; rel++) {\r\nr.r_offset = TO_NATIVE(rel->r_offset);\r\n#if KERNEL_ELFCLASS == ELFCLASS64\r\nif (elf->hdr->e_machine == EM_MIPS) {\r\nunsigned int r_typ;\r\nr_sym = ELF64_MIPS_R_SYM(rel->r_info);\r\nr_sym = TO_NATIVE(r_sym);\r\nr_typ = ELF64_MIPS_R_TYPE(rel->r_info);\r\nr.r_info = ELF64_R_INFO(r_sym, r_typ);\r\n} else {\r\nr.r_info = TO_NATIVE(rel->r_info);\r\nr_sym = ELF_R_SYM(r.r_info);\r\n}\r\n#else\r\nr.r_info = TO_NATIVE(rel->r_info);\r\nr_sym = ELF_R_SYM(r.r_info);\r\n#endif\r\nr.r_addend = 0;\r\nswitch (elf->hdr->e_machine) {\r\ncase EM_386:\r\nif (addend_386_rel(elf, sechdr, &r))\r\ncontinue;\r\nbreak;\r\ncase EM_ARM:\r\nif (addend_arm_rel(elf, sechdr, &r))\r\ncontinue;\r\nbreak;\r\ncase EM_MIPS:\r\nif (addend_mips_rel(elf, sechdr, &r))\r\ncontinue;\r\nbreak;\r\n}\r\nsym = elf->symtab_start + r_sym;\r\nif (is_shndx_special(sym->st_shndx))\r\ncontinue;\r\ncheck_section_mismatch(modname, elf, &r, sym, fromsec);\r\n}\r\n}\r\nstatic void check_sec_ref(struct module *mod, const char *modname,\r\nstruct elf_info *elf)\r\n{\r\nint i;\r\nElf_Shdr *sechdrs = elf->sechdrs;\r\nfor (i = 0; i < elf->num_sections; i++) {\r\ncheck_section(modname, elf, &elf->sechdrs[i]);\r\nif (sechdrs[i].sh_type == SHT_RELA)\r\nsection_rela(modname, elf, &elf->sechdrs[i]);\r\nelse if (sechdrs[i].sh_type == SHT_REL)\r\nsection_rel(modname, elf, &elf->sechdrs[i]);\r\n}\r\n}\r\nstatic char *remove_dot(char *s)\r\n{\r\nsize_t n = strcspn(s, ".");\r\nif (n && s[n]) {\r\nsize_t m = strspn(s + n + 1, "0123456789");\r\nif (m && (s[n + m] == '.' || s[n + m] == 0))\r\ns[n] = 0;\r\n}\r\nreturn s;\r\n}\r\nstatic void read_symbols(char *modname)\r\n{\r\nconst char *symname;\r\nchar *version;\r\nchar *license;\r\nstruct module *mod;\r\nstruct elf_info info = { };\r\nElf_Sym *sym;\r\nif (!parse_elf(&info, modname))\r\nreturn;\r\nmod = new_module(modname);\r\nif (is_vmlinux(modname)) {\r\nhave_vmlinux = 1;\r\nmod->skip = 1;\r\n}\r\nlicense = get_modinfo(info.modinfo, info.modinfo_len, "license");\r\nif (info.modinfo && !license && !is_vmlinux(modname))\r\nwarn("modpost: missing MODULE_LICENSE() in %s\n"\r\n"see include/linux/module.h for "\r\n"more information\n", modname);\r\nwhile (license) {\r\nif (license_is_gpl_compatible(license))\r\nmod->gpl_compatible = 1;\r\nelse {\r\nmod->gpl_compatible = 0;\r\nbreak;\r\n}\r\nlicense = get_next_modinfo(info.modinfo, info.modinfo_len,\r\n"license", license);\r\n}\r\nfor (sym = info.symtab_start; sym < info.symtab_stop; sym++) {\r\nsymname = remove_dot(info.strtab + sym->st_name);\r\nhandle_modversions(mod, &info, sym, symname);\r\nhandle_moddevtable(mod, &info, sym, symname);\r\n}\r\nif (!is_vmlinux(modname) ||\r\n(is_vmlinux(modname) && vmlinux_section_warnings))\r\ncheck_sec_ref(mod, modname, &info);\r\nversion = get_modinfo(info.modinfo, info.modinfo_len, "version");\r\nif (version)\r\nmaybe_frob_rcs_version(modname, version, info.modinfo,\r\nversion - (char *)info.hdr);\r\nif (version || (all_versions && !is_vmlinux(modname)))\r\nget_src_version(modname, mod->srcversion,\r\nsizeof(mod->srcversion)-1);\r\nparse_elf_finish(&info);\r\nif (modversions)\r\nmod->unres = alloc_symbol("module_layout", 0, mod->unres);\r\n}\r\nstatic void read_symbols_from_files(const char *filename)\r\n{\r\nFILE *in = stdin;\r\nchar fname[PATH_MAX];\r\nif (strcmp(filename, "-") != 0) {\r\nin = fopen(filename, "r");\r\nif (!in)\r\nfatal("Can't open filenames file %s: %m", filename);\r\n}\r\nwhile (fgets(fname, PATH_MAX, in) != NULL) {\r\nif (strends(fname, "\n"))\r\nfname[strlen(fname)-1] = '\0';\r\nread_symbols(fname);\r\n}\r\nif (in != stdin)\r\nfclose(in);\r\n}\r\nvoid buf_write(struct buffer *buf, const char *s, int len)\r\n{\r\nif (buf->size - buf->pos < len) {\r\nbuf->size += len + SZ;\r\nbuf->p = realloc(buf->p, buf->size);\r\n}\r\nstrncpy(buf->p + buf->pos, s, len);\r\nbuf->pos += len;\r\n}\r\nstatic void check_for_gpl_usage(enum export exp, const char *m, const char *s)\r\n{\r\nconst char *e = is_vmlinux(m) ?"":".ko";\r\nswitch (exp) {\r\ncase export_gpl:\r\nfatal("modpost: GPL-incompatible module %s%s "\r\n"uses GPL-only symbol '%s'\n", m, e, s);\r\nbreak;\r\ncase export_unused_gpl:\r\nfatal("modpost: GPL-incompatible module %s%s "\r\n"uses GPL-only symbol marked UNUSED '%s'\n", m, e, s);\r\nbreak;\r\ncase export_gpl_future:\r\nwarn("modpost: GPL-incompatible module %s%s "\r\n"uses future GPL-only symbol '%s'\n", m, e, s);\r\nbreak;\r\ncase export_plain:\r\ncase export_unused:\r\ncase export_unknown:\r\nbreak;\r\n}\r\n}\r\nstatic void check_for_unused(enum export exp, const char *m, const char *s)\r\n{\r\nconst char *e = is_vmlinux(m) ?"":".ko";\r\nswitch (exp) {\r\ncase export_unused:\r\ncase export_unused_gpl:\r\nwarn("modpost: module %s%s "\r\n"uses symbol '%s' marked UNUSED\n", m, e, s);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void check_exports(struct module *mod)\r\n{\r\nstruct symbol *s, *exp;\r\nfor (s = mod->unres; s; s = s->next) {\r\nconst char *basename;\r\nexp = find_symbol(s->name);\r\nif (!exp || exp->module == mod)\r\ncontinue;\r\nbasename = strrchr(mod->name, '/');\r\nif (basename)\r\nbasename++;\r\nelse\r\nbasename = mod->name;\r\nif (!mod->gpl_compatible)\r\ncheck_for_gpl_usage(exp->export, basename, exp->name);\r\ncheck_for_unused(exp->export, basename, exp->name);\r\n}\r\n}\r\nstatic void add_header(struct buffer *b, struct module *mod)\r\n{\r\nbuf_printf(b, "#include <linux/module.h>\n");\r\nbuf_printf(b, "#include <linux/vermagic.h>\n");\r\nbuf_printf(b, "#include <linux/compiler.h>\n");\r\nbuf_printf(b, "\n");\r\nbuf_printf(b, "MODULE_INFO(vermagic, VERMAGIC_STRING);\n");\r\nbuf_printf(b, "\n");\r\nbuf_printf(b, "__visible struct module __this_module\n");\r\nbuf_printf(b, "__attribute__((section(\".gnu.linkonce.this_module\"))) = {\n");\r\nbuf_printf(b, "\t.name = KBUILD_MODNAME,\n");\r\nif (mod->has_init)\r\nbuf_printf(b, "\t.init = init_module,\n");\r\nif (mod->has_cleanup)\r\nbuf_printf(b, "#ifdef CONFIG_MODULE_UNLOAD\n"\r\n"\t.exit = cleanup_module,\n"\r\n"#endif\n");\r\nbuf_printf(b, "\t.arch = MODULE_ARCH_INIT,\n");\r\nbuf_printf(b, "};\n");\r\n}\r\nstatic void add_intree_flag(struct buffer *b, int is_intree)\r\n{\r\nif (is_intree)\r\nbuf_printf(b, "\nMODULE_INFO(intree, \"Y\");\n");\r\n}\r\nstatic void add_staging_flag(struct buffer *b, const char *name)\r\n{\r\nstatic const char *staging_dir = "drivers/staging";\r\nif (strncmp(staging_dir, name, strlen(staging_dir)) == 0)\r\nbuf_printf(b, "\nMODULE_INFO(staging, \"Y\");\n");\r\n}\r\nstatic int add_versions(struct buffer *b, struct module *mod)\r\n{\r\nstruct symbol *s, *exp;\r\nint err = 0;\r\nfor (s = mod->unres; s; s = s->next) {\r\nexp = find_symbol(s->name);\r\nif (!exp || exp->module == mod) {\r\nif (have_vmlinux && !s->weak) {\r\nif (warn_unresolved) {\r\nwarn("\"%s\" [%s.ko] undefined!\n",\r\ns->name, mod->name);\r\n} else {\r\nmerror("\"%s\" [%s.ko] undefined!\n",\r\ns->name, mod->name);\r\nerr = 1;\r\n}\r\n}\r\ncontinue;\r\n}\r\ns->module = exp->module;\r\ns->crc_valid = exp->crc_valid;\r\ns->crc = exp->crc;\r\n}\r\nif (!modversions)\r\nreturn err;\r\nbuf_printf(b, "\n");\r\nbuf_printf(b, "static const struct modversion_info ____versions[]\n");\r\nbuf_printf(b, "__used\n");\r\nbuf_printf(b, "__attribute__((section(\"__versions\"))) = {\n");\r\nfor (s = mod->unres; s; s = s->next) {\r\nif (!s->module)\r\ncontinue;\r\nif (!s->crc_valid) {\r\nwarn("\"%s\" [%s.ko] has no CRC!\n",\r\ns->name, mod->name);\r\ncontinue;\r\n}\r\nbuf_printf(b, "\t{ %#8x, __VMLINUX_SYMBOL_STR(%s) },\n",\r\ns->crc, s->name);\r\n}\r\nbuf_printf(b, "};\n");\r\nreturn err;\r\n}\r\nstatic void add_depends(struct buffer *b, struct module *mod,\r\nstruct module *modules)\r\n{\r\nstruct symbol *s;\r\nstruct module *m;\r\nint first = 1;\r\nfor (m = modules; m; m = m->next)\r\nm->seen = is_vmlinux(m->name);\r\nbuf_printf(b, "\n");\r\nbuf_printf(b, "static const char __module_depends[]\n");\r\nbuf_printf(b, "__used\n");\r\nbuf_printf(b, "__attribute__((section(\".modinfo\"))) =\n");\r\nbuf_printf(b, "\"depends=");\r\nfor (s = mod->unres; s; s = s->next) {\r\nconst char *p;\r\nif (!s->module)\r\ncontinue;\r\nif (s->module->seen)\r\ncontinue;\r\ns->module->seen = 1;\r\np = strrchr(s->module->name, '/');\r\nif (p)\r\np++;\r\nelse\r\np = s->module->name;\r\nbuf_printf(b, "%s%s", first ? "" : ",", p);\r\nfirst = 0;\r\n}\r\nbuf_printf(b, "\";\n");\r\n}\r\nstatic void add_srcversion(struct buffer *b, struct module *mod)\r\n{\r\nif (mod->srcversion[0]) {\r\nbuf_printf(b, "\n");\r\nbuf_printf(b, "MODULE_INFO(srcversion, \"%s\");\n",\r\nmod->srcversion);\r\n}\r\n}\r\nstatic void write_if_changed(struct buffer *b, const char *fname)\r\n{\r\nchar *tmp;\r\nFILE *file;\r\nstruct stat st;\r\nfile = fopen(fname, "r");\r\nif (!file)\r\ngoto write;\r\nif (fstat(fileno(file), &st) < 0)\r\ngoto close_write;\r\nif (st.st_size != b->pos)\r\ngoto close_write;\r\ntmp = NOFAIL(malloc(b->pos));\r\nif (fread(tmp, 1, b->pos, file) != b->pos)\r\ngoto free_write;\r\nif (memcmp(tmp, b->p, b->pos) != 0)\r\ngoto free_write;\r\nfree(tmp);\r\nfclose(file);\r\nreturn;\r\nfree_write:\r\nfree(tmp);\r\nclose_write:\r\nfclose(file);\r\nwrite:\r\nfile = fopen(fname, "w");\r\nif (!file) {\r\nperror(fname);\r\nexit(1);\r\n}\r\nif (fwrite(b->p, 1, b->pos, file) != b->pos) {\r\nperror(fname);\r\nexit(1);\r\n}\r\nfclose(file);\r\n}\r\nstatic void read_dump(const char *fname, unsigned int kernel)\r\n{\r\nunsigned long size, pos = 0;\r\nvoid *file = grab_file(fname, &size);\r\nchar *line;\r\nif (!file)\r\nreturn;\r\nwhile ((line = get_next_line(&pos, file, size))) {\r\nchar *symname, *modname, *d, *export, *end;\r\nunsigned int crc;\r\nstruct module *mod;\r\nstruct symbol *s;\r\nif (!(symname = strchr(line, '\t')))\r\ngoto fail;\r\n*symname++ = '\0';\r\nif (!(modname = strchr(symname, '\t')))\r\ngoto fail;\r\n*modname++ = '\0';\r\nif ((export = strchr(modname, '\t')) != NULL)\r\n*export++ = '\0';\r\nif (export && ((end = strchr(export, '\t')) != NULL))\r\n*end = '\0';\r\ncrc = strtoul(line, &d, 16);\r\nif (*symname == '\0' || *modname == '\0' || *d != '\0')\r\ngoto fail;\r\nmod = find_module(modname);\r\nif (!mod) {\r\nif (is_vmlinux(modname))\r\nhave_vmlinux = 1;\r\nmod = new_module(modname);\r\nmod->skip = 1;\r\n}\r\ns = sym_add_exported(symname, mod, export_no(export));\r\ns->kernel = kernel;\r\ns->preloaded = 1;\r\nsym_update_crc(symname, mod, crc, export_no(export));\r\n}\r\nrelease_file(file, size);\r\nreturn;\r\nfail:\r\nrelease_file(file, size);\r\nfatal("parse error in symbol dump file\n");\r\n}\r\nstatic int dump_sym(struct symbol *sym)\r\n{\r\nif (!external_module)\r\nreturn 1;\r\nif (sym->vmlinux || sym->kernel)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void write_dump(const char *fname)\r\n{\r\nstruct buffer buf = { };\r\nstruct symbol *symbol;\r\nint n;\r\nfor (n = 0; n < SYMBOL_HASH_SIZE ; n++) {\r\nsymbol = symbolhash[n];\r\nwhile (symbol) {\r\nif (dump_sym(symbol))\r\nbuf_printf(&buf, "0x%08x\t%s\t%s\t%s\n",\r\nsymbol->crc, symbol->name,\r\nsymbol->module->name,\r\nexport_str(symbol->export));\r\nsymbol = symbol->next;\r\n}\r\n}\r\nwrite_if_changed(&buf, fname);\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nstruct module *mod;\r\nstruct buffer buf = { };\r\nchar *kernel_read = NULL, *module_read = NULL;\r\nchar *dump_write = NULL, *files_source = NULL;\r\nint opt;\r\nint err;\r\nstruct ext_sym_list *extsym_iter;\r\nstruct ext_sym_list *extsym_start = NULL;\r\nwhile ((opt = getopt(argc, argv, "i:I:e:mnsST:o:awM:K:")) != -1) {\r\nswitch (opt) {\r\ncase 'i':\r\nkernel_read = optarg;\r\nbreak;\r\ncase 'I':\r\nmodule_read = optarg;\r\nexternal_module = 1;\r\nbreak;\r\ncase 'e':\r\nexternal_module = 1;\r\nextsym_iter =\r\nNOFAIL(malloc(sizeof(*extsym_iter)));\r\nextsym_iter->next = extsym_start;\r\nextsym_iter->file = optarg;\r\nextsym_start = extsym_iter;\r\nbreak;\r\ncase 'm':\r\nmodversions = 1;\r\nbreak;\r\ncase 'n':\r\nignore_missing_files = 1;\r\nbreak;\r\ncase 'o':\r\ndump_write = optarg;\r\nbreak;\r\ncase 'a':\r\nall_versions = 1;\r\nbreak;\r\ncase 's':\r\nvmlinux_section_warnings = 0;\r\nbreak;\r\ncase 'S':\r\nsec_mismatch_verbose = 0;\r\nbreak;\r\ncase 'T':\r\nfiles_source = optarg;\r\nbreak;\r\ncase 'w':\r\nwarn_unresolved = 1;\r\nbreak;\r\ndefault:\r\nexit(1);\r\n}\r\n}\r\nif (kernel_read)\r\nread_dump(kernel_read, 1);\r\nif (module_read)\r\nread_dump(module_read, 0);\r\nwhile (extsym_start) {\r\nread_dump(extsym_start->file, 0);\r\nextsym_iter = extsym_start->next;\r\nfree(extsym_start);\r\nextsym_start = extsym_iter;\r\n}\r\nwhile (optind < argc)\r\nread_symbols(argv[optind++]);\r\nif (files_source)\r\nread_symbols_from_files(files_source);\r\nfor (mod = modules; mod; mod = mod->next) {\r\nif (mod->skip)\r\ncontinue;\r\ncheck_exports(mod);\r\n}\r\nerr = 0;\r\nfor (mod = modules; mod; mod = mod->next) {\r\nchar fname[PATH_MAX];\r\nif (mod->skip)\r\ncontinue;\r\nbuf.pos = 0;\r\nadd_header(&buf, mod);\r\nadd_intree_flag(&buf, !external_module);\r\nadd_staging_flag(&buf, mod->name);\r\nerr |= add_versions(&buf, mod);\r\nadd_depends(&buf, mod, modules);\r\nadd_moddevtable(&buf, mod);\r\nadd_srcversion(&buf, mod);\r\nsprintf(fname, "%s.mod.c", mod->name);\r\nwrite_if_changed(&buf, fname);\r\n}\r\nif (dump_write)\r\nwrite_dump(dump_write);\r\nif (sec_mismatch_count && !sec_mismatch_verbose)\r\nwarn("modpost: Found %d section mismatch(es).\n"\r\n"To see full details build your kernel with:\n"\r\n"'make CONFIG_DEBUG_SECTION_MISMATCH=y'\n",\r\nsec_mismatch_count);\r\nreturn err;\r\n}
