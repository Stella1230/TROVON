static inline void\r\nmsmsdcc_disable_clocks(struct msmsdcc_host *host, int deferr)\r\n{\r\nWARN_ON(!host->clks_on);\r\nBUG_ON(host->curr.mrq);\r\nif (deferr) {\r\nmod_timer(&host->busclk_timer, jiffies + BUSCLK_TIMEOUT);\r\n} else {\r\ndel_timer_sync(&host->busclk_timer);\r\nif (host->clks_on) {\r\nclk_disable(host->clk);\r\nclk_disable(host->pclk);\r\nhost->clks_on = 0;\r\n}\r\n}\r\n}\r\nstatic inline int\r\nmsmsdcc_enable_clocks(struct msmsdcc_host *host)\r\n{\r\nint rc;\r\ndel_timer_sync(&host->busclk_timer);\r\nif (!host->clks_on) {\r\nrc = clk_enable(host->pclk);\r\nif (rc)\r\nreturn rc;\r\nrc = clk_enable(host->clk);\r\nif (rc) {\r\nclk_disable(host->pclk);\r\nreturn rc;\r\n}\r\nudelay(1 + ((3 * USEC_PER_SEC) /\r\n(host->clk_rate ? host->clk_rate : msmsdcc_fmin)));\r\nhost->clks_on = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline unsigned int\r\nmsmsdcc_readl(struct msmsdcc_host *host, unsigned int reg)\r\n{\r\nreturn readl(host->base + reg);\r\n}\r\nstatic inline void\r\nmsmsdcc_writel(struct msmsdcc_host *host, u32 data, unsigned int reg)\r\n{\r\nwritel(data, host->base + reg);\r\nudelay(1 + ((3 * USEC_PER_SEC) /\r\n(host->clk_rate ? host->clk_rate : msmsdcc_fmin)));\r\n}\r\nstatic void msmsdcc_reset_and_restore(struct msmsdcc_host *host)\r\n{\r\nu32 mci_clk = 0;\r\nu32 mci_mask0 = 0;\r\nint ret = 0;\r\nmci_clk = readl(host->base + MMCICLOCK);\r\nmci_mask0 = readl(host->base + MMCIMASK0);\r\nret = clk_reset(host->clk, CLK_RESET_ASSERT);\r\nif (ret)\r\npr_err("%s: Clock assert failed at %u Hz with err %d\n",\r\nmmc_hostname(host->mmc), host->clk_rate, ret);\r\nret = clk_reset(host->clk, CLK_RESET_DEASSERT);\r\nif (ret)\r\npr_err("%s: Clock deassert failed at %u Hz with err %d\n",\r\nmmc_hostname(host->mmc), host->clk_rate, ret);\r\npr_info("%s: Controller has been re-initialiazed\n",\r\nmmc_hostname(host->mmc));\r\nwritel(host->pwr, host->base + MMCIPOWER);\r\nwritel(mci_clk, host->base + MMCICLOCK);\r\nwritel(mci_mask0, host->base + MMCIMASK0);\r\nret = clk_set_rate(host->clk, host->clk_rate);\r\nif (ret)\r\npr_err("%s: Failed to set clk rate %u Hz (%d)\n",\r\nmmc_hostname(host->mmc), host->clk_rate, ret);\r\n}\r\nstatic void\r\nmsmsdcc_request_end(struct msmsdcc_host *host, struct mmc_request *mrq)\r\n{\r\nBUG_ON(host->curr.data);\r\nhost->curr.mrq = NULL;\r\nhost->curr.cmd = NULL;\r\nif (mrq->data)\r\nmrq->data->bytes_xfered = host->curr.data_xfered;\r\nif (mrq->cmd->error == -ETIMEDOUT)\r\nmdelay(5);\r\n#if BUSCLK_PWRSAVE\r\nmsmsdcc_disable_clocks(host, 1);\r\n#endif\r\nspin_unlock(&host->lock);\r\nmmc_request_done(host->mmc, mrq);\r\nspin_lock(&host->lock);\r\n}\r\nstatic void\r\nmsmsdcc_stop_data(struct msmsdcc_host *host)\r\n{\r\nhost->curr.data = NULL;\r\nhost->curr.got_dataend = 0;\r\n}\r\nuint32_t msmsdcc_fifo_addr(struct msmsdcc_host *host)\r\n{\r\nreturn host->memres->start + MMCIFIFO;\r\n}\r\nstatic inline void\r\nmsmsdcc_start_command_exec(struct msmsdcc_host *host, u32 arg, u32 c) {\r\nmsmsdcc_writel(host, arg, MMCIARGUMENT);\r\nmsmsdcc_writel(host, c, MMCICOMMAND);\r\n}\r\nstatic void\r\nmsmsdcc_dma_exec_func(struct msm_dmov_cmd *cmd)\r\n{\r\nstruct msmsdcc_host *host = (struct msmsdcc_host *)cmd->data;\r\nmsmsdcc_writel(host, host->cmd_timeout, MMCIDATATIMER);\r\nmsmsdcc_writel(host, (unsigned int)host->curr.xfer_size,\r\nMMCIDATALENGTH);\r\nmsmsdcc_writel(host, (msmsdcc_readl(host, MMCIMASK0) &\r\n(~MCI_IRQ_PIO)) | host->cmd_pio_irqmask, MMCIMASK0);\r\nmsmsdcc_writel(host, host->cmd_datactrl, MMCIDATACTRL);\r\nif (host->cmd_cmd) {\r\nmsmsdcc_start_command_exec(host,\r\n(u32) host->cmd_cmd->arg,\r\n(u32) host->cmd_c);\r\n}\r\nhost->dma.active = 1;\r\n}\r\nstatic void\r\nmsmsdcc_dma_complete_tlet(unsigned long data)\r\n{\r\nstruct msmsdcc_host *host = (struct msmsdcc_host *)data;\r\nunsigned long flags;\r\nstruct mmc_request *mrq;\r\nstruct msm_dmov_errdata err;\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->dma.active = 0;\r\nerr = host->dma.err;\r\nmrq = host->curr.mrq;\r\nBUG_ON(!mrq);\r\nWARN_ON(!mrq->data);\r\nif (!(host->dma.result & DMOV_RSLT_VALID)) {\r\npr_err("msmsdcc: Invalid DataMover result\n");\r\ngoto out;\r\n}\r\nif (host->dma.result & DMOV_RSLT_DONE) {\r\nhost->curr.data_xfered = host->curr.xfer_size;\r\n} else {\r\nif (host->dma.result & DMOV_RSLT_ERROR)\r\npr_err("%s: DMA error (0x%.8x)\n",\r\nmmc_hostname(host->mmc), host->dma.result);\r\nif (host->dma.result & DMOV_RSLT_FLUSH)\r\npr_err("%s: DMA channel flushed (0x%.8x)\n",\r\nmmc_hostname(host->mmc), host->dma.result);\r\npr_err("Flush data: %.8x %.8x %.8x %.8x %.8x %.8x\n",\r\nerr.flush[0], err.flush[1], err.flush[2],\r\nerr.flush[3], err.flush[4], err.flush[5]);\r\nmsmsdcc_reset_and_restore(host);\r\nif (!mrq->data->error)\r\nmrq->data->error = -EIO;\r\n}\r\ndma_unmap_sg(mmc_dev(host->mmc), host->dma.sg, host->dma.num_ents,\r\nhost->dma.dir);\r\nhost->dma.sg = NULL;\r\nhost->dma.busy = 0;\r\nif (host->curr.got_dataend || mrq->data->error) {\r\nmsmsdcc_stop_data(host);\r\nif (!mrq->data->error)\r\nhost->curr.data_xfered = host->curr.xfer_size;\r\nif (!mrq->data->stop || mrq->cmd->error) {\r\nhost->curr.mrq = NULL;\r\nhost->curr.cmd = NULL;\r\nmrq->data->bytes_xfered = host->curr.data_xfered;\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n#if BUSCLK_PWRSAVE\r\nmsmsdcc_disable_clocks(host, 1);\r\n#endif\r\nmmc_request_done(host->mmc, mrq);\r\nreturn;\r\n} else\r\nmsmsdcc_start_command(host, mrq->data->stop, 0);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nreturn;\r\n}\r\nstatic void\r\nmsmsdcc_dma_complete_func(struct msm_dmov_cmd *cmd,\r\nunsigned int result,\r\nstruct msm_dmov_errdata *err)\r\n{\r\nstruct msmsdcc_dma_data *dma_data =\r\ncontainer_of(cmd, struct msmsdcc_dma_data, hdr);\r\nstruct msmsdcc_host *host = dma_data->host;\r\ndma_data->result = result;\r\nif (err)\r\nmemcpy(&dma_data->err, err, sizeof(struct msm_dmov_errdata));\r\ntasklet_schedule(&host->dma_tlet);\r\n}\r\nstatic int validate_dma(struct msmsdcc_host *host, struct mmc_data *data)\r\n{\r\nif (host->dma.channel == -1)\r\nreturn -ENOENT;\r\nif ((data->blksz * data->blocks) < MCI_FIFOSIZE)\r\nreturn -EINVAL;\r\nif ((data->blksz * data->blocks) % MCI_FIFOSIZE)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int msmsdcc_config_dma(struct msmsdcc_host *host, struct mmc_data *data)\r\n{\r\nstruct msmsdcc_nc_dmadata *nc;\r\ndmov_box *box;\r\nuint32_t rows;\r\nuint32_t crci;\r\nunsigned int n;\r\nint i, rc;\r\nstruct scatterlist *sg = data->sg;\r\nrc = validate_dma(host, data);\r\nif (rc)\r\nreturn rc;\r\nhost->dma.sg = data->sg;\r\nhost->dma.num_ents = data->sg_len;\r\nBUG_ON(host->dma.num_ents > NR_SG);\r\nnc = host->dma.nc;\r\nswitch (host->pdev_id) {\r\ncase 1:\r\ncrci = MSMSDCC_CRCI_SDC1;\r\nbreak;\r\ncase 2:\r\ncrci = MSMSDCC_CRCI_SDC2;\r\nbreak;\r\ncase 3:\r\ncrci = MSMSDCC_CRCI_SDC3;\r\nbreak;\r\ncase 4:\r\ncrci = MSMSDCC_CRCI_SDC4;\r\nbreak;\r\ndefault:\r\nhost->dma.sg = NULL;\r\nhost->dma.num_ents = 0;\r\nreturn -ENOENT;\r\n}\r\nif (data->flags & MMC_DATA_READ)\r\nhost->dma.dir = DMA_FROM_DEVICE;\r\nelse\r\nhost->dma.dir = DMA_TO_DEVICE;\r\nhost->curr.user_pages = 0;\r\nbox = &nc->cmd[0];\r\nBUG_ON(host->dma.cmd_busaddr & 0x07);\r\nnc->cmdptr = (host->dma.cmd_busaddr >> 3) | CMD_PTR_LP;\r\nhost->dma.hdr.cmdptr = DMOV_CMD_PTR_LIST |\r\nDMOV_CMD_ADDR(host->dma.cmdptr_busaddr);\r\nhost->dma.hdr.complete_func = msmsdcc_dma_complete_func;\r\nn = dma_map_sg(mmc_dev(host->mmc), host->dma.sg,\r\nhost->dma.num_ents, host->dma.dir);\r\nif (n == 0) {\r\npr_err("%s: Unable to map in all sg elements\n",\r\nmmc_hostname(host->mmc));\r\nhost->dma.sg = NULL;\r\nhost->dma.num_ents = 0;\r\nreturn -ENOMEM;\r\n}\r\nfor_each_sg(host->dma.sg, sg, n, i) {\r\nbox->cmd = CMD_MODE_BOX;\r\nif (i == n - 1)\r\nbox->cmd |= CMD_LC;\r\nrows = (sg_dma_len(sg) % MCI_FIFOSIZE) ?\r\n(sg_dma_len(sg) / MCI_FIFOSIZE) + 1 :\r\n(sg_dma_len(sg) / MCI_FIFOSIZE) ;\r\nif (data->flags & MMC_DATA_READ) {\r\nbox->src_row_addr = msmsdcc_fifo_addr(host);\r\nbox->dst_row_addr = sg_dma_address(sg);\r\nbox->src_dst_len = (MCI_FIFOSIZE << 16) |\r\n(MCI_FIFOSIZE);\r\nbox->row_offset = MCI_FIFOSIZE;\r\nbox->num_rows = rows * ((1 << 16) + 1);\r\nbox->cmd |= CMD_SRC_CRCI(crci);\r\n} else {\r\nbox->src_row_addr = sg_dma_address(sg);\r\nbox->dst_row_addr = msmsdcc_fifo_addr(host);\r\nbox->src_dst_len = (MCI_FIFOSIZE << 16) |\r\n(MCI_FIFOSIZE);\r\nbox->row_offset = (MCI_FIFOSIZE << 16);\r\nbox->num_rows = rows * ((1 << 16) + 1);\r\nbox->cmd |= CMD_DST_CRCI(crci);\r\n}\r\nbox++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsnoop_cccr_abort(struct mmc_command *cmd)\r\n{\r\nif ((cmd->opcode == 52) &&\r\n(cmd->arg & 0x80000000) &&\r\n(((cmd->arg >> 9) & 0x1ffff) == SDIO_CCCR_ABORT))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void\r\nmsmsdcc_start_command_deferred(struct msmsdcc_host *host,\r\nstruct mmc_command *cmd, u32 *c)\r\n{\r\n*c |= (cmd->opcode | MCI_CPSM_ENABLE);\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\nif (cmd->flags & MMC_RSP_136)\r\n*c |= MCI_CPSM_LONGRSP;\r\n*c |= MCI_CPSM_RESPONSE;\r\n}\r\nif (0)\r\n*c |= MCI_CPSM_INTERRUPT;\r\nif ((((cmd->opcode == 17) || (cmd->opcode == 18)) ||\r\n((cmd->opcode == 24) || (cmd->opcode == 25))) ||\r\n(cmd->opcode == 53))\r\n*c |= MCI_CSPM_DATCMD;\r\nif (host->prog_scan && (cmd->opcode == 12)) {\r\n*c |= MCI_CPSM_PROGENA;\r\nhost->prog_enable = true;\r\n}\r\nif (cmd == cmd->mrq->stop)\r\n*c |= MCI_CSPM_MCIABORT;\r\nif (snoop_cccr_abort(cmd))\r\n*c |= MCI_CSPM_MCIABORT;\r\nif (host->curr.cmd != NULL) {\r\npr_err("%s: Overlapping command requests\n",\r\nmmc_hostname(host->mmc));\r\n}\r\nhost->curr.cmd = cmd;\r\n}\r\nstatic void\r\nmsmsdcc_start_data(struct msmsdcc_host *host, struct mmc_data *data,\r\nstruct mmc_command *cmd, u32 c)\r\n{\r\nunsigned int datactrl, timeout;\r\nunsigned long long clks;\r\nunsigned int pio_irqmask = 0;\r\nhost->curr.data = data;\r\nhost->curr.xfer_size = data->blksz * data->blocks;\r\nhost->curr.xfer_remain = host->curr.xfer_size;\r\nhost->curr.data_xfered = 0;\r\nhost->curr.got_dataend = 0;\r\nmemset(&host->pio, 0, sizeof(host->pio));\r\ndatactrl = MCI_DPSM_ENABLE | (data->blksz << 4);\r\nif (!msmsdcc_config_dma(host, data))\r\ndatactrl |= MCI_DPSM_DMAENABLE;\r\nelse {\r\nhost->pio.sg = data->sg;\r\nhost->pio.sg_len = data->sg_len;\r\nhost->pio.sg_off = 0;\r\nif (data->flags & MMC_DATA_READ) {\r\npio_irqmask = MCI_RXFIFOHALFFULLMASK;\r\nif (host->curr.xfer_remain < MCI_FIFOSIZE)\r\npio_irqmask |= MCI_RXDATAAVLBLMASK;\r\n} else\r\npio_irqmask = MCI_TXFIFOHALFEMPTYMASK;\r\n}\r\nif (data->flags & MMC_DATA_READ)\r\ndatactrl |= MCI_DPSM_DIRECTION;\r\nclks = (unsigned long long)data->timeout_ns * host->clk_rate;\r\ndo_div(clks, NSEC_PER_SEC);\r\ntimeout = data->timeout_clks + (unsigned int)clks*2 ;\r\nif (datactrl & MCI_DPSM_DMAENABLE) {\r\nhost->cmd_timeout = timeout;\r\nhost->cmd_pio_irqmask = pio_irqmask;\r\nhost->cmd_datactrl = datactrl;\r\nhost->cmd_cmd = cmd;\r\nhost->dma.hdr.execute_func = msmsdcc_dma_exec_func;\r\nhost->dma.hdr.data = (void *)host;\r\nhost->dma.busy = 1;\r\nif (cmd) {\r\nmsmsdcc_start_command_deferred(host, cmd, &c);\r\nhost->cmd_c = c;\r\n}\r\nmsm_dmov_enqueue_cmd(host->dma.channel, &host->dma.hdr);\r\nif (data->flags & MMC_DATA_WRITE)\r\nhost->prog_scan = true;\r\n} else {\r\nmsmsdcc_writel(host, timeout, MMCIDATATIMER);\r\nmsmsdcc_writel(host, host->curr.xfer_size, MMCIDATALENGTH);\r\nmsmsdcc_writel(host, (msmsdcc_readl(host, MMCIMASK0) &\r\n(~MCI_IRQ_PIO)) | pio_irqmask, MMCIMASK0);\r\nmsmsdcc_writel(host, datactrl, MMCIDATACTRL);\r\nif (cmd) {\r\nmsmsdcc_start_command(host, cmd, c);\r\n}\r\n}\r\n}\r\nstatic void\r\nmsmsdcc_start_command(struct msmsdcc_host *host, struct mmc_command *cmd, u32 c)\r\n{\r\nif (cmd == cmd->mrq->stop)\r\nc |= MCI_CSPM_MCIABORT;\r\nhost->stats.cmds++;\r\nmsmsdcc_start_command_deferred(host, cmd, &c);\r\nmsmsdcc_start_command_exec(host, cmd->arg, c);\r\n}\r\nstatic void\r\nmsmsdcc_data_err(struct msmsdcc_host *host, struct mmc_data *data,\r\nunsigned int status)\r\n{\r\nif (status & MCI_DATACRCFAIL) {\r\npr_err("%s: Data CRC error\n", mmc_hostname(host->mmc));\r\npr_err("%s: opcode 0x%.8x\n", __func__,\r\ndata->mrq->cmd->opcode);\r\npr_err("%s: blksz %d, blocks %d\n", __func__,\r\ndata->blksz, data->blocks);\r\ndata->error = -EILSEQ;\r\n} else if (status & MCI_DATATIMEOUT) {\r\npr_err("%s: Data timeout\n", mmc_hostname(host->mmc));\r\ndata->error = -ETIMEDOUT;\r\n} else if (status & MCI_RXOVERRUN) {\r\npr_err("%s: RX overrun\n", mmc_hostname(host->mmc));\r\ndata->error = -EIO;\r\n} else if (status & MCI_TXUNDERRUN) {\r\npr_err("%s: TX underrun\n", mmc_hostname(host->mmc));\r\ndata->error = -EIO;\r\n} else {\r\npr_err("%s: Unknown error (0x%.8x)\n",\r\nmmc_hostname(host->mmc), status);\r\ndata->error = -EIO;\r\n}\r\n}\r\nstatic int\r\nmsmsdcc_pio_read(struct msmsdcc_host *host, char *buffer, unsigned int remain)\r\n{\r\nuint32_t *ptr = (uint32_t *) buffer;\r\nint count = 0;\r\nif (remain % 4)\r\nremain = ((remain >> 2) + 1) << 2;\r\nwhile (msmsdcc_readl(host, MMCISTATUS) & MCI_RXDATAAVLBL) {\r\n*ptr = msmsdcc_readl(host, MMCIFIFO + (count % MCI_FIFOSIZE));\r\nptr++;\r\ncount += sizeof(uint32_t);\r\nremain -= sizeof(uint32_t);\r\nif (remain == 0)\r\nbreak;\r\n}\r\nreturn count;\r\n}\r\nstatic int\r\nmsmsdcc_pio_write(struct msmsdcc_host *host, char *buffer,\r\nunsigned int remain, u32 status)\r\n{\r\nvoid __iomem *base = host->base;\r\nchar *ptr = buffer;\r\ndo {\r\nunsigned int count, maxcnt, sz;\r\nmaxcnt = status & MCI_TXFIFOEMPTY ? MCI_FIFOSIZE :\r\nMCI_FIFOHALFSIZE;\r\ncount = min(remain, maxcnt);\r\nsz = count % 4 ? (count >> 2) + 1 : (count >> 2);\r\nwritesl(base + MMCIFIFO, ptr, sz);\r\nptr += count;\r\nremain -= count;\r\nif (remain == 0)\r\nbreak;\r\nstatus = msmsdcc_readl(host, MMCISTATUS);\r\n} while (status & MCI_TXFIFOHALFEMPTY);\r\nreturn ptr - buffer;\r\n}\r\nstatic int\r\nmsmsdcc_spin_on_status(struct msmsdcc_host *host, uint32_t mask, int maxspin)\r\n{\r\nwhile (maxspin) {\r\nif ((msmsdcc_readl(host, MMCISTATUS) & mask))\r\nreturn 0;\r\nudelay(1);\r\n--maxspin;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic irqreturn_t\r\nmsmsdcc_pio_irq(int irq, void *dev_id)\r\n{\r\nstruct msmsdcc_host *host = dev_id;\r\nuint32_t status;\r\nu32 mci_mask0;\r\nstatus = msmsdcc_readl(host, MMCISTATUS);\r\nmci_mask0 = msmsdcc_readl(host, MMCIMASK0);\r\nif (((mci_mask0 & status) & MCI_IRQ_PIO) == 0)\r\nreturn IRQ_NONE;\r\ndo {\r\nunsigned long flags;\r\nunsigned int remain, len;\r\nchar *buffer;\r\nif (!(status & (MCI_TXFIFOHALFEMPTY | MCI_RXDATAAVLBL))) {\r\nif (host->curr.xfer_remain == 0 || !msmsdcc_piopoll)\r\nbreak;\r\nif (msmsdcc_spin_on_status(host,\r\n(MCI_TXFIFOHALFEMPTY |\r\nMCI_RXDATAAVLBL),\r\nPIO_SPINMAX)) {\r\nbreak;\r\n}\r\n}\r\nlocal_irq_save(flags);\r\nbuffer = kmap_atomic(sg_page(host->pio.sg))\r\n+ host->pio.sg->offset;\r\nbuffer += host->pio.sg_off;\r\nremain = host->pio.sg->length - host->pio.sg_off;\r\nlen = 0;\r\nif (status & MCI_RXACTIVE)\r\nlen = msmsdcc_pio_read(host, buffer, remain);\r\nif (status & MCI_TXACTIVE)\r\nlen = msmsdcc_pio_write(host, buffer, remain, status);\r\nkunmap_atomic(buffer);\r\nlocal_irq_restore(flags);\r\nhost->pio.sg_off += len;\r\nhost->curr.xfer_remain -= len;\r\nhost->curr.data_xfered += len;\r\nremain -= len;\r\nif (remain == 0) {\r\nif (status & MCI_RXACTIVE && host->curr.user_pages)\r\nflush_dcache_page(sg_page(host->pio.sg));\r\nif (!--host->pio.sg_len) {\r\nmemset(&host->pio, 0, sizeof(host->pio));\r\nbreak;\r\n}\r\nhost->pio.sg++;\r\nhost->pio.sg_off = 0;\r\n}\r\nstatus = msmsdcc_readl(host, MMCISTATUS);\r\n} while (1);\r\nif (status & MCI_RXACTIVE && host->curr.xfer_remain < MCI_FIFOSIZE)\r\nmsmsdcc_writel(host, (mci_mask0 & (~MCI_IRQ_PIO)) |\r\nMCI_RXDATAAVLBLMASK, MMCIMASK0);\r\nif (!host->curr.xfer_remain)\r\nmsmsdcc_writel(host, (mci_mask0 & (~MCI_IRQ_PIO)) | 0,\r\nMMCIMASK0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void msmsdcc_do_cmdirq(struct msmsdcc_host *host, uint32_t status)\r\n{\r\nstruct mmc_command *cmd = host->curr.cmd;\r\nhost->curr.cmd = NULL;\r\ncmd->resp[0] = msmsdcc_readl(host, MMCIRESPONSE0);\r\ncmd->resp[1] = msmsdcc_readl(host, MMCIRESPONSE1);\r\ncmd->resp[2] = msmsdcc_readl(host, MMCIRESPONSE2);\r\ncmd->resp[3] = msmsdcc_readl(host, MMCIRESPONSE3);\r\nif (status & MCI_CMDTIMEOUT) {\r\ncmd->error = -ETIMEDOUT;\r\n} else if (status & MCI_CMDCRCFAIL &&\r\ncmd->flags & MMC_RSP_CRC) {\r\npr_err("%s: Command CRC error\n", mmc_hostname(host->mmc));\r\ncmd->error = -EILSEQ;\r\n}\r\nif (!cmd->data || cmd->error) {\r\nif (host->curr.data && host->dma.sg)\r\nmsm_dmov_stop_cmd(host->dma.channel,\r\n&host->dma.hdr, 0);\r\nelse if (host->curr.data) {\r\nmsmsdcc_reset_and_restore(host);\r\nmsmsdcc_stop_data(host);\r\nmsmsdcc_request_end(host, cmd->mrq);\r\n} else {\r\nif (!cmd->error && host->prog_enable) {\r\nif (status & MCI_PROGDONE) {\r\nhost->prog_scan = false;\r\nhost->prog_enable = false;\r\nmsmsdcc_request_end(host, cmd->mrq);\r\n} else {\r\nhost->curr.cmd = cmd;\r\n}\r\n} else {\r\nif (host->prog_enable) {\r\nhost->prog_scan = false;\r\nhost->prog_enable = false;\r\n}\r\nmsmsdcc_request_end(host, cmd->mrq);\r\n}\r\n}\r\n} else if (cmd->data)\r\nif (!(cmd->data->flags & MMC_DATA_READ))\r\nmsmsdcc_start_data(host, cmd->data,\r\nNULL, 0);\r\n}\r\nstatic void\r\nmsmsdcc_handle_irq_data(struct msmsdcc_host *host, u32 status,\r\nvoid __iomem *base)\r\n{\r\nstruct mmc_data *data = host->curr.data;\r\nif (status & (MCI_CMDSENT | MCI_CMDRESPEND | MCI_CMDCRCFAIL |\r\nMCI_CMDTIMEOUT | MCI_PROGDONE) && host->curr.cmd) {\r\nmsmsdcc_do_cmdirq(host, status);\r\n}\r\nif (!data)\r\nreturn;\r\nif (status & (MCI_DATACRCFAIL | MCI_DATATIMEOUT |\r\nMCI_TXUNDERRUN | MCI_RXOVERRUN)) {\r\nmsmsdcc_data_err(host, data, status);\r\nhost->curr.data_xfered = 0;\r\nif (host->dma.sg)\r\nmsm_dmov_stop_cmd(host->dma.channel,\r\n&host->dma.hdr, 0);\r\nelse {\r\nmsmsdcc_reset_and_restore(host);\r\nif (host->curr.data)\r\nmsmsdcc_stop_data(host);\r\nif (!data->stop)\r\nmsmsdcc_request_end(host, data->mrq);\r\nelse\r\nmsmsdcc_start_command(host, data->stop, 0);\r\n}\r\n}\r\nif (!host->curr.got_dataend && (status & MCI_DATAEND))\r\nhost->curr.got_dataend = 1;\r\nif (host->curr.got_dataend && !host->dma.busy) {\r\nif (readl(base + MMCISTATUS) & MCI_RXDATAAVLBL)\r\nmsmsdcc_pio_irq(1, host);\r\nmsmsdcc_stop_data(host);\r\nif (!data->error)\r\nhost->curr.data_xfered = host->curr.xfer_size;\r\nif (!data->stop)\r\nmsmsdcc_request_end(host, data->mrq);\r\nelse\r\nmsmsdcc_start_command(host, data->stop, 0);\r\n}\r\n}\r\nstatic irqreturn_t\r\nmsmsdcc_irq(int irq, void *dev_id)\r\n{\r\nstruct msmsdcc_host *host = dev_id;\r\nvoid __iomem *base = host->base;\r\nu32 status;\r\nint ret = 0;\r\nint cardint = 0;\r\nspin_lock(&host->lock);\r\ndo {\r\nstatus = msmsdcc_readl(host, MMCISTATUS);\r\nstatus &= msmsdcc_readl(host, MMCIMASK0);\r\nif ((status & (~MCI_IRQ_PIO)) == 0)\r\nbreak;\r\nmsmsdcc_writel(host, status, MMCICLEAR);\r\nif (status & MCI_SDIOINTR)\r\nstatus &= ~MCI_SDIOINTR;\r\nif (!status)\r\nbreak;\r\nmsmsdcc_handle_irq_data(host, status, base);\r\nif (status & MCI_SDIOINTOPER) {\r\ncardint = 1;\r\nstatus &= ~MCI_SDIOINTOPER;\r\n}\r\nret = 1;\r\n} while (status);\r\nspin_unlock(&host->lock);\r\nif (cardint)\r\nmmc_signal_sdio_irq(host->mmc);\r\nreturn IRQ_RETVAL(ret);\r\n}\r\nstatic void\r\nmsmsdcc_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct msmsdcc_host *host = mmc_priv(mmc);\r\nunsigned long flags;\r\nWARN_ON(host->curr.mrq != NULL);\r\nWARN_ON(host->pwr == 0);\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->stats.reqs++;\r\nif (host->eject) {\r\nif (mrq->data && !(mrq->data->flags & MMC_DATA_READ)) {\r\nmrq->cmd->error = 0;\r\nmrq->data->bytes_xfered = mrq->data->blksz *\r\nmrq->data->blocks;\r\n} else\r\nmrq->cmd->error = -ENOMEDIUM;\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nmmc_request_done(mmc, mrq);\r\nreturn;\r\n}\r\nmsmsdcc_enable_clocks(host);\r\nhost->curr.mrq = mrq;\r\nif (mrq->data && mrq->data->flags & MMC_DATA_READ)\r\nmsmsdcc_start_data(host, mrq->data, mrq->cmd, 0);\r\nelse\r\nmsmsdcc_start_command(host, mrq->cmd, 0);\r\nif (host->cmdpoll && !msmsdcc_spin_on_status(host,\r\nMCI_CMDRESPEND|MCI_CMDCRCFAIL|MCI_CMDTIMEOUT,\r\nCMD_SPINMAX)) {\r\nuint32_t status = msmsdcc_readl(host, MMCISTATUS);\r\nmsmsdcc_do_cmdirq(host, status);\r\nmsmsdcc_writel(host,\r\nMCI_CMDRESPEND | MCI_CMDCRCFAIL | MCI_CMDTIMEOUT,\r\nMMCICLEAR);\r\nhost->stats.cmdpoll_hits++;\r\n} else {\r\nhost->stats.cmdpoll_misses++;\r\n}\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic void msmsdcc_setup_gpio(struct msmsdcc_host *host, bool enable)\r\n{\r\nstruct msm_mmc_gpio_data *curr;\r\nint i, rc = 0;\r\nif (!host->plat->gpio_data || host->gpio_config_status == enable)\r\nreturn;\r\ncurr = host->plat->gpio_data;\r\nfor (i = 0; i < curr->size; i++) {\r\nif (enable) {\r\nrc = gpio_request(curr->gpio[i].no,\r\ncurr->gpio[i].name);\r\nif (rc) {\r\npr_err("%s: gpio_request(%d, %s) failed %d\n",\r\nmmc_hostname(host->mmc),\r\ncurr->gpio[i].no,\r\ncurr->gpio[i].name, rc);\r\ngoto free_gpios;\r\n}\r\n} else {\r\ngpio_free(curr->gpio[i].no);\r\n}\r\n}\r\nhost->gpio_config_status = enable;\r\nreturn;\r\nfree_gpios:\r\nfor (; i >= 0; i--)\r\ngpio_free(curr->gpio[i].no);\r\n}\r\nstatic void\r\nmsmsdcc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct msmsdcc_host *host = mmc_priv(mmc);\r\nu32 clk = 0, pwr = 0;\r\nint rc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nmsmsdcc_enable_clocks(host);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nif (ios->clock) {\r\nif (ios->clock != host->clk_rate) {\r\nrc = clk_set_rate(host->clk, ios->clock);\r\nif (rc < 0)\r\npr_err("%s: Error setting clock rate (%d)\n",\r\nmmc_hostname(host->mmc), rc);\r\nelse\r\nhost->clk_rate = ios->clock;\r\n}\r\nclk |= MCI_CLK_ENABLE;\r\n}\r\nif (ios->bus_width == MMC_BUS_WIDTH_4)\r\nclk |= (2 << 10);\r\nif (ios->clock > 400000 && msmsdcc_pwrsave)\r\nclk |= (1 << 9);\r\nclk |= (1 << 12);\r\nclk |= (1 << 15);\r\nif (host->plat->translate_vdd)\r\npwr |= host->plat->translate_vdd(mmc_dev(mmc), ios->vdd);\r\nswitch (ios->power_mode) {\r\ncase MMC_POWER_OFF:\r\nmsmsdcc_setup_gpio(host, false);\r\nbreak;\r\ncase MMC_POWER_UP:\r\npwr |= MCI_PWR_UP;\r\nmsmsdcc_setup_gpio(host, true);\r\nbreak;\r\ncase MMC_POWER_ON:\r\npwr |= MCI_PWR_ON;\r\nbreak;\r\n}\r\nif (ios->bus_mode == MMC_BUSMODE_OPENDRAIN)\r\npwr |= MCI_OD;\r\nmsmsdcc_writel(host, clk, MMCICLOCK);\r\nif (host->pwr != pwr) {\r\nhost->pwr = pwr;\r\nmsmsdcc_writel(host, pwr, MMCIPOWER);\r\n}\r\n#if BUSCLK_PWRSAVE\r\nspin_lock_irqsave(&host->lock, flags);\r\nmsmsdcc_disable_clocks(host, 1);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n#endif\r\n}\r\nstatic void msmsdcc_enable_sdio_irq(struct mmc_host *mmc, int enable)\r\n{\r\nstruct msmsdcc_host *host = mmc_priv(mmc);\r\nunsigned long flags;\r\nu32 status;\r\nspin_lock_irqsave(&host->lock, flags);\r\nif (msmsdcc_sdioirq == 1) {\r\nstatus = msmsdcc_readl(host, MMCIMASK0);\r\nif (enable)\r\nstatus |= MCI_SDIOINTOPERMASK;\r\nelse\r\nstatus &= ~MCI_SDIOINTOPERMASK;\r\nhost->saved_irq0mask = status;\r\nmsmsdcc_writel(host, status, MMCIMASK0);\r\n}\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic void msmsdcc_init_card(struct mmc_host *mmc, struct mmc_card *card)\r\n{\r\nstruct msmsdcc_host *host = mmc_priv(mmc);\r\nif (host->plat->init_card)\r\nhost->plat->init_card(card);\r\n}\r\nstatic void\r\nmsmsdcc_check_status(unsigned long data)\r\n{\r\nstruct msmsdcc_host *host = (struct msmsdcc_host *)data;\r\nunsigned int status;\r\nif (!host->plat->status) {\r\nmmc_detect_change(host->mmc, 0);\r\ngoto out;\r\n}\r\nstatus = host->plat->status(mmc_dev(host->mmc));\r\nhost->eject = !status;\r\nif (status ^ host->oldstat) {\r\npr_info("%s: Slot status change detected (%d -> %d)\n",\r\nmmc_hostname(host->mmc), host->oldstat, status);\r\nif (status)\r\nmmc_detect_change(host->mmc, (5 * HZ) / 2);\r\nelse\r\nmmc_detect_change(host->mmc, 0);\r\n}\r\nhost->oldstat = status;\r\nout:\r\nif (host->timer.function)\r\nmod_timer(&host->timer, jiffies + HZ);\r\n}\r\nstatic irqreturn_t\r\nmsmsdcc_platform_status_irq(int irq, void *dev_id)\r\n{\r\nstruct msmsdcc_host *host = dev_id;\r\npr_debug("%s: %d\n", __func__, irq);\r\nmsmsdcc_check_status((unsigned long) host);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nmsmsdcc_status_notify_cb(int card_present, void *dev_id)\r\n{\r\nstruct msmsdcc_host *host = dev_id;\r\npr_debug("%s: card_present %d\n", mmc_hostname(host->mmc),\r\ncard_present);\r\nmsmsdcc_check_status((unsigned long) host);\r\n}\r\nstatic void\r\nmsmsdcc_busclk_expired(unsigned long _data)\r\n{\r\nstruct msmsdcc_host *host = (struct msmsdcc_host *) _data;\r\nif (host->clks_on)\r\nmsmsdcc_disable_clocks(host, 0);\r\n}\r\nstatic int\r\nmsmsdcc_init_dma(struct msmsdcc_host *host)\r\n{\r\nmemset(&host->dma, 0, sizeof(struct msmsdcc_dma_data));\r\nhost->dma.host = host;\r\nhost->dma.channel = -1;\r\nif (!host->dmares)\r\nreturn -ENODEV;\r\nhost->dma.nc = dma_alloc_coherent(NULL,\r\nsizeof(struct msmsdcc_nc_dmadata),\r\n&host->dma.nc_busaddr,\r\nGFP_KERNEL);\r\nif (host->dma.nc == NULL) {\r\npr_err("Unable to allocate DMA buffer\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(host->dma.nc, 0x00, sizeof(struct msmsdcc_nc_dmadata));\r\nhost->dma.cmd_busaddr = host->dma.nc_busaddr;\r\nhost->dma.cmdptr_busaddr = host->dma.nc_busaddr +\r\noffsetof(struct msmsdcc_nc_dmadata, cmdptr);\r\nhost->dma.channel = host->dmares->start;\r\nreturn 0;\r\n}\r\nstatic int\r\nmsmsdcc_probe(struct platform_device *pdev)\r\n{\r\nstruct msm_mmc_platform_data *plat = pdev->dev.platform_data;\r\nstruct msmsdcc_host *host;\r\nstruct mmc_host *mmc;\r\nstruct resource *cmd_irqres = NULL;\r\nstruct resource *stat_irqres = NULL;\r\nstruct resource *memres = NULL;\r\nstruct resource *dmares = NULL;\r\nint ret;\r\nif (!plat) {\r\npr_err("%s: Platform data not available\n", __func__);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (pdev->id < 1 || pdev->id > 4)\r\nreturn -EINVAL;\r\nif (pdev->resource == NULL || pdev->num_resources < 2) {\r\npr_err("%s: Invalid resource\n", __func__);\r\nreturn -ENXIO;\r\n}\r\nmemres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndmares = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\ncmd_irqres = platform_get_resource_byname(pdev, IORESOURCE_IRQ,\r\n"cmd_irq");\r\nstat_irqres = platform_get_resource_byname(pdev, IORESOURCE_IRQ,\r\n"status_irq");\r\nif (!cmd_irqres || !memres) {\r\npr_err("%s: Invalid resource\n", __func__);\r\nreturn -ENXIO;\r\n}\r\nmmc = mmc_alloc_host(sizeof(struct msmsdcc_host), &pdev->dev);\r\nif (!mmc) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nhost = mmc_priv(mmc);\r\nhost->pdev_id = pdev->id;\r\nhost->plat = plat;\r\nhost->mmc = mmc;\r\nhost->curr.cmd = NULL;\r\ninit_timer(&host->busclk_timer);\r\nhost->busclk_timer.data = (unsigned long) host;\r\nhost->busclk_timer.function = msmsdcc_busclk_expired;\r\nhost->cmdpoll = 1;\r\nhost->base = ioremap(memres->start, PAGE_SIZE);\r\nif (!host->base) {\r\nret = -ENOMEM;\r\ngoto host_free;\r\n}\r\nhost->cmd_irqres = cmd_irqres;\r\nhost->memres = memres;\r\nhost->dmares = dmares;\r\nspin_lock_init(&host->lock);\r\ntasklet_init(&host->dma_tlet, msmsdcc_dma_complete_tlet,\r\n(unsigned long)host);\r\nif (host->dmares) {\r\nret = msmsdcc_init_dma(host);\r\nif (ret)\r\ngoto ioremap_free;\r\n} else {\r\nhost->dma.channel = -1;\r\n}\r\nhost->pclk = clk_get(&pdev->dev, "sdc_pclk");\r\nif (IS_ERR(host->pclk)) {\r\nret = PTR_ERR(host->pclk);\r\ngoto dma_free;\r\n}\r\nhost->clk = clk_get(&pdev->dev, "sdc_clk");\r\nif (IS_ERR(host->clk)) {\r\nret = PTR_ERR(host->clk);\r\ngoto pclk_put;\r\n}\r\nret = clk_set_rate(host->clk, msmsdcc_fmin);\r\nif (ret) {\r\npr_err("%s: Clock rate set failed (%d)\n", __func__, ret);\r\ngoto clk_put;\r\n}\r\nret = clk_prepare(host->pclk);\r\nif (ret)\r\ngoto clk_put;\r\nret = clk_prepare(host->clk);\r\nif (ret)\r\ngoto clk_unprepare_p;\r\nret = msmsdcc_enable_clocks(host);\r\nif (ret)\r\ngoto clk_unprepare;\r\nhost->pclk_rate = clk_get_rate(host->pclk);\r\nhost->clk_rate = clk_get_rate(host->clk);\r\nmmc->ops = &msmsdcc_ops;\r\nmmc->f_min = msmsdcc_fmin;\r\nmmc->f_max = msmsdcc_fmax;\r\nmmc->ocr_avail = plat->ocr_mask;\r\nif (msmsdcc_4bit)\r\nmmc->caps |= MMC_CAP_4_BIT_DATA;\r\nif (msmsdcc_sdioirq)\r\nmmc->caps |= MMC_CAP_SDIO_IRQ;\r\nmmc->caps |= MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED;\r\nmmc->max_segs = NR_SG;\r\nmmc->max_blk_size = 4096;\r\nmmc->max_blk_count = 65536;\r\nmmc->max_req_size = 33554432;\r\nmmc->max_seg_size = mmc->max_req_size;\r\nmsmsdcc_writel(host, 0, MMCIMASK0);\r\nmsmsdcc_writel(host, 0x5e007ff, MMCICLEAR);\r\nmsmsdcc_writel(host, MCI_IRQENABLE, MMCIMASK0);\r\nhost->saved_irq0mask = MCI_IRQENABLE;\r\nmemset(&host->timer, 0, sizeof(host->timer));\r\nif (stat_irqres && !(stat_irqres->flags & IORESOURCE_DISABLED)) {\r\nunsigned long irqflags = IRQF_SHARED |\r\n(stat_irqres->flags & IRQF_TRIGGER_MASK);\r\nhost->stat_irq = stat_irqres->start;\r\nret = request_irq(host->stat_irq,\r\nmsmsdcc_platform_status_irq,\r\nirqflags,\r\nDRIVER_NAME " (slot)",\r\nhost);\r\nif (ret) {\r\npr_err("%s: Unable to get slot IRQ %d (%d)\n",\r\nmmc_hostname(mmc), host->stat_irq, ret);\r\ngoto clk_disable;\r\n}\r\n} else if (plat->register_status_notify) {\r\nplat->register_status_notify(msmsdcc_status_notify_cb, host);\r\n} else if (!plat->status)\r\npr_err("%s: No card detect facilities available\n",\r\nmmc_hostname(mmc));\r\nelse {\r\ninit_timer(&host->timer);\r\nhost->timer.data = (unsigned long)host;\r\nhost->timer.function = msmsdcc_check_status;\r\nhost->timer.expires = jiffies + HZ;\r\nadd_timer(&host->timer);\r\n}\r\nif (plat->status) {\r\nhost->oldstat = host->plat->status(mmc_dev(host->mmc));\r\nhost->eject = !host->oldstat;\r\n}\r\nret = request_irq(cmd_irqres->start, msmsdcc_irq, IRQF_SHARED,\r\nDRIVER_NAME " (cmd)", host);\r\nif (ret)\r\ngoto stat_irq_free;\r\nret = request_irq(cmd_irqres->start, msmsdcc_pio_irq, IRQF_SHARED,\r\nDRIVER_NAME " (pio)", host);\r\nif (ret)\r\ngoto cmd_irq_free;\r\nplatform_set_drvdata(pdev, mmc);\r\nmmc_add_host(mmc);\r\npr_info("%s: Qualcomm MSM SDCC at 0x%016llx irq %d,%d dma %d\n",\r\nmmc_hostname(mmc), (unsigned long long)memres->start,\r\n(unsigned int) cmd_irqres->start,\r\n(unsigned int) host->stat_irq, host->dma.channel);\r\npr_info("%s: 4 bit data mode %s\n", mmc_hostname(mmc),\r\n(mmc->caps & MMC_CAP_4_BIT_DATA ? "enabled" : "disabled"));\r\npr_info("%s: MMC clock %u -> %u Hz, PCLK %u Hz\n",\r\nmmc_hostname(mmc), msmsdcc_fmin, msmsdcc_fmax, host->pclk_rate);\r\npr_info("%s: Slot eject status = %d\n", mmc_hostname(mmc), host->eject);\r\npr_info("%s: Power save feature enable = %d\n",\r\nmmc_hostname(mmc), msmsdcc_pwrsave);\r\nif (host->dma.channel != -1) {\r\npr_info("%s: DM non-cached buffer at %p, dma_addr 0x%.8x\n",\r\nmmc_hostname(mmc), host->dma.nc, host->dma.nc_busaddr);\r\npr_info("%s: DM cmd busaddr 0x%.8x, cmdptr busaddr 0x%.8x\n",\r\nmmc_hostname(mmc), host->dma.cmd_busaddr,\r\nhost->dma.cmdptr_busaddr);\r\n} else\r\npr_info("%s: PIO transfer enabled\n", mmc_hostname(mmc));\r\nif (host->timer.function)\r\npr_info("%s: Polling status mode enabled\n", mmc_hostname(mmc));\r\nreturn 0;\r\ncmd_irq_free:\r\nfree_irq(cmd_irqres->start, host);\r\nstat_irq_free:\r\nif (host->stat_irq)\r\nfree_irq(host->stat_irq, host);\r\nclk_disable:\r\nmsmsdcc_disable_clocks(host, 0);\r\nclk_unprepare:\r\nclk_unprepare(host->clk);\r\nclk_unprepare_p:\r\nclk_unprepare(host->pclk);\r\nclk_put:\r\nclk_put(host->clk);\r\npclk_put:\r\nclk_put(host->pclk);\r\ndma_free:\r\nif (host->dmares)\r\ndma_free_coherent(NULL, sizeof(struct msmsdcc_nc_dmadata),\r\nhost->dma.nc, host->dma.nc_busaddr);\r\nioremap_free:\r\ntasklet_kill(&host->dma_tlet);\r\niounmap(host->base);\r\nhost_free:\r\nmmc_free_host(mmc);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\nmsmsdcc_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(dev);\r\nif (mmc) {\r\nstruct msmsdcc_host *host = mmc_priv(mmc);\r\nif (host->stat_irq)\r\ndisable_irq(host->stat_irq);\r\nmsmsdcc_writel(host, 0, MMCIMASK0);\r\nif (host->clks_on)\r\nmsmsdcc_disable_clocks(host, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmsmsdcc_resume(struct platform_device *dev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(dev);\r\nif (mmc) {\r\nstruct msmsdcc_host *host = mmc_priv(mmc);\r\nmsmsdcc_enable_clocks(host);\r\nmsmsdcc_writel(host, host->saved_irq0mask, MMCIMASK0);\r\nif (host->stat_irq)\r\nenable_irq(host->stat_irq);\r\n#if BUSCLK_PWRSAVE\r\nmsmsdcc_disable_clocks(host, 1);\r\n#endif\r\n}\r\nreturn 0;\r\n}
