double __floatsidf(int i)\r\n{\r\nreturn i;\r\n}\r\nunsigned int __fixunsdfsi(double d)\r\n{\r\nreturn d;\r\n}\r\ndouble __adddf3(double a, double b)\r\n{\r\nreturn a+b;\r\n}\r\ndouble __addsf3(float a, float b)\r\n{\r\nreturn a+b;\r\n}\r\ndouble __subdf3(double a, double b)\r\n{\r\nreturn a-b;\r\n}\r\ndouble __extendsfdf2(float a)\r\n{\r\nreturn a;\r\n}\r\nstatic void rtl819x_set_channel_map(u8 channel_plan, struct r8192_priv *priv)\r\n{\r\nint i, max_chan = -1, min_chan = -1;\r\nstruct ieee80211_device *ieee = priv->ieee80211;\r\nswitch (channel_plan) {\r\ncase COUNTRY_CODE_FCC:\r\ncase COUNTRY_CODE_IC:\r\ncase COUNTRY_CODE_ETSI:\r\ncase COUNTRY_CODE_SPAIN:\r\ncase COUNTRY_CODE_FRANCE:\r\ncase COUNTRY_CODE_MKK:\r\ncase COUNTRY_CODE_MKK1:\r\ncase COUNTRY_CODE_ISRAEL:\r\ncase COUNTRY_CODE_TELEC:\r\ncase COUNTRY_CODE_MIC:\r\nDot11d_Init(ieee);\r\nieee->bGlobalDomain = false;\r\nif ((priv->rf_chip == RF_8225) || (priv->rf_chip == RF_8256)) {\r\nmin_chan = 1;\r\nmax_chan = 14;\r\n} else {\r\nRT_TRACE(COMP_ERR, "unknown rf chip, can't set channel map in function:%s()\n", __func__);\r\n}\r\nif (ChannelPlan[channel_plan].Len != 0) {\r\nmemset(GET_DOT11D_INFO(ieee)->channel_map, 0, sizeof(GET_DOT11D_INFO(ieee)->channel_map));\r\nfor (i = 0; i < ChannelPlan[channel_plan].Len; i++) {\r\nif (ChannelPlan[channel_plan].Channel[i] < min_chan || ChannelPlan[channel_plan].Channel[i] > max_chan)\r\nbreak;\r\nGET_DOT11D_INFO(ieee)->channel_map[ChannelPlan[channel_plan].Channel[i]] = 1;\r\n}\r\n}\r\nbreak;\r\ncase COUNTRY_CODE_GLOBAL_DOMAIN:\r\nGET_DOT11D_INFO(ieee)->bEnabled = 0;\r\nDot11d_Reset(ieee);\r\nieee->bGlobalDomain = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void CamResetAllEntry(struct net_device *dev)\r\n{\r\nu32 ulcommand = 0;\r\nulcommand |= BIT31|BIT30;\r\nwrite_nic_dword(dev, RWCAM, ulcommand);\r\n}\r\nvoid write_cam(struct net_device *dev, u8 addr, u32 data)\r\n{\r\nwrite_nic_dword(dev, WCAMI, data);\r\nwrite_nic_dword(dev, RWCAM, BIT31|BIT16|(addr&0xff));\r\n}\r\nu32 read_cam(struct net_device *dev, u8 addr)\r\n{\r\nu32 data;\r\nwrite_nic_dword(dev, RWCAM, 0x80000000|(addr&0xff));\r\nread_nic_dword(dev, 0xa8, &data);\r\nreturn data;\r\n}\r\nvoid write_nic_byte_E(struct net_device *dev, int indx, u8 data)\r\n{\r\nint status;\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nstruct usb_device *udev = priv->udev;\r\nstatus = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nRTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,\r\nindx|0xfe00, 0, &data, 1, HZ / 2);\r\nif (status < 0)\r\nnetdev_err(dev, "write_nic_byte_E TimeOut! status: %d\n", status);\r\n}\r\nint read_nic_byte_E(struct net_device *dev, int indx, u8 *data)\r\n{\r\nint status;\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nstruct usb_device *udev = priv->udev;\r\nstatus = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nRTL8187_REQ_GET_REGS, RTL8187_REQT_READ,\r\nindx|0xfe00, 0, data, 1, HZ / 2);\r\nif (status < 0) {\r\nnetdev_err(dev, "%s failure status: %d\n", __func__, status);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nvoid write_nic_byte(struct net_device *dev, int indx, u8 data)\r\n{\r\nint status;\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nstruct usb_device *udev = priv->udev;\r\nstatus = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nRTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,\r\n(indx&0xff)|0xff00, (indx>>8)&0x0f, &data, 1, HZ / 2);\r\nif (status < 0)\r\nnetdev_err(dev, "write_nic_byte TimeOut! status: %d\n", status);\r\n}\r\nvoid write_nic_word(struct net_device *dev, int indx, u16 data)\r\n{\r\nint status;\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nstruct usb_device *udev = priv->udev;\r\nstatus = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nRTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,\r\n(indx&0xff)|0xff00, (indx>>8)&0x0f, &data, 2, HZ / 2);\r\nif (status < 0)\r\nnetdev_err(dev, "write_nic_word TimeOut! status: %d\n", status);\r\n}\r\nvoid write_nic_dword(struct net_device *dev, int indx, u32 data)\r\n{\r\nint status;\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nstruct usb_device *udev = priv->udev;\r\nstatus = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\nRTL8187_REQ_SET_REGS, RTL8187_REQT_WRITE,\r\n(indx&0xff)|0xff00, (indx>>8)&0x0f, &data, 4, HZ / 2);\r\nif (status < 0)\r\nnetdev_err(dev, "write_nic_dword TimeOut! status: %d\n", status);\r\n}\r\nint read_nic_byte(struct net_device *dev, int indx, u8 *data)\r\n{\r\nint status;\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nstruct usb_device *udev = priv->udev;\r\nstatus = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nRTL8187_REQ_GET_REGS, RTL8187_REQT_READ,\r\n(indx&0xff)|0xff00, (indx>>8)&0x0f, data, 1, HZ / 2);\r\nif (status < 0) {\r\nnetdev_err(dev, "%s failure status: %d\n", __func__, status);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nint read_nic_word(struct net_device *dev, int indx, u16 *data)\r\n{\r\nint status;\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nstruct usb_device *udev = priv->udev;\r\nstatus = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nRTL8187_REQ_GET_REGS, RTL8187_REQT_READ,\r\n(indx&0xff)|0xff00, (indx>>8)&0x0f,\r\ndata, 2, HZ / 2);\r\nif (status < 0) {\r\nnetdev_err(dev, "%s failure status: %d\n", __func__, status);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_nic_word_E(struct net_device *dev, int indx, u16 *data)\r\n{\r\nint status;\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nstruct usb_device *udev = priv->udev;\r\nstatus = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nRTL8187_REQ_GET_REGS, RTL8187_REQT_READ,\r\nindx|0xfe00, 0, data, 2, HZ / 2);\r\nif (status < 0) {\r\nnetdev_err(dev, "%s failure status: %d\n", __func__, status);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nint read_nic_dword(struct net_device *dev, int indx, u32 *data)\r\n{\r\nint status;\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nstruct usb_device *udev = priv->udev;\r\nstatus = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nRTL8187_REQ_GET_REGS, RTL8187_REQT_READ,\r\n(indx&0xff)|0xff00, (indx>>8)&0x0f,\r\ndata, 4, HZ / 2);\r\nif (status < 0) {\r\nnetdev_err(dev, "%s failure status: %d\n", __func__, status);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\ninline void force_pci_posting(struct net_device *dev)\r\n{\r\n}\r\nstatic int proc_get_stats_ap(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nstruct ieee80211_device *ieee = priv->ieee80211;\r\nstruct ieee80211_network *target;\r\nlist_for_each_entry(target, &ieee->network_list, list) {\r\nconst char *wpa = "non_WPA";\r\nif (target->wpa_ie_len > 0 || target->rsn_ie_len > 0)\r\nwpa = "WPA";\r\nseq_printf(m, "%s %s\n", target->ssid, wpa);\r\n}\r\nreturn 0;\r\n}\r\nstatic int proc_get_registers(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nint i, n, max = 0xff;\r\nu8 byte_rd;\r\nseq_puts(m, "\n####################page 0##################\n ");\r\nfor (n = 0; n <= max;) {\r\nseq_printf(m, "\nD: %2x > ", n);\r\nfor (i = 0; i < 16 && n <= max; i++, n++) {\r\nread_nic_byte(dev, 0x000|n, &byte_rd);\r\nseq_printf(m, "%2x ", byte_rd);\r\n}\r\n}\r\nseq_puts(m, "\n####################page 1##################\n ");\r\nfor (n = 0; n <= max;) {\r\nseq_printf(m, "\nD: %2x > ", n);\r\nfor (i = 0; i < 16 && n <= max; i++, n++) {\r\nread_nic_byte(dev, 0x100|n, &byte_rd);\r\nseq_printf(m, "%2x ", byte_rd);\r\n}\r\n}\r\nseq_puts(m, "\n####################page 3##################\n ");\r\nfor (n = 0; n <= max;) {\r\nseq_printf(m, "\nD: %2x > ", n);\r\nfor (i = 0; i < 16 && n <= max; i++, n++) {\r\nread_nic_byte(dev, 0x300|n, &byte_rd);\r\nseq_printf(m, "%2x ", byte_rd);\r\n}\r\n}\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic int proc_get_stats_tx(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nseq_printf(m,\r\n"TX VI priority ok int: %lu\n"\r\n"TX VI priority error int: %lu\n"\r\n"TX VO priority ok int: %lu\n"\r\n"TX VO priority error int: %lu\n"\r\n"TX BE priority ok int: %lu\n"\r\n"TX BE priority error int: %lu\n"\r\n"TX BK priority ok int: %lu\n"\r\n"TX BK priority error int: %lu\n"\r\n"TX MANAGE priority ok int: %lu\n"\r\n"TX MANAGE priority error int: %lu\n"\r\n"TX BEACON priority ok int: %lu\n"\r\n"TX BEACON priority error int: %lu\n"\r\n"TX queue resume: %lu\n"\r\n"TX queue stopped?: %d\n"\r\n"TX fifo overflow: %lu\n"\r\n"TX VI queue: %d\n"\r\n"TX VO queue: %d\n"\r\n"TX BE queue: %d\n"\r\n"TX BK queue: %d\n"\r\n"TX VI dropped: %lu\n"\r\n"TX VO dropped: %lu\n"\r\n"TX BE dropped: %lu\n"\r\n"TX BK dropped: %lu\n"\r\n"TX total data packets %lu\n",\r\npriv->stats.txviokint,\r\npriv->stats.txvierr,\r\npriv->stats.txvookint,\r\npriv->stats.txvoerr,\r\npriv->stats.txbeokint,\r\npriv->stats.txbeerr,\r\npriv->stats.txbkokint,\r\npriv->stats.txbkerr,\r\npriv->stats.txmanageokint,\r\npriv->stats.txmanageerr,\r\npriv->stats.txbeaconokint,\r\npriv->stats.txbeaconerr,\r\npriv->stats.txresumed,\r\nnetif_queue_stopped(dev),\r\npriv->stats.txoverflow,\r\natomic_read(&(priv->tx_pending[VI_PRIORITY])),\r\natomic_read(&(priv->tx_pending[VO_PRIORITY])),\r\natomic_read(&(priv->tx_pending[BE_PRIORITY])),\r\natomic_read(&(priv->tx_pending[BK_PRIORITY])),\r\npriv->stats.txvidrop,\r\npriv->stats.txvodrop,\r\npriv->stats.txbedrop,\r\npriv->stats.txbkdrop,\r\npriv->stats.txdatapkt\r\n);\r\nreturn 0;\r\n}\r\nstatic int proc_get_stats_rx(struct seq_file *m, void *v)\r\n{\r\nstruct net_device *dev = m->private;\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nseq_printf(m,\r\n"RX packets: %lu\n"\r\n"RX urb status error: %lu\n"\r\n"RX invalid urb error: %lu\n",\r\npriv->stats.rxoktotal,\r\npriv->stats.rxstaterr,\r\npriv->stats.rxurberr);\r\nreturn 0;\r\n}\r\nstatic void rtl8192_proc_module_init(void)\r\n{\r\nRT_TRACE(COMP_INIT, "Initializing proc filesystem");\r\nrtl8192_proc = proc_mkdir(RTL819xU_MODULE_NAME, init_net.proc_net);\r\n}\r\nstatic int rtl8192_proc_open(struct inode *inode, struct file *file)\r\n{\r\nstruct net_device *dev = proc_get_parent_data(inode);\r\nint (*show)(struct seq_file *, void *) = PDE_DATA(inode);\r\nreturn single_open(file, show, dev);\r\n}\r\nstatic void rtl8192_proc_init_one(struct net_device *dev)\r\n{\r\nconst struct rtl8192_proc_file *f;\r\nstruct proc_dir_entry *dir;\r\nif (rtl8192_proc) {\r\ndir = proc_mkdir_data(dev->name, 0, rtl8192_proc, dev);\r\nif (!dir) {\r\nRT_TRACE(COMP_ERR, "Unable to initialize /proc/net/rtl8192/%s\n",\r\ndev->name);\r\nreturn;\r\n}\r\nfor (f = rtl8192_proc_files; f->name[0]; f++) {\r\nif (!proc_create_data(f->name, S_IFREG | S_IRUGO, dir,\r\n&rtl8192_proc_fops, f->show)) {\r\nRT_TRACE(COMP_ERR, "Unable to initialize "\r\n"/proc/net/rtl8192/%s/%s\n",\r\ndev->name, f->name);\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nstatic void rtl8192_proc_remove_one(struct net_device *dev)\r\n{\r\nremove_proc_subtree(dev->name, rtl8192_proc);\r\n}\r\nshort check_nic_enough_desc(struct net_device *dev, int queue_index)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nint used = atomic_read(&priv->tx_pending[queue_index]);\r\nreturn (used < MAX_TX_URB);\r\n}\r\nstatic void tx_timeout(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nschedule_work(&priv->reset_wq);\r\n}\r\nvoid rtl8192_update_msr(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu8 msr;\r\nread_nic_byte(dev, MSR, &msr);\r\nmsr &= ~MSR_LINK_MASK;\r\nif (priv->ieee80211->state == IEEE80211_LINKED) {\r\nif (priv->ieee80211->iw_mode == IW_MODE_INFRA)\r\nmsr |= (MSR_LINK_MANAGED<<MSR_LINK_SHIFT);\r\nelse if (priv->ieee80211->iw_mode == IW_MODE_ADHOC)\r\nmsr |= (MSR_LINK_ADHOC<<MSR_LINK_SHIFT);\r\nelse if (priv->ieee80211->iw_mode == IW_MODE_MASTER)\r\nmsr |= (MSR_LINK_MASTER<<MSR_LINK_SHIFT);\r\n} else {\r\nmsr |= (MSR_LINK_NONE<<MSR_LINK_SHIFT);\r\n}\r\nwrite_nic_byte(dev, MSR, msr);\r\n}\r\nvoid rtl8192_set_chan(struct net_device *dev, short ch)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nRT_TRACE(COMP_CH, "=====>%s()====ch:%d\n", __func__, ch);\r\npriv->chan = ch;\r\nif (priv->rf_set_chan)\r\npriv->rf_set_chan(dev, priv->chan);\r\nmdelay(10);\r\n}\r\nstatic u32 get_rxpacket_shiftbytes_819xusb(struct ieee80211_rx_stats *pstats)\r\n{\r\nreturn (sizeof(rx_desc_819x_usb) + pstats->RxDrvInfoSize\r\n+ pstats->RxBufShift);\r\n}\r\nstatic int rtl8192_rx_initiate(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nstruct urb *entry;\r\nstruct sk_buff *skb;\r\nstruct rtl8192_rx_info *info;\r\nwhile (skb_queue_len(&priv->rx_queue) < MAX_RX_URB) {\r\nskb = __dev_alloc_skb(RX_URB_SIZE, GFP_KERNEL);\r\nif (!skb)\r\nbreak;\r\nentry = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!entry) {\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\nusb_fill_bulk_urb(entry, priv->udev,\r\nusb_rcvbulkpipe(priv->udev, 3), skb_tail_pointer(skb),\r\nRX_URB_SIZE, rtl8192_rx_isr, skb);\r\ninfo = (struct rtl8192_rx_info *) skb->cb;\r\ninfo->urb = entry;\r\ninfo->dev = dev;\r\ninfo->out_pipe = 3;\r\nskb_queue_tail(&priv->rx_queue, skb);\r\nusb_submit_urb(entry, GFP_KERNEL);\r\n}\r\nwhile (skb_queue_len(&priv->rx_queue) < MAX_RX_URB + 3) {\r\nskb = __dev_alloc_skb(RX_URB_SIZE, GFP_KERNEL);\r\nif (!skb)\r\nbreak;\r\nentry = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!entry) {\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\nusb_fill_bulk_urb(entry, priv->udev,\r\nusb_rcvbulkpipe(priv->udev, 9), skb_tail_pointer(skb),\r\nRX_URB_SIZE, rtl8192_rx_isr, skb);\r\ninfo = (struct rtl8192_rx_info *) skb->cb;\r\ninfo->urb = entry;\r\ninfo->dev = dev;\r\ninfo->out_pipe = 9;\r\nskb_queue_tail(&priv->rx_queue, skb);\r\nusb_submit_urb(entry, GFP_KERNEL);\r\n}\r\nreturn 0;\r\n}\r\nvoid rtl8192_set_rxconf(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nu32 rxconf;\r\nread_nic_dword(dev, RCR, &rxconf);\r\nrxconf = rxconf & ~MAC_FILTER_MASK;\r\nrxconf = rxconf | RCR_AMF;\r\nrxconf = rxconf | RCR_ADF;\r\nrxconf = rxconf | RCR_AB;\r\nrxconf = rxconf | RCR_AM;\r\nif (dev->flags & IFF_PROMISC)\r\nDMESG("NIC in promisc mode");\r\nif (priv->ieee80211->iw_mode == IW_MODE_MONITOR ||\r\ndev->flags & IFF_PROMISC) {\r\nrxconf = rxconf | RCR_AAP;\r\n} else {\r\nrxconf = rxconf | RCR_APM;\r\nrxconf = rxconf | RCR_CBSSID;\r\n}\r\nif (priv->ieee80211->iw_mode == IW_MODE_MONITOR) {\r\nrxconf = rxconf | RCR_AICV;\r\nrxconf = rxconf | RCR_APWRMGT;\r\n}\r\nif (priv->crcmon == 1 && priv->ieee80211->iw_mode == IW_MODE_MONITOR)\r\nrxconf = rxconf | RCR_ACRC32;\r\nrxconf = rxconf & ~RX_FIFO_THRESHOLD_MASK;\r\nrxconf = rxconf | (RX_FIFO_THRESHOLD_NONE<<RX_FIFO_THRESHOLD_SHIFT);\r\nrxconf = rxconf & ~MAX_RX_DMA_MASK;\r\nrxconf = rxconf | ((u32)7<<RCR_MXDMA_OFFSET);\r\nrxconf = rxconf | RCR_ONLYERLPKT;\r\nwrite_nic_dword(dev, RCR, rxconf);\r\n}\r\nvoid rtl8192_rx_enable(struct net_device *dev)\r\n{\r\nrtl8192_rx_initiate(dev);\r\n}\r\nvoid rtl8192_tx_enable(struct net_device *dev)\r\n{\r\n}\r\nvoid rtl8192_rtx_disable(struct net_device *dev)\r\n{\r\nu8 cmd;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nstruct sk_buff *skb;\r\nstruct rtl8192_rx_info *info;\r\nread_nic_byte(dev, CMDR, &cmd);\r\nwrite_nic_byte(dev, CMDR, cmd & ~(CR_TE|CR_RE));\r\nforce_pci_posting(dev);\r\nmdelay(10);\r\nwhile ((skb = __skb_dequeue(&priv->rx_queue))) {\r\ninfo = (struct rtl8192_rx_info *) skb->cb;\r\nif (!info->urb)\r\ncontinue;\r\nusb_kill_urb(info->urb);\r\nkfree_skb(skb);\r\n}\r\nif (skb_queue_len(&priv->skb_queue))\r\nnetdev_warn(dev, "skb_queue not empty\n");\r\nskb_queue_purge(&priv->skb_queue);\r\nreturn;\r\n}\r\ninline u16 ieeerate2rtlrate(int rate)\r\n{\r\nswitch (rate) {\r\ncase 10:\r\nreturn 0;\r\ncase 20:\r\nreturn 1;\r\ncase 55:\r\nreturn 2;\r\ncase 110:\r\nreturn 3;\r\ncase 60:\r\nreturn 4;\r\ncase 90:\r\nreturn 5;\r\ncase 120:\r\nreturn 6;\r\ncase 180:\r\nreturn 7;\r\ncase 240:\r\nreturn 8;\r\ncase 360:\r\nreturn 9;\r\ncase 480:\r\nreturn 10;\r\ncase 540:\r\nreturn 11;\r\ndefault:\r\nreturn 3;\r\n}\r\n}\r\ninline u16 rtl8192_rate2rate(short rate)\r\n{\r\nif (rate > 11)\r\nreturn 0;\r\nreturn rtl_rate[rate];\r\n}\r\nstatic void rtl8192_rx_isr(struct urb *urb)\r\n{\r\nstruct sk_buff *skb = (struct sk_buff *) urb->context;\r\nstruct rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;\r\nstruct net_device *dev = info->dev;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nint out_pipe = info->out_pipe;\r\nint err;\r\nif (!priv->up)\r\nreturn;\r\nif (unlikely(urb->status)) {\r\ninfo->urb = NULL;\r\npriv->stats.rxstaterr++;\r\npriv->ieee80211->stats.rx_errors++;\r\nusb_free_urb(urb);\r\nreturn;\r\n}\r\nskb_unlink(skb, &priv->rx_queue);\r\nskb_put(skb, urb->actual_length);\r\nskb_queue_tail(&priv->skb_queue, skb);\r\ntasklet_schedule(&priv->irq_rx_tasklet);\r\nskb = dev_alloc_skb(RX_URB_SIZE);\r\nif (unlikely(!skb)) {\r\nusb_free_urb(urb);\r\nnetdev_err(dev, "%s(): can't alloc skb\n", __func__);\r\nreturn;\r\n}\r\nusb_fill_bulk_urb(urb, priv->udev,\r\nusb_rcvbulkpipe(priv->udev, out_pipe), skb_tail_pointer(skb),\r\nRX_URB_SIZE, rtl8192_rx_isr, skb);\r\ninfo = (struct rtl8192_rx_info *) skb->cb;\r\ninfo->urb = urb;\r\ninfo->dev = dev;\r\ninfo->out_pipe = out_pipe;\r\nurb->transfer_buffer = skb_tail_pointer(skb);\r\nurb->context = skb;\r\nskb_queue_tail(&priv->rx_queue, skb);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err && err != EPERM)\r\nnetdev_err(dev, "can not submit rxurb, err is %x, URB status is %x\n", err, urb->status);\r\n}\r\nstatic u32 rtl819xusb_rx_command_packet(struct net_device *dev,\r\nstruct ieee80211_rx_stats *pstats)\r\n{\r\nu32 status;\r\nstatus = cmpk_message_handle_rx(dev, pstats);\r\nif (status)\r\nDMESG("rxcommandpackethandle819xusb: It is a command packet\n");\r\nreturn status;\r\n}\r\nstatic void rtl8192_data_hard_stop(struct net_device *dev)\r\n{\r\n}\r\nstatic void rtl8192_data_hard_resume(struct net_device *dev)\r\n{\r\n}\r\nstatic void rtl8192_hard_data_xmit(struct sk_buff *skb, struct net_device *dev, int rate)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nint ret;\r\nunsigned long flags;\r\ncb_desc *tcb_desc = (cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\r\nu8 queue_index = tcb_desc->queue_index;\r\nRTL8192U_ASSERT(queue_index != TXCMD_QUEUE);\r\nspin_lock_irqsave(&priv->tx_lock, flags);\r\nmemcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));\r\ntcb_desc->bTxEnableFwCalcDur = 1;\r\nskb_push(skb, priv->ieee80211->tx_headroom);\r\nret = rtl8192_tx(dev, skb);\r\nspin_unlock_irqrestore(&priv->tx_lock, flags);\r\nreturn;\r\n}\r\nstatic int rtl8192_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nint ret;\r\nunsigned long flags;\r\ncb_desc *tcb_desc = (cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\r\nu8 queue_index = tcb_desc->queue_index;\r\nspin_lock_irqsave(&priv->tx_lock, flags);\r\nmemcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));\r\nif (queue_index == TXCMD_QUEUE) {\r\nskb_push(skb, USB_HWDESC_HEADER_LEN);\r\nrtl819xU_tx_cmd(dev, skb);\r\nret = 1;\r\nspin_unlock_irqrestore(&priv->tx_lock, flags);\r\nreturn ret;\r\n} else {\r\nskb_push(skb, priv->ieee80211->tx_headroom);\r\nret = rtl8192_tx(dev, skb);\r\n}\r\nspin_unlock_irqrestore(&priv->tx_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void rtl8192_tx_isr(struct urb *tx_urb)\r\n{\r\nstruct sk_buff *skb = (struct sk_buff *)tx_urb->context;\r\nstruct net_device *dev = (struct net_device *)(skb->cb);\r\nstruct r8192_priv *priv = NULL;\r\ncb_desc *tcb_desc = (cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\r\nu8 queue_index = tcb_desc->queue_index;\r\npriv = ieee80211_priv(dev);\r\nif (tcb_desc->queue_index != TXCMD_QUEUE) {\r\nif (tx_urb->status == 0) {\r\ndev->trans_start = jiffies;\r\npriv->stats.txoktotal++;\r\npriv->ieee80211->LinkDetectInfo.NumTxOkInPeriod++;\r\npriv->stats.txbytesunicast += (skb->len - priv->ieee80211->tx_headroom);\r\n} else {\r\npriv->ieee80211->stats.tx_errors++;\r\n}\r\n}\r\nif (skb != NULL) {\r\ndev_kfree_skb_any(skb);\r\nusb_free_urb(tx_urb);\r\natomic_dec(&priv->tx_pending[queue_index]);\r\n}\r\nif (queue_index != BEACON_QUEUE) {\r\nif ((skb_queue_len(&priv->ieee80211->skb_waitQ[queue_index]) != 0) &&\r\n(!(priv->ieee80211->queue_stop))) {\r\nskb = skb_dequeue(&(priv->ieee80211->skb_waitQ[queue_index]));\r\nif (skb)\r\npriv->ieee80211->softmac_hard_start_xmit(skb, dev);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void rtl8192_config_rate(struct net_device *dev, u16 *rate_config)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nstruct ieee80211_network *net;\r\nu8 i = 0, basic_rate = 0;\r\nnet = &priv->ieee80211->current_network;\r\nfor (i = 0; i < net->rates_len; i++) {\r\nbasic_rate = net->rates[i]&0x7f;\r\nswitch (basic_rate) {\r\ncase MGN_1M:\r\n*rate_config |= RRSR_1M;\r\nbreak;\r\ncase MGN_2M:\r\n*rate_config |= RRSR_2M;\r\nbreak;\r\ncase MGN_5_5M:\r\n*rate_config |= RRSR_5_5M;\r\nbreak;\r\ncase MGN_11M:\r\n*rate_config |= RRSR_11M;\r\nbreak;\r\ncase MGN_6M:\r\n*rate_config |= RRSR_6M;\r\nbreak;\r\ncase MGN_9M:\r\n*rate_config |= RRSR_9M;\r\nbreak;\r\ncase MGN_12M:\r\n*rate_config |= RRSR_12M;\r\nbreak;\r\ncase MGN_18M:\r\n*rate_config |= RRSR_18M;\r\nbreak;\r\ncase MGN_24M:\r\n*rate_config |= RRSR_24M;\r\nbreak;\r\ncase MGN_36M:\r\n*rate_config |= RRSR_36M;\r\nbreak;\r\ncase MGN_48M:\r\n*rate_config |= RRSR_48M;\r\nbreak;\r\ncase MGN_54M:\r\n*rate_config |= RRSR_54M;\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < net->rates_ex_len; i++) {\r\nbasic_rate = net->rates_ex[i]&0x7f;\r\nswitch (basic_rate) {\r\ncase MGN_1M:\r\n*rate_config |= RRSR_1M;\r\nbreak;\r\ncase MGN_2M:\r\n*rate_config |= RRSR_2M;\r\nbreak;\r\ncase MGN_5_5M:\r\n*rate_config |= RRSR_5_5M;\r\nbreak;\r\ncase MGN_11M:\r\n*rate_config |= RRSR_11M;\r\nbreak;\r\ncase MGN_6M:\r\n*rate_config |= RRSR_6M;\r\nbreak;\r\ncase MGN_9M:\r\n*rate_config |= RRSR_9M;\r\nbreak;\r\ncase MGN_12M:\r\n*rate_config |= RRSR_12M;\r\nbreak;\r\ncase MGN_18M:\r\n*rate_config |= RRSR_18M;\r\nbreak;\r\ncase MGN_24M:\r\n*rate_config |= RRSR_24M;\r\nbreak;\r\ncase MGN_36M:\r\n*rate_config |= RRSR_36M;\r\nbreak;\r\ncase MGN_48M:\r\n*rate_config |= RRSR_48M;\r\nbreak;\r\ncase MGN_54M:\r\n*rate_config |= RRSR_54M;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void rtl8192_update_cap(struct net_device *dev, u16 cap)\r\n{\r\nu32 tmp = 0;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nstruct ieee80211_network *net = &priv->ieee80211->current_network;\r\npriv->short_preamble = cap & WLAN_CAPABILITY_SHORT_PREAMBLE;\r\ntmp = priv->basic_rate;\r\nif (priv->short_preamble)\r\ntmp |= BRSR_AckShortPmb;\r\nwrite_nic_dword(dev, RRSR, tmp);\r\nif (net->mode & (IEEE_G|IEEE_N_24G)) {\r\nu8 slot_time = 0;\r\nif ((cap & WLAN_CAPABILITY_SHORT_SLOT) && (!priv->ieee80211->pHTInfo->bCurrentRT2RTLongSlotTime))\r\nslot_time = SHORT_SLOT_TIME;\r\nelse\r\nslot_time = NON_SHORT_SLOT_TIME;\r\npriv->slot_time = slot_time;\r\nwrite_nic_byte(dev, SLOT_TIME, slot_time);\r\n}\r\n}\r\nstatic void rtl8192_net_update(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nstruct ieee80211_network *net;\r\nu16 BcnTimeCfg = 0, BcnCW = 6, BcnIFS = 0xf;\r\nu16 rate_config = 0;\r\nnet = &priv->ieee80211->current_network;\r\nrtl8192_config_rate(dev, &rate_config);\r\npriv->basic_rate = rate_config & 0x15f;\r\nwrite_nic_dword(dev, BSSIDR, ((u32 *)net->bssid)[0]);\r\nwrite_nic_word(dev, BSSIDR+4, ((u16 *)net->bssid)[2]);\r\nrtl8192_update_msr(dev);\r\nif (priv->ieee80211->iw_mode == IW_MODE_ADHOC) {\r\nwrite_nic_word(dev, ATIMWND, 2);\r\nwrite_nic_word(dev, BCN_DMATIME, 1023);\r\nwrite_nic_word(dev, BCN_INTERVAL, net->beacon_interval);\r\nwrite_nic_word(dev, BCN_DRV_EARLY_INT, 1);\r\nwrite_nic_byte(dev, BCN_ERR_THRESH, 100);\r\nBcnTimeCfg |= (BcnCW<<BCN_TCFG_CW_SHIFT);\r\nBcnTimeCfg |= BcnIFS<<BCN_TCFG_IFS;\r\nwrite_nic_word(dev, BCN_TCFG, BcnTimeCfg);\r\n}\r\n}\r\nvoid rtl819xusb_beacon_tx(struct net_device *dev, u16 tx_rate)\r\n{\r\n}\r\ninline u8 rtl8192_IsWirelessBMode(u16 rate)\r\n{\r\nif (((rate <= 110) && (rate != 60) && (rate != 90)) || (rate == 220))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nu16 N_DBPSOfRate(u16 DataRate)\r\n{\r\nu16 N_DBPS = 24;\r\nswitch (DataRate) {\r\ncase 60:\r\nN_DBPS = 24;\r\nbreak;\r\ncase 90:\r\nN_DBPS = 36;\r\nbreak;\r\ncase 120:\r\nN_DBPS = 48;\r\nbreak;\r\ncase 180:\r\nN_DBPS = 72;\r\nbreak;\r\ncase 240:\r\nN_DBPS = 96;\r\nbreak;\r\ncase 360:\r\nN_DBPS = 144;\r\nbreak;\r\ncase 480:\r\nN_DBPS = 192;\r\nbreak;\r\ncase 540:\r\nN_DBPS = 216;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn N_DBPS;\r\n}\r\nshort rtl819xU_tx_cmd(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nint status;\r\nstruct urb *tx_urb;\r\nunsigned int idx_pipe;\r\ntx_desc_cmd_819x_usb *pdesc = (tx_desc_cmd_819x_usb *)skb->data;\r\ncb_desc *tcb_desc = (cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\r\nu8 queue_index = tcb_desc->queue_index;\r\natomic_inc(&priv->tx_pending[queue_index]);\r\ntx_urb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!tx_urb) {\r\ndev_kfree_skb(skb);\r\nreturn -ENOMEM;\r\n}\r\nmemset(pdesc, 0, USB_HWDESC_HEADER_LEN);\r\npdesc->FirstSeg = 1;\r\npdesc->LastSeg = 1;\r\npdesc->CmdInit = tcb_desc->bCmdOrInit;\r\npdesc->TxBufferSize = tcb_desc->txbuf_size;\r\npdesc->OWN = 1;\r\npdesc->LINIP = tcb_desc->bLastIniPkt;\r\nidx_pipe = 0x04;\r\nusb_fill_bulk_urb(tx_urb, priv->udev, usb_sndbulkpipe(priv->udev, idx_pipe),\r\nskb->data, skb->len, rtl8192_tx_isr, skb);\r\nstatus = usb_submit_urb(tx_urb, GFP_ATOMIC);\r\nif (!status) {\r\nreturn 0;\r\n} else {\r\nDMESGE("Error TX CMD URB, error %d", status);\r\nreturn -1;\r\n}\r\n}\r\nstatic u8 MapHwQueueToFirmwareQueue(u8 QueueID)\r\n{\r\nu8 QueueSelect = 0x0;\r\nswitch (QueueID) {\r\ncase BE_QUEUE:\r\nQueueSelect = QSLT_BE;\r\nbreak;\r\ncase BK_QUEUE:\r\nQueueSelect = QSLT_BK;\r\nbreak;\r\ncase VO_QUEUE:\r\nQueueSelect = QSLT_VO;\r\nbreak;\r\ncase VI_QUEUE:\r\nQueueSelect = QSLT_VI;\r\nbreak;\r\ncase MGNT_QUEUE:\r\nQueueSelect = QSLT_MGNT;\r\nbreak;\r\ncase BEACON_QUEUE:\r\nQueueSelect = QSLT_BEACON;\r\nbreak;\r\ncase TXCMD_QUEUE:\r\nQueueSelect = QSLT_CMD;\r\nbreak;\r\ncase HIGH_QUEUE:\r\nQueueSelect = QSLT_HIGH;\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "TransmitTCB(): Impossible Queue Selection: %d \n", QueueID);\r\nbreak;\r\n}\r\nreturn QueueSelect;\r\n}\r\nstatic u8 MRateToHwRate8190Pci(u8 rate)\r\n{\r\nu8 ret = DESC90_RATE1M;\r\nswitch (rate) {\r\ncase MGN_1M:\r\nret = DESC90_RATE1M;\r\nbreak;\r\ncase MGN_2M:\r\nret = DESC90_RATE2M;\r\nbreak;\r\ncase MGN_5_5M:\r\nret = DESC90_RATE5_5M;\r\nbreak;\r\ncase MGN_11M:\r\nret = DESC90_RATE11M;\r\nbreak;\r\ncase MGN_6M:\r\nret = DESC90_RATE6M;\r\nbreak;\r\ncase MGN_9M:\r\nret = DESC90_RATE9M;\r\nbreak;\r\ncase MGN_12M:\r\nret = DESC90_RATE12M;\r\nbreak;\r\ncase MGN_18M:\r\nret = DESC90_RATE18M;\r\nbreak;\r\ncase MGN_24M:\r\nret = DESC90_RATE24M;\r\nbreak;\r\ncase MGN_36M:\r\nret = DESC90_RATE36M;\r\nbreak;\r\ncase MGN_48M:\r\nret = DESC90_RATE48M;\r\nbreak;\r\ncase MGN_54M:\r\nret = DESC90_RATE54M;\r\nbreak;\r\ncase MGN_MCS0:\r\nret = DESC90_RATEMCS0;\r\nbreak;\r\ncase MGN_MCS1:\r\nret = DESC90_RATEMCS1;\r\nbreak;\r\ncase MGN_MCS2:\r\nret = DESC90_RATEMCS2;\r\nbreak;\r\ncase MGN_MCS3:\r\nret = DESC90_RATEMCS3;\r\nbreak;\r\ncase MGN_MCS4:\r\nret = DESC90_RATEMCS4;\r\nbreak;\r\ncase MGN_MCS5:\r\nret = DESC90_RATEMCS5;\r\nbreak;\r\ncase MGN_MCS6:\r\nret = DESC90_RATEMCS6;\r\nbreak;\r\ncase MGN_MCS7:\r\nret = DESC90_RATEMCS7;\r\nbreak;\r\ncase MGN_MCS8:\r\nret = DESC90_RATEMCS8;\r\nbreak;\r\ncase MGN_MCS9:\r\nret = DESC90_RATEMCS9;\r\nbreak;\r\ncase MGN_MCS10:\r\nret = DESC90_RATEMCS10;\r\nbreak;\r\ncase MGN_MCS11:\r\nret = DESC90_RATEMCS11;\r\nbreak;\r\ncase MGN_MCS12:\r\nret = DESC90_RATEMCS12;\r\nbreak;\r\ncase MGN_MCS13:\r\nret = DESC90_RATEMCS13;\r\nbreak;\r\ncase MGN_MCS14:\r\nret = DESC90_RATEMCS14;\r\nbreak;\r\ncase MGN_MCS15:\r\nret = DESC90_RATEMCS15;\r\nbreak;\r\ncase (0x80|0x20):\r\nret = DESC90_RATEMCS32;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic u8 QueryIsShort(u8 TxHT, u8 TxRate, cb_desc *tcb_desc)\r\n{\r\nu8 tmp_Short;\r\ntmp_Short = (TxHT == 1) ? ((tcb_desc->bUseShortGI) ? 1 : 0) : ((tcb_desc->bUseShortPreamble) ? 1 : 0);\r\nif (TxHT == 1 && TxRate != DESC90_RATEMCS15)\r\ntmp_Short = 0;\r\nreturn tmp_Short;\r\n}\r\nstatic void tx_zero_isr(struct urb *tx_urb)\r\n{\r\nreturn;\r\n}\r\nshort rtl8192_tx(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\ncb_desc *tcb_desc = (cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\r\ntx_desc_819x_usb *tx_desc = (tx_desc_819x_usb *)skb->data;\r\ntx_fwinfo_819x_usb *tx_fwinfo = (tx_fwinfo_819x_usb *)(skb->data + USB_HWDESC_HEADER_LEN);\r\nstruct usb_device *udev = priv->udev;\r\nint pend;\r\nint status;\r\nstruct urb *tx_urb = NULL, *tx_urb_zero = NULL;\r\nunsigned int idx_pipe;\r\npend = atomic_read(&priv->tx_pending[tcb_desc->queue_index]);\r\nif (pend > MAX_TX_URB) {\r\nnetdev_dbg(dev, "To discard skb packet!\n");\r\ndev_kfree_skb_any(skb);\r\nreturn -1;\r\n}\r\ntx_urb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!tx_urb) {\r\ndev_kfree_skb_any(skb);\r\nreturn -ENOMEM;\r\n}\r\nmemset(tx_fwinfo, 0, sizeof(tx_fwinfo_819x_usb));\r\ntx_fwinfo->TxHT = (tcb_desc->data_rate&0x80) ? 1 : 0;\r\ntx_fwinfo->TxRate = MRateToHwRate8190Pci(tcb_desc->data_rate);\r\ntx_fwinfo->EnableCPUDur = tcb_desc->bTxEnableFwCalcDur;\r\ntx_fwinfo->Short = QueryIsShort(tx_fwinfo->TxHT, tx_fwinfo->TxRate, tcb_desc);\r\nif (tcb_desc->bAMPDUEnable) {\r\ntx_fwinfo->AllowAggregation = 1;\r\ntx_fwinfo->RxMF = tcb_desc->ampdu_factor;\r\ntx_fwinfo->RxAMD = tcb_desc->ampdu_density&0x07;\r\n} else {\r\ntx_fwinfo->AllowAggregation = 0;\r\ntx_fwinfo->RxMF = 0;\r\ntx_fwinfo->RxAMD = 0;\r\n}\r\ntx_fwinfo->RtsEnable = (tcb_desc->bRTSEnable) ? 1 : 0;\r\ntx_fwinfo->CtsEnable = (tcb_desc->bCTSEnable) ? 1 : 0;\r\ntx_fwinfo->RtsSTBC = (tcb_desc->bRTSSTBC) ? 1 : 0;\r\ntx_fwinfo->RtsHT = (tcb_desc->rts_rate&0x80) ? 1 : 0;\r\ntx_fwinfo->RtsRate = MRateToHwRate8190Pci((u8)tcb_desc->rts_rate);\r\ntx_fwinfo->RtsSubcarrier = (tx_fwinfo->RtsHT == 0) ? (tcb_desc->RTSSC) : 0;\r\ntx_fwinfo->RtsBandwidth = (tx_fwinfo->RtsHT == 1) ? ((tcb_desc->bRTSBW) ? 1 : 0) : 0;\r\ntx_fwinfo->RtsShort = (tx_fwinfo->RtsHT == 0) ? (tcb_desc->bRTSUseShortPreamble ? 1 : 0) :\r\n(tcb_desc->bRTSUseShortGI ? 1 : 0);\r\nif (priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20_40) {\r\nif (tcb_desc->bPacketBW) {\r\ntx_fwinfo->TxBandwidth = 1;\r\ntx_fwinfo->TxSubCarrier = 0;\r\n} else {\r\ntx_fwinfo->TxBandwidth = 0;\r\ntx_fwinfo->TxSubCarrier = priv->nCur40MhzPrimeSC;\r\n}\r\n} else {\r\ntx_fwinfo->TxBandwidth = 0;\r\ntx_fwinfo->TxSubCarrier = 0;\r\n}\r\nmemset(tx_desc, 0, sizeof(tx_desc_819x_usb));\r\ntx_desc->LINIP = 0;\r\ntx_desc->CmdInit = 1;\r\ntx_desc->Offset = sizeof(tx_fwinfo_819x_usb) + 8;\r\ntx_desc->PktSize = (skb->len - TX_PACKET_SHIFT_BYTES) & 0xffff;\r\ntx_desc->SecCAMID = 0;\r\ntx_desc->RATid = tcb_desc->RATRIndex;\r\ntx_desc->NoEnc = 1;\r\ntx_desc->SecType = 0x0;\r\nif (tcb_desc->bHwSec) {\r\nswitch (priv->ieee80211->pairwise_key_type) {\r\ncase KEY_TYPE_WEP40:\r\ncase KEY_TYPE_WEP104:\r\ntx_desc->SecType = 0x1;\r\ntx_desc->NoEnc = 0;\r\nbreak;\r\ncase KEY_TYPE_TKIP:\r\ntx_desc->SecType = 0x2;\r\ntx_desc->NoEnc = 0;\r\nbreak;\r\ncase KEY_TYPE_CCMP:\r\ntx_desc->SecType = 0x3;\r\ntx_desc->NoEnc = 0;\r\nbreak;\r\ncase KEY_TYPE_NA:\r\ntx_desc->SecType = 0x0;\r\ntx_desc->NoEnc = 1;\r\nbreak;\r\n}\r\n}\r\ntx_desc->QueueSelect = MapHwQueueToFirmwareQueue(tcb_desc->queue_index);\r\ntx_desc->TxFWInfoSize = sizeof(tx_fwinfo_819x_usb);\r\ntx_desc->DISFB = tcb_desc->bTxDisableRateFallBack;\r\ntx_desc->USERATE = tcb_desc->bTxUseDriverAssingedRate;\r\ntx_desc->FirstSeg = 1;\r\ntx_desc->LastSeg = 1;\r\ntx_desc->OWN = 1;\r\ntx_desc->TxBufferSize = (u32)(skb->len - USB_HWDESC_HEADER_LEN);\r\nidx_pipe = 0x5;\r\nusb_fill_bulk_urb(tx_urb, udev,\r\nusb_sndbulkpipe(udev, idx_pipe), skb->data,\r\nskb->len, rtl8192_tx_isr, skb);\r\nstatus = usb_submit_urb(tx_urb, GFP_ATOMIC);\r\nif (!status) {\r\nbool bSend0Byte = false;\r\nu8 zero = 0;\r\nif (udev->speed == USB_SPEED_HIGH) {\r\nif (skb->len > 0 && skb->len % 512 == 0)\r\nbSend0Byte = true;\r\n} else {\r\nif (skb->len > 0 && skb->len % 64 == 0)\r\nbSend0Byte = true;\r\n}\r\nif (bSend0Byte) {\r\ntx_urb_zero = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!tx_urb_zero) {\r\nRT_TRACE(COMP_ERR, "can't alloc urb for zero byte\n");\r\nreturn -ENOMEM;\r\n}\r\nusb_fill_bulk_urb(tx_urb_zero, udev,\r\nusb_sndbulkpipe(udev, idx_pipe), &zero,\r\n0, tx_zero_isr, dev);\r\nstatus = usb_submit_urb(tx_urb_zero, GFP_ATOMIC);\r\nif (status) {\r\nRT_TRACE(COMP_ERR, "Error TX URB for zero byte %d, error %d", atomic_read(&priv->tx_pending[tcb_desc->queue_index]), status);\r\nreturn -1;\r\n}\r\n}\r\ndev->trans_start = jiffies;\r\natomic_inc(&priv->tx_pending[tcb_desc->queue_index]);\r\nreturn 0;\r\n} else {\r\nRT_TRACE(COMP_ERR, "Error TX URB %d, error %d", atomic_read(&priv->tx_pending[tcb_desc->queue_index]),\r\nstatus);\r\nreturn -1;\r\n}\r\n}\r\nstatic short rtl8192_usb_initendpoints(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\npriv->rx_urb = kmalloc(sizeof(struct urb *) * (MAX_RX_URB+1),\r\nGFP_KERNEL);\r\nif (priv->rx_urb == NULL)\r\nreturn -ENOMEM;\r\n#ifndef JACKSON_NEW_RX\r\nfor (i = 0; i < (MAX_RX_URB+1); i++) {\r\npriv->rx_urb[i] = usb_alloc_urb(0, GFP_KERNEL);\r\npriv->rx_urb[i]->transfer_buffer = kmalloc(RX_URB_SIZE, GFP_KERNEL);\r\npriv->rx_urb[i]->transfer_buffer_length = RX_URB_SIZE;\r\n}\r\n#endif\r\n#ifdef THOMAS_BEACON\r\n{\r\nlong align = 0;\r\nvoid *oldaddr, *newaddr;\r\npriv->rx_urb[16] = usb_alloc_urb(0, GFP_KERNEL);\r\npriv->oldaddr = kmalloc(16, GFP_KERNEL);\r\noldaddr = priv->oldaddr;\r\nalign = ((long)oldaddr) & 3;\r\nif (align) {\r\nnewaddr = oldaddr + 4 - align;\r\npriv->rx_urb[16]->transfer_buffer_length = 16 - 4 + align;\r\n} else {\r\nnewaddr = oldaddr;\r\npriv->rx_urb[16]->transfer_buffer_length = 16;\r\n}\r\npriv->rx_urb[16]->transfer_buffer = newaddr;\r\n}\r\n#endif\r\nmemset(priv->rx_urb, 0, sizeof(struct urb *) * MAX_RX_URB);\r\npriv->pp_rxskb = kcalloc(MAX_RX_URB, sizeof(struct sk_buff *),\r\nGFP_KERNEL);\r\nif (!priv->pp_rxskb) {\r\nkfree(priv->rx_urb);\r\npriv->pp_rxskb = NULL;\r\npriv->rx_urb = NULL;\r\nDMESGE("Endpoint Alloc Failure");\r\nreturn -ENOMEM;\r\n}\r\nnetdev_dbg(dev, "End of initendpoints\n");\r\nreturn 0;\r\n}\r\nstatic void rtl8192_usb_deleteendpoints(struct net_device *dev)\r\n{\r\nint i;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (priv->rx_urb) {\r\nfor (i = 0; i < (MAX_RX_URB+1); i++) {\r\nusb_kill_urb(priv->rx_urb[i]);\r\nusb_free_urb(priv->rx_urb[i]);\r\n}\r\nkfree(priv->rx_urb);\r\npriv->rx_urb = NULL;\r\n}\r\nkfree(priv->oldaddr);\r\npriv->oldaddr = NULL;\r\nif (priv->pp_rxskb) {\r\nkfree(priv->pp_rxskb);\r\npriv->pp_rxskb = NULL;\r\n}\r\n}\r\nvoid rtl8192_usb_deleteendpoints(struct net_device *dev)\r\n{\r\nint i;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\n#ifndef JACKSON_NEW_RX\r\nif (priv->rx_urb) {\r\nfor (i = 0; i < (MAX_RX_URB+1); i++) {\r\nusb_kill_urb(priv->rx_urb[i]);\r\nkfree(priv->rx_urb[i]->transfer_buffer);\r\nusb_free_urb(priv->rx_urb[i]);\r\n}\r\nkfree(priv->rx_urb);\r\npriv->rx_urb = NULL;\r\n}\r\n#else\r\nkfree(priv->rx_urb);\r\npriv->rx_urb = NULL;\r\nkfree(priv->oldaddr);\r\npriv->oldaddr = NULL;\r\nif (priv->pp_rxskb) {\r\nkfree(priv->pp_rxskb);\r\npriv->pp_rxskb = 0;\r\n}\r\n#endif\r\n}\r\nstatic void rtl8192_link_change(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nstruct ieee80211_device *ieee = priv->ieee80211;\r\nif (ieee->state == IEEE80211_LINKED) {\r\nrtl8192_net_update(dev);\r\nrtl8192_update_ratr_table(dev);\r\nif ((KEY_TYPE_WEP40 == ieee->pairwise_key_type) || (KEY_TYPE_WEP104 == ieee->pairwise_key_type))\r\nEnableHWSecurityConfig8192(dev);\r\n}\r\nif (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC) {\r\nu32 reg = 0;\r\nread_nic_dword(dev, RCR, &reg);\r\nif (priv->ieee80211->state == IEEE80211_LINKED)\r\npriv->ReceiveConfig = reg |= RCR_CBSSID;\r\nelse\r\npriv->ReceiveConfig = reg &= ~RCR_CBSSID;\r\nwrite_nic_dword(dev, RCR, reg);\r\n}\r\n}\r\nstatic void rtl8192_update_beacon(struct work_struct *work)\r\n{\r\nstruct r8192_priv *priv = container_of(work, struct r8192_priv, update_beacon_wq.work);\r\nstruct net_device *dev = priv->ieee80211->dev;\r\nstruct ieee80211_device *ieee = priv->ieee80211;\r\nstruct ieee80211_network *net = &ieee->current_network;\r\nif (ieee->pHTInfo->bCurrentHTSupport)\r\nHTUpdateSelfAndPeerSetting(ieee, net);\r\nieee->pHTInfo->bCurrentRT2RTLongSlotTime = net->bssht.bdRT2RTLongSlotTime;\r\nrtl8192_update_cap(dev, net->capability);\r\n}\r\nstatic void rtl8192_qos_activate(struct work_struct *work)\r\n{\r\nstruct r8192_priv *priv = container_of(work, struct r8192_priv, qos_activate);\r\nstruct net_device *dev = priv->ieee80211->dev;\r\nstruct ieee80211_qos_parameters *qos_parameters = &priv->ieee80211->current_network.qos_data.parameters;\r\nu8 mode = priv->ieee80211->current_network.mode;\r\nu32 u1bAIFS;\r\nu32 u4bAcParam;\r\nu32 op_limit;\r\nu32 cw_max;\r\nu32 cw_min;\r\nint i;\r\nmutex_lock(&priv->mutex);\r\nif (priv->ieee80211->state != IEEE80211_LINKED)\r\ngoto success;\r\nRT_TRACE(COMP_QOS, "qos active process with associate response received\n");\r\nfor (i = 0; i < QOS_QUEUE_NUM; i++) {\r\nu1bAIFS = qos_parameters->aifs[i] * ((mode&(IEEE_G|IEEE_N_24G)) ? 9 : 20) + aSifsTime;\r\nu1bAIFS <<= AC_PARAM_AIFS_OFFSET;\r\nop_limit = (u32)le16_to_cpu(qos_parameters->tx_op_limit[i]);\r\nop_limit <<= AC_PARAM_TXOP_LIMIT_OFFSET;\r\ncw_max = (u32)le16_to_cpu(qos_parameters->cw_max[i]);\r\ncw_max <<= AC_PARAM_ECW_MAX_OFFSET;\r\ncw_min = (u32)le16_to_cpu(qos_parameters->cw_min[i]);\r\ncw_min <<= AC_PARAM_ECW_MIN_OFFSET;\r\nu4bAcParam = op_limit | cw_max | cw_min | u1bAIFS;\r\nwrite_nic_dword(dev, WDCAPARA_ADD[i], u4bAcParam);\r\n}\r\nsuccess:\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int rtl8192_qos_handle_probe_response(struct r8192_priv *priv,\r\nint active_network,\r\nstruct ieee80211_network *network)\r\n{\r\nint ret = 0;\r\nu32 size = sizeof(struct ieee80211_qos_parameters);\r\nif (priv->ieee80211->state != IEEE80211_LINKED)\r\nreturn ret;\r\nif ((priv->ieee80211->iw_mode != IW_MODE_INFRA))\r\nreturn ret;\r\nif (network->flags & NETWORK_HAS_QOS_MASK) {\r\nif (active_network &&\r\n(network->flags & NETWORK_HAS_QOS_PARAMETERS))\r\nnetwork->qos_data.active = network->qos_data.supported;\r\nif ((network->qos_data.active == 1) && (active_network == 1) &&\r\n(network->flags & NETWORK_HAS_QOS_PARAMETERS) &&\r\n(network->qos_data.old_param_count !=\r\nnetwork->qos_data.param_count)) {\r\nnetwork->qos_data.old_param_count =\r\nnetwork->qos_data.param_count;\r\nqueue_work(priv->priv_wq, &priv->qos_activate);\r\nRT_TRACE(COMP_QOS, "QoS parameters change call "\r\n"qos_activate\n");\r\n}\r\n} else {\r\nmemcpy(&priv->ieee80211->current_network.qos_data.parameters,\r\n&def_qos_parameters, size);\r\nif ((network->qos_data.active == 1) && (active_network == 1)) {\r\nqueue_work(priv->priv_wq, &priv->qos_activate);\r\nRT_TRACE(COMP_QOS, "QoS was disabled call qos_activate \n");\r\n}\r\nnetwork->qos_data.active = 0;\r\nnetwork->qos_data.supported = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl8192_handle_beacon(struct net_device *dev,\r\nstruct ieee80211_beacon *beacon,\r\nstruct ieee80211_network *network)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nrtl8192_qos_handle_probe_response(priv, 1, network);\r\nqueue_delayed_work(priv->priv_wq, &priv->update_beacon_wq, 0);\r\nreturn 0;\r\n}\r\nstatic int rtl8192_qos_association_resp(struct r8192_priv *priv,\r\nstruct ieee80211_network *network)\r\n{\r\nunsigned long flags;\r\nu32 size = sizeof(struct ieee80211_qos_parameters);\r\nint set_qos_param = 0;\r\nif ((priv == NULL) || (network == NULL))\r\nreturn 0;\r\nif (priv->ieee80211->state != IEEE80211_LINKED)\r\nreturn 0;\r\nif ((priv->ieee80211->iw_mode != IW_MODE_INFRA))\r\nreturn 0;\r\nspin_lock_irqsave(&priv->ieee80211->lock, flags);\r\nif (network->flags & NETWORK_HAS_QOS_PARAMETERS) {\r\nmemcpy(&priv->ieee80211->current_network.qos_data.parameters,\r\n&network->qos_data.parameters,\r\nsizeof(struct ieee80211_qos_parameters));\r\npriv->ieee80211->current_network.qos_data.active = 1;\r\nset_qos_param = 1;\r\npriv->ieee80211->current_network.qos_data.old_param_count =\r\npriv->ieee80211->current_network.qos_data.param_count;\r\npriv->ieee80211->current_network.qos_data.param_count =\r\nnetwork->qos_data.param_count;\r\n} else {\r\nmemcpy(&priv->ieee80211->current_network.qos_data.parameters,\r\n&def_qos_parameters, size);\r\npriv->ieee80211->current_network.qos_data.active = 0;\r\npriv->ieee80211->current_network.qos_data.supported = 0;\r\nset_qos_param = 1;\r\n}\r\nspin_unlock_irqrestore(&priv->ieee80211->lock, flags);\r\nRT_TRACE(COMP_QOS, "%s: network->flags = %d,%d\n", __func__, network->flags, priv->ieee80211->current_network.qos_data.active);\r\nif (set_qos_param == 1)\r\nqueue_work(priv->priv_wq, &priv->qos_activate);\r\nreturn 0;\r\n}\r\nstatic int rtl8192_handle_assoc_response(struct net_device *dev,\r\nstruct ieee80211_assoc_response_frame *resp,\r\nstruct ieee80211_network *network)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nrtl8192_qos_association_resp(priv, network);\r\nreturn 0;\r\n}\r\nvoid rtl8192_update_ratr_table(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nstruct ieee80211_device *ieee = priv->ieee80211;\r\nu8 *pMcsRate = ieee->dot11HTOperationalRateSet;\r\nu32 ratr_value = 0;\r\nu8 rate_index = 0;\r\nrtl8192_config_rate(dev, (u16 *)(&ratr_value));\r\nratr_value |= (*(u16 *)(pMcsRate)) << 12;\r\nswitch (ieee->mode) {\r\ncase IEEE_A:\r\nratr_value &= 0x00000FF0;\r\nbreak;\r\ncase IEEE_B:\r\nratr_value &= 0x0000000F;\r\nbreak;\r\ncase IEEE_G:\r\nratr_value &= 0x00000FF7;\r\nbreak;\r\ncase IEEE_N_24G:\r\ncase IEEE_N_5G:\r\nif (ieee->pHTInfo->PeerMimoPs == 0) {\r\nratr_value &= 0x0007F007;\r\n} else {\r\nif (priv->rf_type == RF_1T2R)\r\nratr_value &= 0x000FF007;\r\nelse\r\nratr_value &= 0x0F81F007;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nratr_value &= 0x0FFFFFFF;\r\nif (ieee->pHTInfo->bCurTxBW40MHz && ieee->pHTInfo->bCurShortGI40MHz)\r\nratr_value |= 0x80000000;\r\nelse if (!ieee->pHTInfo->bCurTxBW40MHz && ieee->pHTInfo->bCurShortGI20MHz)\r\nratr_value |= 0x80000000;\r\nwrite_nic_dword(dev, RATR0+rate_index*4, ratr_value);\r\nwrite_nic_byte(dev, UFWP, 1);\r\n}\r\nstatic bool GetNmodeSupportBySecCfg8192(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nstruct ieee80211_device *ieee = priv->ieee80211;\r\nstruct ieee80211_network *network = &ieee->current_network;\r\nint wpa_ie_len = ieee->wpa_ie_len;\r\nstruct ieee80211_crypt_data *crypt;\r\nint encrypt;\r\ncrypt = ieee->crypt[ieee->tx_keyidx];\r\nencrypt = (network->capability & WLAN_CAPABILITY_PRIVACY) || (ieee->host_encrypt && crypt && crypt->ops && (0 == strcmp(crypt->ops->name, "WEP")));\r\nif (encrypt && (wpa_ie_len == 0)) {\r\nreturn false;\r\n} else if ((wpa_ie_len != 0)) {\r\nif (((ieee->wpa_ie[0] == 0xdd) && (!memcmp(&(ieee->wpa_ie[14]), ccmp_ie, 4))) || ((ieee->wpa_ie[0] == 0x30) && (!memcmp(&ieee->wpa_ie[10], ccmp_rsn_ie, 4))))\r\nreturn true;\r\nelse\r\nreturn false;\r\n} else {\r\nreturn true;\r\n}\r\nreturn true;\r\n}\r\nstatic bool GetHalfNmodeSupportByAPs819xUsb(struct net_device *dev)\r\n{\r\nbool Reval;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nstruct ieee80211_device *ieee = priv->ieee80211;\r\nif (ieee->bHalfWirelessN24GMode == true)\r\nReval = true;\r\nelse\r\nReval = false;\r\nreturn Reval;\r\n}\r\nstatic void rtl8192_refresh_supportrate(struct r8192_priv *priv)\r\n{\r\nstruct ieee80211_device *ieee = priv->ieee80211;\r\nif (ieee->mode == WIRELESS_MODE_N_24G || ieee->mode == WIRELESS_MODE_N_5G)\r\nmemcpy(ieee->Regdot11HTOperationalRateSet, ieee->RegHTSuppRateSet, 16);\r\nelse\r\nmemset(ieee->Regdot11HTOperationalRateSet, 0, 16);\r\nreturn;\r\n}\r\nstatic u8 rtl8192_getSupportedWireleeMode(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu8 ret = 0;\r\nswitch (priv->rf_chip) {\r\ncase RF_8225:\r\ncase RF_8256:\r\ncase RF_PSEUDO_11N:\r\nret = (WIRELESS_MODE_N_24G|WIRELESS_MODE_G|WIRELESS_MODE_B);\r\nbreak;\r\ncase RF_8258:\r\nret = (WIRELESS_MODE_A|WIRELESS_MODE_N_5G);\r\nbreak;\r\ndefault:\r\nret = WIRELESS_MODE_B;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void rtl8192_SetWirelessMode(struct net_device *dev, u8 wireless_mode)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu8 bSupportMode = rtl8192_getSupportedWireleeMode(dev);\r\nif ((wireless_mode == WIRELESS_MODE_AUTO) || ((wireless_mode&bSupportMode) == 0)) {\r\nif (bSupportMode & WIRELESS_MODE_N_24G) {\r\nwireless_mode = WIRELESS_MODE_N_24G;\r\n} else if (bSupportMode & WIRELESS_MODE_N_5G) {\r\nwireless_mode = WIRELESS_MODE_N_5G;\r\n} else if ((bSupportMode & WIRELESS_MODE_A)) {\r\nwireless_mode = WIRELESS_MODE_A;\r\n} else if ((bSupportMode & WIRELESS_MODE_G)) {\r\nwireless_mode = WIRELESS_MODE_G;\r\n} else if ((bSupportMode & WIRELESS_MODE_B)) {\r\nwireless_mode = WIRELESS_MODE_B;\r\n} else {\r\nRT_TRACE(COMP_ERR, "%s(), No valid wireless mode supported, SupportedWirelessMode(%x)!!!\n", __func__, bSupportMode);\r\nwireless_mode = WIRELESS_MODE_B;\r\n}\r\n}\r\n#ifdef TO_DO_LIST\r\nActUpdateChannelAccessSetting(pAdapter, pHalData->CurrentWirelessMode, &pAdapter->MgntInfo.Info8185.ChannelAccessSetting);\r\n#endif\r\npriv->ieee80211->mode = wireless_mode;\r\nif ((wireless_mode == WIRELESS_MODE_N_24G) || (wireless_mode == WIRELESS_MODE_N_5G))\r\npriv->ieee80211->pHTInfo->bEnableHT = 1;\r\nelse\r\npriv->ieee80211->pHTInfo->bEnableHT = 0;\r\nRT_TRACE(COMP_INIT, "Current Wireless Mode is %x\n", wireless_mode);\r\nrtl8192_refresh_supportrate(priv);\r\n}\r\nstatic void rtl8192_init_priv_variable(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu8 i;\r\npriv->card_8192 = NIC_8192U;\r\npriv->chan = 1;\r\npriv->ieee80211->mode = WIRELESS_MODE_AUTO;\r\npriv->ieee80211->iw_mode = IW_MODE_INFRA;\r\npriv->ieee80211->ieee_up = 0;\r\npriv->retry_rts = DEFAULT_RETRY_RTS;\r\npriv->retry_data = DEFAULT_RETRY_DATA;\r\npriv->ieee80211->rts = DEFAULT_RTS_THRESHOLD;\r\npriv->ieee80211->rate = 110;\r\npriv->ieee80211->short_slot = 1;\r\npriv->promisc = (dev->flags & IFF_PROMISC) ? 1 : 0;\r\npriv->CckPwEnl = 6;\r\npriv->IrpPendingCount = 1;\r\npriv->ResetProgress = RESET_TYPE_NORESET;\r\npriv->bForcedSilentReset = 0;\r\npriv->bDisableNormalResetCheck = false;\r\npriv->force_reset = false;\r\npriv->ieee80211->FwRWRF = 0;\r\npriv->ieee80211->current_network.beacon_interval = DEFAULT_BEACONINTERVAL;\r\npriv->ieee80211->softmac_features = IEEE_SOFTMAC_SCAN |\r\nIEEE_SOFTMAC_ASSOCIATE | IEEE_SOFTMAC_PROBERQ |\r\nIEEE_SOFTMAC_PROBERS | IEEE_SOFTMAC_TX_QUEUE |\r\nIEEE_SOFTMAC_BEACONS;\r\npriv->ieee80211->active_scan = 1;\r\npriv->ieee80211->modulation = IEEE80211_CCK_MODULATION | IEEE80211_OFDM_MODULATION;\r\npriv->ieee80211->host_encrypt = 1;\r\npriv->ieee80211->host_decrypt = 1;\r\npriv->ieee80211->start_send_beacons = NULL;\r\npriv->ieee80211->stop_send_beacons = NULL;\r\npriv->ieee80211->softmac_hard_start_xmit = rtl8192_hard_start_xmit;\r\npriv->ieee80211->set_chan = rtl8192_set_chan;\r\npriv->ieee80211->link_change = rtl8192_link_change;\r\npriv->ieee80211->softmac_data_hard_start_xmit = rtl8192_hard_data_xmit;\r\npriv->ieee80211->data_hard_stop = rtl8192_data_hard_stop;\r\npriv->ieee80211->data_hard_resume = rtl8192_data_hard_resume;\r\npriv->ieee80211->init_wmmparam_flag = 0;\r\npriv->ieee80211->fts = DEFAULT_FRAG_THRESHOLD;\r\npriv->ieee80211->check_nic_enough_desc = check_nic_enough_desc;\r\npriv->ieee80211->tx_headroom = TX_PACKET_SHIFT_BYTES;\r\npriv->ieee80211->qos_support = 1;\r\npriv->ieee80211->SetBWModeHandler = rtl8192_SetBWMode;\r\npriv->ieee80211->handle_assoc_response = rtl8192_handle_assoc_response;\r\npriv->ieee80211->handle_beacon = rtl8192_handle_beacon;\r\npriv->ieee80211->GetNmodeSupportBySecCfg = GetNmodeSupportBySecCfg8192;\r\npriv->ieee80211->GetHalfNmodeSupportByAPsHandler = GetHalfNmodeSupportByAPs819xUsb;\r\npriv->ieee80211->SetWirelessMode = rtl8192_SetWirelessMode;\r\npriv->ieee80211->InitialGainHandler = InitialGain819xUsb;\r\npriv->card_type = USB;\r\n#ifdef TO_DO_LIST\r\nif (Adapter->bInHctTest) {\r\npHalData->ShortRetryLimit = 7;\r\npHalData->LongRetryLimit = 7;\r\n}\r\n#endif\r\npriv->ShortRetryLimit = 0x30;\r\npriv->LongRetryLimit = 0x30;\r\npriv->EarlyRxThreshold = 7;\r\npriv->enable_gpio0 = 0;\r\npriv->TransmitConfig =\r\n(TCR_MXDMA_2048<<TCR_MXDMA_OFFSET)|\r\n(priv->ShortRetryLimit<<TCR_SRL_OFFSET)|\r\n(priv->LongRetryLimit<<TCR_LRL_OFFSET) |\r\n(false ? TCR_SAT : 0);\r\n#ifdef TO_DO_LIST\r\nif (Adapter->bInHctTest)\r\npHalData->ReceiveConfig = pHalData->CSMethod |\r\nRCR_AMF | RCR_ADF |\r\nRCR_ACF |\r\nRCR_AB | RCR_AM | RCR_APM |\r\nRCR_AICV | RCR_ACRC32 |\r\n((u32)7<<RCR_MXDMA_OFFSET) |\r\n(pHalData->EarlyRxThreshold<<RCR_FIFO_OFFSET) |\r\n(pHalData->EarlyRxThreshold == 7 ? RCR_OnlyErlPkt : 0);\r\nelse\r\n#endif\r\npriv->ReceiveConfig =\r\nRCR_AMF | RCR_ADF |\r\nRCR_ACF |\r\nRCR_AB | RCR_AM | RCR_APM |\r\n((u32)7<<RCR_MXDMA_OFFSET)|\r\n(priv->EarlyRxThreshold<<RX_FIFO_THRESHOLD_SHIFT) |\r\n(priv->EarlyRxThreshold == 7 ? RCR_ONLYERLPKT : 0);\r\npriv->AcmControl = 0;\r\npriv->pFirmware = kzalloc(sizeof(rt_firmware), GFP_KERNEL);\r\nskb_queue_head_init(&priv->rx_queue);\r\nskb_queue_head_init(&priv->skb_queue);\r\nfor (i = 0; i < MAX_QUEUE_SIZE; i++)\r\nskb_queue_head_init(&priv->ieee80211->skb_waitQ[i]);\r\nfor (i = 0; i < MAX_QUEUE_SIZE; i++)\r\nskb_queue_head_init(&priv->ieee80211->skb_aggQ[i]);\r\nfor (i = 0; i < MAX_QUEUE_SIZE; i++)\r\nskb_queue_head_init(&priv->ieee80211->skb_drv_aggQ[i]);\r\npriv->rf_set_chan = rtl8192_phy_SwChnl;\r\n}\r\nstatic void rtl8192_init_priv_lock(struct r8192_priv *priv)\r\n{\r\nspin_lock_init(&priv->tx_lock);\r\nspin_lock_init(&priv->irq_lock);\r\nsema_init(&priv->wx_sem, 1);\r\nsema_init(&priv->rf_sem, 1);\r\nmutex_init(&priv->mutex);\r\n}\r\nstatic void rtl8192_init_priv_task(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\npriv->priv_wq = create_workqueue(DRV_NAME);\r\nINIT_WORK(&priv->reset_wq, rtl8192_restart);\r\nINIT_DELAYED_WORK(&priv->watch_dog_wq, rtl819x_watchdog_wqcallback);\r\nINIT_DELAYED_WORK(&priv->txpower_tracking_wq, dm_txpower_trackingcallback);\r\nINIT_DELAYED_WORK(&priv->rfpath_check_wq, dm_rf_pathcheck_workitemcallback);\r\nINIT_DELAYED_WORK(&priv->update_beacon_wq, rtl8192_update_beacon);\r\nINIT_DELAYED_WORK(&priv->initialgain_operate_wq, InitialGainOperateWorkItemCallBack);\r\nINIT_WORK(&priv->qos_activate, rtl8192_qos_activate);\r\ntasklet_init(&priv->irq_rx_tasklet,\r\n(void(*)(unsigned long))rtl8192_irq_rx_tasklet,\r\n(unsigned long)priv);\r\n}\r\nstatic void rtl8192_get_eeprom_size(struct net_device *dev)\r\n{\r\nu16 curCR = 0;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nRT_TRACE(COMP_EPROM, "===========>%s()\n", __func__);\r\nread_nic_word_E(dev, EPROM_CMD, &curCR);\r\nRT_TRACE(COMP_EPROM, "read from Reg EPROM_CMD(%x):%x\n", EPROM_CMD, curCR);\r\npriv->epromtype = (curCR & Cmd9346CR_9356SEL) ? EPROM_93c56 : EPROM_93c46;\r\nRT_TRACE(COMP_EPROM, "<===========%s(), epromtype:%d\n", __func__, priv->epromtype);\r\n}\r\nstatic inline u16 endian_swap(u16 *data)\r\n{\r\nu16 tmp = *data;\r\n*data = (tmp >> 8) | (tmp << 8);\r\nreturn *data;\r\n}\r\nstatic void rtl8192_read_eeprom_info(struct net_device *dev)\r\n{\r\nu16 wEPROM_ID = 0;\r\nu8 bMac_Tmp_Addr[6] = {0x00, 0xe0, 0x4c, 0x00, 0x00, 0x02};\r\nu8 bLoad_From_EEPOM = false;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu16 tmpValue = 0;\r\nint i;\r\nRT_TRACE(COMP_EPROM, "===========>%s()\n", __func__);\r\nwEPROM_ID = eprom_read(dev, 0);\r\nRT_TRACE(COMP_EPROM, "EEPROM ID is 0x%x\n", wEPROM_ID);\r\nif (wEPROM_ID != RTL8190_EEPROM_ID) {\r\nRT_TRACE(COMP_ERR, "EEPROM ID is invalid(is 0x%x(should be 0x%x)\n", wEPROM_ID, RTL8190_EEPROM_ID);\r\n} else {\r\nbLoad_From_EEPOM = true;\r\n}\r\nif (bLoad_From_EEPOM) {\r\ntmpValue = eprom_read(dev, (EEPROM_VID>>1));\r\npriv->eeprom_vid = endian_swap(&tmpValue);\r\npriv->eeprom_pid = eprom_read(dev, (EEPROM_PID>>1));\r\ntmpValue = eprom_read(dev, (EEPROM_ChannelPlan>>1));\r\npriv->eeprom_ChannelPlan = ((tmpValue&0xff00)>>8);\r\npriv->btxpowerdata_readfromEEPORM = true;\r\npriv->eeprom_CustomerID = eprom_read(dev, (EEPROM_Customer_ID>>1)) >>8;\r\n} else {\r\npriv->eeprom_vid = 0;\r\npriv->eeprom_pid = 0;\r\npriv->card_8192_version = VERSION_819xU_B;\r\npriv->eeprom_ChannelPlan = 0;\r\npriv->eeprom_CustomerID = 0;\r\n}\r\nRT_TRACE(COMP_EPROM, "vid:0x%4x, pid:0x%4x, CustomID:0x%2x, ChanPlan:0x%x\n", priv->eeprom_vid, priv->eeprom_pid, priv->eeprom_CustomerID, priv->eeprom_ChannelPlan);\r\npriv->ChannelPlan = priv->eeprom_ChannelPlan;\r\nif (bLoad_From_EEPOM) {\r\nint i;\r\nfor (i = 0; i < 6; i += 2) {\r\nu16 tmp = 0;\r\ntmp = eprom_read(dev, (u16)((EEPROM_NODE_ADDRESS_BYTE_0 + i)>>1));\r\n*(u16 *)(&dev->dev_addr[i]) = tmp;\r\n}\r\n} else {\r\nmemcpy(dev->dev_addr, bMac_Tmp_Addr, 6);\r\n}\r\nRT_TRACE(COMP_EPROM, "MAC addr:%pM\n", dev->dev_addr);\r\npriv->rf_type = RTL819X_DEFAULT_RF_TYPE;\r\npriv->rf_chip = RF_8256;\r\nif (priv->card_8192_version == (u8)VERSION_819xU_A) {\r\nif (bLoad_From_EEPOM)\r\npriv->EEPROMTxPowerDiff = (eprom_read(dev, (EEPROM_TxPowerDiff>>1))&0xff00) >> 8;\r\nelse\r\npriv->EEPROMTxPowerDiff = EEPROM_Default_TxPower;\r\nRT_TRACE(COMP_EPROM, "TxPowerDiff:%d\n", priv->EEPROMTxPowerDiff);\r\nif (bLoad_From_EEPOM)\r\npriv->EEPROMThermalMeter = (u8)(eprom_read(dev, (EEPROM_ThermalMeter>>1))&0x00ff);\r\nelse\r\npriv->EEPROMThermalMeter = EEPROM_Default_ThermalMeter;\r\nRT_TRACE(COMP_EPROM, "ThermalMeter:%d\n", priv->EEPROMThermalMeter);\r\npriv->TSSI_13dBm = priv->EEPROMThermalMeter *100;\r\nif (bLoad_From_EEPOM)\r\npriv->EEPROMPwDiff = (eprom_read(dev, (EEPROM_PwDiff>>1))&0x0f00)>>8;\r\nelse\r\npriv->EEPROMPwDiff = EEPROM_Default_PwDiff;\r\nRT_TRACE(COMP_EPROM, "TxPwDiff:%d\n", priv->EEPROMPwDiff);\r\nif (bLoad_From_EEPOM)\r\npriv->EEPROMCrystalCap = (eprom_read(dev, (EEPROM_CrystalCap>>1))&0x0f);\r\nelse\r\npriv->EEPROMCrystalCap = EEPROM_Default_CrystalCap;\r\nRT_TRACE(COMP_EPROM, "CrystalCap = %d\n", priv->EEPROMCrystalCap);\r\nif (bLoad_From_EEPOM)\r\npriv->EEPROM_Def_Ver = (eprom_read(dev, (EEPROM_TxPwIndex_Ver>>1))&0xff00)>>8;\r\nelse\r\npriv->EEPROM_Def_Ver = 1;\r\nRT_TRACE(COMP_EPROM, "EEPROM_DEF_VER:%d\n", priv->EEPROM_Def_Ver);\r\nif (priv->EEPROM_Def_Ver == 0) {\r\nint i;\r\nif (bLoad_From_EEPOM)\r\npriv->EEPROMTxPowerLevelCCK = (eprom_read(dev, (EEPROM_TxPwIndex_CCK>>1))&0xff) >> 8;\r\nelse\r\npriv->EEPROMTxPowerLevelCCK = 0x10;\r\nRT_TRACE(COMP_EPROM, "CCK Tx Power Levl: 0x%02x\n", priv->EEPROMTxPowerLevelCCK);\r\nfor (i = 0; i < 3; i++) {\r\nif (bLoad_From_EEPOM) {\r\ntmpValue = eprom_read(dev, (EEPROM_TxPwIndex_OFDM_24G+i)>>1);\r\nif (((EEPROM_TxPwIndex_OFDM_24G+i) % 2) == 0)\r\ntmpValue = tmpValue & 0x00ff;\r\nelse\r\ntmpValue = (tmpValue & 0xff00) >> 8;\r\n} else {\r\ntmpValue = 0x10;\r\n}\r\npriv->EEPROMTxPowerLevelOFDM24G[i] = (u8) tmpValue;\r\nRT_TRACE(COMP_EPROM, "OFDM 2.4G Tx Power Level, Index %d = 0x%02x\n", i, priv->EEPROMTxPowerLevelCCK);\r\n}\r\n} else if (priv->EEPROM_Def_Ver == 1) {\r\nif (bLoad_From_EEPOM) {\r\ntmpValue = eprom_read(dev, (EEPROM_TxPwIndex_CCK_V1>>1));\r\ntmpValue = (tmpValue & 0xff00) >> 8;\r\n} else {\r\ntmpValue = 0x10;\r\n}\r\npriv->EEPROMTxPowerLevelCCK_V1[0] = (u8)tmpValue;\r\nif (bLoad_From_EEPOM)\r\ntmpValue = eprom_read(dev, (EEPROM_TxPwIndex_CCK_V1 + 2)>>1);\r\nelse\r\ntmpValue = 0x1010;\r\n*((u16 *)(&priv->EEPROMTxPowerLevelCCK_V1[1])) = tmpValue;\r\nif (bLoad_From_EEPOM)\r\ntmpValue = eprom_read(dev, (EEPROM_TxPwIndex_OFDM_24G_V1>>1));\r\nelse\r\ntmpValue = 0x1010;\r\n*((u16 *)(&priv->EEPROMTxPowerLevelOFDM24G[0])) = tmpValue;\r\nif (bLoad_From_EEPOM)\r\ntmpValue = eprom_read(dev, (EEPROM_TxPwIndex_OFDM_24G_V1+2)>>1);\r\nelse\r\ntmpValue = 0x10;\r\npriv->EEPROMTxPowerLevelOFDM24G[2] = (u8)tmpValue;\r\n}\r\nfor (i = 0; i < 14; i++) {\r\nif (i <= 3)\r\npriv->TxPowerLevelOFDM24G[i] = priv->EEPROMTxPowerLevelOFDM24G[0];\r\nelse if (i >= 4 && i <= 9)\r\npriv->TxPowerLevelOFDM24G[i] = priv->EEPROMTxPowerLevelOFDM24G[1];\r\nelse\r\npriv->TxPowerLevelOFDM24G[i] = priv->EEPROMTxPowerLevelOFDM24G[2];\r\n}\r\nfor (i = 0; i < 14; i++) {\r\nif (priv->EEPROM_Def_Ver == 0) {\r\nif (i <= 3)\r\npriv->TxPowerLevelCCK[i] = priv->EEPROMTxPowerLevelOFDM24G[0] + (priv->EEPROMTxPowerLevelCCK - priv->EEPROMTxPowerLevelOFDM24G[1]);\r\nelse if (i >= 4 && i <= 9)\r\npriv->TxPowerLevelCCK[i] = priv->EEPROMTxPowerLevelCCK;\r\nelse\r\npriv->TxPowerLevelCCK[i] = priv->EEPROMTxPowerLevelOFDM24G[2] + (priv->EEPROMTxPowerLevelCCK - priv->EEPROMTxPowerLevelOFDM24G[1]);\r\n} else if (priv->EEPROM_Def_Ver == 1) {\r\nif (i <= 3)\r\npriv->TxPowerLevelCCK[i] = priv->EEPROMTxPowerLevelCCK_V1[0];\r\nelse if (i >= 4 && i <= 9)\r\npriv->TxPowerLevelCCK[i] = priv->EEPROMTxPowerLevelCCK_V1[1];\r\nelse\r\npriv->TxPowerLevelCCK[i] = priv->EEPROMTxPowerLevelCCK_V1[2];\r\n}\r\n}\r\npriv->TxPowerDiff = priv->EEPROMPwDiff;\r\npriv->AntennaTxPwDiff[0] = (priv->EEPROMTxPowerDiff & 0xf);\r\npriv->AntennaTxPwDiff[1] = ((priv->EEPROMTxPowerDiff & 0xf0)>>4);\r\npriv->CrystalCap = priv->EEPROMCrystalCap;\r\npriv->ThermalMeter[0] = priv->EEPROMThermalMeter;\r\n}\r\nswitch (priv->eeprom_CustomerID) {\r\ncase EEPROM_CID_RUNTOP:\r\npriv->CustomerID = RT_CID_819x_RUNTOP;\r\nbreak;\r\ncase EEPROM_CID_DLINK:\r\npriv->CustomerID = RT_CID_DLINK;\r\nbreak;\r\ndefault:\r\npriv->CustomerID = RT_CID_DEFAULT;\r\nbreak;\r\n}\r\nswitch (priv->CustomerID) {\r\ncase RT_CID_819x_RUNTOP:\r\npriv->LedStrategy = SW_LED_MODE2;\r\nbreak;\r\ncase RT_CID_DLINK:\r\npriv->LedStrategy = SW_LED_MODE4;\r\nbreak;\r\ndefault:\r\npriv->LedStrategy = SW_LED_MODE0;\r\nbreak;\r\n}\r\nif (priv->rf_type == RF_1T2R) {\r\nRT_TRACE(COMP_EPROM, "\n1T2R config\n");\r\n} else {\r\nRT_TRACE(COMP_EPROM, "\n2T4R config\n");\r\n}\r\ninit_rate_adaptive(dev);\r\nRT_TRACE(COMP_EPROM, "<===========%s()\n", __func__);\r\nreturn;\r\n}\r\nstatic short rtl8192_get_channel_map(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (priv->ChannelPlan > COUNTRY_CODE_GLOBAL_DOMAIN) {\r\nnetdev_err(dev, "rtl8180_init: Error channel plan! Set to default.\n");\r\npriv->ChannelPlan = 0;\r\n}\r\nRT_TRACE(COMP_INIT, "Channel plan is %d\n", priv->ChannelPlan);\r\nrtl819x_set_channel_map(priv->ChannelPlan, priv);\r\nreturn 0;\r\n}\r\nstatic short rtl8192_init(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nmemset(&(priv->stats), 0, sizeof(struct Stats));\r\nmemset(priv->txqueue_to_outpipemap, 0, 9);\r\n#ifdef PIPE12\r\n{\r\nint i = 0;\r\nu8 queuetopipe[] = {3, 2, 1, 0, 4, 8, 7, 6, 5};\r\nmemcpy(priv->txqueue_to_outpipemap, queuetopipe, 9);\r\n}\r\n#else\r\n{\r\nu8 queuetopipe[] = {3, 2, 1, 0, 4, 4, 0, 4, 4};\r\nmemcpy(priv->txqueue_to_outpipemap, queuetopipe, 9);\r\n}\r\n#endif\r\nrtl8192_init_priv_variable(dev);\r\nrtl8192_init_priv_lock(priv);\r\nrtl8192_init_priv_task(dev);\r\nrtl8192_get_eeprom_size(dev);\r\nrtl8192_read_eeprom_info(dev);\r\nrtl8192_get_channel_map(dev);\r\ninit_hal_dm(dev);\r\ninit_timer(&priv->watch_dog_timer);\r\npriv->watch_dog_timer.data = (unsigned long)dev;\r\npriv->watch_dog_timer.function = watch_dog_timer_callback;\r\nif (rtl8192_usb_initendpoints(dev) != 0) {\r\nDMESG("Endopoints initialization failed");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rtl8192_hwconfig(struct net_device *dev)\r\n{\r\nu32 regRATR = 0, regRRSR = 0;\r\nu8 regBwOpMode = 0, regTmp = 0;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu32 ratr_value = 0;\r\nswitch (priv->ieee80211->mode) {\r\ncase WIRELESS_MODE_B:\r\nregBwOpMode = BW_OPMODE_20MHZ;\r\nregRATR = RATE_ALL_CCK;\r\nregRRSR = RATE_ALL_CCK;\r\nbreak;\r\ncase WIRELESS_MODE_A:\r\nregBwOpMode = BW_OPMODE_5G |BW_OPMODE_20MHZ;\r\nregRATR = RATE_ALL_OFDM_AG;\r\nregRRSR = RATE_ALL_OFDM_AG;\r\nbreak;\r\ncase WIRELESS_MODE_G:\r\nregBwOpMode = BW_OPMODE_20MHZ;\r\nregRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\r\nregRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\r\nbreak;\r\ncase WIRELESS_MODE_AUTO:\r\n#ifdef TO_DO_LIST\r\nif (Adapter->bInHctTest) {\r\nregBwOpMode = BW_OPMODE_20MHZ;\r\nregRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\r\nregRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\r\n}\r\nelse\r\n#endif\r\n{\r\nregBwOpMode = BW_OPMODE_20MHZ;\r\nregRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;\r\nregRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\r\n}\r\nbreak;\r\ncase WIRELESS_MODE_N_24G:\r\nregBwOpMode = BW_OPMODE_20MHZ;\r\nregRATR = RATE_ALL_CCK | RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;\r\nregRRSR = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\r\nbreak;\r\ncase WIRELESS_MODE_N_5G:\r\nregBwOpMode = BW_OPMODE_5G;\r\nregRATR = RATE_ALL_OFDM_AG | RATE_ALL_OFDM_1SS | RATE_ALL_OFDM_2SS;\r\nregRRSR = RATE_ALL_OFDM_AG;\r\nbreak;\r\n}\r\nwrite_nic_byte(dev, BW_OPMODE, regBwOpMode);\r\nratr_value = regRATR;\r\nif (priv->rf_type == RF_1T2R)\r\nratr_value &= ~(RATE_ALL_OFDM_2SS);\r\nwrite_nic_dword(dev, RATR0, ratr_value);\r\nwrite_nic_byte(dev, UFWP, 1);\r\nread_nic_byte(dev, 0x313, &regTmp);\r\nregRRSR = ((regTmp) << 24) | (regRRSR & 0x00ffffff);\r\nwrite_nic_dword(dev, RRSR, regRRSR);\r\nwrite_nic_word(dev, RETRY_LIMIT,\r\npriv->ShortRetryLimit << RETRY_LIMIT_SHORT_SHIFT |\r\npriv->LongRetryLimit << RETRY_LIMIT_LONG_SHIFT);\r\n}\r\nstatic bool rtl8192_adapter_start(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu32 dwRegRead = 0;\r\nbool init_status = true;\r\nu8 SECR_value = 0x0;\r\nu8 tmp;\r\nRT_TRACE(COMP_INIT, "====>%s()\n", __func__);\r\npriv->Rf_Mode = RF_OP_By_SW_3wire;\r\nwrite_nic_byte_E(dev, 0x5f, 0x80);\r\nmdelay(50);\r\nwrite_nic_byte_E(dev, 0x5f, 0xf0);\r\nwrite_nic_byte_E(dev, 0x5d, 0x00);\r\nwrite_nic_byte_E(dev, 0x5e, 0x80);\r\nwrite_nic_byte(dev, 0x17, 0x37);\r\nmdelay(10);\r\npriv->pFirmware->firmware_status = FW_STATUS_0_INIT;\r\nread_nic_dword(dev, CPU_GEN, &dwRegRead);\r\nif (priv->pFirmware->firmware_status == FW_STATUS_0_INIT)\r\ndwRegRead |= CPU_GEN_SYSTEM_RESET;\r\nelse if (priv->pFirmware->firmware_status == FW_STATUS_5_READY)\r\ndwRegRead |= CPU_GEN_FIRMWARE_RESET;\r\nelse\r\nRT_TRACE(COMP_ERR, "ERROR in %s(): undefined firmware state(%d)\n", __func__, priv->pFirmware->firmware_status);\r\nwrite_nic_dword(dev, CPU_GEN, dwRegRead);\r\nrtl8192_BBConfig(dev);\r\npriv->LoopbackMode = RTL819xU_NO_LOOPBACK;\r\nread_nic_dword(dev, CPU_GEN, &dwRegRead);\r\nif (priv->LoopbackMode == RTL819xU_NO_LOOPBACK)\r\ndwRegRead = ((dwRegRead & CPU_GEN_NO_LOOPBACK_MSK) | CPU_GEN_NO_LOOPBACK_SET);\r\nelse if (priv->LoopbackMode == RTL819xU_MAC_LOOPBACK)\r\ndwRegRead |= CPU_CCK_LOOPBACK;\r\nelse\r\nRT_TRACE(COMP_ERR, "Serious error in %s(): wrong loopback mode setting(%d)\n", __func__, priv->LoopbackMode);\r\nwrite_nic_dword(dev, CPU_GEN, dwRegRead);\r\nudelay(500);\r\nread_nic_byte_E(dev, 0x5f, &tmp);\r\nwrite_nic_byte_E(dev, 0x5f, tmp|0x20);\r\nrtl8192_hwconfig(dev);\r\nwrite_nic_byte(dev, CMDR, CR_RE|CR_TE);\r\nwrite_nic_dword(dev, MAC0, ((u32 *)dev->dev_addr)[0]);\r\nwrite_nic_word(dev, MAC4, ((u16 *)(dev->dev_addr + 4))[0]);\r\nwrite_nic_dword(dev, RCR, priv->ReceiveConfig);\r\nwrite_nic_dword(dev, RQPN1, NUM_OF_PAGE_IN_FW_QUEUE_BK << RSVD_FW_QUEUE_PAGE_BK_SHIFT |\r\nNUM_OF_PAGE_IN_FW_QUEUE_BE << RSVD_FW_QUEUE_PAGE_BE_SHIFT |\r\nNUM_OF_PAGE_IN_FW_QUEUE_VI << RSVD_FW_QUEUE_PAGE_VI_SHIFT |\r\nNUM_OF_PAGE_IN_FW_QUEUE_VO <<RSVD_FW_QUEUE_PAGE_VO_SHIFT);\r\nwrite_nic_dword(dev, RQPN2, NUM_OF_PAGE_IN_FW_QUEUE_MGNT << RSVD_FW_QUEUE_PAGE_MGNT_SHIFT |\r\nNUM_OF_PAGE_IN_FW_QUEUE_CMD << RSVD_FW_QUEUE_PAGE_CMD_SHIFT);\r\nwrite_nic_dword(dev, RQPN3, APPLIED_RESERVED_QUEUE_IN_FW|\r\nNUM_OF_PAGE_IN_FW_QUEUE_BCN<<RSVD_FW_QUEUE_PAGE_BCN_SHIFT);\r\nwrite_nic_dword(dev, RATR0+4*7, (RATE_ALL_OFDM_AG | RATE_ALL_CCK));\r\nwrite_nic_byte(dev, ACK_TIMEOUT, 0x30);\r\nif (priv->ResetProgress == RESET_TYPE_NORESET)\r\nrtl8192_SetWirelessMode(dev, priv->ieee80211->mode);\r\nif (priv->ResetProgress == RESET_TYPE_NORESET) {\r\nCamResetAllEntry(dev);\r\nSECR_value |= SCR_TxEncEnable;\r\nSECR_value |= SCR_RxDecEnable;\r\nSECR_value |= SCR_NoSKMC;\r\nwrite_nic_byte(dev, SECR, SECR_value);\r\n}\r\nwrite_nic_word(dev, ATIMWND, 2);\r\nwrite_nic_word(dev, BCN_INTERVAL, 100);\r\n#define DEFAULT_EDCA 0x005e4332\r\n{\r\nint i;\r\nfor (i = 0; i < QOS_QUEUE_NUM; i++)\r\nwrite_nic_dword(dev, WDCAPARA_ADD[i], DEFAULT_EDCA);\r\n}\r\nrtl8192_phy_configmac(dev);\r\nif (priv->card_8192_version == (u8) VERSION_819xU_A) {\r\nrtl8192_phy_getTxPower(dev);\r\nrtl8192_phy_setTxPower(dev, priv->chan);\r\n}\r\ninit_status = init_firmware(dev);\r\nif (!init_status) {\r\nRT_TRACE(COMP_ERR, "ERR!!! %s(): Firmware download is failed\n", __func__);\r\nreturn init_status;\r\n}\r\nRT_TRACE(COMP_INIT, "%s():after firmware download\n", __func__);\r\n#ifdef TO_DO_LIST\r\nif (Adapter->ResetProgress == RESET_TYPE_NORESET) {\r\nif (pMgntInfo->RegRfOff == TRUE) {\r\nRT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter819xUsb(): Turn off RF for RegRfOff ----------\n"));\r\nMgntActSet_RF_State(Adapter, eRfOff, RF_CHANGE_BY_SW);\r\nfor (eRFPath = 0; eRFPath < pHalData->NumTotalRFPath; eRFPath++)\r\nPHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)eRFPath, 0x4, 0xC00, 0x0);\r\n} else if (pMgntInfo->RfOffReason > RF_CHANGE_BY_PS) {\r\nRT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter819xUsb(): Turn off RF for RfOffReason(%d) ----------\n", pMgntInfo->RfOffReason));\r\nMgntActSet_RF_State(Adapter, eRfOff, pMgntInfo->RfOffReason);\r\n} else {\r\npHalData->eRFPowerState = eRfOn;\r\npMgntInfo->RfOffReason = 0;\r\nRT_TRACE((COMP_INIT|COMP_RF), DBG_LOUD, ("InitializeAdapter819xUsb(): RF is on ----------\n"));\r\n}\r\n} else {\r\nif (pHalData->eRFPowerState == eRfOff) {\r\nMgntActSet_RF_State(Adapter, eRfOff, pMgntInfo->RfOffReason);\r\nfor (eRFPath = 0; eRFPath < pHalData->NumTotalRFPath; eRFPath++)\r\nPHY_SetRFReg(Adapter, (RF90_RADIO_PATH_E)eRFPath, 0x4, 0xC00, 0x0);\r\n}\r\n}\r\n#endif\r\nif (priv->ResetProgress == RESET_TYPE_NORESET) {\r\nrtl8192_phy_RFConfig(dev);\r\nRT_TRACE(COMP_INIT, "%s():after phy RF config\n", __func__);\r\n}\r\nif (priv->ieee80211->FwRWRF)\r\npriv->Rf_Mode = RF_OP_By_FW;\r\nelse\r\npriv->Rf_Mode = RF_OP_By_SW_3wire;\r\nrtl8192_phy_updateInitGain(dev);\r\nrtl8192_setBBreg(dev, rFPGA0_RFMOD, bCCKEn, 0x1);\r\nrtl8192_setBBreg(dev, rFPGA0_RFMOD, bOFDMEn, 0x1);\r\nif (priv->ResetProgress == RESET_TYPE_NORESET) {\r\nu8 tmpvalue;\r\nread_nic_byte(dev, 0x301, &tmpvalue);\r\nif (tmpvalue == 0x03) {\r\npriv->bDcut = TRUE;\r\nRT_TRACE(COMP_POWER_TRACKING, "D-cut\n");\r\n} else {\r\npriv->bDcut = FALSE;\r\nRT_TRACE(COMP_POWER_TRACKING, "C-cut\n");\r\n}\r\ndm_initialize_txpower_tracking(dev);\r\nif (priv->bDcut == TRUE) {\r\nu32 i, TempCCk;\r\nu32 tmpRegA = rtl8192_QueryBBReg(dev, rOFDM0_XATxIQImbalance, bMaskDWord);\r\nfor (i = 0; i < TxBBGainTableLength; i++) {\r\nif (tmpRegA == priv->txbbgain_table[i].txbbgain_value) {\r\npriv->rfa_txpowertrackingindex = (u8)i;\r\npriv->rfa_txpowertrackingindex_real = (u8)i;\r\npriv->rfa_txpowertracking_default = priv->rfa_txpowertrackingindex;\r\nbreak;\r\n}\r\n}\r\nTempCCk = rtl8192_QueryBBReg(dev, rCCK0_TxFilter1, bMaskByte2);\r\nfor (i = 0; i < CCKTxBBGainTableLength; i++) {\r\nif (TempCCk == priv->cck_txbbgain_table[i].ccktxbb_valuearray[0]) {\r\npriv->cck_present_attentuation_20Mdefault = (u8) i;\r\nbreak;\r\n}\r\n}\r\npriv->cck_present_attentuation_40Mdefault = 0;\r\npriv->cck_present_attentuation_difference = 0;\r\npriv->cck_present_attentuation = priv->cck_present_attentuation_20Mdefault;\r\n}\r\n}\r\nwrite_nic_byte(dev, 0x87, 0x0);\r\nreturn init_status;\r\n}\r\nstatic struct net_device_stats *rtl8192_stats(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nreturn &priv->ieee80211->stats;\r\n}\r\nstatic bool HalTxCheckStuck819xUsb(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu16 RegTxCounter;\r\nbool bStuck = FALSE;\r\nread_nic_word(dev, 0x128, &RegTxCounter);\r\nRT_TRACE(COMP_RESET, "%s():RegTxCounter is %d,TxCounter is %d\n", __func__, RegTxCounter, priv->TxCounter);\r\nif (priv->TxCounter == RegTxCounter)\r\nbStuck = TRUE;\r\npriv->TxCounter = RegTxCounter;\r\nreturn bStuck;\r\n}\r\nstatic RESET_TYPE TxCheckStuck(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu8 QueueID;\r\nbool bCheckFwTxCnt = false;\r\nfor (QueueID = 0; QueueID <= BEACON_QUEUE; QueueID++) {\r\nif (QueueID == TXCMD_QUEUE)\r\ncontinue;\r\nif ((skb_queue_len(&priv->ieee80211->skb_waitQ[QueueID]) == 0) && (skb_queue_len(&priv->ieee80211->skb_aggQ[QueueID]) == 0))\r\ncontinue;\r\nbCheckFwTxCnt = true;\r\n}\r\nif (bCheckFwTxCnt) {\r\nif (HalTxCheckStuck819xUsb(dev)) {\r\nRT_TRACE(COMP_RESET, "TxCheckStuck(): Fw indicates no Tx condition! \n");\r\nreturn RESET_TYPE_SILENT;\r\n}\r\n}\r\nreturn RESET_TYPE_NORESET;\r\n}\r\nstatic bool HalRxCheckStuck819xUsb(struct net_device *dev)\r\n{\r\nu16 RegRxCounter;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nbool bStuck = FALSE;\r\nstatic u8 rx_chk_cnt;\r\nread_nic_word(dev, 0x130, &RegRxCounter);\r\nRT_TRACE(COMP_RESET, "%s(): RegRxCounter is %d,RxCounter is %d\n", __func__, RegRxCounter, priv->RxCounter);\r\nrx_chk_cnt++;\r\nif (priv->undecorated_smoothed_pwdb >= (RateAdaptiveTH_High+5)) {\r\nrx_chk_cnt = 0;\r\n} else if (priv->undecorated_smoothed_pwdb < (RateAdaptiveTH_High+5) &&\r\n((priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20 && priv->undecorated_smoothed_pwdb >= RateAdaptiveTH_Low_40M) ||\r\n(priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20 && priv->undecorated_smoothed_pwdb >= RateAdaptiveTH_Low_20M))) {\r\nif (rx_chk_cnt < 2)\r\nreturn bStuck;\r\nelse\r\nrx_chk_cnt = 0;\r\n} else if (((priv->CurrentChannelBW != HT_CHANNEL_WIDTH_20 && priv->undecorated_smoothed_pwdb < RateAdaptiveTH_Low_40M) ||\r\n(priv->CurrentChannelBW == HT_CHANNEL_WIDTH_20 && priv->undecorated_smoothed_pwdb < RateAdaptiveTH_Low_20M)) &&\r\npriv->undecorated_smoothed_pwdb >= VeryLowRSSI) {\r\nif (rx_chk_cnt < 4)\r\nreturn bStuck;\r\nelse\r\nrx_chk_cnt = 0;\r\n} else {\r\nif (rx_chk_cnt < 8)\r\nreturn bStuck;\r\nelse\r\nrx_chk_cnt = 0;\r\n}\r\nif (priv->RxCounter == RegRxCounter)\r\nbStuck = TRUE;\r\npriv->RxCounter = RegRxCounter;\r\nreturn bStuck;\r\n}\r\nstatic RESET_TYPE RxCheckStuck(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nbool bRxCheck = FALSE;\r\nif (priv->IrpPendingCount > 1)\r\nbRxCheck = TRUE;\r\nif (bRxCheck) {\r\nif (HalRxCheckStuck819xUsb(dev)) {\r\nRT_TRACE(COMP_RESET, "RxStuck Condition\n");\r\nreturn RESET_TYPE_SILENT;\r\n}\r\n}\r\nreturn RESET_TYPE_NORESET;\r\n}\r\nstatic RESET_TYPE rtl819x_ifcheck_resetornot(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nRESET_TYPE TxResetType = RESET_TYPE_NORESET;\r\nRESET_TYPE RxResetType = RESET_TYPE_NORESET;\r\nRT_RF_POWER_STATE rfState;\r\nrfState = priv->ieee80211->eRFPowerState;\r\nTxResetType = TxCheckStuck(dev);\r\nif (rfState != eRfOff ||\r\n(priv->ieee80211->iw_mode != IW_MODE_ADHOC)) {\r\nRxResetType = RxCheckStuck(dev);\r\n}\r\nif (TxResetType == RESET_TYPE_NORMAL || RxResetType == RESET_TYPE_NORMAL) {\r\nreturn RESET_TYPE_NORMAL;\r\n} else if (TxResetType == RESET_TYPE_SILENT || RxResetType == RESET_TYPE_SILENT) {\r\nRT_TRACE(COMP_RESET, "%s():silent reset\n", __func__);\r\nreturn RESET_TYPE_SILENT;\r\n} else {\r\nreturn RESET_TYPE_NORESET;\r\n}\r\n}\r\nstatic void CamRestoreAllEntry(struct net_device *dev)\r\n{\r\nu8 EntryId = 0;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu8 *MacAddr = priv->ieee80211->current_network.bssid;\r\nstatic u8 CAM_CONST_ADDR[4][6] = {\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x01},\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x02},\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x03} };\r\nstatic u8 CAM_CONST_BROAD[] = {\r\n0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nRT_TRACE(COMP_SEC, "CamRestoreAllEntry: \n");\r\nif ((priv->ieee80211->pairwise_key_type == KEY_TYPE_WEP40) ||\r\n(priv->ieee80211->pairwise_key_type == KEY_TYPE_WEP104)) {\r\nfor (EntryId = 0; EntryId < 4; EntryId++) {\r\nMacAddr = CAM_CONST_ADDR[EntryId];\r\nsetKey(dev, EntryId, EntryId,\r\npriv->ieee80211->pairwise_key_type,\r\nMacAddr, 0, NULL);\r\n}\r\n} else if (priv->ieee80211->pairwise_key_type == KEY_TYPE_TKIP) {\r\nif (priv->ieee80211->iw_mode == IW_MODE_ADHOC)\r\nsetKey(dev, 4, 0, priv->ieee80211->pairwise_key_type,\r\n(u8 *)dev->dev_addr, 0, NULL);\r\nelse\r\nsetKey(dev, 4, 0, priv->ieee80211->pairwise_key_type,\r\nMacAddr, 0, NULL);\r\n} else if (priv->ieee80211->pairwise_key_type == KEY_TYPE_CCMP) {\r\nif (priv->ieee80211->iw_mode == IW_MODE_ADHOC)\r\nsetKey(dev, 4, 0, priv->ieee80211->pairwise_key_type,\r\n(u8 *)dev->dev_addr, 0, NULL);\r\nelse\r\nsetKey(dev, 4, 0, priv->ieee80211->pairwise_key_type,\r\nMacAddr, 0, NULL);\r\n}\r\nif (priv->ieee80211->group_key_type == KEY_TYPE_TKIP) {\r\nMacAddr = CAM_CONST_BROAD;\r\nfor (EntryId = 1; EntryId < 4; EntryId++) {\r\nsetKey(dev, EntryId, EntryId,\r\npriv->ieee80211->group_key_type,\r\nMacAddr, 0, NULL);\r\n}\r\nif (priv->ieee80211->iw_mode == IW_MODE_ADHOC)\r\nsetKey(dev, 0, 0, priv->ieee80211->group_key_type,\r\nCAM_CONST_ADDR[0], 0, NULL);\r\n} else if (priv->ieee80211->group_key_type == KEY_TYPE_CCMP) {\r\nMacAddr = CAM_CONST_BROAD;\r\nfor (EntryId = 1; EntryId < 4; EntryId++) {\r\nsetKey(dev, EntryId, EntryId,\r\npriv->ieee80211->group_key_type,\r\nMacAddr, 0, NULL);\r\n}\r\nif (priv->ieee80211->iw_mode == IW_MODE_ADHOC)\r\nsetKey(dev, 0, 0, priv->ieee80211->group_key_type,\r\nCAM_CONST_ADDR[0], 0, NULL);\r\n}\r\n}\r\nstatic void rtl819x_ifsilentreset(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nu8 reset_times = 0;\r\nint reset_status = 0;\r\nstruct ieee80211_device *ieee = priv->ieee80211;\r\nif (priv->ResetProgress == RESET_TYPE_NORESET) {\r\nRESET_START:\r\nRT_TRACE(COMP_RESET, "=========>Reset progress!! \n");\r\npriv->ResetProgress = RESET_TYPE_SILENT;\r\ndown(&priv->wx_sem);\r\nif (priv->up == 0) {\r\nRT_TRACE(COMP_ERR, "%s():the driver is not up! return\n", __func__);\r\nup(&priv->wx_sem);\r\nreturn;\r\n}\r\npriv->up = 0;\r\nRT_TRACE(COMP_RESET, "%s():======>start to down the driver\n", __func__);\r\nrtl8192_rtx_disable(dev);\r\nrtl8192_cancel_deferred_work(priv);\r\ndeinit_hal_dm(dev);\r\ndel_timer_sync(&priv->watch_dog_timer);\r\nieee->sync_scan_hurryup = 1;\r\nif (ieee->state == IEEE80211_LINKED) {\r\ndown(&ieee->wx_sem);\r\nnetdev_dbg(dev, "ieee->state is IEEE80211_LINKED\n");\r\nieee80211_stop_send_beacons(priv->ieee80211);\r\ndel_timer_sync(&ieee->associate_timer);\r\ncancel_delayed_work(&ieee->associate_retry_wq);\r\nieee80211_stop_scan(ieee);\r\nnetif_carrier_off(dev);\r\nup(&ieee->wx_sem);\r\n} else {\r\nnetdev_dbg(dev, "ieee->state is NOT LINKED\n");\r\nieee80211_softmac_stop_protocol(priv->ieee80211);\r\n}\r\nup(&priv->wx_sem);\r\nRT_TRACE(COMP_RESET, "%s():<==========down process is finished\n", __func__);\r\nRT_TRACE(COMP_RESET, "%s():===========>start up the driver\n", __func__);\r\nreset_status = _rtl8192_up(dev);\r\nRT_TRACE(COMP_RESET, "%s():<===========up process is finished\n", __func__);\r\nif (reset_status == -EAGAIN) {\r\nif (reset_times < 3) {\r\nreset_times++;\r\ngoto RESET_START;\r\n} else {\r\nRT_TRACE(COMP_ERR, " ERR!!! %s(): Reset Failed!!\n", __func__);\r\n}\r\n}\r\nieee->is_silent_reset = 1;\r\nEnableHWSecurityConfig8192(dev);\r\nif (ieee->state == IEEE80211_LINKED && ieee->iw_mode == IW_MODE_INFRA) {\r\nieee->set_chan(ieee->dev, ieee->current_network.channel);\r\nqueue_work(ieee->wq, &ieee->associate_complete_wq);\r\n} else if (ieee->state == IEEE80211_LINKED && ieee->iw_mode == IW_MODE_ADHOC) {\r\nieee->set_chan(ieee->dev, ieee->current_network.channel);\r\nieee->link_change(ieee->dev);\r\nieee80211_start_send_beacons(ieee);\r\nif (ieee->data_hard_resume)\r\nieee->data_hard_resume(ieee->dev);\r\nnetif_carrier_on(ieee->dev);\r\n}\r\nCamRestoreAllEntry(dev);\r\npriv->ResetProgress = RESET_TYPE_NORESET;\r\npriv->reset_count++;\r\npriv->bForcedSilentReset = false;\r\npriv->bResetInProgress = false;\r\nwrite_nic_byte(dev, UFWP, 1);\r\nRT_TRACE(COMP_RESET, "Reset finished!! ====>[%d]\n", priv->reset_count);\r\n}\r\n}\r\nstatic void rtl819x_update_rxcounts(struct r8192_priv *priv, u32 *TotalRxBcnNum,\r\nu32 *TotalRxDataNum)\r\n{\r\nu16 SlotIndex;\r\nu8 i;\r\n*TotalRxBcnNum = 0;\r\n*TotalRxDataNum = 0;\r\nSlotIndex = (priv->ieee80211->LinkDetectInfo.SlotIndex++)%(priv->ieee80211->LinkDetectInfo.SlotNum);\r\npriv->ieee80211->LinkDetectInfo.RxBcnNum[SlotIndex] = priv->ieee80211->LinkDetectInfo.NumRecvBcnInPeriod;\r\npriv->ieee80211->LinkDetectInfo.RxDataNum[SlotIndex] = priv->ieee80211->LinkDetectInfo.NumRecvDataInPeriod;\r\nfor (i = 0; i < priv->ieee80211->LinkDetectInfo.SlotNum; i++) {\r\n*TotalRxBcnNum += priv->ieee80211->LinkDetectInfo.RxBcnNum[i];\r\n*TotalRxDataNum += priv->ieee80211->LinkDetectInfo.RxDataNum[i];\r\n}\r\n}\r\nvoid rtl819x_watchdog_wqcallback(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = container_of(work, struct delayed_work, work);\r\nstruct r8192_priv *priv = container_of(dwork, struct r8192_priv, watch_dog_wq);\r\nstruct net_device *dev = priv->ieee80211->dev;\r\nstruct ieee80211_device *ieee = priv->ieee80211;\r\nRESET_TYPE ResetType = RESET_TYPE_NORESET;\r\nstatic u8 check_reset_cnt;\r\nbool bBusyTraffic = false;\r\nu32 TotalRxBcnNum = 0;\r\nu32 TotalRxDataNum = 0;\r\nif (!priv->up)\r\nreturn;\r\nhal_dm_watchdog(dev);\r\nif (ieee->state == IEEE80211_LINKED) {\r\nif (ieee->LinkDetectInfo.NumRxOkInPeriod > 666 ||\r\nieee->LinkDetectInfo.NumTxOkInPeriod > 666 ) {\r\nbBusyTraffic = true;\r\n}\r\nieee->LinkDetectInfo.NumRxOkInPeriod = 0;\r\nieee->LinkDetectInfo.NumTxOkInPeriod = 0;\r\nieee->LinkDetectInfo.bBusyTraffic = bBusyTraffic;\r\n}\r\nif (priv->ieee80211->state == IEEE80211_LINKED && priv->ieee80211->iw_mode == IW_MODE_INFRA) {\r\nrtl819x_update_rxcounts(priv, &TotalRxBcnNum, &TotalRxDataNum);\r\nif ((TotalRxBcnNum+TotalRxDataNum) == 0) {\r\n#ifdef TODO\r\nif (rfState == eRfOff)\r\nRT_TRACE(COMP_ERR, "========>%s()\n", __func__);\r\n#endif\r\nnetdev_dbg(dev, "===>%s(): AP is power off, connect another one\n", __func__);\r\npriv->ieee80211->state = IEEE80211_ASSOCIATING;\r\nnotify_wx_assoc_event(priv->ieee80211);\r\nRemovePeerTS(priv->ieee80211, priv->ieee80211->current_network.bssid);\r\npriv->ieee80211->link_change(dev);\r\nqueue_work(priv->ieee80211->wq, &priv->ieee80211->associate_procedure_wq);\r\n}\r\n}\r\npriv->ieee80211->LinkDetectInfo.NumRecvBcnInPeriod = 0;\r\npriv->ieee80211->LinkDetectInfo.NumRecvDataInPeriod = 0;\r\nif (check_reset_cnt++ >= 3) {\r\nResetType = rtl819x_ifcheck_resetornot(dev);\r\ncheck_reset_cnt = 3;\r\n}\r\nif ((priv->force_reset) || (priv->ResetProgress == RESET_TYPE_NORESET &&\r\n(priv->bForcedSilentReset ||\r\n(!priv->bDisableNormalResetCheck && ResetType == RESET_TYPE_SILENT)))) {\r\nRT_TRACE(COMP_RESET, "%s():priv->force_reset is %d,priv->ResetProgress is %d, priv->bForcedSilentReset is %d,priv->bDisableNormalResetCheck is %d,ResetType is %d\n", __func__, priv->force_reset, priv->ResetProgress, priv->bForcedSilentReset, priv->bDisableNormalResetCheck, ResetType);\r\nrtl819x_ifsilentreset(dev);\r\n}\r\npriv->force_reset = false;\r\npriv->bForcedSilentReset = false;\r\npriv->bResetInProgress = false;\r\nRT_TRACE(COMP_TRACE, " <==RtUsbCheckForHangWorkItemCallback()\n");\r\n}\r\nvoid watch_dog_timer_callback(unsigned long data)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv((struct net_device *) data);\r\nqueue_delayed_work(priv->priv_wq, &priv->watch_dog_wq, 0);\r\nmod_timer(&priv->watch_dog_timer, jiffies + MSECS(IEEE80211_WATCH_DOG_TIME));\r\n}\r\nint _rtl8192_up(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nint init_status = 0;\r\npriv->up = 1;\r\npriv->ieee80211->ieee_up = 1;\r\nRT_TRACE(COMP_INIT, "Bringing up iface");\r\ninit_status = rtl8192_adapter_start(dev);\r\nif (!init_status) {\r\nRT_TRACE(COMP_ERR, "ERR!!! %s(): initialization failed!\n", __func__);\r\npriv->up = priv->ieee80211->ieee_up = 0;\r\nreturn -EAGAIN;\r\n}\r\nRT_TRACE(COMP_INIT, "start adapter finished\n");\r\nrtl8192_rx_enable(dev);\r\nif (priv->ieee80211->state != IEEE80211_LINKED)\r\nieee80211_softmac_start_protocol(priv->ieee80211);\r\nieee80211_reset_queue(priv->ieee80211);\r\nwatch_dog_timer_callback((unsigned long) dev);\r\nif (!netif_queue_stopped(dev))\r\nnetif_start_queue(dev);\r\nelse\r\nnetif_wake_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int rtl8192_open(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nint ret;\r\ndown(&priv->wx_sem);\r\nret = rtl8192_up(dev);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nint rtl8192_up(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (priv->up == 1)\r\nreturn -1;\r\nreturn _rtl8192_up(dev);\r\n}\r\nint rtl8192_close(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nint ret;\r\ndown(&priv->wx_sem);\r\nret = rtl8192_down(dev);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nint rtl8192_down(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nint i;\r\nif (priv->up == 0)\r\nreturn -1;\r\npriv->up = 0;\r\npriv->ieee80211->ieee_up = 0;\r\nRT_TRACE(COMP_DOWN, "==========>%s()\n", __func__);\r\nif (!netif_queue_stopped(dev))\r\nnetif_stop_queue(dev);\r\nrtl8192_rtx_disable(dev);\r\nfor (i = 0; i < MAX_QUEUE_SIZE; i++)\r\nskb_queue_purge(&priv->ieee80211->skb_waitQ[i]);\r\nfor (i = 0; i < MAX_QUEUE_SIZE; i++)\r\nskb_queue_purge(&priv->ieee80211->skb_aggQ[i]);\r\nfor (i = 0; i < MAX_QUEUE_SIZE; i++)\r\nskb_queue_purge(&priv->ieee80211->skb_drv_aggQ[i]);\r\nrtl8192_cancel_deferred_work(priv);\r\ndeinit_hal_dm(dev);\r\ndel_timer_sync(&priv->watch_dog_timer);\r\nieee80211_softmac_stop_protocol(priv->ieee80211);\r\nmemset(&priv->ieee80211->current_network, 0, offsetof(struct ieee80211_network, list));\r\nRT_TRACE(COMP_DOWN, "<==========%s()\n", __func__);\r\nreturn 0;\r\n}\r\nvoid rtl8192_commit(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nint reset_status = 0;\r\nif (priv->up == 0)\r\nreturn;\r\npriv->up = 0;\r\nrtl8192_cancel_deferred_work(priv);\r\ndel_timer_sync(&priv->watch_dog_timer);\r\nieee80211_softmac_stop_protocol(priv->ieee80211);\r\nrtl8192_rtx_disable(dev);\r\nreset_status = _rtl8192_up(dev);\r\n}\r\nvoid rtl8192_restart(struct work_struct *work)\r\n{\r\nstruct r8192_priv *priv = container_of(work, struct r8192_priv, reset_wq);\r\nstruct net_device *dev = priv->ieee80211->dev;\r\ndown(&priv->wx_sem);\r\nrtl8192_commit(dev);\r\nup(&priv->wx_sem);\r\n}\r\nstatic void r8192_set_multicast(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nshort promisc;\r\npromisc = (dev->flags & IFF_PROMISC) ? 1 : 0;\r\nif (promisc != priv->promisc)\r\npriv->promisc = promisc;\r\n}\r\nstatic int r8192_set_mac_adr(struct net_device *dev, void *mac)\r\n{\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nstruct sockaddr *addr = mac;\r\ndown(&priv->wx_sem);\r\nmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\r\nschedule_work(&priv->reset_wq);\r\nup(&priv->wx_sem);\r\nreturn 0;\r\n}\r\nstatic int rtl8192_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nstruct iwreq *wrq = (struct iwreq *)rq;\r\nint ret = -1;\r\nstruct ieee80211_device *ieee = priv->ieee80211;\r\nu32 key[4];\r\nu8 broadcast_addr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nstruct iw_point *p = &wrq->u.data;\r\nstruct ieee_param *ipw = NULL;\r\ndown(&priv->wx_sem);\r\nif (p->length < sizeof(struct ieee_param) || !p->pointer) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nipw = memdup_user(p->pointer, p->length);\r\nif (IS_ERR(ipw)) {\r\nret = PTR_ERR(ipw);\r\ngoto out;\r\n}\r\nswitch (cmd) {\r\ncase RTL_IOCTL_WPA_SUPPLICANT:\r\nif (ipw->cmd == IEEE_CMD_SET_ENCRYPTION) {\r\nif (ipw->u.crypt.set_tx) {\r\nif (strcmp(ipw->u.crypt.alg, "CCMP") == 0) {\r\nieee->pairwise_key_type = KEY_TYPE_CCMP;\r\n} else if (strcmp(ipw->u.crypt.alg, "TKIP") == 0) {\r\nieee->pairwise_key_type = KEY_TYPE_TKIP;\r\n} else if (strcmp(ipw->u.crypt.alg, "WEP") == 0) {\r\nif (ipw->u.crypt.key_len == 13)\r\nieee->pairwise_key_type = KEY_TYPE_WEP104;\r\nelse if (ipw->u.crypt.key_len == 5)\r\nieee->pairwise_key_type = KEY_TYPE_WEP40;\r\n} else {\r\nieee->pairwise_key_type = KEY_TYPE_NA;\r\n}\r\nif (ieee->pairwise_key_type) {\r\nmemcpy((u8 *)key, ipw->u.crypt.key, 16);\r\nEnableHWSecurityConfig8192(dev);\r\nsetKey(dev, 4, ipw->u.crypt.idx, ieee->pairwise_key_type, (u8 *)ieee->ap_mac_addr, 0, key);\r\nif (ieee->auth_mode != 2)\r\nsetKey(dev, ipw->u.crypt.idx, ipw->u.crypt.idx, ieee->pairwise_key_type, (u8 *)ieee->ap_mac_addr, 0, key);\r\n}\r\n} else {\r\nmemcpy((u8 *)key, ipw->u.crypt.key, 16);\r\nif (strcmp(ipw->u.crypt.alg, "CCMP") == 0) {\r\nieee->group_key_type = KEY_TYPE_CCMP;\r\n} else if (strcmp(ipw->u.crypt.alg, "TKIP") == 0) {\r\nieee->group_key_type = KEY_TYPE_TKIP;\r\n} else if (strcmp(ipw->u.crypt.alg, "WEP") == 0) {\r\nif (ipw->u.crypt.key_len == 13)\r\nieee->group_key_type = KEY_TYPE_WEP104;\r\nelse if (ipw->u.crypt.key_len == 5)\r\nieee->group_key_type = KEY_TYPE_WEP40;\r\n} else {\r\nieee->group_key_type = KEY_TYPE_NA;\r\n}\r\nif (ieee->group_key_type) {\r\nsetKey(dev, ipw->u.crypt.idx,\r\nipw->u.crypt.idx,\r\nieee->group_key_type,\r\nbroadcast_addr,\r\n0,\r\nkey);\r\n}\r\n}\r\n}\r\nret = ieee80211_wpa_supplicant_ioctl(priv->ieee80211, &wrq->u.data);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nkfree(ipw);\r\nipw = NULL;\r\nout:\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic u8 HwRateToMRate90(bool bIsHT, u8 rate)\r\n{\r\nu8 ret_rate = 0xff;\r\nif (!bIsHT) {\r\nswitch (rate) {\r\ncase DESC90_RATE1M:\r\nret_rate = MGN_1M;\r\nbreak;\r\ncase DESC90_RATE2M:\r\nret_rate = MGN_2M;\r\nbreak;\r\ncase DESC90_RATE5_5M:\r\nret_rate = MGN_5_5M;\r\nbreak;\r\ncase DESC90_RATE11M:\r\nret_rate = MGN_11M;\r\nbreak;\r\ncase DESC90_RATE6M:\r\nret_rate = MGN_6M;\r\nbreak;\r\ncase DESC90_RATE9M:\r\nret_rate = MGN_9M;\r\nbreak;\r\ncase DESC90_RATE12M:\r\nret_rate = MGN_12M;\r\nbreak;\r\ncase DESC90_RATE18M:\r\nret_rate = MGN_18M;\r\nbreak;\r\ncase DESC90_RATE24M:\r\nret_rate = MGN_24M;\r\nbreak;\r\ncase DESC90_RATE36M:\r\nret_rate = MGN_36M;\r\nbreak;\r\ncase DESC90_RATE48M:\r\nret_rate = MGN_48M;\r\nbreak;\r\ncase DESC90_RATE54M:\r\nret_rate = MGN_54M;\r\nbreak;\r\ndefault:\r\nret_rate = 0xff;\r\nRT_TRACE(COMP_RECV, "HwRateToMRate90(): Non supported Rate [%x], bIsHT = %d!!!\n", rate, bIsHT);\r\nbreak;\r\n}\r\n} else {\r\nswitch (rate) {\r\ncase DESC90_RATEMCS0:\r\nret_rate = MGN_MCS0;\r\nbreak;\r\ncase DESC90_RATEMCS1:\r\nret_rate = MGN_MCS1;\r\nbreak;\r\ncase DESC90_RATEMCS2:\r\nret_rate = MGN_MCS2;\r\nbreak;\r\ncase DESC90_RATEMCS3:\r\nret_rate = MGN_MCS3;\r\nbreak;\r\ncase DESC90_RATEMCS4:\r\nret_rate = MGN_MCS4;\r\nbreak;\r\ncase DESC90_RATEMCS5:\r\nret_rate = MGN_MCS5;\r\nbreak;\r\ncase DESC90_RATEMCS6:\r\nret_rate = MGN_MCS6;\r\nbreak;\r\ncase DESC90_RATEMCS7:\r\nret_rate = MGN_MCS7;\r\nbreak;\r\ncase DESC90_RATEMCS8:\r\nret_rate = MGN_MCS8;\r\nbreak;\r\ncase DESC90_RATEMCS9:\r\nret_rate = MGN_MCS9;\r\nbreak;\r\ncase DESC90_RATEMCS10:\r\nret_rate = MGN_MCS10;\r\nbreak;\r\ncase DESC90_RATEMCS11:\r\nret_rate = MGN_MCS11;\r\nbreak;\r\ncase DESC90_RATEMCS12:\r\nret_rate = MGN_MCS12;\r\nbreak;\r\ncase DESC90_RATEMCS13:\r\nret_rate = MGN_MCS13;\r\nbreak;\r\ncase DESC90_RATEMCS14:\r\nret_rate = MGN_MCS14;\r\nbreak;\r\ncase DESC90_RATEMCS15:\r\nret_rate = MGN_MCS15;\r\nbreak;\r\ncase DESC90_RATEMCS32:\r\nret_rate = (0x80|0x20);\r\nbreak;\r\ndefault:\r\nret_rate = 0xff;\r\nRT_TRACE(COMP_RECV, "HwRateToMRate90(): Non supported Rate [%x], bIsHT = %d!!!\n", rate, bIsHT);\r\nbreak;\r\n}\r\n}\r\nreturn ret_rate;\r\n}\r\nstatic void UpdateRxPktTimeStamp8190(struct net_device *dev,\r\nstruct ieee80211_rx_stats *stats)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nif (stats->bIsAMPDU && !stats->bFirstMPDU) {\r\nstats->mac_time[0] = priv->LastRxDescTSFLow;\r\nstats->mac_time[1] = priv->LastRxDescTSFHigh;\r\n} else {\r\npriv->LastRxDescTSFLow = stats->mac_time[0];\r\npriv->LastRxDescTSFHigh = stats->mac_time[1];\r\n}\r\n}\r\nstatic long rtl819x_translate_todbm(u8 signal_strength_index)\r\n{\r\nlong signal_power;\r\nsignal_power = (long)((signal_strength_index + 1) >> 1);\r\nsignal_power -= 95;\r\nreturn signal_power;\r\n}\r\nstatic void rtl8192_process_phyinfo(struct r8192_priv *priv, u8 *buffer,\r\nstruct ieee80211_rx_stats *pprevious_stats,\r\nstruct ieee80211_rx_stats *pcurrent_stats)\r\n{\r\nbool bcheck = false;\r\nu8 rfpath;\r\nu32 nspatial_stream, tmp_val;\r\nstatic u32 slide_rssi_index, slide_rssi_statistics;\r\nstatic u32 slide_evm_index, slide_evm_statistics;\r\nstatic u32 last_rssi, last_evm;\r\nstatic u32 slide_beacon_adc_pwdb_index, slide_beacon_adc_pwdb_statistics;\r\nstatic u32 last_beacon_adc_pwdb;\r\nstruct ieee80211_hdr_3addr *hdr;\r\nu16 sc;\r\nunsigned int frag, seq;\r\nhdr = (struct ieee80211_hdr_3addr *)buffer;\r\nsc = le16_to_cpu(hdr->seq_ctl);\r\nfrag = WLAN_GET_SEQ_FRAG(sc);\r\nseq = WLAN_GET_SEQ_SEQ(sc);\r\npcurrent_stats->Seq_Num = seq;\r\nif (!pprevious_stats->bIsAMPDU) {\r\nbcheck = true;\r\n}\r\nif (slide_rssi_statistics++ >= PHY_RSSI_SLID_WIN_MAX) {\r\nslide_rssi_statistics = PHY_RSSI_SLID_WIN_MAX;\r\nlast_rssi = priv->stats.slide_signal_strength[slide_rssi_index];\r\npriv->stats.slide_rssi_total -= last_rssi;\r\n}\r\npriv->stats.slide_rssi_total += pprevious_stats->SignalStrength;\r\npriv->stats.slide_signal_strength[slide_rssi_index++] = pprevious_stats->SignalStrength;\r\nif (slide_rssi_index >= PHY_RSSI_SLID_WIN_MAX)\r\nslide_rssi_index = 0;\r\ntmp_val = priv->stats.slide_rssi_total/slide_rssi_statistics;\r\npriv->stats.signal_strength = rtl819x_translate_todbm((u8)tmp_val);\r\npcurrent_stats->rssi = priv->stats.signal_strength;\r\nif (!pprevious_stats->bPacketMatchBSSID) {\r\nif (!pprevious_stats->bToSelfBA)\r\nreturn;\r\n}\r\nif (!bcheck)\r\nreturn;\r\npriv->stats.num_process_phyinfo++;\r\nif (!pprevious_stats->bIsCCK && (pprevious_stats->bPacketToSelf || pprevious_stats->bToSelfBA)) {\r\nfor (rfpath = RF90_PATH_A; rfpath < priv->NumTotalRFPath; rfpath++) {\r\nif (!rtl8192_phy_CheckIsLegalRFPath(priv->ieee80211->dev, rfpath))\r\ncontinue;\r\nif (priv->stats.rx_rssi_percentage[rfpath] == 0)\r\npriv->stats.rx_rssi_percentage[rfpath] = pprevious_stats->RxMIMOSignalStrength[rfpath];\r\nif (pprevious_stats->RxMIMOSignalStrength[rfpath] > priv->stats.rx_rssi_percentage[rfpath]) {\r\npriv->stats.rx_rssi_percentage[rfpath] =\r\n((priv->stats.rx_rssi_percentage[rfpath]*(Rx_Smooth_Factor-1)) +\r\n(pprevious_stats->RxMIMOSignalStrength[rfpath])) /(Rx_Smooth_Factor);\r\npriv->stats.rx_rssi_percentage[rfpath] = priv->stats.rx_rssi_percentage[rfpath] + 1;\r\n} else {\r\npriv->stats.rx_rssi_percentage[rfpath] =\r\n((priv->stats.rx_rssi_percentage[rfpath]*(Rx_Smooth_Factor-1)) +\r\n(pprevious_stats->RxMIMOSignalStrength[rfpath])) /(Rx_Smooth_Factor);\r\n}\r\nRT_TRACE(COMP_DBG, "priv->stats.rx_rssi_percentage[rfPath] = %d \n", priv->stats.rx_rssi_percentage[rfpath]);\r\n}\r\n}\r\nRT_TRACE(COMP_RXDESC, "Smooth %s PWDB = %d\n",\r\npprevious_stats->bIsCCK ? "CCK" : "OFDM",\r\npprevious_stats->RxPWDBAll);\r\nif (pprevious_stats->bPacketBeacon) {\r\nif (slide_beacon_adc_pwdb_statistics++ >= PHY_Beacon_RSSI_SLID_WIN_MAX) {\r\nslide_beacon_adc_pwdb_statistics = PHY_Beacon_RSSI_SLID_WIN_MAX;\r\nlast_beacon_adc_pwdb = priv->stats.Slide_Beacon_pwdb[slide_beacon_adc_pwdb_index];\r\npriv->stats.Slide_Beacon_Total -= last_beacon_adc_pwdb;\r\n}\r\npriv->stats.Slide_Beacon_Total += pprevious_stats->RxPWDBAll;\r\npriv->stats.Slide_Beacon_pwdb[slide_beacon_adc_pwdb_index] = pprevious_stats->RxPWDBAll;\r\nslide_beacon_adc_pwdb_index++;\r\nif (slide_beacon_adc_pwdb_index >= PHY_Beacon_RSSI_SLID_WIN_MAX)\r\nslide_beacon_adc_pwdb_index = 0;\r\npprevious_stats->RxPWDBAll = priv->stats.Slide_Beacon_Total/slide_beacon_adc_pwdb_statistics;\r\nif (pprevious_stats->RxPWDBAll >= 3)\r\npprevious_stats->RxPWDBAll -= 3;\r\n}\r\nRT_TRACE(COMP_RXDESC, "Smooth %s PWDB = %d\n",\r\npprevious_stats->bIsCCK ? "CCK" : "OFDM",\r\npprevious_stats->RxPWDBAll);\r\nif (pprevious_stats->bPacketToSelf || pprevious_stats->bPacketBeacon || pprevious_stats->bToSelfBA) {\r\nif (priv->undecorated_smoothed_pwdb < 0)\r\npriv->undecorated_smoothed_pwdb = pprevious_stats->RxPWDBAll;\r\nif (pprevious_stats->RxPWDBAll > (u32)priv->undecorated_smoothed_pwdb) {\r\npriv->undecorated_smoothed_pwdb =\r\n(((priv->undecorated_smoothed_pwdb)*(Rx_Smooth_Factor-1)) +\r\n(pprevious_stats->RxPWDBAll)) /(Rx_Smooth_Factor);\r\npriv->undecorated_smoothed_pwdb = priv->undecorated_smoothed_pwdb + 1;\r\n} else {\r\npriv->undecorated_smoothed_pwdb =\r\n(((priv->undecorated_smoothed_pwdb)*(Rx_Smooth_Factor-1)) +\r\n(pprevious_stats->RxPWDBAll)) /(Rx_Smooth_Factor);\r\n}\r\n}\r\nif (pprevious_stats->SignalQuality) {\r\nif (pprevious_stats->bPacketToSelf || pprevious_stats->bPacketBeacon || pprevious_stats->bToSelfBA) {\r\nif (slide_evm_statistics++ >= PHY_RSSI_SLID_WIN_MAX) {\r\nslide_evm_statistics = PHY_RSSI_SLID_WIN_MAX;\r\nlast_evm = priv->stats.slide_evm[slide_evm_index];\r\npriv->stats.slide_evm_total -= last_evm;\r\n}\r\npriv->stats.slide_evm_total += pprevious_stats->SignalQuality;\r\npriv->stats.slide_evm[slide_evm_index++] = pprevious_stats->SignalQuality;\r\nif (slide_evm_index >= PHY_RSSI_SLID_WIN_MAX)\r\nslide_evm_index = 0;\r\ntmp_val = priv->stats.slide_evm_total/slide_evm_statistics;\r\npriv->stats.signal_quality = tmp_val;\r\npriv->stats.last_signal_strength_inpercent = tmp_val;\r\n}\r\nif (pprevious_stats->bPacketToSelf || pprevious_stats->bPacketBeacon || pprevious_stats->bToSelfBA) {\r\nfor (nspatial_stream = 0; nspatial_stream < 2; nspatial_stream++) {\r\nif (pprevious_stats->RxMIMOSignalQuality[nspatial_stream] != -1) {\r\nif (priv->stats.rx_evm_percentage[nspatial_stream] == 0)\r\npriv->stats.rx_evm_percentage[nspatial_stream] = pprevious_stats->RxMIMOSignalQuality[nspatial_stream];\r\npriv->stats.rx_evm_percentage[nspatial_stream] =\r\n((priv->stats.rx_evm_percentage[nspatial_stream]* (Rx_Smooth_Factor-1)) +\r\n(pprevious_stats->RxMIMOSignalQuality[nspatial_stream]* 1)) / (Rx_Smooth_Factor);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic u8 rtl819x_query_rxpwrpercentage(char antpower)\r\n{\r\nif ((antpower <= -100) || (antpower >= 20))\r\nreturn 0;\r\nelse if (antpower >= 0)\r\nreturn 100;\r\nelse\r\nreturn 100 + antpower;\r\n}\r\nstatic u8 rtl819x_evm_dbtopercentage(char value)\r\n{\r\nchar ret_val;\r\nret_val = value;\r\nif (ret_val >= 0)\r\nret_val = 0;\r\nif (ret_val <= -33)\r\nret_val = -33;\r\nret_val = 0 - ret_val;\r\nret_val *= 3;\r\nif (ret_val == 99)\r\nret_val = 100;\r\nreturn ret_val;\r\n}\r\nstatic long rtl819x_signal_scale_mapping(long currsig)\r\n{\r\nlong retsig;\r\nif (currsig >= 61 && currsig <= 100)\r\nretsig = 90 + ((currsig - 60) / 4);\r\nelse if (currsig >= 41 && currsig <= 60)\r\nretsig = 78 + ((currsig - 40) / 2);\r\nelse if (currsig >= 31 && currsig <= 40)\r\nretsig = 66 + (currsig - 30);\r\nelse if (currsig >= 21 && currsig <= 30)\r\nretsig = 54 + (currsig - 20);\r\nelse if (currsig >= 5 && currsig <= 20)\r\nretsig = 42 + (((currsig - 5) * 2) / 3);\r\nelse if (currsig == 4)\r\nretsig = 36;\r\nelse if (currsig == 3)\r\nretsig = 27;\r\nelse if (currsig == 2)\r\nretsig = 18;\r\nelse if (currsig == 1)\r\nretsig = 9;\r\nelse\r\nretsig = currsig;\r\nreturn retsig;\r\n}\r\nstatic inline bool rx_hal_is_cck_rate(struct rx_drvinfo_819x_usb *pdrvinfo)\r\n{\r\nif (pdrvinfo->RxHT)\r\nreturn false;\r\nswitch (pdrvinfo->RxRate) {\r\ncase DESC90_RATE1M:\r\ncase DESC90_RATE2M:\r\ncase DESC90_RATE5_5M:\r\ncase DESC90_RATE11M:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic void rtl8192_query_rxphystatus(struct r8192_priv *priv,\r\nstruct ieee80211_rx_stats *pstats,\r\nrx_drvinfo_819x_usb *pdrvinfo,\r\nstruct ieee80211_rx_stats *precord_stats,\r\nbool bpacket_match_bssid,\r\nbool bpacket_toself,\r\nbool bPacketBeacon,\r\nbool bToSelfBA)\r\n{\r\nphy_sts_ofdm_819xusb_t *pofdm_buf;\r\nphy_sts_cck_819xusb_t *pcck_buf;\r\nphy_ofdm_rx_status_rxsc_sgien_exintfflag *prxsc;\r\nu8 *prxpkt;\r\nu8 i, max_spatial_stream, tmp_rxsnr, tmp_rxevm, rxsc_sgien_exflg;\r\nchar rx_pwr[4], rx_pwr_all = 0;\r\nchar rx_snrX, rx_evmX;\r\nu8 evm, pwdb_all;\r\nu32 RSSI, total_rssi = 0;\r\nu8 is_cck_rate = 0;\r\nu8 rf_rx_num = 0;\r\nu8 sq;\r\npriv->stats.numqry_phystatus++;\r\nis_cck_rate = rx_hal_is_cck_rate(pdrvinfo);\r\nmemset(precord_stats, 0, sizeof(struct ieee80211_rx_stats));\r\npstats->bPacketMatchBSSID = precord_stats->bPacketMatchBSSID = bpacket_match_bssid;\r\npstats->bPacketToSelf = precord_stats->bPacketToSelf = bpacket_toself;\r\npstats->bIsCCK = precord_stats->bIsCCK = is_cck_rate;\r\npstats->bPacketBeacon = precord_stats->bPacketBeacon = bPacketBeacon;\r\npstats->bToSelfBA = precord_stats->bToSelfBA = bToSelfBA;\r\nprxpkt = (u8 *)pdrvinfo;\r\nprxpkt += sizeof(rx_drvinfo_819x_usb);\r\npcck_buf = (phy_sts_cck_819xusb_t *)prxpkt;\r\npofdm_buf = (phy_sts_ofdm_819xusb_t *)prxpkt;\r\npstats->RxMIMOSignalQuality[0] = -1;\r\npstats->RxMIMOSignalQuality[1] = -1;\r\nprecord_stats->RxMIMOSignalQuality[0] = -1;\r\nprecord_stats->RxMIMOSignalQuality[1] = -1;\r\nif (is_cck_rate) {\r\nu8 report;\r\npriv->stats.numqry_phystatusCCK++;\r\nif (!priv->bCckHighPower) {\r\nreport = pcck_buf->cck_agc_rpt & 0xc0;\r\nreport = report>>6;\r\nswitch (report) {\r\ncase 0x3:\r\nrx_pwr_all = -35 - (pcck_buf->cck_agc_rpt & 0x3e);\r\nbreak;\r\ncase 0x2:\r\nrx_pwr_all = -23 - (pcck_buf->cck_agc_rpt & 0x3e);\r\nbreak;\r\ncase 0x1:\r\nrx_pwr_all = -11 - (pcck_buf->cck_agc_rpt & 0x3e);\r\nbreak;\r\ncase 0x0:\r\nrx_pwr_all = 6 - (pcck_buf->cck_agc_rpt & 0x3e);\r\nbreak;\r\n}\r\n} else {\r\nreport = pcck_buf->cck_agc_rpt & 0x60;\r\nreport = report>>5;\r\nswitch (report) {\r\ncase 0x3:\r\nrx_pwr_all = -35 - ((pcck_buf->cck_agc_rpt & 0x1f)<<1);\r\nbreak;\r\ncase 0x2:\r\nrx_pwr_all = -23 - ((pcck_buf->cck_agc_rpt & 0x1f)<<1);\r\nbreak;\r\ncase 0x1:\r\nrx_pwr_all = -11 - ((pcck_buf->cck_agc_rpt & 0x1f)<<1);\r\nbreak;\r\ncase 0x0:\r\nrx_pwr_all = 6 - ((pcck_buf->cck_agc_rpt & 0x1f)<<1);\r\nbreak;\r\n}\r\n}\r\npwdb_all = rtl819x_query_rxpwrpercentage(rx_pwr_all);\r\npstats->RxPWDBAll = precord_stats->RxPWDBAll = pwdb_all;\r\npstats->RecvSignalPower = pwdb_all;\r\nif (pstats->RxPWDBAll > 40) {\r\nsq = 100;\r\n} else {\r\nsq = pcck_buf->sq_rpt;\r\nif (pcck_buf->sq_rpt > 64)\r\nsq = 0;\r\nelse if (pcck_buf->sq_rpt < 20)\r\nsq = 100;\r\nelse\r\nsq = ((64-sq) * 100) / 44;\r\n}\r\npstats->SignalQuality = precord_stats->SignalQuality = sq;\r\npstats->RxMIMOSignalQuality[0] = precord_stats->RxMIMOSignalQuality[0] = sq;\r\npstats->RxMIMOSignalQuality[1] = precord_stats->RxMIMOSignalQuality[1] = -1;\r\n} else {\r\npriv->stats.numqry_phystatusHT++;\r\nfor (i = RF90_PATH_A; i < priv->NumTotalRFPath; i++) {\r\nif (priv->brfpath_rxenable[i])\r\nrf_rx_num++;\r\nelse\r\ncontinue;\r\nif (!rtl8192_phy_CheckIsLegalRFPath(priv->ieee80211->dev, i))\r\ncontinue;\r\nrx_pwr[i] = ((pofdm_buf->trsw_gain_X[i]&0x3F)*2) - 106;\r\ntmp_rxsnr = pofdm_buf->rxsnr_X[i];\r\nrx_snrX = (char)(tmp_rxsnr);\r\nrx_snrX /= 2;\r\npriv->stats.rxSNRdB[i] = (long)rx_snrX;\r\nRSSI = rtl819x_query_rxpwrpercentage(rx_pwr[i]);\r\ntotal_rssi += RSSI;\r\npstats->RxMIMOSignalStrength[i] = (u8) RSSI;\r\nprecord_stats->RxMIMOSignalStrength[i] = (u8) RSSI;\r\n}\r\nrx_pwr_all = (((pofdm_buf->pwdb_all) >> 1)& 0x7f) -106;\r\npwdb_all = rtl819x_query_rxpwrpercentage(rx_pwr_all);\r\npstats->RxPWDBAll = precord_stats->RxPWDBAll = pwdb_all;\r\npstats->RxPower = precord_stats->RxPower = rx_pwr_all;\r\nif (pdrvinfo->RxHT && pdrvinfo->RxRate >= DESC90_RATEMCS8 &&\r\npdrvinfo->RxRate <= DESC90_RATEMCS15)\r\nmax_spatial_stream = 2;\r\nelse\r\nmax_spatial_stream = 1;\r\nfor (i = 0; i < max_spatial_stream; i++) {\r\ntmp_rxevm = pofdm_buf->rxevm_X[i];\r\nrx_evmX = (char)(tmp_rxevm);\r\nrx_evmX /= 2;\r\nevm = rtl819x_evm_dbtopercentage(rx_evmX);\r\nif (i == 0)\r\npstats->SignalQuality = precord_stats->SignalQuality = (u8)(evm & 0xff);\r\npstats->RxMIMOSignalQuality[i] = precord_stats->RxMIMOSignalQuality[i] = (u8)(evm & 0xff);\r\n}\r\nrxsc_sgien_exflg = pofdm_buf->rxsc_sgien_exflg;\r\nprxsc = (phy_ofdm_rx_status_rxsc_sgien_exintfflag *)&rxsc_sgien_exflg;\r\nif (pdrvinfo->BW)\r\npriv->stats.received_bwtype[1+prxsc->rxsc]++;\r\nelse\r\npriv->stats.received_bwtype[0]++;\r\n}\r\nif (is_cck_rate) {\r\npstats->SignalStrength = precord_stats->SignalStrength = (u8)(rtl819x_signal_scale_mapping((long)pwdb_all));\r\n} else {\r\nif (rf_rx_num != 0)\r\npstats->SignalStrength = precord_stats->SignalStrength = (u8)(rtl819x_signal_scale_mapping((long)(total_rssi /= rf_rx_num)));\r\n}\r\n}\r\nstatic void rtl8192_record_rxdesc_forlateruse(struct ieee80211_rx_stats *psrc_stats,\r\nstruct ieee80211_rx_stats *ptarget_stats)\r\n{\r\nptarget_stats->bIsAMPDU = psrc_stats->bIsAMPDU;\r\nptarget_stats->bFirstMPDU = psrc_stats->bFirstMPDU;\r\nptarget_stats->Seq_Num = psrc_stats->Seq_Num;\r\n}\r\nstatic void TranslateRxSignalStuff819xUsb(struct sk_buff *skb,\r\nstruct ieee80211_rx_stats *pstats,\r\nrx_drvinfo_819x_usb *pdrvinfo)\r\n{\r\nrtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;\r\nstruct net_device *dev = info->dev;\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nbool bpacket_match_bssid, bpacket_toself;\r\nbool bPacketBeacon = FALSE, bToSelfBA = FALSE;\r\nstatic struct ieee80211_rx_stats previous_stats;\r\nstruct ieee80211_hdr_3addr *hdr;\r\nu16 fc, type;\r\nu8 *tmp_buf;\r\nu8 *praddr;\r\ntmp_buf = (u8 *)skb->data;\r\nhdr = (struct ieee80211_hdr_3addr *)tmp_buf;\r\nfc = le16_to_cpu(hdr->frame_ctl);\r\ntype = WLAN_FC_GET_TYPE(fc);\r\npraddr = hdr->addr1;\r\nbpacket_match_bssid = ((IEEE80211_FTYPE_CTL != type) &&\r\n(eqMacAddr(priv->ieee80211->current_network.bssid, (fc & IEEE80211_FCTL_TODS) ? hdr->addr1 : (fc & IEEE80211_FCTL_FROMDS) ? hdr->addr2 : hdr->addr3))\r\n&& (!pstats->bHwError) && (!pstats->bCRC) && (!pstats->bICV));\r\nbpacket_toself = bpacket_match_bssid & (eqMacAddr(praddr, priv->ieee80211->dev->dev_addr));\r\nif (WLAN_FC_GET_FRAMETYPE(fc) == IEEE80211_STYPE_BEACON)\r\nbPacketBeacon = true;\r\nif (WLAN_FC_GET_FRAMETYPE(fc) == IEEE80211_STYPE_BLOCKACK) {\r\nif ((eqMacAddr(praddr, dev->dev_addr)))\r\nbToSelfBA = true;\r\n}\r\nif (bpacket_match_bssid)\r\npriv->stats.numpacket_matchbssid++;\r\nif (bpacket_toself)\r\npriv->stats.numpacket_toself++;\r\nrtl8192_process_phyinfo(priv, tmp_buf, &previous_stats, pstats);\r\nrtl8192_query_rxphystatus(priv, pstats, pdrvinfo, &previous_stats, bpacket_match_bssid, bpacket_toself, bPacketBeacon, bToSelfBA);\r\nrtl8192_record_rxdesc_forlateruse(pstats, &previous_stats);\r\n}\r\nstatic void\r\nUpdateReceivedRateHistogramStatistics8190(struct net_device *dev,\r\nstruct ieee80211_rx_stats *stats)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nu32 rcvType = 1;\r\nu32 rateIndex;\r\nu32 preamble_guardinterval;\r\nif (stats->bCRC)\r\nrcvType = 2;\r\nelse if (stats->bICV)\r\nrcvType = 3;\r\nif (stats->bShortPreamble)\r\npreamble_guardinterval = 1;\r\nelse\r\npreamble_guardinterval = 0;\r\nswitch (stats->rate) {\r\ncase MGN_1M:\r\nrateIndex = 0;\r\nbreak;\r\ncase MGN_2M:\r\nrateIndex = 1;\r\nbreak;\r\ncase MGN_5_5M:\r\nrateIndex = 2;\r\nbreak;\r\ncase MGN_11M:\r\nrateIndex = 3;\r\nbreak;\r\ncase MGN_6M:\r\nrateIndex = 4;\r\nbreak;\r\ncase MGN_9M:\r\nrateIndex = 5;\r\nbreak;\r\ncase MGN_12M:\r\nrateIndex = 6;\r\nbreak;\r\ncase MGN_18M:\r\nrateIndex = 7;\r\nbreak;\r\ncase MGN_24M:\r\nrateIndex = 8;\r\nbreak;\r\ncase MGN_36M:\r\nrateIndex = 9;\r\nbreak;\r\ncase MGN_48M:\r\nrateIndex = 10;\r\nbreak;\r\ncase MGN_54M:\r\nrateIndex = 11;\r\nbreak;\r\ncase MGN_MCS0:\r\nrateIndex = 12;\r\nbreak;\r\ncase MGN_MCS1:\r\nrateIndex = 13;\r\nbreak;\r\ncase MGN_MCS2:\r\nrateIndex = 14;\r\nbreak;\r\ncase MGN_MCS3:\r\nrateIndex = 15;\r\nbreak;\r\ncase MGN_MCS4:\r\nrateIndex = 16;\r\nbreak;\r\ncase MGN_MCS5:\r\nrateIndex = 17;\r\nbreak;\r\ncase MGN_MCS6:\r\nrateIndex = 18;\r\nbreak;\r\ncase MGN_MCS7:\r\nrateIndex = 19;\r\nbreak;\r\ncase MGN_MCS8:\r\nrateIndex = 20;\r\nbreak;\r\ncase MGN_MCS9:\r\nrateIndex = 21;\r\nbreak;\r\ncase MGN_MCS10:\r\nrateIndex = 22;\r\nbreak;\r\ncase MGN_MCS11:\r\nrateIndex = 23;\r\nbreak;\r\ncase MGN_MCS12:\r\nrateIndex = 24;\r\nbreak;\r\ncase MGN_MCS13:\r\nrateIndex = 25;\r\nbreak;\r\ncase MGN_MCS14:\r\nrateIndex = 26;\r\nbreak;\r\ncase MGN_MCS15:\r\nrateIndex = 27;\r\nbreak;\r\ndefault:\r\nrateIndex = 28;\r\nbreak;\r\n}\r\npriv->stats.received_preamble_GI[preamble_guardinterval][rateIndex]++;\r\npriv->stats.received_rate_histogram[0][rateIndex]++;\r\npriv->stats.received_rate_histogram[rcvType][rateIndex]++;\r\n}\r\nstatic void query_rxdesc_status(struct sk_buff *skb,\r\nstruct ieee80211_rx_stats *stats,\r\nbool bIsRxAggrSubframe)\r\n{\r\nrtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;\r\nstruct net_device *dev = info->dev;\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nrx_drvinfo_819x_usb *driver_info = NULL;\r\nrx_desc_819x_usb *desc = (rx_desc_819x_usb *)skb->data;\r\nstats->Length = desc->Length;\r\nstats->RxDrvInfoSize = desc->RxDrvInfoSize;\r\nstats->RxBufShift = 0;\r\nstats->bICV = desc->ICV;\r\nstats->bCRC = desc->CRC32;\r\nstats->bHwError = stats->bCRC|stats->bICV;\r\nstats->Decrypted = !desc->SWDec;\r\nif ((priv->ieee80211->pHTInfo->bCurrentHTSupport == true) && (priv->ieee80211->pairwise_key_type == KEY_TYPE_CCMP))\r\nstats->bHwError = false;\r\nelse\r\nstats->bHwError = stats->bCRC|stats->bICV;\r\nif (stats->Length < 24 || stats->Length > MAX_8192U_RX_SIZE)\r\nstats->bHwError |= 1;\r\nif (stats->RxDrvInfoSize != 0) {\r\ndriver_info = (rx_drvinfo_819x_usb *)(skb->data + sizeof(rx_desc_819x_usb) +\r\nstats->RxBufShift);\r\nif (!stats->bHwError) {\r\nu8 ret_rate;\r\nret_rate = HwRateToMRate90(driver_info->RxHT, driver_info->RxRate);\r\nif (ret_rate == 0xff) {\r\nstats->bHwError = 1;\r\nstats->rate = MGN_1M;\r\n} else {\r\nstats->rate = ret_rate;\r\n}\r\n} else {\r\nstats->rate = 0x02;\r\n}\r\nstats->bShortPreamble = driver_info->SPLCP;\r\nUpdateReceivedRateHistogramStatistics8190(dev, stats);\r\nstats->bIsAMPDU = (driver_info->PartAggr == 1);\r\nstats->bFirstMPDU = (driver_info->PartAggr == 1) && (driver_info->FirstAGGR == 1);\r\nstats->TimeStampLow = driver_info->TSFL;\r\nUpdateRxPktTimeStamp8190(dev, stats);\r\nif (driver_info->FirstAGGR == 1 || driver_info->PartAggr == 1)\r\nRT_TRACE(COMP_RXDESC, "driver_info->FirstAGGR = %d, driver_info->PartAggr = %d\n",\r\ndriver_info->FirstAGGR, driver_info->PartAggr);\r\n}\r\nskb_pull(skb, sizeof(rx_desc_819x_usb));\r\nif ((stats->RxBufShift + stats->RxDrvInfoSize) > 0) {\r\nstats->bShift = 1;\r\nskb_pull(skb, stats->RxBufShift + stats->RxDrvInfoSize);\r\n}\r\nstats->RxIs40MHzPacket = driver_info->BW;\r\nif (stats->RxDrvInfoSize != 0)\r\nTranslateRxSignalStuff819xUsb(skb, stats, driver_info);\r\n}\r\nstatic void rtl8192_rx_nomal(struct sk_buff *skb)\r\n{\r\nrtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;\r\nstruct net_device *dev = info->dev;\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nstruct ieee80211_rx_stats stats = {\r\n.signal = 0,\r\n.noise = -98,\r\n.rate = 0,\r\n.freq = IEEE80211_24GHZ_BAND,\r\n};\r\nu32 rx_pkt_len = 0;\r\nstruct ieee80211_hdr_1addr *ieee80211_hdr = NULL;\r\nbool unicast_packet = false;\r\nif ((skb->len >= (20 + sizeof(rx_desc_819x_usb))) && (skb->len < RX_URB_SIZE)) {\r\nquery_rxdesc_status(skb, &stats, false);\r\nskb_trim(skb, skb->len - 4);\r\nrx_pkt_len = skb->len;\r\nieee80211_hdr = (struct ieee80211_hdr_1addr *)skb->data;\r\nunicast_packet = false;\r\nif (is_broadcast_ether_addr(ieee80211_hdr->addr1)) {\r\n} else if (is_multicast_ether_addr(ieee80211_hdr->addr1)) {\r\n} else {\r\nunicast_packet = true;\r\n}\r\nif (!ieee80211_rx(priv->ieee80211, skb, &stats)) {\r\ndev_kfree_skb_any(skb);\r\n} else {\r\npriv->stats.rxoktotal++;\r\nif (unicast_packet)\r\npriv->stats.rxbytesunicast += rx_pkt_len;\r\n}\r\n} else {\r\npriv->stats.rxurberr++;\r\nnetdev_dbg(dev, "actual_length: %d\n", skb->len);\r\ndev_kfree_skb_any(skb);\r\n}\r\n}\r\nstatic void rtl819xusb_process_received_packet(struct net_device *dev,\r\nstruct ieee80211_rx_stats *pstats)\r\n{\r\nu8 *frame;\r\nu16 frame_len = 0;\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\npstats->virtual_address += get_rxpacket_shiftbytes_819xusb(pstats);\r\nframe = pstats->virtual_address;\r\nframe_len = pstats->packetlength;\r\n#ifdef TODO\r\nif (!Adapter->bInHctTest)\r\nCountRxErrStatistics(Adapter, pRfd);\r\n#endif\r\n#ifdef ENABLE_PS\r\nRT_RF_POWER_STATE rtState;\r\nAdapter->HalFunc.GetHwRegHandler(Adapter, HW_VAR_RF_STATE, (u8 *)(&rtState));\r\nif (rtState == eRfOff)\r\nreturn;\r\n#endif\r\npriv->stats.rxframgment++;\r\n#ifdef TODO\r\nRmMonitorSignalStrength(Adapter, pRfd);\r\n#endif\r\nif (rtl819xusb_rx_command_packet(dev, pstats))\r\nreturn;\r\n#ifdef SW_CRC_CHECK\r\nSwCrcCheck();\r\n#endif\r\n}\r\nstatic void query_rx_cmdpkt_desc_status(struct sk_buff *skb,\r\nstruct ieee80211_rx_stats *stats)\r\n{\r\nrx_desc_819x_usb *desc = (rx_desc_819x_usb *)skb->data;\r\nstats->virtual_address = (u8 *)skb->data;\r\nstats->Length = desc->Length;\r\nstats->RxDrvInfoSize = 0;\r\nstats->RxBufShift = 0;\r\nstats->packetlength = stats->Length-scrclng;\r\nstats->fraglength = stats->packetlength;\r\nstats->fragoffset = 0;\r\nstats->ntotalfrag = 1;\r\n}\r\nstatic void rtl8192_rx_cmd(struct sk_buff *skb)\r\n{\r\nstruct rtl8192_rx_info *info = (struct rtl8192_rx_info *)skb->cb;\r\nstruct net_device *dev = info->dev;\r\nstruct ieee80211_rx_stats stats = {\r\n.signal = 0,\r\n.noise = -98,\r\n.rate = 0,\r\n.freq = IEEE80211_24GHZ_BAND,\r\n};\r\nif ((skb->len >= (20 + sizeof(rx_desc_819x_usb))) && (skb->len < RX_URB_SIZE)) {\r\nquery_rx_cmdpkt_desc_status(skb, &stats);\r\nrtl819xusb_process_received_packet(dev, &stats);\r\ndev_kfree_skb_any(skb);\r\n}\r\n}\r\nvoid rtl8192_irq_rx_tasklet(struct r8192_priv *priv)\r\n{\r\nstruct sk_buff *skb;\r\nstruct rtl8192_rx_info *info;\r\nwhile (NULL != (skb = skb_dequeue(&priv->skb_queue))) {\r\ninfo = (struct rtl8192_rx_info *)skb->cb;\r\nswitch (info->out_pipe) {\r\ncase 3:\r\npriv->IrpPendingCount--;\r\nrtl8192_rx_nomal(skb);\r\nbreak;\r\ncase 9:\r\nRT_TRACE(COMP_RECV, "command in-pipe index(%d)\n",\r\ninfo->out_pipe);\r\nrtl8192_rx_cmd(skb);\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "Unknown in-pipe index(%d)\n",\r\ninfo->out_pipe);\r\ndev_kfree_skb(skb);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int rtl8192_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct net_device *dev = NULL;\r\nstruct r8192_priv *priv = NULL;\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nint ret;\r\nRT_TRACE(COMP_INIT, "Oops: i'm coming\n");\r\ndev = alloc_ieee80211(sizeof(struct r8192_priv));\r\nif (dev == NULL)\r\nreturn -ENOMEM;\r\nusb_set_intfdata(intf, dev);\r\nSET_NETDEV_DEV(dev, &intf->dev);\r\npriv = ieee80211_priv(dev);\r\npriv->ieee80211 = netdev_priv(dev);\r\npriv->udev = udev;\r\ndev->netdev_ops = &rtl8192_netdev_ops;\r\ndev->wireless_handlers = (struct iw_handler_def *) &r8192_wx_handlers_def;\r\ndev->type = ARPHRD_ETHER;\r\ndev->watchdog_timeo = HZ*3;\r\nif (dev_alloc_name(dev, ifname) < 0) {\r\nRT_TRACE(COMP_INIT, "Oops: devname already taken! Trying wlan%%d...\n");\r\nifname = "wlan%d";\r\ndev_alloc_name(dev, ifname);\r\n}\r\nRT_TRACE(COMP_INIT, "Driver probe completed1\n");\r\nif (rtl8192_init(dev) != 0) {\r\nRT_TRACE(COMP_ERR, "Initialization failed");\r\nret = -ENODEV;\r\ngoto fail;\r\n}\r\nnetif_carrier_off(dev);\r\nnetif_stop_queue(dev);\r\nret = register_netdev(dev);\r\nif (ret)\r\ngoto fail2;\r\nRT_TRACE(COMP_INIT, "dev name=======> %s\n", dev->name);\r\nrtl8192_proc_init_one(dev);\r\nRT_TRACE(COMP_INIT, "Driver probe completed\n");\r\nreturn 0;\r\nfail2:\r\nrtl8192_down(dev);\r\nkfree(priv->pFirmware);\r\npriv->pFirmware = NULL;\r\nrtl8192_usb_deleteendpoints(dev);\r\ndestroy_workqueue(priv->priv_wq);\r\nmdelay(10);\r\nfail:\r\nfree_ieee80211(dev);\r\nRT_TRACE(COMP_ERR, "wlan driver load failed\n");\r\nreturn ret;\r\n}\r\nvoid rtl8192_cancel_deferred_work(struct r8192_priv *priv)\r\n{\r\ncancel_work_sync(&priv->reset_wq);\r\ncancel_delayed_work(&priv->watch_dog_wq);\r\ncancel_delayed_work(&priv->update_beacon_wq);\r\ncancel_work_sync(&priv->qos_activate);\r\n}\r\nstatic void rtl8192_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct net_device *dev = usb_get_intfdata(intf);\r\nstruct r8192_priv *priv = ieee80211_priv(dev);\r\nif (dev) {\r\nunregister_netdev(dev);\r\nRT_TRACE(COMP_DOWN, "=============>wlan driver to be removed\n");\r\nrtl8192_proc_remove_one(dev);\r\nrtl8192_down(dev);\r\nkfree(priv->pFirmware);\r\npriv->pFirmware = NULL;\r\nrtl8192_usb_deleteendpoints(dev);\r\ndestroy_workqueue(priv->priv_wq);\r\nmdelay(10);\r\n}\r\nfree_ieee80211(dev);\r\nRT_TRACE(COMP_DOWN, "wlan driver removed\n");\r\n}\r\nstatic int __init rtl8192_usb_module_init(void)\r\n{\r\nint ret;\r\n#ifdef CONFIG_IEEE80211_DEBUG\r\nret = ieee80211_debug_init();\r\nif (ret) {\r\npr_err("ieee80211_debug_init() failed %d\n", ret);\r\nreturn ret;\r\n}\r\n#endif\r\nret = ieee80211_crypto_init();\r\nif (ret) {\r\npr_err("ieee80211_crypto_init() failed %d\n", ret);\r\nreturn ret;\r\n}\r\nret = ieee80211_crypto_tkip_init();\r\nif (ret) {\r\npr_err("ieee80211_crypto_tkip_init() failed %d\n", ret);\r\nreturn ret;\r\n}\r\nret = ieee80211_crypto_ccmp_init();\r\nif (ret) {\r\npr_err("ieee80211_crypto_ccmp_init() failed %d\n", ret);\r\nreturn ret;\r\n}\r\nret = ieee80211_crypto_wep_init();\r\nif (ret) {\r\npr_err("ieee80211_crypto_wep_init() failed %d\n", ret);\r\nreturn ret;\r\n}\r\npr_info("\nLinux kernel driver for RTL8192 based WLAN cards\n");\r\npr_info("Copyright (c) 2007-2008, Realsil Wlan\n");\r\nRT_TRACE(COMP_INIT, "Initializing module");\r\nRT_TRACE(COMP_INIT, "Wireless extensions version %d", WIRELESS_EXT);\r\nrtl8192_proc_module_init();\r\nreturn usb_register(&rtl8192_usb_driver);\r\n}\r\nstatic void __exit rtl8192_usb_module_exit(void)\r\n{\r\nusb_deregister(&rtl8192_usb_driver);\r\nRT_TRACE(COMP_DOWN, "Exiting");\r\n}\r\nvoid rtl8192_try_wake_queue(struct net_device *dev, int pri)\r\n{\r\nunsigned long flags;\r\nshort enough_desc;\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nspin_lock_irqsave(&priv->tx_lock, flags);\r\nenough_desc = check_nic_enough_desc(dev, pri);\r\nspin_unlock_irqrestore(&priv->tx_lock, flags);\r\nif (enough_desc)\r\nieee80211_wake_queue(priv->ieee80211);\r\n}\r\nvoid EnableHWSecurityConfig8192(struct net_device *dev)\r\n{\r\nu8 SECR_value = 0x0;\r\nstruct r8192_priv *priv = (struct r8192_priv *)ieee80211_priv(dev);\r\nstruct ieee80211_device *ieee = priv->ieee80211;\r\nSECR_value = SCR_TxEncEnable | SCR_RxDecEnable;\r\nif (((KEY_TYPE_WEP40 == ieee->pairwise_key_type) || (KEY_TYPE_WEP104 == ieee->pairwise_key_type)) && (priv->ieee80211->auth_mode != 2)) {\r\nSECR_value |= SCR_RxUseDK;\r\nSECR_value |= SCR_TxUseDK;\r\n} else if ((ieee->iw_mode == IW_MODE_ADHOC) && (ieee->pairwise_key_type & (KEY_TYPE_CCMP | KEY_TYPE_TKIP))) {\r\nSECR_value |= SCR_RxUseDK;\r\nSECR_value |= SCR_TxUseDK;\r\n}\r\nieee->hwsec_active = 1;\r\nif ((ieee->pHTInfo->IOTAction&HT_IOT_ACT_PURE_N_MODE) || !hwwep) {\r\nieee->hwsec_active = 0;\r\nSECR_value &= ~SCR_RxDecEnable;\r\n}\r\nRT_TRACE(COMP_SEC, "%s:, hwsec:%d, pairwise_key:%d, SECR_value:%x\n", __func__,\r\nieee->hwsec_active, ieee->pairwise_key_type, SECR_value);\r\nwrite_nic_byte(dev, SECR, SECR_value);\r\n}\r\nvoid setKey(struct net_device *dev, u8 EntryNo, u8 KeyIndex, u16 KeyType,\r\nu8 *MacAddr, u8 DefaultKey, u32 *KeyContent)\r\n{\r\nu32 TargetCommand = 0;\r\nu32 TargetContent = 0;\r\nu16 usConfig = 0;\r\nu8 i;\r\nif (EntryNo >= TOTAL_CAM_ENTRY)\r\nRT_TRACE(COMP_ERR, "cam entry exceeds in setKey()\n");\r\nRT_TRACE(COMP_SEC, "====>to setKey(), dev:%p, EntryNo:%d, KeyIndex:%d, KeyType:%d, MacAddr%pM\n", dev, EntryNo, KeyIndex, KeyType, MacAddr);\r\nif (DefaultKey)\r\nusConfig |= BIT15 | (KeyType<<2);\r\nelse\r\nusConfig |= BIT15 | (KeyType<<2) | KeyIndex;\r\nfor (i = 0; i < CAM_CONTENT_COUNT; i++) {\r\nTargetCommand = i+CAM_CONTENT_COUNT*EntryNo;\r\nTargetCommand |= BIT31|BIT16;\r\nif (i == 0) {\r\nTargetContent = (u32)(*(MacAddr+0)) << 16|\r\n(u32)(*(MacAddr+1)) << 24|\r\n(u32)usConfig;\r\nwrite_nic_dword(dev, WCAMI, TargetContent);\r\nwrite_nic_dword(dev, RWCAM, TargetCommand);\r\n} else if (i == 1) {\r\nTargetContent = (u32)(*(MacAddr+2)) |\r\n(u32)(*(MacAddr+3)) << 8|\r\n(u32)(*(MacAddr+4)) << 16|\r\n(u32)(*(MacAddr+5)) << 24;\r\nwrite_nic_dword(dev, WCAMI, TargetContent);\r\nwrite_nic_dword(dev, RWCAM, TargetCommand);\r\n} else {\r\nif (KeyContent != NULL) {\r\nwrite_nic_dword(dev, WCAMI, (u32)(*(KeyContent+i-2)));\r\nwrite_nic_dword(dev, RWCAM, TargetCommand);\r\n}\r\n}\r\n}\r\n}
