static inline struct vpif_disp_buffer *to_vpif_buffer(struct vb2_buffer *vb)\r\n{\r\nreturn container_of(vb, struct vpif_disp_buffer, vb);\r\n}\r\nstatic int vpif_buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct channel_obj *ch = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct common_obj *common;\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nvb2_set_plane_payload(vb, 0, common->fmt.fmt.pix.sizeimage);\r\nif (vb2_get_plane_payload(vb, 0) > vb2_plane_size(vb, 0))\r\nreturn -EINVAL;\r\nvb->v4l2_buf.field = common->fmt.fmt.pix.field;\r\nif (vb->vb2_queue->type != V4L2_BUF_TYPE_SLICED_VBI_OUTPUT) {\r\nunsigned long addr = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nif (!ISALIGNED(addr + common->ytop_off) ||\r\n!ISALIGNED(addr + common->ybtm_off) ||\r\n!ISALIGNED(addr + common->ctop_off) ||\r\n!ISALIGNED(addr + common->cbtm_off)) {\r\nvpif_err("buffer offset not aligned to 8 bytes\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpif_buffer_queue_setup(struct vb2_queue *vq,\r\nconst struct v4l2_format *fmt,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct channel_obj *ch = vb2_get_drv_priv(vq);\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (fmt && fmt->fmt.pix.sizeimage < common->fmt.fmt.pix.sizeimage)\r\nreturn -EINVAL;\r\nif (vq->num_buffers + *nbuffers < 3)\r\n*nbuffers = 3 - vq->num_buffers;\r\n*nplanes = 1;\r\nsizes[0] = fmt ? fmt->fmt.pix.sizeimage : common->fmt.fmt.pix.sizeimage;\r\nalloc_ctxs[0] = common->alloc_ctx;\r\nvpif_calculate_offsets(ch);\r\nreturn 0;\r\n}\r\nstatic void vpif_buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vpif_disp_buffer *buf = to_vpif_buffer(vb);\r\nstruct channel_obj *ch = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct common_obj *common;\r\nunsigned long flags;\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nspin_lock_irqsave(&common->irqlock, flags);\r\nlist_add_tail(&buf->list, &common->dma_queue);\r\nspin_unlock_irqrestore(&common->irqlock, flags);\r\n}\r\nstatic int vpif_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct vpif_display_config *vpif_config_data =\r\nvpif_dev->platform_data;\r\nstruct channel_obj *ch = vb2_get_drv_priv(vq);\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct vpif_params *vpif = &ch->vpifparams;\r\nstruct vpif_disp_buffer *buf, *tmp;\r\nunsigned long addr, flags;\r\nint ret;\r\nspin_lock_irqsave(&common->irqlock, flags);\r\nch->field_id = 0;\r\nif (vpif_config_data->set_clock) {\r\nret = vpif_config_data->set_clock(ch->vpifparams.std_info.\r\nycmux_mode, ch->vpifparams.std_info.hd_sd);\r\nif (ret < 0) {\r\nvpif_err("can't set clock\n");\r\ngoto err;\r\n}\r\n}\r\nret = vpif_set_video_params(vpif, ch->channel_id + 2);\r\nif (ret < 0)\r\ngoto err;\r\nycmux_mode = ret;\r\nvpif_config_addr(ch, ret);\r\ncommon->next_frm = common->cur_frm =\r\nlist_entry(common->dma_queue.next,\r\nstruct vpif_disp_buffer, list);\r\nlist_del(&common->cur_frm->list);\r\nspin_unlock_irqrestore(&common->irqlock, flags);\r\naddr = vb2_dma_contig_plane_dma_addr(&common->cur_frm->vb, 0);\r\ncommon->set_addr((addr + common->ytop_off),\r\n(addr + common->ybtm_off),\r\n(addr + common->ctop_off),\r\n(addr + common->cbtm_off));\r\nchannel_first_int[VPIF_VIDEO_INDEX][ch->channel_id] = 1;\r\nif (VPIF_CHANNEL2_VIDEO == ch->channel_id) {\r\nchannel2_intr_assert();\r\nchannel2_intr_enable(1);\r\nenable_channel2(1);\r\nif (vpif_config_data->chan_config[VPIF_CHANNEL2_VIDEO].clip_en)\r\nchannel2_clipping_enable(1);\r\n}\r\nif (VPIF_CHANNEL3_VIDEO == ch->channel_id || ycmux_mode == 2) {\r\nchannel3_intr_assert();\r\nchannel3_intr_enable(1);\r\nenable_channel3(1);\r\nif (vpif_config_data->chan_config[VPIF_CHANNEL3_VIDEO].clip_en)\r\nchannel3_clipping_enable(1);\r\n}\r\nreturn 0;\r\nerr:\r\nlist_for_each_entry_safe(buf, tmp, &common->dma_queue, list) {\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_QUEUED);\r\n}\r\nspin_unlock_irqrestore(&common->irqlock, flags);\r\nreturn ret;\r\n}\r\nstatic void vpif_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct channel_obj *ch = vb2_get_drv_priv(vq);\r\nstruct common_obj *common;\r\nunsigned long flags;\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nif (VPIF_CHANNEL2_VIDEO == ch->channel_id) {\r\nenable_channel2(0);\r\nchannel2_intr_enable(0);\r\n}\r\nif (VPIF_CHANNEL3_VIDEO == ch->channel_id || ycmux_mode == 2) {\r\nenable_channel3(0);\r\nchannel3_intr_enable(0);\r\n}\r\nspin_lock_irqsave(&common->irqlock, flags);\r\nif (common->cur_frm == common->next_frm) {\r\nvb2_buffer_done(&common->cur_frm->vb, VB2_BUF_STATE_ERROR);\r\n} else {\r\nif (common->cur_frm != NULL)\r\nvb2_buffer_done(&common->cur_frm->vb,\r\nVB2_BUF_STATE_ERROR);\r\nif (common->next_frm != NULL)\r\nvb2_buffer_done(&common->next_frm->vb,\r\nVB2_BUF_STATE_ERROR);\r\n}\r\nwhile (!list_empty(&common->dma_queue)) {\r\ncommon->next_frm = list_entry(common->dma_queue.next,\r\nstruct vpif_disp_buffer, list);\r\nlist_del(&common->next_frm->list);\r\nvb2_buffer_done(&common->next_frm->vb, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&common->irqlock, flags);\r\n}\r\nstatic void process_progressive_mode(struct common_obj *common)\r\n{\r\nunsigned long addr = 0;\r\nspin_lock(&common->irqlock);\r\ncommon->next_frm = list_entry(common->dma_queue.next,\r\nstruct vpif_disp_buffer, list);\r\nlist_del(&common->next_frm->list);\r\nspin_unlock(&common->irqlock);\r\naddr = vb2_dma_contig_plane_dma_addr(&common->next_frm->vb, 0);\r\ncommon->set_addr(addr + common->ytop_off,\r\naddr + common->ybtm_off,\r\naddr + common->ctop_off,\r\naddr + common->cbtm_off);\r\n}\r\nstatic void process_interlaced_mode(int fid, struct common_obj *common)\r\n{\r\nif (0 == fid) {\r\nif (common->cur_frm == common->next_frm)\r\nreturn;\r\nv4l2_get_timestamp(&common->cur_frm->vb.v4l2_buf.timestamp);\r\nvb2_buffer_done(&common->cur_frm->vb,\r\nVB2_BUF_STATE_DONE);\r\ncommon->cur_frm = common->next_frm;\r\n} else if (1 == fid) {\r\nspin_lock(&common->irqlock);\r\nif (list_empty(&common->dma_queue)\r\n|| (common->cur_frm != common->next_frm)) {\r\nspin_unlock(&common->irqlock);\r\nreturn;\r\n}\r\nspin_unlock(&common->irqlock);\r\nprocess_progressive_mode(common);\r\n}\r\n}\r\nstatic irqreturn_t vpif_channel_isr(int irq, void *dev_id)\r\n{\r\nstruct vpif_device *dev = &vpif_obj;\r\nstruct channel_obj *ch;\r\nstruct common_obj *common;\r\nint fid = -1, i;\r\nint channel_id = 0;\r\nchannel_id = *(int *)(dev_id);\r\nif (!vpif_intr_status(channel_id + 2))\r\nreturn IRQ_NONE;\r\nch = dev->dev[channel_id];\r\nfor (i = 0; i < VPIF_NUMOBJECTS; i++) {\r\ncommon = &ch->common[i];\r\nif (1 == ch->vpifparams.std_info.frm_fmt) {\r\nspin_lock(&common->irqlock);\r\nif (list_empty(&common->dma_queue)) {\r\nspin_unlock(&common->irqlock);\r\ncontinue;\r\n}\r\nspin_unlock(&common->irqlock);\r\nif (!channel_first_int[i][channel_id]) {\r\nv4l2_get_timestamp(&common->cur_frm->vb.\r\nv4l2_buf.timestamp);\r\nvb2_buffer_done(&common->cur_frm->vb,\r\nVB2_BUF_STATE_DONE);\r\ncommon->cur_frm = common->next_frm;\r\n}\r\nchannel_first_int[i][channel_id] = 0;\r\nprocess_progressive_mode(common);\r\n} else {\r\nif (channel_first_int[i][channel_id]) {\r\nchannel_first_int[i][channel_id] = 0;\r\ncontinue;\r\n}\r\nif (0 == i) {\r\nch->field_id ^= 1;\r\nfid = vpif_channel_getfid(ch->channel_id + 2);\r\nif (fid != ch->field_id) {\r\nif (0 == fid)\r\nch->field_id = fid;\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nprocess_interlaced_mode(fid, common);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vpif_update_std_info(struct channel_obj *ch)\r\n{\r\nstruct video_obj *vid_ch = &ch->video;\r\nstruct vpif_params *vpifparams = &ch->vpifparams;\r\nstruct vpif_channel_config_params *std_info = &vpifparams->std_info;\r\nconst struct vpif_channel_config_params *config;\r\nint i;\r\nfor (i = 0; i < vpif_ch_params_count; i++) {\r\nconfig = &vpif_ch_params[i];\r\nif (config->hd_sd == 0) {\r\nvpif_dbg(2, debug, "SD format\n");\r\nif (config->stdid & vid_ch->stdid) {\r\nmemcpy(std_info, config, sizeof(*config));\r\nbreak;\r\n}\r\n}\r\n}\r\nif (i == vpif_ch_params_count) {\r\nvpif_dbg(1, debug, "Format not found\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpif_update_resolution(struct channel_obj *ch)\r\n{\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct video_obj *vid_ch = &ch->video;\r\nstruct vpif_params *vpifparams = &ch->vpifparams;\r\nstruct vpif_channel_config_params *std_info = &vpifparams->std_info;\r\nif (!vid_ch->stdid && !vid_ch->dv_timings.bt.height)\r\nreturn -EINVAL;\r\nif (vid_ch->stdid) {\r\nif (vpif_update_std_info(ch))\r\nreturn -EINVAL;\r\n}\r\ncommon->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV422P;\r\ncommon->fmt.fmt.pix.width = std_info->width;\r\ncommon->fmt.fmt.pix.height = std_info->height;\r\nvpif_dbg(1, debug, "Pixel details: Width = %d,Height = %d\n",\r\ncommon->fmt.fmt.pix.width, common->fmt.fmt.pix.height);\r\ncommon->height = std_info->height;\r\ncommon->width = std_info->width;\r\ncommon->fmt.fmt.pix.sizeimage = common->height * common->width * 2;\r\nif (vid_ch->stdid)\r\ncommon->fmt.fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nelse\r\ncommon->fmt.fmt.pix.colorspace = V4L2_COLORSPACE_REC709;\r\nif (ch->vpifparams.std_info.frm_fmt)\r\ncommon->fmt.fmt.pix.field = V4L2_FIELD_NONE;\r\nelse\r\ncommon->fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nreturn 0;\r\n}\r\nstatic void vpif_calculate_offsets(struct channel_obj *ch)\r\n{\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct vpif_params *vpifparams = &ch->vpifparams;\r\nenum v4l2_field field = common->fmt.fmt.pix.field;\r\nstruct video_obj *vid_ch = &ch->video;\r\nunsigned int hpitch, sizeimage;\r\nif (V4L2_FIELD_ANY == common->fmt.fmt.pix.field) {\r\nif (ch->vpifparams.std_info.frm_fmt)\r\nvid_ch->buf_field = V4L2_FIELD_NONE;\r\nelse\r\nvid_ch->buf_field = V4L2_FIELD_INTERLACED;\r\n} else {\r\nvid_ch->buf_field = common->fmt.fmt.pix.field;\r\n}\r\nsizeimage = common->fmt.fmt.pix.sizeimage;\r\nhpitch = common->fmt.fmt.pix.bytesperline;\r\nif ((V4L2_FIELD_NONE == vid_ch->buf_field) ||\r\n(V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {\r\ncommon->ytop_off = 0;\r\ncommon->ybtm_off = hpitch;\r\ncommon->ctop_off = sizeimage / 2;\r\ncommon->cbtm_off = sizeimage / 2 + hpitch;\r\n} else if (V4L2_FIELD_SEQ_TB == vid_ch->buf_field) {\r\ncommon->ytop_off = 0;\r\ncommon->ybtm_off = sizeimage / 4;\r\ncommon->ctop_off = sizeimage / 2;\r\ncommon->cbtm_off = common->ctop_off + sizeimage / 4;\r\n} else if (V4L2_FIELD_SEQ_BT == vid_ch->buf_field) {\r\ncommon->ybtm_off = 0;\r\ncommon->ytop_off = sizeimage / 4;\r\ncommon->cbtm_off = sizeimage / 2;\r\ncommon->ctop_off = common->cbtm_off + sizeimage / 4;\r\n}\r\nif ((V4L2_FIELD_NONE == vid_ch->buf_field) ||\r\n(V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {\r\nvpifparams->video_params.storage_mode = 1;\r\n} else {\r\nvpifparams->video_params.storage_mode = 0;\r\n}\r\nif (ch->vpifparams.std_info.frm_fmt == 1) {\r\nvpifparams->video_params.hpitch =\r\ncommon->fmt.fmt.pix.bytesperline;\r\n} else {\r\nif ((field == V4L2_FIELD_ANY) ||\r\n(field == V4L2_FIELD_INTERLACED))\r\nvpifparams->video_params.hpitch =\r\ncommon->fmt.fmt.pix.bytesperline * 2;\r\nelse\r\nvpifparams->video_params.hpitch =\r\ncommon->fmt.fmt.pix.bytesperline;\r\n}\r\nch->vpifparams.video_params.stdid = ch->vpifparams.std_info.stdid;\r\n}\r\nstatic void vpif_config_addr(struct channel_obj *ch, int muxmode)\r\n{\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (VPIF_CHANNEL3_VIDEO == ch->channel_id) {\r\ncommon->set_addr = ch3_set_videobuf_addr;\r\n} else {\r\nif (2 == muxmode)\r\ncommon->set_addr = ch2_set_videobuf_addr_yc_nmux;\r\nelse\r\ncommon->set_addr = ch2_set_videobuf_addr;\r\n}\r\n}\r\nstatic int vpif_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct vpif_display_config *config = vpif_dev->platform_data;\r\ncap->device_caps = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nstrlcpy(cap->driver, VPIF_DRIVER_NAME, sizeof(cap->driver));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",\r\ndev_name(vpif_dev));\r\nstrlcpy(cap->card, config->card_name, sizeof(cap->card));\r\nreturn 0;\r\n}\r\nstatic int vpif_enum_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nif (fmt->index != 0)\r\nreturn -EINVAL;\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nstrcpy(fmt->description, "YCbCr4:2:2 YC Planar");\r\nfmt->pixelformat = V4L2_PIX_FMT_YUV422P;\r\nfmt->flags = 0;\r\nreturn 0;\r\n}\r\nstatic int vpif_g_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (common->fmt.type != fmt->type)\r\nreturn -EINVAL;\r\nif (vpif_update_resolution(ch))\r\nreturn -EINVAL;\r\n*fmt = common->fmt;\r\nreturn 0;\r\n}\r\nstatic int vpif_try_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\r\nif (pixfmt->pixelformat != V4L2_PIX_FMT_YUV422P)\r\npixfmt->pixelformat = common->fmt.fmt.pix.pixelformat;\r\nif (vpif_update_resolution(ch))\r\nreturn -EINVAL;\r\npixfmt->colorspace = common->fmt.fmt.pix.colorspace;\r\npixfmt->field = common->fmt.fmt.pix.field;\r\npixfmt->bytesperline = common->fmt.fmt.pix.width;\r\npixfmt->width = common->fmt.fmt.pix.width;\r\npixfmt->height = common->fmt.fmt.pix.height;\r\npixfmt->sizeimage = pixfmt->bytesperline * pixfmt->height * 2;\r\nreturn 0;\r\n}\r\nstatic int vpif_s_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\r\nint ret;\r\nif (vb2_is_busy(&common->buffer_queue))\r\nreturn -EBUSY;\r\nret = vpif_try_fmt_vid_out(file, priv, fmt);\r\nif (ret)\r\nreturn ret;\r\ncommon->fmt.fmt.pix = *pixfmt;\r\ncommon->fmt = *fmt;\r\nreturn 0;\r\n}\r\nstatic int vpif_s_std(struct file *file, void *priv, v4l2_std_id std_id)\r\n{\r\nstruct vpif_display_config *config = vpif_dev->platform_data;\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct vpif_display_chan_config *chan_cfg;\r\nstruct v4l2_output output;\r\nint ret;\r\nif (config->chan_config[ch->channel_id].outputs == NULL)\r\nreturn -ENODATA;\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\noutput = chan_cfg->outputs[ch->output_idx].output;\r\nif (output.capabilities != V4L2_OUT_CAP_STD)\r\nreturn -ENODATA;\r\nif (vb2_is_busy(&common->buffer_queue))\r\nreturn -EBUSY;\r\nif (!(std_id & VPIF_V4L2_STD))\r\nreturn -EINVAL;\r\nch->video.stdid = std_id;\r\nmemset(&ch->video.dv_timings, 0, sizeof(ch->video.dv_timings));\r\nif (vpif_update_resolution(ch))\r\nreturn -EINVAL;\r\ncommon->fmt.fmt.pix.bytesperline = common->fmt.fmt.pix.width;\r\nret = v4l2_device_call_until_err(&vpif_obj.v4l2_dev, 1, video,\r\ns_std_output, std_id);\r\nif (ret < 0) {\r\nvpif_err("Failed to set output standard\n");\r\nreturn ret;\r\n}\r\nret = v4l2_device_call_until_err(&vpif_obj.v4l2_dev, 1, video,\r\ns_std, std_id);\r\nif (ret < 0)\r\nvpif_err("Failed to set standard for sub devices\n");\r\nreturn ret;\r\n}\r\nstatic int vpif_g_std(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct vpif_display_config *config = vpif_dev->platform_data;\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct vpif_display_chan_config *chan_cfg;\r\nstruct v4l2_output output;\r\nif (config->chan_config[ch->channel_id].outputs == NULL)\r\nreturn -ENODATA;\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\noutput = chan_cfg->outputs[ch->output_idx].output;\r\nif (output.capabilities != V4L2_OUT_CAP_STD)\r\nreturn -ENODATA;\r\n*std = ch->video.stdid;\r\nreturn 0;\r\n}\r\nstatic int vpif_enum_output(struct file *file, void *fh,\r\nstruct v4l2_output *output)\r\n{\r\nstruct vpif_display_config *config = vpif_dev->platform_data;\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct vpif_display_chan_config *chan_cfg;\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\nif (output->index >= chan_cfg->output_count) {\r\nvpif_dbg(1, debug, "Invalid output index\n");\r\nreturn -EINVAL;\r\n}\r\n*output = chan_cfg->outputs[output->index].output;\r\nreturn 0;\r\n}\r\nstatic int\r\nvpif_output_to_subdev(struct vpif_display_config *vpif_cfg,\r\nstruct vpif_display_chan_config *chan_cfg, int index)\r\n{\r\nstruct vpif_subdev_info *subdev_info;\r\nconst char *subdev_name;\r\nint i;\r\nvpif_dbg(2, debug, "vpif_output_to_subdev\n");\r\nif (chan_cfg->outputs == NULL)\r\nreturn -1;\r\nsubdev_name = chan_cfg->outputs[index].subdev_name;\r\nif (subdev_name == NULL)\r\nreturn -1;\r\nfor (i = 0; i < vpif_cfg->subdev_count; i++) {\r\nsubdev_info = &vpif_cfg->subdevinfo[i];\r\nif (!strcmp(subdev_info->name, subdev_name))\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic int vpif_set_output(struct vpif_display_config *vpif_cfg,\r\nstruct channel_obj *ch, int index)\r\n{\r\nstruct vpif_display_chan_config *chan_cfg =\r\n&vpif_cfg->chan_config[ch->channel_id];\r\nstruct v4l2_subdev *sd = NULL;\r\nu32 input = 0, output = 0;\r\nint sd_index;\r\nint ret;\r\nsd_index = vpif_output_to_subdev(vpif_cfg, chan_cfg, index);\r\nif (sd_index >= 0)\r\nsd = vpif_obj.sd[sd_index];\r\nif (sd) {\r\ninput = chan_cfg->outputs[index].input_route;\r\noutput = chan_cfg->outputs[index].output_route;\r\nret = v4l2_subdev_call(sd, video, s_routing, input, output, 0);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\nvpif_err("Failed to set output\n");\r\nreturn ret;\r\n}\r\n}\r\nch->output_idx = index;\r\nch->sd = sd;\r\nif (chan_cfg->outputs != NULL)\r\nch->video_dev->tvnorms = chan_cfg->outputs[index].output.std;\r\nreturn 0;\r\n}\r\nstatic int vpif_s_output(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct vpif_display_config *config = vpif_dev->platform_data;\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct vpif_display_chan_config *chan_cfg;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (vb2_is_busy(&common->buffer_queue))\r\nreturn -EBUSY;\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\nif (i >= chan_cfg->output_count)\r\nreturn -EINVAL;\r\nreturn vpif_set_output(config, ch, i);\r\n}\r\nstatic int vpif_g_output(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\n*i = ch->output_idx;\r\nreturn 0;\r\n}\r\nstatic int\r\nvpif_enum_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nstruct vpif_display_config *config = vpif_dev->platform_data;\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct vpif_display_chan_config *chan_cfg;\r\nstruct v4l2_output output;\r\nint ret;\r\nif (config->chan_config[ch->channel_id].outputs == NULL)\r\nreturn -ENODATA;\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\noutput = chan_cfg->outputs[ch->output_idx].output;\r\nif (output.capabilities != V4L2_OUT_CAP_DV_TIMINGS)\r\nreturn -ENODATA;\r\ntimings->pad = 0;\r\nret = v4l2_subdev_call(ch->sd, pad, enum_dv_timings, timings);\r\nif (ret == -ENOIOCTLCMD || ret == -ENODEV)\r\nreturn -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int vpif_s_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct vpif_display_config *config = vpif_dev->platform_data;\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct vpif_params *vpifparams = &ch->vpifparams;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct vpif_channel_config_params *std_info = &vpifparams->std_info;\r\nstruct video_obj *vid_ch = &ch->video;\r\nstruct v4l2_bt_timings *bt = &vid_ch->dv_timings.bt;\r\nstruct vpif_display_chan_config *chan_cfg;\r\nstruct v4l2_output output;\r\nint ret;\r\nif (config->chan_config[ch->channel_id].outputs == NULL)\r\nreturn -ENODATA;\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\noutput = chan_cfg->outputs[ch->output_idx].output;\r\nif (output.capabilities != V4L2_OUT_CAP_DV_TIMINGS)\r\nreturn -ENODATA;\r\nif (vb2_is_busy(&common->buffer_queue))\r\nreturn -EBUSY;\r\nif (timings->type != V4L2_DV_BT_656_1120) {\r\nvpif_dbg(2, debug, "Timing type not defined\n");\r\nreturn -EINVAL;\r\n}\r\nret = v4l2_subdev_call(ch->sd, video, s_dv_timings, timings);\r\nif (ret == -ENOIOCTLCMD || ret == -ENODEV)\r\nret = 0;\r\nif (ret < 0) {\r\nvpif_dbg(2, debug, "Error setting custom DV timings\n");\r\nreturn ret;\r\n}\r\nif (!(timings->bt.width && timings->bt.height &&\r\n(timings->bt.hbackporch ||\r\ntimings->bt.hfrontporch ||\r\ntimings->bt.hsync) &&\r\ntimings->bt.vfrontporch &&\r\n(timings->bt.vbackporch ||\r\ntimings->bt.vsync))) {\r\nvpif_dbg(2, debug, "Timings for width, height, "\r\n"horizontal back porch, horizontal sync, "\r\n"horizontal front porch, vertical back porch, "\r\n"vertical sync and vertical back porch "\r\n"must be defined\n");\r\nreturn -EINVAL;\r\n}\r\nvid_ch->dv_timings = *timings;\r\nstd_info->eav2sav = V4L2_DV_BT_BLANKING_WIDTH(bt) - 8;\r\nstd_info->sav2eav = bt->width;\r\nstd_info->l1 = 1;\r\nstd_info->l3 = bt->vsync + bt->vbackporch + 1;\r\nstd_info->vsize = V4L2_DV_BT_FRAME_HEIGHT(bt);\r\nif (bt->interlaced) {\r\nif (bt->il_vbackporch || bt->il_vfrontporch || bt->il_vsync) {\r\nstd_info->l5 = std_info->vsize/2 -\r\n(bt->vfrontporch - 1);\r\nstd_info->l7 = std_info->vsize/2 + 1;\r\nstd_info->l9 = std_info->l7 + bt->il_vsync +\r\nbt->il_vbackporch + 1;\r\nstd_info->l11 = std_info->vsize -\r\n(bt->il_vfrontporch - 1);\r\n} else {\r\nvpif_dbg(2, debug, "Required timing values for "\r\n"interlaced BT format missing\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nstd_info->l5 = std_info->vsize - (bt->vfrontporch - 1);\r\n}\r\nstrncpy(std_info->name, "Custom timings BT656/1120",\r\nVPIF_MAX_NAME);\r\nstd_info->width = bt->width;\r\nstd_info->height = bt->height;\r\nstd_info->frm_fmt = bt->interlaced ? 0 : 1;\r\nstd_info->ycmux_mode = 0;\r\nstd_info->capture_format = 0;\r\nstd_info->vbi_supported = 0;\r\nstd_info->hd_sd = 1;\r\nstd_info->stdid = 0;\r\nvid_ch->stdid = 0;\r\nreturn 0;\r\n}\r\nstatic int vpif_g_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct vpif_display_config *config = vpif_dev->platform_data;\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct vpif_display_chan_config *chan_cfg;\r\nstruct video_obj *vid_ch = &ch->video;\r\nstruct v4l2_output output;\r\nif (config->chan_config[ch->channel_id].outputs == NULL)\r\ngoto error;\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\noutput = chan_cfg->outputs[ch->output_idx].output;\r\nif (output.capabilities != V4L2_OUT_CAP_DV_TIMINGS)\r\ngoto error;\r\n*timings = vid_ch->dv_timings;\r\nreturn 0;\r\nerror:\r\nreturn -ENODATA;\r\n}\r\nstatic int vpif_log_status(struct file *filep, void *priv)\r\n{\r\nv4l2_device_call_all(&vpif_obj.v4l2_dev, 0, core, log_status);\r\nreturn 0;\r\n}\r\nstatic int initialize_vpif(void)\r\n{\r\nint free_channel_objects_index;\r\nint err, i, j;\r\nfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\r\nvpif_obj.dev[i] =\r\nkzalloc(sizeof(struct channel_obj), GFP_KERNEL);\r\nif (!vpif_obj.dev[i]) {\r\nfree_channel_objects_index = i;\r\nerr = -ENOMEM;\r\ngoto vpif_init_free_channel_objects;\r\n}\r\n}\r\nreturn 0;\r\nvpif_init_free_channel_objects:\r\nfor (j = 0; j < free_channel_objects_index; j++)\r\nkfree(vpif_obj.dev[j]);\r\nreturn err;\r\n}\r\nstatic int vpif_async_bound(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *subdev,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nint i;\r\nfor (i = 0; i < vpif_obj.config->subdev_count; i++)\r\nif (!strcmp(vpif_obj.config->subdevinfo[i].name,\r\nsubdev->name)) {\r\nvpif_obj.sd[i] = subdev;\r\nvpif_obj.sd[i]->grp_id = 1 << i;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vpif_probe_complete(void)\r\n{\r\nstruct common_obj *common;\r\nstruct video_device *vdev;\r\nstruct channel_obj *ch;\r\nstruct vb2_queue *q;\r\nint j, err, k;\r\nfor (j = 0; j < VPIF_DISPLAY_MAX_DEVICES; j++) {\r\nch = vpif_obj.dev[j];\r\nfor (k = 0; k < VPIF_NUMOBJECTS; k++) {\r\ncommon = &ch->common[k];\r\nspin_lock_init(&common->irqlock);\r\nmutex_init(&common->lock);\r\ncommon->set_addr = NULL;\r\ncommon->ytop_off = 0;\r\ncommon->ybtm_off = 0;\r\ncommon->ctop_off = 0;\r\ncommon->cbtm_off = 0;\r\ncommon->cur_frm = NULL;\r\ncommon->next_frm = NULL;\r\nmemset(&common->fmt, 0, sizeof(common->fmt));\r\n}\r\nch->initialized = 0;\r\nif (vpif_obj.config->subdev_count)\r\nch->sd = vpif_obj.sd[0];\r\nch->channel_id = j;\r\nmemset(&ch->vpifparams, 0, sizeof(ch->vpifparams));\r\nch->common[VPIF_VIDEO_INDEX].fmt.type =\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nerr = vpif_set_output(vpif_obj.config, ch, 0);\r\nif (err)\r\ngoto probe_out;\r\nch->video.stdid = V4L2_STD_525_60;\r\nmemset(&ch->video.dv_timings, 0, sizeof(ch->video.dv_timings));\r\nvpif_update_resolution(ch);\r\nq = &common->buffer_queue;\r\nq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\nq->drv_priv = ch;\r\nq->ops = &video_qops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->buf_struct_size = sizeof(struct vpif_disp_buffer);\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->min_buffers_needed = 1;\r\nq->lock = &common->lock;\r\nerr = vb2_queue_init(q);\r\nif (err) {\r\nvpif_err("vpif_display: vb2_queue_init() failed\n");\r\ngoto probe_out;\r\n}\r\ncommon->alloc_ctx = vb2_dma_contig_init_ctx(vpif_dev);\r\nif (IS_ERR(common->alloc_ctx)) {\r\nvpif_err("Failed to get the context\n");\r\nerr = PTR_ERR(common->alloc_ctx);\r\ngoto probe_out;\r\n}\r\nINIT_LIST_HEAD(&common->dma_queue);\r\nvpif_dbg(1, debug, "channel=%p,channel->video_dev=%p\n",\r\nch, &ch->video_dev);\r\nvdev = ch->video_dev;\r\nstrlcpy(vdev->name, VPIF_DRIVER_NAME, sizeof(vdev->name));\r\nvdev->release = video_device_release;\r\nvdev->fops = &vpif_fops;\r\nvdev->ioctl_ops = &vpif_ioctl_ops;\r\nvdev->v4l2_dev = &vpif_obj.v4l2_dev;\r\nvdev->vfl_dir = VFL_DIR_TX;\r\nvdev->queue = q;\r\nvdev->lock = &common->lock;\r\nvideo_set_drvdata(ch->video_dev, ch);\r\nerr = video_register_device(vdev, VFL_TYPE_GRABBER,\r\n(j ? 3 : 2));\r\nif (err < 0)\r\ngoto probe_out;\r\n}\r\nreturn 0;\r\nprobe_out:\r\nfor (k = 0; k < j; k++) {\r\nch = vpif_obj.dev[k];\r\ncommon = &ch->common[k];\r\nvb2_dma_contig_cleanup_ctx(common->alloc_ctx);\r\nvideo_unregister_device(ch->video_dev);\r\nvideo_device_release(ch->video_dev);\r\nch->video_dev = NULL;\r\n}\r\nreturn err;\r\n}\r\nstatic int vpif_async_complete(struct v4l2_async_notifier *notifier)\r\n{\r\nreturn vpif_probe_complete();\r\n}\r\nstatic __init int vpif_probe(struct platform_device *pdev)\r\n{\r\nstruct vpif_subdev_info *subdevdata;\r\nint i, j = 0, err = 0;\r\nint res_idx = 0;\r\nstruct i2c_adapter *i2c_adap;\r\nstruct channel_obj *ch;\r\nstruct video_device *vfd;\r\nstruct resource *res;\r\nint subdev_count;\r\nvpif_dev = &pdev->dev;\r\nerr = initialize_vpif();\r\nif (err) {\r\nv4l2_err(vpif_dev->driver, "Error initializing vpif\n");\r\nreturn err;\r\n}\r\nerr = v4l2_device_register(vpif_dev, &vpif_obj.v4l2_dev);\r\nif (err) {\r\nv4l2_err(vpif_dev->driver, "Error registering v4l2 device\n");\r\nreturn err;\r\n}\r\nwhile ((res = platform_get_resource(pdev, IORESOURCE_IRQ, res_idx))) {\r\nerr = devm_request_irq(&pdev->dev, res->start, vpif_channel_isr,\r\nIRQF_SHARED, VPIF_DRIVER_NAME,\r\n(void *)(&vpif_obj.dev[res_idx]->\r\nchannel_id));\r\nif (err) {\r\nerr = -EINVAL;\r\nvpif_err("VPIF IRQ request failed\n");\r\ngoto vpif_unregister;\r\n}\r\nres_idx++;\r\n}\r\nfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\r\nch = vpif_obj.dev[i];\r\nvfd = video_device_alloc();\r\nif (vfd == NULL) {\r\nfor (j = 0; j < i; j++) {\r\nch = vpif_obj.dev[j];\r\nvideo_device_release(ch->video_dev);\r\n}\r\nerr = -ENOMEM;\r\ngoto vpif_unregister;\r\n}\r\nch->video_dev = vfd;\r\n}\r\nvpif_obj.config = pdev->dev.platform_data;\r\nsubdev_count = vpif_obj.config->subdev_count;\r\nsubdevdata = vpif_obj.config->subdevinfo;\r\nvpif_obj.sd = kzalloc(sizeof(struct v4l2_subdev *) * subdev_count,\r\nGFP_KERNEL);\r\nif (vpif_obj.sd == NULL) {\r\nvpif_err("unable to allocate memory for subdevice pointers\n");\r\nerr = -ENOMEM;\r\ngoto vpif_sd_error;\r\n}\r\nif (!vpif_obj.config->asd_sizes) {\r\ni2c_adap = i2c_get_adapter(1);\r\nfor (i = 0; i < subdev_count; i++) {\r\nvpif_obj.sd[i] =\r\nv4l2_i2c_new_subdev_board(&vpif_obj.v4l2_dev,\r\ni2c_adap,\r\n&subdevdata[i].\r\nboard_info,\r\nNULL);\r\nif (!vpif_obj.sd[i]) {\r\nvpif_err("Error registering v4l2 subdevice\n");\r\nerr = -ENODEV;\r\ngoto probe_subdev_out;\r\n}\r\nif (vpif_obj.sd[i])\r\nvpif_obj.sd[i]->grp_id = 1 << i;\r\n}\r\nvpif_probe_complete();\r\n} else {\r\nvpif_obj.notifier.subdevs = vpif_obj.config->asd;\r\nvpif_obj.notifier.num_subdevs = vpif_obj.config->asd_sizes[0];\r\nvpif_obj.notifier.bound = vpif_async_bound;\r\nvpif_obj.notifier.complete = vpif_async_complete;\r\nerr = v4l2_async_notifier_register(&vpif_obj.v4l2_dev,\r\n&vpif_obj.notifier);\r\nif (err) {\r\nvpif_err("Error registering async notifier\n");\r\nerr = -EINVAL;\r\ngoto probe_subdev_out;\r\n}\r\n}\r\nreturn 0;\r\nprobe_subdev_out:\r\nkfree(vpif_obj.sd);\r\nvpif_sd_error:\r\nfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\r\nch = vpif_obj.dev[i];\r\nvideo_device_release(ch->video_dev);\r\n}\r\nvpif_unregister:\r\nv4l2_device_unregister(&vpif_obj.v4l2_dev);\r\nreturn err;\r\n}\r\nstatic int vpif_remove(struct platform_device *device)\r\n{\r\nstruct common_obj *common;\r\nstruct channel_obj *ch;\r\nint i;\r\nv4l2_device_unregister(&vpif_obj.v4l2_dev);\r\nkfree(vpif_obj.sd);\r\nfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\r\nch = vpif_obj.dev[i];\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nvb2_dma_contig_cleanup_ctx(common->alloc_ctx);\r\nvideo_unregister_device(ch->video_dev);\r\nch->video_dev = NULL;\r\nkfree(vpif_obj.dev[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpif_suspend(struct device *dev)\r\n{\r\nstruct common_obj *common;\r\nstruct channel_obj *ch;\r\nint i;\r\nfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\r\nch = vpif_obj.dev[i];\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nif (!vb2_start_streaming_called(&common->buffer_queue))\r\ncontinue;\r\nmutex_lock(&common->lock);\r\nif (ch->channel_id == VPIF_CHANNEL2_VIDEO) {\r\nenable_channel2(0);\r\nchannel2_intr_enable(0);\r\n}\r\nif (ch->channel_id == VPIF_CHANNEL3_VIDEO ||\r\nycmux_mode == 2) {\r\nenable_channel3(0);\r\nchannel3_intr_enable(0);\r\n}\r\nmutex_unlock(&common->lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpif_resume(struct device *dev)\r\n{\r\nstruct common_obj *common;\r\nstruct channel_obj *ch;\r\nint i;\r\nfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\r\nch = vpif_obj.dev[i];\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nif (!vb2_start_streaming_called(&common->buffer_queue))\r\ncontinue;\r\nmutex_lock(&common->lock);\r\nif (ch->channel_id == VPIF_CHANNEL2_VIDEO) {\r\nenable_channel2(1);\r\nchannel2_intr_enable(1);\r\n}\r\nif (ch->channel_id == VPIF_CHANNEL3_VIDEO ||\r\nycmux_mode == 2) {\r\nenable_channel3(1);\r\nchannel3_intr_enable(1);\r\n}\r\nmutex_unlock(&common->lock);\r\n}\r\nreturn 0;\r\n}
