static void ppro_shutdown(struct op_msrs const * const msrs)\r\n{\r\nint i;\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (!msrs->counters[i].addr)\r\ncontinue;\r\nrelease_perfctr_nmi(MSR_P6_PERFCTR0 + i);\r\nrelease_evntsel_nmi(MSR_P6_EVNTSEL0 + i);\r\n}\r\n}\r\nstatic int ppro_fill_in_addresses(struct op_msrs * const msrs)\r\n{\r\nint i;\r\nfor (i = 0; i < num_counters; i++) {\r\nif (!reserve_perfctr_nmi(MSR_P6_PERFCTR0 + i))\r\ngoto fail;\r\nif (!reserve_evntsel_nmi(MSR_P6_EVNTSEL0 + i)) {\r\nrelease_perfctr_nmi(MSR_P6_PERFCTR0 + i);\r\ngoto fail;\r\n}\r\nmsrs->counters[i].addr = MSR_P6_PERFCTR0 + i;\r\nmsrs->controls[i].addr = MSR_P6_EVNTSEL0 + i;\r\ncontinue;\r\nfail:\r\nif (!counter_config[i].enabled)\r\ncontinue;\r\nop_x86_warn_reserved(i);\r\nppro_shutdown(msrs);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ppro_setup_ctrs(struct op_x86_model_spec const *model,\r\nstruct op_msrs const * const msrs)\r\n{\r\nu64 val;\r\nint i;\r\nif (cpu_has_arch_perfmon) {\r\nunion cpuid10_eax eax;\r\neax.full = cpuid_eax(0xa);\r\nif (!(eax.split.version_id == 0 &&\r\n__this_cpu_read(cpu_info.x86) == 6 &&\r\n__this_cpu_read(cpu_info.x86_model) == 15)) {\r\nif (counter_width < eax.split.bit_width)\r\ncounter_width = eax.split.bit_width;\r\n}\r\n}\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (!msrs->controls[i].addr)\r\ncontinue;\r\nrdmsrl(msrs->controls[i].addr, val);\r\nif (val & ARCH_PERFMON_EVENTSEL_ENABLE)\r\nop_x86_warn_in_use(i);\r\nval &= model->reserved;\r\nwrmsrl(msrs->controls[i].addr, val);\r\nwrmsrl(msrs->counters[i].addr, -1LL);\r\n}\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (counter_config[i].enabled && msrs->counters[i].addr) {\r\nreset_value[i] = counter_config[i].count;\r\nwrmsrl(msrs->counters[i].addr, -reset_value[i]);\r\nrdmsrl(msrs->controls[i].addr, val);\r\nval &= model->reserved;\r\nval |= op_x86_get_ctrl(model, &counter_config[i]);\r\nwrmsrl(msrs->controls[i].addr, val);\r\n} else {\r\nreset_value[i] = 0;\r\n}\r\n}\r\n}\r\nstatic int ppro_check_ctrs(struct pt_regs * const regs,\r\nstruct op_msrs const * const msrs)\r\n{\r\nu64 val;\r\nint i;\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (!reset_value[i])\r\ncontinue;\r\nrdmsrl(msrs->counters[i].addr, val);\r\nif (val & (1ULL << (counter_width - 1)))\r\ncontinue;\r\noprofile_add_sample(regs, i);\r\nwrmsrl(msrs->counters[i].addr, -reset_value[i]);\r\n}\r\napic_write(APIC_LVTPC, apic_read(APIC_LVTPC) & ~APIC_LVT_MASKED);\r\nreturn 1;\r\n}\r\nstatic void ppro_start(struct op_msrs const * const msrs)\r\n{\r\nu64 val;\r\nint i;\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (reset_value[i]) {\r\nrdmsrl(msrs->controls[i].addr, val);\r\nval |= ARCH_PERFMON_EVENTSEL_ENABLE;\r\nwrmsrl(msrs->controls[i].addr, val);\r\n}\r\n}\r\n}\r\nstatic void ppro_stop(struct op_msrs const * const msrs)\r\n{\r\nu64 val;\r\nint i;\r\nfor (i = 0; i < num_counters; ++i) {\r\nif (!reset_value[i])\r\ncontinue;\r\nrdmsrl(msrs->controls[i].addr, val);\r\nval &= ~ARCH_PERFMON_EVENTSEL_ENABLE;\r\nwrmsrl(msrs->controls[i].addr, val);\r\n}\r\n}\r\nstatic void arch_perfmon_setup_counters(void)\r\n{\r\nunion cpuid10_eax eax;\r\neax.full = cpuid_eax(0xa);\r\nif (eax.split.version_id == 0 && __this_cpu_read(cpu_info.x86) == 6 &&\r\n__this_cpu_read(cpu_info.x86_model) == 15) {\r\neax.split.version_id = 2;\r\neax.split.num_counters = 2;\r\neax.split.bit_width = 40;\r\n}\r\nnum_counters = min((int)eax.split.num_counters, OP_MAX_COUNTER);\r\nop_arch_perfmon_spec.num_counters = num_counters;\r\nop_arch_perfmon_spec.num_controls = num_counters;\r\n}\r\nstatic int arch_perfmon_init(struct oprofile_operations *ignore)\r\n{\r\narch_perfmon_setup_counters();\r\nreturn 0;\r\n}
