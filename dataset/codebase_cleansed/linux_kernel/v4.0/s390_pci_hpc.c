static int zpci_fn_configured(enum zpci_state state)\r\n{\r\nreturn state == ZPCI_FN_STATE_CONFIGURED ||\r\nstate == ZPCI_FN_STATE_ONLINE;\r\n}\r\nstatic inline int slot_configure(struct slot *slot)\r\n{\r\nint ret = sclp_pci_configure(slot->zdev->fid);\r\nzpci_dbg(3, "conf fid:%x, rc:%d\n", slot->zdev->fid, ret);\r\nif (!ret)\r\nslot->zdev->state = ZPCI_FN_STATE_CONFIGURED;\r\nreturn ret;\r\n}\r\nstatic inline int slot_deconfigure(struct slot *slot)\r\n{\r\nint ret = sclp_pci_deconfigure(slot->zdev->fid);\r\nzpci_dbg(3, "deconf fid:%x, rc:%d\n", slot->zdev->fid, ret);\r\nif (!ret)\r\nslot->zdev->state = ZPCI_FN_STATE_STANDBY;\r\nreturn ret;\r\n}\r\nstatic int enable_slot(struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nint rc;\r\nif (slot->zdev->state != ZPCI_FN_STATE_STANDBY)\r\nreturn -EIO;\r\nrc = slot_configure(slot);\r\nif (rc)\r\nreturn rc;\r\nrc = zpci_enable_device(slot->zdev);\r\nif (rc)\r\ngoto out_deconfigure;\r\npci_scan_slot(slot->zdev->bus, ZPCI_DEVFN);\r\npci_lock_rescan_remove();\r\npci_bus_add_devices(slot->zdev->bus);\r\npci_unlock_rescan_remove();\r\nreturn rc;\r\nout_deconfigure:\r\nslot_deconfigure(slot);\r\nreturn rc;\r\n}\r\nstatic int disable_slot(struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nint rc;\r\nif (!zpci_fn_configured(slot->zdev->state))\r\nreturn -EIO;\r\nif (slot->zdev->pdev)\r\npci_stop_and_remove_bus_device_locked(slot->zdev->pdev);\r\nrc = zpci_disable_device(slot->zdev);\r\nif (rc)\r\nreturn rc;\r\nreturn slot_deconfigure(slot);\r\n}\r\nstatic int get_power_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nswitch (slot->zdev->state) {\r\ncase ZPCI_FN_STATE_STANDBY:\r\n*value = 0;\r\nbreak;\r\ndefault:\r\n*value = 1;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_adapter_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\n*value = 1;\r\nreturn 0;\r\n}\r\nstatic void release_slot(struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nkfree(slot->hotplug_slot->info);\r\nkfree(slot->hotplug_slot);\r\nkfree(slot);\r\n}\r\nint zpci_init_slot(struct zpci_dev *zdev)\r\n{\r\nstruct hotplug_slot *hotplug_slot;\r\nstruct hotplug_slot_info *info;\r\nchar name[SLOT_NAME_SIZE];\r\nstruct slot *slot;\r\nint rc;\r\nif (!zdev)\r\nreturn 0;\r\nslot = kzalloc(sizeof(*slot), GFP_KERNEL);\r\nif (!slot)\r\ngoto error;\r\nhotplug_slot = kzalloc(sizeof(*hotplug_slot), GFP_KERNEL);\r\nif (!hotplug_slot)\r\ngoto error_hp;\r\nhotplug_slot->private = slot;\r\nslot->hotplug_slot = hotplug_slot;\r\nslot->zdev = zdev;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\ngoto error_info;\r\nhotplug_slot->info = info;\r\nhotplug_slot->ops = &s390_hotplug_slot_ops;\r\nhotplug_slot->release = &release_slot;\r\nget_power_status(hotplug_slot, &info->power_status);\r\nget_adapter_status(hotplug_slot, &info->adapter_status);\r\nsnprintf(name, SLOT_NAME_SIZE, "%08x", zdev->fid);\r\nrc = pci_hp_register(slot->hotplug_slot, zdev->bus,\r\nZPCI_DEVFN, name);\r\nif (rc)\r\ngoto error_reg;\r\nlist_add(&slot->slot_list, &s390_hotplug_slot_list);\r\nreturn 0;\r\nerror_reg:\r\nkfree(info);\r\nerror_info:\r\nkfree(hotplug_slot);\r\nerror_hp:\r\nkfree(slot);\r\nerror:\r\nreturn -ENOMEM;\r\n}\r\nvoid zpci_exit_slot(struct zpci_dev *zdev)\r\n{\r\nstruct list_head *tmp, *n;\r\nstruct slot *slot;\r\nlist_for_each_safe(tmp, n, &s390_hotplug_slot_list) {\r\nslot = list_entry(tmp, struct slot, slot_list);\r\nif (slot->zdev != zdev)\r\ncontinue;\r\nlist_del(&slot->slot_list);\r\npci_hp_deregister(slot->hotplug_slot);\r\n}\r\n}
