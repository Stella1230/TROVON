static struct osc_req *cl2osc_req(const struct cl_req_slice *slice)\r\n{\r\nLINVRNT(slice->crs_dev->cd_lu_dev.ld_type == &osc_device_type);\r\nreturn container_of0(slice, struct osc_req, or_cl);\r\n}\r\nstatic struct osc_io *cl2osc_io(const struct lu_env *env,\r\nconst struct cl_io_slice *slice)\r\n{\r\nstruct osc_io *oio = container_of0(slice, struct osc_io, oi_cl);\r\nLINVRNT(oio == osc_env_io(env));\r\nreturn oio;\r\n}\r\nstatic struct osc_page *osc_cl_page_osc(struct cl_page *page)\r\n{\r\nconst struct cl_page_slice *slice;\r\nslice = cl_page_at(page, &osc_device_type);\r\nLASSERT(slice != NULL);\r\nreturn cl2osc_page(slice);\r\n}\r\nstatic void osc_io_fini(const struct lu_env *env, const struct cl_io_slice *io)\r\n{\r\n}\r\nstatic int osc_io_submit(const struct lu_env *env,\r\nconst struct cl_io_slice *ios,\r\nenum cl_req_type crt, struct cl_2queue *queue)\r\n{\r\nstruct cl_page *page;\r\nstruct cl_page *tmp;\r\nstruct client_obd *cli = NULL;\r\nstruct osc_object *osc = NULL;\r\nstruct osc_page *opg;\r\nstruct cl_io *io;\r\nLIST_HEAD(list);\r\nstruct cl_page_list *qin = &queue->c2_qin;\r\nstruct cl_page_list *qout = &queue->c2_qout;\r\nint queued = 0;\r\nint result = 0;\r\nint cmd;\r\nint brw_flags;\r\nint max_pages;\r\nLASSERT(qin->pl_nr > 0);\r\nCDEBUG(D_CACHE, "%d %d\n", qin->pl_nr, crt);\r\nosc = cl2osc(ios->cis_obj);\r\ncli = osc_cli(osc);\r\nmax_pages = cli->cl_max_pages_per_rpc;\r\ncmd = crt == CRT_WRITE ? OBD_BRW_WRITE : OBD_BRW_READ;\r\nbrw_flags = osc_io_srvlock(cl2osc_io(env, ios)) ? OBD_BRW_SRVLOCK : 0;\r\ncl_page_list_for_each_safe(page, tmp, qin) {\r\nstruct osc_async_page *oap;\r\nio = page->cp_owner;\r\nLASSERT(io != NULL);\r\nopg = osc_cl_page_osc(page);\r\noap = &opg->ops_oap;\r\nLASSERT(osc == oap->oap_obj);\r\nif (!list_empty(&oap->oap_pending_item) ||\r\n!list_empty(&oap->oap_rpc_item)) {\r\nCDEBUG(D_CACHE, "Busy oap %p page %p for submit.\n",\r\noap, opg);\r\nresult = -EBUSY;\r\nbreak;\r\n}\r\nresult = cl_page_prep(env, io, page, crt);\r\nif (result != 0) {\r\nLASSERT(result < 0);\r\nif (result != -EALREADY)\r\nbreak;\r\nresult = 0;\r\ncontinue;\r\n}\r\ncl_page_list_move(qout, qin, page);\r\noap->oap_async_flags = ASYNC_URGENT|ASYNC_READY;\r\noap->oap_async_flags |= ASYNC_COUNT_STABLE;\r\nosc_page_submit(env, opg, crt, brw_flags);\r\nlist_add_tail(&oap->oap_pending_item, &list);\r\nif (++queued == max_pages) {\r\nqueued = 0;\r\nresult = osc_queue_sync_pages(env, osc, &list, cmd,\r\nbrw_flags);\r\nif (result < 0)\r\nbreak;\r\n}\r\n}\r\nif (queued > 0)\r\nresult = osc_queue_sync_pages(env, osc, &list, cmd, brw_flags);\r\nCDEBUG(D_INFO, "%d/%d %d\n", qin->pl_nr, qout->pl_nr, result);\r\nreturn qout->pl_nr > 0 ? 0 : result;\r\n}\r\nstatic void osc_page_touch_at(const struct lu_env *env,\r\nstruct cl_object *obj, pgoff_t idx, unsigned to)\r\n{\r\nstruct lov_oinfo *loi = cl2osc(obj)->oo_oinfo;\r\nstruct cl_attr *attr = &osc_env_info(env)->oti_attr;\r\nint valid;\r\n__u64 kms;\r\nkms = cl_offset(obj, idx) + to;\r\ncl_object_attr_lock(obj);\r\nCDEBUG(D_INODE, "stripe KMS %sincreasing %llu->%llu %llu\n",\r\nkms > loi->loi_kms ? "" : "not ", loi->loi_kms, kms,\r\nloi->loi_lvb.lvb_size);\r\nvalid = 0;\r\nif (kms > loi->loi_kms) {\r\nattr->cat_kms = kms;\r\nvalid |= CAT_KMS;\r\n}\r\nif (kms > loi->loi_lvb.lvb_size) {\r\nattr->cat_size = kms;\r\nvalid |= CAT_SIZE;\r\n}\r\ncl_object_attr_set(env, obj, attr, valid);\r\ncl_object_attr_unlock(obj);\r\n}\r\nstatic void osc_page_touch(const struct lu_env *env,\r\nstruct osc_page *opage, unsigned to)\r\n{\r\nstruct cl_page *page = opage->ops_cl.cpl_page;\r\nstruct cl_object *obj = opage->ops_cl.cpl_obj;\r\nosc_page_touch_at(env, obj, page->cp_index, to);\r\n}\r\nstatic int osc_io_prepare_write(const struct lu_env *env,\r\nconst struct cl_io_slice *ios,\r\nconst struct cl_page_slice *slice,\r\nunsigned from, unsigned to)\r\n{\r\nstruct osc_device *dev = lu2osc_dev(slice->cpl_obj->co_lu.lo_dev);\r\nstruct obd_import *imp = class_exp2cliimp(dev->od_exp);\r\nstruct osc_io *oio = cl2osc_io(env, ios);\r\nint result = 0;\r\nif (imp == NULL || imp->imp_invalid)\r\nresult = -EIO;\r\nif (result == 0 && oio->oi_lockless)\r\ncl_page_export(env, slice->cpl_page, 1);\r\nreturn result;\r\n}\r\nstatic int osc_io_commit_write(const struct lu_env *env,\r\nconst struct cl_io_slice *ios,\r\nconst struct cl_page_slice *slice,\r\nunsigned from, unsigned to)\r\n{\r\nstruct osc_io *oio = cl2osc_io(env, ios);\r\nstruct osc_page *opg = cl2osc_page(slice);\r\nstruct osc_object *obj = cl2osc(opg->ops_cl.cpl_obj);\r\nstruct osc_async_page *oap = &opg->ops_oap;\r\nLASSERT(to > 0);\r\nosc_page_touch(env, cl2osc_page(slice), to);\r\nif (!client_is_remote(osc_export(obj)) &&\r\ncapable(CFS_CAP_SYS_RESOURCE))\r\noap->oap_brw_flags |= OBD_BRW_NOQUOTA;\r\nif (oio->oi_lockless)\r\ncl_page_clip(env, slice->cpl_page, from, to);\r\nreturn 0;\r\n}\r\nstatic int osc_io_fault_start(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct cl_io *io;\r\nstruct cl_fault_io *fio;\r\nio = ios->cis_io;\r\nfio = &io->u.ci_fault;\r\nCDEBUG(D_INFO, "%lu %d %d\n",\r\nfio->ft_index, fio->ft_writable, fio->ft_nob);\r\nif (fio->ft_writable)\r\nosc_page_touch_at(env, ios->cis_obj,\r\nfio->ft_index, fio->ft_nob);\r\nreturn 0;\r\n}\r\nstatic int osc_async_upcall(void *a, int rc)\r\n{\r\nstruct osc_async_cbargs *args = a;\r\nargs->opc_rc = rc;\r\ncomplete(&args->opc_sync);\r\nreturn 0;\r\n}\r\nstatic int trunc_check_cb(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_page *page, void *cbdata)\r\n{\r\nconst struct cl_page_slice *slice;\r\nstruct osc_page *ops;\r\nstruct osc_async_page *oap;\r\n__u64 start = *(__u64 *)cbdata;\r\nslice = cl_page_at(page, &osc_device_type);\r\nLASSERT(slice != NULL);\r\nops = cl2osc_page(slice);\r\noap = &ops->ops_oap;\r\nif (oap->oap_cmd & OBD_BRW_WRITE &&\r\n!list_empty(&oap->oap_pending_item))\r\nCL_PAGE_DEBUG(D_ERROR, env, page, "exists %llu/%s.\n",\r\nstart, current->comm);\r\n{\r\nstruct page *vmpage = cl_page_vmpage(env, page);\r\nif (PageLocked(vmpage))\r\nCDEBUG(D_CACHE, "page %p index %lu locked for %d.\n",\r\nops, page->cp_index,\r\n(oap->oap_cmd & OBD_BRW_RWMASK));\r\n}\r\nreturn CLP_GANG_OKAY;\r\n}\r\nstatic void osc_trunc_check(const struct lu_env *env, struct cl_io *io,\r\nstruct osc_io *oio, __u64 size)\r\n{\r\nstruct cl_object *clob;\r\nint partial;\r\npgoff_t start;\r\nclob = oio->oi_cl.cis_obj;\r\nstart = cl_index(clob, size);\r\npartial = cl_offset(clob, start) < size;\r\ncl_page_gang_lookup(env, clob, io, start + partial, CL_PAGE_EOF,\r\ntrunc_check_cb, (void *)&size);\r\n}\r\nstatic int osc_io_setattr_start(const struct lu_env *env,\r\nconst struct cl_io_slice *slice)\r\n{\r\nstruct cl_io *io = slice->cis_io;\r\nstruct osc_io *oio = cl2osc_io(env, slice);\r\nstruct cl_object *obj = slice->cis_obj;\r\nstruct lov_oinfo *loi = cl2osc(obj)->oo_oinfo;\r\nstruct cl_attr *attr = &osc_env_info(env)->oti_attr;\r\nstruct obdo *oa = &oio->oi_oa;\r\nstruct osc_async_cbargs *cbargs = &oio->oi_cbarg;\r\n__u64 size = io->u.ci_setattr.sa_attr.lvb_size;\r\nunsigned int ia_valid = io->u.ci_setattr.sa_valid;\r\nint result = 0;\r\nstruct obd_info oinfo = { { { 0 } } };\r\nif (cl_io_is_trunc(io))\r\nresult = osc_cache_truncate_start(env, oio, cl2osc(obj), size);\r\nif (result == 0 && oio->oi_lockless == 0) {\r\ncl_object_attr_lock(obj);\r\nresult = cl_object_attr_get(env, obj, attr);\r\nif (result == 0) {\r\nstruct ost_lvb *lvb = &io->u.ci_setattr.sa_attr;\r\nunsigned int cl_valid = 0;\r\nif (ia_valid & ATTR_SIZE) {\r\nattr->cat_size = attr->cat_kms = size;\r\ncl_valid = (CAT_SIZE | CAT_KMS);\r\n}\r\nif (ia_valid & ATTR_MTIME_SET) {\r\nattr->cat_mtime = lvb->lvb_mtime;\r\ncl_valid |= CAT_MTIME;\r\n}\r\nif (ia_valid & ATTR_ATIME_SET) {\r\nattr->cat_atime = lvb->lvb_atime;\r\ncl_valid |= CAT_ATIME;\r\n}\r\nif (ia_valid & ATTR_CTIME_SET) {\r\nattr->cat_ctime = lvb->lvb_ctime;\r\ncl_valid |= CAT_CTIME;\r\n}\r\nresult = cl_object_attr_set(env, obj, attr, cl_valid);\r\n}\r\ncl_object_attr_unlock(obj);\r\n}\r\nmemset(oa, 0, sizeof(*oa));\r\nif (result == 0) {\r\noa->o_oi = loi->loi_oi;\r\noa->o_mtime = attr->cat_mtime;\r\noa->o_atime = attr->cat_atime;\r\noa->o_ctime = attr->cat_ctime;\r\noa->o_valid = OBD_MD_FLID | OBD_MD_FLGROUP | OBD_MD_FLATIME |\r\nOBD_MD_FLCTIME | OBD_MD_FLMTIME;\r\nif (ia_valid & ATTR_SIZE) {\r\noa->o_size = size;\r\noa->o_blocks = OBD_OBJECT_EOF;\r\noa->o_valid |= OBD_MD_FLSIZE | OBD_MD_FLBLOCKS;\r\nif (oio->oi_lockless) {\r\noa->o_flags = OBD_FL_SRVLOCK;\r\noa->o_valid |= OBD_MD_FLFLAGS;\r\n}\r\n} else {\r\nLASSERT(oio->oi_lockless == 0);\r\n}\r\noinfo.oi_oa = oa;\r\noinfo.oi_capa = io->u.ci_setattr.sa_capa;\r\ninit_completion(&cbargs->opc_sync);\r\nif (ia_valid & ATTR_SIZE)\r\nresult = osc_punch_base(osc_export(cl2osc(obj)),\r\n&oinfo, osc_async_upcall,\r\ncbargs, PTLRPCD_SET);\r\nelse\r\nresult = osc_setattr_async_base(osc_export(cl2osc(obj)),\r\n&oinfo, NULL,\r\nosc_async_upcall,\r\ncbargs, PTLRPCD_SET);\r\ncbargs->opc_rpc_sent = result == 0;\r\n}\r\nreturn result;\r\n}\r\nstatic void osc_io_setattr_end(const struct lu_env *env,\r\nconst struct cl_io_slice *slice)\r\n{\r\nstruct cl_io *io = slice->cis_io;\r\nstruct osc_io *oio = cl2osc_io(env, slice);\r\nstruct cl_object *obj = slice->cis_obj;\r\nstruct osc_async_cbargs *cbargs = &oio->oi_cbarg;\r\nint result = 0;\r\nif (cbargs->opc_rpc_sent) {\r\nwait_for_completion(&cbargs->opc_sync);\r\nresult = io->ci_result = cbargs->opc_rc;\r\n}\r\nif (result == 0) {\r\nif (oio->oi_lockless) {\r\nstruct osc_device *osd = lu2osc_dev(obj->co_lu.lo_dev);\r\nLASSERT(cl_io_is_trunc(io));\r\nosd->od_stats.os_lockless_truncates++;\r\n}\r\n}\r\nif (cl_io_is_trunc(io)) {\r\n__u64 size = io->u.ci_setattr.sa_attr.lvb_size;\r\nosc_trunc_check(env, io, oio, size);\r\nif (oio->oi_trunc != NULL) {\r\nosc_cache_truncate_end(env, oio, cl2osc(obj));\r\noio->oi_trunc = NULL;\r\n}\r\n}\r\n}\r\nstatic int osc_io_read_start(const struct lu_env *env,\r\nconst struct cl_io_slice *slice)\r\n{\r\nstruct cl_object *obj = slice->cis_obj;\r\nstruct cl_attr *attr = &osc_env_info(env)->oti_attr;\r\nint rc = 0;\r\nif (!slice->cis_io->ci_noatime) {\r\ncl_object_attr_lock(obj);\r\nattr->cat_atime = LTIME_S(CURRENT_TIME);\r\nrc = cl_object_attr_set(env, obj, attr, CAT_ATIME);\r\ncl_object_attr_unlock(obj);\r\n}\r\nreturn rc;\r\n}\r\nstatic int osc_io_write_start(const struct lu_env *env,\r\nconst struct cl_io_slice *slice)\r\n{\r\nstruct cl_object *obj = slice->cis_obj;\r\nstruct cl_attr *attr = &osc_env_info(env)->oti_attr;\r\nint rc = 0;\r\nOBD_FAIL_TIMEOUT(OBD_FAIL_OSC_DELAY_SETTIME, 1);\r\ncl_object_attr_lock(obj);\r\nattr->cat_mtime = attr->cat_ctime = LTIME_S(CURRENT_TIME);\r\nrc = cl_object_attr_set(env, obj, attr, CAT_MTIME | CAT_CTIME);\r\ncl_object_attr_unlock(obj);\r\nreturn rc;\r\n}\r\nstatic int osc_fsync_ost(const struct lu_env *env, struct osc_object *obj,\r\nstruct cl_fsync_io *fio)\r\n{\r\nstruct osc_io *oio = osc_env_io(env);\r\nstruct obdo *oa = &oio->oi_oa;\r\nstruct obd_info *oinfo = &oio->oi_info;\r\nstruct lov_oinfo *loi = obj->oo_oinfo;\r\nstruct osc_async_cbargs *cbargs = &oio->oi_cbarg;\r\nint rc = 0;\r\nmemset(oa, 0, sizeof(*oa));\r\noa->o_oi = loi->loi_oi;\r\noa->o_valid = OBD_MD_FLID | OBD_MD_FLGROUP;\r\noa->o_size = fio->fi_start;\r\noa->o_blocks = fio->fi_end;\r\noa->o_valid |= OBD_MD_FLSIZE | OBD_MD_FLBLOCKS;\r\nobdo_set_parent_fid(oa, fio->fi_fid);\r\nmemset(oinfo, 0, sizeof(*oinfo));\r\noinfo->oi_oa = oa;\r\noinfo->oi_capa = fio->fi_capa;\r\ninit_completion(&cbargs->opc_sync);\r\nrc = osc_sync_base(osc_export(obj), oinfo, osc_async_upcall, cbargs,\r\nPTLRPCD_SET);\r\nreturn rc;\r\n}\r\nstatic int osc_io_fsync_start(const struct lu_env *env,\r\nconst struct cl_io_slice *slice)\r\n{\r\nstruct cl_io *io = slice->cis_io;\r\nstruct cl_fsync_io *fio = &io->u.ci_fsync;\r\nstruct cl_object *obj = slice->cis_obj;\r\nstruct osc_object *osc = cl2osc(obj);\r\npgoff_t start = cl_index(obj, fio->fi_start);\r\npgoff_t end = cl_index(obj, fio->fi_end);\r\nint result = 0;\r\nif (fio->fi_end == OBD_OBJECT_EOF)\r\nend = CL_PAGE_EOF;\r\nresult = osc_cache_writeback_range(env, osc, start, end, 0,\r\nfio->fi_mode == CL_FSYNC_DISCARD);\r\nif (result > 0) {\r\nfio->fi_nr_written += result;\r\nresult = 0;\r\n}\r\nif (fio->fi_mode == CL_FSYNC_ALL) {\r\nint rc;\r\nrc = osc_cache_wait_range(env, osc, start, end);\r\nif (result == 0)\r\nresult = rc;\r\nrc = osc_fsync_ost(env, osc, fio);\r\nif (result == 0)\r\nresult = rc;\r\n}\r\nreturn result;\r\n}\r\nstatic void osc_io_fsync_end(const struct lu_env *env,\r\nconst struct cl_io_slice *slice)\r\n{\r\nstruct cl_fsync_io *fio = &slice->cis_io->u.ci_fsync;\r\nstruct cl_object *obj = slice->cis_obj;\r\npgoff_t start = cl_index(obj, fio->fi_start);\r\npgoff_t end = cl_index(obj, fio->fi_end);\r\nint result = 0;\r\nif (fio->fi_mode == CL_FSYNC_LOCAL) {\r\nresult = osc_cache_wait_range(env, cl2osc(obj), start, end);\r\n} else if (fio->fi_mode == CL_FSYNC_ALL) {\r\nstruct osc_io *oio = cl2osc_io(env, slice);\r\nstruct osc_async_cbargs *cbargs = &oio->oi_cbarg;\r\nwait_for_completion(&cbargs->opc_sync);\r\nif (result == 0)\r\nresult = cbargs->opc_rc;\r\n}\r\nslice->cis_io->ci_result = result;\r\n}\r\nstatic void osc_io_end(const struct lu_env *env,\r\nconst struct cl_io_slice *slice)\r\n{\r\nstruct osc_io *oio = cl2osc_io(env, slice);\r\nif (oio->oi_active) {\r\nosc_extent_release(env, oio->oi_active);\r\noio->oi_active = NULL;\r\n}\r\n}\r\nstatic int osc_req_prep(const struct lu_env *env,\r\nconst struct cl_req_slice *slice)\r\n{\r\nreturn 0;\r\n}\r\nstatic void osc_req_completion(const struct lu_env *env,\r\nconst struct cl_req_slice *slice, int ioret)\r\n{\r\nstruct osc_req *or;\r\nor = cl2osc_req(slice);\r\nOBD_SLAB_FREE_PTR(or, osc_req_kmem);\r\n}\r\nstatic void osc_req_attr_set(const struct lu_env *env,\r\nconst struct cl_req_slice *slice,\r\nconst struct cl_object *obj,\r\nstruct cl_req_attr *attr, u64 flags)\r\n{\r\nstruct lov_oinfo *oinfo;\r\nstruct cl_req *clerq;\r\nstruct cl_page *apage;\r\nstruct cl_lock *lock;\r\nstruct osc_lock *olck;\r\nstruct osc_page *opg;\r\nstruct obdo *oa;\r\nstruct ost_lvb *lvb;\r\noinfo = cl2osc(obj)->oo_oinfo;\r\nlvb = &oinfo->loi_lvb;\r\noa = attr->cra_oa;\r\nif ((flags & OBD_MD_FLMTIME) != 0) {\r\noa->o_mtime = lvb->lvb_mtime;\r\noa->o_valid |= OBD_MD_FLMTIME;\r\n}\r\nif ((flags & OBD_MD_FLATIME) != 0) {\r\noa->o_atime = lvb->lvb_atime;\r\noa->o_valid |= OBD_MD_FLATIME;\r\n}\r\nif ((flags & OBD_MD_FLCTIME) != 0) {\r\noa->o_ctime = lvb->lvb_ctime;\r\noa->o_valid |= OBD_MD_FLCTIME;\r\n}\r\nif (flags & OBD_MD_FLGROUP) {\r\nostid_set_seq(&oa->o_oi, ostid_seq(&oinfo->loi_oi));\r\noa->o_valid |= OBD_MD_FLGROUP;\r\n}\r\nif (flags & OBD_MD_FLID) {\r\nostid_set_id(&oa->o_oi, ostid_id(&oinfo->loi_oi));\r\noa->o_valid |= OBD_MD_FLID;\r\n}\r\nif (flags & OBD_MD_FLHANDLE) {\r\nclerq = slice->crs_req;\r\nLASSERT(!list_empty(&clerq->crq_pages));\r\napage = container_of(clerq->crq_pages.next,\r\nstruct cl_page, cp_flight);\r\nopg = osc_cl_page_osc(apage);\r\napage = opg->ops_cl.cpl_page;\r\nlock = cl_lock_at_page(env, apage->cp_obj, apage, NULL, 1, 1);\r\nif (lock == NULL) {\r\nstruct cl_object_header *head;\r\nstruct cl_lock *scan;\r\nhead = cl_object_header(apage->cp_obj);\r\nlist_for_each_entry(scan, &head->coh_locks,\r\ncll_linkage)\r\nCL_LOCK_DEBUG(D_ERROR, env, scan,\r\n"no cover page!\n");\r\nCL_PAGE_DEBUG(D_ERROR, env, apage,\r\n"dump uncover page!\n");\r\ndump_stack();\r\nLBUG();\r\n}\r\nolck = osc_lock_at(lock);\r\nLASSERT(olck != NULL);\r\nLASSERT(ergo(opg->ops_srvlock, olck->ols_lock == NULL));\r\nif (olck->ols_lock != NULL) {\r\noa->o_handle = olck->ols_lock->l_remote_handle;\r\noa->o_valid |= OBD_MD_FLHANDLE;\r\n}\r\ncl_lock_put(env, lock);\r\n}\r\n}\r\nint osc_io_init(const struct lu_env *env,\r\nstruct cl_object *obj, struct cl_io *io)\r\n{\r\nstruct osc_io *oio = osc_env_io(env);\r\nCL_IO_SLICE_CLEAN(oio, oi_cl);\r\ncl_io_slice_add(io, &oio->oi_cl, obj, &osc_io_ops);\r\nreturn 0;\r\n}\r\nint osc_req_init(const struct lu_env *env, struct cl_device *dev,\r\nstruct cl_req *req)\r\n{\r\nstruct osc_req *or;\r\nint result;\r\nOBD_SLAB_ALLOC_PTR_GFP(or, osc_req_kmem, GFP_NOFS);\r\nif (or != NULL) {\r\ncl_req_slice_add(req, &or->or_cl, dev, &osc_req_ops);\r\nresult = 0;\r\n} else\r\nresult = -ENOMEM;\r\nreturn result;\r\n}
