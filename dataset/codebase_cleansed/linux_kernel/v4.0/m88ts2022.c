static int m88ts2022_cmd(struct m88ts2022_dev *dev, int op, int sleep, u8 reg,\r\nu8 mask, u8 val, u8 *reg_val)\r\n{\r\nint ret, i;\r\nunsigned int utmp;\r\nstruct m88ts2022_reg_val reg_vals[] = {\r\n{0x51, 0x1f - op},\r\n{0x51, 0x1f},\r\n{0x50, 0x00 + op},\r\n{0x50, 0x00},\r\n};\r\nfor (i = 0; i < 2; i++) {\r\ndev_dbg(&dev->client->dev,\r\n"i=%d op=%02x reg=%02x mask=%02x val=%02x\n",\r\ni, op, reg, mask, val);\r\nfor (i = 0; i < ARRAY_SIZE(reg_vals); i++) {\r\nret = regmap_write(dev->regmap, reg_vals[i].reg,\r\nreg_vals[i].val);\r\nif (ret)\r\ngoto err;\r\n}\r\nusleep_range(sleep * 1000, sleep * 10000);\r\nret = regmap_read(dev->regmap, reg, &utmp);\r\nif (ret)\r\ngoto err;\r\nif ((utmp & mask) != val)\r\nbreak;\r\n}\r\nif (reg_val)\r\n*reg_val = utmp;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int m88ts2022_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct m88ts2022_dev *dev = fe->tuner_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nunsigned int utmp, frequency_khz, frequency_offset_khz, f_3db_hz;\r\nunsigned int f_ref_khz, f_vco_khz, div_ref, div_out, pll_n, gdiv28;\r\nu8 buf[3], u8tmp, cap_code, lpf_gm, lpf_mxdiv, div_max, div_min;\r\nu16 u16tmp;\r\ndev_dbg(&dev->client->dev,\r\n"frequency=%d symbol_rate=%d rolloff=%d\n",\r\nc->frequency, c->symbol_rate, c->rolloff);\r\nf_ref_khz = DIV_ROUND_CLOSEST(dev->cfg.clock, 1000);\r\ndiv_ref = DIV_ROUND_CLOSEST(f_ref_khz, 2000);\r\nif (c->symbol_rate < 5000000)\r\nfrequency_offset_khz = 3000;\r\nelse\r\nfrequency_offset_khz = 0;\r\nfrequency_khz = c->frequency + frequency_offset_khz;\r\nif (frequency_khz < 1103000) {\r\ndiv_out = 4;\r\nu8tmp = 0x1b;\r\n} else {\r\ndiv_out = 2;\r\nu8tmp = 0x0b;\r\n}\r\nbuf[0] = u8tmp;\r\nbuf[1] = 0x40;\r\nret = regmap_bulk_write(dev->regmap, 0x10, buf, 2);\r\nif (ret)\r\ngoto err;\r\nf_vco_khz = frequency_khz * div_out;\r\npll_n = f_vco_khz * div_ref / f_ref_khz;\r\npll_n += pll_n % 2;\r\ndev->frequency_khz = pll_n * f_ref_khz / div_ref / div_out;\r\nif (pll_n < 4095)\r\nu16tmp = pll_n - 1024;\r\nelse if (pll_n < 6143)\r\nu16tmp = pll_n + 1024;\r\nelse\r\nu16tmp = pll_n + 3072;\r\nbuf[0] = (u16tmp >> 8) & 0x3f;\r\nbuf[1] = (u16tmp >> 0) & 0xff;\r\nbuf[2] = div_ref - 8;\r\nret = regmap_bulk_write(dev->regmap, 0x01, buf, 3);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&dev->client->dev,\r\n"frequency=%u offset=%d f_vco_khz=%u pll_n=%u div_ref=%u div_out=%u\n",\r\ndev->frequency_khz, dev->frequency_khz - c->frequency,\r\nf_vco_khz, pll_n, div_ref, div_out);\r\nret = m88ts2022_cmd(dev, 0x10, 5, 0x15, 0x40, 0x00, NULL);\r\nif (ret)\r\ngoto err;\r\nret = regmap_read(dev->regmap, 0x14, &utmp);\r\nif (ret)\r\ngoto err;\r\nutmp &= 0x7f;\r\nif (utmp < 64) {\r\nret = regmap_update_bits(dev->regmap, 0x10, 0x80, 0x80);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x11, 0x6f);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_cmd(dev, 0x10, 5, 0x15, 0x40, 0x00, NULL);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = regmap_read(dev->regmap, 0x14, &utmp);\r\nif (ret)\r\ngoto err;\r\nutmp &= 0x1f;\r\nif (utmp > 19) {\r\nret = regmap_update_bits(dev->regmap, 0x10, 0x02, 0x00);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = m88ts2022_cmd(dev, 0x08, 5, 0x3c, 0xff, 0x00, NULL);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x25, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x27, 0x70);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x41, 0x09);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x08, 0x0b);\r\nif (ret)\r\ngoto err;\r\ngdiv28 = DIV_ROUND_CLOSEST(f_ref_khz * 1694U, 1000000U);\r\nret = regmap_write(dev->regmap, 0x04, gdiv28);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_cmd(dev, 0x04, 2, 0x26, 0xff, 0x00, &u8tmp);\r\nif (ret)\r\ngoto err;\r\ncap_code = u8tmp & 0x3f;\r\nret = regmap_write(dev->regmap, 0x41, 0x0d);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_cmd(dev, 0x04, 2, 0x26, 0xff, 0x00, &u8tmp);\r\nif (ret)\r\ngoto err;\r\nu8tmp &= 0x3f;\r\ncap_code = (cap_code + u8tmp) / 2;\r\ngdiv28 = gdiv28 * 207 / (cap_code * 2 + 151);\r\ndiv_max = gdiv28 * 135 / 100;\r\ndiv_min = gdiv28 * 78 / 100;\r\ndiv_max = clamp_val(div_max, 0U, 63U);\r\nf_3db_hz = mult_frac(c->symbol_rate, 135, 200);\r\nf_3db_hz += 2000000U + (frequency_offset_khz * 1000U);\r\nf_3db_hz = clamp(f_3db_hz, 7000000U, 40000000U);\r\n#define LPF_COEFF 3200U\r\nlpf_gm = DIV_ROUND_CLOSEST(f_3db_hz * gdiv28, LPF_COEFF * f_ref_khz);\r\nlpf_gm = clamp_val(lpf_gm, 1U, 23U);\r\nlpf_mxdiv = DIV_ROUND_CLOSEST(lpf_gm * LPF_COEFF * f_ref_khz, f_3db_hz);\r\nif (lpf_mxdiv < div_min)\r\nlpf_mxdiv = DIV_ROUND_CLOSEST(++lpf_gm * LPF_COEFF * f_ref_khz, f_3db_hz);\r\nlpf_mxdiv = clamp_val(lpf_mxdiv, 0U, div_max);\r\nret = regmap_write(dev->regmap, 0x04, lpf_mxdiv);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x06, lpf_gm);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_cmd(dev, 0x04, 2, 0x26, 0xff, 0x00, &u8tmp);\r\nif (ret)\r\ngoto err;\r\ncap_code = u8tmp & 0x3f;\r\nret = regmap_write(dev->regmap, 0x41, 0x09);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_cmd(dev, 0x04, 2, 0x26, 0xff, 0x00, &u8tmp);\r\nif (ret)\r\ngoto err;\r\nu8tmp &= 0x3f;\r\ncap_code = (cap_code + u8tmp) / 2;\r\nu8tmp = cap_code | 0x80;\r\nret = regmap_write(dev->regmap, 0x25, u8tmp);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x27, 0x30);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x08, 0x09);\r\nif (ret)\r\ngoto err;\r\nret = m88ts2022_cmd(dev, 0x01, 20, 0x21, 0xff, 0x00, NULL);\r\nif (ret)\r\ngoto err;\r\nerr:\r\nif (ret)\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88ts2022_init(struct dvb_frontend *fe)\r\n{\r\nstruct m88ts2022_dev *dev = fe->tuner_priv;\r\nint ret, i;\r\nu8 u8tmp;\r\nstatic const struct m88ts2022_reg_val reg_vals[] = {\r\n{0x7d, 0x9d},\r\n{0x7c, 0x9a},\r\n{0x7a, 0x76},\r\n{0x3b, 0x01},\r\n{0x63, 0x88},\r\n{0x61, 0x85},\r\n{0x22, 0x30},\r\n{0x30, 0x40},\r\n{0x20, 0x23},\r\n{0x24, 0x02},\r\n{0x12, 0xa0},\r\n};\r\ndev_dbg(&dev->client->dev, "\n");\r\nret = regmap_write(dev->regmap, 0x00, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x00, 0x03);\r\nif (ret)\r\ngoto err;\r\nswitch (dev->cfg.clock_out) {\r\ncase M88TS2022_CLOCK_OUT_DISABLED:\r\nu8tmp = 0x60;\r\nbreak;\r\ncase M88TS2022_CLOCK_OUT_ENABLED:\r\nu8tmp = 0x70;\r\nret = regmap_write(dev->regmap, 0x05, dev->cfg.clock_out_div);\r\nif (ret)\r\ngoto err;\r\nbreak;\r\ncase M88TS2022_CLOCK_OUT_ENABLED_XTALOUT:\r\nu8tmp = 0x6c;\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\nret = regmap_write(dev->regmap, 0x42, u8tmp);\r\nif (ret)\r\ngoto err;\r\nif (dev->cfg.loop_through)\r\nu8tmp = 0xec;\r\nelse\r\nu8tmp = 0x6c;\r\nret = regmap_write(dev->regmap, 0x62, u8tmp);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(reg_vals); i++) {\r\nret = regmap_write(dev->regmap, reg_vals[i].reg, reg_vals[i].val);\r\nif (ret)\r\ngoto err;\r\n}\r\nerr:\r\nif (ret)\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88ts2022_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct m88ts2022_dev *dev = fe->tuner_priv;\r\nint ret;\r\ndev_dbg(&dev->client->dev, "\n");\r\nret = regmap_write(dev->regmap, 0x00, 0x00);\r\nif (ret)\r\ngoto err;\r\nerr:\r\nif (ret)\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88ts2022_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct m88ts2022_dev *dev = fe->tuner_priv;\r\ndev_dbg(&dev->client->dev, "\n");\r\n*frequency = dev->frequency_khz;\r\nreturn 0;\r\n}\r\nstatic int m88ts2022_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct m88ts2022_dev *dev = fe->tuner_priv;\r\ndev_dbg(&dev->client->dev, "\n");\r\n*frequency = 0;\r\nreturn 0;\r\n}\r\nstatic int m88ts2022_get_rf_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct m88ts2022_dev *dev = fe->tuner_priv;\r\nint ret;\r\nu16 gain, u16tmp;\r\nunsigned int utmp, gain1, gain2, gain3;\r\nret = regmap_read(dev->regmap, 0x3d, &utmp);\r\nif (ret)\r\ngoto err;\r\ngain1 = (utmp >> 0) & 0x1f;\r\ngain1 = clamp(gain1, 0U, 15U);\r\nret = regmap_read(dev->regmap, 0x21, &utmp);\r\nif (ret)\r\ngoto err;\r\ngain2 = (utmp >> 0) & 0x1f;\r\ngain2 = clamp(gain2, 2U, 16U);\r\nret = regmap_read(dev->regmap, 0x66, &utmp);\r\nif (ret)\r\ngoto err;\r\ngain3 = (utmp >> 3) & 0x07;\r\ngain3 = clamp(gain3, 0U, 6U);\r\ngain = gain1 * 265 + gain2 * 338 + gain3 * 285;\r\nu16tmp = (0xffff - gain);\r\nu16tmp = clamp_val(u16tmp, 59000U, 61500U);\r\n*strength = (u16tmp - 59000) * 0xffff / (61500 - 59000);\r\nerr:\r\nif (ret)\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88ts2022_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct m88ts2022_config *cfg = client->dev.platform_data;\r\nstruct dvb_frontend *fe = cfg->fe;\r\nstruct m88ts2022_dev *dev;\r\nint ret;\r\nu8 u8tmp;\r\nunsigned int utmp;\r\nstatic const struct regmap_config regmap_config = {\r\n.reg_bits = 8,\r\n.val_bits = 8,\r\n};\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ndev_err(&client->dev, "kzalloc() failed\n");\r\ngoto err;\r\n}\r\nmemcpy(&dev->cfg, cfg, sizeof(struct m88ts2022_config));\r\ndev->client = client;\r\ndev->regmap = devm_regmap_init_i2c(client, &regmap_config);\r\nif (IS_ERR(dev->regmap)) {\r\nret = PTR_ERR(dev->regmap);\r\ngoto err;\r\n}\r\nret = regmap_read(dev->regmap, 0x00, &utmp);\r\nif (ret)\r\ngoto err;\r\nif ((utmp & 0x03) == 0x00) {\r\nret = regmap_write(dev->regmap, 0x00, 0x01);\r\nif (ret)\r\ngoto err;\r\nusleep_range(2000, 50000);\r\n}\r\nret = regmap_write(dev->regmap, 0x00, 0x03);\r\nif (ret)\r\ngoto err;\r\nusleep_range(2000, 50000);\r\nret = regmap_read(dev->regmap, 0x00, &utmp);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&dev->client->dev, "chip_id=%02x\n", utmp);\r\nswitch (utmp) {\r\ncase 0xc3:\r\ncase 0x83:\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nswitch (dev->cfg.clock_out) {\r\ncase M88TS2022_CLOCK_OUT_DISABLED:\r\nu8tmp = 0x60;\r\nbreak;\r\ncase M88TS2022_CLOCK_OUT_ENABLED:\r\nu8tmp = 0x70;\r\nret = regmap_write(dev->regmap, 0x05, dev->cfg.clock_out_div);\r\nif (ret)\r\ngoto err;\r\nbreak;\r\ncase M88TS2022_CLOCK_OUT_ENABLED_XTALOUT:\r\nu8tmp = 0x6c;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = regmap_write(dev->regmap, 0x42, u8tmp);\r\nif (ret)\r\ngoto err;\r\nif (dev->cfg.loop_through)\r\nu8tmp = 0xec;\r\nelse\r\nu8tmp = 0x6c;\r\nret = regmap_write(dev->regmap, 0x62, u8tmp);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x00, 0x00);\r\nif (ret)\r\ngoto err;\r\ndev_info(&dev->client->dev, "Montage M88TS2022 successfully identified\n");\r\nfe->tuner_priv = dev;\r\nmemcpy(&fe->ops.tuner_ops, &m88ts2022_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\ni2c_set_clientdata(client, dev);\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nkfree(dev);\r\nreturn ret;\r\n}\r\nstatic int m88ts2022_remove(struct i2c_client *client)\r\n{\r\nstruct m88ts2022_dev *dev = i2c_get_clientdata(client);\r\nstruct dvb_frontend *fe = dev->cfg.fe;\r\ndev_dbg(&client->dev, "\n");\r\nmemset(&fe->ops.tuner_ops, 0, sizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = NULL;\r\nkfree(dev);\r\nreturn 0;\r\n}
