static int venc_is_second_field(struct vpbe_display *disp_dev)\r\n{\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nint ret;\r\nint val;\r\nret = v4l2_subdev_call(vpbe_dev->venc,\r\ncore,\r\nioctl,\r\nVENC_GET_FLD,\r\n&val);\r\nif (ret < 0) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Error in getting Field ID 0\n");\r\n}\r\nreturn val;\r\n}\r\nstatic void vpbe_isr_even_field(struct vpbe_display *disp_obj,\r\nstruct vpbe_layer *layer)\r\n{\r\nstruct timespec timevalue;\r\nif (layer->cur_frm == layer->next_frm)\r\nreturn;\r\nktime_get_ts(&timevalue);\r\nlayer->cur_frm->vb.v4l2_buf.timestamp.tv_sec =\r\ntimevalue.tv_sec;\r\nlayer->cur_frm->vb.v4l2_buf.timestamp.tv_usec =\r\ntimevalue.tv_nsec / NSEC_PER_USEC;\r\nvb2_buffer_done(&layer->cur_frm->vb, VB2_BUF_STATE_DONE);\r\nlayer->cur_frm = layer->next_frm;\r\n}\r\nstatic void vpbe_isr_odd_field(struct vpbe_display *disp_obj,\r\nstruct vpbe_layer *layer)\r\n{\r\nstruct osd_state *osd_device = disp_obj->osd_device;\r\nunsigned long addr;\r\nspin_lock(&disp_obj->dma_queue_lock);\r\nif (list_empty(&layer->dma_queue) ||\r\n(layer->cur_frm != layer->next_frm)) {\r\nspin_unlock(&disp_obj->dma_queue_lock);\r\nreturn;\r\n}\r\nlayer->next_frm = list_entry(layer->dma_queue.next,\r\nstruct vpbe_disp_buffer, list);\r\nlist_del(&layer->next_frm->list);\r\nspin_unlock(&disp_obj->dma_queue_lock);\r\nlayer->next_frm->vb.state = VB2_BUF_STATE_ACTIVE;\r\naddr = vb2_dma_contig_plane_dma_addr(&layer->next_frm->vb, 0);\r\nosd_device->ops.start_layer(osd_device,\r\nlayer->layer_info.id,\r\naddr,\r\ndisp_obj->cbcr_ofst);\r\n}\r\nstatic irqreturn_t venc_isr(int irq, void *arg)\r\n{\r\nstruct vpbe_display *disp_dev = (struct vpbe_display *)arg;\r\nstruct vpbe_layer *layer;\r\nstatic unsigned last_event;\r\nunsigned event = 0;\r\nint fid;\r\nint i;\r\nif ((NULL == arg) || (NULL == disp_dev->dev[0]))\r\nreturn IRQ_HANDLED;\r\nif (venc_is_second_field(disp_dev))\r\nevent |= VENC_SECOND_FIELD;\r\nelse\r\nevent |= VENC_FIRST_FIELD;\r\nif (event == (last_event & ~VENC_END_OF_FRAME)) {\r\nevent |= VENC_END_OF_FRAME;\r\n} else if (event == VENC_SECOND_FIELD) {\r\nevent |= VENC_END_OF_FRAME;\r\n}\r\nlast_event = event;\r\nfor (i = 0; i < VPBE_DISPLAY_MAX_DEVICES; i++) {\r\nlayer = disp_dev->dev[i];\r\nif (!vb2_start_streaming_called(&layer->buffer_queue))\r\ncontinue;\r\nif (layer->layer_first_int) {\r\nlayer->layer_first_int = 0;\r\ncontinue;\r\n}\r\nif ((V4L2_FIELD_NONE == layer->pix_fmt.field) &&\r\n(event & VENC_END_OF_FRAME)) {\r\nvpbe_isr_even_field(disp_dev, layer);\r\nvpbe_isr_odd_field(disp_dev, layer);\r\n} else {\r\nlayer->field_id ^= 1;\r\nif (event & VENC_FIRST_FIELD)\r\nfid = 0;\r\nelse\r\nfid = 1;\r\nif (fid != layer->field_id) {\r\nlayer->field_id = fid;\r\ncontinue;\r\n}\r\nif (0 == fid)\r\nvpbe_isr_even_field(disp_dev, layer);\r\nelse\r\nvpbe_isr_odd_field(disp_dev, layer);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vpbe_buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nstruct vpbe_layer *layer = vb2_get_drv_priv(q);\r\nstruct vpbe_device *vpbe_dev = layer->disp_dev->vpbe_dev;\r\nunsigned long addr;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"vpbe_buffer_prepare\n");\r\nvb2_set_plane_payload(vb, 0, layer->pix_fmt.sizeimage);\r\nif (vb2_get_plane_payload(vb, 0) > vb2_plane_size(vb, 0))\r\nreturn -EINVAL;\r\naddr = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nif (!IS_ALIGNED(addr, 8)) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"buffer_prepare:offset is not aligned to 32 bytes\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nvpbe_buffer_queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct vpbe_layer *layer = vb2_get_drv_priv(vq);\r\nstruct vpbe_device *vpbe_dev = layer->disp_dev->vpbe_dev;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "vpbe_buffer_setup\n");\r\nif (fmt && fmt->fmt.pix.sizeimage < layer->pix_fmt.sizeimage)\r\nreturn -EINVAL;\r\nif (vq->num_buffers + *nbuffers < VPBE_DEFAULT_NUM_BUFS)\r\n*nbuffers = VPBE_DEFAULT_NUM_BUFS - vq->num_buffers;\r\n*nplanes = 1;\r\nsizes[0] = fmt ? fmt->fmt.pix.sizeimage : layer->pix_fmt.sizeimage;\r\nalloc_ctxs[0] = layer->alloc_ctx;\r\nreturn 0;\r\n}\r\nstatic void vpbe_buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vpbe_disp_buffer *buf = container_of(vb,\r\nstruct vpbe_disp_buffer, vb);\r\nstruct vpbe_layer *layer = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vpbe_display *disp = layer->disp_dev;\r\nstruct vpbe_device *vpbe_dev = layer->disp_dev->vpbe_dev;\r\nunsigned long flags;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"vpbe_buffer_queue\n");\r\nspin_lock_irqsave(&disp->dma_queue_lock, flags);\r\nlist_add_tail(&buf->list, &layer->dma_queue);\r\nspin_unlock_irqrestore(&disp->dma_queue_lock, flags);\r\n}\r\nstatic int vpbe_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct vpbe_layer *layer = vb2_get_drv_priv(vq);\r\nstruct osd_state *osd_device = layer->disp_dev->osd_device;\r\nint ret;\r\nosd_device->ops.disable_layer(osd_device, layer->layer_info.id);\r\nlayer->next_frm = layer->cur_frm = list_entry(layer->dma_queue.next,\r\nstruct vpbe_disp_buffer, list);\r\nlist_del(&layer->cur_frm->list);\r\nlayer->cur_frm->vb.state = VB2_BUF_STATE_ACTIVE;\r\nlayer->field_id = 0;\r\nret = vpbe_set_osd_display_params(layer->disp_dev, layer);\r\nif (ret < 0) {\r\nstruct vpbe_disp_buffer *buf, *tmp;\r\nvb2_buffer_done(&layer->cur_frm->vb, VB2_BUF_STATE_QUEUED);\r\nlist_for_each_entry_safe(buf, tmp, &layer->dma_queue, list) {\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_QUEUED);\r\n}\r\nreturn ret;\r\n}\r\nlayer->layer_first_int = 1;\r\nreturn ret;\r\n}\r\nstatic void vpbe_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct vpbe_layer *layer = vb2_get_drv_priv(vq);\r\nstruct osd_state *osd_device = layer->disp_dev->osd_device;\r\nstruct vpbe_display *disp = layer->disp_dev;\r\nunsigned long flags;\r\nif (!vb2_is_streaming(vq))\r\nreturn;\r\nosd_device->ops.disable_layer(osd_device, layer->layer_info.id);\r\nspin_lock_irqsave(&disp->dma_queue_lock, flags);\r\nif (layer->cur_frm == layer->next_frm) {\r\nvb2_buffer_done(&layer->cur_frm->vb, VB2_BUF_STATE_ERROR);\r\n} else {\r\nif (layer->cur_frm != NULL)\r\nvb2_buffer_done(&layer->cur_frm->vb,\r\nVB2_BUF_STATE_ERROR);\r\nif (layer->next_frm != NULL)\r\nvb2_buffer_done(&layer->next_frm->vb,\r\nVB2_BUF_STATE_ERROR);\r\n}\r\nwhile (!list_empty(&layer->dma_queue)) {\r\nlayer->next_frm = list_entry(layer->dma_queue.next,\r\nstruct vpbe_disp_buffer, list);\r\nlist_del(&layer->next_frm->list);\r\nvb2_buffer_done(&layer->next_frm->vb, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&disp->dma_queue_lock, flags);\r\n}\r\nstatic\r\nstruct vpbe_layer*\r\n_vpbe_display_get_other_win_layer(struct vpbe_display *disp_dev,\r\nstruct vpbe_layer *layer)\r\n{\r\nenum vpbe_display_device_id thiswin, otherwin;\r\nthiswin = layer->device_id;\r\notherwin = (thiswin == VPBE_DISPLAY_DEVICE_0) ?\r\nVPBE_DISPLAY_DEVICE_1 : VPBE_DISPLAY_DEVICE_0;\r\nreturn disp_dev->dev[otherwin];\r\n}\r\nstatic int vpbe_set_osd_display_params(struct vpbe_display *disp_dev,\r\nstruct vpbe_layer *layer)\r\n{\r\nstruct osd_layer_config *cfg = &layer->layer_info.config;\r\nstruct osd_state *osd_device = disp_dev->osd_device;\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nunsigned long addr;\r\nint ret;\r\naddr = vb2_dma_contig_plane_dma_addr(&layer->cur_frm->vb, 0);\r\nosd_device->ops.start_layer(osd_device,\r\nlayer->layer_info.id,\r\naddr,\r\ndisp_dev->cbcr_ofst);\r\nret = osd_device->ops.enable_layer(osd_device,\r\nlayer->layer_info.id, 0);\r\nif (ret < 0) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Error in enabling osd window layer 0\n");\r\nreturn -1;\r\n}\r\nlayer->layer_info.enable = 1;\r\nif (cfg->pixfmt == PIXFMT_NV12) {\r\nstruct vpbe_layer *otherlayer =\r\n_vpbe_display_get_other_win_layer(disp_dev, layer);\r\nret = osd_device->ops.enable_layer(osd_device,\r\notherlayer->layer_info.id, 1);\r\nif (ret < 0) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Error in enabling osd window layer 1\n");\r\nreturn -1;\r\n}\r\notherlayer->layer_info.enable = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nvpbe_disp_calculate_scale_factor(struct vpbe_display *disp_dev,\r\nstruct vpbe_layer *layer,\r\nint expected_xsize, int expected_ysize)\r\n{\r\nstruct display_layer_info *layer_info = &layer->layer_info;\r\nstruct v4l2_pix_format *pixfmt = &layer->pix_fmt;\r\nstruct osd_layer_config *cfg = &layer->layer_info.config;\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nint calculated_xsize;\r\nint h_exp = 0;\r\nint v_exp = 0;\r\nint h_scale;\r\nint v_scale;\r\nv4l2_std_id standard_id = vpbe_dev->current_timings.std_id;\r\ncfg->xsize = pixfmt->width;\r\ncfg->ysize = pixfmt->height;\r\nlayer_info->h_zoom = ZOOM_X1;\r\nlayer_info->v_zoom = ZOOM_X1;\r\nlayer_info->h_exp = H_EXP_OFF;\r\nlayer_info->v_exp = V_EXP_OFF;\r\nif (pixfmt->width < expected_xsize) {\r\nh_scale = vpbe_dev->current_timings.xres / pixfmt->width;\r\nif (h_scale < 2)\r\nh_scale = 1;\r\nelse if (h_scale >= 4)\r\nh_scale = 4;\r\nelse\r\nh_scale = 2;\r\ncfg->xsize *= h_scale;\r\nif (cfg->xsize < expected_xsize) {\r\nif ((standard_id & V4L2_STD_525_60) ||\r\n(standard_id & V4L2_STD_625_50)) {\r\ncalculated_xsize = (cfg->xsize *\r\nVPBE_DISPLAY_H_EXP_RATIO_N) /\r\nVPBE_DISPLAY_H_EXP_RATIO_D;\r\nif (calculated_xsize <= expected_xsize) {\r\nh_exp = 1;\r\ncfg->xsize = calculated_xsize;\r\n}\r\n}\r\n}\r\nif (h_scale == 2)\r\nlayer_info->h_zoom = ZOOM_X2;\r\nelse if (h_scale == 4)\r\nlayer_info->h_zoom = ZOOM_X4;\r\nif (h_exp)\r\nlayer_info->h_exp = H_EXP_9_OVER_8;\r\n} else {\r\ncfg->xsize = expected_xsize;\r\n}\r\nif (pixfmt->height < expected_ysize) {\r\nv_scale = expected_ysize / pixfmt->height;\r\nif (v_scale < 2)\r\nv_scale = 1;\r\nelse if (v_scale >= 4)\r\nv_scale = 4;\r\nelse\r\nv_scale = 2;\r\ncfg->ysize *= v_scale;\r\nif (cfg->ysize < expected_ysize) {\r\nif ((standard_id & V4L2_STD_625_50)) {\r\ncalculated_xsize = (cfg->ysize *\r\nVPBE_DISPLAY_V_EXP_RATIO_N) /\r\nVPBE_DISPLAY_V_EXP_RATIO_D;\r\nif (calculated_xsize <= expected_ysize) {\r\nv_exp = 1;\r\ncfg->ysize = calculated_xsize;\r\n}\r\n}\r\n}\r\nif (v_scale == 2)\r\nlayer_info->v_zoom = ZOOM_X2;\r\nelse if (v_scale == 4)\r\nlayer_info->v_zoom = ZOOM_X4;\r\nif (v_exp)\r\nlayer_info->h_exp = V_EXP_6_OVER_5;\r\n} else {\r\ncfg->ysize = expected_ysize;\r\n}\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"crop display xsize = %d, ysize = %d\n",\r\ncfg->xsize, cfg->ysize);\r\n}\r\nstatic void vpbe_disp_adj_position(struct vpbe_display *disp_dev,\r\nstruct vpbe_layer *layer,\r\nint top, int left)\r\n{\r\nstruct osd_layer_config *cfg = &layer->layer_info.config;\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\ncfg->xpos = min((unsigned int)left,\r\nvpbe_dev->current_timings.xres - cfg->xsize);\r\ncfg->ypos = min((unsigned int)top,\r\nvpbe_dev->current_timings.yres - cfg->ysize);\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"new xpos = %d, ypos = %d\n",\r\ncfg->xpos, cfg->ypos);\r\n}\r\nstatic void vpbe_disp_check_window_params(struct vpbe_display *disp_dev,\r\nstruct v4l2_rect *c)\r\n{\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nif ((c->width == 0) ||\r\n((c->width + c->left) > vpbe_dev->current_timings.xres))\r\nc->width = vpbe_dev->current_timings.xres - c->left;\r\nif ((c->height == 0) || ((c->height + c->top) >\r\nvpbe_dev->current_timings.yres))\r\nc->height = vpbe_dev->current_timings.yres - c->top;\r\nif (vpbe_dev->current_timings.interlaced)\r\nc->height &= (~0x01);\r\n}\r\nstatic int vpbe_try_format(struct vpbe_display *disp_dev,\r\nstruct v4l2_pix_format *pixfmt, int check)\r\n{\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nint min_height = 1;\r\nint min_width = 32;\r\nint max_height;\r\nint max_width;\r\nint bpp;\r\nif ((pixfmt->pixelformat != V4L2_PIX_FMT_UYVY) &&\r\n(pixfmt->pixelformat != V4L2_PIX_FMT_NV12))\r\npixfmt->pixelformat = V4L2_PIX_FMT_UYVY;\r\nif ((pixfmt->field != V4L2_FIELD_INTERLACED) &&\r\n(pixfmt->field != V4L2_FIELD_NONE)) {\r\nif (vpbe_dev->current_timings.interlaced)\r\npixfmt->field = V4L2_FIELD_INTERLACED;\r\nelse\r\npixfmt->field = V4L2_FIELD_NONE;\r\n}\r\nif (pixfmt->field == V4L2_FIELD_INTERLACED)\r\nmin_height = 2;\r\nif (pixfmt->pixelformat == V4L2_PIX_FMT_NV12)\r\nbpp = 1;\r\nelse\r\nbpp = 2;\r\nmax_width = vpbe_dev->current_timings.xres;\r\nmax_height = vpbe_dev->current_timings.yres;\r\nmin_width /= bpp;\r\nif (!pixfmt->width || (pixfmt->width < min_width) ||\r\n(pixfmt->width > max_width)) {\r\npixfmt->width = vpbe_dev->current_timings.xres;\r\n}\r\nif (!pixfmt->height || (pixfmt->height < min_height) ||\r\n(pixfmt->height > max_height)) {\r\npixfmt->height = vpbe_dev->current_timings.yres;\r\n}\r\nif (pixfmt->bytesperline < (pixfmt->width * bpp))\r\npixfmt->bytesperline = pixfmt->width * bpp;\r\npixfmt->bytesperline = ((pixfmt->width * bpp + 31) & ~31);\r\nif (pixfmt->pixelformat == V4L2_PIX_FMT_NV12)\r\npixfmt->sizeimage = pixfmt->bytesperline * pixfmt->height +\r\n(pixfmt->bytesperline * pixfmt->height >> 1);\r\nelse\r\npixfmt->sizeimage = pixfmt->bytesperline * pixfmt->height;\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct vpbe_device *vpbe_dev = layer->disp_dev->vpbe_dev;\r\ncap->device_caps = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nsnprintf(cap->driver, sizeof(cap->driver), "%s",\r\ndev_name(vpbe_dev->pdev));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",\r\ndev_name(vpbe_dev->pdev));\r\nstrlcpy(cap->card, vpbe_dev->cfg->module_name, sizeof(cap->card));\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_s_crop(struct file *file, void *priv,\r\nconst struct v4l2_crop *crop)\r\n{\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct vpbe_display *disp_dev = layer->disp_dev;\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nstruct osd_layer_config *cfg = &layer->layer_info.config;\r\nstruct osd_state *osd_device = disp_dev->osd_device;\r\nstruct v4l2_rect rect = crop->c;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"VIDIOC_S_CROP, layer id = %d\n", layer->device_id);\r\nif (crop->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Invalid buf type\n");\r\nreturn -EINVAL;\r\n}\r\nif (rect.top < 0)\r\nrect.top = 0;\r\nif (rect.left < 0)\r\nrect.left = 0;\r\nvpbe_disp_check_window_params(disp_dev, &rect);\r\nosd_device->ops.get_layer_config(osd_device,\r\nlayer->layer_info.id, cfg);\r\nvpbe_disp_calculate_scale_factor(disp_dev, layer,\r\nrect.width,\r\nrect.height);\r\nvpbe_disp_adj_position(disp_dev, layer, rect.top,\r\nrect.left);\r\nret = osd_device->ops.set_layer_config(osd_device,\r\nlayer->layer_info.id, cfg);\r\nif (ret < 0) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Error in set layer config:\n");\r\nreturn -EINVAL;\r\n}\r\nosd_device->ops.set_zoom(osd_device,\r\nlayer->layer_info.id,\r\nlayer->layer_info.h_zoom,\r\nlayer->layer_info.v_zoom);\r\nret = osd_device->ops.set_vid_expansion(osd_device,\r\nlayer->layer_info.h_exp,\r\nlayer->layer_info.v_exp);\r\nif (ret < 0) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Error in set vid expansion:\n");\r\nreturn -EINVAL;\r\n}\r\nif ((layer->layer_info.h_zoom != ZOOM_X1) ||\r\n(layer->layer_info.v_zoom != ZOOM_X1) ||\r\n(layer->layer_info.h_exp != H_EXP_OFF) ||\r\n(layer->layer_info.v_exp != V_EXP_OFF))\r\nosd_device->ops.set_interpolation_filter(osd_device, 1);\r\nelse\r\nosd_device->ops.set_interpolation_filter(osd_device, 0);\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_g_crop(struct file *file, void *priv,\r\nstruct v4l2_crop *crop)\r\n{\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct osd_layer_config *cfg = &layer->layer_info.config;\r\nstruct vpbe_device *vpbe_dev = layer->disp_dev->vpbe_dev;\r\nstruct osd_state *osd_device = layer->disp_dev->osd_device;\r\nstruct v4l2_rect *rect = &crop->c;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"VIDIOC_G_CROP, layer id = %d\n",\r\nlayer->device_id);\r\nif (crop->type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Invalid buf type\n");\r\nreturn -EINVAL;\r\n}\r\nosd_device->ops.get_layer_config(osd_device,\r\nlayer->layer_info.id, cfg);\r\nrect->top = cfg->ypos;\r\nrect->left = cfg->xpos;\r\nrect->width = cfg->xsize;\r\nrect->height = cfg->ysize;\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *cropcap)\r\n{\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct vpbe_device *vpbe_dev = layer->disp_dev->vpbe_dev;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_CROPCAP ioctl\n");\r\ncropcap->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\ncropcap->bounds.left = 0;\r\ncropcap->bounds.top = 0;\r\ncropcap->bounds.width = vpbe_dev->current_timings.xres;\r\ncropcap->bounds.height = vpbe_dev->current_timings.yres;\r\ncropcap->pixelaspect = vpbe_dev->current_timings.aspect;\r\ncropcap->defrect = cropcap->bounds;\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_g_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct vpbe_device *vpbe_dev = layer->disp_dev->vpbe_dev;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"VIDIOC_G_FMT, layer id = %d\n",\r\nlayer->device_id);\r\nif (V4L2_BUF_TYPE_VIDEO_OUTPUT != fmt->type) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "invalid type\n");\r\nreturn -EINVAL;\r\n}\r\nfmt->fmt.pix = layer->pix_fmt;\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_enum_fmt(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct vpbe_device *vpbe_dev = layer->disp_dev->vpbe_dev;\r\nunsigned int index = 0;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"VIDIOC_ENUM_FMT, layer id = %d\n",\r\nlayer->device_id);\r\nif (fmt->index > 1) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Invalid format index\n");\r\nreturn -EINVAL;\r\n}\r\nindex = fmt->index;\r\nmemset(fmt, 0, sizeof(*fmt));\r\nfmt->index = index;\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nif (index == 0) {\r\nstrcpy(fmt->description, "YUV 4:2:2 - UYVY");\r\nfmt->pixelformat = V4L2_PIX_FMT_UYVY;\r\n} else {\r\nstrcpy(fmt->description, "Y/CbCr 4:2:0");\r\nfmt->pixelformat = V4L2_PIX_FMT_NV12;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_s_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct vpbe_display *disp_dev = layer->disp_dev;\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nstruct osd_layer_config *cfg = &layer->layer_info.config;\r\nstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\r\nstruct osd_state *osd_device = disp_dev->osd_device;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"VIDIOC_S_FMT, layer id = %d\n",\r\nlayer->device_id);\r\nif (vb2_is_busy(&layer->buffer_queue))\r\nreturn -EBUSY;\r\nif (V4L2_BUF_TYPE_VIDEO_OUTPUT != fmt->type) {\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "invalid type\n");\r\nreturn -EINVAL;\r\n}\r\nret = vpbe_try_format(disp_dev, pixfmt, 1);\r\nif (ret)\r\nreturn ret;\r\nlayer->pix_fmt = *pixfmt;\r\nif (pixfmt->pixelformat == V4L2_PIX_FMT_NV12) {\r\nstruct vpbe_layer *otherlayer;\r\notherlayer = _vpbe_display_get_other_win_layer(disp_dev, layer);\r\nret = osd_device->ops.request_layer(osd_device,\r\notherlayer->layer_info.id);\r\nif (ret < 0) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Display Manager failed to allocate layer\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nosd_device->ops.get_layer_config(osd_device,\r\nlayer->layer_info.id, cfg);\r\ncfg->xsize = pixfmt->width;\r\ncfg->ysize = pixfmt->height;\r\ncfg->line_length = pixfmt->bytesperline;\r\ncfg->ypos = 0;\r\ncfg->xpos = 0;\r\ncfg->interlaced = vpbe_dev->current_timings.interlaced;\r\nif (V4L2_PIX_FMT_UYVY == pixfmt->pixelformat)\r\ncfg->pixfmt = PIXFMT_YCBCRI;\r\nif (V4L2_PIX_FMT_NV12 == pixfmt->pixelformat) {\r\nstruct vpbe_layer *otherlayer;\r\ncfg->pixfmt = PIXFMT_NV12;\r\notherlayer = _vpbe_display_get_other_win_layer(disp_dev,\r\nlayer);\r\notherlayer->layer_info.config.pixfmt = PIXFMT_NV12;\r\n}\r\nret = osd_device->ops.set_layer_config(osd_device,\r\nlayer->layer_info.id, cfg);\r\nif (ret < 0) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Error in S_FMT params:\n");\r\nreturn -EINVAL;\r\n}\r\nosd_device->ops.get_layer_config(osd_device,\r\nlayer->layer_info.id, cfg);\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_try_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct vpbe_display *disp_dev = layer->disp_dev;\r\nstruct vpbe_device *vpbe_dev = layer->disp_dev->vpbe_dev;\r\nstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_TRY_FMT\n");\r\nif (V4L2_BUF_TYPE_VIDEO_OUTPUT != fmt->type) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "invalid type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn vpbe_try_format(disp_dev, pixfmt, 0);\r\n}\r\nstatic int vpbe_display_s_std(struct file *file, void *priv,\r\nv4l2_std_id std_id)\r\n{\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct vpbe_device *vpbe_dev = layer->disp_dev->vpbe_dev;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_S_STD\n");\r\nif (vb2_is_busy(&layer->buffer_queue))\r\nreturn -EBUSY;\r\nif (NULL != vpbe_dev->ops.s_std) {\r\nret = vpbe_dev->ops.s_std(vpbe_dev, std_id);\r\nif (ret) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Failed to set standard for sub devices\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_g_std(struct file *file, void *priv,\r\nv4l2_std_id *std_id)\r\n{\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct vpbe_device *vpbe_dev = layer->disp_dev->vpbe_dev;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_G_STD\n");\r\nif (vpbe_dev->current_timings.timings_type & VPBE_ENC_STD) {\r\n*std_id = vpbe_dev->current_timings.std_id;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vpbe_display_enum_output(struct file *file, void *priv,\r\nstruct v4l2_output *output)\r\n{\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct vpbe_device *vpbe_dev = layer->disp_dev->vpbe_dev;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_ENUM_OUTPUT\n");\r\nif (NULL == vpbe_dev->ops.enum_outputs)\r\nreturn -EINVAL;\r\nret = vpbe_dev->ops.enum_outputs(vpbe_dev, output);\r\nif (ret) {\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"Failed to enumerate outputs\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_s_output(struct file *file, void *priv,\r\nunsigned int i)\r\n{\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct vpbe_device *vpbe_dev = layer->disp_dev->vpbe_dev;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_S_OUTPUT\n");\r\nif (vb2_is_busy(&layer->buffer_queue))\r\nreturn -EBUSY;\r\nif (NULL == vpbe_dev->ops.set_output)\r\nreturn -EINVAL;\r\nret = vpbe_dev->ops.set_output(vpbe_dev, i);\r\nif (ret) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Failed to set output for sub devices\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_g_output(struct file *file, void *priv,\r\nunsigned int *i)\r\n{\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct vpbe_device *vpbe_dev = layer->disp_dev->vpbe_dev;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_G_OUTPUT\n");\r\n*i = vpbe_dev->current_out_index;\r\nreturn 0;\r\n}\r\nstatic int\r\nvpbe_display_enum_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct vpbe_device *vpbe_dev = layer->disp_dev->vpbe_dev;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_ENUM_DV_TIMINGS\n");\r\nif (NULL == vpbe_dev->ops.enum_dv_timings)\r\nreturn -EINVAL;\r\nret = vpbe_dev->ops.enum_dv_timings(vpbe_dev, timings);\r\nif (ret) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Failed to enumerate dv timings info\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nvpbe_display_s_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct vpbe_device *vpbe_dev = layer->disp_dev->vpbe_dev;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_S_DV_TIMINGS\n");\r\nif (vb2_is_busy(&layer->buffer_queue))\r\nreturn -EBUSY;\r\nif (!vpbe_dev->ops.s_dv_timings)\r\nreturn -EINVAL;\r\nret = vpbe_dev->ops.s_dv_timings(vpbe_dev, timings);\r\nif (ret) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Failed to set the dv timings info\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nvpbe_display_g_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_dv_timings *dv_timings)\r\n{\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct vpbe_device *vpbe_dev = layer->disp_dev->vpbe_dev;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "VIDIOC_G_DV_TIMINGS\n");\r\nif (vpbe_dev->current_timings.timings_type &\r\nVPBE_ENC_DV_TIMINGS) {\r\n*dv_timings = vpbe_dev->current_timings.dv_timings;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_open(struct file *file)\r\n{\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct vpbe_display *disp_dev = layer->disp_dev;\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nstruct osd_state *osd_device = disp_dev->osd_device;\r\nint err;\r\nerr = v4l2_fh_open(file);\r\nif (err) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "v4l2_fh_open failed\n");\r\nreturn err;\r\n}\r\nif (!v4l2_fh_is_singular_file(file))\r\nreturn err;\r\nif (!layer->usrs) {\r\nif (mutex_lock_interruptible(&layer->opslock))\r\nreturn -ERESTARTSYS;\r\nerr = osd_device->ops.request_layer(osd_device,\r\nlayer->layer_info.id);\r\nmutex_unlock(&layer->opslock);\r\nif (err < 0) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"Display Manager failed to allocate layer\n");\r\nv4l2_fh_release(file);\r\nreturn -EINVAL;\r\n}\r\n}\r\nlayer->usrs++;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev,\r\n"vpbe display device opened successfully\n");\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_release(struct file *file)\r\n{\r\nstruct vpbe_layer *layer = video_drvdata(file);\r\nstruct osd_layer_config *cfg = &layer->layer_info.config;\r\nstruct vpbe_display *disp_dev = layer->disp_dev;\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nstruct osd_state *osd_device = disp_dev->osd_device;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "vpbe_display_release\n");\r\nmutex_lock(&layer->opslock);\r\nosd_device->ops.disable_layer(osd_device,\r\nlayer->layer_info.id);\r\nlayer->usrs--;\r\nif (!layer->usrs) {\r\nif (cfg->pixfmt == PIXFMT_NV12) {\r\nstruct vpbe_layer *otherlayer;\r\notherlayer =\r\n_vpbe_display_get_other_win_layer(disp_dev, layer);\r\nosd_device->ops.disable_layer(osd_device,\r\notherlayer->layer_info.id);\r\nosd_device->ops.release_layer(osd_device,\r\notherlayer->layer_info.id);\r\n}\r\nosd_device->ops.disable_layer(osd_device,\r\nlayer->layer_info.id);\r\nosd_device->ops.release_layer(osd_device,\r\nlayer->layer_info.id);\r\n}\r\n_vb2_fop_release(file, NULL);\r\nmutex_unlock(&layer->opslock);\r\ndisp_dev->cbcr_ofst = 0;\r\nreturn 0;\r\n}\r\nstatic int vpbe_device_get(struct device *dev, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct vpbe_display *vpbe_disp = data;\r\nif (strcmp("vpbe_controller", pdev->name) == 0)\r\nvpbe_disp->vpbe_dev = platform_get_drvdata(pdev);\r\nif (strstr(pdev->name, "vpbe-osd") != NULL)\r\nvpbe_disp->osd_device = platform_get_drvdata(pdev);\r\nreturn 0;\r\n}\r\nstatic int init_vpbe_layer(int i, struct vpbe_display *disp_dev,\r\nstruct platform_device *pdev)\r\n{\r\nstruct vpbe_layer *vpbe_display_layer = NULL;\r\nstruct video_device *vbd = NULL;\r\ndisp_dev->dev[i] =\r\nkzalloc(sizeof(struct vpbe_layer), GFP_KERNEL);\r\nif (!disp_dev->dev[i]) {\r\nprintk(KERN_ERR "ran out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&disp_dev->dev[i]->irqlock);\r\nmutex_init(&disp_dev->dev[i]->opslock);\r\nvpbe_display_layer = disp_dev->dev[i];\r\nvbd = &vpbe_display_layer->video_dev;\r\nvbd->release = video_device_release_empty;\r\nvbd->fops = &vpbe_fops;\r\nvbd->ioctl_ops = &vpbe_ioctl_ops;\r\nvbd->minor = -1;\r\nvbd->v4l2_dev = &disp_dev->vpbe_dev->v4l2_dev;\r\nvbd->lock = &vpbe_display_layer->opslock;\r\nvbd->vfl_dir = VFL_DIR_TX;\r\nif (disp_dev->vpbe_dev->current_timings.timings_type &\r\nVPBE_ENC_STD)\r\nvbd->tvnorms = (V4L2_STD_525_60 | V4L2_STD_625_50);\r\nsnprintf(vbd->name, sizeof(vbd->name),\r\n"DaVinci_VPBE Display_DRIVER_V%d.%d.%d",\r\n(VPBE_DISPLAY_VERSION_CODE >> 16) & 0xff,\r\n(VPBE_DISPLAY_VERSION_CODE >> 8) & 0xff,\r\n(VPBE_DISPLAY_VERSION_CODE) & 0xff);\r\nvpbe_display_layer->device_id = i;\r\nvpbe_display_layer->layer_info.id =\r\n((i == VPBE_DISPLAY_DEVICE_0) ? WIN_VID0 : WIN_VID1);\r\nreturn 0;\r\n}\r\nstatic int register_device(struct vpbe_layer *vpbe_display_layer,\r\nstruct vpbe_display *disp_dev,\r\nstruct platform_device *pdev)\r\n{\r\nint err;\r\nv4l2_info(&disp_dev->vpbe_dev->v4l2_dev,\r\n"Trying to register VPBE display device.\n");\r\nv4l2_info(&disp_dev->vpbe_dev->v4l2_dev,\r\n"layer=%x,layer->video_dev=%x\n",\r\n(int)vpbe_display_layer,\r\n(int)&vpbe_display_layer->video_dev);\r\nvpbe_display_layer->video_dev.queue = &vpbe_display_layer->buffer_queue;\r\nerr = video_register_device(&vpbe_display_layer->video_dev,\r\nVFL_TYPE_GRABBER,\r\n-1);\r\nif (err)\r\nreturn -ENODEV;\r\nvpbe_display_layer->disp_dev = disp_dev;\r\nplatform_set_drvdata(pdev, disp_dev);\r\nvideo_set_drvdata(&vpbe_display_layer->video_dev,\r\nvpbe_display_layer);\r\nreturn 0;\r\n}\r\nstatic int vpbe_display_probe(struct platform_device *pdev)\r\n{\r\nstruct vpbe_display *disp_dev;\r\nstruct v4l2_device *v4l2_dev;\r\nstruct resource *res = NULL;\r\nstruct vb2_queue *q;\r\nint k;\r\nint i;\r\nint err;\r\nint irq;\r\nprintk(KERN_DEBUG "vpbe_display_probe\n");\r\ndisp_dev = devm_kzalloc(&pdev->dev, sizeof(struct vpbe_display),\r\nGFP_KERNEL);\r\nif (!disp_dev)\r\nreturn -ENOMEM;\r\nspin_lock_init(&disp_dev->dma_queue_lock);\r\nerr = bus_for_each_dev(&platform_bus_type, NULL, disp_dev,\r\nvpbe_device_get);\r\nif (err < 0)\r\nreturn err;\r\nv4l2_dev = &disp_dev->vpbe_dev->v4l2_dev;\r\nif (NULL != disp_dev->vpbe_dev->ops.initialize) {\r\nerr = disp_dev->vpbe_dev->ops.initialize(&pdev->dev,\r\ndisp_dev->vpbe_dev);\r\nif (err) {\r\nv4l2_err(v4l2_dev, "Error initing vpbe\n");\r\nerr = -ENOMEM;\r\ngoto probe_out;\r\n}\r\n}\r\nfor (i = 0; i < VPBE_DISPLAY_MAX_DEVICES; i++) {\r\nif (init_vpbe_layer(i, disp_dev, pdev)) {\r\nerr = -ENODEV;\r\ngoto probe_out;\r\n}\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\nv4l2_err(v4l2_dev, "Unable to get VENC interrupt resource\n");\r\nerr = -ENODEV;\r\ngoto probe_out;\r\n}\r\nirq = res->start;\r\nerr = devm_request_irq(&pdev->dev, irq, venc_isr, 0,\r\nVPBE_DISPLAY_DRIVER, disp_dev);\r\nif (err) {\r\nv4l2_err(v4l2_dev, "VPBE IRQ request failed\n");\r\ngoto probe_out;\r\n}\r\nfor (i = 0; i < VPBE_DISPLAY_MAX_DEVICES; i++) {\r\nq = &disp_dev->dev[i]->buffer_queue;\r\nmemset(q, 0, sizeof(*q));\r\nq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\r\nq->drv_priv = disp_dev->dev[i];\r\nq->ops = &video_qops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->buf_struct_size = sizeof(struct vpbe_disp_buffer);\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->min_buffers_needed = 1;\r\nq->lock = &disp_dev->dev[i]->opslock;\r\nerr = vb2_queue_init(q);\r\nif (err) {\r\nv4l2_err(v4l2_dev, "vb2_queue_init() failed\n");\r\ngoto probe_out;\r\n}\r\ndisp_dev->dev[i]->alloc_ctx =\r\nvb2_dma_contig_init_ctx(disp_dev->vpbe_dev->pdev);\r\nif (IS_ERR(disp_dev->dev[i]->alloc_ctx)) {\r\nv4l2_err(v4l2_dev, "Failed to get the context\n");\r\nerr = PTR_ERR(disp_dev->dev[i]->alloc_ctx);\r\ngoto probe_out;\r\n}\r\nINIT_LIST_HEAD(&disp_dev->dev[i]->dma_queue);\r\nif (register_device(disp_dev->dev[i], disp_dev, pdev)) {\r\nerr = -ENODEV;\r\ngoto probe_out;\r\n}\r\n}\r\nv4l2_dbg(1, debug, v4l2_dev,\r\n"Successfully completed the probing of vpbe v4l2 device\n");\r\nreturn 0;\r\nprobe_out:\r\nfor (k = 0; k < VPBE_DISPLAY_MAX_DEVICES; k++) {\r\nif (disp_dev->dev[k] != NULL) {\r\nvb2_dma_contig_cleanup_ctx(disp_dev->dev[k]->alloc_ctx);\r\nvideo_unregister_device(&disp_dev->dev[k]->video_dev);\r\nkfree(disp_dev->dev[k]);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int vpbe_display_remove(struct platform_device *pdev)\r\n{\r\nstruct vpbe_layer *vpbe_display_layer;\r\nstruct vpbe_display *disp_dev = platform_get_drvdata(pdev);\r\nstruct vpbe_device *vpbe_dev = disp_dev->vpbe_dev;\r\nint i;\r\nv4l2_dbg(1, debug, &vpbe_dev->v4l2_dev, "vpbe_display_remove\n");\r\nif (NULL != vpbe_dev->ops.deinitialize)\r\nvpbe_dev->ops.deinitialize(&pdev->dev, vpbe_dev);\r\nfor (i = 0; i < VPBE_DISPLAY_MAX_DEVICES; i++) {\r\nvpbe_display_layer = disp_dev->dev[i];\r\nvb2_dma_contig_cleanup_ctx(vpbe_display_layer->alloc_ctx);\r\nvideo_unregister_device(&vpbe_display_layer->video_dev);\r\n}\r\nfor (i = 0; i < VPBE_DISPLAY_MAX_DEVICES; i++) {\r\nkfree(disp_dev->dev[i]);\r\ndisp_dev->dev[i] = NULL;\r\n}\r\nreturn 0;\r\n}
