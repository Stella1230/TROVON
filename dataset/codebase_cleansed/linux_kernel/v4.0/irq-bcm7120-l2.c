static void bcm7120_l2_intc_irq_handle(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct bcm7120_l2_intc_data *b = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned int idx;\r\nchained_irq_enter(chip, desc);\r\nfor (idx = 0; idx < b->n_words; idx++) {\r\nint base = idx * IRQS_PER_WORD;\r\nstruct irq_chip_generic *gc =\r\nirq_get_domain_generic_chip(b->domain, base);\r\nunsigned long pending;\r\nint hwirq;\r\nirq_gc_lock(gc);\r\npending = irq_reg_readl(gc, IRQSTAT) & gc->mask_cache;\r\nirq_gc_unlock(gc);\r\nfor_each_set_bit(hwirq, &pending, IRQS_PER_WORD) {\r\ngeneric_handle_irq(irq_find_mapping(b->domain,\r\nbase + hwirq));\r\n}\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void bcm7120_l2_intc_suspend(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct bcm7120_l2_intc_data *b = gc->private;\r\nirq_gc_lock(gc);\r\nif (b->can_wake)\r\nirq_reg_writel(gc, gc->mask_cache | gc->wake_active, IRQEN);\r\nirq_gc_unlock(gc);\r\n}\r\nstatic void bcm7120_l2_intc_resume(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nirq_gc_lock(gc);\r\nirq_reg_writel(gc, gc->mask_cache, IRQEN);\r\nirq_gc_unlock(gc);\r\n}\r\nstatic int bcm7120_l2_intc_init_one(struct device_node *dn,\r\nstruct bcm7120_l2_intc_data *data,\r\nint irq, const __be32 *map_mask)\r\n{\r\nint parent_irq;\r\nunsigned int idx;\r\nparent_irq = irq_of_parse_and_map(dn, irq);\r\nif (!parent_irq) {\r\npr_err("failed to map interrupt %d\n", irq);\r\nreturn -EINVAL;\r\n}\r\nfor (idx = 0; idx < data->n_words; idx++)\r\ndata->irq_map_mask[idx] |=\r\nbe32_to_cpup(map_mask + irq * data->n_words + idx);\r\nirq_set_handler_data(parent_irq, data);\r\nirq_set_chained_handler(parent_irq, bcm7120_l2_intc_irq_handle);\r\nreturn 0;\r\n}\r\nint __init bcm7120_l2_intc_of_init(struct device_node *dn,\r\nstruct device_node *parent)\r\n{\r\nunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\r\nstruct bcm7120_l2_intc_data *data;\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\nconst __be32 *map_mask;\r\nint num_parent_irqs;\r\nint ret = 0, len;\r\nunsigned int idx, irq, flags;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nfor (idx = 0; idx < MAX_WORDS; idx++) {\r\ndata->base[idx] = of_iomap(dn, idx);\r\nif (!data->base[idx])\r\nbreak;\r\ndata->n_words = idx + 1;\r\n}\r\nif (!data->n_words) {\r\npr_err("failed to remap intc L2 registers\n");\r\nret = -ENOMEM;\r\ngoto out_unmap;\r\n}\r\nret = of_property_read_u32_array(dn, "brcm,int-fwd-mask",\r\ndata->irq_fwd_mask, data->n_words);\r\nif (ret == 0 || ret == -EINVAL) {\r\nfor (idx = 0; idx < data->n_words; idx++)\r\n__raw_writel(data->irq_fwd_mask[idx],\r\ndata->base[idx] + IRQEN);\r\n} else {\r\npr_err("invalid int-fwd-mask property\n");\r\nret = -EINVAL;\r\ngoto out_unmap;\r\n}\r\nnum_parent_irqs = of_irq_count(dn);\r\nif (num_parent_irqs <= 0) {\r\npr_err("invalid number of parent interrupts\n");\r\nret = -ENOMEM;\r\ngoto out_unmap;\r\n}\r\nmap_mask = of_get_property(dn, "brcm,int-map-mask", &len);\r\nif (!map_mask ||\r\n(len != (sizeof(*map_mask) * num_parent_irqs * data->n_words))) {\r\npr_err("invalid brcm,int-map-mask property\n");\r\nret = -EINVAL;\r\ngoto out_unmap;\r\n}\r\nfor (irq = 0; irq < num_parent_irqs; irq++) {\r\nret = bcm7120_l2_intc_init_one(dn, data, irq, map_mask);\r\nif (ret)\r\ngoto out_unmap;\r\n}\r\ndata->domain = irq_domain_add_linear(dn, IRQS_PER_WORD * data->n_words,\r\n&irq_generic_chip_ops, NULL);\r\nif (!data->domain) {\r\nret = -ENOMEM;\r\ngoto out_unmap;\r\n}\r\nflags = IRQ_GC_INIT_MASK_CACHE;\r\nif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\r\nflags |= IRQ_GC_BE_IO;\r\nret = irq_alloc_domain_generic_chips(data->domain, IRQS_PER_WORD, 1,\r\ndn->full_name, handle_level_irq, clr, 0, flags);\r\nif (ret) {\r\npr_err("failed to allocate generic irq chip\n");\r\ngoto out_free_domain;\r\n}\r\nif (of_property_read_bool(dn, "brcm,irq-can-wake"))\r\ndata->can_wake = true;\r\nfor (idx = 0; idx < data->n_words; idx++) {\r\nirq = idx * IRQS_PER_WORD;\r\ngc = irq_get_domain_generic_chip(data->domain, irq);\r\ngc->unused = 0xffffffff & ~data->irq_map_mask[idx];\r\ngc->reg_base = data->base[idx];\r\ngc->private = data;\r\nct = gc->chip_types;\r\nct->regs.mask = IRQEN;\r\nct->chip.irq_mask = irq_gc_mask_clr_bit;\r\nct->chip.irq_unmask = irq_gc_mask_set_bit;\r\nct->chip.irq_ack = irq_gc_noop;\r\nct->chip.irq_suspend = bcm7120_l2_intc_suspend;\r\nct->chip.irq_resume = bcm7120_l2_intc_resume;\r\nif (data->can_wake) {\r\ngc->wake_enabled = 0xffffffff;\r\ngc->wake_enabled &= ~gc->unused;\r\nct->chip.irq_set_wake = irq_gc_set_wake;\r\n}\r\n}\r\npr_info("registered BCM7120 L2 intc (mem: 0x%p, parent IRQ(s): %d)\n",\r\ndata->base[0], num_parent_irqs);\r\nreturn 0;\r\nout_free_domain:\r\nirq_domain_remove(data->domain);\r\nout_unmap:\r\nfor (idx = 0; idx < MAX_WORDS; idx++) {\r\nif (data->base[idx])\r\niounmap(data->base[idx]);\r\n}\r\nkfree(data);\r\nreturn ret;\r\n}
