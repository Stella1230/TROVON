static void tag_init(struct mvumi_tag *st, unsigned short size)\r\n{\r\nunsigned short i;\r\nBUG_ON(size != st->size);\r\nst->top = size;\r\nfor (i = 0; i < size; i++)\r\nst->stack[i] = size - 1 - i;\r\n}\r\nstatic unsigned short tag_get_one(struct mvumi_hba *mhba, struct mvumi_tag *st)\r\n{\r\nBUG_ON(st->top <= 0);\r\nreturn st->stack[--st->top];\r\n}\r\nstatic void tag_release_one(struct mvumi_hba *mhba, struct mvumi_tag *st,\r\nunsigned short tag)\r\n{\r\nBUG_ON(st->top >= st->size);\r\nst->stack[st->top++] = tag;\r\n}\r\nstatic bool tag_is_empty(struct mvumi_tag *st)\r\n{\r\nif (st->top == 0)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void mvumi_unmap_pci_addr(struct pci_dev *dev, void **addr_array)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_BASE_ADDRESS; i++)\r\nif ((pci_resource_flags(dev, i) & IORESOURCE_MEM) &&\r\naddr_array[i])\r\npci_iounmap(dev, addr_array[i]);\r\n}\r\nstatic int mvumi_map_pci_addr(struct pci_dev *dev, void **addr_array)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_BASE_ADDRESS; i++) {\r\nif (pci_resource_flags(dev, i) & IORESOURCE_MEM) {\r\naddr_array[i] = pci_iomap(dev, i, 0);\r\nif (!addr_array[i]) {\r\ndev_err(&dev->dev, "failed to map Bar[%d]\n",\r\ni);\r\nmvumi_unmap_pci_addr(dev, addr_array);\r\nreturn -ENOMEM;\r\n}\r\n} else\r\naddr_array[i] = NULL;\r\ndev_dbg(&dev->dev, "Bar %d : %p.\n", i, addr_array[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct mvumi_res *mvumi_alloc_mem_resource(struct mvumi_hba *mhba,\r\nenum resource_type type, unsigned int size)\r\n{\r\nstruct mvumi_res *res = kzalloc(sizeof(*res), GFP_ATOMIC);\r\nif (!res) {\r\ndev_err(&mhba->pdev->dev,\r\n"Failed to allocate memory for resource manager.\n");\r\nreturn NULL;\r\n}\r\nswitch (type) {\r\ncase RESOURCE_CACHED_MEMORY:\r\nres->virt_addr = kzalloc(size, GFP_ATOMIC);\r\nif (!res->virt_addr) {\r\ndev_err(&mhba->pdev->dev,\r\n"unable to allocate memory,size = %d.\n", size);\r\nkfree(res);\r\nreturn NULL;\r\n}\r\nbreak;\r\ncase RESOURCE_UNCACHED_MEMORY:\r\nsize = round_up(size, 8);\r\nres->virt_addr = pci_zalloc_consistent(mhba->pdev, size,\r\n&res->bus_addr);\r\nif (!res->virt_addr) {\r\ndev_err(&mhba->pdev->dev,\r\n"unable to allocate consistent mem,"\r\n"size = %d.\n", size);\r\nkfree(res);\r\nreturn NULL;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(&mhba->pdev->dev, "unknown resource type %d.\n", type);\r\nkfree(res);\r\nreturn NULL;\r\n}\r\nres->type = type;\r\nres->size = size;\r\nINIT_LIST_HEAD(&res->entry);\r\nlist_add_tail(&res->entry, &mhba->res_list);\r\nreturn res;\r\n}\r\nstatic void mvumi_release_mem_resource(struct mvumi_hba *mhba)\r\n{\r\nstruct mvumi_res *res, *tmp;\r\nlist_for_each_entry_safe(res, tmp, &mhba->res_list, entry) {\r\nswitch (res->type) {\r\ncase RESOURCE_UNCACHED_MEMORY:\r\npci_free_consistent(mhba->pdev, res->size,\r\nres->virt_addr, res->bus_addr);\r\nbreak;\r\ncase RESOURCE_CACHED_MEMORY:\r\nkfree(res->virt_addr);\r\nbreak;\r\ndefault:\r\ndev_err(&mhba->pdev->dev,\r\n"unknown resource type %d\n", res->type);\r\nbreak;\r\n}\r\nlist_del(&res->entry);\r\nkfree(res);\r\n}\r\nmhba->fw_flag &= ~MVUMI_FW_ALLOC;\r\n}\r\nstatic int mvumi_make_sgl(struct mvumi_hba *mhba, struct scsi_cmnd *scmd,\r\nvoid *sgl_p, unsigned char *sg_count)\r\n{\r\nstruct scatterlist *sg;\r\nstruct mvumi_sgl *m_sg = (struct mvumi_sgl *) sgl_p;\r\nunsigned int i;\r\nunsigned int sgnum = scsi_sg_count(scmd);\r\ndma_addr_t busaddr;\r\nif (sgnum) {\r\nsg = scsi_sglist(scmd);\r\n*sg_count = pci_map_sg(mhba->pdev, sg, sgnum,\r\n(int) scmd->sc_data_direction);\r\nif (*sg_count > mhba->max_sge) {\r\ndev_err(&mhba->pdev->dev, "sg count[0x%x] is bigger "\r\n"than max sg[0x%x].\n",\r\n*sg_count, mhba->max_sge);\r\nreturn -1;\r\n}\r\nfor (i = 0; i < *sg_count; i++) {\r\nbusaddr = sg_dma_address(&sg[i]);\r\nm_sg->baseaddr_l = cpu_to_le32(lower_32_bits(busaddr));\r\nm_sg->baseaddr_h = cpu_to_le32(upper_32_bits(busaddr));\r\nm_sg->flags = 0;\r\nsgd_setsz(mhba, m_sg, cpu_to_le32(sg_dma_len(&sg[i])));\r\nif ((i + 1) == *sg_count)\r\nm_sg->flags |= 1U << mhba->eot_flag;\r\nsgd_inc(mhba, m_sg);\r\n}\r\n} else {\r\nscmd->SCp.dma_handle = scsi_bufflen(scmd) ?\r\npci_map_single(mhba->pdev, scsi_sglist(scmd),\r\nscsi_bufflen(scmd),\r\n(int) scmd->sc_data_direction)\r\n: 0;\r\nbusaddr = scmd->SCp.dma_handle;\r\nm_sg->baseaddr_l = cpu_to_le32(lower_32_bits(busaddr));\r\nm_sg->baseaddr_h = cpu_to_le32(upper_32_bits(busaddr));\r\nm_sg->flags = 1U << mhba->eot_flag;\r\nsgd_setsz(mhba, m_sg, cpu_to_le32(scsi_bufflen(scmd)));\r\n*sg_count = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mvumi_internal_cmd_sgl(struct mvumi_hba *mhba, struct mvumi_cmd *cmd,\r\nunsigned int size)\r\n{\r\nstruct mvumi_sgl *m_sg;\r\nvoid *virt_addr;\r\ndma_addr_t phy_addr;\r\nif (size == 0)\r\nreturn 0;\r\nvirt_addr = pci_zalloc_consistent(mhba->pdev, size, &phy_addr);\r\nif (!virt_addr)\r\nreturn -1;\r\nm_sg = (struct mvumi_sgl *) &cmd->frame->payload[0];\r\ncmd->frame->sg_counts = 1;\r\ncmd->data_buf = virt_addr;\r\nm_sg->baseaddr_l = cpu_to_le32(lower_32_bits(phy_addr));\r\nm_sg->baseaddr_h = cpu_to_le32(upper_32_bits(phy_addr));\r\nm_sg->flags = 1U << mhba->eot_flag;\r\nsgd_setsz(mhba, m_sg, cpu_to_le32(size));\r\nreturn 0;\r\n}\r\nstatic struct mvumi_cmd *mvumi_create_internal_cmd(struct mvumi_hba *mhba,\r\nunsigned int buf_size)\r\n{\r\nstruct mvumi_cmd *cmd;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (!cmd) {\r\ndev_err(&mhba->pdev->dev, "failed to create a internal cmd\n");\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&cmd->queue_pointer);\r\ncmd->frame = pci_alloc_consistent(mhba->pdev,\r\nmhba->ib_max_size, &cmd->frame_phys);\r\nif (!cmd->frame) {\r\ndev_err(&mhba->pdev->dev, "failed to allocate memory for FW"\r\n" frame,size = %d.\n", mhba->ib_max_size);\r\nkfree(cmd);\r\nreturn NULL;\r\n}\r\nif (buf_size) {\r\nif (mvumi_internal_cmd_sgl(mhba, cmd, buf_size)) {\r\ndev_err(&mhba->pdev->dev, "failed to allocate memory"\r\n" for internal frame\n");\r\npci_free_consistent(mhba->pdev, mhba->ib_max_size,\r\ncmd->frame, cmd->frame_phys);\r\nkfree(cmd);\r\nreturn NULL;\r\n}\r\n} else\r\ncmd->frame->sg_counts = 0;\r\nreturn cmd;\r\n}\r\nstatic void mvumi_delete_internal_cmd(struct mvumi_hba *mhba,\r\nstruct mvumi_cmd *cmd)\r\n{\r\nstruct mvumi_sgl *m_sg;\r\nunsigned int size;\r\ndma_addr_t phy_addr;\r\nif (cmd && cmd->frame) {\r\nif (cmd->frame->sg_counts) {\r\nm_sg = (struct mvumi_sgl *) &cmd->frame->payload[0];\r\nsgd_getsz(mhba, m_sg, size);\r\nphy_addr = (dma_addr_t) m_sg->baseaddr_l |\r\n(dma_addr_t) ((m_sg->baseaddr_h << 16) << 16);\r\npci_free_consistent(mhba->pdev, size, cmd->data_buf,\r\nphy_addr);\r\n}\r\npci_free_consistent(mhba->pdev, mhba->ib_max_size,\r\ncmd->frame, cmd->frame_phys);\r\nkfree(cmd);\r\n}\r\n}\r\nstatic struct mvumi_cmd *mvumi_get_cmd(struct mvumi_hba *mhba)\r\n{\r\nstruct mvumi_cmd *cmd = NULL;\r\nif (likely(!list_empty(&mhba->cmd_pool))) {\r\ncmd = list_entry((&mhba->cmd_pool)->next,\r\nstruct mvumi_cmd, queue_pointer);\r\nlist_del_init(&cmd->queue_pointer);\r\n} else\r\ndev_warn(&mhba->pdev->dev, "command pool is empty!\n");\r\nreturn cmd;\r\n}\r\nstatic inline void mvumi_return_cmd(struct mvumi_hba *mhba,\r\nstruct mvumi_cmd *cmd)\r\n{\r\ncmd->scmd = NULL;\r\nlist_add_tail(&cmd->queue_pointer, &mhba->cmd_pool);\r\n}\r\nstatic void mvumi_free_cmds(struct mvumi_hba *mhba)\r\n{\r\nstruct mvumi_cmd *cmd;\r\nwhile (!list_empty(&mhba->cmd_pool)) {\r\ncmd = list_first_entry(&mhba->cmd_pool, struct mvumi_cmd,\r\nqueue_pointer);\r\nlist_del(&cmd->queue_pointer);\r\nif (!(mhba->hba_capability & HS_CAPABILITY_SUPPORT_DYN_SRC))\r\nkfree(cmd->frame);\r\nkfree(cmd);\r\n}\r\n}\r\nstatic int mvumi_alloc_cmds(struct mvumi_hba *mhba)\r\n{\r\nint i;\r\nstruct mvumi_cmd *cmd;\r\nfor (i = 0; i < mhba->max_io; i++) {\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (!cmd)\r\ngoto err_exit;\r\nINIT_LIST_HEAD(&cmd->queue_pointer);\r\nlist_add_tail(&cmd->queue_pointer, &mhba->cmd_pool);\r\nif (mhba->hba_capability & HS_CAPABILITY_SUPPORT_DYN_SRC) {\r\ncmd->frame = mhba->ib_frame + i * mhba->ib_max_size;\r\ncmd->frame_phys = mhba->ib_frame_phys\r\n+ i * mhba->ib_max_size;\r\n} else\r\ncmd->frame = kzalloc(mhba->ib_max_size, GFP_KERNEL);\r\nif (!cmd->frame)\r\ngoto err_exit;\r\n}\r\nreturn 0;\r\nerr_exit:\r\ndev_err(&mhba->pdev->dev,\r\n"failed to allocate memory for cmd[0x%x].\n", i);\r\nwhile (!list_empty(&mhba->cmd_pool)) {\r\ncmd = list_first_entry(&mhba->cmd_pool, struct mvumi_cmd,\r\nqueue_pointer);\r\nlist_del(&cmd->queue_pointer);\r\nif (!(mhba->hba_capability & HS_CAPABILITY_SUPPORT_DYN_SRC))\r\nkfree(cmd->frame);\r\nkfree(cmd);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic unsigned int mvumi_check_ib_list_9143(struct mvumi_hba *mhba)\r\n{\r\nunsigned int ib_rp_reg;\r\nstruct mvumi_hw_regs *regs = mhba->regs;\r\nib_rp_reg = ioread32(mhba->regs->inb_read_pointer);\r\nif (unlikely(((ib_rp_reg & regs->cl_slot_num_mask) ==\r\n(mhba->ib_cur_slot & regs->cl_slot_num_mask)) &&\r\n((ib_rp_reg & regs->cl_pointer_toggle)\r\n!= (mhba->ib_cur_slot & regs->cl_pointer_toggle)))) {\r\ndev_warn(&mhba->pdev->dev, "no free slot to use.\n");\r\nreturn 0;\r\n}\r\nif (atomic_read(&mhba->fw_outstanding) >= mhba->max_io) {\r\ndev_warn(&mhba->pdev->dev, "firmware io overflow.\n");\r\nreturn 0;\r\n} else {\r\nreturn mhba->max_io - atomic_read(&mhba->fw_outstanding);\r\n}\r\n}\r\nstatic unsigned int mvumi_check_ib_list_9580(struct mvumi_hba *mhba)\r\n{\r\nunsigned int count;\r\nif (atomic_read(&mhba->fw_outstanding) >= (mhba->max_io - 1))\r\nreturn 0;\r\ncount = ioread32(mhba->ib_shadow);\r\nif (count == 0xffff)\r\nreturn 0;\r\nreturn count;\r\n}\r\nstatic void mvumi_get_ib_list_entry(struct mvumi_hba *mhba, void **ib_entry)\r\n{\r\nunsigned int cur_ib_entry;\r\ncur_ib_entry = mhba->ib_cur_slot & mhba->regs->cl_slot_num_mask;\r\ncur_ib_entry++;\r\nif (cur_ib_entry >= mhba->list_num_io) {\r\ncur_ib_entry -= mhba->list_num_io;\r\nmhba->ib_cur_slot ^= mhba->regs->cl_pointer_toggle;\r\n}\r\nmhba->ib_cur_slot &= ~mhba->regs->cl_slot_num_mask;\r\nmhba->ib_cur_slot |= (cur_ib_entry & mhba->regs->cl_slot_num_mask);\r\nif (mhba->hba_capability & HS_CAPABILITY_SUPPORT_DYN_SRC) {\r\n*ib_entry = mhba->ib_list + cur_ib_entry *\r\nsizeof(struct mvumi_dyn_list_entry);\r\n} else {\r\n*ib_entry = mhba->ib_list + cur_ib_entry * mhba->ib_max_size;\r\n}\r\natomic_inc(&mhba->fw_outstanding);\r\n}\r\nstatic void mvumi_send_ib_list_entry(struct mvumi_hba *mhba)\r\n{\r\niowrite32(0xffff, mhba->ib_shadow);\r\niowrite32(mhba->ib_cur_slot, mhba->regs->inb_write_pointer);\r\n}\r\nstatic char mvumi_check_ob_frame(struct mvumi_hba *mhba,\r\nunsigned int cur_obf, struct mvumi_rsp_frame *p_outb_frame)\r\n{\r\nunsigned short tag, request_id;\r\nudelay(1);\r\np_outb_frame = mhba->ob_list + cur_obf * mhba->ob_max_size;\r\nrequest_id = p_outb_frame->request_id;\r\ntag = p_outb_frame->tag;\r\nif (tag > mhba->tag_pool.size) {\r\ndev_err(&mhba->pdev->dev, "ob frame data error\n");\r\nreturn -1;\r\n}\r\nif (mhba->tag_cmd[tag] == NULL) {\r\ndev_err(&mhba->pdev->dev, "tag[0x%x] with NO command\n", tag);\r\nreturn -1;\r\n} else if (mhba->tag_cmd[tag]->request_id != request_id &&\r\nmhba->request_id_enabled) {\r\ndev_err(&mhba->pdev->dev, "request ID from FW:0x%x,"\r\n"cmd request ID:0x%x\n", request_id,\r\nmhba->tag_cmd[tag]->request_id);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mvumi_check_ob_list_9143(struct mvumi_hba *mhba,\r\nunsigned int *cur_obf, unsigned int *assign_obf_end)\r\n{\r\nunsigned int ob_write, ob_write_shadow;\r\nstruct mvumi_hw_regs *regs = mhba->regs;\r\ndo {\r\nob_write = ioread32(regs->outb_copy_pointer);\r\nob_write_shadow = ioread32(mhba->ob_shadow);\r\n} while ((ob_write & regs->cl_slot_num_mask) != ob_write_shadow);\r\n*cur_obf = mhba->ob_cur_slot & mhba->regs->cl_slot_num_mask;\r\n*assign_obf_end = ob_write & mhba->regs->cl_slot_num_mask;\r\nif ((ob_write & regs->cl_pointer_toggle) !=\r\n(mhba->ob_cur_slot & regs->cl_pointer_toggle)) {\r\n*assign_obf_end += mhba->list_num_io;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mvumi_check_ob_list_9580(struct mvumi_hba *mhba,\r\nunsigned int *cur_obf, unsigned int *assign_obf_end)\r\n{\r\nunsigned int ob_write;\r\nstruct mvumi_hw_regs *regs = mhba->regs;\r\nob_write = ioread32(regs->outb_read_pointer);\r\nob_write = ioread32(regs->outb_copy_pointer);\r\n*cur_obf = mhba->ob_cur_slot & mhba->regs->cl_slot_num_mask;\r\n*assign_obf_end = ob_write & mhba->regs->cl_slot_num_mask;\r\nif (*assign_obf_end < *cur_obf)\r\n*assign_obf_end += mhba->list_num_io;\r\nelse if (*assign_obf_end == *cur_obf)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void mvumi_receive_ob_list_entry(struct mvumi_hba *mhba)\r\n{\r\nunsigned int cur_obf, assign_obf_end, i;\r\nstruct mvumi_ob_data *ob_data;\r\nstruct mvumi_rsp_frame *p_outb_frame;\r\nstruct mvumi_hw_regs *regs = mhba->regs;\r\nif (mhba->instancet->check_ob_list(mhba, &cur_obf, &assign_obf_end))\r\nreturn;\r\nfor (i = (assign_obf_end - cur_obf); i != 0; i--) {\r\ncur_obf++;\r\nif (cur_obf >= mhba->list_num_io) {\r\ncur_obf -= mhba->list_num_io;\r\nmhba->ob_cur_slot ^= regs->cl_pointer_toggle;\r\n}\r\np_outb_frame = mhba->ob_list + cur_obf * mhba->ob_max_size;\r\nif (unlikely(p_outb_frame->tag > mhba->tag_pool.size ||\r\nmhba->tag_cmd[p_outb_frame->tag] == NULL ||\r\np_outb_frame->request_id !=\r\nmhba->tag_cmd[p_outb_frame->tag]->request_id))\r\nif (mvumi_check_ob_frame(mhba, cur_obf, p_outb_frame))\r\ncontinue;\r\nif (!list_empty(&mhba->ob_data_list)) {\r\nob_data = (struct mvumi_ob_data *)\r\nlist_first_entry(&mhba->ob_data_list,\r\nstruct mvumi_ob_data, list);\r\nlist_del_init(&ob_data->list);\r\n} else {\r\nob_data = NULL;\r\nif (cur_obf == 0) {\r\ncur_obf = mhba->list_num_io - 1;\r\nmhba->ob_cur_slot ^= regs->cl_pointer_toggle;\r\n} else\r\ncur_obf -= 1;\r\nbreak;\r\n}\r\nmemcpy(ob_data->data, p_outb_frame, mhba->ob_max_size);\r\np_outb_frame->tag = 0xff;\r\nlist_add_tail(&ob_data->list, &mhba->free_ob_list);\r\n}\r\nmhba->ob_cur_slot &= ~regs->cl_slot_num_mask;\r\nmhba->ob_cur_slot |= (cur_obf & regs->cl_slot_num_mask);\r\niowrite32(mhba->ob_cur_slot, regs->outb_read_pointer);\r\n}\r\nstatic void mvumi_reset(struct mvumi_hba *mhba)\r\n{\r\nstruct mvumi_hw_regs *regs = mhba->regs;\r\niowrite32(0, regs->enpointa_mask_reg);\r\nif (ioread32(regs->arm_to_pciea_msg1) != HANDSHAKE_DONESTATE)\r\nreturn;\r\niowrite32(DRBL_SOFT_RESET, regs->pciea_to_arm_drbl_reg);\r\n}\r\nstatic int mvumi_wait_for_outstanding(struct mvumi_hba *mhba)\r\n{\r\nmhba->fw_state = FW_STATE_ABORT;\r\nmvumi_reset(mhba);\r\nif (mvumi_start(mhba))\r\nreturn FAILED;\r\nelse\r\nreturn SUCCESS;\r\n}\r\nstatic int mvumi_wait_for_fw(struct mvumi_hba *mhba)\r\n{\r\nstruct mvumi_hw_regs *regs = mhba->regs;\r\nu32 tmp;\r\nunsigned long before;\r\nbefore = jiffies;\r\niowrite32(0, regs->enpointa_mask_reg);\r\ntmp = ioread32(regs->arm_to_pciea_msg1);\r\nwhile (tmp != HANDSHAKE_READYSTATE) {\r\niowrite32(DRBL_MU_RESET, regs->pciea_to_arm_drbl_reg);\r\nif (time_after(jiffies, before + FW_MAX_DELAY * HZ)) {\r\ndev_err(&mhba->pdev->dev,\r\n"FW reset failed [0x%x].\n", tmp);\r\nreturn FAILED;\r\n}\r\nmsleep(500);\r\nrmb();\r\ntmp = ioread32(regs->arm_to_pciea_msg1);\r\n}\r\nreturn SUCCESS;\r\n}\r\nstatic void mvumi_backup_bar_addr(struct mvumi_hba *mhba)\r\n{\r\nunsigned char i;\r\nfor (i = 0; i < MAX_BASE_ADDRESS; i++) {\r\npci_read_config_dword(mhba->pdev, 0x10 + i * 4,\r\n&mhba->pci_base[i]);\r\n}\r\n}\r\nstatic void mvumi_restore_bar_addr(struct mvumi_hba *mhba)\r\n{\r\nunsigned char i;\r\nfor (i = 0; i < MAX_BASE_ADDRESS; i++) {\r\nif (mhba->pci_base[i])\r\npci_write_config_dword(mhba->pdev, 0x10 + i * 4,\r\nmhba->pci_base[i]);\r\n}\r\n}\r\nstatic unsigned int mvumi_pci_set_master(struct pci_dev *pdev)\r\n{\r\nunsigned int ret = 0;\r\npci_set_master(pdev);\r\nif (IS_DMA64) {\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(64)))\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\n} else\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nreturn ret;\r\n}\r\nstatic int mvumi_reset_host_9580(struct mvumi_hba *mhba)\r\n{\r\nmhba->fw_state = FW_STATE_ABORT;\r\niowrite32(0, mhba->regs->reset_enable);\r\niowrite32(0xf, mhba->regs->reset_request);\r\niowrite32(0x10, mhba->regs->reset_enable);\r\niowrite32(0x10, mhba->regs->reset_request);\r\nmsleep(100);\r\npci_disable_device(mhba->pdev);\r\nif (pci_enable_device(mhba->pdev)) {\r\ndev_err(&mhba->pdev->dev, "enable device failed\n");\r\nreturn FAILED;\r\n}\r\nif (mvumi_pci_set_master(mhba->pdev)) {\r\ndev_err(&mhba->pdev->dev, "set master failed\n");\r\nreturn FAILED;\r\n}\r\nmvumi_restore_bar_addr(mhba);\r\nif (mvumi_wait_for_fw(mhba) == FAILED)\r\nreturn FAILED;\r\nreturn mvumi_wait_for_outstanding(mhba);\r\n}\r\nstatic int mvumi_reset_host_9143(struct mvumi_hba *mhba)\r\n{\r\nreturn mvumi_wait_for_outstanding(mhba);\r\n}\r\nstatic int mvumi_host_reset(struct scsi_cmnd *scmd)\r\n{\r\nstruct mvumi_hba *mhba;\r\nmhba = (struct mvumi_hba *) scmd->device->host->hostdata;\r\nscmd_printk(KERN_NOTICE, scmd, "RESET -%ld cmd=%x retries=%x\n",\r\nscmd->serial_number, scmd->cmnd[0], scmd->retries);\r\nreturn mhba->instancet->reset_host(mhba);\r\n}\r\nstatic int mvumi_issue_blocked_cmd(struct mvumi_hba *mhba,\r\nstruct mvumi_cmd *cmd)\r\n{\r\nunsigned long flags;\r\ncmd->cmd_status = REQ_STATUS_PENDING;\r\nif (atomic_read(&cmd->sync_cmd)) {\r\ndev_err(&mhba->pdev->dev,\r\n"last blocked cmd not finished, sync_cmd = %d\n",\r\natomic_read(&cmd->sync_cmd));\r\nBUG_ON(1);\r\nreturn -1;\r\n}\r\natomic_inc(&cmd->sync_cmd);\r\nspin_lock_irqsave(mhba->shost->host_lock, flags);\r\nmhba->instancet->fire_cmd(mhba, cmd);\r\nspin_unlock_irqrestore(mhba->shost->host_lock, flags);\r\nwait_event_timeout(mhba->int_cmd_wait_q,\r\n(cmd->cmd_status != REQ_STATUS_PENDING),\r\nMVUMI_INTERNAL_CMD_WAIT_TIME * HZ);\r\nif (atomic_read(&cmd->sync_cmd)) {\r\nspin_lock_irqsave(mhba->shost->host_lock, flags);\r\natomic_dec(&cmd->sync_cmd);\r\nif (mhba->tag_cmd[cmd->frame->tag]) {\r\nmhba->tag_cmd[cmd->frame->tag] = 0;\r\ndev_warn(&mhba->pdev->dev, "TIMEOUT:release tag [%d]\n",\r\ncmd->frame->tag);\r\ntag_release_one(mhba, &mhba->tag_pool, cmd->frame->tag);\r\n}\r\nif (!list_empty(&cmd->queue_pointer)) {\r\ndev_warn(&mhba->pdev->dev,\r\n"TIMEOUT:A internal command doesn't send!\n");\r\nlist_del_init(&cmd->queue_pointer);\r\n} else\r\natomic_dec(&mhba->fw_outstanding);\r\nspin_unlock_irqrestore(mhba->shost->host_lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mvumi_release_fw(struct mvumi_hba *mhba)\r\n{\r\nmvumi_free_cmds(mhba);\r\nmvumi_release_mem_resource(mhba);\r\nmvumi_unmap_pci_addr(mhba->pdev, mhba->base_addr);\r\npci_free_consistent(mhba->pdev, HSP_MAX_SIZE,\r\nmhba->handshake_page, mhba->handshake_page_phys);\r\nkfree(mhba->regs);\r\npci_release_regions(mhba->pdev);\r\n}\r\nstatic unsigned char mvumi_flush_cache(struct mvumi_hba *mhba)\r\n{\r\nstruct mvumi_cmd *cmd;\r\nstruct mvumi_msg_frame *frame;\r\nunsigned char device_id, retry = 0;\r\nunsigned char bitcount = sizeof(unsigned char) * 8;\r\nfor (device_id = 0; device_id < mhba->max_target_id; device_id++) {\r\nif (!(mhba->target_map[device_id / bitcount] &\r\n(1 << (device_id % bitcount))))\r\ncontinue;\r\nget_cmd: cmd = mvumi_create_internal_cmd(mhba, 0);\r\nif (!cmd) {\r\nif (retry++ >= 5) {\r\ndev_err(&mhba->pdev->dev, "failed to get memory"\r\n" for internal flush cache cmd for "\r\n"device %d", device_id);\r\nretry = 0;\r\ncontinue;\r\n} else\r\ngoto get_cmd;\r\n}\r\ncmd->scmd = NULL;\r\ncmd->cmd_status = REQ_STATUS_PENDING;\r\natomic_set(&cmd->sync_cmd, 0);\r\nframe = cmd->frame;\r\nframe->req_function = CL_FUN_SCSI_CMD;\r\nframe->device_id = device_id;\r\nframe->cmd_flag = CMD_FLAG_NON_DATA;\r\nframe->data_transfer_length = 0;\r\nframe->cdb_length = MAX_COMMAND_SIZE;\r\nmemset(frame->cdb, 0, MAX_COMMAND_SIZE);\r\nframe->cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;\r\nframe->cdb[1] = CDB_CORE_MODULE;\r\nframe->cdb[2] = CDB_CORE_SHUTDOWN;\r\nmvumi_issue_blocked_cmd(mhba, cmd);\r\nif (cmd->cmd_status != SAM_STAT_GOOD) {\r\ndev_err(&mhba->pdev->dev,\r\n"device %d flush cache failed, status=0x%x.\n",\r\ndevice_id, cmd->cmd_status);\r\n}\r\nmvumi_delete_internal_cmd(mhba, cmd);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned char\r\nmvumi_calculate_checksum(struct mvumi_hs_header *p_header,\r\nunsigned short len)\r\n{\r\nunsigned char *ptr;\r\nunsigned char ret = 0, i;\r\nptr = (unsigned char *) p_header->frame_content;\r\nfor (i = 0; i < len; i++) {\r\nret ^= *ptr;\r\nptr++;\r\n}\r\nreturn ret;\r\n}\r\nstatic void mvumi_hs_build_page(struct mvumi_hba *mhba,\r\nstruct mvumi_hs_header *hs_header)\r\n{\r\nstruct mvumi_hs_page2 *hs_page2;\r\nstruct mvumi_hs_page4 *hs_page4;\r\nstruct mvumi_hs_page3 *hs_page3;\r\nstruct timeval time;\r\nunsigned int local_time;\r\nswitch (hs_header->page_code) {\r\ncase HS_PAGE_HOST_INFO:\r\nhs_page2 = (struct mvumi_hs_page2 *) hs_header;\r\nhs_header->frame_length = sizeof(*hs_page2) - 4;\r\nmemset(hs_header->frame_content, 0, hs_header->frame_length);\r\nhs_page2->host_type = 3;\r\nif (mhba->hba_capability & HS_CAPABILITY_SUPPORT_DYN_SRC)\r\nhs_page2->host_cap = 0x08;\r\nhs_page2->host_ver.ver_major = VER_MAJOR;\r\nhs_page2->host_ver.ver_minor = VER_MINOR;\r\nhs_page2->host_ver.ver_oem = VER_OEM;\r\nhs_page2->host_ver.ver_build = VER_BUILD;\r\nhs_page2->system_io_bus = 0;\r\nhs_page2->slot_number = 0;\r\nhs_page2->intr_level = 0;\r\nhs_page2->intr_vector = 0;\r\ndo_gettimeofday(&time);\r\nlocal_time = (unsigned int) (time.tv_sec -\r\n(sys_tz.tz_minuteswest * 60));\r\nhs_page2->seconds_since1970 = local_time;\r\nhs_header->checksum = mvumi_calculate_checksum(hs_header,\r\nhs_header->frame_length);\r\nbreak;\r\ncase HS_PAGE_FIRM_CTL:\r\nhs_page3 = (struct mvumi_hs_page3 *) hs_header;\r\nhs_header->frame_length = sizeof(*hs_page3) - 4;\r\nmemset(hs_header->frame_content, 0, hs_header->frame_length);\r\nhs_header->checksum = mvumi_calculate_checksum(hs_header,\r\nhs_header->frame_length);\r\nbreak;\r\ncase HS_PAGE_CL_INFO:\r\nhs_page4 = (struct mvumi_hs_page4 *) hs_header;\r\nhs_header->frame_length = sizeof(*hs_page4) - 4;\r\nmemset(hs_header->frame_content, 0, hs_header->frame_length);\r\nhs_page4->ib_baseaddr_l = lower_32_bits(mhba->ib_list_phys);\r\nhs_page4->ib_baseaddr_h = upper_32_bits(mhba->ib_list_phys);\r\nhs_page4->ob_baseaddr_l = lower_32_bits(mhba->ob_list_phys);\r\nhs_page4->ob_baseaddr_h = upper_32_bits(mhba->ob_list_phys);\r\nhs_page4->ib_entry_size = mhba->ib_max_size_setting;\r\nhs_page4->ob_entry_size = mhba->ob_max_size_setting;\r\nif (mhba->hba_capability\r\n& HS_CAPABILITY_NEW_PAGE_IO_DEPTH_DEF) {\r\nhs_page4->ob_depth = find_first_bit((unsigned long *)\r\n&mhba->list_num_io,\r\nBITS_PER_LONG);\r\nhs_page4->ib_depth = find_first_bit((unsigned long *)\r\n&mhba->list_num_io,\r\nBITS_PER_LONG);\r\n} else {\r\nhs_page4->ob_depth = (u8) mhba->list_num_io;\r\nhs_page4->ib_depth = (u8) mhba->list_num_io;\r\n}\r\nhs_header->checksum = mvumi_calculate_checksum(hs_header,\r\nhs_header->frame_length);\r\nbreak;\r\ndefault:\r\ndev_err(&mhba->pdev->dev, "cannot build page, code[0x%x]\n",\r\nhs_header->page_code);\r\nbreak;\r\n}\r\n}\r\nstatic int mvumi_init_data(struct mvumi_hba *mhba)\r\n{\r\nstruct mvumi_ob_data *ob_pool;\r\nstruct mvumi_res *res_mgnt;\r\nunsigned int tmp_size, offset, i;\r\nvoid *virmem, *v;\r\ndma_addr_t p;\r\nif (mhba->fw_flag & MVUMI_FW_ALLOC)\r\nreturn 0;\r\ntmp_size = mhba->ib_max_size * mhba->max_io;\r\nif (mhba->hba_capability & HS_CAPABILITY_SUPPORT_DYN_SRC)\r\ntmp_size += sizeof(struct mvumi_dyn_list_entry) * mhba->max_io;\r\ntmp_size += 128 + mhba->ob_max_size * mhba->max_io;\r\ntmp_size += 8 + sizeof(u32)*2 + 16;\r\nres_mgnt = mvumi_alloc_mem_resource(mhba,\r\nRESOURCE_UNCACHED_MEMORY, tmp_size);\r\nif (!res_mgnt) {\r\ndev_err(&mhba->pdev->dev,\r\n"failed to allocate memory for inbound list\n");\r\ngoto fail_alloc_dma_buf;\r\n}\r\np = res_mgnt->bus_addr;\r\nv = res_mgnt->virt_addr;\r\noffset = round_up(p, 128) - p;\r\np += offset;\r\nv += offset;\r\nmhba->ib_list = v;\r\nmhba->ib_list_phys = p;\r\nif (mhba->hba_capability & HS_CAPABILITY_SUPPORT_DYN_SRC) {\r\nv += sizeof(struct mvumi_dyn_list_entry) * mhba->max_io;\r\np += sizeof(struct mvumi_dyn_list_entry) * mhba->max_io;\r\nmhba->ib_frame = v;\r\nmhba->ib_frame_phys = p;\r\n}\r\nv += mhba->ib_max_size * mhba->max_io;\r\np += mhba->ib_max_size * mhba->max_io;\r\noffset = round_up(p, 8) - p;\r\np += offset;\r\nv += offset;\r\nmhba->ib_shadow = v;\r\nmhba->ib_shadow_phys = p;\r\np += sizeof(u32)*2;\r\nv += sizeof(u32)*2;\r\nif (mhba->pdev->device == PCI_DEVICE_ID_MARVELL_MV9580) {\r\noffset = round_up(p, 8) - p;\r\np += offset;\r\nv += offset;\r\nmhba->ob_shadow = v;\r\nmhba->ob_shadow_phys = p;\r\np += 8;\r\nv += 8;\r\n} else {\r\noffset = round_up(p, 4) - p;\r\np += offset;\r\nv += offset;\r\nmhba->ob_shadow = v;\r\nmhba->ob_shadow_phys = p;\r\np += 4;\r\nv += 4;\r\n}\r\noffset = round_up(p, 128) - p;\r\np += offset;\r\nv += offset;\r\nmhba->ob_list = v;\r\nmhba->ob_list_phys = p;\r\ntmp_size = mhba->max_io * (mhba->ob_max_size + sizeof(*ob_pool));\r\ntmp_size = round_up(tmp_size, 8);\r\nres_mgnt = mvumi_alloc_mem_resource(mhba,\r\nRESOURCE_CACHED_MEMORY, tmp_size);\r\nif (!res_mgnt) {\r\ndev_err(&mhba->pdev->dev,\r\n"failed to allocate memory for outbound data buffer\n");\r\ngoto fail_alloc_dma_buf;\r\n}\r\nvirmem = res_mgnt->virt_addr;\r\nfor (i = mhba->max_io; i != 0; i--) {\r\nob_pool = (struct mvumi_ob_data *) virmem;\r\nlist_add_tail(&ob_pool->list, &mhba->ob_data_list);\r\nvirmem += mhba->ob_max_size + sizeof(*ob_pool);\r\n}\r\ntmp_size = sizeof(unsigned short) * mhba->max_io +\r\nsizeof(struct mvumi_cmd *) * mhba->max_io;\r\ntmp_size += round_up(mhba->max_target_id, sizeof(unsigned char) * 8) /\r\n(sizeof(unsigned char) * 8);\r\nres_mgnt = mvumi_alloc_mem_resource(mhba,\r\nRESOURCE_CACHED_MEMORY, tmp_size);\r\nif (!res_mgnt) {\r\ndev_err(&mhba->pdev->dev,\r\n"failed to allocate memory for tag and target map\n");\r\ngoto fail_alloc_dma_buf;\r\n}\r\nvirmem = res_mgnt->virt_addr;\r\nmhba->tag_pool.stack = virmem;\r\nmhba->tag_pool.size = mhba->max_io;\r\ntag_init(&mhba->tag_pool, mhba->max_io);\r\nvirmem += sizeof(unsigned short) * mhba->max_io;\r\nmhba->tag_cmd = virmem;\r\nvirmem += sizeof(struct mvumi_cmd *) * mhba->max_io;\r\nmhba->target_map = virmem;\r\nmhba->fw_flag |= MVUMI_FW_ALLOC;\r\nreturn 0;\r\nfail_alloc_dma_buf:\r\nmvumi_release_mem_resource(mhba);\r\nreturn -1;\r\n}\r\nstatic int mvumi_hs_process_page(struct mvumi_hba *mhba,\r\nstruct mvumi_hs_header *hs_header)\r\n{\r\nstruct mvumi_hs_page1 *hs_page1;\r\nunsigned char page_checksum;\r\npage_checksum = mvumi_calculate_checksum(hs_header,\r\nhs_header->frame_length);\r\nif (page_checksum != hs_header->checksum) {\r\ndev_err(&mhba->pdev->dev, "checksum error\n");\r\nreturn -1;\r\n}\r\nswitch (hs_header->page_code) {\r\ncase HS_PAGE_FIRM_CAP:\r\nhs_page1 = (struct mvumi_hs_page1 *) hs_header;\r\nmhba->max_io = hs_page1->max_io_support;\r\nmhba->list_num_io = hs_page1->cl_inout_list_depth;\r\nmhba->max_transfer_size = hs_page1->max_transfer_size;\r\nmhba->max_target_id = hs_page1->max_devices_support;\r\nmhba->hba_capability = hs_page1->capability;\r\nmhba->ib_max_size_setting = hs_page1->cl_in_max_entry_size;\r\nmhba->ib_max_size = (1 << hs_page1->cl_in_max_entry_size) << 2;\r\nmhba->ob_max_size_setting = hs_page1->cl_out_max_entry_size;\r\nmhba->ob_max_size = (1 << hs_page1->cl_out_max_entry_size) << 2;\r\ndev_dbg(&mhba->pdev->dev, "FW version:%d\n",\r\nhs_page1->fw_ver.ver_build);\r\nif (mhba->hba_capability & HS_CAPABILITY_SUPPORT_COMPACT_SG)\r\nmhba->eot_flag = 22;\r\nelse\r\nmhba->eot_flag = 27;\r\nif (mhba->hba_capability & HS_CAPABILITY_NEW_PAGE_IO_DEPTH_DEF)\r\nmhba->list_num_io = 1 << hs_page1->cl_inout_list_depth;\r\nbreak;\r\ndefault:\r\ndev_err(&mhba->pdev->dev, "handshake: page code error\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mvumi_handshake(struct mvumi_hba *mhba)\r\n{\r\nunsigned int hs_state, tmp, hs_fun;\r\nstruct mvumi_hs_header *hs_header;\r\nstruct mvumi_hw_regs *regs = mhba->regs;\r\nif (mhba->fw_state == FW_STATE_STARTING)\r\nhs_state = HS_S_START;\r\nelse {\r\ntmp = ioread32(regs->arm_to_pciea_msg0);\r\nhs_state = HS_GET_STATE(tmp);\r\ndev_dbg(&mhba->pdev->dev, "handshake state[0x%x].\n", hs_state);\r\nif (HS_GET_STATUS(tmp) != HS_STATUS_OK) {\r\nmhba->fw_state = FW_STATE_STARTING;\r\nreturn -1;\r\n}\r\n}\r\nhs_fun = 0;\r\nswitch (hs_state) {\r\ncase HS_S_START:\r\nmhba->fw_state = FW_STATE_HANDSHAKING;\r\nHS_SET_STATUS(hs_fun, HS_STATUS_OK);\r\nHS_SET_STATE(hs_fun, HS_S_RESET);\r\niowrite32(HANDSHAKE_SIGNATURE, regs->pciea_to_arm_msg1);\r\niowrite32(hs_fun, regs->pciea_to_arm_msg0);\r\niowrite32(DRBL_HANDSHAKE, regs->pciea_to_arm_drbl_reg);\r\nbreak;\r\ncase HS_S_RESET:\r\niowrite32(lower_32_bits(mhba->handshake_page_phys),\r\nregs->pciea_to_arm_msg1);\r\niowrite32(upper_32_bits(mhba->handshake_page_phys),\r\nregs->arm_to_pciea_msg1);\r\nHS_SET_STATUS(hs_fun, HS_STATUS_OK);\r\nHS_SET_STATE(hs_fun, HS_S_PAGE_ADDR);\r\niowrite32(hs_fun, regs->pciea_to_arm_msg0);\r\niowrite32(DRBL_HANDSHAKE, regs->pciea_to_arm_drbl_reg);\r\nbreak;\r\ncase HS_S_PAGE_ADDR:\r\ncase HS_S_QUERY_PAGE:\r\ncase HS_S_SEND_PAGE:\r\nhs_header = (struct mvumi_hs_header *) mhba->handshake_page;\r\nif (hs_header->page_code == HS_PAGE_FIRM_CAP) {\r\nmhba->hba_total_pages =\r\n((struct mvumi_hs_page1 *) hs_header)->total_pages;\r\nif (mhba->hba_total_pages == 0)\r\nmhba->hba_total_pages = HS_PAGE_TOTAL-1;\r\n}\r\nif (hs_state == HS_S_QUERY_PAGE) {\r\nif (mvumi_hs_process_page(mhba, hs_header)) {\r\nHS_SET_STATE(hs_fun, HS_S_ABORT);\r\nreturn -1;\r\n}\r\nif (mvumi_init_data(mhba)) {\r\nHS_SET_STATE(hs_fun, HS_S_ABORT);\r\nreturn -1;\r\n}\r\n} else if (hs_state == HS_S_PAGE_ADDR) {\r\nhs_header->page_code = 0;\r\nmhba->hba_total_pages = HS_PAGE_TOTAL-1;\r\n}\r\nif ((hs_header->page_code + 1) <= mhba->hba_total_pages) {\r\nhs_header->page_code++;\r\nif (hs_header->page_code != HS_PAGE_FIRM_CAP) {\r\nmvumi_hs_build_page(mhba, hs_header);\r\nHS_SET_STATE(hs_fun, HS_S_SEND_PAGE);\r\n} else\r\nHS_SET_STATE(hs_fun, HS_S_QUERY_PAGE);\r\n} else\r\nHS_SET_STATE(hs_fun, HS_S_END);\r\nHS_SET_STATUS(hs_fun, HS_STATUS_OK);\r\niowrite32(hs_fun, regs->pciea_to_arm_msg0);\r\niowrite32(DRBL_HANDSHAKE, regs->pciea_to_arm_drbl_reg);\r\nbreak;\r\ncase HS_S_END:\r\ntmp = ioread32(regs->enpointa_mask_reg);\r\ntmp |= regs->int_comaout | regs->int_comaerr;\r\niowrite32(tmp, regs->enpointa_mask_reg);\r\niowrite32(mhba->list_num_io, mhba->ib_shadow);\r\niowrite32(lower_32_bits(mhba->ib_shadow_phys),\r\nregs->inb_aval_count_basel);\r\niowrite32(upper_32_bits(mhba->ib_shadow_phys),\r\nregs->inb_aval_count_baseh);\r\nif (mhba->pdev->device == PCI_DEVICE_ID_MARVELL_MV9143) {\r\niowrite32((mhba->list_num_io-1) |\r\nregs->cl_pointer_toggle,\r\nmhba->ob_shadow);\r\niowrite32(lower_32_bits(mhba->ob_shadow_phys),\r\nregs->outb_copy_basel);\r\niowrite32(upper_32_bits(mhba->ob_shadow_phys),\r\nregs->outb_copy_baseh);\r\n}\r\nmhba->ib_cur_slot = (mhba->list_num_io - 1) |\r\nregs->cl_pointer_toggle;\r\nmhba->ob_cur_slot = (mhba->list_num_io - 1) |\r\nregs->cl_pointer_toggle;\r\nmhba->fw_state = FW_STATE_STARTED;\r\nbreak;\r\ndefault:\r\ndev_err(&mhba->pdev->dev, "unknown handshake state [0x%x].\n",\r\nhs_state);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned char mvumi_handshake_event(struct mvumi_hba *mhba)\r\n{\r\nunsigned int isr_status;\r\nunsigned long before;\r\nbefore = jiffies;\r\nmvumi_handshake(mhba);\r\ndo {\r\nisr_status = mhba->instancet->read_fw_status_reg(mhba);\r\nif (mhba->fw_state == FW_STATE_STARTED)\r\nreturn 0;\r\nif (time_after(jiffies, before + FW_MAX_DELAY * HZ)) {\r\ndev_err(&mhba->pdev->dev,\r\n"no handshake response at state 0x%x.\n",\r\nmhba->fw_state);\r\ndev_err(&mhba->pdev->dev,\r\n"isr : global=0x%x,status=0x%x.\n",\r\nmhba->global_isr, isr_status);\r\nreturn -1;\r\n}\r\nrmb();\r\nusleep_range(1000, 2000);\r\n} while (!(isr_status & DRBL_HANDSHAKE_ISR));\r\nreturn 0;\r\n}\r\nstatic unsigned char mvumi_check_handshake(struct mvumi_hba *mhba)\r\n{\r\nunsigned int tmp;\r\nunsigned long before;\r\nbefore = jiffies;\r\ntmp = ioread32(mhba->regs->arm_to_pciea_msg1);\r\nwhile ((tmp != HANDSHAKE_READYSTATE) && (tmp != HANDSHAKE_DONESTATE)) {\r\nif (tmp != HANDSHAKE_READYSTATE)\r\niowrite32(DRBL_MU_RESET,\r\nmhba->regs->pciea_to_arm_drbl_reg);\r\nif (time_after(jiffies, before + FW_MAX_DELAY * HZ)) {\r\ndev_err(&mhba->pdev->dev,\r\n"invalid signature [0x%x].\n", tmp);\r\nreturn -1;\r\n}\r\nusleep_range(1000, 2000);\r\nrmb();\r\ntmp = ioread32(mhba->regs->arm_to_pciea_msg1);\r\n}\r\nmhba->fw_state = FW_STATE_STARTING;\r\ndev_dbg(&mhba->pdev->dev, "start firmware handshake...\n");\r\ndo {\r\nif (mvumi_handshake_event(mhba)) {\r\ndev_err(&mhba->pdev->dev,\r\n"handshake failed at state 0x%x.\n",\r\nmhba->fw_state);\r\nreturn -1;\r\n}\r\n} while (mhba->fw_state != FW_STATE_STARTED);\r\ndev_dbg(&mhba->pdev->dev, "firmware handshake done\n");\r\nreturn 0;\r\n}\r\nstatic unsigned char mvumi_start(struct mvumi_hba *mhba)\r\n{\r\nunsigned int tmp;\r\nstruct mvumi_hw_regs *regs = mhba->regs;\r\ntmp = ioread32(regs->arm_to_pciea_drbl_reg);\r\niowrite32(tmp, regs->arm_to_pciea_drbl_reg);\r\niowrite32(regs->int_drbl_int_mask, regs->arm_to_pciea_mask_reg);\r\ntmp = ioread32(regs->enpointa_mask_reg) | regs->int_dl_cpu2pciea;\r\niowrite32(tmp, regs->enpointa_mask_reg);\r\nmsleep(100);\r\nif (mvumi_check_handshake(mhba))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void mvumi_complete_cmd(struct mvumi_hba *mhba, struct mvumi_cmd *cmd,\r\nstruct mvumi_rsp_frame *ob_frame)\r\n{\r\nstruct scsi_cmnd *scmd = cmd->scmd;\r\ncmd->scmd->SCp.ptr = NULL;\r\nscmd->result = ob_frame->req_status;\r\nswitch (ob_frame->req_status) {\r\ncase SAM_STAT_GOOD:\r\nscmd->result |= DID_OK << 16;\r\nbreak;\r\ncase SAM_STAT_BUSY:\r\nscmd->result |= DID_BUS_BUSY << 16;\r\nbreak;\r\ncase SAM_STAT_CHECK_CONDITION:\r\nscmd->result |= (DID_OK << 16);\r\nif (ob_frame->rsp_flag & CL_RSP_FLAG_SENSEDATA) {\r\nmemcpy(cmd->scmd->sense_buffer, ob_frame->payload,\r\nsizeof(struct mvumi_sense_data));\r\nscmd->result |= (DRIVER_SENSE << 24);\r\n}\r\nbreak;\r\ndefault:\r\nscmd->result |= (DRIVER_INVALID << 24) | (DID_ABORT << 16);\r\nbreak;\r\n}\r\nif (scsi_bufflen(scmd)) {\r\nif (scsi_sg_count(scmd)) {\r\npci_unmap_sg(mhba->pdev,\r\nscsi_sglist(scmd),\r\nscsi_sg_count(scmd),\r\n(int) scmd->sc_data_direction);\r\n} else {\r\npci_unmap_single(mhba->pdev,\r\nscmd->SCp.dma_handle,\r\nscsi_bufflen(scmd),\r\n(int) scmd->sc_data_direction);\r\nscmd->SCp.dma_handle = 0;\r\n}\r\n}\r\ncmd->scmd->scsi_done(scmd);\r\nmvumi_return_cmd(mhba, cmd);\r\n}\r\nstatic void mvumi_complete_internal_cmd(struct mvumi_hba *mhba,\r\nstruct mvumi_cmd *cmd,\r\nstruct mvumi_rsp_frame *ob_frame)\r\n{\r\nif (atomic_read(&cmd->sync_cmd)) {\r\ncmd->cmd_status = ob_frame->req_status;\r\nif ((ob_frame->req_status == SAM_STAT_CHECK_CONDITION) &&\r\n(ob_frame->rsp_flag & CL_RSP_FLAG_SENSEDATA) &&\r\ncmd->data_buf) {\r\nmemcpy(cmd->data_buf, ob_frame->payload,\r\nsizeof(struct mvumi_sense_data));\r\n}\r\natomic_dec(&cmd->sync_cmd);\r\nwake_up(&mhba->int_cmd_wait_q);\r\n}\r\n}\r\nstatic void mvumi_show_event(struct mvumi_hba *mhba,\r\nstruct mvumi_driver_event *ptr)\r\n{\r\nunsigned int i;\r\ndev_warn(&mhba->pdev->dev,\r\n"Event[0x%x] id[0x%x] severity[0x%x] device id[0x%x]\n",\r\nptr->sequence_no, ptr->event_id, ptr->severity, ptr->device_id);\r\nif (ptr->param_count) {\r\nprintk(KERN_WARNING "Event param(len 0x%x): ",\r\nptr->param_count);\r\nfor (i = 0; i < ptr->param_count; i++)\r\nprintk(KERN_WARNING "0x%x ", ptr->params[i]);\r\nprintk(KERN_WARNING "\n");\r\n}\r\nif (ptr->sense_data_length) {\r\nprintk(KERN_WARNING "Event sense data(len 0x%x): ",\r\nptr->sense_data_length);\r\nfor (i = 0; i < ptr->sense_data_length; i++)\r\nprintk(KERN_WARNING "0x%x ", ptr->sense_data[i]);\r\nprintk(KERN_WARNING "\n");\r\n}\r\n}\r\nstatic int mvumi_handle_hotplug(struct mvumi_hba *mhba, u16 devid, int status)\r\n{\r\nstruct scsi_device *sdev;\r\nint ret = -1;\r\nif (status == DEVICE_OFFLINE) {\r\nsdev = scsi_device_lookup(mhba->shost, 0, devid, 0);\r\nif (sdev) {\r\ndev_dbg(&mhba->pdev->dev, "remove disk %d-%d-%d.\n", 0,\r\nsdev->id, 0);\r\nscsi_remove_device(sdev);\r\nscsi_device_put(sdev);\r\nret = 0;\r\n} else\r\ndev_err(&mhba->pdev->dev, " no disk[%d] to remove\n",\r\ndevid);\r\n} else if (status == DEVICE_ONLINE) {\r\nsdev = scsi_device_lookup(mhba->shost, 0, devid, 0);\r\nif (!sdev) {\r\nscsi_add_device(mhba->shost, 0, devid, 0);\r\ndev_dbg(&mhba->pdev->dev, " add disk %d-%d-%d.\n", 0,\r\ndevid, 0);\r\nret = 0;\r\n} else {\r\ndev_err(&mhba->pdev->dev, " don't add disk %d-%d-%d.\n",\r\n0, devid, 0);\r\nscsi_device_put(sdev);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic u64 mvumi_inquiry(struct mvumi_hba *mhba,\r\nunsigned int id, struct mvumi_cmd *cmd)\r\n{\r\nstruct mvumi_msg_frame *frame;\r\nu64 wwid = 0;\r\nint cmd_alloc = 0;\r\nint data_buf_len = 64;\r\nif (!cmd) {\r\ncmd = mvumi_create_internal_cmd(mhba, data_buf_len);\r\nif (cmd)\r\ncmd_alloc = 1;\r\nelse\r\nreturn 0;\r\n} else {\r\nmemset(cmd->data_buf, 0, data_buf_len);\r\n}\r\ncmd->scmd = NULL;\r\ncmd->cmd_status = REQ_STATUS_PENDING;\r\natomic_set(&cmd->sync_cmd, 0);\r\nframe = cmd->frame;\r\nframe->device_id = (u16) id;\r\nframe->cmd_flag = CMD_FLAG_DATA_IN;\r\nframe->req_function = CL_FUN_SCSI_CMD;\r\nframe->cdb_length = 6;\r\nframe->data_transfer_length = MVUMI_INQUIRY_LENGTH;\r\nmemset(frame->cdb, 0, frame->cdb_length);\r\nframe->cdb[0] = INQUIRY;\r\nframe->cdb[4] = frame->data_transfer_length;\r\nmvumi_issue_blocked_cmd(mhba, cmd);\r\nif (cmd->cmd_status == SAM_STAT_GOOD) {\r\nif (mhba->pdev->device == PCI_DEVICE_ID_MARVELL_MV9143)\r\nwwid = id + 1;\r\nelse\r\nmemcpy((void *)&wwid,\r\n(cmd->data_buf + MVUMI_INQUIRY_UUID_OFF),\r\nMVUMI_INQUIRY_UUID_LEN);\r\ndev_dbg(&mhba->pdev->dev,\r\n"inquiry device(0:%d:0) wwid(%llx)\n", id, wwid);\r\n} else {\r\nwwid = 0;\r\n}\r\nif (cmd_alloc)\r\nmvumi_delete_internal_cmd(mhba, cmd);\r\nreturn wwid;\r\n}\r\nstatic void mvumi_detach_devices(struct mvumi_hba *mhba)\r\n{\r\nstruct mvumi_device *mv_dev = NULL , *dev_next;\r\nstruct scsi_device *sdev = NULL;\r\nmutex_lock(&mhba->device_lock);\r\nlist_for_each_entry_safe(mv_dev, dev_next,\r\n&mhba->shost_dev_list, list) {\r\nmvumi_handle_hotplug(mhba, mv_dev->id, DEVICE_OFFLINE);\r\nlist_del_init(&mv_dev->list);\r\ndev_dbg(&mhba->pdev->dev, "release device(0:%d:0) wwid(%llx)\n",\r\nmv_dev->id, mv_dev->wwid);\r\nkfree(mv_dev);\r\n}\r\nlist_for_each_entry_safe(mv_dev, dev_next, &mhba->mhba_dev_list, list) {\r\nlist_del_init(&mv_dev->list);\r\ndev_dbg(&mhba->pdev->dev, "release device(0:%d:0) wwid(%llx)\n",\r\nmv_dev->id, mv_dev->wwid);\r\nkfree(mv_dev);\r\n}\r\nif (mhba->pdev->device == PCI_DEVICE_ID_MARVELL_MV9580)\r\nsdev = scsi_device_lookup(mhba->shost, 0,\r\nmhba->max_target_id - 1, 0);\r\nif (sdev) {\r\nscsi_remove_device(sdev);\r\nscsi_device_put(sdev);\r\n}\r\nmutex_unlock(&mhba->device_lock);\r\n}\r\nstatic void mvumi_rescan_devices(struct mvumi_hba *mhba, int id)\r\n{\r\nstruct scsi_device *sdev;\r\nsdev = scsi_device_lookup(mhba->shost, 0, id, 0);\r\nif (sdev) {\r\nscsi_rescan_device(&sdev->sdev_gendev);\r\nscsi_device_put(sdev);\r\n}\r\n}\r\nstatic int mvumi_match_devices(struct mvumi_hba *mhba, int id, u64 wwid)\r\n{\r\nstruct mvumi_device *mv_dev = NULL;\r\nlist_for_each_entry(mv_dev, &mhba->shost_dev_list, list) {\r\nif (mv_dev->wwid == wwid) {\r\nif (mv_dev->id != id) {\r\ndev_err(&mhba->pdev->dev,\r\n"%s has same wwid[%llx] ,"\r\n" but different id[%d %d]\n",\r\n__func__, mv_dev->wwid, mv_dev->id, id);\r\nreturn -1;\r\n} else {\r\nif (mhba->pdev->device ==\r\nPCI_DEVICE_ID_MARVELL_MV9143)\r\nmvumi_rescan_devices(mhba, id);\r\nreturn 1;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void mvumi_remove_devices(struct mvumi_hba *mhba, int id)\r\n{\r\nstruct mvumi_device *mv_dev = NULL, *dev_next;\r\nlist_for_each_entry_safe(mv_dev, dev_next,\r\n&mhba->shost_dev_list, list) {\r\nif (mv_dev->id == id) {\r\ndev_dbg(&mhba->pdev->dev,\r\n"detach device(0:%d:0) wwid(%llx) from HOST\n",\r\nmv_dev->id, mv_dev->wwid);\r\nmvumi_handle_hotplug(mhba, mv_dev->id, DEVICE_OFFLINE);\r\nlist_del_init(&mv_dev->list);\r\nkfree(mv_dev);\r\n}\r\n}\r\n}\r\nstatic int mvumi_probe_devices(struct mvumi_hba *mhba)\r\n{\r\nint id, maxid;\r\nu64 wwid = 0;\r\nstruct mvumi_device *mv_dev = NULL;\r\nstruct mvumi_cmd *cmd = NULL;\r\nint found = 0;\r\ncmd = mvumi_create_internal_cmd(mhba, 64);\r\nif (!cmd)\r\nreturn -1;\r\nif (mhba->pdev->device == PCI_DEVICE_ID_MARVELL_MV9143)\r\nmaxid = mhba->max_target_id;\r\nelse\r\nmaxid = mhba->max_target_id - 1;\r\nfor (id = 0; id < maxid; id++) {\r\nwwid = mvumi_inquiry(mhba, id, cmd);\r\nif (!wwid) {\r\nmvumi_remove_devices(mhba, id);\r\n} else {\r\nfound = mvumi_match_devices(mhba, id, wwid);\r\nif (!found) {\r\nmvumi_remove_devices(mhba, id);\r\nmv_dev = kzalloc(sizeof(struct mvumi_device),\r\nGFP_KERNEL);\r\nif (!mv_dev) {\r\ndev_err(&mhba->pdev->dev,\r\n"%s alloc mv_dev failed\n",\r\n__func__);\r\ncontinue;\r\n}\r\nmv_dev->id = id;\r\nmv_dev->wwid = wwid;\r\nmv_dev->sdev = NULL;\r\nINIT_LIST_HEAD(&mv_dev->list);\r\nlist_add_tail(&mv_dev->list,\r\n&mhba->mhba_dev_list);\r\ndev_dbg(&mhba->pdev->dev,\r\n"probe a new device(0:%d:0)"\r\n" wwid(%llx)\n", id, mv_dev->wwid);\r\n} else if (found == -1)\r\nreturn -1;\r\nelse\r\ncontinue;\r\n}\r\n}\r\nif (cmd)\r\nmvumi_delete_internal_cmd(mhba, cmd);\r\nreturn 0;\r\n}\r\nstatic int mvumi_rescan_bus(void *data)\r\n{\r\nint ret = 0;\r\nstruct mvumi_hba *mhba = (struct mvumi_hba *) data;\r\nstruct mvumi_device *mv_dev = NULL , *dev_next;\r\nwhile (!kthread_should_stop()) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (!atomic_read(&mhba->pnp_count))\r\nschedule();\r\nmsleep(1000);\r\natomic_set(&mhba->pnp_count, 0);\r\n__set_current_state(TASK_RUNNING);\r\nmutex_lock(&mhba->device_lock);\r\nret = mvumi_probe_devices(mhba);\r\nif (!ret) {\r\nlist_for_each_entry_safe(mv_dev, dev_next,\r\n&mhba->mhba_dev_list, list) {\r\nif (mvumi_handle_hotplug(mhba, mv_dev->id,\r\nDEVICE_ONLINE)) {\r\ndev_err(&mhba->pdev->dev,\r\n"%s add device(0:%d:0) failed"\r\n"wwid(%llx) has exist\n",\r\n__func__,\r\nmv_dev->id, mv_dev->wwid);\r\nlist_del_init(&mv_dev->list);\r\nkfree(mv_dev);\r\n} else {\r\nlist_move_tail(&mv_dev->list,\r\n&mhba->shost_dev_list);\r\n}\r\n}\r\n}\r\nmutex_unlock(&mhba->device_lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mvumi_proc_msg(struct mvumi_hba *mhba,\r\nstruct mvumi_hotplug_event *param)\r\n{\r\nu16 size = param->size;\r\nconst unsigned long *ar_bitmap;\r\nconst unsigned long *re_bitmap;\r\nint index;\r\nif (mhba->fw_flag & MVUMI_FW_ATTACH) {\r\nindex = -1;\r\nar_bitmap = (const unsigned long *) param->bitmap;\r\nre_bitmap = (const unsigned long *) &param->bitmap[size >> 3];\r\nmutex_lock(&mhba->sas_discovery_mutex);\r\ndo {\r\nindex = find_next_zero_bit(ar_bitmap, size, index + 1);\r\nif (index >= size)\r\nbreak;\r\nmvumi_handle_hotplug(mhba, index, DEVICE_ONLINE);\r\n} while (1);\r\nindex = -1;\r\ndo {\r\nindex = find_next_zero_bit(re_bitmap, size, index + 1);\r\nif (index >= size)\r\nbreak;\r\nmvumi_handle_hotplug(mhba, index, DEVICE_OFFLINE);\r\n} while (1);\r\nmutex_unlock(&mhba->sas_discovery_mutex);\r\n}\r\n}\r\nstatic void mvumi_notification(struct mvumi_hba *mhba, u8 msg, void *buffer)\r\n{\r\nif (msg == APICDB1_EVENT_GETEVENT) {\r\nint i, count;\r\nstruct mvumi_driver_event *param = NULL;\r\nstruct mvumi_event_req *er = buffer;\r\ncount = er->count;\r\nif (count > MAX_EVENTS_RETURNED) {\r\ndev_err(&mhba->pdev->dev, "event count[0x%x] is bigger"\r\n" than max event count[0x%x].\n",\r\ncount, MAX_EVENTS_RETURNED);\r\nreturn;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nparam = &er->events[i];\r\nmvumi_show_event(mhba, param);\r\n}\r\n} else if (msg == APICDB1_HOST_GETEVENT) {\r\nmvumi_proc_msg(mhba, buffer);\r\n}\r\n}\r\nstatic int mvumi_get_event(struct mvumi_hba *mhba, unsigned char msg)\r\n{\r\nstruct mvumi_cmd *cmd;\r\nstruct mvumi_msg_frame *frame;\r\ncmd = mvumi_create_internal_cmd(mhba, 512);\r\nif (!cmd)\r\nreturn -1;\r\ncmd->scmd = NULL;\r\ncmd->cmd_status = REQ_STATUS_PENDING;\r\natomic_set(&cmd->sync_cmd, 0);\r\nframe = cmd->frame;\r\nframe->device_id = 0;\r\nframe->cmd_flag = CMD_FLAG_DATA_IN;\r\nframe->req_function = CL_FUN_SCSI_CMD;\r\nframe->cdb_length = MAX_COMMAND_SIZE;\r\nframe->data_transfer_length = sizeof(struct mvumi_event_req);\r\nmemset(frame->cdb, 0, MAX_COMMAND_SIZE);\r\nframe->cdb[0] = APICDB0_EVENT;\r\nframe->cdb[1] = msg;\r\nmvumi_issue_blocked_cmd(mhba, cmd);\r\nif (cmd->cmd_status != SAM_STAT_GOOD)\r\ndev_err(&mhba->pdev->dev, "get event failed, status=0x%x.\n",\r\ncmd->cmd_status);\r\nelse\r\nmvumi_notification(mhba, cmd->frame->cdb[1], cmd->data_buf);\r\nmvumi_delete_internal_cmd(mhba, cmd);\r\nreturn 0;\r\n}\r\nstatic void mvumi_scan_events(struct work_struct *work)\r\n{\r\nstruct mvumi_events_wq *mu_ev =\r\ncontainer_of(work, struct mvumi_events_wq, work_q);\r\nmvumi_get_event(mu_ev->mhba, mu_ev->event);\r\nkfree(mu_ev);\r\n}\r\nstatic void mvumi_launch_events(struct mvumi_hba *mhba, u32 isr_status)\r\n{\r\nstruct mvumi_events_wq *mu_ev;\r\nwhile (isr_status & (DRBL_BUS_CHANGE | DRBL_EVENT_NOTIFY)) {\r\nif (isr_status & DRBL_BUS_CHANGE) {\r\natomic_inc(&mhba->pnp_count);\r\nwake_up_process(mhba->dm_thread);\r\nisr_status &= ~(DRBL_BUS_CHANGE);\r\ncontinue;\r\n}\r\nmu_ev = kzalloc(sizeof(*mu_ev), GFP_ATOMIC);\r\nif (mu_ev) {\r\nINIT_WORK(&mu_ev->work_q, mvumi_scan_events);\r\nmu_ev->mhba = mhba;\r\nmu_ev->event = APICDB1_EVENT_GETEVENT;\r\nisr_status &= ~(DRBL_EVENT_NOTIFY);\r\nmu_ev->param = NULL;\r\nschedule_work(&mu_ev->work_q);\r\n}\r\n}\r\n}\r\nstatic void mvumi_handle_clob(struct mvumi_hba *mhba)\r\n{\r\nstruct mvumi_rsp_frame *ob_frame;\r\nstruct mvumi_cmd *cmd;\r\nstruct mvumi_ob_data *pool;\r\nwhile (!list_empty(&mhba->free_ob_list)) {\r\npool = list_first_entry(&mhba->free_ob_list,\r\nstruct mvumi_ob_data, list);\r\nlist_del_init(&pool->list);\r\nlist_add_tail(&pool->list, &mhba->ob_data_list);\r\nob_frame = (struct mvumi_rsp_frame *) &pool->data[0];\r\ncmd = mhba->tag_cmd[ob_frame->tag];\r\natomic_dec(&mhba->fw_outstanding);\r\nmhba->tag_cmd[ob_frame->tag] = 0;\r\ntag_release_one(mhba, &mhba->tag_pool, ob_frame->tag);\r\nif (cmd->scmd)\r\nmvumi_complete_cmd(mhba, cmd, ob_frame);\r\nelse\r\nmvumi_complete_internal_cmd(mhba, cmd, ob_frame);\r\n}\r\nmhba->instancet->fire_cmd(mhba, NULL);\r\n}\r\nstatic irqreturn_t mvumi_isr_handler(int irq, void *devp)\r\n{\r\nstruct mvumi_hba *mhba = (struct mvumi_hba *) devp;\r\nunsigned long flags;\r\nspin_lock_irqsave(mhba->shost->host_lock, flags);\r\nif (unlikely(mhba->instancet->clear_intr(mhba) || !mhba->global_isr)) {\r\nspin_unlock_irqrestore(mhba->shost->host_lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nif (mhba->global_isr & mhba->regs->int_dl_cpu2pciea) {\r\nif (mhba->isr_status & (DRBL_BUS_CHANGE | DRBL_EVENT_NOTIFY))\r\nmvumi_launch_events(mhba, mhba->isr_status);\r\nif (mhba->isr_status & DRBL_HANDSHAKE_ISR) {\r\ndev_warn(&mhba->pdev->dev, "enter handshake again!\n");\r\nmvumi_handshake(mhba);\r\n}\r\n}\r\nif (mhba->global_isr & mhba->regs->int_comaout)\r\nmvumi_receive_ob_list_entry(mhba);\r\nmhba->global_isr = 0;\r\nmhba->isr_status = 0;\r\nif (mhba->fw_state == FW_STATE_STARTED)\r\nmvumi_handle_clob(mhba);\r\nspin_unlock_irqrestore(mhba->shost->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic enum mvumi_qc_result mvumi_send_command(struct mvumi_hba *mhba,\r\nstruct mvumi_cmd *cmd)\r\n{\r\nvoid *ib_entry;\r\nstruct mvumi_msg_frame *ib_frame;\r\nunsigned int frame_len;\r\nib_frame = cmd->frame;\r\nif (unlikely(mhba->fw_state != FW_STATE_STARTED)) {\r\ndev_dbg(&mhba->pdev->dev, "firmware not ready.\n");\r\nreturn MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;\r\n}\r\nif (tag_is_empty(&mhba->tag_pool)) {\r\ndev_dbg(&mhba->pdev->dev, "no free tag.\n");\r\nreturn MV_QUEUE_COMMAND_RESULT_NO_RESOURCE;\r\n}\r\nmvumi_get_ib_list_entry(mhba, &ib_entry);\r\ncmd->frame->tag = tag_get_one(mhba, &mhba->tag_pool);\r\ncmd->frame->request_id = mhba->io_seq++;\r\ncmd->request_id = cmd->frame->request_id;\r\nmhba->tag_cmd[cmd->frame->tag] = cmd;\r\nframe_len = sizeof(*ib_frame) - 4 +\r\nib_frame->sg_counts * sizeof(struct mvumi_sgl);\r\nif (mhba->hba_capability & HS_CAPABILITY_SUPPORT_DYN_SRC) {\r\nstruct mvumi_dyn_list_entry *dle;\r\ndle = ib_entry;\r\ndle->src_low_addr =\r\ncpu_to_le32(lower_32_bits(cmd->frame_phys));\r\ndle->src_high_addr =\r\ncpu_to_le32(upper_32_bits(cmd->frame_phys));\r\ndle->if_length = (frame_len >> 2) & 0xFFF;\r\n} else {\r\nmemcpy(ib_entry, ib_frame, frame_len);\r\n}\r\nreturn MV_QUEUE_COMMAND_RESULT_SENT;\r\n}\r\nstatic void mvumi_fire_cmd(struct mvumi_hba *mhba, struct mvumi_cmd *cmd)\r\n{\r\nunsigned short num_of_cl_sent = 0;\r\nunsigned int count;\r\nenum mvumi_qc_result result;\r\nif (cmd)\r\nlist_add_tail(&cmd->queue_pointer, &mhba->waiting_req_list);\r\ncount = mhba->instancet->check_ib_list(mhba);\r\nif (list_empty(&mhba->waiting_req_list) || !count)\r\nreturn;\r\ndo {\r\ncmd = list_first_entry(&mhba->waiting_req_list,\r\nstruct mvumi_cmd, queue_pointer);\r\nlist_del_init(&cmd->queue_pointer);\r\nresult = mvumi_send_command(mhba, cmd);\r\nswitch (result) {\r\ncase MV_QUEUE_COMMAND_RESULT_SENT:\r\nnum_of_cl_sent++;\r\nbreak;\r\ncase MV_QUEUE_COMMAND_RESULT_NO_RESOURCE:\r\nlist_add(&cmd->queue_pointer, &mhba->waiting_req_list);\r\nif (num_of_cl_sent > 0)\r\nmvumi_send_ib_list_entry(mhba);\r\nreturn;\r\n}\r\n} while (!list_empty(&mhba->waiting_req_list) && count--);\r\nif (num_of_cl_sent > 0)\r\nmvumi_send_ib_list_entry(mhba);\r\n}\r\nstatic void mvumi_enable_intr(struct mvumi_hba *mhba)\r\n{\r\nunsigned int mask;\r\nstruct mvumi_hw_regs *regs = mhba->regs;\r\niowrite32(regs->int_drbl_int_mask, regs->arm_to_pciea_mask_reg);\r\nmask = ioread32(regs->enpointa_mask_reg);\r\nmask |= regs->int_dl_cpu2pciea | regs->int_comaout | regs->int_comaerr;\r\niowrite32(mask, regs->enpointa_mask_reg);\r\n}\r\nstatic void mvumi_disable_intr(struct mvumi_hba *mhba)\r\n{\r\nunsigned int mask;\r\nstruct mvumi_hw_regs *regs = mhba->regs;\r\niowrite32(0, regs->arm_to_pciea_mask_reg);\r\nmask = ioread32(regs->enpointa_mask_reg);\r\nmask &= ~(regs->int_dl_cpu2pciea | regs->int_comaout |\r\nregs->int_comaerr);\r\niowrite32(mask, regs->enpointa_mask_reg);\r\n}\r\nstatic int mvumi_clear_intr(void *extend)\r\n{\r\nstruct mvumi_hba *mhba = (struct mvumi_hba *) extend;\r\nunsigned int status, isr_status = 0, tmp = 0;\r\nstruct mvumi_hw_regs *regs = mhba->regs;\r\nstatus = ioread32(regs->main_int_cause_reg);\r\nif (!(status & regs->int_mu) || status == 0xFFFFFFFF)\r\nreturn 1;\r\nif (unlikely(status & regs->int_comaerr)) {\r\ntmp = ioread32(regs->outb_isr_cause);\r\nif (mhba->pdev->device == PCI_DEVICE_ID_MARVELL_MV9580) {\r\nif (tmp & regs->clic_out_err) {\r\niowrite32(tmp & regs->clic_out_err,\r\nregs->outb_isr_cause);\r\n}\r\n} else {\r\nif (tmp & (regs->clic_in_err | regs->clic_out_err))\r\niowrite32(tmp & (regs->clic_in_err |\r\nregs->clic_out_err),\r\nregs->outb_isr_cause);\r\n}\r\nstatus ^= mhba->regs->int_comaerr;\r\n}\r\nif (status & regs->int_comaout) {\r\ntmp = ioread32(regs->outb_isr_cause);\r\nif (tmp & regs->clic_irq)\r\niowrite32(tmp & regs->clic_irq, regs->outb_isr_cause);\r\n}\r\nif (status & regs->int_dl_cpu2pciea) {\r\nisr_status = ioread32(regs->arm_to_pciea_drbl_reg);\r\nif (isr_status)\r\niowrite32(isr_status, regs->arm_to_pciea_drbl_reg);\r\n}\r\nmhba->global_isr = status;\r\nmhba->isr_status = isr_status;\r\nreturn 0;\r\n}\r\nstatic unsigned int mvumi_read_fw_status_reg(struct mvumi_hba *mhba)\r\n{\r\nunsigned int status;\r\nstatus = ioread32(mhba->regs->arm_to_pciea_drbl_reg);\r\nif (status)\r\niowrite32(status, mhba->regs->arm_to_pciea_drbl_reg);\r\nreturn status;\r\n}\r\nstatic int mvumi_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct mvumi_hba *mhba;\r\nunsigned char bitcount = sizeof(unsigned char) * 8;\r\nmhba = (struct mvumi_hba *) sdev->host->hostdata;\r\nif (sdev->id >= mhba->max_target_id)\r\nreturn -EINVAL;\r\nmhba->target_map[sdev->id / bitcount] |= (1 << (sdev->id % bitcount));\r\nreturn 0;\r\n}\r\nstatic unsigned char mvumi_build_frame(struct mvumi_hba *mhba,\r\nstruct scsi_cmnd *scmd, struct mvumi_cmd *cmd)\r\n{\r\nstruct mvumi_msg_frame *pframe;\r\ncmd->scmd = scmd;\r\ncmd->cmd_status = REQ_STATUS_PENDING;\r\npframe = cmd->frame;\r\npframe->device_id = ((unsigned short) scmd->device->id) |\r\n(((unsigned short) scmd->device->lun) << 8);\r\npframe->cmd_flag = 0;\r\nswitch (scmd->sc_data_direction) {\r\ncase DMA_NONE:\r\npframe->cmd_flag |= CMD_FLAG_NON_DATA;\r\nbreak;\r\ncase DMA_FROM_DEVICE:\r\npframe->cmd_flag |= CMD_FLAG_DATA_IN;\r\nbreak;\r\ncase DMA_TO_DEVICE:\r\npframe->cmd_flag |= CMD_FLAG_DATA_OUT;\r\nbreak;\r\ncase DMA_BIDIRECTIONAL:\r\ndefault:\r\ndev_warn(&mhba->pdev->dev, "unexpected data direction[%d] "\r\n"cmd[0x%x]\n", scmd->sc_data_direction, scmd->cmnd[0]);\r\ngoto error;\r\n}\r\npframe->cdb_length = scmd->cmd_len;\r\nmemcpy(pframe->cdb, scmd->cmnd, pframe->cdb_length);\r\npframe->req_function = CL_FUN_SCSI_CMD;\r\nif (scsi_bufflen(scmd)) {\r\nif (mvumi_make_sgl(mhba, scmd, &pframe->payload[0],\r\n&pframe->sg_counts))\r\ngoto error;\r\npframe->data_transfer_length = scsi_bufflen(scmd);\r\n} else {\r\npframe->sg_counts = 0;\r\npframe->data_transfer_length = 0;\r\n}\r\nreturn 0;\r\nerror:\r\nscmd->result = (DID_OK << 16) | (DRIVER_SENSE << 24) |\r\nSAM_STAT_CHECK_CONDITION;\r\nscsi_build_sense_buffer(0, scmd->sense_buffer, ILLEGAL_REQUEST, 0x24,\r\n0);\r\nreturn -1;\r\n}\r\nstatic int mvumi_queue_command(struct Scsi_Host *shost,\r\nstruct scsi_cmnd *scmd)\r\n{\r\nstruct mvumi_cmd *cmd;\r\nstruct mvumi_hba *mhba;\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(shost->host_lock, irq_flags);\r\nscsi_cmd_get_serial(shost, scmd);\r\nmhba = (struct mvumi_hba *) shost->hostdata;\r\nscmd->result = 0;\r\ncmd = mvumi_get_cmd(mhba);\r\nif (unlikely(!cmd)) {\r\nspin_unlock_irqrestore(shost->host_lock, irq_flags);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nif (unlikely(mvumi_build_frame(mhba, scmd, cmd)))\r\ngoto out_return_cmd;\r\ncmd->scmd = scmd;\r\nscmd->SCp.ptr = (char *) cmd;\r\nmhba->instancet->fire_cmd(mhba, cmd);\r\nspin_unlock_irqrestore(shost->host_lock, irq_flags);\r\nreturn 0;\r\nout_return_cmd:\r\nmvumi_return_cmd(mhba, cmd);\r\nscmd->scsi_done(scmd);\r\nspin_unlock_irqrestore(shost->host_lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic enum blk_eh_timer_return mvumi_timed_out(struct scsi_cmnd *scmd)\r\n{\r\nstruct mvumi_cmd *cmd = (struct mvumi_cmd *) scmd->SCp.ptr;\r\nstruct Scsi_Host *host = scmd->device->host;\r\nstruct mvumi_hba *mhba = shost_priv(host);\r\nunsigned long flags;\r\nspin_lock_irqsave(mhba->shost->host_lock, flags);\r\nif (mhba->tag_cmd[cmd->frame->tag]) {\r\nmhba->tag_cmd[cmd->frame->tag] = 0;\r\ntag_release_one(mhba, &mhba->tag_pool, cmd->frame->tag);\r\n}\r\nif (!list_empty(&cmd->queue_pointer))\r\nlist_del_init(&cmd->queue_pointer);\r\nelse\r\natomic_dec(&mhba->fw_outstanding);\r\nscmd->result = (DRIVER_INVALID << 24) | (DID_ABORT << 16);\r\nscmd->SCp.ptr = NULL;\r\nif (scsi_bufflen(scmd)) {\r\nif (scsi_sg_count(scmd)) {\r\npci_unmap_sg(mhba->pdev,\r\nscsi_sglist(scmd),\r\nscsi_sg_count(scmd),\r\n(int)scmd->sc_data_direction);\r\n} else {\r\npci_unmap_single(mhba->pdev,\r\nscmd->SCp.dma_handle,\r\nscsi_bufflen(scmd),\r\n(int)scmd->sc_data_direction);\r\nscmd->SCp.dma_handle = 0;\r\n}\r\n}\r\nmvumi_return_cmd(mhba, cmd);\r\nspin_unlock_irqrestore(mhba->shost->host_lock, flags);\r\nreturn BLK_EH_NOT_HANDLED;\r\n}\r\nstatic int\r\nmvumi_bios_param(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int geom[])\r\n{\r\nint heads, sectors;\r\nsector_t cylinders;\r\nunsigned long tmp;\r\nheads = 64;\r\nsectors = 32;\r\ntmp = heads * sectors;\r\ncylinders = capacity;\r\nsector_div(cylinders, tmp);\r\nif (capacity >= 0x200000) {\r\nheads = 255;\r\nsectors = 63;\r\ntmp = heads * sectors;\r\ncylinders = capacity;\r\nsector_div(cylinders, tmp);\r\n}\r\ngeom[0] = heads;\r\ngeom[1] = sectors;\r\ngeom[2] = cylinders;\r\nreturn 0;\r\n}\r\nstatic int mvumi_cfg_hw_reg(struct mvumi_hba *mhba)\r\n{\r\nvoid *base = NULL;\r\nstruct mvumi_hw_regs *regs;\r\nswitch (mhba->pdev->device) {\r\ncase PCI_DEVICE_ID_MARVELL_MV9143:\r\nmhba->mmio = mhba->base_addr[0];\r\nbase = mhba->mmio;\r\nif (!mhba->regs) {\r\nmhba->regs = kzalloc(sizeof(*regs), GFP_KERNEL);\r\nif (mhba->regs == NULL)\r\nreturn -ENOMEM;\r\n}\r\nregs = mhba->regs;\r\nregs->ctrl_sts_reg = base + 0x20104;\r\nregs->rstoutn_mask_reg = base + 0x20108;\r\nregs->sys_soft_rst_reg = base + 0x2010C;\r\nregs->main_int_cause_reg = base + 0x20200;\r\nregs->enpointa_mask_reg = base + 0x2020C;\r\nregs->rstoutn_en_reg = base + 0xF1400;\r\nregs->pciea_to_arm_drbl_reg = base + 0x20400;\r\nregs->arm_to_pciea_drbl_reg = base + 0x20408;\r\nregs->arm_to_pciea_mask_reg = base + 0x2040C;\r\nregs->pciea_to_arm_msg0 = base + 0x20430;\r\nregs->pciea_to_arm_msg1 = base + 0x20434;\r\nregs->arm_to_pciea_msg0 = base + 0x20438;\r\nregs->arm_to_pciea_msg1 = base + 0x2043C;\r\nregs->inb_aval_count_basel = base + 0x508;\r\nregs->inb_aval_count_baseh = base + 0x50C;\r\nregs->inb_write_pointer = base + 0x518;\r\nregs->inb_read_pointer = base + 0x51C;\r\nregs->outb_coal_cfg = base + 0x568;\r\nregs->outb_copy_basel = base + 0x5B0;\r\nregs->outb_copy_baseh = base + 0x5B4;\r\nregs->outb_copy_pointer = base + 0x544;\r\nregs->outb_read_pointer = base + 0x548;\r\nregs->outb_isr_cause = base + 0x560;\r\nregs->outb_coal_cfg = base + 0x568;\r\nregs->int_comaout = 1 << 8;\r\nregs->int_comaerr = 1 << 6;\r\nregs->int_dl_cpu2pciea = 1 << 1;\r\nregs->cl_pointer_toggle = 1 << 12;\r\nregs->clic_irq = 1 << 1;\r\nregs->clic_in_err = 1 << 8;\r\nregs->clic_out_err = 1 << 12;\r\nregs->cl_slot_num_mask = 0xFFF;\r\nregs->int_drbl_int_mask = 0x3FFFFFFF;\r\nregs->int_mu = regs->int_dl_cpu2pciea | regs->int_comaout |\r\nregs->int_comaerr;\r\nbreak;\r\ncase PCI_DEVICE_ID_MARVELL_MV9580:\r\nmhba->mmio = mhba->base_addr[2];\r\nbase = mhba->mmio;\r\nif (!mhba->regs) {\r\nmhba->regs = kzalloc(sizeof(*regs), GFP_KERNEL);\r\nif (mhba->regs == NULL)\r\nreturn -ENOMEM;\r\n}\r\nregs = mhba->regs;\r\nregs->ctrl_sts_reg = base + 0x20104;\r\nregs->rstoutn_mask_reg = base + 0x1010C;\r\nregs->sys_soft_rst_reg = base + 0x10108;\r\nregs->main_int_cause_reg = base + 0x10200;\r\nregs->enpointa_mask_reg = base + 0x1020C;\r\nregs->rstoutn_en_reg = base + 0xF1400;\r\nregs->pciea_to_arm_drbl_reg = base + 0x10460;\r\nregs->arm_to_pciea_drbl_reg = base + 0x10480;\r\nregs->arm_to_pciea_mask_reg = base + 0x10484;\r\nregs->pciea_to_arm_msg0 = base + 0x10400;\r\nregs->pciea_to_arm_msg1 = base + 0x10404;\r\nregs->arm_to_pciea_msg0 = base + 0x10420;\r\nregs->arm_to_pciea_msg1 = base + 0x10424;\r\nregs->reset_request = base + 0x10108;\r\nregs->reset_enable = base + 0x1010c;\r\nregs->inb_aval_count_basel = base + 0x4008;\r\nregs->inb_aval_count_baseh = base + 0x400C;\r\nregs->inb_write_pointer = base + 0x4018;\r\nregs->inb_read_pointer = base + 0x401C;\r\nregs->outb_copy_basel = base + 0x4058;\r\nregs->outb_copy_baseh = base + 0x405C;\r\nregs->outb_copy_pointer = base + 0x406C;\r\nregs->outb_read_pointer = base + 0x4070;\r\nregs->outb_coal_cfg = base + 0x4080;\r\nregs->outb_isr_cause = base + 0x4088;\r\nregs->int_comaout = 1 << 4;\r\nregs->int_dl_cpu2pciea = 1 << 12;\r\nregs->int_comaerr = 1 << 29;\r\nregs->cl_pointer_toggle = 1 << 14;\r\nregs->cl_slot_num_mask = 0x3FFF;\r\nregs->clic_irq = 1 << 0;\r\nregs->clic_out_err = 1 << 1;\r\nregs->int_drbl_int_mask = 0x3FFFFFFF;\r\nregs->int_mu = regs->int_dl_cpu2pciea | regs->int_comaout;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mvumi_init_fw(struct mvumi_hba *mhba)\r\n{\r\nint ret = 0;\r\nif (pci_request_regions(mhba->pdev, MV_DRIVER_NAME)) {\r\ndev_err(&mhba->pdev->dev, "IO memory region busy!\n");\r\nreturn -EBUSY;\r\n}\r\nret = mvumi_map_pci_addr(mhba->pdev, mhba->base_addr);\r\nif (ret)\r\ngoto fail_ioremap;\r\nswitch (mhba->pdev->device) {\r\ncase PCI_DEVICE_ID_MARVELL_MV9143:\r\nmhba->instancet = &mvumi_instance_9143;\r\nmhba->io_seq = 0;\r\nmhba->max_sge = MVUMI_MAX_SG_ENTRY;\r\nmhba->request_id_enabled = 1;\r\nbreak;\r\ncase PCI_DEVICE_ID_MARVELL_MV9580:\r\nmhba->instancet = &mvumi_instance_9580;\r\nmhba->io_seq = 0;\r\nmhba->max_sge = MVUMI_MAX_SG_ENTRY;\r\nbreak;\r\ndefault:\r\ndev_err(&mhba->pdev->dev, "device 0x%x not supported!\n",\r\nmhba->pdev->device);\r\nmhba->instancet = NULL;\r\nret = -EINVAL;\r\ngoto fail_alloc_mem;\r\n}\r\ndev_dbg(&mhba->pdev->dev, "device id : %04X is found.\n",\r\nmhba->pdev->device);\r\nret = mvumi_cfg_hw_reg(mhba);\r\nif (ret) {\r\ndev_err(&mhba->pdev->dev,\r\n"failed to allocate memory for reg\n");\r\nret = -ENOMEM;\r\ngoto fail_alloc_mem;\r\n}\r\nmhba->handshake_page = pci_alloc_consistent(mhba->pdev, HSP_MAX_SIZE,\r\n&mhba->handshake_page_phys);\r\nif (!mhba->handshake_page) {\r\ndev_err(&mhba->pdev->dev,\r\n"failed to allocate memory for handshake\n");\r\nret = -ENOMEM;\r\ngoto fail_alloc_page;\r\n}\r\nif (mvumi_start(mhba)) {\r\nret = -EINVAL;\r\ngoto fail_ready_state;\r\n}\r\nret = mvumi_alloc_cmds(mhba);\r\nif (ret)\r\ngoto fail_ready_state;\r\nreturn 0;\r\nfail_ready_state:\r\nmvumi_release_mem_resource(mhba);\r\npci_free_consistent(mhba->pdev, HSP_MAX_SIZE,\r\nmhba->handshake_page, mhba->handshake_page_phys);\r\nfail_alloc_page:\r\nkfree(mhba->regs);\r\nfail_alloc_mem:\r\nmvumi_unmap_pci_addr(mhba->pdev, mhba->base_addr);\r\nfail_ioremap:\r\npci_release_regions(mhba->pdev);\r\nreturn ret;\r\n}\r\nstatic int mvumi_io_attach(struct mvumi_hba *mhba)\r\n{\r\nstruct Scsi_Host *host = mhba->shost;\r\nstruct scsi_device *sdev = NULL;\r\nint ret;\r\nunsigned int max_sg = (mhba->ib_max_size + 4 -\r\nsizeof(struct mvumi_msg_frame)) / sizeof(struct mvumi_sgl);\r\nhost->irq = mhba->pdev->irq;\r\nhost->unique_id = mhba->unique_id;\r\nhost->can_queue = (mhba->max_io - 1) ? (mhba->max_io - 1) : 1;\r\nhost->sg_tablesize = mhba->max_sge > max_sg ? max_sg : mhba->max_sge;\r\nhost->max_sectors = mhba->max_transfer_size / 512;\r\nhost->cmd_per_lun = (mhba->max_io - 1) ? (mhba->max_io - 1) : 1;\r\nhost->max_id = mhba->max_target_id;\r\nhost->max_cmd_len = MAX_COMMAND_SIZE;\r\nhost->transportt = &mvumi_transport_template;\r\nret = scsi_add_host(host, &mhba->pdev->dev);\r\nif (ret) {\r\ndev_err(&mhba->pdev->dev, "scsi_add_host failed\n");\r\nreturn ret;\r\n}\r\nmhba->fw_flag |= MVUMI_FW_ATTACH;\r\nmutex_lock(&mhba->sas_discovery_mutex);\r\nif (mhba->pdev->device == PCI_DEVICE_ID_MARVELL_MV9580)\r\nret = scsi_add_device(host, 0, mhba->max_target_id - 1, 0);\r\nelse\r\nret = 0;\r\nif (ret) {\r\ndev_err(&mhba->pdev->dev, "add virtual device failed\n");\r\nmutex_unlock(&mhba->sas_discovery_mutex);\r\ngoto fail_add_device;\r\n}\r\nmhba->dm_thread = kthread_create(mvumi_rescan_bus,\r\nmhba, "mvumi_scanthread");\r\nif (IS_ERR(mhba->dm_thread)) {\r\ndev_err(&mhba->pdev->dev,\r\n"failed to create device scan thread\n");\r\nmutex_unlock(&mhba->sas_discovery_mutex);\r\ngoto fail_create_thread;\r\n}\r\natomic_set(&mhba->pnp_count, 1);\r\nwake_up_process(mhba->dm_thread);\r\nmutex_unlock(&mhba->sas_discovery_mutex);\r\nreturn 0;\r\nfail_create_thread:\r\nif (mhba->pdev->device == PCI_DEVICE_ID_MARVELL_MV9580)\r\nsdev = scsi_device_lookup(mhba->shost, 0,\r\nmhba->max_target_id - 1, 0);\r\nif (sdev) {\r\nscsi_remove_device(sdev);\r\nscsi_device_put(sdev);\r\n}\r\nfail_add_device:\r\nscsi_remove_host(mhba->shost);\r\nreturn ret;\r\n}\r\nstatic int mvumi_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct Scsi_Host *host;\r\nstruct mvumi_hba *mhba;\r\nint ret;\r\ndev_dbg(&pdev->dev, " %#4.04x:%#4.04x:%#4.04x:%#4.04x: ",\r\npdev->vendor, pdev->device, pdev->subsystem_vendor,\r\npdev->subsystem_device);\r\nret = pci_enable_device(pdev);\r\nif (ret)\r\nreturn ret;\r\npci_set_master(pdev);\r\nif (IS_DMA64) {\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (ret) {\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret)\r\ngoto fail_set_dma_mask;\r\n}\r\n} else {\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret)\r\ngoto fail_set_dma_mask;\r\n}\r\nhost = scsi_host_alloc(&mvumi_template, sizeof(*mhba));\r\nif (!host) {\r\ndev_err(&pdev->dev, "scsi_host_alloc failed\n");\r\nret = -ENOMEM;\r\ngoto fail_alloc_instance;\r\n}\r\nmhba = shost_priv(host);\r\nINIT_LIST_HEAD(&mhba->cmd_pool);\r\nINIT_LIST_HEAD(&mhba->ob_data_list);\r\nINIT_LIST_HEAD(&mhba->free_ob_list);\r\nINIT_LIST_HEAD(&mhba->res_list);\r\nINIT_LIST_HEAD(&mhba->waiting_req_list);\r\nmutex_init(&mhba->device_lock);\r\nINIT_LIST_HEAD(&mhba->mhba_dev_list);\r\nINIT_LIST_HEAD(&mhba->shost_dev_list);\r\natomic_set(&mhba->fw_outstanding, 0);\r\ninit_waitqueue_head(&mhba->int_cmd_wait_q);\r\nmutex_init(&mhba->sas_discovery_mutex);\r\nmhba->pdev = pdev;\r\nmhba->shost = host;\r\nmhba->unique_id = pdev->bus->number << 8 | pdev->devfn;\r\nret = mvumi_init_fw(mhba);\r\nif (ret)\r\ngoto fail_init_fw;\r\nret = request_irq(mhba->pdev->irq, mvumi_isr_handler, IRQF_SHARED,\r\n"mvumi", mhba);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register IRQ\n");\r\ngoto fail_init_irq;\r\n}\r\nmhba->instancet->enable_intr(mhba);\r\npci_set_drvdata(pdev, mhba);\r\nret = mvumi_io_attach(mhba);\r\nif (ret)\r\ngoto fail_io_attach;\r\nmvumi_backup_bar_addr(mhba);\r\ndev_dbg(&pdev->dev, "probe mvumi driver successfully.\n");\r\nreturn 0;\r\nfail_io_attach:\r\nmhba->instancet->disable_intr(mhba);\r\nfree_irq(mhba->pdev->irq, mhba);\r\nfail_init_irq:\r\nmvumi_release_fw(mhba);\r\nfail_init_fw:\r\nscsi_host_put(host);\r\nfail_alloc_instance:\r\nfail_set_dma_mask:\r\npci_disable_device(pdev);\r\nreturn ret;\r\n}\r\nstatic void mvumi_detach_one(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *host;\r\nstruct mvumi_hba *mhba;\r\nmhba = pci_get_drvdata(pdev);\r\nif (mhba->dm_thread) {\r\nkthread_stop(mhba->dm_thread);\r\nmhba->dm_thread = NULL;\r\n}\r\nmvumi_detach_devices(mhba);\r\nhost = mhba->shost;\r\nscsi_remove_host(mhba->shost);\r\nmvumi_flush_cache(mhba);\r\nmhba->instancet->disable_intr(mhba);\r\nfree_irq(mhba->pdev->irq, mhba);\r\nmvumi_release_fw(mhba);\r\nscsi_host_put(host);\r\npci_disable_device(pdev);\r\ndev_dbg(&pdev->dev, "driver is removed!\n");\r\n}\r\nstatic void mvumi_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct mvumi_hba *mhba = pci_get_drvdata(pdev);\r\nmvumi_flush_cache(mhba);\r\n}\r\nstatic int mvumi_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct mvumi_hba *mhba = NULL;\r\nmhba = pci_get_drvdata(pdev);\r\nmvumi_flush_cache(mhba);\r\npci_set_drvdata(pdev, mhba);\r\nmhba->instancet->disable_intr(mhba);\r\nfree_irq(mhba->pdev->irq, mhba);\r\nmvumi_unmap_pci_addr(pdev, mhba->base_addr);\r\npci_release_regions(pdev);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int mvumi_resume(struct pci_dev *pdev)\r\n{\r\nint ret;\r\nstruct mvumi_hba *mhba = NULL;\r\nmhba = pci_get_drvdata(pdev);\r\npci_set_power_state(pdev, PCI_D0);\r\npci_enable_wake(pdev, PCI_D0, 0);\r\npci_restore_state(pdev);\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "enable device failed\n");\r\nreturn ret;\r\n}\r\npci_set_master(pdev);\r\nif (IS_DMA64) {\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (ret) {\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret)\r\ngoto fail;\r\n}\r\n} else {\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret)\r\ngoto fail;\r\n}\r\nret = pci_request_regions(mhba->pdev, MV_DRIVER_NAME);\r\nif (ret)\r\ngoto fail;\r\nret = mvumi_map_pci_addr(mhba->pdev, mhba->base_addr);\r\nif (ret)\r\ngoto release_regions;\r\nif (mvumi_cfg_hw_reg(mhba)) {\r\nret = -EINVAL;\r\ngoto unmap_pci_addr;\r\n}\r\nmhba->mmio = mhba->base_addr[0];\r\nmvumi_reset(mhba);\r\nif (mvumi_start(mhba)) {\r\nret = -EINVAL;\r\ngoto unmap_pci_addr;\r\n}\r\nret = request_irq(mhba->pdev->irq, mvumi_isr_handler, IRQF_SHARED,\r\n"mvumi", mhba);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register IRQ\n");\r\ngoto unmap_pci_addr;\r\n}\r\nmhba->instancet->enable_intr(mhba);\r\nreturn 0;\r\nunmap_pci_addr:\r\nmvumi_unmap_pci_addr(pdev, mhba->base_addr);\r\nrelease_regions:\r\npci_release_regions(pdev);\r\nfail:\r\npci_disable_device(pdev);\r\nreturn ret;\r\n}\r\nstatic int __init mvumi_init(void)\r\n{\r\nreturn pci_register_driver(&mvumi_pci_driver);\r\n}\r\nstatic void __exit mvumi_exit(void)\r\n{\r\npci_unregister_driver(&mvumi_pci_driver);\r\n}
