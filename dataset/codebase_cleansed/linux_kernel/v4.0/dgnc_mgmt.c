int dgnc_mgmt_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned long flags;\r\nunsigned int minor = iminor(inode);\r\nspin_lock_irqsave(&dgnc_global_lock, flags);\r\nif (minor < MAXMGMTDEVICES) {\r\nif (dgnc_mgmt_in_use[minor]) {\r\nspin_unlock_irqrestore(&dgnc_global_lock, flags);\r\nreturn -EBUSY;\r\n}\r\ndgnc_mgmt_in_use[minor]++;\r\n} else {\r\nspin_unlock_irqrestore(&dgnc_global_lock, flags);\r\nreturn -ENXIO;\r\n}\r\nspin_unlock_irqrestore(&dgnc_global_lock, flags);\r\nreturn 0;\r\n}\r\nint dgnc_mgmt_close(struct inode *inode, struct file *file)\r\n{\r\nunsigned long flags;\r\nunsigned int minor = iminor(inode);\r\nspin_lock_irqsave(&dgnc_global_lock, flags);\r\nif (minor < MAXMGMTDEVICES) {\r\nif (dgnc_mgmt_in_use[minor])\r\ndgnc_mgmt_in_use[minor] = 0;\r\n}\r\nspin_unlock_irqrestore(&dgnc_global_lock, flags);\r\nreturn 0;\r\n}\r\nlong dgnc_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nunsigned long flags;\r\nvoid __user *uarg = (void __user *) arg;\r\nswitch (cmd) {\r\ncase DIGI_GETDD:\r\n{\r\nstruct digi_dinfo ddi;\r\nspin_lock_irqsave(&dgnc_global_lock, flags);\r\nddi.dinfo_nboards = dgnc_NumBoards;\r\nsprintf(ddi.dinfo_version, "%s", DG_PART);\r\nspin_unlock_irqrestore(&dgnc_global_lock, flags);\r\nif (copy_to_user(uarg, &ddi, sizeof(ddi)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase DIGI_GETBD:\r\n{\r\nint brd;\r\nstruct digi_info di;\r\nif (copy_from_user(&brd, uarg, sizeof(int)))\r\nreturn -EFAULT;\r\nif ((brd < 0) || (brd > dgnc_NumBoards) ||\r\n(dgnc_NumBoards == 0))\r\nreturn -ENODEV;\r\nmemset(&di, 0, sizeof(di));\r\ndi.info_bdnum = brd;\r\nspin_lock_irqsave(&dgnc_Board[brd]->bd_lock, flags);\r\ndi.info_bdtype = dgnc_Board[brd]->dpatype;\r\ndi.info_bdstate = dgnc_Board[brd]->dpastatus;\r\ndi.info_ioport = 0;\r\ndi.info_physaddr = (ulong) dgnc_Board[brd]->membase;\r\ndi.info_physsize = (ulong) dgnc_Board[brd]->membase - dgnc_Board[brd]->membase_end;\r\nif (dgnc_Board[brd]->state != BOARD_FAILED)\r\ndi.info_nports = dgnc_Board[brd]->nasync;\r\nelse\r\ndi.info_nports = 0;\r\nspin_unlock_irqrestore(&dgnc_Board[brd]->bd_lock, flags);\r\nif (copy_to_user(uarg, &di, sizeof(di)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase DIGI_GET_NI_INFO:\r\n{\r\nstruct channel_t *ch;\r\nstruct ni_info ni;\r\nunsigned char mstat = 0;\r\nuint board = 0;\r\nuint channel = 0;\r\nif (copy_from_user(&ni, uarg, sizeof(ni)))\r\nreturn -EFAULT;\r\nboard = ni.board;\r\nchannel = ni.channel;\r\nif ((board > dgnc_NumBoards) || (dgnc_NumBoards == 0))\r\nreturn -ENODEV;\r\nif ((channel < 0) || (channel > dgnc_Board[board]->nasync))\r\nreturn -ENODEV;\r\nch = dgnc_Board[board]->channels[channel];\r\nif (!ch || ch->magic != DGNC_CHANNEL_MAGIC)\r\nreturn -ENODEV;\r\nmemset(&ni, 0, sizeof(ni));\r\nni.board = board;\r\nni.channel = channel;\r\nspin_lock_irqsave(&ch->ch_lock, flags);\r\nmstat = (ch->ch_mostat | ch->ch_mistat);\r\nif (mstat & UART_MCR_DTR) {\r\nni.mstat |= TIOCM_DTR;\r\nni.dtr = TIOCM_DTR;\r\n}\r\nif (mstat & UART_MCR_RTS) {\r\nni.mstat |= TIOCM_RTS;\r\nni.rts = TIOCM_RTS;\r\n}\r\nif (mstat & UART_MSR_CTS) {\r\nni.mstat |= TIOCM_CTS;\r\nni.cts = TIOCM_CTS;\r\n}\r\nif (mstat & UART_MSR_RI) {\r\nni.mstat |= TIOCM_RI;\r\nni.ri = TIOCM_RI;\r\n}\r\nif (mstat & UART_MSR_DCD) {\r\nni.mstat |= TIOCM_CD;\r\nni.dcd = TIOCM_CD;\r\n}\r\nif (mstat & UART_MSR_DSR)\r\nni.mstat |= TIOCM_DSR;\r\nni.iflag = ch->ch_c_iflag;\r\nni.oflag = ch->ch_c_oflag;\r\nni.cflag = ch->ch_c_cflag;\r\nni.lflag = ch->ch_c_lflag;\r\nif (ch->ch_digi.digi_flags & CTSPACE ||\r\nch->ch_c_cflag & CRTSCTS)\r\nni.hflow = 1;\r\nelse\r\nni.hflow = 0;\r\nif ((ch->ch_flags & CH_STOPI) ||\r\n(ch->ch_flags & CH_FORCED_STOPI))\r\nni.recv_stopped = 1;\r\nelse\r\nni.recv_stopped = 0;\r\nif ((ch->ch_flags & CH_STOP) || (ch->ch_flags & CH_FORCED_STOP))\r\nni.xmit_stopped = 1;\r\nelse\r\nni.xmit_stopped = 0;\r\nni.curtx = ch->ch_txcount;\r\nni.currx = ch->ch_rxcount;\r\nni.baud = ch->ch_old_baud;\r\nspin_unlock_irqrestore(&ch->ch_lock, flags);\r\nif (copy_to_user(uarg, &ni, sizeof(ni)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}
