static const char *get_err_from_table(const char *table[], int size, int pos)\r\n{\r\nif (unlikely(pos >= size))\r\nreturn "Reserved";\r\nif (unlikely(!table[pos]))\r\nreturn "Reserved";\r\nreturn table[pos];\r\n}\r\nstatic void i7300_process_error_global(struct mem_ctl_info *mci)\r\n{\r\nstruct i7300_pvt *pvt;\r\nu32 errnum, error_reg;\r\nunsigned long errors;\r\nconst char *specific;\r\nbool is_fatal;\r\npvt = mci->pvt_info;\r\npci_read_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\r\nFERR_GLOBAL_HI, &error_reg);\r\nif (unlikely(error_reg)) {\r\nerrors = error_reg;\r\nerrnum = find_first_bit(&errors,\r\nARRAY_SIZE(ferr_global_hi_name));\r\nspecific = GET_ERR_FROM_TABLE(ferr_global_hi_name, errnum);\r\nis_fatal = ferr_global_hi_is_fatal(errnum);\r\npci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\r\nFERR_GLOBAL_HI, error_reg);\r\ngoto error_global;\r\n}\r\npci_read_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\r\nFERR_GLOBAL_LO, &error_reg);\r\nif (unlikely(error_reg)) {\r\nerrors = error_reg;\r\nerrnum = find_first_bit(&errors,\r\nARRAY_SIZE(ferr_global_lo_name));\r\nspecific = GET_ERR_FROM_TABLE(ferr_global_lo_name, errnum);\r\nis_fatal = ferr_global_lo_is_fatal(errnum);\r\npci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\r\nFERR_GLOBAL_LO, error_reg);\r\ngoto error_global;\r\n}\r\nreturn;\r\nerror_global:\r\ni7300_mc_printk(mci, KERN_EMERG, "%s misc error: %s\n",\r\nis_fatal ? "Fatal" : "NOT fatal", specific);\r\n}\r\nstatic void i7300_process_fbd_error(struct mem_ctl_info *mci)\r\n{\r\nstruct i7300_pvt *pvt;\r\nu32 errnum, value, error_reg;\r\nu16 val16;\r\nunsigned branch, channel, bank, rank, cas, ras;\r\nu32 syndrome;\r\nunsigned long errors;\r\nconst char *specific;\r\nbool is_wr;\r\npvt = mci->pvt_info;\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nFERR_FAT_FBD, &error_reg);\r\nif (unlikely(error_reg & FERR_FAT_FBD_ERR_MASK)) {\r\nerrors = error_reg & FERR_FAT_FBD_ERR_MASK ;\r\nerrnum = find_first_bit(&errors,\r\nARRAY_SIZE(ferr_fat_fbd_name));\r\nspecific = GET_ERR_FROM_TABLE(ferr_fat_fbd_name, errnum);\r\nbranch = (GET_FBD_FAT_IDX(error_reg) == 2) ? 1 : 0;\r\npci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map,\r\nNRECMEMA, &val16);\r\nbank = NRECMEMA_BANK(val16);\r\nrank = NRECMEMA_RANK(val16);\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nNRECMEMB, &value);\r\nis_wr = NRECMEMB_IS_WR(value);\r\ncas = NRECMEMB_CAS(value);\r\nras = NRECMEMB_RAS(value);\r\npci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nFERR_FAT_FBD, error_reg);\r\nsnprintf(pvt->tmp_prt_buffer, PAGE_SIZE,\r\n"Bank=%d RAS=%d CAS=%d Err=0x%lx (%s))",\r\nbank, ras, cas, errors, specific);\r\nedac_mc_handle_error(HW_EVENT_ERR_FATAL, mci, 1, 0, 0, 0,\r\nbranch, -1, rank,\r\nis_wr ? "Write error" : "Read error",\r\npvt->tmp_prt_buffer);\r\n}\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nFERR_NF_FBD, &error_reg);\r\nif (unlikely(error_reg & FERR_NF_FBD_ERR_MASK)) {\r\nerrors = error_reg & FERR_NF_FBD_ERR_MASK;\r\nerrnum = find_first_bit(&errors,\r\nARRAY_SIZE(ferr_nf_fbd_name));\r\nspecific = GET_ERR_FROM_TABLE(ferr_nf_fbd_name, errnum);\r\nbranch = (GET_FBD_NF_IDX(error_reg) == 2) ? 1 : 0;\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nREDMEMA, &syndrome);\r\npci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map,\r\nRECMEMA, &val16);\r\nbank = RECMEMA_BANK(val16);\r\nrank = RECMEMA_RANK(val16);\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nRECMEMB, &value);\r\nis_wr = RECMEMB_IS_WR(value);\r\ncas = RECMEMB_CAS(value);\r\nras = RECMEMB_RAS(value);\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nREDMEMB, &value);\r\nchannel = (branch << 1);\r\nif (IS_SECOND_CH(value))\r\nchannel++;\r\npci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nFERR_NF_FBD, error_reg);\r\nsnprintf(pvt->tmp_prt_buffer, PAGE_SIZE,\r\n"DRAM-Bank=%d RAS=%d CAS=%d, Err=0x%lx (%s))",\r\nbank, ras, cas, errors, specific);\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, 0, 0,\r\nsyndrome,\r\nbranch >> 1, channel % 2, rank,\r\nis_wr ? "Write error" : "Read error",\r\npvt->tmp_prt_buffer);\r\n}\r\nreturn;\r\n}\r\nstatic void i7300_check_error(struct mem_ctl_info *mci)\r\n{\r\ni7300_process_error_global(mci);\r\ni7300_process_fbd_error(mci);\r\n}\r\nstatic void i7300_clear_error(struct mem_ctl_info *mci)\r\n{\r\nstruct i7300_pvt *pvt = mci->pvt_info;\r\nu32 value;\r\npci_read_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\r\nFERR_GLOBAL_HI, &value);\r\npci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\r\nFERR_GLOBAL_HI, value);\r\npci_read_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\r\nFERR_GLOBAL_LO, &value);\r\npci_write_config_dword(pvt->pci_dev_16_2_fsb_err_regs,\r\nFERR_GLOBAL_LO, value);\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nFERR_FAT_FBD, &value);\r\npci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nFERR_FAT_FBD, value);\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nFERR_NF_FBD, &value);\r\npci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nFERR_NF_FBD, value);\r\n}\r\nstatic void i7300_enable_error_reporting(struct mem_ctl_info *mci)\r\n{\r\nstruct i7300_pvt *pvt = mci->pvt_info;\r\nu32 fbd_error_mask;\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nEMASK_FBD, &fbd_error_mask);\r\nfbd_error_mask &= ~(EMASK_FBD_ERR_MASK);\r\npci_write_config_dword(pvt->pci_dev_16_1_fsb_addr_map,\r\nEMASK_FBD, fbd_error_mask);\r\n}\r\nstatic int decode_mtr(struct i7300_pvt *pvt,\r\nint slot, int ch, int branch,\r\nstruct i7300_dimm_info *dinfo,\r\nstruct dimm_info *dimm)\r\n{\r\nint mtr, ans, addrBits, channel;\r\nchannel = to_channel(ch, branch);\r\nmtr = pvt->mtr[slot][branch];\r\nans = MTR_DIMMS_PRESENT(mtr) ? 1 : 0;\r\nedac_dbg(2, "\tMTR%d CH%d: DIMMs are %sPresent (mtr)\n",\r\nslot, channel, ans ? "" : "NOT ");\r\nif (!ans)\r\nreturn 0;\r\naddrBits = MTR_DRAM_BANKS_ADDR_BITS;\r\naddrBits += MTR_DIMM_ROWS_ADDR_BITS(mtr);\r\naddrBits += MTR_DIMM_COLS_ADDR_BITS(mtr);\r\naddrBits += MTR_DIMM_RANKS(mtr);\r\naddrBits += 6;\r\naddrBits -= 20;\r\naddrBits -= 3;\r\ndinfo->megabytes = 1 << addrBits;\r\nedac_dbg(2, "\t\tWIDTH: x%d\n", MTR_DRAM_WIDTH(mtr));\r\nedac_dbg(2, "\t\tELECTRICAL THROTTLING is %s\n",\r\nMTR_DIMMS_ETHROTTLE(mtr) ? "enabled" : "disabled");\r\nedac_dbg(2, "\t\tNUMBANK: %d bank(s)\n", MTR_DRAM_BANKS(mtr));\r\nedac_dbg(2, "\t\tNUMRANK: %s\n",\r\nMTR_DIMM_RANKS(mtr) ? "double" : "single");\r\nedac_dbg(2, "\t\tNUMROW: %s\n",\r\nMTR_DIMM_ROWS(mtr) == 0 ? "8,192 - 13 rows" :\r\nMTR_DIMM_ROWS(mtr) == 1 ? "16,384 - 14 rows" :\r\nMTR_DIMM_ROWS(mtr) == 2 ? "32,768 - 15 rows" :\r\n"65,536 - 16 rows");\r\nedac_dbg(2, "\t\tNUMCOL: %s\n",\r\nMTR_DIMM_COLS(mtr) == 0 ? "1,024 - 10 columns" :\r\nMTR_DIMM_COLS(mtr) == 1 ? "2,048 - 11 columns" :\r\nMTR_DIMM_COLS(mtr) == 2 ? "4,096 - 12 columns" :\r\n"reserved");\r\nedac_dbg(2, "\t\tSIZE: %d MB\n", dinfo->megabytes);\r\ndimm->nr_pages = MiB_TO_PAGES(dinfo->megabytes);\r\ndimm->grain = 8;\r\ndimm->mtype = MEM_FB_DDR2;\r\nif (IS_SINGLE_MODE(pvt->mc_settings_a)) {\r\ndimm->edac_mode = EDAC_SECDED;\r\nedac_dbg(2, "\t\tECC code is 8-byte-over-32-byte SECDED+ code\n");\r\n} else {\r\nedac_dbg(2, "\t\tECC code is on Lockstep mode\n");\r\nif (MTR_DRAM_WIDTH(mtr) == 8)\r\ndimm->edac_mode = EDAC_S8ECD8ED;\r\nelse\r\ndimm->edac_mode = EDAC_S4ECD4ED;\r\n}\r\nif (MTR_DRAM_WIDTH(mtr) == 8) {\r\nedac_dbg(2, "\t\tScrub algorithm for x8 is on %s mode\n",\r\nIS_SCRBALGO_ENHANCED(pvt->mc_settings) ?\r\n"enhanced" : "normal");\r\ndimm->dtype = DEV_X8;\r\n} else\r\ndimm->dtype = DEV_X4;\r\nreturn mtr;\r\n}\r\nstatic void print_dimm_size(struct i7300_pvt *pvt)\r\n{\r\n#ifdef CONFIG_EDAC_DEBUG\r\nstruct i7300_dimm_info *dinfo;\r\nchar *p;\r\nint space, n;\r\nint channel, slot;\r\nspace = PAGE_SIZE;\r\np = pvt->tmp_prt_buffer;\r\nn = snprintf(p, space, " ");\r\np += n;\r\nspace -= n;\r\nfor (channel = 0; channel < MAX_CHANNELS; channel++) {\r\nn = snprintf(p, space, "channel %d | ", channel);\r\np += n;\r\nspace -= n;\r\n}\r\nedac_dbg(2, "%s\n", pvt->tmp_prt_buffer);\r\np = pvt->tmp_prt_buffer;\r\nspace = PAGE_SIZE;\r\nn = snprintf(p, space, "-------------------------------"\r\n"------------------------------");\r\np += n;\r\nspace -= n;\r\nedac_dbg(2, "%s\n", pvt->tmp_prt_buffer);\r\np = pvt->tmp_prt_buffer;\r\nspace = PAGE_SIZE;\r\nfor (slot = 0; slot < MAX_SLOTS; slot++) {\r\nn = snprintf(p, space, "csrow/SLOT %d ", slot);\r\np += n;\r\nspace -= n;\r\nfor (channel = 0; channel < MAX_CHANNELS; channel++) {\r\ndinfo = &pvt->dimm_info[slot][channel];\r\nn = snprintf(p, space, "%4d MB | ", dinfo->megabytes);\r\np += n;\r\nspace -= n;\r\n}\r\nedac_dbg(2, "%s\n", pvt->tmp_prt_buffer);\r\np = pvt->tmp_prt_buffer;\r\nspace = PAGE_SIZE;\r\n}\r\nn = snprintf(p, space, "-------------------------------"\r\n"------------------------------");\r\np += n;\r\nspace -= n;\r\nedac_dbg(2, "%s\n", pvt->tmp_prt_buffer);\r\np = pvt->tmp_prt_buffer;\r\nspace = PAGE_SIZE;\r\n#endif\r\n}\r\nstatic int i7300_init_csrows(struct mem_ctl_info *mci)\r\n{\r\nstruct i7300_pvt *pvt;\r\nstruct i7300_dimm_info *dinfo;\r\nint rc = -ENODEV;\r\nint mtr;\r\nint ch, branch, slot, channel, max_channel, max_branch;\r\nstruct dimm_info *dimm;\r\npvt = mci->pvt_info;\r\nedac_dbg(2, "Memory Technology Registers:\n");\r\nif (IS_SINGLE_MODE(pvt->mc_settings_a)) {\r\nmax_branch = 1;\r\nmax_channel = 1;\r\n} else {\r\nmax_branch = MAX_BRANCHES;\r\nmax_channel = MAX_CH_PER_BRANCH;\r\n}\r\nfor (branch = 0; branch < max_branch; branch++) {\r\nchannel = to_channel(0, branch);\r\npci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],\r\nAMBPRESENT_0,\r\n&pvt->ambpresent[channel]);\r\nedac_dbg(2, "\t\tAMB-present CH%d = 0x%x:\n",\r\nchannel, pvt->ambpresent[channel]);\r\nif (max_channel == 1)\r\ncontinue;\r\nchannel = to_channel(1, branch);\r\npci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],\r\nAMBPRESENT_1,\r\n&pvt->ambpresent[channel]);\r\nedac_dbg(2, "\t\tAMB-present CH%d = 0x%x:\n",\r\nchannel, pvt->ambpresent[channel]);\r\n}\r\nfor (slot = 0; slot < MAX_SLOTS; slot++) {\r\nint where = mtr_regs[slot];\r\nfor (branch = 0; branch < max_branch; branch++) {\r\npci_read_config_word(pvt->pci_dev_2x_0_fbd_branch[branch],\r\nwhere,\r\n&pvt->mtr[slot][branch]);\r\nfor (ch = 0; ch < max_channel; ch++) {\r\nint channel = to_channel(ch, branch);\r\ndimm = EDAC_DIMM_PTR(mci->layers, mci->dimms,\r\nmci->n_layers, branch, ch, slot);\r\ndinfo = &pvt->dimm_info[slot][channel];\r\nmtr = decode_mtr(pvt, slot, ch, branch,\r\ndinfo, dimm);\r\nif (!MTR_DIMMS_PRESENT(mtr))\r\ncontinue;\r\nrc = 0;\r\n}\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic void decode_mir(int mir_no, u16 mir[MAX_MIR])\r\n{\r\nif (mir[mir_no] & 3)\r\nedac_dbg(2, "MIR%d: limit= 0x%x Branch(es) that participate: %s %s\n",\r\nmir_no,\r\n(mir[mir_no] >> 4) & 0xfff,\r\n(mir[mir_no] & 1) ? "B0" : "",\r\n(mir[mir_no] & 2) ? "B1" : "");\r\n}\r\nstatic int i7300_get_mc_regs(struct mem_ctl_info *mci)\r\n{\r\nstruct i7300_pvt *pvt;\r\nu32 actual_tolm;\r\nint i, rc;\r\npvt = mci->pvt_info;\r\npci_read_config_dword(pvt->pci_dev_16_0_fsb_ctlr, AMBASE,\r\n(u32 *) &pvt->ambase);\r\nedac_dbg(2, "AMBASE= 0x%lx\n", (long unsigned int)pvt->ambase);\r\npci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, TOLM, &pvt->tolm);\r\npvt->tolm >>= 12;\r\nedac_dbg(2, "TOLM (number of 256M regions) =%u (0x%x)\n",\r\npvt->tolm, pvt->tolm);\r\nactual_tolm = (u32) ((1000l * pvt->tolm) >> (30 - 28));\r\nedac_dbg(2, "Actual TOLM byte addr=%u.%03u GB (0x%x)\n",\r\nactual_tolm/1000, actual_tolm % 1000, pvt->tolm << 28);\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map, MC_SETTINGS,\r\n&pvt->mc_settings);\r\npci_read_config_dword(pvt->pci_dev_16_1_fsb_addr_map, MC_SETTINGS_A,\r\n&pvt->mc_settings_a);\r\nif (IS_SINGLE_MODE(pvt->mc_settings_a))\r\nedac_dbg(0, "Memory controller operating on single mode\n");\r\nelse\r\nedac_dbg(0, "Memory controller operating on %smirrored mode\n",\r\nIS_MIRRORED(pvt->mc_settings) ? "" : "non-");\r\nedac_dbg(0, "Error detection is %s\n",\r\nIS_ECC_ENABLED(pvt->mc_settings) ? "enabled" : "disabled");\r\nedac_dbg(0, "Retry is %s\n",\r\nIS_RETRY_ENABLED(pvt->mc_settings) ? "enabled" : "disabled");\r\npci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR0,\r\n&pvt->mir[0]);\r\npci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR1,\r\n&pvt->mir[1]);\r\npci_read_config_word(pvt->pci_dev_16_1_fsb_addr_map, MIR2,\r\n&pvt->mir[2]);\r\nfor (i = 0; i < MAX_MIR; i++)\r\ndecode_mir(i, pvt->mir);\r\nrc = i7300_init_csrows(mci);\r\nif (rc < 0)\r\nreturn rc;\r\nprint_dimm_size(pvt);\r\nreturn 0;\r\n}\r\nstatic void i7300_put_devices(struct mem_ctl_info *mci)\r\n{\r\nstruct i7300_pvt *pvt;\r\nint branch;\r\npvt = mci->pvt_info;\r\nfor (branch = 0; branch < MAX_CH_PER_BRANCH; branch++)\r\npci_dev_put(pvt->pci_dev_2x_0_fbd_branch[branch]);\r\npci_dev_put(pvt->pci_dev_16_2_fsb_err_regs);\r\npci_dev_put(pvt->pci_dev_16_1_fsb_addr_map);\r\n}\r\nstatic int i7300_get_devices(struct mem_ctl_info *mci)\r\n{\r\nstruct i7300_pvt *pvt;\r\nstruct pci_dev *pdev;\r\npvt = mci->pvt_info;\r\npdev = NULL;\r\nwhile ((pdev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_I7300_MCH_ERR,\r\npdev))) {\r\nswitch (PCI_FUNC(pdev->devfn)) {\r\ncase 1:\r\nif (!pvt->pci_dev_16_1_fsb_addr_map)\r\npvt->pci_dev_16_1_fsb_addr_map =\r\npci_dev_get(pdev);\r\nbreak;\r\ncase 2:\r\nif (!pvt->pci_dev_16_2_fsb_err_regs)\r\npvt->pci_dev_16_2_fsb_err_regs =\r\npci_dev_get(pdev);\r\nbreak;\r\n}\r\n}\r\nif (!pvt->pci_dev_16_1_fsb_addr_map ||\r\n!pvt->pci_dev_16_2_fsb_err_regs) {\r\ni7300_printk(KERN_ERR,\r\n"'system address,Process Bus' device not found:"\r\n"vendor 0x%x device 0x%x ERR funcs (broken BIOS?)\n",\r\nPCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_I7300_MCH_ERR);\r\ngoto error;\r\n}\r\nedac_dbg(1, "System Address, processor bus- PCI Bus ID: %s %x:%x\n",\r\npci_name(pvt->pci_dev_16_0_fsb_ctlr),\r\npvt->pci_dev_16_0_fsb_ctlr->vendor,\r\npvt->pci_dev_16_0_fsb_ctlr->device);\r\nedac_dbg(1, "Branchmap, control and errors - PCI Bus ID: %s %x:%x\n",\r\npci_name(pvt->pci_dev_16_1_fsb_addr_map),\r\npvt->pci_dev_16_1_fsb_addr_map->vendor,\r\npvt->pci_dev_16_1_fsb_addr_map->device);\r\nedac_dbg(1, "FSB Error Regs - PCI Bus ID: %s %x:%x\n",\r\npci_name(pvt->pci_dev_16_2_fsb_err_regs),\r\npvt->pci_dev_16_2_fsb_err_regs->vendor,\r\npvt->pci_dev_16_2_fsb_err_regs->device);\r\npvt->pci_dev_2x_0_fbd_branch[0] = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_I7300_MCH_FB0,\r\nNULL);\r\nif (!pvt->pci_dev_2x_0_fbd_branch[0]) {\r\ni7300_printk(KERN_ERR,\r\n"MC: 'BRANCH 0' device not found:"\r\n"vendor 0x%x device 0x%x Func 0 (broken BIOS?)\n",\r\nPCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_I7300_MCH_FB0);\r\ngoto error;\r\n}\r\npvt->pci_dev_2x_0_fbd_branch[1] = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_I7300_MCH_FB1,\r\nNULL);\r\nif (!pvt->pci_dev_2x_0_fbd_branch[1]) {\r\ni7300_printk(KERN_ERR,\r\n"MC: 'BRANCH 1' device not found:"\r\n"vendor 0x%x device 0x%x Func 0 "\r\n"(broken BIOS?)\n",\r\nPCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_I7300_MCH_FB1);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\ni7300_put_devices(mci);\r\nreturn -ENODEV;\r\n}\r\nstatic int i7300_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[3];\r\nstruct i7300_pvt *pvt;\r\nint rc;\r\nrc = pci_enable_device(pdev);\r\nif (rc == -EIO)\r\nreturn rc;\r\nedac_dbg(0, "MC: pdev bus %u dev=0x%x fn=0x%x\n",\r\npdev->bus->number,\r\nPCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));\r\nif (PCI_FUNC(pdev->devfn) != 0)\r\nreturn -ENODEV;\r\nlayers[0].type = EDAC_MC_LAYER_BRANCH;\r\nlayers[0].size = MAX_BRANCHES;\r\nlayers[0].is_virt_csrow = false;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = MAX_CH_PER_BRANCH;\r\nlayers[1].is_virt_csrow = true;\r\nlayers[2].type = EDAC_MC_LAYER_SLOT;\r\nlayers[2].size = MAX_SLOTS;\r\nlayers[2].is_virt_csrow = true;\r\nmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(*pvt));\r\nif (mci == NULL)\r\nreturn -ENOMEM;\r\nedac_dbg(0, "MC: mci = %p\n", mci);\r\nmci->pdev = &pdev->dev;\r\npvt = mci->pvt_info;\r\npvt->pci_dev_16_0_fsb_ctlr = pdev;\r\npvt->tmp_prt_buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!pvt->tmp_prt_buffer) {\r\nedac_mc_free(mci);\r\nreturn -ENOMEM;\r\n}\r\nif (i7300_get_devices(mci))\r\ngoto fail0;\r\nmci->mc_idx = 0;\r\nmci->mtype_cap = MEM_FLAG_FB_DDR2;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE;\r\nmci->edac_cap = EDAC_FLAG_NONE;\r\nmci->mod_name = "i7300_edac.c";\r\nmci->mod_ver = I7300_REVISION;\r\nmci->ctl_name = i7300_devs[0].ctl_name;\r\nmci->dev_name = pci_name(pdev);\r\nmci->ctl_page_to_phys = NULL;\r\nmci->edac_check = i7300_check_error;\r\nif (i7300_get_mc_regs(mci)) {\r\nedac_dbg(0, "MC: Setting mci->edac_cap to EDAC_FLAG_NONE because i7300_init_csrows() returned nonzero value\n");\r\nmci->edac_cap = EDAC_FLAG_NONE;\r\n} else {\r\nedac_dbg(1, "MC: Enable error reporting now\n");\r\ni7300_enable_error_reporting(mci);\r\n}\r\nif (edac_mc_add_mc(mci)) {\r\nedac_dbg(0, "MC: failed edac_mc_add_mc()\n");\r\ngoto fail1;\r\n}\r\ni7300_clear_error(mci);\r\ni7300_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\r\nif (!i7300_pci) {\r\nprintk(KERN_WARNING\r\n"%s(): Unable to create PCI control\n",\r\n__func__);\r\nprintk(KERN_WARNING\r\n"%s(): PCI error report via EDAC not setup\n",\r\n__func__);\r\n}\r\nreturn 0;\r\nfail1:\r\ni7300_put_devices(mci);\r\nfail0:\r\nkfree(pvt->tmp_prt_buffer);\r\nedac_mc_free(mci);\r\nreturn -ENODEV;\r\n}\r\nstatic void i7300_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nchar *tmp;\r\nedac_dbg(0, "\n");\r\nif (i7300_pci)\r\nedac_pci_release_generic_ctl(i7300_pci);\r\nmci = edac_mc_del_mc(&pdev->dev);\r\nif (!mci)\r\nreturn;\r\ntmp = ((struct i7300_pvt *)mci->pvt_info)->tmp_prt_buffer;\r\ni7300_put_devices(mci);\r\nkfree(tmp);\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init i7300_init(void)\r\n{\r\nint pci_rc;\r\nedac_dbg(2, "\n");\r\nopstate_init();\r\npci_rc = pci_register_driver(&i7300_driver);\r\nreturn (pci_rc < 0) ? pci_rc : 0;\r\n}\r\nstatic void __exit i7300_exit(void)\r\n{\r\nedac_dbg(2, "\n");\r\npci_unregister_driver(&i7300_driver);\r\n}
