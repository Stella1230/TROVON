static bool hist_browser__has_filter(struct hist_browser *hb)\r\n{\r\nreturn hists__has_filter(hb->hists) || hb->min_pcnt;\r\n}\r\nstatic u32 hist_browser__nr_entries(struct hist_browser *hb)\r\n{\r\nu32 nr_entries;\r\nif (hist_browser__has_filter(hb))\r\nnr_entries = hb->nr_non_filtered_entries;\r\nelse\r\nnr_entries = hb->hists->nr_entries;\r\nreturn nr_entries + hb->nr_callchain_rows;\r\n}\r\nstatic void hist_browser__update_rows(struct hist_browser *hb)\r\n{\r\nstruct ui_browser *browser = &hb->b;\r\nu16 header_offset = hb->show_headers ? 1 : 0, index_row;\r\nbrowser->rows = browser->height - header_offset;\r\nindex_row = browser->index - browser->top_idx;\r\nif (index_row >= browser->rows)\r\nbrowser->index -= index_row - browser->rows + 1;\r\n}\r\nstatic void hist_browser__refresh_dimensions(struct ui_browser *browser)\r\n{\r\nstruct hist_browser *hb = container_of(browser, struct hist_browser, b);\r\nbrowser->width = 3 + (hists__sort_list_width(hb->hists) + sizeof("[k]"));\r\nui_browser__refresh_dimensions(browser);\r\nhist_browser__update_rows(hb);\r\n}\r\nstatic void hist_browser__gotorc(struct hist_browser *browser, int row, int column)\r\n{\r\nu16 header_offset = browser->show_headers ? 1 : 0;\r\nui_browser__gotorc(&browser->b, row + header_offset, column);\r\n}\r\nstatic void hist_browser__reset(struct hist_browser *browser)\r\n{\r\nbrowser->nr_callchain_rows = 0;\r\nhist_browser__update_nr_entries(browser);\r\nbrowser->b.nr_entries = hist_browser__nr_entries(browser);\r\nhist_browser__refresh_dimensions(&browser->b);\r\nui_browser__reset_index(&browser->b);\r\n}\r\nstatic char tree__folded_sign(bool unfolded)\r\n{\r\nreturn unfolded ? '-' : '+';\r\n}\r\nstatic char map_symbol__folded(const struct map_symbol *ms)\r\n{\r\nreturn ms->has_children ? tree__folded_sign(ms->unfolded) : ' ';\r\n}\r\nstatic char hist_entry__folded(const struct hist_entry *he)\r\n{\r\nreturn map_symbol__folded(&he->ms);\r\n}\r\nstatic char callchain_list__folded(const struct callchain_list *cl)\r\n{\r\nreturn map_symbol__folded(&cl->ms);\r\n}\r\nstatic void map_symbol__set_folding(struct map_symbol *ms, bool unfold)\r\n{\r\nms->unfolded = unfold ? ms->has_children : false;\r\n}\r\nstatic int callchain_node__count_rows_rb_tree(struct callchain_node *node)\r\n{\r\nint n = 0;\r\nstruct rb_node *nd;\r\nfor (nd = rb_first(&node->rb_root); nd; nd = rb_next(nd)) {\r\nstruct callchain_node *child = rb_entry(nd, struct callchain_node, rb_node);\r\nstruct callchain_list *chain;\r\nchar folded_sign = ' ';\r\nlist_for_each_entry(chain, &child->val, list) {\r\n++n;\r\nfolded_sign = callchain_list__folded(chain);\r\nif (folded_sign == '+')\r\nbreak;\r\n}\r\nif (folded_sign == '-')\r\nn += callchain_node__count_rows_rb_tree(child);\r\n}\r\nreturn n;\r\n}\r\nstatic int callchain_node__count_rows(struct callchain_node *node)\r\n{\r\nstruct callchain_list *chain;\r\nbool unfolded = false;\r\nint n = 0;\r\nlist_for_each_entry(chain, &node->val, list) {\r\n++n;\r\nunfolded = chain->ms.unfolded;\r\n}\r\nif (unfolded)\r\nn += callchain_node__count_rows_rb_tree(node);\r\nreturn n;\r\n}\r\nstatic int callchain__count_rows(struct rb_root *chain)\r\n{\r\nstruct rb_node *nd;\r\nint n = 0;\r\nfor (nd = rb_first(chain); nd; nd = rb_next(nd)) {\r\nstruct callchain_node *node = rb_entry(nd, struct callchain_node, rb_node);\r\nn += callchain_node__count_rows(node);\r\n}\r\nreturn n;\r\n}\r\nstatic bool map_symbol__toggle_fold(struct map_symbol *ms)\r\n{\r\nif (!ms)\r\nreturn false;\r\nif (!ms->has_children)\r\nreturn false;\r\nms->unfolded = !ms->unfolded;\r\nreturn true;\r\n}\r\nstatic void callchain_node__init_have_children_rb_tree(struct callchain_node *node)\r\n{\r\nstruct rb_node *nd = rb_first(&node->rb_root);\r\nfor (nd = rb_first(&node->rb_root); nd; nd = rb_next(nd)) {\r\nstruct callchain_node *child = rb_entry(nd, struct callchain_node, rb_node);\r\nstruct callchain_list *chain;\r\nbool first = true;\r\nlist_for_each_entry(chain, &child->val, list) {\r\nif (first) {\r\nfirst = false;\r\nchain->ms.has_children = chain->list.next != &child->val ||\r\n!RB_EMPTY_ROOT(&child->rb_root);\r\n} else\r\nchain->ms.has_children = chain->list.next == &child->val &&\r\n!RB_EMPTY_ROOT(&child->rb_root);\r\n}\r\ncallchain_node__init_have_children_rb_tree(child);\r\n}\r\n}\r\nstatic void callchain_node__init_have_children(struct callchain_node *node,\r\nbool has_sibling)\r\n{\r\nstruct callchain_list *chain;\r\nchain = list_entry(node->val.next, struct callchain_list, list);\r\nchain->ms.has_children = has_sibling;\r\nif (!list_empty(&node->val)) {\r\nchain = list_entry(node->val.prev, struct callchain_list, list);\r\nchain->ms.has_children = !RB_EMPTY_ROOT(&node->rb_root);\r\n}\r\ncallchain_node__init_have_children_rb_tree(node);\r\n}\r\nstatic void callchain__init_have_children(struct rb_root *root)\r\n{\r\nstruct rb_node *nd = rb_first(root);\r\nbool has_sibling = nd && rb_next(nd);\r\nfor (nd = rb_first(root); nd; nd = rb_next(nd)) {\r\nstruct callchain_node *node = rb_entry(nd, struct callchain_node, rb_node);\r\ncallchain_node__init_have_children(node, has_sibling);\r\n}\r\n}\r\nstatic void hist_entry__init_have_children(struct hist_entry *he)\r\n{\r\nif (!he->init_have_children) {\r\nhe->ms.has_children = !RB_EMPTY_ROOT(&he->sorted_chain);\r\ncallchain__init_have_children(&he->sorted_chain);\r\nhe->init_have_children = true;\r\n}\r\n}\r\nstatic bool hist_browser__toggle_fold(struct hist_browser *browser)\r\n{\r\nif (map_symbol__toggle_fold(browser->selection)) {\r\nstruct hist_entry *he = browser->he_selection;\r\nhist_entry__init_have_children(he);\r\nbrowser->b.nr_entries -= he->nr_rows;\r\nbrowser->nr_callchain_rows -= he->nr_rows;\r\nif (he->ms.unfolded)\r\nhe->nr_rows = callchain__count_rows(&he->sorted_chain);\r\nelse\r\nhe->nr_rows = 0;\r\nbrowser->b.nr_entries += he->nr_rows;\r\nbrowser->nr_callchain_rows += he->nr_rows;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int callchain_node__set_folding_rb_tree(struct callchain_node *node, bool unfold)\r\n{\r\nint n = 0;\r\nstruct rb_node *nd;\r\nfor (nd = rb_first(&node->rb_root); nd; nd = rb_next(nd)) {\r\nstruct callchain_node *child = rb_entry(nd, struct callchain_node, rb_node);\r\nstruct callchain_list *chain;\r\nbool has_children = false;\r\nlist_for_each_entry(chain, &child->val, list) {\r\n++n;\r\nmap_symbol__set_folding(&chain->ms, unfold);\r\nhas_children = chain->ms.has_children;\r\n}\r\nif (has_children)\r\nn += callchain_node__set_folding_rb_tree(child, unfold);\r\n}\r\nreturn n;\r\n}\r\nstatic int callchain_node__set_folding(struct callchain_node *node, bool unfold)\r\n{\r\nstruct callchain_list *chain;\r\nbool has_children = false;\r\nint n = 0;\r\nlist_for_each_entry(chain, &node->val, list) {\r\n++n;\r\nmap_symbol__set_folding(&chain->ms, unfold);\r\nhas_children = chain->ms.has_children;\r\n}\r\nif (has_children)\r\nn += callchain_node__set_folding_rb_tree(node, unfold);\r\nreturn n;\r\n}\r\nstatic int callchain__set_folding(struct rb_root *chain, bool unfold)\r\n{\r\nstruct rb_node *nd;\r\nint n = 0;\r\nfor (nd = rb_first(chain); nd; nd = rb_next(nd)) {\r\nstruct callchain_node *node = rb_entry(nd, struct callchain_node, rb_node);\r\nn += callchain_node__set_folding(node, unfold);\r\n}\r\nreturn n;\r\n}\r\nstatic void hist_entry__set_folding(struct hist_entry *he, bool unfold)\r\n{\r\nhist_entry__init_have_children(he);\r\nmap_symbol__set_folding(&he->ms, unfold);\r\nif (he->ms.has_children) {\r\nint n = callchain__set_folding(&he->sorted_chain, unfold);\r\nhe->nr_rows = unfold ? n : 0;\r\n} else\r\nhe->nr_rows = 0;\r\n}\r\nstatic void\r\n__hist_browser__set_folding(struct hist_browser *browser, bool unfold)\r\n{\r\nstruct rb_node *nd;\r\nstruct hists *hists = browser->hists;\r\nfor (nd = rb_first(&hists->entries);\r\n(nd = hists__filter_entries(nd, browser->min_pcnt)) != NULL;\r\nnd = rb_next(nd)) {\r\nstruct hist_entry *he = rb_entry(nd, struct hist_entry, rb_node);\r\nhist_entry__set_folding(he, unfold);\r\nbrowser->nr_callchain_rows += he->nr_rows;\r\n}\r\n}\r\nstatic void hist_browser__set_folding(struct hist_browser *browser, bool unfold)\r\n{\r\nbrowser->nr_callchain_rows = 0;\r\n__hist_browser__set_folding(browser, unfold);\r\nbrowser->b.nr_entries = hist_browser__nr_entries(browser);\r\nui_browser__reset_index(&browser->b);\r\n}\r\nstatic void ui_browser__warn_lost_events(struct ui_browser *browser)\r\n{\r\nui_browser__warning(browser, 4,\r\n"Events are being lost, check IO/CPU overload!\n\n"\r\n"You may want to run 'perf' using a RT scheduler policy:\n\n"\r\n" perf top -r 80\n\n"\r\n"Or reduce the sampling frequency.");\r\n}\r\nstatic int hist_browser__run(struct hist_browser *browser,\r\nstruct hist_browser_timer *hbt)\r\n{\r\nint key;\r\nchar title[160];\r\nint delay_secs = hbt ? hbt->refresh : 0;\r\nbrowser->b.entries = &browser->hists->entries;\r\nbrowser->b.nr_entries = hist_browser__nr_entries(browser);\r\nhists__browser_title(browser->hists, hbt, title, sizeof(title));\r\nif (ui_browser__show(&browser->b, title,\r\n"Press '?' for help on key bindings") < 0)\r\nreturn -1;\r\nwhile (1) {\r\nkey = ui_browser__run(&browser->b, delay_secs);\r\nswitch (key) {\r\ncase K_TIMER: {\r\nu64 nr_entries;\r\nhbt->timer(hbt->arg);\r\nif (hist_browser__has_filter(browser))\r\nhist_browser__update_nr_entries(browser);\r\nnr_entries = hist_browser__nr_entries(browser);\r\nui_browser__update_nr_entries(&browser->b, nr_entries);\r\nif (browser->hists->stats.nr_lost_warned !=\r\nbrowser->hists->stats.nr_events[PERF_RECORD_LOST]) {\r\nbrowser->hists->stats.nr_lost_warned =\r\nbrowser->hists->stats.nr_events[PERF_RECORD_LOST];\r\nui_browser__warn_lost_events(&browser->b);\r\n}\r\nhists__browser_title(browser->hists,\r\nhbt, title, sizeof(title));\r\nui_browser__show_title(&browser->b, title);\r\ncontinue;\r\n}\r\ncase 'D': {\r\nstatic int seq;\r\nstruct hist_entry *h = rb_entry(browser->b.top,\r\nstruct hist_entry, rb_node);\r\nui_helpline__pop();\r\nui_helpline__fpush("%d: nr_ent=(%d,%d), rows=%d, idx=%d, fve: idx=%d, row_off=%d, nrows=%d",\r\nseq++, browser->b.nr_entries,\r\nbrowser->hists->nr_entries,\r\nbrowser->b.rows,\r\nbrowser->b.index,\r\nbrowser->b.top_idx,\r\nh->row_offset, h->nr_rows);\r\n}\r\nbreak;\r\ncase 'C':\r\nhist_browser__set_folding(browser, false);\r\nbreak;\r\ncase 'E':\r\nhist_browser__set_folding(browser, true);\r\nbreak;\r\ncase 'H':\r\nbrowser->show_headers = !browser->show_headers;\r\nhist_browser__update_rows(browser);\r\nbreak;\r\ncase K_ENTER:\r\nif (hist_browser__toggle_fold(browser))\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\n}\r\nout:\r\nui_browser__hide(&browser->b);\r\nreturn key;\r\n}\r\nstatic void hist_browser__show_callchain_entry(struct hist_browser *browser,\r\nstruct callchain_list *chain,\r\nconst char *str, int offset,\r\nunsigned short row,\r\nstruct callchain_print_arg *arg)\r\n{\r\nint color, width;\r\nchar folded_sign = callchain_list__folded(chain);\r\ncolor = HE_COLORSET_NORMAL;\r\nwidth = browser->b.width - (offset + 2);\r\nif (ui_browser__is_current_entry(&browser->b, row)) {\r\nbrowser->selection = &chain->ms;\r\ncolor = HE_COLORSET_SELECTED;\r\narg->is_current_entry = true;\r\n}\r\nui_browser__set_color(&browser->b, color);\r\nhist_browser__gotorc(browser, row, 0);\r\nslsmg_write_nstring(" ", offset);\r\nslsmg_printf("%c ", folded_sign);\r\nslsmg_write_nstring(str, width);\r\n}\r\nstatic void hist_browser__fprintf_callchain_entry(struct hist_browser *b __maybe_unused,\r\nstruct callchain_list *chain,\r\nconst char *str, int offset,\r\nunsigned short row __maybe_unused,\r\nstruct callchain_print_arg *arg)\r\n{\r\nchar folded_sign = callchain_list__folded(chain);\r\narg->printed += fprintf(arg->fp, "%*s%c %s\n", offset, " ",\r\nfolded_sign, str);\r\n}\r\nstatic bool hist_browser__check_output_full(struct hist_browser *browser,\r\nunsigned short row)\r\n{\r\nreturn browser->b.rows == row;\r\n}\r\nstatic bool hist_browser__check_dump_full(struct hist_browser *browser __maybe_unused,\r\nunsigned short row __maybe_unused)\r\n{\r\nreturn false;\r\n}\r\nstatic int hist_browser__show_callchain(struct hist_browser *browser,\r\nstruct rb_root *root, int level,\r\nunsigned short row, u64 total,\r\nprint_callchain_entry_fn print,\r\nstruct callchain_print_arg *arg,\r\ncheck_output_full_fn is_output_full)\r\n{\r\nstruct rb_node *node;\r\nint first_row = row, offset = level * LEVEL_OFFSET_STEP;\r\nu64 new_total;\r\nbool need_percent;\r\nnode = rb_first(root);\r\nneed_percent = node && rb_next(node);\r\nwhile (node) {\r\nstruct callchain_node *child = rb_entry(node, struct callchain_node, rb_node);\r\nstruct rb_node *next = rb_next(node);\r\nu64 cumul = callchain_cumul_hits(child);\r\nstruct callchain_list *chain;\r\nchar folded_sign = ' ';\r\nint first = true;\r\nint extra_offset = 0;\r\nlist_for_each_entry(chain, &child->val, list) {\r\nchar bf[1024], *alloc_str;\r\nconst char *str;\r\nbool was_first = first;\r\nif (first)\r\nfirst = false;\r\nelse if (need_percent)\r\nextra_offset = LEVEL_OFFSET_STEP;\r\nfolded_sign = callchain_list__folded(chain);\r\nif (arg->row_offset != 0) {\r\narg->row_offset--;\r\ngoto do_next;\r\n}\r\nalloc_str = NULL;\r\nstr = callchain_list__sym_name(chain, bf, sizeof(bf),\r\nbrowser->show_dso);\r\nif (was_first && need_percent) {\r\ndouble percent = cumul * 100.0 / total;\r\nif (asprintf(&alloc_str, "%2.2f%% %s", percent, str) < 0)\r\nstr = "Not enough memory!";\r\nelse\r\nstr = alloc_str;\r\n}\r\nprint(browser, chain, str, offset + extra_offset, row, arg);\r\nfree(alloc_str);\r\nif (is_output_full(browser, ++row))\r\ngoto out;\r\ndo_next:\r\nif (folded_sign == '+')\r\nbreak;\r\n}\r\nif (folded_sign == '-') {\r\nconst int new_level = level + (extra_offset ? 2 : 1);\r\nif (callchain_param.mode == CHAIN_GRAPH_REL)\r\nnew_total = child->children_hit;\r\nelse\r\nnew_total = total;\r\nrow += hist_browser__show_callchain(browser, &child->rb_root,\r\nnew_level, row, new_total,\r\nprint, arg, is_output_full);\r\n}\r\nif (is_output_full(browser, row))\r\nbreak;\r\nnode = next;\r\n}\r\nout:\r\nreturn row - first_row;\r\n}\r\nstatic int __hpp__slsmg_color_printf(struct perf_hpp *hpp, const char *fmt, ...)\r\n{\r\nstruct hpp_arg *arg = hpp->ptr;\r\nint ret, len;\r\nva_list args;\r\ndouble percent;\r\nva_start(args, fmt);\r\nlen = va_arg(args, int);\r\npercent = va_arg(args, double);\r\nva_end(args);\r\nui_browser__set_percent_color(arg->b, percent, arg->current_entry);\r\nret = scnprintf(hpp->buf, hpp->size, fmt, len, percent);\r\nslsmg_printf("%s", hpp->buf);\r\nadvance_hpp(hpp, ret);\r\nreturn ret;\r\n}\r\nvoid hist_browser__init_hpp(void)\r\n{\r\nperf_hpp__format[PERF_HPP__OVERHEAD].color =\r\nhist_browser__hpp_color_overhead;\r\nperf_hpp__format[PERF_HPP__OVERHEAD_SYS].color =\r\nhist_browser__hpp_color_overhead_sys;\r\nperf_hpp__format[PERF_HPP__OVERHEAD_US].color =\r\nhist_browser__hpp_color_overhead_us;\r\nperf_hpp__format[PERF_HPP__OVERHEAD_GUEST_SYS].color =\r\nhist_browser__hpp_color_overhead_guest_sys;\r\nperf_hpp__format[PERF_HPP__OVERHEAD_GUEST_US].color =\r\nhist_browser__hpp_color_overhead_guest_us;\r\nperf_hpp__format[PERF_HPP__OVERHEAD_ACC].color =\r\nhist_browser__hpp_color_overhead_acc;\r\n}\r\nstatic int hist_browser__show_entry(struct hist_browser *browser,\r\nstruct hist_entry *entry,\r\nunsigned short row)\r\n{\r\nchar s[256];\r\nint printed = 0;\r\nint width = browser->b.width;\r\nchar folded_sign = ' ';\r\nbool current_entry = ui_browser__is_current_entry(&browser->b, row);\r\noff_t row_offset = entry->row_offset;\r\nbool first = true;\r\nstruct perf_hpp_fmt *fmt;\r\nif (current_entry) {\r\nbrowser->he_selection = entry;\r\nbrowser->selection = &entry->ms;\r\n}\r\nif (symbol_conf.use_callchain) {\r\nhist_entry__init_have_children(entry);\r\nfolded_sign = hist_entry__folded(entry);\r\n}\r\nif (row_offset == 0) {\r\nstruct hpp_arg arg = {\r\n.b = &browser->b,\r\n.folded_sign = folded_sign,\r\n.current_entry = current_entry,\r\n};\r\nstruct perf_hpp hpp = {\r\n.buf = s,\r\n.size = sizeof(s),\r\n.ptr = &arg,\r\n};\r\nhist_browser__gotorc(browser, row, 0);\r\nperf_hpp__for_each_format(fmt) {\r\nif (perf_hpp__should_skip(fmt))\r\ncontinue;\r\nif (current_entry && browser->b.navkeypressed) {\r\nui_browser__set_color(&browser->b,\r\nHE_COLORSET_SELECTED);\r\n} else {\r\nui_browser__set_color(&browser->b,\r\nHE_COLORSET_NORMAL);\r\n}\r\nif (first) {\r\nif (symbol_conf.use_callchain) {\r\nslsmg_printf("%c ", folded_sign);\r\nwidth -= 2;\r\n}\r\nfirst = false;\r\n} else {\r\nslsmg_printf(" ");\r\nwidth -= 2;\r\n}\r\nif (fmt->color) {\r\nwidth -= fmt->color(fmt, &hpp, entry);\r\n} else {\r\nwidth -= fmt->entry(fmt, &hpp, entry);\r\nslsmg_printf("%s", s);\r\n}\r\n}\r\nif (!browser->b.navkeypressed)\r\nwidth += 1;\r\nslsmg_write_nstring("", width);\r\n++row;\r\n++printed;\r\n} else\r\n--row_offset;\r\nif (folded_sign == '-' && row != browser->b.rows) {\r\nu64 total = hists__total_period(entry->hists);\r\nstruct callchain_print_arg arg = {\r\n.row_offset = row_offset,\r\n.is_current_entry = current_entry,\r\n};\r\nif (callchain_param.mode == CHAIN_GRAPH_REL) {\r\nif (symbol_conf.cumulate_callchain)\r\ntotal = entry->stat_acc->period;\r\nelse\r\ntotal = entry->stat.period;\r\n}\r\nprinted += hist_browser__show_callchain(browser,\r\n&entry->sorted_chain, 1, row, total,\r\nhist_browser__show_callchain_entry, &arg,\r\nhist_browser__check_output_full);\r\nif (arg.is_current_entry)\r\nbrowser->he_selection = entry;\r\n}\r\nreturn printed;\r\n}\r\nstatic int advance_hpp_check(struct perf_hpp *hpp, int inc)\r\n{\r\nadvance_hpp(hpp, inc);\r\nreturn hpp->size <= 0;\r\n}\r\nstatic int hists__scnprintf_headers(char *buf, size_t size, struct hists *hists)\r\n{\r\nstruct perf_hpp dummy_hpp = {\r\n.buf = buf,\r\n.size = size,\r\n};\r\nstruct perf_hpp_fmt *fmt;\r\nsize_t ret = 0;\r\nif (symbol_conf.use_callchain) {\r\nret = scnprintf(buf, size, " ");\r\nif (advance_hpp_check(&dummy_hpp, ret))\r\nreturn ret;\r\n}\r\nperf_hpp__for_each_format(fmt) {\r\nif (perf_hpp__should_skip(fmt))\r\ncontinue;\r\nret = fmt->header(fmt, &dummy_hpp, hists_to_evsel(hists));\r\nif (advance_hpp_check(&dummy_hpp, ret))\r\nbreak;\r\nret = scnprintf(dummy_hpp.buf, dummy_hpp.size, " ");\r\nif (advance_hpp_check(&dummy_hpp, ret))\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void hist_browser__show_headers(struct hist_browser *browser)\r\n{\r\nchar headers[1024];\r\nhists__scnprintf_headers(headers, sizeof(headers), browser->hists);\r\nui_browser__gotorc(&browser->b, 0, 0);\r\nui_browser__set_color(&browser->b, HE_COLORSET_ROOT);\r\nslsmg_write_nstring(headers, browser->b.width + 1);\r\n}\r\nstatic void ui_browser__hists_init_top(struct ui_browser *browser)\r\n{\r\nif (browser->top == NULL) {\r\nstruct hist_browser *hb;\r\nhb = container_of(browser, struct hist_browser, b);\r\nbrowser->top = rb_first(&hb->hists->entries);\r\n}\r\n}\r\nstatic unsigned int hist_browser__refresh(struct ui_browser *browser)\r\n{\r\nunsigned row = 0;\r\nu16 header_offset = 0;\r\nstruct rb_node *nd;\r\nstruct hist_browser *hb = container_of(browser, struct hist_browser, b);\r\nif (hb->show_headers) {\r\nhist_browser__show_headers(hb);\r\nheader_offset = 1;\r\n}\r\nui_browser__hists_init_top(browser);\r\nfor (nd = browser->top; nd; nd = rb_next(nd)) {\r\nstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\r\nfloat percent;\r\nif (h->filtered)\r\ncontinue;\r\npercent = hist_entry__get_percent_limit(h);\r\nif (percent < hb->min_pcnt)\r\ncontinue;\r\nrow += hist_browser__show_entry(hb, h, row);\r\nif (row == browser->rows)\r\nbreak;\r\n}\r\nreturn row + header_offset;\r\n}\r\nstatic struct rb_node *hists__filter_entries(struct rb_node *nd,\r\nfloat min_pcnt)\r\n{\r\nwhile (nd != NULL) {\r\nstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\r\nfloat percent = hist_entry__get_percent_limit(h);\r\nif (!h->filtered && percent >= min_pcnt)\r\nreturn nd;\r\nnd = rb_next(nd);\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct rb_node *hists__filter_prev_entries(struct rb_node *nd,\r\nfloat min_pcnt)\r\n{\r\nwhile (nd != NULL) {\r\nstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\r\nfloat percent = hist_entry__get_percent_limit(h);\r\nif (!h->filtered && percent >= min_pcnt)\r\nreturn nd;\r\nnd = rb_prev(nd);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void ui_browser__hists_seek(struct ui_browser *browser,\r\noff_t offset, int whence)\r\n{\r\nstruct hist_entry *h;\r\nstruct rb_node *nd;\r\nbool first = true;\r\nstruct hist_browser *hb;\r\nhb = container_of(browser, struct hist_browser, b);\r\nif (browser->nr_entries == 0)\r\nreturn;\r\nui_browser__hists_init_top(browser);\r\nswitch (whence) {\r\ncase SEEK_SET:\r\nnd = hists__filter_entries(rb_first(browser->entries),\r\nhb->min_pcnt);\r\nbreak;\r\ncase SEEK_CUR:\r\nnd = browser->top;\r\ngoto do_offset;\r\ncase SEEK_END:\r\nnd = hists__filter_prev_entries(rb_last(browser->entries),\r\nhb->min_pcnt);\r\nfirst = false;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nh = rb_entry(browser->top, struct hist_entry, rb_node);\r\nh->row_offset = 0;\r\ndo_offset:\r\nif (offset > 0) {\r\ndo {\r\nh = rb_entry(nd, struct hist_entry, rb_node);\r\nif (h->ms.unfolded) {\r\nu16 remaining = h->nr_rows - h->row_offset;\r\nif (offset > remaining) {\r\noffset -= remaining;\r\nh->row_offset = 0;\r\n} else {\r\nh->row_offset += offset;\r\noffset = 0;\r\nbrowser->top = nd;\r\nbreak;\r\n}\r\n}\r\nnd = hists__filter_entries(rb_next(nd), hb->min_pcnt);\r\nif (nd == NULL)\r\nbreak;\r\n--offset;\r\nbrowser->top = nd;\r\n} while (offset != 0);\r\n} else if (offset < 0) {\r\nwhile (1) {\r\nh = rb_entry(nd, struct hist_entry, rb_node);\r\nif (h->ms.unfolded) {\r\nif (first) {\r\nif (-offset > h->row_offset) {\r\noffset += h->row_offset;\r\nh->row_offset = 0;\r\n} else {\r\nh->row_offset += offset;\r\noffset = 0;\r\nbrowser->top = nd;\r\nbreak;\r\n}\r\n} else {\r\nif (-offset > h->nr_rows) {\r\noffset += h->nr_rows;\r\nh->row_offset = 0;\r\n} else {\r\nh->row_offset = h->nr_rows + offset;\r\noffset = 0;\r\nbrowser->top = nd;\r\nbreak;\r\n}\r\n}\r\n}\r\nnd = hists__filter_prev_entries(rb_prev(nd),\r\nhb->min_pcnt);\r\nif (nd == NULL)\r\nbreak;\r\n++offset;\r\nbrowser->top = nd;\r\nif (offset == 0) {\r\nh = rb_entry(nd, struct hist_entry, rb_node);\r\nif (h->ms.unfolded)\r\nh->row_offset = h->nr_rows;\r\nbreak;\r\n}\r\nfirst = false;\r\n}\r\n} else {\r\nbrowser->top = nd;\r\nh = rb_entry(nd, struct hist_entry, rb_node);\r\nh->row_offset = 0;\r\n}\r\n}\r\nstatic int hist_browser__fprintf_callchain(struct hist_browser *browser,\r\nstruct hist_entry *he, FILE *fp)\r\n{\r\nu64 total = hists__total_period(he->hists);\r\nstruct callchain_print_arg arg = {\r\n.fp = fp,\r\n};\r\nif (symbol_conf.cumulate_callchain)\r\ntotal = he->stat_acc->period;\r\nhist_browser__show_callchain(browser, &he->sorted_chain, 1, 0, total,\r\nhist_browser__fprintf_callchain_entry, &arg,\r\nhist_browser__check_dump_full);\r\nreturn arg.printed;\r\n}\r\nstatic int hist_browser__fprintf_entry(struct hist_browser *browser,\r\nstruct hist_entry *he, FILE *fp)\r\n{\r\nchar s[8192];\r\nint printed = 0;\r\nchar folded_sign = ' ';\r\nstruct perf_hpp hpp = {\r\n.buf = s,\r\n.size = sizeof(s),\r\n};\r\nstruct perf_hpp_fmt *fmt;\r\nbool first = true;\r\nint ret;\r\nif (symbol_conf.use_callchain)\r\nfolded_sign = hist_entry__folded(he);\r\nif (symbol_conf.use_callchain)\r\nprinted += fprintf(fp, "%c ", folded_sign);\r\nperf_hpp__for_each_format(fmt) {\r\nif (perf_hpp__should_skip(fmt))\r\ncontinue;\r\nif (!first) {\r\nret = scnprintf(hpp.buf, hpp.size, " ");\r\nadvance_hpp(&hpp, ret);\r\n} else\r\nfirst = false;\r\nret = fmt->entry(fmt, &hpp, he);\r\nadvance_hpp(&hpp, ret);\r\n}\r\nprinted += fprintf(fp, "%s\n", rtrim(s));\r\nif (folded_sign == '-')\r\nprinted += hist_browser__fprintf_callchain(browser, he, fp);\r\nreturn printed;\r\n}\r\nstatic int hist_browser__fprintf(struct hist_browser *browser, FILE *fp)\r\n{\r\nstruct rb_node *nd = hists__filter_entries(rb_first(browser->b.entries),\r\nbrowser->min_pcnt);\r\nint printed = 0;\r\nwhile (nd) {\r\nstruct hist_entry *h = rb_entry(nd, struct hist_entry, rb_node);\r\nprinted += hist_browser__fprintf_entry(browser, h, fp);\r\nnd = hists__filter_entries(rb_next(nd), browser->min_pcnt);\r\n}\r\nreturn printed;\r\n}\r\nstatic int hist_browser__dump(struct hist_browser *browser)\r\n{\r\nchar filename[64];\r\nFILE *fp;\r\nwhile (1) {\r\nscnprintf(filename, sizeof(filename), "perf.hist.%d", browser->print_seq);\r\nif (access(filename, F_OK))\r\nbreak;\r\nif (++browser->print_seq == 8192) {\r\nui_helpline__fpush("Too many perf.hist.N files, nothing written!");\r\nreturn -1;\r\n}\r\n}\r\nfp = fopen(filename, "w");\r\nif (fp == NULL) {\r\nchar bf[64];\r\nconst char *err = strerror_r(errno, bf, sizeof(bf));\r\nui_helpline__fpush("Couldn't write to %s: %s", filename, err);\r\nreturn -1;\r\n}\r\n++browser->print_seq;\r\nhist_browser__fprintf(browser, fp);\r\nfclose(fp);\r\nui_helpline__fpush("%s written!", filename);\r\nreturn 0;\r\n}\r\nstatic struct hist_browser *hist_browser__new(struct hists *hists)\r\n{\r\nstruct hist_browser *browser = zalloc(sizeof(*browser));\r\nif (browser) {\r\nbrowser->hists = hists;\r\nbrowser->b.refresh = hist_browser__refresh;\r\nbrowser->b.refresh_dimensions = hist_browser__refresh_dimensions;\r\nbrowser->b.seek = ui_browser__hists_seek;\r\nbrowser->b.use_navkeypressed = true;\r\nbrowser->show_headers = symbol_conf.show_hist_headers;\r\n}\r\nreturn browser;\r\n}\r\nstatic void hist_browser__delete(struct hist_browser *browser)\r\n{\r\nfree(browser);\r\n}\r\nstatic struct hist_entry *hist_browser__selected_entry(struct hist_browser *browser)\r\n{\r\nreturn browser->he_selection;\r\n}\r\nstatic struct thread *hist_browser__selected_thread(struct hist_browser *browser)\r\n{\r\nreturn browser->he_selection->thread;\r\n}\r\nstatic inline bool is_report_browser(void *timer)\r\n{\r\nreturn timer == NULL;\r\n}\r\nstatic int hists__browser_title(struct hists *hists,\r\nstruct hist_browser_timer *hbt,\r\nchar *bf, size_t size)\r\n{\r\nchar unit;\r\nint printed;\r\nconst struct dso *dso = hists->dso_filter;\r\nconst struct thread *thread = hists->thread_filter;\r\nunsigned long nr_samples = hists->stats.nr_events[PERF_RECORD_SAMPLE];\r\nu64 nr_events = hists->stats.total_period;\r\nstruct perf_evsel *evsel = hists_to_evsel(hists);\r\nconst char *ev_name = perf_evsel__name(evsel);\r\nchar buf[512];\r\nsize_t buflen = sizeof(buf);\r\nif (symbol_conf.filter_relative) {\r\nnr_samples = hists->stats.nr_non_filtered_samples;\r\nnr_events = hists->stats.total_non_filtered_period;\r\n}\r\nif (perf_evsel__is_group_event(evsel)) {\r\nstruct perf_evsel *pos;\r\nperf_evsel__group_desc(evsel, buf, buflen);\r\nev_name = buf;\r\nfor_each_group_member(pos, evsel) {\r\nstruct hists *pos_hists = evsel__hists(pos);\r\nif (symbol_conf.filter_relative) {\r\nnr_samples += pos_hists->stats.nr_non_filtered_samples;\r\nnr_events += pos_hists->stats.total_non_filtered_period;\r\n} else {\r\nnr_samples += pos_hists->stats.nr_events[PERF_RECORD_SAMPLE];\r\nnr_events += pos_hists->stats.total_period;\r\n}\r\n}\r\n}\r\nnr_samples = convert_unit(nr_samples, &unit);\r\nprinted = scnprintf(bf, size,\r\n"Samples: %lu%c of event '%s', Event count (approx.): %" PRIu64,\r\nnr_samples, unit, ev_name, nr_events);\r\nif (hists->uid_filter_str)\r\nprinted += snprintf(bf + printed, size - printed,\r\n", UID: %s", hists->uid_filter_str);\r\nif (thread)\r\nprinted += scnprintf(bf + printed, size - printed,\r\n", Thread: %s(%d)",\r\n(thread->comm_set ? thread__comm_str(thread) : ""),\r\nthread->tid);\r\nif (dso)\r\nprinted += scnprintf(bf + printed, size - printed,\r\n", DSO: %s", dso->short_name);\r\nif (!is_report_browser(hbt)) {\r\nstruct perf_top *top = hbt->arg;\r\nif (top->zero)\r\nprinted += scnprintf(bf + printed, size - printed, " [z]");\r\n}\r\nreturn printed;\r\n}\r\nstatic inline void free_popup_options(char **options, int n)\r\n{\r\nint i;\r\nfor (i = 0; i < n; ++i)\r\nzfree(&options[i]);\r\n}\r\nstatic int switch_data_file(void)\r\n{\r\nchar *pwd, *options[32], *abs_path[32], *tmp;\r\nDIR *pwd_dir;\r\nint nr_options = 0, choice = -1, ret = -1;\r\nstruct dirent *dent;\r\npwd = getenv("PWD");\r\nif (!pwd)\r\nreturn ret;\r\npwd_dir = opendir(pwd);\r\nif (!pwd_dir)\r\nreturn ret;\r\nmemset(options, 0, sizeof(options));\r\nmemset(options, 0, sizeof(abs_path));\r\nwhile ((dent = readdir(pwd_dir))) {\r\nchar path[PATH_MAX];\r\nu64 magic;\r\nchar *name = dent->d_name;\r\nFILE *file;\r\nif (!(dent->d_type == DT_REG))\r\ncontinue;\r\nsnprintf(path, sizeof(path), "%s/%s", pwd, name);\r\nfile = fopen(path, "r");\r\nif (!file)\r\ncontinue;\r\nif (fread(&magic, 1, 8, file) < 8)\r\ngoto close_file_and_continue;\r\nif (is_perf_magic(magic)) {\r\noptions[nr_options] = strdup(name);\r\nif (!options[nr_options])\r\ngoto close_file_and_continue;\r\nabs_path[nr_options] = strdup(path);\r\nif (!abs_path[nr_options]) {\r\nzfree(&options[nr_options]);\r\nui__warning("Can't search all data files due to memory shortage.\n");\r\nfclose(file);\r\nbreak;\r\n}\r\nnr_options++;\r\n}\r\nclose_file_and_continue:\r\nfclose(file);\r\nif (nr_options >= 32) {\r\nui__warning("Too many perf data files in PWD!\n"\r\n"Only the first 32 files will be listed.\n");\r\nbreak;\r\n}\r\n}\r\nclosedir(pwd_dir);\r\nif (nr_options) {\r\nchoice = ui__popup_menu(nr_options, options);\r\nif (choice < nr_options && choice >= 0) {\r\ntmp = strdup(abs_path[choice]);\r\nif (tmp) {\r\nif (is_input_name_malloced)\r\nfree((void *)input_name);\r\ninput_name = tmp;\r\nis_input_name_malloced = true;\r\nret = 0;\r\n} else\r\nui__warning("Data switch failed due to memory shortage!\n");\r\n}\r\n}\r\nfree_popup_options(options, nr_options);\r\nfree_popup_options(abs_path, nr_options);\r\nreturn ret;\r\n}\r\nstatic void hist_browser__update_nr_entries(struct hist_browser *hb)\r\n{\r\nu64 nr_entries = 0;\r\nstruct rb_node *nd = rb_first(&hb->hists->entries);\r\nif (hb->min_pcnt == 0) {\r\nhb->nr_non_filtered_entries = hb->hists->nr_non_filtered_entries;\r\nreturn;\r\n}\r\nwhile ((nd = hists__filter_entries(nd, hb->min_pcnt)) != NULL) {\r\nnr_entries++;\r\nnd = rb_next(nd);\r\n}\r\nhb->nr_non_filtered_entries = nr_entries;\r\n}\r\nstatic int perf_evsel__hists_browse(struct perf_evsel *evsel, int nr_events,\r\nconst char *helpline,\r\nbool left_exits,\r\nstruct hist_browser_timer *hbt,\r\nfloat min_pcnt,\r\nstruct perf_session_env *env)\r\n{\r\nstruct hists *hists = evsel__hists(evsel);\r\nstruct hist_browser *browser = hist_browser__new(hists);\r\nstruct branch_info *bi;\r\nstruct pstack *fstack;\r\nchar *options[16];\r\nint nr_options = 0;\r\nint key = -1;\r\nchar buf[64];\r\nchar script_opt[64];\r\nint delay_secs = hbt ? hbt->refresh : 0;\r\nstruct perf_hpp_fmt *fmt;\r\n#define HIST_BROWSER_HELP_COMMON \\r\n"h/?/F1 Show this window\n" \\r\n"UP/DOWN/PGUP\n" \\r\n"PGDN/SPACE Navigate\n" \\r\n"q/ESC/CTRL+C Exit browser\n\n" \\r\n"For multiple event sessions:\n\n" \\r\n"TAB/UNTAB Switch events\n\n" \\r\n"For symbolic views (--sort has sym):\n\n" \\r\n"-> Zoom into DSO/Threads & Annotate current symbol\n" \\r\n"<- Zoom out\n" \\r\n"a Annotate current symbol\n" \\r\n"C Collapse all callchains\n" \\r\n"d Zoom into current DSO\n" \\r\n"E Expand all callchains\n" \\r\n"F Toggle percentage of filtered entries\n" \\r\n"H Display column headers\n" \\r\nconst char report_help[] = HIST_BROWSER_HELP_COMMON\r\n"i Show header information\n"\r\n"P Print histograms to perf.hist.N\n"\r\n"r Run available scripts\n"\r\n"s Switch to another data file in PWD\n"\r\n"t Zoom into current Thread\n"\r\n"V Verbose (DSO names in callchains, etc)\n"\r\n"/ Filter symbol by name";\r\nconst char top_help[] = HIST_BROWSER_HELP_COMMON\r\n"P Print histograms to perf.hist.N\n"\r\n"t Zoom into current Thread\n"\r\n"V Verbose (DSO names in callchains, etc)\n"\r\n"z Toggle zeroing of samples\n"\r\n"/ Filter symbol by name";\r\nif (browser == NULL)\r\nreturn -1;\r\nif (min_pcnt) {\r\nbrowser->min_pcnt = min_pcnt;\r\nhist_browser__update_nr_entries(browser);\r\n}\r\nfstack = pstack__new(2);\r\nif (fstack == NULL)\r\ngoto out;\r\nui_helpline__push(helpline);\r\nmemset(options, 0, sizeof(options));\r\nperf_hpp__for_each_format(fmt)\r\nperf_hpp__reset_width(fmt, hists);\r\nif (symbol_conf.col_width_list_str)\r\nperf_hpp__set_user_width(symbol_conf.col_width_list_str);\r\nwhile (1) {\r\nconst struct thread *thread = NULL;\r\nconst struct dso *dso = NULL;\r\nint choice = 0,\r\nannotate = -2, zoom_dso = -2, zoom_thread = -2,\r\nannotate_f = -2, annotate_t = -2, browse_map = -2;\r\nint scripts_comm = -2, scripts_symbol = -2,\r\nscripts_all = -2, switch_data = -2;\r\nnr_options = 0;\r\nkey = hist_browser__run(browser, hbt);\r\nif (browser->he_selection != NULL) {\r\nthread = hist_browser__selected_thread(browser);\r\ndso = browser->selection->map ? browser->selection->map->dso : NULL;\r\n}\r\nswitch (key) {\r\ncase K_TAB:\r\ncase K_UNTAB:\r\nif (nr_events == 1)\r\ncontinue;\r\ngoto out_free_stack;\r\ncase 'a':\r\nif (!sort__has_sym) {\r\nui_browser__warning(&browser->b, delay_secs * 2,\r\n"Annotation is only available for symbolic views, "\r\n"include \"sym*\" in --sort to use it.");\r\ncontinue;\r\n}\r\nif (browser->selection == NULL ||\r\nbrowser->selection->sym == NULL ||\r\nbrowser->selection->map->dso->annotate_warned)\r\ncontinue;\r\ngoto do_annotate;\r\ncase 'P':\r\nhist_browser__dump(browser);\r\ncontinue;\r\ncase 'd':\r\ngoto zoom_dso;\r\ncase 'V':\r\nbrowser->show_dso = !browser->show_dso;\r\ncontinue;\r\ncase 't':\r\ngoto zoom_thread;\r\ncase '/':\r\nif (ui_browser__input_window("Symbol to show",\r\n"Please enter the name of symbol you want to see",\r\nbuf, "ENTER: OK, ESC: Cancel",\r\ndelay_secs * 2) == K_ENTER) {\r\nhists->symbol_filter_str = *buf ? buf : NULL;\r\nhists__filter_by_symbol(hists);\r\nhist_browser__reset(browser);\r\n}\r\ncontinue;\r\ncase 'r':\r\nif (is_report_browser(hbt))\r\ngoto do_scripts;\r\ncontinue;\r\ncase 's':\r\nif (is_report_browser(hbt))\r\ngoto do_data_switch;\r\ncontinue;\r\ncase 'i':\r\nif (env->arch)\r\ntui__header_window(env);\r\ncontinue;\r\ncase 'F':\r\nsymbol_conf.filter_relative ^= 1;\r\ncontinue;\r\ncase 'z':\r\nif (!is_report_browser(hbt)) {\r\nstruct perf_top *top = hbt->arg;\r\ntop->zero = !top->zero;\r\n}\r\ncontinue;\r\ncase K_F1:\r\ncase 'h':\r\ncase '?':\r\nui_browser__help_window(&browser->b,\r\nis_report_browser(hbt) ? report_help : top_help);\r\ncontinue;\r\ncase K_ENTER:\r\ncase K_RIGHT:\r\nbreak;\r\ncase K_LEFT: {\r\nconst void *top;\r\nif (pstack__empty(fstack)) {\r\nif (left_exits)\r\ngoto out_free_stack;\r\ncontinue;\r\n}\r\ntop = pstack__pop(fstack);\r\nif (top == &browser->hists->dso_filter)\r\ngoto zoom_out_dso;\r\nif (top == &browser->hists->thread_filter)\r\ngoto zoom_out_thread;\r\ncontinue;\r\n}\r\ncase K_ESC:\r\nif (!left_exits &&\r\n!ui_browser__dialog_yesno(&browser->b,\r\n"Do you really want to exit?"))\r\ncontinue;\r\ncase 'q':\r\ncase CTRL('c'):\r\ngoto out_free_stack;\r\ndefault:\r\ncontinue;\r\n}\r\nif (!sort__has_sym)\r\ngoto add_exit_option;\r\nif (sort__mode == SORT_MODE__BRANCH) {\r\nbi = browser->he_selection->branch_info;\r\nif (browser->selection != NULL &&\r\nbi &&\r\nbi->from.sym != NULL &&\r\n!bi->from.map->dso->annotate_warned &&\r\nasprintf(&options[nr_options], "Annotate %s",\r\nbi->from.sym->name) > 0)\r\nannotate_f = nr_options++;\r\nif (browser->selection != NULL &&\r\nbi &&\r\nbi->to.sym != NULL &&\r\n!bi->to.map->dso->annotate_warned &&\r\n(bi->to.sym != bi->from.sym ||\r\nbi->to.map->dso != bi->from.map->dso) &&\r\nasprintf(&options[nr_options], "Annotate %s",\r\nbi->to.sym->name) > 0)\r\nannotate_t = nr_options++;\r\n} else {\r\nif (browser->selection != NULL &&\r\nbrowser->selection->sym != NULL &&\r\n!browser->selection->map->dso->annotate_warned) {\r\nstruct annotation *notes;\r\nnotes = symbol__annotation(browser->selection->sym);\r\nif (notes->src &&\r\nasprintf(&options[nr_options], "Annotate %s",\r\nbrowser->selection->sym->name) > 0)\r\nannotate = nr_options++;\r\n}\r\n}\r\nif (thread != NULL &&\r\nasprintf(&options[nr_options], "Zoom %s %s(%d) thread",\r\n(browser->hists->thread_filter ? "out of" : "into"),\r\n(thread->comm_set ? thread__comm_str(thread) : ""),\r\nthread->tid) > 0)\r\nzoom_thread = nr_options++;\r\nif (dso != NULL &&\r\nasprintf(&options[nr_options], "Zoom %s %s DSO",\r\n(browser->hists->dso_filter ? "out of" : "into"),\r\n(dso->kernel ? "the Kernel" : dso->short_name)) > 0)\r\nzoom_dso = nr_options++;\r\nif (browser->selection != NULL &&\r\nbrowser->selection->map != NULL &&\r\nasprintf(&options[nr_options], "Browse map details") > 0)\r\nbrowse_map = nr_options++;\r\nif (browser->he_selection) {\r\nstruct symbol *sym;\r\nif (asprintf(&options[nr_options], "Run scripts for samples of thread [%s]",\r\nthread__comm_str(browser->he_selection->thread)) > 0)\r\nscripts_comm = nr_options++;\r\nsym = browser->he_selection->ms.sym;\r\nif (sym && sym->namelen &&\r\nasprintf(&options[nr_options], "Run scripts for samples of symbol [%s]",\r\nsym->name) > 0)\r\nscripts_symbol = nr_options++;\r\n}\r\nif (asprintf(&options[nr_options], "Run scripts for all samples") > 0)\r\nscripts_all = nr_options++;\r\nif (is_report_browser(hbt) && asprintf(&options[nr_options],\r\n"Switch to another data file in PWD") > 0)\r\nswitch_data = nr_options++;\r\nadd_exit_option:\r\noptions[nr_options++] = (char *)"Exit";\r\nretry_popup_menu:\r\nchoice = ui__popup_menu(nr_options, options);\r\nif (choice == nr_options - 1)\r\nbreak;\r\nif (choice == -1) {\r\nfree_popup_options(options, nr_options - 1);\r\ncontinue;\r\n}\r\nif (choice == annotate || choice == annotate_t || choice == annotate_f) {\r\nstruct hist_entry *he;\r\nstruct annotation *notes;\r\nint err;\r\ndo_annotate:\r\nif (!objdump_path && perf_session_env__lookup_objdump(env))\r\ncontinue;\r\nhe = hist_browser__selected_entry(browser);\r\nif (he == NULL)\r\ncontinue;\r\nif (choice == annotate_f) {\r\nhe->ms.sym = he->branch_info->from.sym;\r\nhe->ms.map = he->branch_info->from.map;\r\n} else if (choice == annotate_t) {\r\nhe->ms.sym = he->branch_info->to.sym;\r\nhe->ms.map = he->branch_info->to.map;\r\n}\r\nnotes = symbol__annotation(he->ms.sym);\r\nif (!notes->src)\r\ncontinue;\r\nhe->used = true;\r\nerr = hist_entry__tui_annotate(he, evsel, hbt);\r\nhe->used = false;\r\nif ((err == 'q' || err == CTRL('c'))\r\n&& annotate_t != -2 && annotate_f != -2)\r\ngoto retry_popup_menu;\r\nui_browser__update_nr_entries(&browser->b, browser->hists->nr_entries);\r\nif (err)\r\nui_browser__handle_resize(&browser->b);\r\n} else if (choice == browse_map)\r\nmap__browse(browser->selection->map);\r\nelse if (choice == zoom_dso) {\r\nzoom_dso:\r\nif (browser->hists->dso_filter) {\r\npstack__remove(fstack, &browser->hists->dso_filter);\r\nzoom_out_dso:\r\nui_helpline__pop();\r\nbrowser->hists->dso_filter = NULL;\r\nperf_hpp__set_elide(HISTC_DSO, false);\r\n} else {\r\nif (dso == NULL)\r\ncontinue;\r\nui_helpline__fpush("To zoom out press <- or -> + \"Zoom out of %s DSO\"",\r\ndso->kernel ? "the Kernel" : dso->short_name);\r\nbrowser->hists->dso_filter = dso;\r\nperf_hpp__set_elide(HISTC_DSO, true);\r\npstack__push(fstack, &browser->hists->dso_filter);\r\n}\r\nhists__filter_by_dso(hists);\r\nhist_browser__reset(browser);\r\n} else if (choice == zoom_thread) {\r\nzoom_thread:\r\nif (browser->hists->thread_filter) {\r\npstack__remove(fstack, &browser->hists->thread_filter);\r\nzoom_out_thread:\r\nui_helpline__pop();\r\nbrowser->hists->thread_filter = NULL;\r\nperf_hpp__set_elide(HISTC_THREAD, false);\r\n} else {\r\nui_helpline__fpush("To zoom out press <- or -> + \"Zoom out of %s(%d) thread\"",\r\nthread->comm_set ? thread__comm_str(thread) : "",\r\nthread->tid);\r\nbrowser->hists->thread_filter = thread;\r\nperf_hpp__set_elide(HISTC_THREAD, false);\r\npstack__push(fstack, &browser->hists->thread_filter);\r\n}\r\nhists__filter_by_thread(hists);\r\nhist_browser__reset(browser);\r\n}\r\nelse if (choice == scripts_all || choice == scripts_comm ||\r\nchoice == scripts_symbol) {\r\ndo_scripts:\r\nmemset(script_opt, 0, 64);\r\nif (choice == scripts_comm)\r\nsprintf(script_opt, " -c %s ", thread__comm_str(browser->he_selection->thread));\r\nif (choice == scripts_symbol)\r\nsprintf(script_opt, " -S %s ", browser->he_selection->ms.sym->name);\r\nscript_browse(script_opt);\r\n}\r\nelse if (choice == switch_data) {\r\ndo_data_switch:\r\nif (!switch_data_file()) {\r\nkey = K_SWITCH_INPUT_DATA;\r\nbreak;\r\n} else\r\nui__warning("Won't switch the data files due to\n"\r\n"no valid data file get selected!\n");\r\n}\r\n}\r\nout_free_stack:\r\npstack__delete(fstack);\r\nout:\r\nhist_browser__delete(browser);\r\nfree_popup_options(options, nr_options - 1);\r\nreturn key;\r\n}\r\nstatic void perf_evsel_menu__write(struct ui_browser *browser,\r\nvoid *entry, int row)\r\n{\r\nstruct perf_evsel_menu *menu = container_of(browser,\r\nstruct perf_evsel_menu, b);\r\nstruct perf_evsel *evsel = list_entry(entry, struct perf_evsel, node);\r\nstruct hists *hists = evsel__hists(evsel);\r\nbool current_entry = ui_browser__is_current_entry(browser, row);\r\nunsigned long nr_events = hists->stats.nr_events[PERF_RECORD_SAMPLE];\r\nconst char *ev_name = perf_evsel__name(evsel);\r\nchar bf[256], unit;\r\nconst char *warn = " ";\r\nsize_t printed;\r\nui_browser__set_color(browser, current_entry ? HE_COLORSET_SELECTED :\r\nHE_COLORSET_NORMAL);\r\nif (perf_evsel__is_group_event(evsel)) {\r\nstruct perf_evsel *pos;\r\nev_name = perf_evsel__group_name(evsel);\r\nfor_each_group_member(pos, evsel) {\r\nstruct hists *pos_hists = evsel__hists(pos);\r\nnr_events += pos_hists->stats.nr_events[PERF_RECORD_SAMPLE];\r\n}\r\n}\r\nnr_events = convert_unit(nr_events, &unit);\r\nprinted = scnprintf(bf, sizeof(bf), "%lu%c%s%s", nr_events,\r\nunit, unit == ' ' ? "" : " ", ev_name);\r\nslsmg_printf("%s", bf);\r\nnr_events = hists->stats.nr_events[PERF_RECORD_LOST];\r\nif (nr_events != 0) {\r\nmenu->lost_events = true;\r\nif (!current_entry)\r\nui_browser__set_color(browser, HE_COLORSET_TOP);\r\nnr_events = convert_unit(nr_events, &unit);\r\nprinted += scnprintf(bf, sizeof(bf), ": %ld%c%schunks LOST!",\r\nnr_events, unit, unit == ' ' ? "" : " ");\r\nwarn = bf;\r\n}\r\nslsmg_write_nstring(warn, browser->width - printed);\r\nif (current_entry)\r\nmenu->selection = evsel;\r\n}\r\nstatic int perf_evsel_menu__run(struct perf_evsel_menu *menu,\r\nint nr_events, const char *help,\r\nstruct hist_browser_timer *hbt)\r\n{\r\nstruct perf_evlist *evlist = menu->b.priv;\r\nstruct perf_evsel *pos;\r\nconst char *title = "Available samples";\r\nint delay_secs = hbt ? hbt->refresh : 0;\r\nint key;\r\nif (ui_browser__show(&menu->b, title,\r\n"ESC: exit, ENTER|->: Browse histograms") < 0)\r\nreturn -1;\r\nwhile (1) {\r\nkey = ui_browser__run(&menu->b, delay_secs);\r\nswitch (key) {\r\ncase K_TIMER:\r\nhbt->timer(hbt->arg);\r\nif (!menu->lost_events_warned && menu->lost_events) {\r\nui_browser__warn_lost_events(&menu->b);\r\nmenu->lost_events_warned = true;\r\n}\r\ncontinue;\r\ncase K_RIGHT:\r\ncase K_ENTER:\r\nif (!menu->selection)\r\ncontinue;\r\npos = menu->selection;\r\nbrowse_hists:\r\nperf_evlist__set_selected(evlist, pos);\r\nif (hbt)\r\nhbt->timer(hbt->arg);\r\nkey = perf_evsel__hists_browse(pos, nr_events, help,\r\ntrue, hbt,\r\nmenu->min_pcnt,\r\nmenu->env);\r\nui_browser__show_title(&menu->b, title);\r\nswitch (key) {\r\ncase K_TAB:\r\nif (pos->node.next == &evlist->entries)\r\npos = perf_evlist__first(evlist);\r\nelse\r\npos = perf_evsel__next(pos);\r\ngoto browse_hists;\r\ncase K_UNTAB:\r\nif (pos->node.prev == &evlist->entries)\r\npos = perf_evlist__last(evlist);\r\nelse\r\npos = perf_evsel__prev(pos);\r\ngoto browse_hists;\r\ncase K_ESC:\r\nif (!ui_browser__dialog_yesno(&menu->b,\r\n"Do you really want to exit?"))\r\ncontinue;\r\ncase K_SWITCH_INPUT_DATA:\r\ncase 'q':\r\ncase CTRL('c'):\r\ngoto out;\r\ndefault:\r\ncontinue;\r\n}\r\ncase K_LEFT:\r\ncontinue;\r\ncase K_ESC:\r\nif (!ui_browser__dialog_yesno(&menu->b,\r\n"Do you really want to exit?"))\r\ncontinue;\r\ncase 'q':\r\ncase CTRL('c'):\r\ngoto out;\r\ndefault:\r\ncontinue;\r\n}\r\n}\r\nout:\r\nui_browser__hide(&menu->b);\r\nreturn key;\r\n}\r\nstatic bool filter_group_entries(struct ui_browser *browser __maybe_unused,\r\nvoid *entry)\r\n{\r\nstruct perf_evsel *evsel = list_entry(entry, struct perf_evsel, node);\r\nif (symbol_conf.event_group && !perf_evsel__is_group_leader(evsel))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int __perf_evlist__tui_browse_hists(struct perf_evlist *evlist,\r\nint nr_entries, const char *help,\r\nstruct hist_browser_timer *hbt,\r\nfloat min_pcnt,\r\nstruct perf_session_env *env)\r\n{\r\nstruct perf_evsel *pos;\r\nstruct perf_evsel_menu menu = {\r\n.b = {\r\n.entries = &evlist->entries,\r\n.refresh = ui_browser__list_head_refresh,\r\n.seek = ui_browser__list_head_seek,\r\n.write = perf_evsel_menu__write,\r\n.filter = filter_group_entries,\r\n.nr_entries = nr_entries,\r\n.priv = evlist,\r\n},\r\n.min_pcnt = min_pcnt,\r\n.env = env,\r\n};\r\nui_helpline__push("Press ESC to exit");\r\nevlist__for_each(evlist, pos) {\r\nconst char *ev_name = perf_evsel__name(pos);\r\nsize_t line_len = strlen(ev_name) + 7;\r\nif (menu.b.width < line_len)\r\nmenu.b.width = line_len;\r\n}\r\nreturn perf_evsel_menu__run(&menu, nr_entries, help, hbt);\r\n}\r\nint perf_evlist__tui_browse_hists(struct perf_evlist *evlist, const char *help,\r\nstruct hist_browser_timer *hbt,\r\nfloat min_pcnt,\r\nstruct perf_session_env *env)\r\n{\r\nint nr_entries = evlist->nr_entries;\r\nsingle_entry:\r\nif (nr_entries == 1) {\r\nstruct perf_evsel *first = perf_evlist__first(evlist);\r\nreturn perf_evsel__hists_browse(first, nr_entries, help,\r\nfalse, hbt, min_pcnt,\r\nenv);\r\n}\r\nif (symbol_conf.event_group) {\r\nstruct perf_evsel *pos;\r\nnr_entries = 0;\r\nevlist__for_each(evlist, pos) {\r\nif (perf_evsel__is_group_leader(pos))\r\nnr_entries++;\r\n}\r\nif (nr_entries == 1)\r\ngoto single_entry;\r\n}\r\nreturn __perf_evlist__tui_browse_hists(evlist, nr_entries, help,\r\nhbt, min_pcnt, env);\r\n}
