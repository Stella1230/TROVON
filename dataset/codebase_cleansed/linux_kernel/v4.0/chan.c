void cfg80211_chandef_create(struct cfg80211_chan_def *chandef,\r\nstruct ieee80211_channel *chan,\r\nenum nl80211_channel_type chan_type)\r\n{\r\nif (WARN_ON(!chan))\r\nreturn;\r\nchandef->chan = chan;\r\nchandef->center_freq2 = 0;\r\nswitch (chan_type) {\r\ncase NL80211_CHAN_NO_HT:\r\nchandef->width = NL80211_CHAN_WIDTH_20_NOHT;\r\nchandef->center_freq1 = chan->center_freq;\r\nbreak;\r\ncase NL80211_CHAN_HT20:\r\nchandef->width = NL80211_CHAN_WIDTH_20;\r\nchandef->center_freq1 = chan->center_freq;\r\nbreak;\r\ncase NL80211_CHAN_HT40PLUS:\r\nchandef->width = NL80211_CHAN_WIDTH_40;\r\nchandef->center_freq1 = chan->center_freq + 10;\r\nbreak;\r\ncase NL80211_CHAN_HT40MINUS:\r\nchandef->width = NL80211_CHAN_WIDTH_40;\r\nchandef->center_freq1 = chan->center_freq - 10;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\n}\r\nbool cfg80211_chandef_valid(const struct cfg80211_chan_def *chandef)\r\n{\r\nu32 control_freq;\r\nif (!chandef->chan)\r\nreturn false;\r\ncontrol_freq = chandef->chan->center_freq;\r\nswitch (chandef->width) {\r\ncase NL80211_CHAN_WIDTH_5:\r\ncase NL80211_CHAN_WIDTH_10:\r\ncase NL80211_CHAN_WIDTH_20:\r\ncase NL80211_CHAN_WIDTH_20_NOHT:\r\nif (chandef->center_freq1 != control_freq)\r\nreturn false;\r\nif (chandef->center_freq2)\r\nreturn false;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_40:\r\nif (chandef->center_freq1 != control_freq + 10 &&\r\nchandef->center_freq1 != control_freq - 10)\r\nreturn false;\r\nif (chandef->center_freq2)\r\nreturn false;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_80P80:\r\nif (chandef->center_freq1 != control_freq + 30 &&\r\nchandef->center_freq1 != control_freq + 10 &&\r\nchandef->center_freq1 != control_freq - 10 &&\r\nchandef->center_freq1 != control_freq - 30)\r\nreturn false;\r\nif (!chandef->center_freq2)\r\nreturn false;\r\nif (chandef->center_freq1 - chandef->center_freq2 == 80 ||\r\nchandef->center_freq2 - chandef->center_freq1 == 80)\r\nreturn false;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_80:\r\nif (chandef->center_freq1 != control_freq + 30 &&\r\nchandef->center_freq1 != control_freq + 10 &&\r\nchandef->center_freq1 != control_freq - 10 &&\r\nchandef->center_freq1 != control_freq - 30)\r\nreturn false;\r\nif (chandef->center_freq2)\r\nreturn false;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_160:\r\nif (chandef->center_freq1 != control_freq + 70 &&\r\nchandef->center_freq1 != control_freq + 50 &&\r\nchandef->center_freq1 != control_freq + 30 &&\r\nchandef->center_freq1 != control_freq + 10 &&\r\nchandef->center_freq1 != control_freq - 10 &&\r\nchandef->center_freq1 != control_freq - 30 &&\r\nchandef->center_freq1 != control_freq - 50 &&\r\nchandef->center_freq1 != control_freq - 70)\r\nreturn false;\r\nif (chandef->center_freq2)\r\nreturn false;\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void chandef_primary_freqs(const struct cfg80211_chan_def *c,\r\nu32 *pri40, u32 *pri80)\r\n{\r\nint tmp;\r\nswitch (c->width) {\r\ncase NL80211_CHAN_WIDTH_40:\r\n*pri40 = c->center_freq1;\r\n*pri80 = 0;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_80:\r\ncase NL80211_CHAN_WIDTH_80P80:\r\n*pri80 = c->center_freq1;\r\ntmp = (30 + c->chan->center_freq - c->center_freq1)/20;\r\ntmp /= 2;\r\n*pri40 = c->center_freq1 - 20 + 40 * tmp;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_160:\r\ntmp = (70 + c->chan->center_freq - c->center_freq1)/20;\r\ntmp /= 2;\r\n*pri40 = c->center_freq1 - 60 + 40 * tmp;\r\ntmp /= 2;\r\n*pri80 = c->center_freq1 - 40 + 80 * tmp;\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\n}\r\n}\r\nstatic int cfg80211_chandef_get_width(const struct cfg80211_chan_def *c)\r\n{\r\nint width;\r\nswitch (c->width) {\r\ncase NL80211_CHAN_WIDTH_5:\r\nwidth = 5;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_10:\r\nwidth = 10;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_20:\r\ncase NL80211_CHAN_WIDTH_20_NOHT:\r\nwidth = 20;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_40:\r\nwidth = 40;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_80P80:\r\ncase NL80211_CHAN_WIDTH_80:\r\nwidth = 80;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_160:\r\nwidth = 160;\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nreturn -1;\r\n}\r\nreturn width;\r\n}\r\nconst struct cfg80211_chan_def *\r\ncfg80211_chandef_compatible(const struct cfg80211_chan_def *c1,\r\nconst struct cfg80211_chan_def *c2)\r\n{\r\nu32 c1_pri40, c1_pri80, c2_pri40, c2_pri80;\r\nif (cfg80211_chandef_identical(c1, c2))\r\nreturn c1;\r\nif (c1->chan != c2->chan)\r\nreturn NULL;\r\nif (c1->width == c2->width)\r\nreturn NULL;\r\nif (c1->width == NL80211_CHAN_WIDTH_5 ||\r\nc1->width == NL80211_CHAN_WIDTH_10 ||\r\nc2->width == NL80211_CHAN_WIDTH_5 ||\r\nc2->width == NL80211_CHAN_WIDTH_10)\r\nreturn NULL;\r\nif (c1->width == NL80211_CHAN_WIDTH_20_NOHT ||\r\nc1->width == NL80211_CHAN_WIDTH_20)\r\nreturn c2;\r\nif (c2->width == NL80211_CHAN_WIDTH_20_NOHT ||\r\nc2->width == NL80211_CHAN_WIDTH_20)\r\nreturn c1;\r\nchandef_primary_freqs(c1, &c1_pri40, &c1_pri80);\r\nchandef_primary_freqs(c2, &c2_pri40, &c2_pri80);\r\nif (c1_pri40 != c2_pri40)\r\nreturn NULL;\r\nWARN_ON(!c1_pri80 && !c2_pri80);\r\nif (c1_pri80 && c2_pri80 && c1_pri80 != c2_pri80)\r\nreturn NULL;\r\nif (c1->width > c2->width)\r\nreturn c1;\r\nreturn c2;\r\n}\r\nstatic void cfg80211_set_chans_dfs_state(struct wiphy *wiphy, u32 center_freq,\r\nu32 bandwidth,\r\nenum nl80211_dfs_state dfs_state)\r\n{\r\nstruct ieee80211_channel *c;\r\nu32 freq;\r\nfor (freq = center_freq - bandwidth/2 + 10;\r\nfreq <= center_freq + bandwidth/2 - 10;\r\nfreq += 20) {\r\nc = ieee80211_get_channel(wiphy, freq);\r\nif (!c || !(c->flags & IEEE80211_CHAN_RADAR))\r\ncontinue;\r\nc->dfs_state = dfs_state;\r\nc->dfs_state_entered = jiffies;\r\n}\r\n}\r\nvoid cfg80211_set_dfs_state(struct wiphy *wiphy,\r\nconst struct cfg80211_chan_def *chandef,\r\nenum nl80211_dfs_state dfs_state)\r\n{\r\nint width;\r\nif (WARN_ON(!cfg80211_chandef_valid(chandef)))\r\nreturn;\r\nwidth = cfg80211_chandef_get_width(chandef);\r\nif (width < 0)\r\nreturn;\r\ncfg80211_set_chans_dfs_state(wiphy, chandef->center_freq1,\r\nwidth, dfs_state);\r\nif (!chandef->center_freq2)\r\nreturn;\r\ncfg80211_set_chans_dfs_state(wiphy, chandef->center_freq2,\r\nwidth, dfs_state);\r\n}\r\nstatic u32 cfg80211_get_start_freq(u32 center_freq,\r\nu32 bandwidth)\r\n{\r\nu32 start_freq;\r\nif (bandwidth <= 20)\r\nstart_freq = center_freq;\r\nelse\r\nstart_freq = center_freq - bandwidth/2 + 10;\r\nreturn start_freq;\r\n}\r\nstatic u32 cfg80211_get_end_freq(u32 center_freq,\r\nu32 bandwidth)\r\n{\r\nu32 end_freq;\r\nif (bandwidth <= 20)\r\nend_freq = center_freq;\r\nelse\r\nend_freq = center_freq + bandwidth/2 - 10;\r\nreturn end_freq;\r\n}\r\nstatic int cfg80211_get_chans_dfs_required(struct wiphy *wiphy,\r\nu32 center_freq,\r\nu32 bandwidth)\r\n{\r\nstruct ieee80211_channel *c;\r\nu32 freq, start_freq, end_freq;\r\nstart_freq = cfg80211_get_start_freq(center_freq, bandwidth);\r\nend_freq = cfg80211_get_end_freq(center_freq, bandwidth);\r\nfor (freq = start_freq; freq <= end_freq; freq += 20) {\r\nc = ieee80211_get_channel(wiphy, freq);\r\nif (!c)\r\nreturn -EINVAL;\r\nif (c->flags & IEEE80211_CHAN_RADAR)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint cfg80211_chandef_dfs_required(struct wiphy *wiphy,\r\nconst struct cfg80211_chan_def *chandef,\r\nenum nl80211_iftype iftype)\r\n{\r\nint width;\r\nint ret;\r\nif (WARN_ON(!cfg80211_chandef_valid(chandef)))\r\nreturn -EINVAL;\r\nswitch (iftype) {\r\ncase NL80211_IFTYPE_ADHOC:\r\ncase NL80211_IFTYPE_AP:\r\ncase NL80211_IFTYPE_P2P_GO:\r\ncase NL80211_IFTYPE_MESH_POINT:\r\nwidth = cfg80211_chandef_get_width(chandef);\r\nif (width < 0)\r\nreturn -EINVAL;\r\nret = cfg80211_get_chans_dfs_required(wiphy,\r\nchandef->center_freq1,\r\nwidth);\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret > 0)\r\nreturn BIT(chandef->width);\r\nif (!chandef->center_freq2)\r\nreturn 0;\r\nret = cfg80211_get_chans_dfs_required(wiphy,\r\nchandef->center_freq2,\r\nwidth);\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret > 0)\r\nreturn BIT(chandef->width);\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\ncase NL80211_IFTYPE_OCB:\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\ncase NL80211_IFTYPE_MONITOR:\r\ncase NL80211_IFTYPE_AP_VLAN:\r\ncase NL80211_IFTYPE_WDS:\r\ncase NL80211_IFTYPE_P2P_DEVICE:\r\nbreak;\r\ncase NL80211_IFTYPE_UNSPECIFIED:\r\ncase NUM_NL80211_IFTYPES:\r\nWARN_ON(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cfg80211_get_chans_dfs_usable(struct wiphy *wiphy,\r\nu32 center_freq,\r\nu32 bandwidth)\r\n{\r\nstruct ieee80211_channel *c;\r\nu32 freq, start_freq, end_freq;\r\nint count = 0;\r\nstart_freq = cfg80211_get_start_freq(center_freq, bandwidth);\r\nend_freq = cfg80211_get_end_freq(center_freq, bandwidth);\r\nfor (freq = start_freq; freq <= end_freq; freq += 20) {\r\nc = ieee80211_get_channel(wiphy, freq);\r\nif (!c)\r\nreturn -EINVAL;\r\nif (c->flags & IEEE80211_CHAN_DISABLED)\r\nreturn -EINVAL;\r\nif (c->flags & IEEE80211_CHAN_RADAR) {\r\nif (c->dfs_state == NL80211_DFS_UNAVAILABLE)\r\nreturn -EINVAL;\r\nif (c->dfs_state == NL80211_DFS_USABLE)\r\ncount++;\r\n}\r\n}\r\nreturn count;\r\n}\r\nbool cfg80211_chandef_dfs_usable(struct wiphy *wiphy,\r\nconst struct cfg80211_chan_def *chandef)\r\n{\r\nint width;\r\nint r1, r2 = 0;\r\nif (WARN_ON(!cfg80211_chandef_valid(chandef)))\r\nreturn false;\r\nwidth = cfg80211_chandef_get_width(chandef);\r\nif (width < 0)\r\nreturn false;\r\nr1 = cfg80211_get_chans_dfs_usable(wiphy, chandef->center_freq1,\r\nwidth);\r\nif (r1 < 0)\r\nreturn false;\r\nswitch (chandef->width) {\r\ncase NL80211_CHAN_WIDTH_80P80:\r\nWARN_ON(!chandef->center_freq2);\r\nr2 = cfg80211_get_chans_dfs_usable(wiphy,\r\nchandef->center_freq2,\r\nwidth);\r\nif (r2 < 0)\r\nreturn false;\r\nbreak;\r\ndefault:\r\nWARN_ON(chandef->center_freq2);\r\nbreak;\r\n}\r\nreturn (r1 + r2 > 0);\r\n}\r\nstatic bool cfg80211_get_chans_dfs_available(struct wiphy *wiphy,\r\nu32 center_freq,\r\nu32 bandwidth)\r\n{\r\nstruct ieee80211_channel *c;\r\nu32 freq, start_freq, end_freq;\r\nstart_freq = cfg80211_get_start_freq(center_freq, bandwidth);\r\nend_freq = cfg80211_get_end_freq(center_freq, bandwidth);\r\nfor (freq = start_freq; freq <= end_freq; freq += 20) {\r\nc = ieee80211_get_channel(wiphy, freq);\r\nif (!c)\r\nreturn false;\r\nif (c->flags & IEEE80211_CHAN_DISABLED)\r\nreturn false;\r\nif ((c->flags & IEEE80211_CHAN_RADAR) &&\r\n(c->dfs_state != NL80211_DFS_AVAILABLE))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool cfg80211_chandef_dfs_available(struct wiphy *wiphy,\r\nconst struct cfg80211_chan_def *chandef)\r\n{\r\nint width;\r\nint r;\r\nif (WARN_ON(!cfg80211_chandef_valid(chandef)))\r\nreturn false;\r\nwidth = cfg80211_chandef_get_width(chandef);\r\nif (width < 0)\r\nreturn false;\r\nr = cfg80211_get_chans_dfs_available(wiphy, chandef->center_freq1,\r\nwidth);\r\nif (!r)\r\nreturn r;\r\nswitch (chandef->width) {\r\ncase NL80211_CHAN_WIDTH_80P80:\r\nWARN_ON(!chandef->center_freq2);\r\nr = cfg80211_get_chans_dfs_available(wiphy,\r\nchandef->center_freq2,\r\nwidth);\r\ndefault:\r\nWARN_ON(chandef->center_freq2);\r\nbreak;\r\n}\r\nreturn r;\r\n}\r\nstatic unsigned int cfg80211_get_chans_dfs_cac_time(struct wiphy *wiphy,\r\nu32 center_freq,\r\nu32 bandwidth)\r\n{\r\nstruct ieee80211_channel *c;\r\nu32 start_freq, end_freq, freq;\r\nunsigned int dfs_cac_ms = 0;\r\nstart_freq = cfg80211_get_start_freq(center_freq, bandwidth);\r\nend_freq = cfg80211_get_end_freq(center_freq, bandwidth);\r\nfor (freq = start_freq; freq <= end_freq; freq += 20) {\r\nc = ieee80211_get_channel(wiphy, freq);\r\nif (!c)\r\nreturn 0;\r\nif (c->flags & IEEE80211_CHAN_DISABLED)\r\nreturn 0;\r\nif (!(c->flags & IEEE80211_CHAN_RADAR))\r\ncontinue;\r\nif (c->dfs_cac_ms > dfs_cac_ms)\r\ndfs_cac_ms = c->dfs_cac_ms;\r\n}\r\nreturn dfs_cac_ms;\r\n}\r\nunsigned int\r\ncfg80211_chandef_dfs_cac_time(struct wiphy *wiphy,\r\nconst struct cfg80211_chan_def *chandef)\r\n{\r\nint width;\r\nunsigned int t1 = 0, t2 = 0;\r\nif (WARN_ON(!cfg80211_chandef_valid(chandef)))\r\nreturn 0;\r\nwidth = cfg80211_chandef_get_width(chandef);\r\nif (width < 0)\r\nreturn 0;\r\nt1 = cfg80211_get_chans_dfs_cac_time(wiphy,\r\nchandef->center_freq1,\r\nwidth);\r\nif (!chandef->center_freq2)\r\nreturn t1;\r\nt2 = cfg80211_get_chans_dfs_cac_time(wiphy,\r\nchandef->center_freq2,\r\nwidth);\r\nreturn max(t1, t2);\r\n}\r\nstatic bool cfg80211_secondary_chans_ok(struct wiphy *wiphy,\r\nu32 center_freq, u32 bandwidth,\r\nu32 prohibited_flags)\r\n{\r\nstruct ieee80211_channel *c;\r\nu32 freq, start_freq, end_freq;\r\nstart_freq = cfg80211_get_start_freq(center_freq, bandwidth);\r\nend_freq = cfg80211_get_end_freq(center_freq, bandwidth);\r\nfor (freq = start_freq; freq <= end_freq; freq += 20) {\r\nc = ieee80211_get_channel(wiphy, freq);\r\nif (!c || c->flags & prohibited_flags)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nbool cfg80211_chandef_usable(struct wiphy *wiphy,\r\nconst struct cfg80211_chan_def *chandef,\r\nu32 prohibited_flags)\r\n{\r\nstruct ieee80211_sta_ht_cap *ht_cap;\r\nstruct ieee80211_sta_vht_cap *vht_cap;\r\nu32 width, control_freq, cap;\r\nif (WARN_ON(!cfg80211_chandef_valid(chandef)))\r\nreturn false;\r\nht_cap = &wiphy->bands[chandef->chan->band]->ht_cap;\r\nvht_cap = &wiphy->bands[chandef->chan->band]->vht_cap;\r\ncontrol_freq = chandef->chan->center_freq;\r\nswitch (chandef->width) {\r\ncase NL80211_CHAN_WIDTH_5:\r\nwidth = 5;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_10:\r\nprohibited_flags |= IEEE80211_CHAN_NO_10MHZ;\r\nwidth = 10;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_20:\r\nif (!ht_cap->ht_supported)\r\nreturn false;\r\ncase NL80211_CHAN_WIDTH_20_NOHT:\r\nprohibited_flags |= IEEE80211_CHAN_NO_20MHZ;\r\nwidth = 20;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_40:\r\nwidth = 40;\r\nif (!ht_cap->ht_supported)\r\nreturn false;\r\nif (!(ht_cap->cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40) ||\r\nht_cap->cap & IEEE80211_HT_CAP_40MHZ_INTOLERANT)\r\nreturn false;\r\nif (chandef->center_freq1 < control_freq &&\r\nchandef->chan->flags & IEEE80211_CHAN_NO_HT40MINUS)\r\nreturn false;\r\nif (chandef->center_freq1 > control_freq &&\r\nchandef->chan->flags & IEEE80211_CHAN_NO_HT40PLUS)\r\nreturn false;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_80P80:\r\ncap = vht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;\r\nif (cap != IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ)\r\nreturn false;\r\ncase NL80211_CHAN_WIDTH_80:\r\nif (!vht_cap->vht_supported)\r\nreturn false;\r\nprohibited_flags |= IEEE80211_CHAN_NO_80MHZ;\r\nwidth = 80;\r\nbreak;\r\ncase NL80211_CHAN_WIDTH_160:\r\nif (!vht_cap->vht_supported)\r\nreturn false;\r\ncap = vht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK;\r\nif (cap != IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ &&\r\ncap != IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ)\r\nreturn false;\r\nprohibited_flags |= IEEE80211_CHAN_NO_160MHZ;\r\nwidth = 160;\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nreturn false;\r\n}\r\nif (width > 20)\r\nprohibited_flags |= IEEE80211_CHAN_NO_OFDM;\r\nif (width < 20)\r\nprohibited_flags |= IEEE80211_CHAN_NO_OFDM;\r\nif (!cfg80211_secondary_chans_ok(wiphy, chandef->center_freq1,\r\nwidth, prohibited_flags))\r\nreturn false;\r\nif (!chandef->center_freq2)\r\nreturn true;\r\nreturn cfg80211_secondary_chans_ok(wiphy, chandef->center_freq2,\r\nwidth, prohibited_flags);\r\n}\r\nstatic bool cfg80211_go_permissive_chan(struct cfg80211_registered_device *rdev,\r\nstruct ieee80211_channel *chan)\r\n{\r\nstruct wireless_dev *wdev_iter;\r\nstruct wiphy *wiphy = wiphy_idx_to_wiphy(rdev->wiphy_idx);\r\nASSERT_RTNL();\r\nif (!config_enabled(CONFIG_CFG80211_REG_RELAX_NO_IR) ||\r\n!(wiphy->regulatory_flags & REGULATORY_ENABLE_RELAX_NO_IR))\r\nreturn false;\r\nif (regulatory_indoor_allowed() &&\r\n(chan->flags & IEEE80211_CHAN_INDOOR_ONLY))\r\nreturn true;\r\nif (!(chan->flags & IEEE80211_CHAN_GO_CONCURRENT))\r\nreturn false;\r\nlist_for_each_entry(wdev_iter, &rdev->wdev_list, list) {\r\nstruct ieee80211_channel *other_chan = NULL;\r\nint r1, r2;\r\nif (wdev_iter->iftype != NL80211_IFTYPE_STATION ||\r\n!netif_running(wdev_iter->netdev))\r\ncontinue;\r\nwdev_lock(wdev_iter);\r\nif (wdev_iter->current_bss)\r\nother_chan = wdev_iter->current_bss->pub.channel;\r\nwdev_unlock(wdev_iter);\r\nif (!other_chan)\r\ncontinue;\r\nif (chan == other_chan)\r\nreturn true;\r\nif (chan->band != IEEE80211_BAND_5GHZ)\r\ncontinue;\r\nr1 = cfg80211_get_unii(chan->center_freq);\r\nr2 = cfg80211_get_unii(other_chan->center_freq);\r\nif (r1 != -EINVAL && r1 == r2) {\r\nif (chan->center_freq == 5825 &&\r\nother_chan->center_freq != 5825)\r\ncontinue;\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nbool cfg80211_reg_can_beacon(struct wiphy *wiphy,\r\nstruct cfg80211_chan_def *chandef,\r\nenum nl80211_iftype iftype)\r\n{\r\nstruct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);\r\nbool res;\r\nu32 prohibited_flags = IEEE80211_CHAN_DISABLED |\r\nIEEE80211_CHAN_RADAR;\r\ntrace_cfg80211_reg_can_beacon(wiphy, chandef, iftype);\r\nif (iftype != NL80211_IFTYPE_P2P_GO ||\r\n!cfg80211_go_permissive_chan(rdev, chandef->chan))\r\nprohibited_flags |= IEEE80211_CHAN_NO_IR;\r\nif (cfg80211_chandef_dfs_required(wiphy, chandef, iftype) > 0 &&\r\ncfg80211_chandef_dfs_available(wiphy, chandef)) {\r\nprohibited_flags = IEEE80211_CHAN_DISABLED;\r\n}\r\nres = cfg80211_chandef_usable(wiphy, chandef, prohibited_flags);\r\ntrace_cfg80211_return_bool(res);\r\nreturn res;\r\n}\r\nint cfg80211_set_monitor_channel(struct cfg80211_registered_device *rdev,\r\nstruct cfg80211_chan_def *chandef)\r\n{\r\nif (!rdev->ops->set_monitor_channel)\r\nreturn -EOPNOTSUPP;\r\nif (!cfg80211_has_monitors_only(rdev))\r\nreturn -EBUSY;\r\nreturn rdev_set_monitor_channel(rdev, chandef);\r\n}\r\nvoid\r\ncfg80211_get_chan_state(struct wireless_dev *wdev,\r\nstruct ieee80211_channel **chan,\r\nenum cfg80211_chan_mode *chanmode,\r\nu8 *radar_detect)\r\n{\r\nint ret;\r\n*chan = NULL;\r\n*chanmode = CHAN_MODE_UNDEFINED;\r\nASSERT_WDEV_LOCK(wdev);\r\nif (wdev->netdev && !netif_running(wdev->netdev))\r\nreturn;\r\nswitch (wdev->iftype) {\r\ncase NL80211_IFTYPE_ADHOC:\r\nif (wdev->current_bss) {\r\n*chan = wdev->current_bss->pub.channel;\r\n*chanmode = (wdev->ibss_fixed &&\r\n!wdev->ibss_dfs_possible)\r\n? CHAN_MODE_SHARED\r\n: CHAN_MODE_EXCLUSIVE;\r\nif (wdev->ibss_dfs_possible)\r\n*radar_detect |= BIT(wdev->chandef.width);\r\nreturn;\r\n}\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\nif (wdev->current_bss) {\r\n*chan = wdev->current_bss->pub.channel;\r\n*chanmode = CHAN_MODE_SHARED;\r\nreturn;\r\n}\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\ncase NL80211_IFTYPE_P2P_GO:\r\nif (wdev->cac_started) {\r\n*chan = wdev->chandef.chan;\r\n*chanmode = CHAN_MODE_SHARED;\r\n*radar_detect |= BIT(wdev->chandef.width);\r\n} else if (wdev->beacon_interval) {\r\n*chan = wdev->chandef.chan;\r\n*chanmode = CHAN_MODE_SHARED;\r\nret = cfg80211_chandef_dfs_required(wdev->wiphy,\r\n&wdev->chandef,\r\nwdev->iftype);\r\nWARN_ON(ret < 0);\r\nif (ret > 0)\r\n*radar_detect |= BIT(wdev->chandef.width);\r\n}\r\nreturn;\r\ncase NL80211_IFTYPE_MESH_POINT:\r\nif (wdev->mesh_id_len) {\r\n*chan = wdev->chandef.chan;\r\n*chanmode = CHAN_MODE_SHARED;\r\nret = cfg80211_chandef_dfs_required(wdev->wiphy,\r\n&wdev->chandef,\r\nwdev->iftype);\r\nWARN_ON(ret < 0);\r\nif (ret > 0)\r\n*radar_detect |= BIT(wdev->chandef.width);\r\n}\r\nreturn;\r\ncase NL80211_IFTYPE_OCB:\r\nif (wdev->chandef.chan) {\r\n*chan = wdev->chandef.chan;\r\n*chanmode = CHAN_MODE_SHARED;\r\nreturn;\r\n}\r\nbreak;\r\ncase NL80211_IFTYPE_MONITOR:\r\ncase NL80211_IFTYPE_AP_VLAN:\r\ncase NL80211_IFTYPE_WDS:\r\ncase NL80211_IFTYPE_P2P_DEVICE:\r\nreturn;\r\ncase NL80211_IFTYPE_UNSPECIFIED:\r\ncase NUM_NL80211_IFTYPES:\r\nWARN_ON(1);\r\n}\r\n}
