static int omap_irq_to_gpio(struct gpio_bank *bank, unsigned int gpio_irq)\r\n{\r\nreturn bank->chip.base + gpio_irq;\r\n}\r\nstatic inline struct gpio_bank *omap_irq_data_get_bank(struct irq_data *d)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\r\nreturn container_of(chip, struct gpio_bank, chip);\r\n}\r\nstatic void omap_set_gpio_direction(struct gpio_bank *bank, int gpio,\r\nint is_input)\r\n{\r\nvoid __iomem *reg = bank->base;\r\nu32 l;\r\nreg += bank->regs->direction;\r\nl = readl_relaxed(reg);\r\nif (is_input)\r\nl |= BIT(gpio);\r\nelse\r\nl &= ~(BIT(gpio));\r\nwritel_relaxed(l, reg);\r\nbank->context.oe = l;\r\n}\r\nstatic void omap_set_gpio_dataout_reg(struct gpio_bank *bank, int gpio,\r\nint enable)\r\n{\r\nvoid __iomem *reg = bank->base;\r\nu32 l = GPIO_BIT(bank, gpio);\r\nif (enable) {\r\nreg += bank->regs->set_dataout;\r\nbank->context.dataout |= l;\r\n} else {\r\nreg += bank->regs->clr_dataout;\r\nbank->context.dataout &= ~l;\r\n}\r\nwritel_relaxed(l, reg);\r\n}\r\nstatic void omap_set_gpio_dataout_mask(struct gpio_bank *bank, int gpio,\r\nint enable)\r\n{\r\nvoid __iomem *reg = bank->base + bank->regs->dataout;\r\nu32 gpio_bit = GPIO_BIT(bank, gpio);\r\nu32 l;\r\nl = readl_relaxed(reg);\r\nif (enable)\r\nl |= gpio_bit;\r\nelse\r\nl &= ~gpio_bit;\r\nwritel_relaxed(l, reg);\r\nbank->context.dataout = l;\r\n}\r\nstatic int omap_get_gpio_datain(struct gpio_bank *bank, int offset)\r\n{\r\nvoid __iomem *reg = bank->base + bank->regs->datain;\r\nreturn (readl_relaxed(reg) & (BIT(offset))) != 0;\r\n}\r\nstatic int omap_get_gpio_dataout(struct gpio_bank *bank, int offset)\r\n{\r\nvoid __iomem *reg = bank->base + bank->regs->dataout;\r\nreturn (readl_relaxed(reg) & (BIT(offset))) != 0;\r\n}\r\nstatic inline void omap_gpio_rmw(void __iomem *base, u32 reg, u32 mask, bool set)\r\n{\r\nint l = readl_relaxed(base + reg);\r\nif (set)\r\nl |= mask;\r\nelse\r\nl &= ~mask;\r\nwritel_relaxed(l, base + reg);\r\n}\r\nstatic inline void omap_gpio_dbck_enable(struct gpio_bank *bank)\r\n{\r\nif (bank->dbck_enable_mask && !bank->dbck_enabled) {\r\nclk_prepare_enable(bank->dbck);\r\nbank->dbck_enabled = true;\r\nwritel_relaxed(bank->dbck_enable_mask,\r\nbank->base + bank->regs->debounce_en);\r\n}\r\n}\r\nstatic inline void omap_gpio_dbck_disable(struct gpio_bank *bank)\r\n{\r\nif (bank->dbck_enable_mask && bank->dbck_enabled) {\r\nwritel_relaxed(0, bank->base + bank->regs->debounce_en);\r\nclk_disable_unprepare(bank->dbck);\r\nbank->dbck_enabled = false;\r\n}\r\n}\r\nstatic void omap2_set_gpio_debounce(struct gpio_bank *bank, unsigned gpio,\r\nunsigned debounce)\r\n{\r\nvoid __iomem *reg;\r\nu32 val;\r\nu32 l;\r\nif (!bank->dbck_flag)\r\nreturn;\r\nif (debounce < 32)\r\ndebounce = 0x01;\r\nelse if (debounce > 7936)\r\ndebounce = 0xff;\r\nelse\r\ndebounce = (debounce / 0x1f) - 1;\r\nl = GPIO_BIT(bank, gpio);\r\nclk_prepare_enable(bank->dbck);\r\nreg = bank->base + bank->regs->debounce;\r\nwritel_relaxed(debounce, reg);\r\nreg = bank->base + bank->regs->debounce_en;\r\nval = readl_relaxed(reg);\r\nif (debounce)\r\nval |= l;\r\nelse\r\nval &= ~l;\r\nbank->dbck_enable_mask = val;\r\nwritel_relaxed(val, reg);\r\nclk_disable_unprepare(bank->dbck);\r\nomap_gpio_dbck_enable(bank);\r\nif (bank->dbck_enable_mask) {\r\nbank->context.debounce = debounce;\r\nbank->context.debounce_en = val;\r\n}\r\n}\r\nstatic void omap_clear_gpio_debounce(struct gpio_bank *bank, unsigned gpio)\r\n{\r\nu32 gpio_bit = GPIO_BIT(bank, gpio);\r\nif (!bank->dbck_flag)\r\nreturn;\r\nif (!(bank->dbck_enable_mask & gpio_bit))\r\nreturn;\r\nbank->dbck_enable_mask &= ~gpio_bit;\r\nbank->context.debounce_en &= ~gpio_bit;\r\nwritel_relaxed(bank->context.debounce_en,\r\nbank->base + bank->regs->debounce_en);\r\nif (!bank->dbck_enable_mask) {\r\nbank->context.debounce = 0;\r\nwritel_relaxed(bank->context.debounce, bank->base +\r\nbank->regs->debounce);\r\nclk_disable_unprepare(bank->dbck);\r\nbank->dbck_enabled = false;\r\n}\r\n}\r\nstatic inline void omap_set_gpio_trigger(struct gpio_bank *bank, int gpio,\r\nunsigned trigger)\r\n{\r\nvoid __iomem *base = bank->base;\r\nu32 gpio_bit = BIT(gpio);\r\nomap_gpio_rmw(base, bank->regs->leveldetect0, gpio_bit,\r\ntrigger & IRQ_TYPE_LEVEL_LOW);\r\nomap_gpio_rmw(base, bank->regs->leveldetect1, gpio_bit,\r\ntrigger & IRQ_TYPE_LEVEL_HIGH);\r\nomap_gpio_rmw(base, bank->regs->risingdetect, gpio_bit,\r\ntrigger & IRQ_TYPE_EDGE_RISING);\r\nomap_gpio_rmw(base, bank->regs->fallingdetect, gpio_bit,\r\ntrigger & IRQ_TYPE_EDGE_FALLING);\r\nbank->context.leveldetect0 =\r\nreadl_relaxed(bank->base + bank->regs->leveldetect0);\r\nbank->context.leveldetect1 =\r\nreadl_relaxed(bank->base + bank->regs->leveldetect1);\r\nbank->context.risingdetect =\r\nreadl_relaxed(bank->base + bank->regs->risingdetect);\r\nbank->context.fallingdetect =\r\nreadl_relaxed(bank->base + bank->regs->fallingdetect);\r\nif (likely(!(bank->non_wakeup_gpios & gpio_bit))) {\r\nomap_gpio_rmw(base, bank->regs->wkup_en, gpio_bit, trigger != 0);\r\nbank->context.wake_en =\r\nreadl_relaxed(bank->base + bank->regs->wkup_en);\r\n}\r\nif (!bank->regs->irqctrl) {\r\nif (bank->non_wakeup_gpios) {\r\nif (!(bank->non_wakeup_gpios & gpio_bit))\r\ngoto exit;\r\n}\r\nif (trigger & IRQ_TYPE_EDGE_BOTH)\r\nbank->enabled_non_wakeup_gpios |= gpio_bit;\r\nelse\r\nbank->enabled_non_wakeup_gpios &= ~gpio_bit;\r\n}\r\nexit:\r\nbank->level_mask =\r\nreadl_relaxed(bank->base + bank->regs->leveldetect0) |\r\nreadl_relaxed(bank->base + bank->regs->leveldetect1);\r\n}\r\nstatic void omap_toggle_gpio_edge_triggering(struct gpio_bank *bank, int gpio)\r\n{\r\nvoid __iomem *reg = bank->base;\r\nu32 l = 0;\r\nif (!bank->regs->irqctrl)\r\nreturn;\r\nreg += bank->regs->irqctrl;\r\nl = readl_relaxed(reg);\r\nif ((l >> gpio) & 1)\r\nl &= ~(BIT(gpio));\r\nelse\r\nl |= BIT(gpio);\r\nwritel_relaxed(l, reg);\r\n}\r\nstatic void omap_toggle_gpio_edge_triggering(struct gpio_bank *bank, int gpio) {}\r\nstatic int omap_set_gpio_triggering(struct gpio_bank *bank, int gpio,\r\nunsigned trigger)\r\n{\r\nvoid __iomem *reg = bank->base;\r\nvoid __iomem *base = bank->base;\r\nu32 l = 0;\r\nif (bank->regs->leveldetect0 && bank->regs->wkup_en) {\r\nomap_set_gpio_trigger(bank, gpio, trigger);\r\n} else if (bank->regs->irqctrl) {\r\nreg += bank->regs->irqctrl;\r\nl = readl_relaxed(reg);\r\nif ((trigger & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_EDGE_BOTH)\r\nbank->toggle_mask |= BIT(gpio);\r\nif (trigger & IRQ_TYPE_EDGE_RISING)\r\nl |= BIT(gpio);\r\nelse if (trigger & IRQ_TYPE_EDGE_FALLING)\r\nl &= ~(BIT(gpio));\r\nelse\r\nreturn -EINVAL;\r\nwritel_relaxed(l, reg);\r\n} else if (bank->regs->edgectrl1) {\r\nif (gpio & 0x08)\r\nreg += bank->regs->edgectrl2;\r\nelse\r\nreg += bank->regs->edgectrl1;\r\ngpio &= 0x07;\r\nl = readl_relaxed(reg);\r\nl &= ~(3 << (gpio << 1));\r\nif (trigger & IRQ_TYPE_EDGE_RISING)\r\nl |= 2 << (gpio << 1);\r\nif (trigger & IRQ_TYPE_EDGE_FALLING)\r\nl |= BIT(gpio << 1);\r\nomap_gpio_rmw(base, bank->regs->wkup_en, BIT(gpio), trigger);\r\nbank->context.wake_en =\r\nreadl_relaxed(bank->base + bank->regs->wkup_en);\r\nwritel_relaxed(l, reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_enable_gpio_module(struct gpio_bank *bank, unsigned offset)\r\n{\r\nif (bank->regs->pinctrl) {\r\nvoid __iomem *reg = bank->base + bank->regs->pinctrl;\r\nwritel_relaxed(readl_relaxed(reg) | (BIT(offset)), reg);\r\n}\r\nif (bank->regs->ctrl && !BANK_USED(bank)) {\r\nvoid __iomem *reg = bank->base + bank->regs->ctrl;\r\nu32 ctrl;\r\nctrl = readl_relaxed(reg);\r\nctrl &= ~GPIO_MOD_CTRL_BIT;\r\nwritel_relaxed(ctrl, reg);\r\nbank->context.ctrl = ctrl;\r\n}\r\n}\r\nstatic void omap_disable_gpio_module(struct gpio_bank *bank, unsigned offset)\r\n{\r\nvoid __iomem *base = bank->base;\r\nif (bank->regs->wkup_en &&\r\n!LINE_USED(bank->mod_usage, offset) &&\r\n!LINE_USED(bank->irq_usage, offset)) {\r\nomap_gpio_rmw(base, bank->regs->wkup_en, BIT(offset), 0);\r\nbank->context.wake_en =\r\nreadl_relaxed(bank->base + bank->regs->wkup_en);\r\n}\r\nif (bank->regs->ctrl && !BANK_USED(bank)) {\r\nvoid __iomem *reg = bank->base + bank->regs->ctrl;\r\nu32 ctrl;\r\nctrl = readl_relaxed(reg);\r\nctrl |= GPIO_MOD_CTRL_BIT;\r\nwritel_relaxed(ctrl, reg);\r\nbank->context.ctrl = ctrl;\r\n}\r\n}\r\nstatic int omap_gpio_is_input(struct gpio_bank *bank, int mask)\r\n{\r\nvoid __iomem *reg = bank->base + bank->regs->direction;\r\nreturn readl_relaxed(reg) & mask;\r\n}\r\nstatic void omap_gpio_init_irq(struct gpio_bank *bank, unsigned gpio,\r\nunsigned offset)\r\n{\r\nif (!LINE_USED(bank->mod_usage, offset)) {\r\nomap_enable_gpio_module(bank, offset);\r\nomap_set_gpio_direction(bank, offset, 1);\r\n}\r\nbank->irq_usage |= BIT(GPIO_INDEX(bank, gpio));\r\n}\r\nstatic int omap_gpio_irq_type(struct irq_data *d, unsigned type)\r\n{\r\nstruct gpio_bank *bank = omap_irq_data_get_bank(d);\r\nunsigned gpio = 0;\r\nint retval;\r\nunsigned long flags;\r\nunsigned offset;\r\nif (!BANK_USED(bank))\r\npm_runtime_get_sync(bank->dev);\r\n#ifdef CONFIG_ARCH_OMAP1\r\nif (d->irq > IH_MPUIO_BASE)\r\ngpio = OMAP_MPUIO(d->irq - IH_MPUIO_BASE);\r\n#endif\r\nif (!gpio)\r\ngpio = omap_irq_to_gpio(bank, d->hwirq);\r\nif (type & ~IRQ_TYPE_SENSE_MASK)\r\nreturn -EINVAL;\r\nif (!bank->regs->leveldetect0 &&\r\n(type & (IRQ_TYPE_LEVEL_LOW|IRQ_TYPE_LEVEL_HIGH)))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&bank->lock, flags);\r\noffset = GPIO_INDEX(bank, gpio);\r\nretval = omap_set_gpio_triggering(bank, offset, type);\r\nomap_gpio_init_irq(bank, gpio, offset);\r\nif (!omap_gpio_is_input(bank, BIT(offset))) {\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nif (type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH))\r\n__irq_set_handler_locked(d->irq, handle_level_irq);\r\nelse if (type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\r\n__irq_set_handler_locked(d->irq, handle_edge_irq);\r\nreturn retval;\r\n}\r\nstatic void omap_clear_gpio_irqbank(struct gpio_bank *bank, int gpio_mask)\r\n{\r\nvoid __iomem *reg = bank->base;\r\nreg += bank->regs->irqstatus;\r\nwritel_relaxed(gpio_mask, reg);\r\nif (bank->regs->irqstatus2) {\r\nreg = bank->base + bank->regs->irqstatus2;\r\nwritel_relaxed(gpio_mask, reg);\r\n}\r\nreadl_relaxed(reg);\r\n}\r\nstatic inline void omap_clear_gpio_irqstatus(struct gpio_bank *bank, int gpio)\r\n{\r\nomap_clear_gpio_irqbank(bank, GPIO_BIT(bank, gpio));\r\n}\r\nstatic u32 omap_get_gpio_irqbank_mask(struct gpio_bank *bank)\r\n{\r\nvoid __iomem *reg = bank->base;\r\nu32 l;\r\nu32 mask = (BIT(bank->width)) - 1;\r\nreg += bank->regs->irqenable;\r\nl = readl_relaxed(reg);\r\nif (bank->regs->irqenable_inv)\r\nl = ~l;\r\nl &= mask;\r\nreturn l;\r\n}\r\nstatic void omap_enable_gpio_irqbank(struct gpio_bank *bank, int gpio_mask)\r\n{\r\nvoid __iomem *reg = bank->base;\r\nu32 l;\r\nif (bank->regs->set_irqenable) {\r\nreg += bank->regs->set_irqenable;\r\nl = gpio_mask;\r\nbank->context.irqenable1 |= gpio_mask;\r\n} else {\r\nreg += bank->regs->irqenable;\r\nl = readl_relaxed(reg);\r\nif (bank->regs->irqenable_inv)\r\nl &= ~gpio_mask;\r\nelse\r\nl |= gpio_mask;\r\nbank->context.irqenable1 = l;\r\n}\r\nwritel_relaxed(l, reg);\r\n}\r\nstatic void omap_disable_gpio_irqbank(struct gpio_bank *bank, int gpio_mask)\r\n{\r\nvoid __iomem *reg = bank->base;\r\nu32 l;\r\nif (bank->regs->clr_irqenable) {\r\nreg += bank->regs->clr_irqenable;\r\nl = gpio_mask;\r\nbank->context.irqenable1 &= ~gpio_mask;\r\n} else {\r\nreg += bank->regs->irqenable;\r\nl = readl_relaxed(reg);\r\nif (bank->regs->irqenable_inv)\r\nl |= gpio_mask;\r\nelse\r\nl &= ~gpio_mask;\r\nbank->context.irqenable1 = l;\r\n}\r\nwritel_relaxed(l, reg);\r\n}\r\nstatic inline void omap_set_gpio_irqenable(struct gpio_bank *bank, int gpio,\r\nint enable)\r\n{\r\nif (enable)\r\nomap_enable_gpio_irqbank(bank, GPIO_BIT(bank, gpio));\r\nelse\r\nomap_disable_gpio_irqbank(bank, GPIO_BIT(bank, gpio));\r\n}\r\nstatic int omap_set_gpio_wakeup(struct gpio_bank *bank, int gpio, int enable)\r\n{\r\nu32 gpio_bit = GPIO_BIT(bank, gpio);\r\nunsigned long flags;\r\nif (bank->non_wakeup_gpios & gpio_bit) {\r\ndev_err(bank->dev,\r\n"Unable to modify wakeup on non-wakeup GPIO%d\n", gpio);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&bank->lock, flags);\r\nif (enable)\r\nbank->context.wake_en |= gpio_bit;\r\nelse\r\nbank->context.wake_en &= ~gpio_bit;\r\nwritel_relaxed(bank->context.wake_en, bank->base + bank->regs->wkup_en);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void omap_reset_gpio(struct gpio_bank *bank, int gpio)\r\n{\r\nomap_set_gpio_direction(bank, GPIO_INDEX(bank, gpio), 1);\r\nomap_set_gpio_irqenable(bank, gpio, 0);\r\nomap_clear_gpio_irqstatus(bank, gpio);\r\nomap_set_gpio_triggering(bank, GPIO_INDEX(bank, gpio), IRQ_TYPE_NONE);\r\nomap_clear_gpio_debounce(bank, gpio);\r\n}\r\nstatic int omap_gpio_wake_enable(struct irq_data *d, unsigned int enable)\r\n{\r\nstruct gpio_bank *bank = omap_irq_data_get_bank(d);\r\nunsigned int gpio = omap_irq_to_gpio(bank, d->hwirq);\r\nreturn omap_set_gpio_wakeup(bank, gpio, enable);\r\n}\r\nstatic int omap_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_bank *bank = container_of(chip, struct gpio_bank, chip);\r\nunsigned long flags;\r\nif (!BANK_USED(bank))\r\npm_runtime_get_sync(bank->dev);\r\nspin_lock_irqsave(&bank->lock, flags);\r\nif (!LINE_USED(bank->irq_usage, offset)) {\r\nomap_set_gpio_triggering(bank, offset, IRQ_TYPE_NONE);\r\nomap_enable_gpio_module(bank, offset);\r\n}\r\nbank->mod_usage |= BIT(offset);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void omap_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_bank *bank = container_of(chip, struct gpio_bank, chip);\r\nunsigned long flags;\r\nspin_lock_irqsave(&bank->lock, flags);\r\nbank->mod_usage &= ~(BIT(offset));\r\nomap_disable_gpio_module(bank, offset);\r\nomap_reset_gpio(bank, bank->chip.base + offset);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nif (!BANK_USED(bank))\r\npm_runtime_put(bank->dev);\r\n}\r\nstatic void omap_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nvoid __iomem *isr_reg = NULL;\r\nu32 isr;\r\nunsigned int bit;\r\nstruct gpio_bank *bank;\r\nint unmasked = 0;\r\nstruct irq_chip *irqchip = irq_desc_get_chip(desc);\r\nstruct gpio_chip *chip = irq_get_handler_data(irq);\r\nchained_irq_enter(irqchip, desc);\r\nbank = container_of(chip, struct gpio_bank, chip);\r\nisr_reg = bank->base + bank->regs->irqstatus;\r\npm_runtime_get_sync(bank->dev);\r\nif (WARN_ON(!isr_reg))\r\ngoto exit;\r\nwhile (1) {\r\nu32 isr_saved, level_mask = 0;\r\nu32 enabled;\r\nenabled = omap_get_gpio_irqbank_mask(bank);\r\nisr_saved = isr = readl_relaxed(isr_reg) & enabled;\r\nif (bank->level_mask)\r\nlevel_mask = bank->level_mask & enabled;\r\nomap_disable_gpio_irqbank(bank, isr_saved & ~level_mask);\r\nomap_clear_gpio_irqbank(bank, isr_saved & ~level_mask);\r\nomap_enable_gpio_irqbank(bank, isr_saved & ~level_mask);\r\nif (!level_mask && !unmasked) {\r\nunmasked = 1;\r\nchained_irq_exit(irqchip, desc);\r\n}\r\nif (!isr)\r\nbreak;\r\nwhile (isr) {\r\nbit = __ffs(isr);\r\nisr &= ~(BIT(bit));\r\nif (bank->toggle_mask & (BIT(bit)))\r\nomap_toggle_gpio_edge_triggering(bank, bit);\r\ngeneric_handle_irq(irq_find_mapping(bank->chip.irqdomain,\r\nbit));\r\n}\r\n}\r\nexit:\r\nif (!unmasked)\r\nchained_irq_exit(irqchip, desc);\r\npm_runtime_put(bank->dev);\r\n}\r\nstatic unsigned int omap_gpio_irq_startup(struct irq_data *d)\r\n{\r\nstruct gpio_bank *bank = omap_irq_data_get_bank(d);\r\nunsigned int gpio = omap_irq_to_gpio(bank, d->hwirq);\r\nunsigned long flags;\r\nunsigned offset = GPIO_INDEX(bank, gpio);\r\nif (!BANK_USED(bank))\r\npm_runtime_get_sync(bank->dev);\r\nspin_lock_irqsave(&bank->lock, flags);\r\nomap_gpio_init_irq(bank, gpio, offset);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nomap_gpio_unmask_irq(d);\r\nreturn 0;\r\n}\r\nstatic void omap_gpio_irq_shutdown(struct irq_data *d)\r\n{\r\nstruct gpio_bank *bank = omap_irq_data_get_bank(d);\r\nunsigned int gpio = omap_irq_to_gpio(bank, d->hwirq);\r\nunsigned long flags;\r\nunsigned offset = GPIO_INDEX(bank, gpio);\r\nspin_lock_irqsave(&bank->lock, flags);\r\ngpiochip_unlock_as_irq(&bank->chip, offset);\r\nbank->irq_usage &= ~(BIT(offset));\r\nomap_disable_gpio_module(bank, offset);\r\nomap_reset_gpio(bank, gpio);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nif (!BANK_USED(bank))\r\npm_runtime_put(bank->dev);\r\n}\r\nstatic void omap_gpio_ack_irq(struct irq_data *d)\r\n{\r\nstruct gpio_bank *bank = omap_irq_data_get_bank(d);\r\nunsigned int gpio = omap_irq_to_gpio(bank, d->hwirq);\r\nomap_clear_gpio_irqstatus(bank, gpio);\r\n}\r\nstatic void omap_gpio_mask_irq(struct irq_data *d)\r\n{\r\nstruct gpio_bank *bank = omap_irq_data_get_bank(d);\r\nunsigned int gpio = omap_irq_to_gpio(bank, d->hwirq);\r\nunsigned long flags;\r\nspin_lock_irqsave(&bank->lock, flags);\r\nomap_set_gpio_irqenable(bank, gpio, 0);\r\nomap_set_gpio_triggering(bank, GPIO_INDEX(bank, gpio), IRQ_TYPE_NONE);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\n}\r\nstatic void omap_gpio_unmask_irq(struct irq_data *d)\r\n{\r\nstruct gpio_bank *bank = omap_irq_data_get_bank(d);\r\nunsigned int gpio = omap_irq_to_gpio(bank, d->hwirq);\r\nunsigned int irq_mask = GPIO_BIT(bank, gpio);\r\nu32 trigger = irqd_get_trigger_type(d);\r\nunsigned long flags;\r\nspin_lock_irqsave(&bank->lock, flags);\r\nif (trigger)\r\nomap_set_gpio_triggering(bank, GPIO_INDEX(bank, gpio), trigger);\r\nif (bank->level_mask & irq_mask) {\r\nomap_set_gpio_irqenable(bank, gpio, 0);\r\nomap_clear_gpio_irqstatus(bank, gpio);\r\n}\r\nomap_set_gpio_irqenable(bank, gpio, 1);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\n}\r\nstatic int omap_mpuio_suspend_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct gpio_bank *bank = platform_get_drvdata(pdev);\r\nvoid __iomem *mask_reg = bank->base +\r\nOMAP_MPUIO_GPIO_MASKIT / bank->stride;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bank->lock, flags);\r\nwritel_relaxed(0xffff & ~bank->context.wake_en, mask_reg);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int omap_mpuio_resume_noirq(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct gpio_bank *bank = platform_get_drvdata(pdev);\r\nvoid __iomem *mask_reg = bank->base +\r\nOMAP_MPUIO_GPIO_MASKIT / bank->stride;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bank->lock, flags);\r\nwritel_relaxed(bank->context.wake_en, mask_reg);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nstatic inline void omap_mpuio_init(struct gpio_bank *bank)\r\n{\r\nplatform_set_drvdata(&omap_mpuio_device, bank);\r\nif (platform_driver_register(&omap_mpuio_driver) == 0)\r\n(void) platform_device_register(&omap_mpuio_device);\r\n}\r\nstatic int omap_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_bank *bank;\r\nunsigned long flags;\r\nvoid __iomem *reg;\r\nint dir;\r\nbank = container_of(chip, struct gpio_bank, chip);\r\nreg = bank->base + bank->regs->direction;\r\nspin_lock_irqsave(&bank->lock, flags);\r\ndir = !!(readl_relaxed(reg) & BIT(offset));\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn dir;\r\n}\r\nstatic int omap_gpio_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_bank *bank;\r\nunsigned long flags;\r\nbank = container_of(chip, struct gpio_bank, chip);\r\nspin_lock_irqsave(&bank->lock, flags);\r\nomap_set_gpio_direction(bank, offset, 1);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int omap_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_bank *bank;\r\nu32 mask;\r\nbank = container_of(chip, struct gpio_bank, chip);\r\nmask = (BIT(offset));\r\nif (omap_gpio_is_input(bank, mask))\r\nreturn omap_get_gpio_datain(bank, offset);\r\nelse\r\nreturn omap_get_gpio_dataout(bank, offset);\r\n}\r\nstatic int omap_gpio_output(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct gpio_bank *bank;\r\nunsigned long flags;\r\nbank = container_of(chip, struct gpio_bank, chip);\r\nspin_lock_irqsave(&bank->lock, flags);\r\nbank->set_dataout(bank, offset, value);\r\nomap_set_gpio_direction(bank, offset, 0);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int omap_gpio_debounce(struct gpio_chip *chip, unsigned offset,\r\nunsigned debounce)\r\n{\r\nstruct gpio_bank *bank;\r\nunsigned long flags;\r\nbank = container_of(chip, struct gpio_bank, chip);\r\nspin_lock_irqsave(&bank->lock, flags);\r\nomap2_set_gpio_debounce(bank, offset, debounce);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void omap_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct gpio_bank *bank;\r\nunsigned long flags;\r\nbank = container_of(chip, struct gpio_bank, chip);\r\nspin_lock_irqsave(&bank->lock, flags);\r\nbank->set_dataout(bank, offset, value);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\n}\r\nstatic void __init omap_gpio_show_rev(struct gpio_bank *bank)\r\n{\r\nstatic bool called;\r\nu32 rev;\r\nif (called || bank->regs->revision == USHRT_MAX)\r\nreturn;\r\nrev = readw_relaxed(bank->base + bank->regs->revision);\r\npr_info("OMAP GPIO hardware version %d.%d\n",\r\n(rev >> 4) & 0x0f, rev & 0x0f);\r\ncalled = true;\r\n}\r\nstatic void omap_gpio_mod_init(struct gpio_bank *bank)\r\n{\r\nvoid __iomem *base = bank->base;\r\nu32 l = 0xffffffff;\r\nif (bank->width == 16)\r\nl = 0xffff;\r\nif (bank->is_mpuio) {\r\nwritel_relaxed(l, bank->base + bank->regs->irqenable);\r\nreturn;\r\n}\r\nomap_gpio_rmw(base, bank->regs->irqenable, l,\r\nbank->regs->irqenable_inv);\r\nomap_gpio_rmw(base, bank->regs->irqstatus, l,\r\n!bank->regs->irqenable_inv);\r\nif (bank->regs->debounce_en)\r\nwritel_relaxed(0, base + bank->regs->debounce_en);\r\nbank->context.oe = readl_relaxed(bank->base + bank->regs->direction);\r\nif (bank->regs->ctrl)\r\nwritel_relaxed(0, base + bank->regs->ctrl);\r\nbank->dbck = clk_get(bank->dev, "dbclk");\r\nif (IS_ERR(bank->dbck))\r\ndev_err(bank->dev, "Could not get gpio dbck\n");\r\n}\r\nstatic void\r\nomap_mpuio_alloc_gc(struct gpio_bank *bank, unsigned int irq_start,\r\nunsigned int num)\r\n{\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\ngc = irq_alloc_generic_chip("MPUIO", 1, irq_start, bank->base,\r\nhandle_simple_irq);\r\nif (!gc) {\r\ndev_err(bank->dev, "Memory alloc failed for gc\n");\r\nreturn;\r\n}\r\nct = gc->chip_types;\r\nct->chip.irq_mask = irq_gc_mask_set_bit;\r\nct->chip.irq_unmask = irq_gc_mask_clr_bit;\r\nct->chip.irq_set_type = omap_gpio_irq_type;\r\nif (bank->regs->wkup_en)\r\nct->chip.irq_set_wake = omap_gpio_wake_enable;\r\nct->regs.mask = OMAP_MPUIO_GPIO_INT / bank->stride;\r\nirq_setup_generic_chip(gc, IRQ_MSK(num), IRQ_GC_INIT_MASK_CACHE,\r\nIRQ_NOREQUEST | IRQ_NOPROBE, 0);\r\n}\r\nstatic int omap_gpio_chip_init(struct gpio_bank *bank, struct irq_chip *irqc)\r\n{\r\nint j;\r\nstatic int gpio;\r\nint irq_base = 0;\r\nint ret;\r\nbank->chip.request = omap_gpio_request;\r\nbank->chip.free = omap_gpio_free;\r\nbank->chip.get_direction = omap_gpio_get_direction;\r\nbank->chip.direction_input = omap_gpio_input;\r\nbank->chip.get = omap_gpio_get;\r\nbank->chip.direction_output = omap_gpio_output;\r\nbank->chip.set_debounce = omap_gpio_debounce;\r\nbank->chip.set = omap_gpio_set;\r\nif (bank->is_mpuio) {\r\nbank->chip.label = "mpuio";\r\nif (bank->regs->wkup_en)\r\nbank->chip.dev = &omap_mpuio_device.dev;\r\nbank->chip.base = OMAP_MPUIO(0);\r\n} else {\r\nbank->chip.label = "gpio";\r\nbank->chip.base = gpio;\r\ngpio += bank->width;\r\n}\r\nbank->chip.ngpio = bank->width;\r\nret = gpiochip_add(&bank->chip);\r\nif (ret) {\r\ndev_err(bank->dev, "Could not register gpio chip %d\n", ret);\r\nreturn ret;\r\n}\r\n#ifdef CONFIG_ARCH_OMAP1\r\nirq_base = irq_alloc_descs(-1, 0, bank->width, 0);\r\nif (irq_base < 0) {\r\ndev_err(bank->dev, "Couldn't allocate IRQ numbers\n");\r\nreturn -ENODEV;\r\n}\r\n#endif\r\nret = gpiochip_irqchip_add(&bank->chip, irqc,\r\nirq_base, omap_gpio_irq_handler,\r\nIRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(bank->dev, "Couldn't add irqchip to gpiochip %d\n", ret);\r\ngpiochip_remove(&bank->chip);\r\nreturn -ENODEV;\r\n}\r\ngpiochip_set_chained_irqchip(&bank->chip, irqc,\r\nbank->irq, omap_gpio_irq_handler);\r\nfor (j = 0; j < bank->width; j++) {\r\nint irq = irq_find_mapping(bank->chip.irqdomain, j);\r\nif (bank->is_mpuio) {\r\nomap_mpuio_alloc_gc(bank, irq, bank->width);\r\nirq_set_chip_and_handler(irq, NULL, NULL);\r\nset_irq_flags(irq, 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nconst struct of_device_id *match;\r\nconst struct omap_gpio_platform_data *pdata;\r\nstruct resource *res;\r\nstruct gpio_bank *bank;\r\nstruct irq_chip *irqc;\r\nint ret;\r\nmatch = of_match_device(of_match_ptr(omap_gpio_match), dev);\r\npdata = match ? match->data : dev_get_platdata(dev);\r\nif (!pdata)\r\nreturn -EINVAL;\r\nbank = devm_kzalloc(dev, sizeof(struct gpio_bank), GFP_KERNEL);\r\nif (!bank) {\r\ndev_err(dev, "Memory alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nirqc = devm_kzalloc(dev, sizeof(*irqc), GFP_KERNEL);\r\nif (!irqc)\r\nreturn -ENOMEM;\r\nirqc->irq_startup = omap_gpio_irq_startup,\r\nirqc->irq_shutdown = omap_gpio_irq_shutdown,\r\nirqc->irq_ack = omap_gpio_ack_irq,\r\nirqc->irq_mask = omap_gpio_mask_irq,\r\nirqc->irq_unmask = omap_gpio_unmask_irq,\r\nirqc->irq_set_type = omap_gpio_irq_type,\r\nirqc->irq_set_wake = omap_gpio_wake_enable,\r\nirqc->name = dev_name(&pdev->dev);\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (unlikely(!res)) {\r\ndev_err(dev, "Invalid IRQ resource\n");\r\nreturn -ENODEV;\r\n}\r\nbank->irq = res->start;\r\nbank->dev = dev;\r\nbank->chip.dev = dev;\r\nbank->dbck_flag = pdata->dbck_flag;\r\nbank->stride = pdata->bank_stride;\r\nbank->width = pdata->bank_width;\r\nbank->is_mpuio = pdata->is_mpuio;\r\nbank->non_wakeup_gpios = pdata->non_wakeup_gpios;\r\nbank->regs = pdata->regs;\r\n#ifdef CONFIG_OF_GPIO\r\nbank->chip.of_node = of_node_get(node);\r\n#endif\r\nif (node) {\r\nif (!of_property_read_bool(node, "ti,gpio-always-on"))\r\nbank->loses_context = true;\r\n} else {\r\nbank->loses_context = pdata->loses_context;\r\nif (bank->loses_context)\r\nbank->get_context_loss_count =\r\npdata->get_context_loss_count;\r\n}\r\nif (bank->regs->set_dataout && bank->regs->clr_dataout)\r\nbank->set_dataout = omap_set_gpio_dataout_reg;\r\nelse\r\nbank->set_dataout = omap_set_gpio_dataout_mask;\r\nspin_lock_init(&bank->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbank->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(bank->base)) {\r\nirq_domain_remove(bank->chip.irqdomain);\r\nreturn PTR_ERR(bank->base);\r\n}\r\nplatform_set_drvdata(pdev, bank);\r\npm_runtime_enable(bank->dev);\r\npm_runtime_irq_safe(bank->dev);\r\npm_runtime_get_sync(bank->dev);\r\nif (bank->is_mpuio)\r\nomap_mpuio_init(bank);\r\nomap_gpio_mod_init(bank);\r\nret = omap_gpio_chip_init(bank, irqc);\r\nif (ret)\r\nreturn ret;\r\nomap_gpio_show_rev(bank);\r\npm_runtime_put(bank->dev);\r\nlist_add_tail(&bank->node, &omap_gpio_list);\r\nreturn 0;\r\n}\r\nstatic int omap_gpio_runtime_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct gpio_bank *bank = platform_get_drvdata(pdev);\r\nu32 l1 = 0, l2 = 0;\r\nunsigned long flags;\r\nu32 wake_low, wake_hi;\r\nspin_lock_irqsave(&bank->lock, flags);\r\nwake_low = bank->context.leveldetect0 & bank->context.wake_en;\r\nif (wake_low)\r\nwritel_relaxed(wake_low | bank->context.fallingdetect,\r\nbank->base + bank->regs->fallingdetect);\r\nwake_hi = bank->context.leveldetect1 & bank->context.wake_en;\r\nif (wake_hi)\r\nwritel_relaxed(wake_hi | bank->context.risingdetect,\r\nbank->base + bank->regs->risingdetect);\r\nif (!bank->enabled_non_wakeup_gpios)\r\ngoto update_gpio_context_count;\r\nif (bank->power_mode != OFF_MODE) {\r\nbank->power_mode = 0;\r\ngoto update_gpio_context_count;\r\n}\r\nbank->saved_datain = readl_relaxed(bank->base +\r\nbank->regs->datain);\r\nl1 = bank->context.fallingdetect;\r\nl2 = bank->context.risingdetect;\r\nl1 &= ~bank->enabled_non_wakeup_gpios;\r\nl2 &= ~bank->enabled_non_wakeup_gpios;\r\nwritel_relaxed(l1, bank->base + bank->regs->fallingdetect);\r\nwritel_relaxed(l2, bank->base + bank->regs->risingdetect);\r\nbank->workaround_enabled = true;\r\nupdate_gpio_context_count:\r\nif (bank->get_context_loss_count)\r\nbank->context_loss_count =\r\nbank->get_context_loss_count(bank->dev);\r\nomap_gpio_dbck_disable(bank);\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int omap_gpio_runtime_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct gpio_bank *bank = platform_get_drvdata(pdev);\r\nu32 l = 0, gen, gen0, gen1;\r\nunsigned long flags;\r\nint c;\r\nspin_lock_irqsave(&bank->lock, flags);\r\nif (bank->loses_context && !bank->context_valid) {\r\nomap_gpio_init_context(bank);\r\nif (bank->get_context_loss_count)\r\nbank->context_loss_count =\r\nbank->get_context_loss_count(bank->dev);\r\n}\r\nomap_gpio_dbck_enable(bank);\r\nwritel_relaxed(bank->context.fallingdetect,\r\nbank->base + bank->regs->fallingdetect);\r\nwritel_relaxed(bank->context.risingdetect,\r\nbank->base + bank->regs->risingdetect);\r\nif (bank->loses_context) {\r\nif (!bank->get_context_loss_count) {\r\nomap_gpio_restore_context(bank);\r\n} else {\r\nc = bank->get_context_loss_count(bank->dev);\r\nif (c != bank->context_loss_count) {\r\nomap_gpio_restore_context(bank);\r\n} else {\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nif (!bank->workaround_enabled) {\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nl = readl_relaxed(bank->base + bank->regs->datain);\r\nl ^= bank->saved_datain;\r\nl &= bank->enabled_non_wakeup_gpios;\r\ngen0 = l & bank->context.fallingdetect;\r\ngen0 &= bank->saved_datain;\r\ngen1 = l & bank->context.risingdetect;\r\ngen1 &= ~(bank->saved_datain);\r\ngen = l & (~(bank->context.fallingdetect) &\r\n~(bank->context.risingdetect));\r\ngen |= gen0 | gen1;\r\nif (gen) {\r\nu32 old0, old1;\r\nold0 = readl_relaxed(bank->base + bank->regs->leveldetect0);\r\nold1 = readl_relaxed(bank->base + bank->regs->leveldetect1);\r\nif (!bank->regs->irqstatus_raw0) {\r\nwritel_relaxed(old0 | gen, bank->base +\r\nbank->regs->leveldetect0);\r\nwritel_relaxed(old1 | gen, bank->base +\r\nbank->regs->leveldetect1);\r\n}\r\nif (bank->regs->irqstatus_raw0) {\r\nwritel_relaxed(old0 | l, bank->base +\r\nbank->regs->leveldetect0);\r\nwritel_relaxed(old1 | l, bank->base +\r\nbank->regs->leveldetect1);\r\n}\r\nwritel_relaxed(old0, bank->base + bank->regs->leveldetect0);\r\nwritel_relaxed(old1, bank->base + bank->regs->leveldetect1);\r\n}\r\nbank->workaround_enabled = false;\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nreturn 0;\r\n}\r\nvoid omap2_gpio_prepare_for_idle(int pwr_mode)\r\n{\r\nstruct gpio_bank *bank;\r\nlist_for_each_entry(bank, &omap_gpio_list, node) {\r\nif (!BANK_USED(bank) || !bank->loses_context)\r\ncontinue;\r\nbank->power_mode = pwr_mode;\r\npm_runtime_put_sync_suspend(bank->dev);\r\n}\r\n}\r\nvoid omap2_gpio_resume_after_idle(void)\r\n{\r\nstruct gpio_bank *bank;\r\nlist_for_each_entry(bank, &omap_gpio_list, node) {\r\nif (!BANK_USED(bank) || !bank->loses_context)\r\ncontinue;\r\npm_runtime_get_sync(bank->dev);\r\n}\r\n}\r\nstatic void omap_gpio_init_context(struct gpio_bank *p)\r\n{\r\nstruct omap_gpio_reg_offs *regs = p->regs;\r\nvoid __iomem *base = p->base;\r\np->context.ctrl = readl_relaxed(base + regs->ctrl);\r\np->context.oe = readl_relaxed(base + regs->direction);\r\np->context.wake_en = readl_relaxed(base + regs->wkup_en);\r\np->context.leveldetect0 = readl_relaxed(base + regs->leveldetect0);\r\np->context.leveldetect1 = readl_relaxed(base + regs->leveldetect1);\r\np->context.risingdetect = readl_relaxed(base + regs->risingdetect);\r\np->context.fallingdetect = readl_relaxed(base + regs->fallingdetect);\r\np->context.irqenable1 = readl_relaxed(base + regs->irqenable);\r\np->context.irqenable2 = readl_relaxed(base + regs->irqenable2);\r\nif (regs->set_dataout && p->regs->clr_dataout)\r\np->context.dataout = readl_relaxed(base + regs->set_dataout);\r\nelse\r\np->context.dataout = readl_relaxed(base + regs->dataout);\r\np->context_valid = true;\r\n}\r\nstatic void omap_gpio_restore_context(struct gpio_bank *bank)\r\n{\r\nwritel_relaxed(bank->context.wake_en,\r\nbank->base + bank->regs->wkup_en);\r\nwritel_relaxed(bank->context.ctrl, bank->base + bank->regs->ctrl);\r\nwritel_relaxed(bank->context.leveldetect0,\r\nbank->base + bank->regs->leveldetect0);\r\nwritel_relaxed(bank->context.leveldetect1,\r\nbank->base + bank->regs->leveldetect1);\r\nwritel_relaxed(bank->context.risingdetect,\r\nbank->base + bank->regs->risingdetect);\r\nwritel_relaxed(bank->context.fallingdetect,\r\nbank->base + bank->regs->fallingdetect);\r\nif (bank->regs->set_dataout && bank->regs->clr_dataout)\r\nwritel_relaxed(bank->context.dataout,\r\nbank->base + bank->regs->set_dataout);\r\nelse\r\nwritel_relaxed(bank->context.dataout,\r\nbank->base + bank->regs->dataout);\r\nwritel_relaxed(bank->context.oe, bank->base + bank->regs->direction);\r\nif (bank->dbck_enable_mask) {\r\nwritel_relaxed(bank->context.debounce, bank->base +\r\nbank->regs->debounce);\r\nwritel_relaxed(bank->context.debounce_en,\r\nbank->base + bank->regs->debounce_en);\r\n}\r\nwritel_relaxed(bank->context.irqenable1,\r\nbank->base + bank->regs->irqenable);\r\nwritel_relaxed(bank->context.irqenable2,\r\nbank->base + bank->regs->irqenable2);\r\n}\r\nstatic inline void omap_gpio_init_context(struct gpio_bank *p) {}\r\nstatic int __init omap_gpio_drv_reg(void)\r\n{\r\nreturn platform_driver_register(&omap_gpio_driver);\r\n}
