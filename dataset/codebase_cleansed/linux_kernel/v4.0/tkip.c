static u16 tkipS(u16 val)\r\n{\r\nreturn tkip_sbox[val & 0xff] ^ swab16(tkip_sbox[val >> 8]);\r\n}\r\nstatic u8 *write_tkip_iv(u8 *pos, u16 iv16)\r\n{\r\n*pos++ = iv16 >> 8;\r\n*pos++ = ((iv16 >> 8) | 0x20) & 0x7f;\r\n*pos++ = iv16 & 0xFF;\r\nreturn pos;\r\n}\r\nstatic void tkip_mixing_phase1(const u8 *tk, struct tkip_ctx *ctx,\r\nconst u8 *ta, u32 tsc_IV32)\r\n{\r\nint i, j;\r\nu16 *p1k = ctx->p1k;\r\np1k[0] = tsc_IV32 & 0xFFFF;\r\np1k[1] = tsc_IV32 >> 16;\r\np1k[2] = get_unaligned_le16(ta + 0);\r\np1k[3] = get_unaligned_le16(ta + 2);\r\np1k[4] = get_unaligned_le16(ta + 4);\r\nfor (i = 0; i < PHASE1_LOOP_COUNT; i++) {\r\nj = 2 * (i & 1);\r\np1k[0] += tkipS(p1k[4] ^ get_unaligned_le16(tk + 0 + j));\r\np1k[1] += tkipS(p1k[0] ^ get_unaligned_le16(tk + 4 + j));\r\np1k[2] += tkipS(p1k[1] ^ get_unaligned_le16(tk + 8 + j));\r\np1k[3] += tkipS(p1k[2] ^ get_unaligned_le16(tk + 12 + j));\r\np1k[4] += tkipS(p1k[3] ^ get_unaligned_le16(tk + 0 + j)) + i;\r\n}\r\nctx->state = TKIP_STATE_PHASE1_DONE;\r\nctx->p1k_iv32 = tsc_IV32;\r\n}\r\nstatic void tkip_mixing_phase2(const u8 *tk, struct tkip_ctx *ctx,\r\nu16 tsc_IV16, u8 *rc4key)\r\n{\r\nu16 ppk[6];\r\nconst u16 *p1k = ctx->p1k;\r\nint i;\r\nppk[0] = p1k[0];\r\nppk[1] = p1k[1];\r\nppk[2] = p1k[2];\r\nppk[3] = p1k[3];\r\nppk[4] = p1k[4];\r\nppk[5] = p1k[4] + tsc_IV16;\r\nppk[0] += tkipS(ppk[5] ^ get_unaligned_le16(tk + 0));\r\nppk[1] += tkipS(ppk[0] ^ get_unaligned_le16(tk + 2));\r\nppk[2] += tkipS(ppk[1] ^ get_unaligned_le16(tk + 4));\r\nppk[3] += tkipS(ppk[2] ^ get_unaligned_le16(tk + 6));\r\nppk[4] += tkipS(ppk[3] ^ get_unaligned_le16(tk + 8));\r\nppk[5] += tkipS(ppk[4] ^ get_unaligned_le16(tk + 10));\r\nppk[0] += ror16(ppk[5] ^ get_unaligned_le16(tk + 12), 1);\r\nppk[1] += ror16(ppk[0] ^ get_unaligned_le16(tk + 14), 1);\r\nppk[2] += ror16(ppk[1], 1);\r\nppk[3] += ror16(ppk[2], 1);\r\nppk[4] += ror16(ppk[3], 1);\r\nppk[5] += ror16(ppk[4], 1);\r\nrc4key = write_tkip_iv(rc4key, tsc_IV16);\r\n*rc4key++ = ((ppk[5] ^ get_unaligned_le16(tk)) >> 1) & 0xFF;\r\nfor (i = 0; i < 6; i++)\r\nput_unaligned_le16(ppk[i], rc4key + 2 * i);\r\n}\r\nu8 *ieee80211_tkip_add_iv(u8 *pos, struct ieee80211_key *key)\r\n{\r\nlockdep_assert_held(&key->u.tkip.txlock);\r\npos = write_tkip_iv(pos, key->u.tkip.tx.iv16);\r\n*pos++ = (key->conf.keyidx << 6) | (1 << 5) ;\r\nput_unaligned_le32(key->u.tkip.tx.iv32, pos);\r\nreturn pos + 4;\r\n}\r\nstatic void ieee80211_compute_tkip_p1k(struct ieee80211_key *key, u32 iv32)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = key->sdata;\r\nstruct tkip_ctx *ctx = &key->u.tkip.tx;\r\nconst u8 *tk = &key->conf.key[NL80211_TKIP_DATA_OFFSET_ENCR_KEY];\r\nlockdep_assert_held(&key->u.tkip.txlock);\r\nif (ctx->p1k_iv32 != iv32 || ctx->state == TKIP_STATE_NOT_INIT)\r\ntkip_mixing_phase1(tk, ctx, sdata->vif.addr, iv32);\r\n}\r\nvoid ieee80211_get_tkip_p1k_iv(struct ieee80211_key_conf *keyconf,\r\nu32 iv32, u16 *p1k)\r\n{\r\nstruct ieee80211_key *key = (struct ieee80211_key *)\r\ncontainer_of(keyconf, struct ieee80211_key, conf);\r\nstruct tkip_ctx *ctx = &key->u.tkip.tx;\r\nspin_lock_bh(&key->u.tkip.txlock);\r\nieee80211_compute_tkip_p1k(key, iv32);\r\nmemcpy(p1k, ctx->p1k, sizeof(ctx->p1k));\r\nspin_unlock_bh(&key->u.tkip.txlock);\r\n}\r\nvoid ieee80211_get_tkip_rx_p1k(struct ieee80211_key_conf *keyconf,\r\nconst u8 *ta, u32 iv32, u16 *p1k)\r\n{\r\nconst u8 *tk = &keyconf->key[NL80211_TKIP_DATA_OFFSET_ENCR_KEY];\r\nstruct tkip_ctx ctx;\r\ntkip_mixing_phase1(tk, &ctx, ta, iv32);\r\nmemcpy(p1k, ctx.p1k, sizeof(ctx.p1k));\r\n}\r\nvoid ieee80211_get_tkip_p2k(struct ieee80211_key_conf *keyconf,\r\nstruct sk_buff *skb, u8 *p2k)\r\n{\r\nstruct ieee80211_key *key = (struct ieee80211_key *)\r\ncontainer_of(keyconf, struct ieee80211_key, conf);\r\nconst u8 *tk = &key->conf.key[NL80211_TKIP_DATA_OFFSET_ENCR_KEY];\r\nstruct tkip_ctx *ctx = &key->u.tkip.tx;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nconst u8 *data = (u8 *)hdr + ieee80211_hdrlen(hdr->frame_control);\r\nu32 iv32 = get_unaligned_le32(&data[4]);\r\nu16 iv16 = data[2] | (data[0] << 8);\r\nspin_lock(&key->u.tkip.txlock);\r\nieee80211_compute_tkip_p1k(key, iv32);\r\ntkip_mixing_phase2(tk, ctx, iv16, p2k);\r\nspin_unlock(&key->u.tkip.txlock);\r\n}\r\nint ieee80211_tkip_encrypt_data(struct crypto_cipher *tfm,\r\nstruct ieee80211_key *key,\r\nstruct sk_buff *skb,\r\nu8 *payload, size_t payload_len)\r\n{\r\nu8 rc4key[16];\r\nieee80211_get_tkip_p2k(&key->conf, skb, rc4key);\r\nreturn ieee80211_wep_encrypt_data(tfm, rc4key, 16,\r\npayload, payload_len);\r\n}\r\nint ieee80211_tkip_decrypt_data(struct crypto_cipher *tfm,\r\nstruct ieee80211_key *key,\r\nu8 *payload, size_t payload_len, u8 *ta,\r\nu8 *ra, int only_iv, int queue,\r\nu32 *out_iv32, u16 *out_iv16)\r\n{\r\nu32 iv32;\r\nu32 iv16;\r\nu8 rc4key[16], keyid, *pos = payload;\r\nint res;\r\nconst u8 *tk = &key->conf.key[NL80211_TKIP_DATA_OFFSET_ENCR_KEY];\r\nif (payload_len < 12)\r\nreturn -1;\r\niv16 = (pos[0] << 8) | pos[2];\r\nkeyid = pos[3];\r\niv32 = get_unaligned_le32(pos + 4);\r\npos += 8;\r\nif (!(keyid & (1 << 5)))\r\nreturn TKIP_DECRYPT_NO_EXT_IV;\r\nif ((keyid >> 6) != key->conf.keyidx)\r\nreturn TKIP_DECRYPT_INVALID_KEYIDX;\r\nif (key->u.tkip.rx[queue].state != TKIP_STATE_NOT_INIT &&\r\n(iv32 < key->u.tkip.rx[queue].iv32 ||\r\n(iv32 == key->u.tkip.rx[queue].iv32 &&\r\niv16 <= key->u.tkip.rx[queue].iv16)))\r\nreturn TKIP_DECRYPT_REPLAY;\r\nif (only_iv) {\r\nres = TKIP_DECRYPT_OK;\r\nkey->u.tkip.rx[queue].state = TKIP_STATE_PHASE1_HW_UPLOADED;\r\ngoto done;\r\n}\r\nif (key->u.tkip.rx[queue].state == TKIP_STATE_NOT_INIT ||\r\nkey->u.tkip.rx[queue].iv32 != iv32) {\r\ntkip_mixing_phase1(tk, &key->u.tkip.rx[queue], ta, iv32);\r\n}\r\nif (key->local->ops->update_tkip_key &&\r\nkey->flags & KEY_FLAG_UPLOADED_TO_HARDWARE &&\r\nkey->u.tkip.rx[queue].state != TKIP_STATE_PHASE1_HW_UPLOADED) {\r\nstruct ieee80211_sub_if_data *sdata = key->sdata;\r\nif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\r\nsdata = container_of(key->sdata->bss,\r\nstruct ieee80211_sub_if_data, u.ap);\r\ndrv_update_tkip_key(key->local, sdata, &key->conf, key->sta,\r\niv32, key->u.tkip.rx[queue].p1k);\r\nkey->u.tkip.rx[queue].state = TKIP_STATE_PHASE1_HW_UPLOADED;\r\n}\r\ntkip_mixing_phase2(tk, &key->u.tkip.rx[queue], iv16, rc4key);\r\nres = ieee80211_wep_decrypt_data(tfm, rc4key, 16, pos, payload_len - 12);\r\ndone:\r\nif (res == TKIP_DECRYPT_OK) {\r\n*out_iv32 = iv32;\r\n*out_iv16 = iv16;\r\n}\r\nreturn res;\r\n}
