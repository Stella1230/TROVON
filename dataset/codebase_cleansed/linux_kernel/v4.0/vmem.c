static void __ref *vmem_alloc_pages(unsigned int order)\r\n{\r\nif (slab_is_available())\r\nreturn (void *)__get_free_pages(GFP_KERNEL, order);\r\nreturn alloc_bootmem_pages((1 << order) * PAGE_SIZE);\r\n}\r\nstatic inline pud_t *vmem_pud_alloc(void)\r\n{\r\npud_t *pud = NULL;\r\n#ifdef CONFIG_64BIT\r\npud = vmem_alloc_pages(2);\r\nif (!pud)\r\nreturn NULL;\r\nclear_table((unsigned long *) pud, _REGION3_ENTRY_EMPTY, PAGE_SIZE * 4);\r\n#endif\r\nreturn pud;\r\n}\r\nstatic inline pmd_t *vmem_pmd_alloc(void)\r\n{\r\npmd_t *pmd = NULL;\r\n#ifdef CONFIG_64BIT\r\npmd = vmem_alloc_pages(2);\r\nif (!pmd)\r\nreturn NULL;\r\nclear_table((unsigned long *) pmd, _SEGMENT_ENTRY_EMPTY, PAGE_SIZE * 4);\r\n#endif\r\nreturn pmd;\r\n}\r\nstatic pte_t __ref *vmem_pte_alloc(unsigned long address)\r\n{\r\npte_t *pte;\r\nif (slab_is_available())\r\npte = (pte_t *) page_table_alloc(&init_mm);\r\nelse\r\npte = alloc_bootmem_align(PTRS_PER_PTE * sizeof(pte_t),\r\nPTRS_PER_PTE * sizeof(pte_t));\r\nif (!pte)\r\nreturn NULL;\r\nclear_table((unsigned long *) pte, _PAGE_INVALID,\r\nPTRS_PER_PTE * sizeof(pte_t));\r\nreturn pte;\r\n}\r\nstatic int vmem_add_mem(unsigned long start, unsigned long size, int ro)\r\n{\r\nunsigned long end = start + size;\r\nunsigned long address = start;\r\npgd_t *pg_dir;\r\npud_t *pu_dir;\r\npmd_t *pm_dir;\r\npte_t *pt_dir;\r\nint ret = -ENOMEM;\r\nwhile (address < end) {\r\npg_dir = pgd_offset_k(address);\r\nif (pgd_none(*pg_dir)) {\r\npu_dir = vmem_pud_alloc();\r\nif (!pu_dir)\r\ngoto out;\r\npgd_populate(&init_mm, pg_dir, pu_dir);\r\n}\r\npu_dir = pud_offset(pg_dir, address);\r\n#if defined(CONFIG_64BIT) && !defined(CONFIG_DEBUG_PAGEALLOC)\r\nif (MACHINE_HAS_EDAT2 && pud_none(*pu_dir) && address &&\r\n!(address & ~PUD_MASK) && (address + PUD_SIZE <= end)) {\r\npud_val(*pu_dir) = __pa(address) |\r\n_REGION_ENTRY_TYPE_R3 | _REGION3_ENTRY_LARGE |\r\n(ro ? _REGION_ENTRY_PROTECT : 0);\r\naddress += PUD_SIZE;\r\ncontinue;\r\n}\r\n#endif\r\nif (pud_none(*pu_dir)) {\r\npm_dir = vmem_pmd_alloc();\r\nif (!pm_dir)\r\ngoto out;\r\npud_populate(&init_mm, pu_dir, pm_dir);\r\n}\r\npm_dir = pmd_offset(pu_dir, address);\r\n#if defined(CONFIG_64BIT) && !defined(CONFIG_DEBUG_PAGEALLOC)\r\nif (MACHINE_HAS_EDAT1 && pmd_none(*pm_dir) && address &&\r\n!(address & ~PMD_MASK) && (address + PMD_SIZE <= end)) {\r\npmd_val(*pm_dir) = __pa(address) |\r\n_SEGMENT_ENTRY | _SEGMENT_ENTRY_LARGE |\r\n_SEGMENT_ENTRY_YOUNG |\r\n(ro ? _SEGMENT_ENTRY_PROTECT : 0);\r\naddress += PMD_SIZE;\r\ncontinue;\r\n}\r\n#endif\r\nif (pmd_none(*pm_dir)) {\r\npt_dir = vmem_pte_alloc(address);\r\nif (!pt_dir)\r\ngoto out;\r\npmd_populate(&init_mm, pm_dir, pt_dir);\r\n}\r\npt_dir = pte_offset_kernel(pm_dir, address);\r\npte_val(*pt_dir) = __pa(address) |\r\npgprot_val(ro ? PAGE_KERNEL_RO : PAGE_KERNEL);\r\naddress += PAGE_SIZE;\r\n}\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void vmem_remove_range(unsigned long start, unsigned long size)\r\n{\r\nunsigned long end = start + size;\r\nunsigned long address = start;\r\npgd_t *pg_dir;\r\npud_t *pu_dir;\r\npmd_t *pm_dir;\r\npte_t *pt_dir;\r\npte_t pte;\r\npte_val(pte) = _PAGE_INVALID;\r\nwhile (address < end) {\r\npg_dir = pgd_offset_k(address);\r\nif (pgd_none(*pg_dir)) {\r\naddress += PGDIR_SIZE;\r\ncontinue;\r\n}\r\npu_dir = pud_offset(pg_dir, address);\r\nif (pud_none(*pu_dir)) {\r\naddress += PUD_SIZE;\r\ncontinue;\r\n}\r\nif (pud_large(*pu_dir)) {\r\npud_clear(pu_dir);\r\naddress += PUD_SIZE;\r\ncontinue;\r\n}\r\npm_dir = pmd_offset(pu_dir, address);\r\nif (pmd_none(*pm_dir)) {\r\naddress += PMD_SIZE;\r\ncontinue;\r\n}\r\nif (pmd_large(*pm_dir)) {\r\npmd_clear(pm_dir);\r\naddress += PMD_SIZE;\r\ncontinue;\r\n}\r\npt_dir = pte_offset_kernel(pm_dir, address);\r\n*pt_dir = pte;\r\naddress += PAGE_SIZE;\r\n}\r\nflush_tlb_kernel_range(start, end);\r\n}\r\nint __meminit vmemmap_populate(unsigned long start, unsigned long end, int node)\r\n{\r\nunsigned long address = start;\r\npgd_t *pg_dir;\r\npud_t *pu_dir;\r\npmd_t *pm_dir;\r\npte_t *pt_dir;\r\nint ret = -ENOMEM;\r\nfor (address = start; address < end;) {\r\npg_dir = pgd_offset_k(address);\r\nif (pgd_none(*pg_dir)) {\r\npu_dir = vmem_pud_alloc();\r\nif (!pu_dir)\r\ngoto out;\r\npgd_populate(&init_mm, pg_dir, pu_dir);\r\n}\r\npu_dir = pud_offset(pg_dir, address);\r\nif (pud_none(*pu_dir)) {\r\npm_dir = vmem_pmd_alloc();\r\nif (!pm_dir)\r\ngoto out;\r\npud_populate(&init_mm, pu_dir, pm_dir);\r\n}\r\npm_dir = pmd_offset(pu_dir, address);\r\nif (pmd_none(*pm_dir)) {\r\n#ifdef CONFIG_64BIT\r\nif (MACHINE_HAS_EDAT1) {\r\nvoid *new_page;\r\nnew_page = vmemmap_alloc_block(PMD_SIZE, node);\r\nif (!new_page)\r\ngoto out;\r\npmd_val(*pm_dir) = __pa(new_page) |\r\n_SEGMENT_ENTRY | _SEGMENT_ENTRY_LARGE;\r\naddress = (address + PMD_SIZE) & PMD_MASK;\r\ncontinue;\r\n}\r\n#endif\r\npt_dir = vmem_pte_alloc(address);\r\nif (!pt_dir)\r\ngoto out;\r\npmd_populate(&init_mm, pm_dir, pt_dir);\r\n} else if (pmd_large(*pm_dir)) {\r\naddress = (address + PMD_SIZE) & PMD_MASK;\r\ncontinue;\r\n}\r\npt_dir = pte_offset_kernel(pm_dir, address);\r\nif (pte_none(*pt_dir)) {\r\nvoid *new_page;\r\nnew_page = vmemmap_alloc_block(PAGE_SIZE, node);\r\nif (!new_page)\r\ngoto out;\r\npte_val(*pt_dir) =\r\n__pa(new_page) | pgprot_val(PAGE_KERNEL);\r\n}\r\naddress += PAGE_SIZE;\r\n}\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nvoid vmemmap_free(unsigned long start, unsigned long end)\r\n{\r\n}\r\nstatic int insert_memory_segment(struct memory_segment *seg)\r\n{\r\nstruct memory_segment *tmp;\r\nif (seg->start + seg->size > VMEM_MAX_PHYS ||\r\nseg->start + seg->size < seg->start)\r\nreturn -ERANGE;\r\nlist_for_each_entry(tmp, &mem_segs, list) {\r\nif (seg->start >= tmp->start + tmp->size)\r\ncontinue;\r\nif (seg->start + seg->size <= tmp->start)\r\ncontinue;\r\nreturn -ENOSPC;\r\n}\r\nlist_add(&seg->list, &mem_segs);\r\nreturn 0;\r\n}\r\nstatic void remove_memory_segment(struct memory_segment *seg)\r\n{\r\nlist_del(&seg->list);\r\n}\r\nstatic void __remove_shared_memory(struct memory_segment *seg)\r\n{\r\nremove_memory_segment(seg);\r\nvmem_remove_range(seg->start, seg->size);\r\n}\r\nint vmem_remove_mapping(unsigned long start, unsigned long size)\r\n{\r\nstruct memory_segment *seg;\r\nint ret;\r\nmutex_lock(&vmem_mutex);\r\nret = -ENOENT;\r\nlist_for_each_entry(seg, &mem_segs, list) {\r\nif (seg->start == start && seg->size == size)\r\nbreak;\r\n}\r\nif (seg->start != start || seg->size != size)\r\ngoto out;\r\nret = 0;\r\n__remove_shared_memory(seg);\r\nkfree(seg);\r\nout:\r\nmutex_unlock(&vmem_mutex);\r\nreturn ret;\r\n}\r\nint vmem_add_mapping(unsigned long start, unsigned long size)\r\n{\r\nstruct memory_segment *seg;\r\nint ret;\r\nmutex_lock(&vmem_mutex);\r\nret = -ENOMEM;\r\nseg = kzalloc(sizeof(*seg), GFP_KERNEL);\r\nif (!seg)\r\ngoto out;\r\nseg->start = start;\r\nseg->size = size;\r\nret = insert_memory_segment(seg);\r\nif (ret)\r\ngoto out_free;\r\nret = vmem_add_mem(start, size, 0);\r\nif (ret)\r\ngoto out_remove;\r\ngoto out;\r\nout_remove:\r\n__remove_shared_memory(seg);\r\nout_free:\r\nkfree(seg);\r\nout:\r\nmutex_unlock(&vmem_mutex);\r\nreturn ret;\r\n}\r\nvoid __init vmem_map_init(void)\r\n{\r\nunsigned long ro_start, ro_end;\r\nstruct memblock_region *reg;\r\nphys_addr_t start, end;\r\nro_start = PFN_ALIGN((unsigned long)&_stext);\r\nro_end = (unsigned long)&_eshared & PAGE_MASK;\r\nfor_each_memblock(memory, reg) {\r\nstart = reg->base;\r\nend = reg->base + reg->size - 1;\r\nif (start >= ro_end || end <= ro_start)\r\nvmem_add_mem(start, end - start, 0);\r\nelse if (start >= ro_start && end <= ro_end)\r\nvmem_add_mem(start, end - start, 1);\r\nelse if (start >= ro_start) {\r\nvmem_add_mem(start, ro_end - start, 1);\r\nvmem_add_mem(ro_end, end - ro_end, 0);\r\n} else if (end < ro_end) {\r\nvmem_add_mem(start, ro_start - start, 0);\r\nvmem_add_mem(ro_start, end - ro_start, 1);\r\n} else {\r\nvmem_add_mem(start, ro_start - start, 0);\r\nvmem_add_mem(ro_start, ro_end - ro_start, 1);\r\nvmem_add_mem(ro_end, end - ro_end, 0);\r\n}\r\n}\r\n}\r\nstatic int __init vmem_convert_memory_chunk(void)\r\n{\r\nstruct memblock_region *reg;\r\nstruct memory_segment *seg;\r\nmutex_lock(&vmem_mutex);\r\nfor_each_memblock(memory, reg) {\r\nseg = kzalloc(sizeof(*seg), GFP_KERNEL);\r\nif (!seg)\r\npanic("Out of memory...\n");\r\nseg->start = reg->base;\r\nseg->size = reg->size;\r\ninsert_memory_segment(seg);\r\n}\r\nmutex_unlock(&vmem_mutex);\r\nreturn 0;\r\n}
