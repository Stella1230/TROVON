static void nft_reject_br_push_etherhdr(struct sk_buff *oldskb,\r\nstruct sk_buff *nskb)\r\n{\r\nstruct ethhdr *eth;\r\neth = (struct ethhdr *)skb_push(nskb, ETH_HLEN);\r\nskb_reset_mac_header(nskb);\r\nether_addr_copy(eth->h_source, eth_hdr(oldskb)->h_dest);\r\nether_addr_copy(eth->h_dest, eth_hdr(oldskb)->h_source);\r\neth->h_proto = eth_hdr(oldskb)->h_proto;\r\nskb_pull(nskb, ETH_HLEN);\r\n}\r\nstatic void nft_reject_br_send_v4_tcp_reset(struct sk_buff *oldskb, int hook)\r\n{\r\nstruct sk_buff *nskb;\r\nstruct iphdr *niph;\r\nconst struct tcphdr *oth;\r\nstruct tcphdr _oth;\r\nif (!nft_bridge_iphdr_validate(oldskb))\r\nreturn;\r\noth = nf_reject_ip_tcphdr_get(oldskb, &_oth, hook);\r\nif (!oth)\r\nreturn;\r\nnskb = alloc_skb(sizeof(struct iphdr) + sizeof(struct tcphdr) +\r\nLL_MAX_HEADER, GFP_ATOMIC);\r\nif (!nskb)\r\nreturn;\r\nskb_reserve(nskb, LL_MAX_HEADER);\r\nniph = nf_reject_iphdr_put(nskb, oldskb, IPPROTO_TCP,\r\nsysctl_ip_default_ttl);\r\nnf_reject_ip_tcphdr_put(nskb, oldskb, oth);\r\nniph->ttl = sysctl_ip_default_ttl;\r\nniph->tot_len = htons(nskb->len);\r\nip_send_check(niph);\r\nnft_reject_br_push_etherhdr(oldskb, nskb);\r\nbr_deliver(br_port_get_rcu(oldskb->dev), nskb);\r\n}\r\nstatic void nft_reject_br_send_v4_unreach(struct sk_buff *oldskb, int hook,\r\nu8 code)\r\n{\r\nstruct sk_buff *nskb;\r\nstruct iphdr *niph;\r\nstruct icmphdr *icmph;\r\nunsigned int len;\r\nvoid *payload;\r\n__wsum csum;\r\nif (!nft_bridge_iphdr_validate(oldskb))\r\nreturn;\r\nif (ip_hdr(oldskb)->frag_off & htons(IP_OFFSET))\r\nreturn;\r\nlen = min_t(unsigned int, 536, oldskb->len);\r\nif (!pskb_may_pull(oldskb, len))\r\nreturn;\r\nif (nf_ip_checksum(oldskb, hook, ip_hdrlen(oldskb), 0))\r\nreturn;\r\nnskb = alloc_skb(sizeof(struct iphdr) + sizeof(struct icmphdr) +\r\nLL_MAX_HEADER + len, GFP_ATOMIC);\r\nif (!nskb)\r\nreturn;\r\nskb_reserve(nskb, LL_MAX_HEADER);\r\nniph = nf_reject_iphdr_put(nskb, oldskb, IPPROTO_ICMP,\r\nsysctl_ip_default_ttl);\r\nskb_reset_transport_header(nskb);\r\nicmph = (struct icmphdr *)skb_put(nskb, sizeof(struct icmphdr));\r\nmemset(icmph, 0, sizeof(*icmph));\r\nicmph->type = ICMP_DEST_UNREACH;\r\nicmph->code = code;\r\npayload = skb_put(nskb, len);\r\nmemcpy(payload, skb_network_header(oldskb), len);\r\ncsum = csum_partial((void *)icmph, len + sizeof(struct icmphdr), 0);\r\nicmph->checksum = csum_fold(csum);\r\nniph->tot_len = htons(nskb->len);\r\nip_send_check(niph);\r\nnft_reject_br_push_etherhdr(oldskb, nskb);\r\nbr_deliver(br_port_get_rcu(oldskb->dev), nskb);\r\n}\r\nstatic void nft_reject_br_send_v6_tcp_reset(struct net *net,\r\nstruct sk_buff *oldskb, int hook)\r\n{\r\nstruct sk_buff *nskb;\r\nconst struct tcphdr *oth;\r\nstruct tcphdr _oth;\r\nunsigned int otcplen;\r\nstruct ipv6hdr *nip6h;\r\nif (!nft_bridge_ip6hdr_validate(oldskb))\r\nreturn;\r\noth = nf_reject_ip6_tcphdr_get(oldskb, &_oth, &otcplen, hook);\r\nif (!oth)\r\nreturn;\r\nnskb = alloc_skb(sizeof(struct ipv6hdr) + sizeof(struct tcphdr) +\r\nLL_MAX_HEADER, GFP_ATOMIC);\r\nif (!nskb)\r\nreturn;\r\nskb_reserve(nskb, LL_MAX_HEADER);\r\nnip6h = nf_reject_ip6hdr_put(nskb, oldskb, IPPROTO_TCP,\r\nnet->ipv6.devconf_all->hop_limit);\r\nnf_reject_ip6_tcphdr_put(nskb, oldskb, oth, otcplen);\r\nnip6h->payload_len = htons(nskb->len - sizeof(struct ipv6hdr));\r\nnft_reject_br_push_etherhdr(oldskb, nskb);\r\nbr_deliver(br_port_get_rcu(oldskb->dev), nskb);\r\n}\r\nstatic void nft_reject_br_send_v6_unreach(struct net *net,\r\nstruct sk_buff *oldskb, int hook,\r\nu8 code)\r\n{\r\nstruct sk_buff *nskb;\r\nstruct ipv6hdr *nip6h;\r\nstruct icmp6hdr *icmp6h;\r\nunsigned int len;\r\nvoid *payload;\r\nif (!nft_bridge_ip6hdr_validate(oldskb))\r\nreturn;\r\nlen = min_t(unsigned int, 1220, oldskb->len);\r\nif (!pskb_may_pull(oldskb, len))\r\nreturn;\r\nnskb = alloc_skb(sizeof(struct iphdr) + sizeof(struct icmp6hdr) +\r\nLL_MAX_HEADER + len, GFP_ATOMIC);\r\nif (!nskb)\r\nreturn;\r\nskb_reserve(nskb, LL_MAX_HEADER);\r\nnip6h = nf_reject_ip6hdr_put(nskb, oldskb, IPPROTO_ICMPV6,\r\nnet->ipv6.devconf_all->hop_limit);\r\nskb_reset_transport_header(nskb);\r\nicmp6h = (struct icmp6hdr *)skb_put(nskb, sizeof(struct icmp6hdr));\r\nmemset(icmp6h, 0, sizeof(*icmp6h));\r\nicmp6h->icmp6_type = ICMPV6_DEST_UNREACH;\r\nicmp6h->icmp6_code = code;\r\npayload = skb_put(nskb, len);\r\nmemcpy(payload, skb_network_header(oldskb), len);\r\nnip6h->payload_len = htons(nskb->len - sizeof(struct ipv6hdr));\r\nicmp6h->icmp6_cksum =\r\ncsum_ipv6_magic(&nip6h->saddr, &nip6h->daddr,\r\nnskb->len - sizeof(struct ipv6hdr),\r\nIPPROTO_ICMPV6,\r\ncsum_partial(icmp6h,\r\nnskb->len - sizeof(struct ipv6hdr),\r\n0));\r\nnft_reject_br_push_etherhdr(oldskb, nskb);\r\nbr_deliver(br_port_get_rcu(oldskb->dev), nskb);\r\n}\r\nstatic void nft_reject_bridge_eval(const struct nft_expr *expr,\r\nstruct nft_data data[NFT_REG_MAX + 1],\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nstruct nft_reject *priv = nft_expr_priv(expr);\r\nstruct net *net = dev_net((pkt->in != NULL) ? pkt->in : pkt->out);\r\nconst unsigned char *dest = eth_hdr(pkt->skb)->h_dest;\r\nif (is_broadcast_ether_addr(dest) ||\r\nis_multicast_ether_addr(dest))\r\ngoto out;\r\nswitch (eth_hdr(pkt->skb)->h_proto) {\r\ncase htons(ETH_P_IP):\r\nswitch (priv->type) {\r\ncase NFT_REJECT_ICMP_UNREACH:\r\nnft_reject_br_send_v4_unreach(pkt->skb,\r\npkt->ops->hooknum,\r\npriv->icmp_code);\r\nbreak;\r\ncase NFT_REJECT_TCP_RST:\r\nnft_reject_br_send_v4_tcp_reset(pkt->skb,\r\npkt->ops->hooknum);\r\nbreak;\r\ncase NFT_REJECT_ICMPX_UNREACH:\r\nnft_reject_br_send_v4_unreach(pkt->skb,\r\npkt->ops->hooknum,\r\nnft_reject_icmp_code(priv->icmp_code));\r\nbreak;\r\n}\r\nbreak;\r\ncase htons(ETH_P_IPV6):\r\nswitch (priv->type) {\r\ncase NFT_REJECT_ICMP_UNREACH:\r\nnft_reject_br_send_v6_unreach(net, pkt->skb,\r\npkt->ops->hooknum,\r\npriv->icmp_code);\r\nbreak;\r\ncase NFT_REJECT_TCP_RST:\r\nnft_reject_br_send_v6_tcp_reset(net, pkt->skb,\r\npkt->ops->hooknum);\r\nbreak;\r\ncase NFT_REJECT_ICMPX_UNREACH:\r\nnft_reject_br_send_v6_unreach(net, pkt->skb,\r\npkt->ops->hooknum,\r\nnft_reject_icmpv6_code(priv->icmp_code));\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\ndata[NFT_REG_VERDICT].verdict = NF_DROP;\r\n}\r\nstatic int nft_reject_bridge_validate(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nft_data **data)\r\n{\r\nreturn nft_chain_validate_hooks(ctx->chain, (1 << NF_BR_PRE_ROUTING) |\r\n(1 << NF_BR_LOCAL_IN));\r\n}\r\nstatic int nft_reject_bridge_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_reject *priv = nft_expr_priv(expr);\r\nint icmp_code, err;\r\nerr = nft_reject_bridge_validate(ctx, expr, NULL);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[NFTA_REJECT_TYPE] == NULL)\r\nreturn -EINVAL;\r\npriv->type = ntohl(nla_get_be32(tb[NFTA_REJECT_TYPE]));\r\nswitch (priv->type) {\r\ncase NFT_REJECT_ICMP_UNREACH:\r\ncase NFT_REJECT_ICMPX_UNREACH:\r\nif (tb[NFTA_REJECT_ICMP_CODE] == NULL)\r\nreturn -EINVAL;\r\nicmp_code = nla_get_u8(tb[NFTA_REJECT_ICMP_CODE]);\r\nif (priv->type == NFT_REJECT_ICMPX_UNREACH &&\r\nicmp_code > NFT_REJECT_ICMPX_MAX)\r\nreturn -EINVAL;\r\npriv->icmp_code = icmp_code;\r\nbreak;\r\ncase NFT_REJECT_TCP_RST:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nft_reject_bridge_dump(struct sk_buff *skb,\r\nconst struct nft_expr *expr)\r\n{\r\nconst struct nft_reject *priv = nft_expr_priv(expr);\r\nif (nla_put_be32(skb, NFTA_REJECT_TYPE, htonl(priv->type)))\r\ngoto nla_put_failure;\r\nswitch (priv->type) {\r\ncase NFT_REJECT_ICMP_UNREACH:\r\ncase NFT_REJECT_ICMPX_UNREACH:\r\nif (nla_put_u8(skb, NFTA_REJECT_ICMP_CODE, priv->icmp_code))\r\ngoto nla_put_failure;\r\nbreak;\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int __init nft_reject_bridge_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_reject_bridge_type);\r\n}\r\nstatic void __exit nft_reject_bridge_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_reject_bridge_type);\r\n}
