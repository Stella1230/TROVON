short ieee80211_is_54g(const struct ieee80211_network *net)\r\n{\r\nreturn (net->rates_ex_len > 0) || (net->rates_len > 4);\r\n}\r\nshort ieee80211_is_shortslot(const struct ieee80211_network *net)\r\n{\r\nreturn net->capability & WLAN_CAPABILITY_SHORT_SLOT;\r\n}\r\nstatic unsigned int ieee80211_MFIE_rate_len(struct ieee80211_device *ieee)\r\n{\r\nunsigned int rate_len = 0;\r\nif (ieee->modulation & IEEE80211_CCK_MODULATION)\r\nrate_len = IEEE80211_CCK_RATE_LEN + 2;\r\nif (ieee->modulation & IEEE80211_OFDM_MODULATION)\r\nrate_len += IEEE80211_OFDM_RATE_LEN + 2;\r\nreturn rate_len;\r\n}\r\nstatic void ieee80211_MFIE_Brate(struct ieee80211_device *ieee, u8 **tag_p)\r\n{\r\nu8 *tag = *tag_p;\r\nif (ieee->modulation & IEEE80211_CCK_MODULATION){\r\n*tag++ = MFIE_TYPE_RATES;\r\n*tag++ = 4;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_1MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_2MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_5MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_11MB;\r\n}\r\n*tag_p = tag;\r\n}\r\nstatic void ieee80211_MFIE_Grate(struct ieee80211_device *ieee, u8 **tag_p)\r\n{\r\nu8 *tag = *tag_p;\r\nif (ieee->modulation & IEEE80211_OFDM_MODULATION){\r\n*tag++ = MFIE_TYPE_RATES_EX;\r\n*tag++ = 8;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_6MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_9MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_12MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_18MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_24MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_36MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_48MB;\r\n*tag++ = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_54MB;\r\n}\r\n*tag_p = tag;\r\n}\r\nstatic void ieee80211_WMM_Info(struct ieee80211_device *ieee, u8 **tag_p)\r\n{\r\nu8 *tag = *tag_p;\r\n*tag++ = MFIE_TYPE_GENERIC;\r\n*tag++ = 7;\r\n*tag++ = 0x00;\r\n*tag++ = 0x50;\r\n*tag++ = 0xf2;\r\n*tag++ = 0x02;\r\n*tag++ = 0x00;\r\n*tag++ = 0x01;\r\n#ifdef SUPPORT_USPD\r\nif(ieee->current_network.wmm_info & 0x80) {\r\n*tag++ = 0x0f|MAX_SP_Len;\r\n} else {\r\n*tag++ = MAX_SP_Len;\r\n}\r\n#else\r\n*tag++ = MAX_SP_Len;\r\n#endif\r\n*tag_p = tag;\r\n}\r\nstatic void ieee80211_TURBO_Info(struct ieee80211_device *ieee, u8 **tag_p)\r\n{\r\nu8 *tag = *tag_p;\r\n*tag++ = MFIE_TYPE_GENERIC;\r\n*tag++ = 7;\r\n*tag++ = 0x00;\r\n*tag++ = 0xe0;\r\n*tag++ = 0x4c;\r\n*tag++ = 0x01;\r\n*tag++ = 0x02;\r\n*tag++ = 0x11;\r\n*tag++ = 0x00;\r\n*tag_p = tag;\r\nprintk(KERN_ALERT "This is enable turbo mode IE process\n");\r\n}\r\nstatic void enqueue_mgmt(struct ieee80211_device *ieee, struct sk_buff *skb)\r\n{\r\nint nh;\r\nnh = (ieee->mgmt_queue_head +1) % MGMT_QUEUE_NUM;\r\nieee->mgmt_queue_head = nh;\r\nieee->mgmt_queue_ring[nh] = skb;\r\n}\r\nstatic struct sk_buff *dequeue_mgmt(struct ieee80211_device *ieee)\r\n{\r\nstruct sk_buff *ret;\r\nif(ieee->mgmt_queue_tail == ieee->mgmt_queue_head)\r\nreturn NULL;\r\nret = ieee->mgmt_queue_ring[ieee->mgmt_queue_tail];\r\nieee->mgmt_queue_tail =\r\n(ieee->mgmt_queue_tail+1) % MGMT_QUEUE_NUM;\r\nreturn ret;\r\n}\r\nstatic void init_mgmt_queue(struct ieee80211_device *ieee)\r\n{\r\nieee->mgmt_queue_tail = ieee->mgmt_queue_head = 0;\r\n}\r\nstatic u8 MgntQuery_MgntFrameTxRate(struct ieee80211_device *ieee)\r\n{\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\nu8 rate;\r\nif(pHTInfo->IOTAction & HT_IOT_ACT_MGNT_USE_CCK_6M)\r\nrate = 0x0c;\r\nelse\r\nrate = ieee->basic_rate & 0x7f;\r\nif(rate == 0){\r\nif(ieee->mode == IEEE_A||\r\nieee->mode== IEEE_N_5G||\r\n(ieee->mode== IEEE_N_24G&&!pHTInfo->bCurSuppCCK))\r\nrate = 0x0c;\r\nelse\r\nrate = 0x02;\r\n}\r\nreturn rate;\r\n}\r\ninline void softmac_mgmt_xmit(struct sk_buff *skb, struct ieee80211_device *ieee)\r\n{\r\nunsigned long flags;\r\nshort single = ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE;\r\nstruct ieee80211_hdr_3addr *header=\r\n(struct ieee80211_hdr_3addr *) skb->data;\r\ncb_desc *tcb_desc = (cb_desc *)(skb->cb + 8);\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nieee80211_sta_wakeup(ieee, 0);\r\ntcb_desc->queue_index = MGNT_QUEUE;\r\ntcb_desc->data_rate = MgntQuery_MgntFrameTxRate(ieee);\r\ntcb_desc->RATRIndex = 7;\r\ntcb_desc->bTxDisableRateFallBack = 1;\r\ntcb_desc->bTxUseDriverAssingedRate = 1;\r\nif(single){\r\nif(ieee->queue_stop){\r\nenqueue_mgmt(ieee, skb);\r\n}else{\r\nheader->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0]<<4);\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\nieee->dev->trans_start = jiffies;\r\nieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}else{\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nspin_lock_irqsave(&ieee->mgmt_tx_lock, flags);\r\nheader->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\nif(!ieee->check_nic_enough_desc(ieee->dev,tcb_desc->queue_index)||\\r\n(skb_queue_len(&ieee->skb_waitQ[tcb_desc->queue_index]) != 0)||\\r\n(ieee->queue_stop) ) {\r\nprintk("%s():insert to waitqueue!\n",__func__);\r\nskb_queue_tail(&ieee->skb_waitQ[tcb_desc->queue_index], skb);\r\n} else {\r\nieee->softmac_hard_start_xmit(skb, ieee->dev);\r\n}\r\nspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags);\r\n}\r\n}\r\ninline void softmac_ps_mgmt_xmit(struct sk_buff *skb, struct ieee80211_device *ieee)\r\n{\r\nshort single = ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE;\r\nstruct ieee80211_hdr_3addr *header =\r\n(struct ieee80211_hdr_3addr *) skb->data;\r\nif(single){\r\nheader->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\nieee->dev->trans_start = jiffies;\r\nieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);\r\n}else{\r\nheader->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\nieee->softmac_hard_start_xmit(skb, ieee->dev);\r\n}\r\n}\r\ninline struct sk_buff *ieee80211_probe_req(struct ieee80211_device *ieee)\r\n{\r\nunsigned int len, rate_len;\r\nu8 *tag;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_probe_request *req;\r\nlen = ieee->current_network.ssid_len;\r\nrate_len = ieee80211_MFIE_rate_len(ieee);\r\nskb = dev_alloc_skb(sizeof(struct ieee80211_probe_request) +\r\n2 + len + rate_len + ieee->tx_headroom);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, ieee->tx_headroom);\r\nreq = (struct ieee80211_probe_request *) skb_put(skb,sizeof(struct ieee80211_probe_request));\r\nreq->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_PROBE_REQ);\r\nreq->header.duration_id = 0;\r\nmemset(req->header.addr1, 0xff, ETH_ALEN);\r\nmemcpy(req->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nmemset(req->header.addr3, 0xff, ETH_ALEN);\r\ntag = (u8 *) skb_put(skb,len+2+rate_len);\r\n*tag++ = MFIE_TYPE_SSID;\r\n*tag++ = len;\r\nmemcpy(tag, ieee->current_network.ssid, len);\r\ntag += len;\r\nieee80211_MFIE_Brate(ieee,&tag);\r\nieee80211_MFIE_Grate(ieee,&tag);\r\nreturn skb;\r\n}\r\nstatic void ieee80211_send_beacon(struct ieee80211_device *ieee)\r\n{\r\nstruct sk_buff *skb;\r\nif(!ieee->ieee_up)\r\nreturn;\r\nskb = ieee80211_get_beacon_(ieee);\r\nif (skb){\r\nsoftmac_mgmt_xmit(skb, ieee);\r\nieee->softmac_stats.tx_beacons++;\r\n}\r\nif(ieee->beacon_txing && ieee->ieee_up){\r\nmod_timer(&ieee->beacon_timer,jiffies+(MSECS(ieee->current_network.beacon_interval-5)));\r\n}\r\n}\r\nstatic void ieee80211_send_beacon_cb(unsigned long _ieee)\r\n{\r\nstruct ieee80211_device *ieee =\r\n(struct ieee80211_device *) _ieee;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ieee->beacon_lock, flags);\r\nieee80211_send_beacon(ieee);\r\nspin_unlock_irqrestore(&ieee->beacon_lock, flags);\r\n}\r\nstatic void ieee80211_send_probe(struct ieee80211_device *ieee)\r\n{\r\nstruct sk_buff *skb;\r\nskb = ieee80211_probe_req(ieee);\r\nif (skb){\r\nsoftmac_mgmt_xmit(skb, ieee);\r\nieee->softmac_stats.tx_probe_rq++;\r\n}\r\n}\r\nstatic void ieee80211_send_probe_requests(struct ieee80211_device *ieee)\r\n{\r\nif (ieee->active_scan && (ieee->softmac_features & IEEE_SOFTMAC_PROBERQ)){\r\nieee80211_send_probe(ieee);\r\nieee80211_send_probe(ieee);\r\n}\r\n}\r\nvoid ieee80211_softmac_scan_syncro(struct ieee80211_device *ieee)\r\n{\r\nshort ch = 0;\r\nu8 channel_map[MAX_CHANNEL_NUMBER+1];\r\nmemcpy(channel_map, GET_DOT11D_INFO(ieee)->channel_map, MAX_CHANNEL_NUMBER+1);\r\ndown(&ieee->scan_sem);\r\nwhile(1)\r\n{\r\ndo{\r\nch++;\r\nif (ch > MAX_CHANNEL_NUMBER)\r\ngoto out;\r\n}while(!channel_map[ch]);\r\nif (ieee->state == IEEE80211_LINKED)\r\ngoto out;\r\nieee->set_chan(ieee->dev, ch);\r\nif(channel_map[ch] == 1)\r\nieee80211_send_probe_requests(ieee);\r\nif(ieee->state < IEEE80211_LINKED)\r\n;\r\nelse\r\nif (ieee->sync_scan_hurryup)\r\ngoto out;\r\nmsleep_interruptible_rsl(IEEE80211_SOFTMAC_SCAN_TIME);\r\n}\r\nout:\r\nif(ieee->state < IEEE80211_LINKED){\r\nieee->actscanning = false;\r\nup(&ieee->scan_sem);\r\n}\r\nelse{\r\nieee->sync_scan_hurryup = 0;\r\nif(IS_DOT11D_ENABLE(ieee))\r\nDOT11D_ScanComplete(ieee);\r\nup(&ieee->scan_sem);\r\n}\r\n}\r\nstatic void ieee80211_softmac_scan_wq(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = container_of(work, struct delayed_work, work);\r\nstruct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, softmac_scan_wq);\r\nstatic short watchdog;\r\nu8 channel_map[MAX_CHANNEL_NUMBER+1];\r\nmemcpy(channel_map, GET_DOT11D_INFO(ieee)->channel_map, MAX_CHANNEL_NUMBER+1);\r\nif(!ieee->ieee_up)\r\nreturn;\r\ndown(&ieee->scan_sem);\r\ndo{\r\nieee->current_network.channel =\r\n(ieee->current_network.channel + 1) % MAX_CHANNEL_NUMBER;\r\nif (watchdog++ > MAX_CHANNEL_NUMBER)\r\n{\r\nif (!channel_map[ieee->current_network.channel]) {\r\nieee->current_network.channel = 6;\r\ngoto out;\r\n}\r\n}\r\n}while(!channel_map[ieee->current_network.channel]);\r\nif (ieee->scanning == 0 )\r\ngoto out;\r\nieee->set_chan(ieee->dev, ieee->current_network.channel);\r\nif(channel_map[ieee->current_network.channel] == 1)\r\nieee80211_send_probe_requests(ieee);\r\nqueue_delayed_work(ieee->wq, &ieee->softmac_scan_wq, IEEE80211_SOFTMAC_SCAN_TIME);\r\nup(&ieee->scan_sem);\r\nreturn;\r\nout:\r\nif(IS_DOT11D_ENABLE(ieee))\r\nDOT11D_ScanComplete(ieee);\r\nieee->actscanning = false;\r\nwatchdog = 0;\r\nieee->scanning = 0;\r\nup(&ieee->scan_sem);\r\n}\r\nstatic void ieee80211_beacons_start(struct ieee80211_device *ieee)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ieee->beacon_lock,flags);\r\nieee->beacon_txing = 1;\r\nieee80211_send_beacon(ieee);\r\nspin_unlock_irqrestore(&ieee->beacon_lock, flags);\r\n}\r\nstatic void ieee80211_beacons_stop(struct ieee80211_device *ieee)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ieee->beacon_lock, flags);\r\nieee->beacon_txing = 0;\r\ndel_timer_sync(&ieee->beacon_timer);\r\nspin_unlock_irqrestore(&ieee->beacon_lock, flags);\r\n}\r\nvoid ieee80211_stop_send_beacons(struct ieee80211_device *ieee)\r\n{\r\nif(ieee->stop_send_beacons)\r\nieee->stop_send_beacons(ieee->dev);\r\nif (ieee->softmac_features & IEEE_SOFTMAC_BEACONS)\r\nieee80211_beacons_stop(ieee);\r\n}\r\nvoid ieee80211_start_send_beacons(struct ieee80211_device *ieee)\r\n{\r\nif(ieee->start_send_beacons)\r\nieee->start_send_beacons(ieee->dev, ieee->basic_rate);\r\nif(ieee->softmac_features & IEEE_SOFTMAC_BEACONS)\r\nieee80211_beacons_start(ieee);\r\n}\r\nstatic void ieee80211_softmac_stop_scan(struct ieee80211_device *ieee)\r\n{\r\ndown(&ieee->scan_sem);\r\nif (ieee->scanning == 1){\r\nieee->scanning = 0;\r\ncancel_delayed_work(&ieee->softmac_scan_wq);\r\n}\r\nup(&ieee->scan_sem);\r\n}\r\nvoid ieee80211_stop_scan(struct ieee80211_device *ieee)\r\n{\r\nif (ieee->softmac_features & IEEE_SOFTMAC_SCAN)\r\nieee80211_softmac_stop_scan(ieee);\r\nelse\r\nieee->stop_scan(ieee->dev);\r\n}\r\nstatic void ieee80211_start_scan(struct ieee80211_device *ieee)\r\n{\r\nif(IS_DOT11D_ENABLE(ieee) )\r\n{\r\nif(IS_COUNTRY_IE_VALID(ieee))\r\n{\r\nRESET_CIE_WATCHDOG(ieee);\r\n}\r\n}\r\nif (ieee->softmac_features & IEEE_SOFTMAC_SCAN){\r\nif (ieee->scanning == 0){\r\nieee->scanning = 1;\r\nqueue_delayed_work(ieee->wq, &ieee->softmac_scan_wq, 0);\r\n}\r\n}else\r\nieee->start_scan(ieee->dev);\r\n}\r\nvoid ieee80211_start_scan_syncro(struct ieee80211_device *ieee)\r\n{\r\nif(IS_DOT11D_ENABLE(ieee) )\r\n{\r\nif(IS_COUNTRY_IE_VALID(ieee))\r\n{\r\nRESET_CIE_WATCHDOG(ieee);\r\n}\r\n}\r\nieee->sync_scan_hurryup = 0;\r\nif (ieee->softmac_features & IEEE_SOFTMAC_SCAN)\r\nieee80211_softmac_scan_syncro(ieee);\r\nelse\r\nieee->scan_syncro(ieee->dev);\r\n}\r\ninline struct sk_buff *ieee80211_authentication_req(struct ieee80211_network *beacon,\r\nstruct ieee80211_device *ieee, int challengelen)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_authentication *auth;\r\nint len = sizeof(struct ieee80211_authentication) + challengelen + ieee->tx_headroom;\r\nskb = dev_alloc_skb(len);\r\nif (!skb) return NULL;\r\nskb_reserve(skb, ieee->tx_headroom);\r\nauth = (struct ieee80211_authentication *)\r\nskb_put(skb, sizeof(struct ieee80211_authentication));\r\nauth->header.frame_ctl = IEEE80211_STYPE_AUTH;\r\nif (challengelen) auth->header.frame_ctl |= IEEE80211_FCTL_WEP;\r\nauth->header.duration_id = 0x013a;\r\nmemcpy(auth->header.addr1, beacon->bssid, ETH_ALEN);\r\nmemcpy(auth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy(auth->header.addr3, beacon->bssid, ETH_ALEN);\r\nif(ieee->auth_mode == 0)\r\nauth->algorithm = WLAN_AUTH_OPEN;\r\nelse if(ieee->auth_mode == 1)\r\nauth->algorithm = WLAN_AUTH_SHARED_KEY;\r\nelse if(ieee->auth_mode == 2)\r\nauth->algorithm = WLAN_AUTH_OPEN;\r\nprintk("=================>%s():auth->algorithm is %d\n",__func__,auth->algorithm);\r\nauth->transaction = cpu_to_le16(ieee->associate_seq);\r\nieee->associate_seq++;\r\nauth->status = cpu_to_le16(WLAN_STATUS_SUCCESS);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *ieee80211_probe_resp(struct ieee80211_device *ieee, u8 *dest)\r\n{\r\nu8 *tag;\r\nint beacon_size;\r\nstruct ieee80211_probe_response *beacon_buf;\r\nstruct sk_buff *skb = NULL;\r\nint encrypt;\r\nint atim_len, erp_len;\r\nstruct ieee80211_crypt_data *crypt;\r\nchar *ssid = ieee->current_network.ssid;\r\nint ssid_len = ieee->current_network.ssid_len;\r\nint rate_len = ieee->current_network.rates_len+2;\r\nint rate_ex_len = ieee->current_network.rates_ex_len;\r\nint wpa_ie_len = ieee->wpa_ie_len;\r\nu8 erpinfo_content = 0;\r\nu8 *tmp_ht_cap_buf;\r\nu8 tmp_ht_cap_len=0;\r\nu8 *tmp_ht_info_buf;\r\nu8 tmp_ht_info_len=0;\r\nPRT_HIGH_THROUGHPUT pHTInfo = ieee->pHTInfo;\r\nu8 *tmp_generic_ie_buf=NULL;\r\nu8 tmp_generic_ie_len=0;\r\nif(rate_ex_len > 0) rate_ex_len+=2;\r\nif(ieee->current_network.capability & WLAN_CAPABILITY_IBSS)\r\natim_len = 4;\r\nelse\r\natim_len = 0;\r\nif(ieee80211_is_54g(&ieee->current_network))\r\nerp_len = 3;\r\nelse\r\nerp_len = 0;\r\ncrypt = ieee->crypt[ieee->tx_keyidx];\r\nencrypt = ieee->host_encrypt && crypt && crypt->ops &&\r\n((0 == strcmp(crypt->ops->name, "WEP") || wpa_ie_len));\r\ntmp_ht_cap_buf =(u8 *) &(ieee->pHTInfo->SelfHTCap);\r\ntmp_ht_cap_len = sizeof(ieee->pHTInfo->SelfHTCap);\r\ntmp_ht_info_buf =(u8 *) &(ieee->pHTInfo->SelfHTInfo);\r\ntmp_ht_info_len = sizeof(ieee->pHTInfo->SelfHTInfo);\r\nHTConstructCapabilityElement(ieee, tmp_ht_cap_buf, &tmp_ht_cap_len,encrypt);\r\nHTConstructInfoElement(ieee,tmp_ht_info_buf,&tmp_ht_info_len, encrypt);\r\nif(pHTInfo->bRegRT2RTAggregation)\r\n{\r\ntmp_generic_ie_buf = ieee->pHTInfo->szRT2RTAggBuffer;\r\ntmp_generic_ie_len = sizeof(ieee->pHTInfo->szRT2RTAggBuffer);\r\nHTConstructRT2RTAggElement(ieee, tmp_generic_ie_buf, &tmp_generic_ie_len);\r\n}\r\nbeacon_size = sizeof(struct ieee80211_probe_response)+2+\r\nssid_len\r\n+3\r\n+rate_len\r\n+rate_ex_len\r\n+atim_len\r\n+erp_len\r\n+wpa_ie_len\r\n+ieee->tx_headroom;\r\nskb = dev_alloc_skb(beacon_size);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, ieee->tx_headroom);\r\nbeacon_buf = (struct ieee80211_probe_response *) skb_put(skb, (beacon_size - ieee->tx_headroom));\r\nmemcpy (beacon_buf->header.addr1, dest,ETH_ALEN);\r\nmemcpy (beacon_buf->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy (beacon_buf->header.addr3, ieee->current_network.bssid, ETH_ALEN);\r\nbeacon_buf->header.duration_id = 0;\r\nbeacon_buf->beacon_interval =\r\ncpu_to_le16(ieee->current_network.beacon_interval);\r\nbeacon_buf->capability =\r\ncpu_to_le16(ieee->current_network.capability & WLAN_CAPABILITY_IBSS);\r\nbeacon_buf->capability |=\r\ncpu_to_le16(ieee->current_network.capability & WLAN_CAPABILITY_SHORT_PREAMBLE);\r\nif(ieee->short_slot && (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_SLOT))\r\nbeacon_buf->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT);\r\ncrypt = ieee->crypt[ieee->tx_keyidx];\r\nif (encrypt)\r\nbeacon_buf->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);\r\nbeacon_buf->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_PROBE_RESP);\r\nbeacon_buf->info_element[0].id = MFIE_TYPE_SSID;\r\nbeacon_buf->info_element[0].len = ssid_len;\r\ntag = (u8 *) beacon_buf->info_element[0].data;\r\nmemcpy(tag, ssid, ssid_len);\r\ntag += ssid_len;\r\n*(tag++) = MFIE_TYPE_RATES;\r\n*(tag++) = rate_len-2;\r\nmemcpy(tag, ieee->current_network.rates, rate_len-2);\r\ntag+=rate_len-2;\r\n*(tag++) = MFIE_TYPE_DS_SET;\r\n*(tag++) = 1;\r\n*(tag++) = ieee->current_network.channel;\r\nif(atim_len){\r\n*(tag++) = MFIE_TYPE_IBSS_SET;\r\n*(tag++) = 2;\r\nput_unaligned_le16(ieee->current_network.atim_window,\r\n(u8 *)tag);\r\ntag+=2;\r\n}\r\nif(erp_len){\r\n*(tag++) = MFIE_TYPE_ERP;\r\n*(tag++) = 1;\r\n*(tag++) = erpinfo_content;\r\n}\r\nif(rate_ex_len){\r\n*(tag++) = MFIE_TYPE_RATES_EX;\r\n*(tag++) = rate_ex_len-2;\r\nmemcpy(tag, ieee->current_network.rates_ex, rate_ex_len-2);\r\ntag+=rate_ex_len-2;\r\n}\r\nif (wpa_ie_len)\r\n{\r\nif (ieee->iw_mode == IW_MODE_ADHOC)\r\n{\r\nmemcpy(&ieee->wpa_ie[14], &ieee->wpa_ie[8], 4);\r\n}\r\nmemcpy(tag, ieee->wpa_ie, ieee->wpa_ie_len);\r\ntag += wpa_ie_len;\r\n}\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *ieee80211_assoc_resp(struct ieee80211_device *ieee,\r\nu8 *dest)\r\n{\r\nstruct sk_buff *skb;\r\nu8 *tag;\r\nstruct ieee80211_crypt_data *crypt;\r\nstruct ieee80211_assoc_response_frame *assoc;\r\nshort encrypt;\r\nunsigned int rate_len = ieee80211_MFIE_rate_len(ieee);\r\nint len = sizeof(struct ieee80211_assoc_response_frame) + rate_len + ieee->tx_headroom;\r\nskb = dev_alloc_skb(len);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, ieee->tx_headroom);\r\nassoc = (struct ieee80211_assoc_response_frame *)\r\nskb_put(skb, sizeof(struct ieee80211_assoc_response_frame));\r\nassoc->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_ASSOC_RESP);\r\nmemcpy(assoc->header.addr1, dest,ETH_ALEN);\r\nmemcpy(assoc->header.addr3, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy(assoc->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nassoc->capability = cpu_to_le16(ieee->iw_mode == IW_MODE_MASTER ?\r\nWLAN_CAPABILITY_BSS : WLAN_CAPABILITY_IBSS);\r\nif(ieee->short_slot)\r\nassoc->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT);\r\nif (ieee->host_encrypt)\r\ncrypt = ieee->crypt[ieee->tx_keyidx];\r\nelse crypt = NULL;\r\nencrypt = (crypt && crypt->ops);\r\nif (encrypt)\r\nassoc->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);\r\nassoc->status = 0;\r\nassoc->aid = cpu_to_le16(ieee->assoc_id);\r\nif (ieee->assoc_id == 0x2007) ieee->assoc_id=0;\r\nelse ieee->assoc_id++;\r\ntag = (u8 *) skb_put(skb, rate_len);\r\nieee80211_MFIE_Brate(ieee, &tag);\r\nieee80211_MFIE_Grate(ieee, &tag);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *ieee80211_auth_resp(struct ieee80211_device *ieee,\r\nint status, u8 *dest)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_authentication *auth;\r\nint len = ieee->tx_headroom + sizeof(struct ieee80211_authentication)+1;\r\nskb = dev_alloc_skb(len);\r\nif (!skb)\r\nreturn NULL;\r\nskb->len = sizeof(struct ieee80211_authentication);\r\nauth = (struct ieee80211_authentication *)skb->data;\r\nauth->status = cpu_to_le16(status);\r\nauth->transaction = cpu_to_le16(2);\r\nauth->algorithm = cpu_to_le16(WLAN_AUTH_OPEN);\r\nmemcpy(auth->header.addr3, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy(auth->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy(auth->header.addr1, dest, ETH_ALEN);\r\nauth->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_AUTH);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *ieee80211_null_func(struct ieee80211_device *ieee,\r\nshort pwr)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_hdr_3addr *hdr;\r\nskb = dev_alloc_skb(sizeof(struct ieee80211_hdr_3addr));\r\nif (!skb)\r\nreturn NULL;\r\nhdr = (struct ieee80211_hdr_3addr *)skb_put(skb,sizeof(struct ieee80211_hdr_3addr));\r\nmemcpy(hdr->addr1, ieee->current_network.bssid, ETH_ALEN);\r\nmemcpy(hdr->addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy(hdr->addr3, ieee->current_network.bssid, ETH_ALEN);\r\nhdr->frame_ctl = cpu_to_le16(IEEE80211_FTYPE_DATA |\r\nIEEE80211_STYPE_NULLFUNC | IEEE80211_FCTL_TODS |\r\n(pwr ? IEEE80211_FCTL_PM:0));\r\nreturn skb;\r\n}\r\nstatic void ieee80211_resp_to_assoc_rq(struct ieee80211_device *ieee, u8 *dest)\r\n{\r\nstruct sk_buff *buf = ieee80211_assoc_resp(ieee, dest);\r\nif (buf)\r\nsoftmac_mgmt_xmit(buf, ieee);\r\n}\r\nstatic void ieee80211_resp_to_auth(struct ieee80211_device *ieee, int s,\r\nu8 *dest)\r\n{\r\nstruct sk_buff *buf = ieee80211_auth_resp(ieee, s, dest);\r\nif (buf)\r\nsoftmac_mgmt_xmit(buf, ieee);\r\n}\r\nstatic void ieee80211_resp_to_probe(struct ieee80211_device *ieee, u8 *dest)\r\n{\r\nstruct sk_buff *buf = ieee80211_probe_resp(ieee, dest);\r\nif (buf)\r\nsoftmac_mgmt_xmit(buf, ieee);\r\n}\r\ninline struct sk_buff *ieee80211_association_req(struct ieee80211_network *beacon,struct ieee80211_device *ieee)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_assoc_request_frame *hdr;\r\nu8 *tag;\r\nu8 *ht_cap_buf = NULL;\r\nu8 ht_cap_len=0;\r\nu8 *realtek_ie_buf=NULL;\r\nu8 realtek_ie_len=0;\r\nint wpa_ie_len= ieee->wpa_ie_len;\r\nunsigned int ckip_ie_len=0;\r\nunsigned int ccxrm_ie_len=0;\r\nunsigned int cxvernum_ie_len=0;\r\nstruct ieee80211_crypt_data *crypt;\r\nint encrypt;\r\nunsigned int rate_len = ieee80211_MFIE_rate_len(ieee);\r\nunsigned int wmm_info_len = beacon->qos_data.supported?9:0;\r\n#ifdef THOMAS_TURBO\r\nunsigned int turbo_info_len = beacon->Turbo_Enable?9:0;\r\n#endif\r\nint len = 0;\r\ncrypt = ieee->crypt[ieee->tx_keyidx];\r\nencrypt = ieee->host_encrypt && crypt && crypt->ops && ((0 == strcmp(crypt->ops->name,"WEP") || wpa_ie_len));\r\nif(ieee->pHTInfo->bCurrentHTSupport&&ieee->pHTInfo->bEnableHT)\r\n{\r\nht_cap_buf = (u8 *)&(ieee->pHTInfo->SelfHTCap);\r\nht_cap_len = sizeof(ieee->pHTInfo->SelfHTCap);\r\nHTConstructCapabilityElement(ieee, ht_cap_buf, &ht_cap_len, encrypt);\r\nif(ieee->pHTInfo->bCurrentRT2RTAggregation)\r\n{\r\nrealtek_ie_buf = ieee->pHTInfo->szRT2RTAggBuffer;\r\nrealtek_ie_len = sizeof( ieee->pHTInfo->szRT2RTAggBuffer);\r\nHTConstructRT2RTAggElement(ieee, realtek_ie_buf, &realtek_ie_len);\r\n}\r\n}\r\nif(ieee->qos_support){\r\nwmm_info_len = beacon->qos_data.supported?9:0;\r\n}\r\nif(beacon->bCkipSupported)\r\n{\r\nckip_ie_len = 30+2;\r\n}\r\nif(beacon->bCcxRmEnable)\r\n{\r\nccxrm_ie_len = 6+2;\r\n}\r\nif (beacon->BssCcxVerNumber >= 2)\r\ncxvernum_ie_len = 5+2;\r\n#ifdef THOMAS_TURBO\r\nlen = sizeof(struct ieee80211_assoc_request_frame)+ 2\r\n+ beacon->ssid_len\r\n+ rate_len\r\n+ wpa_ie_len\r\n+ wmm_info_len\r\n+ turbo_info_len\r\n+ ht_cap_len\r\n+ realtek_ie_len\r\n+ ckip_ie_len\r\n+ ccxrm_ie_len\r\n+ cxvernum_ie_len\r\n+ ieee->tx_headroom;\r\n#else\r\nlen = sizeof(struct ieee80211_assoc_request_frame)+ 2\r\n+ beacon->ssid_len\r\n+ rate_len\r\n+ wpa_ie_len\r\n+ wmm_info_len\r\n+ ht_cap_len\r\n+ realtek_ie_len\r\n+ ckip_ie_len\r\n+ ccxrm_ie_len\r\n+ cxvernum_ie_len\r\n+ ieee->tx_headroom;\r\n#endif\r\nskb = dev_alloc_skb(len);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, ieee->tx_headroom);\r\nhdr = (struct ieee80211_assoc_request_frame *)\r\nskb_put(skb, sizeof(struct ieee80211_assoc_request_frame)+2);\r\nhdr->header.frame_ctl = IEEE80211_STYPE_ASSOC_REQ;\r\nhdr->header.duration_id= 37;\r\nmemcpy(hdr->header.addr1, beacon->bssid, ETH_ALEN);\r\nmemcpy(hdr->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy(hdr->header.addr3, beacon->bssid, ETH_ALEN);\r\nmemcpy(ieee->ap_mac_addr, beacon->bssid, ETH_ALEN);\r\nhdr->capability = cpu_to_le16(WLAN_CAPABILITY_BSS);\r\nif (beacon->capability & WLAN_CAPABILITY_PRIVACY )\r\nhdr->capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);\r\nif (beacon->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)\r\nhdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_PREAMBLE);\r\nif(ieee->short_slot)\r\nhdr->capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT);\r\nif (wmm_info_len)\r\nhdr->capability |= cpu_to_le16(WLAN_CAPABILITY_QOS);\r\nhdr->listen_interval = 0xa;\r\nhdr->info_element[0].id = MFIE_TYPE_SSID;\r\nhdr->info_element[0].len = beacon->ssid_len;\r\ntag = skb_put(skb, beacon->ssid_len);\r\nmemcpy(tag, beacon->ssid, beacon->ssid_len);\r\ntag = skb_put(skb, rate_len);\r\nieee80211_MFIE_Brate(ieee, &tag);\r\nieee80211_MFIE_Grate(ieee, &tag);\r\nif (beacon->bCkipSupported) {\r\nstatic u8 AironetIeOui[] = {0x00, 0x01, 0x66};\r\nu8 CcxAironetBuf[30];\r\nOCTET_STRING osCcxAironetIE;\r\nmemset(CcxAironetBuf, 0, 30);\r\nosCcxAironetIE.Octet = CcxAironetBuf;\r\nosCcxAironetIE.Length = sizeof(CcxAironetBuf);\r\nmemcpy(osCcxAironetIE.Octet, AironetIeOui, sizeof(AironetIeOui));\r\nosCcxAironetIE.Octet[IE_CISCO_FLAG_POSITION] |= (SUPPORT_CKIP_PK|SUPPORT_CKIP_MIC) ;\r\ntag = skb_put(skb, ckip_ie_len);\r\n*tag++ = MFIE_TYPE_AIRONET;\r\n*tag++ = osCcxAironetIE.Length;\r\nmemcpy(tag, osCcxAironetIE.Octet, osCcxAironetIE.Length);\r\ntag += osCcxAironetIE.Length;\r\n}\r\nif(beacon->bCcxRmEnable)\r\n{\r\nstatic u8 CcxRmCapBuf[] = {0x00, 0x40, 0x96, 0x01, 0x01, 0x00};\r\nOCTET_STRING osCcxRmCap;\r\nosCcxRmCap.Octet = CcxRmCapBuf;\r\nosCcxRmCap.Length = sizeof(CcxRmCapBuf);\r\ntag = skb_put(skb, ccxrm_ie_len);\r\n*tag++ = MFIE_TYPE_GENERIC;\r\n*tag++ = osCcxRmCap.Length;\r\nmemcpy(tag, osCcxRmCap.Octet, osCcxRmCap.Length);\r\ntag += osCcxRmCap.Length;\r\n}\r\nif (beacon->BssCcxVerNumber >= 2) {\r\nu8 CcxVerNumBuf[] = {0x00, 0x40, 0x96, 0x03, 0x00};\r\nOCTET_STRING osCcxVerNum;\r\nCcxVerNumBuf[4] = beacon->BssCcxVerNumber;\r\nosCcxVerNum.Octet = CcxVerNumBuf;\r\nosCcxVerNum.Length = sizeof(CcxVerNumBuf);\r\ntag = skb_put(skb, cxvernum_ie_len);\r\n*tag++ = MFIE_TYPE_GENERIC;\r\n*tag++ = osCcxVerNum.Length;\r\nmemcpy(tag, osCcxVerNum.Octet, osCcxVerNum.Length);\r\ntag += osCcxVerNum.Length;\r\n}\r\nif(ieee->pHTInfo->bCurrentHTSupport&&ieee->pHTInfo->bEnableHT){\r\nif(ieee->pHTInfo->ePeerHTSpecVer != HT_SPEC_VER_EWC)\r\n{\r\ntag = skb_put(skb, ht_cap_len);\r\n*tag++ = MFIE_TYPE_HT_CAP;\r\n*tag++ = ht_cap_len - 2;\r\nmemcpy(tag, ht_cap_buf,ht_cap_len -2);\r\ntag += ht_cap_len -2;\r\n}\r\n}\r\ntag = skb_put(skb, wpa_ie_len);\r\nif (wpa_ie_len){\r\nmemcpy(tag, ieee->wpa_ie, ieee->wpa_ie_len);\r\n}\r\ntag = skb_put(skb, wmm_info_len);\r\nif(wmm_info_len) {\r\nieee80211_WMM_Info(ieee, &tag);\r\n}\r\n#ifdef THOMAS_TURBO\r\ntag = skb_put(skb, turbo_info_len);\r\nif(turbo_info_len) {\r\nieee80211_TURBO_Info(ieee, &tag);\r\n}\r\n#endif\r\nif(ieee->pHTInfo->bCurrentHTSupport&&ieee->pHTInfo->bEnableHT){\r\nif(ieee->pHTInfo->ePeerHTSpecVer == HT_SPEC_VER_EWC)\r\n{\r\ntag = skb_put(skb, ht_cap_len);\r\n*tag++ = MFIE_TYPE_GENERIC;\r\n*tag++ = ht_cap_len - 2;\r\nmemcpy(tag, ht_cap_buf, ht_cap_len - 2);\r\ntag += ht_cap_len -2;\r\n}\r\nif(ieee->pHTInfo->bCurrentRT2RTAggregation){\r\ntag = skb_put(skb, realtek_ie_len);\r\n*tag++ = MFIE_TYPE_GENERIC;\r\n*tag++ = realtek_ie_len - 2;\r\nmemcpy(tag, realtek_ie_buf,realtek_ie_len -2 );\r\n}\r\n}\r\nreturn skb;\r\n}\r\nvoid ieee80211_associate_abort(struct ieee80211_device *ieee)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nieee->associate_seq++;\r\nif (ieee->state == IEEE80211_ASSOCIATING_AUTHENTICATING){\r\nIEEE80211_DEBUG_MGMT("Authentication failed\n");\r\nieee->softmac_stats.no_auth_rs++;\r\n}else{\r\nIEEE80211_DEBUG_MGMT("Association failed\n");\r\nieee->softmac_stats.no_ass_rs++;\r\n}\r\nieee->state = IEEE80211_ASSOCIATING_RETRY;\r\nqueue_delayed_work(ieee->wq, &ieee->associate_retry_wq, \\r\nIEEE80211_SOFTMAC_ASSOC_RETRY_TIME);\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nstatic void ieee80211_associate_abort_cb(unsigned long dev)\r\n{\r\nieee80211_associate_abort((struct ieee80211_device *) dev);\r\n}\r\nstatic void ieee80211_associate_step1(struct ieee80211_device *ieee)\r\n{\r\nstruct ieee80211_network *beacon = &ieee->current_network;\r\nstruct sk_buff *skb;\r\nIEEE80211_DEBUG_MGMT("Stopping scan\n");\r\nieee->softmac_stats.tx_auth_rq++;\r\nskb=ieee80211_authentication_req(beacon, ieee, 0);\r\nif (!skb)\r\nieee80211_associate_abort(ieee);\r\nelse{\r\nieee->state = IEEE80211_ASSOCIATING_AUTHENTICATING ;\r\nIEEE80211_DEBUG_MGMT("Sending authentication request\n");\r\nsoftmac_mgmt_xmit(skb, ieee);\r\nif(!timer_pending(&ieee->associate_timer)){\r\nieee->associate_timer.expires = jiffies + (HZ / 2);\r\nadd_timer(&ieee->associate_timer);\r\n}\r\n}\r\n}\r\nstatic void ieee80211_auth_challenge(struct ieee80211_device *ieee,\r\nu8 *challenge,\r\nint chlen)\r\n{\r\nu8 *c;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_network *beacon = &ieee->current_network;\r\nieee->associate_seq++;\r\nieee->softmac_stats.tx_auth_rq++;\r\nskb = ieee80211_authentication_req(beacon, ieee, chlen+2);\r\nif (!skb)\r\nieee80211_associate_abort(ieee);\r\nelse{\r\nc = skb_put(skb, chlen+2);\r\n*(c++) = MFIE_TYPE_CHALLENGE;\r\n*(c++) = chlen;\r\nmemcpy(c, challenge, chlen);\r\nIEEE80211_DEBUG_MGMT("Sending authentication challenge response\n");\r\nieee80211_encrypt_fragment(ieee, skb, sizeof(struct ieee80211_hdr_3addr ));\r\nsoftmac_mgmt_xmit(skb, ieee);\r\nmod_timer(&ieee->associate_timer, jiffies + (HZ/2));\r\n}\r\nkfree(challenge);\r\n}\r\nstatic void ieee80211_associate_step2(struct ieee80211_device *ieee)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_network *beacon = &ieee->current_network;\r\ndel_timer_sync(&ieee->associate_timer);\r\nIEEE80211_DEBUG_MGMT("Sending association request\n");\r\nieee->softmac_stats.tx_ass_rq++;\r\nskb=ieee80211_association_req(beacon, ieee);\r\nif (!skb)\r\nieee80211_associate_abort(ieee);\r\nelse{\r\nsoftmac_mgmt_xmit(skb, ieee);\r\nmod_timer(&ieee->associate_timer, jiffies + (HZ/2));\r\n}\r\n}\r\nstatic void ieee80211_associate_complete_wq(struct work_struct *work)\r\n{\r\nstruct ieee80211_device *ieee = container_of(work, struct ieee80211_device, associate_complete_wq);\r\nprintk(KERN_INFO "Associated successfully\n");\r\nif(ieee80211_is_54g(&ieee->current_network) &&\r\n(ieee->modulation & IEEE80211_OFDM_MODULATION)){\r\nieee->rate = 108;\r\nprintk(KERN_INFO"Using G rates:%d\n", ieee->rate);\r\n}else{\r\nieee->rate = 22;\r\nprintk(KERN_INFO"Using B rates:%d\n", ieee->rate);\r\n}\r\nif (ieee->pHTInfo->bCurrentHTSupport&&ieee->pHTInfo->bEnableHT)\r\n{\r\nprintk("Successfully associated, ht enabled\n");\r\nHTOnAssocRsp(ieee);\r\n}\r\nelse\r\n{\r\nprintk("Successfully associated, ht not enabled(%d, %d)\n", ieee->pHTInfo->bCurrentHTSupport, ieee->pHTInfo->bEnableHT);\r\nmemset(ieee->dot11HTOperationalRateSet, 0, 16);\r\n}\r\nieee->LinkDetectInfo.SlotNum = 2 * (1 + ieee->current_network.beacon_interval/500);\r\nif(ieee->LinkDetectInfo.NumRecvBcnInPeriod==0||ieee->LinkDetectInfo.NumRecvDataInPeriod==0 )\r\n{\r\nieee->LinkDetectInfo.NumRecvBcnInPeriod = 1;\r\nieee->LinkDetectInfo.NumRecvDataInPeriod= 1;\r\n}\r\nieee->link_change(ieee->dev);\r\nif(ieee->is_silent_reset == 0){\r\nprintk("============>normal associate\n");\r\nnotify_wx_assoc_event(ieee);\r\n}\r\nelse if(ieee->is_silent_reset == 1)\r\n{\r\nprintk("==================>silent reset associate\n");\r\nieee->is_silent_reset = 0;\r\n}\r\nif (ieee->data_hard_resume)\r\nieee->data_hard_resume(ieee->dev);\r\nnetif_carrier_on(ieee->dev);\r\n}\r\nstatic void ieee80211_associate_complete(struct ieee80211_device *ieee)\r\n{\r\ndel_timer_sync(&ieee->associate_timer);\r\nieee->state = IEEE80211_LINKED;\r\nqueue_work(ieee->wq, &ieee->associate_complete_wq);\r\n}\r\nstatic void ieee80211_associate_procedure_wq(struct work_struct *work)\r\n{\r\nstruct ieee80211_device *ieee = container_of(work, struct ieee80211_device, associate_procedure_wq);\r\nieee->sync_scan_hurryup = 1;\r\ndown(&ieee->wx_sem);\r\nif (ieee->data_hard_stop)\r\nieee->data_hard_stop(ieee->dev);\r\nieee80211_stop_scan(ieee);\r\nprintk("===>%s(), chan:%d\n", __func__, ieee->current_network.channel);\r\nHTSetConnectBwMode(ieee, HT_CHANNEL_WIDTH_20, HT_EXTCHNL_OFFSET_NO_EXT);\r\nieee->associate_seq = 1;\r\nieee80211_associate_step1(ieee);\r\nup(&ieee->wx_sem);\r\n}\r\ninline void ieee80211_softmac_new_net(struct ieee80211_device *ieee, struct ieee80211_network *net)\r\n{\r\nu8 tmp_ssid[IW_ESSID_MAX_SIZE+1];\r\nint tmp_ssid_len = 0;\r\nshort apset, ssidset, ssidbroad, apmatch, ssidmatch;\r\nif (ieee->state != IEEE80211_NOLINK)\r\nreturn;\r\nif ((ieee->iw_mode == IW_MODE_INFRA) && !(net->capability & WLAN_CAPABILITY_BSS))\r\nreturn;\r\nif ((ieee->iw_mode == IW_MODE_ADHOC) && !(net->capability & WLAN_CAPABILITY_IBSS))\r\nreturn;\r\nif (ieee->iw_mode == IW_MODE_INFRA || ieee->iw_mode == IW_MODE_ADHOC){\r\napset = ieee->wap_set;\r\nssidset = ieee->ssid_set;\r\nssidbroad = !(net->ssid_len == 0 || net->ssid[0]== '\0');\r\napmatch = (memcmp(ieee->current_network.bssid, net->bssid, ETH_ALEN)==0);\r\nssidmatch = (ieee->current_network.ssid_len == net->ssid_len)&&\\r\n(!strncmp(ieee->current_network.ssid, net->ssid, net->ssid_len));\r\nif (\r\n(apset && apmatch &&\r\n((ssidset && ssidbroad && ssidmatch) || (ssidbroad && !ssidset) || (!ssidbroad && ssidset)) ) ||\r\n(!apset && ssidset && ssidbroad && ssidmatch)\r\n){\r\nif (!ssidbroad){\r\nstrncpy(tmp_ssid, ieee->current_network.ssid, IW_ESSID_MAX_SIZE);\r\ntmp_ssid_len = ieee->current_network.ssid_len;\r\n}\r\nmemcpy(&ieee->current_network, net, sizeof(struct ieee80211_network));\r\nif (!ssidbroad){\r\nstrncpy(ieee->current_network.ssid, tmp_ssid, IW_ESSID_MAX_SIZE);\r\nieee->current_network.ssid_len = tmp_ssid_len;\r\n}\r\nprintk(KERN_INFO"Linking with %s,channel:%d, qos:%d, myHT:%d, networkHT:%d\n",ieee->current_network.ssid,ieee->current_network.channel, ieee->current_network.qos_data.supported, ieee->pHTInfo->bEnableHT, ieee->current_network.bssht.bdSupportHT);\r\nHTResetIOTSetting(ieee->pHTInfo);\r\nif (ieee->iw_mode == IW_MODE_INFRA){\r\nieee->AsocRetryCount = 0;\r\nif((ieee->current_network.qos_data.supported == 1) &&\r\nieee->current_network.bssht.bdSupportHT)\r\n{\r\nHTResetSelfAndSavePeerSetting(ieee, &(ieee->current_network));\r\n}\r\nelse\r\n{\r\nieee->pHTInfo->bCurrentHTSupport = false;\r\n}\r\nieee->state = IEEE80211_ASSOCIATING;\r\nqueue_work(ieee->wq, &ieee->associate_procedure_wq);\r\n}else{\r\nif(ieee80211_is_54g(&ieee->current_network) &&\r\n(ieee->modulation & IEEE80211_OFDM_MODULATION)){\r\nieee->rate = 108;\r\nieee->SetWirelessMode(ieee->dev, IEEE_G);\r\nprintk(KERN_INFO"Using G rates\n");\r\n}else{\r\nieee->rate = 22;\r\nieee->SetWirelessMode(ieee->dev, IEEE_B);\r\nprintk(KERN_INFO"Using B rates\n");\r\n}\r\nmemset(ieee->dot11HTOperationalRateSet, 0, 16);\r\nieee->state = IEEE80211_LINKED;\r\n}\r\n}\r\n}\r\n}\r\nvoid ieee80211_softmac_check_all_nets(struct ieee80211_device *ieee)\r\n{\r\nunsigned long flags;\r\nstruct ieee80211_network *target;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nlist_for_each_entry(target, &ieee->network_list, list) {\r\nif (ieee->state != IEEE80211_NOLINK)\r\nbreak;\r\nif (ieee->scan_age == 0 || time_after(target->last_scanned + ieee->scan_age, jiffies))\r\nieee80211_softmac_new_net(ieee, target);\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nstatic inline u16 auth_parse(struct sk_buff *skb, u8 **challenge, int *chlen)\r\n{\r\nstruct ieee80211_authentication *a;\r\nu8 *t;\r\nif (skb->len < (sizeof(struct ieee80211_authentication)-sizeof(struct ieee80211_info_element))){\r\nIEEE80211_DEBUG_MGMT("invalid len in auth resp: %d\n",skb->len);\r\nreturn 0xcafe;\r\n}\r\n*challenge = NULL;\r\na = (struct ieee80211_authentication *) skb->data;\r\nif(skb->len > (sizeof(struct ieee80211_authentication) +3)){\r\nt = skb->data + sizeof(struct ieee80211_authentication);\r\nif(*(t++) == MFIE_TYPE_CHALLENGE){\r\n*chlen = *(t++);\r\n*challenge = kmemdup(t, *chlen, GFP_ATOMIC);\r\nif (!*challenge)\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn cpu_to_le16(a->status);\r\n}\r\nstatic int auth_rq_parse(struct sk_buff *skb, u8 *dest)\r\n{\r\nstruct ieee80211_authentication *a;\r\nif (skb->len < (sizeof(struct ieee80211_authentication)-sizeof(struct ieee80211_info_element))){\r\nIEEE80211_DEBUG_MGMT("invalid len in auth request: %d\n",skb->len);\r\nreturn -1;\r\n}\r\na = (struct ieee80211_authentication *) skb->data;\r\nmemcpy(dest,a->header.addr2, ETH_ALEN);\r\nif (le16_to_cpu(a->algorithm) != WLAN_AUTH_OPEN)\r\nreturn WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG;\r\nreturn WLAN_STATUS_SUCCESS;\r\n}\r\nstatic short probe_rq_parse(struct ieee80211_device *ieee, struct sk_buff *skb, u8 *src)\r\n{\r\nu8 *tag;\r\nu8 *skbend;\r\nu8 *ssid=NULL;\r\nu8 ssidlen = 0;\r\nstruct ieee80211_hdr_3addr *header =\r\n(struct ieee80211_hdr_3addr *) skb->data;\r\nif (skb->len < sizeof (struct ieee80211_hdr_3addr ))\r\nreturn -1;\r\nmemcpy(src,header->addr2, ETH_ALEN);\r\nskbend = (u8 *)skb->data + skb->len;\r\ntag = skb->data + sizeof (struct ieee80211_hdr_3addr );\r\nwhile (tag+1 < skbend){\r\nif (*tag == 0){\r\nssid = tag+2;\r\nssidlen = *(tag+1);\r\nbreak;\r\n}\r\ntag++;\r\ntag = tag + *(tag);\r\ntag++;\r\n}\r\nif (ssidlen == 0) return 1;\r\nif (!ssid) return 1;\r\nreturn (!strncmp(ssid, ieee->current_network.ssid, ssidlen));\r\n}\r\nstatic int assoc_rq_parse(struct sk_buff *skb, u8 *dest)\r\n{\r\nstruct ieee80211_assoc_request_frame *a;\r\nif (skb->len < (sizeof(struct ieee80211_assoc_request_frame) -\r\nsizeof(struct ieee80211_info_element))) {\r\nIEEE80211_DEBUG_MGMT("invalid len in auth request:%d \n", skb->len);\r\nreturn -1;\r\n}\r\na = (struct ieee80211_assoc_request_frame *) skb->data;\r\nmemcpy(dest,a->header.addr2,ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic inline u16 assoc_parse(struct ieee80211_device *ieee, struct sk_buff *skb, int *aid)\r\n{\r\nstruct ieee80211_assoc_response_frame *response_head;\r\nu16 status_code;\r\nif (skb->len < sizeof(struct ieee80211_assoc_response_frame)){\r\nIEEE80211_DEBUG_MGMT("invalid len in auth resp: %d\n", skb->len);\r\nreturn 0xcafe;\r\n}\r\nresponse_head = (struct ieee80211_assoc_response_frame *) skb->data;\r\n*aid = le16_to_cpu(response_head->aid) & 0x3fff;\r\nstatus_code = le16_to_cpu(response_head->status);\r\nif((status_code==WLAN_STATUS_ASSOC_DENIED_RATES || \\r\nstatus_code==WLAN_STATUS_CAPS_UNSUPPORTED)&&\r\n((ieee->mode == IEEE_G) &&\r\n(ieee->current_network.mode == IEEE_N_24G) &&\r\n(ieee->AsocRetryCount++ < (RT_ASOC_RETRY_LIMIT-1)))) {\r\nieee->pHTInfo->IOTAction |= HT_IOT_ACT_PURE_N_MODE;\r\n}else {\r\nieee->AsocRetryCount = 0;\r\n}\r\nreturn le16_to_cpu(response_head->status);\r\n}\r\nstatic inline void\r\nieee80211_rx_probe_rq(struct ieee80211_device *ieee, struct sk_buff *skb)\r\n{\r\nu8 dest[ETH_ALEN];\r\nieee->softmac_stats.rx_probe_rq++;\r\nif (probe_rq_parse(ieee, skb, dest)){\r\nieee->softmac_stats.tx_probe_rs++;\r\nieee80211_resp_to_probe(ieee, dest);\r\n}\r\n}\r\nstatic inline void\r\nieee80211_rx_auth_rq(struct ieee80211_device *ieee, struct sk_buff *skb)\r\n{\r\nu8 dest[ETH_ALEN];\r\nint status;\r\nieee->softmac_stats.rx_auth_rq++;\r\nstatus = auth_rq_parse(skb, dest);\r\nif (status != -1) {\r\nieee80211_resp_to_auth(ieee, status, dest);\r\n}\r\n}\r\nstatic inline void\r\nieee80211_rx_assoc_rq(struct ieee80211_device *ieee, struct sk_buff *skb)\r\n{\r\nu8 dest[ETH_ALEN];\r\nieee->softmac_stats.rx_ass_rq++;\r\nif (assoc_rq_parse(skb,dest) != -1){\r\nieee80211_resp_to_assoc_rq(ieee, dest);\r\n}\r\nprintk(KERN_INFO"New client associated: %pM\n", dest);\r\n}\r\nstatic void ieee80211_sta_ps_send_null_frame(struct ieee80211_device *ieee,\r\nshort pwr)\r\n{\r\nstruct sk_buff *buf = ieee80211_null_func(ieee, pwr);\r\nif (buf)\r\nsoftmac_ps_mgmt_xmit(buf, ieee);\r\n}\r\nstatic short ieee80211_sta_ps_sleep(struct ieee80211_device *ieee, u32 *time_h,\r\nu32 *time_l)\r\n{\r\nint timeout = ieee->ps_timeout;\r\nu8 dtim;\r\ndtim = ieee->current_network.dtim_data;\r\nif(!(dtim & IEEE80211_DTIM_VALID))\r\nreturn 0;\r\ntimeout = ieee->current_network.beacon_interval;\r\nieee->current_network.dtim_data = IEEE80211_DTIM_INVALID;\r\nif(dtim & ((IEEE80211_DTIM_UCAST | IEEE80211_DTIM_MBCAST)& ieee->ps))\r\nreturn 2;\r\nif(!time_after(jiffies, ieee->dev->trans_start + MSECS(timeout)))\r\nreturn 0;\r\nif(!time_after(jiffies, ieee->last_rx_ps_time + MSECS(timeout)))\r\nreturn 0;\r\nif((ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE ) &&\r\n(ieee->mgmt_queue_tail != ieee->mgmt_queue_head))\r\nreturn 0;\r\nif(time_l){\r\n*time_l = ieee->current_network.last_dtim_sta_time[0]\r\n+ (ieee->current_network.beacon_interval\r\n* ieee->current_network.dtim_period) * 1000;\r\n}\r\nif(time_h){\r\n*time_h = ieee->current_network.last_dtim_sta_time[1];\r\nif(time_l && *time_l < ieee->current_network.last_dtim_sta_time[0])\r\n*time_h += 1;\r\n}\r\nreturn 1;\r\n}\r\nstatic inline void ieee80211_sta_ps(struct ieee80211_device *ieee)\r\n{\r\nu32 th, tl;\r\nshort sleep;\r\nunsigned long flags, flags2;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif((ieee->ps == IEEE80211_PS_DISABLED ||\r\nieee->iw_mode != IW_MODE_INFRA ||\r\nieee->state != IEEE80211_LINKED)){\r\nspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\r\nieee80211_sta_wakeup(ieee, 1);\r\nspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\r\n}\r\nsleep = ieee80211_sta_ps_sleep(ieee,&th, &tl);\r\nif(sleep == 0)\r\ngoto out;\r\nif(sleep == 1){\r\nif(ieee->sta_sleep == 1)\r\nieee->enter_sleep_state(ieee->dev, th, tl);\r\nelse if(ieee->sta_sleep == 0){\r\nspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\r\nif(ieee->ps_is_queue_empty(ieee->dev)){\r\nieee->sta_sleep = 2;\r\nieee->ps_request_tx_ack(ieee->dev);\r\nieee80211_sta_ps_send_null_frame(ieee, 1);\r\nieee->ps_th = th;\r\nieee->ps_tl = tl;\r\n}\r\nspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\r\n}\r\n}else if(sleep == 2){\r\nspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\r\nieee80211_sta_wakeup(ieee, 1);\r\nspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nvoid ieee80211_sta_wakeup(struct ieee80211_device *ieee, short nl)\r\n{\r\nif(ieee->sta_sleep == 0){\r\nif(nl){\r\nprintk("Warning: driver is probably failing to report TX ps error\n");\r\nieee->ps_request_tx_ack(ieee->dev);\r\nieee80211_sta_ps_send_null_frame(ieee, 0);\r\n}\r\nreturn;\r\n}\r\nif(ieee->sta_sleep == 1)\r\nieee->sta_wake_up(ieee->dev);\r\nieee->sta_sleep = 0;\r\nif(nl){\r\nieee->ps_request_tx_ack(ieee->dev);\r\nieee80211_sta_ps_send_null_frame(ieee, 0);\r\n}\r\n}\r\nvoid ieee80211_ps_tx_ack(struct ieee80211_device *ieee, short success)\r\n{\r\nunsigned long flags, flags2;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif(ieee->sta_sleep == 2){\r\nif(success){\r\nieee->sta_sleep = 1;\r\nieee->enter_sleep_state(ieee->dev,ieee->ps_th,ieee->ps_tl);\r\n}\r\n}\r\nelse {\r\nif((ieee->sta_sleep == 0) && !success){\r\nspin_lock_irqsave(&ieee->mgmt_tx_lock, flags2);\r\nieee80211_sta_ps_send_null_frame(ieee, 0);\r\nspin_unlock_irqrestore(&ieee->mgmt_tx_lock, flags2);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nstatic void ieee80211_process_action(struct ieee80211_device *ieee,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *header = (struct ieee80211_hdr *)skb->data;\r\nu8 *act = ieee80211_get_payload(header);\r\nu8 tmp = 0;\r\nif (act == NULL)\r\n{\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "error to get payload of action frame\n");\r\nreturn;\r\n}\r\ntmp = *act;\r\nact ++;\r\nswitch (tmp) {\r\ncase ACT_CAT_BA:\r\nif (*act == ACT_ADDBAREQ)\r\nieee80211_rx_ADDBAReq(ieee, skb);\r\nelse if (*act == ACT_ADDBARSP)\r\nieee80211_rx_ADDBARsp(ieee, skb);\r\nelse if (*act == ACT_DELBA)\r\nieee80211_rx_DELBA(ieee, skb);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn;\r\n}\r\ninline int\r\nieee80211_rx_frame_softmac(struct ieee80211_device *ieee, struct sk_buff *skb,\r\nstruct ieee80211_rx_stats *rx_stats, u16 type,\r\nu16 stype)\r\n{\r\nstruct ieee80211_hdr_3addr *header = (struct ieee80211_hdr_3addr *) skb->data;\r\nu16 errcode;\r\nu8 *challenge;\r\nint chlen=0;\r\nint aid;\r\nstruct ieee80211_assoc_response_frame *assoc_resp;\r\nbool bSupportNmode = true, bHalfSupportNmode = false;\r\nif(!ieee->proto_started)\r\nreturn 0;\r\nif(ieee->sta_sleep || (ieee->ps != IEEE80211_PS_DISABLED &&\r\nieee->iw_mode == IW_MODE_INFRA &&\r\nieee->state == IEEE80211_LINKED))\r\ntasklet_schedule(&ieee->ps_task);\r\nif(WLAN_FC_GET_STYPE(header->frame_ctl) != IEEE80211_STYPE_PROBE_RESP &&\r\nWLAN_FC_GET_STYPE(header->frame_ctl) != IEEE80211_STYPE_BEACON)\r\nieee->last_rx_ps_time = jiffies;\r\nswitch (WLAN_FC_GET_STYPE(header->frame_ctl)) {\r\ncase IEEE80211_STYPE_ASSOC_RESP:\r\ncase IEEE80211_STYPE_REASSOC_RESP:\r\nIEEE80211_DEBUG_MGMT("received [RE]ASSOCIATION RESPONSE (%d)\n",\r\nWLAN_FC_GET_STYPE(header->frame_ctl));\r\nif ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&\r\nieee->state == IEEE80211_ASSOCIATING_AUTHENTICATED &&\r\nieee->iw_mode == IW_MODE_INFRA){\r\nstruct ieee80211_network network_resp;\r\nstruct ieee80211_network *network = &network_resp;\r\nerrcode = assoc_parse(ieee, skb, &aid);\r\nif (!errcode) {\r\nieee->state=IEEE80211_LINKED;\r\nieee->assoc_id = aid;\r\nieee->softmac_stats.rx_ass_ok++;\r\nif(ieee->qos_support) {\r\nassoc_resp = (struct ieee80211_assoc_response_frame *)skb->data;\r\nmemset(network, 0, sizeof(*network));\r\nif (ieee80211_parse_info_param(ieee,assoc_resp->info_element,\\r\nrx_stats->len - sizeof(*assoc_resp),\\r\nnetwork,rx_stats)){\r\nreturn 1;\r\n}\r\nelse\r\n{\r\nmemcpy(ieee->pHTInfo->PeerHTCapBuf, network->bssht.bdHTCapBuf, network->bssht.bdHTCapLen);\r\nmemcpy(ieee->pHTInfo->PeerHTInfoBuf, network->bssht.bdHTInfoBuf, network->bssht.bdHTInfoLen);\r\n}\r\nif (ieee->handle_assoc_response != NULL)\r\nieee->handle_assoc_response(ieee->dev, (struct ieee80211_assoc_response_frame *)header, network);\r\n}\r\nieee80211_associate_complete(ieee);\r\n} else {\r\nieee->softmac_stats.rx_ass_err++;\r\nprintk(\r\n"Association response status code 0x%x\n",\r\nerrcode);\r\nIEEE80211_DEBUG_MGMT(\r\n"Association response status code 0x%x\n",\r\nerrcode);\r\nif(ieee->AsocRetryCount < RT_ASOC_RETRY_LIMIT) {\r\nqueue_work(ieee->wq, &ieee->associate_procedure_wq);\r\n} else {\r\nieee80211_associate_abort(ieee);\r\n}\r\n}\r\n}\r\nbreak;\r\ncase IEEE80211_STYPE_ASSOC_REQ:\r\ncase IEEE80211_STYPE_REASSOC_REQ:\r\nif ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&\r\nieee->iw_mode == IW_MODE_MASTER)\r\nieee80211_rx_assoc_rq(ieee, skb);\r\nbreak;\r\ncase IEEE80211_STYPE_AUTH:\r\nif (ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE){\r\nif (ieee->state == IEEE80211_ASSOCIATING_AUTHENTICATING &&\r\nieee->iw_mode == IW_MODE_INFRA){\r\nIEEE80211_DEBUG_MGMT("Received authentication response");\r\nerrcode = auth_parse(skb, &challenge, &chlen);\r\nif (!errcode) {\r\nif(ieee->open_wep || !challenge){\r\nieee->state = IEEE80211_ASSOCIATING_AUTHENTICATED;\r\nieee->softmac_stats.rx_auth_rs_ok++;\r\nif(!(ieee->pHTInfo->IOTAction&HT_IOT_ACT_PURE_N_MODE))\r\n{\r\nif (!ieee->GetNmodeSupportBySecCfg(ieee->dev))\r\n{\r\nif(IsHTHalfNmodeAPs(ieee))\r\n{\r\nbSupportNmode = true;\r\nbHalfSupportNmode = true;\r\n}\r\nelse\r\n{\r\nbSupportNmode = false;\r\nbHalfSupportNmode = false;\r\n}\r\nprintk("==========>to link with AP using SEC(%d, %d)", bSupportNmode, bHalfSupportNmode);\r\n}\r\n}\r\nif(bSupportNmode) {\r\nieee->SetWirelessMode(ieee->dev, \\r\nieee->current_network.mode);\r\n}else{\r\nieee->SetWirelessMode(ieee->dev, IEEE_G);\r\n}\r\nif (ieee->current_network.mode == IEEE_N_24G && bHalfSupportNmode == true)\r\n{\r\nprintk("===============>entern half N mode\n");\r\nieee->bHalfWirelessN24GMode = true;\r\n}\r\nelse\r\nieee->bHalfWirelessN24GMode = false;\r\nieee80211_associate_step2(ieee);\r\n}else{\r\nieee80211_auth_challenge(ieee, challenge, chlen);\r\n}\r\n}else{\r\nieee->softmac_stats.rx_auth_rs_err++;\r\nIEEE80211_DEBUG_MGMT("Authentication response status code 0x%x",errcode);\r\nieee80211_associate_abort(ieee);\r\n}\r\n}else if (ieee->iw_mode == IW_MODE_MASTER){\r\nieee80211_rx_auth_rq(ieee, skb);\r\n}\r\n}\r\nbreak;\r\ncase IEEE80211_STYPE_PROBE_REQ:\r\nif ((ieee->softmac_features & IEEE_SOFTMAC_PROBERS) &&\r\n((ieee->iw_mode == IW_MODE_ADHOC ||\r\nieee->iw_mode == IW_MODE_MASTER) &&\r\nieee->state == IEEE80211_LINKED)){\r\nieee80211_rx_probe_rq(ieee, skb);\r\n}\r\nbreak;\r\ncase IEEE80211_STYPE_DISASSOC:\r\ncase IEEE80211_STYPE_DEAUTH:\r\nif ((ieee->softmac_features & IEEE_SOFTMAC_ASSOCIATE) &&\r\nieee->state == IEEE80211_LINKED &&\r\nieee->iw_mode == IW_MODE_INFRA){\r\nieee->state = IEEE80211_ASSOCIATING;\r\nieee->softmac_stats.reassoc++;\r\nnotify_wx_assoc_event(ieee);\r\nRemovePeerTS(ieee, header->addr2);\r\nqueue_work(ieee->wq, &ieee->associate_procedure_wq);\r\n}\r\nbreak;\r\ncase IEEE80211_STYPE_MANAGE_ACT:\r\nieee80211_process_action(ieee, skb);\r\nbreak;\r\ndefault:\r\nreturn -1;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid ieee80211_softmac_xmit(struct ieee80211_txb *txb, struct ieee80211_device *ieee)\r\n{\r\nunsigned int queue_index = txb->queue_index;\r\nunsigned long flags;\r\nint i;\r\ncb_desc *tcb_desc = NULL;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nieee80211_sta_wakeup(ieee, 0);\r\nieee->stats.tx_bytes += txb->payload_size;\r\nieee->stats.tx_packets++;\r\ntcb_desc = (cb_desc *)(txb->fragments[0]->cb + MAX_DEV_ADDR_SIZE);\r\nif(tcb_desc->bMulticast) {\r\nieee->stats.multicast++;\r\n}\r\nfor(i = 0; i < txb->nr_frags; i++) {\r\n#ifdef USB_TX_DRIVER_AGGREGATION_ENABLE\r\nif ((skb_queue_len(&ieee->skb_drv_aggQ[queue_index]) != 0) ||\r\n#else\r\nif ((skb_queue_len(&ieee->skb_waitQ[queue_index]) != 0) ||\r\n#endif\r\n(!ieee->check_nic_enough_desc(ieee->dev,queue_index))||\\r\n(ieee->queue_stop)) {\r\n#ifdef USB_TX_DRIVER_AGGREGATION_ENABLE\r\nskb_queue_tail(&ieee->skb_drv_aggQ[queue_index], txb->fragments[i]);\r\n#else\r\nskb_queue_tail(&ieee->skb_waitQ[queue_index], txb->fragments[i]);\r\n#endif\r\n}else{\r\nieee->softmac_data_hard_start_xmit(\r\ntxb->fragments[i],\r\nieee->dev, ieee->rate);\r\n}\r\n}\r\nieee80211_txb_free(txb);\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nstatic void ieee80211_resume_tx(struct ieee80211_device *ieee)\r\n{\r\nint i;\r\nfor(i = ieee->tx_pending.frag; i < ieee->tx_pending.txb->nr_frags; i++) {\r\nif (ieee->queue_stop){\r\nieee->tx_pending.frag = i;\r\nreturn;\r\n}else{\r\nieee->softmac_data_hard_start_xmit(\r\nieee->tx_pending.txb->fragments[i],\r\nieee->dev, ieee->rate);\r\nieee->stats.tx_packets++;\r\nieee->dev->trans_start = jiffies;\r\n}\r\n}\r\nieee80211_txb_free(ieee->tx_pending.txb);\r\nieee->tx_pending.txb = NULL;\r\n}\r\nvoid ieee80211_reset_queue(struct ieee80211_device *ieee)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\ninit_mgmt_queue(ieee);\r\nif (ieee->tx_pending.txb){\r\nieee80211_txb_free(ieee->tx_pending.txb);\r\nieee->tx_pending.txb = NULL;\r\n}\r\nieee->queue_stop = 0;\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nvoid ieee80211_wake_queue(struct ieee80211_device *ieee)\r\n{\r\nunsigned long flags;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_hdr_3addr *header;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif (! ieee->queue_stop) goto exit;\r\nieee->queue_stop = 0;\r\nif(ieee->softmac_features & IEEE_SOFTMAC_SINGLE_QUEUE){\r\nwhile (!ieee->queue_stop && (skb = dequeue_mgmt(ieee))){\r\nheader = (struct ieee80211_hdr_3addr *) skb->data;\r\nheader->seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\nieee->softmac_data_hard_start_xmit(skb,ieee->dev,ieee->basic_rate);\r\n}\r\n}\r\nif (!ieee->queue_stop && ieee->tx_pending.txb)\r\nieee80211_resume_tx(ieee);\r\nif (!ieee->queue_stop && netif_queue_stopped(ieee->dev)){\r\nieee->softmac_stats.swtxawake++;\r\nnetif_wake_queue(ieee->dev);\r\n}\r\nexit :\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nvoid ieee80211_stop_queue(struct ieee80211_device *ieee)\r\n{\r\nif (! netif_queue_stopped(ieee->dev)){\r\nnetif_stop_queue(ieee->dev);\r\nieee->softmac_stats.swtxstop++;\r\n}\r\nieee->queue_stop = 1;\r\n}\r\ninline void ieee80211_randomize_cell(struct ieee80211_device *ieee)\r\n{\r\nrandom_ether_addr(ieee->current_network.bssid);\r\n}\r\nvoid ieee80211_start_master_bss(struct ieee80211_device *ieee)\r\n{\r\nieee->assoc_id = 1;\r\nif (ieee->current_network.ssid_len == 0){\r\nstrncpy(ieee->current_network.ssid,\r\nIEEE80211_DEFAULT_TX_ESSID,\r\nIW_ESSID_MAX_SIZE);\r\nieee->current_network.ssid_len = strlen(IEEE80211_DEFAULT_TX_ESSID);\r\nieee->ssid_set = 1;\r\n}\r\nmemcpy(ieee->current_network.bssid, ieee->dev->dev_addr, ETH_ALEN);\r\nieee->set_chan(ieee->dev, ieee->current_network.channel);\r\nieee->state = IEEE80211_LINKED;\r\nieee->link_change(ieee->dev);\r\nnotify_wx_assoc_event(ieee);\r\nif (ieee->data_hard_resume)\r\nieee->data_hard_resume(ieee->dev);\r\nnetif_carrier_on(ieee->dev);\r\n}\r\nstatic void ieee80211_start_monitor_mode(struct ieee80211_device *ieee)\r\n{\r\nif(ieee->raw_tx){\r\nif (ieee->data_hard_resume)\r\nieee->data_hard_resume(ieee->dev);\r\nnetif_carrier_on(ieee->dev);\r\n}\r\n}\r\nstatic void ieee80211_start_ibss_wq(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = container_of(work, struct delayed_work, work);\r\nstruct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, start_ibss_wq);\r\nif(!ieee->proto_started){\r\nprintk("==========oh driver down return\n");\r\nreturn;\r\n}\r\ndown(&ieee->wx_sem);\r\nif (ieee->current_network.ssid_len == 0){\r\nstrcpy(ieee->current_network.ssid, IEEE80211_DEFAULT_TX_ESSID);\r\nieee->current_network.ssid_len = strlen(IEEE80211_DEFAULT_TX_ESSID);\r\nieee->ssid_set = 1;\r\n}\r\nieee80211_softmac_check_all_nets(ieee);\r\nif (ieee->state == IEEE80211_NOLINK)\r\nieee->current_network.channel = 6;\r\nif (ieee->state == IEEE80211_NOLINK)\r\nieee80211_start_scan_syncro(ieee);\r\nif (ieee->state == IEEE80211_NOLINK){\r\nprintk("creating new IBSS cell\n");\r\nif(!ieee->wap_set)\r\nieee80211_randomize_cell(ieee);\r\nif(ieee->modulation & IEEE80211_CCK_MODULATION){\r\nieee->current_network.rates_len = 4;\r\nieee->current_network.rates[0] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_1MB;\r\nieee->current_network.rates[1] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_2MB;\r\nieee->current_network.rates[2] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_5MB;\r\nieee->current_network.rates[3] = IEEE80211_BASIC_RATE_MASK | IEEE80211_CCK_RATE_11MB;\r\n}else\r\nieee->current_network.rates_len = 0;\r\nif(ieee->modulation & IEEE80211_OFDM_MODULATION){\r\nieee->current_network.rates_ex_len = 8;\r\nieee->current_network.rates_ex[0] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_6MB;\r\nieee->current_network.rates_ex[1] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_9MB;\r\nieee->current_network.rates_ex[2] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_12MB;\r\nieee->current_network.rates_ex[3] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_18MB;\r\nieee->current_network.rates_ex[4] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_24MB;\r\nieee->current_network.rates_ex[5] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_36MB;\r\nieee->current_network.rates_ex[6] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_48MB;\r\nieee->current_network.rates_ex[7] = IEEE80211_BASIC_RATE_MASK | IEEE80211_OFDM_RATE_54MB;\r\nieee->rate = 108;\r\n}else{\r\nieee->current_network.rates_ex_len = 0;\r\nieee->rate = 22;\r\n}\r\nieee->current_network.QoS_Enable = 0;\r\nieee->SetWirelessMode(ieee->dev, IEEE_G);\r\nieee->current_network.atim_window = 0;\r\nieee->current_network.capability = WLAN_CAPABILITY_IBSS;\r\nif(ieee->short_slot)\r\nieee->current_network.capability |= WLAN_CAPABILITY_SHORT_SLOT;\r\n}\r\nieee->state = IEEE80211_LINKED;\r\nieee->set_chan(ieee->dev, ieee->current_network.channel);\r\nieee->link_change(ieee->dev);\r\nnotify_wx_assoc_event(ieee);\r\nieee80211_start_send_beacons(ieee);\r\nif (ieee->data_hard_resume)\r\nieee->data_hard_resume(ieee->dev);\r\nnetif_carrier_on(ieee->dev);\r\nup(&ieee->wx_sem);\r\n}\r\ninline void ieee80211_start_ibss(struct ieee80211_device *ieee)\r\n{\r\nqueue_delayed_work(ieee->wq, &ieee->start_ibss_wq, 150);\r\n}\r\nvoid ieee80211_start_bss(struct ieee80211_device *ieee)\r\n{\r\nunsigned long flags;\r\nif(IS_DOT11D_ENABLE(ieee) && !IS_COUNTRY_IE_VALID(ieee))\r\n{\r\nif(! ieee->bGlobalDomain)\r\n{\r\nreturn;\r\n}\r\n}\r\nieee80211_softmac_check_all_nets(ieee);\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif (ieee->state == IEEE80211_NOLINK){\r\nieee->actscanning = true;\r\nieee80211_start_scan(ieee);\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\n}\r\nvoid ieee80211_disassociate(struct ieee80211_device *ieee)\r\n{\r\nnetif_carrier_off(ieee->dev);\r\nif (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE)\r\nieee80211_reset_queue(ieee);\r\nif (ieee->data_hard_stop)\r\nieee->data_hard_stop(ieee->dev);\r\nif(IS_DOT11D_ENABLE(ieee))\r\nDot11d_Reset(ieee);\r\nieee->state = IEEE80211_NOLINK;\r\nieee->is_set_key = false;\r\nieee->link_change(ieee->dev);\r\nnotify_wx_assoc_event(ieee);\r\n}\r\nstatic void ieee80211_associate_retry_wq(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = container_of(work, struct delayed_work, work);\r\nstruct ieee80211_device *ieee = container_of(dwork, struct ieee80211_device, associate_retry_wq);\r\nunsigned long flags;\r\ndown(&ieee->wx_sem);\r\nif(!ieee->proto_started)\r\ngoto exit;\r\nif(ieee->state != IEEE80211_ASSOCIATING_RETRY)\r\ngoto exit;\r\nieee->state = IEEE80211_NOLINK;\r\nieee80211_softmac_check_all_nets(ieee);\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif(ieee->state == IEEE80211_NOLINK)\r\nieee80211_start_scan(ieee);\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nexit:\r\nup(&ieee->wx_sem);\r\n}\r\nstruct sk_buff *ieee80211_get_beacon_(struct ieee80211_device *ieee)\r\n{\r\nu8 broadcast_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nstruct sk_buff *skb;\r\nstruct ieee80211_probe_response *b;\r\nskb = ieee80211_probe_resp(ieee, broadcast_addr);\r\nif (!skb)\r\nreturn NULL;\r\nb = (struct ieee80211_probe_response *) skb->data;\r\nb->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_BEACON);\r\nreturn skb;\r\n}\r\nstruct sk_buff *ieee80211_get_beacon(struct ieee80211_device *ieee)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_probe_response *b;\r\nskb = ieee80211_get_beacon_(ieee);\r\nif(!skb)\r\nreturn NULL;\r\nb = (struct ieee80211_probe_response *) skb->data;\r\nb->header.seq_ctl = cpu_to_le16(ieee->seq_ctrl[0] << 4);\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\nreturn skb;\r\n}\r\nvoid ieee80211_softmac_stop_protocol(struct ieee80211_device *ieee)\r\n{\r\nieee->sync_scan_hurryup = 1;\r\ndown(&ieee->wx_sem);\r\nieee80211_stop_protocol(ieee);\r\nup(&ieee->wx_sem);\r\n}\r\nvoid ieee80211_stop_protocol(struct ieee80211_device *ieee)\r\n{\r\nif (!ieee->proto_started)\r\nreturn;\r\nieee->proto_started = 0;\r\nieee80211_stop_send_beacons(ieee);\r\ndel_timer_sync(&ieee->associate_timer);\r\ncancel_delayed_work(&ieee->associate_retry_wq);\r\ncancel_delayed_work(&ieee->start_ibss_wq);\r\nieee80211_stop_scan(ieee);\r\nieee80211_disassociate(ieee);\r\nRemoveAllTS(ieee);\r\n}\r\nvoid ieee80211_softmac_start_protocol(struct ieee80211_device *ieee)\r\n{\r\nieee->sync_scan_hurryup = 0;\r\ndown(&ieee->wx_sem);\r\nieee80211_start_protocol(ieee);\r\nup(&ieee->wx_sem);\r\n}\r\nvoid ieee80211_start_protocol(struct ieee80211_device *ieee)\r\n{\r\nshort ch = 0;\r\nint i = 0;\r\nif (ieee->proto_started)\r\nreturn;\r\nieee->proto_started = 1;\r\nif (ieee->current_network.channel == 0){\r\ndo{\r\nch++;\r\nif (ch > MAX_CHANNEL_NUMBER)\r\nreturn;\r\n}while(!GET_DOT11D_INFO(ieee)->channel_map[ch]);\r\nieee->current_network.channel = ch;\r\n}\r\nif (ieee->current_network.beacon_interval == 0)\r\nieee->current_network.beacon_interval = 100;\r\nfor(i = 0; i < 17; i++) {\r\nieee->last_rxseq_num[i] = -1;\r\nieee->last_rxfrag_num[i] = -1;\r\nieee->last_packet_time[i] = 0;\r\n}\r\nieee->init_wmmparam_flag = 0;\r\nif (ieee->iw_mode == IW_MODE_INFRA)\r\nieee80211_start_bss(ieee);\r\nelse if (ieee->iw_mode == IW_MODE_ADHOC)\r\nieee80211_start_ibss(ieee);\r\nelse if (ieee->iw_mode == IW_MODE_MASTER)\r\nieee80211_start_master_bss(ieee);\r\nelse if(ieee->iw_mode == IW_MODE_MONITOR)\r\nieee80211_start_monitor_mode(ieee);\r\n}\r\nvoid ieee80211_softmac_init(struct ieee80211_device *ieee)\r\n{\r\nint i;\r\nmemset(&ieee->current_network, 0, sizeof(struct ieee80211_network));\r\nieee->state = IEEE80211_NOLINK;\r\nieee->sync_scan_hurryup = 0;\r\nfor(i = 0; i < 5; i++) {\r\nieee->seq_ctrl[i] = 0;\r\n}\r\nieee->pDot11dInfo = kzalloc(sizeof(RT_DOT11D_INFO), GFP_ATOMIC);\r\nif (!ieee->pDot11dInfo)\r\nIEEE80211_DEBUG(IEEE80211_DL_ERR, "can't alloc memory for DOT11D\n");\r\nieee->LinkDetectInfo.SlotNum = 2;\r\nieee->LinkDetectInfo.NumRecvBcnInPeriod=0;\r\nieee->LinkDetectInfo.NumRecvDataInPeriod=0;\r\nieee->assoc_id = 0;\r\nieee->queue_stop = 0;\r\nieee->scanning = 0;\r\nieee->softmac_features = 0;\r\nieee->wap_set = 0;\r\nieee->ssid_set = 0;\r\nieee->proto_started = 0;\r\nieee->basic_rate = IEEE80211_DEFAULT_BASIC_RATE;\r\nieee->rate = 22;\r\nieee->ps = IEEE80211_PS_DISABLED;\r\nieee->sta_sleep = 0;\r\nieee->Regdot11HTOperationalRateSet[0]= 0xff;\r\nieee->Regdot11HTOperationalRateSet[1]= 0xff;\r\nieee->Regdot11HTOperationalRateSet[4]= 0x01;\r\nieee->actscanning = false;\r\nieee->beinretry = false;\r\nieee->is_set_key = false;\r\ninit_mgmt_queue(ieee);\r\nieee->sta_edca_param[0] = 0x0000A403;\r\nieee->sta_edca_param[1] = 0x0000A427;\r\nieee->sta_edca_param[2] = 0x005E4342;\r\nieee->sta_edca_param[3] = 0x002F3262;\r\nieee->aggregation = true;\r\nieee->enable_rx_imm_BA = 1;\r\nieee->tx_pending.txb = NULL;\r\ninit_timer(&ieee->associate_timer);\r\nieee->associate_timer.data = (unsigned long)ieee;\r\nieee->associate_timer.function = ieee80211_associate_abort_cb;\r\ninit_timer(&ieee->beacon_timer);\r\nieee->beacon_timer.data = (unsigned long) ieee;\r\nieee->beacon_timer.function = ieee80211_send_beacon_cb;\r\nieee->wq = create_workqueue(DRV_NAME);\r\nINIT_DELAYED_WORK(&ieee->start_ibss_wq, ieee80211_start_ibss_wq);\r\nINIT_WORK(&ieee->associate_complete_wq, ieee80211_associate_complete_wq);\r\nINIT_WORK(&ieee->associate_procedure_wq, ieee80211_associate_procedure_wq);\r\nINIT_DELAYED_WORK(&ieee->softmac_scan_wq, ieee80211_softmac_scan_wq);\r\nINIT_DELAYED_WORK(&ieee->associate_retry_wq, ieee80211_associate_retry_wq);\r\nINIT_WORK(&ieee->wx_sync_scan_wq, ieee80211_wx_sync_scan_wq);\r\nsema_init(&ieee->wx_sem, 1);\r\nsema_init(&ieee->scan_sem, 1);\r\nspin_lock_init(&ieee->mgmt_tx_lock);\r\nspin_lock_init(&ieee->beacon_lock);\r\ntasklet_init(&ieee->ps_task,\r\n(void(*)(unsigned long)) ieee80211_sta_ps,\r\n(unsigned long)ieee);\r\n}\r\nvoid ieee80211_softmac_free(struct ieee80211_device *ieee)\r\n{\r\ndown(&ieee->wx_sem);\r\nkfree(ieee->pDot11dInfo);\r\nieee->pDot11dInfo = NULL;\r\ndel_timer_sync(&ieee->associate_timer);\r\ncancel_delayed_work(&ieee->associate_retry_wq);\r\ndestroy_workqueue(ieee->wq);\r\nup(&ieee->wx_sem);\r\n}\r\nstatic int ieee80211_wpa_enable(struct ieee80211_device *ieee, int value)\r\n{\r\nprintk("%s WPA\n",value ? "enabling" : "disabling");\r\nieee->wpa_enabled = value;\r\nreturn 0;\r\n}\r\nstatic void ieee80211_wpa_assoc_frame(struct ieee80211_device *ieee,\r\nchar *wpa_ie, int wpa_ie_len)\r\n{\r\nieee80211_wpa_enable(ieee, 1);\r\nieee80211_disassociate(ieee);\r\n}\r\nstatic int ieee80211_wpa_mlme(struct ieee80211_device *ieee, int command, int reason)\r\n{\r\nint ret = 0;\r\nswitch (command) {\r\ncase IEEE_MLME_STA_DEAUTH:\r\nbreak;\r\ncase IEEE_MLME_STA_DISASSOC:\r\nieee80211_disassociate(ieee);\r\nbreak;\r\ndefault:\r\nprintk("Unknown MLME request: %d\n", command);\r\nret = -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ieee80211_wpa_set_wpa_ie(struct ieee80211_device *ieee,\r\nstruct ieee_param *param, int plen)\r\n{\r\nu8 *buf;\r\nif (param->u.wpa_ie.len > MAX_WPA_IE_LEN ||\r\n(param->u.wpa_ie.len && param->u.wpa_ie.data == NULL))\r\nreturn -EINVAL;\r\nif (param->u.wpa_ie.len) {\r\nbuf = kmemdup(param->u.wpa_ie.data, param->u.wpa_ie.len,\r\nGFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nkfree(ieee->wpa_ie);\r\nieee->wpa_ie = buf;\r\nieee->wpa_ie_len = param->u.wpa_ie.len;\r\n} else {\r\nkfree(ieee->wpa_ie);\r\nieee->wpa_ie = NULL;\r\nieee->wpa_ie_len = 0;\r\n}\r\nieee80211_wpa_assoc_frame(ieee, ieee->wpa_ie, ieee->wpa_ie_len);\r\nreturn 0;\r\n}\r\nstatic int ieee80211_wpa_set_auth_algs(struct ieee80211_device *ieee, int value)\r\n{\r\nstruct ieee80211_security sec = {\r\n.flags = SEC_AUTH_MODE,\r\n};\r\nif (value & AUTH_ALG_SHARED_KEY) {\r\nsec.auth_mode = WLAN_AUTH_SHARED_KEY;\r\nieee->open_wep = 0;\r\nieee->auth_mode = 1;\r\n} else if (value & AUTH_ALG_OPEN_SYSTEM){\r\nsec.auth_mode = WLAN_AUTH_OPEN;\r\nieee->open_wep = 1;\r\nieee->auth_mode = 0;\r\n}\r\nelse if (value & IW_AUTH_ALG_LEAP){\r\nsec.auth_mode = WLAN_AUTH_LEAP;\r\nieee->open_wep = 1;\r\nieee->auth_mode = 2;\r\n}\r\nif (ieee->set_security)\r\nieee->set_security(ieee->dev, &sec);\r\nreturn 0;\r\n}\r\nstatic int ieee80211_wpa_set_param(struct ieee80211_device *ieee, u8 name, u32 value)\r\n{\r\nint ret=0;\r\nunsigned long flags;\r\nswitch (name) {\r\ncase IEEE_PARAM_WPA_ENABLED:\r\nret = ieee80211_wpa_enable(ieee, value);\r\nbreak;\r\ncase IEEE_PARAM_TKIP_COUNTERMEASURES:\r\nieee->tkip_countermeasures=value;\r\nbreak;\r\ncase IEEE_PARAM_DROP_UNENCRYPTED: {\r\nstruct ieee80211_security sec = {\r\n.flags = SEC_ENABLED,\r\n.enabled = value,\r\n};\r\nieee->drop_unencrypted = value;\r\nif (!value) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_0;\r\n}\r\nelse {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_1;\r\n}\r\nif (ieee->set_security)\r\nieee->set_security(ieee->dev, &sec);\r\nbreak;\r\n}\r\ncase IEEE_PARAM_PRIVACY_INVOKED:\r\nieee->privacy_invoked=value;\r\nbreak;\r\ncase IEEE_PARAM_AUTH_ALGS:\r\nret = ieee80211_wpa_set_auth_algs(ieee, value);\r\nbreak;\r\ncase IEEE_PARAM_IEEE_802_1X:\r\nieee->ieee802_1x=value;\r\nbreak;\r\ncase IEEE_PARAM_WPAX_SELECT:\r\nspin_lock_irqsave(&ieee->wpax_suitlist_lock, flags);\r\nieee->wpax_type_set = 1;\r\nieee->wpax_type_notify = value;\r\nspin_unlock_irqrestore(&ieee->wpax_suitlist_lock, flags);\r\nbreak;\r\ndefault:\r\nprintk("Unknown WPA param: %d\n",name);\r\nret = -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ieee80211_wpa_set_encryption(struct ieee80211_device *ieee,\r\nstruct ieee_param *param, int param_len)\r\n{\r\nint ret = 0;\r\nstruct ieee80211_crypto_ops *ops;\r\nstruct ieee80211_crypt_data **crypt;\r\nstruct ieee80211_security sec = {\r\n.flags = 0,\r\n};\r\nparam->u.crypt.err = 0;\r\nparam->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';\r\nif (param_len !=\r\n(int) ((char *) param->u.crypt.key - (char *) param) +\r\nparam->u.crypt.key_len) {\r\nprintk("Len mismatch %d, %d\n", param_len,\r\nparam->u.crypt.key_len);\r\nreturn -EINVAL;\r\n}\r\nif (is_broadcast_ether_addr(param->sta_addr)) {\r\nif (param->u.crypt.idx >= WEP_KEYS)\r\nreturn -EINVAL;\r\ncrypt = &ieee->crypt[param->u.crypt.idx];\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nif (strcmp(param->u.crypt.alg, "none") == 0) {\r\nif (crypt) {\r\nsec.enabled = 0;\r\nsec.level = SEC_LEVEL_0;\r\nsec.flags |= SEC_ENABLED | SEC_LEVEL;\r\nieee80211_crypt_delayed_deinit(ieee, crypt);\r\n}\r\ngoto done;\r\n}\r\nsec.enabled = 1;\r\nsec.flags |= SEC_ENABLED;\r\nif (!(ieee->host_encrypt || ieee->host_decrypt) &&\r\nstrcmp(param->u.crypt.alg, "TKIP"))\r\ngoto skip_host_crypt;\r\nops = ieee80211_get_crypto_ops(param->u.crypt.alg);\r\nif (ops == NULL && strcmp(param->u.crypt.alg, "WEP") == 0) {\r\nrequest_module("ieee80211_crypt_wep");\r\nops = ieee80211_get_crypto_ops(param->u.crypt.alg);\r\n} else if (ops == NULL && strcmp(param->u.crypt.alg, "TKIP") == 0) {\r\nrequest_module("ieee80211_crypt_tkip");\r\nops = ieee80211_get_crypto_ops(param->u.crypt.alg);\r\n} else if (ops == NULL && strcmp(param->u.crypt.alg, "CCMP") == 0) {\r\nrequest_module("ieee80211_crypt_ccmp");\r\nops = ieee80211_get_crypto_ops(param->u.crypt.alg);\r\n}\r\nif (ops == NULL) {\r\nprintk("unknown crypto alg '%s'\n", param->u.crypt.alg);\r\nparam->u.crypt.err = IEEE_CRYPT_ERR_UNKNOWN_ALG;\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (*crypt == NULL || (*crypt)->ops != ops) {\r\nstruct ieee80211_crypt_data *new_crypt;\r\nieee80211_crypt_delayed_deinit(ieee, crypt);\r\nnew_crypt = kmalloc(sizeof(*new_crypt), GFP_KERNEL);\r\nif (new_crypt == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nmemset(new_crypt, 0, sizeof(struct ieee80211_crypt_data));\r\nnew_crypt->ops = ops;\r\nif (new_crypt->ops && try_module_get(new_crypt->ops->owner))\r\nnew_crypt->priv =\r\nnew_crypt->ops->init(param->u.crypt.idx);\r\nif (new_crypt->priv == NULL) {\r\nkfree(new_crypt);\r\nparam->u.crypt.err = IEEE_CRYPT_ERR_CRYPT_INIT_FAILED;\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\n*crypt = new_crypt;\r\n}\r\nif (param->u.crypt.key_len > 0 && (*crypt)->ops->set_key &&\r\n(*crypt)->ops->set_key(param->u.crypt.key,\r\nparam->u.crypt.key_len, param->u.crypt.seq,\r\n(*crypt)->priv) < 0) {\r\nprintk("key setting failed\n");\r\nparam->u.crypt.err = IEEE_CRYPT_ERR_KEY_SET_FAILED;\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nskip_host_crypt:\r\nif (param->u.crypt.set_tx) {\r\nieee->tx_keyidx = param->u.crypt.idx;\r\nsec.active_key = param->u.crypt.idx;\r\nsec.flags |= SEC_ACTIVE_KEY;\r\n} else\r\nsec.flags &= ~SEC_ACTIVE_KEY;\r\nif (param->u.crypt.alg != NULL) {\r\nmemcpy(sec.keys[param->u.crypt.idx],\r\nparam->u.crypt.key,\r\nparam->u.crypt.key_len);\r\nsec.key_sizes[param->u.crypt.idx] = param->u.crypt.key_len;\r\nsec.flags |= (1 << param->u.crypt.idx);\r\nif (strcmp(param->u.crypt.alg, "WEP") == 0) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_1;\r\n} else if (strcmp(param->u.crypt.alg, "TKIP") == 0) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_2;\r\n} else if (strcmp(param->u.crypt.alg, "CCMP") == 0) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_3;\r\n}\r\n}\r\ndone:\r\nif (ieee->set_security)\r\nieee->set_security(ieee->dev, &sec);\r\nif (ieee->reset_on_keychange &&\r\nieee->iw_mode != IW_MODE_INFRA &&\r\nieee->reset_port &&\r\nieee->reset_port(ieee->dev)) {\r\nprintk("reset_port failed\n");\r\nparam->u.crypt.err = IEEE_CRYPT_ERR_CARD_CONF_FAILED;\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\ninline struct sk_buff *ieee80211_disassociate_skb(\r\nstruct ieee80211_network *beacon,\r\nstruct ieee80211_device *ieee,\r\nu8 asRsn)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ieee80211_disassoc *disass;\r\nskb = dev_alloc_skb(sizeof(struct ieee80211_disassoc));\r\nif (!skb)\r\nreturn NULL;\r\ndisass = (struct ieee80211_disassoc *) skb_put(skb,sizeof(struct ieee80211_disassoc));\r\ndisass->header.frame_ctl = cpu_to_le16(IEEE80211_STYPE_DISASSOC);\r\ndisass->header.duration_id = 0;\r\nmemcpy(disass->header.addr1, beacon->bssid, ETH_ALEN);\r\nmemcpy(disass->header.addr2, ieee->dev->dev_addr, ETH_ALEN);\r\nmemcpy(disass->header.addr3, beacon->bssid, ETH_ALEN);\r\ndisass->reason = asRsn;\r\nreturn skb;\r\n}\r\nvoid\r\nSendDisassociation(\r\nstruct ieee80211_device *ieee,\r\nu8 *asSta,\r\nu8 asRsn\r\n)\r\n{\r\nstruct ieee80211_network *beacon = &ieee->current_network;\r\nstruct sk_buff *skb;\r\nskb = ieee80211_disassociate_skb(beacon,ieee,asRsn);\r\nif (skb){\r\nsoftmac_mgmt_xmit(skb, ieee);\r\n}\r\n}\r\nint ieee80211_wpa_supplicant_ioctl(struct ieee80211_device *ieee, struct iw_point *p)\r\n{\r\nstruct ieee_param *param;\r\nint ret=0;\r\ndown(&ieee->wx_sem);\r\nif (p->length < sizeof(struct ieee_param) || !p->pointer){\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nparam = memdup_user(p->pointer, p->length);\r\nif (IS_ERR(param)) {\r\nret = PTR_ERR(param);\r\ngoto out;\r\n}\r\nswitch (param->cmd) {\r\ncase IEEE_CMD_SET_WPA_PARAM:\r\nret = ieee80211_wpa_set_param(ieee, param->u.wpa_param.name,\r\nparam->u.wpa_param.value);\r\nbreak;\r\ncase IEEE_CMD_SET_WPA_IE:\r\nret = ieee80211_wpa_set_wpa_ie(ieee, param, p->length);\r\nbreak;\r\ncase IEEE_CMD_SET_ENCRYPTION:\r\nret = ieee80211_wpa_set_encryption(ieee, param, p->length);\r\nbreak;\r\ncase IEEE_CMD_MLME:\r\nret = ieee80211_wpa_mlme(ieee, param->u.mlme.command,\r\nparam->u.mlme.reason_code);\r\nbreak;\r\ndefault:\r\nprintk("Unknown WPA supplicant request: %d\n",param->cmd);\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (ret == 0 && copy_to_user(p->pointer, param, p->length))\r\nret = -EFAULT;\r\nkfree(param);\r\nout:\r\nup(&ieee->wx_sem);\r\nreturn ret;\r\n}\r\nvoid notify_wx_assoc_event(struct ieee80211_device *ieee)\r\n{\r\nunion iwreq_data wrqu;\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nif (ieee->state == IEEE80211_LINKED)\r\nmemcpy(wrqu.ap_addr.sa_data, ieee->current_network.bssid, ETH_ALEN);\r\nelse\r\nmemset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);\r\nwireless_send_event(ieee->dev, SIOCGIWAP, &wrqu, NULL);\r\n}
