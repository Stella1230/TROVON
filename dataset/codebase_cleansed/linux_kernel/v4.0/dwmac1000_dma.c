static int dwmac1000_dma_init(void __iomem *ioaddr, int pbl, int fb, int mb,\r\nint burst_len, u32 dma_tx, u32 dma_rx, int atds)\r\n{\r\nu32 value = readl(ioaddr + DMA_BUS_MODE);\r\nint limit;\r\nvalue |= DMA_BUS_MODE_SFT_RESET;\r\nwritel(value, ioaddr + DMA_BUS_MODE);\r\nlimit = 10;\r\nwhile (limit--) {\r\nif (!(readl(ioaddr + DMA_BUS_MODE) & DMA_BUS_MODE_SFT_RESET))\r\nbreak;\r\nmdelay(10);\r\n}\r\nif (limit < 0)\r\nreturn -EBUSY;\r\nvalue = DMA_BUS_MODE_PBL | ((pbl << DMA_BUS_MODE_PBL_SHIFT) |\r\n(pbl << DMA_BUS_MODE_RPBL_SHIFT));\r\nif (fb)\r\nvalue |= DMA_BUS_MODE_FB;\r\nif (mb)\r\nvalue |= DMA_BUS_MODE_MB;\r\nif (atds)\r\nvalue |= DMA_BUS_MODE_ATDS;\r\nwritel(value, ioaddr + DMA_BUS_MODE);\r\nwritel(burst_len, ioaddr + DMA_AXI_BUS_MODE);\r\nwritel(DMA_INTR_DEFAULT_MASK, ioaddr + DMA_INTR_ENA);\r\nwritel(dma_tx, ioaddr + DMA_TX_BASE_ADDR);\r\nwritel(dma_rx, ioaddr + DMA_RCV_BASE_ADDR);\r\nreturn 0;\r\n}\r\nstatic void dwmac1000_dma_operation_mode(void __iomem *ioaddr, int txmode,\r\nint rxmode)\r\n{\r\nu32 csr6 = readl(ioaddr + DMA_CONTROL);\r\nif (txmode == SF_DMA_MODE) {\r\npr_debug("GMAC: enable TX store and forward mode\n");\r\ncsr6 |= DMA_CONTROL_TSF;\r\ncsr6 |= DMA_CONTROL_OSF;\r\n} else {\r\npr_debug("GMAC: disabling TX SF (threshold %d)\n", txmode);\r\ncsr6 &= ~DMA_CONTROL_TSF;\r\ncsr6 &= DMA_CONTROL_TC_TX_MASK;\r\nif (txmode <= 32)\r\ncsr6 |= DMA_CONTROL_TTC_32;\r\nelse if (txmode <= 64)\r\ncsr6 |= DMA_CONTROL_TTC_64;\r\nelse if (txmode <= 128)\r\ncsr6 |= DMA_CONTROL_TTC_128;\r\nelse if (txmode <= 192)\r\ncsr6 |= DMA_CONTROL_TTC_192;\r\nelse\r\ncsr6 |= DMA_CONTROL_TTC_256;\r\n}\r\nif (rxmode == SF_DMA_MODE) {\r\npr_debug("GMAC: enable RX store and forward mode\n");\r\ncsr6 |= DMA_CONTROL_RSF;\r\n} else {\r\npr_debug("GMAC: disable RX SF mode (threshold %d)\n", rxmode);\r\ncsr6 &= ~DMA_CONTROL_RSF;\r\ncsr6 &= DMA_CONTROL_TC_RX_MASK;\r\nif (rxmode <= 32)\r\ncsr6 |= DMA_CONTROL_RTC_32;\r\nelse if (rxmode <= 64)\r\ncsr6 |= DMA_CONTROL_RTC_64;\r\nelse if (rxmode <= 96)\r\ncsr6 |= DMA_CONTROL_RTC_96;\r\nelse\r\ncsr6 |= DMA_CONTROL_RTC_128;\r\n}\r\nwritel(csr6, ioaddr + DMA_CONTROL);\r\n}\r\nstatic void dwmac1000_dump_dma_regs(void __iomem *ioaddr)\r\n{\r\nint i;\r\npr_info(" DMA registers\n");\r\nfor (i = 0; i < 22; i++) {\r\nif ((i < 9) || (i > 17)) {\r\nint offset = i * 4;\r\npr_err("\t Reg No. %d (offset 0x%x): 0x%08x\n", i,\r\n(DMA_BUS_MODE + offset),\r\nreadl(ioaddr + DMA_BUS_MODE + offset));\r\n}\r\n}\r\n}\r\nstatic unsigned int dwmac1000_get_hw_feature(void __iomem *ioaddr)\r\n{\r\nreturn readl(ioaddr + DMA_HW_FEATURE);\r\n}\r\nstatic void dwmac1000_rx_watchdog(void __iomem *ioaddr, u32 riwt)\r\n{\r\nwritel(riwt, ioaddr + DMA_RX_WATCHDOG);\r\n}
