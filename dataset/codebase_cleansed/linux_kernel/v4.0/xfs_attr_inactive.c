STATIC int\r\nxfs_attr3_leaf_freextent(\r\nstruct xfs_trans **trans,\r\nstruct xfs_inode *dp,\r\nxfs_dablk_t blkno,\r\nint blkcnt)\r\n{\r\nstruct xfs_bmbt_irec map;\r\nstruct xfs_buf *bp;\r\nxfs_dablk_t tblkno;\r\nxfs_daddr_t dblkno;\r\nint tblkcnt;\r\nint dblkcnt;\r\nint nmap;\r\nint error;\r\ntblkno = blkno;\r\ntblkcnt = blkcnt;\r\nwhile (tblkcnt > 0) {\r\nnmap = 1;\r\nerror = xfs_bmapi_read(dp, (xfs_fileoff_t)tblkno, tblkcnt,\r\n&map, &nmap, XFS_BMAPI_ATTRFORK);\r\nif (error) {\r\nreturn error;\r\n}\r\nASSERT(nmap == 1);\r\nASSERT(map.br_startblock != DELAYSTARTBLOCK);\r\nif (map.br_startblock != HOLESTARTBLOCK) {\r\ndblkno = XFS_FSB_TO_DADDR(dp->i_mount,\r\nmap.br_startblock);\r\ndblkcnt = XFS_FSB_TO_BB(dp->i_mount,\r\nmap.br_blockcount);\r\nbp = xfs_trans_get_buf(*trans,\r\ndp->i_mount->m_ddev_targp,\r\ndblkno, dblkcnt, 0);\r\nif (!bp)\r\nreturn -ENOMEM;\r\nxfs_trans_binval(*trans, bp);\r\nerror = xfs_trans_roll(trans, dp);\r\nif (error)\r\nreturn error;\r\n}\r\ntblkno += map.br_blockcount;\r\ntblkcnt -= map.br_blockcount;\r\n}\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_attr3_leaf_inactive(\r\nstruct xfs_trans **trans,\r\nstruct xfs_inode *dp,\r\nstruct xfs_buf *bp)\r\n{\r\nstruct xfs_attr_leafblock *leaf;\r\nstruct xfs_attr3_icleaf_hdr ichdr;\r\nstruct xfs_attr_leaf_entry *entry;\r\nstruct xfs_attr_leaf_name_remote *name_rmt;\r\nstruct xfs_attr_inactive_list *list;\r\nstruct xfs_attr_inactive_list *lp;\r\nint error;\r\nint count;\r\nint size;\r\nint tmp;\r\nint i;\r\nleaf = bp->b_addr;\r\nxfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\r\ncount = 0;\r\nentry = xfs_attr3_leaf_entryp(leaf);\r\nfor (i = 0; i < ichdr.count; entry++, i++) {\r\nif (be16_to_cpu(entry->nameidx) &&\r\n((entry->flags & XFS_ATTR_LOCAL) == 0)) {\r\nname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\r\nif (name_rmt->valueblk)\r\ncount++;\r\n}\r\n}\r\nif (count == 0) {\r\nxfs_trans_brelse(*trans, bp);\r\nreturn 0;\r\n}\r\nsize = count * sizeof(xfs_attr_inactive_list_t);\r\nlist = kmem_alloc(size, KM_SLEEP);\r\nlp = list;\r\nentry = xfs_attr3_leaf_entryp(leaf);\r\nfor (i = 0; i < ichdr.count; entry++, i++) {\r\nif (be16_to_cpu(entry->nameidx) &&\r\n((entry->flags & XFS_ATTR_LOCAL) == 0)) {\r\nname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\r\nif (name_rmt->valueblk) {\r\nlp->valueblk = be32_to_cpu(name_rmt->valueblk);\r\nlp->valuelen = xfs_attr3_rmt_blocks(dp->i_mount,\r\nbe32_to_cpu(name_rmt->valuelen));\r\nlp++;\r\n}\r\n}\r\n}\r\nxfs_trans_brelse(*trans, bp);\r\nerror = 0;\r\nfor (lp = list, i = 0; i < count; i++, lp++) {\r\ntmp = xfs_attr3_leaf_freextent(trans, dp,\r\nlp->valueblk, lp->valuelen);\r\nif (error == 0)\r\nerror = tmp;\r\n}\r\nkmem_free(list);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_attr3_node_inactive(\r\nstruct xfs_trans **trans,\r\nstruct xfs_inode *dp,\r\nstruct xfs_buf *bp,\r\nint level)\r\n{\r\nxfs_da_blkinfo_t *info;\r\nxfs_da_intnode_t *node;\r\nxfs_dablk_t child_fsb;\r\nxfs_daddr_t parent_blkno, child_blkno;\r\nint error, i;\r\nstruct xfs_buf *child_bp;\r\nstruct xfs_da_node_entry *btree;\r\nstruct xfs_da3_icnode_hdr ichdr;\r\nif (level > XFS_DA_NODE_MAXDEPTH) {\r\nxfs_trans_brelse(*trans, bp);\r\nreturn -EIO;\r\n}\r\nnode = bp->b_addr;\r\ndp->d_ops->node_hdr_from_disk(&ichdr, node);\r\nparent_blkno = bp->b_bn;\r\nif (!ichdr.count) {\r\nxfs_trans_brelse(*trans, bp);\r\nreturn 0;\r\n}\r\nbtree = dp->d_ops->node_tree_p(node);\r\nchild_fsb = be32_to_cpu(btree[0].before);\r\nxfs_trans_brelse(*trans, bp);\r\nfor (i = 0; i < ichdr.count; i++) {\r\nerror = xfs_da3_node_read(*trans, dp, child_fsb, -2, &child_bp,\r\nXFS_ATTR_FORK);\r\nif (error)\r\nreturn error;\r\nif (child_bp) {\r\nchild_blkno = XFS_BUF_ADDR(child_bp);\r\ninfo = child_bp->b_addr;\r\nswitch (info->magic) {\r\ncase cpu_to_be16(XFS_DA_NODE_MAGIC):\r\ncase cpu_to_be16(XFS_DA3_NODE_MAGIC):\r\nerror = xfs_attr3_node_inactive(trans, dp,\r\nchild_bp, level + 1);\r\nbreak;\r\ncase cpu_to_be16(XFS_ATTR_LEAF_MAGIC):\r\ncase cpu_to_be16(XFS_ATTR3_LEAF_MAGIC):\r\nerror = xfs_attr3_leaf_inactive(trans, dp,\r\nchild_bp);\r\nbreak;\r\ndefault:\r\nerror = -EIO;\r\nxfs_trans_brelse(*trans, child_bp);\r\nbreak;\r\n}\r\nif (error)\r\nreturn error;\r\nerror = xfs_da_get_buf(*trans, dp, 0, child_blkno,\r\n&child_bp, XFS_ATTR_FORK);\r\nif (error)\r\nreturn error;\r\nxfs_trans_binval(*trans, child_bp);\r\n}\r\nif (i + 1 < ichdr.count) {\r\nerror = xfs_da3_node_read(*trans, dp, 0, parent_blkno,\r\n&bp, XFS_ATTR_FORK);\r\nif (error)\r\nreturn error;\r\nchild_fsb = be32_to_cpu(btree[i + 1].before);\r\nxfs_trans_brelse(*trans, bp);\r\n}\r\nerror = xfs_trans_roll(trans, dp);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nxfs_attr3_root_inactive(\r\nstruct xfs_trans **trans,\r\nstruct xfs_inode *dp)\r\n{\r\nstruct xfs_da_blkinfo *info;\r\nstruct xfs_buf *bp;\r\nxfs_daddr_t blkno;\r\nint error;\r\nerror = xfs_da3_node_read(*trans, dp, 0, -1, &bp, XFS_ATTR_FORK);\r\nif (error)\r\nreturn error;\r\nblkno = bp->b_bn;\r\ninfo = bp->b_addr;\r\nswitch (info->magic) {\r\ncase cpu_to_be16(XFS_DA_NODE_MAGIC):\r\ncase cpu_to_be16(XFS_DA3_NODE_MAGIC):\r\nerror = xfs_attr3_node_inactive(trans, dp, bp, 1);\r\nbreak;\r\ncase cpu_to_be16(XFS_ATTR_LEAF_MAGIC):\r\ncase cpu_to_be16(XFS_ATTR3_LEAF_MAGIC):\r\nerror = xfs_attr3_leaf_inactive(trans, dp, bp);\r\nbreak;\r\ndefault:\r\nerror = -EIO;\r\nxfs_trans_brelse(*trans, bp);\r\nbreak;\r\n}\r\nif (error)\r\nreturn error;\r\nerror = xfs_da_get_buf(*trans, dp, 0, blkno, &bp, XFS_ATTR_FORK);\r\nif (error)\r\nreturn error;\r\nxfs_trans_binval(*trans, bp);\r\nerror = xfs_trans_roll(trans, dp);\r\nreturn error;\r\n}\r\nint\r\nxfs_attr_inactive(xfs_inode_t *dp)\r\n{\r\nxfs_trans_t *trans;\r\nxfs_mount_t *mp;\r\nint error;\r\nmp = dp->i_mount;\r\nASSERT(! XFS_NOT_DQATTACHED(mp, dp));\r\nxfs_ilock(dp, XFS_ILOCK_SHARED);\r\nif (!xfs_inode_hasattr(dp) ||\r\ndp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\r\nxfs_iunlock(dp, XFS_ILOCK_SHARED);\r\nreturn 0;\r\n}\r\nxfs_iunlock(dp, XFS_ILOCK_SHARED);\r\ntrans = xfs_trans_alloc(mp, XFS_TRANS_ATTRINVAL);\r\nerror = xfs_trans_reserve(trans, &M_RES(mp)->tr_attrinval, 0, 0);\r\nif (error) {\r\nxfs_trans_cancel(trans, 0);\r\nreturn error;\r\n}\r\nxfs_ilock(dp, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(trans, dp, 0);\r\nif (!xfs_inode_hasattr(dp) ||\r\ndp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\r\nerror = 0;\r\ngoto out;\r\n}\r\nerror = xfs_attr3_root_inactive(&trans, dp);\r\nif (error)\r\ngoto out;\r\nerror = xfs_itruncate_extents(&trans, dp, XFS_ATTR_FORK, 0);\r\nif (error)\r\ngoto out;\r\nerror = xfs_trans_commit(trans, XFS_TRANS_RELEASE_LOG_RES);\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nreturn error;\r\nout:\r\nxfs_trans_cancel(trans, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nreturn error;\r\n}
