static void saa7164_pack_verifier(struct saa7164_buffer *buf)\r\n{\r\nu8 *p = (u8 *)buf->cpu;\r\nint i;\r\nfor (i = 0; i < buf->actual_size; i += 2048) {\r\nif ((*(p + i + 0) != 0x00) || (*(p + i + 1) != 0x00) ||\r\n(*(p + i + 2) != 0x01) || (*(p + i + 3) != 0xBA)) {\r\nprintk(KERN_ERR "No pack at 0x%x\n", i);\r\n#if 0\r\nprint_hex_dump(KERN_INFO, "", DUMP_PREFIX_OFFSET, 16, 1,\r\np + 1, 32, false);\r\n#endif\r\n}\r\n}\r\n}\r\nstatic void saa7164_ts_verifier(struct saa7164_buffer *buf)\r\n{\r\nstruct saa7164_port *port = buf->port;\r\nu32 i;\r\nu8 cc, a;\r\nu16 pid;\r\nu8 *bufcpu = (u8 *)buf->cpu;\r\nport->sync_errors = 0;\r\nport->v_cc_errors = 0;\r\nport->a_cc_errors = 0;\r\nfor (i = 0; i < buf->actual_size; i += 188) {\r\nif (*(bufcpu + i) != 0x47)\r\nport->sync_errors++;\r\npid = ((*(bufcpu + i + 1) & 0x1f) << 8) | *(bufcpu + i + 2);\r\ncc = *(bufcpu + i + 3) & 0x0f;\r\nif (pid == FIXED_VIDEO_PID) {\r\na = ((port->last_v_cc + 1) & 0x0f);\r\nif (a != cc) {\r\nprintk(KERN_ERR "video cc last = %x current = %x i = %d\n",\r\nport->last_v_cc, cc, i);\r\nport->v_cc_errors++;\r\n}\r\nport->last_v_cc = cc;\r\n} else\r\nif (pid == FIXED_AUDIO_PID) {\r\na = ((port->last_a_cc + 1) & 0x0f);\r\nif (a != cc) {\r\nprintk(KERN_ERR "audio cc last = %x current = %x i = %d\n",\r\nport->last_a_cc, cc, i);\r\nport->a_cc_errors++;\r\n}\r\nport->last_a_cc = cc;\r\n}\r\n}\r\nif (port->v_cc_errors && (port->done_first_interrupt > 1))\r\nprintk(KERN_ERR "video pid cc, %d errors\n", port->v_cc_errors);\r\nif (port->a_cc_errors && (port->done_first_interrupt > 1))\r\nprintk(KERN_ERR "audio pid cc, %d errors\n", port->a_cc_errors);\r\nif (port->sync_errors && (port->done_first_interrupt > 1))\r\nprintk(KERN_ERR "sync_errors = %d\n", port->sync_errors);\r\nif (port->done_first_interrupt == 1)\r\nport->done_first_interrupt++;\r\n}\r\nstatic void saa7164_histogram_reset(struct saa7164_histogram *hg, char *name)\r\n{\r\nint i;\r\nmemset(hg, 0, sizeof(struct saa7164_histogram));\r\nstrcpy(hg->name, name);\r\nfor (i = 0; i < 30; i++)\r\nhg->counter1[0 + i].val = i;\r\nfor (i = 0; i < 18; i++)\r\nhg->counter1[30 + i].val = 30 + (i * 10);\r\nfor (i = 0; i < 15; i++)\r\nhg->counter1[48 + i].val = 200 + (i * 200);\r\nhg->counter1[55].val = 2000;\r\nhg->counter1[56].val = 4000;\r\nhg->counter1[57].val = 8000;\r\nhg->counter1[58].val = 15000;\r\nhg->counter1[59].val = 30000;\r\nhg->counter1[60].val = 60000;\r\nhg->counter1[61].val = 300000;\r\nhg->counter1[62].val = 900000;\r\nhg->counter1[63].val = 3600000;\r\n}\r\nvoid saa7164_histogram_update(struct saa7164_histogram *hg, u32 val)\r\n{\r\nint i;\r\nfor (i = 0; i < 64; i++) {\r\nif (val <= hg->counter1[i].val) {\r\nhg->counter1[i].count++;\r\nhg->counter1[i].update_time = jiffies;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void saa7164_histogram_print(struct saa7164_port *port,\r\nstruct saa7164_histogram *hg)\r\n{\r\nu32 entries = 0;\r\nint i;\r\nprintk(KERN_ERR "Histogram named %s (ms, count, last_update_jiffy)\n", hg->name);\r\nfor (i = 0; i < 64; i++) {\r\nif (hg->counter1[i].count == 0)\r\ncontinue;\r\nprintk(KERN_ERR " %4d %12d %Ld\n",\r\nhg->counter1[i].val,\r\nhg->counter1[i].count,\r\nhg->counter1[i].update_time);\r\nentries++;\r\n}\r\nprintk(KERN_ERR "Total: %d\n", entries);\r\n}\r\nstatic void saa7164_work_enchandler_helper(struct saa7164_port *port, int bufnr)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nstruct saa7164_buffer *buf = NULL;\r\nstruct saa7164_user_buffer *ubuf = NULL;\r\nstruct list_head *c, *n;\r\nint i = 0;\r\nu8 *p;\r\nmutex_lock(&port->dmaqueue_lock);\r\nlist_for_each_safe(c, n, &port->dmaqueue.list) {\r\nbuf = list_entry(c, struct saa7164_buffer, list);\r\nif (i++ > port->hwcfg.buffercount) {\r\nprintk(KERN_ERR "%s() illegal i count %d\n",\r\n__func__, i);\r\nbreak;\r\n}\r\nif (buf->idx == bufnr) {\r\ndprintk(DBGLVL_IRQ, "%s() bufnr: %d\n", __func__, bufnr);\r\nif (crc_checking) {\r\nbuf->crc = crc32(0, buf->cpu, buf->actual_size);\r\n}\r\nif (guard_checking) {\r\np = (u8 *)buf->cpu;\r\nif ((*(p + buf->actual_size + 0) != 0xff) ||\r\n(*(p + buf->actual_size + 1) != 0xff) ||\r\n(*(p + buf->actual_size + 2) != 0xff) ||\r\n(*(p + buf->actual_size + 3) != 0xff) ||\r\n(*(p + buf->actual_size + 0x10) != 0xff) ||\r\n(*(p + buf->actual_size + 0x11) != 0xff) ||\r\n(*(p + buf->actual_size + 0x12) != 0xff) ||\r\n(*(p + buf->actual_size + 0x13) != 0xff)) {\r\nprintk(KERN_ERR "%s() buf %p guard buffer breach\n",\r\n__func__, buf);\r\n#if 0\r\nprint_hex_dump(KERN_INFO, "", DUMP_PREFIX_OFFSET, 16, 1,\r\np + buf->actual_size - 32, 64, false);\r\n#endif\r\n}\r\n}\r\nif ((port->nr != SAA7164_PORT_VBI1) && (port->nr != SAA7164_PORT_VBI2)) {\r\nif (port->encoder_params.stream_type == V4L2_MPEG_STREAM_TYPE_MPEG2_TS)\r\nsaa7164_ts_verifier(buf);\r\nelse if (port->encoder_params.stream_type == V4L2_MPEG_STREAM_TYPE_MPEG2_PS)\r\nsaa7164_pack_verifier(buf);\r\n}\r\nif (!list_empty(&port->list_buf_free.list)) {\r\nubuf = list_first_entry(&port->list_buf_free.list,\r\nstruct saa7164_user_buffer, list);\r\nif (buf->actual_size <= ubuf->actual_size) {\r\nmemcpy(ubuf->data, buf->cpu, ubuf->actual_size);\r\nif (crc_checking) {\r\nubuf->crc = crc32(0, ubuf->data, ubuf->actual_size);\r\n}\r\nubuf->pos = 0;\r\nlist_move_tail(&ubuf->list,\r\n&port->list_buf_used.list);\r\nwake_up_interruptible(&port->wait_read);\r\n} else {\r\nprintk(KERN_ERR "buf %p bufsize fails match\n", buf);\r\n}\r\n} else\r\nprintk(KERN_ERR "encirq no free buffers, increase param encoder_buffers\n");\r\nsaa7164_buffer_zero_offsets(port, bufnr);\r\nmemset(buf->cpu, 0xff, buf->pci_size);\r\nif (crc_checking) {\r\nbuf->crc = crc32(0, buf->cpu, buf->actual_size);\r\n}\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&port->dmaqueue_lock);\r\n}\r\nstatic void saa7164_work_enchandler(struct work_struct *w)\r\n{\r\nstruct saa7164_port *port =\r\ncontainer_of(w, struct saa7164_port, workenc);\r\nstruct saa7164_dev *dev = port->dev;\r\nu32 wp, mcb, rp, cnt = 0;\r\nport->last_svc_msecs_diff = port->last_svc_msecs;\r\nport->last_svc_msecs = jiffies_to_msecs(jiffies);\r\nport->last_svc_msecs_diff = port->last_svc_msecs -\r\nport->last_svc_msecs_diff;\r\nsaa7164_histogram_update(&port->svc_interval,\r\nport->last_svc_msecs_diff);\r\nport->last_irq_svc_msecs_diff = port->last_svc_msecs -\r\nport->last_irq_msecs;\r\nsaa7164_histogram_update(&port->irq_svc_interval,\r\nport->last_irq_svc_msecs_diff);\r\ndprintk(DBGLVL_IRQ,\r\n"%s() %Ldms elapsed irq->deferred %Ldms wp: %d rp: %d\n",\r\n__func__,\r\nport->last_svc_msecs_diff,\r\nport->last_irq_svc_msecs_diff,\r\nport->last_svc_wp,\r\nport->last_svc_rp\r\n);\r\nwp = saa7164_readl(port->bufcounter);\r\nif (wp > (port->hwcfg.buffercount - 1)) {\r\nprintk(KERN_ERR "%s() illegal buf count %d\n", __func__, wp);\r\nreturn;\r\n}\r\nif (wp == 0)\r\nmcb = (port->hwcfg.buffercount - 1);\r\nelse\r\nmcb = wp - 1;\r\nwhile (1) {\r\nif (port->done_first_interrupt == 0) {\r\nport->done_first_interrupt++;\r\nrp = mcb;\r\n} else\r\nrp = (port->last_svc_rp + 1) % 8;\r\nif (rp > (port->hwcfg.buffercount - 1)) {\r\nprintk(KERN_ERR "%s() illegal rp count %d\n", __func__, rp);\r\nbreak;\r\n}\r\nsaa7164_work_enchandler_helper(port, rp);\r\nport->last_svc_rp = rp;\r\ncnt++;\r\nif (rp == mcb)\r\nbreak;\r\n}\r\nif (print_histogram == port->nr) {\r\nsaa7164_histogram_print(port, &port->irq_interval);\r\nsaa7164_histogram_print(port, &port->svc_interval);\r\nsaa7164_histogram_print(port, &port->irq_svc_interval);\r\nsaa7164_histogram_print(port, &port->read_interval);\r\nsaa7164_histogram_print(port, &port->poll_interval);\r\nprint_histogram = 64 + port->nr;\r\n}\r\n}\r\nstatic void saa7164_work_vbihandler(struct work_struct *w)\r\n{\r\nstruct saa7164_port *port =\r\ncontainer_of(w, struct saa7164_port, workenc);\r\nstruct saa7164_dev *dev = port->dev;\r\nu32 wp, mcb, rp, cnt = 0;\r\nport->last_svc_msecs_diff = port->last_svc_msecs;\r\nport->last_svc_msecs = jiffies_to_msecs(jiffies);\r\nport->last_svc_msecs_diff = port->last_svc_msecs -\r\nport->last_svc_msecs_diff;\r\nsaa7164_histogram_update(&port->svc_interval,\r\nport->last_svc_msecs_diff);\r\nport->last_irq_svc_msecs_diff = port->last_svc_msecs -\r\nport->last_irq_msecs;\r\nsaa7164_histogram_update(&port->irq_svc_interval,\r\nport->last_irq_svc_msecs_diff);\r\ndprintk(DBGLVL_IRQ,\r\n"%s() %Ldms elapsed irq->deferred %Ldms wp: %d rp: %d\n",\r\n__func__,\r\nport->last_svc_msecs_diff,\r\nport->last_irq_svc_msecs_diff,\r\nport->last_svc_wp,\r\nport->last_svc_rp\r\n);\r\nwp = saa7164_readl(port->bufcounter);\r\nif (wp > (port->hwcfg.buffercount - 1)) {\r\nprintk(KERN_ERR "%s() illegal buf count %d\n", __func__, wp);\r\nreturn;\r\n}\r\nif (wp == 0)\r\nmcb = (port->hwcfg.buffercount - 1);\r\nelse\r\nmcb = wp - 1;\r\nwhile (1) {\r\nif (port->done_first_interrupt == 0) {\r\nport->done_first_interrupt++;\r\nrp = mcb;\r\n} else\r\nrp = (port->last_svc_rp + 1) % 8;\r\nif (rp > (port->hwcfg.buffercount - 1)) {\r\nprintk(KERN_ERR "%s() illegal rp count %d\n", __func__, rp);\r\nbreak;\r\n}\r\nsaa7164_work_enchandler_helper(port, rp);\r\nport->last_svc_rp = rp;\r\ncnt++;\r\nif (rp == mcb)\r\nbreak;\r\n}\r\nif (print_histogram == port->nr) {\r\nsaa7164_histogram_print(port, &port->irq_interval);\r\nsaa7164_histogram_print(port, &port->svc_interval);\r\nsaa7164_histogram_print(port, &port->irq_svc_interval);\r\nsaa7164_histogram_print(port, &port->read_interval);\r\nsaa7164_histogram_print(port, &port->poll_interval);\r\nprint_histogram = 64 + port->nr;\r\n}\r\n}\r\nstatic void saa7164_work_cmdhandler(struct work_struct *w)\r\n{\r\nstruct saa7164_dev *dev = container_of(w, struct saa7164_dev, workcmd);\r\nsaa7164_irq_dequeue(dev);\r\n}\r\nstatic void saa7164_buffer_deliver(struct saa7164_buffer *buf)\r\n{\r\nstruct saa7164_port *port = buf->port;\r\ndvb_dmx_swfilter_packets(&port->dvb.demux, (u8 *)buf->cpu,\r\nSAA7164_TS_NUMBER_OF_LINES);\r\n}\r\nstatic irqreturn_t saa7164_irq_vbi(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nport->last_irq_msecs_diff = port->last_irq_msecs;\r\nport->last_irq_msecs = jiffies_to_msecs(jiffies);\r\nport->last_irq_msecs_diff = port->last_irq_msecs -\r\nport->last_irq_msecs_diff;\r\nsaa7164_histogram_update(&port->irq_interval,\r\nport->last_irq_msecs_diff);\r\ndprintk(DBGLVL_IRQ, "%s() %Ldms elapsed\n", __func__,\r\nport->last_irq_msecs_diff);\r\nschedule_work(&port->workenc);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t saa7164_irq_encoder(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nport->last_irq_msecs_diff = port->last_irq_msecs;\r\nport->last_irq_msecs = jiffies_to_msecs(jiffies);\r\nport->last_irq_msecs_diff = port->last_irq_msecs -\r\nport->last_irq_msecs_diff;\r\nsaa7164_histogram_update(&port->irq_interval,\r\nport->last_irq_msecs_diff);\r\ndprintk(DBGLVL_IRQ, "%s() %Ldms elapsed\n", __func__,\r\nport->last_irq_msecs_diff);\r\nschedule_work(&port->workenc);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t saa7164_irq_ts(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nstruct saa7164_buffer *buf;\r\nstruct list_head *c, *n;\r\nint wp, i = 0, rp;\r\nwp = saa7164_readl(port->bufcounter);\r\nif (wp > (port->hwcfg.buffercount - 1))\r\nBUG();\r\nif (wp == 0)\r\nrp = (port->hwcfg.buffercount - 1);\r\nelse\r\nrp = wp - 1;\r\nlist_for_each_safe(c, n, &port->dmaqueue.list) {\r\nbuf = list_entry(c, struct saa7164_buffer, list);\r\nif (i++ > port->hwcfg.buffercount)\r\nBUG();\r\nif (buf->idx == rp) {\r\ndprintk(DBGLVL_IRQ, "%s() wp: %d processing: %d\n",\r\n__func__, wp, rp);\r\nsaa7164_buffer_deliver(buf);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t saa7164_irq(int irq, void *dev_id)\r\n{\r\nstruct saa7164_dev *dev = dev_id;\r\nstruct saa7164_port *porta = &dev->ports[SAA7164_PORT_TS1];\r\nstruct saa7164_port *portb = &dev->ports[SAA7164_PORT_TS2];\r\nstruct saa7164_port *portc = &dev->ports[SAA7164_PORT_ENC1];\r\nstruct saa7164_port *portd = &dev->ports[SAA7164_PORT_ENC2];\r\nstruct saa7164_port *porte = &dev->ports[SAA7164_PORT_VBI1];\r\nstruct saa7164_port *portf = &dev->ports[SAA7164_PORT_VBI2];\r\nu32 intid, intstat[INT_SIZE/4];\r\nint i, handled = 0, bit;\r\nif (dev == NULL) {\r\nprintk(KERN_ERR "%s() No device specified\n", __func__);\r\nhandled = 0;\r\ngoto out;\r\n}\r\nfor (i = 0; i < INT_SIZE/4; i++) {\r\nintstat[i] = saa7164_readl(dev->int_status + (i * 4));\r\nif (intstat[i])\r\nhandled = 1;\r\n}\r\nif (handled == 0)\r\ngoto out;\r\nfor (i = 0; i < INT_SIZE/4; i++) {\r\nif (intstat[i]) {\r\nfor (bit = 0; bit < 32; bit++) {\r\nif (((intstat[i] >> bit) & 0x00000001) == 0)\r\ncontinue;\r\nintid = (i * 32) + bit;\r\nif (intid == dev->intfdesc.bInterruptId) {\r\nschedule_work(&dev->workcmd);\r\n} else if (intid == porta->hwcfg.interruptid) {\r\nsaa7164_irq_ts(porta);\r\n} else if (intid == portb->hwcfg.interruptid) {\r\nsaa7164_irq_ts(portb);\r\n} else if (intid == portc->hwcfg.interruptid) {\r\nsaa7164_irq_encoder(portc);\r\n} else if (intid == portd->hwcfg.interruptid) {\r\nsaa7164_irq_encoder(portd);\r\n} else if (intid == porte->hwcfg.interruptid) {\r\nsaa7164_irq_vbi(porte);\r\n} else if (intid == portf->hwcfg.interruptid) {\r\nsaa7164_irq_vbi(portf);\r\n} else {\r\ndprintk(DBGLVL_IRQ,\r\n"%s() unhandled interrupt "\r\n"reg 0x%x bit 0x%x "\r\n"intid = 0x%x\n",\r\n__func__, i, bit, intid);\r\n}\r\n}\r\nsaa7164_writel(dev->int_ack + (i * 4), intstat[i]);\r\n}\r\n}\r\nout:\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nvoid saa7164_getfirmwarestatus(struct saa7164_dev *dev)\r\n{\r\nstruct saa7164_fw_status *s = &dev->fw_status;\r\ndev->fw_status.status = saa7164_readl(SAA_DEVICE_SYSINIT_STATUS);\r\ndev->fw_status.mode = saa7164_readl(SAA_DEVICE_SYSINIT_MODE);\r\ndev->fw_status.spec = saa7164_readl(SAA_DEVICE_SYSINIT_SPEC);\r\ndev->fw_status.inst = saa7164_readl(SAA_DEVICE_SYSINIT_INST);\r\ndev->fw_status.cpuload = saa7164_readl(SAA_DEVICE_SYSINIT_CPULOAD);\r\ndev->fw_status.remainheap =\r\nsaa7164_readl(SAA_DEVICE_SYSINIT_REMAINHEAP);\r\ndprintk(1, "Firmware status:\n");\r\ndprintk(1, " .status = 0x%08x\n", s->status);\r\ndprintk(1, " .mode = 0x%08x\n", s->mode);\r\ndprintk(1, " .spec = 0x%08x\n", s->spec);\r\ndprintk(1, " .inst = 0x%08x\n", s->inst);\r\ndprintk(1, " .cpuload = 0x%08x\n", s->cpuload);\r\ndprintk(1, " .remainheap = 0x%08x\n", s->remainheap);\r\n}\r\nu32 saa7164_getcurrentfirmwareversion(struct saa7164_dev *dev)\r\n{\r\nu32 reg;\r\nreg = saa7164_readl(SAA_DEVICE_VERSION);\r\ndprintk(1, "Device running firmware version %d.%d.%d.%d (0x%x)\n",\r\n(reg & 0x0000fc00) >> 10,\r\n(reg & 0x000003e0) >> 5,\r\n(reg & 0x0000001f),\r\n(reg & 0xffff0000) >> 16,\r\nreg);\r\nreturn reg;\r\n}\r\nvoid saa7164_dumpregs(struct saa7164_dev *dev, u32 addr)\r\n{\r\nint i;\r\ndprintk(1, "--------------------> "\r\n"00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\n");\r\nfor (i = 0; i < 0x100; i += 16)\r\ndprintk(1, "region0[0x%08x] = "\r\n"%02x %02x %02x %02x %02x %02x %02x %02x"\r\n" %02x %02x %02x %02x %02x %02x %02x %02x\n", i,\r\n(u8)saa7164_readb(addr + i + 0),\r\n(u8)saa7164_readb(addr + i + 1),\r\n(u8)saa7164_readb(addr + i + 2),\r\n(u8)saa7164_readb(addr + i + 3),\r\n(u8)saa7164_readb(addr + i + 4),\r\n(u8)saa7164_readb(addr + i + 5),\r\n(u8)saa7164_readb(addr + i + 6),\r\n(u8)saa7164_readb(addr + i + 7),\r\n(u8)saa7164_readb(addr + i + 8),\r\n(u8)saa7164_readb(addr + i + 9),\r\n(u8)saa7164_readb(addr + i + 10),\r\n(u8)saa7164_readb(addr + i + 11),\r\n(u8)saa7164_readb(addr + i + 12),\r\n(u8)saa7164_readb(addr + i + 13),\r\n(u8)saa7164_readb(addr + i + 14),\r\n(u8)saa7164_readb(addr + i + 15)\r\n);\r\n}\r\nstatic void saa7164_dump_hwdesc(struct saa7164_dev *dev)\r\n{\r\ndprintk(1, "@0x%p hwdesc sizeof(struct tmComResHWDescr) = %d bytes\n",\r\n&dev->hwdesc, (u32)sizeof(struct tmComResHWDescr));\r\ndprintk(1, " .bLength = 0x%x\n", dev->hwdesc.bLength);\r\ndprintk(1, " .bDescriptorType = 0x%x\n", dev->hwdesc.bDescriptorType);\r\ndprintk(1, " .bDescriptorSubtype = 0x%x\n",\r\ndev->hwdesc.bDescriptorSubtype);\r\ndprintk(1, " .bcdSpecVersion = 0x%x\n", dev->hwdesc.bcdSpecVersion);\r\ndprintk(1, " .dwClockFrequency = 0x%x\n", dev->hwdesc.dwClockFrequency);\r\ndprintk(1, " .dwClockUpdateRes = 0x%x\n", dev->hwdesc.dwClockUpdateRes);\r\ndprintk(1, " .bCapabilities = 0x%x\n", dev->hwdesc.bCapabilities);\r\ndprintk(1, " .dwDeviceRegistersLocation = 0x%x\n",\r\ndev->hwdesc.dwDeviceRegistersLocation);\r\ndprintk(1, " .dwHostMemoryRegion = 0x%x\n",\r\ndev->hwdesc.dwHostMemoryRegion);\r\ndprintk(1, " .dwHostMemoryRegionSize = 0x%x\n",\r\ndev->hwdesc.dwHostMemoryRegionSize);\r\ndprintk(1, " .dwHostHibernatMemRegion = 0x%x\n",\r\ndev->hwdesc.dwHostHibernatMemRegion);\r\ndprintk(1, " .dwHostHibernatMemRegionSize = 0x%x\n",\r\ndev->hwdesc.dwHostHibernatMemRegionSize);\r\n}\r\nstatic void saa7164_dump_intfdesc(struct saa7164_dev *dev)\r\n{\r\ndprintk(1, "@0x%p intfdesc "\r\n"sizeof(struct tmComResInterfaceDescr) = %d bytes\n",\r\n&dev->intfdesc, (u32)sizeof(struct tmComResInterfaceDescr));\r\ndprintk(1, " .bLength = 0x%x\n", dev->intfdesc.bLength);\r\ndprintk(1, " .bDescriptorType = 0x%x\n", dev->intfdesc.bDescriptorType);\r\ndprintk(1, " .bDescriptorSubtype = 0x%x\n",\r\ndev->intfdesc.bDescriptorSubtype);\r\ndprintk(1, " .bFlags = 0x%x\n", dev->intfdesc.bFlags);\r\ndprintk(1, " .bInterfaceType = 0x%x\n", dev->intfdesc.bInterfaceType);\r\ndprintk(1, " .bInterfaceId = 0x%x\n", dev->intfdesc.bInterfaceId);\r\ndprintk(1, " .bBaseInterface = 0x%x\n", dev->intfdesc.bBaseInterface);\r\ndprintk(1, " .bInterruptId = 0x%x\n", dev->intfdesc.bInterruptId);\r\ndprintk(1, " .bDebugInterruptId = 0x%x\n",\r\ndev->intfdesc.bDebugInterruptId);\r\ndprintk(1, " .BARLocation = 0x%x\n", dev->intfdesc.BARLocation);\r\n}\r\nstatic void saa7164_dump_busdesc(struct saa7164_dev *dev)\r\n{\r\ndprintk(1, "@0x%p busdesc sizeof(struct tmComResBusDescr) = %d bytes\n",\r\n&dev->busdesc, (u32)sizeof(struct tmComResBusDescr));\r\ndprintk(1, " .CommandRing = 0x%016Lx\n", dev->busdesc.CommandRing);\r\ndprintk(1, " .ResponseRing = 0x%016Lx\n", dev->busdesc.ResponseRing);\r\ndprintk(1, " .CommandWrite = 0x%x\n", dev->busdesc.CommandWrite);\r\ndprintk(1, " .CommandRead = 0x%x\n", dev->busdesc.CommandRead);\r\ndprintk(1, " .ResponseWrite = 0x%x\n", dev->busdesc.ResponseWrite);\r\ndprintk(1, " .ResponseRead = 0x%x\n", dev->busdesc.ResponseRead);\r\n}\r\nstatic void saa7164_get_descriptors(struct saa7164_dev *dev)\r\n{\r\nmemcpy_fromio(&dev->hwdesc, dev->bmmio, sizeof(struct tmComResHWDescr));\r\nmemcpy_fromio(&dev->intfdesc, dev->bmmio + sizeof(struct tmComResHWDescr),\r\nsizeof(struct tmComResInterfaceDescr));\r\nmemcpy_fromio(&dev->busdesc, dev->bmmio + dev->intfdesc.BARLocation,\r\nsizeof(struct tmComResBusDescr));\r\nif (dev->hwdesc.bLength != sizeof(struct tmComResHWDescr)) {\r\nprintk(KERN_ERR "Structure struct tmComResHWDescr is mangled\n");\r\nprintk(KERN_ERR "Need %x got %d\n", dev->hwdesc.bLength,\r\n(u32)sizeof(struct tmComResHWDescr));\r\n} else\r\nsaa7164_dump_hwdesc(dev);\r\nif (dev->intfdesc.bLength != sizeof(struct tmComResInterfaceDescr)) {\r\nprintk(KERN_ERR "struct struct tmComResInterfaceDescr is mangled\n");\r\nprintk(KERN_ERR "Need %x got %d\n", dev->intfdesc.bLength,\r\n(u32)sizeof(struct tmComResInterfaceDescr));\r\n} else\r\nsaa7164_dump_intfdesc(dev);\r\nsaa7164_dump_busdesc(dev);\r\n}\r\nstatic int saa7164_pci_quirks(struct saa7164_dev *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int get_resources(struct saa7164_dev *dev)\r\n{\r\nif (request_mem_region(pci_resource_start(dev->pci, 0),\r\npci_resource_len(dev->pci, 0), dev->name)) {\r\nif (request_mem_region(pci_resource_start(dev->pci, 2),\r\npci_resource_len(dev->pci, 2), dev->name))\r\nreturn 0;\r\n}\r\nprintk(KERN_ERR "%s: can't get MMIO memory @ 0x%llx or 0x%llx\n",\r\ndev->name,\r\n(u64)pci_resource_start(dev->pci, 0),\r\n(u64)pci_resource_start(dev->pci, 2));\r\nreturn -EBUSY;\r\n}\r\nstatic int saa7164_port_init(struct saa7164_dev *dev, int portnr)\r\n{\r\nstruct saa7164_port *port = NULL;\r\nif ((portnr < 0) || (portnr >= SAA7164_MAX_PORTS))\r\nBUG();\r\nport = &dev->ports[portnr];\r\nport->dev = dev;\r\nport->nr = portnr;\r\nif ((portnr == SAA7164_PORT_TS1) || (portnr == SAA7164_PORT_TS2))\r\nport->type = SAA7164_MPEG_DVB;\r\nelse\r\nif ((portnr == SAA7164_PORT_ENC1) || (portnr == SAA7164_PORT_ENC2)) {\r\nport->type = SAA7164_MPEG_ENCODER;\r\nINIT_WORK(&port->workenc, saa7164_work_enchandler);\r\n} else if ((portnr == SAA7164_PORT_VBI1) || (portnr == SAA7164_PORT_VBI2)) {\r\nport->type = SAA7164_MPEG_VBI;\r\nINIT_WORK(&port->workenc, saa7164_work_vbihandler);\r\n} else\r\nBUG();\r\nmutex_init(&port->dvb.lock);\r\nINIT_LIST_HEAD(&port->dmaqueue.list);\r\nmutex_init(&port->dmaqueue_lock);\r\nINIT_LIST_HEAD(&port->list_buf_used.list);\r\nINIT_LIST_HEAD(&port->list_buf_free.list);\r\ninit_waitqueue_head(&port->wait_read);\r\nsaa7164_histogram_reset(&port->irq_interval, "irq intervals");\r\nsaa7164_histogram_reset(&port->svc_interval, "deferred intervals");\r\nsaa7164_histogram_reset(&port->irq_svc_interval,\r\n"irq to deferred intervals");\r\nsaa7164_histogram_reset(&port->read_interval,\r\n"encoder/vbi read() intervals");\r\nsaa7164_histogram_reset(&port->poll_interval,\r\n"encoder/vbi poll() intervals");\r\nreturn 0;\r\n}\r\nstatic int saa7164_dev_setup(struct saa7164_dev *dev)\r\n{\r\nint i;\r\nmutex_init(&dev->lock);\r\natomic_inc(&dev->refcount);\r\ndev->nr = saa7164_devcount++;\r\nsnprintf(dev->name, sizeof(dev->name), "saa7164[%d]", dev->nr);\r\nmutex_lock(&devlist);\r\nlist_add_tail(&dev->devlist, &saa7164_devlist);\r\nmutex_unlock(&devlist);\r\ndev->board = UNSET;\r\nif (card[dev->nr] < saa7164_bcount)\r\ndev->board = card[dev->nr];\r\nfor (i = 0; UNSET == dev->board && i < saa7164_idcount; i++)\r\nif (dev->pci->subsystem_vendor == saa7164_subids[i].subvendor &&\r\ndev->pci->subsystem_device ==\r\nsaa7164_subids[i].subdevice)\r\ndev->board = saa7164_subids[i].card;\r\nif (UNSET == dev->board) {\r\ndev->board = SAA7164_BOARD_UNKNOWN;\r\nsaa7164_card_list(dev);\r\n}\r\ndev->pci_bus = dev->pci->bus->number;\r\ndev->pci_slot = PCI_SLOT(dev->pci->devfn);\r\ndev->i2c_bus[0].dev = dev;\r\ndev->i2c_bus[0].nr = 0;\r\ndev->i2c_bus[1].dev = dev;\r\ndev->i2c_bus[1].nr = 1;\r\ndev->i2c_bus[2].dev = dev;\r\ndev->i2c_bus[2].nr = 2;\r\nsaa7164_port_init(dev, SAA7164_PORT_TS1);\r\nsaa7164_port_init(dev, SAA7164_PORT_TS2);\r\nsaa7164_port_init(dev, SAA7164_PORT_ENC1);\r\nsaa7164_port_init(dev, SAA7164_PORT_ENC2);\r\nsaa7164_port_init(dev, SAA7164_PORT_VBI1);\r\nsaa7164_port_init(dev, SAA7164_PORT_VBI2);\r\nif (get_resources(dev) < 0) {\r\nprintk(KERN_ERR "CORE %s No more PCIe resources for "\r\n"subsystem: %04x:%04x\n",\r\ndev->name, dev->pci->subsystem_vendor,\r\ndev->pci->subsystem_device);\r\nsaa7164_devcount--;\r\nreturn -ENODEV;\r\n}\r\ndev->lmmio = ioremap(pci_resource_start(dev->pci, 0),\r\npci_resource_len(dev->pci, 0));\r\ndev->lmmio2 = ioremap(pci_resource_start(dev->pci, 2),\r\npci_resource_len(dev->pci, 2));\r\ndev->bmmio = (u8 __iomem *)dev->lmmio;\r\ndev->bmmio2 = (u8 __iomem *)dev->lmmio2;\r\ndev->int_status = 0x183000 + 0xf80;\r\ndev->int_ack = 0x183000 + 0xf90;\r\nprintk(KERN_INFO\r\n"CORE %s: subsystem: %04x:%04x, board: %s [card=%d,%s]\n",\r\ndev->name, dev->pci->subsystem_vendor,\r\ndev->pci->subsystem_device, saa7164_boards[dev->board].name,\r\ndev->board, card[dev->nr] == dev->board ?\r\n"insmod option" : "autodetected");\r\nsaa7164_pci_quirks(dev);\r\nreturn 0;\r\n}\r\nstatic void saa7164_dev_unregister(struct saa7164_dev *dev)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\nrelease_mem_region(pci_resource_start(dev->pci, 0),\r\npci_resource_len(dev->pci, 0));\r\nrelease_mem_region(pci_resource_start(dev->pci, 2),\r\npci_resource_len(dev->pci, 2));\r\nif (!atomic_dec_and_test(&dev->refcount))\r\nreturn;\r\niounmap(dev->lmmio);\r\niounmap(dev->lmmio2);\r\nreturn;\r\n}\r\nstatic int saa7164_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct saa7164_dev *dev;\r\nstruct tmComResBusInfo *b;\r\nstruct list_head *list;\r\nint i, c;\r\nif (saa7164_devcount == 0)\r\nreturn 0;\r\nlist_for_each(list, &saa7164_devlist) {\r\ndev = list_entry(list, struct saa7164_dev, devlist);\r\nseq_printf(m, "%s = %p\n", dev->name, dev);\r\nb = &dev->bus;\r\nmutex_lock(&b->lock);\r\nseq_printf(m, " .m_pdwSetWritePos = 0x%x (0x%08x)\n",\r\nb->m_dwSetReadPos, saa7164_readl(b->m_dwSetReadPos));\r\nseq_printf(m, " .m_pdwSetReadPos = 0x%x (0x%08x)\n",\r\nb->m_dwSetWritePos, saa7164_readl(b->m_dwSetWritePos));\r\nseq_printf(m, " .m_pdwGetWritePos = 0x%x (0x%08x)\n",\r\nb->m_dwGetReadPos, saa7164_readl(b->m_dwGetReadPos));\r\nseq_printf(m, " .m_pdwGetReadPos = 0x%x (0x%08x)\n",\r\nb->m_dwGetWritePos, saa7164_readl(b->m_dwGetWritePos));\r\nc = 0;\r\nseq_printf(m, "\n Set Ring:\n");\r\nseq_printf(m, "\n addr 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\n");\r\nfor (i = 0; i < b->m_dwSizeSetRing; i++) {\r\nif (c == 0)\r\nseq_printf(m, " %04x:", i);\r\nseq_printf(m, " %02x", readb(b->m_pdwSetRing + i));\r\nif (++c == 16) {\r\nseq_printf(m, "\n");\r\nc = 0;\r\n}\r\n}\r\nc = 0;\r\nseq_printf(m, "\n Get Ring:\n");\r\nseq_printf(m, "\n addr 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\n");\r\nfor (i = 0; i < b->m_dwSizeGetRing; i++) {\r\nif (c == 0)\r\nseq_printf(m, " %04x:", i);\r\nseq_printf(m, " %02x", readb(b->m_pdwGetRing + i));\r\nif (++c == 16) {\r\nseq_printf(m, "\n");\r\nc = 0;\r\n}\r\n}\r\nmutex_unlock(&b->lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7164_proc_open(struct inode *inode, struct file *filp)\r\n{\r\nreturn single_open(filp, saa7164_proc_show, NULL);\r\n}\r\nstatic int saa7164_proc_create(void)\r\n{\r\nstruct proc_dir_entry *pe;\r\npe = proc_create("saa7164", S_IRUGO, NULL, &saa7164_proc_fops);\r\nif (!pe)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int saa7164_thread_function(void *data)\r\n{\r\nstruct saa7164_dev *dev = data;\r\nstruct tmFwInfoStruct fwinfo;\r\nu64 last_poll_time = 0;\r\ndprintk(DBGLVL_THR, "thread started\n");\r\nset_freezable();\r\nwhile (1) {\r\nmsleep_interruptible(100);\r\nif (kthread_should_stop())\r\nbreak;\r\ntry_to_freeze();\r\ndprintk(DBGLVL_THR, "thread running\n");\r\nsaa7164_api_collect_debug(dev);\r\nif ((last_poll_time + 1000 ) < jiffies_to_msecs(jiffies)) {\r\nsaa7164_api_get_load_info(dev, &fwinfo);\r\nlast_poll_time = jiffies_to_msecs(jiffies);\r\n}\r\n}\r\ndprintk(DBGLVL_THR, "thread exiting\n");\r\nreturn 0;\r\n}\r\nstatic int saa7164_initdev(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct saa7164_dev *dev;\r\nint err, i;\r\nu32 version;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (NULL == dev)\r\nreturn -ENOMEM;\r\nerr = v4l2_device_register(&pci_dev->dev, &dev->v4l2_dev);\r\nif (err < 0) {\r\ndev_err(&pci_dev->dev, "v4l2_device_register failed\n");\r\ngoto fail_free;\r\n}\r\ndev->pci = pci_dev;\r\nif (pci_enable_device(pci_dev)) {\r\nerr = -EIO;\r\ngoto fail_free;\r\n}\r\nif (saa7164_dev_setup(dev) < 0) {\r\nerr = -EINVAL;\r\ngoto fail_free;\r\n}\r\ndev->pci_rev = pci_dev->revision;\r\npci_read_config_byte(pci_dev, PCI_LATENCY_TIMER, &dev->pci_lat);\r\nprintk(KERN_INFO "%s/0: found at %s, rev: %d, irq: %d, "\r\n"latency: %d, mmio: 0x%llx\n", dev->name,\r\npci_name(pci_dev), dev->pci_rev, pci_dev->irq,\r\ndev->pci_lat,\r\n(unsigned long long)pci_resource_start(pci_dev, 0));\r\npci_set_master(pci_dev);\r\nif (!pci_dma_supported(pci_dev, 0xffffffff)) {\r\nprintk("%s/0: Oops: no 32bit PCI DMA ???\n", dev->name);\r\nerr = -EIO;\r\ngoto fail_irq;\r\n}\r\nerr = request_irq(pci_dev->irq, saa7164_irq,\r\nIRQF_SHARED, dev->name, dev);\r\nif (err < 0) {\r\nprintk(KERN_ERR "%s: can't get IRQ %d\n", dev->name,\r\npci_dev->irq);\r\nerr = -EIO;\r\ngoto fail_irq;\r\n}\r\npci_set_drvdata(pci_dev, dev);\r\nfor (i = 0; i < SAA_CMD_MAX_MSG_UNITS; i++) {\r\ndev->cmds[i].seqno = i;\r\ndev->cmds[i].inuse = 0;\r\nmutex_init(&dev->cmds[i].lock);\r\ninit_waitqueue_head(&dev->cmds[i].wait);\r\n}\r\nINIT_WORK(&dev->workcmd, saa7164_work_cmdhandler);\r\nif (dev->board != SAA7164_BOARD_UNKNOWN) {\r\nerr = saa7164_downloadfirmware(dev);\r\nif (err < 0) {\r\nprintk(KERN_ERR\r\n"Failed to boot firmware, no features "\r\n"registered\n");\r\ngoto fail_fw;\r\n}\r\nsaa7164_get_descriptors(dev);\r\nsaa7164_dumpregs(dev, 0);\r\nsaa7164_getcurrentfirmwareversion(dev);\r\nsaa7164_getfirmwarestatus(dev);\r\nerr = saa7164_bus_setup(dev);\r\nif (err < 0)\r\nprintk(KERN_ERR\r\n"Failed to setup the bus, will continue\n");\r\nsaa7164_bus_dump(dev);\r\nversion = 0;\r\nif (saa7164_api_get_fw_version(dev, &version) == SAA_OK)\r\ndprintk(1, "Bus is operating correctly using "\r\n"version %d.%d.%d.%d (0x%x)\n",\r\n(version & 0x0000fc00) >> 10,\r\n(version & 0x000003e0) >> 5,\r\n(version & 0x0000001f),\r\n(version & 0xffff0000) >> 16,\r\nversion);\r\nelse\r\nprintk(KERN_ERR\r\n"Failed to communicate with the firmware\n");\r\nsaa7164_i2c_register(&dev->i2c_bus[0]);\r\nsaa7164_i2c_register(&dev->i2c_bus[1]);\r\nsaa7164_i2c_register(&dev->i2c_bus[2]);\r\nsaa7164_gpio_setup(dev);\r\nsaa7164_card_setup(dev);\r\nsaa7164_api_enum_subdevs(dev);\r\nif (saa7164_boards[dev->board].porta == SAA7164_MPEG_DVB) {\r\nif (saa7164_dvb_register(&dev->ports[SAA7164_PORT_TS1]) < 0) {\r\nprintk(KERN_ERR "%s() Failed to register "\r\n"dvb adapters on porta\n",\r\n__func__);\r\n}\r\n}\r\nif (saa7164_boards[dev->board].portb == SAA7164_MPEG_DVB) {\r\nif (saa7164_dvb_register(&dev->ports[SAA7164_PORT_TS2]) < 0) {\r\nprintk(KERN_ERR"%s() Failed to register "\r\n"dvb adapters on portb\n",\r\n__func__);\r\n}\r\n}\r\nif (saa7164_boards[dev->board].portc == SAA7164_MPEG_ENCODER) {\r\nif (saa7164_encoder_register(&dev->ports[SAA7164_PORT_ENC1]) < 0) {\r\nprintk(KERN_ERR"%s() Failed to register "\r\n"mpeg encoder\n", __func__);\r\n}\r\n}\r\nif (saa7164_boards[dev->board].portd == SAA7164_MPEG_ENCODER) {\r\nif (saa7164_encoder_register(&dev->ports[SAA7164_PORT_ENC2]) < 0) {\r\nprintk(KERN_ERR"%s() Failed to register "\r\n"mpeg encoder\n", __func__);\r\n}\r\n}\r\nif (saa7164_boards[dev->board].porte == SAA7164_MPEG_VBI) {\r\nif (saa7164_vbi_register(&dev->ports[SAA7164_PORT_VBI1]) < 0) {\r\nprintk(KERN_ERR"%s() Failed to register "\r\n"vbi device\n", __func__);\r\n}\r\n}\r\nif (saa7164_boards[dev->board].portf == SAA7164_MPEG_VBI) {\r\nif (saa7164_vbi_register(&dev->ports[SAA7164_PORT_VBI2]) < 0) {\r\nprintk(KERN_ERR"%s() Failed to register "\r\n"vbi device\n", __func__);\r\n}\r\n}\r\nsaa7164_api_set_debug(dev, fw_debug);\r\nif (fw_debug) {\r\ndev->kthread = kthread_run(saa7164_thread_function, dev,\r\n"saa7164 debug");\r\nif (IS_ERR(dev->kthread)) {\r\ndev->kthread = NULL;\r\nprintk(KERN_ERR "%s() Failed to create "\r\n"debug kernel thread\n", __func__);\r\n}\r\n}\r\n}\r\nelse\r\nprintk(KERN_ERR "%s() Unsupported board detected, "\r\n"registering without firmware\n", __func__);\r\ndprintk(1, "%s() parameter debug = %d\n", __func__, saa_debug);\r\ndprintk(1, "%s() parameter waitsecs = %d\n", __func__, waitsecs);\r\nfail_fw:\r\nreturn 0;\r\nfail_irq:\r\nsaa7164_dev_unregister(dev);\r\nfail_free:\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nkfree(dev);\r\nreturn err;\r\n}\r\nstatic void saa7164_shutdown(struct saa7164_dev *dev)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\n}\r\nstatic void saa7164_finidev(struct pci_dev *pci_dev)\r\n{\r\nstruct saa7164_dev *dev = pci_get_drvdata(pci_dev);\r\nif (dev->board != SAA7164_BOARD_UNKNOWN) {\r\nif (fw_debug && dev->kthread) {\r\nkthread_stop(dev->kthread);\r\ndev->kthread = NULL;\r\n}\r\nif (dev->firmwareloaded)\r\nsaa7164_api_set_debug(dev, 0x00);\r\n}\r\nsaa7164_histogram_print(&dev->ports[SAA7164_PORT_ENC1],\r\n&dev->ports[SAA7164_PORT_ENC1].irq_interval);\r\nsaa7164_histogram_print(&dev->ports[SAA7164_PORT_ENC1],\r\n&dev->ports[SAA7164_PORT_ENC1].svc_interval);\r\nsaa7164_histogram_print(&dev->ports[SAA7164_PORT_ENC1],\r\n&dev->ports[SAA7164_PORT_ENC1].irq_svc_interval);\r\nsaa7164_histogram_print(&dev->ports[SAA7164_PORT_ENC1],\r\n&dev->ports[SAA7164_PORT_ENC1].read_interval);\r\nsaa7164_histogram_print(&dev->ports[SAA7164_PORT_ENC1],\r\n&dev->ports[SAA7164_PORT_ENC1].poll_interval);\r\nsaa7164_histogram_print(&dev->ports[SAA7164_PORT_VBI1],\r\n&dev->ports[SAA7164_PORT_VBI1].read_interval);\r\nsaa7164_histogram_print(&dev->ports[SAA7164_PORT_VBI2],\r\n&dev->ports[SAA7164_PORT_VBI2].poll_interval);\r\nsaa7164_shutdown(dev);\r\nif (saa7164_boards[dev->board].porta == SAA7164_MPEG_DVB)\r\nsaa7164_dvb_unregister(&dev->ports[SAA7164_PORT_TS1]);\r\nif (saa7164_boards[dev->board].portb == SAA7164_MPEG_DVB)\r\nsaa7164_dvb_unregister(&dev->ports[SAA7164_PORT_TS2]);\r\nif (saa7164_boards[dev->board].portc == SAA7164_MPEG_ENCODER)\r\nsaa7164_encoder_unregister(&dev->ports[SAA7164_PORT_ENC1]);\r\nif (saa7164_boards[dev->board].portd == SAA7164_MPEG_ENCODER)\r\nsaa7164_encoder_unregister(&dev->ports[SAA7164_PORT_ENC2]);\r\nif (saa7164_boards[dev->board].porte == SAA7164_MPEG_VBI)\r\nsaa7164_vbi_unregister(&dev->ports[SAA7164_PORT_VBI1]);\r\nif (saa7164_boards[dev->board].portf == SAA7164_MPEG_VBI)\r\nsaa7164_vbi_unregister(&dev->ports[SAA7164_PORT_VBI2]);\r\nsaa7164_i2c_unregister(&dev->i2c_bus[0]);\r\nsaa7164_i2c_unregister(&dev->i2c_bus[1]);\r\nsaa7164_i2c_unregister(&dev->i2c_bus[2]);\r\npci_disable_device(pci_dev);\r\nfree_irq(pci_dev->irq, dev);\r\nmutex_lock(&devlist);\r\nlist_del(&dev->devlist);\r\nmutex_unlock(&devlist);\r\nsaa7164_dev_unregister(dev);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nkfree(dev);\r\n}\r\nstatic int __init saa7164_init(void)\r\n{\r\nprintk(KERN_INFO "saa7164 driver loaded\n");\r\n#ifdef CONFIG_PROC_FS\r\nsaa7164_proc_create();\r\n#endif\r\nreturn pci_register_driver(&saa7164_pci_driver);\r\n}\r\nstatic void __exit saa7164_fini(void)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\nremove_proc_entry("saa7164", NULL);\r\n#endif\r\npci_unregister_driver(&saa7164_pci_driver);\r\n}
