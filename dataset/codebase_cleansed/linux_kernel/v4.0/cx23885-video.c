static struct cx23885_fmt *format_by_fourcc(unsigned int fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(formats); i++)\r\nif (formats[i].fourcc == fourcc)\r\nreturn formats+i;\r\nreturn NULL;\r\n}\r\nvoid cx23885_video_wakeup(struct cx23885_dev *dev,\r\nstruct cx23885_dmaqueue *q, u32 count)\r\n{\r\nstruct cx23885_buffer *buf;\r\nif (list_empty(&q->active))\r\nreturn;\r\nbuf = list_entry(q->active.next,\r\nstruct cx23885_buffer, queue);\r\nbuf->vb.v4l2_buf.sequence = q->count++;\r\nv4l2_get_timestamp(&buf->vb.v4l2_buf.timestamp);\r\ndprintk(2, "[%p/%d] wakeup reg=%d buf=%d\n", buf, buf->vb.v4l2_buf.index,\r\ncount, q->count);\r\nlist_del(&buf->queue);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_DONE);\r\n}\r\nint cx23885_set_tvnorm(struct cx23885_dev *dev, v4l2_std_id norm)\r\n{\r\ndprintk(1, "%s(norm = 0x%08x) name: [%s]\n",\r\n__func__,\r\n(unsigned int)norm,\r\nv4l2_norm_to_name(norm));\r\nif (dev->tvnorm != norm) {\r\nif (vb2_is_busy(&dev->vb2_vidq) || vb2_is_busy(&dev->vb2_vbiq) ||\r\nvb2_is_busy(&dev->vb2_mpegq))\r\nreturn -EBUSY;\r\n}\r\ndev->tvnorm = norm;\r\ncall_all(dev, video, s_std, norm);\r\nreturn 0;\r\n}\r\nstatic struct video_device *cx23885_vdev_init(struct cx23885_dev *dev,\r\nstruct pci_dev *pci,\r\nstruct video_device *template,\r\nchar *type)\r\n{\r\nstruct video_device *vfd;\r\ndprintk(1, "%s()\n", __func__);\r\nvfd = video_device_alloc();\r\nif (NULL == vfd)\r\nreturn NULL;\r\n*vfd = *template;\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->release = video_device_release;\r\nvfd->lock = &dev->lock;\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s (%s)",\r\ncx23885_boards[dev->board].name, type);\r\nvideo_set_drvdata(vfd, dev);\r\nreturn vfd;\r\n}\r\nint cx23885_flatiron_write(struct cx23885_dev *dev, u8 reg, u8 data)\r\n{\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = { .addr = 0x98 >> 1,\r\n.flags = 0, .buf = buf, .len = 2 };\r\nreturn i2c_transfer(&dev->i2c_bus[2].i2c_adap, &msg, 1);\r\n}\r\nu8 cx23885_flatiron_read(struct cx23885_dev *dev, u8 reg)\r\n{\r\nint ret;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0 };\r\nstruct i2c_msg msg[] = {\r\n{ .addr = 0x98 >> 1, .flags = 0, .buf = b0, .len = 1 },\r\n{ .addr = 0x98 >> 1, .flags = I2C_M_RD, .buf = b1, .len = 1 }\r\n};\r\nret = i2c_transfer(&dev->i2c_bus[2].i2c_adap, &msg[0], 2);\r\nif (ret != 2)\r\nprintk(KERN_ERR "%s() error\n", __func__);\r\nreturn b1[0];\r\n}\r\nstatic void cx23885_flatiron_dump(struct cx23885_dev *dev)\r\n{\r\nint i;\r\ndprintk(1, "Flatiron dump\n");\r\nfor (i = 0; i < 0x24; i++) {\r\ndprintk(1, "FI[%02x] = %02x\n", i,\r\ncx23885_flatiron_read(dev, i));\r\n}\r\n}\r\nstatic int cx23885_flatiron_mux(struct cx23885_dev *dev, int input)\r\n{\r\nu8 val;\r\ndprintk(1, "%s(input = %d)\n", __func__, input);\r\nif (input == 1)\r\nval = cx23885_flatiron_read(dev, CH_PWR_CTRL1) & ~FLD_CH_SEL;\r\nelse if (input == 2)\r\nval = cx23885_flatiron_read(dev, CH_PWR_CTRL1) | FLD_CH_SEL;\r\nelse\r\nreturn -EINVAL;\r\nval |= 0x20;\r\ncx23885_flatiron_write(dev, CH_PWR_CTRL1, val);\r\ncx23885_flatiron_write(dev, CH_PWR_CTRL2, 0);\r\nif (video_debug)\r\ncx23885_flatiron_dump(dev);\r\nreturn 0;\r\n}\r\nstatic int cx23885_video_mux(struct cx23885_dev *dev, unsigned int input)\r\n{\r\ndprintk(1, "%s() video_mux: %d [vmux=%d, gpio=0x%x,0x%x,0x%x,0x%x]\n",\r\n__func__,\r\ninput, INPUT(input)->vmux,\r\nINPUT(input)->gpio0, INPUT(input)->gpio1,\r\nINPUT(input)->gpio2, INPUT(input)->gpio3);\r\ndev->input = input;\r\nif (dev->board == CX23885_BOARD_MYGICA_X8506 ||\r\ndev->board == CX23885_BOARD_MAGICPRO_PROHDTVE2 ||\r\ndev->board == CX23885_BOARD_MYGICA_X8507) {\r\nif (INPUT(input)->type == CX23885_VMUX_TELEVISION)\r\ncx23885_gpio_clear(dev, GPIO_0);\r\n}\r\nv4l2_subdev_call(dev->sd_cx25840, video, s_routing,\r\nINPUT(input)->vmux, 0, 0);\r\nif ((dev->board == CX23885_BOARD_HAUPPAUGE_HVR1800) ||\r\n(dev->board == CX23885_BOARD_MPX885) ||\r\n(dev->board == CX23885_BOARD_HAUPPAUGE_HVR1250) ||\r\n(dev->board == CX23885_BOARD_HAUPPAUGE_IMPACTVCBE) ||\r\n(dev->board == CX23885_BOARD_HAUPPAUGE_HVR1255) ||\r\n(dev->board == CX23885_BOARD_HAUPPAUGE_HVR1255_22111) ||\r\n(dev->board == CX23885_BOARD_HAUPPAUGE_HVR1850) ||\r\n(dev->board == CX23885_BOARD_MYGICA_X8507) ||\r\n(dev->board == CX23885_BOARD_AVERMEDIA_HC81R)) {\r\nv4l2_subdev_call(dev->sd_cx25840, audio, s_routing,\r\nINPUT(input)->amux, 0, 0);\r\nif (INPUT(input)->amux == CX25840_AUDIO7)\r\ncx23885_flatiron_mux(dev, 1);\r\nelse if (INPUT(input)->amux == CX25840_AUDIO6)\r\ncx23885_flatiron_mux(dev, 2);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx23885_audio_mux(struct cx23885_dev *dev, unsigned int input)\r\n{\r\ndprintk(1, "%s(input=%d)\n", __func__, input);\r\nif (INPUT(input)->amux == CX25840_AUDIO7)\r\ncx23885_flatiron_mux(dev, 1);\r\nelse if (INPUT(input)->amux == CX25840_AUDIO6)\r\ncx23885_flatiron_mux(dev, 2);\r\nelse {\r\ncx23885_flatiron_mux(dev, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx23885_start_video_dma(struct cx23885_dev *dev,\r\nstruct cx23885_dmaqueue *q,\r\nstruct cx23885_buffer *buf)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\ncx_clear(VID_A_DMA_CTL, 0x11);\r\ncx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH01],\r\nbuf->bpl, buf->risc.dma);\r\ncx_write(VID_A_GPCNT_CTL, 3);\r\nq->count = 0;\r\ncx23885_irq_add_enable(dev, 0x01);\r\ncx_set(VID_A_INT_MSK, 0x000011);\r\ncx_set(DEV_CNTRL2, (1<<5));\r\ncx_set(VID_A_DMA_CTL, 0x11);\r\nreturn 0;\r\n}\r\nstatic int queue_setup(struct vb2_queue *q, const struct v4l2_format *fmt,\r\nunsigned int *num_buffers, unsigned int *num_planes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct cx23885_dev *dev = q->drv_priv;\r\n*num_planes = 1;\r\nsizes[0] = (dev->fmt->depth * dev->width * dev->height) >> 3;\r\nalloc_ctxs[0] = dev->alloc_ctx;\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct cx23885_dev *dev = vb->vb2_queue->drv_priv;\r\nstruct cx23885_buffer *buf =\r\ncontainer_of(vb, struct cx23885_buffer, vb);\r\nu32 line0_offset, line1_offset;\r\nstruct sg_table *sgt = vb2_dma_sg_plane_desc(vb, 0);\r\nint field_tff;\r\nbuf->bpl = (dev->width * dev->fmt->depth) >> 3;\r\nif (vb2_plane_size(vb, 0) < dev->height * buf->bpl)\r\nreturn -EINVAL;\r\nvb2_set_plane_payload(vb, 0, dev->height * buf->bpl);\r\nswitch (dev->field) {\r\ncase V4L2_FIELD_TOP:\r\ncx23885_risc_buffer(dev->pci, &buf->risc,\r\nsgt->sgl, 0, UNSET,\r\nbuf->bpl, 0, dev->height);\r\nbreak;\r\ncase V4L2_FIELD_BOTTOM:\r\ncx23885_risc_buffer(dev->pci, &buf->risc,\r\nsgt->sgl, UNSET, 0,\r\nbuf->bpl, 0, dev->height);\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\nif (dev->tvnorm & V4L2_STD_525_60)\r\nfield_tff = 1;\r\nelse\r\nfield_tff = 0;\r\nif (cx23885_boards[dev->board].force_bff)\r\nfield_tff = 0;\r\nif (field_tff) {\r\ndprintk(1, "%s() Creating TFF/NTSC risc\n",\r\n__func__);\r\nline0_offset = buf->bpl;\r\nline1_offset = 0;\r\n} else {\r\ndprintk(1, "%s() Creating BFF/PAL/SECAM risc\n",\r\n__func__);\r\nline0_offset = 0;\r\nline1_offset = buf->bpl;\r\n}\r\ncx23885_risc_buffer(dev->pci, &buf->risc,\r\nsgt->sgl, line0_offset,\r\nline1_offset,\r\nbuf->bpl, buf->bpl,\r\ndev->height >> 1);\r\nbreak;\r\ncase V4L2_FIELD_SEQ_TB:\r\ncx23885_risc_buffer(dev->pci, &buf->risc,\r\nsgt->sgl,\r\n0, buf->bpl * (dev->height >> 1),\r\nbuf->bpl, 0,\r\ndev->height >> 1);\r\nbreak;\r\ncase V4L2_FIELD_SEQ_BT:\r\ncx23885_risc_buffer(dev->pci, &buf->risc,\r\nsgt->sgl,\r\nbuf->bpl * (dev->height >> 1), 0,\r\nbuf->bpl, 0,\r\ndev->height >> 1);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\ndprintk(2, "[%p/%d] buffer_init - %dx%d %dbpp \"%s\" - dma=0x%08lx\n",\r\nbuf, buf->vb.v4l2_buf.index,\r\ndev->width, dev->height, dev->fmt->depth, dev->fmt->name,\r\n(unsigned long)buf->risc.dma);\r\nreturn 0;\r\n}\r\nstatic void buffer_finish(struct vb2_buffer *vb)\r\n{\r\nstruct cx23885_buffer *buf = container_of(vb,\r\nstruct cx23885_buffer, vb);\r\ncx23885_free_buffer(vb->vb2_queue->drv_priv, buf);\r\n}\r\nstatic void buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct cx23885_dev *dev = vb->vb2_queue->drv_priv;\r\nstruct cx23885_buffer *buf = container_of(vb,\r\nstruct cx23885_buffer, vb);\r\nstruct cx23885_buffer *prev;\r\nstruct cx23885_dmaqueue *q = &dev->vidq;\r\nunsigned long flags;\r\nbuf->risc.cpu[1] = cpu_to_le32(buf->risc.dma + 12);\r\nbuf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_CNT_INC);\r\nbuf->risc.jmp[1] = cpu_to_le32(buf->risc.dma + 12);\r\nbuf->risc.jmp[2] = cpu_to_le32(0);\r\nspin_lock_irqsave(&dev->slock, flags);\r\nif (list_empty(&q->active)) {\r\nlist_add_tail(&buf->queue, &q->active);\r\ndprintk(2, "[%p/%d] buffer_queue - first active\n",\r\nbuf, buf->vb.v4l2_buf.index);\r\n} else {\r\nbuf->risc.cpu[0] |= cpu_to_le32(RISC_IRQ1);\r\nprev = list_entry(q->active.prev, struct cx23885_buffer,\r\nqueue);\r\nlist_add_tail(&buf->queue, &q->active);\r\nprev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\r\ndprintk(2, "[%p/%d] buffer_queue - append to active\n",\r\nbuf, buf->vb.v4l2_buf.index);\r\n}\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nstatic int cx23885_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct cx23885_dev *dev = q->drv_priv;\r\nstruct cx23885_dmaqueue *dmaq = &dev->vidq;\r\nstruct cx23885_buffer *buf = list_entry(dmaq->active.next,\r\nstruct cx23885_buffer, queue);\r\ncx23885_start_video_dma(dev, dmaq, buf);\r\nreturn 0;\r\n}\r\nstatic void cx23885_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct cx23885_dev *dev = q->drv_priv;\r\nstruct cx23885_dmaqueue *dmaq = &dev->vidq;\r\nunsigned long flags;\r\ncx_clear(VID_A_DMA_CTL, 0x11);\r\nspin_lock_irqsave(&dev->slock, flags);\r\nwhile (!list_empty(&dmaq->active)) {\r\nstruct cx23885_buffer *buf = list_entry(dmaq->active.next,\r\nstruct cx23885_buffer, queue);\r\nlist_del(&buf->queue);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nf->fmt.pix.width = dev->width;\r\nf->fmt.pix.height = dev->height;\r\nf->fmt.pix.field = dev->field;\r\nf->fmt.pix.pixelformat = dev->fmt->fourcc;\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * dev->fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nstruct cx23885_fmt *fmt;\r\nenum v4l2_field field;\r\nunsigned int maxw, maxh;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (NULL == fmt)\r\nreturn -EINVAL;\r\nfield = f->fmt.pix.field;\r\nmaxw = norm_maxw(dev->tvnorm);\r\nmaxh = norm_maxh(dev->tvnorm);\r\nif (V4L2_FIELD_ANY == field) {\r\nfield = (f->fmt.pix.height > maxh/2)\r\n? V4L2_FIELD_INTERLACED\r\n: V4L2_FIELD_BOTTOM;\r\n}\r\nswitch (field) {\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\nmaxh = maxh / 2;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\ncase V4L2_FIELD_SEQ_TB:\r\ncase V4L2_FIELD_SEQ_BT:\r\nbreak;\r\ndefault:\r\nfield = V4L2_FIELD_INTERLACED;\r\nbreak;\r\n}\r\nf->fmt.pix.field = field;\r\nv4l_bound_align_image(&f->fmt.pix.width, 48, maxw, 2,\r\n&f->fmt.pix.height, 32, maxh, 0, 0);\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nint err;\r\ndprintk(2, "%s()\n", __func__);\r\nerr = vidioc_try_fmt_vid_cap(file, priv, f);\r\nif (0 != err)\r\nreturn err;\r\nif (vb2_is_busy(&dev->vb2_vidq) || vb2_is_busy(&dev->vb2_vbiq) ||\r\nvb2_is_busy(&dev->vb2_mpegq))\r\nreturn -EBUSY;\r\ndev->fmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\ndev->width = f->fmt.pix.width;\r\ndev->height = f->fmt.pix.height;\r\ndev->field = f->fmt.pix.field;\r\ndprintk(2, "%s() width=%d height=%d field=%d\n", __func__,\r\ndev->width, dev->height, dev->field);\r\nv4l2_fill_mbus_format(&mbus_fmt, &f->fmt.pix, MEDIA_BUS_FMT_FIXED);\r\ncall_all(dev, video, s_mbus_fmt, &mbus_fmt);\r\nv4l2_fill_pix_format(&f->fmt.pix, &mbus_fmt);\r\nf->fmt.pix.field = dev->field;\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nstruct video_device *vdev = video_devdata(file);\r\nstrcpy(cap->driver, "cx23885");\r\nstrlcpy(cap->card, cx23885_boards[dev->board].name,\r\nsizeof(cap->card));\r\nsprintf(cap->bus_info, "PCIe:%s", pci_name(dev->pci));\r\ncap->device_caps = V4L2_CAP_READWRITE | V4L2_CAP_STREAMING | V4L2_CAP_AUDIO;\r\nif (dev->tuner_type != TUNER_ABSENT)\r\ncap->device_caps |= V4L2_CAP_TUNER;\r\nif (vdev->vfl_type == VFL_TYPE_VBI)\r\ncap->device_caps |= V4L2_CAP_VBI_CAPTURE;\r\nelse\r\ncap->device_caps |= V4L2_CAP_VIDEO_CAPTURE;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_VBI_CAPTURE |\r\nV4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (unlikely(f->index >= ARRAY_SIZE(formats)))\r\nreturn -EINVAL;\r\nstrlcpy(f->description, formats[f->index].name,\r\nsizeof(f->description));\r\nf->pixelformat = formats[f->index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *id)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\ndprintk(1, "%s()\n", __func__);\r\n*id = dev->tvnorm;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id tvnorms)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\ndprintk(1, "%s()\n", __func__);\r\nreturn cx23885_set_tvnorm(dev, tvnorms);\r\n}\r\nint cx23885_enum_input(struct cx23885_dev *dev, struct v4l2_input *i)\r\n{\r\nstatic const char *iname[] = {\r\n[CX23885_VMUX_COMPOSITE1] = "Composite1",\r\n[CX23885_VMUX_COMPOSITE2] = "Composite2",\r\n[CX23885_VMUX_COMPOSITE3] = "Composite3",\r\n[CX23885_VMUX_COMPOSITE4] = "Composite4",\r\n[CX23885_VMUX_SVIDEO] = "S-Video",\r\n[CX23885_VMUX_COMPONENT] = "Component",\r\n[CX23885_VMUX_TELEVISION] = "Television",\r\n[CX23885_VMUX_CABLE] = "Cable TV",\r\n[CX23885_VMUX_DVB] = "DVB",\r\n[CX23885_VMUX_DEBUG] = "for debug only",\r\n};\r\nunsigned int n;\r\ndprintk(1, "%s()\n", __func__);\r\nn = i->index;\r\nif (n >= MAX_CX23885_INPUT)\r\nreturn -EINVAL;\r\nif (0 == INPUT(n)->type)\r\nreturn -EINVAL;\r\ni->index = n;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrcpy(i->name, iname[INPUT(n)->type]);\r\ni->std = CX23885_NORMS;\r\nif ((CX23885_VMUX_TELEVISION == INPUT(n)->type) ||\r\n(CX23885_VMUX_CABLE == INPUT(n)->type)) {\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\ni->audioset = 4;\r\n} else {\r\ni->audioset = 3;\r\n}\r\nif (dev->input == n) {\r\ncall_all(dev, video, g_input_status, &i->status);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\ndprintk(1, "%s()\n", __func__);\r\nreturn cx23885_enum_input(dev, i);\r\n}\r\nint cx23885_get_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\n*i = dev->input;\r\ndprintk(1, "%s() returns %d\n", __func__, *i);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nreturn cx23885_get_input(file, priv, i);\r\n}\r\nint cx23885_set_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\ndprintk(1, "%s(%d)\n", __func__, i);\r\nif (i >= MAX_CX23885_INPUT) {\r\ndprintk(1, "%s() -EINVAL\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (INPUT(i)->type == 0)\r\nreturn -EINVAL;\r\ncx23885_video_mux(dev, i);\r\ncx23885_audio_mux(dev, i);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nreturn cx23885_set_input(file, priv, i);\r\n}\r\nstatic int vidioc_log_status(struct file *file, void *priv)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\ncall_all(dev, core, log_status);\r\nreturn 0;\r\n}\r\nstatic int cx23885_query_audinput(struct file *file, void *priv,\r\nstruct v4l2_audio *i)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nstatic const char *iname[] = {\r\n[0] = "Baseband L/R 1",\r\n[1] = "Baseband L/R 2",\r\n[2] = "TV",\r\n};\r\nunsigned int n;\r\ndprintk(1, "%s()\n", __func__);\r\nn = i->index;\r\nif (n >= 3)\r\nreturn -EINVAL;\r\nmemset(i, 0, sizeof(*i));\r\ni->index = n;\r\nstrcpy(i->name, iname[n]);\r\ni->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_audinput(struct file *file, void *priv,\r\nstruct v4l2_audio *i)\r\n{\r\nreturn cx23885_query_audinput(file, priv, i);\r\n}\r\nstatic int vidioc_g_audinput(struct file *file, void *priv,\r\nstruct v4l2_audio *i)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nif ((CX23885_VMUX_TELEVISION == INPUT(dev->input)->type) ||\r\n(CX23885_VMUX_CABLE == INPUT(dev->input)->type))\r\ni->index = 2;\r\nelse\r\ni->index = dev->audinput;\r\ndprintk(1, "%s(input=%d)\n", __func__, i->index);\r\nreturn cx23885_query_audinput(file, priv, i);\r\n}\r\nstatic int vidioc_s_audinput(struct file *file, void *priv,\r\nconst struct v4l2_audio *i)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nif ((CX23885_VMUX_TELEVISION == INPUT(dev->input)->type) ||\r\n(CX23885_VMUX_CABLE == INPUT(dev->input)->type)) {\r\nreturn i->index != 2 ? -EINVAL : 0;\r\n}\r\nif (i->index > 1)\r\nreturn -EINVAL;\r\ndprintk(1, "%s(%d)\n", __func__, i->index);\r\ndev->audinput = i->index;\r\ncx23885_flatiron_mux(dev, dev->audinput + 1);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nif (dev->tuner_type == TUNER_ABSENT)\r\nreturn -EINVAL;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Television");\r\ncall_all(dev, tuner, g_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *t)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nif (dev->tuner_type == TUNER_ABSENT)\r\nreturn -EINVAL;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\ncall_all(dev, tuner, s_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nif (dev->tuner_type == TUNER_ABSENT)\r\nreturn -EINVAL;\r\nf->type = V4L2_TUNER_ANALOG_TV;\r\nf->frequency = dev->freq;\r\ncall_all(dev, tuner, g_frequency, f);\r\nreturn 0;\r\n}\r\nstatic int cx23885_set_freq(struct cx23885_dev *dev, const struct v4l2_frequency *f)\r\n{\r\nstruct v4l2_ctrl *mute;\r\nint old_mute_val = 1;\r\nif (dev->tuner_type == TUNER_ABSENT)\r\nreturn -EINVAL;\r\nif (unlikely(f->tuner != 0))\r\nreturn -EINVAL;\r\ndev->freq = f->frequency;\r\nmute = v4l2_ctrl_find(&dev->ctrl_handler, V4L2_CID_AUDIO_MUTE);\r\nif (mute) {\r\nold_mute_val = v4l2_ctrl_g_ctrl(mute);\r\nif (!old_mute_val)\r\nv4l2_ctrl_s_ctrl(mute, 1);\r\n}\r\ncall_all(dev, tuner, s_frequency, f);\r\nmsleep(100);\r\nif (old_mute_val == 0)\r\nv4l2_ctrl_s_ctrl(mute, old_mute_val);\r\nreturn 0;\r\n}\r\nstatic int cx23885_set_freq_via_ops(struct cx23885_dev *dev,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct v4l2_ctrl *mute;\r\nint old_mute_val = 1;\r\nstruct vb2_dvb_frontend *vfe;\r\nstruct dvb_frontend *fe;\r\nstruct analog_parameters params = {\r\n.mode = V4L2_TUNER_ANALOG_TV,\r\n.audmode = V4L2_TUNER_MODE_STEREO,\r\n.std = dev->tvnorm,\r\n.frequency = f->frequency\r\n};\r\ndev->freq = f->frequency;\r\nmute = v4l2_ctrl_find(&dev->ctrl_handler, V4L2_CID_AUDIO_MUTE);\r\nif (mute) {\r\nold_mute_val = v4l2_ctrl_g_ctrl(mute);\r\nif (!old_mute_val)\r\nv4l2_ctrl_s_ctrl(mute, 1);\r\n}\r\ndprintk(1, "%s() frequency=%d tuner=%d std=0x%llx\n", __func__,\r\nparams.frequency, f->tuner, params.std);\r\nvfe = vb2_dvb_get_frontend(&dev->ts2.frontends, 1);\r\nif (!vfe) {\r\nreturn -EINVAL;\r\n}\r\nfe = vfe->dvb.frontend;\r\nif ((dev->board == CX23885_BOARD_HAUPPAUGE_HVR1850) ||\r\n(dev->board == CX23885_BOARD_HAUPPAUGE_HVR1255) ||\r\n(dev->board == CX23885_BOARD_HAUPPAUGE_HVR1255_22111))\r\nfe = &dev->ts1.analog_fe;\r\nif (fe && fe->ops.tuner_ops.set_analog_params) {\r\ncall_all(dev, video, s_std, dev->tvnorm);\r\nfe->ops.tuner_ops.set_analog_params(fe, &params);\r\n}\r\nelse\r\nprintk(KERN_ERR "%s() No analog tuner, aborting\n", __func__);\r\nmsleep(100);\r\nif (old_mute_val == 0)\r\nv4l2_ctrl_s_ctrl(mute, old_mute_val);\r\nreturn 0;\r\n}\r\nint cx23885_set_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct cx23885_dev *dev = video_drvdata(file);\r\nint ret;\r\nswitch (dev->board) {\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1255:\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1255_22111:\r\ncase CX23885_BOARD_HAUPPAUGE_HVR1850:\r\nret = cx23885_set_freq_via_ops(dev, f);\r\nbreak;\r\ndefault:\r\nret = cx23885_set_freq(dev, f);\r\n}\r\nreturn ret;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nreturn cx23885_set_frequency(file, priv, f);\r\n}\r\nint cx23885_video_irq(struct cx23885_dev *dev, u32 status)\r\n{\r\nu32 mask, count;\r\nint handled = 0;\r\nmask = cx_read(VID_A_INT_MSK);\r\nif (0 == (status & mask))\r\nreturn handled;\r\ncx_write(VID_A_INT_STAT, status);\r\nif ((status & VID_BC_MSK_OPC_ERR) ||\r\n(status & VID_BC_MSK_SYNC) ||\r\n(status & VID_BC_MSK_OF)) {\r\nif (status & VID_BC_MSK_OPC_ERR) {\r\ndprintk(7, " (VID_BC_MSK_OPC_ERR 0x%08x)\n",\r\nVID_BC_MSK_OPC_ERR);\r\nprintk(KERN_WARNING "%s: video risc op code error\n",\r\ndev->name);\r\ncx23885_sram_channel_dump(dev,\r\n&dev->sram_channels[SRAM_CH01]);\r\n}\r\nif (status & VID_BC_MSK_SYNC)\r\ndprintk(7, " (VID_BC_MSK_SYNC 0x%08x) "\r\n"video lines miss-match\n",\r\nVID_BC_MSK_SYNC);\r\nif (status & VID_BC_MSK_OF)\r\ndprintk(7, " (VID_BC_MSK_OF 0x%08x) fifo overflow\n",\r\nVID_BC_MSK_OF);\r\n}\r\nif (status & VID_BC_MSK_RISCI1) {\r\nspin_lock(&dev->slock);\r\ncount = cx_read(VID_A_GPCNT);\r\ncx23885_video_wakeup(dev, &dev->vidq, count);\r\nspin_unlock(&dev->slock);\r\nhandled++;\r\n}\r\nhandled += cx23885_vbi_irq(dev, status);\r\nreturn handled;\r\n}\r\nvoid cx23885_video_unregister(struct cx23885_dev *dev)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\ncx23885_irq_remove(dev, 0x01);\r\nif (dev->vbi_dev) {\r\nif (video_is_registered(dev->vbi_dev))\r\nvideo_unregister_device(dev->vbi_dev);\r\nelse\r\nvideo_device_release(dev->vbi_dev);\r\ndev->vbi_dev = NULL;\r\n}\r\nif (dev->video_dev) {\r\nif (video_is_registered(dev->video_dev))\r\nvideo_unregister_device(dev->video_dev);\r\nelse\r\nvideo_device_release(dev->video_dev);\r\ndev->video_dev = NULL;\r\n}\r\nif (dev->audio_dev)\r\ncx23885_audio_unregister(dev);\r\n}\r\nint cx23885_video_register(struct cx23885_dev *dev)\r\n{\r\nstruct vb2_queue *q;\r\nint err;\r\ndprintk(1, "%s()\n", __func__);\r\nspin_lock_init(&dev->slock);\r\ncx23885_vbi_template = cx23885_video_template;\r\nstrcpy(cx23885_vbi_template.name, "cx23885-vbi");\r\ndev->tvnorm = V4L2_STD_NTSC_M;\r\ndev->fmt = format_by_fourcc(V4L2_PIX_FMT_YUYV);\r\ndev->field = V4L2_FIELD_INTERLACED;\r\ndev->width = 720;\r\ndev->height = norm_maxh(dev->tvnorm);\r\nINIT_LIST_HEAD(&dev->vidq.active);\r\nINIT_LIST_HEAD(&dev->vbiq.active);\r\ncx23885_irq_add_enable(dev, 0x01);\r\nif ((TUNER_ABSENT != dev->tuner_type) &&\r\n((dev->tuner_bus == 0) || (dev->tuner_bus == 1))) {\r\nstruct v4l2_subdev *sd = NULL;\r\nif (dev->tuner_addr)\r\nsd = v4l2_i2c_new_subdev(&dev->v4l2_dev,\r\n&dev->i2c_bus[dev->tuner_bus].i2c_adap,\r\n"tuner", dev->tuner_addr, NULL);\r\nelse\r\nsd = v4l2_i2c_new_subdev(&dev->v4l2_dev,\r\n&dev->i2c_bus[dev->tuner_bus].i2c_adap,\r\n"tuner", 0, v4l2_i2c_tuner_addrs(ADDRS_TV));\r\nif (sd) {\r\nstruct tuner_setup tun_setup;\r\nmemset(&tun_setup, 0, sizeof(tun_setup));\r\ntun_setup.mode_mask = T_ANALOG_TV;\r\ntun_setup.type = dev->tuner_type;\r\ntun_setup.addr = v4l2_i2c_subdev_addr(sd);\r\ntun_setup.tuner_callback = cx23885_tuner_callback;\r\nv4l2_subdev_call(sd, tuner, s_type_addr, &tun_setup);\r\nif ((dev->board == CX23885_BOARD_LEADTEK_WINFAST_PXTV1200) ||\r\n(dev->board == CX23885_BOARD_LEADTEK_WINFAST_PXPVR2200)) {\r\nstruct xc2028_ctrl ctrl = {\r\n.fname = XC2028_DEFAULT_FIRMWARE,\r\n.max_len = 64\r\n};\r\nstruct v4l2_priv_tun_config cfg = {\r\n.tuner = dev->tuner_type,\r\n.priv = &ctrl\r\n};\r\nv4l2_subdev_call(sd, tuner, s_config, &cfg);\r\n}\r\nif (dev->board == CX23885_BOARD_AVERMEDIA_HC81R) {\r\nstruct xc2028_ctrl ctrl = {\r\n.fname = "xc3028L-v36.fw",\r\n.max_len = 64\r\n};\r\nstruct v4l2_priv_tun_config cfg = {\r\n.tuner = dev->tuner_type,\r\n.priv = &ctrl\r\n};\r\nv4l2_subdev_call(sd, tuner, s_config, &cfg);\r\n}\r\n}\r\n}\r\nmutex_lock(&dev->lock);\r\ncx23885_set_tvnorm(dev, dev->tvnorm);\r\ncx23885_video_mux(dev, 0);\r\ncx23885_audio_mux(dev, 0);\r\nmutex_unlock(&dev->lock);\r\nq = &dev->vb2_vidq;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\r\nq->gfp_flags = GFP_DMA32;\r\nq->min_buffers_needed = 2;\r\nq->drv_priv = dev;\r\nq->buf_struct_size = sizeof(struct cx23885_buffer);\r\nq->ops = &cx23885_video_qops;\r\nq->mem_ops = &vb2_dma_sg_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &dev->lock;\r\nerr = vb2_queue_init(q);\r\nif (err < 0)\r\ngoto fail_unreg;\r\nq = &dev->vb2_vbiq;\r\nq->type = V4L2_BUF_TYPE_VBI_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ;\r\nq->gfp_flags = GFP_DMA32;\r\nq->min_buffers_needed = 2;\r\nq->drv_priv = dev;\r\nq->buf_struct_size = sizeof(struct cx23885_buffer);\r\nq->ops = &cx23885_vbi_qops;\r\nq->mem_ops = &vb2_dma_sg_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &dev->lock;\r\nerr = vb2_queue_init(q);\r\nif (err < 0)\r\ngoto fail_unreg;\r\ndev->video_dev = cx23885_vdev_init(dev, dev->pci,\r\n&cx23885_video_template, "video");\r\ndev->video_dev->queue = &dev->vb2_vidq;\r\nerr = video_register_device(dev->video_dev, VFL_TYPE_GRABBER,\r\nvideo_nr[dev->nr]);\r\nif (err < 0) {\r\nprintk(KERN_INFO "%s: can't register video device\n",\r\ndev->name);\r\ngoto fail_unreg;\r\n}\r\nprintk(KERN_INFO "%s: registered device %s [v4l2]\n",\r\ndev->name, video_device_node_name(dev->video_dev));\r\ndev->vbi_dev = cx23885_vdev_init(dev, dev->pci,\r\n&cx23885_vbi_template, "vbi");\r\ndev->vbi_dev->queue = &dev->vb2_vbiq;\r\nerr = video_register_device(dev->vbi_dev, VFL_TYPE_VBI,\r\nvbi_nr[dev->nr]);\r\nif (err < 0) {\r\nprintk(KERN_INFO "%s: can't register vbi device\n",\r\ndev->name);\r\ngoto fail_unreg;\r\n}\r\nprintk(KERN_INFO "%s: registered device %s\n",\r\ndev->name, video_device_node_name(dev->vbi_dev));\r\ndev->audio_dev = cx23885_audio_register(dev);\r\nreturn 0;\r\nfail_unreg:\r\ncx23885_video_unregister(dev);\r\nreturn err;\r\n}
