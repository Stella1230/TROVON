void\r\nlnet_md_unlink(lnet_libmd_t *md)\r\n{\r\nif ((md->md_flags & LNET_MD_FLAG_ZOMBIE) == 0) {\r\nlnet_me_t *me = md->md_me;\r\nmd->md_flags |= LNET_MD_FLAG_ZOMBIE;\r\nif (me != NULL) {\r\nlnet_ptl_detach_md(me, md);\r\nif (me->me_unlink == LNET_UNLINK)\r\nlnet_me_unlink(me);\r\n}\r\nlnet_res_lh_invalidate(&md->md_lh);\r\n}\r\nif (md->md_refcount != 0) {\r\nCDEBUG(D_NET, "Queueing unlink of md %p\n", md);\r\nreturn;\r\n}\r\nCDEBUG(D_NET, "Unlinking md %p\n", md);\r\nif (md->md_eq != NULL) {\r\nint cpt = lnet_cpt_of_cookie(md->md_lh.lh_cookie);\r\nLASSERT(*md->md_eq->eq_refs[cpt] > 0);\r\n(*md->md_eq->eq_refs[cpt])--;\r\n}\r\nLASSERT(!list_empty(&md->md_list));\r\nlist_del_init(&md->md_list);\r\nlnet_md_free_locked(md);\r\n}\r\nstatic int\r\nlnet_md_build(lnet_libmd_t *lmd, lnet_md_t *umd, int unlink)\r\n{\r\nint i;\r\nunsigned int niov;\r\nint total_length = 0;\r\nlmd->md_me = NULL;\r\nlmd->md_start = umd->start;\r\nlmd->md_offset = 0;\r\nlmd->md_max_size = umd->max_size;\r\nlmd->md_options = umd->options;\r\nlmd->md_user_ptr = umd->user_ptr;\r\nlmd->md_eq = NULL;\r\nlmd->md_threshold = umd->threshold;\r\nlmd->md_refcount = 0;\r\nlmd->md_flags = (unlink == LNET_UNLINK) ? LNET_MD_FLAG_AUTO_UNLINK : 0;\r\nif ((umd->options & LNET_MD_IOVEC) != 0) {\r\nif ((umd->options & LNET_MD_KIOV) != 0)\r\nreturn -EINVAL;\r\nlmd->md_niov = niov = umd->length;\r\nmemcpy(lmd->md_iov.iov, umd->start,\r\nniov * sizeof(lmd->md_iov.iov[0]));\r\nfor (i = 0; i < (int)niov; i++) {\r\nif (lmd->md_iov.iov[i].iov_len <= 0)\r\nreturn -EINVAL;\r\ntotal_length += lmd->md_iov.iov[i].iov_len;\r\n}\r\nlmd->md_length = total_length;\r\nif ((umd->options & LNET_MD_MAX_SIZE) != 0 &&\r\n(umd->max_size < 0 ||\r\numd->max_size > total_length))\r\nreturn -EINVAL;\r\n} else if ((umd->options & LNET_MD_KIOV) != 0) {\r\nlmd->md_niov = niov = umd->length;\r\nmemcpy(lmd->md_iov.kiov, umd->start,\r\nniov * sizeof(lmd->md_iov.kiov[0]));\r\nfor (i = 0; i < (int)niov; i++) {\r\nif (lmd->md_iov.kiov[i].kiov_offset +\r\nlmd->md_iov.kiov[i].kiov_len > PAGE_CACHE_SIZE)\r\nreturn -EINVAL;\r\ntotal_length += lmd->md_iov.kiov[i].kiov_len;\r\n}\r\nlmd->md_length = total_length;\r\nif ((umd->options & LNET_MD_MAX_SIZE) != 0 &&\r\n(umd->max_size < 0 ||\r\numd->max_size > total_length))\r\nreturn -EINVAL;\r\n} else {\r\nlmd->md_length = umd->length;\r\nlmd->md_niov = niov = 1;\r\nlmd->md_iov.iov[0].iov_base = umd->start;\r\nlmd->md_iov.iov[0].iov_len = umd->length;\r\nif ((umd->options & LNET_MD_MAX_SIZE) != 0 &&\r\n(umd->max_size < 0 ||\r\numd->max_size > (int)umd->length))\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlnet_md_link(lnet_libmd_t *md, lnet_handle_eq_t eq_handle, int cpt)\r\n{\r\nstruct lnet_res_container *container = the_lnet.ln_md_containers[cpt];\r\nif (!LNetHandleIsInvalid(eq_handle)) {\r\nmd->md_eq = lnet_handle2eq(&eq_handle);\r\nif (md->md_eq == NULL)\r\nreturn -ENOENT;\r\n(*md->md_eq->eq_refs[cpt])++;\r\n}\r\nlnet_res_lh_initialize(container, &md->md_lh);\r\nLASSERT(list_empty(&md->md_list));\r\nlist_add(&md->md_list, &container->rec_active);\r\nreturn 0;\r\n}\r\nvoid\r\nlnet_md_deconstruct(lnet_libmd_t *lmd, lnet_md_t *umd)\r\n{\r\numd->start = lmd->md_start;\r\numd->length = ((lmd->md_options &\r\n(LNET_MD_IOVEC | LNET_MD_KIOV)) == 0) ?\r\nlmd->md_length : lmd->md_niov;\r\numd->threshold = lmd->md_threshold;\r\numd->max_size = lmd->md_max_size;\r\numd->options = lmd->md_options;\r\numd->user_ptr = lmd->md_user_ptr;\r\nlnet_eq2handle(&umd->eq_handle, lmd->md_eq);\r\n}\r\nstatic int\r\nlnet_md_validate(lnet_md_t *umd)\r\n{\r\nif (umd->start == NULL && umd->length != 0) {\r\nCERROR("MD start pointer can not be NULL with length %u\n",\r\numd->length);\r\nreturn -EINVAL;\r\n}\r\nif ((umd->options & (LNET_MD_KIOV | LNET_MD_IOVEC)) != 0 &&\r\numd->length > LNET_MAX_IOV) {\r\nCERROR("Invalid option: too many fragments %u, %d max\n",\r\numd->length, LNET_MAX_IOV);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nLNetMDAttach(lnet_handle_me_t meh, lnet_md_t umd,\r\nlnet_unlink_t unlink, lnet_handle_md_t *handle)\r\n{\r\nLIST_HEAD(matches);\r\nLIST_HEAD(drops);\r\nstruct lnet_me *me;\r\nstruct lnet_libmd *md;\r\nint cpt;\r\nint rc;\r\nLASSERT(the_lnet.ln_init);\r\nLASSERT(the_lnet.ln_refcount > 0);\r\nif (lnet_md_validate(&umd) != 0)\r\nreturn -EINVAL;\r\nif ((umd.options & (LNET_MD_OP_GET | LNET_MD_OP_PUT)) == 0) {\r\nCERROR("Invalid option: no MD_OP set\n");\r\nreturn -EINVAL;\r\n}\r\nmd = lnet_md_alloc(&umd);\r\nif (md == NULL)\r\nreturn -ENOMEM;\r\nrc = lnet_md_build(md, &umd, unlink);\r\ncpt = lnet_cpt_of_cookie(meh.cookie);\r\nlnet_res_lock(cpt);\r\nif (rc != 0)\r\ngoto failed;\r\nme = lnet_handle2me(&meh);\r\nif (me == NULL)\r\nrc = -ENOENT;\r\nelse if (me->me_md != NULL)\r\nrc = -EBUSY;\r\nelse\r\nrc = lnet_md_link(md, umd.eq_handle, cpt);\r\nif (rc != 0)\r\ngoto failed;\r\nlnet_ptl_attach_md(me, md, &matches, &drops);\r\nlnet_md2handle(handle, md);\r\nlnet_res_unlock(cpt);\r\nlnet_drop_delayed_msg_list(&drops, "Bad match");\r\nlnet_recv_delayed_msg_list(&matches);\r\nreturn 0;\r\nfailed:\r\nlnet_md_free_locked(md);\r\nlnet_res_unlock(cpt);\r\nreturn rc;\r\n}\r\nint\r\nLNetMDBind(lnet_md_t umd, lnet_unlink_t unlink, lnet_handle_md_t *handle)\r\n{\r\nlnet_libmd_t *md;\r\nint cpt;\r\nint rc;\r\nLASSERT(the_lnet.ln_init);\r\nLASSERT(the_lnet.ln_refcount > 0);\r\nif (lnet_md_validate(&umd) != 0)\r\nreturn -EINVAL;\r\nif ((umd.options & (LNET_MD_OP_GET | LNET_MD_OP_PUT)) != 0) {\r\nCERROR("Invalid option: GET|PUT illegal on active MDs\n");\r\nreturn -EINVAL;\r\n}\r\nmd = lnet_md_alloc(&umd);\r\nif (md == NULL)\r\nreturn -ENOMEM;\r\nrc = lnet_md_build(md, &umd, unlink);\r\ncpt = lnet_res_lock_current();\r\nif (rc != 0)\r\ngoto failed;\r\nrc = lnet_md_link(md, umd.eq_handle, cpt);\r\nif (rc != 0)\r\ngoto failed;\r\nlnet_md2handle(handle, md);\r\nlnet_res_unlock(cpt);\r\nreturn 0;\r\nfailed:\r\nlnet_md_free_locked(md);\r\nlnet_res_unlock(cpt);\r\nreturn rc;\r\n}\r\nint\r\nLNetMDUnlink(lnet_handle_md_t mdh)\r\n{\r\nlnet_event_t ev;\r\nlnet_libmd_t *md;\r\nint cpt;\r\nLASSERT(the_lnet.ln_init);\r\nLASSERT(the_lnet.ln_refcount > 0);\r\ncpt = lnet_cpt_of_cookie(mdh.cookie);\r\nlnet_res_lock(cpt);\r\nmd = lnet_handle2md(&mdh);\r\nif (md == NULL) {\r\nlnet_res_unlock(cpt);\r\nreturn -ENOENT;\r\n}\r\nmd->md_flags |= LNET_MD_FLAG_ABORTED;\r\nif (md->md_eq != NULL && md->md_refcount == 0) {\r\nlnet_build_unlink_event(md, &ev);\r\nlnet_eq_enqueue_event(md->md_eq, &ev);\r\n}\r\nlnet_md_unlink(md);\r\nlnet_res_unlock(cpt);\r\nreturn 0;\r\n}
