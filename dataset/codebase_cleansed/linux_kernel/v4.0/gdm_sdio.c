static struct sdio_tx *alloc_tx_struct(struct tx_cxt *tx)\r\n{\r\nstruct sdio_tx *t = kzalloc(sizeof(*t), GFP_ATOMIC);\r\nif (!t)\r\nreturn NULL;\r\nt->buf = kmalloc(TX_BUF_SIZE, GFP_ATOMIC);\r\nif (!t->buf) {\r\nkfree(t);\r\nreturn NULL;\r\n}\r\nt->tx_cxt = tx;\r\nreturn t;\r\n}\r\nstatic void free_tx_struct(struct sdio_tx *t)\r\n{\r\nif (t) {\r\nkfree(t->buf);\r\nkfree(t);\r\n}\r\n}\r\nstatic struct sdio_rx *alloc_rx_struct(struct rx_cxt *rx)\r\n{\r\nstruct sdio_rx *r = kzalloc(sizeof(*r), GFP_ATOMIC);\r\nif (r)\r\nr->rx_cxt = rx;\r\nreturn r;\r\n}\r\nstatic void free_rx_struct(struct sdio_rx *r)\r\n{\r\nkfree(r);\r\n}\r\nstatic struct sdio_tx *get_tx_struct(struct tx_cxt *tx, int *no_spc)\r\n{\r\nstruct sdio_tx *t;\r\nif (list_empty(&tx->free_list))\r\nreturn NULL;\r\nt = list_entry(tx->free_list.prev, struct sdio_tx, list);\r\nlist_del(&t->list);\r\n*no_spc = list_empty(&tx->free_list) ? 1 : 0;\r\nreturn t;\r\n}\r\nstatic void put_tx_struct(struct tx_cxt *tx, struct sdio_tx *t)\r\n{\r\nlist_add_tail(&t->list, &tx->free_list);\r\n}\r\nstatic struct sdio_rx *get_rx_struct(struct rx_cxt *rx)\r\n{\r\nstruct sdio_rx *r;\r\nif (list_empty(&rx->free_list))\r\nreturn NULL;\r\nr = list_entry(rx->free_list.prev, struct sdio_rx, list);\r\nlist_del(&r->list);\r\nreturn r;\r\n}\r\nstatic void put_rx_struct(struct rx_cxt *rx, struct sdio_rx *r)\r\n{\r\nlist_add_tail(&r->list, &rx->free_list);\r\n}\r\nstatic void release_sdio(struct sdiowm_dev *sdev)\r\n{\r\nstruct tx_cxt *tx = &sdev->tx;\r\nstruct rx_cxt *rx = &sdev->rx;\r\nstruct sdio_tx *t, *t_next;\r\nstruct sdio_rx *r, *r_next;\r\nkfree(tx->sdu_buf);\r\nlist_for_each_entry_safe(t, t_next, &tx->free_list, list) {\r\nlist_del(&t->list);\r\nfree_tx_struct(t);\r\n}\r\nlist_for_each_entry_safe(t, t_next, &tx->sdu_list, list) {\r\nlist_del(&t->list);\r\nfree_tx_struct(t);\r\n}\r\nlist_for_each_entry_safe(t, t_next, &tx->hci_list, list) {\r\nlist_del(&t->list);\r\nfree_tx_struct(t);\r\n}\r\nkfree(rx->rx_buf);\r\nlist_for_each_entry_safe(r, r_next, &rx->free_list, list) {\r\nlist_del(&r->list);\r\nfree_rx_struct(r);\r\n}\r\nlist_for_each_entry_safe(r, r_next, &rx->req_list, list) {\r\nlist_del(&r->list);\r\nfree_rx_struct(r);\r\n}\r\n}\r\nstatic int init_sdio(struct sdiowm_dev *sdev)\r\n{\r\nint ret = 0, i;\r\nstruct tx_cxt *tx = &sdev->tx;\r\nstruct rx_cxt *rx = &sdev->rx;\r\nstruct sdio_tx *t;\r\nstruct sdio_rx *r;\r\nINIT_LIST_HEAD(&tx->free_list);\r\nINIT_LIST_HEAD(&tx->sdu_list);\r\nINIT_LIST_HEAD(&tx->hci_list);\r\nspin_lock_init(&tx->lock);\r\ntx->sdu_buf = kmalloc(SDU_TX_BUF_SIZE, GFP_KERNEL);\r\nif (tx->sdu_buf == NULL)\r\ngoto fail;\r\nfor (i = 0; i < MAX_NR_SDU_BUF; i++) {\r\nt = alloc_tx_struct(tx);\r\nif (t == NULL) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nlist_add(&t->list, &tx->free_list);\r\n}\r\nINIT_LIST_HEAD(&rx->free_list);\r\nINIT_LIST_HEAD(&rx->req_list);\r\nspin_lock_init(&rx->lock);\r\nfor (i = 0; i < MAX_NR_RX_BUF; i++) {\r\nr = alloc_rx_struct(rx);\r\nif (r == NULL) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nlist_add(&r->list, &rx->free_list);\r\n}\r\nrx->rx_buf = kmalloc(RX_BUF_SIZE, GFP_KERNEL);\r\nif (rx->rx_buf == NULL)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nrelease_sdio(sdev);\r\nreturn ret;\r\n}\r\nstatic void send_sdio_pkt(struct sdio_func *func, u8 *data, int len)\r\n{\r\nint n, blocks, ret, remain;\r\nsdio_claim_host(func);\r\nblocks = len / func->cur_blksize;\r\nn = blocks * func->cur_blksize;\r\nif (blocks) {\r\nret = sdio_memcpy_toio(func, 0, data, n);\r\nif (ret < 0) {\r\nif (ret != -ENOMEDIUM)\r\ndev_err(&func->dev,\r\n"gdmwms: %s error: ret = %d\n",\r\n__func__, ret);\r\ngoto end_io;\r\n}\r\n}\r\nremain = len - n;\r\nremain = (remain + 3) & ~3;\r\nif (remain) {\r\nret = sdio_memcpy_toio(func, 0, data + n, remain);\r\nif (ret < 0) {\r\nif (ret != -ENOMEDIUM)\r\ndev_err(&func->dev,\r\n"gdmwms: %s error: ret = %d\n",\r\n__func__, ret);\r\ngoto end_io;\r\n}\r\n}\r\nend_io:\r\nsdio_release_host(func);\r\n}\r\nstatic void send_sdu(struct sdio_func *func, struct tx_cxt *tx)\r\n{\r\nstruct list_head *l, *next;\r\nstruct hci_s *hci;\r\nstruct sdio_tx *t;\r\nint pos, len, i, estlen, aggr_num = 0, aggr_len;\r\nu8 *buf;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tx->lock, flags);\r\npos = TYPE_A_HEADER_SIZE + HCI_HEADER_SIZE;\r\nlist_for_each_entry(t, &tx->sdu_list, list) {\r\nestlen = ((t->len + 3) & ~3) + 4;\r\nif ((pos + estlen) > SDU_TX_BUF_SIZE)\r\nbreak;\r\naggr_num++;\r\nmemcpy(tx->sdu_buf + pos, t->buf, t->len);\r\nmemset(tx->sdu_buf + pos + t->len, 0, estlen - t->len);\r\npos += estlen;\r\n}\r\naggr_len = pos;\r\nhci = (struct hci_s *)(tx->sdu_buf + TYPE_A_HEADER_SIZE);\r\nhci->cmd_evt = cpu_to_be16(WIMAX_TX_SDU_AGGR);\r\nhci->length = cpu_to_be16(aggr_len - TYPE_A_HEADER_SIZE -\r\nHCI_HEADER_SIZE);\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\ndev_dbg(&func->dev, "sdio_send: %*ph\n", aggr_len - TYPE_A_HEADER_SIZE,\r\ntx->sdu_buf + TYPE_A_HEADER_SIZE);\r\nfor (pos = TYPE_A_HEADER_SIZE; pos < aggr_len; pos += TX_CHUNK_SIZE) {\r\nlen = aggr_len - pos;\r\nlen = len > TX_CHUNK_SIZE ? TX_CHUNK_SIZE : len;\r\nbuf = tx->sdu_buf + pos - TYPE_A_HEADER_SIZE;\r\nbuf[0] = len & 0xff;\r\nbuf[1] = (len >> 8) & 0xff;\r\nbuf[2] = (len >> 16) & 0xff;\r\nbuf[3] = (pos + len) >= aggr_len ? 0 : 1;\r\nsend_sdio_pkt(func, buf, len + TYPE_A_HEADER_SIZE);\r\n}\r\nspin_lock_irqsave(&tx->lock, flags);\r\nfor (l = tx->sdu_list.next, i = 0; i < aggr_num; i++, l = next) {\r\nnext = l->next;\r\nt = list_entry(l, struct sdio_tx, list);\r\nif (t->callback)\r\nt->callback(t->cb_data);\r\nlist_del(l);\r\nput_tx_struct(t->tx_cxt, t);\r\n}\r\ndo_gettimeofday(&tx->sdu_stamp);\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\n}\r\nstatic void send_hci(struct sdio_func *func, struct tx_cxt *tx,\r\nstruct sdio_tx *t)\r\n{\r\nunsigned long flags;\r\ndev_dbg(&func->dev, "sdio_send: %*ph\n", t->len - TYPE_A_HEADER_SIZE,\r\nt->buf + TYPE_A_HEADER_SIZE);\r\nsend_sdio_pkt(func, t->buf, t->len);\r\nspin_lock_irqsave(&tx->lock, flags);\r\nif (t->callback)\r\nt->callback(t->cb_data);\r\nfree_tx_struct(t);\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\n}\r\nstatic void do_tx(struct work_struct *work)\r\n{\r\nstruct sdiowm_dev *sdev = container_of(work, struct sdiowm_dev, ws);\r\nstruct sdio_func *func = sdev->func;\r\nstruct tx_cxt *tx = &sdev->tx;\r\nstruct sdio_tx *t = NULL;\r\nstruct timeval now, *before;\r\nint is_sdu = 0;\r\nlong diff;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tx->lock, flags);\r\nif (!tx->can_send) {\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nreturn;\r\n}\r\nif (!list_empty(&tx->hci_list)) {\r\nt = list_entry(tx->hci_list.next, struct sdio_tx, list);\r\nlist_del(&t->list);\r\nis_sdu = 0;\r\n} else if (!tx->stop_sdu_tx && !list_empty(&tx->sdu_list)) {\r\ndo_gettimeofday(&now);\r\nbefore = &tx->sdu_stamp;\r\ndiff = (now.tv_sec - before->tv_sec) * 1000000 +\r\n(now.tv_usec - before->tv_usec);\r\nif (diff >= 0 && diff < TX_INTERVAL) {\r\nschedule_work(&sdev->ws);\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nreturn;\r\n}\r\nis_sdu = 1;\r\n}\r\nif (!is_sdu && t == NULL) {\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nreturn;\r\n}\r\ntx->can_send = 0;\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nif (is_sdu)\r\nsend_sdu(func, tx);\r\nelse\r\nsend_hci(func, tx, t);\r\n}\r\nstatic int gdm_sdio_send(void *priv_dev, void *data, int len,\r\nvoid (*cb)(void *data), void *cb_data)\r\n{\r\nstruct sdiowm_dev *sdev = priv_dev;\r\nstruct tx_cxt *tx = &sdev->tx;\r\nstruct sdio_tx *t;\r\nu8 *pkt = data;\r\nint no_spc = 0;\r\nu16 cmd_evt;\r\nunsigned long flags;\r\nif (len > TX_BUF_SIZE - TYPE_A_HEADER_SIZE)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&tx->lock, flags);\r\ncmd_evt = (pkt[0] << 8) | pkt[1];\r\nif (cmd_evt == WIMAX_TX_SDU) {\r\nt = get_tx_struct(tx, &no_spc);\r\nif (t == NULL) {\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nreturn -ENOSPC;\r\n}\r\nlist_add_tail(&t->list, &tx->sdu_list);\r\nmemcpy(t->buf, data, len);\r\nt->len = len;\r\nt->callback = cb;\r\nt->cb_data = cb_data;\r\n} else {\r\nt = alloc_tx_struct(tx);\r\nif (t == NULL) {\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nreturn -ENOMEM;\r\n}\r\nlist_add_tail(&t->list, &tx->hci_list);\r\nt->buf[0] = len & 0xff;\r\nt->buf[1] = (len >> 8) & 0xff;\r\nt->buf[2] = (len >> 16) & 0xff;\r\nt->buf[3] = 2;\r\nmemcpy(t->buf + TYPE_A_HEADER_SIZE, data, len);\r\nt->len = len + TYPE_A_HEADER_SIZE;\r\nt->callback = cb;\r\nt->cb_data = cb_data;\r\n}\r\nif (tx->can_send)\r\nschedule_work(&sdev->ws);\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nif (no_spc)\r\nreturn -ENOSPC;\r\nreturn 0;\r\n}\r\nstatic int control_sdu_tx_flow(struct sdiowm_dev *sdev, u8 *hci_data, int len)\r\n{\r\nstruct tx_cxt *tx = &sdev->tx;\r\nu16 cmd_evt;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tx->lock, flags);\r\ncmd_evt = (hci_data[0] << 8) | (hci_data[1]);\r\nif (cmd_evt != WIMAX_SDU_TX_FLOW)\r\ngoto out;\r\nif (hci_data[4] == 0) {\r\ndev_dbg(&sdev->func->dev, "WIMAX ==> STOP SDU TX\n");\r\ntx->stop_sdu_tx = 1;\r\n} else if (hci_data[4] == 1) {\r\ndev_dbg(&sdev->func->dev, "WIMAX ==> START SDU TX\n");\r\ntx->stop_sdu_tx = 0;\r\nif (tx->can_send)\r\nschedule_work(&sdev->ws);\r\nif (list_empty(&tx->free_list))\r\nlen = 0;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\nreturn len;\r\n}\r\nstatic void gdm_sdio_irq(struct sdio_func *func)\r\n{\r\nstruct phy_dev *phy_dev = sdio_get_drvdata(func);\r\nstruct sdiowm_dev *sdev = phy_dev->priv_dev;\r\nstruct tx_cxt *tx = &sdev->tx;\r\nstruct rx_cxt *rx = &sdev->rx;\r\nstruct sdio_rx *r;\r\nunsigned long flags;\r\nu8 val, hdr[TYPE_A_LOOKAHEAD_SIZE], *buf;\r\nu32 len, blocks, n;\r\nint ret, remain;\r\nval = sdio_readb(func, 0x13, &ret);\r\nif (val & 0x01)\r\nsdio_writeb(func, 0x01, 0x13, &ret);\r\nelse\r\nreturn;\r\nret = sdio_memcpy_fromio(func, hdr, 0x0, TYPE_A_LOOKAHEAD_SIZE);\r\nif (ret) {\r\ndev_err(&func->dev,\r\n"Cannot read from function %d\n", func->num);\r\ngoto done;\r\n}\r\nlen = (hdr[2] << 16) | (hdr[1] << 8) | hdr[0];\r\nif (len > (RX_BUF_SIZE - TYPE_A_HEADER_SIZE)) {\r\ndev_err(&func->dev, "Too big Type-A size: %d\n", len);\r\ngoto done;\r\n}\r\nif (hdr[3] == 1) {\r\nu32 *ack_seq = (u32 *)&hdr[4];\r\nspin_lock_irqsave(&tx->lock, flags);\r\ntx->can_send = 1;\r\nif (!list_empty(&tx->sdu_list) || !list_empty(&tx->hci_list))\r\nschedule_work(&sdev->ws);\r\nspin_unlock_irqrestore(&tx->lock, flags);\r\ndev_dbg(&func->dev, "Ack... %0x\n", ntohl(*ack_seq));\r\ngoto done;\r\n}\r\nmemcpy(rx->rx_buf, hdr + TYPE_A_HEADER_SIZE,\r\nTYPE_A_LOOKAHEAD_SIZE - TYPE_A_HEADER_SIZE);\r\nbuf = rx->rx_buf + TYPE_A_LOOKAHEAD_SIZE - TYPE_A_HEADER_SIZE;\r\nremain = len - TYPE_A_LOOKAHEAD_SIZE + TYPE_A_HEADER_SIZE;\r\nif (remain <= 0)\r\ngoto end_io;\r\nblocks = remain / func->cur_blksize;\r\nif (blocks) {\r\nn = blocks * func->cur_blksize;\r\nret = sdio_memcpy_fromio(func, buf, 0x0, n);\r\nif (ret) {\r\ndev_err(&func->dev,\r\n"Cannot read from function %d\n", func->num);\r\ngoto done;\r\n}\r\nbuf += n;\r\nremain -= n;\r\n}\r\nif (remain) {\r\nret = sdio_memcpy_fromio(func, buf, 0x0, remain);\r\nif (ret) {\r\ndev_err(&func->dev,\r\n"Cannot read from function %d\n", func->num);\r\ngoto done;\r\n}\r\n}\r\nend_io:\r\ndev_dbg(&func->dev, "sdio_receive: %*ph\n", len, rx->rx_buf);\r\nlen = control_sdu_tx_flow(sdev, rx->rx_buf, len);\r\nspin_lock_irqsave(&rx->lock, flags);\r\nif (!list_empty(&rx->req_list)) {\r\nr = list_entry(rx->req_list.next, struct sdio_rx, list);\r\nspin_unlock_irqrestore(&rx->lock, flags);\r\nif (r->callback)\r\nr->callback(r->cb_data, rx->rx_buf, len);\r\nspin_lock_irqsave(&rx->lock, flags);\r\nlist_del(&r->list);\r\nput_rx_struct(rx, r);\r\n}\r\nspin_unlock_irqrestore(&rx->lock, flags);\r\ndone:\r\nsdio_writeb(func, 0x00, 0x10, &ret);\r\nif (!phy_dev->netdev)\r\nregister_wimax_device(phy_dev, &func->dev);\r\n}\r\nstatic int gdm_sdio_receive(void *priv_dev,\r\nvoid (*cb)(void *cb_data, void *data, int len),\r\nvoid *cb_data)\r\n{\r\nstruct sdiowm_dev *sdev = priv_dev;\r\nstruct rx_cxt *rx = &sdev->rx;\r\nstruct sdio_rx *r;\r\nunsigned long flags;\r\nspin_lock_irqsave(&rx->lock, flags);\r\nr = get_rx_struct(rx);\r\nif (r == NULL) {\r\nspin_unlock_irqrestore(&rx->lock, flags);\r\nreturn -ENOMEM;\r\n}\r\nr->callback = cb;\r\nr->cb_data = cb_data;\r\nlist_add_tail(&r->list, &rx->req_list);\r\nspin_unlock_irqrestore(&rx->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sdio_wimax_probe(struct sdio_func *func,\r\nconst struct sdio_device_id *id)\r\n{\r\nint ret;\r\nstruct phy_dev *phy_dev = NULL;\r\nstruct sdiowm_dev *sdev = NULL;\r\ndev_info(&func->dev, "Found GDM SDIO VID = 0x%04x PID = 0x%04x...\n",\r\nfunc->vendor, func->device);\r\ndev_info(&func->dev, "GCT WiMax driver version %s\n", DRIVER_VERSION);\r\nsdio_claim_host(func);\r\nsdio_enable_func(func);\r\nsdio_claim_irq(func, gdm_sdio_irq);\r\nret = sdio_boot(func);\r\nif (ret)\r\nreturn ret;\r\nphy_dev = kzalloc(sizeof(*phy_dev), GFP_KERNEL);\r\nif (phy_dev == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nsdev = kzalloc(sizeof(*sdev), GFP_KERNEL);\r\nif (sdev == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nphy_dev->priv_dev = (void *)sdev;\r\nphy_dev->send_func = gdm_sdio_send;\r\nphy_dev->rcv_func = gdm_sdio_receive;\r\nret = init_sdio(sdev);\r\nif (ret < 0)\r\ngoto out;\r\nsdev->func = func;\r\nsdio_writeb(func, 1, 0x14, &ret);\r\nsdio_release_host(func);\r\nINIT_WORK(&sdev->ws, do_tx);\r\nsdio_set_drvdata(func, phy_dev);\r\nout:\r\nif (ret) {\r\nkfree(phy_dev);\r\nkfree(sdev);\r\n}\r\nreturn ret;\r\n}\r\nstatic void sdio_wimax_remove(struct sdio_func *func)\r\n{\r\nstruct phy_dev *phy_dev = sdio_get_drvdata(func);\r\nstruct sdiowm_dev *sdev = phy_dev->priv_dev;\r\ncancel_work_sync(&sdev->ws);\r\nif (phy_dev->netdev)\r\nunregister_wimax_device(phy_dev);\r\nsdio_claim_host(func);\r\nsdio_release_irq(func);\r\nsdio_disable_func(func);\r\nsdio_release_host(func);\r\nrelease_sdio(sdev);\r\nkfree(sdev);\r\nkfree(phy_dev);\r\n}\r\nstatic int __init sdio_gdm_wimax_init(void)\r\n{\r\nreturn sdio_register_driver(&sdio_wimax_driver);\r\n}\r\nstatic void __exit sdio_gdm_wimax_exit(void)\r\n{\r\nsdio_unregister_driver(&sdio_wimax_driver);\r\n}
