static inline\r\nu32 pcicore_read32(struct ssb_pcicore *pc, u16 offset)\r\n{\r\nreturn ssb_read32(pc->dev, offset);\r\n}\r\nstatic inline\r\nvoid pcicore_write32(struct ssb_pcicore *pc, u16 offset, u32 value)\r\n{\r\nssb_write32(pc->dev, offset, value);\r\n}\r\nstatic inline\r\nu16 pcicore_read16(struct ssb_pcicore *pc, u16 offset)\r\n{\r\nreturn ssb_read16(pc->dev, offset);\r\n}\r\nstatic inline\r\nvoid pcicore_write16(struct ssb_pcicore *pc, u16 offset, u16 value)\r\n{\r\nssb_write16(pc->dev, offset, value);\r\n}\r\nstatic u32 get_cfgspace_addr(struct ssb_pcicore *pc,\r\nunsigned int bus, unsigned int dev,\r\nunsigned int func, unsigned int off)\r\n{\r\nu32 addr = 0;\r\nu32 tmp;\r\nif (pc->cardbusmode && (dev > 1))\r\ngoto out;\r\nif (bus == 0) {\r\nif (unlikely(dev >= SSB_PCI_SLOT_MAX))\r\ngoto out;\r\ntmp = SSB_PCICORE_SBTOPCI_CFG0;\r\ntmp |= ((1 << (dev + 16)) & SSB_PCICORE_SBTOPCI1_MASK);\r\npcicore_write32(pc, SSB_PCICORE_SBTOPCI1, tmp);\r\naddr = SSB_PCI_CFG;\r\naddr |= ((1 << (dev + 16)) & ~SSB_PCICORE_SBTOPCI1_MASK);\r\naddr |= (func << 8);\r\naddr |= (off & ~3);\r\n} else {\r\npcicore_write32(pc, SSB_PCICORE_SBTOPCI1,\r\nSSB_PCICORE_SBTOPCI_CFG1);\r\naddr = SSB_PCI_CFG;\r\naddr |= (bus << 16);\r\naddr |= (dev << 11);\r\naddr |= (func << 8);\r\naddr |= (off & ~3);\r\n}\r\nout:\r\nreturn addr;\r\n}\r\nstatic int ssb_extpci_read_config(struct ssb_pcicore *pc,\r\nunsigned int bus, unsigned int dev,\r\nunsigned int func, unsigned int off,\r\nvoid *buf, int len)\r\n{\r\nint err = -EINVAL;\r\nu32 addr, val;\r\nvoid __iomem *mmio;\r\nSSB_WARN_ON(!pc->hostmode);\r\nif (unlikely(len != 1 && len != 2 && len != 4))\r\ngoto out;\r\naddr = get_cfgspace_addr(pc, bus, dev, func, off);\r\nif (unlikely(!addr))\r\ngoto out;\r\nerr = -ENOMEM;\r\nmmio = ioremap_nocache(addr, len);\r\nif (!mmio)\r\ngoto out;\r\nif (mips_busprobe32(val, mmio)) {\r\nval = 0xffffffff;\r\ngoto unmap;\r\n}\r\nval = readl(mmio);\r\nval >>= (8 * (off & 3));\r\nswitch (len) {\r\ncase 1:\r\n*((u8 *)buf) = (u8)val;\r\nbreak;\r\ncase 2:\r\n*((u16 *)buf) = (u16)val;\r\nbreak;\r\ncase 4:\r\n*((u32 *)buf) = (u32)val;\r\nbreak;\r\n}\r\nerr = 0;\r\nunmap:\r\niounmap(mmio);\r\nout:\r\nreturn err;\r\n}\r\nstatic int ssb_extpci_write_config(struct ssb_pcicore *pc,\r\nunsigned int bus, unsigned int dev,\r\nunsigned int func, unsigned int off,\r\nconst void *buf, int len)\r\n{\r\nint err = -EINVAL;\r\nu32 addr, val = 0;\r\nvoid __iomem *mmio;\r\nSSB_WARN_ON(!pc->hostmode);\r\nif (unlikely(len != 1 && len != 2 && len != 4))\r\ngoto out;\r\naddr = get_cfgspace_addr(pc, bus, dev, func, off);\r\nif (unlikely(!addr))\r\ngoto out;\r\nerr = -ENOMEM;\r\nmmio = ioremap_nocache(addr, len);\r\nif (!mmio)\r\ngoto out;\r\nif (mips_busprobe32(val, mmio)) {\r\nval = 0xffffffff;\r\ngoto unmap;\r\n}\r\nswitch (len) {\r\ncase 1:\r\nval = readl(mmio);\r\nval &= ~(0xFF << (8 * (off & 3)));\r\nval |= *((const u8 *)buf) << (8 * (off & 3));\r\nbreak;\r\ncase 2:\r\nval = readl(mmio);\r\nval &= ~(0xFFFF << (8 * (off & 3)));\r\nval |= *((const u16 *)buf) << (8 * (off & 3));\r\nbreak;\r\ncase 4:\r\nval = *((const u32 *)buf);\r\nbreak;\r\n}\r\nwritel(val, mmio);\r\nerr = 0;\r\nunmap:\r\niounmap(mmio);\r\nout:\r\nreturn err;\r\n}\r\nstatic int ssb_pcicore_read_config(struct pci_bus *bus, unsigned int devfn,\r\nint reg, int size, u32 *val)\r\n{\r\nunsigned long flags;\r\nint err;\r\nspin_lock_irqsave(&cfgspace_lock, flags);\r\nerr = ssb_extpci_read_config(extpci_core, bus->number, PCI_SLOT(devfn),\r\nPCI_FUNC(devfn), reg, val, size);\r\nspin_unlock_irqrestore(&cfgspace_lock, flags);\r\nreturn err ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int ssb_pcicore_write_config(struct pci_bus *bus, unsigned int devfn,\r\nint reg, int size, u32 val)\r\n{\r\nunsigned long flags;\r\nint err;\r\nspin_lock_irqsave(&cfgspace_lock, flags);\r\nerr = ssb_extpci_write_config(extpci_core, bus->number, PCI_SLOT(devfn),\r\nPCI_FUNC(devfn), reg, &val, size);\r\nspin_unlock_irqrestore(&cfgspace_lock, flags);\r\nreturn err ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;\r\n}\r\nint ssb_pcicore_plat_dev_init(struct pci_dev *d)\r\n{\r\nif (d->bus->ops != &ssb_pcicore_pciops) {\r\nreturn -ENODEV;\r\n}\r\nssb_info("PCI: Fixing up device %s\n", pci_name(d));\r\nd->irq = ssb_mips_irq(extpci_core->dev) + 2;\r\npci_write_config_byte(d, PCI_INTERRUPT_LINE, d->irq);\r\nreturn 0;\r\n}\r\nstatic void ssb_pcicore_fixup_pcibridge(struct pci_dev *dev)\r\n{\r\nu8 lat;\r\nif (dev->bus->ops != &ssb_pcicore_pciops) {\r\nreturn;\r\n}\r\nif (dev->bus->number != 0 || PCI_SLOT(dev->devfn) != 0)\r\nreturn;\r\nssb_info("PCI: Fixing up bridge %s\n", pci_name(dev));\r\npci_set_master(dev);\r\nif (pcibios_enable_device(dev, ~0) < 0) {\r\nssb_err("PCI: SSB bridge enable failed\n");\r\nreturn;\r\n}\r\npci_write_config_dword(dev, SSB_BAR1_CONTROL, 3);\r\nlat = 168;\r\nssb_info("PCI: Fixing latency timer of device %s to %u\n",\r\npci_name(dev), lat);\r\npci_write_config_byte(dev, PCI_LATENCY_TIMER, lat);\r\n}\r\nint ssb_pcicore_pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nif (dev->bus->ops != &ssb_pcicore_pciops) {\r\nreturn -ENODEV;\r\n}\r\nreturn ssb_mips_irq(extpci_core->dev) + 2;\r\n}\r\nstatic void ssb_pcicore_init_hostmode(struct ssb_pcicore *pc)\r\n{\r\nu32 val;\r\nif (WARN_ON(extpci_core))\r\nreturn;\r\nextpci_core = pc;\r\nssb_dbg("PCIcore in host mode found\n");\r\nval = SSB_PCICORE_CTL_RST_OE;\r\nval |= SSB_PCICORE_CTL_CLK_OE;\r\npcicore_write32(pc, SSB_PCICORE_CTL, val);\r\nval |= SSB_PCICORE_CTL_CLK;\r\npcicore_write32(pc, SSB_PCICORE_CTL, val);\r\nudelay(150);\r\nval |= SSB_PCICORE_CTL_RST;\r\npcicore_write32(pc, SSB_PCICORE_CTL, val);\r\nval = SSB_PCICORE_ARBCTL_INTERN;\r\npcicore_write32(pc, SSB_PCICORE_ARBCTL, val);\r\nudelay(1);\r\nif (pc->dev->bus->has_cardbus_slot) {\r\nssb_dbg("CardBus slot detected\n");\r\npc->cardbusmode = 1;\r\nssb_gpio_out(pc->dev->bus, 1, 1);\r\nssb_gpio_outen(pc->dev->bus, 1, 1);\r\npcicore_write16(pc, SSB_PCICORE_SPROM(0),\r\npcicore_read16(pc, SSB_PCICORE_SPROM(0))\r\n| 0x0400);\r\n}\r\npcicore_write32(pc, SSB_PCICORE_SBTOPCI0,\r\nSSB_PCICORE_SBTOPCI_IO);\r\npcicore_write32(pc, SSB_PCICORE_SBTOPCI1,\r\nSSB_PCICORE_SBTOPCI_CFG0);\r\npcicore_write32(pc, SSB_PCICORE_SBTOPCI2,\r\nSSB_PCICORE_SBTOPCI_MEM | SSB_PCI_DMA);\r\nval = PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;\r\nssb_extpci_write_config(pc, 0, 0, 0, PCI_COMMAND, &val, 2);\r\nval = 0;\r\nssb_extpci_write_config(pc, 0, 0, 0, PCI_STATUS, &val, 2);\r\npcicore_write32(pc, SSB_PCICORE_IMASK,\r\nSSB_PCICORE_IMASK_INTA);\r\nssb_pcicore_controller.io_map_base = (unsigned long)ioremap_nocache(SSB_PCI_MEM, 0x04000000);\r\nset_io_port_base(ssb_pcicore_controller.io_map_base);\r\nmdelay(10);\r\nregister_pci_controller(&ssb_pcicore_controller);\r\n}\r\nstatic int pcicore_is_in_hostmode(struct ssb_pcicore *pc)\r\n{\r\nstruct ssb_bus *bus = pc->dev->bus;\r\nu16 chipid_top;\r\nu32 tmp;\r\nchipid_top = (bus->chip_id & 0xFF00);\r\nif (chipid_top != 0x4700 &&\r\nchipid_top != 0x5300)\r\nreturn 0;\r\nif (bus->sprom.boardflags_lo & SSB_PCICORE_BFL_NOPCI)\r\nreturn 0;\r\nif (bus->chip_id == 0x4712) {\r\nif (bus->chip_package == SSB_CHIPPACK_BCM4712S)\r\nreturn 0;\r\nif (bus->chip_package == SSB_CHIPPACK_BCM4712M)\r\nreturn 0;\r\n}\r\nif (bus->chip_id == 0x5350)\r\nreturn 0;\r\nreturn !mips_busprobe32(tmp, (bus->mmio + (pc->dev->core_index * SSB_CORE_SIZE)));\r\n}\r\nstatic void ssb_pcicore_fix_sprom_core_index(struct ssb_pcicore *pc)\r\n{\r\nu16 tmp = pcicore_read16(pc, SSB_PCICORE_SPROM(0));\r\nif (((tmp & 0xF000) >> 12) != pc->dev->core_index) {\r\ntmp &= ~0xF000;\r\ntmp |= (pc->dev->core_index << 12);\r\npcicore_write16(pc, SSB_PCICORE_SPROM(0), tmp);\r\n}\r\n}\r\nstatic u8 ssb_pcicore_polarity_workaround(struct ssb_pcicore *pc)\r\n{\r\nreturn (ssb_pcie_read(pc, 0x204) & 0x10) ? 0xC0 : 0x80;\r\n}\r\nstatic void ssb_pcicore_serdes_workaround(struct ssb_pcicore *pc)\r\n{\r\nconst u8 serdes_pll_device = 0x1D;\r\nconst u8 serdes_rx_device = 0x1F;\r\nu16 tmp;\r\nssb_pcie_mdio_write(pc, serdes_rx_device, 1 ,\r\nssb_pcicore_polarity_workaround(pc));\r\ntmp = ssb_pcie_mdio_read(pc, serdes_pll_device, 1 );\r\nif (tmp & 0x4000)\r\nssb_pcie_mdio_write(pc, serdes_pll_device, 1, tmp & ~0x4000);\r\n}\r\nstatic void ssb_pcicore_pci_setup_workarounds(struct ssb_pcicore *pc)\r\n{\r\nstruct ssb_device *pdev = pc->dev;\r\nstruct ssb_bus *bus = pdev->bus;\r\nu32 tmp;\r\ntmp = pcicore_read32(pc, SSB_PCICORE_SBTOPCI2);\r\ntmp |= SSB_PCICORE_SBTOPCI_PREF;\r\ntmp |= SSB_PCICORE_SBTOPCI_BURST;\r\npcicore_write32(pc, SSB_PCICORE_SBTOPCI2, tmp);\r\nif (pdev->id.revision < 5) {\r\ntmp = ssb_read32(pdev, SSB_IMCFGLO);\r\ntmp &= ~SSB_IMCFGLO_SERTO;\r\ntmp |= 2;\r\ntmp &= ~SSB_IMCFGLO_REQTO;\r\ntmp |= 3 << SSB_IMCFGLO_REQTO_SHIFT;\r\nssb_write32(pdev, SSB_IMCFGLO, tmp);\r\nssb_commit_settings(bus);\r\n} else if (pdev->id.revision >= 11) {\r\ntmp = pcicore_read32(pc, SSB_PCICORE_SBTOPCI2);\r\ntmp |= SSB_PCICORE_SBTOPCI_MRM;\r\npcicore_write32(pc, SSB_PCICORE_SBTOPCI2, tmp);\r\n}\r\n}\r\nstatic void ssb_pcicore_pcie_setup_workarounds(struct ssb_pcicore *pc)\r\n{\r\nu32 tmp;\r\nu8 rev = pc->dev->id.revision;\r\nif (rev == 0 || rev == 1) {\r\ntmp = ssb_pcie_read(pc, 0x4);\r\ntmp |= 0x8;\r\nssb_pcie_write(pc, 0x4, tmp);\r\n}\r\nif (rev == 1) {\r\ntmp = ssb_pcie_read(pc, 0x100);\r\ntmp |= 0x40;\r\nssb_pcie_write(pc, 0x100, tmp);\r\n}\r\nif (rev == 0) {\r\nconst u8 serdes_rx_device = 0x1F;\r\nssb_pcie_mdio_write(pc, serdes_rx_device,\r\n2 , 0x8128);\r\nssb_pcie_mdio_write(pc, serdes_rx_device,\r\n6 , 0x0100);\r\nssb_pcie_mdio_write(pc, serdes_rx_device,\r\n7 , 0x1466);\r\n} else if (rev == 3 || rev == 4 || rev == 5) {\r\nssb_pcicore_serdes_workaround(pc);\r\n} else if (rev == 7) {\r\n}\r\nif (rev >= 6) {\r\ntmp = pcicore_read16(pc, SSB_PCICORE_SPROM(5));\r\nif (!(tmp & 0x8000))\r\npcicore_write16(pc, SSB_PCICORE_SPROM(5),\r\ntmp | 0x8000);\r\n}\r\n}\r\nstatic void ssb_pcicore_init_clientmode(struct ssb_pcicore *pc)\r\n{\r\nstruct ssb_device *pdev = pc->dev;\r\nstruct ssb_bus *bus = pdev->bus;\r\nif (bus->bustype == SSB_BUSTYPE_PCI)\r\nssb_pcicore_fix_sprom_core_index(pc);\r\nssb_write32(pdev, SSB_INTVEC, 0);\r\nif (pc->dev->id.coreid == SSB_DEV_PCIE) {\r\nssb_pcicore_serdes_workaround(pc);\r\n}\r\n}\r\nvoid ssb_pcicore_init(struct ssb_pcicore *pc)\r\n{\r\nstruct ssb_device *dev = pc->dev;\r\nif (!dev)\r\nreturn;\r\nif (!ssb_device_is_enabled(dev))\r\nssb_device_enable(dev, 0);\r\n#ifdef CONFIG_SSB_PCICORE_HOSTMODE\r\npc->hostmode = pcicore_is_in_hostmode(pc);\r\nif (pc->hostmode)\r\nssb_pcicore_init_hostmode(pc);\r\n#endif\r\nif (!pc->hostmode)\r\nssb_pcicore_init_clientmode(pc);\r\n}\r\nstatic u32 ssb_pcie_read(struct ssb_pcicore *pc, u32 address)\r\n{\r\npcicore_write32(pc, 0x130, address);\r\nreturn pcicore_read32(pc, 0x134);\r\n}\r\nstatic void ssb_pcie_write(struct ssb_pcicore *pc, u32 address, u32 data)\r\n{\r\npcicore_write32(pc, 0x130, address);\r\npcicore_write32(pc, 0x134, data);\r\n}\r\nstatic void ssb_pcie_mdio_set_phy(struct ssb_pcicore *pc, u8 phy)\r\n{\r\nconst u16 mdio_control = 0x128;\r\nconst u16 mdio_data = 0x12C;\r\nu32 v;\r\nint i;\r\nv = (1 << 30);\r\nv |= (1 << 28);\r\nv |= (1 << 17);\r\nv |= (0x1F << 18);\r\nv |= (phy << 4);\r\npcicore_write32(pc, mdio_data, v);\r\nudelay(10);\r\nfor (i = 0; i < 200; i++) {\r\nv = pcicore_read32(pc, mdio_control);\r\nif (v & 0x100 )\r\nbreak;\r\nmsleep(1);\r\n}\r\n}\r\nstatic u16 ssb_pcie_mdio_read(struct ssb_pcicore *pc, u8 device, u8 address)\r\n{\r\nconst u16 mdio_control = 0x128;\r\nconst u16 mdio_data = 0x12C;\r\nint max_retries = 10;\r\nu16 ret = 0;\r\nu32 v;\r\nint i;\r\nv = 0x80;\r\nv |= 0x2;\r\npcicore_write32(pc, mdio_control, v);\r\nif (pc->dev->id.revision >= 10) {\r\nmax_retries = 200;\r\nssb_pcie_mdio_set_phy(pc, device);\r\n}\r\nv = (1 << 30);\r\nv |= (1 << 29);\r\nv |= (1 << 17);\r\nif (pc->dev->id.revision < 10)\r\nv |= (u32)device << 22;\r\nv |= (u32)address << 18;\r\npcicore_write32(pc, mdio_data, v);\r\nudelay(10);\r\nfor (i = 0; i < max_retries; i++) {\r\nv = pcicore_read32(pc, mdio_control);\r\nif (v & 0x100 ) {\r\nudelay(10);\r\nret = pcicore_read32(pc, mdio_data);\r\nbreak;\r\n}\r\nmsleep(1);\r\n}\r\npcicore_write32(pc, mdio_control, 0);\r\nreturn ret;\r\n}\r\nstatic void ssb_pcie_mdio_write(struct ssb_pcicore *pc, u8 device,\r\nu8 address, u16 data)\r\n{\r\nconst u16 mdio_control = 0x128;\r\nconst u16 mdio_data = 0x12C;\r\nint max_retries = 10;\r\nu32 v;\r\nint i;\r\nv = 0x80;\r\nv |= 0x2;\r\npcicore_write32(pc, mdio_control, v);\r\nif (pc->dev->id.revision >= 10) {\r\nmax_retries = 200;\r\nssb_pcie_mdio_set_phy(pc, device);\r\n}\r\nv = (1 << 30);\r\nv |= (1 << 28);\r\nv |= (1 << 17);\r\nif (pc->dev->id.revision < 10)\r\nv |= (u32)device << 22;\r\nv |= (u32)address << 18;\r\nv |= data;\r\npcicore_write32(pc, mdio_data, v);\r\nudelay(10);\r\nfor (i = 0; i < max_retries; i++) {\r\nv = pcicore_read32(pc, mdio_control);\r\nif (v & 0x100 )\r\nbreak;\r\nmsleep(1);\r\n}\r\npcicore_write32(pc, mdio_control, 0);\r\n}\r\nint ssb_pcicore_dev_irqvecs_enable(struct ssb_pcicore *pc,\r\nstruct ssb_device *dev)\r\n{\r\nstruct ssb_device *pdev = pc->dev;\r\nstruct ssb_bus *bus;\r\nint err = 0;\r\nu32 tmp;\r\nif (dev->bus->bustype != SSB_BUSTYPE_PCI) {\r\ngoto out;\r\n}\r\nif (!pdev)\r\ngoto out;\r\nbus = pdev->bus;\r\nmight_sleep_if(pdev->id.coreid != SSB_DEV_PCI);\r\nif ((pdev->id.revision >= 6) || (pdev->id.coreid == SSB_DEV_PCIE)) {\r\nu32 coremask;\r\ncoremask = (1 << dev->core_index);\r\nSSB_WARN_ON(bus->bustype != SSB_BUSTYPE_PCI);\r\nerr = pci_read_config_dword(bus->host_pci, SSB_PCI_IRQMASK, &tmp);\r\nif (err)\r\ngoto out;\r\ntmp |= coremask << 8;\r\nerr = pci_write_config_dword(bus->host_pci, SSB_PCI_IRQMASK, tmp);\r\nif (err)\r\ngoto out;\r\n} else {\r\nu32 intvec;\r\nintvec = ssb_read32(pdev, SSB_INTVEC);\r\ntmp = ssb_read32(dev, SSB_TPSFLAG);\r\ntmp &= SSB_TPSFLAG_BPFLAG;\r\nintvec |= (1 << tmp);\r\nssb_write32(pdev, SSB_INTVEC, intvec);\r\n}\r\nif (pc->setup_done)\r\ngoto out;\r\nif (pdev->id.coreid == SSB_DEV_PCI) {\r\nssb_pcicore_pci_setup_workarounds(pc);\r\n} else {\r\nWARN_ON(pdev->id.coreid != SSB_DEV_PCIE);\r\nssb_pcicore_pcie_setup_workarounds(pc);\r\n}\r\npc->setup_done = 1;\r\nout:\r\nreturn err;\r\n}
