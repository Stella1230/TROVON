static void reset_counters(struct comedi_device *dev)\r\n{\r\noutw(0xFFC2, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF02, dev->iobase + AM9513A_COM_REG);\r\noutw(0x4, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF0A, dev->iobase + AM9513A_COM_REG);\r\noutw(0x3, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF42, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF42, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFFC4, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF03, dev->iobase + AM9513A_COM_REG);\r\noutw(0x4, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF0B, dev->iobase + AM9513A_COM_REG);\r\noutw(0x3, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF44, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF44, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFFC8, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF04, dev->iobase + AM9513A_COM_REG);\r\noutw(0x4, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF0C, dev->iobase + AM9513A_COM_REG);\r\noutw(0x3, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF48, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF48, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFFD0, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF05, dev->iobase + AM9513A_COM_REG);\r\noutw(0x4, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF0D, dev->iobase + AM9513A_COM_REG);\r\noutw(0x3, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF50, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF50, dev->iobase + AM9513A_COM_REG);\r\noutw(0, dev->iobase + AD_CLEAR_REG);\r\n}\r\nstatic void reset_atmio16d(struct comedi_device *dev)\r\n{\r\nstruct atmio16d_private *devpriv = dev->private;\r\nint i;\r\noutw(0, dev->iobase + COM_REG_1);\r\noutw(0, dev->iobase + COM_REG_2);\r\noutw(0, dev->iobase + MUX_GAIN_REG);\r\noutw(0xFFFF, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFFEF, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF17, dev->iobase + AM9513A_COM_REG);\r\noutw(0xF000, dev->iobase + AM9513A_DATA_REG);\r\nfor (i = 1; i <= 5; ++i) {\r\noutw(0xFF00 + i, dev->iobase + AM9513A_COM_REG);\r\noutw(0x0004, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF08 + i, dev->iobase + AM9513A_COM_REG);\r\noutw(0x3, dev->iobase + AM9513A_DATA_REG);\r\n}\r\noutw(0xFF5F, dev->iobase + AM9513A_COM_REG);\r\noutw(0, dev->iobase + AD_CLEAR_REG);\r\noutw(0, dev->iobase + INT2CLR_REG);\r\ndevpriv->com_reg_1_state |= 1;\r\noutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\r\ndevpriv->adc_coding = adc_straight;\r\noutw(2048, dev->iobase + DAC0_REG);\r\noutw(2048, dev->iobase + DAC1_REG);\r\n}\r\nstatic irqreturn_t atmio16d_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nunsigned short val;\r\nval = inw(dev->iobase + AD_FIFO_REG);\r\ncomedi_buf_write_samples(s, &val, 1);\r\ncomedi_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int atmio16d_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nerr |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nerr |= cfc_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_FOLLOW | TRIG_TIMER);\r\nerr |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER);\r\nerr |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= cfc_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= cfc_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (cmd->scan_begin_src == TRIG_FOLLOW) {\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\n} else {\r\n#if 0\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\n#endif\r\n}\r\nerr |= cfc_check_trigger_arg_min(&cmd->convert_arg, 10000);\r\n#if 0\r\nerr |= cfc_check_trigger_arg_max(&cmd->convert_arg, SLOWEST_TIMER);\r\n#endif\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nreturn 0;\r\n}\r\nstatic int atmio16d_ai_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct atmio16d_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int timer, base_clock;\r\nunsigned int sample_count, tmp, chan, gain;\r\nint i;\r\nreset_counters(dev);\r\nif (cmd->chanlist_len < 2) {\r\ndevpriv->com_reg_1_state &= ~COMREG1_SCANEN;\r\noutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\r\n} else {\r\ndevpriv->com_reg_1_state |= COMREG1_SCANEN;\r\ndevpriv->com_reg_2_state |= COMREG2_SCN2;\r\noutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\r\noutw(devpriv->com_reg_2_state, dev->iobase + COM_REG_2);\r\n}\r\nfor (i = 0; i < cmd->chanlist_len; ++i) {\r\nchan = CR_CHAN(cmd->chanlist[i]);\r\ngain = CR_RANGE(cmd->chanlist[i]);\r\noutw(i, dev->iobase + MUX_CNTR_REG);\r\ntmp = chan | (gain << 6);\r\nif (i == cmd->scan_end_arg - 1)\r\ntmp |= 0x0010;\r\noutw(tmp, dev->iobase + MUX_GAIN_REG);\r\n}\r\nif (cmd->convert_arg < 65536000) {\r\nbase_clock = CLOCK_1_MHZ;\r\ntimer = cmd->convert_arg / 1000;\r\n} else if (cmd->convert_arg < 655360000) {\r\nbase_clock = CLOCK_100_KHZ;\r\ntimer = cmd->convert_arg / 10000;\r\n} else {\r\nbase_clock = CLOCK_10_KHZ;\r\ntimer = cmd->convert_arg / 100000;\r\n}\r\noutw(0xFF03, dev->iobase + AM9513A_COM_REG);\r\noutw(base_clock, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF0B, dev->iobase + AM9513A_COM_REG);\r\noutw(0x2, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF44, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFFF3, dev->iobase + AM9513A_COM_REG);\r\noutw(timer, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF24, dev->iobase + AM9513A_COM_REG);\r\nsample_count = cmd->stop_arg * cmd->scan_end_arg;\r\noutw(0xFF04, dev->iobase + AM9513A_COM_REG);\r\noutw(0x1025, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF0C, dev->iobase + AM9513A_COM_REG);\r\nif (sample_count < 65536) {\r\noutw(sample_count, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF48, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFFF4, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF28, dev->iobase + AM9513A_COM_REG);\r\ndevpriv->com_reg_1_state &= ~COMREG1_1632CNT;\r\noutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\r\n} else {\r\ntmp = sample_count & 0xFFFF;\r\nif (tmp)\r\noutw(tmp - 1, dev->iobase + AM9513A_DATA_REG);\r\nelse\r\noutw(0xFFFF, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF48, dev->iobase + AM9513A_COM_REG);\r\noutw(0, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF28, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF05, dev->iobase + AM9513A_COM_REG);\r\noutw(0x25, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF0D, dev->iobase + AM9513A_COM_REG);\r\ntmp = sample_count & 0xFFFF;\r\nif ((tmp == 0) || (tmp == 1)) {\r\noutw((sample_count >> 16) & 0xFFFF,\r\ndev->iobase + AM9513A_DATA_REG);\r\n} else {\r\noutw(((sample_count >> 16) & 0xFFFF) + 1,\r\ndev->iobase + AM9513A_DATA_REG);\r\n}\r\noutw(0xFF70, dev->iobase + AM9513A_COM_REG);\r\ndevpriv->com_reg_1_state |= COMREG1_1632CNT;\r\noutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\r\n}\r\nif (cmd->chanlist_len > 1) {\r\nif (cmd->scan_begin_arg < 65536000) {\r\nbase_clock = CLOCK_1_MHZ;\r\ntimer = cmd->scan_begin_arg / 1000;\r\n} else if (cmd->scan_begin_arg < 655360000) {\r\nbase_clock = CLOCK_100_KHZ;\r\ntimer = cmd->scan_begin_arg / 10000;\r\n} else {\r\nbase_clock = CLOCK_10_KHZ;\r\ntimer = cmd->scan_begin_arg / 100000;\r\n}\r\noutw(0xFF02, dev->iobase + AM9513A_COM_REG);\r\noutw(base_clock, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF0A, dev->iobase + AM9513A_COM_REG);\r\noutw(0x2, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF42, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFFF2, dev->iobase + AM9513A_COM_REG);\r\noutw(timer, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF22, dev->iobase + AM9513A_COM_REG);\r\n}\r\noutw(0, dev->iobase + AD_CLEAR_REG);\r\noutw(0, dev->iobase + MUX_CNTR_REG);\r\noutw(0, dev->iobase + INT2CLR_REG);\r\ndevpriv->com_reg_1_state |= COMREG1_DAQEN;\r\noutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\r\ndevpriv->com_reg_1_state |= COMREG1_CONVINTEN;\r\ndevpriv->com_reg_2_state |= COMREG2_INTEN;\r\noutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\r\noutw(devpriv->com_reg_2_state, dev->iobase + COM_REG_2);\r\noutw(0, dev->iobase + START_DAQ_REG);\r\nreturn 0;\r\n}\r\nstatic int atmio16d_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nreset_atmio16d(dev);\r\nreturn 0;\r\n}\r\nstatic int atmio16d_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nstatus = inw(dev->iobase + STAT_REG);\r\nif (status & STAT_AD_CONVAVAIL)\r\nreturn 0;\r\nif (status & STAT_AD_OVERFLOW) {\r\noutw(0, dev->iobase + AD_CLEAR_REG);\r\nreturn -EOVERFLOW;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int atmio16d_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct atmio16d_private *devpriv = dev->private;\r\nint i;\r\nint chan;\r\nint gain;\r\nint ret;\r\nchan = CR_CHAN(insn->chanspec);\r\ngain = CR_RANGE(insn->chanspec);\r\noutw(chan | (gain << 6), dev->iobase + MUX_GAIN_REG);\r\nfor (i = 0; i < insn->n; i++) {\r\noutw(0, dev->iobase + START_CONVERT_REG);\r\nret = comedi_timeout(dev, s, insn, atmio16d_ai_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\ndata[i] = inw(dev->iobase + AD_FIFO_REG);\r\nif (devpriv->adc_coding == adc_2comp)\r\ndata[i] ^= 0x800;\r\n}\r\nreturn i;\r\n}\r\nstatic int atmio16d_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct atmio16d_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int reg = (chan) ? DAC1_REG : DAC0_REG;\r\nbool munge = false;\r\nint i;\r\nif (chan == 0 && devpriv->dac0_coding == dac_2comp)\r\nmunge = true;\r\nif (chan == 1 && devpriv->dac1_coding == dac_2comp)\r\nmunge = true;\r\nfor (i = 0; i < insn->n; i++) {\r\nunsigned int val = data[i];\r\ns->readback[chan] = val;\r\nif (munge)\r\nval ^= 0x800;\r\noutw(val, dev->iobase + reg);\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int atmio16d_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data))\r\noutw(s->state, dev->iobase + MIO_16_DIG_OUT_REG);\r\ndata[1] = inw(dev->iobase + MIO_16_DIG_IN_REG);\r\nreturn insn->n;\r\n}\r\nstatic int atmio16d_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct atmio16d_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int mask;\r\nint ret;\r\nif (chan < 4)\r\nmask = 0x0f;\r\nelse\r\nmask = 0xf0;\r\nret = comedi_dio_insn_config(dev, s, insn, data, mask);\r\nif (ret)\r\nreturn ret;\r\ndevpriv->com_reg_2_state &= ~(COMREG2_DOUTEN0 | COMREG2_DOUTEN1);\r\nif (s->io_bits & 0x0f)\r\ndevpriv->com_reg_2_state |= COMREG2_DOUTEN0;\r\nif (s->io_bits & 0xf0)\r\ndevpriv->com_reg_2_state |= COMREG2_DOUTEN1;\r\noutw(devpriv->com_reg_2_state, dev->iobase + COM_REG_2);\r\nreturn insn->n;\r\n}\r\nstatic int atmio16d_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nconst struct atmio16_board_t *board = dev->board_ptr;\r\nstruct atmio16d_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nret = comedi_request_region(dev, it->options[0], 0x20);\r\nif (ret)\r\nreturn ret;\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\nreturn ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nreset_atmio16d(dev);\r\nif (it->options[1]) {\r\nret = request_irq(it->options[1], atmio16d_interrupt, 0,\r\ndev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = it->options[1];\r\n}\r\ndevpriv->adc_mux = it->options[5];\r\ndevpriv->adc_range = it->options[6];\r\ndevpriv->dac0_range = it->options[7];\r\ndevpriv->dac0_reference = it->options[8];\r\ndevpriv->dac0_coding = it->options[9];\r\ndevpriv->dac1_range = it->options[10];\r\ndevpriv->dac1_reference = it->options[11];\r\ndevpriv->dac1_coding = it->options[12];\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND;\r\ns->n_chan = (devpriv->adc_mux ? 16 : 8);\r\ns->insn_read = atmio16d_ai_insn_read;\r\ns->maxdata = 0xfff;\r\nswitch (devpriv->adc_range) {\r\ncase adc_bipolar10:\r\ns->range_table = &range_atmio16d_ai_10_bipolar;\r\nbreak;\r\ncase adc_bipolar5:\r\ns->range_table = &range_atmio16d_ai_5_bipolar;\r\nbreak;\r\ncase adc_unipolar10:\r\ns->range_table = &range_atmio16d_ai_unipolar;\r\nbreak;\r\n}\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->len_chanlist = 16;\r\ns->do_cmdtest = atmio16d_ai_cmdtest;\r\ns->do_cmd = atmio16d_ai_cmd;\r\ns->cancel = atmio16d_ai_cancel;\r\n}\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 2;\r\ns->maxdata = 0xfff;\r\ns->range_table_list = devpriv->ao_range_type_list;\r\nswitch (devpriv->dac0_range) {\r\ncase dac_bipolar:\r\ndevpriv->ao_range_type_list[0] = &range_bipolar10;\r\nbreak;\r\ncase dac_unipolar:\r\ndevpriv->ao_range_type_list[0] = &range_unipolar10;\r\nbreak;\r\n}\r\nswitch (devpriv->dac1_range) {\r\ncase dac_bipolar:\r\ndevpriv->ao_range_type_list[1] = &range_bipolar10;\r\nbreak;\r\ncase dac_unipolar:\r\ndevpriv->ao_range_type_list[1] = &range_unipolar10;\r\nbreak;\r\n}\r\ns->insn_write = atmio16d_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = 8;\r\ns->insn_bits = atmio16d_dio_insn_bits;\r\ns->insn_config = atmio16d_dio_insn_config;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns = &dev->subdevices[3];\r\nif (board->has_8255) {\r\nret = subdev_8255_init(dev, s, NULL, 0x00);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\n#if 0\r\ns = &dev->subdevices[4];\r\ns->type = COMEDI_SUBD_TIMER;\r\ns->n_chan = 0;\r\ns->maxdata = 0\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void atmio16d_detach(struct comedi_device *dev)\r\n{\r\nreset_atmio16d(dev);\r\ncomedi_legacy_detach(dev);\r\n}
