static inline struct xfs_efi_log_item *EFI_ITEM(struct xfs_log_item *lip)\r\n{\r\nreturn container_of(lip, struct xfs_efi_log_item, efi_item);\r\n}\r\nvoid\r\nxfs_efi_item_free(\r\nstruct xfs_efi_log_item *efip)\r\n{\r\nif (efip->efi_format.efi_nextents > XFS_EFI_MAX_FAST_EXTENTS)\r\nkmem_free(efip);\r\nelse\r\nkmem_zone_free(xfs_efi_zone, efip);\r\n}\r\nSTATIC void\r\n__xfs_efi_release(\r\nstruct xfs_efi_log_item *efip)\r\n{\r\nstruct xfs_ail *ailp = efip->efi_item.li_ailp;\r\nif (atomic_dec_and_test(&efip->efi_refcount)) {\r\nspin_lock(&ailp->xa_lock);\r\nxfs_trans_ail_delete(ailp, &efip->efi_item,\r\nSHUTDOWN_LOG_IO_ERROR);\r\nxfs_efi_item_free(efip);\r\n}\r\n}\r\nstatic inline int\r\nxfs_efi_item_sizeof(\r\nstruct xfs_efi_log_item *efip)\r\n{\r\nreturn sizeof(struct xfs_efi_log_format) +\r\n(efip->efi_format.efi_nextents - 1) * sizeof(xfs_extent_t);\r\n}\r\nSTATIC void\r\nxfs_efi_item_size(\r\nstruct xfs_log_item *lip,\r\nint *nvecs,\r\nint *nbytes)\r\n{\r\n*nvecs += 1;\r\n*nbytes += xfs_efi_item_sizeof(EFI_ITEM(lip));\r\n}\r\nSTATIC void\r\nxfs_efi_item_format(\r\nstruct xfs_log_item *lip,\r\nstruct xfs_log_vec *lv)\r\n{\r\nstruct xfs_efi_log_item *efip = EFI_ITEM(lip);\r\nstruct xfs_log_iovec *vecp = NULL;\r\nASSERT(atomic_read(&efip->efi_next_extent) ==\r\nefip->efi_format.efi_nextents);\r\nefip->efi_format.efi_type = XFS_LI_EFI;\r\nefip->efi_format.efi_size = 1;\r\nxlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_EFI_FORMAT,\r\n&efip->efi_format,\r\nxfs_efi_item_sizeof(efip));\r\n}\r\nSTATIC void\r\nxfs_efi_item_pin(\r\nstruct xfs_log_item *lip)\r\n{\r\n}\r\nSTATIC void\r\nxfs_efi_item_unpin(\r\nstruct xfs_log_item *lip,\r\nint remove)\r\n{\r\nstruct xfs_efi_log_item *efip = EFI_ITEM(lip);\r\nif (remove) {\r\nASSERT(!(lip->li_flags & XFS_LI_IN_AIL));\r\nif (lip->li_desc)\r\nxfs_trans_del_item(lip);\r\nxfs_efi_item_free(efip);\r\nreturn;\r\n}\r\n__xfs_efi_release(efip);\r\n}\r\nSTATIC uint\r\nxfs_efi_item_push(\r\nstruct xfs_log_item *lip,\r\nstruct list_head *buffer_list)\r\n{\r\nreturn XFS_ITEM_PINNED;\r\n}\r\nSTATIC void\r\nxfs_efi_item_unlock(\r\nstruct xfs_log_item *lip)\r\n{\r\nif (lip->li_flags & XFS_LI_ABORTED)\r\nxfs_efi_item_free(EFI_ITEM(lip));\r\n}\r\nSTATIC xfs_lsn_t\r\nxfs_efi_item_committed(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\nreturn lsn;\r\n}\r\nSTATIC void\r\nxfs_efi_item_committing(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\n}\r\nstruct xfs_efi_log_item *\r\nxfs_efi_init(\r\nstruct xfs_mount *mp,\r\nuint nextents)\r\n{\r\nstruct xfs_efi_log_item *efip;\r\nuint size;\r\nASSERT(nextents > 0);\r\nif (nextents > XFS_EFI_MAX_FAST_EXTENTS) {\r\nsize = (uint)(sizeof(xfs_efi_log_item_t) +\r\n((nextents - 1) * sizeof(xfs_extent_t)));\r\nefip = kmem_zalloc(size, KM_SLEEP);\r\n} else {\r\nefip = kmem_zone_zalloc(xfs_efi_zone, KM_SLEEP);\r\n}\r\nxfs_log_item_init(mp, &efip->efi_item, XFS_LI_EFI, &xfs_efi_item_ops);\r\nefip->efi_format.efi_nextents = nextents;\r\nefip->efi_format.efi_id = (__psint_t)(void*)efip;\r\natomic_set(&efip->efi_next_extent, 0);\r\natomic_set(&efip->efi_refcount, 2);\r\nreturn efip;\r\n}\r\nint\r\nxfs_efi_copy_format(xfs_log_iovec_t *buf, xfs_efi_log_format_t *dst_efi_fmt)\r\n{\r\nxfs_efi_log_format_t *src_efi_fmt = buf->i_addr;\r\nuint i;\r\nuint len = sizeof(xfs_efi_log_format_t) +\r\n(src_efi_fmt->efi_nextents - 1) * sizeof(xfs_extent_t);\r\nuint len32 = sizeof(xfs_efi_log_format_32_t) +\r\n(src_efi_fmt->efi_nextents - 1) * sizeof(xfs_extent_32_t);\r\nuint len64 = sizeof(xfs_efi_log_format_64_t) +\r\n(src_efi_fmt->efi_nextents - 1) * sizeof(xfs_extent_64_t);\r\nif (buf->i_len == len) {\r\nmemcpy((char *)dst_efi_fmt, (char*)src_efi_fmt, len);\r\nreturn 0;\r\n} else if (buf->i_len == len32) {\r\nxfs_efi_log_format_32_t *src_efi_fmt_32 = buf->i_addr;\r\ndst_efi_fmt->efi_type = src_efi_fmt_32->efi_type;\r\ndst_efi_fmt->efi_size = src_efi_fmt_32->efi_size;\r\ndst_efi_fmt->efi_nextents = src_efi_fmt_32->efi_nextents;\r\ndst_efi_fmt->efi_id = src_efi_fmt_32->efi_id;\r\nfor (i = 0; i < dst_efi_fmt->efi_nextents; i++) {\r\ndst_efi_fmt->efi_extents[i].ext_start =\r\nsrc_efi_fmt_32->efi_extents[i].ext_start;\r\ndst_efi_fmt->efi_extents[i].ext_len =\r\nsrc_efi_fmt_32->efi_extents[i].ext_len;\r\n}\r\nreturn 0;\r\n} else if (buf->i_len == len64) {\r\nxfs_efi_log_format_64_t *src_efi_fmt_64 = buf->i_addr;\r\ndst_efi_fmt->efi_type = src_efi_fmt_64->efi_type;\r\ndst_efi_fmt->efi_size = src_efi_fmt_64->efi_size;\r\ndst_efi_fmt->efi_nextents = src_efi_fmt_64->efi_nextents;\r\ndst_efi_fmt->efi_id = src_efi_fmt_64->efi_id;\r\nfor (i = 0; i < dst_efi_fmt->efi_nextents; i++) {\r\ndst_efi_fmt->efi_extents[i].ext_start =\r\nsrc_efi_fmt_64->efi_extents[i].ext_start;\r\ndst_efi_fmt->efi_extents[i].ext_len =\r\nsrc_efi_fmt_64->efi_extents[i].ext_len;\r\n}\r\nreturn 0;\r\n}\r\nreturn -EFSCORRUPTED;\r\n}\r\nvoid\r\nxfs_efi_release(xfs_efi_log_item_t *efip,\r\nuint nextents)\r\n{\r\nASSERT(atomic_read(&efip->efi_next_extent) >= nextents);\r\nif (atomic_sub_and_test(nextents, &efip->efi_next_extent)) {\r\nif (test_bit(XFS_EFI_RECOVERED, &efip->efi_flags))\r\n__xfs_efi_release(efip);\r\n__xfs_efi_release(efip);\r\n}\r\n}\r\nstatic inline struct xfs_efd_log_item *EFD_ITEM(struct xfs_log_item *lip)\r\n{\r\nreturn container_of(lip, struct xfs_efd_log_item, efd_item);\r\n}\r\nSTATIC void\r\nxfs_efd_item_free(struct xfs_efd_log_item *efdp)\r\n{\r\nif (efdp->efd_format.efd_nextents > XFS_EFD_MAX_FAST_EXTENTS)\r\nkmem_free(efdp);\r\nelse\r\nkmem_zone_free(xfs_efd_zone, efdp);\r\n}\r\nstatic inline int\r\nxfs_efd_item_sizeof(\r\nstruct xfs_efd_log_item *efdp)\r\n{\r\nreturn sizeof(xfs_efd_log_format_t) +\r\n(efdp->efd_format.efd_nextents - 1) * sizeof(xfs_extent_t);\r\n}\r\nSTATIC void\r\nxfs_efd_item_size(\r\nstruct xfs_log_item *lip,\r\nint *nvecs,\r\nint *nbytes)\r\n{\r\n*nvecs += 1;\r\n*nbytes += xfs_efd_item_sizeof(EFD_ITEM(lip));\r\n}\r\nSTATIC void\r\nxfs_efd_item_format(\r\nstruct xfs_log_item *lip,\r\nstruct xfs_log_vec *lv)\r\n{\r\nstruct xfs_efd_log_item *efdp = EFD_ITEM(lip);\r\nstruct xfs_log_iovec *vecp = NULL;\r\nASSERT(efdp->efd_next_extent == efdp->efd_format.efd_nextents);\r\nefdp->efd_format.efd_type = XFS_LI_EFD;\r\nefdp->efd_format.efd_size = 1;\r\nxlog_copy_iovec(lv, &vecp, XLOG_REG_TYPE_EFD_FORMAT,\r\n&efdp->efd_format,\r\nxfs_efd_item_sizeof(efdp));\r\n}\r\nSTATIC void\r\nxfs_efd_item_pin(\r\nstruct xfs_log_item *lip)\r\n{\r\n}\r\nSTATIC void\r\nxfs_efd_item_unpin(\r\nstruct xfs_log_item *lip,\r\nint remove)\r\n{\r\n}\r\nSTATIC uint\r\nxfs_efd_item_push(\r\nstruct xfs_log_item *lip,\r\nstruct list_head *buffer_list)\r\n{\r\nreturn XFS_ITEM_PINNED;\r\n}\r\nSTATIC void\r\nxfs_efd_item_unlock(\r\nstruct xfs_log_item *lip)\r\n{\r\nif (lip->li_flags & XFS_LI_ABORTED)\r\nxfs_efd_item_free(EFD_ITEM(lip));\r\n}\r\nSTATIC xfs_lsn_t\r\nxfs_efd_item_committed(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\nstruct xfs_efd_log_item *efdp = EFD_ITEM(lip);\r\nif (!(lip->li_flags & XFS_LI_ABORTED))\r\nxfs_efi_release(efdp->efd_efip, efdp->efd_format.efd_nextents);\r\nxfs_efd_item_free(efdp);\r\nreturn (xfs_lsn_t)-1;\r\n}\r\nSTATIC void\r\nxfs_efd_item_committing(\r\nstruct xfs_log_item *lip,\r\nxfs_lsn_t lsn)\r\n{\r\n}\r\nstruct xfs_efd_log_item *\r\nxfs_efd_init(\r\nstruct xfs_mount *mp,\r\nstruct xfs_efi_log_item *efip,\r\nuint nextents)\r\n{\r\nstruct xfs_efd_log_item *efdp;\r\nuint size;\r\nASSERT(nextents > 0);\r\nif (nextents > XFS_EFD_MAX_FAST_EXTENTS) {\r\nsize = (uint)(sizeof(xfs_efd_log_item_t) +\r\n((nextents - 1) * sizeof(xfs_extent_t)));\r\nefdp = kmem_zalloc(size, KM_SLEEP);\r\n} else {\r\nefdp = kmem_zone_zalloc(xfs_efd_zone, KM_SLEEP);\r\n}\r\nxfs_log_item_init(mp, &efdp->efd_item, XFS_LI_EFD, &xfs_efd_item_ops);\r\nefdp->efd_efip = efip;\r\nefdp->efd_format.efd_nextents = nextents;\r\nefdp->efd_format.efd_efi_id = efip->efi_format.efi_id;\r\nreturn efdp;\r\n}
