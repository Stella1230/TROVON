static void dsos__init(struct dsos *dsos)\r\n{\r\nINIT_LIST_HEAD(&dsos->head);\r\ndsos->root = RB_ROOT;\r\n}\r\nint machine__init(struct machine *machine, const char *root_dir, pid_t pid)\r\n{\r\nmap_groups__init(&machine->kmaps, machine);\r\nRB_CLEAR_NODE(&machine->rb_node);\r\ndsos__init(&machine->user_dsos);\r\ndsos__init(&machine->kernel_dsos);\r\nmachine->threads = RB_ROOT;\r\nINIT_LIST_HEAD(&machine->dead_threads);\r\nmachine->last_match = NULL;\r\nmachine->vdso_info = NULL;\r\nmachine->pid = pid;\r\nmachine->symbol_filter = NULL;\r\nmachine->id_hdr_size = 0;\r\nmachine->comm_exec = false;\r\nmachine->kernel_start = 0;\r\nmachine->root_dir = strdup(root_dir);\r\nif (machine->root_dir == NULL)\r\nreturn -ENOMEM;\r\nif (pid != HOST_KERNEL_ID) {\r\nstruct thread *thread = machine__findnew_thread(machine, -1,\r\npid);\r\nchar comm[64];\r\nif (thread == NULL)\r\nreturn -ENOMEM;\r\nsnprintf(comm, sizeof(comm), "[guest/%d]", pid);\r\nthread__set_comm(thread, comm, 0);\r\n}\r\nmachine->current_tid = NULL;\r\nreturn 0;\r\n}\r\nstruct machine *machine__new_host(void)\r\n{\r\nstruct machine *machine = malloc(sizeof(*machine));\r\nif (machine != NULL) {\r\nmachine__init(machine, "", HOST_KERNEL_ID);\r\nif (machine__create_kernel_maps(machine) < 0)\r\ngoto out_delete;\r\n}\r\nreturn machine;\r\nout_delete:\r\nfree(machine);\r\nreturn NULL;\r\n}\r\nstatic void dsos__delete(struct dsos *dsos)\r\n{\r\nstruct dso *pos, *n;\r\nlist_for_each_entry_safe(pos, n, &dsos->head, node) {\r\nRB_CLEAR_NODE(&pos->rb_node);\r\nlist_del(&pos->node);\r\ndso__delete(pos);\r\n}\r\n}\r\nvoid machine__delete_dead_threads(struct machine *machine)\r\n{\r\nstruct thread *n, *t;\r\nlist_for_each_entry_safe(t, n, &machine->dead_threads, node) {\r\nlist_del(&t->node);\r\nthread__delete(t);\r\n}\r\n}\r\nvoid machine__delete_threads(struct machine *machine)\r\n{\r\nstruct rb_node *nd = rb_first(&machine->threads);\r\nwhile (nd) {\r\nstruct thread *t = rb_entry(nd, struct thread, rb_node);\r\nrb_erase(&t->rb_node, &machine->threads);\r\nnd = rb_next(nd);\r\nthread__delete(t);\r\n}\r\n}\r\nvoid machine__exit(struct machine *machine)\r\n{\r\nmap_groups__exit(&machine->kmaps);\r\ndsos__delete(&machine->user_dsos);\r\ndsos__delete(&machine->kernel_dsos);\r\nvdso__exit(machine);\r\nzfree(&machine->root_dir);\r\nzfree(&machine->current_tid);\r\n}\r\nvoid machine__delete(struct machine *machine)\r\n{\r\nmachine__exit(machine);\r\nfree(machine);\r\n}\r\nvoid machines__init(struct machines *machines)\r\n{\r\nmachine__init(&machines->host, "", HOST_KERNEL_ID);\r\nmachines->guests = RB_ROOT;\r\nmachines->symbol_filter = NULL;\r\n}\r\nvoid machines__exit(struct machines *machines)\r\n{\r\nmachine__exit(&machines->host);\r\n}\r\nstruct machine *machines__add(struct machines *machines, pid_t pid,\r\nconst char *root_dir)\r\n{\r\nstruct rb_node **p = &machines->guests.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct machine *pos, *machine = malloc(sizeof(*machine));\r\nif (machine == NULL)\r\nreturn NULL;\r\nif (machine__init(machine, root_dir, pid) != 0) {\r\nfree(machine);\r\nreturn NULL;\r\n}\r\nmachine->symbol_filter = machines->symbol_filter;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\npos = rb_entry(parent, struct machine, rb_node);\r\nif (pid < pos->pid)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nrb_link_node(&machine->rb_node, parent, p);\r\nrb_insert_color(&machine->rb_node, &machines->guests);\r\nreturn machine;\r\n}\r\nvoid machines__set_symbol_filter(struct machines *machines,\r\nsymbol_filter_t symbol_filter)\r\n{\r\nstruct rb_node *nd;\r\nmachines->symbol_filter = symbol_filter;\r\nmachines->host.symbol_filter = symbol_filter;\r\nfor (nd = rb_first(&machines->guests); nd; nd = rb_next(nd)) {\r\nstruct machine *machine = rb_entry(nd, struct machine, rb_node);\r\nmachine->symbol_filter = symbol_filter;\r\n}\r\n}\r\nvoid machines__set_comm_exec(struct machines *machines, bool comm_exec)\r\n{\r\nstruct rb_node *nd;\r\nmachines->host.comm_exec = comm_exec;\r\nfor (nd = rb_first(&machines->guests); nd; nd = rb_next(nd)) {\r\nstruct machine *machine = rb_entry(nd, struct machine, rb_node);\r\nmachine->comm_exec = comm_exec;\r\n}\r\n}\r\nstruct machine *machines__find(struct machines *machines, pid_t pid)\r\n{\r\nstruct rb_node **p = &machines->guests.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct machine *machine;\r\nstruct machine *default_machine = NULL;\r\nif (pid == HOST_KERNEL_ID)\r\nreturn &machines->host;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\nmachine = rb_entry(parent, struct machine, rb_node);\r\nif (pid < machine->pid)\r\np = &(*p)->rb_left;\r\nelse if (pid > machine->pid)\r\np = &(*p)->rb_right;\r\nelse\r\nreturn machine;\r\nif (!machine->pid)\r\ndefault_machine = machine;\r\n}\r\nreturn default_machine;\r\n}\r\nstruct machine *machines__findnew(struct machines *machines, pid_t pid)\r\n{\r\nchar path[PATH_MAX];\r\nconst char *root_dir = "";\r\nstruct machine *machine = machines__find(machines, pid);\r\nif (machine && (machine->pid == pid))\r\ngoto out;\r\nif ((pid != HOST_KERNEL_ID) &&\r\n(pid != DEFAULT_GUEST_KERNEL_ID) &&\r\n(symbol_conf.guestmount)) {\r\nsprintf(path, "%s/%d", symbol_conf.guestmount, pid);\r\nif (access(path, R_OK)) {\r\nstatic struct strlist *seen;\r\nif (!seen)\r\nseen = strlist__new(true, NULL);\r\nif (!strlist__has_entry(seen, path)) {\r\npr_err("Can't access file %s\n", path);\r\nstrlist__add(seen, path);\r\n}\r\nmachine = NULL;\r\ngoto out;\r\n}\r\nroot_dir = path;\r\n}\r\nmachine = machines__add(machines, pid, root_dir);\r\nout:\r\nreturn machine;\r\n}\r\nvoid machines__process_guests(struct machines *machines,\r\nmachine__process_t process, void *data)\r\n{\r\nstruct rb_node *nd;\r\nfor (nd = rb_first(&machines->guests); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nprocess(pos, data);\r\n}\r\n}\r\nchar *machine__mmap_name(struct machine *machine, char *bf, size_t size)\r\n{\r\nif (machine__is_host(machine))\r\nsnprintf(bf, size, "[%s]", "kernel.kallsyms");\r\nelse if (machine__is_default_guest(machine))\r\nsnprintf(bf, size, "[%s]", "guest.kernel.kallsyms");\r\nelse {\r\nsnprintf(bf, size, "[%s.%d]", "guest.kernel.kallsyms",\r\nmachine->pid);\r\n}\r\nreturn bf;\r\n}\r\nvoid machines__set_id_hdr_size(struct machines *machines, u16 id_hdr_size)\r\n{\r\nstruct rb_node *node;\r\nstruct machine *machine;\r\nmachines->host.id_hdr_size = id_hdr_size;\r\nfor (node = rb_first(&machines->guests); node; node = rb_next(node)) {\r\nmachine = rb_entry(node, struct machine, rb_node);\r\nmachine->id_hdr_size = id_hdr_size;\r\n}\r\nreturn;\r\n}\r\nstatic void machine__update_thread_pid(struct machine *machine,\r\nstruct thread *th, pid_t pid)\r\n{\r\nstruct thread *leader;\r\nif (pid == th->pid_ || pid == -1 || th->pid_ != -1)\r\nreturn;\r\nth->pid_ = pid;\r\nif (th->pid_ == th->tid)\r\nreturn;\r\nleader = machine__findnew_thread(machine, th->pid_, th->pid_);\r\nif (!leader)\r\ngoto out_err;\r\nif (!leader->mg)\r\nleader->mg = map_groups__new(machine);\r\nif (!leader->mg)\r\ngoto out_err;\r\nif (th->mg == leader->mg)\r\nreturn;\r\nif (th->mg) {\r\nif (!map_groups__empty(th->mg))\r\npr_err("Discarding thread maps for %d:%d\n",\r\nth->pid_, th->tid);\r\nmap_groups__delete(th->mg);\r\n}\r\nth->mg = map_groups__get(leader->mg);\r\nreturn;\r\nout_err:\r\npr_err("Failed to join map groups for %d:%d\n", th->pid_, th->tid);\r\n}\r\nstatic struct thread *__machine__findnew_thread(struct machine *machine,\r\npid_t pid, pid_t tid,\r\nbool create)\r\n{\r\nstruct rb_node **p = &machine->threads.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct thread *th;\r\nth = machine->last_match;\r\nif (th && th->tid == tid) {\r\nmachine__update_thread_pid(machine, th, pid);\r\nreturn th;\r\n}\r\nwhile (*p != NULL) {\r\nparent = *p;\r\nth = rb_entry(parent, struct thread, rb_node);\r\nif (th->tid == tid) {\r\nmachine->last_match = th;\r\nmachine__update_thread_pid(machine, th, pid);\r\nreturn th;\r\n}\r\nif (tid < th->tid)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nif (!create)\r\nreturn NULL;\r\nth = thread__new(pid, tid);\r\nif (th != NULL) {\r\nrb_link_node(&th->rb_node, parent, p);\r\nrb_insert_color(&th->rb_node, &machine->threads);\r\nif (thread__init_map_groups(th, machine)) {\r\nrb_erase(&th->rb_node, &machine->threads);\r\nthread__delete(th);\r\nreturn NULL;\r\n}\r\nmachine->last_match = th;\r\n}\r\nreturn th;\r\n}\r\nstruct thread *machine__findnew_thread(struct machine *machine, pid_t pid,\r\npid_t tid)\r\n{\r\nreturn __machine__findnew_thread(machine, pid, tid, true);\r\n}\r\nstruct thread *machine__find_thread(struct machine *machine, pid_t pid,\r\npid_t tid)\r\n{\r\nreturn __machine__findnew_thread(machine, pid, tid, false);\r\n}\r\nstruct comm *machine__thread_exec_comm(struct machine *machine,\r\nstruct thread *thread)\r\n{\r\nif (machine->comm_exec)\r\nreturn thread__exec_comm(thread);\r\nelse\r\nreturn thread__comm(thread);\r\n}\r\nint machine__process_comm_event(struct machine *machine, union perf_event *event,\r\nstruct perf_sample *sample)\r\n{\r\nstruct thread *thread = machine__findnew_thread(machine,\r\nevent->comm.pid,\r\nevent->comm.tid);\r\nbool exec = event->header.misc & PERF_RECORD_MISC_COMM_EXEC;\r\nif (exec)\r\nmachine->comm_exec = true;\r\nif (dump_trace)\r\nperf_event__fprintf_comm(event, stdout);\r\nif (thread == NULL ||\r\n__thread__set_comm(thread, event->comm.comm, sample->time, exec)) {\r\ndump_printf("problem processing PERF_RECORD_COMM, skipping event.\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint machine__process_lost_event(struct machine *machine __maybe_unused,\r\nunion perf_event *event, struct perf_sample *sample __maybe_unused)\r\n{\r\ndump_printf(": id:%" PRIu64 ": lost:%" PRIu64 "\n",\r\nevent->lost.id, event->lost.lost);\r\nreturn 0;\r\n}\r\nstruct map *machine__new_module(struct machine *machine, u64 start,\r\nconst char *filename)\r\n{\r\nstruct map *map;\r\nstruct dso *dso = __dsos__findnew(&machine->kernel_dsos, filename);\r\nbool compressed;\r\nif (dso == NULL)\r\nreturn NULL;\r\nmap = map__new2(start, dso, MAP__FUNCTION);\r\nif (map == NULL)\r\nreturn NULL;\r\nif (machine__is_host(machine))\r\ndso->symtab_type = DSO_BINARY_TYPE__SYSTEM_PATH_KMODULE;\r\nelse\r\ndso->symtab_type = DSO_BINARY_TYPE__GUEST_KMODULE;\r\nif (is_kernel_module(filename, &compressed) && compressed)\r\ndso->symtab_type++;\r\nmap_groups__insert(&machine->kmaps, map);\r\nreturn map;\r\n}\r\nsize_t machines__fprintf_dsos(struct machines *machines, FILE *fp)\r\n{\r\nstruct rb_node *nd;\r\nsize_t ret = __dsos__fprintf(&machines->host.kernel_dsos.head, fp) +\r\n__dsos__fprintf(&machines->host.user_dsos.head, fp);\r\nfor (nd = rb_first(&machines->guests); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nret += __dsos__fprintf(&pos->kernel_dsos.head, fp);\r\nret += __dsos__fprintf(&pos->user_dsos.head, fp);\r\n}\r\nreturn ret;\r\n}\r\nsize_t machine__fprintf_dsos_buildid(struct machine *m, FILE *fp,\r\nbool (skip)(struct dso *dso, int parm), int parm)\r\n{\r\nreturn __dsos__fprintf_buildid(&m->kernel_dsos.head, fp, skip, parm) +\r\n__dsos__fprintf_buildid(&m->user_dsos.head, fp, skip, parm);\r\n}\r\nsize_t machines__fprintf_dsos_buildid(struct machines *machines, FILE *fp,\r\nbool (skip)(struct dso *dso, int parm), int parm)\r\n{\r\nstruct rb_node *nd;\r\nsize_t ret = machine__fprintf_dsos_buildid(&machines->host, fp, skip, parm);\r\nfor (nd = rb_first(&machines->guests); nd; nd = rb_next(nd)) {\r\nstruct machine *pos = rb_entry(nd, struct machine, rb_node);\r\nret += machine__fprintf_dsos_buildid(pos, fp, skip, parm);\r\n}\r\nreturn ret;\r\n}\r\nsize_t machine__fprintf_vmlinux_path(struct machine *machine, FILE *fp)\r\n{\r\nint i;\r\nsize_t printed = 0;\r\nstruct dso *kdso = machine->vmlinux_maps[MAP__FUNCTION]->dso;\r\nif (kdso->has_build_id) {\r\nchar filename[PATH_MAX];\r\nif (dso__build_id_filename(kdso, filename, sizeof(filename)))\r\nprinted += fprintf(fp, "[0] %s\n", filename);\r\n}\r\nfor (i = 0; i < vmlinux_path__nr_entries; ++i)\r\nprinted += fprintf(fp, "[%d] %s\n",\r\ni + kdso->has_build_id, vmlinux_path[i]);\r\nreturn printed;\r\n}\r\nsize_t machine__fprintf(struct machine *machine, FILE *fp)\r\n{\r\nsize_t ret = 0;\r\nstruct rb_node *nd;\r\nfor (nd = rb_first(&machine->threads); nd; nd = rb_next(nd)) {\r\nstruct thread *pos = rb_entry(nd, struct thread, rb_node);\r\nret += thread__fprintf(pos, fp);\r\n}\r\nreturn ret;\r\n}\r\nstatic struct dso *machine__get_kernel(struct machine *machine)\r\n{\r\nconst char *vmlinux_name = NULL;\r\nstruct dso *kernel;\r\nif (machine__is_host(machine)) {\r\nvmlinux_name = symbol_conf.vmlinux_name;\r\nif (!vmlinux_name)\r\nvmlinux_name = "[kernel.kallsyms]";\r\nkernel = dso__kernel_findnew(machine, vmlinux_name,\r\n"[kernel]",\r\nDSO_TYPE_KERNEL);\r\n} else {\r\nchar bf[PATH_MAX];\r\nif (machine__is_default_guest(machine))\r\nvmlinux_name = symbol_conf.default_guest_vmlinux_name;\r\nif (!vmlinux_name)\r\nvmlinux_name = machine__mmap_name(machine, bf,\r\nsizeof(bf));\r\nkernel = dso__kernel_findnew(machine, vmlinux_name,\r\n"[guest.kernel]",\r\nDSO_TYPE_GUEST_KERNEL);\r\n}\r\nif (kernel != NULL && (!kernel->has_build_id))\r\ndso__read_running_kernel_build_id(kernel, machine);\r\nreturn kernel;\r\n}\r\nstatic void machine__get_kallsyms_filename(struct machine *machine, char *buf,\r\nsize_t bufsz)\r\n{\r\nif (machine__is_default_guest(machine))\r\nscnprintf(buf, bufsz, "%s", symbol_conf.default_guest_kallsyms);\r\nelse\r\nscnprintf(buf, bufsz, "%s/proc/kallsyms", machine->root_dir);\r\n}\r\nstatic u64 machine__get_running_kernel_start(struct machine *machine,\r\nconst char **symbol_name)\r\n{\r\nchar filename[PATH_MAX];\r\nint i;\r\nconst char *name;\r\nu64 addr = 0;\r\nmachine__get_kallsyms_filename(machine, filename, PATH_MAX);\r\nif (symbol__restricted_filename(filename, "/proc/kallsyms"))\r\nreturn 0;\r\nfor (i = 0; (name = ref_reloc_sym_names[i]) != NULL; i++) {\r\naddr = kallsyms__get_function_start(filename, name);\r\nif (addr)\r\nbreak;\r\n}\r\nif (symbol_name)\r\n*symbol_name = name;\r\nreturn addr;\r\n}\r\nint __machine__create_kernel_maps(struct machine *machine, struct dso *kernel)\r\n{\r\nenum map_type type;\r\nu64 start = machine__get_running_kernel_start(machine, NULL);\r\nfor (type = 0; type < MAP__NR_TYPES; ++type) {\r\nstruct kmap *kmap;\r\nmachine->vmlinux_maps[type] = map__new2(start, kernel, type);\r\nif (machine->vmlinux_maps[type] == NULL)\r\nreturn -1;\r\nmachine->vmlinux_maps[type]->map_ip =\r\nmachine->vmlinux_maps[type]->unmap_ip =\r\nidentity__map_ip;\r\nkmap = map__kmap(machine->vmlinux_maps[type]);\r\nkmap->kmaps = &machine->kmaps;\r\nmap_groups__insert(&machine->kmaps,\r\nmachine->vmlinux_maps[type]);\r\n}\r\nreturn 0;\r\n}\r\nvoid machine__destroy_kernel_maps(struct machine *machine)\r\n{\r\nenum map_type type;\r\nfor (type = 0; type < MAP__NR_TYPES; ++type) {\r\nstruct kmap *kmap;\r\nif (machine->vmlinux_maps[type] == NULL)\r\ncontinue;\r\nkmap = map__kmap(machine->vmlinux_maps[type]);\r\nmap_groups__remove(&machine->kmaps,\r\nmachine->vmlinux_maps[type]);\r\nif (kmap->ref_reloc_sym) {\r\nif (type == MAP__FUNCTION) {\r\nzfree((char **)&kmap->ref_reloc_sym->name);\r\nzfree(&kmap->ref_reloc_sym);\r\n} else\r\nkmap->ref_reloc_sym = NULL;\r\n}\r\nmap__delete(machine->vmlinux_maps[type]);\r\nmachine->vmlinux_maps[type] = NULL;\r\n}\r\n}\r\nint machines__create_guest_kernel_maps(struct machines *machines)\r\n{\r\nint ret = 0;\r\nstruct dirent **namelist = NULL;\r\nint i, items = 0;\r\nchar path[PATH_MAX];\r\npid_t pid;\r\nchar *endp;\r\nif (symbol_conf.default_guest_vmlinux_name ||\r\nsymbol_conf.default_guest_modules ||\r\nsymbol_conf.default_guest_kallsyms) {\r\nmachines__create_kernel_maps(machines, DEFAULT_GUEST_KERNEL_ID);\r\n}\r\nif (symbol_conf.guestmount) {\r\nitems = scandir(symbol_conf.guestmount, &namelist, NULL, NULL);\r\nif (items <= 0)\r\nreturn -ENOENT;\r\nfor (i = 0; i < items; i++) {\r\nif (!isdigit(namelist[i]->d_name[0])) {\r\ncontinue;\r\n}\r\npid = (pid_t)strtol(namelist[i]->d_name, &endp, 10);\r\nif ((*endp != '\0') ||\r\n(endp == namelist[i]->d_name) ||\r\n(errno == ERANGE)) {\r\npr_debug("invalid directory (%s). Skipping.\n",\r\nnamelist[i]->d_name);\r\ncontinue;\r\n}\r\nsprintf(path, "%s/%s/proc/kallsyms",\r\nsymbol_conf.guestmount,\r\nnamelist[i]->d_name);\r\nret = access(path, R_OK);\r\nif (ret) {\r\npr_debug("Can't access file %s\n", path);\r\ngoto failure;\r\n}\r\nmachines__create_kernel_maps(machines, pid);\r\n}\r\nfailure:\r\nfree(namelist);\r\n}\r\nreturn ret;\r\n}\r\nvoid machines__destroy_kernel_maps(struct machines *machines)\r\n{\r\nstruct rb_node *next = rb_first(&machines->guests);\r\nmachine__destroy_kernel_maps(&machines->host);\r\nwhile (next) {\r\nstruct machine *pos = rb_entry(next, struct machine, rb_node);\r\nnext = rb_next(&pos->rb_node);\r\nrb_erase(&pos->rb_node, &machines->guests);\r\nmachine__delete(pos);\r\n}\r\n}\r\nint machines__create_kernel_maps(struct machines *machines, pid_t pid)\r\n{\r\nstruct machine *machine = machines__findnew(machines, pid);\r\nif (machine == NULL)\r\nreturn -1;\r\nreturn machine__create_kernel_maps(machine);\r\n}\r\nint machine__load_kallsyms(struct machine *machine, const char *filename,\r\nenum map_type type, symbol_filter_t filter)\r\n{\r\nstruct map *map = machine->vmlinux_maps[type];\r\nint ret = dso__load_kallsyms(map->dso, filename, map, filter);\r\nif (ret > 0) {\r\ndso__set_loaded(map->dso, type);\r\n__map_groups__fixup_end(&machine->kmaps, type);\r\n}\r\nreturn ret;\r\n}\r\nint machine__load_vmlinux_path(struct machine *machine, enum map_type type,\r\nsymbol_filter_t filter)\r\n{\r\nstruct map *map = machine->vmlinux_maps[type];\r\nint ret = dso__load_vmlinux_path(map->dso, map, filter);\r\nif (ret > 0)\r\ndso__set_loaded(map->dso, type);\r\nreturn ret;\r\n}\r\nstatic void map_groups__fixup_end(struct map_groups *mg)\r\n{\r\nint i;\r\nfor (i = 0; i < MAP__NR_TYPES; ++i)\r\n__map_groups__fixup_end(mg, i);\r\n}\r\nstatic char *get_kernel_version(const char *root_dir)\r\n{\r\nchar version[PATH_MAX];\r\nFILE *file;\r\nchar *name, *tmp;\r\nconst char *prefix = "Linux version ";\r\nsprintf(version, "%s/proc/version", root_dir);\r\nfile = fopen(version, "r");\r\nif (!file)\r\nreturn NULL;\r\nversion[0] = '\0';\r\ntmp = fgets(version, sizeof(version), file);\r\nfclose(file);\r\nname = strstr(version, prefix);\r\nif (!name)\r\nreturn NULL;\r\nname += strlen(prefix);\r\ntmp = strchr(name, ' ');\r\nif (tmp)\r\n*tmp = '\0';\r\nreturn strdup(name);\r\n}\r\nstatic int map_groups__set_modules_path_dir(struct map_groups *mg,\r\nconst char *dir_name, int depth)\r\n{\r\nstruct dirent *dent;\r\nDIR *dir = opendir(dir_name);\r\nint ret = 0;\r\nif (!dir) {\r\npr_debug("%s: cannot open %s dir\n", __func__, dir_name);\r\nreturn -1;\r\n}\r\nwhile ((dent = readdir(dir)) != NULL) {\r\nchar path[PATH_MAX];\r\nstruct stat st;\r\nsnprintf(path, sizeof(path), "%s/%s", dir_name, dent->d_name);\r\nif (stat(path, &st))\r\ncontinue;\r\nif (S_ISDIR(st.st_mode)) {\r\nif (!strcmp(dent->d_name, ".") ||\r\n!strcmp(dent->d_name, ".."))\r\ncontinue;\r\nif (depth == 0) {\r\nif (!strcmp(dent->d_name, "source") ||\r\n!strcmp(dent->d_name, "build"))\r\ncontinue;\r\n}\r\nret = map_groups__set_modules_path_dir(mg, path,\r\ndepth + 1);\r\nif (ret < 0)\r\ngoto out;\r\n} else {\r\nchar *dot = strrchr(dent->d_name, '.'),\r\ndso_name[PATH_MAX];\r\nstruct map *map;\r\nchar *long_name;\r\nif (dot == NULL)\r\ncontinue;\r\nif (is_supported_compression(dot + 1) &&\r\nis_kmodule_extension(dot - 2))\r\ndot -= 3;\r\nsnprintf(dso_name, sizeof(dso_name), "[%.*s]",\r\n(int)(dot - dent->d_name), dent->d_name);\r\nstrxfrchar(dso_name, '-', '_');\r\nmap = map_groups__find_by_name(mg, MAP__FUNCTION,\r\ndso_name);\r\nif (map == NULL)\r\ncontinue;\r\nlong_name = strdup(path);\r\nif (long_name == NULL) {\r\nret = -1;\r\ngoto out;\r\n}\r\ndso__set_long_name(map->dso, long_name, true);\r\ndso__kernel_module_get_build_id(map->dso, "");\r\n}\r\n}\r\nout:\r\nclosedir(dir);\r\nreturn ret;\r\n}\r\nstatic int machine__set_modules_path(struct machine *machine)\r\n{\r\nchar *version;\r\nchar modules_path[PATH_MAX];\r\nversion = get_kernel_version(machine->root_dir);\r\nif (!version)\r\nreturn -1;\r\nsnprintf(modules_path, sizeof(modules_path), "%s/lib/modules/%s",\r\nmachine->root_dir, version);\r\nfree(version);\r\nreturn map_groups__set_modules_path_dir(&machine->kmaps, modules_path, 0);\r\n}\r\nstatic int machine__create_module(void *arg, const char *name, u64 start)\r\n{\r\nstruct machine *machine = arg;\r\nstruct map *map;\r\nmap = machine__new_module(machine, start, name);\r\nif (map == NULL)\r\nreturn -1;\r\ndso__kernel_module_get_build_id(map->dso, machine->root_dir);\r\nreturn 0;\r\n}\r\nstatic int machine__create_modules(struct machine *machine)\r\n{\r\nconst char *modules;\r\nchar path[PATH_MAX];\r\nif (machine__is_default_guest(machine)) {\r\nmodules = symbol_conf.default_guest_modules;\r\n} else {\r\nsnprintf(path, PATH_MAX, "%s/proc/modules", machine->root_dir);\r\nmodules = path;\r\n}\r\nif (symbol__restricted_filename(modules, "/proc/modules"))\r\nreturn -1;\r\nif (modules__parse(modules, machine, machine__create_module))\r\nreturn -1;\r\nif (!machine__set_modules_path(machine))\r\nreturn 0;\r\npr_debug("Problems setting modules path maps, continuing anyway...\n");\r\nreturn 0;\r\n}\r\nint machine__create_kernel_maps(struct machine *machine)\r\n{\r\nstruct dso *kernel = machine__get_kernel(machine);\r\nconst char *name;\r\nu64 addr = machine__get_running_kernel_start(machine, &name);\r\nif (!addr)\r\nreturn -1;\r\nif (kernel == NULL ||\r\n__machine__create_kernel_maps(machine, kernel) < 0)\r\nreturn -1;\r\nif (symbol_conf.use_modules && machine__create_modules(machine) < 0) {\r\nif (machine__is_host(machine))\r\npr_debug("Problems creating module maps, "\r\n"continuing anyway...\n");\r\nelse\r\npr_debug("Problems creating module maps for guest %d, "\r\n"continuing anyway...\n", machine->pid);\r\n}\r\nmap_groups__fixup_end(&machine->kmaps);\r\nif (maps__set_kallsyms_ref_reloc_sym(machine->vmlinux_maps, name,\r\naddr)) {\r\nmachine__destroy_kernel_maps(machine);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void machine__set_kernel_mmap_len(struct machine *machine,\r\nunion perf_event *event)\r\n{\r\nint i;\r\nfor (i = 0; i < MAP__NR_TYPES; i++) {\r\nmachine->vmlinux_maps[i]->start = event->mmap.start;\r\nmachine->vmlinux_maps[i]->end = (event->mmap.start +\r\nevent->mmap.len);\r\nif (machine->vmlinux_maps[i]->end == 0)\r\nmachine->vmlinux_maps[i]->end = ~0ULL;\r\n}\r\n}\r\nstatic bool machine__uses_kcore(struct machine *machine)\r\n{\r\nstruct dso *dso;\r\nlist_for_each_entry(dso, &machine->kernel_dsos.head, node) {\r\nif (dso__is_kcore(dso))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int machine__process_kernel_mmap_event(struct machine *machine,\r\nunion perf_event *event)\r\n{\r\nstruct map *map;\r\nchar kmmap_prefix[PATH_MAX];\r\nenum dso_kernel_type kernel_type;\r\nbool is_kernel_mmap;\r\nif (machine__uses_kcore(machine))\r\nreturn 0;\r\nmachine__mmap_name(machine, kmmap_prefix, sizeof(kmmap_prefix));\r\nif (machine__is_host(machine))\r\nkernel_type = DSO_TYPE_KERNEL;\r\nelse\r\nkernel_type = DSO_TYPE_GUEST_KERNEL;\r\nis_kernel_mmap = memcmp(event->mmap.filename,\r\nkmmap_prefix,\r\nstrlen(kmmap_prefix) - 1) == 0;\r\nif (event->mmap.filename[0] == '/' ||\r\n(!is_kernel_mmap && event->mmap.filename[0] == '[')) {\r\nchar short_module_name[1024];\r\nchar *name, *dot;\r\nif (event->mmap.filename[0] == '/') {\r\nname = strrchr(event->mmap.filename, '/');\r\nif (name == NULL)\r\ngoto out_problem;\r\n++name;\r\ndot = strrchr(name, '.');\r\nif (dot == NULL)\r\ngoto out_problem;\r\nif (is_supported_compression(dot + 1))\r\ndot -= 3;\r\nif (!is_kmodule_extension(dot + 1))\r\ngoto out_problem;\r\nsnprintf(short_module_name, sizeof(short_module_name),\r\n"[%.*s]", (int)(dot - name), name);\r\nstrxfrchar(short_module_name, '-', '_');\r\n} else\r\nstrcpy(short_module_name, event->mmap.filename);\r\nmap = machine__new_module(machine, event->mmap.start,\r\nevent->mmap.filename);\r\nif (map == NULL)\r\ngoto out_problem;\r\nname = strdup(short_module_name);\r\nif (name == NULL)\r\ngoto out_problem;\r\ndso__set_short_name(map->dso, name, true);\r\nmap->end = map->start + event->mmap.len;\r\n} else if (is_kernel_mmap) {\r\nconst char *symbol_name = (event->mmap.filename +\r\nstrlen(kmmap_prefix));\r\nstruct dso *kernel = NULL;\r\nstruct dso *dso;\r\nlist_for_each_entry(dso, &machine->kernel_dsos.head, node) {\r\nif (is_kernel_module(dso->long_name, NULL))\r\ncontinue;\r\nkernel = dso;\r\nbreak;\r\n}\r\nif (kernel == NULL)\r\nkernel = __dsos__findnew(&machine->kernel_dsos,\r\nkmmap_prefix);\r\nif (kernel == NULL)\r\ngoto out_problem;\r\nkernel->kernel = kernel_type;\r\nif (__machine__create_kernel_maps(machine, kernel) < 0)\r\ngoto out_problem;\r\nif (strstr(kernel->long_name, "vmlinux"))\r\ndso__set_short_name(kernel, "[kernel.vmlinux]", false);\r\nmachine__set_kernel_mmap_len(machine, event);\r\nif (event->mmap.pgoff != 0) {\r\nmaps__set_kallsyms_ref_reloc_sym(machine->vmlinux_maps,\r\nsymbol_name,\r\nevent->mmap.pgoff);\r\n}\r\nif (machine__is_default_guest(machine)) {\r\ndso__load(kernel, machine->vmlinux_maps[MAP__FUNCTION],\r\nNULL);\r\n}\r\n}\r\nreturn 0;\r\nout_problem:\r\nreturn -1;\r\n}\r\nint machine__process_mmap2_event(struct machine *machine,\r\nunion perf_event *event,\r\nstruct perf_sample *sample __maybe_unused)\r\n{\r\nu8 cpumode = event->header.misc & PERF_RECORD_MISC_CPUMODE_MASK;\r\nstruct thread *thread;\r\nstruct map *map;\r\nenum map_type type;\r\nint ret = 0;\r\nif (dump_trace)\r\nperf_event__fprintf_mmap2(event, stdout);\r\nif (cpumode == PERF_RECORD_MISC_GUEST_KERNEL ||\r\ncpumode == PERF_RECORD_MISC_KERNEL) {\r\nret = machine__process_kernel_mmap_event(machine, event);\r\nif (ret < 0)\r\ngoto out_problem;\r\nreturn 0;\r\n}\r\nthread = machine__findnew_thread(machine, event->mmap2.pid,\r\nevent->mmap2.tid);\r\nif (thread == NULL)\r\ngoto out_problem;\r\nif (event->header.misc & PERF_RECORD_MISC_MMAP_DATA)\r\ntype = MAP__VARIABLE;\r\nelse\r\ntype = MAP__FUNCTION;\r\nmap = map__new(machine, event->mmap2.start,\r\nevent->mmap2.len, event->mmap2.pgoff,\r\nevent->mmap2.pid, event->mmap2.maj,\r\nevent->mmap2.min, event->mmap2.ino,\r\nevent->mmap2.ino_generation,\r\nevent->mmap2.prot,\r\nevent->mmap2.flags,\r\nevent->mmap2.filename, type, thread);\r\nif (map == NULL)\r\ngoto out_problem;\r\nthread__insert_map(thread, map);\r\nreturn 0;\r\nout_problem:\r\ndump_printf("problem processing PERF_RECORD_MMAP2, skipping event.\n");\r\nreturn 0;\r\n}\r\nint machine__process_mmap_event(struct machine *machine, union perf_event *event,\r\nstruct perf_sample *sample __maybe_unused)\r\n{\r\nu8 cpumode = event->header.misc & PERF_RECORD_MISC_CPUMODE_MASK;\r\nstruct thread *thread;\r\nstruct map *map;\r\nenum map_type type;\r\nint ret = 0;\r\nif (dump_trace)\r\nperf_event__fprintf_mmap(event, stdout);\r\nif (cpumode == PERF_RECORD_MISC_GUEST_KERNEL ||\r\ncpumode == PERF_RECORD_MISC_KERNEL) {\r\nret = machine__process_kernel_mmap_event(machine, event);\r\nif (ret < 0)\r\ngoto out_problem;\r\nreturn 0;\r\n}\r\nthread = machine__findnew_thread(machine, event->mmap.pid,\r\nevent->mmap.tid);\r\nif (thread == NULL)\r\ngoto out_problem;\r\nif (event->header.misc & PERF_RECORD_MISC_MMAP_DATA)\r\ntype = MAP__VARIABLE;\r\nelse\r\ntype = MAP__FUNCTION;\r\nmap = map__new(machine, event->mmap.start,\r\nevent->mmap.len, event->mmap.pgoff,\r\nevent->mmap.pid, 0, 0, 0, 0, 0, 0,\r\nevent->mmap.filename,\r\ntype, thread);\r\nif (map == NULL)\r\ngoto out_problem;\r\nthread__insert_map(thread, map);\r\nreturn 0;\r\nout_problem:\r\ndump_printf("problem processing PERF_RECORD_MMAP, skipping event.\n");\r\nreturn 0;\r\n}\r\nstatic void machine__remove_thread(struct machine *machine, struct thread *th)\r\n{\r\nmachine->last_match = NULL;\r\nrb_erase(&th->rb_node, &machine->threads);\r\nlist_add_tail(&th->node, &machine->dead_threads);\r\n}\r\nint machine__process_fork_event(struct machine *machine, union perf_event *event,\r\nstruct perf_sample *sample)\r\n{\r\nstruct thread *thread = machine__find_thread(machine,\r\nevent->fork.pid,\r\nevent->fork.tid);\r\nstruct thread *parent = machine__findnew_thread(machine,\r\nevent->fork.ppid,\r\nevent->fork.ptid);\r\nif (thread != NULL)\r\nmachine__remove_thread(machine, thread);\r\nthread = machine__findnew_thread(machine, event->fork.pid,\r\nevent->fork.tid);\r\nif (dump_trace)\r\nperf_event__fprintf_task(event, stdout);\r\nif (thread == NULL || parent == NULL ||\r\nthread__fork(thread, parent, sample->time) < 0) {\r\ndump_printf("problem processing PERF_RECORD_FORK, skipping event.\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint machine__process_exit_event(struct machine *machine, union perf_event *event,\r\nstruct perf_sample *sample __maybe_unused)\r\n{\r\nstruct thread *thread = machine__find_thread(machine,\r\nevent->fork.pid,\r\nevent->fork.tid);\r\nif (dump_trace)\r\nperf_event__fprintf_task(event, stdout);\r\nif (thread != NULL)\r\nthread__exited(thread);\r\nreturn 0;\r\n}\r\nint machine__process_event(struct machine *machine, union perf_event *event,\r\nstruct perf_sample *sample)\r\n{\r\nint ret;\r\nswitch (event->header.type) {\r\ncase PERF_RECORD_COMM:\r\nret = machine__process_comm_event(machine, event, sample); break;\r\ncase PERF_RECORD_MMAP:\r\nret = machine__process_mmap_event(machine, event, sample); break;\r\ncase PERF_RECORD_MMAP2:\r\nret = machine__process_mmap2_event(machine, event, sample); break;\r\ncase PERF_RECORD_FORK:\r\nret = machine__process_fork_event(machine, event, sample); break;\r\ncase PERF_RECORD_EXIT:\r\nret = machine__process_exit_event(machine, event, sample); break;\r\ncase PERF_RECORD_LOST:\r\nret = machine__process_lost_event(machine, event, sample); break;\r\ndefault:\r\nret = -1;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool symbol__match_regex(struct symbol *sym, regex_t *regex)\r\n{\r\nif (sym->name && !regexec(regex, sym->name, 0, NULL, 0))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void ip__resolve_ams(struct thread *thread,\r\nstruct addr_map_symbol *ams,\r\nu64 ip)\r\n{\r\nstruct addr_location al;\r\nmemset(&al, 0, sizeof(al));\r\nthread__find_cpumode_addr_location(thread, MAP__FUNCTION, ip, &al);\r\nams->addr = ip;\r\nams->al_addr = al.addr;\r\nams->sym = al.sym;\r\nams->map = al.map;\r\n}\r\nstatic void ip__resolve_data(struct thread *thread,\r\nu8 m, struct addr_map_symbol *ams, u64 addr)\r\n{\r\nstruct addr_location al;\r\nmemset(&al, 0, sizeof(al));\r\nthread__find_addr_location(thread, m, MAP__VARIABLE, addr, &al);\r\nif (al.map == NULL) {\r\nthread__find_addr_location(thread, m, MAP__FUNCTION, addr, &al);\r\n}\r\nams->addr = addr;\r\nams->al_addr = al.addr;\r\nams->sym = al.sym;\r\nams->map = al.map;\r\n}\r\nstruct mem_info *sample__resolve_mem(struct perf_sample *sample,\r\nstruct addr_location *al)\r\n{\r\nstruct mem_info *mi = zalloc(sizeof(*mi));\r\nif (!mi)\r\nreturn NULL;\r\nip__resolve_ams(al->thread, &mi->iaddr, sample->ip);\r\nip__resolve_data(al->thread, al->cpumode, &mi->daddr, sample->addr);\r\nmi->data_src.val = sample->data_src;\r\nreturn mi;\r\n}\r\nstatic int add_callchain_ip(struct thread *thread,\r\nstruct symbol **parent,\r\nstruct addr_location *root_al,\r\nbool branch_history,\r\nu64 ip)\r\n{\r\nstruct addr_location al;\r\nal.filtered = 0;\r\nal.sym = NULL;\r\nif (branch_history)\r\nthread__find_cpumode_addr_location(thread, MAP__FUNCTION,\r\nip, &al);\r\nelse {\r\nu8 cpumode = PERF_RECORD_MISC_USER;\r\nif (ip >= PERF_CONTEXT_MAX) {\r\nswitch (ip) {\r\ncase PERF_CONTEXT_HV:\r\ncpumode = PERF_RECORD_MISC_HYPERVISOR;\r\nbreak;\r\ncase PERF_CONTEXT_KERNEL:\r\ncpumode = PERF_RECORD_MISC_KERNEL;\r\nbreak;\r\ncase PERF_CONTEXT_USER:\r\ncpumode = PERF_RECORD_MISC_USER;\r\nbreak;\r\ndefault:\r\npr_debug("invalid callchain context: "\r\n"%"PRId64"\n", (s64) ip);\r\ncallchain_cursor_reset(&callchain_cursor);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nthread__find_addr_location(thread, cpumode, MAP__FUNCTION,\r\nip, &al);\r\n}\r\nif (al.sym != NULL) {\r\nif (sort__has_parent && !*parent &&\r\nsymbol__match_regex(al.sym, &parent_regex))\r\n*parent = al.sym;\r\nelse if (have_ignore_callees && root_al &&\r\nsymbol__match_regex(al.sym, &ignore_callees_regex)) {\r\n*root_al = al;\r\ncallchain_cursor_reset(&callchain_cursor);\r\n}\r\n}\r\nreturn callchain_cursor_append(&callchain_cursor, al.addr, al.map, al.sym);\r\n}\r\nstruct branch_info *sample__resolve_bstack(struct perf_sample *sample,\r\nstruct addr_location *al)\r\n{\r\nunsigned int i;\r\nconst struct branch_stack *bs = sample->branch_stack;\r\nstruct branch_info *bi = calloc(bs->nr, sizeof(struct branch_info));\r\nif (!bi)\r\nreturn NULL;\r\nfor (i = 0; i < bs->nr; i++) {\r\nip__resolve_ams(al->thread, &bi[i].to, bs->entries[i].to);\r\nip__resolve_ams(al->thread, &bi[i].from, bs->entries[i].from);\r\nbi[i].flags = bs->entries[i].flags;\r\n}\r\nreturn bi;\r\n}\r\nstatic int remove_loops(struct branch_entry *l, int nr)\r\n{\r\nint i, j, off;\r\nunsigned char chash[CHASHSZ];\r\nmemset(chash, NO_ENTRY, sizeof(chash));\r\nBUG_ON(PERF_MAX_BRANCH_DEPTH > 255);\r\nfor (i = 0; i < nr; i++) {\r\nint h = hash_64(l[i].from, CHASHBITS) % CHASHSZ;\r\nif (chash[h] == NO_ENTRY) {\r\nchash[h] = i;\r\n} else if (l[chash[h]].from == l[i].from) {\r\nbool is_loop = true;\r\noff = 0;\r\nfor (j = chash[h]; j < i && i + off < nr; j++, off++)\r\nif (l[j].from != l[i + off].from) {\r\nis_loop = false;\r\nbreak;\r\n}\r\nif (is_loop) {\r\nmemmove(l + i, l + i + off,\r\n(nr - (i + off)) * sizeof(*l));\r\nnr -= off;\r\n}\r\n}\r\n}\r\nreturn nr;\r\n}\r\nstatic int thread__resolve_callchain_sample(struct thread *thread,\r\nstruct ip_callchain *chain,\r\nstruct branch_stack *branch,\r\nstruct symbol **parent,\r\nstruct addr_location *root_al,\r\nint max_stack)\r\n{\r\nint chain_nr = min(max_stack, (int)chain->nr);\r\nint i, j, err;\r\nint skip_idx = -1;\r\nint first_call = 0;\r\nif (chain->nr < PERF_MAX_STACK_DEPTH)\r\nskip_idx = arch_skip_callchain_idx(thread, chain);\r\ncallchain_cursor_reset(&callchain_cursor);\r\nif (branch && callchain_param.branch_callstack) {\r\nint nr = min(max_stack, (int)branch->nr);\r\nstruct branch_entry be[nr];\r\nif (branch->nr > PERF_MAX_BRANCH_DEPTH) {\r\npr_warning("corrupted branch chain. skipping...\n");\r\ngoto check_calls;\r\n}\r\nfor (i = 0; i < nr; i++) {\r\nif (callchain_param.order == ORDER_CALLEE) {\r\nbe[i] = branch->entries[i];\r\nif (i == skip_idx ||\r\nchain->ips[first_call] >= PERF_CONTEXT_MAX)\r\nfirst_call++;\r\nelse if (be[i].from < chain->ips[first_call] &&\r\nbe[i].from >= chain->ips[first_call] - 8)\r\nfirst_call++;\r\n} else\r\nbe[i] = branch->entries[branch->nr - i - 1];\r\n}\r\nnr = remove_loops(be, nr);\r\nfor (i = 0; i < nr; i++) {\r\nerr = add_callchain_ip(thread, parent, root_al,\r\ntrue, be[i].to);\r\nif (!err)\r\nerr = add_callchain_ip(thread, parent, root_al,\r\ntrue, be[i].from);\r\nif (err == -EINVAL)\r\nbreak;\r\nif (err)\r\nreturn err;\r\n}\r\nchain_nr -= nr;\r\n}\r\ncheck_calls:\r\nif (chain->nr > PERF_MAX_STACK_DEPTH) {\r\npr_warning("corrupted callchain. skipping...\n");\r\nreturn 0;\r\n}\r\nfor (i = first_call; i < chain_nr; i++) {\r\nu64 ip;\r\nif (callchain_param.order == ORDER_CALLEE)\r\nj = i;\r\nelse\r\nj = chain->nr - i - 1;\r\n#ifdef HAVE_SKIP_CALLCHAIN_IDX\r\nif (j == skip_idx)\r\ncontinue;\r\n#endif\r\nip = chain->ips[j];\r\nerr = add_callchain_ip(thread, parent, root_al, false, ip);\r\nif (err)\r\nreturn (err < 0) ? err : 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int unwind_entry(struct unwind_entry *entry, void *arg)\r\n{\r\nstruct callchain_cursor *cursor = arg;\r\nreturn callchain_cursor_append(cursor, entry->ip,\r\nentry->map, entry->sym);\r\n}\r\nint thread__resolve_callchain(struct thread *thread,\r\nstruct perf_evsel *evsel,\r\nstruct perf_sample *sample,\r\nstruct symbol **parent,\r\nstruct addr_location *root_al,\r\nint max_stack)\r\n{\r\nint ret = thread__resolve_callchain_sample(thread, sample->callchain,\r\nsample->branch_stack,\r\nparent, root_al, max_stack);\r\nif (ret)\r\nreturn ret;\r\nif (!((evsel->attr.sample_type & PERF_SAMPLE_REGS_USER) &&\r\n(evsel->attr.sample_type & PERF_SAMPLE_STACK_USER)))\r\nreturn 0;\r\nif ((!sample->user_regs.regs) ||\r\n(!sample->user_stack.size))\r\nreturn 0;\r\nreturn unwind__get_entries(unwind_entry, &callchain_cursor,\r\nthread, sample, max_stack);\r\n}\r\nint machine__for_each_thread(struct machine *machine,\r\nint (*fn)(struct thread *thread, void *p),\r\nvoid *priv)\r\n{\r\nstruct rb_node *nd;\r\nstruct thread *thread;\r\nint rc = 0;\r\nfor (nd = rb_first(&machine->threads); nd; nd = rb_next(nd)) {\r\nthread = rb_entry(nd, struct thread, rb_node);\r\nrc = fn(thread, priv);\r\nif (rc != 0)\r\nreturn rc;\r\n}\r\nlist_for_each_entry(thread, &machine->dead_threads, node) {\r\nrc = fn(thread, priv);\r\nif (rc != 0)\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}\r\nint __machine__synthesize_threads(struct machine *machine, struct perf_tool *tool,\r\nstruct target *target, struct thread_map *threads,\r\nperf_event__handler_t process, bool data_mmap)\r\n{\r\nif (target__has_task(target))\r\nreturn perf_event__synthesize_thread_map(tool, threads, process, machine, data_mmap);\r\nelse if (target__has_cpu(target))\r\nreturn perf_event__synthesize_threads(tool, process, machine, data_mmap);\r\nreturn 0;\r\n}\r\npid_t machine__get_current_tid(struct machine *machine, int cpu)\r\n{\r\nif (cpu < 0 || cpu >= MAX_NR_CPUS || !machine->current_tid)\r\nreturn -1;\r\nreturn machine->current_tid[cpu];\r\n}\r\nint machine__set_current_tid(struct machine *machine, int cpu, pid_t pid,\r\npid_t tid)\r\n{\r\nstruct thread *thread;\r\nif (cpu < 0)\r\nreturn -EINVAL;\r\nif (!machine->current_tid) {\r\nint i;\r\nmachine->current_tid = calloc(MAX_NR_CPUS, sizeof(pid_t));\r\nif (!machine->current_tid)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < MAX_NR_CPUS; i++)\r\nmachine->current_tid[i] = -1;\r\n}\r\nif (cpu >= MAX_NR_CPUS) {\r\npr_err("Requested CPU %d too large. ", cpu);\r\npr_err("Consider raising MAX_NR_CPUS\n");\r\nreturn -EINVAL;\r\n}\r\nmachine->current_tid[cpu] = tid;\r\nthread = machine__findnew_thread(machine, pid, tid);\r\nif (!thread)\r\nreturn -ENOMEM;\r\nthread->cpu = cpu;\r\nreturn 0;\r\n}\r\nint machine__get_kernel_start(struct machine *machine)\r\n{\r\nstruct map *map = machine__kernel_map(machine, MAP__FUNCTION);\r\nint err = 0;\r\nmachine->kernel_start = 1ULL << 63;\r\nif (map) {\r\nerr = map__load(map, machine->symbol_filter);\r\nif (map->start)\r\nmachine->kernel_start = map->start;\r\n}\r\nreturn err;\r\n}
