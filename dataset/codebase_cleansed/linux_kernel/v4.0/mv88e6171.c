static char *mv88e6171_probe(struct device *host_dev, int sw_addr)\r\n{\r\nstruct mii_bus *bus = dsa_host_dev_to_mii_bus(host_dev);\r\nint ret;\r\nif (bus == NULL)\r\nreturn NULL;\r\nret = __mv88e6xxx_reg_read(bus, sw_addr, REG_PORT(0), 0x03);\r\nif (ret >= 0) {\r\nif ((ret & 0xfff0) == 0x1710)\r\nreturn "Marvell 88E6171";\r\nif ((ret & 0xfff0) == 0x1720)\r\nreturn "Marvell 88E6172";\r\n}\r\nreturn NULL;\r\n}\r\nstatic int mv88e6171_switch_reset(struct dsa_switch *ds)\r\n{\r\nint i;\r\nint ret;\r\nunsigned long timeout;\r\nfor (i = 0; i < 8; i++) {\r\nret = REG_READ(REG_PORT(i), 0x04);\r\nREG_WRITE(REG_PORT(i), 0x04, ret & 0xfffc);\r\n}\r\nusleep_range(2000, 4000);\r\nREG_WRITE(REG_GLOBAL, 0x04, 0xc400);\r\ntimeout = jiffies + 1 * HZ;\r\nwhile (time_before(jiffies, timeout)) {\r\nret = REG_READ(REG_GLOBAL, 0x00);\r\nif ((ret & 0xc800) == 0xc800)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\nfor (i = 0; i < 8; i++) {\r\nif (dsa_is_cpu_port(ds, i) || ds->phys_port_mask & (1 << i))\r\ncontinue;\r\nret = REG_READ(REG_PORT(i), 0x04);\r\nREG_WRITE(REG_PORT(i), 0x04, ret | 0x03);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mv88e6171_setup_global(struct dsa_switch *ds)\r\n{\r\nint ret;\r\nint i;\r\nREG_WRITE(REG_GLOBAL, 0x04, 0x0000);\r\nREG_WRITE(REG_GLOBAL, 0x0a, 0x0148);\r\nret = mv88e6xxx_config_prio(ds);\r\nif (ret < 0)\r\nreturn ret;\r\nif (REG_READ(REG_PORT(0), 0x03) == 0x1710)\r\nREG_WRITE(REG_GLOBAL, 0x1a, (dsa_upstream_port(ds) * 0x1111));\r\nelse\r\nREG_WRITE(REG_GLOBAL, 0x1a, (dsa_upstream_port(ds) * 0x1110));\r\nREG_WRITE(REG_GLOBAL, 0x1c, ds->index & 0x1f);\r\nREG_WRITE(REG_GLOBAL2, 0x02, 0xffff);\r\nREG_WRITE(REG_GLOBAL2, 0x03, 0xffff);\r\nREG_WRITE(REG_GLOBAL2, 0x05, 0x00ff);\r\nfor (i = 0; i < 32; i++) {\r\nint nexthop;\r\nnexthop = 0x1f;\r\nif (i != ds->index && i < ds->dst->pd->nr_chips)\r\nnexthop = ds->pd->rtable[i] & 0x1f;\r\nREG_WRITE(REG_GLOBAL2, 0x06, 0x8000 | (i << 8) | nexthop);\r\n}\r\nfor (i = 0; i < 8; i++)\r\nREG_WRITE(REG_GLOBAL2, 0x07, 0x8000 | (i << 12) | 0xff);\r\nfor (i = 0; i < 16; i++)\r\nREG_WRITE(REG_GLOBAL2, 0x08, 0x8000 | (i << 11));\r\nfor (i = 0; i < 6; i++)\r\nREG_WRITE(REG_GLOBAL2, 0x09, 0x9000 | (i << 8));\r\nREG_WRITE(REG_GLOBAL2, 0x0b, 0x9000);\r\nfor (i = 0; i < 16; i++)\r\nREG_WRITE(REG_GLOBAL2, 0x0f, 0x8000 | (i << 8));\r\nreturn 0;\r\n}\r\nstatic int mv88e6171_setup_port(struct dsa_switch *ds, int p)\r\n{\r\nint addr = REG_PORT(p);\r\nu16 val;\r\nval = REG_READ(addr, 0x01);\r\nif (dsa_is_cpu_port(ds, p) || ds->dsa_port_mask & (1 << p))\r\nREG_WRITE(addr, 0x01, val | 0x003e);\r\nelse\r\nREG_WRITE(addr, 0x01, val | 0x0003);\r\nREG_WRITE(addr, 0x02, 0x0000);\r\nval = 0x0433;\r\nif (dsa_is_cpu_port(ds, p)) {\r\nif (ds->dst->tag_protocol == DSA_TAG_PROTO_EDSA)\r\nval |= 0x3300;\r\nelse\r\nval |= 0x0100;\r\n}\r\nif (ds->dsa_port_mask & (1 << p))\r\nval |= 0x0100;\r\nif (p == dsa_upstream_port(ds))\r\nval |= 0x000c;\r\nREG_WRITE(addr, 0x04, val);\r\nREG_WRITE(addr, 0x05, dsa_is_cpu_port(ds, p) ? 0x8000 : 0x0000);\r\nval = (p & 0xf) << 12;\r\nif (dsa_is_cpu_port(ds, p))\r\nval |= ds->phys_port_mask;\r\nelse\r\nval |= 1 << dsa_upstream_port(ds);\r\nREG_WRITE(addr, 0x06, val);\r\nREG_WRITE(addr, 0x07, 0x0000);\r\nREG_WRITE(addr, 0x08, 0x2080);\r\nREG_WRITE(addr, 0x09, 0x0001);\r\nREG_WRITE(addr, 0x0a, 0x0000);\r\nREG_WRITE(addr, 0x0b, 1 << p);\r\nREG_WRITE(addr, 0x0c, 0x0000);\r\nREG_WRITE(addr, 0x0d, 0x0000);\r\nREG_WRITE(addr, 0x0f, ETH_P_EDSA);\r\nREG_WRITE(addr, 0x18, 0x3210);\r\nREG_WRITE(addr, 0x19, 0x7654);\r\nreturn 0;\r\n}\r\nstatic int mv88e6171_setup(struct dsa_switch *ds)\r\n{\r\nstruct mv88e6xxx_priv_state *ps = (void *)(ds + 1);\r\nint i;\r\nint ret;\r\nmutex_init(&ps->smi_mutex);\r\nmutex_init(&ps->stats_mutex);\r\nret = mv88e6171_switch_reset(ds);\r\nif (ret < 0)\r\nreturn ret;\r\nret = mv88e6171_setup_global(ds);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < 8; i++) {\r\nif (!(dsa_is_cpu_port(ds, i) || ds->phys_port_mask & (1 << i)))\r\ncontinue;\r\nret = mv88e6171_setup_port(ds, i);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nmutex_init(&ps->phy_mutex);\r\nreturn 0;\r\n}\r\nstatic int mv88e6171_port_to_phy_addr(int port)\r\n{\r\nif (port >= 0 && port <= 4)\r\nreturn port;\r\nreturn -1;\r\n}\r\nstatic int\r\nmv88e6171_phy_read(struct dsa_switch *ds, int port, int regnum)\r\n{\r\nstruct mv88e6xxx_priv_state *ps = ds_to_priv(ds);\r\nint addr = mv88e6171_port_to_phy_addr(port);\r\nint ret;\r\nmutex_lock(&ps->phy_mutex);\r\nret = mv88e6xxx_phy_read(ds, addr, regnum);\r\nmutex_unlock(&ps->phy_mutex);\r\nreturn ret;\r\n}\r\nstatic int\r\nmv88e6171_phy_write(struct dsa_switch *ds,\r\nint port, int regnum, u16 val)\r\n{\r\nstruct mv88e6xxx_priv_state *ps = ds_to_priv(ds);\r\nint addr = mv88e6171_port_to_phy_addr(port);\r\nint ret;\r\nmutex_lock(&ps->phy_mutex);\r\nret = mv88e6xxx_phy_write(ds, addr, regnum, val);\r\nmutex_unlock(&ps->phy_mutex);\r\nreturn ret;\r\n}\r\nstatic void\r\nmv88e6171_get_strings(struct dsa_switch *ds, int port, uint8_t *data)\r\n{\r\nmv88e6xxx_get_strings(ds, ARRAY_SIZE(mv88e6171_hw_stats),\r\nmv88e6171_hw_stats, port, data);\r\n}\r\nstatic void\r\nmv88e6171_get_ethtool_stats(struct dsa_switch *ds,\r\nint port, uint64_t *data)\r\n{\r\nmv88e6xxx_get_ethtool_stats(ds, ARRAY_SIZE(mv88e6171_hw_stats),\r\nmv88e6171_hw_stats, port, data);\r\n}\r\nstatic int mv88e6171_get_sset_count(struct dsa_switch *ds)\r\n{\r\nreturn ARRAY_SIZE(mv88e6171_hw_stats);\r\n}
