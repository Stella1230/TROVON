static unsigned int codec_send_command(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned int verb, unsigned int parm, unsigned int *res)\r\n{\r\nunsigned int response;\r\nresponse = snd_hda_codec_read(codec, nid, 0, verb, parm);\r\n*res = response;\r\nreturn ((response == -1) ? -1 : 0);\r\n}\r\nstatic int codec_set_converter_format(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned short converter_format, unsigned int *res)\r\n{\r\nreturn codec_send_command(codec, nid, VENDOR_CHIPIO_STREAM_FORMAT,\r\nconverter_format & 0xffff, res);\r\n}\r\nstatic int codec_set_converter_stream_channel(struct hda_codec *codec,\r\nhda_nid_t nid, unsigned char stream,\r\nunsigned char channel, unsigned int *res)\r\n{\r\nunsigned char converter_stream_channel = 0;\r\nconverter_stream_channel = (stream << 4) | (channel & 0x0f);\r\nreturn codec_send_command(codec, nid, AC_VERB_SET_CHANNEL_STREAMID,\r\nconverter_stream_channel, res);\r\n}\r\nstatic int chipio_send(struct hda_codec *codec,\r\nunsigned int reg,\r\nunsigned int data)\r\n{\r\nunsigned int res;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1000);\r\ndo {\r\nres = snd_hda_codec_read(codec, WIDGET_CHIP_CTRL, 0,\r\nreg, data);\r\nif (res == VENDOR_STATUS_CHIPIO_OK)\r\nreturn 0;\r\nmsleep(20);\r\n} while (time_before(jiffies, timeout));\r\nreturn -EIO;\r\n}\r\nstatic int chipio_write_address(struct hda_codec *codec,\r\nunsigned int chip_addx)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nint res;\r\nif (spec->curr_chip_addx == chip_addx)\r\nreturn 0;\r\nres = chipio_send(codec, VENDOR_CHIPIO_ADDRESS_LOW,\r\nchip_addx & 0xffff);\r\nif (res != -EIO) {\r\nres = chipio_send(codec, VENDOR_CHIPIO_ADDRESS_HIGH,\r\nchip_addx >> 16);\r\n}\r\nspec->curr_chip_addx = (res < 0) ? ~0UL : chip_addx;\r\nreturn res;\r\n}\r\nstatic int chipio_write_data(struct hda_codec *codec, unsigned int data)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nint res;\r\nres = chipio_send(codec, VENDOR_CHIPIO_DATA_LOW, data & 0xffff);\r\nif (res != -EIO) {\r\nres = chipio_send(codec, VENDOR_CHIPIO_DATA_HIGH,\r\ndata >> 16);\r\n}\r\nspec->curr_chip_addx = (res != -EIO) ?\r\n(spec->curr_chip_addx + 4) : ~0UL;\r\nreturn res;\r\n}\r\nstatic int chipio_write_data_multiple(struct hda_codec *codec,\r\nconst u32 *data,\r\nunsigned int count)\r\n{\r\nint status = 0;\r\nif (data == NULL) {\r\ncodec_dbg(codec, "chipio_write_data null ptr\n");\r\nreturn -EINVAL;\r\n}\r\nwhile ((count-- != 0) && (status == 0))\r\nstatus = chipio_write_data(codec, *data++);\r\nreturn status;\r\n}\r\nstatic int chipio_read_data(struct hda_codec *codec, unsigned int *data)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nint res;\r\nres = chipio_send(codec, VENDOR_CHIPIO_HIC_POST_READ, 0);\r\nif (res != -EIO) {\r\nres = chipio_send(codec, VENDOR_CHIPIO_STATUS, 0);\r\n}\r\nif (res != -EIO) {\r\n*data = snd_hda_codec_read(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_HIC_READ_DATA,\r\n0);\r\n}\r\nspec->curr_chip_addx = (res != -EIO) ?\r\n(spec->curr_chip_addx + 4) : ~0UL;\r\nreturn res;\r\n}\r\nstatic int chipio_write(struct hda_codec *codec,\r\nunsigned int chip_addx, const unsigned int data)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nint err;\r\nmutex_lock(&spec->chipio_mutex);\r\nerr = chipio_write_address(codec, chip_addx);\r\nif (err < 0)\r\ngoto exit;\r\nerr = chipio_write_data(codec, data);\r\nif (err < 0)\r\ngoto exit;\r\nexit:\r\nmutex_unlock(&spec->chipio_mutex);\r\nreturn err;\r\n}\r\nstatic int chipio_write_multiple(struct hda_codec *codec,\r\nu32 chip_addx,\r\nconst u32 *data,\r\nunsigned int count)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nint status;\r\nmutex_lock(&spec->chipio_mutex);\r\nstatus = chipio_write_address(codec, chip_addx);\r\nif (status < 0)\r\ngoto error;\r\nstatus = chipio_write_data_multiple(codec, data, count);\r\nerror:\r\nmutex_unlock(&spec->chipio_mutex);\r\nreturn status;\r\n}\r\nstatic int chipio_read(struct hda_codec *codec,\r\nunsigned int chip_addx, unsigned int *data)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nint err;\r\nmutex_lock(&spec->chipio_mutex);\r\nerr = chipio_write_address(codec, chip_addx);\r\nif (err < 0)\r\ngoto exit;\r\nerr = chipio_read_data(codec, data);\r\nif (err < 0)\r\ngoto exit;\r\nexit:\r\nmutex_unlock(&spec->chipio_mutex);\r\nreturn err;\r\n}\r\nstatic void chipio_set_control_flag(struct hda_codec *codec,\r\nenum control_flag_id flag_id,\r\nbool flag_state)\r\n{\r\nunsigned int val;\r\nunsigned int flag_bit;\r\nflag_bit = (flag_state ? 1 : 0);\r\nval = (flag_bit << 7) | (flag_id);\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_FLAG_SET, val);\r\n}\r\nstatic void chipio_set_control_param(struct hda_codec *codec,\r\nenum control_param_id param_id, int param_val)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nint val;\r\nif ((param_id < 32) && (param_val < 8)) {\r\nval = (param_val << 5) | (param_id);\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_PARAM_SET, val);\r\n} else {\r\nmutex_lock(&spec->chipio_mutex);\r\nif (chipio_send(codec, VENDOR_CHIPIO_STATUS, 0) == 0) {\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_PARAM_EX_ID_SET,\r\nparam_id);\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_PARAM_EX_VALUE_SET,\r\nparam_val);\r\n}\r\nmutex_unlock(&spec->chipio_mutex);\r\n}\r\n}\r\nstatic void chipio_set_conn_rate(struct hda_codec *codec,\r\nint connid, enum ca0132_sample_rate rate)\r\n{\r\nchipio_set_control_param(codec, CONTROL_PARAM_CONN_POINT_ID, connid);\r\nchipio_set_control_param(codec, CONTROL_PARAM_CONN_POINT_SAMPLE_RATE,\r\nrate);\r\n}\r\nstatic void chipio_enable_clocks(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nmutex_lock(&spec->chipio_mutex);\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_8051_ADDRESS_LOW, 0);\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_PLL_PMU_WRITE, 0xff);\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_8051_ADDRESS_LOW, 5);\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_PLL_PMU_WRITE, 0x0b);\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_8051_ADDRESS_LOW, 6);\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_PLL_PMU_WRITE, 0xff);\r\nmutex_unlock(&spec->chipio_mutex);\r\n}\r\nstatic int dspio_send(struct hda_codec *codec, unsigned int reg,\r\nunsigned int data)\r\n{\r\nint res;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1000);\r\ndo {\r\nres = snd_hda_codec_read(codec, WIDGET_DSP_CTRL, 0, reg, data);\r\nif ((res >= 0) && (res != VENDOR_STATUS_DSPIO_BUSY))\r\nreturn res;\r\nmsleep(20);\r\n} while (time_before(jiffies, timeout));\r\nreturn -EIO;\r\n}\r\nstatic void dspio_write_wait(struct hda_codec *codec)\r\n{\r\nint status;\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1000);\r\ndo {\r\nstatus = snd_hda_codec_read(codec, WIDGET_DSP_CTRL, 0,\r\nVENDOR_DSPIO_STATUS, 0);\r\nif ((status == VENDOR_STATUS_DSPIO_OK) ||\r\n(status == VENDOR_STATUS_DSPIO_SCP_RESPONSE_QUEUE_EMPTY))\r\nbreak;\r\nmsleep(1);\r\n} while (time_before(jiffies, timeout));\r\n}\r\nstatic int dspio_write(struct hda_codec *codec, unsigned int scp_data)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nint status;\r\ndspio_write_wait(codec);\r\nmutex_lock(&spec->chipio_mutex);\r\nstatus = dspio_send(codec, VENDOR_DSPIO_SCP_WRITE_DATA_LOW,\r\nscp_data & 0xffff);\r\nif (status < 0)\r\ngoto error;\r\nstatus = dspio_send(codec, VENDOR_DSPIO_SCP_WRITE_DATA_HIGH,\r\nscp_data >> 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = snd_hda_codec_read(codec, WIDGET_DSP_CTRL, 0,\r\nVENDOR_DSPIO_STATUS, 0);\r\nerror:\r\nmutex_unlock(&spec->chipio_mutex);\r\nreturn (status == VENDOR_STATUS_DSPIO_SCP_COMMAND_QUEUE_FULL) ?\r\n-EIO : 0;\r\n}\r\nstatic int dspio_write_multiple(struct hda_codec *codec,\r\nunsigned int *buffer, unsigned int size)\r\n{\r\nint status = 0;\r\nunsigned int count;\r\nif ((buffer == NULL))\r\nreturn -EINVAL;\r\ncount = 0;\r\nwhile (count < size) {\r\nstatus = dspio_write(codec, *buffer++);\r\nif (status != 0)\r\nbreak;\r\ncount++;\r\n}\r\nreturn status;\r\n}\r\nstatic int dspio_read(struct hda_codec *codec, unsigned int *data)\r\n{\r\nint status;\r\nstatus = dspio_send(codec, VENDOR_DSPIO_SCP_POST_READ_DATA, 0);\r\nif (status == -EIO)\r\nreturn status;\r\nstatus = dspio_send(codec, VENDOR_DSPIO_STATUS, 0);\r\nif (status == -EIO ||\r\nstatus == VENDOR_STATUS_DSPIO_SCP_RESPONSE_QUEUE_EMPTY)\r\nreturn -EIO;\r\n*data = snd_hda_codec_read(codec, WIDGET_DSP_CTRL, 0,\r\nVENDOR_DSPIO_SCP_READ_DATA, 0);\r\nreturn 0;\r\n}\r\nstatic int dspio_read_multiple(struct hda_codec *codec, unsigned int *buffer,\r\nunsigned int *buf_size, unsigned int size_count)\r\n{\r\nint status = 0;\r\nunsigned int size = *buf_size;\r\nunsigned int count;\r\nunsigned int skip_count;\r\nunsigned int dummy;\r\nif ((buffer == NULL))\r\nreturn -1;\r\ncount = 0;\r\nwhile (count < size && count < size_count) {\r\nstatus = dspio_read(codec, buffer++);\r\nif (status != 0)\r\nbreak;\r\ncount++;\r\n}\r\nskip_count = count;\r\nif (status == 0) {\r\nwhile (skip_count < size) {\r\nstatus = dspio_read(codec, &dummy);\r\nif (status != 0)\r\nbreak;\r\nskip_count++;\r\n}\r\n}\r\n*buf_size = count;\r\nreturn status;\r\n}\r\nstatic inline unsigned int\r\nmake_scp_header(unsigned int target_id, unsigned int source_id,\r\nunsigned int get_flag, unsigned int req,\r\nunsigned int device_flag, unsigned int resp_flag,\r\nunsigned int error_flag, unsigned int data_size)\r\n{\r\nunsigned int header = 0;\r\nheader = (data_size & 0x1f) << 27;\r\nheader |= (error_flag & 0x01) << 26;\r\nheader |= (resp_flag & 0x01) << 25;\r\nheader |= (device_flag & 0x01) << 24;\r\nheader |= (req & 0x7f) << 17;\r\nheader |= (get_flag & 0x01) << 16;\r\nheader |= (source_id & 0xff) << 8;\r\nheader |= target_id & 0xff;\r\nreturn header;\r\n}\r\nstatic inline void\r\nextract_scp_header(unsigned int header,\r\nunsigned int *target_id, unsigned int *source_id,\r\nunsigned int *get_flag, unsigned int *req,\r\nunsigned int *device_flag, unsigned int *resp_flag,\r\nunsigned int *error_flag, unsigned int *data_size)\r\n{\r\nif (data_size)\r\n*data_size = (header >> 27) & 0x1f;\r\nif (error_flag)\r\n*error_flag = (header >> 26) & 0x01;\r\nif (resp_flag)\r\n*resp_flag = (header >> 25) & 0x01;\r\nif (device_flag)\r\n*device_flag = (header >> 24) & 0x01;\r\nif (req)\r\n*req = (header >> 17) & 0x7f;\r\nif (get_flag)\r\n*get_flag = (header >> 16) & 0x01;\r\nif (source_id)\r\n*source_id = (header >> 8) & 0xff;\r\nif (target_id)\r\n*target_id = header & 0xff;\r\n}\r\nstatic void dspio_clear_response_queue(struct hda_codec *codec)\r\n{\r\nunsigned int dummy = 0;\r\nint status = -1;\r\ndo {\r\nstatus = dspio_read(codec, &dummy);\r\n} while (status == 0);\r\n}\r\nstatic int dspio_get_response_data(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nunsigned int data = 0;\r\nunsigned int count;\r\nif (dspio_read(codec, &data) < 0)\r\nreturn -EIO;\r\nif ((data & 0x00ffffff) == spec->wait_scp_header) {\r\nspec->scp_resp_header = data;\r\nspec->scp_resp_count = data >> 27;\r\ncount = spec->wait_num_data;\r\ndspio_read_multiple(codec, spec->scp_resp_data,\r\n&spec->scp_resp_count, count);\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int dspio_send_scp_message(struct hda_codec *codec,\r\nunsigned char *send_buf,\r\nunsigned int send_buf_size,\r\nunsigned char *return_buf,\r\nunsigned int return_buf_size,\r\nunsigned int *bytes_returned)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nint status = -1;\r\nunsigned int scp_send_size = 0;\r\nunsigned int total_size;\r\nbool waiting_for_resp = false;\r\nunsigned int header;\r\nstruct scp_msg *ret_msg;\r\nunsigned int resp_src_id, resp_target_id;\r\nunsigned int data_size, src_id, target_id, get_flag, device_flag;\r\nif (bytes_returned)\r\n*bytes_returned = 0;\r\nheader = *((unsigned int *)send_buf);\r\nextract_scp_header(header, &target_id, &src_id, &get_flag, NULL,\r\n&device_flag, NULL, NULL, &data_size);\r\nscp_send_size = data_size + 1;\r\ntotal_size = (scp_send_size * 4);\r\nif (send_buf_size < total_size)\r\nreturn -EINVAL;\r\nif (get_flag || device_flag) {\r\nif (!return_buf || return_buf_size < 4 || !bytes_returned)\r\nreturn -EINVAL;\r\nspec->wait_scp_header = *((unsigned int *)send_buf);\r\nresp_target_id = src_id;\r\nresp_src_id = target_id;\r\nspec->wait_scp_header &= 0xffff0000;\r\nspec->wait_scp_header |= (resp_src_id << 8) | (resp_target_id);\r\nspec->wait_num_data = return_buf_size/sizeof(unsigned int) - 1;\r\nspec->wait_scp = 1;\r\nwaiting_for_resp = true;\r\n}\r\nstatus = dspio_write_multiple(codec, (unsigned int *)send_buf,\r\nscp_send_size);\r\nif (status < 0) {\r\nspec->wait_scp = 0;\r\nreturn status;\r\n}\r\nif (waiting_for_resp) {\r\nunsigned long timeout = jiffies + msecs_to_jiffies(1000);\r\nmemset(return_buf, 0, return_buf_size);\r\ndo {\r\nmsleep(20);\r\n} while (spec->wait_scp && time_before(jiffies, timeout));\r\nwaiting_for_resp = false;\r\nif (!spec->wait_scp) {\r\nret_msg = (struct scp_msg *)return_buf;\r\nmemcpy(&ret_msg->hdr, &spec->scp_resp_header, 4);\r\nmemcpy(&ret_msg->data, spec->scp_resp_data,\r\nspec->wait_num_data);\r\n*bytes_returned = (spec->scp_resp_count + 1) * 4;\r\nstatus = 0;\r\n} else {\r\nstatus = -EIO;\r\n}\r\nspec->wait_scp = 0;\r\n}\r\nreturn status;\r\n}\r\nstatic int dspio_scp(struct hda_codec *codec,\r\nint mod_id, int req, int dir, void *data, unsigned int len,\r\nvoid *reply, unsigned int *reply_len)\r\n{\r\nint status = 0;\r\nstruct scp_msg scp_send, scp_reply;\r\nunsigned int ret_bytes, send_size, ret_size;\r\nunsigned int send_get_flag, reply_resp_flag, reply_error_flag;\r\nunsigned int reply_data_size;\r\nmemset(&scp_send, 0, sizeof(scp_send));\r\nmemset(&scp_reply, 0, sizeof(scp_reply));\r\nif ((len != 0 && data == NULL) || (len > SCP_MAX_DATA_WORDS))\r\nreturn -EINVAL;\r\nif (dir == SCP_GET && reply == NULL) {\r\ncodec_dbg(codec, "dspio_scp get but has no buffer\n");\r\nreturn -EINVAL;\r\n}\r\nif (reply != NULL && (reply_len == NULL || (*reply_len == 0))) {\r\ncodec_dbg(codec, "dspio_scp bad resp buf len parms\n");\r\nreturn -EINVAL;\r\n}\r\nscp_send.hdr = make_scp_header(mod_id, 0x20, (dir == SCP_GET), req,\r\n0, 0, 0, len/sizeof(unsigned int));\r\nif (data != NULL && len > 0) {\r\nlen = min((unsigned int)(sizeof(scp_send.data)), len);\r\nmemcpy(scp_send.data, data, len);\r\n}\r\nret_bytes = 0;\r\nsend_size = sizeof(unsigned int) + len;\r\nstatus = dspio_send_scp_message(codec, (unsigned char *)&scp_send,\r\nsend_size, (unsigned char *)&scp_reply,\r\nsizeof(scp_reply), &ret_bytes);\r\nif (status < 0) {\r\ncodec_dbg(codec, "dspio_scp: send scp msg failed\n");\r\nreturn status;\r\n}\r\nextract_scp_header(scp_send.hdr, NULL, NULL, &send_get_flag,\r\nNULL, NULL, NULL, NULL, NULL);\r\nextract_scp_header(scp_reply.hdr, NULL, NULL, NULL, NULL, NULL,\r\n&reply_resp_flag, &reply_error_flag,\r\n&reply_data_size);\r\nif (!send_get_flag)\r\nreturn 0;\r\nif (reply_resp_flag && !reply_error_flag) {\r\nret_size = (ret_bytes - sizeof(scp_reply.hdr))\r\n/ sizeof(unsigned int);\r\nif (*reply_len < ret_size*sizeof(unsigned int)) {\r\ncodec_dbg(codec, "reply too long for buf\n");\r\nreturn -EINVAL;\r\n} else if (ret_size != reply_data_size) {\r\ncodec_dbg(codec, "RetLen and HdrLen .NE.\n");\r\nreturn -EINVAL;\r\n} else {\r\n*reply_len = ret_size*sizeof(unsigned int);\r\nmemcpy(reply, scp_reply.data, *reply_len);\r\n}\r\n} else {\r\ncodec_dbg(codec, "reply ill-formed or errflag set\n");\r\nreturn -EIO;\r\n}\r\nreturn status;\r\n}\r\nstatic int dspio_set_param(struct hda_codec *codec, int mod_id,\r\nint req, void *data, unsigned int len)\r\n{\r\nreturn dspio_scp(codec, mod_id, req, SCP_SET, data, len, NULL, NULL);\r\n}\r\nstatic int dspio_set_uint_param(struct hda_codec *codec, int mod_id,\r\nint req, unsigned int data)\r\n{\r\nreturn dspio_set_param(codec, mod_id, req, &data, sizeof(unsigned int));\r\n}\r\nstatic int dspio_alloc_dma_chan(struct hda_codec *codec, unsigned int *dma_chan)\r\n{\r\nint status = 0;\r\nunsigned int size = sizeof(dma_chan);\r\ncodec_dbg(codec, " dspio_alloc_dma_chan() -- begin\n");\r\nstatus = dspio_scp(codec, MASTERCONTROL, MASTERCONTROL_ALLOC_DMA_CHAN,\r\nSCP_GET, NULL, 0, dma_chan, &size);\r\nif (status < 0) {\r\ncodec_dbg(codec, "dspio_alloc_dma_chan: SCP Failed\n");\r\nreturn status;\r\n}\r\nif ((*dma_chan + 1) == 0) {\r\ncodec_dbg(codec, "no free dma channels to allocate\n");\r\nreturn -EBUSY;\r\n}\r\ncodec_dbg(codec, "dspio_alloc_dma_chan: chan=%d\n", *dma_chan);\r\ncodec_dbg(codec, " dspio_alloc_dma_chan() -- complete\n");\r\nreturn status;\r\n}\r\nstatic int dspio_free_dma_chan(struct hda_codec *codec, unsigned int dma_chan)\r\n{\r\nint status = 0;\r\nunsigned int dummy = 0;\r\ncodec_dbg(codec, " dspio_free_dma_chan() -- begin\n");\r\ncodec_dbg(codec, "dspio_free_dma_chan: chan=%d\n", dma_chan);\r\nstatus = dspio_scp(codec, MASTERCONTROL, MASTERCONTROL_ALLOC_DMA_CHAN,\r\nSCP_SET, &dma_chan, sizeof(dma_chan), NULL, &dummy);\r\nif (status < 0) {\r\ncodec_dbg(codec, "dspio_free_dma_chan: SCP Failed\n");\r\nreturn status;\r\n}\r\ncodec_dbg(codec, " dspio_free_dma_chan() -- complete\n");\r\nreturn status;\r\n}\r\nstatic int dsp_set_run_state(struct hda_codec *codec)\r\n{\r\nunsigned int dbg_ctrl_reg;\r\nunsigned int halt_state;\r\nint err;\r\nerr = chipio_read(codec, DSP_DBGCNTL_INST_OFFSET, &dbg_ctrl_reg);\r\nif (err < 0)\r\nreturn err;\r\nhalt_state = (dbg_ctrl_reg & DSP_DBGCNTL_STATE_MASK) >>\r\nDSP_DBGCNTL_STATE_LOBIT;\r\nif (halt_state != 0) {\r\ndbg_ctrl_reg &= ~((halt_state << DSP_DBGCNTL_SS_LOBIT) &\r\nDSP_DBGCNTL_SS_MASK);\r\nerr = chipio_write(codec, DSP_DBGCNTL_INST_OFFSET,\r\ndbg_ctrl_reg);\r\nif (err < 0)\r\nreturn err;\r\ndbg_ctrl_reg |= (halt_state << DSP_DBGCNTL_EXEC_LOBIT) &\r\nDSP_DBGCNTL_EXEC_MASK;\r\nerr = chipio_write(codec, DSP_DBGCNTL_INST_OFFSET,\r\ndbg_ctrl_reg);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsp_reset(struct hda_codec *codec)\r\n{\r\nunsigned int res;\r\nint retry = 20;\r\ncodec_dbg(codec, "dsp_reset\n");\r\ndo {\r\nres = dspio_send(codec, VENDOR_DSPIO_DSP_INIT, 0);\r\nretry--;\r\n} while (res == -EIO && retry);\r\nif (!retry) {\r\ncodec_dbg(codec, "dsp_reset timeout\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int dsp_chip_to_dsp_addx(unsigned int chip_addx,\r\nbool *code, bool *yram)\r\n{\r\n*code = *yram = false;\r\nif (UC_RANGE(chip_addx, 1)) {\r\n*code = true;\r\nreturn UC_OFF(chip_addx);\r\n} else if (X_RANGE_ALL(chip_addx, 1)) {\r\nreturn X_OFF(chip_addx);\r\n} else if (Y_RANGE_ALL(chip_addx, 1)) {\r\n*yram = true;\r\nreturn Y_OFF(chip_addx);\r\n}\r\nreturn INVALID_CHIP_ADDRESS;\r\n}\r\nstatic bool dsp_is_dma_active(struct hda_codec *codec, unsigned int dma_chan)\r\n{\r\nunsigned int dma_chnlstart_reg;\r\nchipio_read(codec, DSPDMAC_CHNLSTART_INST_OFFSET, &dma_chnlstart_reg);\r\nreturn ((dma_chnlstart_reg & (1 <<\r\n(DSPDMAC_CHNLSTART_EN_LOBIT + dma_chan))) != 0);\r\n}\r\nstatic int dsp_dma_setup_common(struct hda_codec *codec,\r\nunsigned int chip_addx,\r\nunsigned int dma_chan,\r\nunsigned int port_map_mask,\r\nbool ovly)\r\n{\r\nint status = 0;\r\nunsigned int chnl_prop;\r\nunsigned int dsp_addx;\r\nunsigned int active;\r\nbool code, yram;\r\ncodec_dbg(codec, "-- dsp_dma_setup_common() -- Begin ---------\n");\r\nif (dma_chan >= DSPDMAC_DMA_CFG_CHANNEL_COUNT) {\r\ncodec_dbg(codec, "dma chan num invalid\n");\r\nreturn -EINVAL;\r\n}\r\nif (dsp_is_dma_active(codec, dma_chan)) {\r\ncodec_dbg(codec, "dma already active\n");\r\nreturn -EBUSY;\r\n}\r\ndsp_addx = dsp_chip_to_dsp_addx(chip_addx, &code, &yram);\r\nif (dsp_addx == INVALID_CHIP_ADDRESS) {\r\ncodec_dbg(codec, "invalid chip addr\n");\r\nreturn -ENXIO;\r\n}\r\nchnl_prop = DSPDMAC_CHNLPROP_AC_MASK;\r\nactive = 0;\r\ncodec_dbg(codec, " dsp_dma_setup_common() start reg pgm\n");\r\nif (ovly) {\r\nstatus = chipio_read(codec, DSPDMAC_CHNLPROP_INST_OFFSET,\r\n&chnl_prop);\r\nif (status < 0) {\r\ncodec_dbg(codec, "read CHNLPROP Reg fail\n");\r\nreturn status;\r\n}\r\ncodec_dbg(codec, "dsp_dma_setup_common() Read CHNLPROP\n");\r\n}\r\nif (!code)\r\nchnl_prop &= ~(1 << (DSPDMAC_CHNLPROP_MSPCE_LOBIT + dma_chan));\r\nelse\r\nchnl_prop |= (1 << (DSPDMAC_CHNLPROP_MSPCE_LOBIT + dma_chan));\r\nchnl_prop &= ~(1 << (DSPDMAC_CHNLPROP_DCON_LOBIT + dma_chan));\r\nstatus = chipio_write(codec, DSPDMAC_CHNLPROP_INST_OFFSET, chnl_prop);\r\nif (status < 0) {\r\ncodec_dbg(codec, "write CHNLPROP Reg fail\n");\r\nreturn status;\r\n}\r\ncodec_dbg(codec, " dsp_dma_setup_common() Write CHNLPROP\n");\r\nif (ovly) {\r\nstatus = chipio_read(codec, DSPDMAC_ACTIVE_INST_OFFSET,\r\n&active);\r\nif (status < 0) {\r\ncodec_dbg(codec, "read ACTIVE Reg fail\n");\r\nreturn status;\r\n}\r\ncodec_dbg(codec, "dsp_dma_setup_common() Read ACTIVE\n");\r\n}\r\nactive &= (~(1 << (DSPDMAC_ACTIVE_AAR_LOBIT + dma_chan))) &\r\nDSPDMAC_ACTIVE_AAR_MASK;\r\nstatus = chipio_write(codec, DSPDMAC_ACTIVE_INST_OFFSET, active);\r\nif (status < 0) {\r\ncodec_dbg(codec, "write ACTIVE Reg fail\n");\r\nreturn status;\r\n}\r\ncodec_dbg(codec, " dsp_dma_setup_common() Write ACTIVE\n");\r\nstatus = chipio_write(codec, DSPDMAC_AUDCHSEL_INST_OFFSET(dma_chan),\r\nport_map_mask);\r\nif (status < 0) {\r\ncodec_dbg(codec, "write AUDCHSEL Reg fail\n");\r\nreturn status;\r\n}\r\ncodec_dbg(codec, " dsp_dma_setup_common() Write AUDCHSEL\n");\r\nstatus = chipio_write(codec, DSPDMAC_IRQCNT_INST_OFFSET(dma_chan),\r\nDSPDMAC_IRQCNT_BICNT_MASK | DSPDMAC_IRQCNT_CICNT_MASK);\r\nif (status < 0) {\r\ncodec_dbg(codec, "write IRQCNT Reg fail\n");\r\nreturn status;\r\n}\r\ncodec_dbg(codec, " dsp_dma_setup_common() Write IRQCNT\n");\r\ncodec_dbg(codec,\r\n"ChipA=0x%x,DspA=0x%x,dmaCh=%u, "\r\n"CHSEL=0x%x,CHPROP=0x%x,Active=0x%x\n",\r\nchip_addx, dsp_addx, dma_chan,\r\nport_map_mask, chnl_prop, active);\r\ncodec_dbg(codec, "-- dsp_dma_setup_common() -- Complete ------\n");\r\nreturn 0;\r\n}\r\nstatic int dsp_dma_setup(struct hda_codec *codec,\r\nunsigned int chip_addx,\r\nunsigned int count,\r\nunsigned int dma_chan)\r\n{\r\nint status = 0;\r\nbool code, yram;\r\nunsigned int dsp_addx;\r\nunsigned int addr_field;\r\nunsigned int incr_field;\r\nunsigned int base_cnt;\r\nunsigned int cur_cnt;\r\nunsigned int dma_cfg = 0;\r\nunsigned int adr_ofs = 0;\r\nunsigned int xfr_cnt = 0;\r\nconst unsigned int max_dma_count = 1 << (DSPDMAC_XFRCNT_BCNT_HIBIT -\r\nDSPDMAC_XFRCNT_BCNT_LOBIT + 1);\r\ncodec_dbg(codec, "-- dsp_dma_setup() -- Begin ---------\n");\r\nif (count > max_dma_count) {\r\ncodec_dbg(codec, "count too big\n");\r\nreturn -EINVAL;\r\n}\r\ndsp_addx = dsp_chip_to_dsp_addx(chip_addx, &code, &yram);\r\nif (dsp_addx == INVALID_CHIP_ADDRESS) {\r\ncodec_dbg(codec, "invalid chip addr\n");\r\nreturn -ENXIO;\r\n}\r\ncodec_dbg(codec, " dsp_dma_setup() start reg pgm\n");\r\naddr_field = dsp_addx << DSPDMAC_DMACFG_DBADR_LOBIT;\r\nincr_field = 0;\r\nif (!code) {\r\naddr_field <<= 1;\r\nif (yram)\r\naddr_field |= (1 << DSPDMAC_DMACFG_DBADR_LOBIT);\r\nincr_field = (1 << DSPDMAC_DMACFG_AINCR_LOBIT);\r\n}\r\ndma_cfg = addr_field + incr_field;\r\nstatus = chipio_write(codec, DSPDMAC_DMACFG_INST_OFFSET(dma_chan),\r\ndma_cfg);\r\nif (status < 0) {\r\ncodec_dbg(codec, "write DMACFG Reg fail\n");\r\nreturn status;\r\n}\r\ncodec_dbg(codec, " dsp_dma_setup() Write DMACFG\n");\r\nadr_ofs = (count - 1) << (DSPDMAC_DSPADROFS_BOFS_LOBIT +\r\n(code ? 0 : 1));\r\nstatus = chipio_write(codec, DSPDMAC_DSPADROFS_INST_OFFSET(dma_chan),\r\nadr_ofs);\r\nif (status < 0) {\r\ncodec_dbg(codec, "write DSPADROFS Reg fail\n");\r\nreturn status;\r\n}\r\ncodec_dbg(codec, " dsp_dma_setup() Write DSPADROFS\n");\r\nbase_cnt = (count - 1) << DSPDMAC_XFRCNT_BCNT_LOBIT;\r\ncur_cnt = (count - 1) << DSPDMAC_XFRCNT_CCNT_LOBIT;\r\nxfr_cnt = base_cnt | cur_cnt;\r\nstatus = chipio_write(codec,\r\nDSPDMAC_XFRCNT_INST_OFFSET(dma_chan), xfr_cnt);\r\nif (status < 0) {\r\ncodec_dbg(codec, "write XFRCNT Reg fail\n");\r\nreturn status;\r\n}\r\ncodec_dbg(codec, " dsp_dma_setup() Write XFRCNT\n");\r\ncodec_dbg(codec,\r\n"ChipA=0x%x, cnt=0x%x, DMACFG=0x%x, "\r\n"ADROFS=0x%x, XFRCNT=0x%x\n",\r\nchip_addx, count, dma_cfg, adr_ofs, xfr_cnt);\r\ncodec_dbg(codec, "-- dsp_dma_setup() -- Complete ---------\n");\r\nreturn 0;\r\n}\r\nstatic int dsp_dma_start(struct hda_codec *codec,\r\nunsigned int dma_chan, bool ovly)\r\n{\r\nunsigned int reg = 0;\r\nint status = 0;\r\ncodec_dbg(codec, "-- dsp_dma_start() -- Begin ---------\n");\r\nif (ovly) {\r\nstatus = chipio_read(codec,\r\nDSPDMAC_CHNLSTART_INST_OFFSET, &reg);\r\nif (status < 0) {\r\ncodec_dbg(codec, "read CHNLSTART reg fail\n");\r\nreturn status;\r\n}\r\ncodec_dbg(codec, "-- dsp_dma_start() Read CHNLSTART\n");\r\nreg &= ~(DSPDMAC_CHNLSTART_EN_MASK |\r\nDSPDMAC_CHNLSTART_DIS_MASK);\r\n}\r\nstatus = chipio_write(codec, DSPDMAC_CHNLSTART_INST_OFFSET,\r\nreg | (1 << (dma_chan + DSPDMAC_CHNLSTART_EN_LOBIT)));\r\nif (status < 0) {\r\ncodec_dbg(codec, "write CHNLSTART reg fail\n");\r\nreturn status;\r\n}\r\ncodec_dbg(codec, "-- dsp_dma_start() -- Complete ---------\n");\r\nreturn status;\r\n}\r\nstatic int dsp_dma_stop(struct hda_codec *codec,\r\nunsigned int dma_chan, bool ovly)\r\n{\r\nunsigned int reg = 0;\r\nint status = 0;\r\ncodec_dbg(codec, "-- dsp_dma_stop() -- Begin ---------\n");\r\nif (ovly) {\r\nstatus = chipio_read(codec,\r\nDSPDMAC_CHNLSTART_INST_OFFSET, &reg);\r\nif (status < 0) {\r\ncodec_dbg(codec, "read CHNLSTART reg fail\n");\r\nreturn status;\r\n}\r\ncodec_dbg(codec, "-- dsp_dma_stop() Read CHNLSTART\n");\r\nreg &= ~(DSPDMAC_CHNLSTART_EN_MASK |\r\nDSPDMAC_CHNLSTART_DIS_MASK);\r\n}\r\nstatus = chipio_write(codec, DSPDMAC_CHNLSTART_INST_OFFSET,\r\nreg | (1 << (dma_chan + DSPDMAC_CHNLSTART_DIS_LOBIT)));\r\nif (status < 0) {\r\ncodec_dbg(codec, "write CHNLSTART reg fail\n");\r\nreturn status;\r\n}\r\ncodec_dbg(codec, "-- dsp_dma_stop() -- Complete ---------\n");\r\nreturn status;\r\n}\r\nstatic int dsp_allocate_router_ports(struct hda_codec *codec,\r\nunsigned int num_chans,\r\nunsigned int ports_per_channel,\r\nunsigned int start_device,\r\nunsigned int *port_map)\r\n{\r\nint status = 0;\r\nint res;\r\nu8 val;\r\nstatus = chipio_send(codec, VENDOR_CHIPIO_STATUS, 0);\r\nif (status < 0)\r\nreturn status;\r\nval = start_device << 6;\r\nval |= (ports_per_channel - 1) << 4;\r\nval |= num_chans - 1;\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_PORT_ALLOC_CONFIG_SET,\r\nval);\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_PORT_ALLOC_SET,\r\nMEM_CONNID_DSP);\r\nstatus = chipio_send(codec, VENDOR_CHIPIO_STATUS, 0);\r\nif (status < 0)\r\nreturn status;\r\nres = snd_hda_codec_read(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_PORT_ALLOC_GET, 0);\r\n*port_map = res;\r\nreturn (res < 0) ? res : 0;\r\n}\r\nstatic int dsp_free_router_ports(struct hda_codec *codec)\r\n{\r\nint status = 0;\r\nstatus = chipio_send(codec, VENDOR_CHIPIO_STATUS, 0);\r\nif (status < 0)\r\nreturn status;\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_PORT_FREE_SET,\r\nMEM_CONNID_DSP);\r\nstatus = chipio_send(codec, VENDOR_CHIPIO_STATUS, 0);\r\nreturn status;\r\n}\r\nstatic int dsp_allocate_ports(struct hda_codec *codec,\r\nunsigned int num_chans,\r\nunsigned int rate_multi, unsigned int *port_map)\r\n{\r\nint status;\r\ncodec_dbg(codec, " dsp_allocate_ports() -- begin\n");\r\nif ((rate_multi != 1) && (rate_multi != 2) && (rate_multi != 4)) {\r\ncodec_dbg(codec, "bad rate multiple\n");\r\nreturn -EINVAL;\r\n}\r\nstatus = dsp_allocate_router_ports(codec, num_chans,\r\nrate_multi, 0, port_map);\r\ncodec_dbg(codec, " dsp_allocate_ports() -- complete\n");\r\nreturn status;\r\n}\r\nstatic int dsp_allocate_ports_format(struct hda_codec *codec,\r\nconst unsigned short fmt,\r\nunsigned int *port_map)\r\n{\r\nint status;\r\nunsigned int num_chans;\r\nunsigned int sample_rate_div = ((get_hdafmt_rate(fmt) >> 0) & 3) + 1;\r\nunsigned int sample_rate_mul = ((get_hdafmt_rate(fmt) >> 3) & 3) + 1;\r\nunsigned int rate_multi = sample_rate_mul / sample_rate_div;\r\nif ((rate_multi != 1) && (rate_multi != 2) && (rate_multi != 4)) {\r\ncodec_dbg(codec, "bad rate multiple\n");\r\nreturn -EINVAL;\r\n}\r\nnum_chans = get_hdafmt_chs(fmt) + 1;\r\nstatus = dsp_allocate_ports(codec, num_chans, rate_multi, port_map);\r\nreturn status;\r\n}\r\nstatic int dsp_free_ports(struct hda_codec *codec)\r\n{\r\nint status;\r\ncodec_dbg(codec, " dsp_free_ports() -- begin\n");\r\nstatus = dsp_free_router_ports(codec);\r\nif (status < 0) {\r\ncodec_dbg(codec, "free router ports fail\n");\r\nreturn status;\r\n}\r\ncodec_dbg(codec, " dsp_free_ports() -- complete\n");\r\nreturn status;\r\n}\r\nstatic int dma_convert_to_hda_format(struct hda_codec *codec,\r\nunsigned int sample_rate,\r\nunsigned short channels,\r\nunsigned short *hda_format)\r\n{\r\nunsigned int format_val;\r\nformat_val = snd_hda_calc_stream_format(codec,\r\nsample_rate,\r\nchannels,\r\nSNDRV_PCM_FORMAT_S32_LE,\r\n32, 0);\r\nif (hda_format)\r\n*hda_format = (unsigned short)format_val;\r\nreturn 0;\r\n}\r\nstatic int dma_reset(struct dma_engine *dma)\r\n{\r\nstruct hda_codec *codec = dma->codec;\r\nstruct ca0132_spec *spec = codec->spec;\r\nint status;\r\nif (dma->dmab->area)\r\nsnd_hda_codec_load_dsp_cleanup(codec, dma->dmab);\r\nstatus = snd_hda_codec_load_dsp_prepare(codec,\r\ndma->m_converter_format,\r\ndma->buf_size,\r\ndma->dmab);\r\nif (status < 0)\r\nreturn status;\r\nspec->dsp_stream_id = status;\r\nreturn 0;\r\n}\r\nstatic int dma_set_state(struct dma_engine *dma, enum dma_state state)\r\n{\r\nbool cmd;\r\nswitch (state) {\r\ncase DMA_STATE_STOP:\r\ncmd = false;\r\nbreak;\r\ncase DMA_STATE_RUN:\r\ncmd = true;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nsnd_hda_codec_load_dsp_trigger(dma->codec, cmd);\r\nreturn 0;\r\n}\r\nstatic unsigned int dma_get_buffer_size(struct dma_engine *dma)\r\n{\r\nreturn dma->dmab->bytes;\r\n}\r\nstatic unsigned char *dma_get_buffer_addr(struct dma_engine *dma)\r\n{\r\nreturn dma->dmab->area;\r\n}\r\nstatic int dma_xfer(struct dma_engine *dma,\r\nconst unsigned int *data,\r\nunsigned int count)\r\n{\r\nmemcpy(dma->dmab->area, data, count);\r\nreturn 0;\r\n}\r\nstatic void dma_get_converter_format(\r\nstruct dma_engine *dma,\r\nunsigned short *format)\r\n{\r\nif (format)\r\n*format = dma->m_converter_format;\r\n}\r\nstatic unsigned int dma_get_stream_id(struct dma_engine *dma)\r\n{\r\nstruct ca0132_spec *spec = dma->codec->spec;\r\nreturn spec->dsp_stream_id;\r\n}\r\nstatic bool is_valid(const struct dsp_image_seg *p)\r\n{\r\nreturn p->magic == g_magic_value;\r\n}\r\nstatic bool is_hci_prog_list_seg(const struct dsp_image_seg *p)\r\n{\r\nreturn g_chip_addr_magic_value == p->chip_addr;\r\n}\r\nstatic bool is_last(const struct dsp_image_seg *p)\r\n{\r\nreturn p->count == 0;\r\n}\r\nstatic size_t dsp_sizeof(const struct dsp_image_seg *p)\r\n{\r\nreturn sizeof(*p) + p->count*sizeof(u32);\r\n}\r\nstatic const struct dsp_image_seg *get_next_seg_ptr(\r\nconst struct dsp_image_seg *p)\r\n{\r\nreturn (struct dsp_image_seg *)((unsigned char *)(p) + dsp_sizeof(p));\r\n}\r\nstatic int dspxfr_hci_write(struct hda_codec *codec,\r\nconst struct dsp_image_seg *fls)\r\n{\r\nint status;\r\nconst u32 *data;\r\nunsigned int count;\r\nif (fls == NULL || fls->chip_addr != g_chip_addr_magic_value) {\r\ncodec_dbg(codec, "hci_write invalid params\n");\r\nreturn -EINVAL;\r\n}\r\ncount = fls->count;\r\ndata = (u32 *)(fls->data);\r\nwhile (count >= 2) {\r\nstatus = chipio_write(codec, data[0], data[1]);\r\nif (status < 0) {\r\ncodec_dbg(codec, "hci_write chipio failed\n");\r\nreturn status;\r\n}\r\ncount -= 2;\r\ndata += 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dspxfr_one_seg(struct hda_codec *codec,\r\nconst struct dsp_image_seg *fls,\r\nunsigned int reloc,\r\nstruct dma_engine *dma_engine,\r\nunsigned int dma_chan,\r\nunsigned int port_map_mask,\r\nbool ovly)\r\n{\r\nint status = 0;\r\nbool comm_dma_setup_done = false;\r\nconst unsigned int *data;\r\nunsigned int chip_addx;\r\nunsigned int words_to_write;\r\nunsigned int buffer_size_words;\r\nunsigned char *buffer_addx;\r\nunsigned short hda_format;\r\nunsigned int sample_rate_div;\r\nunsigned int sample_rate_mul;\r\nunsigned int num_chans;\r\nunsigned int hda_frame_size_words;\r\nunsigned int remainder_words;\r\nconst u32 *data_remainder;\r\nu32 chip_addx_remainder;\r\nunsigned int run_size_words;\r\nconst struct dsp_image_seg *hci_write = NULL;\r\nunsigned long timeout;\r\nbool dma_active;\r\nif (fls == NULL)\r\nreturn -EINVAL;\r\nif (is_hci_prog_list_seg(fls)) {\r\nhci_write = fls;\r\nfls = get_next_seg_ptr(fls);\r\n}\r\nif (hci_write && (!fls || is_last(fls))) {\r\ncodec_dbg(codec, "hci_write\n");\r\nreturn dspxfr_hci_write(codec, hci_write);\r\n}\r\nif (fls == NULL || dma_engine == NULL || port_map_mask == 0) {\r\ncodec_dbg(codec, "Invalid Params\n");\r\nreturn -EINVAL;\r\n}\r\ndata = fls->data;\r\nchip_addx = fls->chip_addr,\r\nwords_to_write = fls->count;\r\nif (!words_to_write)\r\nreturn hci_write ? dspxfr_hci_write(codec, hci_write) : 0;\r\nif (reloc)\r\nchip_addx = (chip_addx & (0xFFFF0000 << 2)) + (reloc << 2);\r\nif (!UC_RANGE(chip_addx, words_to_write) &&\r\n!X_RANGE_ALL(chip_addx, words_to_write) &&\r\n!Y_RANGE_ALL(chip_addx, words_to_write)) {\r\ncodec_dbg(codec, "Invalid chip_addx Params\n");\r\nreturn -EINVAL;\r\n}\r\nbuffer_size_words = (unsigned int)dma_get_buffer_size(dma_engine) /\r\nsizeof(u32);\r\nbuffer_addx = dma_get_buffer_addr(dma_engine);\r\nif (buffer_addx == NULL) {\r\ncodec_dbg(codec, "dma_engine buffer NULL\n");\r\nreturn -EINVAL;\r\n}\r\ndma_get_converter_format(dma_engine, &hda_format);\r\nsample_rate_div = ((get_hdafmt_rate(hda_format) >> 0) & 3) + 1;\r\nsample_rate_mul = ((get_hdafmt_rate(hda_format) >> 3) & 3) + 1;\r\nnum_chans = get_hdafmt_chs(hda_format) + 1;\r\nhda_frame_size_words = ((sample_rate_div == 0) ? 0 :\r\n(num_chans * sample_rate_mul / sample_rate_div));\r\nif (hda_frame_size_words == 0) {\r\ncodec_dbg(codec, "frmsz zero\n");\r\nreturn -EINVAL;\r\n}\r\nbuffer_size_words = min(buffer_size_words,\r\n(unsigned int)(UC_RANGE(chip_addx, 1) ?\r\n65536 : 32768));\r\nbuffer_size_words -= buffer_size_words % hda_frame_size_words;\r\ncodec_dbg(codec,\r\n"chpadr=0x%08x frmsz=%u nchan=%u "\r\n"rate_mul=%u div=%u bufsz=%u\n",\r\nchip_addx, hda_frame_size_words, num_chans,\r\nsample_rate_mul, sample_rate_div, buffer_size_words);\r\nif (buffer_size_words < hda_frame_size_words) {\r\ncodec_dbg(codec, "dspxfr_one_seg:failed\n");\r\nreturn -EINVAL;\r\n}\r\nremainder_words = words_to_write % hda_frame_size_words;\r\ndata_remainder = data;\r\nchip_addx_remainder = chip_addx;\r\ndata += remainder_words;\r\nchip_addx += remainder_words*sizeof(u32);\r\nwords_to_write -= remainder_words;\r\nwhile (words_to_write != 0) {\r\nrun_size_words = min(buffer_size_words, words_to_write);\r\ncodec_dbg(codec, "dspxfr (seg loop)cnt=%u rs=%u remainder=%u\n",\r\nwords_to_write, run_size_words, remainder_words);\r\ndma_xfer(dma_engine, data, run_size_words*sizeof(u32));\r\nif (!comm_dma_setup_done) {\r\nstatus = dsp_dma_stop(codec, dma_chan, ovly);\r\nif (status < 0)\r\nreturn status;\r\nstatus = dsp_dma_setup_common(codec, chip_addx,\r\ndma_chan, port_map_mask, ovly);\r\nif (status < 0)\r\nreturn status;\r\ncomm_dma_setup_done = true;\r\n}\r\nstatus = dsp_dma_setup(codec, chip_addx,\r\nrun_size_words, dma_chan);\r\nif (status < 0)\r\nreturn status;\r\nstatus = dsp_dma_start(codec, dma_chan, ovly);\r\nif (status < 0)\r\nreturn status;\r\nif (!dsp_is_dma_active(codec, dma_chan)) {\r\ncodec_dbg(codec, "dspxfr:DMA did not start\n");\r\nreturn -EIO;\r\n}\r\nstatus = dma_set_state(dma_engine, DMA_STATE_RUN);\r\nif (status < 0)\r\nreturn status;\r\nif (remainder_words != 0) {\r\nstatus = chipio_write_multiple(codec,\r\nchip_addx_remainder,\r\ndata_remainder,\r\nremainder_words);\r\nif (status < 0)\r\nreturn status;\r\nremainder_words = 0;\r\n}\r\nif (hci_write) {\r\nstatus = dspxfr_hci_write(codec, hci_write);\r\nif (status < 0)\r\nreturn status;\r\nhci_write = NULL;\r\n}\r\ntimeout = jiffies + msecs_to_jiffies(2000);\r\ndo {\r\ndma_active = dsp_is_dma_active(codec, dma_chan);\r\nif (!dma_active)\r\nbreak;\r\nmsleep(20);\r\n} while (time_before(jiffies, timeout));\r\nif (dma_active)\r\nbreak;\r\ncodec_dbg(codec, "+++++ DMA complete\n");\r\ndma_set_state(dma_engine, DMA_STATE_STOP);\r\nstatus = dma_reset(dma_engine);\r\nif (status < 0)\r\nreturn status;\r\ndata += run_size_words;\r\nchip_addx += run_size_words*sizeof(u32);\r\nwords_to_write -= run_size_words;\r\n}\r\nif (remainder_words != 0) {\r\nstatus = chipio_write_multiple(codec, chip_addx_remainder,\r\ndata_remainder, remainder_words);\r\n}\r\nreturn status;\r\n}\r\nstatic int dspxfr_image(struct hda_codec *codec,\r\nconst struct dsp_image_seg *fls_data,\r\nunsigned int reloc,\r\nunsigned int sample_rate,\r\nunsigned short channels,\r\nbool ovly)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nint status;\r\nunsigned short hda_format = 0;\r\nunsigned int response;\r\nunsigned char stream_id = 0;\r\nstruct dma_engine *dma_engine;\r\nunsigned int dma_chan;\r\nunsigned int port_map_mask;\r\nif (fls_data == NULL)\r\nreturn -EINVAL;\r\ndma_engine = kzalloc(sizeof(*dma_engine), GFP_KERNEL);\r\nif (!dma_engine)\r\nreturn -ENOMEM;\r\ndma_engine->dmab = kzalloc(sizeof(*dma_engine->dmab), GFP_KERNEL);\r\nif (!dma_engine->dmab) {\r\nkfree(dma_engine);\r\nreturn -ENOMEM;\r\n}\r\ndma_engine->codec = codec;\r\ndma_convert_to_hda_format(codec, sample_rate, channels, &hda_format);\r\ndma_engine->m_converter_format = hda_format;\r\ndma_engine->buf_size = (ovly ? DSP_DMA_WRITE_BUFLEN_OVLY :\r\nDSP_DMA_WRITE_BUFLEN_INIT) * 2;\r\ndma_chan = ovly ? INVALID_DMA_CHANNEL : 0;\r\nstatus = codec_set_converter_format(codec, WIDGET_CHIP_CTRL,\r\nhda_format, &response);\r\nif (status < 0) {\r\ncodec_dbg(codec, "set converter format fail\n");\r\ngoto exit;\r\n}\r\nstatus = snd_hda_codec_load_dsp_prepare(codec,\r\ndma_engine->m_converter_format,\r\ndma_engine->buf_size,\r\ndma_engine->dmab);\r\nif (status < 0)\r\ngoto exit;\r\nspec->dsp_stream_id = status;\r\nif (ovly) {\r\nstatus = dspio_alloc_dma_chan(codec, &dma_chan);\r\nif (status < 0) {\r\ncodec_dbg(codec, "alloc dmachan fail\n");\r\ndma_chan = INVALID_DMA_CHANNEL;\r\ngoto exit;\r\n}\r\n}\r\nport_map_mask = 0;\r\nstatus = dsp_allocate_ports_format(codec, hda_format,\r\n&port_map_mask);\r\nif (status < 0) {\r\ncodec_dbg(codec, "alloc ports fail\n");\r\ngoto exit;\r\n}\r\nstream_id = dma_get_stream_id(dma_engine);\r\nstatus = codec_set_converter_stream_channel(codec,\r\nWIDGET_CHIP_CTRL, stream_id, 0, &response);\r\nif (status < 0) {\r\ncodec_dbg(codec, "set stream chan fail\n");\r\ngoto exit;\r\n}\r\nwhile ((fls_data != NULL) && !is_last(fls_data)) {\r\nif (!is_valid(fls_data)) {\r\ncodec_dbg(codec, "FLS check fail\n");\r\nstatus = -EINVAL;\r\ngoto exit;\r\n}\r\nstatus = dspxfr_one_seg(codec, fls_data, reloc,\r\ndma_engine, dma_chan,\r\nport_map_mask, ovly);\r\nif (status < 0)\r\nbreak;\r\nif (is_hci_prog_list_seg(fls_data))\r\nfls_data = get_next_seg_ptr(fls_data);\r\nif ((fls_data != NULL) && !is_last(fls_data))\r\nfls_data = get_next_seg_ptr(fls_data);\r\n}\r\nif (port_map_mask != 0)\r\nstatus = dsp_free_ports(codec);\r\nif (status < 0)\r\ngoto exit;\r\nstatus = codec_set_converter_stream_channel(codec,\r\nWIDGET_CHIP_CTRL, 0, 0, &response);\r\nexit:\r\nif (ovly && (dma_chan != INVALID_DMA_CHANNEL))\r\ndspio_free_dma_chan(codec, dma_chan);\r\nif (dma_engine->dmab->area)\r\nsnd_hda_codec_load_dsp_cleanup(codec, dma_engine->dmab);\r\nkfree(dma_engine->dmab);\r\nkfree(dma_engine);\r\nreturn status;\r\n}\r\nstatic void dspload_post_setup(struct hda_codec *codec)\r\n{\r\ncodec_dbg(codec, "---- dspload_post_setup ------\n");\r\nchipio_write(codec, XRAM_XRAM_INST_OFFSET(0x18), 0x08080080);\r\nchipio_write(codec, XRAM_XRAM_INST_OFFSET(0x19), 0x3f800000);\r\nchipio_write(codec, XRAM_XRAM_INST_OFFSET(0x29), 0x00000002);\r\n}\r\nstatic int dspload_image(struct hda_codec *codec,\r\nconst struct dsp_image_seg *fls,\r\nbool ovly,\r\nunsigned int reloc,\r\nbool autostart,\r\nint router_chans)\r\n{\r\nint status = 0;\r\nunsigned int sample_rate;\r\nunsigned short channels;\r\ncodec_dbg(codec, "---- dspload_image begin ------\n");\r\nif (router_chans == 0) {\r\nif (!ovly)\r\nrouter_chans = DMA_TRANSFER_FRAME_SIZE_NWORDS;\r\nelse\r\nrouter_chans = DMA_OVERLAY_FRAME_SIZE_NWORDS;\r\n}\r\nsample_rate = 48000;\r\nchannels = (unsigned short)router_chans;\r\nwhile (channels > 16) {\r\nsample_rate *= 2;\r\nchannels /= 2;\r\n}\r\ndo {\r\ncodec_dbg(codec, "Ready to program DMA\n");\r\nif (!ovly)\r\nstatus = dsp_reset(codec);\r\nif (status < 0)\r\nbreak;\r\ncodec_dbg(codec, "dsp_reset() complete\n");\r\nstatus = dspxfr_image(codec, fls, reloc, sample_rate, channels,\r\novly);\r\nif (status < 0)\r\nbreak;\r\ncodec_dbg(codec, "dspxfr_image() complete\n");\r\nif (autostart && !ovly) {\r\ndspload_post_setup(codec);\r\nstatus = dsp_set_run_state(codec);\r\n}\r\ncodec_dbg(codec, "LOAD FINISHED\n");\r\n} while (0);\r\nreturn status;\r\n}\r\nstatic bool dspload_is_loaded(struct hda_codec *codec)\r\n{\r\nunsigned int data = 0;\r\nint status = 0;\r\nstatus = chipio_read(codec, 0x40004, &data);\r\nif ((status < 0) || (data != 1))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool dspload_wait_loaded(struct hda_codec *codec)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(2000);\r\ndo {\r\nif (dspload_is_loaded(codec)) {\r\npr_info("ca0132 DOWNLOAD OK :-) DSP IS RUNNING.\n");\r\nreturn true;\r\n}\r\nmsleep(20);\r\n} while (time_before(jiffies, timeout));\r\npr_err("ca0132 DOWNLOAD FAILED!!! DSP IS NOT RUNNING.\n");\r\nreturn false;\r\n}\r\nstatic int ca0132_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nsnd_hda_codec_setup_stream(codec, spec->dacs[0], stream_tag, 0, format);\r\nreturn 0;\r\n}\r\nstatic int ca0132_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nif (spec->dsp_state == DSP_DOWNLOADING)\r\nreturn 0;\r\nif (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])\r\nmsleep(50);\r\nsnd_hda_codec_cleanup_stream(codec, spec->dacs[0]);\r\nreturn 0;\r\n}\r\nstatic unsigned int ca0132_playback_pcm_delay(struct hda_pcm_stream *info,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nunsigned int latency = DSP_PLAYBACK_INIT_LATENCY;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (spec->dsp_state != DSP_DOWNLOADED)\r\nreturn 0;\r\nif (spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID]) {\r\nif ((spec->effects_switch[SURROUND - EFFECT_START_NID]) ||\r\n(spec->effects_switch[DIALOG_PLUS - EFFECT_START_NID]))\r\nlatency += DSP_PLAY_ENHANCEMENT_LATENCY;\r\n}\r\nif (spec->cur_out_type == SPEAKER_OUT)\r\nlatency += DSP_SPEAKER_OUT_LATENCY;\r\nreturn (latency * runtime->rate) / 1000;\r\n}\r\nstatic int ca0132_dig_playback_pcm_open(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_open(codec, &spec->multiout);\r\n}\r\nstatic int ca0132_dig_playback_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_prepare(codec, &spec->multiout,\r\nstream_tag, format, substream);\r\n}\r\nstatic int ca0132_dig_playback_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_cleanup(codec, &spec->multiout);\r\n}\r\nstatic int ca0132_dig_playback_pcm_close(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nreturn snd_hda_multi_out_dig_close(codec, &spec->multiout);\r\n}\r\nstatic int ca0132_capture_pcm_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nsnd_hda_codec_setup_stream(codec, hinfo->nid,\r\nstream_tag, 0, format);\r\nreturn 0;\r\n}\r\nstatic int ca0132_capture_pcm_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nif (spec->dsp_state == DSP_DOWNLOADING)\r\nreturn 0;\r\nsnd_hda_codec_cleanup_stream(codec, hinfo->nid);\r\nreturn 0;\r\n}\r\nstatic unsigned int ca0132_capture_pcm_delay(struct hda_pcm_stream *info,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nunsigned int latency = DSP_CAPTURE_INIT_LATENCY;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (spec->dsp_state != DSP_DOWNLOADED)\r\nreturn 0;\r\nif (spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID])\r\nlatency += DSP_CRYSTAL_VOICE_LATENCY;\r\nreturn (latency * runtime->rate) / 1000;\r\n}\r\nstatic int tuning_ctl_set(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned int *lookup, int idx)\r\n{\r\nint i = 0;\r\nfor (i = 0; i < TUNING_CTLS_COUNT; i++)\r\nif (nid == ca0132_tuning_ctls[i].nid)\r\nbreak;\r\nsnd_hda_power_up(codec);\r\ndspio_set_param(codec, ca0132_tuning_ctls[i].mid,\r\nca0132_tuning_ctls[i].req,\r\n&(lookup[idx]), sizeof(unsigned int));\r\nsnd_hda_power_down(codec);\r\nreturn 1;\r\n}\r\nstatic int tuning_ctl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ca0132_spec *spec = codec->spec;\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nlong *valp = ucontrol->value.integer.value;\r\nint idx = nid - TUNING_CTL_START_NID;\r\n*valp = spec->cur_ctl_vals[idx];\r\nreturn 0;\r\n}\r\nstatic int voice_focus_ctl_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint chs = get_amp_channels(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = chs == 3 ? 2 : 1;\r\nuinfo->value.integer.min = 20;\r\nuinfo->value.integer.max = 180;\r\nuinfo->value.integer.step = 1;\r\nreturn 0;\r\n}\r\nstatic int voice_focus_ctl_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ca0132_spec *spec = codec->spec;\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nlong *valp = ucontrol->value.integer.value;\r\nint idx;\r\nidx = nid - TUNING_CTL_START_NID;\r\nif (spec->cur_ctl_vals[idx] == *valp)\r\nreturn 0;\r\nspec->cur_ctl_vals[idx] = *valp;\r\nidx = *valp - 20;\r\ntuning_ctl_set(codec, nid, voice_focus_vals_lookup, idx);\r\nreturn 1;\r\n}\r\nstatic int mic_svm_ctl_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint chs = get_amp_channels(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = chs == 3 ? 2 : 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 100;\r\nuinfo->value.integer.step = 1;\r\nreturn 0;\r\n}\r\nstatic int mic_svm_ctl_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ca0132_spec *spec = codec->spec;\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nlong *valp = ucontrol->value.integer.value;\r\nint idx;\r\nidx = nid - TUNING_CTL_START_NID;\r\nif (spec->cur_ctl_vals[idx] == *valp)\r\nreturn 0;\r\nspec->cur_ctl_vals[idx] = *valp;\r\nidx = *valp;\r\ntuning_ctl_set(codec, nid, mic_svm_vals_lookup, idx);\r\nreturn 0;\r\n}\r\nstatic int equalizer_ctl_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint chs = get_amp_channels(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = chs == 3 ? 2 : 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 48;\r\nuinfo->value.integer.step = 1;\r\nreturn 0;\r\n}\r\nstatic int equalizer_ctl_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ca0132_spec *spec = codec->spec;\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nlong *valp = ucontrol->value.integer.value;\r\nint idx;\r\nidx = nid - TUNING_CTL_START_NID;\r\nif (spec->cur_ctl_vals[idx] == *valp)\r\nreturn 0;\r\nspec->cur_ctl_vals[idx] = *valp;\r\nidx = *valp;\r\ntuning_ctl_set(codec, nid, equalizer_vals_lookup, idx);\r\nreturn 1;\r\n}\r\nstatic int add_tuning_control(struct hda_codec *codec,\r\nhda_nid_t pnid, hda_nid_t nid,\r\nconst char *name, int dir)\r\n{\r\nchar namestr[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\r\nint type = dir ? HDA_INPUT : HDA_OUTPUT;\r\nstruct snd_kcontrol_new knew =\r\nHDA_CODEC_VOLUME_MONO(namestr, nid, 1, 0, type);\r\nknew.access = SNDRV_CTL_ELEM_ACCESS_READWRITE |\r\nSNDRV_CTL_ELEM_ACCESS_TLV_READ;\r\nknew.tlv.c = 0;\r\nknew.tlv.p = 0;\r\nswitch (pnid) {\r\ncase VOICE_FOCUS:\r\nknew.info = voice_focus_ctl_info;\r\nknew.get = tuning_ctl_get;\r\nknew.put = voice_focus_ctl_put;\r\nknew.tlv.p = voice_focus_db_scale;\r\nbreak;\r\ncase MIC_SVM:\r\nknew.info = mic_svm_ctl_info;\r\nknew.get = tuning_ctl_get;\r\nknew.put = mic_svm_ctl_put;\r\nbreak;\r\ncase EQUALIZER:\r\nknew.info = equalizer_ctl_info;\r\nknew.get = tuning_ctl_get;\r\nknew.put = equalizer_ctl_put;\r\nknew.tlv.p = eq_db_scale;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nknew.private_value =\r\nHDA_COMPOSE_AMP_VAL(nid, 1, 0, type);\r\nsprintf(namestr, "%s %s Volume", name, dirstr[dir]);\r\nreturn snd_hda_ctl_add(codec, nid, snd_ctl_new1(&knew, codec));\r\n}\r\nstatic int add_tuning_ctls(struct hda_codec *codec)\r\n{\r\nint i;\r\nint err;\r\nfor (i = 0; i < TUNING_CTLS_COUNT; i++) {\r\nerr = add_tuning_control(codec,\r\nca0132_tuning_ctls[i].parent_nid,\r\nca0132_tuning_ctls[i].nid,\r\nca0132_tuning_ctls[i].name,\r\nca0132_tuning_ctls[i].direct);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ca0132_init_tuning_defaults(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nint i;\r\nspec->cur_ctl_vals[WEDGE_ANGLE - TUNING_CTL_START_NID] = 10;\r\nspec->cur_ctl_vals[SVM_LEVEL - TUNING_CTL_START_NID] = 74;\r\nfor (i = 2; i < TUNING_CTLS_COUNT; i++)\r\nspec->cur_ctl_vals[i] = 24;\r\n}\r\nstatic int ca0132_select_out(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nunsigned int pin_ctl;\r\nint jack_present;\r\nint auto_jack;\r\nunsigned int tmp;\r\nint err;\r\ncodec_dbg(codec, "ca0132_select_out\n");\r\nsnd_hda_power_up(codec);\r\nauto_jack = spec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];\r\nif (auto_jack)\r\njack_present = snd_hda_jack_detect(codec, spec->out_pins[1]);\r\nelse\r\njack_present =\r\nspec->vnode_lswitch[VNID_HP_SEL - VNODE_START_NID];\r\nif (jack_present)\r\nspec->cur_out_type = HEADPHONE_OUT;\r\nelse\r\nspec->cur_out_type = SPEAKER_OUT;\r\nif (spec->cur_out_type == SPEAKER_OUT) {\r\ncodec_dbg(codec, "ca0132_select_out speaker\n");\r\ntmp = FLOAT_ONE;\r\nerr = dspio_set_uint_param(codec, 0x80, 0x04, tmp);\r\nif (err < 0)\r\ngoto exit;\r\ntmp = FLOAT_ONE;\r\nerr = dspio_set_uint_param(codec, 0x8f, 0x00, tmp);\r\nif (err < 0)\r\ngoto exit;\r\nsnd_hda_codec_write(codec, spec->out_pins[1], 0,\r\nVENDOR_CHIPIO_EAPD_SEL_SET, 0x02);\r\nsnd_hda_codec_write(codec, spec->out_pins[0], 0,\r\nAC_VERB_SET_EAPD_BTLENABLE, 0x00);\r\nsnd_hda_codec_write(codec, spec->out_pins[0], 0,\r\nVENDOR_CHIPIO_EAPD_SEL_SET, 0x00);\r\nsnd_hda_codec_write(codec, spec->out_pins[0], 0,\r\nAC_VERB_SET_EAPD_BTLENABLE, 0x02);\r\npin_ctl = snd_hda_codec_read(codec, spec->out_pins[1], 0,\r\nAC_VERB_GET_PIN_WIDGET_CONTROL, 0);\r\nsnd_hda_set_pin_ctl(codec, spec->out_pins[1],\r\npin_ctl & ~PIN_HP);\r\npin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,\r\nAC_VERB_GET_PIN_WIDGET_CONTROL, 0);\r\nsnd_hda_set_pin_ctl(codec, spec->out_pins[0],\r\npin_ctl | PIN_OUT);\r\n} else {\r\ncodec_dbg(codec, "ca0132_select_out hp\n");\r\ntmp = FLOAT_ZERO;\r\nerr = dspio_set_uint_param(codec, 0x80, 0x04, tmp);\r\nif (err < 0)\r\ngoto exit;\r\ntmp = FLOAT_ZERO;\r\nerr = dspio_set_uint_param(codec, 0x8f, 0x00, tmp);\r\nif (err < 0)\r\ngoto exit;\r\nsnd_hda_codec_write(codec, spec->out_pins[0], 0,\r\nVENDOR_CHIPIO_EAPD_SEL_SET, 0x00);\r\nsnd_hda_codec_write(codec, spec->out_pins[0], 0,\r\nAC_VERB_SET_EAPD_BTLENABLE, 0x00);\r\nsnd_hda_codec_write(codec, spec->out_pins[1], 0,\r\nVENDOR_CHIPIO_EAPD_SEL_SET, 0x02);\r\nsnd_hda_codec_write(codec, spec->out_pins[0], 0,\r\nAC_VERB_SET_EAPD_BTLENABLE, 0x02);\r\npin_ctl = snd_hda_codec_read(codec, spec->out_pins[0], 0,\r\nAC_VERB_GET_PIN_WIDGET_CONTROL, 0);\r\nsnd_hda_set_pin_ctl(codec, spec->out_pins[0],\r\npin_ctl & ~PIN_HP);\r\npin_ctl = snd_hda_codec_read(codec, spec->out_pins[1], 0,\r\nAC_VERB_GET_PIN_WIDGET_CONTROL, 0);\r\nsnd_hda_set_pin_ctl(codec, spec->out_pins[1],\r\npin_ctl | PIN_HP);\r\n}\r\nexit:\r\nsnd_hda_power_down(codec);\r\nreturn err < 0 ? err : 0;\r\n}\r\nstatic void ca0132_unsol_hp_delayed(struct work_struct *work)\r\n{\r\nstruct ca0132_spec *spec = container_of(\r\nto_delayed_work(work), struct ca0132_spec, unsol_hp_work);\r\nstruct hda_jack_tbl *jack;\r\nca0132_select_out(spec->codec);\r\njack = snd_hda_jack_tbl_get(spec->codec, UNSOL_TAG_HP);\r\nif (jack) {\r\njack->block_report = 0;\r\nsnd_hda_jack_report_sync(spec->codec);\r\n}\r\n}\r\nstatic int ca0132_set_vipsource(struct hda_codec *codec, int val)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nunsigned int tmp;\r\nif (spec->dsp_state != DSP_DOWNLOADED)\r\nreturn 0;\r\nif (!spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID] ||\r\n(val == 0)) {\r\nchipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, 0);\r\nchipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);\r\nchipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);\r\nif (spec->cur_mic_type == DIGITAL_MIC)\r\ntmp = FLOAT_TWO;\r\nelse\r\ntmp = FLOAT_ONE;\r\ndspio_set_uint_param(codec, 0x80, 0x00, tmp);\r\ntmp = FLOAT_ZERO;\r\ndspio_set_uint_param(codec, 0x80, 0x05, tmp);\r\n} else {\r\nchipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_16_000);\r\nchipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_16_000);\r\nif (spec->cur_mic_type == DIGITAL_MIC)\r\ntmp = FLOAT_TWO;\r\nelse\r\ntmp = FLOAT_ONE;\r\ndspio_set_uint_param(codec, 0x80, 0x00, tmp);\r\ntmp = FLOAT_ONE;\r\ndspio_set_uint_param(codec, 0x80, 0x05, tmp);\r\nmsleep(20);\r\nchipio_set_control_param(codec, CONTROL_PARAM_VIP_SOURCE, val);\r\n}\r\nreturn 1;\r\n}\r\nstatic int ca0132_select_mic(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nint jack_present;\r\nint auto_jack;\r\ncodec_dbg(codec, "ca0132_select_mic\n");\r\nsnd_hda_power_up(codec);\r\nauto_jack = spec->vnode_lswitch[VNID_AMIC1_ASEL - VNODE_START_NID];\r\nif (auto_jack)\r\njack_present = snd_hda_jack_detect(codec, spec->input_pins[0]);\r\nelse\r\njack_present =\r\nspec->vnode_lswitch[VNID_AMIC1_SEL - VNODE_START_NID];\r\nif (jack_present)\r\nspec->cur_mic_type = LINE_MIC_IN;\r\nelse\r\nspec->cur_mic_type = DIGITAL_MIC;\r\nif (spec->cur_mic_type == DIGITAL_MIC) {\r\nchipio_set_conn_rate(codec, MEM_CONNID_DMIC, SR_32_000);\r\nca0132_set_dmic(codec, 1);\r\nca0132_mic_boost_set(codec, 0);\r\nca0132_effects_set(codec, VOICE_FOCUS,\r\nspec->effects_switch\r\n[VOICE_FOCUS - EFFECT_START_NID]);\r\n} else {\r\nchipio_set_conn_rate(codec, MEM_CONNID_DMIC, SR_96_000);\r\nca0132_set_dmic(codec, 0);\r\nca0132_mic_boost_set(codec, spec->cur_mic_boost);\r\nca0132_effects_set(codec, VOICE_FOCUS, 0);\r\n}\r\nsnd_hda_power_down(codec);\r\nreturn 0;\r\n}\r\nstatic bool ca0132_is_vnode_effective(struct hda_codec *codec,\r\nhda_nid_t vnid,\r\nhda_nid_t *shared_nid)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nhda_nid_t nid;\r\nswitch (vnid) {\r\ncase VNID_SPK:\r\nnid = spec->shared_out_nid;\r\nbreak;\r\ncase VNID_MIC:\r\nnid = spec->shared_mic_nid;\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nif (shared_nid)\r\n*shared_nid = nid;\r\nreturn true;\r\n}\r\nstatic int ca0132_voicefx_set(struct hda_codec *codec, int enable)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nunsigned int tmp;\r\nif (enable) {\r\ntmp = spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID] ?\r\nFLOAT_ONE : FLOAT_ZERO;\r\n} else {\r\ntmp = FLOAT_ZERO;\r\n}\r\ndspio_set_uint_param(codec, ca0132_voicefx.mid,\r\nca0132_voicefx.reqs[0], tmp);\r\nreturn 1;\r\n}\r\nstatic int ca0132_effects_set(struct hda_codec *codec, hda_nid_t nid, long val)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nunsigned int on;\r\nint num_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT;\r\nint err = 0;\r\nint idx = nid - EFFECT_START_NID;\r\nif ((idx < 0) || (idx >= num_fx))\r\nreturn 0;\r\nif ((nid >= OUT_EFFECT_START_NID) && (nid < OUT_EFFECT_END_NID)) {\r\nif (!spec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID])\r\nval = 0;\r\n}\r\nif ((nid >= IN_EFFECT_START_NID) && (nid < IN_EFFECT_END_NID)) {\r\nif (!spec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID])\r\nval = 0;\r\nif ((nid == VOICE_FOCUS) && (spec->cur_mic_type != DIGITAL_MIC))\r\nval = 0;\r\n}\r\ncodec_dbg(codec, "ca0132_effect_set: nid=0x%x, val=%ld\n",\r\nnid, val);\r\non = (val == 0) ? FLOAT_ZERO : FLOAT_ONE;\r\nerr = dspio_set_uint_param(codec, ca0132_effects[idx].mid,\r\nca0132_effects[idx].reqs[0], on);\r\nif (err < 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int ca0132_pe_switch_set(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nhda_nid_t nid;\r\nint i, ret = 0;\r\ncodec_dbg(codec, "ca0132_pe_switch_set: val=%ld\n",\r\nspec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID]);\r\ni = OUT_EFFECT_START_NID - EFFECT_START_NID;\r\nnid = OUT_EFFECT_START_NID;\r\nfor (; nid < OUT_EFFECT_END_NID; nid++, i++)\r\nret |= ca0132_effects_set(codec, nid, spec->effects_switch[i]);\r\nreturn ret;\r\n}\r\nstatic int stop_mic1(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nunsigned int oldval = snd_hda_codec_read(codec, spec->adcs[0], 0,\r\nAC_VERB_GET_CONV, 0);\r\nif (oldval != 0)\r\nsnd_hda_codec_write(codec, spec->adcs[0], 0,\r\nAC_VERB_SET_CHANNEL_STREAMID,\r\n0);\r\nreturn oldval;\r\n}\r\nstatic void resume_mic1(struct hda_codec *codec, unsigned int oldval)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nif (oldval != 0)\r\nsnd_hda_codec_write(codec, spec->adcs[0], 0,\r\nAC_VERB_SET_CHANNEL_STREAMID,\r\noldval);\r\n}\r\nstatic int ca0132_cvoice_switch_set(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nhda_nid_t nid;\r\nint i, ret = 0;\r\nunsigned int oldval;\r\ncodec_dbg(codec, "ca0132_cvoice_switch_set: val=%ld\n",\r\nspec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID]);\r\ni = IN_EFFECT_START_NID - EFFECT_START_NID;\r\nnid = IN_EFFECT_START_NID;\r\nfor (; nid < IN_EFFECT_END_NID; nid++, i++)\r\nret |= ca0132_effects_set(codec, nid, spec->effects_switch[i]);\r\nret |= ca0132_voicefx_set(codec, (spec->voicefx_val ? 1 : 0));\r\noldval = stop_mic1(codec);\r\nret |= ca0132_set_vipsource(codec, 1);\r\nresume_mic1(codec, oldval);\r\nreturn ret;\r\n}\r\nstatic int ca0132_mic_boost_set(struct hda_codec *codec, long val)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nint ret = 0;\r\nif (val)\r\nret = snd_hda_codec_amp_update(codec, spec->input_pins[0], 0,\r\nHDA_INPUT, 0, HDA_AMP_VOLMASK, 3);\r\nelse\r\nret = snd_hda_codec_amp_update(codec, spec->input_pins[0], 0,\r\nHDA_INPUT, 0, HDA_AMP_VOLMASK, 0);\r\nreturn ret;\r\n}\r\nstatic int ca0132_vnode_switch_set(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nhda_nid_t shared_nid = 0;\r\nbool effective;\r\nint ret = 0;\r\nstruct ca0132_spec *spec = codec->spec;\r\nint auto_jack;\r\nif (nid == VNID_HP_SEL) {\r\nauto_jack =\r\nspec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];\r\nif (!auto_jack)\r\nca0132_select_out(codec);\r\nreturn 1;\r\n}\r\nif (nid == VNID_AMIC1_SEL) {\r\nauto_jack =\r\nspec->vnode_lswitch[VNID_AMIC1_ASEL - VNODE_START_NID];\r\nif (!auto_jack)\r\nca0132_select_mic(codec);\r\nreturn 1;\r\n}\r\nif (nid == VNID_HP_ASEL) {\r\nca0132_select_out(codec);\r\nreturn 1;\r\n}\r\nif (nid == VNID_AMIC1_ASEL) {\r\nca0132_select_mic(codec);\r\nreturn 1;\r\n}\r\neffective = ca0132_is_vnode_effective(codec, nid, &shared_nid);\r\nif (effective) {\r\nint dir = get_amp_direction(kcontrol);\r\nint ch = get_amp_channels(kcontrol);\r\nunsigned long pval;\r\nmutex_lock(&codec->control_mutex);\r\npval = kcontrol->private_value;\r\nkcontrol->private_value = HDA_COMPOSE_AMP_VAL(shared_nid, ch,\r\n0, dir);\r\nret = snd_hda_mixer_amp_switch_put(kcontrol, ucontrol);\r\nkcontrol->private_value = pval;\r\nmutex_unlock(&codec->control_mutex);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ca0132_voicefx_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nunsigned int items = sizeof(ca0132_voicefx_presets)\r\n/ sizeof(struct ct_voicefx_preset);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = items;\r\nif (uinfo->value.enumerated.item >= items)\r\nuinfo->value.enumerated.item = items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\nca0132_voicefx_presets[uinfo->value.enumerated.item].name);\r\nreturn 0;\r\n}\r\nstatic int ca0132_voicefx_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ca0132_spec *spec = codec->spec;\r\nucontrol->value.enumerated.item[0] = spec->voicefx_val;\r\nreturn 0;\r\n}\r\nstatic int ca0132_voicefx_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ca0132_spec *spec = codec->spec;\r\nint i, err = 0;\r\nint sel = ucontrol->value.enumerated.item[0];\r\nunsigned int items = sizeof(ca0132_voicefx_presets)\r\n/ sizeof(struct ct_voicefx_preset);\r\nif (sel >= items)\r\nreturn 0;\r\ncodec_dbg(codec, "ca0132_voicefx_put: sel=%d, preset=%s\n",\r\nsel, ca0132_voicefx_presets[sel].name);\r\nfor (i = 0; i < VOICEFX_MAX_PARAM_COUNT; i++) {\r\nerr = dspio_set_uint_param(codec, ca0132_voicefx.mid,\r\nca0132_voicefx.reqs[i],\r\nca0132_voicefx_presets[sel].vals[i]);\r\nif (err < 0)\r\nbreak;\r\n}\r\nif (err >= 0) {\r\nspec->voicefx_val = sel;\r\nca0132_voicefx_set(codec, (sel ? 1 : 0));\r\n}\r\nreturn 1;\r\n}\r\nstatic int ca0132_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ca0132_spec *spec = codec->spec;\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nint ch = get_amp_channels(kcontrol);\r\nlong *valp = ucontrol->value.integer.value;\r\nif ((nid >= VNODE_START_NID) && (nid < VNODE_END_NID)) {\r\nif (ch & 1) {\r\n*valp = spec->vnode_lswitch[nid - VNODE_START_NID];\r\nvalp++;\r\n}\r\nif (ch & 2) {\r\n*valp = spec->vnode_rswitch[nid - VNODE_START_NID];\r\nvalp++;\r\n}\r\nreturn 0;\r\n}\r\nif ((nid >= EFFECT_START_NID) && (nid < EFFECT_END_NID)) {\r\n*valp = spec->effects_switch[nid - EFFECT_START_NID];\r\nreturn 0;\r\n}\r\nif (nid == spec->input_pins[0]) {\r\n*valp = spec->cur_mic_boost;\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ca0132_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ca0132_spec *spec = codec->spec;\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nint ch = get_amp_channels(kcontrol);\r\nlong *valp = ucontrol->value.integer.value;\r\nint changed = 1;\r\ncodec_dbg(codec, "ca0132_switch_put: nid=0x%x, val=%ld\n",\r\nnid, *valp);\r\nsnd_hda_power_up(codec);\r\nif ((nid >= VNODE_START_NID) && (nid < VNODE_END_NID)) {\r\nif (ch & 1) {\r\nspec->vnode_lswitch[nid - VNODE_START_NID] = *valp;\r\nvalp++;\r\n}\r\nif (ch & 2) {\r\nspec->vnode_rswitch[nid - VNODE_START_NID] = *valp;\r\nvalp++;\r\n}\r\nchanged = ca0132_vnode_switch_set(kcontrol, ucontrol);\r\ngoto exit;\r\n}\r\nif (nid == PLAY_ENHANCEMENT) {\r\nspec->effects_switch[nid - EFFECT_START_NID] = *valp;\r\nchanged = ca0132_pe_switch_set(codec);\r\ngoto exit;\r\n}\r\nif (nid == CRYSTAL_VOICE) {\r\nspec->effects_switch[nid - EFFECT_START_NID] = *valp;\r\nchanged = ca0132_cvoice_switch_set(codec);\r\ngoto exit;\r\n}\r\nif (((nid >= OUT_EFFECT_START_NID) && (nid < OUT_EFFECT_END_NID)) ||\r\n((nid >= IN_EFFECT_START_NID) && (nid < IN_EFFECT_END_NID))) {\r\nspec->effects_switch[nid - EFFECT_START_NID] = *valp;\r\nchanged = ca0132_effects_set(codec, nid, *valp);\r\ngoto exit;\r\n}\r\nif (nid == spec->input_pins[0]) {\r\nspec->cur_mic_boost = *valp;\r\nif (spec->cur_mic_type != DIGITAL_MIC)\r\nchanged = ca0132_mic_boost_set(codec, *valp);\r\ngoto exit;\r\n}\r\nexit:\r\nsnd_hda_power_down(codec);\r\nreturn changed;\r\n}\r\nstatic int ca0132_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ca0132_spec *spec = codec->spec;\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nint ch = get_amp_channels(kcontrol);\r\nint dir = get_amp_direction(kcontrol);\r\nunsigned long pval;\r\nint err;\r\nswitch (nid) {\r\ncase VNID_SPK:\r\nnid = spec->shared_out_nid;\r\nmutex_lock(&codec->control_mutex);\r\npval = kcontrol->private_value;\r\nkcontrol->private_value = HDA_COMPOSE_AMP_VAL(nid, ch, 0, dir);\r\nerr = snd_hda_mixer_amp_volume_info(kcontrol, uinfo);\r\nkcontrol->private_value = pval;\r\nmutex_unlock(&codec->control_mutex);\r\nbreak;\r\ncase VNID_MIC:\r\nnid = spec->shared_mic_nid;\r\nmutex_lock(&codec->control_mutex);\r\npval = kcontrol->private_value;\r\nkcontrol->private_value = HDA_COMPOSE_AMP_VAL(nid, ch, 0, dir);\r\nerr = snd_hda_mixer_amp_volume_info(kcontrol, uinfo);\r\nkcontrol->private_value = pval;\r\nmutex_unlock(&codec->control_mutex);\r\nbreak;\r\ndefault:\r\nerr = snd_hda_mixer_amp_volume_info(kcontrol, uinfo);\r\n}\r\nreturn err;\r\n}\r\nstatic int ca0132_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ca0132_spec *spec = codec->spec;\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nint ch = get_amp_channels(kcontrol);\r\nlong *valp = ucontrol->value.integer.value;\r\nif (ch & 1) {\r\n*valp = spec->vnode_lvol[nid - VNODE_START_NID];\r\nvalp++;\r\n}\r\nif (ch & 2) {\r\n*valp = spec->vnode_rvol[nid - VNODE_START_NID];\r\nvalp++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ca0132_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ca0132_spec *spec = codec->spec;\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nint ch = get_amp_channels(kcontrol);\r\nlong *valp = ucontrol->value.integer.value;\r\nhda_nid_t shared_nid = 0;\r\nbool effective;\r\nint changed = 1;\r\nif (ch & 1) {\r\nspec->vnode_lvol[nid - VNODE_START_NID] = *valp;\r\nvalp++;\r\n}\r\nif (ch & 2) {\r\nspec->vnode_rvol[nid - VNODE_START_NID] = *valp;\r\nvalp++;\r\n}\r\neffective = ca0132_is_vnode_effective(codec, nid, &shared_nid);\r\nif (effective) {\r\nint dir = get_amp_direction(kcontrol);\r\nunsigned long pval;\r\nsnd_hda_power_up(codec);\r\nmutex_lock(&codec->control_mutex);\r\npval = kcontrol->private_value;\r\nkcontrol->private_value = HDA_COMPOSE_AMP_VAL(shared_nid, ch,\r\n0, dir);\r\nchanged = snd_hda_mixer_amp_volume_put(kcontrol, ucontrol);\r\nkcontrol->private_value = pval;\r\nmutex_unlock(&codec->control_mutex);\r\nsnd_hda_power_down(codec);\r\n}\r\nreturn changed;\r\n}\r\nstatic int ca0132_volume_tlv(struct snd_kcontrol *kcontrol, int op_flag,\r\nunsigned int size, unsigned int __user *tlv)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct ca0132_spec *spec = codec->spec;\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nint ch = get_amp_channels(kcontrol);\r\nint dir = get_amp_direction(kcontrol);\r\nunsigned long pval;\r\nint err;\r\nswitch (nid) {\r\ncase VNID_SPK:\r\nnid = spec->shared_out_nid;\r\nmutex_lock(&codec->control_mutex);\r\npval = kcontrol->private_value;\r\nkcontrol->private_value = HDA_COMPOSE_AMP_VAL(nid, ch, 0, dir);\r\nerr = snd_hda_mixer_amp_tlv(kcontrol, op_flag, size, tlv);\r\nkcontrol->private_value = pval;\r\nmutex_unlock(&codec->control_mutex);\r\nbreak;\r\ncase VNID_MIC:\r\nnid = spec->shared_mic_nid;\r\nmutex_lock(&codec->control_mutex);\r\npval = kcontrol->private_value;\r\nkcontrol->private_value = HDA_COMPOSE_AMP_VAL(nid, ch, 0, dir);\r\nerr = snd_hda_mixer_amp_tlv(kcontrol, op_flag, size, tlv);\r\nkcontrol->private_value = pval;\r\nmutex_unlock(&codec->control_mutex);\r\nbreak;\r\ndefault:\r\nerr = snd_hda_mixer_amp_tlv(kcontrol, op_flag, size, tlv);\r\n}\r\nreturn err;\r\n}\r\nstatic int add_fx_switch(struct hda_codec *codec, hda_nid_t nid,\r\nconst char *pfx, int dir)\r\n{\r\nchar namestr[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];\r\nint type = dir ? HDA_INPUT : HDA_OUTPUT;\r\nstruct snd_kcontrol_new knew =\r\nCA0132_CODEC_MUTE_MONO(namestr, nid, 1, type);\r\nsprintf(namestr, "%s %s Switch", pfx, dirstr[dir]);\r\nreturn snd_hda_ctl_add(codec, nid, snd_ctl_new1(&knew, codec));\r\n}\r\nstatic int add_voicefx(struct hda_codec *codec)\r\n{\r\nstruct snd_kcontrol_new knew =\r\nHDA_CODEC_MUTE_MONO(ca0132_voicefx.name,\r\nVOICEFX, 1, 0, HDA_INPUT);\r\nknew.info = ca0132_voicefx_info;\r\nknew.get = ca0132_voicefx_get;\r\nknew.put = ca0132_voicefx_put;\r\nreturn snd_hda_ctl_add(codec, VOICEFX, snd_ctl_new1(&knew, codec));\r\n}\r\nstatic int ca0132_build_controls(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nint i, num_fx;\r\nint err = 0;\r\nfor (i = 0; i < spec->num_mixers; i++) {\r\nerr = snd_hda_add_new_ctls(codec, spec->mixers[i]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nnum_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT;\r\nfor (i = 0; i < num_fx; i++) {\r\nerr = add_fx_switch(codec, ca0132_effects[i].nid,\r\nca0132_effects[i].name,\r\nca0132_effects[i].direct);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = add_fx_switch(codec, PLAY_ENHANCEMENT, "PlayEnhancement", 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_fx_switch(codec, CRYSTAL_VOICE, "CrystalVoice", 1);\r\nif (err < 0)\r\nreturn err;\r\nadd_voicefx(codec);\r\n#ifdef ENABLE_TUNING_CONTROLS\r\nadd_tuning_ctls(codec);\r\n#endif\r\nerr = snd_hda_jack_add_kctls(codec, &spec->autocfg);\r\nif (err < 0)\r\nreturn err;\r\nif (spec->dig_out) {\r\nerr = snd_hda_create_spdif_out_ctls(codec, spec->dig_out,\r\nspec->dig_out);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_hda_create_spdif_share_sw(codec, &spec->multiout);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (spec->dig_in) {\r\nerr = snd_hda_create_spdif_in_ctls(codec, spec->dig_in);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ca0132_build_pcms(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nstruct hda_pcm *info = spec->pcm_rec;\r\ncodec->pcm_info = info;\r\ncodec->num_pcms = 0;\r\ninfo->name = "CA0132 Analog";\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK] = ca0132_pcm_analog_playback;\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = spec->dacs[0];\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].channels_max =\r\nspec->multiout.max_channels;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE] = ca0132_pcm_analog_capture;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].substreams = 1;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adcs[0];\r\ncodec->num_pcms++;\r\ninfo++;\r\ninfo->name = "CA0132 Analog Mic-In2";\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE] = ca0132_pcm_analog_capture;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].substreams = 1;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adcs[1];\r\ncodec->num_pcms++;\r\ninfo++;\r\ninfo->name = "CA0132 What U Hear";\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE] = ca0132_pcm_analog_capture;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].substreams = 1;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->adcs[2];\r\ncodec->num_pcms++;\r\nif (!spec->dig_out && !spec->dig_in)\r\nreturn 0;\r\ninfo++;\r\ninfo->name = "CA0132 Digital";\r\ninfo->pcm_type = HDA_PCM_TYPE_SPDIF;\r\nif (spec->dig_out) {\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK] =\r\nca0132_pcm_digital_playback;\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].nid = spec->dig_out;\r\n}\r\nif (spec->dig_in) {\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE] =\r\nca0132_pcm_digital_capture;\r\ninfo->stream[SNDRV_PCM_STREAM_CAPTURE].nid = spec->dig_in;\r\n}\r\ncodec->num_pcms++;\r\nreturn 0;\r\n}\r\nstatic void init_output(struct hda_codec *codec, hda_nid_t pin, hda_nid_t dac)\r\n{\r\nif (pin) {\r\nsnd_hda_set_pin_ctl(codec, pin, PIN_HP);\r\nif (get_wcaps(codec, pin) & AC_WCAP_OUT_AMP)\r\nsnd_hda_codec_write(codec, pin, 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE,\r\nAMP_OUT_UNMUTE);\r\n}\r\nif (dac && (get_wcaps(codec, dac) & AC_WCAP_OUT_AMP))\r\nsnd_hda_codec_write(codec, dac, 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE, AMP_OUT_ZERO);\r\n}\r\nstatic void init_input(struct hda_codec *codec, hda_nid_t pin, hda_nid_t adc)\r\n{\r\nif (pin) {\r\nsnd_hda_set_pin_ctl(codec, pin, PIN_VREF80);\r\nif (get_wcaps(codec, pin) & AC_WCAP_IN_AMP)\r\nsnd_hda_codec_write(codec, pin, 0,\r\nAC_VERB_SET_AMP_GAIN_MUTE,\r\nAMP_IN_UNMUTE(0));\r\n}\r\nif (adc && (get_wcaps(codec, adc) & AC_WCAP_IN_AMP)) {\r\nsnd_hda_codec_write(codec, adc, 0, AC_VERB_SET_AMP_GAIN_MUTE,\r\nAMP_IN_UNMUTE(0));\r\nsnd_hda_codec_amp_stereo(codec, adc, HDA_INPUT, 0,\r\nHDA_AMP_VOLMASK, 0x5a);\r\nsnd_hda_codec_amp_stereo(codec, adc, HDA_INPUT, 0,\r\nHDA_AMP_MUTE, 0);\r\n}\r\n}\r\nstatic void refresh_amp_caps(struct hda_codec *codec, hda_nid_t nid, int dir)\r\n{\r\nunsigned int caps;\r\ncaps = snd_hda_param_read(codec, nid, dir == HDA_OUTPUT ?\r\nAC_PAR_AMP_OUT_CAP : AC_PAR_AMP_IN_CAP);\r\nsnd_hda_override_amp_caps(codec, nid, dir, caps);\r\n}\r\nstatic void ca0132_set_dmic(struct hda_codec *codec, int enable)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nunsigned int tmp;\r\nu8 val;\r\nunsigned int oldval;\r\ncodec_dbg(codec, "ca0132_set_dmic: enable=%d\n", enable);\r\noldval = stop_mic1(codec);\r\nca0132_set_vipsource(codec, 0);\r\nif (enable) {\r\ntmp = FLOAT_TWO;\r\ndspio_set_uint_param(codec, 0x80, 0x00, tmp);\r\nval = spec->dmic_ctl;\r\nval |= 0x80;\r\nsnd_hda_codec_write(codec, spec->input_pins[0], 0,\r\nVENDOR_CHIPIO_DMIC_CTL_SET, val);\r\nif (!(spec->dmic_ctl & 0x20))\r\nchipio_set_control_flag(codec, CONTROL_FLAG_DMIC, 1);\r\n} else {\r\ntmp = FLOAT_ONE;\r\ndspio_set_uint_param(codec, 0x80, 0x00, tmp);\r\nval = spec->dmic_ctl;\r\nval &= 0x5f;\r\nsnd_hda_codec_write(codec, spec->input_pins[0], 0,\r\nVENDOR_CHIPIO_DMIC_CTL_SET, val);\r\nif (!(spec->dmic_ctl & 0x20))\r\nchipio_set_control_flag(codec, CONTROL_FLAG_DMIC, 0);\r\n}\r\nca0132_set_vipsource(codec, 1);\r\nresume_mic1(codec, oldval);\r\n}\r\nstatic void ca0132_init_dmic(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nu8 val;\r\nval = 0x01;\r\nsnd_hda_codec_write(codec, spec->input_pins[0], 0,\r\nVENDOR_CHIPIO_DMIC_MCLK_SET, val);\r\nval = 0x83;\r\nsnd_hda_codec_write(codec, spec->input_pins[0], 0,\r\nVENDOR_CHIPIO_DMIC_PIN_SET, val);\r\nval = 0x23;\r\nspec->dmic_ctl = val;\r\nsnd_hda_codec_write(codec, spec->input_pins[0], 0,\r\nVENDOR_CHIPIO_DMIC_CTL_SET, val);\r\n}\r\nstatic void ca0132_init_analog_mic2(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nmutex_lock(&spec->chipio_mutex);\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_8051_ADDRESS_LOW, 0x20);\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_8051_ADDRESS_HIGH, 0x19);\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_8051_DATA_WRITE, 0x00);\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_8051_ADDRESS_LOW, 0x2D);\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_8051_ADDRESS_HIGH, 0x19);\r\nsnd_hda_codec_write(codec, WIDGET_CHIP_CTRL, 0,\r\nVENDOR_CHIPIO_8051_DATA_WRITE, 0x00);\r\nmutex_unlock(&spec->chipio_mutex);\r\n}\r\nstatic void ca0132_refresh_widget_caps(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nint i;\r\nhda_nid_t nid;\r\ncodec_dbg(codec, "ca0132_refresh_widget_caps.\n");\r\nnid = codec->start_nid;\r\nfor (i = 0; i < codec->num_nodes; i++, nid++)\r\ncodec->wcaps[i] = snd_hda_param_read(codec, nid,\r\nAC_PAR_AUDIO_WIDGET_CAP);\r\nfor (i = 0; i < spec->multiout.num_dacs; i++)\r\nrefresh_amp_caps(codec, spec->dacs[i], HDA_OUTPUT);\r\nfor (i = 0; i < spec->num_outputs; i++)\r\nrefresh_amp_caps(codec, spec->out_pins[i], HDA_OUTPUT);\r\nfor (i = 0; i < spec->num_inputs; i++) {\r\nrefresh_amp_caps(codec, spec->adcs[i], HDA_INPUT);\r\nrefresh_amp_caps(codec, spec->input_pins[i], HDA_INPUT);\r\n}\r\n}\r\nstatic void ca0132_setup_defaults(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nunsigned int tmp;\r\nint num_fx;\r\nint idx, i;\r\nif (spec->dsp_state != DSP_DOWNLOADED)\r\nreturn;\r\nnum_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT + 1;\r\nfor (idx = 0; idx < num_fx; idx++) {\r\nfor (i = 0; i <= ca0132_effects[idx].params; i++) {\r\ndspio_set_uint_param(codec, ca0132_effects[idx].mid,\r\nca0132_effects[idx].reqs[i],\r\nca0132_effects[idx].def_vals[i]);\r\n}\r\n}\r\ntmp = FLOAT_ZERO;\r\ndspio_set_uint_param(codec, 0x96, 0x3C, tmp);\r\ndspio_set_uint_param(codec, 0x8f, 0x01, tmp);\r\ntmp = FLOAT_ONE;\r\ndspio_set_uint_param(codec, 0x80, 0x00, tmp);\r\ndspio_set_uint_param(codec, 0x80, 0x01, tmp);\r\ntmp = FLOAT_ONE;\r\ndspio_set_uint_param(codec, 0x80, 0x05, tmp);\r\ntmp = FLOAT_TWO;\r\ndspio_set_uint_param(codec, 0x31, 0x00, tmp);\r\n}\r\nstatic void ca0132_init_flags(struct hda_codec *codec)\r\n{\r\nchipio_set_control_flag(codec, CONTROL_FLAG_IDLE_ENABLE, 0);\r\nchipio_set_control_flag(codec, CONTROL_FLAG_PORT_A_COMMON_MODE, 0);\r\nchipio_set_control_flag(codec, CONTROL_FLAG_PORT_D_COMMON_MODE, 0);\r\nchipio_set_control_flag(codec, CONTROL_FLAG_PORT_A_10KOHM_LOAD, 0);\r\nchipio_set_control_flag(codec, CONTROL_FLAG_PORT_D_10KOHM_LOAD, 0);\r\nchipio_set_control_flag(codec, CONTROL_FLAG_ADC_C_HIGH_PASS, 1);\r\n}\r\nstatic void ca0132_init_params(struct hda_codec *codec)\r\n{\r\nchipio_set_control_param(codec, CONTROL_PARAM_PORTA_160OHM_GAIN, 6);\r\nchipio_set_control_param(codec, CONTROL_PARAM_PORTD_160OHM_GAIN, 6);\r\n}\r\nstatic void ca0132_set_dsp_msr(struct hda_codec *codec, bool is96k)\r\n{\r\nchipio_set_control_flag(codec, CONTROL_FLAG_DSP_96KHZ, is96k);\r\nchipio_set_control_flag(codec, CONTROL_FLAG_DAC_96KHZ, is96k);\r\nchipio_set_control_flag(codec, CONTROL_FLAG_SRC_RATE_96KHZ, is96k);\r\nchipio_set_control_flag(codec, CONTROL_FLAG_SRC_CLOCK_196MHZ, is96k);\r\nchipio_set_control_flag(codec, CONTROL_FLAG_ADC_B_96KHZ, is96k);\r\nchipio_set_control_flag(codec, CONTROL_FLAG_ADC_C_96KHZ, is96k);\r\nchipio_set_conn_rate(codec, MEM_CONNID_MICIN1, SR_96_000);\r\nchipio_set_conn_rate(codec, MEM_CONNID_MICOUT1, SR_96_000);\r\nchipio_set_conn_rate(codec, MEM_CONNID_WUH, SR_48_000);\r\n}\r\nstatic bool ca0132_download_dsp_images(struct hda_codec *codec)\r\n{\r\nbool dsp_loaded = false;\r\nconst struct dsp_image_seg *dsp_os_image;\r\nconst struct firmware *fw_entry;\r\nif (request_firmware(&fw_entry, EFX_FILE, codec->bus->card->dev) != 0)\r\nreturn false;\r\ndsp_os_image = (struct dsp_image_seg *)(fw_entry->data);\r\nif (dspload_image(codec, dsp_os_image, 0, 0, true, 0)) {\r\npr_err("ca0132 dspload_image failed.\n");\r\ngoto exit_download;\r\n}\r\ndsp_loaded = dspload_wait_loaded(codec);\r\nexit_download:\r\nrelease_firmware(fw_entry);\r\nreturn dsp_loaded;\r\n}\r\nstatic void ca0132_download_dsp(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\n#ifndef CONFIG_SND_HDA_CODEC_CA0132_DSP\r\nreturn;\r\n#endif\r\nif (spec->dsp_state == DSP_DOWNLOAD_FAILED)\r\nreturn;\r\nchipio_enable_clocks(codec);\r\nspec->dsp_state = DSP_DOWNLOADING;\r\nif (!ca0132_download_dsp_images(codec))\r\nspec->dsp_state = DSP_DOWNLOAD_FAILED;\r\nelse\r\nspec->dsp_state = DSP_DOWNLOADED;\r\nif (spec->dsp_state == DSP_DOWNLOADED)\r\nca0132_set_dsp_msr(codec, true);\r\n}\r\nstatic void ca0132_process_dsp_response(struct hda_codec *codec,\r\nstruct hda_jack_callback *callback)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\ncodec_dbg(codec, "ca0132_process_dsp_response\n");\r\nif (spec->wait_scp) {\r\nif (dspio_get_response_data(codec) >= 0)\r\nspec->wait_scp = 0;\r\n}\r\ndspio_clear_response_queue(codec);\r\n}\r\nstatic void hp_callback(struct hda_codec *codec, struct hda_jack_callback *cb)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\ncancel_delayed_work_sync(&spec->unsol_hp_work);\r\nqueue_delayed_work(codec->bus->workq, &spec->unsol_hp_work,\r\nmsecs_to_jiffies(500));\r\ncb->tbl->block_report = 1;\r\n}\r\nstatic void amic_callback(struct hda_codec *codec, struct hda_jack_callback *cb)\r\n{\r\nca0132_select_mic(codec);\r\n}\r\nstatic void ca0132_init_unsol(struct hda_codec *codec)\r\n{\r\nsnd_hda_jack_detect_enable_callback(codec, UNSOL_TAG_HP, hp_callback);\r\nsnd_hda_jack_detect_enable_callback(codec, UNSOL_TAG_AMIC1,\r\namic_callback);\r\nsnd_hda_jack_detect_enable_callback(codec, UNSOL_TAG_DSP,\r\nca0132_process_dsp_response);\r\n}\r\nstatic void ca0132_init_chip(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nint num_fx;\r\nint i;\r\nunsigned int on;\r\nmutex_init(&spec->chipio_mutex);\r\nspec->cur_out_type = SPEAKER_OUT;\r\nspec->cur_mic_type = DIGITAL_MIC;\r\nspec->cur_mic_boost = 0;\r\nfor (i = 0; i < VNODES_COUNT; i++) {\r\nspec->vnode_lvol[i] = 0x5a;\r\nspec->vnode_rvol[i] = 0x5a;\r\nspec->vnode_lswitch[i] = 0;\r\nspec->vnode_rswitch[i] = 0;\r\n}\r\nnum_fx = OUT_EFFECTS_COUNT + IN_EFFECTS_COUNT;\r\nfor (i = 0; i < num_fx; i++) {\r\non = (unsigned int)ca0132_effects[i].reqs[0];\r\nspec->effects_switch[i] = on ? 1 : 0;\r\n}\r\nspec->voicefx_val = 0;\r\nspec->effects_switch[PLAY_ENHANCEMENT - EFFECT_START_NID] = 1;\r\nspec->effects_switch[CRYSTAL_VOICE - EFFECT_START_NID] = 0;\r\n#ifdef ENABLE_TUNING_CONTROLS\r\nca0132_init_tuning_defaults(codec);\r\n#endif\r\n}\r\nstatic void ca0132_exit_chip(struct hda_codec *codec)\r\n{\r\nif (dspload_is_loaded(codec))\r\ndsp_reset(codec);\r\n}\r\nstatic int ca0132_init(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nint i;\r\nif (spec->dsp_state != DSP_DOWNLOAD_FAILED)\r\nspec->dsp_state = DSP_DOWNLOAD_INIT;\r\nspec->curr_chip_addx = INVALID_CHIP_ADDRESS;\r\nsnd_hda_power_up(codec);\r\nca0132_init_unsol(codec);\r\nca0132_init_params(codec);\r\nca0132_init_flags(codec);\r\nsnd_hda_sequence_write(codec, spec->base_init_verbs);\r\nca0132_download_dsp(codec);\r\nca0132_refresh_widget_caps(codec);\r\nca0132_setup_defaults(codec);\r\nca0132_init_analog_mic2(codec);\r\nca0132_init_dmic(codec);\r\nfor (i = 0; i < spec->num_outputs; i++)\r\ninit_output(codec, spec->out_pins[i], spec->dacs[0]);\r\ninit_output(codec, cfg->dig_out_pins[0], spec->dig_out);\r\nfor (i = 0; i < spec->num_inputs; i++)\r\ninit_input(codec, spec->input_pins[i], spec->adcs[i]);\r\ninit_input(codec, cfg->dig_in_pin, spec->dig_in);\r\nfor (i = 0; i < spec->num_init_verbs; i++)\r\nsnd_hda_sequence_write(codec, spec->init_verbs[i]);\r\nca0132_select_out(codec);\r\nca0132_select_mic(codec);\r\nsnd_hda_jack_report_sync(codec);\r\nsnd_hda_power_down(codec);\r\nreturn 0;\r\n}\r\nstatic void ca0132_free(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\ncancel_delayed_work_sync(&spec->unsol_hp_work);\r\nsnd_hda_power_up(codec);\r\nsnd_hda_sequence_write(codec, spec->base_exit_verbs);\r\nca0132_exit_chip(codec);\r\nsnd_hda_power_down(codec);\r\nkfree(codec->spec);\r\n}\r\nstatic void ca0132_config(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->autocfg;\r\nspec->dacs[0] = 0x2;\r\nspec->dacs[1] = 0x3;\r\nspec->dacs[2] = 0x4;\r\nspec->multiout.dac_nids = spec->dacs;\r\nspec->multiout.num_dacs = 3;\r\nspec->multiout.max_channels = 2;\r\nspec->num_outputs = 2;\r\nspec->out_pins[0] = 0x0b;\r\nspec->out_pins[1] = 0x10;\r\nspec->shared_out_nid = 0x2;\r\nspec->num_inputs = 3;\r\nspec->adcs[0] = 0x7;\r\nspec->adcs[1] = 0x8;\r\nspec->adcs[2] = 0xa;\r\nspec->shared_mic_nid = 0x7;\r\nspec->input_pins[0] = 0x12;\r\nspec->input_pins[1] = 0x11;\r\nspec->input_pins[2] = 0x13;\r\nspec->dig_out = 0x05;\r\nspec->multiout.dig_out_nid = spec->dig_out;\r\ncfg->dig_out_pins[0] = 0x0c;\r\ncfg->dig_outs = 1;\r\ncfg->dig_out_type[0] = HDA_PCM_TYPE_SPDIF;\r\nspec->dig_in = 0x09;\r\ncfg->dig_in_pin = 0x0e;\r\ncfg->dig_in_type = HDA_PCM_TYPE_SPDIF;\r\n}\r\nstatic int patch_ca0132(struct hda_codec *codec)\r\n{\r\nstruct ca0132_spec *spec;\r\nint err;\r\ncodec_dbg(codec, "patch_ca0132\n");\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (!spec)\r\nreturn -ENOMEM;\r\ncodec->spec = spec;\r\nspec->codec = codec;\r\nspec->dsp_state = DSP_DOWNLOAD_INIT;\r\nspec->num_mixers = 1;\r\nspec->mixers[0] = ca0132_mixer;\r\nspec->base_init_verbs = ca0132_base_init_verbs;\r\nspec->base_exit_verbs = ca0132_base_exit_verbs;\r\nspec->init_verbs[0] = ca0132_init_verbs0;\r\nspec->init_verbs[1] = ca0132_init_verbs1;\r\nspec->num_init_verbs = 2;\r\nINIT_DELAYED_WORK(&spec->unsol_hp_work, ca0132_unsol_hp_delayed);\r\nca0132_init_chip(codec);\r\nca0132_config(codec);\r\nerr = snd_hda_parse_pin_def_config(codec, &spec->autocfg, NULL);\r\nif (err < 0)\r\nreturn err;\r\ncodec->patch_ops = ca0132_patch_ops;\r\ncodec->pcm_format_first = 1;\r\ncodec->no_sticky_stream = 1;\r\nreturn 0;\r\n}\r\nstatic int __init patch_ca0132_init(void)\r\n{\r\nreturn snd_hda_add_codec_preset(&ca0132_list);\r\n}\r\nstatic void __exit patch_ca0132_exit(void)\r\n{\r\nsnd_hda_delete_codec_preset(&ca0132_list);\r\n}
