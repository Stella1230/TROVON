static int r8192_wx_get_freq(struct net_device *dev,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nreturn rtllib_wx_get_freq(priv->rtllib, a, wrqu, b);\r\n}\r\nstatic int r8192_wx_get_mode(struct net_device *dev, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nreturn rtllib_wx_get_mode(priv->rtllib, a, wrqu, b);\r\n}\r\nstatic int r8192_wx_get_rate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nreturn rtllib_wx_get_rate(priv->rtllib, info, wrqu, extra);\r\n}\r\nstatic int r8192_wx_set_rate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint ret;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->bHwRadioOff == true)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nret = rtllib_wx_set_rate(priv->rtllib, info, wrqu, extra);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_set_rts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint ret;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->bHwRadioOff == true)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nret = rtllib_wx_set_rts(priv->rtllib, info, wrqu, extra);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_get_rts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nreturn rtllib_wx_get_rts(priv->rtllib, info, wrqu, extra);\r\n}\r\nstatic int r8192_wx_set_power(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint ret;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->bHwRadioOff == true) {\r\nRT_TRACE(COMP_ERR, "%s():Hw is Radio Off, we can't set "\r\n"Power,return\n", __func__);\r\nreturn 0;\r\n}\r\ndown(&priv->wx_sem);\r\nret = rtllib_wx_set_power(priv->rtllib, info, wrqu, extra);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_get_power(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nreturn rtllib_wx_get_power(priv->rtllib, info, wrqu, extra);\r\n}\r\nstatic int r8192_wx_set_rawtx(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nint ret;\r\nif (priv->bHwRadioOff == true)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nret = rtllib_wx_set_rawtx(priv->rtllib, info, wrqu, extra);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_force_reset(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\ndown(&priv->wx_sem);\r\nRT_TRACE(COMP_DBG, "%s(): force reset ! extra is %d\n",\r\n__func__, *extra);\r\npriv->force_reset = *extra;\r\nup(&priv->wx_sem);\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_force_mic_error(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\ndown(&priv->wx_sem);\r\nRT_TRACE(COMP_DBG, "%s(): force mic error !\n", __func__);\r\nieee->force_mic_error = true;\r\nup(&priv->wx_sem);\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_get_adhoc_peers(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nreturn 0;\r\n}\r\nstatic int r8191se_wx_get_firm_version(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nstruct iw_param *wrqu, char *extra)\r\n{\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_adapter_power_status(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)\r\n(&(priv->rtllib->PowerSaveControl));\r\nstruct rtllib_device *ieee = priv->rtllib;\r\ndown(&priv->wx_sem);\r\nRT_TRACE(COMP_POWER, "%s(): %s\n", __func__, (*extra == 6) ?\r\n"DC power" : "AC power");\r\nif (*extra || priv->force_lps) {\r\npriv->ps_force = false;\r\npPSC->bLeisurePs = true;\r\n} else {\r\nif (priv->rtllib->state == RTLLIB_LINKED)\r\nLeisurePSLeave(dev);\r\npriv->ps_force = true;\r\npPSC->bLeisurePs = false;\r\nieee->ps = *extra;\r\n}\r\nup(&priv->wx_sem);\r\nreturn 0;\r\n}\r\nstatic int r8192se_wx_set_radio(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\ndown(&priv->wx_sem);\r\nprintk(KERN_INFO "%s(): set radio ! extra is %d\n", __func__, *extra);\r\nif ((*extra != 0) && (*extra != 1)) {\r\nRT_TRACE(COMP_ERR, "%s(): set radio an err value,must 0(radio "\r\n"off) or 1(radio on)\n", __func__);\r\nup(&priv->wx_sem);\r\nreturn -1;\r\n}\r\npriv->sw_radio_on = *extra;\r\nup(&priv->wx_sem);\r\nreturn 0;\r\n}\r\nstatic int r8192se_wx_set_lps_awake_interval(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)\r\n(&(priv->rtllib->PowerSaveControl));\r\ndown(&priv->wx_sem);\r\nprintk(KERN_INFO "%s(): set lps awake interval ! extra is %d\n",\r\n__func__, *extra);\r\npPSC->RegMaxLPSAwakeIntvl = *extra;\r\nup(&priv->wx_sem);\r\nreturn 0;\r\n}\r\nstatic int r8192se_wx_set_force_lps(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\ndown(&priv->wx_sem);\r\nprintk(KERN_INFO "%s(): force LPS ! extra is %d (1 is open 0 is "\r\n"close)\n", __func__, *extra);\r\npriv->force_lps = *extra;\r\nup(&priv->wx_sem);\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_set_debugflag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 c = *extra;\r\nif (priv->bHwRadioOff == true)\r\nreturn 0;\r\nprintk(KERN_INFO "=====>%s(), *extra:%x, debugflag:%x\n", __func__,\r\n*extra, rt_global_debug_component);\r\nif (c > 0)\r\nrt_global_debug_component |= (1<<c);\r\nelse\r\nrt_global_debug_component &= BIT31;\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_set_mode(struct net_device *dev, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = netdev_priv_rsl(dev);\r\nenum rt_rf_power_state rtState;\r\nint ret;\r\nif (priv->bHwRadioOff == true)\r\nreturn 0;\r\nrtState = priv->rtllib->eRFPowerState;\r\ndown(&priv->wx_sem);\r\nif (wrqu->mode == IW_MODE_ADHOC || wrqu->mode == IW_MODE_MONITOR ||\r\nieee->bNetPromiscuousMode) {\r\nif (priv->rtllib->PowerSaveControl.bInactivePs) {\r\nif (rtState == eRfOff) {\r\nif (priv->rtllib->RfOffReason >\r\nRF_CHANGE_BY_IPS) {\r\nRT_TRACE(COMP_ERR, "%s(): RF is OFF.\n",\r\n__func__);\r\nup(&priv->wx_sem);\r\nreturn -1;\r\n} else {\r\nprintk(KERN_INFO "=========>%s(): "\r\n"IPSLeave\n", __func__);\r\ndown(&priv->rtllib->ips_sem);\r\nIPSLeave(dev);\r\nup(&priv->rtllib->ips_sem);\r\n}\r\n}\r\n}\r\n}\r\nret = rtllib_wx_set_mode(priv->rtllib, a, wrqu, b);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int rtl8192_wx_get_range(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct iw_range *range = (struct iw_range *)extra;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu16 val;\r\nint i;\r\nwrqu->data.length = sizeof(*range);\r\nmemset(range, 0, sizeof(*range));\r\nrange->throughput = 130 * 1000 * 1000;\r\nif (priv->rf_set_sens != NULL) {\r\nrange->sensitivity = priv->max_sens;\r\n}\r\nrange->max_qual.qual = 100;\r\nrange->max_qual.level = 0;\r\nrange->max_qual.noise = 0;\r\nrange->max_qual.updated = 7;\r\nrange->avg_qual.qual = 70;\r\nrange->avg_qual.level = 0;\r\nrange->avg_qual.noise = 0;\r\nrange->avg_qual.updated = 7;\r\nrange->num_bitrates = min(RATE_COUNT, IW_MAX_BITRATES);\r\nfor (i = 0; i < range->num_bitrates; i++)\r\nrange->bitrate[i] = rtl8192_rates[i];\r\nrange->max_rts = DEFAULT_RTS_THRESHOLD;\r\nrange->min_frag = MIN_FRAG_THRESHOLD;\r\nrange->max_frag = MAX_FRAG_THRESHOLD;\r\nrange->min_pmp = 0;\r\nrange->max_pmp = 5000000;\r\nrange->min_pmt = 0;\r\nrange->max_pmt = 65535*1000;\r\nrange->pmp_flags = IW_POWER_PERIOD;\r\nrange->pmt_flags = IW_POWER_TIMEOUT;\r\nrange->pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT | IW_POWER_ALL_R;\r\nrange->we_version_compiled = WIRELESS_EXT;\r\nrange->we_version_source = 18;\r\nfor (i = 0, val = 0; i < 14; i++) {\r\nif ((priv->rtllib->active_channel_map)[i+1]) {\r\nrange->freq[val].i = i + 1;\r\nrange->freq[val].m = rtllib_wlan_frequencies[i] *\r\n100000;\r\nrange->freq[val].e = 1;\r\nval++;\r\n}\r\nif (val == IW_MAX_FREQUENCIES)\r\nbreak;\r\n}\r\nrange->num_frequency = val;\r\nrange->num_channels = val;\r\nrange->enc_capa = IW_ENC_CAPA_WPA|IW_ENC_CAPA_WPA2|\r\nIW_ENC_CAPA_CIPHER_TKIP|IW_ENC_CAPA_CIPHER_CCMP;\r\nrange->scan_capa = IW_SCAN_CAPA_ESSID | IW_SCAN_CAPA_TYPE;\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_set_scan(struct net_device *dev, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nenum rt_rf_power_state rtState;\r\nint ret;\r\nif (!(ieee->softmac_features & IEEE_SOFTMAC_SCAN)) {\r\nif ((ieee->state >= RTLLIB_ASSOCIATING) &&\r\n(ieee->state <= RTLLIB_ASSOCIATING_AUTHENTICATED))\r\nreturn 0;\r\nif ((priv->rtllib->state == RTLLIB_LINKED) &&\r\n(priv->rtllib->CntAfterLink < 2))\r\nreturn 0;\r\n}\r\nif (priv->bHwRadioOff == true) {\r\nprintk(KERN_INFO "================>%s(): hwradio off\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nrtState = priv->rtllib->eRFPowerState;\r\nif (!priv->up)\r\nreturn -ENETDOWN;\r\nif (priv->rtllib->LinkDetectInfo.bBusyTraffic == true)\r\nreturn -EAGAIN;\r\nif (wrqu->data.flags & IW_SCAN_THIS_ESSID) {\r\nstruct iw_scan_req *req = (struct iw_scan_req *)b;\r\nif (req->essid_len) {\r\nieee->current_network.ssid_len = req->essid_len;\r\nmemcpy(ieee->current_network.ssid, req->essid,\r\nreq->essid_len);\r\n}\r\n}\r\ndown(&priv->wx_sem);\r\npriv->rtllib->FirstIe_InScan = true;\r\nif (priv->rtllib->state != RTLLIB_LINKED) {\r\nif (priv->rtllib->PowerSaveControl.bInactivePs) {\r\nif (rtState == eRfOff) {\r\nif (priv->rtllib->RfOffReason >\r\nRF_CHANGE_BY_IPS) {\r\nRT_TRACE(COMP_ERR, "%s(): RF is "\r\n"OFF.\n", __func__);\r\nup(&priv->wx_sem);\r\nreturn -1;\r\n} else {\r\nRT_TRACE(COMP_PS, "=========>%s(): "\r\n"IPSLeave\n", __func__);\r\ndown(&priv->rtllib->ips_sem);\r\nIPSLeave(dev);\r\nup(&priv->rtllib->ips_sem);\r\n}\r\n}\r\n}\r\nrtllib_stop_scan(priv->rtllib);\r\nif (priv->rtllib->LedControlHandler)\r\npriv->rtllib->LedControlHandler(dev,\r\nLED_CTL_SITE_SURVEY);\r\nif (priv->rtllib->eRFPowerState != eRfOff) {\r\npriv->rtllib->actscanning = true;\r\nif (ieee->ScanOperationBackupHandler)\r\nieee->ScanOperationBackupHandler(ieee->dev,\r\nSCAN_OPT_BACKUP);\r\nrtllib_start_scan_syncro(priv->rtllib, 0);\r\nif (ieee->ScanOperationBackupHandler)\r\nieee->ScanOperationBackupHandler(ieee->dev,\r\nSCAN_OPT_RESTORE);\r\n}\r\nret = 0;\r\n} else {\r\npriv->rtllib->actscanning = true;\r\nret = rtllib_wx_set_scan(priv->rtllib, a, wrqu, b);\r\n}\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_get_scan(struct net_device *dev, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nint ret;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (!priv->up)\r\nreturn -ENETDOWN;\r\nif (priv->bHwRadioOff == true)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nret = rtllib_wx_get_scan(priv->rtllib, a, wrqu, b);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_set_essid(struct net_device *dev,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nint ret;\r\nif ((rtllib_act_scanning(priv->rtllib, false)) &&\r\n!(priv->rtllib->softmac_features & IEEE_SOFTMAC_SCAN)) {\r\n;\r\n}\r\nif (priv->bHwRadioOff == true) {\r\nprintk(KERN_INFO "=========>%s():hw radio off,or Rf state is "\r\n"eRfOff, return\n", __func__);\r\nreturn 0;\r\n}\r\ndown(&priv->wx_sem);\r\nret = rtllib_wx_set_essid(priv->rtllib, a, wrqu, b);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_get_essid(struct net_device *dev,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nint ret;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\ndown(&priv->wx_sem);\r\nret = rtllib_wx_get_essid(priv->rtllib, a, wrqu, b);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_set_nick(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (wrqu->data.length > IW_ESSID_MAX_SIZE)\r\nreturn -E2BIG;\r\ndown(&priv->wx_sem);\r\nwrqu->data.length = min_t(size_t, wrqu->data.length, sizeof(priv->nick));\r\nmemset(priv->nick, 0, sizeof(priv->nick));\r\nmemcpy(priv->nick, extra, wrqu->data.length);\r\nup(&priv->wx_sem);\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_get_nick(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\ndown(&priv->wx_sem);\r\nwrqu->data.length = strlen(priv->nick);\r\nmemcpy(extra, priv->nick, wrqu->data.length);\r\nwrqu->data.flags = 1;\r\nup(&priv->wx_sem);\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_set_freq(struct net_device *dev, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nint ret;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->bHwRadioOff == true)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nret = rtllib_wx_set_freq(priv->rtllib, a, wrqu, b);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_get_name(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nreturn rtllib_wx_get_name(priv->rtllib, info, wrqu, extra);\r\n}\r\nstatic int r8192_wx_set_frag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->bHwRadioOff == true)\r\nreturn 0;\r\nif (wrqu->frag.disabled)\r\npriv->rtllib->fts = DEFAULT_FRAG_THRESHOLD;\r\nelse {\r\nif (wrqu->frag.value < MIN_FRAG_THRESHOLD ||\r\nwrqu->frag.value > MAX_FRAG_THRESHOLD)\r\nreturn -EINVAL;\r\npriv->rtllib->fts = wrqu->frag.value & ~0x1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_get_frag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nwrqu->frag.value = priv->rtllib->fts;\r\nwrqu->frag.fixed = 0;\r\nwrqu->frag.disabled = (wrqu->frag.value == DEFAULT_FRAG_THRESHOLD);\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_set_wap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *awrq,\r\nchar *extra)\r\n{\r\nint ret;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif ((rtllib_act_scanning(priv->rtllib, false)) &&\r\n!(priv->rtllib->softmac_features & IEEE_SOFTMAC_SCAN)) {\r\n;\r\n}\r\nif (priv->bHwRadioOff == true)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nret = rtllib_wx_set_wap(priv->rtllib, info, awrq, extra);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_get_wap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nreturn rtllib_wx_get_wap(priv->rtllib, info, wrqu, extra);\r\n}\r\nstatic int r8192_wx_get_enc(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *key)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nreturn rtllib_wx_get_encode(priv->rtllib, info, wrqu, key);\r\n}\r\nstatic int r8192_wx_set_enc(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *key)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nint ret;\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nu32 hwkey[4] = {0, 0, 0, 0};\r\nu8 mask = 0xff;\r\nu32 key_idx = 0;\r\nu8 zero_addr[4][6] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x01},\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x02},\r\n{0x00, 0x00, 0x00, 0x00, 0x00, 0x03} };\r\nint i;\r\nif ((rtllib_act_scanning(priv->rtllib, false)) &&\r\n!(priv->rtllib->softmac_features & IEEE_SOFTMAC_SCAN))\r\n;\r\nif (priv->bHwRadioOff == true)\r\nreturn 0;\r\nif (!priv->up)\r\nreturn -ENETDOWN;\r\npriv->rtllib->wx_set_enc = 1;\r\ndown(&priv->rtllib->ips_sem);\r\nIPSLeave(dev);\r\nup(&priv->rtllib->ips_sem);\r\ndown(&priv->wx_sem);\r\nRT_TRACE(COMP_SEC, "Setting SW wep key");\r\nret = rtllib_wx_set_encode(priv->rtllib, info, wrqu, key);\r\nup(&priv->wx_sem);\r\nif (wrqu->encoding.flags & IW_ENCODE_DISABLED) {\r\nieee->pairwise_key_type = ieee->group_key_type = KEY_TYPE_NA;\r\nCamResetAllEntry(dev);\r\nmemset(priv->rtllib->swcamtable, 0,\r\nsizeof(struct sw_cam_table) * 32);\r\ngoto end_hw_sec;\r\n}\r\nif (wrqu->encoding.length != 0) {\r\nfor (i = 0; i < 4; i++) {\r\nhwkey[i] |= key[4*i+0]&mask;\r\nif (i == 1 && (4 * i + 1) == wrqu->encoding.length)\r\nmask = 0x00;\r\nif (i == 3 && (4 * i + 1) == wrqu->encoding.length)\r\nmask = 0x00;\r\nhwkey[i] |= (key[4 * i + 1] & mask) << 8;\r\nhwkey[i] |= (key[4 * i + 2] & mask) << 16;\r\nhwkey[i] |= (key[4 * i + 3] & mask) << 24;\r\n}\r\n#define CONF_WEP40 0x4\r\n#define CONF_WEP104 0x14\r\nswitch (wrqu->encoding.flags & IW_ENCODE_INDEX) {\r\ncase 0:\r\nkey_idx = ieee->crypt_info.tx_keyidx;\r\nbreak;\r\ncase 1:\r\nkey_idx = 0;\r\nbreak;\r\ncase 2:\r\nkey_idx = 1;\r\nbreak;\r\ncase 3:\r\nkey_idx = 2;\r\nbreak;\r\ncase 4:\r\nkey_idx = 3;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (wrqu->encoding.length == 0x5) {\r\nieee->pairwise_key_type = KEY_TYPE_WEP40;\r\nEnableHWSecurityConfig8192(dev);\r\n}\r\nelse if (wrqu->encoding.length == 0xd) {\r\nieee->pairwise_key_type = KEY_TYPE_WEP104;\r\nEnableHWSecurityConfig8192(dev);\r\nsetKey(dev, key_idx, key_idx, KEY_TYPE_WEP104,\r\nzero_addr[key_idx], 0, hwkey);\r\nset_swcam(dev, key_idx, key_idx, KEY_TYPE_WEP104,\r\nzero_addr[key_idx], 0, hwkey, 0);\r\n} else {\r\nprintk(KERN_INFO "wrong type in WEP, not WEP40 and WEP104\n");\r\n}\r\n}\r\nend_hw_sec:\r\npriv->rtllib->wx_set_enc = 0;\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_set_scan_type(struct net_device *dev,\r\nstruct iw_request_info *aa,\r\nunion iwreq_data *wrqu, char *p)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nint *parms = (int *)p;\r\nint mode = parms[0];\r\nif (priv->bHwRadioOff == true)\r\nreturn 0;\r\npriv->rtllib->active_scan = mode;\r\nreturn 1;\r\n}\r\nstatic int r8192_wx_set_retry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nint err = 0;\r\nif (priv->bHwRadioOff == true)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nif (wrqu->retry.flags & IW_RETRY_LIFETIME ||\r\nwrqu->retry.disabled) {\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nif (!(wrqu->retry.flags & IW_RETRY_LIMIT)) {\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nif (wrqu->retry.value > R8192_MAX_RETRY) {\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\nif (wrqu->retry.flags & IW_RETRY_MAX) {\r\npriv->retry_rts = wrqu->retry.value;\r\nDMESG("Setting retry for RTS/CTS data to %d",\r\nwrqu->retry.value);\r\n} else {\r\npriv->retry_data = wrqu->retry.value;\r\nDMESG("Setting retry for non RTS/CTS data to %d",\r\nwrqu->retry.value);\r\n}\r\nrtl8192_commit(dev);\r\nexit:\r\nup(&priv->wx_sem);\r\nreturn err;\r\n}\r\nstatic int r8192_wx_get_retry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nwrqu->retry.disabled = 0;\r\nif ((wrqu->retry.flags & IW_RETRY_TYPE) ==\r\nIW_RETRY_LIFETIME)\r\nreturn -EINVAL;\r\nif (wrqu->retry.flags & IW_RETRY_MAX) {\r\nwrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_MAX;\r\nwrqu->retry.value = priv->retry_rts;\r\n} else {\r\nwrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_MIN;\r\nwrqu->retry.value = priv->retry_data;\r\n}\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_get_sens(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->rf_set_sens == NULL)\r\nreturn -1;\r\nwrqu->sens.value = priv->sens;\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_set_sens(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nshort err = 0;\r\nif (priv->bHwRadioOff == true)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nif (priv->rf_set_sens == NULL) {\r\nerr = -1;\r\ngoto exit;\r\n}\r\nif (priv->rf_set_sens(dev, wrqu->sens.value) == 0)\r\npriv->sens = wrqu->sens.value;\r\nelse\r\nerr = -EINVAL;\r\nexit:\r\nup(&priv->wx_sem);\r\nreturn err;\r\n}\r\nstatic int r8192_wx_set_enc_ext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint ret = 0;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nif (priv->bHwRadioOff == true)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\npriv->rtllib->wx_set_enc = 1;\r\ndown(&priv->rtllib->ips_sem);\r\nIPSLeave(dev);\r\nup(&priv->rtllib->ips_sem);\r\nret = rtllib_wx_set_encode_ext(ieee, info, wrqu, extra);\r\n{\r\nu8 broadcast_addr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nu8 zero[6] = {0};\r\nu32 key[4] = {0};\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\r\nstruct iw_point *encoding = &wrqu->encoding;\r\nu8 idx = 0, alg = 0, group = 0;\r\nif ((encoding->flags & IW_ENCODE_DISABLED) ||\r\next->alg == IW_ENCODE_ALG_NONE) {\r\nieee->pairwise_key_type = ieee->group_key_type\r\n= KEY_TYPE_NA;\r\nCamResetAllEntry(dev);\r\nmemset(priv->rtllib->swcamtable, 0,\r\nsizeof(struct sw_cam_table) * 32);\r\ngoto end_hw_sec;\r\n}\r\nalg = (ext->alg == IW_ENCODE_ALG_CCMP) ? KEY_TYPE_CCMP :\r\next->alg;\r\nidx = encoding->flags & IW_ENCODE_INDEX;\r\nif (idx)\r\nidx--;\r\ngroup = ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY;\r\nif ((!group) || (IW_MODE_ADHOC == ieee->iw_mode) ||\r\n(alg == KEY_TYPE_WEP40)) {\r\nif ((ext->key_len == 13) && (alg == KEY_TYPE_WEP40))\r\nalg = KEY_TYPE_WEP104;\r\nieee->pairwise_key_type = alg;\r\nEnableHWSecurityConfig8192(dev);\r\n}\r\nmemcpy((u8 *)key, ext->key, 16);\r\nif ((alg & KEY_TYPE_WEP40) && (ieee->auth_mode != 2)) {\r\nif (ext->key_len == 13)\r\nieee->pairwise_key_type = alg = KEY_TYPE_WEP104;\r\nsetKey(dev, idx, idx, alg, zero, 0, key);\r\nset_swcam(dev, idx, idx, alg, zero, 0, key, 0);\r\n} else if (group) {\r\nieee->group_key_type = alg;\r\nsetKey(dev, idx, idx, alg, broadcast_addr, 0, key);\r\nset_swcam(dev, idx, idx, alg, broadcast_addr, 0,\r\nkey, 0);\r\n} else {\r\nif ((ieee->pairwise_key_type == KEY_TYPE_CCMP) &&\r\nieee->pHTInfo->bCurrentHTSupport)\r\nwrite_nic_byte(dev, 0x173, 1);\r\nsetKey(dev, 4, idx, alg, (u8 *)ieee->ap_mac_addr,\r\n0, key);\r\nset_swcam(dev, 4, idx, alg, (u8 *)ieee->ap_mac_addr,\r\n0, key, 0);\r\n}\r\n}\r\nend_hw_sec:\r\npriv->rtllib->wx_set_enc = 0;\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_set_auth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\nint ret = 0;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->bHwRadioOff == true)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nret = rtllib_wx_set_auth(priv->rtllib, info, &(data->param), extra);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_set_mlme(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint ret = 0;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->bHwRadioOff == true)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nret = rtllib_wx_set_mlme(priv->rtllib, info, wrqu, extra);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_set_gen_ie(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\nint ret = 0;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->bHwRadioOff == true)\r\nreturn 0;\r\ndown(&priv->wx_sem);\r\nret = rtllib_wx_set_gen_ie(priv->rtllib, extra, data->data.length);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_get_gen_ie(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *data, char *extra)\r\n{\r\nint ret = 0;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nif (ieee->wpa_ie_len == 0 || ieee->wpa_ie == NULL) {\r\ndata->data.length = 0;\r\nreturn 0;\r\n}\r\nif (data->data.length < ieee->wpa_ie_len)\r\nreturn -E2BIG;\r\ndata->data.length = ieee->wpa_ie_len;\r\nmemcpy(extra, ieee->wpa_ie, ieee->wpa_ie_len);\r\nreturn ret;\r\n}\r\nstatic int r8192_wx_set_PromiscuousMode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nu32 info_buf[3];\r\nu32 oid;\r\nu32 bPromiscuousOn;\r\nu32 bFilterSourceStationFrame;\r\nif (copy_from_user(info_buf, wrqu->data.pointer, sizeof(info_buf)))\r\nreturn -EFAULT;\r\noid = info_buf[0];\r\nbPromiscuousOn = info_buf[1];\r\nbFilterSourceStationFrame = info_buf[2];\r\nif (OID_RT_INTEL_PROMISCUOUS_MODE == oid) {\r\nieee->IntelPromiscuousModeInfo.bPromiscuousOn =\r\n(bPromiscuousOn) ? (true) : (false);\r\nieee->IntelPromiscuousModeInfo.bFilterSourceStationFrame =\r\n(bFilterSourceStationFrame) ? (true) : (false);\r\n(bPromiscuousOn) ?\r\n(rtllib_EnableIntelPromiscuousMode(dev, false)) :\r\n(rtllib_DisableIntelPromiscuousMode(dev, false));\r\nprintk(KERN_INFO "=======>%s(), on = %d, filter src sta = %d\n",\r\n__func__, bPromiscuousOn, bFilterSourceStationFrame);\r\n} else {\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int r8192_wx_get_PromiscuousMode(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\ndown(&priv->wx_sem);\r\nsnprintf(extra, 45, "PromiscuousMode:%d, FilterSrcSTAFrame:%d",\r\nieee->IntelPromiscuousModeInfo.bPromiscuousOn,\r\nieee->IntelPromiscuousModeInfo.bFilterSourceStationFrame);\r\nwrqu->data.length = strlen(extra) + 1;\r\nup(&priv->wx_sem);\r\nreturn 0;\r\n}\r\nstatic struct iw_statistics *r8192_get_wireless_stats(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nstruct iw_statistics *wstats = &priv->wstats;\r\nint tmp_level = 0;\r\nint tmp_qual = 0;\r\nint tmp_noise = 0;\r\nif (ieee->state < RTLLIB_LINKED) {\r\nwstats->qual.qual = 10;\r\nwstats->qual.level = 0;\r\nwstats->qual.noise = -100;\r\nwstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\r\nreturn wstats;\r\n}\r\ntmp_level = (&ieee->current_network)->stats.rssi;\r\ntmp_qual = (&ieee->current_network)->stats.signal;\r\ntmp_noise = (&ieee->current_network)->stats.noise;\r\nwstats->qual.level = tmp_level;\r\nwstats->qual.qual = tmp_qual;\r\nwstats->qual.noise = tmp_noise;\r\nwstats->qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\r\nreturn wstats;\r\n}
