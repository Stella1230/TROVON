static int __init hash_setup(char *str)\r\n{\r\nstruct ima_template_desc *template_desc = ima_template_desc_current();\r\nint i;\r\nif (hash_setup_done)\r\nreturn 1;\r\nif (strcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) == 0) {\r\nif (strncmp(str, "sha1", 4) == 0)\r\nima_hash_algo = HASH_ALGO_SHA1;\r\nelse if (strncmp(str, "md5", 3) == 0)\r\nima_hash_algo = HASH_ALGO_MD5;\r\ngoto out;\r\n}\r\nfor (i = 0; i < HASH_ALGO__LAST; i++) {\r\nif (strcmp(str, hash_algo_name[i]) == 0) {\r\nima_hash_algo = i;\r\nbreak;\r\n}\r\n}\r\nout:\r\nhash_setup_done = 1;\r\nreturn 1;\r\n}\r\nstatic void ima_rdwr_violation_check(struct file *file,\r\nstruct integrity_iint_cache *iint,\r\nint must_measure,\r\nchar **pathbuf,\r\nconst char **pathname)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nfmode_t mode = file->f_mode;\r\nbool send_tomtou = false, send_writers = false;\r\nif (mode & FMODE_WRITE) {\r\nif (atomic_read(&inode->i_readcount) && IS_IMA(inode)) {\r\nif (!iint)\r\niint = integrity_iint_find(inode);\r\nif (iint && (iint->flags & IMA_MEASURE))\r\nsend_tomtou = true;\r\n}\r\n} else {\r\nif ((atomic_read(&inode->i_writecount) > 0) && must_measure)\r\nsend_writers = true;\r\n}\r\nif (!send_tomtou && !send_writers)\r\nreturn;\r\n*pathname = ima_d_path(&file->f_path, pathbuf);\r\nif (send_tomtou)\r\nima_add_violation(file, *pathname, "invalid_pcr", "ToMToU");\r\nif (send_writers)\r\nima_add_violation(file, *pathname,\r\n"invalid_pcr", "open_writers");\r\n}\r\nstatic void ima_check_last_writer(struct integrity_iint_cache *iint,\r\nstruct inode *inode, struct file *file)\r\n{\r\nfmode_t mode = file->f_mode;\r\nif (!(mode & FMODE_WRITE))\r\nreturn;\r\nmutex_lock(&inode->i_mutex);\r\nif (atomic_read(&inode->i_writecount) == 1) {\r\nif ((iint->version != inode->i_version) ||\r\n(iint->flags & IMA_NEW_FILE)) {\r\niint->flags &= ~(IMA_DONE_MASK | IMA_NEW_FILE);\r\nif (iint->flags & IMA_APPRAISE)\r\nima_update_xattr(iint, file);\r\n}\r\n}\r\nmutex_unlock(&inode->i_mutex);\r\n}\r\nvoid ima_file_free(struct file *file)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nstruct integrity_iint_cache *iint;\r\nif (!ima_policy_flag || !S_ISREG(inode->i_mode))\r\nreturn;\r\niint = integrity_iint_find(inode);\r\nif (!iint)\r\nreturn;\r\nima_check_last_writer(iint, inode, file);\r\n}\r\nstatic int process_measurement(struct file *file, int mask, int function,\r\nint opened)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nstruct integrity_iint_cache *iint = NULL;\r\nstruct ima_template_desc *template_desc;\r\nchar *pathbuf = NULL;\r\nconst char *pathname = NULL;\r\nint rc = -ENOMEM, action, must_appraise;\r\nstruct evm_ima_xattr_data *xattr_value = NULL, **xattr_ptr = NULL;\r\nint xattr_len = 0;\r\nbool violation_check;\r\nif (!ima_policy_flag || !S_ISREG(inode->i_mode))\r\nreturn 0;\r\naction = ima_get_action(inode, mask, function);\r\nviolation_check = ((function == FILE_CHECK || function == MMAP_CHECK) &&\r\n(ima_policy_flag & IMA_MEASURE));\r\nif (!action && !violation_check)\r\nreturn 0;\r\nmust_appraise = action & IMA_APPRAISE;\r\nif (action & IMA_FILE_APPRAISE)\r\nfunction = FILE_CHECK;\r\nmutex_lock(&inode->i_mutex);\r\nif (action) {\r\niint = integrity_inode_get(inode);\r\nif (!iint)\r\ngoto out;\r\n}\r\nif (violation_check) {\r\nima_rdwr_violation_check(file, iint, action & IMA_MEASURE,\r\n&pathbuf, &pathname);\r\nif (!action) {\r\nrc = 0;\r\ngoto out_free;\r\n}\r\n}\r\niint->flags |= action;\r\naction &= IMA_DO_MASK;\r\naction &= ~((iint->flags & IMA_DONE_MASK) >> 1);\r\nif (!action) {\r\nif (must_appraise)\r\nrc = ima_get_cache_status(iint, function);\r\ngoto out_digsig;\r\n}\r\ntemplate_desc = ima_template_desc_current();\r\nif ((action & IMA_APPRAISE_SUBMASK) ||\r\nstrcmp(template_desc->name, IMA_TEMPLATE_IMA_NAME) != 0)\r\nxattr_ptr = &xattr_value;\r\nrc = ima_collect_measurement(iint, file, xattr_ptr, &xattr_len);\r\nif (rc != 0) {\r\nif (file->f_flags & O_DIRECT)\r\nrc = (iint->flags & IMA_PERMIT_DIRECTIO) ? 0 : -EACCES;\r\ngoto out_digsig;\r\n}\r\nif (!pathname)\r\npathname = ima_d_path(&file->f_path, &pathbuf);\r\nif (action & IMA_MEASURE)\r\nima_store_measurement(iint, file, pathname,\r\nxattr_value, xattr_len);\r\nif (action & IMA_APPRAISE_SUBMASK)\r\nrc = ima_appraise_measurement(function, iint, file, pathname,\r\nxattr_value, xattr_len, opened);\r\nif (action & IMA_AUDIT)\r\nima_audit_measurement(iint, pathname);\r\nout_digsig:\r\nif ((mask & MAY_WRITE) && (iint->flags & IMA_DIGSIG))\r\nrc = -EACCES;\r\nkfree(xattr_value);\r\nout_free:\r\nif (pathbuf)\r\n__putname(pathbuf);\r\nout:\r\nmutex_unlock(&inode->i_mutex);\r\nif ((rc && must_appraise) && (ima_appraise & IMA_APPRAISE_ENFORCE))\r\nreturn -EACCES;\r\nreturn 0;\r\n}\r\nint ima_file_mmap(struct file *file, unsigned long prot)\r\n{\r\nif (file && (prot & PROT_EXEC))\r\nreturn process_measurement(file, MAY_EXEC, MMAP_CHECK, 0);\r\nreturn 0;\r\n}\r\nint ima_bprm_check(struct linux_binprm *bprm)\r\n{\r\nreturn process_measurement(bprm->file, MAY_EXEC, BPRM_CHECK, 0);\r\n}\r\nint ima_file_check(struct file *file, int mask, int opened)\r\n{\r\nreturn process_measurement(file,\r\nmask & (MAY_READ | MAY_WRITE | MAY_EXEC),\r\nFILE_CHECK, opened);\r\n}\r\nint ima_module_check(struct file *file)\r\n{\r\nif (!file) {\r\n#ifndef CONFIG_MODULE_SIG_FORCE\r\nif ((ima_appraise & IMA_APPRAISE_MODULES) &&\r\n(ima_appraise & IMA_APPRAISE_ENFORCE))\r\nreturn -EACCES;\r\n#endif\r\nreturn 0;\r\n}\r\nreturn process_measurement(file, MAY_EXEC, MODULE_CHECK, 0);\r\n}\r\nint ima_fw_from_file(struct file *file, char *buf, size_t size)\r\n{\r\nif (!file) {\r\nif ((ima_appraise & IMA_APPRAISE_FIRMWARE) &&\r\n(ima_appraise & IMA_APPRAISE_ENFORCE))\r\nreturn -EACCES;\r\nreturn 0;\r\n}\r\nreturn process_measurement(file, MAY_EXEC, FIRMWARE_CHECK, 0);\r\n}\r\nstatic int __init init_ima(void)\r\n{\r\nint error;\r\nhash_setup(CONFIG_IMA_DEFAULT_HASH);\r\nerror = ima_init();\r\nif (!error) {\r\nima_initialized = 1;\r\nima_update_policy_flag();\r\n}\r\nreturn error;\r\n}
