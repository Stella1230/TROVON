void gx_set_dclk_frequency(struct fb_info *info)\r\n{\r\nconst struct gx_pll_entry *pll_table;\r\nint pll_table_len;\r\nint i, best_i;\r\nlong min, diff;\r\nu64 dotpll, sys_rstpll;\r\nint timeout = 1000;\r\nif (cpu_data(0).x86_mask == 1) {\r\npll_table = gx_pll_table_14MHz;\r\npll_table_len = ARRAY_SIZE(gx_pll_table_14MHz);\r\n} else {\r\npll_table = gx_pll_table_48MHz;\r\npll_table_len = ARRAY_SIZE(gx_pll_table_48MHz);\r\n}\r\nbest_i = 0;\r\nmin = abs(pll_table[0].pixclock - info->var.pixclock);\r\nfor (i = 1; i < pll_table_len; i++) {\r\ndiff = abs(pll_table[i].pixclock - info->var.pixclock);\r\nif (diff < min) {\r\nmin = diff;\r\nbest_i = i;\r\n}\r\n}\r\nrdmsrl(MSR_GLCP_SYS_RSTPLL, sys_rstpll);\r\nrdmsrl(MSR_GLCP_DOTPLL, dotpll);\r\ndotpll &= 0x00000000ffffffffull;\r\ndotpll |= (u64)pll_table[best_i].dotpll_value << 32;\r\ndotpll |= MSR_GLCP_DOTPLL_DOTRESET;\r\ndotpll &= ~MSR_GLCP_DOTPLL_BYPASS;\r\nwrmsrl(MSR_GLCP_DOTPLL, dotpll);\r\nsys_rstpll &= ~( MSR_GLCP_SYS_RSTPLL_DOTPREDIV2\r\n| MSR_GLCP_SYS_RSTPLL_DOTPREMULT2\r\n| MSR_GLCP_SYS_RSTPLL_DOTPOSTDIV3 );\r\nsys_rstpll |= pll_table[best_i].sys_rstpll_bits;\r\nwrmsrl(MSR_GLCP_SYS_RSTPLL, sys_rstpll);\r\ndotpll &= ~(MSR_GLCP_DOTPLL_DOTRESET);\r\nwrmsrl(MSR_GLCP_DOTPLL, dotpll);\r\ndo {\r\nrdmsrl(MSR_GLCP_DOTPLL, dotpll);\r\n} while (timeout-- && !(dotpll & MSR_GLCP_DOTPLL_LOCK));\r\n}\r\nstatic void\r\ngx_configure_tft(struct fb_info *info)\r\n{\r\nstruct gxfb_par *par = info->par;\r\nunsigned long val;\r\nunsigned long fp;\r\nrdmsrl(MSR_GX_MSR_PADSEL, val);\r\nval &= ~MSR_GX_MSR_PADSEL_MASK;\r\nval |= MSR_GX_MSR_PADSEL_TFT;\r\nwrmsrl(MSR_GX_MSR_PADSEL, val);\r\nfp = read_fp(par, FP_PM);\r\nfp &= ~FP_PM_P;\r\nwrite_fp(par, FP_PM, fp);\r\nfp = read_fp(par, FP_PT1);\r\nfp &= FP_PT1_VSIZE_MASK;\r\nfp |= info->var.yres << FP_PT1_VSIZE_SHIFT;\r\nwrite_fp(par, FP_PT1, fp);\r\nfp = 0x0F100000;\r\nif (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))\r\nfp |= FP_PT2_VSP;\r\nif (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))\r\nfp |= FP_PT2_HSP;\r\nwrite_fp(par, FP_PT2, fp);\r\nwrite_fp(par, FP_DFC, FP_DFC_NFI);\r\nfp = read_vp(par, VP_DCFG);\r\nfp |= VP_DCFG_FP_PWR_EN | VP_DCFG_FP_DATA_EN;\r\nwrite_vp(par, VP_DCFG, fp);\r\nfp = read_fp(par, FP_PM);\r\nfp |= FP_PM_P;\r\nwrite_fp(par, FP_PM, fp);\r\n}\r\nvoid gx_configure_display(struct fb_info *info)\r\n{\r\nstruct gxfb_par *par = info->par;\r\nu32 dcfg, misc;\r\ndcfg = read_vp(par, VP_DCFG);\r\ndcfg &= ~(VP_DCFG_VSYNC_EN | VP_DCFG_HSYNC_EN);\r\nwrite_vp(par, VP_DCFG, dcfg);\r\ndcfg &= ~(VP_DCFG_CRT_SYNC_SKW\r\n| VP_DCFG_CRT_HSYNC_POL | VP_DCFG_CRT_VSYNC_POL\r\n| VP_DCFG_VSYNC_EN | VP_DCFG_HSYNC_EN);\r\ndcfg |= VP_DCFG_CRT_SYNC_SKW_DEFAULT;\r\ndcfg |= VP_DCFG_HSYNC_EN | VP_DCFG_VSYNC_EN;\r\nmisc = read_vp(par, VP_MISC);\r\nmisc |= VP_MISC_GAM_EN;\r\nif (par->enable_crt) {\r\nmisc &= ~(VP_MISC_APWRDN | VP_MISC_DACPWRDN);\r\nwrite_vp(par, VP_MISC, misc);\r\nif (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))\r\ndcfg |= VP_DCFG_CRT_HSYNC_POL;\r\nif (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))\r\ndcfg |= VP_DCFG_CRT_VSYNC_POL;\r\n} else {\r\nmisc |= (VP_MISC_APWRDN | VP_MISC_DACPWRDN);\r\nwrite_vp(par, VP_MISC, misc);\r\n}\r\ndcfg |= VP_DCFG_CRT_EN | VP_DCFG_DAC_BL_EN;\r\nwrite_vp(par, VP_DCFG, dcfg);\r\nif (par->enable_crt == 0)\r\ngx_configure_tft(info);\r\n}\r\nint gx_blank_display(struct fb_info *info, int blank_mode)\r\n{\r\nstruct gxfb_par *par = info->par;\r\nu32 dcfg, fp_pm;\r\nint blank, hsync, vsync, crt;\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\nblank = 0; hsync = 1; vsync = 1; crt = 1;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\nblank = 1; hsync = 1; vsync = 1; crt = 1;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nblank = 1; hsync = 1; vsync = 0; crt = 1;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nblank = 1; hsync = 0; vsync = 1; crt = 1;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nblank = 1; hsync = 0; vsync = 0; crt = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndcfg = read_vp(par, VP_DCFG);\r\ndcfg &= ~(VP_DCFG_DAC_BL_EN | VP_DCFG_HSYNC_EN | VP_DCFG_VSYNC_EN |\r\nVP_DCFG_CRT_EN);\r\nif (!blank)\r\ndcfg |= VP_DCFG_DAC_BL_EN;\r\nif (hsync)\r\ndcfg |= VP_DCFG_HSYNC_EN;\r\nif (vsync)\r\ndcfg |= VP_DCFG_VSYNC_EN;\r\nif (crt)\r\ndcfg |= VP_DCFG_CRT_EN;\r\nwrite_vp(par, VP_DCFG, dcfg);\r\nif (par->enable_crt == 0) {\r\nfp_pm = read_fp(par, FP_PM);\r\nif (blank_mode == FB_BLANK_POWERDOWN)\r\nfp_pm &= ~FP_PM_P;\r\nelse\r\nfp_pm |= FP_PM_P;\r\nwrite_fp(par, FP_PM, fp_pm);\r\n}\r\nreturn 0;\r\n}
