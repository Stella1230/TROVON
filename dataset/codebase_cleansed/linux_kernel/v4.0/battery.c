static inline int acpi_battery_present(struct acpi_battery *battery)\r\n{\r\nreturn battery->device->status.battery_present;\r\n}\r\nstatic int acpi_battery_technology(struct acpi_battery *battery)\r\n{\r\nif (!strcasecmp("NiCd", battery->type))\r\nreturn POWER_SUPPLY_TECHNOLOGY_NiCd;\r\nif (!strcasecmp("NiMH", battery->type))\r\nreturn POWER_SUPPLY_TECHNOLOGY_NiMH;\r\nif (!strcasecmp("LION", battery->type))\r\nreturn POWER_SUPPLY_TECHNOLOGY_LION;\r\nif (!strncasecmp("LI-ION", battery->type, 6))\r\nreturn POWER_SUPPLY_TECHNOLOGY_LION;\r\nif (!strcasecmp("LiP", battery->type))\r\nreturn POWER_SUPPLY_TECHNOLOGY_LIPO;\r\nreturn POWER_SUPPLY_TECHNOLOGY_UNKNOWN;\r\n}\r\nstatic int acpi_battery_is_charged(struct acpi_battery *battery)\r\n{\r\nif (battery->state != 0)\r\nreturn 0;\r\nif (battery->capacity_now == ACPI_BATTERY_VALUE_UNKNOWN ||\r\nbattery->capacity_now == 0)\r\nreturn 0;\r\nif (battery->full_charge_capacity == battery->capacity_now)\r\nreturn 1;\r\nif (battery->design_capacity == battery->capacity_now)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int acpi_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nint ret = 0;\r\nstruct acpi_battery *battery = to_acpi_battery(psy);\r\nif (acpi_battery_present(battery)) {\r\nacpi_battery_get_state(battery);\r\n} else if (psp != POWER_SUPPLY_PROP_PRESENT)\r\nreturn -ENODEV;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nif (battery->state & ACPI_BATTERY_STATE_DISCHARGING)\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse if (battery->state & ACPI_BATTERY_STATE_CHARGING)\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nelse if (acpi_battery_is_charged(battery))\r\nval->intval = POWER_SUPPLY_STATUS_FULL;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = acpi_battery_present(battery);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = acpi_battery_technology(battery);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CYCLE_COUNT:\r\nval->intval = battery->cycle_count;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\r\nif (battery->design_voltage == ACPI_BATTERY_VALUE_UNKNOWN)\r\nret = -ENODEV;\r\nelse\r\nval->intval = battery->design_voltage * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nif (battery->voltage_now == ACPI_BATTERY_VALUE_UNKNOWN)\r\nret = -ENODEV;\r\nelse\r\nval->intval = battery->voltage_now * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\ncase POWER_SUPPLY_PROP_POWER_NOW:\r\nif (battery->rate_now == ACPI_BATTERY_VALUE_UNKNOWN)\r\nret = -ENODEV;\r\nelse\r\nval->intval = battery->rate_now * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\r\nif (battery->design_capacity == ACPI_BATTERY_VALUE_UNKNOWN)\r\nret = -ENODEV;\r\nelse\r\nval->intval = battery->design_capacity * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL:\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL:\r\nif (battery->full_charge_capacity == ACPI_BATTERY_VALUE_UNKNOWN)\r\nret = -ENODEV;\r\nelse\r\nval->intval = battery->full_charge_capacity * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\ncase POWER_SUPPLY_PROP_ENERGY_NOW:\r\nif (battery->capacity_now == ACPI_BATTERY_VALUE_UNKNOWN)\r\nret = -ENODEV;\r\nelse\r\nval->intval = battery->capacity_now * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nif (battery->capacity_now && battery->full_charge_capacity)\r\nval->intval = battery->capacity_now * 100/\r\nbattery->full_charge_capacity;\r\nelse\r\nval->intval = 0;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY_LEVEL:\r\nif (battery->state & ACPI_BATTERY_STATE_CRITICAL)\r\nval->intval = POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\r\nelse if (test_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags) &&\r\n(battery->capacity_now <= battery->alarm))\r\nval->intval = POWER_SUPPLY_CAPACITY_LEVEL_LOW;\r\nelse if (acpi_battery_is_charged(battery))\r\nval->intval = POWER_SUPPLY_CAPACITY_LEVEL_FULL;\r\nelse\r\nval->intval = POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MODEL_NAME:\r\nval->strval = battery->model_number;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MANUFACTURER:\r\nval->strval = battery->oem_info;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_SERIAL_NUMBER:\r\nval->strval = battery->serial_number;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\ninline char *acpi_battery_units(struct acpi_battery *battery)\r\n{\r\nreturn (battery->power_unit == ACPI_BATTERY_POWER_UNIT_MA) ?\r\n"mA" : "mW";\r\n}\r\nstatic int extract_package(struct acpi_battery *battery,\r\nunion acpi_object *package,\r\nstruct acpi_offsets *offsets, int num)\r\n{\r\nint i;\r\nunion acpi_object *element;\r\nif (package->type != ACPI_TYPE_PACKAGE)\r\nreturn -EFAULT;\r\nfor (i = 0; i < num; ++i) {\r\nif (package->package.count <= i)\r\nreturn -EFAULT;\r\nelement = &package->package.elements[i];\r\nif (offsets[i].mode) {\r\nu8 *ptr = (u8 *)battery + offsets[i].offset;\r\nif (element->type == ACPI_TYPE_STRING ||\r\nelement->type == ACPI_TYPE_BUFFER)\r\nstrncpy(ptr, element->string.pointer, 32);\r\nelse if (element->type == ACPI_TYPE_INTEGER) {\r\nstrncpy(ptr, (u8 *)&element->integer.value,\r\nsizeof(u64));\r\nptr[sizeof(u64)] = 0;\r\n} else\r\n*ptr = 0;\r\n} else {\r\nint *x = (int *)((u8 *)battery + offsets[i].offset);\r\n*x = (element->type == ACPI_TYPE_INTEGER) ?\r\nelement->integer.value : -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_battery_get_status(struct acpi_battery *battery)\r\n{\r\nif (acpi_bus_get_status(battery->device)) {\r\nACPI_EXCEPTION((AE_INFO, AE_ERROR, "Evaluating _STA"));\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_battery_get_info(struct acpi_battery *battery)\r\n{\r\nint result = -EFAULT;\r\nacpi_status status = 0;\r\nchar *name = test_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags) ?\r\n"_BIX" : "_BIF";\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nif (!acpi_battery_present(battery))\r\nreturn 0;\r\nmutex_lock(&battery->lock);\r\nstatus = acpi_evaluate_object(battery->device->handle, name,\r\nNULL, &buffer);\r\nmutex_unlock(&battery->lock);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating %s", name));\r\nreturn -ENODEV;\r\n}\r\nif (battery_bix_broken_package)\r\nresult = extract_package(battery, buffer.pointer,\r\nextended_info_offsets + 1,\r\nARRAY_SIZE(extended_info_offsets) - 1);\r\nelse if (test_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags))\r\nresult = extract_package(battery, buffer.pointer,\r\nextended_info_offsets,\r\nARRAY_SIZE(extended_info_offsets));\r\nelse\r\nresult = extract_package(battery, buffer.pointer,\r\ninfo_offsets, ARRAY_SIZE(info_offsets));\r\nkfree(buffer.pointer);\r\nif (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags))\r\nbattery->full_charge_capacity = battery->design_capacity;\r\nif (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH, &battery->flags) &&\r\nbattery->power_unit && battery->design_voltage) {\r\nbattery->design_capacity = battery->design_capacity *\r\n10000 / battery->design_voltage;\r\nbattery->full_charge_capacity = battery->full_charge_capacity *\r\n10000 / battery->design_voltage;\r\nbattery->design_capacity_warning =\r\nbattery->design_capacity_warning *\r\n10000 / battery->design_voltage;\r\n}\r\nreturn result;\r\n}\r\nstatic int acpi_battery_get_state(struct acpi_battery *battery)\r\n{\r\nint result = 0;\r\nacpi_status status = 0;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nif (!acpi_battery_present(battery))\r\nreturn 0;\r\nif (battery->update_time &&\r\ntime_before(jiffies, battery->update_time +\r\nmsecs_to_jiffies(cache_time)))\r\nreturn 0;\r\nmutex_lock(&battery->lock);\r\nstatus = acpi_evaluate_object(battery->device->handle, "_BST",\r\nNULL, &buffer);\r\nmutex_unlock(&battery->lock);\r\nif (ACPI_FAILURE(status)) {\r\nACPI_EXCEPTION((AE_INFO, status, "Evaluating _BST"));\r\nreturn -ENODEV;\r\n}\r\nresult = extract_package(battery, buffer.pointer,\r\nstate_offsets, ARRAY_SIZE(state_offsets));\r\nbattery->update_time = jiffies;\r\nkfree(buffer.pointer);\r\nif (battery->power_unit == ACPI_BATTERY_POWER_UNIT_MA &&\r\nbattery->rate_now != ACPI_BATTERY_VALUE_UNKNOWN &&\r\n(s16)(battery->rate_now) < 0) {\r\nbattery->rate_now = abs((s16)battery->rate_now);\r\nprintk_once(KERN_WARNING FW_BUG "battery: (dis)charge rate"\r\n" invalid.\n");\r\n}\r\nif (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags)\r\n&& battery->capacity_now >= 0 && battery->capacity_now <= 100)\r\nbattery->capacity_now = (battery->capacity_now *\r\nbattery->full_charge_capacity) / 100;\r\nif (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH, &battery->flags) &&\r\nbattery->power_unit && battery->design_voltage) {\r\nbattery->capacity_now = battery->capacity_now *\r\n10000 / battery->design_voltage;\r\n}\r\nreturn result;\r\n}\r\nstatic int acpi_battery_set_alarm(struct acpi_battery *battery)\r\n{\r\nacpi_status status = 0;\r\nif (!acpi_battery_present(battery) ||\r\n!test_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags))\r\nreturn -ENODEV;\r\nmutex_lock(&battery->lock);\r\nstatus = acpi_execute_simple_method(battery->device->handle, "_BTP",\r\nbattery->alarm);\r\nmutex_unlock(&battery->lock);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Alarm set to %d\n", battery->alarm));\r\nreturn 0;\r\n}\r\nstatic int acpi_battery_init_alarm(struct acpi_battery *battery)\r\n{\r\nif (!acpi_has_method(battery->device->handle, "_BTP")) {\r\nclear_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags);\r\nreturn 0;\r\n}\r\nset_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags);\r\nif (!battery->alarm)\r\nbattery->alarm = battery->design_capacity_warning;\r\nreturn acpi_battery_set_alarm(battery);\r\n}\r\nstatic ssize_t acpi_battery_alarm_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct acpi_battery *battery = to_acpi_battery(dev_get_drvdata(dev));\r\nreturn sprintf(buf, "%d\n", battery->alarm * 1000);\r\n}\r\nstatic ssize_t acpi_battery_alarm_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long x;\r\nstruct acpi_battery *battery = to_acpi_battery(dev_get_drvdata(dev));\r\nif (sscanf(buf, "%lu\n", &x) == 1)\r\nbattery->alarm = x/1000;\r\nif (acpi_battery_present(battery))\r\nacpi_battery_set_alarm(battery);\r\nreturn count;\r\n}\r\nstatic int sysfs_add_battery(struct acpi_battery *battery)\r\n{\r\nint result;\r\nif (battery->power_unit == ACPI_BATTERY_POWER_UNIT_MA) {\r\nbattery->bat.properties = charge_battery_props;\r\nbattery->bat.num_properties =\r\nARRAY_SIZE(charge_battery_props);\r\n} else {\r\nbattery->bat.properties = energy_battery_props;\r\nbattery->bat.num_properties =\r\nARRAY_SIZE(energy_battery_props);\r\n}\r\nbattery->bat.name = acpi_device_bid(battery->device);\r\nbattery->bat.type = POWER_SUPPLY_TYPE_BATTERY;\r\nbattery->bat.get_property = acpi_battery_get_property;\r\nresult = power_supply_register_no_ws(&battery->device->dev, &battery->bat);\r\nif (result)\r\nreturn result;\r\nreturn device_create_file(battery->bat.dev, &alarm_attr);\r\n}\r\nstatic void sysfs_remove_battery(struct acpi_battery *battery)\r\n{\r\nmutex_lock(&battery->sysfs_lock);\r\nif (!battery->bat.dev) {\r\nmutex_unlock(&battery->sysfs_lock);\r\nreturn;\r\n}\r\ndevice_remove_file(battery->bat.dev, &alarm_attr);\r\npower_supply_unregister(&battery->bat);\r\nbattery->bat.dev = NULL;\r\nmutex_unlock(&battery->sysfs_lock);\r\n}\r\nstatic void find_battery(const struct dmi_header *dm, void *private)\r\n{\r\nstruct acpi_battery *battery = (struct acpi_battery *)private;\r\nif (dm->type == DMI_ENTRY_PORTABLE_BATTERY && dm->length >= 8) {\r\nconst u8 *dmi_data = (const u8 *)(dm + 1);\r\nint dmi_capacity = get_unaligned((const u16 *)(dmi_data + 6));\r\nif (dm->length >= 18)\r\ndmi_capacity *= dmi_data[17];\r\nif (battery->design_capacity * battery->design_voltage / 1000\r\n!= dmi_capacity &&\r\nbattery->design_capacity * 10 == dmi_capacity)\r\nset_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH,\r\n&battery->flags);\r\n}\r\n}\r\nstatic void acpi_battery_quirks(struct acpi_battery *battery)\r\n{\r\nif (test_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags))\r\nreturn;\r\nif (battery->full_charge_capacity == 100 &&\r\nbattery->rate_now == ACPI_BATTERY_VALUE_UNKNOWN &&\r\nbattery->capacity_now >= 0 && battery->capacity_now <= 100) {\r\nset_bit(ACPI_BATTERY_QUIRK_PERCENTAGE_CAPACITY, &battery->flags);\r\nbattery->full_charge_capacity = battery->design_capacity;\r\nbattery->capacity_now = (battery->capacity_now *\r\nbattery->full_charge_capacity) / 100;\r\n}\r\nif (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH, &battery->flags))\r\nreturn;\r\nif (battery->power_unit && dmi_name_in_vendors("LENOVO")) {\r\nconst char *s;\r\ns = dmi_get_system_info(DMI_PRODUCT_VERSION);\r\nif (s && !strncasecmp(s, "ThinkPad", 8)) {\r\ndmi_walk(find_battery, battery);\r\nif (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH,\r\n&battery->flags) &&\r\nbattery->design_voltage) {\r\nbattery->design_capacity =\r\nbattery->design_capacity *\r\n10000 / battery->design_voltage;\r\nbattery->full_charge_capacity =\r\nbattery->full_charge_capacity *\r\n10000 / battery->design_voltage;\r\nbattery->design_capacity_warning =\r\nbattery->design_capacity_warning *\r\n10000 / battery->design_voltage;\r\nbattery->capacity_now = battery->capacity_now *\r\n10000 / battery->design_voltage;\r\n}\r\n}\r\n}\r\n}\r\nstatic int acpi_battery_update(struct acpi_battery *battery, bool resume)\r\n{\r\nint result, old_present = acpi_battery_present(battery);\r\nresult = acpi_battery_get_status(battery);\r\nif (result)\r\nreturn result;\r\nif (!acpi_battery_present(battery)) {\r\nsysfs_remove_battery(battery);\r\nbattery->update_time = 0;\r\nreturn 0;\r\n}\r\nif (resume)\r\nreturn 0;\r\nif (!battery->update_time ||\r\nold_present != acpi_battery_present(battery)) {\r\nresult = acpi_battery_get_info(battery);\r\nif (result)\r\nreturn result;\r\nacpi_battery_init_alarm(battery);\r\n}\r\nif (!battery->bat.dev) {\r\nresult = sysfs_add_battery(battery);\r\nif (result)\r\nreturn result;\r\n}\r\nresult = acpi_battery_get_state(battery);\r\nif (result)\r\nreturn result;\r\nacpi_battery_quirks(battery);\r\nif ((battery->state & ACPI_BATTERY_STATE_CRITICAL) ||\r\n(test_bit(ACPI_BATTERY_ALARM_PRESENT, &battery->flags) &&\r\n(battery->capacity_now <= battery->alarm)))\r\npm_wakeup_event(&battery->device->dev, 0);\r\nreturn result;\r\n}\r\nstatic void acpi_battery_refresh(struct acpi_battery *battery)\r\n{\r\nint power_unit;\r\nif (!battery->bat.dev)\r\nreturn;\r\npower_unit = battery->power_unit;\r\nacpi_battery_get_info(battery);\r\nif (power_unit == battery->power_unit)\r\nreturn;\r\nsysfs_remove_battery(battery);\r\nsysfs_add_battery(battery);\r\n}\r\nstatic int acpi_battery_print_info(struct seq_file *seq, int result)\r\n{\r\nstruct acpi_battery *battery = seq->private;\r\nif (result)\r\ngoto end;\r\nseq_printf(seq, "present: %s\n",\r\nacpi_battery_present(battery) ? "yes" : "no");\r\nif (!acpi_battery_present(battery))\r\ngoto end;\r\nif (battery->design_capacity == ACPI_BATTERY_VALUE_UNKNOWN)\r\nseq_printf(seq, "design capacity: unknown\n");\r\nelse\r\nseq_printf(seq, "design capacity: %d %sh\n",\r\nbattery->design_capacity,\r\nacpi_battery_units(battery));\r\nif (battery->full_charge_capacity == ACPI_BATTERY_VALUE_UNKNOWN)\r\nseq_printf(seq, "last full capacity: unknown\n");\r\nelse\r\nseq_printf(seq, "last full capacity: %d %sh\n",\r\nbattery->full_charge_capacity,\r\nacpi_battery_units(battery));\r\nseq_printf(seq, "battery technology: %srechargeable\n",\r\n(!battery->technology)?"non-":"");\r\nif (battery->design_voltage == ACPI_BATTERY_VALUE_UNKNOWN)\r\nseq_printf(seq, "design voltage: unknown\n");\r\nelse\r\nseq_printf(seq, "design voltage: %d mV\n",\r\nbattery->design_voltage);\r\nseq_printf(seq, "design capacity warning: %d %sh\n",\r\nbattery->design_capacity_warning,\r\nacpi_battery_units(battery));\r\nseq_printf(seq, "design capacity low: %d %sh\n",\r\nbattery->design_capacity_low,\r\nacpi_battery_units(battery));\r\nseq_printf(seq, "cycle count: %i\n", battery->cycle_count);\r\nseq_printf(seq, "capacity granularity 1: %d %sh\n",\r\nbattery->capacity_granularity_1,\r\nacpi_battery_units(battery));\r\nseq_printf(seq, "capacity granularity 2: %d %sh\n",\r\nbattery->capacity_granularity_2,\r\nacpi_battery_units(battery));\r\nseq_printf(seq, "model number: %s\n", battery->model_number);\r\nseq_printf(seq, "serial number: %s\n", battery->serial_number);\r\nseq_printf(seq, "battery type: %s\n", battery->type);\r\nseq_printf(seq, "OEM info: %s\n", battery->oem_info);\r\nend:\r\nif (result)\r\nseq_printf(seq, "ERROR: Unable to read battery info\n");\r\nreturn result;\r\n}\r\nstatic int acpi_battery_print_state(struct seq_file *seq, int result)\r\n{\r\nstruct acpi_battery *battery = seq->private;\r\nif (result)\r\ngoto end;\r\nseq_printf(seq, "present: %s\n",\r\nacpi_battery_present(battery) ? "yes" : "no");\r\nif (!acpi_battery_present(battery))\r\ngoto end;\r\nseq_printf(seq, "capacity state: %s\n",\r\n(battery->state & 0x04) ? "critical" : "ok");\r\nif ((battery->state & 0x01) && (battery->state & 0x02))\r\nseq_printf(seq,\r\n"charging state: charging/discharging\n");\r\nelse if (battery->state & 0x01)\r\nseq_printf(seq, "charging state: discharging\n");\r\nelse if (battery->state & 0x02)\r\nseq_printf(seq, "charging state: charging\n");\r\nelse\r\nseq_printf(seq, "charging state: charged\n");\r\nif (battery->rate_now == ACPI_BATTERY_VALUE_UNKNOWN)\r\nseq_printf(seq, "present rate: unknown\n");\r\nelse\r\nseq_printf(seq, "present rate: %d %s\n",\r\nbattery->rate_now, acpi_battery_units(battery));\r\nif (battery->capacity_now == ACPI_BATTERY_VALUE_UNKNOWN)\r\nseq_printf(seq, "remaining capacity: unknown\n");\r\nelse\r\nseq_printf(seq, "remaining capacity: %d %sh\n",\r\nbattery->capacity_now, acpi_battery_units(battery));\r\nif (battery->voltage_now == ACPI_BATTERY_VALUE_UNKNOWN)\r\nseq_printf(seq, "present voltage: unknown\n");\r\nelse\r\nseq_printf(seq, "present voltage: %d mV\n",\r\nbattery->voltage_now);\r\nend:\r\nif (result)\r\nseq_printf(seq, "ERROR: Unable to read battery state\n");\r\nreturn result;\r\n}\r\nstatic int acpi_battery_print_alarm(struct seq_file *seq, int result)\r\n{\r\nstruct acpi_battery *battery = seq->private;\r\nif (result)\r\ngoto end;\r\nif (!acpi_battery_present(battery)) {\r\nseq_printf(seq, "present: no\n");\r\ngoto end;\r\n}\r\nseq_printf(seq, "alarm: ");\r\nif (!battery->alarm)\r\nseq_printf(seq, "unsupported\n");\r\nelse\r\nseq_printf(seq, "%u %sh\n", battery->alarm,\r\nacpi_battery_units(battery));\r\nend:\r\nif (result)\r\nseq_printf(seq, "ERROR: Unable to read battery alarm\n");\r\nreturn result;\r\n}\r\nstatic ssize_t acpi_battery_write_alarm(struct file *file,\r\nconst char __user * buffer,\r\nsize_t count, loff_t * ppos)\r\n{\r\nint result = 0;\r\nchar alarm_string[12] = { '\0' };\r\nstruct seq_file *m = file->private_data;\r\nstruct acpi_battery *battery = m->private;\r\nif (!battery || (count > sizeof(alarm_string) - 1))\r\nreturn -EINVAL;\r\nif (!acpi_battery_present(battery)) {\r\nresult = -ENODEV;\r\ngoto end;\r\n}\r\nif (copy_from_user(alarm_string, buffer, count)) {\r\nresult = -EFAULT;\r\ngoto end;\r\n}\r\nalarm_string[count] = '\0';\r\nif (kstrtoint(alarm_string, 0, &battery->alarm)) {\r\nresult = -EINVAL;\r\ngoto end;\r\n}\r\nresult = acpi_battery_set_alarm(battery);\r\nend:\r\nif (!result)\r\nreturn count;\r\nreturn result;\r\n}\r\nstatic int acpi_battery_read(int fid, struct seq_file *seq)\r\n{\r\nstruct acpi_battery *battery = seq->private;\r\nint result = acpi_battery_update(battery, false);\r\nreturn acpi_print_funcs[fid](seq, result);\r\n}\r\nstatic int acpi_battery_add_fs(struct acpi_device *device)\r\n{\r\nstruct proc_dir_entry *entry = NULL;\r\nint i;\r\nprintk(KERN_WARNING PREFIX "Deprecated procfs I/F for battery is loaded,"\r\n" please retry with CONFIG_ACPI_PROCFS_POWER cleared\n");\r\nif (!acpi_device_dir(device)) {\r\nacpi_device_dir(device) = proc_mkdir(acpi_device_bid(device),\r\nacpi_battery_dir);\r\nif (!acpi_device_dir(device))\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < ACPI_BATTERY_NUMFILES; ++i) {\r\nentry = proc_create_data(acpi_battery_file[i].name,\r\nacpi_battery_file[i].mode,\r\nacpi_device_dir(device),\r\n&acpi_battery_file[i].ops,\r\nacpi_driver_data(device));\r\nif (!entry)\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void acpi_battery_remove_fs(struct acpi_device *device)\r\n{\r\nint i;\r\nif (!acpi_device_dir(device))\r\nreturn;\r\nfor (i = 0; i < ACPI_BATTERY_NUMFILES; ++i)\r\nremove_proc_entry(acpi_battery_file[i].name,\r\nacpi_device_dir(device));\r\nremove_proc_entry(acpi_device_bid(device), acpi_battery_dir);\r\nacpi_device_dir(device) = NULL;\r\n}\r\nstatic void acpi_battery_notify(struct acpi_device *device, u32 event)\r\n{\r\nstruct acpi_battery *battery = acpi_driver_data(device);\r\nstruct device *old;\r\nif (!battery)\r\nreturn;\r\nold = battery->bat.dev;\r\nif (battery_notification_delay_ms > 0)\r\nmsleep(battery_notification_delay_ms);\r\nif (event == ACPI_BATTERY_NOTIFY_INFO)\r\nacpi_battery_refresh(battery);\r\nacpi_battery_update(battery, false);\r\nacpi_bus_generate_netlink_event(device->pnp.device_class,\r\ndev_name(&device->dev), event,\r\nacpi_battery_present(battery));\r\nacpi_notifier_call_chain(device, event, acpi_battery_present(battery));\r\nif (old && battery->bat.dev)\r\npower_supply_changed(&battery->bat);\r\n}\r\nstatic int battery_notify(struct notifier_block *nb,\r\nunsigned long mode, void *_unused)\r\n{\r\nstruct acpi_battery *battery = container_of(nb, struct acpi_battery,\r\npm_nb);\r\nint result;\r\nswitch (mode) {\r\ncase PM_POST_HIBERNATION:\r\ncase PM_POST_SUSPEND:\r\nif (!acpi_battery_present(battery))\r\nreturn 0;\r\nif (!battery->bat.dev) {\r\nresult = acpi_battery_get_info(battery);\r\nif (result)\r\nreturn result;\r\nresult = sysfs_add_battery(battery);\r\nif (result)\r\nreturn result;\r\n} else\r\nacpi_battery_refresh(battery);\r\nacpi_battery_init_alarm(battery);\r\nacpi_battery_get_state(battery);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int battery_bix_broken_package_quirk(const struct dmi_system_id *d)\r\n{\r\nbattery_bix_broken_package = 1;\r\nreturn 0;\r\n}\r\nstatic int battery_notification_delay_quirk(const struct dmi_system_id *d)\r\n{\r\nbattery_notification_delay_ms = 1000;\r\nreturn 0;\r\n}\r\nstatic int acpi_battery_update_retry(struct acpi_battery *battery)\r\n{\r\nint retry, ret;\r\nfor (retry = 5; retry; retry--) {\r\nret = acpi_battery_update(battery, false);\r\nif (!ret)\r\nbreak;\r\nmsleep(20);\r\n}\r\nreturn ret;\r\n}\r\nstatic int acpi_battery_add(struct acpi_device *device)\r\n{\r\nint result = 0;\r\nstruct acpi_battery *battery = NULL;\r\nif (!device)\r\nreturn -EINVAL;\r\nif (device->dep_unmet)\r\nreturn -EPROBE_DEFER;\r\nbattery = kzalloc(sizeof(struct acpi_battery), GFP_KERNEL);\r\nif (!battery)\r\nreturn -ENOMEM;\r\nbattery->device = device;\r\nstrcpy(acpi_device_name(device), ACPI_BATTERY_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_BATTERY_CLASS);\r\ndevice->driver_data = battery;\r\nmutex_init(&battery->lock);\r\nmutex_init(&battery->sysfs_lock);\r\nif (acpi_has_method(battery->device->handle, "_BIX"))\r\nset_bit(ACPI_BATTERY_XINFO_PRESENT, &battery->flags);\r\nresult = acpi_battery_update_retry(battery);\r\nif (result)\r\ngoto fail;\r\n#ifdef CONFIG_ACPI_PROCFS_POWER\r\nresult = acpi_battery_add_fs(device);\r\n#endif\r\nif (result) {\r\n#ifdef CONFIG_ACPI_PROCFS_POWER\r\nacpi_battery_remove_fs(device);\r\n#endif\r\ngoto fail;\r\n}\r\nprintk(KERN_INFO PREFIX "%s Slot [%s] (battery %s)\n",\r\nACPI_BATTERY_DEVICE_NAME, acpi_device_bid(device),\r\ndevice->status.battery_present ? "present" : "absent");\r\nbattery->pm_nb.notifier_call = battery_notify;\r\nregister_pm_notifier(&battery->pm_nb);\r\ndevice_init_wakeup(&device->dev, 1);\r\nreturn result;\r\nfail:\r\nsysfs_remove_battery(battery);\r\nmutex_destroy(&battery->lock);\r\nmutex_destroy(&battery->sysfs_lock);\r\nkfree(battery);\r\nreturn result;\r\n}\r\nstatic int acpi_battery_remove(struct acpi_device *device)\r\n{\r\nstruct acpi_battery *battery = NULL;\r\nif (!device || !acpi_driver_data(device))\r\nreturn -EINVAL;\r\ndevice_init_wakeup(&device->dev, 0);\r\nbattery = acpi_driver_data(device);\r\nunregister_pm_notifier(&battery->pm_nb);\r\n#ifdef CONFIG_ACPI_PROCFS_POWER\r\nacpi_battery_remove_fs(device);\r\n#endif\r\nsysfs_remove_battery(battery);\r\nmutex_destroy(&battery->lock);\r\nmutex_destroy(&battery->sysfs_lock);\r\nkfree(battery);\r\nreturn 0;\r\n}\r\nstatic int acpi_battery_resume(struct device *dev)\r\n{\r\nstruct acpi_battery *battery;\r\nif (!dev)\r\nreturn -EINVAL;\r\nbattery = acpi_driver_data(to_acpi_device(dev));\r\nif (!battery)\r\nreturn -EINVAL;\r\nbattery->update_time = 0;\r\nacpi_battery_update(battery, true);\r\nreturn 0;\r\n}\r\nstatic void __init acpi_battery_init_async(void *unused, async_cookie_t cookie)\r\n{\r\nif (acpi_disabled)\r\nreturn;\r\ndmi_check_system(bat_dmi_table);\r\n#ifdef CONFIG_ACPI_PROCFS_POWER\r\nacpi_battery_dir = acpi_lock_battery_dir();\r\nif (!acpi_battery_dir)\r\nreturn;\r\n#endif\r\nif (acpi_bus_register_driver(&acpi_battery_driver) < 0) {\r\n#ifdef CONFIG_ACPI_PROCFS_POWER\r\nacpi_unlock_battery_dir(acpi_battery_dir);\r\n#endif\r\nreturn;\r\n}\r\nreturn;\r\n}\r\nstatic int __init acpi_battery_init(void)\r\n{\r\nasync_schedule(acpi_battery_init_async, NULL);\r\nreturn 0;\r\n}\r\nstatic void __exit acpi_battery_exit(void)\r\n{\r\nacpi_bus_unregister_driver(&acpi_battery_driver);\r\n#ifdef CONFIG_ACPI_PROCFS_POWER\r\nacpi_unlock_battery_dir(acpi_battery_dir);\r\n#endif\r\n}
