static inline int h_total(struct fb_var_screeninfo *var)\r\n{\r\nreturn var->xres + var->left_margin +\r\nvar->right_margin + var->hsync_len;\r\n}\r\nstatic inline int v_total(struct fb_var_screeninfo *var)\r\n{\r\nreturn var->yres + var->upper_margin +\r\nvar->lower_margin + var->vsync_len;\r\n}\r\nstatic inline void sm501fb_sync_regs(struct sm501fb_info *info)\r\n{\r\nsmc501_readl(info->regs);\r\n}\r\nstatic int sm501_alloc_mem(struct sm501fb_info *inf, struct sm501_mem *mem,\r\nunsigned int why, size_t size, u32 smem_len)\r\n{\r\nstruct sm501fb_par *par;\r\nstruct fb_info *fbi;\r\nunsigned int ptr;\r\nunsigned int end;\r\nswitch (why) {\r\ncase SM501_MEMF_CURSOR:\r\nptr = inf->fbmem_len - size;\r\ninf->fbmem_len = ptr;\r\nbreak;\r\ncase SM501_MEMF_PANEL:\r\nif (size > inf->fbmem_len)\r\nreturn -ENOMEM;\r\nptr = inf->fbmem_len - size;\r\nfbi = inf->fb[HEAD_CRT];\r\nif (ptr > 0)\r\nptr &= ~(PAGE_SIZE - 1);\r\nif (fbi && ptr < smem_len)\r\nreturn -ENOMEM;\r\nbreak;\r\ncase SM501_MEMF_CRT:\r\nptr = 0;\r\nfbi = inf->fb[HEAD_PANEL];\r\nif (fbi) {\r\npar = fbi->par;\r\nend = par->screen.k_addr ? par->screen.sm_addr : inf->fbmem_len;\r\n} else\r\nend = inf->fbmem_len;\r\nif ((ptr + size) > end)\r\nreturn -ENOMEM;\r\nbreak;\r\ncase SM501_MEMF_ACCEL:\r\nfbi = inf->fb[HEAD_CRT];\r\nptr = fbi ? smem_len : 0;\r\nfbi = inf->fb[HEAD_PANEL];\r\nif (fbi) {\r\npar = fbi->par;\r\nend = par->screen.sm_addr;\r\n} else\r\nend = inf->fbmem_len;\r\nif ((ptr + size) > end)\r\nreturn -ENOMEM;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmem->size = size;\r\nmem->sm_addr = ptr;\r\nmem->k_addr = inf->fbmem + ptr;\r\ndev_dbg(inf->dev, "%s: result %08lx, %p - %u, %zd\n",\r\n__func__, mem->sm_addr, mem->k_addr, why, size);\r\nreturn 0;\r\n}\r\nstatic unsigned long sm501fb_ps_to_hz(unsigned long psvalue)\r\n{\r\nunsigned long long numerator=1000000000000ULL;\r\ndo_div(numerator, psvalue);\r\nreturn (unsigned long)numerator;\r\n}\r\nstatic void sm501fb_setup_gamma(struct sm501fb_info *fbi,\r\nunsigned long palette)\r\n{\r\nunsigned long value = 0;\r\nint offset;\r\nfor (offset = 0; offset < 256 * 4; offset += 4) {\r\nsmc501_writel(value, fbi->regs + palette + offset);\r\nvalue += 0x010101;\r\n}\r\n}\r\nstatic int sm501fb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct sm501fb_par *par = info->par;\r\nstruct sm501fb_info *sm = par->info;\r\nunsigned long tmp;\r\nif (var->hsync_len > 255 || var->vsync_len > 63)\r\nreturn -EINVAL;\r\nif ((var->xres + var->right_margin) > 4096)\r\nreturn -EINVAL;\r\nif ((var->yres + var->lower_margin) > 2048)\r\nreturn -EINVAL;\r\nif (h_total(var) > 4096 || v_total(var) > 2048)\r\nreturn -EINVAL;\r\ntmp = (var->xres * var->bits_per_pixel) / 8;\r\nif ((tmp & 15) != 0)\r\nreturn -EINVAL;\r\nif (var->xres_virtual > 4096 || var->yres_virtual > 2048)\r\nreturn -EINVAL;\r\nif (var->bits_per_pixel <= 8)\r\nvar->bits_per_pixel = 8;\r\nelse if (var->bits_per_pixel <= 16)\r\nvar->bits_per_pixel = 16;\r\nelse if (var->bits_per_pixel == 24)\r\nvar->bits_per_pixel = 32;\r\nswitch(var->bits_per_pixel) {\r\ncase 8:\r\nvar->red.length = var->bits_per_pixel;\r\nvar->red.offset = 0;\r\nvar->green.length = var->bits_per_pixel;\r\nvar->green.offset = 0;\r\nvar->blue.length = var->bits_per_pixel;\r\nvar->blue.offset = 0;\r\nvar->transp.length = 0;\r\nvar->transp.offset = 0;\r\nbreak;\r\ncase 16:\r\nif (sm->pdata->flags & SM501_FBPD_SWAP_FB_ENDIAN) {\r\nvar->blue.offset = 11;\r\nvar->green.offset = 5;\r\nvar->red.offset = 0;\r\n} else {\r\nvar->red.offset = 11;\r\nvar->green.offset = 5;\r\nvar->blue.offset = 0;\r\n}\r\nvar->transp.offset = 0;\r\nvar->red.length = 5;\r\nvar->green.length = 6;\r\nvar->blue.length = 5;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 32:\r\nif (sm->pdata->flags & SM501_FBPD_SWAP_FB_ENDIAN) {\r\nvar->transp.offset = 0;\r\nvar->red.offset = 8;\r\nvar->green.offset = 16;\r\nvar->blue.offset = 24;\r\n} else {\r\nvar->transp.offset = 24;\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\n}\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nvar->transp.length = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sm501fb_check_var_crt(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nreturn sm501fb_check_var(var, info);\r\n}\r\nstatic int sm501fb_check_var_pnl(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nreturn sm501fb_check_var(var, info);\r\n}\r\nstatic int sm501fb_set_par_common(struct fb_info *info,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nstruct sm501fb_par *par = info->par;\r\nstruct sm501fb_info *fbi = par->info;\r\nunsigned long pixclock;\r\nunsigned long sm501pixclock;\r\nunsigned int mem_type;\r\nunsigned int clock_type;\r\nunsigned int head_addr;\r\nunsigned int smem_len;\r\ndev_dbg(fbi->dev, "%s: %dx%d, bpp = %d, virtual %dx%d\n",\r\n__func__, var->xres, var->yres, var->bits_per_pixel,\r\nvar->xres_virtual, var->yres_virtual);\r\nswitch (par->head) {\r\ncase HEAD_CRT:\r\nmem_type = SM501_MEMF_CRT;\r\nclock_type = SM501_CLOCK_V2XCLK;\r\nhead_addr = SM501_DC_CRT_FB_ADDR;\r\nbreak;\r\ncase HEAD_PANEL:\r\nmem_type = SM501_MEMF_PANEL;\r\nclock_type = SM501_CLOCK_P2XCLK;\r\nhead_addr = SM501_DC_PANEL_FB_ADDR;\r\nbreak;\r\ndefault:\r\nmem_type = 0;\r\nhead_addr = 0;\r\nclock_type = 0;\r\n}\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nbreak;\r\ncase 16:\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nbreak;\r\ncase 32:\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nbreak;\r\n}\r\ninfo->fix.line_length = (var->xres_virtual * var->bits_per_pixel)/8;\r\nsmem_len = info->fix.line_length * var->yres_virtual;\r\ndev_dbg(fbi->dev, "%s: line length = %u\n", __func__,\r\ninfo->fix.line_length);\r\nif (sm501_alloc_mem(fbi, &par->screen, mem_type, smem_len, smem_len)) {\r\ndev_err(fbi->dev, "no memory available\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&info->mm_lock);\r\ninfo->fix.smem_start = fbi->fbmem_res->start + par->screen.sm_addr;\r\ninfo->fix.smem_len = smem_len;\r\nmutex_unlock(&info->mm_lock);\r\ninfo->screen_base = fbi->fbmem + par->screen.sm_addr;\r\ninfo->screen_size = info->fix.smem_len;\r\nsmc501_writel(par->screen.sm_addr | SM501_ADDR_FLIP,\r\nfbi->regs + head_addr);\r\npixclock = sm501fb_ps_to_hz(var->pixclock);\r\nsm501pixclock = sm501_set_clock(fbi->dev->parent, clock_type,\r\npixclock);\r\nvar->pixclock = sm501fb_hz_to_ps(sm501pixclock);\r\ndev_dbg(fbi->dev, "%s: pixclock(ps) = %u, pixclock(Hz) = %lu, "\r\n"sm501pixclock = %lu, error = %ld%%\n",\r\n__func__, var->pixclock, pixclock, sm501pixclock,\r\n((pixclock - sm501pixclock)*100)/pixclock);\r\nreturn 0;\r\n}\r\nstatic void sm501fb_set_par_geometry(struct fb_info *info,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nstruct sm501fb_par *par = info->par;\r\nstruct sm501fb_info *fbi = par->info;\r\nvoid __iomem *base = fbi->regs;\r\nunsigned long reg;\r\nif (par->head == HEAD_CRT)\r\nbase += SM501_DC_CRT_H_TOT;\r\nelse\r\nbase += SM501_DC_PANEL_H_TOT;\r\nreg = info->fix.line_length;\r\nreg |= ((var->xres * var->bits_per_pixel)/8) << 16;\r\nsmc501_writel(reg, fbi->regs + (par->head == HEAD_CRT ?\r\nSM501_DC_CRT_FB_OFFSET : SM501_DC_PANEL_FB_OFFSET));\r\nreg = (h_total(var) - 1) << 16;\r\nreg |= (var->xres - 1);\r\nsmc501_writel(reg, base + SM501_OFF_DC_H_TOT);\r\nreg = var->hsync_len << 16;\r\nreg |= var->xres + var->right_margin - 1;\r\nsmc501_writel(reg, base + SM501_OFF_DC_H_SYNC);\r\nreg = (v_total(var) - 1) << 16;\r\nreg |= (var->yres - 1);\r\nsmc501_writel(reg, base + SM501_OFF_DC_V_TOT);\r\nreg = var->vsync_len << 16;\r\nreg |= var->yres + var->lower_margin - 1;\r\nsmc501_writel(reg, base + SM501_OFF_DC_V_SYNC);\r\n}\r\nstatic int sm501fb_pan_crt(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct sm501fb_par *par = info->par;\r\nstruct sm501fb_info *fbi = par->info;\r\nunsigned int bytes_pixel = info->var.bits_per_pixel / 8;\r\nunsigned long reg;\r\nunsigned long xoffs;\r\nxoffs = var->xoffset * bytes_pixel;\r\nreg = smc501_readl(fbi->regs + SM501_DC_CRT_CONTROL);\r\nreg &= ~SM501_DC_CRT_CONTROL_PIXEL_MASK;\r\nreg |= ((xoffs & 15) / bytes_pixel) << 4;\r\nsmc501_writel(reg, fbi->regs + SM501_DC_CRT_CONTROL);\r\nreg = (par->screen.sm_addr + xoffs +\r\nvar->yoffset * info->fix.line_length);\r\nsmc501_writel(reg | SM501_ADDR_FLIP, fbi->regs + SM501_DC_CRT_FB_ADDR);\r\nsm501fb_sync_regs(fbi);\r\nreturn 0;\r\n}\r\nstatic int sm501fb_pan_pnl(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct sm501fb_par *par = info->par;\r\nstruct sm501fb_info *fbi = par->info;\r\nunsigned long reg;\r\nreg = var->xoffset | (info->var.xres_virtual << 16);\r\nsmc501_writel(reg, fbi->regs + SM501_DC_PANEL_FB_WIDTH);\r\nreg = var->yoffset | (info->var.yres_virtual << 16);\r\nsmc501_writel(reg, fbi->regs + SM501_DC_PANEL_FB_HEIGHT);\r\nsm501fb_sync_regs(fbi);\r\nreturn 0;\r\n}\r\nstatic int sm501fb_set_par_crt(struct fb_info *info)\r\n{\r\nstruct sm501fb_par *par = info->par;\r\nstruct sm501fb_info *fbi = par->info;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nunsigned long control;\r\nint ret;\r\ndev_dbg(fbi->dev, "%s(%p)\n", __func__, info);\r\nsm501_misc_control(fbi->dev->parent, 0, SM501_MISC_DAC_POWER);\r\ncontrol = smc501_readl(fbi->regs + SM501_DC_CRT_CONTROL);\r\ncontrol &= (SM501_DC_CRT_CONTROL_PIXEL_MASK |\r\nSM501_DC_CRT_CONTROL_GAMMA |\r\nSM501_DC_CRT_CONTROL_BLANK |\r\nSM501_DC_CRT_CONTROL_SEL |\r\nSM501_DC_CRT_CONTROL_CP |\r\nSM501_DC_CRT_CONTROL_TVP);\r\nif ((var->sync & FB_SYNC_HOR_HIGH_ACT) == 0)\r\ncontrol |= SM501_DC_CRT_CONTROL_HSP;\r\nif ((var->sync & FB_SYNC_VERT_HIGH_ACT) == 0)\r\ncontrol |= SM501_DC_CRT_CONTROL_VSP;\r\nif ((control & SM501_DC_CRT_CONTROL_SEL) == 0) {\r\nsm501_alloc_mem(fbi, &par->screen, SM501_MEMF_CRT, 0,\r\ninfo->fix.smem_len);\r\ngoto out_update;\r\n}\r\nret = sm501fb_set_par_common(info, var);\r\nif (ret) {\r\ndev_err(fbi->dev, "failed to set common parameters\n");\r\nreturn ret;\r\n}\r\nsm501fb_pan_crt(var, info);\r\nsm501fb_set_par_geometry(info, var);\r\ncontrol |= SM501_FIFO_3;\r\nswitch(var->bits_per_pixel) {\r\ncase 8:\r\ncontrol |= SM501_DC_CRT_CONTROL_8BPP;\r\nbreak;\r\ncase 16:\r\ncontrol |= SM501_DC_CRT_CONTROL_16BPP;\r\nsm501fb_setup_gamma(fbi, SM501_DC_CRT_PALETTE);\r\nbreak;\r\ncase 32:\r\ncontrol |= SM501_DC_CRT_CONTROL_32BPP;\r\nsm501fb_setup_gamma(fbi, SM501_DC_CRT_PALETTE);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\ncontrol |= SM501_DC_CRT_CONTROL_SEL;\r\ncontrol |= SM501_DC_CRT_CONTROL_TE;\r\ncontrol |= SM501_DC_CRT_CONTROL_ENABLE;\r\nout_update:\r\ndev_dbg(fbi->dev, "new control is %08lx\n", control);\r\nsmc501_writel(control, fbi->regs + SM501_DC_CRT_CONTROL);\r\nsm501fb_sync_regs(fbi);\r\nreturn 0;\r\n}\r\nstatic void sm501fb_panel_power(struct sm501fb_info *fbi, int to)\r\n{\r\nunsigned long control;\r\nvoid __iomem *ctrl_reg = fbi->regs + SM501_DC_PANEL_CONTROL;\r\nstruct sm501_platdata_fbsub *pd = fbi->pdata->fb_pnl;\r\ncontrol = smc501_readl(ctrl_reg);\r\nif (to && (control & SM501_DC_PANEL_CONTROL_VDD) == 0) {\r\ncontrol |= SM501_DC_PANEL_CONTROL_VDD;\r\nsmc501_writel(control, ctrl_reg);\r\nsm501fb_sync_regs(fbi);\r\nmdelay(10);\r\ncontrol |= SM501_DC_PANEL_CONTROL_DATA;\r\nsmc501_writel(control, ctrl_reg);\r\nsm501fb_sync_regs(fbi);\r\nmdelay(10);\r\nif (!(pd->flags & SM501FB_FLAG_PANEL_NO_VBIASEN)) {\r\nif (pd->flags & SM501FB_FLAG_PANEL_INV_VBIASEN)\r\ncontrol &= ~SM501_DC_PANEL_CONTROL_BIAS;\r\nelse\r\ncontrol |= SM501_DC_PANEL_CONTROL_BIAS;\r\nsmc501_writel(control, ctrl_reg);\r\nsm501fb_sync_regs(fbi);\r\nmdelay(10);\r\n}\r\nif (!(pd->flags & SM501FB_FLAG_PANEL_NO_FPEN)) {\r\nif (pd->flags & SM501FB_FLAG_PANEL_INV_FPEN)\r\ncontrol &= ~SM501_DC_PANEL_CONTROL_FPEN;\r\nelse\r\ncontrol |= SM501_DC_PANEL_CONTROL_FPEN;\r\nsmc501_writel(control, ctrl_reg);\r\nsm501fb_sync_regs(fbi);\r\nmdelay(10);\r\n}\r\n} else if (!to && (control & SM501_DC_PANEL_CONTROL_VDD) != 0) {\r\nif (!(pd->flags & SM501FB_FLAG_PANEL_NO_FPEN)) {\r\nif (pd->flags & SM501FB_FLAG_PANEL_INV_FPEN)\r\ncontrol |= SM501_DC_PANEL_CONTROL_FPEN;\r\nelse\r\ncontrol &= ~SM501_DC_PANEL_CONTROL_FPEN;\r\nsmc501_writel(control, ctrl_reg);\r\nsm501fb_sync_regs(fbi);\r\nmdelay(10);\r\n}\r\nif (!(pd->flags & SM501FB_FLAG_PANEL_NO_VBIASEN)) {\r\nif (pd->flags & SM501FB_FLAG_PANEL_INV_VBIASEN)\r\ncontrol |= SM501_DC_PANEL_CONTROL_BIAS;\r\nelse\r\ncontrol &= ~SM501_DC_PANEL_CONTROL_BIAS;\r\nsmc501_writel(control, ctrl_reg);\r\nsm501fb_sync_regs(fbi);\r\nmdelay(10);\r\n}\r\ncontrol &= ~SM501_DC_PANEL_CONTROL_DATA;\r\nsmc501_writel(control, ctrl_reg);\r\nsm501fb_sync_regs(fbi);\r\nmdelay(10);\r\ncontrol &= ~SM501_DC_PANEL_CONTROL_VDD;\r\nsmc501_writel(control, ctrl_reg);\r\nsm501fb_sync_regs(fbi);\r\nmdelay(10);\r\n}\r\nsm501fb_sync_regs(fbi);\r\n}\r\nstatic int sm501fb_set_par_pnl(struct fb_info *info)\r\n{\r\nstruct sm501fb_par *par = info->par;\r\nstruct sm501fb_info *fbi = par->info;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nunsigned long control;\r\nunsigned long reg;\r\nint ret;\r\ndev_dbg(fbi->dev, "%s(%p)\n", __func__, info);\r\nret = sm501fb_set_par_common(info, var);\r\nif (ret)\r\nreturn ret;\r\nsm501fb_pan_pnl(var, info);\r\nsm501fb_set_par_geometry(info, var);\r\ncontrol = smc501_readl(fbi->regs + SM501_DC_PANEL_CONTROL);\r\ncontrol &= (SM501_DC_PANEL_CONTROL_GAMMA |\r\nSM501_DC_PANEL_CONTROL_VDD |\r\nSM501_DC_PANEL_CONTROL_DATA |\r\nSM501_DC_PANEL_CONTROL_BIAS |\r\nSM501_DC_PANEL_CONTROL_FPEN |\r\nSM501_DC_PANEL_CONTROL_CP |\r\nSM501_DC_PANEL_CONTROL_CK |\r\nSM501_DC_PANEL_CONTROL_HP |\r\nSM501_DC_PANEL_CONTROL_VP |\r\nSM501_DC_PANEL_CONTROL_HPD |\r\nSM501_DC_PANEL_CONTROL_VPD);\r\ncontrol |= SM501_FIFO_3;\r\nswitch(var->bits_per_pixel) {\r\ncase 8:\r\ncontrol |= SM501_DC_PANEL_CONTROL_8BPP;\r\nbreak;\r\ncase 16:\r\ncontrol |= SM501_DC_PANEL_CONTROL_16BPP;\r\nsm501fb_setup_gamma(fbi, SM501_DC_PANEL_PALETTE);\r\nbreak;\r\ncase 32:\r\ncontrol |= SM501_DC_PANEL_CONTROL_32BPP;\r\nsm501fb_setup_gamma(fbi, SM501_DC_PANEL_PALETTE);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nsmc501_writel(0x0, fbi->regs + SM501_DC_PANEL_PANNING_CONTROL);\r\nsmc501_writel(0x00, fbi->regs + SM501_DC_PANEL_TL_LOC);\r\nreg = var->xres - 1;\r\nreg |= (var->yres - 1) << 16;\r\nsmc501_writel(reg, fbi->regs + SM501_DC_PANEL_BR_LOC);\r\ncontrol |= SM501_DC_PANEL_CONTROL_TE;\r\ncontrol |= SM501_DC_PANEL_CONTROL_EN;\r\nif ((var->sync & FB_SYNC_HOR_HIGH_ACT) == 0)\r\ncontrol |= SM501_DC_PANEL_CONTROL_HSP;\r\nif ((var->sync & FB_SYNC_VERT_HIGH_ACT) == 0)\r\ncontrol |= SM501_DC_PANEL_CONTROL_VSP;\r\nsmc501_writel(control, fbi->regs + SM501_DC_PANEL_CONTROL);\r\nsm501fb_sync_regs(fbi);\r\nsm501_modify_reg(fbi->dev->parent, SM501_SYSTEM_CONTROL,\r\n0, SM501_SYSCTRL_PANEL_TRISTATE);\r\nsm501fb_panel_power(fbi, 1);\r\nreturn 0;\r\n}\r\nstatic inline unsigned int chan_to_field(unsigned int chan,\r\nstruct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int sm501fb_setcolreg(unsigned regno,\r\nunsigned red, unsigned green, unsigned blue,\r\nunsigned transp, struct fb_info *info)\r\n{\r\nstruct sm501fb_par *par = info->par;\r\nstruct sm501fb_info *fbi = par->info;\r\nvoid __iomem *base = fbi->regs;\r\nunsigned int val;\r\nif (par->head == HEAD_CRT)\r\nbase += SM501_DC_CRT_PALETTE;\r\nelse\r\nbase += SM501_DC_PANEL_PALETTE;\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\nu32 *pal = par->pseudo_palette;\r\nval = chan_to_field(red, &info->var.red);\r\nval |= chan_to_field(green, &info->var.green);\r\nval |= chan_to_field(blue, &info->var.blue);\r\npal[regno] = val;\r\n}\r\nbreak;\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nif (regno < 256) {\r\nval = (red >> 8) << 16;\r\nval |= (green >> 8) << 8;\r\nval |= blue >> 8;\r\nsmc501_writel(val, base + (regno * 4));\r\n}\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sm501fb_blank_pnl(int blank_mode, struct fb_info *info)\r\n{\r\nstruct sm501fb_par *par = info->par;\r\nstruct sm501fb_info *fbi = par->info;\r\ndev_dbg(fbi->dev, "%s(mode=%d, %p)\n", __func__, blank_mode, info);\r\nswitch (blank_mode) {\r\ncase FB_BLANK_POWERDOWN:\r\nsm501fb_panel_power(fbi, 0);\r\nbreak;\r\ncase FB_BLANK_UNBLANK:\r\nsm501fb_panel_power(fbi, 1);\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ndefault:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sm501fb_blank_crt(int blank_mode, struct fb_info *info)\r\n{\r\nstruct sm501fb_par *par = info->par;\r\nstruct sm501fb_info *fbi = par->info;\r\nunsigned long ctrl;\r\ndev_dbg(fbi->dev, "%s(mode=%d, %p)\n", __func__, blank_mode, info);\r\nctrl = smc501_readl(fbi->regs + SM501_DC_CRT_CONTROL);\r\nswitch (blank_mode) {\r\ncase FB_BLANK_POWERDOWN:\r\nctrl &= ~SM501_DC_CRT_CONTROL_ENABLE;\r\nsm501_misc_control(fbi->dev->parent, SM501_MISC_DAC_POWER, 0);\r\ncase FB_BLANK_NORMAL:\r\nctrl |= SM501_DC_CRT_CONTROL_BLANK;\r\nbreak;\r\ncase FB_BLANK_UNBLANK:\r\nctrl &= ~SM501_DC_CRT_CONTROL_BLANK;\r\nctrl |= SM501_DC_CRT_CONTROL_ENABLE;\r\nsm501_misc_control(fbi->dev->parent, 0, SM501_MISC_DAC_POWER);\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ndefault:\r\nreturn 1;\r\n}\r\nsmc501_writel(ctrl, fbi->regs + SM501_DC_CRT_CONTROL);\r\nsm501fb_sync_regs(fbi);\r\nreturn 0;\r\n}\r\nstatic int sm501fb_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\nstruct sm501fb_par *par = info->par;\r\nstruct sm501fb_info *fbi = par->info;\r\nvoid __iomem *base = fbi->regs;\r\nunsigned long hwc_addr;\r\nunsigned long fg, bg;\r\ndev_dbg(fbi->dev, "%s(%p,%p)\n", __func__, info, cursor);\r\nif (par->head == HEAD_CRT)\r\nbase += SM501_DC_CRT_HWC_BASE;\r\nelse\r\nbase += SM501_DC_PANEL_HWC_BASE;\r\nif (cursor->image.width > 64)\r\nreturn -EINVAL;\r\nif (cursor->image.height > 64)\r\nreturn -EINVAL;\r\nif (cursor->image.depth > 1)\r\nreturn -EINVAL;\r\nhwc_addr = smc501_readl(base + SM501_OFF_HWC_ADDR);\r\nif (cursor->enable)\r\nsmc501_writel(hwc_addr | SM501_HWC_EN,\r\nbase + SM501_OFF_HWC_ADDR);\r\nelse\r\nsmc501_writel(hwc_addr & ~SM501_HWC_EN,\r\nbase + SM501_OFF_HWC_ADDR);\r\nif (cursor->set & FB_CUR_SETPOS) {\r\nunsigned int x = cursor->image.dx;\r\nunsigned int y = cursor->image.dy;\r\nif (x >= 2048 || y >= 2048 )\r\nreturn -EINVAL;\r\ndev_dbg(fbi->dev, "set position %d,%d\n", x, y);\r\nsmc501_writel(x | (y << 16), base + SM501_OFF_HWC_LOC);\r\n}\r\nif (cursor->set & FB_CUR_SETCMAP) {\r\nunsigned int bg_col = cursor->image.bg_color;\r\nunsigned int fg_col = cursor->image.fg_color;\r\ndev_dbg(fbi->dev, "%s: update cmap (%08x,%08x)\n",\r\n__func__, bg_col, fg_col);\r\nbg = ((info->cmap.red[bg_col] & 0xF8) << 8) |\r\n((info->cmap.green[bg_col] & 0xFC) << 3) |\r\n((info->cmap.blue[bg_col] & 0xF8) >> 3);\r\nfg = ((info->cmap.red[fg_col] & 0xF8) << 8) |\r\n((info->cmap.green[fg_col] & 0xFC) << 3) |\r\n((info->cmap.blue[fg_col] & 0xF8) >> 3);\r\ndev_dbg(fbi->dev, "fgcol %08lx, bgcol %08lx\n", fg, bg);\r\nsmc501_writel(bg, base + SM501_OFF_HWC_COLOR_1_2);\r\nsmc501_writel(fg, base + SM501_OFF_HWC_COLOR_3);\r\n}\r\nif (cursor->set & FB_CUR_SETSIZE ||\r\ncursor->set & (FB_CUR_SETIMAGE | FB_CUR_SETSHAPE)) {\r\nint x, y;\r\nconst unsigned char *pcol = cursor->image.data;\r\nconst unsigned char *pmsk = cursor->mask;\r\nvoid __iomem *dst = par->cursor.k_addr;\r\nunsigned char dcol = 0;\r\nunsigned char dmsk = 0;\r\nunsigned int op;\r\ndev_dbg(fbi->dev, "%s: setting shape (%d,%d)\n",\r\n__func__, cursor->image.width, cursor->image.height);\r\nfor (op = 0; op < (64*64*2)/8; op+=4)\r\nsmc501_writel(0x0, dst + op);\r\nfor (y = 0; y < cursor->image.height; y++) {\r\nfor (x = 0; x < cursor->image.width; x++) {\r\nif ((x % 8) == 0) {\r\ndcol = *pcol++;\r\ndmsk = *pmsk++;\r\n} else {\r\ndcol >>= 1;\r\ndmsk >>= 1;\r\n}\r\nif (dmsk & 1) {\r\nop = (dcol & 1) ? 1 : 3;\r\nop <<= ((x % 4) * 2);\r\nop |= readb(dst + (x / 4));\r\nwriteb(op, dst + (x / 4));\r\n}\r\n}\r\ndst += (64*2)/8;\r\n}\r\n}\r\nsm501fb_sync_regs(fbi);\r\nreturn 0;\r\n}\r\nstatic ssize_t sm501fb_crtsrc_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sm501fb_info *info = dev_get_drvdata(dev);\r\nunsigned long ctrl;\r\nctrl = smc501_readl(info->regs + SM501_DC_CRT_CONTROL);\r\nctrl &= SM501_DC_CRT_CONTROL_SEL;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", ctrl ? "crt" : "panel");\r\n}\r\nstatic ssize_t sm501fb_crtsrc_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct sm501fb_info *info = dev_get_drvdata(dev);\r\nenum sm501_controller head;\r\nunsigned long ctrl;\r\nif (len < 1)\r\nreturn -EINVAL;\r\nif (strncasecmp(buf, "crt", 3) == 0)\r\nhead = HEAD_CRT;\r\nelse if (strncasecmp(buf, "panel", 5) == 0)\r\nhead = HEAD_PANEL;\r\nelse\r\nreturn -EINVAL;\r\ndev_info(dev, "setting crt source to head %d\n", head);\r\nctrl = smc501_readl(info->regs + SM501_DC_CRT_CONTROL);\r\nif (head == HEAD_CRT) {\r\nctrl |= SM501_DC_CRT_CONTROL_SEL;\r\nctrl |= SM501_DC_CRT_CONTROL_ENABLE;\r\nctrl |= SM501_DC_CRT_CONTROL_TE;\r\n} else {\r\nctrl &= ~SM501_DC_CRT_CONTROL_SEL;\r\nctrl &= ~SM501_DC_CRT_CONTROL_ENABLE;\r\nctrl &= ~SM501_DC_CRT_CONTROL_TE;\r\n}\r\nsmc501_writel(ctrl, info->regs + SM501_DC_CRT_CONTROL);\r\nsm501fb_sync_regs(info);\r\nreturn len;\r\n}\r\nstatic int sm501fb_show_regs(struct sm501fb_info *info, char *ptr,\r\nunsigned int start, unsigned int len)\r\n{\r\nvoid __iomem *mem = info->regs;\r\nchar *buf = ptr;\r\nunsigned int reg;\r\nfor (reg = start; reg < (len + start); reg += 4)\r\nptr += sprintf(ptr, "%08x = %08x\n", reg,\r\nsmc501_readl(mem + reg));\r\nreturn ptr - buf;\r\n}\r\nstatic ssize_t sm501fb_debug_show_crt(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sm501fb_info *info = dev_get_drvdata(dev);\r\nchar *ptr = buf;\r\nptr += sm501fb_show_regs(info, ptr, SM501_DC_CRT_CONTROL, 0x40);\r\nptr += sm501fb_show_regs(info, ptr, SM501_DC_CRT_HWC_BASE, 0x10);\r\nreturn ptr - buf;\r\n}\r\nstatic ssize_t sm501fb_debug_show_pnl(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sm501fb_info *info = dev_get_drvdata(dev);\r\nchar *ptr = buf;\r\nptr += sm501fb_show_regs(info, ptr, 0x0, 0x40);\r\nptr += sm501fb_show_regs(info, ptr, SM501_DC_PANEL_HWC_BASE, 0x10);\r\nreturn ptr - buf;\r\n}\r\nstatic int sm501fb_sync(struct fb_info *info)\r\n{\r\nint count = 1000000;\r\nstruct sm501fb_par *par = info->par;\r\nstruct sm501fb_info *fbi = par->info;\r\nwhile ((count > 0) &&\r\n(smc501_readl(fbi->regs + SM501_SYSTEM_CONTROL) &\r\nSM501_SYSCTRL_2D_ENGINE_STATUS) != 0)\r\ncount--;\r\nif (count <= 0) {\r\ndev_err(info->dev, "Timeout waiting for 2d engine sync\n");\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sm501fb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\r\n{\r\nstruct sm501fb_par *par = info->par;\r\nstruct sm501fb_info *fbi = par->info;\r\nint width = area->width;\r\nint height = area->height;\r\nint sx = area->sx;\r\nint sy = area->sy;\r\nint dx = area->dx;\r\nint dy = area->dy;\r\nunsigned long rtl = 0;\r\nif ((sx >= info->var.xres_virtual) ||\r\n(sy >= info->var.yres_virtual))\r\nreturn;\r\nif ((sx + width) >= info->var.xres_virtual)\r\nwidth = info->var.xres_virtual - sx - 1;\r\nif ((sy + height) >= info->var.yres_virtual)\r\nheight = info->var.yres_virtual - sy - 1;\r\nif ((dx >= info->var.xres_virtual) ||\r\n(dy >= info->var.yres_virtual))\r\nreturn;\r\nif ((dx + width) >= info->var.xres_virtual)\r\nwidth = info->var.xres_virtual - dx - 1;\r\nif ((dy + height) >= info->var.yres_virtual)\r\nheight = info->var.yres_virtual - dy - 1;\r\nif ((sx < dx) || (sy < dy)) {\r\nrtl = 1 << 27;\r\nsx += width - 1;\r\ndx += width - 1;\r\nsy += height - 1;\r\ndy += height - 1;\r\n}\r\nif (sm501fb_sync(info))\r\nreturn;\r\nsmc501_writel(par->screen.sm_addr, fbi->regs2d + SM501_2D_SOURCE_BASE);\r\nsmc501_writel(par->screen.sm_addr,\r\nfbi->regs2d + SM501_2D_DESTINATION_BASE);\r\nsmc501_writel((info->var.xres << 16) | info->var.xres,\r\nfbi->regs2d + SM501_2D_WINDOW_WIDTH);\r\nsmc501_writel((info->var.xres_virtual << 16) | info->var.xres_virtual,\r\nfbi->regs2d + SM501_2D_PITCH);\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nsmc501_writel(0, fbi->regs2d + SM501_2D_STRETCH);\r\nbreak;\r\ncase 16:\r\nsmc501_writel(0x00100000, fbi->regs2d + SM501_2D_STRETCH);\r\nbreak;\r\ncase 32:\r\nsmc501_writel(0x00200000, fbi->regs2d + SM501_2D_STRETCH);\r\nbreak;\r\n}\r\nsmc501_writel(0xffffffff, fbi->regs2d + SM501_2D_COLOR_COMPARE_MASK);\r\nsmc501_writel(0xffffffff, fbi->regs2d + SM501_2D_MASK);\r\nsmc501_writel((sx << 16) | sy, fbi->regs2d + SM501_2D_SOURCE);\r\nsmc501_writel((dx << 16) | dy, fbi->regs2d + SM501_2D_DESTINATION);\r\nsmc501_writel((width << 16) | height, fbi->regs2d + SM501_2D_DIMENSION);\r\nsmc501_writel(0x800000cc | rtl, fbi->regs2d + SM501_2D_CONTROL);\r\n}\r\nstatic void sm501fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nstruct sm501fb_par *par = info->par;\r\nstruct sm501fb_info *fbi = par->info;\r\nint width = rect->width, height = rect->height;\r\nif ((rect->dx >= info->var.xres_virtual) ||\r\n(rect->dy >= info->var.yres_virtual))\r\nreturn;\r\nif ((rect->dx + width) >= info->var.xres_virtual)\r\nwidth = info->var.xres_virtual - rect->dx - 1;\r\nif ((rect->dy + height) >= info->var.yres_virtual)\r\nheight = info->var.yres_virtual - rect->dy - 1;\r\nif (sm501fb_sync(info))\r\nreturn;\r\nsmc501_writel(par->screen.sm_addr, fbi->regs2d + SM501_2D_SOURCE_BASE);\r\nsmc501_writel(par->screen.sm_addr,\r\nfbi->regs2d + SM501_2D_DESTINATION_BASE);\r\nsmc501_writel((info->var.xres << 16) | info->var.xres,\r\nfbi->regs2d + SM501_2D_WINDOW_WIDTH);\r\nsmc501_writel((info->var.xres_virtual << 16) | info->var.xres_virtual,\r\nfbi->regs2d + SM501_2D_PITCH);\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nsmc501_writel(0, fbi->regs2d + SM501_2D_STRETCH);\r\nbreak;\r\ncase 16:\r\nsmc501_writel(0x00100000, fbi->regs2d + SM501_2D_STRETCH);\r\nbreak;\r\ncase 32:\r\nsmc501_writel(0x00200000, fbi->regs2d + SM501_2D_STRETCH);\r\nbreak;\r\n}\r\nsmc501_writel(0xffffffff, fbi->regs2d + SM501_2D_COLOR_COMPARE_MASK);\r\nsmc501_writel(0xffffffff, fbi->regs2d + SM501_2D_MASK);\r\nsmc501_writel(rect->color, fbi->regs2d + SM501_2D_FOREGROUND);\r\nsmc501_writel((rect->dx << 16) | rect->dy,\r\nfbi->regs2d + SM501_2D_DESTINATION);\r\nsmc501_writel((width << 16) | height, fbi->regs2d + SM501_2D_DIMENSION);\r\nsmc501_writel(0x800100cc, fbi->regs2d + SM501_2D_CONTROL);\r\n}\r\nstatic int sm501_init_cursor(struct fb_info *fbi, unsigned int reg_base)\r\n{\r\nstruct sm501fb_par *par;\r\nstruct sm501fb_info *info;\r\nint ret;\r\nif (fbi == NULL)\r\nreturn 0;\r\npar = fbi->par;\r\ninfo = par->info;\r\npar->cursor_regs = info->regs + reg_base;\r\nret = sm501_alloc_mem(info, &par->cursor, SM501_MEMF_CURSOR, 1024,\r\nfbi->fix.smem_len);\r\nif (ret < 0)\r\nreturn ret;\r\nsmc501_writel(par->cursor.sm_addr,\r\npar->cursor_regs + SM501_OFF_HWC_ADDR);\r\nsmc501_writel(0x00, par->cursor_regs + SM501_OFF_HWC_LOC);\r\nsmc501_writel(0x00, par->cursor_regs + SM501_OFF_HWC_COLOR_1_2);\r\nsmc501_writel(0x00, par->cursor_regs + SM501_OFF_HWC_COLOR_3);\r\nsm501fb_sync_regs(info);\r\nreturn 0;\r\n}\r\nstatic int sm501fb_start(struct sm501fb_info *info,\r\nstruct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct device *dev = &pdev->dev;\r\nint k;\r\nint ret;\r\ninfo->irq = ret = platform_get_irq(pdev, 0);\r\nif (ret < 0) {\r\ndev_warn(dev, "no irq for device\n");\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(dev, "no resource definition for registers\n");\r\nret = -ENOENT;\r\ngoto err_release;\r\n}\r\ninfo->regs_res = request_mem_region(res->start,\r\nresource_size(res),\r\npdev->name);\r\nif (info->regs_res == NULL) {\r\ndev_err(dev, "cannot claim registers\n");\r\nret = -ENXIO;\r\ngoto err_release;\r\n}\r\ninfo->regs = ioremap(res->start, resource_size(res));\r\nif (info->regs == NULL) {\r\ndev_err(dev, "cannot remap registers\n");\r\nret = -ENXIO;\r\ngoto err_regs_res;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (res == NULL) {\r\ndev_err(dev, "no resource definition for 2d registers\n");\r\nret = -ENOENT;\r\ngoto err_regs_map;\r\n}\r\ninfo->regs2d_res = request_mem_region(res->start,\r\nresource_size(res),\r\npdev->name);\r\nif (info->regs2d_res == NULL) {\r\ndev_err(dev, "cannot claim registers\n");\r\nret = -ENXIO;\r\ngoto err_regs_map;\r\n}\r\ninfo->regs2d = ioremap(res->start, resource_size(res));\r\nif (info->regs2d == NULL) {\r\ndev_err(dev, "cannot remap registers\n");\r\nret = -ENXIO;\r\ngoto err_regs2d_res;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nif (res == NULL) {\r\ndev_err(dev, "no memory resource defined\n");\r\nret = -ENXIO;\r\ngoto err_regs2d_map;\r\n}\r\ninfo->fbmem_res = request_mem_region(res->start,\r\nresource_size(res),\r\npdev->name);\r\nif (info->fbmem_res == NULL) {\r\ndev_err(dev, "cannot claim framebuffer\n");\r\nret = -ENXIO;\r\ngoto err_regs2d_map;\r\n}\r\ninfo->fbmem = ioremap(res->start, resource_size(res));\r\nif (info->fbmem == NULL) {\r\ndev_err(dev, "cannot remap framebuffer\n");\r\ngoto err_mem_res;\r\n}\r\ninfo->fbmem_len = resource_size(res);\r\nmemset(info->fbmem, 0, info->fbmem_len);\r\nfor (k = 0; k < (256 * 3); k++)\r\nsmc501_writel(0, info->regs + SM501_DC_PANEL_PALETTE + (k * 4));\r\nsm501_unit_power(dev->parent, SM501_GATE_DISPLAY, 1);\r\nsm501_unit_power(dev->parent, SM501_GATE_2D_ENGINE, 1);\r\nsm501_init_cursor(info->fb[HEAD_CRT], SM501_DC_CRT_HWC_ADDR);\r\nsm501_init_cursor(info->fb[HEAD_PANEL], SM501_DC_PANEL_HWC_ADDR);\r\nreturn 0;\r\nerr_mem_res:\r\nrelease_mem_region(info->fbmem_res->start,\r\nresource_size(info->fbmem_res));\r\nerr_regs2d_map:\r\niounmap(info->regs2d);\r\nerr_regs2d_res:\r\nrelease_mem_region(info->regs2d_res->start,\r\nresource_size(info->regs2d_res));\r\nerr_regs_map:\r\niounmap(info->regs);\r\nerr_regs_res:\r\nrelease_mem_region(info->regs_res->start,\r\nresource_size(info->regs_res));\r\nerr_release:\r\nreturn ret;\r\n}\r\nstatic void sm501fb_stop(struct sm501fb_info *info)\r\n{\r\nsm501_unit_power(info->dev->parent, SM501_GATE_DISPLAY, 0);\r\niounmap(info->fbmem);\r\nrelease_mem_region(info->fbmem_res->start,\r\nresource_size(info->fbmem_res));\r\niounmap(info->regs2d);\r\nrelease_mem_region(info->regs2d_res->start,\r\nresource_size(info->regs2d_res));\r\niounmap(info->regs);\r\nrelease_mem_region(info->regs_res->start,\r\nresource_size(info->regs_res));\r\n}\r\nstatic int sm501fb_init_fb(struct fb_info *fb, enum sm501_controller head,\r\nconst char *fbname)\r\n{\r\nstruct sm501_platdata_fbsub *pd;\r\nstruct sm501fb_par *par = fb->par;\r\nstruct sm501fb_info *info = par->info;\r\nunsigned long ctrl;\r\nunsigned int enable;\r\nint ret;\r\nswitch (head) {\r\ncase HEAD_CRT:\r\npd = info->pdata->fb_crt;\r\nctrl = smc501_readl(info->regs + SM501_DC_CRT_CONTROL);\r\nenable = (ctrl & SM501_DC_CRT_CONTROL_ENABLE) ? 1 : 0;\r\nif (info->pdata->fb_route != SM501_FB_CRT_PANEL) {\r\nctrl |= SM501_DC_CRT_CONTROL_SEL;\r\nsmc501_writel(ctrl, info->regs + SM501_DC_CRT_CONTROL);\r\n}\r\nbreak;\r\ncase HEAD_PANEL:\r\npd = info->pdata->fb_pnl;\r\nctrl = smc501_readl(info->regs + SM501_DC_PANEL_CONTROL);\r\nenable = (ctrl & SM501_DC_PANEL_CONTROL_EN) ? 1 : 0;\r\nbreak;\r\ndefault:\r\npd = NULL;\r\nctrl = 0;\r\nenable = 0;\r\nBUG();\r\n}\r\ndev_info(info->dev, "fb %s %sabled at start\n",\r\nfbname, enable ? "en" : "dis");\r\nif (head == HEAD_CRT && info->pdata->fb_route == SM501_FB_CRT_PANEL) {\r\nctrl &= ~SM501_DC_CRT_CONTROL_SEL;\r\nsmc501_writel(ctrl, info->regs + SM501_DC_CRT_CONTROL);\r\nenable = 0;\r\n}\r\nstrlcpy(fb->fix.id, fbname, sizeof(fb->fix.id));\r\nmemcpy(&par->ops,\r\n(head == HEAD_CRT) ? &sm501fb_ops_crt : &sm501fb_ops_pnl,\r\nsizeof(struct fb_ops));\r\nif ((pd->flags & SM501FB_FLAG_USE_HWCURSOR) == 0)\r\npar->ops.fb_cursor = NULL;\r\nfb->fbops = &par->ops;\r\nfb->flags = FBINFO_FLAG_DEFAULT | FBINFO_READS_FAST |\r\nFBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT |\r\nFBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;\r\n#if defined(CONFIG_OF)\r\n#ifdef __BIG_ENDIAN\r\nif (of_get_property(info->dev->parent->of_node, "little-endian", NULL))\r\nfb->flags |= FBINFO_FOREIGN_ENDIAN;\r\n#else\r\nif (of_get_property(info->dev->parent->of_node, "big-endian", NULL))\r\nfb->flags |= FBINFO_FOREIGN_ENDIAN;\r\n#endif\r\n#endif\r\nfb->fix.type = FB_TYPE_PACKED_PIXELS;\r\nfb->fix.type_aux = 0;\r\nfb->fix.xpanstep = 1;\r\nfb->fix.ypanstep = 1;\r\nfb->fix.ywrapstep = 0;\r\nfb->fix.accel = FB_ACCEL_NONE;\r\nfb->var.nonstd = 0;\r\nfb->var.activate = FB_ACTIVATE_NOW;\r\nfb->var.accel_flags = 0;\r\nfb->var.vmode = FB_VMODE_NONINTERLACED;\r\nfb->var.bits_per_pixel = 16;\r\nif (info->edid_data) {\r\nfb_edid_to_monspecs(info->edid_data, &fb->monspecs);\r\nfb_videomode_to_modelist(fb->monspecs.modedb,\r\nfb->monspecs.modedb_len,\r\n&fb->modelist);\r\n}\r\nif (enable && (pd->flags & SM501FB_FLAG_USE_INIT_MODE) && 0) {\r\n} else {\r\nif (pd->def_mode) {\r\ndev_info(info->dev, "using supplied mode\n");\r\nfb_videomode_to_var(&fb->var, pd->def_mode);\r\nfb->var.bits_per_pixel = pd->def_bpp ? pd->def_bpp : 8;\r\nfb->var.xres_virtual = fb->var.xres;\r\nfb->var.yres_virtual = fb->var.yres;\r\n} else {\r\nif (info->edid_data) {\r\nret = fb_find_mode(&fb->var, fb, fb_mode,\r\nfb->monspecs.modedb,\r\nfb->monspecs.modedb_len,\r\n&sm501_default_mode, default_bpp);\r\nkfree(info->edid_data);\r\n} else {\r\nret = fb_find_mode(&fb->var, fb,\r\nNULL, NULL, 0, NULL, 8);\r\n}\r\nswitch (ret) {\r\ncase 1:\r\ndev_info(info->dev, "using mode specified in "\r\n"@mode\n");\r\nbreak;\r\ncase 2:\r\ndev_info(info->dev, "using mode specified in "\r\n"@mode with ignored refresh rate\n");\r\nbreak;\r\ncase 3:\r\ndev_info(info->dev, "using mode default "\r\n"mode\n");\r\nbreak;\r\ncase 4:\r\ndev_info(info->dev, "using mode from list\n");\r\nbreak;\r\ndefault:\r\ndev_info(info->dev, "ret = %d\n", ret);\r\ndev_info(info->dev, "failed to find mode\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nif (fb_alloc_cmap(&fb->cmap, NR_PALETTE, 0)) {\r\ndev_err(info->dev, "failed to allocate cmap memory\n");\r\nreturn -ENOMEM;\r\n}\r\nfb_set_cmap(&fb->cmap, fb);\r\nret = (fb->fbops->fb_check_var)(&fb->var, fb);\r\nif (ret)\r\ndev_err(info->dev, "check_var() failed on initial setup?\n");\r\nreturn 0;\r\n}\r\nstatic int sm501fb_probe_one(struct sm501fb_info *info,\r\nenum sm501_controller head)\r\n{\r\nunsigned char *name = (head == HEAD_CRT) ? "crt" : "panel";\r\nstruct sm501_platdata_fbsub *pd;\r\nstruct sm501fb_par *par;\r\nstruct fb_info *fbi;\r\npd = (head == HEAD_CRT) ? info->pdata->fb_crt : info->pdata->fb_pnl;\r\nif (pd == NULL) {\r\ndev_info(info->dev, "no data for fb %s (disabled)\n", name);\r\nreturn 0;\r\n}\r\nfbi = framebuffer_alloc(sizeof(struct sm501fb_par), info->dev);\r\nif (fbi == NULL) {\r\ndev_err(info->dev, "cannot allocate %s framebuffer\n", name);\r\nreturn -ENOMEM;\r\n}\r\npar = fbi->par;\r\npar->info = info;\r\npar->head = head;\r\nfbi->pseudo_palette = &par->pseudo_palette;\r\ninfo->fb[head] = fbi;\r\nreturn 0;\r\n}\r\nstatic void sm501_free_init_fb(struct sm501fb_info *info,\r\nenum sm501_controller head)\r\n{\r\nstruct fb_info *fbi = info->fb[head];\r\nfb_dealloc_cmap(&fbi->cmap);\r\n}\r\nstatic int sm501fb_start_one(struct sm501fb_info *info,\r\nenum sm501_controller head, const char *drvname)\r\n{\r\nstruct fb_info *fbi = info->fb[head];\r\nint ret;\r\nif (!fbi)\r\nreturn 0;\r\nmutex_init(&info->fb[head]->mm_lock);\r\nret = sm501fb_init_fb(info->fb[head], head, drvname);\r\nif (ret) {\r\ndev_err(info->dev, "cannot initialise fb %s\n", drvname);\r\nreturn ret;\r\n}\r\nret = register_framebuffer(info->fb[head]);\r\nif (ret) {\r\ndev_err(info->dev, "failed to register fb %s\n", drvname);\r\nsm501_free_init_fb(info, head);\r\nreturn ret;\r\n}\r\ndev_info(info->dev, "fb%d: %s frame buffer\n", fbi->node, fbi->fix.id);\r\nreturn 0;\r\n}\r\nstatic int sm501fb_probe(struct platform_device *pdev)\r\n{\r\nstruct sm501fb_info *info;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\ninfo = kzalloc(sizeof(struct sm501fb_info), GFP_KERNEL);\r\nif (!info) {\r\ndev_err(dev, "failed to allocate state\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo->dev = dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, info);\r\nif (dev->parent->platform_data) {\r\nstruct sm501_platdata *pd = dev->parent->platform_data;\r\ninfo->pdata = pd->fb;\r\n}\r\nif (info->pdata == NULL) {\r\nint found = 0;\r\n#if defined(CONFIG_OF)\r\nstruct device_node *np = pdev->dev.parent->of_node;\r\nconst u8 *prop;\r\nconst char *cp;\r\nint len;\r\ninfo->pdata = &sm501fb_def_pdata;\r\nif (np) {\r\ncp = of_get_property(np, "mode", &len);\r\nif (cp)\r\nstrcpy(fb_mode, cp);\r\nprop = of_get_property(np, "edid", &len);\r\nif (prop && len == EDID_LENGTH) {\r\ninfo->edid_data = kmemdup(prop, EDID_LENGTH,\r\nGFP_KERNEL);\r\nif (info->edid_data)\r\nfound = 1;\r\n}\r\n}\r\n#endif\r\nif (!found) {\r\ndev_info(dev, "using default configuration data\n");\r\ninfo->pdata = &sm501fb_def_pdata;\r\n}\r\n}\r\nret = sm501fb_probe_one(info, HEAD_CRT);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to probe CRT\n");\r\ngoto err_alloc;\r\n}\r\nret = sm501fb_probe_one(info, HEAD_PANEL);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to probe PANEL\n");\r\ngoto err_probed_crt;\r\n}\r\nif (info->fb[HEAD_PANEL] == NULL &&\r\ninfo->fb[HEAD_CRT] == NULL) {\r\ndev_err(dev, "no framebuffers found\n");\r\nret = -ENODEV;\r\ngoto err_alloc;\r\n}\r\nret = sm501fb_start(info, pdev);\r\nif (ret) {\r\ndev_err(dev, "cannot initialise SM501\n");\r\ngoto err_probed_panel;\r\n}\r\nret = sm501fb_start_one(info, HEAD_CRT, driver_name_crt);\r\nif (ret) {\r\ndev_err(dev, "failed to start CRT\n");\r\ngoto err_started;\r\n}\r\nret = sm501fb_start_one(info, HEAD_PANEL, driver_name_pnl);\r\nif (ret) {\r\ndev_err(dev, "failed to start Panel\n");\r\ngoto err_started_crt;\r\n}\r\nret = device_create_file(dev, &dev_attr_crt_src);\r\nif (ret)\r\ngoto err_started_panel;\r\nret = device_create_file(dev, &dev_attr_fbregs_pnl);\r\nif (ret)\r\ngoto err_attached_crtsrc_file;\r\nret = device_create_file(dev, &dev_attr_fbregs_crt);\r\nif (ret)\r\ngoto err_attached_pnlregs_file;\r\nreturn 0;\r\nerr_attached_pnlregs_file:\r\ndevice_remove_file(dev, &dev_attr_fbregs_pnl);\r\nerr_attached_crtsrc_file:\r\ndevice_remove_file(dev, &dev_attr_crt_src);\r\nerr_started_panel:\r\nunregister_framebuffer(info->fb[HEAD_PANEL]);\r\nsm501_free_init_fb(info, HEAD_PANEL);\r\nerr_started_crt:\r\nunregister_framebuffer(info->fb[HEAD_CRT]);\r\nsm501_free_init_fb(info, HEAD_CRT);\r\nerr_started:\r\nsm501fb_stop(info);\r\nerr_probed_panel:\r\nframebuffer_release(info->fb[HEAD_PANEL]);\r\nerr_probed_crt:\r\nframebuffer_release(info->fb[HEAD_CRT]);\r\nerr_alloc:\r\nkfree(info);\r\nreturn ret;\r\n}\r\nstatic int sm501fb_remove(struct platform_device *pdev)\r\n{\r\nstruct sm501fb_info *info = platform_get_drvdata(pdev);\r\nstruct fb_info *fbinfo_crt = info->fb[0];\r\nstruct fb_info *fbinfo_pnl = info->fb[1];\r\ndevice_remove_file(&pdev->dev, &dev_attr_fbregs_crt);\r\ndevice_remove_file(&pdev->dev, &dev_attr_fbregs_pnl);\r\ndevice_remove_file(&pdev->dev, &dev_attr_crt_src);\r\nsm501_free_init_fb(info, HEAD_CRT);\r\nsm501_free_init_fb(info, HEAD_PANEL);\r\nunregister_framebuffer(fbinfo_crt);\r\nunregister_framebuffer(fbinfo_pnl);\r\nsm501fb_stop(info);\r\nkfree(info);\r\nframebuffer_release(fbinfo_pnl);\r\nframebuffer_release(fbinfo_crt);\r\nreturn 0;\r\n}\r\nstatic int sm501fb_suspend_fb(struct sm501fb_info *info,\r\nenum sm501_controller head)\r\n{\r\nstruct fb_info *fbi = info->fb[head];\r\nstruct sm501fb_par *par = fbi->par;\r\nif (par->screen.size == 0)\r\nreturn 0;\r\n(par->ops.fb_blank)(FB_BLANK_POWERDOWN, fbi);\r\nconsole_lock();\r\nfb_set_suspend(fbi, 1);\r\nconsole_unlock();\r\npar->store_fb = vmalloc(par->screen.size);\r\nif (par->store_fb == NULL) {\r\ndev_err(info->dev, "no memory to store screen\n");\r\nreturn -ENOMEM;\r\n}\r\npar->store_cursor = vmalloc(par->cursor.size);\r\nif (par->store_cursor == NULL) {\r\ndev_err(info->dev, "no memory to store cursor\n");\r\ngoto err_nocursor;\r\n}\r\ndev_dbg(info->dev, "suspending screen to %p\n", par->store_fb);\r\ndev_dbg(info->dev, "suspending cursor to %p\n", par->store_cursor);\r\nmemcpy_fromio(par->store_fb, par->screen.k_addr, par->screen.size);\r\nmemcpy_fromio(par->store_cursor, par->cursor.k_addr, par->cursor.size);\r\nreturn 0;\r\nerr_nocursor:\r\nvfree(par->store_fb);\r\npar->store_fb = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic void sm501fb_resume_fb(struct sm501fb_info *info,\r\nenum sm501_controller head)\r\n{\r\nstruct fb_info *fbi = info->fb[head];\r\nstruct sm501fb_par *par = fbi->par;\r\nif (par->screen.size == 0)\r\nreturn;\r\n(par->ops.fb_set_par)(fbi);\r\ndev_dbg(info->dev, "restoring screen from %p\n", par->store_fb);\r\ndev_dbg(info->dev, "restoring cursor from %p\n", par->store_cursor);\r\nif (par->store_fb)\r\nmemcpy_toio(par->screen.k_addr, par->store_fb,\r\npar->screen.size);\r\nif (par->store_cursor)\r\nmemcpy_toio(par->cursor.k_addr, par->store_cursor,\r\npar->cursor.size);\r\nconsole_lock();\r\nfb_set_suspend(fbi, 0);\r\nconsole_unlock();\r\nvfree(par->store_fb);\r\nvfree(par->store_cursor);\r\n}\r\nstatic int sm501fb_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct sm501fb_info *info = platform_get_drvdata(pdev);\r\ninfo->pm_crt_ctrl = smc501_readl(info->regs + SM501_DC_CRT_CONTROL);\r\nsm501fb_suspend_fb(info, HEAD_CRT);\r\nsm501fb_suspend_fb(info, HEAD_PANEL);\r\nsm501_unit_power(info->dev->parent, SM501_GATE_DISPLAY, 0);\r\nreturn 0;\r\n}\r\nstatic int sm501fb_resume(struct platform_device *pdev)\r\n{\r\nstruct sm501fb_info *info = platform_get_drvdata(pdev);\r\nunsigned long crt_ctrl;\r\nsm501_unit_power(info->dev->parent, SM501_GATE_DISPLAY, 1);\r\ncrt_ctrl = smc501_readl(info->regs + SM501_DC_CRT_CONTROL);\r\ncrt_ctrl &= ~SM501_CRT_CTRL_SAVE;\r\ncrt_ctrl |= info->pm_crt_ctrl & SM501_CRT_CTRL_SAVE;\r\nsmc501_writel(crt_ctrl, info->regs + SM501_DC_CRT_CONTROL);\r\nsm501fb_resume_fb(info, HEAD_CRT);\r\nsm501fb_resume_fb(info, HEAD_PANEL);\r\nreturn 0;\r\n}
