int core_tmr_alloc_req(\r\nstruct se_cmd *se_cmd,\r\nvoid *fabric_tmr_ptr,\r\nu8 function,\r\ngfp_t gfp_flags)\r\n{\r\nstruct se_tmr_req *tmr;\r\ntmr = kzalloc(sizeof(struct se_tmr_req), gfp_flags);\r\nif (!tmr) {\r\npr_err("Unable to allocate struct se_tmr_req\n");\r\nreturn -ENOMEM;\r\n}\r\nse_cmd->se_cmd_flags |= SCF_SCSI_TMR_CDB;\r\nse_cmd->se_tmr_req = tmr;\r\ntmr->task_cmd = se_cmd;\r\ntmr->fabric_tmr_ptr = fabric_tmr_ptr;\r\ntmr->function = function;\r\nINIT_LIST_HEAD(&tmr->tmr_list);\r\nreturn 0;\r\n}\r\nvoid core_tmr_release_req(struct se_tmr_req *tmr)\r\n{\r\nstruct se_device *dev = tmr->tmr_dev;\r\nunsigned long flags;\r\nif (dev) {\r\nspin_lock_irqsave(&dev->se_tmr_lock, flags);\r\nlist_del(&tmr->tmr_list);\r\nspin_unlock_irqrestore(&dev->se_tmr_lock, flags);\r\n}\r\nkfree(tmr);\r\n}\r\nstatic void core_tmr_handle_tas_abort(\r\nstruct se_node_acl *tmr_nacl,\r\nstruct se_cmd *cmd,\r\nint tas)\r\n{\r\nbool remove = true;\r\nif ((tmr_nacl && (tmr_nacl != cmd->se_sess->se_node_acl)) && tas) {\r\nremove = false;\r\ntransport_send_task_abort(cmd);\r\n}\r\ntransport_cmd_finish_abort(cmd, remove);\r\n}\r\nstatic int target_check_cdb_and_preempt(struct list_head *list,\r\nstruct se_cmd *cmd)\r\n{\r\nstruct t10_pr_registration *reg;\r\nif (!list)\r\nreturn 0;\r\nlist_for_each_entry(reg, list, pr_reg_abort_list) {\r\nif (reg->pr_res_key == cmd->pr_res_key)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nvoid core_tmr_abort_task(\r\nstruct se_device *dev,\r\nstruct se_tmr_req *tmr,\r\nstruct se_session *se_sess)\r\n{\r\nstruct se_cmd *se_cmd;\r\nunsigned long flags;\r\nint ref_tag;\r\nspin_lock_irqsave(&se_sess->sess_cmd_lock, flags);\r\nlist_for_each_entry(se_cmd, &se_sess->sess_cmd_list, se_cmd_list) {\r\nif (dev != se_cmd->se_dev)\r\ncontinue;\r\nif (tmr->task_cmd == se_cmd)\r\ncontinue;\r\nref_tag = se_cmd->se_tfo->get_task_tag(se_cmd);\r\nif (tmr->ref_task_tag != ref_tag)\r\ncontinue;\r\nprintk("ABORT_TASK: Found referenced %s task_tag: %u\n",\r\nse_cmd->se_tfo->get_fabric_name(), ref_tag);\r\nspin_lock(&se_cmd->t_state_lock);\r\nif (se_cmd->transport_state & CMD_T_COMPLETE) {\r\nprintk("ABORT_TASK: ref_tag: %u already complete, skipping\n", ref_tag);\r\nspin_unlock(&se_cmd->t_state_lock);\r\nspin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);\r\ngoto out;\r\n}\r\nse_cmd->transport_state |= CMD_T_ABORTED;\r\nspin_unlock(&se_cmd->t_state_lock);\r\nlist_del_init(&se_cmd->se_cmd_list);\r\nkref_get(&se_cmd->cmd_kref);\r\nspin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);\r\ncancel_work_sync(&se_cmd->work);\r\ntransport_wait_for_tasks(se_cmd);\r\ntarget_put_sess_cmd(se_sess, se_cmd);\r\ntransport_cmd_finish_abort(se_cmd, true);\r\nprintk("ABORT_TASK: Sending TMR_FUNCTION_COMPLETE for"\r\n" ref_tag: %d\n", ref_tag);\r\ntmr->response = TMR_FUNCTION_COMPLETE;\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);\r\nout:\r\nprintk("ABORT_TASK: Sending TMR_TASK_DOES_NOT_EXIST for ref_tag: %d\n",\r\ntmr->ref_task_tag);\r\ntmr->response = TMR_TASK_DOES_NOT_EXIST;\r\n}\r\nstatic void core_tmr_drain_tmr_list(\r\nstruct se_device *dev,\r\nstruct se_tmr_req *tmr,\r\nstruct list_head *preempt_and_abort_list)\r\n{\r\nLIST_HEAD(drain_tmr_list);\r\nstruct se_tmr_req *tmr_p, *tmr_pp;\r\nstruct se_cmd *cmd;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->se_tmr_lock, flags);\r\nlist_for_each_entry_safe(tmr_p, tmr_pp, &dev->dev_tmr_list, tmr_list) {\r\nif (tmr_p == tmr)\r\ncontinue;\r\ncmd = tmr_p->task_cmd;\r\nif (!cmd) {\r\npr_err("Unable to locate struct se_cmd for TMR\n");\r\ncontinue;\r\n}\r\nif (target_check_cdb_and_preempt(preempt_and_abort_list, cmd))\r\ncontinue;\r\nspin_lock(&cmd->t_state_lock);\r\nif (!(cmd->transport_state & CMD_T_ACTIVE)) {\r\nspin_unlock(&cmd->t_state_lock);\r\ncontinue;\r\n}\r\nif (cmd->t_state == TRANSPORT_ISTATE_PROCESSING) {\r\nspin_unlock(&cmd->t_state_lock);\r\ncontinue;\r\n}\r\nspin_unlock(&cmd->t_state_lock);\r\nlist_move_tail(&tmr_p->tmr_list, &drain_tmr_list);\r\n}\r\nspin_unlock_irqrestore(&dev->se_tmr_lock, flags);\r\nlist_for_each_entry_safe(tmr_p, tmr_pp, &drain_tmr_list, tmr_list) {\r\nlist_del_init(&tmr_p->tmr_list);\r\ncmd = tmr_p->task_cmd;\r\npr_debug("LUN_RESET: %s releasing TMR %p Function: 0x%02x,"\r\n" Response: 0x%02x, t_state: %d\n",\r\n(preempt_and_abort_list) ? "Preempt" : "", tmr_p,\r\ntmr_p->function, tmr_p->response, cmd->t_state);\r\ntransport_cmd_finish_abort(cmd, 1);\r\n}\r\n}\r\nstatic void core_tmr_drain_state_list(\r\nstruct se_device *dev,\r\nstruct se_cmd *prout_cmd,\r\nstruct se_node_acl *tmr_nacl,\r\nint tas,\r\nstruct list_head *preempt_and_abort_list)\r\n{\r\nLIST_HEAD(drain_task_list);\r\nstruct se_cmd *cmd, *next;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->execute_task_lock, flags);\r\nlist_for_each_entry_safe(cmd, next, &dev->state_list, state_list) {\r\nif (target_check_cdb_and_preempt(preempt_and_abort_list, cmd))\r\ncontinue;\r\nif (prout_cmd == cmd)\r\ncontinue;\r\nlist_move_tail(&cmd->state_list, &drain_task_list);\r\ncmd->state_active = false;\r\n}\r\nspin_unlock_irqrestore(&dev->execute_task_lock, flags);\r\nwhile (!list_empty(&drain_task_list)) {\r\ncmd = list_entry(drain_task_list.next, struct se_cmd, state_list);\r\nlist_del(&cmd->state_list);\r\npr_debug("LUN_RESET: %s cmd: %p"\r\n" ITT/CmdSN: 0x%08x/0x%08x, i_state: %d, t_state: %d"\r\n"cdb: 0x%02x\n",\r\n(preempt_and_abort_list) ? "Preempt" : "", cmd,\r\ncmd->se_tfo->get_task_tag(cmd), 0,\r\ncmd->se_tfo->get_cmd_state(cmd), cmd->t_state,\r\ncmd->t_task_cdb[0]);\r\npr_debug("LUN_RESET: ITT[0x%08x] - pr_res_key: 0x%016Lx"\r\n" -- CMD_T_ACTIVE: %d"\r\n" CMD_T_STOP: %d CMD_T_SENT: %d\n",\r\ncmd->se_tfo->get_task_tag(cmd), cmd->pr_res_key,\r\n(cmd->transport_state & CMD_T_ACTIVE) != 0,\r\n(cmd->transport_state & CMD_T_STOP) != 0,\r\n(cmd->transport_state & CMD_T_SENT) != 0);\r\nif (cmd->t_state == TRANSPORT_COMPLETE)\r\ncancel_work_sync(&cmd->work);\r\nspin_lock_irqsave(&cmd->t_state_lock, flags);\r\ntarget_stop_cmd(cmd, &flags);\r\ncmd->transport_state |= CMD_T_ABORTED;\r\nspin_unlock_irqrestore(&cmd->t_state_lock, flags);\r\ncore_tmr_handle_tas_abort(tmr_nacl, cmd, tas);\r\n}\r\n}\r\nint core_tmr_lun_reset(\r\nstruct se_device *dev,\r\nstruct se_tmr_req *tmr,\r\nstruct list_head *preempt_and_abort_list,\r\nstruct se_cmd *prout_cmd)\r\n{\r\nstruct se_node_acl *tmr_nacl = NULL;\r\nstruct se_portal_group *tmr_tpg = NULL;\r\nint tas;\r\ntas = dev->dev_attrib.emulate_tas;\r\nif (tmr && tmr->task_cmd && tmr->task_cmd->se_sess) {\r\ntmr_nacl = tmr->task_cmd->se_sess->se_node_acl;\r\ntmr_tpg = tmr->task_cmd->se_sess->se_tpg;\r\nif (tmr_nacl && tmr_tpg) {\r\npr_debug("LUN_RESET: TMR caller fabric: %s"\r\n" initiator port %s\n",\r\ntmr_tpg->se_tpg_tfo->get_fabric_name(),\r\ntmr_nacl->initiatorname);\r\n}\r\n}\r\npr_debug("LUN_RESET: %s starting for [%s], tas: %d\n",\r\n(preempt_and_abort_list) ? "Preempt" : "TMR",\r\ndev->transport->name, tas);\r\ncore_tmr_drain_tmr_list(dev, tmr, preempt_and_abort_list);\r\ncore_tmr_drain_state_list(dev, prout_cmd, tmr_nacl, tas,\r\npreempt_and_abort_list);\r\nif (!preempt_and_abort_list &&\r\n(dev->dev_reservation_flags & DRF_SPC2_RESERVATIONS)) {\r\nspin_lock(&dev->dev_reservation_lock);\r\ndev->dev_reserved_node_acl = NULL;\r\ndev->dev_reservation_flags &= ~DRF_SPC2_RESERVATIONS;\r\nspin_unlock(&dev->dev_reservation_lock);\r\npr_debug("LUN_RESET: SCSI-2 Released reservation\n");\r\n}\r\natomic_long_inc(&dev->num_resets);\r\npr_debug("LUN_RESET: %s for [%s] Complete\n",\r\n(preempt_and_abort_list) ? "Preempt" : "TMR",\r\ndev->transport->name);\r\nreturn 0;\r\n}
