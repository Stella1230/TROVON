int vnt_control_out(struct vnt_private *priv, u8 request, u16 value,\r\nu16 index, u16 length, u8 *buffer)\r\n{\r\nint status = 0;\r\nif (test_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags))\r\nreturn STATUS_FAILURE;\r\nmutex_lock(&priv->usb_lock);\r\nstatus = usb_control_msg(priv->usb,\r\nusb_sndctrlpipe(priv->usb, 0), request, 0x40, value,\r\nindex, buffer, length, USB_CTL_WAIT);\r\nmutex_unlock(&priv->usb_lock);\r\nif (status < (int)length)\r\nreturn STATUS_FAILURE;\r\nreturn STATUS_SUCCESS;\r\n}\r\nvoid vnt_control_out_u8(struct vnt_private *priv, u8 reg, u8 reg_off, u8 data)\r\n{\r\nvnt_control_out(priv, MESSAGE_TYPE_WRITE,\r\nreg_off, reg, sizeof(u8), &data);\r\n}\r\nint vnt_control_in(struct vnt_private *priv, u8 request, u16 value,\r\nu16 index, u16 length, u8 *buffer)\r\n{\r\nint status;\r\nif (test_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags))\r\nreturn STATUS_FAILURE;\r\nmutex_lock(&priv->usb_lock);\r\nstatus = usb_control_msg(priv->usb,\r\nusb_rcvctrlpipe(priv->usb, 0), request, 0xc0, value,\r\nindex, buffer, length, USB_CTL_WAIT);\r\nmutex_unlock(&priv->usb_lock);\r\nif (status < (int)length)\r\nreturn STATUS_FAILURE;\r\nreturn STATUS_SUCCESS;\r\n}\r\nvoid vnt_control_in_u8(struct vnt_private *priv, u8 reg, u8 reg_off, u8 *data)\r\n{\r\nvnt_control_in(priv, MESSAGE_TYPE_READ,\r\nreg_off, reg, sizeof(u8), data);\r\n}\r\nstatic void vnt_start_interrupt_urb_complete(struct urb *urb)\r\n{\r\nstruct vnt_private *priv = urb->context;\r\nint status;\r\nswitch (urb->status) {\r\ncase 0:\r\ncase -ETIMEDOUT:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\npriv->int_buf.in_use = false;\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\nstatus = urb->status;\r\nif (status != STATUS_SUCCESS) {\r\npriv->int_buf.in_use = false;\r\ndev_dbg(&priv->usb->dev, "%s status = %d\n", __func__, status);\r\n} else {\r\nvnt_int_process_data(priv);\r\n}\r\nstatus = usb_submit_urb(priv->interrupt_urb, GFP_ATOMIC);\r\nif (status)\r\ndev_dbg(&priv->usb->dev, "Submit int URB failed %d\n", status);\r\nelse\r\npriv->int_buf.in_use = true;\r\n}\r\nint vnt_start_interrupt_urb(struct vnt_private *priv)\r\n{\r\nint status = STATUS_FAILURE;\r\nif (priv->int_buf.in_use == true)\r\nreturn STATUS_FAILURE;\r\npriv->int_buf.in_use = true;\r\nusb_fill_int_urb(priv->interrupt_urb,\r\npriv->usb,\r\nusb_rcvintpipe(priv->usb, 1),\r\npriv->int_buf.data_buf,\r\nMAX_INTERRUPT_SIZE,\r\nvnt_start_interrupt_urb_complete,\r\npriv,\r\npriv->int_interval);\r\nstatus = usb_submit_urb(priv->interrupt_urb, GFP_ATOMIC);\r\nif (status) {\r\ndev_dbg(&priv->usb->dev, "Submit int URB failed %d\n", status);\r\npriv->int_buf.in_use = false;\r\n}\r\nreturn status;\r\n}\r\nstatic void vnt_submit_rx_urb_complete(struct urb *urb)\r\n{\r\nstruct vnt_rcb *rcb = urb->context;\r\nstruct vnt_private *priv = rcb->priv;\r\nunsigned long flags;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ncase -ETIMEDOUT:\r\ndefault:\r\ndev_dbg(&priv->usb->dev, "BULK In failed %d\n", urb->status);\r\nbreak;\r\n}\r\nif (urb->actual_length) {\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (vnt_rx_data(priv, rcb, urb->actual_length)) {\r\nrcb->skb = dev_alloc_skb(priv->rx_buf_sz);\r\nif (!rcb->skb) {\r\ndev_dbg(&priv->usb->dev,\r\n"Failed to re-alloc rx skb\n");\r\nrcb->in_use = false;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn;\r\n}\r\n} else {\r\nskb_push(rcb->skb, skb_headroom(rcb->skb));\r\nskb_trim(rcb->skb, 0);\r\n}\r\nurb->transfer_buffer = skb_put(rcb->skb,\r\nskb_tailroom(rcb->skb));\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nif (usb_submit_urb(urb, GFP_ATOMIC)) {\r\ndev_dbg(&priv->usb->dev, "Failed to re submit rx skb\n");\r\nrcb->in_use = false;\r\n}\r\n}\r\nint vnt_submit_rx_urb(struct vnt_private *priv, struct vnt_rcb *rcb)\r\n{\r\nint status = 0;\r\nstruct urb *urb;\r\nurb = rcb->urb;\r\nif (rcb->skb == NULL) {\r\ndev_dbg(&priv->usb->dev, "rcb->skb is null\n");\r\nreturn status;\r\n}\r\nusb_fill_bulk_urb(urb,\r\npriv->usb,\r\nusb_rcvbulkpipe(priv->usb, 2),\r\nskb_put(rcb->skb, skb_tailroom(rcb->skb)),\r\nMAX_TOTAL_SIZE_WITH_ALL_HEADERS,\r\nvnt_submit_rx_urb_complete,\r\nrcb);\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status != 0) {\r\ndev_dbg(&priv->usb->dev, "Submit Rx URB failed %d\n", status);\r\nreturn STATUS_FAILURE;\r\n}\r\nrcb->in_use = true;\r\nreturn status;\r\n}\r\nstatic void vnt_tx_context_complete(struct urb *urb)\r\n{\r\nstruct vnt_usb_send_context *context = urb->context;\r\nstruct vnt_private *priv = context->priv;\r\nswitch (urb->status) {\r\ncase 0:\r\ndev_dbg(&priv->usb->dev, "Write %d bytes\n", context->buf_len);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncontext->in_use = false;\r\nreturn;\r\ncase -ETIMEDOUT:\r\ndefault:\r\ndev_dbg(&priv->usb->dev, "BULK Out failed %d\n", urb->status);\r\nbreak;\r\n}\r\nif (context->type == CONTEXT_DATA_PACKET)\r\nieee80211_wake_queues(priv->hw);\r\nif (urb->status || context->type == CONTEXT_BEACON_PACKET) {\r\nif (context->skb)\r\nieee80211_free_txskb(priv->hw, context->skb);\r\ncontext->in_use = false;\r\n}\r\n}\r\nint vnt_tx_context(struct vnt_private *priv,\r\nstruct vnt_usb_send_context *context)\r\n{\r\nint status;\r\nstruct urb *urb;\r\nif (test_bit(DEVICE_FLAGS_DISCONNECTED, &priv->flags)) {\r\ncontext->in_use = false;\r\nreturn STATUS_RESOURCES;\r\n}\r\nurb = context->urb;\r\nusb_fill_bulk_urb(urb,\r\npriv->usb,\r\nusb_sndbulkpipe(priv->usb, 3),\r\ncontext->data,\r\ncontext->buf_len,\r\nvnt_tx_context_complete,\r\ncontext);\r\nstatus = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (status != 0) {\r\ndev_dbg(&priv->usb->dev, "Submit Tx URB failed %d\n", status);\r\ncontext->in_use = false;\r\nreturn STATUS_FAILURE;\r\n}\r\nreturn STATUS_PENDING;\r\n}
