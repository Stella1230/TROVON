void indicate_wx_scan_complete_event(struct adapter *padapter)\r\n{\r\nunion iwreq_data wrqu;\r\nmemset(&wrqu, 0, sizeof(union iwreq_data));\r\nwireless_send_event(padapter->pnetdev, SIOCGIWSCAN, &wrqu, NULL);\r\n}\r\nvoid rtw_indicate_wx_assoc_event(struct adapter *padapter)\r\n{\r\nunion iwreq_data wrqu;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nmemset(&wrqu, 0, sizeof(union iwreq_data));\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(wrqu.ap_addr.sa_data, pmlmepriv->cur_network.network.MacAddress, ETH_ALEN);\r\nDBG_88E_LEVEL(_drv_always_, "assoc success\n");\r\nwireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);\r\n}\r\nvoid rtw_indicate_wx_disassoc_event(struct adapter *padapter)\r\n{\r\nunion iwreq_data wrqu;\r\nmemset(&wrqu, 0, sizeof(union iwreq_data));\r\nwrqu.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);\r\nDBG_88E_LEVEL(_drv_always_, "indicate disassoc\n");\r\nwireless_send_event(padapter->pnetdev, SIOCGIWAP, &wrqu, NULL);\r\n}\r\nstatic char *translate_scan(struct adapter *padapter,\r\nstruct iw_request_info *info,\r\nstruct wlan_network *pnetwork,\r\nchar *start, char *stop)\r\n{\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct iw_event iwe;\r\nu16 cap;\r\n__le16 le_tmp;\r\nu32 ht_ielen = 0;\r\nchar custom[MAX_CUSTOM_LEN];\r\nchar *p;\r\nu16 max_rate = 0, rate, ht_cap = false;\r\nu32 i = 0;\r\nu8 bw_40MHz = 0, short_GI = 0;\r\nu16 mcs_rate = 0;\r\nu8 ss, sq;\r\niwe.cmd = SIOCGIWAP;\r\niwe.u.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(iwe.u.ap_addr.sa_data, pnetwork->network.MacAddress, ETH_ALEN);\r\nstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN);\r\niwe.cmd = SIOCGIWESSID;\r\niwe.u.data.flags = 1;\r\niwe.u.data.length = min_t(u16, pnetwork->network.Ssid.SsidLength, 32);\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, pnetwork->network.Ssid.Ssid);\r\np = rtw_get_ie(&pnetwork->network.IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pnetwork->network.IELength-12);\r\nif (p && ht_ielen > 0) {\r\nstruct rtw_ieee80211_ht_cap *pht_capie;\r\nht_cap = true;\r\npht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);\r\nmemcpy(&mcs_rate, pht_capie->supp_mcs_set, 2);\r\nbw_40MHz = (pht_capie->cap_info&IEEE80211_HT_CAP_SUP_WIDTH) ? 1 : 0;\r\nshort_GI = (pht_capie->cap_info&(IEEE80211_HT_CAP_SGI_20|IEEE80211_HT_CAP_SGI_40)) ? 1 : 0;\r\n}\r\niwe.cmd = SIOCGIWNAME;\r\nif ((rtw_is_cckratesonly_included((u8 *)&pnetwork->network.SupportedRates))) {\r\nif (ht_cap)\r\nsnprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bn");\r\nelse\r\nsnprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11b");\r\n} else if ((rtw_is_cckrates_included((u8 *)&pnetwork->network.SupportedRates))) {\r\nif (ht_cap)\r\nsnprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bgn");\r\nelse\r\nsnprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11bg");\r\n} else {\r\nif (pnetwork->network.Configuration.DSConfig > 14) {\r\nif (ht_cap)\r\nsnprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11an");\r\nelse\r\nsnprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11a");\r\n} else {\r\nif (ht_cap)\r\nsnprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11gn");\r\nelse\r\nsnprintf(iwe.u.name, IFNAMSIZ, "IEEE 802.11g");\r\n}\r\n}\r\nstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);\r\niwe.cmd = SIOCGIWMODE;\r\nmemcpy(&le_tmp, rtw_get_capability_from_ie(pnetwork->network.IEs), 2);\r\ncap = le16_to_cpu(le_tmp);\r\nif (cap & (WLAN_CAPABILITY_IBSS | WLAN_CAPABILITY_BSS)) {\r\nif (cap & WLAN_CAPABILITY_BSS)\r\niwe.u.mode = IW_MODE_MASTER;\r\nelse\r\niwe.u.mode = IW_MODE_ADHOC;\r\nstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_UINT_LEN);\r\n}\r\nif (pnetwork->network.Configuration.DSConfig < 1)\r\npnetwork->network.Configuration.DSConfig = 1;\r\niwe.cmd = SIOCGIWFREQ;\r\niwe.u.freq.m = rtw_ch2freq(pnetwork->network.Configuration.DSConfig) * 100000;\r\niwe.u.freq.e = 1;\r\niwe.u.freq.i = pnetwork->network.Configuration.DSConfig;\r\nstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_FREQ_LEN);\r\niwe.cmd = SIOCGIWENCODE;\r\nif (cap & WLAN_CAPABILITY_PRIVACY)\r\niwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\r\nelse\r\niwe.u.data.flags = IW_ENCODE_DISABLED;\r\niwe.u.data.length = 0;\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, pnetwork->network.Ssid.Ssid);\r\nmax_rate = 0;\r\np = custom;\r\np += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Rates (Mb/s): ");\r\nwhile (pnetwork->network.SupportedRates[i] != 0) {\r\nrate = pnetwork->network.SupportedRates[i]&0x7F;\r\nif (rate > max_rate)\r\nmax_rate = rate;\r\np += snprintf(p, MAX_CUSTOM_LEN - (p - custom),\r\n"%d%s ", rate >> 1, (rate & 1) ? ".5" : "");\r\ni++;\r\n}\r\nif (ht_cap) {\r\nif (mcs_rate&0x8000)\r\nmax_rate = (bw_40MHz) ? ((short_GI) ? 300 : 270) : ((short_GI) ? 144 : 130);\r\nelse if (mcs_rate&0x0080)\r\n;\r\nelse\r\nmax_rate = (bw_40MHz) ? ((short_GI) ? 150 : 135) : ((short_GI) ? 72 : 65);\r\nmax_rate = max_rate*2;\r\n}\r\niwe.cmd = SIOCGIWRATE;\r\niwe.u.bitrate.fixed = 0;\r\niwe.u.bitrate.disabled = 0;\r\niwe.u.bitrate.value = max_rate * 500000;\r\nstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_PARAM_LEN);\r\n{\r\nu8 buf[MAX_WPA_IE_LEN];\r\nu8 wpa_ie[255], rsn_ie[255];\r\nu16 wpa_len = 0, rsn_len = 0;\r\nu8 *p;\r\nrtw_get_sec_ie(pnetwork->network.IEs, pnetwork->network.IELength, rsn_ie, &rsn_len, wpa_ie, &wpa_len);\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_scan: ssid =%s\n", pnetwork->network.Ssid.Ssid));\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_scan: wpa_len =%d rsn_len =%d\n", wpa_len, rsn_len));\r\nif (wpa_len > 0) {\r\np = buf;\r\nmemset(buf, 0, MAX_WPA_IE_LEN);\r\np += sprintf(p, "wpa_ie=");\r\nfor (i = 0; i < wpa_len; i++)\r\np += sprintf(p, "%02x", wpa_ie[i]);\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVCUSTOM;\r\niwe.u.data.length = strlen(buf);\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, buf);\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = wpa_len;\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, wpa_ie);\r\n}\r\nif (rsn_len > 0) {\r\np = buf;\r\nmemset(buf, 0, MAX_WPA_IE_LEN);\r\np += sprintf(p, "rsn_ie=");\r\nfor (i = 0; i < rsn_len; i++)\r\np += sprintf(p, "%02x", rsn_ie[i]);\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVCUSTOM;\r\niwe.u.data.length = strlen(buf);\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, buf);\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = rsn_len;\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, rsn_ie);\r\n}\r\n}\r\n{\r\nuint cnt = 0, total_ielen;\r\nu8 *wpsie_ptr = NULL;\r\nuint wps_ielen = 0;\r\nu8 *ie_ptr = pnetwork->network.IEs + _FIXED_IE_LENGTH_;\r\ntotal_ielen = pnetwork->network.IELength - _FIXED_IE_LENGTH_;\r\nwhile (cnt < total_ielen) {\r\nif (rtw_is_wps_ie(&ie_ptr[cnt], &wps_ielen) && (wps_ielen > 2)) {\r\nwpsie_ptr = &ie_ptr[cnt];\r\niwe.cmd = IWEVGENIE;\r\niwe.u.data.length = (u16)wps_ielen;\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, wpsie_ptr);\r\n}\r\ncnt += ie_ptr[cnt+1]+2;\r\n}\r\n}\r\niwe.cmd = IWEVQUAL;\r\niwe.u.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_INVALID;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == true &&\r\nis_same_network(&pmlmepriv->cur_network.network, &pnetwork->network)) {\r\nss = padapter->recvpriv.signal_strength;\r\nsq = padapter->recvpriv.signal_qual;\r\n} else {\r\nss = pnetwork->network.PhyInfo.SignalStrength;\r\nsq = pnetwork->network.PhyInfo.SignalQuality;\r\n}\r\niwe.u.qual.level = (u8)ss;\r\niwe.u.qual.qual = (u8)sq;\r\niwe.u.qual.noise = 0;\r\nstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);\r\nreturn start;\r\n}\r\nstatic int wpa_set_auth_algs(struct net_device *dev, u32 value)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nint ret = 0;\r\nif ((value & AUTH_ALG_SHARED_KEY) && (value & AUTH_ALG_OPEN_SYSTEM)) {\r\nDBG_88E("wpa_set_auth_algs, AUTH_ALG_SHARED_KEY and AUTH_ALG_OPEN_SYSTEM [value:0x%x]\n", value);\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\npadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeAutoSwitch;\r\npadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Auto;\r\n} else if (value & AUTH_ALG_SHARED_KEY) {\r\nDBG_88E("wpa_set_auth_algs, AUTH_ALG_SHARED_KEY [value:0x%x]\n", value);\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\npadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeShared;\r\npadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Shared;\r\n} else if (value & AUTH_ALG_OPEN_SYSTEM) {\r\nDBG_88E("wpa_set_auth_algs, AUTH_ALG_OPEN_SYSTEM\n");\r\nif (padapter->securitypriv.ndisauthtype < Ndis802_11AuthModeWPAPSK) {\r\npadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;\r\npadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;\r\n}\r\n} else if (value & AUTH_ALG_LEAP) {\r\nDBG_88E("wpa_set_auth_algs, AUTH_ALG_LEAP\n");\r\n} else {\r\nDBG_88E("wpa_set_auth_algs, error!\n");\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int wpa_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)\r\n{\r\nint ret = 0;\r\nu32 wep_key_idx, wep_key_len, wep_total_len;\r\nstruct ndis_802_11_wep *pwep = NULL;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nparam->u.crypt.err = 0;\r\nparam->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';\r\nif (param_len < (u32)((u8 *)param->u.crypt.key - (u8 *)param) + param->u.crypt.key_len) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\r\nparam->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\r\nparam->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {\r\nif (param->u.crypt.idx >= WEP_KEYS) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\n} else {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nif (strcmp(param->u.crypt.alg, "WEP") == 0) {\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("wpa_set_encryption, crypt.alg = WEP\n"));\r\nDBG_88E("wpa_set_encryption, crypt.alg = WEP\n");\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;\r\npadapter->securitypriv.dot118021XGrpPrivacy = _WEP40_;\r\nwep_key_idx = param->u.crypt.idx;\r\nwep_key_len = param->u.crypt.key_len;\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("(1)wep_key_idx =%d\n", wep_key_idx));\r\nDBG_88E("(1)wep_key_idx =%d\n", wep_key_idx);\r\nif (wep_key_idx > WEP_KEYS)\r\nreturn -EINVAL;\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("(2)wep_key_idx =%d\n", wep_key_idx));\r\nif (wep_key_len > 0) {\r\nwep_key_len = wep_key_len <= 5 ? 5 : 13;\r\nwep_total_len = wep_key_len + FIELD_OFFSET(struct ndis_802_11_wep, KeyMaterial);\r\npwep = (struct ndis_802_11_wep *)rtw_malloc(wep_total_len);\r\nif (pwep == NULL) {\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, (" wpa_set_encryption: pwep allocate fail !!!\n"));\r\ngoto exit;\r\n}\r\nmemset(pwep, 0, wep_total_len);\r\npwep->KeyLength = wep_key_len;\r\npwep->Length = wep_total_len;\r\nif (wep_key_len == 13) {\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;\r\npadapter->securitypriv.dot118021XGrpPrivacy = _WEP104_;\r\n}\r\n} else {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\npwep->KeyIndex = wep_key_idx;\r\npwep->KeyIndex |= 0x80000000;\r\nmemcpy(pwep->KeyMaterial, param->u.crypt.key, pwep->KeyLength);\r\nif (param->u.crypt.set_tx) {\r\nDBG_88E("wep, set_tx = 1\n");\r\nif (rtw_set_802_11_add_wep(padapter, pwep) == (u8)_FAIL)\r\nret = -EOPNOTSUPP;\r\n} else {\r\nDBG_88E("wep, set_tx = 0\n");\r\nif (wep_key_idx >= WEP_KEYS) {\r\nret = -EOPNOTSUPP;\r\ngoto exit;\r\n}\r\nmemcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);\r\npsecuritypriv->dot11DefKeylen[wep_key_idx] = pwep->KeyLength;\r\nrtw_set_key(padapter, psecuritypriv, wep_key_idx, 0);\r\n}\r\ngoto exit;\r\n}\r\nif (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) {\r\nstruct sta_info *psta, *pbcmc_sta;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_MP_STATE)) {\r\npsta = rtw_get_stainfo(pstapriv, get_bssid(pmlmepriv));\r\nif (psta == NULL) {\r\n;\r\n} else {\r\nif (strcmp(param->u.crypt.alg, "none") != 0)\r\npsta->ieee8021x_blocked = false;\r\nif ((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled) ||\r\n(padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption3Enabled))\r\npsta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;\r\nif (param->u.crypt.set_tx == 1) {\r\nmemcpy(psta->dot118021x_UncstKey.skey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\r\nif (strcmp(param->u.crypt.alg, "TKIP") == 0) {\r\nmemcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);\r\nmemcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);\r\npadapter->securitypriv.busetkipkey = false;\r\n}\r\nDBG_88E(" ~~~~set sta key:unicastkey\n");\r\nrtw_setstakey_cmd(padapter, (unsigned char *)psta, true);\r\n} else {\r\nmemcpy(padapter->securitypriv.dot118021XGrpKey[param->u.crypt.idx].skey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\r\nmemcpy(padapter->securitypriv.dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);\r\nmemcpy(padapter->securitypriv.dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);\r\npadapter->securitypriv.binstallGrpkey = true;\r\nDBG_88E(" ~~~~set sta key:groupkey\n");\r\npadapter->securitypriv.dot118021XGrpKeyid = param->u.crypt.idx;\r\nrtw_set_key(padapter, &padapter->securitypriv, param->u.crypt.idx, 1);\r\n}\r\n}\r\npbcmc_sta = rtw_get_bcmc_stainfo(padapter);\r\nif (pbcmc_sta == NULL) {\r\n;\r\n} else {\r\nif (strcmp(param->u.crypt.alg, "none") != 0)\r\npbcmc_sta->ieee8021x_blocked = false;\r\nif ((padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption2Enabled) ||\r\n(padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption3Enabled))\r\npbcmc_sta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;\r\n}\r\n}\r\n}\r\nexit:\r\nkfree(pwep);\r\nreturn ret;\r\n}\r\nstatic int rtw_set_wpa_ie(struct adapter *padapter, char *pie, unsigned short ielen)\r\n{\r\nu8 *buf = NULL;\r\nint group_cipher = 0, pairwise_cipher = 0;\r\nint ret = 0;\r\nif ((ielen > MAX_WPA_IE_LEN) || (pie == NULL)) {\r\n_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);\r\nif (pie == NULL)\r\nreturn ret;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nif (ielen) {\r\nbuf = kmemdup(pie, ielen, GFP_KERNEL);\r\nif (buf == NULL) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\n{\r\nint i;\r\nDBG_88E("\n wpa_ie(length:%d):\n", ielen);\r\nfor (i = 0; i < ielen; i += 8)\r\nDBG_88E("0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x 0x%.2x\n", buf[i], buf[i+1], buf[i+2], buf[i+3], buf[i+4], buf[i+5], buf[i+6], buf[i+7]);\r\n}\r\nif (ielen < RSN_HEADER_LEN) {\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("Ie len too short %d\n", ielen));\r\nret = -1;\r\ngoto exit;\r\n}\r\nif (rtw_parse_wpa_ie(buf, ielen, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS) {\r\npadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\r\npadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPAPSK;\r\nmemcpy(padapter->securitypriv.supplicant_ie, &buf[0], ielen);\r\n}\r\nif (rtw_parse_wpa2_ie(buf, ielen, &group_cipher, &pairwise_cipher, NULL) == _SUCCESS) {\r\npadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\r\npadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPA2PSK;\r\nmemcpy(padapter->securitypriv.supplicant_ie, &buf[0], ielen);\r\n}\r\nswitch (group_cipher) {\r\ncase WPA_CIPHER_NONE:\r\npadapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;\r\nbreak;\r\ncase WPA_CIPHER_WEP40:\r\npadapter->securitypriv.dot118021XGrpPrivacy = _WEP40_;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\nbreak;\r\ncase WPA_CIPHER_TKIP:\r\npadapter->securitypriv.dot118021XGrpPrivacy = _TKIP_;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;\r\nbreak;\r\ncase WPA_CIPHER_CCMP:\r\npadapter->securitypriv.dot118021XGrpPrivacy = _AES_;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;\r\nbreak;\r\ncase WPA_CIPHER_WEP104:\r\npadapter->securitypriv.dot118021XGrpPrivacy = _WEP104_;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\nbreak;\r\n}\r\nswitch (pairwise_cipher) {\r\ncase WPA_CIPHER_NONE:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;\r\nbreak;\r\ncase WPA_CIPHER_WEP40:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\nbreak;\r\ncase WPA_CIPHER_TKIP:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _TKIP_;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;\r\nbreak;\r\ncase WPA_CIPHER_CCMP:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _AES_;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;\r\nbreak;\r\ncase WPA_CIPHER_WEP104:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\nbreak;\r\n}\r\n_clr_fwstate_(&padapter->mlmepriv, WIFI_UNDER_WPS);\r\n{\r\nu16 cnt = 0;\r\nu8 eid, wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};\r\nwhile (cnt < ielen) {\r\neid = buf[cnt];\r\nif ((eid == _VENDOR_SPECIFIC_IE_) && (!memcmp(&buf[cnt+2], wps_oui, 4))) {\r\nDBG_88E("SET WPS_IE\n");\r\npadapter->securitypriv.wps_ie_len = ((buf[cnt+1]+2) < (MAX_WPA_IE_LEN<<2)) ? (buf[cnt+1]+2) : (MAX_WPA_IE_LEN<<2);\r\nmemcpy(padapter->securitypriv.wps_ie, &buf[cnt], padapter->securitypriv.wps_ie_len);\r\nset_fwstate(&padapter->mlmepriv, WIFI_UNDER_WPS);\r\ncnt += buf[cnt+1]+2;\r\nbreak;\r\n} else {\r\ncnt += buf[cnt+1]+2;\r\n}\r\n}\r\n}\r\n}\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,\r\n("rtw_set_wpa_ie: pairwise_cipher = 0x%08x padapter->securitypriv.ndisencryptstatus =%d padapter->securitypriv.ndisauthtype =%d\n",\r\npairwise_cipher, padapter->securitypriv.ndisencryptstatus, padapter->securitypriv.ndisauthtype));\r\nexit:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int rtw_wx_get_name(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nu32 ht_ielen = 0;\r\nchar *p;\r\nu8 ht_cap = false;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;\r\nNDIS_802_11_RATES_EX *prates = NULL;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("cmd_code =%x\n", info->cmd));\r\nif (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE) == true) {\r\np = rtw_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pcur_bss->IELength-12);\r\nif (p && ht_ielen > 0)\r\nht_cap = true;\r\nprates = &pcur_bss->SupportedRates;\r\nif (rtw_is_cckratesonly_included((u8 *)prates) == true) {\r\nif (ht_cap)\r\nsnprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bn");\r\nelse\r\nsnprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11b");\r\n} else if ((rtw_is_cckrates_included((u8 *)prates)) == true) {\r\nif (ht_cap)\r\nsnprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bgn");\r\nelse\r\nsnprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11bg");\r\n} else {\r\nif (pcur_bss->Configuration.DSConfig > 14) {\r\nif (ht_cap)\r\nsnprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11an");\r\nelse\r\nsnprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11a");\r\n} else {\r\nif (ht_cap)\r\nsnprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11gn");\r\nelse\r\nsnprintf(wrqu->name, IFNAMSIZ, "IEEE 802.11g");\r\n}\r\n}\r\n} else {\r\nsnprintf(wrqu->name, IFNAMSIZ, "unassociated");\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtw_wx_set_freq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+rtw_wx_set_freq\n"));\r\nreturn 0;\r\n}\r\nstatic int rtw_wx_get_freq(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED)) {\r\nwrqu->freq.m = rtw_ch2freq(pcur_bss->Configuration.DSConfig) * 100000;\r\nwrqu->freq.e = 1;\r\nwrqu->freq.i = pcur_bss->Configuration.DSConfig;\r\n} else {\r\nwrqu->freq.m = rtw_ch2freq(padapter->mlmeextpriv.cur_channel) * 100000;\r\nwrqu->freq.e = 1;\r\nwrqu->freq.i = padapter->mlmeextpriv.cur_channel;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtw_wx_set_mode(struct net_device *dev, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nenum ndis_802_11_network_infra networkType;\r\nint ret = 0;\r\nif (_FAIL == rtw_pwr_wakeup(padapter)) {\r\nret = -EPERM;\r\ngoto exit;\r\n}\r\nif (!padapter->hw_init_completed) {\r\nret = -EPERM;\r\ngoto exit;\r\n}\r\nswitch (wrqu->mode) {\r\ncase IW_MODE_AUTO:\r\nnetworkType = Ndis802_11AutoUnknown;\r\nDBG_88E("set_mode = IW_MODE_AUTO\n");\r\nbreak;\r\ncase IW_MODE_ADHOC:\r\nnetworkType = Ndis802_11IBSS;\r\nDBG_88E("set_mode = IW_MODE_ADHOC\n");\r\nbreak;\r\ncase IW_MODE_MASTER:\r\nnetworkType = Ndis802_11APMode;\r\nDBG_88E("set_mode = IW_MODE_MASTER\n");\r\nbreak;\r\ncase IW_MODE_INFRA:\r\nnetworkType = Ndis802_11Infrastructure;\r\nDBG_88E("set_mode = IW_MODE_INFRA\n");\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_err_, ("\n Mode: %s is not supported\n", iw_operation_mode[wrqu->mode]));\r\ngoto exit;\r\n}\r\nif (rtw_set_802_11_infrastructure_mode(padapter, networkType) == false) {\r\nret = -EPERM;\r\ngoto exit;\r\n}\r\nrtw_setopmode_cmd(padapter, networkType);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int rtw_wx_get_mode(struct net_device *dev, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, (" rtw_wx_get_mode\n"));\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE))\r\nwrqu->mode = IW_MODE_INFRA;\r\nelse if ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) ||\r\n(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)))\r\nwrqu->mode = IW_MODE_ADHOC;\r\nelse if (check_fwstate(pmlmepriv, WIFI_AP_STATE))\r\nwrqu->mode = IW_MODE_MASTER;\r\nelse\r\nwrqu->mode = IW_MODE_AUTO;\r\nreturn 0;\r\n}\r\nstatic int rtw_wx_set_pmkid(struct net_device *dev,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nu8 j, blInserted = false;\r\nint ret = false;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nstruct iw_pmksa *pPMK = (struct iw_pmksa *)extra;\r\nu8 strZeroMacAddress[ETH_ALEN] = {0x00};\r\nu8 strIssueBssid[ETH_ALEN] = {0x00};\r\nmemcpy(strIssueBssid, pPMK->bssid.sa_data, ETH_ALEN);\r\nif (pPMK->cmd == IW_PMKSA_ADD) {\r\nDBG_88E("[rtw_wx_set_pmkid] IW_PMKSA_ADD!\n");\r\nif (!memcmp(strIssueBssid, strZeroMacAddress, ETH_ALEN))\r\nreturn ret;\r\nelse\r\nret = true;\r\nblInserted = false;\r\nfor (j = 0; j < NUM_PMKID_CACHE; j++) {\r\nif (!memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN)) {\r\nDBG_88E("[rtw_wx_set_pmkid] BSSID exists in the PMKList.\n");\r\nmemcpy(psecuritypriv->PMKIDList[j].PMKID, pPMK->pmkid, IW_PMKID_LEN);\r\npsecuritypriv->PMKIDList[j].bUsed = true;\r\npsecuritypriv->PMKIDIndex = j+1;\r\nblInserted = true;\r\nbreak;\r\n}\r\n}\r\nif (!blInserted) {\r\nDBG_88E("[rtw_wx_set_pmkid] Use the new entry index = %d for this PMKID.\n",\r\npsecuritypriv->PMKIDIndex);\r\nmemcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].Bssid, strIssueBssid, ETH_ALEN);\r\nmemcpy(psecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].PMKID, pPMK->pmkid, IW_PMKID_LEN);\r\npsecuritypriv->PMKIDList[psecuritypriv->PMKIDIndex].bUsed = true;\r\npsecuritypriv->PMKIDIndex++;\r\nif (psecuritypriv->PMKIDIndex == 16)\r\npsecuritypriv->PMKIDIndex = 0;\r\n}\r\n} else if (pPMK->cmd == IW_PMKSA_REMOVE) {\r\nDBG_88E("[rtw_wx_set_pmkid] IW_PMKSA_REMOVE!\n");\r\nret = true;\r\nfor (j = 0; j < NUM_PMKID_CACHE; j++) {\r\nif (!memcmp(psecuritypriv->PMKIDList[j].Bssid, strIssueBssid, ETH_ALEN)) {\r\nmemset(psecuritypriv->PMKIDList[j].Bssid, 0x00, ETH_ALEN);\r\npsecuritypriv->PMKIDList[j].bUsed = false;\r\nbreak;\r\n}\r\n}\r\n} else if (pPMK->cmd == IW_PMKSA_FLUSH) {\r\nDBG_88E("[rtw_wx_set_pmkid] IW_PMKSA_FLUSH!\n");\r\nmemset(&psecuritypriv->PMKIDList[0], 0x00, sizeof(struct rt_pmkid_list) * NUM_PMKID_CACHE);\r\npsecuritypriv->PMKIDIndex = 0;\r\nret = true;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtw_wx_get_sens(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nwrqu->sens.value = 0;\r\nwrqu->sens.fixed = 0;\r\nwrqu->sens.disabled = 1;\r\nreturn 0;\r\n}\r\nstatic int rtw_wx_get_range(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct iw_range *range = (struct iw_range *)extra;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nu16 val;\r\nint i;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_range. cmd_code =%x\n", info->cmd));\r\nwrqu->data.length = sizeof(*range);\r\nmemset(range, 0, sizeof(*range));\r\nrange->throughput = 5 * 1000 * 1000;\r\nrange->max_qual.qual = 100;\r\nrange->max_qual.level = 100;\r\nrange->max_qual.noise = 100;\r\nrange->max_qual.updated = 7;\r\nrange->avg_qual.qual = 92;\r\nrange->avg_qual.level = 178;\r\nrange->avg_qual.noise = 0;\r\nrange->avg_qual.updated = 7;\r\nrange->num_bitrates = RATE_COUNT;\r\nfor (i = 0; i < RATE_COUNT && i < IW_MAX_BITRATES; i++)\r\nrange->bitrate[i] = rtw_rates[i];\r\nrange->min_frag = MIN_FRAG_THRESHOLD;\r\nrange->max_frag = MAX_FRAG_THRESHOLD;\r\nrange->pm_capa = 0;\r\nrange->we_version_compiled = WIRELESS_EXT;\r\nrange->we_version_source = 16;\r\nfor (i = 0, val = 0; i < MAX_CHANNEL_NUM; i++) {\r\nif (pmlmeext->channel_set[i].ChannelNum != 0) {\r\nrange->freq[val].i = pmlmeext->channel_set[i].ChannelNum;\r\nrange->freq[val].m = rtw_ch2freq(pmlmeext->channel_set[i].ChannelNum) * 100000;\r\nrange->freq[val].e = 1;\r\nval++;\r\n}\r\nif (val == IW_MAX_FREQUENCIES)\r\nbreak;\r\n}\r\nrange->num_channels = val;\r\nrange->num_frequency = val;\r\nrange->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |\r\nIW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;\r\nrange->scan_capa = IW_SCAN_CAPA_ESSID | IW_SCAN_CAPA_TYPE |\r\nIW_SCAN_CAPA_BSSID | IW_SCAN_CAPA_CHANNEL |\r\nIW_SCAN_CAPA_MODE | IW_SCAN_CAPA_RATE;\r\nreturn 0;\r\n}\r\nstatic int rtw_wx_set_wap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *awrq,\r\nchar *extra)\r\n{\r\nuint ret = 0;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct sockaddr *temp = (struct sockaddr *)awrq;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct list_head *phead;\r\nu8 *dst_bssid, *src_bssid;\r\nstruct __queue *queue = &(pmlmepriv->scanned_queue);\r\nstruct wlan_network *pnetwork = NULL;\r\nenum ndis_802_11_auth_mode authmode;\r\nif (_FAIL == rtw_pwr_wakeup(padapter)) {\r\nret = -1;\r\ngoto exit;\r\n}\r\nif (!padapter->bup) {\r\nret = -1;\r\ngoto exit;\r\n}\r\nif (temp->sa_family != ARPHRD_ETHER) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nauthmode = padapter->securitypriv.ndisauthtype;\r\nspin_lock_bh(&queue->lock);\r\nphead = get_list_head(queue);\r\npmlmepriv->pscanned = phead->next;\r\nwhile (phead != pmlmepriv->pscanned) {\r\npnetwork = container_of(pmlmepriv->pscanned, struct wlan_network, list);\r\npmlmepriv->pscanned = pmlmepriv->pscanned->next;\r\ndst_bssid = pnetwork->network.MacAddress;\r\nsrc_bssid = temp->sa_data;\r\nif ((!memcmp(dst_bssid, src_bssid, ETH_ALEN))) {\r\nif (!rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode)) {\r\nret = -1;\r\nspin_unlock_bh(&queue->lock);\r\ngoto exit;\r\n}\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&queue->lock);\r\nrtw_set_802_11_authentication_mode(padapter, authmode);\r\nif (rtw_set_802_11_bssid(padapter, temp->sa_data) == false) {\r\nret = -1;\r\ngoto exit;\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int rtw_wx_get_wap(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;\r\nwrqu->ap_addr.sa_family = ARPHRD_ETHER;\r\nmemset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_wap\n"));\r\nif (((check_fwstate(pmlmepriv, _FW_LINKED)) == true) ||\r\n((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == true) ||\r\n((check_fwstate(pmlmepriv, WIFI_AP_STATE)) == true))\r\nmemcpy(wrqu->ap_addr.sa_data, pcur_bss->MacAddress, ETH_ALEN);\r\nelse\r\nmemset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic int rtw_wx_set_mlme(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint ret = 0;\r\nu16 reason;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct iw_mlme *mlme = (struct iw_mlme *)extra;\r\nif (mlme == NULL)\r\nreturn -1;\r\nDBG_88E("%s\n", __func__);\r\nreason = mlme->reason_code;\r\nDBG_88E("%s, cmd =%d, reason =%d\n", __func__, mlme->cmd, reason);\r\nswitch (mlme->cmd) {\r\ncase IW_MLME_DEAUTH:\r\nif (!rtw_set_802_11_disassociate(padapter))\r\nret = -1;\r\nbreak;\r\ncase IW_MLME_DISASSOC:\r\nif (!rtw_set_802_11_disassociate(padapter))\r\nret = -1;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtw_wx_set_scan(struct net_device *dev, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nu8 _status = false;\r\nint ret = 0;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct ndis_802_11_ssid ssid[RTW_SSID_SCAN_AMOUNT];\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_set_scan\n"));\r\nif (padapter->registrypriv.mp_mode == 1) {\r\nif (check_fwstate(pmlmepriv, WIFI_MP_STATE)) {\r\nret = -1;\r\ngoto exit;\r\n}\r\n}\r\nif (_FAIL == rtw_pwr_wakeup(padapter)) {\r\nret = -1;\r\ngoto exit;\r\n}\r\nif (padapter->bDriverStopped) {\r\nDBG_88E("bDriverStopped =%d\n", padapter->bDriverStopped);\r\nret = -1;\r\ngoto exit;\r\n}\r\nif (!padapter->bup) {\r\nret = -1;\r\ngoto exit;\r\n}\r\nif (!padapter->hw_init_completed) {\r\nret = -1;\r\ngoto exit;\r\n}\r\nif (pmlmepriv->LinkDetectInfo.bBusyTraffic) {\r\nindicate_wx_scan_complete_event(padapter);\r\ngoto exit;\r\n}\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)) {\r\nindicate_wx_scan_complete_event(padapter);\r\ngoto exit;\r\n}\r\nmemset(ssid, 0, sizeof(struct ndis_802_11_ssid)*RTW_SSID_SCAN_AMOUNT);\r\nif (wrqu->data.length == sizeof(struct iw_scan_req)) {\r\nstruct iw_scan_req *req = (struct iw_scan_req *)extra;\r\nif (wrqu->data.flags & IW_SCAN_THIS_ESSID) {\r\nint len = min_t(int, req->essid_len,\r\nIW_ESSID_MAX_SIZE);\r\nmemcpy(ssid[0].Ssid, req->essid, len);\r\nssid[0].SsidLength = len;\r\nDBG_88E("IW_SCAN_THIS_ESSID, ssid =%s, len =%d\n", req->essid, req->essid_len);\r\nspin_lock_bh(&pmlmepriv->lock);\r\n_status = rtw_sitesurvey_cmd(padapter, ssid, 1, NULL, 0);\r\nspin_unlock_bh(&pmlmepriv->lock);\r\n} else if (req->scan_type == IW_SCAN_TYPE_PASSIVE) {\r\nDBG_88E("rtw_wx_set_scan, req->scan_type == IW_SCAN_TYPE_PASSIVE\n");\r\n}\r\n} else {\r\nif (wrqu->data.length >= WEXT_CSCAN_HEADER_SIZE &&\r\n!memcmp(extra, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE)) {\r\nint len = wrqu->data.length - WEXT_CSCAN_HEADER_SIZE;\r\nchar *pos = extra+WEXT_CSCAN_HEADER_SIZE;\r\nchar section;\r\nchar sec_len;\r\nint ssid_index = 0;\r\nwhile (len >= 1) {\r\nsection = *(pos++);\r\nlen -= 1;\r\nswitch (section) {\r\ncase WEXT_CSCAN_SSID_SECTION:\r\nif (len < 1) {\r\nlen = 0;\r\nbreak;\r\n}\r\nsec_len = *(pos++); len -= 1;\r\nif (sec_len > 0 && sec_len <= len) {\r\nssid[ssid_index].SsidLength = sec_len;\r\nmemcpy(ssid[ssid_index].Ssid, pos, ssid[ssid_index].SsidLength);\r\nssid_index++;\r\n}\r\npos += sec_len;\r\nlen -= sec_len;\r\nbreak;\r\ncase WEXT_CSCAN_TYPE_SECTION:\r\ncase WEXT_CSCAN_CHANNEL_SECTION:\r\npos += 1;\r\nlen -= 1;\r\nbreak;\r\ncase WEXT_CSCAN_PASV_DWELL_SECTION:\r\ncase WEXT_CSCAN_HOME_DWELL_SECTION:\r\ncase WEXT_CSCAN_ACTV_DWELL_SECTION:\r\npos += 2;\r\nlen -= 2;\r\nbreak;\r\ndefault:\r\nlen = 0;\r\n}\r\n}\r\n_status = rtw_set_802_11_bssid_list_scan(padapter, ssid, RTW_SSID_SCAN_AMOUNT);\r\n} else {\r\n_status = rtw_set_802_11_bssid_list_scan(padapter, NULL, 0);\r\n}\r\n}\r\nif (!_status)\r\nret = -1;\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int rtw_wx_get_scan(struct net_device *dev, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct list_head *plist, *phead;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct __queue *queue = &(pmlmepriv->scanned_queue);\r\nstruct wlan_network *pnetwork = NULL;\r\nchar *ev = extra;\r\nchar *stop = ev + wrqu->data.length;\r\nu32 ret = 0;\r\nu32 cnt = 0;\r\nu32 wait_for_surveydone;\r\nint wait_status;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_scan\n"));\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, (" Start of Query SIOCGIWSCAN .\n"));\r\nif (padapter->pwrctrlpriv.brfoffbyhw && padapter->bDriverStopped) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nwait_for_surveydone = 100;\r\nwait_status = _FW_UNDER_SURVEY | _FW_UNDER_LINKING;\r\nwhile (check_fwstate(pmlmepriv, wait_status)) {\r\nmsleep(30);\r\ncnt++;\r\nif (cnt > wait_for_surveydone)\r\nbreak;\r\n}\r\nspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\r\nphead = get_list_head(queue);\r\nplist = phead->next;\r\nwhile (phead != plist) {\r\nif ((stop - ev) < SCAN_ITEM_SIZE) {\r\nret = -E2BIG;\r\nbreak;\r\n}\r\npnetwork = container_of(plist, struct wlan_network, list);\r\nif (rtw_ch_set_search_ch(padapter->mlmeextpriv.channel_set, pnetwork->network.Configuration.DSConfig) >= 0)\r\nev = translate_scan(padapter, a, pnetwork, ev, stop);\r\nplist = plist->next;\r\n}\r\nspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\r\nwrqu->data.length = ev-extra;\r\nwrqu->data.flags = 0;\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int rtw_wx_set_essid(struct net_device *dev,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct __queue *queue = &pmlmepriv->scanned_queue;\r\nstruct list_head *phead;\r\nstruct wlan_network *pnetwork = NULL;\r\nenum ndis_802_11_auth_mode authmode;\r\nstruct ndis_802_11_ssid ndis_ssid;\r\nu8 *dst_ssid, *src_ssid;\r\nuint ret = 0, len;\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,\r\n("+rtw_wx_set_essid: fw_state = 0x%08x\n", get_fwstate(pmlmepriv)));\r\nif (_FAIL == rtw_pwr_wakeup(padapter)) {\r\nret = -1;\r\ngoto exit;\r\n}\r\nif (!padapter->bup) {\r\nret = -1;\r\ngoto exit;\r\n}\r\nif (wrqu->essid.length > IW_ESSID_MAX_SIZE) {\r\nret = -E2BIG;\r\ngoto exit;\r\n}\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nret = -1;\r\ngoto exit;\r\n}\r\nauthmode = padapter->securitypriv.ndisauthtype;\r\nDBG_88E("=>%s\n", __func__);\r\nif (wrqu->essid.flags && wrqu->essid.length) {\r\nlen = (wrqu->essid.length < IW_ESSID_MAX_SIZE) ? wrqu->essid.length : IW_ESSID_MAX_SIZE;\r\nif (wrqu->essid.length != 33)\r\nDBG_88E("ssid =%s, len =%d\n", extra, wrqu->essid.length);\r\nmemset(&ndis_ssid, 0, sizeof(struct ndis_802_11_ssid));\r\nndis_ssid.SsidLength = len;\r\nmemcpy(ndis_ssid.Ssid, extra, len);\r\nsrc_ssid = ndis_ssid.Ssid;\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("rtw_wx_set_essid: ssid =[%s]\n", src_ssid));\r\nspin_lock_bh(&queue->lock);\r\nphead = get_list_head(queue);\r\npmlmepriv->pscanned = phead->next;\r\nwhile (phead != pmlmepriv->pscanned) {\r\npnetwork = container_of(pmlmepriv->pscanned, struct wlan_network, list);\r\npmlmepriv->pscanned = pmlmepriv->pscanned->next;\r\ndst_ssid = pnetwork->network.Ssid.Ssid;\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,\r\n("rtw_wx_set_essid: dst_ssid =%s\n",\r\npnetwork->network.Ssid.Ssid));\r\nif ((!memcmp(dst_ssid, src_ssid, ndis_ssid.SsidLength)) &&\r\n(pnetwork->network.Ssid.SsidLength == ndis_ssid.SsidLength)) {\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,\r\n("rtw_wx_set_essid: find match, set infra mode\n"));\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) {\r\nif (pnetwork->network.InfrastructureMode != pmlmepriv->cur_network.network.InfrastructureMode)\r\ncontinue;\r\n}\r\nif (!rtw_set_802_11_infrastructure_mode(padapter, pnetwork->network.InfrastructureMode)) {\r\nret = -1;\r\nspin_unlock_bh(&queue->lock);\r\ngoto exit;\r\n}\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&queue->lock);\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,\r\n("set ssid: set_802_11_auth. mode =%d\n", authmode));\r\nrtw_set_802_11_authentication_mode(padapter, authmode);\r\nif (rtw_set_802_11_ssid(padapter, &ndis_ssid) == false) {\r\nret = -1;\r\ngoto exit;\r\n}\r\n}\r\nexit:\r\nDBG_88E("<=%s, ret %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int rtw_wx_get_essid(struct net_device *dev,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nu32 len, ret = 0;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_wx_get_essid\n"));\r\nif ((check_fwstate(pmlmepriv, _FW_LINKED)) ||\r\n(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE))) {\r\nlen = pcur_bss->Ssid.SsidLength;\r\nwrqu->essid.length = len;\r\nmemcpy(extra, pcur_bss->Ssid.Ssid, len);\r\nwrqu->essid.flags = 1;\r\n} else {\r\nret = -1;\r\ngoto exit;\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int rtw_wx_set_rate(struct net_device *dev,\r\nstruct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint i;\r\nu8 datarates[NumRates];\r\nu32 target_rate = wrqu->bitrate.value;\r\nu32 fixed = wrqu->bitrate.fixed;\r\nu32 ratevalue = 0;\r\nu8 mpdatarate[NumRates] = {11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0xff};\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, (" rtw_wx_set_rate\n"));\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("target_rate = %d, fixed = %d\n", target_rate, fixed));\r\nif (target_rate == -1) {\r\nratevalue = 11;\r\ngoto set_rate;\r\n}\r\ntarget_rate = target_rate/100000;\r\nswitch (target_rate) {\r\ncase 10:\r\nratevalue = 0;\r\nbreak;\r\ncase 20:\r\nratevalue = 1;\r\nbreak;\r\ncase 55:\r\nratevalue = 2;\r\nbreak;\r\ncase 60:\r\nratevalue = 3;\r\nbreak;\r\ncase 90:\r\nratevalue = 4;\r\nbreak;\r\ncase 110:\r\nratevalue = 5;\r\nbreak;\r\ncase 120:\r\nratevalue = 6;\r\nbreak;\r\ncase 180:\r\nratevalue = 7;\r\nbreak;\r\ncase 240:\r\nratevalue = 8;\r\nbreak;\r\ncase 360:\r\nratevalue = 9;\r\nbreak;\r\ncase 480:\r\nratevalue = 10;\r\nbreak;\r\ncase 540:\r\nratevalue = 11;\r\nbreak;\r\ndefault:\r\nratevalue = 11;\r\nbreak;\r\n}\r\nset_rate:\r\nfor (i = 0; i < NumRates; i++) {\r\nif (ratevalue == mpdatarate[i]) {\r\ndatarates[i] = mpdatarate[i];\r\nif (fixed == 0)\r\nbreak;\r\n} else {\r\ndatarates[i] = 0xff;\r\n}\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_, ("datarate_inx =%d\n", datarates[i]));\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtw_wx_get_rate(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nu16 max_rate = 0;\r\nmax_rate = rtw_get_cur_max_rate((struct adapter *)rtw_netdev_priv(dev));\r\nif (max_rate == 0)\r\nreturn -EPERM;\r\nwrqu->bitrate.fixed = 0;\r\nwrqu->bitrate.value = max_rate * 100000;\r\nreturn 0;\r\n}\r\nstatic int rtw_wx_set_rts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nif (wrqu->rts.disabled) {\r\npadapter->registrypriv.rts_thresh = 2347;\r\n} else {\r\nif (wrqu->rts.value < 0 ||\r\nwrqu->rts.value > 2347)\r\nreturn -EINVAL;\r\npadapter->registrypriv.rts_thresh = wrqu->rts.value;\r\n}\r\nDBG_88E("%s, rts_thresh =%d\n", __func__, padapter->registrypriv.rts_thresh);\r\nreturn 0;\r\n}\r\nstatic int rtw_wx_get_rts(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nDBG_88E("%s, rts_thresh =%d\n", __func__, padapter->registrypriv.rts_thresh);\r\nwrqu->rts.value = padapter->registrypriv.rts_thresh;\r\nwrqu->rts.fixed = 0;\r\nreturn 0;\r\n}\r\nstatic int rtw_wx_set_frag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nif (wrqu->frag.disabled) {\r\npadapter->xmitpriv.frag_len = MAX_FRAG_THRESHOLD;\r\n} else {\r\nif (wrqu->frag.value < MIN_FRAG_THRESHOLD ||\r\nwrqu->frag.value > MAX_FRAG_THRESHOLD)\r\nreturn -EINVAL;\r\npadapter->xmitpriv.frag_len = wrqu->frag.value & ~0x1;\r\n}\r\nDBG_88E("%s, frag_len =%d\n", __func__, padapter->xmitpriv.frag_len);\r\nreturn 0;\r\n}\r\nstatic int rtw_wx_get_frag(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nDBG_88E("%s, frag_len =%d\n", __func__, padapter->xmitpriv.frag_len);\r\nwrqu->frag.value = padapter->xmitpriv.frag_len;\r\nwrqu->frag.fixed = 0;\r\nreturn 0;\r\n}\r\nstatic int rtw_wx_get_retry(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nwrqu->retry.value = 7;\r\nwrqu->retry.fixed = 0;\r\nwrqu->retry.disabled = 1;\r\nreturn 0;\r\n}\r\nstatic int rtw_wx_set_enc(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *keybuf)\r\n{\r\nu32 key, ret = 0;\r\nu32 keyindex_provided;\r\nstruct ndis_802_11_wep wep;\r\nenum ndis_802_11_auth_mode authmode;\r\nstruct iw_point *erq = &(wrqu->encoding);\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\nDBG_88E("+rtw_wx_set_enc, flags = 0x%x\n", erq->flags);\r\nmemset(&wep, 0, sizeof(struct ndis_802_11_wep));\r\nkey = erq->flags & IW_ENCODE_INDEX;\r\nif (erq->flags & IW_ENCODE_DISABLED) {\r\nDBG_88E("EncryptionDisabled\n");\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;\r\npadapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;\r\npadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;\r\nauthmode = Ndis802_11AuthModeOpen;\r\npadapter->securitypriv.ndisauthtype = authmode;\r\ngoto exit;\r\n}\r\nif (key) {\r\nif (key > WEP_KEYS)\r\nreturn -EINVAL;\r\nkey--;\r\nkeyindex_provided = 1;\r\n} else {\r\nkeyindex_provided = 0;\r\nkey = padapter->securitypriv.dot11PrivacyKeyIndex;\r\nDBG_88E("rtw_wx_set_enc, key =%d\n", key);\r\n}\r\nif (erq->flags & IW_ENCODE_OPEN) {\r\nDBG_88E("rtw_wx_set_enc():IW_ENCODE_OPEN\n");\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\npadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;\r\npadapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;\r\nauthmode = Ndis802_11AuthModeOpen;\r\npadapter->securitypriv.ndisauthtype = authmode;\r\n} else if (erq->flags & IW_ENCODE_RESTRICTED) {\r\nDBG_88E("rtw_wx_set_enc():IW_ENCODE_RESTRICTED\n");\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\npadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Shared;\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;\r\npadapter->securitypriv.dot118021XGrpPrivacy = _WEP40_;\r\nauthmode = Ndis802_11AuthModeShared;\r\npadapter->securitypriv.ndisauthtype = authmode;\r\n} else {\r\nDBG_88E("rtw_wx_set_enc():erq->flags = 0x%x\n", erq->flags);\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\npadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;\r\npadapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;\r\nauthmode = Ndis802_11AuthModeOpen;\r\npadapter->securitypriv.ndisauthtype = authmode;\r\n}\r\nwep.KeyIndex = key;\r\nif (erq->length > 0) {\r\nwep.KeyLength = erq->length <= 5 ? 5 : 13;\r\nwep.Length = wep.KeyLength + FIELD_OFFSET(struct ndis_802_11_wep, KeyMaterial);\r\n} else {\r\nwep.KeyLength = 0;\r\nif (keyindex_provided == 1) {\r\npadapter->securitypriv.dot11PrivacyKeyIndex = key;\r\nDBG_88E("(keyindex_provided == 1), keyid =%d, key_len =%d\n", key, padapter->securitypriv.dot11DefKeylen[key]);\r\nswitch (padapter->securitypriv.dot11DefKeylen[key]) {\r\ncase 5:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;\r\nbreak;\r\ncase 13:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;\r\nbreak;\r\ndefault:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;\r\nbreak;\r\n}\r\ngoto exit;\r\n}\r\n}\r\nwep.KeyIndex |= 0x80000000;\r\nmemcpy(wep.KeyMaterial, keybuf, wep.KeyLength);\r\nif (rtw_set_802_11_add_wep(padapter, &wep) == false) {\r\nif (rf_on == pwrpriv->rf_pwrstate)\r\nret = -EOPNOTSUPP;\r\ngoto exit;\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int rtw_wx_get_enc(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *keybuf)\r\n{\r\nuint key, ret = 0;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct iw_point *erq = &(wrqu->encoding);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) != true) {\r\nif (!check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) {\r\nerq->length = 0;\r\nerq->flags |= IW_ENCODE_DISABLED;\r\nreturn 0;\r\n}\r\n}\r\nkey = erq->flags & IW_ENCODE_INDEX;\r\nif (key) {\r\nif (key > WEP_KEYS)\r\nreturn -EINVAL;\r\nkey--;\r\n} else {\r\nkey = padapter->securitypriv.dot11PrivacyKeyIndex;\r\n}\r\nerq->flags = key + 1;\r\nswitch (padapter->securitypriv.ndisencryptstatus) {\r\ncase Ndis802_11EncryptionNotSupported:\r\ncase Ndis802_11EncryptionDisabled:\r\nerq->length = 0;\r\nerq->flags |= IW_ENCODE_DISABLED;\r\nbreak;\r\ncase Ndis802_11Encryption1Enabled:\r\nerq->length = padapter->securitypriv.dot11DefKeylen[key];\r\nif (erq->length) {\r\nmemcpy(keybuf, padapter->securitypriv.dot11DefKey[key].skey, padapter->securitypriv.dot11DefKeylen[key]);\r\nerq->flags |= IW_ENCODE_ENABLED;\r\nif (padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeOpen)\r\nerq->flags |= IW_ENCODE_OPEN;\r\nelse if (padapter->securitypriv.ndisauthtype == Ndis802_11AuthModeShared)\r\nerq->flags |= IW_ENCODE_RESTRICTED;\r\n} else {\r\nerq->length = 0;\r\nerq->flags |= IW_ENCODE_DISABLED;\r\n}\r\nbreak;\r\ncase Ndis802_11Encryption2Enabled:\r\ncase Ndis802_11Encryption3Enabled:\r\nerq->length = 16;\r\nerq->flags |= (IW_ENCODE_ENABLED | IW_ENCODE_OPEN | IW_ENCODE_NOKEY);\r\nbreak;\r\ndefault:\r\nerq->length = 0;\r\nerq->flags |= IW_ENCODE_DISABLED;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtw_wx_get_power(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nwrqu->power.value = 0;\r\nwrqu->power.fixed = 0;\r\nwrqu->power.disabled = 1;\r\nreturn 0;\r\n}\r\nstatic int rtw_wx_set_gen_ie(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint ret;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nret = rtw_set_wpa_ie(padapter, extra, wrqu->data.length);\r\nreturn ret;\r\n}\r\nstatic int rtw_wx_set_auth(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct iw_param *param = (struct iw_param *)&(wrqu->param);\r\nint ret = 0;\r\nswitch (param->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_WPA_VERSION:\r\nbreak;\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\nbreak;\r\ncase IW_AUTH_CIPHER_GROUP:\r\nbreak;\r\ncase IW_AUTH_KEY_MGMT:\r\nbreak;\r\ncase IW_AUTH_TKIP_COUNTERMEASURES:\r\nif (param->value) {\r\npadapter->securitypriv.btkip_countermeasure = true;\r\n} else {\r\npadapter->securitypriv.btkip_countermeasure = false;\r\n}\r\nbreak;\r\ncase IW_AUTH_DROP_UNENCRYPTED:\r\nif (padapter->securitypriv.ndisencryptstatus == Ndis802_11Encryption1Enabled)\r\nbreak;\r\nif (param->value) {\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11EncryptionDisabled;\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;\r\npadapter->securitypriv.dot118021XGrpPrivacy = _NO_PRIVACY_;\r\npadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_Open;\r\npadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeOpen;\r\n}\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nif (check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {\r\nLeaveAllPowerSaveMode(padapter);\r\nrtw_disassoc_cmd(padapter, 500, false);\r\nDBG_88E("%s...call rtw_indicate_disconnect\n ", __func__);\r\nrtw_indicate_disconnect(padapter);\r\nrtw_free_assoc_resources(padapter, 1);\r\n}\r\nret = wpa_set_auth_algs(dev, (u32)param->value);\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nbreak;\r\ncase IW_AUTH_RX_UNENCRYPTED_EAPOL:\r\nbreak;\r\ncase IW_AUTH_PRIVACY_INVOKED:\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtw_wx_set_enc_ext(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nchar *alg_name;\r\nu32 param_len;\r\nstruct ieee_param *param = NULL;\r\nstruct iw_point *pencoding = &wrqu->encoding;\r\nstruct iw_encode_ext *pext = (struct iw_encode_ext *)extra;\r\nint ret = 0;\r\nparam_len = sizeof(struct ieee_param) + pext->key_len;\r\nparam = (struct ieee_param *)rtw_malloc(param_len);\r\nif (param == NULL)\r\nreturn -1;\r\nmemset(param, 0, param_len);\r\nparam->cmd = IEEE_CMD_SET_ENCRYPTION;\r\nmemset(param->sta_addr, 0xff, ETH_ALEN);\r\nswitch (pext->alg) {\r\ncase IW_ENCODE_ALG_NONE:\r\nalg_name = "none";\r\nbreak;\r\ncase IW_ENCODE_ALG_WEP:\r\nalg_name = "WEP";\r\nbreak;\r\ncase IW_ENCODE_ALG_TKIP:\r\nalg_name = "TKIP";\r\nbreak;\r\ncase IW_ENCODE_ALG_CCMP:\r\nalg_name = "CCMP";\r\nbreak;\r\ndefault:\r\nret = -1;\r\ngoto exit;\r\n}\r\nstrncpy((char *)param->u.crypt.alg, alg_name, IEEE_CRYPT_ALG_NAME_LEN);\r\nif (pext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY)\r\nparam->u.crypt.set_tx = 1;\r\nif ((pext->alg != IW_ENCODE_ALG_WEP) &&\r\n(pext->ext_flags & IW_ENCODE_EXT_GROUP_KEY))\r\nparam->u.crypt.set_tx = 0;\r\nparam->u.crypt.idx = (pencoding->flags&0x00FF) - 1;\r\nif (pext->ext_flags & IW_ENCODE_EXT_RX_SEQ_VALID)\r\nmemcpy(param->u.crypt.seq, pext->rx_seq, 8);\r\nif (pext->key_len) {\r\nparam->u.crypt.key_len = pext->key_len;\r\nmemcpy(param->u.crypt.key, pext + 1, pext->key_len);\r\n}\r\nret = wpa_set_encryption(dev, param, param_len);\r\nexit:\r\nkfree(param);\r\nreturn ret;\r\n}\r\nstatic int rtw_wx_get_nick(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nif (extra) {\r\nwrqu->data.length = 14;\r\nwrqu->data.flags = 1;\r\nmemcpy(extra, "<WIFI@REALTEK>", 14);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dummy(struct net_device *dev, struct iw_request_info *a,\r\nunion iwreq_data *wrqu, char *b)\r\n{\r\nreturn -1;\r\n}\r\nstatic int wpa_set_param(struct net_device *dev, u8 name, u32 value)\r\n{\r\nuint ret = 0;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nswitch (name) {\r\ncase IEEE_PARAM_WPA_ENABLED:\r\npadapter->securitypriv.dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\r\nswitch ((value)&0xff) {\r\ncase 1:\r\npadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPAPSK;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption2Enabled;\r\nbreak;\r\ncase 2:\r\npadapter->securitypriv.ndisauthtype = Ndis802_11AuthModeWPA2PSK;\r\npadapter->securitypriv.ndisencryptstatus = Ndis802_11Encryption3Enabled;\r\nbreak;\r\n}\r\nRT_TRACE(_module_rtl871x_ioctl_os_c, _drv_info_,\r\n("wpa_set_param:padapter->securitypriv.ndisauthtype =%d\n", padapter->securitypriv.ndisauthtype));\r\nbreak;\r\ncase IEEE_PARAM_TKIP_COUNTERMEASURES:\r\nbreak;\r\ncase IEEE_PARAM_DROP_UNENCRYPTED: {\r\nbreak;\r\n}\r\ncase IEEE_PARAM_PRIVACY_INVOKED:\r\nbreak;\r\ncase IEEE_PARAM_AUTH_ALGS:\r\nret = wpa_set_auth_algs(dev, value);\r\nbreak;\r\ncase IEEE_PARAM_IEEE_802_1X:\r\nbreak;\r\ncase IEEE_PARAM_WPAX_SELECT:\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int wpa_mlme(struct net_device *dev, u32 command, u32 reason)\r\n{\r\nint ret = 0;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nswitch (command) {\r\ncase IEEE_MLME_STA_DEAUTH:\r\nif (!rtw_set_802_11_disassociate(padapter))\r\nret = -1;\r\nbreak;\r\ncase IEEE_MLME_STA_DISASSOC:\r\nif (!rtw_set_802_11_disassociate(padapter))\r\nret = -1;\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int wpa_supplicant_ioctl(struct net_device *dev, struct iw_point *p)\r\n{\r\nstruct ieee_param *param;\r\nuint ret = 0;\r\nif (p->length < sizeof(struct ieee_param) || !p->pointer) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nparam = (struct ieee_param *)rtw_malloc(p->length);\r\nif (param == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (copy_from_user(param, p->pointer, p->length)) {\r\nkfree(param);\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nswitch (param->cmd) {\r\ncase IEEE_CMD_SET_WPA_PARAM:\r\nret = wpa_set_param(dev, param->u.wpa_param.name, param->u.wpa_param.value);\r\nbreak;\r\ncase IEEE_CMD_SET_WPA_IE:\r\nret = rtw_set_wpa_ie((struct adapter *)rtw_netdev_priv(dev),\r\n(char *)param->u.wpa_ie.data, (u16)param->u.wpa_ie.len);\r\nbreak;\r\ncase IEEE_CMD_SET_ENCRYPTION:\r\nret = wpa_set_encryption(dev, param, p->length);\r\nbreak;\r\ncase IEEE_CMD_MLME:\r\nret = wpa_mlme(dev, param->u.mlme.command, param->u.mlme.reason_code);\r\nbreak;\r\ndefault:\r\nDBG_88E("Unknown WPA supplicant request: %d\n", param->cmd);\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (ret == 0 && copy_to_user(p->pointer, param, p->length))\r\nret = -EFAULT;\r\nkfree(param);\r\nout:\r\nreturn ret;\r\n}\r\nstatic u8 set_pairwise_key(struct adapter *padapter, struct sta_info *psta)\r\n{\r\nstruct cmd_obj *ph2c;\r\nstruct set_stakey_parm *psetstakey_para;\r\nstruct cmd_priv *pcmdpriv = &padapter->cmdpriv;\r\nu8 res = _SUCCESS;\r\nph2c = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);\r\nif (ph2c == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npsetstakey_para = kzalloc(sizeof(struct set_stakey_parm), GFP_KERNEL);\r\nif (psetstakey_para == NULL) {\r\nkfree(ph2c);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\ninit_h2fwcmd_w_parm_no_rsp(ph2c, psetstakey_para, _SetStaKey_CMD_);\r\npsetstakey_para->algorithm = (u8)psta->dot118021XPrivacy;\r\nmemcpy(psetstakey_para->addr, psta->hwaddr, ETH_ALEN);\r\nmemcpy(psetstakey_para->key, &psta->dot118021x_UncstKey, 16);\r\nres = rtw_enqueue_cmd(pcmdpriv, ph2c);\r\nexit:\r\nreturn res;\r\n}\r\nstatic int set_group_key(struct adapter *padapter, u8 *key, u8 alg, int keyid)\r\n{\r\nu8 keylen;\r\nstruct cmd_obj *pcmd;\r\nstruct setkey_parm *psetkeyparm;\r\nstruct cmd_priv *pcmdpriv = &(padapter->cmdpriv);\r\nint res = _SUCCESS;\r\nDBG_88E("%s\n", __func__);\r\npcmd = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);\r\nif (pcmd == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npsetkeyparm = kzalloc(sizeof(struct setkey_parm), GFP_KERNEL);\r\nif (psetkeyparm == NULL) {\r\nkfree(pcmd);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nmemset(psetkeyparm, 0, sizeof(struct setkey_parm));\r\npsetkeyparm->keyid = (u8)keyid;\r\npsetkeyparm->algorithm = alg;\r\npsetkeyparm->set_tx = 1;\r\nswitch (alg) {\r\ncase _WEP40_:\r\nkeylen = 5;\r\nbreak;\r\ncase _WEP104_:\r\nkeylen = 13;\r\nbreak;\r\ncase _TKIP_:\r\ncase _TKIP_WTMIC_:\r\ncase _AES_:\r\ndefault:\r\nkeylen = 16;\r\n}\r\nmemcpy(&(psetkeyparm->key[0]), key, keylen);\r\npcmd->cmdcode = _SetKey_CMD_;\r\npcmd->parmbuf = (u8 *)psetkeyparm;\r\npcmd->cmdsz = (sizeof(struct setkey_parm));\r\npcmd->rsp = NULL;\r\npcmd->rspsz = 0;\r\nINIT_LIST_HEAD(&pcmd->list);\r\nres = rtw_enqueue_cmd(pcmdpriv, pcmd);\r\nexit:\r\nreturn res;\r\n}\r\nstatic int set_wep_key(struct adapter *padapter, u8 *key, u8 keylen, int keyid)\r\n{\r\nu8 alg;\r\nswitch (keylen) {\r\ncase 5:\r\nalg = _WEP40_;\r\nbreak;\r\ncase 13:\r\nalg = _WEP104_;\r\nbreak;\r\ndefault:\r\nalg = _NO_PRIVACY_;\r\n}\r\nreturn set_group_key(padapter, key, alg, keyid);\r\n}\r\nstatic int rtw_set_encryption(struct net_device *dev, struct ieee_param *param, u32 param_len)\r\n{\r\nint ret = 0;\r\nu32 wep_key_idx, wep_key_len, wep_total_len;\r\nstruct ndis_802_11_wep *pwep = NULL;\r\nstruct sta_info *psta = NULL, *pbcmc_sta = NULL;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct security_priv *psecuritypriv = &(padapter->securitypriv);\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nDBG_88E("%s\n", __func__);\r\nparam->u.crypt.err = 0;\r\nparam->u.crypt.alg[IEEE_CRYPT_ALG_NAME_LEN - 1] = '\0';\r\nif (param_len != sizeof(struct ieee_param) + param->u.crypt.key_len) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\r\nparam->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\r\nparam->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff) {\r\nif (param->u.crypt.idx >= WEP_KEYS) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\n} else {\r\npsta = rtw_get_stainfo(pstapriv, param->sta_addr);\r\nif (!psta) {\r\nDBG_88E("rtw_set_encryption(), sta has already been removed or never been added\n");\r\ngoto exit;\r\n}\r\n}\r\nif (strcmp(param->u.crypt.alg, "none") == 0 && (psta == NULL)) {\r\nDBG_88E("clear default encryption keys, keyid =%d\n", param->u.crypt.idx);\r\ngoto exit;\r\n}\r\nif (strcmp(param->u.crypt.alg, "WEP") == 0 && (psta == NULL)) {\r\nDBG_88E("r871x_set_encryption, crypt.alg = WEP\n");\r\nwep_key_idx = param->u.crypt.idx;\r\nwep_key_len = param->u.crypt.key_len;\r\nDBG_88E("r871x_set_encryption, wep_key_idx=%d, len=%d\n", wep_key_idx, wep_key_len);\r\nif ((wep_key_idx >= WEP_KEYS) || (wep_key_len <= 0)) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nif (wep_key_len > 0) {\r\nwep_key_len = wep_key_len <= 5 ? 5 : 13;\r\nwep_total_len = wep_key_len + FIELD_OFFSET(struct ndis_802_11_wep, KeyMaterial);\r\npwep = (struct ndis_802_11_wep *)rtw_malloc(wep_total_len);\r\nif (pwep == NULL) {\r\nDBG_88E(" r871x_set_encryption: pwep allocate fail !!!\n");\r\ngoto exit;\r\n}\r\nmemset(pwep, 0, wep_total_len);\r\npwep->KeyLength = wep_key_len;\r\npwep->Length = wep_total_len;\r\n}\r\npwep->KeyIndex = wep_key_idx;\r\nmemcpy(pwep->KeyMaterial, param->u.crypt.key, pwep->KeyLength);\r\nif (param->u.crypt.set_tx) {\r\nDBG_88E("wep, set_tx = 1\n");\r\npsecuritypriv->ndisencryptstatus = Ndis802_11Encryption1Enabled;\r\npsecuritypriv->dot11PrivacyAlgrthm = _WEP40_;\r\npsecuritypriv->dot118021XGrpPrivacy = _WEP40_;\r\nif (pwep->KeyLength == 13) {\r\npsecuritypriv->dot11PrivacyAlgrthm = _WEP104_;\r\npsecuritypriv->dot118021XGrpPrivacy = _WEP104_;\r\n}\r\npsecuritypriv->dot11PrivacyKeyIndex = wep_key_idx;\r\nmemcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);\r\npsecuritypriv->dot11DefKeylen[wep_key_idx] = pwep->KeyLength;\r\nset_wep_key(padapter, pwep->KeyMaterial, pwep->KeyLength, wep_key_idx);\r\n} else {\r\nDBG_88E("wep, set_tx = 0\n");\r\nmemcpy(&(psecuritypriv->dot11DefKey[wep_key_idx].skey[0]), pwep->KeyMaterial, pwep->KeyLength);\r\npsecuritypriv->dot11DefKeylen[wep_key_idx] = pwep->KeyLength;\r\nset_wep_key(padapter, pwep->KeyMaterial, pwep->KeyLength, wep_key_idx);\r\n}\r\ngoto exit;\r\n}\r\nif (!psta && check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nif (param->u.crypt.set_tx == 1) {\r\nif (strcmp(param->u.crypt.alg, "WEP") == 0) {\r\nDBG_88E("%s, set group_key, WEP\n", __func__);\r\nmemcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,\r\nparam->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\r\npsecuritypriv->dot118021XGrpPrivacy = _WEP40_;\r\nif (param->u.crypt.key_len == 13)\r\npsecuritypriv->dot118021XGrpPrivacy = _WEP104_;\r\n} else if (strcmp(param->u.crypt.alg, "TKIP") == 0) {\r\nDBG_88E("%s, set group_key, TKIP\n", __func__);\r\npsecuritypriv->dot118021XGrpPrivacy = _TKIP_;\r\nmemcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,\r\nparam->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\r\nmemcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);\r\nmemcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);\r\npsecuritypriv->busetkipkey = true;\r\n} else if (strcmp(param->u.crypt.alg, "CCMP") == 0) {\r\nDBG_88E("%s, set group_key, CCMP\n", __func__);\r\npsecuritypriv->dot118021XGrpPrivacy = _AES_;\r\nmemcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,\r\nparam->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\r\n} else {\r\nDBG_88E("%s, set group_key, none\n", __func__);\r\npsecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;\r\n}\r\npsecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;\r\npsecuritypriv->binstallGrpkey = true;\r\npsecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;\r\nset_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);\r\npbcmc_sta = rtw_get_bcmc_stainfo(padapter);\r\nif (pbcmc_sta) {\r\npbcmc_sta->ieee8021x_blocked = false;\r\npbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy;\r\n}\r\n}\r\ngoto exit;\r\n}\r\nif (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X && psta) {\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nif (param->u.crypt.set_tx == 1) {\r\nmemcpy(psta->dot118021x_UncstKey.skey, param->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\r\nif (strcmp(param->u.crypt.alg, "WEP") == 0) {\r\nDBG_88E("%s, set pairwise key, WEP\n", __func__);\r\npsta->dot118021XPrivacy = _WEP40_;\r\nif (param->u.crypt.key_len == 13)\r\npsta->dot118021XPrivacy = _WEP104_;\r\n} else if (strcmp(param->u.crypt.alg, "TKIP") == 0) {\r\nDBG_88E("%s, set pairwise key, TKIP\n", __func__);\r\npsta->dot118021XPrivacy = _TKIP_;\r\nmemcpy(psta->dot11tkiptxmickey.skey, &(param->u.crypt.key[16]), 8);\r\nmemcpy(psta->dot11tkiprxmickey.skey, &(param->u.crypt.key[24]), 8);\r\npsecuritypriv->busetkipkey = true;\r\n} else if (strcmp(param->u.crypt.alg, "CCMP") == 0) {\r\nDBG_88E("%s, set pairwise key, CCMP\n", __func__);\r\npsta->dot118021XPrivacy = _AES_;\r\n} else {\r\nDBG_88E("%s, set pairwise key, none\n", __func__);\r\npsta->dot118021XPrivacy = _NO_PRIVACY_;\r\n}\r\nset_pairwise_key(padapter, psta);\r\npsta->ieee8021x_blocked = false;\r\n} else {\r\nif (strcmp(param->u.crypt.alg, "WEP") == 0) {\r\nmemcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,\r\nparam->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\r\npsecuritypriv->dot118021XGrpPrivacy = _WEP40_;\r\nif (param->u.crypt.key_len == 13)\r\npsecuritypriv->dot118021XGrpPrivacy = _WEP104_;\r\n} else if (strcmp(param->u.crypt.alg, "TKIP") == 0) {\r\npsecuritypriv->dot118021XGrpPrivacy = _TKIP_;\r\nmemcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,\r\nparam->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\r\nmemcpy(psecuritypriv->dot118021XGrptxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[16]), 8);\r\nmemcpy(psecuritypriv->dot118021XGrprxmickey[param->u.crypt.idx].skey, &(param->u.crypt.key[24]), 8);\r\npsecuritypriv->busetkipkey = true;\r\n} else if (strcmp(param->u.crypt.alg, "CCMP") == 0) {\r\npsecuritypriv->dot118021XGrpPrivacy = _AES_;\r\nmemcpy(psecuritypriv->dot118021XGrpKey[param->u.crypt.idx].skey,\r\nparam->u.crypt.key, (param->u.crypt.key_len > 16 ? 16 : param->u.crypt.key_len));\r\n} else {\r\npsecuritypriv->dot118021XGrpPrivacy = _NO_PRIVACY_;\r\n}\r\npsecuritypriv->dot118021XGrpKeyid = param->u.crypt.idx;\r\npsecuritypriv->binstallGrpkey = true;\r\npsecuritypriv->dot11PrivacyAlgrthm = psecuritypriv->dot118021XGrpPrivacy;\r\nset_group_key(padapter, param->u.crypt.key, psecuritypriv->dot118021XGrpPrivacy, param->u.crypt.idx);\r\npbcmc_sta = rtw_get_bcmc_stainfo(padapter);\r\nif (pbcmc_sta) {\r\npbcmc_sta->ieee8021x_blocked = false;\r\npbcmc_sta->dot118021XPrivacy = psecuritypriv->dot118021XGrpPrivacy;\r\n}\r\n}\r\n}\r\n}\r\nexit:\r\nkfree(pwep);\r\nreturn ret;\r\n}\r\nstatic int rtw_set_beacon(struct net_device *dev, struct ieee_param *param, int len)\r\n{\r\nint ret = 0;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nunsigned char *pbuf = param->u.bcn_ie.buf;\r\nDBG_88E("%s, len =%d\n", __func__, len);\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\r\nreturn -EINVAL;\r\nmemcpy(&pstapriv->max_num_sta, param->u.bcn_ie.reserved, 2);\r\nif ((pstapriv->max_num_sta > NUM_STA) || (pstapriv->max_num_sta <= 0))\r\npstapriv->max_num_sta = NUM_STA;\r\nif (rtw_check_beacon_data(padapter, pbuf, (len-12-2)) == _SUCCESS)\r\nret = 0;\r\nelse\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int rtw_hostapd_sta_flush(struct net_device *dev)\r\n{\r\nint ret = 0;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nDBG_88E("%s\n", __func__);\r\nflush_all_cam_entry(padapter);\r\nret = rtw_sta_flush(padapter);\r\nreturn ret;\r\n}\r\nstatic int rtw_add_sta(struct net_device *dev, struct ieee_param *param)\r\n{\r\nint ret = 0;\r\nstruct sta_info *psta = NULL;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nDBG_88E("rtw_add_sta(aid =%d) =%pM\n", param->u.add_sta.aid, (param->sta_addr));\r\nif (!check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)))\r\nreturn -EINVAL;\r\nif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\r\nparam->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\r\nparam->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)\r\nreturn -EINVAL;\r\npsta = rtw_get_stainfo(pstapriv, param->sta_addr);\r\nif (psta) {\r\nint flags = param->u.add_sta.flags;\r\npsta->aid = param->u.add_sta.aid;\r\nmemcpy(psta->bssrateset, param->u.add_sta.tx_supp_rates, 16);\r\nif (WLAN_STA_WME&flags)\r\npsta->qos_option = 1;\r\nelse\r\npsta->qos_option = 0;\r\nif (pmlmepriv->qospriv.qos_option == 0)\r\npsta->qos_option = 0;\r\nif (WLAN_STA_HT&flags) {\r\npsta->htpriv.ht_option = true;\r\npsta->qos_option = 1;\r\nmemcpy((void *)&psta->htpriv.ht_cap, (void *)&param->u.add_sta.ht_cap, sizeof(struct rtw_ieee80211_ht_cap));\r\n} else {\r\npsta->htpriv.ht_option = false;\r\n}\r\nif (pmlmepriv->htpriv.ht_option == false)\r\npsta->htpriv.ht_option = false;\r\nupdate_sta_info_apmode(padapter, psta);\r\n} else {\r\nret = -ENOMEM;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtw_del_sta(struct net_device *dev, struct ieee_param *param)\r\n{\r\nint ret = 0;\r\nstruct sta_info *psta = NULL;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nint updated = 0;\r\nDBG_88E("rtw_del_sta =%pM\n", (param->sta_addr));\r\nif (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true)\r\nreturn -EINVAL;\r\nif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\r\nparam->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\r\nparam->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)\r\nreturn -EINVAL;\r\npsta = rtw_get_stainfo(pstapriv, param->sta_addr);\r\nif (psta) {\r\nspin_lock_bh(&pstapriv->asoc_list_lock);\r\nif (!list_empty(&psta->asoc_list)) {\r\nlist_del_init(&psta->asoc_list);\r\npstapriv->asoc_list_cnt--;\r\nupdated = ap_free_sta(padapter, psta, true, WLAN_REASON_DEAUTH_LEAVING);\r\n}\r\nspin_unlock_bh(&pstapriv->asoc_list_lock);\r\nassociated_clients_update(padapter, updated);\r\npsta = NULL;\r\n} else {\r\nDBG_88E("rtw_del_sta(), sta has already been removed or never been added\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtw_ioctl_get_sta_data(struct net_device *dev, struct ieee_param *param, int len)\r\n{\r\nint ret = 0;\r\nstruct sta_info *psta = NULL;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct ieee_param_ex *param_ex = (struct ieee_param_ex *)param;\r\nstruct sta_data *psta_data = (struct sta_data *)param_ex->data;\r\nDBG_88E("rtw_ioctl_get_sta_info, sta_addr: %pM\n", (param_ex->sta_addr));\r\nif (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true)\r\nreturn -EINVAL;\r\nif (param_ex->sta_addr[0] == 0xff && param_ex->sta_addr[1] == 0xff &&\r\nparam_ex->sta_addr[2] == 0xff && param_ex->sta_addr[3] == 0xff &&\r\nparam_ex->sta_addr[4] == 0xff && param_ex->sta_addr[5] == 0xff)\r\nreturn -EINVAL;\r\npsta = rtw_get_stainfo(pstapriv, param_ex->sta_addr);\r\nif (psta) {\r\npsta_data->aid = (u16)psta->aid;\r\npsta_data->capability = psta->capability;\r\npsta_data->flags = psta->flags;\r\npsta_data->sta_set = ((psta->nonerp_set) |\r\n(psta->no_short_slot_time_set << 1) |\r\n(psta->no_short_preamble_set << 2) |\r\n(psta->no_ht_gf_set << 3) |\r\n(psta->no_ht_set << 4) |\r\n(psta->ht_20mhz_set << 5));\r\npsta_data->tx_supp_rates_len = psta->bssratelen;\r\nmemcpy(psta_data->tx_supp_rates, psta->bssrateset, psta->bssratelen);\r\nmemcpy(&psta_data->ht_cap, &psta->htpriv.ht_cap, sizeof(struct rtw_ieee80211_ht_cap));\r\npsta_data->rx_pkts = psta->sta_stats.rx_data_pkts;\r\npsta_data->rx_bytes = psta->sta_stats.rx_bytes;\r\npsta_data->rx_drops = psta->sta_stats.rx_drops;\r\npsta_data->tx_pkts = psta->sta_stats.tx_pkts;\r\npsta_data->tx_bytes = psta->sta_stats.tx_bytes;\r\npsta_data->tx_drops = psta->sta_stats.tx_drops;\r\n} else {\r\nret = -1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtw_get_sta_wpaie(struct net_device *dev, struct ieee_param *param)\r\n{\r\nint ret = 0;\r\nstruct sta_info *psta = NULL;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nDBG_88E("rtw_get_sta_wpaie, sta_addr: %pM\n", (param->sta_addr));\r\nif (check_fwstate(pmlmepriv, (_FW_LINKED|WIFI_AP_STATE)) != true)\r\nreturn -EINVAL;\r\nif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\r\nparam->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\r\nparam->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)\r\nreturn -EINVAL;\r\npsta = rtw_get_stainfo(pstapriv, param->sta_addr);\r\nif (psta) {\r\nif ((psta->wpa_ie[0] == WLAN_EID_RSN) || (psta->wpa_ie[0] == WLAN_EID_GENERIC)) {\r\nint wpa_ie_len;\r\nint copy_len;\r\nwpa_ie_len = psta->wpa_ie[1];\r\ncopy_len = ((wpa_ie_len+2) > sizeof(psta->wpa_ie)) ? (sizeof(psta->wpa_ie)) : (wpa_ie_len+2);\r\nparam->u.wpa_ie.len = copy_len;\r\nmemcpy(param->u.wpa_ie.reserved, psta->wpa_ie, copy_len);\r\n} else {\r\nDBG_88E("sta's wpa_ie is NONE\n");\r\n}\r\n} else {\r\nret = -1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtw_set_wps_beacon(struct net_device *dev, struct ieee_param *param, int len)\r\n{\r\nint ret = 0;\r\nunsigned char wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nint ie_len;\r\nDBG_88E("%s, len =%d\n", __func__, len);\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\r\nreturn -EINVAL;\r\nie_len = len-12-2;\r\nkfree(pmlmepriv->wps_beacon_ie);\r\npmlmepriv->wps_beacon_ie = NULL;\r\nif (ie_len > 0) {\r\npmlmepriv->wps_beacon_ie = rtw_malloc(ie_len);\r\npmlmepriv->wps_beacon_ie_len = ie_len;\r\nif (pmlmepriv->wps_beacon_ie == NULL) {\r\nDBG_88E("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(pmlmepriv->wps_beacon_ie, param->u.bcn_ie.buf, ie_len);\r\nupdate_beacon(padapter, _VENDOR_SPECIFIC_IE_, wps_oui, true);\r\npmlmeext->bstart_bss = true;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtw_set_wps_probe_resp(struct net_device *dev, struct ieee_param *param, int len)\r\n{\r\nint ret = 0;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nint ie_len;\r\nDBG_88E("%s, len =%d\n", __func__, len);\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\r\nreturn -EINVAL;\r\nie_len = len-12-2;\r\nkfree(pmlmepriv->wps_probe_resp_ie);\r\npmlmepriv->wps_probe_resp_ie = NULL;\r\nif (ie_len > 0) {\r\npmlmepriv->wps_probe_resp_ie = rtw_malloc(ie_len);\r\npmlmepriv->wps_probe_resp_ie_len = ie_len;\r\nif (pmlmepriv->wps_probe_resp_ie == NULL) {\r\nDBG_88E("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(pmlmepriv->wps_probe_resp_ie, param->u.bcn_ie.buf, ie_len);\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtw_set_wps_assoc_resp(struct net_device *dev, struct ieee_param *param, int len)\r\n{\r\nint ret = 0;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nint ie_len;\r\nDBG_88E("%s, len =%d\n", __func__, len);\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\r\nreturn -EINVAL;\r\nie_len = len-12-2;\r\nkfree(pmlmepriv->wps_assoc_resp_ie);\r\npmlmepriv->wps_assoc_resp_ie = NULL;\r\nif (ie_len > 0) {\r\npmlmepriv->wps_assoc_resp_ie = rtw_malloc(ie_len);\r\npmlmepriv->wps_assoc_resp_ie_len = ie_len;\r\nif (pmlmepriv->wps_assoc_resp_ie == NULL) {\r\nDBG_88E("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(pmlmepriv->wps_assoc_resp_ie, param->u.bcn_ie.buf, ie_len);\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtw_set_hidden_ssid(struct net_device *dev, struct ieee_param *param, int len)\r\n{\r\nint ret = 0;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nu8 value;\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\r\nreturn -EINVAL;\r\nif (param->u.wpa_param.name != 0)\r\nDBG_88E("%s name(%u) != 0\n", __func__, param->u.wpa_param.name);\r\nvalue = param->u.wpa_param.value;\r\nif (value != 1 && value != 2)\r\nvalue = 0;\r\nDBG_88E("%s value(%u)\n", __func__, value);\r\npmlmeinfo->hidden_ssid_mode = value;\r\nreturn ret;\r\n}\r\nstatic int rtw_ioctl_acl_remove_sta(struct net_device *dev, struct ieee_param *param, int len)\r\n{\r\nint ret = 0;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\r\nreturn -EINVAL;\r\nif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\r\nparam->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\r\nparam->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)\r\nreturn -EINVAL;\r\nret = rtw_acl_remove_sta(padapter, param->sta_addr);\r\nreturn ret;\r\n}\r\nstatic int rtw_ioctl_acl_add_sta(struct net_device *dev, struct ieee_param *param, int len)\r\n{\r\nint ret = 0;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\r\nreturn -EINVAL;\r\nif (param->sta_addr[0] == 0xff && param->sta_addr[1] == 0xff &&\r\nparam->sta_addr[2] == 0xff && param->sta_addr[3] == 0xff &&\r\nparam->sta_addr[4] == 0xff && param->sta_addr[5] == 0xff)\r\nreturn -EINVAL;\r\nret = rtw_acl_add_sta(padapter, param->sta_addr);\r\nreturn ret;\r\n}\r\nstatic int rtw_ioctl_set_macaddr_acl(struct net_device *dev, struct ieee_param *param, int len)\r\n{\r\nint ret = 0;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE) != true)\r\nreturn -EINVAL;\r\nrtw_set_macaddr_acl(padapter, param->u.mlme.command);\r\nreturn ret;\r\n}\r\nstatic int rtw_hostapd_ioctl(struct net_device *dev, struct iw_point *p)\r\n{\r\nstruct ieee_param *param;\r\nint ret = 0;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nif (!padapter->hw_init_completed) {\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nif (!p->pointer) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nparam = (struct ieee_param *)rtw_malloc(p->length);\r\nif (param == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (copy_from_user(param, p->pointer, p->length)) {\r\nkfree(param);\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nswitch (param->cmd) {\r\ncase RTL871X_HOSTAPD_FLUSH:\r\nret = rtw_hostapd_sta_flush(dev);\r\nbreak;\r\ncase RTL871X_HOSTAPD_ADD_STA:\r\nret = rtw_add_sta(dev, param);\r\nbreak;\r\ncase RTL871X_HOSTAPD_REMOVE_STA:\r\nret = rtw_del_sta(dev, param);\r\nbreak;\r\ncase RTL871X_HOSTAPD_SET_BEACON:\r\nret = rtw_set_beacon(dev, param, p->length);\r\nbreak;\r\ncase RTL871X_SET_ENCRYPTION:\r\nret = rtw_set_encryption(dev, param, p->length);\r\nbreak;\r\ncase RTL871X_HOSTAPD_GET_WPAIE_STA:\r\nret = rtw_get_sta_wpaie(dev, param);\r\nbreak;\r\ncase RTL871X_HOSTAPD_SET_WPS_BEACON:\r\nret = rtw_set_wps_beacon(dev, param, p->length);\r\nbreak;\r\ncase RTL871X_HOSTAPD_SET_WPS_PROBE_RESP:\r\nret = rtw_set_wps_probe_resp(dev, param, p->length);\r\nbreak;\r\ncase RTL871X_HOSTAPD_SET_WPS_ASSOC_RESP:\r\nret = rtw_set_wps_assoc_resp(dev, param, p->length);\r\nbreak;\r\ncase RTL871X_HOSTAPD_SET_HIDDEN_SSID:\r\nret = rtw_set_hidden_ssid(dev, param, p->length);\r\nbreak;\r\ncase RTL871X_HOSTAPD_GET_INFO_STA:\r\nret = rtw_ioctl_get_sta_data(dev, param, p->length);\r\nbreak;\r\ncase RTL871X_HOSTAPD_SET_MACADDR_ACL:\r\nret = rtw_ioctl_set_macaddr_acl(dev, param, p->length);\r\nbreak;\r\ncase RTL871X_HOSTAPD_ACL_ADD_STA:\r\nret = rtw_ioctl_acl_add_sta(dev, param, p->length);\r\nbreak;\r\ncase RTL871X_HOSTAPD_ACL_REMOVE_STA:\r\nret = rtw_ioctl_acl_remove_sta(dev, param, p->length);\r\nbreak;\r\ndefault:\r\nDBG_88E("Unknown hostapd request: %d\n", param->cmd);\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nif (ret == 0 && copy_to_user(p->pointer, param, p->length))\r\nret = -EFAULT;\r\nkfree(param);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int rtw_wx_set_priv(struct net_device *dev,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *awrq,\r\nchar *extra)\r\n{\r\nint ret = 0;\r\nint len = 0;\r\nchar *ext;\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct iw_point *dwrq = (struct iw_point *)awrq;\r\nif (dwrq->length == 0)\r\nreturn -EFAULT;\r\nlen = dwrq->length;\r\next = vmalloc(len);\r\nif (!ext)\r\nreturn -ENOMEM;\r\nif (copy_from_user(ext, dwrq->pointer, len)) {\r\nvfree(ext);\r\nreturn -EFAULT;\r\n}\r\nif (dwrq->flags == 0x8766 && len > 8) {\r\nu32 cp_sz;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nu8 *probereq_wpsie = ext;\r\nint probereq_wpsie_len = len;\r\nu8 wps_oui[4] = {0x0, 0x50, 0xf2, 0x04};\r\nif ((_VENDOR_SPECIFIC_IE_ == probereq_wpsie[0]) &&\r\n(!memcmp(&probereq_wpsie[2], wps_oui, 4))) {\r\ncp_sz = probereq_wpsie_len > MAX_WPS_IE_LEN ? MAX_WPS_IE_LEN : probereq_wpsie_len;\r\npmlmepriv->wps_probe_req_ie_len = 0;\r\nkfree(pmlmepriv->wps_probe_req_ie);\r\npmlmepriv->wps_probe_req_ie = NULL;\r\npmlmepriv->wps_probe_req_ie = rtw_malloc(cp_sz);\r\nif (pmlmepriv->wps_probe_req_ie == NULL) {\r\npr_info("%s()-%d: rtw_malloc() ERROR!\n", __func__, __LINE__);\r\nret = -EINVAL;\r\ngoto FREE_EXT;\r\n}\r\nmemcpy(pmlmepriv->wps_probe_req_ie, probereq_wpsie, cp_sz);\r\npmlmepriv->wps_probe_req_ie_len = cp_sz;\r\n}\r\ngoto FREE_EXT;\r\n}\r\nif (len >= WEXT_CSCAN_HEADER_SIZE &&\r\n!memcmp(ext, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE)) {\r\nret = rtw_wx_set_scan(dev, info, awrq, ext);\r\ngoto FREE_EXT;\r\n}\r\nFREE_EXT:\r\nvfree(ext);\r\nreturn ret;\r\n}\r\nstatic struct iw_statistics *rtw_get_wireless_stats(struct net_device *dev)\r\n{\r\nstruct adapter *padapter = (struct adapter *)rtw_netdev_priv(dev);\r\nstruct iw_statistics *piwstats = &padapter->iwstats;\r\nint tmp_level = 0;\r\nint tmp_qual = 0;\r\nint tmp_noise = 0;\r\nif (!check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {\r\npiwstats->qual.qual = 0;\r\npiwstats->qual.level = 0;\r\npiwstats->qual.noise = 0;\r\n} else {\r\ntmp_level = padapter->recvpriv.signal_strength;\r\ntmp_qual = padapter->recvpriv.signal_qual;\r\ntmp_noise = padapter->recvpriv.noise;\r\npiwstats->qual.level = tmp_level;\r\npiwstats->qual.qual = tmp_qual;\r\npiwstats->qual.noise = tmp_noise;\r\n}\r\npiwstats->qual.updated = IW_QUAL_ALL_UPDATED;\r\nreturn &padapter->iwstats;\r\n}\r\nint rtw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct iwreq *wrq = (struct iwreq *)rq;\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase RTL_IOCTL_WPA_SUPPLICANT:\r\nret = wpa_supplicant_ioctl(dev, &wrq->u.data);\r\nbreak;\r\n#ifdef CONFIG_88EU_AP_MODE\r\ncase RTL_IOCTL_HOSTAPD:\r\nret = rtw_hostapd_ioctl(dev, &wrq->u.data);\r\nbreak;\r\n#endif\r\ncase (SIOCDEVPRIVATE+1):\r\nret = rtw_android_priv_cmd(dev, rq, cmd);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ret;\r\n}
