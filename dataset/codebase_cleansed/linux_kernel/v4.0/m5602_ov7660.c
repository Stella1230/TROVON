int ov7660_probe(struct sd *sd)\r\n{\r\nint err = 0, i;\r\nu8 prod_id = 0, ver_id = 0;\r\nif (force_sensor) {\r\nif (force_sensor == OV7660_SENSOR) {\r\npr_info("Forcing an %s sensor\n", ov7660.name);\r\ngoto sensor_found;\r\n}\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(preinit_ov7660) && !err; i++) {\r\nu8 data[2];\r\nif (preinit_ov7660[i][0] == BRIDGE) {\r\nerr = m5602_write_bridge(sd,\r\npreinit_ov7660[i][1],\r\npreinit_ov7660[i][2]);\r\n} else {\r\ndata[0] = preinit_ov7660[i][2];\r\nerr = m5602_write_sensor(sd,\r\npreinit_ov7660[i][1], data, 1);\r\n}\r\n}\r\nif (err < 0)\r\nreturn err;\r\nif (m5602_read_sensor(sd, OV7660_PID, &prod_id, 1))\r\nreturn -ENODEV;\r\nif (m5602_read_sensor(sd, OV7660_VER, &ver_id, 1))\r\nreturn -ENODEV;\r\npr_info("Sensor reported 0x%x%x\n", prod_id, ver_id);\r\nif ((prod_id == 0x76) && (ver_id == 0x60)) {\r\npr_info("Detected a ov7660 sensor\n");\r\ngoto sensor_found;\r\n}\r\nreturn -ENODEV;\r\nsensor_found:\r\nsd->gspca_dev.cam.cam_mode = ov7660_modes;\r\nsd->gspca_dev.cam.nmodes = ARRAY_SIZE(ov7660_modes);\r\nreturn 0;\r\n}\r\nint ov7660_init(struct sd *sd)\r\n{\r\nint i, err;\r\nfor (i = 0; i < ARRAY_SIZE(init_ov7660); i++) {\r\nu8 data[2];\r\nif (init_ov7660[i][0] == BRIDGE) {\r\nerr = m5602_write_bridge(sd,\r\ninit_ov7660[i][1],\r\ninit_ov7660[i][2]);\r\n} else {\r\ndata[0] = init_ov7660[i][2];\r\nerr = m5602_write_sensor(sd,\r\ninit_ov7660[i][1], data, 1);\r\n}\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (dump_sensor)\r\nov7660_dump_registers(sd);\r\nreturn 0;\r\n}\r\nint ov7660_init_controls(struct sd *sd)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &sd->gspca_dev.ctrl_handler;\r\nsd->gspca_dev.vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 6);\r\nv4l2_ctrl_new_std(hdl, &ov7660_ctrl_ops, V4L2_CID_AUTO_WHITE_BALANCE,\r\n0, 1, 1, 1);\r\nv4l2_ctrl_new_std_menu(hdl, &ov7660_ctrl_ops,\r\nV4L2_CID_EXPOSURE_AUTO, 1, 0, V4L2_EXPOSURE_AUTO);\r\nsd->autogain = v4l2_ctrl_new_std(hdl, &ov7660_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\nsd->gain = v4l2_ctrl_new_std(hdl, &ov7660_ctrl_ops, V4L2_CID_GAIN, 0,\r\n255, 1, OV7660_DEFAULT_GAIN);\r\nsd->hflip = v4l2_ctrl_new_std(hdl, &ov7660_ctrl_ops, V4L2_CID_HFLIP,\r\n0, 1, 1, 0);\r\nsd->vflip = v4l2_ctrl_new_std(hdl, &ov7660_ctrl_ops, V4L2_CID_VFLIP,\r\n0, 1, 1, 0);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nv4l2_ctrl_auto_cluster(2, &sd->autogain, 0, false);\r\nv4l2_ctrl_cluster(2, &sd->hflip);\r\nreturn 0;\r\n}\r\nint ov7660_start(struct sd *sd)\r\n{\r\nreturn 0;\r\n}\r\nint ov7660_stop(struct sd *sd)\r\n{\r\nreturn 0;\r\n}\r\nvoid ov7660_disconnect(struct sd *sd)\r\n{\r\nov7660_stop(sd);\r\nsd->sensor = NULL;\r\n}\r\nstatic int ov7660_set_gain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 i2c_data = val;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nPDEBUG(D_CONF, "Setting gain to %d", val);\r\nerr = m5602_write_sensor(sd, OV7660_GAIN, &i2c_data, 1);\r\nreturn err;\r\n}\r\nstatic int ov7660_set_auto_white_balance(struct gspca_dev *gspca_dev,\r\n__s32 val)\r\n{\r\nint err;\r\nu8 i2c_data;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nPDEBUG(D_CONF, "Set auto white balance to %d", val);\r\nerr = m5602_read_sensor(sd, OV7660_COM8, &i2c_data, 1);\r\nif (err < 0)\r\nreturn err;\r\ni2c_data = ((i2c_data & 0xfd) | ((val & 0x01) << 1));\r\nerr = m5602_write_sensor(sd, OV7660_COM8, &i2c_data, 1);\r\nreturn err;\r\n}\r\nstatic int ov7660_set_auto_gain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 i2c_data;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nPDEBUG(D_CONF, "Set auto gain control to %d", val);\r\nerr = m5602_read_sensor(sd, OV7660_COM8, &i2c_data, 1);\r\nif (err < 0)\r\nreturn err;\r\ni2c_data = ((i2c_data & 0xfb) | ((val & 0x01) << 2));\r\nreturn m5602_write_sensor(sd, OV7660_COM8, &i2c_data, 1);\r\n}\r\nstatic int ov7660_set_auto_exposure(struct gspca_dev *gspca_dev,\r\n__s32 val)\r\n{\r\nint err;\r\nu8 i2c_data;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nPDEBUG(D_CONF, "Set auto exposure control to %d", val);\r\nerr = m5602_read_sensor(sd, OV7660_COM8, &i2c_data, 1);\r\nif (err < 0)\r\nreturn err;\r\nval = (val == V4L2_EXPOSURE_AUTO);\r\ni2c_data = ((i2c_data & 0xfe) | ((val & 0x01) << 0));\r\nreturn m5602_write_sensor(sd, OV7660_COM8, &i2c_data, 1);\r\n}\r\nstatic int ov7660_set_hvflip(struct gspca_dev *gspca_dev)\r\n{\r\nint err;\r\nu8 i2c_data;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nPDEBUG(D_CONF, "Set hvflip to %d, %d", sd->hflip->val, sd->vflip->val);\r\ni2c_data = (sd->hflip->val << 5) | (sd->vflip->val << 4);\r\nerr = m5602_write_sensor(sd, OV7660_MVFP, &i2c_data, 1);\r\nreturn err;\r\n}\r\nstatic int ov7660_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint err;\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUTO_WHITE_BALANCE:\r\nerr = ov7660_set_auto_white_balance(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_EXPOSURE_AUTO:\r\nerr = ov7660_set_auto_exposure(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_AUTOGAIN:\r\nerr = ov7660_set_auto_gain(gspca_dev, ctrl->val);\r\nif (err || ctrl->val)\r\nreturn err;\r\nerr = ov7660_set_gain(gspca_dev, sd->gain->val);\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\nerr = ov7660_set_hvflip(gspca_dev);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic void ov7660_dump_registers(struct sd *sd)\r\n{\r\nint address;\r\npr_info("Dumping the ov7660 register state\n");\r\nfor (address = 0; address < 0xa9; address++) {\r\nu8 value;\r\nm5602_read_sensor(sd, address, &value, 1);\r\npr_info("register 0x%x contains 0x%x\n", address, value);\r\n}\r\npr_info("ov7660 register state dump complete\n");\r\npr_info("Probing for which registers that are read/write\n");\r\nfor (address = 0; address < 0xff; address++) {\r\nu8 old_value, ctrl_value;\r\nu8 test_value[2] = {0xff, 0xff};\r\nm5602_read_sensor(sd, address, &old_value, 1);\r\nm5602_write_sensor(sd, address, test_value, 1);\r\nm5602_read_sensor(sd, address, &ctrl_value, 1);\r\nif (ctrl_value == test_value[0])\r\npr_info("register 0x%x is writeable\n", address);\r\nelse\r\npr_info("register 0x%x is read only\n", address);\r\nm5602_write_sensor(sd, address, &old_value, 1);\r\n}\r\n}
