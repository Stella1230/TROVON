static void netdev_port_receive(struct vport *vport, struct sk_buff *skb)\r\n{\r\nif (unlikely(!vport))\r\ngoto error;\r\nif (unlikely(skb_warn_if_lro(skb)))\r\ngoto error;\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (unlikely(!skb))\r\nreturn;\r\nskb_push(skb, ETH_HLEN);\r\novs_skb_postpush_rcsum(skb, skb->data, ETH_HLEN);\r\novs_vport_receive(vport, skb, NULL);\r\nreturn;\r\nerror:\r\nkfree_skb(skb);\r\n}\r\nstatic rx_handler_result_t netdev_frame_hook(struct sk_buff **pskb)\r\n{\r\nstruct sk_buff *skb = *pskb;\r\nstruct vport *vport;\r\nif (unlikely(skb->pkt_type == PACKET_LOOPBACK))\r\nreturn RX_HANDLER_PASS;\r\nvport = ovs_netdev_get_vport(skb->dev);\r\nnetdev_port_receive(vport, skb);\r\nreturn RX_HANDLER_CONSUMED;\r\n}\r\nstatic struct net_device *get_dpdev(const struct datapath *dp)\r\n{\r\nstruct vport *local;\r\nlocal = ovs_vport_ovsl(dp, OVSP_LOCAL);\r\nBUG_ON(!local);\r\nreturn netdev_vport_priv(local)->dev;\r\n}\r\nstatic struct vport *netdev_create(const struct vport_parms *parms)\r\n{\r\nstruct vport *vport;\r\nstruct netdev_vport *netdev_vport;\r\nint err;\r\nvport = ovs_vport_alloc(sizeof(struct netdev_vport),\r\n&ovs_netdev_vport_ops, parms);\r\nif (IS_ERR(vport)) {\r\nerr = PTR_ERR(vport);\r\ngoto error;\r\n}\r\nnetdev_vport = netdev_vport_priv(vport);\r\nnetdev_vport->dev = dev_get_by_name(ovs_dp_get_net(vport->dp), parms->name);\r\nif (!netdev_vport->dev) {\r\nerr = -ENODEV;\r\ngoto error_free_vport;\r\n}\r\nif (netdev_vport->dev->flags & IFF_LOOPBACK ||\r\nnetdev_vport->dev->type != ARPHRD_ETHER ||\r\novs_is_internal_dev(netdev_vport->dev)) {\r\nerr = -EINVAL;\r\ngoto error_put;\r\n}\r\nrtnl_lock();\r\nerr = netdev_master_upper_dev_link(netdev_vport->dev,\r\nget_dpdev(vport->dp));\r\nif (err)\r\ngoto error_unlock;\r\nerr = netdev_rx_handler_register(netdev_vport->dev, netdev_frame_hook,\r\nvport);\r\nif (err)\r\ngoto error_master_upper_dev_unlink;\r\ndev_set_promiscuity(netdev_vport->dev, 1);\r\nnetdev_vport->dev->priv_flags |= IFF_OVS_DATAPATH;\r\nrtnl_unlock();\r\nreturn vport;\r\nerror_master_upper_dev_unlink:\r\nnetdev_upper_dev_unlink(netdev_vport->dev, get_dpdev(vport->dp));\r\nerror_unlock:\r\nrtnl_unlock();\r\nerror_put:\r\ndev_put(netdev_vport->dev);\r\nerror_free_vport:\r\novs_vport_free(vport);\r\nerror:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void free_port_rcu(struct rcu_head *rcu)\r\n{\r\nstruct netdev_vport *netdev_vport = container_of(rcu,\r\nstruct netdev_vport, rcu);\r\ndev_put(netdev_vport->dev);\r\novs_vport_free(vport_from_priv(netdev_vport));\r\n}\r\nvoid ovs_netdev_detach_dev(struct vport *vport)\r\n{\r\nstruct netdev_vport *netdev_vport = netdev_vport_priv(vport);\r\nASSERT_RTNL();\r\nnetdev_vport->dev->priv_flags &= ~IFF_OVS_DATAPATH;\r\nnetdev_rx_handler_unregister(netdev_vport->dev);\r\nnetdev_upper_dev_unlink(netdev_vport->dev,\r\nnetdev_master_upper_dev_get(netdev_vport->dev));\r\ndev_set_promiscuity(netdev_vport->dev, -1);\r\n}\r\nstatic void netdev_destroy(struct vport *vport)\r\n{\r\nstruct netdev_vport *netdev_vport = netdev_vport_priv(vport);\r\nrtnl_lock();\r\nif (netdev_vport->dev->priv_flags & IFF_OVS_DATAPATH)\r\novs_netdev_detach_dev(vport);\r\nrtnl_unlock();\r\ncall_rcu(&netdev_vport->rcu, free_port_rcu);\r\n}\r\nconst char *ovs_netdev_get_name(const struct vport *vport)\r\n{\r\nconst struct netdev_vport *netdev_vport = netdev_vport_priv(vport);\r\nreturn netdev_vport->dev->name;\r\n}\r\nstatic unsigned int packet_length(const struct sk_buff *skb)\r\n{\r\nunsigned int length = skb->len - ETH_HLEN;\r\nif (skb->protocol == htons(ETH_P_8021Q))\r\nlength -= VLAN_HLEN;\r\nreturn length;\r\n}\r\nstatic int netdev_send(struct vport *vport, struct sk_buff *skb)\r\n{\r\nstruct netdev_vport *netdev_vport = netdev_vport_priv(vport);\r\nint mtu = netdev_vport->dev->mtu;\r\nint len;\r\nif (unlikely(packet_length(skb) > mtu && !skb_is_gso(skb))) {\r\nnet_warn_ratelimited("%s: dropped over-mtu packet: %d > %d\n",\r\nnetdev_vport->dev->name,\r\npacket_length(skb), mtu);\r\ngoto drop;\r\n}\r\nskb->dev = netdev_vport->dev;\r\nlen = skb->len;\r\ndev_queue_xmit(skb);\r\nreturn len;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstruct vport *ovs_netdev_get_vport(struct net_device *dev)\r\n{\r\nif (likely(dev->priv_flags & IFF_OVS_DATAPATH))\r\nreturn (struct vport *)\r\nrcu_dereference_rtnl(dev->rx_handler_data);\r\nelse\r\nreturn NULL;\r\n}\r\nint __init ovs_netdev_init(void)\r\n{\r\nreturn ovs_vport_ops_register(&ovs_netdev_vport_ops);\r\n}\r\nvoid ovs_netdev_exit(void)\r\n{\r\novs_vport_ops_unregister(&ovs_netdev_vport_ops);\r\n}
