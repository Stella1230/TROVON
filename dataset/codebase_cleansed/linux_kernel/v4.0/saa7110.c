static inline struct saa7110 *to_saa7110(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct saa7110, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct saa7110, hdl)->sd;\r\n}\r\nstatic int saa7110_write(struct v4l2_subdev *sd, u8 reg, u8 value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct saa7110 *decoder = to_saa7110(sd);\r\ndecoder->reg[reg] = value;\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic int saa7110_write_block(struct v4l2_subdev *sd, const u8 *data, unsigned int len)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct saa7110 *decoder = to_saa7110(sd);\r\nint ret = -1;\r\nu8 reg = *data;\r\nif (reg + (len - 1) > SAA7110_NR_REG)\r\nreturn ret;\r\nif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {\r\nret = i2c_master_send(client, data, len);\r\nmemcpy(decoder->reg + reg, data + 1, len - 1);\r\n} else {\r\nfor (++data, --len; len; len--) {\r\nret = saa7110_write(sd, reg++, *data++);\r\nif (ret < 0)\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic inline int saa7110_read(struct v4l2_subdev *sd)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn i2c_smbus_read_byte(client);\r\n}\r\nstatic int saa7110_selmux(struct v4l2_subdev *sd, int chan)\r\n{\r\nstatic const unsigned char modes[9][8] = {\r\n{FRESP_06H_COMPST, 0xD9, 0x17, 0x40, 0x03,\r\n0x44, 0x75, 0x16},\r\n{FRESP_06H_COMPST, 0xD8, 0x17, 0x40, 0x03,\r\n0x44, 0x75, 0x16},\r\n{FRESP_06H_COMPST, 0xBA, 0x07, 0x91, 0x03,\r\n0x60, 0xB5, 0x05},\r\n{FRESP_06H_COMPST, 0xB8, 0x07, 0x91, 0x03,\r\n0x60, 0xB5, 0x05},\r\n{FRESP_06H_COMPST, 0x7C, 0x07, 0xD2, 0x83,\r\n0x60, 0xB5, 0x03},\r\n{FRESP_06H_COMPST, 0x78, 0x07, 0xD2, 0x83,\r\n0x60, 0xB5, 0x03},\r\n{FRESP_06H_SVIDEO, 0x59, 0x17, 0x42, 0xA3,\r\n0x44, 0x75, 0x12},\r\n{FRESP_06H_SVIDEO, 0x9A, 0x17, 0xB1, 0x13,\r\n0x60, 0xB5, 0x14},\r\n{FRESP_06H_SVIDEO, 0x3C, 0x27, 0xC1, 0x23,\r\n0x44, 0x75, 0x21}\r\n};\r\nstruct saa7110 *decoder = to_saa7110(sd);\r\nconst unsigned char *ptr = modes[chan];\r\nsaa7110_write(sd, 0x06, ptr[0]);\r\nsaa7110_write(sd, 0x20, ptr[1]);\r\nsaa7110_write(sd, 0x21, ptr[2]);\r\nsaa7110_write(sd, 0x22, ptr[3]);\r\nsaa7110_write(sd, 0x2C, ptr[4]);\r\nsaa7110_write(sd, 0x30, ptr[5]);\r\nsaa7110_write(sd, 0x31, ptr[6]);\r\nsaa7110_write(sd, 0x21, ptr[7]);\r\ndecoder->input = chan;\r\nreturn 0;\r\n}\r\nstatic v4l2_std_id determine_norm(struct v4l2_subdev *sd)\r\n{\r\nDEFINE_WAIT(wait);\r\nstruct saa7110 *decoder = to_saa7110(sd);\r\nint status;\r\nsaa7110_write_block(sd, initseq, sizeof(initseq));\r\nsaa7110_selmux(sd, decoder->input);\r\nprepare_to_wait(&decoder->wq, &wait, TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(msecs_to_jiffies(250));\r\nfinish_wait(&decoder->wq, &wait);\r\nstatus = saa7110_read(sd);\r\nif (status & 0x40) {\r\nv4l2_dbg(1, debug, sd, "status=0x%02x (no signal)\n", status);\r\nreturn V4L2_STD_UNKNOWN;\r\n}\r\nif ((status & 3) == 0) {\r\nsaa7110_write(sd, 0x06, 0x83);\r\nif (status & 0x20) {\r\nv4l2_dbg(1, debug, sd, "status=0x%02x (NTSC/no color)\n", status);\r\nreturn V4L2_STD_NTSC;\r\n}\r\nv4l2_dbg(1, debug, sd, "status=0x%02x (PAL/no color)\n", status);\r\nreturn V4L2_STD_PAL;\r\n}\r\nif (status & 0x20) {\r\nv4l2_dbg(1, debug, sd, "status=0x%02x (NTSC)\n", status);\r\nsaa7110_write(sd, 0x0D, 0x86);\r\nsaa7110_write(sd, 0x0F, 0x50);\r\nsaa7110_write(sd, 0x11, 0x2C);\r\nreturn V4L2_STD_NTSC;\r\n}\r\nsaa7110_write(sd, 0x0D, 0x86);\r\nsaa7110_write(sd, 0x0F, 0x10);\r\nsaa7110_write(sd, 0x11, 0x59);\r\nprepare_to_wait(&decoder->wq, &wait, TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(msecs_to_jiffies(250));\r\nfinish_wait(&decoder->wq, &wait);\r\nstatus = saa7110_read(sd);\r\nif ((status & 0x03) == 0x01) {\r\nv4l2_dbg(1, debug, sd, "status=0x%02x (SECAM)\n", status);\r\nsaa7110_write(sd, 0x0D, 0x87);\r\nreturn V4L2_STD_SECAM;\r\n}\r\nv4l2_dbg(1, debug, sd, "status=0x%02x (PAL)\n", status);\r\nreturn V4L2_STD_PAL;\r\n}\r\nstatic int saa7110_g_input_status(struct v4l2_subdev *sd, u32 *pstatus)\r\n{\r\nstruct saa7110 *decoder = to_saa7110(sd);\r\nint res = V4L2_IN_ST_NO_SIGNAL;\r\nint status = saa7110_read(sd);\r\nv4l2_dbg(1, debug, sd, "status=0x%02x norm=%llx\n",\r\nstatus, (unsigned long long)decoder->norm);\r\nif (!(status & 0x40))\r\nres = 0;\r\nif (!(status & 0x03))\r\nres |= V4L2_IN_ST_NO_COLOR;\r\n*pstatus = res;\r\nreturn 0;\r\n}\r\nstatic int saa7110_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\r\n{\r\n*std &= determine_norm(sd);\r\nreturn 0;\r\n}\r\nstatic int saa7110_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct saa7110 *decoder = to_saa7110(sd);\r\nif (decoder->norm != std) {\r\ndecoder->norm = std;\r\nif (std & V4L2_STD_NTSC) {\r\nsaa7110_write(sd, 0x0D, 0x86);\r\nsaa7110_write(sd, 0x0F, 0x50);\r\nsaa7110_write(sd, 0x11, 0x2C);\r\nv4l2_dbg(1, debug, sd, "switched to NTSC\n");\r\n} else if (std & V4L2_STD_PAL) {\r\nsaa7110_write(sd, 0x0D, 0x86);\r\nsaa7110_write(sd, 0x0F, 0x10);\r\nsaa7110_write(sd, 0x11, 0x59);\r\nv4l2_dbg(1, debug, sd, "switched to PAL\n");\r\n} else if (std & V4L2_STD_SECAM) {\r\nsaa7110_write(sd, 0x0D, 0x87);\r\nsaa7110_write(sd, 0x0F, 0x10);\r\nsaa7110_write(sd, 0x11, 0x59);\r\nv4l2_dbg(1, debug, sd, "switched to SECAM\n");\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7110_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct saa7110 *decoder = to_saa7110(sd);\r\nif (input >= SAA7110_MAX_INPUT) {\r\nv4l2_dbg(1, debug, sd, "input=%d not available\n", input);\r\nreturn -EINVAL;\r\n}\r\nif (decoder->input != input) {\r\nsaa7110_selmux(sd, input);\r\nv4l2_dbg(1, debug, sd, "switched to input=%d\n", input);\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7110_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct saa7110 *decoder = to_saa7110(sd);\r\nif (decoder->enable != enable) {\r\ndecoder->enable = enable;\r\nsaa7110_write(sd, 0x0E, enable ? 0x18 : 0x80);\r\nv4l2_dbg(1, debug, sd, "YUV %s\n", enable ? "on" : "off");\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7110_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsaa7110_write(sd, 0x19, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nsaa7110_write(sd, 0x13, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nsaa7110_write(sd, 0x12, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nsaa7110_write(sd, 0x07, ctrl->val);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7110_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct saa7110 *decoder;\r\nstruct v4l2_subdev *sd;\r\nint rv;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))\r\nreturn -ENODEV;\r\nv4l_info(client, "chip found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\ndecoder = devm_kzalloc(&client->dev, sizeof(*decoder), GFP_KERNEL);\r\nif (!decoder)\r\nreturn -ENOMEM;\r\nsd = &decoder->sd;\r\nv4l2_i2c_subdev_init(sd, client, &saa7110_ops);\r\ndecoder->norm = V4L2_STD_PAL;\r\ndecoder->input = 0;\r\ndecoder->enable = 1;\r\nv4l2_ctrl_handler_init(&decoder->hdl, 2);\r\nv4l2_ctrl_new_std(&decoder->hdl, &saa7110_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(&decoder->hdl, &saa7110_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 127, 1, 64);\r\nv4l2_ctrl_new_std(&decoder->hdl, &saa7110_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 127, 1, 64);\r\nv4l2_ctrl_new_std(&decoder->hdl, &saa7110_ctrl_ops,\r\nV4L2_CID_HUE, -128, 127, 1, 0);\r\nsd->ctrl_handler = &decoder->hdl;\r\nif (decoder->hdl.error) {\r\nint err = decoder->hdl.error;\r\nv4l2_ctrl_handler_free(&decoder->hdl);\r\nreturn err;\r\n}\r\nv4l2_ctrl_handler_setup(&decoder->hdl);\r\ninit_waitqueue_head(&decoder->wq);\r\nrv = saa7110_write_block(sd, initseq, sizeof(initseq));\r\nif (rv < 0) {\r\nv4l2_dbg(1, debug, sd, "init status %d\n", rv);\r\n} else {\r\nint ver, status;\r\nsaa7110_write(sd, 0x21, 0x10);\r\nsaa7110_write(sd, 0x0e, 0x18);\r\nsaa7110_write(sd, 0x0D, 0x04);\r\nver = saa7110_read(sd);\r\nsaa7110_write(sd, 0x0D, 0x06);\r\nstatus = saa7110_read(sd);\r\nv4l2_dbg(1, debug, sd, "version %x, status=0x%02x\n",\r\nver, status);\r\nsaa7110_write(sd, 0x0D, 0x86);\r\nsaa7110_write(sd, 0x0F, 0x10);\r\nsaa7110_write(sd, 0x11, 0x59);\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7110_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct saa7110 *decoder = to_saa7110(sd);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(&decoder->hdl);\r\nreturn 0;\r\n}
