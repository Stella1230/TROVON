static int\r\ndummy_input(struct snd_seq_event *ev, int direct, void *private_data,\r\nint atomic, int hop)\r\n{\r\nstruct snd_seq_dummy_port *p;\r\nstruct snd_seq_event tmpev;\r\np = private_data;\r\nif (ev->source.client == SNDRV_SEQ_CLIENT_SYSTEM ||\r\nev->type == SNDRV_SEQ_EVENT_KERNEL_ERROR)\r\nreturn 0;\r\ntmpev = *ev;\r\nif (p->duplex)\r\ntmpev.source.port = p->connect;\r\nelse\r\ntmpev.source.port = p->port;\r\ntmpev.dest.client = SNDRV_SEQ_ADDRESS_SUBSCRIBERS;\r\nreturn snd_seq_kernel_client_dispatch(p->client, &tmpev, atomic, hop);\r\n}\r\nstatic void\r\ndummy_free(void *private_data)\r\n{\r\nkfree(private_data);\r\n}\r\nstatic struct snd_seq_dummy_port __init *\r\ncreate_port(int idx, int type)\r\n{\r\nstruct snd_seq_port_info pinfo;\r\nstruct snd_seq_port_callback pcb;\r\nstruct snd_seq_dummy_port *rec;\r\nif ((rec = kzalloc(sizeof(*rec), GFP_KERNEL)) == NULL)\r\nreturn NULL;\r\nrec->client = my_client;\r\nrec->duplex = duplex;\r\nrec->connect = 0;\r\nmemset(&pinfo, 0, sizeof(pinfo));\r\npinfo.addr.client = my_client;\r\nif (duplex)\r\nsprintf(pinfo.name, "Midi Through Port-%d:%c", idx,\r\n(type ? 'B' : 'A'));\r\nelse\r\nsprintf(pinfo.name, "Midi Through Port-%d", idx);\r\npinfo.capability = SNDRV_SEQ_PORT_CAP_READ | SNDRV_SEQ_PORT_CAP_SUBS_READ;\r\npinfo.capability |= SNDRV_SEQ_PORT_CAP_WRITE | SNDRV_SEQ_PORT_CAP_SUBS_WRITE;\r\nif (duplex)\r\npinfo.capability |= SNDRV_SEQ_PORT_CAP_DUPLEX;\r\npinfo.type = SNDRV_SEQ_PORT_TYPE_MIDI_GENERIC\r\n| SNDRV_SEQ_PORT_TYPE_SOFTWARE\r\n| SNDRV_SEQ_PORT_TYPE_PORT;\r\nmemset(&pcb, 0, sizeof(pcb));\r\npcb.owner = THIS_MODULE;\r\npcb.event_input = dummy_input;\r\npcb.private_free = dummy_free;\r\npcb.private_data = rec;\r\npinfo.kernel = &pcb;\r\nif (snd_seq_kernel_client_ctl(my_client, SNDRV_SEQ_IOCTL_CREATE_PORT, &pinfo) < 0) {\r\nkfree(rec);\r\nreturn NULL;\r\n}\r\nrec->port = pinfo.addr.port;\r\nreturn rec;\r\n}\r\nstatic int __init\r\nregister_client(void)\r\n{\r\nstruct snd_seq_dummy_port *rec1, *rec2;\r\nint i;\r\nif (ports < 1) {\r\npr_err("ALSA: seq_dummy: invalid number of ports %d\n", ports);\r\nreturn -EINVAL;\r\n}\r\nmy_client = snd_seq_create_kernel_client(NULL, SNDRV_SEQ_CLIENT_DUMMY,\r\n"Midi Through");\r\nif (my_client < 0)\r\nreturn my_client;\r\nfor (i = 0; i < ports; i++) {\r\nrec1 = create_port(i, 0);\r\nif (rec1 == NULL) {\r\nsnd_seq_delete_kernel_client(my_client);\r\nreturn -ENOMEM;\r\n}\r\nif (duplex) {\r\nrec2 = create_port(i, 1);\r\nif (rec2 == NULL) {\r\nsnd_seq_delete_kernel_client(my_client);\r\nreturn -ENOMEM;\r\n}\r\nrec1->connect = rec2->port;\r\nrec2->connect = rec1->port;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit\r\ndelete_client(void)\r\n{\r\nif (my_client >= 0)\r\nsnd_seq_delete_kernel_client(my_client);\r\n}\r\nstatic int __init alsa_seq_dummy_init(void)\r\n{\r\nint err;\r\nsnd_seq_autoload_lock();\r\nerr = register_client();\r\nsnd_seq_autoload_unlock();\r\nreturn err;\r\n}\r\nstatic void __exit alsa_seq_dummy_exit(void)\r\n{\r\ndelete_client();\r\n}
