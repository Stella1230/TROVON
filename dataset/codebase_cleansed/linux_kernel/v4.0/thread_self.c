static int proc_thread_self_readlink(struct dentry *dentry, char __user *buffer,\r\nint buflen)\r\n{\r\nstruct pid_namespace *ns = dentry->d_sb->s_fs_info;\r\npid_t tgid = task_tgid_nr_ns(current, ns);\r\npid_t pid = task_pid_nr_ns(current, ns);\r\nchar tmp[PROC_NUMBUF + 6 + PROC_NUMBUF];\r\nif (!pid)\r\nreturn -ENOENT;\r\nsprintf(tmp, "%d/task/%d", tgid, pid);\r\nreturn readlink_copy(buffer, buflen, tmp);\r\n}\r\nstatic void *proc_thread_self_follow_link(struct dentry *dentry, struct nameidata *nd)\r\n{\r\nstruct pid_namespace *ns = dentry->d_sb->s_fs_info;\r\npid_t tgid = task_tgid_nr_ns(current, ns);\r\npid_t pid = task_pid_nr_ns(current, ns);\r\nchar *name = ERR_PTR(-ENOENT);\r\nif (pid) {\r\nname = kmalloc(PROC_NUMBUF + 6 + PROC_NUMBUF, GFP_KERNEL);\r\nif (!name)\r\nname = ERR_PTR(-ENOMEM);\r\nelse\r\nsprintf(name, "%d/task/%d", tgid, pid);\r\n}\r\nnd_set_link(nd, name);\r\nreturn NULL;\r\n}\r\nint proc_setup_thread_self(struct super_block *s)\r\n{\r\nstruct inode *root_inode = s->s_root->d_inode;\r\nstruct pid_namespace *ns = s->s_fs_info;\r\nstruct dentry *thread_self;\r\nmutex_lock(&root_inode->i_mutex);\r\nthread_self = d_alloc_name(s->s_root, "thread-self");\r\nif (thread_self) {\r\nstruct inode *inode = new_inode_pseudo(s);\r\nif (inode) {\r\ninode->i_ino = thread_self_inum;\r\ninode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\r\ninode->i_mode = S_IFLNK | S_IRWXUGO;\r\ninode->i_uid = GLOBAL_ROOT_UID;\r\ninode->i_gid = GLOBAL_ROOT_GID;\r\ninode->i_op = &proc_thread_self_inode_operations;\r\nd_add(thread_self, inode);\r\n} else {\r\ndput(thread_self);\r\nthread_self = ERR_PTR(-ENOMEM);\r\n}\r\n} else {\r\nthread_self = ERR_PTR(-ENOMEM);\r\n}\r\nmutex_unlock(&root_inode->i_mutex);\r\nif (IS_ERR(thread_self)) {\r\npr_err("proc_fill_super: can't allocate /proc/thread_self\n");\r\nreturn PTR_ERR(thread_self);\r\n}\r\nns->proc_thread_self = thread_self;\r\nreturn 0;\r\n}\r\nvoid __init proc_thread_self_init(void)\r\n{\r\nproc_alloc_inum(&thread_self_inum);\r\n}
