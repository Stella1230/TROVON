int sptlrpc_proc_enc_pool_seq_show(struct seq_file *m, void *v)\r\n{\r\nint rc;\r\nspin_lock(&page_pools.epp_lock);\r\nrc = seq_printf(m,\r\n"physical pages: %lu\n"\r\n"pages per pool: %lu\n"\r\n"max pages: %lu\n"\r\n"max pools: %u\n"\r\n"total pages: %lu\n"\r\n"total free: %lu\n"\r\n"idle index: %lu/100\n"\r\n"last shrink: %lds\n"\r\n"last access: %lds\n"\r\n"max pages reached: %lu\n"\r\n"grows: %u\n"\r\n"grows failure: %u\n"\r\n"shrinks: %u\n"\r\n"cache access: %lu\n"\r\n"cache missing: %lu\n"\r\n"low free mark: %lu\n"\r\n"max waitqueue depth: %u\n"\r\n"max wait time: "CFS_TIME_T"/%u\n"\r\n,\r\ntotalram_pages,\r\nPAGES_PER_POOL,\r\npage_pools.epp_max_pages,\r\npage_pools.epp_max_pools,\r\npage_pools.epp_total_pages,\r\npage_pools.epp_free_pages,\r\npage_pools.epp_idle_idx,\r\nget_seconds() - page_pools.epp_last_shrink,\r\nget_seconds() - page_pools.epp_last_access,\r\npage_pools.epp_st_max_pages,\r\npage_pools.epp_st_grows,\r\npage_pools.epp_st_grow_fails,\r\npage_pools.epp_st_shrinks,\r\npage_pools.epp_st_access,\r\npage_pools.epp_st_missings,\r\npage_pools.epp_st_lowfree,\r\npage_pools.epp_st_max_wqlen,\r\npage_pools.epp_st_max_wait, HZ\r\n);\r\nspin_unlock(&page_pools.epp_lock);\r\nreturn rc;\r\n}\r\nstatic void enc_pools_release_free_pages(long npages)\r\n{\r\nint p_idx, g_idx;\r\nint p_idx_max1, p_idx_max2;\r\nLASSERT(npages > 0);\r\nLASSERT(npages <= page_pools.epp_free_pages);\r\nLASSERT(page_pools.epp_free_pages <= page_pools.epp_total_pages);\r\np_idx_max2 = (page_pools.epp_total_pages - 1) / PAGES_PER_POOL;\r\npage_pools.epp_free_pages -= npages;\r\npage_pools.epp_total_pages -= npages;\r\np_idx_max1 = page_pools.epp_total_pages == 0 ? -1 :\r\n((page_pools.epp_total_pages - 1) / PAGES_PER_POOL);\r\np_idx = page_pools.epp_free_pages / PAGES_PER_POOL;\r\ng_idx = page_pools.epp_free_pages % PAGES_PER_POOL;\r\nLASSERT(page_pools.epp_pools[p_idx]);\r\nwhile (npages--) {\r\nLASSERT(page_pools.epp_pools[p_idx]);\r\nLASSERT(page_pools.epp_pools[p_idx][g_idx] != NULL);\r\n__free_page(page_pools.epp_pools[p_idx][g_idx]);\r\npage_pools.epp_pools[p_idx][g_idx] = NULL;\r\nif (++g_idx == PAGES_PER_POOL) {\r\np_idx++;\r\ng_idx = 0;\r\n}\r\n}\r\nwhile (p_idx_max1 < p_idx_max2) {\r\nLASSERT(page_pools.epp_pools[p_idx_max2]);\r\nOBD_FREE(page_pools.epp_pools[p_idx_max2], PAGE_CACHE_SIZE);\r\npage_pools.epp_pools[p_idx_max2] = NULL;\r\np_idx_max2--;\r\n}\r\n}\r\nstatic unsigned long enc_pools_shrink_count(struct shrinker *s,\r\nstruct shrink_control *sc)\r\n{\r\nif (unlikely(get_seconds() - page_pools.epp_last_access >\r\nCACHE_QUIESCENT_PERIOD)) {\r\nspin_lock(&page_pools.epp_lock);\r\npage_pools.epp_idle_idx = IDLE_IDX_MAX;\r\nspin_unlock(&page_pools.epp_lock);\r\n}\r\nLASSERT(page_pools.epp_idle_idx <= IDLE_IDX_MAX);\r\nreturn max((int)page_pools.epp_free_pages - PTLRPC_MAX_BRW_PAGES, 0) *\r\n(IDLE_IDX_MAX - page_pools.epp_idle_idx) / IDLE_IDX_MAX;\r\n}\r\nstatic unsigned long enc_pools_shrink_scan(struct shrinker *s,\r\nstruct shrink_control *sc)\r\n{\r\nspin_lock(&page_pools.epp_lock);\r\nsc->nr_to_scan = min_t(unsigned long, sc->nr_to_scan,\r\npage_pools.epp_free_pages - PTLRPC_MAX_BRW_PAGES);\r\nif (sc->nr_to_scan > 0) {\r\nenc_pools_release_free_pages(sc->nr_to_scan);\r\nCDEBUG(D_SEC, "released %ld pages, %ld left\n",\r\n(long)sc->nr_to_scan, page_pools.epp_free_pages);\r\npage_pools.epp_st_shrinks++;\r\npage_pools.epp_last_shrink = get_seconds();\r\n}\r\nspin_unlock(&page_pools.epp_lock);\r\nif (unlikely(get_seconds() - page_pools.epp_last_access >\r\nCACHE_QUIESCENT_PERIOD)) {\r\nspin_lock(&page_pools.epp_lock);\r\npage_pools.epp_idle_idx = IDLE_IDX_MAX;\r\nspin_unlock(&page_pools.epp_lock);\r\n}\r\nLASSERT(page_pools.epp_idle_idx <= IDLE_IDX_MAX);\r\nreturn sc->nr_to_scan;\r\n}\r\nstatic inline\r\nint npages_to_npools(unsigned long npages)\r\n{\r\nreturn (int) ((npages + PAGES_PER_POOL - 1) / PAGES_PER_POOL);\r\n}\r\nstatic unsigned long enc_pools_cleanup(struct page ***pools, int npools)\r\n{\r\nunsigned long cleaned = 0;\r\nint i, j;\r\nfor (i = 0; i < npools; i++) {\r\nif (pools[i]) {\r\nfor (j = 0; j < PAGES_PER_POOL; j++) {\r\nif (pools[i][j]) {\r\n__free_page(pools[i][j]);\r\ncleaned++;\r\n}\r\n}\r\nOBD_FREE(pools[i], PAGE_CACHE_SIZE);\r\npools[i] = NULL;\r\n}\r\n}\r\nreturn cleaned;\r\n}\r\nstatic void enc_pools_insert(struct page ***pools, int npools, int npages)\r\n{\r\nint freeslot;\r\nint op_idx, np_idx, og_idx, ng_idx;\r\nint cur_npools, end_npools;\r\nLASSERT(npages > 0);\r\nLASSERT(page_pools.epp_total_pages+npages <= page_pools.epp_max_pages);\r\nLASSERT(npages_to_npools(npages) == npools);\r\nLASSERT(page_pools.epp_growing);\r\nspin_lock(&page_pools.epp_lock);\r\nfreeslot = page_pools.epp_total_pages % PAGES_PER_POOL;\r\nif (freeslot != 0)\r\nfreeslot = PAGES_PER_POOL - freeslot;\r\nfreeslot += page_pools.epp_total_pages - page_pools.epp_free_pages;\r\nop_idx = page_pools.epp_free_pages / PAGES_PER_POOL;\r\nog_idx = page_pools.epp_free_pages % PAGES_PER_POOL;\r\nnp_idx = npools - 1;\r\nng_idx = (npages - 1) % PAGES_PER_POOL;\r\nwhile (freeslot) {\r\nLASSERT(page_pools.epp_pools[op_idx][og_idx] == NULL);\r\nLASSERT(pools[np_idx][ng_idx] != NULL);\r\npage_pools.epp_pools[op_idx][og_idx] = pools[np_idx][ng_idx];\r\npools[np_idx][ng_idx] = NULL;\r\nfreeslot--;\r\nif (++og_idx == PAGES_PER_POOL) {\r\nop_idx++;\r\nog_idx = 0;\r\n}\r\nif (--ng_idx < 0) {\r\nif (np_idx == 0)\r\nbreak;\r\nnp_idx--;\r\nng_idx = PAGES_PER_POOL - 1;\r\n}\r\n}\r\ncur_npools = (page_pools.epp_total_pages + PAGES_PER_POOL - 1) /\r\nPAGES_PER_POOL;\r\nend_npools = (page_pools.epp_total_pages + npages + PAGES_PER_POOL - 1) /\r\nPAGES_PER_POOL;\r\nLASSERT(end_npools <= page_pools.epp_max_pools);\r\nnp_idx = 0;\r\nwhile (cur_npools < end_npools) {\r\nLASSERT(page_pools.epp_pools[cur_npools] == NULL);\r\nLASSERT(np_idx < npools);\r\nLASSERT(pools[np_idx] != NULL);\r\npage_pools.epp_pools[cur_npools++] = pools[np_idx];\r\npools[np_idx++] = NULL;\r\n}\r\npage_pools.epp_total_pages += npages;\r\npage_pools.epp_free_pages += npages;\r\npage_pools.epp_st_lowfree = page_pools.epp_free_pages;\r\nif (page_pools.epp_total_pages > page_pools.epp_st_max_pages)\r\npage_pools.epp_st_max_pages = page_pools.epp_total_pages;\r\nCDEBUG(D_SEC, "add %d pages to total %lu\n", npages,\r\npage_pools.epp_total_pages);\r\nspin_unlock(&page_pools.epp_lock);\r\n}\r\nstatic int enc_pools_add_pages(int npages)\r\n{\r\nstatic DEFINE_MUTEX(add_pages_mutex);\r\nstruct page ***pools;\r\nint npools, alloced = 0;\r\nint i, j, rc = -ENOMEM;\r\nif (npages < PTLRPC_MAX_BRW_PAGES)\r\nnpages = PTLRPC_MAX_BRW_PAGES;\r\nmutex_lock(&add_pages_mutex);\r\nif (npages + page_pools.epp_total_pages > page_pools.epp_max_pages)\r\nnpages = page_pools.epp_max_pages - page_pools.epp_total_pages;\r\nLASSERT(npages > 0);\r\npage_pools.epp_st_grows++;\r\nnpools = npages_to_npools(npages);\r\nOBD_ALLOC(pools, npools * sizeof(*pools));\r\nif (pools == NULL)\r\ngoto out;\r\nfor (i = 0; i < npools; i++) {\r\nOBD_ALLOC(pools[i], PAGE_CACHE_SIZE);\r\nif (pools[i] == NULL)\r\ngoto out_pools;\r\nfor (j = 0; j < PAGES_PER_POOL && alloced < npages; j++) {\r\npools[i][j] = alloc_page(GFP_NOFS |\r\n__GFP_HIGHMEM);\r\nif (pools[i][j] == NULL)\r\ngoto out_pools;\r\nalloced++;\r\n}\r\n}\r\nLASSERT(alloced == npages);\r\nenc_pools_insert(pools, npools, npages);\r\nCDEBUG(D_SEC, "added %d pages into pools\n", npages);\r\nrc = 0;\r\nout_pools:\r\nenc_pools_cleanup(pools, npools);\r\nOBD_FREE(pools, npools * sizeof(*pools));\r\nout:\r\nif (rc) {\r\npage_pools.epp_st_grow_fails++;\r\nCERROR("Failed to allocate %d enc pages\n", npages);\r\n}\r\nmutex_unlock(&add_pages_mutex);\r\nreturn rc;\r\n}\r\nstatic inline void enc_pools_wakeup(void)\r\n{\r\nassert_spin_locked(&page_pools.epp_lock);\r\nLASSERT(page_pools.epp_waitqlen >= 0);\r\nif (unlikely(page_pools.epp_waitqlen)) {\r\nLASSERT(waitqueue_active(&page_pools.epp_waitq));\r\nwake_up_all(&page_pools.epp_waitq);\r\n}\r\n}\r\nstatic int enc_pools_should_grow(int page_needed, long now)\r\n{\r\nif (page_pools.epp_growing ||\r\npage_pools.epp_total_pages == page_pools.epp_max_pages)\r\nreturn 0;\r\nif (page_pools.epp_total_pages < page_needed)\r\nreturn 1;\r\n#if 0\r\nif (now - page_pools.epp_last_shrink < 2)\r\nreturn 0;\r\n#endif\r\nreturn 1;\r\n}\r\nint sptlrpc_enc_pool_get_pages(struct ptlrpc_bulk_desc *desc)\r\n{\r\nwait_queue_t waitlink;\r\nunsigned long this_idle = -1;\r\nunsigned long tick = 0;\r\nlong now;\r\nint p_idx, g_idx;\r\nint i;\r\nLASSERT(desc->bd_iov_count > 0);\r\nLASSERT(desc->bd_iov_count <= page_pools.epp_max_pages);\r\nif (desc->bd_enc_iov != NULL)\r\nreturn 0;\r\nOBD_ALLOC(desc->bd_enc_iov,\r\ndesc->bd_iov_count * sizeof(*desc->bd_enc_iov));\r\nif (desc->bd_enc_iov == NULL)\r\nreturn -ENOMEM;\r\nspin_lock(&page_pools.epp_lock);\r\npage_pools.epp_st_access++;\r\nagain:\r\nif (unlikely(page_pools.epp_free_pages < desc->bd_iov_count)) {\r\nif (tick == 0)\r\ntick = cfs_time_current();\r\nnow = get_seconds();\r\npage_pools.epp_st_missings++;\r\npage_pools.epp_pages_short += desc->bd_iov_count;\r\nif (enc_pools_should_grow(desc->bd_iov_count, now)) {\r\npage_pools.epp_growing = 1;\r\nspin_unlock(&page_pools.epp_lock);\r\nenc_pools_add_pages(page_pools.epp_pages_short / 2);\r\nspin_lock(&page_pools.epp_lock);\r\npage_pools.epp_growing = 0;\r\nenc_pools_wakeup();\r\n} else {\r\nif (++page_pools.epp_waitqlen >\r\npage_pools.epp_st_max_wqlen)\r\npage_pools.epp_st_max_wqlen =\r\npage_pools.epp_waitqlen;\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\ninit_waitqueue_entry(&waitlink, current);\r\nadd_wait_queue(&page_pools.epp_waitq, &waitlink);\r\nspin_unlock(&page_pools.epp_lock);\r\nschedule();\r\nremove_wait_queue(&page_pools.epp_waitq, &waitlink);\r\nLASSERT(page_pools.epp_waitqlen > 0);\r\nspin_lock(&page_pools.epp_lock);\r\npage_pools.epp_waitqlen--;\r\n}\r\nLASSERT(page_pools.epp_pages_short >= desc->bd_iov_count);\r\npage_pools.epp_pages_short -= desc->bd_iov_count;\r\nthis_idle = 0;\r\ngoto again;\r\n}\r\nif (unlikely(tick != 0)) {\r\ntick = cfs_time_current() - tick;\r\nif (tick > page_pools.epp_st_max_wait)\r\npage_pools.epp_st_max_wait = tick;\r\n}\r\npage_pools.epp_free_pages -= desc->bd_iov_count;\r\np_idx = page_pools.epp_free_pages / PAGES_PER_POOL;\r\ng_idx = page_pools.epp_free_pages % PAGES_PER_POOL;\r\nfor (i = 0; i < desc->bd_iov_count; i++) {\r\nLASSERT(page_pools.epp_pools[p_idx][g_idx] != NULL);\r\ndesc->bd_enc_iov[i].kiov_page =\r\npage_pools.epp_pools[p_idx][g_idx];\r\npage_pools.epp_pools[p_idx][g_idx] = NULL;\r\nif (++g_idx == PAGES_PER_POOL) {\r\np_idx++;\r\ng_idx = 0;\r\n}\r\n}\r\nif (page_pools.epp_free_pages < page_pools.epp_st_lowfree)\r\npage_pools.epp_st_lowfree = page_pools.epp_free_pages;\r\nif (this_idle == -1) {\r\nthis_idle = page_pools.epp_free_pages * IDLE_IDX_MAX /\r\npage_pools.epp_total_pages;\r\n}\r\npage_pools.epp_idle_idx = (page_pools.epp_idle_idx * IDLE_IDX_WEIGHT +\r\nthis_idle) /\r\n(IDLE_IDX_WEIGHT + 1);\r\npage_pools.epp_last_access = get_seconds();\r\nspin_unlock(&page_pools.epp_lock);\r\nreturn 0;\r\n}\r\nvoid sptlrpc_enc_pool_put_pages(struct ptlrpc_bulk_desc *desc)\r\n{\r\nint p_idx, g_idx;\r\nint i;\r\nif (desc->bd_enc_iov == NULL)\r\nreturn;\r\nLASSERT(desc->bd_iov_count > 0);\r\nspin_lock(&page_pools.epp_lock);\r\np_idx = page_pools.epp_free_pages / PAGES_PER_POOL;\r\ng_idx = page_pools.epp_free_pages % PAGES_PER_POOL;\r\nLASSERT(page_pools.epp_free_pages + desc->bd_iov_count <=\r\npage_pools.epp_total_pages);\r\nLASSERT(page_pools.epp_pools[p_idx]);\r\nfor (i = 0; i < desc->bd_iov_count; i++) {\r\nLASSERT(desc->bd_enc_iov[i].kiov_page != NULL);\r\nLASSERT(g_idx != 0 || page_pools.epp_pools[p_idx]);\r\nLASSERT(page_pools.epp_pools[p_idx][g_idx] == NULL);\r\npage_pools.epp_pools[p_idx][g_idx] =\r\ndesc->bd_enc_iov[i].kiov_page;\r\nif (++g_idx == PAGES_PER_POOL) {\r\np_idx++;\r\ng_idx = 0;\r\n}\r\n}\r\npage_pools.epp_free_pages += desc->bd_iov_count;\r\nenc_pools_wakeup();\r\nspin_unlock(&page_pools.epp_lock);\r\nOBD_FREE(desc->bd_enc_iov,\r\ndesc->bd_iov_count * sizeof(*desc->bd_enc_iov));\r\ndesc->bd_enc_iov = NULL;\r\n}\r\nint sptlrpc_enc_pool_add_user(void)\r\n{\r\nint need_grow = 0;\r\nspin_lock(&page_pools.epp_lock);\r\nif (page_pools.epp_growing == 0 && page_pools.epp_total_pages == 0) {\r\npage_pools.epp_growing = 1;\r\nneed_grow = 1;\r\n}\r\nspin_unlock(&page_pools.epp_lock);\r\nif (need_grow) {\r\nenc_pools_add_pages(PTLRPC_MAX_BRW_PAGES +\r\nPTLRPC_MAX_BRW_PAGES);\r\nspin_lock(&page_pools.epp_lock);\r\npage_pools.epp_growing = 0;\r\nenc_pools_wakeup();\r\nspin_unlock(&page_pools.epp_lock);\r\n}\r\nreturn 0;\r\n}\r\nint sptlrpc_enc_pool_del_user(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void enc_pools_alloc(void)\r\n{\r\nLASSERT(page_pools.epp_max_pools);\r\nOBD_ALLOC_LARGE(page_pools.epp_pools,\r\npage_pools.epp_max_pools *\r\nsizeof(*page_pools.epp_pools));\r\n}\r\nstatic inline void enc_pools_free(void)\r\n{\r\nLASSERT(page_pools.epp_max_pools);\r\nLASSERT(page_pools.epp_pools);\r\nOBD_FREE_LARGE(page_pools.epp_pools,\r\npage_pools.epp_max_pools *\r\nsizeof(*page_pools.epp_pools));\r\n}\r\nint sptlrpc_enc_pool_init(void)\r\n{\r\npage_pools.epp_max_pages = totalram_pages / 8;\r\npage_pools.epp_max_pools = npages_to_npools(page_pools.epp_max_pages);\r\ninit_waitqueue_head(&page_pools.epp_waitq);\r\npage_pools.epp_waitqlen = 0;\r\npage_pools.epp_pages_short = 0;\r\npage_pools.epp_growing = 0;\r\npage_pools.epp_idle_idx = 0;\r\npage_pools.epp_last_shrink = get_seconds();\r\npage_pools.epp_last_access = get_seconds();\r\nspin_lock_init(&page_pools.epp_lock);\r\npage_pools.epp_total_pages = 0;\r\npage_pools.epp_free_pages = 0;\r\npage_pools.epp_st_max_pages = 0;\r\npage_pools.epp_st_grows = 0;\r\npage_pools.epp_st_grow_fails = 0;\r\npage_pools.epp_st_shrinks = 0;\r\npage_pools.epp_st_access = 0;\r\npage_pools.epp_st_missings = 0;\r\npage_pools.epp_st_lowfree = 0;\r\npage_pools.epp_st_max_wqlen = 0;\r\npage_pools.epp_st_max_wait = 0;\r\nenc_pools_alloc();\r\nif (page_pools.epp_pools == NULL)\r\nreturn -ENOMEM;\r\nregister_shrinker(&pools_shrinker);\r\nreturn 0;\r\n}\r\nvoid sptlrpc_enc_pool_fini(void)\r\n{\r\nunsigned long cleaned, npools;\r\nLASSERT(page_pools.epp_pools);\r\nLASSERT(page_pools.epp_total_pages == page_pools.epp_free_pages);\r\nunregister_shrinker(&pools_shrinker);\r\nnpools = npages_to_npools(page_pools.epp_total_pages);\r\ncleaned = enc_pools_cleanup(page_pools.epp_pools, npools);\r\nLASSERT(cleaned == page_pools.epp_total_pages);\r\nenc_pools_free();\r\nif (page_pools.epp_st_access > 0) {\r\nCDEBUG(D_SEC,\r\n"max pages %lu, grows %u, grow fails %u, shrinks %u, access %lu, missing %lu, max qlen %u, max wait "\r\nCFS_TIME_T"/%d\n",\r\npage_pools.epp_st_max_pages, page_pools.epp_st_grows,\r\npage_pools.epp_st_grow_fails,\r\npage_pools.epp_st_shrinks, page_pools.epp_st_access,\r\npage_pools.epp_st_missings, page_pools.epp_st_max_wqlen,\r\npage_pools.epp_st_max_wait, HZ);\r\n}\r\n}\r\nconst char *sptlrpc_get_hash_name(__u8 hash_alg)\r\n{\r\nreturn cfs_crypto_hash_name(cfs_hash_alg_id[hash_alg]);\r\n}\r\n__u8 sptlrpc_get_hash_alg(const char *algname)\r\n{\r\nreturn cfs_crypto_hash_alg(algname);\r\n}\r\nint bulk_sec_desc_unpack(struct lustre_msg *msg, int offset, int swabbed)\r\n{\r\nstruct ptlrpc_bulk_sec_desc *bsd;\r\nint size = msg->lm_buflens[offset];\r\nbsd = lustre_msg_buf(msg, offset, sizeof(*bsd));\r\nif (bsd == NULL) {\r\nCERROR("Invalid bulk sec desc: size %d\n", size);\r\nreturn -EINVAL;\r\n}\r\nif (swabbed) {\r\n__swab32s(&bsd->bsd_nob);\r\n}\r\nif (unlikely(bsd->bsd_version != 0)) {\r\nCERROR("Unexpected version %u\n", bsd->bsd_version);\r\nreturn -EPROTO;\r\n}\r\nif (unlikely(bsd->bsd_type >= SPTLRPC_BULK_MAX)) {\r\nCERROR("Invalid type %u\n", bsd->bsd_type);\r\nreturn -EPROTO;\r\n}\r\nif (unlikely(bsd->bsd_svc != SPTLRPC_BULK_SVC_NULL &&\r\nbsd->bsd_svc != SPTLRPC_BULK_SVC_INTG &&\r\nbsd->bsd_svc != SPTLRPC_BULK_SVC_PRIV)) {\r\nCERROR("Invalid svc %u\n", bsd->bsd_svc);\r\nreturn -EPROTO;\r\n}\r\nreturn 0;\r\n}\r\nint sptlrpc_get_bulk_checksum(struct ptlrpc_bulk_desc *desc, __u8 alg,\r\nvoid *buf, int buflen)\r\n{\r\nstruct cfs_crypto_hash_desc *hdesc;\r\nint hashsize;\r\nchar hashbuf[64];\r\nunsigned int bufsize;\r\nint i, err;\r\nLASSERT(alg > BULK_HASH_ALG_NULL && alg < BULK_HASH_ALG_MAX);\r\nLASSERT(buflen >= 4);\r\nhdesc = cfs_crypto_hash_init(cfs_hash_alg_id[alg], NULL, 0);\r\nif (IS_ERR(hdesc)) {\r\nCERROR("Unable to initialize checksum hash %s\n",\r\ncfs_crypto_hash_name(cfs_hash_alg_id[alg]));\r\nreturn PTR_ERR(hdesc);\r\n}\r\nhashsize = cfs_crypto_hash_digestsize(cfs_hash_alg_id[alg]);\r\nfor (i = 0; i < desc->bd_iov_count; i++) {\r\ncfs_crypto_hash_update_page(hdesc, desc->bd_iov[i].kiov_page,\r\ndesc->bd_iov[i].kiov_offset & ~CFS_PAGE_MASK,\r\ndesc->bd_iov[i].kiov_len);\r\n}\r\nif (hashsize > buflen) {\r\nbufsize = sizeof(hashbuf);\r\nerr = cfs_crypto_hash_final(hdesc, (unsigned char *)hashbuf,\r\n&bufsize);\r\nmemcpy(buf, hashbuf, buflen);\r\n} else {\r\nbufsize = buflen;\r\nerr = cfs_crypto_hash_final(hdesc, (unsigned char *)buf,\r\n&bufsize);\r\n}\r\nif (err)\r\ncfs_crypto_hash_final(hdesc, NULL, NULL);\r\nreturn err;\r\n}
