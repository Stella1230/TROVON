static inline struct l2tp_ip_sock *l2tp_ip_sk(const struct sock *sk)\r\n{\r\nreturn (struct l2tp_ip_sock *)sk;\r\n}\r\nstatic struct sock *__l2tp_ip_bind_lookup(struct net *net, __be32 laddr, int dif, u32 tunnel_id)\r\n{\r\nstruct sock *sk;\r\nsk_for_each_bound(sk, &l2tp_ip_bind_table) {\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct l2tp_ip_sock *l2tp = l2tp_ip_sk(sk);\r\nif (l2tp == NULL)\r\ncontinue;\r\nif ((l2tp->conn_id == tunnel_id) &&\r\nnet_eq(sock_net(sk), net) &&\r\n!(inet->inet_rcv_saddr && inet->inet_rcv_saddr != laddr) &&\r\n!(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))\r\ngoto found;\r\n}\r\nsk = NULL;\r\nfound:\r\nreturn sk;\r\n}\r\nstatic inline struct sock *l2tp_ip_bind_lookup(struct net *net, __be32 laddr, int dif, u32 tunnel_id)\r\n{\r\nstruct sock *sk = __l2tp_ip_bind_lookup(net, laddr, dif, tunnel_id);\r\nif (sk)\r\nsock_hold(sk);\r\nreturn sk;\r\n}\r\nstatic int l2tp_ip_recv(struct sk_buff *skb)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\nstruct sock *sk;\r\nu32 session_id;\r\nu32 tunnel_id;\r\nunsigned char *ptr, *optr;\r\nstruct l2tp_session *session;\r\nstruct l2tp_tunnel *tunnel = NULL;\r\nint length;\r\noptr = ptr = skb->data;\r\nif (!pskb_may_pull(skb, 4))\r\ngoto discard;\r\nsession_id = ntohl(*((__be32 *) ptr));\r\nptr += 4;\r\nif (session_id == 0) {\r\n__skb_pull(skb, 4);\r\ngoto pass_up;\r\n}\r\nsession = l2tp_session_find(net, NULL, session_id);\r\nif (session == NULL)\r\ngoto discard;\r\ntunnel = session->tunnel;\r\nif (tunnel == NULL)\r\ngoto discard;\r\nif (tunnel->debug & L2TP_MSG_DATA) {\r\nlength = min(32u, skb->len);\r\nif (!pskb_may_pull(skb, length))\r\ngoto discard;\r\npr_debug("%s: ip recv\n", tunnel->name);\r\nprint_hex_dump_bytes("", DUMP_PREFIX_OFFSET, ptr, length);\r\n}\r\nl2tp_recv_common(session, skb, ptr, optr, 0, skb->len, tunnel->recv_payload_hook);\r\nreturn 0;\r\npass_up:\r\nif (!pskb_may_pull(skb, 12))\r\ngoto discard;\r\nif ((skb->data[0] & 0xc0) != 0xc0)\r\ngoto discard;\r\ntunnel_id = ntohl(*(__be32 *) &skb->data[4]);\r\ntunnel = l2tp_tunnel_find(net, tunnel_id);\r\nif (tunnel != NULL)\r\nsk = tunnel->sock;\r\nelse {\r\nstruct iphdr *iph = (struct iphdr *) skb_network_header(skb);\r\nread_lock_bh(&l2tp_ip_lock);\r\nsk = __l2tp_ip_bind_lookup(net, iph->daddr, 0, tunnel_id);\r\nread_unlock_bh(&l2tp_ip_lock);\r\n}\r\nif (sk == NULL)\r\ngoto discard;\r\nsock_hold(sk);\r\nif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))\r\ngoto discard_put;\r\nnf_reset(skb);\r\nreturn sk_receive_skb(sk, skb, 1);\r\ndiscard_put:\r\nsock_put(sk);\r\ndiscard:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int l2tp_ip_open(struct sock *sk)\r\n{\r\ninet_sk(sk)->inet_num = IPPROTO_L2TP;\r\nwrite_lock_bh(&l2tp_ip_lock);\r\nsk_add_node(sk, &l2tp_ip_table);\r\nwrite_unlock_bh(&l2tp_ip_lock);\r\nreturn 0;\r\n}\r\nstatic void l2tp_ip_close(struct sock *sk, long timeout)\r\n{\r\nwrite_lock_bh(&l2tp_ip_lock);\r\nhlist_del_init(&sk->sk_bind_node);\r\nsk_del_node_init(sk);\r\nwrite_unlock_bh(&l2tp_ip_lock);\r\nsk_common_release(sk);\r\n}\r\nstatic void l2tp_ip_destroy_sock(struct sock *sk)\r\n{\r\nstruct sk_buff *skb;\r\nstruct l2tp_tunnel *tunnel = l2tp_sock_to_tunnel(sk);\r\nwhile ((skb = __skb_dequeue_tail(&sk->sk_write_queue)) != NULL)\r\nkfree_skb(skb);\r\nif (tunnel) {\r\nl2tp_tunnel_closeall(tunnel);\r\nsock_put(sk);\r\n}\r\nsk_refcnt_debug_dec(sk);\r\n}\r\nstatic int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;\r\nstruct net *net = sock_net(sk);\r\nint ret;\r\nint chk_addr_ret;\r\nif (!sock_flag(sk, SOCK_ZAPPED))\r\nreturn -EINVAL;\r\nif (addr_len < sizeof(struct sockaddr_l2tpip))\r\nreturn -EINVAL;\r\nif (addr->l2tp_family != AF_INET)\r\nreturn -EINVAL;\r\nret = -EADDRINUSE;\r\nread_lock_bh(&l2tp_ip_lock);\r\nif (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,\r\nsk->sk_bound_dev_if, addr->l2tp_conn_id))\r\ngoto out_in_use;\r\nread_unlock_bh(&l2tp_ip_lock);\r\nlock_sock(sk);\r\nif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\r\ngoto out;\r\nchk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);\r\nret = -EADDRNOTAVAIL;\r\nif (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\r\nchk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\r\ngoto out;\r\nif (addr->l2tp_addr.s_addr)\r\ninet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;\r\nif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\r\ninet->inet_saddr = 0;\r\nsk_dst_reset(sk);\r\nl2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;\r\nwrite_lock_bh(&l2tp_ip_lock);\r\nsk_add_bind_node(sk, &l2tp_ip_bind_table);\r\nsk_del_node_init(sk);\r\nwrite_unlock_bh(&l2tp_ip_lock);\r\nret = 0;\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nout:\r\nrelease_sock(sk);\r\nreturn ret;\r\nout_in_use:\r\nread_unlock_bh(&l2tp_ip_lock);\r\nreturn ret;\r\n}\r\nstatic int l2tp_ip_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct sockaddr_l2tpip *lsa = (struct sockaddr_l2tpip *) uaddr;\r\nint rc;\r\nif (sock_flag(sk, SOCK_ZAPPED))\r\nreturn -EINVAL;\r\nif (addr_len < sizeof(*lsa))\r\nreturn -EINVAL;\r\nif (ipv4_is_multicast(lsa->l2tp_addr.s_addr))\r\nreturn -EINVAL;\r\nrc = ip4_datagram_connect(sk, uaddr, addr_len);\r\nif (rc < 0)\r\nreturn rc;\r\nlock_sock(sk);\r\nl2tp_ip_sk(sk)->peer_conn_id = lsa->l2tp_conn_id;\r\nwrite_lock_bh(&l2tp_ip_lock);\r\nhlist_del_init(&sk->sk_bind_node);\r\nsk_add_bind_node(sk, &l2tp_ip_bind_table);\r\nwrite_unlock_bh(&l2tp_ip_lock);\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int l2tp_ip_disconnect(struct sock *sk, int flags)\r\n{\r\nif (sock_flag(sk, SOCK_ZAPPED))\r\nreturn 0;\r\nreturn udp_disconnect(sk, flags);\r\n}\r\nstatic int l2tp_ip_getname(struct socket *sock, struct sockaddr *uaddr,\r\nint *uaddr_len, int peer)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct l2tp_ip_sock *lsk = l2tp_ip_sk(sk);\r\nstruct sockaddr_l2tpip *lsa = (struct sockaddr_l2tpip *)uaddr;\r\nmemset(lsa, 0, sizeof(*lsa));\r\nlsa->l2tp_family = AF_INET;\r\nif (peer) {\r\nif (!inet->inet_dport)\r\nreturn -ENOTCONN;\r\nlsa->l2tp_conn_id = lsk->peer_conn_id;\r\nlsa->l2tp_addr.s_addr = inet->inet_daddr;\r\n} else {\r\n__be32 addr = inet->inet_rcv_saddr;\r\nif (!addr)\r\naddr = inet->inet_saddr;\r\nlsa->l2tp_conn_id = lsk->conn_id;\r\nlsa->l2tp_addr.s_addr = addr;\r\n}\r\n*uaddr_len = sizeof(*lsa);\r\nreturn 0;\r\n}\r\nstatic int l2tp_ip_backlog_recv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nint rc;\r\nrc = sock_queue_rcv_skb(sk, skb);\r\nif (rc < 0)\r\ngoto drop;\r\nreturn 0;\r\ndrop:\r\nIP_INC_STATS(sock_net(sk), IPSTATS_MIB_INDISCARDS);\r\nkfree_skb(skb);\r\nreturn -1;\r\n}\r\nstatic int l2tp_ip_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg, size_t len)\r\n{\r\nstruct sk_buff *skb;\r\nint rc;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct rtable *rt = NULL;\r\nstruct flowi4 *fl4;\r\nint connected = 0;\r\n__be32 daddr;\r\nlock_sock(sk);\r\nrc = -ENOTCONN;\r\nif (sock_flag(sk, SOCK_DEAD))\r\ngoto out;\r\nif (msg->msg_name) {\r\nDECLARE_SOCKADDR(struct sockaddr_l2tpip *, lip, msg->msg_name);\r\nrc = -EINVAL;\r\nif (msg->msg_namelen < sizeof(*lip))\r\ngoto out;\r\nif (lip->l2tp_family != AF_INET) {\r\nrc = -EAFNOSUPPORT;\r\nif (lip->l2tp_family != AF_UNSPEC)\r\ngoto out;\r\n}\r\ndaddr = lip->l2tp_addr.s_addr;\r\n} else {\r\nrc = -EDESTADDRREQ;\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\ngoto out;\r\ndaddr = inet->inet_daddr;\r\nconnected = 1;\r\n}\r\nrc = -ENOMEM;\r\nskb = sock_wmalloc(sk, 2 + NET_SKB_PAD + sizeof(struct iphdr) +\r\n4 + len, 0, GFP_KERNEL);\r\nif (!skb)\r\ngoto error;\r\nskb_reserve(skb, 2 + NET_SKB_PAD);\r\nskb_reset_network_header(skb);\r\nskb_reserve(skb, sizeof(struct iphdr));\r\nskb_reset_transport_header(skb);\r\n*((__be32 *) skb_put(skb, 4)) = 0;\r\nrc = memcpy_from_msg(skb_put(skb, len), msg, len);\r\nif (rc < 0) {\r\nkfree_skb(skb);\r\ngoto error;\r\n}\r\nfl4 = &inet->cork.fl.u.ip4;\r\nif (connected)\r\nrt = (struct rtable *) __sk_dst_check(sk, 0);\r\nrcu_read_lock();\r\nif (rt == NULL) {\r\nconst struct ip_options_rcu *inet_opt;\r\ninet_opt = rcu_dereference(inet->inet_opt);\r\nif (inet_opt && inet_opt->opt.srr)\r\ndaddr = inet_opt->opt.faddr;\r\nrt = ip_route_output_ports(sock_net(sk), fl4, sk,\r\ndaddr, inet->inet_saddr,\r\ninet->inet_dport, inet->inet_sport,\r\nsk->sk_protocol, RT_CONN_FLAGS(sk),\r\nsk->sk_bound_dev_if);\r\nif (IS_ERR(rt))\r\ngoto no_route;\r\nif (connected) {\r\nsk_setup_caps(sk, &rt->dst);\r\n} else {\r\nskb_dst_set(skb, &rt->dst);\r\ngoto xmit;\r\n}\r\n}\r\nskb_dst_set_noref(skb, &rt->dst);\r\nxmit:\r\nrc = ip_queue_xmit(sk, skb, &inet->cork.fl);\r\nrcu_read_unlock();\r\nerror:\r\nif (rc >= 0)\r\nrc = len;\r\nout:\r\nrelease_sock(sk);\r\nreturn rc;\r\nno_route:\r\nrcu_read_unlock();\r\nIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);\r\nkfree_skb(skb);\r\nrc = -EHOSTUNREACH;\r\ngoto out;\r\n}\r\nstatic int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\r\nsize_t len, int noblock, int flags, int *addr_len)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nsize_t copied = 0;\r\nint err = -EOPNOTSUPP;\r\nDECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);\r\nstruct sk_buff *skb;\r\nif (flags & MSG_OOB)\r\ngoto out;\r\nskb = skb_recv_datagram(sk, flags, noblock, &err);\r\nif (!skb)\r\ngoto out;\r\ncopied = skb->len;\r\nif (len < copied) {\r\nmsg->msg_flags |= MSG_TRUNC;\r\ncopied = len;\r\n}\r\nerr = skb_copy_datagram_msg(skb, 0, msg, copied);\r\nif (err)\r\ngoto done;\r\nsock_recv_timestamp(msg, sk, skb);\r\nif (sin) {\r\nsin->sin_family = AF_INET;\r\nsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\r\nsin->sin_port = 0;\r\nmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\r\n*addr_len = sizeof(*sin);\r\n}\r\nif (inet->cmsg_flags)\r\nip_cmsg_recv(msg, skb);\r\nif (flags & MSG_TRUNC)\r\ncopied = skb->len;\r\ndone:\r\nskb_free_datagram(sk, skb);\r\nout:\r\nreturn err ? err : copied;\r\n}\r\nstatic int __init l2tp_ip_init(void)\r\n{\r\nint err;\r\npr_info("L2TP IP encapsulation support (L2TPv3)\n");\r\nerr = proto_register(&l2tp_ip_prot, 1);\r\nif (err != 0)\r\ngoto out;\r\nerr = inet_add_protocol(&l2tp_ip_protocol, IPPROTO_L2TP);\r\nif (err)\r\ngoto out1;\r\ninet_register_protosw(&l2tp_ip_protosw);\r\nreturn 0;\r\nout1:\r\nproto_unregister(&l2tp_ip_prot);\r\nout:\r\nreturn err;\r\n}\r\nstatic void __exit l2tp_ip_exit(void)\r\n{\r\ninet_unregister_protosw(&l2tp_ip_protosw);\r\ninet_del_protocol(&l2tp_ip_protocol, IPPROTO_L2TP);\r\nproto_unregister(&l2tp_ip_prot);\r\n}
