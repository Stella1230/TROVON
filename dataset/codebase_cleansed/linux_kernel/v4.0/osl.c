static u32 acpi_osi_handler(acpi_string interface, u32 supported)\r\n{\r\nif (!strcmp("Linux", interface)) {\r\nprintk_once(KERN_NOTICE FW_BUG PREFIX\r\n"BIOS _OSI(Linux) query %s%s\n",\r\nosi_linux.enable ? "honored" : "ignored",\r\nosi_linux.cmdline ? " via cmdline" :\r\nosi_linux.dmi ? " via DMI" : "");\r\n}\r\nif (!strcmp("Darwin", interface)) {\r\nacpi_update_interfaces(ACPI_DISABLE_ALL_VENDOR_STRINGS);\r\nsupported = ACPI_UINT32_MAX;\r\n}\r\nreturn supported;\r\n}\r\nstatic void __init acpi_request_region (struct acpi_generic_address *gas,\r\nunsigned int length, char *desc)\r\n{\r\nu64 addr;\r\nmemcpy(&addr, &gas->address, sizeof(addr));\r\nif (!addr || !length)\r\nreturn;\r\nif (gas->space_id == ACPI_ADR_SPACE_SYSTEM_IO)\r\nrequest_region(addr, length, desc);\r\nelse if (gas->space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)\r\nrequest_mem_region(addr, length, desc);\r\n}\r\nstatic int __init acpi_reserve_resources(void)\r\n{\r\nacpi_request_region(&acpi_gbl_FADT.xpm1a_event_block, acpi_gbl_FADT.pm1_event_length,\r\n"ACPI PM1a_EVT_BLK");\r\nacpi_request_region(&acpi_gbl_FADT.xpm1b_event_block, acpi_gbl_FADT.pm1_event_length,\r\n"ACPI PM1b_EVT_BLK");\r\nacpi_request_region(&acpi_gbl_FADT.xpm1a_control_block, acpi_gbl_FADT.pm1_control_length,\r\n"ACPI PM1a_CNT_BLK");\r\nacpi_request_region(&acpi_gbl_FADT.xpm1b_control_block, acpi_gbl_FADT.pm1_control_length,\r\n"ACPI PM1b_CNT_BLK");\r\nif (acpi_gbl_FADT.pm_timer_length == 4)\r\nacpi_request_region(&acpi_gbl_FADT.xpm_timer_block, 4, "ACPI PM_TMR");\r\nacpi_request_region(&acpi_gbl_FADT.xpm2_control_block, acpi_gbl_FADT.pm2_control_length,\r\n"ACPI PM2_CNT_BLK");\r\nif (!(acpi_gbl_FADT.gpe0_block_length & 0x1))\r\nacpi_request_region(&acpi_gbl_FADT.xgpe0_block,\r\nacpi_gbl_FADT.gpe0_block_length, "ACPI GPE0_BLK");\r\nif (!(acpi_gbl_FADT.gpe1_block_length & 0x1))\r\nacpi_request_region(&acpi_gbl_FADT.xgpe1_block,\r\nacpi_gbl_FADT.gpe1_block_length, "ACPI GPE1_BLK");\r\nreturn 0;\r\n}\r\nvoid acpi_os_printf(const char *fmt, ...)\r\n{\r\nva_list args;\r\nva_start(args, fmt);\r\nacpi_os_vprintf(fmt, args);\r\nva_end(args);\r\n}\r\nvoid acpi_os_vprintf(const char *fmt, va_list args)\r\n{\r\nstatic char buffer[512];\r\nvsprintf(buffer, fmt, args);\r\n#ifdef ENABLE_DEBUGGER\r\nif (acpi_in_debugger) {\r\nkdb_printf("%s", buffer);\r\n} else {\r\nprintk(KERN_CONT "%s", buffer);\r\n}\r\n#else\r\nprintk(KERN_CONT "%s", buffer);\r\n#endif\r\n}\r\nstatic int __init setup_acpi_rsdp(char *arg)\r\n{\r\nif (kstrtoul(arg, 16, &acpi_rsdp))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nacpi_physical_address __init acpi_os_get_root_pointer(void)\r\n{\r\n#ifdef CONFIG_KEXEC\r\nif (acpi_rsdp)\r\nreturn acpi_rsdp;\r\n#endif\r\nif (efi_enabled(EFI_CONFIG_TABLES)) {\r\nif (efi.acpi20 != EFI_INVALID_TABLE_ADDR)\r\nreturn efi.acpi20;\r\nelse if (efi.acpi != EFI_INVALID_TABLE_ADDR)\r\nreturn efi.acpi;\r\nelse {\r\nprintk(KERN_ERR PREFIX\r\n"System description tables not found\n");\r\nreturn 0;\r\n}\r\n} else if (IS_ENABLED(CONFIG_ACPI_LEGACY_TABLES_LOOKUP)) {\r\nacpi_physical_address pa = 0;\r\nacpi_find_root_pointer(&pa);\r\nreturn pa;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct acpi_ioremap *\r\nacpi_map_lookup(acpi_physical_address phys, acpi_size size)\r\n{\r\nstruct acpi_ioremap *map;\r\nlist_for_each_entry_rcu(map, &acpi_ioremaps, list)\r\nif (map->phys <= phys &&\r\nphys + size <= map->phys + map->size)\r\nreturn map;\r\nreturn NULL;\r\n}\r\nstatic void __iomem *\r\nacpi_map_vaddr_lookup(acpi_physical_address phys, unsigned int size)\r\n{\r\nstruct acpi_ioremap *map;\r\nmap = acpi_map_lookup(phys, size);\r\nif (map)\r\nreturn map->virt + (phys - map->phys);\r\nreturn NULL;\r\n}\r\nvoid __iomem *acpi_os_get_iomem(acpi_physical_address phys, unsigned int size)\r\n{\r\nstruct acpi_ioremap *map;\r\nvoid __iomem *virt = NULL;\r\nmutex_lock(&acpi_ioremap_lock);\r\nmap = acpi_map_lookup(phys, size);\r\nif (map) {\r\nvirt = map->virt + (phys - map->phys);\r\nmap->refcount++;\r\n}\r\nmutex_unlock(&acpi_ioremap_lock);\r\nreturn virt;\r\n}\r\nstatic struct acpi_ioremap *\r\nacpi_map_lookup_virt(void __iomem *virt, acpi_size size)\r\n{\r\nstruct acpi_ioremap *map;\r\nlist_for_each_entry_rcu(map, &acpi_ioremaps, list)\r\nif (map->virt <= virt &&\r\nvirt + size <= map->virt + map->size)\r\nreturn map;\r\nreturn NULL;\r\n}\r\nstatic void __iomem *acpi_map(acpi_physical_address pg_off, unsigned long pg_sz)\r\n{\r\nunsigned long pfn;\r\npfn = pg_off >> PAGE_SHIFT;\r\nif (should_use_kmap(pfn)) {\r\nif (pg_sz > PAGE_SIZE)\r\nreturn NULL;\r\nreturn (void __iomem __force *)kmap(pfn_to_page(pfn));\r\n} else\r\nreturn acpi_os_ioremap(pg_off, pg_sz);\r\n}\r\nstatic void acpi_unmap(acpi_physical_address pg_off, void __iomem *vaddr)\r\n{\r\nunsigned long pfn;\r\npfn = pg_off >> PAGE_SHIFT;\r\nif (should_use_kmap(pfn))\r\nkunmap(pfn_to_page(pfn));\r\nelse\r\niounmap(vaddr);\r\n}\r\nvoid __iomem *__init_refok\r\nacpi_os_map_iomem(acpi_physical_address phys, acpi_size size)\r\n{\r\nstruct acpi_ioremap *map;\r\nvoid __iomem *virt;\r\nacpi_physical_address pg_off;\r\nacpi_size pg_sz;\r\nif (phys > ULONG_MAX) {\r\nprintk(KERN_ERR PREFIX "Cannot map memory that high\n");\r\nreturn NULL;\r\n}\r\nif (!acpi_gbl_permanent_mmap)\r\nreturn __acpi_map_table((unsigned long)phys, size);\r\nmutex_lock(&acpi_ioremap_lock);\r\nmap = acpi_map_lookup(phys, size);\r\nif (map) {\r\nmap->refcount++;\r\ngoto out;\r\n}\r\nmap = kzalloc(sizeof(*map), GFP_KERNEL);\r\nif (!map) {\r\nmutex_unlock(&acpi_ioremap_lock);\r\nreturn NULL;\r\n}\r\npg_off = round_down(phys, PAGE_SIZE);\r\npg_sz = round_up(phys + size, PAGE_SIZE) - pg_off;\r\nvirt = acpi_map(pg_off, pg_sz);\r\nif (!virt) {\r\nmutex_unlock(&acpi_ioremap_lock);\r\nkfree(map);\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&map->list);\r\nmap->virt = virt;\r\nmap->phys = pg_off;\r\nmap->size = pg_sz;\r\nmap->refcount = 1;\r\nlist_add_tail_rcu(&map->list, &acpi_ioremaps);\r\nout:\r\nmutex_unlock(&acpi_ioremap_lock);\r\nreturn map->virt + (phys - map->phys);\r\n}\r\nvoid *__init_refok\r\nacpi_os_map_memory(acpi_physical_address phys, acpi_size size)\r\n{\r\nreturn (void *)acpi_os_map_iomem(phys, size);\r\n}\r\nstatic void acpi_os_drop_map_ref(struct acpi_ioremap *map)\r\n{\r\nif (!--map->refcount)\r\nlist_del_rcu(&map->list);\r\n}\r\nstatic void acpi_os_map_cleanup(struct acpi_ioremap *map)\r\n{\r\nif (!map->refcount) {\r\nsynchronize_rcu_expedited();\r\nacpi_unmap(map->phys, map->virt);\r\nkfree(map);\r\n}\r\n}\r\nvoid __ref acpi_os_unmap_iomem(void __iomem *virt, acpi_size size)\r\n{\r\nstruct acpi_ioremap *map;\r\nif (!acpi_gbl_permanent_mmap) {\r\n__acpi_unmap_table(virt, size);\r\nreturn;\r\n}\r\nmutex_lock(&acpi_ioremap_lock);\r\nmap = acpi_map_lookup_virt(virt, size);\r\nif (!map) {\r\nmutex_unlock(&acpi_ioremap_lock);\r\nWARN(true, PREFIX "%s: bad address %p\n", __func__, virt);\r\nreturn;\r\n}\r\nacpi_os_drop_map_ref(map);\r\nmutex_unlock(&acpi_ioremap_lock);\r\nacpi_os_map_cleanup(map);\r\n}\r\nvoid __ref acpi_os_unmap_memory(void *virt, acpi_size size)\r\n{\r\nreturn acpi_os_unmap_iomem((void __iomem *)virt, size);\r\n}\r\nvoid __init early_acpi_os_unmap_memory(void __iomem *virt, acpi_size size)\r\n{\r\nif (!acpi_gbl_permanent_mmap)\r\n__acpi_unmap_table(virt, size);\r\n}\r\nint acpi_os_map_generic_address(struct acpi_generic_address *gas)\r\n{\r\nu64 addr;\r\nvoid __iomem *virt;\r\nif (gas->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)\r\nreturn 0;\r\nmemcpy(&addr, &gas->address, sizeof(addr));\r\nif (!addr || !gas->bit_width)\r\nreturn -EINVAL;\r\nvirt = acpi_os_map_iomem(addr, gas->bit_width / 8);\r\nif (!virt)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nvoid acpi_os_unmap_generic_address(struct acpi_generic_address *gas)\r\n{\r\nu64 addr;\r\nstruct acpi_ioremap *map;\r\nif (gas->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY)\r\nreturn;\r\nmemcpy(&addr, &gas->address, sizeof(addr));\r\nif (!addr || !gas->bit_width)\r\nreturn;\r\nmutex_lock(&acpi_ioremap_lock);\r\nmap = acpi_map_lookup(addr, gas->bit_width / 8);\r\nif (!map) {\r\nmutex_unlock(&acpi_ioremap_lock);\r\nreturn;\r\n}\r\nacpi_os_drop_map_ref(map);\r\nmutex_unlock(&acpi_ioremap_lock);\r\nacpi_os_map_cleanup(map);\r\n}\r\nacpi_status\r\nacpi_os_get_physical_address(void *virt, acpi_physical_address * phys)\r\n{\r\nif (!phys || !virt)\r\nreturn AE_BAD_PARAMETER;\r\n*phys = virt_to_phys(virt);\r\nreturn AE_OK;\r\n}\r\nacpi_status\r\nacpi_os_predefined_override(const struct acpi_predefined_names *init_val,\r\nacpi_string * new_val)\r\n{\r\nif (!init_val || !new_val)\r\nreturn AE_BAD_PARAMETER;\r\n*new_val = NULL;\r\nif (!memcmp(init_val->name, "_OS_", 4) && strlen(acpi_os_name)) {\r\nprintk(KERN_INFO PREFIX "Overriding _OS definition to '%s'\n",\r\nacpi_os_name);\r\n*new_val = acpi_os_name;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic u8 __init acpi_table_checksum(u8 *buffer, u32 length)\r\n{\r\nu8 sum = 0;\r\nu8 *end = buffer + length;\r\nwhile (buffer < end)\r\nsum = (u8) (sum + *(buffer++));\r\nreturn sum;\r\n}\r\nvoid __init acpi_initrd_override(void *data, size_t size)\r\n{\r\nint sig, no, table_nr = 0, total_offset = 0;\r\nlong offset = 0;\r\nstruct acpi_table_header *table;\r\nchar cpio_path[32] = "kernel/firmware/acpi/";\r\nstruct cpio_data file;\r\nif (data == NULL || size == 0)\r\nreturn;\r\nfor (no = 0; no < ACPI_OVERRIDE_TABLES; no++) {\r\nfile = find_cpio_data(cpio_path, data, size, &offset);\r\nif (!file.data)\r\nbreak;\r\ndata += offset;\r\nsize -= offset;\r\nif (file.size < sizeof(struct acpi_table_header)) {\r\npr_err("ACPI OVERRIDE: Table smaller than ACPI header [%s%s]\n",\r\ncpio_path, file.name);\r\ncontinue;\r\n}\r\ntable = file.data;\r\nfor (sig = 0; table_sigs[sig]; sig++)\r\nif (!memcmp(table->signature, table_sigs[sig], 4))\r\nbreak;\r\nif (!table_sigs[sig]) {\r\npr_err("ACPI OVERRIDE: Unknown signature [%s%s]\n",\r\ncpio_path, file.name);\r\ncontinue;\r\n}\r\nif (file.size != table->length) {\r\npr_err("ACPI OVERRIDE: File length does not match table length [%s%s]\n",\r\ncpio_path, file.name);\r\ncontinue;\r\n}\r\nif (acpi_table_checksum(file.data, table->length)) {\r\npr_err("ACPI OVERRIDE: Bad table checksum [%s%s]\n",\r\ncpio_path, file.name);\r\ncontinue;\r\n}\r\npr_info("%4.4s ACPI table found in initrd [%s%s][0x%x]\n",\r\ntable->signature, cpio_path, file.name, table->length);\r\nall_tables_size += table->length;\r\nacpi_initrd_files[table_nr].data = file.data;\r\nacpi_initrd_files[table_nr].size = file.size;\r\ntable_nr++;\r\n}\r\nif (table_nr == 0)\r\nreturn;\r\nacpi_tables_addr =\r\nmemblock_find_in_range(0, max_low_pfn_mapped << PAGE_SHIFT,\r\nall_tables_size, PAGE_SIZE);\r\nif (!acpi_tables_addr) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nmemblock_reserve(acpi_tables_addr, all_tables_size);\r\narch_reserve_mem_area(acpi_tables_addr, all_tables_size);\r\nfor (no = 0; no < table_nr; no++) {\r\nunsigned char *src_p = acpi_initrd_files[no].data;\r\nphys_addr_t size = acpi_initrd_files[no].size;\r\nphys_addr_t dest_addr = acpi_tables_addr + total_offset;\r\nphys_addr_t slop, clen;\r\nchar *dest_p;\r\ntotal_offset += size;\r\nwhile (size) {\r\nslop = dest_addr & ~PAGE_MASK;\r\nclen = size;\r\nif (clen > MAP_CHUNK_SIZE - slop)\r\nclen = MAP_CHUNK_SIZE - slop;\r\ndest_p = early_ioremap(dest_addr & PAGE_MASK,\r\nclen + slop);\r\nmemcpy(dest_p + slop, src_p, clen);\r\nearly_iounmap(dest_p, clen + slop);\r\nsrc_p += clen;\r\ndest_addr += clen;\r\nsize -= clen;\r\n}\r\n}\r\n}\r\nstatic void acpi_table_taint(struct acpi_table_header *table)\r\n{\r\npr_warn(PREFIX\r\n"Override [%4.4s-%8.8s], this is unsafe: tainting kernel\n",\r\ntable->signature, table->oem_table_id);\r\nadd_taint(TAINT_OVERRIDDEN_ACPI_TABLE, LOCKDEP_NOW_UNRELIABLE);\r\n}\r\nacpi_status\r\nacpi_os_table_override(struct acpi_table_header * existing_table,\r\nstruct acpi_table_header ** new_table)\r\n{\r\nif (!existing_table || !new_table)\r\nreturn AE_BAD_PARAMETER;\r\n*new_table = NULL;\r\n#ifdef CONFIG_ACPI_CUSTOM_DSDT\r\nif (strncmp(existing_table->signature, "DSDT", 4) == 0)\r\n*new_table = (struct acpi_table_header *)AmlCode;\r\n#endif\r\nif (*new_table != NULL)\r\nacpi_table_taint(existing_table);\r\nreturn AE_OK;\r\n}\r\nacpi_status\r\nacpi_os_physical_table_override(struct acpi_table_header *existing_table,\r\nacpi_physical_address *address,\r\nu32 *table_length)\r\n{\r\n#ifndef CONFIG_ACPI_INITRD_TABLE_OVERRIDE\r\n*table_length = 0;\r\n*address = 0;\r\nreturn AE_OK;\r\n#else\r\nint table_offset = 0;\r\nstruct acpi_table_header *table;\r\n*table_length = 0;\r\n*address = 0;\r\nif (!acpi_tables_addr)\r\nreturn AE_OK;\r\ndo {\r\nif (table_offset + ACPI_HEADER_SIZE > all_tables_size) {\r\nWARN_ON(1);\r\nreturn AE_OK;\r\n}\r\ntable = acpi_os_map_memory(acpi_tables_addr + table_offset,\r\nACPI_HEADER_SIZE);\r\nif (table_offset + table->length > all_tables_size) {\r\nacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\r\nWARN_ON(1);\r\nreturn AE_OK;\r\n}\r\ntable_offset += table->length;\r\nif (memcmp(existing_table->signature, table->signature, 4)) {\r\nacpi_os_unmap_memory(table,\r\nACPI_HEADER_SIZE);\r\ncontinue;\r\n}\r\nif (memcmp(table->oem_table_id, existing_table->oem_table_id,\r\nACPI_OEM_TABLE_ID_SIZE)) {\r\nacpi_os_unmap_memory(table,\r\nACPI_HEADER_SIZE);\r\ncontinue;\r\n}\r\ntable_offset -= table->length;\r\n*table_length = table->length;\r\nacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\r\n*address = acpi_tables_addr + table_offset;\r\nbreak;\r\n} while (table_offset + ACPI_HEADER_SIZE < all_tables_size);\r\nif (*address != 0)\r\nacpi_table_taint(existing_table);\r\nreturn AE_OK;\r\n#endif\r\n}\r\nstatic irqreturn_t acpi_irq(int irq, void *dev_id)\r\n{\r\nu32 handled;\r\nhandled = (*acpi_irq_handler) (acpi_irq_context);\r\nif (handled) {\r\nacpi_irq_handled++;\r\nreturn IRQ_HANDLED;\r\n} else {\r\nacpi_irq_not_handled++;\r\nreturn IRQ_NONE;\r\n}\r\n}\r\nacpi_status\r\nacpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler,\r\nvoid *context)\r\n{\r\nunsigned int irq;\r\nacpi_irq_stats_init();\r\nif (gsi != acpi_gbl_FADT.sci_interrupt)\r\nreturn AE_BAD_PARAMETER;\r\nif (acpi_irq_handler)\r\nreturn AE_ALREADY_ACQUIRED;\r\nif (acpi_gsi_to_irq(gsi, &irq) < 0) {\r\nprintk(KERN_ERR PREFIX "SCI (ACPI GSI %d) not registered\n",\r\ngsi);\r\nreturn AE_OK;\r\n}\r\nacpi_irq_handler = handler;\r\nacpi_irq_context = context;\r\nif (request_irq(irq, acpi_irq, IRQF_SHARED, "acpi", acpi_irq)) {\r\nprintk(KERN_ERR PREFIX "SCI (IRQ%d) allocation failed\n", irq);\r\nacpi_irq_handler = NULL;\r\nreturn AE_NOT_ACQUIRED;\r\n}\r\nreturn AE_OK;\r\n}\r\nacpi_status acpi_os_remove_interrupt_handler(u32 irq, acpi_osd_handler handler)\r\n{\r\nif (irq != acpi_gbl_FADT.sci_interrupt)\r\nreturn AE_BAD_PARAMETER;\r\nfree_irq(irq, acpi_irq);\r\nacpi_irq_handler = NULL;\r\nreturn AE_OK;\r\n}\r\nvoid acpi_os_sleep(u64 ms)\r\n{\r\nmsleep(ms);\r\n}\r\nvoid acpi_os_stall(u32 us)\r\n{\r\nwhile (us) {\r\nu32 delay = 1000;\r\nif (delay > us)\r\ndelay = us;\r\nudelay(delay);\r\ntouch_nmi_watchdog();\r\nus -= delay;\r\n}\r\n}\r\nu64 acpi_os_get_timer(void)\r\n{\r\nu64 time_ns = ktime_to_ns(ktime_get());\r\ndo_div(time_ns, 100);\r\nreturn time_ns;\r\n}\r\nacpi_status acpi_os_read_port(acpi_io_address port, u32 * value, u32 width)\r\n{\r\nu32 dummy;\r\nif (!value)\r\nvalue = &dummy;\r\n*value = 0;\r\nif (width <= 8) {\r\n*(u8 *) value = inb(port);\r\n} else if (width <= 16) {\r\n*(u16 *) value = inw(port);\r\n} else if (width <= 32) {\r\n*(u32 *) value = inl(port);\r\n} else {\r\nBUG();\r\n}\r\nreturn AE_OK;\r\n}\r\nacpi_status acpi_os_write_port(acpi_io_address port, u32 value, u32 width)\r\n{\r\nif (width <= 8) {\r\noutb(value, port);\r\n} else if (width <= 16) {\r\noutw(value, port);\r\n} else if (width <= 32) {\r\noutl(value, port);\r\n} else {\r\nBUG();\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic inline u64 read64(const volatile void __iomem *addr)\r\n{\r\nreturn readq(addr);\r\n}\r\nstatic inline u64 read64(const volatile void __iomem *addr)\r\n{\r\nu64 l, h;\r\nl = readl(addr);\r\nh = readl(addr+4);\r\nreturn l | (h << 32);\r\n}\r\nacpi_status\r\nacpi_os_read_memory(acpi_physical_address phys_addr, u64 *value, u32 width)\r\n{\r\nvoid __iomem *virt_addr;\r\nunsigned int size = width / 8;\r\nbool unmap = false;\r\nu64 dummy;\r\nrcu_read_lock();\r\nvirt_addr = acpi_map_vaddr_lookup(phys_addr, size);\r\nif (!virt_addr) {\r\nrcu_read_unlock();\r\nvirt_addr = acpi_os_ioremap(phys_addr, size);\r\nif (!virt_addr)\r\nreturn AE_BAD_ADDRESS;\r\nunmap = true;\r\n}\r\nif (!value)\r\nvalue = &dummy;\r\nswitch (width) {\r\ncase 8:\r\n*(u8 *) value = readb(virt_addr);\r\nbreak;\r\ncase 16:\r\n*(u16 *) value = readw(virt_addr);\r\nbreak;\r\ncase 32:\r\n*(u32 *) value = readl(virt_addr);\r\nbreak;\r\ncase 64:\r\n*(u64 *) value = read64(virt_addr);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (unmap)\r\niounmap(virt_addr);\r\nelse\r\nrcu_read_unlock();\r\nreturn AE_OK;\r\n}\r\nstatic inline void write64(u64 val, volatile void __iomem *addr)\r\n{\r\nwriteq(val, addr);\r\n}\r\nstatic inline void write64(u64 val, volatile void __iomem *addr)\r\n{\r\nwritel(val, addr);\r\nwritel(val>>32, addr+4);\r\n}\r\nacpi_status\r\nacpi_os_write_memory(acpi_physical_address phys_addr, u64 value, u32 width)\r\n{\r\nvoid __iomem *virt_addr;\r\nunsigned int size = width / 8;\r\nbool unmap = false;\r\nrcu_read_lock();\r\nvirt_addr = acpi_map_vaddr_lookup(phys_addr, size);\r\nif (!virt_addr) {\r\nrcu_read_unlock();\r\nvirt_addr = acpi_os_ioremap(phys_addr, size);\r\nif (!virt_addr)\r\nreturn AE_BAD_ADDRESS;\r\nunmap = true;\r\n}\r\nswitch (width) {\r\ncase 8:\r\nwriteb(value, virt_addr);\r\nbreak;\r\ncase 16:\r\nwritew(value, virt_addr);\r\nbreak;\r\ncase 32:\r\nwritel(value, virt_addr);\r\nbreak;\r\ncase 64:\r\nwrite64(value, virt_addr);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (unmap)\r\niounmap(virt_addr);\r\nelse\r\nrcu_read_unlock();\r\nreturn AE_OK;\r\n}\r\nacpi_status\r\nacpi_os_read_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,\r\nu64 *value, u32 width)\r\n{\r\nint result, size;\r\nu32 value32;\r\nif (!value)\r\nreturn AE_BAD_PARAMETER;\r\nswitch (width) {\r\ncase 8:\r\nsize = 1;\r\nbreak;\r\ncase 16:\r\nsize = 2;\r\nbreak;\r\ncase 32:\r\nsize = 4;\r\nbreak;\r\ndefault:\r\nreturn AE_ERROR;\r\n}\r\nresult = raw_pci_read(pci_id->segment, pci_id->bus,\r\nPCI_DEVFN(pci_id->device, pci_id->function),\r\nreg, size, &value32);\r\n*value = value32;\r\nreturn (result ? AE_ERROR : AE_OK);\r\n}\r\nacpi_status\r\nacpi_os_write_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,\r\nu64 value, u32 width)\r\n{\r\nint result, size;\r\nswitch (width) {\r\ncase 8:\r\nsize = 1;\r\nbreak;\r\ncase 16:\r\nsize = 2;\r\nbreak;\r\ncase 32:\r\nsize = 4;\r\nbreak;\r\ndefault:\r\nreturn AE_ERROR;\r\n}\r\nresult = raw_pci_write(pci_id->segment, pci_id->bus,\r\nPCI_DEVFN(pci_id->device, pci_id->function),\r\nreg, size, value);\r\nreturn (result ? AE_ERROR : AE_OK);\r\n}\r\nstatic void acpi_os_execute_deferred(struct work_struct *work)\r\n{\r\nstruct acpi_os_dpc *dpc = container_of(work, struct acpi_os_dpc, work);\r\ndpc->function(dpc->context);\r\nkfree(dpc);\r\n}\r\nacpi_status acpi_os_execute(acpi_execute_type type,\r\nacpi_osd_exec_callback function, void *context)\r\n{\r\nacpi_status status = AE_OK;\r\nstruct acpi_os_dpc *dpc;\r\nstruct workqueue_struct *queue;\r\nint ret;\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"Scheduling function [%p(%p)] for deferred execution.\n",\r\nfunction, context));\r\ndpc = kzalloc(sizeof(struct acpi_os_dpc), GFP_ATOMIC);\r\nif (!dpc)\r\nreturn AE_NO_MEMORY;\r\ndpc->function = function;\r\ndpc->context = context;\r\nif (type == OSL_NOTIFY_HANDLER) {\r\nqueue = kacpi_notify_wq;\r\nINIT_WORK(&dpc->work, acpi_os_execute_deferred);\r\n} else {\r\nqueue = kacpid_wq;\r\nINIT_WORK(&dpc->work, acpi_os_execute_deferred);\r\n}\r\nret = queue_work_on(0, queue, &dpc->work);\r\nif (!ret) {\r\nprintk(KERN_ERR PREFIX\r\n"Call to queue_work() failed.\n");\r\nstatus = AE_ERROR;\r\nkfree(dpc);\r\n}\r\nreturn status;\r\n}\r\nvoid acpi_os_wait_events_complete(void)\r\n{\r\nif (acpi_irq_handler)\r\nsynchronize_hardirq(acpi_gbl_FADT.sci_interrupt);\r\nflush_workqueue(kacpid_wq);\r\nflush_workqueue(kacpi_notify_wq);\r\n}\r\nstatic void acpi_hotplug_work_fn(struct work_struct *work)\r\n{\r\nstruct acpi_hp_work *hpw = container_of(work, struct acpi_hp_work, work);\r\nacpi_os_wait_events_complete();\r\nacpi_device_hotplug(hpw->adev, hpw->src);\r\nkfree(hpw);\r\n}\r\nacpi_status acpi_hotplug_schedule(struct acpi_device *adev, u32 src)\r\n{\r\nstruct acpi_hp_work *hpw;\r\nACPI_DEBUG_PRINT((ACPI_DB_EXEC,\r\n"Scheduling hotplug event (%p, %u) for deferred execution.\n",\r\nadev, src));\r\nhpw = kmalloc(sizeof(*hpw), GFP_KERNEL);\r\nif (!hpw)\r\nreturn AE_NO_MEMORY;\r\nINIT_WORK(&hpw->work, acpi_hotplug_work_fn);\r\nhpw->adev = adev;\r\nhpw->src = src;\r\nif (!queue_work(kacpi_hotplug_wq, &hpw->work)) {\r\nkfree(hpw);\r\nreturn AE_ERROR;\r\n}\r\nreturn AE_OK;\r\n}\r\nbool acpi_queue_hotplug_work(struct work_struct *work)\r\n{\r\nreturn queue_work(kacpi_hotplug_wq, work);\r\n}\r\nacpi_status\r\nacpi_os_create_semaphore(u32 max_units, u32 initial_units, acpi_handle * handle)\r\n{\r\nstruct semaphore *sem = NULL;\r\nsem = acpi_os_allocate_zeroed(sizeof(struct semaphore));\r\nif (!sem)\r\nreturn AE_NO_MEMORY;\r\nsema_init(sem, initial_units);\r\n*handle = (acpi_handle *) sem;\r\nACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Creating semaphore[%p|%d].\n",\r\n*handle, initial_units));\r\nreturn AE_OK;\r\n}\r\nacpi_status acpi_os_delete_semaphore(acpi_handle handle)\r\n{\r\nstruct semaphore *sem = (struct semaphore *)handle;\r\nif (!sem)\r\nreturn AE_BAD_PARAMETER;\r\nACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Deleting semaphore[%p].\n", handle));\r\nBUG_ON(!list_empty(&sem->wait_list));\r\nkfree(sem);\r\nsem = NULL;\r\nreturn AE_OK;\r\n}\r\nacpi_status acpi_os_wait_semaphore(acpi_handle handle, u32 units, u16 timeout)\r\n{\r\nacpi_status status = AE_OK;\r\nstruct semaphore *sem = (struct semaphore *)handle;\r\nlong jiffies;\r\nint ret = 0;\r\nif (!sem || (units < 1))\r\nreturn AE_BAD_PARAMETER;\r\nif (units > 1)\r\nreturn AE_SUPPORT;\r\nACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Waiting for semaphore[%p|%d|%d]\n",\r\nhandle, units, timeout));\r\nif (timeout == ACPI_WAIT_FOREVER)\r\njiffies = MAX_SCHEDULE_TIMEOUT;\r\nelse\r\njiffies = msecs_to_jiffies(timeout);\r\nret = down_timeout(sem, jiffies);\r\nif (ret)\r\nstatus = AE_TIME;\r\nif (ACPI_FAILURE(status)) {\r\nACPI_DEBUG_PRINT((ACPI_DB_MUTEX,\r\n"Failed to acquire semaphore[%p|%d|%d], %s",\r\nhandle, units, timeout,\r\nacpi_format_exception(status)));\r\n} else {\r\nACPI_DEBUG_PRINT((ACPI_DB_MUTEX,\r\n"Acquired semaphore[%p|%d|%d]", handle,\r\nunits, timeout));\r\n}\r\nreturn status;\r\n}\r\nacpi_status acpi_os_signal_semaphore(acpi_handle handle, u32 units)\r\n{\r\nstruct semaphore *sem = (struct semaphore *)handle;\r\nif (!sem || (units < 1))\r\nreturn AE_BAD_PARAMETER;\r\nif (units > 1)\r\nreturn AE_SUPPORT;\r\nACPI_DEBUG_PRINT((ACPI_DB_MUTEX, "Signaling semaphore[%p|%d]\n", handle,\r\nunits));\r\nup(sem);\r\nreturn AE_OK;\r\n}\r\nu32 acpi_os_get_line(char *buffer)\r\n{\r\n#ifdef ENABLE_DEBUGGER\r\nif (acpi_in_debugger) {\r\nu32 chars;\r\nkdb_read(buffer, sizeof(line_buf));\r\nchars = strlen(buffer) - 1;\r\nbuffer[chars] = '\0';\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nacpi_status acpi_os_signal(u32 function, void *info)\r\n{\r\nswitch (function) {\r\ncase ACPI_SIGNAL_FATAL:\r\nprintk(KERN_ERR PREFIX "Fatal opcode executed\n");\r\nbreak;\r\ncase ACPI_SIGNAL_BREAKPOINT:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic int __init acpi_os_name_setup(char *str)\r\n{\r\nchar *p = acpi_os_name;\r\nint count = ACPI_MAX_OVERRIDE_LEN - 1;\r\nif (!str || !*str)\r\nreturn 0;\r\nfor (; count-- && *str; str++) {\r\nif (isalnum(*str) || *str == ' ' || *str == ':')\r\n*p++ = *str;\r\nelse if (*str == '\'' || *str == '"')\r\ncontinue;\r\nelse\r\nbreak;\r\n}\r\n*p = 0;\r\nreturn 1;\r\n}\r\nvoid __init acpi_osi_setup(char *str)\r\n{\r\nstruct osi_setup_entry *osi;\r\nbool enable = true;\r\nint i;\r\nif (!acpi_gbl_create_osi_method)\r\nreturn;\r\nif (str == NULL || *str == '\0') {\r\nprintk(KERN_INFO PREFIX "_OSI method disabled\n");\r\nacpi_gbl_create_osi_method = FALSE;\r\nreturn;\r\n}\r\nif (*str == '!') {\r\nstr++;\r\nif (*str == '\0') {\r\nosi_linux.default_disabling = 1;\r\nreturn;\r\n} else if (*str == '*') {\r\nacpi_update_interfaces(ACPI_DISABLE_ALL_STRINGS);\r\nfor (i = 0; i < OSI_STRING_ENTRIES_MAX; i++) {\r\nosi = &osi_setup_entries[i];\r\nosi->enable = false;\r\n}\r\nreturn;\r\n}\r\nenable = false;\r\n}\r\nfor (i = 0; i < OSI_STRING_ENTRIES_MAX; i++) {\r\nosi = &osi_setup_entries[i];\r\nif (!strcmp(osi->string, str)) {\r\nosi->enable = enable;\r\nbreak;\r\n} else if (osi->string[0] == '\0') {\r\nosi->enable = enable;\r\nstrncpy(osi->string, str, OSI_STRING_LENGTH_MAX);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void __init set_osi_linux(unsigned int enable)\r\n{\r\nif (osi_linux.enable != enable)\r\nosi_linux.enable = enable;\r\nif (osi_linux.enable)\r\nacpi_osi_setup("Linux");\r\nelse\r\nacpi_osi_setup("!Linux");\r\nreturn;\r\n}\r\nstatic void __init acpi_cmdline_osi_linux(unsigned int enable)\r\n{\r\nosi_linux.cmdline = 1;\r\nosi_linux.dmi = 0;\r\nset_osi_linux(enable);\r\nreturn;\r\n}\r\nvoid __init acpi_dmi_osi_linux(int enable, const struct dmi_system_id *d)\r\n{\r\nprintk(KERN_NOTICE PREFIX "DMI detected: %s\n", d->ident);\r\nif (enable == -1)\r\nreturn;\r\nosi_linux.dmi = 1;\r\nset_osi_linux(enable);\r\nreturn;\r\n}\r\nstatic void __init acpi_osi_setup_late(void)\r\n{\r\nstruct osi_setup_entry *osi;\r\nchar *str;\r\nint i;\r\nacpi_status status;\r\nif (osi_linux.default_disabling) {\r\nstatus = acpi_update_interfaces(ACPI_DISABLE_ALL_VENDOR_STRINGS);\r\nif (ACPI_SUCCESS(status))\r\nprintk(KERN_INFO PREFIX "Disabled all _OSI OS vendors\n");\r\n}\r\nfor (i = 0; i < OSI_STRING_ENTRIES_MAX; i++) {\r\nosi = &osi_setup_entries[i];\r\nstr = osi->string;\r\nif (*str == '\0')\r\nbreak;\r\nif (osi->enable) {\r\nstatus = acpi_install_interface(str);\r\nif (ACPI_SUCCESS(status))\r\nprintk(KERN_INFO PREFIX "Added _OSI(%s)\n", str);\r\n} else {\r\nstatus = acpi_remove_interface(str);\r\nif (ACPI_SUCCESS(status))\r\nprintk(KERN_INFO PREFIX "Deleted _OSI(%s)\n", str);\r\n}\r\n}\r\n}\r\nstatic int __init osi_setup(char *str)\r\n{\r\nif (str && !strcmp("Linux", str))\r\nacpi_cmdline_osi_linux(1);\r\nelse if (str && !strcmp("!Linux", str))\r\nacpi_cmdline_osi_linux(0);\r\nelse\r\nacpi_osi_setup(str);\r\nreturn 1;\r\n}\r\nstatic int __init acpi_no_auto_serialize_setup(char *str)\r\n{\r\nacpi_gbl_auto_serialize_methods = FALSE;\r\npr_info("ACPI: auto-serialization disabled\n");\r\nreturn 1;\r\n}\r\nstatic int __init acpi_enforce_resources_setup(char *str)\r\n{\r\nif (str == NULL || *str == '\0')\r\nreturn 0;\r\nif (!strcmp("strict", str))\r\nacpi_enforce_resources = ENFORCE_RESOURCES_STRICT;\r\nelse if (!strcmp("lax", str))\r\nacpi_enforce_resources = ENFORCE_RESOURCES_LAX;\r\nelse if (!strcmp("no", str))\r\nacpi_enforce_resources = ENFORCE_RESOURCES_NO;\r\nreturn 1;\r\n}\r\nint acpi_check_resource_conflict(const struct resource *res)\r\n{\r\nacpi_adr_space_type space_id;\r\nacpi_size length;\r\nu8 warn = 0;\r\nint clash = 0;\r\nif (acpi_enforce_resources == ENFORCE_RESOURCES_NO)\r\nreturn 0;\r\nif (!(res->flags & IORESOURCE_IO) && !(res->flags & IORESOURCE_MEM))\r\nreturn 0;\r\nif (res->flags & IORESOURCE_IO)\r\nspace_id = ACPI_ADR_SPACE_SYSTEM_IO;\r\nelse\r\nspace_id = ACPI_ADR_SPACE_SYSTEM_MEMORY;\r\nlength = resource_size(res);\r\nif (acpi_enforce_resources != ENFORCE_RESOURCES_NO)\r\nwarn = 1;\r\nclash = acpi_check_address_range(space_id, res->start, length, warn);\r\nif (clash) {\r\nif (acpi_enforce_resources != ENFORCE_RESOURCES_NO) {\r\nif (acpi_enforce_resources == ENFORCE_RESOURCES_LAX)\r\nprintk(KERN_NOTICE "ACPI: This conflict may"\r\n" cause random problems and system"\r\n" instability\n");\r\nprintk(KERN_INFO "ACPI: If an ACPI driver is available"\r\n" for this device, you should use it instead of"\r\n" the native driver\n");\r\n}\r\nif (acpi_enforce_resources == ENFORCE_RESOURCES_STRICT)\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nint acpi_check_region(resource_size_t start, resource_size_t n,\r\nconst char *name)\r\n{\r\nstruct resource res = {\r\n.start = start,\r\n.end = start + n - 1,\r\n.name = name,\r\n.flags = IORESOURCE_IO,\r\n};\r\nreturn acpi_check_resource_conflict(&res);\r\n}\r\nint acpi_resources_are_enforced(void)\r\n{\r\nreturn acpi_enforce_resources == ENFORCE_RESOURCES_STRICT;\r\n}\r\nvoid acpi_os_delete_lock(acpi_spinlock handle)\r\n{\r\nACPI_FREE(handle);\r\n}\r\nacpi_cpu_flags acpi_os_acquire_lock(acpi_spinlock lockp)\r\n{\r\nacpi_cpu_flags flags;\r\nspin_lock_irqsave(lockp, flags);\r\nreturn flags;\r\n}\r\nvoid acpi_os_release_lock(acpi_spinlock lockp, acpi_cpu_flags flags)\r\n{\r\nspin_unlock_irqrestore(lockp, flags);\r\n}\r\nacpi_status\r\nacpi_os_create_cache(char *name, u16 size, u16 depth, acpi_cache_t ** cache)\r\n{\r\n*cache = kmem_cache_create(name, size, 0, 0, NULL);\r\nif (*cache == NULL)\r\nreturn AE_ERROR;\r\nelse\r\nreturn AE_OK;\r\n}\r\nacpi_status acpi_os_purge_cache(acpi_cache_t * cache)\r\n{\r\nkmem_cache_shrink(cache);\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_os_delete_cache(acpi_cache_t * cache)\r\n{\r\nkmem_cache_destroy(cache);\r\nreturn (AE_OK);\r\n}\r\nacpi_status acpi_os_release_object(acpi_cache_t * cache, void *object)\r\n{\r\nkmem_cache_free(cache, object);\r\nreturn (AE_OK);\r\n}\r\nstatic int __init acpi_no_static_ssdt_setup(char *s)\r\n{\r\nacpi_gbl_disable_ssdt_table_install = TRUE;\r\npr_info("ACPI: static SSDT installation disabled\n");\r\nreturn 0;\r\n}\r\nstatic int __init acpi_disable_return_repair(char *s)\r\n{\r\nprintk(KERN_NOTICE PREFIX\r\n"ACPI: Predefined validation mechanism disabled\n");\r\nacpi_gbl_disable_auto_repair = TRUE;\r\nreturn 1;\r\n}\r\nacpi_status __init acpi_os_initialize(void)\r\n{\r\nacpi_os_map_generic_address(&acpi_gbl_FADT.xpm1a_event_block);\r\nacpi_os_map_generic_address(&acpi_gbl_FADT.xpm1b_event_block);\r\nacpi_os_map_generic_address(&acpi_gbl_FADT.xgpe0_block);\r\nacpi_os_map_generic_address(&acpi_gbl_FADT.xgpe1_block);\r\nif (acpi_gbl_FADT.flags & ACPI_FADT_RESET_REGISTER) {\r\nint rv;\r\nrv = acpi_os_map_generic_address(&acpi_gbl_FADT.reset_register);\r\npr_debug(PREFIX "%s: map reset_reg status %d\n", __func__, rv);\r\n}\r\nreturn AE_OK;\r\n}\r\nacpi_status __init acpi_os_initialize1(void)\r\n{\r\nkacpid_wq = alloc_workqueue("kacpid", 0, 1);\r\nkacpi_notify_wq = alloc_workqueue("kacpi_notify", 0, 1);\r\nkacpi_hotplug_wq = alloc_ordered_workqueue("kacpi_hotplug", 0);\r\nBUG_ON(!kacpid_wq);\r\nBUG_ON(!kacpi_notify_wq);\r\nBUG_ON(!kacpi_hotplug_wq);\r\nacpi_install_interface_handler(acpi_osi_handler);\r\nacpi_osi_setup_late();\r\nreturn AE_OK;\r\n}\r\nacpi_status acpi_os_terminate(void)\r\n{\r\nif (acpi_irq_handler) {\r\nacpi_os_remove_interrupt_handler(acpi_gbl_FADT.sci_interrupt,\r\nacpi_irq_handler);\r\n}\r\nacpi_os_unmap_generic_address(&acpi_gbl_FADT.xgpe1_block);\r\nacpi_os_unmap_generic_address(&acpi_gbl_FADT.xgpe0_block);\r\nacpi_os_unmap_generic_address(&acpi_gbl_FADT.xpm1b_event_block);\r\nacpi_os_unmap_generic_address(&acpi_gbl_FADT.xpm1a_event_block);\r\nif (acpi_gbl_FADT.flags & ACPI_FADT_RESET_REGISTER)\r\nacpi_os_unmap_generic_address(&acpi_gbl_FADT.reset_register);\r\ndestroy_workqueue(kacpid_wq);\r\ndestroy_workqueue(kacpi_notify_wq);\r\ndestroy_workqueue(kacpi_hotplug_wq);\r\nreturn AE_OK;\r\n}\r\nacpi_status acpi_os_prepare_sleep(u8 sleep_state, u32 pm1a_control,\r\nu32 pm1b_control)\r\n{\r\nint rc = 0;\r\nif (__acpi_os_prepare_sleep)\r\nrc = __acpi_os_prepare_sleep(sleep_state,\r\npm1a_control, pm1b_control);\r\nif (rc < 0)\r\nreturn AE_ERROR;\r\nelse if (rc > 0)\r\nreturn AE_CTRL_SKIP;\r\nreturn AE_OK;\r\n}\r\nvoid acpi_os_set_prepare_sleep(int (*func)(u8 sleep_state,\r\nu32 pm1a_ctrl, u32 pm1b_ctrl))\r\n{\r\n__acpi_os_prepare_sleep = func;\r\n}\r\nacpi_status acpi_os_prepare_extended_sleep(u8 sleep_state, u32 val_a,\r\nu32 val_b)\r\n{\r\nint rc = 0;\r\nif (__acpi_os_prepare_extended_sleep)\r\nrc = __acpi_os_prepare_extended_sleep(sleep_state,\r\nval_a, val_b);\r\nif (rc < 0)\r\nreturn AE_ERROR;\r\nelse if (rc > 0)\r\nreturn AE_CTRL_SKIP;\r\nreturn AE_OK;\r\n}\r\nvoid acpi_os_set_prepare_extended_sleep(int (*func)(u8 sleep_state,\r\nu32 val_a, u32 val_b))\r\n{\r\n__acpi_os_prepare_extended_sleep = func;\r\n}
