static void nft_ct_get_eval(const struct nft_expr *expr,\r\nstruct nft_data data[NFT_REG_MAX + 1],\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_ct *priv = nft_expr_priv(expr);\r\nstruct nft_data *dest = &data[priv->dreg];\r\nenum ip_conntrack_info ctinfo;\r\nconst struct nf_conn *ct;\r\nconst struct nf_conn_help *help;\r\nconst struct nf_conntrack_tuple *tuple;\r\nconst struct nf_conntrack_helper *helper;\r\nlong diff;\r\nunsigned int state;\r\nct = nf_ct_get(pkt->skb, &ctinfo);\r\nswitch (priv->key) {\r\ncase NFT_CT_STATE:\r\nif (ct == NULL)\r\nstate = NF_CT_STATE_INVALID_BIT;\r\nelse if (nf_ct_is_untracked(ct))\r\nstate = NF_CT_STATE_UNTRACKED_BIT;\r\nelse\r\nstate = NF_CT_STATE_BIT(ctinfo);\r\ndest->data[0] = state;\r\nreturn;\r\n}\r\nif (ct == NULL)\r\ngoto err;\r\nswitch (priv->key) {\r\ncase NFT_CT_DIRECTION:\r\ndest->data[0] = CTINFO2DIR(ctinfo);\r\nreturn;\r\ncase NFT_CT_STATUS:\r\ndest->data[0] = ct->status;\r\nreturn;\r\n#ifdef CONFIG_NF_CONNTRACK_MARK\r\ncase NFT_CT_MARK:\r\ndest->data[0] = ct->mark;\r\nreturn;\r\n#endif\r\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\r\ncase NFT_CT_SECMARK:\r\ndest->data[0] = ct->secmark;\r\nreturn;\r\n#endif\r\ncase NFT_CT_EXPIRATION:\r\ndiff = (long)jiffies - (long)ct->timeout.expires;\r\nif (diff < 0)\r\ndiff = 0;\r\ndest->data[0] = jiffies_to_msecs(diff);\r\nreturn;\r\ncase NFT_CT_HELPER:\r\nif (ct->master == NULL)\r\ngoto err;\r\nhelp = nfct_help(ct->master);\r\nif (help == NULL)\r\ngoto err;\r\nhelper = rcu_dereference(help->helper);\r\nif (helper == NULL)\r\ngoto err;\r\nif (strlen(helper->name) >= sizeof(dest->data))\r\ngoto err;\r\nstrncpy((char *)dest->data, helper->name, sizeof(dest->data));\r\nreturn;\r\n#ifdef CONFIG_NF_CONNTRACK_LABELS\r\ncase NFT_CT_LABELS: {\r\nstruct nf_conn_labels *labels = nf_ct_labels_find(ct);\r\nunsigned int size;\r\nif (!labels) {\r\nmemset(dest->data, 0, sizeof(dest->data));\r\nreturn;\r\n}\r\nBUILD_BUG_ON(NF_CT_LABELS_MAX_SIZE > sizeof(dest->data));\r\nsize = labels->words * sizeof(long);\r\nmemcpy(dest->data, labels->bits, size);\r\nif (size < sizeof(dest->data))\r\nmemset(((char *) dest->data) + size, 0,\r\nsizeof(dest->data) - size);\r\nreturn;\r\n}\r\n#endif\r\n}\r\ntuple = &ct->tuplehash[priv->dir].tuple;\r\nswitch (priv->key) {\r\ncase NFT_CT_L3PROTOCOL:\r\ndest->data[0] = nf_ct_l3num(ct);\r\nreturn;\r\ncase NFT_CT_SRC:\r\nmemcpy(dest->data, tuple->src.u3.all,\r\nnf_ct_l3num(ct) == NFPROTO_IPV4 ? 4 : 16);\r\nreturn;\r\ncase NFT_CT_DST:\r\nmemcpy(dest->data, tuple->dst.u3.all,\r\nnf_ct_l3num(ct) == NFPROTO_IPV4 ? 4 : 16);\r\nreturn;\r\ncase NFT_CT_PROTOCOL:\r\ndest->data[0] = nf_ct_protonum(ct);\r\nreturn;\r\ncase NFT_CT_PROTO_SRC:\r\ndest->data[0] = (__force __u16)tuple->src.u.all;\r\nreturn;\r\ncase NFT_CT_PROTO_DST:\r\ndest->data[0] = (__force __u16)tuple->dst.u.all;\r\nreturn;\r\n}\r\nreturn;\r\nerr:\r\ndata[NFT_REG_VERDICT].verdict = NFT_BREAK;\r\n}\r\nstatic void nft_ct_set_eval(const struct nft_expr *expr,\r\nstruct nft_data data[NFT_REG_MAX + 1],\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_ct *priv = nft_expr_priv(expr);\r\nstruct sk_buff *skb = pkt->skb;\r\n#ifdef CONFIG_NF_CONNTRACK_MARK\r\nu32 value = data[priv->sreg].data[0];\r\n#endif\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct == NULL)\r\nreturn;\r\nswitch (priv->key) {\r\n#ifdef CONFIG_NF_CONNTRACK_MARK\r\ncase NFT_CT_MARK:\r\nif (ct->mark != value) {\r\nct->mark = value;\r\nnf_conntrack_event_cache(IPCT_MARK, ct);\r\n}\r\nbreak;\r\n#endif\r\n}\r\n}\r\nstatic int nft_ct_l3proto_try_module_get(uint8_t family)\r\n{\r\nint err;\r\nif (family == NFPROTO_INET) {\r\nerr = nf_ct_l3proto_try_module_get(NFPROTO_IPV4);\r\nif (err < 0)\r\ngoto err1;\r\nerr = nf_ct_l3proto_try_module_get(NFPROTO_IPV6);\r\nif (err < 0)\r\ngoto err2;\r\n} else {\r\nerr = nf_ct_l3proto_try_module_get(family);\r\nif (err < 0)\r\ngoto err1;\r\n}\r\nreturn 0;\r\nerr2:\r\nnf_ct_l3proto_module_put(NFPROTO_IPV4);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic void nft_ct_l3proto_module_put(uint8_t family)\r\n{\r\nif (family == NFPROTO_INET) {\r\nnf_ct_l3proto_module_put(NFPROTO_IPV4);\r\nnf_ct_l3proto_module_put(NFPROTO_IPV6);\r\n} else\r\nnf_ct_l3proto_module_put(family);\r\n}\r\nstatic int nft_ct_get_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_ct *priv = nft_expr_priv(expr);\r\nint err;\r\npriv->key = ntohl(nla_get_be32(tb[NFTA_CT_KEY]));\r\nswitch (priv->key) {\r\ncase NFT_CT_STATE:\r\ncase NFT_CT_DIRECTION:\r\ncase NFT_CT_STATUS:\r\n#ifdef CONFIG_NF_CONNTRACK_MARK\r\ncase NFT_CT_MARK:\r\n#endif\r\n#ifdef CONFIG_NF_CONNTRACK_SECMARK\r\ncase NFT_CT_SECMARK:\r\n#endif\r\n#ifdef CONFIG_NF_CONNTRACK_LABELS\r\ncase NFT_CT_LABELS:\r\n#endif\r\ncase NFT_CT_EXPIRATION:\r\ncase NFT_CT_HELPER:\r\nif (tb[NFTA_CT_DIRECTION] != NULL)\r\nreturn -EINVAL;\r\nbreak;\r\ncase NFT_CT_L3PROTOCOL:\r\ncase NFT_CT_PROTOCOL:\r\ncase NFT_CT_SRC:\r\ncase NFT_CT_DST:\r\ncase NFT_CT_PROTO_SRC:\r\ncase NFT_CT_PROTO_DST:\r\nif (tb[NFTA_CT_DIRECTION] == NULL)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (tb[NFTA_CT_DIRECTION] != NULL) {\r\npriv->dir = nla_get_u8(tb[NFTA_CT_DIRECTION]);\r\nswitch (priv->dir) {\r\ncase IP_CT_DIR_ORIGINAL:\r\ncase IP_CT_DIR_REPLY:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\npriv->dreg = ntohl(nla_get_be32(tb[NFTA_CT_DREG]));\r\nerr = nft_validate_output_register(priv->dreg);\r\nif (err < 0)\r\nreturn err;\r\nerr = nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);\r\nif (err < 0)\r\nreturn err;\r\nerr = nft_ct_l3proto_try_module_get(ctx->afi->family);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int nft_ct_set_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_ct *priv = nft_expr_priv(expr);\r\nint err;\r\npriv->key = ntohl(nla_get_be32(tb[NFTA_CT_KEY]));\r\nswitch (priv->key) {\r\n#ifdef CONFIG_NF_CONNTRACK_MARK\r\ncase NFT_CT_MARK:\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\npriv->sreg = ntohl(nla_get_be32(tb[NFTA_CT_SREG]));\r\nerr = nft_validate_input_register(priv->sreg);\r\nif (err < 0)\r\nreturn err;\r\nerr = nft_ct_l3proto_try_module_get(ctx->afi->family);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void nft_ct_destroy(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr)\r\n{\r\nnft_ct_l3proto_module_put(ctx->afi->family);\r\n}\r\nstatic int nft_ct_get_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_ct *priv = nft_expr_priv(expr);\r\nif (nla_put_be32(skb, NFTA_CT_DREG, htonl(priv->dreg)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_CT_KEY, htonl(priv->key)))\r\ngoto nla_put_failure;\r\nswitch (priv->key) {\r\ncase NFT_CT_PROTOCOL:\r\ncase NFT_CT_SRC:\r\ncase NFT_CT_DST:\r\ncase NFT_CT_PROTO_SRC:\r\ncase NFT_CT_PROTO_DST:\r\nif (nla_put_u8(skb, NFTA_CT_DIRECTION, priv->dir))\r\ngoto nla_put_failure;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int nft_ct_set_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_ct *priv = nft_expr_priv(expr);\r\nif (nla_put_be32(skb, NFTA_CT_SREG, htonl(priv->sreg)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_CT_KEY, htonl(priv->key)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_ct_select_ops(const struct nft_ctx *ctx,\r\nconst struct nlattr * const tb[])\r\n{\r\nif (tb[NFTA_CT_KEY] == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nif (tb[NFTA_CT_DREG] && tb[NFTA_CT_SREG])\r\nreturn ERR_PTR(-EINVAL);\r\nif (tb[NFTA_CT_DREG])\r\nreturn &nft_ct_get_ops;\r\nif (tb[NFTA_CT_SREG])\r\nreturn &nft_ct_set_ops;\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int __init nft_ct_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_ct_type);\r\n}\r\nstatic void __exit nft_ct_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_ct_type);\r\n}
