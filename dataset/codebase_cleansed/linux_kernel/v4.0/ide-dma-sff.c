int config_drive_for_dma(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu16 *id = drive->id;\r\nif (drive->media != ide_disk) {\r\nif (hwif->host_flags & IDE_HFLAG_NO_ATAPI_DMA)\r\nreturn 0;\r\n}\r\nif ((id[ATA_ID_FIELD_VALID] & 4) &&\r\n((id[ATA_ID_UDMA_MODES] >> 8) & 0x7f))\r\nreturn 1;\r\nif ((id[ATA_ID_MWDMA_MODES] & 0x404) == 0x404 ||\r\n(id[ATA_ID_SWDMA_MODES] & 0x404) == 0x404)\r\nreturn 1;\r\nif (ide_dma_good_drive(drive))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nu8 ide_dma_sff_read_status(ide_hwif_t *hwif)\r\n{\r\nunsigned long addr = hwif->dma_base + ATA_DMA_STATUS;\r\nif (hwif->host_flags & IDE_HFLAG_MMIO)\r\nreturn readb((void __iomem *)addr);\r\nelse\r\nreturn inb(addr);\r\n}\r\nstatic void ide_dma_sff_write_status(ide_hwif_t *hwif, u8 val)\r\n{\r\nunsigned long addr = hwif->dma_base + ATA_DMA_STATUS;\r\nif (hwif->host_flags & IDE_HFLAG_MMIO)\r\nwriteb(val, (void __iomem *)addr);\r\nelse\r\noutb(val, addr);\r\n}\r\nvoid ide_dma_host_set(ide_drive_t *drive, int on)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu8 unit = drive->dn & 1;\r\nu8 dma_stat = hwif->dma_ops->dma_sff_read_status(hwif);\r\nif (on)\r\ndma_stat |= (1 << (5 + unit));\r\nelse\r\ndma_stat &= ~(1 << (5 + unit));\r\nide_dma_sff_write_status(hwif, dma_stat);\r\n}\r\nint ide_build_dmatable(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\n__le32 *table = (__le32 *)hwif->dmatable_cpu;\r\nunsigned int count = 0;\r\nint i;\r\nstruct scatterlist *sg;\r\nu8 is_trm290 = !!(hwif->host_flags & IDE_HFLAG_TRM290);\r\nfor_each_sg(hwif->sg_table, sg, cmd->sg_nents, i) {\r\nu32 cur_addr, cur_len, xcount, bcount;\r\ncur_addr = sg_dma_address(sg);\r\ncur_len = sg_dma_len(sg);\r\nwhile (cur_len) {\r\nif (count++ >= PRD_ENTRIES)\r\ngoto use_pio_instead;\r\nbcount = 0x10000 - (cur_addr & 0xffff);\r\nif (bcount > cur_len)\r\nbcount = cur_len;\r\n*table++ = cpu_to_le32(cur_addr);\r\nxcount = bcount & 0xffff;\r\nif (is_trm290)\r\nxcount = ((xcount >> 2) - 1) << 16;\r\nelse if (xcount == 0x0000) {\r\nif (count++ >= PRD_ENTRIES)\r\ngoto use_pio_instead;\r\n*table++ = cpu_to_le32(0x8000);\r\n*table++ = cpu_to_le32(cur_addr + 0x8000);\r\nxcount = 0x8000;\r\n}\r\n*table++ = cpu_to_le32(xcount);\r\ncur_addr += bcount;\r\ncur_len -= bcount;\r\n}\r\n}\r\nif (count) {\r\nif (!is_trm290)\r\n*--table |= cpu_to_le32(0x80000000);\r\nreturn count;\r\n}\r\nuse_pio_instead:\r\nprintk(KERN_ERR "%s: %s\n", drive->name,\r\ncount ? "DMA table too small" : "empty DMA table?");\r\nreturn 0;\r\n}\r\nint ide_dma_setup(ide_drive_t *drive, struct ide_cmd *cmd)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;\r\nu8 rw = (cmd->tf_flags & IDE_TFLAG_WRITE) ? 0 : ATA_DMA_WR;\r\nu8 dma_stat;\r\nif (ide_build_dmatable(drive, cmd) == 0) {\r\nide_map_sg(drive, cmd);\r\nreturn 1;\r\n}\r\nif (mmio)\r\nwritel(hwif->dmatable_dma,\r\n(void __iomem *)(hwif->dma_base + ATA_DMA_TABLE_OFS));\r\nelse\r\noutl(hwif->dmatable_dma, hwif->dma_base + ATA_DMA_TABLE_OFS);\r\nif (mmio)\r\nwriteb(rw, (void __iomem *)(hwif->dma_base + ATA_DMA_CMD));\r\nelse\r\noutb(rw, hwif->dma_base + ATA_DMA_CMD);\r\ndma_stat = hwif->dma_ops->dma_sff_read_status(hwif);\r\nide_dma_sff_write_status(hwif, dma_stat | ATA_DMA_ERR | ATA_DMA_INTR);\r\nreturn 0;\r\n}\r\nint ide_dma_sff_timer_expiry(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu8 dma_stat = hwif->dma_ops->dma_sff_read_status(hwif);\r\nprintk(KERN_WARNING "%s: %s: DMA status (0x%02x)\n",\r\ndrive->name, __func__, dma_stat);\r\nif ((dma_stat & 0x18) == 0x18)\r\nreturn WAIT_CMD;\r\nhwif->expiry = NULL;\r\nif (dma_stat & ATA_DMA_ERR)\r\nreturn -1;\r\nif (dma_stat & ATA_DMA_ACTIVE)\r\nreturn WAIT_CMD;\r\nif (dma_stat & ATA_DMA_INTR)\r\nreturn WAIT_CMD;\r\nreturn 0;\r\n}\r\nvoid ide_dma_start(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu8 dma_cmd;\r\nif (hwif->host_flags & IDE_HFLAG_MMIO) {\r\ndma_cmd = readb((void __iomem *)(hwif->dma_base + ATA_DMA_CMD));\r\nwriteb(dma_cmd | ATA_DMA_START,\r\n(void __iomem *)(hwif->dma_base + ATA_DMA_CMD));\r\n} else {\r\ndma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);\r\noutb(dma_cmd | ATA_DMA_START, hwif->dma_base + ATA_DMA_CMD);\r\n}\r\n}\r\nint ide_dma_end(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu8 dma_stat = 0, dma_cmd = 0;\r\nif (hwif->host_flags & IDE_HFLAG_MMIO) {\r\ndma_cmd = readb((void __iomem *)(hwif->dma_base + ATA_DMA_CMD));\r\nwriteb(dma_cmd & ~ATA_DMA_START,\r\n(void __iomem *)(hwif->dma_base + ATA_DMA_CMD));\r\n} else {\r\ndma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);\r\noutb(dma_cmd & ~ATA_DMA_START, hwif->dma_base + ATA_DMA_CMD);\r\n}\r\ndma_stat = hwif->dma_ops->dma_sff_read_status(hwif);\r\nide_dma_sff_write_status(hwif, dma_stat | ATA_DMA_ERR | ATA_DMA_INTR);\r\n#define CHECK_DMA_MASK (ATA_DMA_ACTIVE | ATA_DMA_ERR | ATA_DMA_INTR)\r\nif ((dma_stat & CHECK_DMA_MASK) != ATA_DMA_INTR)\r\nreturn 0x10 | dma_stat;\r\nreturn 0;\r\n}\r\nint ide_dma_test_irq(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu8 dma_stat = hwif->dma_ops->dma_sff_read_status(hwif);\r\nreturn (dma_stat & ATA_DMA_INTR) ? 1 : 0;\r\n}
