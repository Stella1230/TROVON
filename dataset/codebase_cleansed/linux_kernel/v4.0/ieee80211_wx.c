static inline char *rtl819x_translate_scan(struct ieee80211_device *ieee,\r\nchar *start, char *stop,\r\nstruct ieee80211_network *network,\r\nstruct iw_request_info *info)\r\n{\r\nchar custom[MAX_CUSTOM_LEN];\r\nchar proto_name[IFNAMSIZ];\r\nchar *pname = proto_name;\r\nchar *p;\r\nstruct iw_event iwe;\r\nint i, j;\r\nu16 max_rate, rate;\r\nstatic u8 EWC11NHTCap[] = {0x00, 0x90, 0x4c, 0x33};\r\niwe.cmd = SIOCGIWAP;\r\niwe.u.ap_addr.sa_family = ARPHRD_ETHER;\r\nmemcpy(iwe.u.ap_addr.sa_data, network->bssid, ETH_ALEN);\r\nstart = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_ADDR_LEN);\r\niwe.cmd = SIOCGIWESSID;\r\niwe.u.data.flags = 1;\r\nif (network->ssid_len == 0) {\r\niwe.u.data.length = sizeof("<hidden>");\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, "<hidden>");\r\n} else {\r\niwe.u.data.length = min(network->ssid_len, (u8)32);\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, network->ssid);\r\n}\r\niwe.cmd = SIOCGIWNAME;\r\nfor(i=0; i<ARRAY_SIZE(ieee80211_modes); i++) {\r\nif(network->mode&(1<<i)) {\r\nsprintf(pname,ieee80211_modes[i].mode_string,ieee80211_modes[i].mode_size);\r\npname +=ieee80211_modes[i].mode_size;\r\n}\r\n}\r\n*pname = '\0';\r\nsnprintf(iwe.u.name, IFNAMSIZ, "IEEE802.11%s", proto_name);\r\nstart = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_CHAR_LEN);\r\niwe.cmd = SIOCGIWMODE;\r\nif (network->capability &\r\n(WLAN_CAPABILITY_BSS | WLAN_CAPABILITY_IBSS)) {\r\nif (network->capability & WLAN_CAPABILITY_BSS)\r\niwe.u.mode = IW_MODE_MASTER;\r\nelse\r\niwe.u.mode = IW_MODE_ADHOC;\r\nstart = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_UINT_LEN);\r\n}\r\niwe.cmd = SIOCGIWFREQ;\r\niwe.u.freq.m = network->channel;\r\niwe.u.freq.e = 0;\r\niwe.u.freq.i = 0;\r\nstart = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_FREQ_LEN);\r\niwe.cmd = SIOCGIWENCODE;\r\nif (network->capability & WLAN_CAPABILITY_PRIVACY)\r\niwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\r\nelse\r\niwe.u.data.flags = IW_ENCODE_DISABLED;\r\niwe.u.data.length = 0;\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, network->ssid);\r\nmax_rate = 0;\r\np = custom;\r\np += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Rates (Mb/s): ");\r\nfor (i = 0, j = 0; i < network->rates_len; ) {\r\nif (j < network->rates_ex_len &&\r\n((network->rates_ex[j] & 0x7F) <\r\n(network->rates[i] & 0x7F)))\r\nrate = network->rates_ex[j++] & 0x7F;\r\nelse\r\nrate = network->rates[i++] & 0x7F;\r\nif (rate > max_rate)\r\nmax_rate = rate;\r\np += snprintf(p, MAX_CUSTOM_LEN - (p - custom),\r\n"%d%s ", rate >> 1, (rate & 1) ? ".5" : "");\r\n}\r\nfor (; j < network->rates_ex_len; j++) {\r\nrate = network->rates_ex[j] & 0x7F;\r\np += snprintf(p, MAX_CUSTOM_LEN - (p - custom),\r\n"%d%s ", rate >> 1, (rate & 1) ? ".5" : "");\r\nif (rate > max_rate)\r\nmax_rate = rate;\r\n}\r\nif (network->mode >= IEEE_N_24G)\r\n{\r\nPHT_CAPABILITY_ELE ht_cap = NULL;\r\nbool is40M = false, isShortGI = false;\r\nu8 max_mcs = 0;\r\nif (!memcmp(network->bssht.bdHTCapBuf, EWC11NHTCap, 4))\r\nht_cap = (PHT_CAPABILITY_ELE)&network->bssht.bdHTCapBuf[4];\r\nelse\r\nht_cap = (PHT_CAPABILITY_ELE)&network->bssht.bdHTCapBuf[0];\r\nis40M = (ht_cap->ChlWidth)?1:0;\r\nisShortGI = (ht_cap->ChlWidth)?\r\n((ht_cap->ShortGI40Mhz)?1:0):\r\n((ht_cap->ShortGI20Mhz)?1:0);\r\nmax_mcs = HTGetHighestMCSRate(ieee, ht_cap->MCS, MCS_FILTER_ALL);\r\nrate = MCS_DATA_RATE[is40M][isShortGI][max_mcs&0x7f];\r\nif (rate > max_rate)\r\nmax_rate = rate;\r\n}\r\niwe.cmd = SIOCGIWRATE;\r\niwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;\r\niwe.u.bitrate.value = max_rate * 500000;\r\nstart = iwe_stream_add_event_rsl(info, start, stop, &iwe,\r\nIW_EV_PARAM_LEN);\r\niwe.cmd = IWEVCUSTOM;\r\niwe.u.data.length = p - custom;\r\nif (iwe.u.data.length)\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, custom);\r\niwe.cmd = IWEVQUAL;\r\niwe.u.qual.qual = network->stats.signal;\r\niwe.u.qual.level = network->stats.rssi;\r\niwe.u.qual.noise = network->stats.noise;\r\niwe.u.qual.updated = network->stats.mask & IEEE80211_STATMASK_WEMASK;\r\nif (!(network->stats.mask & IEEE80211_STATMASK_RSSI))\r\niwe.u.qual.updated |= IW_QUAL_LEVEL_INVALID;\r\nif (!(network->stats.mask & IEEE80211_STATMASK_NOISE))\r\niwe.u.qual.updated |= IW_QUAL_NOISE_INVALID;\r\nif (!(network->stats.mask & IEEE80211_STATMASK_SIGNAL))\r\niwe.u.qual.updated |= IW_QUAL_QUAL_INVALID;\r\niwe.u.qual.updated = 7;\r\nstart = iwe_stream_add_event_rsl(info, start, stop, &iwe, IW_EV_QUAL_LEN);\r\niwe.cmd = IWEVCUSTOM;\r\np = custom;\r\niwe.u.data.length = p - custom;\r\nif (iwe.u.data.length)\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, custom);\r\nif (ieee->wpa_enabled && network->wpa_ie_len){\r\nchar buf[MAX_WPA_IE_LEN * 2 + 30];\r\nu8 *p = buf;\r\np += sprintf(p, "wpa_ie=");\r\nfor (i = 0; i < network->wpa_ie_len; i++) {\r\np += sprintf(p, "%02x", network->wpa_ie[i]);\r\n}\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVCUSTOM;\r\niwe.u.data.length = strlen(buf);\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, buf);\r\n}\r\nif (ieee->wpa_enabled && network->rsn_ie_len){\r\nchar buf[MAX_WPA_IE_LEN * 2 + 30];\r\nu8 *p = buf;\r\np += sprintf(p, "rsn_ie=");\r\nfor (i = 0; i < network->rsn_ie_len; i++) {\r\np += sprintf(p, "%02x", network->rsn_ie[i]);\r\n}\r\nmemset(&iwe, 0, sizeof(iwe));\r\niwe.cmd = IWEVCUSTOM;\r\niwe.u.data.length = strlen(buf);\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, buf);\r\n}\r\niwe.cmd = IWEVCUSTOM;\r\np = custom;\r\np += snprintf(p, MAX_CUSTOM_LEN - (p - custom),\r\n" Last beacon: %lums ago", (jiffies - network->last_scanned) / (HZ / 100));\r\niwe.u.data.length = p - custom;\r\nif (iwe.u.data.length)\r\nstart = iwe_stream_add_point(info, start, stop, &iwe, custom);\r\nreturn start;\r\n}\r\nint ieee80211_wx_get_scan(struct ieee80211_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct ieee80211_network *network;\r\nunsigned long flags;\r\nchar *ev = extra;\r\nchar *stop = ev + wrqu->data.length;\r\nint i = 0;\r\nint err = 0;\r\nIEEE80211_DEBUG_WX("Getting scan\n");\r\ndown(&ieee->wx_sem);\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nlist_for_each_entry(network, &ieee->network_list, list) {\r\ni++;\r\nif((stop-ev)<200)\r\n{\r\nerr = -E2BIG;\r\nbreak;\r\n}\r\nif (ieee->scan_age == 0 ||\r\ntime_after(network->last_scanned + ieee->scan_age, jiffies))\r\nev = rtl819x_translate_scan(ieee, ev, stop, network, info);\r\nelse\r\nIEEE80211_DEBUG_SCAN(\r\n"Not showing network '%s ("\r\n"%pM)' due to age (%lums).\n",\r\nescape_essid(network->ssid,\r\nnetwork->ssid_len),\r\nnetwork->bssid,\r\n(jiffies - network->last_scanned) / (HZ / 100));\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nup(&ieee->wx_sem);\r\nwrqu->data.length = ev - extra;\r\nwrqu->data.flags = 0;\r\nIEEE80211_DEBUG_WX("exit: %d networks returned.\n", i);\r\nreturn err;\r\n}\r\nint ieee80211_wx_set_encode(struct ieee80211_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *keybuf)\r\n{\r\nstruct iw_point *erq = &(wrqu->encoding);\r\nstruct net_device *dev = ieee->dev;\r\nstruct ieee80211_security sec = {\r\n.flags = 0\r\n};\r\nint i, key, key_provided, len;\r\nstruct ieee80211_crypt_data **crypt;\r\nIEEE80211_DEBUG_WX("SET_ENCODE\n");\r\nkey = erq->flags & IW_ENCODE_INDEX;\r\nif (key) {\r\nif (key > WEP_KEYS)\r\nreturn -EINVAL;\r\nkey--;\r\nkey_provided = 1;\r\n} else {\r\nkey_provided = 0;\r\nkey = ieee->tx_keyidx;\r\n}\r\nIEEE80211_DEBUG_WX("Key: %d [%s]\n", key, key_provided ?\r\n"provided" : "default");\r\ncrypt = &ieee->crypt[key];\r\nif (erq->flags & IW_ENCODE_DISABLED) {\r\nif (key_provided && *crypt) {\r\nIEEE80211_DEBUG_WX("Disabling encryption on key %d.\n",\r\nkey);\r\nieee80211_crypt_delayed_deinit(ieee, crypt);\r\n} else\r\nIEEE80211_DEBUG_WX("Disabling encryption.\n");\r\nfor (i = 0; i < WEP_KEYS; i++) {\r\nif (ieee->crypt[i] != NULL) {\r\nif (key_provided)\r\nbreak;\r\nieee80211_crypt_delayed_deinit(\r\nieee, &ieee->crypt[i]);\r\n}\r\n}\r\nif (i == WEP_KEYS) {\r\nsec.enabled = 0;\r\nsec.level = SEC_LEVEL_0;\r\nsec.flags |= SEC_ENABLED | SEC_LEVEL;\r\n}\r\ngoto done;\r\n}\r\nsec.enabled = 1;\r\nsec.flags |= SEC_ENABLED;\r\nif (*crypt != NULL && (*crypt)->ops != NULL &&\r\nstrcmp((*crypt)->ops->name, "WEP") != 0) {\r\nieee80211_crypt_delayed_deinit(ieee, crypt);\r\n}\r\nif (*crypt == NULL) {\r\nstruct ieee80211_crypt_data *new_crypt;\r\nnew_crypt = kzalloc(sizeof(struct ieee80211_crypt_data),\r\nGFP_KERNEL);\r\nif (new_crypt == NULL)\r\nreturn -ENOMEM;\r\nnew_crypt->ops = ieee80211_get_crypto_ops("WEP");\r\nif (!new_crypt->ops) {\r\nrequest_module("ieee80211_crypt_wep");\r\nnew_crypt->ops = ieee80211_get_crypto_ops("WEP");\r\n}\r\nif (new_crypt->ops && try_module_get(new_crypt->ops->owner))\r\nnew_crypt->priv = new_crypt->ops->init(key);\r\nif (!new_crypt->ops || !new_crypt->priv) {\r\nkfree(new_crypt);\r\nnew_crypt = NULL;\r\nprintk(KERN_WARNING "%s: could not initialize WEP: "\r\n"load module ieee80211_crypt_wep\n",\r\ndev->name);\r\nreturn -EOPNOTSUPP;\r\n}\r\n*crypt = new_crypt;\r\n}\r\nif (erq->length > 0) {\r\nlen = erq->length <= 5 ? 5 : 13;\r\nmemcpy(sec.keys[key], keybuf, erq->length);\r\nif (len > erq->length)\r\nmemset(sec.keys[key] + erq->length, 0,\r\nlen - erq->length);\r\nIEEE80211_DEBUG_WX("Setting key %d to '%s' (%d:%d bytes)\n",\r\nkey, escape_essid(sec.keys[key], len),\r\nerq->length, len);\r\nsec.key_sizes[key] = len;\r\n(*crypt)->ops->set_key(sec.keys[key], len, NULL,\r\n(*crypt)->priv);\r\nsec.flags |= (1 << key);\r\nif (key == sec.active_key)\r\nsec.flags |= SEC_ACTIVE_KEY;\r\nieee->tx_keyidx = key;\r\n} else {\r\nlen = (*crypt)->ops->get_key(sec.keys[key], WEP_KEY_LEN,\r\nNULL, (*crypt)->priv);\r\nif (len == 0) {\r\nprintk("Setting key %d to all zero.\n",\r\nkey);\r\nIEEE80211_DEBUG_WX("Setting key %d to all zero.\n",\r\nkey);\r\nmemset(sec.keys[key], 0, 13);\r\n(*crypt)->ops->set_key(sec.keys[key], 13, NULL,\r\n(*crypt)->priv);\r\nsec.key_sizes[key] = 13;\r\nsec.flags |= (1 << key);\r\n}\r\nif (key_provided) {\r\nIEEE80211_DEBUG_WX(\r\n"Setting key %d to default Tx key.\n", key);\r\nieee->tx_keyidx = key;\r\nsec.active_key = key;\r\nsec.flags |= SEC_ACTIVE_KEY;\r\n}\r\n}\r\ndone:\r\nieee->open_wep = !(erq->flags & IW_ENCODE_RESTRICTED);\r\nieee->auth_mode = ieee->open_wep ? WLAN_AUTH_OPEN : WLAN_AUTH_SHARED_KEY;\r\nsec.auth_mode = ieee->open_wep ? WLAN_AUTH_OPEN : WLAN_AUTH_SHARED_KEY;\r\nsec.flags |= SEC_AUTH_MODE;\r\nIEEE80211_DEBUG_WX("Auth: %s\n", sec.auth_mode == WLAN_AUTH_OPEN ?\r\n"OPEN" : "SHARED KEY");\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_1;\r\nif (ieee->set_security)\r\nieee->set_security(dev, &sec);\r\nif (ieee->reset_on_keychange &&\r\nieee->iw_mode != IW_MODE_INFRA &&\r\nieee->reset_port && ieee->reset_port(dev)) {\r\nprintk(KERN_DEBUG "%s: reset_port failed\n", dev->name);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint ieee80211_wx_get_encode(struct ieee80211_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *keybuf)\r\n{\r\nstruct iw_point *erq = &(wrqu->encoding);\r\nint len, key;\r\nstruct ieee80211_crypt_data *crypt;\r\nIEEE80211_DEBUG_WX("GET_ENCODE\n");\r\nif(ieee->iw_mode == IW_MODE_MONITOR)\r\nreturn -1;\r\nkey = erq->flags & IW_ENCODE_INDEX;\r\nif (key) {\r\nif (key > WEP_KEYS)\r\nreturn -EINVAL;\r\nkey--;\r\n} else\r\nkey = ieee->tx_keyidx;\r\ncrypt = ieee->crypt[key];\r\nerq->flags = key + 1;\r\nif (crypt == NULL || crypt->ops == NULL) {\r\nerq->length = 0;\r\nerq->flags |= IW_ENCODE_DISABLED;\r\nreturn 0;\r\n}\r\nlen = crypt->ops->get_key(keybuf, SCM_KEY_LEN, NULL, crypt->priv);\r\nerq->length = (len >= 0 ? len : 0);\r\nerq->flags |= IW_ENCODE_ENABLED;\r\nif (ieee->open_wep)\r\nerq->flags |= IW_ENCODE_OPEN;\r\nelse\r\nerq->flags |= IW_ENCODE_RESTRICTED;\r\nreturn 0;\r\n}\r\nint ieee80211_wx_set_encode_ext(struct ieee80211_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nint ret = 0;\r\nstruct net_device *dev = ieee->dev;\r\nstruct iw_point *encoding = &wrqu->encoding;\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\r\nint i, idx;\r\nint group_key = 0;\r\nconst char *alg, *module;\r\nstruct ieee80211_crypto_ops *ops;\r\nstruct ieee80211_crypt_data **crypt;\r\nstruct ieee80211_security sec = {\r\n.flags = 0,\r\n};\r\nidx = encoding->flags & IW_ENCODE_INDEX;\r\nif (idx) {\r\nif (idx < 1 || idx > WEP_KEYS)\r\nreturn -EINVAL;\r\nidx--;\r\n} else\r\nidx = ieee->tx_keyidx;\r\nif (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {\r\ncrypt = &ieee->crypt[idx];\r\ngroup_key = 1;\r\n} else {\r\nif (idx != 0 && ext->alg != IW_ENCODE_ALG_WEP)\r\nreturn -EINVAL;\r\nif (ieee->iw_mode == IW_MODE_INFRA)\r\ncrypt = &ieee->crypt[idx];\r\nelse\r\nreturn -EINVAL;\r\n}\r\nsec.flags |= SEC_ENABLED;\r\nif ((encoding->flags & IW_ENCODE_DISABLED) ||\r\next->alg == IW_ENCODE_ALG_NONE) {\r\nif (*crypt)\r\nieee80211_crypt_delayed_deinit(ieee, crypt);\r\nfor (i = 0; i < WEP_KEYS; i++)\r\nif (ieee->crypt[i] != NULL)\r\nbreak;\r\nif (i == WEP_KEYS) {\r\nsec.enabled = 0;\r\nsec.level = SEC_LEVEL_0;\r\nsec.flags |= SEC_LEVEL;\r\n}\r\ngoto done;\r\n}\r\nsec.enabled = 1;\r\nswitch (ext->alg) {\r\ncase IW_ENCODE_ALG_WEP:\r\nalg = "WEP";\r\nmodule = "ieee80211_crypt_wep";\r\nbreak;\r\ncase IW_ENCODE_ALG_TKIP:\r\nalg = "TKIP";\r\nmodule = "ieee80211_crypt_tkip";\r\nbreak;\r\ncase IW_ENCODE_ALG_CCMP:\r\nalg = "CCMP";\r\nmodule = "ieee80211_crypt_ccmp";\r\nbreak;\r\ndefault:\r\nIEEE80211_DEBUG_WX("%s: unknown crypto alg %d\n",\r\ndev->name, ext->alg);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nprintk("alg name:%s\n",alg);\r\nops = ieee80211_get_crypto_ops(alg);\r\nif (ops == NULL) {\r\nrequest_module(module);\r\nops = ieee80211_get_crypto_ops(alg);\r\n}\r\nif (ops == NULL) {\r\nIEEE80211_DEBUG_WX("%s: unknown crypto alg %d\n",\r\ndev->name, ext->alg);\r\nprintk("========>unknown crypto alg %d\n", ext->alg);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (*crypt == NULL || (*crypt)->ops != ops) {\r\nstruct ieee80211_crypt_data *new_crypt;\r\nieee80211_crypt_delayed_deinit(ieee, crypt);\r\nnew_crypt = kzalloc(sizeof(*new_crypt), GFP_KERNEL);\r\nif (new_crypt == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nnew_crypt->ops = ops;\r\nif (new_crypt->ops && try_module_get(new_crypt->ops->owner))\r\nnew_crypt->priv = new_crypt->ops->init(idx);\r\nif (new_crypt->priv == NULL) {\r\nkfree(new_crypt);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\n*crypt = new_crypt;\r\n}\r\nif (ext->key_len > 0 && (*crypt)->ops->set_key &&\r\n(*crypt)->ops->set_key(ext->key, ext->key_len, ext->rx_seq,\r\n(*crypt)->priv) < 0) {\r\nIEEE80211_DEBUG_WX("%s: key setting failed\n", dev->name);\r\nprintk("key setting failed\n");\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\r\nieee->tx_keyidx = idx;\r\nsec.active_key = idx;\r\nsec.flags |= SEC_ACTIVE_KEY;\r\n}\r\nif (ext->alg != IW_ENCODE_ALG_NONE) {\r\nsec.key_sizes[idx] = ext->key_len;\r\nsec.flags |= (1 << idx);\r\nif (ext->alg == IW_ENCODE_ALG_WEP) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_1;\r\n} else if (ext->alg == IW_ENCODE_ALG_TKIP) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_2;\r\n} else if (ext->alg == IW_ENCODE_ALG_CCMP) {\r\nsec.flags |= SEC_LEVEL;\r\nsec.level = SEC_LEVEL_3;\r\n}\r\nif (group_key)\r\nsec.flags &= ~SEC_LEVEL;\r\n}\r\ndone:\r\nif (ieee->set_security)\r\nieee->set_security(ieee->dev, &sec);\r\nif (ieee->reset_on_keychange &&\r\nieee->iw_mode != IW_MODE_INFRA &&\r\nieee->reset_port && ieee->reset_port(dev)) {\r\nIEEE80211_DEBUG_WX("%s: reset_port failed\n", dev->name);\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nint ieee80211_wx_get_encode_ext(struct ieee80211_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct iw_point *encoding = &wrqu->encoding;\r\nstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\r\nstruct ieee80211_crypt_data *crypt;\r\nint idx, max_key_len;\r\nmax_key_len = encoding->length - sizeof(*ext);\r\nif (max_key_len < 0)\r\nreturn -EINVAL;\r\nidx = encoding->flags & IW_ENCODE_INDEX;\r\nif (idx) {\r\nif (idx < 1 || idx > WEP_KEYS)\r\nreturn -EINVAL;\r\nidx--;\r\n} else\r\nidx = ieee->tx_keyidx;\r\nif (!(ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) &&\r\next->alg != IW_ENCODE_ALG_WEP)\r\nif (idx != 0 || ieee->iw_mode != IW_MODE_INFRA)\r\nreturn -EINVAL;\r\ncrypt = ieee->crypt[idx];\r\nencoding->flags = idx + 1;\r\nmemset(ext, 0, sizeof(*ext));\r\nif (crypt == NULL || crypt->ops == NULL ) {\r\next->alg = IW_ENCODE_ALG_NONE;\r\next->key_len = 0;\r\nencoding->flags |= IW_ENCODE_DISABLED;\r\n} else {\r\nif (strcmp(crypt->ops->name, "WEP") == 0 )\r\next->alg = IW_ENCODE_ALG_WEP;\r\nelse if (strcmp(crypt->ops->name, "TKIP"))\r\next->alg = IW_ENCODE_ALG_TKIP;\r\nelse if (strcmp(crypt->ops->name, "CCMP"))\r\next->alg = IW_ENCODE_ALG_CCMP;\r\nelse\r\nreturn -EINVAL;\r\next->key_len = crypt->ops->get_key(ext->key, SCM_KEY_LEN, NULL, crypt->priv);\r\nencoding->flags |= IW_ENCODE_ENABLED;\r\nif (ext->key_len &&\r\n(ext->alg == IW_ENCODE_ALG_TKIP ||\r\next->alg == IW_ENCODE_ALG_CCMP))\r\next->ext_flags |= IW_ENCODE_EXT_TX_SEQ_VALID;\r\n}\r\nreturn 0;\r\n}\r\nint ieee80211_wx_set_mlme(struct ieee80211_device *ieee,\r\nstruct iw_request_info *info,\r\nunion iwreq_data *wrqu, char *extra)\r\n{\r\nstruct iw_mlme *mlme = (struct iw_mlme *) extra;\r\nswitch (mlme->cmd) {\r\ncase IW_MLME_DEAUTH:\r\ncase IW_MLME_DISASSOC:\r\nieee80211_disassociate(ieee);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nint ieee80211_wx_set_auth(struct ieee80211_device *ieee,\r\nstruct iw_request_info *info,\r\nstruct iw_param *data, char *extra)\r\n{\r\nswitch (data->flags & IW_AUTH_INDEX) {\r\ncase IW_AUTH_WPA_VERSION:\r\nbreak;\r\ncase IW_AUTH_CIPHER_PAIRWISE:\r\ncase IW_AUTH_CIPHER_GROUP:\r\ncase IW_AUTH_KEY_MGMT:\r\nbreak;\r\ncase IW_AUTH_TKIP_COUNTERMEASURES:\r\nieee->tkip_countermeasures = data->value;\r\nbreak;\r\ncase IW_AUTH_DROP_UNENCRYPTED:\r\nieee->drop_unencrypted = data->value;\r\nbreak;\r\ncase IW_AUTH_80211_AUTH_ALG:\r\nif(data->value & IW_AUTH_ALG_SHARED_KEY){\r\nieee->open_wep = 0;\r\nieee->auth_mode = 1;\r\n}\r\nelse if(data->value & IW_AUTH_ALG_OPEN_SYSTEM){\r\nieee->open_wep = 1;\r\nieee->auth_mode = 0;\r\n}\r\nelse if(data->value & IW_AUTH_ALG_LEAP){\r\nieee->open_wep = 1;\r\nieee->auth_mode = 2;\r\n}\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase IW_AUTH_WPA_ENABLED:\r\nieee->wpa_enabled = (data->value)?1:0;\r\nbreak;\r\ncase IW_AUTH_RX_UNENCRYPTED_EAPOL:\r\nieee->ieee802_1x = data->value;\r\nbreak;\r\ncase IW_AUTH_PRIVACY_INVOKED:\r\nieee->privacy_invoked = data->value;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nint ieee80211_wx_set_gen_ie(struct ieee80211_device *ieee, u8 *ie, size_t len)\r\n{\r\nu8 *buf;\r\nif (len>MAX_WPA_IE_LEN || (len && ie == NULL))\r\n{\r\nreturn -EINVAL;\r\n}\r\nif (len)\r\n{\r\nif (len != ie[1]+2)\r\n{\r\nprintk("len:%zu, ie:%d\n", len, ie[1]);\r\nreturn -EINVAL;\r\n}\r\nbuf = kmemdup(ie, len, GFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nkfree(ieee->wpa_ie);\r\nieee->wpa_ie = buf;\r\nieee->wpa_ie_len = len;\r\n}\r\nelse{\r\nkfree(ieee->wpa_ie);\r\nieee->wpa_ie = NULL;\r\nieee->wpa_ie_len = 0;\r\n}\r\nreturn 0;\r\n}
