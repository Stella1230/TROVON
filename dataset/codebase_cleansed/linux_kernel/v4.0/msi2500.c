static struct msi2500_frame_buf *msi2500_get_next_fill_buf(\r\nstruct msi2500_state *s)\r\n{\r\nunsigned long flags;\r\nstruct msi2500_frame_buf *buf = NULL;\r\nspin_lock_irqsave(&s->queued_bufs_lock, flags);\r\nif (list_empty(&s->queued_bufs))\r\ngoto leave;\r\nbuf = list_entry(s->queued_bufs.next, struct msi2500_frame_buf, list);\r\nlist_del(&buf->list);\r\nleave:\r\nspin_unlock_irqrestore(&s->queued_bufs_lock, flags);\r\nreturn buf;\r\n}\r\nstatic int msi2500_convert_stream(struct msi2500_state *s, u8 *dst, u8 *src,\r\nunsigned int src_len)\r\n{\r\nunsigned int i, j, transactions, dst_len = 0;\r\nu32 sample[3];\r\ntransactions = src_len / 1024;\r\nfor (i = 0; i < transactions; i++) {\r\nsample[i] = src[3] << 24 | src[2] << 16 | src[1] << 8 |\r\nsrc[0] << 0;\r\nif (i == 0 && s->next_sample != sample[0]) {\r\ndev_dbg_ratelimited(s->dev,\r\n"%d samples lost, %d %08x:%08x\n",\r\nsample[0] - s->next_sample,\r\nsrc_len, s->next_sample, sample[0]);\r\n}\r\ndev_dbg_ratelimited(s->dev, "%*ph\n", 12, &src[4]);\r\nsrc += 16;\r\nswitch (s->pixelformat) {\r\ncase V4L2_SDR_FMT_CU8:\r\n{\r\ns8 *s8src = (s8 *) src;\r\nu8 *u8dst = (u8 *) dst;\r\nfor (j = 0; j < 1008; j++)\r\n*u8dst++ = *s8src++ + 128;\r\nsrc += 1008;\r\ndst += 1008;\r\ndst_len += 1008;\r\ns->next_sample = sample[i] + 504;\r\nbreak;\r\n}\r\ncase V4L2_SDR_FMT_CU16LE:\r\n{\r\ns16 *s16src = (s16 *) src;\r\nu16 *u16dst = (u16 *) dst;\r\nstruct {signed int x:14; } se;\r\nunsigned int utmp;\r\nfor (j = 0; j < 1008; j += 2) {\r\nse.x = *s16src++;\r\nutmp = se.x + 8192;\r\n*u16dst++ = utmp << 2 | utmp >> 12;\r\n}\r\nsrc += 1008;\r\ndst += 1008;\r\ndst_len += 1008;\r\ns->next_sample = sample[i] + 252;\r\nbreak;\r\n}\r\ncase MSI2500_PIX_FMT_SDR_MSI2500_384:\r\ndev_dbg_ratelimited(s->dev, "%*ph\n", 24, &src[1000]);\r\nmemcpy(dst, src, 984);\r\nsrc += 984 + 24;\r\ndst += 984;\r\ndst_len += 984;\r\ns->next_sample = sample[i] + 384;\r\nbreak;\r\ncase V4L2_SDR_FMT_CS8:\r\nmemcpy(dst, src, 1008);\r\nsrc += 1008;\r\ndst += 1008;\r\ndst_len += 1008;\r\ns->next_sample = sample[i] + 504;\r\nbreak;\r\ncase MSI2500_PIX_FMT_SDR_S12:\r\nmemcpy(dst, src, 1008);\r\nsrc += 1008;\r\ndst += 1008;\r\ndst_len += 1008;\r\ns->next_sample = sample[i] + 336;\r\nbreak;\r\ncase V4L2_SDR_FMT_CS14LE:\r\nmemcpy(dst, src, 1008);\r\nsrc += 1008;\r\ndst += 1008;\r\ndst_len += 1008;\r\ns->next_sample = sample[i] + 252;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (unlikely(time_is_before_jiffies(s->jiffies_next))) {\r\n#define MSECS 10000UL\r\nunsigned int msecs = jiffies_to_msecs(jiffies -\r\ns->jiffies_next + msecs_to_jiffies(MSECS));\r\nunsigned int samples = s->next_sample - s->sample;\r\ns->jiffies_next = jiffies + msecs_to_jiffies(MSECS);\r\ns->sample = s->next_sample;\r\ndev_dbg(s->dev, "size=%u samples=%u msecs=%u sample rate=%lu\n",\r\nsrc_len, samples, msecs,\r\nsamples * 1000UL / msecs);\r\n}\r\nreturn dst_len;\r\n}\r\nstatic void msi2500_isoc_handler(struct urb *urb)\r\n{\r\nstruct msi2500_state *s = (struct msi2500_state *)urb->context;\r\nint i, flen, fstatus;\r\nunsigned char *iso_buf = NULL;\r\nstruct msi2500_frame_buf *fbuf;\r\nif (unlikely(urb->status == -ENOENT || urb->status == -ECONNRESET ||\r\nurb->status == -ESHUTDOWN)) {\r\ndev_dbg(s->dev, "URB (%p) unlinked %ssynchronuously\n",\r\nurb, urb->status == -ENOENT ? "" : "a");\r\nreturn;\r\n}\r\nif (unlikely(urb->status != 0)) {\r\ndev_dbg(s->dev, "called with status %d\n", urb->status);\r\nif (++s->isoc_errors > MAX_ISOC_ERRORS)\r\ndev_dbg(s->dev, "Too many ISOC errors, bailing out\n");\r\ngoto handler_end;\r\n} else {\r\ns->isoc_errors = 0;\r\n}\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nvoid *ptr;\r\nfstatus = urb->iso_frame_desc[i].status;\r\nif (unlikely(fstatus)) {\r\ndev_dbg_ratelimited(s->dev,\r\n"frame=%d/%d has error %d skipping\n",\r\ni, urb->number_of_packets, fstatus);\r\ncontinue;\r\n}\r\nflen = urb->iso_frame_desc[i].actual_length;\r\nif (unlikely(flen == 0))\r\ncontinue;\r\niso_buf = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\r\nfbuf = msi2500_get_next_fill_buf(s);\r\nif (unlikely(fbuf == NULL)) {\r\ns->vb_full++;\r\ndev_dbg_ratelimited(s->dev,\r\n"videobuf is full, %d packets dropped\n",\r\ns->vb_full);\r\ncontinue;\r\n}\r\nptr = vb2_plane_vaddr(&fbuf->vb, 0);\r\nflen = msi2500_convert_stream(s, ptr, iso_buf, flen);\r\nvb2_set_plane_payload(&fbuf->vb, 0, flen);\r\nvb2_buffer_done(&fbuf->vb, VB2_BUF_STATE_DONE);\r\n}\r\nhandler_end:\r\ni = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (unlikely(i != 0))\r\ndev_dbg(s->dev, "Error (%d) re-submitting urb\n", i);\r\n}\r\nstatic void msi2500_iso_stop(struct msi2500_state *s)\r\n{\r\nint i;\r\ndev_dbg(s->dev, "\n");\r\nfor (i = 0; i < MAX_ISO_BUFS; i++) {\r\nif (s->urbs[i]) {\r\ndev_dbg(s->dev, "Unlinking URB %p\n", s->urbs[i]);\r\nusb_kill_urb(s->urbs[i]);\r\n}\r\n}\r\n}\r\nstatic void msi2500_iso_free(struct msi2500_state *s)\r\n{\r\nint i;\r\ndev_dbg(s->dev, "\n");\r\nfor (i = 0; i < MAX_ISO_BUFS; i++) {\r\nif (s->urbs[i]) {\r\ndev_dbg(s->dev, "Freeing URB\n");\r\nif (s->urbs[i]->transfer_buffer) {\r\nusb_free_coherent(s->udev,\r\ns->urbs[i]->transfer_buffer_length,\r\ns->urbs[i]->transfer_buffer,\r\ns->urbs[i]->transfer_dma);\r\n}\r\nusb_free_urb(s->urbs[i]);\r\ns->urbs[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic void msi2500_isoc_cleanup(struct msi2500_state *s)\r\n{\r\ndev_dbg(s->dev, "\n");\r\nmsi2500_iso_stop(s);\r\nmsi2500_iso_free(s);\r\n}\r\nstatic int msi2500_isoc_init(struct msi2500_state *s)\r\n{\r\nstruct urb *urb;\r\nint i, j, ret;\r\ndev_dbg(s->dev, "\n");\r\ns->isoc_errors = 0;\r\nret = usb_set_interface(s->udev, 0, 1);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < MAX_ISO_BUFS; i++) {\r\nurb = usb_alloc_urb(ISO_FRAMES_PER_DESC, GFP_KERNEL);\r\nif (urb == NULL) {\r\ndev_err(s->dev, "Failed to allocate urb %d\n", i);\r\nmsi2500_isoc_cleanup(s);\r\nreturn -ENOMEM;\r\n}\r\ns->urbs[i] = urb;\r\ndev_dbg(s->dev, "Allocated URB at 0x%p\n", urb);\r\nurb->interval = 1;\r\nurb->dev = s->udev;\r\nurb->pipe = usb_rcvisocpipe(s->udev, 0x81);\r\nurb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\r\nurb->transfer_buffer = usb_alloc_coherent(s->udev,\r\nISO_BUFFER_SIZE,\r\nGFP_KERNEL, &urb->transfer_dma);\r\nif (urb->transfer_buffer == NULL) {\r\ndev_err(s->dev, "Failed to allocate urb buffer %d\n",\r\ni);\r\nmsi2500_isoc_cleanup(s);\r\nreturn -ENOMEM;\r\n}\r\nurb->transfer_buffer_length = ISO_BUFFER_SIZE;\r\nurb->complete = msi2500_isoc_handler;\r\nurb->context = s;\r\nurb->start_frame = 0;\r\nurb->number_of_packets = ISO_FRAMES_PER_DESC;\r\nfor (j = 0; j < ISO_FRAMES_PER_DESC; j++) {\r\nurb->iso_frame_desc[j].offset = j * ISO_MAX_FRAME_SIZE;\r\nurb->iso_frame_desc[j].length = ISO_MAX_FRAME_SIZE;\r\n}\r\n}\r\nfor (i = 0; i < MAX_ISO_BUFS; i++) {\r\nret = usb_submit_urb(s->urbs[i], GFP_KERNEL);\r\nif (ret) {\r\ndev_err(s->dev, "usb_submit_urb %d failed with error %d\n",\r\ni, ret);\r\nmsi2500_isoc_cleanup(s);\r\nreturn ret;\r\n}\r\ndev_dbg(s->dev, "URB 0x%p submitted.\n", s->urbs[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void msi2500_cleanup_queued_bufs(struct msi2500_state *s)\r\n{\r\nunsigned long flags;\r\ndev_dbg(s->dev, "\n");\r\nspin_lock_irqsave(&s->queued_bufs_lock, flags);\r\nwhile (!list_empty(&s->queued_bufs)) {\r\nstruct msi2500_frame_buf *buf;\r\nbuf = list_entry(s->queued_bufs.next, struct msi2500_frame_buf,\r\nlist);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&s->queued_bufs_lock, flags);\r\n}\r\nstatic void msi2500_disconnect(struct usb_interface *intf)\r\n{\r\nstruct v4l2_device *v = usb_get_intfdata(intf);\r\nstruct msi2500_state *s =\r\ncontainer_of(v, struct msi2500_state, v4l2_dev);\r\ndev_dbg(s->dev, "\n");\r\nmutex_lock(&s->vb_queue_lock);\r\nmutex_lock(&s->v4l2_lock);\r\ns->udev = NULL;\r\nv4l2_device_disconnect(&s->v4l2_dev);\r\nvideo_unregister_device(&s->vdev);\r\nspi_unregister_master(s->master);\r\nmutex_unlock(&s->v4l2_lock);\r\nmutex_unlock(&s->vb_queue_lock);\r\nv4l2_device_put(&s->v4l2_dev);\r\n}\r\nstatic int msi2500_querycap(struct file *file, void *fh,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct msi2500_state *s = video_drvdata(file);\r\ndev_dbg(s->dev, "\n");\r\nstrlcpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, s->vdev.name, sizeof(cap->card));\r\nusb_make_path(s->udev, cap->bus_info, sizeof(cap->bus_info));\r\ncap->device_caps = V4L2_CAP_SDR_CAPTURE | V4L2_CAP_STREAMING |\r\nV4L2_CAP_READWRITE | V4L2_CAP_TUNER;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int msi2500_queue_setup(struct vb2_queue *vq,\r\nconst struct v4l2_format *fmt, unsigned int *nbuffers,\r\nunsigned int *nplanes, unsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct msi2500_state *s = vb2_get_drv_priv(vq);\r\ndev_dbg(s->dev, "nbuffers=%d\n", *nbuffers);\r\n*nbuffers = clamp_t(unsigned int, *nbuffers, 8, 32);\r\n*nplanes = 1;\r\nsizes[0] = PAGE_ALIGN(s->buffersize);\r\ndev_dbg(s->dev, "nbuffers=%d sizes[0]=%d\n", *nbuffers, sizes[0]);\r\nreturn 0;\r\n}\r\nstatic void msi2500_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct msi2500_state *s = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct msi2500_frame_buf *buf =\r\ncontainer_of(vb, struct msi2500_frame_buf, vb);\r\nunsigned long flags;\r\nif (unlikely(!s->udev)) {\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&s->queued_bufs_lock, flags);\r\nlist_add_tail(&buf->list, &s->queued_bufs);\r\nspin_unlock_irqrestore(&s->queued_bufs_lock, flags);\r\n}\r\nstatic int msi2500_ctrl_msg(struct msi2500_state *s, u8 cmd, u32 data)\r\n{\r\nint ret;\r\nu8 request = cmd;\r\nu8 requesttype = USB_DIR_OUT | USB_TYPE_VENDOR;\r\nu16 value = (data >> 0) & 0xffff;\r\nu16 index = (data >> 16) & 0xffff;\r\nmsi2500_dbg_usb_control_msg(s->dev,\r\nrequest, requesttype, value, index, NULL, 0);\r\nret = usb_control_msg(s->udev, usb_sndctrlpipe(s->udev, 0),\r\nrequest, requesttype, value, index, NULL, 0, 2000);\r\nif (ret)\r\ndev_err(s->dev, "failed %d, cmd %02x, data %04x\n",\r\nret, cmd, data);\r\nreturn ret;\r\n}\r\nstatic int msi2500_set_usb_adc(struct msi2500_state *s)\r\n{\r\nint ret, div_n, div_m, div_r_out, f_sr, f_vco, fract;\r\nu32 reg3, reg4, reg7;\r\nstruct v4l2_ctrl *bandwidth_auto;\r\nstruct v4l2_ctrl *bandwidth;\r\nf_sr = s->f_adc;\r\nbandwidth_auto = v4l2_ctrl_find(&s->hdl,\r\nV4L2_CID_RF_TUNER_BANDWIDTH_AUTO);\r\nif (v4l2_ctrl_g_ctrl(bandwidth_auto)) {\r\nbandwidth = v4l2_ctrl_find(&s->hdl,\r\nV4L2_CID_RF_TUNER_BANDWIDTH);\r\nv4l2_ctrl_s_ctrl(bandwidth, s->f_adc);\r\n}\r\nswitch (s->pixelformat) {\r\ncase V4L2_SDR_FMT_CU8:\r\nreg7 = 0x000c9407;\r\nbreak;\r\ncase V4L2_SDR_FMT_CU16LE:\r\nreg7 = 0x00009407;\r\nbreak;\r\ncase V4L2_SDR_FMT_CS8:\r\nreg7 = 0x000c9407;\r\nbreak;\r\ncase MSI2500_PIX_FMT_SDR_MSI2500_384:\r\nreg7 = 0x0000a507;\r\nbreak;\r\ncase MSI2500_PIX_FMT_SDR_S12:\r\nreg7 = 0x00008507;\r\nbreak;\r\ncase V4L2_SDR_FMT_CS14LE:\r\nreg7 = 0x00009407;\r\nbreak;\r\ndefault:\r\nreg7 = 0x000c9407;\r\nbreak;\r\n}\r\nreg3 = 0x01000303;\r\nreg4 = 0x00000004;\r\nif (f_sr < 6000000)\r\nreg3 |= 0x1 << 20;\r\nelse if (f_sr < 7000000)\r\nreg3 |= 0x5 << 20;\r\nelse if (f_sr < 8500000)\r\nreg3 |= 0x9 << 20;\r\nelse\r\nreg3 |= 0xd << 20;\r\nfor (div_r_out = 4; div_r_out < 16; div_r_out += 2) {\r\nf_vco = f_sr * div_r_out * 12;\r\ndev_dbg(s->dev, "div_r_out=%d f_vco=%d\n", div_r_out, f_vco);\r\nif (f_vco >= 202000000)\r\nbreak;\r\n}\r\ndiv_n = f_vco / (F_REF * DIV_R_IN);\r\ndiv_m = f_vco % (F_REF * DIV_R_IN);\r\nfract = 0x200000ul * div_m / (F_REF * DIV_R_IN);\r\nreg3 |= div_n << 16;\r\nreg3 |= (div_r_out / 2 - 1) << 10;\r\nreg3 |= ((fract >> 20) & 0x000001) << 15;\r\nreg4 |= ((fract >> 0) & 0x0fffff) << 8;\r\ndev_dbg(s->dev, "f_sr=%d f_vco=%d div_n=%d div_m=%d div_r_out=%d reg3=%08x reg4=%08x\n",\r\nf_sr, f_vco, div_n, div_m, div_r_out, reg3, reg4);\r\nret = msi2500_ctrl_msg(s, CMD_WREG, 0x00608008);\r\nif (ret)\r\ngoto err;\r\nret = msi2500_ctrl_msg(s, CMD_WREG, 0x00000c05);\r\nif (ret)\r\ngoto err;\r\nret = msi2500_ctrl_msg(s, CMD_WREG, 0x00020000);\r\nif (ret)\r\ngoto err;\r\nret = msi2500_ctrl_msg(s, CMD_WREG, 0x00480102);\r\nif (ret)\r\ngoto err;\r\nret = msi2500_ctrl_msg(s, CMD_WREG, 0x00f38008);\r\nif (ret)\r\ngoto err;\r\nret = msi2500_ctrl_msg(s, CMD_WREG, reg7);\r\nif (ret)\r\ngoto err;\r\nret = msi2500_ctrl_msg(s, CMD_WREG, reg4);\r\nif (ret)\r\ngoto err;\r\nret = msi2500_ctrl_msg(s, CMD_WREG, reg3);\r\nif (ret)\r\ngoto err;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int msi2500_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct msi2500_state *s = vb2_get_drv_priv(vq);\r\nint ret;\r\ndev_dbg(s->dev, "\n");\r\nif (!s->udev)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&s->v4l2_lock))\r\nreturn -ERESTARTSYS;\r\nv4l2_subdev_call(s->v4l2_subdev, core, s_power, 1);\r\nret = msi2500_set_usb_adc(s);\r\nret = msi2500_isoc_init(s);\r\nif (ret)\r\nmsi2500_cleanup_queued_bufs(s);\r\nret = msi2500_ctrl_msg(s, CMD_START_STREAMING, 0);\r\nmutex_unlock(&s->v4l2_lock);\r\nreturn ret;\r\n}\r\nstatic void msi2500_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct msi2500_state *s = vb2_get_drv_priv(vq);\r\ndev_dbg(s->dev, "\n");\r\nmutex_lock(&s->v4l2_lock);\r\nif (s->udev)\r\nmsi2500_isoc_cleanup(s);\r\nmsi2500_cleanup_queued_bufs(s);\r\nmsleep(20);\r\nif (!msi2500_ctrl_msg(s, CMD_STOP_STREAMING, 0)) {\r\nmsi2500_ctrl_msg(s, CMD_WREG, 0x01000003);\r\n}\r\nv4l2_subdev_call(s->v4l2_subdev, core, s_power, 0);\r\nmutex_unlock(&s->v4l2_lock);\r\n}\r\nstatic int msi2500_enum_fmt_sdr_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct msi2500_state *s = video_drvdata(file);\r\ndev_dbg(s->dev, "index=%d\n", f->index);\r\nif (f->index >= s->num_formats)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, formats[f->index].name, sizeof(f->description));\r\nf->pixelformat = formats[f->index].pixelformat;\r\nreturn 0;\r\n}\r\nstatic int msi2500_g_fmt_sdr_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct msi2500_state *s = video_drvdata(file);\r\ndev_dbg(s->dev, "pixelformat fourcc %4.4s\n",\r\n(char *)&s->pixelformat);\r\nf->fmt.sdr.pixelformat = s->pixelformat;\r\nf->fmt.sdr.buffersize = s->buffersize;\r\nmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\r\nreturn 0;\r\n}\r\nstatic int msi2500_s_fmt_sdr_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct msi2500_state *s = video_drvdata(file);\r\nstruct vb2_queue *q = &s->vb_queue;\r\nint i;\r\ndev_dbg(s->dev, "pixelformat fourcc %4.4s\n",\r\n(char *)&f->fmt.sdr.pixelformat);\r\nif (vb2_is_busy(q))\r\nreturn -EBUSY;\r\nmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\r\nfor (i = 0; i < s->num_formats; i++) {\r\nif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\r\ns->pixelformat = formats[i].pixelformat;\r\ns->buffersize = formats[i].buffersize;\r\nf->fmt.sdr.buffersize = formats[i].buffersize;\r\nreturn 0;\r\n}\r\n}\r\ns->pixelformat = formats[0].pixelformat;\r\ns->buffersize = formats[0].buffersize;\r\nf->fmt.sdr.pixelformat = formats[0].pixelformat;\r\nf->fmt.sdr.buffersize = formats[0].buffersize;\r\nreturn 0;\r\n}\r\nstatic int msi2500_try_fmt_sdr_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct msi2500_state *s = video_drvdata(file);\r\nint i;\r\ndev_dbg(s->dev, "pixelformat fourcc %4.4s\n",\r\n(char *)&f->fmt.sdr.pixelformat);\r\nmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\r\nfor (i = 0; i < s->num_formats; i++) {\r\nif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\r\nf->fmt.sdr.buffersize = formats[i].buffersize;\r\nreturn 0;\r\n}\r\n}\r\nf->fmt.sdr.pixelformat = formats[0].pixelformat;\r\nf->fmt.sdr.buffersize = formats[0].buffersize;\r\nreturn 0;\r\n}\r\nstatic int msi2500_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *v)\r\n{\r\nstruct msi2500_state *s = video_drvdata(file);\r\nint ret;\r\ndev_dbg(s->dev, "index=%d\n", v->index);\r\nif (v->index == 0)\r\nret = 0;\r\nelse if (v->index == 1)\r\nret = v4l2_subdev_call(s->v4l2_subdev, tuner, s_tuner, v);\r\nelse\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int msi2500_g_tuner(struct file *file, void *priv, struct v4l2_tuner *v)\r\n{\r\nstruct msi2500_state *s = video_drvdata(file);\r\nint ret;\r\ndev_dbg(s->dev, "index=%d\n", v->index);\r\nif (v->index == 0) {\r\nstrlcpy(v->name, "Mirics MSi2500", sizeof(v->name));\r\nv->type = V4L2_TUNER_ADC;\r\nv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\r\nv->rangelow = 1200000;\r\nv->rangehigh = 15000000;\r\nret = 0;\r\n} else if (v->index == 1) {\r\nret = v4l2_subdev_call(s->v4l2_subdev, tuner, g_tuner, v);\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int msi2500_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct msi2500_state *s = video_drvdata(file);\r\nint ret = 0;\r\ndev_dbg(s->dev, "tuner=%d type=%d\n", f->tuner, f->type);\r\nif (f->tuner == 0) {\r\nf->frequency = s->f_adc;\r\nret = 0;\r\n} else if (f->tuner == 1) {\r\nf->type = V4L2_TUNER_RF;\r\nret = v4l2_subdev_call(s->v4l2_subdev, tuner, g_frequency, f);\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int msi2500_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct msi2500_state *s = video_drvdata(file);\r\nint ret;\r\ndev_dbg(s->dev, "tuner=%d type=%d frequency=%u\n",\r\nf->tuner, f->type, f->frequency);\r\nif (f->tuner == 0) {\r\ns->f_adc = clamp_t(unsigned int, f->frequency,\r\nbands[0].rangelow,\r\nbands[0].rangehigh);\r\ndev_dbg(s->dev, "ADC frequency=%u Hz\n", s->f_adc);\r\nret = msi2500_set_usb_adc(s);\r\n} else if (f->tuner == 1) {\r\nret = v4l2_subdev_call(s->v4l2_subdev, tuner, s_frequency, f);\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int msi2500_enum_freq_bands(struct file *file, void *priv,\r\nstruct v4l2_frequency_band *band)\r\n{\r\nstruct msi2500_state *s = video_drvdata(file);\r\nint ret;\r\ndev_dbg(s->dev, "tuner=%d type=%d index=%d\n",\r\nband->tuner, band->type, band->index);\r\nif (band->tuner == 0) {\r\nif (band->index >= ARRAY_SIZE(bands)) {\r\nret = -EINVAL;\r\n} else {\r\n*band = bands[band->index];\r\nret = 0;\r\n}\r\n} else if (band->tuner == 1) {\r\nret = v4l2_subdev_call(s->v4l2_subdev, tuner,\r\nenum_freq_bands, band);\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void msi2500_video_release(struct v4l2_device *v)\r\n{\r\nstruct msi2500_state *s =\r\ncontainer_of(v, struct msi2500_state, v4l2_dev);\r\nv4l2_ctrl_handler_free(&s->hdl);\r\nv4l2_device_unregister(&s->v4l2_dev);\r\nkfree(s);\r\n}\r\nstatic int msi2500_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *m)\r\n{\r\nstruct msi2500_state *s = spi_master_get_devdata(master);\r\nstruct spi_transfer *t;\r\nint ret = 0;\r\nu32 data;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\ndev_dbg(s->dev, "msg=%*ph\n", t->len, t->tx_buf);\r\ndata = 0x09;\r\ndata |= ((u8 *)t->tx_buf)[0] << 8;\r\ndata |= ((u8 *)t->tx_buf)[1] << 16;\r\ndata |= ((u8 *)t->tx_buf)[2] << 24;\r\nret = msi2500_ctrl_msg(s, CMD_WREG, data);\r\n}\r\nm->status = ret;\r\nspi_finalize_current_message(master);\r\nreturn ret;\r\n}\r\nstatic int msi2500_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct msi2500_state *s;\r\nstruct v4l2_subdev *sd;\r\nstruct spi_master *master;\r\nint ret;\r\nstatic struct spi_board_info board_info = {\r\n.modalias = "msi001",\r\n.bus_num = 0,\r\n.chip_select = 0,\r\n.max_speed_hz = 12000000,\r\n};\r\ns = kzalloc(sizeof(struct msi2500_state), GFP_KERNEL);\r\nif (s == NULL) {\r\ndev_err(&intf->dev, "Could not allocate memory for state\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&s->v4l2_lock);\r\nmutex_init(&s->vb_queue_lock);\r\nspin_lock_init(&s->queued_bufs_lock);\r\nINIT_LIST_HEAD(&s->queued_bufs);\r\ns->dev = &intf->dev;\r\ns->udev = interface_to_usbdev(intf);\r\ns->f_adc = bands[0].rangelow;\r\ns->pixelformat = formats[0].pixelformat;\r\ns->buffersize = formats[0].buffersize;\r\ns->num_formats = NUM_FORMATS;\r\nif (!msi2500_emulated_fmt)\r\ns->num_formats -= 2;\r\ns->vb_queue.type = V4L2_BUF_TYPE_SDR_CAPTURE;\r\ns->vb_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\r\ns->vb_queue.drv_priv = s;\r\ns->vb_queue.buf_struct_size = sizeof(struct msi2500_frame_buf);\r\ns->vb_queue.ops = &msi2500_vb2_ops;\r\ns->vb_queue.mem_ops = &vb2_vmalloc_memops;\r\ns->vb_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nret = vb2_queue_init(&s->vb_queue);\r\nif (ret) {\r\ndev_err(s->dev, "Could not initialize vb2 queue\n");\r\ngoto err_free_mem;\r\n}\r\ns->vdev = msi2500_template;\r\ns->vdev.queue = &s->vb_queue;\r\ns->vdev.queue->lock = &s->vb_queue_lock;\r\nvideo_set_drvdata(&s->vdev, s);\r\ns->v4l2_dev.release = msi2500_video_release;\r\nret = v4l2_device_register(&intf->dev, &s->v4l2_dev);\r\nif (ret) {\r\ndev_err(s->dev, "Failed to register v4l2-device (%d)\n", ret);\r\ngoto err_free_mem;\r\n}\r\nmaster = spi_alloc_master(s->dev, 0);\r\nif (master == NULL) {\r\nret = -ENOMEM;\r\ngoto err_unregister_v4l2_dev;\r\n}\r\ns->master = master;\r\nmaster->bus_num = 0;\r\nmaster->num_chipselect = 1;\r\nmaster->transfer_one_message = msi2500_transfer_one_message;\r\nspi_master_set_devdata(master, s);\r\nret = spi_register_master(master);\r\nif (ret) {\r\nspi_master_put(master);\r\ngoto err_unregister_v4l2_dev;\r\n}\r\nsd = v4l2_spi_new_subdev(&s->v4l2_dev, master, &board_info);\r\ns->v4l2_subdev = sd;\r\nif (sd == NULL) {\r\ndev_err(s->dev, "cannot get v4l2 subdevice\n");\r\nret = -ENODEV;\r\ngoto err_unregister_master;\r\n}\r\nv4l2_ctrl_handler_init(&s->hdl, 0);\r\nif (s->hdl.error) {\r\nret = s->hdl.error;\r\ndev_err(s->dev, "Could not initialize controls\n");\r\ngoto err_free_controls;\r\n}\r\nv4l2_ctrl_add_handler(&s->hdl, sd->ctrl_handler, NULL);\r\ns->v4l2_dev.ctrl_handler = &s->hdl;\r\ns->vdev.v4l2_dev = &s->v4l2_dev;\r\ns->vdev.lock = &s->v4l2_lock;\r\nret = video_register_device(&s->vdev, VFL_TYPE_SDR, -1);\r\nif (ret) {\r\ndev_err(s->dev, "Failed to register as video device (%d)\n",\r\nret);\r\ngoto err_unregister_v4l2_dev;\r\n}\r\ndev_info(s->dev, "Registered as %s\n",\r\nvideo_device_node_name(&s->vdev));\r\ndev_notice(s->dev, "SDR API is still slightly experimental and functionality changes may follow\n");\r\nreturn 0;\r\nerr_free_controls:\r\nv4l2_ctrl_handler_free(&s->hdl);\r\nerr_unregister_master:\r\nspi_unregister_master(s->master);\r\nerr_unregister_v4l2_dev:\r\nv4l2_device_unregister(&s->v4l2_dev);\r\nerr_free_mem:\r\nkfree(s);\r\nreturn ret;\r\n}
