int thread__init_map_groups(struct thread *thread, struct machine *machine)\r\n{\r\nstruct thread *leader;\r\npid_t pid = thread->pid_;\r\nif (pid == thread->tid || pid == -1) {\r\nthread->mg = map_groups__new(machine);\r\n} else {\r\nleader = machine__findnew_thread(machine, pid, pid);\r\nif (leader)\r\nthread->mg = map_groups__get(leader->mg);\r\n}\r\nreturn thread->mg ? 0 : -1;\r\n}\r\nstruct thread *thread__new(pid_t pid, pid_t tid)\r\n{\r\nchar *comm_str;\r\nstruct comm *comm;\r\nstruct thread *thread = zalloc(sizeof(*thread));\r\nif (thread != NULL) {\r\nthread->pid_ = pid;\r\nthread->tid = tid;\r\nthread->ppid = -1;\r\nthread->cpu = -1;\r\nINIT_LIST_HEAD(&thread->comm_list);\r\nif (unwind__prepare_access(thread) < 0)\r\ngoto err_thread;\r\ncomm_str = malloc(32);\r\nif (!comm_str)\r\ngoto err_thread;\r\nsnprintf(comm_str, 32, ":%d", tid);\r\ncomm = comm__new(comm_str, 0, false);\r\nfree(comm_str);\r\nif (!comm)\r\ngoto err_thread;\r\nlist_add(&comm->list, &thread->comm_list);\r\n}\r\nreturn thread;\r\nerr_thread:\r\nfree(thread);\r\nreturn NULL;\r\n}\r\nvoid thread__delete(struct thread *thread)\r\n{\r\nstruct comm *comm, *tmp;\r\nthread_stack__free(thread);\r\nif (thread->mg) {\r\nmap_groups__put(thread->mg);\r\nthread->mg = NULL;\r\n}\r\nlist_for_each_entry_safe(comm, tmp, &thread->comm_list, list) {\r\nlist_del(&comm->list);\r\ncomm__free(comm);\r\n}\r\nunwind__finish_access(thread);\r\nfree(thread);\r\n}\r\nstruct comm *thread__comm(const struct thread *thread)\r\n{\r\nif (list_empty(&thread->comm_list))\r\nreturn NULL;\r\nreturn list_first_entry(&thread->comm_list, struct comm, list);\r\n}\r\nstruct comm *thread__exec_comm(const struct thread *thread)\r\n{\r\nstruct comm *comm, *last = NULL;\r\nlist_for_each_entry(comm, &thread->comm_list, list) {\r\nif (comm->exec)\r\nreturn comm;\r\nlast = comm;\r\n}\r\nreturn last;\r\n}\r\nint __thread__set_comm(struct thread *thread, const char *str, u64 timestamp,\r\nbool exec)\r\n{\r\nstruct comm *new, *curr = thread__comm(thread);\r\nint err;\r\nif (!thread->comm_set) {\r\nerr = comm__override(curr, str, timestamp, exec);\r\nif (err)\r\nreturn err;\r\n} else {\r\nnew = comm__new(str, timestamp, exec);\r\nif (!new)\r\nreturn -ENOMEM;\r\nlist_add(&new->list, &thread->comm_list);\r\nif (exec)\r\nunwind__flush_access(thread);\r\n}\r\nthread->comm_set = true;\r\nreturn 0;\r\n}\r\nconst char *thread__comm_str(const struct thread *thread)\r\n{\r\nconst struct comm *comm = thread__comm(thread);\r\nif (!comm)\r\nreturn NULL;\r\nreturn comm__str(comm);\r\n}\r\nint thread__comm_len(struct thread *thread)\r\n{\r\nif (!thread->comm_len) {\r\nconst char *comm = thread__comm_str(thread);\r\nif (!comm)\r\nreturn 0;\r\nthread->comm_len = strlen(comm);\r\n}\r\nreturn thread->comm_len;\r\n}\r\nsize_t thread__fprintf(struct thread *thread, FILE *fp)\r\n{\r\nreturn fprintf(fp, "Thread %d %s\n", thread->tid, thread__comm_str(thread)) +\r\nmap_groups__fprintf(thread->mg, fp);\r\n}\r\nvoid thread__insert_map(struct thread *thread, struct map *map)\r\n{\r\nmap_groups__fixup_overlappings(thread->mg, map, stderr);\r\nmap_groups__insert(thread->mg, map);\r\n}\r\nstatic int thread__clone_map_groups(struct thread *thread,\r\nstruct thread *parent)\r\n{\r\nint i;\r\nif (thread->pid_ == parent->pid_)\r\nreturn 0;\r\nfor (i = 0; i < MAP__NR_TYPES; ++i)\r\nif (map_groups__clone(thread->mg, parent->mg, i) < 0)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint thread__fork(struct thread *thread, struct thread *parent, u64 timestamp)\r\n{\r\nint err;\r\nif (parent->comm_set) {\r\nconst char *comm = thread__comm_str(parent);\r\nif (!comm)\r\nreturn -ENOMEM;\r\nerr = thread__set_comm(thread, comm, timestamp);\r\nif (err)\r\nreturn err;\r\nthread->comm_set = true;\r\n}\r\nthread->ppid = parent->tid;\r\nreturn thread__clone_map_groups(thread, parent);\r\n}\r\nvoid thread__find_cpumode_addr_location(struct thread *thread,\r\nenum map_type type, u64 addr,\r\nstruct addr_location *al)\r\n{\r\nsize_t i;\r\nconst u8 const cpumodes[] = {\r\nPERF_RECORD_MISC_USER,\r\nPERF_RECORD_MISC_KERNEL,\r\nPERF_RECORD_MISC_GUEST_USER,\r\nPERF_RECORD_MISC_GUEST_KERNEL\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(cpumodes); i++) {\r\nthread__find_addr_location(thread, cpumodes[i], type, addr, al);\r\nif (al->map)\r\nbreak;\r\n}\r\n}
