static int init_hw(struct echoaudio *chip, u16 device_id, u16 subdevice_id)\r\n{\r\nint err;\r\nif (snd_BUG_ON((subdevice_id & 0xfff0) != LAYLA20))\r\nreturn -ENODEV;\r\nif ((err = init_dsp_comm_page(chip))) {\r\ndev_err(chip->card->dev,\r\n"init_hw - could not initialize DSP comm page\n");\r\nreturn err;\r\n}\r\nchip->device_id = device_id;\r\nchip->subdevice_id = subdevice_id;\r\nchip->bad_board = TRUE;\r\nchip->has_midi = TRUE;\r\nchip->dsp_code_to_load = FW_LAYLA20_DSP;\r\nchip->input_clock_types =\r\nECHO_CLOCK_BIT_INTERNAL | ECHO_CLOCK_BIT_SPDIF |\r\nECHO_CLOCK_BIT_WORD | ECHO_CLOCK_BIT_SUPER;\r\nchip->output_clock_types =\r\nECHO_CLOCK_BIT_WORD | ECHO_CLOCK_BIT_SUPER;\r\nif ((err = load_firmware(chip)) < 0)\r\nreturn err;\r\nchip->bad_board = FALSE;\r\nreturn err;\r\n}\r\nstatic int set_mixer_defaults(struct echoaudio *chip)\r\n{\r\nchip->professional_spdif = FALSE;\r\nreturn init_line_levels(chip);\r\n}\r\nstatic u32 detect_input_clocks(const struct echoaudio *chip)\r\n{\r\nu32 clocks_from_dsp, clock_bits;\r\nclocks_from_dsp = le32_to_cpu(chip->comm_page->status_clocks);\r\nclock_bits = ECHO_CLOCK_BIT_INTERNAL;\r\nif (clocks_from_dsp & GLDM_CLOCK_DETECT_BIT_SPDIF)\r\nclock_bits |= ECHO_CLOCK_BIT_SPDIF;\r\nif (clocks_from_dsp & GLDM_CLOCK_DETECT_BIT_WORD) {\r\nif (clocks_from_dsp & GLDM_CLOCK_DETECT_BIT_SUPER)\r\nclock_bits |= ECHO_CLOCK_BIT_SUPER;\r\nelse\r\nclock_bits |= ECHO_CLOCK_BIT_WORD;\r\n}\r\nreturn clock_bits;\r\n}\r\nstatic int check_asic_status(struct echoaudio *chip)\r\n{\r\nu32 asic_status;\r\nint goodcnt, i;\r\nchip->asic_loaded = FALSE;\r\nfor (i = goodcnt = 0; i < 5; i++) {\r\nsend_vector(chip, DSP_VC_TEST_ASIC);\r\nif (read_dsp(chip, &asic_status) < 0) {\r\ndev_err(chip->card->dev,\r\n"check_asic_status: failed on read_dsp\n");\r\nreturn -EIO;\r\n}\r\nif (asic_status == ASIC_ALREADY_LOADED) {\r\nif (++goodcnt == 3) {\r\nchip->asic_loaded = TRUE;\r\nreturn 0;\r\n}\r\n}\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int load_asic(struct echoaudio *chip)\r\n{\r\nint err;\r\nif (chip->asic_loaded)\r\nreturn 0;\r\nerr = load_asic_generic(chip, DSP_FNC_LOAD_LAYLA_ASIC,\r\nFW_LAYLA20_ASIC);\r\nif (err < 0)\r\nreturn err;\r\nreturn check_asic_status(chip);\r\n}\r\nstatic int set_sample_rate(struct echoaudio *chip, u32 rate)\r\n{\r\nif (snd_BUG_ON(rate < 8000 || rate > 50000))\r\nreturn -EINVAL;\r\nif (chip->input_clock != ECHO_CLOCK_INTERNAL) {\r\ndev_warn(chip->card->dev,\r\n"Cannot set sample rate - clock not set to CLK_CLOCKININTERNAL\n");\r\nchip->comm_page->sample_rate = cpu_to_le32(rate);\r\nchip->sample_rate = rate;\r\nreturn 0;\r\n}\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\ndev_dbg(chip->card->dev, "set_sample_rate(%d)\n", rate);\r\nchip->sample_rate = rate;\r\nchip->comm_page->sample_rate = cpu_to_le32(rate);\r\nclear_handshake(chip);\r\nreturn send_vector(chip, DSP_VC_SET_LAYLA_SAMPLE_RATE);\r\n}\r\nstatic int set_input_clock(struct echoaudio *chip, u16 clock_source)\r\n{\r\nu16 clock;\r\nu32 rate;\r\nrate = 0;\r\nswitch (clock_source) {\r\ncase ECHO_CLOCK_INTERNAL:\r\nrate = chip->sample_rate;\r\nclock = LAYLA20_CLOCK_INTERNAL;\r\nbreak;\r\ncase ECHO_CLOCK_SPDIF:\r\nclock = LAYLA20_CLOCK_SPDIF;\r\nbreak;\r\ncase ECHO_CLOCK_WORD:\r\nclock = LAYLA20_CLOCK_WORD;\r\nbreak;\r\ncase ECHO_CLOCK_SUPER:\r\nclock = LAYLA20_CLOCK_SUPER;\r\nbreak;\r\ndefault:\r\ndev_err(chip->card->dev,\r\n"Input clock 0x%x not supported for Layla24\n",\r\nclock_source);\r\nreturn -EINVAL;\r\n}\r\nchip->input_clock = clock_source;\r\nchip->comm_page->input_clock = cpu_to_le16(clock);\r\nclear_handshake(chip);\r\nsend_vector(chip, DSP_VC_UPDATE_CLOCKS);\r\nif (rate)\r\nset_sample_rate(chip, rate);\r\nreturn 0;\r\n}\r\nstatic int set_output_clock(struct echoaudio *chip, u16 clock)\r\n{\r\nswitch (clock) {\r\ncase ECHO_CLOCK_SUPER:\r\nclock = LAYLA20_OUTPUT_CLOCK_SUPER;\r\nbreak;\r\ncase ECHO_CLOCK_WORD:\r\nclock = LAYLA20_OUTPUT_CLOCK_WORD;\r\nbreak;\r\ndefault:\r\ndev_err(chip->card->dev, "set_output_clock wrong clock\n");\r\nreturn -EINVAL;\r\n}\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nchip->comm_page->output_clock = cpu_to_le16(clock);\r\nchip->output_clock = clock;\r\nclear_handshake(chip);\r\nreturn send_vector(chip, DSP_VC_UPDATE_CLOCKS);\r\n}\r\nstatic int set_input_gain(struct echoaudio *chip, u16 input, int gain)\r\n{\r\nif (snd_BUG_ON(input >= num_busses_in(chip)))\r\nreturn -EINVAL;\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nchip->input_gain[input] = gain;\r\ngain += GL20_INPUT_GAIN_MAGIC_NUMBER;\r\nchip->comm_page->line_in_level[input] = gain;\r\nreturn 0;\r\n}\r\nstatic int update_flags(struct echoaudio *chip)\r\n{\r\nif (wait_handshake(chip))\r\nreturn -EIO;\r\nclear_handshake(chip);\r\nreturn send_vector(chip, DSP_VC_UPDATE_FLAGS);\r\n}\r\nstatic int set_professional_spdif(struct echoaudio *chip, char prof)\r\n{\r\nif (prof)\r\nchip->comm_page->flags |=\r\ncpu_to_le32(DSP_FLAG_PROFESSIONAL_SPDIF);\r\nelse\r\nchip->comm_page->flags &=\r\n~cpu_to_le32(DSP_FLAG_PROFESSIONAL_SPDIF);\r\nchip->professional_spdif = prof;\r\nreturn update_flags(chip);\r\n}
