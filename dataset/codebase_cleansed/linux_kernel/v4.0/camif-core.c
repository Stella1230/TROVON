const struct camif_fmt *s3c_camif_find_format(struct camif_vp *vp,\r\nconst u32 *pixelformat,\r\nint index)\r\n{\r\nconst struct camif_fmt *fmt, *def_fmt = NULL;\r\nunsigned int i;\r\nint id = 0;\r\nif (index >= (int)ARRAY_SIZE(camif_formats))\r\nreturn NULL;\r\nfor (i = 0; i < ARRAY_SIZE(camif_formats); ++i) {\r\nfmt = &camif_formats[i];\r\nif (vp && !(vp->fmt_flags & fmt->flags))\r\ncontinue;\r\nif (pixelformat && fmt->fourcc == *pixelformat)\r\nreturn fmt;\r\nif (index == id)\r\ndef_fmt = fmt;\r\nid++;\r\n}\r\nreturn def_fmt;\r\n}\r\nstatic int camif_get_scaler_factor(u32 src, u32 tar, u32 *ratio, u32 *shift)\r\n{\r\nunsigned int sh = 6;\r\nif (src >= 64 * tar)\r\nreturn -EINVAL;\r\nwhile (sh--) {\r\nunsigned int tmp = 1 << sh;\r\nif (src >= tar * tmp) {\r\n*shift = sh, *ratio = tmp;\r\nreturn 0;\r\n}\r\n}\r\n*shift = 0, *ratio = 1;\r\nreturn 0;\r\n}\r\nint s3c_camif_get_scaler_config(struct camif_vp *vp,\r\nstruct camif_scaler *scaler)\r\n{\r\nstruct v4l2_rect *camif_crop = &vp->camif->camif_crop;\r\nint source_x = camif_crop->width;\r\nint source_y = camif_crop->height;\r\nint target_x = vp->out_frame.rect.width;\r\nint target_y = vp->out_frame.rect.height;\r\nint ret;\r\nif (vp->rotation == 90 || vp->rotation == 270)\r\nswap(target_x, target_y);\r\nret = camif_get_scaler_factor(source_x, target_x, &scaler->pre_h_ratio,\r\n&scaler->h_shift);\r\nif (ret < 0)\r\nreturn ret;\r\nret = camif_get_scaler_factor(source_y, target_y, &scaler->pre_v_ratio,\r\n&scaler->v_shift);\r\nif (ret < 0)\r\nreturn ret;\r\nscaler->pre_dst_width = source_x / scaler->pre_h_ratio;\r\nscaler->pre_dst_height = source_y / scaler->pre_v_ratio;\r\nscaler->main_h_ratio = (source_x << 8) / (target_x << scaler->h_shift);\r\nscaler->main_v_ratio = (source_y << 8) / (target_y << scaler->v_shift);\r\nscaler->scaleup_h = (target_x >= source_x);\r\nscaler->scaleup_v = (target_y >= source_y);\r\nscaler->copy = 0;\r\npr_debug("H: ratio: %u, shift: %u. V: ratio: %u, shift: %u.\n",\r\nscaler->pre_h_ratio, scaler->h_shift,\r\nscaler->pre_v_ratio, scaler->v_shift);\r\npr_debug("Source: %dx%d, Target: %dx%d, scaleup_h/v: %d/%d\n",\r\nsource_x, source_y, target_x, target_y,\r\nscaler->scaleup_h, scaler->scaleup_v);\r\nreturn 0;\r\n}\r\nstatic int camif_register_sensor(struct camif_dev *camif)\r\n{\r\nstruct s3c_camif_sensor_info *sensor = &camif->pdata.sensor;\r\nstruct v4l2_device *v4l2_dev = &camif->v4l2_dev;\r\nstruct i2c_adapter *adapter;\r\nstruct v4l2_subdev_format format;\r\nstruct v4l2_subdev *sd;\r\nint ret;\r\ncamif->sensor.sd = NULL;\r\nif (sensor->i2c_board_info.addr == 0)\r\nreturn -EINVAL;\r\nadapter = i2c_get_adapter(sensor->i2c_bus_num);\r\nif (adapter == NULL) {\r\nv4l2_warn(v4l2_dev, "failed to get I2C adapter %d\n",\r\nsensor->i2c_bus_num);\r\nreturn -EPROBE_DEFER;\r\n}\r\nsd = v4l2_i2c_new_subdev_board(v4l2_dev, adapter,\r\n&sensor->i2c_board_info, NULL);\r\nif (sd == NULL) {\r\ni2c_put_adapter(adapter);\r\nv4l2_warn(v4l2_dev, "failed to acquire subdev %s\n",\r\nsensor->i2c_board_info.type);\r\nreturn -EPROBE_DEFER;\r\n}\r\ncamif->sensor.sd = sd;\r\nv4l2_info(v4l2_dev, "registered sensor subdevice %s\n", sd->name);\r\nformat.pad = 0;\r\nformat.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &format);\r\nif (ret < 0)\r\nreturn 0;\r\nformat.pad = CAMIF_SD_PAD_SINK;\r\nv4l2_subdev_call(&camif->subdev, pad, set_fmt, NULL, &format);\r\nv4l2_info(sd, "Initial format from sensor: %dx%d, %#x\n",\r\nformat.format.width, format.format.height,\r\nformat.format.code);\r\nreturn 0;\r\n}\r\nstatic void camif_unregister_sensor(struct camif_dev *camif)\r\n{\r\nstruct v4l2_subdev *sd = camif->sensor.sd;\r\nstruct i2c_client *client = sd ? v4l2_get_subdevdata(sd) : NULL;\r\nstruct i2c_adapter *adapter;\r\nif (client == NULL)\r\nreturn;\r\nadapter = client->adapter;\r\nv4l2_device_unregister_subdev(sd);\r\ncamif->sensor.sd = NULL;\r\ni2c_unregister_device(client);\r\ni2c_put_adapter(adapter);\r\n}\r\nstatic int camif_create_media_links(struct camif_dev *camif)\r\n{\r\nint i, ret;\r\nret = media_entity_create_link(&camif->sensor.sd->entity, 0,\r\n&camif->subdev.entity, CAMIF_SD_PAD_SINK,\r\nMEDIA_LNK_FL_IMMUTABLE |\r\nMEDIA_LNK_FL_ENABLED);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 1; i < CAMIF_SD_PADS_NUM && !ret; i++) {\r\nret = media_entity_create_link(&camif->subdev.entity, i,\r\n&camif->vp[i - 1].vdev.entity, 0,\r\nMEDIA_LNK_FL_IMMUTABLE |\r\nMEDIA_LNK_FL_ENABLED);\r\n}\r\nreturn ret;\r\n}\r\nstatic int camif_register_video_nodes(struct camif_dev *camif)\r\n{\r\nint ret = s3c_camif_register_video_node(camif, VP_CODEC);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn s3c_camif_register_video_node(camif, VP_PREVIEW);\r\n}\r\nstatic void camif_unregister_video_nodes(struct camif_dev *camif)\r\n{\r\ns3c_camif_unregister_video_node(camif, VP_CODEC);\r\ns3c_camif_unregister_video_node(camif, VP_PREVIEW);\r\n}\r\nstatic void camif_unregister_media_entities(struct camif_dev *camif)\r\n{\r\ncamif_unregister_video_nodes(camif);\r\ncamif_unregister_sensor(camif);\r\ns3c_camif_unregister_subdev(camif);\r\n}\r\nstatic int camif_media_dev_register(struct camif_dev *camif)\r\n{\r\nstruct media_device *md = &camif->media_dev;\r\nstruct v4l2_device *v4l2_dev = &camif->v4l2_dev;\r\nunsigned int ip_rev = camif->variant->ip_revision;\r\nint ret;\r\nmemset(md, 0, sizeof(*md));\r\nsnprintf(md->model, sizeof(md->model), "SAMSUNG S3C%s CAMIF",\r\nip_rev == S3C6410_CAMIF_IP_REV ? "6410" : "244X");\r\nstrlcpy(md->bus_info, "platform", sizeof(md->bus_info));\r\nmd->hw_revision = ip_rev;\r\nmd->driver_version = KERNEL_VERSION(1, 0, 0);\r\nmd->dev = camif->dev;\r\nstrlcpy(v4l2_dev->name, "s3c-camif", sizeof(v4l2_dev->name));\r\nv4l2_dev->mdev = md;\r\nret = v4l2_device_register(camif->dev, v4l2_dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = media_device_register(md);\r\nif (ret < 0)\r\nv4l2_device_unregister(v4l2_dev);\r\nreturn ret;\r\n}\r\nstatic void camif_clk_put(struct camif_dev *camif)\r\n{\r\nint i;\r\nfor (i = 0; i < CLK_MAX_NUM; i++) {\r\nif (IS_ERR(camif->clock[i]))\r\ncontinue;\r\nclk_unprepare(camif->clock[i]);\r\nclk_put(camif->clock[i]);\r\ncamif->clock[i] = ERR_PTR(-EINVAL);\r\n}\r\n}\r\nstatic int camif_clk_get(struct camif_dev *camif)\r\n{\r\nint ret, i;\r\nfor (i = 1; i < CLK_MAX_NUM; i++)\r\ncamif->clock[i] = ERR_PTR(-EINVAL);\r\nfor (i = 0; i < CLK_MAX_NUM; i++) {\r\ncamif->clock[i] = clk_get(camif->dev, camif_clocks[i]);\r\nif (IS_ERR(camif->clock[i])) {\r\nret = PTR_ERR(camif->clock[i]);\r\ngoto err;\r\n}\r\nret = clk_prepare(camif->clock[i]);\r\nif (ret < 0) {\r\nclk_put(camif->clock[i]);\r\ncamif->clock[i] = NULL;\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\ncamif_clk_put(camif);\r\ndev_err(camif->dev, "failed to get clock: %s\n",\r\ncamif_clocks[i]);\r\nreturn ret;\r\n}\r\nstatic int camif_request_irqs(struct platform_device *pdev,\r\nstruct camif_dev *camif)\r\n{\r\nint irq, ret, i;\r\nfor (i = 0; i < CAMIF_VP_NUM; i++) {\r\nstruct camif_vp *vp = &camif->vp[i];\r\ninit_waitqueue_head(&vp->irq_queue);\r\nirq = platform_get_irq(pdev, i);\r\nif (irq <= 0) {\r\ndev_err(&pdev->dev, "failed to get IRQ %d\n", i);\r\nreturn -ENXIO;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, s3c_camif_irq_handler,\r\n0, dev_name(&pdev->dev), vp);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to install IRQ: %d\n", ret);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int s3c_camif_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct s3c_camif_plat_data *pdata = dev->platform_data;\r\nstruct s3c_camif_drvdata *drvdata;\r\nstruct camif_dev *camif;\r\nstruct resource *mres;\r\nint ret = 0;\r\ncamif = devm_kzalloc(dev, sizeof(*camif), GFP_KERNEL);\r\nif (!camif)\r\nreturn -ENOMEM;\r\nspin_lock_init(&camif->slock);\r\nmutex_init(&camif->lock);\r\ncamif->dev = dev;\r\nif (!pdata || !pdata->gpio_get || !pdata->gpio_put) {\r\ndev_err(dev, "wrong platform data\n");\r\nreturn -EINVAL;\r\n}\r\ncamif->pdata = *pdata;\r\ndrvdata = (void *)platform_get_device_id(pdev)->driver_data;\r\ncamif->variant = drvdata->variant;\r\nmres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ncamif->io_base = devm_ioremap_resource(dev, mres);\r\nif (IS_ERR(camif->io_base))\r\nreturn PTR_ERR(camif->io_base);\r\nret = camif_request_irqs(pdev, camif);\r\nif (ret < 0)\r\nreturn ret;\r\nret = pdata->gpio_get();\r\nif (ret < 0)\r\nreturn ret;\r\nret = s3c_camif_create_subdev(camif);\r\nif (ret < 0)\r\ngoto err_sd;\r\nret = camif_clk_get(camif);\r\nif (ret < 0)\r\ngoto err_clk;\r\nplatform_set_drvdata(pdev, camif);\r\nclk_set_rate(camif->clock[CLK_CAM],\r\ncamif->pdata.sensor.clock_frequency);\r\ndev_info(dev, "sensor clock frequency: %lu\n",\r\nclk_get_rate(camif->clock[CLK_CAM]));\r\ns3c_camif_set_defaults(camif);\r\npm_runtime_enable(dev);\r\nret = pm_runtime_get_sync(dev);\r\nif (ret < 0)\r\ngoto err_pm;\r\ncamif->alloc_ctx = vb2_dma_contig_init_ctx(dev);\r\nif (IS_ERR(camif->alloc_ctx)) {\r\nret = PTR_ERR(camif->alloc_ctx);\r\ngoto err_alloc;\r\n}\r\nret = camif_media_dev_register(camif);\r\nif (ret < 0)\r\ngoto err_mdev;\r\nret = camif_register_sensor(camif);\r\nif (ret < 0)\r\ngoto err_sens;\r\nret = v4l2_device_register_subdev(&camif->v4l2_dev, &camif->subdev);\r\nif (ret < 0)\r\ngoto err_sens;\r\nmutex_lock(&camif->media_dev.graph_mutex);\r\nret = v4l2_device_register_subdev_nodes(&camif->v4l2_dev);\r\nif (ret < 0)\r\ngoto err_unlock;\r\nret = camif_register_video_nodes(camif);\r\nif (ret < 0)\r\ngoto err_unlock;\r\nret = camif_create_media_links(camif);\r\nif (ret < 0)\r\ngoto err_unlock;\r\nmutex_unlock(&camif->media_dev.graph_mutex);\r\npm_runtime_put(dev);\r\nreturn 0;\r\nerr_unlock:\r\nmutex_unlock(&camif->media_dev.graph_mutex);\r\nerr_sens:\r\nv4l2_device_unregister(&camif->v4l2_dev);\r\nmedia_device_unregister(&camif->media_dev);\r\ncamif_unregister_media_entities(camif);\r\nerr_mdev:\r\nvb2_dma_contig_cleanup_ctx(camif->alloc_ctx);\r\nerr_alloc:\r\npm_runtime_put(dev);\r\npm_runtime_disable(dev);\r\nerr_pm:\r\ncamif_clk_put(camif);\r\nerr_clk:\r\ns3c_camif_unregister_subdev(camif);\r\nerr_sd:\r\npdata->gpio_put();\r\nreturn ret;\r\n}\r\nstatic int s3c_camif_remove(struct platform_device *pdev)\r\n{\r\nstruct camif_dev *camif = platform_get_drvdata(pdev);\r\nstruct s3c_camif_plat_data *pdata = &camif->pdata;\r\nmedia_device_unregister(&camif->media_dev);\r\ncamif_unregister_media_entities(camif);\r\nv4l2_device_unregister(&camif->v4l2_dev);\r\npm_runtime_disable(&pdev->dev);\r\ncamif_clk_put(camif);\r\npdata->gpio_put();\r\nreturn 0;\r\n}\r\nstatic int s3c_camif_runtime_resume(struct device *dev)\r\n{\r\nstruct camif_dev *camif = dev_get_drvdata(dev);\r\nclk_enable(camif->clock[CLK_GATE]);\r\nclk_enable(camif->clock[CLK_CAM]);\r\nreturn 0;\r\n}\r\nstatic int s3c_camif_runtime_suspend(struct device *dev)\r\n{\r\nstruct camif_dev *camif = dev_get_drvdata(dev);\r\nclk_disable(camif->clock[CLK_CAM]);\r\nclk_disable(camif->clock[CLK_GATE]);\r\nreturn 0;\r\n}
