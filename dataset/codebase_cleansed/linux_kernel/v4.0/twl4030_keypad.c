static int twl4030_kpread(struct twl4030_keypad *kp,\r\nu8 *data, u32 reg, u8 num_bytes)\r\n{\r\nint ret = twl_i2c_read(TWL4030_MODULE_KEYPAD, data, reg, num_bytes);\r\nif (ret < 0)\r\ndev_warn(kp->dbg_dev,\r\n"Couldn't read TWL4030: %X - ret %d[%x]\n",\r\nreg, ret, ret);\r\nreturn ret;\r\n}\r\nstatic int twl4030_kpwrite_u8(struct twl4030_keypad *kp, u8 data, u32 reg)\r\n{\r\nint ret = twl_i2c_write_u8(TWL4030_MODULE_KEYPAD, data, reg);\r\nif (ret < 0)\r\ndev_warn(kp->dbg_dev,\r\n"Could not write TWL4030: %X - ret %d[%x]\n",\r\nreg, ret, ret);\r\nreturn ret;\r\n}\r\nstatic inline u16 twl4030_col_xlate(struct twl4030_keypad *kp, u8 col)\r\n{\r\nif (col == 0xFF)\r\nreturn 1 << kp->n_cols;\r\nelse\r\nreturn col & ((1 << kp->n_cols) - 1);\r\n}\r\nstatic int twl4030_read_kp_matrix_state(struct twl4030_keypad *kp, u16 *state)\r\n{\r\nu8 new_state[TWL4030_MAX_ROWS];\r\nint row;\r\nint ret = twl4030_kpread(kp, new_state,\r\nKEYP_FULL_CODE_7_0, kp->n_rows);\r\nif (ret >= 0)\r\nfor (row = 0; row < kp->n_rows; row++)\r\nstate[row] = twl4030_col_xlate(kp, new_state[row]);\r\nreturn ret;\r\n}\r\nstatic bool twl4030_is_in_ghost_state(struct twl4030_keypad *kp, u16 *key_state)\r\n{\r\nint i;\r\nu16 check = 0;\r\nfor (i = 0; i < kp->n_rows; i++) {\r\nu16 col = key_state[i];\r\nif ((col & check) && hweight16(col) > 1)\r\nreturn true;\r\ncheck |= col;\r\n}\r\nreturn false;\r\n}\r\nstatic void twl4030_kp_scan(struct twl4030_keypad *kp, bool release_all)\r\n{\r\nstruct input_dev *input = kp->input;\r\nu16 new_state[TWL4030_MAX_ROWS];\r\nint col, row;\r\nif (release_all)\r\nmemset(new_state, 0, sizeof(new_state));\r\nelse {\r\nint ret = twl4030_read_kp_matrix_state(kp, new_state);\r\nif (ret < 0)\r\nreturn;\r\nif (twl4030_is_in_ghost_state(kp, new_state))\r\nreturn;\r\n}\r\nfor (row = 0; row < kp->n_rows; row++) {\r\nint changed = new_state[row] ^ kp->kp_state[row];\r\nif (!changed)\r\ncontinue;\r\nfor (col = 0; col < kp->n_cols + 1; col++) {\r\nint code;\r\nif (!(changed & (1 << col)))\r\ncontinue;\r\ndev_dbg(kp->dbg_dev, "key [%d:%d] %s\n", row, col,\r\n(new_state[row] & (1 << col)) ?\r\n"press" : "release");\r\ncode = MATRIX_SCAN_CODE(row, col, TWL4030_ROW_SHIFT);\r\ninput_event(input, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(input, kp->keymap[code],\r\nnew_state[row] & (1 << col));\r\n}\r\nkp->kp_state[row] = new_state[row];\r\n}\r\ninput_sync(input);\r\n}\r\nstatic irqreturn_t do_kp_irq(int irq, void *_kp)\r\n{\r\nstruct twl4030_keypad *kp = _kp;\r\nu8 reg;\r\nint ret;\r\nret = twl4030_kpread(kp, &reg, KEYP_ISR1, 1);\r\nif (ret >= 0 && (reg & KEYP_IMR1_KP))\r\ntwl4030_kp_scan(kp, false);\r\nelse\r\ntwl4030_kp_scan(kp, true);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int twl4030_kp_program(struct twl4030_keypad *kp)\r\n{\r\nu8 reg;\r\nint i;\r\nreg = KEYP_CTRL_SOFT_NRST | KEYP_CTRL_SOFTMODEN\r\n| KEYP_CTRL_TOE_EN | KEYP_CTRL_KBD_ON;\r\nif (twl4030_kpwrite_u8(kp, reg, KEYP_CTRL) < 0)\r\nreturn -EIO;\r\nreg = KEYP_EDR_KP_BOTH | KEYP_EDR_TO_RISING;\r\nif (twl4030_kpwrite_u8(kp, reg, KEYP_EDR) < 0)\r\nreturn -EIO;\r\nreg = (PTV_PRESCALER << KEYP_LK_PTV_PTV_SHIFT);\r\nif (twl4030_kpwrite_u8(kp, reg, KEYP_LK_PTV) < 0)\r\nreturn -EIO;\r\ni = KEYP_PERIOD_US(20000, PTV_PRESCALER);\r\nif (twl4030_kpwrite_u8(kp, i, KEYP_DEB) < 0)\r\nreturn -EIO;\r\ni = KEYP_PERIOD_US(200000, PTV_PRESCALER);\r\nif (twl4030_kpwrite_u8(kp, (i & 0xFF), KEYP_TIMEOUT_L) < 0)\r\nreturn -EIO;\r\nif (twl4030_kpwrite_u8(kp, (i >> 8), KEYP_TIMEOUT_H) < 0)\r\nreturn -EIO;\r\nreg = TWL4030_SIH_CTRL_COR_MASK | TWL4030_SIH_CTRL_PENDDIS_MASK;\r\nif (twl4030_kpwrite_u8(kp, reg, KEYP_SIH_CTRL) < 0)\r\nreturn -EIO;\r\nif (twl4030_read_kp_matrix_state(kp, kp->kp_state) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int twl4030_kp_probe(struct platform_device *pdev)\r\n{\r\nstruct twl4030_keypad_data *pdata = dev_get_platdata(&pdev->dev);\r\nconst struct matrix_keymap_data *keymap_data = NULL;\r\nstruct twl4030_keypad *kp;\r\nstruct input_dev *input;\r\nu8 reg;\r\nint error;\r\nkp = devm_kzalloc(&pdev->dev, sizeof(*kp), GFP_KERNEL);\r\nif (!kp)\r\nreturn -ENOMEM;\r\ninput = devm_input_allocate_device(&pdev->dev);\r\nif (!input)\r\nreturn -ENOMEM;\r\nkp->dbg_dev = &pdev->dev;\r\nkp->input = input;\r\ninput->name = "TWL4030 Keypad";\r\ninput->phys = "twl4030_keypad/input0";\r\ninput->id.bustype = BUS_HOST;\r\ninput->id.vendor = 0x0001;\r\ninput->id.product = 0x0001;\r\ninput->id.version = 0x0003;\r\nif (pdata) {\r\nif (!pdata->rows || !pdata->cols || !pdata->keymap_data) {\r\ndev_err(&pdev->dev, "Missing platform_data\n");\r\nreturn -EINVAL;\r\n}\r\nkp->n_rows = pdata->rows;\r\nkp->n_cols = pdata->cols;\r\nkp->autorepeat = pdata->rep;\r\nkeymap_data = pdata->keymap_data;\r\n} else {\r\nerror = matrix_keypad_parse_of_params(&pdev->dev, &kp->n_rows,\r\n&kp->n_cols);\r\nif (error)\r\nreturn error;\r\nkp->autorepeat = true;\r\n}\r\nif (kp->n_rows > TWL4030_MAX_ROWS || kp->n_cols > TWL4030_MAX_COLS) {\r\ndev_err(&pdev->dev,\r\n"Invalid rows/cols amount specified in platform/devicetree data\n");\r\nreturn -EINVAL;\r\n}\r\nkp->irq = platform_get_irq(pdev, 0);\r\nif (!kp->irq) {\r\ndev_err(&pdev->dev, "no keyboard irq assigned\n");\r\nreturn -EINVAL;\r\n}\r\nerror = matrix_keypad_build_keymap(keymap_data, NULL,\r\nTWL4030_MAX_ROWS,\r\n1 << TWL4030_ROW_SHIFT,\r\nkp->keymap, input);\r\nif (error) {\r\ndev_err(kp->dbg_dev, "Failed to build keymap\n");\r\nreturn error;\r\n}\r\ninput_set_capability(input, EV_MSC, MSC_SCAN);\r\nif (kp->autorepeat)\r\n__set_bit(EV_REP, input->evbit);\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(kp->dbg_dev,\r\n"Unable to register twl4030 keypad device\n");\r\nreturn error;\r\n}\r\nerror = twl4030_kp_program(kp);\r\nif (error)\r\nreturn error;\r\nerror = devm_request_threaded_irq(&pdev->dev, kp->irq, NULL, do_kp_irq,\r\n0, pdev->name, kp);\r\nif (error) {\r\ndev_info(kp->dbg_dev, "request_irq failed for irq no=%d: %d\n",\r\nkp->irq, error);\r\nreturn error;\r\n}\r\nreg = (u8) ~(KEYP_IMR1_KP | KEYP_IMR1_TO);\r\nif (twl4030_kpwrite_u8(kp, reg, KEYP_IMR1)) {\r\n(void) twl4030_kpwrite_u8(kp, 0xff, KEYP_IMR1);\r\nreturn -EIO;\r\n}\r\nplatform_set_drvdata(pdev, kp);\r\nreturn 0;\r\n}
