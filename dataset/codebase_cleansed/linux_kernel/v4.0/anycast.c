int ipv6_sock_ac_join(struct sock *sk, int ifindex, const struct in6_addr *addr)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct net_device *dev = NULL;\r\nstruct inet6_dev *idev;\r\nstruct ipv6_ac_socklist *pac;\r\nstruct net *net = sock_net(sk);\r\nint ishost = !net->ipv6.devconf_all->forwarding;\r\nint err = 0;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (ipv6_addr_is_multicast(addr))\r\nreturn -EINVAL;\r\nif (ipv6_chk_addr(net, addr, NULL, 0))\r\nreturn -EINVAL;\r\npac = sock_kmalloc(sk, sizeof(struct ipv6_ac_socklist), GFP_KERNEL);\r\nif (pac == NULL)\r\nreturn -ENOMEM;\r\npac->acl_next = NULL;\r\npac->acl_addr = *addr;\r\nrtnl_lock();\r\nif (ifindex == 0) {\r\nstruct rt6_info *rt;\r\nrt = rt6_lookup(net, addr, NULL, 0, 0);\r\nif (rt) {\r\ndev = rt->dst.dev;\r\nip6_rt_put(rt);\r\n} else if (ishost) {\r\nerr = -EADDRNOTAVAIL;\r\ngoto error;\r\n} else {\r\ndev = __dev_get_by_flags(net, IFF_UP,\r\nIFF_UP | IFF_LOOPBACK);\r\n}\r\n} else\r\ndev = __dev_get_by_index(net, ifindex);\r\nif (dev == NULL) {\r\nerr = -ENODEV;\r\ngoto error;\r\n}\r\nidev = __in6_dev_get(dev);\r\nif (!idev) {\r\nif (ifindex)\r\nerr = -ENODEV;\r\nelse\r\nerr = -EADDRNOTAVAIL;\r\ngoto error;\r\n}\r\nishost = !idev->cnf.forwarding;\r\npac->acl_ifindex = dev->ifindex;\r\nif (!ipv6_chk_prefix(addr, dev)) {\r\nif (ishost)\r\nerr = -EADDRNOTAVAIL;\r\nif (err)\r\ngoto error;\r\n}\r\nerr = __ipv6_dev_ac_inc(idev, addr);\r\nif (!err) {\r\npac->acl_next = np->ipv6_ac_list;\r\nnp->ipv6_ac_list = pac;\r\npac = NULL;\r\n}\r\nerror:\r\nrtnl_unlock();\r\nif (pac)\r\nsock_kfree_s(sk, pac, sizeof(*pac));\r\nreturn err;\r\n}\r\nint ipv6_sock_ac_drop(struct sock *sk, int ifindex, const struct in6_addr *addr)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct net_device *dev;\r\nstruct ipv6_ac_socklist *pac, *prev_pac;\r\nstruct net *net = sock_net(sk);\r\nrtnl_lock();\r\nprev_pac = NULL;\r\nfor (pac = np->ipv6_ac_list; pac; pac = pac->acl_next) {\r\nif ((ifindex == 0 || pac->acl_ifindex == ifindex) &&\r\nipv6_addr_equal(&pac->acl_addr, addr))\r\nbreak;\r\nprev_pac = pac;\r\n}\r\nif (!pac) {\r\nrtnl_unlock();\r\nreturn -ENOENT;\r\n}\r\nif (prev_pac)\r\nprev_pac->acl_next = pac->acl_next;\r\nelse\r\nnp->ipv6_ac_list = pac->acl_next;\r\ndev = __dev_get_by_index(net, pac->acl_ifindex);\r\nif (dev)\r\nipv6_dev_ac_dec(dev, &pac->acl_addr);\r\nrtnl_unlock();\r\nsock_kfree_s(sk, pac, sizeof(*pac));\r\nreturn 0;\r\n}\r\nvoid ipv6_sock_ac_close(struct sock *sk)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct net_device *dev = NULL;\r\nstruct ipv6_ac_socklist *pac;\r\nstruct net *net = sock_net(sk);\r\nint prev_index;\r\nif (!np->ipv6_ac_list)\r\nreturn;\r\nrtnl_lock();\r\npac = np->ipv6_ac_list;\r\nnp->ipv6_ac_list = NULL;\r\nprev_index = 0;\r\nwhile (pac) {\r\nstruct ipv6_ac_socklist *next = pac->acl_next;\r\nif (pac->acl_ifindex != prev_index) {\r\ndev = __dev_get_by_index(net, pac->acl_ifindex);\r\nprev_index = pac->acl_ifindex;\r\n}\r\nif (dev)\r\nipv6_dev_ac_dec(dev, &pac->acl_addr);\r\nsock_kfree_s(sk, pac, sizeof(*pac));\r\npac = next;\r\n}\r\nrtnl_unlock();\r\n}\r\nstatic void aca_get(struct ifacaddr6 *aca)\r\n{\r\natomic_inc(&aca->aca_refcnt);\r\n}\r\nstatic void aca_put(struct ifacaddr6 *ac)\r\n{\r\nif (atomic_dec_and_test(&ac->aca_refcnt)) {\r\nin6_dev_put(ac->aca_idev);\r\ndst_release(&ac->aca_rt->dst);\r\nkfree(ac);\r\n}\r\n}\r\nstatic struct ifacaddr6 *aca_alloc(struct rt6_info *rt,\r\nconst struct in6_addr *addr)\r\n{\r\nstruct inet6_dev *idev = rt->rt6i_idev;\r\nstruct ifacaddr6 *aca;\r\naca = kzalloc(sizeof(*aca), GFP_ATOMIC);\r\nif (aca == NULL)\r\nreturn NULL;\r\naca->aca_addr = *addr;\r\nin6_dev_hold(idev);\r\naca->aca_idev = idev;\r\naca->aca_rt = rt;\r\naca->aca_users = 1;\r\naca->aca_cstamp = aca->aca_tstamp = jiffies;\r\natomic_set(&aca->aca_refcnt, 1);\r\nreturn aca;\r\n}\r\nint __ipv6_dev_ac_inc(struct inet6_dev *idev, const struct in6_addr *addr)\r\n{\r\nstruct ifacaddr6 *aca;\r\nstruct rt6_info *rt;\r\nint err;\r\nASSERT_RTNL();\r\nwrite_lock_bh(&idev->lock);\r\nif (idev->dead) {\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nfor (aca = idev->ac_list; aca; aca = aca->aca_next) {\r\nif (ipv6_addr_equal(&aca->aca_addr, addr)) {\r\naca->aca_users++;\r\nerr = 0;\r\ngoto out;\r\n}\r\n}\r\nrt = addrconf_dst_alloc(idev, addr, true);\r\nif (IS_ERR(rt)) {\r\nerr = PTR_ERR(rt);\r\ngoto out;\r\n}\r\naca = aca_alloc(rt, addr);\r\nif (aca == NULL) {\r\nip6_rt_put(rt);\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\naca->aca_next = idev->ac_list;\r\nidev->ac_list = aca;\r\naca_get(aca);\r\nwrite_unlock_bh(&idev->lock);\r\nip6_ins_rt(rt);\r\naddrconf_join_solict(idev->dev, &aca->aca_addr);\r\naca_put(aca);\r\nreturn 0;\r\nout:\r\nwrite_unlock_bh(&idev->lock);\r\nreturn err;\r\n}\r\nint __ipv6_dev_ac_dec(struct inet6_dev *idev, const struct in6_addr *addr)\r\n{\r\nstruct ifacaddr6 *aca, *prev_aca;\r\nASSERT_RTNL();\r\nwrite_lock_bh(&idev->lock);\r\nprev_aca = NULL;\r\nfor (aca = idev->ac_list; aca; aca = aca->aca_next) {\r\nif (ipv6_addr_equal(&aca->aca_addr, addr))\r\nbreak;\r\nprev_aca = aca;\r\n}\r\nif (!aca) {\r\nwrite_unlock_bh(&idev->lock);\r\nreturn -ENOENT;\r\n}\r\nif (--aca->aca_users > 0) {\r\nwrite_unlock_bh(&idev->lock);\r\nreturn 0;\r\n}\r\nif (prev_aca)\r\nprev_aca->aca_next = aca->aca_next;\r\nelse\r\nidev->ac_list = aca->aca_next;\r\nwrite_unlock_bh(&idev->lock);\r\naddrconf_leave_solict(idev, &aca->aca_addr);\r\ndst_hold(&aca->aca_rt->dst);\r\nip6_del_rt(aca->aca_rt);\r\naca_put(aca);\r\nreturn 0;\r\n}\r\nstatic int ipv6_dev_ac_dec(struct net_device *dev, const struct in6_addr *addr)\r\n{\r\nstruct inet6_dev *idev = __in6_dev_get(dev);\r\nif (idev == NULL)\r\nreturn -ENODEV;\r\nreturn __ipv6_dev_ac_dec(idev, addr);\r\n}\r\nvoid ipv6_ac_destroy_dev(struct inet6_dev *idev)\r\n{\r\nstruct ifacaddr6 *aca;\r\nwrite_lock_bh(&idev->lock);\r\nwhile ((aca = idev->ac_list) != NULL) {\r\nidev->ac_list = aca->aca_next;\r\nwrite_unlock_bh(&idev->lock);\r\naddrconf_leave_solict(idev, &aca->aca_addr);\r\ndst_hold(&aca->aca_rt->dst);\r\nip6_del_rt(aca->aca_rt);\r\naca_put(aca);\r\nwrite_lock_bh(&idev->lock);\r\n}\r\nwrite_unlock_bh(&idev->lock);\r\n}\r\nstatic bool ipv6_chk_acast_dev(struct net_device *dev, const struct in6_addr *addr)\r\n{\r\nstruct inet6_dev *idev;\r\nstruct ifacaddr6 *aca;\r\nidev = __in6_dev_get(dev);\r\nif (idev) {\r\nread_lock_bh(&idev->lock);\r\nfor (aca = idev->ac_list; aca; aca = aca->aca_next)\r\nif (ipv6_addr_equal(&aca->aca_addr, addr))\r\nbreak;\r\nread_unlock_bh(&idev->lock);\r\nreturn aca != NULL;\r\n}\r\nreturn false;\r\n}\r\nbool ipv6_chk_acast_addr(struct net *net, struct net_device *dev,\r\nconst struct in6_addr *addr)\r\n{\r\nbool found = false;\r\nrcu_read_lock();\r\nif (dev)\r\nfound = ipv6_chk_acast_dev(dev, addr);\r\nelse\r\nfor_each_netdev_rcu(net, dev)\r\nif (ipv6_chk_acast_dev(dev, addr)) {\r\nfound = true;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn found;\r\n}\r\nbool ipv6_chk_acast_addr_src(struct net *net, struct net_device *dev,\r\nconst struct in6_addr *addr)\r\n{\r\nreturn ipv6_chk_acast_addr(net,\r\n(ipv6_addr_type(addr) & IPV6_ADDR_LINKLOCAL ?\r\ndev : NULL),\r\naddr);\r\n}\r\nstatic inline struct ifacaddr6 *ac6_get_first(struct seq_file *seq)\r\n{\r\nstruct ifacaddr6 *im = NULL;\r\nstruct ac6_iter_state *state = ac6_seq_private(seq);\r\nstruct net *net = seq_file_net(seq);\r\nstate->idev = NULL;\r\nfor_each_netdev_rcu(net, state->dev) {\r\nstruct inet6_dev *idev;\r\nidev = __in6_dev_get(state->dev);\r\nif (!idev)\r\ncontinue;\r\nread_lock_bh(&idev->lock);\r\nim = idev->ac_list;\r\nif (im) {\r\nstate->idev = idev;\r\nbreak;\r\n}\r\nread_unlock_bh(&idev->lock);\r\n}\r\nreturn im;\r\n}\r\nstatic struct ifacaddr6 *ac6_get_next(struct seq_file *seq, struct ifacaddr6 *im)\r\n{\r\nstruct ac6_iter_state *state = ac6_seq_private(seq);\r\nim = im->aca_next;\r\nwhile (!im) {\r\nif (likely(state->idev != NULL))\r\nread_unlock_bh(&state->idev->lock);\r\nstate->dev = next_net_device_rcu(state->dev);\r\nif (!state->dev) {\r\nstate->idev = NULL;\r\nbreak;\r\n}\r\nstate->idev = __in6_dev_get(state->dev);\r\nif (!state->idev)\r\ncontinue;\r\nread_lock_bh(&state->idev->lock);\r\nim = state->idev->ac_list;\r\n}\r\nreturn im;\r\n}\r\nstatic struct ifacaddr6 *ac6_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct ifacaddr6 *im = ac6_get_first(seq);\r\nif (im)\r\nwhile (pos && (im = ac6_get_next(seq, im)) != NULL)\r\n--pos;\r\nreturn pos ? NULL : im;\r\n}\r\nstatic void *ac6_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nrcu_read_lock();\r\nreturn ac6_get_idx(seq, *pos);\r\n}\r\nstatic void *ac6_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct ifacaddr6 *im = ac6_get_next(seq, v);\r\n++*pos;\r\nreturn im;\r\n}\r\nstatic void ac6_seq_stop(struct seq_file *seq, void *v)\r\n__releases(RCU)\r\n{\r\nstruct ac6_iter_state *state = ac6_seq_private(seq);\r\nif (likely(state->idev != NULL)) {\r\nread_unlock_bh(&state->idev->lock);\r\nstate->idev = NULL;\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic int ac6_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct ifacaddr6 *im = (struct ifacaddr6 *)v;\r\nstruct ac6_iter_state *state = ac6_seq_private(seq);\r\nseq_printf(seq, "%-4d %-15s %pi6 %5d\n",\r\nstate->dev->ifindex, state->dev->name,\r\n&im->aca_addr, im->aca_users);\r\nreturn 0;\r\n}\r\nstatic int ac6_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &ac6_seq_ops,\r\nsizeof(struct ac6_iter_state));\r\n}\r\nint __net_init ac6_proc_init(struct net *net)\r\n{\r\nif (!proc_create("anycast6", S_IRUGO, net->proc_net, &ac6_seq_fops))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid ac6_proc_exit(struct net *net)\r\n{\r\nremove_proc_entry("anycast6", net->proc_net);\r\n}
