static int\r\nbnad_debugfs_open_fwtrc(struct inode *inode, struct file *file)\r\n{\r\nstruct bnad *bnad = inode->i_private;\r\nstruct bnad_debug_info *fw_debug;\r\nunsigned long flags;\r\nint rc;\r\nfw_debug = kzalloc(sizeof(struct bnad_debug_info), GFP_KERNEL);\r\nif (!fw_debug)\r\nreturn -ENOMEM;\r\nfw_debug->buffer_len = BNA_DBG_FWTRC_LEN;\r\nfw_debug->debug_buffer = kzalloc(fw_debug->buffer_len, GFP_KERNEL);\r\nif (!fw_debug->debug_buffer) {\r\nkfree(fw_debug);\r\nfw_debug = NULL;\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nrc = bfa_nw_ioc_debug_fwtrc(&bnad->bna.ioceth.ioc,\r\nfw_debug->debug_buffer,\r\n&fw_debug->buffer_len);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nif (rc != BFA_STATUS_OK) {\r\nkfree(fw_debug->debug_buffer);\r\nfw_debug->debug_buffer = NULL;\r\nkfree(fw_debug);\r\nfw_debug = NULL;\r\npr_warn("bnad %s: Failed to collect fwtrc\n",\r\npci_name(bnad->pcidev));\r\nreturn -ENOMEM;\r\n}\r\nfile->private_data = fw_debug;\r\nreturn 0;\r\n}\r\nstatic int\r\nbnad_debugfs_open_fwsave(struct inode *inode, struct file *file)\r\n{\r\nstruct bnad *bnad = inode->i_private;\r\nstruct bnad_debug_info *fw_debug;\r\nunsigned long flags;\r\nint rc;\r\nfw_debug = kzalloc(sizeof(struct bnad_debug_info), GFP_KERNEL);\r\nif (!fw_debug)\r\nreturn -ENOMEM;\r\nfw_debug->buffer_len = BNA_DBG_FWTRC_LEN;\r\nfw_debug->debug_buffer = kzalloc(fw_debug->buffer_len, GFP_KERNEL);\r\nif (!fw_debug->debug_buffer) {\r\nkfree(fw_debug);\r\nfw_debug = NULL;\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nrc = bfa_nw_ioc_debug_fwsave(&bnad->bna.ioceth.ioc,\r\nfw_debug->debug_buffer,\r\n&fw_debug->buffer_len);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nif (rc != BFA_STATUS_OK && rc != BFA_STATUS_ENOFSAVE) {\r\nkfree(fw_debug->debug_buffer);\r\nfw_debug->debug_buffer = NULL;\r\nkfree(fw_debug);\r\nfw_debug = NULL;\r\npr_warn("bna %s: Failed to collect fwsave\n",\r\npci_name(bnad->pcidev));\r\nreturn -ENOMEM;\r\n}\r\nfile->private_data = fw_debug;\r\nreturn 0;\r\n}\r\nstatic int\r\nbnad_debugfs_open_reg(struct inode *inode, struct file *file)\r\n{\r\nstruct bnad_debug_info *reg_debug;\r\nreg_debug = kzalloc(sizeof(struct bnad_debug_info), GFP_KERNEL);\r\nif (!reg_debug)\r\nreturn -ENOMEM;\r\nreg_debug->i_private = inode->i_private;\r\nfile->private_data = reg_debug;\r\nreturn 0;\r\n}\r\nstatic int\r\nbnad_get_debug_drvinfo(struct bnad *bnad, void *buffer, u32 len)\r\n{\r\nstruct bnad_drvinfo *drvinfo = (struct bnad_drvinfo *) buffer;\r\nstruct bnad_iocmd_comp fcomp;\r\nunsigned long flags = 0;\r\nint ret = BFA_STATUS_FAILED;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nbfa_nw_ioc_get_attr(&bnad->bna.ioceth.ioc, &drvinfo->ioc_attr);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nfcomp.bnad = bnad;\r\nfcomp.comp_status = 0;\r\ninit_completion(&fcomp.comp);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nret = bfa_nw_cee_get_attr(&bnad->bna.cee, &drvinfo->cee_attr,\r\nbnad_cb_completion, &fcomp);\r\nif (ret != BFA_STATUS_OK) {\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\ngoto out;\r\n}\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nwait_for_completion(&fcomp.comp);\r\ndrvinfo->cee_status = fcomp.comp_status;\r\nfcomp.comp_status = 0;\r\nreinit_completion(&fcomp.comp);\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nret = bfa_nw_flash_get_attr(&bnad->bna.flash, &drvinfo->flash_attr,\r\nbnad_cb_completion, &fcomp);\r\nif (ret != BFA_STATUS_OK) {\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\ngoto out;\r\n}\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nwait_for_completion(&fcomp.comp);\r\ndrvinfo->flash_status = fcomp.comp_status;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\nbnad_debugfs_open_drvinfo(struct inode *inode, struct file *file)\r\n{\r\nstruct bnad *bnad = inode->i_private;\r\nstruct bnad_debug_info *drv_info;\r\nint rc;\r\ndrv_info = kzalloc(sizeof(struct bnad_debug_info), GFP_KERNEL);\r\nif (!drv_info)\r\nreturn -ENOMEM;\r\ndrv_info->buffer_len = sizeof(struct bnad_drvinfo);\r\ndrv_info->debug_buffer = kzalloc(drv_info->buffer_len, GFP_KERNEL);\r\nif (!drv_info->debug_buffer) {\r\nkfree(drv_info);\r\ndrv_info = NULL;\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&bnad->conf_mutex);\r\nrc = bnad_get_debug_drvinfo(bnad, drv_info->debug_buffer,\r\ndrv_info->buffer_len);\r\nmutex_unlock(&bnad->conf_mutex);\r\nif (rc != BFA_STATUS_OK) {\r\nkfree(drv_info->debug_buffer);\r\ndrv_info->debug_buffer = NULL;\r\nkfree(drv_info);\r\ndrv_info = NULL;\r\npr_warn("bna %s: Failed to collect drvinfo\n",\r\npci_name(bnad->pcidev));\r\nreturn -ENOMEM;\r\n}\r\nfile->private_data = drv_info;\r\nreturn 0;\r\n}\r\nstatic loff_t\r\nbnad_debugfs_lseek(struct file *file, loff_t offset, int orig)\r\n{\r\nstruct bnad_debug_info *debug = file->private_data;\r\nif (!debug)\r\nreturn -EINVAL;\r\nreturn fixed_size_llseek(file, offset, orig, debug->buffer_len);\r\n}\r\nstatic ssize_t\r\nbnad_debugfs_read(struct file *file, char __user *buf,\r\nsize_t nbytes, loff_t *pos)\r\n{\r\nstruct bnad_debug_info *debug = file->private_data;\r\nif (!debug || !debug->debug_buffer)\r\nreturn 0;\r\nreturn simple_read_from_buffer(buf, nbytes, pos,\r\ndebug->debug_buffer, debug->buffer_len);\r\n}\r\nstatic int\r\nbna_reg_offset_check(struct bfa_ioc *ioc, u32 offset, u32 len)\r\n{\r\nu8 area;\r\narea = (offset >> 15) & 0x7;\r\nif (area == 0) {\r\nif ((offset + (len<<2)) > 0x8000)\r\nreturn BFA_STATUS_EINVAL;\r\n} else if (area == 0x1) {\r\nif ((offset + (len<<2)) > 0x10000)\r\nreturn BFA_STATUS_EINVAL;\r\n} else {\r\nif ((offset + (len<<2)) > BFA_REG_ADDRMSK(ioc))\r\nreturn BFA_STATUS_EINVAL;\r\n}\r\nreturn BFA_STATUS_OK;\r\n}\r\nstatic ssize_t\r\nbnad_debugfs_read_regrd(struct file *file, char __user *buf,\r\nsize_t nbytes, loff_t *pos)\r\n{\r\nstruct bnad_debug_info *regrd_debug = file->private_data;\r\nstruct bnad *bnad = (struct bnad *)regrd_debug->i_private;\r\nssize_t rc;\r\nif (!bnad->regdata)\r\nreturn 0;\r\nrc = simple_read_from_buffer(buf, nbytes, pos,\r\nbnad->regdata, bnad->reglen);\r\nif ((*pos + nbytes) >= bnad->reglen) {\r\nkfree(bnad->regdata);\r\nbnad->regdata = NULL;\r\nbnad->reglen = 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\nbnad_debugfs_write_regrd(struct file *file, const char __user *buf,\r\nsize_t nbytes, loff_t *ppos)\r\n{\r\nstruct bnad_debug_info *regrd_debug = file->private_data;\r\nstruct bnad *bnad = (struct bnad *)regrd_debug->i_private;\r\nstruct bfa_ioc *ioc = &bnad->bna.ioceth.ioc;\r\nint addr, len, rc, i;\r\nu32 *regbuf;\r\nvoid __iomem *rb, *reg_addr;\r\nunsigned long flags;\r\nvoid *kern_buf;\r\nkern_buf = kzalloc(nbytes, GFP_KERNEL);\r\nif (!kern_buf)\r\nreturn -ENOMEM;\r\nif (copy_from_user(kern_buf, (void __user *)buf, nbytes)) {\r\nkfree(kern_buf);\r\nreturn -ENOMEM;\r\n}\r\nrc = sscanf(kern_buf, "%x:%x", &addr, &len);\r\nif (rc < 2) {\r\npr_warn("bna %s: Failed to read user buffer\n",\r\npci_name(bnad->pcidev));\r\nkfree(kern_buf);\r\nreturn -EINVAL;\r\n}\r\nkfree(kern_buf);\r\nkfree(bnad->regdata);\r\nbnad->regdata = NULL;\r\nbnad->reglen = 0;\r\nbnad->regdata = kzalloc(len << 2, GFP_KERNEL);\r\nif (!bnad->regdata)\r\nreturn -ENOMEM;\r\nbnad->reglen = len << 2;\r\nrb = bfa_ioc_bar0(ioc);\r\naddr &= BFA_REG_ADDRMSK(ioc);\r\nrc = bna_reg_offset_check(ioc, addr, len);\r\nif (rc) {\r\npr_warn("bna %s: Failed reg offset check\n",\r\npci_name(bnad->pcidev));\r\nkfree(bnad->regdata);\r\nbnad->regdata = NULL;\r\nbnad->reglen = 0;\r\nreturn -EINVAL;\r\n}\r\nreg_addr = rb + addr;\r\nregbuf = (u32 *)bnad->regdata;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nfor (i = 0; i < len; i++) {\r\n*regbuf = readl(reg_addr);\r\nregbuf++;\r\nreg_addr += sizeof(u32);\r\n}\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nreturn nbytes;\r\n}\r\nstatic ssize_t\r\nbnad_debugfs_write_regwr(struct file *file, const char __user *buf,\r\nsize_t nbytes, loff_t *ppos)\r\n{\r\nstruct bnad_debug_info *debug = file->private_data;\r\nstruct bnad *bnad = (struct bnad *)debug->i_private;\r\nstruct bfa_ioc *ioc = &bnad->bna.ioceth.ioc;\r\nint addr, val, rc;\r\nvoid __iomem *reg_addr;\r\nunsigned long flags;\r\nvoid *kern_buf;\r\nkern_buf = kzalloc(nbytes, GFP_KERNEL);\r\nif (!kern_buf)\r\nreturn -ENOMEM;\r\nif (copy_from_user(kern_buf, (void __user *)buf, nbytes)) {\r\nkfree(kern_buf);\r\nreturn -ENOMEM;\r\n}\r\nrc = sscanf(kern_buf, "%x:%x", &addr, &val);\r\nif (rc < 2) {\r\npr_warn("bna %s: Failed to read user buffer\n",\r\npci_name(bnad->pcidev));\r\nkfree(kern_buf);\r\nreturn -EINVAL;\r\n}\r\nkfree(kern_buf);\r\naddr &= BFA_REG_ADDRMSK(ioc);\r\nrc = bna_reg_offset_check(ioc, addr, 1);\r\nif (rc) {\r\npr_warn("bna %s: Failed reg offset check\n",\r\npci_name(bnad->pcidev));\r\nreturn -EINVAL;\r\n}\r\nreg_addr = (bfa_ioc_bar0(ioc)) + addr;\r\nspin_lock_irqsave(&bnad->bna_lock, flags);\r\nwritel(val, reg_addr);\r\nspin_unlock_irqrestore(&bnad->bna_lock, flags);\r\nreturn nbytes;\r\n}\r\nstatic int\r\nbnad_debugfs_release(struct inode *inode, struct file *file)\r\n{\r\nstruct bnad_debug_info *debug = file->private_data;\r\nif (!debug)\r\nreturn 0;\r\nfile->private_data = NULL;\r\nkfree(debug);\r\nreturn 0;\r\n}\r\nstatic int\r\nbnad_debugfs_buffer_release(struct inode *inode, struct file *file)\r\n{\r\nstruct bnad_debug_info *debug = file->private_data;\r\nif (!debug)\r\nreturn 0;\r\nkfree(debug->debug_buffer);\r\nfile->private_data = NULL;\r\nkfree(debug);\r\ndebug = NULL;\r\nreturn 0;\r\n}\r\nvoid\r\nbnad_debugfs_init(struct bnad *bnad)\r\n{\r\nconst struct bnad_debugfs_entry *file;\r\nchar name[64];\r\nint i;\r\nif (!bna_debugfs_root) {\r\nbna_debugfs_root = debugfs_create_dir("bna", NULL);\r\natomic_set(&bna_debugfs_port_count, 0);\r\nif (!bna_debugfs_root) {\r\npr_warn("BNA: debugfs root dir creation failed\n");\r\nreturn;\r\n}\r\n}\r\nsnprintf(name, sizeof(name), "pci_dev:%s", pci_name(bnad->pcidev));\r\nif (!bnad->port_debugfs_root) {\r\nbnad->port_debugfs_root =\r\ndebugfs_create_dir(name, bna_debugfs_root);\r\nif (!bnad->port_debugfs_root) {\r\npr_warn("bna pci_dev %s: root dir creation failed\n",\r\npci_name(bnad->pcidev));\r\nreturn;\r\n}\r\natomic_inc(&bna_debugfs_port_count);\r\nfor (i = 0; i < ARRAY_SIZE(bnad_debugfs_files); i++) {\r\nfile = &bnad_debugfs_files[i];\r\nbnad->bnad_dentry_files[i] =\r\ndebugfs_create_file(file->name,\r\nfile->mode,\r\nbnad->port_debugfs_root,\r\nbnad,\r\nfile->fops);\r\nif (!bnad->bnad_dentry_files[i]) {\r\npr_warn(\r\n"BNA pci_dev:%s: create %s entry failed\n",\r\npci_name(bnad->pcidev), file->name);\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nvoid\r\nbnad_debugfs_uninit(struct bnad *bnad)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(bnad_debugfs_files); i++) {\r\nif (bnad->bnad_dentry_files[i]) {\r\ndebugfs_remove(bnad->bnad_dentry_files[i]);\r\nbnad->bnad_dentry_files[i] = NULL;\r\n}\r\n}\r\nif (bnad->port_debugfs_root) {\r\ndebugfs_remove(bnad->port_debugfs_root);\r\nbnad->port_debugfs_root = NULL;\r\natomic_dec(&bna_debugfs_port_count);\r\n}\r\nif (atomic_read(&bna_debugfs_port_count) == 0) {\r\ndebugfs_remove(bna_debugfs_root);\r\nbna_debugfs_root = NULL;\r\n}\r\n}
