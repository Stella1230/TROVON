static int uncompress_addr(struct sk_buff *skb,\r\nstruct in6_addr *ipaddr, const u8 address_mode,\r\nconst u8 *lladdr, const u8 addr_type,\r\nconst u8 addr_len)\r\n{\r\nbool fail;\r\nswitch (address_mode) {\r\ncase LOWPAN_IPHC_ADDR_00:\r\nfail = lowpan_fetch_skb(skb, ipaddr->s6_addr, 16);\r\nbreak;\r\ncase LOWPAN_IPHC_ADDR_01:\r\nipaddr->s6_addr[0] = 0xFE;\r\nipaddr->s6_addr[1] = 0x80;\r\nfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[8], 8);\r\nbreak;\r\ncase LOWPAN_IPHC_ADDR_02:\r\nipaddr->s6_addr[0] = 0xFE;\r\nipaddr->s6_addr[1] = 0x80;\r\nipaddr->s6_addr[11] = 0xFF;\r\nipaddr->s6_addr[12] = 0xFE;\r\nfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[14], 2);\r\nbreak;\r\ncase LOWPAN_IPHC_ADDR_03:\r\nfail = false;\r\nswitch (addr_type) {\r\ncase IEEE802154_ADDR_LONG:\r\nipaddr->s6_addr[0] = 0xFE;\r\nipaddr->s6_addr[1] = 0x80;\r\nmemcpy(&ipaddr->s6_addr[8], lladdr, addr_len);\r\nipaddr->s6_addr[8] ^= 0x02;\r\nbreak;\r\ncase IEEE802154_ADDR_SHORT:\r\nipaddr->s6_addr[0] = 0xFE;\r\nipaddr->s6_addr[1] = 0x80;\r\nipaddr->s6_addr[11] = 0xFF;\r\nipaddr->s6_addr[12] = 0xFE;\r\nipaddr->s6_addr16[7] = htons(*((u16 *)lladdr));\r\nbreak;\r\ndefault:\r\npr_debug("Invalid addr_type set\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\npr_debug("Invalid address mode value: 0x%x\n", address_mode);\r\nreturn -EINVAL;\r\n}\r\nif (fail) {\r\npr_debug("Failed to fetch skb data\n");\r\nreturn -EIO;\r\n}\r\nraw_dump_inline(NULL, "Reconstructed ipv6 addr is",\r\nipaddr->s6_addr, 16);\r\nreturn 0;\r\n}\r\nstatic int uncompress_context_based_src_addr(struct sk_buff *skb,\r\nstruct in6_addr *ipaddr,\r\nconst u8 sam)\r\n{\r\nswitch (sam) {\r\ncase LOWPAN_IPHC_ADDR_00:\r\nbreak;\r\ncase LOWPAN_IPHC_ADDR_01:\r\ncase LOWPAN_IPHC_ADDR_02:\r\ncase LOWPAN_IPHC_ADDR_03:\r\nnetdev_warn(skb->dev, "SAM value 0x%x not supported\n", sam);\r\nreturn -EINVAL;\r\ndefault:\r\npr_debug("Invalid sam value: 0x%x\n", sam);\r\nreturn -EINVAL;\r\n}\r\nraw_dump_inline(NULL,\r\n"Reconstructed context based ipv6 src addr is",\r\nipaddr->s6_addr, 16);\r\nreturn 0;\r\n}\r\nstatic int lowpan_uncompress_multicast_daddr(struct sk_buff *skb,\r\nstruct in6_addr *ipaddr,\r\nconst u8 dam)\r\n{\r\nbool fail;\r\nswitch (dam) {\r\ncase LOWPAN_IPHC_DAM_00:\r\nfail = lowpan_fetch_skb(skb, ipaddr->s6_addr, 16);\r\nbreak;\r\ncase LOWPAN_IPHC_DAM_01:\r\nipaddr->s6_addr[0] = 0xFF;\r\nfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[1], 1);\r\nfail |= lowpan_fetch_skb(skb, &ipaddr->s6_addr[11], 5);\r\nbreak;\r\ncase LOWPAN_IPHC_DAM_10:\r\nipaddr->s6_addr[0] = 0xFF;\r\nfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[1], 1);\r\nfail |= lowpan_fetch_skb(skb, &ipaddr->s6_addr[13], 3);\r\nbreak;\r\ncase LOWPAN_IPHC_DAM_11:\r\nipaddr->s6_addr[0] = 0xFF;\r\nipaddr->s6_addr[1] = 0x02;\r\nfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[15], 1);\r\nbreak;\r\ndefault:\r\npr_debug("DAM value has a wrong value: 0x%x\n", dam);\r\nreturn -EINVAL;\r\n}\r\nif (fail) {\r\npr_debug("Failed to fetch skb data\n");\r\nreturn -EIO;\r\n}\r\nraw_dump_inline(NULL, "Reconstructed ipv6 multicast addr is",\r\nipaddr->s6_addr, 16);\r\nreturn 0;\r\n}\r\nstatic int uncompress_udp_header(struct sk_buff *skb, struct udphdr *uh)\r\n{\r\nbool fail;\r\nu8 tmp = 0, val = 0;\r\nfail = lowpan_fetch_skb(skb, &tmp, sizeof(tmp));\r\nif ((tmp & LOWPAN_NHC_UDP_MASK) == LOWPAN_NHC_UDP_ID) {\r\npr_debug("UDP header uncompression\n");\r\nswitch (tmp & LOWPAN_NHC_UDP_CS_P_11) {\r\ncase LOWPAN_NHC_UDP_CS_P_00:\r\nfail |= lowpan_fetch_skb(skb, &uh->source,\r\nsizeof(uh->source));\r\nfail |= lowpan_fetch_skb(skb, &uh->dest,\r\nsizeof(uh->dest));\r\nbreak;\r\ncase LOWPAN_NHC_UDP_CS_P_01:\r\nfail |= lowpan_fetch_skb(skb, &uh->source,\r\nsizeof(uh->source));\r\nfail |= lowpan_fetch_skb(skb, &val, sizeof(val));\r\nuh->dest = htons(val + LOWPAN_NHC_UDP_8BIT_PORT);\r\nbreak;\r\ncase LOWPAN_NHC_UDP_CS_P_10:\r\nfail |= lowpan_fetch_skb(skb, &val, sizeof(val));\r\nuh->source = htons(val + LOWPAN_NHC_UDP_8BIT_PORT);\r\nfail |= lowpan_fetch_skb(skb, &uh->dest,\r\nsizeof(uh->dest));\r\nbreak;\r\ncase LOWPAN_NHC_UDP_CS_P_11:\r\nfail |= lowpan_fetch_skb(skb, &val, sizeof(val));\r\nuh->source = htons(LOWPAN_NHC_UDP_4BIT_PORT +\r\n(val >> 4));\r\nuh->dest = htons(LOWPAN_NHC_UDP_4BIT_PORT +\r\n(val & 0x0f));\r\nbreak;\r\ndefault:\r\npr_debug("ERROR: unknown UDP format\n");\r\ngoto err;\r\n}\r\npr_debug("uncompressed UDP ports: src = %d, dst = %d\n",\r\nntohs(uh->source), ntohs(uh->dest));\r\nif (tmp & LOWPAN_NHC_UDP_CS_C) {\r\npr_debug_ratelimited("checksum elided currently not supported\n");\r\ngoto err;\r\n} else {\r\nfail |= lowpan_fetch_skb(skb, &uh->check,\r\nsizeof(uh->check));\r\n}\r\nuh->len = htons(skb->len + sizeof(struct udphdr));\r\npr_debug("uncompressed UDP length: src = %d", ntohs(uh->len));\r\n} else {\r\npr_debug("ERROR: unsupported NH format\n");\r\ngoto err;\r\n}\r\nif (fail)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nreturn -EINVAL;\r\n}\r\nint\r\nlowpan_header_decompress(struct sk_buff *skb, struct net_device *dev,\r\nconst u8 *saddr, const u8 saddr_type,\r\nconst u8 saddr_len, const u8 *daddr,\r\nconst u8 daddr_type, const u8 daddr_len,\r\nu8 iphc0, u8 iphc1)\r\n{\r\nstruct ipv6hdr hdr = {};\r\nu8 tmp, num_context = 0;\r\nint err;\r\nraw_dump_table(__func__, "raw skb data dump uncompressed",\r\nskb->data, skb->len);\r\nif (iphc1 & LOWPAN_IPHC_CID) {\r\npr_debug("CID flag is set, increase header with one\n");\r\nif (lowpan_fetch_skb(skb, &num_context, sizeof(num_context)))\r\nreturn -EINVAL;\r\n}\r\nhdr.version = 6;\r\nswitch ((iphc0 & LOWPAN_IPHC_TF) >> 3) {\r\ncase 0:\r\nif (lowpan_fetch_skb(skb, &tmp, sizeof(tmp)))\r\nreturn -EINVAL;\r\nmemcpy(&hdr.flow_lbl, &skb->data[0], 3);\r\nskb_pull(skb, 3);\r\nhdr.priority = ((tmp >> 2) & 0x0f);\r\nhdr.flow_lbl[0] = ((tmp >> 2) & 0x30) | (tmp << 6) |\r\n(hdr.flow_lbl[0] & 0x0f);\r\nbreak;\r\ncase 2:\r\nif (lowpan_fetch_skb(skb, &tmp, sizeof(tmp)))\r\nreturn -EINVAL;\r\nhdr.priority = ((tmp >> 2) & 0x0f);\r\nhdr.flow_lbl[0] = ((tmp << 6) & 0xC0) | ((tmp >> 2) & 0x30);\r\nbreak;\r\ncase 1:\r\nif (lowpan_fetch_skb(skb, &tmp, sizeof(tmp)))\r\nreturn -EINVAL;\r\nhdr.flow_lbl[0] = (skb->data[0] & 0x0F) | ((tmp >> 2) & 0x30);\r\nmemcpy(&hdr.flow_lbl[1], &skb->data[0], 2);\r\nskb_pull(skb, 2);\r\nbreak;\r\ncase 3:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif ((iphc0 & LOWPAN_IPHC_NH_C) == 0) {\r\nif (lowpan_fetch_skb(skb, &hdr.nexthdr, sizeof(hdr.nexthdr)))\r\nreturn -EINVAL;\r\npr_debug("NH flag is set, next header carried inline: %02x\n",\r\nhdr.nexthdr);\r\n}\r\nif ((iphc0 & 0x03) != LOWPAN_IPHC_TTL_I) {\r\nhdr.hop_limit = lowpan_ttl_values[iphc0 & 0x03];\r\n} else {\r\nif (lowpan_fetch_skb(skb, &hdr.hop_limit,\r\nsizeof(hdr.hop_limit)))\r\nreturn -EINVAL;\r\n}\r\ntmp = ((iphc1 & LOWPAN_IPHC_SAM) >> LOWPAN_IPHC_SAM_BIT) & 0x03;\r\nif (iphc1 & LOWPAN_IPHC_SAC) {\r\npr_debug("SAC bit is set. Handle context based source address.\n");\r\nerr = uncompress_context_based_src_addr(skb, &hdr.saddr, tmp);\r\n} else {\r\npr_debug("source address stateless compression\n");\r\nerr = uncompress_addr(skb, &hdr.saddr, tmp, saddr,\r\nsaddr_type, saddr_len);\r\n}\r\nif (err)\r\nreturn -EINVAL;\r\ntmp = ((iphc1 & LOWPAN_IPHC_DAM_11) >> LOWPAN_IPHC_DAM_BIT) & 0x03;\r\nif (iphc1 & LOWPAN_IPHC_M) {\r\nif (iphc1 & LOWPAN_IPHC_DAC) {\r\npr_debug("dest: context-based mcast compression\n");\r\n} else {\r\nerr = lowpan_uncompress_multicast_daddr(skb, &hdr.daddr,\r\ntmp);\r\nif (err)\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nerr = uncompress_addr(skb, &hdr.daddr, tmp, daddr,\r\ndaddr_type, daddr_len);\r\npr_debug("dest: stateless compression mode %d dest %pI6c\n",\r\ntmp, &hdr.daddr);\r\nif (err)\r\nreturn -EINVAL;\r\n}\r\nif (iphc0 & LOWPAN_IPHC_NH_C) {\r\nstruct udphdr uh;\r\nconst int needed = sizeof(struct udphdr) + sizeof(hdr);\r\nif (uncompress_udp_header(skb, &uh))\r\nreturn -EINVAL;\r\nerr = skb_cow(skb, needed);\r\nif (unlikely(err))\r\nreturn err;\r\nskb_push(skb, sizeof(struct udphdr));\r\nskb_reset_transport_header(skb);\r\nskb_copy_to_linear_data(skb, &uh, sizeof(struct udphdr));\r\nraw_dump_table(__func__, "raw UDP header dump",\r\n(u8 *)&uh, sizeof(uh));\r\nhdr.nexthdr = UIP_PROTO_UDP;\r\n} else {\r\nerr = skb_cow(skb, sizeof(hdr));\r\nif (unlikely(err))\r\nreturn err;\r\n}\r\nhdr.payload_len = htons(skb->len);\r\npr_debug("skb headroom size = %d, data length = %d\n",\r\nskb_headroom(skb), skb->len);\r\npr_debug("IPv6 header dump:\n\tversion = %d\n\tlength = %d\n\t"\r\n"nexthdr = 0x%02x\n\thop_lim = %d\n\tdest = %pI6c\n",\r\nhdr.version, ntohs(hdr.payload_len), hdr.nexthdr,\r\nhdr.hop_limit, &hdr.daddr);\r\nskb_push(skb, sizeof(hdr));\r\nskb_reset_network_header(skb);\r\nskb_copy_to_linear_data(skb, &hdr, sizeof(hdr));\r\nraw_dump_table(__func__, "raw header dump", (u8 *)&hdr, sizeof(hdr));\r\nreturn 0;\r\n}\r\nstatic u8 lowpan_compress_addr_64(u8 **hc_ptr, u8 shift,\r\nconst struct in6_addr *ipaddr,\r\nconst unsigned char *lladdr)\r\n{\r\nu8 val = 0;\r\nif (is_addr_mac_addr_based(ipaddr, lladdr)) {\r\nval = 3;\r\npr_debug("address compression 0 bits\n");\r\n} else if (lowpan_is_iid_16_bit_compressable(ipaddr)) {\r\nlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr16[7], 2);\r\nval = 2;\r\nraw_dump_inline(NULL, "Compressed ipv6 addr is (16 bits)",\r\n*hc_ptr - 2, 2);\r\n} else {\r\nlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr16[4], 8);\r\nval = 1;\r\nraw_dump_inline(NULL, "Compressed ipv6 addr is (64 bits)",\r\n*hc_ptr - 8, 8);\r\n}\r\nreturn rol8(val, shift);\r\n}\r\nstatic void compress_udp_header(u8 **hc_ptr, struct sk_buff *skb)\r\n{\r\nstruct udphdr *uh;\r\nu8 tmp;\r\nif (skb->transport_header == skb->network_header)\r\nskb_set_transport_header(skb, sizeof(struct ipv6hdr));\r\nuh = udp_hdr(skb);\r\nif (((ntohs(uh->source) & LOWPAN_NHC_UDP_4BIT_MASK) ==\r\nLOWPAN_NHC_UDP_4BIT_PORT) &&\r\n((ntohs(uh->dest) & LOWPAN_NHC_UDP_4BIT_MASK) ==\r\nLOWPAN_NHC_UDP_4BIT_PORT)) {\r\npr_debug("UDP header: both ports compression to 4 bits\n");\r\ntmp = LOWPAN_NHC_UDP_CS_P_11;\r\nlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\r\ntmp = ntohs(uh->dest) - LOWPAN_NHC_UDP_4BIT_PORT +\r\n((ntohs(uh->source) - LOWPAN_NHC_UDP_4BIT_PORT) << 4);\r\nlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\r\n} else if ((ntohs(uh->dest) & LOWPAN_NHC_UDP_8BIT_MASK) ==\r\nLOWPAN_NHC_UDP_8BIT_PORT) {\r\npr_debug("UDP header: remove 8 bits of dest\n");\r\ntmp = LOWPAN_NHC_UDP_CS_P_01;\r\nlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\r\nlowpan_push_hc_data(hc_ptr, &uh->source, sizeof(uh->source));\r\ntmp = ntohs(uh->dest) - LOWPAN_NHC_UDP_8BIT_PORT;\r\nlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\r\n} else if ((ntohs(uh->source) & LOWPAN_NHC_UDP_8BIT_MASK) ==\r\nLOWPAN_NHC_UDP_8BIT_PORT) {\r\npr_debug("UDP header: remove 8 bits of source\n");\r\ntmp = LOWPAN_NHC_UDP_CS_P_10;\r\nlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\r\ntmp = ntohs(uh->source) - LOWPAN_NHC_UDP_8BIT_PORT;\r\nlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\r\nlowpan_push_hc_data(hc_ptr, &uh->dest, sizeof(uh->dest));\r\n} else {\r\npr_debug("UDP header: can't compress\n");\r\ntmp = LOWPAN_NHC_UDP_CS_P_00;\r\nlowpan_push_hc_data(hc_ptr, &tmp, sizeof(tmp));\r\nlowpan_push_hc_data(hc_ptr, &uh->source, sizeof(uh->source));\r\nlowpan_push_hc_data(hc_ptr, &uh->dest, sizeof(uh->dest));\r\n}\r\nlowpan_push_hc_data(hc_ptr, &uh->check, sizeof(uh->check));\r\nskb_pull(skb, sizeof(struct udphdr));\r\n}\r\nint lowpan_header_compress(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type, const void *_daddr,\r\nconst void *_saddr, unsigned int len)\r\n{\r\nu8 tmp, iphc0, iphc1, *hc_ptr;\r\nstruct ipv6hdr *hdr;\r\nu8 head[100] = {};\r\nint addr_type;\r\nif (type != ETH_P_IPV6)\r\nreturn -EINVAL;\r\nhdr = ipv6_hdr(skb);\r\nhc_ptr = head + 2;\r\npr_debug("IPv6 header dump:\n\tversion = %d\n\tlength = %d\n"\r\n"\tnexthdr = 0x%02x\n\thop_lim = %d\n\tdest = %pI6c\n",\r\nhdr->version, ntohs(hdr->payload_len), hdr->nexthdr,\r\nhdr->hop_limit, &hdr->daddr);\r\nraw_dump_table(__func__, "raw skb network header dump",\r\nskb_network_header(skb), sizeof(struct ipv6hdr));\r\niphc0 = LOWPAN_DISPATCH_IPHC;\r\niphc1 = 0;\r\nraw_dump_inline(__func__, "saddr",\r\n(unsigned char *)_saddr, IEEE802154_ADDR_LEN);\r\nraw_dump_inline(__func__, "daddr",\r\n(unsigned char *)_daddr, IEEE802154_ADDR_LEN);\r\nraw_dump_table(__func__, "sending raw skb network uncompressed packet",\r\nskb->data, skb->len);\r\ntmp = (hdr->priority << 4) | (hdr->flow_lbl[0] >> 4);\r\ntmp = ((tmp & 0x03) << 6) | (tmp >> 2);\r\nif (((hdr->flow_lbl[0] & 0x0F) == 0) &&\r\n(hdr->flow_lbl[1] == 0) && (hdr->flow_lbl[2] == 0)) {\r\niphc0 |= LOWPAN_IPHC_FL_C;\r\nif ((hdr->priority == 0) &&\r\n((hdr->flow_lbl[0] & 0xF0) == 0)) {\r\niphc0 |= LOWPAN_IPHC_TC_C;\r\n} else {\r\n*hc_ptr = tmp;\r\nhc_ptr += 1;\r\n}\r\n} else {\r\nif ((hdr->priority == 0) &&\r\n((hdr->flow_lbl[0] & 0xF0) == 0)) {\r\niphc0 |= LOWPAN_IPHC_TC_C;\r\n*hc_ptr = (tmp & 0xc0) | (hdr->flow_lbl[0] & 0x0F);\r\nmemcpy(hc_ptr + 1, &hdr->flow_lbl[1], 2);\r\nhc_ptr += 3;\r\n} else {\r\nmemcpy(hc_ptr, hdr, 4);\r\n*hc_ptr = tmp;\r\nhc_ptr += 4;\r\n}\r\n}\r\nif (hdr->nexthdr == UIP_PROTO_UDP)\r\niphc0 |= LOWPAN_IPHC_NH_C;\r\nif ((iphc0 & LOWPAN_IPHC_NH_C) == 0)\r\nlowpan_push_hc_data(&hc_ptr, &hdr->nexthdr,\r\nsizeof(hdr->nexthdr));\r\nswitch (hdr->hop_limit) {\r\ncase 1:\r\niphc0 |= LOWPAN_IPHC_TTL_1;\r\nbreak;\r\ncase 64:\r\niphc0 |= LOWPAN_IPHC_TTL_64;\r\nbreak;\r\ncase 255:\r\niphc0 |= LOWPAN_IPHC_TTL_255;\r\nbreak;\r\ndefault:\r\nlowpan_push_hc_data(&hc_ptr, &hdr->hop_limit,\r\nsizeof(hdr->hop_limit));\r\n}\r\naddr_type = ipv6_addr_type(&hdr->saddr);\r\nif (addr_type == IPV6_ADDR_ANY) {\r\npr_debug("source address is unspecified, setting SAC\n");\r\niphc1 |= LOWPAN_IPHC_SAC;\r\n} else {\r\nif (addr_type & IPV6_ADDR_LINKLOCAL) {\r\niphc1 |= lowpan_compress_addr_64(&hc_ptr,\r\nLOWPAN_IPHC_SAM_BIT,\r\n&hdr->saddr, _saddr);\r\npr_debug("source address unicast link-local %pI6c iphc1 0x%02x\n",\r\n&hdr->saddr, iphc1);\r\n} else {\r\npr_debug("send the full source address\n");\r\nlowpan_push_hc_data(&hc_ptr, hdr->saddr.s6_addr, 16);\r\n}\r\n}\r\naddr_type = ipv6_addr_type(&hdr->daddr);\r\nif (addr_type & IPV6_ADDR_MULTICAST) {\r\npr_debug("destination address is multicast: ");\r\niphc1 |= LOWPAN_IPHC_M;\r\nif (lowpan_is_mcast_addr_compressable8(&hdr->daddr)) {\r\npr_debug("compressed to 1 octet\n");\r\niphc1 |= LOWPAN_IPHC_DAM_11;\r\nlowpan_push_hc_data(&hc_ptr,\r\n&hdr->daddr.s6_addr[15], 1);\r\n} else if (lowpan_is_mcast_addr_compressable32(&hdr->daddr)) {\r\npr_debug("compressed to 4 octets\n");\r\niphc1 |= LOWPAN_IPHC_DAM_10;\r\nlowpan_push_hc_data(&hc_ptr,\r\n&hdr->daddr.s6_addr[1], 1);\r\nlowpan_push_hc_data(&hc_ptr,\r\n&hdr->daddr.s6_addr[13], 3);\r\n} else if (lowpan_is_mcast_addr_compressable48(&hdr->daddr)) {\r\npr_debug("compressed to 6 octets\n");\r\niphc1 |= LOWPAN_IPHC_DAM_01;\r\nlowpan_push_hc_data(&hc_ptr,\r\n&hdr->daddr.s6_addr[1], 1);\r\nlowpan_push_hc_data(&hc_ptr,\r\n&hdr->daddr.s6_addr[11], 5);\r\n} else {\r\npr_debug("using full address\n");\r\niphc1 |= LOWPAN_IPHC_DAM_00;\r\nlowpan_push_hc_data(&hc_ptr, hdr->daddr.s6_addr, 16);\r\n}\r\n} else {\r\nif (addr_type & IPV6_ADDR_LINKLOCAL) {\r\niphc1 |= lowpan_compress_addr_64(&hc_ptr,\r\nLOWPAN_IPHC_DAM_BIT, &hdr->daddr, _daddr);\r\npr_debug("dest address unicast link-local %pI6c "\r\n"iphc1 0x%02x\n", &hdr->daddr, iphc1);\r\n} else {\r\npr_debug("dest address unicast %pI6c\n", &hdr->daddr);\r\nlowpan_push_hc_data(&hc_ptr, hdr->daddr.s6_addr, 16);\r\n}\r\n}\r\nif (hdr->nexthdr == UIP_PROTO_UDP)\r\ncompress_udp_header(&hc_ptr, skb);\r\nhead[0] = iphc0;\r\nhead[1] = iphc1;\r\nskb_pull(skb, sizeof(struct ipv6hdr));\r\nskb_reset_transport_header(skb);\r\nmemcpy(skb_push(skb, hc_ptr - head), head, hc_ptr - head);\r\nskb_reset_network_header(skb);\r\npr_debug("header len %d skb %u\n", (int)(hc_ptr - head), skb->len);\r\nraw_dump_table(__func__, "raw skb data dump compressed",\r\nskb->data, skb->len);\r\nreturn 0;\r\n}
