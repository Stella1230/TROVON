static void socfpga_dwmac_fix_mac_speed(void *priv, unsigned int speed)\r\n{\r\nstruct socfpga_dwmac *dwmac = (struct socfpga_dwmac *)priv;\r\nvoid __iomem *splitter_base = dwmac->splitter_base;\r\nu32 val;\r\nif (!splitter_base)\r\nreturn;\r\nval = readl(splitter_base + EMAC_SPLITTER_CTRL_REG);\r\nval &= ~EMAC_SPLITTER_CTRL_SPEED_MASK;\r\nswitch (speed) {\r\ncase 1000:\r\nval |= EMAC_SPLITTER_CTRL_SPEED_1000;\r\nbreak;\r\ncase 100:\r\nval |= EMAC_SPLITTER_CTRL_SPEED_100;\r\nbreak;\r\ncase 10:\r\nval |= EMAC_SPLITTER_CTRL_SPEED_10;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nwritel(val, splitter_base + EMAC_SPLITTER_CTRL_REG);\r\n}\r\nstatic int socfpga_dwmac_parse_data(struct socfpga_dwmac *dwmac, struct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct regmap *sys_mgr_base_addr;\r\nu32 reg_offset, reg_shift;\r\nint ret;\r\nstruct device_node *np_splitter;\r\nstruct resource res_splitter;\r\ndwmac->stmmac_rst = devm_reset_control_get(dev,\r\nSTMMAC_RESOURCE_NAME);\r\nif (IS_ERR(dwmac->stmmac_rst)) {\r\ndev_info(dev, "Could not get reset control!\n");\r\nreturn -EINVAL;\r\n}\r\ndwmac->interface = of_get_phy_mode(np);\r\nsys_mgr_base_addr = syscon_regmap_lookup_by_phandle(np, "altr,sysmgr-syscon");\r\nif (IS_ERR(sys_mgr_base_addr)) {\r\ndev_info(dev, "No sysmgr-syscon node found\n");\r\nreturn PTR_ERR(sys_mgr_base_addr);\r\n}\r\nret = of_property_read_u32_index(np, "altr,sysmgr-syscon", 1, &reg_offset);\r\nif (ret) {\r\ndev_info(dev, "Could not read reg_offset from sysmgr-syscon!\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_property_read_u32_index(np, "altr,sysmgr-syscon", 2, &reg_shift);\r\nif (ret) {\r\ndev_info(dev, "Could not read reg_shift from sysmgr-syscon!\n");\r\nreturn -EINVAL;\r\n}\r\nnp_splitter = of_parse_phandle(np, "altr,emac-splitter", 0);\r\nif (np_splitter) {\r\nif (of_address_to_resource(np_splitter, 0, &res_splitter)) {\r\ndev_info(dev, "Missing emac splitter address\n");\r\nreturn -EINVAL;\r\n}\r\ndwmac->splitter_base = devm_ioremap_resource(dev, &res_splitter);\r\nif (IS_ERR(dwmac->splitter_base)) {\r\ndev_info(dev, "Failed to mapping emac splitter\n");\r\nreturn PTR_ERR(dwmac->splitter_base);\r\n}\r\n}\r\ndwmac->reg_offset = reg_offset;\r\ndwmac->reg_shift = reg_shift;\r\ndwmac->sys_mgr_base_addr = sys_mgr_base_addr;\r\ndwmac->dev = dev;\r\nreturn 0;\r\n}\r\nstatic int socfpga_dwmac_setup(struct socfpga_dwmac *dwmac)\r\n{\r\nstruct regmap *sys_mgr_base_addr = dwmac->sys_mgr_base_addr;\r\nint phymode = dwmac->interface;\r\nu32 reg_offset = dwmac->reg_offset;\r\nu32 reg_shift = dwmac->reg_shift;\r\nu32 ctrl, val;\r\nswitch (phymode) {\r\ncase PHY_INTERFACE_MODE_RGMII:\r\ncase PHY_INTERFACE_MODE_RGMII_ID:\r\nval = SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_RGMII;\r\nbreak;\r\ncase PHY_INTERFACE_MODE_MII:\r\ncase PHY_INTERFACE_MODE_GMII:\r\nval = SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_GMII_MII;\r\nbreak;\r\ndefault:\r\ndev_err(dwmac->dev, "bad phy mode %d\n", phymode);\r\nreturn -EINVAL;\r\n}\r\nif (dwmac->splitter_base)\r\nval = SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_GMII_MII;\r\nregmap_read(sys_mgr_base_addr, reg_offset, &ctrl);\r\nctrl &= ~(SYSMGR_EMACGRP_CTRL_PHYSEL_MASK << reg_shift);\r\nctrl |= val << reg_shift;\r\nregmap_write(sys_mgr_base_addr, reg_offset, ctrl);\r\nreturn 0;\r\n}\r\nstatic void *socfpga_dwmac_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\nstruct socfpga_dwmac *dwmac;\r\ndwmac = devm_kzalloc(dev, sizeof(*dwmac), GFP_KERNEL);\r\nif (!dwmac)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = socfpga_dwmac_parse_data(dwmac, dev);\r\nif (ret) {\r\ndev_err(dev, "Unable to parse OF data\n");\r\nreturn ERR_PTR(ret);\r\n}\r\nret = socfpga_dwmac_setup(dwmac);\r\nif (ret) {\r\ndev_err(dev, "couldn't setup SoC glue (%d)\n", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn dwmac;\r\n}\r\nstatic void socfpga_dwmac_exit(struct platform_device *pdev, void *priv)\r\n{\r\nstruct socfpga_dwmac *dwmac = priv;\r\nif (dwmac->stmmac_rst)\r\nreset_control_assert(dwmac->stmmac_rst);\r\n}\r\nstatic int socfpga_dwmac_init(struct platform_device *pdev, void *priv)\r\n{\r\nstruct socfpga_dwmac *dwmac = priv;\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct stmmac_priv *stpriv = NULL;\r\nint ret = 0;\r\nif (ndev)\r\nstpriv = netdev_priv(ndev);\r\nif (dwmac->stmmac_rst)\r\nreset_control_assert(dwmac->stmmac_rst);\r\nret = socfpga_dwmac_setup(dwmac);\r\nif (dwmac->stmmac_rst)\r\nreset_control_deassert(dwmac->stmmac_rst);\r\nif (stpriv && stpriv->phydev)\r\nphy_resume(stpriv->phydev);\r\nreturn ret;\r\n}
