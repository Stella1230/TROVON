static int m88ds3103_wr_regs(struct m88ds3103_priv *priv,\r\nu8 reg, const u8 *val, int len)\r\n{\r\n#define MAX_WR_LEN 32\r\n#define MAX_WR_XFER_LEN (MAX_WR_LEN + 1)\r\nint ret;\r\nu8 buf[MAX_WR_XFER_LEN];\r\nstruct i2c_msg msg[1] = {\r\n{\r\n.addr = priv->cfg->i2c_addr,\r\n.flags = 0,\r\n.len = 1 + len,\r\n.buf = buf,\r\n}\r\n};\r\nif (WARN_ON(len > MAX_WR_LEN))\r\nreturn -EINVAL;\r\nbuf[0] = reg;\r\nmemcpy(&buf[1], val, len);\r\nmutex_lock(&priv->i2c_mutex);\r\nret = i2c_transfer(priv->i2c, msg, 1);\r\nmutex_unlock(&priv->i2c_mutex);\r\nif (ret == 1) {\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c wr failed=%d reg=%02x len=%d\n",\r\nKBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_rd_regs(struct m88ds3103_priv *priv,\r\nu8 reg, u8 *val, int len)\r\n{\r\n#define MAX_RD_LEN 3\r\n#define MAX_RD_XFER_LEN (MAX_RD_LEN)\r\nint ret;\r\nu8 buf[MAX_RD_XFER_LEN];\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = priv->cfg->i2c_addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg,\r\n}, {\r\n.addr = priv->cfg->i2c_addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = buf,\r\n}\r\n};\r\nif (WARN_ON(len > MAX_RD_LEN))\r\nreturn -EINVAL;\r\nmutex_lock(&priv->i2c_mutex);\r\nret = i2c_transfer(priv->i2c, msg, 2);\r\nmutex_unlock(&priv->i2c_mutex);\r\nif (ret == 2) {\r\nmemcpy(val, buf, len);\r\nret = 0;\r\n} else {\r\ndev_warn(&priv->i2c->dev,\r\n"%s: i2c rd failed=%d reg=%02x len=%d\n",\r\nKBUILD_MODNAME, ret, reg, len);\r\nret = -EREMOTEIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_wr_reg(struct m88ds3103_priv *priv, u8 reg, u8 val)\r\n{\r\nreturn m88ds3103_wr_regs(priv, reg, &val, 1);\r\n}\r\nstatic int m88ds3103_rd_reg(struct m88ds3103_priv *priv, u8 reg, u8 *val)\r\n{\r\nreturn m88ds3103_rd_regs(priv, reg, val, 1);\r\n}\r\nstatic int m88ds3103_wr_reg_mask(struct m88ds3103_priv *priv,\r\nu8 reg, u8 val, u8 mask)\r\n{\r\nint ret;\r\nu8 u8tmp;\r\nif (mask != 0xff) {\r\nret = m88ds3103_rd_regs(priv, reg, &u8tmp, 1);\r\nif (ret)\r\nreturn ret;\r\nval &= mask;\r\nu8tmp &= ~mask;\r\nval |= u8tmp;\r\n}\r\nreturn m88ds3103_wr_regs(priv, reg, &val, 1);\r\n}\r\nstatic int m88ds3103_rd_reg_mask(struct m88ds3103_priv *priv,\r\nu8 reg, u8 *val, u8 mask)\r\n{\r\nint ret, i;\r\nu8 u8tmp;\r\nret = m88ds3103_rd_regs(priv, reg, &u8tmp, 1);\r\nif (ret)\r\nreturn ret;\r\nu8tmp &= mask;\r\nfor (i = 0; i < 8; i++) {\r\nif ((mask >> i) & 0x01)\r\nbreak;\r\n}\r\n*val = u8tmp >> i;\r\nreturn 0;\r\n}\r\nstatic int m88ds3103_wr_reg_val_tab(struct m88ds3103_priv *priv,\r\nconst struct m88ds3103_reg_val *tab, int tab_len)\r\n{\r\nint ret, i, j;\r\nu8 buf[83];\r\ndev_dbg(&priv->i2c->dev, "%s: tab_len=%d\n", __func__, tab_len);\r\nif (tab_len > 86) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nfor (i = 0, j = 0; i < tab_len; i++, j++) {\r\nbuf[j] = tab[i].val;\r\nif (i == tab_len - 1 || tab[i].reg != tab[i + 1].reg - 1 ||\r\n!((j + 1) % (priv->cfg->i2c_wr_max - 1))) {\r\nret = m88ds3103_wr_regs(priv, tab[i].reg - j, buf, j + 1);\r\nif (ret)\r\ngoto err;\r\nj = -1;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct m88ds3103_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nu8 u8tmp;\r\n*status = 0;\r\nif (!priv->warm) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\nret = m88ds3103_rd_reg_mask(priv, 0xd1, &u8tmp, 0x07);\r\nif (ret)\r\ngoto err;\r\nif (u8tmp == 0x07)\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC |\r\nFE_HAS_LOCK;\r\nbreak;\r\ncase SYS_DVBS2:\r\nret = m88ds3103_rd_reg_mask(priv, 0x0d, &u8tmp, 0x8f);\r\nif (ret)\r\ngoto err;\r\nif (u8tmp == 0x8f)\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC |\r\nFE_HAS_LOCK;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid delivery_system\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\npriv->fe_status = *status;\r\ndev_dbg(&priv->i2c->dev, "%s: lock=%02x status=%02x\n",\r\n__func__, u8tmp, *status);\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct m88ds3103_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, len;\r\nconst struct m88ds3103_reg_val *init;\r\nu8 u8tmp, u8tmp1 = 0, u8tmp2 = 0;\r\nu8 buf[3];\r\nu16 u16tmp, divide_ratio = 0;\r\nu32 tuner_frequency, target_mclk;\r\ns32 s32tmp;\r\ndev_dbg(&priv->i2c->dev,\r\n"%s: delivery_system=%d modulation=%d frequency=%d symbol_rate=%d inversion=%d pilot=%d rolloff=%d\n",\r\n__func__, c->delivery_system,\r\nc->modulation, c->frequency, c->symbol_rate,\r\nc->inversion, c->pilot, c->rolloff);\r\nif (!priv->warm) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nret = m88ds3103_wr_reg(priv, 0x07, 0x80);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg(priv, 0x07, 0x00);\r\nif (ret)\r\ngoto err;\r\nif (priv->chip_id == M88RS6000_CHIP_ID) {\r\nret = m88ds3103_wr_reg(priv, 0x06, 0xe0);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (fe->ops.tuner_ops.set_params) {\r\nret = fe->ops.tuner_ops.set_params(fe);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (fe->ops.tuner_ops.get_frequency) {\r\nret = fe->ops.tuner_ops.get_frequency(fe, &tuner_frequency);\r\nif (ret)\r\ngoto err;\r\n} else {\r\ntuner_frequency = c->frequency;\r\n}\r\nif (priv->chip_id == M88RS6000_CHIP_ID) {\r\nif (c->symbol_rate > 45010000)\r\npriv->mclk_khz = 110250;\r\nelse\r\npriv->mclk_khz = 96000;\r\nif (c->delivery_system == SYS_DVBS)\r\ntarget_mclk = 96000;\r\nelse\r\ntarget_mclk = 144000;\r\nret = m88ds3103_wr_reg(priv, 0x06, 0x00);\r\nif (ret)\r\ngoto err;\r\nusleep_range(10000, 20000);\r\n} else {\r\npriv->mclk_khz = 96000;\r\nswitch (priv->cfg->ts_mode) {\r\ncase M88DS3103_TS_SERIAL:\r\ncase M88DS3103_TS_SERIAL_D7:\r\ntarget_mclk = priv->cfg->ts_clk;\r\nbreak;\r\ncase M88DS3103_TS_PARALLEL:\r\ncase M88DS3103_TS_CI:\r\nif (c->delivery_system == SYS_DVBS)\r\ntarget_mclk = 96000;\r\nelse {\r\nif (c->symbol_rate < 18000000)\r\ntarget_mclk = 96000;\r\nelse if (c->symbol_rate < 28000000)\r\ntarget_mclk = 144000;\r\nelse\r\ntarget_mclk = 192000;\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid ts_mode\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nswitch (target_mclk) {\r\ncase 96000:\r\nu8tmp1 = 0x02;\r\nu8tmp2 = 0x01;\r\nbreak;\r\ncase 144000:\r\nu8tmp1 = 0x00;\r\nu8tmp2 = 0x01;\r\nbreak;\r\ncase 192000:\r\nu8tmp1 = 0x03;\r\nu8tmp2 = 0x00;\r\nbreak;\r\n}\r\nret = m88ds3103_wr_reg_mask(priv, 0x22, u8tmp1 << 6, 0xc0);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg_mask(priv, 0x24, u8tmp2 << 6, 0xc0);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = m88ds3103_wr_reg(priv, 0xb2, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg(priv, 0x00, 0x01);\r\nif (ret)\r\ngoto err;\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\nif (priv->chip_id == M88RS6000_CHIP_ID) {\r\nlen = ARRAY_SIZE(m88rs6000_dvbs_init_reg_vals);\r\ninit = m88rs6000_dvbs_init_reg_vals;\r\n} else {\r\nlen = ARRAY_SIZE(m88ds3103_dvbs_init_reg_vals);\r\ninit = m88ds3103_dvbs_init_reg_vals;\r\n}\r\nbreak;\r\ncase SYS_DVBS2:\r\nif (priv->chip_id == M88RS6000_CHIP_ID) {\r\nlen = ARRAY_SIZE(m88rs6000_dvbs2_init_reg_vals);\r\ninit = m88rs6000_dvbs2_init_reg_vals;\r\n} else {\r\nlen = ARRAY_SIZE(m88ds3103_dvbs2_init_reg_vals);\r\ninit = m88ds3103_dvbs2_init_reg_vals;\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid delivery_system\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (c->delivery_system != priv->delivery_system) {\r\nret = m88ds3103_wr_reg_val_tab(priv, init, len);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (priv->chip_id == M88RS6000_CHIP_ID) {\r\nif ((c->delivery_system == SYS_DVBS2)\r\n&& ((c->symbol_rate / 1000) <= 5000)) {\r\nret = m88ds3103_wr_reg(priv, 0xc0, 0x04);\r\nif (ret)\r\ngoto err;\r\nbuf[0] = 0x09;\r\nbuf[1] = 0x22;\r\nbuf[2] = 0x88;\r\nret = m88ds3103_wr_regs(priv, 0x8a, buf, 3);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = m88ds3103_wr_reg_mask(priv, 0x9d, 0x08, 0x08);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg(priv, 0xf1, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg_mask(priv, 0x30, 0x80, 0x80);\r\nif (ret)\r\ngoto err;\r\n}\r\nswitch (priv->cfg->ts_mode) {\r\ncase M88DS3103_TS_SERIAL:\r\nu8tmp1 = 0x00;\r\nu8tmp = 0x06;\r\nbreak;\r\ncase M88DS3103_TS_SERIAL_D7:\r\nu8tmp1 = 0x20;\r\nu8tmp = 0x06;\r\nbreak;\r\ncase M88DS3103_TS_PARALLEL:\r\nu8tmp = 0x02;\r\nbreak;\r\ncase M88DS3103_TS_CI:\r\nu8tmp = 0x03;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid ts_mode\n", __func__);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (priv->cfg->ts_clk_pol)\r\nu8tmp |= 0x40;\r\nret = m88ds3103_wr_reg(priv, 0xfd, u8tmp);\r\nif (ret)\r\ngoto err;\r\nswitch (priv->cfg->ts_mode) {\r\ncase M88DS3103_TS_SERIAL:\r\ncase M88DS3103_TS_SERIAL_D7:\r\nret = m88ds3103_wr_reg_mask(priv, 0x29, u8tmp1, 0x20);\r\nif (ret)\r\ngoto err;\r\nu8tmp1 = 0;\r\nu8tmp2 = 0;\r\nbreak;\r\ndefault:\r\nif (priv->cfg->ts_clk) {\r\ndivide_ratio = DIV_ROUND_UP(target_mclk, priv->cfg->ts_clk);\r\nu8tmp1 = divide_ratio / 2;\r\nu8tmp2 = DIV_ROUND_UP(divide_ratio, 2);\r\n}\r\n}\r\ndev_dbg(&priv->i2c->dev,\r\n"%s: target_mclk=%d ts_clk=%d divide_ratio=%d\n",\r\n__func__, target_mclk, priv->cfg->ts_clk, divide_ratio);\r\nu8tmp1--;\r\nu8tmp2--;\r\nu8tmp1 &= 0x3f;\r\nu8tmp2 &= 0x3f;\r\nret = m88ds3103_rd_reg(priv, 0xfe, &u8tmp);\r\nif (ret)\r\ngoto err;\r\nu8tmp = ((u8tmp & 0xf0) << 0) | u8tmp1 >> 2;\r\nret = m88ds3103_wr_reg(priv, 0xfe, u8tmp);\r\nif (ret)\r\ngoto err;\r\nu8tmp = ((u8tmp1 & 0x03) << 6) | u8tmp2 >> 0;\r\nret = m88ds3103_wr_reg(priv, 0xea, u8tmp);\r\nif (ret)\r\ngoto err;\r\nif (c->symbol_rate <= 3000000)\r\nu8tmp = 0x20;\r\nelse if (c->symbol_rate <= 10000000)\r\nu8tmp = 0x10;\r\nelse\r\nu8tmp = 0x06;\r\nret = m88ds3103_wr_reg(priv, 0xc3, 0x08);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg(priv, 0xc8, u8tmp);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg(priv, 0xc4, 0x08);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg(priv, 0xc7, 0x00);\r\nif (ret)\r\ngoto err;\r\nu16tmp = DIV_ROUND_CLOSEST((c->symbol_rate / 1000) << 15, priv->mclk_khz / 2);\r\nbuf[0] = (u16tmp >> 0) & 0xff;\r\nbuf[1] = (u16tmp >> 8) & 0xff;\r\nret = m88ds3103_wr_regs(priv, 0x61, buf, 2);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg_mask(priv, 0x4d, priv->cfg->spec_inv << 1, 0x02);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg_mask(priv, 0x30, priv->cfg->agc_inv << 4, 0x10);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg(priv, 0x33, priv->cfg->agc);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&priv->i2c->dev, "%s: carrier offset=%d\n", __func__,\r\n(tuner_frequency - c->frequency));\r\ns32tmp = 0x10000 * (tuner_frequency - c->frequency);\r\ns32tmp = DIV_ROUND_CLOSEST(s32tmp, priv->mclk_khz);\r\nif (s32tmp < 0)\r\ns32tmp += 0x10000;\r\nbuf[0] = (s32tmp >> 0) & 0xff;\r\nbuf[1] = (s32tmp >> 8) & 0xff;\r\nret = m88ds3103_wr_regs(priv, 0x5e, buf, 2);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg(priv, 0x00, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg(priv, 0xb2, 0x00);\r\nif (ret)\r\ngoto err;\r\npriv->delivery_system = c->delivery_system;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_init(struct dvb_frontend *fe)\r\n{\r\nstruct m88ds3103_priv *priv = fe->demodulator_priv;\r\nint ret, len, remaining;\r\nconst struct firmware *fw = NULL;\r\nu8 *fw_file;\r\nu8 u8tmp;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\npriv->warm = false;\r\nret = m88ds3103_wr_reg_mask(priv, 0x08, 0x01, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg_mask(priv, 0x04, 0x00, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg_mask(priv, 0x23, 0x00, 0x10);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_rd_reg(priv, 0xb9, &u8tmp);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&priv->i2c->dev, "%s: firmware=%02x\n", __func__, u8tmp);\r\nif (u8tmp)\r\ngoto skip_fw_download;\r\nret = m88ds3103_wr_reg(priv, 0x07, 0xe0);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg(priv, 0x07, 0x00);\r\nif (ret)\r\ngoto err;\r\ndev_info(&priv->i2c->dev, "%s: found a '%s' in cold state\n",\r\nKBUILD_MODNAME, m88ds3103_ops.info.name);\r\nif (priv->chip_id == M88RS6000_CHIP_ID)\r\nfw_file = M88RS6000_FIRMWARE;\r\nelse\r\nfw_file = M88DS3103_FIRMWARE;\r\nret = request_firmware(&fw, fw_file, priv->i2c->dev.parent);\r\nif (ret) {\r\ndev_err(&priv->i2c->dev, "%s: firmare file '%s' not found\n",\r\nKBUILD_MODNAME, fw_file);\r\ngoto err;\r\n}\r\ndev_info(&priv->i2c->dev, "%s: downloading firmware from file '%s'\n",\r\nKBUILD_MODNAME, fw_file);\r\nret = m88ds3103_wr_reg(priv, 0xb2, 0x01);\r\nif (ret)\r\ngoto error_fw_release;\r\nfor (remaining = fw->size; remaining > 0;\r\nremaining -= (priv->cfg->i2c_wr_max - 1)) {\r\nlen = remaining;\r\nif (len > (priv->cfg->i2c_wr_max - 1))\r\nlen = (priv->cfg->i2c_wr_max - 1);\r\nret = m88ds3103_wr_regs(priv, 0xb0,\r\n&fw->data[fw->size - remaining], len);\r\nif (ret) {\r\ndev_err(&priv->i2c->dev,\r\n"%s: firmware download failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\ngoto error_fw_release;\r\n}\r\n}\r\nret = m88ds3103_wr_reg(priv, 0xb2, 0x00);\r\nif (ret)\r\ngoto error_fw_release;\r\nrelease_firmware(fw);\r\nfw = NULL;\r\nret = m88ds3103_rd_reg(priv, 0xb9, &u8tmp);\r\nif (ret)\r\ngoto err;\r\nif (!u8tmp) {\r\ndev_info(&priv->i2c->dev, "%s: firmware did not run\n",\r\nKBUILD_MODNAME);\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\ndev_info(&priv->i2c->dev, "%s: found a '%s' in warm state\n",\r\nKBUILD_MODNAME, m88ds3103_ops.info.name);\r\ndev_info(&priv->i2c->dev, "%s: firmware version %X.%X\n",\r\nKBUILD_MODNAME, (u8tmp >> 4) & 0xf, (u8tmp >> 0 & 0xf));\r\nskip_fw_download:\r\npriv->warm = true;\r\nreturn 0;\r\nerror_fw_release:\r\nrelease_firmware(fw);\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct m88ds3103_priv *priv = fe->demodulator_priv;\r\nint ret;\r\nu8 u8tmp;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\npriv->delivery_system = SYS_UNDEFINED;\r\nif (priv->chip_id == M88RS6000_CHIP_ID)\r\nu8tmp = 0x29;\r\nelse\r\nu8tmp = 0x27;\r\nret = m88ds3103_wr_reg_mask(priv, u8tmp, 0x00, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg_mask(priv, 0x08, 0x00, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg_mask(priv, 0x04, 0x01, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg_mask(priv, 0x23, 0x10, 0x10);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct m88ds3103_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nu8 buf[3];\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\nif (!priv->warm || !(priv->fe_status & FE_HAS_LOCK)) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\nret = m88ds3103_rd_reg(priv, 0xe0, &buf[0]);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_rd_reg(priv, 0xe6, &buf[1]);\r\nif (ret)\r\ngoto err;\r\nswitch ((buf[0] >> 2) & 0x01) {\r\ncase 0:\r\nc->inversion = INVERSION_OFF;\r\nbreak;\r\ncase 1:\r\nc->inversion = INVERSION_ON;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 5) & 0x07) {\r\ncase 0:\r\nc->fec_inner = FEC_7_8;\r\nbreak;\r\ncase 1:\r\nc->fec_inner = FEC_5_6;\r\nbreak;\r\ncase 2:\r\nc->fec_inner = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->fec_inner = FEC_2_3;\r\nbreak;\r\ncase 4:\r\nc->fec_inner = FEC_1_2;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid fec_inner\n",\r\n__func__);\r\n}\r\nc->modulation = QPSK;\r\nbreak;\r\ncase SYS_DVBS2:\r\nret = m88ds3103_rd_reg(priv, 0x7e, &buf[0]);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_rd_reg(priv, 0x89, &buf[1]);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_rd_reg(priv, 0xf2, &buf[2]);\r\nif (ret)\r\ngoto err;\r\nswitch ((buf[0] >> 0) & 0x0f) {\r\ncase 2:\r\nc->fec_inner = FEC_2_5;\r\nbreak;\r\ncase 3:\r\nc->fec_inner = FEC_1_2;\r\nbreak;\r\ncase 4:\r\nc->fec_inner = FEC_3_5;\r\nbreak;\r\ncase 5:\r\nc->fec_inner = FEC_2_3;\r\nbreak;\r\ncase 6:\r\nc->fec_inner = FEC_3_4;\r\nbreak;\r\ncase 7:\r\nc->fec_inner = FEC_4_5;\r\nbreak;\r\ncase 8:\r\nc->fec_inner = FEC_5_6;\r\nbreak;\r\ncase 9:\r\nc->fec_inner = FEC_8_9;\r\nbreak;\r\ncase 10:\r\nc->fec_inner = FEC_9_10;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid fec_inner\n",\r\n__func__);\r\n}\r\nswitch ((buf[0] >> 5) & 0x01) {\r\ncase 0:\r\nc->pilot = PILOT_OFF;\r\nbreak;\r\ncase 1:\r\nc->pilot = PILOT_ON;\r\nbreak;\r\n}\r\nswitch ((buf[0] >> 6) & 0x07) {\r\ncase 0:\r\nc->modulation = QPSK;\r\nbreak;\r\ncase 1:\r\nc->modulation = PSK_8;\r\nbreak;\r\ncase 2:\r\nc->modulation = APSK_16;\r\nbreak;\r\ncase 3:\r\nc->modulation = APSK_32;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid modulation\n",\r\n__func__);\r\n}\r\nswitch ((buf[1] >> 7) & 0x01) {\r\ncase 0:\r\nc->inversion = INVERSION_OFF;\r\nbreak;\r\ncase 1:\r\nc->inversion = INVERSION_ON;\r\nbreak;\r\n}\r\nswitch ((buf[2] >> 0) & 0x03) {\r\ncase 0:\r\nc->rolloff = ROLLOFF_35;\r\nbreak;\r\ncase 1:\r\nc->rolloff = ROLLOFF_25;\r\nbreak;\r\ncase 2:\r\nc->rolloff = ROLLOFF_20;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid rolloff\n",\r\n__func__);\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid delivery_system\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = m88ds3103_rd_regs(priv, 0x6d, buf, 2);\r\nif (ret)\r\ngoto err;\r\nc->symbol_rate = 1ull * ((buf[1] << 8) | (buf[0] << 0)) *\r\npriv->mclk_khz * 1000 / 0x10000;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct m88ds3103_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i, tmp;\r\nu8 buf[3];\r\nu16 noise, signal;\r\nu32 noise_tot, signal_tot;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\n#define M88DS3103_SNR_ITERATIONS 3\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\ntmp = 0;\r\nfor (i = 0; i < M88DS3103_SNR_ITERATIONS; i++) {\r\nret = m88ds3103_rd_reg(priv, 0xff, &buf[0]);\r\nif (ret)\r\ngoto err;\r\ntmp += buf[0];\r\n}\r\ntmp = DIV_ROUND_CLOSEST(tmp, 8 * M88DS3103_SNR_ITERATIONS);\r\nif (tmp)\r\n*snr = div_u64((u64) 100 * intlog2(tmp), intlog2(10));\r\nelse\r\n*snr = 0;\r\nbreak;\r\ncase SYS_DVBS2:\r\nnoise_tot = 0;\r\nsignal_tot = 0;\r\nfor (i = 0; i < M88DS3103_SNR_ITERATIONS; i++) {\r\nret = m88ds3103_rd_regs(priv, 0x8c, buf, 3);\r\nif (ret)\r\ngoto err;\r\nnoise = buf[1] << 6;\r\nnoise |= buf[0] & 0x3f;\r\nnoise >>= 2;\r\nsignal = buf[2] * buf[2];\r\nsignal >>= 1;\r\nnoise_tot += noise;\r\nsignal_tot += signal;\r\n}\r\nnoise = noise_tot / M88DS3103_SNR_ITERATIONS;\r\nsignal = signal_tot / M88DS3103_SNR_ITERATIONS;\r\nif (signal > noise) {\r\ntmp = signal / noise;\r\n*snr = div_u64((u64) 100 * intlog10(tmp), (1 << 24));\r\n} else {\r\n*snr = 0;\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid delivery_system\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct m88ds3103_priv *priv = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nunsigned int utmp;\r\nu8 buf[3], u8tmp;\r\ndev_dbg(&priv->i2c->dev, "%s:\n", __func__);\r\nswitch (c->delivery_system) {\r\ncase SYS_DVBS:\r\nret = m88ds3103_wr_reg(priv, 0xf9, 0x04);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_rd_reg(priv, 0xf8, &u8tmp);\r\nif (ret)\r\ngoto err;\r\nif (!(u8tmp & 0x10)) {\r\nu8tmp |= 0x10;\r\nret = m88ds3103_rd_regs(priv, 0xf6, buf, 2);\r\nif (ret)\r\ngoto err;\r\npriv->ber = (buf[1] << 8) | (buf[0] << 0);\r\nret = m88ds3103_wr_reg(priv, 0xf8, u8tmp);\r\nif (ret)\r\ngoto err;\r\n}\r\nbreak;\r\ncase SYS_DVBS2:\r\nret = m88ds3103_rd_regs(priv, 0xd5, buf, 3);\r\nif (ret)\r\ngoto err;\r\nutmp = (buf[2] << 16) | (buf[1] << 8) | (buf[0] << 0);\r\nif (utmp > 3000) {\r\nret = m88ds3103_rd_regs(priv, 0xf7, buf, 2);\r\nif (ret)\r\ngoto err;\r\npriv->ber = (buf[1] << 8) | (buf[0] << 0);\r\nret = m88ds3103_wr_reg(priv, 0xd1, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg(priv, 0xf9, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg(priv, 0xf9, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg(priv, 0xd1, 0x00);\r\nif (ret)\r\ngoto err;\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid delivery_system\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\n*ber = priv->ber;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_set_tone(struct dvb_frontend *fe,\r\nfe_sec_tone_mode_t fe_sec_tone_mode)\r\n{\r\nstruct m88ds3103_priv *priv = fe->demodulator_priv;\r\nint ret;\r\nu8 u8tmp, tone, reg_a1_mask;\r\ndev_dbg(&priv->i2c->dev, "%s: fe_sec_tone_mode=%d\n", __func__,\r\nfe_sec_tone_mode);\r\nif (!priv->warm) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nswitch (fe_sec_tone_mode) {\r\ncase SEC_TONE_ON:\r\ntone = 0;\r\nreg_a1_mask = 0x47;\r\nbreak;\r\ncase SEC_TONE_OFF:\r\ntone = 1;\r\nreg_a1_mask = 0x00;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid fe_sec_tone_mode\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nu8tmp = tone << 7 | priv->cfg->envelope_mode << 5;\r\nret = m88ds3103_wr_reg_mask(priv, 0xa2, u8tmp, 0xe0);\r\nif (ret)\r\ngoto err;\r\nu8tmp = 1 << 2;\r\nret = m88ds3103_wr_reg_mask(priv, 0xa1, u8tmp, reg_a1_mask);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_set_voltage(struct dvb_frontend *fe,\r\nfe_sec_voltage_t fe_sec_voltage)\r\n{\r\nstruct m88ds3103_priv *priv = fe->demodulator_priv;\r\nint ret;\r\nu8 u8tmp;\r\nbool voltage_sel, voltage_dis;\r\ndev_dbg(&priv->i2c->dev, "%s: fe_sec_voltage=%d\n", __func__,\r\nfe_sec_voltage);\r\nif (!priv->warm) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nswitch (fe_sec_voltage) {\r\ncase SEC_VOLTAGE_18:\r\nvoltage_sel = true;\r\nvoltage_dis = false;\r\nbreak;\r\ncase SEC_VOLTAGE_13:\r\nvoltage_sel = false;\r\nvoltage_dis = false;\r\nbreak;\r\ncase SEC_VOLTAGE_OFF:\r\nvoltage_sel = false;\r\nvoltage_dis = true;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid fe_sec_voltage\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nvoltage_sel ^= priv->cfg->lnb_hv_pol;\r\nvoltage_dis ^= priv->cfg->lnb_en_pol;\r\nu8tmp = voltage_dis << 1 | voltage_sel << 0;\r\nret = m88ds3103_wr_reg_mask(priv, 0xa2, u8tmp, 0x03);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_diseqc_send_master_cmd(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_master_cmd *diseqc_cmd)\r\n{\r\nstruct m88ds3103_priv *priv = fe->demodulator_priv;\r\nint ret, i;\r\nu8 u8tmp;\r\ndev_dbg(&priv->i2c->dev, "%s: msg=%*ph\n", __func__,\r\ndiseqc_cmd->msg_len, diseqc_cmd->msg);\r\nif (!priv->warm) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nif (diseqc_cmd->msg_len < 3 || diseqc_cmd->msg_len > 6) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nu8tmp = priv->cfg->envelope_mode << 5;\r\nret = m88ds3103_wr_reg_mask(priv, 0xa2, u8tmp, 0xe0);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_regs(priv, 0xa3, diseqc_cmd->msg,\r\ndiseqc_cmd->msg_len);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg(priv, 0xa1,\r\n(diseqc_cmd->msg_len - 1) << 3 | 0x07);\r\nif (ret)\r\ngoto err;\r\nusleep_range(40000, 60000);\r\nfor (i = 20, u8tmp = 1; i && u8tmp; i--) {\r\nusleep_range(5000, 10000);\r\nret = m88ds3103_rd_reg_mask(priv, 0xa1, &u8tmp, 0x40);\r\nif (ret)\r\ngoto err;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s: loop=%d\n", __func__, i);\r\nif (i == 0) {\r\ndev_dbg(&priv->i2c->dev, "%s: diseqc tx timeout\n", __func__);\r\nret = m88ds3103_wr_reg_mask(priv, 0xa1, 0x40, 0xc0);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = m88ds3103_wr_reg_mask(priv, 0xa2, 0x80, 0xc0);\r\nif (ret)\r\ngoto err;\r\nif (i == 0) {\r\nret = -ETIMEDOUT;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_diseqc_send_burst(struct dvb_frontend *fe,\r\nfe_sec_mini_cmd_t fe_sec_mini_cmd)\r\n{\r\nstruct m88ds3103_priv *priv = fe->demodulator_priv;\r\nint ret, i;\r\nu8 u8tmp, burst;\r\ndev_dbg(&priv->i2c->dev, "%s: fe_sec_mini_cmd=%d\n", __func__,\r\nfe_sec_mini_cmd);\r\nif (!priv->warm) {\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nu8tmp = priv->cfg->envelope_mode << 5;\r\nret = m88ds3103_wr_reg_mask(priv, 0xa2, u8tmp, 0xe0);\r\nif (ret)\r\ngoto err;\r\nswitch (fe_sec_mini_cmd) {\r\ncase SEC_MINI_A:\r\nburst = 0x02;\r\nbreak;\r\ncase SEC_MINI_B:\r\nburst = 0x01;\r\nbreak;\r\ndefault:\r\ndev_dbg(&priv->i2c->dev, "%s: invalid fe_sec_mini_cmd\n",\r\n__func__);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = m88ds3103_wr_reg(priv, 0xa1, burst);\r\nif (ret)\r\ngoto err;\r\nusleep_range(11000, 20000);\r\nfor (i = 5, u8tmp = 1; i && u8tmp; i--) {\r\nusleep_range(800, 2000);\r\nret = m88ds3103_rd_reg_mask(priv, 0xa1, &u8tmp, 0x40);\r\nif (ret)\r\ngoto err;\r\n}\r\ndev_dbg(&priv->i2c->dev, "%s: loop=%d\n", __func__, i);\r\nret = m88ds3103_wr_reg_mask(priv, 0xa2, 0x80, 0xc0);\r\nif (ret)\r\ngoto err;\r\nif (i == 0) {\r\ndev_dbg(&priv->i2c->dev, "%s: diseqc tx timeout\n", __func__);\r\nret = -ETIMEDOUT;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&priv->i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int m88ds3103_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *s)\r\n{\r\ns->min_delay_ms = 3000;\r\nreturn 0;\r\n}\r\nstatic void m88ds3103_release(struct dvb_frontend *fe)\r\n{\r\nstruct m88ds3103_priv *priv = fe->demodulator_priv;\r\ni2c_del_mux_adapter(priv->i2c_adapter);\r\nkfree(priv);\r\n}\r\nstatic int m88ds3103_select(struct i2c_adapter *adap, void *mux_priv, u32 chan)\r\n{\r\nstruct m88ds3103_priv *priv = mux_priv;\r\nint ret;\r\nstruct i2c_msg gate_open_msg[1] = {\r\n{\r\n.addr = priv->cfg->i2c_addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = "\x03\x11",\r\n}\r\n};\r\nmutex_lock(&priv->i2c_mutex);\r\nret = __i2c_transfer(priv->i2c, gate_open_msg, 1);\r\nif (ret != 1) {\r\ndev_warn(&priv->i2c->dev, "%s: i2c wr failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\nif (ret >= 0)\r\nret = -EREMOTEIO;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int m88ds3103_deselect(struct i2c_adapter *adap, void *mux_priv,\r\nu32 chan)\r\n{\r\nstruct m88ds3103_priv *priv = mux_priv;\r\nmutex_unlock(&priv->i2c_mutex);\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *m88ds3103_attach(const struct m88ds3103_config *cfg,\r\nstruct i2c_adapter *i2c, struct i2c_adapter **tuner_i2c_adapter)\r\n{\r\nint ret;\r\nstruct m88ds3103_priv *priv;\r\nu8 chip_id, u8tmp;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\nret = -ENOMEM;\r\ndev_err(&i2c->dev, "%s: kzalloc() failed\n", KBUILD_MODNAME);\r\ngoto err;\r\n}\r\npriv->cfg = cfg;\r\npriv->i2c = i2c;\r\nmutex_init(&priv->i2c_mutex);\r\nret = m88ds3103_rd_reg(priv, 0x00, &chip_id);\r\nif (ret)\r\ngoto err;\r\nchip_id >>= 1;\r\ndev_info(&priv->i2c->dev, "%s: chip_id=%02x\n", __func__, chip_id);\r\nswitch (chip_id) {\r\ncase M88RS6000_CHIP_ID:\r\ncase M88DS3103_CHIP_ID:\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\npriv->chip_id = chip_id;\r\nswitch (priv->cfg->clock_out) {\r\ncase M88DS3103_CLOCK_OUT_DISABLED:\r\nu8tmp = 0x80;\r\nbreak;\r\ncase M88DS3103_CLOCK_OUT_ENABLED:\r\nu8tmp = 0x00;\r\nbreak;\r\ncase M88DS3103_CLOCK_OUT_ENABLED_DIV2:\r\nu8tmp = 0x10;\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\nif (chip_id == M88RS6000_CHIP_ID)\r\nu8tmp = 0x00;\r\nret = m88ds3103_wr_reg(priv, 0x29, u8tmp);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg_mask(priv, 0x08, 0x00, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg_mask(priv, 0x04, 0x01, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = m88ds3103_wr_reg_mask(priv, 0x23, 0x10, 0x10);\r\nif (ret)\r\ngoto err;\r\npriv->i2c_adapter = i2c_add_mux_adapter(i2c, &i2c->dev, priv, 0, 0, 0,\r\nm88ds3103_select, m88ds3103_deselect);\r\nif (priv->i2c_adapter == NULL)\r\ngoto err;\r\n*tuner_i2c_adapter = priv->i2c_adapter;\r\nmemcpy(&priv->fe.ops, &m88ds3103_ops, sizeof(struct dvb_frontend_ops));\r\nif (priv->chip_id == M88RS6000_CHIP_ID)\r\nstrncpy(priv->fe.ops.info.name,\r\n"Montage M88RS6000", sizeof(priv->fe.ops.info.name));\r\npriv->fe.demodulator_priv = priv;\r\nreturn &priv->fe;\r\nerr:\r\ndev_dbg(&i2c->dev, "%s: failed=%d\n", __func__, ret);\r\nkfree(priv);\r\nreturn NULL;\r\n}
