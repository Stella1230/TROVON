static inline bool\r\nspi_match(u_int32_t min, u_int32_t max, u_int32_t spi, bool invert)\r\n{\r\nbool r;\r\npr_debug("spi_match:%c 0x%x <= 0x%x <= 0x%x\n",\r\ninvert ? '!' : ' ', min, spi, max);\r\nr = (spi >= min && spi <= max) ^ invert;\r\npr_debug(" result %s\n", r ? "PASS" : "FAILED");\r\nreturn r;\r\n}\r\nstatic bool comp_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nstruct ip_comp_hdr _comphdr;\r\nconst struct ip_comp_hdr *chdr;\r\nconst struct xt_ipcomp *compinfo = par->matchinfo;\r\nif (par->fragoff != 0)\r\nreturn false;\r\nchdr = skb_header_pointer(skb, par->thoff, sizeof(_comphdr), &_comphdr);\r\nif (chdr == NULL) {\r\npr_debug("Dropping evil IPComp tinygram.\n");\r\npar->hotdrop = true;\r\nreturn 0;\r\n}\r\nreturn spi_match(compinfo->spis[0], compinfo->spis[1],\r\nntohs(chdr->cpi),\r\n!!(compinfo->invflags & XT_IPCOMP_INV_SPI));\r\n}\r\nstatic int comp_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_ipcomp *compinfo = par->matchinfo;\r\nif (compinfo->invflags & ~XT_IPCOMP_INV_MASK) {\r\npr_err("unknown flags %X\n", compinfo->invflags);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init comp_mt_init(void)\r\n{\r\nreturn xt_register_matches(comp_mt_reg, ARRAY_SIZE(comp_mt_reg));\r\n}\r\nstatic void __exit comp_mt_exit(void)\r\n{\r\nxt_unregister_matches(comp_mt_reg, ARRAY_SIZE(comp_mt_reg));\r\n}
