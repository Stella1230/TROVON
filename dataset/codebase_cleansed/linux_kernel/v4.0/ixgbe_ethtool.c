static int ixgbe_get_settings(struct net_device *netdev,\r\nstruct ethtool_cmd *ecmd)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nixgbe_link_speed supported_link;\r\nu32 link_speed = 0;\r\nbool autoneg = false;\r\nbool link_up;\r\nhw->mac.ops.get_link_capabilities(hw, &supported_link, &autoneg);\r\nif (supported_link & IXGBE_LINK_SPEED_10GB_FULL)\r\necmd->supported |= SUPPORTED_10000baseT_Full;\r\nif (supported_link & IXGBE_LINK_SPEED_1GB_FULL)\r\necmd->supported |= SUPPORTED_1000baseT_Full;\r\nif (supported_link & IXGBE_LINK_SPEED_100_FULL)\r\necmd->supported |= SUPPORTED_100baseT_Full;\r\nif (hw->phy.autoneg_advertised) {\r\nif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_100_FULL)\r\necmd->advertising |= ADVERTISED_100baseT_Full;\r\nif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_10GB_FULL)\r\necmd->advertising |= ADVERTISED_10000baseT_Full;\r\nif (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_1GB_FULL)\r\necmd->advertising |= ADVERTISED_1000baseT_Full;\r\n} else {\r\nif (supported_link & IXGBE_LINK_SPEED_10GB_FULL)\r\necmd->advertising |= ADVERTISED_10000baseT_Full;\r\nif (supported_link & IXGBE_LINK_SPEED_1GB_FULL)\r\necmd->advertising |= ADVERTISED_1000baseT_Full;\r\nif (supported_link & IXGBE_LINK_SPEED_100_FULL)\r\necmd->advertising |= ADVERTISED_100baseT_Full;\r\nif (hw->phy.multispeed_fiber && !autoneg) {\r\nif (supported_link & IXGBE_LINK_SPEED_10GB_FULL)\r\necmd->advertising = ADVERTISED_10000baseT_Full;\r\n}\r\n}\r\nif (autoneg) {\r\necmd->supported |= SUPPORTED_Autoneg;\r\necmd->advertising |= ADVERTISED_Autoneg;\r\necmd->autoneg = AUTONEG_ENABLE;\r\n} else\r\necmd->autoneg = AUTONEG_DISABLE;\r\necmd->transceiver = XCVR_EXTERNAL;\r\nswitch (adapter->hw.phy.type) {\r\ncase ixgbe_phy_tn:\r\ncase ixgbe_phy_aq:\r\ncase ixgbe_phy_cu_unknown:\r\necmd->supported |= SUPPORTED_TP;\r\necmd->advertising |= ADVERTISED_TP;\r\necmd->port = PORT_TP;\r\nbreak;\r\ncase ixgbe_phy_qt:\r\necmd->supported |= SUPPORTED_FIBRE;\r\necmd->advertising |= ADVERTISED_FIBRE;\r\necmd->port = PORT_FIBRE;\r\nbreak;\r\ncase ixgbe_phy_nl:\r\ncase ixgbe_phy_sfp_passive_tyco:\r\ncase ixgbe_phy_sfp_passive_unknown:\r\ncase ixgbe_phy_sfp_ftl:\r\ncase ixgbe_phy_sfp_avago:\r\ncase ixgbe_phy_sfp_intel:\r\ncase ixgbe_phy_sfp_unknown:\r\nswitch (adapter->hw.phy.sfp_type) {\r\ncase ixgbe_sfp_type_da_cu:\r\ncase ixgbe_sfp_type_da_cu_core0:\r\ncase ixgbe_sfp_type_da_cu_core1:\r\necmd->supported |= SUPPORTED_FIBRE;\r\necmd->advertising |= ADVERTISED_FIBRE;\r\necmd->port = PORT_DA;\r\nbreak;\r\ncase ixgbe_sfp_type_sr:\r\ncase ixgbe_sfp_type_lr:\r\ncase ixgbe_sfp_type_srlr_core0:\r\ncase ixgbe_sfp_type_srlr_core1:\r\ncase ixgbe_sfp_type_1g_sx_core0:\r\ncase ixgbe_sfp_type_1g_sx_core1:\r\ncase ixgbe_sfp_type_1g_lx_core0:\r\ncase ixgbe_sfp_type_1g_lx_core1:\r\necmd->supported |= SUPPORTED_FIBRE;\r\necmd->advertising |= ADVERTISED_FIBRE;\r\necmd->port = PORT_FIBRE;\r\nbreak;\r\ncase ixgbe_sfp_type_not_present:\r\necmd->supported |= SUPPORTED_FIBRE;\r\necmd->advertising |= ADVERTISED_FIBRE;\r\necmd->port = PORT_NONE;\r\nbreak;\r\ncase ixgbe_sfp_type_1g_cu_core0:\r\ncase ixgbe_sfp_type_1g_cu_core1:\r\necmd->supported |= SUPPORTED_TP;\r\necmd->advertising |= ADVERTISED_TP;\r\necmd->port = PORT_TP;\r\nbreak;\r\ncase ixgbe_sfp_type_unknown:\r\ndefault:\r\necmd->supported |= SUPPORTED_FIBRE;\r\necmd->advertising |= ADVERTISED_FIBRE;\r\necmd->port = PORT_OTHER;\r\nbreak;\r\n}\r\nbreak;\r\ncase ixgbe_phy_xaui:\r\necmd->supported |= SUPPORTED_FIBRE;\r\necmd->advertising |= ADVERTISED_FIBRE;\r\necmd->port = PORT_NONE;\r\nbreak;\r\ncase ixgbe_phy_unknown:\r\ncase ixgbe_phy_generic:\r\ncase ixgbe_phy_sfp_unsupported:\r\ndefault:\r\necmd->supported |= SUPPORTED_FIBRE;\r\necmd->advertising |= ADVERTISED_FIBRE;\r\necmd->port = PORT_OTHER;\r\nbreak;\r\n}\r\nhw->mac.ops.check_link(hw, &link_speed, &link_up, false);\r\nif (link_up) {\r\nswitch (link_speed) {\r\ncase IXGBE_LINK_SPEED_10GB_FULL:\r\nethtool_cmd_speed_set(ecmd, SPEED_10000);\r\nbreak;\r\ncase IXGBE_LINK_SPEED_1GB_FULL:\r\nethtool_cmd_speed_set(ecmd, SPEED_1000);\r\nbreak;\r\ncase IXGBE_LINK_SPEED_100_FULL:\r\nethtool_cmd_speed_set(ecmd, SPEED_100);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\necmd->duplex = DUPLEX_FULL;\r\n} else {\r\nethtool_cmd_speed_set(ecmd, SPEED_UNKNOWN);\r\necmd->duplex = DUPLEX_UNKNOWN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ixgbe_set_settings(struct net_device *netdev,\r\nstruct ethtool_cmd *ecmd)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 advertised, old;\r\ns32 err = 0;\r\nif ((hw->phy.media_type == ixgbe_media_type_copper) ||\r\n(hw->phy.multispeed_fiber)) {\r\nif (ecmd->advertising & ~ecmd->supported)\r\nreturn -EINVAL;\r\nif (!ecmd->autoneg && hw->phy.multispeed_fiber) {\r\nif (ecmd->advertising ==\r\n(ADVERTISED_10000baseT_Full |\r\nADVERTISED_1000baseT_Full))\r\nreturn -EINVAL;\r\n}\r\nold = hw->phy.autoneg_advertised;\r\nadvertised = 0;\r\nif (ecmd->advertising & ADVERTISED_10000baseT_Full)\r\nadvertised |= IXGBE_LINK_SPEED_10GB_FULL;\r\nif (ecmd->advertising & ADVERTISED_1000baseT_Full)\r\nadvertised |= IXGBE_LINK_SPEED_1GB_FULL;\r\nif (ecmd->advertising & ADVERTISED_100baseT_Full)\r\nadvertised |= IXGBE_LINK_SPEED_100_FULL;\r\nif (old == advertised)\r\nreturn err;\r\nwhile (test_and_set_bit(__IXGBE_IN_SFP_INIT, &adapter->state))\r\nusleep_range(1000, 2000);\r\nhw->mac.autotry_restart = true;\r\nerr = hw->mac.ops.setup_link(hw, advertised, true);\r\nif (err) {\r\ne_info(probe, "setup link failed with code %d\n", err);\r\nhw->mac.ops.setup_link(hw, old, true);\r\n}\r\nclear_bit(__IXGBE_IN_SFP_INIT, &adapter->state);\r\n} else {\r\nu32 speed = ethtool_cmd_speed(ecmd);\r\nif ((ecmd->autoneg == AUTONEG_ENABLE) ||\r\n(ecmd->advertising != ADVERTISED_10000baseT_Full) ||\r\n(speed + ecmd->duplex != SPEED_10000 + DUPLEX_FULL))\r\nreturn -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic void ixgbe_get_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nif (ixgbe_device_supports_autoneg_fc(hw) &&\r\n!hw->fc.disable_fc_autoneg)\r\npause->autoneg = 1;\r\nelse\r\npause->autoneg = 0;\r\nif (hw->fc.current_mode == ixgbe_fc_rx_pause) {\r\npause->rx_pause = 1;\r\n} else if (hw->fc.current_mode == ixgbe_fc_tx_pause) {\r\npause->tx_pause = 1;\r\n} else if (hw->fc.current_mode == ixgbe_fc_full) {\r\npause->rx_pause = 1;\r\npause->tx_pause = 1;\r\n}\r\n}\r\nstatic int ixgbe_set_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nstruct ixgbe_fc_info fc = hw->fc;\r\nif ((hw->mac.type == ixgbe_mac_82598EB) &&\r\n(adapter->flags & IXGBE_FLAG_DCB_ENABLED))\r\nreturn -EINVAL;\r\nif ((pause->autoneg == AUTONEG_ENABLE) &&\r\n!ixgbe_device_supports_autoneg_fc(hw))\r\nreturn -EINVAL;\r\nfc.disable_fc_autoneg = (pause->autoneg != AUTONEG_ENABLE);\r\nif ((pause->rx_pause && pause->tx_pause) || pause->autoneg)\r\nfc.requested_mode = ixgbe_fc_full;\r\nelse if (pause->rx_pause && !pause->tx_pause)\r\nfc.requested_mode = ixgbe_fc_rx_pause;\r\nelse if (!pause->rx_pause && pause->tx_pause)\r\nfc.requested_mode = ixgbe_fc_tx_pause;\r\nelse\r\nfc.requested_mode = ixgbe_fc_none;\r\nif (memcmp(&fc, &hw->fc, sizeof(struct ixgbe_fc_info))) {\r\nhw->fc = fc;\r\nif (netif_running(netdev))\r\nixgbe_reinit_locked(adapter);\r\nelse\r\nixgbe_reset(adapter);\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 ixgbe_get_msglevel(struct net_device *netdev)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nreturn adapter->msg_enable;\r\n}\r\nstatic void ixgbe_set_msglevel(struct net_device *netdev, u32 data)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nadapter->msg_enable = data;\r\n}\r\nstatic int ixgbe_get_regs_len(struct net_device *netdev)\r\n{\r\n#define IXGBE_REGS_LEN 1139\r\nreturn IXGBE_REGS_LEN * sizeof(u32);\r\n}\r\nstatic void ixgbe_get_regs(struct net_device *netdev,\r\nstruct ethtool_regs *regs, void *p)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 *regs_buff = p;\r\nu8 i;\r\nmemset(p, 0, IXGBE_REGS_LEN * sizeof(u32));\r\nregs->version = hw->mac.type << 24 | hw->revision_id << 16 |\r\nhw->device_id;\r\nregs_buff[0] = IXGBE_READ_REG(hw, IXGBE_CTRL);\r\nregs_buff[1] = IXGBE_READ_REG(hw, IXGBE_STATUS);\r\nregs_buff[2] = IXGBE_READ_REG(hw, IXGBE_CTRL_EXT);\r\nregs_buff[3] = IXGBE_READ_REG(hw, IXGBE_ESDP);\r\nregs_buff[4] = IXGBE_READ_REG(hw, IXGBE_EODSDP);\r\nregs_buff[5] = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\r\nregs_buff[6] = IXGBE_READ_REG(hw, IXGBE_FRTIMER);\r\nregs_buff[7] = IXGBE_READ_REG(hw, IXGBE_TCPTIMER);\r\nregs_buff[8] = IXGBE_READ_REG(hw, IXGBE_EEC);\r\nregs_buff[9] = IXGBE_READ_REG(hw, IXGBE_EERD);\r\nregs_buff[10] = IXGBE_READ_REG(hw, IXGBE_FLA);\r\nregs_buff[11] = IXGBE_READ_REG(hw, IXGBE_EEMNGCTL);\r\nregs_buff[12] = IXGBE_READ_REG(hw, IXGBE_EEMNGDATA);\r\nregs_buff[13] = IXGBE_READ_REG(hw, IXGBE_FLMNGCTL);\r\nregs_buff[14] = IXGBE_READ_REG(hw, IXGBE_FLMNGDATA);\r\nregs_buff[15] = IXGBE_READ_REG(hw, IXGBE_FLMNGCNT);\r\nregs_buff[16] = IXGBE_READ_REG(hw, IXGBE_FLOP);\r\nregs_buff[17] = IXGBE_READ_REG(hw, IXGBE_GRC);\r\nregs_buff[18] = IXGBE_READ_REG(hw, IXGBE_EICS);\r\nregs_buff[19] = IXGBE_READ_REG(hw, IXGBE_EICS);\r\nregs_buff[20] = IXGBE_READ_REG(hw, IXGBE_EIMS);\r\nregs_buff[21] = IXGBE_READ_REG(hw, IXGBE_EIMC);\r\nregs_buff[22] = IXGBE_READ_REG(hw, IXGBE_EIAC);\r\nregs_buff[23] = IXGBE_READ_REG(hw, IXGBE_EIAM);\r\nregs_buff[24] = IXGBE_READ_REG(hw, IXGBE_EITR(0));\r\nregs_buff[25] = IXGBE_READ_REG(hw, IXGBE_IVAR(0));\r\nregs_buff[26] = IXGBE_READ_REG(hw, IXGBE_MSIXT);\r\nregs_buff[27] = IXGBE_READ_REG(hw, IXGBE_MSIXPBA);\r\nregs_buff[28] = IXGBE_READ_REG(hw, IXGBE_PBACL(0));\r\nregs_buff[29] = IXGBE_READ_REG(hw, IXGBE_GPIE);\r\nregs_buff[30] = IXGBE_READ_REG(hw, IXGBE_PFCTOP);\r\nregs_buff[31] = IXGBE_READ_REG(hw, IXGBE_FCTTV(0));\r\nregs_buff[32] = IXGBE_READ_REG(hw, IXGBE_FCTTV(1));\r\nregs_buff[33] = IXGBE_READ_REG(hw, IXGBE_FCTTV(2));\r\nregs_buff[34] = IXGBE_READ_REG(hw, IXGBE_FCTTV(3));\r\nfor (i = 0; i < 8; i++) {\r\nswitch (hw->mac.type) {\r\ncase ixgbe_mac_82598EB:\r\nregs_buff[35 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTL(i));\r\nregs_buff[43 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTH(i));\r\nbreak;\r\ncase ixgbe_mac_82599EB:\r\ncase ixgbe_mac_X540:\r\ncase ixgbe_mac_X550:\r\ncase ixgbe_mac_X550EM_x:\r\nregs_buff[35 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTL_82599(i));\r\nregs_buff[43 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTH_82599(i));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nregs_buff[51] = IXGBE_READ_REG(hw, IXGBE_FCRTV);\r\nregs_buff[52] = IXGBE_READ_REG(hw, IXGBE_TFCS);\r\nfor (i = 0; i < 64; i++)\r\nregs_buff[53 + i] = IXGBE_READ_REG(hw, IXGBE_RDBAL(i));\r\nfor (i = 0; i < 64; i++)\r\nregs_buff[117 + i] = IXGBE_READ_REG(hw, IXGBE_RDBAH(i));\r\nfor (i = 0; i < 64; i++)\r\nregs_buff[181 + i] = IXGBE_READ_REG(hw, IXGBE_RDLEN(i));\r\nfor (i = 0; i < 64; i++)\r\nregs_buff[245 + i] = IXGBE_READ_REG(hw, IXGBE_RDH(i));\r\nfor (i = 0; i < 64; i++)\r\nregs_buff[309 + i] = IXGBE_READ_REG(hw, IXGBE_RDT(i));\r\nfor (i = 0; i < 64; i++)\r\nregs_buff[373 + i] = IXGBE_READ_REG(hw, IXGBE_RXDCTL(i));\r\nfor (i = 0; i < 16; i++)\r\nregs_buff[437 + i] = IXGBE_READ_REG(hw, IXGBE_SRRCTL(i));\r\nfor (i = 0; i < 16; i++)\r\nregs_buff[453 + i] = IXGBE_READ_REG(hw, IXGBE_DCA_RXCTRL(i));\r\nregs_buff[469] = IXGBE_READ_REG(hw, IXGBE_RDRXCTL);\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[470 + i] = IXGBE_READ_REG(hw, IXGBE_RXPBSIZE(i));\r\nregs_buff[478] = IXGBE_READ_REG(hw, IXGBE_RXCTRL);\r\nregs_buff[479] = IXGBE_READ_REG(hw, IXGBE_DROPEN);\r\nregs_buff[480] = IXGBE_READ_REG(hw, IXGBE_RXCSUM);\r\nregs_buff[481] = IXGBE_READ_REG(hw, IXGBE_RFCTL);\r\nfor (i = 0; i < 16; i++)\r\nregs_buff[482 + i] = IXGBE_READ_REG(hw, IXGBE_RAL(i));\r\nfor (i = 0; i < 16; i++)\r\nregs_buff[498 + i] = IXGBE_READ_REG(hw, IXGBE_RAH(i));\r\nregs_buff[514] = IXGBE_READ_REG(hw, IXGBE_PSRTYPE(0));\r\nregs_buff[515] = IXGBE_READ_REG(hw, IXGBE_FCTRL);\r\nregs_buff[516] = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);\r\nregs_buff[517] = IXGBE_READ_REG(hw, IXGBE_MCSTCTRL);\r\nregs_buff[518] = IXGBE_READ_REG(hw, IXGBE_MRQC);\r\nregs_buff[519] = IXGBE_READ_REG(hw, IXGBE_VMD_CTL);\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[520 + i] = IXGBE_READ_REG(hw, IXGBE_IMIR(i));\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[528 + i] = IXGBE_READ_REG(hw, IXGBE_IMIREXT(i));\r\nregs_buff[536] = IXGBE_READ_REG(hw, IXGBE_IMIRVP);\r\nfor (i = 0; i < 32; i++)\r\nregs_buff[537 + i] = IXGBE_READ_REG(hw, IXGBE_TDBAL(i));\r\nfor (i = 0; i < 32; i++)\r\nregs_buff[569 + i] = IXGBE_READ_REG(hw, IXGBE_TDBAH(i));\r\nfor (i = 0; i < 32; i++)\r\nregs_buff[601 + i] = IXGBE_READ_REG(hw, IXGBE_TDLEN(i));\r\nfor (i = 0; i < 32; i++)\r\nregs_buff[633 + i] = IXGBE_READ_REG(hw, IXGBE_TDH(i));\r\nfor (i = 0; i < 32; i++)\r\nregs_buff[665 + i] = IXGBE_READ_REG(hw, IXGBE_TDT(i));\r\nfor (i = 0; i < 32; i++)\r\nregs_buff[697 + i] = IXGBE_READ_REG(hw, IXGBE_TXDCTL(i));\r\nfor (i = 0; i < 32; i++)\r\nregs_buff[729 + i] = IXGBE_READ_REG(hw, IXGBE_TDWBAL(i));\r\nfor (i = 0; i < 32; i++)\r\nregs_buff[761 + i] = IXGBE_READ_REG(hw, IXGBE_TDWBAH(i));\r\nregs_buff[793] = IXGBE_READ_REG(hw, IXGBE_DTXCTL);\r\nfor (i = 0; i < 16; i++)\r\nregs_buff[794 + i] = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL(i));\r\nregs_buff[810] = IXGBE_READ_REG(hw, IXGBE_TIPG);\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[811 + i] = IXGBE_READ_REG(hw, IXGBE_TXPBSIZE(i));\r\nregs_buff[819] = IXGBE_READ_REG(hw, IXGBE_MNGTXMAP);\r\nregs_buff[820] = IXGBE_READ_REG(hw, IXGBE_WUC);\r\nregs_buff[821] = IXGBE_READ_REG(hw, IXGBE_WUFC);\r\nregs_buff[822] = IXGBE_READ_REG(hw, IXGBE_WUS);\r\nregs_buff[823] = IXGBE_READ_REG(hw, IXGBE_IPAV);\r\nregs_buff[824] = IXGBE_READ_REG(hw, IXGBE_IP4AT);\r\nregs_buff[825] = IXGBE_READ_REG(hw, IXGBE_IP6AT);\r\nregs_buff[826] = IXGBE_READ_REG(hw, IXGBE_WUPL);\r\nregs_buff[827] = IXGBE_READ_REG(hw, IXGBE_WUPM);\r\nregs_buff[828] = IXGBE_READ_REG(hw, IXGBE_FHFT(0));\r\nregs_buff[829] = IXGBE_READ_REG(hw, IXGBE_RMCS);\r\nregs_buff[831] = IXGBE_READ_REG(hw, IXGBE_PDPMCS);\r\nswitch (hw->mac.type) {\r\ncase ixgbe_mac_82598EB:\r\nregs_buff[830] = IXGBE_READ_REG(hw, IXGBE_DPMCS);\r\nregs_buff[832] = IXGBE_READ_REG(hw, IXGBE_RUPPBMR);\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[833 + i] =\r\nIXGBE_READ_REG(hw, IXGBE_RT2CR(i));\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[841 + i] =\r\nIXGBE_READ_REG(hw, IXGBE_RT2SR(i));\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[849 + i] =\r\nIXGBE_READ_REG(hw, IXGBE_TDTQ2TCCR(i));\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[857 + i] =\r\nIXGBE_READ_REG(hw, IXGBE_TDTQ2TCSR(i));\r\nbreak;\r\ncase ixgbe_mac_82599EB:\r\ncase ixgbe_mac_X540:\r\ncase ixgbe_mac_X550:\r\ncase ixgbe_mac_X550EM_x:\r\nregs_buff[830] = IXGBE_READ_REG(hw, IXGBE_RTTDCS);\r\nregs_buff[832] = IXGBE_READ_REG(hw, IXGBE_RTRPCS);\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[833 + i] =\r\nIXGBE_READ_REG(hw, IXGBE_RTRPT4C(i));\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[841 + i] =\r\nIXGBE_READ_REG(hw, IXGBE_RTRPT4S(i));\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[849 + i] =\r\nIXGBE_READ_REG(hw, IXGBE_RTTDT2C(i));\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[857 + i] =\r\nIXGBE_READ_REG(hw, IXGBE_RTTDT2S(i));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[865 + i] =\r\nIXGBE_READ_REG(hw, IXGBE_TDPT2TCCR(i));\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[873 + i] =\r\nIXGBE_READ_REG(hw, IXGBE_TDPT2TCSR(i));\r\nregs_buff[881] = IXGBE_GET_STAT(adapter, crcerrs);\r\nregs_buff[882] = IXGBE_GET_STAT(adapter, illerrc);\r\nregs_buff[883] = IXGBE_GET_STAT(adapter, errbc);\r\nregs_buff[884] = IXGBE_GET_STAT(adapter, mspdc);\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[885 + i] = IXGBE_GET_STAT(adapter, mpc[i]);\r\nregs_buff[893] = IXGBE_GET_STAT(adapter, mlfc);\r\nregs_buff[894] = IXGBE_GET_STAT(adapter, mrfc);\r\nregs_buff[895] = IXGBE_GET_STAT(adapter, rlec);\r\nregs_buff[896] = IXGBE_GET_STAT(adapter, lxontxc);\r\nregs_buff[897] = IXGBE_GET_STAT(adapter, lxonrxc);\r\nregs_buff[898] = IXGBE_GET_STAT(adapter, lxofftxc);\r\nregs_buff[899] = IXGBE_GET_STAT(adapter, lxoffrxc);\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[900 + i] = IXGBE_GET_STAT(adapter, pxontxc[i]);\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[908 + i] = IXGBE_GET_STAT(adapter, pxonrxc[i]);\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[916 + i] = IXGBE_GET_STAT(adapter, pxofftxc[i]);\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[924 + i] = IXGBE_GET_STAT(adapter, pxoffrxc[i]);\r\nregs_buff[932] = IXGBE_GET_STAT(adapter, prc64);\r\nregs_buff[933] = IXGBE_GET_STAT(adapter, prc127);\r\nregs_buff[934] = IXGBE_GET_STAT(adapter, prc255);\r\nregs_buff[935] = IXGBE_GET_STAT(adapter, prc511);\r\nregs_buff[936] = IXGBE_GET_STAT(adapter, prc1023);\r\nregs_buff[937] = IXGBE_GET_STAT(adapter, prc1522);\r\nregs_buff[938] = IXGBE_GET_STAT(adapter, gprc);\r\nregs_buff[939] = IXGBE_GET_STAT(adapter, bprc);\r\nregs_buff[940] = IXGBE_GET_STAT(adapter, mprc);\r\nregs_buff[941] = IXGBE_GET_STAT(adapter, gptc);\r\nregs_buff[942] = IXGBE_GET_STAT(adapter, gorc);\r\nregs_buff[944] = IXGBE_GET_STAT(adapter, gotc);\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[946 + i] = IXGBE_GET_STAT(adapter, rnbc[i]);\r\nregs_buff[954] = IXGBE_GET_STAT(adapter, ruc);\r\nregs_buff[955] = IXGBE_GET_STAT(adapter, rfc);\r\nregs_buff[956] = IXGBE_GET_STAT(adapter, roc);\r\nregs_buff[957] = IXGBE_GET_STAT(adapter, rjc);\r\nregs_buff[958] = IXGBE_GET_STAT(adapter, mngprc);\r\nregs_buff[959] = IXGBE_GET_STAT(adapter, mngpdc);\r\nregs_buff[960] = IXGBE_GET_STAT(adapter, mngptc);\r\nregs_buff[961] = IXGBE_GET_STAT(adapter, tor);\r\nregs_buff[963] = IXGBE_GET_STAT(adapter, tpr);\r\nregs_buff[964] = IXGBE_GET_STAT(adapter, tpt);\r\nregs_buff[965] = IXGBE_GET_STAT(adapter, ptc64);\r\nregs_buff[966] = IXGBE_GET_STAT(adapter, ptc127);\r\nregs_buff[967] = IXGBE_GET_STAT(adapter, ptc255);\r\nregs_buff[968] = IXGBE_GET_STAT(adapter, ptc511);\r\nregs_buff[969] = IXGBE_GET_STAT(adapter, ptc1023);\r\nregs_buff[970] = IXGBE_GET_STAT(adapter, ptc1522);\r\nregs_buff[971] = IXGBE_GET_STAT(adapter, mptc);\r\nregs_buff[972] = IXGBE_GET_STAT(adapter, bptc);\r\nregs_buff[973] = IXGBE_GET_STAT(adapter, xec);\r\nfor (i = 0; i < 16; i++)\r\nregs_buff[974 + i] = IXGBE_GET_STAT(adapter, qprc[i]);\r\nfor (i = 0; i < 16; i++)\r\nregs_buff[990 + i] = IXGBE_GET_STAT(adapter, qptc[i]);\r\nfor (i = 0; i < 16; i++)\r\nregs_buff[1006 + i] = IXGBE_GET_STAT(adapter, qbrc[i]);\r\nfor (i = 0; i < 16; i++)\r\nregs_buff[1022 + i] = IXGBE_GET_STAT(adapter, qbtc[i]);\r\nregs_buff[1038] = IXGBE_READ_REG(hw, IXGBE_PCS1GCFIG);\r\nregs_buff[1039] = IXGBE_READ_REG(hw, IXGBE_PCS1GLCTL);\r\nregs_buff[1040] = IXGBE_READ_REG(hw, IXGBE_PCS1GLSTA);\r\nregs_buff[1041] = IXGBE_READ_REG(hw, IXGBE_PCS1GDBG0);\r\nregs_buff[1042] = IXGBE_READ_REG(hw, IXGBE_PCS1GDBG1);\r\nregs_buff[1043] = IXGBE_READ_REG(hw, IXGBE_PCS1GANA);\r\nregs_buff[1044] = IXGBE_READ_REG(hw, IXGBE_PCS1GANLP);\r\nregs_buff[1045] = IXGBE_READ_REG(hw, IXGBE_PCS1GANNP);\r\nregs_buff[1046] = IXGBE_READ_REG(hw, IXGBE_PCS1GANLPNP);\r\nregs_buff[1047] = IXGBE_READ_REG(hw, IXGBE_HLREG0);\r\nregs_buff[1048] = IXGBE_READ_REG(hw, IXGBE_HLREG1);\r\nregs_buff[1049] = IXGBE_READ_REG(hw, IXGBE_PAP);\r\nregs_buff[1050] = IXGBE_READ_REG(hw, IXGBE_MACA);\r\nregs_buff[1051] = IXGBE_READ_REG(hw, IXGBE_APAE);\r\nregs_buff[1052] = IXGBE_READ_REG(hw, IXGBE_ARD);\r\nregs_buff[1053] = IXGBE_READ_REG(hw, IXGBE_AIS);\r\nregs_buff[1054] = IXGBE_READ_REG(hw, IXGBE_MSCA);\r\nregs_buff[1055] = IXGBE_READ_REG(hw, IXGBE_MSRWD);\r\nregs_buff[1056] = IXGBE_READ_REG(hw, IXGBE_MLADD);\r\nregs_buff[1057] = IXGBE_READ_REG(hw, IXGBE_MHADD);\r\nregs_buff[1058] = IXGBE_READ_REG(hw, IXGBE_TREG);\r\nregs_buff[1059] = IXGBE_READ_REG(hw, IXGBE_PCSS1);\r\nregs_buff[1060] = IXGBE_READ_REG(hw, IXGBE_PCSS2);\r\nregs_buff[1061] = IXGBE_READ_REG(hw, IXGBE_XPCSS);\r\nregs_buff[1062] = IXGBE_READ_REG(hw, IXGBE_SERDESC);\r\nregs_buff[1063] = IXGBE_READ_REG(hw, IXGBE_MACS);\r\nregs_buff[1064] = IXGBE_READ_REG(hw, IXGBE_AUTOC);\r\nregs_buff[1065] = IXGBE_READ_REG(hw, IXGBE_LINKS);\r\nregs_buff[1066] = IXGBE_READ_REG(hw, IXGBE_AUTOC2);\r\nregs_buff[1067] = IXGBE_READ_REG(hw, IXGBE_AUTOC3);\r\nregs_buff[1068] = IXGBE_READ_REG(hw, IXGBE_ANLP1);\r\nregs_buff[1069] = IXGBE_READ_REG(hw, IXGBE_ANLP2);\r\nregs_buff[1070] = IXGBE_READ_REG(hw, IXGBE_ATLASCTL);\r\nregs_buff[1071] = IXGBE_READ_REG(hw, IXGBE_RDSTATCTL);\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[1072 + i] = IXGBE_READ_REG(hw, IXGBE_RDSTAT(i));\r\nregs_buff[1080] = IXGBE_READ_REG(hw, IXGBE_RDHMPN);\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[1081 + i] = IXGBE_READ_REG(hw, IXGBE_RIC_DW(i));\r\nregs_buff[1085] = IXGBE_READ_REG(hw, IXGBE_RDPROBE);\r\nregs_buff[1086] = IXGBE_READ_REG(hw, IXGBE_TDSTATCTL);\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[1087 + i] = IXGBE_READ_REG(hw, IXGBE_TDSTAT(i));\r\nregs_buff[1095] = IXGBE_READ_REG(hw, IXGBE_TDHMPN);\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[1096 + i] = IXGBE_READ_REG(hw, IXGBE_TIC_DW(i));\r\nregs_buff[1100] = IXGBE_READ_REG(hw, IXGBE_TDPROBE);\r\nregs_buff[1101] = IXGBE_READ_REG(hw, IXGBE_TXBUFCTRL);\r\nregs_buff[1102] = IXGBE_READ_REG(hw, IXGBE_TXBUFDATA0);\r\nregs_buff[1103] = IXGBE_READ_REG(hw, IXGBE_TXBUFDATA1);\r\nregs_buff[1104] = IXGBE_READ_REG(hw, IXGBE_TXBUFDATA2);\r\nregs_buff[1105] = IXGBE_READ_REG(hw, IXGBE_TXBUFDATA3);\r\nregs_buff[1106] = IXGBE_READ_REG(hw, IXGBE_RXBUFCTRL);\r\nregs_buff[1107] = IXGBE_READ_REG(hw, IXGBE_RXBUFDATA0);\r\nregs_buff[1108] = IXGBE_READ_REG(hw, IXGBE_RXBUFDATA1);\r\nregs_buff[1109] = IXGBE_READ_REG(hw, IXGBE_RXBUFDATA2);\r\nregs_buff[1110] = IXGBE_READ_REG(hw, IXGBE_RXBUFDATA3);\r\nfor (i = 0; i < 8; i++)\r\nregs_buff[1111 + i] = IXGBE_READ_REG(hw, IXGBE_PCIE_DIAG(i));\r\nregs_buff[1119] = IXGBE_READ_REG(hw, IXGBE_RFVAL);\r\nregs_buff[1120] = IXGBE_READ_REG(hw, IXGBE_MDFTC1);\r\nregs_buff[1121] = IXGBE_READ_REG(hw, IXGBE_MDFTC2);\r\nregs_buff[1122] = IXGBE_READ_REG(hw, IXGBE_MDFTFIFO1);\r\nregs_buff[1123] = IXGBE_READ_REG(hw, IXGBE_MDFTFIFO2);\r\nregs_buff[1124] = IXGBE_READ_REG(hw, IXGBE_MDFTS);\r\nregs_buff[1125] = IXGBE_READ_REG(hw, IXGBE_PCIEECCCTL);\r\nregs_buff[1126] = IXGBE_READ_REG(hw, IXGBE_PBTXECC);\r\nregs_buff[1127] = IXGBE_READ_REG(hw, IXGBE_PBRXECC);\r\nregs_buff[1128] = IXGBE_READ_REG(hw, IXGBE_MFLCN);\r\nregs_buff[1129] = IXGBE_READ_REG(hw, IXGBE_RTRUP2TC);\r\nregs_buff[1130] = IXGBE_READ_REG(hw, IXGBE_RTTUP2TC);\r\nfor (i = 0; i < 4; i++)\r\nregs_buff[1131 + i] = IXGBE_READ_REG(hw, IXGBE_TXLLQ(i));\r\nregs_buff[1135] = IXGBE_READ_REG(hw, IXGBE_RTTBCNRM);\r\nregs_buff[1136] = IXGBE_READ_REG(hw, IXGBE_RTTBCNRD);\r\nregs_buff[1137] = IXGBE_READ_REG(hw, IXGBE_RTTQCNCR);\r\nregs_buff[1138] = IXGBE_READ_REG(hw, IXGBE_RTTQCNTG);\r\n}\r\nstatic int ixgbe_get_eeprom_len(struct net_device *netdev)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nreturn adapter->hw.eeprom.word_size * 2;\r\n}\r\nstatic int ixgbe_get_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *eeprom, u8 *bytes)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu16 *eeprom_buff;\r\nint first_word, last_word, eeprom_len;\r\nint ret_val = 0;\r\nu16 i;\r\nif (eeprom->len == 0)\r\nreturn -EINVAL;\r\neeprom->magic = hw->vendor_id | (hw->device_id << 16);\r\nfirst_word = eeprom->offset >> 1;\r\nlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\r\neeprom_len = last_word - first_word + 1;\r\neeprom_buff = kmalloc(sizeof(u16) * eeprom_len, GFP_KERNEL);\r\nif (!eeprom_buff)\r\nreturn -ENOMEM;\r\nret_val = hw->eeprom.ops.read_buffer(hw, first_word, eeprom_len,\r\neeprom_buff);\r\nfor (i = 0; i < eeprom_len; i++)\r\nle16_to_cpus(&eeprom_buff[i]);\r\nmemcpy(bytes, (u8 *)eeprom_buff + (eeprom->offset & 1), eeprom->len);\r\nkfree(eeprom_buff);\r\nreturn ret_val;\r\n}\r\nstatic int ixgbe_set_eeprom(struct net_device *netdev,\r\nstruct ethtool_eeprom *eeprom, u8 *bytes)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu16 *eeprom_buff;\r\nvoid *ptr;\r\nint max_len, first_word, last_word, ret_val = 0;\r\nu16 i;\r\nif (eeprom->len == 0)\r\nreturn -EINVAL;\r\nif (eeprom->magic != (hw->vendor_id | (hw->device_id << 16)))\r\nreturn -EINVAL;\r\nmax_len = hw->eeprom.word_size * 2;\r\nfirst_word = eeprom->offset >> 1;\r\nlast_word = (eeprom->offset + eeprom->len - 1) >> 1;\r\neeprom_buff = kmalloc(max_len, GFP_KERNEL);\r\nif (!eeprom_buff)\r\nreturn -ENOMEM;\r\nptr = eeprom_buff;\r\nif (eeprom->offset & 1) {\r\nret_val = hw->eeprom.ops.read(hw, first_word, &eeprom_buff[0]);\r\nif (ret_val)\r\ngoto err;\r\nptr++;\r\n}\r\nif ((eeprom->offset + eeprom->len) & 1) {\r\nret_val = hw->eeprom.ops.read(hw, last_word,\r\n&eeprom_buff[last_word - first_word]);\r\nif (ret_val)\r\ngoto err;\r\n}\r\nfor (i = 0; i < last_word - first_word + 1; i++)\r\nle16_to_cpus(&eeprom_buff[i]);\r\nmemcpy(ptr, bytes, eeprom->len);\r\nfor (i = 0; i < last_word - first_word + 1; i++)\r\ncpu_to_le16s(&eeprom_buff[i]);\r\nret_val = hw->eeprom.ops.write_buffer(hw, first_word,\r\nlast_word - first_word + 1,\r\neeprom_buff);\r\nif (ret_val == 0)\r\nhw->eeprom.ops.update_checksum(hw);\r\nerr:\r\nkfree(eeprom_buff);\r\nreturn ret_val;\r\n}\r\nstatic void ixgbe_get_drvinfo(struct net_device *netdev,\r\nstruct ethtool_drvinfo *drvinfo)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nu32 nvm_track_id;\r\nstrlcpy(drvinfo->driver, ixgbe_driver_name, sizeof(drvinfo->driver));\r\nstrlcpy(drvinfo->version, ixgbe_driver_version,\r\nsizeof(drvinfo->version));\r\nnvm_track_id = (adapter->eeprom_verh << 16) |\r\nadapter->eeprom_verl;\r\nsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version), "0x%08x",\r\nnvm_track_id);\r\nstrlcpy(drvinfo->bus_info, pci_name(adapter->pdev),\r\nsizeof(drvinfo->bus_info));\r\ndrvinfo->n_stats = IXGBE_STATS_LEN;\r\ndrvinfo->testinfo_len = IXGBE_TEST_LEN;\r\ndrvinfo->regdump_len = ixgbe_get_regs_len(netdev);\r\n}\r\nstatic void ixgbe_get_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nstruct ixgbe_ring *tx_ring = adapter->tx_ring[0];\r\nstruct ixgbe_ring *rx_ring = adapter->rx_ring[0];\r\nring->rx_max_pending = IXGBE_MAX_RXD;\r\nring->tx_max_pending = IXGBE_MAX_TXD;\r\nring->rx_pending = rx_ring->count;\r\nring->tx_pending = tx_ring->count;\r\n}\r\nstatic int ixgbe_set_ringparam(struct net_device *netdev,\r\nstruct ethtool_ringparam *ring)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nstruct ixgbe_ring *temp_ring;\r\nint i, err = 0;\r\nu32 new_rx_count, new_tx_count;\r\nif ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))\r\nreturn -EINVAL;\r\nnew_tx_count = clamp_t(u32, ring->tx_pending,\r\nIXGBE_MIN_TXD, IXGBE_MAX_TXD);\r\nnew_tx_count = ALIGN(new_tx_count, IXGBE_REQ_TX_DESCRIPTOR_MULTIPLE);\r\nnew_rx_count = clamp_t(u32, ring->rx_pending,\r\nIXGBE_MIN_RXD, IXGBE_MAX_RXD);\r\nnew_rx_count = ALIGN(new_rx_count, IXGBE_REQ_RX_DESCRIPTOR_MULTIPLE);\r\nif ((new_tx_count == adapter->tx_ring_count) &&\r\n(new_rx_count == adapter->rx_ring_count)) {\r\nreturn 0;\r\n}\r\nwhile (test_and_set_bit(__IXGBE_RESETTING, &adapter->state))\r\nusleep_range(1000, 2000);\r\nif (!netif_running(adapter->netdev)) {\r\nfor (i = 0; i < adapter->num_tx_queues; i++)\r\nadapter->tx_ring[i]->count = new_tx_count;\r\nfor (i = 0; i < adapter->num_rx_queues; i++)\r\nadapter->rx_ring[i]->count = new_rx_count;\r\nadapter->tx_ring_count = new_tx_count;\r\nadapter->rx_ring_count = new_rx_count;\r\ngoto clear_reset;\r\n}\r\ni = max_t(int, adapter->num_tx_queues, adapter->num_rx_queues);\r\ntemp_ring = vmalloc(i * sizeof(struct ixgbe_ring));\r\nif (!temp_ring) {\r\nerr = -ENOMEM;\r\ngoto clear_reset;\r\n}\r\nixgbe_down(adapter);\r\nif (new_tx_count != adapter->tx_ring_count) {\r\nfor (i = 0; i < adapter->num_tx_queues; i++) {\r\nmemcpy(&temp_ring[i], adapter->tx_ring[i],\r\nsizeof(struct ixgbe_ring));\r\ntemp_ring[i].count = new_tx_count;\r\nerr = ixgbe_setup_tx_resources(&temp_ring[i]);\r\nif (err) {\r\nwhile (i) {\r\ni--;\r\nixgbe_free_tx_resources(&temp_ring[i]);\r\n}\r\ngoto err_setup;\r\n}\r\n}\r\nfor (i = 0; i < adapter->num_tx_queues; i++) {\r\nixgbe_free_tx_resources(adapter->tx_ring[i]);\r\nmemcpy(adapter->tx_ring[i], &temp_ring[i],\r\nsizeof(struct ixgbe_ring));\r\n}\r\nadapter->tx_ring_count = new_tx_count;\r\n}\r\nif (new_rx_count != adapter->rx_ring_count) {\r\nfor (i = 0; i < adapter->num_rx_queues; i++) {\r\nmemcpy(&temp_ring[i], adapter->rx_ring[i],\r\nsizeof(struct ixgbe_ring));\r\ntemp_ring[i].count = new_rx_count;\r\nerr = ixgbe_setup_rx_resources(&temp_ring[i]);\r\nif (err) {\r\nwhile (i) {\r\ni--;\r\nixgbe_free_rx_resources(&temp_ring[i]);\r\n}\r\ngoto err_setup;\r\n}\r\n}\r\nfor (i = 0; i < adapter->num_rx_queues; i++) {\r\nixgbe_free_rx_resources(adapter->rx_ring[i]);\r\nmemcpy(adapter->rx_ring[i], &temp_ring[i],\r\nsizeof(struct ixgbe_ring));\r\n}\r\nadapter->rx_ring_count = new_rx_count;\r\n}\r\nerr_setup:\r\nixgbe_up(adapter);\r\nvfree(temp_ring);\r\nclear_reset:\r\nclear_bit(__IXGBE_RESETTING, &adapter->state);\r\nreturn err;\r\n}\r\nstatic int ixgbe_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_TEST:\r\nreturn IXGBE_TEST_LEN;\r\ncase ETH_SS_STATS:\r\nreturn IXGBE_STATS_LEN;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void ixgbe_get_ethtool_stats(struct net_device *netdev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nstruct rtnl_link_stats64 temp;\r\nconst struct rtnl_link_stats64 *net_stats;\r\nunsigned int start;\r\nstruct ixgbe_ring *ring;\r\nint i, j;\r\nchar *p = NULL;\r\nixgbe_update_stats(adapter);\r\nnet_stats = dev_get_stats(netdev, &temp);\r\nfor (i = 0; i < IXGBE_GLOBAL_STATS_LEN; i++) {\r\nswitch (ixgbe_gstrings_stats[i].type) {\r\ncase NETDEV_STATS:\r\np = (char *) net_stats +\r\nixgbe_gstrings_stats[i].stat_offset;\r\nbreak;\r\ncase IXGBE_STATS:\r\np = (char *) adapter +\r\nixgbe_gstrings_stats[i].stat_offset;\r\nbreak;\r\ndefault:\r\ndata[i] = 0;\r\ncontinue;\r\n}\r\ndata[i] = (ixgbe_gstrings_stats[i].sizeof_stat ==\r\nsizeof(u64)) ? *(u64 *)p : *(u32 *)p;\r\n}\r\nfor (j = 0; j < netdev->num_tx_queues; j++) {\r\nring = adapter->tx_ring[j];\r\nif (!ring) {\r\ndata[i] = 0;\r\ndata[i+1] = 0;\r\ni += 2;\r\n#ifdef BP_EXTENDED_STATS\r\ndata[i] = 0;\r\ndata[i+1] = 0;\r\ndata[i+2] = 0;\r\ni += 3;\r\n#endif\r\ncontinue;\r\n}\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&ring->syncp);\r\ndata[i] = ring->stats.packets;\r\ndata[i+1] = ring->stats.bytes;\r\n} while (u64_stats_fetch_retry_irq(&ring->syncp, start));\r\ni += 2;\r\n#ifdef BP_EXTENDED_STATS\r\ndata[i] = ring->stats.yields;\r\ndata[i+1] = ring->stats.misses;\r\ndata[i+2] = ring->stats.cleaned;\r\ni += 3;\r\n#endif\r\n}\r\nfor (j = 0; j < IXGBE_NUM_RX_QUEUES; j++) {\r\nring = adapter->rx_ring[j];\r\nif (!ring) {\r\ndata[i] = 0;\r\ndata[i+1] = 0;\r\ni += 2;\r\n#ifdef BP_EXTENDED_STATS\r\ndata[i] = 0;\r\ndata[i+1] = 0;\r\ndata[i+2] = 0;\r\ni += 3;\r\n#endif\r\ncontinue;\r\n}\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&ring->syncp);\r\ndata[i] = ring->stats.packets;\r\ndata[i+1] = ring->stats.bytes;\r\n} while (u64_stats_fetch_retry_irq(&ring->syncp, start));\r\ni += 2;\r\n#ifdef BP_EXTENDED_STATS\r\ndata[i] = ring->stats.yields;\r\ndata[i+1] = ring->stats.misses;\r\ndata[i+2] = ring->stats.cleaned;\r\ni += 3;\r\n#endif\r\n}\r\nfor (j = 0; j < IXGBE_MAX_PACKET_BUFFERS; j++) {\r\ndata[i++] = adapter->stats.pxontxc[j];\r\ndata[i++] = adapter->stats.pxofftxc[j];\r\n}\r\nfor (j = 0; j < IXGBE_MAX_PACKET_BUFFERS; j++) {\r\ndata[i++] = adapter->stats.pxonrxc[j];\r\ndata[i++] = adapter->stats.pxoffrxc[j];\r\n}\r\n}\r\nstatic void ixgbe_get_strings(struct net_device *netdev, u32 stringset,\r\nu8 *data)\r\n{\r\nchar *p = (char *)data;\r\nint i;\r\nswitch (stringset) {\r\ncase ETH_SS_TEST:\r\nfor (i = 0; i < IXGBE_TEST_LEN; i++) {\r\nmemcpy(data, ixgbe_gstrings_test[i], ETH_GSTRING_LEN);\r\ndata += ETH_GSTRING_LEN;\r\n}\r\nbreak;\r\ncase ETH_SS_STATS:\r\nfor (i = 0; i < IXGBE_GLOBAL_STATS_LEN; i++) {\r\nmemcpy(p, ixgbe_gstrings_stats[i].stat_string,\r\nETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\n}\r\nfor (i = 0; i < netdev->num_tx_queues; i++) {\r\nsprintf(p, "tx_queue_%u_packets", i);\r\np += ETH_GSTRING_LEN;\r\nsprintf(p, "tx_queue_%u_bytes", i);\r\np += ETH_GSTRING_LEN;\r\n#ifdef BP_EXTENDED_STATS\r\nsprintf(p, "tx_queue_%u_bp_napi_yield", i);\r\np += ETH_GSTRING_LEN;\r\nsprintf(p, "tx_queue_%u_bp_misses", i);\r\np += ETH_GSTRING_LEN;\r\nsprintf(p, "tx_queue_%u_bp_cleaned", i);\r\np += ETH_GSTRING_LEN;\r\n#endif\r\n}\r\nfor (i = 0; i < IXGBE_NUM_RX_QUEUES; i++) {\r\nsprintf(p, "rx_queue_%u_packets", i);\r\np += ETH_GSTRING_LEN;\r\nsprintf(p, "rx_queue_%u_bytes", i);\r\np += ETH_GSTRING_LEN;\r\n#ifdef BP_EXTENDED_STATS\r\nsprintf(p, "rx_queue_%u_bp_poll_yield", i);\r\np += ETH_GSTRING_LEN;\r\nsprintf(p, "rx_queue_%u_bp_misses", i);\r\np += ETH_GSTRING_LEN;\r\nsprintf(p, "rx_queue_%u_bp_cleaned", i);\r\np += ETH_GSTRING_LEN;\r\n#endif\r\n}\r\nfor (i = 0; i < IXGBE_MAX_PACKET_BUFFERS; i++) {\r\nsprintf(p, "tx_pb_%u_pxon", i);\r\np += ETH_GSTRING_LEN;\r\nsprintf(p, "tx_pb_%u_pxoff", i);\r\np += ETH_GSTRING_LEN;\r\n}\r\nfor (i = 0; i < IXGBE_MAX_PACKET_BUFFERS; i++) {\r\nsprintf(p, "rx_pb_%u_pxon", i);\r\np += ETH_GSTRING_LEN;\r\nsprintf(p, "rx_pb_%u_pxoff", i);\r\np += ETH_GSTRING_LEN;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int ixgbe_link_test(struct ixgbe_adapter *adapter, u64 *data)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nbool link_up;\r\nu32 link_speed = 0;\r\nif (ixgbe_removed(hw->hw_addr)) {\r\n*data = 1;\r\nreturn 1;\r\n}\r\n*data = 0;\r\nhw->mac.ops.check_link(hw, &link_speed, &link_up, true);\r\nif (link_up)\r\nreturn *data;\r\nelse\r\n*data = 1;\r\nreturn *data;\r\n}\r\nstatic bool reg_pattern_test(struct ixgbe_adapter *adapter, u64 *data, int reg,\r\nu32 mask, u32 write)\r\n{\r\nu32 pat, val, before;\r\nstatic const u32 test_pattern[] = {\r\n0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF};\r\nif (ixgbe_removed(adapter->hw.hw_addr)) {\r\n*data = 1;\r\nreturn 1;\r\n}\r\nfor (pat = 0; pat < ARRAY_SIZE(test_pattern); pat++) {\r\nbefore = ixgbe_read_reg(&adapter->hw, reg);\r\nixgbe_write_reg(&adapter->hw, reg, test_pattern[pat] & write);\r\nval = ixgbe_read_reg(&adapter->hw, reg);\r\nif (val != (test_pattern[pat] & write & mask)) {\r\ne_err(drv, "pattern test reg %04X failed: got 0x%08X expected 0x%08X\n",\r\nreg, val, (test_pattern[pat] & write & mask));\r\n*data = reg;\r\nixgbe_write_reg(&adapter->hw, reg, before);\r\nreturn true;\r\n}\r\nixgbe_write_reg(&adapter->hw, reg, before);\r\n}\r\nreturn false;\r\n}\r\nstatic bool reg_set_and_check(struct ixgbe_adapter *adapter, u64 *data, int reg,\r\nu32 mask, u32 write)\r\n{\r\nu32 val, before;\r\nif (ixgbe_removed(adapter->hw.hw_addr)) {\r\n*data = 1;\r\nreturn 1;\r\n}\r\nbefore = ixgbe_read_reg(&adapter->hw, reg);\r\nixgbe_write_reg(&adapter->hw, reg, write & mask);\r\nval = ixgbe_read_reg(&adapter->hw, reg);\r\nif ((write & mask) != (val & mask)) {\r\ne_err(drv, "set/check reg %04X test failed: got 0x%08X expected 0x%08X\n",\r\nreg, (val & mask), (write & mask));\r\n*data = reg;\r\nixgbe_write_reg(&adapter->hw, reg, before);\r\nreturn true;\r\n}\r\nixgbe_write_reg(&adapter->hw, reg, before);\r\nreturn false;\r\n}\r\nstatic int ixgbe_reg_test(struct ixgbe_adapter *adapter, u64 *data)\r\n{\r\nconst struct ixgbe_reg_test *test;\r\nu32 value, before, after;\r\nu32 i, toggle;\r\nif (ixgbe_removed(adapter->hw.hw_addr)) {\r\ne_err(drv, "Adapter removed - register test blocked\n");\r\n*data = 1;\r\nreturn 1;\r\n}\r\nswitch (adapter->hw.mac.type) {\r\ncase ixgbe_mac_82598EB:\r\ntoggle = 0x7FFFF3FF;\r\ntest = reg_test_82598;\r\nbreak;\r\ncase ixgbe_mac_82599EB:\r\ncase ixgbe_mac_X540:\r\ncase ixgbe_mac_X550:\r\ncase ixgbe_mac_X550EM_x:\r\ntoggle = 0x7FFFF30F;\r\ntest = reg_test_82599;\r\nbreak;\r\ndefault:\r\n*data = 1;\r\nreturn 1;\r\n}\r\nbefore = ixgbe_read_reg(&adapter->hw, IXGBE_STATUS);\r\nvalue = (ixgbe_read_reg(&adapter->hw, IXGBE_STATUS) & toggle);\r\nixgbe_write_reg(&adapter->hw, IXGBE_STATUS, toggle);\r\nafter = ixgbe_read_reg(&adapter->hw, IXGBE_STATUS) & toggle;\r\nif (value != after) {\r\ne_err(drv, "failed STATUS register test got: 0x%08X expected: 0x%08X\n",\r\nafter, value);\r\n*data = 1;\r\nreturn 1;\r\n}\r\nixgbe_write_reg(&adapter->hw, IXGBE_STATUS, before);\r\nwhile (test->reg) {\r\nfor (i = 0; i < test->array_len; i++) {\r\nbool b = false;\r\nswitch (test->test_type) {\r\ncase PATTERN_TEST:\r\nb = reg_pattern_test(adapter, data,\r\ntest->reg + (i * 0x40),\r\ntest->mask,\r\ntest->write);\r\nbreak;\r\ncase SET_READ_TEST:\r\nb = reg_set_and_check(adapter, data,\r\ntest->reg + (i * 0x40),\r\ntest->mask,\r\ntest->write);\r\nbreak;\r\ncase WRITE_NO_TEST:\r\nixgbe_write_reg(&adapter->hw,\r\ntest->reg + (i * 0x40),\r\ntest->write);\r\nbreak;\r\ncase TABLE32_TEST:\r\nb = reg_pattern_test(adapter, data,\r\ntest->reg + (i * 4),\r\ntest->mask,\r\ntest->write);\r\nbreak;\r\ncase TABLE64_TEST_LO:\r\nb = reg_pattern_test(adapter, data,\r\ntest->reg + (i * 8),\r\ntest->mask,\r\ntest->write);\r\nbreak;\r\ncase TABLE64_TEST_HI:\r\nb = reg_pattern_test(adapter, data,\r\n(test->reg + 4) + (i * 8),\r\ntest->mask,\r\ntest->write);\r\nbreak;\r\n}\r\nif (b)\r\nreturn 1;\r\n}\r\ntest++;\r\n}\r\n*data = 0;\r\nreturn 0;\r\n}\r\nstatic int ixgbe_eeprom_test(struct ixgbe_adapter *adapter, u64 *data)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nif (hw->eeprom.ops.validate_checksum(hw, NULL))\r\n*data = 1;\r\nelse\r\n*data = 0;\r\nreturn *data;\r\n}\r\nstatic irqreturn_t ixgbe_test_intr(int irq, void *data)\r\n{\r\nstruct net_device *netdev = (struct net_device *) data;\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nadapter->test_icr |= IXGBE_READ_REG(&adapter->hw, IXGBE_EICR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ixgbe_intr_test(struct ixgbe_adapter *adapter, u64 *data)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nu32 mask, i = 0, shared_int = true;\r\nu32 irq = adapter->pdev->irq;\r\n*data = 0;\r\nif (adapter->msix_entries) {\r\nreturn 0;\r\n} else if (adapter->flags & IXGBE_FLAG_MSI_ENABLED) {\r\nshared_int = false;\r\nif (request_irq(irq, ixgbe_test_intr, 0, netdev->name,\r\nnetdev)) {\r\n*data = 1;\r\nreturn -1;\r\n}\r\n} else if (!request_irq(irq, ixgbe_test_intr, IRQF_PROBE_SHARED,\r\nnetdev->name, netdev)) {\r\nshared_int = false;\r\n} else if (request_irq(irq, ixgbe_test_intr, IRQF_SHARED,\r\nnetdev->name, netdev)) {\r\n*data = 1;\r\nreturn -1;\r\n}\r\ne_info(hw, "testing %s interrupt\n", shared_int ?\r\n"shared" : "unshared");\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_EIMC, 0xFFFFFFFF);\r\nIXGBE_WRITE_FLUSH(&adapter->hw);\r\nusleep_range(10000, 20000);\r\nfor (; i < 10; i++) {\r\nmask = 1 << i;\r\nif (!shared_int) {\r\nadapter->test_icr = 0;\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_EIMC,\r\n~mask & 0x00007FFF);\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_EICS,\r\n~mask & 0x00007FFF);\r\nIXGBE_WRITE_FLUSH(&adapter->hw);\r\nusleep_range(10000, 20000);\r\nif (adapter->test_icr & mask) {\r\n*data = 3;\r\nbreak;\r\n}\r\n}\r\nadapter->test_icr = 0;\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_EIMS, mask);\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_EICS, mask);\r\nIXGBE_WRITE_FLUSH(&adapter->hw);\r\nusleep_range(10000, 20000);\r\nif (!(adapter->test_icr & mask)) {\r\n*data = 4;\r\nbreak;\r\n}\r\nif (!shared_int) {\r\nadapter->test_icr = 0;\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_EIMC,\r\n~mask & 0x00007FFF);\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_EICS,\r\n~mask & 0x00007FFF);\r\nIXGBE_WRITE_FLUSH(&adapter->hw);\r\nusleep_range(10000, 20000);\r\nif (adapter->test_icr) {\r\n*data = 5;\r\nbreak;\r\n}\r\n}\r\n}\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_EIMC, 0xFFFFFFFF);\r\nIXGBE_WRITE_FLUSH(&adapter->hw);\r\nusleep_range(10000, 20000);\r\nfree_irq(irq, netdev);\r\nreturn *data;\r\n}\r\nstatic void ixgbe_free_desc_rings(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_ring *tx_ring = &adapter->test_tx_ring;\r\nstruct ixgbe_ring *rx_ring = &adapter->test_rx_ring;\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 reg_ctl;\r\nreg_ctl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);\r\nreg_ctl &= ~IXGBE_RXCTRL_RXEN;\r\nIXGBE_WRITE_REG(hw, IXGBE_RXCTRL, reg_ctl);\r\nixgbe_disable_rx_queue(adapter, rx_ring);\r\nreg_ctl = IXGBE_READ_REG(hw, IXGBE_TXDCTL(tx_ring->reg_idx));\r\nreg_ctl &= ~IXGBE_TXDCTL_ENABLE;\r\nIXGBE_WRITE_REG(hw, IXGBE_TXDCTL(tx_ring->reg_idx), reg_ctl);\r\nswitch (hw->mac.type) {\r\ncase ixgbe_mac_82599EB:\r\ncase ixgbe_mac_X540:\r\ncase ixgbe_mac_X550:\r\ncase ixgbe_mac_X550EM_x:\r\nreg_ctl = IXGBE_READ_REG(hw, IXGBE_DMATXCTL);\r\nreg_ctl &= ~IXGBE_DMATXCTL_TE;\r\nIXGBE_WRITE_REG(hw, IXGBE_DMATXCTL, reg_ctl);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nixgbe_reset(adapter);\r\nixgbe_free_tx_resources(&adapter->test_tx_ring);\r\nixgbe_free_rx_resources(&adapter->test_rx_ring);\r\n}\r\nstatic int ixgbe_setup_desc_rings(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_ring *tx_ring = &adapter->test_tx_ring;\r\nstruct ixgbe_ring *rx_ring = &adapter->test_rx_ring;\r\nu32 rctl, reg_data;\r\nint ret_val;\r\nint err;\r\ntx_ring->count = IXGBE_DEFAULT_TXD;\r\ntx_ring->queue_index = 0;\r\ntx_ring->dev = &adapter->pdev->dev;\r\ntx_ring->netdev = adapter->netdev;\r\ntx_ring->reg_idx = adapter->tx_ring[0]->reg_idx;\r\nerr = ixgbe_setup_tx_resources(tx_ring);\r\nif (err)\r\nreturn 1;\r\nswitch (adapter->hw.mac.type) {\r\ncase ixgbe_mac_82599EB:\r\ncase ixgbe_mac_X540:\r\ncase ixgbe_mac_X550:\r\ncase ixgbe_mac_X550EM_x:\r\nreg_data = IXGBE_READ_REG(&adapter->hw, IXGBE_DMATXCTL);\r\nreg_data |= IXGBE_DMATXCTL_TE;\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_DMATXCTL, reg_data);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nixgbe_configure_tx_ring(adapter, tx_ring);\r\nrx_ring->count = IXGBE_DEFAULT_RXD;\r\nrx_ring->queue_index = 0;\r\nrx_ring->dev = &adapter->pdev->dev;\r\nrx_ring->netdev = adapter->netdev;\r\nrx_ring->reg_idx = adapter->rx_ring[0]->reg_idx;\r\nerr = ixgbe_setup_rx_resources(rx_ring);\r\nif (err) {\r\nret_val = 4;\r\ngoto err_nomem;\r\n}\r\nrctl = IXGBE_READ_REG(&adapter->hw, IXGBE_RXCTRL);\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_RXCTRL, rctl & ~IXGBE_RXCTRL_RXEN);\r\nixgbe_configure_rx_ring(adapter, rx_ring);\r\nrctl |= IXGBE_RXCTRL_RXEN | IXGBE_RXCTRL_DMBYPS;\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_RXCTRL, rctl);\r\nreturn 0;\r\nerr_nomem:\r\nixgbe_free_desc_rings(adapter);\r\nreturn ret_val;\r\n}\r\nstatic int ixgbe_setup_loopback_test(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 reg_data;\r\nreg_data = IXGBE_READ_REG(hw, IXGBE_HLREG0);\r\nreg_data |= IXGBE_HLREG0_LPBK;\r\nIXGBE_WRITE_REG(hw, IXGBE_HLREG0, reg_data);\r\nreg_data = IXGBE_READ_REG(hw, IXGBE_FCTRL);\r\nreg_data |= IXGBE_FCTRL_BAM | IXGBE_FCTRL_SBP | IXGBE_FCTRL_MPE;\r\nIXGBE_WRITE_REG(hw, IXGBE_FCTRL, reg_data);\r\nswitch (adapter->hw.mac.type) {\r\ncase ixgbe_mac_X540:\r\ncase ixgbe_mac_X550:\r\ncase ixgbe_mac_X550EM_x:\r\nreg_data = IXGBE_READ_REG(hw, IXGBE_MACC);\r\nreg_data |= IXGBE_MACC_FLU;\r\nIXGBE_WRITE_REG(hw, IXGBE_MACC, reg_data);\r\nbreak;\r\ndefault:\r\nif (hw->mac.orig_autoc) {\r\nreg_data = hw->mac.orig_autoc | IXGBE_AUTOC_FLU;\r\nIXGBE_WRITE_REG(hw, IXGBE_AUTOC, reg_data);\r\n} else {\r\nreturn 10;\r\n}\r\n}\r\nIXGBE_WRITE_FLUSH(hw);\r\nusleep_range(10000, 20000);\r\nif (hw->mac.type == ixgbe_mac_82598EB) {\r\nu8 atlas;\r\nhw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK, &atlas);\r\natlas |= IXGBE_ATLAS_PDN_TX_REG_EN;\r\nhw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK, atlas);\r\nhw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_10G, &atlas);\r\natlas |= IXGBE_ATLAS_PDN_TX_10G_QL_ALL;\r\nhw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_10G, atlas);\r\nhw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_1G, &atlas);\r\natlas |= IXGBE_ATLAS_PDN_TX_1G_QL_ALL;\r\nhw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_1G, atlas);\r\nhw->mac.ops.read_analog_reg8(hw, IXGBE_ATLAS_PDN_AN, &atlas);\r\natlas |= IXGBE_ATLAS_PDN_TX_AN_QL_ALL;\r\nhw->mac.ops.write_analog_reg8(hw, IXGBE_ATLAS_PDN_AN, atlas);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ixgbe_loopback_cleanup(struct ixgbe_adapter *adapter)\r\n{\r\nu32 reg_data;\r\nreg_data = IXGBE_READ_REG(&adapter->hw, IXGBE_HLREG0);\r\nreg_data &= ~IXGBE_HLREG0_LPBK;\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_HLREG0, reg_data);\r\n}\r\nstatic void ixgbe_create_lbtest_frame(struct sk_buff *skb,\r\nunsigned int frame_size)\r\n{\r\nmemset(skb->data, 0xFF, frame_size);\r\nframe_size >>= 1;\r\nmemset(&skb->data[frame_size], 0xAA, frame_size / 2 - 1);\r\nmemset(&skb->data[frame_size + 10], 0xBE, 1);\r\nmemset(&skb->data[frame_size + 12], 0xAF, 1);\r\n}\r\nstatic bool ixgbe_check_lbtest_frame(struct ixgbe_rx_buffer *rx_buffer,\r\nunsigned int frame_size)\r\n{\r\nunsigned char *data;\r\nbool match = true;\r\nframe_size >>= 1;\r\ndata = kmap(rx_buffer->page) + rx_buffer->page_offset;\r\nif (data[3] != 0xFF ||\r\ndata[frame_size + 10] != 0xBE ||\r\ndata[frame_size + 12] != 0xAF)\r\nmatch = false;\r\nkunmap(rx_buffer->page);\r\nreturn match;\r\n}\r\nstatic u16 ixgbe_clean_test_rings(struct ixgbe_ring *rx_ring,\r\nstruct ixgbe_ring *tx_ring,\r\nunsigned int size)\r\n{\r\nunion ixgbe_adv_rx_desc *rx_desc;\r\nstruct ixgbe_rx_buffer *rx_buffer;\r\nstruct ixgbe_tx_buffer *tx_buffer;\r\nu16 rx_ntc, tx_ntc, count = 0;\r\nrx_ntc = rx_ring->next_to_clean;\r\ntx_ntc = tx_ring->next_to_clean;\r\nrx_desc = IXGBE_RX_DESC(rx_ring, rx_ntc);\r\nwhile (ixgbe_test_staterr(rx_desc, IXGBE_RXD_STAT_DD)) {\r\nrx_buffer = &rx_ring->rx_buffer_info[rx_ntc];\r\ndma_sync_single_for_cpu(rx_ring->dev,\r\nrx_buffer->dma,\r\nixgbe_rx_bufsz(rx_ring),\r\nDMA_FROM_DEVICE);\r\nif (ixgbe_check_lbtest_frame(rx_buffer, size))\r\ncount++;\r\ndma_sync_single_for_device(rx_ring->dev,\r\nrx_buffer->dma,\r\nixgbe_rx_bufsz(rx_ring),\r\nDMA_FROM_DEVICE);\r\ntx_buffer = &tx_ring->tx_buffer_info[tx_ntc];\r\nixgbe_unmap_and_free_tx_resource(tx_ring, tx_buffer);\r\nrx_ntc++;\r\nif (rx_ntc == rx_ring->count)\r\nrx_ntc = 0;\r\ntx_ntc++;\r\nif (tx_ntc == tx_ring->count)\r\ntx_ntc = 0;\r\nrx_desc = IXGBE_RX_DESC(rx_ring, rx_ntc);\r\n}\r\nnetdev_tx_reset_queue(txring_txq(tx_ring));\r\nixgbe_alloc_rx_buffers(rx_ring, count);\r\nrx_ring->next_to_clean = rx_ntc;\r\ntx_ring->next_to_clean = tx_ntc;\r\nreturn count;\r\n}\r\nstatic int ixgbe_run_loopback_test(struct ixgbe_adapter *adapter)\r\n{\r\nstruct ixgbe_ring *tx_ring = &adapter->test_tx_ring;\r\nstruct ixgbe_ring *rx_ring = &adapter->test_rx_ring;\r\nint i, j, lc, good_cnt, ret_val = 0;\r\nunsigned int size = 1024;\r\nnetdev_tx_t tx_ret_val;\r\nstruct sk_buff *skb;\r\nu32 flags_orig = adapter->flags;\r\nadapter->flags &= ~IXGBE_FLAG_DCB_ENABLED;\r\nskb = alloc_skb(size, GFP_KERNEL);\r\nif (!skb)\r\nreturn 11;\r\nixgbe_create_lbtest_frame(skb, size);\r\nskb_put(skb, size);\r\nif (rx_ring->count <= tx_ring->count)\r\nlc = ((tx_ring->count / 64) * 2) + 1;\r\nelse\r\nlc = ((rx_ring->count / 64) * 2) + 1;\r\nfor (j = 0; j <= lc; j++) {\r\ngood_cnt = 0;\r\nfor (i = 0; i < 64; i++) {\r\nskb_get(skb);\r\ntx_ret_val = ixgbe_xmit_frame_ring(skb,\r\nadapter,\r\ntx_ring);\r\nif (tx_ret_val == NETDEV_TX_OK)\r\ngood_cnt++;\r\n}\r\nif (good_cnt != 64) {\r\nret_val = 12;\r\nbreak;\r\n}\r\nmsleep(200);\r\ngood_cnt = ixgbe_clean_test_rings(rx_ring, tx_ring, size);\r\nif (good_cnt != 64) {\r\nret_val = 13;\r\nbreak;\r\n}\r\n}\r\nkfree_skb(skb);\r\nadapter->flags = flags_orig;\r\nreturn ret_val;\r\n}\r\nstatic int ixgbe_loopback_test(struct ixgbe_adapter *adapter, u64 *data)\r\n{\r\n*data = ixgbe_setup_desc_rings(adapter);\r\nif (*data)\r\ngoto out;\r\n*data = ixgbe_setup_loopback_test(adapter);\r\nif (*data)\r\ngoto err_loopback;\r\n*data = ixgbe_run_loopback_test(adapter);\r\nixgbe_loopback_cleanup(adapter);\r\nerr_loopback:\r\nixgbe_free_desc_rings(adapter);\r\nout:\r\nreturn *data;\r\n}\r\nstatic void ixgbe_diag_test(struct net_device *netdev,\r\nstruct ethtool_test *eth_test, u64 *data)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nbool if_running = netif_running(netdev);\r\nif (ixgbe_removed(adapter->hw.hw_addr)) {\r\ne_err(hw, "Adapter removed - test blocked\n");\r\ndata[0] = 1;\r\ndata[1] = 1;\r\ndata[2] = 1;\r\ndata[3] = 1;\r\ndata[4] = 1;\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nreturn;\r\n}\r\nset_bit(__IXGBE_TESTING, &adapter->state);\r\nif (eth_test->flags == ETH_TEST_FL_OFFLINE) {\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nif (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED) {\r\nint i;\r\nfor (i = 0; i < adapter->num_vfs; i++) {\r\nif (adapter->vfinfo[i].clear_to_send) {\r\nnetdev_warn(netdev, "offline diagnostic is not supported when VFs are present\n");\r\ndata[0] = 1;\r\ndata[1] = 1;\r\ndata[2] = 1;\r\ndata[3] = 1;\r\ndata[4] = 1;\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nclear_bit(__IXGBE_TESTING,\r\n&adapter->state);\r\ngoto skip_ol_tests;\r\n}\r\n}\r\n}\r\ne_info(hw, "offline testing starting\n");\r\nif (ixgbe_link_test(adapter, &data[4]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nif (if_running)\r\ndev_close(netdev);\r\nelse\r\nixgbe_reset(adapter);\r\ne_info(hw, "register testing starting\n");\r\nif (ixgbe_reg_test(adapter, &data[0]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nixgbe_reset(adapter);\r\ne_info(hw, "eeprom testing starting\n");\r\nif (ixgbe_eeprom_test(adapter, &data[1]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nixgbe_reset(adapter);\r\ne_info(hw, "interrupt testing starting\n");\r\nif (ixgbe_intr_test(adapter, &data[2]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nif (adapter->flags & (IXGBE_FLAG_SRIOV_ENABLED |\r\nIXGBE_FLAG_VMDQ_ENABLED)) {\r\ne_info(hw, "Skip MAC loopback diagnostic in VT mode\n");\r\ndata[3] = 0;\r\ngoto skip_loopback;\r\n}\r\nixgbe_reset(adapter);\r\ne_info(hw, "loopback testing starting\n");\r\nif (ixgbe_loopback_test(adapter, &data[3]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\nskip_loopback:\r\nixgbe_reset(adapter);\r\nclear_bit(__IXGBE_TESTING, &adapter->state);\r\nif (if_running)\r\ndev_open(netdev);\r\nelse if (hw->mac.ops.disable_tx_laser)\r\nhw->mac.ops.disable_tx_laser(hw);\r\n} else {\r\ne_info(hw, "online testing starting\n");\r\nif (ixgbe_link_test(adapter, &data[4]))\r\neth_test->flags |= ETH_TEST_FL_FAILED;\r\ndata[0] = 0;\r\ndata[1] = 0;\r\ndata[2] = 0;\r\ndata[3] = 0;\r\nclear_bit(__IXGBE_TESTING, &adapter->state);\r\n}\r\nskip_ol_tests:\r\nmsleep_interruptible(4 * 1000);\r\n}\r\nstatic int ixgbe_wol_exclusion(struct ixgbe_adapter *adapter,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nint retval = 0;\r\nif (!ixgbe_wol_supported(adapter, hw->device_id,\r\nhw->subsystem_device_id)) {\r\nretval = 1;\r\nwol->supported = 0;\r\n}\r\nreturn retval;\r\n}\r\nstatic void ixgbe_get_wol(struct net_device *netdev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nwol->supported = WAKE_UCAST | WAKE_MCAST |\r\nWAKE_BCAST | WAKE_MAGIC;\r\nwol->wolopts = 0;\r\nif (ixgbe_wol_exclusion(adapter, wol) ||\r\n!device_can_wakeup(&adapter->pdev->dev))\r\nreturn;\r\nif (adapter->wol & IXGBE_WUFC_EX)\r\nwol->wolopts |= WAKE_UCAST;\r\nif (adapter->wol & IXGBE_WUFC_MC)\r\nwol->wolopts |= WAKE_MCAST;\r\nif (adapter->wol & IXGBE_WUFC_BC)\r\nwol->wolopts |= WAKE_BCAST;\r\nif (adapter->wol & IXGBE_WUFC_MAG)\r\nwol->wolopts |= WAKE_MAGIC;\r\n}\r\nstatic int ixgbe_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nif (wol->wolopts & (WAKE_PHY | WAKE_ARP | WAKE_MAGICSECURE))\r\nreturn -EOPNOTSUPP;\r\nif (ixgbe_wol_exclusion(adapter, wol))\r\nreturn wol->wolopts ? -EOPNOTSUPP : 0;\r\nadapter->wol = 0;\r\nif (wol->wolopts & WAKE_UCAST)\r\nadapter->wol |= IXGBE_WUFC_EX;\r\nif (wol->wolopts & WAKE_MCAST)\r\nadapter->wol |= IXGBE_WUFC_MC;\r\nif (wol->wolopts & WAKE_BCAST)\r\nadapter->wol |= IXGBE_WUFC_BC;\r\nif (wol->wolopts & WAKE_MAGIC)\r\nadapter->wol |= IXGBE_WUFC_MAG;\r\ndevice_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);\r\nreturn 0;\r\n}\r\nstatic int ixgbe_nway_reset(struct net_device *netdev)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nif (netif_running(netdev))\r\nixgbe_reinit_locked(adapter);\r\nreturn 0;\r\n}\r\nstatic int ixgbe_set_phys_id(struct net_device *netdev,\r\nenum ethtool_phys_id_state state)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nswitch (state) {\r\ncase ETHTOOL_ID_ACTIVE:\r\nadapter->led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);\r\nreturn 2;\r\ncase ETHTOOL_ID_ON:\r\nhw->mac.ops.led_on(hw, IXGBE_LED_ON);\r\nbreak;\r\ncase ETHTOOL_ID_OFF:\r\nhw->mac.ops.led_off(hw, IXGBE_LED_ON);\r\nbreak;\r\ncase ETHTOOL_ID_INACTIVE:\r\nIXGBE_WRITE_REG(&adapter->hw, IXGBE_LEDCTL, adapter->led_reg);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ixgbe_get_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nif (adapter->rx_itr_setting <= 1)\r\nec->rx_coalesce_usecs = adapter->rx_itr_setting;\r\nelse\r\nec->rx_coalesce_usecs = adapter->rx_itr_setting >> 2;\r\nif (adapter->q_vector[0]->tx.count && adapter->q_vector[0]->rx.count)\r\nreturn 0;\r\nif (adapter->tx_itr_setting <= 1)\r\nec->tx_coalesce_usecs = adapter->tx_itr_setting;\r\nelse\r\nec->tx_coalesce_usecs = adapter->tx_itr_setting >> 2;\r\nreturn 0;\r\n}\r\nstatic bool ixgbe_update_rsc(struct ixgbe_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nif (!(adapter->flags2 & IXGBE_FLAG2_RSC_CAPABLE) ||\r\n!(netdev->features & NETIF_F_LRO))\r\nreturn false;\r\nif (adapter->rx_itr_setting == 1 ||\r\nadapter->rx_itr_setting > IXGBE_MIN_RSC_ITR) {\r\nif (!(adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED)) {\r\nadapter->flags2 |= IXGBE_FLAG2_RSC_ENABLED;\r\ne_info(probe, "rx-usecs value high enough to re-enable RSC\n");\r\nreturn true;\r\n}\r\n} else if (adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED) {\r\nadapter->flags2 &= ~IXGBE_FLAG2_RSC_ENABLED;\r\ne_info(probe, "rx-usecs set too low, disabling RSC\n");\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int ixgbe_set_coalesce(struct net_device *netdev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(netdev);\r\nstruct ixgbe_q_vector *q_vector;\r\nint i;\r\nu16 tx_itr_param, rx_itr_param, tx_itr_prev;\r\nbool need_reset = false;\r\nif (adapter->q_vector[0]->tx.count && adapter->q_vector[0]->rx.count) {\r\nif (ec->tx_coalesce_usecs)\r\nreturn -EINVAL;\r\ntx_itr_prev = adapter->rx_itr_setting;\r\n} else {\r\ntx_itr_prev = adapter->tx_itr_setting;\r\n}\r\nif ((ec->rx_coalesce_usecs > (IXGBE_MAX_EITR >> 2)) ||\r\n(ec->tx_coalesce_usecs > (IXGBE_MAX_EITR >> 2)))\r\nreturn -EINVAL;\r\nif (ec->rx_coalesce_usecs > 1)\r\nadapter->rx_itr_setting = ec->rx_coalesce_usecs << 2;\r\nelse\r\nadapter->rx_itr_setting = ec->rx_coalesce_usecs;\r\nif (adapter->rx_itr_setting == 1)\r\nrx_itr_param = IXGBE_20K_ITR;\r\nelse\r\nrx_itr_param = adapter->rx_itr_setting;\r\nif (ec->tx_coalesce_usecs > 1)\r\nadapter->tx_itr_setting = ec->tx_coalesce_usecs << 2;\r\nelse\r\nadapter->tx_itr_setting = ec->tx_coalesce_usecs;\r\nif (adapter->tx_itr_setting == 1)\r\ntx_itr_param = IXGBE_10K_ITR;\r\nelse\r\ntx_itr_param = adapter->tx_itr_setting;\r\nif (adapter->q_vector[0]->tx.count && adapter->q_vector[0]->rx.count)\r\nadapter->tx_itr_setting = adapter->rx_itr_setting;\r\nif ((adapter->tx_itr_setting != 1) &&\r\n(adapter->tx_itr_setting < IXGBE_100K_ITR)) {\r\nif ((tx_itr_prev == 1) ||\r\n(tx_itr_prev >= IXGBE_100K_ITR))\r\nneed_reset = true;\r\n} else {\r\nif ((tx_itr_prev != 1) &&\r\n(tx_itr_prev < IXGBE_100K_ITR))\r\nneed_reset = true;\r\n}\r\nneed_reset |= ixgbe_update_rsc(adapter);\r\nfor (i = 0; i < adapter->num_q_vectors; i++) {\r\nq_vector = adapter->q_vector[i];\r\nif (q_vector->tx.count && !q_vector->rx.count)\r\nq_vector->itr = tx_itr_param;\r\nelse\r\nq_vector->itr = rx_itr_param;\r\nixgbe_write_eitr(q_vector);\r\n}\r\nif (need_reset)\r\nixgbe_do_reset(netdev);\r\nreturn 0;\r\n}\r\nstatic int ixgbe_get_ethtool_fdir_entry(struct ixgbe_adapter *adapter,\r\nstruct ethtool_rxnfc *cmd)\r\n{\r\nunion ixgbe_atr_input *mask = &adapter->fdir_mask;\r\nstruct ethtool_rx_flow_spec *fsp =\r\n(struct ethtool_rx_flow_spec *)&cmd->fs;\r\nstruct hlist_node *node2;\r\nstruct ixgbe_fdir_filter *rule = NULL;\r\ncmd->data = (1024 << adapter->fdir_pballoc) - 2;\r\nhlist_for_each_entry_safe(rule, node2,\r\n&adapter->fdir_filter_list, fdir_node) {\r\nif (fsp->location <= rule->sw_idx)\r\nbreak;\r\n}\r\nif (!rule || fsp->location != rule->sw_idx)\r\nreturn -EINVAL;\r\nswitch (rule->filter.formatted.flow_type) {\r\ncase IXGBE_ATR_FLOW_TYPE_TCPV4:\r\nfsp->flow_type = TCP_V4_FLOW;\r\nbreak;\r\ncase IXGBE_ATR_FLOW_TYPE_UDPV4:\r\nfsp->flow_type = UDP_V4_FLOW;\r\nbreak;\r\ncase IXGBE_ATR_FLOW_TYPE_SCTPV4:\r\nfsp->flow_type = SCTP_V4_FLOW;\r\nbreak;\r\ncase IXGBE_ATR_FLOW_TYPE_IPV4:\r\nfsp->flow_type = IP_USER_FLOW;\r\nfsp->h_u.usr_ip4_spec.ip_ver = ETH_RX_NFC_IP4;\r\nfsp->h_u.usr_ip4_spec.proto = 0;\r\nfsp->m_u.usr_ip4_spec.proto = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfsp->h_u.tcp_ip4_spec.psrc = rule->filter.formatted.src_port;\r\nfsp->m_u.tcp_ip4_spec.psrc = mask->formatted.src_port;\r\nfsp->h_u.tcp_ip4_spec.pdst = rule->filter.formatted.dst_port;\r\nfsp->m_u.tcp_ip4_spec.pdst = mask->formatted.dst_port;\r\nfsp->h_u.tcp_ip4_spec.ip4src = rule->filter.formatted.src_ip[0];\r\nfsp->m_u.tcp_ip4_spec.ip4src = mask->formatted.src_ip[0];\r\nfsp->h_u.tcp_ip4_spec.ip4dst = rule->filter.formatted.dst_ip[0];\r\nfsp->m_u.tcp_ip4_spec.ip4dst = mask->formatted.dst_ip[0];\r\nfsp->h_ext.vlan_tci = rule->filter.formatted.vlan_id;\r\nfsp->m_ext.vlan_tci = mask->formatted.vlan_id;\r\nfsp->h_ext.vlan_etype = rule->filter.formatted.flex_bytes;\r\nfsp->m_ext.vlan_etype = mask->formatted.flex_bytes;\r\nfsp->h_ext.data[1] = htonl(rule->filter.formatted.vm_pool);\r\nfsp->m_ext.data[1] = htonl(mask->formatted.vm_pool);\r\nfsp->flow_type |= FLOW_EXT;\r\nif (rule->action == IXGBE_FDIR_DROP_QUEUE)\r\nfsp->ring_cookie = RX_CLS_FLOW_DISC;\r\nelse\r\nfsp->ring_cookie = rule->action;\r\nreturn 0;\r\n}\r\nstatic int ixgbe_get_ethtool_fdir_all(struct ixgbe_adapter *adapter,\r\nstruct ethtool_rxnfc *cmd,\r\nu32 *rule_locs)\r\n{\r\nstruct hlist_node *node2;\r\nstruct ixgbe_fdir_filter *rule;\r\nint cnt = 0;\r\ncmd->data = (1024 << adapter->fdir_pballoc) - 2;\r\nhlist_for_each_entry_safe(rule, node2,\r\n&adapter->fdir_filter_list, fdir_node) {\r\nif (cnt == cmd->rule_cnt)\r\nreturn -EMSGSIZE;\r\nrule_locs[cnt] = rule->sw_idx;\r\ncnt++;\r\n}\r\ncmd->rule_cnt = cnt;\r\nreturn 0;\r\n}\r\nstatic int ixgbe_get_rss_hash_opts(struct ixgbe_adapter *adapter,\r\nstruct ethtool_rxnfc *cmd)\r\n{\r\ncmd->data = 0;\r\nswitch (cmd->flow_type) {\r\ncase TCP_V4_FLOW:\r\ncmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\ncase UDP_V4_FLOW:\r\nif (adapter->flags2 & IXGBE_FLAG2_RSS_FIELD_IPV4_UDP)\r\ncmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\ncase SCTP_V4_FLOW:\r\ncase AH_ESP_V4_FLOW:\r\ncase AH_V4_FLOW:\r\ncase ESP_V4_FLOW:\r\ncase IPV4_FLOW:\r\ncmd->data |= RXH_IP_SRC | RXH_IP_DST;\r\nbreak;\r\ncase TCP_V6_FLOW:\r\ncmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\ncase UDP_V6_FLOW:\r\nif (adapter->flags2 & IXGBE_FLAG2_RSS_FIELD_IPV6_UDP)\r\ncmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\r\ncase SCTP_V6_FLOW:\r\ncase AH_ESP_V6_FLOW:\r\ncase AH_V6_FLOW:\r\ncase ESP_V6_FLOW:\r\ncase IPV6_FLOW:\r\ncmd->data |= RXH_IP_SRC | RXH_IP_DST;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ixgbe_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\r\nu32 *rule_locs)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(dev);\r\nint ret = -EOPNOTSUPP;\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_GRXRINGS:\r\ncmd->data = adapter->num_rx_queues;\r\nret = 0;\r\nbreak;\r\ncase ETHTOOL_GRXCLSRLCNT:\r\ncmd->rule_cnt = adapter->fdir_filter_count;\r\nret = 0;\r\nbreak;\r\ncase ETHTOOL_GRXCLSRULE:\r\nret = ixgbe_get_ethtool_fdir_entry(adapter, cmd);\r\nbreak;\r\ncase ETHTOOL_GRXCLSRLALL:\r\nret = ixgbe_get_ethtool_fdir_all(adapter, cmd, rule_locs);\r\nbreak;\r\ncase ETHTOOL_GRXFH:\r\nret = ixgbe_get_rss_hash_opts(adapter, cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ixgbe_update_ethtool_fdir_entry(struct ixgbe_adapter *adapter,\r\nstruct ixgbe_fdir_filter *input,\r\nu16 sw_idx)\r\n{\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nstruct hlist_node *node2;\r\nstruct ixgbe_fdir_filter *rule, *parent;\r\nint err = -EINVAL;\r\nparent = NULL;\r\nrule = NULL;\r\nhlist_for_each_entry_safe(rule, node2,\r\n&adapter->fdir_filter_list, fdir_node) {\r\nif (rule->sw_idx >= sw_idx)\r\nbreak;\r\nparent = rule;\r\n}\r\nif (rule && (rule->sw_idx == sw_idx)) {\r\nif (!input || (rule->filter.formatted.bkt_hash !=\r\ninput->filter.formatted.bkt_hash)) {\r\nerr = ixgbe_fdir_erase_perfect_filter_82599(hw,\r\n&rule->filter,\r\nsw_idx);\r\n}\r\nhlist_del(&rule->fdir_node);\r\nkfree(rule);\r\nadapter->fdir_filter_count--;\r\n}\r\nif (!input)\r\nreturn err;\r\nINIT_HLIST_NODE(&input->fdir_node);\r\nif (parent)\r\nhlist_add_behind(&input->fdir_node, &parent->fdir_node);\r\nelse\r\nhlist_add_head(&input->fdir_node,\r\n&adapter->fdir_filter_list);\r\nadapter->fdir_filter_count++;\r\nreturn 0;\r\n}\r\nstatic int ixgbe_flowspec_to_flow_type(struct ethtool_rx_flow_spec *fsp,\r\nu8 *flow_type)\r\n{\r\nswitch (fsp->flow_type & ~FLOW_EXT) {\r\ncase TCP_V4_FLOW:\r\n*flow_type = IXGBE_ATR_FLOW_TYPE_TCPV4;\r\nbreak;\r\ncase UDP_V4_FLOW:\r\n*flow_type = IXGBE_ATR_FLOW_TYPE_UDPV4;\r\nbreak;\r\ncase SCTP_V4_FLOW:\r\n*flow_type = IXGBE_ATR_FLOW_TYPE_SCTPV4;\r\nbreak;\r\ncase IP_USER_FLOW:\r\nswitch (fsp->h_u.usr_ip4_spec.proto) {\r\ncase IPPROTO_TCP:\r\n*flow_type = IXGBE_ATR_FLOW_TYPE_TCPV4;\r\nbreak;\r\ncase IPPROTO_UDP:\r\n*flow_type = IXGBE_ATR_FLOW_TYPE_UDPV4;\r\nbreak;\r\ncase IPPROTO_SCTP:\r\n*flow_type = IXGBE_ATR_FLOW_TYPE_SCTPV4;\r\nbreak;\r\ncase 0:\r\nif (!fsp->m_u.usr_ip4_spec.proto) {\r\n*flow_type = IXGBE_ATR_FLOW_TYPE_IPV4;\r\nbreak;\r\n}\r\ndefault:\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int ixgbe_add_ethtool_fdir_entry(struct ixgbe_adapter *adapter,\r\nstruct ethtool_rxnfc *cmd)\r\n{\r\nstruct ethtool_rx_flow_spec *fsp =\r\n(struct ethtool_rx_flow_spec *)&cmd->fs;\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nstruct ixgbe_fdir_filter *input;\r\nunion ixgbe_atr_input mask;\r\nint err;\r\nif (!(adapter->flags & IXGBE_FLAG_FDIR_PERFECT_CAPABLE))\r\nreturn -EOPNOTSUPP;\r\nif ((fsp->ring_cookie != RX_CLS_FLOW_DISC) &&\r\n(fsp->ring_cookie >= adapter->num_rx_queues))\r\nreturn -EINVAL;\r\nif (fsp->location >= ((1024 << adapter->fdir_pballoc) - 2)) {\r\ne_err(drv, "Location out of range\n");\r\nreturn -EINVAL;\r\n}\r\ninput = kzalloc(sizeof(*input), GFP_ATOMIC);\r\nif (!input)\r\nreturn -ENOMEM;\r\nmemset(&mask, 0, sizeof(union ixgbe_atr_input));\r\ninput->sw_idx = fsp->location;\r\nif (!ixgbe_flowspec_to_flow_type(fsp,\r\n&input->filter.formatted.flow_type)) {\r\ne_err(drv, "Unrecognized flow type\n");\r\ngoto err_out;\r\n}\r\nmask.formatted.flow_type = IXGBE_ATR_L4TYPE_IPV6_MASK |\r\nIXGBE_ATR_L4TYPE_MASK;\r\nif (input->filter.formatted.flow_type == IXGBE_ATR_FLOW_TYPE_IPV4)\r\nmask.formatted.flow_type &= IXGBE_ATR_L4TYPE_IPV6_MASK;\r\ninput->filter.formatted.src_ip[0] = fsp->h_u.tcp_ip4_spec.ip4src;\r\nmask.formatted.src_ip[0] = fsp->m_u.tcp_ip4_spec.ip4src;\r\ninput->filter.formatted.dst_ip[0] = fsp->h_u.tcp_ip4_spec.ip4dst;\r\nmask.formatted.dst_ip[0] = fsp->m_u.tcp_ip4_spec.ip4dst;\r\ninput->filter.formatted.src_port = fsp->h_u.tcp_ip4_spec.psrc;\r\nmask.formatted.src_port = fsp->m_u.tcp_ip4_spec.psrc;\r\ninput->filter.formatted.dst_port = fsp->h_u.tcp_ip4_spec.pdst;\r\nmask.formatted.dst_port = fsp->m_u.tcp_ip4_spec.pdst;\r\nif (fsp->flow_type & FLOW_EXT) {\r\ninput->filter.formatted.vm_pool =\r\n(unsigned char)ntohl(fsp->h_ext.data[1]);\r\nmask.formatted.vm_pool =\r\n(unsigned char)ntohl(fsp->m_ext.data[1]);\r\ninput->filter.formatted.vlan_id = fsp->h_ext.vlan_tci;\r\nmask.formatted.vlan_id = fsp->m_ext.vlan_tci;\r\ninput->filter.formatted.flex_bytes =\r\nfsp->h_ext.vlan_etype;\r\nmask.formatted.flex_bytes = fsp->m_ext.vlan_etype;\r\n}\r\nif (fsp->ring_cookie == RX_CLS_FLOW_DISC)\r\ninput->action = IXGBE_FDIR_DROP_QUEUE;\r\nelse\r\ninput->action = fsp->ring_cookie;\r\nspin_lock(&adapter->fdir_perfect_lock);\r\nif (hlist_empty(&adapter->fdir_filter_list)) {\r\nmemcpy(&adapter->fdir_mask, &mask, sizeof(mask));\r\nerr = ixgbe_fdir_set_input_mask_82599(hw, &mask);\r\nif (err) {\r\ne_err(drv, "Error writing mask\n");\r\ngoto err_out_w_lock;\r\n}\r\n} else if (memcmp(&adapter->fdir_mask, &mask, sizeof(mask))) {\r\ne_err(drv, "Only one mask supported per port\n");\r\ngoto err_out_w_lock;\r\n}\r\nixgbe_atr_compute_perfect_hash_82599(&input->filter, &mask);\r\nerr = ixgbe_fdir_write_perfect_filter_82599(hw,\r\n&input->filter, input->sw_idx,\r\n(input->action == IXGBE_FDIR_DROP_QUEUE) ?\r\nIXGBE_FDIR_DROP_QUEUE :\r\nadapter->rx_ring[input->action]->reg_idx);\r\nif (err)\r\ngoto err_out_w_lock;\r\nixgbe_update_ethtool_fdir_entry(adapter, input, input->sw_idx);\r\nspin_unlock(&adapter->fdir_perfect_lock);\r\nreturn err;\r\nerr_out_w_lock:\r\nspin_unlock(&adapter->fdir_perfect_lock);\r\nerr_out:\r\nkfree(input);\r\nreturn -EINVAL;\r\n}\r\nstatic int ixgbe_del_ethtool_fdir_entry(struct ixgbe_adapter *adapter,\r\nstruct ethtool_rxnfc *cmd)\r\n{\r\nstruct ethtool_rx_flow_spec *fsp =\r\n(struct ethtool_rx_flow_spec *)&cmd->fs;\r\nint err;\r\nspin_lock(&adapter->fdir_perfect_lock);\r\nerr = ixgbe_update_ethtool_fdir_entry(adapter, NULL, fsp->location);\r\nspin_unlock(&adapter->fdir_perfect_lock);\r\nreturn err;\r\n}\r\nstatic int ixgbe_set_rss_hash_opt(struct ixgbe_adapter *adapter,\r\nstruct ethtool_rxnfc *nfc)\r\n{\r\nu32 flags2 = adapter->flags2;\r\nif (nfc->data & ~(RXH_IP_SRC | RXH_IP_DST |\r\nRXH_L4_B_0_1 | RXH_L4_B_2_3))\r\nreturn -EINVAL;\r\nswitch (nfc->flow_type) {\r\ncase TCP_V4_FLOW:\r\ncase TCP_V6_FLOW:\r\nif (!(nfc->data & RXH_IP_SRC) ||\r\n!(nfc->data & RXH_IP_DST) ||\r\n!(nfc->data & RXH_L4_B_0_1) ||\r\n!(nfc->data & RXH_L4_B_2_3))\r\nreturn -EINVAL;\r\nbreak;\r\ncase UDP_V4_FLOW:\r\nif (!(nfc->data & RXH_IP_SRC) ||\r\n!(nfc->data & RXH_IP_DST))\r\nreturn -EINVAL;\r\nswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\r\ncase 0:\r\nflags2 &= ~IXGBE_FLAG2_RSS_FIELD_IPV4_UDP;\r\nbreak;\r\ncase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\r\nflags2 |= IXGBE_FLAG2_RSS_FIELD_IPV4_UDP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase UDP_V6_FLOW:\r\nif (!(nfc->data & RXH_IP_SRC) ||\r\n!(nfc->data & RXH_IP_DST))\r\nreturn -EINVAL;\r\nswitch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {\r\ncase 0:\r\nflags2 &= ~IXGBE_FLAG2_RSS_FIELD_IPV6_UDP;\r\nbreak;\r\ncase (RXH_L4_B_0_1 | RXH_L4_B_2_3):\r\nflags2 |= IXGBE_FLAG2_RSS_FIELD_IPV6_UDP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase AH_ESP_V4_FLOW:\r\ncase AH_V4_FLOW:\r\ncase ESP_V4_FLOW:\r\ncase SCTP_V4_FLOW:\r\ncase AH_ESP_V6_FLOW:\r\ncase AH_V6_FLOW:\r\ncase ESP_V6_FLOW:\r\ncase SCTP_V6_FLOW:\r\nif (!(nfc->data & RXH_IP_SRC) ||\r\n!(nfc->data & RXH_IP_DST) ||\r\n(nfc->data & RXH_L4_B_0_1) ||\r\n(nfc->data & RXH_L4_B_2_3))\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (flags2 != adapter->flags2) {\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 mrqc;\r\nunsigned int pf_pool = adapter->num_vfs;\r\nif ((hw->mac.type >= ixgbe_mac_X550) &&\r\n(adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))\r\nmrqc = IXGBE_READ_REG(hw, IXGBE_PFVFMRQC(pf_pool));\r\nelse\r\nmrqc = IXGBE_READ_REG(hw, IXGBE_MRQC);\r\nif ((flags2 & UDP_RSS_FLAGS) &&\r\n!(adapter->flags2 & UDP_RSS_FLAGS))\r\ne_warn(drv, "enabling UDP RSS: fragmented packets may arrive out of order to the stack above\n");\r\nadapter->flags2 = flags2;\r\nmrqc |= IXGBE_MRQC_RSS_FIELD_IPV4\r\n| IXGBE_MRQC_RSS_FIELD_IPV4_TCP\r\n| IXGBE_MRQC_RSS_FIELD_IPV6\r\n| IXGBE_MRQC_RSS_FIELD_IPV6_TCP;\r\nmrqc &= ~(IXGBE_MRQC_RSS_FIELD_IPV4_UDP |\r\nIXGBE_MRQC_RSS_FIELD_IPV6_UDP);\r\nif (flags2 & IXGBE_FLAG2_RSS_FIELD_IPV4_UDP)\r\nmrqc |= IXGBE_MRQC_RSS_FIELD_IPV4_UDP;\r\nif (flags2 & IXGBE_FLAG2_RSS_FIELD_IPV6_UDP)\r\nmrqc |= IXGBE_MRQC_RSS_FIELD_IPV6_UDP;\r\nif ((hw->mac.type >= ixgbe_mac_X550) &&\r\n(adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))\r\nIXGBE_WRITE_REG(hw, IXGBE_PFVFMRQC(pf_pool), mrqc);\r\nelse\r\nIXGBE_WRITE_REG(hw, IXGBE_MRQC, mrqc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ixgbe_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(dev);\r\nint ret = -EOPNOTSUPP;\r\nswitch (cmd->cmd) {\r\ncase ETHTOOL_SRXCLSRLINS:\r\nret = ixgbe_add_ethtool_fdir_entry(adapter, cmd);\r\nbreak;\r\ncase ETHTOOL_SRXCLSRLDEL:\r\nret = ixgbe_del_ethtool_fdir_entry(adapter, cmd);\r\nbreak;\r\ncase ETHTOOL_SRXFH:\r\nret = ixgbe_set_rss_hash_opt(adapter, cmd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ixgbe_get_ts_info(struct net_device *dev,\r\nstruct ethtool_ts_info *info)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(dev);\r\nswitch (adapter->hw.mac.type) {\r\ncase ixgbe_mac_X550:\r\ncase ixgbe_mac_X550EM_x:\r\ncase ixgbe_mac_X540:\r\ncase ixgbe_mac_82599EB:\r\ninfo->so_timestamping =\r\nSOF_TIMESTAMPING_TX_SOFTWARE |\r\nSOF_TIMESTAMPING_RX_SOFTWARE |\r\nSOF_TIMESTAMPING_SOFTWARE |\r\nSOF_TIMESTAMPING_TX_HARDWARE |\r\nSOF_TIMESTAMPING_RX_HARDWARE |\r\nSOF_TIMESTAMPING_RAW_HARDWARE;\r\nif (adapter->ptp_clock)\r\ninfo->phc_index = ptp_clock_index(adapter->ptp_clock);\r\nelse\r\ninfo->phc_index = -1;\r\ninfo->tx_types =\r\n(1 << HWTSTAMP_TX_OFF) |\r\n(1 << HWTSTAMP_TX_ON);\r\ninfo->rx_filters =\r\n(1 << HWTSTAMP_FILTER_NONE) |\r\n(1 << HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |\r\n(1 << HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_SYNC) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L2_SYNC) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_EVENT);\r\nbreak;\r\ndefault:\r\nreturn ethtool_op_get_ts_info(dev, info);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int ixgbe_max_channels(struct ixgbe_adapter *adapter)\r\n{\r\nunsigned int max_combined;\r\nu8 tcs = netdev_get_num_tc(adapter->netdev);\r\nif (!(adapter->flags & IXGBE_FLAG_MSIX_ENABLED)) {\r\nmax_combined = 1;\r\n} else if (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED) {\r\nmax_combined = 1;\r\n} else if (tcs > 1) {\r\nif (adapter->hw.mac.type == ixgbe_mac_82598EB) {\r\nmax_combined = 4;\r\n} else if (tcs > 4) {\r\nmax_combined = 8;\r\n} else {\r\nmax_combined = 16;\r\n}\r\n} else if (adapter->atr_sample_rate) {\r\nmax_combined = IXGBE_MAX_FDIR_INDICES;\r\n} else {\r\nmax_combined = ixgbe_max_rss_indices(adapter);\r\n}\r\nreturn max_combined;\r\n}\r\nstatic void ixgbe_get_channels(struct net_device *dev,\r\nstruct ethtool_channels *ch)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(dev);\r\nch->max_combined = ixgbe_max_channels(adapter);\r\nif (adapter->flags & IXGBE_FLAG_MSIX_ENABLED) {\r\nch->max_other = NON_Q_VECTORS;\r\nch->other_count = NON_Q_VECTORS;\r\n}\r\nch->combined_count = adapter->ring_feature[RING_F_RSS].indices;\r\nif (ch->combined_count == 1)\r\nreturn;\r\nif (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED)\r\nreturn;\r\nif (netdev_get_num_tc(dev) > 1)\r\nreturn;\r\nif (!adapter->atr_sample_rate)\r\nreturn;\r\nch->combined_count = adapter->ring_feature[RING_F_FDIR].indices;\r\n}\r\nstatic int ixgbe_set_channels(struct net_device *dev,\r\nstruct ethtool_channels *ch)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(dev);\r\nunsigned int count = ch->combined_count;\r\nu8 max_rss_indices = ixgbe_max_rss_indices(adapter);\r\nif (!count || ch->rx_count || ch->tx_count)\r\nreturn -EINVAL;\r\nif (ch->other_count != NON_Q_VECTORS)\r\nreturn -EINVAL;\r\nif (count > ixgbe_max_channels(adapter))\r\nreturn -EINVAL;\r\nadapter->ring_feature[RING_F_FDIR].limit = count;\r\nif (count > max_rss_indices)\r\ncount = max_rss_indices;\r\nadapter->ring_feature[RING_F_RSS].limit = count;\r\n#ifdef IXGBE_FCOE\r\nif (count > IXGBE_FCRETA_SIZE)\r\ncount = IXGBE_FCRETA_SIZE;\r\nadapter->ring_feature[RING_F_FCOE].limit = count;\r\n#endif\r\nreturn ixgbe_setup_tc(dev, netdev_get_num_tc(dev));\r\n}\r\nstatic int ixgbe_get_module_info(struct net_device *dev,\r\nstruct ethtool_modinfo *modinfo)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(dev);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 status;\r\nu8 sff8472_rev, addr_mode;\r\nbool page_swap = false;\r\nstatus = hw->phy.ops.read_i2c_eeprom(hw,\r\nIXGBE_SFF_SFF_8472_COMP,\r\n&sff8472_rev);\r\nif (status != 0)\r\nreturn -EIO;\r\nstatus = hw->phy.ops.read_i2c_eeprom(hw,\r\nIXGBE_SFF_SFF_8472_SWAP,\r\n&addr_mode);\r\nif (status != 0)\r\nreturn -EIO;\r\nif (addr_mode & IXGBE_SFF_ADDRESSING_MODE) {\r\ne_err(drv, "Address change required to access page 0xA2, but not supported. Please report the module type to the driver maintainers.\n");\r\npage_swap = true;\r\n}\r\nif (sff8472_rev == IXGBE_SFF_SFF_8472_UNSUP || page_swap) {\r\nmodinfo->type = ETH_MODULE_SFF_8079;\r\nmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\r\n} else {\r\nmodinfo->type = ETH_MODULE_SFF_8472;\r\nmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ixgbe_get_module_eeprom(struct net_device *dev,\r\nstruct ethtool_eeprom *ee,\r\nu8 *data)\r\n{\r\nstruct ixgbe_adapter *adapter = netdev_priv(dev);\r\nstruct ixgbe_hw *hw = &adapter->hw;\r\nu32 status = IXGBE_ERR_PHY_ADDR_INVALID;\r\nu8 databyte = 0xFF;\r\nint i = 0;\r\nif (ee->len == 0)\r\nreturn -EINVAL;\r\nfor (i = ee->offset; i < ee->offset + ee->len; i++) {\r\nif (test_bit(__IXGBE_IN_SFP_INIT, &adapter->state))\r\nreturn -EBUSY;\r\nif (i < ETH_MODULE_SFF_8079_LEN)\r\nstatus = hw->phy.ops.read_i2c_eeprom(hw, i, &databyte);\r\nelse\r\nstatus = hw->phy.ops.read_i2c_sff8472(hw, i, &databyte);\r\nif (status != 0)\r\nreturn -EIO;\r\ndata[i - ee->offset] = databyte;\r\n}\r\nreturn 0;\r\n}\r\nvoid ixgbe_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nnetdev->ethtool_ops = &ixgbe_ethtool_ops;\r\n}
