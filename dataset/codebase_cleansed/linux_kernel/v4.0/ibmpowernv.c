static ssize_t show_sensor(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_data *sdata = container_of(devattr, struct sensor_data,\r\ndev_attr);\r\nssize_t ret;\r\nu32 x;\r\nret = opal_get_sensor_data(sdata->id, &x);\r\nif (ret)\r\nreturn ret;\r\nif (sdata->type == AMBIENT_TEMP)\r\nx *= 1000;\r\nelse if (sdata->type == POWER_INPUT)\r\nx *= 1000000;\r\nreturn sprintf(buf, "%u\n", x);\r\n}\r\nstatic int get_sensor_index_attr(const char *name, u32 *index,\r\nchar *attr)\r\n{\r\nchar *hash_pos = strchr(name, '#');\r\nchar buf[8] = { 0 };\r\nchar *dash_pos;\r\nu32 copy_len;\r\nint err;\r\nif (!hash_pos)\r\nreturn -EINVAL;\r\ndash_pos = strchr(hash_pos, '-');\r\nif (!dash_pos)\r\nreturn -EINVAL;\r\ncopy_len = dash_pos - hash_pos - 1;\r\nif (copy_len >= sizeof(buf))\r\nreturn -EINVAL;\r\nstrncpy(buf, hash_pos + 1, copy_len);\r\nerr = kstrtou32(buf, 10, index);\r\nif (err)\r\nreturn err;\r\nstrncpy(attr, dash_pos + 1, MAX_ATTR_LEN);\r\nreturn 0;\r\n}\r\nstatic int create_hwmon_attr_name(struct device *dev, enum sensors type,\r\nconst char *node_name,\r\nchar *hwmon_attr_name)\r\n{\r\nchar attr_suffix[MAX_ATTR_LEN];\r\nchar *attr_name;\r\nu32 index;\r\nint err;\r\nerr = get_sensor_index_attr(node_name, &index, attr_suffix);\r\nif (err) {\r\ndev_err(dev, "Sensor device node name '%s' is invalid\n",\r\nnode_name);\r\nreturn err;\r\n}\r\nif (!strcmp(attr_suffix, DT_FAULT_ATTR_SUFFIX)) {\r\nattr_name = "fault";\r\n} else if (!strcmp(attr_suffix, DT_DATA_ATTR_SUFFIX)) {\r\nattr_name = "input";\r\n} else if (!strcmp(attr_suffix, DT_THRESHOLD_ATTR_SUFFIX)) {\r\nif (type == AMBIENT_TEMP)\r\nattr_name = "max";\r\nelse if (type == FAN)\r\nattr_name = "min";\r\nelse\r\nreturn -ENOENT;\r\n} else {\r\nreturn -ENOENT;\r\n}\r\nsnprintf(hwmon_attr_name, MAX_ATTR_LEN, "%s%d_%s",\r\nsensor_groups[type].name, index, attr_name);\r\nreturn 0;\r\n}\r\nstatic int populate_attr_groups(struct platform_device *pdev)\r\n{\r\nstruct platform_data *pdata = platform_get_drvdata(pdev);\r\nconst struct attribute_group **pgroups = pdata->attr_groups;\r\nstruct device_node *opal, *np;\r\nenum sensors type;\r\nopal = of_find_node_by_path("/ibm,opal/sensors");\r\nfor_each_child_of_node(opal, np) {\r\nif (np->name == NULL)\r\ncontinue;\r\nfor (type = 0; type < MAX_SENSOR_TYPE; type++)\r\nif (of_device_is_compatible(np,\r\nsensor_groups[type].compatible)) {\r\nsensor_groups[type].attr_count++;\r\nbreak;\r\n}\r\n}\r\nof_node_put(opal);\r\nfor (type = 0; type < MAX_SENSOR_TYPE; type++) {\r\nsensor_groups[type].group.attrs = devm_kzalloc(&pdev->dev,\r\nsizeof(struct attribute *) *\r\n(sensor_groups[type].attr_count + 1),\r\nGFP_KERNEL);\r\nif (!sensor_groups[type].group.attrs)\r\nreturn -ENOMEM;\r\npgroups[type] = &sensor_groups[type].group;\r\npdata->sensors_count += sensor_groups[type].attr_count;\r\nsensor_groups[type].attr_count = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int create_device_attrs(struct platform_device *pdev)\r\n{\r\nstruct platform_data *pdata = platform_get_drvdata(pdev);\r\nconst struct attribute_group **pgroups = pdata->attr_groups;\r\nstruct device_node *opal, *np;\r\nstruct sensor_data *sdata;\r\nu32 sensor_id;\r\nenum sensors type;\r\nu32 count = 0;\r\nint err = 0;\r\nopal = of_find_node_by_path("/ibm,opal/sensors");\r\nsdata = devm_kzalloc(&pdev->dev, pdata->sensors_count * sizeof(*sdata),\r\nGFP_KERNEL);\r\nif (!sdata) {\r\nerr = -ENOMEM;\r\ngoto exit_put_node;\r\n}\r\nfor_each_child_of_node(opal, np) {\r\nif (np->name == NULL)\r\ncontinue;\r\nfor (type = 0; type < MAX_SENSOR_TYPE; type++)\r\nif (of_device_is_compatible(np,\r\nsensor_groups[type].compatible))\r\nbreak;\r\nif (type == MAX_SENSOR_TYPE)\r\ncontinue;\r\nif (of_property_read_u32(np, "sensor-id", &sensor_id)) {\r\ndev_info(&pdev->dev,\r\n"'sensor-id' missing in the node '%s'\n",\r\nnp->name);\r\ncontinue;\r\n}\r\nsdata[count].id = sensor_id;\r\nsdata[count].type = type;\r\nerr = create_hwmon_attr_name(&pdev->dev, type, np->name,\r\nsdata[count].name);\r\nif (err)\r\ngoto exit_put_node;\r\nsysfs_attr_init(&sdata[count].dev_attr.attr);\r\nsdata[count].dev_attr.attr.name = sdata[count].name;\r\nsdata[count].dev_attr.attr.mode = S_IRUGO;\r\nsdata[count].dev_attr.show = show_sensor;\r\npgroups[type]->attrs[sensor_groups[type].attr_count++] =\r\n&sdata[count++].dev_attr.attr;\r\n}\r\nexit_put_node:\r\nof_node_put(opal);\r\nreturn err;\r\n}\r\nstatic int ibmpowernv_probe(struct platform_device *pdev)\r\n{\r\nstruct platform_data *pdata;\r\nstruct device *hwmon_dev;\r\nint err;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, pdata);\r\npdata->sensors_count = 0;\r\nerr = populate_attr_groups(pdev);\r\nif (err)\r\nreturn err;\r\nerr = create_device_attrs(pdev);\r\nif (err)\r\nreturn err;\r\nhwmon_dev = devm_hwmon_device_register_with_groups(&pdev->dev, DRVNAME,\r\npdata,\r\npdata->attr_groups);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
