static int sp2_read_i2c(struct sp2 *s, u8 reg, u8 *buf, int len)\r\n{\r\nint ret;\r\nstruct i2c_client *client = s->client;\r\nstruct i2c_adapter *adap = client->adapter;\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.buf = &reg,\r\n.len = 1\r\n}, {\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.buf = buf,\r\n.len = len\r\n}\r\n};\r\nret = i2c_transfer(adap, msg, 2);\r\nif (ret != 2) {\r\ndev_err(&client->dev, "i2c read error, reg = 0x%02x, status = %d\n",\r\nreg, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EIO;\r\n}\r\ndev_dbg(&s->client->dev, "addr=0x%04x, reg = 0x%02x, data = %02x\n",\r\nclient->addr, reg, buf[0]);\r\nreturn 0;\r\n}\r\nstatic int sp2_write_i2c(struct sp2 *s, u8 reg, u8 *buf, int len)\r\n{\r\nint ret;\r\nu8 buffer[35];\r\nstruct i2c_client *client = s->client;\r\nstruct i2c_adapter *adap = client->adapter;\r\nstruct i2c_msg msg = {\r\n.addr = client->addr,\r\n.flags = 0,\r\n.buf = &buffer[0],\r\n.len = len + 1\r\n};\r\nif ((len + 1) > sizeof(buffer)) {\r\ndev_err(&client->dev, "i2c wr reg=%02x: len=%d is too big!\n",\r\nreg, len);\r\nreturn -EINVAL;\r\n}\r\nbuffer[0] = reg;\r\nmemcpy(&buffer[1], buf, len);\r\nret = i2c_transfer(adap, &msg, 1);\r\nif (ret != 1) {\r\ndev_err(&client->dev, "i2c write error, reg = 0x%02x, status = %d\n",\r\nreg, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EIO;\r\n}\r\ndev_dbg(&s->client->dev, "addr=0x%04x, reg = 0x%02x, data = %*ph\n",\r\nclient->addr, reg, len, buf);\r\nreturn 0;\r\n}\r\nstatic int sp2_ci_op_cam(struct dvb_ca_en50221 *en50221, int slot, u8 acs,\r\nu8 read, int addr, u8 data)\r\n{\r\nstruct sp2 *s = en50221->data;\r\nu8 store;\r\nint mem, ret;\r\nint (*ci_op_cam)(void*, u8, int, u8, int*) = s->ci_control;\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nif (s->module_access_type != acs) {\r\nret = sp2_read_i2c(s, 0x00, &store, 1);\r\nif (ret)\r\nreturn ret;\r\nstore &= ~(SP2_MOD_CTL_ACS1 | SP2_MOD_CTL_ACS0);\r\nstore |= acs;\r\nret = sp2_write_i2c(s, 0x00, &store, 1);\r\nif (ret)\r\nreturn ret;\r\n}\r\ns->module_access_type = acs;\r\nif (ci_op_cam) {\r\nret = ci_op_cam(s->priv, read, addr, data, &mem);\r\n} else {\r\ndev_err(&s->client->dev, "callback not defined");\r\nreturn -EINVAL;\r\n}\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(&s->client->dev, "%s: slot=%d, addr=0x%04x, %s, data=%x",\r\n(read) ? "read" : "write", slot, addr,\r\n(acs == SP2_CI_ATTR_ACS) ? "attr" : "io",\r\n(read) ? mem : data);\r\nif (read)\r\nreturn mem;\r\nelse\r\nreturn 0;\r\n}\r\nint sp2_ci_read_attribute_mem(struct dvb_ca_en50221 *en50221,\r\nint slot, int addr)\r\n{\r\nreturn sp2_ci_op_cam(en50221, slot, SP2_CI_ATTR_ACS,\r\nSP2_CI_RD, addr, 0);\r\n}\r\nint sp2_ci_write_attribute_mem(struct dvb_ca_en50221 *en50221,\r\nint slot, int addr, u8 data)\r\n{\r\nreturn sp2_ci_op_cam(en50221, slot, SP2_CI_ATTR_ACS,\r\nSP2_CI_WR, addr, data);\r\n}\r\nint sp2_ci_read_cam_control(struct dvb_ca_en50221 *en50221,\r\nint slot, u8 addr)\r\n{\r\nreturn sp2_ci_op_cam(en50221, slot, SP2_CI_IO_ACS,\r\nSP2_CI_RD, addr, 0);\r\n}\r\nint sp2_ci_write_cam_control(struct dvb_ca_en50221 *en50221,\r\nint slot, u8 addr, u8 data)\r\n{\r\nreturn sp2_ci_op_cam(en50221, slot, SP2_CI_IO_ACS,\r\nSP2_CI_WR, addr, data);\r\n}\r\nint sp2_ci_slot_reset(struct dvb_ca_en50221 *en50221, int slot)\r\n{\r\nstruct sp2 *s = en50221->data;\r\nu8 buf;\r\nint ret;\r\ndev_dbg(&s->client->dev, "slot: %d\n", slot);\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nbuf = SP2_MOD_CTL_RST;\r\nret = sp2_write_i2c(s, 0x00, &buf, 1);\r\nif (ret)\r\nreturn ret;\r\nusleep_range(500, 600);\r\nbuf = 0x00;\r\nret = sp2_write_i2c(s, 0x00, &buf, 1);\r\nif (ret)\r\nreturn ret;\r\nmsleep(1000);\r\nreturn 0;\r\n}\r\nint sp2_ci_slot_shutdown(struct dvb_ca_en50221 *en50221, int slot)\r\n{\r\nstruct sp2 *s = en50221->data;\r\ndev_dbg(&s->client->dev, "slot:%d\n", slot);\r\nreturn 0;\r\n}\r\nint sp2_ci_slot_ts_enable(struct dvb_ca_en50221 *en50221, int slot)\r\n{\r\nstruct sp2 *s = en50221->data;\r\nu8 buf;\r\ndev_dbg(&s->client->dev, "slot:%d\n", slot);\r\nif (slot != 0)\r\nreturn -EINVAL;\r\nsp2_read_i2c(s, 0x00, &buf, 1);\r\nbuf |= (SP2_MOD_CTL_TSOEN | SP2_MOD_CTL_TSIEN);\r\nreturn sp2_write_i2c(s, 0, &buf, 1);\r\n}\r\nint sp2_ci_poll_slot_status(struct dvb_ca_en50221 *en50221,\r\nint slot, int open)\r\n{\r\nstruct sp2 *s = en50221->data;\r\nu8 buf[2];\r\nint ret;\r\ndev_dbg(&s->client->dev, "slot:%d open:%d\n", slot, open);\r\nif (time_after(jiffies, s->next_status_checked_time)) {\r\nret = sp2_read_i2c(s, 0x00, buf, 1);\r\ns->next_status_checked_time = jiffies + msecs_to_jiffies(1000);\r\nif (ret)\r\nreturn 0;\r\nif (buf[0] & SP2_MOD_CTL_DET)\r\ns->status = DVB_CA_EN50221_POLL_CAM_PRESENT |\r\nDVB_CA_EN50221_POLL_CAM_READY;\r\nelse\r\ns->status = 0;\r\n}\r\nreturn s->status;\r\n}\r\nstatic int sp2_init(struct sp2 *s)\r\n{\r\nint ret = 0;\r\nu8 buf;\r\nu8 cimax_init[34] = {\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x44,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x44,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x02,\r\n0x01,\r\n0x00,\r\n0x00,\r\n0x00,\r\n0x05,\r\n0x00,\r\n0x04,\r\n0x00,\r\n0x22,\r\n0x00,\r\n};\r\ndev_dbg(&s->client->dev, "\n");\r\ns->ca.owner = THIS_MODULE;\r\ns->ca.read_attribute_mem = sp2_ci_read_attribute_mem;\r\ns->ca.write_attribute_mem = sp2_ci_write_attribute_mem;\r\ns->ca.read_cam_control = sp2_ci_read_cam_control;\r\ns->ca.write_cam_control = sp2_ci_write_cam_control;\r\ns->ca.slot_reset = sp2_ci_slot_reset;\r\ns->ca.slot_shutdown = sp2_ci_slot_shutdown;\r\ns->ca.slot_ts_enable = sp2_ci_slot_ts_enable;\r\ns->ca.poll_slot_status = sp2_ci_poll_slot_status;\r\ns->ca.data = s;\r\ns->module_access_type = 0;\r\nret = sp2_write_i2c(s, 0x00, &cimax_init[0], 34);\r\nif (ret)\r\ngoto err;\r\nbuf = 1;\r\nret = sp2_write_i2c(s, 0x1f, &buf, 1);\r\nif (ret)\r\ngoto err;\r\nret = sp2_write_i2c(s, 0x18, &buf, 1);\r\nif (ret)\r\ngoto err;\r\nret = dvb_ca_en50221_init(s->dvb_adap, &s->ca, 0, 1);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&s->client->dev, "init failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int sp2_exit(struct i2c_client *client)\r\n{\r\nstruct sp2 *s;\r\ndev_dbg(&client->dev, "\n");\r\nif (client == NULL)\r\nreturn 0;\r\ns = i2c_get_clientdata(client);\r\nif (s == NULL)\r\nreturn 0;\r\nif (s->ca.data == NULL)\r\nreturn 0;\r\ndvb_ca_en50221_release(&s->ca);\r\nreturn 0;\r\n}\r\nstatic int sp2_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct sp2_config *cfg = client->dev.platform_data;\r\nstruct sp2 *s;\r\nint ret;\r\ndev_dbg(&client->dev, "\n");\r\ns = kzalloc(sizeof(struct sp2), GFP_KERNEL);\r\nif (!s) {\r\nret = -ENOMEM;\r\ndev_err(&client->dev, "kzalloc() failed\n");\r\ngoto err;\r\n}\r\ns->client = client;\r\ns->dvb_adap = cfg->dvb_adap;\r\ns->priv = cfg->priv;\r\ns->ci_control = cfg->ci_control;\r\ni2c_set_clientdata(client, s);\r\nret = sp2_init(s);\r\nif (ret)\r\ngoto err;\r\ndev_info(&s->client->dev, "CIMaX SP2 successfully attached\n");\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "init failed=%d\n", ret);\r\nkfree(s);\r\nreturn ret;\r\n}\r\nstatic int sp2_remove(struct i2c_client *client)\r\n{\r\nstruct sp2 *s = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\nsp2_exit(client);\r\nif (s != NULL)\r\nkfree(s);\r\nreturn 0;\r\n}
