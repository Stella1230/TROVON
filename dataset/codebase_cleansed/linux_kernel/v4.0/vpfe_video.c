static struct media_entity *vpfe_get_input_entity\r\n(struct vpfe_video_device *video)\r\n{\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct media_pad *remote;\r\nremote = media_entity_remote_pad(&vpfe_dev->vpfe_isif.pads[0]);\r\nif (remote == NULL) {\r\npr_err("Invalid media connection to isif/ccdc\n");\r\nreturn NULL;\r\n}\r\nreturn remote->entity;\r\n}\r\nstatic int vpfe_update_current_ext_subdev(struct vpfe_video_device *video)\r\n{\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct vpfe_config *vpfe_cfg;\r\nstruct v4l2_subdev *subdev;\r\nstruct media_pad *remote;\r\nint i;\r\nremote = media_entity_remote_pad(&vpfe_dev->vpfe_isif.pads[0]);\r\nif (remote == NULL) {\r\npr_err("Invalid media connection to isif/ccdc\n");\r\nreturn -EINVAL;\r\n}\r\nsubdev = media_entity_to_v4l2_subdev(remote->entity);\r\nvpfe_cfg = vpfe_dev->pdev->platform_data;\r\nfor (i = 0; i < vpfe_cfg->num_subdevs; i++) {\r\nif (!strcmp(vpfe_cfg->sub_devs[i].module_name, subdev->name)) {\r\nvideo->current_ext_subdev = &vpfe_cfg->sub_devs[i];\r\nbreak;\r\n}\r\n}\r\nif (i == vpfe_cfg->num_subdevs) {\r\npr_err("Invalid media chain connection to isif/ccdc\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < vpfe_dev->num_ext_subdevs; i++) {\r\nif (!strcmp(video->current_ext_subdev->module_name,\r\nvpfe_dev->sd[i]->name))\r\nvideo->current_ext_subdev->subdev = vpfe_dev->sd[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic struct v4l2_subdev *\r\nvpfe_video_remote_subdev(struct vpfe_video_device *video, u32 *pad)\r\n{\r\nstruct media_pad *remote = media_entity_remote_pad(&video->pad);\r\nif (remote == NULL || remote->entity->type != MEDIA_ENT_T_V4L2_SUBDEV)\r\nreturn NULL;\r\nif (pad)\r\n*pad = remote->index;\r\nreturn media_entity_to_v4l2_subdev(remote->entity);\r\n}\r\nstatic int\r\n__vpfe_video_get_format(struct vpfe_video_device *video,\r\nstruct v4l2_format *format)\r\n{\r\nstruct v4l2_subdev_format fmt;\r\nstruct v4l2_subdev *subdev;\r\nstruct media_pad *remote;\r\nu32 pad;\r\nint ret;\r\nsubdev = vpfe_video_remote_subdev(video, &pad);\r\nif (subdev == NULL)\r\nreturn -EINVAL;\r\nfmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nremote = media_entity_remote_pad(&video->pad);\r\nfmt.pad = remote->index;\r\nret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);\r\nif (ret == -ENOIOCTLCMD)\r\nreturn -EINVAL;\r\nformat->type = video->type;\r\nv4l2_fill_pix_format(&format->fmt.pix, &fmt.format);\r\nmbus_to_pix(&fmt.format, &format->fmt.pix);\r\nreturn 0;\r\n}\r\nstatic void vpfe_prepare_pipeline(struct vpfe_video_device *video)\r\n{\r\nstruct media_entity *entity = &video->video_dev.entity;\r\nstruct media_device *mdev = entity->parent;\r\nstruct vpfe_pipeline *pipe = &video->pipe;\r\nstruct vpfe_video_device *far_end = NULL;\r\nstruct media_entity_graph graph;\r\npipe->input_num = 0;\r\npipe->output_num = 0;\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\npipe->inputs[pipe->input_num++] = video;\r\nelse\r\npipe->outputs[pipe->output_num++] = video;\r\nmutex_lock(&mdev->graph_mutex);\r\nmedia_entity_graph_walk_start(&graph, entity);\r\nwhile ((entity = media_entity_graph_walk_next(&graph))) {\r\nif (entity == &video->video_dev.entity)\r\ncontinue;\r\nif (media_entity_type(entity) != MEDIA_ENT_T_DEVNODE)\r\ncontinue;\r\nfar_end = to_vpfe_video(media_entity_to_video_device(entity));\r\nif (far_end->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\npipe->inputs[pipe->input_num++] = far_end;\r\nelse\r\npipe->outputs[pipe->output_num++] = far_end;\r\n}\r\nmutex_unlock(&mdev->graph_mutex);\r\n}\r\nstatic int vpfe_update_pipe_state(struct vpfe_video_device *video)\r\n{\r\nstruct vpfe_pipeline *pipe = &video->pipe;\r\nint ret;\r\nvpfe_prepare_pipeline(video);\r\nif (pipe->input_num == 0) {\r\npipe->state = VPFE_PIPELINE_STREAM_CONTINUOUS;\r\nret = vpfe_update_current_ext_subdev(video);\r\nif (ret) {\r\npr_err("Invalid external subdev\n");\r\nreturn ret;\r\n}\r\n} else {\r\npipe->state = VPFE_PIPELINE_STREAM_SINGLESHOT;\r\n}\r\nvideo->initialized = 1;\r\nvideo->skip_frame_count = 1;\r\nvideo->skip_frame_count_init = 1;\r\nreturn 0;\r\n}\r\nint vpfe_video_is_pipe_ready(struct vpfe_pipeline *pipe)\r\n{\r\nint i;\r\nfor (i = 0; i < pipe->input_num; i++)\r\nif (!pipe->inputs[i]->started ||\r\npipe->inputs[i]->state != VPFE_VIDEO_BUFFER_QUEUED)\r\nreturn 0;\r\nfor (i = 0; i < pipe->output_num; i++)\r\nif (!pipe->outputs[i]->started ||\r\npipe->outputs[i]->state != VPFE_VIDEO_BUFFER_QUEUED)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int vpfe_video_validate_pipeline(struct vpfe_pipeline *pipe)\r\n{\r\nstruct v4l2_subdev_format fmt_source;\r\nstruct v4l2_subdev_format fmt_sink;\r\nstruct v4l2_subdev *subdev;\r\nstruct media_pad *pad;\r\nint ret;\r\nsubdev = vpfe_video_remote_subdev(pipe->outputs[0], NULL);\r\nif (subdev == NULL)\r\nreturn -EPIPE;\r\nwhile (1) {\r\npad = &subdev->entity.pads[0];\r\nif (!(pad->flags & MEDIA_PAD_FL_SINK))\r\nbreak;\r\nfmt_sink.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nfmt_sink.pad = pad->index;\r\nret = v4l2_subdev_call(subdev, pad, get_fmt, NULL,\r\n&fmt_sink);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn -EPIPE;\r\npad = media_entity_remote_pad(pad);\r\nif (pad == NULL ||\r\npad->entity->type != MEDIA_ENT_T_V4L2_SUBDEV)\r\nbreak;\r\nsubdev = media_entity_to_v4l2_subdev(pad->entity);\r\nfmt_source.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nfmt_source.pad = pad->index;\r\nret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt_source);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn -EPIPE;\r\nif (fmt_source.format.code != fmt_sink.format.code ||\r\nfmt_source.format.width != fmt_sink.format.width ||\r\nfmt_source.format.height != fmt_sink.format.height)\r\nreturn -EPIPE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpfe_pipeline_enable(struct vpfe_pipeline *pipe)\r\n{\r\nstruct media_entity_graph graph;\r\nstruct media_entity *entity;\r\nstruct v4l2_subdev *subdev;\r\nstruct media_device *mdev;\r\nint ret = 0;\r\nif (pipe->state == VPFE_PIPELINE_STREAM_CONTINUOUS)\r\nentity = vpfe_get_input_entity(pipe->outputs[0]);\r\nelse\r\nentity = &pipe->inputs[0]->video_dev.entity;\r\nmdev = entity->parent;\r\nmutex_lock(&mdev->graph_mutex);\r\nmedia_entity_graph_walk_start(&graph, entity);\r\nwhile ((entity = media_entity_graph_walk_next(&graph))) {\r\nif (media_entity_type(entity) == MEDIA_ENT_T_DEVNODE)\r\ncontinue;\r\nsubdev = media_entity_to_v4l2_subdev(entity);\r\nret = v4l2_subdev_call(subdev, video, s_stream, 1);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nbreak;\r\n}\r\nmutex_unlock(&mdev->graph_mutex);\r\nreturn ret;\r\n}\r\nstatic int vpfe_pipeline_disable(struct vpfe_pipeline *pipe)\r\n{\r\nstruct media_entity_graph graph;\r\nstruct media_entity *entity;\r\nstruct v4l2_subdev *subdev;\r\nstruct media_device *mdev;\r\nint ret = 0;\r\nif (pipe->state == VPFE_PIPELINE_STREAM_CONTINUOUS)\r\nentity = vpfe_get_input_entity(pipe->outputs[0]);\r\nelse\r\nentity = &pipe->inputs[0]->video_dev.entity;\r\nmdev = entity->parent;\r\nmutex_lock(&mdev->graph_mutex);\r\nmedia_entity_graph_walk_start(&graph, entity);\r\nwhile ((entity = media_entity_graph_walk_next(&graph))) {\r\nif (media_entity_type(entity) == MEDIA_ENT_T_DEVNODE)\r\ncontinue;\r\nsubdev = media_entity_to_v4l2_subdev(entity);\r\nret = v4l2_subdev_call(subdev, video, s_stream, 0);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nbreak;\r\n}\r\nmutex_unlock(&mdev->graph_mutex);\r\nreturn ret ? -ETIMEDOUT : 0;\r\n}\r\nstatic int vpfe_pipeline_set_stream(struct vpfe_pipeline *pipe,\r\nenum vpfe_pipeline_stream_state state)\r\n{\r\nif (state == VPFE_PIPELINE_STREAM_STOPPED)\r\nreturn vpfe_pipeline_disable(pipe);\r\nreturn vpfe_pipeline_enable(pipe);\r\n}\r\nstatic int all_videos_stopped(struct vpfe_video_device *video)\r\n{\r\nstruct vpfe_pipeline *pipe = &video->pipe;\r\nint i;\r\nfor (i = 0; i < pipe->input_num; i++)\r\nif (pipe->inputs[i]->started)\r\nreturn 0;\r\nfor (i = 0; i < pipe->output_num; i++)\r\nif (pipe->outputs[i]->started)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int vpfe_open(struct file *file)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_fh *handle;\r\nhandle = kzalloc(sizeof(struct vpfe_fh), GFP_KERNEL);\r\nif (handle == NULL)\r\nreturn -ENOMEM;\r\nv4l2_fh_init(&handle->vfh, &video->video_dev);\r\nv4l2_fh_add(&handle->vfh);\r\nmutex_lock(&video->lock);\r\nif (!video->initialized && vpfe_update_pipe_state(video)) {\r\nmutex_unlock(&video->lock);\r\nreturn -ENODEV;\r\n}\r\nvideo->usrs++;\r\nhandle->io_allowed = 0;\r\nhandle->video = video;\r\nfile->private_data = &handle->vfh;\r\nmutex_unlock(&video->lock);\r\nreturn 0;\r\n}\r\nstatic unsigned long\r\nvpfe_video_get_next_buffer(struct vpfe_video_device *video)\r\n{\r\nvideo->cur_frm = video->next_frm =\r\nlist_entry(video->dma_queue.next,\r\nstruct vpfe_cap_buffer, list);\r\nlist_del(&video->next_frm->list);\r\nvideo->next_frm->vb.state = VB2_BUF_STATE_ACTIVE;\r\nreturn vb2_dma_contig_plane_dma_addr(&video->next_frm->vb, 0);\r\n}\r\nvoid vpfe_video_schedule_next_buffer(struct vpfe_video_device *video)\r\n{\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nunsigned long addr;\r\nif (list_empty(&video->dma_queue))\r\nreturn;\r\nvideo->next_frm = list_entry(video->dma_queue.next,\r\nstruct vpfe_cap_buffer, list);\r\nif (VPFE_PIPELINE_STREAM_SINGLESHOT == video->pipe.state)\r\nvideo->cur_frm = video->next_frm;\r\nlist_del(&video->next_frm->list);\r\nvideo->next_frm->vb.state = VB2_BUF_STATE_ACTIVE;\r\naddr = vb2_dma_contig_plane_dma_addr(&video->next_frm->vb, 0);\r\nvideo->ops->queue(vpfe_dev, addr);\r\nvideo->state = VPFE_VIDEO_BUFFER_QUEUED;\r\n}\r\nvoid vpfe_video_schedule_bottom_field(struct vpfe_video_device *video)\r\n{\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nunsigned long addr;\r\naddr = vb2_dma_contig_plane_dma_addr(&video->cur_frm->vb, 0);\r\naddr += video->field_off;\r\nvideo->ops->queue(vpfe_dev, addr);\r\n}\r\nvoid vpfe_video_process_buffer_complete(struct vpfe_video_device *video)\r\n{\r\nstruct vpfe_pipeline *pipe = &video->pipe;\r\ndo_gettimeofday(&video->cur_frm->vb.v4l2_buf.timestamp);\r\nvb2_buffer_done(&video->cur_frm->vb, VB2_BUF_STATE_DONE);\r\nif (pipe->state == VPFE_PIPELINE_STREAM_CONTINUOUS)\r\nvideo->cur_frm = video->next_frm;\r\n}\r\nstatic void vpfe_stop_capture(struct vpfe_video_device *video)\r\n{\r\nstruct vpfe_pipeline *pipe = &video->pipe;\r\nvideo->started = 0;\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn;\r\nif (all_videos_stopped(video))\r\nvpfe_pipeline_set_stream(pipe,\r\nVPFE_PIPELINE_STREAM_STOPPED);\r\n}\r\nstatic int vpfe_release(struct file *file)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct v4l2_fh *vfh = file->private_data;\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct vpfe_fh *fh = container_of(vfh, struct vpfe_fh, vfh);\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_release\n");\r\nmutex_lock(&video->lock);\r\nif (fh->io_allowed) {\r\nif (video->started) {\r\nvpfe_stop_capture(video);\r\nvideo->pipe.state = VPFE_PIPELINE_STREAM_STOPPED;\r\nvb2_streamoff(&video->buffer_queue,\r\nvideo->buffer_queue.type);\r\n}\r\nvideo->io_usrs = 0;\r\nvb2_queue_release(&video->buffer_queue);\r\nvb2_dma_contig_cleanup_ctx(video->alloc_ctx);\r\n}\r\nvideo->usrs--;\r\nv4l2_fh_del(&fh->vfh);\r\nv4l2_fh_exit(&fh->vfh);\r\nif (!video->usrs)\r\nvideo->initialized = 0;\r\nmutex_unlock(&video->lock);\r\nfile->private_data = NULL;\r\nv4l2_fh_del(vfh);\r\nkzfree(fh);\r\nreturn 0;\r\n}\r\nstatic int vpfe_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_mmap\n");\r\nreturn vb2_mmap(&video->buffer_queue, vma);\r\n}\r\nstatic unsigned int vpfe_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_poll\n");\r\nif (video->started)\r\nreturn vb2_poll(&video->buffer_queue, file, wait);\r\nreturn 0;\r\n}\r\nstatic int vpfe_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_querycap\n");\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\nelse\r\ncap->device_caps = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT |\r\nV4L2_CAP_STREAMING | V4L2_CAP_DEVICE_CAPS;\r\nstrlcpy(cap->driver, CAPTURE_DRV_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->bus_info, "VPFE", sizeof(cap->bus_info));\r\nstrlcpy(cap->card, vpfe_dev->cfg->card_name, sizeof(cap->card));\r\nreturn 0;\r\n}\r\nstatic int vpfe_g_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_g_fmt\n");\r\n*fmt = video->fmt;\r\nreturn 0;\r\n}\r\nstatic int vpfe_enum_fmt(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct v4l2_subdev_format sd_fmt;\r\nstruct v4l2_mbus_framefmt mbus;\r\nstruct v4l2_subdev *subdev;\r\nstruct v4l2_format format;\r\nstruct media_pad *remote;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_enum_fmt\n");\r\nif (fmt->index > 0) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Invalid index\n");\r\nreturn -EINVAL;\r\n}\r\nremote = media_entity_remote_pad(&video->pad);\r\nif (remote == NULL) {\r\nv4l2_err(&vpfe_dev->v4l2_dev,\r\n"invalid remote pad for video node\n");\r\nreturn -EINVAL;\r\n}\r\nsubdev = vpfe_video_remote_subdev(video, NULL);\r\nif (subdev == NULL) {\r\nv4l2_err(&vpfe_dev->v4l2_dev,\r\n"invalid remote subdev for video node\n");\r\nreturn -EINVAL;\r\n}\r\nsd_fmt.pad = remote->index;\r\nsd_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &sd_fmt);\r\nif (ret) {\r\nv4l2_err(&vpfe_dev->v4l2_dev,\r\n"invalid remote subdev for video node\n");\r\nreturn ret;\r\n}\r\nmbus.code = sd_fmt.format.code;\r\nmbus_to_pix(&mbus, &format.fmt.pix);\r\nfmt->pixelformat = format.fmt.pix.pixelformat;\r\nreturn 0;\r\n}\r\nstatic int vpfe_s_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct v4l2_format format;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_s_fmt\n");\r\nif (video->started) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Streaming is started\n");\r\nreturn -EBUSY;\r\n}\r\nret = __vpfe_video_get_format(video, &format);\r\nif (ret)\r\nreturn ret;\r\n*fmt = format;\r\nvideo->fmt = *fmt;\r\nreturn 0;\r\n}\r\nstatic int vpfe_try_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct v4l2_format format;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_try_fmt\n");\r\nret = __vpfe_video_get_format(video, &format);\r\nif (ret)\r\nreturn ret;\r\n*fmt = format;\r\nreturn 0;\r\n}\r\nstatic int vpfe_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *inp)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_ext_subdev_info *sdinfo = video->current_ext_subdev;\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_enum_input\n");\r\nif (inp->index < sdinfo->num_inputs) {\r\nmemcpy(inp, &sdinfo->inputs[inp->index],\r\nsizeof(struct v4l2_input));\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vpfe_g_input(struct file *file, void *priv, unsigned int *index)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_g_input\n");\r\n*index = video->current_input;\r\nreturn 0;\r\n}\r\nstatic int vpfe_s_input(struct file *file, void *priv, unsigned int index)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct vpfe_ext_subdev_info *sdinfo;\r\nstruct vpfe_route *route;\r\nstruct v4l2_input *inps;\r\nu32 output;\r\nu32 input;\r\nint ret;\r\nint i;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_s_input\n");\r\nret = mutex_lock_interruptible(&video->lock);\r\nif (ret)\r\nreturn ret;\r\nif (video->started) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Streaming is on\n");\r\nret = -EBUSY;\r\ngoto unlock_out;\r\n}\r\nsdinfo = video->current_ext_subdev;\r\nif (!sdinfo->registered) {\r\nret = -EINVAL;\r\ngoto unlock_out;\r\n}\r\nif (vpfe_dev->cfg->setup_input &&\r\nvpfe_dev->cfg->setup_input(sdinfo->grp_id) < 0) {\r\nret = -EFAULT;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,\r\n"couldn't setup input for %s\n",\r\nsdinfo->module_name);\r\ngoto unlock_out;\r\n}\r\nroute = &sdinfo->routes[index];\r\nif (route && sdinfo->can_route) {\r\ninput = route->input;\r\noutput = route->output;\r\nret = v4l2_device_call_until_err(&vpfe_dev->v4l2_dev,\r\nsdinfo->grp_id, video,\r\ns_routing, input, output, 0);\r\nif (ret) {\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,\r\n"s_input:error in setting input in decoder\n");\r\nret = -EINVAL;\r\ngoto unlock_out;\r\n}\r\n}\r\nfor (i = 0; i < sdinfo->num_inputs; i++) {\r\ninps = &sdinfo->inputs[i];\r\nvideo->video_dev.tvnorms |= inps->std;\r\n}\r\nvideo->current_input = index;\r\nunlock_out:\r\nmutex_unlock(&video->lock);\r\nreturn ret;\r\n}\r\nstatic int vpfe_querystd(struct file *file, void *priv, v4l2_std_id *std_id)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct vpfe_ext_subdev_info *sdinfo;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_querystd\n");\r\nret = mutex_lock_interruptible(&video->lock);\r\nsdinfo = video->current_ext_subdev;\r\nif (ret)\r\nreturn ret;\r\nret = v4l2_device_call_until_err(&vpfe_dev->v4l2_dev, sdinfo->grp_id,\r\nvideo, querystd, std_id);\r\nmutex_unlock(&video->lock);\r\nreturn ret;\r\n}\r\nstatic int vpfe_s_std(struct file *file, void *priv, v4l2_std_id std_id)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct vpfe_ext_subdev_info *sdinfo;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_s_std\n");\r\nret = mutex_lock_interruptible(&video->lock);\r\nif (ret)\r\nreturn ret;\r\nsdinfo = video->current_ext_subdev;\r\nif (video->started) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "streaming is started\n");\r\nret = -EBUSY;\r\ngoto unlock_out;\r\n}\r\nret = v4l2_device_call_until_err(&vpfe_dev->v4l2_dev, sdinfo->grp_id,\r\nvideo, s_std, std_id);\r\nif (ret < 0) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Failed to set standard\n");\r\nvideo->stdid = V4L2_STD_UNKNOWN;\r\ngoto unlock_out;\r\n}\r\nvideo->stdid = std_id;\r\nunlock_out:\r\nmutex_unlock(&video->lock);\r\nreturn ret;\r\n}\r\nstatic int vpfe_g_std(struct file *file, void *priv, v4l2_std_id *tvnorm)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_g_std\n");\r\n*tvnorm = video->stdid;\r\nreturn 0;\r\n}\r\nstatic int\r\nvpfe_enum_dv_timings(struct file *file, void *fh,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct v4l2_subdev *subdev = video->current_ext_subdev->subdev;\r\ntimings->pad = 0;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_enum_dv_timings\n");\r\nreturn v4l2_subdev_call(subdev, pad, enum_dv_timings, timings);\r\n}\r\nstatic int\r\nvpfe_query_dv_timings(struct file *file, void *fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct v4l2_subdev *subdev = video->current_ext_subdev->subdev;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_query_dv_timings\n");\r\nreturn v4l2_subdev_call(subdev, video, query_dv_timings, timings);\r\n}\r\nstatic int\r\nvpfe_s_dv_timings(struct file *file, void *fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_s_dv_timings\n");\r\nvideo->stdid = V4L2_STD_UNKNOWN;\r\nreturn v4l2_device_call_until_err(&vpfe_dev->v4l2_dev,\r\nvideo->current_ext_subdev->grp_id,\r\nvideo, s_dv_timings, timings);\r\n}\r\nstatic int\r\nvpfe_g_dv_timings(struct file *file, void *fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct v4l2_subdev *subdev = video->current_ext_subdev->subdev;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_g_dv_timings\n");\r\nreturn v4l2_subdev_call(subdev, video, g_dv_timings, timings);\r\n}\r\nstatic int\r\nvpfe_buffer_queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct vpfe_fh *fh = vb2_get_drv_priv(vq);\r\nstruct vpfe_video_device *video = fh->video;\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct vpfe_pipeline *pipe = &video->pipe;\r\nunsigned long size;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_buffer_queue_setup\n");\r\nsize = video->fmt.fmt.pix.sizeimage;\r\nif (vpfe_dev->video_limit) {\r\nwhile (size * *nbuffers > vpfe_dev->video_limit)\r\n(*nbuffers)--;\r\n}\r\nif (pipe->state == VPFE_PIPELINE_STREAM_CONTINUOUS) {\r\nif (*nbuffers < MIN_NUM_BUFFERS)\r\n*nbuffers = MIN_NUM_BUFFERS;\r\n}\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nalloc_ctxs[0] = video->alloc_ctx;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev,\r\n"nbuffers=%d, size=%lu\n", *nbuffers, size);\r\nreturn 0;\r\n}\r\nstatic int vpfe_buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vpfe_fh *fh = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vpfe_video_device *video = fh->video;\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nunsigned long addr;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_buffer_prepare\n");\r\nif (vb->state != VB2_BUF_STATE_ACTIVE &&\r\nvb->state != VB2_BUF_STATE_PREPARED)\r\nreturn 0;\r\nvb2_set_plane_payload(vb, 0, video->fmt.fmt.pix.sizeimage);\r\nif (vb2_plane_vaddr(vb, 0) &&\r\nvb2_get_plane_payload(vb, 0) > vb2_plane_size(vb, 0))\r\nreturn -EINVAL;\r\naddr = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nif (!ALIGN(addr, 32))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void vpfe_buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vpfe_fh *fh = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vpfe_video_device *video = fh->video;\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct vpfe_pipeline *pipe = &video->pipe;\r\nstruct vpfe_cap_buffer *buf = container_of(vb,\r\nstruct vpfe_cap_buffer, vb);\r\nunsigned long flags;\r\nunsigned long empty;\r\nunsigned long addr;\r\nspin_lock_irqsave(&video->dma_queue_lock, flags);\r\nempty = list_empty(&video->dma_queue);\r\nlist_add_tail(&buf->list, &video->dma_queue);\r\nspin_unlock_irqrestore(&video->dma_queue_lock, flags);\r\nif (empty && video->started && pipe->state ==\r\nVPFE_PIPELINE_STREAM_SINGLESHOT &&\r\nvideo->state == VPFE_VIDEO_BUFFER_NOT_QUEUED) {\r\nspin_lock(&video->dma_queue_lock);\r\naddr = vpfe_video_get_next_buffer(video);\r\nvideo->ops->queue(vpfe_dev, addr);\r\nvideo->state = VPFE_VIDEO_BUFFER_QUEUED;\r\nspin_unlock(&video->dma_queue_lock);\r\nif (vpfe_video_is_pipe_ready(pipe))\r\nvpfe_pipeline_set_stream(pipe,\r\nVPFE_PIPELINE_STREAM_SINGLESHOT);\r\n}\r\n}\r\nstatic int vpfe_start_capture(struct vpfe_video_device *video)\r\n{\r\nstruct vpfe_pipeline *pipe = &video->pipe;\r\nint ret = 0;\r\nvideo->started = 1;\r\nif (vpfe_video_is_pipe_ready(pipe))\r\nret = vpfe_pipeline_set_stream(pipe, pipe->state);\r\nreturn ret;\r\n}\r\nstatic int vpfe_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct vpfe_fh *fh = vb2_get_drv_priv(vq);\r\nstruct vpfe_video_device *video = fh->video;\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nunsigned long addr;\r\nint ret;\r\nret = mutex_lock_interruptible(&video->lock);\r\nif (ret)\r\ngoto streamoff;\r\nvideo->cur_frm = video->next_frm =\r\nlist_entry(video->dma_queue.next, struct vpfe_cap_buffer, list);\r\nlist_del(&video->cur_frm->list);\r\nvideo->cur_frm->vb.state = VB2_BUF_STATE_ACTIVE;\r\nvideo->field_id = 0;\r\naddr = vb2_dma_contig_plane_dma_addr(&video->cur_frm->vb, 0);\r\nvideo->ops->queue(vpfe_dev, addr);\r\nvideo->state = VPFE_VIDEO_BUFFER_QUEUED;\r\nret = vpfe_start_capture(video);\r\nif (ret) {\r\nstruct vpfe_cap_buffer *buf, *tmp;\r\nvb2_buffer_done(&video->cur_frm->vb, VB2_BUF_STATE_QUEUED);\r\nlist_for_each_entry_safe(buf, tmp, &video->dma_queue, list) {\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_QUEUED);\r\n}\r\ngoto unlock_out;\r\n}\r\nmutex_unlock(&video->lock);\r\nreturn ret;\r\nunlock_out:\r\nmutex_unlock(&video->lock);\r\nstreamoff:\r\nret = vb2_streamoff(&video->buffer_queue, video->buffer_queue.type);\r\nreturn 0;\r\n}\r\nstatic int vpfe_buffer_init(struct vb2_buffer *vb)\r\n{\r\nstruct vpfe_cap_buffer *buf = container_of(vb,\r\nstruct vpfe_cap_buffer, vb);\r\nINIT_LIST_HEAD(&buf->list);\r\nreturn 0;\r\n}\r\nstatic void vpfe_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct vpfe_fh *fh = vb2_get_drv_priv(vq);\r\nstruct vpfe_video_device *video = fh->video;\r\nif (video->cur_frm == video->next_frm) {\r\nvb2_buffer_done(&video->cur_frm->vb, VB2_BUF_STATE_ERROR);\r\n} else {\r\nif (video->cur_frm != NULL)\r\nvb2_buffer_done(&video->cur_frm->vb,\r\nVB2_BUF_STATE_ERROR);\r\nif (video->next_frm != NULL)\r\nvb2_buffer_done(&video->next_frm->vb,\r\nVB2_BUF_STATE_ERROR);\r\n}\r\nwhile (!list_empty(&video->dma_queue)) {\r\nvideo->next_frm = list_entry(video->dma_queue.next,\r\nstruct vpfe_cap_buffer, list);\r\nlist_del(&video->next_frm->list);\r\nvb2_buffer_done(&video->next_frm->vb, VB2_BUF_STATE_ERROR);\r\n}\r\n}\r\nstatic void vpfe_buf_cleanup(struct vb2_buffer *vb)\r\n{\r\nstruct vpfe_fh *fh = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vpfe_video_device *video = fh->video;\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct vpfe_cap_buffer *buf = container_of(vb,\r\nstruct vpfe_cap_buffer, vb);\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_buf_cleanup\n");\r\nif (vb->state == VB2_BUF_STATE_ACTIVE)\r\nlist_del_init(&buf->list);\r\n}\r\nstatic int vpfe_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *req_buf)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct vpfe_fh *fh = file->private_data;\r\nstruct vb2_queue *q;\r\nint ret;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_reqbufs\n");\r\nif (V4L2_BUF_TYPE_VIDEO_CAPTURE != req_buf->type &&\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT != req_buf->type) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Invalid buffer type\n");\r\nreturn -EINVAL;\r\n}\r\nret = mutex_lock_interruptible(&video->lock);\r\nif (ret)\r\nreturn ret;\r\nif (video->io_usrs != 0) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Only one IO user allowed\n");\r\nret = -EBUSY;\r\ngoto unlock_out;\r\n}\r\nvideo->memory = req_buf->memory;\r\nvideo->alloc_ctx = vb2_dma_contig_init_ctx(vpfe_dev->pdev);\r\nif (IS_ERR(video->alloc_ctx)) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Failed to get the context\n");\r\nreturn PTR_ERR(video->alloc_ctx);\r\n}\r\nq = &video->buffer_queue;\r\nq->type = req_buf->type;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR;\r\nq->drv_priv = fh;\r\nq->min_buffers_needed = 1;\r\nq->ops = &video_qops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->buf_struct_size = sizeof(struct vpfe_cap_buffer);\r\nret = vb2_queue_init(q);\r\nif (ret) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "vb2_queue_init() failed\n");\r\nvb2_dma_contig_cleanup_ctx(vpfe_dev->pdev);\r\nreturn ret;\r\n}\r\nfh->io_allowed = 1;\r\nvideo->io_usrs = 1;\r\nINIT_LIST_HEAD(&video->dma_queue);\r\nret = vb2_reqbufs(&video->buffer_queue, req_buf);\r\nunlock_out:\r\nmutex_unlock(&video->lock);\r\nreturn ret;\r\n}\r\nstatic int vpfe_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_querybuf\n");\r\nif (V4L2_BUF_TYPE_VIDEO_CAPTURE != buf->type &&\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT != buf->type) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Invalid buf type\n");\r\nreturn -EINVAL;\r\n}\r\nif (video->memory != V4L2_MEMORY_MMAP) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Invalid memory\n");\r\nreturn -EINVAL;\r\n}\r\nreturn vb2_querybuf(&video->buffer_queue, buf);\r\n}\r\nstatic int vpfe_qbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *p)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct vpfe_fh *fh = file->private_data;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_qbuf\n");\r\nif (V4L2_BUF_TYPE_VIDEO_CAPTURE != p->type &&\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT != p->type) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Invalid buf type\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fh->io_allowed) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "fh->io_allowed\n");\r\nreturn -EACCES;\r\n}\r\nreturn vb2_qbuf(&video->buffer_queue, p);\r\n}\r\nstatic int vpfe_dqbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_dqbuf\n");\r\nif (V4L2_BUF_TYPE_VIDEO_CAPTURE != buf->type &&\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT != buf->type) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Invalid buf type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn vb2_dqbuf(&video->buffer_queue,\r\nbuf, (file->f_flags & O_NONBLOCK));\r\n}\r\nstatic int vpfe_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type buf_type)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct vpfe_pipeline *pipe = &video->pipe;\r\nstruct vpfe_fh *fh = file->private_data;\r\nstruct vpfe_ext_subdev_info *sdinfo;\r\nint ret = -EINVAL;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_streamon\n");\r\nif (V4L2_BUF_TYPE_VIDEO_CAPTURE != buf_type &&\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT != buf_type) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "Invalid buf type\n");\r\nreturn ret;\r\n}\r\nif (!fh->io_allowed) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "fh->io_allowed\n");\r\nreturn -EACCES;\r\n}\r\nsdinfo = video->current_ext_subdev;\r\nif (list_empty(&video->buffer_queue.queued_list)) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "buffer queue is empty\n");\r\nreturn -EIO;\r\n}\r\nif (V4L2_BUF_TYPE_VIDEO_CAPTURE == buf_type) {\r\nret = vpfe_video_validate_pipeline(pipe);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn vb2_streamon(&video->buffer_queue, buf_type);\r\n}\r\nstatic int vpfe_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type buf_type)\r\n{\r\nstruct vpfe_video_device *video = video_drvdata(file);\r\nstruct vpfe_device *vpfe_dev = video->vpfe_dev;\r\nstruct vpfe_fh *fh = file->private_data;\r\nint ret = 0;\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "vpfe_streamoff\n");\r\nif (buf_type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\nbuf_type != V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "Invalid buf type\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fh->io_allowed) {\r\nv4l2_dbg(1, debug, &vpfe_dev->v4l2_dev, "fh->io_allowed\n");\r\nreturn -EACCES;\r\n}\r\nif (!video->started) {\r\nv4l2_err(&vpfe_dev->v4l2_dev, "device is not started\n");\r\nreturn -EINVAL;\r\n}\r\nret = mutex_lock_interruptible(&video->lock);\r\nif (ret)\r\nreturn ret;\r\nvpfe_stop_capture(video);\r\nret = vb2_streamoff(&video->buffer_queue, buf_type);\r\nmutex_unlock(&video->lock);\r\nreturn ret;\r\n}\r\nint vpfe_video_init(struct vpfe_video_device *video, const char *name)\r\n{\r\nconst char *direction;\r\nint ret;\r\nswitch (video->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\ndirection = "output";\r\nvideo->pad.flags = MEDIA_PAD_FL_SINK;\r\nvideo->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\ndirection = "input";\r\nvideo->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nvideo->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nvideo->video_dev.release = video_device_release;\r\nvideo->video_dev.fops = &vpfe_fops;\r\nvideo->video_dev.ioctl_ops = &vpfe_ioctl_ops;\r\nvideo->video_dev.minor = -1;\r\nvideo->video_dev.tvnorms = 0;\r\nsnprintf(video->video_dev.name, sizeof(video->video_dev.name),\r\n"DAVINCI VIDEO %s %s", name, direction);\r\nspin_lock_init(&video->irqlock);\r\nspin_lock_init(&video->dma_queue_lock);\r\nmutex_init(&video->lock);\r\nret = media_entity_init(&video->video_dev.entity,\r\n1, &video->pad, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nvideo_set_drvdata(&video->video_dev, video);\r\nreturn 0;\r\n}\r\nint vpfe_video_register(struct vpfe_video_device *video,\r\nstruct v4l2_device *vdev)\r\n{\r\nint ret;\r\nvideo->video_dev.v4l2_dev = vdev;\r\nret = video_register_device(&video->video_dev, VFL_TYPE_GRABBER, -1);\r\nif (ret < 0)\r\npr_err("%s: could not register video device (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nvoid vpfe_video_unregister(struct vpfe_video_device *video)\r\n{\r\nif (video_is_registered(&video->video_dev)) {\r\nvideo_unregister_device(&video->video_dev);\r\nmedia_entity_cleanup(&video->video_dev.entity);\r\n}\r\n}
