static void isram_write(const void *addr, uint64_t data)\r\n{\r\nuint32_t cmd;\r\nunsigned long flags;\r\nif (unlikely(addr >= (void *)(L1_CODE_START + L1_CODE_LENGTH)))\r\nreturn;\r\ncmd = IADDR2DTEST(addr) | 2;\r\nspin_lock_irqsave(&dtest_lock, flags);\r\nbfin_write_DTEST_DATA0(data & 0xFFFFFFFF);\r\nbfin_write_DTEST_DATA1(data >> 32);\r\n__builtin_bfin_csync();\r\nbfin_write_DTEST_COMMAND(cmd);\r\n__builtin_bfin_csync();\r\nbfin_write_DTEST_COMMAND(0);\r\n__builtin_bfin_csync();\r\nspin_unlock_irqrestore(&dtest_lock, flags);\r\n}\r\nstatic uint64_t isram_read(const void *addr)\r\n{\r\nuint32_t cmd;\r\nunsigned long flags;\r\nuint64_t ret;\r\nif (unlikely(addr > (void *)(L1_CODE_START + L1_CODE_LENGTH)))\r\nreturn 0;\r\ncmd = IADDR2DTEST(addr) | 0;\r\nspin_lock_irqsave(&dtest_lock, flags);\r\n__builtin_bfin_csync();\r\nbfin_write_DTEST_COMMAND(cmd);\r\n__builtin_bfin_csync();\r\nret = bfin_read_DTEST_DATA0() | ((uint64_t)bfin_read_DTEST_DATA1() << 32);\r\nbfin_write_DTEST_COMMAND(0);\r\n__builtin_bfin_csync();\r\nspin_unlock_irqrestore(&dtest_lock, flags);\r\nreturn ret;\r\n}\r\nstatic bool isram_check_addr(const void *addr, size_t n)\r\n{\r\nif ((addr >= (void *)L1_CODE_START) &&\r\n(addr < (void *)(L1_CODE_START + L1_CODE_LENGTH))) {\r\nif (unlikely((addr + n) > (void *)(L1_CODE_START + L1_CODE_LENGTH))) {\r\nshow_stack(NULL, NULL);\r\npr_err("copy involving %p length (%zu) too long\n", addr, n);\r\n}\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid *isram_memcpy(void *dest, const void *src, size_t n)\r\n{\r\nuint64_t data_in = 0, data_out = 0;\r\nsize_t count;\r\nbool dest_in_l1, src_in_l1, need_data, put_data;\r\nunsigned char byte, *src_byte, *dest_byte;\r\nsrc_byte = (unsigned char *)src;\r\ndest_byte = (unsigned char *)dest;\r\ndest_in_l1 = isram_check_addr(dest, n);\r\nsrc_in_l1 = isram_check_addr(src, n);\r\nneed_data = true;\r\nput_data = true;\r\nfor (count = 0; count < n; count++) {\r\nif (src_in_l1) {\r\nif (need_data) {\r\ndata_in = isram_read(src + count);\r\nneed_data = false;\r\n}\r\nif (ADDR2LAST(src + count))\r\nneed_data = true;\r\nbyte = (unsigned char)((data_in >> ADDR2OFFSET(src + count)) & 0xff);\r\n} else {\r\nbyte = src_byte[count];\r\n}\r\nif (dest_in_l1) {\r\nif (put_data) {\r\ndata_out = isram_read(dest + count);\r\nput_data = false;\r\n}\r\ndata_out &= ~((uint64_t)0xff << ADDR2OFFSET(dest + count));\r\ndata_out |= ((uint64_t)byte << ADDR2OFFSET(dest + count));\r\nif (ADDR2LAST(dest + count)) {\r\nput_data = true;\r\nisram_write(dest + count, data_out);\r\n}\r\n} else {\r\ndest_byte[count] = byte;\r\n}\r\n}\r\nif (dest_in_l1 && !put_data)\r\nisram_write(dest + count, data_out);\r\nreturn dest;\r\n}\r\nstatic __init void hex_dump(unsigned char *buf, int len)\r\n{\r\nwhile (len--)\r\npr_cont("%02x", *buf++);\r\n}\r\nstatic __init int isram_read_test(char *sdram, void *l1inst)\r\n{\r\nint i, ret = 0;\r\nuint64_t data1, data2;\r\npr_info("INFO: running isram_read tests\n");\r\nfor (i = 0; i < test_len; ++i)\r\nsdram[i] = i % 255;\r\ndma_memcpy(l1inst, sdram, test_len);\r\nfor (i = 0; i < test_len; i += sizeof(uint64_t)) {\r\ndata1 = isram_read(l1inst + i);\r\nmemcpy(&data2, sdram + i, sizeof(data2));\r\nif (data1 != data2) {\r\npr_err("FAIL: isram_read(%p) returned %#llx but wanted %#llx\n",\r\nl1inst + i, data1, data2);\r\n++ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic __init int isram_write_test(char *sdram, void *l1inst)\r\n{\r\nint i, ret = 0;\r\nuint64_t data1, data2;\r\npr_info("INFO: running isram_write tests\n");\r\nmemset(sdram, 0, test_len * 2);\r\ndma_memcpy(l1inst, sdram, test_len);\r\nfor (i = 0; i < test_len; ++i)\r\nsdram[i] = i % 255;\r\nfor (i = 0; i < test_len; i += sizeof(uint64_t)) {\r\nmemcpy(&data1, sdram + i, sizeof(data1));\r\nisram_write(l1inst + i, data1);\r\ndata2 = isram_read(l1inst + i);\r\nif (data1 != data2) {\r\npr_err("FAIL: isram_write(%p, %#llx) != %#llx\n",\r\nl1inst + i, data1, data2);\r\n++ret;\r\n}\r\n}\r\ndma_memcpy(sdram + test_len, l1inst, test_len);\r\nif (memcmp(sdram, sdram + test_len, test_len)) {\r\npr_err("FAIL: isram_write() did not work properly\n");\r\n++ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic __init int\r\n_isram_memcpy_test(char pattern, void *sdram, void *l1inst, const char *smemcpy,\r\nvoid *(*fmemcpy)(void *, const void *, size_t))\r\n{\r\nmemset(sdram, pattern, test_len);\r\nfmemcpy(l1inst, sdram, test_len);\r\nfmemcpy(sdram + test_len, l1inst, test_len);\r\nif (memcmp(sdram, sdram + test_len, test_len)) {\r\npr_err("FAIL: %s(%p <=> %p, %#x) failed (data is %#x)\n",\r\nsmemcpy, l1inst, sdram, test_len, pattern);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic __init int isram_memcpy_test(char *sdram, void *l1inst)\r\n{\r\nint i, j, thisret, ret = 0;\r\npr_info("INFO: running broad isram_memcpy tests\n");\r\nfor (i = 0xf; i >= 0; --i)\r\nret += _isram_memcpy_test(i, sdram, l1inst, isram_memcpy);\r\npr_info("INFO: running isram_memcpy (read) tests\n");\r\nfor (i = 0; i < test_len; ++i)\r\nsdram[i] = i % 255;\r\ndma_memcpy(l1inst, sdram, test_len);\r\nthisret = 0;\r\nfor (i = 0; i < test_len - 32; ++i) {\r\nunsigned char cmp[32];\r\nfor (j = 1; j <= 32; ++j) {\r\nmemset(cmp, 0, sizeof(cmp));\r\nisram_memcpy(cmp, l1inst + i, j);\r\nif (memcmp(cmp, sdram + i, j)) {\r\npr_err("FAIL: %p:", l1inst + 1);\r\nhex_dump(cmp, j);\r\npr_cont(" SDRAM:");\r\nhex_dump(sdram + i, j);\r\npr_cont("\n");\r\nif (++thisret > 20) {\r\npr_err("FAIL: skipping remaining series\n");\r\ni = test_len;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nret += thisret;\r\npr_info("INFO: running isram_memcpy (write) tests\n");\r\nmemset(sdram + test_len, 0, test_len);\r\ndma_memcpy(l1inst, sdram + test_len, test_len);\r\nthisret = 0;\r\nfor (i = 0; i < test_len - 32; ++i) {\r\nunsigned char cmp[32];\r\nfor (j = 1; j <= 32; ++j) {\r\nisram_memcpy(l1inst + i, sdram + i, j);\r\ndma_memcpy(cmp, l1inst + i, j);\r\nif (memcmp(cmp, sdram + i, j)) {\r\npr_err("FAIL: %p:", l1inst + i);\r\nhex_dump(cmp, j);\r\npr_cont(" SDRAM:");\r\nhex_dump(sdram + i, j);\r\npr_cont("\n");\r\nif (++thisret > 20) {\r\npr_err("FAIL: skipping remaining series\n");\r\ni = test_len;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nret += thisret;\r\nreturn ret;\r\n}\r\nstatic __init int isram_test_init(void)\r\n{\r\nint ret;\r\nchar *sdram;\r\nvoid *l1inst;\r\nwhile (test_len) {\r\ntest_len >>= 1;\r\nl1inst = l1_inst_sram_alloc(test_len);\r\nif (l1inst)\r\nbreak;\r\n}\r\nif (!l1inst) {\r\npr_warning("SKIP: could not allocate L1 inst\n");\r\nreturn 0;\r\n}\r\npr_info("INFO: testing %#x bytes (%p - %p)\n",\r\ntest_len, l1inst, l1inst + test_len);\r\nsdram = kmalloc(test_len * 2, GFP_KERNEL);\r\nif (!sdram) {\r\nsram_free(l1inst);\r\npr_warning("SKIP: could not allocate sdram\n");\r\nreturn 0;\r\n}\r\nret = 1;\r\npr_info("INFO: running initial dma_memcpy checks %p\n", sdram);\r\nif (_isram_memcpy_test(0xa, sdram, l1inst, dma_memcpy))\r\ngoto abort;\r\nif (_isram_memcpy_test(0x5, sdram, l1inst, dma_memcpy))\r\ngoto abort;\r\nret = 0;\r\nret += isram_read_test(sdram, l1inst);\r\nret += isram_write_test(sdram, l1inst);\r\nret += isram_memcpy_test(sdram, l1inst);\r\nabort:\r\nsram_free(l1inst);\r\nkfree(sdram);\r\nif (ret)\r\nreturn -EIO;\r\npr_info("PASS: all tests worked !\n");\r\nreturn 0;\r\n}\r\nstatic __exit void isram_test_exit(void)\r\n{\r\n}
