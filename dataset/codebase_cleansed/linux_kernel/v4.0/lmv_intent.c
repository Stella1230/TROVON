static int lmv_intent_remote(struct obd_export *exp, void *lmm,\r\nint lmmsize, struct lookup_intent *it,\r\nconst struct lu_fid *parent_fid, int flags,\r\nstruct ptlrpc_request **reqp,\r\nldlm_blocking_callback cb_blocking,\r\n__u64 extra_lock_flags)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct ptlrpc_request *req = NULL;\r\nstruct lustre_handle plock;\r\nstruct md_op_data *op_data;\r\nstruct lmv_tgt_desc *tgt;\r\nstruct mdt_body *body;\r\nint pmode;\r\nint rc = 0;\r\nbody = req_capsule_server_get(&(*reqp)->rq_pill, &RMF_MDT_BODY);\r\nif (body == NULL)\r\nreturn -EPROTO;\r\nLASSERT((body->valid & OBD_MD_MDS));\r\nif (it->it_op & IT_LOOKUP)\r\nit->it_op = IT_GETATTR;\r\npmode = it->d.lustre.it_lock_mode;\r\nif (pmode) {\r\nplock.cookie = it->d.lustre.it_lock_handle;\r\nit->d.lustre.it_lock_mode = 0;\r\nit->d.lustre.it_data = NULL;\r\n}\r\nLASSERT(fid_is_sane(&body->fid1));\r\ntgt = lmv_find_target(lmv, &body->fid1);\r\nif (IS_ERR(tgt)) {\r\nrc = PTR_ERR(tgt);\r\ngoto out;\r\n}\r\nOBD_ALLOC_PTR(op_data);\r\nif (op_data == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nop_data->op_fid1 = body->fid1;\r\nif (parent_fid != NULL) {\r\nLASSERT(it->it_op & IT_OPEN);\r\nop_data->op_fid2 = *parent_fid;\r\nop_data->op_fid3 = body->fid1;\r\n}\r\nop_data->op_bias = MDS_CROSS_REF;\r\nCDEBUG(D_INODE, "REMOTE_INTENT with fid="DFID" -> mds #%d\n",\r\nPFID(&body->fid1), tgt->ltd_idx);\r\nrc = md_intent_lock(tgt->ltd_exp, op_data, lmm, lmmsize, it,\r\nflags, &req, cb_blocking, extra_lock_flags);\r\nif (rc)\r\ngoto out_free_op_data;\r\nif (it->d.lustre.it_lock_mode != 0) {\r\nit->d.lustre.it_remote_lock_handle =\r\nit->d.lustre.it_lock_handle;\r\nit->d.lustre.it_remote_lock_mode = it->d.lustre.it_lock_mode;\r\n}\r\nit->d.lustre.it_lock_handle = plock.cookie;\r\nit->d.lustre.it_lock_mode = pmode;\r\nout_free_op_data:\r\nOBD_FREE_PTR(op_data);\r\nout:\r\nif (rc && pmode)\r\nldlm_lock_decref(&plock, pmode);\r\nptlrpc_req_finished(*reqp);\r\n*reqp = req;\r\nreturn rc;\r\n}\r\nint lmv_intent_open(struct obd_export *exp, struct md_op_data *op_data,\r\nvoid *lmm, int lmmsize, struct lookup_intent *it,\r\nint flags, struct ptlrpc_request **reqp,\r\nldlm_blocking_callback cb_blocking,\r\n__u64 extra_lock_flags)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nstruct mdt_body *body;\r\nint rc;\r\ntgt = lmv_locate_mds(lmv, op_data, &op_data->op_fid1);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nif ((it->it_op & IT_CREAT) &&\r\n!(it->it_flags & MDS_OPEN_BY_FID)) {\r\nop_data->op_fid3 = op_data->op_fid2;\r\nrc = lmv_fid_alloc(exp, &op_data->op_fid2, op_data);\r\nif (rc != 0)\r\nreturn rc;\r\n}\r\nCDEBUG(D_INODE, "OPEN_INTENT with fid1=" DFID ", fid2=" DFID ", name='%s' -> mds #%d\n",\r\nPFID(&op_data->op_fid1),\r\nPFID(&op_data->op_fid2), op_data->op_name, tgt->ltd_idx);\r\nrc = md_intent_lock(tgt->ltd_exp, op_data, lmm, lmmsize, it, flags,\r\nreqp, cb_blocking, extra_lock_flags);\r\nif (rc != 0)\r\nreturn rc;\r\nif ((it->d.lustre.it_disposition & DISP_LOOKUP_NEG) &&\r\n!(it->d.lustre.it_disposition & DISP_OPEN_CREATE) &&\r\n!(it->d.lustre.it_disposition & DISP_OPEN_OPEN))\r\nreturn rc;\r\nbody = req_capsule_server_get(&(*reqp)->rq_pill, &RMF_MDT_BODY);\r\nif (body == NULL)\r\nreturn -EPROTO;\r\nif (likely(!(body->valid & OBD_MD_MDS)))\r\nreturn 0;\r\nrc = lmv_intent_remote(exp, lmm, lmmsize, it, &op_data->op_fid1, flags,\r\nreqp, cb_blocking, extra_lock_flags);\r\nif (rc != 0) {\r\nLASSERT(rc < 0);\r\nCDEBUG(D_INODE, "Can't handle remote %s: dir " DFID "(" DFID "):%*s: %d\n",\r\nLL_IT2STR(it), PFID(&op_data->op_fid2),\r\nPFID(&op_data->op_fid1), op_data->op_namelen,\r\nop_data->op_name, rc);\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}\r\nint lmv_intent_lookup(struct obd_export *exp, struct md_op_data *op_data,\r\nvoid *lmm, int lmmsize, struct lookup_intent *it,\r\nint flags, struct ptlrpc_request **reqp,\r\nldlm_blocking_callback cb_blocking,\r\n__u64 extra_lock_flags)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt = NULL;\r\nstruct mdt_body *body;\r\nint rc = 0;\r\ntgt = lmv_locate_mds(lmv, op_data, &op_data->op_fid1);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nif (!fid_is_sane(&op_data->op_fid2))\r\nfid_zero(&op_data->op_fid2);\r\nCDEBUG(D_INODE, "LOOKUP_INTENT with fid1="DFID", fid2="DFID\r\n", name='%s' -> mds #%d\n", PFID(&op_data->op_fid1),\r\nPFID(&op_data->op_fid2),\r\nop_data->op_name ? op_data->op_name : "<NULL>",\r\ntgt->ltd_idx);\r\nop_data->op_bias &= ~MDS_CROSS_REF;\r\nrc = md_intent_lock(tgt->ltd_exp, op_data, lmm, lmmsize, it,\r\nflags, reqp, cb_blocking, extra_lock_flags);\r\nif (rc < 0 || *reqp == NULL)\r\nreturn rc;\r\nbody = req_capsule_server_get(&(*reqp)->rq_pill, &RMF_MDT_BODY);\r\nif (body == NULL)\r\nreturn -EPROTO;\r\nif (likely(!(body->valid & OBD_MD_MDS)))\r\nreturn 0;\r\nrc = lmv_intent_remote(exp, lmm, lmmsize, it, NULL, flags, reqp,\r\ncb_blocking, extra_lock_flags);\r\nreturn rc;\r\n}\r\nint lmv_intent_lock(struct obd_export *exp, struct md_op_data *op_data,\r\nvoid *lmm, int lmmsize, struct lookup_intent *it,\r\nint flags, struct ptlrpc_request **reqp,\r\nldlm_blocking_callback cb_blocking,\r\n__u64 extra_lock_flags)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nint rc;\r\nLASSERT(it != NULL);\r\nLASSERT(fid_is_sane(&op_data->op_fid1));\r\nCDEBUG(D_INODE, "INTENT LOCK '%s' for '%*s' on "DFID"\n",\r\nLL_IT2STR(it), op_data->op_namelen, op_data->op_name,\r\nPFID(&op_data->op_fid1));\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\nif (it->it_op & (IT_LOOKUP | IT_GETATTR | IT_LAYOUT))\r\nrc = lmv_intent_lookup(exp, op_data, lmm, lmmsize, it,\r\nflags, reqp, cb_blocking,\r\nextra_lock_flags);\r\nelse if (it->it_op & IT_OPEN)\r\nrc = lmv_intent_open(exp, op_data, lmm, lmmsize, it,\r\nflags, reqp, cb_blocking,\r\nextra_lock_flags);\r\nelse\r\nLBUG();\r\nreturn rc;\r\n}
