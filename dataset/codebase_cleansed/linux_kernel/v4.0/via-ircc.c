static void iodelay(int udelay)\r\n{\r\nu8 data;\r\nint i;\r\nfor (i = 0; i < udelay; i++) {\r\ndata = inb(0x80);\r\n}\r\n}\r\nstatic int __init via_ircc_init(void)\r\n{\r\nint rc;\r\nrc = pci_register_driver(&via_driver);\r\nif (rc < 0) {\r\npr_debug("%s(): error rc = %d, returning -ENODEV...\n",\r\n__func__, rc);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int via_init_one(struct pci_dev *pcidev, const struct pci_device_id *id)\r\n{\r\nint rc;\r\nu8 temp,oldPCI_40,oldPCI_44,bTmp,bTmp1;\r\nu16 Chipset,FirDRQ1,FirDRQ0,FirIRQ,FirIOBase;\r\nchipio_t info;\r\npr_debug("%s(): Device ID=(0X%X)\n", __func__, id->device);\r\nrc = pci_enable_device (pcidev);\r\nif (rc) {\r\npr_debug("%s(): error rc = %d\n", __func__, rc);\r\nreturn -ENODEV;\r\n}\r\nif ( ReadLPCReg(0x20) != 0x3C )\r\nChipset=0x3096;\r\nelse\r\nChipset=0x3076;\r\nif (Chipset==0x3076) {\r\npr_debug("%s(): Chipset = 3076\n", __func__);\r\nWriteLPCReg(7,0x0c );\r\ntemp=ReadLPCReg(0x30);\r\nif((temp&0x01)==1) {\r\nWriteLPCReg(0x1d, 0x82 );\r\nWriteLPCReg(0x23,0x18);\r\ntemp=ReadLPCReg(0xF0);\r\nif((temp&0x01)==0) {\r\ntemp=(ReadLPCReg(0x74)&0x03);\r\nFirDRQ0=temp + 4;\r\ntemp=(ReadLPCReg(0x74)&0x0C) >> 2;\r\nFirDRQ1=temp + 4;\r\n} else {\r\ntemp=(ReadLPCReg(0x74)&0x0C) >> 2;\r\nFirDRQ0=temp + 4;\r\nFirDRQ1=FirDRQ0;\r\n}\r\nFirIRQ=(ReadLPCReg(0x70)&0x0f);\r\nFirIOBase=ReadLPCReg(0x60 ) << 8;\r\nFirIOBase=FirIOBase| ReadLPCReg(0x61) ;\r\nFirIOBase=FirIOBase ;\r\ninfo.fir_base=FirIOBase;\r\ninfo.irq=FirIRQ;\r\ninfo.dma=FirDRQ1;\r\ninfo.dma2=FirDRQ0;\r\npci_read_config_byte(pcidev,0x40,&bTmp);\r\npci_write_config_byte(pcidev,0x40,((bTmp | 0x08) & 0xfe));\r\npci_read_config_byte(pcidev,0x42,&bTmp);\r\npci_write_config_byte(pcidev,0x42,(bTmp | 0xf0));\r\npci_write_config_byte(pcidev,0x5a,0xc0);\r\nWriteLPCReg(0x28, 0x70 );\r\nrc = via_ircc_open(pcidev, &info, 0x3076);\r\n} else\r\nrc = -ENODEV;\r\n} else {\r\npr_debug("%s(): Chipset = 3096\n", __func__);\r\npci_read_config_byte(pcidev,0x67,&bTmp);\r\nif((bTmp&0x01)==1) {\r\npci_read_config_byte(pcidev,0x42,&oldPCI_40);\r\npci_write_config_byte(pcidev,0x42,oldPCI_40 | 0x80);\r\npci_read_config_byte(pcidev,0x40,&oldPCI_40);\r\npci_write_config_byte(pcidev,0x40,oldPCI_40 & 0xf7);\r\npci_read_config_byte(pcidev,0x44,&oldPCI_44);\r\npci_write_config_byte(pcidev,0x44,0x4e);\r\nif((bTmp&0x02)==0) {\r\npci_read_config_byte(pcidev,0x44,&bTmp1);\r\nFirDRQ0 = (bTmp1 & 0x30) >> 4;\r\npci_read_config_byte(pcidev,0x44,&bTmp1);\r\nFirDRQ1 = (bTmp1 & 0xc0) >> 6;\r\n} else {\r\npci_read_config_byte(pcidev,0x44,&bTmp1);\r\nFirDRQ0 = (bTmp1 & 0x30) >> 4 ;\r\nFirDRQ1=0;\r\n}\r\npci_read_config_byte(pcidev,0x47,&bTmp1);\r\nFirIRQ = bTmp1 & 0x0f;\r\npci_read_config_byte(pcidev,0x69,&bTmp);\r\nFirIOBase = bTmp << 8;\r\npci_read_config_byte(pcidev,0x68,&bTmp);\r\nFirIOBase = (FirIOBase | bTmp ) & 0xfff0;\r\ninfo.fir_base=FirIOBase;\r\ninfo.irq=FirIRQ;\r\ninfo.dma=FirDRQ1;\r\ninfo.dma2=FirDRQ0;\r\nrc = via_ircc_open(pcidev, &info, 0x3096);\r\n} else\r\nrc = -ENODEV;\r\n}\r\npr_debug("%s(): End - rc = %d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nstatic void __exit via_ircc_cleanup(void)\r\n{\r\npci_unregister_driver (&via_driver);\r\n}\r\nstatic int via_ircc_open(struct pci_dev *pdev, chipio_t *info, unsigned int id)\r\n{\r\nstruct net_device *dev;\r\nstruct via_ircc_cb *self;\r\nint err;\r\ndev = alloc_irdadev(sizeof(struct via_ircc_cb));\r\nif (dev == NULL)\r\nreturn -ENOMEM;\r\nself = netdev_priv(dev);\r\nself->netdev = dev;\r\nspin_lock_init(&self->lock);\r\npci_set_drvdata(pdev, self);\r\nself->io.cfg_base = info->cfg_base;\r\nself->io.fir_base = info->fir_base;\r\nself->io.irq = info->irq;\r\nself->io.fir_ext = CHIP_IO_EXTENT;\r\nself->io.dma = info->dma;\r\nself->io.dma2 = info->dma2;\r\nself->io.fifo_size = 32;\r\nself->chip_id = id;\r\nself->st_fifo.len = 0;\r\nself->RxDataReady = 0;\r\nif (!request_region(self->io.fir_base, self->io.fir_ext, driver_name)) {\r\npr_debug("%s(), can't get iobase of 0x%03x\n",\r\n__func__, self->io.fir_base);\r\nerr = -ENODEV;\r\ngoto err_out1;\r\n}\r\nirda_init_max_qos_capabilies(&self->qos);\r\nif (!dongle_id)\r\ndongle_id = via_ircc_read_dongle_id(self->io.fir_base);\r\nself->io.dongle_id = dongle_id;\r\nswitch( self->io.dongle_id ){\r\ncase 0x0d:\r\nself->qos.baud_rate.bits =\r\nIR_9600 | IR_19200 | IR_38400 | IR_57600 | IR_115200 |\r\nIR_576000 | IR_1152000 | (IR_4000000 << 8);\r\nbreak;\r\ndefault:\r\nself->qos.baud_rate.bits =\r\nIR_9600 | IR_19200 | IR_38400 | IR_57600 | IR_115200;\r\nbreak;\r\n}\r\nself->qos.min_turn_time.bits = qos_mtt_bits;\r\nirda_qos_bits_to_value(&self->qos);\r\nself->rx_buff.truesize = 14384 + 2048;\r\nself->tx_buff.truesize = 14384 + 2048;\r\nself->rx_buff.head =\r\ndma_zalloc_coherent(&pdev->dev, self->rx_buff.truesize,\r\n&self->rx_buff_dma, GFP_KERNEL);\r\nif (self->rx_buff.head == NULL) {\r\nerr = -ENOMEM;\r\ngoto err_out2;\r\n}\r\nself->tx_buff.head =\r\ndma_zalloc_coherent(&pdev->dev, self->tx_buff.truesize,\r\n&self->tx_buff_dma, GFP_KERNEL);\r\nif (self->tx_buff.head == NULL) {\r\nerr = -ENOMEM;\r\ngoto err_out3;\r\n}\r\nself->rx_buff.in_frame = FALSE;\r\nself->rx_buff.state = OUTSIDE_FRAME;\r\nself->tx_buff.data = self->tx_buff.head;\r\nself->rx_buff.data = self->rx_buff.head;\r\nself->tx_fifo.len = self->tx_fifo.ptr = self->tx_fifo.free = 0;\r\nself->tx_fifo.tail = self->tx_buff.head;\r\ndev->netdev_ops = &via_ircc_sir_ops;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto err_out4;\r\nnet_info_ratelimited("IrDA: Registered device %s (via-ircc)\n",\r\ndev->name);\r\nself->io.speed = 9600;\r\nvia_hw_init(self);\r\nreturn 0;\r\nerr_out4:\r\ndma_free_coherent(&pdev->dev, self->tx_buff.truesize,\r\nself->tx_buff.head, self->tx_buff_dma);\r\nerr_out3:\r\ndma_free_coherent(&pdev->dev, self->rx_buff.truesize,\r\nself->rx_buff.head, self->rx_buff_dma);\r\nerr_out2:\r\nrelease_region(self->io.fir_base, self->io.fir_ext);\r\nerr_out1:\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic void via_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct via_ircc_cb *self = pci_get_drvdata(pdev);\r\nint iobase;\r\niobase = self->io.fir_base;\r\nResetChip(iobase, 5);\r\nunregister_netdev(self->netdev);\r\npr_debug("%s(), Releasing Region %03x\n",\r\n__func__, self->io.fir_base);\r\nrelease_region(self->io.fir_base, self->io.fir_ext);\r\nif (self->tx_buff.head)\r\ndma_free_coherent(&pdev->dev, self->tx_buff.truesize,\r\nself->tx_buff.head, self->tx_buff_dma);\r\nif (self->rx_buff.head)\r\ndma_free_coherent(&pdev->dev, self->rx_buff.truesize,\r\nself->rx_buff.head, self->rx_buff_dma);\r\nfree_netdev(self->netdev);\r\npci_disable_device(pdev);\r\n}\r\nstatic void via_hw_init(struct via_ircc_cb *self)\r\n{\r\nint iobase = self->io.fir_base;\r\nSetMaxRxPacketSize(iobase, 0x0fff);\r\nEnRXFIFOReadyInt(iobase, OFF);\r\nEnRXFIFOHalfLevelInt(iobase, OFF);\r\nEnTXFIFOHalfLevelInt(iobase, OFF);\r\nEnTXFIFOUnderrunEOMInt(iobase, ON);\r\nEnTXFIFOReadyInt(iobase, OFF);\r\nInvertTX(iobase, OFF);\r\nInvertRX(iobase, OFF);\r\nif (ReadLPCReg(0x20) == 0x3c)\r\nWriteLPCReg(0xF0, 0);\r\nEnRXSpecInt(iobase, ON);\r\nResetChip(iobase, 5);\r\nEnableDMA(iobase, OFF);\r\nEnableTX(iobase, OFF);\r\nEnableRX(iobase, OFF);\r\nEnRXDMA(iobase, OFF);\r\nEnTXDMA(iobase, OFF);\r\nRXStart(iobase, OFF);\r\nTXStart(iobase, OFF);\r\nInitCard(iobase);\r\nCommonInit(iobase);\r\nSIRFilter(iobase, ON);\r\nSetSIR(iobase, ON);\r\nCRC16(iobase, ON);\r\nEnTXCRC(iobase, 0);\r\nWriteReg(iobase, I_ST_CT_0, 0x00);\r\nSetBaudRate(iobase, 9600);\r\nSetPulseWidth(iobase, 12);\r\nSetSendPreambleCount(iobase, 0);\r\nself->io.speed = 9600;\r\nself->st_fifo.len = 0;\r\nvia_ircc_change_dongle_speed(iobase, self->io.speed,\r\nself->io.dongle_id);\r\nWriteReg(iobase, I_ST_CT_0, 0x80);\r\n}\r\nstatic int via_ircc_read_dongle_id(int iobase)\r\n{\r\nnet_err_ratelimited("via-ircc: dongle probing not supported, please specify dongle_id module parameter\n");\r\nreturn 9;\r\n}\r\nstatic void via_ircc_change_dongle_speed(int iobase, int speed,\r\nint dongle_id)\r\n{\r\nu8 mode = 0;\r\nspeed = speed;\r\npr_debug("%s(): change_dongle_speed to %d for 0x%x, %d\n",\r\n__func__, speed, iobase, dongle_id);\r\nswitch (dongle_id) {\r\ncase 0x08:\r\nUseOneRX(iobase, ON);\r\nInvertTX(iobase, OFF);\r\nInvertRX(iobase, OFF);\r\nEnRX2(iobase, ON);\r\nEnGPIOtoRX2(iobase, OFF);\r\nif (IsSIROn(iobase)) {\r\nSlowIRRXLowActive(iobase, ON);\r\nudelay(1000);\r\nSlowIRRXLowActive(iobase, OFF);\r\n} else {\r\nif (IsMIROn(iobase)) {\r\nSlowIRRXLowActive(iobase, OFF);\r\nudelay(20);\r\n} else {\r\nif (IsFIROn(iobase)) {\r\nSlowIRRXLowActive(iobase, OFF);\r\nudelay(20);\r\n}\r\n}\r\n}\r\nbreak;\r\ncase 0x09:\r\nUseOneRX(iobase, ON);\r\nInvertTX(iobase, OFF);\r\nInvertRX(iobase, OFF);\r\nEnRX2(iobase, ON);\r\nEnGPIOtoRX2(iobase, OFF);\r\nif (IsSIROn(iobase)) {\r\nSlowIRRXLowActive(iobase, ON);\r\nudelay(20);\r\nSlowIRRXLowActive(iobase, OFF);\r\n}\r\nif (IsMIROn(iobase)) {\r\nSlowIRRXLowActive(iobase, OFF);\r\nudelay(20);\r\nSlowIRRXLowActive(iobase, ON);\r\n} else {\r\nif (IsFIROn(iobase)) {\r\nSlowIRRXLowActive(iobase, OFF);\r\nWriteTX(iobase, ON);\r\nudelay(20);\r\nSlowIRRXLowActive(iobase, ON);\r\nudelay(20);\r\nWriteTX(iobase, OFF);\r\n}\r\n}\r\nbreak;\r\ncase 0x0d:\r\nUseOneRX(iobase, OFF);\r\nInvertTX(iobase, OFF);\r\nInvertRX(iobase, OFF);\r\nSlowIRRXLowActive(iobase, OFF);\r\nif (IsSIROn(iobase)) {\r\nEnGPIOtoRX2(iobase, OFF);\r\nWriteGIO(iobase, OFF);\r\nEnRX2(iobase, OFF);\r\n} else {\r\nEnGPIOtoRX2(iobase, OFF);\r\nWriteGIO(iobase, OFF);\r\nEnRX2(iobase, OFF);\r\n}\r\nbreak;\r\ncase 0x11:\r\npr_debug("%s: Temic TFDS4500: One RX pin, TX normal, RX inverted\n",\r\n__func__);\r\nUseOneRX(iobase, ON);\r\nInvertTX(iobase, OFF);\r\nInvertRX(iobase, ON);\r\nEnRX2(iobase, ON);\r\nEnGPIOtoRX2(iobase, OFF);\r\nif( IsSIROn(iobase) ){\r\nSlowIRRXLowActive(iobase, ON);\r\nudelay(20);\r\nSlowIRRXLowActive(iobase, OFF);\r\n} else{\r\npr_debug("%s: Warning: TFDS4500 not running in SIR mode !\n",\r\n__func__);\r\n}\r\nbreak;\r\ncase 0x0ff:\r\nif (IsSIROn(iobase))\r\nmode = 0;\r\nelse if (IsMIROn(iobase))\r\nmode = 1;\r\nelse if (IsFIROn(iobase))\r\nmode = 2;\r\nelse if (IsVFIROn(iobase))\r\nmode = 5;\r\nSI_SetMode(iobase, mode);\r\nbreak;\r\ndefault:\r\nnet_err_ratelimited("%s: Error: dongle_id %d unsupported !\n",\r\n__func__, dongle_id);\r\n}\r\n}\r\nstatic void via_ircc_change_speed(struct via_ircc_cb *self, __u32 speed)\r\n{\r\nstruct net_device *dev = self->netdev;\r\nu16 iobase;\r\nu8 value = 0, bTmp;\r\niobase = self->io.fir_base;\r\nself->io.speed = speed;\r\npr_debug("%s: change_speed to %d bps.\n", __func__, speed);\r\nWriteReg(iobase, I_ST_CT_0, 0x0);\r\nswitch (speed) {\r\ncase 2400:\r\ncase 9600:\r\ncase 19200:\r\ncase 38400:\r\ncase 57600:\r\ncase 115200:\r\nvalue = (115200/speed)-1;\r\nSetSIR(iobase, ON);\r\nCRC16(iobase, ON);\r\nbreak;\r\ncase 576000:\r\nvalue = 0;\r\nSetSIR(iobase, ON);\r\nCRC16(iobase, ON);\r\nbreak;\r\ncase 1152000:\r\nvalue = 0;\r\nSetMIR(iobase, ON);\r\nbreak;\r\ncase 4000000:\r\nvalue = 0;\r\nSetFIR(iobase, ON);\r\nSetPulseWidth(iobase, 0);\r\nSetSendPreambleCount(iobase, 14);\r\nCRC16(iobase, OFF);\r\nEnTXCRC(iobase, ON);\r\nbreak;\r\ncase 16000000:\r\nvalue = 0;\r\nSetVFIR(iobase, ON);\r\nbreak;\r\ndefault:\r\nvalue = 0;\r\nbreak;\r\n}\r\nbTmp = (ReadReg(iobase, I_CF_H_1) & 0x03);\r\nbTmp |= value << 2;\r\nWriteReg(iobase, I_CF_H_1, bTmp);\r\nvia_ircc_change_dongle_speed(iobase, speed, self->io.dongle_id);\r\nSetFIFO(iobase, 64);\r\nWriteReg(iobase, I_ST_CT_0, 0x80);\r\nif (IsSIROn(iobase)) {\r\nSIRFilter(iobase, ON);\r\nSIRRecvAny(iobase, ON);\r\n} else {\r\nSIRFilter(iobase, OFF);\r\nSIRRecvAny(iobase, OFF);\r\n}\r\nif (speed > 115200) {\r\ndev->netdev_ops = &via_ircc_fir_ops;\r\nvia_ircc_dma_receive(self);\r\n} else {\r\ndev->netdev_ops = &via_ircc_sir_ops;\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t via_ircc_hard_xmit_sir(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct via_ircc_cb *self;\r\nunsigned long flags;\r\nu16 iobase;\r\n__u32 speed;\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT(self != NULL, return NETDEV_TX_OK;);\r\niobase = self->io.fir_base;\r\nnetif_stop_queue(dev);\r\nspeed = irda_get_next_speed(skb);\r\nif ((speed != self->io.speed) && (speed != -1)) {\r\nif (!skb->len) {\r\nvia_ircc_change_speed(self, speed);\r\ndev->trans_start = jiffies;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n} else\r\nself->new_speed = speed;\r\n}\r\nInitCard(iobase);\r\nCommonInit(iobase);\r\nSIRFilter(iobase, ON);\r\nSetSIR(iobase, ON);\r\nCRC16(iobase, ON);\r\nEnTXCRC(iobase, 0);\r\nWriteReg(iobase, I_ST_CT_0, 0x00);\r\nspin_lock_irqsave(&self->lock, flags);\r\nself->tx_buff.data = self->tx_buff.head;\r\nself->tx_buff.len =\r\nasync_wrap_skb(skb, self->tx_buff.data,\r\nself->tx_buff.truesize);\r\ndev->stats.tx_bytes += self->tx_buff.len;\r\nSetBaudRate(iobase, self->io.speed);\r\nSetPulseWidth(iobase, 12);\r\nSetSendPreambleCount(iobase, 0);\r\nWriteReg(iobase, I_ST_CT_0, 0x80);\r\nEnableTX(iobase, ON);\r\nEnableRX(iobase, OFF);\r\nResetChip(iobase, 0);\r\nResetChip(iobase, 1);\r\nResetChip(iobase, 2);\r\nResetChip(iobase, 3);\r\nResetChip(iobase, 4);\r\nEnAllInt(iobase, ON);\r\nEnTXDMA(iobase, ON);\r\nEnRXDMA(iobase, OFF);\r\nirda_setup_dma(self->io.dma, self->tx_buff_dma, self->tx_buff.len,\r\nDMA_TX_MODE);\r\nSetSendByte(iobase, self->tx_buff.len);\r\nRXStart(iobase, OFF);\r\nTXStart(iobase, ON);\r\ndev->trans_start = jiffies;\r\nspin_unlock_irqrestore(&self->lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic netdev_tx_t via_ircc_hard_xmit_fir(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct via_ircc_cb *self;\r\nu16 iobase;\r\n__u32 speed;\r\nunsigned long flags;\r\nself = netdev_priv(dev);\r\niobase = self->io.fir_base;\r\nif (self->st_fifo.len)\r\nreturn NETDEV_TX_OK;\r\nif (self->chip_id == 0x3076)\r\niodelay(1500);\r\nelse\r\nudelay(1500);\r\nnetif_stop_queue(dev);\r\nspeed = irda_get_next_speed(skb);\r\nif ((speed != self->io.speed) && (speed != -1)) {\r\nif (!skb->len) {\r\nvia_ircc_change_speed(self, speed);\r\ndev->trans_start = jiffies;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n} else\r\nself->new_speed = speed;\r\n}\r\nspin_lock_irqsave(&self->lock, flags);\r\nself->tx_fifo.queue[self->tx_fifo.free].start = self->tx_fifo.tail;\r\nself->tx_fifo.queue[self->tx_fifo.free].len = skb->len;\r\nself->tx_fifo.tail += skb->len;\r\ndev->stats.tx_bytes += skb->len;\r\nskb_copy_from_linear_data(skb,\r\nself->tx_fifo.queue[self->tx_fifo.free].start, skb->len);\r\nself->tx_fifo.len++;\r\nself->tx_fifo.free++;\r\nvia_ircc_dma_xmit(self, iobase);\r\ndev->trans_start = jiffies;\r\ndev_kfree_skb(skb);\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int via_ircc_dma_xmit(struct via_ircc_cb *self, u16 iobase)\r\n{\r\nEnTXDMA(iobase, OFF);\r\nself->io.direction = IO_XMIT;\r\nEnPhys(iobase, ON);\r\nEnableTX(iobase, ON);\r\nEnableRX(iobase, OFF);\r\nResetChip(iobase, 0);\r\nResetChip(iobase, 1);\r\nResetChip(iobase, 2);\r\nResetChip(iobase, 3);\r\nResetChip(iobase, 4);\r\nEnAllInt(iobase, ON);\r\nEnTXDMA(iobase, ON);\r\nEnRXDMA(iobase, OFF);\r\nirda_setup_dma(self->io.dma,\r\n((u8 *)self->tx_fifo.queue[self->tx_fifo.ptr].start -\r\nself->tx_buff.head) + self->tx_buff_dma,\r\nself->tx_fifo.queue[self->tx_fifo.ptr].len, DMA_TX_MODE);\r\npr_debug("%s: tx_fifo.ptr=%x,len=%x,tx_fifo.len=%x..\n",\r\n__func__, self->tx_fifo.ptr,\r\nself->tx_fifo.queue[self->tx_fifo.ptr].len,\r\nself->tx_fifo.len);\r\nSetSendByte(iobase, self->tx_fifo.queue[self->tx_fifo.ptr].len);\r\nRXStart(iobase, OFF);\r\nTXStart(iobase, ON);\r\nreturn 0;\r\n}\r\nstatic int via_ircc_dma_xmit_complete(struct via_ircc_cb *self)\r\n{\r\nint iobase;\r\nu8 Tx_status;\r\niobase = self->io.fir_base;\r\nTx_status = GetTXStatus(iobase);\r\nif (Tx_status & 0x08) {\r\nself->netdev->stats.tx_errors++;\r\nself->netdev->stats.tx_fifo_errors++;\r\nhwreset(self);\r\n} else {\r\nself->netdev->stats.tx_packets++;\r\nResetChip(iobase, 3);\r\nResetChip(iobase, 4);\r\n}\r\nif (self->new_speed) {\r\nvia_ircc_change_speed(self, self->new_speed);\r\nself->new_speed = 0;\r\n}\r\nif (IsFIROn(iobase)) {\r\nif (self->tx_fifo.len) {\r\nself->tx_fifo.len--;\r\nself->tx_fifo.ptr++;\r\n}\r\n}\r\npr_debug("%s: tx_fifo.len=%x ,tx_fifo.ptr=%x,tx_fifo.free=%x...\n",\r\n__func__,\r\nself->tx_fifo.len, self->tx_fifo.ptr, self->tx_fifo.free);\r\nself->tx_fifo.len = self->tx_fifo.ptr = self->tx_fifo.free = 0;\r\nself->tx_fifo.tail = self->tx_buff.head;\r\nnetif_wake_queue(self->netdev);\r\nreturn TRUE;\r\n}\r\nstatic int via_ircc_dma_receive(struct via_ircc_cb *self)\r\n{\r\nint iobase;\r\niobase = self->io.fir_base;\r\nself->tx_fifo.len = self->tx_fifo.ptr = self->tx_fifo.free = 0;\r\nself->tx_fifo.tail = self->tx_buff.head;\r\nself->RxDataReady = 0;\r\nself->io.direction = IO_RECV;\r\nself->rx_buff.data = self->rx_buff.head;\r\nself->st_fifo.len = self->st_fifo.pending_bytes = 0;\r\nself->st_fifo.tail = self->st_fifo.head = 0;\r\nEnPhys(iobase, ON);\r\nEnableTX(iobase, OFF);\r\nEnableRX(iobase, ON);\r\nResetChip(iobase, 0);\r\nResetChip(iobase, 1);\r\nResetChip(iobase, 2);\r\nResetChip(iobase, 3);\r\nResetChip(iobase, 4);\r\nEnAllInt(iobase, ON);\r\nEnTXDMA(iobase, OFF);\r\nEnRXDMA(iobase, ON);\r\nirda_setup_dma(self->io.dma2, self->rx_buff_dma,\r\nself->rx_buff.truesize, DMA_RX_MODE);\r\nTXStart(iobase, OFF);\r\nRXStart(iobase, ON);\r\nreturn 0;\r\n}\r\nstatic int via_ircc_dma_receive_complete(struct via_ircc_cb *self,\r\nint iobase)\r\n{\r\nstruct st_fifo *st_fifo;\r\nstruct sk_buff *skb;\r\nint len, i;\r\nu8 status = 0;\r\niobase = self->io.fir_base;\r\nst_fifo = &self->st_fifo;\r\nif (self->io.speed < 4000000) {\r\nlen = GetRecvByte(iobase, self);\r\nskb = dev_alloc_skb(len + 1);\r\nif (skb == NULL)\r\nreturn FALSE;\r\nskb_reserve(skb, 1);\r\nskb_put(skb, len - 2);\r\nif (self->chip_id == 0x3076) {\r\nfor (i = 0; i < len - 2; i++)\r\nskb->data[i] = self->rx_buff.data[i * 2];\r\n} else {\r\nif (self->chip_id == 0x3096) {\r\nfor (i = 0; i < len - 2; i++)\r\nskb->data[i] =\r\nself->rx_buff.data[i];\r\n}\r\n}\r\nself->rx_buff.data += len;\r\nself->netdev->stats.rx_bytes += len;\r\nself->netdev->stats.rx_packets++;\r\nskb->dev = self->netdev;\r\nskb_reset_mac_header(skb);\r\nskb->protocol = htons(ETH_P_IRDA);\r\nnetif_rx(skb);\r\nreturn TRUE;\r\n}\r\nelse {\r\nlen = GetRecvByte(iobase, self);\r\nif (len == 0)\r\nreturn TRUE;\r\nif (((len - 4) < 2) || ((len - 4) > 2048)) {\r\npr_debug("%s(): Trouble:len=%x,CurCount=%x,LastCount=%x\n",\r\n__func__, len, RxCurCount(iobase, self),\r\nself->RxLastCount);\r\nhwreset(self);\r\nreturn FALSE;\r\n}\r\npr_debug("%s(): fifo.len=%x,len=%x,CurCount=%x..\n",\r\n__func__,\r\nst_fifo->len, len - 4, RxCurCount(iobase, self));\r\nst_fifo->entries[st_fifo->tail].status = status;\r\nst_fifo->entries[st_fifo->tail].len = len;\r\nst_fifo->pending_bytes += len;\r\nst_fifo->tail++;\r\nst_fifo->len++;\r\nif (st_fifo->tail > MAX_RX_WINDOW)\r\nst_fifo->tail = 0;\r\nself->RxDataReady = 0;\r\nEnableRX(iobase, OFF);\r\nEnRXDMA(iobase, OFF);\r\nRXStart(iobase, OFF);\r\nif (st_fifo->head > MAX_RX_WINDOW)\r\nst_fifo->head = 0;\r\nstatus = st_fifo->entries[st_fifo->head].status;\r\nlen = st_fifo->entries[st_fifo->head].len;\r\nst_fifo->head++;\r\nst_fifo->len--;\r\nskb = dev_alloc_skb(len + 1 - 4);\r\nif ((skb == NULL) || (skb->data == NULL) ||\r\n(self->rx_buff.data == NULL) || (len < 6)) {\r\nself->netdev->stats.rx_dropped++;\r\nkfree_skb(skb);\r\nreturn TRUE;\r\n}\r\nskb_reserve(skb, 1);\r\nskb_put(skb, len - 4);\r\nskb_copy_to_linear_data(skb, self->rx_buff.data, len - 4);\r\npr_debug("%s(): len=%x.rx_buff=%p\n", __func__,\r\nlen - 4, self->rx_buff.data);\r\nself->rx_buff.data += len;\r\nself->netdev->stats.rx_bytes += len;\r\nself->netdev->stats.rx_packets++;\r\nskb->dev = self->netdev;\r\nskb_reset_mac_header(skb);\r\nskb->protocol = htons(ETH_P_IRDA);\r\nnetif_rx(skb);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int upload_rxdata(struct via_ircc_cb *self, int iobase)\r\n{\r\nstruct sk_buff *skb;\r\nint len;\r\nstruct st_fifo *st_fifo;\r\nst_fifo = &self->st_fifo;\r\nlen = GetRecvByte(iobase, self);\r\npr_debug("%s(): len=%x\n", __func__, len);\r\nif ((len - 4) < 2) {\r\nself->netdev->stats.rx_dropped++;\r\nreturn FALSE;\r\n}\r\nskb = dev_alloc_skb(len + 1);\r\nif (skb == NULL) {\r\nself->netdev->stats.rx_dropped++;\r\nreturn FALSE;\r\n}\r\nskb_reserve(skb, 1);\r\nskb_put(skb, len - 4 + 1);\r\nskb_copy_to_linear_data(skb, self->rx_buff.data, len - 4 + 1);\r\nst_fifo->tail++;\r\nst_fifo->len++;\r\nif (st_fifo->tail > MAX_RX_WINDOW)\r\nst_fifo->tail = 0;\r\nself->rx_buff.data += len;\r\nself->netdev->stats.rx_bytes += len;\r\nself->netdev->stats.rx_packets++;\r\nskb->dev = self->netdev;\r\nskb_reset_mac_header(skb);\r\nskb->protocol = htons(ETH_P_IRDA);\r\nnetif_rx(skb);\r\nif (st_fifo->len < (MAX_RX_WINDOW + 2)) {\r\nRXStart(iobase, ON);\r\n} else {\r\nEnableRX(iobase, OFF);\r\nEnRXDMA(iobase, OFF);\r\nRXStart(iobase, OFF);\r\n}\r\nreturn TRUE;\r\n}\r\nstatic int RxTimerHandler(struct via_ircc_cb *self, int iobase)\r\n{\r\nstruct st_fifo *st_fifo;\r\nstruct sk_buff *skb;\r\nint len;\r\nu8 status;\r\nst_fifo = &self->st_fifo;\r\nif (CkRxRecv(iobase, self)) {\r\nself->RetryCount = 0;\r\nSetTimer(iobase, 20);\r\nself->RxDataReady++;\r\nreturn FALSE;\r\n} else\r\nself->RetryCount++;\r\nif ((self->RetryCount >= 1) ||\r\n((st_fifo->pending_bytes + 2048) > self->rx_buff.truesize) ||\r\n(st_fifo->len >= (MAX_RX_WINDOW))) {\r\nwhile (st_fifo->len > 0) {\r\nif (st_fifo->head > MAX_RX_WINDOW)\r\nst_fifo->head = 0;\r\nstatus = st_fifo->entries[st_fifo->head].status;\r\nlen = st_fifo->entries[st_fifo->head].len;\r\nst_fifo->head++;\r\nst_fifo->len--;\r\nskb = dev_alloc_skb(len + 1 - 4);\r\nif ((skb == NULL) || (skb->data == NULL) ||\r\n(self->rx_buff.data == NULL) || (len < 6)) {\r\nself->netdev->stats.rx_dropped++;\r\ncontinue;\r\n}\r\nskb_reserve(skb, 1);\r\nskb_put(skb, len - 4);\r\nskb_copy_to_linear_data(skb, self->rx_buff.data, len - 4);\r\npr_debug("%s(): len=%x.head=%x\n", __func__,\r\nlen - 4, st_fifo->head);\r\nself->rx_buff.data += len;\r\nself->netdev->stats.rx_bytes += len;\r\nself->netdev->stats.rx_packets++;\r\nskb->dev = self->netdev;\r\nskb_reset_mac_header(skb);\r\nskb->protocol = htons(ETH_P_IRDA);\r\nnetif_rx(skb);\r\n}\r\nself->RetryCount = 0;\r\npr_debug("%s(): End of upload HostStatus=%x,RxStatus=%x\n",\r\n__func__, GetHostStatus(iobase), GetRXStatus(iobase));\r\nif ((GetRXStatus(iobase) & 0x10) &&\r\n(RxCurCount(iobase, self) != self->RxLastCount)) {\r\nupload_rxdata(self, iobase);\r\nif (irda_device_txqueue_empty(self->netdev))\r\nvia_ircc_dma_receive(self);\r\n}\r\n}\r\nelse\r\nSetTimer(iobase, 4);\r\nreturn TRUE;\r\n}\r\nstatic irqreturn_t via_ircc_interrupt(int dummy, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct via_ircc_cb *self = netdev_priv(dev);\r\nint iobase;\r\nu8 iHostIntType, iRxIntType, iTxIntType;\r\niobase = self->io.fir_base;\r\nspin_lock(&self->lock);\r\niHostIntType = GetHostStatus(iobase);\r\npr_debug("%s(): iHostIntType %02x: %s %s %s %02x\n",\r\n__func__, iHostIntType,\r\n(iHostIntType & 0x40) ? "Timer" : "",\r\n(iHostIntType & 0x20) ? "Tx" : "",\r\n(iHostIntType & 0x10) ? "Rx" : "",\r\n(iHostIntType & 0x0e) >> 1);\r\nif ((iHostIntType & 0x40) != 0) {\r\nself->EventFlag.TimeOut++;\r\nClearTimerInt(iobase, 1);\r\nif (self->io.direction == IO_XMIT) {\r\nvia_ircc_dma_xmit(self, iobase);\r\n}\r\nif (self->io.direction == IO_RECV) {\r\nif (self->RxDataReady > 30) {\r\nhwreset(self);\r\nif (irda_device_txqueue_empty(self->netdev)) {\r\nvia_ircc_dma_receive(self);\r\n}\r\n} else {\r\nRxTimerHandler(self, iobase);\r\n}\r\n}\r\n}\r\nif ((iHostIntType & 0x20) != 0) {\r\niTxIntType = GetTXStatus(iobase);\r\npr_debug("%s(): iTxIntType %02x: %s %s %s %s\n",\r\n__func__, iTxIntType,\r\n(iTxIntType & 0x08) ? "FIFO underr." : "",\r\n(iTxIntType & 0x04) ? "EOM" : "",\r\n(iTxIntType & 0x02) ? "FIFO ready" : "",\r\n(iTxIntType & 0x01) ? "Early EOM" : "");\r\nif (iTxIntType & 0x4) {\r\nself->EventFlag.EOMessage++;\r\nif (via_ircc_dma_xmit_complete(self)) {\r\nif (irda_device_txqueue_empty\r\n(self->netdev)) {\r\nvia_ircc_dma_receive(self);\r\n}\r\n} else {\r\nself->EventFlag.Unknown++;\r\n}\r\n}\r\n}\r\nif ((iHostIntType & 0x10) != 0) {\r\niRxIntType = GetRXStatus(iobase);\r\npr_debug("%s(): iRxIntType %02x: %s %s %s %s %s %s %s\n",\r\n__func__, iRxIntType,\r\n(iRxIntType & 0x80) ? "PHY err." : "",\r\n(iRxIntType & 0x40) ? "CRC err" : "",\r\n(iRxIntType & 0x20) ? "FIFO overr." : "",\r\n(iRxIntType & 0x10) ? "EOF" : "",\r\n(iRxIntType & 0x08) ? "RxData" : "",\r\n(iRxIntType & 0x02) ? "RxMaxLen" : "",\r\n(iRxIntType & 0x01) ? "SIR bad" : "");\r\nif (!iRxIntType)\r\npr_debug("%s(): RxIRQ =0\n", __func__);\r\nif (iRxIntType & 0x10) {\r\nif (via_ircc_dma_receive_complete(self, iobase)) {\r\nvia_ircc_dma_receive(self);\r\n}\r\n}\r\nelse {\r\npr_debug("%s(): RxIRQ ERR:iRxIntType=%x,HostIntType=%x,CurCount=%x,RxLastCount=%x_____\n",\r\n__func__, iRxIntType, iHostIntType,\r\nRxCurCount(iobase, self), self->RxLastCount);\r\nif (iRxIntType & 0x20) {\r\nResetChip(iobase, 0);\r\nResetChip(iobase, 1);\r\n} else {\r\nif (iRxIntType != 0x08)\r\nhwreset(self);\r\n}\r\nvia_ircc_dma_receive(self);\r\n}\r\n}\r\nspin_unlock(&self->lock);\r\nreturn IRQ_RETVAL(iHostIntType);\r\n}\r\nstatic void hwreset(struct via_ircc_cb *self)\r\n{\r\nint iobase;\r\niobase = self->io.fir_base;\r\nResetChip(iobase, 5);\r\nEnableDMA(iobase, OFF);\r\nEnableTX(iobase, OFF);\r\nEnableRX(iobase, OFF);\r\nEnRXDMA(iobase, OFF);\r\nEnTXDMA(iobase, OFF);\r\nRXStart(iobase, OFF);\r\nTXStart(iobase, OFF);\r\nInitCard(iobase);\r\nCommonInit(iobase);\r\nSIRFilter(iobase, ON);\r\nSetSIR(iobase, ON);\r\nCRC16(iobase, ON);\r\nEnTXCRC(iobase, 0);\r\nWriteReg(iobase, I_ST_CT_0, 0x00);\r\nSetBaudRate(iobase, 9600);\r\nSetPulseWidth(iobase, 12);\r\nSetSendPreambleCount(iobase, 0);\r\nWriteReg(iobase, I_ST_CT_0, 0x80);\r\nvia_ircc_change_speed(self, self->io.speed);\r\nself->st_fifo.len = 0;\r\n}\r\nstatic int via_ircc_is_receiving(struct via_ircc_cb *self)\r\n{\r\nint status = FALSE;\r\nint iobase;\r\nIRDA_ASSERT(self != NULL, return FALSE;);\r\niobase = self->io.fir_base;\r\nif (CkRxRecv(iobase, self))\r\nstatus = TRUE;\r\npr_debug("%s(): status=%x....\n", __func__, status);\r\nreturn status;\r\n}\r\nstatic int via_ircc_net_open(struct net_device *dev)\r\n{\r\nstruct via_ircc_cb *self;\r\nint iobase;\r\nchar hwname[32];\r\nIRDA_ASSERT(dev != NULL, return -1;);\r\nself = netdev_priv(dev);\r\ndev->stats.rx_packets = 0;\r\nIRDA_ASSERT(self != NULL, return 0;);\r\niobase = self->io.fir_base;\r\nif (request_irq(self->io.irq, via_ircc_interrupt, 0, dev->name, dev)) {\r\nnet_warn_ratelimited("%s, unable to allocate irq=%d\n",\r\ndriver_name, self->io.irq);\r\nreturn -EAGAIN;\r\n}\r\nif (request_dma(self->io.dma, dev->name)) {\r\nnet_warn_ratelimited("%s, unable to allocate dma=%d\n",\r\ndriver_name, self->io.dma);\r\nfree_irq(self->io.irq, dev);\r\nreturn -EAGAIN;\r\n}\r\nif (self->io.dma2 != self->io.dma) {\r\nif (request_dma(self->io.dma2, dev->name)) {\r\nnet_warn_ratelimited("%s, unable to allocate dma2=%d\n",\r\ndriver_name, self->io.dma2);\r\nfree_irq(self->io.irq, dev);\r\nfree_dma(self->io.dma);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nEnAllInt(iobase, ON);\r\nEnInternalLoop(iobase, OFF);\r\nEnExternalLoop(iobase, OFF);\r\nvia_ircc_dma_receive(self);\r\nnetif_start_queue(dev);\r\nsprintf(hwname, "VIA @ 0x%x", iobase);\r\nself->irlap = irlap_open(dev, &self->qos, hwname);\r\nself->RxLastCount = 0;\r\nreturn 0;\r\n}\r\nstatic int via_ircc_net_close(struct net_device *dev)\r\n{\r\nstruct via_ircc_cb *self;\r\nint iobase;\r\nIRDA_ASSERT(dev != NULL, return -1;);\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT(self != NULL, return 0;);\r\nnetif_stop_queue(dev);\r\nif (self->irlap)\r\nirlap_close(self->irlap);\r\nself->irlap = NULL;\r\niobase = self->io.fir_base;\r\nEnTXDMA(iobase, OFF);\r\nEnRXDMA(iobase, OFF);\r\nDisableDmaChannel(self->io.dma);\r\nEnAllInt(iobase, OFF);\r\nfree_irq(self->io.irq, dev);\r\nfree_dma(self->io.dma);\r\nif (self->io.dma2 != self->io.dma)\r\nfree_dma(self->io.dma2);\r\nreturn 0;\r\n}\r\nstatic int via_ircc_net_ioctl(struct net_device *dev, struct ifreq *rq,\r\nint cmd)\r\n{\r\nstruct if_irda_req *irq = (struct if_irda_req *) rq;\r\nstruct via_ircc_cb *self;\r\nunsigned long flags;\r\nint ret = 0;\r\nIRDA_ASSERT(dev != NULL, return -1;);\r\nself = netdev_priv(dev);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\npr_debug("%s(), %s, (cmd=0x%X)\n", __func__, dev->name,\r\ncmd);\r\nspin_lock_irqsave(&self->lock, flags);\r\nswitch (cmd) {\r\ncase SIOCSBANDWIDTH:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nvia_ircc_change_speed(self, irq->ifr_baudrate);\r\nbreak;\r\ncase SIOCSMEDIABUSY:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nret = -EPERM;\r\ngoto out;\r\n}\r\nirda_device_set_media_busy(self->netdev, TRUE);\r\nbreak;\r\ncase SIOCGRECEIVING:\r\nirq->ifr_receiving = via_ircc_is_receiving(self);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&self->lock, flags);\r\nreturn ret;\r\n}
