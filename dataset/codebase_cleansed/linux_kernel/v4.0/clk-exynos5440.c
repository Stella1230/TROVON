static int exynos5440_clk_restart_notify(struct notifier_block *this,\r\nunsigned long code, void *unused)\r\n{\r\nu32 val, status;\r\nstatus = readl_relaxed(reg_base + 0xbc);\r\nval = readl_relaxed(reg_base + 0xcc);\r\nval = (val & 0xffff0000) | (status & 0xffff);\r\nwritel_relaxed(val, reg_base + 0xcc);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void __init exynos5440_clk_init(struct device_node *np)\r\n{\r\nstruct samsung_clk_provider *ctx;\r\nreg_base = of_iomap(np, 0);\r\nif (!reg_base) {\r\npr_err("%s: failed to map clock controller registers,"\r\n" aborting clock initialization\n", __func__);\r\nreturn;\r\n}\r\nctx = samsung_clk_init(np, reg_base, CLK_NR_CLKS);\r\nif (!ctx)\r\npanic("%s: unable to allocate context.\n", __func__);\r\nsamsung_clk_of_register_fixed_ext(ctx, exynos5440_fixed_rate_ext_clks,\r\nARRAY_SIZE(exynos5440_fixed_rate_ext_clks), ext_clk_match);\r\nsamsung_clk_register_pll2550x("cplla", "xtal", reg_base + 0x1c, 0x10);\r\nsamsung_clk_register_pll2550x("cpllb", "xtal", reg_base + 0x20, 0x10);\r\nsamsung_clk_register_fixed_rate(ctx, exynos5440_fixed_rate_clks,\r\nARRAY_SIZE(exynos5440_fixed_rate_clks));\r\nsamsung_clk_register_fixed_factor(ctx, exynos5440_fixed_factor_clks,\r\nARRAY_SIZE(exynos5440_fixed_factor_clks));\r\nsamsung_clk_register_mux(ctx, exynos5440_mux_clks,\r\nARRAY_SIZE(exynos5440_mux_clks));\r\nsamsung_clk_register_div(ctx, exynos5440_div_clks,\r\nARRAY_SIZE(exynos5440_div_clks));\r\nsamsung_clk_register_gate(ctx, exynos5440_gate_clks,\r\nARRAY_SIZE(exynos5440_gate_clks));\r\nsamsung_clk_of_add_provider(np, ctx);\r\nif (register_restart_handler(&exynos5440_clk_restart_handler))\r\npr_warn("exynos5440 clock can't register restart handler\n");\r\npr_info("Exynos5440: arm_clk = %ldHz\n", _get_rate("arm_clk"));\r\npr_info("exynos5440 clock initialization complete\n");\r\n}
