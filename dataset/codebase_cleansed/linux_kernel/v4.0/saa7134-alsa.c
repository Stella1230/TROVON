static void saa7134_dma_stop(struct saa7134_dev *dev)\r\n{\r\ndev->dmasound.dma_blk = -1;\r\ndev->dmasound.dma_running = 0;\r\nsaa7134_set_dmabits(dev);\r\n}\r\nstatic void saa7134_dma_start(struct saa7134_dev *dev)\r\n{\r\ndev->dmasound.dma_blk = 0;\r\ndev->dmasound.dma_running = 1;\r\nsaa7134_set_dmabits(dev);\r\n}\r\nstatic void saa7134_irq_alsa_done(struct saa7134_dev *dev,\r\nunsigned long status)\r\n{\r\nint next_blk, reg = 0;\r\nspin_lock(&dev->slock);\r\nif (UNSET == dev->dmasound.dma_blk) {\r\ndprintk("irq: recording stopped\n");\r\ngoto done;\r\n}\r\nif (0 != (status & 0x0f000000))\r\ndprintk("irq: lost %ld\n", (status >> 24) & 0x0f);\r\nif (0 == (status & 0x10000000)) {\r\nif (0 == (dev->dmasound.dma_blk & 0x01))\r\nreg = SAA7134_RS_BA1(6);\r\n} else {\r\nif (1 == (dev->dmasound.dma_blk & 0x01))\r\nreg = SAA7134_RS_BA2(6);\r\n}\r\nif (0 == reg) {\r\ndprintk("irq: field oops [%s]\n",\r\n(status & 0x10000000) ? "even" : "odd");\r\ngoto done;\r\n}\r\nif (dev->dmasound.read_count >= dev->dmasound.blksize * (dev->dmasound.blocks-2)) {\r\ndprintk("irq: overrun [full=%d/%d] - Blocks in %d\n",dev->dmasound.read_count,\r\ndev->dmasound.bufsize, dev->dmasound.blocks);\r\nspin_unlock(&dev->slock);\r\nsnd_pcm_stop_xrun(dev->dmasound.substream);\r\nreturn;\r\n}\r\nnext_blk = (dev->dmasound.dma_blk + 2) % dev->dmasound.blocks;\r\nsaa_writel(reg,next_blk * dev->dmasound.blksize);\r\nif (debug > 2)\r\ndprintk("irq: ok, %s, next_blk=%d, addr=%x, blocks=%u, size=%u, read=%u\n",\r\n(status & 0x10000000) ? "even" : "odd ", next_blk,\r\nnext_blk * dev->dmasound.blksize, dev->dmasound.blocks, dev->dmasound.blksize, dev->dmasound.read_count);\r\ndev->dmasound.dma_blk = (dev->dmasound.dma_blk + 1) % dev->dmasound.blocks;\r\ndev->dmasound.read_count += dev->dmasound.blksize;\r\ndev->dmasound.recording_on = reg;\r\nif (dev->dmasound.read_count >= snd_pcm_lib_period_bytes(dev->dmasound.substream)) {\r\nspin_unlock(&dev->slock);\r\nsnd_pcm_period_elapsed(dev->dmasound.substream);\r\nspin_lock(&dev->slock);\r\n}\r\ndone:\r\nspin_unlock(&dev->slock);\r\n}\r\nstatic irqreturn_t saa7134_alsa_irq(int irq, void *dev_id)\r\n{\r\nstruct saa7134_dmasound *dmasound = dev_id;\r\nstruct saa7134_dev *dev = dmasound->priv_data;\r\nunsigned long report, status;\r\nint loop, handled = 0;\r\nfor (loop = 0; loop < 10; loop++) {\r\nreport = saa_readl(SAA7134_IRQ_REPORT);\r\nstatus = saa_readl(SAA7134_IRQ_STATUS);\r\nif (report & SAA7134_IRQ_REPORT_DONE_RA3) {\r\nhandled = 1;\r\nsaa_writel(SAA7134_IRQ_REPORT,\r\nSAA7134_IRQ_REPORT_DONE_RA3);\r\nsaa7134_irq_alsa_done(dev, status);\r\n} else {\r\ngoto out;\r\n}\r\n}\r\nif (loop == 10) {\r\ndprintk("error! looping IRQ!");\r\n}\r\nout:\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int snd_card_saa7134_capture_trigger(struct snd_pcm_substream * substream,\r\nint cmd)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_card_saa7134_pcm_t *pcm = runtime->private_data;\r\nstruct saa7134_dev *dev=pcm->dev;\r\nint err = 0;\r\nspin_lock(&dev->slock);\r\nif (cmd == SNDRV_PCM_TRIGGER_START) {\r\nsaa7134_dma_start(dev);\r\n} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\r\nsaa7134_dma_stop(dev);\r\n} else {\r\nerr = -EINVAL;\r\n}\r\nspin_unlock(&dev->slock);\r\nreturn err;\r\n}\r\nstatic int saa7134_alsa_dma_init(struct saa7134_dev *dev, int nr_pages)\r\n{\r\nstruct saa7134_dmasound *dma = &dev->dmasound;\r\nstruct page *pg;\r\nint i;\r\ndma->vaddr = vmalloc_32(nr_pages << PAGE_SHIFT);\r\nif (NULL == dma->vaddr) {\r\ndprintk("vmalloc_32(%d pages) failed\n", nr_pages);\r\nreturn -ENOMEM;\r\n}\r\ndprintk("vmalloc is at addr 0x%08lx, size=%d\n",\r\n(unsigned long)dma->vaddr,\r\nnr_pages << PAGE_SHIFT);\r\nmemset(dma->vaddr, 0, nr_pages << PAGE_SHIFT);\r\ndma->nr_pages = nr_pages;\r\ndma->sglist = vzalloc(dma->nr_pages * sizeof(*dma->sglist));\r\nif (NULL == dma->sglist)\r\ngoto vzalloc_err;\r\nsg_init_table(dma->sglist, dma->nr_pages);\r\nfor (i = 0; i < dma->nr_pages; i++) {\r\npg = vmalloc_to_page(dma->vaddr + i * PAGE_SIZE);\r\nif (NULL == pg)\r\ngoto vmalloc_to_page_err;\r\nsg_set_page(&dma->sglist[i], pg, PAGE_SIZE, 0);\r\n}\r\nreturn 0;\r\nvmalloc_to_page_err:\r\nvfree(dma->sglist);\r\ndma->sglist = NULL;\r\nvzalloc_err:\r\nvfree(dma->vaddr);\r\ndma->vaddr = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic int saa7134_alsa_dma_map(struct saa7134_dev *dev)\r\n{\r\nstruct saa7134_dmasound *dma = &dev->dmasound;\r\ndma->sglen = dma_map_sg(&dev->pci->dev, dma->sglist,\r\ndma->nr_pages, PCI_DMA_FROMDEVICE);\r\nif (0 == dma->sglen) {\r\npr_warn("%s: saa7134_alsa_map_sg failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7134_alsa_dma_unmap(struct saa7134_dev *dev)\r\n{\r\nstruct saa7134_dmasound *dma = &dev->dmasound;\r\nif (!dma->sglen)\r\nreturn 0;\r\ndma_unmap_sg(&dev->pci->dev, dma->sglist, dma->sglen, PCI_DMA_FROMDEVICE);\r\ndma->sglen = 0;\r\nreturn 0;\r\n}\r\nstatic int saa7134_alsa_dma_free(struct saa7134_dmasound *dma)\r\n{\r\nvfree(dma->sglist);\r\ndma->sglist = NULL;\r\nvfree(dma->vaddr);\r\ndma->vaddr = NULL;\r\nreturn 0;\r\n}\r\nstatic int dsp_buffer_init(struct saa7134_dev *dev)\r\n{\r\nint err;\r\nBUG_ON(!dev->dmasound.bufsize);\r\nerr = saa7134_alsa_dma_init(dev,\r\n(dev->dmasound.bufsize + PAGE_SIZE) >> PAGE_SHIFT);\r\nif (0 != err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int dsp_buffer_free(struct saa7134_dev *dev)\r\n{\r\nBUG_ON(!dev->dmasound.blksize);\r\nsaa7134_alsa_dma_free(&dev->dmasound);\r\ndev->dmasound.blocks = 0;\r\ndev->dmasound.blksize = 0;\r\ndev->dmasound.bufsize = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_saa7134_capsrc_set(struct snd_kcontrol *kcontrol,\r\nint left, int right, bool force_notify)\r\n{\r\nsnd_card_saa7134_t *chip = snd_kcontrol_chip(kcontrol);\r\nint change = 0, addr = kcontrol->private_value;\r\nint active, old_addr;\r\nu32 anabar, xbarin;\r\nint analog_io, rate;\r\nstruct saa7134_dev *dev;\r\ndev = chip->dev;\r\nspin_lock_irq(&chip->mixer_lock);\r\nactive = left != 0 || right != 0;\r\nold_addr = chip->capture_source_addr;\r\nif (active) {\r\nchange = old_addr != addr ||\r\nchip->capture_source[0] != left ||\r\nchip->capture_source[1] != right;\r\nchip->capture_source[0] = left;\r\nchip->capture_source[1] = right;\r\nchip->capture_source_addr = addr;\r\ndev->dmasound.input = addr;\r\n}\r\nspin_unlock_irq(&chip->mixer_lock);\r\nif (change) {\r\nswitch (dev->pci->device) {\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7134:\r\nswitch (addr) {\r\ncase MIXER_ADDR_TVTUNER:\r\nsaa_andorb(SAA7134_AUDIO_FORMAT_CTRL,\r\n0xc0, 0xc0);\r\nsaa_andorb(SAA7134_SIF_SAMPLE_FREQ,\r\n0x03, 0x00);\r\nbreak;\r\ncase MIXER_ADDR_LINE1:\r\ncase MIXER_ADDR_LINE2:\r\nanalog_io = (MIXER_ADDR_LINE1 == addr) ?\r\n0x00 : 0x08;\r\nrate = (32000 == dev->dmasound.rate) ?\r\n0x01 : 0x03;\r\nsaa_andorb(SAA7134_ANALOG_IO_SELECT,\r\n0x08, analog_io);\r\nsaa_andorb(SAA7134_AUDIO_FORMAT_CTRL,\r\n0xc0, 0x80);\r\nsaa_andorb(SAA7134_SIF_SAMPLE_FREQ,\r\n0x03, rate);\r\nbreak;\r\n}\r\nbreak;\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7133:\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7135:\r\nxbarin = 0x03;\r\nanabar = 0;\r\nswitch (addr) {\r\ncase MIXER_ADDR_TVTUNER:\r\nxbarin = 0;\r\nanabar = 2;\r\nbreak;\r\ncase MIXER_ADDR_LINE1:\r\nanabar = 0;\r\nbreak;\r\ncase MIXER_ADDR_LINE2:\r\nanabar = 9;\r\nbreak;\r\n}\r\nsaa_dsp_writel(dev, SAA7133_DIGITAL_OUTPUT_SEL1,\r\n0xbbbb10);\r\nif (left || right) {\r\nsaa_dsp_writel(dev, SAA7133_DIGITAL_INPUT_XBAR1,\r\nxbarin);\r\nsaa_writel(SAA7133_ANALOG_IO_SELECT, anabar);\r\n} else {\r\nsaa_dsp_writel(dev, SAA7133_DIGITAL_INPUT_XBAR1,\r\n0);\r\nsaa_writel(SAA7133_ANALOG_IO_SELECT, 0);\r\n}\r\nbreak;\r\n}\r\n}\r\nif (change) {\r\nif (force_notify)\r\nsnd_ctl_notify(chip->card,\r\nSNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->capture_ctl[addr]->id);\r\nif (old_addr != MIXER_ADDR_UNSELECTED && old_addr != addr)\r\nsnd_ctl_notify(chip->card,\r\nSNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->capture_ctl[old_addr]->id);\r\n}\r\nreturn change;\r\n}\r\nstatic int snd_card_saa7134_capture_prepare(struct snd_pcm_substream * substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint bswap, sign;\r\nu32 fmt, control;\r\nsnd_card_saa7134_t *saa7134 = snd_pcm_substream_chip(substream);\r\nstruct saa7134_dev *dev;\r\nsnd_card_saa7134_pcm_t *pcm = runtime->private_data;\r\npcm->dev->dmasound.substream = substream;\r\ndev = saa7134->dev;\r\nif (snd_pcm_format_width(runtime->format) == 8)\r\nfmt = 0x00;\r\nelse\r\nfmt = 0x01;\r\nif (snd_pcm_format_signed(runtime->format))\r\nsign = 1;\r\nelse\r\nsign = 0;\r\nif (snd_pcm_format_big_endian(runtime->format))\r\nbswap = 1;\r\nelse\r\nbswap = 0;\r\nswitch (dev->pci->device) {\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7134:\r\nif (1 == runtime->channels)\r\nfmt |= (1 << 3);\r\nif (2 == runtime->channels)\r\nfmt |= (3 << 3);\r\nif (sign)\r\nfmt |= 0x04;\r\nfmt |= (MIXER_ADDR_TVTUNER == dev->dmasound.input) ? 0xc0 : 0x80;\r\nsaa_writeb(SAA7134_NUM_SAMPLES0, ((dev->dmasound.blksize - 1) & 0x0000ff));\r\nsaa_writeb(SAA7134_NUM_SAMPLES1, ((dev->dmasound.blksize - 1) & 0x00ff00) >> 8);\r\nsaa_writeb(SAA7134_NUM_SAMPLES2, ((dev->dmasound.blksize - 1) & 0xff0000) >> 16);\r\nsaa_writeb(SAA7134_AUDIO_FORMAT_CTRL, fmt);\r\nbreak;\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7133:\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7135:\r\nif (1 == runtime->channels)\r\nfmt |= (1 << 4);\r\nif (2 == runtime->channels)\r\nfmt |= (2 << 4);\r\nif (!sign)\r\nfmt |= 0x04;\r\nsaa_writel(SAA7133_NUM_SAMPLES, dev->dmasound.blksize -1);\r\nsaa_writel(SAA7133_AUDIO_CHANNEL, 0x543210 | (fmt << 24));\r\nbreak;\r\n}\r\ndprintk("rec_start: afmt=%d ch=%d => fmt=0x%x swap=%c\n",\r\nruntime->format, runtime->channels, fmt,\r\nbswap ? 'b' : '-');\r\ncontrol = SAA7134_RS_CONTROL_BURST_16 |\r\nSAA7134_RS_CONTROL_ME |\r\n(dev->dmasound.pt.dma >> 12);\r\nif (bswap)\r\ncontrol |= SAA7134_RS_CONTROL_BSWAP;\r\nsaa_writel(SAA7134_RS_BA1(6),0);\r\nsaa_writel(SAA7134_RS_BA2(6),dev->dmasound.blksize);\r\nsaa_writel(SAA7134_RS_PITCH(6),0);\r\nsaa_writel(SAA7134_RS_CONTROL(6),control);\r\ndev->dmasound.rate = runtime->rate;\r\nsnd_saa7134_capsrc_set(saa7134->capture_ctl[dev->dmasound.input], 1, 1,\r\ntrue);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_card_saa7134_capture_pointer(struct snd_pcm_substream * substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_card_saa7134_pcm_t *pcm = runtime->private_data;\r\nstruct saa7134_dev *dev=pcm->dev;\r\nif (dev->dmasound.read_count) {\r\ndev->dmasound.read_count -= snd_pcm_lib_period_bytes(substream);\r\ndev->dmasound.read_offset += snd_pcm_lib_period_bytes(substream);\r\nif (dev->dmasound.read_offset == dev->dmasound.bufsize)\r\ndev->dmasound.read_offset = 0;\r\n}\r\nreturn bytes_to_frames(runtime, dev->dmasound.read_offset);\r\n}\r\nstatic void snd_card_saa7134_runtime_free(struct snd_pcm_runtime *runtime)\r\n{\r\nsnd_card_saa7134_pcm_t *pcm = runtime->private_data;\r\nkfree(pcm);\r\n}\r\nstatic int snd_card_saa7134_hw_params(struct snd_pcm_substream * substream,\r\nstruct snd_pcm_hw_params * hw_params)\r\n{\r\nsnd_card_saa7134_t *saa7134 = snd_pcm_substream_chip(substream);\r\nstruct saa7134_dev *dev;\r\nunsigned int period_size, periods;\r\nint err;\r\nperiod_size = params_period_bytes(hw_params);\r\nperiods = params_periods(hw_params);\r\nif (period_size < 0x100 || period_size > 0x10000)\r\nreturn -EINVAL;\r\nif (periods < 4)\r\nreturn -EINVAL;\r\nif (period_size * periods > 1024 * 1024)\r\nreturn -EINVAL;\r\ndev = saa7134->dev;\r\nif (dev->dmasound.blocks == periods &&\r\ndev->dmasound.blksize == period_size)\r\nreturn 0;\r\nif (substream->runtime->dma_area) {\r\nsaa7134_pgtable_free(dev->pci, &dev->dmasound.pt);\r\nsaa7134_alsa_dma_unmap(dev);\r\ndsp_buffer_free(dev);\r\nsubstream->runtime->dma_area = NULL;\r\n}\r\ndev->dmasound.blocks = periods;\r\ndev->dmasound.blksize = period_size;\r\ndev->dmasound.bufsize = period_size * periods;\r\nerr = dsp_buffer_init(dev);\r\nif (0 != err) {\r\ndev->dmasound.blocks = 0;\r\ndev->dmasound.blksize = 0;\r\ndev->dmasound.bufsize = 0;\r\nreturn err;\r\n}\r\nerr = saa7134_alsa_dma_map(dev);\r\nif (err) {\r\ndsp_buffer_free(dev);\r\nreturn err;\r\n}\r\nerr = saa7134_pgtable_alloc(dev->pci, &dev->dmasound.pt);\r\nif (err) {\r\nsaa7134_alsa_dma_unmap(dev);\r\ndsp_buffer_free(dev);\r\nreturn err;\r\n}\r\nerr = saa7134_pgtable_build(dev->pci, &dev->dmasound.pt,\r\ndev->dmasound.sglist, dev->dmasound.sglen, 0);\r\nif (err) {\r\nsaa7134_pgtable_free(dev->pci, &dev->dmasound.pt);\r\nsaa7134_alsa_dma_unmap(dev);\r\ndsp_buffer_free(dev);\r\nreturn err;\r\n}\r\nsubstream->runtime->dma_area = dev->dmasound.vaddr;\r\nsubstream->runtime->dma_bytes = dev->dmasound.bufsize;\r\nsubstream->runtime->dma_addr = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_card_saa7134_hw_free(struct snd_pcm_substream * substream)\r\n{\r\nsnd_card_saa7134_t *saa7134 = snd_pcm_substream_chip(substream);\r\nstruct saa7134_dev *dev;\r\ndev = saa7134->dev;\r\nif (substream->runtime->dma_area) {\r\nsaa7134_pgtable_free(dev->pci, &dev->dmasound.pt);\r\nsaa7134_alsa_dma_unmap(dev);\r\ndsp_buffer_free(dev);\r\nsubstream->runtime->dma_area = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_card_saa7134_capture_close(struct snd_pcm_substream * substream)\r\n{\r\nsnd_card_saa7134_t *saa7134 = snd_pcm_substream_chip(substream);\r\nstruct saa7134_dev *dev = saa7134->dev;\r\nif (saa7134->mute_was_on) {\r\ndev->ctl_mute = 1;\r\nsaa7134_tvaudio_setmute(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_card_saa7134_capture_open(struct snd_pcm_substream * substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_card_saa7134_pcm_t *pcm;\r\nsnd_card_saa7134_t *saa7134 = snd_pcm_substream_chip(substream);\r\nstruct saa7134_dev *dev;\r\nint amux, err;\r\nif (!saa7134) {\r\nprintk(KERN_ERR "BUG: saa7134 can't find device struct."\r\n" Can't proceed with open\n");\r\nreturn -ENODEV;\r\n}\r\ndev = saa7134->dev;\r\nmutex_lock(&dev->dmasound.lock);\r\ndev->dmasound.read_count = 0;\r\ndev->dmasound.read_offset = 0;\r\namux = dev->input->amux;\r\nif ((amux < 1) || (amux > 3))\r\namux = 1;\r\ndev->dmasound.input = amux - 1;\r\nmutex_unlock(&dev->dmasound.lock);\r\npcm = kzalloc(sizeof(*pcm), GFP_KERNEL);\r\nif (pcm == NULL)\r\nreturn -ENOMEM;\r\npcm->dev=saa7134->dev;\r\nspin_lock_init(&pcm->lock);\r\npcm->substream = substream;\r\nruntime->private_data = pcm;\r\nruntime->private_free = snd_card_saa7134_runtime_free;\r\nruntime->hw = snd_card_saa7134_capture;\r\nif (dev->ctl_mute != 0) {\r\nsaa7134->mute_was_on = 1;\r\ndev->ctl_mute = 0;\r\nsaa7134_tvaudio_setmute(dev);\r\n}\r\nerr = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIODS, 2);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic struct page *snd_card_saa7134_page(struct snd_pcm_substream *substream,\r\nunsigned long offset)\r\n{\r\nvoid *pageptr = substream->runtime->dma_area + offset;\r\nreturn vmalloc_to_page(pageptr);\r\n}\r\nstatic int snd_card_saa7134_pcm(snd_card_saa7134_t *saa7134, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif ((err = snd_pcm_new(saa7134->card, "SAA7134 PCM", device, 0, 1, &pcm)) < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_card_saa7134_capture_ops);\r\npcm->private_data = saa7134;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "SAA7134 PCM");\r\nreturn 0;\r\n}\r\nstatic int snd_saa7134_volume_info(struct snd_kcontrol * kcontrol,\r\nstruct snd_ctl_elem_info * uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 20;\r\nreturn 0;\r\n}\r\nstatic int snd_saa7134_volume_get(struct snd_kcontrol * kcontrol,\r\nstruct snd_ctl_elem_value * ucontrol)\r\n{\r\nsnd_card_saa7134_t *chip = snd_kcontrol_chip(kcontrol);\r\nint addr = kcontrol->private_value;\r\nucontrol->value.integer.value[0] = chip->mixer_volume[addr][0];\r\nucontrol->value.integer.value[1] = chip->mixer_volume[addr][1];\r\nreturn 0;\r\n}\r\nstatic int snd_saa7134_volume_put(struct snd_kcontrol * kcontrol,\r\nstruct snd_ctl_elem_value * ucontrol)\r\n{\r\nsnd_card_saa7134_t *chip = snd_kcontrol_chip(kcontrol);\r\nstruct saa7134_dev *dev = chip->dev;\r\nint change, addr = kcontrol->private_value;\r\nint left, right;\r\nleft = ucontrol->value.integer.value[0];\r\nif (left < 0)\r\nleft = 0;\r\nif (left > 20)\r\nleft = 20;\r\nright = ucontrol->value.integer.value[1];\r\nif (right < 0)\r\nright = 0;\r\nif (right > 20)\r\nright = 20;\r\nspin_lock_irq(&chip->mixer_lock);\r\nchange = 0;\r\nif (chip->mixer_volume[addr][0] != left) {\r\nchange = 1;\r\nright = left;\r\n}\r\nif (chip->mixer_volume[addr][1] != right) {\r\nchange = 1;\r\nleft = right;\r\n}\r\nif (change) {\r\nswitch (dev->pci->device) {\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7134:\r\nswitch (addr) {\r\ncase MIXER_ADDR_TVTUNER:\r\nleft = 20;\r\nbreak;\r\ncase MIXER_ADDR_LINE1:\r\nsaa_andorb(SAA7134_ANALOG_IO_SELECT, 0x10,\r\n(left > 10) ? 0x00 : 0x10);\r\nbreak;\r\ncase MIXER_ADDR_LINE2:\r\nsaa_andorb(SAA7134_ANALOG_IO_SELECT, 0x20,\r\n(left > 10) ? 0x00 : 0x20);\r\nbreak;\r\n}\r\nbreak;\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7133:\r\ncase PCI_DEVICE_ID_PHILIPS_SAA7135:\r\nswitch (addr) {\r\ncase MIXER_ADDR_TVTUNER:\r\nleft = 20;\r\nbreak;\r\ncase MIXER_ADDR_LINE1:\r\nsaa_andorb(0x0594, 0x10,\r\n(left > 10) ? 0x00 : 0x10);\r\nbreak;\r\ncase MIXER_ADDR_LINE2:\r\nsaa_andorb(0x0594, 0x20,\r\n(left > 10) ? 0x00 : 0x20);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nchip->mixer_volume[addr][0] = left;\r\nchip->mixer_volume[addr][1] = right;\r\n}\r\nspin_unlock_irq(&chip->mixer_lock);\r\nreturn change;\r\n}\r\nstatic int snd_saa7134_capsrc_info(struct snd_kcontrol * kcontrol,\r\nstruct snd_ctl_elem_info * uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_saa7134_capsrc_get(struct snd_kcontrol * kcontrol,\r\nstruct snd_ctl_elem_value * ucontrol)\r\n{\r\nsnd_card_saa7134_t *chip = snd_kcontrol_chip(kcontrol);\r\nint addr = kcontrol->private_value;\r\nspin_lock_irq(&chip->mixer_lock);\r\nif (chip->capture_source_addr == addr) {\r\nucontrol->value.integer.value[0] = chip->capture_source[0];\r\nucontrol->value.integer.value[1] = chip->capture_source[1];\r\n} else {\r\nucontrol->value.integer.value[0] = 0;\r\nucontrol->value.integer.value[1] = 0;\r\n}\r\nspin_unlock_irq(&chip->mixer_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_saa7134_capsrc_put(struct snd_kcontrol * kcontrol,\r\nstruct snd_ctl_elem_value * ucontrol)\r\n{\r\nint left, right;\r\nleft = ucontrol->value.integer.value[0] & 1;\r\nright = ucontrol->value.integer.value[1] & 1;\r\nreturn snd_saa7134_capsrc_set(kcontrol, left, right, false);\r\n}\r\nstatic int snd_card_saa7134_new_mixer(snd_card_saa7134_t * chip)\r\n{\r\nstruct snd_card *card = chip->card;\r\nstruct snd_kcontrol *kcontrol;\r\nunsigned int idx;\r\nint err, addr;\r\nstrcpy(card->mixername, "SAA7134 Mixer");\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_saa7134_volume_controls); idx++) {\r\nkcontrol = snd_ctl_new1(&snd_saa7134_volume_controls[idx],\r\nchip);\r\nerr = snd_ctl_add(card, kcontrol);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_saa7134_capture_controls); idx++) {\r\nkcontrol = snd_ctl_new1(&snd_saa7134_capture_controls[idx],\r\nchip);\r\naddr = snd_saa7134_capture_controls[idx].private_value;\r\nchip->capture_ctl[addr] = kcontrol;\r\nerr = snd_ctl_add(card, kcontrol);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nchip->capture_source_addr = MIXER_ADDR_UNSELECTED;\r\nreturn 0;\r\n}\r\nstatic void snd_saa7134_free(struct snd_card * card)\r\n{\r\nsnd_card_saa7134_t *chip = card->private_data;\r\nif (chip->dev->dmasound.priv_data == NULL)\r\nreturn;\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, &chip->dev->dmasound);\r\nchip->dev->dmasound.priv_data = NULL;\r\n}\r\nstatic int alsa_card_saa7134_create(struct saa7134_dev *dev, int devnum)\r\n{\r\nstruct snd_card *card;\r\nsnd_card_saa7134_t *chip;\r\nint err;\r\nif (devnum >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[devnum])\r\nreturn -ENODEV;\r\nerr = snd_card_new(&dev->pci->dev, index[devnum], id[devnum],\r\nTHIS_MODULE, sizeof(snd_card_saa7134_t), &card);\r\nif (err < 0)\r\nreturn err;\r\nstrcpy(card->driver, "SAA7134");\r\ncard->private_free = snd_saa7134_free;\r\nchip = card->private_data;\r\nspin_lock_init(&chip->lock);\r\nspin_lock_init(&chip->mixer_lock);\r\nchip->dev = dev;\r\nchip->card = card;\r\nchip->pci = dev->pci;\r\nchip->iobase = pci_resource_start(dev->pci, 0);\r\nerr = request_irq(dev->pci->irq, saa7134_alsa_irq,\r\nIRQF_SHARED, dev->name,\r\n(void*) &dev->dmasound);\r\nif (err < 0) {\r\nprintk(KERN_ERR "%s: can't get IRQ %d for ALSA\n",\r\ndev->name, dev->pci->irq);\r\ngoto __nodev;\r\n}\r\nchip->irq = dev->pci->irq;\r\nmutex_init(&dev->dmasound.lock);\r\nif ((err = snd_card_saa7134_new_mixer(chip)) < 0)\r\ngoto __nodev;\r\nif ((err = snd_card_saa7134_pcm(chip, 0)) < 0)\r\ngoto __nodev;\r\nstrcpy(card->shortname, "SAA7134");\r\nsprintf(card->longname, "%s at 0x%lx irq %d",\r\nchip->dev->name, chip->iobase, chip->irq);\r\nprintk(KERN_INFO "%s/alsa: %s registered as card %d\n",dev->name,card->longname,index[devnum]);\r\nif ((err = snd_card_register(card)) == 0) {\r\nsnd_saa7134_cards[devnum] = card;\r\nreturn 0;\r\n}\r\n__nodev:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic int alsa_device_init(struct saa7134_dev *dev)\r\n{\r\ndev->dmasound.priv_data = dev;\r\nalsa_card_saa7134_create(dev,dev->nr);\r\nreturn 1;\r\n}\r\nstatic int alsa_device_exit(struct saa7134_dev *dev)\r\n{\r\nsnd_card_free(snd_saa7134_cards[dev->nr]);\r\nsnd_saa7134_cards[dev->nr] = NULL;\r\nreturn 1;\r\n}\r\nstatic int saa7134_alsa_init(void)\r\n{\r\nstruct saa7134_dev *dev = NULL;\r\nstruct list_head *list;\r\nsaa7134_dmasound_init = alsa_device_init;\r\nsaa7134_dmasound_exit = alsa_device_exit;\r\nprintk(KERN_INFO "saa7134 ALSA driver for DMA sound loaded\n");\r\nlist_for_each(list,&saa7134_devlist) {\r\ndev = list_entry(list, struct saa7134_dev, devlist);\r\nif (dev->pci->device == PCI_DEVICE_ID_PHILIPS_SAA7130)\r\nprintk(KERN_INFO "%s/alsa: %s doesn't support digital audio\n",\r\ndev->name, saa7134_boards[dev->board].name);\r\nelse\r\nalsa_device_init(dev);\r\n}\r\nif (dev == NULL)\r\nprintk(KERN_INFO "saa7134 ALSA: no saa7134 cards found\n");\r\nreturn 0;\r\n}\r\nstatic void saa7134_alsa_exit(void)\r\n{\r\nint idx;\r\nfor (idx = 0; idx < SNDRV_CARDS; idx++) {\r\nsnd_card_free(snd_saa7134_cards[idx]);\r\n}\r\nsaa7134_dmasound_init = NULL;\r\nsaa7134_dmasound_exit = NULL;\r\nprintk(KERN_INFO "saa7134 ALSA driver for DMA sound unloaded\n");\r\nreturn;\r\n}
