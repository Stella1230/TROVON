static void *ion_page_pool_alloc_pages(struct ion_page_pool *pool)\r\n{\r\nstruct page *page = alloc_pages(pool->gfp_mask, pool->order);\r\nif (!page)\r\nreturn NULL;\r\nion_pages_sync_for_device(NULL, page, PAGE_SIZE << pool->order,\r\nDMA_BIDIRECTIONAL);\r\nreturn page;\r\n}\r\nstatic void ion_page_pool_free_pages(struct ion_page_pool *pool,\r\nstruct page *page)\r\n{\r\n__free_pages(page, pool->order);\r\n}\r\nstatic int ion_page_pool_add(struct ion_page_pool *pool, struct page *page)\r\n{\r\nmutex_lock(&pool->mutex);\r\nif (PageHighMem(page)) {\r\nlist_add_tail(&page->lru, &pool->high_items);\r\npool->high_count++;\r\n} else {\r\nlist_add_tail(&page->lru, &pool->low_items);\r\npool->low_count++;\r\n}\r\nmutex_unlock(&pool->mutex);\r\nreturn 0;\r\n}\r\nstatic struct page *ion_page_pool_remove(struct ion_page_pool *pool, bool high)\r\n{\r\nstruct page *page;\r\nif (high) {\r\nBUG_ON(!pool->high_count);\r\npage = list_first_entry(&pool->high_items, struct page, lru);\r\npool->high_count--;\r\n} else {\r\nBUG_ON(!pool->low_count);\r\npage = list_first_entry(&pool->low_items, struct page, lru);\r\npool->low_count--;\r\n}\r\nlist_del(&page->lru);\r\nreturn page;\r\n}\r\nstruct page *ion_page_pool_alloc(struct ion_page_pool *pool)\r\n{\r\nstruct page *page = NULL;\r\nBUG_ON(!pool);\r\nmutex_lock(&pool->mutex);\r\nif (pool->high_count)\r\npage = ion_page_pool_remove(pool, true);\r\nelse if (pool->low_count)\r\npage = ion_page_pool_remove(pool, false);\r\nmutex_unlock(&pool->mutex);\r\nif (!page)\r\npage = ion_page_pool_alloc_pages(pool);\r\nreturn page;\r\n}\r\nvoid ion_page_pool_free(struct ion_page_pool *pool, struct page *page)\r\n{\r\nint ret;\r\nBUG_ON(pool->order != compound_order(page));\r\nret = ion_page_pool_add(pool, page);\r\nif (ret)\r\nion_page_pool_free_pages(pool, page);\r\n}\r\nstatic int ion_page_pool_total(struct ion_page_pool *pool, bool high)\r\n{\r\nint count = pool->low_count;\r\nif (high)\r\ncount += pool->high_count;\r\nreturn count << pool->order;\r\n}\r\nint ion_page_pool_shrink(struct ion_page_pool *pool, gfp_t gfp_mask,\r\nint nr_to_scan)\r\n{\r\nint freed;\r\nbool high;\r\nif (current_is_kswapd())\r\nhigh = true;\r\nelse\r\nhigh = !!(gfp_mask & __GFP_HIGHMEM);\r\nif (nr_to_scan == 0)\r\nreturn ion_page_pool_total(pool, high);\r\nfor (freed = 0; freed < nr_to_scan; freed++) {\r\nstruct page *page;\r\nmutex_lock(&pool->mutex);\r\nif (pool->low_count) {\r\npage = ion_page_pool_remove(pool, false);\r\n} else if (high && pool->high_count) {\r\npage = ion_page_pool_remove(pool, true);\r\n} else {\r\nmutex_unlock(&pool->mutex);\r\nbreak;\r\n}\r\nmutex_unlock(&pool->mutex);\r\nion_page_pool_free_pages(pool, page);\r\n}\r\nreturn freed;\r\n}\r\nstruct ion_page_pool *ion_page_pool_create(gfp_t gfp_mask, unsigned int order)\r\n{\r\nstruct ion_page_pool *pool = kmalloc(sizeof(struct ion_page_pool),\r\nGFP_KERNEL);\r\nif (!pool)\r\nreturn NULL;\r\npool->high_count = 0;\r\npool->low_count = 0;\r\nINIT_LIST_HEAD(&pool->low_items);\r\nINIT_LIST_HEAD(&pool->high_items);\r\npool->gfp_mask = gfp_mask | __GFP_COMP;\r\npool->order = order;\r\nmutex_init(&pool->mutex);\r\nplist_node_init(&pool->list, order);\r\nreturn pool;\r\n}\r\nvoid ion_page_pool_destroy(struct ion_page_pool *pool)\r\n{\r\nkfree(pool);\r\n}\r\nstatic int __init ion_page_pool_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit ion_page_pool_exit(void)\r\n{\r\n}
