int rtw_init_mlme_priv(struct adapter *padapter)\r\n{\r\nint i;\r\nu8 *pbuf;\r\nstruct wlan_network *pnetwork;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nint res = _SUCCESS;\r\npmlmepriv->nic_hdl = (u8 *)padapter;\r\npmlmepriv->pscanned = NULL;\r\npmlmepriv->fw_state = 0;\r\npmlmepriv->cur_network.network.InfrastructureMode = Ndis802_11AutoUnknown;\r\npmlmepriv->scan_mode = SCAN_ACTIVE;\r\nspin_lock_init(&(pmlmepriv->lock));\r\n_rtw_init_queue(&(pmlmepriv->free_bss_pool));\r\n_rtw_init_queue(&(pmlmepriv->scanned_queue));\r\nset_scanned_network_val(pmlmepriv, 0);\r\nmemset(&pmlmepriv->assoc_ssid, 0, sizeof(struct ndis_802_11_ssid));\r\npbuf = vzalloc(MAX_BSS_CNT * (sizeof(struct wlan_network)));\r\nif (pbuf == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npmlmepriv->free_bss_buf = pbuf;\r\npnetwork = (struct wlan_network *)pbuf;\r\nfor (i = 0; i < MAX_BSS_CNT; i++) {\r\nINIT_LIST_HEAD(&(pnetwork->list));\r\nlist_add_tail(&(pnetwork->list), &(pmlmepriv->free_bss_pool.queue));\r\npnetwork++;\r\n}\r\nrtw_clear_scan_deny(padapter);\r\nrtw_init_mlme_timer(padapter);\r\nexit:\r\nreturn res;\r\n}\r\nstatic void rtw_free_mlme_ie_data(u8 **ppie, u32 *plen)\r\n{\r\nkfree(*ppie);\r\n*plen = 0;\r\n*ppie = NULL;\r\n}\r\nvoid rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv)\r\n{\r\nrtw_buf_free(&pmlmepriv->assoc_req, &pmlmepriv->assoc_req_len);\r\nrtw_buf_free(&pmlmepriv->assoc_rsp, &pmlmepriv->assoc_rsp_len);\r\nrtw_free_mlme_ie_data(&pmlmepriv->wps_beacon_ie, &pmlmepriv->wps_beacon_ie_len);\r\nrtw_free_mlme_ie_data(&pmlmepriv->wps_probe_req_ie, &pmlmepriv->wps_probe_req_ie_len);\r\nrtw_free_mlme_ie_data(&pmlmepriv->wps_probe_resp_ie, &pmlmepriv->wps_probe_resp_ie_len);\r\nrtw_free_mlme_ie_data(&pmlmepriv->wps_assoc_resp_ie, &pmlmepriv->wps_assoc_resp_ie_len);\r\nrtw_free_mlme_ie_data(&pmlmepriv->p2p_beacon_ie, &pmlmepriv->p2p_beacon_ie_len);\r\nrtw_free_mlme_ie_data(&pmlmepriv->p2p_probe_req_ie, &pmlmepriv->p2p_probe_req_ie_len);\r\nrtw_free_mlme_ie_data(&pmlmepriv->p2p_probe_resp_ie, &pmlmepriv->p2p_probe_resp_ie_len);\r\nrtw_free_mlme_ie_data(&pmlmepriv->p2p_go_probe_resp_ie, &pmlmepriv->p2p_go_probe_resp_ie_len);\r\nrtw_free_mlme_ie_data(&pmlmepriv->p2p_assoc_req_ie, &pmlmepriv->p2p_assoc_req_ie_len);\r\n}\r\nvoid rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv)\r\n{\r\n}\r\nvoid rtw_free_mlme_priv(struct mlme_priv *pmlmepriv)\r\n{\r\nrtw_free_mlme_priv_ie_data(pmlmepriv);\r\nif (pmlmepriv) {\r\nif (pmlmepriv->free_bss_buf)\r\nvfree(pmlmepriv->free_bss_buf);\r\n}\r\n}\r\nstruct wlan_network *_rtw_alloc_network(struct mlme_priv *pmlmepriv)\r\n{\r\nstruct wlan_network *pnetwork;\r\nstruct __queue *free_queue = &pmlmepriv->free_bss_pool;\r\nstruct list_head *plist = NULL;\r\nspin_lock_bh(&free_queue->lock);\r\nif (list_empty(&free_queue->queue)) {\r\npnetwork = NULL;\r\ngoto exit;\r\n}\r\nplist = free_queue->queue.next;\r\npnetwork = container_of(plist , struct wlan_network, list);\r\nlist_del_init(&pnetwork->list);\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("_rtw_alloc_network: ptr=%p\n", plist));\r\npnetwork->network_type = 0;\r\npnetwork->fixed = false;\r\npnetwork->last_scanned = jiffies;\r\npnetwork->aid = 0;\r\npnetwork->join_res = 0;\r\npmlmepriv->num_of_scanned++;\r\nexit:\r\nspin_unlock_bh(&free_queue->lock);\r\nreturn pnetwork;\r\n}\r\nstatic void _rtw_free_network(struct mlme_priv *pmlmepriv , struct wlan_network *pnetwork, u8 isfreeall)\r\n{\r\nu32 curr_time, delta_time;\r\nu32 lifetime = SCANQUEUE_LIFETIME;\r\nstruct __queue *free_queue = &(pmlmepriv->free_bss_pool);\r\nif (pnetwork == NULL)\r\nreturn;\r\nif (pnetwork->fixed)\r\nreturn;\r\ncurr_time = jiffies;\r\nif ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) ||\r\n(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)))\r\nlifetime = 1;\r\nif (!isfreeall) {\r\ndelta_time = (curr_time - pnetwork->last_scanned)/HZ;\r\nif (delta_time < lifetime)\r\nreturn;\r\n}\r\nspin_lock_bh(&free_queue->lock);\r\nlist_del_init(&(pnetwork->list));\r\nlist_add_tail(&(pnetwork->list), &(free_queue->queue));\r\npmlmepriv->num_of_scanned--;\r\nspin_unlock_bh(&free_queue->lock);\r\n}\r\nvoid _rtw_free_network_nolock(struct mlme_priv *pmlmepriv, struct wlan_network *pnetwork)\r\n{\r\nstruct __queue *free_queue = &(pmlmepriv->free_bss_pool);\r\nif (pnetwork == NULL)\r\nreturn;\r\nif (pnetwork->fixed)\r\nreturn;\r\nlist_del_init(&(pnetwork->list));\r\nlist_add_tail(&(pnetwork->list), get_list_head(free_queue));\r\npmlmepriv->num_of_scanned--;\r\n}\r\nstruct wlan_network *rtw_find_network(struct __queue *scanned_queue, u8 *addr)\r\n{\r\nstruct list_head *phead, *plist;\r\nstruct wlan_network *pnetwork = NULL;\r\nu8 zero_addr[ETH_ALEN] = {0, 0, 0, 0, 0, 0};\r\nif (!memcmp(zero_addr, addr, ETH_ALEN)) {\r\npnetwork = NULL;\r\ngoto exit;\r\n}\r\nphead = get_list_head(scanned_queue);\r\nplist = phead->next;\r\nwhile (plist != phead) {\r\npnetwork = container_of(plist, struct wlan_network , list);\r\nif (!memcmp(addr, pnetwork->network.MacAddress, ETH_ALEN))\r\nbreak;\r\nplist = plist->next;\r\n}\r\nif (plist == phead)\r\npnetwork = NULL;\r\nexit:\r\nreturn pnetwork;\r\n}\r\nvoid rtw_free_network_queue(struct adapter *padapter, u8 isfreeall)\r\n{\r\nstruct list_head *phead, *plist;\r\nstruct wlan_network *pnetwork;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct __queue *scanned_queue = &pmlmepriv->scanned_queue;\r\nspin_lock_bh(&scanned_queue->lock);\r\nphead = get_list_head(scanned_queue);\r\nplist = phead->next;\r\nwhile (phead != plist) {\r\npnetwork = container_of(plist, struct wlan_network, list);\r\nplist = plist->next;\r\n_rtw_free_network(pmlmepriv, pnetwork, isfreeall);\r\n}\r\nspin_unlock_bh(&scanned_queue->lock);\r\n}\r\nint rtw_if_up(struct adapter *padapter)\r\n{\r\nint res;\r\nif (padapter->bDriverStopped || padapter->bSurpriseRemoved ||\r\n(check_fwstate(&padapter->mlmepriv, _FW_LINKED) == false)) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,\r\n("rtw_if_up:bDriverStopped(%d) OR bSurpriseRemoved(%d)",\r\npadapter->bDriverStopped, padapter->bSurpriseRemoved));\r\nres = false;\r\n} else {\r\nres = true;\r\n}\r\nreturn res;\r\n}\r\nvoid rtw_generate_random_ibss(u8 *pibss)\r\n{\r\nu32 curtime = jiffies;\r\npibss[0] = 0x02;\r\npibss[1] = 0x11;\r\npibss[2] = 0x87;\r\npibss[3] = (u8)(curtime & 0xff);\r\npibss[4] = (u8)((curtime>>8) & 0xff);\r\npibss[5] = (u8)((curtime>>16) & 0xff);\r\nreturn;\r\n}\r\nu8 *rtw_get_capability_from_ie(u8 *ie)\r\n{\r\nreturn ie + 8 + 2;\r\n}\r\nu16 rtw_get_capability(struct wlan_bssid_ex *bss)\r\n{\r\n__le16 val;\r\nmemcpy((u8 *)&val, rtw_get_capability_from_ie(bss->IEs), 2);\r\nreturn le16_to_cpu(val);\r\n}\r\nu8 *rtw_get_beacon_interval_from_ie(u8 *ie)\r\n{\r\nreturn ie + 8;\r\n}\r\nstatic struct wlan_network *rtw_alloc_network(struct mlme_priv *pmlmepriv)\r\n{\r\nreturn _rtw_alloc_network(pmlmepriv);\r\n}\r\nstatic void rtw_free_network_nolock(struct mlme_priv *pmlmepriv,\r\nstruct wlan_network *pnetwork)\r\n{\r\n_rtw_free_network_nolock(pmlmepriv, pnetwork);\r\n}\r\nint rtw_is_same_ibss(struct adapter *adapter, struct wlan_network *pnetwork)\r\n{\r\nint ret = true;\r\nstruct security_priv *psecuritypriv = &adapter->securitypriv;\r\nif ((psecuritypriv->dot11PrivacyAlgrthm != _NO_PRIVACY_) &&\r\n(pnetwork->network.Privacy == 0))\r\nret = false;\r\nelse if ((psecuritypriv->dot11PrivacyAlgrthm == _NO_PRIVACY_) &&\r\n(pnetwork->network.Privacy == 1))\r\nret = false;\r\nelse\r\nret = true;\r\nreturn ret;\r\n}\r\nstatic int is_same_ess(struct wlan_bssid_ex *a, struct wlan_bssid_ex *b)\r\n{\r\nreturn (a->Ssid.SsidLength == b->Ssid.SsidLength) &&\r\n!memcmp(a->Ssid.Ssid, b->Ssid.Ssid, a->Ssid.SsidLength);\r\n}\r\nint is_same_network(struct wlan_bssid_ex *src, struct wlan_bssid_ex *dst)\r\n{\r\nu16 s_cap, d_cap;\r\n__le16 le_scap, le_dcap;\r\nmemcpy((u8 *)&le_scap, rtw_get_capability_from_ie(src->IEs), 2);\r\nmemcpy((u8 *)&le_dcap, rtw_get_capability_from_ie(dst->IEs), 2);\r\ns_cap = le16_to_cpu(le_scap);\r\nd_cap = le16_to_cpu(le_dcap);\r\nreturn ((src->Ssid.SsidLength == dst->Ssid.SsidLength) &&\r\n((!memcmp(src->MacAddress, dst->MacAddress, ETH_ALEN)) == true) &&\r\n((!memcmp(src->Ssid.Ssid, dst->Ssid.Ssid, src->Ssid.SsidLength)) == true) &&\r\n((s_cap & WLAN_CAPABILITY_IBSS) ==\r\n(d_cap & WLAN_CAPABILITY_IBSS)) &&\r\n((s_cap & WLAN_CAPABILITY_BSS) ==\r\n(d_cap & WLAN_CAPABILITY_BSS)));\r\n}\r\nstruct wlan_network *rtw_get_oldest_wlan_network(struct __queue *scanned_queue)\r\n{\r\nstruct list_head *plist, *phead;\r\nstruct wlan_network *pwlan = NULL;\r\nstruct wlan_network *oldest = NULL;\r\nphead = get_list_head(scanned_queue);\r\nplist = phead->next;\r\nwhile (1) {\r\nif (phead == plist)\r\nbreak;\r\npwlan = container_of(plist, struct wlan_network, list);\r\nif (!pwlan->fixed) {\r\nif (oldest == NULL || time_after(oldest->last_scanned, pwlan->last_scanned))\r\noldest = pwlan;\r\n}\r\nplist = plist->next;\r\n}\r\nreturn oldest;\r\n}\r\nvoid update_network(struct wlan_bssid_ex *dst, struct wlan_bssid_ex *src,\r\nstruct adapter *padapter, bool update_ie)\r\n{\r\nlong rssi_ori = dst->Rssi;\r\nu8 sq_smp = src->PhyInfo.SignalQuality;\r\nu8 ss_final;\r\nu8 sq_final;\r\nlong rssi_final;\r\nrtw_hal_antdiv_rssi_compared(padapter, dst, src);\r\nif (check_fwstate(&padapter->mlmepriv, _FW_LINKED) && is_same_network(&(padapter->mlmepriv.cur_network.network), src)) {\r\nss_final = padapter->recvpriv.signal_strength;\r\nsq_final = padapter->recvpriv.signal_qual;\r\nif (sq_smp != 101)\r\nrssi_final = (src->Rssi+dst->Rssi*4)/5;\r\nelse\r\nrssi_final = rssi_ori;\r\n} else {\r\nif (sq_smp != 101) {\r\nss_final = ((u32)(src->PhyInfo.SignalStrength)+(u32)(dst->PhyInfo.SignalStrength)*4)/5;\r\nsq_final = ((u32)(src->PhyInfo.SignalQuality)+(u32)(dst->PhyInfo.SignalQuality)*4)/5;\r\nrssi_final = (src->Rssi+dst->Rssi*4)/5;\r\n} else {\r\nss_final = dst->PhyInfo.SignalStrength;\r\nsq_final = dst->PhyInfo.SignalQuality;\r\nrssi_final = dst->Rssi;\r\n}\r\n}\r\nif (update_ie)\r\nmemcpy((u8 *)dst, (u8 *)src, get_wlan_bssid_ex_sz(src));\r\ndst->PhyInfo.SignalStrength = ss_final;\r\ndst->PhyInfo.SignalQuality = sq_final;\r\ndst->Rssi = rssi_final;\r\n}\r\nstatic void update_current_network(struct adapter *adapter, struct wlan_bssid_ex *pnetwork)\r\n{\r\nstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\r\nif ((check_fwstate(pmlmepriv, _FW_LINKED) == true) &&\r\n(is_same_network(&(pmlmepriv->cur_network.network), pnetwork))) {\r\nupdate_network(&(pmlmepriv->cur_network.network), pnetwork, adapter, true);\r\nrtw_update_protection(adapter, (pmlmepriv->cur_network.network.IEs) + sizeof(struct ndis_802_11_fixed_ie),\r\npmlmepriv->cur_network.network.IELength);\r\n}\r\n}\r\nvoid rtw_update_scanned_network(struct adapter *adapter, struct wlan_bssid_ex *target)\r\n{\r\nstruct list_head *plist, *phead;\r\nu32 bssid_ex_sz;\r\nstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\r\nstruct __queue *queue = &(pmlmepriv->scanned_queue);\r\nstruct wlan_network *pnetwork = NULL;\r\nstruct wlan_network *oldest = NULL;\r\nspin_lock_bh(&queue->lock);\r\nphead = get_list_head(queue);\r\nplist = phead->next;\r\nwhile (phead != plist) {\r\npnetwork = container_of(plist, struct wlan_network, list);\r\nif (is_same_network(&(pnetwork->network), target))\r\nbreak;\r\nif ((oldest == ((struct wlan_network *)0)) ||\r\ntime_after(oldest->last_scanned, pnetwork->last_scanned))\r\noldest = pnetwork;\r\nplist = plist->next;\r\n}\r\nif (phead == plist) {\r\nif (list_empty(&(pmlmepriv->free_bss_pool.queue))) {\r\npnetwork = oldest;\r\nrtw_hal_get_def_var(adapter, HAL_DEF_CURRENT_ANTENNA, &(target->PhyInfo.Optimum_antenna));\r\nmemcpy(&(pnetwork->network), target, get_wlan_bssid_ex_sz(target));\r\npnetwork->fixed = false;\r\npnetwork->last_scanned = jiffies;\r\npnetwork->network_type = 0;\r\npnetwork->aid = 0;\r\npnetwork->join_res = 0;\r\nif (pnetwork->network.PhyInfo.SignalQuality == 101)\r\npnetwork->network.PhyInfo.SignalQuality = 0;\r\n} else {\r\npnetwork = rtw_alloc_network(pmlmepriv);\r\nif (pnetwork == NULL) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("\n\n\nsomething wrong here\n\n\n"));\r\ngoto exit;\r\n}\r\nbssid_ex_sz = get_wlan_bssid_ex_sz(target);\r\ntarget->Length = bssid_ex_sz;\r\nrtw_hal_get_def_var(adapter, HAL_DEF_CURRENT_ANTENNA, &(target->PhyInfo.Optimum_antenna));\r\nmemcpy(&(pnetwork->network), target, bssid_ex_sz);\r\npnetwork->last_scanned = jiffies;\r\nif (pnetwork->network.PhyInfo.SignalQuality == 101)\r\npnetwork->network.PhyInfo.SignalQuality = 0;\r\nlist_add_tail(&(pnetwork->list), &(queue->queue));\r\n}\r\n} else {\r\nbool update_ie = true;\r\npnetwork->last_scanned = jiffies;\r\nif ((pnetwork->network.IELength > target->IELength) && (target->Reserved[0] == 1))\r\nupdate_ie = false;\r\nupdate_network(&(pnetwork->network), target, adapter, update_ie);\r\n}\r\nexit:\r\nspin_unlock_bh(&queue->lock);\r\n}\r\nstatic void rtw_add_network(struct adapter *adapter,\r\nstruct wlan_bssid_ex *pnetwork)\r\n{\r\nupdate_current_network(adapter, pnetwork);\r\nrtw_update_scanned_network(adapter, pnetwork);\r\n}\r\nstatic int rtw_is_desired_network(struct adapter *adapter, struct wlan_network *pnetwork)\r\n{\r\nstruct security_priv *psecuritypriv = &adapter->securitypriv;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nu32 desired_encmode;\r\nu32 privacy;\r\nuint wps_ielen;\r\nint bselected = true;\r\ndesired_encmode = psecuritypriv->ndisencryptstatus;\r\nprivacy = pnetwork->network.Privacy;\r\nif (check_fwstate(pmlmepriv, WIFI_UNDER_WPS)) {\r\nif (rtw_get_wps_ie(pnetwork->network.IEs+_FIXED_IE_LENGTH_, pnetwork->network.IELength-_FIXED_IE_LENGTH_, NULL, &wps_ielen) != NULL)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nif (adapter->registrypriv.wifi_spec == 1) {\r\nif ((desired_encmode == Ndis802_11EncryptionDisabled) && (privacy != 0))\r\nbselected = false;\r\n}\r\nif ((desired_encmode != Ndis802_11EncryptionDisabled) && (privacy == 0)) {\r\nDBG_88E("desired_encmode: %d, privacy: %d\n", desired_encmode, privacy);\r\nbselected = false;\r\n}\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) {\r\nif (pnetwork->network.InfrastructureMode != pmlmepriv->cur_network.network.InfrastructureMode)\r\nbselected = false;\r\n}\r\nreturn bselected;\r\n}\r\nvoid rtw_atimdone_event_callback(struct adapter *adapter , u8 *pbuf)\r\n{\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("receive atimdone_evet\n"));\r\nreturn;\r\n}\r\nvoid rtw_survey_event_callback(struct adapter *adapter, u8 *pbuf)\r\n{\r\nu32 len;\r\nstruct wlan_bssid_ex *pnetwork;\r\nstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\r\npnetwork = (struct wlan_bssid_ex *)pbuf;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_survey_event_callback, ssid=%s\n", pnetwork->Ssid.Ssid));\r\nlen = get_wlan_bssid_ex_sz(pnetwork);\r\nif (len > (sizeof(struct wlan_bssid_ex))) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("\n****rtw_survey_event_callback: return a wrong bss ***\n"));\r\nreturn;\r\n}\r\nspin_lock_bh(&pmlmepriv->lock);\r\nif ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) == true) {\r\nif (!memcmp(&(pmlmepriv->cur_network.network.MacAddress), pnetwork->MacAddress, ETH_ALEN)) {\r\nstruct wlan_network *ibss_wlan = NULL;\r\nmemcpy(pmlmepriv->cur_network.network.IEs, pnetwork->IEs, 8);\r\nspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\r\nibss_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->MacAddress);\r\nif (ibss_wlan) {\r\nmemcpy(ibss_wlan->network.IEs , pnetwork->IEs, 8);\r\nspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\r\ngoto exit;\r\n}\r\nspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\r\n}\r\n}\r\nif ((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == false) {\r\nif (pnetwork->Ssid.Ssid[0] == 0)\r\npnetwork->Ssid.SsidLength = 0;\r\nrtw_add_network(adapter, pnetwork);\r\n}\r\nexit:\r\nspin_unlock_bh(&pmlmepriv->lock);\r\nreturn;\r\n}\r\nvoid rtw_surveydone_event_callback(struct adapter *adapter, u8 *pbuf)\r\n{\r\nstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext;\r\nspin_lock_bh(&pmlmepriv->lock);\r\nif (pmlmepriv->wps_probe_req_ie) {\r\npmlmepriv->wps_probe_req_ie_len = 0;\r\nkfree(pmlmepriv->wps_probe_req_ie);\r\npmlmepriv->wps_probe_req_ie = NULL;\r\n}\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("rtw_surveydone_event_callback: fw_state:%x\n\n", get_fwstate(pmlmepriv)));\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)) {\r\ndel_timer_sync(&pmlmepriv->scan_to_timer);\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);\r\n} else {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("nic status=%x, survey done event comes too late!\n", get_fwstate(pmlmepriv)));\r\n}\r\nrtw_set_signal_stat_timer(&adapter->recvpriv);\r\nif (pmlmepriv->to_join) {\r\nif ((check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true)) {\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == false) {\r\nset_fwstate(pmlmepriv, _FW_UNDER_LINKING);\r\nif (rtw_select_and_join_from_scanned_queue(pmlmepriv) == _SUCCESS) {\r\n_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);\r\n} else {\r\nstruct wlan_bssid_ex *pdev_network = &(adapter->registrypriv.dev_network);\r\nu8 *pibss = adapter->registrypriv.dev_network.MacAddress;\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("switching to adhoc master\n"));\r\nmemcpy(&pdev_network->Ssid, &pmlmepriv->assoc_ssid, sizeof(struct ndis_802_11_ssid));\r\nrtw_update_registrypriv_dev_network(adapter);\r\nrtw_generate_random_ibss(pibss);\r\npmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;\r\nif (rtw_createbss_cmd(adapter) != _SUCCESS)\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("Error=>rtw_createbss_cmd status FAIL\n"));\r\npmlmepriv->to_join = false;\r\n}\r\n}\r\n} else {\r\nint s_ret;\r\nset_fwstate(pmlmepriv, _FW_UNDER_LINKING);\r\npmlmepriv->to_join = false;\r\ns_ret = rtw_select_and_join_from_scanned_queue(pmlmepriv);\r\nif (_SUCCESS == s_ret) {\r\n_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);\r\n} else if (s_ret == 2) {\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\r\nrtw_indicate_connect(adapter);\r\n} else {\r\nDBG_88E("try_to_join, but select scanning queue fail, to_roaming:%d\n", pmlmepriv->to_roaming);\r\nif (pmlmepriv->to_roaming != 0) {\r\nif (--pmlmepriv->to_roaming == 0 ||\r\n_SUCCESS != rtw_sitesurvey_cmd(adapter, &pmlmepriv->assoc_ssid, 1, NULL, 0)) {\r\npmlmepriv->to_roaming = 0;\r\nrtw_free_assoc_resources(adapter, 1);\r\nrtw_indicate_disconnect(adapter);\r\n} else {\r\npmlmepriv->to_join = true;\r\n}\r\n}\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\r\n}\r\n}\r\n}\r\nindicate_wx_scan_complete_event(adapter);\r\nspin_unlock_bh(&pmlmepriv->lock);\r\nrtw_os_xmit_schedule(adapter);\r\npmlmeext = &adapter->mlmeextpriv;\r\n}\r\nvoid rtw_dummy_event_callback(struct adapter *adapter , u8 *pbuf)\r\n{\r\n}\r\nvoid rtw_fwdbg_event_callback(struct adapter *adapter , u8 *pbuf)\r\n{\r\n}\r\nstatic void free_scanqueue(struct mlme_priv *pmlmepriv)\r\n{\r\nstruct __queue *free_queue = &pmlmepriv->free_bss_pool;\r\nstruct __queue *scan_queue = &pmlmepriv->scanned_queue;\r\nstruct list_head *plist, *phead, *ptemp;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+free_scanqueue\n"));\r\nspin_lock_bh(&scan_queue->lock);\r\nspin_lock_bh(&free_queue->lock);\r\nphead = get_list_head(scan_queue);\r\nplist = phead->next;\r\nwhile (plist != phead) {\r\nptemp = plist->next;\r\nlist_del_init(plist);\r\nlist_add_tail(plist, &free_queue->queue);\r\nplist = ptemp;\r\npmlmepriv->num_of_scanned--;\r\n}\r\nspin_unlock_bh(&free_queue->lock);\r\nspin_unlock_bh(&scan_queue->lock);\r\n}\r\nvoid rtw_free_assoc_resources(struct adapter *adapter, int lock_scanned_queue)\r\n{\r\nstruct wlan_network *pwlan = NULL;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nstruct sta_priv *pstapriv = &adapter->stapriv;\r\nstruct wlan_network *tgt_network = &pmlmepriv->cur_network;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_, ("+rtw_free_assoc_resources\n"));\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,\r\n("tgt_network->network.MacAddress=%pM ssid=%s\n",\r\ntgt_network->network.MacAddress, tgt_network->network.Ssid.Ssid));\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_AP_STATE)) {\r\nstruct sta_info *psta;\r\npsta = rtw_get_stainfo(&adapter->stapriv, tgt_network->network.MacAddress);\r\nspin_lock_bh(&(pstapriv->sta_hash_lock));\r\nrtw_free_stainfo(adapter, psta);\r\nspin_unlock_bh(&pstapriv->sta_hash_lock);\r\n}\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE | WIFI_ADHOC_MASTER_STATE | WIFI_AP_STATE)) {\r\nstruct sta_info *psta;\r\nrtw_free_all_stainfo(adapter);\r\npsta = rtw_get_bcmc_stainfo(adapter);\r\nspin_lock_bh(&(pstapriv->sta_hash_lock));\r\nrtw_free_stainfo(adapter, psta);\r\nspin_unlock_bh(&pstapriv->sta_hash_lock);\r\nrtw_init_bcmc_stainfo(adapter);\r\n}\r\nif (lock_scanned_queue)\r\nspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\r\npwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);\r\nif (pwlan)\r\npwlan->fixed = false;\r\nelse\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("rtw_free_assoc_resources:pwlan==NULL\n\n"));\r\nif ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) && (adapter->stapriv.asoc_sta_count == 1)))\r\nrtw_free_network_nolock(pmlmepriv, pwlan);\r\nif (lock_scanned_queue)\r\nspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\r\npmlmepriv->key_mask = 0;\r\n}\r\nvoid rtw_indicate_connect(struct adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("+rtw_indicate_connect\n"));\r\npmlmepriv->to_join = false;\r\nif (!check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {\r\nset_fwstate(pmlmepriv, _FW_LINKED);\r\nrtw_led_control(padapter, LED_CTL_LINK);\r\nrtw_os_indicate_connect(padapter);\r\n}\r\npmlmepriv->to_roaming = 0;\r\nrtw_set_scan_deny(padapter, 3000);\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("-rtw_indicate_connect: fw_state=0x%08x\n", get_fwstate(pmlmepriv)));\r\n}\r\nvoid rtw_indicate_disconnect(struct adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("+rtw_indicate_disconnect\n"));\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING | WIFI_UNDER_WPS);\r\nif (pmlmepriv->to_roaming > 0)\r\n_clr_fwstate_(pmlmepriv, _FW_LINKED);\r\nif (check_fwstate(&padapter->mlmepriv, _FW_LINKED) ||\r\n(pmlmepriv->to_roaming <= 0)) {\r\nrtw_os_indicate_disconnect(padapter);\r\n_clr_fwstate_(pmlmepriv, _FW_LINKED);\r\nrtw_led_control(padapter, LED_CTL_NO_LINK);\r\nrtw_clear_scan_deny(padapter);\r\n}\r\nrtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_DISCONNECT, 1);\r\n}\r\ninline void rtw_indicate_scan_done(struct adapter *padapter, bool aborted)\r\n{\r\nrtw_os_indicate_scan_done(padapter, aborted);\r\n}\r\nvoid rtw_scan_abort(struct adapter *adapter)\r\n{\r\nu32 start;\r\nstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\r\nstruct mlme_ext_priv *pmlmeext = &(adapter->mlmeextpriv);\r\nstart = jiffies;\r\npmlmeext->scan_abort = true;\r\nwhile (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) &&\r\nrtw_get_passing_time_ms(start) <= 200) {\r\nif (adapter->bDriverStopped || adapter->bSurpriseRemoved)\r\nbreak;\r\nDBG_88E(FUNC_NDEV_FMT"fw_state=_FW_UNDER_SURVEY!\n", FUNC_NDEV_ARG(adapter->pnetdev));\r\nmsleep(20);\r\n}\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)) {\r\nif (!adapter->bDriverStopped && !adapter->bSurpriseRemoved)\r\nDBG_88E(FUNC_NDEV_FMT"waiting for scan_abort time out!\n", FUNC_NDEV_ARG(adapter->pnetdev));\r\nrtw_indicate_scan_done(adapter, true);\r\n}\r\npmlmeext->scan_abort = false;\r\n}\r\nstatic struct sta_info *rtw_joinbss_update_stainfo(struct adapter *padapter, struct wlan_network *pnetwork)\r\n{\r\nint i;\r\nstruct sta_info *bmc_sta, *psta = NULL;\r\nstruct recv_reorder_ctrl *preorder_ctrl;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\npsta = rtw_get_stainfo(pstapriv, pnetwork->network.MacAddress);\r\nif (psta == NULL)\r\npsta = rtw_alloc_stainfo(pstapriv, pnetwork->network.MacAddress);\r\nif (psta) {\r\nDBG_88E("%s\n", __func__);\r\npsta->aid = pnetwork->join_res;\r\npsta->mac_id = 0;\r\nrtw_hal_set_odm_var(padapter, HAL_ODM_STA_INFO, psta, true);\r\nif (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) {\r\npadapter->securitypriv.binstallGrpkey = false;\r\npadapter->securitypriv.busetkipkey = false;\r\npadapter->securitypriv.bgrpkey_handshake = false;\r\npsta->ieee8021x_blocked = true;\r\npsta->dot118021XPrivacy = padapter->securitypriv.dot11PrivacyAlgrthm;\r\nmemset((u8 *)&psta->dot118021x_UncstKey, 0, sizeof(union Keytype));\r\nmemset((u8 *)&psta->dot11tkiprxmickey, 0, sizeof(union Keytype));\r\nmemset((u8 *)&psta->dot11tkiptxmickey, 0, sizeof(union Keytype));\r\nmemset((u8 *)&psta->dot11txpn, 0, sizeof(union pn48));\r\nmemset((u8 *)&psta->dot11rxpn, 0, sizeof(union pn48));\r\n}\r\nif (padapter->securitypriv.wps_ie_len != 0) {\r\npsta->ieee8021x_blocked = true;\r\npadapter->securitypriv.wps_ie_len = 0;\r\n}\r\nfor (i = 0; i < 16; i++) {\r\npreorder_ctrl = &psta->recvreorder_ctrl[i];\r\npreorder_ctrl->enable = false;\r\npreorder_ctrl->indicate_seq = 0xffff;\r\npreorder_ctrl->wend_b = 0xffff;\r\npreorder_ctrl->wsize_b = 64;\r\n}\r\nbmc_sta = rtw_get_bcmc_stainfo(padapter);\r\nif (bmc_sta) {\r\nfor (i = 0; i < 16; i++) {\r\npreorder_ctrl = &bmc_sta->recvreorder_ctrl[i];\r\npreorder_ctrl->enable = false;\r\npreorder_ctrl->indicate_seq = 0xffff;\r\npreorder_ctrl->wend_b = 0xffff;\r\npreorder_ctrl->wsize_b = 64;\r\n}\r\n}\r\nupdate_sta_info(padapter, psta);\r\n}\r\nreturn psta;\r\n}\r\nstatic void rtw_joinbss_update_network(struct adapter *padapter, struct wlan_network *ptarget_wlan, struct wlan_network *pnetwork)\r\n{\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct wlan_network *cur_network = &(pmlmepriv->cur_network);\r\nDBG_88E("%s\n", __func__);\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,\r\n("\nfw_state:%x, BSSID:%pM\n",\r\nget_fwstate(pmlmepriv), pnetwork->network.MacAddress));\r\nmemcpy(&cur_network->network, &pnetwork->network, pnetwork->network.Length);\r\ncur_network->network.IELength = ptarget_wlan->network.IELength;\r\nmemcpy(&cur_network->network.IEs[0], &ptarget_wlan->network.IEs[0], MAX_IE_SZ);\r\ncur_network->aid = pnetwork->join_res;\r\nrtw_set_signal_stat_timer(&padapter->recvpriv);\r\npadapter->recvpriv.signal_strength = ptarget_wlan->network.PhyInfo.SignalStrength;\r\npadapter->recvpriv.signal_qual = ptarget_wlan->network.PhyInfo.SignalQuality;\r\npadapter->recvpriv.rssi = translate_percentage_to_dbm(ptarget_wlan->network.PhyInfo.SignalStrength);\r\nrtw_set_signal_stat_timer(&padapter->recvpriv);\r\nswitch (pnetwork->network.InfrastructureMode) {\r\ncase Ndis802_11Infrastructure:\r\nif (pmlmepriv->fw_state&WIFI_UNDER_WPS)\r\npmlmepriv->fw_state = WIFI_STATION_STATE|WIFI_UNDER_WPS;\r\nelse\r\npmlmepriv->fw_state = WIFI_STATION_STATE;\r\nbreak;\r\ncase Ndis802_11IBSS:\r\npmlmepriv->fw_state = WIFI_ADHOC_STATE;\r\nbreak;\r\ndefault:\r\npmlmepriv->fw_state = WIFI_NULL_STATE;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("Invalid network_mode\n"));\r\nbreak;\r\n}\r\nrtw_update_protection(padapter, (cur_network->network.IEs) +\r\nsizeof(struct ndis_802_11_fixed_ie),\r\n(cur_network->network.IELength));\r\nrtw_update_ht_cap(padapter, cur_network->network.IEs, cur_network->network.IELength);\r\n}\r\nvoid rtw_joinbss_event_prehandle(struct adapter *adapter, u8 *pbuf)\r\n{\r\nstruct sta_info *ptarget_sta = NULL, *pcur_sta = NULL;\r\nstruct sta_priv *pstapriv = &adapter->stapriv;\r\nstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\r\nstruct wlan_network *pnetwork = (struct wlan_network *)pbuf;\r\nstruct wlan_network *cur_network = &(pmlmepriv->cur_network);\r\nstruct wlan_network *pcur_wlan = NULL, *ptarget_wlan = NULL;\r\nunsigned int the_same_macaddr = false;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("joinbss event call back received with res=%d\n", pnetwork->join_res));\r\nrtw_get_encrypt_decrypt_from_registrypriv(adapter);\r\nif (pmlmepriv->assoc_ssid.SsidLength == 0)\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("@@@@@ joinbss event call back for Any SSid\n"));\r\nelse\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("@@@@@ rtw_joinbss_event_callback for SSid:%s\n", pmlmepriv->assoc_ssid.Ssid));\r\nthe_same_macaddr = !memcmp(pnetwork->network.MacAddress, cur_network->network.MacAddress, ETH_ALEN);\r\npnetwork->network.Length = get_wlan_bssid_ex_sz(&pnetwork->network);\r\nif (pnetwork->network.Length > sizeof(struct wlan_bssid_ex)) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("\n\n ***joinbss_evt_callback return a wrong bss ***\n\n"));\r\nreturn;\r\n}\r\nspin_lock_bh(&pmlmepriv->lock);\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("\nrtw_joinbss_event_callback!! _enter_critical\n"));\r\nif (pnetwork->join_res > 0) {\r\nspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) {\r\nif (check_fwstate(pmlmepriv, _FW_LINKED)) {\r\nif (the_same_macaddr) {\r\nptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);\r\n} else {\r\npcur_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);\r\nif (pcur_wlan)\r\npcur_wlan->fixed = false;\r\npcur_sta = rtw_get_stainfo(pstapriv, cur_network->network.MacAddress);\r\nif (pcur_sta) {\r\nspin_lock_bh(&(pstapriv->sta_hash_lock));\r\nrtw_free_stainfo(adapter, pcur_sta);\r\nspin_unlock_bh(&pstapriv->sta_hash_lock);\r\n}\r\nptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {\r\nif (ptarget_wlan)\r\nptarget_wlan->fixed = true;\r\n}\r\n}\r\n} else {\r\nptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, pnetwork->network.MacAddress);\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {\r\nif (ptarget_wlan)\r\nptarget_wlan->fixed = true;\r\n}\r\n}\r\nif (ptarget_wlan) {\r\nrtw_joinbss_update_network(adapter, ptarget_wlan, pnetwork);\r\n} else {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("Can't find ptarget_wlan when joinbss_event callback\n"));\r\nspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\r\ngoto ignore_joinbss_callback;\r\n}\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {\r\nptarget_sta = rtw_joinbss_update_stainfo(adapter, pnetwork);\r\nif (ptarget_sta == NULL) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("Can't update stainfo when joinbss_event callback\n"));\r\nspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\r\ngoto ignore_joinbss_callback;\r\n}\r\n}\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true) {\r\nrtw_indicate_connect(adapter);\r\n} else {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("adhoc mode, fw_state:%x", get_fwstate(pmlmepriv)));\r\n}\r\ndel_timer_sync(&pmlmepriv->assoc_timer);\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_, ("Cancle assoc_timer\n"));\r\n} else {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("rtw_joinbss_event_callback err: fw_state:%x", get_fwstate(pmlmepriv)));\r\nspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\r\ngoto ignore_joinbss_callback;\r\n}\r\nspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\r\n} else if (pnetwork->join_res == -4) {\r\nrtw_reset_securitypriv(adapter);\r\n_set_timer(&pmlmepriv->assoc_timer, 1);\r\nif ((check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) == true) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("fail! clear _FW_UNDER_LINKING ^^^fw_state=%x\n", get_fwstate(pmlmepriv)));\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\r\n}\r\n} else {\r\n_set_timer(&pmlmepriv->assoc_timer, 1);\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\r\n}\r\nignore_joinbss_callback:\r\nspin_unlock_bh(&pmlmepriv->lock);\r\n}\r\nvoid rtw_joinbss_event_callback(struct adapter *adapter, u8 *pbuf)\r\n{\r\nstruct wlan_network *pnetwork = (struct wlan_network *)pbuf;\r\nmlmeext_joinbss_event_callback(adapter, pnetwork->join_res);\r\nrtw_os_xmit_schedule(adapter);\r\n}\r\nstatic u8 search_max_mac_id(struct adapter *padapter)\r\n{\r\nu8 mac_id;\r\n#if defined(CONFIG_88EU_AP_MODE)\r\nu8 aid;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\n#endif\r\nstruct mlme_ext_priv *pmlmeext = &(padapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\n#if defined(CONFIG_88EU_AP_MODE)\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\nfor (aid = (pstapriv->max_num_sta); aid > 0; aid--) {\r\nif (pstapriv->sta_aid[aid-1] != NULL)\r\nbreak;\r\n}\r\nmac_id = aid + 1;\r\n} else\r\n#endif\r\n{\r\nfor (mac_id = (NUM_STA-1); mac_id >= IBSS_START_MAC_ID; mac_id--) {\r\nif (pmlmeinfo->FW_sta_info[mac_id].status == 1)\r\nbreak;\r\n}\r\n}\r\nreturn mac_id;\r\n}\r\nvoid rtw_stassoc_hw_rpt(struct adapter *adapter, struct sta_info *psta)\r\n{\r\nu16 media_status;\r\nu8 macid;\r\nif (psta == NULL)\r\nreturn;\r\nmacid = search_max_mac_id(adapter);\r\nrtw_hal_set_hwreg(adapter, HW_VAR_TX_RPT_MAX_MACID, (u8 *)&macid);\r\nmedia_status = (psta->mac_id<<8)|1;\r\nrtw_hal_set_hwreg(adapter, HW_VAR_H2C_MEDIA_STATUS_RPT, (u8 *)&media_status);\r\n}\r\nvoid rtw_stassoc_event_callback(struct adapter *adapter, u8 *pbuf)\r\n{\r\nstruct sta_info *psta;\r\nstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\r\nstruct stassoc_event *pstassoc = (struct stassoc_event *)pbuf;\r\nstruct wlan_network *cur_network = &(pmlmepriv->cur_network);\r\nstruct wlan_network *ptarget_wlan = NULL;\r\nif (rtw_access_ctrl(adapter, pstassoc->macaddr) == false)\r\nreturn;\r\n#if defined(CONFIG_88EU_AP_MODE)\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE)) {\r\npsta = rtw_get_stainfo(&adapter->stapriv, pstassoc->macaddr);\r\nif (psta) {\r\nap_sta_info_defer_update(adapter, psta);\r\nrtw_stassoc_hw_rpt(adapter, psta);\r\n}\r\nreturn;\r\n}\r\n#endif\r\npsta = rtw_get_stainfo(&adapter->stapriv, pstassoc->macaddr);\r\nif (psta != NULL) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("Error: rtw_stassoc_event_callback: sta has been in sta_hash_queue\n"));\r\nreturn;\r\n}\r\npsta = rtw_alloc_stainfo(&adapter->stapriv, pstassoc->macaddr);\r\nif (psta == NULL) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("Can't alloc sta_info when rtw_stassoc_event_callback\n"));\r\nreturn;\r\n}\r\npsta->qos_option = 0;\r\npsta->mac_id = (uint)pstassoc->cam_id;\r\nDBG_88E("%s\n", __func__);\r\nrtw_hal_set_odm_var(adapter, HAL_ODM_STA_INFO, psta, true);\r\nrtw_stassoc_hw_rpt(adapter, psta);\r\nif (adapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)\r\npsta->dot118021XPrivacy = adapter->securitypriv.dot11PrivacyAlgrthm;\r\npsta->ieee8021x_blocked = false;\r\nspin_lock_bh(&pmlmepriv->lock);\r\nif ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) ||\r\n(check_fwstate(pmlmepriv, WIFI_ADHOC_STATE))) {\r\nif (adapter->stapriv.asoc_sta_count == 2) {\r\nspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\r\nptarget_wlan = rtw_find_network(&pmlmepriv->scanned_queue, cur_network->network.MacAddress);\r\nif (ptarget_wlan)\r\nptarget_wlan->fixed = true;\r\nspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\r\nrtw_indicate_connect(adapter);\r\n}\r\n}\r\nspin_unlock_bh(&pmlmepriv->lock);\r\nmlmeext_sta_add_event_callback(adapter, psta);\r\n}\r\nvoid rtw_stadel_event_callback(struct adapter *adapter, u8 *pbuf)\r\n{\r\nint mac_id = -1;\r\nstruct sta_info *psta;\r\nstruct wlan_network *pwlan = NULL;\r\nstruct wlan_bssid_ex *pdev_network = NULL;\r\nu8 *pibss = NULL;\r\nstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\r\nstruct stadel_event *pstadel = (struct stadel_event *)pbuf;\r\nstruct sta_priv *pstapriv = &adapter->stapriv;\r\nstruct wlan_network *tgt_network = &(pmlmepriv->cur_network);\r\npsta = rtw_get_stainfo(&adapter->stapriv, pstadel->macaddr);\r\nif (psta)\r\nmac_id = psta->mac_id;\r\nelse\r\nmac_id = pstadel->mac_id;\r\nDBG_88E("%s(mac_id=%d)=%pM\n", __func__, mac_id, pstadel->macaddr);\r\nif (mac_id >= 0) {\r\nu16 media_status;\r\nmedia_status = (mac_id<<8)|0;\r\nrtw_hal_set_hwreg(adapter, HW_VAR_H2C_MEDIA_STATUS_RPT, (u8 *)&media_status);\r\n}\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE))\r\nreturn;\r\nmlmeext_sta_del_event_callback(adapter);\r\nspin_lock_bh(&pmlmepriv->lock);\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\r\nif (pmlmepriv->to_roaming > 0)\r\npmlmepriv->to_roaming--;\r\nelse if (pmlmepriv->to_roaming == 0)\r\npmlmepriv->to_roaming = adapter->registrypriv.max_roaming_times;\r\nif (*((unsigned short *)(pstadel->rsvd)) != WLAN_REASON_EXPIRATION_CHK)\r\npmlmepriv->to_roaming = 0;\r\nrtw_free_uc_swdec_pending_queue(adapter);\r\nrtw_free_assoc_resources(adapter, 1);\r\nrtw_indicate_disconnect(adapter);\r\nspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\r\npwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);\r\nif (pwlan) {\r\npwlan->fixed = false;\r\nrtw_free_network_nolock(pmlmepriv, pwlan);\r\n}\r\nspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\r\n_rtw_roaming(adapter, tgt_network);\r\n}\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) ||\r\ncheck_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {\r\nspin_lock_bh(&(pstapriv->sta_hash_lock));\r\nrtw_free_stainfo(adapter, psta);\r\nspin_unlock_bh(&pstapriv->sta_hash_lock);\r\nif (adapter->stapriv.asoc_sta_count == 1) {\r\nspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\r\npwlan = rtw_find_network(&pmlmepriv->scanned_queue, tgt_network->network.MacAddress);\r\nif (pwlan) {\r\npwlan->fixed = false;\r\nrtw_free_network_nolock(pmlmepriv, pwlan);\r\n}\r\nspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\r\npdev_network = &(adapter->registrypriv.dev_network);\r\npibss = adapter->registrypriv.dev_network.MacAddress;\r\nmemcpy(pdev_network, &tgt_network->network, get_wlan_bssid_ex_sz(&tgt_network->network));\r\nmemcpy(&pdev_network->Ssid, &pmlmepriv->assoc_ssid, sizeof(struct ndis_802_11_ssid));\r\nrtw_update_registrypriv_dev_network(adapter);\r\nrtw_generate_random_ibss(pibss);\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {\r\nset_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE);\r\n_clr_fwstate_(pmlmepriv, WIFI_ADHOC_STATE);\r\n}\r\nif (rtw_createbss_cmd(adapter) != _SUCCESS)\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("***Error=>stadel_event_callback: rtw_createbss_cmd status FAIL***\n "));\r\n}\r\n}\r\nspin_unlock_bh(&pmlmepriv->lock);\r\n}\r\nvoid rtw_cpwm_event_callback(struct adapter *padapter, u8 *pbuf)\r\n{\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("+rtw_cpwm_event_callback !!!\n"));\r\n}\r\nvoid _rtw_join_timeout_handler (void *function_context)\r\n{\r\nstruct adapter *adapter = function_context;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nint do_join_r;\r\nDBG_88E("%s, fw_state=%x\n", __func__, get_fwstate(pmlmepriv));\r\nif (adapter->bDriverStopped || adapter->bSurpriseRemoved)\r\nreturn;\r\nspin_lock_bh(&pmlmepriv->lock);\r\nif (pmlmepriv->to_roaming > 0) {\r\nwhile (1) {\r\npmlmepriv->to_roaming--;\r\nif (pmlmepriv->to_roaming != 0) {\r\nDBG_88E("%s try another roaming\n", __func__);\r\ndo_join_r = rtw_do_join(adapter);\r\nif (_SUCCESS != do_join_r) {\r\nDBG_88E("%s roaming do_join return %d\n", __func__ , do_join_r);\r\ncontinue;\r\n}\r\nbreak;\r\n} else {\r\nDBG_88E("%s We've try roaming but fail\n", __func__);\r\nrtw_indicate_disconnect(adapter);\r\nbreak;\r\n}\r\n}\r\n} else {\r\nrtw_indicate_disconnect(adapter);\r\nfree_scanqueue(pmlmepriv);\r\n}\r\nspin_unlock_bh(&pmlmepriv->lock);\r\n}\r\nvoid rtw_scan_timeout_handler (void *function_context)\r\n{\r\nstruct adapter *adapter = function_context;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nDBG_88E(FUNC_ADPT_FMT" fw_state=%x\n", FUNC_ADPT_ARG(adapter), get_fwstate(pmlmepriv));\r\nspin_lock_bh(&pmlmepriv->lock);\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);\r\nspin_unlock_bh(&pmlmepriv->lock);\r\nrtw_indicate_scan_done(adapter, true);\r\n}\r\nstatic void rtw_auto_scan_handler(struct adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nif (pmlmepriv->scan_interval > 0) {\r\npmlmepriv->scan_interval--;\r\nif (pmlmepriv->scan_interval == 0) {\r\nDBG_88E("%s\n", __func__);\r\nrtw_set_802_11_bssid_list_scan(padapter, NULL, 0);\r\npmlmepriv->scan_interval = SCAN_INTERVAL;\r\n}\r\n}\r\n}\r\nvoid rtw_dynamic_check_timer_handlder(void *function_context)\r\n{\r\nstruct adapter *adapter = (struct adapter *)function_context;\r\nstruct registry_priv *pregistrypriv = &adapter->registrypriv;\r\nif (!adapter)\r\nreturn;\r\nif (!adapter->hw_init_completed)\r\ngoto exit;\r\nif ((adapter->bDriverStopped) || (adapter->bSurpriseRemoved))\r\ngoto exit;\r\nif (adapter->net_closed)\r\ngoto exit;\r\nrtw_dynamic_chk_wk_cmd(adapter);\r\nif (pregistrypriv->wifi_spec == 1) {\r\nrtw_auto_scan_handler(adapter);\r\n}\r\nexit:\r\n_set_timer(&adapter->mlmepriv.dynamic_chk_timer, 2000);\r\n}\r\nstatic int rtw_check_join_candidate(struct mlme_priv *pmlmepriv\r\n, struct wlan_network **candidate, struct wlan_network *competitor)\r\n{\r\nint updated = false;\r\nstruct adapter *adapter = container_of(pmlmepriv, struct adapter, mlmepriv);\r\nif (pmlmepriv->assoc_by_bssid) {\r\nif (memcmp(competitor->network.MacAddress, pmlmepriv->assoc_bssid, ETH_ALEN))\r\ngoto exit;\r\n}\r\nif (pmlmepriv->assoc_ssid.SsidLength) {\r\nif (competitor->network.Ssid.SsidLength != pmlmepriv->assoc_ssid.SsidLength ||\r\n!memcmp(competitor->network.Ssid.Ssid, pmlmepriv->assoc_ssid.Ssid, pmlmepriv->assoc_ssid.SsidLength) == false)\r\ngoto exit;\r\n}\r\nif (rtw_is_desired_network(adapter, competitor) == false)\r\ngoto exit;\r\nif (pmlmepriv->to_roaming) {\r\nif (rtw_get_passing_time_ms((u32)competitor->last_scanned) >= RTW_SCAN_RESULT_EXPIRE ||\r\nis_same_ess(&competitor->network, &pmlmepriv->cur_network.network) == false)\r\ngoto exit;\r\n}\r\nif (*candidate == NULL || (*candidate)->network.Rssi < competitor->network.Rssi) {\r\n*candidate = competitor;\r\nupdated = true;\r\n}\r\nif (updated) {\r\nDBG_88E("[by_bssid:%u][assoc_ssid:%s]new candidate: %s(%pM rssi:%d\n",\r\npmlmepriv->assoc_by_bssid,\r\npmlmepriv->assoc_ssid.Ssid,\r\n(*candidate)->network.Ssid.Ssid,\r\n(*candidate)->network.MacAddress,\r\n(int)(*candidate)->network.Rssi);\r\nDBG_88E("[to_roaming:%u]\n", pmlmepriv->to_roaming);\r\n}\r\nexit:\r\nreturn updated;\r\n}\r\nint rtw_select_and_join_from_scanned_queue(struct mlme_priv *pmlmepriv)\r\n{\r\nint ret;\r\nstruct list_head *phead;\r\nstruct adapter *adapter;\r\nstruct __queue *queue = &(pmlmepriv->scanned_queue);\r\nstruct wlan_network *pnetwork = NULL;\r\nstruct wlan_network *candidate = NULL;\r\nu8 supp_ant_div = false;\r\nspin_lock_bh(&(pmlmepriv->scanned_queue.lock));\r\nphead = get_list_head(queue);\r\nadapter = (struct adapter *)pmlmepriv->nic_hdl;\r\npmlmepriv->pscanned = phead->next;\r\nwhile (phead != pmlmepriv->pscanned) {\r\npnetwork = container_of(pmlmepriv->pscanned, struct wlan_network, list);\r\nif (pnetwork == NULL) {\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_, ("%s return _FAIL:(pnetwork==NULL)\n", __func__));\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\npmlmepriv->pscanned = pmlmepriv->pscanned->next;\r\nrtw_check_join_candidate(pmlmepriv, &candidate, pnetwork);\r\n}\r\nif (candidate == NULL) {\r\nDBG_88E("%s: return _FAIL(candidate==NULL)\n", __func__);\r\nret = _FAIL;\r\ngoto exit;\r\n} else {\r\nDBG_88E("%s: candidate: %s(%pM ch:%u)\n", __func__,\r\ncandidate->network.Ssid.Ssid, candidate->network.MacAddress,\r\ncandidate->network.Configuration.DSConfig);\r\n}\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == true) {\r\nDBG_88E("%s: _FW_LINKED while ask_for_joinbss!!!\n", __func__);\r\nrtw_disassoc_cmd(adapter, 0, true);\r\nrtw_indicate_disconnect(adapter);\r\nrtw_free_assoc_resources(adapter, 0);\r\n}\r\nrtw_hal_get_def_var(adapter, HAL_DEF_IS_SUPPORT_ANT_DIV, &(supp_ant_div));\r\nif (supp_ant_div) {\r\nu8 cur_ant;\r\nrtw_hal_get_def_var(adapter, HAL_DEF_CURRENT_ANTENNA, &(cur_ant));\r\nDBG_88E("#### Opt_Ant_(%s), cur_Ant(%s)\n",\r\n(2 == candidate->network.PhyInfo.Optimum_antenna) ? "A" : "B",\r\n(2 == cur_ant) ? "A" : "B"\r\n);\r\n}\r\nret = rtw_joinbss_cmd(adapter, candidate);\r\nexit:\r\nspin_unlock_bh(&pmlmepriv->scanned_queue.lock);\r\nreturn ret;\r\n}\r\nint rtw_set_auth(struct adapter *adapter, struct security_priv *psecuritypriv)\r\n{\r\nstruct cmd_obj *pcmd;\r\nstruct setauth_parm *psetauthparm;\r\nstruct cmd_priv *pcmdpriv = &(adapter->cmdpriv);\r\nint res = _SUCCESS;\r\npcmd = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);\r\nif (pcmd == NULL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npsetauthparm = kzalloc(sizeof(struct setauth_parm), GFP_KERNEL);\r\nif (psetauthparm == NULL) {\r\nkfree(pcmd);\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nmemset(psetauthparm, 0, sizeof(struct setauth_parm));\r\npsetauthparm->mode = (unsigned char)psecuritypriv->dot11AuthAlgrthm;\r\npcmd->cmdcode = _SetAuth_CMD_;\r\npcmd->parmbuf = (unsigned char *)psetauthparm;\r\npcmd->cmdsz = (sizeof(struct setauth_parm));\r\npcmd->rsp = NULL;\r\npcmd->rspsz = 0;\r\nINIT_LIST_HEAD(&pcmd->list);\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,\r\n("after enqueue set_auth_cmd, auth_mode=%x\n",\r\npsecuritypriv->dot11AuthAlgrthm));\r\nres = rtw_enqueue_cmd(pcmdpriv, pcmd);\r\nexit:\r\nreturn res;\r\n}\r\nint rtw_set_key(struct adapter *adapter, struct security_priv *psecuritypriv, int keyid, u8 set_tx)\r\n{\r\nu8 keylen;\r\nstruct cmd_obj *pcmd;\r\nstruct setkey_parm *psetkeyparm;\r\nstruct cmd_priv *pcmdpriv = &(adapter->cmdpriv);\r\nstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\r\nint res = _SUCCESS;\r\npcmd = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);\r\nif (pcmd == NULL)\r\nreturn _FAIL;\r\npsetkeyparm = kzalloc(sizeof(struct setkey_parm), GFP_KERNEL);\r\nif (psetkeyparm == NULL) {\r\nres = _FAIL;\r\ngoto err_free_cmd;\r\n}\r\nmemset(psetkeyparm, 0, sizeof(struct setkey_parm));\r\nif (psecuritypriv->dot11AuthAlgrthm == dot11AuthAlgrthm_8021X) {\r\npsetkeyparm->algorithm = (unsigned char)psecuritypriv->dot118021XGrpPrivacy;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,\r\n("\n rtw_set_key: psetkeyparm->algorithm=(unsigned char)psecuritypriv->dot118021XGrpPrivacy=%d\n",\r\npsetkeyparm->algorithm));\r\n} else {\r\npsetkeyparm->algorithm = (u8)psecuritypriv->dot11PrivacyAlgrthm;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,\r\n("\n rtw_set_key: psetkeyparm->algorithm=(u8)psecuritypriv->dot11PrivacyAlgrthm=%d\n",\r\npsetkeyparm->algorithm));\r\n}\r\npsetkeyparm->keyid = (u8)keyid;\r\npsetkeyparm->set_tx = set_tx;\r\npmlmepriv->key_mask |= BIT(psetkeyparm->keyid);\r\nDBG_88E("==> rtw_set_key algorithm(%x), keyid(%x), key_mask(%x)\n",\r\npsetkeyparm->algorithm, psetkeyparm->keyid, pmlmepriv->key_mask);\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,\r\n("\n rtw_set_key: psetkeyparm->algorithm=%d psetkeyparm->keyid=(u8)keyid=%d\n",\r\npsetkeyparm->algorithm, keyid));\r\nswitch (psetkeyparm->algorithm) {\r\ncase _WEP40_:\r\nkeylen = 5;\r\nmemcpy(&(psetkeyparm->key[0]), &(psecuritypriv->dot11DefKey[keyid].skey[0]), keylen);\r\nbreak;\r\ncase _WEP104_:\r\nkeylen = 13;\r\nmemcpy(&(psetkeyparm->key[0]), &(psecuritypriv->dot11DefKey[keyid].skey[0]), keylen);\r\nbreak;\r\ncase _TKIP_:\r\nkeylen = 16;\r\nmemcpy(&psetkeyparm->key, &psecuritypriv->dot118021XGrpKey[keyid], keylen);\r\npsetkeyparm->grpkey = 1;\r\nbreak;\r\ncase _AES_:\r\nkeylen = 16;\r\nmemcpy(&psetkeyparm->key, &psecuritypriv->dot118021XGrpKey[keyid], keylen);\r\npsetkeyparm->grpkey = 1;\r\nbreak;\r\ndefault:\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_err_,\r\n("\n rtw_set_key:psecuritypriv->dot11PrivacyAlgrthm=%x (must be 1 or 2 or 4 or 5)\n",\r\npsecuritypriv->dot11PrivacyAlgrthm));\r\nres = _FAIL;\r\ngoto err_free_parm;\r\n}\r\npcmd->cmdcode = _SetKey_CMD_;\r\npcmd->parmbuf = (u8 *)psetkeyparm;\r\npcmd->cmdsz = (sizeof(struct setkey_parm));\r\npcmd->rsp = NULL;\r\npcmd->rspsz = 0;\r\nINIT_LIST_HEAD(&pcmd->list);\r\nres = rtw_enqueue_cmd(pcmdpriv, pcmd);\r\nreturn res;\r\nerr_free_parm:\r\nkfree(psetkeyparm);\r\nerr_free_cmd:\r\nkfree(pcmd);\r\nreturn res;\r\n}\r\nint rtw_restruct_wmm_ie(struct adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len, uint initial_out_len)\r\n{\r\nunsigned int ielength = 0;\r\nunsigned int i, j;\r\ni = 12;\r\nwhile (i < in_len) {\r\nielength = initial_out_len;\r\nif (in_ie[i] == 0xDD && in_ie[i+2] == 0x00 && in_ie[i+3] == 0x50 && in_ie[i+4] == 0xF2 && in_ie[i+5] == 0x02 && i+5 < in_len) {\r\nfor (j = i; j < i + 9; j++) {\r\nout_ie[ielength] = in_ie[j];\r\nielength++;\r\n}\r\nout_ie[initial_out_len + 1] = 0x07;\r\nout_ie[initial_out_len + 6] = 0x00;\r\nout_ie[initial_out_len + 8] = 0x00;\r\nbreak;\r\n}\r\ni += (in_ie[i+1]+2);\r\n}\r\nreturn ielength;\r\n}\r\nstatic int SecIsInPMKIDList(struct adapter *Adapter, u8 *bssid)\r\n{\r\nstruct security_priv *psecuritypriv = &Adapter->securitypriv;\r\nint i = 0;\r\ndo {\r\nif ((psecuritypriv->PMKIDList[i].bUsed) &&\r\n(!memcmp(psecuritypriv->PMKIDList[i].Bssid, bssid, ETH_ALEN))) {\r\nbreak;\r\n} else {\r\ni++;\r\n}\r\n} while (i < NUM_PMKID_CACHE);\r\nif (i == NUM_PMKID_CACHE)\r\ni = -1;\r\nreturn i;\r\n}\r\nstatic int rtw_append_pmkid(struct adapter *Adapter, int iEntry, u8 *ie, uint ie_len)\r\n{\r\nstruct security_priv *psecuritypriv = &Adapter->securitypriv;\r\nif (ie[13] <= 20) {\r\nie[ie_len] = 1;\r\nie_len++;\r\nie[ie_len] = 0;\r\nie_len++;\r\nmemcpy(&ie[ie_len], &psecuritypriv->PMKIDList[iEntry].PMKID, 16);\r\nie_len += 16;\r\nie[13] += 18;\r\n}\r\nreturn ie_len;\r\n}\r\nint rtw_restruct_sec_ie(struct adapter *adapter, u8 *in_ie, u8 *out_ie, uint in_len)\r\n{\r\nu8 authmode;\r\nuint ielength;\r\nint iEntry;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nstruct security_priv *psecuritypriv = &adapter->securitypriv;\r\nuint ndisauthmode = psecuritypriv->ndisauthtype;\r\nuint ndissecuritytype = psecuritypriv->ndisencryptstatus;\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_notice_,\r\n("+rtw_restruct_sec_ie: ndisauthmode=%d ndissecuritytype=%d\n",\r\nndisauthmode, ndissecuritytype));\r\nmemcpy(out_ie, in_ie, 12);\r\nielength = 12;\r\nif ((ndisauthmode == Ndis802_11AuthModeWPA) ||\r\n(ndisauthmode == Ndis802_11AuthModeWPAPSK))\r\nauthmode = _WPA_IE_ID_;\r\nif ((ndisauthmode == Ndis802_11AuthModeWPA2) ||\r\n(ndisauthmode == Ndis802_11AuthModeWPA2PSK))\r\nauthmode = _WPA2_IE_ID_;\r\nif (check_fwstate(pmlmepriv, WIFI_UNDER_WPS)) {\r\nmemcpy(out_ie+ielength, psecuritypriv->wps_ie, psecuritypriv->wps_ie_len);\r\nielength += psecuritypriv->wps_ie_len;\r\n} else if ((authmode == _WPA_IE_ID_) || (authmode == _WPA2_IE_ID_)) {\r\nmemcpy(&out_ie[ielength], &psecuritypriv->supplicant_ie[0], psecuritypriv->supplicant_ie[1]+2);\r\nielength += psecuritypriv->supplicant_ie[1]+2;\r\nrtw_report_sec_ie(adapter, authmode, psecuritypriv->supplicant_ie);\r\n}\r\niEntry = SecIsInPMKIDList(adapter, pmlmepriv->assoc_bssid);\r\nif (iEntry < 0) {\r\nreturn ielength;\r\n} else {\r\nif (authmode == _WPA2_IE_ID_)\r\nielength = rtw_append_pmkid(adapter, iEntry, out_ie, ielength);\r\n}\r\nreturn ielength;\r\n}\r\nvoid rtw_init_registrypriv_dev_network(struct adapter *adapter)\r\n{\r\nstruct registry_priv *pregistrypriv = &adapter->registrypriv;\r\nstruct eeprom_priv *peepriv = &adapter->eeprompriv;\r\nstruct wlan_bssid_ex *pdev_network = &pregistrypriv->dev_network;\r\nu8 *myhwaddr = myid(peepriv);\r\nmemcpy(pdev_network->MacAddress, myhwaddr, ETH_ALEN);\r\nmemcpy(&pdev_network->Ssid, &pregistrypriv->ssid, sizeof(struct ndis_802_11_ssid));\r\npdev_network->Configuration.Length = sizeof(struct ndis_802_11_config);\r\npdev_network->Configuration.BeaconPeriod = 100;\r\npdev_network->Configuration.FHConfig.Length = 0;\r\npdev_network->Configuration.FHConfig.HopPattern = 0;\r\npdev_network->Configuration.FHConfig.HopSet = 0;\r\npdev_network->Configuration.FHConfig.DwellTime = 0;\r\n}\r\nvoid rtw_update_registrypriv_dev_network(struct adapter *adapter)\r\n{\r\nint sz = 0;\r\nstruct registry_priv *pregistrypriv = &adapter->registrypriv;\r\nstruct wlan_bssid_ex *pdev_network = &pregistrypriv->dev_network;\r\nstruct security_priv *psecuritypriv = &adapter->securitypriv;\r\nstruct wlan_network *cur_network = &adapter->mlmepriv.cur_network;\r\npdev_network->Privacy = (psecuritypriv->dot11PrivacyAlgrthm > 0 ? 1 : 0);\r\npdev_network->Rssi = 0;\r\nswitch (pregistrypriv->wireless_mode) {\r\ncase WIRELESS_11B:\r\npdev_network->NetworkTypeInUse = (Ndis802_11DS);\r\nbreak;\r\ncase WIRELESS_11G:\r\ncase WIRELESS_11BG:\r\ncase WIRELESS_11_24N:\r\ncase WIRELESS_11G_24N:\r\ncase WIRELESS_11BG_24N:\r\npdev_network->NetworkTypeInUse = (Ndis802_11OFDM24);\r\nbreak;\r\ncase WIRELESS_11A:\r\ncase WIRELESS_11A_5N:\r\npdev_network->NetworkTypeInUse = (Ndis802_11OFDM5);\r\nbreak;\r\ncase WIRELESS_11ABGN:\r\nif (pregistrypriv->channel > 14)\r\npdev_network->NetworkTypeInUse = (Ndis802_11OFDM5);\r\nelse\r\npdev_network->NetworkTypeInUse = (Ndis802_11OFDM24);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npdev_network->Configuration.DSConfig = (pregistrypriv->channel);\r\nRT_TRACE(_module_rtl871x_mlme_c_, _drv_info_,\r\n("pregistrypriv->channel=%d, pdev_network->Configuration.DSConfig=0x%x\n",\r\npregistrypriv->channel, pdev_network->Configuration.DSConfig));\r\nif (cur_network->network.InfrastructureMode == Ndis802_11IBSS)\r\npdev_network->Configuration.ATIMWindow = (0);\r\npdev_network->InfrastructureMode = (cur_network->network.InfrastructureMode);\r\nsz = rtw_generate_ie(pregistrypriv);\r\npdev_network->IELength = sz;\r\npdev_network->Length = get_wlan_bssid_ex_sz((struct wlan_bssid_ex *)pdev_network);\r\n}\r\nvoid rtw_get_encrypt_decrypt_from_registrypriv(struct adapter *adapter)\r\n{\r\n}\r\nvoid rtw_joinbss_reset(struct adapter *padapter)\r\n{\r\nu8 threshold;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\r\npmlmepriv->num_FortyMHzIntolerant = 0;\r\npmlmepriv->num_sta_no_ht = 0;\r\nphtpriv->ampdu_enable = false;\r\nif (phtpriv->ht_option) {\r\nif (padapter->registrypriv.wifi_spec == 1)\r\nthreshold = 1;\r\nelse\r\nthreshold = 0;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_RXDMA_AGG_PG_TH, (u8 *)(&threshold));\r\n} else {\r\nthreshold = 1;\r\nrtw_hal_set_hwreg(padapter, HW_VAR_RXDMA_AGG_PG_TH, (u8 *)(&threshold));\r\n}\r\n}\r\nunsigned int rtw_restructure_ht_ie(struct adapter *padapter, u8 *in_ie, u8 *out_ie, uint in_len, uint *pout_len)\r\n{\r\nu32 ielen, out_len;\r\nenum ht_cap_ampdu_factor max_rx_ampdu_factor;\r\nunsigned char *p;\r\nstruct rtw_ieee80211_ht_cap ht_capie;\r\nunsigned char WMM_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00};\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct qos_priv *pqospriv = &pmlmepriv->qospriv;\r\nstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\r\nu32 rx_packet_offset, max_recvbuf_sz;\r\nphtpriv->ht_option = false;\r\np = rtw_get_ie(in_ie+12, _HT_CAPABILITY_IE_, &ielen, in_len-12);\r\nif (p && ielen > 0) {\r\nif (pqospriv->qos_option == 0) {\r\nout_len = *pout_len;\r\nrtw_set_ie(out_ie+out_len, _VENDOR_SPECIFIC_IE_,\r\n_WMM_IE_Length_, WMM_IE, pout_len);\r\npqospriv->qos_option = 1;\r\n}\r\nout_len = *pout_len;\r\nmemset(&ht_capie, 0, sizeof(struct rtw_ieee80211_ht_cap));\r\nht_capie.cap_info = IEEE80211_HT_CAP_SUP_WIDTH |\r\nIEEE80211_HT_CAP_SGI_20 |\r\nIEEE80211_HT_CAP_SGI_40 |\r\nIEEE80211_HT_CAP_TX_STBC |\r\nIEEE80211_HT_CAP_DSSSCCK40;\r\nrtw_hal_get_def_var(padapter, HAL_DEF_RX_PACKET_OFFSET, &rx_packet_offset);\r\nrtw_hal_get_def_var(padapter, HAL_DEF_MAX_RECVBUF_SZ, &max_recvbuf_sz);\r\nrtw_hal_get_def_var(padapter, HW_VAR_MAX_RX_AMPDU_FACTOR, &max_rx_ampdu_factor);\r\nht_capie.ampdu_params_info = (max_rx_ampdu_factor&0x03);\r\nif (padapter->securitypriv.dot11PrivacyAlgrthm == _AES_)\r\nht_capie.ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&(0x07<<2));\r\nelse\r\nht_capie.ampdu_params_info |= (IEEE80211_HT_CAP_AMPDU_DENSITY&0x00);\r\nrtw_set_ie(out_ie+out_len, _HT_CAPABILITY_IE_,\r\nsizeof(struct rtw_ieee80211_ht_cap), (unsigned char *)&ht_capie, pout_len);\r\nphtpriv->ht_option = true;\r\np = rtw_get_ie(in_ie+12, _HT_ADD_INFO_IE_, &ielen, in_len-12);\r\nif (p && (ielen == sizeof(struct ieee80211_ht_addt_info))) {\r\nout_len = *pout_len;\r\nrtw_set_ie(out_ie+out_len, _HT_ADD_INFO_IE_, ielen, p+2 , pout_len);\r\n}\r\n}\r\nreturn phtpriv->ht_option;\r\n}\r\nvoid rtw_update_ht_cap(struct adapter *padapter, u8 *pie, uint ie_len)\r\n{\r\nu8 *p, max_ampdu_sz;\r\nint len;\r\nstruct rtw_ieee80211_ht_cap *pht_capie;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\r\nstruct registry_priv *pregistrypriv = &padapter->registrypriv;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nif (!phtpriv->ht_option)\r\nreturn;\r\nif ((!pmlmeinfo->HT_info_enable) || (!pmlmeinfo->HT_caps_enable))\r\nreturn;\r\nDBG_88E("+rtw_update_ht_cap()\n");\r\nif ((!phtpriv->ampdu_enable) && (pregistrypriv->ampdu_enable == 1)) {\r\nif (pregistrypriv->wifi_spec == 1)\r\nphtpriv->ampdu_enable = false;\r\nelse\r\nphtpriv->ampdu_enable = true;\r\n} else if (pregistrypriv->ampdu_enable == 2) {\r\nphtpriv->ampdu_enable = true;\r\n}\r\nlen = 0;\r\np = rtw_get_ie(pie+sizeof(struct ndis_802_11_fixed_ie), _HT_CAPABILITY_IE_, &len, ie_len-sizeof(struct ndis_802_11_fixed_ie));\r\nif (p && len > 0) {\r\npht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);\r\nmax_ampdu_sz = (pht_capie->ampdu_params_info & IEEE80211_HT_CAP_AMPDU_FACTOR);\r\nmax_ampdu_sz = 1 << (max_ampdu_sz+3);\r\nphtpriv->rx_ampdu_maxlen = max_ampdu_sz;\r\n}\r\nlen = 0;\r\np = rtw_get_ie(pie+sizeof(struct ndis_802_11_fixed_ie), _HT_ADD_INFO_IE_, &len, ie_len-sizeof(struct ndis_802_11_fixed_ie));\r\nif ((pregistrypriv->cbw40_enable) &&\r\n(le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info) & BIT(1)) &&\r\n(pmlmeinfo->HT_info.infos[0] & BIT(2))) {\r\nint i;\r\nu8 rf_type;\r\npadapter->HalFunc.GetHwRegHandler(padapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));\r\nfor (i = 0; i < 16; i++) {\r\nif ((rf_type == RF_1T1R) || (rf_type == RF_1T2R))\r\npmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_1R[i];\r\nelse\r\npmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate[i] &= MCS_rate_2R[i];\r\n}\r\npmlmeext->cur_bwmode = HT_CHANNEL_WIDTH_40;\r\nswitch ((pmlmeinfo->HT_info.infos[0] & 0x3)) {\r\ncase HT_EXTCHNL_OFFSET_UPPER:\r\npmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_LOWER;\r\nbreak;\r\ncase HT_EXTCHNL_OFFSET_LOWER:\r\npmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_UPPER;\r\nbreak;\r\ndefault:\r\npmlmeext->cur_ch_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\nbreak;\r\n}\r\n}\r\npmlmeinfo->SM_PS = (le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info) & 0x0C) >> 2;\r\nif (pmlmeinfo->SM_PS == WLAN_HT_CAP_SM_PS_STATIC)\r\nDBG_88E("%s(): WLAN_HT_CAP_SM_PS_STATIC\n", __func__);\r\npmlmeinfo->HT_protection = pmlmeinfo->HT_info.infos[1] & 0x3;\r\n}\r\nvoid rtw_issue_addbareq_cmd(struct adapter *padapter, struct xmit_frame *pxmitframe)\r\n{\r\nu8 issued;\r\nint priority;\r\nstruct sta_info *psta = NULL;\r\nstruct ht_priv *phtpriv;\r\nstruct pkt_attrib *pattrib = &pxmitframe->attrib;\r\ns32 bmcst = IS_MCAST(pattrib->ra);\r\nif (bmcst || (padapter->mlmepriv.LinkDetectInfo.NumTxOkInPeriod < 100))\r\nreturn;\r\npriority = pattrib->priority;\r\nif (pattrib->psta)\r\npsta = pattrib->psta;\r\nelse\r\npsta = rtw_get_stainfo(&padapter->stapriv, pattrib->ra);\r\nif (psta == NULL)\r\nreturn;\r\nphtpriv = &psta->htpriv;\r\nif ((phtpriv->ht_option) && (phtpriv->ampdu_enable)) {\r\nissued = (phtpriv->agg_enable_bitmap>>priority)&0x1;\r\nissued |= (phtpriv->candidate_tid_bitmap>>priority)&0x1;\r\nif (0 == issued) {\r\nDBG_88E("rtw_issue_addbareq_cmd, p=%d\n", priority);\r\npsta->htpriv.candidate_tid_bitmap |= BIT((u8)priority);\r\nrtw_addbareq_cmd(padapter, (u8)priority, pattrib->ra);\r\n}\r\n}\r\n}\r\nvoid rtw_roaming(struct adapter *padapter, struct wlan_network *tgt_network)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nspin_lock_bh(&pmlmepriv->lock);\r\n_rtw_roaming(padapter, tgt_network);\r\nspin_unlock_bh(&pmlmepriv->lock);\r\n}\r\nvoid _rtw_roaming(struct adapter *padapter, struct wlan_network *tgt_network)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nint do_join_r;\r\nstruct wlan_network *pnetwork;\r\nif (tgt_network != NULL)\r\npnetwork = tgt_network;\r\nelse\r\npnetwork = &pmlmepriv->cur_network;\r\nif (0 < pmlmepriv->to_roaming) {\r\nDBG_88E("roaming from %s(%pM length:%d\n",\r\npnetwork->network.Ssid.Ssid, pnetwork->network.MacAddress,\r\npnetwork->network.Ssid.SsidLength);\r\nmemcpy(&pmlmepriv->assoc_ssid, &pnetwork->network.Ssid, sizeof(struct ndis_802_11_ssid));\r\npmlmepriv->assoc_by_bssid = false;\r\nwhile (1) {\r\ndo_join_r = rtw_do_join(padapter);\r\nif (_SUCCESS == do_join_r) {\r\nbreak;\r\n} else {\r\nDBG_88E("roaming do_join return %d\n", do_join_r);\r\npmlmepriv->to_roaming--;\r\nif (0 < pmlmepriv->to_roaming) {\r\ncontinue;\r\n} else {\r\nDBG_88E("%s(%d) -to roaming fail, indicate_disconnect\n", __func__, __LINE__);\r\nrtw_indicate_disconnect(padapter);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\n}
