static inline struct sctp_net *sctp_pernet(struct net *net)\r\n{\r\nreturn net_generic(net, sctp_net_id);\r\n}\r\nstatic bool sctp_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,\r\nstruct nf_conntrack_tuple *tuple)\r\n{\r\nconst struct sctphdr *hp;\r\nstruct sctphdr _hdr;\r\nhp = skb_header_pointer(skb, dataoff, 8, &_hdr);\r\nif (hp == NULL)\r\nreturn false;\r\ntuple->src.u.sctp.port = hp->source;\r\ntuple->dst.u.sctp.port = hp->dest;\r\nreturn true;\r\n}\r\nstatic bool sctp_invert_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_tuple *orig)\r\n{\r\ntuple->src.u.sctp.port = orig->dst.u.sctp.port;\r\ntuple->dst.u.sctp.port = orig->src.u.sctp.port;\r\nreturn true;\r\n}\r\nstatic void sctp_print_tuple(struct seq_file *s,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nseq_printf(s, "sport=%hu dport=%hu ",\r\nntohs(tuple->src.u.sctp.port),\r\nntohs(tuple->dst.u.sctp.port));\r\n}\r\nstatic void sctp_print_conntrack(struct seq_file *s, struct nf_conn *ct)\r\n{\r\nenum sctp_conntrack state;\r\nspin_lock_bh(&ct->lock);\r\nstate = ct->proto.sctp.state;\r\nspin_unlock_bh(&ct->lock);\r\nseq_printf(s, "%s ", sctp_conntrack_names[state]);\r\n}\r\nstatic int do_basic_checks(struct nf_conn *ct,\r\nconst struct sk_buff *skb,\r\nunsigned int dataoff,\r\nunsigned long *map)\r\n{\r\nu_int32_t offset, count;\r\nsctp_chunkhdr_t _sch, *sch;\r\nint flag;\r\nflag = 0;\r\nfor_each_sctp_chunk (skb, sch, _sch, offset, dataoff, count) {\r\npr_debug("Chunk Num: %d Type: %d\n", count, sch->type);\r\nif (sch->type == SCTP_CID_INIT ||\r\nsch->type == SCTP_CID_INIT_ACK ||\r\nsch->type == SCTP_CID_SHUTDOWN_COMPLETE)\r\nflag = 1;\r\nif (((sch->type == SCTP_CID_COOKIE_ACK ||\r\nsch->type == SCTP_CID_COOKIE_ECHO ||\r\nflag) &&\r\ncount != 0) || !sch->length) {\r\npr_debug("Basic checks failed\n");\r\nreturn 1;\r\n}\r\nif (map)\r\nset_bit(sch->type, map);\r\n}\r\npr_debug("Basic checks passed\n");\r\nreturn count == 0;\r\n}\r\nstatic int sctp_new_state(enum ip_conntrack_dir dir,\r\nenum sctp_conntrack cur_state,\r\nint chunk_type)\r\n{\r\nint i;\r\npr_debug("Chunk type: %d\n", chunk_type);\r\nswitch (chunk_type) {\r\ncase SCTP_CID_INIT:\r\npr_debug("SCTP_CID_INIT\n");\r\ni = 0;\r\nbreak;\r\ncase SCTP_CID_INIT_ACK:\r\npr_debug("SCTP_CID_INIT_ACK\n");\r\ni = 1;\r\nbreak;\r\ncase SCTP_CID_ABORT:\r\npr_debug("SCTP_CID_ABORT\n");\r\ni = 2;\r\nbreak;\r\ncase SCTP_CID_SHUTDOWN:\r\npr_debug("SCTP_CID_SHUTDOWN\n");\r\ni = 3;\r\nbreak;\r\ncase SCTP_CID_SHUTDOWN_ACK:\r\npr_debug("SCTP_CID_SHUTDOWN_ACK\n");\r\ni = 4;\r\nbreak;\r\ncase SCTP_CID_ERROR:\r\npr_debug("SCTP_CID_ERROR\n");\r\ni = 5;\r\nbreak;\r\ncase SCTP_CID_COOKIE_ECHO:\r\npr_debug("SCTP_CID_COOKIE_ECHO\n");\r\ni = 6;\r\nbreak;\r\ncase SCTP_CID_COOKIE_ACK:\r\npr_debug("SCTP_CID_COOKIE_ACK\n");\r\ni = 7;\r\nbreak;\r\ncase SCTP_CID_SHUTDOWN_COMPLETE:\r\npr_debug("SCTP_CID_SHUTDOWN_COMPLETE\n");\r\ni = 8;\r\nbreak;\r\ndefault:\r\npr_debug("Unknown chunk type, Will stay in %s\n",\r\nsctp_conntrack_names[cur_state]);\r\nreturn cur_state;\r\n}\r\npr_debug("dir: %d cur_state: %s chunk_type: %d new_state: %s\n",\r\ndir, sctp_conntrack_names[cur_state], chunk_type,\r\nsctp_conntrack_names[sctp_conntracks[dir][i][cur_state]]);\r\nreturn sctp_conntracks[dir][i][cur_state];\r\n}\r\nstatic unsigned int *sctp_get_timeouts(struct net *net)\r\n{\r\nreturn sctp_pernet(net)->timeouts;\r\n}\r\nstatic int sctp_packet(struct nf_conn *ct,\r\nconst struct sk_buff *skb,\r\nunsigned int dataoff,\r\nenum ip_conntrack_info ctinfo,\r\nu_int8_t pf,\r\nunsigned int hooknum,\r\nunsigned int *timeouts)\r\n{\r\nenum sctp_conntrack new_state, old_state;\r\nenum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);\r\nconst struct sctphdr *sh;\r\nstruct sctphdr _sctph;\r\nconst struct sctp_chunkhdr *sch;\r\nstruct sctp_chunkhdr _sch;\r\nu_int32_t offset, count;\r\nunsigned long map[256 / sizeof(unsigned long)] = { 0 };\r\nsh = skb_header_pointer(skb, dataoff, sizeof(_sctph), &_sctph);\r\nif (sh == NULL)\r\ngoto out;\r\nif (do_basic_checks(ct, skb, dataoff, map) != 0)\r\ngoto out;\r\nif (!test_bit(SCTP_CID_INIT, map) &&\r\n!test_bit(SCTP_CID_SHUTDOWN_COMPLETE, map) &&\r\n!test_bit(SCTP_CID_COOKIE_ECHO, map) &&\r\n!test_bit(SCTP_CID_ABORT, map) &&\r\n!test_bit(SCTP_CID_SHUTDOWN_ACK, map) &&\r\nsh->vtag != ct->proto.sctp.vtag[dir]) {\r\npr_debug("Verification tag check failed\n");\r\ngoto out;\r\n}\r\nold_state = new_state = SCTP_CONNTRACK_NONE;\r\nspin_lock_bh(&ct->lock);\r\nfor_each_sctp_chunk (skb, sch, _sch, offset, dataoff, count) {\r\nif (sch->type == SCTP_CID_INIT) {\r\nif (sh->vtag != 0)\r\ngoto out_unlock;\r\n} else if (sch->type == SCTP_CID_ABORT) {\r\nif (sh->vtag != ct->proto.sctp.vtag[dir] &&\r\nsh->vtag != ct->proto.sctp.vtag[!dir])\r\ngoto out_unlock;\r\n} else if (sch->type == SCTP_CID_SHUTDOWN_COMPLETE) {\r\nif (sh->vtag != ct->proto.sctp.vtag[dir] &&\r\nsh->vtag != ct->proto.sctp.vtag[!dir] &&\r\nsch->flags & SCTP_CHUNK_FLAG_T)\r\ngoto out_unlock;\r\n} else if (sch->type == SCTP_CID_COOKIE_ECHO) {\r\nif (sh->vtag != ct->proto.sctp.vtag[dir])\r\ngoto out_unlock;\r\n}\r\nold_state = ct->proto.sctp.state;\r\nnew_state = sctp_new_state(dir, old_state, sch->type);\r\nif (new_state == SCTP_CONNTRACK_MAX) {\r\npr_debug("nf_conntrack_sctp: Invalid dir=%i ctype=%u "\r\n"conntrack=%u\n",\r\ndir, sch->type, old_state);\r\ngoto out_unlock;\r\n}\r\nif (sch->type == SCTP_CID_INIT ||\r\nsch->type == SCTP_CID_INIT_ACK) {\r\nsctp_inithdr_t _inithdr, *ih;\r\nih = skb_header_pointer(skb, offset + sizeof(sctp_chunkhdr_t),\r\nsizeof(_inithdr), &_inithdr);\r\nif (ih == NULL)\r\ngoto out_unlock;\r\npr_debug("Setting vtag %x for dir %d\n",\r\nih->init_tag, !dir);\r\nct->proto.sctp.vtag[!dir] = ih->init_tag;\r\n}\r\nct->proto.sctp.state = new_state;\r\nif (old_state != new_state)\r\nnf_conntrack_event_cache(IPCT_PROTOINFO, ct);\r\n}\r\nspin_unlock_bh(&ct->lock);\r\nnf_ct_refresh_acct(ct, ctinfo, skb, timeouts[new_state]);\r\nif (old_state == SCTP_CONNTRACK_COOKIE_ECHOED &&\r\ndir == IP_CT_DIR_REPLY &&\r\nnew_state == SCTP_CONNTRACK_ESTABLISHED) {\r\npr_debug("Setting assured bit\n");\r\nset_bit(IPS_ASSURED_BIT, &ct->status);\r\nnf_conntrack_event_cache(IPCT_ASSURED, ct);\r\n}\r\nreturn NF_ACCEPT;\r\nout_unlock:\r\nspin_unlock_bh(&ct->lock);\r\nout:\r\nreturn -NF_ACCEPT;\r\n}\r\nstatic bool sctp_new(struct nf_conn *ct, const struct sk_buff *skb,\r\nunsigned int dataoff, unsigned int *timeouts)\r\n{\r\nenum sctp_conntrack new_state;\r\nconst struct sctphdr *sh;\r\nstruct sctphdr _sctph;\r\nconst struct sctp_chunkhdr *sch;\r\nstruct sctp_chunkhdr _sch;\r\nu_int32_t offset, count;\r\nunsigned long map[256 / sizeof(unsigned long)] = { 0 };\r\nsh = skb_header_pointer(skb, dataoff, sizeof(_sctph), &_sctph);\r\nif (sh == NULL)\r\nreturn false;\r\nif (do_basic_checks(ct, skb, dataoff, map) != 0)\r\nreturn false;\r\nif (test_bit(SCTP_CID_ABORT, map) ||\r\ntest_bit(SCTP_CID_SHUTDOWN_COMPLETE, map) ||\r\ntest_bit(SCTP_CID_COOKIE_ACK, map))\r\nreturn false;\r\nmemset(&ct->proto.sctp, 0, sizeof(ct->proto.sctp));\r\nnew_state = SCTP_CONNTRACK_MAX;\r\nfor_each_sctp_chunk (skb, sch, _sch, offset, dataoff, count) {\r\nnew_state = sctp_new_state(IP_CT_DIR_ORIGINAL,\r\nSCTP_CONNTRACK_NONE, sch->type);\r\nif (new_state == SCTP_CONNTRACK_NONE ||\r\nnew_state == SCTP_CONNTRACK_MAX) {\r\npr_debug("nf_conntrack_sctp: invalid new deleting.\n");\r\nreturn false;\r\n}\r\nif (sch->type == SCTP_CID_INIT) {\r\nif (sh->vtag == 0) {\r\nsctp_inithdr_t _inithdr, *ih;\r\nih = skb_header_pointer(skb, offset + sizeof(sctp_chunkhdr_t),\r\nsizeof(_inithdr), &_inithdr);\r\nif (ih == NULL)\r\nreturn false;\r\npr_debug("Setting vtag %x for new conn\n",\r\nih->init_tag);\r\nct->proto.sctp.vtag[IP_CT_DIR_REPLY] =\r\nih->init_tag;\r\n} else {\r\nreturn false;\r\n}\r\n}\r\nelse {\r\npr_debug("Setting vtag %x for new conn OOTB\n",\r\nsh->vtag);\r\nct->proto.sctp.vtag[IP_CT_DIR_REPLY] = sh->vtag;\r\n}\r\nct->proto.sctp.state = new_state;\r\n}\r\nreturn true;\r\n}\r\nstatic int sctp_to_nlattr(struct sk_buff *skb, struct nlattr *nla,\r\nstruct nf_conn *ct)\r\n{\r\nstruct nlattr *nest_parms;\r\nspin_lock_bh(&ct->lock);\r\nnest_parms = nla_nest_start(skb, CTA_PROTOINFO_SCTP | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nif (nla_put_u8(skb, CTA_PROTOINFO_SCTP_STATE, ct->proto.sctp.state) ||\r\nnla_put_be32(skb, CTA_PROTOINFO_SCTP_VTAG_ORIGINAL,\r\nct->proto.sctp.vtag[IP_CT_DIR_ORIGINAL]) ||\r\nnla_put_be32(skb, CTA_PROTOINFO_SCTP_VTAG_REPLY,\r\nct->proto.sctp.vtag[IP_CT_DIR_REPLY]))\r\ngoto nla_put_failure;\r\nspin_unlock_bh(&ct->lock);\r\nnla_nest_end(skb, nest_parms);\r\nreturn 0;\r\nnla_put_failure:\r\nspin_unlock_bh(&ct->lock);\r\nreturn -1;\r\n}\r\nstatic int nlattr_to_sctp(struct nlattr *cda[], struct nf_conn *ct)\r\n{\r\nstruct nlattr *attr = cda[CTA_PROTOINFO_SCTP];\r\nstruct nlattr *tb[CTA_PROTOINFO_SCTP_MAX+1];\r\nint err;\r\nif (!attr)\r\nreturn 0;\r\nerr = nla_parse_nested(tb,\r\nCTA_PROTOINFO_SCTP_MAX,\r\nattr,\r\nsctp_nla_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (!tb[CTA_PROTOINFO_SCTP_STATE] ||\r\n!tb[CTA_PROTOINFO_SCTP_VTAG_ORIGINAL] ||\r\n!tb[CTA_PROTOINFO_SCTP_VTAG_REPLY])\r\nreturn -EINVAL;\r\nspin_lock_bh(&ct->lock);\r\nct->proto.sctp.state = nla_get_u8(tb[CTA_PROTOINFO_SCTP_STATE]);\r\nct->proto.sctp.vtag[IP_CT_DIR_ORIGINAL] =\r\nnla_get_be32(tb[CTA_PROTOINFO_SCTP_VTAG_ORIGINAL]);\r\nct->proto.sctp.vtag[IP_CT_DIR_REPLY] =\r\nnla_get_be32(tb[CTA_PROTOINFO_SCTP_VTAG_REPLY]);\r\nspin_unlock_bh(&ct->lock);\r\nreturn 0;\r\n}\r\nstatic int sctp_nlattr_size(void)\r\n{\r\nreturn nla_total_size(0)\r\n+ nla_policy_len(sctp_nla_policy, CTA_PROTOINFO_SCTP_MAX + 1);\r\n}\r\nstatic int sctp_timeout_nlattr_to_obj(struct nlattr *tb[],\r\nstruct net *net, void *data)\r\n{\r\nunsigned int *timeouts = data;\r\nstruct sctp_net *sn = sctp_pernet(net);\r\nint i;\r\nfor (i=0; i<SCTP_CONNTRACK_MAX; i++)\r\ntimeouts[i] = sn->timeouts[i];\r\nfor (i=CTA_TIMEOUT_SCTP_UNSPEC+1; i<CTA_TIMEOUT_SCTP_MAX+1; i++) {\r\nif (tb[i]) {\r\ntimeouts[i] = ntohl(nla_get_be32(tb[i])) * HZ;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsctp_timeout_obj_to_nlattr(struct sk_buff *skb, const void *data)\r\n{\r\nconst unsigned int *timeouts = data;\r\nint i;\r\nfor (i=CTA_TIMEOUT_SCTP_UNSPEC+1; i<CTA_TIMEOUT_SCTP_MAX+1; i++) {\r\nif (nla_put_be32(skb, i, htonl(timeouts[i] / HZ)))\r\ngoto nla_put_failure;\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -ENOSPC;\r\n}\r\nstatic int sctp_kmemdup_sysctl_table(struct nf_proto_net *pn,\r\nstruct sctp_net *sn)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\nif (pn->ctl_table)\r\nreturn 0;\r\npn->ctl_table = kmemdup(sctp_sysctl_table,\r\nsizeof(sctp_sysctl_table),\r\nGFP_KERNEL);\r\nif (!pn->ctl_table)\r\nreturn -ENOMEM;\r\npn->ctl_table[0].data = &sn->timeouts[SCTP_CONNTRACK_CLOSED];\r\npn->ctl_table[1].data = &sn->timeouts[SCTP_CONNTRACK_COOKIE_WAIT];\r\npn->ctl_table[2].data = &sn->timeouts[SCTP_CONNTRACK_COOKIE_ECHOED];\r\npn->ctl_table[3].data = &sn->timeouts[SCTP_CONNTRACK_ESTABLISHED];\r\npn->ctl_table[4].data = &sn->timeouts[SCTP_CONNTRACK_SHUTDOWN_SENT];\r\npn->ctl_table[5].data = &sn->timeouts[SCTP_CONNTRACK_SHUTDOWN_RECD];\r\npn->ctl_table[6].data = &sn->timeouts[SCTP_CONNTRACK_SHUTDOWN_ACK_SENT];\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int sctp_kmemdup_compat_sysctl_table(struct nf_proto_net *pn,\r\nstruct sctp_net *sn)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\n#ifdef CONFIG_NF_CONNTRACK_PROC_COMPAT\r\npn->ctl_compat_table = kmemdup(sctp_compat_sysctl_table,\r\nsizeof(sctp_compat_sysctl_table),\r\nGFP_KERNEL);\r\nif (!pn->ctl_compat_table)\r\nreturn -ENOMEM;\r\npn->ctl_compat_table[0].data = &sn->timeouts[SCTP_CONNTRACK_CLOSED];\r\npn->ctl_compat_table[1].data = &sn->timeouts[SCTP_CONNTRACK_COOKIE_WAIT];\r\npn->ctl_compat_table[2].data = &sn->timeouts[SCTP_CONNTRACK_COOKIE_ECHOED];\r\npn->ctl_compat_table[3].data = &sn->timeouts[SCTP_CONNTRACK_ESTABLISHED];\r\npn->ctl_compat_table[4].data = &sn->timeouts[SCTP_CONNTRACK_SHUTDOWN_SENT];\r\npn->ctl_compat_table[5].data = &sn->timeouts[SCTP_CONNTRACK_SHUTDOWN_RECD];\r\npn->ctl_compat_table[6].data = &sn->timeouts[SCTP_CONNTRACK_SHUTDOWN_ACK_SENT];\r\n#endif\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int sctp_init_net(struct net *net, u_int16_t proto)\r\n{\r\nint ret;\r\nstruct sctp_net *sn = sctp_pernet(net);\r\nstruct nf_proto_net *pn = &sn->pn;\r\nif (!pn->users) {\r\nint i;\r\nfor (i = 0; i < SCTP_CONNTRACK_MAX; i++)\r\nsn->timeouts[i] = sctp_timeouts[i];\r\n}\r\nif (proto == AF_INET) {\r\nret = sctp_kmemdup_compat_sysctl_table(pn, sn);\r\nif (ret < 0)\r\nreturn ret;\r\nret = sctp_kmemdup_sysctl_table(pn, sn);\r\nif (ret < 0)\r\nnf_ct_kfree_compat_sysctl_table(pn);\r\n} else\r\nret = sctp_kmemdup_sysctl_table(pn, sn);\r\nreturn ret;\r\n}\r\nstatic int sctp_net_init(struct net *net)\r\n{\r\nint ret = 0;\r\nret = nf_ct_l4proto_pernet_register(net, &nf_conntrack_l4proto_sctp4);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_sctp4: pernet registration failed.\n");\r\ngoto out;\r\n}\r\nret = nf_ct_l4proto_pernet_register(net, &nf_conntrack_l4proto_sctp6);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_sctp6: pernet registration failed.\n");\r\ngoto cleanup_sctp4;\r\n}\r\nreturn 0;\r\ncleanup_sctp4:\r\nnf_ct_l4proto_pernet_unregister(net, &nf_conntrack_l4proto_sctp4);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void sctp_net_exit(struct net *net)\r\n{\r\nnf_ct_l4proto_pernet_unregister(net, &nf_conntrack_l4proto_sctp6);\r\nnf_ct_l4proto_pernet_unregister(net, &nf_conntrack_l4proto_sctp4);\r\n}\r\nstatic int __init nf_conntrack_proto_sctp_init(void)\r\n{\r\nint ret;\r\nret = register_pernet_subsys(&sctp_net_ops);\r\nif (ret < 0)\r\ngoto out_pernet;\r\nret = nf_ct_l4proto_register(&nf_conntrack_l4proto_sctp4);\r\nif (ret < 0)\r\ngoto out_sctp4;\r\nret = nf_ct_l4proto_register(&nf_conntrack_l4proto_sctp6);\r\nif (ret < 0)\r\ngoto out_sctp6;\r\nreturn 0;\r\nout_sctp6:\r\nnf_ct_l4proto_unregister(&nf_conntrack_l4proto_sctp4);\r\nout_sctp4:\r\nunregister_pernet_subsys(&sctp_net_ops);\r\nout_pernet:\r\nreturn ret;\r\n}\r\nstatic void __exit nf_conntrack_proto_sctp_fini(void)\r\n{\r\nnf_ct_l4proto_unregister(&nf_conntrack_l4proto_sctp6);\r\nnf_ct_l4proto_unregister(&nf_conntrack_l4proto_sctp4);\r\nunregister_pernet_subsys(&sctp_net_ops);\r\n}
