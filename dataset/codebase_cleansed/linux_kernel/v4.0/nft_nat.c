static void nft_nat_eval(const struct nft_expr *expr,\r\nstruct nft_data data[NFT_REG_MAX + 1],\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_nat *priv = nft_expr_priv(expr);\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(pkt->skb, &ctinfo);\r\nstruct nf_nat_range range;\r\nmemset(&range, 0, sizeof(range));\r\nif (priv->sreg_addr_min) {\r\nif (priv->family == AF_INET) {\r\nrange.min_addr.ip = (__force __be32)\r\ndata[priv->sreg_addr_min].data[0];\r\nrange.max_addr.ip = (__force __be32)\r\ndata[priv->sreg_addr_max].data[0];\r\n} else {\r\nmemcpy(range.min_addr.ip6,\r\ndata[priv->sreg_addr_min].data,\r\nsizeof(struct nft_data));\r\nmemcpy(range.max_addr.ip6,\r\ndata[priv->sreg_addr_max].data,\r\nsizeof(struct nft_data));\r\n}\r\nrange.flags |= NF_NAT_RANGE_MAP_IPS;\r\n}\r\nif (priv->sreg_proto_min) {\r\nrange.min_proto.all =\r\n*(__be16 *)&data[priv->sreg_proto_min].data[0];\r\nrange.max_proto.all =\r\n*(__be16 *)&data[priv->sreg_proto_max].data[0];\r\nrange.flags |= NF_NAT_RANGE_PROTO_SPECIFIED;\r\n}\r\nrange.flags |= priv->flags;\r\ndata[NFT_REG_VERDICT].verdict =\r\nnf_nat_setup_info(ct, &range, priv->type);\r\n}\r\nstatic int nft_nat_validate(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nft_data **data)\r\n{\r\nstruct nft_nat *priv = nft_expr_priv(expr);\r\nint err;\r\nerr = nft_chain_validate_dependency(ctx->chain, NFT_CHAIN_T_NAT);\r\nif (err < 0)\r\nreturn err;\r\nswitch (priv->type) {\r\ncase NFT_NAT_SNAT:\r\nerr = nft_chain_validate_hooks(ctx->chain,\r\n(1 << NF_INET_POST_ROUTING) |\r\n(1 << NF_INET_LOCAL_IN));\r\nbreak;\r\ncase NFT_NAT_DNAT:\r\nerr = nft_chain_validate_hooks(ctx->chain,\r\n(1 << NF_INET_PRE_ROUTING) |\r\n(1 << NF_INET_LOCAL_OUT));\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int nft_nat_init(const struct nft_ctx *ctx, const struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_nat *priv = nft_expr_priv(expr);\r\nu32 family;\r\nint err;\r\nif (tb[NFTA_NAT_TYPE] == NULL ||\r\n(tb[NFTA_NAT_REG_ADDR_MIN] == NULL &&\r\ntb[NFTA_NAT_REG_PROTO_MIN] == NULL))\r\nreturn -EINVAL;\r\nswitch (ntohl(nla_get_be32(tb[NFTA_NAT_TYPE]))) {\r\ncase NFT_NAT_SNAT:\r\npriv->type = NF_NAT_MANIP_SRC;\r\nbreak;\r\ncase NFT_NAT_DNAT:\r\npriv->type = NF_NAT_MANIP_DST;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerr = nft_nat_validate(ctx, expr, NULL);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[NFTA_NAT_FAMILY] == NULL)\r\nreturn -EINVAL;\r\nfamily = ntohl(nla_get_be32(tb[NFTA_NAT_FAMILY]));\r\nif (family != AF_INET && family != AF_INET6)\r\nreturn -EAFNOSUPPORT;\r\nif (family != ctx->afi->family)\r\nreturn -EOPNOTSUPP;\r\npriv->family = family;\r\nif (tb[NFTA_NAT_REG_ADDR_MIN]) {\r\npriv->sreg_addr_min =\r\nntohl(nla_get_be32(tb[NFTA_NAT_REG_ADDR_MIN]));\r\nerr = nft_validate_input_register(priv->sreg_addr_min);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[NFTA_NAT_REG_ADDR_MAX]) {\r\npriv->sreg_addr_max =\r\nntohl(nla_get_be32(tb[NFTA_NAT_REG_ADDR_MAX]));\r\nerr = nft_validate_input_register(priv->sreg_addr_max);\r\nif (err < 0)\r\nreturn err;\r\n} else {\r\npriv->sreg_addr_max = priv->sreg_addr_min;\r\n}\r\n}\r\nif (tb[NFTA_NAT_REG_PROTO_MIN]) {\r\npriv->sreg_proto_min =\r\nntohl(nla_get_be32(tb[NFTA_NAT_REG_PROTO_MIN]));\r\nerr = nft_validate_input_register(priv->sreg_proto_min);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[NFTA_NAT_REG_PROTO_MAX]) {\r\npriv->sreg_proto_max =\r\nntohl(nla_get_be32(tb[NFTA_NAT_REG_PROTO_MAX]));\r\nerr = nft_validate_input_register(priv->sreg_proto_max);\r\nif (err < 0)\r\nreturn err;\r\n} else {\r\npriv->sreg_proto_max = priv->sreg_proto_min;\r\n}\r\n}\r\nif (tb[NFTA_NAT_FLAGS]) {\r\npriv->flags = ntohl(nla_get_be32(tb[NFTA_NAT_FLAGS]));\r\nif (priv->flags & ~NF_NAT_RANGE_MASK)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nft_nat_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_nat *priv = nft_expr_priv(expr);\r\nswitch (priv->type) {\r\ncase NF_NAT_MANIP_SRC:\r\nif (nla_put_be32(skb, NFTA_NAT_TYPE, htonl(NFT_NAT_SNAT)))\r\ngoto nla_put_failure;\r\nbreak;\r\ncase NF_NAT_MANIP_DST:\r\nif (nla_put_be32(skb, NFTA_NAT_TYPE, htonl(NFT_NAT_DNAT)))\r\ngoto nla_put_failure;\r\nbreak;\r\n}\r\nif (nla_put_be32(skb, NFTA_NAT_FAMILY, htonl(priv->family)))\r\ngoto nla_put_failure;\r\nif (priv->sreg_addr_min) {\r\nif (nla_put_be32(skb, NFTA_NAT_REG_ADDR_MIN,\r\nhtonl(priv->sreg_addr_min)) ||\r\nnla_put_be32(skb, NFTA_NAT_REG_ADDR_MAX,\r\nhtonl(priv->sreg_addr_max)))\r\ngoto nla_put_failure;\r\n}\r\nif (priv->sreg_proto_min) {\r\nif (nla_put_be32(skb, NFTA_NAT_REG_PROTO_MIN,\r\nhtonl(priv->sreg_proto_min)) ||\r\nnla_put_be32(skb, NFTA_NAT_REG_PROTO_MAX,\r\nhtonl(priv->sreg_proto_max)))\r\ngoto nla_put_failure;\r\n}\r\nif (priv->flags != 0) {\r\nif (nla_put_be32(skb, NFTA_NAT_FLAGS, htonl(priv->flags)))\r\ngoto nla_put_failure;\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int __init nft_nat_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_nat_type);\r\n}\r\nstatic void __exit nft_nat_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_nat_type);\r\n}
