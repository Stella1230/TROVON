static int t7l66xb_mmc_enable(struct platform_device *mmc)\r\n{\r\nstruct platform_device *dev = to_platform_device(mmc->dev.parent);\r\nstruct t7l66xb *t7l66xb = platform_get_drvdata(dev);\r\nunsigned long flags;\r\nu8 dev_ctl;\r\nclk_prepare_enable(t7l66xb->clk32k);\r\nspin_lock_irqsave(&t7l66xb->lock, flags);\r\ndev_ctl = tmio_ioread8(t7l66xb->scr + SCR_DEV_CTL);\r\ndev_ctl |= SCR_DEV_CTL_MMC;\r\ntmio_iowrite8(dev_ctl, t7l66xb->scr + SCR_DEV_CTL);\r\nspin_unlock_irqrestore(&t7l66xb->lock, flags);\r\ntmio_core_mmc_enable(t7l66xb->scr + 0x200, 0,\r\nt7l66xb_mmc_resources[0].start & 0xfffe);\r\nreturn 0;\r\n}\r\nstatic int t7l66xb_mmc_disable(struct platform_device *mmc)\r\n{\r\nstruct platform_device *dev = to_platform_device(mmc->dev.parent);\r\nstruct t7l66xb *t7l66xb = platform_get_drvdata(dev);\r\nunsigned long flags;\r\nu8 dev_ctl;\r\nspin_lock_irqsave(&t7l66xb->lock, flags);\r\ndev_ctl = tmio_ioread8(t7l66xb->scr + SCR_DEV_CTL);\r\ndev_ctl &= ~SCR_DEV_CTL_MMC;\r\ntmio_iowrite8(dev_ctl, t7l66xb->scr + SCR_DEV_CTL);\r\nspin_unlock_irqrestore(&t7l66xb->lock, flags);\r\nclk_disable_unprepare(t7l66xb->clk32k);\r\nreturn 0;\r\n}\r\nstatic void t7l66xb_mmc_pwr(struct platform_device *mmc, int state)\r\n{\r\nstruct platform_device *dev = to_platform_device(mmc->dev.parent);\r\nstruct t7l66xb *t7l66xb = platform_get_drvdata(dev);\r\ntmio_core_mmc_pwr(t7l66xb->scr + 0x200, 0, state);\r\n}\r\nstatic void t7l66xb_mmc_clk_div(struct platform_device *mmc, int state)\r\n{\r\nstruct platform_device *dev = to_platform_device(mmc->dev.parent);\r\nstruct t7l66xb *t7l66xb = platform_get_drvdata(dev);\r\ntmio_core_mmc_clk_div(t7l66xb->scr + 0x200, 0, state);\r\n}\r\nstatic void t7l66xb_irq(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct t7l66xb *t7l66xb = irq_get_handler_data(irq);\r\nunsigned int isr;\r\nunsigned int i, irq_base;\r\nirq_base = t7l66xb->irq_base;\r\nwhile ((isr = tmio_ioread8(t7l66xb->scr + SCR_ISR) &\r\n~tmio_ioread8(t7l66xb->scr + SCR_IMR)))\r\nfor (i = 0; i < T7L66XB_NR_IRQS; i++)\r\nif (isr & (1 << i))\r\ngeneric_handle_irq(irq_base + i);\r\n}\r\nstatic void t7l66xb_irq_mask(struct irq_data *data)\r\n{\r\nstruct t7l66xb *t7l66xb = irq_data_get_irq_chip_data(data);\r\nunsigned long flags;\r\nu8 imr;\r\nspin_lock_irqsave(&t7l66xb->lock, flags);\r\nimr = tmio_ioread8(t7l66xb->scr + SCR_IMR);\r\nimr |= 1 << (data->irq - t7l66xb->irq_base);\r\ntmio_iowrite8(imr, t7l66xb->scr + SCR_IMR);\r\nspin_unlock_irqrestore(&t7l66xb->lock, flags);\r\n}\r\nstatic void t7l66xb_irq_unmask(struct irq_data *data)\r\n{\r\nstruct t7l66xb *t7l66xb = irq_data_get_irq_chip_data(data);\r\nunsigned long flags;\r\nu8 imr;\r\nspin_lock_irqsave(&t7l66xb->lock, flags);\r\nimr = tmio_ioread8(t7l66xb->scr + SCR_IMR);\r\nimr &= ~(1 << (data->irq - t7l66xb->irq_base));\r\ntmio_iowrite8(imr, t7l66xb->scr + SCR_IMR);\r\nspin_unlock_irqrestore(&t7l66xb->lock, flags);\r\n}\r\nstatic void t7l66xb_attach_irq(struct platform_device *dev)\r\n{\r\nstruct t7l66xb *t7l66xb = platform_get_drvdata(dev);\r\nunsigned int irq, irq_base;\r\nirq_base = t7l66xb->irq_base;\r\nfor (irq = irq_base; irq < irq_base + T7L66XB_NR_IRQS; irq++) {\r\nirq_set_chip_and_handler(irq, &t7l66xb_chip, handle_level_irq);\r\nirq_set_chip_data(irq, t7l66xb);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(irq, IRQF_VALID | IRQF_PROBE);\r\n#endif\r\n}\r\nirq_set_irq_type(t7l66xb->irq, IRQ_TYPE_EDGE_FALLING);\r\nirq_set_handler_data(t7l66xb->irq, t7l66xb);\r\nirq_set_chained_handler(t7l66xb->irq, t7l66xb_irq);\r\n}\r\nstatic void t7l66xb_detach_irq(struct platform_device *dev)\r\n{\r\nstruct t7l66xb *t7l66xb = platform_get_drvdata(dev);\r\nunsigned int irq, irq_base;\r\nirq_base = t7l66xb->irq_base;\r\nirq_set_chained_handler(t7l66xb->irq, NULL);\r\nirq_set_handler_data(t7l66xb->irq, NULL);\r\nfor (irq = irq_base; irq < irq_base + T7L66XB_NR_IRQS; irq++) {\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(irq, 0);\r\n#endif\r\nirq_set_chip(irq, NULL);\r\nirq_set_chip_data(irq, NULL);\r\n}\r\n}\r\nstatic int t7l66xb_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct t7l66xb *t7l66xb = platform_get_drvdata(dev);\r\nstruct t7l66xb_platform_data *pdata = dev_get_platdata(&dev->dev);\r\nif (pdata && pdata->suspend)\r\npdata->suspend(dev);\r\nclk_disable_unprepare(t7l66xb->clk48m);\r\nreturn 0;\r\n}\r\nstatic int t7l66xb_resume(struct platform_device *dev)\r\n{\r\nstruct t7l66xb *t7l66xb = platform_get_drvdata(dev);\r\nstruct t7l66xb_platform_data *pdata = dev_get_platdata(&dev->dev);\r\nclk_prepare_enable(t7l66xb->clk48m);\r\nif (pdata && pdata->resume)\r\npdata->resume(dev);\r\ntmio_core_mmc_enable(t7l66xb->scr + 0x200, 0,\r\nt7l66xb_mmc_resources[0].start & 0xfffe);\r\nreturn 0;\r\n}\r\nstatic int t7l66xb_probe(struct platform_device *dev)\r\n{\r\nstruct t7l66xb_platform_data *pdata = dev_get_platdata(&dev->dev);\r\nstruct t7l66xb *t7l66xb;\r\nstruct resource *iomem, *rscr;\r\nint ret;\r\nif (pdata == NULL)\r\nreturn -EINVAL;\r\niomem = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (!iomem)\r\nreturn -EINVAL;\r\nt7l66xb = kzalloc(sizeof *t7l66xb, GFP_KERNEL);\r\nif (!t7l66xb)\r\nreturn -ENOMEM;\r\nspin_lock_init(&t7l66xb->lock);\r\nplatform_set_drvdata(dev, t7l66xb);\r\nret = platform_get_irq(dev, 0);\r\nif (ret >= 0)\r\nt7l66xb->irq = ret;\r\nelse\r\ngoto err_noirq;\r\nt7l66xb->irq_base = pdata->irq_base;\r\nt7l66xb->clk32k = clk_get(&dev->dev, "CLK_CK32K");\r\nif (IS_ERR(t7l66xb->clk32k)) {\r\nret = PTR_ERR(t7l66xb->clk32k);\r\ngoto err_clk32k_get;\r\n}\r\nt7l66xb->clk48m = clk_get(&dev->dev, "CLK_CK48M");\r\nif (IS_ERR(t7l66xb->clk48m)) {\r\nret = PTR_ERR(t7l66xb->clk48m);\r\ngoto err_clk48m_get;\r\n}\r\nrscr = &t7l66xb->rscr;\r\nrscr->name = "t7l66xb-core";\r\nrscr->start = iomem->start;\r\nrscr->end = iomem->start + 0xff;\r\nrscr->flags = IORESOURCE_MEM;\r\nret = request_resource(iomem, rscr);\r\nif (ret)\r\ngoto err_request_scr;\r\nt7l66xb->scr = ioremap(rscr->start, resource_size(rscr));\r\nif (!t7l66xb->scr) {\r\nret = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\nclk_prepare_enable(t7l66xb->clk48m);\r\nif (pdata && pdata->enable)\r\npdata->enable(dev);\r\ntmio_iowrite8(0xbf, t7l66xb->scr + SCR_IMR);\r\nprintk(KERN_INFO "%s rev %d @ 0x%08lx, irq %d\n",\r\ndev->name, tmio_ioread8(t7l66xb->scr + SCR_REVID),\r\n(unsigned long)iomem->start, t7l66xb->irq);\r\nt7l66xb_attach_irq(dev);\r\nt7l66xb_cells[T7L66XB_CELL_NAND].platform_data = pdata->nand_data;\r\nt7l66xb_cells[T7L66XB_CELL_NAND].pdata_size = sizeof(*pdata->nand_data);\r\nret = mfd_add_devices(&dev->dev, dev->id,\r\nt7l66xb_cells, ARRAY_SIZE(t7l66xb_cells),\r\niomem, t7l66xb->irq_base, NULL);\r\nif (!ret)\r\nreturn 0;\r\nt7l66xb_detach_irq(dev);\r\niounmap(t7l66xb->scr);\r\nerr_ioremap:\r\nrelease_resource(&t7l66xb->rscr);\r\nerr_request_scr:\r\nclk_put(t7l66xb->clk48m);\r\nerr_clk48m_get:\r\nclk_put(t7l66xb->clk32k);\r\nerr_clk32k_get:\r\nerr_noirq:\r\nkfree(t7l66xb);\r\nreturn ret;\r\n}\r\nstatic int t7l66xb_remove(struct platform_device *dev)\r\n{\r\nstruct t7l66xb_platform_data *pdata = dev_get_platdata(&dev->dev);\r\nstruct t7l66xb *t7l66xb = platform_get_drvdata(dev);\r\nint ret;\r\nret = pdata->disable(dev);\r\nclk_disable_unprepare(t7l66xb->clk48m);\r\nclk_put(t7l66xb->clk48m);\r\nclk_disable_unprepare(t7l66xb->clk32k);\r\nclk_put(t7l66xb->clk32k);\r\nt7l66xb_detach_irq(dev);\r\niounmap(t7l66xb->scr);\r\nrelease_resource(&t7l66xb->rscr);\r\nmfd_remove_devices(&dev->dev);\r\nkfree(t7l66xb);\r\nreturn ret;\r\n}
