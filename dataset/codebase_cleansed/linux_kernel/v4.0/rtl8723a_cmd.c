static u8 _is_fw_read_cmd_down(struct rtw_adapter *padapter, u8 msgbox_num)\r\n{\r\nu8 read_down = false;\r\nint retry_cnts = 100;\r\nu8 valid;\r\ndo {\r\nvalid = rtl8723au_read8(padapter, REG_HMETFR) & BIT(msgbox_num);\r\nif (0 == valid)\r\nread_down = true;\r\n} while ((!read_down) && (retry_cnts--));\r\nreturn read_down;\r\n}\r\nint FillH2CCmd(struct rtw_adapter *padapter, u8 ElementID, u32 CmdLen,\r\nu8 *pCmdBuffer)\r\n{\r\nu8 bcmd_down = false;\r\ns32 retry_cnts = 100;\r\nu8 h2c_box_num;\r\nu32 msgbox_addr;\r\nu32 msgbox_ex_addr;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu32 h2c_cmd = 0;\r\nu16 h2c_cmd_ex = 0;\r\nint ret = _FAIL;\r\npadapter = GET_PRIMARY_ADAPTER(padapter);\r\npHalData = GET_HAL_DATA(padapter);\r\nmutex_lock(&adapter_to_dvobj(padapter)->h2c_fwcmd_mutex);\r\nif (!pCmdBuffer)\r\ngoto exit;\r\nif (CmdLen > RTL92C_MAX_CMD_LEN)\r\ngoto exit;\r\nif (padapter->bSurpriseRemoved == true)\r\ngoto exit;\r\ndo {\r\nh2c_box_num = pHalData->LastHMEBoxNum;\r\nif (!_is_fw_read_cmd_down(padapter, h2c_box_num)) {\r\nDBG_8723A(" fw read cmd failed...\n");\r\ngoto exit;\r\n}\r\nif (CmdLen <= 3) {\r\nmemcpy((u8 *)(&h2c_cmd)+1, pCmdBuffer, CmdLen);\r\n} else {\r\nmemcpy((u8 *)(&h2c_cmd_ex), pCmdBuffer, EX_MESSAGE_BOX_SIZE);\r\nmemcpy((u8 *)(&h2c_cmd)+1, pCmdBuffer+2, (CmdLen-EX_MESSAGE_BOX_SIZE));\r\n*(u8 *)(&h2c_cmd) |= BIT(7);\r\n}\r\n*(u8 *)(&h2c_cmd) |= ElementID;\r\nif (h2c_cmd & BIT(7)) {\r\nmsgbox_ex_addr = REG_HMEBOX_EXT_0 + (h2c_box_num * EX_MESSAGE_BOX_SIZE);\r\nh2c_cmd_ex = le16_to_cpu(h2c_cmd_ex);\r\nrtl8723au_write16(padapter, msgbox_ex_addr, h2c_cmd_ex);\r\n}\r\nmsgbox_addr = REG_HMEBOX_0 + (h2c_box_num * MESSAGE_BOX_SIZE);\r\nh2c_cmd = le32_to_cpu(h2c_cmd);\r\nrtl8723au_write32(padapter, msgbox_addr, h2c_cmd);\r\nbcmd_down = true;\r\npHalData->LastHMEBoxNum = (h2c_box_num+1) % RTL92C_MAX_H2C_BOX_NUMS;\r\n} while ((!bcmd_down) && (retry_cnts--));\r\nret = _SUCCESS;\r\nexit:\r\nmutex_unlock(&adapter_to_dvobj(padapter)->h2c_fwcmd_mutex);\r\nreturn ret;\r\n}\r\nint rtl8723a_set_rssi_cmd(struct rtw_adapter *padapter, u8 *param)\r\n{\r\n*((u32 *)param) = cpu_to_le32(*((u32 *)param));\r\nFillH2CCmd(padapter, RSSI_SETTING_EID, 3, param);\r\nreturn _SUCCESS;\r\n}\r\nint rtl8723a_set_raid_cmd(struct rtw_adapter *padapter, u32 mask, u8 arg)\r\n{\r\nu8 buf[5];\r\nmemset(buf, 0, 5);\r\nmask = cpu_to_le32(mask);\r\nmemcpy(buf, &mask, 4);\r\nbuf[4] = arg;\r\nFillH2CCmd(padapter, MACID_CONFIG_EID, 5, buf);\r\nreturn _SUCCESS;\r\n}\r\nvoid rtl8723a_add_rateatid(struct rtw_adapter *pAdapter, u32 bitmap, u8 arg, u8 rssi_level)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(pAdapter);\r\nu8 macid = arg&0x1f;\r\nu8 raid = (bitmap>>28) & 0x0f;\r\nbitmap &= 0x0fffffff;\r\nif (rssi_level != DM_RATR_STA_INIT)\r\nbitmap = ODM_Get_Rate_Bitmap23a(pHalData, macid, bitmap,\r\nrssi_level);\r\nbitmap |= ((raid<<28)&0xf0000000);\r\nif (pHalData->fw_ractrl == true) {\r\nrtl8723a_set_raid_cmd(pAdapter, bitmap, arg);\r\n} else {\r\nu8 init_rate, shortGIrate = false;\r\ninit_rate = get_highest_rate_idx23a(bitmap&0x0fffffff)&0x3f;\r\nshortGIrate = (arg&BIT(5)) ? true:false;\r\nif (shortGIrate == true)\r\ninit_rate |= BIT(6);\r\nrtl8723au_write8(pAdapter, REG_INIDATA_RATE_SEL + macid,\r\ninit_rate);\r\n}\r\n}\r\nvoid rtl8723a_set_FwPwrMode_cmd(struct rtw_adapter *padapter, u8 Mode)\r\n{\r\nstruct setpwrmode_parm H2CSetPwrMode;\r\nstruct pwrctrl_priv *pwrpriv = &padapter->pwrctrlpriv;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nDBG_8723A("%s: Mode =%d SmartPS =%d UAPSD =%d BcnMode = 0x%02x\n", __func__,\r\nMode, pwrpriv->smart_ps, padapter->registrypriv.uapsd_enable, pwrpriv->bcn_ant_mode);\r\nif ((Mode != PS_MODE_ACTIVE) &&\r\n(!IS_92C_SERIAL(pHalData->VersionID))) {\r\nODM_RF_Saving23a(&pHalData->odmpriv, true);\r\n}\r\nH2CSetPwrMode.Mode = Mode;\r\nH2CSetPwrMode.SmartPS = pwrpriv->smart_ps;\r\nH2CSetPwrMode.AwakeInterval = 1;\r\nH2CSetPwrMode.bAllQueueUAPSD = padapter->registrypriv.uapsd_enable;\r\nH2CSetPwrMode.BcnAntMode = pwrpriv->bcn_ant_mode;\r\nFillH2CCmd(padapter, SET_PWRMODE_EID, sizeof(H2CSetPwrMode), (u8 *)&H2CSetPwrMode);\r\n}\r\nstatic void\r\nConstructBeacon(struct rtw_adapter *padapter, u8 *pframe, u32 *pLength)\r\n{\r\nstruct ieee80211_mgmt *mgmt;\r\nu32 rate_len, pktlen;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nstruct wlan_bssid_ex *cur_network = &pmlmeinfo->network;\r\nu8 bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nmgmt = (struct ieee80211_mgmt *)pframe;\r\nmgmt->frame_control =\r\ncpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_BEACON);\r\nether_addr_copy(mgmt->da, bc_addr);\r\nether_addr_copy(mgmt->sa, myid(&padapter->eeprompriv));\r\nether_addr_copy(mgmt->bssid, get_my_bssid23a(cur_network));\r\nmgmt->seq_ctrl = 0;\r\nput_unaligned_le16(cur_network->beacon_interval,\r\n&mgmt->u.beacon.beacon_int);\r\nput_unaligned_le16(cur_network->capability,\r\n&mgmt->u.beacon.capab_info);\r\npframe = mgmt->u.beacon.variable;\r\npktlen = offsetof(struct ieee80211_mgmt, u.beacon.variable);\r\nif ((pmlmeinfo->state&0x03) == MSR_AP) {\r\npktlen += cur_network->IELength;\r\nmemcpy(pframe, cur_network->IEs, pktlen);\r\ngoto _ConstructBeacon;\r\n}\r\npframe = rtw_set_ie23a(pframe, WLAN_EID_SSID,\r\ncur_network->Ssid.ssid_len,\r\ncur_network->Ssid.ssid, &pktlen);\r\nrate_len = rtw_get_rateset_len23a(cur_network->SupportedRates);\r\npframe = rtw_set_ie23a(pframe, WLAN_EID_SUPP_RATES, ((rate_len > 8) ?\r\n8 : rate_len), cur_network->SupportedRates, &pktlen);\r\npframe = rtw_set_ie23a(pframe, WLAN_EID_DS_PARAMS, 1, (unsigned char *)\r\n&cur_network->DSConfig, &pktlen);\r\nif ((pmlmeinfo->state&0x03) == MSR_ADHOC) {\r\nu32 ATIMWindow;\r\nATIMWindow = 0;\r\npframe = rtw_set_ie23a(pframe, WLAN_EID_IBSS_PARAMS, 2,\r\n(unsigned char *)&ATIMWindow, &pktlen);\r\n}\r\nif (rate_len > 8)\r\npframe = rtw_set_ie23a(pframe, WLAN_EID_EXT_SUPP_RATES,\r\n(rate_len - 8),\r\n(cur_network->SupportedRates + 8),\r\n&pktlen);\r\n_ConstructBeacon:\r\nif ((pktlen + TXDESC_SIZE) > 512) {\r\nDBG_8723A("beacon frame too large\n");\r\nreturn;\r\n}\r\n*pLength = pktlen;\r\n}\r\nstatic void ConstructPSPoll(struct rtw_adapter *padapter,\r\nu8 *pframe, u32 *pLength)\r\n{\r\nstruct ieee80211_hdr *pwlanhdr;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\npwlanhdr = (struct ieee80211_hdr *)pframe;\r\npwlanhdr->frame_control =\r\ncpu_to_le16(IEEE80211_FTYPE_CTL | IEEE80211_STYPE_PSPOLL);\r\npwlanhdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\r\npwlanhdr->duration_id = cpu_to_le16(pmlmeinfo->aid | 0xc000);\r\nmemcpy(pwlanhdr->addr1, get_my_bssid23a(&pmlmeinfo->network), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&padapter->eeprompriv), ETH_ALEN);\r\n*pLength = 16;\r\n}\r\nstatic void\r\nConstructNullFunctionData(struct rtw_adapter *padapter, u8 *pframe,\r\nu32 *pLength, u8 *StaAddr, u8 bQoS, u8 AC,\r\nu8 bEosp, u8 bForcePowerSave)\r\n{\r\nstruct ieee80211_hdr *pwlanhdr;\r\nu32 pktlen;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_network *cur_network = &pmlmepriv->cur_network;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\npwlanhdr = (struct ieee80211_hdr *)pframe;\r\npwlanhdr->frame_control = 0;\r\npwlanhdr->seq_ctrl = 0;\r\nif (bForcePowerSave)\r\npwlanhdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\r\nswitch (cur_network->network.ifmode) {\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\ncase NL80211_IFTYPE_STATION:\r\npwlanhdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_TODS);\r\nmemcpy(pwlanhdr->addr1,\r\nget_my_bssid23a(&pmlmeinfo->network), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&padapter->eeprompriv),\r\nETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, StaAddr, ETH_ALEN);\r\nbreak;\r\ncase NL80211_IFTYPE_P2P_GO:\r\ncase NL80211_IFTYPE_AP:\r\npwlanhdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_FROMDS);\r\nmemcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2,\r\nget_my_bssid23a(&pmlmeinfo->network), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3, myid(&padapter->eeprompriv),\r\nETH_ALEN);\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\ndefault:\r\nmemcpy(pwlanhdr->addr1, StaAddr, ETH_ALEN);\r\nmemcpy(pwlanhdr->addr2, myid(&padapter->eeprompriv), ETH_ALEN);\r\nmemcpy(pwlanhdr->addr3,\r\nget_my_bssid23a(&pmlmeinfo->network), ETH_ALEN);\r\nbreak;\r\n}\r\nif (bQoS == true) {\r\nstruct ieee80211_qos_hdr *qoshdr;\r\nqoshdr = (struct ieee80211_qos_hdr *)pframe;\r\nqoshdr->frame_control |=\r\ncpu_to_le16(IEEE80211_FTYPE_DATA |\r\nIEEE80211_STYPE_QOS_NULLFUNC);\r\nqoshdr->qos_ctrl = cpu_to_le16(AC & IEEE80211_QOS_CTL_TID_MASK);\r\nif (bEosp)\r\nqoshdr->qos_ctrl |= cpu_to_le16(IEEE80211_QOS_CTL_EOSP);\r\npktlen = sizeof(struct ieee80211_qos_hdr);\r\n} else {\r\npwlanhdr->frame_control |=\r\ncpu_to_le16(IEEE80211_FTYPE_DATA |\r\nIEEE80211_STYPE_NULLFUNC);\r\npktlen = sizeof(struct ieee80211_hdr_3addr);\r\n}\r\n*pLength = pktlen;\r\n}\r\nstatic void ConstructProbeRsp(struct rtw_adapter *padapter, u8 *pframe,\r\nu32 *pLength, u8 *StaAddr, bool bHideSSID)\r\n{\r\nstruct ieee80211_mgmt *mgmt;\r\nu8 *mac, *bssid;\r\nu32 pktlen;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nstruct wlan_bssid_ex *cur_network = &pmlmeinfo->network;\r\nmgmt = (struct ieee80211_mgmt *)pframe;\r\nmac = myid(&padapter->eeprompriv);\r\nbssid = cur_network->MacAddress;\r\nmgmt->frame_control =\r\ncpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_PROBE_RESP);\r\nmgmt->seq_ctrl = 0;\r\nmemcpy(mgmt->da, StaAddr, ETH_ALEN);\r\nmemcpy(mgmt->sa, mac, ETH_ALEN);\r\nmemcpy(mgmt->bssid, bssid, ETH_ALEN);\r\nput_unaligned_le64(cur_network->tsf,\r\n&mgmt->u.probe_resp.timestamp);\r\nput_unaligned_le16(cur_network->beacon_interval,\r\n&mgmt->u.probe_resp.beacon_int);\r\nput_unaligned_le16(cur_network->capability,\r\n&mgmt->u.probe_resp.capab_info);\r\npktlen = offsetof(struct ieee80211_mgmt, u.probe_resp.variable);\r\nif (cur_network->IELength > MAX_IE_SZ)\r\nreturn;\r\nmemcpy(mgmt->u.probe_resp.variable, cur_network->IEs,\r\ncur_network->IELength);\r\npktlen += (cur_network->IELength);\r\n*pLength = pktlen;\r\n}\r\nstatic void SetFwRsvdPagePkt(struct rtw_adapter *padapter, bool bDLFinished)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct xmit_frame *pmgntframe;\r\nstruct pkt_attrib *pattrib;\r\nstruct xmit_priv *pxmitpriv;\r\nstruct mlme_ext_priv *pmlmeext;\r\nstruct mlme_ext_info *pmlmeinfo;\r\nu32 BeaconLength = 0, ProbeRspLength = 0, PSPollLength;\r\nu32 NullDataLength, QosNullLength, BTQosNullLength;\r\nu8 *ReservedPagePacket;\r\nu8 PageNum, PageNeed, TxDescLen;\r\nu16 BufIndex;\r\nu32 TotalPacketLen;\r\nstruct rsvdpage_loc RsvdPageLoc;\r\nDBG_8723A("%s\n", __func__);\r\nReservedPagePacket = kzalloc(1000, GFP_KERNEL);\r\nif (ReservedPagePacket == NULL) {\r\nDBG_8723A("%s: alloc ReservedPagePacket fail!\n", __func__);\r\nreturn;\r\n}\r\npHalData = GET_HAL_DATA(padapter);\r\npxmitpriv = &padapter->xmitpriv;\r\npmlmeext = &padapter->mlmeextpriv;\r\npmlmeinfo = &pmlmeext->mlmext_info;\r\nTxDescLen = TXDESC_SIZE;\r\nPageNum = 0;\r\nBufIndex = TXDESC_OFFSET;\r\nConstructBeacon(padapter, &ReservedPagePacket[BufIndex], &BeaconLength);\r\nPageNeed = (u8)PageNum_128(TxDescLen + BeaconLength);\r\nif (PageNeed == 1)\r\nPageNeed += 1;\r\nPageNum += PageNeed;\r\npHalData->FwRsvdPageStartOffset = PageNum;\r\nBufIndex += PageNeed*128;\r\nRsvdPageLoc.LocPsPoll = PageNum;\r\nConstructPSPoll(padapter, &ReservedPagePacket[BufIndex], &PSPollLength);\r\nrtl8723a_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], PSPollLength, true, false);\r\nPageNeed = (u8)PageNum_128(TxDescLen + PSPollLength);\r\nPageNum += PageNeed;\r\nBufIndex += PageNeed*128;\r\nRsvdPageLoc.LocNullData = PageNum;\r\nConstructNullFunctionData(padapter, &ReservedPagePacket[BufIndex],\r\n&NullDataLength,\r\nget_my_bssid23a(&pmlmeinfo->network),\r\nfalse, 0, 0, false);\r\nrtl8723a_fill_fake_txdesc(padapter,\r\n&ReservedPagePacket[BufIndex-TxDescLen],\r\nNullDataLength, false, false);\r\nPageNeed = (u8)PageNum_128(TxDescLen + NullDataLength);\r\nPageNum += PageNeed;\r\nBufIndex += PageNeed*128;\r\nRsvdPageLoc.LocProbeRsp = PageNum;\r\nConstructProbeRsp(\r\npadapter,\r\n&ReservedPagePacket[BufIndex],\r\n&ProbeRspLength,\r\nget_my_bssid23a(&pmlmeinfo->network),\r\nfalse);\r\nrtl8723a_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], ProbeRspLength, false, false);\r\nPageNeed = (u8)PageNum_128(TxDescLen + ProbeRspLength);\r\nPageNum += PageNeed;\r\nBufIndex += PageNeed*128;\r\nRsvdPageLoc.LocQosNull = PageNum;\r\nConstructNullFunctionData(\r\npadapter,\r\n&ReservedPagePacket[BufIndex],\r\n&QosNullLength,\r\nget_my_bssid23a(&pmlmeinfo->network),\r\ntrue, 0, 0, false);\r\nrtl8723a_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], QosNullLength, false, false);\r\nPageNeed = (u8)PageNum_128(TxDescLen + QosNullLength);\r\nPageNum += PageNeed;\r\nBufIndex += PageNeed*128;\r\nRsvdPageLoc.LocBTQosNull = PageNum;\r\nConstructNullFunctionData(\r\npadapter,\r\n&ReservedPagePacket[BufIndex],\r\n&BTQosNullLength,\r\nget_my_bssid23a(&pmlmeinfo->network),\r\ntrue, 0, 0, false);\r\nrtl8723a_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], BTQosNullLength, false, true);\r\nTotalPacketLen = BufIndex + BTQosNullLength;\r\npmgntframe = alloc_mgtxmitframe23a(pxmitpriv);\r\nif (pmgntframe == NULL)\r\ngoto exit;\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib23a(padapter, pattrib);\r\npattrib->qsel = 0x10;\r\npattrib->pktlen = pattrib->last_txcmdsz = TotalPacketLen - TXDESC_OFFSET;\r\nmemcpy(pmgntframe->buf_addr, ReservedPagePacket, TotalPacketLen);\r\nrtl8723au_mgnt_xmit(padapter, pmgntframe);\r\nDBG_8723A("%s: Set RSVD page location to Fw\n", __func__);\r\nFillH2CCmd(padapter, RSVD_PAGE_EID, sizeof(RsvdPageLoc), (u8 *)&RsvdPageLoc);\r\nexit:\r\nkfree(ReservedPagePacket);\r\n}\r\nvoid rtl8723a_set_FwJoinBssReport_cmd(struct rtw_adapter *padapter, u8 mstatus)\r\n{\r\nstruct joinbssrpt_parm JoinBssRptParm;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nDBG_8723A("%s mstatus(%x)\n", __func__, mstatus);\r\nif (mstatus == 1) {\r\nbool bRecover = false;\r\nu8 v8;\r\nrtl8723au_write16(padapter, REG_BCN_PSR_RPT,\r\n0xC000|pmlmeinfo->aid);\r\nv8 = rtl8723au_read8(padapter, REG_CR+1);\r\nv8 |= BIT(0);\r\nrtl8723au_write8(padapter, REG_CR+1, v8);\r\nSetBcnCtrlReg23a(padapter, BIT(4), BIT(3));\r\nif (pHalData->RegFwHwTxQCtrl & BIT(6))\r\nbRecover = true;\r\nrtl8723au_write8(padapter, REG_FWHW_TXQ_CTRL + 2,\r\npHalData->RegFwHwTxQCtrl & ~BIT(6));\r\npHalData->RegFwHwTxQCtrl &= ~BIT(6);\r\nSetFwRsvdPagePkt(padapter, 0);\r\nSetBcnCtrlReg23a(padapter, BIT(3), BIT(4));\r\nif (bRecover) {\r\nrtl8723au_write8(padapter, REG_FWHW_TXQ_CTRL + 2,\r\npHalData->RegFwHwTxQCtrl | BIT(6));\r\npHalData->RegFwHwTxQCtrl |= BIT(6);\r\n}\r\nv8 = rtl8723au_read8(padapter, REG_CR+1);\r\nv8 &= ~BIT(0);\r\nrtl8723au_write8(padapter, REG_CR+1, v8);\r\n}\r\nJoinBssRptParm.OpMode = mstatus;\r\nFillH2CCmd(padapter, JOINBSS_RPT_EID, sizeof(JoinBssRptParm), (u8 *)&JoinBssRptParm);\r\n}\r\nstatic void SetFwRsvdPagePkt_BTCoex(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct xmit_frame *pmgntframe;\r\nstruct pkt_attrib *pattrib;\r\nstruct xmit_priv *pxmitpriv;\r\nstruct mlme_ext_priv *pmlmeext;\r\nstruct mlme_ext_info *pmlmeinfo;\r\nu8 fakemac[6] = {0x00, 0xe0, 0x4c, 0x00, 0x00, 0x00};\r\nu32 NullDataLength, BTQosNullLength;\r\nu8 *ReservedPagePacket;\r\nu8 PageNum, PageNeed, TxDescLen;\r\nu16 BufIndex;\r\nu32 TotalPacketLen;\r\nstruct rsvdpage_loc RsvdPageLoc;\r\nDBG_8723A("+%s\n", __func__);\r\nReservedPagePacket = kzalloc(1024, GFP_KERNEL);\r\nif (ReservedPagePacket == NULL) {\r\nDBG_8723A("%s: alloc ReservedPagePacket fail!\n", __func__);\r\nreturn;\r\n}\r\npHalData = GET_HAL_DATA(padapter);\r\npxmitpriv = &padapter->xmitpriv;\r\npmlmeext = &padapter->mlmeextpriv;\r\npmlmeinfo = &pmlmeext->mlmext_info;\r\nTxDescLen = TXDESC_SIZE;\r\nPageNum = 0;\r\nBufIndex = TXDESC_OFFSET;\r\nPageNeed = 3;\r\nPageNum += PageNeed;\r\npHalData->FwRsvdPageStartOffset = PageNum;\r\nBufIndex += PageNeed*128;\r\nRsvdPageLoc.LocNullData = PageNum;\r\nConstructNullFunctionData(\r\npadapter,\r\n&ReservedPagePacket[BufIndex],\r\n&NullDataLength,\r\nfakemac,\r\nfalse, 0, 0, false);\r\nrtl8723a_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], NullDataLength, false, false);\r\nPageNeed = (u8)PageNum_128(TxDescLen + NullDataLength);\r\nPageNum += PageNeed;\r\nBufIndex += PageNeed*128;\r\nRsvdPageLoc.LocBTQosNull = PageNum;\r\nConstructNullFunctionData(\r\npadapter,\r\n&ReservedPagePacket[BufIndex],\r\n&BTQosNullLength,\r\nfakemac,\r\ntrue, 0, 0, false);\r\nrtl8723a_fill_fake_txdesc(padapter, &ReservedPagePacket[BufIndex-TxDescLen], BTQosNullLength, false, true);\r\nTotalPacketLen = BufIndex + BTQosNullLength;\r\npmgntframe = alloc_mgtxmitframe23a(pxmitpriv);\r\nif (pmgntframe == NULL)\r\ngoto exit;\r\npattrib = &pmgntframe->attrib;\r\nupdate_mgntframe_attrib23a(padapter, pattrib);\r\npattrib->qsel = 0x10;\r\npattrib->pktlen = pattrib->last_txcmdsz = TotalPacketLen - TXDESC_OFFSET;\r\nmemcpy(pmgntframe->buf_addr, ReservedPagePacket, TotalPacketLen);\r\nrtl8723au_mgnt_xmit(padapter, pmgntframe);\r\nDBG_8723A("%s: Set RSVD page location to Fw\n", __func__);\r\nFillH2CCmd(padapter, RSVD_PAGE_EID, sizeof(RsvdPageLoc), (u8 *)&RsvdPageLoc);\r\nexit:\r\nkfree(ReservedPagePacket);\r\n}\r\nvoid rtl8723a_set_BTCoex_AP_mode_FwRsvdPkt_cmd(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nu8 bRecover = false;\r\nDBG_8723A("+%s\n", __func__);\r\npHalData = GET_HAL_DATA(padapter);\r\nif (pHalData->RegFwHwTxQCtrl & BIT(6))\r\nbRecover = true;\r\npHalData->RegFwHwTxQCtrl &= ~BIT(6);\r\nrtl8723au_write8(padapter, REG_FWHW_TXQ_CTRL + 2,\r\npHalData->RegFwHwTxQCtrl);\r\nSetFwRsvdPagePkt_BTCoex(padapter);\r\nif (bRecover) {\r\npHalData->RegFwHwTxQCtrl |= BIT(6);\r\nrtl8723au_write8(padapter, REG_FWHW_TXQ_CTRL + 2,\r\npHalData->RegFwHwTxQCtrl);\r\n}\r\n}
