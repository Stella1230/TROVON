struct ssp_device *pxa_ssp_request(int port, const char *label)\r\n{\r\nstruct ssp_device *ssp = NULL;\r\nmutex_lock(&ssp_lock);\r\nlist_for_each_entry(ssp, &ssp_list, node) {\r\nif (ssp->port_id == port && ssp->use_count == 0) {\r\nssp->use_count++;\r\nssp->label = label;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&ssp_lock);\r\nif (&ssp->node == &ssp_list)\r\nreturn NULL;\r\nreturn ssp;\r\n}\r\nstruct ssp_device *pxa_ssp_request_of(const struct device_node *of_node,\r\nconst char *label)\r\n{\r\nstruct ssp_device *ssp = NULL;\r\nmutex_lock(&ssp_lock);\r\nlist_for_each_entry(ssp, &ssp_list, node) {\r\nif (ssp->of_node == of_node && ssp->use_count == 0) {\r\nssp->use_count++;\r\nssp->label = label;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&ssp_lock);\r\nif (&ssp->node == &ssp_list)\r\nreturn NULL;\r\nreturn ssp;\r\n}\r\nvoid pxa_ssp_free(struct ssp_device *ssp)\r\n{\r\nmutex_lock(&ssp_lock);\r\nif (ssp->use_count) {\r\nssp->use_count--;\r\nssp->label = NULL;\r\n} else\r\ndev_err(&ssp->pdev->dev, "device already free\n");\r\nmutex_unlock(&ssp_lock);\r\n}\r\nstatic int pxa_ssp_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct ssp_device *ssp;\r\nstruct device *dev = &pdev->dev;\r\nssp = devm_kzalloc(dev, sizeof(struct ssp_device), GFP_KERNEL);\r\nif (ssp == NULL)\r\nreturn -ENOMEM;\r\nssp->pdev = pdev;\r\nssp->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(ssp->clk))\r\nreturn PTR_ERR(ssp->clk);\r\nif (dev->of_node) {\r\nstruct of_phandle_args dma_spec;\r\nstruct device_node *np = dev->of_node;\r\nint ret;\r\nret = of_parse_phandle_with_args(np, "dmas", "#dma-cells",\r\n0, &dma_spec);\r\nif (ret) {\r\ndev_err(dev, "Can't parse dmas property\n");\r\nreturn -ENODEV;\r\n}\r\nssp->drcmr_rx = dma_spec.args[0];\r\nof_node_put(dma_spec.np);\r\nret = of_parse_phandle_with_args(np, "dmas", "#dma-cells",\r\n1, &dma_spec);\r\nif (ret) {\r\ndev_err(dev, "Can't parse dmas property\n");\r\nreturn -ENODEV;\r\n}\r\nssp->drcmr_tx = dma_spec.args[0];\r\nof_node_put(dma_spec.np);\r\n} else {\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (res == NULL) {\r\ndev_err(dev, "no SSP RX DRCMR defined\n");\r\nreturn -ENODEV;\r\n}\r\nssp->drcmr_rx = res->start;\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (res == NULL) {\r\ndev_err(dev, "no SSP TX DRCMR defined\n");\r\nreturn -ENODEV;\r\n}\r\nssp->drcmr_tx = res->start;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(dev, "no memory resource defined\n");\r\nreturn -ENODEV;\r\n}\r\nres = devm_request_mem_region(dev, res->start, resource_size(res),\r\npdev->name);\r\nif (res == NULL) {\r\ndev_err(dev, "failed to request memory resource\n");\r\nreturn -EBUSY;\r\n}\r\nssp->phys_base = res->start;\r\nssp->mmio_base = devm_ioremap(dev, res->start, resource_size(res));\r\nif (ssp->mmio_base == NULL) {\r\ndev_err(dev, "failed to ioremap() registers\n");\r\nreturn -ENODEV;\r\n}\r\nssp->irq = platform_get_irq(pdev, 0);\r\nif (ssp->irq < 0) {\r\ndev_err(dev, "no IRQ resource defined\n");\r\nreturn -ENODEV;\r\n}\r\nif (dev->of_node) {\r\nconst struct of_device_id *id =\r\nof_match_device(of_match_ptr(pxa_ssp_of_ids), dev);\r\nssp->type = (int) id->data;\r\n} else {\r\nconst struct platform_device_id *id =\r\nplatform_get_device_id(pdev);\r\nssp->type = (int) id->driver_data;\r\nssp->port_id = pdev->id + 1;\r\n}\r\nssp->use_count = 0;\r\nssp->of_node = dev->of_node;\r\nmutex_lock(&ssp_lock);\r\nlist_add(&ssp->node, &ssp_list);\r\nmutex_unlock(&ssp_lock);\r\nplatform_set_drvdata(pdev, ssp);\r\nreturn 0;\r\n}\r\nstatic int pxa_ssp_remove(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct ssp_device *ssp;\r\nssp = platform_get_drvdata(pdev);\r\nif (ssp == NULL)\r\nreturn -ENODEV;\r\niounmap(ssp->mmio_base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nclk_put(ssp->clk);\r\nmutex_lock(&ssp_lock);\r\nlist_del(&ssp->node);\r\nmutex_unlock(&ssp_lock);\r\nkfree(ssp);\r\nreturn 0;\r\n}\r\nstatic int __init pxa_ssp_init(void)\r\n{\r\nreturn platform_driver_register(&pxa_ssp_driver);\r\n}\r\nstatic void __exit pxa_ssp_exit(void)\r\n{\r\nplatform_driver_unregister(&pxa_ssp_driver);\r\n}
