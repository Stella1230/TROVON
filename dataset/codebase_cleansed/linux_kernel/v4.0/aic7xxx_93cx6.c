static void\r\nsend_seeprom_cmd(struct seeprom_descriptor *sd, const struct seeprom_cmd *cmd)\r\n{\r\nuint8_t temp;\r\nint i = 0;\r\ntemp = sd->sd_MS ^ sd->sd_CS;\r\nSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\r\nCLOCK_PULSE(sd, sd->sd_RDY);\r\nfor (i = 0; i < cmd->len; i++) {\r\nif (cmd->bits[i] != 0)\r\ntemp ^= sd->sd_DO;\r\nSEEPROM_OUTB(sd, temp);\r\nCLOCK_PULSE(sd, sd->sd_RDY);\r\nSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\r\nCLOCK_PULSE(sd, sd->sd_RDY);\r\nif (cmd->bits[i] != 0)\r\ntemp ^= sd->sd_DO;\r\n}\r\n}\r\nstatic void\r\nreset_seeprom(struct seeprom_descriptor *sd)\r\n{\r\nuint8_t temp;\r\ntemp = sd->sd_MS;\r\nSEEPROM_OUTB(sd, temp);\r\nCLOCK_PULSE(sd, sd->sd_RDY);\r\nSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\r\nCLOCK_PULSE(sd, sd->sd_RDY);\r\nSEEPROM_OUTB(sd, temp);\r\nCLOCK_PULSE(sd, sd->sd_RDY);\r\n}\r\nint\r\nahc_read_seeprom(struct seeprom_descriptor *sd, uint16_t *buf,\r\nu_int start_addr, u_int count)\r\n{\r\nint i = 0;\r\nu_int k = 0;\r\nuint16_t v;\r\nuint8_t temp;\r\nfor (k = start_addr; k < count + start_addr; k++) {\r\nsend_seeprom_cmd(sd, &seeprom_read);\r\ntemp = sd->sd_MS ^ sd->sd_CS;\r\nfor (i = (sd->sd_chip - 1); i >= 0; i--) {\r\nif ((k & (1 << i)) != 0)\r\ntemp ^= sd->sd_DO;\r\nSEEPROM_OUTB(sd, temp);\r\nCLOCK_PULSE(sd, sd->sd_RDY);\r\nSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\r\nCLOCK_PULSE(sd, sd->sd_RDY);\r\nif ((k & (1 << i)) != 0)\r\ntemp ^= sd->sd_DO;\r\n}\r\nv = 0;\r\nfor (i = 16; i >= 0; i--) {\r\nSEEPROM_OUTB(sd, temp);\r\nCLOCK_PULSE(sd, sd->sd_RDY);\r\nv <<= 1;\r\nif (SEEPROM_DATA_INB(sd) & sd->sd_DI)\r\nv |= 1;\r\nSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\r\nCLOCK_PULSE(sd, sd->sd_RDY);\r\n}\r\nbuf[k - start_addr] = v;\r\nreset_seeprom(sd);\r\n}\r\n#ifdef AHC_DUMP_EEPROM\r\nprintk("\nSerial EEPROM:\n\t");\r\nfor (k = 0; k < count; k = k + 1) {\r\nif (((k % 8) == 0) && (k != 0)) {\r\nprintk(KERN_CONT "\n\t");\r\n}\r\nprintk(KERN_CONT " 0x%x", buf[k]);\r\n}\r\nprintk(KERN_CONT "\n");\r\n#endif\r\nreturn (1);\r\n}\r\nint\r\nahc_write_seeprom(struct seeprom_descriptor *sd, uint16_t *buf,\r\nu_int start_addr, u_int count)\r\n{\r\nconst struct seeprom_cmd *ewen, *ewds;\r\nuint16_t v;\r\nuint8_t temp;\r\nint i, k;\r\nif (sd->sd_chip == C46) {\r\newen = &seeprom_ewen;\r\newds = &seeprom_ewds;\r\n} else if (sd->sd_chip == C56_66) {\r\newen = &seeprom_long_ewen;\r\newds = &seeprom_long_ewds;\r\n} else {\r\nprintk("ahc_write_seeprom: unsupported seeprom type %d\n",\r\nsd->sd_chip);\r\nreturn (0);\r\n}\r\nsend_seeprom_cmd(sd, ewen);\r\nreset_seeprom(sd);\r\ntemp = sd->sd_MS ^ sd->sd_CS;\r\nfor (k = start_addr; k < count + start_addr; k++) {\r\nsend_seeprom_cmd(sd, &seeprom_write);\r\nfor (i = (sd->sd_chip - 1); i >= 0; i--) {\r\nif ((k & (1 << i)) != 0)\r\ntemp ^= sd->sd_DO;\r\nSEEPROM_OUTB(sd, temp);\r\nCLOCK_PULSE(sd, sd->sd_RDY);\r\nSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\r\nCLOCK_PULSE(sd, sd->sd_RDY);\r\nif ((k & (1 << i)) != 0)\r\ntemp ^= sd->sd_DO;\r\n}\r\nv = buf[k - start_addr];\r\nfor (i = 15; i >= 0; i--) {\r\nif ((v & (1 << i)) != 0)\r\ntemp ^= sd->sd_DO;\r\nSEEPROM_OUTB(sd, temp);\r\nCLOCK_PULSE(sd, sd->sd_RDY);\r\nSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\r\nCLOCK_PULSE(sd, sd->sd_RDY);\r\nif ((v & (1 << i)) != 0)\r\ntemp ^= sd->sd_DO;\r\n}\r\ntemp = sd->sd_MS;\r\nSEEPROM_OUTB(sd, temp);\r\nCLOCK_PULSE(sd, sd->sd_RDY);\r\ntemp = sd->sd_MS ^ sd->sd_CS;\r\ndo {\r\nSEEPROM_OUTB(sd, temp);\r\nCLOCK_PULSE(sd, sd->sd_RDY);\r\nSEEPROM_OUTB(sd, temp ^ sd->sd_CK);\r\nCLOCK_PULSE(sd, sd->sd_RDY);\r\n} while ((SEEPROM_DATA_INB(sd) & sd->sd_DI) == 0);\r\nreset_seeprom(sd);\r\n}\r\nsend_seeprom_cmd(sd, ewds);\r\nreset_seeprom(sd);\r\nreturn (1);\r\n}\r\nint\r\nahc_verify_cksum(struct seeprom_config *sc)\r\n{\r\nint i;\r\nint maxaddr;\r\nuint32_t checksum;\r\nuint16_t *scarray;\r\nmaxaddr = (sizeof(*sc)/2) - 1;\r\nchecksum = 0;\r\nscarray = (uint16_t *)sc;\r\nfor (i = 0; i < maxaddr; i++)\r\nchecksum = checksum + scarray[i];\r\nif (checksum == 0\r\n|| (checksum & 0xFFFF) != sc->checksum) {\r\nreturn (0);\r\n} else {\r\nreturn(1);\r\n}\r\n}
