void nft_meta_get_eval(const struct nft_expr *expr,\r\nstruct nft_data data[NFT_REG_MAX + 1],\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_meta *priv = nft_expr_priv(expr);\r\nconst struct sk_buff *skb = pkt->skb;\r\nconst struct net_device *in = pkt->in, *out = pkt->out;\r\nstruct nft_data *dest = &data[priv->dreg];\r\nswitch (priv->key) {\r\ncase NFT_META_LEN:\r\ndest->data[0] = skb->len;\r\nbreak;\r\ncase NFT_META_PROTOCOL:\r\n*(__be16 *)dest->data = skb->protocol;\r\nbreak;\r\ncase NFT_META_NFPROTO:\r\ndest->data[0] = pkt->ops->pf;\r\nbreak;\r\ncase NFT_META_L4PROTO:\r\ndest->data[0] = pkt->tprot;\r\nbreak;\r\ncase NFT_META_PRIORITY:\r\ndest->data[0] = skb->priority;\r\nbreak;\r\ncase NFT_META_MARK:\r\ndest->data[0] = skb->mark;\r\nbreak;\r\ncase NFT_META_IIF:\r\nif (in == NULL)\r\ngoto err;\r\ndest->data[0] = in->ifindex;\r\nbreak;\r\ncase NFT_META_OIF:\r\nif (out == NULL)\r\ngoto err;\r\ndest->data[0] = out->ifindex;\r\nbreak;\r\ncase NFT_META_IIFNAME:\r\nif (in == NULL)\r\ngoto err;\r\nstrncpy((char *)dest->data, in->name, sizeof(dest->data));\r\nbreak;\r\ncase NFT_META_OIFNAME:\r\nif (out == NULL)\r\ngoto err;\r\nstrncpy((char *)dest->data, out->name, sizeof(dest->data));\r\nbreak;\r\ncase NFT_META_IIFTYPE:\r\nif (in == NULL)\r\ngoto err;\r\n*(u16 *)dest->data = in->type;\r\nbreak;\r\ncase NFT_META_OIFTYPE:\r\nif (out == NULL)\r\ngoto err;\r\n*(u16 *)dest->data = out->type;\r\nbreak;\r\ncase NFT_META_SKUID:\r\nif (skb->sk == NULL || skb->sk->sk_state == TCP_TIME_WAIT)\r\ngoto err;\r\nread_lock_bh(&skb->sk->sk_callback_lock);\r\nif (skb->sk->sk_socket == NULL ||\r\nskb->sk->sk_socket->file == NULL) {\r\nread_unlock_bh(&skb->sk->sk_callback_lock);\r\ngoto err;\r\n}\r\ndest->data[0] =\r\nfrom_kuid_munged(&init_user_ns,\r\nskb->sk->sk_socket->file->f_cred->fsuid);\r\nread_unlock_bh(&skb->sk->sk_callback_lock);\r\nbreak;\r\ncase NFT_META_SKGID:\r\nif (skb->sk == NULL || skb->sk->sk_state == TCP_TIME_WAIT)\r\ngoto err;\r\nread_lock_bh(&skb->sk->sk_callback_lock);\r\nif (skb->sk->sk_socket == NULL ||\r\nskb->sk->sk_socket->file == NULL) {\r\nread_unlock_bh(&skb->sk->sk_callback_lock);\r\ngoto err;\r\n}\r\ndest->data[0] =\r\nfrom_kgid_munged(&init_user_ns,\r\nskb->sk->sk_socket->file->f_cred->fsgid);\r\nread_unlock_bh(&skb->sk->sk_callback_lock);\r\nbreak;\r\n#ifdef CONFIG_IP_ROUTE_CLASSID\r\ncase NFT_META_RTCLASSID: {\r\nconst struct dst_entry *dst = skb_dst(skb);\r\nif (dst == NULL)\r\ngoto err;\r\ndest->data[0] = dst->tclassid;\r\nbreak;\r\n}\r\n#endif\r\n#ifdef CONFIG_NETWORK_SECMARK\r\ncase NFT_META_SECMARK:\r\ndest->data[0] = skb->secmark;\r\nbreak;\r\n#endif\r\ncase NFT_META_PKTTYPE:\r\nif (skb->pkt_type != PACKET_LOOPBACK) {\r\ndest->data[0] = skb->pkt_type;\r\nbreak;\r\n}\r\nswitch (pkt->ops->pf) {\r\ncase NFPROTO_IPV4:\r\nif (ipv4_is_multicast(ip_hdr(skb)->daddr))\r\ndest->data[0] = PACKET_MULTICAST;\r\nelse\r\ndest->data[0] = PACKET_BROADCAST;\r\nbreak;\r\ncase NFPROTO_IPV6:\r\nif (ipv6_hdr(skb)->daddr.s6_addr[0] == 0xFF)\r\ndest->data[0] = PACKET_MULTICAST;\r\nelse\r\ndest->data[0] = PACKET_BROADCAST;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\ngoto err;\r\n}\r\nbreak;\r\ncase NFT_META_CPU:\r\ndest->data[0] = smp_processor_id();\r\nbreak;\r\ncase NFT_META_IIFGROUP:\r\nif (in == NULL)\r\ngoto err;\r\ndest->data[0] = in->group;\r\nbreak;\r\ncase NFT_META_OIFGROUP:\r\nif (out == NULL)\r\ngoto err;\r\ndest->data[0] = out->group;\r\nbreak;\r\ncase NFT_META_CGROUP:\r\nif (skb->sk == NULL)\r\nbreak;\r\ndest->data[0] = skb->sk->sk_classid;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\ngoto err;\r\n}\r\nreturn;\r\nerr:\r\ndata[NFT_REG_VERDICT].verdict = NFT_BREAK;\r\n}\r\nvoid nft_meta_set_eval(const struct nft_expr *expr,\r\nstruct nft_data data[NFT_REG_MAX + 1],\r\nconst struct nft_pktinfo *pkt)\r\n{\r\nconst struct nft_meta *meta = nft_expr_priv(expr);\r\nstruct sk_buff *skb = pkt->skb;\r\nu32 value = data[meta->sreg].data[0];\r\nswitch (meta->key) {\r\ncase NFT_META_MARK:\r\nskb->mark = value;\r\nbreak;\r\ncase NFT_META_PRIORITY:\r\nskb->priority = value;\r\nbreak;\r\ncase NFT_META_NFTRACE:\r\nskb->nf_trace = 1;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\n}\r\nint nft_meta_get_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_meta *priv = nft_expr_priv(expr);\r\nint err;\r\npriv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));\r\nswitch (priv->key) {\r\ncase NFT_META_LEN:\r\ncase NFT_META_PROTOCOL:\r\ncase NFT_META_NFPROTO:\r\ncase NFT_META_L4PROTO:\r\ncase NFT_META_PRIORITY:\r\ncase NFT_META_MARK:\r\ncase NFT_META_IIF:\r\ncase NFT_META_OIF:\r\ncase NFT_META_IIFNAME:\r\ncase NFT_META_OIFNAME:\r\ncase NFT_META_IIFTYPE:\r\ncase NFT_META_OIFTYPE:\r\ncase NFT_META_SKUID:\r\ncase NFT_META_SKGID:\r\n#ifdef CONFIG_IP_ROUTE_CLASSID\r\ncase NFT_META_RTCLASSID:\r\n#endif\r\n#ifdef CONFIG_NETWORK_SECMARK\r\ncase NFT_META_SECMARK:\r\n#endif\r\ncase NFT_META_PKTTYPE:\r\ncase NFT_META_CPU:\r\ncase NFT_META_IIFGROUP:\r\ncase NFT_META_OIFGROUP:\r\ncase NFT_META_CGROUP:\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\npriv->dreg = ntohl(nla_get_be32(tb[NFTA_META_DREG]));\r\nerr = nft_validate_output_register(priv->dreg);\r\nif (err < 0)\r\nreturn err;\r\nerr = nft_validate_data_load(ctx, priv->dreg, NULL, NFT_DATA_VALUE);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint nft_meta_set_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_meta *priv = nft_expr_priv(expr);\r\nint err;\r\npriv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));\r\nswitch (priv->key) {\r\ncase NFT_META_MARK:\r\ncase NFT_META_PRIORITY:\r\ncase NFT_META_NFTRACE:\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\npriv->sreg = ntohl(nla_get_be32(tb[NFTA_META_SREG]));\r\nerr = nft_validate_input_register(priv->sreg);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nint nft_meta_get_dump(struct sk_buff *skb,\r\nconst struct nft_expr *expr)\r\n{\r\nconst struct nft_meta *priv = nft_expr_priv(expr);\r\nif (nla_put_be32(skb, NFTA_META_KEY, htonl(priv->key)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_META_DREG, htonl(priv->dreg)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nint nft_meta_set_dump(struct sk_buff *skb,\r\nconst struct nft_expr *expr)\r\n{\r\nconst struct nft_meta *priv = nft_expr_priv(expr);\r\nif (nla_put_be32(skb, NFTA_META_KEY, htonl(priv->key)))\r\ngoto nla_put_failure;\r\nif (nla_put_be32(skb, NFTA_META_SREG, htonl(priv->sreg)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic const struct nft_expr_ops *\r\nnft_meta_select_ops(const struct nft_ctx *ctx,\r\nconst struct nlattr * const tb[])\r\n{\r\nif (tb[NFTA_META_KEY] == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nif (tb[NFTA_META_DREG] && tb[NFTA_META_SREG])\r\nreturn ERR_PTR(-EINVAL);\r\nif (tb[NFTA_META_DREG])\r\nreturn &nft_meta_get_ops;\r\nif (tb[NFTA_META_SREG])\r\nreturn &nft_meta_set_ops;\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int __init nft_meta_module_init(void)\r\n{\r\nreturn nft_register_expr(&nft_meta_type);\r\n}\r\nstatic void __exit nft_meta_module_exit(void)\r\n{\r\nnft_unregister_expr(&nft_meta_type);\r\n}
