static ssize_t pSeries_nvram_read(char *buf, size_t count, loff_t *index)\r\n{\r\nunsigned int i;\r\nunsigned long len;\r\nint done;\r\nunsigned long flags;\r\nchar *p = buf;\r\nif (nvram_size == 0 || nvram_fetch == RTAS_UNKNOWN_SERVICE)\r\nreturn -ENODEV;\r\nif (*index >= nvram_size)\r\nreturn 0;\r\ni = *index;\r\nif (i + count > nvram_size)\r\ncount = nvram_size - i;\r\nspin_lock_irqsave(&nvram_lock, flags);\r\nfor (; count != 0; count -= len) {\r\nlen = count;\r\nif (len > NVRW_CNT)\r\nlen = NVRW_CNT;\r\nif ((rtas_call(nvram_fetch, 3, 2, &done, i, __pa(nvram_buf),\r\nlen) != 0) || len != done) {\r\nspin_unlock_irqrestore(&nvram_lock, flags);\r\nreturn -EIO;\r\n}\r\nmemcpy(p, nvram_buf, len);\r\np += len;\r\ni += len;\r\n}\r\nspin_unlock_irqrestore(&nvram_lock, flags);\r\n*index = i;\r\nreturn p - buf;\r\n}\r\nstatic ssize_t pSeries_nvram_write(char *buf, size_t count, loff_t *index)\r\n{\r\nunsigned int i;\r\nunsigned long len;\r\nint done;\r\nunsigned long flags;\r\nconst char *p = buf;\r\nif (nvram_size == 0 || nvram_store == RTAS_UNKNOWN_SERVICE)\r\nreturn -ENODEV;\r\nif (*index >= nvram_size)\r\nreturn 0;\r\ni = *index;\r\nif (i + count > nvram_size)\r\ncount = nvram_size - i;\r\nspin_lock_irqsave(&nvram_lock, flags);\r\nfor (; count != 0; count -= len) {\r\nlen = count;\r\nif (len > NVRW_CNT)\r\nlen = NVRW_CNT;\r\nmemcpy(nvram_buf, p, len);\r\nif ((rtas_call(nvram_store, 3, 2, &done, i, __pa(nvram_buf),\r\nlen) != 0) || len != done) {\r\nspin_unlock_irqrestore(&nvram_lock, flags);\r\nreturn -EIO;\r\n}\r\np += len;\r\ni += len;\r\n}\r\nspin_unlock_irqrestore(&nvram_lock, flags);\r\n*index = i;\r\nreturn p - buf;\r\n}\r\nstatic ssize_t pSeries_nvram_get_size(void)\r\n{\r\nreturn nvram_size ? nvram_size : -ENODEV;\r\n}\r\nstatic int nvram_write_os_partition(struct nvram_os_partition *part,\r\nchar *buff, int length,\r\nunsigned int err_type,\r\nunsigned int error_log_cnt)\r\n{\r\nint rc;\r\nloff_t tmp_index;\r\nstruct err_log_info info;\r\nif (part->index == -1) {\r\nreturn -ESPIPE;\r\n}\r\nif (length > part->size) {\r\nlength = part->size;\r\n}\r\ninfo.error_type = cpu_to_be32(err_type);\r\ninfo.seq_num = cpu_to_be32(error_log_cnt);\r\ntmp_index = part->index;\r\nrc = ppc_md.nvram_write((char *)&info, sizeof(struct err_log_info), &tmp_index);\r\nif (rc <= 0) {\r\npr_err("%s: Failed nvram_write (%d)\n", __func__, rc);\r\nreturn rc;\r\n}\r\nrc = ppc_md.nvram_write(buff, length, &tmp_index);\r\nif (rc <= 0) {\r\npr_err("%s: Failed nvram_write (%d)\n", __func__, rc);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nint nvram_write_error_log(char * buff, int length,\r\nunsigned int err_type, unsigned int error_log_cnt)\r\n{\r\nint rc = nvram_write_os_partition(&rtas_log_partition, buff, length,\r\nerr_type, error_log_cnt);\r\nif (!rc) {\r\nlast_unread_rtas_event = get_seconds();\r\n#ifdef CONFIG_PSTORE\r\nlast_rtas_event = get_seconds();\r\n#endif\r\n}\r\nreturn rc;\r\n}\r\nstatic int nvram_read_partition(struct nvram_os_partition *part, char *buff,\r\nint length, unsigned int *err_type,\r\nunsigned int *error_log_cnt)\r\n{\r\nint rc;\r\nloff_t tmp_index;\r\nstruct err_log_info info;\r\nif (part->index == -1)\r\nreturn -1;\r\nif (length > part->size)\r\nlength = part->size;\r\ntmp_index = part->index;\r\nif (part->os_partition) {\r\nrc = ppc_md.nvram_read((char *)&info,\r\nsizeof(struct err_log_info),\r\n&tmp_index);\r\nif (rc <= 0) {\r\npr_err("%s: Failed nvram_read (%d)\n", __func__, rc);\r\nreturn rc;\r\n}\r\n}\r\nrc = ppc_md.nvram_read(buff, length, &tmp_index);\r\nif (rc <= 0) {\r\npr_err("%s: Failed nvram_read (%d)\n", __func__, rc);\r\nreturn rc;\r\n}\r\nif (part->os_partition) {\r\n*error_log_cnt = be32_to_cpu(info.seq_num);\r\n*err_type = be32_to_cpu(info.error_type);\r\n}\r\nreturn 0;\r\n}\r\nint nvram_read_error_log(char *buff, int length,\r\nunsigned int *err_type, unsigned int *error_log_cnt)\r\n{\r\nreturn nvram_read_partition(&rtas_log_partition, buff, length,\r\nerr_type, error_log_cnt);\r\n}\r\nint nvram_clear_error_log(void)\r\n{\r\nloff_t tmp_index;\r\nint clear_word = ERR_FLAG_ALREADY_LOGGED;\r\nint rc;\r\nif (rtas_log_partition.index == -1)\r\nreturn -1;\r\ntmp_index = rtas_log_partition.index;\r\nrc = ppc_md.nvram_write((char *)&clear_word, sizeof(int), &tmp_index);\r\nif (rc <= 0) {\r\nprintk(KERN_ERR "nvram_clear_error_log: Failed nvram_write (%d)\n", rc);\r\nreturn rc;\r\n}\r\nlast_unread_rtas_event = 0;\r\nreturn 0;\r\n}\r\nstatic int __init pseries_nvram_init_os_partition(struct nvram_os_partition\r\n*part)\r\n{\r\nloff_t p;\r\nint size;\r\np = nvram_find_partition(part->name, NVRAM_SIG_OS, &size);\r\nif (p && size < part->min_size) {\r\npr_info("nvram: Found too small %s partition,"\r\n" removing it...\n", part->name);\r\nnvram_remove_partition(part->name, NVRAM_SIG_OS, NULL);\r\np = 0;\r\n}\r\nif (!p) {\r\np = nvram_create_partition(part->name, NVRAM_SIG_OS,\r\npart->req_size, part->min_size);\r\nif (p == -ENOSPC) {\r\npr_info("nvram: No room to create %s partition, "\r\n"deleting any obsolete OS partitions...\n",\r\npart->name);\r\nnvram_remove_partition(NULL, NVRAM_SIG_OS,\r\npseries_nvram_os_partitions);\r\np = nvram_create_partition(part->name, NVRAM_SIG_OS,\r\npart->req_size, part->min_size);\r\n}\r\n}\r\nif (p <= 0) {\r\npr_err("nvram: Failed to find or create %s"\r\n" partition, err %d\n", part->name, (int)p);\r\nreturn -1;\r\n}\r\npart->index = p;\r\npart->size = nvram_get_partition_size(p) - sizeof(struct err_log_info);\r\nreturn 0;\r\n}\r\nstatic int clobbering_unread_rtas_event(void)\r\n{\r\nreturn (oops_log_partition.index == rtas_log_partition.index\r\n&& last_unread_rtas_event\r\n&& get_seconds() - last_unread_rtas_event <=\r\nNVRAM_RTAS_READ_TIMEOUT);\r\n}\r\nstatic int nvram_compress(const void *in, void *out, size_t inlen,\r\nsize_t outlen)\r\n{\r\nint err, ret;\r\nret = -EIO;\r\nerr = zlib_deflateInit2(&stream, COMPR_LEVEL, Z_DEFLATED, WINDOW_BITS,\r\nMEM_LEVEL, Z_DEFAULT_STRATEGY);\r\nif (err != Z_OK)\r\ngoto error;\r\nstream.next_in = in;\r\nstream.avail_in = inlen;\r\nstream.total_in = 0;\r\nstream.next_out = out;\r\nstream.avail_out = outlen;\r\nstream.total_out = 0;\r\nerr = zlib_deflate(&stream, Z_FINISH);\r\nif (err != Z_STREAM_END)\r\ngoto error;\r\nerr = zlib_deflateEnd(&stream);\r\nif (err != Z_OK)\r\ngoto error;\r\nif (stream.total_out >= stream.total_in)\r\ngoto error;\r\nret = stream.total_out;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int zip_oops(size_t text_len)\r\n{\r\nstruct oops_log_info *oops_hdr = (struct oops_log_info *)oops_buf;\r\nint zipped_len = nvram_compress(big_oops_buf, oops_data, text_len,\r\noops_data_sz);\r\nif (zipped_len < 0) {\r\npr_err("nvram: compression failed; returned %d\n", zipped_len);\r\npr_err("nvram: logging uncompressed oops/panic report\n");\r\nreturn -1;\r\n}\r\noops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\r\noops_hdr->report_length = cpu_to_be16(zipped_len);\r\noops_hdr->timestamp = cpu_to_be64(get_seconds());\r\nreturn 0;\r\n}\r\nstatic int nvram_pstore_open(struct pstore_info *psi)\r\n{\r\nread_type = -1;\r\nreturn 0;\r\n}\r\nstatic int nvram_pstore_write(enum pstore_type_id type,\r\nenum kmsg_dump_reason reason,\r\nu64 *id, unsigned int part, int count,\r\nbool compressed, size_t size,\r\nstruct pstore_info *psi)\r\n{\r\nint rc;\r\nunsigned int err_type = ERR_TYPE_KERNEL_PANIC;\r\nstruct oops_log_info *oops_hdr = (struct oops_log_info *) oops_buf;\r\nif (part > 1 || type != PSTORE_TYPE_DMESG ||\r\nclobbering_unread_rtas_event())\r\nreturn -1;\r\noops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\r\noops_hdr->report_length = cpu_to_be16(size);\r\noops_hdr->timestamp = cpu_to_be64(get_seconds());\r\nif (compressed)\r\nerr_type = ERR_TYPE_KERNEL_PANIC_GZ;\r\nrc = nvram_write_os_partition(&oops_log_partition, oops_buf,\r\n(int) (sizeof(*oops_hdr) + size), err_type, count);\r\nif (rc != 0)\r\nreturn rc;\r\n*id = part;\r\nreturn 0;\r\n}\r\nstatic ssize_t nvram_pstore_read(u64 *id, enum pstore_type_id *type,\r\nint *count, struct timespec *time, char **buf,\r\nbool *compressed, struct pstore_info *psi)\r\n{\r\nstruct oops_log_info *oops_hdr;\r\nunsigned int err_type, id_no, size = 0;\r\nstruct nvram_os_partition *part = NULL;\r\nchar *buff = NULL;\r\nint sig = 0;\r\nloff_t p;\r\nread_type++;\r\nswitch (nvram_type_ids[read_type]) {\r\ncase PSTORE_TYPE_DMESG:\r\npart = &oops_log_partition;\r\n*type = PSTORE_TYPE_DMESG;\r\nbreak;\r\ncase PSTORE_TYPE_PPC_RTAS:\r\npart = &rtas_log_partition;\r\n*type = PSTORE_TYPE_PPC_RTAS;\r\ntime->tv_sec = last_rtas_event;\r\ntime->tv_nsec = 0;\r\nbreak;\r\ncase PSTORE_TYPE_PPC_OF:\r\nsig = NVRAM_SIG_OF;\r\npart = &of_config_partition;\r\n*type = PSTORE_TYPE_PPC_OF;\r\n*id = PSTORE_TYPE_PPC_OF;\r\ntime->tv_sec = 0;\r\ntime->tv_nsec = 0;\r\nbreak;\r\ncase PSTORE_TYPE_PPC_COMMON:\r\nsig = NVRAM_SIG_SYS;\r\npart = &common_partition;\r\n*type = PSTORE_TYPE_PPC_COMMON;\r\n*id = PSTORE_TYPE_PPC_COMMON;\r\ntime->tv_sec = 0;\r\ntime->tv_nsec = 0;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (!part->os_partition) {\r\np = nvram_find_partition(part->name, sig, &size);\r\nif (p <= 0) {\r\npr_err("nvram: Failed to find partition %s, "\r\n"err %d\n", part->name, (int)p);\r\nreturn 0;\r\n}\r\npart->index = p;\r\npart->size = size;\r\n}\r\nbuff = kmalloc(part->size, GFP_KERNEL);\r\nif (!buff)\r\nreturn -ENOMEM;\r\nif (nvram_read_partition(part, buff, part->size, &err_type, &id_no)) {\r\nkfree(buff);\r\nreturn 0;\r\n}\r\n*count = 0;\r\nif (part->os_partition)\r\n*id = id_no;\r\nif (nvram_type_ids[read_type] == PSTORE_TYPE_DMESG) {\r\nsize_t length, hdr_size;\r\noops_hdr = (struct oops_log_info *)buff;\r\nif (be16_to_cpu(oops_hdr->version) < OOPS_HDR_VERSION) {\r\nhdr_size = sizeof(u16);\r\nlength = be16_to_cpu(oops_hdr->version);\r\ntime->tv_sec = 0;\r\ntime->tv_nsec = 0;\r\n} else {\r\nhdr_size = sizeof(*oops_hdr);\r\nlength = be16_to_cpu(oops_hdr->report_length);\r\ntime->tv_sec = be64_to_cpu(oops_hdr->timestamp);\r\ntime->tv_nsec = 0;\r\n}\r\n*buf = kmalloc(length, GFP_KERNEL);\r\nif (*buf == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(*buf, buff + hdr_size, length);\r\nkfree(buff);\r\nif (err_type == ERR_TYPE_KERNEL_PANIC_GZ)\r\n*compressed = true;\r\nelse\r\n*compressed = false;\r\nreturn length;\r\n}\r\n*buf = buff;\r\nreturn part->size;\r\n}\r\nstatic int nvram_pstore_init(void)\r\n{\r\nint rc = 0;\r\nnvram_pstore_info.buf = oops_data;\r\nnvram_pstore_info.bufsize = oops_data_sz;\r\nspin_lock_init(&nvram_pstore_info.buf_lock);\r\nrc = pstore_register(&nvram_pstore_info);\r\nif (rc != 0)\r\npr_err("nvram: pstore_register() failed, defaults to "\r\n"kmsg_dump; returned %d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int nvram_pstore_init(void)\r\n{\r\nreturn -1;\r\n}\r\nstatic void __init nvram_init_oops_partition(int rtas_partition_exists)\r\n{\r\nint rc;\r\nrc = pseries_nvram_init_os_partition(&oops_log_partition);\r\nif (rc != 0) {\r\nif (!rtas_partition_exists)\r\nreturn;\r\npr_notice("nvram: Using %s partition to log both"\r\n" RTAS errors and oops/panic reports\n",\r\nrtas_log_partition.name);\r\nmemcpy(&oops_log_partition, &rtas_log_partition,\r\nsizeof(rtas_log_partition));\r\n}\r\noops_buf = kmalloc(oops_log_partition.size, GFP_KERNEL);\r\nif (!oops_buf) {\r\npr_err("nvram: No memory for %s partition\n",\r\noops_log_partition.name);\r\nreturn;\r\n}\r\noops_data = oops_buf + sizeof(struct oops_log_info);\r\noops_data_sz = oops_log_partition.size - sizeof(struct oops_log_info);\r\nrc = nvram_pstore_init();\r\nif (!rc)\r\nreturn;\r\nbig_oops_buf_sz = (oops_data_sz * 100) / 45;\r\nbig_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);\r\nif (big_oops_buf) {\r\nstream.workspace = kmalloc(zlib_deflate_workspacesize(\r\nWINDOW_BITS, MEM_LEVEL), GFP_KERNEL);\r\nif (!stream.workspace) {\r\npr_err("nvram: No memory for compression workspace; "\r\n"skipping compression of %s partition data\n",\r\noops_log_partition.name);\r\nkfree(big_oops_buf);\r\nbig_oops_buf = NULL;\r\n}\r\n} else {\r\npr_err("No memory for uncompressed %s data; "\r\n"skipping compression\n", oops_log_partition.name);\r\nstream.workspace = NULL;\r\n}\r\nrc = kmsg_dump_register(&nvram_kmsg_dumper);\r\nif (rc != 0) {\r\npr_err("nvram: kmsg_dump_register() failed; returned %d\n", rc);\r\nkfree(oops_buf);\r\nkfree(big_oops_buf);\r\nkfree(stream.workspace);\r\n}\r\n}\r\nstatic int __init pseries_nvram_init_log_partitions(void)\r\n{\r\nint rc;\r\nnvram_scan_partitions();\r\nrc = pseries_nvram_init_os_partition(&rtas_log_partition);\r\nnvram_init_oops_partition(rc == 0);\r\nreturn 0;\r\n}\r\nint __init pSeries_nvram_init(void)\r\n{\r\nstruct device_node *nvram;\r\nconst __be32 *nbytes_p;\r\nunsigned int proplen;\r\nnvram = of_find_node_by_type(NULL, "nvram");\r\nif (nvram == NULL)\r\nreturn -ENODEV;\r\nnbytes_p = of_get_property(nvram, "#bytes", &proplen);\r\nif (nbytes_p == NULL || proplen != sizeof(unsigned int)) {\r\nof_node_put(nvram);\r\nreturn -EIO;\r\n}\r\nnvram_size = be32_to_cpup(nbytes_p);\r\nnvram_fetch = rtas_token("nvram-fetch");\r\nnvram_store = rtas_token("nvram-store");\r\nprintk(KERN_INFO "PPC64 nvram contains %d bytes\n", nvram_size);\r\nof_node_put(nvram);\r\nppc_md.nvram_read = pSeries_nvram_read;\r\nppc_md.nvram_write = pSeries_nvram_write;\r\nppc_md.nvram_size = pSeries_nvram_get_size;\r\nreturn 0;\r\n}\r\nstatic void oops_to_nvram(struct kmsg_dumper *dumper,\r\nenum kmsg_dump_reason reason)\r\n{\r\nstruct oops_log_info *oops_hdr = (struct oops_log_info *)oops_buf;\r\nstatic unsigned int oops_count = 0;\r\nstatic bool panicking = false;\r\nstatic DEFINE_SPINLOCK(lock);\r\nunsigned long flags;\r\nsize_t text_len;\r\nunsigned int err_type = ERR_TYPE_KERNEL_PANIC_GZ;\r\nint rc = -1;\r\nswitch (reason) {\r\ncase KMSG_DUMP_RESTART:\r\ncase KMSG_DUMP_HALT:\r\ncase KMSG_DUMP_POWEROFF:\r\nreturn;\r\ncase KMSG_DUMP_OOPS:\r\nbreak;\r\ncase KMSG_DUMP_PANIC:\r\npanicking = true;\r\nbreak;\r\ncase KMSG_DUMP_EMERG:\r\nif (panicking)\r\nreturn;\r\nbreak;\r\ndefault:\r\npr_err("%s: ignoring unrecognized KMSG_DUMP_* reason %d\n",\r\n__func__, (int) reason);\r\nreturn;\r\n}\r\nif (clobbering_unread_rtas_event())\r\nreturn;\r\nif (!spin_trylock_irqsave(&lock, flags))\r\nreturn;\r\nif (big_oops_buf) {\r\nkmsg_dump_get_buffer(dumper, false,\r\nbig_oops_buf, big_oops_buf_sz, &text_len);\r\nrc = zip_oops(text_len);\r\n}\r\nif (rc != 0) {\r\nkmsg_dump_rewind(dumper);\r\nkmsg_dump_get_buffer(dumper, false,\r\noops_data, oops_data_sz, &text_len);\r\nerr_type = ERR_TYPE_KERNEL_PANIC;\r\noops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\r\noops_hdr->report_length = cpu_to_be16(text_len);\r\noops_hdr->timestamp = cpu_to_be64(get_seconds());\r\n}\r\n(void) nvram_write_os_partition(&oops_log_partition, oops_buf,\r\n(int) (sizeof(*oops_hdr) + text_len), err_type,\r\n++oops_count);\r\nspin_unlock_irqrestore(&lock, flags);\r\n}
