static int swsci(struct drm_device *dev, u32 function, u32 parm, u32 *parm_out)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct opregion_swsci __iomem *swsci = dev_priv->opregion.swsci;\r\nu32 main_function, sub_function, scic;\r\nu16 pci_swsci;\r\nu32 dslp;\r\nif (!swsci)\r\nreturn -ENODEV;\r\nmain_function = (function & SWSCI_SCIC_MAIN_FUNCTION_MASK) >>\r\nSWSCI_SCIC_MAIN_FUNCTION_SHIFT;\r\nsub_function = (function & SWSCI_SCIC_SUB_FUNCTION_MASK) >>\r\nSWSCI_SCIC_SUB_FUNCTION_SHIFT;\r\nif (main_function == SWSCI_SBCB) {\r\nif ((dev_priv->opregion.swsci_sbcb_sub_functions &\r\n(1 << sub_function)) == 0)\r\nreturn -EINVAL;\r\n} else if (main_function == SWSCI_GBDA) {\r\nif ((dev_priv->opregion.swsci_gbda_sub_functions &\r\n(1 << sub_function)) == 0)\r\nreturn -EINVAL;\r\n}\r\ndslp = ioread32(&swsci->dslp);\r\nif (!dslp) {\r\ndslp = 50;\r\n} else if (dslp > MAX_DSLP) {\r\nDRM_INFO_ONCE("ACPI BIOS requests an excessive sleep of %u ms, "\r\n"using %u ms instead\n", dslp, MAX_DSLP);\r\ndslp = MAX_DSLP;\r\n}\r\nscic = ioread32(&swsci->scic);\r\nif (scic & SWSCI_SCIC_INDICATOR) {\r\nDRM_DEBUG_DRIVER("SWSCI request already in progress\n");\r\nreturn -EBUSY;\r\n}\r\nscic = function | SWSCI_SCIC_INDICATOR;\r\niowrite32(parm, &swsci->parm);\r\niowrite32(scic, &swsci->scic);\r\npci_read_config_word(dev->pdev, PCI_SWSCI, &pci_swsci);\r\nif (!(pci_swsci & PCI_SWSCI_SCISEL) || (pci_swsci & PCI_SWSCI_GSSCIE)) {\r\npci_swsci |= PCI_SWSCI_SCISEL;\r\npci_swsci &= ~PCI_SWSCI_GSSCIE;\r\npci_write_config_word(dev->pdev, PCI_SWSCI, pci_swsci);\r\n}\r\npci_swsci |= PCI_SWSCI_GSSCIE;\r\npci_write_config_word(dev->pdev, PCI_SWSCI, pci_swsci);\r\n#define C (((scic = ioread32(&swsci->scic)) & SWSCI_SCIC_INDICATOR) == 0)\r\nif (wait_for(C, dslp)) {\r\nDRM_DEBUG_DRIVER("SWSCI request timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nscic = (scic & SWSCI_SCIC_EXIT_STATUS_MASK) >>\r\nSWSCI_SCIC_EXIT_STATUS_SHIFT;\r\nif (scic != SWSCI_SCIC_EXIT_STATUS_SUCCESS) {\r\nDRM_DEBUG_DRIVER("SWSCI request error %u\n", scic);\r\nreturn -EIO;\r\n}\r\nif (parm_out)\r\n*parm_out = ioread32(&swsci->parm);\r\nreturn 0;\r\n#undef C\r\n}\r\nint intel_opregion_notify_encoder(struct intel_encoder *intel_encoder,\r\nbool enable)\r\n{\r\nstruct drm_device *dev = intel_encoder->base.dev;\r\nu32 parm = 0;\r\nu32 type = 0;\r\nu32 port;\r\nif (!HAS_DDI(dev))\r\nreturn 0;\r\nport = intel_ddi_get_encoder_port(intel_encoder);\r\nif (port == PORT_E) {\r\nport = 0;\r\n} else {\r\nparm |= 1 << port;\r\nport++;\r\n}\r\nif (!enable)\r\nparm |= 4 << 8;\r\nswitch (intel_encoder->type) {\r\ncase INTEL_OUTPUT_ANALOG:\r\ntype = DISPLAY_TYPE_CRT;\r\nbreak;\r\ncase INTEL_OUTPUT_UNKNOWN:\r\ncase INTEL_OUTPUT_DISPLAYPORT:\r\ncase INTEL_OUTPUT_HDMI:\r\ncase INTEL_OUTPUT_DP_MST:\r\ntype = DISPLAY_TYPE_EXTERNAL_FLAT_PANEL;\r\nbreak;\r\ncase INTEL_OUTPUT_EDP:\r\ntype = DISPLAY_TYPE_INTERNAL_FLAT_PANEL;\r\nbreak;\r\ndefault:\r\nWARN_ONCE(1, "unsupported intel_encoder type %d\n",\r\nintel_encoder->type);\r\nreturn -EINVAL;\r\n}\r\nparm |= type << (16 + port * 3);\r\nreturn swsci(dev, SWSCI_SBCB_DISPLAY_POWER_STATE, parm, NULL);\r\n}\r\nint intel_opregion_notify_adapter(struct drm_device *dev, pci_power_t state)\r\n{\r\nint i;\r\nif (!HAS_DDI(dev))\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(power_state_map); i++) {\r\nif (state == power_state_map[i].pci_power_state)\r\nreturn swsci(dev, SWSCI_SBCB_ADAPTER_POWER_STATE,\r\npower_state_map[i].parm, NULL);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic bool should_ignore_backlight_request(void)\r\n{\r\nreturn acpi_video_backlight_support() &&\r\n!acpi_video_verify_backlight_support();\r\n}\r\nstatic u32 asle_set_backlight(struct drm_device *dev, u32 bclp)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_connector *intel_connector;\r\nstruct opregion_asle __iomem *asle = dev_priv->opregion.asle;\r\nDRM_DEBUG_DRIVER("bclp = 0x%08x\n", bclp);\r\nif (should_ignore_backlight_request()) {\r\nDRM_DEBUG_KMS("opregion backlight request ignored\n");\r\nreturn 0;\r\n}\r\nif (!(bclp & ASLE_BCLP_VALID))\r\nreturn ASLC_BACKLIGHT_FAILED;\r\nbclp &= ASLE_BCLP_MSK;\r\nif (bclp > 255)\r\nreturn ASLC_BACKLIGHT_FAILED;\r\ndrm_modeset_lock(&dev->mode_config.connection_mutex, NULL);\r\nDRM_DEBUG_KMS("updating opregion backlight %d/255\n", bclp);\r\nlist_for_each_entry(intel_connector, &dev->mode_config.connector_list, base.head)\r\nintel_panel_set_backlight_acpi(intel_connector, bclp, 255);\r\niowrite32(DIV_ROUND_UP(bclp * 100, 255) | ASLE_CBLV_VALID, &asle->cblv);\r\ndrm_modeset_unlock(&dev->mode_config.connection_mutex);\r\nreturn 0;\r\n}\r\nstatic u32 asle_set_als_illum(struct drm_device *dev, u32 alsi)\r\n{\r\nDRM_DEBUG_DRIVER("Illum is not supported\n");\r\nreturn ASLC_ALS_ILLUM_FAILED;\r\n}\r\nstatic u32 asle_set_pwm_freq(struct drm_device *dev, u32 pfmb)\r\n{\r\nDRM_DEBUG_DRIVER("PWM freq is not supported\n");\r\nreturn ASLC_PWM_FREQ_FAILED;\r\n}\r\nstatic u32 asle_set_pfit(struct drm_device *dev, u32 pfit)\r\n{\r\nDRM_DEBUG_DRIVER("Pfit is not supported\n");\r\nreturn ASLC_PFIT_FAILED;\r\n}\r\nstatic u32 asle_set_supported_rotation_angles(struct drm_device *dev, u32 srot)\r\n{\r\nDRM_DEBUG_DRIVER("SROT is not supported\n");\r\nreturn ASLC_ROTATION_ANGLES_FAILED;\r\n}\r\nstatic u32 asle_set_button_array(struct drm_device *dev, u32 iuer)\r\n{\r\nif (!iuer)\r\nDRM_DEBUG_DRIVER("Button array event is not supported (nothing)\n");\r\nif (iuer & ASLE_IUER_ROTATION_LOCK_BTN)\r\nDRM_DEBUG_DRIVER("Button array event is not supported (rotation lock)\n");\r\nif (iuer & ASLE_IUER_VOLUME_DOWN_BTN)\r\nDRM_DEBUG_DRIVER("Button array event is not supported (volume down)\n");\r\nif (iuer & ASLE_IUER_VOLUME_UP_BTN)\r\nDRM_DEBUG_DRIVER("Button array event is not supported (volume up)\n");\r\nif (iuer & ASLE_IUER_WINDOWS_BTN)\r\nDRM_DEBUG_DRIVER("Button array event is not supported (windows)\n");\r\nif (iuer & ASLE_IUER_POWER_BTN)\r\nDRM_DEBUG_DRIVER("Button array event is not supported (power)\n");\r\nreturn ASLC_BUTTON_ARRAY_FAILED;\r\n}\r\nstatic u32 asle_set_convertible(struct drm_device *dev, u32 iuer)\r\n{\r\nif (iuer & ASLE_IUER_CONVERTIBLE)\r\nDRM_DEBUG_DRIVER("Convertible is not supported (clamshell)\n");\r\nelse\r\nDRM_DEBUG_DRIVER("Convertible is not supported (slate)\n");\r\nreturn ASLC_CONVERTIBLE_FAILED;\r\n}\r\nstatic u32 asle_set_docking(struct drm_device *dev, u32 iuer)\r\n{\r\nif (iuer & ASLE_IUER_DOCKING)\r\nDRM_DEBUG_DRIVER("Docking is not supported (docked)\n");\r\nelse\r\nDRM_DEBUG_DRIVER("Docking is not supported (undocked)\n");\r\nreturn ASLC_DOCKING_FAILED;\r\n}\r\nstatic u32 asle_isct_state(struct drm_device *dev)\r\n{\r\nDRM_DEBUG_DRIVER("ISCT is not supported\n");\r\nreturn ASLC_ISCT_STATE_FAILED;\r\n}\r\nstatic void asle_work(struct work_struct *work)\r\n{\r\nstruct intel_opregion *opregion =\r\ncontainer_of(work, struct intel_opregion, asle_work);\r\nstruct drm_i915_private *dev_priv =\r\ncontainer_of(opregion, struct drm_i915_private, opregion);\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct opregion_asle __iomem *asle = dev_priv->opregion.asle;\r\nu32 aslc_stat = 0;\r\nu32 aslc_req;\r\nif (!asle)\r\nreturn;\r\naslc_req = ioread32(&asle->aslc);\r\nif (!(aslc_req & ASLC_REQ_MSK)) {\r\nDRM_DEBUG_DRIVER("No request on ASLC interrupt 0x%08x\n",\r\naslc_req);\r\nreturn;\r\n}\r\nif (aslc_req & ASLC_SET_ALS_ILLUM)\r\naslc_stat |= asle_set_als_illum(dev, ioread32(&asle->alsi));\r\nif (aslc_req & ASLC_SET_BACKLIGHT)\r\naslc_stat |= asle_set_backlight(dev, ioread32(&asle->bclp));\r\nif (aslc_req & ASLC_SET_PFIT)\r\naslc_stat |= asle_set_pfit(dev, ioread32(&asle->pfit));\r\nif (aslc_req & ASLC_SET_PWM_FREQ)\r\naslc_stat |= asle_set_pwm_freq(dev, ioread32(&asle->pfmb));\r\nif (aslc_req & ASLC_SUPPORTED_ROTATION_ANGLES)\r\naslc_stat |= asle_set_supported_rotation_angles(dev,\r\nioread32(&asle->srot));\r\nif (aslc_req & ASLC_BUTTON_ARRAY)\r\naslc_stat |= asle_set_button_array(dev, ioread32(&asle->iuer));\r\nif (aslc_req & ASLC_CONVERTIBLE_INDICATOR)\r\naslc_stat |= asle_set_convertible(dev, ioread32(&asle->iuer));\r\nif (aslc_req & ASLC_DOCKING_INDICATOR)\r\naslc_stat |= asle_set_docking(dev, ioread32(&asle->iuer));\r\nif (aslc_req & ASLC_ISCT_STATE_CHANGE)\r\naslc_stat |= asle_isct_state(dev);\r\niowrite32(aslc_stat, &asle->aslc);\r\n}\r\nvoid intel_opregion_asle_intr(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nif (dev_priv->opregion.asle)\r\nschedule_work(&dev_priv->opregion.asle_work);\r\n}\r\nstatic int intel_opregion_video_event(struct notifier_block *nb,\r\nunsigned long val, void *data)\r\n{\r\nstruct opregion_acpi __iomem *acpi;\r\nstruct acpi_bus_event *event = data;\r\nint ret = NOTIFY_OK;\r\nif (strcmp(event->device_class, ACPI_VIDEO_CLASS) != 0)\r\nreturn NOTIFY_DONE;\r\nif (!system_opregion)\r\nreturn NOTIFY_DONE;\r\nacpi = system_opregion->acpi;\r\nif (event->type == 0x80 &&\r\n(ioread32(&acpi->cevt) & 1) == 0)\r\nret = NOTIFY_BAD;\r\niowrite32(0, &acpi->csts);\r\nreturn ret;\r\n}\r\nstatic void intel_didl_outputs(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_opregion *opregion = &dev_priv->opregion;\r\nstruct drm_connector *connector;\r\nacpi_handle handle;\r\nstruct acpi_device *acpi_dev, *acpi_cdev, *acpi_video_bus = NULL;\r\nunsigned long long device_id;\r\nacpi_status status;\r\nu32 temp;\r\nint i = 0;\r\nhandle = ACPI_HANDLE(&dev->pdev->dev);\r\nif (!handle || acpi_bus_get_device(handle, &acpi_dev))\r\nreturn;\r\nif (acpi_is_video_device(handle))\r\nacpi_video_bus = acpi_dev;\r\nelse {\r\nlist_for_each_entry(acpi_cdev, &acpi_dev->children, node) {\r\nif (acpi_is_video_device(acpi_cdev->handle)) {\r\nacpi_video_bus = acpi_cdev;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!acpi_video_bus) {\r\npr_warn("No ACPI video bus found\n");\r\nreturn;\r\n}\r\nlist_for_each_entry(acpi_cdev, &acpi_video_bus->children, node) {\r\nif (i >= 8) {\r\ndev_dbg(&dev->pdev->dev,\r\n"More than 8 outputs detected via ACPI\n");\r\nreturn;\r\n}\r\nstatus =\r\nacpi_evaluate_integer(acpi_cdev->handle, "_ADR",\r\nNULL, &device_id);\r\nif (ACPI_SUCCESS(status)) {\r\nif (!device_id)\r\ngoto blind_set;\r\niowrite32((u32)(device_id & 0x0f0f),\r\n&opregion->acpi->didl[i]);\r\ni++;\r\n}\r\n}\r\nend:\r\nif (i < 8)\r\niowrite32(0, &opregion->acpi->didl[i]);\r\nreturn;\r\nblind_set:\r\ni = 0;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nint output_type = ACPI_OTHER_OUTPUT;\r\nif (i >= 8) {\r\ndev_dbg(&dev->pdev->dev,\r\n"More than 8 outputs in connector list\n");\r\nreturn;\r\n}\r\nswitch (connector->connector_type) {\r\ncase DRM_MODE_CONNECTOR_VGA:\r\ncase DRM_MODE_CONNECTOR_DVIA:\r\noutput_type = ACPI_VGA_OUTPUT;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_Composite:\r\ncase DRM_MODE_CONNECTOR_SVIDEO:\r\ncase DRM_MODE_CONNECTOR_Component:\r\ncase DRM_MODE_CONNECTOR_9PinDIN:\r\noutput_type = ACPI_TV_OUTPUT;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_DVII:\r\ncase DRM_MODE_CONNECTOR_DVID:\r\ncase DRM_MODE_CONNECTOR_DisplayPort:\r\ncase DRM_MODE_CONNECTOR_HDMIA:\r\ncase DRM_MODE_CONNECTOR_HDMIB:\r\noutput_type = ACPI_DIGITAL_OUTPUT;\r\nbreak;\r\ncase DRM_MODE_CONNECTOR_LVDS:\r\noutput_type = ACPI_LVDS_OUTPUT;\r\nbreak;\r\n}\r\ntemp = ioread32(&opregion->acpi->didl[i]);\r\niowrite32(temp | (1<<31) | output_type | i,\r\n&opregion->acpi->didl[i]);\r\ni++;\r\n}\r\ngoto end;\r\n}\r\nstatic void intel_setup_cadls(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_opregion *opregion = &dev_priv->opregion;\r\nint i = 0;\r\nu32 disp_id;\r\ndo {\r\ndisp_id = ioread32(&opregion->acpi->didl[i]);\r\niowrite32(disp_id, &opregion->acpi->cadl[i]);\r\n} while (++i < 8 && disp_id != 0);\r\n}\r\nvoid intel_opregion_init(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_opregion *opregion = &dev_priv->opregion;\r\nif (!opregion->header)\r\nreturn;\r\nif (opregion->acpi) {\r\nif (drm_core_check_feature(dev, DRIVER_MODESET)) {\r\nintel_didl_outputs(dev);\r\nintel_setup_cadls(dev);\r\n}\r\niowrite32(0, &opregion->acpi->csts);\r\niowrite32(1, &opregion->acpi->drdy);\r\nsystem_opregion = opregion;\r\nregister_acpi_notifier(&intel_opregion_notifier);\r\n}\r\nif (opregion->asle) {\r\niowrite32(ASLE_TCHE_BLC_EN, &opregion->asle->tche);\r\niowrite32(ASLE_ARDY_READY, &opregion->asle->ardy);\r\n}\r\n}\r\nvoid intel_opregion_fini(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_opregion *opregion = &dev_priv->opregion;\r\nif (!opregion->header)\r\nreturn;\r\nif (opregion->asle)\r\niowrite32(ASLE_ARDY_NOT_READY, &opregion->asle->ardy);\r\ncancel_work_sync(&dev_priv->opregion.asle_work);\r\nif (opregion->acpi) {\r\niowrite32(0, &opregion->acpi->drdy);\r\nsystem_opregion = NULL;\r\nunregister_acpi_notifier(&intel_opregion_notifier);\r\n}\r\niounmap(opregion->header);\r\nopregion->header = NULL;\r\nopregion->acpi = NULL;\r\nopregion->swsci = NULL;\r\nopregion->asle = NULL;\r\nopregion->vbt = NULL;\r\nopregion->lid_state = NULL;\r\n}\r\nstatic void swsci_setup(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_opregion *opregion = &dev_priv->opregion;\r\nbool requested_callbacks = false;\r\nu32 tmp;\r\nopregion->swsci_gbda_sub_functions = 1;\r\nopregion->swsci_sbcb_sub_functions = 1;\r\nif (swsci(dev, SWSCI_GBDA_SUPPORTED_CALLS, 0, &tmp) == 0) {\r\ntmp <<= 1;\r\nopregion->swsci_gbda_sub_functions |= tmp;\r\n}\r\nif (swsci(dev, SWSCI_GBDA_REQUESTED_CALLBACKS, 0, &tmp) == 0) {\r\nopregion->swsci_sbcb_sub_functions |= tmp;\r\nrequested_callbacks = true;\r\n}\r\nif (swsci(dev, SWSCI_SBCB_SUPPORTED_CALLBACKS, 0, &tmp) == 0) {\r\nu32 low = tmp & 0x7ff;\r\nu32 high = tmp & ~0xfff;\r\ntmp = (high << 4) | (low << 1) | 1;\r\nif (requested_callbacks) {\r\nu32 req = opregion->swsci_sbcb_sub_functions;\r\nif ((req & tmp) != req)\r\nDRM_DEBUG_DRIVER("SWSCI BIOS requested (%08x) SBCB callbacks that are not supported (%08x)\n", req, tmp);\r\n} else {\r\nopregion->swsci_sbcb_sub_functions |= tmp;\r\n}\r\n}\r\nDRM_DEBUG_DRIVER("SWSCI GBDA callbacks %08x, SBCB callbacks %08x\n",\r\nopregion->swsci_gbda_sub_functions,\r\nopregion->swsci_sbcb_sub_functions);\r\n}\r\nstatic inline void swsci_setup(struct drm_device *dev) {}\r\nint intel_opregion_setup(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct intel_opregion *opregion = &dev_priv->opregion;\r\nvoid __iomem *base;\r\nu32 asls, mboxes;\r\nchar buf[sizeof(OPREGION_SIGNATURE)];\r\nint err = 0;\r\npci_read_config_dword(dev->pdev, PCI_ASLS, &asls);\r\nDRM_DEBUG_DRIVER("graphic opregion physical addr: 0x%x\n", asls);\r\nif (asls == 0) {\r\nDRM_DEBUG_DRIVER("ACPI OpRegion not supported!\n");\r\nreturn -ENOTSUPP;\r\n}\r\n#ifdef CONFIG_ACPI\r\nINIT_WORK(&opregion->asle_work, asle_work);\r\n#endif\r\nbase = acpi_os_ioremap(asls, OPREGION_SIZE);\r\nif (!base)\r\nreturn -ENOMEM;\r\nmemcpy_fromio(buf, base, sizeof(buf));\r\nif (memcmp(buf, OPREGION_SIGNATURE, 16)) {\r\nDRM_DEBUG_DRIVER("opregion signature mismatch\n");\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\nopregion->header = base;\r\nopregion->vbt = base + OPREGION_VBT_OFFSET;\r\nopregion->lid_state = base + ACPI_CLID;\r\nmboxes = ioread32(&opregion->header->mboxes);\r\nif (mboxes & MBOX_ACPI) {\r\nDRM_DEBUG_DRIVER("Public ACPI methods supported\n");\r\nopregion->acpi = base + OPREGION_ACPI_OFFSET;\r\n}\r\nif (mboxes & MBOX_SWSCI) {\r\nDRM_DEBUG_DRIVER("SWSCI supported\n");\r\nopregion->swsci = base + OPREGION_SWSCI_OFFSET;\r\nswsci_setup(dev);\r\n}\r\nif (mboxes & MBOX_ASLE) {\r\nDRM_DEBUG_DRIVER("ASLE supported\n");\r\nopregion->asle = base + OPREGION_ASLE_OFFSET;\r\niowrite32(ASLE_ARDY_NOT_READY, &opregion->asle->ardy);\r\n}\r\nreturn 0;\r\nerr_out:\r\niounmap(base);\r\nreturn err;\r\n}
