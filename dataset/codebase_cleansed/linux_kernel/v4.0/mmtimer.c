static int mmtimer_int_pending(int comparator)\r\n{\r\nif (HUB_L((unsigned long *)LOCAL_MMR_ADDR(SH_EVENT_OCCURRED)) &\r\nSH_EVENT_OCCURRED_RTC1_INT_MASK << comparator)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void mmtimer_clr_int_pending(int comparator)\r\n{\r\nHUB_S((u64 *)LOCAL_MMR_ADDR(SH_EVENT_OCCURRED_ALIAS),\r\nSH_EVENT_OCCURRED_RTC1_INT_MASK << comparator);\r\n}\r\nstatic void mmtimer_setup_int_0(int cpu, u64 expires)\r\n{\r\nu64 val;\r\nHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC1_INT_ENABLE), 0UL);\r\nHUB_S((u64 *)LOCAL_MMR_ADDR(SH_INT_CMPB), -1L);\r\nmmtimer_clr_int_pending(0);\r\nval = ((u64)SGI_MMTIMER_VECTOR << SH_RTC1_INT_CONFIG_IDX_SHFT) |\r\n((u64)cpu_physical_id(cpu) <<\r\nSH_RTC1_INT_CONFIG_PID_SHFT);\r\nHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC1_INT_CONFIG), val);\r\nHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC1_INT_ENABLE), 1UL);\r\nHUB_S((u64 *)LOCAL_MMR_ADDR(SH_INT_CMPB), expires);\r\n}\r\nstatic void mmtimer_setup_int_1(int cpu, u64 expires)\r\n{\r\nu64 val;\r\nHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC2_INT_ENABLE), 0UL);\r\nHUB_S((u64 *)LOCAL_MMR_ADDR(SH_INT_CMPC), -1L);\r\nmmtimer_clr_int_pending(1);\r\nval = ((u64)SGI_MMTIMER_VECTOR << SH_RTC2_INT_CONFIG_IDX_SHFT) |\r\n((u64)cpu_physical_id(cpu) <<\r\nSH_RTC2_INT_CONFIG_PID_SHFT);\r\nHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC2_INT_CONFIG), val);\r\nHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC2_INT_ENABLE), 1UL);\r\nHUB_S((u64 *)LOCAL_MMR_ADDR(SH_INT_CMPC), expires);\r\n}\r\nstatic void mmtimer_setup_int_2(int cpu, u64 expires)\r\n{\r\nu64 val;\r\nHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC3_INT_ENABLE), 0UL);\r\nHUB_S((u64 *)LOCAL_MMR_ADDR(SH_INT_CMPD), -1L);\r\nmmtimer_clr_int_pending(2);\r\nval = ((u64)SGI_MMTIMER_VECTOR << SH_RTC3_INT_CONFIG_IDX_SHFT) |\r\n((u64)cpu_physical_id(cpu) <<\r\nSH_RTC3_INT_CONFIG_PID_SHFT);\r\nHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC3_INT_CONFIG), val);\r\nHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC3_INT_ENABLE), 1UL);\r\nHUB_S((u64 *)LOCAL_MMR_ADDR(SH_INT_CMPD), expires);\r\n}\r\nstatic int mmtimer_setup(int cpu, int comparator, unsigned long expires,\r\nu64 *set_completion_time)\r\n{\r\nswitch (comparator) {\r\ncase 0:\r\nmmtimer_setup_int_0(cpu, expires);\r\nbreak;\r\ncase 1:\r\nmmtimer_setup_int_1(cpu, expires);\r\nbreak;\r\ncase 2:\r\nmmtimer_setup_int_2(cpu, expires);\r\nbreak;\r\n}\r\n*set_completion_time = rtc_time();\r\nif (*set_completion_time <= expires)\r\nreturn 1;\r\nreturn mmtimer_int_pending(comparator);\r\n}\r\nstatic int mmtimer_disable_int(long nasid, int comparator)\r\n{\r\nswitch (comparator) {\r\ncase 0:\r\nnasid == -1 ? HUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC1_INT_ENABLE),\r\n0UL) : REMOTE_HUB_S(nasid, SH_RTC1_INT_ENABLE, 0UL);\r\nbreak;\r\ncase 1:\r\nnasid == -1 ? HUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC2_INT_ENABLE),\r\n0UL) : REMOTE_HUB_S(nasid, SH_RTC2_INT_ENABLE, 0UL);\r\nbreak;\r\ncase 2:\r\nnasid == -1 ? HUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC3_INT_ENABLE),\r\n0UL) : REMOTE_HUB_S(nasid, SH_RTC3_INT_ENABLE, 0UL);\r\nbreak;\r\ndefault:\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mmtimer_add_list(struct mmtimer *n)\r\n{\r\nint nodeid = n->timer->it.mmtimer.node;\r\nunsigned long expires = n->timer->it.mmtimer.expires;\r\nstruct rb_node **link = &timers[nodeid].timer_head.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct mmtimer *x;\r\nwhile (*link) {\r\nparent = *link;\r\nx = rb_entry(parent, struct mmtimer, list);\r\nif (expires < x->timer->it.mmtimer.expires)\r\nlink = &(*link)->rb_left;\r\nelse\r\nlink = &(*link)->rb_right;\r\n}\r\nrb_link_node(&n->list, parent, link);\r\nrb_insert_color(&n->list, &timers[nodeid].timer_head);\r\nif (!timers[nodeid].next || expires < rb_entry(timers[nodeid].next,\r\nstruct mmtimer, list)->timer->it.mmtimer.expires)\r\ntimers[nodeid].next = &n->list;\r\n}\r\nstatic void mmtimer_set_next_timer(int nodeid)\r\n{\r\nstruct mmtimer_node *n = &timers[nodeid];\r\nstruct mmtimer *x;\r\nstruct k_itimer *t;\r\nu64 expires, exp, set_completion_time;\r\nint i;\r\nrestart:\r\nif (n->next == NULL)\r\nreturn;\r\nx = rb_entry(n->next, struct mmtimer, list);\r\nt = x->timer;\r\nif (!t->it.mmtimer.incr) {\r\nif (!mmtimer_setup(x->cpu, COMPARATOR,\r\nt->it.mmtimer.expires,\r\n&set_completion_time)) {\r\ntasklet_schedule(&n->tasklet);\r\n}\r\nreturn;\r\n}\r\ni = 0;\r\nexpires = exp = t->it.mmtimer.expires;\r\nwhile (!mmtimer_setup(x->cpu, COMPARATOR, expires,\r\n&set_completion_time)) {\r\nint to;\r\ni++;\r\nexpires = set_completion_time +\r\nmmtimer_interval_retry_increment + (1 << i);\r\nto = ((u64)(expires - exp) / t->it.mmtimer.incr);\r\nif (to) {\r\nt->it_overrun += to;\r\nt->it.mmtimer.expires += t->it.mmtimer.incr * to;\r\nexp = t->it.mmtimer.expires;\r\n}\r\nif (i > 20) {\r\nprintk(KERN_ALERT "mmtimer: cannot reschedule timer\n");\r\nt->it.mmtimer.clock = TIMER_OFF;\r\nn->next = rb_next(&x->list);\r\nrb_erase(&x->list, &n->timer_head);\r\nkfree(x);\r\ngoto restart;\r\n}\r\n}\r\n}\r\nstatic long mmtimer_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint ret = 0;\r\nmutex_lock(&mmtimer_mutex);\r\nswitch (cmd) {\r\ncase MMTIMER_GETOFFSET:\r\nif(PAGE_SIZE <= (1 << 16))\r\nret = (((long)RTC_COUNTER_ADDR) & (PAGE_SIZE-1)) / 8;\r\nelse\r\nret = -ENOSYS;\r\nbreak;\r\ncase MMTIMER_GETRES:\r\nif(copy_to_user((unsigned long __user *)arg,\r\n&mmtimer_femtoperiod, sizeof(unsigned long)))\r\nret = -EFAULT;\r\nbreak;\r\ncase MMTIMER_GETFREQ:\r\nif(copy_to_user((unsigned long __user *)arg,\r\n&sn_rtc_cycles_per_second,\r\nsizeof(unsigned long)))\r\nret = -EFAULT;\r\nbreak;\r\ncase MMTIMER_GETBITS:\r\nret = RTC_BITS;\r\nbreak;\r\ncase MMTIMER_MMAPAVAIL:\r\nret = (PAGE_SIZE <= (1 << 16)) ? 1 : 0;\r\nbreak;\r\ncase MMTIMER_GETCOUNTER:\r\nif(copy_to_user((unsigned long __user *)arg,\r\nRTC_COUNTER_ADDR, sizeof(unsigned long)))\r\nret = -EFAULT;\r\nbreak;\r\ndefault:\r\nret = -ENOTTY;\r\nbreak;\r\n}\r\nmutex_unlock(&mmtimer_mutex);\r\nreturn ret;\r\n}\r\nstatic int mmtimer_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nunsigned long mmtimer_addr;\r\nif (vma->vm_end - vma->vm_start != PAGE_SIZE)\r\nreturn -EINVAL;\r\nif (vma->vm_flags & VM_WRITE)\r\nreturn -EPERM;\r\nif (PAGE_SIZE > (1 << 16))\r\nreturn -ENOSYS;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\nmmtimer_addr = __pa(RTC_COUNTER_ADDR);\r\nmmtimer_addr &= ~(PAGE_SIZE - 1);\r\nmmtimer_addr &= 0xfffffffffffffffUL;\r\nif (remap_pfn_range(vma, vma->vm_start, mmtimer_addr >> PAGE_SHIFT,\r\nPAGE_SIZE, vma->vm_page_prot)) {\r\nprintk(KERN_ERR "remap_pfn_range failed in mmtimer.c\n");\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sgi_clock_get(clockid_t clockid, struct timespec *tp)\r\n{\r\nu64 nsec;\r\nnsec = rtc_time() * sgi_clock_period\r\n+ sgi_clock_offset.tv_nsec;\r\n*tp = ns_to_timespec(nsec);\r\ntp->tv_sec += sgi_clock_offset.tv_sec;\r\nreturn 0;\r\n}\r\nstatic int sgi_clock_set(const clockid_t clockid, const struct timespec *tp)\r\n{\r\nu64 nsec;\r\nu32 rem;\r\nnsec = rtc_time() * sgi_clock_period;\r\nsgi_clock_offset.tv_sec = tp->tv_sec - div_u64_rem(nsec, NSEC_PER_SEC, &rem);\r\nif (rem <= tp->tv_nsec)\r\nsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\r\nelse {\r\nsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;\r\nsgi_clock_offset.tv_sec--;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t\r\nmmtimer_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned long expires = 0;\r\nint result = IRQ_NONE;\r\nunsigned indx = cpu_to_node(smp_processor_id());\r\nstruct mmtimer *base;\r\nspin_lock(&timers[indx].lock);\r\nbase = rb_entry(timers[indx].next, struct mmtimer, list);\r\nif (base == NULL) {\r\nspin_unlock(&timers[indx].lock);\r\nreturn result;\r\n}\r\nif (base->cpu == smp_processor_id()) {\r\nif (base->timer)\r\nexpires = base->timer->it.mmtimer.expires;\r\nif ((mmtimer_int_pending(COMPARATOR) > 0) ||\r\n(expires && (expires <= rtc_time()))) {\r\nmmtimer_clr_int_pending(COMPARATOR);\r\ntasklet_schedule(&timers[indx].tasklet);\r\nresult = IRQ_HANDLED;\r\n}\r\n}\r\nspin_unlock(&timers[indx].lock);\r\nreturn result;\r\n}\r\nstatic void mmtimer_tasklet(unsigned long data)\r\n{\r\nint nodeid = data;\r\nstruct mmtimer_node *mn = &timers[nodeid];\r\nstruct mmtimer *x;\r\nstruct k_itimer *t;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mn->lock, flags);\r\nif (!mn->next)\r\ngoto out;\r\nx = rb_entry(mn->next, struct mmtimer, list);\r\nt = x->timer;\r\nif (t->it.mmtimer.clock == TIMER_OFF)\r\ngoto out;\r\nt->it_overrun = 0;\r\nmn->next = rb_next(&x->list);\r\nrb_erase(&x->list, &mn->timer_head);\r\nif (posix_timer_event(t, 0) != 0)\r\nt->it_overrun++;\r\nif(t->it.mmtimer.incr) {\r\nt->it.mmtimer.expires += t->it.mmtimer.incr;\r\nmmtimer_add_list(x);\r\n} else {\r\nt->it.mmtimer.clock = TIMER_OFF;\r\nt->it.mmtimer.expires = 0;\r\nkfree(x);\r\n}\r\nmmtimer_set_next_timer(nodeid);\r\nt->it_overrun_last = t->it_overrun;\r\nout:\r\nspin_unlock_irqrestore(&mn->lock, flags);\r\n}\r\nstatic int sgi_timer_create(struct k_itimer *timer)\r\n{\r\ntimer->it.mmtimer.clock = TIMER_OFF;\r\nreturn 0;\r\n}\r\nstatic int sgi_timer_del(struct k_itimer *timr)\r\n{\r\ncnodeid_t nodeid = timr->it.mmtimer.node;\r\nunsigned long irqflags;\r\nspin_lock_irqsave(&timers[nodeid].lock, irqflags);\r\nif (timr->it.mmtimer.clock != TIMER_OFF) {\r\nunsigned long expires = timr->it.mmtimer.expires;\r\nstruct rb_node *n = timers[nodeid].timer_head.rb_node;\r\nstruct mmtimer *uninitialized_var(t);\r\nint r = 0;\r\ntimr->it.mmtimer.clock = TIMER_OFF;\r\ntimr->it.mmtimer.expires = 0;\r\nwhile (n) {\r\nt = rb_entry(n, struct mmtimer, list);\r\nif (t->timer == timr)\r\nbreak;\r\nif (expires < t->timer->it.mmtimer.expires)\r\nn = n->rb_left;\r\nelse\r\nn = n->rb_right;\r\n}\r\nif (!n) {\r\nspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\r\nreturn 0;\r\n}\r\nif (timers[nodeid].next == n) {\r\ntimers[nodeid].next = rb_next(n);\r\nr = 1;\r\n}\r\nrb_erase(n, &timers[nodeid].timer_head);\r\nkfree(t);\r\nif (r) {\r\nmmtimer_disable_int(cnodeid_to_nasid(nodeid),\r\nCOMPARATOR);\r\nmmtimer_set_next_timer(nodeid);\r\n}\r\n}\r\nspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\r\nreturn 0;\r\n}\r\nstatic void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\r\n{\r\nif (timr->it.mmtimer.clock == TIMER_OFF) {\r\ncur_setting->it_interval.tv_nsec = 0;\r\ncur_setting->it_interval.tv_sec = 0;\r\ncur_setting->it_value.tv_nsec = 0;\r\ncur_setting->it_value.tv_sec =0;\r\nreturn;\r\n}\r\ncur_setting->it_interval = ns_to_timespec(timr->it.mmtimer.incr * sgi_clock_period);\r\ncur_setting->it_value = ns_to_timespec((timr->it.mmtimer.expires - rtc_time()) * sgi_clock_period);\r\n}\r\nstatic int sgi_timer_set(struct k_itimer *timr, int flags,\r\nstruct itimerspec * new_setting,\r\nstruct itimerspec * old_setting)\r\n{\r\nunsigned long when, period, irqflags;\r\nint err = 0;\r\ncnodeid_t nodeid;\r\nstruct mmtimer *base;\r\nstruct rb_node *n;\r\nif (old_setting)\r\nsgi_timer_get(timr, old_setting);\r\nsgi_timer_del(timr);\r\nwhen = timespec_to_ns(&new_setting->it_value);\r\nperiod = timespec_to_ns(&new_setting->it_interval);\r\nif (when == 0)\r\nreturn 0;\r\nbase = kmalloc(sizeof(struct mmtimer), GFP_KERNEL);\r\nif (base == NULL)\r\nreturn -ENOMEM;\r\nif (flags & TIMER_ABSTIME) {\r\nstruct timespec n;\r\nunsigned long now;\r\ngetnstimeofday(&n);\r\nnow = timespec_to_ns(&n);\r\nif (when > now)\r\nwhen -= now;\r\nelse\r\nwhen = 0;\r\n}\r\nwhen = (when + sgi_clock_period - 1) / sgi_clock_period + rtc_time();\r\nperiod = (period + sgi_clock_period - 1) / sgi_clock_period;\r\npreempt_disable();\r\nnodeid = cpu_to_node(smp_processor_id());\r\nspin_lock_irqsave(&timers[nodeid].lock, irqflags);\r\nbase->timer = timr;\r\nbase->cpu = smp_processor_id();\r\ntimr->it.mmtimer.clock = TIMER_SET;\r\ntimr->it.mmtimer.node = nodeid;\r\ntimr->it.mmtimer.incr = period;\r\ntimr->it.mmtimer.expires = when;\r\nn = timers[nodeid].next;\r\nmmtimer_add_list(base);\r\nif (timers[nodeid].next == n) {\r\nspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\r\npreempt_enable();\r\nreturn err;\r\n}\r\nif (n)\r\nmmtimer_disable_int(cnodeid_to_nasid(nodeid), COMPARATOR);\r\nmmtimer_set_next_timer(nodeid);\r\nspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\r\npreempt_enable();\r\nreturn err;\r\n}\r\nstatic int sgi_clock_getres(const clockid_t which_clock, struct timespec *tp)\r\n{\r\ntp->tv_sec = 0;\r\ntp->tv_nsec = sgi_clock_period;\r\nreturn 0;\r\n}\r\nstatic int __init mmtimer_init(void)\r\n{\r\ncnodeid_t node, maxn = -1;\r\nif (!ia64_platform_is("sn2"))\r\nreturn 0;\r\nif (sn_rtc_cycles_per_second < 100000) {\r\nprintk(KERN_ERR "%s: unable to determine clock frequency\n",\r\nMMTIMER_NAME);\r\ngoto out1;\r\n}\r\nmmtimer_femtoperiod = ((unsigned long)1E15 + sn_rtc_cycles_per_second /\r\n2) / sn_rtc_cycles_per_second;\r\nif (request_irq(SGI_MMTIMER_VECTOR, mmtimer_interrupt, IRQF_PERCPU, MMTIMER_NAME, NULL)) {\r\nprintk(KERN_WARNING "%s: unable to allocate interrupt.",\r\nMMTIMER_NAME);\r\ngoto out1;\r\n}\r\nif (misc_register(&mmtimer_miscdev)) {\r\nprintk(KERN_ERR "%s: failed to register device\n",\r\nMMTIMER_NAME);\r\ngoto out2;\r\n}\r\nfor_each_online_node(node) {\r\nmaxn = node;\r\n}\r\nmaxn++;\r\ntimers = kzalloc(sizeof(struct mmtimer_node)*maxn, GFP_KERNEL);\r\nif (!timers) {\r\nprintk(KERN_ERR "%s: failed to allocate memory for device\n",\r\nMMTIMER_NAME);\r\ngoto out3;\r\n}\r\nfor_each_online_node(node) {\r\nspin_lock_init(&timers[node].lock);\r\ntasklet_init(&timers[node].tasklet, mmtimer_tasklet,\r\n(unsigned long) node);\r\n}\r\nsgi_clock_period = NSEC_PER_SEC / sn_rtc_cycles_per_second;\r\nposix_timers_register_clock(CLOCK_SGI_CYCLE, &sgi_clock);\r\nprintk(KERN_INFO "%s: v%s, %ld MHz\n", MMTIMER_DESC, MMTIMER_VERSION,\r\nsn_rtc_cycles_per_second/(unsigned long)1E6);\r\nreturn 0;\r\nout3:\r\nmisc_deregister(&mmtimer_miscdev);\r\nout2:\r\nfree_irq(SGI_MMTIMER_VECTOR, NULL);\r\nout1:\r\nreturn -1;\r\n}
