static int\r\nqcaspi_info_show(struct seq_file *s, void *what)\r\n{\r\nstruct qcaspi *qca = s->private;\r\nseq_printf(s, "RX buffer size : %lu\n",\r\n(unsigned long)qca->buffer_size);\r\nseq_puts(s, "TX ring state : ");\r\nif (qca->txr.skb[qca->txr.head] == NULL)\r\nseq_puts(s, "empty");\r\nelse if (qca->txr.skb[qca->txr.tail])\r\nseq_puts(s, "full");\r\nelse\r\nseq_puts(s, "in use");\r\nseq_puts(s, "\n");\r\nseq_printf(s, "TX ring size : %u\n",\r\nqca->txr.size);\r\nseq_printf(s, "Sync state : %u (",\r\n(unsigned int)qca->sync);\r\nswitch (qca->sync) {\r\ncase QCASPI_SYNC_UNKNOWN:\r\nseq_puts(s, "QCASPI_SYNC_UNKNOWN");\r\nbreak;\r\ncase QCASPI_SYNC_RESET:\r\nseq_puts(s, "QCASPI_SYNC_RESET");\r\nbreak;\r\ncase QCASPI_SYNC_READY:\r\nseq_puts(s, "QCASPI_SYNC_READY");\r\nbreak;\r\ndefault:\r\nseq_puts(s, "INVALID");\r\nbreak;\r\n}\r\nseq_puts(s, ")\n");\r\nseq_printf(s, "IRQ : %d\n",\r\nqca->spi_dev->irq);\r\nseq_printf(s, "INTR REQ : %u\n",\r\nqca->intr_req);\r\nseq_printf(s, "INTR SVC : %u\n",\r\nqca->intr_svc);\r\nseq_printf(s, "SPI max speed : %lu\n",\r\n(unsigned long)qca->spi_dev->max_speed_hz);\r\nseq_printf(s, "SPI mode : %x\n",\r\nqca->spi_dev->mode);\r\nseq_printf(s, "SPI chip select : %u\n",\r\n(unsigned int)qca->spi_dev->chip_select);\r\nseq_printf(s, "SPI legacy mode : %u\n",\r\n(unsigned int)qca->legacy_mode);\r\nseq_printf(s, "SPI burst length : %u\n",\r\n(unsigned int)qca->burst_len);\r\nreturn 0;\r\n}\r\nstatic int\r\nqcaspi_info_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, qcaspi_info_show, inode->i_private);\r\n}\r\nvoid\r\nqcaspi_init_device_debugfs(struct qcaspi *qca)\r\n{\r\nstruct dentry *device_root;\r\ndevice_root = debugfs_create_dir(dev_name(&qca->net_dev->dev), NULL);\r\nqca->device_root = device_root;\r\nif (IS_ERR(device_root) || !device_root) {\r\npr_warn("failed to create debugfs directory for %s\n",\r\ndev_name(&qca->net_dev->dev));\r\nreturn;\r\n}\r\ndebugfs_create_file("info", S_IFREG | S_IRUGO, device_root, qca,\r\n&qcaspi_info_ops);\r\n}\r\nvoid\r\nqcaspi_remove_device_debugfs(struct qcaspi *qca)\r\n{\r\ndebugfs_remove_recursive(qca->device_root);\r\n}\r\nvoid\r\nqcaspi_init_device_debugfs(struct qcaspi *qca)\r\n{\r\n}\r\nvoid\r\nqcaspi_remove_device_debugfs(struct qcaspi *qca)\r\n{\r\n}\r\nstatic void\r\nqcaspi_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *p)\r\n{\r\nstruct qcaspi *qca = netdev_priv(dev);\r\nstrlcpy(p->driver, QCASPI_DRV_NAME, sizeof(p->driver));\r\nstrlcpy(p->version, QCASPI_DRV_VERSION, sizeof(p->version));\r\nstrlcpy(p->fw_version, "QCA7000", sizeof(p->fw_version));\r\nstrlcpy(p->bus_info, dev_name(&qca->spi_dev->dev),\r\nsizeof(p->bus_info));\r\n}\r\nstatic int\r\nqcaspi_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\ncmd->transceiver = XCVR_INTERNAL;\r\ncmd->supported = SUPPORTED_10baseT_Half;\r\nethtool_cmd_speed_set(cmd, SPEED_10);\r\ncmd->duplex = DUPLEX_HALF;\r\ncmd->port = PORT_OTHER;\r\ncmd->autoneg = AUTONEG_DISABLE;\r\nreturn 0;\r\n}\r\nstatic void\r\nqcaspi_get_ethtool_stats(struct net_device *dev, struct ethtool_stats *estats, u64 *data)\r\n{\r\nstruct qcaspi *qca = netdev_priv(dev);\r\nstruct qcaspi_stats *st = &qca->stats;\r\nmemcpy(data, st, ARRAY_SIZE(qcaspi_gstrings_stats) * sizeof(u64));\r\n}\r\nstatic void\r\nqcaspi_get_strings(struct net_device *dev, u32 stringset, u8 *buf)\r\n{\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nmemcpy(buf, &qcaspi_gstrings_stats,\r\nsizeof(qcaspi_gstrings_stats));\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nqcaspi_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn ARRAY_SIZE(qcaspi_gstrings_stats);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int\r\nqcaspi_get_regs_len(struct net_device *dev)\r\n{\r\nreturn sizeof(u32) * QCASPI_MAX_REGS;\r\n}\r\nstatic void\r\nqcaspi_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *p)\r\n{\r\nstruct qcaspi *qca = netdev_priv(dev);\r\nu32 *regs_buff = p;\r\nunsigned int i;\r\nregs->version = 1;\r\nmemset(regs_buff, 0, sizeof(u32) * QCASPI_MAX_REGS);\r\nfor (i = 0; i < ARRAY_SIZE(qcaspi_spi_regs); i++) {\r\nu16 offset, value;\r\nqcaspi_read_register(qca, qcaspi_spi_regs[i], &value);\r\noffset = qcaspi_spi_regs[i] >> 8;\r\nregs_buff[offset] = value;\r\n}\r\n}\r\nstatic void\r\nqcaspi_get_ringparam(struct net_device *dev, struct ethtool_ringparam *ring)\r\n{\r\nstruct qcaspi *qca = netdev_priv(dev);\r\nring->rx_max_pending = 4;\r\nring->tx_max_pending = TX_RING_MAX_LEN;\r\nring->rx_pending = 4;\r\nring->tx_pending = qca->txr.count;\r\n}\r\nstatic int\r\nqcaspi_set_ringparam(struct net_device *dev, struct ethtool_ringparam *ring)\r\n{\r\nstruct qcaspi *qca = netdev_priv(dev);\r\nif ((ring->rx_pending) ||\r\n(ring->rx_mini_pending) ||\r\n(ring->rx_jumbo_pending))\r\nreturn -EINVAL;\r\nif (netif_running(dev))\r\nqcaspi_netdev_close(dev);\r\nqca->txr.count = max_t(u32, ring->tx_pending, TX_RING_MIN_LEN);\r\nqca->txr.count = min_t(u16, qca->txr.count, TX_RING_MAX_LEN);\r\nif (netif_running(dev))\r\nqcaspi_netdev_open(dev);\r\nreturn 0;\r\n}\r\nvoid qcaspi_set_ethtool_ops(struct net_device *dev)\r\n{\r\ndev->ethtool_ops = &qcaspi_ethtool_ops;\r\n}
