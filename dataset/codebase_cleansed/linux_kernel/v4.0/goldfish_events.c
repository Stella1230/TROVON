static irqreturn_t events_interrupt(int irq, void *dev_id)\r\n{\r\nstruct event_dev *edev = dev_id;\r\nunsigned type, code, value;\r\ntype = __raw_readl(edev->addr + REG_READ);\r\ncode = __raw_readl(edev->addr + REG_READ);\r\nvalue = __raw_readl(edev->addr + REG_READ);\r\ninput_event(edev->input, type, code, value);\r\ninput_sync(edev->input);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void events_import_bits(struct event_dev *edev,\r\nunsigned long bits[], unsigned type, size_t count)\r\n{\r\nvoid __iomem *addr = edev->addr;\r\nint i, j;\r\nsize_t size;\r\nuint8_t val;\r\n__raw_writel(PAGE_EVBITS | type, addr + REG_SET_PAGE);\r\nsize = __raw_readl(addr + REG_LEN) * 8;\r\nif (size < count)\r\ncount = size;\r\naddr += REG_DATA;\r\nfor (i = 0; i < count; i += 8) {\r\nval = __raw_readb(addr++);\r\nfor (j = 0; j < 8; j++)\r\nif (val & 1 << j)\r\nset_bit(i + j, bits);\r\n}\r\n}\r\nstatic void events_import_abs_params(struct event_dev *edev)\r\n{\r\nstruct input_dev *input_dev = edev->input;\r\nvoid __iomem *addr = edev->addr;\r\nu32 val[4];\r\nint count;\r\nint i, j;\r\n__raw_writel(PAGE_ABSDATA, addr + REG_SET_PAGE);\r\ncount = __raw_readl(addr + REG_LEN) / sizeof(val);\r\nif (count > ABS_MAX)\r\ncount = ABS_MAX;\r\nfor (i = 0; i < count; i++) {\r\nif (!test_bit(i, input_dev->absbit))\r\ncontinue;\r\nfor (j = 0; j < ARRAY_SIZE(val); j++) {\r\nint offset = (i * ARRAY_SIZE(val) + j) * sizeof(u32);\r\nval[j] = __raw_readl(edev->addr + REG_DATA + offset);\r\n}\r\ninput_set_abs_params(input_dev, i,\r\nval[0], val[1], val[2], val[3]);\r\n}\r\n}\r\nstatic int events_probe(struct platform_device *pdev)\r\n{\r\nstruct input_dev *input_dev;\r\nstruct event_dev *edev;\r\nstruct resource *res;\r\nunsigned keymapnamelen;\r\nvoid __iomem *addr;\r\nint irq;\r\nint i;\r\nint error;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn -EINVAL;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -EINVAL;\r\naddr = devm_ioremap(&pdev->dev, res->start, 4096);\r\nif (!addr)\r\nreturn -ENOMEM;\r\n__raw_writel(PAGE_NAME, addr + REG_SET_PAGE);\r\nkeymapnamelen = __raw_readl(addr + REG_LEN);\r\nedev = devm_kzalloc(&pdev->dev,\r\nsizeof(struct event_dev) + keymapnamelen + 1,\r\nGFP_KERNEL);\r\nif (!edev)\r\nreturn -ENOMEM;\r\ninput_dev = devm_input_allocate_device(&pdev->dev);\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\nedev->input = input_dev;\r\nedev->addr = addr;\r\nedev->irq = irq;\r\nfor (i = 0; i < keymapnamelen; i++)\r\nedev->name[i] = __raw_readb(edev->addr + REG_DATA + i);\r\npr_debug("events_probe() keymap=%s\n", edev->name);\r\ninput_dev->name = edev->name;\r\ninput_dev->id.bustype = BUS_HOST;\r\nevents_import_bits(edev, input_dev->evbit, EV_SYN, EV_MAX);\r\nevents_import_bits(edev, input_dev->keybit, EV_KEY, KEY_MAX);\r\nevents_import_bits(edev, input_dev->relbit, EV_REL, REL_MAX);\r\nevents_import_bits(edev, input_dev->absbit, EV_ABS, ABS_MAX);\r\nevents_import_bits(edev, input_dev->mscbit, EV_MSC, MSC_MAX);\r\nevents_import_bits(edev, input_dev->ledbit, EV_LED, LED_MAX);\r\nevents_import_bits(edev, input_dev->sndbit, EV_SND, SND_MAX);\r\nevents_import_bits(edev, input_dev->ffbit, EV_FF, FF_MAX);\r\nevents_import_bits(edev, input_dev->swbit, EV_SW, SW_MAX);\r\nevents_import_abs_params(edev);\r\nerror = devm_request_irq(&pdev->dev, edev->irq, events_interrupt, 0,\r\n"goldfish-events-keypad", edev);\r\nif (error)\r\nreturn error;\r\nerror = input_register_device(input_dev);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}
