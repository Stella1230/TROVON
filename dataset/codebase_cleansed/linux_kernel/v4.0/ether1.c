static inline unsigned short\r\nether1_inw_p (struct net_device *dev, int addr, int svflgs)\r\n{\r\nunsigned long flags;\r\nunsigned short ret;\r\nif (svflgs)\r\nlocal_irq_save (flags);\r\nwriteb(addr >> 12, REG_PAGE);\r\nret = readw(ETHER1_RAM + ((addr & 4095) << 1));\r\nif (svflgs)\r\nlocal_irq_restore (flags);\r\nreturn ret;\r\n}\r\nstatic inline void\r\nether1_outw_p (struct net_device *dev, unsigned short val, int addr, int svflgs)\r\n{\r\nunsigned long flags;\r\nif (svflgs)\r\nlocal_irq_save (flags);\r\nwriteb(addr >> 12, REG_PAGE);\r\nwritew(val, ETHER1_RAM + ((addr & 4095) << 1));\r\nif (svflgs)\r\nlocal_irq_restore (flags);\r\n}\r\nstatic void\r\nether1_writebuffer (struct net_device *dev, void *data, unsigned int start, unsigned int length)\r\n{\r\nunsigned int page, thislen, offset;\r\nvoid __iomem *addr;\r\noffset = start & 4095;\r\npage = start >> 12;\r\naddr = ETHER1_RAM + (offset << 1);\r\nif (offset + length > 4096)\r\nthislen = 4096 - offset;\r\nelse\r\nthislen = length;\r\ndo {\r\nint used;\r\nwriteb(page, REG_PAGE);\r\nlength -= thislen;\r\n__asm__ __volatile__(\r\n"subs %3, %3, #2\n\\r\nbmi 2f\n\\r\n1: ldr %0, [%1], #2\n\\r\nmov %0, %0, lsl #16\n\\r\norr %0, %0, %0, lsr #16\n\\r\nstr %0, [%2], #4\n\\r\nsubs %3, %3, #2\n\\r\nbmi 2f\n\\r\nldr %0, [%1], #2\n\\r\nmov %0, %0, lsl #16\n\\r\norr %0, %0, %0, lsr #16\n\\r\nstr %0, [%2], #4\n\\r\nsubs %3, %3, #2\n\\r\nbmi 2f\n\\r\nldr %0, [%1], #2\n\\r\nmov %0, %0, lsl #16\n\\r\norr %0, %0, %0, lsr #16\n\\r\nstr %0, [%2], #4\n\\r\nsubs %3, %3, #2\n\\r\nbmi 2f\n\\r\nldr %0, [%1], #2\n\\r\nmov %0, %0, lsl #16\n\\r\norr %0, %0, %0, lsr #16\n\\r\nstr %0, [%2], #4\n\\r\nsubs %3, %3, #2\n\\r\nbpl 1b\n\\r\n2: adds %3, %3, #1\n\\r\nldreqb %0, [%1]\n\\r\nstreqb %0, [%2]"\r\n: "=&r" (used), "=&r" (data)\r\n: "r" (addr), "r" (thislen), "1" (data));\r\naddr = ETHER1_RAM;\r\nthislen = length;\r\nif (thislen > 4096)\r\nthislen = 4096;\r\npage++;\r\n} while (thislen);\r\n}\r\nstatic void\r\nether1_readbuffer (struct net_device *dev, void *data, unsigned int start, unsigned int length)\r\n{\r\nunsigned int page, thislen, offset;\r\nvoid __iomem *addr;\r\noffset = start & 4095;\r\npage = start >> 12;\r\naddr = ETHER1_RAM + (offset << 1);\r\nif (offset + length > 4096)\r\nthislen = 4096 - offset;\r\nelse\r\nthislen = length;\r\ndo {\r\nint used;\r\nwriteb(page, REG_PAGE);\r\nlength -= thislen;\r\n__asm__ __volatile__(\r\n"subs %3, %3, #2\n\\r\nbmi 2f\n\\r\n1: ldr %0, [%2], #4\n\\r\nstrb %0, [%1], #1\n\\r\nmov %0, %0, lsr #8\n\\r\nstrb %0, [%1], #1\n\\r\nsubs %3, %3, #2\n\\r\nbmi 2f\n\\r\nldr %0, [%2], #4\n\\r\nstrb %0, [%1], #1\n\\r\nmov %0, %0, lsr #8\n\\r\nstrb %0, [%1], #1\n\\r\nsubs %3, %3, #2\n\\r\nbmi 2f\n\\r\nldr %0, [%2], #4\n\\r\nstrb %0, [%1], #1\n\\r\nmov %0, %0, lsr #8\n\\r\nstrb %0, [%1], #1\n\\r\nsubs %3, %3, #2\n\\r\nbmi 2f\n\\r\nldr %0, [%2], #4\n\\r\nstrb %0, [%1], #1\n\\r\nmov %0, %0, lsr #8\n\\r\nstrb %0, [%1], #1\n\\r\nsubs %3, %3, #2\n\\r\nbpl 1b\n\\r\n2: adds %3, %3, #1\n\\r\nldreqb %0, [%2]\n\\r\nstreqb %0, [%1]"\r\n: "=&r" (used), "=&r" (data)\r\n: "r" (addr), "r" (thislen), "1" (data));\r\naddr = ETHER1_RAM;\r\nthislen = length;\r\nif (thislen > 4096)\r\nthislen = 4096;\r\npage++;\r\n} while (thislen);\r\n}\r\nstatic int\r\nether1_ramtest(struct net_device *dev, unsigned char byte)\r\n{\r\nunsigned char *buffer = kmalloc (BUFFER_SIZE, GFP_KERNEL);\r\nint i, ret = BUFFER_SIZE;\r\nint max_errors = 15;\r\nint bad = -1;\r\nint bad_start = 0;\r\nif (!buffer)\r\nreturn 1;\r\nmemset (buffer, byte, BUFFER_SIZE);\r\nether1_writebuffer (dev, buffer, 0, BUFFER_SIZE);\r\nmemset (buffer, byte ^ 0xff, BUFFER_SIZE);\r\nether1_readbuffer (dev, buffer, 0, BUFFER_SIZE);\r\nfor (i = 0; i < BUFFER_SIZE; i++) {\r\nif (buffer[i] != byte) {\r\nif (max_errors >= 0 && bad != buffer[i]) {\r\nif (bad != -1)\r\nprintk ("\n");\r\nprintk (KERN_CRIT "%s: RAM failed with (%02X instead of %02X) at 0x%04X",\r\ndev->name, buffer[i], byte, i);\r\nret = -ENODEV;\r\nmax_errors --;\r\nbad = buffer[i];\r\nbad_start = i;\r\n}\r\n} else {\r\nif (bad != -1) {\r\nif (bad_start == i - 1)\r\nprintk ("\n");\r\nelse\r\nprintk (" - 0x%04X\n", i - 1);\r\nbad = -1;\r\n}\r\n}\r\n}\r\nif (bad != -1)\r\nprintk (" - 0x%04X\n", BUFFER_SIZE);\r\nkfree (buffer);\r\nreturn ret;\r\n}\r\nstatic int\r\nether1_reset (struct net_device *dev)\r\n{\r\nwriteb(CTRL_RST|CTRL_ACK, REG_CONTROL);\r\nreturn BUS_16;\r\n}\r\nstatic int\r\nether1_init_2(struct net_device *dev)\r\n{\r\nint i;\r\ndev->mem_start = 0;\r\ni = ether1_ramtest (dev, 0x5a);\r\nif (i > 0)\r\ni = ether1_ramtest (dev, 0x1e);\r\nif (i <= 0)\r\nreturn -ENODEV;\r\ndev->mem_end = i;\r\nreturn 0;\r\n}\r\nstatic int\r\nether1_init_for_open (struct net_device *dev)\r\n{\r\nint i, status, addr, next, next2;\r\nint failures = 0;\r\nunsigned long timeout;\r\nwriteb(CTRL_RST|CTRL_ACK, REG_CONTROL);\r\nfor (i = 0; i < 6; i++)\r\ninit_sa.sa_addr[i] = dev->dev_addr[i];\r\nether1_writebuffer (dev, &init_scp, SCP_ADDR, SCP_SIZE);\r\nether1_writebuffer (dev, &init_iscp, ISCP_ADDR, ISCP_SIZE);\r\nether1_writebuffer (dev, &init_scb, SCB_ADDR, SCB_SIZE);\r\nether1_writebuffer (dev, &init_cfg, CFG_ADDR, CFG_SIZE);\r\nether1_writebuffer (dev, &init_sa, SA_ADDR, SA_SIZE);\r\nether1_writebuffer (dev, &init_mc, MC_ADDR, MC_SIZE);\r\nether1_writebuffer (dev, &init_tdr, TDR_ADDR, TDR_SIZE);\r\nether1_writebuffer (dev, &init_nop, NOP_ADDR, NOP_SIZE);\r\nif (ether1_readw(dev, CFG_ADDR, cfg_t, cfg_command, NORMALIRQS) != CMD_CONFIG) {\r\nprintk (KERN_ERR "%s: detected either RAM fault or compiler bug\n",\r\ndev->name);\r\nreturn 1;\r\n}\r\naddr = RX_AREA_START;\r\ndo {\r\nnext = addr + RFD_SIZE + RBD_SIZE + ETH_FRAME_LEN + 10;\r\nnext2 = next + RFD_SIZE + RBD_SIZE + ETH_FRAME_LEN + 10;\r\nif (next2 >= RX_AREA_END) {\r\nnext = RX_AREA_START;\r\ninit_rfd.rfd_command = RFD_CMDEL | RFD_CMDSUSPEND;\r\npriv(dev)->rx_tail = addr;\r\n} else\r\ninit_rfd.rfd_command = 0;\r\nif (addr == RX_AREA_START)\r\ninit_rfd.rfd_rbdoffset = addr + RFD_SIZE;\r\nelse\r\ninit_rfd.rfd_rbdoffset = 0;\r\ninit_rfd.rfd_link = next;\r\ninit_rbd.rbd_link = next + RFD_SIZE;\r\ninit_rbd.rbd_bufl = addr + RFD_SIZE + RBD_SIZE;\r\nether1_writebuffer (dev, &init_rfd, addr, RFD_SIZE);\r\nether1_writebuffer (dev, &init_rbd, addr + RFD_SIZE, RBD_SIZE);\r\naddr = next;\r\n} while (next2 < RX_AREA_END);\r\npriv(dev)->tx_link = NOP_ADDR;\r\npriv(dev)->tx_head = NOP_ADDR + NOP_SIZE;\r\npriv(dev)->tx_tail = TDR_ADDR;\r\npriv(dev)->rx_head = RX_AREA_START;\r\npriv(dev)->resetting = 1;\r\npriv(dev)->initialising = 1;\r\nwriteb(CTRL_RST, REG_CONTROL);\r\nwriteb(0, REG_CONTROL);\r\nwriteb(CTRL_CA, REG_CONTROL);\r\ntimeout = jiffies + HZ/2;\r\nwhile (ether1_readw(dev, ISCP_ADDR, iscp_t, iscp_busy, DISABLEIRQS) == 1) {\r\nif (time_after(jiffies, timeout)) {\r\nprintk (KERN_WARNING "%s: can't initialise 82586: iscp is busy\n", dev->name);\r\nreturn 1;\r\n}\r\n}\r\ntimeout += HZ/10;\r\nwhile (((status = ether1_readw(dev, CFG_ADDR, cfg_t, cfg_status, DISABLEIRQS))\r\n& STAT_COMPLETE) == 0) {\r\nif (time_after(jiffies, timeout))\r\nbreak;\r\n}\r\nif ((status & (STAT_COMPLETE | STAT_OK)) != (STAT_COMPLETE | STAT_OK)) {\r\nprintk (KERN_WARNING "%s: can't initialise 82586: config status %04X\n", dev->name, status);\r\nprintk (KERN_DEBUG "%s: SCB=[STS=%04X CMD=%04X CBL=%04X RFA=%04X]\n", dev->name,\r\nether1_readw(dev, SCB_ADDR, scb_t, scb_status, NORMALIRQS),\r\nether1_readw(dev, SCB_ADDR, scb_t, scb_command, NORMALIRQS),\r\nether1_readw(dev, SCB_ADDR, scb_t, scb_cbl_offset, NORMALIRQS),\r\nether1_readw(dev, SCB_ADDR, scb_t, scb_rfa_offset, NORMALIRQS));\r\nfailures += 1;\r\n}\r\ntimeout += HZ/10;\r\nwhile (((status = ether1_readw(dev, SA_ADDR, sa_t, sa_status, DISABLEIRQS))\r\n& STAT_COMPLETE) == 0) {\r\nif (time_after(jiffies, timeout))\r\nbreak;\r\n}\r\nif ((status & (STAT_COMPLETE | STAT_OK)) != (STAT_COMPLETE | STAT_OK)) {\r\nprintk (KERN_WARNING "%s: can't initialise 82586: set address status %04X\n", dev->name, status);\r\nprintk (KERN_DEBUG "%s: SCB=[STS=%04X CMD=%04X CBL=%04X RFA=%04X]\n", dev->name,\r\nether1_readw(dev, SCB_ADDR, scb_t, scb_status, NORMALIRQS),\r\nether1_readw(dev, SCB_ADDR, scb_t, scb_command, NORMALIRQS),\r\nether1_readw(dev, SCB_ADDR, scb_t, scb_cbl_offset, NORMALIRQS),\r\nether1_readw(dev, SCB_ADDR, scb_t, scb_rfa_offset, NORMALIRQS));\r\nfailures += 1;\r\n}\r\ntimeout += HZ/10;\r\nwhile (((status = ether1_readw(dev, MC_ADDR, mc_t, mc_status, DISABLEIRQS))\r\n& STAT_COMPLETE) == 0) {\r\nif (time_after(jiffies, timeout))\r\nbreak;\r\n}\r\nif ((status & (STAT_COMPLETE | STAT_OK)) != (STAT_COMPLETE | STAT_OK)) {\r\nprintk (KERN_WARNING "%s: can't initialise 82586: set multicast status %04X\n", dev->name, status);\r\nprintk (KERN_DEBUG "%s: SCB=[STS=%04X CMD=%04X CBL=%04X RFA=%04X]\n", dev->name,\r\nether1_readw(dev, SCB_ADDR, scb_t, scb_status, NORMALIRQS),\r\nether1_readw(dev, SCB_ADDR, scb_t, scb_command, NORMALIRQS),\r\nether1_readw(dev, SCB_ADDR, scb_t, scb_cbl_offset, NORMALIRQS),\r\nether1_readw(dev, SCB_ADDR, scb_t, scb_rfa_offset, NORMALIRQS));\r\nfailures += 1;\r\n}\r\ntimeout += HZ;\r\nwhile (((status = ether1_readw(dev, TDR_ADDR, tdr_t, tdr_status, DISABLEIRQS))\r\n& STAT_COMPLETE) == 0) {\r\nif (time_after(jiffies, timeout))\r\nbreak;\r\n}\r\nif ((status & (STAT_COMPLETE | STAT_OK)) != (STAT_COMPLETE | STAT_OK)) {\r\nprintk (KERN_WARNING "%s: can't tdr (ignored)\n", dev->name);\r\nprintk (KERN_DEBUG "%s: SCB=[STS=%04X CMD=%04X CBL=%04X RFA=%04X]\n", dev->name,\r\nether1_readw(dev, SCB_ADDR, scb_t, scb_status, NORMALIRQS),\r\nether1_readw(dev, SCB_ADDR, scb_t, scb_command, NORMALIRQS),\r\nether1_readw(dev, SCB_ADDR, scb_t, scb_cbl_offset, NORMALIRQS),\r\nether1_readw(dev, SCB_ADDR, scb_t, scb_rfa_offset, NORMALIRQS));\r\n} else {\r\nstatus = ether1_readw(dev, TDR_ADDR, tdr_t, tdr_result, DISABLEIRQS);\r\nif (status & TDR_XCVRPROB)\r\nprintk (KERN_WARNING "%s: i/f failed tdr: transceiver problem\n", dev->name);\r\nelse if ((status & (TDR_SHORT|TDR_OPEN)) && (status & TDR_TIME)) {\r\n#ifdef FANCY\r\nprintk (KERN_WARNING "%s: i/f failed tdr: cable %s %d.%d us away\n", dev->name,\r\nstatus & TDR_SHORT ? "short" : "open", (status & TDR_TIME) / 10,\r\n(status & TDR_TIME) % 10);\r\n#else\r\nprintk (KERN_WARNING "%s: i/f failed tdr: cable %s %d clks away\n", dev->name,\r\nstatus & TDR_SHORT ? "short" : "open", (status & TDR_TIME));\r\n#endif\r\n}\r\n}\r\nif (failures)\r\nether1_reset (dev);\r\nreturn failures ? 1 : 0;\r\n}\r\nstatic int\r\nether1_txalloc (struct net_device *dev, int size)\r\n{\r\nint start, tail;\r\nsize = (size + 1) & ~1;\r\ntail = priv(dev)->tx_tail;\r\nif (priv(dev)->tx_head + size > TX_AREA_END) {\r\nif (tail > priv(dev)->tx_head)\r\nreturn -1;\r\nstart = TX_AREA_START;\r\nif (start + size > tail)\r\nreturn -1;\r\npriv(dev)->tx_head = start + size;\r\n} else {\r\nif (priv(dev)->tx_head < tail && (priv(dev)->tx_head + size) > tail)\r\nreturn -1;\r\nstart = priv(dev)->tx_head;\r\npriv(dev)->tx_head += size;\r\n}\r\nreturn start;\r\n}\r\nstatic int\r\nether1_open (struct net_device *dev)\r\n{\r\nif (request_irq(dev->irq, ether1_interrupt, 0, "ether1", dev))\r\nreturn -EAGAIN;\r\nif (ether1_init_for_open (dev)) {\r\nfree_irq (dev->irq, dev);\r\nreturn -EAGAIN;\r\n}\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void\r\nether1_timeout(struct net_device *dev)\r\n{\r\nprintk(KERN_WARNING "%s: transmit timeout, network cable problem?\n",\r\ndev->name);\r\nprintk(KERN_WARNING "%s: resetting device\n", dev->name);\r\nether1_reset (dev);\r\nif (ether1_init_for_open (dev))\r\nprintk (KERN_ERR "%s: unable to restart interface\n", dev->name);\r\ndev->stats.tx_errors++;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int\r\nether1_sendpacket (struct sk_buff *skb, struct net_device *dev)\r\n{\r\nint tmp, tst, nopaddr, txaddr, tbdaddr, dataddr;\r\nunsigned long flags;\r\ntx_t tx;\r\ntbd_t tbd;\r\nnop_t nop;\r\nif (priv(dev)->restart) {\r\nprintk(KERN_WARNING "%s: resetting device\n", dev->name);\r\nether1_reset(dev);\r\nif (ether1_init_for_open(dev))\r\nprintk(KERN_ERR "%s: unable to restart interface\n", dev->name);\r\nelse\r\npriv(dev)->restart = 0;\r\n}\r\nif (skb->len < ETH_ZLEN) {\r\nif (skb_padto(skb, ETH_ZLEN))\r\ngoto out;\r\n}\r\ntxaddr = ether1_txalloc (dev, TX_SIZE);\r\ntbdaddr = ether1_txalloc (dev, TBD_SIZE);\r\ndataddr = ether1_txalloc (dev, skb->len);\r\nnopaddr = ether1_txalloc (dev, NOP_SIZE);\r\ntx.tx_status = 0;\r\ntx.tx_command = CMD_TX | CMD_INTR;\r\ntx.tx_link = nopaddr;\r\ntx.tx_tbdoffset = tbdaddr;\r\ntbd.tbd_opts = TBD_EOL | skb->len;\r\ntbd.tbd_link = I82586_NULL;\r\ntbd.tbd_bufl = dataddr;\r\ntbd.tbd_bufh = 0;\r\nnop.nop_status = 0;\r\nnop.nop_command = CMD_NOP;\r\nnop.nop_link = nopaddr;\r\nlocal_irq_save(flags);\r\nether1_writebuffer (dev, &tx, txaddr, TX_SIZE);\r\nether1_writebuffer (dev, &tbd, tbdaddr, TBD_SIZE);\r\nether1_writebuffer (dev, skb->data, dataddr, skb->len);\r\nether1_writebuffer (dev, &nop, nopaddr, NOP_SIZE);\r\ntmp = priv(dev)->tx_link;\r\npriv(dev)->tx_link = nopaddr;\r\nether1_writew(dev, txaddr, tmp, nop_t, nop_link, NORMALIRQS);\r\nlocal_irq_restore(flags);\r\ntmp = priv(dev)->tx_head;\r\ntst = ether1_txalloc (dev, TX_SIZE + TBD_SIZE + NOP_SIZE + ETH_FRAME_LEN);\r\npriv(dev)->tx_head = tmp;\r\ndev_kfree_skb (skb);\r\nif (tst == -1)\r\nnetif_stop_queue(dev);\r\nout:\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void\r\nether1_xmit_done (struct net_device *dev)\r\n{\r\nnop_t nop;\r\nint caddr, tst;\r\ncaddr = priv(dev)->tx_tail;\r\nagain:\r\nether1_readbuffer (dev, &nop, caddr, NOP_SIZE);\r\nswitch (nop.nop_command & CMD_MASK) {\r\ncase CMD_TDR:\r\nif (ether1_readw(dev, SCB_ADDR, scb_t, scb_cbl_offset, NORMALIRQS)\r\n!= (unsigned short)I82586_NULL) {\r\nether1_writew(dev, SCB_CMDCUCSTART | SCB_CMDRXSTART, SCB_ADDR, scb_t,\r\nscb_command, NORMALIRQS);\r\nwriteb(CTRL_CA, REG_CONTROL);\r\n}\r\npriv(dev)->tx_tail = NOP_ADDR;\r\nreturn;\r\ncase CMD_NOP:\r\nif (nop.nop_link == caddr) {\r\nif (priv(dev)->initialising == 0)\r\nprintk (KERN_WARNING "%s: strange command complete with no tx command!\n", dev->name);\r\nelse\r\npriv(dev)->initialising = 0;\r\nreturn;\r\n}\r\nif (caddr == nop.nop_link)\r\nreturn;\r\ncaddr = nop.nop_link;\r\ngoto again;\r\ncase CMD_TX:\r\nif (nop.nop_status & STAT_COMPLETE)\r\nbreak;\r\nprintk (KERN_ERR "%s: strange command complete without completed command\n", dev->name);\r\npriv(dev)->restart = 1;\r\nreturn;\r\ndefault:\r\nprintk (KERN_WARNING "%s: strange command %d complete! (offset %04X)", dev->name,\r\nnop.nop_command & CMD_MASK, caddr);\r\npriv(dev)->restart = 1;\r\nreturn;\r\n}\r\nwhile (nop.nop_status & STAT_COMPLETE) {\r\nif (nop.nop_status & STAT_OK) {\r\ndev->stats.tx_packets++;\r\ndev->stats.collisions += (nop.nop_status & STAT_COLLISIONS);\r\n} else {\r\ndev->stats.tx_errors++;\r\nif (nop.nop_status & STAT_COLLAFTERTX)\r\ndev->stats.collisions++;\r\nif (nop.nop_status & STAT_NOCARRIER)\r\ndev->stats.tx_carrier_errors++;\r\nif (nop.nop_status & STAT_TXLOSTCTS)\r\nprintk (KERN_WARNING "%s: cts lost\n", dev->name);\r\nif (nop.nop_status & STAT_TXSLOWDMA)\r\ndev->stats.tx_fifo_errors++;\r\nif (nop.nop_status & STAT_COLLEXCESSIVE)\r\ndev->stats.collisions += 16;\r\n}\r\nif (nop.nop_link == caddr) {\r\nprintk (KERN_ERR "%s: tx buffer chaining error: tx command points to itself\n", dev->name);\r\nbreak;\r\n}\r\ncaddr = nop.nop_link;\r\nether1_readbuffer (dev, &nop, caddr, NOP_SIZE);\r\nif ((nop.nop_command & CMD_MASK) != CMD_NOP) {\r\nprintk (KERN_ERR "%s: tx buffer chaining error: no nop after tx command\n", dev->name);\r\nbreak;\r\n}\r\nif (caddr == nop.nop_link)\r\nbreak;\r\ncaddr = nop.nop_link;\r\nether1_readbuffer (dev, &nop, caddr, NOP_SIZE);\r\nif ((nop.nop_command & CMD_MASK) != CMD_TX) {\r\nprintk (KERN_ERR "%s: tx buffer chaining error: no tx command after nop\n", dev->name);\r\nbreak;\r\n}\r\n}\r\npriv(dev)->tx_tail = caddr;\r\ncaddr = priv(dev)->tx_head;\r\ntst = ether1_txalloc (dev, TX_SIZE + TBD_SIZE + NOP_SIZE + ETH_FRAME_LEN);\r\npriv(dev)->tx_head = caddr;\r\nif (tst != -1)\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void\r\nether1_recv_done (struct net_device *dev)\r\n{\r\nint status;\r\nint nexttail, rbdaddr;\r\nrbd_t rbd;\r\ndo {\r\nstatus = ether1_readw(dev, priv(dev)->rx_head, rfd_t, rfd_status, NORMALIRQS);\r\nif ((status & RFD_COMPLETE) == 0)\r\nbreak;\r\nrbdaddr = ether1_readw(dev, priv(dev)->rx_head, rfd_t, rfd_rbdoffset, NORMALIRQS);\r\nether1_readbuffer (dev, &rbd, rbdaddr, RBD_SIZE);\r\nif ((rbd.rbd_status & (RBD_EOF | RBD_ACNTVALID)) == (RBD_EOF | RBD_ACNTVALID)) {\r\nint length = rbd.rbd_status & RBD_ACNT;\r\nstruct sk_buff *skb;\r\nlength = (length + 1) & ~1;\r\nskb = netdev_alloc_skb(dev, length + 2);\r\nif (skb) {\r\nskb_reserve (skb, 2);\r\nether1_readbuffer (dev, skb_put (skb, length), rbd.rbd_bufl, length);\r\nskb->protocol = eth_type_trans (skb, dev);\r\nnetif_rx (skb);\r\ndev->stats.rx_packets++;\r\n} else\r\ndev->stats.rx_dropped++;\r\n} else {\r\nprintk(KERN_WARNING "%s: %s\n", dev->name,\r\n(rbd.rbd_status & RBD_EOF) ? "oversized packet" : "acnt not valid");\r\ndev->stats.rx_dropped++;\r\n}\r\nnexttail = ether1_readw(dev, priv(dev)->rx_tail, rfd_t, rfd_link, NORMALIRQS);\r\nif (nexttail != priv(dev)->rx_head)\r\nprintk(KERN_ERR "%s: receiver buffer chaining error (%04X != %04X)\n",\r\ndev->name, nexttail, priv(dev)->rx_head);\r\nether1_writew(dev, RFD_CMDEL | RFD_CMDSUSPEND, nexttail, rfd_t, rfd_command, NORMALIRQS);\r\nether1_writew(dev, 0, priv(dev)->rx_tail, rfd_t, rfd_command, NORMALIRQS);\r\nether1_writew(dev, 0, priv(dev)->rx_tail, rfd_t, rfd_status, NORMALIRQS);\r\nether1_writew(dev, 0, priv(dev)->rx_tail, rfd_t, rfd_rbdoffset, NORMALIRQS);\r\npriv(dev)->rx_tail = nexttail;\r\npriv(dev)->rx_head = ether1_readw(dev, priv(dev)->rx_head, rfd_t, rfd_link, NORMALIRQS);\r\n} while (1);\r\n}\r\nstatic irqreturn_t\r\nether1_interrupt (int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nint status;\r\nstatus = ether1_readw(dev, SCB_ADDR, scb_t, scb_status, NORMALIRQS);\r\nif (status) {\r\nether1_writew(dev, status & (SCB_STRNR | SCB_STCNA | SCB_STFR | SCB_STCX),\r\nSCB_ADDR, scb_t, scb_command, NORMALIRQS);\r\nwriteb(CTRL_CA | CTRL_ACK, REG_CONTROL);\r\nif (status & SCB_STCX) {\r\nether1_xmit_done (dev);\r\n}\r\nif (status & SCB_STCNA) {\r\nif (priv(dev)->resetting == 0)\r\nprintk (KERN_WARNING "%s: CU went not ready ???\n", dev->name);\r\nelse\r\npriv(dev)->resetting += 1;\r\nif (ether1_readw(dev, SCB_ADDR, scb_t, scb_cbl_offset, NORMALIRQS)\r\n!= (unsigned short)I82586_NULL) {\r\nether1_writew(dev, SCB_CMDCUCSTART, SCB_ADDR, scb_t, scb_command, NORMALIRQS);\r\nwriteb(CTRL_CA, REG_CONTROL);\r\n}\r\nif (priv(dev)->resetting == 2)\r\npriv(dev)->resetting = 0;\r\n}\r\nif (status & SCB_STFR) {\r\nether1_recv_done (dev);\r\n}\r\nif (status & SCB_STRNR) {\r\nif (ether1_readw(dev, SCB_ADDR, scb_t, scb_status, NORMALIRQS) & SCB_STRXSUSP) {\r\nprintk (KERN_WARNING "%s: RU went not ready: RU suspended\n", dev->name);\r\nether1_writew(dev, SCB_CMDRXRESUME, SCB_ADDR, scb_t, scb_command, NORMALIRQS);\r\nwriteb(CTRL_CA, REG_CONTROL);\r\ndev->stats.rx_dropped++;\r\n} else\r\nprintk(KERN_WARNING "%s: RU went not ready: %04X\n", dev->name,\r\nether1_readw(dev, SCB_ADDR, scb_t, scb_status, NORMALIRQS));\r\nprintk (KERN_WARNING "RU ptr = %04X\n", ether1_readw(dev, SCB_ADDR, scb_t, scb_rfa_offset,\r\nNORMALIRQS));\r\n}\r\n} else\r\nwriteb(CTRL_ACK, REG_CONTROL);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nether1_close (struct net_device *dev)\r\n{\r\nether1_reset (dev);\r\nfree_irq(dev->irq, dev);\r\nreturn 0;\r\n}\r\nstatic void\r\nether1_setmulticastlist (struct net_device *dev)\r\n{\r\n}\r\nstatic void ether1_banner(void)\r\n{\r\nstatic unsigned int version_printed = 0;\r\nif (net_debug && version_printed++ == 0)\r\nprintk(KERN_INFO "%s", version);\r\n}\r\nstatic int\r\nether1_probe(struct expansion_card *ec, const struct ecard_id *id)\r\n{\r\nstruct net_device *dev;\r\nint i, ret = 0;\r\nether1_banner();\r\nret = ecard_request_resources(ec);\r\nif (ret)\r\ngoto out;\r\ndev = alloc_etherdev(sizeof(struct ether1_priv));\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto release;\r\n}\r\nSET_NETDEV_DEV(dev, &ec->dev);\r\ndev->irq = ec->irq;\r\npriv(dev)->base = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);\r\nif (!priv(dev)->base) {\r\nret = -ENOMEM;\r\ngoto free;\r\n}\r\nif ((priv(dev)->bus_type = ether1_reset(dev)) == 0) {\r\nret = -ENODEV;\r\ngoto free;\r\n}\r\nfor (i = 0; i < 6; i++)\r\ndev->dev_addr[i] = readb(IDPROM_ADDRESS + (i << 2));\r\nif (ether1_init_2(dev)) {\r\nret = -ENODEV;\r\ngoto free;\r\n}\r\ndev->netdev_ops = &ether1_netdev_ops;\r\ndev->watchdog_timeo = 5 * HZ / 100;\r\nret = register_netdev(dev);\r\nif (ret)\r\ngoto free;\r\nprintk(KERN_INFO "%s: ether1 in slot %d, %pM\n",\r\ndev->name, ec->slot_no, dev->dev_addr);\r\necard_set_drvdata(ec, dev);\r\nreturn 0;\r\nfree:\r\nfree_netdev(dev);\r\nrelease:\r\necard_release_resources(ec);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void ether1_remove(struct expansion_card *ec)\r\n{\r\nstruct net_device *dev = ecard_get_drvdata(ec);\r\necard_set_drvdata(ec, NULL);\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\necard_release_resources(ec);\r\n}\r\nstatic int __init ether1_init(void)\r\n{\r\nreturn ecard_register_driver(&ether1_driver);\r\n}\r\nstatic void __exit ether1_exit(void)\r\n{\r\necard_remove_driver(&ether1_driver);\r\n}
