static inline int\r\ncompute_yday(efi_time_t *eft)\r\n{\r\nreturn __mon_yday[is_leap(eft->year)][eft->month-1]+ eft->day -1;\r\n}\r\nstatic int\r\ncompute_wday(efi_time_t *eft)\r\n{\r\nint y;\r\nint ndays = 0;\r\nif ( eft->year < 1998 ) {\r\nprintk(KERN_ERR "efirtc: EFI year < 1998, invalid date\n");\r\nreturn -1;\r\n}\r\nfor(y=EFI_RTC_EPOCH; y < eft->year; y++ ) {\r\nndays += 365 + (is_leap(y) ? 1 : 0);\r\n}\r\nndays += compute_yday(eft);\r\nreturn (ndays + 4) % 7;\r\n}\r\nstatic void\r\nconvert_to_efi_time(struct rtc_time *wtime, efi_time_t *eft)\r\n{\r\neft->year = wtime->tm_year + 1900;\r\neft->month = wtime->tm_mon + 1;\r\neft->day = wtime->tm_mday;\r\neft->hour = wtime->tm_hour;\r\neft->minute = wtime->tm_min;\r\neft->second = wtime->tm_sec;\r\neft->nanosecond = 0;\r\neft->daylight = wtime->tm_isdst ? EFI_ISDST: 0;\r\neft->timezone = EFI_UNSPECIFIED_TIMEZONE;\r\n}\r\nstatic void\r\nconvert_from_efi_time(efi_time_t *eft, struct rtc_time *wtime)\r\n{\r\nmemset(wtime, 0, sizeof(*wtime));\r\nwtime->tm_sec = eft->second;\r\nwtime->tm_min = eft->minute;\r\nwtime->tm_hour = eft->hour;\r\nwtime->tm_mday = eft->day;\r\nwtime->tm_mon = eft->month - 1;\r\nwtime->tm_year = eft->year - 1900;\r\nwtime->tm_wday = compute_wday(eft);\r\nwtime->tm_yday = compute_yday(eft);\r\nswitch (eft->daylight & EFI_ISDST) {\r\ncase EFI_ISDST:\r\nwtime->tm_isdst = 1;\r\nbreak;\r\ncase EFI_TIME_ADJUST_DAYLIGHT:\r\nwtime->tm_isdst = 0;\r\nbreak;\r\ndefault:\r\nwtime->tm_isdst = -1;\r\n}\r\n}\r\nstatic long efi_rtc_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nefi_status_t status;\r\nunsigned long flags;\r\nefi_time_t eft;\r\nefi_time_cap_t cap;\r\nstruct rtc_time wtime;\r\nstruct rtc_wkalrm __user *ewp;\r\nunsigned char enabled, pending;\r\nswitch (cmd) {\r\ncase RTC_UIE_ON:\r\ncase RTC_UIE_OFF:\r\ncase RTC_PIE_ON:\r\ncase RTC_PIE_OFF:\r\ncase RTC_AIE_ON:\r\ncase RTC_AIE_OFF:\r\ncase RTC_ALM_SET:\r\ncase RTC_ALM_READ:\r\ncase RTC_IRQP_READ:\r\ncase RTC_IRQP_SET:\r\ncase RTC_EPOCH_READ:\r\ncase RTC_EPOCH_SET:\r\nreturn -EINVAL;\r\ncase RTC_RD_TIME:\r\nspin_lock_irqsave(&efi_rtc_lock, flags);\r\nstatus = efi.get_time(&eft, &cap);\r\nspin_unlock_irqrestore(&efi_rtc_lock,flags);\r\nif (status != EFI_SUCCESS) {\r\nprintk(KERN_ERR "efitime: can't read time\n");\r\nreturn -EINVAL;\r\n}\r\nconvert_from_efi_time(&eft, &wtime);\r\nreturn copy_to_user((void __user *)arg, &wtime,\r\nsizeof (struct rtc_time)) ? - EFAULT : 0;\r\ncase RTC_SET_TIME:\r\nif (!capable(CAP_SYS_TIME)) return -EACCES;\r\nif (copy_from_user(&wtime, (struct rtc_time __user *)arg,\r\nsizeof(struct rtc_time)) )\r\nreturn -EFAULT;\r\nconvert_to_efi_time(&wtime, &eft);\r\nspin_lock_irqsave(&efi_rtc_lock, flags);\r\nstatus = efi.set_time(&eft);\r\nspin_unlock_irqrestore(&efi_rtc_lock,flags);\r\nreturn status == EFI_SUCCESS ? 0 : -EINVAL;\r\ncase RTC_WKALM_SET:\r\nif (!capable(CAP_SYS_TIME)) return -EACCES;\r\newp = (struct rtc_wkalrm __user *)arg;\r\nif ( get_user(enabled, &ewp->enabled)\r\n|| copy_from_user(&wtime, &ewp->time, sizeof(struct rtc_time)) )\r\nreturn -EFAULT;\r\nconvert_to_efi_time(&wtime, &eft);\r\nspin_lock_irqsave(&efi_rtc_lock, flags);\r\nstatus = efi.set_wakeup_time((efi_bool_t)enabled, &eft);\r\nspin_unlock_irqrestore(&efi_rtc_lock,flags);\r\nreturn status == EFI_SUCCESS ? 0 : -EINVAL;\r\ncase RTC_WKALM_RD:\r\nspin_lock_irqsave(&efi_rtc_lock, flags);\r\nstatus = efi.get_wakeup_time((efi_bool_t *)&enabled, (efi_bool_t *)&pending, &eft);\r\nspin_unlock_irqrestore(&efi_rtc_lock,flags);\r\nif (status != EFI_SUCCESS) return -EINVAL;\r\newp = (struct rtc_wkalrm __user *)arg;\r\nif ( put_user(enabled, &ewp->enabled)\r\n|| put_user(pending, &ewp->pending)) return -EFAULT;\r\nconvert_from_efi_time(&eft, &wtime);\r\nreturn copy_to_user(&ewp->time, &wtime,\r\nsizeof(struct rtc_time)) ? -EFAULT : 0;\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic int efi_rtc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic int efi_rtc_close(struct inode *inode, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic int efi_rtc_proc_show(struct seq_file *m, void *v)\r\n{\r\nefi_time_t eft, alm;\r\nefi_time_cap_t cap;\r\nefi_bool_t enabled, pending;\r\nunsigned long flags;\r\nmemset(&eft, 0, sizeof(eft));\r\nmemset(&alm, 0, sizeof(alm));\r\nmemset(&cap, 0, sizeof(cap));\r\nspin_lock_irqsave(&efi_rtc_lock, flags);\r\nefi.get_time(&eft, &cap);\r\nefi.get_wakeup_time(&enabled, &pending, &alm);\r\nspin_unlock_irqrestore(&efi_rtc_lock,flags);\r\nseq_printf(m,\r\n"Time : %u:%u:%u.%09u\n"\r\n"Date : %u-%u-%u\n"\r\n"Daylight : %u\n",\r\neft.hour, eft.minute, eft.second, eft.nanosecond,\r\neft.year, eft.month, eft.day,\r\neft.daylight);\r\nif (eft.timezone == EFI_UNSPECIFIED_TIMEZONE)\r\nseq_puts(m, "Timezone : unspecified\n");\r\nelse\r\nseq_printf(m, "Timezone : %u\n", eft.timezone);\r\nseq_printf(m,\r\n"Alarm Time : %u:%u:%u.%09u\n"\r\n"Alarm Date : %u-%u-%u\n"\r\n"Alarm Daylight : %u\n"\r\n"Enabled : %s\n"\r\n"Pending : %s\n",\r\nalm.hour, alm.minute, alm.second, alm.nanosecond,\r\nalm.year, alm.month, alm.day,\r\nalm.daylight,\r\nenabled == 1 ? "yes" : "no",\r\npending == 1 ? "yes" : "no");\r\nif (eft.timezone == EFI_UNSPECIFIED_TIMEZONE)\r\nseq_puts(m, "Timezone : unspecified\n");\r\nelse\r\nseq_printf(m, "Timezone : %u\n", alm.timezone);\r\nseq_printf(m,\r\n"Resolution : %u\n"\r\n"Accuracy : %u\n"\r\n"SetstoZero : %u\n",\r\ncap.resolution, cap.accuracy, cap.sets_to_zero);\r\nreturn 0;\r\n}\r\nstatic int efi_rtc_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, efi_rtc_proc_show, NULL);\r\n}\r\nstatic int __init\r\nefi_rtc_init(void)\r\n{\r\nint ret;\r\nstruct proc_dir_entry *dir;\r\nprintk(KERN_INFO "EFI Time Services Driver v%s\n", EFI_RTC_VERSION);\r\nret = misc_register(&efi_rtc_dev);\r\nif (ret) {\r\nprintk(KERN_ERR "efirtc: can't misc_register on minor=%d\n",\r\nEFI_RTC_MINOR);\r\nreturn ret;\r\n}\r\ndir = proc_create("driver/efirtc", 0, NULL, &efi_rtc_proc_fops);\r\nif (dir == NULL) {\r\nprintk(KERN_ERR "efirtc: can't create /proc/driver/efirtc.\n");\r\nmisc_deregister(&efi_rtc_dev);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit\r\nefi_rtc_exit(void)\r\n{\r\n}
