static void ieee80211_send_addba_request(struct ieee80211_sub_if_data *sdata,\r\nconst u8 *da, u16 tid,\r\nu8 dialog_token, u16 start_seq_num,\r\nu16 agg_size, u16 timeout)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_mgmt *mgmt;\r\nu16 capab;\r\nskb = dev_alloc_skb(sizeof(*mgmt) + local->hw.extra_tx_headroom);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, local->hw.extra_tx_headroom);\r\nmgmt = (struct ieee80211_mgmt *) skb_put(skb, 24);\r\nmemset(mgmt, 0, 24);\r\nmemcpy(mgmt->da, da, ETH_ALEN);\r\nmemcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);\r\nif (sdata->vif.type == NL80211_IFTYPE_AP ||\r\nsdata->vif.type == NL80211_IFTYPE_AP_VLAN ||\r\nsdata->vif.type == NL80211_IFTYPE_MESH_POINT)\r\nmemcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);\r\nelse if (sdata->vif.type == NL80211_IFTYPE_STATION)\r\nmemcpy(mgmt->bssid, sdata->u.mgd.bssid, ETH_ALEN);\r\nelse if (sdata->vif.type == NL80211_IFTYPE_ADHOC)\r\nmemcpy(mgmt->bssid, sdata->u.ibss.bssid, ETH_ALEN);\r\nmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\r\nIEEE80211_STYPE_ACTION);\r\nskb_put(skb, 1 + sizeof(mgmt->u.action.u.addba_req));\r\nmgmt->u.action.category = WLAN_CATEGORY_BACK;\r\nmgmt->u.action.u.addba_req.action_code = WLAN_ACTION_ADDBA_REQ;\r\nmgmt->u.action.u.addba_req.dialog_token = dialog_token;\r\ncapab = (u16)(1 << 1);\r\ncapab |= (u16)(tid << 2);\r\ncapab |= (u16)(agg_size << 6);\r\nmgmt->u.action.u.addba_req.capab = cpu_to_le16(capab);\r\nmgmt->u.action.u.addba_req.timeout = cpu_to_le16(timeout);\r\nmgmt->u.action.u.addba_req.start_seq_num =\r\ncpu_to_le16(start_seq_num << 4);\r\nieee80211_tx_skb(sdata, skb);\r\n}\r\nvoid ieee80211_send_bar(struct ieee80211_vif *vif, u8 *ra, u16 tid, u16 ssn)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_bar *bar;\r\nu16 bar_control = 0;\r\nskb = dev_alloc_skb(sizeof(*bar) + local->hw.extra_tx_headroom);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, local->hw.extra_tx_headroom);\r\nbar = (struct ieee80211_bar *)skb_put(skb, sizeof(*bar));\r\nmemset(bar, 0, sizeof(*bar));\r\nbar->frame_control = cpu_to_le16(IEEE80211_FTYPE_CTL |\r\nIEEE80211_STYPE_BACK_REQ);\r\nmemcpy(bar->ra, ra, ETH_ALEN);\r\nmemcpy(bar->ta, sdata->vif.addr, ETH_ALEN);\r\nbar_control |= (u16)IEEE80211_BAR_CTRL_ACK_POLICY_NORMAL;\r\nbar_control |= (u16)IEEE80211_BAR_CTRL_CBMTID_COMPRESSED_BA;\r\nbar_control |= (u16)(tid << IEEE80211_BAR_CTRL_TID_INFO_SHIFT);\r\nbar->control = cpu_to_le16(bar_control);\r\nbar->start_seq_num = cpu_to_le16(ssn);\r\nIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |\r\nIEEE80211_TX_CTL_REQ_TX_STATUS;\r\nieee80211_tx_skb_tid(sdata, skb, tid);\r\n}\r\nvoid ieee80211_assign_tid_tx(struct sta_info *sta, int tid,\r\nstruct tid_ampdu_tx *tid_tx)\r\n{\r\nlockdep_assert_held(&sta->ampdu_mlme.mtx);\r\nlockdep_assert_held(&sta->lock);\r\nrcu_assign_pointer(sta->ampdu_mlme.tid_tx[tid], tid_tx);\r\n}\r\nstatic void __acquires(agg_queue)\r\nieee80211_stop_queue_agg(struct ieee80211_sub_if_data *sdata, int tid)\r\n{\r\nint queue = sdata->vif.hw_queue[ieee80211_ac_from_tid(tid)];\r\nif (atomic_inc_return(&sdata->local->agg_queue_stop[queue]) == 1)\r\nieee80211_stop_queue_by_reason(\r\n&sdata->local->hw, queue,\r\nIEEE80211_QUEUE_STOP_REASON_AGGREGATION,\r\nfalse);\r\n__acquire(agg_queue);\r\n}\r\nstatic void __releases(agg_queue)\r\nieee80211_wake_queue_agg(struct ieee80211_sub_if_data *sdata, int tid)\r\n{\r\nint queue = sdata->vif.hw_queue[ieee80211_ac_from_tid(tid)];\r\nif (atomic_dec_return(&sdata->local->agg_queue_stop[queue]) == 0)\r\nieee80211_wake_queue_by_reason(\r\n&sdata->local->hw, queue,\r\nIEEE80211_QUEUE_STOP_REASON_AGGREGATION,\r\nfalse);\r\n__release(agg_queue);\r\n}\r\nstatic void __acquires(agg_queue)\r\nieee80211_agg_splice_packets(struct ieee80211_sub_if_data *sdata,\r\nstruct tid_ampdu_tx *tid_tx, u16 tid)\r\n{\r\nstruct ieee80211_local *local = sdata->local;\r\nint queue = sdata->vif.hw_queue[ieee80211_ac_from_tid(tid)];\r\nunsigned long flags;\r\nieee80211_stop_queue_agg(sdata, tid);\r\nif (WARN(!tid_tx,\r\n"TID %d gone but expected when splicing aggregates from the pending queue\n",\r\ntid))\r\nreturn;\r\nif (!skb_queue_empty(&tid_tx->pending)) {\r\nspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\r\nskb_queue_splice_tail_init(&tid_tx->pending,\r\n&local->pending[queue]);\r\nspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\r\n}\r\n}\r\nstatic void __releases(agg_queue)\r\nieee80211_agg_splice_finish(struct ieee80211_sub_if_data *sdata, u16 tid)\r\n{\r\nieee80211_wake_queue_agg(sdata, tid);\r\n}\r\nstatic void ieee80211_remove_tid_tx(struct sta_info *sta, int tid)\r\n{\r\nstruct tid_ampdu_tx *tid_tx;\r\nlockdep_assert_held(&sta->ampdu_mlme.mtx);\r\nlockdep_assert_held(&sta->lock);\r\ntid_tx = rcu_dereference_protected_tid_tx(sta, tid);\r\nieee80211_agg_splice_packets(sta->sdata, tid_tx, tid);\r\nieee80211_assign_tid_tx(sta, tid, NULL);\r\nieee80211_agg_splice_finish(sta->sdata, tid);\r\nkfree_rcu(tid_tx, rcu_head);\r\n}\r\nint ___ieee80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,\r\nenum ieee80211_agg_stop_reason reason)\r\n{\r\nstruct ieee80211_local *local = sta->local;\r\nstruct tid_ampdu_tx *tid_tx;\r\nenum ieee80211_ampdu_mlme_action action;\r\nint ret;\r\nlockdep_assert_held(&sta->ampdu_mlme.mtx);\r\nswitch (reason) {\r\ncase AGG_STOP_DECLINED:\r\ncase AGG_STOP_LOCAL_REQUEST:\r\ncase AGG_STOP_PEER_REQUEST:\r\naction = IEEE80211_AMPDU_TX_STOP_CONT;\r\nbreak;\r\ncase AGG_STOP_DESTROY_STA:\r\naction = IEEE80211_AMPDU_TX_STOP_FLUSH;\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_bh(&sta->lock);\r\ntid_tx = rcu_dereference_protected_tid_tx(sta, tid);\r\nif (!tid_tx) {\r\nspin_unlock_bh(&sta->lock);\r\nreturn -ENOENT;\r\n}\r\nif (test_bit(HT_AGG_STATE_STOPPING, &tid_tx->state)) {\r\nspin_unlock_bh(&sta->lock);\r\nif (reason != AGG_STOP_DESTROY_STA)\r\nreturn -EALREADY;\r\nret = drv_ampdu_action(local, sta->sdata,\r\nIEEE80211_AMPDU_TX_STOP_FLUSH_CONT,\r\n&sta->sta, tid, NULL, 0);\r\nWARN_ON_ONCE(ret);\r\nreturn 0;\r\n}\r\nif (test_bit(HT_AGG_STATE_WANT_START, &tid_tx->state)) {\r\nieee80211_assign_tid_tx(sta, tid, NULL);\r\nspin_unlock_bh(&sta->lock);\r\nkfree_rcu(tid_tx, rcu_head);\r\nreturn 0;\r\n}\r\nset_bit(HT_AGG_STATE_STOPPING, &tid_tx->state);\r\nspin_unlock_bh(&sta->lock);\r\nht_dbg(sta->sdata, "Tx BA session stop requested for %pM tid %u\n",\r\nsta->sta.addr, tid);\r\ndel_timer_sync(&tid_tx->addba_resp_timer);\r\ndel_timer_sync(&tid_tx->session_timer);\r\nclear_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state);\r\nsynchronize_net();\r\ntid_tx->stop_initiator = reason == AGG_STOP_PEER_REQUEST ?\r\nWLAN_BACK_RECIPIENT :\r\nWLAN_BACK_INITIATOR;\r\ntid_tx->tx_stop = reason == AGG_STOP_LOCAL_REQUEST;\r\nret = drv_ampdu_action(local, sta->sdata, action,\r\n&sta->sta, tid, NULL, 0);\r\nif (WARN_ON(ret)) {\r\n}\r\nreturn 0;\r\n}\r\nstatic void sta_addba_resp_timer_expired(unsigned long data)\r\n{\r\nu16 tid = *(u8 *)data;\r\nstruct sta_info *sta = container_of((void *)data,\r\nstruct sta_info, timer_to_tid[tid]);\r\nstruct tid_ampdu_tx *tid_tx;\r\nrcu_read_lock();\r\ntid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[tid]);\r\nif (!tid_tx ||\r\ntest_bit(HT_AGG_STATE_RESPONSE_RECEIVED, &tid_tx->state)) {\r\nrcu_read_unlock();\r\nht_dbg(sta->sdata,\r\n"timer expired on %pM tid %d but we are not (or no longer) expecting addBA response there\n",\r\nsta->sta.addr, tid);\r\nreturn;\r\n}\r\nht_dbg(sta->sdata, "addBA response timer expired on %pM tid %d\n",\r\nsta->sta.addr, tid);\r\nieee80211_stop_tx_ba_session(&sta->sta, tid);\r\nrcu_read_unlock();\r\n}\r\nvoid ieee80211_tx_ba_session_handle_start(struct sta_info *sta, int tid)\r\n{\r\nstruct tid_ampdu_tx *tid_tx;\r\nstruct ieee80211_local *local = sta->local;\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nu16 start_seq_num;\r\nint ret;\r\ntid_tx = rcu_dereference_protected_tid_tx(sta, tid);\r\nclear_bit(HT_AGG_STATE_WANT_START, &tid_tx->state);\r\nsynchronize_net();\r\nstart_seq_num = sta->tid_seq[tid] >> 4;\r\nret = drv_ampdu_action(local, sdata, IEEE80211_AMPDU_TX_START,\r\n&sta->sta, tid, &start_seq_num, 0);\r\nif (ret) {\r\nht_dbg(sdata,\r\n"BA request denied - HW unavailable for %pM tid %d\n",\r\nsta->sta.addr, tid);\r\nspin_lock_bh(&sta->lock);\r\nieee80211_agg_splice_packets(sdata, tid_tx, tid);\r\nieee80211_assign_tid_tx(sta, tid, NULL);\r\nieee80211_agg_splice_finish(sdata, tid);\r\nspin_unlock_bh(&sta->lock);\r\nkfree_rcu(tid_tx, rcu_head);\r\nreturn;\r\n}\r\nmod_timer(&tid_tx->addba_resp_timer, jiffies + ADDBA_RESP_INTERVAL);\r\nht_dbg(sdata, "activated addBA response timer on %pM tid %d\n",\r\nsta->sta.addr, tid);\r\nspin_lock_bh(&sta->lock);\r\nsta->ampdu_mlme.last_addba_req_time[tid] = jiffies;\r\nsta->ampdu_mlme.addba_req_num[tid]++;\r\nspin_unlock_bh(&sta->lock);\r\nieee80211_send_addba_request(sdata, sta->sta.addr, tid,\r\ntid_tx->dialog_token, start_seq_num,\r\nlocal->hw.max_tx_aggregation_subframes,\r\ntid_tx->timeout);\r\n}\r\nstatic void sta_tx_agg_session_timer_expired(unsigned long data)\r\n{\r\nu8 *ptid = (u8 *)data;\r\nu8 *timer_to_id = ptid - *ptid;\r\nstruct sta_info *sta = container_of(timer_to_id, struct sta_info,\r\ntimer_to_tid[0]);\r\nstruct tid_ampdu_tx *tid_tx;\r\nunsigned long timeout;\r\nrcu_read_lock();\r\ntid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[*ptid]);\r\nif (!tid_tx || test_bit(HT_AGG_STATE_STOPPING, &tid_tx->state)) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\ntimeout = tid_tx->last_tx + TU_TO_JIFFIES(tid_tx->timeout);\r\nif (time_is_after_jiffies(timeout)) {\r\nmod_timer(&tid_tx->session_timer, timeout);\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nrcu_read_unlock();\r\nht_dbg(sta->sdata, "tx session timer expired on %pM tid %d\n",\r\nsta->sta.addr, (u16)*ptid);\r\nieee80211_stop_tx_ba_session(&sta->sta, *ptid);\r\n}\r\nint ieee80211_start_tx_ba_session(struct ieee80211_sta *pubsta, u16 tid,\r\nu16 timeout)\r\n{\r\nstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct tid_ampdu_tx *tid_tx;\r\nint ret = 0;\r\nif (WARN(sta->reserved_tid == tid,\r\n"Requested to start BA session on reserved tid=%d", tid))\r\nreturn -EINVAL;\r\ntrace_api_start_tx_ba_session(pubsta, tid);\r\nif (WARN_ON_ONCE(!local->ops->ampdu_action))\r\nreturn -EINVAL;\r\nif ((tid >= IEEE80211_NUM_TIDS) ||\r\n!(local->hw.flags & IEEE80211_HW_AMPDU_AGGREGATION) ||\r\n(local->hw.flags & IEEE80211_HW_TX_AMPDU_SETUP_IN_HW))\r\nreturn -EINVAL;\r\nht_dbg(sdata, "Open BA session requested for %pM tid %u\n",\r\npubsta->addr, tid);\r\nif (sdata->vif.type != NL80211_IFTYPE_STATION &&\r\nsdata->vif.type != NL80211_IFTYPE_MESH_POINT &&\r\nsdata->vif.type != NL80211_IFTYPE_AP_VLAN &&\r\nsdata->vif.type != NL80211_IFTYPE_AP &&\r\nsdata->vif.type != NL80211_IFTYPE_ADHOC)\r\nreturn -EINVAL;\r\nif (test_sta_flag(sta, WLAN_STA_BLOCK_BA)) {\r\nht_dbg(sdata,\r\n"BA sessions blocked - Denying BA session request %pM tid %d\n",\r\nsta->sta.addr, tid);\r\nreturn -EINVAL;\r\n}\r\nif (sta->sdata->vif.type == NL80211_IFTYPE_ADHOC &&\r\n!sta->sta.ht_cap.ht_supported) {\r\nht_dbg(sdata,\r\n"BA request denied - IBSS STA %pM does not advertise HT support\n",\r\npubsta->addr);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_bh(&sta->lock);\r\nif (sta->ampdu_mlme.addba_req_num[tid] > HT_AGG_MAX_RETRIES) {\r\nret = -EBUSY;\r\ngoto err_unlock_sta;\r\n}\r\nif (sta->ampdu_mlme.addba_req_num[tid] > HT_AGG_BURST_RETRIES &&\r\ntime_before(jiffies, sta->ampdu_mlme.last_addba_req_time[tid] +\r\nHT_AGG_RETRIES_PERIOD)) {\r\nht_dbg(sdata,\r\n"BA request denied - waiting a grace period after %d failed requests on %pM tid %u\n",\r\nsta->ampdu_mlme.addba_req_num[tid], sta->sta.addr, tid);\r\nret = -EBUSY;\r\ngoto err_unlock_sta;\r\n}\r\ntid_tx = rcu_dereference_protected_tid_tx(sta, tid);\r\nif (tid_tx || sta->ampdu_mlme.tid_start_tx[tid]) {\r\nht_dbg(sdata,\r\n"BA request denied - session is not idle on %pM tid %u\n",\r\nsta->sta.addr, tid);\r\nret = -EAGAIN;\r\ngoto err_unlock_sta;\r\n}\r\ntid_tx = kzalloc(sizeof(struct tid_ampdu_tx), GFP_ATOMIC);\r\nif (!tid_tx) {\r\nret = -ENOMEM;\r\ngoto err_unlock_sta;\r\n}\r\nskb_queue_head_init(&tid_tx->pending);\r\n__set_bit(HT_AGG_STATE_WANT_START, &tid_tx->state);\r\ntid_tx->timeout = timeout;\r\ntid_tx->addba_resp_timer.function = sta_addba_resp_timer_expired;\r\ntid_tx->addba_resp_timer.data = (unsigned long)&sta->timer_to_tid[tid];\r\ninit_timer(&tid_tx->addba_resp_timer);\r\ntid_tx->session_timer.function = sta_tx_agg_session_timer_expired;\r\ntid_tx->session_timer.data = (unsigned long)&sta->timer_to_tid[tid];\r\ninit_timer_deferrable(&tid_tx->session_timer);\r\nsta->ampdu_mlme.dialog_token_allocator++;\r\ntid_tx->dialog_token = sta->ampdu_mlme.dialog_token_allocator;\r\nsta->ampdu_mlme.tid_start_tx[tid] = tid_tx;\r\nieee80211_queue_work(&local->hw, &sta->ampdu_mlme.work);\r\nerr_unlock_sta:\r\nspin_unlock_bh(&sta->lock);\r\nreturn ret;\r\n}\r\nstatic void ieee80211_agg_tx_operational(struct ieee80211_local *local,\r\nstruct sta_info *sta, u16 tid)\r\n{\r\nstruct tid_ampdu_tx *tid_tx;\r\nlockdep_assert_held(&sta->ampdu_mlme.mtx);\r\ntid_tx = rcu_dereference_protected_tid_tx(sta, tid);\r\nht_dbg(sta->sdata, "Aggregation is on for %pM tid %d\n",\r\nsta->sta.addr, tid);\r\ndrv_ampdu_action(local, sta->sdata,\r\nIEEE80211_AMPDU_TX_OPERATIONAL,\r\n&sta->sta, tid, NULL, tid_tx->buf_size);\r\nspin_lock_bh(&sta->lock);\r\nieee80211_agg_splice_packets(sta->sdata, tid_tx, tid);\r\nset_bit(HT_AGG_STATE_OPERATIONAL, &tid_tx->state);\r\nieee80211_agg_splice_finish(sta->sdata, tid);\r\nspin_unlock_bh(&sta->lock);\r\n}\r\nvoid ieee80211_start_tx_ba_cb(struct ieee80211_vif *vif, u8 *ra, u16 tid)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sta_info *sta;\r\nstruct tid_ampdu_tx *tid_tx;\r\ntrace_api_start_tx_ba_cb(sdata, ra, tid);\r\nif (tid >= IEEE80211_NUM_TIDS) {\r\nht_dbg(sdata, "Bad TID value: tid = %d (>= %d)\n",\r\ntid, IEEE80211_NUM_TIDS);\r\nreturn;\r\n}\r\nmutex_lock(&local->sta_mtx);\r\nsta = sta_info_get_bss(sdata, ra);\r\nif (!sta) {\r\nmutex_unlock(&local->sta_mtx);\r\nht_dbg(sdata, "Could not find station: %pM\n", ra);\r\nreturn;\r\n}\r\nmutex_lock(&sta->ampdu_mlme.mtx);\r\ntid_tx = rcu_dereference_protected_tid_tx(sta, tid);\r\nif (WARN_ON(!tid_tx)) {\r\nht_dbg(sdata, "addBA was not requested!\n");\r\ngoto unlock;\r\n}\r\nif (WARN_ON(test_and_set_bit(HT_AGG_STATE_DRV_READY, &tid_tx->state)))\r\ngoto unlock;\r\nif (test_bit(HT_AGG_STATE_RESPONSE_RECEIVED, &tid_tx->state))\r\nieee80211_agg_tx_operational(local, sta, tid);\r\nunlock:\r\nmutex_unlock(&sta->ampdu_mlme.mtx);\r\nmutex_unlock(&local->sta_mtx);\r\n}\r\nvoid ieee80211_start_tx_ba_cb_irqsafe(struct ieee80211_vif *vif,\r\nconst u8 *ra, u16 tid)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_ra_tid *ra_tid;\r\nstruct sk_buff *skb = dev_alloc_skb(0);\r\nif (unlikely(!skb))\r\nreturn;\r\nra_tid = (struct ieee80211_ra_tid *) &skb->cb;\r\nmemcpy(&ra_tid->ra, ra, ETH_ALEN);\r\nra_tid->tid = tid;\r\nskb->pkt_type = IEEE80211_SDATA_QUEUE_AGG_START;\r\nskb_queue_tail(&sdata->skb_queue, skb);\r\nieee80211_queue_work(&local->hw, &sdata->work);\r\n}\r\nint __ieee80211_stop_tx_ba_session(struct sta_info *sta, u16 tid,\r\nenum ieee80211_agg_stop_reason reason)\r\n{\r\nint ret;\r\nmutex_lock(&sta->ampdu_mlme.mtx);\r\nret = ___ieee80211_stop_tx_ba_session(sta, tid, reason);\r\nmutex_unlock(&sta->ampdu_mlme.mtx);\r\nreturn ret;\r\n}\r\nint ieee80211_stop_tx_ba_session(struct ieee80211_sta *pubsta, u16 tid)\r\n{\r\nstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct tid_ampdu_tx *tid_tx;\r\nint ret = 0;\r\ntrace_api_stop_tx_ba_session(pubsta, tid);\r\nif (!local->ops->ampdu_action)\r\nreturn -EINVAL;\r\nif (tid >= IEEE80211_NUM_TIDS)\r\nreturn -EINVAL;\r\nspin_lock_bh(&sta->lock);\r\ntid_tx = rcu_dereference_protected_tid_tx(sta, tid);\r\nif (!tid_tx) {\r\nret = -ENOENT;\r\ngoto unlock;\r\n}\r\nWARN(sta->reserved_tid == tid,\r\n"Requested to stop BA session on reserved tid=%d", tid);\r\nif (test_bit(HT_AGG_STATE_STOPPING, &tid_tx->state)) {\r\nret = 0;\r\ngoto unlock;\r\n}\r\nset_bit(HT_AGG_STATE_WANT_STOP, &tid_tx->state);\r\nieee80211_queue_work(&local->hw, &sta->ampdu_mlme.work);\r\nunlock:\r\nspin_unlock_bh(&sta->lock);\r\nreturn ret;\r\n}\r\nvoid ieee80211_stop_tx_ba_cb(struct ieee80211_vif *vif, u8 *ra, u8 tid)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct sta_info *sta;\r\nstruct tid_ampdu_tx *tid_tx;\r\ntrace_api_stop_tx_ba_cb(sdata, ra, tid);\r\nif (tid >= IEEE80211_NUM_TIDS) {\r\nht_dbg(sdata, "Bad TID value: tid = %d (>= %d)\n",\r\ntid, IEEE80211_NUM_TIDS);\r\nreturn;\r\n}\r\nht_dbg(sdata, "Stopping Tx BA session for %pM tid %d\n", ra, tid);\r\nmutex_lock(&local->sta_mtx);\r\nsta = sta_info_get_bss(sdata, ra);\r\nif (!sta) {\r\nht_dbg(sdata, "Could not find station: %pM\n", ra);\r\ngoto unlock;\r\n}\r\nmutex_lock(&sta->ampdu_mlme.mtx);\r\nspin_lock_bh(&sta->lock);\r\ntid_tx = rcu_dereference_protected_tid_tx(sta, tid);\r\nif (!tid_tx || !test_bit(HT_AGG_STATE_STOPPING, &tid_tx->state)) {\r\nht_dbg(sdata,\r\n"unexpected callback to A-MPDU stop for %pM tid %d\n",\r\nsta->sta.addr, tid);\r\ngoto unlock_sta;\r\n}\r\nif (tid_tx->stop_initiator == WLAN_BACK_INITIATOR && tid_tx->tx_stop)\r\nieee80211_send_delba(sta->sdata, ra, tid,\r\nWLAN_BACK_INITIATOR, WLAN_REASON_QSTA_NOT_USE);\r\nieee80211_remove_tid_tx(sta, tid);\r\nunlock_sta:\r\nspin_unlock_bh(&sta->lock);\r\nmutex_unlock(&sta->ampdu_mlme.mtx);\r\nunlock:\r\nmutex_unlock(&local->sta_mtx);\r\n}\r\nvoid ieee80211_stop_tx_ba_cb_irqsafe(struct ieee80211_vif *vif,\r\nconst u8 *ra, u16 tid)\r\n{\r\nstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\r\nstruct ieee80211_local *local = sdata->local;\r\nstruct ieee80211_ra_tid *ra_tid;\r\nstruct sk_buff *skb = dev_alloc_skb(0);\r\nif (unlikely(!skb))\r\nreturn;\r\nra_tid = (struct ieee80211_ra_tid *) &skb->cb;\r\nmemcpy(&ra_tid->ra, ra, ETH_ALEN);\r\nra_tid->tid = tid;\r\nskb->pkt_type = IEEE80211_SDATA_QUEUE_AGG_STOP;\r\nskb_queue_tail(&sdata->skb_queue, skb);\r\nieee80211_queue_work(&local->hw, &sdata->work);\r\n}\r\nvoid ieee80211_process_addba_resp(struct ieee80211_local *local,\r\nstruct sta_info *sta,\r\nstruct ieee80211_mgmt *mgmt,\r\nsize_t len)\r\n{\r\nstruct tid_ampdu_tx *tid_tx;\r\nu16 capab, tid;\r\nu8 buf_size;\r\ncapab = le16_to_cpu(mgmt->u.action.u.addba_resp.capab);\r\ntid = (capab & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2;\r\nbuf_size = (capab & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK) >> 6;\r\nmutex_lock(&sta->ampdu_mlme.mtx);\r\ntid_tx = rcu_dereference_protected_tid_tx(sta, tid);\r\nif (!tid_tx)\r\ngoto out;\r\nif (mgmt->u.action.u.addba_resp.dialog_token != tid_tx->dialog_token) {\r\nht_dbg(sta->sdata, "wrong addBA response token, %pM tid %d\n",\r\nsta->sta.addr, tid);\r\ngoto out;\r\n}\r\ndel_timer_sync(&tid_tx->addba_resp_timer);\r\nht_dbg(sta->sdata, "switched off addBA timer for %pM tid %d\n",\r\nsta->sta.addr, tid);\r\nif (test_bit(HT_AGG_STATE_WANT_STOP, &tid_tx->state) ||\r\ntest_bit(HT_AGG_STATE_STOPPING, &tid_tx->state)) {\r\nht_dbg(sta->sdata,\r\n"got addBA resp for %pM tid %d but we already gave up\n",\r\nsta->sta.addr, tid);\r\ngoto out;\r\n}\r\nif (le16_to_cpu(mgmt->u.action.u.addba_resp.status)\r\n== WLAN_STATUS_SUCCESS && buf_size) {\r\nif (test_and_set_bit(HT_AGG_STATE_RESPONSE_RECEIVED,\r\n&tid_tx->state)) {\r\ngoto out;\r\n}\r\ntid_tx->buf_size = buf_size;\r\nif (test_bit(HT_AGG_STATE_DRV_READY, &tid_tx->state))\r\nieee80211_agg_tx_operational(local, sta, tid);\r\nsta->ampdu_mlme.addba_req_num[tid] = 0;\r\nif (tid_tx->timeout) {\r\nmod_timer(&tid_tx->session_timer,\r\nTU_TO_EXP_TIME(tid_tx->timeout));\r\ntid_tx->last_tx = jiffies;\r\n}\r\n} else {\r\n___ieee80211_stop_tx_ba_session(sta, tid, AGG_STOP_DECLINED);\r\n}\r\nout:\r\nmutex_unlock(&sta->ampdu_mlme.mtx);\r\n}
