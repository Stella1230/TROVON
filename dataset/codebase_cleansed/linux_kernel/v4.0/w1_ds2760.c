static int w1_ds2760_io(struct device *dev, char *buf, int addr, size_t count,\r\nint io)\r\n{\r\nstruct w1_slave *sl = container_of(dev, struct w1_slave, dev);\r\nif (!dev)\r\nreturn 0;\r\nmutex_lock(&sl->master->bus_mutex);\r\nif (addr > DS2760_DATA_SIZE || addr < 0) {\r\ncount = 0;\r\ngoto out;\r\n}\r\nif (addr + count > DS2760_DATA_SIZE)\r\ncount = DS2760_DATA_SIZE - addr;\r\nif (!w1_reset_select_slave(sl)) {\r\nif (!io) {\r\nw1_write_8(sl->master, W1_DS2760_READ_DATA);\r\nw1_write_8(sl->master, addr);\r\ncount = w1_read_block(sl->master, buf, count);\r\n} else {\r\nw1_write_8(sl->master, W1_DS2760_WRITE_DATA);\r\nw1_write_8(sl->master, addr);\r\nw1_write_block(sl->master, buf, count);\r\n}\r\n}\r\nout:\r\nmutex_unlock(&sl->master->bus_mutex);\r\nreturn count;\r\n}\r\nint w1_ds2760_read(struct device *dev, char *buf, int addr, size_t count)\r\n{\r\nreturn w1_ds2760_io(dev, buf, addr, count, 0);\r\n}\r\nint w1_ds2760_write(struct device *dev, char *buf, int addr, size_t count)\r\n{\r\nreturn w1_ds2760_io(dev, buf, addr, count, 1);\r\n}\r\nstatic int w1_ds2760_eeprom_cmd(struct device *dev, int addr, int cmd)\r\n{\r\nstruct w1_slave *sl = container_of(dev, struct w1_slave, dev);\r\nif (!dev)\r\nreturn -EINVAL;\r\nmutex_lock(&sl->master->bus_mutex);\r\nif (w1_reset_select_slave(sl) == 0) {\r\nw1_write_8(sl->master, cmd);\r\nw1_write_8(sl->master, addr);\r\n}\r\nmutex_unlock(&sl->master->bus_mutex);\r\nreturn 0;\r\n}\r\nint w1_ds2760_store_eeprom(struct device *dev, int addr)\r\n{\r\nreturn w1_ds2760_eeprom_cmd(dev, addr, W1_DS2760_COPY_DATA);\r\n}\r\nint w1_ds2760_recall_eeprom(struct device *dev, int addr)\r\n{\r\nreturn w1_ds2760_eeprom_cmd(dev, addr, W1_DS2760_RECALL_DATA);\r\n}\r\nstatic ssize_t w1_slave_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr, char *buf,\r\nloff_t off, size_t count)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nreturn w1_ds2760_read(dev, buf, off, count);\r\n}\r\nstatic int w1_ds2760_add_slave(struct w1_slave *sl)\r\n{\r\nint ret;\r\nint id;\r\nstruct platform_device *pdev;\r\nid = ida_simple_get(&bat_ida, 0, 0, GFP_KERNEL);\r\nif (id < 0) {\r\nret = id;\r\ngoto noid;\r\n}\r\npdev = platform_device_alloc("ds2760-battery", id);\r\nif (!pdev) {\r\nret = -ENOMEM;\r\ngoto pdev_alloc_failed;\r\n}\r\npdev->dev.parent = &sl->dev;\r\nret = platform_device_add(pdev);\r\nif (ret)\r\ngoto pdev_add_failed;\r\ndev_set_drvdata(&sl->dev, pdev);\r\ngoto success;\r\npdev_add_failed:\r\nplatform_device_put(pdev);\r\npdev_alloc_failed:\r\nida_simple_remove(&bat_ida, id);\r\nnoid:\r\nsuccess:\r\nreturn ret;\r\n}\r\nstatic void w1_ds2760_remove_slave(struct w1_slave *sl)\r\n{\r\nstruct platform_device *pdev = dev_get_drvdata(&sl->dev);\r\nint id = pdev->id;\r\nplatform_device_unregister(pdev);\r\nida_simple_remove(&bat_ida, id);\r\n}\r\nstatic int __init w1_ds2760_init(void)\r\n{\r\npr_info("1-Wire driver for the DS2760 battery monitor chip - (c) 2004-2005, Szabolcs Gyurko\n");\r\nida_init(&bat_ida);\r\nreturn w1_register_family(&w1_ds2760_family);\r\n}\r\nstatic void __exit w1_ds2760_exit(void)\r\n{\r\nw1_unregister_family(&w1_ds2760_family);\r\nida_destroy(&bat_ida);\r\n}
