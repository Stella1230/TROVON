static int\r\nsti_drm_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb, int crtc_x, int crtc_y,\r\nunsigned int crtc_w, unsigned int crtc_h,\r\nuint32_t src_x, uint32_t src_y,\r\nuint32_t src_w, uint32_t src_h)\r\n{\r\nstruct sti_layer *layer = to_sti_layer(plane);\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nint res;\r\nDRM_DEBUG_KMS("CRTC:%d (%s) drm plane:%d (%s) drm fb:%d\n",\r\ncrtc->base.id, sti_mixer_to_str(mixer),\r\nplane->base.id, sti_layer_to_str(layer), fb->base.id);\r\nDRM_DEBUG_KMS("(%dx%d)@(%d,%d)\n", crtc_w, crtc_h, crtc_x, crtc_y);\r\nres = sti_mixer_set_layer_depth(mixer, layer);\r\nif (res) {\r\nDRM_ERROR("Can not set layer depth\n");\r\nreturn res;\r\n}\r\nres = sti_layer_prepare(layer, crtc, fb,\r\n&crtc->mode, mixer->id,\r\ncrtc_x, crtc_y, crtc_w, crtc_h,\r\nsrc_x >> 16, src_y >> 16,\r\nsrc_w >> 16, src_h >> 16);\r\nif (res) {\r\nDRM_ERROR("Layer prepare failed\n");\r\nreturn res;\r\n}\r\nres = sti_layer_commit(layer);\r\nif (res) {\r\nDRM_ERROR("Layer commit failed\n");\r\nreturn res;\r\n}\r\nres = sti_mixer_set_layer_status(mixer, layer, true);\r\nif (res) {\r\nDRM_ERROR("Can not enable layer at mixer\n");\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sti_drm_disable_plane(struct drm_plane *plane)\r\n{\r\nstruct sti_layer *layer;\r\nstruct sti_mixer *mixer;\r\nint lay_res, mix_res;\r\nif (!plane->crtc) {\r\nDRM_DEBUG_DRIVER("drm plane:%d not enabled\n", plane->base.id);\r\nreturn 0;\r\n}\r\nlayer = to_sti_layer(plane);\r\nmixer = to_sti_mixer(plane->crtc);\r\nDRM_DEBUG_DRIVER("CRTC:%d (%s) drm plane:%d (%s)\n",\r\nplane->crtc->base.id, sti_mixer_to_str(mixer),\r\nplane->base.id, sti_layer_to_str(layer));\r\nmix_res = sti_mixer_set_layer_status(mixer, layer, false);\r\nif (mix_res)\r\nDRM_ERROR("Can not disable layer at mixer\n");\r\nmsleep(WAIT_NEXT_VSYNC_MS);\r\nlay_res = sti_layer_disable(layer);\r\nif (lay_res)\r\nDRM_ERROR("Layer disable failed\n");\r\nif (lay_res || mix_res)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void sti_drm_plane_destroy(struct drm_plane *plane)\r\n{\r\nDRM_DEBUG_DRIVER("\n");\r\nsti_drm_disable_plane(plane);\r\ndrm_plane_cleanup(plane);\r\n}\r\nstatic int sti_drm_plane_set_property(struct drm_plane *plane,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct drm_device *dev = plane->dev;\r\nstruct sti_drm_private *private = dev->dev_private;\r\nstruct sti_layer *layer = to_sti_layer(plane);\r\nDRM_DEBUG_DRIVER("\n");\r\nif (property == private->plane_zorder_property) {\r\nlayer->zorder = val;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void sti_drm_plane_attach_zorder_property(struct drm_plane *plane,\r\nuint64_t default_val)\r\n{\r\nstruct drm_device *dev = plane->dev;\r\nstruct sti_drm_private *private = dev->dev_private;\r\nstruct drm_property *prop;\r\nstruct sti_layer *layer = to_sti_layer(plane);\r\nprop = private->plane_zorder_property;\r\nif (!prop) {\r\nprop = drm_property_create_range(dev, 0, "zpos", 0,\r\nGAM_MIXER_NB_DEPTH_LEVEL - 1);\r\nif (!prop)\r\nreturn;\r\nprivate->plane_zorder_property = prop;\r\n}\r\ndrm_object_attach_property(&plane->base, prop, default_val);\r\nlayer->zorder = default_val;\r\n}\r\nstruct drm_plane *sti_drm_plane_init(struct drm_device *dev,\r\nstruct sti_layer *layer,\r\nunsigned int possible_crtcs,\r\nenum drm_plane_type type)\r\n{\r\nint err, i;\r\nuint64_t default_zorder = 0;\r\nerr = drm_universal_plane_init(dev, &layer->plane, possible_crtcs,\r\n&sti_drm_plane_funcs,\r\nsti_layer_get_formats(layer),\r\nsti_layer_get_nb_formats(layer), type);\r\nif (err) {\r\nDRM_ERROR("Failed to initialize plane\n");\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(sti_layer_default_zorder); i++)\r\nif (sti_layer_default_zorder[i] == layer->desc)\r\nbreak;\r\ndefault_zorder = i;\r\nif (type == DRM_PLANE_TYPE_OVERLAY)\r\nsti_drm_plane_attach_zorder_property(&layer->plane,\r\ndefault_zorder);\r\nDRM_DEBUG_DRIVER("drm plane:%d mapped to %s with zorder:%llu\n",\r\nlayer->plane.base.id,\r\nsti_layer_to_str(layer), default_zorder);\r\nreturn &layer->plane;\r\n}
