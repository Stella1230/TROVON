static ssize_t\r\nqla4_8xxx_sysfs_read_fw_dump(struct file *filep, struct kobject *kobj,\r\nstruct bin_attribute *ba, char *buf, loff_t off,\r\nsize_t count)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nif (is_qla40XX(ha))\r\nreturn -EINVAL;\r\nif (!test_bit(AF_82XX_DUMP_READING, &ha->flags))\r\nreturn 0;\r\nreturn memory_read_from_buffer(buf, count, &off, ha->fw_dump,\r\nha->fw_dump_size);\r\n}\r\nstatic ssize_t\r\nqla4_8xxx_sysfs_write_fw_dump(struct file *filep, struct kobject *kobj,\r\nstruct bin_attribute *ba, char *buf, loff_t off,\r\nsize_t count)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(dev_to_shost(container_of(kobj,\r\nstruct device, kobj)));\r\nuint32_t dev_state;\r\nlong reading;\r\nint ret = 0;\r\nif (is_qla40XX(ha))\r\nreturn -EINVAL;\r\nif (off != 0)\r\nreturn ret;\r\nbuf[1] = 0;\r\nret = kstrtol(buf, 10, &reading);\r\nif (ret) {\r\nql4_printk(KERN_ERR, ha, "%s: Invalid input. Return err %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nswitch (reading) {\r\ncase 0:\r\nif (test_and_clear_bit(AF_82XX_DUMP_READING, &ha->flags)) {\r\nclear_bit(AF_82XX_FW_DUMPED, &ha->flags);\r\nqla4xxx_alloc_fw_dump(ha);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Firmware template reloaded\n"));\r\n}\r\nbreak;\r\ncase 1:\r\nif (test_bit(AF_82XX_FW_DUMPED, &ha->flags) &&\r\n!test_bit(AF_82XX_DUMP_READING, &ha->flags)) {\r\nset_bit(AF_82XX_DUMP_READING, &ha->flags);\r\nDEBUG2(ql4_printk(KERN_INFO, ha,\r\n"Raw firmware dump ready for read on (%ld).\n",\r\nha->host_no));\r\n}\r\nbreak;\r\ncase 2:\r\nha->isp_ops->idc_lock(ha);\r\ndev_state = qla4_8xxx_rd_direct(ha, QLA8XXX_CRB_DEV_STATE);\r\nif (dev_state == QLA8XXX_DEV_READY) {\r\nql4_printk(KERN_INFO, ha, "%s: Setting Need reset\n",\r\n__func__);\r\nqla4_8xxx_wr_direct(ha, QLA8XXX_CRB_DEV_STATE,\r\nQLA8XXX_DEV_NEED_RESET);\r\nif (is_qla8022(ha) ||\r\n((is_qla8032(ha) || is_qla8042(ha)) &&\r\nqla4_83xx_can_perform_reset(ha))) {\r\nset_bit(AF_8XXX_RST_OWNER, &ha->flags);\r\nset_bit(AF_FW_RECOVERY, &ha->flags);\r\nql4_printk(KERN_INFO, ha, "%s: Reset owner is 0x%x\n",\r\n__func__, ha->func_num);\r\n}\r\n} else\r\nql4_printk(KERN_INFO, ha,\r\n"%s: Reset not performed as device state is 0x%x\n",\r\n__func__, dev_state);\r\nha->isp_ops->idc_unlock(ha);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn count;\r\n}\r\nvoid qla4_8xxx_alloc_sysfs_attr(struct scsi_qla_host *ha)\r\n{\r\nstruct Scsi_Host *host = ha->host;\r\nstruct sysfs_entry *iter;\r\nint ret;\r\nfor (iter = bin_file_entries; iter->name; iter++) {\r\nret = sysfs_create_bin_file(&host->shost_gendev.kobj,\r\niter->attr);\r\nif (ret)\r\nql4_printk(KERN_ERR, ha,\r\n"Unable to create sysfs %s binary attribute (%d).\n",\r\niter->name, ret);\r\n}\r\n}\r\nvoid qla4_8xxx_free_sysfs_attr(struct scsi_qla_host *ha)\r\n{\r\nstruct Scsi_Host *host = ha->host;\r\nstruct sysfs_entry *iter;\r\nfor (iter = bin_file_entries; iter->name; iter++)\r\nsysfs_remove_bin_file(&host->shost_gendev.kobj,\r\niter->attr);\r\n}\r\nstatic ssize_t\r\nqla4xxx_fw_version_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nif (is_qla80XX(ha))\r\nreturn snprintf(buf, PAGE_SIZE, "%d.%02d.%02d (%x)\n",\r\nha->fw_info.fw_major, ha->fw_info.fw_minor,\r\nha->fw_info.fw_patch, ha->fw_info.fw_build);\r\nelse\r\nreturn snprintf(buf, PAGE_SIZE, "%d.%02d.%02d.%02d\n",\r\nha->fw_info.fw_major, ha->fw_info.fw_minor,\r\nha->fw_info.fw_patch, ha->fw_info.fw_build);\r\n}\r\nstatic ssize_t\r\nqla4xxx_serial_num_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", ha->serial_number);\r\n}\r\nstatic ssize_t\r\nqla4xxx_iscsi_version_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nreturn snprintf(buf, PAGE_SIZE, "%d.%02d\n", ha->fw_info.iscsi_major,\r\nha->fw_info.iscsi_minor);\r\n}\r\nstatic ssize_t\r\nqla4xxx_optrom_version_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nreturn snprintf(buf, PAGE_SIZE, "%d.%02d.%02d.%02d\n",\r\nha->fw_info.bootload_major, ha->fw_info.bootload_minor,\r\nha->fw_info.bootload_patch, ha->fw_info.bootload_build);\r\n}\r\nstatic ssize_t\r\nqla4xxx_board_id_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nreturn snprintf(buf, PAGE_SIZE, "0x%08X\n", ha->board_id);\r\n}\r\nstatic ssize_t\r\nqla4xxx_fw_state_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nqla4xxx_get_firmware_state(ha);\r\nreturn snprintf(buf, PAGE_SIZE, "0x%08X%8X\n", ha->firmware_state,\r\nha->addl_fw_state);\r\n}\r\nstatic ssize_t\r\nqla4xxx_phy_port_cnt_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nif (is_qla40XX(ha))\r\nreturn -ENOSYS;\r\nreturn snprintf(buf, PAGE_SIZE, "0x%04X\n", ha->phy_port_cnt);\r\n}\r\nstatic ssize_t\r\nqla4xxx_phy_port_num_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nif (is_qla40XX(ha))\r\nreturn -ENOSYS;\r\nreturn snprintf(buf, PAGE_SIZE, "0x%04X\n", ha->phy_port_num);\r\n}\r\nstatic ssize_t\r\nqla4xxx_iscsi_func_cnt_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nif (is_qla40XX(ha))\r\nreturn -ENOSYS;\r\nreturn snprintf(buf, PAGE_SIZE, "0x%04X\n", ha->iscsi_pci_func_cnt);\r\n}\r\nstatic ssize_t\r\nqla4xxx_hba_model_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", ha->model_name);\r\n}\r\nstatic ssize_t\r\nqla4xxx_fw_timestamp_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nreturn snprintf(buf, PAGE_SIZE, "%s %s\n", ha->fw_info.fw_build_date,\r\nha->fw_info.fw_build_time);\r\n}\r\nstatic ssize_t\r\nqla4xxx_fw_build_user_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", ha->fw_info.fw_build_user);\r\n}\r\nstatic ssize_t\r\nqla4xxx_fw_ext_timestamp_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", ha->fw_info.extended_timestamp);\r\n}\r\nstatic ssize_t\r\nqla4xxx_fw_load_src_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nchar *load_src = NULL;\r\nswitch (ha->fw_info.fw_load_source) {\r\ncase 1:\r\nload_src = "Flash Primary";\r\nbreak;\r\ncase 2:\r\nload_src = "Flash Secondary";\r\nbreak;\r\ncase 3:\r\nload_src = "Host Download";\r\nbreak;\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", load_src);\r\n}\r\nstatic ssize_t\r\nqla4xxx_fw_uptime_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_qla_host *ha = to_qla_host(class_to_shost(dev));\r\nqla4xxx_about_firmware(ha);\r\nreturn snprintf(buf, PAGE_SIZE, "%u.%u secs\n", ha->fw_uptime_secs,\r\nha->fw_uptime_msecs);\r\n}
