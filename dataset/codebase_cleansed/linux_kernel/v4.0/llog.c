static struct llog_handle *llog_alloc_handle(void)\r\n{\r\nstruct llog_handle *loghandle;\r\nOBD_ALLOC_PTR(loghandle);\r\nif (loghandle == NULL)\r\nreturn NULL;\r\ninit_rwsem(&loghandle->lgh_lock);\r\nspin_lock_init(&loghandle->lgh_hdr_lock);\r\nINIT_LIST_HEAD(&loghandle->u.phd.phd_entry);\r\natomic_set(&loghandle->lgh_refcount, 1);\r\nreturn loghandle;\r\n}\r\nstatic void llog_free_handle(struct llog_handle *loghandle)\r\n{\r\nLASSERT(loghandle != NULL);\r\nif (!loghandle->lgh_hdr)\r\ngoto out;\r\nif (loghandle->lgh_hdr->llh_flags & LLOG_F_IS_PLAIN)\r\nLASSERT(list_empty(&loghandle->u.phd.phd_entry));\r\nelse if (loghandle->lgh_hdr->llh_flags & LLOG_F_IS_CAT)\r\nLASSERT(list_empty(&loghandle->u.chd.chd_head));\r\nLASSERT(sizeof(*(loghandle->lgh_hdr)) == LLOG_CHUNK_SIZE);\r\nOBD_FREE(loghandle->lgh_hdr, LLOG_CHUNK_SIZE);\r\nout:\r\nOBD_FREE_PTR(loghandle);\r\n}\r\nvoid llog_handle_get(struct llog_handle *loghandle)\r\n{\r\natomic_inc(&loghandle->lgh_refcount);\r\n}\r\nvoid llog_handle_put(struct llog_handle *loghandle)\r\n{\r\nLASSERT(atomic_read(&loghandle->lgh_refcount) > 0);\r\nif (atomic_dec_and_test(&loghandle->lgh_refcount))\r\nllog_free_handle(loghandle);\r\n}\r\nint llog_cancel_rec(const struct lu_env *env, struct llog_handle *loghandle,\r\nint index)\r\n{\r\nstruct llog_log_hdr *llh = loghandle->lgh_hdr;\r\nint rc = 0;\r\nCDEBUG(D_RPCTRACE, "Canceling %d in log "DOSTID"\n",\r\nindex, POSTID(&loghandle->lgh_id.lgl_oi));\r\nif (index == 0) {\r\nCERROR("Can't cancel index 0 which is header\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&loghandle->lgh_hdr_lock);\r\nif (!ext2_clear_bit(index, llh->llh_bitmap)) {\r\nspin_unlock(&loghandle->lgh_hdr_lock);\r\nCDEBUG(D_RPCTRACE, "Catalog index %u already clear?\n", index);\r\nreturn -ENOENT;\r\n}\r\nllh->llh_count--;\r\nif ((llh->llh_flags & LLOG_F_ZAP_WHEN_EMPTY) &&\r\n(llh->llh_count == 1) &&\r\n(loghandle->lgh_last_idx == (LLOG_BITMAP_BYTES * 8) - 1)) {\r\nspin_unlock(&loghandle->lgh_hdr_lock);\r\nrc = llog_destroy(env, loghandle);\r\nif (rc < 0) {\r\nCERROR("%s: can't destroy empty llog #"DOSTID\r\n"#%08x: rc = %d\n",\r\nloghandle->lgh_ctxt->loc_obd->obd_name,\r\nPOSTID(&loghandle->lgh_id.lgl_oi),\r\nloghandle->lgh_id.lgl_ogen, rc);\r\ngoto out_err;\r\n}\r\nreturn 1;\r\n}\r\nspin_unlock(&loghandle->lgh_hdr_lock);\r\nrc = llog_write(env, loghandle, &llh->llh_hdr, NULL, 0, NULL, 0);\r\nif (rc < 0) {\r\nCERROR("%s: fail to write header for llog #"DOSTID\r\n"#%08x: rc = %d\n",\r\nloghandle->lgh_ctxt->loc_obd->obd_name,\r\nPOSTID(&loghandle->lgh_id.lgl_oi),\r\nloghandle->lgh_id.lgl_ogen, rc);\r\ngoto out_err;\r\n}\r\nreturn 0;\r\nout_err:\r\nspin_lock(&loghandle->lgh_hdr_lock);\r\next2_set_bit(index, llh->llh_bitmap);\r\nllh->llh_count++;\r\nspin_unlock(&loghandle->lgh_hdr_lock);\r\nreturn rc;\r\n}\r\nstatic int llog_read_header(const struct lu_env *env,\r\nstruct llog_handle *handle,\r\nstruct obd_uuid *uuid)\r\n{\r\nstruct llog_operations *lop;\r\nint rc;\r\nrc = llog_handle2ops(handle, &lop);\r\nif (rc)\r\nreturn rc;\r\nif (lop->lop_read_header == NULL)\r\nreturn -EOPNOTSUPP;\r\nrc = lop->lop_read_header(env, handle);\r\nif (rc == LLOG_EEMPTY) {\r\nstruct llog_log_hdr *llh = handle->lgh_hdr;\r\nhandle->lgh_last_idx = 0;\r\nllh->llh_count = 1;\r\nllh->llh_hdr.lrh_type = LLOG_HDR_MAGIC;\r\nllh->llh_hdr.lrh_len = llh->llh_tail.lrt_len = LLOG_CHUNK_SIZE;\r\nllh->llh_hdr.lrh_index = llh->llh_tail.lrt_index = 0;\r\nllh->llh_timestamp = get_seconds();\r\nif (uuid)\r\nmemcpy(&llh->llh_tgtuuid, uuid,\r\nsizeof(llh->llh_tgtuuid));\r\nllh->llh_bitmap_offset = offsetof(typeof(*llh), llh_bitmap);\r\next2_set_bit(0, llh->llh_bitmap);\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nint llog_init_handle(const struct lu_env *env, struct llog_handle *handle,\r\nint flags, struct obd_uuid *uuid)\r\n{\r\nstruct llog_log_hdr *llh;\r\nint rc;\r\nLASSERT(handle->lgh_hdr == NULL);\r\nOBD_ALLOC_PTR(llh);\r\nif (llh == NULL)\r\nreturn -ENOMEM;\r\nhandle->lgh_hdr = llh;\r\nllh->llh_flags = flags;\r\nrc = llog_read_header(env, handle, uuid);\r\nif (rc == 0) {\r\nif (unlikely((llh->llh_flags & LLOG_F_IS_PLAIN &&\r\nflags & LLOG_F_IS_CAT) ||\r\n(llh->llh_flags & LLOG_F_IS_CAT &&\r\nflags & LLOG_F_IS_PLAIN))) {\r\nCERROR("%s: llog type is %s but initializing %s\n",\r\nhandle->lgh_ctxt->loc_obd->obd_name,\r\nllh->llh_flags & LLOG_F_IS_CAT ?\r\n"catalog" : "plain",\r\nflags & LLOG_F_IS_CAT ? "catalog" : "plain");\r\nrc = -EINVAL;\r\ngoto out;\r\n} else if (llh->llh_flags &\r\n(LLOG_F_IS_PLAIN | LLOG_F_IS_CAT)) {\r\nflags = llh->llh_flags;\r\n} else {\r\nCERROR("llog type is not specified!\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (unlikely(uuid &&\r\n!obd_uuid_equals(uuid, &llh->llh_tgtuuid))) {\r\nCERROR("%s: llog uuid mismatch: %s/%s\n",\r\nhandle->lgh_ctxt->loc_obd->obd_name,\r\n(char *)uuid->uuid,\r\n(char *)llh->llh_tgtuuid.uuid);\r\nrc = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nif (flags & LLOG_F_IS_CAT) {\r\nLASSERT(list_empty(&handle->u.chd.chd_head));\r\nINIT_LIST_HEAD(&handle->u.chd.chd_head);\r\nllh->llh_size = sizeof(struct llog_logid_rec);\r\n} else if (!(flags & LLOG_F_IS_PLAIN)) {\r\nCERROR("%s: unknown flags: %#x (expected %#x or %#x)\n",\r\nhandle->lgh_ctxt->loc_obd->obd_name,\r\nflags, LLOG_F_IS_CAT, LLOG_F_IS_PLAIN);\r\nrc = -EINVAL;\r\n}\r\nout:\r\nif (rc) {\r\nOBD_FREE_PTR(llh);\r\nhandle->lgh_hdr = NULL;\r\n}\r\nreturn rc;\r\n}\r\nstatic int llog_process_thread(void *arg)\r\n{\r\nstruct llog_process_info *lpi = arg;\r\nstruct llog_handle *loghandle = lpi->lpi_loghandle;\r\nstruct llog_log_hdr *llh = loghandle->lgh_hdr;\r\nstruct llog_process_cat_data *cd = lpi->lpi_catdata;\r\nchar *buf;\r\n__u64 cur_offset = LLOG_CHUNK_SIZE;\r\n__u64 last_offset;\r\nint rc = 0, index = 1, last_index;\r\nint saved_index = 0;\r\nint last_called_index = 0;\r\nLASSERT(llh);\r\nOBD_ALLOC(buf, LLOG_CHUNK_SIZE);\r\nif (!buf) {\r\nlpi->lpi_rc = -ENOMEM;\r\nreturn 0;\r\n}\r\nif (cd != NULL) {\r\nlast_called_index = cd->lpcd_first_idx;\r\nindex = cd->lpcd_first_idx + 1;\r\n}\r\nif (cd != NULL && cd->lpcd_last_idx)\r\nlast_index = cd->lpcd_last_idx;\r\nelse\r\nlast_index = LLOG_BITMAP_BYTES * 8 - 1;\r\nwhile (rc == 0) {\r\nstruct llog_rec_hdr *rec;\r\nwhile (index <= last_index &&\r\n!ext2_test_bit(index, llh->llh_bitmap))\r\n++index;\r\nLASSERT(index <= last_index + 1);\r\nif (index == last_index + 1)\r\nbreak;\r\nrepeat:\r\nCDEBUG(D_OTHER, "index: %d last_index %d\n",\r\nindex, last_index);\r\nmemset(buf, 0, LLOG_CHUNK_SIZE);\r\nlast_offset = cur_offset;\r\nrc = llog_next_block(lpi->lpi_env, loghandle, &saved_index,\r\nindex, &cur_offset, buf, LLOG_CHUNK_SIZE);\r\nif (rc)\r\ngoto out;\r\nfor (rec = (struct llog_rec_hdr *)buf;\r\n(char *)rec < buf + LLOG_CHUNK_SIZE;\r\nrec = (struct llog_rec_hdr *)((char *)rec + rec->lrh_len)){\r\nCDEBUG(D_OTHER, "processing rec 0x%p type %#x\n",\r\nrec, rec->lrh_type);\r\nif (LLOG_REC_HDR_NEEDS_SWABBING(rec))\r\nlustre_swab_llog_rec(rec);\r\nCDEBUG(D_OTHER, "after swabbing, type=%#x idx=%d\n",\r\nrec->lrh_type, rec->lrh_index);\r\nif (rec->lrh_index == 0) {\r\nrc = 0;\r\nif (index <= loghandle->lgh_last_idx)\r\ngoto repeat;\r\ngoto out;\r\n}\r\nif (rec->lrh_len == 0 ||\r\nrec->lrh_len > LLOG_CHUNK_SIZE) {\r\nCWARN("invalid length %d in llog record for index %d/%d\n",\r\nrec->lrh_len,\r\nrec->lrh_index, index);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (rec->lrh_index < index) {\r\nCDEBUG(D_OTHER, "skipping lrh_index %d\n",\r\nrec->lrh_index);\r\ncontinue;\r\n}\r\nCDEBUG(D_OTHER,\r\n"lrh_index: %d lrh_len: %d (%d remains)\n",\r\nrec->lrh_index, rec->lrh_len,\r\n(int)(buf + LLOG_CHUNK_SIZE - (char *)rec));\r\nloghandle->lgh_cur_idx = rec->lrh_index;\r\nloghandle->lgh_cur_offset = (char *)rec - (char *)buf +\r\nlast_offset;\r\nif (ext2_test_bit(index, llh->llh_bitmap)) {\r\nrc = lpi->lpi_cb(lpi->lpi_env, loghandle, rec,\r\nlpi->lpi_cbdata);\r\nlast_called_index = index;\r\nif (rc == LLOG_PROC_BREAK) {\r\ngoto out;\r\n} else if (rc == LLOG_DEL_RECORD) {\r\nllog_cancel_rec(lpi->lpi_env,\r\nloghandle,\r\nrec->lrh_index);\r\nrc = 0;\r\n}\r\nif (rc)\r\ngoto out;\r\n} else {\r\nCDEBUG(D_OTHER, "Skipped index %d\n", index);\r\n}\r\n++index;\r\nif (index > last_index) {\r\nrc = 0;\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\nif (cd != NULL)\r\ncd->lpcd_last_idx = last_called_index;\r\nOBD_FREE(buf, LLOG_CHUNK_SIZE);\r\nlpi->lpi_rc = rc;\r\nreturn 0;\r\n}\r\nstatic int llog_process_thread_daemonize(void *arg)\r\n{\r\nstruct llog_process_info *lpi = arg;\r\nstruct lu_env env;\r\nint rc;\r\nunshare_fs_struct();\r\nrc = lu_env_init(&env, LCT_LOCAL | LCT_MG_THREAD);\r\nif (rc)\r\ngoto out;\r\nlpi->lpi_env = &env;\r\nrc = llog_process_thread(arg);\r\nlu_env_fini(&env);\r\nout:\r\ncomplete(&lpi->lpi_completion);\r\nreturn rc;\r\n}\r\nint llog_process_or_fork(const struct lu_env *env,\r\nstruct llog_handle *loghandle,\r\nllog_cb_t cb, void *data, void *catdata, bool fork)\r\n{\r\nstruct llog_process_info *lpi;\r\nint rc;\r\nOBD_ALLOC_PTR(lpi);\r\nif (lpi == NULL) {\r\nCERROR("cannot alloc pointer\n");\r\nreturn -ENOMEM;\r\n}\r\nlpi->lpi_loghandle = loghandle;\r\nlpi->lpi_cb = cb;\r\nlpi->lpi_cbdata = data;\r\nlpi->lpi_catdata = catdata;\r\nif (fork) {\r\nlpi->lpi_env = NULL;\r\ninit_completion(&lpi->lpi_completion);\r\nrc = PTR_ERR(kthread_run(llog_process_thread_daemonize, lpi,\r\n"llog_process_thread"));\r\nif (IS_ERR_VALUE(rc)) {\r\nCERROR("%s: cannot start thread: rc = %d\n",\r\nloghandle->lgh_ctxt->loc_obd->obd_name, rc);\r\nOBD_FREE_PTR(lpi);\r\nreturn rc;\r\n}\r\nwait_for_completion(&lpi->lpi_completion);\r\n} else {\r\nlpi->lpi_env = env;\r\nllog_process_thread(lpi);\r\n}\r\nrc = lpi->lpi_rc;\r\nOBD_FREE_PTR(lpi);\r\nreturn rc;\r\n}\r\nint llog_process(const struct lu_env *env, struct llog_handle *loghandle,\r\nllog_cb_t cb, void *data, void *catdata)\r\n{\r\nreturn llog_process_or_fork(env, loghandle, cb, data, catdata, true);\r\n}\r\nint llog_reverse_process(const struct lu_env *env,\r\nstruct llog_handle *loghandle, llog_cb_t cb,\r\nvoid *data, void *catdata)\r\n{\r\nstruct llog_log_hdr *llh = loghandle->lgh_hdr;\r\nstruct llog_process_cat_data *cd = catdata;\r\nvoid *buf;\r\nint rc = 0, first_index = 1, index, idx;\r\nOBD_ALLOC(buf, LLOG_CHUNK_SIZE);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (cd != NULL)\r\nfirst_index = cd->lpcd_first_idx + 1;\r\nif (cd != NULL && cd->lpcd_last_idx)\r\nindex = cd->lpcd_last_idx;\r\nelse\r\nindex = LLOG_BITMAP_BYTES * 8 - 1;\r\nwhile (rc == 0) {\r\nstruct llog_rec_hdr *rec;\r\nstruct llog_rec_tail *tail;\r\nwhile (index >= first_index &&\r\n!ext2_test_bit(index, llh->llh_bitmap))\r\n--index;\r\nLASSERT(index >= first_index - 1);\r\nif (index == first_index - 1)\r\nbreak;\r\nmemset(buf, 0, LLOG_CHUNK_SIZE);\r\nrc = llog_prev_block(env, loghandle, index, buf,\r\nLLOG_CHUNK_SIZE);\r\nif (rc)\r\ngoto out;\r\nrec = buf;\r\nidx = rec->lrh_index;\r\nCDEBUG(D_RPCTRACE, "index %u : idx %u\n", index, idx);\r\nwhile (idx < index) {\r\nrec = (void *)rec + rec->lrh_len;\r\nif (LLOG_REC_HDR_NEEDS_SWABBING(rec))\r\nlustre_swab_llog_rec(rec);\r\nidx ++;\r\n}\r\nLASSERT(idx == index);\r\ntail = (void *)rec + rec->lrh_len - sizeof(*tail);\r\nwhile ((void *)tail > buf) {\r\nif (tail->lrt_index == 0) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nif (ext2_test_bit(index, llh->llh_bitmap)) {\r\nrec = (void *)tail - tail->lrt_len +\r\nsizeof(*tail);\r\nrc = cb(env, loghandle, rec, data);\r\nif (rc == LLOG_PROC_BREAK) {\r\ngoto out;\r\n} else if (rc == LLOG_DEL_RECORD) {\r\nllog_cancel_rec(env, loghandle,\r\ntail->lrt_index);\r\nrc = 0;\r\n}\r\nif (rc)\r\ngoto out;\r\n}\r\n--index;\r\nif (index < first_index) {\r\nrc = 0;\r\ngoto out;\r\n}\r\ntail = (void *)tail - tail->lrt_len;\r\n}\r\n}\r\nout:\r\nif (buf)\r\nOBD_FREE(buf, LLOG_CHUNK_SIZE);\r\nreturn rc;\r\n}\r\nint llog_exist(struct llog_handle *loghandle)\r\n{\r\nstruct llog_operations *lop;\r\nint rc;\r\nrc = llog_handle2ops(loghandle, &lop);\r\nif (rc)\r\nreturn rc;\r\nif (lop->lop_exist == NULL)\r\nreturn -EOPNOTSUPP;\r\nrc = lop->lop_exist(loghandle);\r\nreturn rc;\r\n}\r\nint llog_declare_create(const struct lu_env *env,\r\nstruct llog_handle *loghandle, struct thandle *th)\r\n{\r\nstruct llog_operations *lop;\r\nint raised, rc;\r\nrc = llog_handle2ops(loghandle, &lop);\r\nif (rc)\r\nreturn rc;\r\nif (lop->lop_declare_create == NULL)\r\nreturn -EOPNOTSUPP;\r\nraised = cfs_cap_raised(CFS_CAP_SYS_RESOURCE);\r\nif (!raised)\r\ncfs_cap_raise(CFS_CAP_SYS_RESOURCE);\r\nrc = lop->lop_declare_create(env, loghandle, th);\r\nif (!raised)\r\ncfs_cap_lower(CFS_CAP_SYS_RESOURCE);\r\nreturn rc;\r\n}\r\nint llog_create(const struct lu_env *env, struct llog_handle *handle,\r\nstruct thandle *th)\r\n{\r\nstruct llog_operations *lop;\r\nint raised, rc;\r\nrc = llog_handle2ops(handle, &lop);\r\nif (rc)\r\nreturn rc;\r\nif (lop->lop_create == NULL)\r\nreturn -EOPNOTSUPP;\r\nraised = cfs_cap_raised(CFS_CAP_SYS_RESOURCE);\r\nif (!raised)\r\ncfs_cap_raise(CFS_CAP_SYS_RESOURCE);\r\nrc = lop->lop_create(env, handle, th);\r\nif (!raised)\r\ncfs_cap_lower(CFS_CAP_SYS_RESOURCE);\r\nreturn rc;\r\n}\r\nint llog_declare_write_rec(const struct lu_env *env,\r\nstruct llog_handle *handle,\r\nstruct llog_rec_hdr *rec, int idx,\r\nstruct thandle *th)\r\n{\r\nstruct llog_operations *lop;\r\nint raised, rc;\r\nrc = llog_handle2ops(handle, &lop);\r\nif (rc)\r\nreturn rc;\r\nLASSERT(lop);\r\nif (lop->lop_declare_write_rec == NULL)\r\nreturn -EOPNOTSUPP;\r\nraised = cfs_cap_raised(CFS_CAP_SYS_RESOURCE);\r\nif (!raised)\r\ncfs_cap_raise(CFS_CAP_SYS_RESOURCE);\r\nrc = lop->lop_declare_write_rec(env, handle, rec, idx, th);\r\nif (!raised)\r\ncfs_cap_lower(CFS_CAP_SYS_RESOURCE);\r\nreturn rc;\r\n}\r\nint llog_write_rec(const struct lu_env *env, struct llog_handle *handle,\r\nstruct llog_rec_hdr *rec, struct llog_cookie *logcookies,\r\nint numcookies, void *buf, int idx, struct thandle *th)\r\n{\r\nstruct llog_operations *lop;\r\nint raised, rc, buflen;\r\nrc = llog_handle2ops(handle, &lop);\r\nif (rc)\r\nreturn rc;\r\nLASSERT(lop);\r\nif (lop->lop_write_rec == NULL)\r\nreturn -EOPNOTSUPP;\r\nif (buf)\r\nbuflen = rec->lrh_len + sizeof(struct llog_rec_hdr) +\r\nsizeof(struct llog_rec_tail);\r\nelse\r\nbuflen = rec->lrh_len;\r\nLASSERT(cfs_size_round(buflen) == buflen);\r\nraised = cfs_cap_raised(CFS_CAP_SYS_RESOURCE);\r\nif (!raised)\r\ncfs_cap_raise(CFS_CAP_SYS_RESOURCE);\r\nrc = lop->lop_write_rec(env, handle, rec, logcookies, numcookies,\r\nbuf, idx, th);\r\nif (!raised)\r\ncfs_cap_lower(CFS_CAP_SYS_RESOURCE);\r\nreturn rc;\r\n}\r\nint llog_add(const struct lu_env *env, struct llog_handle *lgh,\r\nstruct llog_rec_hdr *rec, struct llog_cookie *logcookies,\r\nvoid *buf, struct thandle *th)\r\n{\r\nint raised, rc;\r\nif (lgh->lgh_logops->lop_add == NULL)\r\nreturn -EOPNOTSUPP;\r\nraised = cfs_cap_raised(CFS_CAP_SYS_RESOURCE);\r\nif (!raised)\r\ncfs_cap_raise(CFS_CAP_SYS_RESOURCE);\r\nrc = lgh->lgh_logops->lop_add(env, lgh, rec, logcookies, buf, th);\r\nif (!raised)\r\ncfs_cap_lower(CFS_CAP_SYS_RESOURCE);\r\nreturn rc;\r\n}\r\nint llog_declare_add(const struct lu_env *env, struct llog_handle *lgh,\r\nstruct llog_rec_hdr *rec, struct thandle *th)\r\n{\r\nint raised, rc;\r\nif (lgh->lgh_logops->lop_declare_add == NULL)\r\nreturn -EOPNOTSUPP;\r\nraised = cfs_cap_raised(CFS_CAP_SYS_RESOURCE);\r\nif (!raised)\r\ncfs_cap_raise(CFS_CAP_SYS_RESOURCE);\r\nrc = lgh->lgh_logops->lop_declare_add(env, lgh, rec, th);\r\nif (!raised)\r\ncfs_cap_lower(CFS_CAP_SYS_RESOURCE);\r\nreturn rc;\r\n}\r\nint llog_open_create(const struct lu_env *env, struct llog_ctxt *ctxt,\r\nstruct llog_handle **res, struct llog_logid *logid,\r\nchar *name)\r\n{\r\nstruct dt_device *d;\r\nstruct thandle *th;\r\nint rc;\r\nrc = llog_open(env, ctxt, res, logid, name, LLOG_OPEN_NEW);\r\nif (rc)\r\nreturn rc;\r\nif (llog_exist(*res))\r\nreturn 0;\r\nLASSERT((*res)->lgh_obj != NULL);\r\nd = lu2dt_dev((*res)->lgh_obj->do_lu.lo_dev);\r\nth = dt_trans_create(env, d);\r\nif (IS_ERR(th)) {\r\nrc = PTR_ERR(th);\r\ngoto out;\r\n}\r\nrc = llog_declare_create(env, *res, th);\r\nif (rc == 0) {\r\nrc = dt_trans_start_local(env, d, th);\r\nif (rc == 0)\r\nrc = llog_create(env, *res, th);\r\n}\r\ndt_trans_stop(env, d, th);\r\nout:\r\nif (rc)\r\nllog_close(env, *res);\r\nreturn rc;\r\n}\r\nint llog_erase(const struct lu_env *env, struct llog_ctxt *ctxt,\r\nstruct llog_logid *logid, char *name)\r\n{\r\nstruct llog_handle *handle;\r\nint rc = 0, rc2;\r\nif (name == NULL && logid == NULL)\r\nreturn 0;\r\nrc = llog_open(env, ctxt, &handle, logid, name, LLOG_OPEN_EXISTS);\r\nif (rc < 0)\r\nreturn rc;\r\nrc = llog_init_handle(env, handle, LLOG_F_IS_PLAIN, NULL);\r\nif (rc == 0)\r\nrc = llog_destroy(env, handle);\r\nrc2 = llog_close(env, handle);\r\nif (rc == 0)\r\nrc = rc2;\r\nreturn rc;\r\n}\r\nint llog_write(const struct lu_env *env, struct llog_handle *loghandle,\r\nstruct llog_rec_hdr *rec, struct llog_cookie *reccookie,\r\nint cookiecount, void *buf, int idx)\r\n{\r\nstruct dt_device *dt;\r\nstruct thandle *th;\r\nint rc;\r\nLASSERT(loghandle);\r\nLASSERT(loghandle->lgh_ctxt);\r\nLASSERT(loghandle->lgh_obj != NULL);\r\ndt = lu2dt_dev(loghandle->lgh_obj->do_lu.lo_dev);\r\nth = dt_trans_create(env, dt);\r\nif (IS_ERR(th))\r\nreturn PTR_ERR(th);\r\nrc = llog_declare_write_rec(env, loghandle, rec, idx, th);\r\nif (rc)\r\ngoto out_trans;\r\nrc = dt_trans_start_local(env, dt, th);\r\nif (rc)\r\ngoto out_trans;\r\ndown_write(&loghandle->lgh_lock);\r\nrc = llog_write_rec(env, loghandle, rec, reccookie,\r\ncookiecount, buf, idx, th);\r\nup_write(&loghandle->lgh_lock);\r\nout_trans:\r\ndt_trans_stop(env, dt, th);\r\nreturn rc;\r\n}\r\nint llog_open(const struct lu_env *env, struct llog_ctxt *ctxt,\r\nstruct llog_handle **lgh, struct llog_logid *logid,\r\nchar *name, enum llog_open_param open_param)\r\n{\r\nint raised;\r\nint rc;\r\nLASSERT(ctxt);\r\nLASSERT(ctxt->loc_logops);\r\nif (ctxt->loc_logops->lop_open == NULL) {\r\n*lgh = NULL;\r\nreturn -EOPNOTSUPP;\r\n}\r\n*lgh = llog_alloc_handle();\r\nif (*lgh == NULL)\r\nreturn -ENOMEM;\r\n(*lgh)->lgh_ctxt = ctxt;\r\n(*lgh)->lgh_logops = ctxt->loc_logops;\r\nraised = cfs_cap_raised(CFS_CAP_SYS_RESOURCE);\r\nif (!raised)\r\ncfs_cap_raise(CFS_CAP_SYS_RESOURCE);\r\nrc = ctxt->loc_logops->lop_open(env, *lgh, logid, name, open_param);\r\nif (!raised)\r\ncfs_cap_lower(CFS_CAP_SYS_RESOURCE);\r\nif (rc) {\r\nllog_free_handle(*lgh);\r\n*lgh = NULL;\r\n}\r\nreturn rc;\r\n}\r\nint llog_close(const struct lu_env *env, struct llog_handle *loghandle)\r\n{\r\nstruct llog_operations *lop;\r\nint rc;\r\nrc = llog_handle2ops(loghandle, &lop);\r\nif (rc)\r\ngoto out;\r\nif (lop->lop_close == NULL) {\r\nrc = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nrc = lop->lop_close(env, loghandle);\r\nout:\r\nllog_handle_put(loghandle);\r\nreturn rc;\r\n}\r\nint llog_is_empty(const struct lu_env *env, struct llog_ctxt *ctxt,\r\nchar *name)\r\n{\r\nstruct llog_handle *llh;\r\nint rc = 0;\r\nrc = llog_open(env, ctxt, &llh, NULL, name, LLOG_OPEN_EXISTS);\r\nif (rc < 0) {\r\nif (likely(rc == -ENOENT))\r\nrc = 0;\r\ngoto out;\r\n}\r\nrc = llog_init_handle(env, llh, LLOG_F_IS_PLAIN, NULL);\r\nif (rc)\r\ngoto out_close;\r\nrc = llog_get_size(llh);\r\nout_close:\r\nllog_close(env, llh);\r\nout:\r\nreturn rc <= 1;\r\n}\r\nint llog_copy_handler(const struct lu_env *env, struct llog_handle *llh,\r\nstruct llog_rec_hdr *rec, void *data)\r\n{\r\nstruct llog_handle *copy_llh = data;\r\nreturn llog_write(env, copy_llh, rec, NULL, 0, NULL, -1);\r\n}\r\nint llog_backup(const struct lu_env *env, struct obd_device *obd,\r\nstruct llog_ctxt *ctxt, struct llog_ctxt *bctxt,\r\nchar *name, char *backup)\r\n{\r\nstruct llog_handle *llh, *bllh;\r\nint rc;\r\nrc = llog_open(env, ctxt, &llh, NULL, name, LLOG_OPEN_EXISTS);\r\nif (rc < 0) {\r\nif (rc != -ENOENT)\r\nCERROR("%s: failed to open log %s: rc = %d\n",\r\nobd->obd_name, name, rc);\r\nreturn rc;\r\n}\r\nrc = llog_init_handle(env, llh, LLOG_F_IS_PLAIN, NULL);\r\nif (rc)\r\ngoto out_close;\r\nrc = llog_erase(env, bctxt, NULL, backup);\r\nif (rc < 0 && rc != -ENOENT)\r\ngoto out_close;\r\nrc = llog_open_create(env, bctxt, &bllh, NULL, backup);\r\nif (rc) {\r\nCERROR("%s: failed to open backup logfile %s: rc = %d\n",\r\nobd->obd_name, backup, rc);\r\ngoto out_close;\r\n}\r\nif (llh->lgh_obj == bllh->lgh_obj) {\r\nCERROR("%s: backup llog %s to itself (%s), objects %p/%p\n",\r\nobd->obd_name, name, backup, llh->lgh_obj,\r\nbllh->lgh_obj);\r\nrc = -EEXIST;\r\ngoto out_backup;\r\n}\r\nrc = llog_init_handle(env, bllh, LLOG_F_IS_PLAIN, NULL);\r\nif (rc)\r\ngoto out_backup;\r\nrc = llog_process_or_fork(env, llh, llog_copy_handler, (void *)bllh,\r\nNULL, false);\r\nif (rc)\r\nCERROR("%s: failed to backup log %s: rc = %d\n",\r\nobd->obd_name, name, rc);\r\nout_backup:\r\nllog_close(env, bllh);\r\nout_close:\r\nllog_close(env, llh);\r\nreturn rc;\r\n}
