static struct bpf_map *array_map_alloc(union bpf_attr *attr)\r\n{\r\nstruct bpf_array *array;\r\nu32 elem_size, array_size;\r\nif (attr->max_entries == 0 || attr->key_size != 4 ||\r\nattr->value_size == 0)\r\nreturn ERR_PTR(-EINVAL);\r\nelem_size = round_up(attr->value_size, 8);\r\nif (elem_size == 0 ||\r\nattr->max_entries > (U32_MAX - sizeof(*array)) / elem_size)\r\nreturn ERR_PTR(-ENOMEM);\r\narray_size = sizeof(*array) + attr->max_entries * elem_size;\r\narray = kzalloc(array_size, GFP_USER | __GFP_NOWARN);\r\nif (!array) {\r\narray = vzalloc(array_size);\r\nif (!array)\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\narray->map.key_size = attr->key_size;\r\narray->map.value_size = attr->value_size;\r\narray->map.max_entries = attr->max_entries;\r\narray->elem_size = elem_size;\r\nreturn &array->map;\r\n}\r\nstatic void *array_map_lookup_elem(struct bpf_map *map, void *key)\r\n{\r\nstruct bpf_array *array = container_of(map, struct bpf_array, map);\r\nu32 index = *(u32 *)key;\r\nif (index >= array->map.max_entries)\r\nreturn NULL;\r\nreturn array->value + array->elem_size * index;\r\n}\r\nstatic int array_map_get_next_key(struct bpf_map *map, void *key, void *next_key)\r\n{\r\nstruct bpf_array *array = container_of(map, struct bpf_array, map);\r\nu32 index = *(u32 *)key;\r\nu32 *next = (u32 *)next_key;\r\nif (index >= array->map.max_entries) {\r\n*next = 0;\r\nreturn 0;\r\n}\r\nif (index == array->map.max_entries - 1)\r\nreturn -ENOENT;\r\n*next = index + 1;\r\nreturn 0;\r\n}\r\nstatic int array_map_update_elem(struct bpf_map *map, void *key, void *value,\r\nu64 map_flags)\r\n{\r\nstruct bpf_array *array = container_of(map, struct bpf_array, map);\r\nu32 index = *(u32 *)key;\r\nif (map_flags > BPF_EXIST)\r\nreturn -EINVAL;\r\nif (index >= array->map.max_entries)\r\nreturn -E2BIG;\r\nif (map_flags == BPF_NOEXIST)\r\nreturn -EEXIST;\r\nmemcpy(array->value + array->elem_size * index, value, array->elem_size);\r\nreturn 0;\r\n}\r\nstatic int array_map_delete_elem(struct bpf_map *map, void *key)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic void array_map_free(struct bpf_map *map)\r\n{\r\nstruct bpf_array *array = container_of(map, struct bpf_array, map);\r\nsynchronize_rcu();\r\nkvfree(array);\r\n}\r\nstatic int __init register_array_map(void)\r\n{\r\nbpf_register_map_type(&tl);\r\nreturn 0;\r\n}
