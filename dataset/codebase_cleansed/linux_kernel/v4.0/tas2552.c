static void tas2552_sw_shutdown(struct tas2552_data *tas_data, int sw_shutdown)\r\n{\r\nu8 cfg1_reg;\r\nif (sw_shutdown)\r\ncfg1_reg = 0;\r\nelse\r\ncfg1_reg = TAS2552_SWS_MASK;\r\nsnd_soc_update_bits(tas_data->codec, TAS2552_CFG_1,\r\nTAS2552_SWS_MASK, cfg1_reg);\r\n}\r\nstatic int tas2552_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct tas2552_data *tas2552 = dev_get_drvdata(codec->dev);\r\nint sample_rate, pll_clk;\r\nint d;\r\nu8 p, j;\r\nif (!tas2552->mclk)\r\nreturn -EINVAL;\r\nsnd_soc_update_bits(codec, TAS2552_CFG_2, TAS2552_PLL_ENABLE, 0);\r\nif (tas2552->mclk == TAS2552_245MHZ_CLK ||\r\ntas2552->mclk == TAS2552_225MHZ_CLK) {\r\nsnd_soc_update_bits(codec, TAS2552_PLL_CTRL_2,\r\nTAS2552_PLL_BYPASS_MASK,\r\nTAS2552_PLL_BYPASS);\r\n} else {\r\np = snd_soc_read(codec, TAS2552_PLL_CTRL_1);\r\np = (p >> 7);\r\nsample_rate = params_rate(params);\r\nif (sample_rate == 48000)\r\npll_clk = TAS2552_245MHZ_CLK;\r\nelse if (sample_rate == 44100)\r\npll_clk = TAS2552_225MHZ_CLK;\r\nelse {\r\ndev_vdbg(codec->dev, "Substream sample rate is not found %i\n",\r\nparams_rate(params));\r\nreturn -EINVAL;\r\n}\r\nj = (pll_clk * 2 * (1 << p)) / tas2552->mclk;\r\nd = (pll_clk * 2 * (1 << p)) % tas2552->mclk;\r\nsnd_soc_update_bits(codec, TAS2552_PLL_CTRL_1,\r\nTAS2552_PLL_J_MASK, j);\r\nsnd_soc_write(codec, TAS2552_PLL_CTRL_2,\r\n(d >> 7) & TAS2552_PLL_D_UPPER_MASK);\r\nsnd_soc_write(codec, TAS2552_PLL_CTRL_3,\r\nd & TAS2552_PLL_D_LOWER_MASK);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tas2552_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 serial_format;\r\nu8 serial_control_mask;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nserial_format = 0x00;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nserial_format = TAS2552_WORD_CLK_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nserial_format = TAS2552_BIT_CLK_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nserial_format = (TAS2552_BIT_CLK_MASK | TAS2552_WORD_CLK_MASK);\r\nbreak;\r\ndefault:\r\ndev_vdbg(codec->dev, "DAI Format master is not found\n");\r\nreturn -EINVAL;\r\n}\r\nserial_control_mask = TAS2552_BIT_CLK_MASK | TAS2552_WORD_CLK_MASK;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nserial_format &= TAS2552_DAIFMT_I2S_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nserial_format |= TAS2552_DAIFMT_DSP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nserial_format |= TAS2552_DAIFMT_RIGHT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nserial_format |= TAS2552_DAIFMT_LEFT_J;\r\nbreak;\r\ndefault:\r\ndev_vdbg(codec->dev, "DAI Format is not found\n");\r\nreturn -EINVAL;\r\n}\r\nif (fmt & SND_SOC_DAIFMT_FORMAT_MASK)\r\nserial_control_mask |= TAS2552_DATA_FORMAT_MASK;\r\nsnd_soc_update_bits(codec, TAS2552_SER_CTRL_1, serial_control_mask,\r\nserial_format);\r\nreturn 0;\r\n}\r\nstatic int tas2552_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct tas2552_data *tas2552 = dev_get_drvdata(codec->dev);\r\ntas2552->mclk = freq;\r\nreturn 0;\r\n}\r\nstatic int tas2552_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nu8 cfg1_reg;\r\nstruct snd_soc_codec *codec = dai->codec;\r\nif (mute)\r\ncfg1_reg = TAS2552_MUTE_MASK;\r\nelse\r\ncfg1_reg = ~TAS2552_MUTE_MASK;\r\nsnd_soc_update_bits(codec, TAS2552_CFG_1, TAS2552_MUTE_MASK, cfg1_reg);\r\nreturn 0;\r\n}\r\nstatic int tas2552_runtime_suspend(struct device *dev)\r\n{\r\nstruct tas2552_data *tas2552 = dev_get_drvdata(dev);\r\ntas2552_sw_shutdown(tas2552, 0);\r\nregcache_cache_only(tas2552->regmap, true);\r\nregcache_mark_dirty(tas2552->regmap);\r\nif (tas2552->enable_gpio)\r\ngpiod_set_value(tas2552->enable_gpio, 0);\r\nreturn 0;\r\n}\r\nstatic int tas2552_runtime_resume(struct device *dev)\r\n{\r\nstruct tas2552_data *tas2552 = dev_get_drvdata(dev);\r\nif (tas2552->enable_gpio)\r\ngpiod_set_value(tas2552->enable_gpio, 1);\r\ntas2552_sw_shutdown(tas2552, 1);\r\nregcache_cache_only(tas2552->regmap, false);\r\nregcache_sync(tas2552->regmap);\r\nreturn 0;\r\n}\r\nstatic int tas2552_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct tas2552_data *tas2552 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\ntas2552->codec = codec;\r\nret = regulator_bulk_enable(ARRAY_SIZE(tas2552->supplies),\r\ntas2552->supplies);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to enable supplies: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (tas2552->enable_gpio)\r\ngpiod_set_value(tas2552->enable_gpio, 1);\r\nret = pm_runtime_get_sync(codec->dev);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Enabling device failed: %d\n",\r\nret);\r\ngoto probe_fail;\r\n}\r\nsnd_soc_write(codec, TAS2552_CFG_1, TAS2552_MUTE_MASK |\r\nTAS2552_PLL_SRC_BCLK);\r\nsnd_soc_write(codec, TAS2552_CFG_3, TAS2552_I2S_OUT_SEL |\r\nTAS2552_DIN_SRC_SEL_AVG_L_R | TAS2552_88_96KHZ);\r\nsnd_soc_write(codec, TAS2552_DOUT, TAS2552_PDM_DATA_I);\r\nsnd_soc_write(codec, TAS2552_OUTPUT_DATA, TAS2552_PDM_DATA_V_I | 0x8);\r\nsnd_soc_write(codec, TAS2552_PDM_CFG, TAS2552_PDM_BCLK_SEL);\r\nsnd_soc_write(codec, TAS2552_BOOST_PT_CTRL, TAS2552_APT_DELAY_200 |\r\nTAS2552_APT_THRESH_2_1_7);\r\nret = regmap_register_patch(tas2552->regmap, tas2552_init_regs,\r\nARRAY_SIZE(tas2552_init_regs));\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to write init registers: %d\n",\r\nret);\r\ngoto patch_fail;\r\n}\r\nsnd_soc_write(codec, TAS2552_CFG_2, TAS2552_BOOST_EN |\r\nTAS2552_APT_EN | TAS2552_LIM_EN);\r\nreturn 0;\r\npatch_fail:\r\npm_runtime_put(codec->dev);\r\nprobe_fail:\r\nif (tas2552->enable_gpio)\r\ngpiod_set_value(tas2552->enable_gpio, 0);\r\nregulator_bulk_disable(ARRAY_SIZE(tas2552->supplies),\r\ntas2552->supplies);\r\nreturn -EIO;\r\n}\r\nstatic int tas2552_codec_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct tas2552_data *tas2552 = snd_soc_codec_get_drvdata(codec);\r\npm_runtime_put(codec->dev);\r\nif (tas2552->enable_gpio)\r\ngpiod_set_value(tas2552->enable_gpio, 0);\r\nreturn 0;\r\n}\r\nstatic int tas2552_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct tas2552_data *tas2552 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = regulator_bulk_disable(ARRAY_SIZE(tas2552->supplies),\r\ntas2552->supplies);\r\nif (ret != 0)\r\ndev_err(codec->dev, "Failed to disable supplies: %d\n",\r\nret);\r\nreturn 0;\r\n}\r\nstatic int tas2552_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct tas2552_data *tas2552 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(tas2552->supplies),\r\ntas2552->supplies);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to enable supplies: %d\n",\r\nret);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tas2552_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev;\r\nstruct tas2552_data *data;\r\nint ret;\r\nint i;\r\ndev = &client->dev;\r\ndata = devm_kzalloc(&client->dev, sizeof(*data), GFP_KERNEL);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\ndata->enable_gpio = devm_gpiod_get(dev, "enable");\r\nif (IS_ERR(data->enable_gpio)) {\r\nret = PTR_ERR(data->enable_gpio);\r\nif (ret != -ENOENT && ret != -ENOSYS)\r\nreturn ret;\r\ndata->enable_gpio = NULL;\r\n} else {\r\ngpiod_direction_output(data->enable_gpio, 0);\r\n}\r\ndata->tas2552_client = client;\r\ndata->regmap = devm_regmap_init_i2c(client, &tas2552_regmap_config);\r\nif (IS_ERR(data->regmap)) {\r\nret = PTR_ERR(data->regmap);\r\ndev_err(&client->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->supplies); i++)\r\ndata->supplies[i].supply = tas2552_supply_names[i];\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(data->supplies),\r\ndata->supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\npm_runtime_set_active(&client->dev);\r\npm_runtime_set_autosuspend_delay(&client->dev, 1000);\r\npm_runtime_use_autosuspend(&client->dev);\r\npm_runtime_enable(&client->dev);\r\npm_runtime_mark_last_busy(&client->dev);\r\npm_runtime_put_sync_autosuspend(&client->dev);\r\ndev_set_drvdata(&client->dev, data);\r\nret = snd_soc_register_codec(&client->dev,\r\n&soc_codec_dev_tas2552,\r\ntas2552_dai, ARRAY_SIZE(tas2552_dai));\r\nif (ret < 0)\r\ndev_err(&client->dev, "Failed to register codec: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int tas2552_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
