__le32 *rt2800mmio_get_txwi(struct queue_entry *entry)\r\n{\r\nreturn (__le32 *) entry->skb->data;\r\n}\r\nvoid rt2800mmio_write_tx_desc(struct queue_entry *entry,\r\nstruct txentry_desc *txdesc)\r\n{\r\nstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\r\nstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\r\n__le32 *txd = entry_priv->desc;\r\nu32 word;\r\nconst unsigned int txwi_size = entry->queue->winfo_size;\r\nword = 0;\r\nrt2x00_set_field32(&word, TXD_W0_SD_PTR0, skbdesc->skb_dma);\r\nrt2x00_desc_write(txd, 0, word);\r\nword = 0;\r\nrt2x00_set_field32(&word, TXD_W1_SD_LEN1, entry->skb->len);\r\nrt2x00_set_field32(&word, TXD_W1_LAST_SEC1,\r\n!test_bit(ENTRY_TXD_MORE_FRAG, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W1_BURST,\r\ntest_bit(ENTRY_TXD_BURST, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W1_SD_LEN0, txwi_size);\r\nrt2x00_set_field32(&word, TXD_W1_LAST_SEC0, 0);\r\nrt2x00_set_field32(&word, TXD_W1_DMA_DONE, 0);\r\nrt2x00_desc_write(txd, 1, word);\r\nword = 0;\r\nrt2x00_set_field32(&word, TXD_W2_SD_PTR1,\r\nskbdesc->skb_dma + txwi_size);\r\nrt2x00_desc_write(txd, 2, word);\r\nword = 0;\r\nrt2x00_set_field32(&word, TXD_W3_WIV,\r\n!test_bit(ENTRY_TXD_ENCRYPT_IV, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W3_QSEL, 2);\r\nrt2x00_desc_write(txd, 3, word);\r\nskbdesc->desc = txd;\r\nskbdesc->desc_len = TXD_DESC_SIZE;\r\n}\r\nvoid rt2800mmio_fill_rxdone(struct queue_entry *entry,\r\nstruct rxdone_entry_desc *rxdesc)\r\n{\r\nstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\r\n__le32 *rxd = entry_priv->desc;\r\nu32 word;\r\nrt2x00_desc_read(rxd, 3, &word);\r\nif (rt2x00_get_field32(word, RXD_W3_CRC_ERROR))\r\nrxdesc->flags |= RX_FLAG_FAILED_FCS_CRC;\r\nrxdesc->cipher_status = rt2x00_get_field32(word, RXD_W3_CIPHER_ERROR);\r\nif (rt2x00_get_field32(word, RXD_W3_DECRYPTED)) {\r\nrxdesc->flags |= RX_FLAG_IV_STRIPPED;\r\nrxdesc->flags |= RX_FLAG_MMIC_STRIPPED;\r\nif (rxdesc->cipher_status == RX_CRYPTO_SUCCESS)\r\nrxdesc->flags |= RX_FLAG_DECRYPTED;\r\nelse if (rxdesc->cipher_status == RX_CRYPTO_FAIL_MIC)\r\nrxdesc->flags |= RX_FLAG_MMIC_ERROR;\r\n}\r\nif (rt2x00_get_field32(word, RXD_W3_MY_BSS))\r\nrxdesc->dev_flags |= RXDONE_MY_BSS;\r\nif (rt2x00_get_field32(word, RXD_W3_L2PAD))\r\nrxdesc->dev_flags |= RXDONE_L2PAD;\r\nrt2800_process_rxwi(entry, rxdesc);\r\n}\r\nstatic void rt2800mmio_wakeup(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct ieee80211_conf conf = { .flags = 0 };\r\nstruct rt2x00lib_conf libconf = { .conf = &conf };\r\nrt2800_config(rt2x00dev, &libconf, IEEE80211_CONF_CHANGE_PS);\r\n}\r\nstatic bool rt2800mmio_txdone_entry_check(struct queue_entry *entry, u32 status)\r\n{\r\n__le32 *txwi;\r\nu32 word;\r\nint wcid, tx_wcid;\r\nwcid = rt2x00_get_field32(status, TX_STA_FIFO_WCID);\r\ntxwi = rt2800_drv_get_txwi(entry);\r\nrt2x00_desc_read(txwi, 1, &word);\r\ntx_wcid = rt2x00_get_field32(word, TXWI_W1_WIRELESS_CLI_ID);\r\nreturn (tx_wcid == wcid);\r\n}\r\nstatic bool rt2800mmio_txdone_find_entry(struct queue_entry *entry, void *data)\r\n{\r\nu32 status = *(u32 *)data;\r\nif (rt2800mmio_txdone_entry_check(entry, status) &&\r\n!test_bit(ENTRY_DATA_STATUS_SET, &entry->flags)) {\r\nentry->status = status;\r\nset_bit(ENTRY_DATA_STATUS_SET, &entry->flags);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool rt2800mmio_txdone_match_first(struct queue_entry *entry, void *data)\r\n{\r\nu32 status = *(u32 *)data;\r\nif (!test_bit(ENTRY_DATA_STATUS_SET, &entry->flags)) {\r\nentry->status = status;\r\nset_bit(ENTRY_DATA_STATUS_SET, &entry->flags);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool rt2800mmio_txdone_release_entries(struct queue_entry *entry,\r\nvoid *data)\r\n{\r\nif (test_bit(ENTRY_DATA_STATUS_SET, &entry->flags)) {\r\nrt2800_txdone_entry(entry, entry->status,\r\nrt2800mmio_get_txwi(entry));\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool rt2800mmio_txdone(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct data_queue *queue;\r\nu32 status;\r\nu8 qid;\r\nint max_tx_done = 16;\r\nwhile (kfifo_get(&rt2x00dev->txstatus_fifo, &status)) {\r\nqid = rt2x00_get_field32(status, TX_STA_FIFO_PID_QUEUE);\r\nif (unlikely(qid >= QID_RX)) {\r\nrt2x00_warn(rt2x00dev, "Got TX status report with unexpected pid %u, dropping\n",\r\nqid);\r\nbreak;\r\n}\r\nqueue = rt2x00queue_get_tx_queue(rt2x00dev, qid);\r\nif (unlikely(queue == NULL)) {\r\nrt2x00_warn(rt2x00dev, "Got TX status for an unavailable queue %u, dropping\n",\r\nqid);\r\nbreak;\r\n}\r\nif (unlikely(rt2x00queue_empty(queue))) {\r\nrt2x00_warn(rt2x00dev, "Got TX status for an empty queue %u, dropping\n",\r\nqid);\r\nbreak;\r\n}\r\nif (!rt2x00queue_for_each_entry(queue, Q_INDEX_DONE,\r\nQ_INDEX, &status,\r\nrt2800mmio_txdone_find_entry)) {\r\nif (!rt2x00queue_for_each_entry(queue, Q_INDEX_DONE,\r\nQ_INDEX, &status,\r\nrt2800mmio_txdone_match_first)) {\r\nrt2x00_warn(rt2x00dev, "No frame found for TX status on queue %u, dropping\n",\r\nqid);\r\nbreak;\r\n}\r\n}\r\nrt2x00queue_for_each_entry(queue, Q_INDEX_DONE,\r\nQ_INDEX, NULL,\r\nrt2800mmio_txdone_release_entries);\r\nif (--max_tx_done == 0)\r\nbreak;\r\n}\r\nreturn !max_tx_done;\r\n}\r\nstatic inline void rt2800mmio_enable_interrupt(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00_field32 irq_field)\r\n{\r\nu32 reg;\r\nspin_lock_irq(&rt2x00dev->irqmask_lock);\r\nrt2x00mmio_register_read(rt2x00dev, INT_MASK_CSR, &reg);\r\nrt2x00_set_field32(&reg, irq_field, 1);\r\nrt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);\r\nspin_unlock_irq(&rt2x00dev->irqmask_lock);\r\n}\r\nvoid rt2800mmio_txstatus_tasklet(unsigned long data)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;\r\nif (rt2800mmio_txdone(rt2x00dev))\r\ntasklet_schedule(&rt2x00dev->txstatus_tasklet);\r\n}\r\nvoid rt2800mmio_pretbtt_tasklet(unsigned long data)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;\r\nrt2x00lib_pretbtt(rt2x00dev);\r\nif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nrt2800mmio_enable_interrupt(rt2x00dev, INT_MASK_CSR_PRE_TBTT);\r\n}\r\nvoid rt2800mmio_tbtt_tasklet(unsigned long data)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;\r\nstruct rt2800_drv_data *drv_data = rt2x00dev->drv_data;\r\nu32 reg;\r\nrt2x00lib_beacondone(rt2x00dev);\r\nif (rt2x00dev->intf_ap_count) {\r\nif (drv_data->tbtt_tick == (BCN_TBTT_OFFSET - 2)) {\r\nrt2x00mmio_register_read(rt2x00dev, BCN_TIME_CFG, &reg);\r\nrt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_INTERVAL,\r\n(rt2x00dev->beacon_int * 16) - 1);\r\nrt2x00mmio_register_write(rt2x00dev, BCN_TIME_CFG, reg);\r\n} else if (drv_data->tbtt_tick == (BCN_TBTT_OFFSET - 1)) {\r\nrt2x00mmio_register_read(rt2x00dev, BCN_TIME_CFG, &reg);\r\nrt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_INTERVAL,\r\n(rt2x00dev->beacon_int * 16));\r\nrt2x00mmio_register_write(rt2x00dev, BCN_TIME_CFG, reg);\r\n}\r\ndrv_data->tbtt_tick++;\r\ndrv_data->tbtt_tick %= BCN_TBTT_OFFSET;\r\n}\r\nif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nrt2800mmio_enable_interrupt(rt2x00dev, INT_MASK_CSR_TBTT);\r\n}\r\nvoid rt2800mmio_rxdone_tasklet(unsigned long data)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;\r\nif (rt2x00mmio_rxdone(rt2x00dev))\r\ntasklet_schedule(&rt2x00dev->rxdone_tasklet);\r\nelse if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nrt2800mmio_enable_interrupt(rt2x00dev, INT_MASK_CSR_RX_DONE);\r\n}\r\nvoid rt2800mmio_autowake_tasklet(unsigned long data)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;\r\nrt2800mmio_wakeup(rt2x00dev);\r\nif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nrt2800mmio_enable_interrupt(rt2x00dev,\r\nINT_MASK_CSR_AUTO_WAKEUP);\r\n}\r\nstatic void rt2800mmio_txstatus_interrupt(struct rt2x00_dev *rt2x00dev)\r\n{\r\nu32 status;\r\nint i;\r\nfor (i = 0; i < rt2x00dev->tx->limit; i++) {\r\nrt2x00mmio_register_read(rt2x00dev, TX_STA_FIFO, &status);\r\nif (!rt2x00_get_field32(status, TX_STA_FIFO_VALID))\r\nbreak;\r\nif (!kfifo_put(&rt2x00dev->txstatus_fifo, status)) {\r\nrt2x00_warn(rt2x00dev, "TX status FIFO overrun, drop tx status report\n");\r\nbreak;\r\n}\r\n}\r\ntasklet_schedule(&rt2x00dev->txstatus_tasklet);\r\n}\r\nirqreturn_t rt2800mmio_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = dev_instance;\r\nu32 reg, mask;\r\nrt2x00mmio_register_read(rt2x00dev, INT_SOURCE_CSR, &reg);\r\nrt2x00mmio_register_write(rt2x00dev, INT_SOURCE_CSR, reg);\r\nif (!reg)\r\nreturn IRQ_NONE;\r\nif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nreturn IRQ_HANDLED;\r\nmask = ~reg;\r\nif (rt2x00_get_field32(reg, INT_SOURCE_CSR_TX_FIFO_STATUS)) {\r\nrt2800mmio_txstatus_interrupt(rt2x00dev);\r\nrt2x00_set_field32(&mask, INT_MASK_CSR_TX_FIFO_STATUS, 1);\r\n}\r\nif (rt2x00_get_field32(reg, INT_SOURCE_CSR_PRE_TBTT))\r\ntasklet_hi_schedule(&rt2x00dev->pretbtt_tasklet);\r\nif (rt2x00_get_field32(reg, INT_SOURCE_CSR_TBTT))\r\ntasklet_hi_schedule(&rt2x00dev->tbtt_tasklet);\r\nif (rt2x00_get_field32(reg, INT_SOURCE_CSR_RX_DONE))\r\ntasklet_schedule(&rt2x00dev->rxdone_tasklet);\r\nif (rt2x00_get_field32(reg, INT_SOURCE_CSR_AUTO_WAKEUP))\r\ntasklet_schedule(&rt2x00dev->autowake_tasklet);\r\nspin_lock(&rt2x00dev->irqmask_lock);\r\nrt2x00mmio_register_read(rt2x00dev, INT_MASK_CSR, &reg);\r\nreg &= mask;\r\nrt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);\r\nspin_unlock(&rt2x00dev->irqmask_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid rt2800mmio_toggle_irq(struct rt2x00_dev *rt2x00dev,\r\nenum dev_state state)\r\n{\r\nu32 reg;\r\nunsigned long flags;\r\nif (state == STATE_RADIO_IRQ_ON) {\r\nrt2x00mmio_register_read(rt2x00dev, INT_SOURCE_CSR, &reg);\r\nrt2x00mmio_register_write(rt2x00dev, INT_SOURCE_CSR, reg);\r\n}\r\nspin_lock_irqsave(&rt2x00dev->irqmask_lock, flags);\r\nreg = 0;\r\nif (state == STATE_RADIO_IRQ_ON) {\r\nrt2x00_set_field32(&reg, INT_MASK_CSR_RX_DONE, 1);\r\nrt2x00_set_field32(&reg, INT_MASK_CSR_TBTT, 1);\r\nrt2x00_set_field32(&reg, INT_MASK_CSR_PRE_TBTT, 1);\r\nrt2x00_set_field32(&reg, INT_MASK_CSR_TX_FIFO_STATUS, 1);\r\nrt2x00_set_field32(&reg, INT_MASK_CSR_AUTO_WAKEUP, 1);\r\n}\r\nrt2x00mmio_register_write(rt2x00dev, INT_MASK_CSR, reg);\r\nspin_unlock_irqrestore(&rt2x00dev->irqmask_lock, flags);\r\nif (state == STATE_RADIO_IRQ_OFF) {\r\ntasklet_kill(&rt2x00dev->txstatus_tasklet);\r\ntasklet_kill(&rt2x00dev->rxdone_tasklet);\r\ntasklet_kill(&rt2x00dev->autowake_tasklet);\r\ntasklet_kill(&rt2x00dev->tbtt_tasklet);\r\ntasklet_kill(&rt2x00dev->pretbtt_tasklet);\r\n}\r\n}\r\nvoid rt2800mmio_start_queue(struct data_queue *queue)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\r\nu32 reg;\r\nswitch (queue->qid) {\r\ncase QID_RX:\r\nrt2x00mmio_register_read(rt2x00dev, MAC_SYS_CTRL, &reg);\r\nrt2x00_set_field32(&reg, MAC_SYS_CTRL_ENABLE_RX, 1);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_SYS_CTRL, reg);\r\nbreak;\r\ncase QID_BEACON:\r\nrt2x00mmio_register_read(rt2x00dev, BCN_TIME_CFG, &reg);\r\nrt2x00_set_field32(&reg, BCN_TIME_CFG_TSF_TICKING, 1);\r\nrt2x00_set_field32(&reg, BCN_TIME_CFG_TBTT_ENABLE, 1);\r\nrt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_GEN, 1);\r\nrt2x00mmio_register_write(rt2x00dev, BCN_TIME_CFG, reg);\r\nrt2x00mmio_register_read(rt2x00dev, INT_TIMER_EN, &reg);\r\nrt2x00_set_field32(&reg, INT_TIMER_EN_PRE_TBTT_TIMER, 1);\r\nrt2x00mmio_register_write(rt2x00dev, INT_TIMER_EN, reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid rt2800mmio_kick_queue(struct data_queue *queue)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\r\nstruct queue_entry *entry;\r\nswitch (queue->qid) {\r\ncase QID_AC_VO:\r\ncase QID_AC_VI:\r\ncase QID_AC_BE:\r\ncase QID_AC_BK:\r\nentry = rt2x00queue_get_entry(queue, Q_INDEX);\r\nrt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX(queue->qid),\r\nentry->entry_idx);\r\nbreak;\r\ncase QID_MGMT:\r\nentry = rt2x00queue_get_entry(queue, Q_INDEX);\r\nrt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX(5),\r\nentry->entry_idx);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid rt2800mmio_stop_queue(struct data_queue *queue)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\r\nu32 reg;\r\nswitch (queue->qid) {\r\ncase QID_RX:\r\nrt2x00mmio_register_read(rt2x00dev, MAC_SYS_CTRL, &reg);\r\nrt2x00_set_field32(&reg, MAC_SYS_CTRL_ENABLE_RX, 0);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_SYS_CTRL, reg);\r\nbreak;\r\ncase QID_BEACON:\r\nrt2x00mmio_register_read(rt2x00dev, BCN_TIME_CFG, &reg);\r\nrt2x00_set_field32(&reg, BCN_TIME_CFG_TSF_TICKING, 0);\r\nrt2x00_set_field32(&reg, BCN_TIME_CFG_TBTT_ENABLE, 0);\r\nrt2x00_set_field32(&reg, BCN_TIME_CFG_BEACON_GEN, 0);\r\nrt2x00mmio_register_write(rt2x00dev, BCN_TIME_CFG, reg);\r\nrt2x00mmio_register_read(rt2x00dev, INT_TIMER_EN, &reg);\r\nrt2x00_set_field32(&reg, INT_TIMER_EN_PRE_TBTT_TIMER, 0);\r\nrt2x00mmio_register_write(rt2x00dev, INT_TIMER_EN, reg);\r\ntasklet_kill(&rt2x00dev->tbtt_tasklet);\r\ntasklet_kill(&rt2x00dev->pretbtt_tasklet);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid rt2800mmio_queue_init(struct data_queue *queue)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\r\nunsigned short txwi_size, rxwi_size;\r\nrt2800_get_txwi_rxwi_size(rt2x00dev, &txwi_size, &rxwi_size);\r\nswitch (queue->qid) {\r\ncase QID_RX:\r\nqueue->limit = 128;\r\nqueue->data_size = AGGREGATION_SIZE;\r\nqueue->desc_size = RXD_DESC_SIZE;\r\nqueue->winfo_size = rxwi_size;\r\nqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\r\nbreak;\r\ncase QID_AC_VO:\r\ncase QID_AC_VI:\r\ncase QID_AC_BE:\r\ncase QID_AC_BK:\r\nqueue->limit = 64;\r\nqueue->data_size = AGGREGATION_SIZE;\r\nqueue->desc_size = TXD_DESC_SIZE;\r\nqueue->winfo_size = txwi_size;\r\nqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\r\nbreak;\r\ncase QID_BEACON:\r\nqueue->limit = 8;\r\nqueue->data_size = 0;\r\nqueue->desc_size = TXD_DESC_SIZE;\r\nqueue->winfo_size = txwi_size;\r\nqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\r\nbreak;\r\ncase QID_ATIM:\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\n}\r\nbool rt2800mmio_get_entry_state(struct queue_entry *entry)\r\n{\r\nstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\r\nu32 word;\r\nif (entry->queue->qid == QID_RX) {\r\nrt2x00_desc_read(entry_priv->desc, 1, &word);\r\nreturn (!rt2x00_get_field32(word, RXD_W1_DMA_DONE));\r\n} else {\r\nrt2x00_desc_read(entry_priv->desc, 1, &word);\r\nreturn (!rt2x00_get_field32(word, TXD_W1_DMA_DONE));\r\n}\r\n}\r\nvoid rt2800mmio_clear_entry(struct queue_entry *entry)\r\n{\r\nstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\r\nstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\r\nstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\r\nu32 word;\r\nif (entry->queue->qid == QID_RX) {\r\nrt2x00_desc_read(entry_priv->desc, 0, &word);\r\nrt2x00_set_field32(&word, RXD_W0_SDP0, skbdesc->skb_dma);\r\nrt2x00_desc_write(entry_priv->desc, 0, word);\r\nrt2x00_desc_read(entry_priv->desc, 1, &word);\r\nrt2x00_set_field32(&word, RXD_W1_DMA_DONE, 0);\r\nrt2x00_desc_write(entry_priv->desc, 1, word);\r\nrt2x00mmio_register_write(rt2x00dev, RX_CRX_IDX,\r\nentry->entry_idx);\r\n} else {\r\nrt2x00_desc_read(entry_priv->desc, 1, &word);\r\nrt2x00_set_field32(&word, TXD_W1_DMA_DONE, 1);\r\nrt2x00_desc_write(entry_priv->desc, 1, word);\r\n}\r\n}\r\nint rt2800mmio_init_queues(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct queue_entry_priv_mmio *entry_priv;\r\nentry_priv = rt2x00dev->tx[0].entries[0].priv_data;\r\nrt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR0,\r\nentry_priv->desc_dma);\r\nrt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT0,\r\nrt2x00dev->tx[0].limit);\r\nrt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX0, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX0, 0);\r\nentry_priv = rt2x00dev->tx[1].entries[0].priv_data;\r\nrt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR1,\r\nentry_priv->desc_dma);\r\nrt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT1,\r\nrt2x00dev->tx[1].limit);\r\nrt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX1, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX1, 0);\r\nentry_priv = rt2x00dev->tx[2].entries[0].priv_data;\r\nrt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR2,\r\nentry_priv->desc_dma);\r\nrt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT2,\r\nrt2x00dev->tx[2].limit);\r\nrt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX2, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX2, 0);\r\nentry_priv = rt2x00dev->tx[3].entries[0].priv_data;\r\nrt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR3,\r\nentry_priv->desc_dma);\r\nrt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT3,\r\nrt2x00dev->tx[3].limit);\r\nrt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX3, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX3, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR4, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT4, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX4, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX4, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR5, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT5, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX5, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX5, 0);\r\nentry_priv = rt2x00dev->rx->entries[0].priv_data;\r\nrt2x00mmio_register_write(rt2x00dev, RX_BASE_PTR,\r\nentry_priv->desc_dma);\r\nrt2x00mmio_register_write(rt2x00dev, RX_MAX_CNT,\r\nrt2x00dev->rx[0].limit);\r\nrt2x00mmio_register_write(rt2x00dev, RX_CRX_IDX,\r\nrt2x00dev->rx[0].limit - 1);\r\nrt2x00mmio_register_write(rt2x00dev, RX_DRX_IDX, 0);\r\nrt2800_disable_wpdma(rt2x00dev);\r\nrt2x00mmio_register_write(rt2x00dev, DELAY_INT_CFG, 0);\r\nreturn 0;\r\n}\r\nint rt2800mmio_init_registers(struct rt2x00_dev *rt2x00dev)\r\n{\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, WPDMA_RST_IDX, &reg);\r\nrt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX0, 1);\r\nrt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX1, 1);\r\nrt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX2, 1);\r\nrt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX3, 1);\r\nrt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX4, 1);\r\nrt2x00_set_field32(&reg, WPDMA_RST_IDX_DTX_IDX5, 1);\r\nrt2x00_set_field32(&reg, WPDMA_RST_IDX_DRX_IDX0, 1);\r\nrt2x00mmio_register_write(rt2x00dev, WPDMA_RST_IDX, reg);\r\nrt2x00mmio_register_write(rt2x00dev, PBF_SYS_CTRL, 0x00000e1f);\r\nrt2x00mmio_register_write(rt2x00dev, PBF_SYS_CTRL, 0x00000e00);\r\nif (rt2x00_is_pcie(rt2x00dev) &&\r\n(rt2x00_rt(rt2x00dev, RT3090) ||\r\nrt2x00_rt(rt2x00dev, RT3390) ||\r\nrt2x00_rt(rt2x00dev, RT3572) ||\r\nrt2x00_rt(rt2x00dev, RT3593) ||\r\nrt2x00_rt(rt2x00dev, RT5390) ||\r\nrt2x00_rt(rt2x00dev, RT5392) ||\r\nrt2x00_rt(rt2x00dev, RT5592))) {\r\nrt2x00mmio_register_read(rt2x00dev, AUX_CTRL, &reg);\r\nrt2x00_set_field32(&reg, AUX_CTRL_FORCE_PCIE_CLK, 1);\r\nrt2x00_set_field32(&reg, AUX_CTRL_WAKE_PCIE_EN, 1);\r\nrt2x00mmio_register_write(rt2x00dev, AUX_CTRL, reg);\r\n}\r\nrt2x00mmio_register_write(rt2x00dev, PWR_PIN_CFG, 0x00000003);\r\nreg = 0;\r\nrt2x00_set_field32(&reg, MAC_SYS_CTRL_RESET_CSR, 1);\r\nrt2x00_set_field32(&reg, MAC_SYS_CTRL_RESET_BBP, 1);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_SYS_CTRL, reg);\r\nrt2x00mmio_register_write(rt2x00dev, MAC_SYS_CTRL, 0x00000000);\r\nreturn 0;\r\n}\r\nint rt2800mmio_enable_radio(struct rt2x00_dev *rt2x00dev)\r\n{\r\nrt2800_wait_wpdma_ready(rt2x00dev);\r\nif (unlikely(rt2800mmio_init_queues(rt2x00dev)))\r\nreturn -EIO;\r\nreturn rt2800_enable_radio(rt2x00dev);\r\n}
