static int ili210x_read_reg(struct i2c_client *client, u8 reg, void *buf,\r\nsize_t len)\r\n{\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &reg,\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = buf,\r\n}\r\n};\r\nif (i2c_transfer(client->adapter, msg, 2) != 2) {\r\ndev_err(&client->dev, "i2c transfer failed\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ili210x_report_events(struct input_dev *input,\r\nconst struct touchdata *touchdata)\r\n{\r\nint i;\r\nbool touch;\r\nunsigned int x, y;\r\nconst struct finger *finger;\r\nfor (i = 0; i < MAX_TOUCHES; i++) {\r\ninput_mt_slot(input, i);\r\nfinger = &touchdata->finger[i];\r\ntouch = touchdata->status & (1 << i);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, touch);\r\nif (touch) {\r\nx = finger->x_low | (finger->x_high << 8);\r\ny = finger->y_low | (finger->y_high << 8);\r\ninput_report_abs(input, ABS_MT_POSITION_X, x);\r\ninput_report_abs(input, ABS_MT_POSITION_Y, y);\r\n}\r\n}\r\ninput_mt_report_pointer_emulation(input, false);\r\ninput_sync(input);\r\n}\r\nstatic bool get_pendown_state(const struct ili210x *priv)\r\n{\r\nbool state = false;\r\nif (priv->get_pendown_state)\r\nstate = priv->get_pendown_state();\r\nreturn state;\r\n}\r\nstatic void ili210x_work(struct work_struct *work)\r\n{\r\nstruct ili210x *priv = container_of(work, struct ili210x,\r\ndwork.work);\r\nstruct i2c_client *client = priv->client;\r\nstruct touchdata touchdata;\r\nint error;\r\nerror = ili210x_read_reg(client, REG_TOUCHDATA,\r\n&touchdata, sizeof(touchdata));\r\nif (error) {\r\ndev_err(&client->dev,\r\n"Unable to get touchdata, err = %d\n", error);\r\nreturn;\r\n}\r\nili210x_report_events(priv->input, &touchdata);\r\nif ((touchdata.status & 0xf3) || get_pendown_state(priv))\r\nschedule_delayed_work(&priv->dwork,\r\nmsecs_to_jiffies(priv->poll_period));\r\n}\r\nstatic irqreturn_t ili210x_irq(int irq, void *irq_data)\r\n{\r\nstruct ili210x *priv = irq_data;\r\nschedule_delayed_work(&priv->dwork, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic ssize_t ili210x_calibrate(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct ili210x *priv = i2c_get_clientdata(client);\r\nunsigned long calibrate;\r\nint rc;\r\nu8 cmd = REG_CALIBRATE;\r\nif (kstrtoul(buf, 10, &calibrate))\r\nreturn -EINVAL;\r\nif (calibrate > 1)\r\nreturn -EINVAL;\r\nif (calibrate) {\r\nrc = i2c_master_send(priv->client, &cmd, sizeof(cmd));\r\nif (rc != sizeof(cmd))\r\nreturn -EIO;\r\n}\r\nreturn count;\r\n}\r\nstatic int ili210x_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nconst struct ili210x_platform_data *pdata = dev_get_platdata(dev);\r\nstruct ili210x *priv;\r\nstruct input_dev *input;\r\nstruct panel_info panel;\r\nstruct firmware_version firmware;\r\nint xmax, ymax;\r\nint error;\r\ndev_dbg(dev, "Probing for ILI210X I2C Touschreen driver");\r\nif (!pdata) {\r\ndev_err(dev, "No platform data!\n");\r\nreturn -EINVAL;\r\n}\r\nif (client->irq <= 0) {\r\ndev_err(dev, "No IRQ!\n");\r\nreturn -EINVAL;\r\n}\r\nerror = ili210x_read_reg(client, REG_FIRMWARE_VERSION,\r\n&firmware, sizeof(firmware));\r\nif (error) {\r\ndev_err(dev, "Failed to get firmware version, err: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = ili210x_read_reg(client, REG_PANEL_INFO, &panel, sizeof(panel));\r\nif (error) {\r\ndev_err(dev, "Failed to get panel informations, err: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nxmax = panel.finger_max.x_low | (panel.finger_max.x_high << 8);\r\nymax = panel.finger_max.y_low | (panel.finger_max.y_high << 8);\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!priv || !input) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\npriv->client = client;\r\npriv->input = input;\r\npriv->get_pendown_state = pdata->get_pendown_state;\r\npriv->poll_period = pdata->poll_period ? : DEFAULT_POLL_PERIOD;\r\nINIT_DELAYED_WORK(&priv->dwork, ili210x_work);\r\ninput->name = "ILI210x Touchscreen";\r\ninput->id.bustype = BUS_I2C;\r\ninput->dev.parent = dev;\r\n__set_bit(EV_SYN, input->evbit);\r\n__set_bit(EV_KEY, input->evbit);\r\n__set_bit(EV_ABS, input->evbit);\r\n__set_bit(BTN_TOUCH, input->keybit);\r\ninput_set_abs_params(input, ABS_X, 0, xmax, 0, 0);\r\ninput_set_abs_params(input, ABS_Y, 0, ymax, 0, 0);\r\ninput_mt_init_slots(input, MAX_TOUCHES, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_X, 0, xmax, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y, 0, ymax, 0, 0);\r\ninput_set_drvdata(input, priv);\r\ni2c_set_clientdata(client, priv);\r\nerror = request_irq(client->irq, ili210x_irq, pdata->irq_flags,\r\nclient->name, priv);\r\nif (error) {\r\ndev_err(dev, "Unable to request touchscreen IRQ, err: %d\n",\r\nerror);\r\ngoto err_free_mem;\r\n}\r\nerror = sysfs_create_group(&dev->kobj, &ili210x_attr_group);\r\nif (error) {\r\ndev_err(dev, "Unable to create sysfs attributes, err: %d\n",\r\nerror);\r\ngoto err_free_irq;\r\n}\r\nerror = input_register_device(priv->input);\r\nif (error) {\r\ndev_err(dev, "Cannot regiser input device, err: %d\n", error);\r\ngoto err_remove_sysfs;\r\n}\r\ndevice_init_wakeup(&client->dev, 1);\r\ndev_dbg(dev,\r\n"ILI210x initialized (IRQ: %d), firmware version %d.%d.%d",\r\nclient->irq, firmware.id, firmware.major, firmware.minor);\r\nreturn 0;\r\nerr_remove_sysfs:\r\nsysfs_remove_group(&dev->kobj, &ili210x_attr_group);\r\nerr_free_irq:\r\nfree_irq(client->irq, priv);\r\nerr_free_mem:\r\ninput_free_device(input);\r\nkfree(priv);\r\nreturn error;\r\n}\r\nstatic int ili210x_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct ili210x *priv = i2c_get_clientdata(client);\r\nsysfs_remove_group(&client->dev.kobj, &ili210x_attr_group);\r\nfree_irq(priv->client->irq, priv);\r\ncancel_delayed_work_sync(&priv->dwork);\r\ninput_unregister_device(priv->input);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused ili210x_i2c_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nif (device_may_wakeup(&client->dev))\r\nenable_irq_wake(client->irq);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused ili210x_i2c_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nif (device_may_wakeup(&client->dev))\r\ndisable_irq_wake(client->irq);\r\nreturn 0;\r\n}
