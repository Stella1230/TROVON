static void zfcp_fsf_request_timeout_handler(unsigned long data)\r\n{\r\nstruct zfcp_adapter *adapter = (struct zfcp_adapter *) data;\r\nzfcp_qdio_siosl(adapter);\r\nzfcp_erp_adapter_reopen(adapter, ZFCP_STATUS_COMMON_ERP_FAILED,\r\n"fsrth_1");\r\n}\r\nstatic void zfcp_fsf_start_timer(struct zfcp_fsf_req *fsf_req,\r\nunsigned long timeout)\r\n{\r\nfsf_req->timer.function = zfcp_fsf_request_timeout_handler;\r\nfsf_req->timer.data = (unsigned long) fsf_req->adapter;\r\nfsf_req->timer.expires = jiffies + timeout;\r\nadd_timer(&fsf_req->timer);\r\n}\r\nstatic void zfcp_fsf_start_erp_timer(struct zfcp_fsf_req *fsf_req)\r\n{\r\nBUG_ON(!fsf_req->erp_action);\r\nfsf_req->timer.function = zfcp_erp_timeout_handler;\r\nfsf_req->timer.data = (unsigned long) fsf_req->erp_action;\r\nfsf_req->timer.expires = jiffies + 30 * HZ;\r\nadd_timer(&fsf_req->timer);\r\n}\r\nstatic void zfcp_fsf_class_not_supp(struct zfcp_fsf_req *req)\r\n{\r\ndev_err(&req->adapter->ccw_device->dev, "FCP device not "\r\n"operational because of an unsupported FC class\n");\r\nzfcp_erp_adapter_shutdown(req->adapter, 0, "fscns_1");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\n}\r\nvoid zfcp_fsf_req_free(struct zfcp_fsf_req *req)\r\n{\r\nif (likely(req->pool)) {\r\nif (likely(req->qtcb))\r\nmempool_free(req->qtcb, req->adapter->pool.qtcb_pool);\r\nmempool_free(req, req->pool);\r\nreturn;\r\n}\r\nif (likely(req->qtcb))\r\nkmem_cache_free(zfcp_fsf_qtcb_cache, req->qtcb);\r\nkfree(req);\r\n}\r\nstatic void zfcp_fsf_status_read_port_closed(struct zfcp_fsf_req *req)\r\n{\r\nunsigned long flags;\r\nstruct fsf_status_read_buffer *sr_buf = req->data;\r\nstruct zfcp_adapter *adapter = req->adapter;\r\nstruct zfcp_port *port;\r\nint d_id = ntoh24(sr_buf->d_id);\r\nread_lock_irqsave(&adapter->port_list_lock, flags);\r\nlist_for_each_entry(port, &adapter->port_list, list)\r\nif (port->d_id == d_id) {\r\nzfcp_erp_port_reopen(port, 0, "fssrpc1");\r\nbreak;\r\n}\r\nread_unlock_irqrestore(&adapter->port_list_lock, flags);\r\n}\r\nstatic void zfcp_fsf_link_down_info_eval(struct zfcp_fsf_req *req,\r\nstruct fsf_link_down_info *link_down)\r\n{\r\nstruct zfcp_adapter *adapter = req->adapter;\r\nif (atomic_read(&adapter->status) & ZFCP_STATUS_ADAPTER_LINK_UNPLUGGED)\r\nreturn;\r\natomic_set_mask(ZFCP_STATUS_ADAPTER_LINK_UNPLUGGED, &adapter->status);\r\nzfcp_scsi_schedule_rports_block(adapter);\r\nif (!link_down)\r\ngoto out;\r\nswitch (link_down->error_code) {\r\ncase FSF_PSQ_LINK_NO_LIGHT:\r\ndev_warn(&req->adapter->ccw_device->dev,\r\n"There is no light signal from the local "\r\n"fibre channel cable\n");\r\nbreak;\r\ncase FSF_PSQ_LINK_WRAP_PLUG:\r\ndev_warn(&req->adapter->ccw_device->dev,\r\n"There is a wrap plug instead of a fibre "\r\n"channel cable\n");\r\nbreak;\r\ncase FSF_PSQ_LINK_NO_FCP:\r\ndev_warn(&req->adapter->ccw_device->dev,\r\n"The adjacent fibre channel node does not "\r\n"support FCP\n");\r\nbreak;\r\ncase FSF_PSQ_LINK_FIRMWARE_UPDATE:\r\ndev_warn(&req->adapter->ccw_device->dev,\r\n"The FCP device is suspended because of a "\r\n"firmware update\n");\r\nbreak;\r\ncase FSF_PSQ_LINK_INVALID_WWPN:\r\ndev_warn(&req->adapter->ccw_device->dev,\r\n"The FCP device detected a WWPN that is "\r\n"duplicate or not valid\n");\r\nbreak;\r\ncase FSF_PSQ_LINK_NO_NPIV_SUPPORT:\r\ndev_warn(&req->adapter->ccw_device->dev,\r\n"The fibre channel fabric does not support NPIV\n");\r\nbreak;\r\ncase FSF_PSQ_LINK_NO_FCP_RESOURCES:\r\ndev_warn(&req->adapter->ccw_device->dev,\r\n"The FCP adapter cannot support more NPIV ports\n");\r\nbreak;\r\ncase FSF_PSQ_LINK_NO_FABRIC_RESOURCES:\r\ndev_warn(&req->adapter->ccw_device->dev,\r\n"The adjacent switch cannot support "\r\n"more NPIV ports\n");\r\nbreak;\r\ncase FSF_PSQ_LINK_FABRIC_LOGIN_UNABLE:\r\ndev_warn(&req->adapter->ccw_device->dev,\r\n"The FCP adapter could not log in to the "\r\n"fibre channel fabric\n");\r\nbreak;\r\ncase FSF_PSQ_LINK_WWPN_ASSIGNMENT_CORRUPTED:\r\ndev_warn(&req->adapter->ccw_device->dev,\r\n"The WWPN assignment file on the FCP adapter "\r\n"has been damaged\n");\r\nbreak;\r\ncase FSF_PSQ_LINK_MODE_TABLE_CURRUPTED:\r\ndev_warn(&req->adapter->ccw_device->dev,\r\n"The mode table on the FCP adapter "\r\n"has been damaged\n");\r\nbreak;\r\ncase FSF_PSQ_LINK_NO_WWPN_ASSIGNMENT:\r\ndev_warn(&req->adapter->ccw_device->dev,\r\n"All NPIV ports on the FCP adapter have "\r\n"been assigned\n");\r\nbreak;\r\ndefault:\r\ndev_warn(&req->adapter->ccw_device->dev,\r\n"The link between the FCP adapter and "\r\n"the FC fabric is down\n");\r\n}\r\nout:\r\nzfcp_erp_set_adapter_status(adapter, ZFCP_STATUS_COMMON_ERP_FAILED);\r\n}\r\nstatic void zfcp_fsf_status_read_link_down(struct zfcp_fsf_req *req)\r\n{\r\nstruct fsf_status_read_buffer *sr_buf = req->data;\r\nstruct fsf_link_down_info *ldi =\r\n(struct fsf_link_down_info *) &sr_buf->payload;\r\nswitch (sr_buf->status_subtype) {\r\ncase FSF_STATUS_READ_SUB_NO_PHYSICAL_LINK:\r\nzfcp_fsf_link_down_info_eval(req, ldi);\r\nbreak;\r\ncase FSF_STATUS_READ_SUB_FDISC_FAILED:\r\nzfcp_fsf_link_down_info_eval(req, ldi);\r\nbreak;\r\ncase FSF_STATUS_READ_SUB_FIRMWARE_UPDATE:\r\nzfcp_fsf_link_down_info_eval(req, NULL);\r\n};\r\n}\r\nstatic void zfcp_fsf_status_read_handler(struct zfcp_fsf_req *req)\r\n{\r\nstruct zfcp_adapter *adapter = req->adapter;\r\nstruct fsf_status_read_buffer *sr_buf = req->data;\r\nif (req->status & ZFCP_STATUS_FSFREQ_DISMISSED) {\r\nzfcp_dbf_hba_fsf_uss("fssrh_1", req);\r\nmempool_free(virt_to_page(sr_buf), adapter->pool.sr_data);\r\nzfcp_fsf_req_free(req);\r\nreturn;\r\n}\r\nzfcp_dbf_hba_fsf_uss("fssrh_4", req);\r\nswitch (sr_buf->status_type) {\r\ncase FSF_STATUS_READ_PORT_CLOSED:\r\nzfcp_fsf_status_read_port_closed(req);\r\nbreak;\r\ncase FSF_STATUS_READ_INCOMING_ELS:\r\nzfcp_fc_incoming_els(req);\r\nbreak;\r\ncase FSF_STATUS_READ_SENSE_DATA_AVAIL:\r\nbreak;\r\ncase FSF_STATUS_READ_BIT_ERROR_THRESHOLD:\r\ndev_warn(&adapter->ccw_device->dev,\r\n"The error threshold for checksum statistics "\r\n"has been exceeded\n");\r\nzfcp_dbf_hba_bit_err("fssrh_3", req);\r\nbreak;\r\ncase FSF_STATUS_READ_LINK_DOWN:\r\nzfcp_fsf_status_read_link_down(req);\r\nzfcp_fc_enqueue_event(adapter, FCH_EVT_LINKDOWN, 0);\r\nbreak;\r\ncase FSF_STATUS_READ_LINK_UP:\r\ndev_info(&adapter->ccw_device->dev,\r\n"The local link has been restored\n");\r\nzfcp_erp_set_adapter_status(adapter,\r\nZFCP_STATUS_COMMON_RUNNING);\r\nzfcp_erp_adapter_reopen(adapter,\r\nZFCP_STATUS_ADAPTER_LINK_UNPLUGGED |\r\nZFCP_STATUS_COMMON_ERP_FAILED,\r\n"fssrh_2");\r\nzfcp_fc_enqueue_event(adapter, FCH_EVT_LINKUP, 0);\r\nbreak;\r\ncase FSF_STATUS_READ_NOTIFICATION_LOST:\r\nif (sr_buf->status_subtype & FSF_STATUS_READ_SUB_INCOMING_ELS)\r\nzfcp_fc_conditional_port_scan(adapter);\r\nbreak;\r\ncase FSF_STATUS_READ_FEATURE_UPDATE_ALERT:\r\nadapter->adapter_features = sr_buf->payload.word[0];\r\nbreak;\r\n}\r\nmempool_free(virt_to_page(sr_buf), adapter->pool.sr_data);\r\nzfcp_fsf_req_free(req);\r\natomic_inc(&adapter->stat_miss);\r\nqueue_work(adapter->work_queue, &adapter->stat_work);\r\n}\r\nstatic void zfcp_fsf_fsfstatus_qual_eval(struct zfcp_fsf_req *req)\r\n{\r\nswitch (req->qtcb->header.fsf_status_qual.word[0]) {\r\ncase FSF_SQ_FCP_RSP_AVAILABLE:\r\ncase FSF_SQ_INVOKE_LINK_TEST_PROCEDURE:\r\ncase FSF_SQ_NO_RETRY_POSSIBLE:\r\ncase FSF_SQ_ULP_DEPENDENT_ERP_REQUIRED:\r\nreturn;\r\ncase FSF_SQ_COMMAND_ABORTED:\r\nbreak;\r\ncase FSF_SQ_NO_RECOM:\r\ndev_err(&req->adapter->ccw_device->dev,\r\n"The FCP adapter reported a problem "\r\n"that cannot be recovered\n");\r\nzfcp_qdio_siosl(req->adapter);\r\nzfcp_erp_adapter_shutdown(req->adapter, 0, "fsfsqe1");\r\nbreak;\r\n}\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\n}\r\nstatic void zfcp_fsf_fsfstatus_eval(struct zfcp_fsf_req *req)\r\n{\r\nif (unlikely(req->status & ZFCP_STATUS_FSFREQ_ERROR))\r\nreturn;\r\nswitch (req->qtcb->header.fsf_status) {\r\ncase FSF_UNKNOWN_COMMAND:\r\ndev_err(&req->adapter->ccw_device->dev,\r\n"The FCP adapter does not recognize the command 0x%x\n",\r\nreq->qtcb->header.fsf_command);\r\nzfcp_erp_adapter_shutdown(req->adapter, 0, "fsfse_1");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_ADAPTER_STATUS_AVAILABLE:\r\nzfcp_fsf_fsfstatus_qual_eval(req);\r\nbreak;\r\n}\r\n}\r\nstatic void zfcp_fsf_protstatus_eval(struct zfcp_fsf_req *req)\r\n{\r\nstruct zfcp_adapter *adapter = req->adapter;\r\nstruct fsf_qtcb *qtcb = req->qtcb;\r\nunion fsf_prot_status_qual *psq = &qtcb->prefix.prot_status_qual;\r\nzfcp_dbf_hba_fsf_response(req);\r\nif (req->status & ZFCP_STATUS_FSFREQ_DISMISSED) {\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nreturn;\r\n}\r\nswitch (qtcb->prefix.prot_status) {\r\ncase FSF_PROT_GOOD:\r\ncase FSF_PROT_FSF_STATUS_PRESENTED:\r\nreturn;\r\ncase FSF_PROT_QTCB_VERSION_ERROR:\r\ndev_err(&adapter->ccw_device->dev,\r\n"QTCB version 0x%x not supported by FCP adapter "\r\n"(0x%x to 0x%x)\n", FSF_QTCB_CURRENT_VERSION,\r\npsq->word[0], psq->word[1]);\r\nzfcp_erp_adapter_shutdown(adapter, 0, "fspse_1");\r\nbreak;\r\ncase FSF_PROT_ERROR_STATE:\r\ncase FSF_PROT_SEQ_NUMB_ERROR:\r\nzfcp_erp_adapter_reopen(adapter, 0, "fspse_2");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_PROT_UNSUPP_QTCB_TYPE:\r\ndev_err(&adapter->ccw_device->dev,\r\n"The QTCB type is not supported by the FCP adapter\n");\r\nzfcp_erp_adapter_shutdown(adapter, 0, "fspse_3");\r\nbreak;\r\ncase FSF_PROT_HOST_CONNECTION_INITIALIZING:\r\natomic_set_mask(ZFCP_STATUS_ADAPTER_HOST_CON_INIT,\r\n&adapter->status);\r\nbreak;\r\ncase FSF_PROT_DUPLICATE_REQUEST_ID:\r\ndev_err(&adapter->ccw_device->dev,\r\n"0x%Lx is an ambiguous request identifier\n",\r\n(unsigned long long)qtcb->bottom.support.req_handle);\r\nzfcp_erp_adapter_shutdown(adapter, 0, "fspse_4");\r\nbreak;\r\ncase FSF_PROT_LINK_DOWN:\r\nzfcp_fsf_link_down_info_eval(req, &psq->link_down_info);\r\nzfcp_erp_adapter_reopen(adapter, 0, "fspse_6");\r\nbreak;\r\ncase FSF_PROT_REEST_QUEUE:\r\nzfcp_erp_set_adapter_status(adapter,\r\nZFCP_STATUS_COMMON_RUNNING);\r\nzfcp_erp_adapter_reopen(adapter,\r\nZFCP_STATUS_ADAPTER_LINK_UNPLUGGED |\r\nZFCP_STATUS_COMMON_ERP_FAILED,\r\n"fspse_8");\r\nbreak;\r\ndefault:\r\ndev_err(&adapter->ccw_device->dev,\r\n"0x%x is not a valid transfer protocol status\n",\r\nqtcb->prefix.prot_status);\r\nzfcp_qdio_siosl(adapter);\r\nzfcp_erp_adapter_shutdown(adapter, 0, "fspse_9");\r\n}\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\n}\r\nstatic void zfcp_fsf_req_complete(struct zfcp_fsf_req *req)\r\n{\r\nif (unlikely(req->fsf_command == FSF_QTCB_UNSOLICITED_STATUS)) {\r\nzfcp_fsf_status_read_handler(req);\r\nreturn;\r\n}\r\ndel_timer(&req->timer);\r\nzfcp_fsf_protstatus_eval(req);\r\nzfcp_fsf_fsfstatus_eval(req);\r\nreq->handler(req);\r\nif (req->erp_action)\r\nzfcp_erp_notify(req->erp_action, 0);\r\nif (likely(req->status & ZFCP_STATUS_FSFREQ_CLEANUP))\r\nzfcp_fsf_req_free(req);\r\nelse\r\ncomplete(&req->completion);\r\n}\r\nvoid zfcp_fsf_req_dismiss_all(struct zfcp_adapter *adapter)\r\n{\r\nstruct zfcp_fsf_req *req, *tmp;\r\nLIST_HEAD(remove_queue);\r\nBUG_ON(atomic_read(&adapter->status) & ZFCP_STATUS_ADAPTER_QDIOUP);\r\nzfcp_reqlist_move(adapter->req_list, &remove_queue);\r\nlist_for_each_entry_safe(req, tmp, &remove_queue, list) {\r\nlist_del(&req->list);\r\nreq->status |= ZFCP_STATUS_FSFREQ_DISMISSED;\r\nzfcp_fsf_req_complete(req);\r\n}\r\n}\r\nstatic u32 zfcp_fsf_convert_portspeed(u32 fsf_speed)\r\n{\r\nu32 fdmi_speed = 0;\r\nif (fsf_speed & ZFCP_FSF_PORTSPEED_1GBIT)\r\nfdmi_speed |= FC_PORTSPEED_1GBIT;\r\nif (fsf_speed & ZFCP_FSF_PORTSPEED_2GBIT)\r\nfdmi_speed |= FC_PORTSPEED_2GBIT;\r\nif (fsf_speed & ZFCP_FSF_PORTSPEED_4GBIT)\r\nfdmi_speed |= FC_PORTSPEED_4GBIT;\r\nif (fsf_speed & ZFCP_FSF_PORTSPEED_10GBIT)\r\nfdmi_speed |= FC_PORTSPEED_10GBIT;\r\nif (fsf_speed & ZFCP_FSF_PORTSPEED_8GBIT)\r\nfdmi_speed |= FC_PORTSPEED_8GBIT;\r\nif (fsf_speed & ZFCP_FSF_PORTSPEED_16GBIT)\r\nfdmi_speed |= FC_PORTSPEED_16GBIT;\r\nif (fsf_speed & ZFCP_FSF_PORTSPEED_NOT_NEGOTIATED)\r\nfdmi_speed |= FC_PORTSPEED_NOT_NEGOTIATED;\r\nreturn fdmi_speed;\r\n}\r\nstatic int zfcp_fsf_exchange_config_evaluate(struct zfcp_fsf_req *req)\r\n{\r\nstruct fsf_qtcb_bottom_config *bottom = &req->qtcb->bottom.config;\r\nstruct zfcp_adapter *adapter = req->adapter;\r\nstruct Scsi_Host *shost = adapter->scsi_host;\r\nstruct fc_els_flogi *nsp, *plogi;\r\nnsp = (struct fc_els_flogi *) ((u8 *)&bottom->nport_serv_param\r\n- sizeof(u32));\r\nplogi = (struct fc_els_flogi *) ((u8 *)&bottom->plogi_payload\r\n- sizeof(u32));\r\nif (req->data)\r\nmemcpy(req->data, bottom, sizeof(*bottom));\r\nfc_host_port_name(shost) = nsp->fl_wwpn;\r\nfc_host_node_name(shost) = nsp->fl_wwnn;\r\nfc_host_supported_classes(shost) = FC_COS_CLASS2 | FC_COS_CLASS3;\r\nadapter->timer_ticks = bottom->timer_interval & ZFCP_FSF_TIMER_INT_MASK;\r\nadapter->stat_read_buf_num = max(bottom->status_read_buf_num,\r\n(u16)FSF_STATUS_READS_RECOM);\r\nif (fc_host_permanent_port_name(shost) == -1)\r\nfc_host_permanent_port_name(shost) = fc_host_port_name(shost);\r\nzfcp_scsi_set_prot(adapter);\r\nif (req->qtcb->header.fsf_status == FSF_EXCHANGE_CONFIG_DATA_INCOMPLETE)\r\nreturn 0;\r\nfc_host_port_id(shost) = ntoh24(bottom->s_id);\r\nfc_host_speed(shost) =\r\nzfcp_fsf_convert_portspeed(bottom->fc_link_speed);\r\nadapter->hydra_version = bottom->adapter_type;\r\nswitch (bottom->fc_topology) {\r\ncase FSF_TOPO_P2P:\r\nadapter->peer_d_id = ntoh24(bottom->peer_d_id);\r\nadapter->peer_wwpn = plogi->fl_wwpn;\r\nadapter->peer_wwnn = plogi->fl_wwnn;\r\nfc_host_port_type(shost) = FC_PORTTYPE_PTP;\r\nbreak;\r\ncase FSF_TOPO_FABRIC:\r\nfc_host_port_type(shost) = FC_PORTTYPE_NPORT;\r\nbreak;\r\ncase FSF_TOPO_AL:\r\nfc_host_port_type(shost) = FC_PORTTYPE_NLPORT;\r\ndefault:\r\ndev_err(&adapter->ccw_device->dev,\r\n"Unknown or unsupported arbitrated loop "\r\n"fibre channel topology detected\n");\r\nzfcp_erp_adapter_shutdown(adapter, 0, "fsece_1");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void zfcp_fsf_exchange_config_data_handler(struct zfcp_fsf_req *req)\r\n{\r\nstruct zfcp_adapter *adapter = req->adapter;\r\nstruct fsf_qtcb *qtcb = req->qtcb;\r\nstruct fsf_qtcb_bottom_config *bottom = &qtcb->bottom.config;\r\nstruct Scsi_Host *shost = adapter->scsi_host;\r\nif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\r\nreturn;\r\nadapter->fsf_lic_version = bottom->lic_version;\r\nadapter->adapter_features = bottom->adapter_features;\r\nadapter->connection_features = bottom->connection_features;\r\nadapter->peer_wwpn = 0;\r\nadapter->peer_wwnn = 0;\r\nadapter->peer_d_id = 0;\r\nswitch (qtcb->header.fsf_status) {\r\ncase FSF_GOOD:\r\nif (zfcp_fsf_exchange_config_evaluate(req))\r\nreturn;\r\nif (bottom->max_qtcb_size < sizeof(struct fsf_qtcb)) {\r\ndev_err(&adapter->ccw_device->dev,\r\n"FCP adapter maximum QTCB size (%d bytes) "\r\n"is too small\n",\r\nbottom->max_qtcb_size);\r\nzfcp_erp_adapter_shutdown(adapter, 0, "fsecdh1");\r\nreturn;\r\n}\r\natomic_set_mask(ZFCP_STATUS_ADAPTER_XCONFIG_OK,\r\n&adapter->status);\r\nbreak;\r\ncase FSF_EXCHANGE_CONFIG_DATA_INCOMPLETE:\r\nfc_host_node_name(shost) = 0;\r\nfc_host_port_name(shost) = 0;\r\nfc_host_port_id(shost) = 0;\r\nfc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;\r\nfc_host_port_type(shost) = FC_PORTTYPE_UNKNOWN;\r\nadapter->hydra_version = 0;\r\natomic_set_mask(ZFCP_STATUS_ADAPTER_XCONFIG_OK,\r\n&adapter->status);\r\nzfcp_fsf_link_down_info_eval(req,\r\n&qtcb->header.fsf_status_qual.link_down_info);\r\nif (zfcp_fsf_exchange_config_evaluate(req))\r\nreturn;\r\nbreak;\r\ndefault:\r\nzfcp_erp_adapter_shutdown(adapter, 0, "fsecdh3");\r\nreturn;\r\n}\r\nif (adapter->adapter_features & FSF_FEATURE_HBAAPI_MANAGEMENT) {\r\nadapter->hardware_version = bottom->hardware_version;\r\nmemcpy(fc_host_serial_number(shost), bottom->serial_number,\r\nmin(FC_SERIAL_NUMBER_SIZE, 17));\r\nEBCASC(fc_host_serial_number(shost),\r\nmin(FC_SERIAL_NUMBER_SIZE, 17));\r\n}\r\nif (FSF_QTCB_CURRENT_VERSION < bottom->low_qtcb_version) {\r\ndev_err(&adapter->ccw_device->dev,\r\n"The FCP adapter only supports newer "\r\n"control block versions\n");\r\nzfcp_erp_adapter_shutdown(adapter, 0, "fsecdh4");\r\nreturn;\r\n}\r\nif (FSF_QTCB_CURRENT_VERSION > bottom->high_qtcb_version) {\r\ndev_err(&adapter->ccw_device->dev,\r\n"The FCP adapter only supports older "\r\n"control block versions\n");\r\nzfcp_erp_adapter_shutdown(adapter, 0, "fsecdh5");\r\n}\r\n}\r\nstatic void zfcp_fsf_exchange_port_evaluate(struct zfcp_fsf_req *req)\r\n{\r\nstruct zfcp_adapter *adapter = req->adapter;\r\nstruct fsf_qtcb_bottom_port *bottom = &req->qtcb->bottom.port;\r\nstruct Scsi_Host *shost = adapter->scsi_host;\r\nif (req->data)\r\nmemcpy(req->data, bottom, sizeof(*bottom));\r\nif (adapter->connection_features & FSF_FEATURE_NPIV_MODE) {\r\nfc_host_permanent_port_name(shost) = bottom->wwpn;\r\nfc_host_port_type(shost) = FC_PORTTYPE_NPIV;\r\n} else\r\nfc_host_permanent_port_name(shost) = fc_host_port_name(shost);\r\nfc_host_maxframe_size(shost) = bottom->maximum_frame_size;\r\nfc_host_supported_speeds(shost) =\r\nzfcp_fsf_convert_portspeed(bottom->supported_speed);\r\nmemcpy(fc_host_supported_fc4s(shost), bottom->supported_fc4_types,\r\nFC_FC4_LIST_SIZE);\r\nmemcpy(fc_host_active_fc4s(shost), bottom->active_fc4_types,\r\nFC_FC4_LIST_SIZE);\r\n}\r\nstatic void zfcp_fsf_exchange_port_data_handler(struct zfcp_fsf_req *req)\r\n{\r\nstruct fsf_qtcb *qtcb = req->qtcb;\r\nif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\r\nreturn;\r\nswitch (qtcb->header.fsf_status) {\r\ncase FSF_GOOD:\r\nzfcp_fsf_exchange_port_evaluate(req);\r\nbreak;\r\ncase FSF_EXCHANGE_CONFIG_DATA_INCOMPLETE:\r\nzfcp_fsf_exchange_port_evaluate(req);\r\nzfcp_fsf_link_down_info_eval(req,\r\n&qtcb->header.fsf_status_qual.link_down_info);\r\nbreak;\r\n}\r\n}\r\nstatic struct zfcp_fsf_req *zfcp_fsf_alloc(mempool_t *pool)\r\n{\r\nstruct zfcp_fsf_req *req;\r\nif (likely(pool))\r\nreq = mempool_alloc(pool, GFP_ATOMIC);\r\nelse\r\nreq = kmalloc(sizeof(*req), GFP_ATOMIC);\r\nif (unlikely(!req))\r\nreturn NULL;\r\nmemset(req, 0, sizeof(*req));\r\nreq->pool = pool;\r\nreturn req;\r\n}\r\nstatic struct fsf_qtcb *zfcp_qtcb_alloc(mempool_t *pool)\r\n{\r\nstruct fsf_qtcb *qtcb;\r\nif (likely(pool))\r\nqtcb = mempool_alloc(pool, GFP_ATOMIC);\r\nelse\r\nqtcb = kmem_cache_alloc(zfcp_fsf_qtcb_cache, GFP_ATOMIC);\r\nif (unlikely(!qtcb))\r\nreturn NULL;\r\nmemset(qtcb, 0, sizeof(*qtcb));\r\nreturn qtcb;\r\n}\r\nstatic struct zfcp_fsf_req *zfcp_fsf_req_create(struct zfcp_qdio *qdio,\r\nu32 fsf_cmd, u8 sbtype,\r\nmempool_t *pool)\r\n{\r\nstruct zfcp_adapter *adapter = qdio->adapter;\r\nstruct zfcp_fsf_req *req = zfcp_fsf_alloc(pool);\r\nif (unlikely(!req))\r\nreturn ERR_PTR(-ENOMEM);\r\nif (adapter->req_no == 0)\r\nadapter->req_no++;\r\nINIT_LIST_HEAD(&req->list);\r\ninit_timer(&req->timer);\r\ninit_completion(&req->completion);\r\nreq->adapter = adapter;\r\nreq->fsf_command = fsf_cmd;\r\nreq->req_id = adapter->req_no;\r\nif (likely(fsf_cmd != FSF_QTCB_UNSOLICITED_STATUS)) {\r\nif (likely(pool))\r\nreq->qtcb = zfcp_qtcb_alloc(adapter->pool.qtcb_pool);\r\nelse\r\nreq->qtcb = zfcp_qtcb_alloc(NULL);\r\nif (unlikely(!req->qtcb)) {\r\nzfcp_fsf_req_free(req);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreq->seq_no = adapter->fsf_req_seq_no;\r\nreq->qtcb->prefix.req_seq_no = adapter->fsf_req_seq_no;\r\nreq->qtcb->prefix.req_id = req->req_id;\r\nreq->qtcb->prefix.ulp_info = 26;\r\nreq->qtcb->prefix.qtcb_type = fsf_qtcb_type[req->fsf_command];\r\nreq->qtcb->prefix.qtcb_version = FSF_QTCB_CURRENT_VERSION;\r\nreq->qtcb->header.req_handle = req->req_id;\r\nreq->qtcb->header.fsf_command = req->fsf_command;\r\n}\r\nzfcp_qdio_req_init(adapter->qdio, &req->qdio_req, req->req_id, sbtype,\r\nreq->qtcb, sizeof(struct fsf_qtcb));\r\nreturn req;\r\n}\r\nstatic int zfcp_fsf_req_send(struct zfcp_fsf_req *req)\r\n{\r\nstruct zfcp_adapter *adapter = req->adapter;\r\nstruct zfcp_qdio *qdio = adapter->qdio;\r\nint with_qtcb = (req->qtcb != NULL);\r\nint req_id = req->req_id;\r\nzfcp_reqlist_add(adapter->req_list, req);\r\nreq->qdio_req.qdio_outb_usage = atomic_read(&qdio->req_q_free);\r\nreq->issued = get_tod_clock();\r\nif (zfcp_qdio_send(qdio, &req->qdio_req)) {\r\ndel_timer(&req->timer);\r\nzfcp_reqlist_find_rm(adapter->req_list, req_id);\r\nzfcp_erp_adapter_reopen(adapter, 0, "fsrs__1");\r\nreturn -EIO;\r\n}\r\nif (with_qtcb)\r\nadapter->fsf_req_seq_no++;\r\nadapter->req_no++;\r\nreturn 0;\r\n}\r\nint zfcp_fsf_status_read(struct zfcp_qdio *qdio)\r\n{\r\nstruct zfcp_adapter *adapter = qdio->adapter;\r\nstruct zfcp_fsf_req *req;\r\nstruct fsf_status_read_buffer *sr_buf;\r\nstruct page *page;\r\nint retval = -EIO;\r\nspin_lock_irq(&qdio->req_q_lock);\r\nif (zfcp_qdio_sbal_get(qdio))\r\ngoto out;\r\nreq = zfcp_fsf_req_create(qdio, FSF_QTCB_UNSOLICITED_STATUS,\r\nSBAL_SFLAGS0_TYPE_STATUS,\r\nadapter->pool.status_read_req);\r\nif (IS_ERR(req)) {\r\nretval = PTR_ERR(req);\r\ngoto out;\r\n}\r\npage = mempool_alloc(adapter->pool.sr_data, GFP_ATOMIC);\r\nif (!page) {\r\nretval = -ENOMEM;\r\ngoto failed_buf;\r\n}\r\nsr_buf = page_address(page);\r\nmemset(sr_buf, 0, sizeof(*sr_buf));\r\nreq->data = sr_buf;\r\nzfcp_qdio_fill_next(qdio, &req->qdio_req, sr_buf, sizeof(*sr_buf));\r\nzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\r\nretval = zfcp_fsf_req_send(req);\r\nif (retval)\r\ngoto failed_req_send;\r\ngoto out;\r\nfailed_req_send:\r\nreq->data = NULL;\r\nmempool_free(virt_to_page(sr_buf), adapter->pool.sr_data);\r\nfailed_buf:\r\nzfcp_dbf_hba_fsf_uss("fssr__1", req);\r\nzfcp_fsf_req_free(req);\r\nout:\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nreturn retval;\r\n}\r\nstatic void zfcp_fsf_abort_fcp_command_handler(struct zfcp_fsf_req *req)\r\n{\r\nstruct scsi_device *sdev = req->data;\r\nstruct zfcp_scsi_dev *zfcp_sdev;\r\nunion fsf_status_qual *fsq = &req->qtcb->header.fsf_status_qual;\r\nif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\r\nreturn;\r\nzfcp_sdev = sdev_to_zfcp(sdev);\r\nswitch (req->qtcb->header.fsf_status) {\r\ncase FSF_PORT_HANDLE_NOT_VALID:\r\nif (fsq->word[0] == fsq->word[1]) {\r\nzfcp_erp_adapter_reopen(zfcp_sdev->port->adapter, 0,\r\n"fsafch1");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\n}\r\nbreak;\r\ncase FSF_LUN_HANDLE_NOT_VALID:\r\nif (fsq->word[0] == fsq->word[1]) {\r\nzfcp_erp_port_reopen(zfcp_sdev->port, 0, "fsafch2");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\n}\r\nbreak;\r\ncase FSF_FCP_COMMAND_DOES_NOT_EXIST:\r\nreq->status |= ZFCP_STATUS_FSFREQ_ABORTNOTNEEDED;\r\nbreak;\r\ncase FSF_PORT_BOXED:\r\nzfcp_erp_set_port_status(zfcp_sdev->port,\r\nZFCP_STATUS_COMMON_ACCESS_BOXED);\r\nzfcp_erp_port_reopen(zfcp_sdev->port,\r\nZFCP_STATUS_COMMON_ERP_FAILED, "fsafch3");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_LUN_BOXED:\r\nzfcp_erp_set_lun_status(sdev, ZFCP_STATUS_COMMON_ACCESS_BOXED);\r\nzfcp_erp_lun_reopen(sdev, ZFCP_STATUS_COMMON_ERP_FAILED,\r\n"fsafch4");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_ADAPTER_STATUS_AVAILABLE:\r\nswitch (fsq->word[0]) {\r\ncase FSF_SQ_INVOKE_LINK_TEST_PROCEDURE:\r\nzfcp_fc_test_link(zfcp_sdev->port);\r\ncase FSF_SQ_ULP_DEPENDENT_ERP_REQUIRED:\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\n}\r\nbreak;\r\ncase FSF_GOOD:\r\nreq->status |= ZFCP_STATUS_FSFREQ_ABORTSUCCEEDED;\r\nbreak;\r\n}\r\n}\r\nstruct zfcp_fsf_req *zfcp_fsf_abort_fcp_cmnd(struct scsi_cmnd *scmnd)\r\n{\r\nstruct zfcp_fsf_req *req = NULL;\r\nstruct scsi_device *sdev = scmnd->device;\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\r\nstruct zfcp_qdio *qdio = zfcp_sdev->port->adapter->qdio;\r\nunsigned long old_req_id = (unsigned long) scmnd->host_scribble;\r\nspin_lock_irq(&qdio->req_q_lock);\r\nif (zfcp_qdio_sbal_get(qdio))\r\ngoto out;\r\nreq = zfcp_fsf_req_create(qdio, FSF_QTCB_ABORT_FCP_CMND,\r\nSBAL_SFLAGS0_TYPE_READ,\r\nqdio->adapter->pool.scsi_abort);\r\nif (IS_ERR(req)) {\r\nreq = NULL;\r\ngoto out;\r\n}\r\nif (unlikely(!(atomic_read(&zfcp_sdev->status) &\r\nZFCP_STATUS_COMMON_UNBLOCKED)))\r\ngoto out_error_free;\r\nzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\r\nreq->data = sdev;\r\nreq->handler = zfcp_fsf_abort_fcp_command_handler;\r\nreq->qtcb->header.lun_handle = zfcp_sdev->lun_handle;\r\nreq->qtcb->header.port_handle = zfcp_sdev->port->handle;\r\nreq->qtcb->bottom.support.req_handle = (u64) old_req_id;\r\nzfcp_fsf_start_timer(req, ZFCP_SCSI_ER_TIMEOUT);\r\nif (!zfcp_fsf_req_send(req))\r\ngoto out;\r\nout_error_free:\r\nzfcp_fsf_req_free(req);\r\nreq = NULL;\r\nout:\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nreturn req;\r\n}\r\nstatic void zfcp_fsf_send_ct_handler(struct zfcp_fsf_req *req)\r\n{\r\nstruct zfcp_adapter *adapter = req->adapter;\r\nstruct zfcp_fsf_ct_els *ct = req->data;\r\nstruct fsf_qtcb_header *header = &req->qtcb->header;\r\nct->status = -EINVAL;\r\nif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\r\ngoto skip_fsfstatus;\r\nswitch (header->fsf_status) {\r\ncase FSF_GOOD:\r\nzfcp_dbf_san_res("fsscth2", req);\r\nct->status = 0;\r\nbreak;\r\ncase FSF_SERVICE_CLASS_NOT_SUPPORTED:\r\nzfcp_fsf_class_not_supp(req);\r\nbreak;\r\ncase FSF_ADAPTER_STATUS_AVAILABLE:\r\nswitch (header->fsf_status_qual.word[0]){\r\ncase FSF_SQ_INVOKE_LINK_TEST_PROCEDURE:\r\ncase FSF_SQ_ULP_DEPENDENT_ERP_REQUIRED:\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\n}\r\nbreak;\r\ncase FSF_PORT_BOXED:\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_PORT_HANDLE_NOT_VALID:\r\nzfcp_erp_adapter_reopen(adapter, 0, "fsscth1");\r\ncase FSF_GENERIC_COMMAND_REJECTED:\r\ncase FSF_PAYLOAD_SIZE_MISMATCH:\r\ncase FSF_REQUEST_SIZE_TOO_LARGE:\r\ncase FSF_RESPONSE_SIZE_TOO_LARGE:\r\ncase FSF_SBAL_MISMATCH:\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\n}\r\nskip_fsfstatus:\r\nif (ct->handler)\r\nct->handler(ct->handler_data);\r\n}\r\nstatic void zfcp_fsf_setup_ct_els_unchained(struct zfcp_qdio *qdio,\r\nstruct zfcp_qdio_req *q_req,\r\nstruct scatterlist *sg_req,\r\nstruct scatterlist *sg_resp)\r\n{\r\nzfcp_qdio_fill_next(qdio, q_req, sg_virt(sg_req), sg_req->length);\r\nzfcp_qdio_fill_next(qdio, q_req, sg_virt(sg_resp), sg_resp->length);\r\nzfcp_qdio_set_sbale_last(qdio, q_req);\r\n}\r\nstatic int zfcp_fsf_setup_ct_els_sbals(struct zfcp_fsf_req *req,\r\nstruct scatterlist *sg_req,\r\nstruct scatterlist *sg_resp)\r\n{\r\nstruct zfcp_adapter *adapter = req->adapter;\r\nstruct zfcp_qdio *qdio = adapter->qdio;\r\nstruct fsf_qtcb *qtcb = req->qtcb;\r\nu32 feat = adapter->adapter_features;\r\nif (zfcp_adapter_multi_buffer_active(adapter)) {\r\nif (zfcp_qdio_sbals_from_sg(qdio, &req->qdio_req, sg_req))\r\nreturn -EIO;\r\nif (zfcp_qdio_sbals_from_sg(qdio, &req->qdio_req, sg_resp))\r\nreturn -EIO;\r\nzfcp_qdio_set_data_div(qdio, &req->qdio_req,\r\nzfcp_qdio_sbale_count(sg_req));\r\nzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\r\nzfcp_qdio_set_scount(qdio, &req->qdio_req);\r\nreturn 0;\r\n}\r\nif (zfcp_qdio_sg_one_sbale(sg_req) && zfcp_qdio_sg_one_sbale(sg_resp)) {\r\nzfcp_fsf_setup_ct_els_unchained(qdio, &req->qdio_req,\r\nsg_req, sg_resp);\r\nreturn 0;\r\n}\r\nif (!(feat & FSF_FEATURE_ELS_CT_CHAINED_SBALS))\r\nreturn -EOPNOTSUPP;\r\nif (zfcp_qdio_sbals_from_sg(qdio, &req->qdio_req, sg_req))\r\nreturn -EIO;\r\nqtcb->bottom.support.req_buf_length = zfcp_qdio_real_bytes(sg_req);\r\nzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\r\nzfcp_qdio_skip_to_last_sbale(qdio, &req->qdio_req);\r\nif (zfcp_qdio_sbals_from_sg(qdio, &req->qdio_req, sg_resp))\r\nreturn -EIO;\r\nqtcb->bottom.support.resp_buf_length = zfcp_qdio_real_bytes(sg_resp);\r\nzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\r\nreturn 0;\r\n}\r\nstatic int zfcp_fsf_setup_ct_els(struct zfcp_fsf_req *req,\r\nstruct scatterlist *sg_req,\r\nstruct scatterlist *sg_resp,\r\nunsigned int timeout)\r\n{\r\nint ret;\r\nret = zfcp_fsf_setup_ct_els_sbals(req, sg_req, sg_resp);\r\nif (ret)\r\nreturn ret;\r\nif (timeout > 255)\r\ntimeout = 255;\r\nreq->qtcb->bottom.support.service_class = FSF_CLASS_3;\r\nreq->qtcb->bottom.support.timeout = timeout;\r\nzfcp_fsf_start_timer(req, (timeout + 10) * HZ);\r\nreturn 0;\r\n}\r\nint zfcp_fsf_send_ct(struct zfcp_fc_wka_port *wka_port,\r\nstruct zfcp_fsf_ct_els *ct, mempool_t *pool,\r\nunsigned int timeout)\r\n{\r\nstruct zfcp_qdio *qdio = wka_port->adapter->qdio;\r\nstruct zfcp_fsf_req *req;\r\nint ret = -EIO;\r\nspin_lock_irq(&qdio->req_q_lock);\r\nif (zfcp_qdio_sbal_get(qdio))\r\ngoto out;\r\nreq = zfcp_fsf_req_create(qdio, FSF_QTCB_SEND_GENERIC,\r\nSBAL_SFLAGS0_TYPE_WRITE_READ, pool);\r\nif (IS_ERR(req)) {\r\nret = PTR_ERR(req);\r\ngoto out;\r\n}\r\nreq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\r\nret = zfcp_fsf_setup_ct_els(req, ct->req, ct->resp, timeout);\r\nif (ret)\r\ngoto failed_send;\r\nreq->handler = zfcp_fsf_send_ct_handler;\r\nreq->qtcb->header.port_handle = wka_port->handle;\r\nreq->data = ct;\r\nzfcp_dbf_san_req("fssct_1", req, wka_port->d_id);\r\nret = zfcp_fsf_req_send(req);\r\nif (ret)\r\ngoto failed_send;\r\ngoto out;\r\nfailed_send:\r\nzfcp_fsf_req_free(req);\r\nout:\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nreturn ret;\r\n}\r\nstatic void zfcp_fsf_send_els_handler(struct zfcp_fsf_req *req)\r\n{\r\nstruct zfcp_fsf_ct_els *send_els = req->data;\r\nstruct fsf_qtcb_header *header = &req->qtcb->header;\r\nsend_els->status = -EINVAL;\r\nif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\r\ngoto skip_fsfstatus;\r\nswitch (header->fsf_status) {\r\ncase FSF_GOOD:\r\nzfcp_dbf_san_res("fsselh1", req);\r\nsend_els->status = 0;\r\nbreak;\r\ncase FSF_SERVICE_CLASS_NOT_SUPPORTED:\r\nzfcp_fsf_class_not_supp(req);\r\nbreak;\r\ncase FSF_ADAPTER_STATUS_AVAILABLE:\r\nswitch (header->fsf_status_qual.word[0]){\r\ncase FSF_SQ_INVOKE_LINK_TEST_PROCEDURE:\r\ncase FSF_SQ_ULP_DEPENDENT_ERP_REQUIRED:\r\ncase FSF_SQ_RETRY_IF_POSSIBLE:\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\n}\r\nbreak;\r\ncase FSF_ELS_COMMAND_REJECTED:\r\ncase FSF_PAYLOAD_SIZE_MISMATCH:\r\ncase FSF_REQUEST_SIZE_TOO_LARGE:\r\ncase FSF_RESPONSE_SIZE_TOO_LARGE:\r\nbreak;\r\ncase FSF_SBAL_MISMATCH:\r\ndefault:\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\n}\r\nskip_fsfstatus:\r\nif (send_els->handler)\r\nsend_els->handler(send_els->handler_data);\r\n}\r\nint zfcp_fsf_send_els(struct zfcp_adapter *adapter, u32 d_id,\r\nstruct zfcp_fsf_ct_els *els, unsigned int timeout)\r\n{\r\nstruct zfcp_fsf_req *req;\r\nstruct zfcp_qdio *qdio = adapter->qdio;\r\nint ret = -EIO;\r\nspin_lock_irq(&qdio->req_q_lock);\r\nif (zfcp_qdio_sbal_get(qdio))\r\ngoto out;\r\nreq = zfcp_fsf_req_create(qdio, FSF_QTCB_SEND_ELS,\r\nSBAL_SFLAGS0_TYPE_WRITE_READ, NULL);\r\nif (IS_ERR(req)) {\r\nret = PTR_ERR(req);\r\ngoto out;\r\n}\r\nreq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\r\nif (!zfcp_adapter_multi_buffer_active(adapter))\r\nzfcp_qdio_sbal_limit(qdio, &req->qdio_req, 2);\r\nret = zfcp_fsf_setup_ct_els(req, els->req, els->resp, timeout);\r\nif (ret)\r\ngoto failed_send;\r\nhton24(req->qtcb->bottom.support.d_id, d_id);\r\nreq->handler = zfcp_fsf_send_els_handler;\r\nreq->data = els;\r\nzfcp_dbf_san_req("fssels1", req, d_id);\r\nret = zfcp_fsf_req_send(req);\r\nif (ret)\r\ngoto failed_send;\r\ngoto out;\r\nfailed_send:\r\nzfcp_fsf_req_free(req);\r\nout:\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nreturn ret;\r\n}\r\nint zfcp_fsf_exchange_config_data(struct zfcp_erp_action *erp_action)\r\n{\r\nstruct zfcp_fsf_req *req;\r\nstruct zfcp_qdio *qdio = erp_action->adapter->qdio;\r\nint retval = -EIO;\r\nspin_lock_irq(&qdio->req_q_lock);\r\nif (zfcp_qdio_sbal_get(qdio))\r\ngoto out;\r\nreq = zfcp_fsf_req_create(qdio, FSF_QTCB_EXCHANGE_CONFIG_DATA,\r\nSBAL_SFLAGS0_TYPE_READ,\r\nqdio->adapter->pool.erp_req);\r\nif (IS_ERR(req)) {\r\nretval = PTR_ERR(req);\r\ngoto out;\r\n}\r\nreq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\r\nzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\r\nreq->qtcb->bottom.config.feature_selection =\r\nFSF_FEATURE_NOTIFICATION_LOST |\r\nFSF_FEATURE_UPDATE_ALERT;\r\nreq->erp_action = erp_action;\r\nreq->handler = zfcp_fsf_exchange_config_data_handler;\r\nerp_action->fsf_req_id = req->req_id;\r\nzfcp_fsf_start_erp_timer(req);\r\nretval = zfcp_fsf_req_send(req);\r\nif (retval) {\r\nzfcp_fsf_req_free(req);\r\nerp_action->fsf_req_id = 0;\r\n}\r\nout:\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nreturn retval;\r\n}\r\nint zfcp_fsf_exchange_config_data_sync(struct zfcp_qdio *qdio,\r\nstruct fsf_qtcb_bottom_config *data)\r\n{\r\nstruct zfcp_fsf_req *req = NULL;\r\nint retval = -EIO;\r\nspin_lock_irq(&qdio->req_q_lock);\r\nif (zfcp_qdio_sbal_get(qdio))\r\ngoto out_unlock;\r\nreq = zfcp_fsf_req_create(qdio, FSF_QTCB_EXCHANGE_CONFIG_DATA,\r\nSBAL_SFLAGS0_TYPE_READ, NULL);\r\nif (IS_ERR(req)) {\r\nretval = PTR_ERR(req);\r\ngoto out_unlock;\r\n}\r\nzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\r\nreq->handler = zfcp_fsf_exchange_config_data_handler;\r\nreq->qtcb->bottom.config.feature_selection =\r\nFSF_FEATURE_NOTIFICATION_LOST |\r\nFSF_FEATURE_UPDATE_ALERT;\r\nif (data)\r\nreq->data = data;\r\nzfcp_fsf_start_timer(req, ZFCP_FSF_REQUEST_TIMEOUT);\r\nretval = zfcp_fsf_req_send(req);\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nif (!retval)\r\nwait_for_completion(&req->completion);\r\nzfcp_fsf_req_free(req);\r\nreturn retval;\r\nout_unlock:\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nreturn retval;\r\n}\r\nint zfcp_fsf_exchange_port_data(struct zfcp_erp_action *erp_action)\r\n{\r\nstruct zfcp_qdio *qdio = erp_action->adapter->qdio;\r\nstruct zfcp_fsf_req *req;\r\nint retval = -EIO;\r\nif (!(qdio->adapter->adapter_features & FSF_FEATURE_HBAAPI_MANAGEMENT))\r\nreturn -EOPNOTSUPP;\r\nspin_lock_irq(&qdio->req_q_lock);\r\nif (zfcp_qdio_sbal_get(qdio))\r\ngoto out;\r\nreq = zfcp_fsf_req_create(qdio, FSF_QTCB_EXCHANGE_PORT_DATA,\r\nSBAL_SFLAGS0_TYPE_READ,\r\nqdio->adapter->pool.erp_req);\r\nif (IS_ERR(req)) {\r\nretval = PTR_ERR(req);\r\ngoto out;\r\n}\r\nreq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\r\nzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\r\nreq->handler = zfcp_fsf_exchange_port_data_handler;\r\nreq->erp_action = erp_action;\r\nerp_action->fsf_req_id = req->req_id;\r\nzfcp_fsf_start_erp_timer(req);\r\nretval = zfcp_fsf_req_send(req);\r\nif (retval) {\r\nzfcp_fsf_req_free(req);\r\nerp_action->fsf_req_id = 0;\r\n}\r\nout:\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nreturn retval;\r\n}\r\nint zfcp_fsf_exchange_port_data_sync(struct zfcp_qdio *qdio,\r\nstruct fsf_qtcb_bottom_port *data)\r\n{\r\nstruct zfcp_fsf_req *req = NULL;\r\nint retval = -EIO;\r\nif (!(qdio->adapter->adapter_features & FSF_FEATURE_HBAAPI_MANAGEMENT))\r\nreturn -EOPNOTSUPP;\r\nspin_lock_irq(&qdio->req_q_lock);\r\nif (zfcp_qdio_sbal_get(qdio))\r\ngoto out_unlock;\r\nreq = zfcp_fsf_req_create(qdio, FSF_QTCB_EXCHANGE_PORT_DATA,\r\nSBAL_SFLAGS0_TYPE_READ, NULL);\r\nif (IS_ERR(req)) {\r\nretval = PTR_ERR(req);\r\ngoto out_unlock;\r\n}\r\nif (data)\r\nreq->data = data;\r\nzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\r\nreq->handler = zfcp_fsf_exchange_port_data_handler;\r\nzfcp_fsf_start_timer(req, ZFCP_FSF_REQUEST_TIMEOUT);\r\nretval = zfcp_fsf_req_send(req);\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nif (!retval)\r\nwait_for_completion(&req->completion);\r\nzfcp_fsf_req_free(req);\r\nreturn retval;\r\nout_unlock:\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nreturn retval;\r\n}\r\nstatic void zfcp_fsf_open_port_handler(struct zfcp_fsf_req *req)\r\n{\r\nstruct zfcp_port *port = req->data;\r\nstruct fsf_qtcb_header *header = &req->qtcb->header;\r\nstruct fc_els_flogi *plogi;\r\nif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\r\ngoto out;\r\nswitch (header->fsf_status) {\r\ncase FSF_PORT_ALREADY_OPEN:\r\nbreak;\r\ncase FSF_MAXIMUM_NUMBER_OF_PORTS_EXCEEDED:\r\ndev_warn(&req->adapter->ccw_device->dev,\r\n"Not enough FCP adapter resources to open "\r\n"remote port 0x%016Lx\n",\r\n(unsigned long long)port->wwpn);\r\nzfcp_erp_set_port_status(port,\r\nZFCP_STATUS_COMMON_ERP_FAILED);\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_ADAPTER_STATUS_AVAILABLE:\r\nswitch (header->fsf_status_qual.word[0]) {\r\ncase FSF_SQ_INVOKE_LINK_TEST_PROCEDURE:\r\ncase FSF_SQ_ULP_DEPENDENT_ERP_REQUIRED:\r\ncase FSF_SQ_NO_RETRY_POSSIBLE:\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\n}\r\nbreak;\r\ncase FSF_GOOD:\r\nport->handle = header->port_handle;\r\natomic_set_mask(ZFCP_STATUS_COMMON_OPEN |\r\nZFCP_STATUS_PORT_PHYS_OPEN, &port->status);\r\natomic_clear_mask(ZFCP_STATUS_COMMON_ACCESS_BOXED,\r\n&port->status);\r\nplogi = (struct fc_els_flogi *) req->qtcb->bottom.support.els;\r\nif (req->qtcb->bottom.support.els1_length >=\r\nFSF_PLOGI_MIN_LEN)\r\nzfcp_fc_plogi_evaluate(port, plogi);\r\nbreak;\r\ncase FSF_UNKNOWN_OP_SUBTYPE:\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\n}\r\nout:\r\nput_device(&port->dev);\r\n}\r\nint zfcp_fsf_open_port(struct zfcp_erp_action *erp_action)\r\n{\r\nstruct zfcp_qdio *qdio = erp_action->adapter->qdio;\r\nstruct zfcp_port *port = erp_action->port;\r\nstruct zfcp_fsf_req *req;\r\nint retval = -EIO;\r\nspin_lock_irq(&qdio->req_q_lock);\r\nif (zfcp_qdio_sbal_get(qdio))\r\ngoto out;\r\nreq = zfcp_fsf_req_create(qdio, FSF_QTCB_OPEN_PORT_WITH_DID,\r\nSBAL_SFLAGS0_TYPE_READ,\r\nqdio->adapter->pool.erp_req);\r\nif (IS_ERR(req)) {\r\nretval = PTR_ERR(req);\r\ngoto out;\r\n}\r\nreq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\r\nzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\r\nreq->handler = zfcp_fsf_open_port_handler;\r\nhton24(req->qtcb->bottom.support.d_id, port->d_id);\r\nreq->data = port;\r\nreq->erp_action = erp_action;\r\nerp_action->fsf_req_id = req->req_id;\r\nget_device(&port->dev);\r\nzfcp_fsf_start_erp_timer(req);\r\nretval = zfcp_fsf_req_send(req);\r\nif (retval) {\r\nzfcp_fsf_req_free(req);\r\nerp_action->fsf_req_id = 0;\r\nput_device(&port->dev);\r\n}\r\nout:\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nreturn retval;\r\n}\r\nstatic void zfcp_fsf_close_port_handler(struct zfcp_fsf_req *req)\r\n{\r\nstruct zfcp_port *port = req->data;\r\nif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\r\nreturn;\r\nswitch (req->qtcb->header.fsf_status) {\r\ncase FSF_PORT_HANDLE_NOT_VALID:\r\nzfcp_erp_adapter_reopen(port->adapter, 0, "fscph_1");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_ADAPTER_STATUS_AVAILABLE:\r\nbreak;\r\ncase FSF_GOOD:\r\nzfcp_erp_clear_port_status(port, ZFCP_STATUS_COMMON_OPEN);\r\nbreak;\r\n}\r\n}\r\nint zfcp_fsf_close_port(struct zfcp_erp_action *erp_action)\r\n{\r\nstruct zfcp_qdio *qdio = erp_action->adapter->qdio;\r\nstruct zfcp_fsf_req *req;\r\nint retval = -EIO;\r\nspin_lock_irq(&qdio->req_q_lock);\r\nif (zfcp_qdio_sbal_get(qdio))\r\ngoto out;\r\nreq = zfcp_fsf_req_create(qdio, FSF_QTCB_CLOSE_PORT,\r\nSBAL_SFLAGS0_TYPE_READ,\r\nqdio->adapter->pool.erp_req);\r\nif (IS_ERR(req)) {\r\nretval = PTR_ERR(req);\r\ngoto out;\r\n}\r\nreq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\r\nzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\r\nreq->handler = zfcp_fsf_close_port_handler;\r\nreq->data = erp_action->port;\r\nreq->erp_action = erp_action;\r\nreq->qtcb->header.port_handle = erp_action->port->handle;\r\nerp_action->fsf_req_id = req->req_id;\r\nzfcp_fsf_start_erp_timer(req);\r\nretval = zfcp_fsf_req_send(req);\r\nif (retval) {\r\nzfcp_fsf_req_free(req);\r\nerp_action->fsf_req_id = 0;\r\n}\r\nout:\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nreturn retval;\r\n}\r\nstatic void zfcp_fsf_open_wka_port_handler(struct zfcp_fsf_req *req)\r\n{\r\nstruct zfcp_fc_wka_port *wka_port = req->data;\r\nstruct fsf_qtcb_header *header = &req->qtcb->header;\r\nif (req->status & ZFCP_STATUS_FSFREQ_ERROR) {\r\nwka_port->status = ZFCP_FC_WKA_PORT_OFFLINE;\r\ngoto out;\r\n}\r\nswitch (header->fsf_status) {\r\ncase FSF_MAXIMUM_NUMBER_OF_PORTS_EXCEEDED:\r\ndev_warn(&req->adapter->ccw_device->dev,\r\n"Opening WKA port 0x%x failed\n", wka_port->d_id);\r\ncase FSF_ADAPTER_STATUS_AVAILABLE:\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nwka_port->status = ZFCP_FC_WKA_PORT_OFFLINE;\r\nbreak;\r\ncase FSF_GOOD:\r\nwka_port->handle = header->port_handle;\r\ncase FSF_PORT_ALREADY_OPEN:\r\nwka_port->status = ZFCP_FC_WKA_PORT_ONLINE;\r\n}\r\nout:\r\nwake_up(&wka_port->completion_wq);\r\n}\r\nint zfcp_fsf_open_wka_port(struct zfcp_fc_wka_port *wka_port)\r\n{\r\nstruct zfcp_qdio *qdio = wka_port->adapter->qdio;\r\nstruct zfcp_fsf_req *req;\r\nint retval = -EIO;\r\nspin_lock_irq(&qdio->req_q_lock);\r\nif (zfcp_qdio_sbal_get(qdio))\r\ngoto out;\r\nreq = zfcp_fsf_req_create(qdio, FSF_QTCB_OPEN_PORT_WITH_DID,\r\nSBAL_SFLAGS0_TYPE_READ,\r\nqdio->adapter->pool.erp_req);\r\nif (IS_ERR(req)) {\r\nretval = PTR_ERR(req);\r\ngoto out;\r\n}\r\nreq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\r\nzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\r\nreq->handler = zfcp_fsf_open_wka_port_handler;\r\nhton24(req->qtcb->bottom.support.d_id, wka_port->d_id);\r\nreq->data = wka_port;\r\nzfcp_fsf_start_timer(req, ZFCP_FSF_REQUEST_TIMEOUT);\r\nretval = zfcp_fsf_req_send(req);\r\nif (retval)\r\nzfcp_fsf_req_free(req);\r\nout:\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nreturn retval;\r\n}\r\nstatic void zfcp_fsf_close_wka_port_handler(struct zfcp_fsf_req *req)\r\n{\r\nstruct zfcp_fc_wka_port *wka_port = req->data;\r\nif (req->qtcb->header.fsf_status == FSF_PORT_HANDLE_NOT_VALID) {\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nzfcp_erp_adapter_reopen(wka_port->adapter, 0, "fscwph1");\r\n}\r\nwka_port->status = ZFCP_FC_WKA_PORT_OFFLINE;\r\nwake_up(&wka_port->completion_wq);\r\n}\r\nint zfcp_fsf_close_wka_port(struct zfcp_fc_wka_port *wka_port)\r\n{\r\nstruct zfcp_qdio *qdio = wka_port->adapter->qdio;\r\nstruct zfcp_fsf_req *req;\r\nint retval = -EIO;\r\nspin_lock_irq(&qdio->req_q_lock);\r\nif (zfcp_qdio_sbal_get(qdio))\r\ngoto out;\r\nreq = zfcp_fsf_req_create(qdio, FSF_QTCB_CLOSE_PORT,\r\nSBAL_SFLAGS0_TYPE_READ,\r\nqdio->adapter->pool.erp_req);\r\nif (IS_ERR(req)) {\r\nretval = PTR_ERR(req);\r\ngoto out;\r\n}\r\nreq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\r\nzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\r\nreq->handler = zfcp_fsf_close_wka_port_handler;\r\nreq->data = wka_port;\r\nreq->qtcb->header.port_handle = wka_port->handle;\r\nzfcp_fsf_start_timer(req, ZFCP_FSF_REQUEST_TIMEOUT);\r\nretval = zfcp_fsf_req_send(req);\r\nif (retval)\r\nzfcp_fsf_req_free(req);\r\nout:\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nreturn retval;\r\n}\r\nstatic void zfcp_fsf_close_physical_port_handler(struct zfcp_fsf_req *req)\r\n{\r\nstruct zfcp_port *port = req->data;\r\nstruct fsf_qtcb_header *header = &req->qtcb->header;\r\nstruct scsi_device *sdev;\r\nif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\r\nreturn;\r\nswitch (header->fsf_status) {\r\ncase FSF_PORT_HANDLE_NOT_VALID:\r\nzfcp_erp_adapter_reopen(port->adapter, 0, "fscpph1");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_PORT_BOXED:\r\natomic_clear_mask(ZFCP_STATUS_PORT_PHYS_OPEN, &port->status);\r\nshost_for_each_device(sdev, port->adapter->scsi_host)\r\nif (sdev_to_zfcp(sdev)->port == port)\r\natomic_clear_mask(ZFCP_STATUS_COMMON_OPEN,\r\n&sdev_to_zfcp(sdev)->status);\r\nzfcp_erp_set_port_status(port, ZFCP_STATUS_COMMON_ACCESS_BOXED);\r\nzfcp_erp_port_reopen(port, ZFCP_STATUS_COMMON_ERP_FAILED,\r\n"fscpph2");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_ADAPTER_STATUS_AVAILABLE:\r\nswitch (header->fsf_status_qual.word[0]) {\r\ncase FSF_SQ_INVOKE_LINK_TEST_PROCEDURE:\r\ncase FSF_SQ_ULP_DEPENDENT_ERP_REQUIRED:\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\n}\r\nbreak;\r\ncase FSF_GOOD:\r\natomic_clear_mask(ZFCP_STATUS_PORT_PHYS_OPEN, &port->status);\r\nshost_for_each_device(sdev, port->adapter->scsi_host)\r\nif (sdev_to_zfcp(sdev)->port == port)\r\natomic_clear_mask(ZFCP_STATUS_COMMON_OPEN,\r\n&sdev_to_zfcp(sdev)->status);\r\nbreak;\r\n}\r\n}\r\nint zfcp_fsf_close_physical_port(struct zfcp_erp_action *erp_action)\r\n{\r\nstruct zfcp_qdio *qdio = erp_action->adapter->qdio;\r\nstruct zfcp_fsf_req *req;\r\nint retval = -EIO;\r\nspin_lock_irq(&qdio->req_q_lock);\r\nif (zfcp_qdio_sbal_get(qdio))\r\ngoto out;\r\nreq = zfcp_fsf_req_create(qdio, FSF_QTCB_CLOSE_PHYSICAL_PORT,\r\nSBAL_SFLAGS0_TYPE_READ,\r\nqdio->adapter->pool.erp_req);\r\nif (IS_ERR(req)) {\r\nretval = PTR_ERR(req);\r\ngoto out;\r\n}\r\nreq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\r\nzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\r\nreq->data = erp_action->port;\r\nreq->qtcb->header.port_handle = erp_action->port->handle;\r\nreq->erp_action = erp_action;\r\nreq->handler = zfcp_fsf_close_physical_port_handler;\r\nerp_action->fsf_req_id = req->req_id;\r\nzfcp_fsf_start_erp_timer(req);\r\nretval = zfcp_fsf_req_send(req);\r\nif (retval) {\r\nzfcp_fsf_req_free(req);\r\nerp_action->fsf_req_id = 0;\r\n}\r\nout:\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nreturn retval;\r\n}\r\nstatic void zfcp_fsf_open_lun_handler(struct zfcp_fsf_req *req)\r\n{\r\nstruct zfcp_adapter *adapter = req->adapter;\r\nstruct scsi_device *sdev = req->data;\r\nstruct zfcp_scsi_dev *zfcp_sdev;\r\nstruct fsf_qtcb_header *header = &req->qtcb->header;\r\nunion fsf_status_qual *qual = &header->fsf_status_qual;\r\nif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\r\nreturn;\r\nzfcp_sdev = sdev_to_zfcp(sdev);\r\natomic_clear_mask(ZFCP_STATUS_COMMON_ACCESS_DENIED |\r\nZFCP_STATUS_COMMON_ACCESS_BOXED,\r\n&zfcp_sdev->status);\r\nswitch (header->fsf_status) {\r\ncase FSF_PORT_HANDLE_NOT_VALID:\r\nzfcp_erp_adapter_reopen(adapter, 0, "fsouh_1");\r\ncase FSF_LUN_ALREADY_OPEN:\r\nbreak;\r\ncase FSF_PORT_BOXED:\r\nzfcp_erp_set_port_status(zfcp_sdev->port,\r\nZFCP_STATUS_COMMON_ACCESS_BOXED);\r\nzfcp_erp_port_reopen(zfcp_sdev->port,\r\nZFCP_STATUS_COMMON_ERP_FAILED, "fsouh_2");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_LUN_SHARING_VIOLATION:\r\nif (qual->word[0])\r\ndev_warn(&zfcp_sdev->port->adapter->ccw_device->dev,\r\n"LUN 0x%Lx on port 0x%Lx is already in "\r\n"use by CSS%d, MIF Image ID %x\n",\r\nzfcp_scsi_dev_lun(sdev),\r\n(unsigned long long)zfcp_sdev->port->wwpn,\r\nqual->fsf_queue_designator.cssid,\r\nqual->fsf_queue_designator.hla);\r\nzfcp_erp_set_lun_status(sdev,\r\nZFCP_STATUS_COMMON_ERP_FAILED |\r\nZFCP_STATUS_COMMON_ACCESS_DENIED);\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_MAXIMUM_NUMBER_OF_LUNS_EXCEEDED:\r\ndev_warn(&adapter->ccw_device->dev,\r\n"No handle is available for LUN "\r\n"0x%016Lx on port 0x%016Lx\n",\r\n(unsigned long long)zfcp_scsi_dev_lun(sdev),\r\n(unsigned long long)zfcp_sdev->port->wwpn);\r\nzfcp_erp_set_lun_status(sdev, ZFCP_STATUS_COMMON_ERP_FAILED);\r\ncase FSF_INVALID_COMMAND_OPTION:\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_ADAPTER_STATUS_AVAILABLE:\r\nswitch (header->fsf_status_qual.word[0]) {\r\ncase FSF_SQ_INVOKE_LINK_TEST_PROCEDURE:\r\nzfcp_fc_test_link(zfcp_sdev->port);\r\ncase FSF_SQ_ULP_DEPENDENT_ERP_REQUIRED:\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\n}\r\nbreak;\r\ncase FSF_GOOD:\r\nzfcp_sdev->lun_handle = header->lun_handle;\r\natomic_set_mask(ZFCP_STATUS_COMMON_OPEN, &zfcp_sdev->status);\r\nbreak;\r\n}\r\n}\r\nint zfcp_fsf_open_lun(struct zfcp_erp_action *erp_action)\r\n{\r\nstruct zfcp_adapter *adapter = erp_action->adapter;\r\nstruct zfcp_qdio *qdio = adapter->qdio;\r\nstruct zfcp_fsf_req *req;\r\nint retval = -EIO;\r\nspin_lock_irq(&qdio->req_q_lock);\r\nif (zfcp_qdio_sbal_get(qdio))\r\ngoto out;\r\nreq = zfcp_fsf_req_create(qdio, FSF_QTCB_OPEN_LUN,\r\nSBAL_SFLAGS0_TYPE_READ,\r\nadapter->pool.erp_req);\r\nif (IS_ERR(req)) {\r\nretval = PTR_ERR(req);\r\ngoto out;\r\n}\r\nreq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\r\nzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\r\nreq->qtcb->header.port_handle = erp_action->port->handle;\r\nreq->qtcb->bottom.support.fcp_lun = zfcp_scsi_dev_lun(erp_action->sdev);\r\nreq->handler = zfcp_fsf_open_lun_handler;\r\nreq->data = erp_action->sdev;\r\nreq->erp_action = erp_action;\r\nerp_action->fsf_req_id = req->req_id;\r\nif (!(adapter->connection_features & FSF_FEATURE_NPIV_MODE))\r\nreq->qtcb->bottom.support.option = FSF_OPEN_LUN_SUPPRESS_BOXING;\r\nzfcp_fsf_start_erp_timer(req);\r\nretval = zfcp_fsf_req_send(req);\r\nif (retval) {\r\nzfcp_fsf_req_free(req);\r\nerp_action->fsf_req_id = 0;\r\n}\r\nout:\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nreturn retval;\r\n}\r\nstatic void zfcp_fsf_close_lun_handler(struct zfcp_fsf_req *req)\r\n{\r\nstruct scsi_device *sdev = req->data;\r\nstruct zfcp_scsi_dev *zfcp_sdev;\r\nif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\r\nreturn;\r\nzfcp_sdev = sdev_to_zfcp(sdev);\r\nswitch (req->qtcb->header.fsf_status) {\r\ncase FSF_PORT_HANDLE_NOT_VALID:\r\nzfcp_erp_adapter_reopen(zfcp_sdev->port->adapter, 0, "fscuh_1");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_LUN_HANDLE_NOT_VALID:\r\nzfcp_erp_port_reopen(zfcp_sdev->port, 0, "fscuh_2");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_PORT_BOXED:\r\nzfcp_erp_set_port_status(zfcp_sdev->port,\r\nZFCP_STATUS_COMMON_ACCESS_BOXED);\r\nzfcp_erp_port_reopen(zfcp_sdev->port,\r\nZFCP_STATUS_COMMON_ERP_FAILED, "fscuh_3");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_ADAPTER_STATUS_AVAILABLE:\r\nswitch (req->qtcb->header.fsf_status_qual.word[0]) {\r\ncase FSF_SQ_INVOKE_LINK_TEST_PROCEDURE:\r\nzfcp_fc_test_link(zfcp_sdev->port);\r\ncase FSF_SQ_ULP_DEPENDENT_ERP_REQUIRED:\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\n}\r\nbreak;\r\ncase FSF_GOOD:\r\natomic_clear_mask(ZFCP_STATUS_COMMON_OPEN, &zfcp_sdev->status);\r\nbreak;\r\n}\r\n}\r\nint zfcp_fsf_close_lun(struct zfcp_erp_action *erp_action)\r\n{\r\nstruct zfcp_qdio *qdio = erp_action->adapter->qdio;\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(erp_action->sdev);\r\nstruct zfcp_fsf_req *req;\r\nint retval = -EIO;\r\nspin_lock_irq(&qdio->req_q_lock);\r\nif (zfcp_qdio_sbal_get(qdio))\r\ngoto out;\r\nreq = zfcp_fsf_req_create(qdio, FSF_QTCB_CLOSE_LUN,\r\nSBAL_SFLAGS0_TYPE_READ,\r\nqdio->adapter->pool.erp_req);\r\nif (IS_ERR(req)) {\r\nretval = PTR_ERR(req);\r\ngoto out;\r\n}\r\nreq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\r\nzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\r\nreq->qtcb->header.port_handle = erp_action->port->handle;\r\nreq->qtcb->header.lun_handle = zfcp_sdev->lun_handle;\r\nreq->handler = zfcp_fsf_close_lun_handler;\r\nreq->data = erp_action->sdev;\r\nreq->erp_action = erp_action;\r\nerp_action->fsf_req_id = req->req_id;\r\nzfcp_fsf_start_erp_timer(req);\r\nretval = zfcp_fsf_req_send(req);\r\nif (retval) {\r\nzfcp_fsf_req_free(req);\r\nerp_action->fsf_req_id = 0;\r\n}\r\nout:\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nreturn retval;\r\n}\r\nstatic void zfcp_fsf_update_lat(struct fsf_latency_record *lat_rec, u32 lat)\r\n{\r\nlat_rec->sum += lat;\r\nlat_rec->min = min(lat_rec->min, lat);\r\nlat_rec->max = max(lat_rec->max, lat);\r\n}\r\nstatic void zfcp_fsf_req_trace(struct zfcp_fsf_req *req, struct scsi_cmnd *scsi)\r\n{\r\nstruct fsf_qual_latency_info *lat_in;\r\nstruct latency_cont *lat = NULL;\r\nstruct zfcp_scsi_dev *zfcp_sdev;\r\nstruct zfcp_blk_drv_data blktrc;\r\nint ticks = req->adapter->timer_ticks;\r\nlat_in = &req->qtcb->prefix.prot_status_qual.latency_info;\r\nblktrc.flags = 0;\r\nblktrc.magic = ZFCP_BLK_DRV_DATA_MAGIC;\r\nif (req->status & ZFCP_STATUS_FSFREQ_ERROR)\r\nblktrc.flags |= ZFCP_BLK_REQ_ERROR;\r\nblktrc.inb_usage = 0;\r\nblktrc.outb_usage = req->qdio_req.qdio_outb_usage;\r\nif (req->adapter->adapter_features & FSF_FEATURE_MEASUREMENT_DATA &&\r\n!(req->status & ZFCP_STATUS_FSFREQ_ERROR)) {\r\nzfcp_sdev = sdev_to_zfcp(scsi->device);\r\nblktrc.flags |= ZFCP_BLK_LAT_VALID;\r\nblktrc.channel_lat = lat_in->channel_lat * ticks;\r\nblktrc.fabric_lat = lat_in->fabric_lat * ticks;\r\nswitch (req->qtcb->bottom.io.data_direction) {\r\ncase FSF_DATADIR_DIF_READ_STRIP:\r\ncase FSF_DATADIR_DIF_READ_CONVERT:\r\ncase FSF_DATADIR_READ:\r\nlat = &zfcp_sdev->latencies.read;\r\nbreak;\r\ncase FSF_DATADIR_DIF_WRITE_INSERT:\r\ncase FSF_DATADIR_DIF_WRITE_CONVERT:\r\ncase FSF_DATADIR_WRITE:\r\nlat = &zfcp_sdev->latencies.write;\r\nbreak;\r\ncase FSF_DATADIR_CMND:\r\nlat = &zfcp_sdev->latencies.cmd;\r\nbreak;\r\n}\r\nif (lat) {\r\nspin_lock(&zfcp_sdev->latencies.lock);\r\nzfcp_fsf_update_lat(&lat->channel, lat_in->channel_lat);\r\nzfcp_fsf_update_lat(&lat->fabric, lat_in->fabric_lat);\r\nlat->counter++;\r\nspin_unlock(&zfcp_sdev->latencies.lock);\r\n}\r\n}\r\nblk_add_driver_data(scsi->request->q, scsi->request, &blktrc,\r\nsizeof(blktrc));\r\n}\r\nstatic void zfcp_fsf_fcp_handler_common(struct zfcp_fsf_req *req)\r\n{\r\nstruct scsi_cmnd *scmnd = req->data;\r\nstruct scsi_device *sdev = scmnd->device;\r\nstruct zfcp_scsi_dev *zfcp_sdev;\r\nstruct fsf_qtcb_header *header = &req->qtcb->header;\r\nif (unlikely(req->status & ZFCP_STATUS_FSFREQ_ERROR))\r\nreturn;\r\nzfcp_sdev = sdev_to_zfcp(sdev);\r\nswitch (header->fsf_status) {\r\ncase FSF_HANDLE_MISMATCH:\r\ncase FSF_PORT_HANDLE_NOT_VALID:\r\nzfcp_erp_adapter_reopen(zfcp_sdev->port->adapter, 0, "fssfch1");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_FCPLUN_NOT_VALID:\r\ncase FSF_LUN_HANDLE_NOT_VALID:\r\nzfcp_erp_port_reopen(zfcp_sdev->port, 0, "fssfch2");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_SERVICE_CLASS_NOT_SUPPORTED:\r\nzfcp_fsf_class_not_supp(req);\r\nbreak;\r\ncase FSF_DIRECTION_INDICATOR_NOT_VALID:\r\ndev_err(&req->adapter->ccw_device->dev,\r\n"Incorrect direction %d, LUN 0x%016Lx on port "\r\n"0x%016Lx closed\n",\r\nreq->qtcb->bottom.io.data_direction,\r\n(unsigned long long)zfcp_scsi_dev_lun(sdev),\r\n(unsigned long long)zfcp_sdev->port->wwpn);\r\nzfcp_erp_adapter_shutdown(zfcp_sdev->port->adapter, 0,\r\n"fssfch3");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_CMND_LENGTH_NOT_VALID:\r\ndev_err(&req->adapter->ccw_device->dev,\r\n"Incorrect CDB length %d, LUN 0x%016Lx on "\r\n"port 0x%016Lx closed\n",\r\nreq->qtcb->bottom.io.fcp_cmnd_length,\r\n(unsigned long long)zfcp_scsi_dev_lun(sdev),\r\n(unsigned long long)zfcp_sdev->port->wwpn);\r\nzfcp_erp_adapter_shutdown(zfcp_sdev->port->adapter, 0,\r\n"fssfch4");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_PORT_BOXED:\r\nzfcp_erp_set_port_status(zfcp_sdev->port,\r\nZFCP_STATUS_COMMON_ACCESS_BOXED);\r\nzfcp_erp_port_reopen(zfcp_sdev->port,\r\nZFCP_STATUS_COMMON_ERP_FAILED, "fssfch5");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_LUN_BOXED:\r\nzfcp_erp_set_lun_status(sdev, ZFCP_STATUS_COMMON_ACCESS_BOXED);\r\nzfcp_erp_lun_reopen(sdev, ZFCP_STATUS_COMMON_ERP_FAILED,\r\n"fssfch6");\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\ncase FSF_ADAPTER_STATUS_AVAILABLE:\r\nif (header->fsf_status_qual.word[0] ==\r\nFSF_SQ_INVOKE_LINK_TEST_PROCEDURE)\r\nzfcp_fc_test_link(zfcp_sdev->port);\r\nreq->status |= ZFCP_STATUS_FSFREQ_ERROR;\r\nbreak;\r\n}\r\n}\r\nstatic void zfcp_fsf_fcp_cmnd_handler(struct zfcp_fsf_req *req)\r\n{\r\nstruct scsi_cmnd *scpnt;\r\nstruct fcp_resp_with_ext *fcp_rsp;\r\nunsigned long flags;\r\nread_lock_irqsave(&req->adapter->abort_lock, flags);\r\nscpnt = req->data;\r\nif (unlikely(!scpnt)) {\r\nread_unlock_irqrestore(&req->adapter->abort_lock, flags);\r\nreturn;\r\n}\r\nzfcp_fsf_fcp_handler_common(req);\r\nif (unlikely(req->status & ZFCP_STATUS_FSFREQ_ERROR)) {\r\nset_host_byte(scpnt, DID_TRANSPORT_DISRUPTED);\r\ngoto skip_fsfstatus;\r\n}\r\nswitch (req->qtcb->header.fsf_status) {\r\ncase FSF_INCONSISTENT_PROT_DATA:\r\ncase FSF_INVALID_PROT_PARM:\r\nset_host_byte(scpnt, DID_ERROR);\r\ngoto skip_fsfstatus;\r\ncase FSF_BLOCK_GUARD_CHECK_FAILURE:\r\nzfcp_scsi_dif_sense_error(scpnt, 0x1);\r\ngoto skip_fsfstatus;\r\ncase FSF_APP_TAG_CHECK_FAILURE:\r\nzfcp_scsi_dif_sense_error(scpnt, 0x2);\r\ngoto skip_fsfstatus;\r\ncase FSF_REF_TAG_CHECK_FAILURE:\r\nzfcp_scsi_dif_sense_error(scpnt, 0x3);\r\ngoto skip_fsfstatus;\r\n}\r\nfcp_rsp = (struct fcp_resp_with_ext *) &req->qtcb->bottom.io.fcp_rsp;\r\nzfcp_fc_eval_fcp_rsp(fcp_rsp, scpnt);\r\nskip_fsfstatus:\r\nzfcp_fsf_req_trace(req, scpnt);\r\nzfcp_dbf_scsi_result(scpnt, req);\r\nscpnt->host_scribble = NULL;\r\n(scpnt->scsi_done) (scpnt);\r\nread_unlock_irqrestore(&req->adapter->abort_lock, flags);\r\n}\r\nstatic int zfcp_fsf_set_data_dir(struct scsi_cmnd *scsi_cmnd, u32 *data_dir)\r\n{\r\nswitch (scsi_get_prot_op(scsi_cmnd)) {\r\ncase SCSI_PROT_NORMAL:\r\nswitch (scsi_cmnd->sc_data_direction) {\r\ncase DMA_NONE:\r\n*data_dir = FSF_DATADIR_CMND;\r\nbreak;\r\ncase DMA_FROM_DEVICE:\r\n*data_dir = FSF_DATADIR_READ;\r\nbreak;\r\ncase DMA_TO_DEVICE:\r\n*data_dir = FSF_DATADIR_WRITE;\r\nbreak;\r\ncase DMA_BIDIRECTIONAL:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SCSI_PROT_READ_STRIP:\r\n*data_dir = FSF_DATADIR_DIF_READ_STRIP;\r\nbreak;\r\ncase SCSI_PROT_WRITE_INSERT:\r\n*data_dir = FSF_DATADIR_DIF_WRITE_INSERT;\r\nbreak;\r\ncase SCSI_PROT_READ_PASS:\r\n*data_dir = FSF_DATADIR_DIF_READ_CONVERT;\r\nbreak;\r\ncase SCSI_PROT_WRITE_PASS:\r\n*data_dir = FSF_DATADIR_DIF_WRITE_CONVERT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint zfcp_fsf_fcp_cmnd(struct scsi_cmnd *scsi_cmnd)\r\n{\r\nstruct zfcp_fsf_req *req;\r\nstruct fcp_cmnd *fcp_cmnd;\r\nu8 sbtype = SBAL_SFLAGS0_TYPE_READ;\r\nint retval = -EIO;\r\nstruct scsi_device *sdev = scsi_cmnd->device;\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\r\nstruct zfcp_adapter *adapter = zfcp_sdev->port->adapter;\r\nstruct zfcp_qdio *qdio = adapter->qdio;\r\nstruct fsf_qtcb_bottom_io *io;\r\nunsigned long flags;\r\nif (unlikely(!(atomic_read(&zfcp_sdev->status) &\r\nZFCP_STATUS_COMMON_UNBLOCKED)))\r\nreturn -EBUSY;\r\nspin_lock_irqsave(&qdio->req_q_lock, flags);\r\nif (atomic_read(&qdio->req_q_free) <= 0) {\r\natomic_inc(&qdio->req_q_full);\r\ngoto out;\r\n}\r\nif (scsi_cmnd->sc_data_direction == DMA_TO_DEVICE)\r\nsbtype = SBAL_SFLAGS0_TYPE_WRITE;\r\nreq = zfcp_fsf_req_create(qdio, FSF_QTCB_FCP_CMND,\r\nsbtype, adapter->pool.scsi_req);\r\nif (IS_ERR(req)) {\r\nretval = PTR_ERR(req);\r\ngoto out;\r\n}\r\nscsi_cmnd->host_scribble = (unsigned char *) req->req_id;\r\nio = &req->qtcb->bottom.io;\r\nreq->status |= ZFCP_STATUS_FSFREQ_CLEANUP;\r\nreq->data = scsi_cmnd;\r\nreq->handler = zfcp_fsf_fcp_cmnd_handler;\r\nreq->qtcb->header.lun_handle = zfcp_sdev->lun_handle;\r\nreq->qtcb->header.port_handle = zfcp_sdev->port->handle;\r\nio->service_class = FSF_CLASS_3;\r\nio->fcp_cmnd_length = FCP_CMND_LEN;\r\nif (scsi_get_prot_op(scsi_cmnd) != SCSI_PROT_NORMAL) {\r\nio->data_block_length = scsi_cmnd->device->sector_size;\r\nio->ref_tag_value = scsi_get_lba(scsi_cmnd) & 0xFFFFFFFF;\r\n}\r\nif (zfcp_fsf_set_data_dir(scsi_cmnd, &io->data_direction))\r\ngoto failed_scsi_cmnd;\r\nfcp_cmnd = (struct fcp_cmnd *) &req->qtcb->bottom.io.fcp_cmnd;\r\nzfcp_fc_scsi_to_fcp(fcp_cmnd, scsi_cmnd, 0);\r\nif (scsi_prot_sg_count(scsi_cmnd)) {\r\nzfcp_qdio_set_data_div(qdio, &req->qdio_req,\r\nscsi_prot_sg_count(scsi_cmnd));\r\nretval = zfcp_qdio_sbals_from_sg(qdio, &req->qdio_req,\r\nscsi_prot_sglist(scsi_cmnd));\r\nif (retval)\r\ngoto failed_scsi_cmnd;\r\nio->prot_data_length = zfcp_qdio_real_bytes(\r\nscsi_prot_sglist(scsi_cmnd));\r\n}\r\nretval = zfcp_qdio_sbals_from_sg(qdio, &req->qdio_req,\r\nscsi_sglist(scsi_cmnd));\r\nif (unlikely(retval))\r\ngoto failed_scsi_cmnd;\r\nzfcp_qdio_set_sbale_last(adapter->qdio, &req->qdio_req);\r\nif (zfcp_adapter_multi_buffer_active(adapter))\r\nzfcp_qdio_set_scount(qdio, &req->qdio_req);\r\nretval = zfcp_fsf_req_send(req);\r\nif (unlikely(retval))\r\ngoto failed_scsi_cmnd;\r\ngoto out;\r\nfailed_scsi_cmnd:\r\nzfcp_fsf_req_free(req);\r\nscsi_cmnd->host_scribble = NULL;\r\nout:\r\nspin_unlock_irqrestore(&qdio->req_q_lock, flags);\r\nreturn retval;\r\n}\r\nstatic void zfcp_fsf_fcp_task_mgmt_handler(struct zfcp_fsf_req *req)\r\n{\r\nstruct fcp_resp_with_ext *fcp_rsp;\r\nstruct fcp_resp_rsp_info *rsp_info;\r\nzfcp_fsf_fcp_handler_common(req);\r\nfcp_rsp = (struct fcp_resp_with_ext *) &req->qtcb->bottom.io.fcp_rsp;\r\nrsp_info = (struct fcp_resp_rsp_info *) &fcp_rsp[1];\r\nif ((rsp_info->rsp_code != FCP_TMF_CMPL) ||\r\n(req->status & ZFCP_STATUS_FSFREQ_ERROR))\r\nreq->status |= ZFCP_STATUS_FSFREQ_TMFUNCFAILED;\r\n}\r\nstruct zfcp_fsf_req *zfcp_fsf_fcp_task_mgmt(struct scsi_cmnd *scmnd,\r\nu8 tm_flags)\r\n{\r\nstruct zfcp_fsf_req *req = NULL;\r\nstruct fcp_cmnd *fcp_cmnd;\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scmnd->device);\r\nstruct zfcp_qdio *qdio = zfcp_sdev->port->adapter->qdio;\r\nif (unlikely(!(atomic_read(&zfcp_sdev->status) &\r\nZFCP_STATUS_COMMON_UNBLOCKED)))\r\nreturn NULL;\r\nspin_lock_irq(&qdio->req_q_lock);\r\nif (zfcp_qdio_sbal_get(qdio))\r\ngoto out;\r\nreq = zfcp_fsf_req_create(qdio, FSF_QTCB_FCP_CMND,\r\nSBAL_SFLAGS0_TYPE_WRITE,\r\nqdio->adapter->pool.scsi_req);\r\nif (IS_ERR(req)) {\r\nreq = NULL;\r\ngoto out;\r\n}\r\nreq->data = scmnd;\r\nreq->handler = zfcp_fsf_fcp_task_mgmt_handler;\r\nreq->qtcb->header.lun_handle = zfcp_sdev->lun_handle;\r\nreq->qtcb->header.port_handle = zfcp_sdev->port->handle;\r\nreq->qtcb->bottom.io.data_direction = FSF_DATADIR_CMND;\r\nreq->qtcb->bottom.io.service_class = FSF_CLASS_3;\r\nreq->qtcb->bottom.io.fcp_cmnd_length = FCP_CMND_LEN;\r\nzfcp_qdio_set_sbale_last(qdio, &req->qdio_req);\r\nfcp_cmnd = (struct fcp_cmnd *) &req->qtcb->bottom.io.fcp_cmnd;\r\nzfcp_fc_scsi_to_fcp(fcp_cmnd, scmnd, tm_flags);\r\nzfcp_fsf_start_timer(req, ZFCP_SCSI_ER_TIMEOUT);\r\nif (!zfcp_fsf_req_send(req))\r\ngoto out;\r\nzfcp_fsf_req_free(req);\r\nreq = NULL;\r\nout:\r\nspin_unlock_irq(&qdio->req_q_lock);\r\nreturn req;\r\n}\r\nvoid zfcp_fsf_reqid_check(struct zfcp_qdio *qdio, int sbal_idx)\r\n{\r\nstruct zfcp_adapter *adapter = qdio->adapter;\r\nstruct qdio_buffer *sbal = qdio->res_q[sbal_idx];\r\nstruct qdio_buffer_element *sbale;\r\nstruct zfcp_fsf_req *fsf_req;\r\nunsigned long req_id;\r\nint idx;\r\nfor (idx = 0; idx < QDIO_MAX_ELEMENTS_PER_BUFFER; idx++) {\r\nsbale = &sbal->element[idx];\r\nreq_id = (unsigned long) sbale->addr;\r\nfsf_req = zfcp_reqlist_find_rm(adapter->req_list, req_id);\r\nif (!fsf_req) {\r\nzfcp_qdio_siosl(adapter);\r\npanic("error: unknown req_id (%lx) on adapter %s.\n",\r\nreq_id, dev_name(&adapter->ccw_device->dev));\r\n}\r\nfsf_req->qdio_req.sbal_response = sbal_idx;\r\nzfcp_fsf_req_complete(fsf_req);\r\nif (likely(sbale->eflags & SBAL_EFLAGS_LAST_ENTRY))\r\nbreak;\r\n}\r\n}
