static void i2c_int_disable(struct axxia_i2c_dev *idev, u32 mask)\r\n{\r\nu32 int_en;\r\nint_en = readl(idev->base + MST_INT_ENABLE);\r\nwritel(int_en & ~mask, idev->base + MST_INT_ENABLE);\r\n}\r\nstatic void i2c_int_enable(struct axxia_i2c_dev *idev, u32 mask)\r\n{\r\nu32 int_en;\r\nint_en = readl(idev->base + MST_INT_ENABLE);\r\nwritel(int_en | mask, idev->base + MST_INT_ENABLE);\r\n}\r\nstatic u32 ns_to_clk(u64 ns, u32 clk_mhz)\r\n{\r\nreturn div_u64(ns * clk_mhz, 1000);\r\n}\r\nstatic int axxia_i2c_init(struct axxia_i2c_dev *idev)\r\n{\r\nu32 divisor = clk_get_rate(idev->i2c_clk) / idev->bus_clk_rate;\r\nu32 clk_mhz = clk_get_rate(idev->i2c_clk) / 1000000;\r\nu32 t_setup;\r\nu32 t_high, t_low;\r\nu32 tmo_clk;\r\nu32 prescale;\r\nunsigned long timeout;\r\ndev_dbg(idev->dev, "rate=%uHz per_clk=%uMHz -> ratio=1:%u\n",\r\nidev->bus_clk_rate, clk_mhz, divisor);\r\nwritel(0x01, idev->base + SOFT_RESET);\r\ntimeout = jiffies + msecs_to_jiffies(100);\r\nwhile (readl(idev->base + SOFT_RESET) & 1) {\r\nif (time_after(jiffies, timeout)) {\r\ndev_warn(idev->dev, "Soft reset failed\n");\r\nbreak;\r\n}\r\n}\r\nwritel(0x1, idev->base + GLOBAL_CONTROL);\r\nif (idev->bus_clk_rate <= 100000) {\r\nt_high = divisor * 1 / 2;\r\nt_low = divisor * 1 / 2;\r\nt_setup = ns_to_clk(250, clk_mhz);\r\n} else {\r\nt_high = divisor * 1 / 3;\r\nt_low = divisor * 2 / 3;\r\nt_setup = ns_to_clk(100, clk_mhz);\r\n}\r\nwritel(t_high, idev->base + SCL_HIGH_PERIOD);\r\nwritel(t_low, idev->base + SCL_LOW_PERIOD);\r\nwritel(t_setup, idev->base + SDA_SETUP_TIME);\r\nwritel(ns_to_clk(300, clk_mhz), idev->base + SDA_HOLD_TIME);\r\nwritel(ns_to_clk(50, clk_mhz), idev->base + SPIKE_FLTR_LEN);\r\ntmo_clk = ns_to_clk(SCL_WAIT_TIMEOUT_NS, clk_mhz);\r\nfor (prescale = 0; prescale < 15; ++prescale) {\r\nif (tmo_clk <= 0x7fff)\r\nbreak;\r\ntmo_clk >>= 1;\r\n}\r\nif (tmo_clk > 0x7fff)\r\ntmo_clk = 0x7fff;\r\nwritel(prescale, idev->base + TIMER_CLOCK_DIV);\r\nwritel(WT_EN | WT_VALUE(tmo_clk), idev->base + WAIT_TIMER_CONTROL);\r\ni2c_int_disable(idev, ~0);\r\nwritel(0x01, idev->base + INTERRUPT_ENABLE);\r\nreturn 0;\r\n}\r\nstatic int i2c_m_rd(const struct i2c_msg *msg)\r\n{\r\nreturn (msg->flags & I2C_M_RD) != 0;\r\n}\r\nstatic int i2c_m_ten(const struct i2c_msg *msg)\r\n{\r\nreturn (msg->flags & I2C_M_TEN) != 0;\r\n}\r\nstatic int i2c_m_recv_len(const struct i2c_msg *msg)\r\n{\r\nreturn (msg->flags & I2C_M_RECV_LEN) != 0;\r\n}\r\nstatic int axxia_i2c_empty_rx_fifo(struct axxia_i2c_dev *idev)\r\n{\r\nstruct i2c_msg *msg = idev->msg;\r\nsize_t rx_fifo_avail = readl(idev->base + MST_RX_FIFO);\r\nint bytes_to_transfer = min(rx_fifo_avail, msg->len - idev->msg_xfrd);\r\nwhile (bytes_to_transfer-- > 0) {\r\nint c = readl(idev->base + MST_DATA);\r\nif (idev->msg_xfrd == 0 && i2c_m_recv_len(msg)) {\r\nif (c <= 0 || c > I2C_SMBUS_BLOCK_MAX) {\r\nidev->msg_err = -EPROTO;\r\ni2c_int_disable(idev, ~0);\r\ncomplete(&idev->msg_complete);\r\nbreak;\r\n}\r\nmsg->len = 1 + c;\r\nwritel(msg->len, idev->base + MST_RX_XFER);\r\n}\r\nmsg->buf[idev->msg_xfrd++] = c;\r\n}\r\nreturn 0;\r\n}\r\nstatic int axxia_i2c_fill_tx_fifo(struct axxia_i2c_dev *idev)\r\n{\r\nstruct i2c_msg *msg = idev->msg;\r\nsize_t tx_fifo_avail = FIFO_SIZE - readl(idev->base + MST_TX_FIFO);\r\nint bytes_to_transfer = min(tx_fifo_avail, msg->len - idev->msg_xfrd);\r\nint ret = msg->len - idev->msg_xfrd - bytes_to_transfer;\r\nwhile (bytes_to_transfer-- > 0)\r\nwritel(msg->buf[idev->msg_xfrd++], idev->base + MST_DATA);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t axxia_i2c_isr(int irq, void *_dev)\r\n{\r\nstruct axxia_i2c_dev *idev = _dev;\r\nu32 status;\r\nif (!(readl(idev->base + INTERRUPT_STATUS) & INT_MST))\r\nreturn IRQ_NONE;\r\nstatus = readl(idev->base + MST_INT_STATUS);\r\nif (!idev->msg) {\r\ndev_warn(idev->dev, "unexpected interrupt\n");\r\ngoto out;\r\n}\r\nif (i2c_m_rd(idev->msg) && (status & MST_STATUS_RFL))\r\naxxia_i2c_empty_rx_fifo(idev);\r\nif (!i2c_m_rd(idev->msg) && (status & MST_STATUS_TFL)) {\r\nif (axxia_i2c_fill_tx_fifo(idev) == 0)\r\ni2c_int_disable(idev, MST_STATUS_TFL);\r\n}\r\nif (status & MST_STATUS_SCC) {\r\ni2c_int_disable(idev, ~0);\r\ncomplete(&idev->msg_complete);\r\n} else if (status & MST_STATUS_SNS) {\r\ni2c_int_disable(idev, ~0);\r\nif (i2c_m_rd(idev->msg) && idev->msg_xfrd < idev->msg->len)\r\naxxia_i2c_empty_rx_fifo(idev);\r\ncomplete(&idev->msg_complete);\r\n} else if (unlikely(status & MST_STATUS_ERR)) {\r\ni2c_int_disable(idev, ~0);\r\nif (status & MST_STATUS_AL)\r\nidev->msg_err = -EAGAIN;\r\nelse if (status & MST_STATUS_NAK)\r\nidev->msg_err = -ENXIO;\r\nelse\r\nidev->msg_err = -EIO;\r\ndev_dbg(idev->dev, "error %#x, addr=%#x rx=%u/%u tx=%u/%u\n",\r\nstatus,\r\nidev->msg->addr,\r\nreadl(idev->base + MST_RX_BYTES_XFRD),\r\nreadl(idev->base + MST_RX_XFER),\r\nreadl(idev->base + MST_TX_BYTES_XFRD),\r\nreadl(idev->base + MST_TX_XFER));\r\ncomplete(&idev->msg_complete);\r\n}\r\nout:\r\nwritel(INT_MST, idev->base + INTERRUPT_STATUS);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int axxia_i2c_xfer_msg(struct axxia_i2c_dev *idev, struct i2c_msg *msg)\r\n{\r\nu32 int_mask = MST_STATUS_ERR | MST_STATUS_SNS;\r\nu32 rx_xfer, tx_xfer;\r\nu32 addr_1, addr_2;\r\nint ret;\r\nif (msg->len > 255) {\r\ndev_warn(idev->dev, "unsupported length %u\n", msg->len);\r\nreturn -EINVAL;\r\n}\r\nidev->msg = msg;\r\nidev->msg_xfrd = 0;\r\nidev->msg_err = 0;\r\nreinit_completion(&idev->msg_complete);\r\nif (i2c_m_ten(msg)) {\r\naddr_1 = 0xF0 | ((msg->addr >> 7) & 0x06);\r\naddr_2 = msg->addr & 0xFF;\r\n} else {\r\naddr_1 = (msg->addr << 1) & 0xFF;\r\naddr_2 = 0;\r\n}\r\nif (i2c_m_rd(msg)) {\r\nrx_xfer = i2c_m_recv_len(msg) ? I2C_SMBUS_BLOCK_MAX : msg->len;\r\ntx_xfer = 0;\r\naddr_1 |= 1;\r\n} else {\r\nrx_xfer = 0;\r\ntx_xfer = msg->len;\r\n}\r\nwritel(rx_xfer, idev->base + MST_RX_XFER);\r\nwritel(tx_xfer, idev->base + MST_TX_XFER);\r\nwritel(addr_1, idev->base + MST_ADDR_1);\r\nwritel(addr_2, idev->base + MST_ADDR_2);\r\nif (i2c_m_rd(msg))\r\nint_mask |= MST_STATUS_RFL;\r\nelse if (axxia_i2c_fill_tx_fifo(idev) != 0)\r\nint_mask |= MST_STATUS_TFL;\r\nwritel(CMD_MANUAL, idev->base + MST_COMMAND);\r\ni2c_int_enable(idev, int_mask);\r\nret = wait_for_completion_timeout(&idev->msg_complete,\r\nI2C_XFER_TIMEOUT);\r\ni2c_int_disable(idev, int_mask);\r\nif (readl(idev->base + MST_COMMAND) & CMD_BUSY)\r\ndev_warn(idev->dev, "busy after xfer\n");\r\nif (ret == 0)\r\nidev->msg_err = -ETIMEDOUT;\r\nif (unlikely(idev->msg_err) && idev->msg_err != -ENXIO)\r\naxxia_i2c_init(idev);\r\nreturn idev->msg_err;\r\n}\r\nstatic int axxia_i2c_stop(struct axxia_i2c_dev *idev)\r\n{\r\nu32 int_mask = MST_STATUS_ERR | MST_STATUS_SCC;\r\nint ret;\r\nreinit_completion(&idev->msg_complete);\r\nwritel(0xb, idev->base + MST_COMMAND);\r\ni2c_int_enable(idev, int_mask);\r\nret = wait_for_completion_timeout(&idev->msg_complete,\r\nI2C_STOP_TIMEOUT);\r\ni2c_int_disable(idev, int_mask);\r\nif (ret == 0)\r\nreturn -ETIMEDOUT;\r\nif (readl(idev->base + MST_COMMAND) & CMD_BUSY)\r\ndev_warn(idev->dev, "busy after stop\n");\r\nreturn 0;\r\n}\r\nstatic int\r\naxxia_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\r\n{\r\nstruct axxia_i2c_dev *idev = i2c_get_adapdata(adap);\r\nint i;\r\nint ret = 0;\r\nfor (i = 0; ret == 0 && i < num; ++i)\r\nret = axxia_i2c_xfer_msg(idev, &msgs[i]);\r\naxxia_i2c_stop(idev);\r\nreturn ret ? : i;\r\n}\r\nstatic u32 axxia_i2c_func(struct i2c_adapter *adap)\r\n{\r\nu32 caps = (I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR |\r\nI2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_BLOCK_DATA);\r\nreturn caps;\r\n}\r\nstatic int axxia_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct axxia_i2c_dev *idev = NULL;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nint irq;\r\nint ret = 0;\r\nidev = devm_kzalloc(&pdev->dev, sizeof(*idev), GFP_KERNEL);\r\nif (!idev)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "missing interrupt resource\n");\r\nreturn irq;\r\n}\r\nidev->i2c_clk = devm_clk_get(&pdev->dev, "i2c");\r\nif (IS_ERR(idev->i2c_clk)) {\r\ndev_err(&pdev->dev, "missing clock\n");\r\nreturn PTR_ERR(idev->i2c_clk);\r\n}\r\nidev->base = base;\r\nidev->dev = &pdev->dev;\r\ninit_completion(&idev->msg_complete);\r\nof_property_read_u32(np, "clock-frequency", &idev->bus_clk_rate);\r\nif (idev->bus_clk_rate == 0)\r\nidev->bus_clk_rate = 100000;\r\nret = axxia_i2c_init(idev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to initialize\n");\r\nreturn ret;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, axxia_i2c_isr, 0,\r\npdev->name, idev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to claim IRQ%d\n", irq);\r\nreturn ret;\r\n}\r\nclk_prepare_enable(idev->i2c_clk);\r\ni2c_set_adapdata(&idev->adapter, idev);\r\nstrlcpy(idev->adapter.name, pdev->name, sizeof(idev->adapter.name));\r\nidev->adapter.owner = THIS_MODULE;\r\nidev->adapter.algo = &axxia_i2c_algo;\r\nidev->adapter.dev.parent = &pdev->dev;\r\nidev->adapter.dev.of_node = pdev->dev.of_node;\r\nplatform_set_drvdata(pdev, idev);\r\nret = i2c_add_adapter(&idev->adapter);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add adapter\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int axxia_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct axxia_i2c_dev *idev = platform_get_drvdata(pdev);\r\nclk_disable_unprepare(idev->i2c_clk);\r\ni2c_del_adapter(&idev->adapter);\r\nreturn 0;\r\n}
