void ucb1x00_io_set_dir(struct ucb1x00 *ucb, unsigned int in, unsigned int out)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ucb->io_lock, flags);\r\nucb->io_dir |= out;\r\nucb->io_dir &= ~in;\r\nucb1x00_reg_write(ucb, UCB_IO_DIR, ucb->io_dir);\r\nspin_unlock_irqrestore(&ucb->io_lock, flags);\r\n}\r\nvoid ucb1x00_io_write(struct ucb1x00 *ucb, unsigned int set, unsigned int clear)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ucb->io_lock, flags);\r\nucb->io_out |= set;\r\nucb->io_out &= ~clear;\r\nucb1x00_reg_write(ucb, UCB_IO_DATA, ucb->io_out);\r\nspin_unlock_irqrestore(&ucb->io_lock, flags);\r\n}\r\nunsigned int ucb1x00_io_read(struct ucb1x00 *ucb)\r\n{\r\nreturn ucb1x00_reg_read(ucb, UCB_IO_DATA);\r\n}\r\nstatic void ucb1x00_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct ucb1x00 *ucb = container_of(chip, struct ucb1x00, gpio);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ucb->io_lock, flags);\r\nif (value)\r\nucb->io_out |= 1 << offset;\r\nelse\r\nucb->io_out &= ~(1 << offset);\r\nucb1x00_enable(ucb);\r\nucb1x00_reg_write(ucb, UCB_IO_DATA, ucb->io_out);\r\nucb1x00_disable(ucb);\r\nspin_unlock_irqrestore(&ucb->io_lock, flags);\r\n}\r\nstatic int ucb1x00_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct ucb1x00 *ucb = container_of(chip, struct ucb1x00, gpio);\r\nunsigned val;\r\nucb1x00_enable(ucb);\r\nval = ucb1x00_reg_read(ucb, UCB_IO_DATA);\r\nucb1x00_disable(ucb);\r\nreturn val & (1 << offset);\r\n}\r\nstatic int ucb1x00_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct ucb1x00 *ucb = container_of(chip, struct ucb1x00, gpio);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ucb->io_lock, flags);\r\nucb->io_dir &= ~(1 << offset);\r\nucb1x00_enable(ucb);\r\nucb1x00_reg_write(ucb, UCB_IO_DIR, ucb->io_dir);\r\nucb1x00_disable(ucb);\r\nspin_unlock_irqrestore(&ucb->io_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ucb1x00_gpio_direction_output(struct gpio_chip *chip, unsigned offset\r\n, int value)\r\n{\r\nstruct ucb1x00 *ucb = container_of(chip, struct ucb1x00, gpio);\r\nunsigned long flags;\r\nunsigned old, mask = 1 << offset;\r\nspin_lock_irqsave(&ucb->io_lock, flags);\r\nold = ucb->io_out;\r\nif (value)\r\nucb->io_out |= mask;\r\nelse\r\nucb->io_out &= ~mask;\r\nucb1x00_enable(ucb);\r\nif (old != ucb->io_out)\r\nucb1x00_reg_write(ucb, UCB_IO_DATA, ucb->io_out);\r\nif (!(ucb->io_dir & mask)) {\r\nucb->io_dir |= mask;\r\nucb1x00_reg_write(ucb, UCB_IO_DIR, ucb->io_dir);\r\n}\r\nucb1x00_disable(ucb);\r\nspin_unlock_irqrestore(&ucb->io_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ucb1x00_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct ucb1x00 *ucb = container_of(chip, struct ucb1x00, gpio);\r\nreturn ucb->irq_base > 0 ? ucb->irq_base + offset : -ENXIO;\r\n}\r\nvoid ucb1x00_adc_enable(struct ucb1x00 *ucb)\r\n{\r\nmutex_lock(&ucb->adc_mutex);\r\nucb->adc_cr |= UCB_ADC_ENA;\r\nucb1x00_enable(ucb);\r\nucb1x00_reg_write(ucb, UCB_ADC_CR, ucb->adc_cr);\r\n}\r\nunsigned int ucb1x00_adc_read(struct ucb1x00 *ucb, int adc_channel, int sync)\r\n{\r\nunsigned int val;\r\nif (sync)\r\nadc_channel |= UCB_ADC_SYNC_ENA;\r\nucb1x00_reg_write(ucb, UCB_ADC_CR, ucb->adc_cr | adc_channel);\r\nucb1x00_reg_write(ucb, UCB_ADC_CR, ucb->adc_cr | adc_channel | UCB_ADC_START);\r\nfor (;;) {\r\nval = ucb1x00_reg_read(ucb, UCB_ADC_DATA);\r\nif (val & UCB_ADC_DAT_VAL)\r\nbreak;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(1);\r\n}\r\nreturn UCB_ADC_DAT(val);\r\n}\r\nvoid ucb1x00_adc_disable(struct ucb1x00 *ucb)\r\n{\r\nucb->adc_cr &= ~UCB_ADC_ENA;\r\nucb1x00_reg_write(ucb, UCB_ADC_CR, ucb->adc_cr);\r\nucb1x00_disable(ucb);\r\nmutex_unlock(&ucb->adc_mutex);\r\n}\r\nstatic void ucb1x00_irq(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct ucb1x00 *ucb = irq_desc_get_handler_data(desc);\r\nunsigned int isr, i;\r\nucb1x00_enable(ucb);\r\nisr = ucb1x00_reg_read(ucb, UCB_IE_STATUS);\r\nucb1x00_reg_write(ucb, UCB_IE_CLEAR, isr);\r\nucb1x00_reg_write(ucb, UCB_IE_CLEAR, 0);\r\nfor (i = 0; i < 16 && isr; i++, isr >>= 1, irq++)\r\nif (isr & 1)\r\ngeneric_handle_irq(ucb->irq_base + i);\r\nucb1x00_disable(ucb);\r\n}\r\nstatic void ucb1x00_irq_update(struct ucb1x00 *ucb, unsigned mask)\r\n{\r\nucb1x00_enable(ucb);\r\nif (ucb->irq_ris_enbl & mask)\r\nucb1x00_reg_write(ucb, UCB_IE_RIS, ucb->irq_ris_enbl &\r\nucb->irq_mask);\r\nif (ucb->irq_fal_enbl & mask)\r\nucb1x00_reg_write(ucb, UCB_IE_FAL, ucb->irq_fal_enbl &\r\nucb->irq_mask);\r\nucb1x00_disable(ucb);\r\n}\r\nstatic void ucb1x00_irq_noop(struct irq_data *data)\r\n{\r\n}\r\nstatic void ucb1x00_irq_mask(struct irq_data *data)\r\n{\r\nstruct ucb1x00 *ucb = irq_data_get_irq_chip_data(data);\r\nunsigned mask = 1 << (data->irq - ucb->irq_base);\r\nraw_spin_lock(&ucb->irq_lock);\r\nucb->irq_mask &= ~mask;\r\nucb1x00_irq_update(ucb, mask);\r\nraw_spin_unlock(&ucb->irq_lock);\r\n}\r\nstatic void ucb1x00_irq_unmask(struct irq_data *data)\r\n{\r\nstruct ucb1x00 *ucb = irq_data_get_irq_chip_data(data);\r\nunsigned mask = 1 << (data->irq - ucb->irq_base);\r\nraw_spin_lock(&ucb->irq_lock);\r\nucb->irq_mask |= mask;\r\nucb1x00_irq_update(ucb, mask);\r\nraw_spin_unlock(&ucb->irq_lock);\r\n}\r\nstatic int ucb1x00_irq_set_type(struct irq_data *data, unsigned int type)\r\n{\r\nstruct ucb1x00 *ucb = irq_data_get_irq_chip_data(data);\r\nunsigned mask = 1 << (data->irq - ucb->irq_base);\r\nraw_spin_lock(&ucb->irq_lock);\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nucb->irq_ris_enbl |= mask;\r\nelse\r\nucb->irq_ris_enbl &= ~mask;\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nucb->irq_fal_enbl |= mask;\r\nelse\r\nucb->irq_fal_enbl &= ~mask;\r\nif (ucb->irq_mask & mask) {\r\nucb1x00_reg_write(ucb, UCB_IE_RIS, ucb->irq_ris_enbl &\r\nucb->irq_mask);\r\nucb1x00_reg_write(ucb, UCB_IE_FAL, ucb->irq_fal_enbl &\r\nucb->irq_mask);\r\n}\r\nraw_spin_unlock(&ucb->irq_lock);\r\nreturn 0;\r\n}\r\nstatic int ucb1x00_irq_set_wake(struct irq_data *data, unsigned int on)\r\n{\r\nstruct ucb1x00 *ucb = irq_data_get_irq_chip_data(data);\r\nstruct ucb1x00_plat_data *pdata = ucb->mcp->attached_device.platform_data;\r\nunsigned mask = 1 << (data->irq - ucb->irq_base);\r\nif (!pdata || !pdata->can_wakeup)\r\nreturn -EINVAL;\r\nraw_spin_lock(&ucb->irq_lock);\r\nif (on)\r\nucb->irq_wake |= mask;\r\nelse\r\nucb->irq_wake &= ~mask;\r\nraw_spin_unlock(&ucb->irq_lock);\r\nreturn 0;\r\n}\r\nstatic int ucb1x00_add_dev(struct ucb1x00 *ucb, struct ucb1x00_driver *drv)\r\n{\r\nstruct ucb1x00_dev *dev;\r\nint ret;\r\ndev = kmalloc(sizeof(struct ucb1x00_dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->ucb = ucb;\r\ndev->drv = drv;\r\nret = drv->add(dev);\r\nif (ret) {\r\nkfree(dev);\r\nreturn ret;\r\n}\r\nlist_add_tail(&dev->dev_node, &ucb->devs);\r\nlist_add_tail(&dev->drv_node, &drv->devs);\r\nreturn ret;\r\n}\r\nstatic void ucb1x00_remove_dev(struct ucb1x00_dev *dev)\r\n{\r\ndev->drv->remove(dev);\r\nlist_del(&dev->dev_node);\r\nlist_del(&dev->drv_node);\r\nkfree(dev);\r\n}\r\nstatic int ucb1x00_detect_irq(struct ucb1x00 *ucb)\r\n{\r\nunsigned long mask;\r\nmask = probe_irq_on();\r\nif (!mask) {\r\nprobe_irq_off(mask);\r\nreturn NO_IRQ;\r\n}\r\nucb1x00_reg_write(ucb, UCB_IE_RIS, UCB_IE_ADC);\r\nucb1x00_reg_write(ucb, UCB_IE_FAL, UCB_IE_ADC);\r\nucb1x00_reg_write(ucb, UCB_IE_CLEAR, 0xffff);\r\nucb1x00_reg_write(ucb, UCB_IE_CLEAR, 0);\r\nucb1x00_reg_write(ucb, UCB_ADC_CR, UCB_ADC_ENA);\r\nucb1x00_reg_write(ucb, UCB_ADC_CR, UCB_ADC_ENA | UCB_ADC_START);\r\nwhile ((ucb1x00_reg_read(ucb, UCB_ADC_DATA) & UCB_ADC_DAT_VAL) == 0);\r\nucb1x00_reg_write(ucb, UCB_ADC_CR, 0);\r\nucb1x00_reg_write(ucb, UCB_IE_RIS, 0);\r\nucb1x00_reg_write(ucb, UCB_IE_FAL, 0);\r\nucb1x00_reg_write(ucb, UCB_IE_CLEAR, 0xffff);\r\nucb1x00_reg_write(ucb, UCB_IE_CLEAR, 0);\r\nreturn probe_irq_off(mask);\r\n}\r\nstatic void ucb1x00_release(struct device *dev)\r\n{\r\nstruct ucb1x00 *ucb = classdev_to_ucb1x00(dev);\r\nkfree(ucb);\r\n}\r\nstatic int ucb1x00_probe(struct mcp *mcp)\r\n{\r\nstruct ucb1x00_plat_data *pdata = mcp->attached_device.platform_data;\r\nstruct ucb1x00_driver *drv;\r\nstruct ucb1x00 *ucb;\r\nunsigned id, i, irq_base;\r\nint ret = -ENODEV;\r\nif (pdata && pdata->reset)\r\npdata->reset(UCB_RST_PROBE);\r\nmcp_enable(mcp);\r\nid = mcp_reg_read(mcp, UCB_ID);\r\nmcp_disable(mcp);\r\nif (id != UCB_ID_1200 && id != UCB_ID_1300 && id != UCB_ID_TC35143) {\r\nprintk(KERN_WARNING "UCB1x00 ID not found: %04x\n", id);\r\ngoto out;\r\n}\r\nucb = kzalloc(sizeof(struct ucb1x00), GFP_KERNEL);\r\nret = -ENOMEM;\r\nif (!ucb)\r\ngoto out;\r\ndevice_initialize(&ucb->dev);\r\nucb->dev.class = &ucb1x00_class;\r\nucb->dev.parent = &mcp->attached_device;\r\ndev_set_name(&ucb->dev, "ucb1x00");\r\nraw_spin_lock_init(&ucb->irq_lock);\r\nspin_lock_init(&ucb->io_lock);\r\nmutex_init(&ucb->adc_mutex);\r\nucb->id = id;\r\nucb->mcp = mcp;\r\nret = device_add(&ucb->dev);\r\nif (ret)\r\ngoto err_dev_add;\r\nucb1x00_enable(ucb);\r\nucb->irq = ucb1x00_detect_irq(ucb);\r\nucb1x00_disable(ucb);\r\nif (ucb->irq == NO_IRQ) {\r\ndev_err(&ucb->dev, "IRQ probe failed\n");\r\nret = -ENODEV;\r\ngoto err_no_irq;\r\n}\r\nucb->gpio.base = -1;\r\nirq_base = pdata ? pdata->irq_base : 0;\r\nucb->irq_base = irq_alloc_descs(-1, irq_base, 16, -1);\r\nif (ucb->irq_base < 0) {\r\ndev_err(&ucb->dev, "unable to allocate 16 irqs: %d\n",\r\nucb->irq_base);\r\nret = ucb->irq_base;\r\ngoto err_irq_alloc;\r\n}\r\nfor (i = 0; i < 16; i++) {\r\nunsigned irq = ucb->irq_base + i;\r\nirq_set_chip_and_handler(irq, &ucb1x00_irqchip, handle_edge_irq);\r\nirq_set_chip_data(irq, ucb);\r\nset_irq_flags(irq, IRQF_VALID | IRQ_NOREQUEST);\r\n}\r\nirq_set_irq_type(ucb->irq, IRQ_TYPE_EDGE_RISING);\r\nirq_set_handler_data(ucb->irq, ucb);\r\nirq_set_chained_handler(ucb->irq, ucb1x00_irq);\r\nif (pdata && pdata->gpio_base) {\r\nucb->gpio.label = dev_name(&ucb->dev);\r\nucb->gpio.dev = &ucb->dev;\r\nucb->gpio.owner = THIS_MODULE;\r\nucb->gpio.base = pdata->gpio_base;\r\nucb->gpio.ngpio = 10;\r\nucb->gpio.set = ucb1x00_gpio_set;\r\nucb->gpio.get = ucb1x00_gpio_get;\r\nucb->gpio.direction_input = ucb1x00_gpio_direction_input;\r\nucb->gpio.direction_output = ucb1x00_gpio_direction_output;\r\nucb->gpio.to_irq = ucb1x00_to_irq;\r\nret = gpiochip_add(&ucb->gpio);\r\nif (ret)\r\ngoto err_gpio_add;\r\n} else\r\ndev_info(&ucb->dev, "gpio_base not set so no gpiolib support");\r\nmcp_set_drvdata(mcp, ucb);\r\nif (pdata)\r\ndevice_set_wakeup_capable(&ucb->dev, pdata->can_wakeup);\r\nINIT_LIST_HEAD(&ucb->devs);\r\nmutex_lock(&ucb1x00_mutex);\r\nlist_add_tail(&ucb->node, &ucb1x00_devices);\r\nlist_for_each_entry(drv, &ucb1x00_drivers, node) {\r\nucb1x00_add_dev(ucb, drv);\r\n}\r\nmutex_unlock(&ucb1x00_mutex);\r\nreturn ret;\r\nerr_gpio_add:\r\nirq_set_chained_handler(ucb->irq, NULL);\r\nerr_irq_alloc:\r\nif (ucb->irq_base > 0)\r\nirq_free_descs(ucb->irq_base, 16);\r\nerr_no_irq:\r\ndevice_del(&ucb->dev);\r\nerr_dev_add:\r\nput_device(&ucb->dev);\r\nout:\r\nif (pdata && pdata->reset)\r\npdata->reset(UCB_RST_PROBE_FAIL);\r\nreturn ret;\r\n}\r\nstatic void ucb1x00_remove(struct mcp *mcp)\r\n{\r\nstruct ucb1x00_plat_data *pdata = mcp->attached_device.platform_data;\r\nstruct ucb1x00 *ucb = mcp_get_drvdata(mcp);\r\nstruct list_head *l, *n;\r\nmutex_lock(&ucb1x00_mutex);\r\nlist_del(&ucb->node);\r\nlist_for_each_safe(l, n, &ucb->devs) {\r\nstruct ucb1x00_dev *dev = list_entry(l, struct ucb1x00_dev, dev_node);\r\nucb1x00_remove_dev(dev);\r\n}\r\nmutex_unlock(&ucb1x00_mutex);\r\nif (ucb->gpio.base != -1)\r\ngpiochip_remove(&ucb->gpio);\r\nirq_set_chained_handler(ucb->irq, NULL);\r\nirq_free_descs(ucb->irq_base, 16);\r\ndevice_unregister(&ucb->dev);\r\nif (pdata && pdata->reset)\r\npdata->reset(UCB_RST_REMOVE);\r\n}\r\nint ucb1x00_register_driver(struct ucb1x00_driver *drv)\r\n{\r\nstruct ucb1x00 *ucb;\r\nINIT_LIST_HEAD(&drv->devs);\r\nmutex_lock(&ucb1x00_mutex);\r\nlist_add_tail(&drv->node, &ucb1x00_drivers);\r\nlist_for_each_entry(ucb, &ucb1x00_devices, node) {\r\nucb1x00_add_dev(ucb, drv);\r\n}\r\nmutex_unlock(&ucb1x00_mutex);\r\nreturn 0;\r\n}\r\nvoid ucb1x00_unregister_driver(struct ucb1x00_driver *drv)\r\n{\r\nstruct list_head *n, *l;\r\nmutex_lock(&ucb1x00_mutex);\r\nlist_del(&drv->node);\r\nlist_for_each_safe(l, n, &drv->devs) {\r\nstruct ucb1x00_dev *dev = list_entry(l, struct ucb1x00_dev, drv_node);\r\nucb1x00_remove_dev(dev);\r\n}\r\nmutex_unlock(&ucb1x00_mutex);\r\n}\r\nstatic int ucb1x00_suspend(struct device *dev)\r\n{\r\nstruct ucb1x00_plat_data *pdata = dev_get_platdata(dev);\r\nstruct ucb1x00 *ucb = dev_get_drvdata(dev);\r\nstruct ucb1x00_dev *udev;\r\nmutex_lock(&ucb1x00_mutex);\r\nlist_for_each_entry(udev, &ucb->devs, dev_node) {\r\nif (udev->drv->suspend)\r\nudev->drv->suspend(udev);\r\n}\r\nmutex_unlock(&ucb1x00_mutex);\r\nif (ucb->irq_wake) {\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&ucb->irq_lock, flags);\r\nucb1x00_enable(ucb);\r\nucb1x00_reg_write(ucb, UCB_IE_RIS, ucb->irq_ris_enbl &\r\nucb->irq_wake);\r\nucb1x00_reg_write(ucb, UCB_IE_FAL, ucb->irq_fal_enbl &\r\nucb->irq_wake);\r\nucb1x00_disable(ucb);\r\nraw_spin_unlock_irqrestore(&ucb->irq_lock, flags);\r\nenable_irq_wake(ucb->irq);\r\n} else if (pdata && pdata->reset)\r\npdata->reset(UCB_RST_SUSPEND);\r\nreturn 0;\r\n}\r\nstatic int ucb1x00_resume(struct device *dev)\r\n{\r\nstruct ucb1x00_plat_data *pdata = dev_get_platdata(dev);\r\nstruct ucb1x00 *ucb = dev_get_drvdata(dev);\r\nstruct ucb1x00_dev *udev;\r\nif (!ucb->irq_wake && pdata && pdata->reset)\r\npdata->reset(UCB_RST_RESUME);\r\nucb1x00_enable(ucb);\r\nucb1x00_reg_write(ucb, UCB_IO_DATA, ucb->io_out);\r\nucb1x00_reg_write(ucb, UCB_IO_DIR, ucb->io_dir);\r\nif (ucb->irq_wake) {\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&ucb->irq_lock, flags);\r\nucb1x00_reg_write(ucb, UCB_IE_RIS, ucb->irq_ris_enbl &\r\nucb->irq_mask);\r\nucb1x00_reg_write(ucb, UCB_IE_FAL, ucb->irq_fal_enbl &\r\nucb->irq_mask);\r\nraw_spin_unlock_irqrestore(&ucb->irq_lock, flags);\r\ndisable_irq_wake(ucb->irq);\r\n}\r\nucb1x00_disable(ucb);\r\nmutex_lock(&ucb1x00_mutex);\r\nlist_for_each_entry(udev, &ucb->devs, dev_node) {\r\nif (udev->drv->resume)\r\nudev->drv->resume(udev);\r\n}\r\nmutex_unlock(&ucb1x00_mutex);\r\nreturn 0;\r\n}\r\nstatic int __init ucb1x00_init(void)\r\n{\r\nint ret = class_register(&ucb1x00_class);\r\nif (ret == 0) {\r\nret = mcp_driver_register(&ucb1x00_driver);\r\nif (ret)\r\nclass_unregister(&ucb1x00_class);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit ucb1x00_exit(void)\r\n{\r\nmcp_driver_unregister(&ucb1x00_driver);\r\nclass_unregister(&ucb1x00_class);\r\n}
