static enum htc_phymode ath9k_htc_get_curmode(struct ath9k_htc_priv *priv,\r\nstruct ath9k_channel *ichan)\r\n{\r\nif (IS_CHAN_5GHZ(ichan))\r\nreturn HTC_MODE_11NA;\r\nreturn HTC_MODE_11NG;\r\n}\r\nbool ath9k_htc_setpower(struct ath9k_htc_priv *priv,\r\nenum ath9k_power_mode mode)\r\n{\r\nbool ret;\r\nmutex_lock(&priv->htc_pm_lock);\r\nret = ath9k_hw_setpower(priv->ah, mode);\r\nmutex_unlock(&priv->htc_pm_lock);\r\nreturn ret;\r\n}\r\nvoid ath9k_htc_ps_wakeup(struct ath9k_htc_priv *priv)\r\n{\r\nmutex_lock(&priv->htc_pm_lock);\r\nif (++priv->ps_usecount != 1)\r\ngoto unlock;\r\nath9k_hw_setpower(priv->ah, ATH9K_PM_AWAKE);\r\nunlock:\r\nmutex_unlock(&priv->htc_pm_lock);\r\n}\r\nvoid ath9k_htc_ps_restore(struct ath9k_htc_priv *priv)\r\n{\r\nbool reset;\r\nmutex_lock(&priv->htc_pm_lock);\r\nif (--priv->ps_usecount != 0)\r\ngoto unlock;\r\nif (priv->ps_idle) {\r\nath9k_hw_setrxabort(priv->ah, true);\r\nath9k_hw_stopdmarecv(priv->ah, &reset);\r\nath9k_hw_setpower(priv->ah, ATH9K_PM_FULL_SLEEP);\r\n} else if (priv->ps_enabled) {\r\nath9k_hw_setpower(priv->ah, ATH9K_PM_NETWORK_SLEEP);\r\n}\r\nunlock:\r\nmutex_unlock(&priv->htc_pm_lock);\r\n}\r\nvoid ath9k_ps_work(struct work_struct *work)\r\n{\r\nstruct ath9k_htc_priv *priv =\r\ncontainer_of(work, struct ath9k_htc_priv,\r\nps_work);\r\nath9k_htc_setpower(priv, ATH9K_PM_AWAKE);\r\nath9k_htc_setpower(priv, ATH9K_PM_NETWORK_SLEEP);\r\n}\r\nstatic void ath9k_htc_vif_iter(void *data, u8 *mac, struct ieee80211_vif *vif)\r\n{\r\nstruct ath9k_htc_priv *priv = data;\r\nstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\r\nif ((vif->type == NL80211_IFTYPE_AP ||\r\nvif->type == NL80211_IFTYPE_MESH_POINT) &&\r\nbss_conf->enable_beacon) {\r\npriv->reconfig_beacon = true;\r\npriv->rearm_ani = true;\r\n}\r\nif (bss_conf->assoc) {\r\npriv->rearm_ani = true;\r\npriv->reconfig_beacon = true;\r\n}\r\n}\r\nstatic void ath9k_htc_vif_reconfig(struct ath9k_htc_priv *priv)\r\n{\r\npriv->rearm_ani = false;\r\npriv->reconfig_beacon = false;\r\nieee80211_iterate_active_interfaces_atomic(\r\npriv->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\r\nath9k_htc_vif_iter, priv);\r\nif (priv->rearm_ani)\r\nath9k_htc_start_ani(priv);\r\nif (priv->reconfig_beacon) {\r\nath9k_htc_ps_wakeup(priv);\r\nath9k_htc_beacon_reconfig(priv);\r\nath9k_htc_ps_restore(priv);\r\n}\r\n}\r\nstatic void ath9k_htc_bssid_iter(void *data, u8 *mac, struct ieee80211_vif *vif)\r\n{\r\nstruct ath9k_vif_iter_data *iter_data = data;\r\nint i;\r\nif (iter_data->hw_macaddr != NULL) {\r\nfor (i = 0; i < ETH_ALEN; i++)\r\niter_data->mask[i] &= ~(iter_data->hw_macaddr[i] ^ mac[i]);\r\n} else {\r\niter_data->hw_macaddr = mac;\r\n}\r\n}\r\nstatic void ath9k_htc_set_mac_bssid_mask(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_vif_iter_data iter_data;\r\niter_data.hw_macaddr = NULL;\r\nmemset(&iter_data.mask, 0xff, ETH_ALEN);\r\nif (vif)\r\nath9k_htc_bssid_iter(&iter_data, vif->addr, vif);\r\nieee80211_iterate_active_interfaces_atomic(\r\npriv->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\r\nath9k_htc_bssid_iter, &iter_data);\r\nmemcpy(common->bssidmask, iter_data.mask, ETH_ALEN);\r\nif (iter_data.hw_macaddr)\r\nmemcpy(common->macaddr, iter_data.hw_macaddr, ETH_ALEN);\r\nath_hw_setbssidmask(common);\r\n}\r\nstatic void ath9k_htc_set_opmode(struct ath9k_htc_priv *priv)\r\n{\r\nif (priv->num_ibss_vif)\r\npriv->ah->opmode = NL80211_IFTYPE_ADHOC;\r\nelse if (priv->num_ap_vif)\r\npriv->ah->opmode = NL80211_IFTYPE_AP;\r\nelse if (priv->num_mbss_vif)\r\npriv->ah->opmode = NL80211_IFTYPE_MESH_POINT;\r\nelse\r\npriv->ah->opmode = NL80211_IFTYPE_STATION;\r\nath9k_hw_setopmode(priv->ah);\r\n}\r\nvoid ath9k_htc_reset(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_hw *ah = priv->ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ieee80211_channel *channel = priv->hw->conf.chandef.chan;\r\nstruct ath9k_hw_cal_data *caldata = NULL;\r\nenum htc_phymode mode;\r\n__be16 htc_mode;\r\nu8 cmd_rsp;\r\nint ret;\r\nmutex_lock(&priv->mutex);\r\nath9k_htc_ps_wakeup(priv);\r\nath9k_htc_stop_ani(priv);\r\nieee80211_stop_queues(priv->hw);\r\ndel_timer_sync(&priv->tx.cleanup_timer);\r\nath9k_htc_tx_drain(priv);\r\nWMI_CMD(WMI_DISABLE_INTR_CMDID);\r\nWMI_CMD(WMI_DRAIN_TXQ_ALL_CMDID);\r\nWMI_CMD(WMI_STOP_RECV_CMDID);\r\nath9k_wmi_event_drain(priv);\r\ncaldata = &priv->caldata;\r\nret = ath9k_hw_reset(ah, ah->curchan, caldata, false);\r\nif (ret) {\r\nath_err(common,\r\n"Unable to reset device (%u Mhz) reset status %d\n",\r\nchannel->center_freq, ret);\r\n}\r\nath9k_cmn_update_txpow(ah, priv->curtxpow, priv->txpowlimit,\r\n&priv->curtxpow);\r\nWMI_CMD(WMI_START_RECV_CMDID);\r\nath9k_host_rx_init(priv);\r\nmode = ath9k_htc_get_curmode(priv, ah->curchan);\r\nhtc_mode = cpu_to_be16(mode);\r\nWMI_CMD_BUF(WMI_SET_MODE_CMDID, &htc_mode);\r\nWMI_CMD(WMI_ENABLE_INTR_CMDID);\r\nhtc_start(priv->htc);\r\nath9k_htc_vif_reconfig(priv);\r\nieee80211_wake_queues(priv->hw);\r\nmod_timer(&priv->tx.cleanup_timer,\r\njiffies + msecs_to_jiffies(ATH9K_HTC_TX_CLEANUP_INTERVAL));\r\nath9k_htc_ps_restore(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int ath9k_htc_set_channel(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_hw *hw,\r\nstruct ath9k_channel *hchan)\r\n{\r\nstruct ath_hw *ah = priv->ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ieee80211_conf *conf = &common->hw->conf;\r\nbool fastcc;\r\nstruct ieee80211_channel *channel = hw->conf.chandef.chan;\r\nstruct ath9k_hw_cal_data *caldata = NULL;\r\nenum htc_phymode mode;\r\n__be16 htc_mode;\r\nu8 cmd_rsp;\r\nint ret;\r\nif (test_bit(ATH_OP_INVALID, &common->op_flags))\r\nreturn -EIO;\r\nfastcc = !!(hw->conf.flags & IEEE80211_CONF_OFFCHANNEL);\r\nath9k_htc_ps_wakeup(priv);\r\nath9k_htc_stop_ani(priv);\r\ndel_timer_sync(&priv->tx.cleanup_timer);\r\nath9k_htc_tx_drain(priv);\r\nWMI_CMD(WMI_DISABLE_INTR_CMDID);\r\nWMI_CMD(WMI_DRAIN_TXQ_ALL_CMDID);\r\nWMI_CMD(WMI_STOP_RECV_CMDID);\r\nath9k_wmi_event_drain(priv);\r\nath_dbg(common, CONFIG,\r\n"(%u MHz) -> (%u MHz), HT: %d, HT40: %d fastcc: %d\n",\r\npriv->ah->curchan->channel,\r\nchannel->center_freq, conf_is_ht(conf), conf_is_ht40(conf),\r\nfastcc);\r\nif (!fastcc)\r\ncaldata = &priv->caldata;\r\nret = ath9k_hw_reset(ah, hchan, caldata, fastcc);\r\nif (ret) {\r\nath_err(common,\r\n"Unable to reset channel (%u Mhz) reset status %d\n",\r\nchannel->center_freq, ret);\r\ngoto err;\r\n}\r\nath9k_cmn_update_txpow(ah, priv->curtxpow, priv->txpowlimit,\r\n&priv->curtxpow);\r\nWMI_CMD(WMI_START_RECV_CMDID);\r\nif (ret)\r\ngoto err;\r\nath9k_host_rx_init(priv);\r\nmode = ath9k_htc_get_curmode(priv, hchan);\r\nhtc_mode = cpu_to_be16(mode);\r\nWMI_CMD_BUF(WMI_SET_MODE_CMDID, &htc_mode);\r\nif (ret)\r\ngoto err;\r\nWMI_CMD(WMI_ENABLE_INTR_CMDID);\r\nif (ret)\r\ngoto err;\r\nhtc_start(priv->htc);\r\nif (!test_bit(ATH_OP_SCANNING, &common->op_flags) &&\r\n!(hw->conf.flags & IEEE80211_CONF_OFFCHANNEL))\r\nath9k_htc_vif_reconfig(priv);\r\nmod_timer(&priv->tx.cleanup_timer,\r\njiffies + msecs_to_jiffies(ATH9K_HTC_TX_CLEANUP_INTERVAL));\r\nif (test_bit(ATH_OP_SCANNING, &common->op_flags) &&\r\npriv->spec_priv.spectral_mode == SPECTRAL_CHANSCAN)\r\nath9k_cmn_spectral_scan_trigger(common, &priv->spec_priv);\r\nerr:\r\nath9k_htc_ps_restore(priv);\r\nreturn ret;\r\n}\r\nstatic void __ath9k_htc_remove_monitor_interface(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_target_vif hvif;\r\nint ret = 0;\r\nu8 cmd_rsp;\r\nmemset(&hvif, 0, sizeof(struct ath9k_htc_target_vif));\r\nmemcpy(&hvif.myaddr, common->macaddr, ETH_ALEN);\r\nhvif.index = priv->mon_vif_idx;\r\nWMI_CMD_BUF(WMI_VAP_REMOVE_CMDID, &hvif);\r\nif (ret) {\r\nath_err(common, "Unable to remove monitor interface at idx: %d\n",\r\npriv->mon_vif_idx);\r\n}\r\npriv->nvifs--;\r\npriv->vif_slot &= ~(1 << priv->mon_vif_idx);\r\n}\r\nstatic int ath9k_htc_add_monitor_interface(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_target_vif hvif;\r\nstruct ath9k_htc_target_sta tsta;\r\nint ret = 0, sta_idx;\r\nu8 cmd_rsp;\r\nif ((priv->nvifs >= ATH9K_HTC_MAX_VIF) ||\r\n(priv->nstations >= ATH9K_HTC_MAX_STA)) {\r\nret = -ENOBUFS;\r\ngoto err_vif;\r\n}\r\nsta_idx = ffz(priv->sta_slot);\r\nif ((sta_idx < 0) || (sta_idx > ATH9K_HTC_MAX_STA)) {\r\nret = -ENOBUFS;\r\ngoto err_vif;\r\n}\r\nmemset(&hvif, 0, sizeof(struct ath9k_htc_target_vif));\r\nmemcpy(&hvif.myaddr, common->macaddr, ETH_ALEN);\r\nhvif.opmode = HTC_M_MONITOR;\r\nhvif.index = ffz(priv->vif_slot);\r\nWMI_CMD_BUF(WMI_VAP_CREATE_CMDID, &hvif);\r\nif (ret)\r\ngoto err_vif;\r\npriv->mon_vif_idx = hvif.index;\r\npriv->vif_slot |= (1 << hvif.index);\r\nif (!priv->nvifs)\r\npriv->ah->opmode = NL80211_IFTYPE_MONITOR;\r\npriv->nvifs++;\r\nmemset(&tsta, 0, sizeof(struct ath9k_htc_target_sta));\r\nmemcpy(&tsta.macaddr, common->macaddr, ETH_ALEN);\r\ntsta.is_vif_sta = 1;\r\ntsta.sta_index = sta_idx;\r\ntsta.vif_index = hvif.index;\r\ntsta.maxampdu = cpu_to_be16(0xffff);\r\nWMI_CMD_BUF(WMI_NODE_CREATE_CMDID, &tsta);\r\nif (ret) {\r\nath_err(common, "Unable to add station entry for monitor mode\n");\r\ngoto err_sta;\r\n}\r\npriv->sta_slot |= (1 << sta_idx);\r\npriv->nstations++;\r\npriv->vif_sta_pos[priv->mon_vif_idx] = sta_idx;\r\npriv->ah->is_monitoring = true;\r\nath_dbg(common, CONFIG,\r\n"Attached a monitor interface at idx: %d, sta idx: %d\n",\r\npriv->mon_vif_idx, sta_idx);\r\nreturn 0;\r\nerr_sta:\r\n__ath9k_htc_remove_monitor_interface(priv);\r\nerr_vif:\r\nath_dbg(common, FATAL, "Unable to attach a monitor interface\n");\r\nreturn ret;\r\n}\r\nstatic int ath9k_htc_remove_monitor_interface(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nint ret = 0;\r\nu8 cmd_rsp, sta_idx;\r\n__ath9k_htc_remove_monitor_interface(priv);\r\nsta_idx = priv->vif_sta_pos[priv->mon_vif_idx];\r\nWMI_CMD_BUF(WMI_NODE_REMOVE_CMDID, &sta_idx);\r\nif (ret) {\r\nath_err(common, "Unable to remove station entry for monitor mode\n");\r\nreturn ret;\r\n}\r\npriv->sta_slot &= ~(1 << sta_idx);\r\npriv->nstations--;\r\npriv->ah->is_monitoring = false;\r\nath_dbg(common, CONFIG,\r\n"Removed a monitor interface at idx: %d, sta idx: %d\n",\r\npriv->mon_vif_idx, sta_idx);\r\nreturn 0;\r\n}\r\nstatic int ath9k_htc_add_station(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_target_sta tsta;\r\nstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *) vif->drv_priv;\r\nstruct ath9k_htc_sta *ista;\r\nint ret, sta_idx;\r\nu8 cmd_rsp;\r\nu16 maxampdu;\r\nif (priv->nstations >= ATH9K_HTC_MAX_STA)\r\nreturn -ENOBUFS;\r\nsta_idx = ffz(priv->sta_slot);\r\nif ((sta_idx < 0) || (sta_idx > ATH9K_HTC_MAX_STA))\r\nreturn -ENOBUFS;\r\nmemset(&tsta, 0, sizeof(struct ath9k_htc_target_sta));\r\nif (sta) {\r\nista = (struct ath9k_htc_sta *) sta->drv_priv;\r\nmemcpy(&tsta.macaddr, sta->addr, ETH_ALEN);\r\nmemcpy(&tsta.bssid, common->curbssid, ETH_ALEN);\r\nista->index = sta_idx;\r\ntsta.is_vif_sta = 0;\r\nmaxampdu = 1 << (IEEE80211_HT_MAX_AMPDU_FACTOR +\r\nsta->ht_cap.ampdu_factor);\r\ntsta.maxampdu = cpu_to_be16(maxampdu);\r\n} else {\r\nmemcpy(&tsta.macaddr, vif->addr, ETH_ALEN);\r\ntsta.is_vif_sta = 1;\r\ntsta.maxampdu = cpu_to_be16(0xffff);\r\n}\r\ntsta.sta_index = sta_idx;\r\ntsta.vif_index = avp->index;\r\nWMI_CMD_BUF(WMI_NODE_CREATE_CMDID, &tsta);\r\nif (ret) {\r\nif (sta)\r\nath_err(common,\r\n"Unable to add station entry for: %pM\n",\r\nsta->addr);\r\nreturn ret;\r\n}\r\nif (sta) {\r\nath_dbg(common, CONFIG,\r\n"Added a station entry for: %pM (idx: %d)\n",\r\nsta->addr, tsta.sta_index);\r\n} else {\r\nath_dbg(common, CONFIG,\r\n"Added a station entry for VIF %d (idx: %d)\n",\r\navp->index, tsta.sta_index);\r\n}\r\npriv->sta_slot |= (1 << sta_idx);\r\npriv->nstations++;\r\nif (!sta)\r\npriv->vif_sta_pos[avp->index] = sta_idx;\r\nreturn 0;\r\n}\r\nstatic int ath9k_htc_remove_station(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *) vif->drv_priv;\r\nstruct ath9k_htc_sta *ista;\r\nint ret;\r\nu8 cmd_rsp, sta_idx;\r\nif (sta) {\r\nista = (struct ath9k_htc_sta *) sta->drv_priv;\r\nsta_idx = ista->index;\r\n} else {\r\nsta_idx = priv->vif_sta_pos[avp->index];\r\n}\r\nWMI_CMD_BUF(WMI_NODE_REMOVE_CMDID, &sta_idx);\r\nif (ret) {\r\nif (sta)\r\nath_err(common,\r\n"Unable to remove station entry for: %pM\n",\r\nsta->addr);\r\nreturn ret;\r\n}\r\nif (sta) {\r\nath_dbg(common, CONFIG,\r\n"Removed a station entry for: %pM (idx: %d)\n",\r\nsta->addr, sta_idx);\r\n} else {\r\nath_dbg(common, CONFIG,\r\n"Removed a station entry for VIF %d (idx: %d)\n",\r\navp->index, sta_idx);\r\n}\r\npriv->sta_slot &= ~(1 << sta_idx);\r\npriv->nstations--;\r\nreturn 0;\r\n}\r\nint ath9k_htc_update_cap_target(struct ath9k_htc_priv *priv,\r\nu8 enable_coex)\r\n{\r\nstruct ath9k_htc_cap_target tcap;\r\nint ret;\r\nu8 cmd_rsp;\r\nmemset(&tcap, 0, sizeof(struct ath9k_htc_cap_target));\r\ntcap.ampdu_limit = cpu_to_be32(0xffff);\r\ntcap.ampdu_subframes = 0xff;\r\ntcap.enable_coex = enable_coex;\r\ntcap.tx_chainmask = priv->ah->caps.tx_chainmask;\r\nWMI_CMD_BUF(WMI_TARGET_IC_UPDATE_CMDID, &tcap);\r\nreturn ret;\r\n}\r\nstatic void ath9k_htc_setup_rate(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_sta *sta,\r\nstruct ath9k_htc_target_rate *trate)\r\n{\r\nstruct ath9k_htc_sta *ista = (struct ath9k_htc_sta *) sta->drv_priv;\r\nstruct ieee80211_supported_band *sband;\r\nu32 caps = 0;\r\nint i, j;\r\nsband = priv->hw->wiphy->bands[priv->hw->conf.chandef.chan->band];\r\nfor (i = 0, j = 0; i < sband->n_bitrates; i++) {\r\nif (sta->supp_rates[sband->band] & BIT(i)) {\r\ntrate->rates.legacy_rates.rs_rates[j]\r\n= (sband->bitrates[i].bitrate * 2) / 10;\r\nj++;\r\n}\r\n}\r\ntrate->rates.legacy_rates.rs_nrates = j;\r\nif (sta->ht_cap.ht_supported) {\r\nfor (i = 0, j = 0; i < 77; i++) {\r\nif (sta->ht_cap.mcs.rx_mask[i/8] & (1<<(i%8)))\r\ntrate->rates.ht_rates.rs_rates[j++] = i;\r\nif (j == ATH_HTC_RATE_MAX)\r\nbreak;\r\n}\r\ntrate->rates.ht_rates.rs_nrates = j;\r\ncaps = WLAN_RC_HT_FLAG;\r\nif (sta->ht_cap.cap & IEEE80211_HT_CAP_RX_STBC)\r\ncaps |= ATH_RC_TX_STBC_FLAG;\r\nif (sta->ht_cap.mcs.rx_mask[1])\r\ncaps |= WLAN_RC_DS_FLAG;\r\nif ((sta->ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40) &&\r\n(conf_is_ht40(&priv->hw->conf)))\r\ncaps |= WLAN_RC_40_FLAG;\r\nif (conf_is_ht40(&priv->hw->conf) &&\r\n(sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40))\r\ncaps |= WLAN_RC_SGI_FLAG;\r\nelse if (conf_is_ht20(&priv->hw->conf) &&\r\n(sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20))\r\ncaps |= WLAN_RC_SGI_FLAG;\r\n}\r\ntrate->sta_index = ista->index;\r\ntrate->isnew = 1;\r\ntrate->capflags = cpu_to_be32(caps);\r\n}\r\nstatic int ath9k_htc_send_rate_cmd(struct ath9k_htc_priv *priv,\r\nstruct ath9k_htc_target_rate *trate)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nint ret;\r\nu8 cmd_rsp;\r\nWMI_CMD_BUF(WMI_RC_RATE_UPDATE_CMDID, trate);\r\nif (ret) {\r\nath_err(common,\r\n"Unable to initialize Rate information on target\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic void ath9k_htc_init_rate(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_target_rate trate;\r\nint ret;\r\nmemset(&trate, 0, sizeof(struct ath9k_htc_target_rate));\r\nath9k_htc_setup_rate(priv, sta, &trate);\r\nret = ath9k_htc_send_rate_cmd(priv, &trate);\r\nif (!ret)\r\nath_dbg(common, CONFIG,\r\n"Updated target sta: %pM, rate caps: 0x%X\n",\r\nsta->addr, be32_to_cpu(trate.capflags));\r\n}\r\nstatic void ath9k_htc_update_rate(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *bss_conf)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_target_rate trate;\r\nstruct ieee80211_sta *sta;\r\nint ret;\r\nmemset(&trate, 0, sizeof(struct ath9k_htc_target_rate));\r\nrcu_read_lock();\r\nsta = ieee80211_find_sta(vif, bss_conf->bssid);\r\nif (!sta) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nath9k_htc_setup_rate(priv, sta, &trate);\r\nrcu_read_unlock();\r\nret = ath9k_htc_send_rate_cmd(priv, &trate);\r\nif (!ret)\r\nath_dbg(common, CONFIG,\r\n"Updated target sta: %pM, rate caps: 0x%X\n",\r\nbss_conf->bssid, be32_to_cpu(trate.capflags));\r\n}\r\nstatic int ath9k_htc_tx_aggr_oper(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta,\r\nenum ieee80211_ampdu_mlme_action action,\r\nu16 tid)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_target_aggr aggr;\r\nstruct ath9k_htc_sta *ista;\r\nint ret = 0;\r\nu8 cmd_rsp;\r\nif (tid >= ATH9K_HTC_MAX_TID)\r\nreturn -EINVAL;\r\nmemset(&aggr, 0, sizeof(struct ath9k_htc_target_aggr));\r\nista = (struct ath9k_htc_sta *) sta->drv_priv;\r\naggr.sta_index = ista->index;\r\naggr.tidno = tid & 0xf;\r\naggr.aggr_enable = (action == IEEE80211_AMPDU_TX_START) ? true : false;\r\nWMI_CMD_BUF(WMI_TX_AGGR_ENABLE_CMDID, &aggr);\r\nif (ret)\r\nath_dbg(common, CONFIG,\r\n"Unable to %s TX aggregation for (%pM, %d)\n",\r\n(aggr.aggr_enable) ? "start" : "stop", sta->addr, tid);\r\nelse\r\nath_dbg(common, CONFIG,\r\n"%s TX aggregation for (%pM, %d)\n",\r\n(aggr.aggr_enable) ? "Starting" : "Stopping",\r\nsta->addr, tid);\r\nspin_lock_bh(&priv->tx.tx_lock);\r\nista->tid_state[tid] = (aggr.aggr_enable && !ret) ? AGGR_START : AGGR_STOP;\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\nreturn ret;\r\n}\r\nvoid ath9k_htc_start_ani(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nunsigned long timestamp = jiffies_to_msecs(jiffies);\r\ncommon->ani.longcal_timer = timestamp;\r\ncommon->ani.shortcal_timer = timestamp;\r\ncommon->ani.checkani_timer = timestamp;\r\nset_bit(ATH_OP_ANI_RUN, &common->op_flags);\r\nieee80211_queue_delayed_work(common->hw, &priv->ani_work,\r\nmsecs_to_jiffies(ATH_ANI_POLLINTERVAL));\r\n}\r\nvoid ath9k_htc_stop_ani(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\ncancel_delayed_work_sync(&priv->ani_work);\r\nclear_bit(ATH_OP_ANI_RUN, &common->op_flags);\r\n}\r\nvoid ath9k_htc_ani_work(struct work_struct *work)\r\n{\r\nstruct ath9k_htc_priv *priv =\r\ncontainer_of(work, struct ath9k_htc_priv, ani_work.work);\r\nstruct ath_hw *ah = priv->ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nbool longcal = false;\r\nbool shortcal = false;\r\nbool aniflag = false;\r\nunsigned int timestamp = jiffies_to_msecs(jiffies);\r\nu32 cal_interval, short_cal_interval;\r\nshort_cal_interval = (ah->opmode == NL80211_IFTYPE_AP) ?\r\nATH_AP_SHORT_CALINTERVAL : ATH_STA_SHORT_CALINTERVAL;\r\nif (ah->power_mode != ATH9K_PM_AWAKE)\r\ngoto set_timer;\r\nif ((timestamp - common->ani.longcal_timer) >= ATH_LONG_CALINTERVAL) {\r\nlongcal = true;\r\nath_dbg(common, ANI, "longcal @%lu\n", jiffies);\r\ncommon->ani.longcal_timer = timestamp;\r\n}\r\nif (!common->ani.caldone) {\r\nif ((timestamp - common->ani.shortcal_timer) >=\r\nshort_cal_interval) {\r\nshortcal = true;\r\nath_dbg(common, ANI, "shortcal @%lu\n", jiffies);\r\ncommon->ani.shortcal_timer = timestamp;\r\ncommon->ani.resetcal_timer = timestamp;\r\n}\r\n} else {\r\nif ((timestamp - common->ani.resetcal_timer) >=\r\nATH_RESTART_CALINTERVAL) {\r\ncommon->ani.caldone = ath9k_hw_reset_calvalid(ah);\r\nif (common->ani.caldone)\r\ncommon->ani.resetcal_timer = timestamp;\r\n}\r\n}\r\nif ((timestamp - common->ani.checkani_timer) >= ATH_ANI_POLLINTERVAL) {\r\naniflag = true;\r\ncommon->ani.checkani_timer = timestamp;\r\n}\r\nif (longcal || shortcal || aniflag) {\r\nath9k_htc_ps_wakeup(priv);\r\nif (aniflag)\r\nath9k_hw_ani_monitor(ah, ah->curchan);\r\nif (longcal || shortcal)\r\ncommon->ani.caldone =\r\nath9k_hw_calibrate(ah, ah->curchan,\r\nah->rxchainmask, longcal);\r\nath9k_htc_ps_restore(priv);\r\n}\r\nset_timer:\r\ncal_interval = ATH_LONG_CALINTERVAL;\r\ncal_interval = min(cal_interval, (u32)ATH_ANI_POLLINTERVAL);\r\nif (!common->ani.caldone)\r\ncal_interval = min(cal_interval, (u32)short_cal_interval);\r\nieee80211_queue_delayed_work(common->hw, &priv->ani_work,\r\nmsecs_to_jiffies(cal_interval));\r\n}\r\nstatic void ath9k_htc_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_tx_control *control,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_hdr *hdr;\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nint padpos, padsize, ret, slot;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\npadpos = ieee80211_hdrlen(hdr->frame_control);\r\npadsize = padpos & 3;\r\nif (padsize && skb->len > padpos) {\r\nif (skb_headroom(skb) < padsize) {\r\nath_dbg(common, XMIT, "No room for padding\n");\r\ngoto fail_tx;\r\n}\r\nskb_push(skb, padsize);\r\nmemmove(skb->data, skb->data + padsize, padpos);\r\n}\r\nslot = ath9k_htc_tx_get_slot(priv);\r\nif (slot < 0) {\r\nath_dbg(common, XMIT, "No free TX slot\n");\r\ngoto fail_tx;\r\n}\r\nret = ath9k_htc_tx_start(priv, control->sta, skb, slot, false);\r\nif (ret != 0) {\r\nath_dbg(common, XMIT, "Tx failed\n");\r\ngoto clear_slot;\r\n}\r\nath9k_htc_check_stop_queues(priv);\r\nreturn;\r\nclear_slot:\r\nath9k_htc_tx_clear_slot(priv, slot);\r\nfail_tx:\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic int ath9k_htc_start(struct ieee80211_hw *hw)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath_hw *ah = priv->ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ieee80211_channel *curchan = hw->conf.chandef.chan;\r\nstruct ath9k_channel *init_channel;\r\nint ret = 0;\r\nenum htc_phymode mode;\r\n__be16 htc_mode;\r\nu8 cmd_rsp;\r\nmutex_lock(&priv->mutex);\r\nath_dbg(common, CONFIG,\r\n"Starting driver with initial channel: %d MHz\n",\r\ncurchan->center_freq);\r\nath9k_htc_setpower(priv, ATH9K_PM_AWAKE);\r\nWMI_CMD(WMI_FLUSH_RECV_CMDID);\r\ninit_channel = ath9k_cmn_get_channel(hw, ah, &hw->conf.chandef);\r\nret = ath9k_hw_reset(ah, init_channel, ah->caldata, false);\r\nif (ret) {\r\nath_err(common,\r\n"Unable to reset hardware; reset status %d (freq %u MHz)\n",\r\nret, curchan->center_freq);\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nath9k_cmn_update_txpow(ah, priv->curtxpow, priv->txpowlimit,\r\n&priv->curtxpow);\r\nmode = ath9k_htc_get_curmode(priv, init_channel);\r\nhtc_mode = cpu_to_be16(mode);\r\nWMI_CMD_BUF(WMI_SET_MODE_CMDID, &htc_mode);\r\nWMI_CMD(WMI_ATH_INIT_CMDID);\r\nWMI_CMD(WMI_START_RECV_CMDID);\r\nath9k_host_rx_init(priv);\r\nret = ath9k_htc_update_cap_target(priv, 0);\r\nif (ret)\r\nath_dbg(common, CONFIG,\r\n"Failed to update capability in target\n");\r\nclear_bit(ATH_OP_INVALID, &common->op_flags);\r\nhtc_start(priv->htc);\r\nspin_lock_bh(&priv->tx.tx_lock);\r\npriv->tx.flags &= ~ATH9K_HTC_OP_TX_QUEUES_STOP;\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\nieee80211_wake_queues(hw);\r\nmod_timer(&priv->tx.cleanup_timer,\r\njiffies + msecs_to_jiffies(ATH9K_HTC_TX_CLEANUP_INTERVAL));\r\nath9k_htc_start_btcoex(priv);\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nstatic void ath9k_htc_stop(struct ieee80211_hw *hw)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath_hw *ah = priv->ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nint ret __attribute__ ((unused));\r\nu8 cmd_rsp;\r\nmutex_lock(&priv->mutex);\r\nif (test_bit(ATH_OP_INVALID, &common->op_flags)) {\r\nath_dbg(common, ANY, "Device not present\n");\r\nmutex_unlock(&priv->mutex);\r\nreturn;\r\n}\r\nath9k_htc_ps_wakeup(priv);\r\nWMI_CMD(WMI_DISABLE_INTR_CMDID);\r\nWMI_CMD(WMI_DRAIN_TXQ_ALL_CMDID);\r\nWMI_CMD(WMI_STOP_RECV_CMDID);\r\ntasklet_kill(&priv->rx_tasklet);\r\ndel_timer_sync(&priv->tx.cleanup_timer);\r\nath9k_htc_tx_drain(priv);\r\nath9k_wmi_event_drain(priv);\r\nmutex_unlock(&priv->mutex);\r\ncancel_work_sync(&priv->fatal_work);\r\ncancel_work_sync(&priv->ps_work);\r\n#ifdef CONFIG_MAC80211_LEDS\r\ncancel_work_sync(&priv->led_work);\r\n#endif\r\nath9k_htc_stop_ani(priv);\r\nmutex_lock(&priv->mutex);\r\nath9k_htc_stop_btcoex(priv);\r\nif (priv->ah->is_monitoring)\r\nath9k_htc_remove_monitor_interface(priv);\r\nath9k_hw_phy_disable(ah);\r\nath9k_hw_disable(ah);\r\nath9k_htc_ps_restore(priv);\r\nath9k_htc_setpower(priv, ATH9K_PM_FULL_SLEEP);\r\nset_bit(ATH_OP_INVALID, &common->op_flags);\r\nath_dbg(common, CONFIG, "Driver halt\n");\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int ath9k_htc_add_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath9k_htc_vif *avp = (void *)vif->drv_priv;\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_target_vif hvif;\r\nint ret = 0;\r\nu8 cmd_rsp;\r\nmutex_lock(&priv->mutex);\r\nath9k_htc_ps_wakeup(priv);\r\nmemset(&hvif, 0, sizeof(struct ath9k_htc_target_vif));\r\nmemcpy(&hvif.myaddr, vif->addr, ETH_ALEN);\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\nhvif.opmode = HTC_M_STA;\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\nhvif.opmode = HTC_M_IBSS;\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\nhvif.opmode = HTC_M_HOSTAP;\r\nbreak;\r\ncase NL80211_IFTYPE_MESH_POINT:\r\nhvif.opmode = HTC_M_WDS;\r\nbreak;\r\ndefault:\r\nath_err(common,\r\n"Interface type %d not yet supported\n", vif->type);\r\nret = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\navp->index = hvif.index = ffz(priv->vif_slot);\r\nhvif.rtsthreshold = cpu_to_be16(2304);\r\nWMI_CMD_BUF(WMI_VAP_CREATE_CMDID, &hvif);\r\nif (ret)\r\ngoto out;\r\nret = ath9k_htc_add_station(priv, vif, NULL);\r\nif (ret) {\r\nWMI_CMD_BUF(WMI_VAP_REMOVE_CMDID, &hvif);\r\ngoto out;\r\n}\r\nath9k_htc_set_mac_bssid_mask(priv, vif);\r\npriv->vif_slot |= (1 << avp->index);\r\npriv->nvifs++;\r\nINC_VIF(priv, vif->type);\r\nif ((vif->type == NL80211_IFTYPE_AP) ||\r\n(vif->type == NL80211_IFTYPE_MESH_POINT) ||\r\n(vif->type == NL80211_IFTYPE_ADHOC))\r\nath9k_htc_assign_bslot(priv, vif);\r\nath9k_htc_set_opmode(priv);\r\nif ((priv->ah->opmode == NL80211_IFTYPE_AP) &&\r\n!test_bit(ATH_OP_ANI_RUN, &common->op_flags)) {\r\nath9k_hw_set_tsfadjust(priv->ah, true);\r\nath9k_htc_start_ani(priv);\r\n}\r\nath_dbg(common, CONFIG, "Attach a VIF of type: %d at idx: %d\n",\r\nvif->type, avp->index);\r\nout:\r\nath9k_htc_ps_restore(priv);\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nstatic void ath9k_htc_remove_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_vif *avp = (void *)vif->drv_priv;\r\nstruct ath9k_htc_target_vif hvif;\r\nint ret = 0;\r\nu8 cmd_rsp;\r\nmutex_lock(&priv->mutex);\r\nath9k_htc_ps_wakeup(priv);\r\nmemset(&hvif, 0, sizeof(struct ath9k_htc_target_vif));\r\nmemcpy(&hvif.myaddr, vif->addr, ETH_ALEN);\r\nhvif.index = avp->index;\r\nWMI_CMD_BUF(WMI_VAP_REMOVE_CMDID, &hvif);\r\nif (ret) {\r\nath_err(common, "Unable to remove interface at idx: %d\n",\r\navp->index);\r\n}\r\npriv->nvifs--;\r\npriv->vif_slot &= ~(1 << avp->index);\r\nath9k_htc_remove_station(priv, vif, NULL);\r\nDEC_VIF(priv, vif->type);\r\nif ((vif->type == NL80211_IFTYPE_AP) ||\r\nvif->type == NL80211_IFTYPE_MESH_POINT ||\r\n(vif->type == NL80211_IFTYPE_ADHOC))\r\nath9k_htc_remove_bslot(priv, vif);\r\nath9k_htc_set_opmode(priv);\r\nath9k_htc_set_mac_bssid_mask(priv, vif);\r\nif ((vif->type == NL80211_IFTYPE_AP) && (priv->num_ap_vif == 0)) {\r\npriv->rearm_ani = false;\r\nieee80211_iterate_active_interfaces_atomic(\r\npriv->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\r\nath9k_htc_vif_iter, priv);\r\nif (!priv->rearm_ani)\r\nath9k_htc_stop_ani(priv);\r\n}\r\nath_dbg(common, CONFIG, "Detach Interface at idx: %d\n", avp->index);\r\nath9k_htc_ps_restore(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int ath9k_htc_config(struct ieee80211_hw *hw, u32 changed)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ieee80211_conf *conf = &hw->conf;\r\nbool chip_reset = false;\r\nint ret = 0;\r\nmutex_lock(&priv->mutex);\r\nath9k_htc_ps_wakeup(priv);\r\nif (changed & IEEE80211_CONF_CHANGE_IDLE) {\r\nmutex_lock(&priv->htc_pm_lock);\r\npriv->ps_idle = !!(conf->flags & IEEE80211_CONF_IDLE);\r\nif (!priv->ps_idle)\r\nchip_reset = true;\r\nmutex_unlock(&priv->htc_pm_lock);\r\n}\r\nif (changed & IEEE80211_CONF_CHANGE_MONITOR) {\r\nif ((conf->flags & IEEE80211_CONF_MONITOR) &&\r\n!priv->ah->is_monitoring)\r\nath9k_htc_add_monitor_interface(priv);\r\nelse if (priv->ah->is_monitoring)\r\nath9k_htc_remove_monitor_interface(priv);\r\n}\r\nif ((changed & IEEE80211_CONF_CHANGE_CHANNEL) || chip_reset) {\r\nstruct ieee80211_channel *curchan = hw->conf.chandef.chan;\r\nint pos = curchan->hw_value;\r\nath_dbg(common, CONFIG, "Set channel: %d MHz\n",\r\ncurchan->center_freq);\r\nath9k_cmn_get_channel(hw, priv->ah, &hw->conf.chandef);\r\nif (ath9k_htc_set_channel(priv, hw, &priv->ah->channels[pos]) < 0) {\r\nath_err(common, "Unable to set channel\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nif (changed & IEEE80211_CONF_CHANGE_PS) {\r\nif (conf->flags & IEEE80211_CONF_PS) {\r\nath9k_htc_setpower(priv, ATH9K_PM_NETWORK_SLEEP);\r\npriv->ps_enabled = true;\r\n} else {\r\npriv->ps_enabled = false;\r\ncancel_work_sync(&priv->ps_work);\r\nath9k_htc_setpower(priv, ATH9K_PM_AWAKE);\r\n}\r\n}\r\nif (changed & IEEE80211_CONF_CHANGE_POWER) {\r\npriv->txpowlimit = 2 * conf->power_level;\r\nath9k_cmn_update_txpow(priv->ah, priv->curtxpow,\r\npriv->txpowlimit, &priv->curtxpow);\r\n}\r\nout:\r\nath9k_htc_ps_restore(priv);\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nstatic void ath9k_htc_configure_filter(struct ieee80211_hw *hw,\r\nunsigned int changed_flags,\r\nunsigned int *total_flags,\r\nu64 multicast)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nu32 rfilt;\r\nmutex_lock(&priv->mutex);\r\nchanged_flags &= SUPPORTED_FILTERS;\r\n*total_flags &= SUPPORTED_FILTERS;\r\nif (test_bit(ATH_OP_INVALID, &common->op_flags)) {\r\nath_dbg(ath9k_hw_common(priv->ah), ANY,\r\n"Unable to configure filter on invalid state\n");\r\nmutex_unlock(&priv->mutex);\r\nreturn;\r\n}\r\nath9k_htc_ps_wakeup(priv);\r\npriv->rxfilter = *total_flags;\r\nrfilt = ath9k_htc_calcrxfilter(priv);\r\nath9k_hw_setrxfilter(priv->ah, rfilt);\r\nath_dbg(ath9k_hw_common(priv->ah), CONFIG, "Set HW RX filter: 0x%x\n",\r\nrfilt);\r\nath9k_htc_ps_restore(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic void ath9k_htc_sta_rc_update_work(struct work_struct *work)\r\n{\r\nstruct ath9k_htc_sta *ista =\r\ncontainer_of(work, struct ath9k_htc_sta, rc_update_work);\r\nstruct ieee80211_sta *sta =\r\ncontainer_of((void *)ista, struct ieee80211_sta, drv_priv);\r\nstruct ath9k_htc_priv *priv = ista->htc_priv;\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_target_rate trate;\r\nmutex_lock(&priv->mutex);\r\nath9k_htc_ps_wakeup(priv);\r\nmemset(&trate, 0, sizeof(struct ath9k_htc_target_rate));\r\nath9k_htc_setup_rate(priv, sta, &trate);\r\nif (!ath9k_htc_send_rate_cmd(priv, &trate))\r\nath_dbg(common, CONFIG,\r\n"Supported rates for sta: %pM updated, rate caps: 0x%X\n",\r\nsta->addr, be32_to_cpu(trate.capflags));\r\nelse\r\nath_dbg(common, CONFIG,\r\n"Unable to update supported rates for sta: %pM\n",\r\nsta->addr);\r\nath9k_htc_ps_restore(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int ath9k_htc_sta_add(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath9k_htc_sta *ista = (struct ath9k_htc_sta *) sta->drv_priv;\r\nint ret;\r\nmutex_lock(&priv->mutex);\r\nath9k_htc_ps_wakeup(priv);\r\nret = ath9k_htc_add_station(priv, vif, sta);\r\nif (!ret) {\r\nINIT_WORK(&ista->rc_update_work, ath9k_htc_sta_rc_update_work);\r\nista->htc_priv = priv;\r\nath9k_htc_init_rate(priv, sta);\r\n}\r\nath9k_htc_ps_restore(priv);\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nstatic int ath9k_htc_sta_remove(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath9k_htc_sta *ista = (struct ath9k_htc_sta *) sta->drv_priv;\r\nint ret;\r\ncancel_work_sync(&ista->rc_update_work);\r\nmutex_lock(&priv->mutex);\r\nath9k_htc_ps_wakeup(priv);\r\nhtc_sta_drain(priv->htc, ista->index);\r\nret = ath9k_htc_remove_station(priv, vif, sta);\r\nath9k_htc_ps_restore(priv);\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nstatic void ath9k_htc_sta_rc_update(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta, u32 changed)\r\n{\r\nstruct ath9k_htc_sta *ista = (struct ath9k_htc_sta *) sta->drv_priv;\r\nif (!(changed & IEEE80211_RC_SUPP_RATES_CHANGED))\r\nreturn;\r\nschedule_work(&ista->rc_update_work);\r\n}\r\nstatic int ath9k_htc_conf_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, u16 queue,\r\nconst struct ieee80211_tx_queue_params *params)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_tx_queue_info qi;\r\nint ret = 0, qnum;\r\nif (queue >= IEEE80211_NUM_ACS)\r\nreturn 0;\r\nmutex_lock(&priv->mutex);\r\nath9k_htc_ps_wakeup(priv);\r\nmemset(&qi, 0, sizeof(struct ath9k_tx_queue_info));\r\nqi.tqi_aifs = params->aifs;\r\nqi.tqi_cwmin = params->cw_min;\r\nqi.tqi_cwmax = params->cw_max;\r\nqi.tqi_burstTime = params->txop * 32;\r\nqnum = get_hw_qnum(queue, priv->hwq_map);\r\nath_dbg(common, CONFIG,\r\n"Configure tx [queue/hwq] [%d/%d], aifs: %d, cw_min: %d, cw_max: %d, txop: %d\n",\r\nqueue, qnum, params->aifs, params->cw_min,\r\nparams->cw_max, params->txop);\r\nret = ath_htc_txq_update(priv, qnum, &qi);\r\nif (ret) {\r\nath_err(common, "TXQ Update failed\n");\r\ngoto out;\r\n}\r\nif ((priv->ah->opmode == NL80211_IFTYPE_ADHOC) &&\r\n(qnum == priv->hwq_map[IEEE80211_AC_BE]))\r\nath9k_htc_beaconq_config(priv);\r\nout:\r\nath9k_htc_ps_restore(priv);\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nstatic int ath9k_htc_set_key(struct ieee80211_hw *hw,\r\nenum set_key_cmd cmd,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nint ret = 0;\r\nif (htc_modparam_nohwcrypt)\r\nreturn -ENOSPC;\r\nif ((vif->type == NL80211_IFTYPE_ADHOC ||\r\nvif->type == NL80211_IFTYPE_MESH_POINT) &&\r\n(key->cipher == WLAN_CIPHER_SUITE_TKIP ||\r\nkey->cipher == WLAN_CIPHER_SUITE_CCMP) &&\r\n!(key->flags & IEEE80211_KEY_FLAG_PAIRWISE)) {\r\nreturn -EOPNOTSUPP;\r\n}\r\nmutex_lock(&priv->mutex);\r\nath_dbg(common, CONFIG, "Set HW Key\n");\r\nath9k_htc_ps_wakeup(priv);\r\nswitch (cmd) {\r\ncase SET_KEY:\r\nret = ath_key_config(common, vif, sta, key);\r\nif (ret >= 0) {\r\nkey->hw_key_idx = ret;\r\nkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\r\nif (key->cipher == WLAN_CIPHER_SUITE_TKIP)\r\nkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\r\nif (priv->ah->sw_mgmt_crypto_tx &&\r\nkey->cipher == WLAN_CIPHER_SUITE_CCMP)\r\nkey->flags |= IEEE80211_KEY_FLAG_SW_MGMT_TX;\r\nret = 0;\r\n}\r\nbreak;\r\ncase DISABLE_KEY:\r\nath_key_delete(common, key);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nath9k_htc_ps_restore(priv);\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nstatic void ath9k_htc_set_bssid(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nath9k_hw_write_associd(priv->ah);\r\nath_dbg(common, CONFIG, "BSSID: %pM aid: 0x%x\n",\r\ncommon->curbssid, common->curaid);\r\n}\r\nstatic void ath9k_htc_bss_iter(void *data, u8 *mac, struct ieee80211_vif *vif)\r\n{\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *)data;\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\r\nif ((vif->type == NL80211_IFTYPE_STATION) && bss_conf->assoc) {\r\ncommon->curaid = bss_conf->aid;\r\ncommon->last_rssi = ATH_RSSI_DUMMY_MARKER;\r\nmemcpy(common->curbssid, bss_conf->bssid, ETH_ALEN);\r\nset_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags);\r\n}\r\n}\r\nstatic void ath9k_htc_choose_set_bssid(struct ath9k_htc_priv *priv)\r\n{\r\nif (priv->num_sta_assoc_vif == 1) {\r\nieee80211_iterate_active_interfaces_atomic(\r\npriv->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\r\nath9k_htc_bss_iter, priv);\r\nath9k_htc_set_bssid(priv);\r\n}\r\n}\r\nstatic void ath9k_htc_bss_info_changed(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *bss_conf,\r\nu32 changed)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath_hw *ah = priv->ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nint slottime;\r\nmutex_lock(&priv->mutex);\r\nath9k_htc_ps_wakeup(priv);\r\nif (changed & BSS_CHANGED_ASSOC) {\r\nath_dbg(common, CONFIG, "BSS Changed ASSOC %d\n",\r\nbss_conf->assoc);\r\nbss_conf->assoc ?\r\npriv->num_sta_assoc_vif++ : priv->num_sta_assoc_vif--;\r\nif (!bss_conf->assoc)\r\nclear_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags);\r\nif (priv->ah->opmode == NL80211_IFTYPE_STATION) {\r\nath9k_htc_choose_set_bssid(priv);\r\nif (bss_conf->assoc && (priv->num_sta_assoc_vif == 1))\r\nath9k_htc_start_ani(priv);\r\nelse if (priv->num_sta_assoc_vif == 0)\r\nath9k_htc_stop_ani(priv);\r\n}\r\n}\r\nif (changed & BSS_CHANGED_IBSS) {\r\nif (priv->ah->opmode == NL80211_IFTYPE_ADHOC) {\r\ncommon->curaid = bss_conf->aid;\r\nmemcpy(common->curbssid, bss_conf->bssid, ETH_ALEN);\r\nath9k_htc_set_bssid(priv);\r\n}\r\n}\r\nif ((changed & BSS_CHANGED_BEACON_ENABLED) && bss_conf->enable_beacon) {\r\nath_dbg(common, CONFIG, "Beacon enabled for BSS: %pM\n",\r\nbss_conf->bssid);\r\nath9k_htc_set_tsfadjust(priv, vif);\r\npriv->cur_beacon_conf.enable_beacon = 1;\r\nath9k_htc_beacon_config(priv, vif);\r\n}\r\nif ((changed & BSS_CHANGED_BEACON_ENABLED) && !bss_conf->enable_beacon) {\r\nif ((priv->num_ap_vif + priv->num_mbss_vif <= 1) ||\r\npriv->num_ibss_vif) {\r\nath_dbg(common, CONFIG,\r\n"Beacon disabled for BSS: %pM\n",\r\nbss_conf->bssid);\r\npriv->cur_beacon_conf.enable_beacon = 0;\r\nath9k_htc_beacon_config(priv, vif);\r\n}\r\n}\r\nif (changed & BSS_CHANGED_BEACON_INT) {\r\nif (priv->nvifs == 1 &&\r\n((priv->ah->opmode == NL80211_IFTYPE_AP &&\r\nvif->type == NL80211_IFTYPE_AP &&\r\npriv->num_ap_vif == 1) ||\r\n(priv->ah->opmode == NL80211_IFTYPE_MESH_POINT &&\r\nvif->type == NL80211_IFTYPE_MESH_POINT &&\r\npriv->num_mbss_vif == 1))) {\r\nset_bit(OP_TSF_RESET, &priv->op_flags);\r\n}\r\nath_dbg(common, CONFIG,\r\n"Beacon interval changed for BSS: %pM\n",\r\nbss_conf->bssid);\r\nath9k_htc_beacon_config(priv, vif);\r\n}\r\nif (changed & BSS_CHANGED_ERP_SLOT) {\r\nif (bss_conf->use_short_slot)\r\nslottime = 9;\r\nelse\r\nslottime = 20;\r\nif (vif->type == NL80211_IFTYPE_AP) {\r\npriv->beacon.slottime = slottime;\r\npriv->beacon.updateslot = UPDATE;\r\n} else {\r\nah->slottime = slottime;\r\nath9k_hw_init_global_settings(ah);\r\n}\r\n}\r\nif (changed & BSS_CHANGED_HT)\r\nath9k_htc_update_rate(priv, vif, bss_conf);\r\nath9k_htc_ps_restore(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic u64 ath9k_htc_get_tsf(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nu64 tsf;\r\nmutex_lock(&priv->mutex);\r\nath9k_htc_ps_wakeup(priv);\r\ntsf = ath9k_hw_gettsf64(priv->ah);\r\nath9k_htc_ps_restore(priv);\r\nmutex_unlock(&priv->mutex);\r\nreturn tsf;\r\n}\r\nstatic void ath9k_htc_set_tsf(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, u64 tsf)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nmutex_lock(&priv->mutex);\r\nath9k_htc_ps_wakeup(priv);\r\nath9k_hw_settsf64(priv->ah, tsf);\r\nath9k_htc_ps_restore(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic void ath9k_htc_reset_tsf(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nmutex_lock(&priv->mutex);\r\nath9k_htc_ps_wakeup(priv);\r\nath9k_hw_reset_tsf(priv->ah);\r\nath9k_htc_ps_restore(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int ath9k_htc_ampdu_action(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nenum ieee80211_ampdu_mlme_action action,\r\nstruct ieee80211_sta *sta,\r\nu16 tid, u16 *ssn, u8 buf_size)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath9k_htc_sta *ista;\r\nint ret = 0;\r\nmutex_lock(&priv->mutex);\r\nath9k_htc_ps_wakeup(priv);\r\nswitch (action) {\r\ncase IEEE80211_AMPDU_RX_START:\r\nbreak;\r\ncase IEEE80211_AMPDU_RX_STOP:\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_START:\r\nret = ath9k_htc_tx_aggr_oper(priv, vif, sta, action, tid);\r\nif (!ret)\r\nieee80211_start_tx_ba_cb_irqsafe(vif, sta->addr, tid);\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_STOP_CONT:\r\ncase IEEE80211_AMPDU_TX_STOP_FLUSH:\r\ncase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\r\nath9k_htc_tx_aggr_oper(priv, vif, sta, action, tid);\r\nieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_OPERATIONAL:\r\nista = (struct ath9k_htc_sta *) sta->drv_priv;\r\nspin_lock_bh(&priv->tx.tx_lock);\r\nista->tid_state[tid] = AGGR_OPERATIONAL;\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\nbreak;\r\ndefault:\r\nath_err(ath9k_hw_common(priv->ah), "Unknown AMPDU action\n");\r\n}\r\nath9k_htc_ps_restore(priv);\r\nmutex_unlock(&priv->mutex);\r\nreturn ret;\r\n}\r\nstatic void ath9k_htc_sw_scan_start(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nconst u8 *mac_addr)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nmutex_lock(&priv->mutex);\r\nspin_lock_bh(&priv->beacon_lock);\r\nset_bit(ATH_OP_SCANNING, &common->op_flags);\r\nspin_unlock_bh(&priv->beacon_lock);\r\ncancel_work_sync(&priv->ps_work);\r\nath9k_htc_stop_ani(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic void ath9k_htc_sw_scan_complete(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nmutex_lock(&priv->mutex);\r\nspin_lock_bh(&priv->beacon_lock);\r\nclear_bit(ATH_OP_SCANNING, &common->op_flags);\r\nspin_unlock_bh(&priv->beacon_lock);\r\nath9k_htc_ps_wakeup(priv);\r\nath9k_htc_vif_reconfig(priv);\r\nath9k_htc_ps_restore(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int ath9k_htc_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\r\n{\r\nreturn 0;\r\n}\r\nstatic void ath9k_htc_set_coverage_class(struct ieee80211_hw *hw,\r\ns16 coverage_class)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nmutex_lock(&priv->mutex);\r\nath9k_htc_ps_wakeup(priv);\r\npriv->ah->coverage_class = coverage_class;\r\nath9k_hw_init_global_settings(priv->ah);\r\nath9k_htc_ps_restore(priv);\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int ath9k_htc_set_bitrate_mask(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nconst struct cfg80211_bitrate_mask *mask)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_target_rate_mask tmask;\r\nstruct ath9k_htc_vif *avp = (void *)vif->drv_priv;\r\nint ret = 0;\r\nu8 cmd_rsp;\r\nmemset(&tmask, 0, sizeof(struct ath9k_htc_target_rate_mask));\r\ntmask.vif_index = avp->index;\r\ntmask.band = IEEE80211_BAND_2GHZ;\r\ntmask.mask = cpu_to_be32(mask->control[IEEE80211_BAND_2GHZ].legacy);\r\nWMI_CMD_BUF(WMI_BITRATE_MASK_CMDID, &tmask);\r\nif (ret) {\r\nath_err(common,\r\n"Unable to set 2G rate mask for "\r\n"interface at idx: %d\n", avp->index);\r\ngoto out;\r\n}\r\ntmask.band = IEEE80211_BAND_5GHZ;\r\ntmask.mask = cpu_to_be32(mask->control[IEEE80211_BAND_5GHZ].legacy);\r\nWMI_CMD_BUF(WMI_BITRATE_MASK_CMDID, &tmask);\r\nif (ret) {\r\nath_err(common,\r\n"Unable to set 5G rate mask for "\r\n"interface at idx: %d\n", avp->index);\r\ngoto out;\r\n}\r\nath_dbg(common, CONFIG, "Set bitrate masks: 0x%x, 0x%x\n",\r\nmask->control[IEEE80211_BAND_2GHZ].legacy,\r\nmask->control[IEEE80211_BAND_5GHZ].legacy);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ath9k_htc_get_stats(struct ieee80211_hw *hw,\r\nstruct ieee80211_low_level_stats *stats)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct ath_hw *ah = priv->ah;\r\nstruct ath9k_mib_stats *mib_stats = &ah->ah_mibStats;\r\nstats->dot11ACKFailureCount = mib_stats->ackrcv_bad;\r\nstats->dot11RTSFailureCount = mib_stats->rts_bad;\r\nstats->dot11FCSErrorCount = mib_stats->fcs_bad;\r\nstats->dot11RTSSuccessCount = mib_stats->rts_good;\r\nreturn 0;\r\n}\r\nstruct base_eep_header *ath9k_htc_get_eeprom_base(struct ath9k_htc_priv *priv)\r\n{\r\nstruct base_eep_header *pBase = NULL;\r\nif (AR_SREV_9271(priv->ah))\r\npBase = (struct base_eep_header *)\r\n&priv->ah->eeprom.map4k.baseEepHeader;\r\nelse if (priv->ah->hw_version.usbdev == AR9280_USB)\r\npBase = (struct base_eep_header *)\r\n&priv->ah->eeprom.def.baseEepHeader;\r\nelse if (priv->ah->hw_version.usbdev == AR9287_USB)\r\npBase = (struct base_eep_header *)\r\n&priv->ah->eeprom.map9287.baseEepHeader;\r\nreturn pBase;\r\n}\r\nstatic int ath9k_htc_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant,\r\nu32 *rx_ant)\r\n{\r\nstruct ath9k_htc_priv *priv = hw->priv;\r\nstruct base_eep_header *pBase = ath9k_htc_get_eeprom_base(priv);\r\nif (pBase) {\r\n*tx_ant = pBase->txMask;\r\n*rx_ant = pBase->rxMask;\r\n} else {\r\n*tx_ant = 0;\r\n*rx_ant = 0;\r\n}\r\nreturn 0;\r\n}
