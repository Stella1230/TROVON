static int berlin_reset_reset(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nstruct berlin_reset_priv *priv = to_berlin_reset_priv(rcdev);\r\nint offset = id >> 8;\r\nint mask = BIT(id & 0x1f);\r\nwritel(mask, priv->base + offset);\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic int berlin_reset_xlate(struct reset_controller_dev *rcdev,\r\nconst struct of_phandle_args *reset_spec)\r\n{\r\nstruct berlin_reset_priv *priv = to_berlin_reset_priv(rcdev);\r\nunsigned offset, bit;\r\nif (WARN_ON(reset_spec->args_count != rcdev->of_reset_n_cells))\r\nreturn -EINVAL;\r\noffset = reset_spec->args[0];\r\nbit = reset_spec->args[1];\r\nif (offset >= priv->size)\r\nreturn -EINVAL;\r\nif (bit >= BERLIN_MAX_RESETS)\r\nreturn -EINVAL;\r\nreturn (offset << 8) | bit;\r\n}\r\nstatic int __berlin_reset_init(struct device_node *np)\r\n{\r\nstruct berlin_reset_priv *priv;\r\nstruct resource res;\r\nresource_size_t size;\r\nint ret;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nret = of_address_to_resource(np, 0, &res);\r\nif (ret)\r\ngoto err;\r\nsize = resource_size(&res);\r\npriv->base = ioremap(res.start, size);\r\nif (!priv->base) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\npriv->size = size;\r\npriv->rcdev.owner = THIS_MODULE;\r\npriv->rcdev.ops = &berlin_reset_ops;\r\npriv->rcdev.of_node = np;\r\npriv->rcdev.of_reset_n_cells = 2;\r\npriv->rcdev.of_xlate = berlin_reset_xlate;\r\nreset_controller_register(&priv->rcdev);\r\nreturn 0;\r\nerr:\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nstatic int __init berlin_reset_init(void)\r\n{\r\nstruct device_node *np;\r\nint ret;\r\nfor_each_matching_node(np, berlin_reset_of_match) {\r\nret = __berlin_reset_init(np);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
