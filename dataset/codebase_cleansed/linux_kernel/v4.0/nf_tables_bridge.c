int nft_bridge_iphdr_validate(struct sk_buff *skb)\r\n{\r\nstruct iphdr *iph;\r\nu32 len;\r\nif (!pskb_may_pull(skb, sizeof(struct iphdr)))\r\nreturn 0;\r\niph = ip_hdr(skb);\r\nif (iph->ihl < 5 || iph->version != 4)\r\nreturn 0;\r\nlen = ntohs(iph->tot_len);\r\nif (skb->len < len)\r\nreturn 0;\r\nelse if (len < (iph->ihl*4))\r\nreturn 0;\r\nif (!pskb_may_pull(skb, iph->ihl*4))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint nft_bridge_ip6hdr_validate(struct sk_buff *skb)\r\n{\r\nstruct ipv6hdr *hdr;\r\nu32 pkt_len;\r\nif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\r\nreturn 0;\r\nhdr = ipv6_hdr(skb);\r\nif (hdr->version != 6)\r\nreturn 0;\r\npkt_len = ntohs(hdr->payload_len);\r\nif (pkt_len + sizeof(struct ipv6hdr) > skb->len)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic inline void nft_bridge_set_pktinfo_ipv4(struct nft_pktinfo *pkt,\r\nconst struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out)\r\n{\r\nif (nft_bridge_iphdr_validate(skb))\r\nnft_set_pktinfo_ipv4(pkt, ops, skb, in, out);\r\nelse\r\nnft_set_pktinfo(pkt, ops, skb, in, out);\r\n}\r\nstatic inline void nft_bridge_set_pktinfo_ipv6(struct nft_pktinfo *pkt,\r\nconst struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out)\r\n{\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (nft_bridge_ip6hdr_validate(skb) &&\r\nnft_set_pktinfo_ipv6(pkt, ops, skb, in, out) == 0)\r\nreturn;\r\n#endif\r\nnft_set_pktinfo(pkt, ops, skb, in, out);\r\n}\r\nstatic unsigned int\r\nnft_do_chain_bridge(const struct nf_hook_ops *ops,\r\nstruct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nint (*okfn)(struct sk_buff *))\r\n{\r\nstruct nft_pktinfo pkt;\r\nswitch (eth_hdr(skb)->h_proto) {\r\ncase htons(ETH_P_IP):\r\nnft_bridge_set_pktinfo_ipv4(&pkt, ops, skb, in, out);\r\nbreak;\r\ncase htons(ETH_P_IPV6):\r\nnft_bridge_set_pktinfo_ipv6(&pkt, ops, skb, in, out);\r\nbreak;\r\ndefault:\r\nnft_set_pktinfo(&pkt, ops, skb, in, out);\r\nbreak;\r\n}\r\nreturn nft_do_chain(&pkt, ops);\r\n}\r\nstatic int nf_tables_bridge_init_net(struct net *net)\r\n{\r\nnet->nft.bridge = kmalloc(sizeof(struct nft_af_info), GFP_KERNEL);\r\nif (net->nft.bridge == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(net->nft.bridge, &nft_af_bridge, sizeof(nft_af_bridge));\r\nif (nft_register_afinfo(net, net->nft.bridge) < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nkfree(net->nft.bridge);\r\nreturn -ENOMEM;\r\n}\r\nstatic void nf_tables_bridge_exit_net(struct net *net)\r\n{\r\nnft_unregister_afinfo(net->nft.bridge);\r\nkfree(net->nft.bridge);\r\n}\r\nstatic int __init nf_tables_bridge_init(void)\r\n{\r\nint ret;\r\nnft_register_chain_type(&filter_bridge);\r\nret = register_pernet_subsys(&nf_tables_bridge_net_ops);\r\nif (ret < 0)\r\nnft_unregister_chain_type(&filter_bridge);\r\nreturn ret;\r\n}\r\nstatic void __exit nf_tables_bridge_exit(void)\r\n{\r\nunregister_pernet_subsys(&nf_tables_bridge_net_ops);\r\nnft_unregister_chain_type(&filter_bridge);\r\n}
