void mac802154_llsec_init(struct mac802154_llsec *sec)\r\n{\r\nmemset(sec, 0, sizeof(*sec));\r\nmemset(&sec->params.default_key_source, 0xFF, IEEE802154_ADDR_LEN);\r\nINIT_LIST_HEAD(&sec->table.security_levels);\r\nINIT_LIST_HEAD(&sec->table.devices);\r\nINIT_LIST_HEAD(&sec->table.keys);\r\nhash_init(sec->devices_short);\r\nhash_init(sec->devices_hw);\r\nrwlock_init(&sec->lock);\r\n}\r\nvoid mac802154_llsec_destroy(struct mac802154_llsec *sec)\r\n{\r\nstruct ieee802154_llsec_seclevel *sl, *sn;\r\nstruct ieee802154_llsec_device *dev, *dn;\r\nstruct ieee802154_llsec_key_entry *key, *kn;\r\nlist_for_each_entry_safe(sl, sn, &sec->table.security_levels, list) {\r\nstruct mac802154_llsec_seclevel *msl;\r\nmsl = container_of(sl, struct mac802154_llsec_seclevel, level);\r\nlist_del(&sl->list);\r\nkfree(msl);\r\n}\r\nlist_for_each_entry_safe(dev, dn, &sec->table.devices, list) {\r\nstruct mac802154_llsec_device *mdev;\r\nmdev = container_of(dev, struct mac802154_llsec_device, dev);\r\nlist_del(&dev->list);\r\nllsec_dev_free(mdev);\r\n}\r\nlist_for_each_entry_safe(key, kn, &sec->table.keys, list) {\r\nstruct mac802154_llsec_key *mkey;\r\nmkey = container_of(key->key, struct mac802154_llsec_key, key);\r\nlist_del(&key->list);\r\nllsec_key_put(mkey);\r\nkfree(key);\r\n}\r\n}\r\nint mac802154_llsec_get_params(struct mac802154_llsec *sec,\r\nstruct ieee802154_llsec_params *params)\r\n{\r\nread_lock_bh(&sec->lock);\r\n*params = sec->params;\r\nread_unlock_bh(&sec->lock);\r\nreturn 0;\r\n}\r\nint mac802154_llsec_set_params(struct mac802154_llsec *sec,\r\nconst struct ieee802154_llsec_params *params,\r\nint changed)\r\n{\r\nwrite_lock_bh(&sec->lock);\r\nif (changed & IEEE802154_LLSEC_PARAM_ENABLED)\r\nsec->params.enabled = params->enabled;\r\nif (changed & IEEE802154_LLSEC_PARAM_FRAME_COUNTER)\r\nsec->params.frame_counter = params->frame_counter;\r\nif (changed & IEEE802154_LLSEC_PARAM_OUT_LEVEL)\r\nsec->params.out_level = params->out_level;\r\nif (changed & IEEE802154_LLSEC_PARAM_OUT_KEY)\r\nsec->params.out_key = params->out_key;\r\nif (changed & IEEE802154_LLSEC_PARAM_KEY_SOURCE)\r\nsec->params.default_key_source = params->default_key_source;\r\nif (changed & IEEE802154_LLSEC_PARAM_PAN_ID)\r\nsec->params.pan_id = params->pan_id;\r\nif (changed & IEEE802154_LLSEC_PARAM_HWADDR)\r\nsec->params.hwaddr = params->hwaddr;\r\nif (changed & IEEE802154_LLSEC_PARAM_COORD_HWADDR)\r\nsec->params.coord_hwaddr = params->coord_hwaddr;\r\nif (changed & IEEE802154_LLSEC_PARAM_COORD_SHORTADDR)\r\nsec->params.coord_shortaddr = params->coord_shortaddr;\r\nwrite_unlock_bh(&sec->lock);\r\nreturn 0;\r\n}\r\nstatic struct mac802154_llsec_key*\r\nllsec_key_alloc(const struct ieee802154_llsec_key *template)\r\n{\r\nconst int authsizes[3] = { 4, 8, 16 };\r\nstruct mac802154_llsec_key *key;\r\nint i;\r\nkey = kzalloc(sizeof(*key), GFP_KERNEL);\r\nif (!key)\r\nreturn NULL;\r\nkref_init(&key->ref);\r\nkey->key = *template;\r\nBUILD_BUG_ON(ARRAY_SIZE(authsizes) != ARRAY_SIZE(key->tfm));\r\nfor (i = 0; i < ARRAY_SIZE(key->tfm); i++) {\r\nkey->tfm[i] = crypto_alloc_aead("ccm(aes)", 0,\r\nCRYPTO_ALG_ASYNC);\r\nif (!key->tfm[i])\r\ngoto err_tfm;\r\nif (crypto_aead_setkey(key->tfm[i], template->key,\r\nIEEE802154_LLSEC_KEY_SIZE))\r\ngoto err_tfm;\r\nif (crypto_aead_setauthsize(key->tfm[i], authsizes[i]))\r\ngoto err_tfm;\r\n}\r\nkey->tfm0 = crypto_alloc_blkcipher("ctr(aes)", 0, CRYPTO_ALG_ASYNC);\r\nif (!key->tfm0)\r\ngoto err_tfm;\r\nif (crypto_blkcipher_setkey(key->tfm0, template->key,\r\nIEEE802154_LLSEC_KEY_SIZE))\r\ngoto err_tfm0;\r\nreturn key;\r\nerr_tfm0:\r\ncrypto_free_blkcipher(key->tfm0);\r\nerr_tfm:\r\nfor (i = 0; i < ARRAY_SIZE(key->tfm); i++)\r\nif (key->tfm[i])\r\ncrypto_free_aead(key->tfm[i]);\r\nkfree(key);\r\nreturn NULL;\r\n}\r\nstatic void llsec_key_release(struct kref *ref)\r\n{\r\nstruct mac802154_llsec_key *key;\r\nint i;\r\nkey = container_of(ref, struct mac802154_llsec_key, ref);\r\nfor (i = 0; i < ARRAY_SIZE(key->tfm); i++)\r\ncrypto_free_aead(key->tfm[i]);\r\ncrypto_free_blkcipher(key->tfm0);\r\nkfree(key);\r\n}\r\nstatic struct mac802154_llsec_key*\r\nllsec_key_get(struct mac802154_llsec_key *key)\r\n{\r\nkref_get(&key->ref);\r\nreturn key;\r\n}\r\nstatic void llsec_key_put(struct mac802154_llsec_key *key)\r\n{\r\nkref_put(&key->ref, llsec_key_release);\r\n}\r\nstatic bool llsec_key_id_equal(const struct ieee802154_llsec_key_id *a,\r\nconst struct ieee802154_llsec_key_id *b)\r\n{\r\nif (a->mode != b->mode)\r\nreturn false;\r\nif (a->mode == IEEE802154_SCF_KEY_IMPLICIT)\r\nreturn ieee802154_addr_equal(&a->device_addr, &b->device_addr);\r\nif (a->id != b->id)\r\nreturn false;\r\nswitch (a->mode) {\r\ncase IEEE802154_SCF_KEY_INDEX:\r\nreturn true;\r\ncase IEEE802154_SCF_KEY_SHORT_INDEX:\r\nreturn a->short_source == b->short_source;\r\ncase IEEE802154_SCF_KEY_HW_INDEX:\r\nreturn a->extended_source == b->extended_source;\r\n}\r\nreturn false;\r\n}\r\nint mac802154_llsec_key_add(struct mac802154_llsec *sec,\r\nconst struct ieee802154_llsec_key_id *id,\r\nconst struct ieee802154_llsec_key *key)\r\n{\r\nstruct mac802154_llsec_key *mkey = NULL;\r\nstruct ieee802154_llsec_key_entry *pos, *new;\r\nif (!(key->frame_types & (1 << IEEE802154_FC_TYPE_MAC_CMD)) &&\r\nkey->cmd_frame_ids)\r\nreturn -EINVAL;\r\nlist_for_each_entry(pos, &sec->table.keys, list) {\r\nif (llsec_key_id_equal(&pos->id, id))\r\nreturn -EEXIST;\r\nif (memcmp(pos->key->key, key->key,\r\nIEEE802154_LLSEC_KEY_SIZE))\r\ncontinue;\r\nmkey = container_of(pos->key, struct mac802154_llsec_key, key);\r\nif (pos->key->frame_types != key->frame_types ||\r\npos->key->cmd_frame_ids != key->cmd_frame_ids)\r\nreturn -EEXIST;\r\nbreak;\r\n}\r\nnew = kzalloc(sizeof(*new), GFP_KERNEL);\r\nif (!new)\r\nreturn -ENOMEM;\r\nif (!mkey)\r\nmkey = llsec_key_alloc(key);\r\nelse\r\nmkey = llsec_key_get(mkey);\r\nif (!mkey)\r\ngoto fail;\r\nnew->id = *id;\r\nnew->key = &mkey->key;\r\nlist_add_rcu(&new->list, &sec->table.keys);\r\nreturn 0;\r\nfail:\r\nkfree(new);\r\nreturn -ENOMEM;\r\n}\r\nint mac802154_llsec_key_del(struct mac802154_llsec *sec,\r\nconst struct ieee802154_llsec_key_id *key)\r\n{\r\nstruct ieee802154_llsec_key_entry *pos;\r\nlist_for_each_entry(pos, &sec->table.keys, list) {\r\nstruct mac802154_llsec_key *mkey;\r\nmkey = container_of(pos->key, struct mac802154_llsec_key, key);\r\nif (llsec_key_id_equal(&pos->id, key)) {\r\nlist_del_rcu(&pos->list);\r\nllsec_key_put(mkey);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic bool llsec_dev_use_shortaddr(__le16 short_addr)\r\n{\r\nreturn short_addr != cpu_to_le16(IEEE802154_ADDR_UNDEF) &&\r\nshort_addr != cpu_to_le16(0xffff);\r\n}\r\nstatic u32 llsec_dev_hash_short(__le16 short_addr, __le16 pan_id)\r\n{\r\nreturn ((__force u16)short_addr) << 16 | (__force u16)pan_id;\r\n}\r\nstatic u64 llsec_dev_hash_long(__le64 hwaddr)\r\n{\r\nreturn (__force u64)hwaddr;\r\n}\r\nstatic struct mac802154_llsec_device*\r\nllsec_dev_find_short(struct mac802154_llsec *sec, __le16 short_addr,\r\n__le16 pan_id)\r\n{\r\nstruct mac802154_llsec_device *dev;\r\nu32 key = llsec_dev_hash_short(short_addr, pan_id);\r\nhash_for_each_possible_rcu(sec->devices_short, dev, bucket_s, key) {\r\nif (dev->dev.short_addr == short_addr &&\r\ndev->dev.pan_id == pan_id)\r\nreturn dev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mac802154_llsec_device*\r\nllsec_dev_find_long(struct mac802154_llsec *sec, __le64 hwaddr)\r\n{\r\nstruct mac802154_llsec_device *dev;\r\nu64 key = llsec_dev_hash_long(hwaddr);\r\nhash_for_each_possible_rcu(sec->devices_hw, dev, bucket_hw, key) {\r\nif (dev->dev.hwaddr == hwaddr)\r\nreturn dev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void llsec_dev_free(struct mac802154_llsec_device *dev)\r\n{\r\nstruct ieee802154_llsec_device_key *pos, *pn;\r\nstruct mac802154_llsec_device_key *devkey;\r\nlist_for_each_entry_safe(pos, pn, &dev->dev.keys, list) {\r\ndevkey = container_of(pos, struct mac802154_llsec_device_key,\r\ndevkey);\r\nlist_del(&pos->list);\r\nkfree(devkey);\r\n}\r\nkfree(dev);\r\n}\r\nint mac802154_llsec_dev_add(struct mac802154_llsec *sec,\r\nconst struct ieee802154_llsec_device *dev)\r\n{\r\nstruct mac802154_llsec_device *entry;\r\nu32 skey = llsec_dev_hash_short(dev->short_addr, dev->pan_id);\r\nu64 hwkey = llsec_dev_hash_long(dev->hwaddr);\r\nBUILD_BUG_ON(sizeof(hwkey) != IEEE802154_ADDR_LEN);\r\nif ((llsec_dev_use_shortaddr(dev->short_addr) &&\r\nllsec_dev_find_short(sec, dev->short_addr, dev->pan_id)) ||\r\nllsec_dev_find_long(sec, dev->hwaddr))\r\nreturn -EEXIST;\r\nentry = kmalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->dev = *dev;\r\nspin_lock_init(&entry->lock);\r\nINIT_LIST_HEAD(&entry->dev.keys);\r\nif (llsec_dev_use_shortaddr(dev->short_addr))\r\nhash_add_rcu(sec->devices_short, &entry->bucket_s, skey);\r\nelse\r\nINIT_HLIST_NODE(&entry->bucket_s);\r\nhash_add_rcu(sec->devices_hw, &entry->bucket_hw, hwkey);\r\nlist_add_tail_rcu(&entry->dev.list, &sec->table.devices);\r\nreturn 0;\r\n}\r\nstatic void llsec_dev_free_rcu(struct rcu_head *rcu)\r\n{\r\nllsec_dev_free(container_of(rcu, struct mac802154_llsec_device, rcu));\r\n}\r\nint mac802154_llsec_dev_del(struct mac802154_llsec *sec, __le64 device_addr)\r\n{\r\nstruct mac802154_llsec_device *pos;\r\npos = llsec_dev_find_long(sec, device_addr);\r\nif (!pos)\r\nreturn -ENOENT;\r\nhash_del_rcu(&pos->bucket_s);\r\nhash_del_rcu(&pos->bucket_hw);\r\ncall_rcu(&pos->rcu, llsec_dev_free_rcu);\r\nreturn 0;\r\n}\r\nstatic struct mac802154_llsec_device_key*\r\nllsec_devkey_find(struct mac802154_llsec_device *dev,\r\nconst struct ieee802154_llsec_key_id *key)\r\n{\r\nstruct ieee802154_llsec_device_key *devkey;\r\nlist_for_each_entry_rcu(devkey, &dev->dev.keys, list) {\r\nif (!llsec_key_id_equal(key, &devkey->key_id))\r\ncontinue;\r\nreturn container_of(devkey, struct mac802154_llsec_device_key,\r\ndevkey);\r\n}\r\nreturn NULL;\r\n}\r\nint mac802154_llsec_devkey_add(struct mac802154_llsec *sec,\r\n__le64 dev_addr,\r\nconst struct ieee802154_llsec_device_key *key)\r\n{\r\nstruct mac802154_llsec_device *dev;\r\nstruct mac802154_llsec_device_key *devkey;\r\ndev = llsec_dev_find_long(sec, dev_addr);\r\nif (!dev)\r\nreturn -ENOENT;\r\nif (llsec_devkey_find(dev, &key->key_id))\r\nreturn -EEXIST;\r\ndevkey = kmalloc(sizeof(*devkey), GFP_KERNEL);\r\nif (!devkey)\r\nreturn -ENOMEM;\r\ndevkey->devkey = *key;\r\nlist_add_tail_rcu(&devkey->devkey.list, &dev->dev.keys);\r\nreturn 0;\r\n}\r\nint mac802154_llsec_devkey_del(struct mac802154_llsec *sec,\r\n__le64 dev_addr,\r\nconst struct ieee802154_llsec_device_key *key)\r\n{\r\nstruct mac802154_llsec_device *dev;\r\nstruct mac802154_llsec_device_key *devkey;\r\ndev = llsec_dev_find_long(sec, dev_addr);\r\nif (!dev)\r\nreturn -ENOENT;\r\ndevkey = llsec_devkey_find(dev, &key->key_id);\r\nif (!devkey)\r\nreturn -ENOENT;\r\nlist_del_rcu(&devkey->devkey.list);\r\nkfree_rcu(devkey, rcu);\r\nreturn 0;\r\n}\r\nstatic struct mac802154_llsec_seclevel*\r\nllsec_find_seclevel(const struct mac802154_llsec *sec,\r\nconst struct ieee802154_llsec_seclevel *sl)\r\n{\r\nstruct ieee802154_llsec_seclevel *pos;\r\nlist_for_each_entry(pos, &sec->table.security_levels, list) {\r\nif (pos->frame_type != sl->frame_type ||\r\n(pos->frame_type == IEEE802154_FC_TYPE_MAC_CMD &&\r\npos->cmd_frame_id != sl->cmd_frame_id) ||\r\npos->device_override != sl->device_override ||\r\npos->sec_levels != sl->sec_levels)\r\ncontinue;\r\nreturn container_of(pos, struct mac802154_llsec_seclevel,\r\nlevel);\r\n}\r\nreturn NULL;\r\n}\r\nint mac802154_llsec_seclevel_add(struct mac802154_llsec *sec,\r\nconst struct ieee802154_llsec_seclevel *sl)\r\n{\r\nstruct mac802154_llsec_seclevel *entry;\r\nif (llsec_find_seclevel(sec, sl))\r\nreturn -EEXIST;\r\nentry = kmalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->level = *sl;\r\nlist_add_tail_rcu(&entry->level.list, &sec->table.security_levels);\r\nreturn 0;\r\n}\r\nint mac802154_llsec_seclevel_del(struct mac802154_llsec *sec,\r\nconst struct ieee802154_llsec_seclevel *sl)\r\n{\r\nstruct mac802154_llsec_seclevel *pos;\r\npos = llsec_find_seclevel(sec, sl);\r\nif (!pos)\r\nreturn -ENOENT;\r\nlist_del_rcu(&pos->level.list);\r\nkfree_rcu(pos, rcu);\r\nreturn 0;\r\n}\r\nstatic int llsec_recover_addr(struct mac802154_llsec *sec,\r\nstruct ieee802154_addr *addr)\r\n{\r\n__le16 caddr = sec->params.coord_shortaddr;\r\naddr->pan_id = sec->params.pan_id;\r\nif (caddr == cpu_to_le16(IEEE802154_ADDR_BROADCAST)) {\r\nreturn -EINVAL;\r\n} else if (caddr == cpu_to_le16(IEEE802154_ADDR_UNDEF)) {\r\naddr->extended_addr = sec->params.coord_hwaddr;\r\naddr->mode = IEEE802154_ADDR_LONG;\r\n} else {\r\naddr->short_addr = sec->params.coord_shortaddr;\r\naddr->mode = IEEE802154_ADDR_SHORT;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct mac802154_llsec_key*\r\nllsec_lookup_key(struct mac802154_llsec *sec,\r\nconst struct ieee802154_hdr *hdr,\r\nconst struct ieee802154_addr *addr,\r\nstruct ieee802154_llsec_key_id *key_id)\r\n{\r\nstruct ieee802154_addr devaddr = *addr;\r\nu8 key_id_mode = hdr->sec.key_id_mode;\r\nstruct ieee802154_llsec_key_entry *key_entry;\r\nstruct mac802154_llsec_key *key;\r\nif (key_id_mode == IEEE802154_SCF_KEY_IMPLICIT &&\r\ndevaddr.mode == IEEE802154_ADDR_NONE) {\r\nif (hdr->fc.type == IEEE802154_FC_TYPE_BEACON) {\r\ndevaddr.extended_addr = sec->params.coord_hwaddr;\r\ndevaddr.mode = IEEE802154_ADDR_LONG;\r\n} else if (llsec_recover_addr(sec, &devaddr) < 0) {\r\nreturn NULL;\r\n}\r\n}\r\nlist_for_each_entry_rcu(key_entry, &sec->table.keys, list) {\r\nconst struct ieee802154_llsec_key_id *id = &key_entry->id;\r\nif (!(key_entry->key->frame_types & BIT(hdr->fc.type)))\r\ncontinue;\r\nif (id->mode != key_id_mode)\r\ncontinue;\r\nif (key_id_mode == IEEE802154_SCF_KEY_IMPLICIT) {\r\nif (ieee802154_addr_equal(&devaddr, &id->device_addr))\r\ngoto found;\r\n} else {\r\nif (id->id != hdr->sec.key_id)\r\ncontinue;\r\nif ((key_id_mode == IEEE802154_SCF_KEY_INDEX) ||\r\n(key_id_mode == IEEE802154_SCF_KEY_SHORT_INDEX &&\r\nid->short_source == hdr->sec.short_src) ||\r\n(key_id_mode == IEEE802154_SCF_KEY_HW_INDEX &&\r\nid->extended_source == hdr->sec.extended_src))\r\ngoto found;\r\n}\r\n}\r\nreturn NULL;\r\nfound:\r\nkey = container_of(key_entry->key, struct mac802154_llsec_key, key);\r\nif (key_id)\r\n*key_id = key_entry->id;\r\nreturn llsec_key_get(key);\r\n}\r\nstatic void llsec_geniv(u8 iv[16], __le64 addr,\r\nconst struct ieee802154_sechdr *sec)\r\n{\r\n__be64 addr_bytes = (__force __be64) swab64((__force u64) addr);\r\n__be32 frame_counter = (__force __be32) swab32((__force u32) sec->frame_counter);\r\niv[0] = 1;\r\nmemcpy(iv + 1, &addr_bytes, sizeof(addr_bytes));\r\nmemcpy(iv + 9, &frame_counter, sizeof(frame_counter));\r\niv[13] = sec->level;\r\niv[14] = 0;\r\niv[15] = 1;\r\n}\r\nstatic int\r\nllsec_do_encrypt_unauth(struct sk_buff *skb, const struct mac802154_llsec *sec,\r\nconst struct ieee802154_hdr *hdr,\r\nstruct mac802154_llsec_key *key)\r\n{\r\nu8 iv[16];\r\nstruct scatterlist src;\r\nstruct blkcipher_desc req = {\r\n.tfm = key->tfm0,\r\n.info = iv,\r\n.flags = 0,\r\n};\r\nllsec_geniv(iv, sec->params.hwaddr, &hdr->sec);\r\nsg_init_one(&src, skb->data, skb->len);\r\nreturn crypto_blkcipher_encrypt_iv(&req, &src, &src, skb->len);\r\n}\r\nstatic struct crypto_aead*\r\nllsec_tfm_by_len(struct mac802154_llsec_key *key, int authlen)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(key->tfm); i++)\r\nif (crypto_aead_authsize(key->tfm[i]) == authlen)\r\nreturn key->tfm[i];\r\nBUG();\r\n}\r\nstatic int\r\nllsec_do_encrypt_auth(struct sk_buff *skb, const struct mac802154_llsec *sec,\r\nconst struct ieee802154_hdr *hdr,\r\nstruct mac802154_llsec_key *key)\r\n{\r\nu8 iv[16];\r\nunsigned char *data;\r\nint authlen, assoclen, datalen, rc;\r\nstruct scatterlist src, assoc[2], dst[2];\r\nstruct aead_request *req;\r\nauthlen = ieee802154_sechdr_authtag_len(&hdr->sec);\r\nllsec_geniv(iv, sec->params.hwaddr, &hdr->sec);\r\nreq = aead_request_alloc(llsec_tfm_by_len(key, authlen), GFP_ATOMIC);\r\nif (!req)\r\nreturn -ENOMEM;\r\nsg_init_table(assoc, 2);\r\nsg_set_buf(&assoc[0], skb_mac_header(skb), skb->mac_len);\r\nassoclen = skb->mac_len;\r\ndata = skb_mac_header(skb) + skb->mac_len;\r\ndatalen = skb_tail_pointer(skb) - data;\r\nif (hdr->sec.level & IEEE802154_SCF_SECLEVEL_ENC) {\r\nsg_set_buf(&assoc[1], data, 0);\r\n} else {\r\nsg_set_buf(&assoc[1], data, datalen);\r\nassoclen += datalen;\r\ndatalen = 0;\r\n}\r\nsg_init_one(&src, data, datalen);\r\nsg_init_table(dst, 2);\r\nsg_set_buf(&dst[0], data, datalen);\r\nsg_set_buf(&dst[1], skb_put(skb, authlen), authlen);\r\naead_request_set_callback(req, 0, NULL, NULL);\r\naead_request_set_assoc(req, assoc, assoclen);\r\naead_request_set_crypt(req, &src, dst, datalen, iv);\r\nrc = crypto_aead_encrypt(req);\r\nkfree(req);\r\nreturn rc;\r\n}\r\nstatic int llsec_do_encrypt(struct sk_buff *skb,\r\nconst struct mac802154_llsec *sec,\r\nconst struct ieee802154_hdr *hdr,\r\nstruct mac802154_llsec_key *key)\r\n{\r\nif (hdr->sec.level == IEEE802154_SCF_SECLEVEL_ENC)\r\nreturn llsec_do_encrypt_unauth(skb, sec, hdr, key);\r\nelse\r\nreturn llsec_do_encrypt_auth(skb, sec, hdr, key);\r\n}\r\nint mac802154_llsec_encrypt(struct mac802154_llsec *sec, struct sk_buff *skb)\r\n{\r\nstruct ieee802154_hdr hdr;\r\nint rc, authlen, hlen;\r\nstruct mac802154_llsec_key *key;\r\nu32 frame_ctr;\r\nhlen = ieee802154_hdr_pull(skb, &hdr);\r\nif (hlen < 0 || hdr.fc.type != IEEE802154_FC_TYPE_DATA)\r\nreturn -EINVAL;\r\nif (!hdr.fc.security_enabled || hdr.sec.level == 0) {\r\nskb_push(skb, hlen);\r\nreturn 0;\r\n}\r\nauthlen = ieee802154_sechdr_authtag_len(&hdr.sec);\r\nif (skb->len + hlen + authlen + IEEE802154_MFR_SIZE > IEEE802154_MTU)\r\nreturn -EMSGSIZE;\r\nrcu_read_lock();\r\nread_lock_bh(&sec->lock);\r\nif (!sec->params.enabled) {\r\nrc = -EINVAL;\r\ngoto fail_read;\r\n}\r\nkey = llsec_lookup_key(sec, &hdr, &hdr.dest, NULL);\r\nif (!key) {\r\nrc = -ENOKEY;\r\ngoto fail_read;\r\n}\r\nread_unlock_bh(&sec->lock);\r\nwrite_lock_bh(&sec->lock);\r\nframe_ctr = be32_to_cpu(sec->params.frame_counter);\r\nhdr.sec.frame_counter = cpu_to_le32(frame_ctr);\r\nif (frame_ctr == 0xFFFFFFFF) {\r\nwrite_unlock_bh(&sec->lock);\r\nllsec_key_put(key);\r\nrc = -EOVERFLOW;\r\ngoto fail;\r\n}\r\nsec->params.frame_counter = cpu_to_be32(frame_ctr + 1);\r\nwrite_unlock_bh(&sec->lock);\r\nrcu_read_unlock();\r\nskb->mac_len = ieee802154_hdr_push(skb, &hdr);\r\nskb_reset_mac_header(skb);\r\nrc = llsec_do_encrypt(skb, sec, &hdr, key);\r\nllsec_key_put(key);\r\nreturn rc;\r\nfail_read:\r\nread_unlock_bh(&sec->lock);\r\nfail:\r\nrcu_read_unlock();\r\nreturn rc;\r\n}\r\nstatic struct mac802154_llsec_device*\r\nllsec_lookup_dev(struct mac802154_llsec *sec,\r\nconst struct ieee802154_addr *addr)\r\n{\r\nstruct ieee802154_addr devaddr = *addr;\r\nstruct mac802154_llsec_device *dev = NULL;\r\nif (devaddr.mode == IEEE802154_ADDR_NONE &&\r\nllsec_recover_addr(sec, &devaddr) < 0)\r\nreturn NULL;\r\nif (devaddr.mode == IEEE802154_ADDR_SHORT) {\r\nu32 key = llsec_dev_hash_short(devaddr.short_addr,\r\ndevaddr.pan_id);\r\nhash_for_each_possible_rcu(sec->devices_short, dev,\r\nbucket_s, key) {\r\nif (dev->dev.pan_id == devaddr.pan_id &&\r\ndev->dev.short_addr == devaddr.short_addr)\r\nreturn dev;\r\n}\r\n} else {\r\nu64 key = llsec_dev_hash_long(devaddr.extended_addr);\r\nhash_for_each_possible_rcu(sec->devices_hw, dev,\r\nbucket_hw, key) {\r\nif (dev->dev.hwaddr == devaddr.extended_addr)\r\nreturn dev;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nllsec_lookup_seclevel(const struct mac802154_llsec *sec,\r\nu8 frame_type, u8 cmd_frame_id,\r\nstruct ieee802154_llsec_seclevel *rlevel)\r\n{\r\nstruct ieee802154_llsec_seclevel *level;\r\nlist_for_each_entry_rcu(level, &sec->table.security_levels, list) {\r\nif (level->frame_type == frame_type &&\r\n(frame_type != IEEE802154_FC_TYPE_MAC_CMD ||\r\nlevel->cmd_frame_id == cmd_frame_id)) {\r\n*rlevel = *level;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nllsec_do_decrypt_unauth(struct sk_buff *skb, const struct mac802154_llsec *sec,\r\nconst struct ieee802154_hdr *hdr,\r\nstruct mac802154_llsec_key *key, __le64 dev_addr)\r\n{\r\nu8 iv[16];\r\nunsigned char *data;\r\nint datalen;\r\nstruct scatterlist src;\r\nstruct blkcipher_desc req = {\r\n.tfm = key->tfm0,\r\n.info = iv,\r\n.flags = 0,\r\n};\r\nllsec_geniv(iv, dev_addr, &hdr->sec);\r\ndata = skb_mac_header(skb) + skb->mac_len;\r\ndatalen = skb_tail_pointer(skb) - data;\r\nsg_init_one(&src, data, datalen);\r\nreturn crypto_blkcipher_decrypt_iv(&req, &src, &src, datalen);\r\n}\r\nstatic int\r\nllsec_do_decrypt_auth(struct sk_buff *skb, const struct mac802154_llsec *sec,\r\nconst struct ieee802154_hdr *hdr,\r\nstruct mac802154_llsec_key *key, __le64 dev_addr)\r\n{\r\nu8 iv[16];\r\nunsigned char *data;\r\nint authlen, datalen, assoclen, rc;\r\nstruct scatterlist src, assoc[2];\r\nstruct aead_request *req;\r\nauthlen = ieee802154_sechdr_authtag_len(&hdr->sec);\r\nllsec_geniv(iv, dev_addr, &hdr->sec);\r\nreq = aead_request_alloc(llsec_tfm_by_len(key, authlen), GFP_ATOMIC);\r\nif (!req)\r\nreturn -ENOMEM;\r\nsg_init_table(assoc, 2);\r\nsg_set_buf(&assoc[0], skb_mac_header(skb), skb->mac_len);\r\nassoclen = skb->mac_len;\r\ndata = skb_mac_header(skb) + skb->mac_len;\r\ndatalen = skb_tail_pointer(skb) - data;\r\nif (hdr->sec.level & IEEE802154_SCF_SECLEVEL_ENC) {\r\nsg_set_buf(&assoc[1], data, 0);\r\n} else {\r\nsg_set_buf(&assoc[1], data, datalen - authlen);\r\nassoclen += datalen - authlen;\r\ndata += datalen - authlen;\r\ndatalen = authlen;\r\n}\r\nsg_init_one(&src, data, datalen);\r\naead_request_set_callback(req, 0, NULL, NULL);\r\naead_request_set_assoc(req, assoc, assoclen);\r\naead_request_set_crypt(req, &src, &src, datalen, iv);\r\nrc = crypto_aead_decrypt(req);\r\nkfree(req);\r\nskb_trim(skb, skb->len - authlen);\r\nreturn rc;\r\n}\r\nstatic int\r\nllsec_do_decrypt(struct sk_buff *skb, const struct mac802154_llsec *sec,\r\nconst struct ieee802154_hdr *hdr,\r\nstruct mac802154_llsec_key *key, __le64 dev_addr)\r\n{\r\nif (hdr->sec.level == IEEE802154_SCF_SECLEVEL_ENC)\r\nreturn llsec_do_decrypt_unauth(skb, sec, hdr, key, dev_addr);\r\nelse\r\nreturn llsec_do_decrypt_auth(skb, sec, hdr, key, dev_addr);\r\n}\r\nstatic int\r\nllsec_update_devkey_record(struct mac802154_llsec_device *dev,\r\nconst struct ieee802154_llsec_key_id *in_key)\r\n{\r\nstruct mac802154_llsec_device_key *devkey;\r\ndevkey = llsec_devkey_find(dev, in_key);\r\nif (!devkey) {\r\nstruct mac802154_llsec_device_key *next;\r\nnext = kzalloc(sizeof(*devkey), GFP_ATOMIC);\r\nif (!next)\r\nreturn -ENOMEM;\r\nnext->devkey.key_id = *in_key;\r\nspin_lock_bh(&dev->lock);\r\ndevkey = llsec_devkey_find(dev, in_key);\r\nif (!devkey)\r\nlist_add_rcu(&next->devkey.list, &dev->dev.keys);\r\nelse\r\nkfree(next);\r\nspin_unlock_bh(&dev->lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nllsec_update_devkey_info(struct mac802154_llsec_device *dev,\r\nconst struct ieee802154_llsec_key_id *in_key,\r\nu32 frame_counter)\r\n{\r\nstruct mac802154_llsec_device_key *devkey = NULL;\r\nif (dev->dev.key_mode == IEEE802154_LLSEC_DEVKEY_RESTRICT) {\r\ndevkey = llsec_devkey_find(dev, in_key);\r\nif (!devkey)\r\nreturn -ENOENT;\r\n}\r\nif (dev->dev.key_mode == IEEE802154_LLSEC_DEVKEY_RECORD) {\r\nint rc = llsec_update_devkey_record(dev, in_key);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nspin_lock_bh(&dev->lock);\r\nif ((!devkey && frame_counter < dev->dev.frame_counter) ||\r\n(devkey && frame_counter < devkey->devkey.frame_counter)) {\r\nspin_unlock_bh(&dev->lock);\r\nreturn -EINVAL;\r\n}\r\nif (devkey)\r\ndevkey->devkey.frame_counter = frame_counter + 1;\r\nelse\r\ndev->dev.frame_counter = frame_counter + 1;\r\nspin_unlock_bh(&dev->lock);\r\nreturn 0;\r\n}\r\nint mac802154_llsec_decrypt(struct mac802154_llsec *sec, struct sk_buff *skb)\r\n{\r\nstruct ieee802154_hdr hdr;\r\nstruct mac802154_llsec_key *key;\r\nstruct ieee802154_llsec_key_id key_id;\r\nstruct mac802154_llsec_device *dev;\r\nstruct ieee802154_llsec_seclevel seclevel;\r\nint err;\r\n__le64 dev_addr;\r\nu32 frame_ctr;\r\nif (ieee802154_hdr_peek(skb, &hdr) < 0)\r\nreturn -EINVAL;\r\nif (!hdr.fc.security_enabled)\r\nreturn 0;\r\nif (hdr.fc.version == 0)\r\nreturn -EINVAL;\r\nread_lock_bh(&sec->lock);\r\nif (!sec->params.enabled) {\r\nread_unlock_bh(&sec->lock);\r\nreturn -EINVAL;\r\n}\r\nread_unlock_bh(&sec->lock);\r\nrcu_read_lock();\r\nkey = llsec_lookup_key(sec, &hdr, &hdr.source, &key_id);\r\nif (!key) {\r\nerr = -ENOKEY;\r\ngoto fail;\r\n}\r\ndev = llsec_lookup_dev(sec, &hdr.source);\r\nif (!dev) {\r\nerr = -EINVAL;\r\ngoto fail_dev;\r\n}\r\nif (llsec_lookup_seclevel(sec, hdr.fc.type, 0, &seclevel) < 0) {\r\nerr = -EINVAL;\r\ngoto fail_dev;\r\n}\r\nif (!(seclevel.sec_levels & BIT(hdr.sec.level)) &&\r\n(hdr.sec.level == 0 && seclevel.device_override &&\r\n!dev->dev.seclevel_exempt)) {\r\nerr = -EINVAL;\r\ngoto fail_dev;\r\n}\r\nframe_ctr = le32_to_cpu(hdr.sec.frame_counter);\r\nif (frame_ctr == 0xffffffff) {\r\nerr = -EOVERFLOW;\r\ngoto fail_dev;\r\n}\r\nerr = llsec_update_devkey_info(dev, &key_id, frame_ctr);\r\nif (err)\r\ngoto fail_dev;\r\ndev_addr = dev->dev.hwaddr;\r\nrcu_read_unlock();\r\nerr = llsec_do_decrypt(skb, sec, &hdr, key, dev_addr);\r\nllsec_key_put(key);\r\nreturn err;\r\nfail_dev:\r\nllsec_key_put(key);\r\nfail:\r\nrcu_read_unlock();\r\nreturn err;\r\n}
