void dt_txn_callback_add(struct dt_device *dev, struct dt_txn_callback *cb)\r\n{\r\nlist_add(&cb->dtc_linkage, &dev->dd_txn_callbacks);\r\n}\r\nvoid dt_txn_callback_del(struct dt_device *dev, struct dt_txn_callback *cb)\r\n{\r\nlist_del_init(&cb->dtc_linkage);\r\n}\r\nint dt_txn_hook_start(const struct lu_env *env,\r\nstruct dt_device *dev, struct thandle *th)\r\n{\r\nint rc = 0;\r\nstruct dt_txn_callback *cb;\r\nif (th->th_local)\r\nreturn 0;\r\nlist_for_each_entry(cb, &dev->dd_txn_callbacks, dtc_linkage) {\r\nif (cb->dtc_txn_start == NULL ||\r\n!(cb->dtc_tag & env->le_ctx.lc_tags))\r\ncontinue;\r\nrc = cb->dtc_txn_start(env, th, cb->dtc_cookie);\r\nif (rc < 0)\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nint dt_txn_hook_stop(const struct lu_env *env, struct thandle *txn)\r\n{\r\nstruct dt_device *dev = txn->th_dev;\r\nstruct dt_txn_callback *cb;\r\nint rc = 0;\r\nif (txn->th_local)\r\nreturn 0;\r\nlist_for_each_entry(cb, &dev->dd_txn_callbacks, dtc_linkage) {\r\nif (cb->dtc_txn_stop == NULL ||\r\n!(cb->dtc_tag & env->le_ctx.lc_tags))\r\ncontinue;\r\nrc = cb->dtc_txn_stop(env, txn, cb->dtc_cookie);\r\nif (rc < 0)\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nvoid dt_txn_hook_commit(struct thandle *txn)\r\n{\r\nstruct dt_txn_callback *cb;\r\nif (txn->th_local)\r\nreturn;\r\nlist_for_each_entry(cb, &txn->th_dev->dd_txn_callbacks,\r\ndtc_linkage) {\r\nif (cb->dtc_txn_commit)\r\ncb->dtc_txn_commit(txn, cb->dtc_cookie);\r\n}\r\n}\r\nint dt_device_init(struct dt_device *dev, struct lu_device_type *t)\r\n{\r\nINIT_LIST_HEAD(&dev->dd_txn_callbacks);\r\nreturn lu_device_init(&dev->dd_lu_dev, t);\r\n}\r\nvoid dt_device_fini(struct dt_device *dev)\r\n{\r\nlu_device_fini(&dev->dd_lu_dev);\r\n}\r\nint dt_object_init(struct dt_object *obj,\r\nstruct lu_object_header *h, struct lu_device *d)\r\n{\r\nreturn lu_object_init(&obj->do_lu, h, d);\r\n}\r\nvoid dt_object_fini(struct dt_object *obj)\r\n{\r\nlu_object_fini(&obj->do_lu);\r\n}\r\nint dt_try_as_dir(const struct lu_env *env, struct dt_object *obj)\r\n{\r\nif (obj->do_index_ops == NULL)\r\nobj->do_ops->do_index_try(env, obj, &dt_directory_features);\r\nreturn obj->do_index_ops != NULL;\r\n}\r\nenum dt_format_type dt_mode_to_dft(__u32 mode)\r\n{\r\nenum dt_format_type result;\r\nswitch (mode & S_IFMT) {\r\ncase S_IFDIR:\r\nresult = DFT_DIR;\r\nbreak;\r\ncase S_IFREG:\r\nresult = DFT_REGULAR;\r\nbreak;\r\ncase S_IFLNK:\r\nresult = DFT_SYM;\r\nbreak;\r\ncase S_IFCHR:\r\ncase S_IFBLK:\r\ncase S_IFIFO:\r\ncase S_IFSOCK:\r\nresult = DFT_NODE;\r\nbreak;\r\ndefault:\r\nLBUG();\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nint dt_lookup_dir(const struct lu_env *env, struct dt_object *dir,\r\nconst char *name, struct lu_fid *fid)\r\n{\r\nif (dt_try_as_dir(env, dir))\r\nreturn dt_lookup(env, dir, (struct dt_rec *)fid,\r\n(const struct dt_key *)name, BYPASS_CAPA);\r\nreturn -ENOTDIR;\r\n}\r\nstruct dt_object *dt_locate_at(const struct lu_env *env,\r\nstruct dt_device *dev, const struct lu_fid *fid,\r\nstruct lu_device *top_dev)\r\n{\r\nstruct lu_object *lo, *n;\r\nlo = lu_object_find_at(env, top_dev, fid, NULL);\r\nif (IS_ERR(lo))\r\nreturn (void *)lo;\r\nLASSERT(lo != NULL);\r\nlist_for_each_entry(n, &lo->lo_header->loh_layers, lo_linkage) {\r\nif (n->lo_dev == &dev->dd_lu_dev)\r\nreturn container_of0(n, struct dt_object, do_lu);\r\n}\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nstatic int dt_find_entry(const struct lu_env *env, const char *entry, void *data)\r\n{\r\nstruct dt_find_hint *dfh = data;\r\nstruct dt_device *dt = dfh->dfh_dt;\r\nstruct lu_fid *fid = dfh->dfh_fid;\r\nstruct dt_object *obj = dfh->dfh_o;\r\nint result;\r\nresult = dt_lookup_dir(env, obj, entry, fid);\r\nlu_object_put(env, &obj->do_lu);\r\nif (result == 0) {\r\nobj = dt_locate(env, dt, fid);\r\nif (IS_ERR(obj))\r\nresult = PTR_ERR(obj);\r\n}\r\ndfh->dfh_o = obj;\r\nreturn result;\r\n}\r\nint dt_path_parser(const struct lu_env *env,\r\nchar *path, dt_entry_func_t entry_func,\r\nvoid *data)\r\n{\r\nchar *e;\r\nint rc = 0;\r\nwhile (1) {\r\ne = strsep(&path, "/");\r\nif (e == NULL)\r\nbreak;\r\nif (e[0] == 0) {\r\nif (!path || path[0] == '\0')\r\nbreak;\r\ncontinue;\r\n}\r\nrc = entry_func(env, e, data);\r\nif (rc)\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstruct dt_object *\r\ndt_store_resolve(const struct lu_env *env, struct dt_device *dt,\r\nconst char *path, struct lu_fid *fid)\r\n{\r\nstruct dt_thread_info *info = dt_info(env);\r\nstruct dt_find_hint *dfh = &info->dti_dfh;\r\nstruct dt_object *obj;\r\nchar *local = info->dti_buf;\r\nint result;\r\ndfh->dfh_dt = dt;\r\ndfh->dfh_fid = fid;\r\nstrncpy(local, path, DT_MAX_PATH);\r\nlocal[DT_MAX_PATH - 1] = '\0';\r\nresult = dt->dd_ops->dt_root_get(env, dt, fid);\r\nif (result == 0) {\r\nobj = dt_locate(env, dt, fid);\r\nif (!IS_ERR(obj)) {\r\ndfh->dfh_o = obj;\r\nresult = dt_path_parser(env, local, dt_find_entry, dfh);\r\nif (result != 0)\r\nobj = ERR_PTR(result);\r\nelse\r\nobj = dfh->dfh_o;\r\n}\r\n} else {\r\nobj = ERR_PTR(result);\r\n}\r\nreturn obj;\r\n}\r\nstatic struct dt_object *dt_reg_open(const struct lu_env *env,\r\nstruct dt_device *dt,\r\nstruct dt_object *p,\r\nconst char *name,\r\nstruct lu_fid *fid)\r\n{\r\nstruct dt_object *o;\r\nint result;\r\nresult = dt_lookup_dir(env, p, name, fid);\r\nif (result == 0){\r\no = dt_locate(env, dt, fid);\r\n} else\r\no = ERR_PTR(result);\r\nreturn o;\r\n}\r\nstruct dt_object *dt_store_open(const struct lu_env *env,\r\nstruct dt_device *dt,\r\nconst char *dirname,\r\nconst char *filename,\r\nstruct lu_fid *fid)\r\n{\r\nstruct dt_object *file;\r\nstruct dt_object *dir;\r\ndir = dt_store_resolve(env, dt, dirname, fid);\r\nif (!IS_ERR(dir)) {\r\nfile = dt_reg_open(env, dt, dir,\r\nfilename, fid);\r\nlu_object_put(env, &dir->do_lu);\r\n} else {\r\nfile = dir;\r\n}\r\nreturn file;\r\n}\r\nstruct dt_object *dt_find_or_create(const struct lu_env *env,\r\nstruct dt_device *dt,\r\nconst struct lu_fid *fid,\r\nstruct dt_object_format *dof,\r\nstruct lu_attr *at)\r\n{\r\nstruct dt_object *dto;\r\nstruct thandle *th;\r\nint rc;\r\ndto = dt_locate(env, dt, fid);\r\nif (IS_ERR(dto))\r\nreturn dto;\r\nLASSERT(dto != NULL);\r\nif (dt_object_exists(dto))\r\nreturn dto;\r\nth = dt_trans_create(env, dt);\r\nif (IS_ERR(th)) {\r\nrc = PTR_ERR(th);\r\ngoto out;\r\n}\r\nrc = dt_declare_create(env, dto, at, NULL, dof, th);\r\nif (rc)\r\ngoto trans_stop;\r\nrc = dt_trans_start_local(env, dt, th);\r\nif (rc)\r\ngoto trans_stop;\r\ndt_write_lock(env, dto, 0);\r\nif (dt_object_exists(dto)) {\r\nrc = 0;\r\ngoto unlock;\r\n}\r\nCDEBUG(D_OTHER, "create new object "DFID"\n", PFID(fid));\r\nrc = dt_create(env, dto, at, NULL, dof, th);\r\nif (rc)\r\ngoto unlock;\r\nLASSERT(dt_object_exists(dto));\r\nunlock:\r\ndt_write_unlock(env, dto);\r\ntrans_stop:\r\ndt_trans_stop(env, dt, th);\r\nout:\r\nif (rc) {\r\nlu_object_put(env, &dto->do_lu);\r\nreturn ERR_PTR(rc);\r\n}\r\nreturn dto;\r\n}\r\nint dt_global_init(void)\r\n{\r\nint result;\r\nLU_CONTEXT_KEY_INIT(&dt_key);\r\nresult = lu_context_key_register(&dt_key);\r\nreturn result;\r\n}\r\nvoid dt_global_fini(void)\r\n{\r\nlu_context_key_degister(&dt_key);\r\n}\r\nint dt_read(const struct lu_env *env, struct dt_object *dt,\r\nstruct lu_buf *buf, loff_t *pos)\r\n{\r\nLASSERTF(dt != NULL, "dt is NULL when we want to read record\n");\r\nreturn dt->do_body_ops->dbo_read(env, dt, buf, pos, BYPASS_CAPA);\r\n}\r\nint dt_record_read(const struct lu_env *env, struct dt_object *dt,\r\nstruct lu_buf *buf, loff_t *pos)\r\n{\r\nint rc;\r\nLASSERTF(dt != NULL, "dt is NULL when we want to read record\n");\r\nrc = dt->do_body_ops->dbo_read(env, dt, buf, pos, BYPASS_CAPA);\r\nif (rc == buf->lb_len)\r\nrc = 0;\r\nelse if (rc >= 0)\r\nrc = -EFAULT;\r\nreturn rc;\r\n}\r\nint dt_record_write(const struct lu_env *env, struct dt_object *dt,\r\nconst struct lu_buf *buf, loff_t *pos, struct thandle *th)\r\n{\r\nint rc;\r\nLASSERTF(dt != NULL, "dt is NULL when we want to write record\n");\r\nLASSERT(th != NULL);\r\nLASSERT(dt->do_body_ops);\r\nLASSERT(dt->do_body_ops->dbo_write);\r\nrc = dt->do_body_ops->dbo_write(env, dt, buf, pos, th, BYPASS_CAPA, 1);\r\nif (rc == buf->lb_len)\r\nrc = 0;\r\nelse if (rc >= 0)\r\nrc = -EFAULT;\r\nreturn rc;\r\n}\r\nint dt_declare_version_set(const struct lu_env *env, struct dt_object *o,\r\nstruct thandle *th)\r\n{\r\nstruct lu_buf vbuf;\r\nchar *xname = XATTR_NAME_VERSION;\r\nLASSERT(o);\r\nvbuf.lb_buf = NULL;\r\nvbuf.lb_len = sizeof(dt_obj_version_t);\r\nreturn dt_declare_xattr_set(env, o, &vbuf, xname, 0, th);\r\n}\r\nvoid dt_version_set(const struct lu_env *env, struct dt_object *o,\r\ndt_obj_version_t version, struct thandle *th)\r\n{\r\nstruct lu_buf vbuf;\r\nchar *xname = XATTR_NAME_VERSION;\r\nint rc;\r\nLASSERT(o);\r\nvbuf.lb_buf = &version;\r\nvbuf.lb_len = sizeof(version);\r\nrc = dt_xattr_set(env, o, &vbuf, xname, 0, th, BYPASS_CAPA);\r\nif (rc < 0)\r\nCDEBUG(D_INODE, "Can't set version, rc %d\n", rc);\r\nreturn;\r\n}\r\ndt_obj_version_t dt_version_get(const struct lu_env *env, struct dt_object *o)\r\n{\r\nstruct lu_buf vbuf;\r\nchar *xname = XATTR_NAME_VERSION;\r\ndt_obj_version_t version;\r\nint rc;\r\nLASSERT(o);\r\nvbuf.lb_buf = &version;\r\nvbuf.lb_len = sizeof(version);\r\nrc = dt_xattr_get(env, o, &vbuf, xname, BYPASS_CAPA);\r\nif (rc != sizeof(version)) {\r\nCDEBUG(D_INODE, "Can't get version, rc %d\n", rc);\r\nversion = 0;\r\n}\r\nreturn version;\r\n}\r\nstatic inline const struct dt_index_features *dt_index_feat_select(__u64 seq,\r\n__u32 mode)\r\n{\r\nif (seq == FID_SEQ_QUOTA_GLB) {\r\nif (!S_ISREG(mode))\r\nreturn ERR_PTR(-ENOENT);\r\nreturn &dt_quota_glb_features;\r\n} else if (seq == FID_SEQ_QUOTA) {\r\nif (!S_ISREG(mode))\r\nreturn ERR_PTR(-ENOENT);\r\nreturn &dt_quota_slv_features;\r\n} else if (seq >= FID_SEQ_NORMAL) {\r\nif (!S_ISDIR(mode))\r\nreturn ERR_PTR(-ENOTDIR);\r\nreturn &dt_directory_features;\r\n}\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\n}\r\nstatic int dt_index_page_build(const struct lu_env *env, union lu_page *lp,\r\nint nob, const struct dt_it_ops *iops,\r\nstruct dt_it *it, __u32 attr, void *arg)\r\n{\r\nstruct idx_info *ii = (struct idx_info *)arg;\r\nstruct lu_idxpage *lip = &lp->lp_idx;\r\nchar *entry;\r\nint rc, size;\r\nLASSERT((ii->ii_flags & II_FL_VARKEY) == 0);\r\nLASSERT((ii->ii_flags & II_FL_VARREC) == 0);\r\nmemset(lip, 0, LIP_HDR_SIZE);\r\nlip->lip_magic = LIP_MAGIC;\r\nnob -= LIP_HDR_SIZE;\r\nsize = ii->ii_recsize + ii->ii_keysize;\r\nif ((ii->ii_flags & II_FL_NOHASH) == 0)\r\nsize += sizeof(__u64);\r\nentry = lip->lip_entries;\r\ndo {\r\nchar *tmp_entry = entry;\r\nstruct dt_key *key;\r\n__u64 hash;\r\nhash = iops->store(env, it);\r\nii->ii_hash_end = hash;\r\nif (OBD_FAIL_CHECK(OBD_FAIL_OBD_IDX_READ_BREAK)) {\r\nif (lip->lip_nr != 0) {\r\nrc = 0;\r\ngoto out;\r\n}\r\n}\r\nif (nob < size) {\r\nif (lip->lip_nr == 0)\r\nrc = -EINVAL;\r\nelse\r\nrc = 0;\r\ngoto out;\r\n}\r\nif ((ii->ii_flags & II_FL_NOHASH) == 0) {\r\nmemcpy(tmp_entry, &hash, sizeof(hash));\r\ntmp_entry += sizeof(hash);\r\n}\r\nLASSERT(iops->key_size(env, it) == ii->ii_keysize);\r\nkey = iops->key(env, it);\r\nmemcpy(tmp_entry, key, ii->ii_keysize);\r\ntmp_entry += ii->ii_keysize;\r\nrc = iops->rec(env, it, (struct dt_rec *)tmp_entry, attr);\r\nif (rc != -ESTALE) {\r\nif (rc != 0)\r\ngoto out;\r\nlip->lip_nr++;\r\nif (unlikely(lip->lip_nr == 1 && ii->ii_count == 0))\r\nii->ii_hash_start = hash;\r\nentry = tmp_entry + ii->ii_recsize;\r\nnob -= size;\r\n}\r\ndo {\r\nrc = iops->next(env, it);\r\n} while (rc == -ESTALE);\r\n} while (rc == 0);\r\ngoto out;\r\nout:\r\nif (rc >= 0 && lip->lip_nr > 0)\r\nii->ii_count++;\r\nif (rc > 0)\r\nii->ii_hash_end = II_END_OFF;\r\nreturn rc;\r\n}\r\nint dt_index_walk(const struct lu_env *env, struct dt_object *obj,\r\nconst struct lu_rdpg *rdpg, dt_index_page_build_t filler,\r\nvoid *arg)\r\n{\r\nstruct dt_it *it;\r\nconst struct dt_it_ops *iops;\r\nunsigned int pageidx, nob, nlupgs = 0;\r\nint rc;\r\nLASSERT(rdpg->rp_pages != NULL);\r\nLASSERT(obj->do_index_ops != NULL);\r\nnob = rdpg->rp_count;\r\nif (nob <= 0)\r\nreturn -EFAULT;\r\niops = &obj->do_index_ops->dio_it;\r\nLASSERT(iops != NULL);\r\nit = iops->init(env, obj, rdpg->rp_attrs, BYPASS_CAPA);\r\nif (IS_ERR(it))\r\nreturn PTR_ERR(it);\r\nrc = iops->load(env, it, rdpg->rp_hash);\r\nif (rc == 0) {\r\nrc = iops->next(env, it);\r\n} else if (rc > 0) {\r\nrc = 0;\r\n}\r\nfor (pageidx = 0; rc == 0 && nob > 0; pageidx++) {\r\nunion lu_page *lp;\r\nint i;\r\nLASSERT(pageidx < rdpg->rp_npages);\r\nlp = kmap(rdpg->rp_pages[pageidx]);\r\nfor (i = 0; i < LU_PAGE_COUNT; i++, lp++, nob -= LU_PAGE_SIZE) {\r\nrc = filler(env, lp, min_t(int, nob, LU_PAGE_SIZE),\r\niops, it, rdpg->rp_attrs, arg);\r\nif (rc < 0)\r\nbreak;\r\nnlupgs++;\r\nif (rc > 0)\r\nbreak;\r\n}\r\nkunmap(rdpg->rp_pages[i]);\r\n}\r\niops->put(env, it);\r\niops->fini(env, it);\r\nif (rc >= 0)\r\nrc = min_t(unsigned int, nlupgs * LU_PAGE_SIZE, rdpg->rp_count);\r\nreturn rc;\r\n}\r\nint dt_index_read(const struct lu_env *env, struct dt_device *dev,\r\nstruct idx_info *ii, const struct lu_rdpg *rdpg)\r\n{\r\nconst struct dt_index_features *feat;\r\nstruct dt_object *obj;\r\nint rc;\r\nif (rdpg->rp_count <= 0 && (rdpg->rp_count & (LU_PAGE_SIZE - 1)) != 0)\r\nreturn -EFAULT;\r\nif (fid_seq(&ii->ii_fid) >= FID_SEQ_NORMAL)\r\nreturn -EOPNOTSUPP;\r\nif (!fid_is_quota(&ii->ii_fid))\r\nreturn -EPERM;\r\nobj = dt_locate(env, dev, &ii->ii_fid);\r\nif (IS_ERR(obj))\r\nreturn PTR_ERR(obj);\r\nif (dt_object_exists(obj) == 0) {\r\nrc = -ENOENT;\r\ngoto out;\r\n}\r\nfeat = dt_index_feat_select(fid_seq(&ii->ii_fid),\r\nlu_object_attr(&obj->do_lu));\r\nif (IS_ERR(feat)) {\r\nrc = PTR_ERR(feat);\r\ngoto out;\r\n}\r\nif (obj->do_index_ops == NULL) {\r\nrc = obj->do_ops->do_index_try(env, obj, feat);\r\nif (rc)\r\ngoto out;\r\n}\r\nii->ii_flags &= II_FL_NOHASH;\r\nii->ii_keysize = feat->dif_keysize_max;\r\nif ((feat->dif_flags & DT_IND_VARKEY) != 0) {\r\nii->ii_flags |= II_FL_VARKEY;\r\nrc = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nii->ii_recsize = feat->dif_recsize_max;\r\nif ((feat->dif_flags & DT_IND_VARREC) != 0) {\r\nii->ii_flags |= II_FL_VARREC;\r\nrc = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif ((feat->dif_flags & DT_IND_NONUNQ) != 0)\r\nii->ii_flags |= II_FL_NONUNQ;\r\ndt_read_lock(env, obj, 0);\r\nii->ii_version = dt_version_get(env, obj);\r\nrc = dt_index_walk(env, obj, rdpg, dt_index_page_build ,ii);\r\ndt_read_unlock(env, obj);\r\nif (rc == 0) {\r\nLASSERT(ii->ii_count == 0);\r\nii->ii_hash_end = II_END_OFF;\r\n}\r\ngoto out;\r\nout:\r\nlu_object_put(env, &obj->do_lu);\r\nreturn rc;\r\n}\r\nint lprocfs_dt_rd_blksize(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nstruct dt_device *dt = data;\r\nstruct obd_statfs osfs;\r\nint rc = dt_statfs(NULL, dt, &osfs);\r\nif (rc == 0) {\r\n*eof = 1;\r\nrc = snprintf(page, count, "%u\n",\r\n(unsigned) osfs.os_bsize);\r\n}\r\nreturn rc;\r\n}\r\nint lprocfs_dt_rd_kbytestotal(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nstruct dt_device *dt = data;\r\nstruct obd_statfs osfs;\r\nint rc = dt_statfs(NULL, dt, &osfs);\r\nif (rc == 0) {\r\n__u32 blk_size = osfs.os_bsize >> 10;\r\n__u64 result = osfs.os_blocks;\r\nwhile (blk_size >>= 1)\r\nresult <<= 1;\r\n*eof = 1;\r\nrc = snprintf(page, count, "%llu\n", result);\r\n}\r\nreturn rc;\r\n}\r\nint lprocfs_dt_rd_kbytesfree(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nstruct dt_device *dt = data;\r\nstruct obd_statfs osfs;\r\nint rc = dt_statfs(NULL, dt, &osfs);\r\nif (rc == 0) {\r\n__u32 blk_size = osfs.os_bsize >> 10;\r\n__u64 result = osfs.os_bfree;\r\nwhile (blk_size >>= 1)\r\nresult <<= 1;\r\n*eof = 1;\r\nrc = snprintf(page, count, "%llu\n", result);\r\n}\r\nreturn rc;\r\n}\r\nint lprocfs_dt_rd_kbytesavail(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nstruct dt_device *dt = data;\r\nstruct obd_statfs osfs;\r\nint rc = dt_statfs(NULL, dt, &osfs);\r\nif (rc == 0) {\r\n__u32 blk_size = osfs.os_bsize >> 10;\r\n__u64 result = osfs.os_bavail;\r\nwhile (blk_size >>= 1)\r\nresult <<= 1;\r\n*eof = 1;\r\nrc = snprintf(page, count, "%llu\n", result);\r\n}\r\nreturn rc;\r\n}\r\nint lprocfs_dt_rd_filestotal(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nstruct dt_device *dt = data;\r\nstruct obd_statfs osfs;\r\nint rc = dt_statfs(NULL, dt, &osfs);\r\nif (rc == 0) {\r\n*eof = 1;\r\nrc = snprintf(page, count, "%llu\n", osfs.os_files);\r\n}\r\nreturn rc;\r\n}\r\nint lprocfs_dt_rd_filesfree(char *page, char **start, off_t off,\r\nint count, int *eof, void *data)\r\n{\r\nstruct dt_device *dt = data;\r\nstruct obd_statfs osfs;\r\nint rc = dt_statfs(NULL, dt, &osfs);\r\nif (rc == 0) {\r\n*eof = 1;\r\nrc = snprintf(page, count, "%llu\n", osfs.os_ffree);\r\n}\r\nreturn rc;\r\n}
