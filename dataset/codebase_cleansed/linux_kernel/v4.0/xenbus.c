static int xenvif_read_io_ring(struct seq_file *m, void *v)\r\n{\r\nstruct xenvif_queue *queue = m->private;\r\nstruct xen_netif_tx_back_ring *tx_ring = &queue->tx;\r\nstruct xen_netif_rx_back_ring *rx_ring = &queue->rx;\r\nstruct netdev_queue *dev_queue;\r\nif (tx_ring->sring) {\r\nstruct xen_netif_tx_sring *sring = tx_ring->sring;\r\nseq_printf(m, "Queue %d\nTX: nr_ents %u\n", queue->id,\r\ntx_ring->nr_ents);\r\nseq_printf(m, "req prod %u (%d) cons %u (%d) event %u (%d)\n",\r\nsring->req_prod,\r\nsring->req_prod - sring->rsp_prod,\r\ntx_ring->req_cons,\r\ntx_ring->req_cons - sring->rsp_prod,\r\nsring->req_event,\r\nsring->req_event - sring->rsp_prod);\r\nseq_printf(m, "rsp prod %u (base) pvt %u (%d) event %u (%d)\n",\r\nsring->rsp_prod,\r\ntx_ring->rsp_prod_pvt,\r\ntx_ring->rsp_prod_pvt - sring->rsp_prod,\r\nsring->rsp_event,\r\nsring->rsp_event - sring->rsp_prod);\r\nseq_printf(m, "pending prod %u pending cons %u nr_pending_reqs %u\n",\r\nqueue->pending_prod,\r\nqueue->pending_cons,\r\nnr_pending_reqs(queue));\r\nseq_printf(m, "dealloc prod %u dealloc cons %u dealloc_queue %u\n\n",\r\nqueue->dealloc_prod,\r\nqueue->dealloc_cons,\r\nqueue->dealloc_prod - queue->dealloc_cons);\r\n}\r\nif (rx_ring->sring) {\r\nstruct xen_netif_rx_sring *sring = rx_ring->sring;\r\nseq_printf(m, "RX: nr_ents %u\n", rx_ring->nr_ents);\r\nseq_printf(m, "req prod %u (%d) cons %u (%d) event %u (%d)\n",\r\nsring->req_prod,\r\nsring->req_prod - sring->rsp_prod,\r\nrx_ring->req_cons,\r\nrx_ring->req_cons - sring->rsp_prod,\r\nsring->req_event,\r\nsring->req_event - sring->rsp_prod);\r\nseq_printf(m, "rsp prod %u (base) pvt %u (%d) event %u (%d)\n\n",\r\nsring->rsp_prod,\r\nrx_ring->rsp_prod_pvt,\r\nrx_ring->rsp_prod_pvt - sring->rsp_prod,\r\nsring->rsp_event,\r\nsring->rsp_event - sring->rsp_prod);\r\n}\r\nseq_printf(m, "NAPI state: %lx NAPI weight: %d TX queue len %u\n"\r\n"Credit timer_pending: %d, credit: %lu, usec: %lu\n"\r\n"remaining: %lu, expires: %lu, now: %lu\n",\r\nqueue->napi.state, queue->napi.weight,\r\nskb_queue_len(&queue->tx_queue),\r\ntimer_pending(&queue->credit_timeout),\r\nqueue->credit_bytes,\r\nqueue->credit_usec,\r\nqueue->remaining_credit,\r\nqueue->credit_timeout.expires,\r\njiffies);\r\ndev_queue = netdev_get_tx_queue(queue->vif->dev, queue->id);\r\nseq_printf(m, "\nRx internal queue: len %u max %u pkts %u %s\n",\r\nqueue->rx_queue_len, queue->rx_queue_max,\r\nskb_queue_len(&queue->rx_queue),\r\nnetif_tx_queue_stopped(dev_queue) ? "stopped" : "running");\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nxenvif_write_io_ring(struct file *filp, const char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct xenvif_queue *queue =\r\n((struct seq_file *)filp->private_data)->private;\r\nint len;\r\nchar write[BUFFER_SIZE];\r\nif (*ppos != 0)\r\nreturn 0;\r\nif (count >= sizeof(write))\r\nreturn -ENOSPC;\r\nlen = simple_write_to_buffer(write,\r\nsizeof(write) - 1,\r\nppos,\r\nbuf,\r\ncount);\r\nif (len < 0)\r\nreturn len;\r\nwrite[len] = '\0';\r\nif (!strncmp(write, XENVIF_KICK_STR, sizeof(XENVIF_KICK_STR) - 1))\r\nxenvif_interrupt(0, (void *)queue);\r\nelse {\r\npr_warn("Unknown command to io_ring_q%d. Available: kick\n",\r\nqueue->id);\r\ncount = -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic int xenvif_dump_open(struct inode *inode, struct file *filp)\r\n{\r\nint ret;\r\nvoid *queue = NULL;\r\nif (inode->i_private)\r\nqueue = inode->i_private;\r\nret = single_open(filp, xenvif_read_io_ring, queue);\r\nfilp->f_mode |= FMODE_PWRITE;\r\nreturn ret;\r\n}\r\nstatic void xenvif_debugfs_addif(struct xenvif *vif)\r\n{\r\nstruct dentry *pfile;\r\nint i;\r\nif (IS_ERR_OR_NULL(xen_netback_dbg_root))\r\nreturn;\r\nvif->xenvif_dbg_root = debugfs_create_dir(vif->dev->name,\r\nxen_netback_dbg_root);\r\nif (!IS_ERR_OR_NULL(vif->xenvif_dbg_root)) {\r\nfor (i = 0; i < vif->num_queues; ++i) {\r\nchar filename[sizeof("io_ring_q") + 4];\r\nsnprintf(filename, sizeof(filename), "io_ring_q%d", i);\r\npfile = debugfs_create_file(filename,\r\nS_IRUSR | S_IWUSR,\r\nvif->xenvif_dbg_root,\r\n&vif->queues[i],\r\n&xenvif_dbg_io_ring_ops_fops);\r\nif (IS_ERR_OR_NULL(pfile))\r\npr_warn("Creation of io_ring file returned %ld!\n",\r\nPTR_ERR(pfile));\r\n}\r\n} else\r\nnetdev_warn(vif->dev,\r\n"Creation of vif debugfs dir returned %ld!\n",\r\nPTR_ERR(vif->xenvif_dbg_root));\r\n}\r\nstatic void xenvif_debugfs_delif(struct xenvif *vif)\r\n{\r\nif (IS_ERR_OR_NULL(xen_netback_dbg_root))\r\nreturn;\r\nif (!IS_ERR_OR_NULL(vif->xenvif_dbg_root))\r\ndebugfs_remove_recursive(vif->xenvif_dbg_root);\r\nvif->xenvif_dbg_root = NULL;\r\n}\r\nstatic int netback_remove(struct xenbus_device *dev)\r\n{\r\nstruct backend_info *be = dev_get_drvdata(&dev->dev);\r\nset_backend_state(be, XenbusStateClosed);\r\nunregister_hotplug_status_watch(be);\r\nif (be->vif) {\r\nkobject_uevent(&dev->dev.kobj, KOBJ_OFFLINE);\r\nxenbus_rm(XBT_NIL, dev->nodename, "hotplug-status");\r\nxenvif_free(be->vif);\r\nbe->vif = NULL;\r\n}\r\nkfree(be);\r\ndev_set_drvdata(&dev->dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int netback_probe(struct xenbus_device *dev,\r\nconst struct xenbus_device_id *id)\r\n{\r\nconst char *message;\r\nstruct xenbus_transaction xbt;\r\nint err;\r\nint sg;\r\nstruct backend_info *be = kzalloc(sizeof(struct backend_info),\r\nGFP_KERNEL);\r\nif (!be) {\r\nxenbus_dev_fatal(dev, -ENOMEM,\r\n"allocating backend structure");\r\nreturn -ENOMEM;\r\n}\r\nbe->dev = dev;\r\ndev_set_drvdata(&dev->dev, be);\r\nsg = 1;\r\ndo {\r\nerr = xenbus_transaction_start(&xbt);\r\nif (err) {\r\nxenbus_dev_fatal(dev, err, "starting transaction");\r\ngoto fail;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename, "feature-sg", "%d", sg);\r\nif (err) {\r\nmessage = "writing feature-sg";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename, "feature-gso-tcpv4",\r\n"%d", sg);\r\nif (err) {\r\nmessage = "writing feature-gso-tcpv4";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename, "feature-gso-tcpv6",\r\n"%d", sg);\r\nif (err) {\r\nmessage = "writing feature-gso-tcpv6";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename,\r\n"feature-ipv6-csum-offload",\r\n"%d", 1);\r\nif (err) {\r\nmessage = "writing feature-ipv6-csum-offload";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename,\r\n"feature-rx-copy", "%d", 1);\r\nif (err) {\r\nmessage = "writing feature-rx-copy";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_printf(xbt, dev->nodename,\r\n"feature-rx-flip", "%d", 0);\r\nif (err) {\r\nmessage = "writing feature-rx-flip";\r\ngoto abort_transaction;\r\n}\r\nerr = xenbus_transaction_end(xbt, 0);\r\n} while (err == -EAGAIN);\r\nif (err) {\r\nxenbus_dev_fatal(dev, err, "completing transaction");\r\ngoto fail;\r\n}\r\nerr = xenbus_printf(XBT_NIL, dev->nodename,\r\n"feature-split-event-channels",\r\n"%u", separate_tx_rx_irq);\r\nif (err)\r\npr_debug("Error writing feature-split-event-channels\n");\r\nerr = xenbus_printf(XBT_NIL, dev->nodename,\r\n"multi-queue-max-queues", "%u", xenvif_max_queues);\r\nif (err)\r\npr_debug("Error writing multi-queue-max-queues\n");\r\nerr = xenbus_switch_state(dev, XenbusStateInitWait);\r\nif (err)\r\ngoto fail;\r\nbe->state = XenbusStateInitWait;\r\nerr = backend_create_xenvif(be);\r\nif (err)\r\ngoto fail;\r\nreturn 0;\r\nabort_transaction:\r\nxenbus_transaction_end(xbt, 1);\r\nxenbus_dev_fatal(dev, err, "%s", message);\r\nfail:\r\npr_debug("failed\n");\r\nnetback_remove(dev);\r\nreturn err;\r\n}\r\nstatic int netback_uevent(struct xenbus_device *xdev,\r\nstruct kobj_uevent_env *env)\r\n{\r\nstruct backend_info *be = dev_get_drvdata(&xdev->dev);\r\nchar *val;\r\nval = xenbus_read(XBT_NIL, xdev->nodename, "script", NULL);\r\nif (IS_ERR(val)) {\r\nint err = PTR_ERR(val);\r\nxenbus_dev_fatal(xdev, err, "reading script");\r\nreturn err;\r\n} else {\r\nif (add_uevent_var(env, "script=%s", val)) {\r\nkfree(val);\r\nreturn -ENOMEM;\r\n}\r\nkfree(val);\r\n}\r\nif (!be || !be->vif)\r\nreturn 0;\r\nreturn add_uevent_var(env, "vif=%s", be->vif->dev->name);\r\n}\r\nstatic int backend_create_xenvif(struct backend_info *be)\r\n{\r\nint err;\r\nlong handle;\r\nstruct xenbus_device *dev = be->dev;\r\nstruct xenvif *vif;\r\nif (be->vif != NULL)\r\nreturn 0;\r\nerr = xenbus_scanf(XBT_NIL, dev->nodename, "handle", "%li", &handle);\r\nif (err != 1) {\r\nxenbus_dev_fatal(dev, err, "reading handle");\r\nreturn (err < 0) ? err : -EINVAL;\r\n}\r\nvif = xenvif_alloc(&dev->dev, dev->otherend_id, handle);\r\nif (IS_ERR(vif)) {\r\nerr = PTR_ERR(vif);\r\nxenbus_dev_fatal(dev, err, "creating interface");\r\nreturn err;\r\n}\r\nbe->vif = vif;\r\nkobject_uevent(&dev->dev.kobj, KOBJ_ONLINE);\r\nreturn 0;\r\n}\r\nstatic void backend_disconnect(struct backend_info *be)\r\n{\r\nif (be->vif) {\r\n#ifdef CONFIG_DEBUG_FS\r\nxenvif_debugfs_delif(be->vif);\r\n#endif\r\nxenvif_disconnect(be->vif);\r\n}\r\n}\r\nstatic void backend_connect(struct backend_info *be)\r\n{\r\nif (be->vif)\r\nconnect(be);\r\n}\r\nstatic inline void backend_switch_state(struct backend_info *be,\r\nenum xenbus_state state)\r\n{\r\nstruct xenbus_device *dev = be->dev;\r\npr_debug("%s -> %s\n", dev->nodename, xenbus_strstate(state));\r\nbe->state = state;\r\nif (!be->have_hotplug_status_watch)\r\nxenbus_switch_state(dev, state);\r\n}\r\nstatic void set_backend_state(struct backend_info *be,\r\nenum xenbus_state state)\r\n{\r\nwhile (be->state != state) {\r\nswitch (be->state) {\r\ncase XenbusStateClosed:\r\nswitch (state) {\r\ncase XenbusStateInitWait:\r\ncase XenbusStateConnected:\r\npr_info("%s: prepare for reconnect\n",\r\nbe->dev->nodename);\r\nbackend_switch_state(be, XenbusStateInitWait);\r\nbreak;\r\ncase XenbusStateClosing:\r\nbackend_switch_state(be, XenbusStateClosing);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nbreak;\r\ncase XenbusStateInitWait:\r\nswitch (state) {\r\ncase XenbusStateConnected:\r\nbackend_connect(be);\r\nbackend_switch_state(be, XenbusStateConnected);\r\nbreak;\r\ncase XenbusStateClosing:\r\ncase XenbusStateClosed:\r\nbackend_switch_state(be, XenbusStateClosing);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nbreak;\r\ncase XenbusStateConnected:\r\nswitch (state) {\r\ncase XenbusStateInitWait:\r\ncase XenbusStateClosing:\r\ncase XenbusStateClosed:\r\nbackend_disconnect(be);\r\nbackend_switch_state(be, XenbusStateClosing);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nbreak;\r\ncase XenbusStateClosing:\r\nswitch (state) {\r\ncase XenbusStateInitWait:\r\ncase XenbusStateConnected:\r\ncase XenbusStateClosed:\r\nbackend_switch_state(be, XenbusStateClosed);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\n}\r\nstatic void frontend_changed(struct xenbus_device *dev,\r\nenum xenbus_state frontend_state)\r\n{\r\nstruct backend_info *be = dev_get_drvdata(&dev->dev);\r\npr_debug("%s -> %s\n", dev->otherend, xenbus_strstate(frontend_state));\r\nbe->frontend_state = frontend_state;\r\nswitch (frontend_state) {\r\ncase XenbusStateInitialising:\r\nset_backend_state(be, XenbusStateInitWait);\r\nbreak;\r\ncase XenbusStateInitialised:\r\nbreak;\r\ncase XenbusStateConnected:\r\nset_backend_state(be, XenbusStateConnected);\r\nbreak;\r\ncase XenbusStateClosing:\r\nset_backend_state(be, XenbusStateClosing);\r\nbreak;\r\ncase XenbusStateClosed:\r\nset_backend_state(be, XenbusStateClosed);\r\nif (xenbus_dev_is_online(dev))\r\nbreak;\r\ncase XenbusStateUnknown:\r\nset_backend_state(be, XenbusStateClosed);\r\ndevice_unregister(&dev->dev);\r\nbreak;\r\ndefault:\r\nxenbus_dev_fatal(dev, -EINVAL, "saw state %d at frontend",\r\nfrontend_state);\r\nbreak;\r\n}\r\n}\r\nstatic void xen_net_read_rate(struct xenbus_device *dev,\r\nunsigned long *bytes, unsigned long *usec)\r\n{\r\nchar *s, *e;\r\nunsigned long b, u;\r\nchar *ratestr;\r\n*bytes = ~0UL;\r\n*usec = 0;\r\nratestr = xenbus_read(XBT_NIL, dev->nodename, "rate", NULL);\r\nif (IS_ERR(ratestr))\r\nreturn;\r\ns = ratestr;\r\nb = simple_strtoul(s, &e, 10);\r\nif ((s == e) || (*e != ','))\r\ngoto fail;\r\ns = e + 1;\r\nu = simple_strtoul(s, &e, 10);\r\nif ((s == e) || (*e != '\0'))\r\ngoto fail;\r\n*bytes = b;\r\n*usec = u;\r\nkfree(ratestr);\r\nreturn;\r\nfail:\r\npr_warn("Failed to parse network rate limit. Traffic unlimited.\n");\r\nkfree(ratestr);\r\n}\r\nstatic int xen_net_read_mac(struct xenbus_device *dev, u8 mac[])\r\n{\r\nchar *s, *e, *macstr;\r\nint i;\r\nmacstr = s = xenbus_read(XBT_NIL, dev->nodename, "mac", NULL);\r\nif (IS_ERR(macstr))\r\nreturn PTR_ERR(macstr);\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\nmac[i] = simple_strtoul(s, &e, 16);\r\nif ((s == e) || (*e != ((i == ETH_ALEN-1) ? '\0' : ':'))) {\r\nkfree(macstr);\r\nreturn -ENOENT;\r\n}\r\ns = e+1;\r\n}\r\nkfree(macstr);\r\nreturn 0;\r\n}\r\nstatic void unregister_hotplug_status_watch(struct backend_info *be)\r\n{\r\nif (be->have_hotplug_status_watch) {\r\nunregister_xenbus_watch(&be->hotplug_status_watch);\r\nkfree(be->hotplug_status_watch.node);\r\n}\r\nbe->have_hotplug_status_watch = 0;\r\n}\r\nstatic void hotplug_status_changed(struct xenbus_watch *watch,\r\nconst char **vec,\r\nunsigned int vec_size)\r\n{\r\nstruct backend_info *be = container_of(watch,\r\nstruct backend_info,\r\nhotplug_status_watch);\r\nchar *str;\r\nunsigned int len;\r\nstr = xenbus_read(XBT_NIL, be->dev->nodename, "hotplug-status", &len);\r\nif (IS_ERR(str))\r\nreturn;\r\nif (len == sizeof("connected")-1 && !memcmp(str, "connected", len)) {\r\nxenbus_switch_state(be->dev, be->state);\r\nunregister_hotplug_status_watch(be);\r\n}\r\nkfree(str);\r\n}\r\nstatic void connect(struct backend_info *be)\r\n{\r\nint err;\r\nstruct xenbus_device *dev = be->dev;\r\nunsigned long credit_bytes, credit_usec;\r\nunsigned int queue_index;\r\nunsigned int requested_num_queues;\r\nstruct xenvif_queue *queue;\r\nerr = xenbus_scanf(XBT_NIL, dev->otherend,\r\n"multi-queue-num-queues",\r\n"%u", &requested_num_queues);\r\nif (err < 0) {\r\nrequested_num_queues = 1;\r\n} else if (requested_num_queues > xenvif_max_queues) {\r\nxenbus_dev_fatal(dev, err,\r\n"guest requested %u queues, exceeding the maximum of %u.",\r\nrequested_num_queues, xenvif_max_queues);\r\nreturn;\r\n}\r\nerr = xen_net_read_mac(dev, be->vif->fe_dev_addr);\r\nif (err) {\r\nxenbus_dev_fatal(dev, err, "parsing %s/mac", dev->nodename);\r\nreturn;\r\n}\r\nxen_net_read_rate(dev, &credit_bytes, &credit_usec);\r\nread_xenbus_vif_flags(be);\r\nbe->vif->queues = vzalloc(requested_num_queues *\r\nsizeof(struct xenvif_queue));\r\nbe->vif->num_queues = requested_num_queues;\r\nbe->vif->stalled_queues = requested_num_queues;\r\nfor (queue_index = 0; queue_index < requested_num_queues; ++queue_index) {\r\nqueue = &be->vif->queues[queue_index];\r\nqueue->vif = be->vif;\r\nqueue->id = queue_index;\r\nsnprintf(queue->name, sizeof(queue->name), "%s-q%u",\r\nbe->vif->dev->name, queue->id);\r\nerr = xenvif_init_queue(queue);\r\nif (err) {\r\nbe->vif->num_queues = queue_index;\r\ngoto err;\r\n}\r\nqueue->remaining_credit = credit_bytes;\r\nqueue->credit_usec = credit_usec;\r\nerr = connect_rings(be, queue);\r\nif (err) {\r\nxenvif_deinit_queue(queue);\r\nbe->vif->num_queues = queue_index;\r\ngoto err;\r\n}\r\n}\r\n#ifdef CONFIG_DEBUG_FS\r\nxenvif_debugfs_addif(be->vif);\r\n#endif\r\nrtnl_lock();\r\nnetif_set_real_num_tx_queues(be->vif->dev, requested_num_queues);\r\nnetif_set_real_num_rx_queues(be->vif->dev, requested_num_queues);\r\nrtnl_unlock();\r\nxenvif_carrier_on(be->vif);\r\nunregister_hotplug_status_watch(be);\r\nerr = xenbus_watch_pathfmt(dev, &be->hotplug_status_watch,\r\nhotplug_status_changed,\r\n"%s/%s", dev->nodename, "hotplug-status");\r\nif (!err)\r\nbe->have_hotplug_status_watch = 1;\r\nnetif_tx_wake_all_queues(be->vif->dev);\r\nreturn;\r\nerr:\r\nif (be->vif->num_queues > 0)\r\nxenvif_disconnect(be->vif);\r\nvfree(be->vif->queues);\r\nbe->vif->queues = NULL;\r\nbe->vif->num_queues = 0;\r\nreturn;\r\n}\r\nstatic int connect_rings(struct backend_info *be, struct xenvif_queue *queue)\r\n{\r\nstruct xenbus_device *dev = be->dev;\r\nunsigned int num_queues = queue->vif->num_queues;\r\nunsigned long tx_ring_ref, rx_ring_ref;\r\nunsigned int tx_evtchn, rx_evtchn;\r\nint err;\r\nchar *xspath;\r\nsize_t xspathsize;\r\nconst size_t xenstore_path_ext_size = 11;\r\nif (num_queues == 1) {\r\nxspath = kzalloc(strlen(dev->otherend) + 1, GFP_KERNEL);\r\nif (!xspath) {\r\nxenbus_dev_fatal(dev, -ENOMEM,\r\n"reading ring references");\r\nreturn -ENOMEM;\r\n}\r\nstrcpy(xspath, dev->otherend);\r\n} else {\r\nxspathsize = strlen(dev->otherend) + xenstore_path_ext_size;\r\nxspath = kzalloc(xspathsize, GFP_KERNEL);\r\nif (!xspath) {\r\nxenbus_dev_fatal(dev, -ENOMEM,\r\n"reading ring references");\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(xspath, xspathsize, "%s/queue-%u", dev->otherend,\r\nqueue->id);\r\n}\r\nerr = xenbus_gather(XBT_NIL, xspath,\r\n"tx-ring-ref", "%lu", &tx_ring_ref,\r\n"rx-ring-ref", "%lu", &rx_ring_ref, NULL);\r\nif (err) {\r\nxenbus_dev_fatal(dev, err,\r\n"reading %s/ring-ref",\r\nxspath);\r\ngoto err;\r\n}\r\nerr = xenbus_gather(XBT_NIL, xspath,\r\n"event-channel-tx", "%u", &tx_evtchn,\r\n"event-channel-rx", "%u", &rx_evtchn, NULL);\r\nif (err < 0) {\r\nerr = xenbus_scanf(XBT_NIL, xspath,\r\n"event-channel", "%u", &tx_evtchn);\r\nif (err < 0) {\r\nxenbus_dev_fatal(dev, err,\r\n"reading %s/event-channel(-tx/rx)",\r\nxspath);\r\ngoto err;\r\n}\r\nrx_evtchn = tx_evtchn;\r\n}\r\nerr = xenvif_connect(queue, tx_ring_ref, rx_ring_ref,\r\ntx_evtchn, rx_evtchn);\r\nif (err) {\r\nxenbus_dev_fatal(dev, err,\r\n"mapping shared-frames %lu/%lu port tx %u rx %u",\r\ntx_ring_ref, rx_ring_ref,\r\ntx_evtchn, rx_evtchn);\r\ngoto err;\r\n}\r\nerr = 0;\r\nerr:\r\nkfree(xspath);\r\nreturn err;\r\n}\r\nstatic int read_xenbus_vif_flags(struct backend_info *be)\r\n{\r\nstruct xenvif *vif = be->vif;\r\nstruct xenbus_device *dev = be->dev;\r\nunsigned int rx_copy;\r\nint err, val;\r\nerr = xenbus_scanf(XBT_NIL, dev->otherend, "request-rx-copy", "%u",\r\n&rx_copy);\r\nif (err == -ENOENT) {\r\nerr = 0;\r\nrx_copy = 0;\r\n}\r\nif (err < 0) {\r\nxenbus_dev_fatal(dev, err, "reading %s/request-rx-copy",\r\ndev->otherend);\r\nreturn err;\r\n}\r\nif (!rx_copy)\r\nreturn -EOPNOTSUPP;\r\nif (xenbus_scanf(XBT_NIL, dev->otherend,\r\n"feature-rx-notify", "%d", &val) < 0)\r\nval = 0;\r\nif (!val) {\r\nbe->vif->drain_timeout = msecs_to_jiffies(30);\r\nbe->vif->stall_timeout = 0;\r\n}\r\nif (xenbus_scanf(XBT_NIL, dev->otherend, "feature-sg",\r\n"%d", &val) < 0)\r\nval = 0;\r\nvif->can_sg = !!val;\r\nvif->gso_mask = 0;\r\nvif->gso_prefix_mask = 0;\r\nif (xenbus_scanf(XBT_NIL, dev->otherend, "feature-gso-tcpv4",\r\n"%d", &val) < 0)\r\nval = 0;\r\nif (val)\r\nvif->gso_mask |= GSO_BIT(TCPV4);\r\nif (xenbus_scanf(XBT_NIL, dev->otherend, "feature-gso-tcpv4-prefix",\r\n"%d", &val) < 0)\r\nval = 0;\r\nif (val)\r\nvif->gso_prefix_mask |= GSO_BIT(TCPV4);\r\nif (xenbus_scanf(XBT_NIL, dev->otherend, "feature-gso-tcpv6",\r\n"%d", &val) < 0)\r\nval = 0;\r\nif (val)\r\nvif->gso_mask |= GSO_BIT(TCPV6);\r\nif (xenbus_scanf(XBT_NIL, dev->otherend, "feature-gso-tcpv6-prefix",\r\n"%d", &val) < 0)\r\nval = 0;\r\nif (val)\r\nvif->gso_prefix_mask |= GSO_BIT(TCPV6);\r\nif (vif->gso_mask & vif->gso_prefix_mask) {\r\nxenbus_dev_fatal(dev, err,\r\n"%s: gso and gso prefix flags are not "\r\n"mutually exclusive",\r\ndev->otherend);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (xenbus_scanf(XBT_NIL, dev->otherend, "feature-no-csum-offload",\r\n"%d", &val) < 0)\r\nval = 0;\r\nvif->ip_csum = !val;\r\nif (xenbus_scanf(XBT_NIL, dev->otherend, "feature-ipv6-csum-offload",\r\n"%d", &val) < 0)\r\nval = 0;\r\nvif->ipv6_csum = !!val;\r\nreturn 0;\r\n}\r\nint xenvif_xenbus_init(void)\r\n{\r\nreturn xenbus_register_backend(&netback_driver);\r\n}\r\nvoid xenvif_xenbus_fini(void)\r\n{\r\nreturn xenbus_unregister_driver(&netback_driver);\r\n}
