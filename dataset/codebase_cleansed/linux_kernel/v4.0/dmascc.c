static void __exit dmascc_exit(void)\r\n{\r\nint i;\r\nstruct scc_info *info;\r\nwhile (first) {\r\ninfo = first;\r\nfor (i = 0; i < 2; i++)\r\nunregister_netdev(info->dev[i]);\r\nif (info->priv[0].type == TYPE_TWIN)\r\noutb(0, info->dev[0]->base_addr + TWIN_SERIAL_CFG);\r\nwrite_scc(&info->priv[0], R9, FHWRES);\r\nrelease_region(info->dev[0]->base_addr,\r\nhw[info->priv[0].type].io_size);\r\nfor (i = 0; i < 2; i++)\r\nfree_netdev(info->dev[i]);\r\nfirst = info->next;\r\nkfree(info);\r\n}\r\n}\r\nstatic int __init dmascc_init(void)\r\n{\r\nint h, i, j, n;\r\nint base[MAX_NUM_DEVS], tcmd[MAX_NUM_DEVS], t0[MAX_NUM_DEVS],\r\nt1[MAX_NUM_DEVS];\r\nunsigned t_val;\r\nunsigned long time, start[MAX_NUM_DEVS], delay[MAX_NUM_DEVS],\r\ncounting[MAX_NUM_DEVS];\r\nrand = jiffies;\r\nn = 0;\r\nif (!io[0])\r\nprintk(KERN_INFO "dmascc: autoprobing (dangerous)\n");\r\nfor (h = 0; h < NUM_TYPES; h++) {\r\nif (io[0]) {\r\nfor (i = 0; i < hw[h].num_devs; i++)\r\nbase[i] = 0;\r\nfor (i = 0; i < MAX_NUM_DEVS && io[i]; i++) {\r\nj = (io[i] -\r\nhw[h].io_region) / hw[h].io_delta;\r\nif (j >= 0 && j < hw[h].num_devs &&\r\nhw[h].io_region +\r\nj * hw[h].io_delta == io[i]) {\r\nbase[j] = io[i];\r\n}\r\n}\r\n} else {\r\nfor (i = 0; i < hw[h].num_devs; i++) {\r\nbase[i] =\r\nhw[h].io_region + i * hw[h].io_delta;\r\n}\r\n}\r\nfor (i = 0; i < hw[h].num_devs; i++)\r\nif (base[i]) {\r\nif (!request_region\r\n(base[i], hw[h].io_size, "dmascc"))\r\nbase[i] = 0;\r\nelse {\r\ntcmd[i] =\r\nbase[i] + hw[h].tmr_offset +\r\nTMR_CTRL;\r\nt0[i] =\r\nbase[i] + hw[h].tmr_offset +\r\nTMR_CNT0;\r\nt1[i] =\r\nbase[i] + hw[h].tmr_offset +\r\nTMR_CNT1;\r\n}\r\n}\r\nfor (i = 0; i < hw[h].num_devs; i++)\r\nif (base[i]) {\r\noutb(0x36, tcmd[i]);\r\noutb((hw[h].tmr_hz / TMR_0_HZ) & 0xFF,\r\nt0[i]);\r\noutb((hw[h].tmr_hz / TMR_0_HZ) >> 8,\r\nt0[i]);\r\noutb(0x70, tcmd[i]);\r\noutb((TMR_0_HZ / HZ * 10) & 0xFF, t1[i]);\r\noutb((TMR_0_HZ / HZ * 10) >> 8, t1[i]);\r\nstart[i] = jiffies;\r\ndelay[i] = 0;\r\ncounting[i] = 1;\r\noutb(0xb0, tcmd[i]);\r\n}\r\ntime = jiffies;\r\nudelay(2000000 / TMR_0_HZ);\r\nwhile (jiffies - time < 13) {\r\nfor (i = 0; i < hw[h].num_devs; i++)\r\nif (base[i] && counting[i]) {\r\noutb(0x40, tcmd[i]);\r\nt_val =\r\ninb(t1[i]) + (inb(t1[i]) << 8);\r\nif (t_val == 0 ||\r\nt_val > TMR_0_HZ / HZ * 10)\r\ncounting[i] = 0;\r\ndelay[i] = jiffies - start[i];\r\n}\r\n}\r\nfor (i = 0; i < hw[h].num_devs; i++)\r\nif (base[i]) {\r\nif ((delay[i] >= 9 && delay[i] <= 11) &&\r\n(setup_adapter(base[i], h, n) == 0))\r\nn++;\r\nelse\r\nrelease_region(base[i],\r\nhw[h].io_size);\r\n}\r\n}\r\nif (n)\r\nreturn 0;\r\nprintk(KERN_INFO "dmascc: no adapters found\n");\r\nreturn -EIO;\r\n}\r\nstatic void __init dev_setup(struct net_device *dev)\r\n{\r\ndev->type = ARPHRD_AX25;\r\ndev->hard_header_len = AX25_MAX_HEADER_LEN;\r\ndev->mtu = 1500;\r\ndev->addr_len = AX25_ADDR_LEN;\r\ndev->tx_queue_len = 64;\r\nmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\r\nmemcpy(dev->dev_addr, &ax25_defaddr, AX25_ADDR_LEN);\r\n}\r\nstatic int __init setup_adapter(int card_base, int type, int n)\r\n{\r\nint i, irq, chip;\r\nstruct scc_info *info;\r\nstruct net_device *dev;\r\nstruct scc_priv *priv;\r\nunsigned long time;\r\nunsigned int irqs;\r\nint tmr_base = card_base + hw[type].tmr_offset;\r\nint scc_base = card_base + hw[type].scc_offset;\r\nchar *chipnames[] = CHIPNAMES;\r\ninfo = kzalloc(sizeof(struct scc_info), GFP_KERNEL | GFP_DMA);\r\nif (!info)\r\ngoto out;\r\ninfo->dev[0] = alloc_netdev(0, "", NET_NAME_UNKNOWN, dev_setup);\r\nif (!info->dev[0]) {\r\nprintk(KERN_ERR "dmascc: "\r\n"could not allocate memory for %s at %#3x\n",\r\nhw[type].name, card_base);\r\ngoto out1;\r\n}\r\ninfo->dev[1] = alloc_netdev(0, "", NET_NAME_UNKNOWN, dev_setup);\r\nif (!info->dev[1]) {\r\nprintk(KERN_ERR "dmascc: "\r\n"could not allocate memory for %s at %#3x\n",\r\nhw[type].name, card_base);\r\ngoto out2;\r\n}\r\nspin_lock_init(&info->register_lock);\r\npriv = &info->priv[0];\r\npriv->type = type;\r\npriv->card_base = card_base;\r\npriv->scc_cmd = scc_base + SCCA_CMD;\r\npriv->scc_data = scc_base + SCCA_DATA;\r\npriv->register_lock = &info->register_lock;\r\nwrite_scc(priv, R9, FHWRES | MIE | NV);\r\nwrite_scc(priv, R15, SHDLCE);\r\nif (!read_scc(priv, R15)) {\r\nchip = Z8530;\r\n} else {\r\nwrite_scc_data(priv, 0, 0);\r\nif (read_scc(priv, R0) & Tx_BUF_EMP) {\r\nchip = Z85230;\r\n} else {\r\nchip = Z85C30;\r\n}\r\n}\r\nwrite_scc(priv, R15, 0);\r\nirqs = probe_irq_on();\r\nif (type == TYPE_TWIN) {\r\noutb(0, card_base + TWIN_DMA_CFG);\r\ninb(card_base + TWIN_CLR_TMR1);\r\ninb(card_base + TWIN_CLR_TMR2);\r\ninfo->twin_serial_cfg = TWIN_EI;\r\noutb(info->twin_serial_cfg, card_base + TWIN_SERIAL_CFG);\r\n} else {\r\nwrite_scc(priv, R15, CTSIE);\r\nwrite_scc(priv, R0, RES_EXT_INT);\r\nwrite_scc(priv, R1, EXT_INT_ENAB);\r\n}\r\noutb(1, tmr_base + TMR_CNT1);\r\noutb(0, tmr_base + TMR_CNT1);\r\ntime = jiffies;\r\nwhile (jiffies - time < 2 + HZ / TMR_0_HZ);\r\nirq = probe_irq_off(irqs);\r\nif (type == TYPE_TWIN) {\r\ninb(card_base + TWIN_CLR_TMR1);\r\n} else {\r\nwrite_scc(priv, R1, 0);\r\nwrite_scc(priv, R15, 0);\r\nwrite_scc(priv, R0, RES_EXT_INT);\r\n}\r\nif (irq <= 0) {\r\nprintk(KERN_ERR\r\n"dmascc: could not find irq of %s at %#3x (irq=%d)\n",\r\nhw[type].name, card_base, irq);\r\ngoto out3;\r\n}\r\nfor (i = 0; i < 2; i++) {\r\ndev = info->dev[i];\r\npriv = &info->priv[i];\r\npriv->type = type;\r\npriv->chip = chip;\r\npriv->dev = dev;\r\npriv->info = info;\r\npriv->channel = i;\r\nspin_lock_init(&priv->ring_lock);\r\npriv->register_lock = &info->register_lock;\r\npriv->card_base = card_base;\r\npriv->scc_cmd = scc_base + (i ? SCCB_CMD : SCCA_CMD);\r\npriv->scc_data = scc_base + (i ? SCCB_DATA : SCCA_DATA);\r\npriv->tmr_cnt = tmr_base + (i ? TMR_CNT2 : TMR_CNT1);\r\npriv->tmr_ctrl = tmr_base + TMR_CTRL;\r\npriv->tmr_mode = i ? 0xb0 : 0x70;\r\npriv->param.pclk_hz = hw[type].pclk_hz;\r\npriv->param.brg_tc = -1;\r\npriv->param.clocks = TCTRxCP | RCRTxCP;\r\npriv->param.persist = 256;\r\npriv->param.dma = -1;\r\nINIT_WORK(&priv->rx_work, rx_bh);\r\ndev->ml_priv = priv;\r\nsprintf(dev->name, "dmascc%i", 2 * n + i);\r\ndev->base_addr = card_base;\r\ndev->irq = irq;\r\ndev->netdev_ops = &scc_netdev_ops;\r\ndev->header_ops = &ax25_header_ops;\r\n}\r\nif (register_netdev(info->dev[0])) {\r\nprintk(KERN_ERR "dmascc: could not register %s\n",\r\ninfo->dev[0]->name);\r\ngoto out3;\r\n}\r\nif (register_netdev(info->dev[1])) {\r\nprintk(KERN_ERR "dmascc: could not register %s\n",\r\ninfo->dev[1]->name);\r\ngoto out4;\r\n}\r\ninfo->next = first;\r\nfirst = info;\r\nprintk(KERN_INFO "dmascc: found %s (%s) at %#3x, irq %d\n",\r\nhw[type].name, chipnames[chip], card_base, irq);\r\nreturn 0;\r\nout4:\r\nunregister_netdev(info->dev[0]);\r\nout3:\r\nif (info->priv[0].type == TYPE_TWIN)\r\noutb(0, info->dev[0]->base_addr + TWIN_SERIAL_CFG);\r\nwrite_scc(&info->priv[0], R9, FHWRES);\r\nfree_netdev(info->dev[1]);\r\nout2:\r\nfree_netdev(info->dev[0]);\r\nout1:\r\nkfree(info);\r\nout:\r\nreturn -1;\r\n}\r\nstatic void write_scc(struct scc_priv *priv, int reg, int val)\r\n{\r\nunsigned long flags;\r\nswitch (priv->type) {\r\ncase TYPE_S5:\r\nif (reg)\r\noutb(reg, priv->scc_cmd);\r\noutb(val, priv->scc_cmd);\r\nreturn;\r\ncase TYPE_TWIN:\r\nif (reg)\r\noutb_p(reg, priv->scc_cmd);\r\noutb_p(val, priv->scc_cmd);\r\nreturn;\r\ndefault:\r\nspin_lock_irqsave(priv->register_lock, flags);\r\noutb_p(0, priv->card_base + PI_DREQ_MASK);\r\nif (reg)\r\noutb_p(reg, priv->scc_cmd);\r\noutb_p(val, priv->scc_cmd);\r\noutb(1, priv->card_base + PI_DREQ_MASK);\r\nspin_unlock_irqrestore(priv->register_lock, flags);\r\nreturn;\r\n}\r\n}\r\nstatic void write_scc_data(struct scc_priv *priv, int val, int fast)\r\n{\r\nunsigned long flags;\r\nswitch (priv->type) {\r\ncase TYPE_S5:\r\noutb(val, priv->scc_data);\r\nreturn;\r\ncase TYPE_TWIN:\r\noutb_p(val, priv->scc_data);\r\nreturn;\r\ndefault:\r\nif (fast)\r\noutb_p(val, priv->scc_data);\r\nelse {\r\nspin_lock_irqsave(priv->register_lock, flags);\r\noutb_p(0, priv->card_base + PI_DREQ_MASK);\r\noutb_p(val, priv->scc_data);\r\noutb(1, priv->card_base + PI_DREQ_MASK);\r\nspin_unlock_irqrestore(priv->register_lock, flags);\r\n}\r\nreturn;\r\n}\r\n}\r\nstatic int read_scc(struct scc_priv *priv, int reg)\r\n{\r\nint rc;\r\nunsigned long flags;\r\nswitch (priv->type) {\r\ncase TYPE_S5:\r\nif (reg)\r\noutb(reg, priv->scc_cmd);\r\nreturn inb(priv->scc_cmd);\r\ncase TYPE_TWIN:\r\nif (reg)\r\noutb_p(reg, priv->scc_cmd);\r\nreturn inb_p(priv->scc_cmd);\r\ndefault:\r\nspin_lock_irqsave(priv->register_lock, flags);\r\noutb_p(0, priv->card_base + PI_DREQ_MASK);\r\nif (reg)\r\noutb_p(reg, priv->scc_cmd);\r\nrc = inb_p(priv->scc_cmd);\r\noutb(1, priv->card_base + PI_DREQ_MASK);\r\nspin_unlock_irqrestore(priv->register_lock, flags);\r\nreturn rc;\r\n}\r\n}\r\nstatic int read_scc_data(struct scc_priv *priv)\r\n{\r\nint rc;\r\nunsigned long flags;\r\nswitch (priv->type) {\r\ncase TYPE_S5:\r\nreturn inb(priv->scc_data);\r\ncase TYPE_TWIN:\r\nreturn inb_p(priv->scc_data);\r\ndefault:\r\nspin_lock_irqsave(priv->register_lock, flags);\r\noutb_p(0, priv->card_base + PI_DREQ_MASK);\r\nrc = inb_p(priv->scc_data);\r\noutb(1, priv->card_base + PI_DREQ_MASK);\r\nspin_unlock_irqrestore(priv->register_lock, flags);\r\nreturn rc;\r\n}\r\n}\r\nstatic int scc_open(struct net_device *dev)\r\n{\r\nstruct scc_priv *priv = dev->ml_priv;\r\nstruct scc_info *info = priv->info;\r\nint card_base = priv->card_base;\r\nif (!info->irq_used) {\r\nif (request_irq(dev->irq, scc_isr, 0, "dmascc", info)) {\r\nreturn -EAGAIN;\r\n}\r\n}\r\ninfo->irq_used++;\r\nif (priv->param.dma >= 0) {\r\nif (request_dma(priv->param.dma, "dmascc")) {\r\nif (--info->irq_used == 0)\r\nfree_irq(dev->irq, info);\r\nreturn -EAGAIN;\r\n} else {\r\nunsigned long flags = claim_dma_lock();\r\nclear_dma_ff(priv->param.dma);\r\nrelease_dma_lock(flags);\r\n}\r\n}\r\npriv->rx_ptr = 0;\r\npriv->rx_over = 0;\r\npriv->rx_head = priv->rx_tail = priv->rx_count = 0;\r\npriv->state = IDLE;\r\npriv->tx_head = priv->tx_tail = priv->tx_count = 0;\r\npriv->tx_ptr = 0;\r\nwrite_scc(priv, R9, (priv->channel ? CHRB : CHRA) | MIE | NV);\r\nwrite_scc(priv, R4, SDLC | X1CLK);\r\nwrite_scc(priv, R1, EXT_INT_ENAB | WT_FN_RDYFN);\r\nwrite_scc(priv, R3, Rx8);\r\nwrite_scc(priv, R5, Tx8);\r\nwrite_scc(priv, R6, 0);\r\nwrite_scc(priv, R7, FLAG);\r\nswitch (priv->chip) {\r\ncase Z85C30:\r\nwrite_scc(priv, R15, SHDLCE);\r\nwrite_scc(priv, R7, AUTOEOM);\r\nwrite_scc(priv, R15, 0);\r\nbreak;\r\ncase Z85230:\r\nwrite_scc(priv, R15, SHDLCE);\r\nif (priv->param.dma >= 0) {\r\nif (priv->type == TYPE_TWIN)\r\nwrite_scc(priv, R7, AUTOEOM | TXFIFOE);\r\nelse\r\nwrite_scc(priv, R7, AUTOEOM);\r\n} else {\r\nwrite_scc(priv, R7, AUTOEOM | RXFIFOH);\r\n}\r\nwrite_scc(priv, R15, 0);\r\nbreak;\r\n}\r\nwrite_scc(priv, R10, CRCPS | (priv->param.nrzi ? NRZI : NRZ));\r\nif (priv->param.brg_tc >= 0) {\r\nwrite_scc(priv, R12, priv->param.brg_tc & 0xFF);\r\nwrite_scc(priv, R13, (priv->param.brg_tc >> 8) & 0xFF);\r\nwrite_scc(priv, R14, SSBR | DTRREQ | BRSRC | BRENABL);\r\nwrite_scc(priv, R14, SEARCH | DTRREQ | BRSRC | BRENABL);\r\n} else {\r\nwrite_scc(priv, R14, DTRREQ | BRSRC);\r\n}\r\nif (priv->type == TYPE_TWIN) {\r\noutb((info->twin_serial_cfg &=\r\n~(priv->channel ? TWIN_EXTCLKB : TWIN_EXTCLKA)),\r\ncard_base + TWIN_SERIAL_CFG);\r\n}\r\nwrite_scc(priv, R11, priv->param.clocks);\r\nif ((priv->type == TYPE_TWIN) && !(priv->param.clocks & TRxCOI)) {\r\noutb((info->twin_serial_cfg |=\r\n(priv->channel ? TWIN_EXTCLKB : TWIN_EXTCLKA)),\r\ncard_base + TWIN_SERIAL_CFG);\r\n}\r\nif (priv->type == TYPE_TWIN) {\r\noutb((info->twin_serial_cfg |= TWIN_EI |\r\n(priv->channel ? TWIN_DTRB_ON : TWIN_DTRA_ON)),\r\ncard_base + TWIN_SERIAL_CFG);\r\n}\r\npriv->rr0 = read_scc(priv, R0);\r\nwrite_scc(priv, R15, DCDIE);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int scc_close(struct net_device *dev)\r\n{\r\nstruct scc_priv *priv = dev->ml_priv;\r\nstruct scc_info *info = priv->info;\r\nint card_base = priv->card_base;\r\nnetif_stop_queue(dev);\r\nif (priv->type == TYPE_TWIN) {\r\noutb((info->twin_serial_cfg &=\r\n(priv->channel ? ~TWIN_DTRB_ON : ~TWIN_DTRA_ON)),\r\ncard_base + TWIN_SERIAL_CFG);\r\n}\r\nwrite_scc(priv, R9, (priv->channel ? CHRB : CHRA) | MIE | NV);\r\nif (priv->param.dma >= 0) {\r\nif (priv->type == TYPE_TWIN)\r\noutb(0, card_base + TWIN_DMA_CFG);\r\nfree_dma(priv->param.dma);\r\n}\r\nif (--info->irq_used == 0)\r\nfree_irq(dev->irq, info);\r\nreturn 0;\r\n}\r\nstatic int scc_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct scc_priv *priv = dev->ml_priv;\r\nswitch (cmd) {\r\ncase SIOCGSCCPARAM:\r\nif (copy_to_user\r\n(ifr->ifr_data, &priv->param,\r\nsizeof(struct scc_param)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase SIOCSSCCPARAM:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (netif_running(dev))\r\nreturn -EAGAIN;\r\nif (copy_from_user\r\n(&priv->param, ifr->ifr_data,\r\nsizeof(struct scc_param)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int scc_send_packet(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct scc_priv *priv = dev->ml_priv;\r\nunsigned long flags;\r\nint i;\r\nnetif_stop_queue(dev);\r\ni = priv->tx_head;\r\nskb_copy_from_linear_data_offset(skb, 1, priv->tx_buf[i], skb->len - 1);\r\npriv->tx_len[i] = skb->len - 1;\r\nspin_lock_irqsave(&priv->ring_lock, flags);\r\npriv->tx_head = (i + 1) % NUM_TX_BUF;\r\npriv->tx_count++;\r\nif (priv->tx_count < NUM_TX_BUF)\r\nnetif_wake_queue(dev);\r\nif (priv->state == IDLE) {\r\npriv->state = TX_HEAD;\r\npriv->tx_start = jiffies;\r\nwrite_scc(priv, R5, TxCRC_ENAB | RTS | TxENAB | Tx8);\r\nwrite_scc(priv, R15, 0);\r\nstart_timer(priv, priv->param.txdelay, 0);\r\n}\r\nspin_unlock_irqrestore(&priv->ring_lock, flags);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int scc_set_mac_address(struct net_device *dev, void *sa)\r\n{\r\nmemcpy(dev->dev_addr, ((struct sockaddr *) sa)->sa_data,\r\ndev->addr_len);\r\nreturn 0;\r\n}\r\nstatic inline void tx_on(struct scc_priv *priv)\r\n{\r\nint i, n;\r\nunsigned long flags;\r\nif (priv->param.dma >= 0) {\r\nn = (priv->chip == Z85230) ? 3 : 1;\r\nflags = claim_dma_lock();\r\nset_dma_mode(priv->param.dma, DMA_MODE_WRITE);\r\nset_dma_addr(priv->param.dma,\r\n(int) priv->tx_buf[priv->tx_tail] + n);\r\nset_dma_count(priv->param.dma,\r\npriv->tx_len[priv->tx_tail] - n);\r\nrelease_dma_lock(flags);\r\nwrite_scc(priv, R15, TxUIE);\r\nif (priv->type == TYPE_TWIN)\r\noutb((priv->param.dma ==\r\n1) ? TWIN_DMA_HDX_T1 : TWIN_DMA_HDX_T3,\r\npriv->card_base + TWIN_DMA_CFG);\r\nelse\r\nwrite_scc(priv, R1,\r\nEXT_INT_ENAB | WT_FN_RDYFN |\r\nWT_RDY_ENAB);\r\nspin_lock_irqsave(priv->register_lock, flags);\r\nfor (i = 0; i < n; i++)\r\nwrite_scc_data(priv,\r\npriv->tx_buf[priv->tx_tail][i], 1);\r\nenable_dma(priv->param.dma);\r\nspin_unlock_irqrestore(priv->register_lock, flags);\r\n} else {\r\nwrite_scc(priv, R15, TxUIE);\r\nwrite_scc(priv, R1,\r\nEXT_INT_ENAB | WT_FN_RDYFN | TxINT_ENAB);\r\ntx_isr(priv);\r\n}\r\nif (priv->chip == Z8530)\r\nwrite_scc(priv, R0, RES_EOM_L);\r\n}\r\nstatic inline void rx_on(struct scc_priv *priv)\r\n{\r\nunsigned long flags;\r\nwhile (read_scc(priv, R0) & Rx_CH_AV)\r\nread_scc_data(priv);\r\npriv->rx_over = 0;\r\nif (priv->param.dma >= 0) {\r\nflags = claim_dma_lock();\r\nset_dma_mode(priv->param.dma, DMA_MODE_READ);\r\nset_dma_addr(priv->param.dma,\r\n(int) priv->rx_buf[priv->rx_head]);\r\nset_dma_count(priv->param.dma, BUF_SIZE);\r\nrelease_dma_lock(flags);\r\nenable_dma(priv->param.dma);\r\nif (priv->type == TYPE_TWIN) {\r\noutb((priv->param.dma ==\r\n1) ? TWIN_DMA_HDX_R1 : TWIN_DMA_HDX_R3,\r\npriv->card_base + TWIN_DMA_CFG);\r\n}\r\nwrite_scc(priv, R1, EXT_INT_ENAB | INT_ERR_Rx |\r\nWT_RDY_RT | WT_FN_RDYFN | WT_RDY_ENAB);\r\n} else {\r\npriv->rx_ptr = 0;\r\nwrite_scc(priv, R1, EXT_INT_ENAB | INT_ALL_Rx | WT_RDY_RT |\r\nWT_FN_RDYFN);\r\n}\r\nwrite_scc(priv, R0, ERR_RES);\r\nwrite_scc(priv, R3, RxENABLE | Rx8 | RxCRC_ENAB);\r\n}\r\nstatic inline void rx_off(struct scc_priv *priv)\r\n{\r\nwrite_scc(priv, R3, Rx8);\r\nif (priv->param.dma >= 0 && priv->type == TYPE_TWIN)\r\noutb(0, priv->card_base + TWIN_DMA_CFG);\r\nelse\r\nwrite_scc(priv, R1, EXT_INT_ENAB | WT_FN_RDYFN);\r\nif (priv->param.dma >= 0)\r\ndisable_dma(priv->param.dma);\r\n}\r\nstatic void start_timer(struct scc_priv *priv, int t, int r15)\r\n{\r\noutb(priv->tmr_mode, priv->tmr_ctrl);\r\nif (t == 0) {\r\ntm_isr(priv);\r\n} else if (t > 0) {\r\noutb(t & 0xFF, priv->tmr_cnt);\r\noutb((t >> 8) & 0xFF, priv->tmr_cnt);\r\nif (priv->type != TYPE_TWIN) {\r\nwrite_scc(priv, R15, r15 | CTSIE);\r\npriv->rr0 |= CTS;\r\n}\r\n}\r\n}\r\nstatic inline unsigned char random(void)\r\n{\r\nrand = rand * 1664525L + 1013904223L;\r\nreturn (unsigned char) (rand >> 24);\r\n}\r\nstatic inline void z8530_isr(struct scc_info *info)\r\n{\r\nint is, i = 100;\r\nwhile ((is = read_scc(&info->priv[0], R3)) && i--) {\r\nif (is & CHARxIP) {\r\nrx_isr(&info->priv[0]);\r\n} else if (is & CHATxIP) {\r\ntx_isr(&info->priv[0]);\r\n} else if (is & CHAEXT) {\r\nes_isr(&info->priv[0]);\r\n} else if (is & CHBRxIP) {\r\nrx_isr(&info->priv[1]);\r\n} else if (is & CHBTxIP) {\r\ntx_isr(&info->priv[1]);\r\n} else {\r\nes_isr(&info->priv[1]);\r\n}\r\nwrite_scc(&info->priv[0], R0, RES_H_IUS);\r\ni++;\r\n}\r\nif (i < 0) {\r\nprintk(KERN_ERR "dmascc: stuck in ISR with RR3=0x%02x.\n",\r\nis);\r\n}\r\n}\r\nstatic irqreturn_t scc_isr(int irq, void *dev_id)\r\n{\r\nstruct scc_info *info = dev_id;\r\nspin_lock(info->priv[0].register_lock);\r\nif (info->priv[0].type == TYPE_TWIN) {\r\nint is, card_base = info->priv[0].card_base;\r\nwhile ((is = ~inb(card_base + TWIN_INT_REG)) &\r\nTWIN_INT_MSK) {\r\nif (is & TWIN_SCC_MSK) {\r\nz8530_isr(info);\r\n} else if (is & TWIN_TMR1_MSK) {\r\ninb(card_base + TWIN_CLR_TMR1);\r\ntm_isr(&info->priv[0]);\r\n} else {\r\ninb(card_base + TWIN_CLR_TMR2);\r\ntm_isr(&info->priv[1]);\r\n}\r\n}\r\n} else\r\nz8530_isr(info);\r\nspin_unlock(info->priv[0].register_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void rx_isr(struct scc_priv *priv)\r\n{\r\nif (priv->param.dma >= 0) {\r\nspecial_condition(priv, read_scc(priv, R1));\r\nwrite_scc(priv, R0, ERR_RES);\r\n} else {\r\nint rc;\r\nwhile (read_scc(priv, R0) & Rx_CH_AV) {\r\nrc = read_scc(priv, R1);\r\nif (priv->rx_ptr < BUF_SIZE)\r\npriv->rx_buf[priv->rx_head][priv->\r\nrx_ptr++] =\r\nread_scc_data(priv);\r\nelse {\r\npriv->rx_over = 2;\r\nread_scc_data(priv);\r\n}\r\nspecial_condition(priv, rc);\r\n}\r\n}\r\n}\r\nstatic void special_condition(struct scc_priv *priv, int rc)\r\n{\r\nint cb;\r\nunsigned long flags;\r\nif (rc & Rx_OVR) {\r\npriv->rx_over = 1;\r\nif (priv->param.dma < 0)\r\nwrite_scc(priv, R0, ERR_RES);\r\n} else if (rc & END_FR) {\r\nif (priv->param.dma >= 0) {\r\nflags = claim_dma_lock();\r\ncb = BUF_SIZE - get_dma_residue(priv->param.dma) -\r\n2;\r\nrelease_dma_lock(flags);\r\n} else {\r\ncb = priv->rx_ptr - 2;\r\n}\r\nif (priv->rx_over) {\r\npriv->dev->stats.rx_errors++;\r\nif (priv->rx_over == 2)\r\npriv->dev->stats.rx_length_errors++;\r\nelse\r\npriv->dev->stats.rx_fifo_errors++;\r\npriv->rx_over = 0;\r\n} else if (rc & CRC_ERR) {\r\nif (cb >= 15) {\r\npriv->dev->stats.rx_errors++;\r\npriv->dev->stats.rx_crc_errors++;\r\n}\r\n} else {\r\nif (cb >= 15) {\r\nif (priv->rx_count < NUM_RX_BUF - 1) {\r\npriv->rx_len[priv->rx_head] = cb;\r\npriv->rx_head =\r\n(priv->rx_head +\r\n1) % NUM_RX_BUF;\r\npriv->rx_count++;\r\nschedule_work(&priv->rx_work);\r\n} else {\r\npriv->dev->stats.rx_errors++;\r\npriv->dev->stats.rx_over_errors++;\r\n}\r\n}\r\n}\r\nif (priv->param.dma >= 0) {\r\nflags = claim_dma_lock();\r\nset_dma_addr(priv->param.dma,\r\n(int) priv->rx_buf[priv->rx_head]);\r\nset_dma_count(priv->param.dma, BUF_SIZE);\r\nrelease_dma_lock(flags);\r\n} else {\r\npriv->rx_ptr = 0;\r\n}\r\n}\r\n}\r\nstatic void rx_bh(struct work_struct *ugli_api)\r\n{\r\nstruct scc_priv *priv = container_of(ugli_api, struct scc_priv, rx_work);\r\nint i = priv->rx_tail;\r\nint cb;\r\nunsigned long flags;\r\nstruct sk_buff *skb;\r\nunsigned char *data;\r\nspin_lock_irqsave(&priv->ring_lock, flags);\r\nwhile (priv->rx_count) {\r\nspin_unlock_irqrestore(&priv->ring_lock, flags);\r\ncb = priv->rx_len[i];\r\nskb = dev_alloc_skb(cb + 1);\r\nif (skb == NULL) {\r\npriv->dev->stats.rx_dropped++;\r\n} else {\r\ndata = skb_put(skb, cb + 1);\r\ndata[0] = 0;\r\nmemcpy(&data[1], priv->rx_buf[i], cb);\r\nskb->protocol = ax25_type_trans(skb, priv->dev);\r\nnetif_rx(skb);\r\npriv->dev->stats.rx_packets++;\r\npriv->dev->stats.rx_bytes += cb;\r\n}\r\nspin_lock_irqsave(&priv->ring_lock, flags);\r\npriv->rx_tail = i = (i + 1) % NUM_RX_BUF;\r\npriv->rx_count--;\r\n}\r\nspin_unlock_irqrestore(&priv->ring_lock, flags);\r\n}\r\nstatic void tx_isr(struct scc_priv *priv)\r\n{\r\nint i = priv->tx_tail, p = priv->tx_ptr;\r\nif (p == priv->tx_len[i]) {\r\nwrite_scc(priv, R0, RES_Tx_P);\r\nreturn;\r\n}\r\nwhile ((read_scc(priv, R0) & Tx_BUF_EMP) && p < priv->tx_len[i]) {\r\nwrite_scc_data(priv, priv->tx_buf[i][p++], 0);\r\n}\r\nif (!priv->tx_ptr && p && priv->chip == Z8530)\r\nwrite_scc(priv, R0, RES_EOM_L);\r\npriv->tx_ptr = p;\r\n}\r\nstatic void es_isr(struct scc_priv *priv)\r\n{\r\nint i, rr0, drr0, res;\r\nunsigned long flags;\r\nrr0 = read_scc(priv, R0);\r\nwrite_scc(priv, R0, RES_EXT_INT);\r\ndrr0 = priv->rr0 ^ rr0;\r\npriv->rr0 = rr0;\r\nif (priv->state == TX_DATA) {\r\ni = priv->tx_tail;\r\nif (priv->param.dma >= 0) {\r\ndisable_dma(priv->param.dma);\r\nflags = claim_dma_lock();\r\nres = get_dma_residue(priv->param.dma);\r\nrelease_dma_lock(flags);\r\n} else {\r\nres = priv->tx_len[i] - priv->tx_ptr;\r\npriv->tx_ptr = 0;\r\n}\r\nif (priv->param.dma >= 0 && priv->type == TYPE_TWIN)\r\noutb(0, priv->card_base + TWIN_DMA_CFG);\r\nelse\r\nwrite_scc(priv, R1, EXT_INT_ENAB | WT_FN_RDYFN);\r\nif (res) {\r\npriv->dev->stats.tx_errors++;\r\npriv->dev->stats.tx_fifo_errors++;\r\nwrite_scc(priv, R0, RES_EXT_INT);\r\nwrite_scc(priv, R0, RES_EXT_INT);\r\n} else {\r\npriv->dev->stats.tx_packets++;\r\npriv->dev->stats.tx_bytes += priv->tx_len[i];\r\npriv->tx_tail = (i + 1) % NUM_TX_BUF;\r\npriv->tx_count--;\r\nnetif_wake_queue(priv->dev);\r\n}\r\nwrite_scc(priv, R15, 0);\r\nif (priv->tx_count &&\r\n(jiffies - priv->tx_start) < priv->param.txtimeout) {\r\npriv->state = TX_PAUSE;\r\nstart_timer(priv, priv->param.txpause, 0);\r\n} else {\r\npriv->state = TX_TAIL;\r\nstart_timer(priv, priv->param.txtail, 0);\r\n}\r\n}\r\nif (drr0 & DCD) {\r\nif (rr0 & DCD) {\r\nswitch (priv->state) {\r\ncase IDLE:\r\ncase WAIT:\r\npriv->state = DCD_ON;\r\nwrite_scc(priv, R15, 0);\r\nstart_timer(priv, priv->param.dcdon, 0);\r\n}\r\n} else {\r\nswitch (priv->state) {\r\ncase RX_ON:\r\nrx_off(priv);\r\npriv->state = DCD_OFF;\r\nwrite_scc(priv, R15, 0);\r\nstart_timer(priv, priv->param.dcdoff, 0);\r\n}\r\n}\r\n}\r\nif ((drr0 & CTS) && (~rr0 & CTS) && priv->type != TYPE_TWIN)\r\ntm_isr(priv);\r\n}\r\nstatic void tm_isr(struct scc_priv *priv)\r\n{\r\nswitch (priv->state) {\r\ncase TX_HEAD:\r\ncase TX_PAUSE:\r\ntx_on(priv);\r\npriv->state = TX_DATA;\r\nbreak;\r\ncase TX_TAIL:\r\nwrite_scc(priv, R5, TxCRC_ENAB | Tx8);\r\npriv->state = RTS_OFF;\r\nif (priv->type != TYPE_TWIN)\r\nwrite_scc(priv, R15, 0);\r\nstart_timer(priv, priv->param.rtsoff, 0);\r\nbreak;\r\ncase RTS_OFF:\r\nwrite_scc(priv, R15, DCDIE);\r\npriv->rr0 = read_scc(priv, R0);\r\nif (priv->rr0 & DCD) {\r\npriv->dev->stats.collisions++;\r\nrx_on(priv);\r\npriv->state = RX_ON;\r\n} else {\r\npriv->state = WAIT;\r\nstart_timer(priv, priv->param.waittime, DCDIE);\r\n}\r\nbreak;\r\ncase WAIT:\r\nif (priv->tx_count) {\r\npriv->state = TX_HEAD;\r\npriv->tx_start = jiffies;\r\nwrite_scc(priv, R5,\r\nTxCRC_ENAB | RTS | TxENAB | Tx8);\r\nwrite_scc(priv, R15, 0);\r\nstart_timer(priv, priv->param.txdelay, 0);\r\n} else {\r\npriv->state = IDLE;\r\nif (priv->type != TYPE_TWIN)\r\nwrite_scc(priv, R15, DCDIE);\r\n}\r\nbreak;\r\ncase DCD_ON:\r\ncase DCD_OFF:\r\nwrite_scc(priv, R15, DCDIE);\r\npriv->rr0 = read_scc(priv, R0);\r\nif (priv->rr0 & DCD) {\r\nrx_on(priv);\r\npriv->state = RX_ON;\r\n} else {\r\npriv->state = WAIT;\r\nstart_timer(priv,\r\nrandom() / priv->param.persist *\r\npriv->param.slottime, DCDIE);\r\n}\r\nbreak;\r\n}\r\n}
