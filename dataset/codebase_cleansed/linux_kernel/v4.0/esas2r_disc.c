void esas2r_disc_initialize(struct esas2r_adapter *a)\r\n{\r\nstruct esas2r_sas_nvram *nvr = a->nvram;\r\nesas2r_trace_enter();\r\nclear_bit(AF_DISC_IN_PROG, &a->flags);\r\nclear_bit(AF2_DEV_SCAN, &a->flags2);\r\nclear_bit(AF2_DEV_CNT_OK, &a->flags2);\r\na->disc_start_time = jiffies_to_msecs(jiffies);\r\na->disc_wait_time = nvr->dev_wait_time * 1000;\r\na->disc_wait_cnt = nvr->dev_wait_count;\r\nif (a->disc_wait_cnt > ESAS2R_MAX_TARGETS)\r\na->disc_wait_cnt = ESAS2R_MAX_TARGETS;\r\nesas2r_hdebug("starting discovery...");\r\na->general_req.interrupt_cx = NULL;\r\nif (test_bit(AF_CHPRST_DETECTED, &a->flags) ||\r\ntest_bit(AF_POWER_MGT, &a->flags)) {\r\nif (a->prev_dev_cnt == 0) {\r\na->disc_wait_time = 0;\r\n} else {\r\na->disc_wait_cnt = a->prev_dev_cnt;\r\nif (a->disc_wait_time < 15000)\r\na->disc_wait_time = 15000;\r\n}\r\n}\r\nesas2r_trace("disc wait count: %d", a->disc_wait_cnt);\r\nesas2r_trace("disc wait time: %d", a->disc_wait_time);\r\nif (a->disc_wait_time == 0)\r\nesas2r_disc_check_complete(a);\r\nesas2r_trace_exit();\r\n}\r\nvoid esas2r_disc_start_waiting(struct esas2r_adapter *a)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&a->mem_lock, flags);\r\nif (a->disc_ctx.disc_evt)\r\nesas2r_disc_start_port(a);\r\nspin_unlock_irqrestore(&a->mem_lock, flags);\r\n}\r\nvoid esas2r_disc_check_for_work(struct esas2r_adapter *a)\r\n{\r\nstruct esas2r_request *rq = &a->general_req;\r\nesas2r_polled_interrupt(a);\r\nesas2r_disc_start_waiting(a);\r\nif (rq->interrupt_cx == NULL)\r\nreturn;\r\nif (rq->req_stat == RS_STARTED\r\n&& rq->timeout <= RQ_MAX_TIMEOUT) {\r\nesas2r_wait_request(a, rq);\r\nif (rq->req_stat == RS_TIMEOUT) {\r\nesas2r_disc_abort(a, rq);\r\nesas2r_local_reset_adapter(a);\r\nreturn;\r\n}\r\n}\r\nif (rq->req_stat == RS_PENDING\r\n|| rq->req_stat == RS_STARTED)\r\nreturn;\r\nesas2r_disc_continue(a, rq);\r\n}\r\nvoid esas2r_disc_check_complete(struct esas2r_adapter *a)\r\n{\r\nunsigned long flags;\r\nesas2r_trace_enter();\r\nif (a->disc_wait_time) {\r\nu32 currtime = jiffies_to_msecs(jiffies);\r\nu32 time = currtime - a->disc_start_time;\r\nif (time < a->disc_wait_time\r\n&& (esas2r_targ_db_get_tgt_cnt(a) < a->disc_wait_cnt\r\n|| a->disc_wait_cnt == 0)) {\r\nif (time >= 3000\r\n&& !test_and_set_bit(AF2_DEV_SCAN, &a->flags2)) {\r\nspin_lock_irqsave(&a->mem_lock, flags);\r\nesas2r_disc_queue_event(a, DCDE_DEV_SCAN);\r\nspin_unlock_irqrestore(&a->mem_lock, flags);\r\n}\r\nesas2r_trace_exit();\r\nreturn;\r\n}\r\nif (!test_and_set_bit(AF2_DEV_CNT_OK, &a->flags2))\r\na->disc_wait_time = time + 3000;\r\nif (!test_and_set_bit(AF2_DEV_SCAN, &a->flags2)) {\r\nspin_lock_irqsave(&a->mem_lock, flags);\r\nesas2r_disc_queue_event(a, DCDE_DEV_SCAN);\r\nspin_unlock_irqrestore(&a->mem_lock, flags);\r\nesas2r_trace_exit();\r\nreturn;\r\n}\r\nif (time < a->disc_wait_time) {\r\nesas2r_trace_exit();\r\nreturn;\r\n}\r\n} else {\r\nif (!test_and_set_bit(AF2_DEV_SCAN, &a->flags2)) {\r\nspin_lock_irqsave(&a->mem_lock, flags);\r\nesas2r_disc_queue_event(a, DCDE_DEV_SCAN);\r\nspin_unlock_irqrestore(&a->mem_lock, flags);\r\n}\r\n}\r\na->disc_wait_time = 0;\r\nif (test_bit(AF_DISC_POLLED, &a->flags) &&\r\ntest_bit(AF_DISC_IN_PROG, &a->flags)) {\r\n} else {\r\nesas2r_disc_fix_curr_requests(a);\r\nclear_bit(AF_DISC_PENDING, &a->flags);\r\nset_bit(AF_PORT_CHANGE, &a->flags);\r\n}\r\nesas2r_trace_exit();\r\n}\r\nvoid esas2r_disc_queue_event(struct esas2r_adapter *a, u8 disc_evt)\r\n{\r\nstruct esas2r_disc_context *dc = &a->disc_ctx;\r\nesas2r_trace_enter();\r\nesas2r_trace("disc_event: %d", disc_evt);\r\ndc->disc_evt |= disc_evt;\r\nif (!test_bit(AF_CHPRST_PENDING, &a->flags) &&\r\n!test_bit(AF_DISC_POLLED, &a->flags))\r\nesas2r_disc_start_port(a);\r\nesas2r_trace_exit();\r\n}\r\nbool esas2r_disc_start_port(struct esas2r_adapter *a)\r\n{\r\nstruct esas2r_request *rq = &a->general_req;\r\nstruct esas2r_disc_context *dc = &a->disc_ctx;\r\nbool ret;\r\nesas2r_trace_enter();\r\nif (test_bit(AF_DISC_IN_PROG, &a->flags)) {\r\nesas2r_trace_exit();\r\nreturn false;\r\n}\r\nif (dc->disc_evt) {\r\nif (test_bit(AF_DISC_POLLED, &a->flags)\r\n&& a->disc_wait_time == 0) {\r\nesas2r_trace_exit();\r\nreturn false;\r\n}\r\n} else {\r\nesas2r_hdebug("disc done");\r\nset_bit(AF_PORT_CHANGE, &a->flags);\r\nesas2r_trace_exit();\r\nreturn false;\r\n}\r\nesas2r_trace("disc_evt: %d", dc->disc_evt);\r\nset_bit(AF_DISC_IN_PROG, &a->flags);\r\ndc->flags = 0;\r\nif (test_bit(AF_DISC_POLLED, &a->flags))\r\ndc->flags |= DCF_POLLED;\r\nrq->interrupt_cx = dc;\r\nrq->req_stat = RS_SUCCESS;\r\nif (dc->disc_evt & DCDE_DEV_SCAN) {\r\ndc->disc_evt &= ~DCDE_DEV_SCAN;\r\ndc->flags |= DCF_DEV_SCAN;\r\ndc->state = DCS_BLOCK_DEV_SCAN;\r\n} else if (dc->disc_evt & DCDE_DEV_CHANGE) {\r\ndc->disc_evt &= ~DCDE_DEV_CHANGE;\r\ndc->flags |= DCF_DEV_CHANGE;\r\ndc->state = DCS_DEV_RMV;\r\n}\r\nif (!test_bit(AF_DISC_POLLED, &a->flags))\r\nret = esas2r_disc_continue(a, rq);\r\nelse\r\nret = true;\r\nesas2r_trace_exit();\r\nreturn ret;\r\n}\r\nstatic bool esas2r_disc_continue(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_disc_context *dc =\r\n(struct esas2r_disc_context *)rq->interrupt_cx;\r\nbool rslt;\r\nwhile (dc->flags & (DCF_DEV_CHANGE | DCF_DEV_SCAN)) {\r\nrslt = false;\r\nswitch (dc->state) {\r\ncase DCS_DEV_RMV:\r\nrslt = esas2r_disc_dev_remove(a, rq);\r\nbreak;\r\ncase DCS_DEV_ADD:\r\nrslt = esas2r_disc_dev_add(a, rq);\r\nbreak;\r\ncase DCS_BLOCK_DEV_SCAN:\r\nrslt = esas2r_disc_block_dev_scan(a, rq);\r\nbreak;\r\ncase DCS_RAID_GRP_INFO:\r\nrslt = esas2r_disc_raid_grp_info(a, rq);\r\nbreak;\r\ncase DCS_PART_INFO:\r\nrslt = esas2r_disc_part_info(a, rq);\r\nbreak;\r\ncase DCS_PT_DEV_INFO:\r\nrslt = esas2r_disc_passthru_dev_info(a, rq);\r\nbreak;\r\ncase DCS_PT_DEV_ADDR:\r\nrslt = esas2r_disc_passthru_dev_addr(a, rq);\r\nbreak;\r\ncase DCS_DISC_DONE:\r\ndc->flags &= ~(DCF_DEV_CHANGE | DCF_DEV_SCAN);\r\nbreak;\r\ndefault:\r\nesas2r_bugon();\r\ndc->state = DCS_DISC_DONE;\r\nbreak;\r\n}\r\nif (rslt)\r\nreturn true;\r\n}\r\nrq->interrupt_cx = NULL;\r\nif (!test_bit(AF_DISC_PENDING, &a->flags))\r\nesas2r_disc_fix_curr_requests(a);\r\nclear_bit(AF_DISC_IN_PROG, &a->flags);\r\nreturn esas2r_disc_start_port(a);\r\n}\r\nstatic bool esas2r_disc_start_request(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nunsigned long flags;\r\nif (rq->timeout < ESAS2R_DEFAULT_TMO)\r\nrq->timeout = ESAS2R_DEFAULT_TMO;\r\nrq->req_type = RT_DISC_REQ;\r\nspin_lock_irqsave(&a->queue_lock, flags);\r\nif (!test_bit(AF_CHPRST_PENDING, &a->flags) &&\r\n!test_bit(AF_FLASHING, &a->flags))\r\nesas2r_disc_local_start_request(a, rq);\r\nelse\r\nlist_add_tail(&rq->req_list, &a->defer_list);\r\nspin_unlock_irqrestore(&a->queue_lock, flags);\r\nreturn true;\r\n}\r\nvoid esas2r_disc_local_start_request(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nesas2r_trace_enter();\r\nlist_add_tail(&rq->req_list, &a->active_list);\r\nesas2r_start_vda_request(a, rq);\r\nesas2r_trace_exit();\r\nreturn;\r\n}\r\nstatic void esas2r_disc_abort(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_disc_context *dc =\r\n(struct esas2r_disc_context *)rq->interrupt_cx;\r\nesas2r_trace_enter();\r\ndc->state = DCS_DISC_DONE;\r\nesas2r_trace_exit();\r\n}\r\nstatic bool esas2r_disc_block_dev_scan(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_disc_context *dc =\r\n(struct esas2r_disc_context *)rq->interrupt_cx;\r\nbool rslt;\r\nesas2r_trace_enter();\r\nesas2r_rq_init_request(rq, a);\r\nesas2r_build_mgt_req(a,\r\nrq,\r\nVDAMGT_DEV_SCAN,\r\n0,\r\n0,\r\n0,\r\nNULL);\r\nrq->comp_cb = esas2r_disc_block_dev_scan_cb;\r\nrq->timeout = 30000;\r\nrq->interrupt_cx = dc;\r\nrslt = esas2r_disc_start_request(a, rq);\r\nesas2r_trace_exit();\r\nreturn rslt;\r\n}\r\nstatic void esas2r_disc_block_dev_scan_cb(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_disc_context *dc =\r\n(struct esas2r_disc_context *)rq->interrupt_cx;\r\nunsigned long flags;\r\nesas2r_trace_enter();\r\nspin_lock_irqsave(&a->mem_lock, flags);\r\nif (rq->req_stat == RS_SUCCESS)\r\ndc->scan_gen = rq->func_rsp.mgt_rsp.scan_generation;\r\ndc->state = DCS_RAID_GRP_INFO;\r\ndc->raid_grp_ix = 0;\r\nesas2r_rq_destroy_request(rq, a);\r\nif (!(dc->flags & DCF_POLLED))\r\nesas2r_disc_continue(a, rq);\r\nspin_unlock_irqrestore(&a->mem_lock, flags);\r\nesas2r_trace_exit();\r\n}\r\nstatic bool esas2r_disc_raid_grp_info(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_disc_context *dc =\r\n(struct esas2r_disc_context *)rq->interrupt_cx;\r\nbool rslt;\r\nstruct atto_vda_grp_info *grpinfo;\r\nesas2r_trace_enter();\r\nesas2r_trace("raid_group_idx: %d", dc->raid_grp_ix);\r\nif (dc->raid_grp_ix >= VDA_MAX_RAID_GROUPS) {\r\ndc->state = DCS_DISC_DONE;\r\nesas2r_trace_exit();\r\nreturn false;\r\n}\r\nesas2r_rq_init_request(rq, a);\r\ngrpinfo = &rq->vda_rsp_data->mgt_data.data.grp_info;\r\nmemset(grpinfo, 0, sizeof(struct atto_vda_grp_info));\r\nesas2r_build_mgt_req(a,\r\nrq,\r\nVDAMGT_GRP_INFO,\r\ndc->scan_gen,\r\n0,\r\nsizeof(struct atto_vda_grp_info),\r\nNULL);\r\ngrpinfo->grp_index = dc->raid_grp_ix;\r\nrq->comp_cb = esas2r_disc_raid_grp_info_cb;\r\nrq->interrupt_cx = dc;\r\nrslt = esas2r_disc_start_request(a, rq);\r\nesas2r_trace_exit();\r\nreturn rslt;\r\n}\r\nstatic void esas2r_disc_raid_grp_info_cb(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_disc_context *dc =\r\n(struct esas2r_disc_context *)rq->interrupt_cx;\r\nunsigned long flags;\r\nstruct atto_vda_grp_info *grpinfo;\r\nesas2r_trace_enter();\r\nspin_lock_irqsave(&a->mem_lock, flags);\r\nif (rq->req_stat == RS_SCAN_GEN) {\r\ndc->scan_gen = rq->func_rsp.mgt_rsp.scan_generation;\r\ndc->raid_grp_ix = 0;\r\ngoto done;\r\n}\r\nif (rq->req_stat == RS_SUCCESS) {\r\ngrpinfo = &rq->vda_rsp_data->mgt_data.data.grp_info;\r\nif (grpinfo->status != VDA_GRP_STAT_ONLINE\r\n&& grpinfo->status != VDA_GRP_STAT_DEGRADED) {\r\ndc->raid_grp_ix++;\r\n} else {\r\nmemcpy(&dc->raid_grp_name[0],\r\n&grpinfo->grp_name[0],\r\nsizeof(grpinfo->grp_name));\r\ndc->interleave = le32_to_cpu(grpinfo->interleave);\r\ndc->block_size = le32_to_cpu(grpinfo->block_size);\r\ndc->state = DCS_PART_INFO;\r\ndc->part_num = 0;\r\n}\r\n} else {\r\nif (!(rq->req_stat == RS_GRP_INVALID)) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"A request for RAID group info failed - "\r\n"returned with %x",\r\nrq->req_stat);\r\n}\r\ndc->dev_ix = 0;\r\ndc->state = DCS_PT_DEV_INFO;\r\n}\r\ndone:\r\nesas2r_rq_destroy_request(rq, a);\r\nif (!(dc->flags & DCF_POLLED))\r\nesas2r_disc_continue(a, rq);\r\nspin_unlock_irqrestore(&a->mem_lock, flags);\r\nesas2r_trace_exit();\r\n}\r\nstatic bool esas2r_disc_part_info(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_disc_context *dc =\r\n(struct esas2r_disc_context *)rq->interrupt_cx;\r\nbool rslt;\r\nstruct atto_vdapart_info *partinfo;\r\nesas2r_trace_enter();\r\nesas2r_trace("part_num: %d", dc->part_num);\r\nif (dc->part_num >= VDA_MAX_PARTITIONS) {\r\ndc->state = DCS_RAID_GRP_INFO;\r\ndc->raid_grp_ix++;\r\nesas2r_trace_exit();\r\nreturn false;\r\n}\r\nesas2r_rq_init_request(rq, a);\r\npartinfo = &rq->vda_rsp_data->mgt_data.data.part_info;\r\nmemset(partinfo, 0, sizeof(struct atto_vdapart_info));\r\nesas2r_build_mgt_req(a,\r\nrq,\r\nVDAMGT_PART_INFO,\r\ndc->scan_gen,\r\n0,\r\nsizeof(struct atto_vdapart_info),\r\nNULL);\r\npartinfo->part_no = dc->part_num;\r\nmemcpy(&partinfo->grp_name[0],\r\n&dc->raid_grp_name[0],\r\nsizeof(partinfo->grp_name));\r\nrq->comp_cb = esas2r_disc_part_info_cb;\r\nrq->interrupt_cx = dc;\r\nrslt = esas2r_disc_start_request(a, rq);\r\nesas2r_trace_exit();\r\nreturn rslt;\r\n}\r\nstatic void esas2r_disc_part_info_cb(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_disc_context *dc =\r\n(struct esas2r_disc_context *)rq->interrupt_cx;\r\nunsigned long flags;\r\nstruct atto_vdapart_info *partinfo;\r\nesas2r_trace_enter();\r\nspin_lock_irqsave(&a->mem_lock, flags);\r\nif (rq->req_stat == RS_SCAN_GEN) {\r\ndc->scan_gen = rq->func_rsp.mgt_rsp.scan_generation;\r\ndc->raid_grp_ix = 0;\r\ndc->state = DCS_RAID_GRP_INFO;\r\n} else if (rq->req_stat == RS_SUCCESS) {\r\npartinfo = &rq->vda_rsp_data->mgt_data.data.part_info;\r\ndc->part_num = partinfo->part_no;\r\ndc->curr_virt_id = le16_to_cpu(partinfo->target_id);\r\nesas2r_targ_db_add_raid(a, dc);\r\ndc->part_num++;\r\n} else {\r\nif (!(rq->req_stat == RS_PART_LAST)) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"A request for RAID group partition info "\r\n"failed - status:%d", rq->req_stat);\r\n}\r\ndc->state = DCS_RAID_GRP_INFO;\r\ndc->raid_grp_ix++;\r\n}\r\nesas2r_rq_destroy_request(rq, a);\r\nif (!(dc->flags & DCF_POLLED))\r\nesas2r_disc_continue(a, rq);\r\nspin_unlock_irqrestore(&a->mem_lock, flags);\r\nesas2r_trace_exit();\r\n}\r\nstatic bool esas2r_disc_passthru_dev_info(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_disc_context *dc =\r\n(struct esas2r_disc_context *)rq->interrupt_cx;\r\nbool rslt;\r\nstruct atto_vda_devinfo *devinfo;\r\nesas2r_trace_enter();\r\nesas2r_trace("dev_ix: %d", dc->dev_ix);\r\nesas2r_rq_init_request(rq, a);\r\ndevinfo = &rq->vda_rsp_data->mgt_data.data.dev_info;\r\nmemset(devinfo, 0, sizeof(struct atto_vda_devinfo));\r\nesas2r_build_mgt_req(a,\r\nrq,\r\nVDAMGT_DEV_PT_INFO,\r\ndc->scan_gen,\r\ndc->dev_ix,\r\nsizeof(struct atto_vda_devinfo),\r\nNULL);\r\nrq->comp_cb = esas2r_disc_passthru_dev_info_cb;\r\nrq->interrupt_cx = dc;\r\nrslt = esas2r_disc_start_request(a, rq);\r\nesas2r_trace_exit();\r\nreturn rslt;\r\n}\r\nstatic void esas2r_disc_passthru_dev_info_cb(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_disc_context *dc =\r\n(struct esas2r_disc_context *)rq->interrupt_cx;\r\nunsigned long flags;\r\nstruct atto_vda_devinfo *devinfo;\r\nesas2r_trace_enter();\r\nspin_lock_irqsave(&a->mem_lock, flags);\r\nif (rq->req_stat == RS_SCAN_GEN) {\r\ndc->scan_gen = rq->func_rsp.mgt_rsp.scan_generation;\r\ndc->dev_ix = 0;\r\ndc->state = DCS_PT_DEV_INFO;\r\n} else if (rq->req_stat == RS_SUCCESS) {\r\ndevinfo = &rq->vda_rsp_data->mgt_data.data.dev_info;\r\ndc->dev_ix = le16_to_cpu(rq->func_rsp.mgt_rsp.dev_index);\r\ndc->curr_virt_id = le16_to_cpu(devinfo->target_id);\r\nif (le16_to_cpu(devinfo->features) & VDADEVFEAT_PHYS_ID) {\r\ndc->curr_phys_id =\r\nle16_to_cpu(devinfo->phys_target_id);\r\ndc->dev_addr_type = ATTO_GDA_AT_PORT;\r\ndc->state = DCS_PT_DEV_ADDR;\r\nesas2r_trace("curr_virt_id: %d", dc->curr_virt_id);\r\nesas2r_trace("curr_phys_id: %d", dc->curr_phys_id);\r\n} else {\r\ndc->dev_ix++;\r\n}\r\n} else {\r\nif (!(rq->req_stat == RS_DEV_INVALID)) {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"A request for device information failed - "\r\n"status:%d", rq->req_stat);\r\n}\r\ndc->state = DCS_DISC_DONE;\r\n}\r\nesas2r_rq_destroy_request(rq, a);\r\nif (!(dc->flags & DCF_POLLED))\r\nesas2r_disc_continue(a, rq);\r\nspin_unlock_irqrestore(&a->mem_lock, flags);\r\nesas2r_trace_exit();\r\n}\r\nstatic bool esas2r_disc_passthru_dev_addr(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_disc_context *dc =\r\n(struct esas2r_disc_context *)rq->interrupt_cx;\r\nbool rslt;\r\nstruct atto_ioctl *hi;\r\nstruct esas2r_sg_context sgc;\r\nesas2r_trace_enter();\r\nesas2r_rq_init_request(rq, a);\r\nsgc.cur_offset = NULL;\r\nsgc.get_phys_addr = (PGETPHYSADDR)esas2r_disc_get_phys_addr;\r\nsgc.length = offsetof(struct atto_ioctl, data)\r\n+ sizeof(struct atto_hba_get_device_address);\r\nesas2r_sgc_init(&sgc, a, rq, rq->vrq->ioctl.sge);\r\nesas2r_build_ioctl_req(a, rq, sgc.length, VDA_IOCTL_HBA);\r\nif (!esas2r_build_sg_list(a, rq, &sgc)) {\r\nesas2r_rq_destroy_request(rq, a);\r\nesas2r_trace_exit();\r\nreturn false;\r\n}\r\nrq->comp_cb = esas2r_disc_passthru_dev_addr_cb;\r\nrq->interrupt_cx = dc;\r\nhi = (struct atto_ioctl *)a->disc_buffer;\r\nmemset(a->disc_buffer, 0, ESAS2R_DISC_BUF_LEN);\r\nhi->version = ATTO_VER_GET_DEV_ADDR0;\r\nhi->function = ATTO_FUNC_GET_DEV_ADDR;\r\nhi->flags = HBAF_TUNNEL;\r\nhi->data.get_dev_addr.target_id = le32_to_cpu(dc->curr_phys_id);\r\nhi->data.get_dev_addr.addr_type = dc->dev_addr_type;\r\nrslt = esas2r_disc_start_request(a, rq);\r\nesas2r_trace_exit();\r\nreturn rslt;\r\n}\r\nstatic void esas2r_disc_passthru_dev_addr_cb(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_disc_context *dc =\r\n(struct esas2r_disc_context *)rq->interrupt_cx;\r\nstruct esas2r_target *t = NULL;\r\nunsigned long flags;\r\nstruct atto_ioctl *hi;\r\nu16 addrlen;\r\nesas2r_trace_enter();\r\nspin_lock_irqsave(&a->mem_lock, flags);\r\nhi = (struct atto_ioctl *)a->disc_buffer;\r\nif (rq->req_stat == RS_SUCCESS\r\n&& hi->status == ATTO_STS_SUCCESS) {\r\naddrlen = le16_to_cpu(hi->data.get_dev_addr.addr_len);\r\nif (dc->dev_addr_type == ATTO_GDA_AT_PORT) {\r\nif (addrlen == sizeof(u64))\r\nmemcpy(&dc->sas_addr,\r\n&hi->data.get_dev_addr.address[0],\r\naddrlen);\r\nelse\r\nmemset(&dc->sas_addr, 0, sizeof(dc->sas_addr));\r\ndc->dev_addr_type = ATTO_GDA_AT_UNIQUE;\r\ngoto next_dev_addr;\r\n} else {\r\nif (HIBYTE(addrlen) == 0) {\r\nt = esas2r_targ_db_add_pthru(a,\r\ndc,\r\n&hi->data.\r\nget_dev_addr.\r\naddress[0],\r\n(u8)hi->data.\r\nget_dev_addr.\r\naddr_len);\r\nif (t)\r\nmemcpy(&t->sas_addr, &dc->sas_addr,\r\nsizeof(t->sas_addr));\r\n} else {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"an error occurred retrieving the "\r\n"back end data (%s:%d)",\r\n__func__,\r\n__LINE__);\r\n}\r\n}\r\n} else {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"an error occurred retrieving the back end data - "\r\n"rq->req_stat:%d hi->status:%d",\r\nrq->req_stat, hi->status);\r\n}\r\nif (dc->flags & DCF_DEV_SCAN) {\r\ndc->dev_ix++;\r\ndc->state = DCS_PT_DEV_INFO;\r\n} else if (dc->flags & DCF_DEV_CHANGE) {\r\ndc->curr_targ++;\r\ndc->state = DCS_DEV_ADD;\r\n} else {\r\nesas2r_bugon();\r\n}\r\nnext_dev_addr:\r\nesas2r_rq_destroy_request(rq, a);\r\nif (!(dc->flags & DCF_POLLED))\r\nesas2r_disc_continue(a, rq);\r\nspin_unlock_irqrestore(&a->mem_lock, flags);\r\nesas2r_trace_exit();\r\n}\r\nstatic u32 esas2r_disc_get_phys_addr(struct esas2r_sg_context *sgc, u64 *addr)\r\n{\r\nstruct esas2r_adapter *a = sgc->adapter;\r\nif (sgc->length > ESAS2R_DISC_BUF_LEN)\r\nesas2r_bugon();\r\n*addr = a->uncached_phys\r\n+ (u64)((u8 *)a->disc_buffer - a->uncached);\r\nreturn sgc->length;\r\n}\r\nstatic bool esas2r_disc_dev_remove(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_disc_context *dc =\r\n(struct esas2r_disc_context *)rq->interrupt_cx;\r\nstruct esas2r_target *t;\r\nstruct esas2r_target *t2;\r\nesas2r_trace_enter();\r\nfor (t = a->targetdb; t < a->targetdb_end; t++) {\r\nif (t->new_target_state != TS_NOT_PRESENT)\r\ncontinue;\r\nt->new_target_state = TS_INVALID;\r\nt2 =\r\nesas2r_targ_db_find_by_virt_id(a,\r\nesas2r_targ_get_id(t,\r\na));\r\nif (t2)\r\nesas2r_targ_db_remove(a, t2);\r\n}\r\ndc->state = DCS_DEV_ADD;\r\ndc->curr_targ = a->targetdb;\r\nesas2r_trace_exit();\r\nreturn false;\r\n}\r\nstatic bool esas2r_disc_dev_add(struct esas2r_adapter *a,\r\nstruct esas2r_request *rq)\r\n{\r\nstruct esas2r_disc_context *dc =\r\n(struct esas2r_disc_context *)rq->interrupt_cx;\r\nstruct esas2r_target *t = dc->curr_targ;\r\nif (t >= a->targetdb_end) {\r\ndc->state = DCS_DISC_DONE;\r\n} else if (t->new_target_state == TS_PRESENT) {\r\nstruct atto_vda_ae_lu *luevt = &t->lu_event;\r\nesas2r_trace_enter();\r\nt->new_target_state = TS_INVALID;\r\ndc->curr_virt_id = esas2r_targ_get_id(t, a);\r\nif ((luevt->hdr.bylength >= offsetof(struct atto_vda_ae_lu, id)\r\n+ sizeof(struct atto_vda_ae_lu_tgt_lun_raid))\r\n&& !(luevt->dwevent & VDAAE_LU_PASSTHROUGH)) {\r\ndc->block_size = luevt->id.tgtlun_raid.dwblock_size;\r\ndc->interleave = luevt->id.tgtlun_raid.dwinterleave;\r\n} else {\r\ndc->block_size = 0;\r\ndc->interleave = 0;\r\n}\r\nif (luevt->dwevent & VDAAE_LU_PASSTHROUGH) {\r\nif (luevt->dwevent & VDAAE_LU_PHYS_ID) {\r\ndc->state = DCS_PT_DEV_ADDR;\r\ndc->dev_addr_type = ATTO_GDA_AT_PORT;\r\ndc->curr_phys_id = luevt->wphys_target_id;\r\n} else {\r\nesas2r_log(ESAS2R_LOG_WARN,\r\n"luevt->dwevent does not have the "\r\n"VDAAE_LU_PHYS_ID bit set (%s:%d)",\r\n__func__, __LINE__);\r\n}\r\n} else {\r\ndc->raid_grp_name[0] = 0;\r\nesas2r_targ_db_add_raid(a, dc);\r\n}\r\nesas2r_trace("curr_virt_id: %d", dc->curr_virt_id);\r\nesas2r_trace("curr_phys_id: %d", dc->curr_phys_id);\r\nesas2r_trace("dwevent: %d", luevt->dwevent);\r\nesas2r_trace_exit();\r\n}\r\nif (dc->state == DCS_DEV_ADD) {\r\ndc->curr_targ++;\r\n}\r\nreturn false;\r\n}\r\nstatic void esas2r_disc_fix_curr_requests(struct esas2r_adapter *a)\r\n{\r\nunsigned long flags;\r\nstruct esas2r_target *t;\r\nstruct esas2r_request *rq;\r\nstruct list_head *element;\r\nspin_lock_irqsave(&a->queue_lock, flags);\r\nlist_for_each(element, &a->defer_list) {\r\nrq = list_entry(element, struct esas2r_request, req_list);\r\nif (rq->vrq->scsi.function == VDA_FUNC_SCSI) {\r\nt = a->targetdb + rq->target_id;\r\nif (t->target_state == TS_PRESENT)\r\nrq->vrq->scsi.target_id = le16_to_cpu(\r\nt->virt_targ_id);\r\nelse\r\nrq->req_stat = RS_SEL;\r\n}\r\n}\r\nspin_unlock_irqrestore(&a->queue_lock, flags);\r\n}
