static inline struct echo_device *cl2echo_dev(const struct cl_device *dev)\r\n{\r\nreturn container_of0(dev, struct echo_device, ed_cl);\r\n}\r\nstatic inline struct cl_device *echo_dev2cl(struct echo_device *d)\r\n{\r\nreturn &d->ed_cl;\r\n}\r\nstatic inline struct echo_device *obd2echo_dev(const struct obd_device *obd)\r\n{\r\nreturn cl2echo_dev(lu2cl_dev(obd->obd_lu_dev));\r\n}\r\nstatic inline struct cl_object *echo_obj2cl(struct echo_object *eco)\r\n{\r\nreturn &eco->eo_cl;\r\n}\r\nstatic inline struct echo_object *cl2echo_obj(const struct cl_object *o)\r\n{\r\nreturn container_of(o, struct echo_object, eo_cl);\r\n}\r\nstatic inline struct echo_page *cl2echo_page(const struct cl_page_slice *s)\r\n{\r\nreturn container_of(s, struct echo_page, ep_cl);\r\n}\r\nstatic inline struct echo_lock *cl2echo_lock(const struct cl_lock_slice *s)\r\n{\r\nreturn container_of(s, struct echo_lock, el_cl);\r\n}\r\nstatic inline struct cl_lock *echo_lock2cl(const struct echo_lock *ecl)\r\n{\r\nreturn ecl->el_cl.cls_lock;\r\n}\r\nstatic inline struct echo_thread_info *echo_env_info(const struct lu_env *env)\r\n{\r\nstruct echo_thread_info *info;\r\ninfo = lu_context_key_get(&env->le_ctx, &echo_thread_key);\r\nLASSERT(info != NULL);\r\nreturn info;\r\n}\r\nstatic inline\r\nstruct echo_object_conf *cl2echo_conf(const struct cl_object_conf *c)\r\n{\r\nreturn container_of(c, struct echo_object_conf, eoc_cl);\r\n}\r\nstatic struct page *echo_page_vmpage(const struct lu_env *env,\r\nconst struct cl_page_slice *slice)\r\n{\r\nreturn cl2echo_page(slice)->ep_vmpage;\r\n}\r\nstatic int echo_page_own(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *io, int nonblock)\r\n{\r\nstruct echo_page *ep = cl2echo_page(slice);\r\nif (!nonblock)\r\nmutex_lock(&ep->ep_lock);\r\nelse if (!mutex_trylock(&ep->ep_lock))\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic void echo_page_disown(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *io)\r\n{\r\nstruct echo_page *ep = cl2echo_page(slice);\r\nLASSERT(mutex_is_locked(&ep->ep_lock));\r\nmutex_unlock(&ep->ep_lock);\r\n}\r\nstatic void echo_page_discard(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\ncl_page_delete(env, slice->cpl_page);\r\n}\r\nstatic int echo_page_is_vmlocked(const struct lu_env *env,\r\nconst struct cl_page_slice *slice)\r\n{\r\nif (mutex_is_locked(&cl2echo_page(slice)->ep_lock))\r\nreturn -EBUSY;\r\nreturn -ENODATA;\r\n}\r\nstatic void echo_page_completion(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nint ioret)\r\n{\r\nLASSERT(slice->cpl_page->cp_sync_io != NULL);\r\n}\r\nstatic void echo_page_fini(const struct lu_env *env,\r\nstruct cl_page_slice *slice)\r\n{\r\nstruct echo_page *ep = cl2echo_page(slice);\r\nstruct echo_object *eco = cl2echo_obj(slice->cpl_obj);\r\nstruct page *vmpage = ep->ep_vmpage;\r\natomic_dec(&eco->eo_npages);\r\npage_cache_release(vmpage);\r\n}\r\nstatic int echo_page_prep(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic int echo_page_print(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nvoid *cookie, lu_printer_t printer)\r\n{\r\nstruct echo_page *ep = cl2echo_page(slice);\r\n(*printer)(env, cookie, LUSTRE_ECHO_CLIENT_NAME"-page@%p %d vm@%p\n",\r\nep, mutex_is_locked(&ep->ep_lock), ep->ep_vmpage);\r\nreturn 0;\r\n}\r\nstatic void echo_lock_fini(const struct lu_env *env,\r\nstruct cl_lock_slice *slice)\r\n{\r\nstruct echo_lock *ecl = cl2echo_lock(slice);\r\nLASSERT(list_empty(&ecl->el_chain));\r\nOBD_SLAB_FREE_PTR(ecl, echo_lock_kmem);\r\n}\r\nstatic void echo_lock_delete(const struct lu_env *env,\r\nconst struct cl_lock_slice *slice)\r\n{\r\nstruct echo_lock *ecl = cl2echo_lock(slice);\r\nLASSERT(list_empty(&ecl->el_chain));\r\n}\r\nstatic int echo_lock_fits_into(const struct lu_env *env,\r\nconst struct cl_lock_slice *slice,\r\nconst struct cl_lock_descr *need,\r\nconst struct cl_io *unused)\r\n{\r\nreturn 1;\r\n}\r\nstatic int echo_page_init(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_page *page, struct page *vmpage)\r\n{\r\nstruct echo_page *ep = cl_object_page_slice(obj, page);\r\nstruct echo_object *eco = cl2echo_obj(obj);\r\nep->ep_vmpage = vmpage;\r\npage_cache_get(vmpage);\r\nmutex_init(&ep->ep_lock);\r\ncl_page_slice_add(page, &ep->ep_cl, obj, &echo_page_ops);\r\natomic_inc(&eco->eo_npages);\r\nreturn 0;\r\n}\r\nstatic int echo_io_init(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_io *io)\r\n{\r\nreturn 0;\r\n}\r\nstatic int echo_lock_init(const struct lu_env *env,\r\nstruct cl_object *obj, struct cl_lock *lock,\r\nconst struct cl_io *unused)\r\n{\r\nstruct echo_lock *el;\r\nOBD_SLAB_ALLOC_PTR_GFP(el, echo_lock_kmem, GFP_NOFS);\r\nif (el != NULL) {\r\ncl_lock_slice_add(lock, &el->el_cl, obj, &echo_lock_ops);\r\nel->el_object = cl2echo_obj(obj);\r\nINIT_LIST_HEAD(&el->el_chain);\r\natomic_set(&el->el_refcount, 0);\r\n}\r\nreturn el == NULL ? -ENOMEM : 0;\r\n}\r\nstatic int echo_conf_set(const struct lu_env *env, struct cl_object *obj,\r\nconst struct cl_object_conf *conf)\r\n{\r\nreturn 0;\r\n}\r\nstatic int echo_object_init(const struct lu_env *env, struct lu_object *obj,\r\nconst struct lu_object_conf *conf)\r\n{\r\nstruct echo_device *ed = cl2echo_dev(lu2cl_dev(obj->lo_dev));\r\nstruct echo_client_obd *ec = ed->ed_ec;\r\nstruct echo_object *eco = cl2echo_obj(lu2cl(obj));\r\nconst struct cl_object_conf *cconf;\r\nstruct echo_object_conf *econf;\r\nif (ed->ed_next) {\r\nstruct lu_object *below;\r\nstruct lu_device *under;\r\nunder = ed->ed_next;\r\nbelow = under->ld_ops->ldo_object_alloc(env, obj->lo_header,\r\nunder);\r\nif (below == NULL)\r\nreturn -ENOMEM;\r\nlu_object_add(obj, below);\r\n}\r\ncconf = lu2cl_conf(conf);\r\neconf = cl2echo_conf(cconf);\r\nLASSERT(econf->eoc_md);\r\neco->eo_lsm = *econf->eoc_md;\r\n*econf->eoc_md = NULL;\r\neco->eo_dev = ed;\r\natomic_set(&eco->eo_npages, 0);\r\ncl_object_page_init(lu2cl(obj), sizeof(struct echo_page));\r\nspin_lock(&ec->ec_lock);\r\nlist_add_tail(&eco->eo_obj_chain, &ec->ec_objects);\r\nspin_unlock(&ec->ec_lock);\r\nreturn 0;\r\n}\r\nstatic int echo_alloc_memmd(struct echo_device *ed,\r\nstruct lov_stripe_md **lsmp)\r\n{\r\nint lsm_size;\r\nif (ed->ed_next != NULL)\r\nreturn obd_alloc_memmd(ed->ed_ec->ec_exp, lsmp);\r\nlsm_size = lov_stripe_md_size(1);\r\nLASSERT(*lsmp == NULL);\r\nOBD_ALLOC(*lsmp, lsm_size);\r\nif (*lsmp == NULL)\r\nreturn -ENOMEM;\r\nOBD_ALLOC((*lsmp)->lsm_oinfo[0], sizeof(struct lov_oinfo));\r\nif ((*lsmp)->lsm_oinfo[0] == NULL) {\r\nOBD_FREE(*lsmp, lsm_size);\r\nreturn -ENOMEM;\r\n}\r\nloi_init((*lsmp)->lsm_oinfo[0]);\r\n(*lsmp)->lsm_maxbytes = LUSTRE_STRIPE_MAXBYTES;\r\nostid_set_seq_echo(&(*lsmp)->lsm_oi);\r\nreturn lsm_size;\r\n}\r\nstatic int echo_free_memmd(struct echo_device *ed, struct lov_stripe_md **lsmp)\r\n{\r\nint lsm_size;\r\nif (ed->ed_next != NULL)\r\nreturn obd_free_memmd(ed->ed_ec->ec_exp, lsmp);\r\nlsm_size = lov_stripe_md_size(1);\r\nLASSERT(*lsmp != NULL);\r\nOBD_FREE((*lsmp)->lsm_oinfo[0], sizeof(struct lov_oinfo));\r\nOBD_FREE(*lsmp, lsm_size);\r\n*lsmp = NULL;\r\nreturn 0;\r\n}\r\nstatic void echo_object_free(const struct lu_env *env, struct lu_object *obj)\r\n{\r\nstruct echo_object *eco = cl2echo_obj(lu2cl(obj));\r\nstruct echo_client_obd *ec = eco->eo_dev->ed_ec;\r\nLASSERT(atomic_read(&eco->eo_npages) == 0);\r\nspin_lock(&ec->ec_lock);\r\nlist_del_init(&eco->eo_obj_chain);\r\nspin_unlock(&ec->ec_lock);\r\nlu_object_fini(obj);\r\nlu_object_header_fini(obj->lo_header);\r\nif (eco->eo_lsm)\r\necho_free_memmd(eco->eo_dev, &eco->eo_lsm);\r\nOBD_SLAB_FREE_PTR(eco, echo_object_kmem);\r\n}\r\nstatic int echo_object_print(const struct lu_env *env, void *cookie,\r\nlu_printer_t p, const struct lu_object *o)\r\n{\r\nstruct echo_object *obj = cl2echo_obj(lu2cl(o));\r\nreturn (*p)(env, cookie, "echoclient-object@%p", obj);\r\n}\r\nstatic struct lu_object *echo_object_alloc(const struct lu_env *env,\r\nconst struct lu_object_header *hdr,\r\nstruct lu_device *dev)\r\n{\r\nstruct echo_object *eco;\r\nstruct lu_object *obj = NULL;\r\nLASSERT(hdr == NULL);\r\nOBD_SLAB_ALLOC_PTR_GFP(eco, echo_object_kmem, GFP_NOFS);\r\nif (eco != NULL) {\r\nstruct cl_object_header *hdr = &eco->eo_hdr;\r\nobj = &echo_obj2cl(eco)->co_lu;\r\ncl_object_header_init(hdr);\r\nlu_object_init(obj, &hdr->coh_lu, dev);\r\nlu_object_add_top(&hdr->coh_lu, obj);\r\neco->eo_cl.co_ops = &echo_cl_obj_ops;\r\nobj->lo_ops = &echo_lu_obj_ops;\r\n}\r\nreturn obj;\r\n}\r\nstatic int echo_site_init(const struct lu_env *env, struct echo_device *ed)\r\n{\r\nstruct cl_site *site = &ed->ed_site_myself;\r\nint rc;\r\nrc = cl_site_init(site, &ed->ed_cl);\r\nif (rc) {\r\nCERROR("Cannot initialize site for echo client(%d)\n", rc);\r\nreturn rc;\r\n}\r\nrc = lu_site_init_finish(&site->cs_lu);\r\nif (rc)\r\nreturn rc;\r\ned->ed_site = site;\r\nreturn 0;\r\n}\r\nstatic void echo_site_fini(const struct lu_env *env, struct echo_device *ed)\r\n{\r\nif (ed->ed_site) {\r\ncl_site_fini(ed->ed_site);\r\ned->ed_site = NULL;\r\n}\r\n}\r\nstatic void *echo_thread_key_init(const struct lu_context *ctx,\r\nstruct lu_context_key *key)\r\n{\r\nstruct echo_thread_info *info;\r\nOBD_SLAB_ALLOC_PTR_GFP(info, echo_thread_kmem, GFP_NOFS);\r\nif (info == NULL)\r\ninfo = ERR_PTR(-ENOMEM);\r\nreturn info;\r\n}\r\nstatic void echo_thread_key_fini(const struct lu_context *ctx,\r\nstruct lu_context_key *key, void *data)\r\n{\r\nstruct echo_thread_info *info = data;\r\nOBD_SLAB_FREE_PTR(info, echo_thread_kmem);\r\n}\r\nstatic void echo_thread_key_exit(const struct lu_context *ctx,\r\nstruct lu_context_key *key, void *data)\r\n{\r\n}\r\nstatic void *echo_session_key_init(const struct lu_context *ctx,\r\nstruct lu_context_key *key)\r\n{\r\nstruct echo_session_info *session;\r\nOBD_SLAB_ALLOC_PTR_GFP(session, echo_session_kmem, GFP_NOFS);\r\nif (session == NULL)\r\nsession = ERR_PTR(-ENOMEM);\r\nreturn session;\r\n}\r\nstatic void echo_session_key_fini(const struct lu_context *ctx,\r\nstruct lu_context_key *key, void *data)\r\n{\r\nstruct echo_session_info *session = data;\r\nOBD_SLAB_FREE_PTR(session, echo_session_kmem);\r\n}\r\nstatic void echo_session_key_exit(const struct lu_context *ctx,\r\nstruct lu_context_key *key, void *data)\r\n{\r\n}\r\nstatic struct lu_device *echo_device_alloc(const struct lu_env *env,\r\nstruct lu_device_type *t,\r\nstruct lustre_cfg *cfg)\r\n{\r\nstruct lu_device *next;\r\nstruct echo_device *ed;\r\nstruct cl_device *cd;\r\nstruct obd_device *obd = NULL;\r\nstruct obd_device *tgt;\r\nconst char *tgt_type_name;\r\nint rc;\r\nint cleanup = 0;\r\nOBD_ALLOC_PTR(ed);\r\nif (ed == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\ncleanup = 1;\r\ncd = &ed->ed_cl;\r\nrc = cl_device_init(cd, t);\r\nif (rc)\r\ngoto out;\r\ncd->cd_lu_dev.ld_ops = &echo_device_lu_ops;\r\ncd->cd_ops = &echo_device_cl_ops;\r\ncleanup = 2;\r\nobd = class_name2obd(lustre_cfg_string(cfg, 0));\r\nLASSERT(obd != NULL);\r\nLASSERT(env != NULL);\r\ntgt = class_name2obd(lustre_cfg_string(cfg, 1));\r\nif (tgt == NULL) {\r\nCERROR("Can not find tgt device %s\n",\r\nlustre_cfg_string(cfg, 1));\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nnext = tgt->obd_lu_dev;\r\nif (!strcmp(tgt->obd_type->typ_name, LUSTRE_MDT_NAME)) {\r\nCERROR("echo MDT client must be run on server\n");\r\nrc = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nrc = echo_site_init(env, ed);\r\nif (rc)\r\ngoto out;\r\ncleanup = 3;\r\nrc = echo_client_setup(env, obd, cfg);\r\nif (rc)\r\ngoto out;\r\ned->ed_ec = &obd->u.echo_client;\r\ncleanup = 4;\r\nif (next != NULL && !lu_device_is_cl(next))\r\nnext = NULL;\r\ntgt_type_name = tgt->obd_type->typ_name;\r\nif (next != NULL) {\r\nLASSERT(next != NULL);\r\nif (next->ld_site != NULL) {\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\nnext->ld_site = &ed->ed_site->cs_lu;\r\nrc = next->ld_type->ldt_ops->ldto_device_init(env, next,\r\nnext->ld_type->ldt_name,\r\nNULL);\r\nif (rc)\r\ngoto out;\r\nif (strcmp(tgt_type_name, LUSTRE_LOV_NAME) == 0)\r\ned->ed_next_islov = 1;\r\nelse\r\nLASSERT(strcmp(tgt_type_name,\r\nLUSTRE_OSC_NAME) == 0);\r\n} else {\r\nLASSERT(strcmp(tgt_type_name, LUSTRE_OST_NAME) == 0);\r\n}\r\ned->ed_next = next;\r\nreturn &cd->cd_lu_dev;\r\nout:\r\nswitch (cleanup) {\r\ncase 4: {\r\nint rc2;\r\nrc2 = echo_client_cleanup(obd);\r\nif (rc2)\r\nCERROR("Cleanup obd device %s error(%d)\n",\r\nobd->obd_name, rc2);\r\n}\r\ncase 3:\r\necho_site_fini(env, ed);\r\ncase 2:\r\ncl_device_fini(&ed->ed_cl);\r\ncase 1:\r\nOBD_FREE_PTR(ed);\r\ncase 0:\r\ndefault:\r\nbreak;\r\n}\r\nreturn ERR_PTR(rc);\r\n}\r\nstatic int echo_device_init(const struct lu_env *env, struct lu_device *d,\r\nconst char *name, struct lu_device *next)\r\n{\r\nLBUG();\r\nreturn 0;\r\n}\r\nstatic struct lu_device *echo_device_fini(const struct lu_env *env,\r\nstruct lu_device *d)\r\n{\r\nstruct echo_device *ed = cl2echo_dev(lu2cl_dev(d));\r\nstruct lu_device *next = ed->ed_next;\r\nwhile (next)\r\nnext = next->ld_type->ldt_ops->ldto_device_fini(env, next);\r\nreturn NULL;\r\n}\r\nstatic void echo_lock_release(const struct lu_env *env,\r\nstruct echo_lock *ecl,\r\nint still_used)\r\n{\r\nstruct cl_lock *clk = echo_lock2cl(ecl);\r\ncl_lock_get(clk);\r\ncl_unuse(env, clk);\r\ncl_lock_release(env, clk, "ec enqueue", ecl->el_object);\r\nif (!still_used) {\r\ncl_lock_mutex_get(env, clk);\r\ncl_lock_cancel(env, clk);\r\ncl_lock_delete(env, clk);\r\ncl_lock_mutex_put(env, clk);\r\n}\r\ncl_lock_put(env, clk);\r\n}\r\nstatic struct lu_device *echo_device_free(const struct lu_env *env,\r\nstruct lu_device *d)\r\n{\r\nstruct echo_device *ed = cl2echo_dev(lu2cl_dev(d));\r\nstruct echo_client_obd *ec = ed->ed_ec;\r\nstruct echo_object *eco;\r\nstruct lu_device *next = ed->ed_next;\r\nCDEBUG(D_INFO, "echo device:%p is going to be freed, next = %p\n",\r\ned, next);\r\nlu_site_purge(env, &ed->ed_site->cs_lu, -1);\r\nspin_lock(&ec->ec_lock);\r\nlist_for_each_entry(eco, &ec->ec_objects, eo_obj_chain)\r\neco->eo_deleted = 1;\r\nspin_unlock(&ec->ec_lock);\r\nlu_site_purge(env, &ed->ed_site->cs_lu, -1);\r\nCDEBUG(D_INFO,\r\n"Waiting for the reference of echo object to be dropped\n");\r\nspin_lock(&ec->ec_lock);\r\nwhile (!list_empty(&ec->ec_objects)) {\r\nspin_unlock(&ec->ec_lock);\r\nCERROR("echo_client still has objects at cleanup time, wait for 1 second\n");\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(cfs_time_seconds(1));\r\nlu_site_purge(env, &ed->ed_site->cs_lu, -1);\r\nspin_lock(&ec->ec_lock);\r\n}\r\nspin_unlock(&ec->ec_lock);\r\nLASSERT(list_empty(&ec->ec_locks));\r\nCDEBUG(D_INFO, "No object exists, exiting...\n");\r\necho_client_cleanup(d->ld_obd);\r\nwhile (next)\r\nnext = next->ld_type->ldt_ops->ldto_device_free(env, next);\r\nLASSERT(ed->ed_site == lu2cl_site(d->ld_site));\r\necho_site_fini(env, ed);\r\ncl_device_fini(&ed->ed_cl);\r\nOBD_FREE_PTR(ed);\r\nreturn NULL;\r\n}\r\nstatic struct echo_object *cl_echo_object_find(struct echo_device *d,\r\nstruct lov_stripe_md **lsmp)\r\n{\r\nstruct lu_env *env;\r\nstruct echo_thread_info *info;\r\nstruct echo_object_conf *conf;\r\nstruct lov_stripe_md *lsm;\r\nstruct echo_object *eco;\r\nstruct cl_object *obj;\r\nstruct lu_fid *fid;\r\nint refcheck;\r\nint rc;\r\nLASSERT(lsmp);\r\nlsm = *lsmp;\r\nLASSERT(lsm);\r\nLASSERTF(ostid_id(&lsm->lsm_oi) != 0, DOSTID"\n", POSTID(&lsm->lsm_oi));\r\nLASSERTF(ostid_seq(&lsm->lsm_oi) == FID_SEQ_ECHO, DOSTID"\n",\r\nPOSTID(&lsm->lsm_oi));\r\nif (echo_dev2cl(d)->cd_lu_dev.ld_obd->obd_stopping)\r\nreturn ERR_PTR(-ENODEV);\r\nenv = cl_env_get(&refcheck);\r\nif (IS_ERR(env))\r\nreturn (void *)env;\r\ninfo = echo_env_info(env);\r\nconf = &info->eti_conf;\r\nif (d->ed_next) {\r\nif (!d->ed_next_islov) {\r\nstruct lov_oinfo *oinfo = lsm->lsm_oinfo[0];\r\nLASSERT(oinfo != NULL);\r\noinfo->loi_oi = lsm->lsm_oi;\r\nconf->eoc_cl.u.coc_oinfo = oinfo;\r\n} else {\r\nstruct lustre_md *md;\r\nmd = &info->eti_md;\r\nmemset(md, 0, sizeof(*md));\r\nmd->lsm = lsm;\r\nconf->eoc_cl.u.coc_md = md;\r\n}\r\n}\r\nconf->eoc_md = lsmp;\r\nfid = &info->eti_fid;\r\nrc = ostid_to_fid(fid, &lsm->lsm_oi, 0);\r\nif (rc != 0) {\r\neco = ERR_PTR(rc);\r\ngoto out;\r\n}\r\nobj = cl_object_find(env, echo_dev2cl(d), fid, &conf->eoc_cl);\r\nif (IS_ERR(obj)) {\r\neco = (void *)obj;\r\ngoto out;\r\n}\r\neco = cl2echo_obj(obj);\r\nif (eco->eo_deleted) {\r\ncl_object_put(env, obj);\r\neco = ERR_PTR(-EAGAIN);\r\n}\r\nout:\r\ncl_env_put(env, &refcheck);\r\nreturn eco;\r\n}\r\nstatic int cl_echo_object_put(struct echo_object *eco)\r\n{\r\nstruct lu_env *env;\r\nstruct cl_object *obj = echo_obj2cl(eco);\r\nint refcheck;\r\nenv = cl_env_get(&refcheck);\r\nif (IS_ERR(env))\r\nreturn PTR_ERR(env);\r\nif (eco->eo_deleted) {\r\nstruct lu_object_header *loh = obj->co_lu.lo_header;\r\nLASSERT(&eco->eo_hdr == luh2coh(loh));\r\nset_bit(LU_OBJECT_HEARD_BANSHEE, &loh->loh_flags);\r\n}\r\ncl_object_put(env, obj);\r\ncl_env_put(env, &refcheck);\r\nreturn 0;\r\n}\r\nstatic int cl_echo_enqueue0(struct lu_env *env, struct echo_object *eco,\r\nu64 start, u64 end, int mode,\r\n__u64 *cookie , __u32 enqflags)\r\n{\r\nstruct cl_io *io;\r\nstruct cl_lock *lck;\r\nstruct cl_object *obj;\r\nstruct cl_lock_descr *descr;\r\nstruct echo_thread_info *info;\r\nint rc = -ENOMEM;\r\ninfo = echo_env_info(env);\r\nio = &info->eti_io;\r\ndescr = &info->eti_descr;\r\nobj = echo_obj2cl(eco);\r\ndescr->cld_obj = obj;\r\ndescr->cld_start = cl_index(obj, start);\r\ndescr->cld_end = cl_index(obj, end);\r\ndescr->cld_mode = mode == LCK_PW ? CLM_WRITE : CLM_READ;\r\ndescr->cld_enq_flags = enqflags;\r\nio->ci_obj = obj;\r\nlck = cl_lock_request(env, io, descr, "ec enqueue", eco);\r\nif (lck) {\r\nstruct echo_client_obd *ec = eco->eo_dev->ed_ec;\r\nstruct echo_lock *el;\r\nrc = cl_wait(env, lck);\r\nif (rc == 0) {\r\nel = cl2echo_lock(cl_lock_at(lck, &echo_device_type));\r\nspin_lock(&ec->ec_lock);\r\nif (list_empty(&el->el_chain)) {\r\nlist_add(&el->el_chain, &ec->ec_locks);\r\nel->el_cookie = ++ec->ec_unique;\r\n}\r\natomic_inc(&el->el_refcount);\r\n*cookie = el->el_cookie;\r\nspin_unlock(&ec->ec_lock);\r\n} else {\r\ncl_lock_release(env, lck, "ec enqueue", current);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int cl_echo_enqueue(struct echo_object *eco, u64 start, u64 end,\r\nint mode, __u64 *cookie)\r\n{\r\nstruct echo_thread_info *info;\r\nstruct lu_env *env;\r\nstruct cl_io *io;\r\nint refcheck;\r\nint result;\r\nenv = cl_env_get(&refcheck);\r\nif (IS_ERR(env))\r\nreturn PTR_ERR(env);\r\ninfo = echo_env_info(env);\r\nio = &info->eti_io;\r\nio->ci_ignore_layout = 1;\r\nresult = cl_io_init(env, io, CIT_MISC, echo_obj2cl(eco));\r\nif (result < 0)\r\ngoto out;\r\nLASSERT(result == 0);\r\nresult = cl_echo_enqueue0(env, eco, start, end, mode, cookie, 0);\r\ncl_io_fini(env, io);\r\nout:\r\ncl_env_put(env, &refcheck);\r\nreturn result;\r\n}\r\nstatic int cl_echo_cancel0(struct lu_env *env, struct echo_device *ed,\r\n__u64 cookie)\r\n{\r\nstruct echo_client_obd *ec = ed->ed_ec;\r\nstruct echo_lock *ecl = NULL;\r\nstruct list_head *el;\r\nint found = 0, still_used = 0;\r\nLASSERT(ec != NULL);\r\nspin_lock(&ec->ec_lock);\r\nlist_for_each (el, &ec->ec_locks) {\r\necl = list_entry (el, struct echo_lock, el_chain);\r\nCDEBUG(D_INFO, "ecl: %p, cookie: %#llx\n", ecl, ecl->el_cookie);\r\nfound = (ecl->el_cookie == cookie);\r\nif (found) {\r\nif (atomic_dec_and_test(&ecl->el_refcount))\r\nlist_del_init(&ecl->el_chain);\r\nelse\r\nstill_used = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&ec->ec_lock);\r\nif (!found)\r\nreturn -ENOENT;\r\necho_lock_release(env, ecl, still_used);\r\nreturn 0;\r\n}\r\nstatic int cl_echo_cancel(struct echo_device *ed, __u64 cookie)\r\n{\r\nstruct lu_env *env;\r\nint refcheck;\r\nint rc;\r\nenv = cl_env_get(&refcheck);\r\nif (IS_ERR(env))\r\nreturn PTR_ERR(env);\r\nrc = cl_echo_cancel0(env, ed, cookie);\r\ncl_env_put(env, &refcheck);\r\nreturn rc;\r\n}\r\nstatic int cl_echo_async_brw(const struct lu_env *env, struct cl_io *io,\r\nenum cl_req_type unused, struct cl_2queue *queue)\r\n{\r\nstruct cl_page *clp;\r\nstruct cl_page *temp;\r\nint result = 0;\r\ncl_page_list_for_each_safe(clp, temp, &queue->c2_qin) {\r\nint rc;\r\nrc = cl_page_cache_add(env, io, clp, CRT_WRITE);\r\nif (rc == 0)\r\ncontinue;\r\nresult = result ?: rc;\r\n}\r\nreturn result;\r\n}\r\nstatic int cl_echo_object_brw(struct echo_object *eco, int rw, u64 offset,\r\nstruct page **pages, int npages, int async)\r\n{\r\nstruct lu_env *env;\r\nstruct echo_thread_info *info;\r\nstruct cl_object *obj = echo_obj2cl(eco);\r\nstruct echo_device *ed = eco->eo_dev;\r\nstruct cl_2queue *queue;\r\nstruct cl_io *io;\r\nstruct cl_page *clp;\r\nstruct lustre_handle lh = { 0 };\r\nint page_size = cl_page_size(obj);\r\nint refcheck;\r\nint rc;\r\nint i;\r\nLASSERT((offset & ~CFS_PAGE_MASK) == 0);\r\nLASSERT(ed->ed_next != NULL);\r\nenv = cl_env_get(&refcheck);\r\nif (IS_ERR(env))\r\nreturn PTR_ERR(env);\r\ninfo = echo_env_info(env);\r\nio = &info->eti_io;\r\nqueue = &info->eti_queue;\r\ncl_2queue_init(queue);\r\nio->ci_ignore_layout = 1;\r\nrc = cl_io_init(env, io, CIT_MISC, obj);\r\nif (rc < 0)\r\ngoto out;\r\nLASSERT(rc == 0);\r\nrc = cl_echo_enqueue0(env, eco, offset,\r\noffset + npages * PAGE_CACHE_SIZE - 1,\r\nrw == READ ? LCK_PR : LCK_PW, &lh.cookie,\r\nCEF_NEVER);\r\nif (rc < 0)\r\ngoto error_lock;\r\nfor (i = 0; i < npages; i++) {\r\nLASSERT(pages[i]);\r\nclp = cl_page_find(env, obj, cl_index(obj, offset),\r\npages[i], CPT_TRANSIENT);\r\nif (IS_ERR(clp)) {\r\nrc = PTR_ERR(clp);\r\nbreak;\r\n}\r\nLASSERT(clp->cp_type == CPT_TRANSIENT);\r\nrc = cl_page_own(env, io, clp);\r\nif (rc) {\r\nLASSERT(clp->cp_state == CPS_FREEING);\r\ncl_page_put(env, clp);\r\nbreak;\r\n}\r\ncl_2queue_add(queue, clp);\r\ncl_page_put(env, clp);\r\ncl_page_clip(env, clp, 0, page_size);\r\noffset += page_size;\r\n}\r\nif (rc == 0) {\r\nenum cl_req_type typ = rw == READ ? CRT_READ : CRT_WRITE;\r\nasync = async && (typ == CRT_WRITE);\r\nif (async)\r\nrc = cl_echo_async_brw(env, io, typ, queue);\r\nelse\r\nrc = cl_io_submit_sync(env, io, typ, queue, 0);\r\nCDEBUG(D_INFO, "echo_client %s write returns %d\n",\r\nasync ? "async" : "sync", rc);\r\n}\r\ncl_echo_cancel0(env, ed, lh.cookie);\r\nerror_lock:\r\ncl_2queue_discard(env, io, queue);\r\ncl_2queue_disown(env, io, queue);\r\ncl_2queue_fini(env, queue);\r\ncl_io_fini(env, io);\r\nout:\r\ncl_env_put(env, &refcheck);\r\nreturn rc;\r\n}\r\nstatic int\r\necho_copyout_lsm (struct lov_stripe_md *lsm, void *_ulsm, int ulsm_nob)\r\n{\r\nstruct lov_stripe_md *ulsm = _ulsm;\r\nint nob, i;\r\nnob = offsetof (struct lov_stripe_md, lsm_oinfo[lsm->lsm_stripe_count]);\r\nif (nob > ulsm_nob)\r\nreturn -EINVAL;\r\nif (copy_to_user (ulsm, lsm, sizeof(*ulsm)))\r\nreturn -EFAULT;\r\nfor (i = 0; i < lsm->lsm_stripe_count; i++) {\r\nif (copy_to_user (ulsm->lsm_oinfo[i], lsm->lsm_oinfo[i],\r\nsizeof(lsm->lsm_oinfo[0])))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\necho_copyin_lsm (struct echo_device *ed, struct lov_stripe_md *lsm,\r\nvoid *ulsm, int ulsm_nob)\r\n{\r\nstruct echo_client_obd *ec = ed->ed_ec;\r\nint i;\r\nif (ulsm_nob < sizeof (*lsm))\r\nreturn -EINVAL;\r\nif (copy_from_user (lsm, ulsm, sizeof (*lsm)))\r\nreturn -EFAULT;\r\nif (lsm->lsm_stripe_count > ec->ec_nstripes ||\r\nlsm->lsm_magic != LOV_MAGIC ||\r\n(lsm->lsm_stripe_size & (~CFS_PAGE_MASK)) != 0 ||\r\n((__u64)lsm->lsm_stripe_size * lsm->lsm_stripe_count > ~0UL))\r\nreturn -EINVAL;\r\nfor (i = 0; i < lsm->lsm_stripe_count; i++) {\r\nif (copy_from_user(lsm->lsm_oinfo[i],\r\n((struct lov_stripe_md *)ulsm)-> \\r\nlsm_oinfo[i],\r\nsizeof(lsm->lsm_oinfo[0])))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int echo_create_object(const struct lu_env *env, struct echo_device *ed,\r\nint on_target, struct obdo *oa, void *ulsm,\r\nint ulsm_nob, struct obd_trans_info *oti)\r\n{\r\nstruct echo_object *eco;\r\nstruct echo_client_obd *ec = ed->ed_ec;\r\nstruct lov_stripe_md *lsm = NULL;\r\nint rc;\r\nint created = 0;\r\nif ((oa->o_valid & OBD_MD_FLID) == 0 &&\r\n(on_target ||\r\nec->ec_nstripes != 0)) {\r\nCERROR ("No valid oid\n");\r\nreturn -EINVAL;\r\n}\r\nrc = echo_alloc_memmd(ed, &lsm);\r\nif (rc < 0) {\r\nCERROR("Cannot allocate md: rc = %d\n", rc);\r\ngoto failed;\r\n}\r\nif (ulsm != NULL) {\r\nint i, idx;\r\nrc = echo_copyin_lsm (ed, lsm, ulsm, ulsm_nob);\r\nif (rc != 0)\r\ngoto failed;\r\nif (lsm->lsm_stripe_count == 0)\r\nlsm->lsm_stripe_count = ec->ec_nstripes;\r\nif (lsm->lsm_stripe_size == 0)\r\nlsm->lsm_stripe_size = PAGE_CACHE_SIZE;\r\nidx = cfs_rand();\r\nfor (i = 0; i < lsm->lsm_stripe_count; i++) {\r\nif (ostid_id(&lsm->lsm_oinfo[i]->loi_oi) == 0)\r\nlsm->lsm_oinfo[i]->loi_oi = lsm->lsm_oi;\r\nlsm->lsm_oinfo[i]->loi_ost_idx =\r\n(idx + i) % ec->ec_nstripes;\r\n}\r\n}\r\nif (oa->o_valid & OBD_MD_FLID) {\r\nLASSERT(oa->o_valid & OBD_MD_FLGROUP);\r\nlsm->lsm_oi = oa->o_oi;\r\n}\r\nif (ostid_id(&lsm->lsm_oi) == 0)\r\nostid_set_id(&lsm->lsm_oi, ++last_object_id);\r\nrc = 0;\r\nif (on_target) {\r\nLASSERT((oa->o_valid & OBD_MD_FLGROUP) &&\r\n(ostid_seq(&oa->o_oi) == FID_SEQ_ECHO));\r\nrc = obd_create(env, ec->ec_exp, oa, &lsm, oti);\r\nif (rc != 0) {\r\nCERROR("Cannot create objects: rc = %d\n", rc);\r\ngoto failed;\r\n}\r\ncreated = 1;\r\n}\r\noa->o_oi = lsm->lsm_oi;\r\noa->o_valid |= OBD_MD_FLID;\r\neco = cl_echo_object_find(ed, &lsm);\r\nif (IS_ERR(eco)) {\r\nrc = PTR_ERR(eco);\r\ngoto failed;\r\n}\r\ncl_echo_object_put(eco);\r\nCDEBUG(D_INFO, "oa oid "DOSTID"\n", POSTID(&oa->o_oi));\r\nfailed:\r\nif (created && rc)\r\nobd_destroy(env, ec->ec_exp, oa, lsm, oti, NULL, NULL);\r\nif (lsm)\r\necho_free_memmd(ed, &lsm);\r\nif (rc)\r\nCERROR("create object failed with: rc = %d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int echo_get_object(struct echo_object **ecop, struct echo_device *ed,\r\nstruct obdo *oa)\r\n{\r\nstruct lov_stripe_md *lsm = NULL;\r\nstruct echo_object *eco;\r\nint rc;\r\nif ((oa->o_valid & OBD_MD_FLID) == 0 || ostid_id(&oa->o_oi) == 0) {\r\nCERROR ("No valid oid\n");\r\nreturn -EINVAL;\r\n}\r\nrc = echo_alloc_memmd(ed, &lsm);\r\nif (rc < 0)\r\nreturn rc;\r\nlsm->lsm_oi = oa->o_oi;\r\nif (!(oa->o_valid & OBD_MD_FLGROUP))\r\nostid_set_seq_echo(&lsm->lsm_oi);\r\nrc = 0;\r\neco = cl_echo_object_find(ed, &lsm);\r\nif (!IS_ERR(eco))\r\n*ecop = eco;\r\nelse\r\nrc = PTR_ERR(eco);\r\nif (lsm)\r\necho_free_memmd(ed, &lsm);\r\nreturn rc;\r\n}\r\nstatic void echo_put_object(struct echo_object *eco)\r\n{\r\nif (cl_echo_object_put(eco))\r\nCERROR("echo client: drop an object failed");\r\n}\r\nstatic void\r\necho_get_stripe_off_id(struct lov_stripe_md *lsm, u64 *offp, u64 *idp)\r\n{\r\nunsigned long stripe_count;\r\nunsigned long stripe_size;\r\nunsigned long width;\r\nunsigned long woffset;\r\nint stripe_index;\r\nu64 offset;\r\nif (lsm->lsm_stripe_count <= 1)\r\nreturn;\r\noffset = *offp;\r\nstripe_size = lsm->lsm_stripe_size;\r\nstripe_count = lsm->lsm_stripe_count;\r\nwidth = stripe_size * stripe_count;\r\nwoffset = do_div (offset, width);\r\nstripe_index = woffset / stripe_size;\r\n*idp = ostid_id(&lsm->lsm_oinfo[stripe_index]->loi_oi);\r\n*offp = offset * stripe_size + woffset % stripe_size;\r\n}\r\nstatic void\r\necho_client_page_debug_setup(struct lov_stripe_md *lsm,\r\nstruct page *page, int rw, u64 id,\r\nu64 offset, u64 count)\r\n{\r\nchar *addr;\r\nu64 stripe_off;\r\nu64 stripe_id;\r\nint delta;\r\nLASSERT(count == PAGE_CACHE_SIZE);\r\naddr = kmap(page);\r\nfor (delta = 0; delta < PAGE_CACHE_SIZE; delta += OBD_ECHO_BLOCK_SIZE) {\r\nif (rw == OBD_BRW_WRITE) {\r\nstripe_off = offset + delta;\r\nstripe_id = id;\r\necho_get_stripe_off_id(lsm, &stripe_off, &stripe_id);\r\n} else {\r\nstripe_off = 0xdeadbeef00c0ffeeULL;\r\nstripe_id = 0xdeadbeef00c0ffeeULL;\r\n}\r\nblock_debug_setup(addr + delta, OBD_ECHO_BLOCK_SIZE,\r\nstripe_off, stripe_id);\r\n}\r\nkunmap(page);\r\n}\r\nstatic int echo_client_page_debug_check(struct lov_stripe_md *lsm,\r\nstruct page *page, u64 id,\r\nu64 offset, u64 count)\r\n{\r\nu64 stripe_off;\r\nu64 stripe_id;\r\nchar *addr;\r\nint delta;\r\nint rc;\r\nint rc2;\r\nLASSERT(count == PAGE_CACHE_SIZE);\r\naddr = kmap(page);\r\nfor (rc = delta = 0; delta < PAGE_CACHE_SIZE; delta += OBD_ECHO_BLOCK_SIZE) {\r\nstripe_off = offset + delta;\r\nstripe_id = id;\r\necho_get_stripe_off_id (lsm, &stripe_off, &stripe_id);\r\nrc2 = block_debug_check("test_brw",\r\naddr + delta, OBD_ECHO_BLOCK_SIZE,\r\nstripe_off, stripe_id);\r\nif (rc2 != 0) {\r\nCERROR ("Error in echo object %#llx\n", id);\r\nrc = rc2;\r\n}\r\n}\r\nkunmap(page);\r\nreturn rc;\r\n}\r\nstatic int echo_client_kbrw(struct echo_device *ed, int rw, struct obdo *oa,\r\nstruct echo_object *eco, u64 offset,\r\nu64 count, int async,\r\nstruct obd_trans_info *oti)\r\n{\r\nstruct lov_stripe_md *lsm = eco->eo_lsm;\r\nu32 npages;\r\nstruct brw_page *pga;\r\nstruct brw_page *pgp;\r\nstruct page **pages;\r\nu64 off;\r\nint i;\r\nint rc;\r\nint verify;\r\ngfp_t gfp_mask;\r\nint brw_flags = 0;\r\nverify = (ostid_id(&oa->o_oi) != ECHO_PERSISTENT_OBJID &&\r\n(oa->o_valid & OBD_MD_FLFLAGS) != 0 &&\r\n(oa->o_flags & OBD_FL_DEBUG_CHECK) != 0);\r\ngfp_mask = ((ostid_id(&oa->o_oi) & 2) == 0) ? GFP_IOFS : GFP_HIGHUSER;\r\nLASSERT(rw == OBD_BRW_WRITE || rw == OBD_BRW_READ);\r\nLASSERT(lsm != NULL);\r\nLASSERT(ostid_id(&lsm->lsm_oi) == ostid_id(&oa->o_oi));\r\nif (count <= 0 ||\r\n(count & (~CFS_PAGE_MASK)) != 0)\r\nreturn -EINVAL;\r\nnpages = count >> PAGE_CACHE_SHIFT;\r\nif (rw == OBD_BRW_WRITE)\r\nbrw_flags = OBD_BRW_ASYNC;\r\nOBD_ALLOC(pga, npages * sizeof(*pga));\r\nif (pga == NULL)\r\nreturn -ENOMEM;\r\nOBD_ALLOC(pages, npages * sizeof(*pages));\r\nif (pages == NULL) {\r\nOBD_FREE(pga, npages * sizeof(*pga));\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0, pgp = pga, off = offset;\r\ni < npages;\r\ni++, pgp++, off += PAGE_CACHE_SIZE) {\r\nLASSERT (pgp->pg == NULL);\r\nrc = -ENOMEM;\r\nOBD_PAGE_ALLOC(pgp->pg, gfp_mask);\r\nif (pgp->pg == NULL)\r\ngoto out;\r\npages[i] = pgp->pg;\r\npgp->count = PAGE_CACHE_SIZE;\r\npgp->off = off;\r\npgp->flag = brw_flags;\r\nif (verify)\r\necho_client_page_debug_setup(lsm, pgp->pg, rw,\r\nostid_id(&oa->o_oi), off,\r\npgp->count);\r\n}\r\nLASSERT(ed->ed_next != NULL);\r\nrc = cl_echo_object_brw(eco, rw, offset, pages, npages, async);\r\nout:\r\nif (rc != 0 || rw != OBD_BRW_READ)\r\nverify = 0;\r\nfor (i = 0, pgp = pga; i < npages; i++, pgp++) {\r\nif (pgp->pg == NULL)\r\ncontinue;\r\nif (verify) {\r\nint vrc;\r\nvrc = echo_client_page_debug_check(lsm, pgp->pg,\r\nostid_id(&oa->o_oi),\r\npgp->off, pgp->count);\r\nif (vrc != 0 && rc == 0)\r\nrc = vrc;\r\n}\r\nOBD_PAGE_FREE(pgp->pg);\r\n}\r\nOBD_FREE(pga, npages * sizeof(*pga));\r\nOBD_FREE(pages, npages * sizeof(*pages));\r\nreturn rc;\r\n}\r\nstatic int echo_client_prep_commit(const struct lu_env *env,\r\nstruct obd_export *exp, int rw,\r\nstruct obdo *oa, struct echo_object *eco,\r\nu64 offset, u64 count,\r\nu64 batch, struct obd_trans_info *oti,\r\nint async)\r\n{\r\nstruct lov_stripe_md *lsm = eco->eo_lsm;\r\nstruct obd_ioobj ioo;\r\nstruct niobuf_local *lnb;\r\nstruct niobuf_remote *rnb;\r\nu64 off;\r\nu64 npages, tot_pages;\r\nint i, ret = 0, brw_flags = 0;\r\nif (count <= 0 || (count & (~CFS_PAGE_MASK)) != 0 ||\r\n(lsm != NULL && ostid_id(&lsm->lsm_oi) != ostid_id(&oa->o_oi)))\r\nreturn -EINVAL;\r\nnpages = batch >> PAGE_CACHE_SHIFT;\r\ntot_pages = count >> PAGE_CACHE_SHIFT;\r\nOBD_ALLOC(lnb, npages * sizeof(struct niobuf_local));\r\nOBD_ALLOC(rnb, npages * sizeof(struct niobuf_remote));\r\nif (lnb == NULL || rnb == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (rw == OBD_BRW_WRITE && async)\r\nbrw_flags |= OBD_BRW_ASYNC;\r\nobdo_to_ioobj(oa, &ioo);\r\noff = offset;\r\nfor (; tot_pages; tot_pages -= npages) {\r\nint lpages;\r\nif (tot_pages < npages)\r\nnpages = tot_pages;\r\nfor (i = 0; i < npages; i++, off += PAGE_CACHE_SIZE) {\r\nrnb[i].offset = off;\r\nrnb[i].len = PAGE_CACHE_SIZE;\r\nrnb[i].flags = brw_flags;\r\n}\r\nioo.ioo_bufcnt = npages;\r\noti->oti_transno = 0;\r\nlpages = npages;\r\nret = obd_preprw(env, rw, exp, oa, 1, &ioo, rnb, &lpages,\r\nlnb, oti, NULL);\r\nif (ret != 0)\r\ngoto out;\r\nLASSERT(lpages == npages);\r\nfor (i = 0; i < lpages; i++) {\r\nstruct page *page = lnb[i].page;\r\nif (page == NULL && lnb[i].rc == 0)\r\ncontinue;\r\nif (async)\r\nlnb[i].flags |= OBD_BRW_ASYNC;\r\nif (ostid_id(&oa->o_oi) == ECHO_PERSISTENT_OBJID ||\r\n(oa->o_valid & OBD_MD_FLFLAGS) == 0 ||\r\n(oa->o_flags & OBD_FL_DEBUG_CHECK) == 0)\r\ncontinue;\r\nif (rw == OBD_BRW_WRITE)\r\necho_client_page_debug_setup(lsm, page, rw,\r\nostid_id(&oa->o_oi),\r\nrnb[i].offset,\r\nrnb[i].len);\r\nelse\r\necho_client_page_debug_check(lsm, page,\r\nostid_id(&oa->o_oi),\r\nrnb[i].offset,\r\nrnb[i].len);\r\n}\r\nret = obd_commitrw(env, rw, exp, oa, 1, &ioo,\r\nrnb, npages, lnb, oti, ret);\r\nif (ret != 0)\r\ngoto out;\r\nmemset(oti, 0, sizeof(*oti));\r\nlu_context_exit((struct lu_context *)&env->le_ctx);\r\nlu_context_enter((struct lu_context *)&env->le_ctx);\r\n}\r\nout:\r\nif (lnb)\r\nOBD_FREE(lnb, npages * sizeof(struct niobuf_local));\r\nif (rnb)\r\nOBD_FREE(rnb, npages * sizeof(struct niobuf_remote));\r\nreturn ret;\r\n}\r\nstatic int echo_client_brw_ioctl(const struct lu_env *env, int rw,\r\nstruct obd_export *exp,\r\nstruct obd_ioctl_data *data,\r\nstruct obd_trans_info *dummy_oti)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct echo_device *ed = obd2echo_dev(obd);\r\nstruct echo_client_obd *ec = ed->ed_ec;\r\nstruct obdo *oa = &data->ioc_obdo1;\r\nstruct echo_object *eco;\r\nint rc;\r\nint async = 1;\r\nlong test_mode;\r\nLASSERT(oa->o_valid & OBD_MD_FLGROUP);\r\nrc = echo_get_object(&eco, ed, oa);\r\nif (rc)\r\nreturn rc;\r\noa->o_valid &= ~OBD_MD_FLHANDLE;\r\ntest_mode = (long)data->ioc_pbuf1;\r\nif (test_mode == 1)\r\nasync = 0;\r\nif (ed->ed_next == NULL && test_mode != 3) {\r\ntest_mode = 3;\r\ndata->ioc_plen1 = data->ioc_count;\r\n}\r\nif (data->ioc_plen1 > PTLRPC_MAX_BRW_SIZE)\r\ndata->ioc_plen1 = PTLRPC_MAX_BRW_SIZE;\r\nswitch (test_mode) {\r\ncase 1:\r\ncase 2:\r\nrc = echo_client_kbrw(ed, rw, oa,\r\neco, data->ioc_offset,\r\ndata->ioc_count, async, dummy_oti);\r\nbreak;\r\ncase 3:\r\nrc = echo_client_prep_commit(env, ec->ec_exp, rw, oa,\r\neco, data->ioc_offset,\r\ndata->ioc_count, data->ioc_plen1,\r\ndummy_oti, async);\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\n}\r\necho_put_object(eco);\r\nreturn rc;\r\n}\r\nstatic int\r\necho_client_enqueue(struct obd_export *exp, struct obdo *oa,\r\nint mode, u64 offset, u64 nob)\r\n{\r\nstruct echo_device *ed = obd2echo_dev(exp->exp_obd);\r\nstruct lustre_handle *ulh = &oa->o_handle;\r\nstruct echo_object *eco;\r\nu64 end;\r\nint rc;\r\nif (ed->ed_next == NULL)\r\nreturn -EOPNOTSUPP;\r\nif (!(mode == LCK_PR || mode == LCK_PW))\r\nreturn -EINVAL;\r\nif ((offset & (~CFS_PAGE_MASK)) != 0 ||\r\n(nob & (~CFS_PAGE_MASK)) != 0)\r\nreturn -EINVAL;\r\nrc = echo_get_object (&eco, ed, oa);\r\nif (rc != 0)\r\nreturn rc;\r\nend = (nob == 0) ? ((u64) -1) : (offset + nob - 1);\r\nrc = cl_echo_enqueue(eco, offset, end, mode, &ulh->cookie);\r\nif (rc == 0) {\r\noa->o_valid |= OBD_MD_FLHANDLE;\r\nCDEBUG(D_INFO, "Cookie is %#llx\n", ulh->cookie);\r\n}\r\necho_put_object(eco);\r\nreturn rc;\r\n}\r\nstatic int\r\necho_client_cancel(struct obd_export *exp, struct obdo *oa)\r\n{\r\nstruct echo_device *ed = obd2echo_dev(exp->exp_obd);\r\n__u64 cookie = oa->o_handle.cookie;\r\nif ((oa->o_valid & OBD_MD_FLHANDLE) == 0)\r\nreturn -EINVAL;\r\nCDEBUG(D_INFO, "Cookie is %#llx\n", cookie);\r\nreturn cl_echo_cancel(ed, cookie);\r\n}\r\nstatic int\r\necho_client_iocontrol(unsigned int cmd, struct obd_export *exp, int len,\r\nvoid *karg, void *uarg)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct echo_device *ed = obd2echo_dev(obd);\r\nstruct echo_client_obd *ec = ed->ed_ec;\r\nstruct echo_object *eco;\r\nstruct obd_ioctl_data *data = karg;\r\nstruct obd_trans_info dummy_oti;\r\nstruct lu_env *env;\r\nstruct oti_req_ack_lock *ack_lock;\r\nstruct obdo *oa;\r\nstruct lu_fid fid;\r\nint rw = OBD_BRW_READ;\r\nint rc = 0;\r\nint i;\r\nmemset(&dummy_oti, 0, sizeof(dummy_oti));\r\noa = &data->ioc_obdo1;\r\nif (!(oa->o_valid & OBD_MD_FLGROUP)) {\r\noa->o_valid |= OBD_MD_FLGROUP;\r\nostid_set_seq_echo(&oa->o_oi);\r\n}\r\nrc = ostid_to_fid(&fid, &oa->o_oi, 0);\r\nif (rc < 0)\r\nreturn rc;\r\nOBD_ALLOC_PTR(env);\r\nif (env == NULL)\r\nreturn -ENOMEM;\r\nrc = lu_env_init(env, LCT_DT_THREAD);\r\nif (rc) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nswitch (cmd) {\r\ncase OBD_IOC_CREATE:\r\nif (!capable(CFS_CAP_SYS_ADMIN)) {\r\nrc = -EPERM;\r\ngoto out;\r\n}\r\nrc = echo_create_object(env, ed, 1, oa, data->ioc_pbuf1,\r\ndata->ioc_plen1, &dummy_oti);\r\ngoto out;\r\ncase OBD_IOC_DESTROY:\r\nif (!capable(CFS_CAP_SYS_ADMIN)) {\r\nrc = -EPERM;\r\ngoto out;\r\n}\r\nrc = echo_get_object(&eco, ed, oa);\r\nif (rc == 0) {\r\nrc = obd_destroy(env, ec->ec_exp, oa, eco->eo_lsm,\r\n&dummy_oti, NULL, NULL);\r\nif (rc == 0)\r\neco->eo_deleted = 1;\r\necho_put_object(eco);\r\n}\r\ngoto out;\r\ncase OBD_IOC_GETATTR:\r\nrc = echo_get_object(&eco, ed, oa);\r\nif (rc == 0) {\r\nstruct obd_info oinfo = { { { 0 } } };\r\noinfo.oi_md = eco->eo_lsm;\r\noinfo.oi_oa = oa;\r\nrc = obd_getattr(env, ec->ec_exp, &oinfo);\r\necho_put_object(eco);\r\n}\r\ngoto out;\r\ncase OBD_IOC_SETATTR:\r\nif (!capable(CFS_CAP_SYS_ADMIN)) {\r\nrc = -EPERM;\r\ngoto out;\r\n}\r\nrc = echo_get_object(&eco, ed, oa);\r\nif (rc == 0) {\r\nstruct obd_info oinfo = { { { 0 } } };\r\noinfo.oi_oa = oa;\r\noinfo.oi_md = eco->eo_lsm;\r\nrc = obd_setattr(env, ec->ec_exp, &oinfo, NULL);\r\necho_put_object(eco);\r\n}\r\ngoto out;\r\ncase OBD_IOC_BRW_WRITE:\r\nif (!capable(CFS_CAP_SYS_ADMIN)) {\r\nrc = -EPERM;\r\ngoto out;\r\n}\r\nrw = OBD_BRW_WRITE;\r\ncase OBD_IOC_BRW_READ:\r\nrc = echo_client_brw_ioctl(env, rw, exp, data, &dummy_oti);\r\ngoto out;\r\ncase ECHO_IOC_GET_STRIPE:\r\nrc = echo_get_object(&eco, ed, oa);\r\nif (rc == 0) {\r\nrc = echo_copyout_lsm(eco->eo_lsm, data->ioc_pbuf1,\r\ndata->ioc_plen1);\r\necho_put_object(eco);\r\n}\r\ngoto out;\r\ncase ECHO_IOC_SET_STRIPE:\r\nif (!capable(CFS_CAP_SYS_ADMIN)) {\r\nrc = -EPERM;\r\ngoto out;\r\n}\r\nif (data->ioc_pbuf1 == NULL) {\r\nrc = echo_get_object(&eco, ed, oa);\r\nif (rc == 0) {\r\neco->eo_deleted = 1;\r\necho_put_object(eco);\r\n}\r\n} else {\r\nrc = echo_create_object(env, ed, 0, oa,\r\ndata->ioc_pbuf1,\r\ndata->ioc_plen1, &dummy_oti);\r\n}\r\ngoto out;\r\ncase ECHO_IOC_ENQUEUE:\r\nif (!capable(CFS_CAP_SYS_ADMIN)) {\r\nrc = -EPERM;\r\ngoto out;\r\n}\r\nrc = echo_client_enqueue(exp, oa,\r\ndata->ioc_conn1,\r\ndata->ioc_offset,\r\ndata->ioc_count);\r\ngoto out;\r\ncase ECHO_IOC_CANCEL:\r\nrc = echo_client_cancel(exp, oa);\r\ngoto out;\r\ndefault:\r\nCERROR ("echo_ioctl(): unrecognised ioctl %#x\n", cmd);\r\nrc = -ENOTTY;\r\ngoto out;\r\n}\r\nout:\r\nlu_env_fini(env);\r\nOBD_FREE_PTR(env);\r\nfor (ack_lock = dummy_oti.oti_ack_locks, i = 0; i < 4;\r\ni++, ack_lock++) {\r\nif (!ack_lock->mode)\r\nbreak;\r\nldlm_lock_decref(&ack_lock->lock, ack_lock->mode);\r\n}\r\nreturn rc;\r\n}\r\nstatic int echo_client_setup(const struct lu_env *env,\r\nstruct obd_device *obddev, struct lustre_cfg *lcfg)\r\n{\r\nstruct echo_client_obd *ec = &obddev->u.echo_client;\r\nstruct obd_device *tgt;\r\nstruct obd_uuid echo_uuid = { "ECHO_UUID" };\r\nstruct obd_connect_data *ocd = NULL;\r\nint rc;\r\nif (lcfg->lcfg_bufcount < 2 || LUSTRE_CFG_BUFLEN(lcfg, 1) < 1) {\r\nCERROR("requires a TARGET OBD name\n");\r\nreturn -EINVAL;\r\n}\r\ntgt = class_name2obd(lustre_cfg_string(lcfg, 1));\r\nif (!tgt || !tgt->obd_attached || !tgt->obd_set_up) {\r\nCERROR("device not attached or not set up (%s)\n",\r\nlustre_cfg_string(lcfg, 1));\r\nreturn -EINVAL;\r\n}\r\nspin_lock_init(&ec->ec_lock);\r\nINIT_LIST_HEAD (&ec->ec_objects);\r\nINIT_LIST_HEAD (&ec->ec_locks);\r\nec->ec_unique = 0;\r\nec->ec_nstripes = 0;\r\nOBD_ALLOC(ocd, sizeof(*ocd));\r\nif (ocd == NULL) {\r\nCERROR("Can't alloc ocd connecting to %s\n",\r\nlustre_cfg_string(lcfg, 1));\r\nreturn -ENOMEM;\r\n}\r\nocd->ocd_connect_flags = OBD_CONNECT_VERSION | OBD_CONNECT_REQPORTAL |\r\nOBD_CONNECT_BRW_SIZE |\r\nOBD_CONNECT_GRANT | OBD_CONNECT_FULL20 |\r\nOBD_CONNECT_64BITHASH | OBD_CONNECT_LVB_TYPE |\r\nOBD_CONNECT_FID;\r\nocd->ocd_brw_size = DT_MAX_BRW_SIZE;\r\nocd->ocd_version = LUSTRE_VERSION_CODE;\r\nocd->ocd_group = FID_SEQ_ECHO;\r\nrc = obd_connect(env, &ec->ec_exp, tgt, &echo_uuid, ocd, NULL);\r\nif (rc == 0) {\r\nspin_lock(&tgt->obd_dev_lock);\r\nlist_del_init(&ec->ec_exp->exp_obd_chain_timed);\r\nspin_unlock(&tgt->obd_dev_lock);\r\n}\r\nOBD_FREE(ocd, sizeof(*ocd));\r\nif (rc != 0) {\r\nCERROR("fail to connect to device %s\n",\r\nlustre_cfg_string(lcfg, 1));\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}\r\nstatic int echo_client_cleanup(struct obd_device *obddev)\r\n{\r\nstruct echo_client_obd *ec = &obddev->u.echo_client;\r\nint rc;\r\nif (!list_empty(&obddev->obd_exports)) {\r\nCERROR("still has clients!\n");\r\nreturn -EBUSY;\r\n}\r\nLASSERT(atomic_read(&ec->ec_exp->exp_refcount) > 0);\r\nrc = obd_disconnect(ec->ec_exp);\r\nif (rc != 0)\r\nCERROR("fail to disconnect device: %d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int echo_client_connect(const struct lu_env *env,\r\nstruct obd_export **exp,\r\nstruct obd_device *src, struct obd_uuid *cluuid,\r\nstruct obd_connect_data *data, void *localdata)\r\n{\r\nint rc;\r\nstruct lustre_handle conn = { 0 };\r\nrc = class_connect(&conn, src, cluuid);\r\nif (rc == 0) {\r\n*exp = class_conn2export(&conn);\r\n}\r\nreturn rc;\r\n}\r\nstatic int echo_client_disconnect(struct obd_export *exp)\r\n{\r\nint rc;\r\nif (exp == NULL) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = class_disconnect(exp);\r\ngoto out;\r\nout:\r\nreturn rc;\r\n}\r\nint echo_client_init(void)\r\n{\r\nstruct lprocfs_static_vars lvars = { NULL };\r\nint rc;\r\nlprocfs_echo_init_vars(&lvars);\r\nrc = lu_kmem_init(echo_caches);\r\nif (rc == 0) {\r\nrc = class_register_type(&echo_client_obd_ops, NULL,\r\nlvars.module_vars,\r\nLUSTRE_ECHO_CLIENT_NAME,\r\n&echo_device_type);\r\nif (rc)\r\nlu_kmem_fini(echo_caches);\r\n}\r\nreturn rc;\r\n}\r\nvoid echo_client_exit(void)\r\n{\r\nclass_unregister_type(LUSTRE_ECHO_CLIENT_NAME);\r\nlu_kmem_fini(echo_caches);\r\n}\r\nstatic int __init obdecho_init(void)\r\n{\r\nstruct lprocfs_static_vars lvars;\r\nint rc;\r\nLCONSOLE_INFO("Echo OBD driver; http://www.lustre.org/\n");\r\nLASSERT(PAGE_CACHE_SIZE % OBD_ECHO_BLOCK_SIZE == 0);\r\nlprocfs_echo_init_vars(&lvars);\r\nrc = echo_client_init();\r\nreturn rc;\r\n}\r\nstatic void obdecho_exit(void)\r\n{\r\necho_client_exit();\r\n}
