static int samsung_usb2_phy_power_on(struct phy *phy)\r\n{\r\nstruct samsung_usb2_phy_instance *inst = phy_get_drvdata(phy);\r\nstruct samsung_usb2_phy_driver *drv = inst->drv;\r\nint ret;\r\ndev_dbg(drv->dev, "Request to power_on \"%s\" usb phy\n",\r\ninst->cfg->label);\r\nret = clk_prepare_enable(drv->clk);\r\nif (ret)\r\ngoto err_main_clk;\r\nret = clk_prepare_enable(drv->ref_clk);\r\nif (ret)\r\ngoto err_instance_clk;\r\nif (inst->cfg->power_on) {\r\nspin_lock(&drv->lock);\r\nret = inst->cfg->power_on(inst);\r\nspin_unlock(&drv->lock);\r\n}\r\nreturn 0;\r\nerr_instance_clk:\r\nclk_disable_unprepare(drv->clk);\r\nerr_main_clk:\r\nreturn ret;\r\n}\r\nstatic int samsung_usb2_phy_power_off(struct phy *phy)\r\n{\r\nstruct samsung_usb2_phy_instance *inst = phy_get_drvdata(phy);\r\nstruct samsung_usb2_phy_driver *drv = inst->drv;\r\nint ret = 0;\r\ndev_dbg(drv->dev, "Request to power_off \"%s\" usb phy\n",\r\ninst->cfg->label);\r\nif (inst->cfg->power_off) {\r\nspin_lock(&drv->lock);\r\nret = inst->cfg->power_off(inst);\r\nspin_unlock(&drv->lock);\r\n}\r\nclk_disable_unprepare(drv->ref_clk);\r\nclk_disable_unprepare(drv->clk);\r\nreturn ret;\r\n}\r\nstatic struct phy *samsung_usb2_phy_xlate(struct device *dev,\r\nstruct of_phandle_args *args)\r\n{\r\nstruct samsung_usb2_phy_driver *drv;\r\ndrv = dev_get_drvdata(dev);\r\nif (!drv)\r\nreturn ERR_PTR(-EINVAL);\r\nif (WARN_ON(args->args[0] >= drv->cfg->num_phys))\r\nreturn ERR_PTR(-ENODEV);\r\nreturn drv->instances[args->args[0]].phy;\r\n}\r\nstatic int samsung_usb2_phy_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nconst struct samsung_usb2_phy_config *cfg;\r\nstruct device *dev = &pdev->dev;\r\nstruct phy_provider *phy_provider;\r\nstruct resource *mem;\r\nstruct samsung_usb2_phy_driver *drv;\r\nint i, ret;\r\nif (!pdev->dev.of_node) {\r\ndev_err(dev, "This driver is required to be instantiated from device tree\n");\r\nreturn -EINVAL;\r\n}\r\nmatch = of_match_node(samsung_usb2_phy_of_match, pdev->dev.of_node);\r\nif (!match) {\r\ndev_err(dev, "of_match_node() failed\n");\r\nreturn -EINVAL;\r\n}\r\ncfg = match->data;\r\ndrv = devm_kzalloc(dev, sizeof(struct samsung_usb2_phy_driver) +\r\ncfg->num_phys * sizeof(struct samsung_usb2_phy_instance),\r\nGFP_KERNEL);\r\nif (!drv)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, drv);\r\nspin_lock_init(&drv->lock);\r\ndrv->cfg = cfg;\r\ndrv->dev = dev;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndrv->reg_phy = devm_ioremap_resource(dev, mem);\r\nif (IS_ERR(drv->reg_phy)) {\r\ndev_err(dev, "Failed to map register memory (phy)\n");\r\nreturn PTR_ERR(drv->reg_phy);\r\n}\r\ndrv->reg_pmu = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\r\n"samsung,pmureg-phandle");\r\nif (IS_ERR(drv->reg_pmu)) {\r\ndev_err(dev, "Failed to map PMU registers (via syscon)\n");\r\nreturn PTR_ERR(drv->reg_pmu);\r\n}\r\nif (drv->cfg->has_mode_switch) {\r\ndrv->reg_sys = syscon_regmap_lookup_by_phandle(\r\npdev->dev.of_node, "samsung,sysreg-phandle");\r\nif (IS_ERR(drv->reg_sys)) {\r\ndev_err(dev, "Failed to map system registers (via syscon)\n");\r\nreturn PTR_ERR(drv->reg_sys);\r\n}\r\n}\r\ndrv->clk = devm_clk_get(dev, "phy");\r\nif (IS_ERR(drv->clk)) {\r\ndev_err(dev, "Failed to get clock of phy controller\n");\r\nreturn PTR_ERR(drv->clk);\r\n}\r\ndrv->ref_clk = devm_clk_get(dev, "ref");\r\nif (IS_ERR(drv->ref_clk)) {\r\ndev_err(dev, "Failed to get reference clock for the phy controller\n");\r\nreturn PTR_ERR(drv->ref_clk);\r\n}\r\ndrv->ref_rate = clk_get_rate(drv->ref_clk);\r\nif (drv->cfg->rate_to_clk) {\r\nret = drv->cfg->rate_to_clk(drv->ref_rate, &drv->ref_reg_val);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < drv->cfg->num_phys; i++) {\r\nchar *label = drv->cfg->phys[i].label;\r\nstruct samsung_usb2_phy_instance *p = &drv->instances[i];\r\ndev_dbg(dev, "Creating phy \"%s\"\n", label);\r\np->phy = devm_phy_create(dev, NULL, &samsung_usb2_phy_ops);\r\nif (IS_ERR(p->phy)) {\r\ndev_err(drv->dev, "Failed to create usb2_phy \"%s\"\n",\r\nlabel);\r\nreturn PTR_ERR(p->phy);\r\n}\r\np->cfg = &drv->cfg->phys[i];\r\np->drv = drv;\r\nphy_set_bus_width(p->phy, 8);\r\nphy_set_drvdata(p->phy, p);\r\n}\r\nphy_provider = devm_of_phy_provider_register(dev,\r\nsamsung_usb2_phy_xlate);\r\nif (IS_ERR(phy_provider)) {\r\ndev_err(drv->dev, "Failed to register phy provider\n");\r\nreturn PTR_ERR(phy_provider);\r\n}\r\nreturn 0;\r\n}
