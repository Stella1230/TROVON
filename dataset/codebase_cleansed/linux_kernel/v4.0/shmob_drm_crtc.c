static int shmob_drm_clk_on(struct shmob_drm_device *sdev)\r\n{\r\nint ret;\r\nif (sdev->clock) {\r\nret = clk_prepare_enable(sdev->clock);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n#if 0\r\nif (sdev->meram_dev && sdev->meram_dev->pdev)\r\npm_runtime_get_sync(&sdev->meram_dev->pdev->dev);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void shmob_drm_clk_off(struct shmob_drm_device *sdev)\r\n{\r\n#if 0\r\nif (sdev->meram_dev && sdev->meram_dev->pdev)\r\npm_runtime_put_sync(&sdev->meram_dev->pdev->dev);\r\n#endif\r\nif (sdev->clock)\r\nclk_disable_unprepare(sdev->clock);\r\n}\r\nstatic void shmob_drm_crtc_setup_geometry(struct shmob_drm_crtc *scrtc)\r\n{\r\nstruct drm_crtc *crtc = &scrtc->crtc;\r\nstruct shmob_drm_device *sdev = crtc->dev->dev_private;\r\nconst struct shmob_drm_interface_data *idata = &sdev->pdata->iface;\r\nconst struct drm_display_mode *mode = &crtc->mode;\r\nu32 value;\r\nvalue = sdev->ldmt1r\r\n| ((mode->flags & DRM_MODE_FLAG_PVSYNC) ? 0 : LDMT1R_VPOL)\r\n| ((mode->flags & DRM_MODE_FLAG_PHSYNC) ? 0 : LDMT1R_HPOL)\r\n| ((idata->flags & SHMOB_DRM_IFACE_FL_DWPOL) ? LDMT1R_DWPOL : 0)\r\n| ((idata->flags & SHMOB_DRM_IFACE_FL_DIPOL) ? LDMT1R_DIPOL : 0)\r\n| ((idata->flags & SHMOB_DRM_IFACE_FL_DAPOL) ? LDMT1R_DAPOL : 0)\r\n| ((idata->flags & SHMOB_DRM_IFACE_FL_HSCNT) ? LDMT1R_HSCNT : 0)\r\n| ((idata->flags & SHMOB_DRM_IFACE_FL_DWCNT) ? LDMT1R_DWCNT : 0);\r\nlcdc_write(sdev, LDMT1R, value);\r\nif (idata->interface >= SHMOB_DRM_IFACE_SYS8A &&\r\nidata->interface <= SHMOB_DRM_IFACE_SYS24) {\r\nvalue = (idata->sys.cs_setup << LDMT2R_CSUP_SHIFT)\r\n| (idata->sys.vsync_active_high ? LDMT2R_RSV : 0)\r\n| (idata->sys.vsync_dir_input ? LDMT2R_VSEL : 0)\r\n| (idata->sys.write_setup << LDMT2R_WCSC_SHIFT)\r\n| (idata->sys.write_cycle << LDMT2R_WCEC_SHIFT)\r\n| (idata->sys.write_strobe << LDMT2R_WCLW_SHIFT);\r\nlcdc_write(sdev, LDMT2R, value);\r\nvalue = (idata->sys.read_latch << LDMT3R_RDLC_SHIFT)\r\n| (idata->sys.read_setup << LDMT3R_RCSC_SHIFT)\r\n| (idata->sys.read_cycle << LDMT3R_RCEC_SHIFT)\r\n| (idata->sys.read_strobe << LDMT3R_RCLW_SHIFT);\r\nlcdc_write(sdev, LDMT3R, value);\r\n}\r\nvalue = ((mode->hdisplay / 8) << 16)\r\n| (mode->htotal / 8);\r\nlcdc_write(sdev, LDHCNR, value);\r\nvalue = (((mode->hsync_end - mode->hsync_start) / 8) << 16)\r\n| (mode->hsync_start / 8);\r\nlcdc_write(sdev, LDHSYNR, value);\r\nvalue = ((mode->hdisplay & 7) << 24) | ((mode->htotal & 7) << 16)\r\n| (((mode->hsync_end - mode->hsync_start) & 7) << 8)\r\n| (mode->hsync_start & 7);\r\nlcdc_write(sdev, LDHAJR, value);\r\nvalue = ((mode->vdisplay) << 16)\r\n| mode->vtotal;\r\nlcdc_write(sdev, LDVLNR, value);\r\nvalue = ((mode->vsync_end - mode->vsync_start) << 16)\r\n| mode->vsync_start;\r\nlcdc_write(sdev, LDVSYNR, value);\r\n}\r\nstatic void shmob_drm_crtc_start_stop(struct shmob_drm_crtc *scrtc, bool start)\r\n{\r\nstruct shmob_drm_device *sdev = scrtc->crtc.dev->dev_private;\r\nu32 value;\r\nvalue = lcdc_read(sdev, LDCNT2R);\r\nif (start)\r\nlcdc_write(sdev, LDCNT2R, value | LDCNT2R_DO);\r\nelse\r\nlcdc_write(sdev, LDCNT2R, value & ~LDCNT2R_DO);\r\nwhile (1) {\r\nvalue = lcdc_read(sdev, LDPMR) & LDPMR_LPS;\r\nif ((start && value) || (!start && !value))\r\nbreak;\r\ncpu_relax();\r\n}\r\nif (!start) {\r\nlcdc_write(sdev, LDDCKSTPR, LDDCKSTPR_DCKSTP);\r\n}\r\n}\r\nstatic void shmob_drm_crtc_start(struct shmob_drm_crtc *scrtc)\r\n{\r\nstruct drm_crtc *crtc = &scrtc->crtc;\r\nstruct shmob_drm_device *sdev = crtc->dev->dev_private;\r\nconst struct shmob_drm_interface_data *idata = &sdev->pdata->iface;\r\nconst struct shmob_drm_format_info *format;\r\nstruct drm_device *dev = sdev->ddev;\r\nstruct drm_plane *plane;\r\nu32 value;\r\nint ret;\r\nif (scrtc->started)\r\nreturn;\r\nformat = shmob_drm_format_info(crtc->primary->fb->pixel_format);\r\nif (WARN_ON(format == NULL))\r\nreturn;\r\nret = shmob_drm_clk_on(sdev);\r\nif (ret < 0)\r\nreturn;\r\nlcdc_write(sdev, LDCNT2R, lcdc_read(sdev, LDCNT2R) | LDCNT2R_BR);\r\nlcdc_wait_bit(sdev, LDCNT2R, LDCNT2R_BR, 0);\r\nlcdc_write(sdev, LDCNT2R, LDCNT2R_ME);\r\nshmob_drm_crtc_start_stop(scrtc, false);\r\nlcdc_write(sdev, LDINTR, 0);\r\nlcdc_write(sdev, LDPMR, 0);\r\nvalue = sdev->lddckr;\r\nif (idata->clk_div) {\r\nlcdc_write(sdev, LDDCKPAT1R, 0);\r\nlcdc_write(sdev, LDDCKPAT2R, (1 << (idata->clk_div / 2)) - 1);\r\nif (idata->clk_div == 1)\r\nvalue |= LDDCKR_MOSEL;\r\nelse\r\nvalue |= idata->clk_div;\r\n}\r\nlcdc_write(sdev, LDDCKR, value);\r\nlcdc_write(sdev, LDDCKSTPR, 0);\r\nlcdc_wait_bit(sdev, LDDCKSTPR, ~0, 0);\r\nshmob_drm_crtc_setup_geometry(scrtc);\r\nlcdc_write(sdev, LDDFR, format->lddfr | LDDFR_CF1);\r\nlcdc_write(sdev, LDMLSR, scrtc->line_size);\r\nlcdc_write(sdev, LDSA1R, scrtc->dma[0]);\r\nif (format->yuv)\r\nlcdc_write(sdev, LDSA2R, scrtc->dma[1]);\r\nlcdc_write(sdev, LDSM1R, 0);\r\nswitch (format->fourcc) {\r\ncase DRM_FORMAT_RGB565:\r\ncase DRM_FORMAT_NV21:\r\ncase DRM_FORMAT_NV61:\r\ncase DRM_FORMAT_NV42:\r\nvalue = LDDDSR_LS | LDDDSR_WS;\r\nbreak;\r\ncase DRM_FORMAT_RGB888:\r\ncase DRM_FORMAT_NV12:\r\ncase DRM_FORMAT_NV16:\r\ncase DRM_FORMAT_NV24:\r\nvalue = LDDDSR_LS | LDDDSR_WS | LDDDSR_BS;\r\nbreak;\r\ncase DRM_FORMAT_ARGB8888:\r\ndefault:\r\nvalue = LDDDSR_LS;\r\nbreak;\r\n}\r\nlcdc_write(sdev, LDDDSR, value);\r\ndrm_for_each_legacy_plane(plane, &dev->mode_config.plane_list) {\r\nif (plane->crtc == crtc)\r\nshmob_drm_plane_setup(plane);\r\n}\r\nlcdc_write(sdev, LDCNT1R, LDCNT1R_DE);\r\nshmob_drm_crtc_start_stop(scrtc, true);\r\nscrtc->started = true;\r\n}\r\nstatic void shmob_drm_crtc_stop(struct shmob_drm_crtc *scrtc)\r\n{\r\nstruct drm_crtc *crtc = &scrtc->crtc;\r\nstruct shmob_drm_device *sdev = crtc->dev->dev_private;\r\nif (!scrtc->started)\r\nreturn;\r\nif (scrtc->cache) {\r\nsh_mobile_meram_cache_free(sdev->meram, scrtc->cache);\r\nscrtc->cache = NULL;\r\n}\r\nshmob_drm_crtc_start_stop(scrtc, false);\r\nlcdc_write(sdev, LDCNT1R, 0);\r\nshmob_drm_clk_off(sdev);\r\nscrtc->started = false;\r\n}\r\nvoid shmob_drm_crtc_suspend(struct shmob_drm_crtc *scrtc)\r\n{\r\nshmob_drm_crtc_stop(scrtc);\r\n}\r\nvoid shmob_drm_crtc_resume(struct shmob_drm_crtc *scrtc)\r\n{\r\nif (scrtc->dpms != DRM_MODE_DPMS_ON)\r\nreturn;\r\nshmob_drm_crtc_start(scrtc);\r\n}\r\nstatic void shmob_drm_crtc_compute_base(struct shmob_drm_crtc *scrtc,\r\nint x, int y)\r\n{\r\nstruct drm_crtc *crtc = &scrtc->crtc;\r\nstruct drm_framebuffer *fb = crtc->primary->fb;\r\nstruct shmob_drm_device *sdev = crtc->dev->dev_private;\r\nstruct drm_gem_cma_object *gem;\r\nunsigned int bpp;\r\nbpp = scrtc->format->yuv ? 8 : scrtc->format->bpp;\r\ngem = drm_fb_cma_get_gem_obj(fb, 0);\r\nscrtc->dma[0] = gem->paddr + fb->offsets[0]\r\n+ y * fb->pitches[0] + x * bpp / 8;\r\nif (scrtc->format->yuv) {\r\nbpp = scrtc->format->bpp - 8;\r\ngem = drm_fb_cma_get_gem_obj(fb, 1);\r\nscrtc->dma[1] = gem->paddr + fb->offsets[1]\r\n+ y / (bpp == 4 ? 2 : 1) * fb->pitches[1]\r\n+ x * (bpp == 16 ? 2 : 1);\r\n}\r\nif (scrtc->cache)\r\nsh_mobile_meram_cache_update(sdev->meram, scrtc->cache,\r\nscrtc->dma[0], scrtc->dma[1],\r\n&scrtc->dma[0], &scrtc->dma[1]);\r\n}\r\nstatic void shmob_drm_crtc_update_base(struct shmob_drm_crtc *scrtc)\r\n{\r\nstruct drm_crtc *crtc = &scrtc->crtc;\r\nstruct shmob_drm_device *sdev = crtc->dev->dev_private;\r\nshmob_drm_crtc_compute_base(scrtc, crtc->x, crtc->y);\r\nlcdc_write_mirror(sdev, LDSA1R, scrtc->dma[0]);\r\nif (scrtc->format->yuv)\r\nlcdc_write_mirror(sdev, LDSA2R, scrtc->dma[1]);\r\nlcdc_write(sdev, LDRCNTR, lcdc_read(sdev, LDRCNTR) ^ LDRCNTR_MRS);\r\n}\r\nstatic void shmob_drm_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct shmob_drm_crtc *scrtc = to_shmob_crtc(crtc);\r\nif (scrtc->dpms == mode)\r\nreturn;\r\nif (mode == DRM_MODE_DPMS_ON)\r\nshmob_drm_crtc_start(scrtc);\r\nelse\r\nshmob_drm_crtc_stop(scrtc);\r\nscrtc->dpms = mode;\r\n}\r\nstatic bool shmob_drm_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void shmob_drm_crtc_mode_prepare(struct drm_crtc *crtc)\r\n{\r\nshmob_drm_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);\r\n}\r\nstatic int shmob_drm_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct shmob_drm_crtc *scrtc = to_shmob_crtc(crtc);\r\nstruct shmob_drm_device *sdev = crtc->dev->dev_private;\r\nconst struct sh_mobile_meram_cfg *mdata = sdev->pdata->meram;\r\nconst struct shmob_drm_format_info *format;\r\nvoid *cache;\r\nformat = shmob_drm_format_info(crtc->primary->fb->pixel_format);\r\nif (format == NULL) {\r\ndev_dbg(sdev->dev, "mode_set: unsupported format %08x\n",\r\ncrtc->primary->fb->pixel_format);\r\nreturn -EINVAL;\r\n}\r\nscrtc->format = format;\r\nscrtc->line_size = crtc->primary->fb->pitches[0];\r\nif (sdev->meram) {\r\nif (scrtc->cache) {\r\nsh_mobile_meram_cache_free(sdev->meram, scrtc->cache);\r\nscrtc->cache = NULL;\r\n}\r\ncache = sh_mobile_meram_cache_alloc(sdev->meram, mdata,\r\ncrtc->primary->fb->pitches[0],\r\nadjusted_mode->vdisplay,\r\nformat->meram,\r\n&scrtc->line_size);\r\nif (!IS_ERR(cache))\r\nscrtc->cache = cache;\r\n}\r\nshmob_drm_crtc_compute_base(scrtc, x, y);\r\nreturn 0;\r\n}\r\nstatic void shmob_drm_crtc_mode_commit(struct drm_crtc *crtc)\r\n{\r\nshmob_drm_crtc_dpms(crtc, DRM_MODE_DPMS_ON);\r\n}\r\nstatic int shmob_drm_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nshmob_drm_crtc_update_base(to_shmob_crtc(crtc));\r\nreturn 0;\r\n}\r\nvoid shmob_drm_crtc_cancel_page_flip(struct shmob_drm_crtc *scrtc,\r\nstruct drm_file *file)\r\n{\r\nstruct drm_pending_vblank_event *event;\r\nstruct drm_device *dev = scrtc->crtc.dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nevent = scrtc->event;\r\nif (event && event->base.file_priv == file) {\r\nscrtc->event = NULL;\r\nevent->base.destroy(&event->base);\r\ndrm_vblank_put(dev, 0);\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nvoid shmob_drm_crtc_finish_page_flip(struct shmob_drm_crtc *scrtc)\r\n{\r\nstruct drm_pending_vblank_event *event;\r\nstruct drm_device *dev = scrtc->crtc.dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nevent = scrtc->event;\r\nscrtc->event = NULL;\r\nif (event) {\r\ndrm_send_vblank_event(dev, 0, event);\r\ndrm_vblank_put(dev, 0);\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nstatic int shmob_drm_crtc_page_flip(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nstruct drm_pending_vblank_event *event,\r\nuint32_t page_flip_flags)\r\n{\r\nstruct shmob_drm_crtc *scrtc = to_shmob_crtc(crtc);\r\nstruct drm_device *dev = scrtc->crtc.dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nif (scrtc->event != NULL) {\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nreturn -EBUSY;\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\ncrtc->primary->fb = fb;\r\nshmob_drm_crtc_update_base(scrtc);\r\nif (event) {\r\nevent->pipe = 0;\r\ndrm_vblank_get(dev, 0);\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nscrtc->event = event;\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nint shmob_drm_crtc_create(struct shmob_drm_device *sdev)\r\n{\r\nstruct drm_crtc *crtc = &sdev->crtc.crtc;\r\nint ret;\r\nsdev->crtc.dpms = DRM_MODE_DPMS_OFF;\r\nret = drm_crtc_init(sdev->ddev, crtc, &crtc_funcs);\r\nif (ret < 0)\r\nreturn ret;\r\ndrm_crtc_helper_add(crtc, &crtc_helper_funcs);\r\nreturn 0;\r\n}\r\nstatic void shmob_drm_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct shmob_drm_encoder *senc = to_shmob_encoder(encoder);\r\nstruct shmob_drm_device *sdev = encoder->dev->dev_private;\r\nstruct shmob_drm_connector *scon = &sdev->connector;\r\nif (senc->dpms == mode)\r\nreturn;\r\nshmob_drm_backlight_dpms(scon, mode);\r\nsenc->dpms = mode;\r\n}\r\nstatic bool shmob_drm_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct shmob_drm_device *sdev = dev->dev_private;\r\nstruct drm_connector *connector = &sdev->connector.connector;\r\nconst struct drm_display_mode *panel_mode;\r\nif (list_empty(&connector->modes)) {\r\ndev_dbg(dev->dev, "mode_fixup: empty modes list\n");\r\nreturn false;\r\n}\r\npanel_mode = list_first_entry(&connector->modes,\r\nstruct drm_display_mode, head);\r\ndrm_mode_copy(adjusted_mode, panel_mode);\r\nreturn true;\r\n}\r\nstatic void shmob_drm_encoder_mode_prepare(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void shmob_drm_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\n}\r\nstatic void shmob_drm_encoder_mode_commit(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void shmob_drm_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\n}\r\nint shmob_drm_encoder_create(struct shmob_drm_device *sdev)\r\n{\r\nstruct drm_encoder *encoder = &sdev->encoder.encoder;\r\nint ret;\r\nsdev->encoder.dpms = DRM_MODE_DPMS_OFF;\r\nencoder->possible_crtcs = 1;\r\nret = drm_encoder_init(sdev->ddev, encoder, &encoder_funcs,\r\nDRM_MODE_ENCODER_LVDS);\r\nif (ret < 0)\r\nreturn ret;\r\ndrm_encoder_helper_add(encoder, &encoder_helper_funcs);\r\nreturn 0;\r\n}\r\nvoid shmob_drm_crtc_enable_vblank(struct shmob_drm_device *sdev, bool enable)\r\n{\r\nunsigned long flags;\r\nu32 ldintr;\r\nspin_lock_irqsave(&sdev->irq_lock, flags);\r\nldintr = lcdc_read(sdev, LDINTR) | LDINTR_STATUS_MASK;\r\nif (enable)\r\nldintr |= LDINTR_VEE;\r\nelse\r\nldintr &= ~LDINTR_VEE;\r\nlcdc_write(sdev, LDINTR, ldintr);\r\nspin_unlock_irqrestore(&sdev->irq_lock, flags);\r\n}\r\nstatic int shmob_drm_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct shmob_drm_device *sdev = connector->dev->dev_private;\r\nstruct drm_display_mode *mode;\r\nmode = drm_mode_create(connector->dev);\r\nif (mode == NULL)\r\nreturn 0;\r\nmode->type = DRM_MODE_TYPE_PREFERRED | DRM_MODE_TYPE_DRIVER;\r\nmode->clock = sdev->pdata->panel.mode.clock;\r\nmode->hdisplay = sdev->pdata->panel.mode.hdisplay;\r\nmode->hsync_start = sdev->pdata->panel.mode.hsync_start;\r\nmode->hsync_end = sdev->pdata->panel.mode.hsync_end;\r\nmode->htotal = sdev->pdata->panel.mode.htotal;\r\nmode->vdisplay = sdev->pdata->panel.mode.vdisplay;\r\nmode->vsync_start = sdev->pdata->panel.mode.vsync_start;\r\nmode->vsync_end = sdev->pdata->panel.mode.vsync_end;\r\nmode->vtotal = sdev->pdata->panel.mode.vtotal;\r\nmode->flags = sdev->pdata->panel.mode.flags;\r\ndrm_mode_set_name(mode);\r\ndrm_mode_probed_add(connector, mode);\r\nconnector->display_info.width_mm = sdev->pdata->panel.width_mm;\r\nconnector->display_info.height_mm = sdev->pdata->panel.height_mm;\r\nreturn 1;\r\n}\r\nstatic struct drm_encoder *\r\nshmob_drm_connector_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct shmob_drm_connector *scon = to_shmob_connector(connector);\r\nreturn scon->encoder;\r\n}\r\nstatic void shmob_drm_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct shmob_drm_connector *scon = to_shmob_connector(connector);\r\nshmob_drm_backlight_exit(scon);\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\n}\r\nstatic enum drm_connector_status\r\nshmob_drm_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nint shmob_drm_connector_create(struct shmob_drm_device *sdev,\r\nstruct drm_encoder *encoder)\r\n{\r\nstruct drm_connector *connector = &sdev->connector.connector;\r\nint ret;\r\nsdev->connector.encoder = encoder;\r\nconnector->display_info.width_mm = sdev->pdata->panel.width_mm;\r\nconnector->display_info.height_mm = sdev->pdata->panel.height_mm;\r\nret = drm_connector_init(sdev->ddev, connector, &connector_funcs,\r\nDRM_MODE_CONNECTOR_LVDS);\r\nif (ret < 0)\r\nreturn ret;\r\ndrm_connector_helper_add(connector, &connector_helper_funcs);\r\nret = drm_connector_register(connector);\r\nif (ret < 0)\r\ngoto err_cleanup;\r\nret = shmob_drm_backlight_init(&sdev->connector);\r\nif (ret < 0)\r\ngoto err_sysfs;\r\nret = drm_mode_connector_attach_encoder(connector, encoder);\r\nif (ret < 0)\r\ngoto err_backlight;\r\nconnector->encoder = encoder;\r\ndrm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);\r\ndrm_object_property_set_value(&connector->base,\r\nsdev->ddev->mode_config.dpms_property, DRM_MODE_DPMS_OFF);\r\nreturn 0;\r\nerr_backlight:\r\nshmob_drm_backlight_exit(&sdev->connector);\r\nerr_sysfs:\r\ndrm_connector_unregister(connector);\r\nerr_cleanup:\r\ndrm_connector_cleanup(connector);\r\nreturn ret;\r\n}
