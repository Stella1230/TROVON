static int\r\nhw_rule_rate(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_bebob_stream_formation *formations = rule->private;\r\nstruct snd_interval *r =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nconst struct snd_interval *c =\r\nhw_param_interval_c(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval t = {\r\n.min = UINT_MAX, .max = 0, .integer = 1\r\n};\r\nunsigned int i;\r\nfor (i = 0; i < SND_BEBOB_STRM_FMT_ENTRIES; i++) {\r\nif (formations[i].pcm == 0)\r\ncontinue;\r\nif (!snd_interval_test(c, formations[i].pcm))\r\ncontinue;\r\nt.min = min(t.min, snd_bebob_rate_table[i]);\r\nt.max = max(t.max, snd_bebob_rate_table[i]);\r\n}\r\nreturn snd_interval_refine(r, &t);\r\n}\r\nstatic int\r\nhw_rule_channels(struct snd_pcm_hw_params *params, struct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_bebob_stream_formation *formations = rule->private;\r\nstruct snd_interval *c =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nconst struct snd_interval *r =\r\nhw_param_interval_c(params, SNDRV_PCM_HW_PARAM_RATE);\r\nstruct snd_interval t = {\r\n.min = UINT_MAX, .max = 0, .integer = 1\r\n};\r\nunsigned int i;\r\nfor (i = 0; i < SND_BEBOB_STRM_FMT_ENTRIES; i++) {\r\nif (formations[i].pcm == 0)\r\ncontinue;\r\nif (!snd_interval_test(r, snd_bebob_rate_table[i]))\r\ncontinue;\r\nt.min = min(t.min, formations[i].pcm);\r\nt.max = max(t.max, formations[i].pcm);\r\n}\r\nreturn snd_interval_refine(c, &t);\r\n}\r\nstatic void\r\nlimit_channels_and_rates(struct snd_pcm_hardware *hw,\r\nstruct snd_bebob_stream_formation *formations)\r\n{\r\nunsigned int i;\r\nhw->channels_min = UINT_MAX;\r\nhw->channels_max = 0;\r\nhw->rate_min = UINT_MAX;\r\nhw->rate_max = 0;\r\nhw->rates = 0;\r\nfor (i = 0; i < SND_BEBOB_STRM_FMT_ENTRIES; i++) {\r\nif (formations[i].pcm == 0)\r\ncontinue;\r\nhw->channels_min = min(hw->channels_min, formations[i].pcm);\r\nhw->channels_max = max(hw->channels_max, formations[i].pcm);\r\nhw->rate_min = min(hw->rate_min, snd_bebob_rate_table[i]);\r\nhw->rate_max = max(hw->rate_max, snd_bebob_rate_table[i]);\r\nhw->rates |= snd_pcm_rate_to_rate_bit(snd_bebob_rate_table[i]);\r\n}\r\n}\r\nstatic void\r\nlimit_period_and_buffer(struct snd_pcm_hardware *hw)\r\n{\r\nhw->periods_min = 2;\r\nhw->periods_max = UINT_MAX;\r\nhw->period_bytes_min = 4 * hw->channels_max;\r\nhw->period_bytes_max = hw->period_bytes_min * 2048;\r\nhw->buffer_bytes_max = hw->period_bytes_max * hw->periods_min;\r\n}\r\nstatic int\r\npcm_init_hw_params(struct snd_bebob *bebob,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct amdtp_stream *s;\r\nstruct snd_bebob_stream_formation *formations;\r\nint err;\r\nruntime->hw.info = SNDRV_PCM_INFO_BATCH |\r\nSNDRV_PCM_INFO_BLOCK_TRANSFER |\r\nSNDRV_PCM_INFO_INTERLEAVED |\r\nSNDRV_PCM_INFO_JOINT_DUPLEX |\r\nSNDRV_PCM_INFO_MMAP |\r\nSNDRV_PCM_INFO_MMAP_VALID;\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\r\nruntime->hw.formats = AMDTP_IN_PCM_FORMAT_BITS;\r\ns = &bebob->tx_stream;\r\nformations = bebob->tx_stream_formations;\r\n} else {\r\nruntime->hw.formats = AMDTP_OUT_PCM_FORMAT_BITS;\r\ns = &bebob->rx_stream;\r\nformations = bebob->rx_stream_formations;\r\n}\r\nlimit_channels_and_rates(&runtime->hw, formations);\r\nlimit_period_and_buffer(&runtime->hw);\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nhw_rule_channels, formations,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nif (err < 0)\r\ngoto end;\r\nerr = snd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\nhw_rule_rate, formations,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nif (err < 0)\r\ngoto end;\r\nerr = amdtp_stream_add_pcm_hw_constraints(s, runtime);\r\nend:\r\nreturn err;\r\n}\r\nstatic int\r\npcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_bebob *bebob = substream->private_data;\r\nstruct snd_bebob_rate_spec *spec = bebob->spec->rate;\r\nunsigned int sampling_rate;\r\nbool internal;\r\nint err;\r\nerr = snd_bebob_stream_lock_try(bebob);\r\nif (err < 0)\r\ngoto end;\r\nerr = pcm_init_hw_params(bebob, substream);\r\nif (err < 0)\r\ngoto err_locked;\r\nerr = snd_bebob_stream_check_internal_clock(bebob, &internal);\r\nif (err < 0)\r\ngoto err_locked;\r\nif (!internal ||\r\namdtp_stream_pcm_running(&bebob->tx_stream) ||\r\namdtp_stream_pcm_running(&bebob->rx_stream)) {\r\nerr = spec->get(bebob, &sampling_rate);\r\nif (err < 0) {\r\ndev_err(&bebob->unit->device,\r\n"fail to get sampling rate: %d\n", err);\r\ngoto err_locked;\r\n}\r\nsubstream->runtime->hw.rate_min = sampling_rate;\r\nsubstream->runtime->hw.rate_max = sampling_rate;\r\n}\r\nsnd_pcm_set_sync(substream);\r\nend:\r\nreturn err;\r\nerr_locked:\r\nsnd_bebob_stream_lock_release(bebob);\r\nreturn err;\r\n}\r\nstatic int\r\npcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_bebob *bebob = substream->private_data;\r\nsnd_bebob_stream_lock_release(bebob);\r\nreturn 0;\r\n}\r\nstatic int\r\npcm_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_bebob *bebob = substream->private_data;\r\nif (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN)\r\natomic_inc(&bebob->capture_substreams);\r\namdtp_stream_set_pcm_format(&bebob->tx_stream,\r\nparams_format(hw_params));\r\nreturn snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int\r\npcm_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_bebob *bebob = substream->private_data;\r\nif (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN)\r\natomic_inc(&bebob->playback_substreams);\r\namdtp_stream_set_pcm_format(&bebob->rx_stream,\r\nparams_format(hw_params));\r\nreturn snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int\r\npcm_capture_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_bebob *bebob = substream->private_data;\r\nif (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)\r\natomic_dec(&bebob->capture_substreams);\r\nsnd_bebob_stream_stop_duplex(bebob);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int\r\npcm_playback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_bebob *bebob = substream->private_data;\r\nif (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)\r\natomic_dec(&bebob->playback_substreams);\r\nsnd_bebob_stream_stop_duplex(bebob);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int\r\npcm_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_bebob *bebob = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nerr = snd_bebob_stream_start_duplex(bebob, runtime->rate);\r\nif (err >= 0)\r\namdtp_stream_pcm_prepare(&bebob->tx_stream);\r\nreturn err;\r\n}\r\nstatic int\r\npcm_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_bebob *bebob = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nerr = snd_bebob_stream_start_duplex(bebob, runtime->rate);\r\nif (err >= 0)\r\namdtp_stream_pcm_prepare(&bebob->rx_stream);\r\nreturn err;\r\n}\r\nstatic int\r\npcm_capture_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_bebob *bebob = substream->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\namdtp_stream_pcm_trigger(&bebob->tx_stream, substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\namdtp_stream_pcm_trigger(&bebob->tx_stream, NULL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\npcm_playback_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_bebob *bebob = substream->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\namdtp_stream_pcm_trigger(&bebob->rx_stream, substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\namdtp_stream_pcm_trigger(&bebob->rx_stream, NULL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\npcm_capture_pointer(struct snd_pcm_substream *sbstrm)\r\n{\r\nstruct snd_bebob *bebob = sbstrm->private_data;\r\nreturn amdtp_stream_pcm_pointer(&bebob->tx_stream);\r\n}\r\nstatic snd_pcm_uframes_t\r\npcm_playback_pointer(struct snd_pcm_substream *sbstrm)\r\n{\r\nstruct snd_bebob *bebob = sbstrm->private_data;\r\nreturn amdtp_stream_pcm_pointer(&bebob->rx_stream);\r\n}\r\nint snd_bebob_create_pcm_devices(struct snd_bebob *bebob)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(bebob->card, bebob->card->driver, 0, 1, 1, &pcm);\r\nif (err < 0)\r\ngoto end;\r\npcm->private_data = bebob;\r\nsnprintf(pcm->name, sizeof(pcm->name),\r\n"%s PCM", bebob->card->shortname);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &pcm_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &pcm_capture_ops);\r\nend:\r\nreturn err;\r\n}
