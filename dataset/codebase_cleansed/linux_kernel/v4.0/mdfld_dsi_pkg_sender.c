static inline int wait_for_gen_fifo_empty(struct mdfld_dsi_pkg_sender *sender,\r\nu32 mask)\r\n{\r\nstruct drm_device *dev = sender->dev;\r\nu32 gen_fifo_stat_reg = sender->mipi_gen_fifo_stat_reg;\r\nint retry = 0xffff;\r\nwhile (retry--) {\r\nif ((mask & REG_READ(gen_fifo_stat_reg)) == mask)\r\nreturn 0;\r\nudelay(100);\r\n}\r\nDRM_ERROR("fifo is NOT empty 0x%08x\n", REG_READ(gen_fifo_stat_reg));\r\nreturn -EIO;\r\n}\r\nstatic int wait_for_all_fifos_empty(struct mdfld_dsi_pkg_sender *sender)\r\n{\r\nreturn wait_for_gen_fifo_empty(sender, (BIT(2) | BIT(10) | BIT(18) |\r\nBIT(26) | BIT(27) | BIT(28)));\r\n}\r\nstatic int wait_for_lp_fifos_empty(struct mdfld_dsi_pkg_sender *sender)\r\n{\r\nreturn wait_for_gen_fifo_empty(sender, (BIT(10) | BIT(26)));\r\n}\r\nstatic int wait_for_hs_fifos_empty(struct mdfld_dsi_pkg_sender *sender)\r\n{\r\nreturn wait_for_gen_fifo_empty(sender, (BIT(2) | BIT(18)));\r\n}\r\nstatic int handle_dsi_error(struct mdfld_dsi_pkg_sender *sender, u32 mask)\r\n{\r\nu32 intr_stat_reg = sender->mipi_intr_stat_reg;\r\nstruct drm_device *dev = sender->dev;\r\ndev_dbg(sender->dev->dev, "Handling error 0x%08x\n", mask);\r\nswitch (mask) {\r\ncase BIT(0):\r\ncase BIT(1):\r\ncase BIT(2):\r\ncase BIT(3):\r\ncase BIT(4):\r\ncase BIT(5):\r\ncase BIT(6):\r\ncase BIT(7):\r\ncase BIT(8):\r\ncase BIT(9):\r\ncase BIT(10):\r\ncase BIT(11):\r\ncase BIT(12):\r\ncase BIT(13):\r\ndev_dbg(sender->dev->dev, "No Action required\n");\r\nbreak;\r\ncase BIT(14):\r\nbreak;\r\ncase BIT(15):\r\ndev_dbg(sender->dev->dev, "No Action required\n");\r\nbreak;\r\ncase BIT(16):\r\nbreak;\r\ncase BIT(17):\r\nbreak;\r\ncase BIT(18):\r\ncase BIT(19):\r\ndev_dbg(sender->dev->dev, "High/Low contention detected\n");\r\nif (0)\r\nwait_for_all_fifos_empty(sender);\r\nbreak;\r\ncase BIT(20):\r\ndev_dbg(sender->dev->dev, "No Action required\n");\r\nbreak;\r\ncase BIT(21):\r\nbreak;\r\ncase BIT(22):\r\nbreak;\r\ncase BIT(23):\r\ncase BIT(24):\r\ncase BIT(25):\r\ncase BIT(26):\r\ncase BIT(27):\r\ndev_dbg(sender->dev->dev, "HS Gen fifo full\n");\r\nREG_WRITE(intr_stat_reg, mask);\r\nwait_for_hs_fifos_empty(sender);\r\nbreak;\r\ncase BIT(28):\r\ndev_dbg(sender->dev->dev, "LP Gen fifo full\n");\r\nREG_WRITE(intr_stat_reg, mask);\r\nwait_for_lp_fifos_empty(sender);\r\nbreak;\r\ncase BIT(29):\r\ncase BIT(30):\r\ncase BIT(31):\r\ndev_dbg(sender->dev->dev, "No Action required\n");\r\nbreak;\r\n}\r\nif (mask & REG_READ(intr_stat_reg))\r\ndev_dbg(sender->dev->dev,\r\n"Cannot clean interrupt 0x%08x\n", mask);\r\nreturn 0;\r\n}\r\nstatic int dsi_error_handler(struct mdfld_dsi_pkg_sender *sender)\r\n{\r\nstruct drm_device *dev = sender->dev;\r\nu32 intr_stat_reg = sender->mipi_intr_stat_reg;\r\nu32 mask;\r\nu32 intr_stat;\r\nint i;\r\nint err = 0;\r\nintr_stat = REG_READ(intr_stat_reg);\r\nfor (i = 0; i < 32; i++) {\r\nmask = (0x00000001UL) << i;\r\nif (intr_stat & mask) {\r\ndev_dbg(sender->dev->dev, "[DSI]: %s\n", dsi_errors[i]);\r\nerr = handle_dsi_error(sender, mask);\r\nif (err)\r\nDRM_ERROR("Cannot handle error\n");\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int send_short_pkg(struct mdfld_dsi_pkg_sender *sender, u8 data_type,\r\nu8 cmd, u8 param, bool hs)\r\n{\r\nstruct drm_device *dev = sender->dev;\r\nu32 ctrl_reg;\r\nu32 val;\r\nu8 virtual_channel = 0;\r\nif (hs) {\r\nctrl_reg = sender->mipi_hs_gen_ctrl_reg;\r\n} else {\r\nctrl_reg = sender->mipi_lp_gen_ctrl_reg;\r\n}\r\nval = FLD_VAL(param, 23, 16) | FLD_VAL(cmd, 15, 8) |\r\nFLD_VAL(virtual_channel, 7, 6) | FLD_VAL(data_type, 5, 0);\r\nREG_WRITE(ctrl_reg, val);\r\nreturn 0;\r\n}\r\nstatic int send_long_pkg(struct mdfld_dsi_pkg_sender *sender, u8 data_type,\r\nu8 *data, int len, bool hs)\r\n{\r\nstruct drm_device *dev = sender->dev;\r\nu32 ctrl_reg;\r\nu32 data_reg;\r\nu32 val;\r\nu8 *p;\r\nu8 b1, b2, b3, b4;\r\nu8 virtual_channel = 0;\r\nint i;\r\nif (hs) {\r\nctrl_reg = sender->mipi_hs_gen_ctrl_reg;\r\ndata_reg = sender->mipi_hs_gen_data_reg;\r\n} else {\r\nctrl_reg = sender->mipi_lp_gen_ctrl_reg;\r\ndata_reg = sender->mipi_lp_gen_data_reg;\r\n}\r\np = data;\r\nfor (i = 0; i < len / 4; i++) {\r\nb1 = *p++;\r\nb2 = *p++;\r\nb3 = *p++;\r\nb4 = *p++;\r\nREG_WRITE(data_reg, b4 << 24 | b3 << 16 | b2 << 8 | b1);\r\n}\r\ni = len % 4;\r\nif (i) {\r\nb1 = 0; b2 = 0; b3 = 0;\r\nswitch (i) {\r\ncase 3:\r\nb1 = *p++;\r\nb2 = *p++;\r\nb3 = *p++;\r\nbreak;\r\ncase 2:\r\nb1 = *p++;\r\nb2 = *p++;\r\nbreak;\r\ncase 1:\r\nb1 = *p++;\r\nbreak;\r\n}\r\nREG_WRITE(data_reg, b3 << 16 | b2 << 8 | b1);\r\n}\r\nval = FLD_VAL(len, 23, 8) | FLD_VAL(virtual_channel, 7, 6) |\r\nFLD_VAL(data_type, 5, 0);\r\nREG_WRITE(ctrl_reg, val);\r\nreturn 0;\r\n}\r\nstatic int send_pkg_prepare(struct mdfld_dsi_pkg_sender *sender, u8 data_type,\r\nu8 *data, u16 len)\r\n{\r\nu8 cmd;\r\nswitch (data_type) {\r\ncase MIPI_DSI_DCS_SHORT_WRITE:\r\ncase MIPI_DSI_DCS_SHORT_WRITE_PARAM:\r\ncase MIPI_DSI_DCS_LONG_WRITE:\r\ncmd = *data;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nsender->status = MDFLD_DSI_PKG_SENDER_BUSY;\r\nif (unlikely(cmd == MIPI_DCS_ENTER_SLEEP_MODE)) {\r\nmdelay(120);\r\n}\r\nif (unlikely(cmd == MIPI_DCS_EXIT_SLEEP_MODE)) {\r\nmdelay(120);\r\n}\r\nreturn 0;\r\n}\r\nstatic int send_pkg_done(struct mdfld_dsi_pkg_sender *sender, u8 data_type,\r\nu8 *data, u16 len)\r\n{\r\nu8 cmd;\r\nswitch (data_type) {\r\ncase MIPI_DSI_DCS_SHORT_WRITE:\r\ncase MIPI_DSI_DCS_SHORT_WRITE_PARAM:\r\ncase MIPI_DSI_DCS_LONG_WRITE:\r\ncmd = *data;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (unlikely(cmd == MIPI_DCS_ENTER_SLEEP_MODE)) {\r\nsender->panel_mode |= MDFLD_DSI_PANEL_MODE_SLEEP;\r\nmdelay(120);\r\n} else if (unlikely(cmd == MIPI_DCS_EXIT_SLEEP_MODE)) {\r\nsender->panel_mode &= ~MDFLD_DSI_PANEL_MODE_SLEEP;\r\nmdelay(120);\r\n} else if (unlikely(cmd == MIPI_DCS_SOFT_RESET)) {\r\nmdelay(5);\r\n}\r\nsender->status = MDFLD_DSI_PKG_SENDER_FREE;\r\nreturn 0;\r\n}\r\nstatic int send_pkg(struct mdfld_dsi_pkg_sender *sender, u8 data_type,\r\nu8 *data, u16 len, bool hs)\r\n{\r\nint ret;\r\nret = dsi_error_handler(sender);\r\nif (ret) {\r\nDRM_ERROR("Error handling failed\n");\r\nreturn -EAGAIN;\r\n}\r\nif (sender->status == MDFLD_DSI_PKG_SENDER_BUSY) {\r\nDRM_ERROR("sender is busy\n");\r\nreturn -EAGAIN;\r\n}\r\nret = send_pkg_prepare(sender, data_type, data, len);\r\nif (ret) {\r\nDRM_ERROR("send_pkg_prepare error\n");\r\nreturn ret;\r\n}\r\nswitch (data_type) {\r\ncase MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:\r\ncase MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:\r\ncase MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:\r\ncase MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM:\r\ncase MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM:\r\ncase MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM:\r\ncase MIPI_DSI_DCS_SHORT_WRITE:\r\ncase MIPI_DSI_DCS_SHORT_WRITE_PARAM:\r\ncase MIPI_DSI_DCS_READ:\r\nret = send_short_pkg(sender, data_type, data[0], data[1], hs);\r\nbreak;\r\ncase MIPI_DSI_GENERIC_LONG_WRITE:\r\ncase MIPI_DSI_DCS_LONG_WRITE:\r\nret = send_long_pkg(sender, data_type, data, len, hs);\r\nbreak;\r\n}\r\nsend_pkg_done(sender, data_type, data, len);\r\nreturn ret;\r\n}\r\nint mdfld_dsi_send_mcs_long(struct mdfld_dsi_pkg_sender *sender, u8 *data,\r\nu32 len, bool hs)\r\n{\r\nunsigned long flags;\r\nif (!sender || !data || !len) {\r\nDRM_ERROR("Invalid parameters\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&sender->lock, flags);\r\nsend_pkg(sender, MIPI_DSI_DCS_LONG_WRITE, data, len, hs);\r\nspin_unlock_irqrestore(&sender->lock, flags);\r\nreturn 0;\r\n}\r\nint mdfld_dsi_send_mcs_short(struct mdfld_dsi_pkg_sender *sender, u8 cmd,\r\nu8 param, u8 param_num, bool hs)\r\n{\r\nu8 data[2];\r\nunsigned long flags;\r\nu8 data_type;\r\nif (!sender) {\r\nDRM_ERROR("Invalid parameter\n");\r\nreturn -EINVAL;\r\n}\r\ndata[0] = cmd;\r\nif (param_num) {\r\ndata_type = MIPI_DSI_DCS_SHORT_WRITE_PARAM;\r\ndata[1] = param;\r\n} else {\r\ndata_type = MIPI_DSI_DCS_SHORT_WRITE;\r\ndata[1] = 0;\r\n}\r\nspin_lock_irqsave(&sender->lock, flags);\r\nsend_pkg(sender, data_type, data, sizeof(data), hs);\r\nspin_unlock_irqrestore(&sender->lock, flags);\r\nreturn 0;\r\n}\r\nint mdfld_dsi_send_gen_short(struct mdfld_dsi_pkg_sender *sender, u8 param0,\r\nu8 param1, u8 param_num, bool hs)\r\n{\r\nu8 data[2];\r\nunsigned long flags;\r\nu8 data_type;\r\nif (!sender || param_num > 2) {\r\nDRM_ERROR("Invalid parameter\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (param_num) {\r\ncase 0:\r\ndata_type = MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM;\r\ndata[0] = 0;\r\ndata[1] = 0;\r\nbreak;\r\ncase 1:\r\ndata_type = MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM;\r\ndata[0] = param0;\r\ndata[1] = 0;\r\nbreak;\r\ncase 2:\r\ndata_type = MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM;\r\ndata[0] = param0;\r\ndata[1] = param1;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&sender->lock, flags);\r\nsend_pkg(sender, data_type, data, sizeof(data), hs);\r\nspin_unlock_irqrestore(&sender->lock, flags);\r\nreturn 0;\r\n}\r\nint mdfld_dsi_send_gen_long(struct mdfld_dsi_pkg_sender *sender, u8 *data,\r\nu32 len, bool hs)\r\n{\r\nunsigned long flags;\r\nif (!sender || !data || !len) {\r\nDRM_ERROR("Invalid parameters\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&sender->lock, flags);\r\nsend_pkg(sender, MIPI_DSI_GENERIC_LONG_WRITE, data, len, hs);\r\nspin_unlock_irqrestore(&sender->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __read_panel_data(struct mdfld_dsi_pkg_sender *sender, u8 data_type,\r\nu8 *data, u16 len, u32 *data_out, u16 len_out, bool hs)\r\n{\r\nunsigned long flags;\r\nstruct drm_device *dev = sender->dev;\r\nint i;\r\nu32 gen_data_reg;\r\nint retry = MDFLD_DSI_READ_MAX_COUNT;\r\nif (!sender || !data_out || !len_out) {\r\nDRM_ERROR("Invalid parameters\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&sender->lock, flags);\r\nREG_WRITE(sender->mipi_intr_stat_reg, BIT(29));\r\nif ((REG_READ(sender->mipi_intr_stat_reg) & BIT(29)))\r\nDRM_ERROR("Can NOT clean read data valid interrupt\n");\r\nsend_pkg(sender, data_type, data, len, hs);\r\nwhile (retry && !(REG_READ(sender->mipi_intr_stat_reg) & BIT(29))) {\r\nudelay(100);\r\nretry--;\r\n}\r\nif (!retry) {\r\nspin_unlock_irqrestore(&sender->lock, flags);\r\nreturn -ETIMEDOUT;\r\n}\r\nREG_WRITE(sender->mipi_intr_stat_reg, BIT(29));\r\nif (hs)\r\ngen_data_reg = sender->mipi_hs_gen_data_reg;\r\nelse\r\ngen_data_reg = sender->mipi_lp_gen_data_reg;\r\nfor (i = 0; i < len_out; i++)\r\n*(data_out + i) = REG_READ(gen_data_reg);\r\nspin_unlock_irqrestore(&sender->lock, flags);\r\nreturn 0;\r\n}\r\nint mdfld_dsi_read_mcs(struct mdfld_dsi_pkg_sender *sender, u8 cmd,\r\nu32 *data, u16 len, bool hs)\r\n{\r\nif (!sender || !data || !len) {\r\nDRM_ERROR("Invalid parameters\n");\r\nreturn -EINVAL;\r\n}\r\nreturn __read_panel_data(sender, MIPI_DSI_DCS_READ, &cmd, 1,\r\ndata, len, hs);\r\n}\r\nint mdfld_dsi_pkg_sender_init(struct mdfld_dsi_connector *dsi_connector,\r\nint pipe)\r\n{\r\nstruct mdfld_dsi_pkg_sender *pkg_sender;\r\nstruct mdfld_dsi_config *dsi_config =\r\nmdfld_dsi_get_config(dsi_connector);\r\nstruct drm_device *dev = dsi_config->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nu32 mipi_val = 0;\r\nif (!dsi_connector) {\r\nDRM_ERROR("Invalid parameter\n");\r\nreturn -EINVAL;\r\n}\r\npkg_sender = dsi_connector->pkg_sender;\r\nif (!pkg_sender || IS_ERR(pkg_sender)) {\r\npkg_sender = kzalloc(sizeof(struct mdfld_dsi_pkg_sender),\r\nGFP_KERNEL);\r\nif (!pkg_sender) {\r\nDRM_ERROR("Create DSI pkg sender failed\n");\r\nreturn -ENOMEM;\r\n}\r\ndsi_connector->pkg_sender = (void *)pkg_sender;\r\n}\r\npkg_sender->dev = dev;\r\npkg_sender->dsi_connector = dsi_connector;\r\npkg_sender->pipe = pipe;\r\npkg_sender->pkg_num = 0;\r\npkg_sender->panel_mode = 0;\r\npkg_sender->status = MDFLD_DSI_PKG_SENDER_FREE;\r\npkg_sender->dpll_reg = map->dpll;\r\npkg_sender->dspcntr_reg = map->cntr;\r\npkg_sender->pipeconf_reg = map->conf;\r\npkg_sender->dsplinoff_reg = map->linoff;\r\npkg_sender->dspsurf_reg = map->surf;\r\npkg_sender->pipestat_reg = map->status;\r\npkg_sender->mipi_intr_stat_reg = MIPI_INTR_STAT_REG(pipe);\r\npkg_sender->mipi_lp_gen_data_reg = MIPI_LP_GEN_DATA_REG(pipe);\r\npkg_sender->mipi_hs_gen_data_reg = MIPI_HS_GEN_DATA_REG(pipe);\r\npkg_sender->mipi_lp_gen_ctrl_reg = MIPI_LP_GEN_CTRL_REG(pipe);\r\npkg_sender->mipi_hs_gen_ctrl_reg = MIPI_HS_GEN_CTRL_REG(pipe);\r\npkg_sender->mipi_gen_fifo_stat_reg = MIPI_GEN_FIFO_STAT_REG(pipe);\r\npkg_sender->mipi_data_addr_reg = MIPI_DATA_ADD_REG(pipe);\r\npkg_sender->mipi_data_len_reg = MIPI_DATA_LEN_REG(pipe);\r\npkg_sender->mipi_cmd_addr_reg = MIPI_CMD_ADD_REG(pipe);\r\npkg_sender->mipi_cmd_len_reg = MIPI_CMD_LEN_REG(pipe);\r\nspin_lock_init(&pkg_sender->lock);\r\nif (mdfld_get_panel_type(dev, pipe) != TC35876X) {\r\nmipi_val = PASS_FROM_SPHY_TO_AFE | SEL_FLOPPED_HSTX;\r\nif (pipe == 0)\r\nmipi_val |= 0x2;\r\nREG_WRITE(MIPI_PORT_CONTROL(pipe), mipi_val);\r\nREG_READ(MIPI_PORT_CONTROL(pipe));\r\nmdfld_dsi_controller_init(dsi_config, pipe);\r\n}\r\nreturn 0;\r\n}\r\nvoid mdfld_dsi_pkg_sender_destroy(struct mdfld_dsi_pkg_sender *sender)\r\n{\r\nif (!sender || IS_ERR(sender))\r\nreturn;\r\nkfree(sender);\r\n}
