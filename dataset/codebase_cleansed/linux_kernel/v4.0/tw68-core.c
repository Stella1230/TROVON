static int tw68_hw_init1(struct tw68_dev *dev)\r\n{\r\ntw_writel(TW68_INTMASK, 0);\r\ntw_writel(TW68_INTSTAT, 0xffffffff);\r\ntw_writel(TW68_DMAC, 0x1600);\r\ntw_writeb(TW68_ACNTL, 0x80);\r\nmsleep(100);\r\ntw_writeb(TW68_INFORM, 0x40);\r\ntw_writeb(TW68_OPFORM, 0x04);\r\ntw_writeb(TW68_HSYNC, 0);\r\ntw_writeb(TW68_ACNTL, 0x42);\r\ntw_writeb(TW68_CROP_HI, 0x02);\r\ntw_writeb(TW68_VDELAY_LO, 0x12);\r\ntw_writeb(TW68_VACTIVE_LO, 0xf0);\r\ntw_writeb(TW68_HDELAY_LO, 0x0f);\r\ntw_writeb(TW68_HACTIVE_LO, 0xd0);\r\ntw_writeb(TW68_CNTRL1, 0xcd);\r\ntw_writeb(TW68_VSCALE_LO, 0);\r\ntw_writeb(TW68_SCALE_HI, 0x11);\r\ntw_writeb(TW68_HSCALE_LO, 0);\r\ntw_writeb(TW68_BRIGHT, 0);\r\ntw_writeb(TW68_CONTRAST, 0x5c);\r\ntw_writeb(TW68_SHARPNESS, 0x51);\r\ntw_writeb(TW68_SAT_U, 0x80);\r\ntw_writeb(TW68_SAT_V, 0x80);\r\ntw_writeb(TW68_HUE, 0x00);\r\ntw_writeb(TW68_SHARP2, 0x53);\r\ntw_writeb(TW68_VSHARP, 0x80);\r\ntw_writeb(TW68_CORING, 0x44);\r\ntw_writeb(TW68_CNTRL2, 0x00);\r\ntw_writeb(TW68_SDT, 0x07);\r\ntw_writeb(TW68_SDTR, 0x7f);\r\ntw_writeb(TW68_CLMPG, 0x50);\r\ntw_writeb(TW68_IAGC, 0x22);\r\ntw_writeb(TW68_AGCGAIN, 0xf0);\r\ntw_writeb(TW68_PEAKWT, 0xd8);\r\ntw_writeb(TW68_CLMPL, 0x3c);\r\ntw_writeb(TW68_SYNCT, 0x30);\r\ntw_writeb(TW68_MISSCNT, 0x44);\r\ntw_writeb(TW68_PCLAMP, 0x28);\r\ntw_writeb(TW68_VCNTL1, 0x04);\r\ntw_writeb(TW68_VCNTL2, 0);\r\ntw_writeb(TW68_CKILL, 0x68);\r\ntw_writeb(TW68_COMB, 0x44);\r\ntw_writeb(TW68_LDLY, 0x30);\r\ntw_writeb(TW68_MISC1, 0x14);\r\ntw_writeb(TW68_LOOP, 0xa5);\r\ntw_writeb(TW68_MISC2, 0xe0);\r\ntw_writeb(TW68_MVSN, 0);\r\ntw_writeb(TW68_CLMD, 0x05);\r\ntw_writeb(TW68_IDCNTL, 0);\r\ntw_writeb(TW68_CLCNTL1, 0);\r\ntw_writel(TW68_VBIC, 0x03);\r\ntw_writel(TW68_CAP_CTL, 0x03);\r\ntw_writel(TW68_DMAC, 0x2000);\r\ntw_writel(TW68_TESTREG, 0);\r\ntw_writel(TW68_GPIOC, 0);\r\ntw_writel(TW68_GPOE, 0x0f);\r\ntw_writel(TW68_GPDATA, 0);\r\nmutex_init(&dev->lock);\r\nspin_lock_init(&dev->slock);\r\ntw68_video_init1(dev);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t tw68_irq(int irq, void *dev_id)\r\n{\r\nstruct tw68_dev *dev = dev_id;\r\nu32 status, orig;\r\nint loop;\r\nstatus = orig = tw_readl(TW68_INTSTAT) & dev->pci_irqmask;\r\nif (0 == status)\r\nreturn IRQ_NONE;\r\nfor (loop = 0; loop < 10; loop++) {\r\nif (status & dev->board_virqmask)\r\ntw68_irq_video_done(dev, status);\r\nstatus = tw_readl(TW68_INTSTAT) & dev->pci_irqmask;\r\nif (0 == status)\r\nreturn IRQ_HANDLED;\r\n}\r\ndev_dbg(&dev->pci->dev, "%s: **** INTERRUPT NOT HANDLED - clearing mask (orig 0x%08x, cur 0x%08x)",\r\ndev->name, orig, tw_readl(TW68_INTSTAT));\r\ndev_dbg(&dev->pci->dev, "%s: pci_irqmask 0x%08x; board_virqmask 0x%08x ****\n",\r\ndev->name, dev->pci_irqmask, dev->board_virqmask);\r\ntw_clearl(TW68_INTMASK, dev->pci_irqmask);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tw68_initdev(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct tw68_dev *dev;\r\nint vidnr = -1;\r\nint err;\r\ndev = devm_kzalloc(&pci_dev->dev, sizeof(*dev), GFP_KERNEL);\r\nif (NULL == dev)\r\nreturn -ENOMEM;\r\ndev->instance = v4l2_device_set_name(&dev->v4l2_dev, "tw68",\r\n&tw68_instance);\r\nerr = v4l2_device_register(&pci_dev->dev, &dev->v4l2_dev);\r\nif (err)\r\nreturn err;\r\ndev->pci = pci_dev;\r\nif (pci_enable_device(pci_dev)) {\r\nerr = -EIO;\r\ngoto fail1;\r\n}\r\ndev->name = dev->v4l2_dev.name;\r\nif (UNSET != latency) {\r\npr_info("%s: setting pci latency timer to %d\n",\r\ndev->name, latency);\r\npci_write_config_byte(pci_dev, PCI_LATENCY_TIMER, latency);\r\n}\r\npci_read_config_byte(pci_dev, PCI_CLASS_REVISION, &dev->pci_rev);\r\npci_read_config_byte(pci_dev, PCI_LATENCY_TIMER, &dev->pci_lat);\r\npr_info("%s: found at %s, rev: %d, irq: %d, latency: %d, mmio: 0x%llx\n",\r\ndev->name, pci_name(pci_dev), dev->pci_rev, pci_dev->irq,\r\ndev->pci_lat, (u64)pci_resource_start(pci_dev, 0));\r\npci_set_master(pci_dev);\r\nif (!pci_dma_supported(pci_dev, DMA_BIT_MASK(32))) {\r\npr_info("%s: Oops: no 32bit PCI DMA ???\n", dev->name);\r\nerr = -EIO;\r\ngoto fail1;\r\n}\r\nswitch (pci_id->device) {\r\ncase PCI_DEVICE_ID_6800:\r\ndev->vdecoder = TW6800;\r\ndev->board_virqmask = TW68_VID_INTS;\r\nbreak;\r\ncase PCI_DEVICE_ID_6801:\r\ndev->vdecoder = TW6801;\r\ndev->board_virqmask = TW68_VID_INTS | TW68_VID_INTSX;\r\nbreak;\r\ncase PCI_DEVICE_ID_6804:\r\ndev->vdecoder = TW6804;\r\ndev->board_virqmask = TW68_VID_INTS | TW68_VID_INTSX;\r\nbreak;\r\ndefault:\r\ndev->vdecoder = TWXXXX;\r\ndev->board_virqmask = TW68_VID_INTS | TW68_VID_INTSX;\r\nbreak;\r\n}\r\nif (!request_mem_region(pci_resource_start(pci_dev, 0),\r\npci_resource_len(pci_dev, 0),\r\ndev->name)) {\r\nerr = -EBUSY;\r\npr_err("%s: can't get MMIO memory @ 0x%llx\n",\r\ndev->name,\r\n(unsigned long long)pci_resource_start(pci_dev, 0));\r\ngoto fail1;\r\n}\r\ndev->lmmio = ioremap(pci_resource_start(pci_dev, 0),\r\npci_resource_len(pci_dev, 0));\r\ndev->bmmio = (__u8 __iomem *)dev->lmmio;\r\nif (NULL == dev->lmmio) {\r\nerr = -EIO;\r\npr_err("%s: can't ioremap() MMIO memory\n",\r\ndev->name);\r\ngoto fail2;\r\n}\r\ntw68_hw_init1(dev);\r\ndev->alloc_ctx = vb2_dma_sg_init_ctx(&pci_dev->dev);\r\nif (IS_ERR(dev->alloc_ctx)) {\r\nerr = PTR_ERR(dev->alloc_ctx);\r\ngoto fail3;\r\n}\r\nerr = devm_request_irq(&pci_dev->dev, pci_dev->irq, tw68_irq,\r\nIRQF_SHARED, dev->name, dev);\r\nif (err < 0) {\r\npr_err("%s: can't get IRQ %d\n",\r\ndev->name, pci_dev->irq);\r\ngoto fail4;\r\n}\r\nif (dev->instance < TW68_MAXBOARDS)\r\nvidnr = video_nr[dev->instance];\r\nerr = tw68_video_init2(dev, vidnr);\r\nif (err < 0) {\r\npr_err("%s: can't register video device\n",\r\ndev->name);\r\ngoto fail5;\r\n}\r\ntw_setl(TW68_INTMASK, dev->pci_irqmask);\r\npr_info("%s: registered device %s\n",\r\ndev->name, video_device_node_name(&dev->vdev));\r\nreturn 0;\r\nfail5:\r\nvideo_unregister_device(&dev->vdev);\r\nfail4:\r\nvb2_dma_sg_cleanup_ctx(dev->alloc_ctx);\r\nfail3:\r\niounmap(dev->lmmio);\r\nfail2:\r\nrelease_mem_region(pci_resource_start(pci_dev, 0),\r\npci_resource_len(pci_dev, 0));\r\nfail1:\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nreturn err;\r\n}\r\nstatic void tw68_finidev(struct pci_dev *pci_dev)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\r\nstruct tw68_dev *dev =\r\ncontainer_of(v4l2_dev, struct tw68_dev, v4l2_dev);\r\ntw_clearl(TW68_DMAC, TW68_DMAP_EN | TW68_FIFO_EN);\r\ntw_writel(TW68_INTMASK, 0);\r\nvideo_unregister_device(&dev->vdev);\r\nv4l2_ctrl_handler_free(&dev->hdl);\r\nvb2_dma_sg_cleanup_ctx(dev->alloc_ctx);\r\niounmap(dev->lmmio);\r\nrelease_mem_region(pci_resource_start(pci_dev, 0),\r\npci_resource_len(pci_dev, 0));\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\n}\r\nstatic int tw68_suspend(struct pci_dev *pci_dev , pm_message_t state)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\r\nstruct tw68_dev *dev = container_of(v4l2_dev,\r\nstruct tw68_dev, v4l2_dev);\r\ntw_clearl(TW68_DMAC, TW68_DMAP_EN | TW68_FIFO_EN);\r\ndev->pci_irqmask &= ~TW68_VID_INTS;\r\ntw_writel(TW68_INTMASK, 0);\r\nsynchronize_irq(pci_dev->irq);\r\npci_save_state(pci_dev);\r\npci_set_power_state(pci_dev, pci_choose_state(pci_dev, state));\r\nvb2_discard_done(&dev->vidq);\r\nreturn 0;\r\n}\r\nstatic int tw68_resume(struct pci_dev *pci_dev)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pci_dev);\r\nstruct tw68_dev *dev = container_of(v4l2_dev,\r\nstruct tw68_dev, v4l2_dev);\r\nstruct tw68_buf *buf;\r\nunsigned long flags;\r\npci_set_power_state(pci_dev, PCI_D0);\r\npci_restore_state(pci_dev);\r\nmsleep(100);\r\ntw68_set_tvnorm_hw(dev);\r\nspin_lock_irqsave(&dev->slock, flags);\r\nbuf = container_of(dev->active.next, struct tw68_buf, list);\r\ntw68_video_start_dma(dev, buf);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nreturn 0;\r\n}
