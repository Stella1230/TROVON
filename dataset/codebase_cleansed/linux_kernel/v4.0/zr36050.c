static u8\r\nzr36050_read (struct zr36050 *ptr,\r\nu16 reg)\r\n{\r\nu8 value = 0;\r\nif (ptr->codec->master_data->readreg)\r\nvalue = (ptr->codec->master_data->readreg(ptr->codec,\r\nreg)) & 0xFF;\r\nelse\r\ndprintk(1,\r\nKERN_ERR "%s: invalid I/O setup, nothing read!\n",\r\nptr->name);\r\ndprintk(4, "%s: reading from 0x%04x: %02x\n", ptr->name, reg,\r\nvalue);\r\nreturn value;\r\n}\r\nstatic void\r\nzr36050_write (struct zr36050 *ptr,\r\nu16 reg,\r\nu8 value)\r\n{\r\ndprintk(4, "%s: writing 0x%02x to 0x%04x\n", ptr->name, value,\r\nreg);\r\nif (ptr->codec->master_data->writereg)\r\nptr->codec->master_data->writereg(ptr->codec, reg, value);\r\nelse\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: invalid I/O setup, nothing written!\n",\r\nptr->name);\r\n}\r\nstatic u8\r\nzr36050_read_status1 (struct zr36050 *ptr)\r\n{\r\nptr->status1 = zr36050_read(ptr, ZR050_STATUS_1);\r\nzr36050_read(ptr, 0);\r\nreturn ptr->status1;\r\n}\r\nstatic u16\r\nzr36050_read_scalefactor (struct zr36050 *ptr)\r\n{\r\nptr->scalefact = (zr36050_read(ptr, ZR050_SF_HI) << 8) |\r\n(zr36050_read(ptr, ZR050_SF_LO) & 0xFF);\r\nzr36050_read(ptr, 0);\r\nreturn ptr->scalefact;\r\n}\r\nstatic void\r\nzr36050_wait_end (struct zr36050 *ptr)\r\n{\r\nint i = 0;\r\nwhile (!(zr36050_read_status1(ptr) & 0x4)) {\r\nudelay(1);\r\nif (i++ > 200000) {\r\ndprintk(1,\r\n"%s: timeout at wait_end (last status: 0x%02x)\n",\r\nptr->name, ptr->status1);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int\r\nzr36050_basic_test (struct zr36050 *ptr)\r\n{\r\nzr36050_write(ptr, ZR050_SOF_IDX, 0x00);\r\nzr36050_write(ptr, ZR050_SOF_IDX + 1, 0x00);\r\nif ((zr36050_read(ptr, ZR050_SOF_IDX) |\r\nzr36050_read(ptr, ZR050_SOF_IDX + 1)) != 0x0000) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: attach failed, can't connect to jpeg processor!\n",\r\nptr->name);\r\nreturn -ENXIO;\r\n}\r\nzr36050_write(ptr, ZR050_SOF_IDX, 0xff);\r\nzr36050_write(ptr, ZR050_SOF_IDX + 1, 0xc0);\r\nif (((zr36050_read(ptr, ZR050_SOF_IDX) << 8) |\r\nzr36050_read(ptr, ZR050_SOF_IDX + 1)) != 0xffc0) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: attach failed, can't connect to jpeg processor!\n",\r\nptr->name);\r\nreturn -ENXIO;\r\n}\r\nzr36050_wait_end(ptr);\r\nif ((ptr->status1 & 0x4) == 0) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: attach failed, jpeg processor failed (end flag)!\n",\r\nptr->name);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nzr36050_pushit (struct zr36050 *ptr,\r\nu16 startreg,\r\nu16 len,\r\nconst char *data)\r\n{\r\nint i = 0;\r\ndprintk(4, "%s: write data block to 0x%04x (len=%d)\n", ptr->name,\r\nstartreg, len);\r\nwhile (i < len) {\r\nzr36050_write(ptr, startreg++, data[i++]);\r\n}\r\nreturn i;\r\n}\r\nstatic int\r\nzr36050_set_sof (struct zr36050 *ptr)\r\n{\r\nchar sof_data[34];\r\nint i;\r\ndprintk(3, "%s: write SOF (%dx%d, %d components)\n", ptr->name,\r\nptr->width, ptr->height, NO_OF_COMPONENTS);\r\nsof_data[0] = 0xff;\r\nsof_data[1] = 0xc0;\r\nsof_data[2] = 0x00;\r\nsof_data[3] = (3 * NO_OF_COMPONENTS) + 8;\r\nsof_data[4] = BASELINE_PRECISION;\r\nsof_data[5] = (ptr->height) >> 8;\r\nsof_data[6] = (ptr->height) & 0xff;\r\nsof_data[7] = (ptr->width) >> 8;\r\nsof_data[8] = (ptr->width) & 0xff;\r\nsof_data[9] = NO_OF_COMPONENTS;\r\nfor (i = 0; i < NO_OF_COMPONENTS; i++) {\r\nsof_data[10 + (i * 3)] = i;\r\nsof_data[11 + (i * 3)] = (ptr->h_samp_ratio[i] << 4) | (ptr->v_samp_ratio[i]);\r\nsof_data[12 + (i * 3)] = zr36050_tq[i];\r\n}\r\nreturn zr36050_pushit(ptr, ZR050_SOF_IDX,\r\n(3 * NO_OF_COMPONENTS) + 10, sof_data);\r\n}\r\nstatic int\r\nzr36050_set_sos (struct zr36050 *ptr)\r\n{\r\nchar sos_data[16];\r\nint i;\r\ndprintk(3, "%s: write SOS\n", ptr->name);\r\nsos_data[0] = 0xff;\r\nsos_data[1] = 0xda;\r\nsos_data[2] = 0x00;\r\nsos_data[3] = 2 + 1 + (2 * NO_OF_COMPONENTS) + 3;\r\nsos_data[4] = NO_OF_COMPONENTS;\r\nfor (i = 0; i < NO_OF_COMPONENTS; i++) {\r\nsos_data[5 + (i * 2)] = i;\r\nsos_data[6 + (i * 2)] = (zr36050_td[i] << 4) | zr36050_ta[i];\r\n}\r\nsos_data[2 + 1 + (2 * NO_OF_COMPONENTS) + 2] = 00;\r\nsos_data[2 + 1 + (2 * NO_OF_COMPONENTS) + 3] = 0x3F;\r\nsos_data[2 + 1 + (2 * NO_OF_COMPONENTS) + 4] = 00;\r\nreturn zr36050_pushit(ptr, ZR050_SOS1_IDX,\r\n4 + 1 + (2 * NO_OF_COMPONENTS) + 3,\r\nsos_data);\r\n}\r\nstatic int\r\nzr36050_set_dri (struct zr36050 *ptr)\r\n{\r\nchar dri_data[6];\r\ndprintk(3, "%s: write DRI\n", ptr->name);\r\ndri_data[0] = 0xff;\r\ndri_data[1] = 0xdd;\r\ndri_data[2] = 0x00;\r\ndri_data[3] = 0x04;\r\ndri_data[4] = ptr->dri >> 8;\r\ndri_data[5] = ptr->dri & 0xff;\r\nreturn zr36050_pushit(ptr, ZR050_DRI_IDX, 6, dri_data);\r\n}\r\nstatic void\r\nzr36050_init (struct zr36050 *ptr)\r\n{\r\nint sum = 0;\r\nlong bitcnt, tmp;\r\nif (ptr->mode == CODEC_DO_COMPRESSION) {\r\ndprintk(2, "%s: COMPRESSION SETUP\n", ptr->name);\r\nzr36050_write(ptr, ZR050_HARDWARE, ZR050_HW_MSTR);\r\nzr36050_write(ptr, ZR050_MODE,\r\nZR050_MO_COMP | ZR050_MO_TLM);\r\nzr36050_write(ptr, ZR050_OPTIONS, 0);\r\nzr36050_write(ptr, ZR050_INT_REQ_0, 0);\r\nzr36050_write(ptr, ZR050_INT_REQ_1, 3);\r\nzr36050_write(ptr, ZR050_SF_HI, ptr->scalefact >> 8);\r\nzr36050_write(ptr, ZR050_SF_LO, ptr->scalefact & 0xff);\r\nzr36050_write(ptr, ZR050_AF_HI, 0xff);\r\nzr36050_write(ptr, ZR050_AF_M, 0xff);\r\nzr36050_write(ptr, ZR050_AF_LO, 0xff);\r\nsum += zr36050_set_sof(ptr);\r\nsum += zr36050_set_sos(ptr);\r\nsum += zr36050_set_dri(ptr);\r\ndprintk(3, "%s: write DQT, DHT, APP\n", ptr->name);\r\nsum += zr36050_pushit(ptr, ZR050_DQT_IDX,\r\nsizeof(zr36050_dqt), zr36050_dqt);\r\nsum += zr36050_pushit(ptr, ZR050_DHT_IDX,\r\nsizeof(zr36050_dht), zr36050_dht);\r\nzr36050_write(ptr, ZR050_APP_IDX, 0xff);\r\nzr36050_write(ptr, ZR050_APP_IDX + 1, 0xe0 + ptr->app.appn);\r\nzr36050_write(ptr, ZR050_APP_IDX + 2, 0x00);\r\nzr36050_write(ptr, ZR050_APP_IDX + 3, ptr->app.len + 2);\r\nsum += zr36050_pushit(ptr, ZR050_APP_IDX + 4, 60,\r\nptr->app.data) + 4;\r\nzr36050_write(ptr, ZR050_COM_IDX, 0xff);\r\nzr36050_write(ptr, ZR050_COM_IDX + 1, 0xfe);\r\nzr36050_write(ptr, ZR050_COM_IDX + 2, 0x00);\r\nzr36050_write(ptr, ZR050_COM_IDX + 3, ptr->com.len + 2);\r\nsum += zr36050_pushit(ptr, ZR050_COM_IDX + 4, 60,\r\nptr->com.data) + 4;\r\nzr36050_write(ptr, ZR050_MARKERS_EN, ZR050_ME_DHTI);\r\nzr36050_write(ptr, ZR050_GO, 1);\r\nzr36050_wait_end(ptr);\r\ndprintk(2, "%s: Status after table preload: 0x%02x\n",\r\nptr->name, ptr->status1);\r\nif ((ptr->status1 & 0x4) == 0) {\r\ndprintk(1, KERN_ERR "%s: init aborted!\n",\r\nptr->name);\r\nreturn;\r\n}\r\nsum = ptr->real_code_vol - sum;\r\nbitcnt = sum << 3;\r\ntmp = bitcnt >> 16;\r\ndprintk(3,\r\n"%s: code: csize=%d, tot=%d, bit=%ld, highbits=%ld\n",\r\nptr->name, sum, ptr->real_code_vol, bitcnt, tmp);\r\nzr36050_write(ptr, ZR050_TCV_NET_HI, tmp >> 8);\r\nzr36050_write(ptr, ZR050_TCV_NET_MH, tmp & 0xff);\r\ntmp = bitcnt & 0xffff;\r\nzr36050_write(ptr, ZR050_TCV_NET_ML, tmp >> 8);\r\nzr36050_write(ptr, ZR050_TCV_NET_LO, tmp & 0xff);\r\nbitcnt -= bitcnt >> 7;\r\nbitcnt -= ((bitcnt * 5) >> 6);\r\ntmp = bitcnt >> 16;\r\ndprintk(3, "%s: code: nettobit=%ld, highnettobits=%ld\n",\r\nptr->name, bitcnt, tmp);\r\nzr36050_write(ptr, ZR050_TCV_DATA_HI, tmp >> 8);\r\nzr36050_write(ptr, ZR050_TCV_DATA_MH, tmp & 0xff);\r\ntmp = bitcnt & 0xffff;\r\nzr36050_write(ptr, ZR050_TCV_DATA_ML, tmp >> 8);\r\nzr36050_write(ptr, ZR050_TCV_DATA_LO, tmp & 0xff);\r\nzr36050_write(ptr, ZR050_MODE,\r\nZR050_MO_COMP | ZR050_MO_PASS2 |\r\n(ptr->bitrate_ctrl ? ZR050_MO_BRC : 0));\r\nzr36050_write(ptr, ZR050_MARKERS_EN,\r\nZR050_ME_DQT | ZR050_ME_DHT |\r\n((ptr->app.len > 0) ? ZR050_ME_APP : 0) |\r\n((ptr->com.len > 0) ? ZR050_ME_COM : 0));\r\n} else {\r\ndprintk(2, "%s: EXPANSION SETUP\n", ptr->name);\r\nzr36050_write(ptr, ZR050_HARDWARE,\r\nZR050_HW_MSTR | ZR050_HW_CFIS_2_CLK);\r\nzr36050_write(ptr, ZR050_MODE, ZR050_MO_TLM);\r\nzr36050_write(ptr, ZR050_INT_REQ_0, 0);\r\nzr36050_write(ptr, ZR050_INT_REQ_1, 3);\r\ndprintk(3, "%s: write DHT\n", ptr->name);\r\nzr36050_pushit(ptr, ZR050_DHT_IDX, sizeof(zr36050_dht),\r\nzr36050_dht);\r\nzr36050_write(ptr, ZR050_MARKERS_EN, ZR050_ME_DHTI);\r\nzr36050_write(ptr, ZR050_GO, 1);\r\nzr36050_wait_end(ptr);\r\ndprintk(2, "%s: Status after table preload: 0x%02x\n",\r\nptr->name, ptr->status1);\r\nif ((ptr->status1 & 0x4) == 0) {\r\ndprintk(1, KERN_ERR "%s: init aborted!\n",\r\nptr->name);\r\nreturn;\r\n}\r\nzr36050_write(ptr, ZR050_MODE, 0);\r\nzr36050_write(ptr, ZR050_MARKERS_EN, 0);\r\n}\r\nzr36050_read(ptr, 0);\r\n}\r\nstatic int\r\nzr36050_set_mode (struct videocodec *codec,\r\nint mode)\r\n{\r\nstruct zr36050 *ptr = (struct zr36050 *) codec->data;\r\ndprintk(2, "%s: set_mode %d call\n", ptr->name, mode);\r\nif ((mode != CODEC_DO_EXPANSION) && (mode != CODEC_DO_COMPRESSION))\r\nreturn -EINVAL;\r\nptr->mode = mode;\r\nzr36050_init(ptr);\r\nreturn 0;\r\n}\r\nstatic int\r\nzr36050_set_video (struct videocodec *codec,\r\nstruct tvnorm *norm,\r\nstruct vfe_settings *cap,\r\nstruct vfe_polarity *pol)\r\n{\r\nstruct zr36050 *ptr = (struct zr36050 *) codec->data;\r\nint size;\r\ndprintk(2, "%s: set_video %d.%d, %d/%d-%dx%d (0x%x) q%d call\n",\r\nptr->name, norm->HStart, norm->VStart,\r\ncap->x, cap->y, cap->width, cap->height,\r\ncap->decimation, cap->quality);\r\nptr->width = cap->width / (cap->decimation & 0xff);\r\nptr->height = cap->height / ((cap->decimation >> 8) & 0xff);\r\nsize = ptr->width * ptr->height;\r\nsize *= 16;\r\nsize = size * cap->quality / 200;\r\nif (size < 8192)\r\nsize = 8192;\r\nif (size > ptr->total_code_vol * 7)\r\nsize = ptr->total_code_vol * 7;\r\nptr->real_code_vol = size >> 3;\r\nzr36050_write(ptr, ZR050_MBCV, ptr->max_block_vol);\r\nreturn 0;\r\n}\r\nstatic int\r\nzr36050_control (struct videocodec *codec,\r\nint type,\r\nint size,\r\nvoid *data)\r\n{\r\nstruct zr36050 *ptr = (struct zr36050 *) codec->data;\r\nint *ival = (int *) data;\r\ndprintk(2, "%s: control %d call with %d byte\n", ptr->name, type,\r\nsize);\r\nswitch (type) {\r\ncase CODEC_G_STATUS:\r\nif (size != sizeof(int))\r\nreturn -EFAULT;\r\nzr36050_read_status1(ptr);\r\n*ival = ptr->status1;\r\nbreak;\r\ncase CODEC_G_CODEC_MODE:\r\nif (size != sizeof(int))\r\nreturn -EFAULT;\r\n*ival = CODEC_MODE_BJPG;\r\nbreak;\r\ncase CODEC_S_CODEC_MODE:\r\nif (size != sizeof(int))\r\nreturn -EFAULT;\r\nif (*ival != CODEC_MODE_BJPG)\r\nreturn -EINVAL;\r\nreturn 0;\r\ncase CODEC_G_VFE:\r\ncase CODEC_S_VFE:\r\nreturn 0;\r\ncase CODEC_S_MMAP:\r\nreturn -ENXIO;\r\ncase CODEC_G_JPEG_TDS_BYTE:\r\nif (size != sizeof(int))\r\nreturn -EFAULT;\r\n*ival = ptr->total_code_vol;\r\nbreak;\r\ncase CODEC_S_JPEG_TDS_BYTE:\r\nif (size != sizeof(int))\r\nreturn -EFAULT;\r\nptr->total_code_vol = *ival;\r\nptr->real_code_vol = (ptr->total_code_vol * 6) >> 3;\r\nbreak;\r\ncase CODEC_G_JPEG_SCALE:\r\nif (size != sizeof(int))\r\nreturn -EFAULT;\r\n*ival = zr36050_read_scalefactor(ptr);\r\nbreak;\r\ncase CODEC_S_JPEG_SCALE:\r\nif (size != sizeof(int))\r\nreturn -EFAULT;\r\nptr->scalefact = *ival;\r\nbreak;\r\ncase CODEC_G_JPEG_APP_DATA: {\r\nstruct jpeg_app_marker *app = data;\r\nif (size != sizeof(struct jpeg_app_marker))\r\nreturn -EFAULT;\r\n*app = ptr->app;\r\nbreak;\r\n}\r\ncase CODEC_S_JPEG_APP_DATA: {\r\nstruct jpeg_app_marker *app = data;\r\nif (size != sizeof(struct jpeg_app_marker))\r\nreturn -EFAULT;\r\nptr->app = *app;\r\nbreak;\r\n}\r\ncase CODEC_G_JPEG_COM_DATA: {\r\nstruct jpeg_com_marker *com = data;\r\nif (size != sizeof(struct jpeg_com_marker))\r\nreturn -EFAULT;\r\n*com = ptr->com;\r\nbreak;\r\n}\r\ncase CODEC_S_JPEG_COM_DATA: {\r\nstruct jpeg_com_marker *com = data;\r\nif (size != sizeof(struct jpeg_com_marker))\r\nreturn -EFAULT;\r\nptr->com = *com;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn size;\r\n}\r\nstatic int\r\nzr36050_unset (struct videocodec *codec)\r\n{\r\nstruct zr36050 *ptr = codec->data;\r\nif (ptr) {\r\ndprintk(1, "%s: finished codec #%d\n", ptr->name,\r\nptr->num);\r\nkfree(ptr);\r\ncodec->data = NULL;\r\nzr36050_codecs--;\r\nreturn 0;\r\n}\r\nreturn -EFAULT;\r\n}\r\nstatic int\r\nzr36050_setup (struct videocodec *codec)\r\n{\r\nstruct zr36050 *ptr;\r\nint res;\r\ndprintk(2, "zr36050: initializing MJPEG subsystem #%d.\n",\r\nzr36050_codecs);\r\nif (zr36050_codecs == MAX_CODECS) {\r\ndprintk(1,\r\nKERN_ERR "zr36050: Can't attach more codecs!\n");\r\nreturn -ENOSPC;\r\n}\r\ncodec->data = ptr = kzalloc(sizeof(struct zr36050), GFP_KERNEL);\r\nif (NULL == ptr) {\r\ndprintk(1, KERN_ERR "zr36050: Can't get enough memory!\n");\r\nreturn -ENOMEM;\r\n}\r\nsnprintf(ptr->name, sizeof(ptr->name), "zr36050[%d]",\r\nzr36050_codecs);\r\nptr->num = zr36050_codecs++;\r\nptr->codec = codec;\r\nres = zr36050_basic_test(ptr);\r\nif (res < 0) {\r\nzr36050_unset(codec);\r\nreturn res;\r\n}\r\nmemcpy(ptr->h_samp_ratio, zr36050_decimation_h, 8);\r\nmemcpy(ptr->v_samp_ratio, zr36050_decimation_v, 8);\r\nptr->bitrate_ctrl = 0;\r\nptr->mode = CODEC_DO_COMPRESSION;\r\nptr->width = 384;\r\nptr->height = 288;\r\nptr->total_code_vol = 16000;\r\nptr->max_block_vol = 240;\r\nptr->scalefact = 0x100;\r\nptr->dri = 1;\r\nptr->app.appn = 0;\r\nptr->app.len = 0;\r\nptr->com.len = 0;\r\nzr36050_init(ptr);\r\ndprintk(1, KERN_INFO "%s: codec attached and running\n",\r\nptr->name);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nzr36050_init_module (void)\r\n{\r\nzr36050_codecs = 0;\r\nreturn videocodec_register(&zr36050_codec);\r\n}\r\nstatic void __exit\r\nzr36050_cleanup_module (void)\r\n{\r\nif (zr36050_codecs) {\r\ndprintk(1,\r\n"zr36050: something's wrong - %d codecs left somehow.\n",\r\nzr36050_codecs);\r\n}\r\nvideocodec_unregister(&zr36050_codec);\r\n}
