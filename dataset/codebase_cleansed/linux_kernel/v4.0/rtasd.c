static char *rtas_event_type(int type)\r\n{\r\nif ((type > 0) && (type < 11))\r\nreturn rtas_type[type];\r\nswitch (type) {\r\ncase RTAS_TYPE_EPOW:\r\nreturn "EPOW";\r\ncase RTAS_TYPE_PLATFORM:\r\nreturn "Platform Error";\r\ncase RTAS_TYPE_IO:\r\nreturn "I/O Event";\r\ncase RTAS_TYPE_INFO:\r\nreturn "Platform Information Event";\r\ncase RTAS_TYPE_DEALLOC:\r\nreturn "Resource Deallocation Event";\r\ncase RTAS_TYPE_DUMP:\r\nreturn "Dump Notification Event";\r\ncase RTAS_TYPE_PRRN:\r\nreturn "Platform Resource Reassignment Event";\r\n}\r\nreturn rtas_type[0];\r\n}\r\nstatic void printk_log_rtas(char *buf, int len)\r\n{\r\nint i,j,n = 0;\r\nint perline = 16;\r\nchar buffer[64];\r\nchar * str = "RTAS event";\r\nif (full_rtas_msgs) {\r\nprintk(RTAS_DEBUG "%d -------- %s begin --------\n",\r\nerror_log_cnt, str);\r\nfor (i = 0; i < len; i++) {\r\nj = i % perline;\r\nif (j == 0) {\r\nmemset(buffer, 0, sizeof(buffer));\r\nn = sprintf(buffer, "RTAS %d:", i/perline);\r\n}\r\nif ((i % 4) == 0)\r\nn += sprintf(buffer+n, " ");\r\nn += sprintf(buffer+n, "%02x", (unsigned char)buf[i]);\r\nif (j == (perline-1))\r\nprintk(KERN_DEBUG "%s\n", buffer);\r\n}\r\nif ((i % perline) != 0)\r\nprintk(KERN_DEBUG "%s\n", buffer);\r\nprintk(RTAS_DEBUG "%d -------- %s end ----------\n",\r\nerror_log_cnt, str);\r\n} else {\r\nstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\r\nprintk(RTAS_DEBUG "event: %d, Type: %s, Severity: %d\n",\r\nerror_log_cnt, rtas_event_type(rtas_error_type(errlog)),\r\nrtas_error_severity(errlog));\r\n}\r\n}\r\nstatic int log_rtas_len(char * buf)\r\n{\r\nint len;\r\nstruct rtas_error_log *err;\r\nuint32_t extended_log_length;\r\nlen = 8;\r\nerr = (struct rtas_error_log *)buf;\r\nextended_log_length = rtas_error_extended_log_length(err);\r\nif (rtas_error_extended(err) && extended_log_length) {\r\nlen += extended_log_length;\r\n}\r\nif (rtas_error_log_max == 0)\r\nrtas_error_log_max = rtas_get_error_log_max();\r\nif (len > rtas_error_log_max)\r\nlen = rtas_error_log_max;\r\nreturn len;\r\n}\r\nvoid pSeries_log_error(char *buf, unsigned int err_type, int fatal)\r\n{\r\nunsigned long offset;\r\nunsigned long s;\r\nint len = 0;\r\npr_debug("rtasd: logging event\n");\r\nif (buf == NULL)\r\nreturn;\r\nspin_lock_irqsave(&rtasd_log_lock, s);\r\nswitch (err_type & ERR_TYPE_MASK) {\r\ncase ERR_TYPE_RTAS_LOG:\r\nlen = log_rtas_len(buf);\r\nif (!(err_type & ERR_FLAG_BOOT))\r\nerror_log_cnt++;\r\nbreak;\r\ncase ERR_TYPE_KERNEL_PANIC:\r\ndefault:\r\nWARN_ON_ONCE(!irqs_disabled());\r\nspin_unlock_irqrestore(&rtasd_log_lock, s);\r\nreturn;\r\n}\r\n#ifdef CONFIG_PPC64\r\nif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\r\nnvram_write_error_log(buf, len, err_type, error_log_cnt);\r\n#endif\r\nif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\r\nprintk_log_rtas(buf, len);\r\nif (fatal || !logging_enabled) {\r\nlogging_enabled = 0;\r\nWARN_ON_ONCE(!irqs_disabled());\r\nspin_unlock_irqrestore(&rtasd_log_lock, s);\r\nreturn;\r\n}\r\nswitch (err_type & ERR_TYPE_MASK) {\r\ncase ERR_TYPE_RTAS_LOG:\r\noffset = rtas_error_log_buffer_max *\r\n((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\r\nmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\r\noffset += sizeof(int);\r\nmemcpy(&rtas_log_buf[offset], buf, len);\r\nif (rtas_log_size < LOG_NUMBER)\r\nrtas_log_size += 1;\r\nelse\r\nrtas_log_start += 1;\r\nWARN_ON_ONCE(!irqs_disabled());\r\nspin_unlock_irqrestore(&rtasd_log_lock, s);\r\nwake_up_interruptible(&rtas_log_wait);\r\nbreak;\r\ncase ERR_TYPE_KERNEL_PANIC:\r\ndefault:\r\nWARN_ON_ONCE(!irqs_disabled());\r\nspin_unlock_irqrestore(&rtasd_log_lock, s);\r\nreturn;\r\n}\r\n}\r\nstatic void prrn_work_fn(struct work_struct *work)\r\n{\r\npseries_devicetree_update(-prrn_update_scope);\r\n}\r\nstatic void prrn_schedule_update(u32 scope)\r\n{\r\nflush_work(&prrn_work);\r\nprrn_update_scope = scope;\r\nschedule_work(&prrn_work);\r\n}\r\nstatic void handle_rtas_event(const struct rtas_error_log *log)\r\n{\r\nif (rtas_error_type(log) != RTAS_TYPE_PRRN || !prrn_is_enabled())\r\nreturn;\r\nprrn_schedule_update(rtas_error_extended_log_length(log));\r\n}\r\nstatic void handle_rtas_event(const struct rtas_error_log *log)\r\n{\r\nreturn;\r\n}\r\nstatic int rtas_log_open(struct inode * inode, struct file * file)\r\n{\r\nreturn 0;\r\n}\r\nstatic int rtas_log_release(struct inode * inode, struct file * file)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t rtas_log_read(struct file * file, char __user * buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint error;\r\nchar *tmp;\r\nunsigned long s;\r\nunsigned long offset;\r\nif (!buf || count < rtas_error_log_buffer_max)\r\nreturn -EINVAL;\r\ncount = rtas_error_log_buffer_max;\r\nif (!access_ok(VERIFY_WRITE, buf, count))\r\nreturn -EFAULT;\r\ntmp = kmalloc(count, GFP_KERNEL);\r\nif (!tmp)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&rtasd_log_lock, s);\r\nwhile (rtas_log_size == 0) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nspin_unlock_irqrestore(&rtasd_log_lock, s);\r\nerror = -EAGAIN;\r\ngoto out;\r\n}\r\nif (!logging_enabled) {\r\nspin_unlock_irqrestore(&rtasd_log_lock, s);\r\nerror = -ENODATA;\r\ngoto out;\r\n}\r\n#ifdef CONFIG_PPC64\r\nnvram_clear_error_log();\r\n#endif\r\nspin_unlock_irqrestore(&rtasd_log_lock, s);\r\nerror = wait_event_interruptible(rtas_log_wait, rtas_log_size);\r\nif (error)\r\ngoto out;\r\nspin_lock_irqsave(&rtasd_log_lock, s);\r\n}\r\noffset = rtas_error_log_buffer_max * (rtas_log_start & LOG_NUMBER_MASK);\r\nmemcpy(tmp, &rtas_log_buf[offset], count);\r\nrtas_log_start += 1;\r\nrtas_log_size -= 1;\r\nspin_unlock_irqrestore(&rtasd_log_lock, s);\r\nerror = copy_to_user(buf, tmp, count) ? -EFAULT : count;\r\nout:\r\nkfree(tmp);\r\nreturn error;\r\n}\r\nstatic unsigned int rtas_log_poll(struct file *file, poll_table * wait)\r\n{\r\npoll_wait(file, &rtas_log_wait, wait);\r\nif (rtas_log_size)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int enable_surveillance(int timeout)\r\n{\r\nint error;\r\nerror = rtas_set_indicator(SURVEILLANCE_TOKEN, 0, timeout);\r\nif (error == 0)\r\nreturn 0;\r\nif (error == -EINVAL) {\r\nprintk(KERN_DEBUG "rtasd: surveillance not supported\n");\r\nreturn 0;\r\n}\r\nprintk(KERN_ERR "rtasd: could not update surveillance\n");\r\nreturn -1;\r\n}\r\nstatic void do_event_scan(void)\r\n{\r\nint error;\r\ndo {\r\nmemset(logdata, 0, rtas_error_log_max);\r\nerror = rtas_call(event_scan, 4, 1, NULL,\r\nRTAS_EVENT_SCAN_ALL_EVENTS, 0,\r\n__pa(logdata), rtas_error_log_max);\r\nif (error == -1) {\r\nprintk(KERN_ERR "event-scan failed\n");\r\nbreak;\r\n}\r\nif (error == 0) {\r\npSeries_log_error(logdata, ERR_TYPE_RTAS_LOG, 0);\r\nhandle_rtas_event((struct rtas_error_log *)logdata);\r\n}\r\n} while(error == 0);\r\n}\r\nstatic void rtas_event_scan(struct work_struct *w)\r\n{\r\nunsigned int cpu;\r\ndo_event_scan();\r\nget_online_cpus();\r\ncpu = cpumask_next(raw_smp_processor_id(), cpu_online_mask);\r\nif (cpu >= nr_cpu_ids) {\r\ncpu = cpumask_first(cpu_online_mask);\r\nif (first_pass) {\r\nfirst_pass = 0;\r\nevent_scan_delay = 30*HZ/rtas_event_scan_rate;\r\nif (surveillance_timeout != -1) {\r\npr_debug("rtasd: enabling surveillance\n");\r\nenable_surveillance(surveillance_timeout);\r\npr_debug("rtasd: surveillance enabled\n");\r\n}\r\n}\r\n}\r\nschedule_delayed_work_on(cpu, &event_scan_work,\r\n__round_jiffies_relative(event_scan_delay, cpu));\r\nput_online_cpus();\r\n}\r\nstatic void retreive_nvram_error_log(void)\r\n{\r\nunsigned int err_type ;\r\nint rc ;\r\nmemset(logdata, 0, rtas_error_log_max);\r\nrc = nvram_read_error_log(logdata, rtas_error_log_max,\r\n&err_type, &error_log_cnt);\r\nlogging_enabled = 1;\r\nif (!rc) {\r\nif (err_type != ERR_FLAG_ALREADY_LOGGED) {\r\npSeries_log_error(logdata, err_type | ERR_FLAG_BOOT, 0);\r\n}\r\n}\r\n}\r\nstatic void retreive_nvram_error_log(void)\r\n{\r\n}\r\nstatic void start_event_scan(void)\r\n{\r\nprintk(KERN_DEBUG "RTAS daemon started\n");\r\npr_debug("rtasd: will sleep for %d milliseconds\n",\r\n(30000 / rtas_event_scan_rate));\r\nretreive_nvram_error_log();\r\nschedule_delayed_work_on(cpumask_first(cpu_online_mask),\r\n&event_scan_work, event_scan_delay);\r\n}\r\nvoid rtas_cancel_event_scan(void)\r\n{\r\ncancel_delayed_work_sync(&event_scan_work);\r\n}\r\nstatic int __init rtas_init(void)\r\n{\r\nstruct proc_dir_entry *entry;\r\nif (!machine_is(pseries) && !machine_is(chrp))\r\nreturn 0;\r\nevent_scan = rtas_token("event-scan");\r\nif (event_scan == RTAS_UNKNOWN_SERVICE) {\r\nprintk(KERN_INFO "rtasd: No event-scan on system\n");\r\nreturn -ENODEV;\r\n}\r\nrtas_event_scan_rate = rtas_token("rtas-event-scan-rate");\r\nif (rtas_event_scan_rate == RTAS_UNKNOWN_SERVICE) {\r\nprintk(KERN_ERR "rtasd: no rtas-event-scan-rate on system\n");\r\nreturn -ENODEV;\r\n}\r\nif (!rtas_event_scan_rate) {\r\nprintk(KERN_DEBUG "rtasd: scan rate is 0, not scanning\n");\r\nreturn 0;\r\n}\r\nrtas_error_log_max = rtas_get_error_log_max();\r\nrtas_error_log_buffer_max = rtas_error_log_max + sizeof(int);\r\nrtas_log_buf = vmalloc(rtas_error_log_buffer_max*LOG_NUMBER);\r\nif (!rtas_log_buf) {\r\nprintk(KERN_ERR "rtasd: no memory\n");\r\nreturn -ENOMEM;\r\n}\r\nentry = proc_create("powerpc/rtas/error_log", S_IRUSR, NULL,\r\n&proc_rtas_log_operations);\r\nif (!entry)\r\nprintk(KERN_ERR "Failed to create error_log proc entry\n");\r\nstart_event_scan();\r\nreturn 0;\r\n}\r\nstatic int __init surveillance_setup(char *str)\r\n{\r\nint i;\r\nif (!machine_is(pseries))\r\nreturn 0;\r\nif (get_option(&str,&i)) {\r\nif (i >= 0 && i <= 255)\r\nsurveillance_timeout = i;\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init rtasmsgs_setup(char *str)\r\n{\r\nif (strcmp(str, "on") == 0)\r\nfull_rtas_msgs = 1;\r\nelse if (strcmp(str, "off") == 0)\r\nfull_rtas_msgs = 0;\r\nreturn 1;\r\n}
