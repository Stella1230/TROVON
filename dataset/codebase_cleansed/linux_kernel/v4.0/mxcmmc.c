static inline int is_imx31_mmc(struct mxcmci_host *host)\r\n{\r\nreturn host->devtype == IMX31_MMC;\r\n}\r\nstatic inline int is_mpc512x_mmc(struct mxcmci_host *host)\r\n{\r\nreturn host->devtype == MPC512X_MMC;\r\n}\r\nstatic inline u32 mxcmci_readl(struct mxcmci_host *host, int reg)\r\n{\r\nif (IS_ENABLED(CONFIG_PPC_MPC512x))\r\nreturn ioread32be(host->base + reg);\r\nelse\r\nreturn readl(host->base + reg);\r\n}\r\nstatic inline void mxcmci_writel(struct mxcmci_host *host, u32 val, int reg)\r\n{\r\nif (IS_ENABLED(CONFIG_PPC_MPC512x))\r\niowrite32be(val, host->base + reg);\r\nelse\r\nwritel(val, host->base + reg);\r\n}\r\nstatic inline u16 mxcmci_readw(struct mxcmci_host *host, int reg)\r\n{\r\nif (IS_ENABLED(CONFIG_PPC_MPC512x))\r\nreturn ioread32be(host->base + reg);\r\nelse\r\nreturn readw(host->base + reg);\r\n}\r\nstatic inline void mxcmci_writew(struct mxcmci_host *host, u16 val, int reg)\r\n{\r\nif (IS_ENABLED(CONFIG_PPC_MPC512x))\r\niowrite32be(val, host->base + reg);\r\nelse\r\nwritew(val, host->base + reg);\r\n}\r\nstatic void mxcmci_set_power(struct mxcmci_host *host, unsigned int vdd)\r\n{\r\nif (!IS_ERR(host->mmc->supply.vmmc)) {\r\nif (host->power_mode == MMC_POWER_UP)\r\nmmc_regulator_set_ocr(host->mmc,\r\nhost->mmc->supply.vmmc, vdd);\r\nelse if (host->power_mode == MMC_POWER_OFF)\r\nmmc_regulator_set_ocr(host->mmc,\r\nhost->mmc->supply.vmmc, 0);\r\n}\r\nif (host->pdata && host->pdata->setpower)\r\nhost->pdata->setpower(mmc_dev(host->mmc), vdd);\r\n}\r\nstatic inline int mxcmci_use_dma(struct mxcmci_host *host)\r\n{\r\nreturn host->do_dma;\r\n}\r\nstatic void mxcmci_softreset(struct mxcmci_host *host)\r\n{\r\nint i;\r\ndev_dbg(mmc_dev(host->mmc), "mxcmci_softreset\n");\r\nmxcmci_writew(host, STR_STP_CLK_RESET, MMC_REG_STR_STP_CLK);\r\nmxcmci_writew(host, STR_STP_CLK_RESET | STR_STP_CLK_START_CLK,\r\nMMC_REG_STR_STP_CLK);\r\nfor (i = 0; i < 8; i++)\r\nmxcmci_writew(host, STR_STP_CLK_START_CLK, MMC_REG_STR_STP_CLK);\r\nmxcmci_writew(host, 0xff, MMC_REG_RES_TO);\r\n}\r\nstatic inline void buffer_swap32(u32 *buf, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < ((len + 3) / 4); i++) {\r\nst_le32(buf, *buf);\r\nbuf++;\r\n}\r\n}\r\nstatic void mxcmci_swap_buffers(struct mmc_data *data)\r\n{\r\nstruct scatterlist *sg;\r\nint i;\r\nfor_each_sg(data->sg, sg, data->sg_len, i)\r\nbuffer_swap32(sg_virt(sg), sg->length);\r\n}\r\nstatic inline void mxcmci_swap_buffers(struct mmc_data *data) {}\r\nstatic int mxcmci_setup_data(struct mxcmci_host *host, struct mmc_data *data)\r\n{\r\nunsigned int nob = data->blocks;\r\nunsigned int blksz = data->blksz;\r\nunsigned int datasize = nob * blksz;\r\nstruct scatterlist *sg;\r\nenum dma_transfer_direction slave_dirn;\r\nint i, nents;\r\nif (data->flags & MMC_DATA_STREAM)\r\nnob = 0xffff;\r\nhost->data = data;\r\ndata->bytes_xfered = 0;\r\nmxcmci_writew(host, nob, MMC_REG_NOB);\r\nmxcmci_writew(host, blksz, MMC_REG_BLK_LEN);\r\nhost->datasize = datasize;\r\nif (!mxcmci_use_dma(host))\r\nreturn 0;\r\nfor_each_sg(data->sg, sg, data->sg_len, i) {\r\nif (sg->offset & 3 || sg->length & 3 || sg->length < 512) {\r\nhost->do_dma = 0;\r\nreturn 0;\r\n}\r\n}\r\nif (data->flags & MMC_DATA_READ) {\r\nhost->dma_dir = DMA_FROM_DEVICE;\r\nslave_dirn = DMA_DEV_TO_MEM;\r\n} else {\r\nhost->dma_dir = DMA_TO_DEVICE;\r\nslave_dirn = DMA_MEM_TO_DEV;\r\nmxcmci_swap_buffers(data);\r\n}\r\nnents = dma_map_sg(host->dma->device->dev, data->sg,\r\ndata->sg_len, host->dma_dir);\r\nif (nents != data->sg_len)\r\nreturn -EINVAL;\r\nhost->desc = dmaengine_prep_slave_sg(host->dma,\r\ndata->sg, data->sg_len, slave_dirn,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!host->desc) {\r\ndma_unmap_sg(host->dma->device->dev, data->sg, data->sg_len,\r\nhost->dma_dir);\r\nhost->do_dma = 0;\r\nreturn 0;\r\n}\r\nwmb();\r\ndmaengine_submit(host->desc);\r\ndma_async_issue_pending(host->dma);\r\nmod_timer(&host->watchdog, jiffies + msecs_to_jiffies(MXCMCI_TIMEOUT_MS));\r\nreturn 0;\r\n}\r\nstatic void mxcmci_dma_callback(void *data)\r\n{\r\nstruct mxcmci_host *host = data;\r\nu32 stat;\r\ndel_timer(&host->watchdog);\r\nstat = mxcmci_readl(host, MMC_REG_STATUS);\r\ndev_dbg(mmc_dev(host->mmc), "%s: 0x%08x\n", __func__, stat);\r\nmxcmci_data_done(host, stat);\r\n}\r\nstatic int mxcmci_start_cmd(struct mxcmci_host *host, struct mmc_command *cmd,\r\nunsigned int cmdat)\r\n{\r\nu32 int_cntr = host->default_irq_mask;\r\nunsigned long flags;\r\nWARN_ON(host->cmd != NULL);\r\nhost->cmd = cmd;\r\nswitch (mmc_resp_type(cmd)) {\r\ncase MMC_RSP_R1:\r\ncase MMC_RSP_R1B:\r\ncmdat |= CMD_DAT_CONT_RESPONSE_48BIT_CRC;\r\nbreak;\r\ncase MMC_RSP_R2:\r\ncmdat |= CMD_DAT_CONT_RESPONSE_136BIT;\r\nbreak;\r\ncase MMC_RSP_R3:\r\ncmdat |= CMD_DAT_CONT_RESPONSE_48BIT;\r\nbreak;\r\ncase MMC_RSP_NONE:\r\nbreak;\r\ndefault:\r\ndev_err(mmc_dev(host->mmc), "unhandled response type 0x%x\n",\r\nmmc_resp_type(cmd));\r\ncmd->error = -EINVAL;\r\nreturn -EINVAL;\r\n}\r\nint_cntr = INT_END_CMD_RES_EN;\r\nif (mxcmci_use_dma(host)) {\r\nif (host->dma_dir == DMA_FROM_DEVICE) {\r\nhost->desc->callback = mxcmci_dma_callback;\r\nhost->desc->callback_param = host;\r\n} else {\r\nint_cntr |= INT_WRITE_OP_DONE_EN;\r\n}\r\n}\r\nspin_lock_irqsave(&host->lock, flags);\r\nif (host->use_sdio)\r\nint_cntr |= INT_SDIO_IRQ_EN;\r\nmxcmci_writel(host, int_cntr, MMC_REG_INT_CNTR);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nmxcmci_writew(host, cmd->opcode, MMC_REG_CMD);\r\nmxcmci_writel(host, cmd->arg, MMC_REG_ARG);\r\nmxcmci_writew(host, cmdat, MMC_REG_CMD_DAT_CONT);\r\nreturn 0;\r\n}\r\nstatic void mxcmci_finish_request(struct mxcmci_host *host,\r\nstruct mmc_request *req)\r\n{\r\nu32 int_cntr = host->default_irq_mask;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nif (host->use_sdio)\r\nint_cntr |= INT_SDIO_IRQ_EN;\r\nmxcmci_writel(host, int_cntr, MMC_REG_INT_CNTR);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nhost->req = NULL;\r\nhost->cmd = NULL;\r\nhost->data = NULL;\r\nmmc_request_done(host->mmc, req);\r\n}\r\nstatic int mxcmci_finish_data(struct mxcmci_host *host, unsigned int stat)\r\n{\r\nstruct mmc_data *data = host->data;\r\nint data_error;\r\nif (mxcmci_use_dma(host)) {\r\ndma_unmap_sg(host->dma->device->dev, data->sg, data->sg_len,\r\nhost->dma_dir);\r\nmxcmci_swap_buffers(data);\r\n}\r\nif (stat & STATUS_ERR_MASK) {\r\ndev_dbg(mmc_dev(host->mmc), "request failed. status: 0x%08x\n",\r\nstat);\r\nif (stat & STATUS_CRC_READ_ERR) {\r\ndev_err(mmc_dev(host->mmc), "%s: -EILSEQ\n", __func__);\r\ndata->error = -EILSEQ;\r\n} else if (stat & STATUS_CRC_WRITE_ERR) {\r\nu32 err_code = (stat >> 9) & 0x3;\r\nif (err_code == 2) {\r\ndev_err(mmc_dev(host->mmc),\r\n"%s: No CRC -ETIMEDOUT\n", __func__);\r\ndata->error = -ETIMEDOUT;\r\n} else {\r\ndev_err(mmc_dev(host->mmc),\r\n"%s: -EILSEQ\n", __func__);\r\ndata->error = -EILSEQ;\r\n}\r\n} else if (stat & STATUS_TIME_OUT_READ) {\r\ndev_err(mmc_dev(host->mmc),\r\n"%s: read -ETIMEDOUT\n", __func__);\r\ndata->error = -ETIMEDOUT;\r\n} else {\r\ndev_err(mmc_dev(host->mmc), "%s: -EIO\n", __func__);\r\ndata->error = -EIO;\r\n}\r\n} else {\r\ndata->bytes_xfered = host->datasize;\r\n}\r\ndata_error = data->error;\r\nhost->data = NULL;\r\nreturn data_error;\r\n}\r\nstatic void mxcmci_read_response(struct mxcmci_host *host, unsigned int stat)\r\n{\r\nstruct mmc_command *cmd = host->cmd;\r\nint i;\r\nu32 a, b, c;\r\nif (!cmd)\r\nreturn;\r\nif (stat & STATUS_TIME_OUT_RESP) {\r\ndev_dbg(mmc_dev(host->mmc), "CMD TIMEOUT\n");\r\ncmd->error = -ETIMEDOUT;\r\n} else if (stat & STATUS_RESP_CRC_ERR && cmd->flags & MMC_RSP_CRC) {\r\ndev_dbg(mmc_dev(host->mmc), "cmd crc error\n");\r\ncmd->error = -EILSEQ;\r\n}\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\nif (cmd->flags & MMC_RSP_136) {\r\nfor (i = 0; i < 4; i++) {\r\na = mxcmci_readw(host, MMC_REG_RES_FIFO);\r\nb = mxcmci_readw(host, MMC_REG_RES_FIFO);\r\ncmd->resp[i] = a << 16 | b;\r\n}\r\n} else {\r\na = mxcmci_readw(host, MMC_REG_RES_FIFO);\r\nb = mxcmci_readw(host, MMC_REG_RES_FIFO);\r\nc = mxcmci_readw(host, MMC_REG_RES_FIFO);\r\ncmd->resp[0] = a << 24 | b << 8 | c >> 8;\r\n}\r\n}\r\n}\r\nstatic int mxcmci_poll_status(struct mxcmci_host *host, u32 mask)\r\n{\r\nu32 stat;\r\nunsigned long timeout = jiffies + HZ;\r\ndo {\r\nstat = mxcmci_readl(host, MMC_REG_STATUS);\r\nif (stat & STATUS_ERR_MASK)\r\nreturn stat;\r\nif (time_after(jiffies, timeout)) {\r\nmxcmci_softreset(host);\r\nmxcmci_set_clk_rate(host, host->clock);\r\nreturn STATUS_TIME_OUT_READ;\r\n}\r\nif (stat & mask)\r\nreturn 0;\r\ncpu_relax();\r\n} while (1);\r\n}\r\nstatic int mxcmci_pull(struct mxcmci_host *host, void *_buf, int bytes)\r\n{\r\nunsigned int stat;\r\nu32 *buf = _buf;\r\nwhile (bytes > 3) {\r\nstat = mxcmci_poll_status(host,\r\nSTATUS_BUF_READ_RDY | STATUS_READ_OP_DONE);\r\nif (stat)\r\nreturn stat;\r\n*buf++ = cpu_to_le32(mxcmci_readl(host, MMC_REG_BUFFER_ACCESS));\r\nbytes -= 4;\r\n}\r\nif (bytes) {\r\nu8 *b = (u8 *)buf;\r\nu32 tmp;\r\nstat = mxcmci_poll_status(host,\r\nSTATUS_BUF_READ_RDY | STATUS_READ_OP_DONE);\r\nif (stat)\r\nreturn stat;\r\ntmp = cpu_to_le32(mxcmci_readl(host, MMC_REG_BUFFER_ACCESS));\r\nmemcpy(b, &tmp, bytes);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxcmci_push(struct mxcmci_host *host, void *_buf, int bytes)\r\n{\r\nunsigned int stat;\r\nu32 *buf = _buf;\r\nwhile (bytes > 3) {\r\nstat = mxcmci_poll_status(host, STATUS_BUF_WRITE_RDY);\r\nif (stat)\r\nreturn stat;\r\nmxcmci_writel(host, cpu_to_le32(*buf++), MMC_REG_BUFFER_ACCESS);\r\nbytes -= 4;\r\n}\r\nif (bytes) {\r\nu8 *b = (u8 *)buf;\r\nu32 tmp;\r\nstat = mxcmci_poll_status(host, STATUS_BUF_WRITE_RDY);\r\nif (stat)\r\nreturn stat;\r\nmemcpy(&tmp, b, bytes);\r\nmxcmci_writel(host, cpu_to_le32(tmp), MMC_REG_BUFFER_ACCESS);\r\n}\r\nstat = mxcmci_poll_status(host, STATUS_BUF_WRITE_RDY);\r\nif (stat)\r\nreturn stat;\r\nreturn 0;\r\n}\r\nstatic int mxcmci_transfer_data(struct mxcmci_host *host)\r\n{\r\nstruct mmc_data *data = host->req->data;\r\nstruct scatterlist *sg;\r\nint stat, i;\r\nhost->data = data;\r\nhost->datasize = 0;\r\nif (data->flags & MMC_DATA_READ) {\r\nfor_each_sg(data->sg, sg, data->sg_len, i) {\r\nstat = mxcmci_pull(host, sg_virt(sg), sg->length);\r\nif (stat)\r\nreturn stat;\r\nhost->datasize += sg->length;\r\n}\r\n} else {\r\nfor_each_sg(data->sg, sg, data->sg_len, i) {\r\nstat = mxcmci_push(host, sg_virt(sg), sg->length);\r\nif (stat)\r\nreturn stat;\r\nhost->datasize += sg->length;\r\n}\r\nstat = mxcmci_poll_status(host, STATUS_WRITE_OP_DONE);\r\nif (stat)\r\nreturn stat;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mxcmci_datawork(struct work_struct *work)\r\n{\r\nstruct mxcmci_host *host = container_of(work, struct mxcmci_host,\r\ndatawork);\r\nint datastat = mxcmci_transfer_data(host);\r\nmxcmci_writel(host, STATUS_READ_OP_DONE | STATUS_WRITE_OP_DONE,\r\nMMC_REG_STATUS);\r\nmxcmci_finish_data(host, datastat);\r\nif (host->req->stop) {\r\nif (mxcmci_start_cmd(host, host->req->stop, 0)) {\r\nmxcmci_finish_request(host, host->req);\r\nreturn;\r\n}\r\n} else {\r\nmxcmci_finish_request(host, host->req);\r\n}\r\n}\r\nstatic void mxcmci_data_done(struct mxcmci_host *host, unsigned int stat)\r\n{\r\nstruct mmc_request *req;\r\nint data_error;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nif (!host->data) {\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nreturn;\r\n}\r\nif (!host->req) {\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nreturn;\r\n}\r\nreq = host->req;\r\nif (!req->stop)\r\nhost->req = NULL;\r\ndata_error = mxcmci_finish_data(host, stat);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nmxcmci_read_response(host, stat);\r\nhost->cmd = NULL;\r\nif (req->stop) {\r\nif (mxcmci_start_cmd(host, req->stop, 0)) {\r\nmxcmci_finish_request(host, req);\r\nreturn;\r\n}\r\n} else {\r\nmxcmci_finish_request(host, req);\r\n}\r\n}\r\nstatic void mxcmci_cmd_done(struct mxcmci_host *host, unsigned int stat)\r\n{\r\nmxcmci_read_response(host, stat);\r\nhost->cmd = NULL;\r\nif (!host->data && host->req) {\r\nmxcmci_finish_request(host, host->req);\r\nreturn;\r\n}\r\nif (!mxcmci_use_dma(host) && host->data)\r\nschedule_work(&host->datawork);\r\n}\r\nstatic irqreturn_t mxcmci_irq(int irq, void *devid)\r\n{\r\nstruct mxcmci_host *host = devid;\r\nunsigned long flags;\r\nbool sdio_irq;\r\nu32 stat;\r\nstat = mxcmci_readl(host, MMC_REG_STATUS);\r\nmxcmci_writel(host,\r\nstat & ~(STATUS_SDIO_INT_ACTIVE | STATUS_DATA_TRANS_DONE |\r\nSTATUS_WRITE_OP_DONE),\r\nMMC_REG_STATUS);\r\ndev_dbg(mmc_dev(host->mmc), "%s: 0x%08x\n", __func__, stat);\r\nspin_lock_irqsave(&host->lock, flags);\r\nsdio_irq = (stat & STATUS_SDIO_INT_ACTIVE) && host->use_sdio;\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nif (mxcmci_use_dma(host) && (stat & (STATUS_WRITE_OP_DONE)))\r\nmxcmci_writel(host, STATUS_WRITE_OP_DONE, MMC_REG_STATUS);\r\nif (sdio_irq) {\r\nmxcmci_writel(host, STATUS_SDIO_INT_ACTIVE, MMC_REG_STATUS);\r\nmmc_signal_sdio_irq(host->mmc);\r\n}\r\nif (stat & STATUS_END_CMD_RESP)\r\nmxcmci_cmd_done(host, stat);\r\nif (mxcmci_use_dma(host) && (stat & STATUS_WRITE_OP_DONE)) {\r\ndel_timer(&host->watchdog);\r\nmxcmci_data_done(host, stat);\r\n}\r\nif (host->default_irq_mask &&\r\n(stat & (STATUS_CARD_INSERTION | STATUS_CARD_REMOVAL)))\r\nmmc_detect_change(host->mmc, msecs_to_jiffies(200));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mxcmci_request(struct mmc_host *mmc, struct mmc_request *req)\r\n{\r\nstruct mxcmci_host *host = mmc_priv(mmc);\r\nunsigned int cmdat = host->cmdat;\r\nint error;\r\nWARN_ON(host->req != NULL);\r\nhost->req = req;\r\nhost->cmdat &= ~CMD_DAT_CONT_INIT;\r\nif (host->dma)\r\nhost->do_dma = 1;\r\nif (req->data) {\r\nerror = mxcmci_setup_data(host, req->data);\r\nif (error) {\r\nreq->cmd->error = error;\r\ngoto out;\r\n}\r\ncmdat |= CMD_DAT_CONT_DATA_ENABLE;\r\nif (req->data->flags & MMC_DATA_WRITE)\r\ncmdat |= CMD_DAT_CONT_WRITE;\r\n}\r\nerror = mxcmci_start_cmd(host, req->cmd, cmdat);\r\nout:\r\nif (error)\r\nmxcmci_finish_request(host, req);\r\n}\r\nstatic void mxcmci_set_clk_rate(struct mxcmci_host *host, unsigned int clk_ios)\r\n{\r\nunsigned int divider;\r\nint prescaler = 0;\r\nunsigned int clk_in = clk_get_rate(host->clk_per);\r\nwhile (prescaler <= 0x800) {\r\nfor (divider = 1; divider <= 0xF; divider++) {\r\nint x;\r\nx = (clk_in / (divider + 1));\r\nif (prescaler)\r\nx /= (prescaler * 2);\r\nif (x <= clk_ios)\r\nbreak;\r\n}\r\nif (divider < 0x10)\r\nbreak;\r\nif (prescaler == 0)\r\nprescaler = 1;\r\nelse\r\nprescaler <<= 1;\r\n}\r\nmxcmci_writew(host, (prescaler << 4) | divider, MMC_REG_CLK_RATE);\r\ndev_dbg(mmc_dev(host->mmc), "scaler: %d divider: %d in: %d out: %d\n",\r\nprescaler, divider, clk_in, clk_ios);\r\n}\r\nstatic int mxcmci_setup_dma(struct mmc_host *mmc)\r\n{\r\nstruct mxcmci_host *host = mmc_priv(mmc);\r\nstruct dma_slave_config *config = &host->dma_slave_config;\r\nconfig->dst_addr = host->phys_base + MMC_REG_BUFFER_ACCESS;\r\nconfig->src_addr = host->phys_base + MMC_REG_BUFFER_ACCESS;\r\nconfig->dst_addr_width = 4;\r\nconfig->src_addr_width = 4;\r\nconfig->dst_maxburst = host->burstlen;\r\nconfig->src_maxburst = host->burstlen;\r\nconfig->device_fc = false;\r\nreturn dmaengine_slave_config(host->dma, config);\r\n}\r\nstatic void mxcmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct mxcmci_host *host = mmc_priv(mmc);\r\nint burstlen, ret;\r\nif (ios->bus_width == MMC_BUS_WIDTH_4)\r\nburstlen = 16;\r\nelse\r\nburstlen = 4;\r\nif (mxcmci_use_dma(host) && burstlen != host->burstlen) {\r\nhost->burstlen = burstlen;\r\nret = mxcmci_setup_dma(mmc);\r\nif (ret) {\r\ndev_err(mmc_dev(host->mmc),\r\n"failed to config DMA channel. Falling back to PIO\n");\r\ndma_release_channel(host->dma);\r\nhost->do_dma = 0;\r\nhost->dma = NULL;\r\n}\r\n}\r\nif (ios->bus_width == MMC_BUS_WIDTH_4)\r\nhost->cmdat |= CMD_DAT_CONT_BUS_WIDTH_4;\r\nelse\r\nhost->cmdat &= ~CMD_DAT_CONT_BUS_WIDTH_4;\r\nif (host->power_mode != ios->power_mode) {\r\nhost->power_mode = ios->power_mode;\r\nmxcmci_set_power(host, ios->vdd);\r\nif (ios->power_mode == MMC_POWER_ON)\r\nhost->cmdat |= CMD_DAT_CONT_INIT;\r\n}\r\nif (ios->clock) {\r\nmxcmci_set_clk_rate(host, ios->clock);\r\nmxcmci_writew(host, STR_STP_CLK_START_CLK, MMC_REG_STR_STP_CLK);\r\n} else {\r\nmxcmci_writew(host, STR_STP_CLK_STOP_CLK, MMC_REG_STR_STP_CLK);\r\n}\r\nhost->clock = ios->clock;\r\n}\r\nstatic irqreturn_t mxcmci_detect_irq(int irq, void *data)\r\n{\r\nstruct mmc_host *mmc = data;\r\ndev_dbg(mmc_dev(mmc), "%s\n", __func__);\r\nmmc_detect_change(mmc, msecs_to_jiffies(250));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mxcmci_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct mxcmci_host *host = mmc_priv(mmc);\r\nif (host->pdata && host->pdata->get_ro)\r\nreturn !!host->pdata->get_ro(mmc_dev(mmc));\r\nreturn mmc_gpio_get_ro(mmc);\r\n}\r\nstatic void mxcmci_enable_sdio_irq(struct mmc_host *mmc, int enable)\r\n{\r\nstruct mxcmci_host *host = mmc_priv(mmc);\r\nunsigned long flags;\r\nu32 int_cntr;\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->use_sdio = enable;\r\nint_cntr = mxcmci_readl(host, MMC_REG_INT_CNTR);\r\nif (enable)\r\nint_cntr |= INT_SDIO_IRQ_EN;\r\nelse\r\nint_cntr &= ~INT_SDIO_IRQ_EN;\r\nmxcmci_writel(host, int_cntr, MMC_REG_INT_CNTR);\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic void mxcmci_init_card(struct mmc_host *host, struct mmc_card *card)\r\n{\r\nstruct mxcmci_host *mxcmci = mmc_priv(host);\r\nif (is_imx31_mmc(mxcmci) && card->type == MMC_TYPE_SDIO)\r\nhost->caps &= ~MMC_CAP_4_BIT_DATA;\r\nelse\r\nhost->caps |= MMC_CAP_4_BIT_DATA;\r\n}\r\nstatic bool filter(struct dma_chan *chan, void *param)\r\n{\r\nstruct mxcmci_host *host = param;\r\nif (!imx_dma_is_general_purpose(chan))\r\nreturn false;\r\nchan->private = &host->dma_data;\r\nreturn true;\r\n}\r\nstatic void mxcmci_watchdog(unsigned long data)\r\n{\r\nstruct mmc_host *mmc = (struct mmc_host *)data;\r\nstruct mxcmci_host *host = mmc_priv(mmc);\r\nstruct mmc_request *req = host->req;\r\nunsigned int stat = mxcmci_readl(host, MMC_REG_STATUS);\r\nif (host->dma_dir == DMA_FROM_DEVICE) {\r\ndmaengine_terminate_all(host->dma);\r\ndev_err(mmc_dev(host->mmc),\r\n"%s: read time out (status = 0x%08x)\n",\r\n__func__, stat);\r\n} else {\r\ndev_err(mmc_dev(host->mmc),\r\n"%s: write time out (status = 0x%08x)\n",\r\n__func__, stat);\r\nmxcmci_softreset(host);\r\n}\r\nif (host->data)\r\nhost->data->error = -ETIMEDOUT;\r\nhost->req = NULL;\r\nhost->cmd = NULL;\r\nhost->data = NULL;\r\nmmc_request_done(host->mmc, req);\r\n}\r\nstatic int mxcmci_probe(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct mxcmci_host *host;\r\nstruct resource *res;\r\nint ret = 0, irq;\r\nbool dat3_card_detect = false;\r\ndma_cap_mask_t mask;\r\nconst struct of_device_id *of_id;\r\nstruct imxmmc_platform_data *pdata = pdev->dev.platform_data;\r\npr_info("i.MX/MPC512x SDHC driver\n");\r\nof_id = of_match_device(mxcmci_of_match, &pdev->dev);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn -EINVAL;\r\nmmc = mmc_alloc_host(sizeof(*host), &pdev->dev);\r\nif (!mmc)\r\nreturn -ENOMEM;\r\nhost = mmc_priv(mmc);\r\nhost->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(host->base)) {\r\nret = PTR_ERR(host->base);\r\ngoto out_free;\r\n}\r\nhost->phys_base = res->start;\r\nret = mmc_of_parse(mmc);\r\nif (ret)\r\ngoto out_free;\r\nmmc->ops = &mxcmci_ops;\r\nif (pdata)\r\nmmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ;\r\nelse\r\nmmc->caps |= MMC_CAP_SDIO_IRQ;\r\nmmc->max_blk_size = 2048;\r\nmmc->max_blk_count = 65535;\r\nmmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;\r\nmmc->max_seg_size = mmc->max_req_size;\r\nif (of_id) {\r\nconst struct platform_device_id *id_entry = of_id->data;\r\nhost->devtype = id_entry->driver_data;\r\n} else {\r\nhost->devtype = pdev->id_entry->driver_data;\r\n}\r\nif (!is_mpc512x_mmc(host))\r\nmmc->max_segs = 64;\r\nhost->mmc = mmc;\r\nhost->pdata = pdata;\r\nspin_lock_init(&host->lock);\r\nif (pdata)\r\ndat3_card_detect = pdata->dat3_card_detect;\r\nelse if (!(mmc->caps & MMC_CAP_NONREMOVABLE)\r\n&& !of_property_read_bool(pdev->dev.of_node, "cd-gpios"))\r\ndat3_card_detect = true;\r\nret = mmc_regulator_get_supply(mmc);\r\nif (ret == -EPROBE_DEFER)\r\ngoto out_free;\r\nif (!mmc->ocr_avail) {\r\nif (pdata && pdata->ocr_avail)\r\nmmc->ocr_avail = pdata->ocr_avail;\r\nelse\r\nmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\r\n}\r\nif (dat3_card_detect)\r\nhost->default_irq_mask =\r\nINT_CARD_INSERTION_EN | INT_CARD_REMOVAL_EN;\r\nelse\r\nhost->default_irq_mask = 0;\r\nhost->clk_ipg = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(host->clk_ipg)) {\r\nret = PTR_ERR(host->clk_ipg);\r\ngoto out_free;\r\n}\r\nhost->clk_per = devm_clk_get(&pdev->dev, "per");\r\nif (IS_ERR(host->clk_per)) {\r\nret = PTR_ERR(host->clk_per);\r\ngoto out_free;\r\n}\r\nclk_prepare_enable(host->clk_per);\r\nclk_prepare_enable(host->clk_ipg);\r\nmxcmci_softreset(host);\r\nhost->rev_no = mxcmci_readw(host, MMC_REG_REV_NO);\r\nif (host->rev_no != 0x400) {\r\nret = -ENODEV;\r\ndev_err(mmc_dev(host->mmc), "wrong rev.no. 0x%08x. aborting.\n",\r\nhost->rev_no);\r\ngoto out_clk_put;\r\n}\r\nmmc->f_min = clk_get_rate(host->clk_per) >> 16;\r\nmmc->f_max = clk_get_rate(host->clk_per) >> 1;\r\nmxcmci_writew(host, 0x2db4, MMC_REG_READ_TO);\r\nmxcmci_writel(host, host->default_irq_mask, MMC_REG_INT_CNTR);\r\nif (!host->pdata) {\r\nhost->dma = dma_request_slave_channel(&pdev->dev, "rx-tx");\r\n} else {\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (res) {\r\nhost->dmareq = res->start;\r\nhost->dma_data.peripheral_type = IMX_DMATYPE_SDHC;\r\nhost->dma_data.priority = DMA_PRIO_LOW;\r\nhost->dma_data.dma_request = host->dmareq;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nhost->dma = dma_request_channel(mask, filter, host);\r\n}\r\n}\r\nif (host->dma)\r\nmmc->max_seg_size = dma_get_max_seg_size(\r\nhost->dma->device->dev);\r\nelse\r\ndev_info(mmc_dev(host->mmc), "dma not available. Using PIO\n");\r\nINIT_WORK(&host->datawork, mxcmci_datawork);\r\nret = devm_request_irq(&pdev->dev, irq, mxcmci_irq, 0,\r\ndev_name(&pdev->dev), host);\r\nif (ret)\r\ngoto out_free_dma;\r\nplatform_set_drvdata(pdev, mmc);\r\nif (host->pdata && host->pdata->init) {\r\nret = host->pdata->init(&pdev->dev, mxcmci_detect_irq,\r\nhost->mmc);\r\nif (ret)\r\ngoto out_free_dma;\r\n}\r\ninit_timer(&host->watchdog);\r\nhost->watchdog.function = &mxcmci_watchdog;\r\nhost->watchdog.data = (unsigned long)mmc;\r\nmmc_add_host(mmc);\r\nreturn 0;\r\nout_free_dma:\r\nif (host->dma)\r\ndma_release_channel(host->dma);\r\nout_clk_put:\r\nclk_disable_unprepare(host->clk_per);\r\nclk_disable_unprepare(host->clk_ipg);\r\nout_free:\r\nmmc_free_host(mmc);\r\nreturn ret;\r\n}\r\nstatic int mxcmci_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct mxcmci_host *host = mmc_priv(mmc);\r\nmmc_remove_host(mmc);\r\nif (host->pdata && host->pdata->exit)\r\nhost->pdata->exit(&pdev->dev, mmc);\r\nif (host->dma)\r\ndma_release_channel(host->dma);\r\nclk_disable_unprepare(host->clk_per);\r\nclk_disable_unprepare(host->clk_ipg);\r\nmmc_free_host(mmc);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mxcmci_suspend(struct device *dev)\r\n{\r\nstruct mmc_host *mmc = dev_get_drvdata(dev);\r\nstruct mxcmci_host *host = mmc_priv(mmc);\r\nclk_disable_unprepare(host->clk_per);\r\nclk_disable_unprepare(host->clk_ipg);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mxcmci_resume(struct device *dev)\r\n{\r\nstruct mmc_host *mmc = dev_get_drvdata(dev);\r\nstruct mxcmci_host *host = mmc_priv(mmc);\r\nclk_prepare_enable(host->clk_per);\r\nclk_prepare_enable(host->clk_ipg);\r\nreturn 0;\r\n}
