static void bochs_vga_writeb(struct bochs_device *bochs, u16 ioport, u8 val)\r\n{\r\nif (WARN_ON(ioport < 0x3c0 || ioport > 0x3df))\r\nreturn;\r\nif (bochs->mmio) {\r\nint offset = ioport - 0x3c0 + 0x400;\r\nwriteb(val, bochs->mmio + offset);\r\n} else {\r\noutb(val, ioport);\r\n}\r\n}\r\nstatic u16 bochs_dispi_read(struct bochs_device *bochs, u16 reg)\r\n{\r\nu16 ret = 0;\r\nif (bochs->mmio) {\r\nint offset = 0x500 + (reg << 1);\r\nret = readw(bochs->mmio + offset);\r\n} else {\r\noutw(reg, VBE_DISPI_IOPORT_INDEX);\r\nret = inw(VBE_DISPI_IOPORT_DATA);\r\n}\r\nreturn ret;\r\n}\r\nstatic void bochs_dispi_write(struct bochs_device *bochs, u16 reg, u16 val)\r\n{\r\nif (bochs->mmio) {\r\nint offset = 0x500 + (reg << 1);\r\nwritew(val, bochs->mmio + offset);\r\n} else {\r\noutw(reg, VBE_DISPI_IOPORT_INDEX);\r\noutw(val, VBE_DISPI_IOPORT_DATA);\r\n}\r\n}\r\nint bochs_hw_init(struct drm_device *dev, uint32_t flags)\r\n{\r\nstruct bochs_device *bochs = dev->dev_private;\r\nstruct pci_dev *pdev = dev->pdev;\r\nunsigned long addr, size, mem, ioaddr, iosize, qext_size;\r\nu16 id;\r\nif (pdev->resource[2].flags & IORESOURCE_MEM) {\r\nif (pci_request_region(pdev, 2, "bochs-drm") != 0) {\r\nDRM_ERROR("Cannot request mmio region\n");\r\nreturn -EBUSY;\r\n}\r\nioaddr = pci_resource_start(pdev, 2);\r\niosize = pci_resource_len(pdev, 2);\r\nbochs->mmio = ioremap(ioaddr, iosize);\r\nif (bochs->mmio == NULL) {\r\nDRM_ERROR("Cannot map mmio region\n");\r\nreturn -ENOMEM;\r\n}\r\n} else {\r\nioaddr = VBE_DISPI_IOPORT_INDEX;\r\niosize = 2;\r\nif (!request_region(ioaddr, iosize, "bochs-drm")) {\r\nDRM_ERROR("Cannot request ioports\n");\r\nreturn -EBUSY;\r\n}\r\nbochs->ioports = 1;\r\n}\r\nid = bochs_dispi_read(bochs, VBE_DISPI_INDEX_ID);\r\nmem = bochs_dispi_read(bochs, VBE_DISPI_INDEX_VIDEO_MEMORY_64K)\r\n* 64 * 1024;\r\nif ((id & 0xfff0) != VBE_DISPI_ID0) {\r\nDRM_ERROR("ID mismatch\n");\r\nreturn -ENODEV;\r\n}\r\nif ((pdev->resource[0].flags & IORESOURCE_MEM) == 0)\r\nreturn -ENODEV;\r\naddr = pci_resource_start(pdev, 0);\r\nsize = pci_resource_len(pdev, 0);\r\nif (addr == 0)\r\nreturn -ENODEV;\r\nif (size != mem) {\r\nDRM_ERROR("Size mismatch: pci=%ld, bochs=%ld\n",\r\nsize, mem);\r\nsize = min(size, mem);\r\n}\r\nif (pci_request_region(pdev, 0, "bochs-drm") != 0) {\r\nDRM_ERROR("Cannot request framebuffer\n");\r\nreturn -EBUSY;\r\n}\r\nbochs->fb_map = ioremap(addr, size);\r\nif (bochs->fb_map == NULL) {\r\nDRM_ERROR("Cannot map framebuffer\n");\r\nreturn -ENOMEM;\r\n}\r\nbochs->fb_base = addr;\r\nbochs->fb_size = size;\r\nDRM_INFO("Found bochs VGA, ID 0x%x.\n", id);\r\nDRM_INFO("Framebuffer size %ld kB @ 0x%lx, %s @ 0x%lx.\n",\r\nsize / 1024, addr,\r\nbochs->ioports ? "ioports" : "mmio",\r\nioaddr);\r\nif (bochs->mmio && pdev->revision >= 2) {\r\nqext_size = readl(bochs->mmio + 0x600);\r\nif (qext_size < 4 || qext_size > iosize)\r\ngoto noext;\r\nDRM_DEBUG("Found qemu ext regs, size %ld\n", qext_size);\r\nif (qext_size >= 8) {\r\n#ifdef __BIG_ENDIAN\r\nwritel(0xbebebebe, bochs->mmio + 0x604);\r\n#else\r\nwritel(0x1e1e1e1e, bochs->mmio + 0x604);\r\n#endif\r\nDRM_DEBUG(" qext endian: 0x%x\n",\r\nreadl(bochs->mmio + 0x604));\r\n}\r\n}\r\nnoext:\r\nreturn 0;\r\n}\r\nvoid bochs_hw_fini(struct drm_device *dev)\r\n{\r\nstruct bochs_device *bochs = dev->dev_private;\r\nif (bochs->mmio)\r\niounmap(bochs->mmio);\r\nif (bochs->ioports)\r\nrelease_region(VBE_DISPI_IOPORT_INDEX, 2);\r\nif (bochs->fb_map)\r\niounmap(bochs->fb_map);\r\npci_release_regions(dev->pdev);\r\n}\r\nvoid bochs_hw_setmode(struct bochs_device *bochs,\r\nstruct drm_display_mode *mode)\r\n{\r\nbochs->xres = mode->hdisplay;\r\nbochs->yres = mode->vdisplay;\r\nbochs->bpp = 32;\r\nbochs->stride = mode->hdisplay * (bochs->bpp / 8);\r\nbochs->yres_virtual = bochs->fb_size / bochs->stride;\r\nDRM_DEBUG_DRIVER("%dx%d @ %d bpp, vy %d\n",\r\nbochs->xres, bochs->yres, bochs->bpp,\r\nbochs->yres_virtual);\r\nbochs_vga_writeb(bochs, 0x3c0, 0x20);\r\nbochs_dispi_write(bochs, VBE_DISPI_INDEX_BPP, bochs->bpp);\r\nbochs_dispi_write(bochs, VBE_DISPI_INDEX_XRES, bochs->xres);\r\nbochs_dispi_write(bochs, VBE_DISPI_INDEX_YRES, bochs->yres);\r\nbochs_dispi_write(bochs, VBE_DISPI_INDEX_BANK, 0);\r\nbochs_dispi_write(bochs, VBE_DISPI_INDEX_VIRT_WIDTH, bochs->xres);\r\nbochs_dispi_write(bochs, VBE_DISPI_INDEX_VIRT_HEIGHT,\r\nbochs->yres_virtual);\r\nbochs_dispi_write(bochs, VBE_DISPI_INDEX_X_OFFSET, 0);\r\nbochs_dispi_write(bochs, VBE_DISPI_INDEX_Y_OFFSET, 0);\r\nbochs_dispi_write(bochs, VBE_DISPI_INDEX_ENABLE,\r\nVBE_DISPI_ENABLED | VBE_DISPI_LFB_ENABLED);\r\n}\r\nvoid bochs_hw_setbase(struct bochs_device *bochs,\r\nint x, int y, u64 addr)\r\n{\r\nunsigned long offset = (unsigned long)addr +\r\ny * bochs->stride +\r\nx * (bochs->bpp / 8);\r\nint vy = offset / bochs->stride;\r\nint vx = (offset % bochs->stride) * 8 / bochs->bpp;\r\nDRM_DEBUG_DRIVER("x %d, y %d, addr %llx -> offset %lx, vx %d, vy %d\n",\r\nx, y, addr, offset, vx, vy);\r\nbochs_dispi_write(bochs, VBE_DISPI_INDEX_X_OFFSET, vx);\r\nbochs_dispi_write(bochs, VBE_DISPI_INDEX_Y_OFFSET, vy);\r\n}
