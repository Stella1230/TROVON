static void vx_pcm_read_per_bytes(struct vx_core *chip, struct snd_pcm_runtime *runtime,\r\nstruct vx_pipe *pipe)\r\n{\r\nint offset = pipe->hw_ptr;\r\nunsigned char *buf = (unsigned char *)(runtime->dma_area + offset);\r\n*buf++ = vx_inb(chip, RXH);\r\nif (++offset >= pipe->buffer_bytes) {\r\noffset = 0;\r\nbuf = (unsigned char *)runtime->dma_area;\r\n}\r\n*buf++ = vx_inb(chip, RXM);\r\nif (++offset >= pipe->buffer_bytes) {\r\noffset = 0;\r\nbuf = (unsigned char *)runtime->dma_area;\r\n}\r\n*buf++ = vx_inb(chip, RXL);\r\nif (++offset >= pipe->buffer_bytes) {\r\noffset = 0;\r\nbuf = (unsigned char *)runtime->dma_area;\r\n}\r\npipe->hw_ptr = offset;\r\n}\r\nstatic void vx_set_pcx_time(struct vx_core *chip, pcx_time_t *pc_time,\r\nunsigned int *dsp_time)\r\n{\r\ndsp_time[0] = (unsigned int)((*pc_time) >> 24) & PCX_TIME_HI_MASK;\r\ndsp_time[1] = (unsigned int)(*pc_time) & MASK_DSP_WORD;\r\n}\r\nstatic int vx_set_differed_time(struct vx_core *chip, struct vx_rmh *rmh,\r\nstruct vx_pipe *pipe)\r\n{\r\nif (! (pipe->differed_type & DC_DIFFERED_DELAY))\r\nreturn 0;\r\nrmh->Cmd[0] |= DSP_DIFFERED_COMMAND_MASK;\r\nvx_set_pcx_time(chip, &pipe->pcx_time, &rmh->Cmd[1]);\r\nif (pipe->differed_type & DC_NOTIFY_DELAY)\r\nrmh->Cmd[1] |= NOTIFY_MASK_TIME_HIGH ;\r\nif (pipe->differed_type & DC_MULTIPLE_DELAY)\r\nrmh->Cmd[1] |= MULTIPLE_MASK_TIME_HIGH;\r\nif (pipe->differed_type & DC_STREAM_TIME_DELAY)\r\nrmh->Cmd[1] |= STREAM_MASK_TIME_HIGH;\r\nrmh->LgCmd += 2;\r\nreturn 2;\r\n}\r\nstatic int vx_set_stream_format(struct vx_core *chip, struct vx_pipe *pipe,\r\nunsigned int data)\r\n{\r\nstruct vx_rmh rmh;\r\nvx_init_rmh(&rmh, pipe->is_capture ?\r\nCMD_FORMAT_STREAM_IN : CMD_FORMAT_STREAM_OUT);\r\nrmh.Cmd[0] |= pipe->number << FIELD_SIZE;\r\nvx_set_differed_time(chip, &rmh, pipe);\r\nrmh.Cmd[rmh.LgCmd] = (data & 0xFFFFFF00) >> 8;\r\nrmh.Cmd[rmh.LgCmd + 1] = (data & 0xFF) << 16 ;\r\nrmh.LgCmd += 2;\r\nreturn vx_send_msg(chip, &rmh);\r\n}\r\nstatic int vx_set_format(struct vx_core *chip, struct vx_pipe *pipe,\r\nstruct snd_pcm_runtime *runtime)\r\n{\r\nunsigned int header = HEADER_FMT_BASE;\r\nif (runtime->channels == 1)\r\nheader |= HEADER_FMT_MONO;\r\nif (snd_pcm_format_little_endian(runtime->format))\r\nheader |= HEADER_FMT_INTEL;\r\nif (runtime->rate < 32000 && runtime->rate > 11025)\r\nheader |= HEADER_FMT_UPTO32;\r\nelse if (runtime->rate <= 11025)\r\nheader |= HEADER_FMT_UPTO11;\r\nswitch (snd_pcm_format_physical_width(runtime->format)) {\r\ncase 16: header |= HEADER_FMT_16BITS; break;\r\ncase 24: header |= HEADER_FMT_24BITS; break;\r\ndefault :\r\nsnd_BUG();\r\nreturn -EINVAL;\r\n}\r\nreturn vx_set_stream_format(chip, pipe, header);\r\n}\r\nstatic int vx_set_ibl(struct vx_core *chip, struct vx_ibl_info *info)\r\n{\r\nint err;\r\nstruct vx_rmh rmh;\r\nvx_init_rmh(&rmh, CMD_IBL);\r\nrmh.Cmd[0] |= info->size & 0x03ffff;\r\nerr = vx_send_msg(chip, &rmh);\r\nif (err < 0)\r\nreturn err;\r\ninfo->size = rmh.Stat[0];\r\ninfo->max_size = rmh.Stat[1];\r\ninfo->min_size = rmh.Stat[2];\r\ninfo->granularity = rmh.Stat[3];\r\nsnd_printdd(KERN_DEBUG "vx_set_ibl: size = %d, max = %d, min = %d, gran = %d\n",\r\ninfo->size, info->max_size, info->min_size, info->granularity);\r\nreturn 0;\r\n}\r\nstatic int vx_get_pipe_state(struct vx_core *chip, struct vx_pipe *pipe, int *state)\r\n{\r\nint err;\r\nstruct vx_rmh rmh;\r\nvx_init_rmh(&rmh, CMD_PIPE_STATE);\r\nvx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);\r\nerr = vx_send_msg(chip, &rmh);\r\nif (! err)\r\n*state = (rmh.Stat[0] & (1 << pipe->number)) ? 1 : 0;\r\nreturn err;\r\n}\r\nstatic int vx_query_hbuffer_size(struct vx_core *chip, struct vx_pipe *pipe)\r\n{\r\nint result;\r\nstruct vx_rmh rmh;\r\nvx_init_rmh(&rmh, CMD_SIZE_HBUFFER);\r\nvx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);\r\nif (pipe->is_capture)\r\nrmh.Cmd[0] |= 0x00000001;\r\nresult = vx_send_msg(chip, &rmh);\r\nif (! result)\r\nresult = rmh.Stat[0] & 0xffff;\r\nreturn result;\r\n}\r\nstatic int vx_pipe_can_start(struct vx_core *chip, struct vx_pipe *pipe)\r\n{\r\nint err;\r\nstruct vx_rmh rmh;\r\nvx_init_rmh(&rmh, CMD_CAN_START_PIPE);\r\nvx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);\r\nrmh.Cmd[0] |= 1;\r\nerr = vx_send_msg(chip, &rmh);\r\nif (! err) {\r\nif (rmh.Stat[0])\r\nerr = 1;\r\n}\r\nreturn err;\r\n}\r\nstatic int vx_conf_pipe(struct vx_core *chip, struct vx_pipe *pipe)\r\n{\r\nstruct vx_rmh rmh;\r\nvx_init_rmh(&rmh, CMD_CONF_PIPE);\r\nif (pipe->is_capture)\r\nrmh.Cmd[0] |= COMMAND_RECORD_MASK;\r\nrmh.Cmd[1] = 1 << pipe->number;\r\nreturn vx_send_msg(chip, &rmh);\r\n}\r\nstatic int vx_send_irqa(struct vx_core *chip)\r\n{\r\nstruct vx_rmh rmh;\r\nvx_init_rmh(&rmh, CMD_SEND_IRQA);\r\nreturn vx_send_msg(chip, &rmh);\r\n}\r\nstatic int vx_toggle_pipe(struct vx_core *chip, struct vx_pipe *pipe, int state)\r\n{\r\nint err, i, cur_state;\r\nif (vx_get_pipe_state(chip, pipe, &cur_state) < 0)\r\nreturn -EBADFD;\r\nif (state == cur_state)\r\nreturn 0;\r\nif (state) {\r\nfor (i = 0 ; i < MAX_WAIT_FOR_DSP; i++) {\r\nerr = vx_pipe_can_start(chip, pipe);\r\nif (err > 0)\r\nbreak;\r\nmdelay(1);\r\n}\r\n}\r\nif ((err = vx_conf_pipe(chip, pipe)) < 0)\r\nreturn err;\r\nif ((err = vx_send_irqa(chip)) < 0)\r\nreturn err;\r\nfor (i = 0; i < MAX_WAIT_FOR_DSP; i++) {\r\nerr = vx_get_pipe_state(chip, pipe, &cur_state);\r\nif (err < 0 || cur_state == state)\r\nbreak;\r\nerr = -EIO;\r\nmdelay(1);\r\n}\r\nreturn err < 0 ? -EIO : 0;\r\n}\r\nstatic int vx_stop_pipe(struct vx_core *chip, struct vx_pipe *pipe)\r\n{\r\nstruct vx_rmh rmh;\r\nvx_init_rmh(&rmh, CMD_STOP_PIPE);\r\nvx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);\r\nreturn vx_send_msg(chip, &rmh);\r\n}\r\nstatic int vx_alloc_pipe(struct vx_core *chip, int capture,\r\nint audioid, int num_audio,\r\nstruct vx_pipe **pipep)\r\n{\r\nint err;\r\nstruct vx_pipe *pipe;\r\nstruct vx_rmh rmh;\r\nint data_mode;\r\n*pipep = NULL;\r\nvx_init_rmh(&rmh, CMD_RES_PIPE);\r\nvx_set_pipe_cmd_params(&rmh, capture, audioid, num_audio);\r\n#if 0\r\nif (underrun_skip_sound)\r\nrmh.Cmd[0] |= BIT_SKIP_SOUND;\r\n#endif\r\ndata_mode = (chip->uer_bits & IEC958_AES0_NONAUDIO) != 0;\r\nif (! capture && data_mode)\r\nrmh.Cmd[0] |= BIT_DATA_MODE;\r\nerr = vx_send_msg(chip, &rmh);\r\nif (err < 0)\r\nreturn err;\r\npipe = kzalloc(sizeof(*pipe), GFP_KERNEL);\r\nif (! pipe) {\r\nvx_init_rmh(&rmh, CMD_FREE_PIPE);\r\nvx_set_pipe_cmd_params(&rmh, capture, audioid, 0);\r\nvx_send_msg(chip, &rmh);\r\nreturn -ENOMEM;\r\n}\r\npipe->number = audioid;\r\npipe->is_capture = capture;\r\npipe->channels = num_audio;\r\npipe->differed_type = 0;\r\npipe->pcx_time = 0;\r\npipe->data_mode = data_mode;\r\n*pipep = pipe;\r\nreturn 0;\r\n}\r\nstatic int vx_free_pipe(struct vx_core *chip, struct vx_pipe *pipe)\r\n{\r\nstruct vx_rmh rmh;\r\nvx_init_rmh(&rmh, CMD_FREE_PIPE);\r\nvx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);\r\nvx_send_msg(chip, &rmh);\r\nkfree(pipe);\r\nreturn 0;\r\n}\r\nstatic int vx_start_stream(struct vx_core *chip, struct vx_pipe *pipe)\r\n{\r\nstruct vx_rmh rmh;\r\nvx_init_rmh(&rmh, CMD_START_ONE_STREAM);\r\nvx_set_stream_cmd_params(&rmh, pipe->is_capture, pipe->number);\r\nvx_set_differed_time(chip, &rmh, pipe);\r\nreturn vx_send_msg(chip, &rmh);\r\n}\r\nstatic int vx_stop_stream(struct vx_core *chip, struct vx_pipe *pipe)\r\n{\r\nstruct vx_rmh rmh;\r\nvx_init_rmh(&rmh, CMD_STOP_STREAM);\r\nvx_set_stream_cmd_params(&rmh, pipe->is_capture, pipe->number);\r\nreturn vx_send_msg(chip, &rmh);\r\n}\r\nstatic int vx_pcm_playback_open(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nstruct vx_core *chip = snd_pcm_substream_chip(subs);\r\nstruct vx_pipe *pipe = NULL;\r\nunsigned int audio;\r\nint err;\r\nif (chip->chip_status & VX_STAT_IS_STALE)\r\nreturn -EBUSY;\r\naudio = subs->pcm->device * 2;\r\nif (snd_BUG_ON(audio >= chip->audio_outs))\r\nreturn -EINVAL;\r\npipe = chip->playback_pipes[audio];\r\nif (! pipe) {\r\nerr = vx_alloc_pipe(chip, 0, audio, 2, &pipe);\r\nif (err < 0)\r\nreturn err;\r\nchip->playback_pipes[audio] = pipe;\r\n}\r\npipe->references++;\r\npipe->substream = subs;\r\nchip->playback_pipes[audio] = pipe;\r\nruntime->hw = vx_pcm_playback_hw;\r\nruntime->hw.period_bytes_min = chip->ibl.size;\r\nruntime->private_data = pipe;\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 4);\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 4);\r\nreturn 0;\r\n}\r\nstatic int vx_pcm_playback_close(struct snd_pcm_substream *subs)\r\n{\r\nstruct vx_core *chip = snd_pcm_substream_chip(subs);\r\nstruct vx_pipe *pipe;\r\nif (! subs->runtime->private_data)\r\nreturn -EINVAL;\r\npipe = subs->runtime->private_data;\r\nif (--pipe->references == 0) {\r\nchip->playback_pipes[pipe->number] = NULL;\r\nvx_free_pipe(chip, pipe);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vx_notify_end_of_buffer(struct vx_core *chip, struct vx_pipe *pipe)\r\n{\r\nint err;\r\nstruct vx_rmh rmh;\r\nvx_send_rih_nolock(chip, IRQ_PAUSE_START_CONNECT);\r\nvx_init_rmh(&rmh, CMD_NOTIFY_END_OF_BUFFER);\r\nvx_set_stream_cmd_params(&rmh, 0, pipe->number);\r\nerr = vx_send_msg_nolock(chip, &rmh);\r\nif (err < 0)\r\nreturn err;\r\nvx_send_rih_nolock(chip, IRQ_PAUSE_START_CONNECT);\r\nreturn 0;\r\n}\r\nstatic int vx_pcm_playback_transfer_chunk(struct vx_core *chip,\r\nstruct snd_pcm_runtime *runtime,\r\nstruct vx_pipe *pipe, int size)\r\n{\r\nint space, err = 0;\r\nspace = vx_query_hbuffer_size(chip, pipe);\r\nif (space < 0) {\r\nvx_send_rih(chip, IRQ_CONNECT_STREAM_NEXT);\r\nsnd_printd("error hbuffer\n");\r\nreturn space;\r\n}\r\nif (space < size) {\r\nvx_send_rih(chip, IRQ_CONNECT_STREAM_NEXT);\r\nsnd_printd("no enough hbuffer space %d\n", space);\r\nreturn -EIO;\r\n}\r\nmutex_lock(&chip->lock);\r\nvx_pseudo_dma_write(chip, runtime, pipe, size);\r\nerr = vx_notify_end_of_buffer(chip, pipe);\r\nvx_send_rih_nolock(chip, IRQ_CONNECT_STREAM_NEXT);\r\nmutex_unlock(&chip->lock);\r\nreturn err;\r\n}\r\nstatic int vx_update_pipe_position(struct vx_core *chip,\r\nstruct snd_pcm_runtime *runtime,\r\nstruct vx_pipe *pipe)\r\n{\r\nstruct vx_rmh rmh;\r\nint err, update;\r\nu64 count;\r\nvx_init_rmh(&rmh, CMD_STREAM_SAMPLE_COUNT);\r\nvx_set_pipe_cmd_params(&rmh, pipe->is_capture, pipe->number, 0);\r\nerr = vx_send_msg(chip, &rmh);\r\nif (err < 0)\r\nreturn err;\r\ncount = ((u64)(rmh.Stat[0] & 0xfffff) << 24) | (u64)rmh.Stat[1];\r\nupdate = (int)(count - pipe->cur_count);\r\npipe->cur_count = count;\r\npipe->position += update;\r\nif (pipe->position >= (int)runtime->buffer_size)\r\npipe->position %= runtime->buffer_size;\r\npipe->transferred += update;\r\nreturn 0;\r\n}\r\nstatic void vx_pcm_playback_transfer(struct vx_core *chip,\r\nstruct snd_pcm_substream *subs,\r\nstruct vx_pipe *pipe, int nchunks)\r\n{\r\nint i, err;\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nif (! pipe->prepared || (chip->chip_status & VX_STAT_IS_STALE))\r\nreturn;\r\nfor (i = 0; i < nchunks; i++) {\r\nif ((err = vx_pcm_playback_transfer_chunk(chip, runtime, pipe,\r\nchip->ibl.size)) < 0)\r\nreturn;\r\n}\r\n}\r\nstatic void vx_pcm_playback_update(struct vx_core *chip,\r\nstruct snd_pcm_substream *subs,\r\nstruct vx_pipe *pipe)\r\n{\r\nint err;\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nif (pipe->running && ! (chip->chip_status & VX_STAT_IS_STALE)) {\r\nif ((err = vx_update_pipe_position(chip, runtime, pipe)) < 0)\r\nreturn;\r\nif (pipe->transferred >= (int)runtime->period_size) {\r\npipe->transferred %= runtime->period_size;\r\nsnd_pcm_period_elapsed(subs);\r\n}\r\n}\r\n}\r\nstatic int vx_pcm_trigger(struct snd_pcm_substream *subs, int cmd)\r\n{\r\nstruct vx_core *chip = snd_pcm_substream_chip(subs);\r\nstruct vx_pipe *pipe = subs->runtime->private_data;\r\nint err;\r\nif (chip->chip_status & VX_STAT_IS_STALE)\r\nreturn -EBUSY;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif (! pipe->is_capture)\r\nvx_pcm_playback_transfer(chip, subs, pipe, 2);\r\nerr = vx_start_stream(chip, pipe);\r\nif (err < 0) {\r\npr_debug("vx: cannot start stream\n");\r\nreturn err;\r\n}\r\nerr = vx_toggle_pipe(chip, pipe, 1);\r\nif (err < 0) {\r\npr_debug("vx: cannot start pipe\n");\r\nvx_stop_stream(chip, pipe);\r\nreturn err;\r\n}\r\nchip->pcm_running++;\r\npipe->running = 1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nvx_toggle_pipe(chip, pipe, 0);\r\nvx_stop_pipe(chip, pipe);\r\nvx_stop_stream(chip, pipe);\r\nchip->pcm_running--;\r\npipe->running = 0;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif ((err = vx_toggle_pipe(chip, pipe, 0)) < 0)\r\nreturn err;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif ((err = vx_toggle_pipe(chip, pipe, 1)) < 0)\r\nreturn err;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t vx_pcm_playback_pointer(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nstruct vx_pipe *pipe = runtime->private_data;\r\nreturn pipe->position;\r\n}\r\nstatic int vx_pcm_hw_params(struct snd_pcm_substream *subs,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_alloc_vmalloc_32_buffer\r\n(subs, params_buffer_bytes(hw_params));\r\n}\r\nstatic int vx_pcm_hw_free(struct snd_pcm_substream *subs)\r\n{\r\nreturn snd_pcm_lib_free_vmalloc_buffer(subs);\r\n}\r\nstatic int vx_pcm_prepare(struct snd_pcm_substream *subs)\r\n{\r\nstruct vx_core *chip = snd_pcm_substream_chip(subs);\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nstruct vx_pipe *pipe = runtime->private_data;\r\nint err, data_mode;\r\nif (chip->chip_status & VX_STAT_IS_STALE)\r\nreturn -EBUSY;\r\ndata_mode = (chip->uer_bits & IEC958_AES0_NONAUDIO) != 0;\r\nif (data_mode != pipe->data_mode && ! pipe->is_capture) {\r\nstruct vx_rmh rmh;\r\nsnd_printdd(KERN_DEBUG "reopen the pipe with data_mode = %d\n", data_mode);\r\nvx_init_rmh(&rmh, CMD_FREE_PIPE);\r\nvx_set_pipe_cmd_params(&rmh, 0, pipe->number, 0);\r\nif ((err = vx_send_msg(chip, &rmh)) < 0)\r\nreturn err;\r\nvx_init_rmh(&rmh, CMD_RES_PIPE);\r\nvx_set_pipe_cmd_params(&rmh, 0, pipe->number, pipe->channels);\r\nif (data_mode)\r\nrmh.Cmd[0] |= BIT_DATA_MODE;\r\nif ((err = vx_send_msg(chip, &rmh)) < 0)\r\nreturn err;\r\npipe->data_mode = data_mode;\r\n}\r\nif (chip->pcm_running && chip->freq != runtime->rate) {\r\nsnd_printk(KERN_ERR "vx: cannot set different clock %d "\r\n"from the current %d\n", runtime->rate, chip->freq);\r\nreturn -EINVAL;\r\n}\r\nvx_set_clock(chip, runtime->rate);\r\nif ((err = vx_set_format(chip, pipe, runtime)) < 0)\r\nreturn err;\r\nif (vx_is_pcmcia(chip)) {\r\npipe->align = 2;\r\n} else {\r\npipe->align = 4;\r\n}\r\npipe->buffer_bytes = frames_to_bytes(runtime, runtime->buffer_size);\r\npipe->period_bytes = frames_to_bytes(runtime, runtime->period_size);\r\npipe->hw_ptr = 0;\r\nvx_update_pipe_position(chip, runtime, pipe);\r\npipe->transferred = 0;\r\npipe->position = 0;\r\npipe->prepared = 1;\r\nreturn 0;\r\n}\r\nstatic int vx_pcm_capture_open(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nstruct vx_core *chip = snd_pcm_substream_chip(subs);\r\nstruct vx_pipe *pipe;\r\nstruct vx_pipe *pipe_out_monitoring = NULL;\r\nunsigned int audio;\r\nint err;\r\nif (chip->chip_status & VX_STAT_IS_STALE)\r\nreturn -EBUSY;\r\naudio = subs->pcm->device * 2;\r\nif (snd_BUG_ON(audio >= chip->audio_ins))\r\nreturn -EINVAL;\r\nerr = vx_alloc_pipe(chip, 1, audio, 2, &pipe);\r\nif (err < 0)\r\nreturn err;\r\npipe->substream = subs;\r\nchip->capture_pipes[audio] = pipe;\r\nif (chip->audio_monitor_active[audio]) {\r\npipe_out_monitoring = chip->playback_pipes[audio];\r\nif (! pipe_out_monitoring) {\r\nerr = vx_alloc_pipe(chip, 0, audio, 2, &pipe_out_monitoring);\r\nif (err < 0)\r\nreturn err;\r\nchip->playback_pipes[audio] = pipe_out_monitoring;\r\n}\r\npipe_out_monitoring->references++;\r\nvx_set_monitor_level(chip, audio, chip->audio_monitor[audio],\r\nchip->audio_monitor_active[audio]);\r\nvx_set_monitor_level(chip, audio+1, chip->audio_monitor[audio+1],\r\nchip->audio_monitor_active[audio+1]);\r\n}\r\npipe->monitoring_pipe = pipe_out_monitoring;\r\nruntime->hw = vx_pcm_capture_hw;\r\nruntime->hw.period_bytes_min = chip->ibl.size;\r\nruntime->private_data = pipe;\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 4);\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 4);\r\nreturn 0;\r\n}\r\nstatic int vx_pcm_capture_close(struct snd_pcm_substream *subs)\r\n{\r\nstruct vx_core *chip = snd_pcm_substream_chip(subs);\r\nstruct vx_pipe *pipe;\r\nstruct vx_pipe *pipe_out_monitoring;\r\nif (! subs->runtime->private_data)\r\nreturn -EINVAL;\r\npipe = subs->runtime->private_data;\r\nchip->capture_pipes[pipe->number] = NULL;\r\npipe_out_monitoring = pipe->monitoring_pipe;\r\nif (pipe_out_monitoring) {\r\nif (--pipe_out_monitoring->references == 0) {\r\nvx_free_pipe(chip, pipe_out_monitoring);\r\nchip->playback_pipes[pipe->number] = NULL;\r\npipe->monitoring_pipe = NULL;\r\n}\r\n}\r\nvx_free_pipe(chip, pipe);\r\nreturn 0;\r\n}\r\nstatic void vx_pcm_capture_update(struct vx_core *chip, struct snd_pcm_substream *subs,\r\nstruct vx_pipe *pipe)\r\n{\r\nint size, space, count;\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nif (! pipe->prepared || (chip->chip_status & VX_STAT_IS_STALE))\r\nreturn;\r\nsize = runtime->buffer_size - snd_pcm_capture_avail(runtime);\r\nif (! size)\r\nreturn;\r\nsize = frames_to_bytes(runtime, size);\r\nspace = vx_query_hbuffer_size(chip, pipe);\r\nif (space < 0)\r\ngoto _error;\r\nif (size > space)\r\nsize = space;\r\nsize = (size / 3) * 3;\r\nif (size < DMA_READ_ALIGN)\r\ngoto _error;\r\ncount = size - DMA_READ_ALIGN;\r\nwhile (count > 0) {\r\nif ((pipe->hw_ptr % pipe->align) == 0)\r\nbreak;\r\nif (vx_wait_for_rx_full(chip) < 0)\r\ngoto _error;\r\nvx_pcm_read_per_bytes(chip, runtime, pipe);\r\ncount -= 3;\r\n}\r\nif (count > 0) {\r\nint align = pipe->align * 3;\r\nspace = (count / align) * align;\r\nvx_pseudo_dma_read(chip, runtime, pipe, space);\r\ncount -= space;\r\n}\r\nwhile (count > 0) {\r\nif (vx_wait_for_rx_full(chip) < 0)\r\ngoto _error;\r\nvx_pcm_read_per_bytes(chip, runtime, pipe);\r\ncount -= 3;\r\n}\r\nvx_send_rih(chip, IRQ_CONNECT_STREAM_NEXT);\r\ncount = DMA_READ_ALIGN;\r\nwhile (count > 0) {\r\nvx_pcm_read_per_bytes(chip, runtime, pipe);\r\ncount -= 3;\r\n}\r\npipe->transferred += size;\r\nif (pipe->transferred >= pipe->period_bytes) {\r\npipe->transferred %= pipe->period_bytes;\r\nsnd_pcm_period_elapsed(subs);\r\n}\r\nreturn;\r\n_error:\r\nvx_send_rih(chip, IRQ_CONNECT_STREAM_NEXT);\r\nreturn;\r\n}\r\nstatic snd_pcm_uframes_t vx_pcm_capture_pointer(struct snd_pcm_substream *subs)\r\n{\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\nstruct vx_pipe *pipe = runtime->private_data;\r\nreturn bytes_to_frames(runtime, pipe->hw_ptr);\r\n}\r\nvoid vx_pcm_update_intr(struct vx_core *chip, unsigned int events)\r\n{\r\nunsigned int i;\r\nstruct vx_pipe *pipe;\r\n#define EVENT_MASK (END_OF_BUFFER_EVENTS_PENDING|ASYNC_EVENTS_PENDING)\r\nif (events & EVENT_MASK) {\r\nvx_init_rmh(&chip->irq_rmh, CMD_ASYNC);\r\nif (events & ASYNC_EVENTS_PENDING)\r\nchip->irq_rmh.Cmd[0] |= 0x00000001;\r\nif (events & END_OF_BUFFER_EVENTS_PENDING)\r\nchip->irq_rmh.Cmd[0] |= 0x00000002;\r\nif (vx_send_msg(chip, &chip->irq_rmh) < 0) {\r\nsnd_printdd(KERN_ERR "msg send error!!\n");\r\nreturn;\r\n}\r\ni = 1;\r\nwhile (i < chip->irq_rmh.LgStat) {\r\nint p, buf, capture, eob;\r\np = chip->irq_rmh.Stat[i] & MASK_FIRST_FIELD;\r\ncapture = (chip->irq_rmh.Stat[i] & 0x400000) ? 1 : 0;\r\neob = (chip->irq_rmh.Stat[i] & 0x800000) ? 1 : 0;\r\ni++;\r\nif (events & ASYNC_EVENTS_PENDING)\r\ni++;\r\nbuf = 1;\r\nif (events & END_OF_BUFFER_EVENTS_PENDING) {\r\nif (eob)\r\nbuf = chip->irq_rmh.Stat[i];\r\ni++;\r\n}\r\nif (capture)\r\ncontinue;\r\nif (snd_BUG_ON(p < 0 || p >= chip->audio_outs))\r\ncontinue;\r\npipe = chip->playback_pipes[p];\r\nif (pipe && pipe->substream) {\r\nvx_pcm_playback_update(chip, pipe->substream, pipe);\r\nvx_pcm_playback_transfer(chip, pipe->substream, pipe, buf);\r\n}\r\n}\r\n}\r\nfor (i = 0; i < chip->audio_ins; i++) {\r\npipe = chip->capture_pipes[i];\r\nif (pipe && pipe->substream)\r\nvx_pcm_capture_update(chip, pipe->substream, pipe);\r\n}\r\n}\r\nstatic int vx_init_audio_io(struct vx_core *chip)\r\n{\r\nstruct vx_rmh rmh;\r\nint preferred;\r\nvx_init_rmh(&rmh, CMD_SUPPORTED);\r\nif (vx_send_msg(chip, &rmh) < 0) {\r\nsnd_printk(KERN_ERR "vx: cannot get the supported audio data\n");\r\nreturn -ENXIO;\r\n}\r\nchip->audio_outs = rmh.Stat[0] & MASK_FIRST_FIELD;\r\nchip->audio_ins = (rmh.Stat[0] >> (FIELD_SIZE*2)) & MASK_FIRST_FIELD;\r\nchip->audio_info = rmh.Stat[1];\r\nchip->playback_pipes = kcalloc(chip->audio_outs, sizeof(struct vx_pipe *), GFP_KERNEL);\r\nif (!chip->playback_pipes)\r\nreturn -ENOMEM;\r\nchip->capture_pipes = kcalloc(chip->audio_ins, sizeof(struct vx_pipe *), GFP_KERNEL);\r\nif (!chip->capture_pipes) {\r\nkfree(chip->playback_pipes);\r\nreturn -ENOMEM;\r\n}\r\npreferred = chip->ibl.size;\r\nchip->ibl.size = 0;\r\nvx_set_ibl(chip, &chip->ibl);\r\nif (preferred > 0) {\r\nchip->ibl.size = ((preferred + chip->ibl.granularity - 1) /\r\nchip->ibl.granularity) * chip->ibl.granularity;\r\nif (chip->ibl.size > chip->ibl.max_size)\r\nchip->ibl.size = chip->ibl.max_size;\r\n} else\r\nchip->ibl.size = chip->ibl.min_size;\r\nvx_set_ibl(chip, &chip->ibl);\r\nreturn 0;\r\n}\r\nstatic void snd_vx_pcm_free(struct snd_pcm *pcm)\r\n{\r\nstruct vx_core *chip = pcm->private_data;\r\nchip->pcm[pcm->device] = NULL;\r\nkfree(chip->playback_pipes);\r\nchip->playback_pipes = NULL;\r\nkfree(chip->capture_pipes);\r\nchip->capture_pipes = NULL;\r\n}\r\nint snd_vx_pcm_new(struct vx_core *chip)\r\n{\r\nstruct snd_pcm *pcm;\r\nunsigned int i;\r\nint err;\r\nif ((err = vx_init_audio_io(chip)) < 0)\r\nreturn err;\r\nfor (i = 0; i < chip->hw->num_codecs; i++) {\r\nunsigned int outs, ins;\r\nouts = chip->audio_outs > i * 2 ? 1 : 0;\r\nins = chip->audio_ins > i * 2 ? 1 : 0;\r\nif (! outs && ! ins)\r\nbreak;\r\nerr = snd_pcm_new(chip->card, "VX PCM", i,\r\nouts, ins, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nif (outs)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &vx_pcm_playback_ops);\r\nif (ins)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &vx_pcm_capture_ops);\r\npcm->private_data = chip;\r\npcm->private_free = snd_vx_pcm_free;\r\npcm->info_flags = 0;\r\npcm->nonatomic = true;\r\nstrcpy(pcm->name, chip->card->shortname);\r\nchip->pcm[i] = pcm;\r\n}\r\nreturn 0;\r\n}
