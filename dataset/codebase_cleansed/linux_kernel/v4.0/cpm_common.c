static void udbg_putc_cpm(char c)\r\n{\r\nu8 __iomem *txbuf = (u8 __iomem __force *)in_be32(&cpm_udbg_txdesc[1]);\r\nif (c == '\n')\r\nudbg_putc_cpm('\r');\r\nwhile (in_be32(&cpm_udbg_txdesc[0]) & 0x80000000)\r\n;\r\nout_8(txbuf, c);\r\nout_be32(&cpm_udbg_txdesc[0], 0xa0000001);\r\n}\r\nvoid __init udbg_init_cpm(void)\r\n{\r\nif (cpm_udbg_txdesc) {\r\n#ifdef CONFIG_CPM2\r\nsetbat(1, 0xf0000000, 0xf0000000, 1024*1024, PAGE_KERNEL_NCG);\r\n#endif\r\nudbg_putc = udbg_putc_cpm;\r\n}\r\n}\r\nint cpm_muram_init(void)\r\n{\r\nstruct device_node *np;\r\nstruct resource r;\r\nu32 zero[OF_MAX_ADDR_CELLS] = {};\r\nresource_size_t max = 0;\r\nint i = 0;\r\nint ret = 0;\r\nif (muram_pbase)\r\nreturn 0;\r\nspin_lock_init(&cpm_muram_lock);\r\nrh_init(&cpm_muram_info, 1,\r\nsizeof(cpm_boot_muram_rh_block) /\r\nsizeof(cpm_boot_muram_rh_block[0]),\r\ncpm_boot_muram_rh_block);\r\nnp = of_find_compatible_node(NULL, NULL, "fsl,cpm-muram-data");\r\nif (!np) {\r\nnp = of_find_node_by_name(NULL, "data-only");\r\nif (!np) {\r\nprintk(KERN_ERR "Cannot find CPM muram data node");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\n}\r\nmuram_pbase = of_translate_address(np, zero);\r\nif (muram_pbase == (phys_addr_t)OF_BAD_ADDR) {\r\nprintk(KERN_ERR "Cannot translate zero through CPM muram node");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nwhile (of_address_to_resource(np, i++, &r) == 0) {\r\nif (r.end > max)\r\nmax = r.end;\r\nrh_attach_region(&cpm_muram_info, r.start - muram_pbase,\r\nresource_size(&r));\r\n}\r\nmuram_vbase = ioremap(muram_pbase, max - muram_pbase + 1);\r\nif (!muram_vbase) {\r\nprintk(KERN_ERR "Cannot map CPM muram");\r\nret = -ENOMEM;\r\n}\r\nout:\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\nunsigned long cpm_muram_alloc(unsigned long size, unsigned long align)\r\n{\r\nunsigned long start;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cpm_muram_lock, flags);\r\ncpm_muram_info.alignment = align;\r\nstart = rh_alloc(&cpm_muram_info, size, "commproc");\r\nmemset(cpm_muram_addr(start), 0, size);\r\nspin_unlock_irqrestore(&cpm_muram_lock, flags);\r\nreturn start;\r\n}\r\nint cpm_muram_free(unsigned long offset)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cpm_muram_lock, flags);\r\nret = rh_free(&cpm_muram_info, offset);\r\nspin_unlock_irqrestore(&cpm_muram_lock, flags);\r\nreturn ret;\r\n}\r\nunsigned long cpm_muram_alloc_fixed(unsigned long offset, unsigned long size)\r\n{\r\nunsigned long start;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cpm_muram_lock, flags);\r\ncpm_muram_info.alignment = 1;\r\nstart = rh_alloc_fixed(&cpm_muram_info, offset, size, "commproc");\r\nspin_unlock_irqrestore(&cpm_muram_lock, flags);\r\nreturn start;\r\n}\r\nvoid __iomem *cpm_muram_addr(unsigned long offset)\r\n{\r\nreturn muram_vbase + offset;\r\n}\r\nunsigned long cpm_muram_offset(void __iomem *addr)\r\n{\r\nreturn addr - (void __iomem *)muram_vbase;\r\n}\r\ndma_addr_t cpm_muram_dma(void __iomem *addr)\r\n{\r\nreturn muram_pbase + ((u8 __iomem *)addr - muram_vbase);\r\n}\r\nstatic inline struct cpm2_gpio32_chip *\r\nto_cpm2_gpio32_chip(struct of_mm_gpio_chip *mm_gc)\r\n{\r\nreturn container_of(mm_gc, struct cpm2_gpio32_chip, mm_gc);\r\n}\r\nstatic void cpm2_gpio32_save_regs(struct of_mm_gpio_chip *mm_gc)\r\n{\r\nstruct cpm2_gpio32_chip *cpm2_gc = to_cpm2_gpio32_chip(mm_gc);\r\nstruct cpm2_ioports __iomem *iop = mm_gc->regs;\r\ncpm2_gc->cpdata = in_be32(&iop->dat);\r\n}\r\nstatic int cpm2_gpio32_get(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct cpm2_ioports __iomem *iop = mm_gc->regs;\r\nu32 pin_mask;\r\npin_mask = 1 << (31 - gpio);\r\nreturn !!(in_be32(&iop->dat) & pin_mask);\r\n}\r\nstatic void __cpm2_gpio32_set(struct of_mm_gpio_chip *mm_gc, u32 pin_mask,\r\nint value)\r\n{\r\nstruct cpm2_gpio32_chip *cpm2_gc = to_cpm2_gpio32_chip(mm_gc);\r\nstruct cpm2_ioports __iomem *iop = mm_gc->regs;\r\nif (value)\r\ncpm2_gc->cpdata |= pin_mask;\r\nelse\r\ncpm2_gc->cpdata &= ~pin_mask;\r\nout_be32(&iop->dat, cpm2_gc->cpdata);\r\n}\r\nstatic void cpm2_gpio32_set(struct gpio_chip *gc, unsigned int gpio, int value)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct cpm2_gpio32_chip *cpm2_gc = to_cpm2_gpio32_chip(mm_gc);\r\nunsigned long flags;\r\nu32 pin_mask = 1 << (31 - gpio);\r\nspin_lock_irqsave(&cpm2_gc->lock, flags);\r\n__cpm2_gpio32_set(mm_gc, pin_mask, value);\r\nspin_unlock_irqrestore(&cpm2_gc->lock, flags);\r\n}\r\nstatic int cpm2_gpio32_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct cpm2_gpio32_chip *cpm2_gc = to_cpm2_gpio32_chip(mm_gc);\r\nstruct cpm2_ioports __iomem *iop = mm_gc->regs;\r\nunsigned long flags;\r\nu32 pin_mask = 1 << (31 - gpio);\r\nspin_lock_irqsave(&cpm2_gc->lock, flags);\r\nsetbits32(&iop->dir, pin_mask);\r\n__cpm2_gpio32_set(mm_gc, pin_mask, val);\r\nspin_unlock_irqrestore(&cpm2_gc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int cpm2_gpio32_dir_in(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct cpm2_gpio32_chip *cpm2_gc = to_cpm2_gpio32_chip(mm_gc);\r\nstruct cpm2_ioports __iomem *iop = mm_gc->regs;\r\nunsigned long flags;\r\nu32 pin_mask = 1 << (31 - gpio);\r\nspin_lock_irqsave(&cpm2_gc->lock, flags);\r\nclrbits32(&iop->dir, pin_mask);\r\nspin_unlock_irqrestore(&cpm2_gc->lock, flags);\r\nreturn 0;\r\n}\r\nint cpm2_gpiochip_add32(struct device_node *np)\r\n{\r\nstruct cpm2_gpio32_chip *cpm2_gc;\r\nstruct of_mm_gpio_chip *mm_gc;\r\nstruct gpio_chip *gc;\r\ncpm2_gc = kzalloc(sizeof(*cpm2_gc), GFP_KERNEL);\r\nif (!cpm2_gc)\r\nreturn -ENOMEM;\r\nspin_lock_init(&cpm2_gc->lock);\r\nmm_gc = &cpm2_gc->mm_gc;\r\ngc = &mm_gc->gc;\r\nmm_gc->save_regs = cpm2_gpio32_save_regs;\r\ngc->ngpio = 32;\r\ngc->direction_input = cpm2_gpio32_dir_in;\r\ngc->direction_output = cpm2_gpio32_dir_out;\r\ngc->get = cpm2_gpio32_get;\r\ngc->set = cpm2_gpio32_set;\r\nreturn of_mm_gpiochip_add(np, mm_gc);\r\n}
