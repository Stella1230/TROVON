void\r\ncifs_sb_active(struct super_block *sb)\r\n{\r\nstruct cifs_sb_info *server = CIFS_SB(sb);\r\nif (atomic_inc_return(&server->active) == 1)\r\natomic_inc(&sb->s_active);\r\n}\r\nvoid\r\ncifs_sb_deactive(struct super_block *sb)\r\n{\r\nstruct cifs_sb_info *server = CIFS_SB(sb);\r\nif (atomic_dec_and_test(&server->active))\r\ndeactivate_super(sb);\r\n}\r\nstatic int\r\ncifs_read_super(struct super_block *sb)\r\n{\r\nstruct inode *inode;\r\nstruct cifs_sb_info *cifs_sb;\r\nstruct cifs_tcon *tcon;\r\nint rc = 0;\r\ncifs_sb = CIFS_SB(sb);\r\ntcon = cifs_sb_master_tcon(cifs_sb);\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIXACL)\r\nsb->s_flags |= MS_POSIXACL;\r\nif (tcon->ses->capabilities & tcon->ses->server->vals->cap_large_files)\r\nsb->s_maxbytes = MAX_LFS_FILESIZE;\r\nelse\r\nsb->s_maxbytes = MAX_NON_LFS;\r\nsb->s_time_gran = 100;\r\nsb->s_magic = CIFS_MAGIC_NUMBER;\r\nsb->s_op = &cifs_super_ops;\r\nsb->s_bdi = &cifs_sb->bdi;\r\nsb->s_blocksize = CIFS_MAX_MSGSIZE;\r\nsb->s_blocksize_bits = 14;\r\ninode = cifs_root_iget(sb);\r\nif (IS_ERR(inode)) {\r\nrc = PTR_ERR(inode);\r\ngoto out_no_root;\r\n}\r\nif (tcon->nocase)\r\nsb->s_d_op = &cifs_ci_dentry_ops;\r\nelse\r\nsb->s_d_op = &cifs_dentry_ops;\r\nsb->s_root = d_make_root(inode);\r\nif (!sb->s_root) {\r\nrc = -ENOMEM;\r\ngoto out_no_root;\r\n}\r\n#ifdef CONFIG_CIFS_NFSD_EXPORT\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) {\r\ncifs_dbg(FYI, "export ops supported\n");\r\nsb->s_export_op = &cifs_export_ops;\r\n}\r\n#endif\r\nreturn 0;\r\nout_no_root:\r\ncifs_dbg(VFS, "%s: get root inode failed\n", __func__);\r\nreturn rc;\r\n}\r\nstatic void cifs_kill_sb(struct super_block *sb)\r\n{\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\r\nkill_anon_super(sb);\r\ncifs_umount(cifs_sb);\r\n}\r\nstatic int\r\ncifs_statfs(struct dentry *dentry, struct kstatfs *buf)\r\n{\r\nstruct super_block *sb = dentry->d_sb;\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\r\nstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\r\nstruct TCP_Server_Info *server = tcon->ses->server;\r\nunsigned int xid;\r\nint rc = 0;\r\nxid = get_xid();\r\nbuf->f_namelen = PATH_MAX;\r\nbuf->f_files = 0;\r\nbuf->f_ffree = 0;\r\nif (server->ops->queryfs)\r\nrc = server->ops->queryfs(xid, tcon, buf);\r\nfree_xid(xid);\r\nreturn 0;\r\n}\r\nstatic long cifs_fallocate(struct file *file, int mode, loff_t off, loff_t len)\r\n{\r\nstruct cifs_sb_info *cifs_sb = CIFS_FILE_SB(file);\r\nstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\r\nstruct TCP_Server_Info *server = tcon->ses->server;\r\nif (server->ops->fallocate)\r\nreturn server->ops->fallocate(file, tcon, mode, off, len);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int cifs_permission(struct inode *inode, int mask)\r\n{\r\nstruct cifs_sb_info *cifs_sb;\r\ncifs_sb = CIFS_SB(inode->i_sb);\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM) {\r\nif ((mask & MAY_EXEC) && !execute_ok(inode))\r\nreturn -EACCES;\r\nelse\r\nreturn 0;\r\n} else\r\nreturn generic_permission(inode, mask);\r\n}\r\nstatic struct inode *\r\ncifs_alloc_inode(struct super_block *sb)\r\n{\r\nstruct cifsInodeInfo *cifs_inode;\r\ncifs_inode = kmem_cache_alloc(cifs_inode_cachep, GFP_KERNEL);\r\nif (!cifs_inode)\r\nreturn NULL;\r\ncifs_inode->cifsAttrs = 0x20;\r\ncifs_inode->time = 0;\r\ncifs_set_oplock_level(cifs_inode, 0);\r\ncifs_inode->flags = 0;\r\nspin_lock_init(&cifs_inode->writers_lock);\r\ncifs_inode->writers = 0;\r\ncifs_inode->vfs_inode.i_blkbits = 14;\r\ncifs_inode->server_eof = 0;\r\ncifs_inode->uniqueid = 0;\r\ncifs_inode->createtime = 0;\r\ncifs_inode->epoch = 0;\r\n#ifdef CONFIG_CIFS_SMB2\r\nget_random_bytes(cifs_inode->lease_key, SMB2_LEASE_KEY_SIZE);\r\n#endif\r\nINIT_LIST_HEAD(&cifs_inode->openFileList);\r\nINIT_LIST_HEAD(&cifs_inode->llist);\r\nreturn &cifs_inode->vfs_inode;\r\n}\r\nstatic void cifs_i_callback(struct rcu_head *head)\r\n{\r\nstruct inode *inode = container_of(head, struct inode, i_rcu);\r\nkmem_cache_free(cifs_inode_cachep, CIFS_I(inode));\r\n}\r\nstatic void\r\ncifs_destroy_inode(struct inode *inode)\r\n{\r\ncall_rcu(&inode->i_rcu, cifs_i_callback);\r\n}\r\nstatic void\r\ncifs_evict_inode(struct inode *inode)\r\n{\r\ntruncate_inode_pages_final(&inode->i_data);\r\nclear_inode(inode);\r\ncifs_fscache_release_inode_cookie(inode);\r\n}\r\nstatic void\r\ncifs_show_address(struct seq_file *s, struct TCP_Server_Info *server)\r\n{\r\nstruct sockaddr_in *sa = (struct sockaddr_in *) &server->dstaddr;\r\nstruct sockaddr_in6 *sa6 = (struct sockaddr_in6 *) &server->dstaddr;\r\nseq_puts(s, ",addr=");\r\nswitch (server->dstaddr.ss_family) {\r\ncase AF_INET:\r\nseq_printf(s, "%pI4", &sa->sin_addr.s_addr);\r\nbreak;\r\ncase AF_INET6:\r\nseq_printf(s, "%pI6", &sa6->sin6_addr.s6_addr);\r\nif (sa6->sin6_scope_id)\r\nseq_printf(s, "%%%u", sa6->sin6_scope_id);\r\nbreak;\r\ndefault:\r\nseq_puts(s, "(unknown)");\r\n}\r\n}\r\nstatic void\r\ncifs_show_security(struct seq_file *s, struct cifs_ses *ses)\r\n{\r\nif (ses->sectype == Unspecified)\r\nreturn;\r\nseq_puts(s, ",sec=");\r\nswitch (ses->sectype) {\r\ncase LANMAN:\r\nseq_puts(s, "lanman");\r\nbreak;\r\ncase NTLMv2:\r\nseq_puts(s, "ntlmv2");\r\nbreak;\r\ncase NTLM:\r\nseq_puts(s, "ntlm");\r\nbreak;\r\ncase Kerberos:\r\nseq_puts(s, "krb5");\r\nbreak;\r\ncase RawNTLMSSP:\r\nseq_puts(s, "ntlmssp");\r\nbreak;\r\ndefault:\r\nseq_puts(s, "unknown");\r\nbreak;\r\n}\r\nif (ses->sign)\r\nseq_puts(s, "i");\r\n}\r\nstatic void\r\ncifs_show_cache_flavor(struct seq_file *s, struct cifs_sb_info *cifs_sb)\r\n{\r\nseq_puts(s, ",cache=");\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_STRICT_IO)\r\nseq_puts(s, "strict");\r\nelse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DIRECT_IO)\r\nseq_puts(s, "none");\r\nelse\r\nseq_puts(s, "loose");\r\n}\r\nstatic void\r\ncifs_show_nls(struct seq_file *s, struct nls_table *cur)\r\n{\r\nstruct nls_table *def;\r\ndef = load_nls_default();\r\nif (def != cur)\r\nseq_printf(s, ",iocharset=%s", cur->charset);\r\nunload_nls(def);\r\n}\r\nstatic int\r\ncifs_show_options(struct seq_file *s, struct dentry *root)\r\n{\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(root->d_sb);\r\nstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\r\nstruct sockaddr *srcaddr;\r\nsrcaddr = (struct sockaddr *)&tcon->ses->server->srcaddr;\r\nseq_printf(s, ",vers=%s", tcon->ses->server->vals->version_string);\r\ncifs_show_security(s, tcon->ses);\r\ncifs_show_cache_flavor(s, cifs_sb);\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER)\r\nseq_puts(s, ",multiuser");\r\nelse if (tcon->ses->user_name)\r\nseq_printf(s, ",username=%s", tcon->ses->user_name);\r\nif (tcon->ses->domainName)\r\nseq_printf(s, ",domain=%s", tcon->ses->domainName);\r\nif (srcaddr->sa_family != AF_UNSPEC) {\r\nstruct sockaddr_in *saddr4;\r\nstruct sockaddr_in6 *saddr6;\r\nsaddr4 = (struct sockaddr_in *)srcaddr;\r\nsaddr6 = (struct sockaddr_in6 *)srcaddr;\r\nif (srcaddr->sa_family == AF_INET6)\r\nseq_printf(s, ",srcaddr=%pI6c",\r\n&saddr6->sin6_addr);\r\nelse if (srcaddr->sa_family == AF_INET)\r\nseq_printf(s, ",srcaddr=%pI4",\r\n&saddr4->sin_addr.s_addr);\r\nelse\r\nseq_printf(s, ",srcaddr=BAD-AF:%i",\r\n(int)(srcaddr->sa_family));\r\n}\r\nseq_printf(s, ",uid=%u",\r\nfrom_kuid_munged(&init_user_ns, cifs_sb->mnt_uid));\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_UID)\r\nseq_puts(s, ",forceuid");\r\nelse\r\nseq_puts(s, ",noforceuid");\r\nseq_printf(s, ",gid=%u",\r\nfrom_kgid_munged(&init_user_ns, cifs_sb->mnt_gid));\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_OVERR_GID)\r\nseq_puts(s, ",forcegid");\r\nelse\r\nseq_puts(s, ",noforcegid");\r\ncifs_show_address(s, tcon->ses->server);\r\nif (!tcon->unix_ext)\r\nseq_printf(s, ",file_mode=0%ho,dir_mode=0%ho",\r\ncifs_sb->mnt_file_mode,\r\ncifs_sb->mnt_dir_mode);\r\ncifs_show_nls(s, cifs_sb->local_nls);\r\nif (tcon->seal)\r\nseq_puts(s, ",seal");\r\nif (tcon->nocase)\r\nseq_puts(s, ",nocase");\r\nif (tcon->retry)\r\nseq_puts(s, ",hard");\r\nif (tcon->unix_ext)\r\nseq_puts(s, ",unix");\r\nelse\r\nseq_puts(s, ",nounix");\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS)\r\nseq_puts(s, ",posixpaths");\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SET_UID)\r\nseq_puts(s, ",setuids");\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM)\r\nseq_puts(s, ",serverino");\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD)\r\nseq_puts(s, ",rwpidforward");\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOPOSIXBRL)\r\nseq_puts(s, ",forcemand");\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_XATTR)\r\nseq_puts(s, ",nouser_xattr");\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\r\nseq_puts(s, ",mapchars");\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_UNX_EMUL)\r\nseq_puts(s, ",sfu");\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_BRL)\r\nseq_puts(s, ",nobrl");\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_ACL)\r\nseq_puts(s, ",cifsacl");\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_DYNPERM)\r\nseq_puts(s, ",dynperm");\r\nif (root->d_sb->s_flags & MS_POSIXACL)\r\nseq_puts(s, ",acl");\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MF_SYMLINKS)\r\nseq_puts(s, ",mfsymlinks");\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_FSCACHE)\r\nseq_puts(s, ",fsc");\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NOSSYNC)\r\nseq_puts(s, ",nostrictsync");\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_NO_PERM)\r\nseq_puts(s, ",noperm");\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPUID)\r\nseq_printf(s, ",backupuid=%u",\r\nfrom_kuid_munged(&init_user_ns,\r\ncifs_sb->mnt_backupuid));\r\nif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_CIFS_BACKUPGID)\r\nseq_printf(s, ",backupgid=%u",\r\nfrom_kgid_munged(&init_user_ns,\r\ncifs_sb->mnt_backupgid));\r\nseq_printf(s, ",rsize=%u", cifs_sb->rsize);\r\nseq_printf(s, ",wsize=%u", cifs_sb->wsize);\r\nseq_printf(s, ",actimeo=%lu", cifs_sb->actimeo / HZ);\r\nreturn 0;\r\n}\r\nstatic void cifs_umount_begin(struct super_block *sb)\r\n{\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\r\nstruct cifs_tcon *tcon;\r\nif (cifs_sb == NULL)\r\nreturn;\r\ntcon = cifs_sb_master_tcon(cifs_sb);\r\nspin_lock(&cifs_tcp_ses_lock);\r\nif ((tcon->tc_count > 1) || (tcon->tidStatus == CifsExiting)) {\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nreturn;\r\n} else if (tcon->tc_count == 1)\r\ntcon->tidStatus = CifsExiting;\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nif (tcon->ses && tcon->ses->server) {\r\ncifs_dbg(FYI, "wake up tasks now - umount begin not complete\n");\r\nwake_up_all(&tcon->ses->server->request_q);\r\nwake_up_all(&tcon->ses->server->response_q);\r\nmsleep(1);\r\nwake_up_all(&tcon->ses->server->response_q);\r\nmsleep(1);\r\n}\r\nreturn;\r\n}\r\nstatic int cifs_show_stats(struct seq_file *s, struct dentry *root)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cifs_remount(struct super_block *sb, int *flags, char *data)\r\n{\r\nsync_filesystem(sb);\r\n*flags |= MS_NODIRATIME;\r\nreturn 0;\r\n}\r\nstatic int cifs_drop_inode(struct inode *inode)\r\n{\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(inode->i_sb);\r\nreturn !(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_SERVER_INUM) ||\r\ngeneric_drop_inode(inode);\r\n}\r\nstatic struct dentry *\r\ncifs_get_root(struct smb_vol *vol, struct super_block *sb)\r\n{\r\nstruct dentry *dentry;\r\nstruct cifs_sb_info *cifs_sb = CIFS_SB(sb);\r\nchar *full_path = NULL;\r\nchar *s, *p;\r\nchar sep;\r\nfull_path = cifs_build_path_to_root(vol, cifs_sb,\r\ncifs_sb_master_tcon(cifs_sb));\r\nif (full_path == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\ncifs_dbg(FYI, "Get root dentry for %s\n", full_path);\r\nsep = CIFS_DIR_SEP(cifs_sb);\r\ndentry = dget(sb->s_root);\r\np = s = full_path;\r\ndo {\r\nstruct inode *dir = dentry->d_inode;\r\nstruct dentry *child;\r\nif (!dir) {\r\ndput(dentry);\r\ndentry = ERR_PTR(-ENOENT);\r\nbreak;\r\n}\r\nif (!S_ISDIR(dir->i_mode)) {\r\ndput(dentry);\r\ndentry = ERR_PTR(-ENOTDIR);\r\nbreak;\r\n}\r\nwhile (*s == sep)\r\ns++;\r\nif (!*s)\r\nbreak;\r\np = s++;\r\nwhile (*s && *s != sep)\r\ns++;\r\nmutex_lock(&dir->i_mutex);\r\nchild = lookup_one_len(p, dentry, s - p);\r\nmutex_unlock(&dir->i_mutex);\r\ndput(dentry);\r\ndentry = child;\r\n} while (!IS_ERR(dentry));\r\nkfree(full_path);\r\nreturn dentry;\r\n}\r\nstatic int cifs_set_super(struct super_block *sb, void *data)\r\n{\r\nstruct cifs_mnt_data *mnt_data = data;\r\nsb->s_fs_info = mnt_data->cifs_sb;\r\nreturn set_anon_super(sb, NULL);\r\n}\r\nstatic struct dentry *\r\ncifs_do_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nint rc;\r\nstruct super_block *sb;\r\nstruct cifs_sb_info *cifs_sb;\r\nstruct smb_vol *volume_info;\r\nstruct cifs_mnt_data mnt_data;\r\nstruct dentry *root;\r\ncifs_dbg(FYI, "Devname: %s flags: %d\n", dev_name, flags);\r\nvolume_info = cifs_get_volume_info((char *)data, dev_name);\r\nif (IS_ERR(volume_info))\r\nreturn ERR_CAST(volume_info);\r\ncifs_sb = kzalloc(sizeof(struct cifs_sb_info), GFP_KERNEL);\r\nif (cifs_sb == NULL) {\r\nroot = ERR_PTR(-ENOMEM);\r\ngoto out_nls;\r\n}\r\ncifs_sb->mountdata = kstrndup(data, PAGE_SIZE, GFP_KERNEL);\r\nif (cifs_sb->mountdata == NULL) {\r\nroot = ERR_PTR(-ENOMEM);\r\ngoto out_cifs_sb;\r\n}\r\ncifs_setup_cifs_sb(volume_info, cifs_sb);\r\nrc = cifs_mount(cifs_sb, volume_info);\r\nif (rc) {\r\nif (!(flags & MS_SILENT))\r\ncifs_dbg(VFS, "cifs_mount failed w/return code = %d\n",\r\nrc);\r\nroot = ERR_PTR(rc);\r\ngoto out_mountdata;\r\n}\r\nmnt_data.vol = volume_info;\r\nmnt_data.cifs_sb = cifs_sb;\r\nmnt_data.flags = flags;\r\nflags |= MS_NODIRATIME | MS_NOATIME;\r\nsb = sget(fs_type, cifs_match_super, cifs_set_super, flags, &mnt_data);\r\nif (IS_ERR(sb)) {\r\nroot = ERR_CAST(sb);\r\ncifs_umount(cifs_sb);\r\ngoto out;\r\n}\r\nif (sb->s_root) {\r\ncifs_dbg(FYI, "Use existing superblock\n");\r\ncifs_umount(cifs_sb);\r\n} else {\r\nrc = cifs_read_super(sb);\r\nif (rc) {\r\nroot = ERR_PTR(rc);\r\ngoto out_super;\r\n}\r\nsb->s_flags |= MS_ACTIVE;\r\n}\r\nroot = cifs_get_root(volume_info, sb);\r\nif (IS_ERR(root))\r\ngoto out_super;\r\ncifs_dbg(FYI, "dentry root is: %p\n", root);\r\ngoto out;\r\nout_super:\r\ndeactivate_locked_super(sb);\r\nout:\r\ncifs_cleanup_volume_info(volume_info);\r\nreturn root;\r\nout_mountdata:\r\nkfree(cifs_sb->mountdata);\r\nout_cifs_sb:\r\nkfree(cifs_sb);\r\nout_nls:\r\nunload_nls(volume_info->local_nls);\r\ngoto out;\r\n}\r\nstatic ssize_t\r\ncifs_loose_read_iter(struct kiocb *iocb, struct iov_iter *iter)\r\n{\r\nssize_t rc;\r\nstruct inode *inode = file_inode(iocb->ki_filp);\r\nrc = cifs_revalidate_mapping(inode);\r\nif (rc)\r\nreturn rc;\r\nreturn generic_file_read_iter(iocb, iter);\r\n}\r\nstatic ssize_t cifs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\r\n{\r\nstruct inode *inode = file_inode(iocb->ki_filp);\r\nstruct cifsInodeInfo *cinode = CIFS_I(inode);\r\nssize_t written;\r\nint rc;\r\nwritten = cifs_get_writer(cinode);\r\nif (written)\r\nreturn written;\r\nwritten = generic_file_write_iter(iocb, from);\r\nif (CIFS_CACHE_WRITE(CIFS_I(inode)))\r\ngoto out;\r\nrc = filemap_fdatawrite(inode->i_mapping);\r\nif (rc)\r\ncifs_dbg(FYI, "cifs_file_write_iter: %d rc on %p inode\n",\r\nrc, inode);\r\nout:\r\ncifs_put_writer(cinode);\r\nreturn written;\r\n}\r\nstatic loff_t cifs_llseek(struct file *file, loff_t offset, int whence)\r\n{\r\nif (whence != SEEK_SET && whence != SEEK_CUR) {\r\nint rc;\r\nstruct inode *inode = file_inode(file);\r\nif (!CIFS_CACHE_READ(CIFS_I(inode)) && inode->i_mapping &&\r\ninode->i_mapping->nrpages != 0) {\r\nrc = filemap_fdatawait(inode->i_mapping);\r\nif (rc) {\r\nmapping_set_error(inode->i_mapping, rc);\r\nreturn rc;\r\n}\r\n}\r\nCIFS_I(inode)->time = 0;\r\nrc = cifs_revalidate_file_attr(file);\r\nif (rc < 0)\r\nreturn (loff_t)rc;\r\n}\r\nreturn generic_file_llseek(file, offset, whence);\r\n}\r\nstatic int\r\ncifs_setlease(struct file *file, long arg, struct file_lock **lease, void **priv)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nstruct cifsFileInfo *cfile = file->private_data;\r\nif (!(S_ISREG(inode->i_mode)))\r\nreturn -EINVAL;\r\nif (arg == F_UNLCK ||\r\n((arg == F_RDLCK) && CIFS_CACHE_READ(CIFS_I(inode))) ||\r\n((arg == F_WRLCK) && CIFS_CACHE_WRITE(CIFS_I(inode))))\r\nreturn generic_setlease(file, arg, lease, priv);\r\nelse if (tlink_tcon(cfile->tlink)->local_lease &&\r\n!CIFS_CACHE_READ(CIFS_I(inode)))\r\nreturn generic_setlease(file, arg, lease, priv);\r\nelse\r\nreturn -EAGAIN;\r\n}\r\nstatic void\r\ncifs_init_once(void *inode)\r\n{\r\nstruct cifsInodeInfo *cifsi = inode;\r\ninode_init_once(&cifsi->vfs_inode);\r\ninit_rwsem(&cifsi->lock_sem);\r\n}\r\nstatic int __init\r\ncifs_init_inodecache(void)\r\n{\r\ncifs_inode_cachep = kmem_cache_create("cifs_inode_cache",\r\nsizeof(struct cifsInodeInfo),\r\n0, (SLAB_RECLAIM_ACCOUNT|\r\nSLAB_MEM_SPREAD),\r\ncifs_init_once);\r\nif (cifs_inode_cachep == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void\r\ncifs_destroy_inodecache(void)\r\n{\r\nrcu_barrier();\r\nkmem_cache_destroy(cifs_inode_cachep);\r\n}\r\nstatic int\r\ncifs_init_request_bufs(void)\r\n{\r\nsize_t max_hdr_size = MAX_CIFS_HDR_SIZE;\r\n#ifdef CONFIG_CIFS_SMB2\r\nmax_hdr_size = MAX_SMB2_HDR_SIZE;\r\n#endif\r\nif (CIFSMaxBufSize < 8192) {\r\nCIFSMaxBufSize = 8192;\r\n} else if (CIFSMaxBufSize > 1024*127) {\r\nCIFSMaxBufSize = 1024 * 127;\r\n} else {\r\nCIFSMaxBufSize &= 0x1FE00;\r\n}\r\ncifs_req_cachep = kmem_cache_create("cifs_request",\r\nCIFSMaxBufSize + max_hdr_size, 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (cifs_req_cachep == NULL)\r\nreturn -ENOMEM;\r\nif (cifs_min_rcv < 1)\r\ncifs_min_rcv = 1;\r\nelse if (cifs_min_rcv > 64) {\r\ncifs_min_rcv = 64;\r\ncifs_dbg(VFS, "cifs_min_rcv set to maximum (64)\n");\r\n}\r\ncifs_req_poolp = mempool_create_slab_pool(cifs_min_rcv,\r\ncifs_req_cachep);\r\nif (cifs_req_poolp == NULL) {\r\nkmem_cache_destroy(cifs_req_cachep);\r\nreturn -ENOMEM;\r\n}\r\ncifs_sm_req_cachep = kmem_cache_create("cifs_small_rq",\r\nMAX_CIFS_SMALL_BUFFER_SIZE, 0, SLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (cifs_sm_req_cachep == NULL) {\r\nmempool_destroy(cifs_req_poolp);\r\nkmem_cache_destroy(cifs_req_cachep);\r\nreturn -ENOMEM;\r\n}\r\nif (cifs_min_small < 2)\r\ncifs_min_small = 2;\r\nelse if (cifs_min_small > 256) {\r\ncifs_min_small = 256;\r\ncifs_dbg(FYI, "cifs_min_small set to maximum (256)\n");\r\n}\r\ncifs_sm_req_poolp = mempool_create_slab_pool(cifs_min_small,\r\ncifs_sm_req_cachep);\r\nif (cifs_sm_req_poolp == NULL) {\r\nmempool_destroy(cifs_req_poolp);\r\nkmem_cache_destroy(cifs_req_cachep);\r\nkmem_cache_destroy(cifs_sm_req_cachep);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ncifs_destroy_request_bufs(void)\r\n{\r\nmempool_destroy(cifs_req_poolp);\r\nkmem_cache_destroy(cifs_req_cachep);\r\nmempool_destroy(cifs_sm_req_poolp);\r\nkmem_cache_destroy(cifs_sm_req_cachep);\r\n}\r\nstatic int\r\ncifs_init_mids(void)\r\n{\r\ncifs_mid_cachep = kmem_cache_create("cifs_mpx_ids",\r\nsizeof(struct mid_q_entry), 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (cifs_mid_cachep == NULL)\r\nreturn -ENOMEM;\r\ncifs_mid_poolp = mempool_create_slab_pool(3, cifs_mid_cachep);\r\nif (cifs_mid_poolp == NULL) {\r\nkmem_cache_destroy(cifs_mid_cachep);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ncifs_destroy_mids(void)\r\n{\r\nmempool_destroy(cifs_mid_poolp);\r\nkmem_cache_destroy(cifs_mid_cachep);\r\n}\r\nstatic int __init\r\ninit_cifs(void)\r\n{\r\nint rc = 0;\r\ncifs_proc_init();\r\nINIT_LIST_HEAD(&cifs_tcp_ses_list);\r\n#ifdef CONFIG_CIFS_DNOTIFY_EXPERIMENTAL\r\nINIT_LIST_HEAD(&GlobalDnotifyReqList);\r\nINIT_LIST_HEAD(&GlobalDnotifyRsp_Q);\r\n#endif\r\natomic_set(&sesInfoAllocCount, 0);\r\natomic_set(&tconInfoAllocCount, 0);\r\natomic_set(&tcpSesAllocCount, 0);\r\natomic_set(&tcpSesReconnectCount, 0);\r\natomic_set(&tconInfoReconnectCount, 0);\r\natomic_set(&bufAllocCount, 0);\r\natomic_set(&smBufAllocCount, 0);\r\n#ifdef CONFIG_CIFS_STATS2\r\natomic_set(&totBufAllocCount, 0);\r\natomic_set(&totSmBufAllocCount, 0);\r\n#endif\r\natomic_set(&midCount, 0);\r\nGlobalCurrentXid = 0;\r\nGlobalTotalActiveXid = 0;\r\nGlobalMaxActiveXid = 0;\r\nspin_lock_init(&cifs_tcp_ses_lock);\r\nspin_lock_init(&cifs_file_list_lock);\r\nspin_lock_init(&GlobalMid_Lock);\r\nif (cifs_max_pending < 2) {\r\ncifs_max_pending = 2;\r\ncifs_dbg(FYI, "cifs_max_pending set to min of 2\n");\r\n} else if (cifs_max_pending > CIFS_MAX_REQ) {\r\ncifs_max_pending = CIFS_MAX_REQ;\r\ncifs_dbg(FYI, "cifs_max_pending set to max of %u\n",\r\nCIFS_MAX_REQ);\r\n}\r\ncifsiod_wq = alloc_workqueue("cifsiod", WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);\r\nif (!cifsiod_wq) {\r\nrc = -ENOMEM;\r\ngoto out_clean_proc;\r\n}\r\nrc = cifs_fscache_register();\r\nif (rc)\r\ngoto out_destroy_wq;\r\nrc = cifs_init_inodecache();\r\nif (rc)\r\ngoto out_unreg_fscache;\r\nrc = cifs_init_mids();\r\nif (rc)\r\ngoto out_destroy_inodecache;\r\nrc = cifs_init_request_bufs();\r\nif (rc)\r\ngoto out_destroy_mids;\r\n#ifdef CONFIG_CIFS_UPCALL\r\nrc = register_key_type(&cifs_spnego_key_type);\r\nif (rc)\r\ngoto out_destroy_request_bufs;\r\n#endif\r\n#ifdef CONFIG_CIFS_ACL\r\nrc = init_cifs_idmap();\r\nif (rc)\r\ngoto out_register_key_type;\r\n#endif\r\nrc = register_filesystem(&cifs_fs_type);\r\nif (rc)\r\ngoto out_init_cifs_idmap;\r\nreturn 0;\r\nout_init_cifs_idmap:\r\n#ifdef CONFIG_CIFS_ACL\r\nexit_cifs_idmap();\r\nout_register_key_type:\r\n#endif\r\n#ifdef CONFIG_CIFS_UPCALL\r\nunregister_key_type(&cifs_spnego_key_type);\r\nout_destroy_request_bufs:\r\n#endif\r\ncifs_destroy_request_bufs();\r\nout_destroy_mids:\r\ncifs_destroy_mids();\r\nout_destroy_inodecache:\r\ncifs_destroy_inodecache();\r\nout_unreg_fscache:\r\ncifs_fscache_unregister();\r\nout_destroy_wq:\r\ndestroy_workqueue(cifsiod_wq);\r\nout_clean_proc:\r\ncifs_proc_clean();\r\nreturn rc;\r\n}\r\nstatic void __exit\r\nexit_cifs(void)\r\n{\r\ncifs_dbg(NOISY, "exit_cifs\n");\r\nunregister_filesystem(&cifs_fs_type);\r\ncifs_dfs_release_automount_timer();\r\n#ifdef CONFIG_CIFS_ACL\r\nexit_cifs_idmap();\r\n#endif\r\n#ifdef CONFIG_CIFS_UPCALL\r\nunregister_key_type(&cifs_spnego_key_type);\r\n#endif\r\ncifs_destroy_request_bufs();\r\ncifs_destroy_mids();\r\ncifs_destroy_inodecache();\r\ncifs_fscache_unregister();\r\ndestroy_workqueue(cifsiod_wq);\r\ncifs_proc_clean();\r\n}
