static u_char normalize_no_excep(FPU_REG *r, int exp, int sign)\r\n{\r\nu_char tag;\r\nsetexponent16(r, exp);\r\ntag = FPU_normalize_nuo(r);\r\nstdexp(r);\r\nif (sign)\r\nsetnegative(r);\r\nreturn tag;\r\n}\r\nint FPU_tagof(FPU_REG *ptr)\r\n{\r\nint exp;\r\nexp = exponent16(ptr) & 0x7fff;\r\nif (exp == 0) {\r\nif (!(ptr->sigh | ptr->sigl)) {\r\nreturn TAG_Zero;\r\n}\r\nreturn TAG_Special;\r\n}\r\nif (exp == 0x7fff) {\r\nreturn TAG_Special;\r\n}\r\nif (!(ptr->sigh & 0x80000000)) {\r\nreturn TAG_Special;\r\n}\r\nreturn TAG_Valid;\r\n}\r\nint FPU_load_extended(long double __user *s, int stnr)\r\n{\r\nFPU_REG *sti_ptr = &st(stnr);\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_READ, s, 10);\r\n__copy_from_user(sti_ptr, s, 10);\r\nRE_ENTRANT_CHECK_ON;\r\nreturn FPU_tagof(sti_ptr);\r\n}\r\nint FPU_load_double(double __user *dfloat, FPU_REG *loaded_data)\r\n{\r\nint exp, tag, negative;\r\nunsigned m64, l64;\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_READ, dfloat, 8);\r\nFPU_get_user(m64, 1 + (unsigned long __user *)dfloat);\r\nFPU_get_user(l64, (unsigned long __user *)dfloat);\r\nRE_ENTRANT_CHECK_ON;\r\nnegative = (m64 & 0x80000000) ? SIGN_Negative : SIGN_Positive;\r\nexp = ((m64 & 0x7ff00000) >> 20) - DOUBLE_Ebias + EXTENDED_Ebias;\r\nm64 &= 0xfffff;\r\nif (exp > DOUBLE_Emax + EXTENDED_Ebias) {\r\nif ((m64 == 0) && (l64 == 0)) {\r\nloaded_data->sigh = 0x80000000;\r\nloaded_data->sigl = 0x00000000;\r\nexp = EXP_Infinity + EXTENDED_Ebias;\r\ntag = TAG_Special;\r\n} else {\r\nexp = EXP_NaN + EXTENDED_Ebias;\r\nloaded_data->sigh = (m64 << 11) | 0x80000000;\r\nloaded_data->sigh |= l64 >> 21;\r\nloaded_data->sigl = l64 << 11;\r\ntag = TAG_Special;\r\n}\r\n} else if (exp < DOUBLE_Emin + EXTENDED_Ebias) {\r\nif ((m64 == 0) && (l64 == 0)) {\r\nreg_copy(&CONST_Z, loaded_data);\r\nexp = 0;\r\ntag = TAG_Zero;\r\n} else {\r\nloaded_data->sigh = m64 << 11;\r\nloaded_data->sigh |= l64 >> 21;\r\nloaded_data->sigl = l64 << 11;\r\nreturn normalize_no_excep(loaded_data, DOUBLE_Emin,\r\nnegative)\r\n| (denormal_operand() < 0 ? FPU_Exception : 0);\r\n}\r\n} else {\r\nloaded_data->sigh = (m64 << 11) | 0x80000000;\r\nloaded_data->sigh |= l64 >> 21;\r\nloaded_data->sigl = l64 << 11;\r\ntag = TAG_Valid;\r\n}\r\nsetexponent16(loaded_data, exp | negative);\r\nreturn tag;\r\n}\r\nint FPU_load_single(float __user *single, FPU_REG *loaded_data)\r\n{\r\nunsigned m32;\r\nint exp, tag, negative;\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_READ, single, 4);\r\nFPU_get_user(m32, (unsigned long __user *)single);\r\nRE_ENTRANT_CHECK_ON;\r\nnegative = (m32 & 0x80000000) ? SIGN_Negative : SIGN_Positive;\r\nif (!(m32 & 0x7fffffff)) {\r\nreg_copy(&CONST_Z, loaded_data);\r\naddexponent(loaded_data, negative);\r\nreturn TAG_Zero;\r\n}\r\nexp = ((m32 & 0x7f800000) >> 23) - SINGLE_Ebias + EXTENDED_Ebias;\r\nm32 = (m32 & 0x7fffff) << 8;\r\nif (exp < SINGLE_Emin + EXTENDED_Ebias) {\r\nloaded_data->sigh = m32;\r\nloaded_data->sigl = 0;\r\nreturn normalize_no_excep(loaded_data, SINGLE_Emin, negative)\r\n| (denormal_operand() < 0 ? FPU_Exception : 0);\r\n} else if (exp > SINGLE_Emax + EXTENDED_Ebias) {\r\nif (m32 == 0) {\r\nloaded_data->sigh = 0x80000000;\r\nloaded_data->sigl = 0x00000000;\r\nexp = EXP_Infinity + EXTENDED_Ebias;\r\ntag = TAG_Special;\r\n} else {\r\nexp = EXP_NaN + EXTENDED_Ebias;\r\nloaded_data->sigh = m32 | 0x80000000;\r\nloaded_data->sigl = 0;\r\ntag = TAG_Special;\r\n}\r\n} else {\r\nloaded_data->sigh = m32 | 0x80000000;\r\nloaded_data->sigl = 0;\r\ntag = TAG_Valid;\r\n}\r\nsetexponent16(loaded_data, exp | negative);\r\nreturn tag;\r\n}\r\nint FPU_load_int64(long long __user *_s)\r\n{\r\nlong long s;\r\nint sign;\r\nFPU_REG *st0_ptr = &st(0);\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_READ, _s, 8);\r\nif (copy_from_user(&s, _s, 8))\r\nFPU_abort;\r\nRE_ENTRANT_CHECK_ON;\r\nif (s == 0) {\r\nreg_copy(&CONST_Z, st0_ptr);\r\nreturn TAG_Zero;\r\n}\r\nif (s > 0)\r\nsign = SIGN_Positive;\r\nelse {\r\ns = -s;\r\nsign = SIGN_Negative;\r\n}\r\nsignificand(st0_ptr) = s;\r\nreturn normalize_no_excep(st0_ptr, 63, sign);\r\n}\r\nint FPU_load_int32(long __user *_s, FPU_REG *loaded_data)\r\n{\r\nlong s;\r\nint negative;\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_READ, _s, 4);\r\nFPU_get_user(s, _s);\r\nRE_ENTRANT_CHECK_ON;\r\nif (s == 0) {\r\nreg_copy(&CONST_Z, loaded_data);\r\nreturn TAG_Zero;\r\n}\r\nif (s > 0)\r\nnegative = SIGN_Positive;\r\nelse {\r\ns = -s;\r\nnegative = SIGN_Negative;\r\n}\r\nloaded_data->sigh = s;\r\nloaded_data->sigl = 0;\r\nreturn normalize_no_excep(loaded_data, 31, negative);\r\n}\r\nint FPU_load_int16(short __user *_s, FPU_REG *loaded_data)\r\n{\r\nint s, negative;\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_READ, _s, 2);\r\nFPU_get_user(s, _s);\r\nRE_ENTRANT_CHECK_ON;\r\nif (s == 0) {\r\nreg_copy(&CONST_Z, loaded_data);\r\nreturn TAG_Zero;\r\n}\r\nif (s > 0)\r\nnegative = SIGN_Positive;\r\nelse {\r\ns = -s;\r\nnegative = SIGN_Negative;\r\n}\r\nloaded_data->sigh = s << 16;\r\nloaded_data->sigl = 0;\r\nreturn normalize_no_excep(loaded_data, 15, negative);\r\n}\r\nint FPU_load_bcd(u_char __user *s)\r\n{\r\nFPU_REG *st0_ptr = &st(0);\r\nint pos;\r\nu_char bcd;\r\nlong long l = 0;\r\nint sign;\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_READ, s, 10);\r\nRE_ENTRANT_CHECK_ON;\r\nfor (pos = 8; pos >= 0; pos--) {\r\nl *= 10;\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_get_user(bcd, s + pos);\r\nRE_ENTRANT_CHECK_ON;\r\nl += bcd >> 4;\r\nl *= 10;\r\nl += bcd & 0x0f;\r\n}\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_get_user(sign, s + 9);\r\nsign = sign & 0x80 ? SIGN_Negative : SIGN_Positive;\r\nRE_ENTRANT_CHECK_ON;\r\nif (l == 0) {\r\nreg_copy(&CONST_Z, st0_ptr);\r\naddexponent(st0_ptr, sign);\r\nreturn TAG_Zero;\r\n} else {\r\nsignificand(st0_ptr) = l;\r\nreturn normalize_no_excep(st0_ptr, 63, sign);\r\n}\r\n}\r\nint FPU_store_extended(FPU_REG *st0_ptr, u_char st0_tag,\r\nlong double __user * d)\r\n{\r\nif (st0_tag != TAG_Empty) {\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_WRITE, d, 10);\r\nFPU_put_user(st0_ptr->sigl, (unsigned long __user *)d);\r\nFPU_put_user(st0_ptr->sigh,\r\n(unsigned long __user *)((u_char __user *) d + 4));\r\nFPU_put_user(exponent16(st0_ptr),\r\n(unsigned short __user *)((u_char __user *) d +\r\n8));\r\nRE_ENTRANT_CHECK_ON;\r\nreturn 1;\r\n}\r\nEXCEPTION(EX_StackUnder);\r\nif (control_word & CW_Invalid) {\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_WRITE, d, 10);\r\nFPU_put_user(0, (unsigned long __user *)d);\r\nFPU_put_user(0xc0000000, 1 + (unsigned long __user *)d);\r\nFPU_put_user(0xffff, 4 + (short __user *)d);\r\nRE_ENTRANT_CHECK_ON;\r\nreturn 1;\r\n} else\r\nreturn 0;\r\n}\r\nint FPU_store_double(FPU_REG *st0_ptr, u_char st0_tag, double __user *dfloat)\r\n{\r\nunsigned long l[2];\r\nunsigned long increment = 0;\r\nint precision_loss;\r\nint exp;\r\nFPU_REG tmp;\r\nl[0] = 0;\r\nl[1] = 0;\r\nif (st0_tag == TAG_Valid) {\r\nreg_copy(st0_ptr, &tmp);\r\nexp = exponent(&tmp);\r\nif (exp < DOUBLE_Emin) {\r\naddexponent(&tmp, -DOUBLE_Emin + 52);\r\ndenormal_arg:\r\nif ((precision_loss = FPU_round_to_int(&tmp, st0_tag))) {\r\n#ifdef PECULIAR_486\r\nif (!\r\n((tmp.sigh == 0x00100000) && (tmp.sigl == 0)\r\n&& (st0_ptr->sigl & 0x000007ff)))\r\n#endif\r\n{\r\nEXCEPTION(EX_Underflow);\r\nif (!(control_word & CW_Underflow))\r\nreturn 0;\r\n}\r\nEXCEPTION(precision_loss);\r\nif (!(control_word & CW_Precision))\r\nreturn 0;\r\n}\r\nl[0] = tmp.sigl;\r\nl[1] = tmp.sigh;\r\n} else {\r\nif (tmp.sigl & 0x000007ff) {\r\nprecision_loss = 1;\r\nswitch (control_word & CW_RC) {\r\ncase RC_RND:\r\nincrement = ((tmp.sigl & 0x7ff) > 0x400) |\r\n((tmp.sigl & 0xc00) == 0xc00);\r\nbreak;\r\ncase RC_DOWN:\r\nincrement =\r\nsignpositive(&tmp) ? 0 : tmp.\r\nsigl & 0x7ff;\r\nbreak;\r\ncase RC_UP:\r\nincrement =\r\nsignpositive(&tmp) ? tmp.\r\nsigl & 0x7ff : 0;\r\nbreak;\r\ncase RC_CHOP:\r\nincrement = 0;\r\nbreak;\r\n}\r\ntmp.sigl &= 0xfffff800;\r\nif (increment) {\r\nif (tmp.sigl >= 0xfffff800) {\r\nif (tmp.sigh == 0xffffffff) {\r\ntmp.sigh = 0x80000000;\r\nexp++;\r\nif (exp >= EXP_OVER)\r\ngoto overflow;\r\n} else {\r\ntmp.sigh++;\r\n}\r\ntmp.sigl = 0x00000000;\r\n} else {\r\ntmp.sigl += 0x00000800;\r\n}\r\n}\r\n} else\r\nprecision_loss = 0;\r\nl[0] = (tmp.sigl >> 11) | (tmp.sigh << 21);\r\nl[1] = ((tmp.sigh >> 11) & 0xfffff);\r\nif (exp > DOUBLE_Emax) {\r\noverflow:\r\nEXCEPTION(EX_Overflow);\r\nif (!(control_word & CW_Overflow))\r\nreturn 0;\r\nset_precision_flag_up();\r\nif (!(control_word & CW_Precision))\r\nreturn 0;\r\nl[1] = 0x7ff00000;\r\n} else {\r\nif (precision_loss) {\r\nif (increment)\r\nset_precision_flag_up();\r\nelse\r\nset_precision_flag_down();\r\n}\r\nl[1] |= (((exp + DOUBLE_Ebias) & 0x7ff) << 20);\r\n}\r\n}\r\n} else if (st0_tag == TAG_Zero) {\r\n} else if (st0_tag == TAG_Special) {\r\nst0_tag = FPU_Special(st0_ptr);\r\nif (st0_tag == TW_Denormal) {\r\n#ifndef PECULIAR_486\r\nif (control_word & CW_Underflow)\r\ndenormal_operand();\r\n#endif\r\nreg_copy(st0_ptr, &tmp);\r\ngoto denormal_arg;\r\n} else if (st0_tag == TW_Infinity) {\r\nl[1] = 0x7ff00000;\r\n} else if (st0_tag == TW_NaN) {\r\nif ((exponent(st0_ptr) == EXP_OVER)\r\n&& (st0_ptr->sigh & 0x80000000)) {\r\nl[0] =\r\n(st0_ptr->sigl >> 11) | (st0_ptr->\r\nsigh << 21);\r\nl[1] = ((st0_ptr->sigh >> 11) & 0xfffff);\r\nif (!(st0_ptr->sigh & 0x40000000)) {\r\nEXCEPTION(EX_Invalid);\r\nif (!(control_word & CW_Invalid))\r\nreturn 0;\r\nl[1] |= (0x40000000 >> 11);\r\n}\r\nl[1] |= 0x7ff00000;\r\n} else {\r\nEXCEPTION(EX_Invalid);\r\nif (!(control_word & CW_Invalid))\r\nreturn 0;\r\nl[1] = 0xfff80000;\r\n}\r\n}\r\n} else if (st0_tag == TAG_Empty) {\r\nEXCEPTION(EX_StackUnder);\r\nif (control_word & CW_Invalid) {\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_WRITE, dfloat, 8);\r\nFPU_put_user(0, (unsigned long __user *)dfloat);\r\nFPU_put_user(0xfff80000,\r\n1 + (unsigned long __user *)dfloat);\r\nRE_ENTRANT_CHECK_ON;\r\nreturn 1;\r\n} else\r\nreturn 0;\r\n}\r\nif (getsign(st0_ptr))\r\nl[1] |= 0x80000000;\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_WRITE, dfloat, 8);\r\nFPU_put_user(l[0], (unsigned long __user *)dfloat);\r\nFPU_put_user(l[1], 1 + (unsigned long __user *)dfloat);\r\nRE_ENTRANT_CHECK_ON;\r\nreturn 1;\r\n}\r\nint FPU_store_single(FPU_REG *st0_ptr, u_char st0_tag, float __user *single)\r\n{\r\nlong templ = 0;\r\nunsigned long increment = 0;\r\nint precision_loss;\r\nint exp;\r\nFPU_REG tmp;\r\nif (st0_tag == TAG_Valid) {\r\nreg_copy(st0_ptr, &tmp);\r\nexp = exponent(&tmp);\r\nif (exp < SINGLE_Emin) {\r\naddexponent(&tmp, -SINGLE_Emin + 23);\r\ndenormal_arg:\r\nif ((precision_loss = FPU_round_to_int(&tmp, st0_tag))) {\r\n#ifdef PECULIAR_486\r\nif (!((tmp.sigl == 0x00800000) &&\r\n((st0_ptr->sigh & 0x000000ff)\r\n|| st0_ptr->sigl)))\r\n#endif\r\n{\r\nEXCEPTION(EX_Underflow);\r\nif (!(control_word & CW_Underflow))\r\nreturn 0;\r\n}\r\nEXCEPTION(precision_loss);\r\nif (!(control_word & CW_Precision))\r\nreturn 0;\r\n}\r\ntempl = tmp.sigl;\r\n} else {\r\nif (tmp.sigl | (tmp.sigh & 0x000000ff)) {\r\nunsigned long sigh = tmp.sigh;\r\nunsigned long sigl = tmp.sigl;\r\nprecision_loss = 1;\r\nswitch (control_word & CW_RC) {\r\ncase RC_RND:\r\nincrement = ((sigh & 0xff) > 0x80)\r\n||(((sigh & 0xff) == 0x80) && sigl)\r\n||((sigh & 0x180) == 0x180);\r\nbreak;\r\ncase RC_DOWN:\r\nincrement = signpositive(&tmp)\r\n? 0 : (sigl | (sigh & 0xff));\r\nbreak;\r\ncase RC_UP:\r\nincrement = signpositive(&tmp)\r\n? (sigl | (sigh & 0xff)) : 0;\r\nbreak;\r\ncase RC_CHOP:\r\nincrement = 0;\r\nbreak;\r\n}\r\ntmp.sigl = 0;\r\nif (increment) {\r\nif (sigh >= 0xffffff00) {\r\ntmp.sigh = 0x80000000;\r\nexp++;\r\nif (exp >= EXP_OVER)\r\ngoto overflow;\r\n} else {\r\ntmp.sigh &= 0xffffff00;\r\ntmp.sigh += 0x100;\r\n}\r\n} else {\r\ntmp.sigh &= 0xffffff00;\r\n}\r\n} else\r\nprecision_loss = 0;\r\ntempl = (tmp.sigh >> 8) & 0x007fffff;\r\nif (exp > SINGLE_Emax) {\r\noverflow:\r\nEXCEPTION(EX_Overflow);\r\nif (!(control_word & CW_Overflow))\r\nreturn 0;\r\nset_precision_flag_up();\r\nif (!(control_word & CW_Precision))\r\nreturn 0;\r\ntempl = 0x7f800000;\r\n} else {\r\nif (precision_loss) {\r\nif (increment)\r\nset_precision_flag_up();\r\nelse\r\nset_precision_flag_down();\r\n}\r\ntempl |= ((exp + SINGLE_Ebias) & 0xff) << 23;\r\n}\r\n}\r\n} else if (st0_tag == TAG_Zero) {\r\ntempl = 0;\r\n} else if (st0_tag == TAG_Special) {\r\nst0_tag = FPU_Special(st0_ptr);\r\nif (st0_tag == TW_Denormal) {\r\nreg_copy(st0_ptr, &tmp);\r\n#ifndef PECULIAR_486\r\nif (control_word & CW_Underflow)\r\ndenormal_operand();\r\n#endif\r\ngoto denormal_arg;\r\n} else if (st0_tag == TW_Infinity) {\r\ntempl = 0x7f800000;\r\n} else if (st0_tag == TW_NaN) {\r\nif ((exponent(st0_ptr) == EXP_OVER)\r\n&& (st0_ptr->sigh & 0x80000000)) {\r\ntempl = st0_ptr->sigh >> 8;\r\nif (!(st0_ptr->sigh & 0x40000000)) {\r\nEXCEPTION(EX_Invalid);\r\nif (!(control_word & CW_Invalid))\r\nreturn 0;\r\ntempl |= (0x40000000 >> 8);\r\n}\r\ntempl |= 0x7f800000;\r\n} else {\r\nEXCEPTION(EX_Invalid);\r\nif (!(control_word & CW_Invalid))\r\nreturn 0;\r\ntempl = 0xffc00000;\r\n}\r\n}\r\n#ifdef PARANOID\r\nelse {\r\nEXCEPTION(EX_INTERNAL | 0x164);\r\nreturn 0;\r\n}\r\n#endif\r\n} else if (st0_tag == TAG_Empty) {\r\nEXCEPTION(EX_StackUnder);\r\nif (control_word & EX_Invalid) {\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_WRITE, single, 4);\r\nFPU_put_user(0xffc00000,\r\n(unsigned long __user *)single);\r\nRE_ENTRANT_CHECK_ON;\r\nreturn 1;\r\n} else\r\nreturn 0;\r\n}\r\n#ifdef PARANOID\r\nelse {\r\nEXCEPTION(EX_INTERNAL | 0x163);\r\nreturn 0;\r\n}\r\n#endif\r\nif (getsign(st0_ptr))\r\ntempl |= 0x80000000;\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_WRITE, single, 4);\r\nFPU_put_user(templ, (unsigned long __user *)single);\r\nRE_ENTRANT_CHECK_ON;\r\nreturn 1;\r\n}\r\nint FPU_store_int64(FPU_REG *st0_ptr, u_char st0_tag, long long __user *d)\r\n{\r\nFPU_REG t;\r\nlong long tll;\r\nint precision_loss;\r\nif (st0_tag == TAG_Empty) {\r\nEXCEPTION(EX_StackUnder);\r\ngoto invalid_operand;\r\n} else if (st0_tag == TAG_Special) {\r\nst0_tag = FPU_Special(st0_ptr);\r\nif ((st0_tag == TW_Infinity) || (st0_tag == TW_NaN)) {\r\nEXCEPTION(EX_Invalid);\r\ngoto invalid_operand;\r\n}\r\n}\r\nreg_copy(st0_ptr, &t);\r\nprecision_loss = FPU_round_to_int(&t, st0_tag);\r\n((long *)&tll)[0] = t.sigl;\r\n((long *)&tll)[1] = t.sigh;\r\nif ((precision_loss == 1) ||\r\n((t.sigh & 0x80000000) &&\r\n!((t.sigh == 0x80000000) && (t.sigl == 0) && signnegative(&t)))) {\r\nEXCEPTION(EX_Invalid);\r\ninvalid_operand:\r\nif (control_word & EX_Invalid) {\r\ntll = 0x8000000000000000LL;\r\n} else\r\nreturn 0;\r\n} else {\r\nif (precision_loss)\r\nset_precision_flag(precision_loss);\r\nif (signnegative(&t))\r\ntll = -tll;\r\n}\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_WRITE, d, 8);\r\nif (copy_to_user(d, &tll, 8))\r\nFPU_abort;\r\nRE_ENTRANT_CHECK_ON;\r\nreturn 1;\r\n}\r\nint FPU_store_int32(FPU_REG *st0_ptr, u_char st0_tag, long __user *d)\r\n{\r\nFPU_REG t;\r\nint precision_loss;\r\nif (st0_tag == TAG_Empty) {\r\nEXCEPTION(EX_StackUnder);\r\ngoto invalid_operand;\r\n} else if (st0_tag == TAG_Special) {\r\nst0_tag = FPU_Special(st0_ptr);\r\nif ((st0_tag == TW_Infinity) || (st0_tag == TW_NaN)) {\r\nEXCEPTION(EX_Invalid);\r\ngoto invalid_operand;\r\n}\r\n}\r\nreg_copy(st0_ptr, &t);\r\nprecision_loss = FPU_round_to_int(&t, st0_tag);\r\nif (t.sigh ||\r\n((t.sigl & 0x80000000) &&\r\n!((t.sigl == 0x80000000) && signnegative(&t)))) {\r\nEXCEPTION(EX_Invalid);\r\ninvalid_operand:\r\nif (control_word & EX_Invalid) {\r\nt.sigl = 0x80000000;\r\n} else\r\nreturn 0;\r\n} else {\r\nif (precision_loss)\r\nset_precision_flag(precision_loss);\r\nif (signnegative(&t))\r\nt.sigl = -(long)t.sigl;\r\n}\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_WRITE, d, 4);\r\nFPU_put_user(t.sigl, (unsigned long __user *)d);\r\nRE_ENTRANT_CHECK_ON;\r\nreturn 1;\r\n}\r\nint FPU_store_int16(FPU_REG *st0_ptr, u_char st0_tag, short __user *d)\r\n{\r\nFPU_REG t;\r\nint precision_loss;\r\nif (st0_tag == TAG_Empty) {\r\nEXCEPTION(EX_StackUnder);\r\ngoto invalid_operand;\r\n} else if (st0_tag == TAG_Special) {\r\nst0_tag = FPU_Special(st0_ptr);\r\nif ((st0_tag == TW_Infinity) || (st0_tag == TW_NaN)) {\r\nEXCEPTION(EX_Invalid);\r\ngoto invalid_operand;\r\n}\r\n}\r\nreg_copy(st0_ptr, &t);\r\nprecision_loss = FPU_round_to_int(&t, st0_tag);\r\nif (t.sigh ||\r\n((t.sigl & 0xffff8000) &&\r\n!((t.sigl == 0x8000) && signnegative(&t)))) {\r\nEXCEPTION(EX_Invalid);\r\ninvalid_operand:\r\nif (control_word & EX_Invalid) {\r\nt.sigl = 0x8000;\r\n} else\r\nreturn 0;\r\n} else {\r\nif (precision_loss)\r\nset_precision_flag(precision_loss);\r\nif (signnegative(&t))\r\nt.sigl = -t.sigl;\r\n}\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_WRITE, d, 2);\r\nFPU_put_user((short)t.sigl, d);\r\nRE_ENTRANT_CHECK_ON;\r\nreturn 1;\r\n}\r\nint FPU_store_bcd(FPU_REG *st0_ptr, u_char st0_tag, u_char __user *d)\r\n{\r\nFPU_REG t;\r\nunsigned long long ll;\r\nu_char b;\r\nint i, precision_loss;\r\nu_char sign = (getsign(st0_ptr) == SIGN_NEG) ? 0x80 : 0;\r\nif (st0_tag == TAG_Empty) {\r\nEXCEPTION(EX_StackUnder);\r\ngoto invalid_operand;\r\n} else if (st0_tag == TAG_Special) {\r\nst0_tag = FPU_Special(st0_ptr);\r\nif ((st0_tag == TW_Infinity) || (st0_tag == TW_NaN)) {\r\nEXCEPTION(EX_Invalid);\r\ngoto invalid_operand;\r\n}\r\n}\r\nreg_copy(st0_ptr, &t);\r\nprecision_loss = FPU_round_to_int(&t, st0_tag);\r\nll = significand(&t);\r\nif ((t.sigh > 0x0de0b6b3) ||\r\n((t.sigh == 0x0de0b6b3) && (t.sigl > 0xa763ffff))) {\r\nEXCEPTION(EX_Invalid);\r\ninvalid_operand:\r\nif (control_word & CW_Invalid) {\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_WRITE, d, 10);\r\nfor (i = 0; i < 7; i++)\r\nFPU_put_user(0, d + i);\r\nFPU_put_user(0xc0, d + 7);\r\nFPU_put_user(0xff, d + 8);\r\nFPU_put_user(0xff, d + 9);\r\nRE_ENTRANT_CHECK_ON;\r\nreturn 1;\r\n} else\r\nreturn 0;\r\n} else if (precision_loss) {\r\nset_precision_flag(precision_loss);\r\n}\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_WRITE, d, 10);\r\nRE_ENTRANT_CHECK_ON;\r\nfor (i = 0; i < 9; i++) {\r\nb = FPU_div_small(&ll, 10);\r\nb |= (FPU_div_small(&ll, 10)) << 4;\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_put_user(b, d + i);\r\nRE_ENTRANT_CHECK_ON;\r\n}\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_put_user(sign, d + 9);\r\nRE_ENTRANT_CHECK_ON;\r\nreturn 1;\r\n}\r\nint FPU_round_to_int(FPU_REG *r, u_char tag)\r\n{\r\nu_char very_big;\r\nunsigned eax;\r\nif (tag == TAG_Zero) {\r\nsignificand(r) = 0;\r\nreturn 0;\r\n}\r\nif (exponent(r) > 63) {\r\nr->sigl = r->sigh = ~0;\r\nreturn 1;\r\n}\r\neax = FPU_shrxs(&r->sigl, 63 - exponent(r));\r\nvery_big = !(~(r->sigh) | ~(r->sigl));\r\n#define half_or_more (eax & 0x80000000)\r\n#define frac_part (eax)\r\n#define more_than_half ((eax & 0x80000001) == 0x80000001)\r\nswitch (control_word & CW_RC) {\r\ncase RC_RND:\r\nif (more_than_half\r\n|| (half_or_more && (r->sigl & 1))) {\r\nif (very_big)\r\nreturn 1;\r\nsignificand(r)++;\r\nreturn PRECISION_LOST_UP;\r\n}\r\nbreak;\r\ncase RC_DOWN:\r\nif (frac_part && getsign(r)) {\r\nif (very_big)\r\nreturn 1;\r\nsignificand(r)++;\r\nreturn PRECISION_LOST_UP;\r\n}\r\nbreak;\r\ncase RC_UP:\r\nif (frac_part && !getsign(r)) {\r\nif (very_big)\r\nreturn 1;\r\nsignificand(r)++;\r\nreturn PRECISION_LOST_UP;\r\n}\r\nbreak;\r\ncase RC_CHOP:\r\nbreak;\r\n}\r\nreturn eax ? PRECISION_LOST_DOWN : 0;\r\n}\r\nu_char __user *fldenv(fpu_addr_modes addr_modes, u_char __user *s)\r\n{\r\nunsigned short tag_word = 0;\r\nu_char tag;\r\nint i;\r\nif ((addr_modes.default_mode == VM86) ||\r\n((addr_modes.default_mode == PM16)\r\n^ (addr_modes.override.operand_size == OP_SIZE_PREFIX))) {\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_READ, s, 0x0e);\r\nFPU_get_user(control_word, (unsigned short __user *)s);\r\nFPU_get_user(partial_status, (unsigned short __user *)(s + 2));\r\nFPU_get_user(tag_word, (unsigned short __user *)(s + 4));\r\nFPU_get_user(instruction_address.offset,\r\n(unsigned short __user *)(s + 6));\r\nFPU_get_user(instruction_address.selector,\r\n(unsigned short __user *)(s + 8));\r\nFPU_get_user(operand_address.offset,\r\n(unsigned short __user *)(s + 0x0a));\r\nFPU_get_user(operand_address.selector,\r\n(unsigned short __user *)(s + 0x0c));\r\nRE_ENTRANT_CHECK_ON;\r\ns += 0x0e;\r\nif (addr_modes.default_mode == VM86) {\r\ninstruction_address.offset\r\n+= (instruction_address.selector & 0xf000) << 4;\r\noperand_address.offset +=\r\n(operand_address.selector & 0xf000) << 4;\r\n}\r\n} else {\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_READ, s, 0x1c);\r\nFPU_get_user(control_word, (unsigned short __user *)s);\r\nFPU_get_user(partial_status, (unsigned short __user *)(s + 4));\r\nFPU_get_user(tag_word, (unsigned short __user *)(s + 8));\r\nFPU_get_user(instruction_address.offset,\r\n(unsigned long __user *)(s + 0x0c));\r\nFPU_get_user(instruction_address.selector,\r\n(unsigned short __user *)(s + 0x10));\r\nFPU_get_user(instruction_address.opcode,\r\n(unsigned short __user *)(s + 0x12));\r\nFPU_get_user(operand_address.offset,\r\n(unsigned long __user *)(s + 0x14));\r\nFPU_get_user(operand_address.selector,\r\n(unsigned long __user *)(s + 0x18));\r\nRE_ENTRANT_CHECK_ON;\r\ns += 0x1c;\r\n}\r\n#ifdef PECULIAR_486\r\ncontrol_word &= ~0xe080;\r\n#endif\r\ntop = (partial_status >> SW_Top_Shift) & 7;\r\nif (partial_status & ~control_word & CW_Exceptions)\r\npartial_status |= (SW_Summary | SW_Backward);\r\nelse\r\npartial_status &= ~(SW_Summary | SW_Backward);\r\nfor (i = 0; i < 8; i++) {\r\ntag = tag_word & 3;\r\ntag_word >>= 2;\r\nif (tag == TAG_Empty)\r\nFPU_settag(i, TAG_Empty);\r\nelse if (FPU_gettag(i) == TAG_Empty) {\r\nif (exponent(&fpu_register(i)) == -EXTENDED_Ebias) {\r\nif (!\r\n(fpu_register(i).sigl | fpu_register(i).\r\nsigh))\r\nFPU_settag(i, TAG_Zero);\r\nelse\r\nFPU_settag(i, TAG_Special);\r\n} else if (exponent(&fpu_register(i)) ==\r\n0x7fff - EXTENDED_Ebias) {\r\nFPU_settag(i, TAG_Special);\r\n} else if (fpu_register(i).sigh & 0x80000000)\r\nFPU_settag(i, TAG_Valid);\r\nelse\r\nFPU_settag(i, TAG_Special);\r\n}\r\n}\r\nreturn s;\r\n}\r\nvoid frstor(fpu_addr_modes addr_modes, u_char __user *data_address)\r\n{\r\nint i, regnr;\r\nu_char __user *s = fldenv(addr_modes, data_address);\r\nint offset = (top & 7) * 10, other = 80 - offset;\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_READ, s, 80);\r\n__copy_from_user(register_base + offset, s, other);\r\nif (offset)\r\n__copy_from_user(register_base, s + other, offset);\r\nRE_ENTRANT_CHECK_ON;\r\nfor (i = 0; i < 8; i++) {\r\nregnr = (i + top) & 7;\r\nif (FPU_gettag(regnr) != TAG_Empty)\r\nFPU_settag(regnr, FPU_tagof(&st(i)));\r\n}\r\n}\r\nu_char __user *fstenv(fpu_addr_modes addr_modes, u_char __user *d)\r\n{\r\nif ((addr_modes.default_mode == VM86) ||\r\n((addr_modes.default_mode == PM16)\r\n^ (addr_modes.override.operand_size == OP_SIZE_PREFIX))) {\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_WRITE, d, 14);\r\n#ifdef PECULIAR_486\r\nFPU_put_user(control_word & ~0xe080, (unsigned long __user *)d);\r\n#else\r\nFPU_put_user(control_word, (unsigned short __user *)d);\r\n#endif\r\nFPU_put_user(status_word(), (unsigned short __user *)(d + 2));\r\nFPU_put_user(fpu_tag_word, (unsigned short __user *)(d + 4));\r\nFPU_put_user(instruction_address.offset,\r\n(unsigned short __user *)(d + 6));\r\nFPU_put_user(operand_address.offset,\r\n(unsigned short __user *)(d + 0x0a));\r\nif (addr_modes.default_mode == VM86) {\r\nFPU_put_user((instruction_address.\r\noffset & 0xf0000) >> 4,\r\n(unsigned short __user *)(d + 8));\r\nFPU_put_user((operand_address.offset & 0xf0000) >> 4,\r\n(unsigned short __user *)(d + 0x0c));\r\n} else {\r\nFPU_put_user(instruction_address.selector,\r\n(unsigned short __user *)(d + 8));\r\nFPU_put_user(operand_address.selector,\r\n(unsigned short __user *)(d + 0x0c));\r\n}\r\nRE_ENTRANT_CHECK_ON;\r\nd += 0x0e;\r\n} else {\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_WRITE, d, 7 * 4);\r\n#ifdef PECULIAR_486\r\ncontrol_word &= ~0xe080;\r\ncontrol_word |= 0xffff0040;\r\npartial_status = status_word() | 0xffff0000;\r\nfpu_tag_word |= 0xffff0000;\r\nI387->soft.fcs &= ~0xf8000000;\r\nI387->soft.fos |= 0xffff0000;\r\n#endif\r\nif (__copy_to_user(d, &control_word, 7 * 4))\r\nFPU_abort;\r\nRE_ENTRANT_CHECK_ON;\r\nd += 0x1c;\r\n}\r\ncontrol_word |= CW_Exceptions;\r\npartial_status &= ~(SW_Summary | SW_Backward);\r\nreturn d;\r\n}\r\nvoid fsave(fpu_addr_modes addr_modes, u_char __user *data_address)\r\n{\r\nu_char __user *d;\r\nint offset = (top & 7) * 10, other = 80 - offset;\r\nd = fstenv(addr_modes, data_address);\r\nRE_ENTRANT_CHECK_OFF;\r\nFPU_access_ok(VERIFY_WRITE, d, 80);\r\nif (__copy_to_user(d, register_base + offset, other))\r\nFPU_abort;\r\nif (offset)\r\nif (__copy_to_user(d + other, register_base, offset))\r\nFPU_abort;\r\nRE_ENTRANT_CHECK_ON;\r\nfinit();\r\n}
