static int ds1343_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\n#ifdef RTC_SET_CHARGE\r\ncase RTC_SET_CHARGE:\r\n{\r\nint val;\r\nif (copy_from_user(&val, (int __user *)arg, sizeof(int)))\r\nreturn -EFAULT;\r\nreturn regmap_write(priv->map, DS1343_TRICKLE_REG, val);\r\n}\r\nbreak;\r\n#endif\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic ssize_t ds1343_show_glitchfilter(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ds1343_priv *priv = dev_get_drvdata(dev);\r\nint glitch_filt_status, data;\r\nregmap_read(priv->map, DS1343_CONTROL_REG, &data);\r\nglitch_filt_status = !!(data & DS1343_EGFIL);\r\nif (glitch_filt_status)\r\nreturn sprintf(buf, "enabled\n");\r\nelse\r\nreturn sprintf(buf, "disabled\n");\r\n}\r\nstatic ssize_t ds1343_store_glitchfilter(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ds1343_priv *priv = dev_get_drvdata(dev);\r\nint data;\r\nregmap_read(priv->map, DS1343_CONTROL_REG, &data);\r\nif (strncmp(buf, "enabled", 7) == 0)\r\ndata |= DS1343_EGFIL;\r\nelse if (strncmp(buf, "disabled", 8) == 0)\r\ndata &= ~(DS1343_EGFIL);\r\nelse\r\nreturn -EINVAL;\r\nregmap_write(priv->map, DS1343_CONTROL_REG, data);\r\nreturn count;\r\n}\r\nstatic ssize_t ds1343_nvram_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nint ret;\r\nunsigned char address;\r\nstruct device *dev = kobj_to_dev(kobj);\r\nstruct ds1343_priv *priv = dev_get_drvdata(dev);\r\nif (unlikely(!count))\r\nreturn count;\r\nif ((count + off) > DS1343_NVRAM_LEN)\r\ncount = DS1343_NVRAM_LEN - off;\r\naddress = DS1343_NVRAM + off;\r\nret = regmap_bulk_write(priv->map, address, buf, count);\r\nif (ret < 0)\r\ndev_err(&priv->spi->dev, "Error in nvram write %d", ret);\r\nreturn (ret < 0) ? ret : count;\r\n}\r\nstatic ssize_t ds1343_nvram_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nint ret;\r\nunsigned char address;\r\nstruct device *dev = kobj_to_dev(kobj);\r\nstruct ds1343_priv *priv = dev_get_drvdata(dev);\r\nif (unlikely(!count))\r\nreturn count;\r\nif ((count + off) > DS1343_NVRAM_LEN)\r\ncount = DS1343_NVRAM_LEN - off;\r\naddress = DS1343_NVRAM + off;\r\nret = regmap_bulk_read(priv->map, address, buf, count);\r\nif (ret < 0)\r\ndev_err(&priv->spi->dev, "Error in nvram read %d\n", ret);\r\nreturn (ret < 0) ? ret : count;\r\n}\r\nstatic ssize_t ds1343_show_alarmstatus(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ds1343_priv *priv = dev_get_drvdata(dev);\r\nint alarmstatus, data;\r\nregmap_read(priv->map, DS1343_CONTROL_REG, &data);\r\nalarmstatus = !!(data & DS1343_A0IE);\r\nif (alarmstatus)\r\nreturn sprintf(buf, "enabled\n");\r\nelse\r\nreturn sprintf(buf, "disabled\n");\r\n}\r\nstatic ssize_t ds1343_show_alarmmode(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ds1343_priv *priv = dev_get_drvdata(dev);\r\nint alarm_mode, data;\r\nchar *alarm_str;\r\nregmap_read(priv->map, DS1343_ALM0_SEC_REG, &data);\r\nalarm_mode = (data & 0x80) >> 4;\r\nregmap_read(priv->map, DS1343_ALM0_MIN_REG, &data);\r\nalarm_mode |= (data & 0x80) >> 5;\r\nregmap_read(priv->map, DS1343_ALM0_HOUR_REG, &data);\r\nalarm_mode |= (data & 0x80) >> 6;\r\nregmap_read(priv->map, DS1343_ALM0_DAY_REG, &data);\r\nalarm_mode |= (data & 0x80) >> 7;\r\nswitch (alarm_mode) {\r\ncase 15:\r\nalarm_str = "each second";\r\nbreak;\r\ncase 7:\r\nalarm_str = "seconds match";\r\nbreak;\r\ncase 3:\r\nalarm_str = "minutes and seconds match";\r\nbreak;\r\ncase 1:\r\nalarm_str = "hours, minutes and seconds match";\r\nbreak;\r\ncase 0:\r\nalarm_str = "day, hours, minutes and seconds match";\r\nbreak;\r\ndefault:\r\nalarm_str = "invalid";\r\nbreak;\r\n}\r\nreturn sprintf(buf, "%s\n", alarm_str);\r\n}\r\nstatic ssize_t ds1343_show_tricklecharger(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ds1343_priv *priv = dev_get_drvdata(dev);\r\nint data;\r\nchar *diodes = "disabled", *resistors = " ";\r\nregmap_read(priv->map, DS1343_TRICKLE_REG, &data);\r\nif ((data & 0xf0) == DS1343_TRICKLE_MAGIC) {\r\nswitch (data & 0x0c) {\r\ncase DS1343_TRICKLE_DS1:\r\ndiodes = "one diode,";\r\nbreak;\r\ndefault:\r\ndiodes = "no diode,";\r\nbreak;\r\n}\r\nswitch (data & 0x03) {\r\ncase DS1343_TRICKLE_1K:\r\nresistors = "1k Ohm";\r\nbreak;\r\ncase DS1343_TRICKLE_2K:\r\nresistors = "2k Ohm";\r\nbreak;\r\ncase DS1343_TRICKLE_4K:\r\nresistors = "4k Ohm";\r\nbreak;\r\ndefault:\r\ndiodes = "disabled";\r\nbreak;\r\n}\r\n}\r\nreturn sprintf(buf, "%s %s\n", diodes, resistors);\r\n}\r\nstatic int ds1343_sysfs_register(struct device *dev)\r\n{\r\nstruct ds1343_priv *priv = dev_get_drvdata(dev);\r\nint err;\r\nerr = device_create_file(dev, &dev_attr_glitch_filter);\r\nif (err)\r\nreturn err;\r\nerr = device_create_file(dev, &dev_attr_trickle_charger);\r\nif (err)\r\ngoto error1;\r\nerr = device_create_bin_file(dev, &nvram_attr);\r\nif (err)\r\ngoto error2;\r\nif (priv->irq <= 0)\r\nreturn err;\r\nerr = device_create_file(dev, &dev_attr_alarm_mode);\r\nif (err)\r\ngoto error3;\r\nerr = device_create_file(dev, &dev_attr_alarm_status);\r\nif (!err)\r\nreturn err;\r\ndevice_remove_file(dev, &dev_attr_alarm_mode);\r\nerror3:\r\ndevice_remove_bin_file(dev, &nvram_attr);\r\nerror2:\r\ndevice_remove_file(dev, &dev_attr_trickle_charger);\r\nerror1:\r\ndevice_remove_file(dev, &dev_attr_glitch_filter);\r\nreturn err;\r\n}\r\nstatic void ds1343_sysfs_unregister(struct device *dev)\r\n{\r\nstruct ds1343_priv *priv = dev_get_drvdata(dev);\r\ndevice_remove_file(dev, &dev_attr_glitch_filter);\r\ndevice_remove_file(dev, &dev_attr_trickle_charger);\r\ndevice_remove_bin_file(dev, &nvram_attr);\r\nif (priv->irq <= 0)\r\nreturn;\r\ndevice_remove_file(dev, &dev_attr_alarm_status);\r\ndevice_remove_file(dev, &dev_attr_alarm_mode);\r\n}\r\nstatic int ds1343_read_time(struct device *dev, struct rtc_time *dt)\r\n{\r\nstruct ds1343_priv *priv = dev_get_drvdata(dev);\r\nunsigned char buf[7];\r\nint res;\r\nres = regmap_bulk_read(priv->map, DS1343_SECONDS_REG, buf, 7);\r\nif (res)\r\nreturn res;\r\ndt->tm_sec = bcd2bin(buf[0]);\r\ndt->tm_min = bcd2bin(buf[1]);\r\ndt->tm_hour = bcd2bin(buf[2] & 0x3F);\r\ndt->tm_wday = bcd2bin(buf[3]) - 1;\r\ndt->tm_mday = bcd2bin(buf[4]);\r\ndt->tm_mon = bcd2bin(buf[5] & 0x1F) - 1;\r\ndt->tm_year = bcd2bin(buf[6]) + 100;\r\nreturn rtc_valid_tm(dt);\r\n}\r\nstatic int ds1343_set_time(struct device *dev, struct rtc_time *dt)\r\n{\r\nstruct ds1343_priv *priv = dev_get_drvdata(dev);\r\nint res;\r\nres = regmap_write(priv->map, DS1343_SECONDS_REG,\r\nbin2bcd(dt->tm_sec));\r\nif (res)\r\nreturn res;\r\nres = regmap_write(priv->map, DS1343_MINUTES_REG,\r\nbin2bcd(dt->tm_min));\r\nif (res)\r\nreturn res;\r\nres = regmap_write(priv->map, DS1343_HOURS_REG,\r\nbin2bcd(dt->tm_hour) & 0x3F);\r\nif (res)\r\nreturn res;\r\nres = regmap_write(priv->map, DS1343_DAY_REG,\r\nbin2bcd(dt->tm_wday + 1));\r\nif (res)\r\nreturn res;\r\nres = regmap_write(priv->map, DS1343_DATE_REG,\r\nbin2bcd(dt->tm_mday));\r\nif (res)\r\nreturn res;\r\nres = regmap_write(priv->map, DS1343_MONTH_REG,\r\nbin2bcd(dt->tm_mon + 1));\r\nif (res)\r\nreturn res;\r\ndt->tm_year %= 100;\r\nres = regmap_write(priv->map, DS1343_YEAR_REG,\r\nbin2bcd(dt->tm_year));\r\nif (res)\r\nreturn res;\r\nreturn 0;\r\n}\r\nstatic int ds1343_update_alarm(struct device *dev)\r\n{\r\nstruct ds1343_priv *priv = dev_get_drvdata(dev);\r\nunsigned int control, stat;\r\nunsigned char buf[4];\r\nint res = 0;\r\nres = regmap_read(priv->map, DS1343_CONTROL_REG, &control);\r\nif (res)\r\nreturn res;\r\nres = regmap_read(priv->map, DS1343_STATUS_REG, &stat);\r\nif (res)\r\nreturn res;\r\ncontrol &= ~(DS1343_A0IE);\r\nstat &= ~(DS1343_IRQF0);\r\nres = regmap_write(priv->map, DS1343_CONTROL_REG, control);\r\nif (res)\r\nreturn res;\r\nres = regmap_write(priv->map, DS1343_STATUS_REG, stat);\r\nif (res)\r\nreturn res;\r\nbuf[0] = priv->alarm_sec < 0 || (priv->irqen & RTC_UF) ?\r\n0x80 : bin2bcd(priv->alarm_sec) & 0x7F;\r\nbuf[1] = priv->alarm_min < 0 || (priv->irqen & RTC_UF) ?\r\n0x80 : bin2bcd(priv->alarm_min) & 0x7F;\r\nbuf[2] = priv->alarm_hour < 0 || (priv->irqen & RTC_UF) ?\r\n0x80 : bin2bcd(priv->alarm_hour) & 0x3F;\r\nbuf[3] = priv->alarm_mday < 0 || (priv->irqen & RTC_UF) ?\r\n0x80 : bin2bcd(priv->alarm_mday) & 0x7F;\r\nres = regmap_bulk_write(priv->map, DS1343_ALM0_SEC_REG, buf, 4);\r\nif (res)\r\nreturn res;\r\nif (priv->irqen) {\r\ncontrol |= DS1343_A0IE;\r\nres = regmap_write(priv->map, DS1343_CONTROL_REG, control);\r\n}\r\nreturn res;\r\n}\r\nstatic int ds1343_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct ds1343_priv *priv = dev_get_drvdata(dev);\r\nint res = 0;\r\nunsigned int stat;\r\nif (priv->irq <= 0)\r\nreturn -EINVAL;\r\nmutex_lock(&priv->mutex);\r\nres = regmap_read(priv->map, DS1343_STATUS_REG, &stat);\r\nif (res)\r\ngoto out;\r\nalarm->enabled = !!(priv->irqen & RTC_AF);\r\nalarm->pending = !!(stat & DS1343_IRQF0);\r\nalarm->time.tm_sec = priv->alarm_sec < 0 ? 0 : priv->alarm_sec;\r\nalarm->time.tm_min = priv->alarm_min < 0 ? 0 : priv->alarm_min;\r\nalarm->time.tm_hour = priv->alarm_hour < 0 ? 0 : priv->alarm_hour;\r\nalarm->time.tm_mday = priv->alarm_mday < 0 ? 0 : priv->alarm_mday;\r\nalarm->time.tm_mon = -1;\r\nalarm->time.tm_year = -1;\r\nalarm->time.tm_wday = -1;\r\nalarm->time.tm_yday = -1;\r\nalarm->time.tm_isdst = -1;\r\nout:\r\nmutex_unlock(&priv->mutex);\r\nreturn res;\r\n}\r\nstatic int ds1343_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct ds1343_priv *priv = dev_get_drvdata(dev);\r\nint res = 0;\r\nif (priv->irq <= 0)\r\nreturn -EINVAL;\r\nmutex_lock(&priv->mutex);\r\npriv->alarm_sec = alarm->time.tm_sec;\r\npriv->alarm_min = alarm->time.tm_min;\r\npriv->alarm_hour = alarm->time.tm_hour;\r\npriv->alarm_mday = alarm->time.tm_mday;\r\nif (alarm->enabled)\r\npriv->irqen |= RTC_AF;\r\nres = ds1343_update_alarm(dev);\r\nmutex_unlock(&priv->mutex);\r\nreturn res;\r\n}\r\nstatic int ds1343_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct ds1343_priv *priv = dev_get_drvdata(dev);\r\nint res = 0;\r\nif (priv->irq <= 0)\r\nreturn -EINVAL;\r\nmutex_lock(&priv->mutex);\r\nif (enabled)\r\npriv->irqen |= RTC_AF;\r\nelse\r\npriv->irqen &= ~RTC_AF;\r\nres = ds1343_update_alarm(dev);\r\nmutex_unlock(&priv->mutex);\r\nreturn res;\r\n}\r\nstatic irqreturn_t ds1343_thread(int irq, void *dev_id)\r\n{\r\nstruct ds1343_priv *priv = dev_id;\r\nunsigned int stat, control;\r\nint res = 0;\r\nmutex_lock(&priv->mutex);\r\nres = regmap_read(priv->map, DS1343_STATUS_REG, &stat);\r\nif (res)\r\ngoto out;\r\nif (stat & DS1343_IRQF0) {\r\nstat &= ~DS1343_IRQF0;\r\nregmap_write(priv->map, DS1343_STATUS_REG, stat);\r\nres = regmap_read(priv->map, DS1343_CONTROL_REG, &control);\r\nif (res)\r\ngoto out;\r\ncontrol &= ~DS1343_A0IE;\r\nregmap_write(priv->map, DS1343_CONTROL_REG, control);\r\nrtc_update_irq(priv->rtc, 1, RTC_AF | RTC_IRQF);\r\n}\r\nout:\r\nmutex_unlock(&priv->mutex);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ds1343_probe(struct spi_device *spi)\r\n{\r\nstruct ds1343_priv *priv;\r\nstruct regmap_config config;\r\nunsigned int data;\r\nint res;\r\nmemset(&config, 0, sizeof(config));\r\nconfig.reg_bits = 8;\r\nconfig.val_bits = 8;\r\nconfig.write_flag_mask = 0x80;\r\npriv = devm_kzalloc(&spi->dev, sizeof(struct ds1343_priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->spi = spi;\r\nmutex_init(&priv->mutex);\r\nspi->mode = SPI_MODE_3 | SPI_CS_HIGH;\r\nspi->bits_per_word = 8;\r\nres = spi_setup(spi);\r\nif (res)\r\nreturn res;\r\nspi_set_drvdata(spi, priv);\r\npriv->map = devm_regmap_init_spi(spi, &config);\r\nif (IS_ERR(priv->map)) {\r\ndev_err(&spi->dev, "spi regmap init failed for rtc ds1343\n");\r\nreturn PTR_ERR(priv->map);\r\n}\r\nres = regmap_read(priv->map, DS1343_SECONDS_REG, &data);\r\nif (res)\r\nreturn res;\r\nregmap_read(priv->map, DS1343_CONTROL_REG, &data);\r\ndata |= DS1343_INTCN;\r\ndata &= ~(DS1343_EOSC | DS1343_A1IE | DS1343_A0IE);\r\nregmap_write(priv->map, DS1343_CONTROL_REG, data);\r\nregmap_read(priv->map, DS1343_STATUS_REG, &data);\r\ndata &= ~(DS1343_OSF | DS1343_IRQF1 | DS1343_IRQF0);\r\nregmap_write(priv->map, DS1343_STATUS_REG, data);\r\npriv->rtc = devm_rtc_device_register(&spi->dev, "ds1343",\r\n&ds1343_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(priv->rtc)) {\r\ndev_err(&spi->dev, "unable to register rtc ds1343\n");\r\nreturn PTR_ERR(priv->rtc);\r\n}\r\npriv->irq = spi->irq;\r\nif (priv->irq >= 0) {\r\nres = devm_request_threaded_irq(&spi->dev, spi->irq, NULL,\r\nds1343_thread,\r\nIRQF_NO_SUSPEND | IRQF_ONESHOT,\r\n"ds1343", priv);\r\nif (res) {\r\npriv->irq = -1;\r\ndev_err(&spi->dev,\r\n"unable to request irq for rtc ds1343\n");\r\n} else {\r\ndevice_set_wakeup_capable(&spi->dev, 1);\r\n}\r\n}\r\nres = ds1343_sysfs_register(&spi->dev);\r\nif (res)\r\ndev_err(&spi->dev,\r\n"unable to create sysfs entries for rtc ds1343\n");\r\nreturn 0;\r\n}\r\nstatic int ds1343_remove(struct spi_device *spi)\r\n{\r\nstruct ds1343_priv *priv = spi_get_drvdata(spi);\r\nif (spi->irq) {\r\nmutex_lock(&priv->mutex);\r\npriv->irqen &= ~RTC_AF;\r\nmutex_unlock(&priv->mutex);\r\ndevm_free_irq(&spi->dev, spi->irq, priv);\r\n}\r\nspi_set_drvdata(spi, NULL);\r\nds1343_sysfs_unregister(&spi->dev);\r\nreturn 0;\r\n}\r\nstatic int ds1343_suspend(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nif (spi->irq >= 0 && device_may_wakeup(dev))\r\nenable_irq_wake(spi->irq);\r\nreturn 0;\r\n}\r\nstatic int ds1343_resume(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nif (spi->irq >= 0 && device_may_wakeup(dev))\r\ndisable_irq_wake(spi->irq);\r\nreturn 0;\r\n}
