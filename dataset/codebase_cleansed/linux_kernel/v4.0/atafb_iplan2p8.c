void atafb_iplan2p8_copyarea(struct fb_info *info, u_long next_line,\r\nint sy, int sx, int dy, int dx,\r\nint height, int width)\r\n{\r\nu8 *src, *dst;\r\nu32 *s, *d;\r\nint w, l , i, j;\r\nu_int colsize;\r\nu_int upwards = (dy < sy) || (dy == sy && dx < sx);\r\ncolsize = height;\r\nif (!((sx ^ dx) & 15)) {\r\nif (upwards) {\r\nsrc = (u8 *)info->screen_base + sy * next_line + (sx & ~15) / (8 / BPL);\r\ndst = (u8 *)info->screen_base + dy * next_line + (dx & ~15) / (8 / BPL);\r\nif (sx & 15) {\r\nmemmove32_col(dst, src, 0xff00ff, height, next_line - BPL * 2);\r\nsrc += BPL * 2;\r\ndst += BPL * 2;\r\nwidth -= 8;\r\n}\r\nw = width >> 4;\r\nif (w) {\r\ns = (u32 *)src;\r\nd = (u32 *)dst;\r\nw *= BPL / 2;\r\nl = next_line - w * 4;\r\nfor (j = height; j > 0; j--) {\r\nfor (i = w; i > 0; i--)\r\n*d++ = *s++;\r\ns = (u32 *)((u8 *)s + l);\r\nd = (u32 *)((u8 *)d + l);\r\n}\r\n}\r\nif (width & 15)\r\nmemmove32_col(dst + width / (8 / BPL), src + width / (8 / BPL),\r\n0xff00ff00, height, next_line - BPL * 2);\r\n} else {\r\nsrc = (u8 *)info->screen_base + (sy - 1) * next_line + ((sx + width + 8) & ~15) / (8 / BPL);\r\ndst = (u8 *)info->screen_base + (dy - 1) * next_line + ((dx + width + 8) & ~15) / (8 / BPL);\r\nif ((sx + width) & 15) {\r\nsrc -= BPL * 2;\r\ndst -= BPL * 2;\r\nmemmove32_col(dst, src, 0xff00ff00, colsize, -next_line - BPL * 2);\r\nwidth -= 8;\r\n}\r\nw = width >> 4;\r\nif (w) {\r\ns = (u32 *)src;\r\nd = (u32 *)dst;\r\nw *= BPL / 2;\r\nl = next_line - w * 4;\r\nfor (j = height; j > 0; j--) {\r\nfor (i = w; i > 0; i--)\r\n*--d = *--s;\r\ns = (u32 *)((u8 *)s - l);\r\nd = (u32 *)((u8 *)d - l);\r\n}\r\n}\r\nif (sx & 15)\r\nmemmove32_col(dst - (width - 16) / (8 / BPL),\r\nsrc - (width - 16) / (8 / BPL),\r\n0xff00ff, colsize, -next_line - BPL * 2);\r\n}\r\n} else {\r\nif (upwards) {\r\nu32 *src32, *dst32;\r\nu32 pval[4], v, v1, mask;\r\nint i, j, w, f;\r\nsrc = (u8 *)info->screen_base + sy * next_line + (sx & ~15) / (8 / BPL);\r\ndst = (u8 *)info->screen_base + dy * next_line + (dx & ~15) / (8 / BPL);\r\nmask = 0xff00ff00;\r\nf = 0;\r\nw = width;\r\nif (sx & 15) {\r\nf = 1;\r\nw += 8;\r\n}\r\nif ((sx + width) & 15)\r\nf |= 2;\r\nw >>= 4;\r\nfor (i = height; i; i--) {\r\nsrc32 = (u32 *)src;\r\ndst32 = (u32 *)dst;\r\nif (f & 1) {\r\npval[0] = (*src32++ << 8) & mask;\r\npval[1] = (*src32++ << 8) & mask;\r\npval[2] = (*src32++ << 8) & mask;\r\npval[3] = (*src32++ << 8) & mask;\r\n} else {\r\npval[0] = dst32[0] & mask;\r\npval[1] = dst32[1] & mask;\r\npval[2] = dst32[2] & mask;\r\npval[3] = dst32[3] & mask;\r\n}\r\nfor (j = w; j > 0; j--) {\r\nv = *src32++;\r\nv1 = v & mask;\r\n*dst32++ = pval[0] | (v1 >> 8);\r\npval[0] = (v ^ v1) << 8;\r\nv = *src32++;\r\nv1 = v & mask;\r\n*dst32++ = pval[1] | (v1 >> 8);\r\npval[1] = (v ^ v1) << 8;\r\nv = *src32++;\r\nv1 = v & mask;\r\n*dst32++ = pval[2] | (v1 >> 8);\r\npval[2] = (v ^ v1) << 8;\r\nv = *src32++;\r\nv1 = v & mask;\r\n*dst32++ = pval[3] | (v1 >> 8);\r\npval[3] = (v ^ v1) << 8;\r\n}\r\nif (f & 2) {\r\ndst32[0] = (dst32[0] & mask) | pval[0];\r\ndst32[1] = (dst32[1] & mask) | pval[1];\r\ndst32[2] = (dst32[2] & mask) | pval[2];\r\ndst32[3] = (dst32[3] & mask) | pval[3];\r\n}\r\nsrc += next_line;\r\ndst += next_line;\r\n}\r\n} else {\r\nu32 *src32, *dst32;\r\nu32 pval[4], v, v1, mask;\r\nint i, j, w, f;\r\nsrc = (u8 *)info->screen_base + (sy - 1) * next_line + ((sx + width + 8) & ~15) / (8 / BPL);\r\ndst = (u8 *)info->screen_base + (dy - 1) * next_line + ((dx + width + 8) & ~15) / (8 / BPL);\r\nmask = 0xff00ff;\r\nf = 0;\r\nw = width;\r\nif ((dx + width) & 15)\r\nf = 1;\r\nif (sx & 15) {\r\nf |= 2;\r\nw += 8;\r\n}\r\nw >>= 4;\r\nfor (i = height; i; i--) {\r\nsrc32 = (u32 *)src;\r\ndst32 = (u32 *)dst;\r\nif (f & 1) {\r\npval[0] = dst32[-1] & mask;\r\npval[1] = dst32[-2] & mask;\r\npval[2] = dst32[-3] & mask;\r\npval[3] = dst32[-4] & mask;\r\n} else {\r\npval[0] = (*--src32 >> 8) & mask;\r\npval[1] = (*--src32 >> 8) & mask;\r\npval[2] = (*--src32 >> 8) & mask;\r\npval[3] = (*--src32 >> 8) & mask;\r\n}\r\nfor (j = w; j > 0; j--) {\r\nv = *--src32;\r\nv1 = v & mask;\r\n*--dst32 = pval[0] | (v1 << 8);\r\npval[0] = (v ^ v1) >> 8;\r\nv = *--src32;\r\nv1 = v & mask;\r\n*--dst32 = pval[1] | (v1 << 8);\r\npval[1] = (v ^ v1) >> 8;\r\nv = *--src32;\r\nv1 = v & mask;\r\n*--dst32 = pval[2] | (v1 << 8);\r\npval[2] = (v ^ v1) >> 8;\r\nv = *--src32;\r\nv1 = v & mask;\r\n*--dst32 = pval[3] | (v1 << 8);\r\npval[3] = (v ^ v1) >> 8;\r\n}\r\nif (!(f & 2)) {\r\ndst32[-1] = (dst32[-1] & mask) | pval[0];\r\ndst32[-2] = (dst32[-2] & mask) | pval[1];\r\ndst32[-3] = (dst32[-3] & mask) | pval[2];\r\ndst32[-4] = (dst32[-4] & mask) | pval[3];\r\n}\r\nsrc -= next_line;\r\ndst -= next_line;\r\n}\r\n}\r\n}\r\n}\r\nvoid atafb_iplan2p8_fillrect(struct fb_info *info, u_long next_line, u32 color,\r\nint sy, int sx, int height, int width)\r\n{\r\nu32 *dest;\r\nint rows, i;\r\nu32 cval[4];\r\ndest = (u32 *)(info->screen_base + sy * next_line + (sx & ~15) / (8 / BPL));\r\nif (sx & 15) {\r\nu8 *dest8 = (u8 *)dest + 1;\r\nexpand8_col2mask(color, cval);\r\nfor (i = height; i; i--) {\r\nfill8_col(dest8, cval);\r\ndest8 += next_line;\r\n}\r\ndest += BPL / 2;\r\nwidth -= 8;\r\n}\r\nexpand16_col2mask(color, cval);\r\nrows = width >> 4;\r\nif (rows) {\r\nu32 *d = dest;\r\nu32 off = next_line - rows * BPL * 2;\r\nfor (i = height; i; i--) {\r\nd = fill16_col(d, rows, cval);\r\nd = (u32 *)((long)d + off);\r\n}\r\ndest += rows * BPL / 2;\r\nwidth &= 15;\r\n}\r\nif (width) {\r\nu8 *dest8 = (u8 *)dest;\r\nexpand8_col2mask(color, cval);\r\nfor (i = height; i; i--) {\r\nfill8_col(dest8, cval);\r\ndest8 += next_line;\r\n}\r\n}\r\n}\r\nvoid atafb_iplan2p8_linefill(struct fb_info *info, u_long next_line,\r\nint dy, int dx, u32 width,\r\nconst u8 *data, u32 bgcolor, u32 fgcolor)\r\n{\r\nu32 *dest;\r\nconst u16 *data16;\r\nint rows;\r\nu32 fgm[4], bgm[4], m;\r\ndest = (u32 *)(info->screen_base + dy * next_line + (dx & ~15) / (8 / BPL));\r\nif (dx & 15) {\r\nfill8_2col((u8 *)dest + 1, fgcolor, bgcolor, *data++);\r\ndest += BPL / 2;\r\nwidth -= 8;\r\n}\r\nif (width >= 16) {\r\ndata16 = (const u16 *)data;\r\nexpand16_2col2mask(fgcolor, bgcolor, fgm, bgm);\r\nfor (rows = width / 16; rows; rows--) {\r\nu16 d = *data16++;\r\nm = d | ((u32)d << 16);\r\n*dest++ = (m & fgm[0]) ^ bgm[0];\r\n*dest++ = (m & fgm[1]) ^ bgm[1];\r\n*dest++ = (m & fgm[2]) ^ bgm[2];\r\n*dest++ = (m & fgm[3]) ^ bgm[3];\r\n}\r\ndata = (const u8 *)data16;\r\nwidth &= 15;\r\n}\r\nif (width)\r\nfill8_2col((u8 *)dest, fgcolor, bgcolor, *data);\r\n}\r\nint init_module(void)\r\n{\r\nreturn 0;\r\n}\r\nvoid cleanup_module(void)\r\n{\r\n}
