static inline u32 fsl_msi_read(u32 __iomem *base, unsigned int reg)\r\n{\r\nreturn in_be32(base + (reg >> 2));\r\n}\r\nstatic void fsl_msi_end_irq(struct irq_data *d)\r\n{\r\n}\r\nstatic void fsl_msi_print_chip(struct irq_data *irqd, struct seq_file *p)\r\n{\r\nstruct fsl_msi *msi_data = irqd->domain->host_data;\r\nirq_hw_number_t hwirq = irqd_to_hwirq(irqd);\r\nint cascade_virq, srs;\r\nsrs = (hwirq >> msi_data->srs_shift) & MSI_SRS_MASK;\r\ncascade_virq = msi_data->cascade_array[srs]->virq;\r\nseq_printf(p, " fsl-msi-%d", cascade_virq);\r\n}\r\nstatic int fsl_msi_host_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct fsl_msi *msi_data = h->host_data;\r\nstruct irq_chip *chip = &fsl_msi_chip;\r\nirq_set_status_flags(virq, IRQ_TYPE_EDGE_FALLING);\r\nirq_set_chip_data(virq, msi_data);\r\nirq_set_chip_and_handler(virq, chip, handle_edge_irq);\r\nreturn 0;\r\n}\r\nstatic int fsl_msi_init_allocator(struct fsl_msi *msi_data)\r\n{\r\nint rc, hwirq;\r\nrc = msi_bitmap_alloc(&msi_data->bitmap, NR_MSI_IRQS_MAX,\r\nmsi_data->irqhost->of_node);\r\nif (rc)\r\nreturn rc;\r\nfor (hwirq = 0; hwirq < NR_MSI_IRQS_MAX; hwirq++)\r\nmsi_bitmap_reserve_hwirq(&msi_data->bitmap, hwirq);\r\nreturn 0;\r\n}\r\nstatic void fsl_teardown_msi_irqs(struct pci_dev *pdev)\r\n{\r\nstruct msi_desc *entry;\r\nstruct fsl_msi *msi_data;\r\nlist_for_each_entry(entry, &pdev->msi_list, list) {\r\nif (entry->irq == NO_IRQ)\r\ncontinue;\r\nmsi_data = irq_get_chip_data(entry->irq);\r\nirq_set_msi_desc(entry->irq, NULL);\r\nmsi_bitmap_free_hwirqs(&msi_data->bitmap,\r\nvirq_to_hw(entry->irq), 1);\r\nirq_dispose_mapping(entry->irq);\r\n}\r\nreturn;\r\n}\r\nstatic void fsl_compose_msi_msg(struct pci_dev *pdev, int hwirq,\r\nstruct msi_msg *msg,\r\nstruct fsl_msi *fsl_msi_data)\r\n{\r\nstruct fsl_msi *msi_data = fsl_msi_data;\r\nstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\r\nu64 address;\r\nint len;\r\nconst __be64 *reg;\r\nreg = of_get_property(hose->dn, "msi-address-64", &len);\r\nif (reg && (len == sizeof(u64)))\r\naddress = be64_to_cpup(reg);\r\nelse\r\naddress = fsl_pci_immrbar_base(hose) + msi_data->msiir_offset;\r\nmsg->address_lo = lower_32_bits(address);\r\nmsg->address_hi = upper_32_bits(address);\r\nmsg->data = hwirq;\r\npr_debug("%s: allocated srs: %d, ibs: %d\n", __func__,\r\n(hwirq >> msi_data->srs_shift) & MSI_SRS_MASK,\r\n(hwirq >> msi_data->ibs_shift) & MSI_IBS_MASK);\r\n}\r\nstatic int fsl_setup_msi_irqs(struct pci_dev *pdev, int nvec, int type)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\r\nstruct device_node *np;\r\nphandle phandle = 0;\r\nint rc, hwirq = -ENOMEM;\r\nunsigned int virq;\r\nstruct msi_desc *entry;\r\nstruct msi_msg msg;\r\nstruct fsl_msi *msi_data;\r\nif (type == PCI_CAP_ID_MSIX)\r\npr_debug("fslmsi: MSI-X untested, trying anyway.\n");\r\nnp = of_parse_phandle(hose->dn, "fsl,msi", 0);\r\nif (np) {\r\nif (of_device_is_compatible(np, "fsl,mpic-msi") ||\r\nof_device_is_compatible(np, "fsl,vmpic-msi") ||\r\nof_device_is_compatible(np, "fsl,vmpic-msi-v4.3"))\r\nphandle = np->phandle;\r\nelse {\r\ndev_err(&pdev->dev,\r\n"node %s has an invalid fsl,msi phandle %u\n",\r\nhose->dn->full_name, np->phandle);\r\nreturn -EINVAL;\r\n}\r\n}\r\nlist_for_each_entry(entry, &pdev->msi_list, list) {\r\nlist_for_each_entry(msi_data, &msi_head, list) {\r\nif (phandle && (phandle != msi_data->phandle))\r\ncontinue;\r\nhwirq = msi_bitmap_alloc_hwirqs(&msi_data->bitmap, 1);\r\nif (hwirq >= 0)\r\nbreak;\r\n}\r\nif (hwirq < 0) {\r\nrc = hwirq;\r\ndev_err(&pdev->dev, "could not allocate MSI interrupt\n");\r\ngoto out_free;\r\n}\r\nvirq = irq_create_mapping(msi_data->irqhost, hwirq);\r\nif (virq == NO_IRQ) {\r\ndev_err(&pdev->dev, "fail mapping hwirq %i\n", hwirq);\r\nmsi_bitmap_free_hwirqs(&msi_data->bitmap, hwirq, 1);\r\nrc = -ENOSPC;\r\ngoto out_free;\r\n}\r\nirq_set_msi_desc(virq, entry);\r\nfsl_compose_msi_msg(pdev, hwirq, &msg, msi_data);\r\npci_write_msi_msg(virq, &msg);\r\n}\r\nreturn 0;\r\nout_free:\r\nreturn rc;\r\n}\r\nstatic irqreturn_t fsl_msi_cascade(int irq, void *data)\r\n{\r\nunsigned int cascade_irq;\r\nstruct fsl_msi *msi_data;\r\nint msir_index = -1;\r\nu32 msir_value = 0;\r\nu32 intr_index;\r\nu32 have_shift = 0;\r\nstruct fsl_msi_cascade_data *cascade_data = data;\r\nirqreturn_t ret = IRQ_NONE;\r\nmsi_data = cascade_data->msi_data;\r\nmsir_index = cascade_data->index;\r\nif (msir_index >= NR_MSI_REG_MAX)\r\ncascade_irq = NO_IRQ;\r\nswitch (msi_data->feature & FSL_PIC_IP_MASK) {\r\ncase FSL_PIC_IP_MPIC:\r\nmsir_value = fsl_msi_read(msi_data->msi_regs,\r\nmsir_index * 0x10);\r\nbreak;\r\ncase FSL_PIC_IP_IPIC:\r\nmsir_value = fsl_msi_read(msi_data->msi_regs, msir_index * 0x4);\r\nbreak;\r\n#ifdef CONFIG_EPAPR_PARAVIRT\r\ncase FSL_PIC_IP_VMPIC: {\r\nunsigned int ret;\r\nret = fh_vmpic_get_msir(virq_to_hw(irq), &msir_value);\r\nif (ret) {\r\npr_err("fsl-msi: fh_vmpic_get_msir() failed for "\r\n"irq %u (ret=%u)\n", irq, ret);\r\nmsir_value = 0;\r\n}\r\nbreak;\r\n}\r\n#endif\r\n}\r\nwhile (msir_value) {\r\nintr_index = ffs(msir_value) - 1;\r\ncascade_irq = irq_linear_revmap(msi_data->irqhost,\r\nmsi_hwirq(msi_data, msir_index,\r\nintr_index + have_shift));\r\nif (cascade_irq != NO_IRQ) {\r\ngeneric_handle_irq(cascade_irq);\r\nret = IRQ_HANDLED;\r\n}\r\nhave_shift += intr_index + 1;\r\nmsir_value = msir_value >> (intr_index + 1);\r\n}\r\nreturn ret;\r\n}\r\nstatic int fsl_of_msi_remove(struct platform_device *ofdev)\r\n{\r\nstruct fsl_msi *msi = platform_get_drvdata(ofdev);\r\nint virq, i;\r\nif (msi->list.prev != NULL)\r\nlist_del(&msi->list);\r\nfor (i = 0; i < NR_MSI_REG_MAX; i++) {\r\nif (msi->cascade_array[i]) {\r\nvirq = msi->cascade_array[i]->virq;\r\nBUG_ON(virq == NO_IRQ);\r\nfree_irq(virq, msi->cascade_array[i]);\r\nkfree(msi->cascade_array[i]);\r\nirq_dispose_mapping(virq);\r\n}\r\n}\r\nif (msi->bitmap.bitmap)\r\nmsi_bitmap_free(&msi->bitmap);\r\nif ((msi->feature & FSL_PIC_IP_MASK) != FSL_PIC_IP_VMPIC)\r\niounmap(msi->msi_regs);\r\nkfree(msi);\r\nreturn 0;\r\n}\r\nstatic int fsl_msi_setup_hwirq(struct fsl_msi *msi, struct platform_device *dev,\r\nint offset, int irq_index)\r\n{\r\nstruct fsl_msi_cascade_data *cascade_data = NULL;\r\nint virt_msir, i, ret;\r\nvirt_msir = irq_of_parse_and_map(dev->dev.of_node, irq_index);\r\nif (virt_msir == NO_IRQ) {\r\ndev_err(&dev->dev, "%s: Cannot translate IRQ index %d\n",\r\n__func__, irq_index);\r\nreturn 0;\r\n}\r\ncascade_data = kzalloc(sizeof(struct fsl_msi_cascade_data), GFP_KERNEL);\r\nif (!cascade_data) {\r\ndev_err(&dev->dev, "No memory for MSI cascade data\n");\r\nreturn -ENOMEM;\r\n}\r\nirq_set_lockdep_class(virt_msir, &fsl_msi_irq_class);\r\ncascade_data->index = offset;\r\ncascade_data->msi_data = msi;\r\ncascade_data->virq = virt_msir;\r\nmsi->cascade_array[irq_index] = cascade_data;\r\nret = request_irq(virt_msir, fsl_msi_cascade, IRQF_NO_THREAD,\r\n"fsl-msi-cascade", cascade_data);\r\nif (ret) {\r\ndev_err(&dev->dev, "failed to request_irq(%d), ret = %d\n",\r\nvirt_msir, ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < IRQS_PER_MSI_REG; i++)\r\nmsi_bitmap_free_hwirqs(&msi->bitmap,\r\nmsi_hwirq(msi, offset, i), 1);\r\nreturn 0;\r\n}\r\nstatic int fsl_of_msi_probe(struct platform_device *dev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct fsl_msi *msi;\r\nstruct resource res, msiir;\r\nint err, i, j, irq_index, count;\r\nconst u32 *p;\r\nconst struct fsl_msi_feature *features;\r\nint len;\r\nu32 offset;\r\nmatch = of_match_device(fsl_of_msi_ids, &dev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nfeatures = match->data;\r\nprintk(KERN_DEBUG "Setting up Freescale MSI support\n");\r\nmsi = kzalloc(sizeof(struct fsl_msi), GFP_KERNEL);\r\nif (!msi) {\r\ndev_err(&dev->dev, "No memory for MSI structure\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(dev, msi);\r\nmsi->irqhost = irq_domain_add_linear(dev->dev.of_node,\r\nNR_MSI_IRQS_MAX, &fsl_msi_host_ops, msi);\r\nif (msi->irqhost == NULL) {\r\ndev_err(&dev->dev, "No memory for MSI irqhost\n");\r\nerr = -ENOMEM;\r\ngoto error_out;\r\n}\r\nif ((features->fsl_pic_ip & FSL_PIC_IP_MASK) != FSL_PIC_IP_VMPIC) {\r\nerr = of_address_to_resource(dev->dev.of_node, 0, &res);\r\nif (err) {\r\ndev_err(&dev->dev, "invalid resource for node %s\n",\r\ndev->dev.of_node->full_name);\r\ngoto error_out;\r\n}\r\nmsi->msi_regs = ioremap(res.start, resource_size(&res));\r\nif (!msi->msi_regs) {\r\nerr = -ENOMEM;\r\ndev_err(&dev->dev, "could not map node %s\n",\r\ndev->dev.of_node->full_name);\r\ngoto error_out;\r\n}\r\nmsi->msiir_offset =\r\nfeatures->msiir_offset + (res.start & 0xfffff);\r\nif (of_address_to_resource(dev->dev.of_node, 1, &msiir))\r\nmsi->msiir_offset = features->msiir_offset +\r\n(res.start & MSIIR_OFFSET_MASK);\r\nelse\r\nmsi->msiir_offset = msiir.start & MSIIR_OFFSET_MASK;\r\n}\r\nmsi->feature = features->fsl_pic_ip;\r\nmsi->phandle = dev->dev.of_node->phandle;\r\nerr = fsl_msi_init_allocator(msi);\r\nif (err) {\r\ndev_err(&dev->dev, "Error allocating MSI bitmap\n");\r\ngoto error_out;\r\n}\r\np = of_get_property(dev->dev.of_node, "msi-available-ranges", &len);\r\nif (of_device_is_compatible(dev->dev.of_node, "fsl,mpic-msi-v4.3") ||\r\nof_device_is_compatible(dev->dev.of_node, "fsl,vmpic-msi-v4.3")) {\r\nmsi->srs_shift = MSIIR1_SRS_SHIFT;\r\nmsi->ibs_shift = MSIIR1_IBS_SHIFT;\r\nif (p)\r\ndev_warn(&dev->dev, "%s: dose not support msi-available-ranges property\n",\r\n__func__);\r\nfor (irq_index = 0; irq_index < NR_MSI_REG_MSIIR1;\r\nirq_index++) {\r\nerr = fsl_msi_setup_hwirq(msi, dev,\r\nirq_index, irq_index);\r\nif (err)\r\ngoto error_out;\r\n}\r\n} else {\r\nstatic const u32 all_avail[] =\r\n{ 0, NR_MSI_REG_MSIIR * IRQS_PER_MSI_REG };\r\nmsi->srs_shift = MSIIR_SRS_SHIFT;\r\nmsi->ibs_shift = MSIIR_IBS_SHIFT;\r\nif (p && len % (2 * sizeof(u32)) != 0) {\r\ndev_err(&dev->dev, "%s: Malformed msi-available-ranges property\n",\r\n__func__);\r\nerr = -EINVAL;\r\ngoto error_out;\r\n}\r\nif (!p) {\r\np = all_avail;\r\nlen = sizeof(all_avail);\r\n}\r\nfor (irq_index = 0, i = 0; i < len / (2 * sizeof(u32)); i++) {\r\nif (p[i * 2] % IRQS_PER_MSI_REG ||\r\np[i * 2 + 1] % IRQS_PER_MSI_REG) {\r\npr_warn("%s: %s: msi available range of %u at %u is not IRQ-aligned\n",\r\n__func__, dev->dev.of_node->full_name,\r\np[i * 2 + 1], p[i * 2]);\r\nerr = -EINVAL;\r\ngoto error_out;\r\n}\r\noffset = p[i * 2] / IRQS_PER_MSI_REG;\r\ncount = p[i * 2 + 1] / IRQS_PER_MSI_REG;\r\nfor (j = 0; j < count; j++, irq_index++) {\r\nerr = fsl_msi_setup_hwirq(msi, dev, offset + j,\r\nirq_index);\r\nif (err)\r\ngoto error_out;\r\n}\r\n}\r\n}\r\nlist_add_tail(&msi->list, &msi_head);\r\nif (!ppc_md.setup_msi_irqs) {\r\nppc_md.setup_msi_irqs = fsl_setup_msi_irqs;\r\nppc_md.teardown_msi_irqs = fsl_teardown_msi_irqs;\r\n} else if (ppc_md.setup_msi_irqs != fsl_setup_msi_irqs) {\r\ndev_err(&dev->dev, "Different MSI driver already installed!\n");\r\nerr = -ENODEV;\r\ngoto error_out;\r\n}\r\nreturn 0;\r\nerror_out:\r\nfsl_of_msi_remove(dev);\r\nreturn err;\r\n}\r\nstatic __init int fsl_of_msi_init(void)\r\n{\r\nreturn platform_driver_register(&fsl_of_msi_driver);\r\n}
