static void sirc_irq_mask(struct irq_data *d)\r\n{\r\nunsigned int mask;\r\nmask = 1 << (d->irq - FIRST_SIRC_IRQ);\r\nwritel(mask, sirc_regs.int_enable_clear);\r\nint_enable &= ~mask;\r\nreturn;\r\n}\r\nstatic void sirc_irq_unmask(struct irq_data *d)\r\n{\r\nunsigned int mask;\r\nmask = 1 << (d->irq - FIRST_SIRC_IRQ);\r\nwritel(mask, sirc_regs.int_enable_set);\r\nint_enable |= mask;\r\nreturn;\r\n}\r\nstatic void sirc_irq_ack(struct irq_data *d)\r\n{\r\nunsigned int mask;\r\nmask = 1 << (d->irq - FIRST_SIRC_IRQ);\r\nwritel(mask, sirc_regs.int_clear);\r\nreturn;\r\n}\r\nstatic int sirc_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nunsigned int mask;\r\nmask = 1 << (d->irq - FIRST_SIRC_IRQ);\r\nif (on)\r\nwake_enable |= mask;\r\nelse\r\nwake_enable &= ~mask;\r\nreturn 0;\r\n}\r\nstatic int sirc_irq_set_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nunsigned int mask;\r\nunsigned int val;\r\nmask = 1 << (d->irq - FIRST_SIRC_IRQ);\r\nval = readl(sirc_regs.int_polarity);\r\nif (flow_type & (IRQF_TRIGGER_LOW | IRQF_TRIGGER_FALLING))\r\nval |= mask;\r\nelse\r\nval &= ~mask;\r\nwritel(val, sirc_regs.int_polarity);\r\nval = readl(sirc_regs.int_type);\r\nif (flow_type & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)) {\r\nval |= mask;\r\n__irq_set_handler_locked(d->irq, handle_edge_irq);\r\n} else {\r\nval &= ~mask;\r\n__irq_set_handler_locked(d->irq, handle_level_irq);\r\n}\r\nwritel(val, sirc_regs.int_type);\r\nreturn 0;\r\n}\r\nstatic void sirc_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nunsigned int reg = 0;\r\nunsigned int sirq;\r\nunsigned int status;\r\nwhile ((reg < ARRAY_SIZE(sirc_reg_table)) &&\r\n(sirc_reg_table[reg].cascade_irq != irq))\r\nreg++;\r\nstatus = readl(sirc_reg_table[reg].int_status);\r\nstatus &= SIRC_MASK;\r\nif (status == 0)\r\nreturn;\r\nfor (sirq = 0;\r\n(sirq < NR_SIRC_IRQS) && ((status & (1U << sirq)) == 0);\r\nsirq++)\r\n;\r\ngeneric_handle_irq(sirq+FIRST_SIRC_IRQ);\r\ndesc->irq_data.chip->irq_ack(&desc->irq_data);\r\n}\r\nvoid __init msm_init_sirc(void)\r\n{\r\nint i;\r\nint_enable = 0;\r\nwake_enable = 0;\r\nfor (i = FIRST_SIRC_IRQ; i < LAST_SIRC_IRQ; i++) {\r\nirq_set_chip_and_handler(i, &sirc_irq_chip, handle_edge_irq);\r\nset_irq_flags(i, IRQF_VALID);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(sirc_reg_table); i++) {\r\nirq_set_chained_handler(sirc_reg_table[i].cascade_irq,\r\nsirc_irq_handler);\r\nirq_set_irq_wake(sirc_reg_table[i].cascade_irq, 1);\r\n}\r\nreturn;\r\n}
