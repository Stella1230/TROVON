static int read_method_int(acpi_handle handle, const char *method, int *val)\r\n{\r\nacpi_status status;\r\nunsigned long long result;\r\nstatus = acpi_evaluate_integer(handle, (char *)method, NULL, &result);\r\nif (ACPI_FAILURE(status)) {\r\n*val = -1;\r\nreturn -1;\r\n} else {\r\n*val = result;\r\nreturn 0;\r\n}\r\n}\r\nstatic int method_vpcr(acpi_handle handle, int cmd, int *ret)\r\n{\r\nacpi_status status;\r\nunsigned long long result;\r\nstruct acpi_object_list params;\r\nunion acpi_object in_obj;\r\nparams.count = 1;\r\nparams.pointer = &in_obj;\r\nin_obj.type = ACPI_TYPE_INTEGER;\r\nin_obj.integer.value = cmd;\r\nstatus = acpi_evaluate_integer(handle, "VPCR", &params, &result);\r\nif (ACPI_FAILURE(status)) {\r\n*ret = -1;\r\nreturn -1;\r\n} else {\r\n*ret = result;\r\nreturn 0;\r\n}\r\n}\r\nstatic int method_vpcw(acpi_handle handle, int cmd, int data)\r\n{\r\nstruct acpi_object_list params;\r\nunion acpi_object in_obj[2];\r\nacpi_status status;\r\nparams.count = 2;\r\nparams.pointer = in_obj;\r\nin_obj[0].type = ACPI_TYPE_INTEGER;\r\nin_obj[0].integer.value = cmd;\r\nin_obj[1].type = ACPI_TYPE_INTEGER;\r\nin_obj[1].integer.value = data;\r\nstatus = acpi_evaluate_object(handle, "VPCW", &params, NULL);\r\nif (status != AE_OK)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int read_ec_data(acpi_handle handle, int cmd, unsigned long *data)\r\n{\r\nint val;\r\nunsigned long int end_jiffies;\r\nif (method_vpcw(handle, 1, cmd))\r\nreturn -1;\r\nfor (end_jiffies = jiffies+(HZ)*IDEAPAD_EC_TIMEOUT/1000+1;\r\ntime_before(jiffies, end_jiffies);) {\r\nschedule();\r\nif (method_vpcr(handle, 1, &val))\r\nreturn -1;\r\nif (val == 0) {\r\nif (method_vpcr(handle, 0, &val))\r\nreturn -1;\r\n*data = val;\r\nreturn 0;\r\n}\r\n}\r\npr_err("timeout in read_ec_cmd\n");\r\nreturn -1;\r\n}\r\nstatic int write_ec_cmd(acpi_handle handle, int cmd, unsigned long data)\r\n{\r\nint val;\r\nunsigned long int end_jiffies;\r\nif (method_vpcw(handle, 0, data))\r\nreturn -1;\r\nif (method_vpcw(handle, 1, cmd))\r\nreturn -1;\r\nfor (end_jiffies = jiffies+(HZ)*IDEAPAD_EC_TIMEOUT/1000+1;\r\ntime_before(jiffies, end_jiffies);) {\r\nschedule();\r\nif (method_vpcr(handle, 1, &val))\r\nreturn -1;\r\nif (val == 0)\r\nreturn 0;\r\n}\r\npr_err("timeout in write_ec_cmd\n");\r\nreturn -1;\r\n}\r\nstatic int debugfs_status_show(struct seq_file *s, void *data)\r\n{\r\nstruct ideapad_private *priv = s->private;\r\nunsigned long value;\r\nif (!priv)\r\nreturn -EINVAL;\r\nif (!read_ec_data(priv->adev->handle, VPCCMD_R_BL_MAX, &value))\r\nseq_printf(s, "Backlight max:\t%lu\n", value);\r\nif (!read_ec_data(priv->adev->handle, VPCCMD_R_BL, &value))\r\nseq_printf(s, "Backlight now:\t%lu\n", value);\r\nif (!read_ec_data(priv->adev->handle, VPCCMD_R_BL_POWER, &value))\r\nseq_printf(s, "BL power value:\t%s\n", value ? "On" : "Off");\r\nseq_printf(s, "=====================\n");\r\nif (!read_ec_data(priv->adev->handle, VPCCMD_R_RF, &value))\r\nseq_printf(s, "Radio status:\t%s(%lu)\n",\r\nvalue ? "On" : "Off", value);\r\nif (!read_ec_data(priv->adev->handle, VPCCMD_R_WIFI, &value))\r\nseq_printf(s, "Wifi status:\t%s(%lu)\n",\r\nvalue ? "On" : "Off", value);\r\nif (!read_ec_data(priv->adev->handle, VPCCMD_R_BT, &value))\r\nseq_printf(s, "BT status:\t%s(%lu)\n",\r\nvalue ? "On" : "Off", value);\r\nif (!read_ec_data(priv->adev->handle, VPCCMD_R_3G, &value))\r\nseq_printf(s, "3G status:\t%s(%lu)\n",\r\nvalue ? "On" : "Off", value);\r\nseq_printf(s, "=====================\n");\r\nif (!read_ec_data(priv->adev->handle, VPCCMD_R_TOUCHPAD, &value))\r\nseq_printf(s, "Touchpad status:%s(%lu)\n",\r\nvalue ? "On" : "Off", value);\r\nif (!read_ec_data(priv->adev->handle, VPCCMD_R_CAMERA, &value))\r\nseq_printf(s, "Camera status:\t%s(%lu)\n",\r\nvalue ? "On" : "Off", value);\r\nreturn 0;\r\n}\r\nstatic int debugfs_status_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, debugfs_status_show, inode->i_private);\r\n}\r\nstatic int debugfs_cfg_show(struct seq_file *s, void *data)\r\n{\r\nstruct ideapad_private *priv = s->private;\r\nif (!priv) {\r\nseq_printf(s, "cfg: N/A\n");\r\n} else {\r\nseq_printf(s, "cfg: 0x%.8lX\n\nCapability: ",\r\npriv->cfg);\r\nif (test_bit(CFG_BT_BIT, &priv->cfg))\r\nseq_printf(s, "Bluetooth ");\r\nif (test_bit(CFG_3G_BIT, &priv->cfg))\r\nseq_printf(s, "3G ");\r\nif (test_bit(CFG_WIFI_BIT, &priv->cfg))\r\nseq_printf(s, "Wireless ");\r\nif (test_bit(CFG_CAMERA_BIT, &priv->cfg))\r\nseq_printf(s, "Camera ");\r\nseq_printf(s, "\nGraphic: ");\r\nswitch ((priv->cfg)&0x700) {\r\ncase 0x100:\r\nseq_printf(s, "Intel");\r\nbreak;\r\ncase 0x200:\r\nseq_printf(s, "ATI");\r\nbreak;\r\ncase 0x300:\r\nseq_printf(s, "Nvidia");\r\nbreak;\r\ncase 0x400:\r\nseq_printf(s, "Intel and ATI");\r\nbreak;\r\ncase 0x500:\r\nseq_printf(s, "Intel and Nvidia");\r\nbreak;\r\n}\r\nseq_printf(s, "\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int debugfs_cfg_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, debugfs_cfg_show, inode->i_private);\r\n}\r\nstatic int ideapad_debugfs_init(struct ideapad_private *priv)\r\n{\r\nstruct dentry *node;\r\npriv->debug = debugfs_create_dir("ideapad", NULL);\r\nif (priv->debug == NULL) {\r\npr_err("failed to create debugfs directory");\r\ngoto errout;\r\n}\r\nnode = debugfs_create_file("cfg", S_IRUGO, priv->debug, priv,\r\n&debugfs_cfg_fops);\r\nif (!node) {\r\npr_err("failed to create cfg in debugfs");\r\ngoto errout;\r\n}\r\nnode = debugfs_create_file("status", S_IRUGO, priv->debug, priv,\r\n&debugfs_status_fops);\r\nif (!node) {\r\npr_err("failed to create status in debugfs");\r\ngoto errout;\r\n}\r\nreturn 0;\r\nerrout:\r\nreturn -ENOMEM;\r\n}\r\nstatic void ideapad_debugfs_exit(struct ideapad_private *priv)\r\n{\r\ndebugfs_remove_recursive(priv->debug);\r\npriv->debug = NULL;\r\n}\r\nstatic ssize_t show_ideapad_cam(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long result;\r\nstruct ideapad_private *priv = dev_get_drvdata(dev);\r\nif (read_ec_data(priv->adev->handle, VPCCMD_R_CAMERA, &result))\r\nreturn sprintf(buf, "-1\n");\r\nreturn sprintf(buf, "%lu\n", result);\r\n}\r\nstatic ssize_t store_ideapad_cam(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret, state;\r\nstruct ideapad_private *priv = dev_get_drvdata(dev);\r\nif (!count)\r\nreturn 0;\r\nif (sscanf(buf, "%i", &state) != 1)\r\nreturn -EINVAL;\r\nret = write_ec_cmd(priv->adev->handle, VPCCMD_W_CAMERA, state);\r\nif (ret < 0)\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic ssize_t show_ideapad_fan(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long result;\r\nstruct ideapad_private *priv = dev_get_drvdata(dev);\r\nif (read_ec_data(priv->adev->handle, VPCCMD_R_FAN, &result))\r\nreturn sprintf(buf, "-1\n");\r\nreturn sprintf(buf, "%lu\n", result);\r\n}\r\nstatic ssize_t store_ideapad_fan(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret, state;\r\nstruct ideapad_private *priv = dev_get_drvdata(dev);\r\nif (!count)\r\nreturn 0;\r\nif (sscanf(buf, "%i", &state) != 1)\r\nreturn -EINVAL;\r\nif (state < 0 || state > 4 || state == 3)\r\nreturn -EINVAL;\r\nret = write_ec_cmd(priv->adev->handle, VPCCMD_W_FAN, state);\r\nif (ret < 0)\r\nreturn -EIO;\r\nreturn count;\r\n}\r\nstatic umode_t ideapad_is_visible(struct kobject *kobj,\r\nstruct attribute *attr,\r\nint idx)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct ideapad_private *priv = dev_get_drvdata(dev);\r\nbool supported;\r\nif (attr == &dev_attr_camera_power.attr)\r\nsupported = test_bit(CFG_CAMERA_BIT, &(priv->cfg));\r\nelse if (attr == &dev_attr_fan_mode.attr) {\r\nunsigned long value;\r\nsupported = !read_ec_data(priv->adev->handle, VPCCMD_R_FAN,\r\n&value);\r\n} else\r\nsupported = true;\r\nreturn supported ? attr->mode : 0;\r\n}\r\nstatic int ideapad_rfk_set(void *data, bool blocked)\r\n{\r\nstruct ideapad_rfk_priv *priv = data;\r\nreturn write_ec_cmd(priv->priv->adev->handle, priv->dev, !blocked);\r\n}\r\nstatic void ideapad_sync_rfk_state(struct ideapad_private *priv)\r\n{\r\nunsigned long hw_blocked = 0;\r\nint i;\r\nif (priv->has_hw_rfkill_switch) {\r\nif (read_ec_data(priv->adev->handle, VPCCMD_R_RF, &hw_blocked))\r\nreturn;\r\nhw_blocked = !hw_blocked;\r\n}\r\nfor (i = 0; i < IDEAPAD_RFKILL_DEV_NUM; i++)\r\nif (priv->rfk[i])\r\nrfkill_set_hw_state(priv->rfk[i], hw_blocked);\r\n}\r\nstatic int ideapad_register_rfkill(struct ideapad_private *priv, int dev)\r\n{\r\nint ret;\r\nunsigned long sw_blocked;\r\nif (no_bt_rfkill &&\r\n(ideapad_rfk_data[dev].type == RFKILL_TYPE_BLUETOOTH)) {\r\nwrite_ec_cmd(priv->adev->handle,\r\nideapad_rfk_data[dev].opcode, 1);\r\nreturn 0;\r\n}\r\npriv->rfk_priv[dev].dev = dev;\r\npriv->rfk_priv[dev].priv = priv;\r\npriv->rfk[dev] = rfkill_alloc(ideapad_rfk_data[dev].name,\r\n&priv->platform_device->dev,\r\nideapad_rfk_data[dev].type,\r\n&ideapad_rfk_ops,\r\n&priv->rfk_priv[dev]);\r\nif (!priv->rfk[dev])\r\nreturn -ENOMEM;\r\nif (read_ec_data(priv->adev->handle, ideapad_rfk_data[dev].opcode-1,\r\n&sw_blocked)) {\r\nrfkill_init_sw_state(priv->rfk[dev], 0);\r\n} else {\r\nsw_blocked = !sw_blocked;\r\nrfkill_init_sw_state(priv->rfk[dev], sw_blocked);\r\n}\r\nret = rfkill_register(priv->rfk[dev]);\r\nif (ret) {\r\nrfkill_destroy(priv->rfk[dev]);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ideapad_unregister_rfkill(struct ideapad_private *priv, int dev)\r\n{\r\nif (!priv->rfk[dev])\r\nreturn;\r\nrfkill_unregister(priv->rfk[dev]);\r\nrfkill_destroy(priv->rfk[dev]);\r\n}\r\nstatic int ideapad_sysfs_init(struct ideapad_private *priv)\r\n{\r\nreturn sysfs_create_group(&priv->platform_device->dev.kobj,\r\n&ideapad_attribute_group);\r\n}\r\nstatic void ideapad_sysfs_exit(struct ideapad_private *priv)\r\n{\r\nsysfs_remove_group(&priv->platform_device->dev.kobj,\r\n&ideapad_attribute_group);\r\n}\r\nstatic int ideapad_input_init(struct ideapad_private *priv)\r\n{\r\nstruct input_dev *inputdev;\r\nint error;\r\ninputdev = input_allocate_device();\r\nif (!inputdev)\r\nreturn -ENOMEM;\r\ninputdev->name = "Ideapad extra buttons";\r\ninputdev->phys = "ideapad/input0";\r\ninputdev->id.bustype = BUS_HOST;\r\ninputdev->dev.parent = &priv->platform_device->dev;\r\nerror = sparse_keymap_setup(inputdev, ideapad_keymap, NULL);\r\nif (error) {\r\npr_err("Unable to setup input device keymap\n");\r\ngoto err_free_dev;\r\n}\r\nerror = input_register_device(inputdev);\r\nif (error) {\r\npr_err("Unable to register input device\n");\r\ngoto err_free_keymap;\r\n}\r\npriv->inputdev = inputdev;\r\nreturn 0;\r\nerr_free_keymap:\r\nsparse_keymap_free(inputdev);\r\nerr_free_dev:\r\ninput_free_device(inputdev);\r\nreturn error;\r\n}\r\nstatic void ideapad_input_exit(struct ideapad_private *priv)\r\n{\r\nsparse_keymap_free(priv->inputdev);\r\ninput_unregister_device(priv->inputdev);\r\npriv->inputdev = NULL;\r\n}\r\nstatic void ideapad_input_report(struct ideapad_private *priv,\r\nunsigned long scancode)\r\n{\r\nsparse_keymap_report_event(priv->inputdev, scancode, 1, true);\r\n}\r\nstatic void ideapad_input_novokey(struct ideapad_private *priv)\r\n{\r\nunsigned long long_pressed;\r\nif (read_ec_data(priv->adev->handle, VPCCMD_R_NOVO, &long_pressed))\r\nreturn;\r\nif (long_pressed)\r\nideapad_input_report(priv, 17);\r\nelse\r\nideapad_input_report(priv, 16);\r\n}\r\nstatic void ideapad_check_special_buttons(struct ideapad_private *priv)\r\n{\r\nunsigned long bit, value;\r\nread_ec_data(priv->adev->handle, VPCCMD_R_SPECIAL_BUTTONS, &value);\r\nfor (bit = 0; bit < 16; bit++) {\r\nif (test_bit(bit, &value)) {\r\nswitch (bit) {\r\ncase 0:\r\ncase 6:\r\nideapad_input_report(priv, 65);\r\nbreak;\r\ncase 1:\r\nideapad_input_report(priv, 64);\r\nbreak;\r\ndefault:\r\npr_info("Unknown special button: %lu\n", bit);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic int ideapad_backlight_get_brightness(struct backlight_device *blightdev)\r\n{\r\nstruct ideapad_private *priv = bl_get_data(blightdev);\r\nunsigned long now;\r\nif (!priv)\r\nreturn -EINVAL;\r\nif (read_ec_data(priv->adev->handle, VPCCMD_R_BL, &now))\r\nreturn -EIO;\r\nreturn now;\r\n}\r\nstatic int ideapad_backlight_update_status(struct backlight_device *blightdev)\r\n{\r\nstruct ideapad_private *priv = bl_get_data(blightdev);\r\nif (!priv)\r\nreturn -EINVAL;\r\nif (write_ec_cmd(priv->adev->handle, VPCCMD_W_BL,\r\nblightdev->props.brightness))\r\nreturn -EIO;\r\nif (write_ec_cmd(priv->adev->handle, VPCCMD_W_BL_POWER,\r\nblightdev->props.power == FB_BLANK_POWERDOWN ? 0 : 1))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int ideapad_backlight_init(struct ideapad_private *priv)\r\n{\r\nstruct backlight_device *blightdev;\r\nstruct backlight_properties props;\r\nunsigned long max, now, power;\r\nif (read_ec_data(priv->adev->handle, VPCCMD_R_BL_MAX, &max))\r\nreturn -EIO;\r\nif (read_ec_data(priv->adev->handle, VPCCMD_R_BL, &now))\r\nreturn -EIO;\r\nif (read_ec_data(priv->adev->handle, VPCCMD_R_BL_POWER, &power))\r\nreturn -EIO;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.max_brightness = max;\r\nprops.type = BACKLIGHT_PLATFORM;\r\nblightdev = backlight_device_register("ideapad",\r\n&priv->platform_device->dev,\r\npriv,\r\n&ideapad_backlight_ops,\r\n&props);\r\nif (IS_ERR(blightdev)) {\r\npr_err("Could not register backlight device\n");\r\nreturn PTR_ERR(blightdev);\r\n}\r\npriv->blightdev = blightdev;\r\nblightdev->props.brightness = now;\r\nblightdev->props.power = power ? FB_BLANK_UNBLANK : FB_BLANK_POWERDOWN;\r\nbacklight_update_status(blightdev);\r\nreturn 0;\r\n}\r\nstatic void ideapad_backlight_exit(struct ideapad_private *priv)\r\n{\r\nbacklight_device_unregister(priv->blightdev);\r\npriv->blightdev = NULL;\r\n}\r\nstatic void ideapad_backlight_notify_power(struct ideapad_private *priv)\r\n{\r\nunsigned long power;\r\nstruct backlight_device *blightdev = priv->blightdev;\r\nif (!blightdev)\r\nreturn;\r\nif (read_ec_data(priv->adev->handle, VPCCMD_R_BL_POWER, &power))\r\nreturn;\r\nblightdev->props.power = power ? FB_BLANK_UNBLANK : FB_BLANK_POWERDOWN;\r\n}\r\nstatic void ideapad_backlight_notify_brightness(struct ideapad_private *priv)\r\n{\r\nunsigned long now;\r\nif (priv->blightdev == NULL) {\r\nread_ec_data(priv->adev->handle, VPCCMD_R_BL, &now);\r\nreturn;\r\n}\r\nbacklight_force_update(priv->blightdev, BACKLIGHT_UPDATE_HOTKEY);\r\n}\r\nstatic void ideapad_sync_touchpad_state(struct ideapad_private *priv)\r\n{\r\nunsigned long value;\r\nif (!read_ec_data(priv->adev->handle, VPCCMD_R_TOUCHPAD, &value)) {\r\nunsigned char param;\r\ni8042_command(&param, value ? I8042_CMD_AUX_ENABLE :\r\nI8042_CMD_AUX_DISABLE);\r\nideapad_input_report(priv, value ? 67 : 66);\r\n}\r\n}\r\nstatic void ideapad_acpi_notify(acpi_handle handle, u32 event, void *data)\r\n{\r\nstruct ideapad_private *priv = data;\r\nunsigned long vpc1, vpc2, vpc_bit;\r\nif (read_ec_data(handle, VPCCMD_R_VPC1, &vpc1))\r\nreturn;\r\nif (read_ec_data(handle, VPCCMD_R_VPC2, &vpc2))\r\nreturn;\r\nvpc1 = (vpc2 << 8) | vpc1;\r\nfor (vpc_bit = 0; vpc_bit < 16; vpc_bit++) {\r\nif (test_bit(vpc_bit, &vpc1)) {\r\nswitch (vpc_bit) {\r\ncase 9:\r\nideapad_sync_rfk_state(priv);\r\nbreak;\r\ncase 13:\r\ncase 11:\r\ncase 7:\r\ncase 6:\r\nideapad_input_report(priv, vpc_bit);\r\nbreak;\r\ncase 5:\r\nideapad_sync_touchpad_state(priv);\r\nbreak;\r\ncase 4:\r\nideapad_backlight_notify_brightness(priv);\r\nbreak;\r\ncase 3:\r\nideapad_input_novokey(priv);\r\nbreak;\r\ncase 2:\r\nideapad_backlight_notify_power(priv);\r\nbreak;\r\ncase 0:\r\nideapad_check_special_buttons(priv);\r\nbreak;\r\ndefault:\r\npr_info("Unknown event: %lu\n", vpc_bit);\r\n}\r\n}\r\n}\r\n}\r\nstatic int ideapad_acpi_add(struct platform_device *pdev)\r\n{\r\nint ret, i;\r\nint cfg;\r\nstruct ideapad_private *priv;\r\nstruct acpi_device *adev;\r\nret = acpi_bus_get_device(ACPI_HANDLE(&pdev->dev), &adev);\r\nif (ret)\r\nreturn -ENODEV;\r\nif (read_method_int(adev->handle, "_CFG", &cfg))\r\nreturn -ENODEV;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&pdev->dev, priv);\r\npriv->cfg = cfg;\r\npriv->adev = adev;\r\npriv->platform_device = pdev;\r\npriv->has_hw_rfkill_switch = !dmi_check_system(no_hw_rfkill_list);\r\nret = ideapad_sysfs_init(priv);\r\nif (ret)\r\nreturn ret;\r\nret = ideapad_debugfs_init(priv);\r\nif (ret)\r\ngoto debugfs_failed;\r\nret = ideapad_input_init(priv);\r\nif (ret)\r\ngoto input_failed;\r\nif (!priv->has_hw_rfkill_switch)\r\nwrite_ec_cmd(priv->adev->handle, VPCCMD_W_RF, 1);\r\nfor (i = 0; i < IDEAPAD_RFKILL_DEV_NUM; i++)\r\nif (test_bit(ideapad_rfk_data[i].cfgbit, &priv->cfg))\r\nideapad_register_rfkill(priv, i);\r\nideapad_sync_rfk_state(priv);\r\nideapad_sync_touchpad_state(priv);\r\nif (!acpi_video_backlight_support()) {\r\nret = ideapad_backlight_init(priv);\r\nif (ret && ret != -ENODEV)\r\ngoto backlight_failed;\r\n}\r\nret = acpi_install_notify_handler(adev->handle,\r\nACPI_DEVICE_NOTIFY, ideapad_acpi_notify, priv);\r\nif (ret)\r\ngoto notification_failed;\r\nreturn 0;\r\nnotification_failed:\r\nideapad_backlight_exit(priv);\r\nbacklight_failed:\r\nfor (i = 0; i < IDEAPAD_RFKILL_DEV_NUM; i++)\r\nideapad_unregister_rfkill(priv, i);\r\nideapad_input_exit(priv);\r\ninput_failed:\r\nideapad_debugfs_exit(priv);\r\ndebugfs_failed:\r\nideapad_sysfs_exit(priv);\r\nreturn ret;\r\n}\r\nstatic int ideapad_acpi_remove(struct platform_device *pdev)\r\n{\r\nstruct ideapad_private *priv = dev_get_drvdata(&pdev->dev);\r\nint i;\r\nacpi_remove_notify_handler(priv->adev->handle,\r\nACPI_DEVICE_NOTIFY, ideapad_acpi_notify);\r\nideapad_backlight_exit(priv);\r\nfor (i = 0; i < IDEAPAD_RFKILL_DEV_NUM; i++)\r\nideapad_unregister_rfkill(priv, i);\r\nideapad_input_exit(priv);\r\nideapad_debugfs_exit(priv);\r\nideapad_sysfs_exit(priv);\r\ndev_set_drvdata(&pdev->dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int ideapad_acpi_resume(struct device *device)\r\n{\r\nstruct ideapad_private *priv;\r\nif (!device)\r\nreturn -EINVAL;\r\npriv = dev_get_drvdata(device);\r\nideapad_sync_rfk_state(priv);\r\nideapad_sync_touchpad_state(priv);\r\nreturn 0;\r\n}
