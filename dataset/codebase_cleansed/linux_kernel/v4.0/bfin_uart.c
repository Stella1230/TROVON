static unsigned int bfin_serial_get_mctrl(struct uart_port *port)\r\n{\r\nstruct bfin_serial_port *uart = (struct bfin_serial_port *)port;\r\nif (uart->cts_pin < 0)\r\nreturn TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\r\nif (UART_GET_CTS(uart))\r\nreturn TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\r\nelse\r\nreturn TIOCM_DSR | TIOCM_CAR;\r\n}\r\nstatic void bfin_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct bfin_serial_port *uart = (struct bfin_serial_port *)port;\r\nif (uart->rts_pin < 0)\r\nreturn;\r\nif (mctrl & TIOCM_RTS)\r\nUART_ENABLE_RTS(uart);\r\nelse\r\nUART_DISABLE_RTS(uart);\r\n}\r\nstatic irqreturn_t bfin_serial_mctrl_cts_int(int irq, void *dev_id)\r\n{\r\nstruct bfin_serial_port *uart = dev_id;\r\nstruct uart_port *uport = &uart->port;\r\nunsigned int status = bfin_serial_get_mctrl(uport);\r\n#ifdef CONFIG_SERIAL_BFIN_HARD_CTSRTS\r\nUART_CLEAR_SCTS(uart);\r\nif (uport->hw_stopped) {\r\nif (status) {\r\nuport->hw_stopped = 0;\r\nuart_write_wakeup(uport);\r\n}\r\n} else {\r\nif (!status)\r\nuport->hw_stopped = 1;\r\n}\r\n#else\r\nuart_handle_cts_change(uport, status & TIOCM_CTS);\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int bfin_serial_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;\r\n}\r\nstatic void bfin_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void bfin_serial_stop_tx(struct uart_port *port)\r\n{\r\nstruct bfin_serial_port *uart = (struct bfin_serial_port *)port;\r\n#ifdef CONFIG_SERIAL_BFIN_DMA\r\nstruct circ_buf *xmit = &uart->port.state->xmit;\r\n#endif\r\nwhile (!(UART_GET_LSR(uart) & TEMT))\r\ncpu_relax();\r\n#ifdef CONFIG_SERIAL_BFIN_DMA\r\ndisable_dma(uart->tx_dma_channel);\r\nxmit->tail = (xmit->tail + uart->tx_count) & (UART_XMIT_SIZE - 1);\r\nuart->port.icount.tx += uart->tx_count;\r\nuart->tx_count = 0;\r\nuart->tx_done = 1;\r\n#else\r\n#if defined(CONFIG_BF54x) || defined(CONFIG_BF60x)\r\nUART_PUT_LSR(uart, TFI);\r\n#endif\r\nUART_CLEAR_IER(uart, ETBEI);\r\n#endif\r\n}\r\nstatic void bfin_serial_start_tx(struct uart_port *port)\r\n{\r\nstruct bfin_serial_port *uart = (struct bfin_serial_port *)port;\r\nstruct tty_struct *tty = uart->port.state->port.tty;\r\nif (tty->termios.c_line == N_IRDA)\r\nbfin_serial_reset_irda(port);\r\n#ifdef CONFIG_SERIAL_BFIN_DMA\r\nif (uart->tx_done)\r\nbfin_serial_dma_tx_chars(uart);\r\n#else\r\nUART_SET_IER(uart, ETBEI);\r\nbfin_serial_tx_chars(uart);\r\n#endif\r\n}\r\nstatic void bfin_serial_stop_rx(struct uart_port *port)\r\n{\r\nstruct bfin_serial_port *uart = (struct bfin_serial_port *)port;\r\nUART_CLEAR_IER(uart, ERBFI);\r\n}\r\nstatic void bfin_serial_rx_chars(struct bfin_serial_port *uart)\r\n{\r\nunsigned int status, ch, flg;\r\nstatic struct timeval anomaly_start = { .tv_sec = 0 };\r\nstatus = UART_GET_LSR(uart);\r\nUART_CLEAR_LSR(uart);\r\nch = UART_GET_CHAR(uart);\r\nuart->port.icount.rx++;\r\n#if defined(CONFIG_KGDB_SERIAL_CONSOLE) || \\r\ndefined(CONFIG_KGDB_SERIAL_CONSOLE_MODULE)\r\nif (kgdb_connected && kgdboc_port_line == uart->port.line\r\n&& kgdboc_break_enabled)\r\nif (ch == 0x3) {\r\nkgdb_breakpoint();\r\nreturn;\r\n}\r\nif (!uart->port.state)\r\nreturn;\r\n#endif\r\nif (ANOMALY_05000363) {\r\nif (anomaly_start.tv_sec) {\r\nstruct timeval curr;\r\nsuseconds_t usecs;\r\nif ((~ch & (~ch + 1)) & 0xff)\r\ngoto known_good_char;\r\ndo_gettimeofday(&curr);\r\nif (curr.tv_sec - anomaly_start.tv_sec > 1)\r\ngoto known_good_char;\r\nusecs = 0;\r\nif (curr.tv_sec != anomaly_start.tv_sec)\r\nusecs += USEC_PER_SEC;\r\nusecs += curr.tv_usec - anomaly_start.tv_usec;\r\nif (usecs > UART_GET_ANOMALY_THRESHOLD(uart))\r\ngoto known_good_char;\r\nif (ch)\r\nanomaly_start.tv_sec = 0;\r\nelse\r\nanomaly_start = curr;\r\nreturn;\r\nknown_good_char:\r\nstatus &= ~BI;\r\nanomaly_start.tv_sec = 0;\r\n}\r\n}\r\nif (status & BI) {\r\nif (ANOMALY_05000363)\r\nif (bfin_revid() < 5)\r\ndo_gettimeofday(&anomaly_start);\r\nuart->port.icount.brk++;\r\nif (uart_handle_break(&uart->port))\r\ngoto ignore_char;\r\nstatus &= ~(PE | FE);\r\n}\r\nif (status & PE)\r\nuart->port.icount.parity++;\r\nif (status & OE)\r\nuart->port.icount.overrun++;\r\nif (status & FE)\r\nuart->port.icount.frame++;\r\nstatus &= uart->port.read_status_mask;\r\nif (status & BI)\r\nflg = TTY_BREAK;\r\nelse if (status & PE)\r\nflg = TTY_PARITY;\r\nelse if (status & FE)\r\nflg = TTY_FRAME;\r\nelse\r\nflg = TTY_NORMAL;\r\nif (uart_handle_sysrq_char(&uart->port, ch))\r\ngoto ignore_char;\r\nuart_insert_char(&uart->port, status, OE, ch, flg);\r\nignore_char:\r\ntty_flip_buffer_push(&uart->port.state->port);\r\n}\r\nstatic void bfin_serial_tx_chars(struct bfin_serial_port *uart)\r\n{\r\nstruct circ_buf *xmit = &uart->port.state->xmit;\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&uart->port)) {\r\n#if defined(CONFIG_BF54x) || defined(CONFIG_BF60x)\r\nUART_PUT_LSR(uart, TFI);\r\n#endif\r\nUART_CLEAR_IER(uart, ETBEI);\r\nreturn;\r\n}\r\nif (uart->port.x_char) {\r\nUART_PUT_CHAR(uart, uart->port.x_char);\r\nuart->port.icount.tx++;\r\nuart->port.x_char = 0;\r\n}\r\nwhile ((UART_GET_LSR(uart) & THRE) && xmit->tail != xmit->head) {\r\nUART_PUT_CHAR(uart, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nuart->port.icount.tx++;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&uart->port);\r\n}\r\nstatic irqreturn_t bfin_serial_rx_int(int irq, void *dev_id)\r\n{\r\nstruct bfin_serial_port *uart = dev_id;\r\nwhile (UART_GET_LSR(uart) & DR)\r\nbfin_serial_rx_chars(uart);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t bfin_serial_tx_int(int irq, void *dev_id)\r\n{\r\nstruct bfin_serial_port *uart = dev_id;\r\nspin_lock(&uart->port.lock);\r\nif (UART_GET_LSR(uart) & THRE)\r\nbfin_serial_tx_chars(uart);\r\nspin_unlock(&uart->port.lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void bfin_serial_dma_tx_chars(struct bfin_serial_port *uart)\r\n{\r\nstruct circ_buf *xmit = &uart->port.state->xmit;\r\nuart->tx_done = 0;\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&uart->port)) {\r\nuart->tx_count = 0;\r\nuart->tx_done = 1;\r\nreturn;\r\n}\r\nif (uart->port.x_char) {\r\nUART_PUT_CHAR(uart, uart->port.x_char);\r\nuart->port.icount.tx++;\r\nuart->port.x_char = 0;\r\n}\r\nuart->tx_count = CIRC_CNT(xmit->head, xmit->tail, UART_XMIT_SIZE);\r\nif (uart->tx_count > (UART_XMIT_SIZE - xmit->tail))\r\nuart->tx_count = UART_XMIT_SIZE - xmit->tail;\r\nblackfin_dcache_flush_range((unsigned long)(xmit->buf+xmit->tail),\r\n(unsigned long)(xmit->buf+xmit->tail+uart->tx_count));\r\nset_dma_config(uart->tx_dma_channel,\r\nset_bfin_dma_config(DIR_READ, DMA_FLOW_STOP,\r\nINTR_ON_BUF,\r\nDIMENSION_LINEAR,\r\nDATA_SIZE_8,\r\nDMA_SYNC_RESTART));\r\nset_dma_start_addr(uart->tx_dma_channel, (unsigned long)(xmit->buf+xmit->tail));\r\nset_dma_x_count(uart->tx_dma_channel, uart->tx_count);\r\nset_dma_x_modify(uart->tx_dma_channel, 1);\r\nSSYNC();\r\nenable_dma(uart->tx_dma_channel);\r\nUART_SET_IER(uart, ETBEI);\r\n}\r\nstatic void bfin_serial_dma_rx_chars(struct bfin_serial_port *uart)\r\n{\r\nint i, flg, status;\r\nstatus = UART_GET_LSR(uart);\r\nUART_CLEAR_LSR(uart);\r\nuart->port.icount.rx +=\r\nCIRC_CNT(uart->rx_dma_buf.head, uart->rx_dma_buf.tail,\r\nUART_XMIT_SIZE);\r\nif (status & BI) {\r\nuart->port.icount.brk++;\r\nif (uart_handle_break(&uart->port))\r\ngoto dma_ignore_char;\r\nstatus &= ~(PE | FE);\r\n}\r\nif (status & PE)\r\nuart->port.icount.parity++;\r\nif (status & OE)\r\nuart->port.icount.overrun++;\r\nif (status & FE)\r\nuart->port.icount.frame++;\r\nstatus &= uart->port.read_status_mask;\r\nif (status & BI)\r\nflg = TTY_BREAK;\r\nelse if (status & PE)\r\nflg = TTY_PARITY;\r\nelse if (status & FE)\r\nflg = TTY_FRAME;\r\nelse\r\nflg = TTY_NORMAL;\r\nfor (i = uart->rx_dma_buf.tail; ; i++) {\r\nif (i >= UART_XMIT_SIZE)\r\ni = 0;\r\nif (i == uart->rx_dma_buf.head)\r\nbreak;\r\nif (!uart_handle_sysrq_char(&uart->port, uart->rx_dma_buf.buf[i]))\r\nuart_insert_char(&uart->port, status, OE,\r\nuart->rx_dma_buf.buf[i], flg);\r\n}\r\ndma_ignore_char:\r\ntty_flip_buffer_push(&uart->port.state->port);\r\n}\r\nvoid bfin_serial_rx_dma_timeout(struct bfin_serial_port *uart)\r\n{\r\nint x_pos, pos;\r\nunsigned long flags;\r\nspin_lock_irqsave(&uart->rx_lock, flags);\r\nuart->rx_dma_nrows = get_dma_curr_ycount(uart->rx_dma_channel);\r\nx_pos = get_dma_curr_xcount(uart->rx_dma_channel);\r\nuart->rx_dma_nrows = DMA_RX_YCOUNT - uart->rx_dma_nrows;\r\nif (uart->rx_dma_nrows == DMA_RX_YCOUNT || x_pos == 0)\r\nuart->rx_dma_nrows = 0;\r\nx_pos = DMA_RX_XCOUNT - x_pos;\r\nif (x_pos == DMA_RX_XCOUNT)\r\nx_pos = 0;\r\npos = uart->rx_dma_nrows * DMA_RX_XCOUNT + x_pos;\r\nif (pos > uart->rx_dma_buf.tail ||\r\nuart->rx_dma_nrows < (uart->rx_dma_buf.tail/DMA_RX_XCOUNT)) {\r\nuart->rx_dma_buf.head = pos;\r\nbfin_serial_dma_rx_chars(uart);\r\nuart->rx_dma_buf.tail = uart->rx_dma_buf.head;\r\n}\r\nspin_unlock_irqrestore(&uart->rx_lock, flags);\r\nmod_timer(&(uart->rx_dma_timer), jiffies + DMA_RX_FLUSH_JIFFIES);\r\n}\r\nstatic irqreturn_t bfin_serial_dma_tx_int(int irq, void *dev_id)\r\n{\r\nstruct bfin_serial_port *uart = dev_id;\r\nstruct circ_buf *xmit = &uart->port.state->xmit;\r\nspin_lock(&uart->port.lock);\r\nif (!(get_dma_curr_irqstat(uart->tx_dma_channel)&DMA_RUN)) {\r\ndisable_dma(uart->tx_dma_channel);\r\nclear_dma_irqstat(uart->tx_dma_channel);\r\nUART_CLEAR_IER(uart, ETBEI);\r\nuart->port.icount.tx += uart->tx_count;\r\nif (!(xmit->tail == 0 && xmit->head == 0)) {\r\nxmit->tail = (xmit->tail + uart->tx_count) & (UART_XMIT_SIZE - 1);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&uart->port);\r\n}\r\nbfin_serial_dma_tx_chars(uart);\r\n}\r\nspin_unlock(&uart->port.lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t bfin_serial_dma_rx_int(int irq, void *dev_id)\r\n{\r\nstruct bfin_serial_port *uart = dev_id;\r\nunsigned int irqstat;\r\nint x_pos, pos;\r\nspin_lock(&uart->rx_lock);\r\nirqstat = get_dma_curr_irqstat(uart->rx_dma_channel);\r\nclear_dma_irqstat(uart->rx_dma_channel);\r\nuart->rx_dma_nrows = get_dma_curr_ycount(uart->rx_dma_channel);\r\nx_pos = get_dma_curr_xcount(uart->rx_dma_channel);\r\nuart->rx_dma_nrows = DMA_RX_YCOUNT - uart->rx_dma_nrows;\r\nif (uart->rx_dma_nrows == DMA_RX_YCOUNT || x_pos == 0)\r\nuart->rx_dma_nrows = 0;\r\npos = uart->rx_dma_nrows * DMA_RX_XCOUNT;\r\nif (pos > uart->rx_dma_buf.tail ||\r\nuart->rx_dma_nrows < (uart->rx_dma_buf.tail/DMA_RX_XCOUNT)) {\r\nuart->rx_dma_buf.head = pos;\r\nbfin_serial_dma_rx_chars(uart);\r\nuart->rx_dma_buf.tail = uart->rx_dma_buf.head;\r\n}\r\nspin_unlock(&uart->rx_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int bfin_serial_tx_empty(struct uart_port *port)\r\n{\r\nstruct bfin_serial_port *uart = (struct bfin_serial_port *)port;\r\nunsigned int lsr;\r\nlsr = UART_GET_LSR(uart);\r\nif (lsr & TEMT)\r\nreturn TIOCSER_TEMT;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void bfin_serial_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct bfin_serial_port *uart = (struct bfin_serial_port *)port;\r\nu32 lcr = UART_GET_LCR(uart);\r\nif (break_state)\r\nlcr |= SB;\r\nelse\r\nlcr &= ~SB;\r\nUART_PUT_LCR(uart, lcr);\r\nSSYNC();\r\n}\r\nstatic int bfin_serial_startup(struct uart_port *port)\r\n{\r\nstruct bfin_serial_port *uart = (struct bfin_serial_port *)port;\r\n#ifdef CONFIG_SERIAL_BFIN_DMA\r\ndma_addr_t dma_handle;\r\nif (request_dma(uart->rx_dma_channel, "BFIN_UART_RX") < 0) {\r\nprintk(KERN_NOTICE "Unable to attach Blackfin UART RX DMA channel\n");\r\nreturn -EBUSY;\r\n}\r\nif (request_dma(uart->tx_dma_channel, "BFIN_UART_TX") < 0) {\r\nprintk(KERN_NOTICE "Unable to attach Blackfin UART TX DMA channel\n");\r\nfree_dma(uart->rx_dma_channel);\r\nreturn -EBUSY;\r\n}\r\nset_dma_callback(uart->rx_dma_channel, bfin_serial_dma_rx_int, uart);\r\nset_dma_callback(uart->tx_dma_channel, bfin_serial_dma_tx_int, uart);\r\nuart->rx_dma_buf.buf = (unsigned char *)dma_alloc_coherent(NULL, PAGE_SIZE, &dma_handle, GFP_DMA);\r\nuart->rx_dma_buf.head = 0;\r\nuart->rx_dma_buf.tail = 0;\r\nuart->rx_dma_nrows = 0;\r\nset_dma_config(uart->rx_dma_channel,\r\nset_bfin_dma_config(DIR_WRITE, DMA_FLOW_AUTO,\r\nINTR_ON_ROW, DIMENSION_2D,\r\nDATA_SIZE_8,\r\nDMA_SYNC_RESTART));\r\nset_dma_x_count(uart->rx_dma_channel, DMA_RX_XCOUNT);\r\nset_dma_x_modify(uart->rx_dma_channel, 1);\r\nset_dma_y_count(uart->rx_dma_channel, DMA_RX_YCOUNT);\r\nset_dma_y_modify(uart->rx_dma_channel, 1);\r\nset_dma_start_addr(uart->rx_dma_channel, (unsigned long)uart->rx_dma_buf.buf);\r\nenable_dma(uart->rx_dma_channel);\r\nuart->rx_dma_timer.data = (unsigned long)(uart);\r\nuart->rx_dma_timer.function = (void *)bfin_serial_rx_dma_timeout;\r\nuart->rx_dma_timer.expires = jiffies + DMA_RX_FLUSH_JIFFIES;\r\nadd_timer(&(uart->rx_dma_timer));\r\n#else\r\n# if defined(CONFIG_KGDB_SERIAL_CONSOLE) || \\r\ndefined(CONFIG_KGDB_SERIAL_CONSOLE_MODULE)\r\nif (kgdboc_port_line == uart->port.line && kgdboc_break_enabled)\r\nkgdboc_break_enabled = 0;\r\nelse {\r\n# endif\r\nif (request_irq(uart->rx_irq, bfin_serial_rx_int, 0,\r\n"BFIN_UART_RX", uart)) {\r\nprintk(KERN_NOTICE "Unable to attach BlackFin UART RX interrupt\n");\r\nreturn -EBUSY;\r\n}\r\nif (request_irq\r\n(uart->tx_irq, bfin_serial_tx_int, 0,\r\n"BFIN_UART_TX", uart)) {\r\nprintk(KERN_NOTICE "Unable to attach BlackFin UART TX interrupt\n");\r\nfree_irq(uart->rx_irq, uart);\r\nreturn -EBUSY;\r\n}\r\n# ifdef CONFIG_BF54x\r\n{\r\nunsigned uart_dma_ch_rx, uart_dma_ch_tx;\r\nswitch (uart->rx_irq) {\r\ncase IRQ_UART3_RX:\r\nuart_dma_ch_rx = CH_UART3_RX;\r\nuart_dma_ch_tx = CH_UART3_TX;\r\nbreak;\r\ncase IRQ_UART2_RX:\r\nuart_dma_ch_rx = CH_UART2_RX;\r\nuart_dma_ch_tx = CH_UART2_TX;\r\nbreak;\r\ndefault:\r\nuart_dma_ch_rx = uart_dma_ch_tx = 0;\r\nbreak;\r\n}\r\nif (uart_dma_ch_rx &&\r\nrequest_dma(uart_dma_ch_rx, "BFIN_UART_RX") < 0) {\r\nprintk(KERN_NOTICE"Fail to attach UART interrupt\n");\r\nfree_irq(uart->rx_irq, uart);\r\nfree_irq(uart->tx_irq, uart);\r\nreturn -EBUSY;\r\n}\r\nif (uart_dma_ch_tx &&\r\nrequest_dma(uart_dma_ch_tx, "BFIN_UART_TX") < 0) {\r\nprintk(KERN_NOTICE "Fail to attach UART interrupt\n");\r\nfree_dma(uart_dma_ch_rx);\r\nfree_irq(uart->rx_irq, uart);\r\nfree_irq(uart->tx_irq, uart);\r\nreturn -EBUSY;\r\n}\r\n}\r\n# endif\r\n# if defined(CONFIG_KGDB_SERIAL_CONSOLE) || \\r\ndefined(CONFIG_KGDB_SERIAL_CONSOLE_MODULE)\r\n}\r\n# endif\r\n#endif\r\n#ifdef CONFIG_SERIAL_BFIN_CTSRTS\r\nif (uart->cts_pin >= 0) {\r\nif (request_irq(gpio_to_irq(uart->cts_pin),\r\nbfin_serial_mctrl_cts_int,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |\r\n0, "BFIN_UART_CTS", uart)) {\r\nuart->cts_pin = -1;\r\npr_info("Unable to attach BlackFin UART CTS interrupt. So, disable it.\n");\r\n}\r\n}\r\nif (uart->rts_pin >= 0) {\r\nif (gpio_request(uart->rts_pin, DRIVER_NAME)) {\r\npr_info("fail to request RTS PIN at GPIO_%d\n", uart->rts_pin);\r\nuart->rts_pin = -1;\r\n} else\r\ngpio_direction_output(uart->rts_pin, 0);\r\n}\r\n#endif\r\n#ifdef CONFIG_SERIAL_BFIN_HARD_CTSRTS\r\nif (uart->cts_pin >= 0) {\r\nif (request_irq(uart->status_irq, bfin_serial_mctrl_cts_int,\r\n0, "BFIN_UART_MODEM_STATUS", uart)) {\r\nuart->cts_pin = -1;\r\ndev_info(port->dev, "Unable to attach BlackFin UART Modem Status interrupt.\n");\r\n}\r\nUART_PUT_MCR(uart, UART_GET_MCR(uart) | ACTS);\r\nUART_SET_IER(uart, EDSSI);\r\n}\r\n#endif\r\nUART_SET_IER(uart, ERBFI);\r\nreturn 0;\r\n}\r\nstatic void bfin_serial_shutdown(struct uart_port *port)\r\n{\r\nstruct bfin_serial_port *uart = (struct bfin_serial_port *)port;\r\n#ifdef CONFIG_SERIAL_BFIN_DMA\r\ndisable_dma(uart->tx_dma_channel);\r\nfree_dma(uart->tx_dma_channel);\r\ndisable_dma(uart->rx_dma_channel);\r\nfree_dma(uart->rx_dma_channel);\r\ndel_timer(&(uart->rx_dma_timer));\r\ndma_free_coherent(NULL, PAGE_SIZE, uart->rx_dma_buf.buf, 0);\r\n#else\r\n#ifdef CONFIG_BF54x\r\nswitch (uart->port.irq) {\r\ncase IRQ_UART3_RX:\r\nfree_dma(CH_UART3_RX);\r\nfree_dma(CH_UART3_TX);\r\nbreak;\r\ncase IRQ_UART2_RX:\r\nfree_dma(CH_UART2_RX);\r\nfree_dma(CH_UART2_TX);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n#endif\r\nfree_irq(uart->rx_irq, uart);\r\nfree_irq(uart->tx_irq, uart);\r\n#endif\r\n#ifdef CONFIG_SERIAL_BFIN_CTSRTS\r\nif (uart->cts_pin >= 0)\r\nfree_irq(gpio_to_irq(uart->cts_pin), uart);\r\nif (uart->rts_pin >= 0)\r\ngpio_free(uart->rts_pin);\r\n#endif\r\n#ifdef CONFIG_SERIAL_BFIN_HARD_CTSRTS\r\nif (uart->cts_pin >= 0)\r\nfree_irq(uart->status_irq, uart);\r\n#endif\r\n}\r\nstatic void\r\nbfin_serial_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct bfin_serial_port *uart = (struct bfin_serial_port *)port;\r\nunsigned long flags;\r\nunsigned int baud, quot;\r\nunsigned int ier, lcr = 0;\r\nunsigned long timeout;\r\n#ifdef CONFIG_SERIAL_BFIN_CTSRTS\r\nif (old == NULL && uart->cts_pin != -1)\r\ntermios->c_cflag |= CRTSCTS;\r\nelse if (uart->cts_pin == -1)\r\ntermios->c_cflag &= ~CRTSCTS;\r\n#endif\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS8:\r\nlcr = WLS(8);\r\nbreak;\r\ncase CS7:\r\nlcr = WLS(7);\r\nbreak;\r\ncase CS6:\r\nlcr = WLS(6);\r\nbreak;\r\ncase CS5:\r\nlcr = WLS(5);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: word length not supported\n",\r\n__func__);\r\n}\r\nif (termios->c_cflag & CSTOPB) {\r\nif (ANOMALY_05000231)\r\nprintk(KERN_WARNING "STOP bits other than 1 is not "\r\n"supported in case of anomaly 05000231.\n");\r\nelse\r\nlcr |= STB;\r\n}\r\nif (termios->c_cflag & PARENB)\r\nlcr |= PEN;\r\nif (!(termios->c_cflag & PARODD))\r\nlcr |= EPS;\r\nif (termios->c_cflag & CMSPAR)\r\nlcr |= STP;\r\nspin_lock_irqsave(&uart->port.lock, flags);\r\nport->read_status_mask = OE;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= (FE | PE);\r\nif (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))\r\nport->read_status_mask |= BI;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= FE | PE;\r\nif (termios->c_iflag & IGNBRK) {\r\nport->ignore_status_mask |= BI;\r\nif (termios->c_iflag & IGNPAR)\r\nport->ignore_status_mask |= OE;\r\n}\r\nbaud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);\r\nquot = uart_get_divisor(port, baud);\r\nif (termios->c_line != N_IRDA)\r\nquot -= ANOMALY_05000230;\r\nUART_SET_ANOMALY_THRESHOLD(uart, USEC_PER_SEC / baud * 15);\r\ntimeout = jiffies + msecs_to_jiffies(10);\r\nwhile (UART_GET_GCTL(uart) & UCEN && !(UART_GET_LSR(uart) & TEMT))\r\nif (time_after(jiffies, timeout)) {\r\ndev_warn(port->dev, "timeout waiting for TX buffer empty\n");\r\nbreak;\r\n}\r\nier = UART_GET_IER(uart);\r\nUART_PUT_GCTL(uart, UART_GET_GCTL(uart) & ~UCEN);\r\nUART_DISABLE_INTS(uart);\r\nUART_SET_DLAB(uart);\r\nUART_PUT_CLK(uart, quot);\r\nSSYNC();\r\nUART_CLEAR_DLAB(uart);\r\nUART_PUT_LCR(uart, (UART_GET_LCR(uart) & ~LCR_MASK) | lcr);\r\nUART_ENABLE_INTS(uart, ier);\r\nUART_PUT_GCTL(uart, UART_GET_GCTL(uart) | UCEN);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nspin_unlock_irqrestore(&uart->port.lock, flags);\r\n}\r\nstatic const char *bfin_serial_type(struct uart_port *port)\r\n{\r\nstruct bfin_serial_port *uart = (struct bfin_serial_port *)port;\r\nreturn uart->port.type == PORT_BFIN ? "BFIN-UART" : NULL;\r\n}\r\nstatic void bfin_serial_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int bfin_serial_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void bfin_serial_config_port(struct uart_port *port, int flags)\r\n{\r\nstruct bfin_serial_port *uart = (struct bfin_serial_port *)port;\r\nif (flags & UART_CONFIG_TYPE &&\r\nbfin_serial_request_port(&uart->port) == 0)\r\nuart->port.type = PORT_BFIN;\r\n}\r\nstatic int\r\nbfin_serial_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nreturn 0;\r\n}\r\nstatic void bfin_serial_set_ldisc(struct uart_port *port,\r\nstruct ktermios *termios)\r\n{\r\nstruct bfin_serial_port *uart = (struct bfin_serial_port *)port;\r\nunsigned int val;\r\nswitch (termios->c_line) {\r\ncase N_IRDA:\r\nval = UART_GET_GCTL(uart);\r\nval |= (UMOD_IRDA | RPOLC);\r\nUART_PUT_GCTL(uart, val);\r\nbreak;\r\ndefault:\r\nval = UART_GET_GCTL(uart);\r\nval &= ~(UMOD_MASK | RPOLC);\r\nUART_PUT_GCTL(uart, val);\r\n}\r\n}\r\nstatic void bfin_serial_reset_irda(struct uart_port *port)\r\n{\r\nstruct bfin_serial_port *uart = (struct bfin_serial_port *)port;\r\nunsigned int val;\r\nval = UART_GET_GCTL(uart);\r\nval &= ~(UMOD_MASK | RPOLC);\r\nUART_PUT_GCTL(uart, val);\r\nSSYNC();\r\nval |= (UMOD_IRDA | RPOLC);\r\nUART_PUT_GCTL(uart, val);\r\nSSYNC();\r\n}\r\nstatic void bfin_serial_poll_put_char(struct uart_port *port, unsigned char chr)\r\n{\r\nstruct bfin_serial_port *uart = (struct bfin_serial_port *)port;\r\nwhile (!(UART_GET_LSR(uart) & THRE))\r\ncpu_relax();\r\nUART_CLEAR_DLAB(uart);\r\nUART_PUT_CHAR(uart, (unsigned char)chr);\r\n}\r\nstatic int bfin_serial_poll_get_char(struct uart_port *port)\r\n{\r\nstruct bfin_serial_port *uart = (struct bfin_serial_port *)port;\r\nunsigned char chr;\r\nwhile (!(UART_GET_LSR(uart) & DR))\r\ncpu_relax();\r\nUART_CLEAR_DLAB(uart);\r\nchr = UART_GET_CHAR(uart);\r\nreturn chr;\r\n}\r\nstatic void __init\r\nbfin_serial_console_get_options(struct bfin_serial_port *uart, int *baud,\r\nint *parity, int *bits)\r\n{\r\nunsigned int status;\r\nstatus = UART_GET_IER(uart) & (ERBFI | ETBEI);\r\nif (status == (ERBFI | ETBEI)) {\r\nu32 lcr, clk;\r\nlcr = UART_GET_LCR(uart);\r\n*parity = 'n';\r\nif (lcr & PEN) {\r\nif (lcr & EPS)\r\n*parity = 'e';\r\nelse\r\n*parity = 'o';\r\n}\r\n*bits = ((lcr & WLS_MASK) >> WLS_OFFSET) + 5;\r\nUART_SET_DLAB(uart);\r\nclk = UART_GET_CLK(uart);\r\nUART_CLEAR_DLAB(uart);\r\n*baud = get_sclk() / (16*clk);\r\n}\r\npr_debug("%s:baud = %d, parity = %c, bits= %d\n", __func__, *baud, *parity, *bits);\r\n}\r\nstatic void bfin_serial_console_putchar(struct uart_port *port, int ch)\r\n{\r\nstruct bfin_serial_port *uart = (struct bfin_serial_port *)port;\r\nwhile (!(UART_GET_LSR(uart) & THRE))\r\nbarrier();\r\nUART_PUT_CHAR(uart, ch);\r\n}\r\nstatic void\r\nbfin_serial_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct bfin_serial_port *uart = bfin_serial_ports[co->index];\r\nunsigned long flags;\r\nspin_lock_irqsave(&uart->port.lock, flags);\r\nuart_console_write(&uart->port, s, count, bfin_serial_console_putchar);\r\nspin_unlock_irqrestore(&uart->port.lock, flags);\r\n}\r\nstatic int __init\r\nbfin_serial_console_setup(struct console *co, char *options)\r\n{\r\nstruct bfin_serial_port *uart;\r\nint baud = 57600;\r\nint bits = 8;\r\nint parity = 'n';\r\n# if defined(CONFIG_SERIAL_BFIN_CTSRTS) || \\r\ndefined(CONFIG_SERIAL_BFIN_HARD_CTSRTS)\r\nint flow = 'r';\r\n# else\r\nint flow = 'n';\r\n# endif\r\nif (co->index < 0 || co->index >= BFIN_UART_NR_PORTS)\r\nreturn -ENODEV;\r\nuart = bfin_serial_ports[co->index];\r\nif (!uart)\r\nreturn -ENODEV;\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nelse\r\nbfin_serial_console_get_options(uart, &baud, &parity, &bits);\r\nreturn uart_set_options(&uart->port, co, baud, parity, bits, flow);\r\n}\r\nstatic void\r\nbfin_earlyprintk_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nunsigned long flags;\r\nif (bfin_earlyprintk_port.port.line != co->index)\r\nreturn;\r\nspin_lock_irqsave(&bfin_earlyprintk_port.port.lock, flags);\r\nuart_console_write(&bfin_earlyprintk_port.port, s, count,\r\nbfin_serial_console_putchar);\r\nspin_unlock_irqrestore(&bfin_earlyprintk_port.port.lock, flags);\r\n}\r\nstatic int bfin_serial_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct bfin_serial_port *uart = platform_get_drvdata(pdev);\r\nreturn uart_suspend_port(&bfin_serial_reg, &uart->port);\r\n}\r\nstatic int bfin_serial_resume(struct platform_device *pdev)\r\n{\r\nstruct bfin_serial_port *uart = platform_get_drvdata(pdev);\r\nreturn uart_resume_port(&bfin_serial_reg, &uart->port);\r\n}\r\nstatic int bfin_serial_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct bfin_serial_port *uart = NULL;\r\nint ret = 0;\r\nif (pdev->id < 0 || pdev->id >= BFIN_UART_NR_PORTS) {\r\ndev_err(&pdev->dev, "Wrong bfin uart platform device id.\n");\r\nreturn -ENOENT;\r\n}\r\nif (bfin_serial_ports[pdev->id] == NULL) {\r\nuart = kzalloc(sizeof(*uart), GFP_KERNEL);\r\nif (!uart) {\r\ndev_err(&pdev->dev,\r\n"fail to malloc bfin_serial_port\n");\r\nreturn -ENOMEM;\r\n}\r\nbfin_serial_ports[pdev->id] = uart;\r\n#ifdef CONFIG_EARLY_PRINTK\r\nif (!(bfin_earlyprintk_port.port.membase\r\n&& bfin_earlyprintk_port.port.line == pdev->id)) {\r\n#endif\r\nret = peripheral_request_list(\r\ndev_get_platdata(&pdev->dev),\r\nDRIVER_NAME);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"fail to request bfin serial peripherals\n");\r\ngoto out_error_free_mem;\r\n}\r\n#ifdef CONFIG_EARLY_PRINTK\r\n}\r\n#endif\r\nspin_lock_init(&uart->port.lock);\r\nuart->port.uartclk = get_sclk();\r\nuart->port.fifosize = BFIN_UART_TX_FIFO_SIZE;\r\nuart->port.ops = &bfin_serial_pops;\r\nuart->port.line = pdev->id;\r\nuart->port.iotype = UPIO_MEM;\r\nuart->port.flags = UPF_BOOT_AUTOCONF;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");\r\nret = -ENOENT;\r\ngoto out_error_free_peripherals;\r\n}\r\nuart->port.membase = ioremap(res->start, resource_size(res));\r\nif (!uart->port.membase) {\r\ndev_err(&pdev->dev, "Cannot map uart IO\n");\r\nret = -ENXIO;\r\ngoto out_error_free_peripherals;\r\n}\r\nuart->port.mapbase = res->start;\r\nuart->tx_irq = platform_get_irq(pdev, 0);\r\nif (uart->tx_irq < 0) {\r\ndev_err(&pdev->dev, "No uart TX IRQ specified\n");\r\nret = -ENOENT;\r\ngoto out_error_unmap;\r\n}\r\nuart->rx_irq = platform_get_irq(pdev, 1);\r\nif (uart->rx_irq < 0) {\r\ndev_err(&pdev->dev, "No uart RX IRQ specified\n");\r\nret = -ENOENT;\r\ngoto out_error_unmap;\r\n}\r\nuart->port.irq = uart->rx_irq;\r\nuart->status_irq = platform_get_irq(pdev, 2);\r\nif (uart->status_irq < 0) {\r\ndev_err(&pdev->dev, "No uart status IRQ specified\n");\r\nret = -ENOENT;\r\ngoto out_error_unmap;\r\n}\r\n#ifdef CONFIG_SERIAL_BFIN_DMA\r\nspin_lock_init(&uart->rx_lock);\r\nuart->tx_done = 1;\r\nuart->tx_count = 0;\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "No uart TX DMA channel specified\n");\r\nret = -ENOENT;\r\ngoto out_error_unmap;\r\n}\r\nuart->tx_dma_channel = res->start;\r\nres = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "No uart RX DMA channel specified\n");\r\nret = -ENOENT;\r\ngoto out_error_unmap;\r\n}\r\nuart->rx_dma_channel = res->start;\r\ninit_timer(&(uart->rx_dma_timer));\r\n#endif\r\n#if defined(CONFIG_SERIAL_BFIN_CTSRTS) || \\r\ndefined(CONFIG_SERIAL_BFIN_HARD_CTSRTS)\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (res == NULL)\r\nuart->cts_pin = -1;\r\nelse\r\nuart->cts_pin = res->start;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 1);\r\nif (res == NULL)\r\nuart->rts_pin = -1;\r\nelse\r\nuart->rts_pin = res->start;\r\n#endif\r\n}\r\n#ifdef CONFIG_SERIAL_BFIN_CONSOLE\r\nif (!is_early_platform_device(pdev)) {\r\n#endif\r\nuart = bfin_serial_ports[pdev->id];\r\nuart->port.dev = &pdev->dev;\r\ndev_set_drvdata(&pdev->dev, uart);\r\nret = uart_add_one_port(&bfin_serial_reg, &uart->port);\r\n#ifdef CONFIG_SERIAL_BFIN_CONSOLE\r\n}\r\n#endif\r\nif (!ret)\r\nreturn 0;\r\nif (uart) {\r\nout_error_unmap:\r\niounmap(uart->port.membase);\r\nout_error_free_peripherals:\r\nperipheral_free_list(dev_get_platdata(&pdev->dev));\r\nout_error_free_mem:\r\nkfree(uart);\r\nbfin_serial_ports[pdev->id] = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int bfin_serial_remove(struct platform_device *pdev)\r\n{\r\nstruct bfin_serial_port *uart = platform_get_drvdata(pdev);\r\ndev_set_drvdata(&pdev->dev, NULL);\r\nif (uart) {\r\nuart_remove_one_port(&bfin_serial_reg, &uart->port);\r\niounmap(uart->port.membase);\r\nperipheral_free_list(dev_get_platdata(&pdev->dev));\r\nkfree(uart);\r\nbfin_serial_ports[pdev->id] = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init bfin_serial_rs_console_init(void)\r\n{\r\nearly_platform_driver_register(&early_bfin_serial_driver, DRIVER_NAME);\r\nearly_platform_driver_probe(CLASS_BFIN_CONSOLE, BFIN_UART_NR_PORTS, 0);\r\nregister_console(&bfin_serial_console);\r\nreturn 0;\r\n}\r\nstatic int bfin_earlyprintk_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint ret;\r\nif (pdev->id < 0 || pdev->id >= BFIN_UART_NR_PORTS) {\r\ndev_err(&pdev->dev, "Wrong earlyprintk platform device id.\n");\r\nreturn -ENOENT;\r\n}\r\nret = peripheral_request_list(dev_get_platdata(&pdev->dev),\r\nDRIVER_NAME);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"fail to request bfin serial peripherals\n");\r\nreturn ret;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");\r\nret = -ENOENT;\r\ngoto out_error_free_peripherals;\r\n}\r\nbfin_earlyprintk_port.port.membase = ioremap(res->start,\r\nresource_size(res));\r\nif (!bfin_earlyprintk_port.port.membase) {\r\ndev_err(&pdev->dev, "Cannot map uart IO\n");\r\nret = -ENXIO;\r\ngoto out_error_free_peripherals;\r\n}\r\nbfin_earlyprintk_port.port.mapbase = res->start;\r\nbfin_earlyprintk_port.port.line = pdev->id;\r\nbfin_earlyprintk_port.port.uartclk = get_sclk();\r\nbfin_earlyprintk_port.port.fifosize = BFIN_UART_TX_FIFO_SIZE;\r\nspin_lock_init(&bfin_earlyprintk_port.port.lock);\r\nreturn 0;\r\nout_error_free_peripherals:\r\nperipheral_free_list(dev_get_platdata(&pdev->dev));\r\nreturn ret;\r\n}\r\nstruct console __init *bfin_earlyserial_init(unsigned int port,\r\nunsigned int cflag)\r\n{\r\nstruct ktermios t;\r\nchar port_name[20];\r\nif (port < 0 || port >= BFIN_UART_NR_PORTS)\r\nreturn NULL;\r\nsnprintf(port_name, 20, DRIVER_NAME ".%d", port);\r\nearly_platform_driver_register(&early_bfin_earlyprintk_driver,\r\nport_name);\r\nearly_platform_driver_probe(CLASS_BFIN_EARLYPRINTK, 1, 0);\r\nif (!bfin_earlyprintk_port.port.membase)\r\nreturn NULL;\r\n#ifdef CONFIG_SERIAL_BFIN_CONSOLE\r\nbfin_serial_console.flags &= ~CON_PRINTBUFFER;\r\n#endif\r\nbfin_early_serial_console.index = port;\r\nt.c_cflag = cflag;\r\nt.c_iflag = 0;\r\nt.c_oflag = 0;\r\nt.c_lflag = ICANON;\r\nt.c_line = port;\r\nbfin_serial_set_termios(&bfin_earlyprintk_port.port, &t, &t);\r\nreturn &bfin_early_serial_console;\r\n}\r\nstatic int __init bfin_serial_init(void)\r\n{\r\nint ret;\r\npr_info("Blackfin serial driver\n");\r\nret = uart_register_driver(&bfin_serial_reg);\r\nif (ret) {\r\npr_err("failed to register %s:%d\n",\r\nbfin_serial_reg.driver_name, ret);\r\n}\r\nret = platform_driver_register(&bfin_serial_driver);\r\nif (ret) {\r\npr_err("fail to register bfin uart\n");\r\nuart_unregister_driver(&bfin_serial_reg);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit bfin_serial_exit(void)\r\n{\r\nplatform_driver_unregister(&bfin_serial_driver);\r\nuart_unregister_driver(&bfin_serial_reg);\r\n}
