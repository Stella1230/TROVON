static int pxa_videobuf_setup(struct videobuf_queue *vq, unsigned int *count,\r\nunsigned int *size)\r\n{\r\nstruct soc_camera_device *icd = vq->priv_data;\r\ndev_dbg(icd->parent, "count=%d, size=%d\n", *count, *size);\r\n*size = icd->sizeimage;\r\nif (0 == *count)\r\n*count = 32;\r\nif (*size * *count > vid_limit * 1024 * 1024)\r\n*count = (vid_limit * 1024 * 1024) / *size;\r\nreturn 0;\r\n}\r\nstatic void free_buffer(struct videobuf_queue *vq, struct pxa_buffer *buf)\r\n{\r\nstruct soc_camera_device *icd = vq->priv_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(&buf->vb);\r\nint i;\r\nBUG_ON(in_interrupt());\r\ndev_dbg(icd->parent, "%s (vb=0x%p) 0x%08lx %d\n", __func__,\r\n&buf->vb, buf->vb.baddr, buf->vb.bsize);\r\nvideobuf_waiton(vq, &buf->vb, 0, 0);\r\nvideobuf_dma_unmap(vq->dev, dma);\r\nvideobuf_dma_free(dma);\r\nfor (i = 0; i < ARRAY_SIZE(buf->dmas); i++) {\r\nif (buf->dmas[i].sg_cpu)\r\ndma_free_coherent(ici->v4l2_dev.dev,\r\nbuf->dmas[i].sg_size,\r\nbuf->dmas[i].sg_cpu,\r\nbuf->dmas[i].sg_dma);\r\nbuf->dmas[i].sg_cpu = NULL;\r\n}\r\nbuf->vb.state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nstatic int calculate_dma_sglen(struct scatterlist *sglist, int sglen,\r\nint sg_first_ofs, int size)\r\n{\r\nint i, offset, dma_len, xfer_len;\r\nstruct scatterlist *sg;\r\noffset = sg_first_ofs;\r\nfor_each_sg(sglist, sg, sglen, i) {\r\ndma_len = sg_dma_len(sg);\r\nxfer_len = roundup(min(dma_len - offset, size), 8);\r\nsize = max(0, size - xfer_len);\r\noffset = 0;\r\nif (size == 0)\r\nbreak;\r\n}\r\nBUG_ON(size != 0);\r\nreturn i + 1;\r\n}\r\nstatic int pxa_init_dma_channel(struct pxa_camera_dev *pcdev,\r\nstruct pxa_buffer *buf,\r\nstruct videobuf_dmabuf *dma, int channel,\r\nint cibr, int size,\r\nstruct scatterlist **sg_first, int *sg_first_ofs)\r\n{\r\nstruct pxa_cam_dma *pxa_dma = &buf->dmas[channel];\r\nstruct device *dev = pcdev->soc_host.v4l2_dev.dev;\r\nstruct scatterlist *sg;\r\nint i, offset, sglen;\r\nint dma_len = 0, xfer_len = 0;\r\nif (pxa_dma->sg_cpu)\r\ndma_free_coherent(dev, pxa_dma->sg_size,\r\npxa_dma->sg_cpu, pxa_dma->sg_dma);\r\nsglen = calculate_dma_sglen(*sg_first, dma->sglen,\r\n*sg_first_ofs, size);\r\npxa_dma->sg_size = (sglen + 1) * sizeof(struct pxa_dma_desc);\r\npxa_dma->sg_cpu = dma_alloc_coherent(dev, pxa_dma->sg_size,\r\n&pxa_dma->sg_dma, GFP_KERNEL);\r\nif (!pxa_dma->sg_cpu)\r\nreturn -ENOMEM;\r\npxa_dma->sglen = sglen;\r\noffset = *sg_first_ofs;\r\ndev_dbg(dev, "DMA: sg_first=%p, sglen=%d, ofs=%d, dma.desc=%x\n",\r\n*sg_first, sglen, *sg_first_ofs, pxa_dma->sg_dma);\r\nfor_each_sg(*sg_first, sg, sglen, i) {\r\ndma_len = sg_dma_len(sg);\r\nxfer_len = roundup(min(dma_len - offset, size), 8);\r\nsize = max(0, size - xfer_len);\r\npxa_dma->sg_cpu[i].dsadr = pcdev->res->start + cibr;\r\npxa_dma->sg_cpu[i].dtadr = sg_dma_address(sg) + offset;\r\npxa_dma->sg_cpu[i].dcmd =\r\nDCMD_FLOWSRC | DCMD_BURST8 | DCMD_INCTRGADDR | xfer_len;\r\n#ifdef DEBUG\r\nif (!i)\r\npxa_dma->sg_cpu[i].dcmd |= DCMD_STARTIRQEN;\r\n#endif\r\npxa_dma->sg_cpu[i].ddadr =\r\npxa_dma->sg_dma + (i + 1) * sizeof(struct pxa_dma_desc);\r\ndev_vdbg(dev, "DMA: desc.%08x->@phys=0x%08x, len=%d\n",\r\npxa_dma->sg_dma + i * sizeof(struct pxa_dma_desc),\r\nsg_dma_address(sg) + offset, xfer_len);\r\noffset = 0;\r\nif (size == 0)\r\nbreak;\r\n}\r\npxa_dma->sg_cpu[sglen].ddadr = DDADR_STOP;\r\npxa_dma->sg_cpu[sglen].dcmd = DCMD_FLOWSRC | DCMD_BURST8 | DCMD_ENDIRQEN;\r\nif (xfer_len >= dma_len) {\r\n*sg_first_ofs = xfer_len - dma_len;\r\n*sg_first = sg_next(sg);\r\n} else {\r\n*sg_first_ofs = xfer_len;\r\n*sg_first = sg;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pxa_videobuf_set_actdma(struct pxa_camera_dev *pcdev,\r\nstruct pxa_buffer *buf)\r\n{\r\nbuf->active_dma = DMA_Y;\r\nif (pcdev->channels == 3)\r\nbuf->active_dma |= DMA_U | DMA_V;\r\n}\r\nstatic int pxa_videobuf_prepare(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb, enum v4l2_field field)\r\n{\r\nstruct soc_camera_device *icd = vq->priv_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nstruct device *dev = pcdev->soc_host.v4l2_dev.dev;\r\nstruct pxa_buffer *buf = container_of(vb, struct pxa_buffer, vb);\r\nint ret;\r\nint size_y, size_u = 0, size_v = 0;\r\ndev_dbg(dev, "%s (vb=0x%p) 0x%08lx %d\n", __func__,\r\nvb, vb->baddr, vb->bsize);\r\nWARN_ON(!list_empty(&vb->queue));\r\n#ifdef DEBUG\r\nmemset((void *)vb->baddr, 0xaa, vb->bsize);\r\n#endif\r\nBUG_ON(NULL == icd->current_fmt);\r\nbuf->inwork = 1;\r\nif (buf->code != icd->current_fmt->code ||\r\nvb->width != icd->user_width ||\r\nvb->height != icd->user_height ||\r\nvb->field != field) {\r\nbuf->code = icd->current_fmt->code;\r\nvb->width = icd->user_width;\r\nvb->height = icd->user_height;\r\nvb->field = field;\r\nvb->state = VIDEOBUF_NEEDS_INIT;\r\n}\r\nvb->size = icd->sizeimage;\r\nif (0 != vb->baddr && vb->bsize < vb->size) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (vb->state == VIDEOBUF_NEEDS_INIT) {\r\nint size = vb->size;\r\nint next_ofs = 0;\r\nstruct videobuf_dmabuf *dma = videobuf_to_dma(vb);\r\nstruct scatterlist *sg;\r\nret = videobuf_iolock(vq, vb, NULL);\r\nif (ret)\r\ngoto fail;\r\nif (pcdev->channels == 3) {\r\nsize_y = size / 2;\r\nsize_u = size_v = size / 4;\r\n} else {\r\nsize_y = size;\r\n}\r\nsg = dma->sglist;\r\nret = pxa_init_dma_channel(pcdev, buf, dma, 0, CIBR0, size_y,\r\n&sg, &next_ofs);\r\nif (ret) {\r\ndev_err(dev, "DMA initialization for Y/RGB failed\n");\r\ngoto fail;\r\n}\r\nif (size_u)\r\nret = pxa_init_dma_channel(pcdev, buf, dma, 1, CIBR1,\r\nsize_u, &sg, &next_ofs);\r\nif (ret) {\r\ndev_err(dev, "DMA initialization for U failed\n");\r\ngoto fail_u;\r\n}\r\nif (size_v)\r\nret = pxa_init_dma_channel(pcdev, buf, dma, 2, CIBR2,\r\nsize_v, &sg, &next_ofs);\r\nif (ret) {\r\ndev_err(dev, "DMA initialization for V failed\n");\r\ngoto fail_v;\r\n}\r\nvb->state = VIDEOBUF_PREPARED;\r\n}\r\nbuf->inwork = 0;\r\npxa_videobuf_set_actdma(pcdev, buf);\r\nreturn 0;\r\nfail_v:\r\ndma_free_coherent(dev, buf->dmas[1].sg_size,\r\nbuf->dmas[1].sg_cpu, buf->dmas[1].sg_dma);\r\nfail_u:\r\ndma_free_coherent(dev, buf->dmas[0].sg_size,\r\nbuf->dmas[0].sg_cpu, buf->dmas[0].sg_dma);\r\nfail:\r\nfree_buffer(vq, buf);\r\nout:\r\nbuf->inwork = 0;\r\nreturn ret;\r\n}\r\nstatic void pxa_dma_start_channels(struct pxa_camera_dev *pcdev)\r\n{\r\nint i;\r\nstruct pxa_buffer *active;\r\nactive = pcdev->active;\r\nfor (i = 0; i < pcdev->channels; i++) {\r\ndev_dbg(pcdev->soc_host.v4l2_dev.dev,\r\n"%s (channel=%d) ddadr=%08x\n", __func__,\r\ni, active->dmas[i].sg_dma);\r\nDDADR(pcdev->dma_chans[i]) = active->dmas[i].sg_dma;\r\nDCSR(pcdev->dma_chans[i]) = DCSR_RUN;\r\n}\r\n}\r\nstatic void pxa_dma_stop_channels(struct pxa_camera_dev *pcdev)\r\n{\r\nint i;\r\nfor (i = 0; i < pcdev->channels; i++) {\r\ndev_dbg(pcdev->soc_host.v4l2_dev.dev,\r\n"%s (channel=%d)\n", __func__, i);\r\nDCSR(pcdev->dma_chans[i]) = 0;\r\n}\r\n}\r\nstatic void pxa_dma_add_tail_buf(struct pxa_camera_dev *pcdev,\r\nstruct pxa_buffer *buf)\r\n{\r\nint i;\r\nstruct pxa_dma_desc *buf_last_desc;\r\nfor (i = 0; i < pcdev->channels; i++) {\r\nbuf_last_desc = buf->dmas[i].sg_cpu + buf->dmas[i].sglen;\r\nbuf_last_desc->ddadr = DDADR_STOP;\r\nif (pcdev->sg_tail[i])\r\npcdev->sg_tail[i]->ddadr = buf->dmas[i].sg_dma;\r\npcdev->sg_tail[i] = buf_last_desc;\r\n}\r\n}\r\nstatic void pxa_camera_start_capture(struct pxa_camera_dev *pcdev)\r\n{\r\nunsigned long cicr0;\r\ndev_dbg(pcdev->soc_host.v4l2_dev.dev, "%s\n", __func__);\r\ncicr0 = __raw_readl(pcdev->base + CICR0) | CICR0_ENB;\r\ncicr0 &= ~CICR0_EOFM;\r\n__raw_writel(cicr0, pcdev->base + CICR0);\r\n}\r\nstatic void pxa_camera_stop_capture(struct pxa_camera_dev *pcdev)\r\n{\r\nunsigned long cicr0;\r\npxa_dma_stop_channels(pcdev);\r\ncicr0 = __raw_readl(pcdev->base + CICR0) & ~CICR0_ENB;\r\n__raw_writel(cicr0, pcdev->base + CICR0);\r\npcdev->active = NULL;\r\ndev_dbg(pcdev->soc_host.v4l2_dev.dev, "%s\n", __func__);\r\n}\r\nstatic void pxa_videobuf_queue(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct soc_camera_device *icd = vq->priv_data;\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nstruct pxa_buffer *buf = container_of(vb, struct pxa_buffer, vb);\r\ndev_dbg(icd->parent, "%s (vb=0x%p) 0x%08lx %d active=%p\n",\r\n__func__, vb, vb->baddr, vb->bsize, pcdev->active);\r\nlist_add_tail(&vb->queue, &pcdev->capture);\r\nvb->state = VIDEOBUF_ACTIVE;\r\npxa_dma_add_tail_buf(pcdev, buf);\r\nif (!pcdev->active)\r\npxa_camera_start_capture(pcdev);\r\n}\r\nstatic void pxa_videobuf_release(struct videobuf_queue *vq,\r\nstruct videobuf_buffer *vb)\r\n{\r\nstruct pxa_buffer *buf = container_of(vb, struct pxa_buffer, vb);\r\n#ifdef DEBUG\r\nstruct soc_camera_device *icd = vq->priv_data;\r\nstruct device *dev = icd->parent;\r\ndev_dbg(dev, "%s (vb=0x%p) 0x%08lx %d\n", __func__,\r\nvb, vb->baddr, vb->bsize);\r\nswitch (vb->state) {\r\ncase VIDEOBUF_ACTIVE:\r\ndev_dbg(dev, "%s (active)\n", __func__);\r\nbreak;\r\ncase VIDEOBUF_QUEUED:\r\ndev_dbg(dev, "%s (queued)\n", __func__);\r\nbreak;\r\ncase VIDEOBUF_PREPARED:\r\ndev_dbg(dev, "%s (prepared)\n", __func__);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "%s (unknown)\n", __func__);\r\nbreak;\r\n}\r\n#endif\r\nfree_buffer(vq, buf);\r\n}\r\nstatic void pxa_camera_wakeup(struct pxa_camera_dev *pcdev,\r\nstruct videobuf_buffer *vb,\r\nstruct pxa_buffer *buf)\r\n{\r\nint i;\r\nlist_del_init(&vb->queue);\r\nvb->state = VIDEOBUF_DONE;\r\nv4l2_get_timestamp(&vb->ts);\r\nvb->field_count++;\r\nwake_up(&vb->done);\r\ndev_dbg(pcdev->soc_host.v4l2_dev.dev, "%s dequeud buffer (vb=0x%p)\n",\r\n__func__, vb);\r\nif (list_empty(&pcdev->capture)) {\r\npxa_camera_stop_capture(pcdev);\r\nfor (i = 0; i < pcdev->channels; i++)\r\npcdev->sg_tail[i] = NULL;\r\nreturn;\r\n}\r\npcdev->active = list_entry(pcdev->capture.next,\r\nstruct pxa_buffer, vb.queue);\r\n}\r\nstatic void pxa_camera_check_link_miss(struct pxa_camera_dev *pcdev)\r\n{\r\nint i, is_dma_stopped = 1;\r\nfor (i = 0; i < pcdev->channels; i++)\r\nif (DDADR(pcdev->dma_chans[i]) != DDADR_STOP)\r\nis_dma_stopped = 0;\r\ndev_dbg(pcdev->soc_host.v4l2_dev.dev,\r\n"%s : top queued buffer=%p, dma_stopped=%d\n",\r\n__func__, pcdev->active, is_dma_stopped);\r\nif (pcdev->active && is_dma_stopped)\r\npxa_camera_start_capture(pcdev);\r\n}\r\nstatic void pxa_camera_dma_irq(int channel, struct pxa_camera_dev *pcdev,\r\nenum pxa_camera_active_dma act_dma)\r\n{\r\nstruct device *dev = pcdev->soc_host.v4l2_dev.dev;\r\nstruct pxa_buffer *buf;\r\nunsigned long flags;\r\nu32 status, camera_status, overrun;\r\nstruct videobuf_buffer *vb;\r\nspin_lock_irqsave(&pcdev->lock, flags);\r\nstatus = DCSR(channel);\r\nDCSR(channel) = status;\r\ncamera_status = __raw_readl(pcdev->base + CISR);\r\noverrun = CISR_IFO_0;\r\nif (pcdev->channels == 3)\r\noverrun |= CISR_IFO_1 | CISR_IFO_2;\r\nif (status & DCSR_BUSERR) {\r\ndev_err(dev, "DMA Bus Error IRQ!\n");\r\ngoto out;\r\n}\r\nif (!(status & (DCSR_ENDINTR | DCSR_STARTINTR))) {\r\ndev_err(dev, "Unknown DMA IRQ source, status: 0x%08x\n",\r\nstatus);\r\ngoto out;\r\n}\r\nif (!pcdev->active)\r\ngoto out;\r\nvb = &pcdev->active->vb;\r\nbuf = container_of(vb, struct pxa_buffer, vb);\r\nWARN_ON(buf->inwork || list_empty(&vb->queue));\r\ndev_dbg(dev, "%s channel=%d %s%s(vb=0x%p) dma.desc=%x\n",\r\n__func__, channel, status & DCSR_STARTINTR ? "SOF " : "",\r\nstatus & DCSR_ENDINTR ? "EOF " : "", vb, DDADR(channel));\r\nif (status & DCSR_ENDINTR) {\r\nif (camera_status & overrun &&\r\n!list_is_last(pcdev->capture.next, &pcdev->capture)) {\r\ndev_dbg(dev, "FIFO overrun! CISR: %x\n",\r\ncamera_status);\r\npxa_camera_stop_capture(pcdev);\r\npxa_camera_start_capture(pcdev);\r\ngoto out;\r\n}\r\nbuf->active_dma &= ~act_dma;\r\nif (!buf->active_dma) {\r\npxa_camera_wakeup(pcdev, vb, buf);\r\npxa_camera_check_link_miss(pcdev);\r\n}\r\n}\r\nout:\r\nspin_unlock_irqrestore(&pcdev->lock, flags);\r\n}\r\nstatic void pxa_camera_dma_irq_y(int channel, void *data)\r\n{\r\nstruct pxa_camera_dev *pcdev = data;\r\npxa_camera_dma_irq(channel, pcdev, DMA_Y);\r\n}\r\nstatic void pxa_camera_dma_irq_u(int channel, void *data)\r\n{\r\nstruct pxa_camera_dev *pcdev = data;\r\npxa_camera_dma_irq(channel, pcdev, DMA_U);\r\n}\r\nstatic void pxa_camera_dma_irq_v(int channel, void *data)\r\n{\r\nstruct pxa_camera_dev *pcdev = data;\r\npxa_camera_dma_irq(channel, pcdev, DMA_V);\r\n}\r\nstatic void pxa_camera_init_videobuf(struct videobuf_queue *q,\r\nstruct soc_camera_device *icd)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nvideobuf_queue_sg_init(q, &pxa_videobuf_ops, NULL, &pcdev->lock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE, V4L2_FIELD_NONE,\r\nsizeof(struct pxa_buffer), icd, &ici->host_lock);\r\n}\r\nstatic u32 mclk_get_divisor(struct platform_device *pdev,\r\nstruct pxa_camera_dev *pcdev)\r\n{\r\nunsigned long mclk = pcdev->mclk;\r\nstruct device *dev = &pdev->dev;\r\nu32 div;\r\nunsigned long lcdclk;\r\nlcdclk = clk_get_rate(pcdev->clk);\r\npcdev->ciclk = lcdclk;\r\nif (mclk > lcdclk / 4) {\r\nmclk = lcdclk / 4;\r\ndev_warn(dev, "Limiting master clock to %lu\n", mclk);\r\n}\r\ndiv = (lcdclk + 2 * mclk - 1) / (2 * mclk) - 1;\r\nif (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)\r\npcdev->mclk = lcdclk / (2 * (div + 1));\r\ndev_dbg(dev, "LCD clock %luHz, target freq %luHz, divisor %u\n",\r\nlcdclk, mclk, div);\r\nreturn div;\r\n}\r\nstatic void recalculate_fifo_timeout(struct pxa_camera_dev *pcdev,\r\nunsigned long pclk)\r\n{\r\nu32 ciclk_per_pixel = pcdev->ciclk / pclk + 1;\r\n__raw_writel(ciclk_per_pixel, pcdev->base + CITOR);\r\n}\r\nstatic void pxa_camera_activate(struct pxa_camera_dev *pcdev)\r\n{\r\nu32 cicr4 = 0;\r\n__raw_writel(0x3ff, pcdev->base + CICR0);\r\nif (pcdev->platform_flags & PXA_CAMERA_PCLK_EN)\r\ncicr4 |= CICR4_PCLK_EN;\r\nif (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)\r\ncicr4 |= CICR4_MCLK_EN;\r\nif (pcdev->platform_flags & PXA_CAMERA_PCP)\r\ncicr4 |= CICR4_PCP;\r\nif (pcdev->platform_flags & PXA_CAMERA_HSP)\r\ncicr4 |= CICR4_HSP;\r\nif (pcdev->platform_flags & PXA_CAMERA_VSP)\r\ncicr4 |= CICR4_VSP;\r\n__raw_writel(pcdev->mclk_divisor | cicr4, pcdev->base + CICR4);\r\nif (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)\r\nrecalculate_fifo_timeout(pcdev, pcdev->mclk);\r\nelse\r\nrecalculate_fifo_timeout(pcdev, 13000000);\r\nclk_prepare_enable(pcdev->clk);\r\n}\r\nstatic void pxa_camera_deactivate(struct pxa_camera_dev *pcdev)\r\n{\r\nclk_disable_unprepare(pcdev->clk);\r\n}\r\nstatic irqreturn_t pxa_camera_irq(int irq, void *data)\r\n{\r\nstruct pxa_camera_dev *pcdev = data;\r\nunsigned long status, cifr, cicr0;\r\nstruct pxa_buffer *buf;\r\nstruct videobuf_buffer *vb;\r\nstatus = __raw_readl(pcdev->base + CISR);\r\ndev_dbg(pcdev->soc_host.v4l2_dev.dev,\r\n"Camera interrupt status 0x%lx\n", status);\r\nif (!status)\r\nreturn IRQ_NONE;\r\n__raw_writel(status, pcdev->base + CISR);\r\nif (status & CISR_EOF) {\r\ncifr = __raw_readl(pcdev->base + CIFR) | CIFR_RESET_F;\r\n__raw_writel(cifr, pcdev->base + CIFR);\r\npcdev->active = list_first_entry(&pcdev->capture,\r\nstruct pxa_buffer, vb.queue);\r\nvb = &pcdev->active->vb;\r\nbuf = container_of(vb, struct pxa_buffer, vb);\r\npxa_videobuf_set_actdma(pcdev, buf);\r\npxa_dma_start_channels(pcdev);\r\ncicr0 = __raw_readl(pcdev->base + CICR0) | CICR0_EOFM;\r\n__raw_writel(cicr0, pcdev->base + CICR0);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pxa_camera_add_device(struct soc_camera_device *icd)\r\n{\r\ndev_info(icd->parent, "PXA Camera driver attached to camera %d\n",\r\nicd->devnum);\r\nreturn 0;\r\n}\r\nstatic void pxa_camera_remove_device(struct soc_camera_device *icd)\r\n{\r\ndev_info(icd->parent, "PXA Camera driver detached from camera %d\n",\r\nicd->devnum);\r\n}\r\nstatic int pxa_camera_clock_start(struct soc_camera_host *ici)\r\n{\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\npxa_camera_activate(pcdev);\r\nreturn 0;\r\n}\r\nstatic void pxa_camera_clock_stop(struct soc_camera_host *ici)\r\n{\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\n__raw_writel(0x3ff, pcdev->base + CICR0);\r\nDCSR(pcdev->dma_chans[0]) = 0;\r\nDCSR(pcdev->dma_chans[1]) = 0;\r\nDCSR(pcdev->dma_chans[2]) = 0;\r\npxa_camera_deactivate(pcdev);\r\n}\r\nstatic int test_platform_param(struct pxa_camera_dev *pcdev,\r\nunsigned char buswidth, unsigned long *flags)\r\n{\r\n*flags = (pcdev->platform_flags & PXA_CAMERA_MASTER ?\r\nV4L2_MBUS_MASTER : V4L2_MBUS_SLAVE) |\r\nV4L2_MBUS_HSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_HSYNC_ACTIVE_LOW |\r\nV4L2_MBUS_VSYNC_ACTIVE_HIGH |\r\nV4L2_MBUS_VSYNC_ACTIVE_LOW |\r\nV4L2_MBUS_DATA_ACTIVE_HIGH |\r\nV4L2_MBUS_PCLK_SAMPLE_RISING |\r\nV4L2_MBUS_PCLK_SAMPLE_FALLING;\r\nif ((1 << (buswidth - 1)) & pcdev->width_flags)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic void pxa_camera_setup_cicr(struct soc_camera_device *icd,\r\nunsigned long flags, __u32 pixfmt)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nunsigned long dw, bpp;\r\nu32 cicr0, cicr1, cicr2, cicr3, cicr4 = 0, y_skip_top;\r\nint ret = v4l2_subdev_call(sd, sensor, g_skip_top_lines, &y_skip_top);\r\nif (ret < 0)\r\ny_skip_top = 0;\r\nswitch (icd->current_fmt->host_fmt->bits_per_sample) {\r\ncase 10:\r\ndw = 4;\r\nbpp = 0x40;\r\nbreak;\r\ncase 9:\r\ndw = 3;\r\nbpp = 0x20;\r\nbreak;\r\ndefault:\r\ncase 8:\r\ndw = 2;\r\nbpp = 0;\r\n}\r\nif (pcdev->platform_flags & PXA_CAMERA_PCLK_EN)\r\ncicr4 |= CICR4_PCLK_EN;\r\nif (pcdev->platform_flags & PXA_CAMERA_MCLK_EN)\r\ncicr4 |= CICR4_MCLK_EN;\r\nif (flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\r\ncicr4 |= CICR4_PCP;\r\nif (flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)\r\ncicr4 |= CICR4_HSP;\r\nif (flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)\r\ncicr4 |= CICR4_VSP;\r\ncicr0 = __raw_readl(pcdev->base + CICR0);\r\nif (cicr0 & CICR0_ENB)\r\n__raw_writel(cicr0 & ~CICR0_ENB, pcdev->base + CICR0);\r\ncicr1 = CICR1_PPL_VAL(icd->user_width - 1) | bpp | dw;\r\nswitch (pixfmt) {\r\ncase V4L2_PIX_FMT_YUV422P:\r\npcdev->channels = 3;\r\ncicr1 |= CICR1_YCBCR_F;\r\ncase V4L2_PIX_FMT_UYVY:\r\ncase V4L2_PIX_FMT_VYUY:\r\ncase V4L2_PIX_FMT_YUYV:\r\ncase V4L2_PIX_FMT_YVYU:\r\ncicr1 |= CICR1_COLOR_SP_VAL(2);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB555:\r\ncicr1 |= CICR1_RGB_BPP_VAL(1) | CICR1_RGBT_CONV_VAL(2) |\r\nCICR1_TBIT | CICR1_COLOR_SP_VAL(1);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\ncicr1 |= CICR1_COLOR_SP_VAL(1) | CICR1_RGB_BPP_VAL(2);\r\nbreak;\r\n}\r\ncicr2 = 0;\r\ncicr3 = CICR3_LPF_VAL(icd->user_height - 1) |\r\nCICR3_BFW_VAL(min((u32)255, y_skip_top));\r\ncicr4 |= pcdev->mclk_divisor;\r\n__raw_writel(cicr1, pcdev->base + CICR1);\r\n__raw_writel(cicr2, pcdev->base + CICR2);\r\n__raw_writel(cicr3, pcdev->base + CICR3);\r\n__raw_writel(cicr4, pcdev->base + CICR4);\r\ncicr0 = (cicr0 & CICR0_ENB) | (pcdev->platform_flags & PXA_CAMERA_MASTER ?\r\nCICR0_SIM_MP : (CICR0_SL_CAP_EN | CICR0_SIM_SP));\r\ncicr0 |= CICR0_DMAEN | CICR0_IRQ_MASK;\r\n__raw_writel(cicr0, pcdev->base + CICR0);\r\n}\r\nstatic int pxa_camera_set_bus_param(struct soc_camera_device *icd)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nstruct v4l2_mbus_config cfg = {.type = V4L2_MBUS_PARALLEL,};\r\nu32 pixfmt = icd->current_fmt->host_fmt->fourcc;\r\nunsigned long bus_flags, common_flags;\r\nint ret;\r\nstruct pxa_cam *cam = icd->host_priv;\r\nret = test_platform_param(pcdev, icd->current_fmt->host_fmt->bits_per_sample,\r\n&bus_flags);\r\nif (ret < 0)\r\nreturn ret;\r\nret = v4l2_subdev_call(sd, video, g_mbus_config, &cfg);\r\nif (!ret) {\r\ncommon_flags = soc_mbus_config_compatible(&cfg,\r\nbus_flags);\r\nif (!common_flags) {\r\ndev_warn(icd->parent,\r\n"Flags incompatible: camera 0x%x, host 0x%lx\n",\r\ncfg.flags, bus_flags);\r\nreturn -EINVAL;\r\n}\r\n} else if (ret != -ENOIOCTLCMD) {\r\nreturn ret;\r\n} else {\r\ncommon_flags = bus_flags;\r\n}\r\npcdev->channels = 1;\r\nif ((common_flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH) &&\r\n(common_flags & V4L2_MBUS_HSYNC_ACTIVE_LOW)) {\r\nif (pcdev->platform_flags & PXA_CAMERA_HSP)\r\ncommon_flags &= ~V4L2_MBUS_HSYNC_ACTIVE_HIGH;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_HSYNC_ACTIVE_LOW;\r\n}\r\nif ((common_flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH) &&\r\n(common_flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)) {\r\nif (pcdev->platform_flags & PXA_CAMERA_VSP)\r\ncommon_flags &= ~V4L2_MBUS_VSYNC_ACTIVE_HIGH;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_VSYNC_ACTIVE_LOW;\r\n}\r\nif ((common_flags & V4L2_MBUS_PCLK_SAMPLE_RISING) &&\r\n(common_flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)) {\r\nif (pcdev->platform_flags & PXA_CAMERA_PCP)\r\ncommon_flags &= ~V4L2_MBUS_PCLK_SAMPLE_RISING;\r\nelse\r\ncommon_flags &= ~V4L2_MBUS_PCLK_SAMPLE_FALLING;\r\n}\r\ncfg.flags = common_flags;\r\nret = v4l2_subdev_call(sd, video, s_mbus_config, &cfg);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\ndev_dbg(icd->parent, "camera s_mbus_config(0x%lx) returned %d\n",\r\ncommon_flags, ret);\r\nreturn ret;\r\n}\r\ncam->flags = common_flags;\r\npxa_camera_setup_cicr(icd, common_flags, pixfmt);\r\nreturn 0;\r\n}\r\nstatic int pxa_camera_try_bus_param(struct soc_camera_device *icd,\r\nunsigned char buswidth)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct soc_camera_host *ici = to_soc_camera_host(icd->parent);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nstruct v4l2_mbus_config cfg = {.type = V4L2_MBUS_PARALLEL,};\r\nunsigned long bus_flags, common_flags;\r\nint ret = test_platform_param(pcdev, buswidth, &bus_flags);\r\nif (ret < 0)\r\nreturn ret;\r\nret = v4l2_subdev_call(sd, video, g_mbus_config, &cfg);\r\nif (!ret) {\r\ncommon_flags = soc_mbus_config_compatible(&cfg,\r\nbus_flags);\r\nif (!common_flags) {\r\ndev_warn(icd->parent,\r\n"Flags incompatible: camera 0x%x, host 0x%lx\n",\r\ncfg.flags, bus_flags);\r\nreturn -EINVAL;\r\n}\r\n} else if (ret == -ENOIOCTLCMD) {\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool pxa_camera_packing_supported(const struct soc_mbus_pixelfmt *fmt)\r\n{\r\nreturn fmt->packing == SOC_MBUS_PACKING_NONE ||\r\n(fmt->bits_per_sample == 8 &&\r\nfmt->packing == SOC_MBUS_PACKING_2X8_PADHI) ||\r\n(fmt->bits_per_sample > 8 &&\r\nfmt->packing == SOC_MBUS_PACKING_EXTEND16);\r\n}\r\nstatic int pxa_camera_get_formats(struct soc_camera_device *icd, unsigned int idx,\r\nstruct soc_camera_format_xlate *xlate)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct device *dev = icd->parent;\r\nint formats = 0, ret;\r\nstruct pxa_cam *cam;\r\nu32 code;\r\nconst struct soc_mbus_pixelfmt *fmt;\r\nret = v4l2_subdev_call(sd, video, enum_mbus_fmt, idx, &code);\r\nif (ret < 0)\r\nreturn 0;\r\nfmt = soc_mbus_get_fmtdesc(code);\r\nif (!fmt) {\r\ndev_err(dev, "Invalid format code #%u: %d\n", idx, code);\r\nreturn 0;\r\n}\r\nret = pxa_camera_try_bus_param(icd, fmt->bits_per_sample);\r\nif (ret < 0)\r\nreturn 0;\r\nif (!icd->host_priv) {\r\ncam = kzalloc(sizeof(*cam), GFP_KERNEL);\r\nif (!cam)\r\nreturn -ENOMEM;\r\nicd->host_priv = cam;\r\n} else {\r\ncam = icd->host_priv;\r\n}\r\nswitch (code) {\r\ncase MEDIA_BUS_FMT_UYVY8_2X8:\r\nformats++;\r\nif (xlate) {\r\nxlate->host_fmt = &pxa_camera_formats[0];\r\nxlate->code = code;\r\nxlate++;\r\ndev_dbg(dev, "Providing format %s using code %d\n",\r\npxa_camera_formats[0].name, code);\r\n}\r\ncase MEDIA_BUS_FMT_VYUY8_2X8:\r\ncase MEDIA_BUS_FMT_YUYV8_2X8:\r\ncase MEDIA_BUS_FMT_YVYU8_2X8:\r\ncase MEDIA_BUS_FMT_RGB565_2X8_LE:\r\ncase MEDIA_BUS_FMT_RGB555_2X8_PADHI_LE:\r\nif (xlate)\r\ndev_dbg(dev, "Providing format %s packed\n",\r\nfmt->name);\r\nbreak;\r\ndefault:\r\nif (!pxa_camera_packing_supported(fmt))\r\nreturn 0;\r\nif (xlate)\r\ndev_dbg(dev,\r\n"Providing format %s in pass-through mode\n",\r\nfmt->name);\r\n}\r\nformats++;\r\nif (xlate) {\r\nxlate->host_fmt = fmt;\r\nxlate->code = code;\r\nxlate++;\r\n}\r\nreturn formats;\r\n}\r\nstatic void pxa_camera_put_formats(struct soc_camera_device *icd)\r\n{\r\nkfree(icd->host_priv);\r\nicd->host_priv = NULL;\r\n}\r\nstatic int pxa_camera_check_frame(u32 width, u32 height)\r\n{\r\nreturn height < 32 || height > 2048 || width < 48 || width > 2048 ||\r\n(width & 0x01);\r\n}\r\nstatic int pxa_camera_set_crop(struct soc_camera_device *icd,\r\nconst struct v4l2_crop *a)\r\n{\r\nconst struct v4l2_rect *rect = &a->c;\r\nstruct device *dev = icd->parent;\r\nstruct soc_camera_host *ici = to_soc_camera_host(dev);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nstruct soc_camera_sense sense = {\r\n.master_clock = pcdev->mclk,\r\n.pixel_clock_max = pcdev->ciclk / 4,\r\n};\r\nstruct v4l2_mbus_framefmt mf;\r\nstruct pxa_cam *cam = icd->host_priv;\r\nu32 fourcc = icd->current_fmt->host_fmt->fourcc;\r\nint ret;\r\nif (pcdev->platform_flags & PXA_CAMERA_PCLK_EN)\r\nicd->sense = &sense;\r\nret = v4l2_subdev_call(sd, video, s_crop, a);\r\nicd->sense = NULL;\r\nif (ret < 0) {\r\ndev_warn(dev, "Failed to crop to %ux%u@%u:%u\n",\r\nrect->width, rect->height, rect->left, rect->top);\r\nreturn ret;\r\n}\r\nret = v4l2_subdev_call(sd, video, g_mbus_fmt, &mf);\r\nif (ret < 0)\r\nreturn ret;\r\nif (pxa_camera_check_frame(mf.width, mf.height)) {\r\nv4l_bound_align_image(&mf.width, 48, 2048, 1,\r\n&mf.height, 32, 2048, 0,\r\nfourcc == V4L2_PIX_FMT_YUV422P ? 4 : 0);\r\nret = v4l2_subdev_call(sd, video, s_mbus_fmt, &mf);\r\nif (ret < 0)\r\nreturn ret;\r\nif (pxa_camera_check_frame(mf.width, mf.height)) {\r\ndev_warn(icd->parent,\r\n"Inconsistent state. Use S_FMT to repair\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (sense.flags & SOCAM_SENSE_PCLK_CHANGED) {\r\nif (sense.pixel_clock > sense.pixel_clock_max) {\r\ndev_err(dev,\r\n"pixel clock %lu set by the camera too high!",\r\nsense.pixel_clock);\r\nreturn -EIO;\r\n}\r\nrecalculate_fifo_timeout(pcdev, sense.pixel_clock);\r\n}\r\nicd->user_width = mf.width;\r\nicd->user_height = mf.height;\r\npxa_camera_setup_cicr(icd, cam->flags, fourcc);\r\nreturn ret;\r\n}\r\nstatic int pxa_camera_set_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct device *dev = icd->parent;\r\nstruct soc_camera_host *ici = to_soc_camera_host(dev);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nconst struct soc_camera_format_xlate *xlate = NULL;\r\nstruct soc_camera_sense sense = {\r\n.master_clock = pcdev->mclk,\r\n.pixel_clock_max = pcdev->ciclk / 4,\r\n};\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_mbus_framefmt mf;\r\nint ret;\r\nxlate = soc_camera_xlate_by_fourcc(icd, pix->pixelformat);\r\nif (!xlate) {\r\ndev_warn(dev, "Format %x not found\n", pix->pixelformat);\r\nreturn -EINVAL;\r\n}\r\nif (pcdev->platform_flags & PXA_CAMERA_PCLK_EN)\r\nicd->sense = &sense;\r\nmf.width = pix->width;\r\nmf.height = pix->height;\r\nmf.field = pix->field;\r\nmf.colorspace = pix->colorspace;\r\nmf.code = xlate->code;\r\nret = v4l2_subdev_call(sd, video, s_mbus_fmt, &mf);\r\nif (mf.code != xlate->code)\r\nreturn -EINVAL;\r\nicd->sense = NULL;\r\nif (ret < 0) {\r\ndev_warn(dev, "Failed to configure for format %x\n",\r\npix->pixelformat);\r\n} else if (pxa_camera_check_frame(mf.width, mf.height)) {\r\ndev_warn(dev,\r\n"Camera driver produced an unsupported frame %dx%d\n",\r\nmf.width, mf.height);\r\nret = -EINVAL;\r\n} else if (sense.flags & SOCAM_SENSE_PCLK_CHANGED) {\r\nif (sense.pixel_clock > sense.pixel_clock_max) {\r\ndev_err(dev,\r\n"pixel clock %lu set by the camera too high!",\r\nsense.pixel_clock);\r\nreturn -EIO;\r\n}\r\nrecalculate_fifo_timeout(pcdev, sense.pixel_clock);\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\npix->width = mf.width;\r\npix->height = mf.height;\r\npix->field = mf.field;\r\npix->colorspace = mf.colorspace;\r\nicd->current_fmt = xlate;\r\nreturn ret;\r\n}\r\nstatic int pxa_camera_try_fmt(struct soc_camera_device *icd,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(icd);\r\nconst struct soc_camera_format_xlate *xlate;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct v4l2_mbus_framefmt mf;\r\n__u32 pixfmt = pix->pixelformat;\r\nint ret;\r\nxlate = soc_camera_xlate_by_fourcc(icd, pixfmt);\r\nif (!xlate) {\r\ndev_warn(icd->parent, "Format %x not found\n", pixfmt);\r\nreturn -EINVAL;\r\n}\r\nv4l_bound_align_image(&pix->width, 48, 2048, 1,\r\n&pix->height, 32, 2048, 0,\r\npixfmt == V4L2_PIX_FMT_YUV422P ? 4 : 0);\r\nmf.width = pix->width;\r\nmf.height = pix->height;\r\nmf.field = V4L2_FIELD_NONE;\r\nmf.colorspace = pix->colorspace;\r\nmf.code = xlate->code;\r\nret = v4l2_subdev_call(sd, video, try_mbus_fmt, &mf);\r\nif (ret < 0)\r\nreturn ret;\r\npix->width = mf.width;\r\npix->height = mf.height;\r\npix->colorspace = mf.colorspace;\r\nswitch (mf.field) {\r\ncase V4L2_FIELD_ANY:\r\ncase V4L2_FIELD_NONE:\r\npix->field = V4L2_FIELD_NONE;\r\nbreak;\r\ndefault:\r\ndev_err(icd->parent, "Field type %d unsupported.\n",\r\nmf.field);\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int pxa_camera_reqbufs(struct soc_camera_device *icd,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nint i;\r\nfor (i = 0; i < p->count; i++) {\r\nstruct pxa_buffer *buf = container_of(icd->vb_vidq.bufs[i],\r\nstruct pxa_buffer, vb);\r\nbuf->inwork = 0;\r\nINIT_LIST_HEAD(&buf->vb.queue);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int pxa_camera_poll(struct file *file, poll_table *pt)\r\n{\r\nstruct soc_camera_device *icd = file->private_data;\r\nstruct pxa_buffer *buf;\r\nbuf = list_entry(icd->vb_vidq.stream.next, struct pxa_buffer,\r\nvb.stream);\r\npoll_wait(file, &buf->vb.done, pt);\r\nif (buf->vb.state == VIDEOBUF_DONE ||\r\nbuf->vb.state == VIDEOBUF_ERROR)\r\nreturn POLLIN|POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int pxa_camera_querycap(struct soc_camera_host *ici,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrlcpy(cap->card, pxa_cam_driver_description, sizeof(cap->card));\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int pxa_camera_suspend(struct device *dev)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(dev);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nint i = 0, ret = 0;\r\npcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR0);\r\npcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR1);\r\npcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR2);\r\npcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR3);\r\npcdev->save_cicr[i++] = __raw_readl(pcdev->base + CICR4);\r\nif (pcdev->soc_host.icd) {\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(pcdev->soc_host.icd);\r\nret = v4l2_subdev_call(sd, core, s_power, 0);\r\nif (ret == -ENOIOCTLCMD)\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int pxa_camera_resume(struct device *dev)\r\n{\r\nstruct soc_camera_host *ici = to_soc_camera_host(dev);\r\nstruct pxa_camera_dev *pcdev = ici->priv;\r\nint i = 0, ret = 0;\r\nDRCMR(68) = pcdev->dma_chans[0] | DRCMR_MAPVLD;\r\nDRCMR(69) = pcdev->dma_chans[1] | DRCMR_MAPVLD;\r\nDRCMR(70) = pcdev->dma_chans[2] | DRCMR_MAPVLD;\r\n__raw_writel(pcdev->save_cicr[i++] & ~CICR0_ENB, pcdev->base + CICR0);\r\n__raw_writel(pcdev->save_cicr[i++], pcdev->base + CICR1);\r\n__raw_writel(pcdev->save_cicr[i++], pcdev->base + CICR2);\r\n__raw_writel(pcdev->save_cicr[i++], pcdev->base + CICR3);\r\n__raw_writel(pcdev->save_cicr[i++], pcdev->base + CICR4);\r\nif (pcdev->soc_host.icd) {\r\nstruct v4l2_subdev *sd = soc_camera_to_subdev(pcdev->soc_host.icd);\r\nret = v4l2_subdev_call(sd, core, s_power, 1);\r\nif (ret == -ENOIOCTLCMD)\r\nret = 0;\r\n}\r\nif (!ret && pcdev->active)\r\npxa_camera_start_capture(pcdev);\r\nreturn ret;\r\n}\r\nstatic int pxa_camera_pdata_from_dt(struct device *dev,\r\nstruct pxa_camera_dev *pcdev)\r\n{\r\nu32 mclk_rate;\r\nstruct device_node *np = dev->of_node;\r\nstruct v4l2_of_endpoint ep;\r\nint err = of_property_read_u32(np, "clock-frequency",\r\n&mclk_rate);\r\nif (!err) {\r\npcdev->platform_flags |= PXA_CAMERA_MCLK_EN;\r\npcdev->mclk = mclk_rate;\r\n}\r\nnp = of_graph_get_next_endpoint(np, NULL);\r\nif (!np) {\r\ndev_err(dev, "could not find endpoint\n");\r\nreturn -EINVAL;\r\n}\r\nerr = v4l2_of_parse_endpoint(np, &ep);\r\nif (err) {\r\ndev_err(dev, "could not parse endpoint\n");\r\ngoto out;\r\n}\r\nswitch (ep.bus.parallel.bus_width) {\r\ncase 4:\r\npcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_4;\r\nbreak;\r\ncase 5:\r\npcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_5;\r\nbreak;\r\ncase 8:\r\npcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_8;\r\nbreak;\r\ncase 9:\r\npcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_9;\r\nbreak;\r\ncase 10:\r\npcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_10;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ep.bus.parallel.flags & V4L2_MBUS_MASTER)\r\npcdev->platform_flags |= PXA_CAMERA_MASTER;\r\nif (ep.bus.parallel.flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)\r\npcdev->platform_flags |= PXA_CAMERA_HSP;\r\nif (ep.bus.parallel.flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)\r\npcdev->platform_flags |= PXA_CAMERA_VSP;\r\nif (ep.bus.parallel.flags & V4L2_MBUS_PCLK_SAMPLE_RISING)\r\npcdev->platform_flags |= PXA_CAMERA_PCLK_EN | PXA_CAMERA_PCP;\r\nif (ep.bus.parallel.flags & V4L2_MBUS_PCLK_SAMPLE_FALLING)\r\npcdev->platform_flags |= PXA_CAMERA_PCLK_EN;\r\nout:\r\nof_node_put(np);\r\nreturn err;\r\n}\r\nstatic int pxa_camera_probe(struct platform_device *pdev)\r\n{\r\nstruct pxa_camera_dev *pcdev;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nint irq;\r\nint err = 0;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!res || irq < 0)\r\nreturn -ENODEV;\r\npcdev = devm_kzalloc(&pdev->dev, sizeof(*pcdev), GFP_KERNEL);\r\nif (!pcdev) {\r\ndev_err(&pdev->dev, "Could not allocate pcdev\n");\r\nreturn -ENOMEM;\r\n}\r\npcdev->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(pcdev->clk))\r\nreturn PTR_ERR(pcdev->clk);\r\npcdev->res = res;\r\npcdev->pdata = pdev->dev.platform_data;\r\nif (&pdev->dev.of_node && !pcdev->pdata) {\r\nerr = pxa_camera_pdata_from_dt(&pdev->dev, pcdev);\r\n} else {\r\npcdev->platform_flags = pcdev->pdata->flags;\r\npcdev->mclk = pcdev->pdata->mclk_10khz * 10000;\r\n}\r\nif (err < 0)\r\nreturn err;\r\nif (!(pcdev->platform_flags & (PXA_CAMERA_DATAWIDTH_8 |\r\nPXA_CAMERA_DATAWIDTH_9 | PXA_CAMERA_DATAWIDTH_10))) {\r\ndev_warn(&pdev->dev, "WARNING! Platform hasn't set available "\r\n"data widths, using default 10 bit\n");\r\npcdev->platform_flags |= PXA_CAMERA_DATAWIDTH_10;\r\n}\r\nif (pcdev->platform_flags & PXA_CAMERA_DATAWIDTH_8)\r\npcdev->width_flags = 1 << 7;\r\nif (pcdev->platform_flags & PXA_CAMERA_DATAWIDTH_9)\r\npcdev->width_flags |= 1 << 8;\r\nif (pcdev->platform_flags & PXA_CAMERA_DATAWIDTH_10)\r\npcdev->width_flags |= 1 << 9;\r\nif (!pcdev->mclk) {\r\ndev_warn(&pdev->dev,\r\n"mclk == 0! Please, fix your platform data. "\r\n"Using default 20MHz\n");\r\npcdev->mclk = 20000000;\r\n}\r\npcdev->mclk_divisor = mclk_get_divisor(pdev, pcdev);\r\nINIT_LIST_HEAD(&pcdev->capture);\r\nspin_lock_init(&pcdev->lock);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\npcdev->irq = irq;\r\npcdev->base = base;\r\nerr = pxa_request_dma("CI_Y", DMA_PRIO_HIGH,\r\npxa_camera_dma_irq_y, pcdev);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "Can't request DMA for Y\n");\r\nreturn err;\r\n}\r\npcdev->dma_chans[0] = err;\r\ndev_dbg(&pdev->dev, "got DMA channel %d\n", pcdev->dma_chans[0]);\r\nerr = pxa_request_dma("CI_U", DMA_PRIO_HIGH,\r\npxa_camera_dma_irq_u, pcdev);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "Can't request DMA for U\n");\r\ngoto exit_free_dma_y;\r\n}\r\npcdev->dma_chans[1] = err;\r\ndev_dbg(&pdev->dev, "got DMA channel (U) %d\n", pcdev->dma_chans[1]);\r\nerr = pxa_request_dma("CI_V", DMA_PRIO_HIGH,\r\npxa_camera_dma_irq_v, pcdev);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "Can't request DMA for V\n");\r\ngoto exit_free_dma_u;\r\n}\r\npcdev->dma_chans[2] = err;\r\ndev_dbg(&pdev->dev, "got DMA channel (V) %d\n", pcdev->dma_chans[2]);\r\nDRCMR(68) = pcdev->dma_chans[0] | DRCMR_MAPVLD;\r\nDRCMR(69) = pcdev->dma_chans[1] | DRCMR_MAPVLD;\r\nDRCMR(70) = pcdev->dma_chans[2] | DRCMR_MAPVLD;\r\nerr = devm_request_irq(&pdev->dev, pcdev->irq, pxa_camera_irq, 0,\r\nPXA_CAM_DRV_NAME, pcdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Camera interrupt register failed\n");\r\ngoto exit_free_dma;\r\n}\r\npcdev->soc_host.drv_name = PXA_CAM_DRV_NAME;\r\npcdev->soc_host.ops = &pxa_soc_camera_host_ops;\r\npcdev->soc_host.priv = pcdev;\r\npcdev->soc_host.v4l2_dev.dev = &pdev->dev;\r\npcdev->soc_host.nr = pdev->id;\r\nerr = soc_camera_host_register(&pcdev->soc_host);\r\nif (err)\r\ngoto exit_free_dma;\r\nreturn 0;\r\nexit_free_dma:\r\npxa_free_dma(pcdev->dma_chans[2]);\r\nexit_free_dma_u:\r\npxa_free_dma(pcdev->dma_chans[1]);\r\nexit_free_dma_y:\r\npxa_free_dma(pcdev->dma_chans[0]);\r\nreturn err;\r\n}\r\nstatic int pxa_camera_remove(struct platform_device *pdev)\r\n{\r\nstruct soc_camera_host *soc_host = to_soc_camera_host(&pdev->dev);\r\nstruct pxa_camera_dev *pcdev = container_of(soc_host,\r\nstruct pxa_camera_dev, soc_host);\r\npxa_free_dma(pcdev->dma_chans[0]);\r\npxa_free_dma(pcdev->dma_chans[1]);\r\npxa_free_dma(pcdev->dma_chans[2]);\r\nsoc_camera_host_unregister(soc_host);\r\ndev_info(&pdev->dev, "PXA Camera driver unloaded\n");\r\nreturn 0;\r\n}
