static inline void crossbar_writel(int irq_no, int cb_no)\r\n{\r\nwritel(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);\r\n}\r\nstatic inline void crossbar_writew(int irq_no, int cb_no)\r\n{\r\nwritew(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);\r\n}\r\nstatic inline void crossbar_writeb(int irq_no, int cb_no)\r\n{\r\nwriteb(cb_no, cb->crossbar_base + cb->register_offsets[irq_no]);\r\n}\r\nstatic inline int get_prev_map_irq(int cb_no)\r\n{\r\nint i;\r\nfor (i = cb->int_max - 1; i >= 0; i--)\r\nif (cb->irq_map[i] == cb_no)\r\nreturn i;\r\nreturn -ENODEV;\r\n}\r\nstatic inline int allocate_free_irq(int cb_no)\r\n{\r\nint i;\r\nfor (i = cb->int_max - 1; i >= 0; i--) {\r\nif (cb->irq_map[i] == IRQ_FREE) {\r\ncb->irq_map[i] = cb_no;\r\nreturn i;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic inline bool needs_crossbar_write(irq_hw_number_t hw)\r\n{\r\nint cb_no;\r\nif (hw > GIC_IRQ_START) {\r\ncb_no = cb->irq_map[hw - GIC_IRQ_START];\r\nif (cb_no != IRQ_RESERVED && cb_no != IRQ_SKIP)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int crossbar_domain_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hw)\r\n{\r\nif (needs_crossbar_write(hw))\r\ncb->write(hw - GIC_IRQ_START, cb->irq_map[hw - GIC_IRQ_START]);\r\nreturn 0;\r\n}\r\nstatic void crossbar_domain_unmap(struct irq_domain *d, unsigned int irq)\r\n{\r\nirq_hw_number_t hw = irq_get_irq_data(irq)->hwirq;\r\nif (needs_crossbar_write(hw)) {\r\ncb->irq_map[hw - GIC_IRQ_START] = IRQ_FREE;\r\ncb->write(hw - GIC_IRQ_START, cb->safe_map);\r\n}\r\n}\r\nstatic int crossbar_domain_xlate(struct irq_domain *d,\r\nstruct device_node *controller,\r\nconst u32 *intspec, unsigned int intsize,\r\nunsigned long *out_hwirq,\r\nunsigned int *out_type)\r\n{\r\nint ret;\r\nint req_num = intspec[1];\r\nint direct_map_num;\r\nif (req_num >= cb->max_crossbar_sources) {\r\ndirect_map_num = req_num - cb->max_crossbar_sources;\r\nif (direct_map_num < cb->int_max) {\r\nret = cb->irq_map[direct_map_num];\r\nif (ret == IRQ_RESERVED || ret == IRQ_SKIP) {\r\nret = direct_map_num;\r\ngoto found;\r\n}\r\n}\r\npr_err("%s: requested crossbar number %d > max %d\n",\r\n__func__, req_num, cb->max_crossbar_sources);\r\nreturn -EINVAL;\r\n}\r\nret = get_prev_map_irq(req_num);\r\nif (ret >= 0)\r\ngoto found;\r\nret = allocate_free_irq(req_num);\r\nif (ret < 0)\r\nreturn ret;\r\nfound:\r\n*out_hwirq = ret + GIC_IRQ_START;\r\nreturn 0;\r\n}\r\nstatic int __init crossbar_of_init(struct device_node *node)\r\n{\r\nint i, size, max = 0, reserved = 0, entry;\r\nconst __be32 *irqsr;\r\nint ret = -ENOMEM;\r\ncb = kzalloc(sizeof(*cb), GFP_KERNEL);\r\nif (!cb)\r\nreturn ret;\r\ncb->crossbar_base = of_iomap(node, 0);\r\nif (!cb->crossbar_base)\r\ngoto err_cb;\r\nof_property_read_u32(node, "ti,max-crossbar-sources",\r\n&cb->max_crossbar_sources);\r\nif (!cb->max_crossbar_sources) {\r\npr_err("missing 'ti,max-crossbar-sources' property\n");\r\nret = -EINVAL;\r\ngoto err_base;\r\n}\r\nof_property_read_u32(node, "ti,max-irqs", &max);\r\nif (!max) {\r\npr_err("missing 'ti,max-irqs' property\n");\r\nret = -EINVAL;\r\ngoto err_base;\r\n}\r\ncb->irq_map = kcalloc(max, sizeof(int), GFP_KERNEL);\r\nif (!cb->irq_map)\r\ngoto err_base;\r\ncb->int_max = max;\r\nfor (i = 0; i < max; i++)\r\ncb->irq_map[i] = IRQ_FREE;\r\nirqsr = of_get_property(node, "ti,irqs-reserved", &size);\r\nif (irqsr) {\r\nsize /= sizeof(__be32);\r\nfor (i = 0; i < size; i++) {\r\nof_property_read_u32_index(node,\r\n"ti,irqs-reserved",\r\ni, &entry);\r\nif (entry >= max) {\r\npr_err("Invalid reserved entry\n");\r\nret = -EINVAL;\r\ngoto err_irq_map;\r\n}\r\ncb->irq_map[entry] = IRQ_RESERVED;\r\n}\r\n}\r\nirqsr = of_get_property(node, "ti,irqs-skip", &size);\r\nif (irqsr) {\r\nsize /= sizeof(__be32);\r\nfor (i = 0; i < size; i++) {\r\nof_property_read_u32_index(node,\r\n"ti,irqs-skip",\r\ni, &entry);\r\nif (entry >= max) {\r\npr_err("Invalid skip entry\n");\r\nret = -EINVAL;\r\ngoto err_irq_map;\r\n}\r\ncb->irq_map[entry] = IRQ_SKIP;\r\n}\r\n}\r\ncb->register_offsets = kcalloc(max, sizeof(int), GFP_KERNEL);\r\nif (!cb->register_offsets)\r\ngoto err_irq_map;\r\nof_property_read_u32(node, "ti,reg-size", &size);\r\nswitch (size) {\r\ncase 1:\r\ncb->write = crossbar_writeb;\r\nbreak;\r\ncase 2:\r\ncb->write = crossbar_writew;\r\nbreak;\r\ncase 4:\r\ncb->write = crossbar_writel;\r\nbreak;\r\ndefault:\r\npr_err("Invalid reg-size property\n");\r\nret = -EINVAL;\r\ngoto err_reg_offset;\r\nbreak;\r\n}\r\nfor (i = 0; i < max; i++) {\r\nif (cb->irq_map[i] == IRQ_RESERVED)\r\ncontinue;\r\ncb->register_offsets[i] = reserved;\r\nreserved += size;\r\n}\r\nof_property_read_u32(node, "ti,irqs-safe-map", &cb->safe_map);\r\nfor (i = 0; i < max; i++) {\r\nif (cb->irq_map[i] == IRQ_RESERVED ||\r\ncb->irq_map[i] == IRQ_SKIP)\r\ncontinue;\r\ncb->write(i, cb->safe_map);\r\n}\r\nregister_routable_domain_ops(&routable_irq_domain_ops);\r\nreturn 0;\r\nerr_reg_offset:\r\nkfree(cb->register_offsets);\r\nerr_irq_map:\r\nkfree(cb->irq_map);\r\nerr_base:\r\niounmap(cb->crossbar_base);\r\nerr_cb:\r\nkfree(cb);\r\ncb = NULL;\r\nreturn ret;\r\n}\r\nint __init irqcrossbar_init(void)\r\n{\r\nstruct device_node *np;\r\nnp = of_find_matching_node(NULL, crossbar_match);\r\nif (!np)\r\nreturn -ENODEV;\r\ncrossbar_of_init(np);\r\nreturn 0;\r\n}
