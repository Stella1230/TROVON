static void mmp2_pll_init(struct mmp2_clk_unit *pxa_unit)\r\n{\r\nstruct clk *clk;\r\nstruct mmp_clk_unit *unit = &pxa_unit->unit;\r\nmmp_register_fixed_rate_clks(unit, fixed_rate_clks,\r\nARRAY_SIZE(fixed_rate_clks));\r\nmmp_register_fixed_factor_clks(unit, fixed_factor_clks,\r\nARRAY_SIZE(fixed_factor_clks));\r\nclk = mmp_clk_register_factor("uart_pll", "pll1_4",\r\nCLK_SET_RATE_PARENT,\r\npxa_unit->mpmu_base + MPMU_UART_PLL,\r\n&uart_factor_masks, uart_factor_tbl,\r\nARRAY_SIZE(uart_factor_tbl), NULL);\r\nmmp_clk_add(unit, MMP2_CLK_UART_PLL, clk);\r\n}\r\nstatic void mmp2_apb_periph_clk_init(struct mmp2_clk_unit *pxa_unit)\r\n{\r\nstruct mmp_clk_unit *unit = &pxa_unit->unit;\r\nmmp_register_mux_clks(unit, apbc_mux_clks, pxa_unit->apbc_base,\r\nARRAY_SIZE(apbc_mux_clks));\r\nmmp_register_gate_clks(unit, apbc_gate_clks, pxa_unit->apbc_base,\r\nARRAY_SIZE(apbc_gate_clks));\r\n}\r\nstatic void mmp2_axi_periph_clk_init(struct mmp2_clk_unit *pxa_unit)\r\n{\r\nstruct clk *clk;\r\nstruct mmp_clk_unit *unit = &pxa_unit->unit;\r\nsdh_mix_config.reg_info.reg_clk_ctrl = pxa_unit->apmu_base + APMU_SDH0;\r\nclk = mmp_clk_register_mix(NULL, "sdh_mix_clk", sdh_parent_names,\r\nARRAY_SIZE(sdh_parent_names),\r\nCLK_SET_RATE_PARENT,\r\n&sdh_mix_config, &sdh_lock);\r\nccic0_mix_config.reg_info.reg_clk_ctrl = pxa_unit->apmu_base + APMU_CCIC0;\r\nclk = mmp_clk_register_mix(NULL, "ccic0_mix_clk", ccic_parent_names,\r\nARRAY_SIZE(ccic_parent_names),\r\nCLK_SET_RATE_PARENT,\r\n&ccic0_mix_config, &ccic0_lock);\r\nmmp_clk_add(unit, MMP2_CLK_CCIC0_MIX, clk);\r\nccic1_mix_config.reg_info.reg_clk_ctrl = pxa_unit->apmu_base + APMU_CCIC1;\r\nclk = mmp_clk_register_mix(NULL, "ccic1_mix_clk", ccic_parent_names,\r\nARRAY_SIZE(ccic_parent_names),\r\nCLK_SET_RATE_PARENT,\r\n&ccic1_mix_config, &ccic1_lock);\r\nmmp_clk_add(unit, MMP2_CLK_CCIC1_MIX, clk);\r\nmmp_register_mux_clks(unit, apmu_mux_clks, pxa_unit->apmu_base,\r\nARRAY_SIZE(apmu_mux_clks));\r\nmmp_register_div_clks(unit, apmu_div_clks, pxa_unit->apmu_base,\r\nARRAY_SIZE(apmu_div_clks));\r\nmmp_register_gate_clks(unit, apmu_gate_clks, pxa_unit->apmu_base,\r\nARRAY_SIZE(apmu_gate_clks));\r\n}\r\nstatic void mmp2_clk_reset_init(struct device_node *np,\r\nstruct mmp2_clk_unit *pxa_unit)\r\n{\r\nstruct mmp_clk_reset_cell *cells;\r\nint i, nr_resets;\r\nnr_resets = ARRAY_SIZE(apbc_gate_clks);\r\ncells = kcalloc(nr_resets, sizeof(*cells), GFP_KERNEL);\r\nif (!cells)\r\nreturn;\r\nfor (i = 0; i < nr_resets; i++) {\r\ncells[i].clk_id = apbc_gate_clks[i].id;\r\ncells[i].reg = pxa_unit->apbc_base + apbc_gate_clks[i].offset;\r\ncells[i].flags = 0;\r\ncells[i].lock = apbc_gate_clks[i].lock;\r\ncells[i].bits = 0x4;\r\n}\r\nmmp_clk_reset_register(np, cells, nr_resets);\r\n}\r\nstatic void __init mmp2_clk_init(struct device_node *np)\r\n{\r\nstruct mmp2_clk_unit *pxa_unit;\r\npxa_unit = kzalloc(sizeof(*pxa_unit), GFP_KERNEL);\r\nif (!pxa_unit)\r\nreturn;\r\npxa_unit->mpmu_base = of_iomap(np, 0);\r\nif (!pxa_unit->mpmu_base) {\r\npr_err("failed to map mpmu registers\n");\r\nreturn;\r\n}\r\npxa_unit->apmu_base = of_iomap(np, 1);\r\nif (!pxa_unit->mpmu_base) {\r\npr_err("failed to map apmu registers\n");\r\nreturn;\r\n}\r\npxa_unit->apbc_base = of_iomap(np, 2);\r\nif (!pxa_unit->apbc_base) {\r\npr_err("failed to map apbc registers\n");\r\nreturn;\r\n}\r\nmmp_clk_init(np, &pxa_unit->unit, MMP2_NR_CLKS);\r\nmmp2_pll_init(pxa_unit);\r\nmmp2_apb_periph_clk_init(pxa_unit);\r\nmmp2_axi_periph_clk_init(pxa_unit);\r\nmmp2_clk_reset_init(np, pxa_unit);\r\n}
