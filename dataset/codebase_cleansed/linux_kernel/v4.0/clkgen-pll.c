static int clkgen_pll_is_locked(struct clk_hw *hw)\r\n{\r\nstruct clkgen_pll *pll = to_clkgen_pll(hw);\r\nu32 locked = CLKGEN_READ(pll, locked_status);\r\nreturn !!locked;\r\n}\r\nstatic int clkgen_pll_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct clkgen_pll *pll = to_clkgen_pll(hw);\r\nu32 poweroff = CLKGEN_READ(pll, pdn_status);\r\nreturn !poweroff;\r\n}\r\nunsigned long recalc_stm_pll800c65(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clkgen_pll *pll = to_clkgen_pll(hw);\r\nunsigned long mdiv, ndiv, pdiv;\r\nunsigned long rate;\r\nuint64_t res;\r\nif (!clkgen_pll_is_enabled(hw) || !clkgen_pll_is_locked(hw))\r\nreturn 0;\r\npdiv = CLKGEN_READ(pll, pdiv);\r\nmdiv = CLKGEN_READ(pll, mdiv);\r\nndiv = CLKGEN_READ(pll, ndiv);\r\nif (!mdiv)\r\nmdiv++;\r\nres = (uint64_t)2 * (uint64_t)parent_rate * (uint64_t)ndiv;\r\nrate = (unsigned long)div64_u64(res, mdiv * (1 << pdiv));\r\npr_debug("%s:%s rate %lu\n", __clk_get_name(hw->clk), __func__, rate);\r\nreturn rate;\r\n}\r\nunsigned long recalc_stm_pll1600c65(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clkgen_pll *pll = to_clkgen_pll(hw);\r\nunsigned long mdiv, ndiv;\r\nunsigned long rate;\r\nif (!clkgen_pll_is_enabled(hw) || !clkgen_pll_is_locked(hw))\r\nreturn 0;\r\nmdiv = CLKGEN_READ(pll, mdiv);\r\nndiv = CLKGEN_READ(pll, ndiv);\r\nif (!mdiv)\r\nmdiv = 1;\r\nrate = ((2 * (parent_rate / 1000) * ndiv) / mdiv) * 1000;\r\npr_debug("%s:%s rate %lu\n", __clk_get_name(hw->clk), __func__, rate);\r\nreturn rate;\r\n}\r\nunsigned long recalc_stm_pll3200c32(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clkgen_pll *pll = to_clkgen_pll(hw);\r\nunsigned long ndiv, idf;\r\nunsigned long rate = 0;\r\nif (!clkgen_pll_is_enabled(hw) || !clkgen_pll_is_locked(hw))\r\nreturn 0;\r\nndiv = CLKGEN_READ(pll, ndiv);\r\nidf = CLKGEN_READ(pll, idf);\r\nif (idf)\r\nrate = ((2 * (parent_rate/1000) * ndiv) / idf) * 1000;\r\npr_debug("%s:%s rate %lu\n", __clk_get_name(hw->clk), __func__, rate);\r\nreturn rate;\r\n}\r\nunsigned long recalc_stm_pll1200c32(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clkgen_pll *pll = to_clkgen_pll(hw);\r\nunsigned long odf, ldf, idf;\r\nunsigned long rate;\r\nif (!clkgen_pll_is_enabled(hw) || !clkgen_pll_is_locked(hw))\r\nreturn 0;\r\nodf = CLKGEN_READ(pll, odf[0]);\r\nldf = CLKGEN_READ(pll, ldf);\r\nidf = CLKGEN_READ(pll, idf);\r\nif (!idf)\r\nidf = 1;\r\nif (!odf)\r\nodf = 1;\r\nrate = (((parent_rate / 1000) * ldf) / (odf * idf)) * 1000;\r\npr_debug("%s:%s rate %lu\n", __clk_get_name(hw->clk), __func__, rate);\r\nreturn rate;\r\n}\r\nstatic struct clk * __init clkgen_pll_register(const char *parent_name,\r\nstruct clkgen_pll_data *pll_data,\r\nvoid __iomem *reg,\r\nconst char *clk_name)\r\n{\r\nstruct clkgen_pll *pll;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\npll = kzalloc(sizeof(*pll), GFP_KERNEL);\r\nif (!pll)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = clk_name;\r\ninit.ops = pll_data->ops;\r\ninit.flags = CLK_IS_BASIC;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\npll->data = pll_data;\r\npll->regs_base = reg;\r\npll->hw.init = &init;\r\nclk = clk_register(NULL, &pll->hw);\r\nif (IS_ERR(clk)) {\r\nkfree(pll);\r\nreturn clk;\r\n}\r\npr_debug("%s: parent %s rate %lu\n",\r\n__clk_get_name(clk),\r\n__clk_get_name(clk_get_parent(clk)),\r\nclk_get_rate(clk));\r\nreturn clk;\r\n}\r\nstatic struct clk * __init clkgen_c65_lsdiv_register(const char *parent_name,\r\nconst char *clk_name)\r\n{\r\nstruct clk *clk;\r\nclk = clk_register_fixed_factor(NULL, clk_name, parent_name, 0, 1, 2);\r\nif (IS_ERR(clk))\r\nreturn clk;\r\npr_debug("%s: parent %s rate %lu\n",\r\n__clk_get_name(clk),\r\n__clk_get_name(clk_get_parent(clk)),\r\nclk_get_rate(clk));\r\nreturn clk;\r\n}\r\nstatic void __iomem * __init clkgen_get_register_base(\r\nstruct device_node *np)\r\n{\r\nstruct device_node *pnode;\r\nvoid __iomem *reg = NULL;\r\npnode = of_get_parent(np);\r\nif (!pnode)\r\nreturn NULL;\r\nreg = of_iomap(pnode, 0);\r\nof_node_put(pnode);\r\nreturn reg;\r\n}\r\nstatic void __init clkgena_c65_pll_setup(struct device_node *np)\r\n{\r\nconst int num_pll_outputs = 3;\r\nstruct clk_onecell_data *clk_data;\r\nconst char *parent_name;\r\nvoid __iomem *reg;\r\nconst char *clk_name;\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nif (!parent_name)\r\nreturn;\r\nreg = clkgen_get_register_base(np);\r\nif (!reg)\r\nreturn;\r\nclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\r\nif (!clk_data)\r\nreturn;\r\nclk_data->clk_num = num_pll_outputs;\r\nclk_data->clks = kzalloc(clk_data->clk_num * sizeof(struct clk *),\r\nGFP_KERNEL);\r\nif (!clk_data->clks)\r\ngoto err;\r\nif (of_property_read_string_index(np, "clock-output-names",\r\n0, &clk_name))\r\ngoto err;\r\nclk_data->clks[0] = clkgen_pll_register(parent_name,\r\n(struct clkgen_pll_data *) &st_pll1600c65_ax,\r\nreg + CLKGENAx_PLL0_OFFSET, clk_name);\r\nif (IS_ERR(clk_data->clks[0]))\r\ngoto err;\r\nif (of_property_read_string_index(np, "clock-output-names",\r\n1, &clk_name))\r\ngoto err;\r\nclk_data->clks[1] = clkgen_c65_lsdiv_register(__clk_get_name\r\n(clk_data->clks[0]),\r\nclk_name);\r\nif (IS_ERR(clk_data->clks[1]))\r\ngoto err;\r\nif (of_property_read_string_index(np, "clock-output-names",\r\n2, &clk_name))\r\ngoto err;\r\nclk_data->clks[2] = clkgen_pll_register(parent_name,\r\n(struct clkgen_pll_data *) &st_pll800c65_ax,\r\nreg + CLKGENAx_PLL1_OFFSET, clk_name);\r\nif (IS_ERR(clk_data->clks[2]))\r\ngoto err;\r\nof_clk_add_provider(np, of_clk_src_onecell_get, clk_data);\r\nreturn;\r\nerr:\r\nkfree(clk_data->clks);\r\nkfree(clk_data);\r\n}\r\nstatic struct clk * __init clkgen_odf_register(const char *parent_name,\r\nvoid * __iomem reg,\r\nstruct clkgen_pll_data *pll_data,\r\nint odf,\r\nspinlock_t *odf_lock,\r\nconst char *odf_name)\r\n{\r\nstruct clk *clk;\r\nunsigned long flags;\r\nstruct clk_gate *gate;\r\nstruct clk_divider *div;\r\nflags = CLK_GET_RATE_NOCACHE | CLK_SET_RATE_GATE;\r\ngate = kzalloc(sizeof(*gate), GFP_KERNEL);\r\nif (!gate)\r\nreturn ERR_PTR(-ENOMEM);\r\ngate->flags = CLK_GATE_SET_TO_DISABLE;\r\ngate->reg = reg + pll_data->odf_gate[odf].offset;\r\ngate->bit_idx = pll_data->odf_gate[odf].shift;\r\ngate->lock = odf_lock;\r\ndiv = kzalloc(sizeof(*div), GFP_KERNEL);\r\nif (!div) {\r\nkfree(gate);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ndiv->flags = CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ALLOW_ZERO;\r\ndiv->reg = reg + pll_data->odf[odf].offset;\r\ndiv->shift = pll_data->odf[odf].shift;\r\ndiv->width = fls(pll_data->odf[odf].mask);\r\ndiv->lock = odf_lock;\r\nclk = clk_register_composite(NULL, odf_name, &parent_name, 1,\r\nNULL, NULL,\r\n&div->hw, &clk_divider_ops,\r\n&gate->hw, &clk_gate_ops,\r\nflags);\r\nif (IS_ERR(clk))\r\nreturn clk;\r\npr_debug("%s: parent %s rate %lu\n",\r\n__clk_get_name(clk),\r\n__clk_get_name(clk_get_parent(clk)),\r\nclk_get_rate(clk));\r\nreturn clk;\r\n}\r\nstatic void __init clkgen_c32_pll_setup(struct device_node *np)\r\n{\r\nconst struct of_device_id *match;\r\nstruct clk *clk;\r\nconst char *parent_name, *pll_name;\r\nvoid __iomem *pll_base;\r\nint num_odfs, odf;\r\nstruct clk_onecell_data *clk_data;\r\nstruct clkgen_pll_data *data;\r\nmatch = of_match_node(c32_pll_of_match, np);\r\nif (!match) {\r\npr_err("%s: No matching data\n", __func__);\r\nreturn;\r\n}\r\ndata = (struct clkgen_pll_data *) match->data;\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nif (!parent_name)\r\nreturn;\r\npll_base = clkgen_get_register_base(np);\r\nif (!pll_base)\r\nreturn;\r\nclk = clkgen_pll_register(parent_name, data, pll_base, np->name);\r\nif (IS_ERR(clk))\r\nreturn;\r\npll_name = __clk_get_name(clk);\r\nnum_odfs = data->num_odfs;\r\nclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\r\nif (!clk_data)\r\nreturn;\r\nclk_data->clk_num = num_odfs;\r\nclk_data->clks = kzalloc(clk_data->clk_num * sizeof(struct clk *),\r\nGFP_KERNEL);\r\nif (!clk_data->clks)\r\ngoto err;\r\nfor (odf = 0; odf < num_odfs; odf++) {\r\nstruct clk *clk;\r\nconst char *clk_name;\r\nif (of_property_read_string_index(np, "clock-output-names",\r\nodf, &clk_name))\r\nreturn;\r\nclk = clkgen_odf_register(pll_name, pll_base, data,\r\nodf, &clkgena_c32_odf_lock, clk_name);\r\nif (IS_ERR(clk))\r\ngoto err;\r\nclk_data->clks[odf] = clk;\r\n}\r\nof_clk_add_provider(np, of_clk_src_onecell_get, clk_data);\r\nreturn;\r\nerr:\r\nkfree(pll_name);\r\nkfree(clk_data->clks);\r\nkfree(clk_data);\r\n}\r\nstatic void __init clkgengpu_c32_pll_setup(struct device_node *np)\r\n{\r\nconst struct of_device_id *match;\r\nstruct clk *clk;\r\nconst char *parent_name;\r\nvoid __iomem *reg;\r\nconst char *clk_name;\r\nstruct clkgen_pll_data *data;\r\nmatch = of_match_node(c32_gpu_pll_of_match, np);\r\nif (!match) {\r\npr_err("%s: No matching data\n", __func__);\r\nreturn;\r\n}\r\ndata = (struct clkgen_pll_data *)match->data;\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nif (!parent_name)\r\nreturn;\r\nreg = clkgen_get_register_base(np);\r\nif (!reg)\r\nreturn;\r\nif (of_property_read_string_index(np, "clock-output-names",\r\n0, &clk_name))\r\nreturn;\r\nclk = clkgen_pll_register(parent_name, data, reg, clk_name);\r\nif (!IS_ERR(clk))\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\nreturn;\r\n}
