static ssize_t power_on_acct_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hda_codec *codec = dev_get_drvdata(dev);\r\nsnd_hda_update_power_acct(codec);\r\nreturn sprintf(buf, "%u\n", jiffies_to_msecs(codec->power_on_acct));\r\n}\r\nstatic ssize_t power_off_acct_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hda_codec *codec = dev_get_drvdata(dev);\r\nsnd_hda_update_power_acct(codec);\r\nreturn sprintf(buf, "%u\n", jiffies_to_msecs(codec->power_off_acct));\r\n}\r\nstatic ssize_t pin_configs_show(struct hda_codec *codec,\r\nstruct snd_array *list,\r\nchar *buf)\r\n{\r\nint i, len = 0;\r\nmutex_lock(&codec->user_mutex);\r\nfor (i = 0; i < list->used; i++) {\r\nstruct hda_pincfg *pin = snd_array_elem(list, i);\r\nlen += sprintf(buf + len, "0x%02x 0x%08x\n",\r\npin->nid, pin->cfg);\r\n}\r\nmutex_unlock(&codec->user_mutex);\r\nreturn len;\r\n}\r\nstatic ssize_t init_pin_configs_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hda_codec *codec = dev_get_drvdata(dev);\r\nreturn pin_configs_show(codec, &codec->init_pins, buf);\r\n}\r\nstatic ssize_t driver_pin_configs_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hda_codec *codec = dev_get_drvdata(dev);\r\nreturn pin_configs_show(codec, &codec->driver_pins, buf);\r\n}\r\nstatic int clear_codec(struct hda_codec *codec)\r\n{\r\nint err;\r\nerr = snd_hda_codec_reset(codec);\r\nif (err < 0) {\r\ncodec_err(codec, "The codec is being used, can't free.\n");\r\nreturn err;\r\n}\r\nsnd_hda_sysfs_clear(codec);\r\nreturn 0;\r\n}\r\nstatic int reconfig_codec(struct hda_codec *codec)\r\n{\r\nint err;\r\nsnd_hda_power_up(codec);\r\ncodec_info(codec, "hda-codec: reconfiguring\n");\r\nerr = snd_hda_codec_reset(codec);\r\nif (err < 0) {\r\ncodec_err(codec,\r\n"The codec is being used, can't reconfigure.\n");\r\ngoto error;\r\n}\r\nerr = snd_hda_codec_configure(codec);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_hda_codec_build_pcms(codec);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_hda_codec_build_controls(codec);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_card_register(codec->bus->card);\r\nerror:\r\nsnd_hda_power_down(codec);\r\nreturn err;\r\n}\r\nstatic char *kstrndup_noeol(const char *src, size_t len)\r\n{\r\nchar *s = kstrndup(src, len, GFP_KERNEL);\r\nchar *p;\r\nif (!s)\r\nreturn NULL;\r\np = strchr(s, '\n');\r\nif (p)\r\n*p = 0;\r\nreturn s;\r\n}\r\nstatic ssize_t init_verbs_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hda_codec *codec = dev_get_drvdata(dev);\r\nint i, len = 0;\r\nmutex_lock(&codec->user_mutex);\r\nfor (i = 0; i < codec->init_verbs.used; i++) {\r\nstruct hda_verb *v = snd_array_elem(&codec->init_verbs, i);\r\nlen += snprintf(buf + len, PAGE_SIZE - len,\r\n"0x%02x 0x%03x 0x%04x\n",\r\nv->nid, v->verb, v->param);\r\n}\r\nmutex_unlock(&codec->user_mutex);\r\nreturn len;\r\n}\r\nstatic int parse_init_verbs(struct hda_codec *codec, const char *buf)\r\n{\r\nstruct hda_verb *v;\r\nint nid, verb, param;\r\nif (sscanf(buf, "%i %i %i", &nid, &verb, &param) != 3)\r\nreturn -EINVAL;\r\nif (!nid || !verb)\r\nreturn -EINVAL;\r\nmutex_lock(&codec->user_mutex);\r\nv = snd_array_new(&codec->init_verbs);\r\nif (!v) {\r\nmutex_unlock(&codec->user_mutex);\r\nreturn -ENOMEM;\r\n}\r\nv->nid = nid;\r\nv->verb = verb;\r\nv->param = param;\r\nmutex_unlock(&codec->user_mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t init_verbs_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hda_codec *codec = dev_get_drvdata(dev);\r\nint err = parse_init_verbs(codec, buf);\r\nif (err < 0)\r\nreturn err;\r\nreturn count;\r\n}\r\nstatic ssize_t hints_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hda_codec *codec = dev_get_drvdata(dev);\r\nint i, len = 0;\r\nmutex_lock(&codec->user_mutex);\r\nfor (i = 0; i < codec->hints.used; i++) {\r\nstruct hda_hint *hint = snd_array_elem(&codec->hints, i);\r\nlen += snprintf(buf + len, PAGE_SIZE - len,\r\n"%s = %s\n", hint->key, hint->val);\r\n}\r\nmutex_unlock(&codec->user_mutex);\r\nreturn len;\r\n}\r\nstatic struct hda_hint *get_hint(struct hda_codec *codec, const char *key)\r\n{\r\nint i;\r\nfor (i = 0; i < codec->hints.used; i++) {\r\nstruct hda_hint *hint = snd_array_elem(&codec->hints, i);\r\nif (!strcmp(hint->key, key))\r\nreturn hint;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void remove_trail_spaces(char *str)\r\n{\r\nchar *p;\r\nif (!*str)\r\nreturn;\r\np = str + strlen(str) - 1;\r\nfor (; isspace(*p); p--) {\r\n*p = 0;\r\nif (p == str)\r\nreturn;\r\n}\r\n}\r\nstatic int parse_hints(struct hda_codec *codec, const char *buf)\r\n{\r\nchar *key, *val;\r\nstruct hda_hint *hint;\r\nint err = 0;\r\nbuf = skip_spaces(buf);\r\nif (!*buf || *buf == '#' || *buf == '\n')\r\nreturn 0;\r\nif (*buf == '=')\r\nreturn -EINVAL;\r\nkey = kstrndup_noeol(buf, 1024);\r\nif (!key)\r\nreturn -ENOMEM;\r\nval = strchr(key, '=');\r\nif (!val) {\r\nkfree(key);\r\nreturn -EINVAL;\r\n}\r\n*val++ = 0;\r\nval = skip_spaces(val);\r\nremove_trail_spaces(key);\r\nremove_trail_spaces(val);\r\nmutex_lock(&codec->user_mutex);\r\nhint = get_hint(codec, key);\r\nif (hint) {\r\nkfree(hint->key);\r\nhint->key = key;\r\nhint->val = val;\r\ngoto unlock;\r\n}\r\nif (codec->hints.used >= MAX_HINTS)\r\nhint = NULL;\r\nelse\r\nhint = snd_array_new(&codec->hints);\r\nif (hint) {\r\nhint->key = key;\r\nhint->val = val;\r\n} else {\r\nerr = -ENOMEM;\r\n}\r\nunlock:\r\nmutex_unlock(&codec->user_mutex);\r\nif (err)\r\nkfree(key);\r\nreturn err;\r\n}\r\nstatic ssize_t hints_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hda_codec *codec = dev_get_drvdata(dev);\r\nint err = parse_hints(codec, buf);\r\nif (err < 0)\r\nreturn err;\r\nreturn count;\r\n}\r\nstatic ssize_t user_pin_configs_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hda_codec *codec = dev_get_drvdata(dev);\r\nreturn pin_configs_show(codec, &codec->user_pins, buf);\r\n}\r\nstatic int parse_user_pin_configs(struct hda_codec *codec, const char *buf)\r\n{\r\nint nid, cfg, err;\r\nif (sscanf(buf, "%i %i", &nid, &cfg) != 2)\r\nreturn -EINVAL;\r\nif (!nid)\r\nreturn -EINVAL;\r\nmutex_lock(&codec->user_mutex);\r\nerr = snd_hda_add_pincfg(codec, &codec->user_pins, nid, cfg);\r\nmutex_unlock(&codec->user_mutex);\r\nreturn err;\r\n}\r\nstatic ssize_t user_pin_configs_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hda_codec *codec = dev_get_drvdata(dev);\r\nint err = parse_user_pin_configs(codec, buf);\r\nif (err < 0)\r\nreturn err;\r\nreturn count;\r\n}\r\nconst char *snd_hda_get_hint(struct hda_codec *codec, const char *key)\r\n{\r\nstruct hda_hint *hint = get_hint(codec, key);\r\nreturn hint ? hint->val : NULL;\r\n}\r\nint snd_hda_get_bool_hint(struct hda_codec *codec, const char *key)\r\n{\r\nconst char *p;\r\nint ret;\r\nmutex_lock(&codec->user_mutex);\r\np = snd_hda_get_hint(codec, key);\r\nif (!p || !*p)\r\nret = -ENOENT;\r\nelse {\r\nswitch (toupper(*p)) {\r\ncase 'T':\r\ncase 'Y':\r\ncase '1':\r\nret = 1;\r\nbreak;\r\ndefault:\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&codec->user_mutex);\r\nreturn ret;\r\n}\r\nint snd_hda_get_int_hint(struct hda_codec *codec, const char *key, int *valp)\r\n{\r\nconst char *p;\r\nunsigned long val;\r\nint ret;\r\nmutex_lock(&codec->user_mutex);\r\np = snd_hda_get_hint(codec, key);\r\nif (!p)\r\nret = -ENOENT;\r\nelse if (kstrtoul(p, 0, &val))\r\nret = -EINVAL;\r\nelse {\r\n*valp = val;\r\nret = 0;\r\n}\r\nmutex_unlock(&codec->user_mutex);\r\nreturn ret;\r\n}\r\nstatic inline int strmatch(const char *a, const char *b)\r\n{\r\nreturn strncasecmp(a, b, strlen(b)) == 0;\r\n}\r\nstatic void parse_codec_mode(char *buf, struct hda_bus *bus,\r\nstruct hda_codec **codecp)\r\n{\r\nint vendorid, subid, caddr;\r\nstruct hda_codec *codec;\r\n*codecp = NULL;\r\nif (sscanf(buf, "%i %i %i", &vendorid, &subid, &caddr) == 3) {\r\nlist_for_each_entry(codec, &bus->codec_list, list) {\r\nif ((vendorid <= 0 || codec->vendor_id == vendorid) &&\r\n(subid <= 0 || codec->subsystem_id == subid) &&\r\ncodec->addr == caddr) {\r\n*codecp = codec;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nstatic void parse_pincfg_mode(char *buf, struct hda_bus *bus,\r\nstruct hda_codec **codecp)\r\n{\r\nparse_user_pin_configs(*codecp, buf);\r\n}\r\nstatic void parse_verb_mode(char *buf, struct hda_bus *bus,\r\nstruct hda_codec **codecp)\r\n{\r\nparse_init_verbs(*codecp, buf);\r\n}\r\nstatic void parse_hint_mode(char *buf, struct hda_bus *bus,\r\nstruct hda_codec **codecp)\r\n{\r\nparse_hints(*codecp, buf);\r\n}\r\nstatic void parse_model_mode(char *buf, struct hda_bus *bus,\r\nstruct hda_codec **codecp)\r\n{\r\nkfree((*codecp)->modelname);\r\n(*codecp)->modelname = kstrdup(buf, GFP_KERNEL);\r\n}\r\nstatic void parse_chip_name_mode(char *buf, struct hda_bus *bus,\r\nstruct hda_codec **codecp)\r\n{\r\nkfree((*codecp)->chip_name);\r\n(*codecp)->chip_name = kstrdup(buf, GFP_KERNEL);\r\n}\r\nstatic int parse_line_mode(char *buf, struct hda_bus *bus)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(patch_items); i++) {\r\nif (!patch_items[i].tag)\r\ncontinue;\r\nif (strmatch(buf, patch_items[i].tag))\r\nreturn i;\r\nif (patch_items[i].alias && strmatch(buf, patch_items[i].alias))\r\nreturn i;\r\n}\r\nreturn LINE_MODE_NONE;\r\n}\r\nstatic int get_line_from_fw(char *buf, int size, size_t *fw_size_p,\r\nconst void **fw_data_p)\r\n{\r\nint len;\r\nsize_t fw_size = *fw_size_p;\r\nconst char *p = *fw_data_p;\r\nwhile (isspace(*p) && fw_size) {\r\np++;\r\nfw_size--;\r\n}\r\nif (!fw_size)\r\nreturn 0;\r\nfor (len = 0; len < fw_size; len++) {\r\nif (!*p)\r\nbreak;\r\nif (*p == '\n') {\r\np++;\r\nlen++;\r\nbreak;\r\n}\r\nif (len < size)\r\n*buf++ = *p++;\r\n}\r\n*buf = 0;\r\n*fw_size_p = fw_size - len;\r\n*fw_data_p = p;\r\nremove_trail_spaces(buf);\r\nreturn 1;\r\n}\r\nint snd_hda_load_patch(struct hda_bus *bus, size_t fw_size, const void *fw_buf)\r\n{\r\nchar buf[128];\r\nstruct hda_codec *codec;\r\nint line_mode;\r\nline_mode = LINE_MODE_NONE;\r\ncodec = NULL;\r\nwhile (get_line_from_fw(buf, sizeof(buf) - 1, &fw_size, &fw_buf)) {\r\nif (!*buf || *buf == '#' || *buf == '\n')\r\ncontinue;\r\nif (*buf == '[')\r\nline_mode = parse_line_mode(buf, bus);\r\nelse if (patch_items[line_mode].parser &&\r\n(codec || line_mode <= LINE_MODE_CODEC))\r\npatch_items[line_mode].parser(buf, bus, &codec);\r\n}\r\nreturn 0;\r\n}\r\nvoid snd_hda_sysfs_init(struct hda_codec *codec)\r\n{\r\nmutex_init(&codec->user_mutex);\r\n#ifdef CONFIG_SND_HDA_RECONFIG\r\nsnd_array_init(&codec->init_verbs, sizeof(struct hda_verb), 32);\r\nsnd_array_init(&codec->hints, sizeof(struct hda_hint), 32);\r\nsnd_array_init(&codec->user_pins, sizeof(struct hda_pincfg), 16);\r\n#endif\r\n}\r\nvoid snd_hda_sysfs_clear(struct hda_codec *codec)\r\n{\r\n#ifdef CONFIG_SND_HDA_RECONFIG\r\nint i;\r\nsnd_array_free(&codec->init_verbs);\r\nfor (i = 0; i < codec->hints.used; i++) {\r\nstruct hda_hint *hint = snd_array_elem(&codec->hints, i);\r\nkfree(hint->key);\r\n}\r\nsnd_array_free(&codec->hints);\r\nsnd_array_free(&codec->user_pins);\r\n#endif\r\n}
