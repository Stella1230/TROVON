unsigned long pseries_memory_block_size(void)\r\n{\r\nstruct device_node *np;\r\nunsigned int memblock_size = MIN_MEMORY_BLOCK_SIZE;\r\nstruct resource r;\r\nnp = of_find_node_by_path("/ibm,dynamic-reconfiguration-memory");\r\nif (np) {\r\nconst __be64 *size;\r\nsize = of_get_property(np, "ibm,lmb-size", NULL);\r\nif (size)\r\nmemblock_size = be64_to_cpup(size);\r\nof_node_put(np);\r\n} else if (machine_is(pseries)) {\r\nunsigned int memzero_size = 0;\r\nnp = of_find_node_by_path("/memory@0");\r\nif (np) {\r\nif (!of_address_to_resource(np, 0, &r))\r\nmemzero_size = resource_size(&r);\r\nof_node_put(np);\r\n}\r\nif (memzero_size) {\r\nchar buf[64];\r\nsprintf(buf, "/memory@%x", memzero_size);\r\nnp = of_find_node_by_path(buf);\r\nif (np) {\r\nif (!of_address_to_resource(np, 0, &r))\r\nmemblock_size = resource_size(&r);\r\nof_node_put(np);\r\n}\r\n}\r\n}\r\nreturn memblock_size;\r\n}\r\nstatic int pseries_remove_memblock(unsigned long base, unsigned int memblock_size)\r\n{\r\nunsigned long block_sz, start_pfn;\r\nint sections_per_block;\r\nint i, nid;\r\nstart_pfn = base >> PAGE_SHIFT;\r\nlock_device_hotplug();\r\nif (!pfn_valid(start_pfn))\r\ngoto out;\r\nblock_sz = pseries_memory_block_size();\r\nsections_per_block = block_sz / MIN_MEMORY_BLOCK_SIZE;\r\nnid = memory_add_physaddr_to_nid(base);\r\nfor (i = 0; i < sections_per_block; i++) {\r\nremove_memory(nid, base, MIN_MEMORY_BLOCK_SIZE);\r\nbase += MIN_MEMORY_BLOCK_SIZE;\r\n}\r\nout:\r\nmemblock_remove(base, memblock_size);\r\nunlock_device_hotplug();\r\nreturn 0;\r\n}\r\nstatic int pseries_remove_mem_node(struct device_node *np)\r\n{\r\nconst char *type;\r\nconst __be32 *regs;\r\nunsigned long base;\r\nunsigned int lmb_size;\r\nint ret = -EINVAL;\r\ntype = of_get_property(np, "device_type", NULL);\r\nif (type == NULL || strcmp(type, "memory") != 0)\r\nreturn 0;\r\nregs = of_get_property(np, "reg", NULL);\r\nif (!regs)\r\nreturn ret;\r\nbase = be64_to_cpu(*(unsigned long *)regs);\r\nlmb_size = be32_to_cpu(regs[3]);\r\npseries_remove_memblock(base, lmb_size);\r\nreturn 0;\r\n}\r\nstatic inline int pseries_remove_memblock(unsigned long base,\r\nunsigned int memblock_size)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic inline int pseries_remove_mem_node(struct device_node *np)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pseries_add_mem_node(struct device_node *np)\r\n{\r\nconst char *type;\r\nconst __be32 *regs;\r\nunsigned long base;\r\nunsigned int lmb_size;\r\nint ret = -EINVAL;\r\ntype = of_get_property(np, "device_type", NULL);\r\nif (type == NULL || strcmp(type, "memory") != 0)\r\nreturn 0;\r\nregs = of_get_property(np, "reg", NULL);\r\nif (!regs)\r\nreturn ret;\r\nbase = be64_to_cpu(*(unsigned long *)regs);\r\nlmb_size = be32_to_cpu(regs[3]);\r\nret = memblock_add(base, lmb_size);\r\nreturn (ret < 0) ? -EINVAL : 0;\r\n}\r\nstatic int pseries_update_drconf_memory(struct of_reconfig_data *pr)\r\n{\r\nstruct of_drconf_cell *new_drmem, *old_drmem;\r\nunsigned long memblock_size;\r\nu32 entries;\r\n__be32 *p;\r\nint i, rc = -EINVAL;\r\nmemblock_size = pseries_memory_block_size();\r\nif (!memblock_size)\r\nreturn -EINVAL;\r\np = (__be32 *) pr->old_prop->value;\r\nif (!p)\r\nreturn -EINVAL;\r\nentries = be32_to_cpu(*p++);\r\nold_drmem = (struct of_drconf_cell *)p;\r\np = (__be32 *)pr->prop->value;\r\np++;\r\nnew_drmem = (struct of_drconf_cell *)p;\r\nfor (i = 0; i < entries; i++) {\r\nif ((be32_to_cpu(old_drmem[i].flags) & DRCONF_MEM_ASSIGNED) &&\r\n(!(be32_to_cpu(new_drmem[i].flags) & DRCONF_MEM_ASSIGNED))) {\r\nrc = pseries_remove_memblock(\r\nbe64_to_cpu(old_drmem[i].base_addr),\r\nmemblock_size);\r\nbreak;\r\n} else if ((!(be32_to_cpu(old_drmem[i].flags) &\r\nDRCONF_MEM_ASSIGNED)) &&\r\n(be32_to_cpu(new_drmem[i].flags) &\r\nDRCONF_MEM_ASSIGNED)) {\r\nrc = memblock_add(be64_to_cpu(old_drmem[i].base_addr),\r\nmemblock_size);\r\nrc = (rc < 0) ? -EINVAL : 0;\r\nbreak;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int pseries_memory_notifier(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct of_reconfig_data *rd = data;\r\nint err = 0;\r\nswitch (action) {\r\ncase OF_RECONFIG_ATTACH_NODE:\r\nerr = pseries_add_mem_node(rd->dn);\r\nbreak;\r\ncase OF_RECONFIG_DETACH_NODE:\r\nerr = pseries_remove_mem_node(rd->dn);\r\nbreak;\r\ncase OF_RECONFIG_UPDATE_PROPERTY:\r\nif (!strcmp(rd->prop->name, "ibm,dynamic-memory"))\r\nerr = pseries_update_drconf_memory(rd);\r\nbreak;\r\n}\r\nreturn notifier_from_errno(err);\r\n}\r\nstatic int __init pseries_memory_hotplug_init(void)\r\n{\r\nif (firmware_has_feature(FW_FEATURE_LPAR))\r\nof_reconfig_notifier_register(&pseries_mem_nb);\r\nreturn 0;\r\n}
