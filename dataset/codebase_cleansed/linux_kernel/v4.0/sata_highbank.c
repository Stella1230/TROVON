static inline int sgpio_bit_shift(struct ecx_plat_data *pdata, u32 port,\r\nu32 shift)\r\n{\r\nreturn 1 << (3 * pdata->port_to_sgpio[port] + shift);\r\n}\r\nstatic void ecx_parse_sgpio(struct ecx_plat_data *pdata, u32 port, u32 state)\r\n{\r\nif (state & ECX_ACTIVITY_BITS)\r\npdata->sgpio_pattern |= sgpio_bit_shift(pdata, port,\r\nECX_ACTIVITY_SHIFT);\r\nelse\r\npdata->sgpio_pattern &= ~sgpio_bit_shift(pdata, port,\r\nECX_ACTIVITY_SHIFT);\r\nif (state & ECX_LOCATE_BITS)\r\npdata->sgpio_pattern |= sgpio_bit_shift(pdata, port,\r\nECX_LOCATE_SHIFT);\r\nelse\r\npdata->sgpio_pattern &= ~sgpio_bit_shift(pdata, port,\r\nECX_LOCATE_SHIFT);\r\nif (state & ECX_FAULT_BITS)\r\npdata->sgpio_pattern |= sgpio_bit_shift(pdata, port,\r\nECX_FAULT_SHIFT);\r\nelse\r\npdata->sgpio_pattern &= ~sgpio_bit_shift(pdata, port,\r\nECX_FAULT_SHIFT);\r\n}\r\nstatic void ecx_led_cycle_clock(struct ecx_plat_data *pdata)\r\n{\r\ngpio_set_value(pdata->sgpio_gpio[SCLOCK], 1);\r\nudelay(50);\r\ngpio_set_value(pdata->sgpio_gpio[SCLOCK], 0);\r\nudelay(50);\r\n}\r\nstatic ssize_t ecx_transmit_led_message(struct ata_port *ap, u32 state,\r\nssize_t size)\r\n{\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nstruct ecx_plat_data *pdata = hpriv->plat_data;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nunsigned long flags;\r\nint pmp, i;\r\nstruct ahci_em_priv *emp;\r\nu32 sgpio_out;\r\npmp = (state & EM_MSG_LED_PMP_SLOT) >> 8;\r\nif (pmp < EM_MAX_SLOTS)\r\nemp = &pp->em_priv[pmp];\r\nelse\r\nreturn -EINVAL;\r\nif (!(hpriv->em_msg_type & EM_MSG_TYPE_LED))\r\nreturn size;\r\nspin_lock_irqsave(&sgpio_lock, flags);\r\necx_parse_sgpio(pdata, ap->port_no, state);\r\nsgpio_out = pdata->sgpio_pattern;\r\nfor (i = 0; i < pdata->pre_clocks; i++)\r\necx_led_cycle_clock(pdata);\r\ngpio_set_value(pdata->sgpio_gpio[SLOAD], 1);\r\necx_led_cycle_clock(pdata);\r\ngpio_set_value(pdata->sgpio_gpio[SLOAD], 0);\r\nfor (i = 0; i < (SGPIO_SIGNALS * pdata->n_ports); i++) {\r\ngpio_set_value(pdata->sgpio_gpio[SDATA], sgpio_out & 1);\r\nsgpio_out >>= 1;\r\necx_led_cycle_clock(pdata);\r\n}\r\nfor (i = 0; i < pdata->post_clocks; i++)\r\necx_led_cycle_clock(pdata);\r\nemp->led_state = state;\r\nspin_unlock_irqrestore(&sgpio_lock, flags);\r\nreturn size;\r\n}\r\nstatic void highbank_set_em_messages(struct device *dev,\r\nstruct ahci_host_priv *hpriv,\r\nstruct ata_port_info *pi)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct ecx_plat_data *pdata = hpriv->plat_data;\r\nint i;\r\nint err;\r\nfor (i = 0; i < SGPIO_PINS; i++) {\r\nerr = of_get_named_gpio(np, "calxeda,sgpio-gpio", i);\r\nif (IS_ERR_VALUE(err))\r\nreturn;\r\npdata->sgpio_gpio[i] = err;\r\nerr = gpio_request(pdata->sgpio_gpio[i], "CX SGPIO");\r\nif (err) {\r\npr_err("sata_highbank gpio_request %d failed: %d\n",\r\ni, err);\r\nreturn;\r\n}\r\ngpio_direction_output(pdata->sgpio_gpio[i], 1);\r\n}\r\nof_property_read_u32_array(np, "calxeda,led-order",\r\npdata->port_to_sgpio,\r\npdata->n_ports);\r\nif (of_property_read_u32(np, "calxeda,pre-clocks", &pdata->pre_clocks))\r\npdata->pre_clocks = 0;\r\nif (of_property_read_u32(np, "calxeda,post-clocks",\r\n&pdata->post_clocks))\r\npdata->post_clocks = 0;\r\nhpriv->em_loc = 0;\r\nhpriv->em_buf_sz = 4;\r\nhpriv->em_msg_type = EM_MSG_TYPE_LED;\r\npi->flags |= ATA_FLAG_EM | ATA_FLAG_SW_ACTIVITY;\r\n}\r\nstatic u32 __combo_phy_reg_read(u8 sata_port, u32 addr)\r\n{\r\nu32 data;\r\nu8 dev = port_data[sata_port].phy_devs;\r\nspin_lock(&cphy_lock);\r\nwritel(CPHY_MAP(dev, addr), port_data[sata_port].phy_base + 0x800);\r\ndata = readl(port_data[sata_port].phy_base + CPHY_ADDR(addr));\r\nspin_unlock(&cphy_lock);\r\nreturn data;\r\n}\r\nstatic void __combo_phy_reg_write(u8 sata_port, u32 addr, u32 data)\r\n{\r\nu8 dev = port_data[sata_port].phy_devs;\r\nspin_lock(&cphy_lock);\r\nwritel(CPHY_MAP(dev, addr), port_data[sata_port].phy_base + 0x800);\r\nwritel(data, port_data[sata_port].phy_base + CPHY_ADDR(addr));\r\nspin_unlock(&cphy_lock);\r\n}\r\nstatic void combo_phy_wait_for_ready(u8 sata_port)\r\n{\r\nwhile (__combo_phy_reg_read(sata_port, SERDES_CR_CTL) & CR_BUSY)\r\nudelay(5);\r\n}\r\nstatic u32 combo_phy_read(u8 sata_port, u32 addr)\r\n{\r\ncombo_phy_wait_for_ready(sata_port);\r\n__combo_phy_reg_write(sata_port, SERDES_CR_ADDR, addr);\r\n__combo_phy_reg_write(sata_port, SERDES_CR_CTL, CR_START);\r\ncombo_phy_wait_for_ready(sata_port);\r\nreturn __combo_phy_reg_read(sata_port, SERDES_CR_DATA);\r\n}\r\nstatic void combo_phy_write(u8 sata_port, u32 addr, u32 data)\r\n{\r\ncombo_phy_wait_for_ready(sata_port);\r\n__combo_phy_reg_write(sata_port, SERDES_CR_ADDR, addr);\r\n__combo_phy_reg_write(sata_port, SERDES_CR_DATA, data);\r\n__combo_phy_reg_write(sata_port, SERDES_CR_CTL, CR_WR_RDN | CR_START);\r\n}\r\nstatic void highbank_cphy_disable_overrides(u8 sata_port)\r\n{\r\nu8 lane = port_data[sata_port].lane_mapping;\r\nu32 tmp;\r\nif (unlikely(port_data[sata_port].phy_base == NULL))\r\nreturn;\r\ntmp = combo_phy_read(sata_port, CPHY_RX_INPUT_STS + lane * SPHY_LANE);\r\ntmp &= ~CPHY_SATA_RX_OVERRIDE;\r\ncombo_phy_write(sata_port, CPHY_RX_OVERRIDE + lane * SPHY_LANE, tmp);\r\n}\r\nstatic void cphy_override_tx_attenuation(u8 sata_port, u32 val)\r\n{\r\nu8 lane = port_data[sata_port].lane_mapping;\r\nu32 tmp;\r\nif (val & 0x8)\r\nreturn;\r\ntmp = combo_phy_read(sata_port, CPHY_TX_INPUT_STS + lane * SPHY_LANE);\r\ntmp &= ~CPHY_SATA_TX_OVERRIDE;\r\ncombo_phy_write(sata_port, CPHY_TX_OVERRIDE + lane * SPHY_LANE, tmp);\r\ntmp |= CPHY_SATA_TX_OVERRIDE;\r\ncombo_phy_write(sata_port, CPHY_TX_OVERRIDE + lane * SPHY_LANE, tmp);\r\ntmp |= (val << CPHY_SATA_TX_ATTEN_SHIFT) & CPHY_SATA_TX_ATTEN;\r\ncombo_phy_write(sata_port, CPHY_TX_OVERRIDE + lane * SPHY_LANE, tmp);\r\n}\r\nstatic void cphy_override_rx_mode(u8 sata_port, u32 val)\r\n{\r\nu8 lane = port_data[sata_port].lane_mapping;\r\nu32 tmp;\r\ntmp = combo_phy_read(sata_port, CPHY_RX_INPUT_STS + lane * SPHY_LANE);\r\ntmp &= ~CPHY_SATA_RX_OVERRIDE;\r\ncombo_phy_write(sata_port, CPHY_RX_OVERRIDE + lane * SPHY_LANE, tmp);\r\ntmp |= CPHY_SATA_RX_OVERRIDE;\r\ncombo_phy_write(sata_port, CPHY_RX_OVERRIDE + lane * SPHY_LANE, tmp);\r\ntmp &= ~CPHY_SATA_DPLL_MODE;\r\ntmp |= val << CPHY_SATA_DPLL_SHIFT;\r\ncombo_phy_write(sata_port, CPHY_RX_OVERRIDE + lane * SPHY_LANE, tmp);\r\ntmp |= CPHY_SATA_DPLL_RESET;\r\ncombo_phy_write(sata_port, CPHY_RX_OVERRIDE + lane * SPHY_LANE, tmp);\r\ntmp &= ~CPHY_SATA_DPLL_RESET;\r\ncombo_phy_write(sata_port, CPHY_RX_OVERRIDE + lane * SPHY_LANE, tmp);\r\nmsleep(15);\r\n}\r\nstatic void highbank_cphy_override_lane(u8 sata_port)\r\n{\r\nu8 lane = port_data[sata_port].lane_mapping;\r\nu32 tmp, k = 0;\r\nif (unlikely(port_data[sata_port].phy_base == NULL))\r\nreturn;\r\ndo {\r\ntmp = combo_phy_read(sata_port, CPHY_RX_INPUT_STS +\r\nlane * SPHY_LANE);\r\n} while ((tmp & SPHY_HALF_RATE) && (k++ < 1000));\r\ncphy_override_rx_mode(sata_port, 3);\r\ncphy_override_tx_attenuation(sata_port, port_data[sata_port].tx_atten);\r\n}\r\nstatic int highbank_initialize_phys(struct device *dev, void __iomem *addr)\r\n{\r\nstruct device_node *sata_node = dev->of_node;\r\nint phy_count = 0, phy, port = 0, i;\r\nvoid __iomem *cphy_base[CPHY_PHY_COUNT] = {};\r\nstruct device_node *phy_nodes[CPHY_PHY_COUNT] = {};\r\nu32 tx_atten[CPHY_PORT_COUNT] = {};\r\nmemset(port_data, 0, sizeof(struct phy_lane_info) * CPHY_PORT_COUNT);\r\ndo {\r\nu32 tmp;\r\nstruct of_phandle_args phy_data;\r\nif (of_parse_phandle_with_args(sata_node,\r\n"calxeda,port-phys", "#phy-cells",\r\nport, &phy_data))\r\nbreak;\r\nfor (phy = 0; phy < phy_count; phy++) {\r\nif (phy_nodes[phy] == phy_data.np)\r\nbreak;\r\n}\r\nif (phy_nodes[phy] == NULL) {\r\nphy_nodes[phy] = phy_data.np;\r\ncphy_base[phy] = of_iomap(phy_nodes[phy], 0);\r\nif (cphy_base[phy] == NULL) {\r\nreturn 0;\r\n}\r\nphy_count += 1;\r\n}\r\nport_data[port].lane_mapping = phy_data.args[0];\r\nof_property_read_u32(phy_nodes[phy], "phydev", &tmp);\r\nport_data[port].phy_devs = tmp;\r\nport_data[port].phy_base = cphy_base[phy];\r\nof_node_put(phy_data.np);\r\nport += 1;\r\n} while (port < CPHY_PORT_COUNT);\r\nof_property_read_u32_array(sata_node, "calxeda,tx-atten",\r\ntx_atten, port);\r\nfor (i = 0; i < port; i++)\r\nport_data[i].tx_atten = (u8) tx_atten[i];\r\nreturn 0;\r\n}\r\nstatic int ahci_highbank_hardreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nstatic const unsigned long timing[] = { 5, 100, 500};\r\nstruct ata_port *ap = link->ap;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nstruct ahci_host_priv *hpriv = ap->host->private_data;\r\nu8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;\r\nstruct ata_taskfile tf;\r\nbool online;\r\nu32 sstatus;\r\nint rc;\r\nint retry = 100;\r\nahci_stop_engine(ap);\r\nata_tf_init(link->device, &tf);\r\ntf.command = ATA_BUSY;\r\nata_tf_to_fis(&tf, 0, 0, d2h_fis);\r\ndo {\r\nhighbank_cphy_disable_overrides(link->ap->port_no);\r\nrc = sata_link_hardreset(link, timing, deadline, &online, NULL);\r\nhighbank_cphy_override_lane(link->ap->port_no);\r\nif (sata_scr_read(link, SCR_STATUS, &sstatus))\r\nbreak;\r\nif (!(sstatus & 0x3))\r\nbreak;\r\n} while (!online && retry--);\r\nhpriv->start_engine(ap);\r\nif (online)\r\n*class = ahci_dev_classify(ap);\r\nreturn rc;\r\n}\r\nstatic int ahci_highbank_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ahci_host_priv *hpriv;\r\nstruct ecx_plat_data *pdata;\r\nstruct ata_host *host;\r\nstruct resource *mem;\r\nint irq;\r\nint i;\r\nint rc;\r\nu32 n_ports;\r\nstruct ata_port_info pi = ahci_highbank_port_info;\r\nconst struct ata_port_info *ppi[] = { &pi, NULL };\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(dev, "no mmio space\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\ndev_err(dev, "no irq\n");\r\nreturn -EINVAL;\r\n}\r\nhpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);\r\nif (!hpriv) {\r\ndev_err(dev, "can't alloc ahci_host_priv\n");\r\nreturn -ENOMEM;\r\n}\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata) {\r\ndev_err(dev, "can't alloc ecx_plat_data\n");\r\nreturn -ENOMEM;\r\n}\r\nhpriv->flags |= (unsigned long)pi.private_data;\r\nhpriv->mmio = devm_ioremap(dev, mem->start, resource_size(mem));\r\nif (!hpriv->mmio) {\r\ndev_err(dev, "can't map %pR\n", mem);\r\nreturn -ENOMEM;\r\n}\r\nrc = highbank_initialize_phys(dev, hpriv->mmio);\r\nif (rc)\r\nreturn rc;\r\nahci_save_initial_config(dev, hpriv);\r\nif (hpriv->cap & HOST_CAP_NCQ)\r\npi.flags |= ATA_FLAG_NCQ;\r\nif (hpriv->cap & HOST_CAP_PMP)\r\npi.flags |= ATA_FLAG_PMP;\r\nif (hpriv->cap & HOST_CAP_64)\r\ndma_set_coherent_mask(dev, DMA_BIT_MASK(64));\r\nn_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));\r\npdata->n_ports = n_ports;\r\nhpriv->plat_data = pdata;\r\nhighbank_set_em_messages(dev, hpriv, &pi);\r\nhost = ata_host_alloc_pinfo(dev, ppi, n_ports);\r\nif (!host) {\r\nrc = -ENOMEM;\r\ngoto err0;\r\n}\r\nhost->private_data = hpriv;\r\nif (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)\r\nhost->flags |= ATA_HOST_PARALLEL_SCAN;\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nata_port_desc(ap, "mmio %pR", mem);\r\nata_port_desc(ap, "port 0x%x", 0x100 + ap->port_no * 0x80);\r\nif (ap->flags & ATA_FLAG_EM)\r\nap->em_message_type = hpriv->em_msg_type;\r\nif (!(hpriv->port_map & (1 << i)))\r\nap->ops = &ata_dummy_port_ops;\r\n}\r\nrc = ahci_reset_controller(host);\r\nif (rc)\r\ngoto err0;\r\nahci_init_controller(host);\r\nahci_print_info(host, "platform");\r\nrc = ahci_host_activate(host, irq, &ahci_highbank_platform_sht);\r\nif (rc)\r\ngoto err0;\r\nreturn 0;\r\nerr0:\r\nreturn rc;\r\n}\r\nstatic int ahci_highbank_suspend(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nvoid __iomem *mmio = hpriv->mmio;\r\nu32 ctl;\r\nint rc;\r\nif (hpriv->flags & AHCI_HFLAG_NO_SUSPEND) {\r\ndev_err(dev, "firmware update required for suspend/resume\n");\r\nreturn -EIO;\r\n}\r\nctl = readl(mmio + HOST_CTL);\r\nctl &= ~HOST_IRQ_EN;\r\nwritel(ctl, mmio + HOST_CTL);\r\nreadl(mmio + HOST_CTL);\r\nrc = ata_host_suspend(host, PMSG_SUSPEND);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int ahci_highbank_resume(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nint rc;\r\nif (dev->power.power_state.event == PM_EVENT_SUSPEND) {\r\nrc = ahci_reset_controller(host);\r\nif (rc)\r\nreturn rc;\r\nahci_init_controller(host);\r\n}\r\nata_host_resume(host);\r\nreturn 0;\r\n}
