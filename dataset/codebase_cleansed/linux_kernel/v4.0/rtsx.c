static const char *host_info(struct Scsi_Host *host)\r\n{\r\nreturn "SCSI emulation for PCI-Express Mass Storage devices";\r\n}\r\nstatic int slave_alloc(struct scsi_device *sdev)\r\n{\r\nsdev->inquiry_len = 36;\r\nreturn 0;\r\n}\r\nstatic int slave_configure(struct scsi_device *sdev)\r\n{\r\nblk_queue_dma_alignment(sdev->request_queue, (512 - 1));\r\nif (sdev->scsi_level < SCSI_2)\r\nsdev->scsi_level = sdev->sdev_target->scsi_level = SCSI_2;\r\nreturn 0;\r\n}\r\nstatic int queuecommand_lck(struct scsi_cmnd *srb,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\nstruct rtsx_dev *dev = host_to_rtsx(srb->device->host);\r\nstruct rtsx_chip *chip = dev->chip;\r\nif (chip->srb != NULL) {\r\ndev_err(&dev->pci->dev, "Error in %s: chip->srb = %p\n",\r\n__func__, chip->srb);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nif (rtsx_chk_stat(chip, RTSX_STAT_DISCONNECT)) {\r\ndev_info(&dev->pci->dev, "Fail command during disconnect\n");\r\nsrb->result = DID_NO_CONNECT << 16;\r\ndone(srb);\r\nreturn 0;\r\n}\r\nsrb->scsi_done = done;\r\nchip->srb = srb;\r\ncomplete(&dev->cmnd_ready);\r\nreturn 0;\r\n}\r\nint device_reset(struct scsi_cmnd *srb)\r\n{\r\nint result = 0;\r\nstruct rtsx_dev *dev = host_to_rtsx(srb->device->host);\r\ndev_info(&dev->pci->dev, "%s called\n", __func__);\r\nreturn result < 0 ? FAILED : SUCCESS;\r\n}\r\nstatic int bus_reset(struct scsi_cmnd *srb)\r\n{\r\nint result = 0;\r\nstruct rtsx_dev *dev = host_to_rtsx(srb->device->host);\r\ndev_info(&dev->pci->dev, "%s called\n", __func__);\r\nreturn result < 0 ? FAILED : SUCCESS;\r\n}\r\nstatic int rtsx_acquire_irq(struct rtsx_dev *dev)\r\n{\r\nstruct rtsx_chip *chip = dev->chip;\r\ndev_info(&dev->pci->dev, "%s: chip->msi_en = %d, pci->irq = %d\n",\r\n__func__, chip->msi_en, dev->pci->irq);\r\nif (request_irq(dev->pci->irq, rtsx_interrupt,\r\nchip->msi_en ? 0 : IRQF_SHARED,\r\nCR_DRIVER_NAME, dev)) {\r\ndev_err(&dev->pci->dev,\r\n"rtsx: unable to grab IRQ %d, disabling device\n",\r\ndev->pci->irq);\r\nreturn -1;\r\n}\r\ndev->irq = dev->pci->irq;\r\npci_intx(dev->pci, !chip->msi_en);\r\nreturn 0;\r\n}\r\nint rtsx_read_pci_cfg_byte(u8 bus, u8 dev, u8 func, u8 offset, u8 *val)\r\n{\r\nstruct pci_dev *pdev;\r\nu8 data;\r\nu8 devfn = (dev << 3) | func;\r\npdev = pci_get_bus_and_slot(bus, devfn);\r\nif (!pdev)\r\nreturn -1;\r\npci_read_config_byte(pdev, offset, &data);\r\nif (val)\r\n*val = data;\r\nreturn 0;\r\n}\r\nstatic int rtsx_suspend(struct pci_dev *pci, pm_message_t state)\r\n{\r\nstruct rtsx_dev *dev = pci_get_drvdata(pci);\r\nstruct rtsx_chip *chip;\r\nif (!dev)\r\nreturn 0;\r\nmutex_lock(&(dev->dev_mutex));\r\nchip = dev->chip;\r\nrtsx_do_before_power_down(chip, PM_S3);\r\nif (dev->irq >= 0) {\r\nsynchronize_irq(dev->irq);\r\nfree_irq(dev->irq, (void *)dev);\r\ndev->irq = -1;\r\n}\r\nif (chip->msi_en)\r\npci_disable_msi(pci);\r\npci_save_state(pci);\r\npci_enable_wake(pci, pci_choose_state(pci, state), 1);\r\npci_disable_device(pci);\r\npci_set_power_state(pci, pci_choose_state(pci, state));\r\nmutex_unlock(&dev->dev_mutex);\r\nreturn 0;\r\n}\r\nstatic int rtsx_resume(struct pci_dev *pci)\r\n{\r\nstruct rtsx_dev *dev = pci_get_drvdata(pci);\r\nstruct rtsx_chip *chip;\r\nif (!dev)\r\nreturn 0;\r\nchip = dev->chip;\r\nmutex_lock(&(dev->dev_mutex));\r\npci_set_power_state(pci, PCI_D0);\r\npci_restore_state(pci);\r\nif (pci_enable_device(pci) < 0) {\r\ndev_err(&dev->pci->dev,\r\n"%s: pci_enable_device failed, disabling device\n",\r\nCR_DRIVER_NAME);\r\nmutex_unlock(&dev->dev_mutex);\r\nreturn -EIO;\r\n}\r\npci_set_master(pci);\r\nif (chip->msi_en) {\r\nif (pci_enable_msi(pci) < 0)\r\nchip->msi_en = 0;\r\n}\r\nif (rtsx_acquire_irq(dev) < 0) {\r\nmutex_unlock(&dev->dev_mutex);\r\nreturn -EIO;\r\n}\r\nrtsx_write_register(chip, HOST_SLEEP_STATE, 0x03, 0x00);\r\nrtsx_init_chip(chip);\r\nmutex_unlock(&dev->dev_mutex);\r\nreturn 0;\r\n}\r\nstatic void rtsx_shutdown(struct pci_dev *pci)\r\n{\r\nstruct rtsx_dev *dev = pci_get_drvdata(pci);\r\nstruct rtsx_chip *chip;\r\nif (!dev)\r\nreturn;\r\nchip = dev->chip;\r\nrtsx_do_before_power_down(chip, PM_S1);\r\nif (dev->irq >= 0) {\r\nsynchronize_irq(dev->irq);\r\nfree_irq(dev->irq, (void *)dev);\r\ndev->irq = -1;\r\n}\r\nif (chip->msi_en)\r\npci_disable_msi(pci);\r\npci_disable_device(pci);\r\n}\r\nstatic int rtsx_control_thread(void *__dev)\r\n{\r\nstruct rtsx_dev *dev = __dev;\r\nstruct rtsx_chip *chip = dev->chip;\r\nstruct Scsi_Host *host = rtsx_to_host(dev);\r\nfor (;;) {\r\nif (wait_for_completion_interruptible(&dev->cmnd_ready))\r\nbreak;\r\nmutex_lock(&(dev->dev_mutex));\r\nif (rtsx_chk_stat(chip, RTSX_STAT_DISCONNECT)) {\r\ndev_info(&dev->pci->dev, "-- rtsx-control exiting\n");\r\nmutex_unlock(&dev->dev_mutex);\r\nbreak;\r\n}\r\nscsi_lock(host);\r\nif (rtsx_chk_stat(chip, RTSX_STAT_ABORT)) {\r\nchip->srb->result = DID_ABORT << 16;\r\ngoto SkipForAbort;\r\n}\r\nscsi_unlock(host);\r\nif (chip->srb->sc_data_direction == DMA_BIDIRECTIONAL) {\r\ndev_err(&dev->pci->dev, "UNKNOWN data direction\n");\r\nchip->srb->result = DID_ERROR << 16;\r\n}\r\nelse if (chip->srb->device->id) {\r\ndev_err(&dev->pci->dev, "Bad target number (%d:%d)\n",\r\nchip->srb->device->id,\r\n(u8)chip->srb->device->lun);\r\nchip->srb->result = DID_BAD_TARGET << 16;\r\n}\r\nelse if (chip->srb->device->lun > chip->max_lun) {\r\ndev_err(&dev->pci->dev, "Bad LUN (%d:%d)\n",\r\nchip->srb->device->id,\r\n(u8)chip->srb->device->lun);\r\nchip->srb->result = DID_BAD_TARGET << 16;\r\n}\r\nelse {\r\nscsi_show_command(chip);\r\nrtsx_invoke_transport(chip->srb, chip);\r\n}\r\nscsi_lock(host);\r\nif (!chip->srb)\r\n;\r\nelse if (chip->srb->result != DID_ABORT << 16) {\r\nchip->srb->scsi_done(chip->srb);\r\n} else {\r\nSkipForAbort:\r\ndev_err(&dev->pci->dev, "scsi command aborted\n");\r\n}\r\nif (rtsx_chk_stat(chip, RTSX_STAT_ABORT)) {\r\ncomplete(&(dev->notify));\r\nrtsx_set_stat(chip, RTSX_STAT_IDLE);\r\n}\r\nchip->srb = NULL;\r\nscsi_unlock(host);\r\nmutex_unlock(&dev->dev_mutex);\r\n}\r\ncomplete_and_exit(&dev->control_exit, 0);\r\n}\r\nstatic int rtsx_polling_thread(void *__dev)\r\n{\r\nstruct rtsx_dev *dev = __dev;\r\nstruct rtsx_chip *chip = dev->chip;\r\nstruct sd_info *sd_card = &(chip->sd_card);\r\nstruct xd_info *xd_card = &(chip->xd_card);\r\nstruct ms_info *ms_card = &(chip->ms_card);\r\nsd_card->cleanup_counter = 0;\r\nxd_card->cleanup_counter = 0;\r\nms_card->cleanup_counter = 0;\r\nwait_timeout((delay_use + 5) * 1000);\r\nfor (;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(POLLING_INTERVAL);\r\nmutex_lock(&(dev->dev_mutex));\r\nif (rtsx_chk_stat(chip, RTSX_STAT_DISCONNECT)) {\r\ndev_info(&dev->pci->dev, "-- rtsx-polling exiting\n");\r\nmutex_unlock(&dev->dev_mutex);\r\nbreak;\r\n}\r\nmutex_unlock(&dev->dev_mutex);\r\nmspro_polling_format_status(chip);\r\nmutex_lock(&(dev->dev_mutex));\r\nrtsx_polling_func(chip);\r\nmutex_unlock(&dev->dev_mutex);\r\n}\r\ncomplete_and_exit(&dev->polling_exit, 0);\r\n}\r\nstatic irqreturn_t rtsx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct rtsx_dev *dev = dev_id;\r\nstruct rtsx_chip *chip;\r\nint retval;\r\nu32 status;\r\nif (dev)\r\nchip = dev->chip;\r\nelse\r\nreturn IRQ_NONE;\r\nif (!chip)\r\nreturn IRQ_NONE;\r\nspin_lock(&dev->reg_lock);\r\nretval = rtsx_pre_handle_interrupt(chip);\r\nif (retval == STATUS_FAIL) {\r\nspin_unlock(&dev->reg_lock);\r\nif (chip->int_reg == 0xFFFFFFFF)\r\nreturn IRQ_HANDLED;\r\nreturn IRQ_NONE;\r\n}\r\nstatus = chip->int_reg;\r\nif (dev->check_card_cd) {\r\nif (!(dev->check_card_cd & status)) {\r\ndev->trans_result = TRANS_RESULT_FAIL;\r\nif (dev->done)\r\ncomplete(dev->done);\r\ngoto Exit;\r\n}\r\n}\r\nif (status & (NEED_COMPLETE_INT | DELINK_INT)) {\r\nif (status & (TRANS_FAIL_INT | DELINK_INT)) {\r\nif (status & DELINK_INT)\r\nRTSX_SET_DELINK(chip);\r\ndev->trans_result = TRANS_RESULT_FAIL;\r\nif (dev->done)\r\ncomplete(dev->done);\r\n} else if (status & TRANS_OK_INT) {\r\ndev->trans_result = TRANS_RESULT_OK;\r\nif (dev->done)\r\ncomplete(dev->done);\r\n} else if (status & DATA_DONE_INT) {\r\ndev->trans_result = TRANS_NOT_READY;\r\nif (dev->done && (dev->trans_state == STATE_TRANS_SG))\r\ncomplete(dev->done);\r\n}\r\n}\r\nExit:\r\nspin_unlock(&dev->reg_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void rtsx_release_resources(struct rtsx_dev *dev)\r\n{\r\ndev_info(&dev->pci->dev, "-- %s\n", __func__);\r\ndev_info(&dev->pci->dev, "-- sending exit command to thread\n");\r\ncomplete(&dev->cmnd_ready);\r\nif (dev->ctl_thread)\r\nwait_for_completion(&dev->control_exit);\r\nif (dev->polling_thread)\r\nwait_for_completion(&dev->polling_exit);\r\nwait_timeout(200);\r\nif (dev->rtsx_resv_buf) {\r\ndma_free_coherent(&(dev->pci->dev), RTSX_RESV_BUF_LEN,\r\ndev->rtsx_resv_buf, dev->rtsx_resv_buf_addr);\r\ndev->chip->host_cmds_ptr = NULL;\r\ndev->chip->host_sg_tbl_ptr = NULL;\r\n}\r\nif (dev->irq > 0)\r\nfree_irq(dev->irq, (void *)dev);\r\nif (dev->chip->msi_en)\r\npci_disable_msi(dev->pci);\r\nif (dev->remap_addr)\r\niounmap(dev->remap_addr);\r\npci_disable_device(dev->pci);\r\npci_release_regions(dev->pci);\r\nrtsx_release_chip(dev->chip);\r\nkfree(dev->chip);\r\n}\r\nstatic void quiesce_and_remove_host(struct rtsx_dev *dev)\r\n{\r\nstruct Scsi_Host *host = rtsx_to_host(dev);\r\nstruct rtsx_chip *chip = dev->chip;\r\nmutex_lock(&dev->dev_mutex);\r\nscsi_lock(host);\r\nrtsx_set_stat(chip, RTSX_STAT_DISCONNECT);\r\nscsi_unlock(host);\r\nmutex_unlock(&dev->dev_mutex);\r\nwake_up(&dev->delay_wait);\r\nwait_for_completion(&dev->scanning_done);\r\nwait_timeout(100);\r\nmutex_lock(&dev->dev_mutex);\r\nif (chip->srb) {\r\nchip->srb->result = DID_NO_CONNECT << 16;\r\nscsi_lock(host);\r\nchip->srb->scsi_done(dev->chip->srb);\r\nchip->srb = NULL;\r\nscsi_unlock(host);\r\n}\r\nmutex_unlock(&dev->dev_mutex);\r\nscsi_remove_host(host);\r\n}\r\nstatic void release_everything(struct rtsx_dev *dev)\r\n{\r\nrtsx_release_resources(dev);\r\nscsi_host_put(rtsx_to_host(dev));\r\n}\r\nstatic int rtsx_scan_thread(void *__dev)\r\n{\r\nstruct rtsx_dev *dev = (struct rtsx_dev *)__dev;\r\nstruct rtsx_chip *chip = dev->chip;\r\nif (delay_use > 0) {\r\ndev_info(&dev->pci->dev,\r\n"%s: waiting for device to settle before scanning\n",\r\nCR_DRIVER_NAME);\r\nwait_event_interruptible_timeout(dev->delay_wait,\r\nrtsx_chk_stat(chip, RTSX_STAT_DISCONNECT),\r\ndelay_use * HZ);\r\n}\r\nif (!rtsx_chk_stat(chip, RTSX_STAT_DISCONNECT)) {\r\nscsi_scan_host(rtsx_to_host(dev));\r\ndev_info(&dev->pci->dev, "%s: device scan complete\n",\r\nCR_DRIVER_NAME);\r\n}\r\ncomplete_and_exit(&dev->scanning_done, 0);\r\n}\r\nstatic void rtsx_init_options(struct rtsx_chip *chip)\r\n{\r\nchip->vendor_id = chip->rtsx->pci->vendor;\r\nchip->product_id = chip->rtsx->pci->device;\r\nchip->adma_mode = 1;\r\nchip->lun_mc = 0;\r\nchip->driver_first_load = 1;\r\n#ifdef HW_AUTO_SWITCH_SD_BUS\r\nchip->sdio_in_charge = 0;\r\n#endif\r\nchip->mspro_formatter_enable = 1;\r\nchip->ignore_sd = 0;\r\nchip->use_hw_setting = 0;\r\nchip->lun_mode = DEFAULT_SINGLE;\r\nchip->auto_delink_en = auto_delink_en;\r\nchip->ss_en = ss_en;\r\nchip->ss_idle_period = ss_interval * 1000;\r\nchip->remote_wakeup_en = 0;\r\nchip->aspm_l0s_l1_en = aspm_l0s_l1_en;\r\nchip->dynamic_aspm = 1;\r\nchip->fpga_sd_sdr104_clk = CLK_200;\r\nchip->fpga_sd_ddr50_clk = CLK_100;\r\nchip->fpga_sd_sdr50_clk = CLK_100;\r\nchip->fpga_sd_hs_clk = CLK_100;\r\nchip->fpga_mmc_52m_clk = CLK_80;\r\nchip->fpga_ms_hg_clk = CLK_80;\r\nchip->fpga_ms_4bit_clk = CLK_80;\r\nchip->fpga_ms_1bit_clk = CLK_40;\r\nchip->asic_sd_sdr104_clk = 203;\r\nchip->asic_sd_sdr50_clk = 98;\r\nchip->asic_sd_ddr50_clk = 98;\r\nchip->asic_sd_hs_clk = 98;\r\nchip->asic_mmc_52m_clk = 98;\r\nchip->asic_ms_hg_clk = 117;\r\nchip->asic_ms_4bit_clk = 78;\r\nchip->asic_ms_1bit_clk = 39;\r\nchip->ssc_depth_sd_sdr104 = SSC_DEPTH_2M;\r\nchip->ssc_depth_sd_sdr50 = SSC_DEPTH_2M;\r\nchip->ssc_depth_sd_ddr50 = SSC_DEPTH_1M;\r\nchip->ssc_depth_sd_hs = SSC_DEPTH_1M;\r\nchip->ssc_depth_mmc_52m = SSC_DEPTH_1M;\r\nchip->ssc_depth_ms_hg = SSC_DEPTH_1M;\r\nchip->ssc_depth_ms_4bit = SSC_DEPTH_512K;\r\nchip->ssc_depth_low_speed = SSC_DEPTH_512K;\r\nchip->ssc_en = 1;\r\nchip->sd_speed_prior = 0x01040203;\r\nchip->sd_current_prior = 0x00010203;\r\nchip->sd_ctl = SD_PUSH_POINT_AUTO |\r\nSD_SAMPLE_POINT_AUTO |\r\nSUPPORT_MMC_DDR_MODE;\r\nchip->sd_ddr_tx_phase = 0;\r\nchip->mmc_ddr_tx_phase = 1;\r\nchip->sd_default_tx_phase = 15;\r\nchip->sd_default_rx_phase = 15;\r\nchip->pmos_pwr_on_interval = 200;\r\nchip->sd_voltage_switch_delay = 1000;\r\nchip->ms_power_class_en = 3;\r\nchip->sd_400mA_ocp_thd = 1;\r\nchip->sd_800mA_ocp_thd = 5;\r\nchip->ms_ocp_thd = 2;\r\nchip->card_drive_sel = 0x55;\r\nchip->sd30_drive_sel_1v8 = 0x03;\r\nchip->sd30_drive_sel_3v3 = 0x01;\r\nchip->do_delink_before_power_down = 1;\r\nchip->auto_power_down = 1;\r\nchip->polling_config = 0;\r\nchip->force_clkreq_0 = 1;\r\nchip->ft2_fast_mode = 0;\r\nchip->sdio_retry_cnt = 1;\r\nchip->xd_timeout = 2000;\r\nchip->sd_timeout = 10000;\r\nchip->ms_timeout = 2000;\r\nchip->mspro_timeout = 15000;\r\nchip->power_down_in_ss = 1;\r\nchip->sdr104_en = 1;\r\nchip->sdr50_en = 1;\r\nchip->ddr50_en = 1;\r\nchip->delink_stage1_step = 100;\r\nchip->delink_stage2_step = 40;\r\nchip->delink_stage3_step = 20;\r\nchip->auto_delink_in_L1 = 1;\r\nchip->blink_led = 1;\r\nchip->msi_en = msi_en;\r\nchip->hp_watch_bios_hotplug = 0;\r\nchip->max_payload = 0;\r\nchip->phy_voltage = 0;\r\nchip->support_ms_8bit = 1;\r\nchip->s3_pwr_off_delay = 1000;\r\n}\r\nstatic int rtsx_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct Scsi_Host *host;\r\nstruct rtsx_dev *dev;\r\nint err = 0;\r\nstruct task_struct *th;\r\ndev_dbg(&pci->dev, "Realtek PCI-E card reader detected\n");\r\nerr = pci_enable_device(pci);\r\nif (err < 0) {\r\ndev_err(&pci->dev, "PCI enable device failed!\n");\r\nreturn err;\r\n}\r\nerr = pci_request_regions(pci, CR_DRIVER_NAME);\r\nif (err < 0) {\r\ndev_err(&pci->dev, "PCI request regions for %s failed!\n",\r\nCR_DRIVER_NAME);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nhost = scsi_host_alloc(&rtsx_host_template, sizeof(*dev));\r\nif (!host) {\r\ndev_err(&pci->dev, "Unable to allocate the scsi host\n");\r\npci_release_regions(pci);\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\ndev = host_to_rtsx(host);\r\nmemset(dev, 0, sizeof(struct rtsx_dev));\r\ndev->chip = kzalloc(sizeof(struct rtsx_chip), GFP_KERNEL);\r\nif (dev->chip == NULL) {\r\nerr = -ENOMEM;\r\ngoto errout;\r\n}\r\nspin_lock_init(&dev->reg_lock);\r\nmutex_init(&(dev->dev_mutex));\r\ninit_completion(&dev->cmnd_ready);\r\ninit_completion(&dev->control_exit);\r\ninit_completion(&dev->polling_exit);\r\ninit_completion(&(dev->notify));\r\ninit_completion(&dev->scanning_done);\r\ninit_waitqueue_head(&dev->delay_wait);\r\ndev->pci = pci;\r\ndev->irq = -1;\r\ndev_info(&pci->dev, "Resource length: 0x%x\n",\r\n(unsigned int)pci_resource_len(pci, 0));\r\ndev->addr = pci_resource_start(pci, 0);\r\ndev->remap_addr = ioremap_nocache(dev->addr, pci_resource_len(pci, 0));\r\nif (dev->remap_addr == NULL) {\r\ndev_err(&pci->dev, "ioremap error\n");\r\nerr = -ENXIO;\r\ngoto errout;\r\n}\r\ndev_info(&pci->dev, "Original address: 0x%lx, remapped address: 0x%lx\n",\r\n(unsigned long)(dev->addr), (unsigned long)(dev->remap_addr));\r\ndev->rtsx_resv_buf = dma_alloc_coherent(&(pci->dev), RTSX_RESV_BUF_LEN,\r\n&(dev->rtsx_resv_buf_addr), GFP_KERNEL);\r\nif (dev->rtsx_resv_buf == NULL) {\r\ndev_err(&pci->dev, "alloc dma buffer fail\n");\r\nerr = -ENXIO;\r\ngoto errout;\r\n}\r\ndev->chip->host_cmds_ptr = dev->rtsx_resv_buf;\r\ndev->chip->host_cmds_addr = dev->rtsx_resv_buf_addr;\r\ndev->chip->host_sg_tbl_ptr = dev->rtsx_resv_buf + HOST_CMDS_BUF_LEN;\r\ndev->chip->host_sg_tbl_addr = dev->rtsx_resv_buf_addr +\r\nHOST_CMDS_BUF_LEN;\r\ndev->chip->rtsx = dev;\r\nrtsx_init_options(dev->chip);\r\ndev_info(&pci->dev, "pci->irq = %d\n", pci->irq);\r\nif (dev->chip->msi_en) {\r\nif (pci_enable_msi(pci) < 0)\r\ndev->chip->msi_en = 0;\r\n}\r\nif (rtsx_acquire_irq(dev) < 0) {\r\nerr = -EBUSY;\r\ngoto errout;\r\n}\r\npci_set_master(pci);\r\nsynchronize_irq(dev->irq);\r\nrtsx_init_chip(dev->chip);\r\nhost->max_id = 1;\r\nhost->max_lun = dev->chip->max_lun;\r\nth = kthread_run(rtsx_control_thread, dev, CR_DRIVER_NAME);\r\nif (IS_ERR(th)) {\r\ndev_err(&pci->dev, "Unable to start control thread\n");\r\nerr = PTR_ERR(th);\r\ngoto errout;\r\n}\r\ndev->ctl_thread = th;\r\nerr = scsi_add_host(host, &pci->dev);\r\nif (err) {\r\ndev_err(&pci->dev, "Unable to add the scsi host\n");\r\ngoto errout;\r\n}\r\nth = kthread_run(rtsx_scan_thread, dev, "rtsx-scan");\r\nif (IS_ERR(th)) {\r\ndev_err(&pci->dev, "Unable to start the device-scanning thread\n");\r\ncomplete(&dev->scanning_done);\r\nquiesce_and_remove_host(dev);\r\nerr = PTR_ERR(th);\r\ngoto errout;\r\n}\r\nth = kthread_run(rtsx_polling_thread, dev, "rtsx-polling");\r\nif (IS_ERR(th)) {\r\ndev_err(&pci->dev, "Unable to start the device-polling thread\n");\r\nquiesce_and_remove_host(dev);\r\nerr = PTR_ERR(th);\r\ngoto errout;\r\n}\r\ndev->polling_thread = th;\r\npci_set_drvdata(pci, dev);\r\nreturn 0;\r\nerrout:\r\ndev_err(&pci->dev, "rtsx_probe() failed\n");\r\nrelease_everything(dev);\r\nreturn err;\r\n}\r\nstatic void rtsx_remove(struct pci_dev *pci)\r\n{\r\nstruct rtsx_dev *dev = pci_get_drvdata(pci);\r\ndev_info(&pci->dev, "rtsx_remove() called\n");\r\nquiesce_and_remove_host(dev);\r\nrelease_everything(dev);\r\npci_set_drvdata(pci, NULL);\r\n}\r\nstatic int __init rtsx_init(void)\r\n{\r\npr_info("Initializing Realtek PCIE storage driver...\n");\r\nreturn pci_register_driver(&driver);\r\n}\r\nstatic void __exit rtsx_exit(void)\r\n{\r\npr_info("rtsx_exit() called\n");\r\npci_unregister_driver(&driver);\r\npr_info("%s module exit\n", CR_DRIVER_NAME);\r\n}
