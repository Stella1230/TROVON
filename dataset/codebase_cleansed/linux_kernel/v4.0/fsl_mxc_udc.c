int fsl_udc_clk_init(struct platform_device *pdev)\r\n{\r\nstruct fsl_usb2_platform_data *pdata;\r\nunsigned long freq;\r\nint ret;\r\npdata = dev_get_platdata(&pdev->dev);\r\nmxc_ipg_clk = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(mxc_ipg_clk)) {\r\ndev_err(&pdev->dev, "clk_get(\"ipg\") failed\n");\r\nreturn PTR_ERR(mxc_ipg_clk);\r\n}\r\nmxc_ahb_clk = devm_clk_get(&pdev->dev, "ahb");\r\nif (IS_ERR(mxc_ahb_clk)) {\r\ndev_err(&pdev->dev, "clk_get(\"ahb\") failed\n");\r\nreturn PTR_ERR(mxc_ahb_clk);\r\n}\r\nmxc_per_clk = devm_clk_get(&pdev->dev, "per");\r\nif (IS_ERR(mxc_per_clk)) {\r\ndev_err(&pdev->dev, "clk_get(\"per\") failed\n");\r\nreturn PTR_ERR(mxc_per_clk);\r\n}\r\nclk_prepare_enable(mxc_ipg_clk);\r\nclk_prepare_enable(mxc_ahb_clk);\r\nclk_prepare_enable(mxc_per_clk);\r\nif (!strcmp(pdev->id_entry->name, "imx-udc-mx27")) {\r\nfreq = clk_get_rate(mxc_per_clk);\r\nif (pdata->phy_mode != FSL_USB2_PHY_ULPI &&\r\n(freq < 59999000 || freq > 60001000)) {\r\ndev_err(&pdev->dev, "USB_CLK=%lu, should be 60MHz\n", freq);\r\nret = -EINVAL;\r\ngoto eclkrate;\r\n}\r\n}\r\nreturn 0;\r\neclkrate:\r\nclk_disable_unprepare(mxc_ipg_clk);\r\nclk_disable_unprepare(mxc_ahb_clk);\r\nclk_disable_unprepare(mxc_per_clk);\r\nmxc_per_clk = NULL;\r\nreturn ret;\r\n}\r\nint fsl_udc_clk_finalize(struct platform_device *pdev)\r\n{\r\nstruct fsl_usb2_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nint ret = 0;\r\nif (pdata->workaround & FLS_USB2_WORKAROUND_ENGCM09152) {\r\nunsigned int v;\r\nstruct resource *res = platform_get_resource\r\n(pdev, IORESOURCE_MEM, 0);\r\nvoid __iomem *phy_regs = ioremap(res->start +\r\nMX35_USBPHYCTRL_OFFSET, 512);\r\nif (!phy_regs) {\r\ndev_err(&pdev->dev, "ioremap for phy address fails\n");\r\nret = -EINVAL;\r\ngoto ioremap_err;\r\n}\r\nv = readl(phy_regs + USBPHYCTRL_OTGBASE_OFFSET);\r\nwritel(v | USBPHYCTRL_EVDO,\r\nphy_regs + USBPHYCTRL_OTGBASE_OFFSET);\r\niounmap(phy_regs);\r\n}\r\nioremap_err:\r\nif (pdata->phy_mode == FSL_USB2_PHY_ULPI) {\r\nclk_disable_unprepare(mxc_per_clk);\r\nmxc_per_clk = NULL;\r\n}\r\nreturn ret;\r\n}\r\nvoid fsl_udc_clk_release(void)\r\n{\r\nif (mxc_per_clk)\r\nclk_disable_unprepare(mxc_per_clk);\r\nclk_disable_unprepare(mxc_ahb_clk);\r\nclk_disable_unprepare(mxc_ipg_clk);\r\n}
