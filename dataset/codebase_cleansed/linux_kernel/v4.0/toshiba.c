static int tosh_fn_status(void)\r\n{\r\nunsigned char scan;\r\nunsigned long flags;\r\nif (tosh_fn!=0) {\r\nscan = inb(tosh_fn);\r\n} else {\r\nlocal_irq_save(flags);\r\noutb(0x8e, 0xe4);\r\nscan = inb(0xe5);\r\nlocal_irq_restore(flags);\r\n}\r\nreturn (int) scan;\r\n}\r\nstatic int tosh_emulate_fan(SMMRegisters *regs)\r\n{\r\nunsigned long eax,ecx,flags;\r\nunsigned char al;\r\neax = regs->eax & 0xff00;\r\necx = regs->ecx & 0xffff;\r\nif (tosh_id==0xfccb) {\r\nif (eax==0xfe00) {\r\nlocal_irq_save(flags);\r\noutb(0xbe, 0xe4);\r\nal = inb(0xe5);\r\nlocal_irq_restore(flags);\r\nregs->eax = 0x00;\r\nregs->ecx = (unsigned int) (al & 0x01);\r\n}\r\nif ((eax==0xff00) && (ecx==0x0000)) {\r\nlocal_irq_save(flags);\r\noutb(0xbe, 0xe4);\r\nal = inb(0xe5);\r\noutb(0xbe, 0xe4);\r\noutb (al | 0x01, 0xe5);\r\nlocal_irq_restore(flags);\r\nregs->eax = 0x00;\r\nregs->ecx = 0x00;\r\n}\r\nif ((eax==0xff00) && (ecx==0x0001)) {\r\nlocal_irq_save(flags);\r\noutb(0xbe, 0xe4);\r\nal = inb(0xe5);\r\noutb(0xbe, 0xe4);\r\noutb(al & 0xfe, 0xe5);\r\nlocal_irq_restore(flags);\r\nregs->eax = 0x00;\r\nregs->ecx = 0x01;\r\n}\r\n}\r\nif (tosh_id==0xfccc) {\r\nif (eax==0xfe00) {\r\nlocal_irq_save(flags);\r\noutb(0xe0, 0xe4);\r\nal = inb(0xe5);\r\nlocal_irq_restore(flags);\r\nregs->eax = 0x00;\r\nregs->ecx = al & 0x01;\r\n}\r\nif ((eax==0xff00) && (ecx==0x0000)) {\r\nlocal_irq_save(flags);\r\noutb(0xe0, 0xe4);\r\nal = inb(0xe5);\r\noutw(0xe0 | ((al & 0xfe) << 8), 0xe4);\r\nlocal_irq_restore(flags);\r\nregs->eax = 0x00;\r\nregs->ecx = 0x00;\r\n}\r\nif ((eax==0xff00) && (ecx==0x0001)) {\r\nlocal_irq_save(flags);\r\noutb(0xe0, 0xe4);\r\nal = inb(0xe5);\r\noutw(0xe0 | ((al | 0x01) << 8), 0xe4);\r\nlocal_irq_restore(flags);\r\nregs->eax = 0x00;\r\nregs->ecx = 0x01;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint tosh_smm(SMMRegisters *regs)\r\n{\r\nint eax;\r\nasm ("# load the values into the registers\n\t" \\r\n"pushl %%eax\n\t" \\r\n"movl 0(%%eax),%%edx\n\t" \\r\n"push %%edx\n\t" \\r\n"movl 4(%%eax),%%ebx\n\t" \\r\n"movl 8(%%eax),%%ecx\n\t" \\r\n"movl 12(%%eax),%%edx\n\t" \\r\n"movl 16(%%eax),%%esi\n\t" \\r\n"movl 20(%%eax),%%edi\n\t" \\r\n"popl %%eax\n\t" \\r\n"# call the System Management mode\n\t" \\r\n"inb $0xb2,%%al\n\t"\r\n"# fill out the memory with the values in the registers\n\t" \\r\n"xchgl %%eax,(%%esp)\n\t"\r\n"movl %%ebx,4(%%eax)\n\t" \\r\n"movl %%ecx,8(%%eax)\n\t" \\r\n"movl %%edx,12(%%eax)\n\t" \\r\n"movl %%esi,16(%%eax)\n\t" \\r\n"movl %%edi,20(%%eax)\n\t" \\r\n"popl %%edx\n\t" \\r\n"movl %%edx,0(%%eax)\n\t" \\r\n"# setup the return value to the carry flag\n\t" \\r\n"lahf\n\t" \\r\n"shrl $8,%%eax\n\t" \\r\n"andl $1,%%eax\n" \\r\n: "=a" (eax)\r\n: "a" (regs)\r\n: "%ebx", "%ecx", "%edx", "%esi", "%edi", "memory");\r\nreturn eax;\r\n}\r\nstatic long tosh_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)\r\n{\r\nSMMRegisters regs;\r\nSMMRegisters __user *argp = (SMMRegisters __user *)arg;\r\nunsigned short ax,bx;\r\nint err;\r\nif (!argp)\r\nreturn -EINVAL;\r\nif (copy_from_user(&regs, argp, sizeof(SMMRegisters)))\r\nreturn -EFAULT;\r\nswitch (cmd) {\r\ncase TOSH_SMM:\r\nax = regs.eax & 0xff00;\r\nbx = regs.ebx & 0xffff;\r\nif (((ax==0xff00) || (ax==0xfe00)) && (bx>0x0069))\r\nreturn -EINVAL;\r\nmutex_lock(&tosh_mutex);\r\nif (tosh_fan==1) {\r\nif (((ax==0xf300) || (ax==0xf400)) && (bx==0x0004)) {\r\nerr = tosh_emulate_fan(&regs);\r\nmutex_unlock(&tosh_mutex);\r\nbreak;\r\n}\r\n}\r\nerr = tosh_smm(&regs);\r\nmutex_unlock(&tosh_mutex);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (copy_to_user(argp, &regs, sizeof(SMMRegisters)))\r\nreturn -EFAULT;\r\nreturn (err==0) ? 0:-EINVAL;\r\n}\r\nstatic int proc_toshiba_show(struct seq_file *m, void *v)\r\n{\r\nint key;\r\nkey = tosh_fn_status();\r\nseq_printf(m, "1.1 0x%04x %d.%d %d.%d 0x%04x 0x%02x\n",\r\ntosh_id,\r\n(tosh_sci & 0xff00)>>8,\r\ntosh_sci & 0xff,\r\n(tosh_bios & 0xff00)>>8,\r\ntosh_bios & 0xff,\r\ntosh_date,\r\nkey);\r\nreturn 0;\r\n}\r\nstatic int proc_toshiba_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, proc_toshiba_show, NULL);\r\n}\r\nstatic void tosh_set_fn_port(void)\r\n{\r\nswitch (tosh_id) {\r\ncase 0xfc02: case 0xfc04: case 0xfc09: case 0xfc0a: case 0xfc10:\r\ncase 0xfc11: case 0xfc13: case 0xfc15: case 0xfc1a: case 0xfc1b:\r\ncase 0xfc5a:\r\ntosh_fn = 0x62;\r\nbreak;\r\ncase 0xfc08: case 0xfc17: case 0xfc1d: case 0xfcd1: case 0xfce0:\r\ncase 0xfce2:\r\ntosh_fn = 0x68;\r\nbreak;\r\ndefault:\r\ntosh_fn = 0x00;\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic int tosh_get_machine_id(void __iomem *bios)\r\n{\r\nint id;\r\nSMMRegisters regs;\r\nunsigned short bx,cx;\r\nunsigned long address;\r\nid = (0x100*(int) readb(bios+0xfffe))+((int) readb(bios+0xfffa));\r\nif (id==0xfc2f) {\r\nregs.eax = 0xc000;\r\nregs.ebx = 0x0000;\r\nregs.ecx = 0x0000;\r\ntosh_smm(&regs);\r\nbx = (unsigned short) (regs.ebx & 0xffff);\r\n#if TOSH_DEBUG\r\nprintk("toshiba: debugging ID ebx=0x%04x\n", regs.ebx);\r\n#endif\r\nbx = 0xe6f5;\r\naddress = bx;\r\ncx = readw(bios + address);\r\naddress = 9+bx+cx;\r\ncx = readw(bios + address);\r\naddress = 0xa+cx;\r\ncx = readw(bios + address);\r\nid = ((cx & 0xff)<<8)+((cx & 0xff00)>>8);\r\n}\r\nreturn id;\r\n}\r\nstatic int tosh_probe(void)\r\n{\r\nint i,major,minor,day,year,month,flag;\r\nunsigned char signature[7] = { 0x54,0x4f,0x53,0x48,0x49,0x42,0x41 };\r\nSMMRegisters regs;\r\nvoid __iomem *bios = ioremap_cache(0xf0000, 0x10000);\r\nif (!bios)\r\nreturn -ENOMEM;\r\nfor (i=0;i<7;i++) {\r\nif (readb(bios+0xe010+i)!=signature[i]) {\r\nprintk("toshiba: not a supported Toshiba laptop\n");\r\niounmap(bios);\r\nreturn -ENODEV;\r\n}\r\n}\r\nregs.eax = 0xf0f0;\r\nregs.ebx = 0x0000;\r\nregs.ecx = 0x0000;\r\nflag = tosh_smm(&regs);\r\nif ((flag==1) || ((regs.eax & 0xff00)==0x8600)) {\r\nprintk("toshiba: not a supported Toshiba laptop\n");\r\niounmap(bios);\r\nreturn -ENODEV;\r\n}\r\ntosh_sci = regs.edx & 0xffff;\r\ntosh_id = tosh_get_machine_id(bios);\r\nmajor = readb(bios+0xe009)-'0';\r\nminor = ((readb(bios+0xe00b)-'0')*10)+(readb(bios+0xe00c)-'0');\r\ntosh_bios = (major*0x100)+minor;\r\nday = ((readb(bios+0xfff5)-'0')*10)+(readb(bios+0xfff6)-'0');\r\nmonth = ((readb(bios+0xfff8)-'0')*10)+(readb(bios+0xfff9)-'0');\r\nyear = ((readb(bios+0xfffb)-'0')*10)+(readb(bios+0xfffc)-'0');\r\ntosh_date = (((year-90) & 0x1f)<<10) | ((month & 0xf)<<6)\r\n| ((day & 0x1f)<<1);\r\nif ((tosh_id==0xfccb) || (tosh_id==0xfccc))\r\ntosh_fan = 1;\r\niounmap(bios);\r\nreturn 0;\r\n}\r\nstatic int __init toshiba_init(void)\r\n{\r\nint retval;\r\nif (tosh_probe())\r\nreturn -ENODEV;\r\nprintk(KERN_INFO "Toshiba System Management Mode driver v" TOSH_VERSION "\n");\r\nif (tosh_fn==0x00)\r\ntosh_set_fn_port();\r\nretval = misc_register(&tosh_device);\r\nif (retval < 0)\r\nreturn retval;\r\n#ifdef CONFIG_PROC_FS\r\n{\r\nstruct proc_dir_entry *pde;\r\npde = proc_create("toshiba", 0, NULL, &proc_toshiba_fops);\r\nif (!pde) {\r\nmisc_deregister(&tosh_device);\r\nreturn -ENOMEM;\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __exit toshiba_exit(void)\r\n{\r\nremove_proc_entry("toshiba", NULL);\r\nmisc_deregister(&tosh_device);\r\n}
