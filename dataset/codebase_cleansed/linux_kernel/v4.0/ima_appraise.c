static int __init default_appraise_setup(char *str)\r\n{\r\nif (strncmp(str, "off", 3) == 0)\r\nima_appraise = 0;\r\nelse if (strncmp(str, "log", 3) == 0)\r\nima_appraise = IMA_APPRAISE_LOG;\r\nelse if (strncmp(str, "fix", 3) == 0)\r\nima_appraise = IMA_APPRAISE_FIX;\r\nreturn 1;\r\n}\r\nint ima_must_appraise(struct inode *inode, int mask, enum ima_hooks func)\r\n{\r\nif (!ima_appraise)\r\nreturn 0;\r\nreturn ima_match_policy(inode, func, mask, IMA_APPRAISE);\r\n}\r\nstatic int ima_fix_xattr(struct dentry *dentry,\r\nstruct integrity_iint_cache *iint)\r\n{\r\nint rc, offset;\r\nu8 algo = iint->ima_hash->algo;\r\nif (algo <= HASH_ALGO_SHA1) {\r\noffset = 1;\r\niint->ima_hash->xattr.sha1.type = IMA_XATTR_DIGEST;\r\n} else {\r\noffset = 0;\r\niint->ima_hash->xattr.ng.type = IMA_XATTR_DIGEST_NG;\r\niint->ima_hash->xattr.ng.algo = algo;\r\n}\r\nrc = __vfs_setxattr_noperm(dentry, XATTR_NAME_IMA,\r\n&iint->ima_hash->xattr.data[offset],\r\n(sizeof(iint->ima_hash->xattr) - offset) +\r\niint->ima_hash->length, 0);\r\nreturn rc;\r\n}\r\nenum integrity_status ima_get_cache_status(struct integrity_iint_cache *iint,\r\nint func)\r\n{\r\nswitch (func) {\r\ncase MMAP_CHECK:\r\nreturn iint->ima_mmap_status;\r\ncase BPRM_CHECK:\r\nreturn iint->ima_bprm_status;\r\ncase MODULE_CHECK:\r\nreturn iint->ima_module_status;\r\ncase FIRMWARE_CHECK:\r\nreturn iint->ima_firmware_status;\r\ncase FILE_CHECK:\r\ndefault:\r\nreturn iint->ima_file_status;\r\n}\r\n}\r\nstatic void ima_set_cache_status(struct integrity_iint_cache *iint,\r\nint func, enum integrity_status status)\r\n{\r\nswitch (func) {\r\ncase MMAP_CHECK:\r\niint->ima_mmap_status = status;\r\nbreak;\r\ncase BPRM_CHECK:\r\niint->ima_bprm_status = status;\r\nbreak;\r\ncase MODULE_CHECK:\r\niint->ima_module_status = status;\r\nbreak;\r\ncase FIRMWARE_CHECK:\r\niint->ima_firmware_status = status;\r\nbreak;\r\ncase FILE_CHECK:\r\ndefault:\r\niint->ima_file_status = status;\r\nbreak;\r\n}\r\n}\r\nstatic void ima_cache_flags(struct integrity_iint_cache *iint, int func)\r\n{\r\nswitch (func) {\r\ncase MMAP_CHECK:\r\niint->flags |= (IMA_MMAP_APPRAISED | IMA_APPRAISED);\r\nbreak;\r\ncase BPRM_CHECK:\r\niint->flags |= (IMA_BPRM_APPRAISED | IMA_APPRAISED);\r\nbreak;\r\ncase MODULE_CHECK:\r\niint->flags |= (IMA_MODULE_APPRAISED | IMA_APPRAISED);\r\nbreak;\r\ncase FIRMWARE_CHECK:\r\niint->flags |= (IMA_FIRMWARE_APPRAISED | IMA_APPRAISED);\r\nbreak;\r\ncase FILE_CHECK:\r\ndefault:\r\niint->flags |= (IMA_FILE_APPRAISED | IMA_APPRAISED);\r\nbreak;\r\n}\r\n}\r\nvoid ima_get_hash_algo(struct evm_ima_xattr_data *xattr_value, int xattr_len,\r\nstruct ima_digest_data *hash)\r\n{\r\nstruct signature_v2_hdr *sig;\r\nif (!xattr_value || xattr_len < 2)\r\nreturn;\r\nswitch (xattr_value->type) {\r\ncase EVM_IMA_XATTR_DIGSIG:\r\nsig = (typeof(sig))xattr_value;\r\nif (sig->version != 2 || xattr_len <= sizeof(*sig))\r\nreturn;\r\nhash->algo = sig->hash_algo;\r\nbreak;\r\ncase IMA_XATTR_DIGEST_NG:\r\nhash->algo = xattr_value->digest[0];\r\nbreak;\r\ncase IMA_XATTR_DIGEST:\r\nif (xattr_len == 21) {\r\nunsigned int zero = 0;\r\nif (!memcmp(&xattr_value->digest[16], &zero, 4))\r\nhash->algo = HASH_ALGO_MD5;\r\nelse\r\nhash->algo = HASH_ALGO_SHA1;\r\n} else if (xattr_len == 17)\r\nhash->algo = HASH_ALGO_MD5;\r\nbreak;\r\n}\r\n}\r\nint ima_read_xattr(struct dentry *dentry,\r\nstruct evm_ima_xattr_data **xattr_value)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nif (!inode->i_op->getxattr)\r\nreturn 0;\r\nreturn vfs_getxattr_alloc(dentry, XATTR_NAME_IMA, (char **)xattr_value,\r\n0, GFP_NOFS);\r\n}\r\nint ima_appraise_measurement(int func, struct integrity_iint_cache *iint,\r\nstruct file *file, const unsigned char *filename,\r\nstruct evm_ima_xattr_data *xattr_value,\r\nint xattr_len, int opened)\r\n{\r\nstatic const char op[] = "appraise_data";\r\nchar *cause = "unknown";\r\nstruct dentry *dentry = file->f_path.dentry;\r\nstruct inode *inode = dentry->d_inode;\r\nenum integrity_status status = INTEGRITY_UNKNOWN;\r\nint rc = xattr_len, hash_start = 0;\r\nif (!inode->i_op->getxattr)\r\nreturn INTEGRITY_UNKNOWN;\r\nif (rc <= 0) {\r\nif (rc && rc != -ENODATA)\r\ngoto out;\r\ncause = "missing-hash";\r\nstatus = INTEGRITY_NOLABEL;\r\nif (opened & FILE_CREATED) {\r\niint->flags |= IMA_NEW_FILE;\r\nstatus = INTEGRITY_PASS;\r\n}\r\ngoto out;\r\n}\r\nstatus = evm_verifyxattr(dentry, XATTR_NAME_IMA, xattr_value, rc, iint);\r\nif ((status != INTEGRITY_PASS) && (status != INTEGRITY_UNKNOWN)) {\r\nif ((status == INTEGRITY_NOLABEL)\r\n|| (status == INTEGRITY_NOXATTRS))\r\ncause = "missing-HMAC";\r\nelse if (status == INTEGRITY_FAIL)\r\ncause = "invalid-HMAC";\r\ngoto out;\r\n}\r\nswitch (xattr_value->type) {\r\ncase IMA_XATTR_DIGEST_NG:\r\nhash_start = 1;\r\ncase IMA_XATTR_DIGEST:\r\nif (iint->flags & IMA_DIGSIG_REQUIRED) {\r\ncause = "IMA-signature-required";\r\nstatus = INTEGRITY_FAIL;\r\nbreak;\r\n}\r\nif (xattr_len - sizeof(xattr_value->type) - hash_start >=\r\niint->ima_hash->length)\r\nrc = memcmp(&xattr_value->digest[hash_start],\r\niint->ima_hash->digest,\r\niint->ima_hash->length);\r\nelse\r\nrc = -EINVAL;\r\nif (rc) {\r\ncause = "invalid-hash";\r\nstatus = INTEGRITY_FAIL;\r\nbreak;\r\n}\r\nstatus = INTEGRITY_PASS;\r\nbreak;\r\ncase EVM_IMA_XATTR_DIGSIG:\r\niint->flags |= IMA_DIGSIG;\r\nrc = integrity_digsig_verify(INTEGRITY_KEYRING_IMA,\r\n(const char *)xattr_value, rc,\r\niint->ima_hash->digest,\r\niint->ima_hash->length);\r\nif (rc == -EOPNOTSUPP) {\r\nstatus = INTEGRITY_UNKNOWN;\r\n} else if (rc) {\r\ncause = "invalid-signature";\r\nstatus = INTEGRITY_FAIL;\r\n} else {\r\nstatus = INTEGRITY_PASS;\r\n}\r\nbreak;\r\ndefault:\r\nstatus = INTEGRITY_UNKNOWN;\r\ncause = "unknown-ima-data";\r\nbreak;\r\n}\r\nout:\r\nif (status != INTEGRITY_PASS) {\r\nif ((ima_appraise & IMA_APPRAISE_FIX) &&\r\n(!xattr_value ||\r\nxattr_value->type != EVM_IMA_XATTR_DIGSIG)) {\r\nif (!ima_fix_xattr(dentry, iint))\r\nstatus = INTEGRITY_PASS;\r\n}\r\nintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode, filename,\r\nop, cause, rc, 0);\r\n} else {\r\nima_cache_flags(iint, func);\r\n}\r\nima_set_cache_status(iint, func, status);\r\nreturn status;\r\n}\r\nvoid ima_update_xattr(struct integrity_iint_cache *iint, struct file *file)\r\n{\r\nstruct dentry *dentry = file->f_path.dentry;\r\nint rc = 0;\r\nif (iint->flags & IMA_DIGSIG)\r\nreturn;\r\nrc = ima_collect_measurement(iint, file, NULL, NULL);\r\nif (rc < 0)\r\nreturn;\r\nima_fix_xattr(dentry, iint);\r\n}\r\nvoid ima_inode_post_setattr(struct dentry *dentry)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nstruct integrity_iint_cache *iint;\r\nint must_appraise, rc;\r\nif (!(ima_policy_flag & IMA_APPRAISE) || !S_ISREG(inode->i_mode)\r\n|| !inode->i_op->removexattr)\r\nreturn;\r\nmust_appraise = ima_must_appraise(inode, MAY_ACCESS, POST_SETATTR);\r\niint = integrity_iint_find(inode);\r\nif (iint) {\r\niint->flags &= ~(IMA_APPRAISE | IMA_APPRAISED |\r\nIMA_APPRAISE_SUBMASK | IMA_APPRAISED_SUBMASK |\r\nIMA_ACTION_FLAGS);\r\nif (must_appraise)\r\niint->flags |= IMA_APPRAISE;\r\n}\r\nif (!must_appraise)\r\nrc = inode->i_op->removexattr(dentry, XATTR_NAME_IMA);\r\nreturn;\r\n}\r\nstatic int ima_protect_xattr(struct dentry *dentry, const char *xattr_name,\r\nconst void *xattr_value, size_t xattr_value_len)\r\n{\r\nif (strcmp(xattr_name, XATTR_NAME_IMA) == 0) {\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ima_reset_appraise_flags(struct inode *inode, int digsig)\r\n{\r\nstruct integrity_iint_cache *iint;\r\nif (!(ima_policy_flag & IMA_APPRAISE) || !S_ISREG(inode->i_mode))\r\nreturn;\r\niint = integrity_iint_find(inode);\r\nif (!iint)\r\nreturn;\r\niint->flags &= ~IMA_DONE_MASK;\r\nif (digsig)\r\niint->flags |= IMA_DIGSIG;\r\nreturn;\r\n}\r\nint ima_inode_setxattr(struct dentry *dentry, const char *xattr_name,\r\nconst void *xattr_value, size_t xattr_value_len)\r\n{\r\nconst struct evm_ima_xattr_data *xvalue = xattr_value;\r\nint result;\r\nresult = ima_protect_xattr(dentry, xattr_name, xattr_value,\r\nxattr_value_len);\r\nif (result == 1) {\r\nif (!xattr_value_len || (xvalue->type >= IMA_XATTR_LAST))\r\nreturn -EINVAL;\r\nima_reset_appraise_flags(dentry->d_inode,\r\n(xvalue->type == EVM_IMA_XATTR_DIGSIG) ? 1 : 0);\r\nresult = 0;\r\n}\r\nreturn result;\r\n}\r\nint ima_inode_removexattr(struct dentry *dentry, const char *xattr_name)\r\n{\r\nint result;\r\nresult = ima_protect_xattr(dentry, xattr_name, NULL, 0);\r\nif (result == 1) {\r\nima_reset_appraise_flags(dentry->d_inode, 0);\r\nresult = 0;\r\n}\r\nreturn result;\r\n}
