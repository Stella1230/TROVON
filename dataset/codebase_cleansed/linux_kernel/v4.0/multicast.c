static int batadv_mcast_mla_softif_get(struct net_device *dev,\r\nstruct hlist_head *mcast_list)\r\n{\r\nstruct netdev_hw_addr *mc_list_entry;\r\nstruct batadv_hw_addr *new;\r\nint ret = 0;\r\nnetif_addr_lock_bh(dev);\r\nnetdev_for_each_mc_addr(mc_list_entry, dev) {\r\nnew = kmalloc(sizeof(*new), GFP_ATOMIC);\r\nif (!new) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nether_addr_copy(new->addr, mc_list_entry->addr);\r\nhlist_add_head(&new->list, mcast_list);\r\nret++;\r\n}\r\nnetif_addr_unlock_bh(dev);\r\nreturn ret;\r\n}\r\nstatic bool batadv_mcast_mla_is_duplicate(uint8_t *mcast_addr,\r\nstruct hlist_head *mcast_list)\r\n{\r\nstruct batadv_hw_addr *mcast_entry;\r\nhlist_for_each_entry(mcast_entry, mcast_list, list)\r\nif (batadv_compare_eth(mcast_entry->addr, mcast_addr))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void batadv_mcast_mla_list_free(struct hlist_head *mcast_list)\r\n{\r\nstruct batadv_hw_addr *mcast_entry;\r\nstruct hlist_node *tmp;\r\nhlist_for_each_entry_safe(mcast_entry, tmp, mcast_list, list) {\r\nhlist_del(&mcast_entry->list);\r\nkfree(mcast_entry);\r\n}\r\n}\r\nstatic void batadv_mcast_mla_tt_retract(struct batadv_priv *bat_priv,\r\nstruct hlist_head *mcast_list)\r\n{\r\nstruct batadv_hw_addr *mcast_entry;\r\nstruct hlist_node *tmp;\r\nhlist_for_each_entry_safe(mcast_entry, tmp, &bat_priv->mcast.mla_list,\r\nlist) {\r\nif (mcast_list &&\r\nbatadv_mcast_mla_is_duplicate(mcast_entry->addr,\r\nmcast_list))\r\ncontinue;\r\nbatadv_tt_local_remove(bat_priv, mcast_entry->addr,\r\nBATADV_NO_FLAGS,\r\n"mcast TT outdated", false);\r\nhlist_del(&mcast_entry->list);\r\nkfree(mcast_entry);\r\n}\r\n}\r\nstatic void batadv_mcast_mla_tt_add(struct batadv_priv *bat_priv,\r\nstruct hlist_head *mcast_list)\r\n{\r\nstruct batadv_hw_addr *mcast_entry;\r\nstruct hlist_node *tmp;\r\nif (!mcast_list)\r\nreturn;\r\nhlist_for_each_entry_safe(mcast_entry, tmp, mcast_list, list) {\r\nif (batadv_mcast_mla_is_duplicate(mcast_entry->addr,\r\n&bat_priv->mcast.mla_list))\r\ncontinue;\r\nif (!batadv_tt_local_add(bat_priv->soft_iface,\r\nmcast_entry->addr, BATADV_NO_FLAGS,\r\nBATADV_NULL_IFINDEX, BATADV_NO_MARK))\r\ncontinue;\r\nhlist_del(&mcast_entry->list);\r\nhlist_add_head(&mcast_entry->list, &bat_priv->mcast.mla_list);\r\n}\r\n}\r\nstatic bool batadv_mcast_has_bridge(struct batadv_priv *bat_priv)\r\n{\r\nstruct net_device *upper = bat_priv->soft_iface;\r\nrcu_read_lock();\r\ndo {\r\nupper = netdev_master_upper_dev_get_rcu(upper);\r\n} while (upper && !(upper->priv_flags & IFF_EBRIDGE));\r\nrcu_read_unlock();\r\nreturn upper;\r\n}\r\nstatic bool batadv_mcast_mla_tvlv_update(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_tvlv_mcast_data mcast_data;\r\nmcast_data.flags = BATADV_NO_FLAGS;\r\nmemset(mcast_data.reserved, 0, sizeof(mcast_data.reserved));\r\nif (batadv_mcast_has_bridge(bat_priv)) {\r\nif (bat_priv->mcast.enabled) {\r\nbatadv_tvlv_container_unregister(bat_priv,\r\nBATADV_TVLV_MCAST, 1);\r\nbat_priv->mcast.enabled = false;\r\n}\r\nreturn false;\r\n}\r\nif (!bat_priv->mcast.enabled ||\r\nmcast_data.flags != bat_priv->mcast.flags) {\r\nbatadv_tvlv_container_register(bat_priv, BATADV_TVLV_MCAST, 1,\r\n&mcast_data, sizeof(mcast_data));\r\nbat_priv->mcast.flags = mcast_data.flags;\r\nbat_priv->mcast.enabled = true;\r\n}\r\nreturn true;\r\n}\r\nvoid batadv_mcast_mla_update(struct batadv_priv *bat_priv)\r\n{\r\nstruct net_device *soft_iface = bat_priv->soft_iface;\r\nstruct hlist_head mcast_list = HLIST_HEAD_INIT;\r\nint ret;\r\nif (!batadv_mcast_mla_tvlv_update(bat_priv))\r\ngoto update;\r\nret = batadv_mcast_mla_softif_get(soft_iface, &mcast_list);\r\nif (ret < 0)\r\ngoto out;\r\nupdate:\r\nbatadv_mcast_mla_tt_retract(bat_priv, &mcast_list);\r\nbatadv_mcast_mla_tt_add(bat_priv, &mcast_list);\r\nout:\r\nbatadv_mcast_mla_list_free(&mcast_list);\r\n}\r\nstatic int batadv_mcast_forw_mode_check_ipv4(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb,\r\nbool *is_unsnoopable)\r\n{\r\nstruct iphdr *iphdr;\r\nif (!pskb_may_pull(skb, sizeof(struct ethhdr) + sizeof(*iphdr)))\r\nreturn -ENOMEM;\r\niphdr = ip_hdr(skb);\r\nif (!ipv4_is_local_multicast(iphdr->daddr))\r\nreturn -EINVAL;\r\n*is_unsnoopable = true;\r\nreturn 0;\r\n}\r\nstatic int batadv_mcast_forw_mode_check_ipv6(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb,\r\nbool *is_unsnoopable)\r\n{\r\nstruct ipv6hdr *ip6hdr;\r\nif (!pskb_may_pull(skb, sizeof(struct ethhdr) + sizeof(*ip6hdr)))\r\nreturn -ENOMEM;\r\nip6hdr = ipv6_hdr(skb);\r\nif (IPV6_ADDR_MC_SCOPE(&ip6hdr->daddr) != IPV6_ADDR_SCOPE_LINKLOCAL)\r\nreturn -EINVAL;\r\nif (ipv6_addr_is_ll_all_nodes(&ip6hdr->daddr))\r\n*is_unsnoopable = true;\r\nreturn 0;\r\n}\r\nstatic int batadv_mcast_forw_mode_check(struct batadv_priv *bat_priv,\r\nstruct sk_buff *skb,\r\nbool *is_unsnoopable)\r\n{\r\nstruct ethhdr *ethhdr = eth_hdr(skb);\r\nif (!atomic_read(&bat_priv->multicast_mode))\r\nreturn -EINVAL;\r\nif (atomic_read(&bat_priv->mcast.num_disabled))\r\nreturn -EINVAL;\r\nswitch (ntohs(ethhdr->h_proto)) {\r\ncase ETH_P_IP:\r\nreturn batadv_mcast_forw_mode_check_ipv4(bat_priv, skb,\r\nis_unsnoopable);\r\ncase ETH_P_IPV6:\r\nreturn batadv_mcast_forw_mode_check_ipv6(bat_priv, skb,\r\nis_unsnoopable);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int batadv_mcast_forw_want_all_ip_count(struct batadv_priv *bat_priv,\r\nstruct ethhdr *ethhdr)\r\n{\r\nswitch (ntohs(ethhdr->h_proto)) {\r\ncase ETH_P_IP:\r\nreturn atomic_read(&bat_priv->mcast.num_want_all_ipv4);\r\ncase ETH_P_IPV6:\r\nreturn atomic_read(&bat_priv->mcast.num_want_all_ipv6);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic struct batadv_orig_node *\r\nbatadv_mcast_forw_tt_node_get(struct batadv_priv *bat_priv,\r\nstruct ethhdr *ethhdr)\r\n{\r\nreturn batadv_transtable_search(bat_priv, ethhdr->h_source,\r\nethhdr->h_dest, BATADV_NO_FLAGS);\r\n}\r\nstatic struct batadv_orig_node *\r\nbatadv_mcast_forw_ipv4_node_get(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_orig_node *tmp_orig_node, *orig_node = NULL;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tmp_orig_node,\r\n&bat_priv->mcast.want_all_ipv4_list,\r\nmcast_want_all_ipv4_node) {\r\nif (!atomic_inc_not_zero(&tmp_orig_node->refcount))\r\ncontinue;\r\norig_node = tmp_orig_node;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn orig_node;\r\n}\r\nstatic struct batadv_orig_node *\r\nbatadv_mcast_forw_ipv6_node_get(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_orig_node *tmp_orig_node, *orig_node = NULL;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tmp_orig_node,\r\n&bat_priv->mcast.want_all_ipv6_list,\r\nmcast_want_all_ipv6_node) {\r\nif (!atomic_inc_not_zero(&tmp_orig_node->refcount))\r\ncontinue;\r\norig_node = tmp_orig_node;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn orig_node;\r\n}\r\nstatic struct batadv_orig_node *\r\nbatadv_mcast_forw_ip_node_get(struct batadv_priv *bat_priv,\r\nstruct ethhdr *ethhdr)\r\n{\r\nswitch (ntohs(ethhdr->h_proto)) {\r\ncase ETH_P_IP:\r\nreturn batadv_mcast_forw_ipv4_node_get(bat_priv);\r\ncase ETH_P_IPV6:\r\nreturn batadv_mcast_forw_ipv6_node_get(bat_priv);\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic struct batadv_orig_node *\r\nbatadv_mcast_forw_unsnoop_node_get(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_orig_node *tmp_orig_node, *orig_node = NULL;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tmp_orig_node,\r\n&bat_priv->mcast.want_all_unsnoopables_list,\r\nmcast_want_all_unsnoopables_node) {\r\nif (!atomic_inc_not_zero(&tmp_orig_node->refcount))\r\ncontinue;\r\norig_node = tmp_orig_node;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn orig_node;\r\n}\r\nenum batadv_forw_mode\r\nbatadv_mcast_forw_mode(struct batadv_priv *bat_priv, struct sk_buff *skb,\r\nstruct batadv_orig_node **orig)\r\n{\r\nint ret, tt_count, ip_count, unsnoop_count, total_count;\r\nbool is_unsnoopable = false;\r\nstruct ethhdr *ethhdr;\r\nret = batadv_mcast_forw_mode_check(bat_priv, skb, &is_unsnoopable);\r\nif (ret == -ENOMEM)\r\nreturn BATADV_FORW_NONE;\r\nelse if (ret < 0)\r\nreturn BATADV_FORW_ALL;\r\nethhdr = eth_hdr(skb);\r\ntt_count = batadv_tt_global_hash_count(bat_priv, ethhdr->h_dest,\r\nBATADV_NO_FLAGS);\r\nip_count = batadv_mcast_forw_want_all_ip_count(bat_priv, ethhdr);\r\nunsnoop_count = !is_unsnoopable ? 0 :\r\natomic_read(&bat_priv->mcast.num_want_all_unsnoopables);\r\ntotal_count = tt_count + ip_count + unsnoop_count;\r\nswitch (total_count) {\r\ncase 1:\r\nif (tt_count)\r\n*orig = batadv_mcast_forw_tt_node_get(bat_priv, ethhdr);\r\nelse if (ip_count)\r\n*orig = batadv_mcast_forw_ip_node_get(bat_priv, ethhdr);\r\nelse if (unsnoop_count)\r\n*orig = batadv_mcast_forw_unsnoop_node_get(bat_priv);\r\nif (*orig)\r\nreturn BATADV_FORW_SINGLE;\r\ncase 0:\r\nreturn BATADV_FORW_NONE;\r\ndefault:\r\nreturn BATADV_FORW_ALL;\r\n}\r\n}\r\nstatic void batadv_mcast_want_unsnoop_update(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig,\r\nuint8_t mcast_flags)\r\n{\r\nif (mcast_flags & BATADV_MCAST_WANT_ALL_UNSNOOPABLES &&\r\n!(orig->mcast_flags & BATADV_MCAST_WANT_ALL_UNSNOOPABLES)) {\r\natomic_inc(&bat_priv->mcast.num_want_all_unsnoopables);\r\nspin_lock_bh(&bat_priv->mcast.want_lists_lock);\r\nhlist_add_head_rcu(&orig->mcast_want_all_unsnoopables_node,\r\n&bat_priv->mcast.want_all_unsnoopables_list);\r\nspin_unlock_bh(&bat_priv->mcast.want_lists_lock);\r\n} else if (!(mcast_flags & BATADV_MCAST_WANT_ALL_UNSNOOPABLES) &&\r\norig->mcast_flags & BATADV_MCAST_WANT_ALL_UNSNOOPABLES) {\r\natomic_dec(&bat_priv->mcast.num_want_all_unsnoopables);\r\nspin_lock_bh(&bat_priv->mcast.want_lists_lock);\r\nhlist_del_rcu(&orig->mcast_want_all_unsnoopables_node);\r\nspin_unlock_bh(&bat_priv->mcast.want_lists_lock);\r\n}\r\n}\r\nstatic void batadv_mcast_want_ipv4_update(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig,\r\nuint8_t mcast_flags)\r\n{\r\nif (mcast_flags & BATADV_MCAST_WANT_ALL_IPV4 &&\r\n!(orig->mcast_flags & BATADV_MCAST_WANT_ALL_IPV4)) {\r\natomic_inc(&bat_priv->mcast.num_want_all_ipv4);\r\nspin_lock_bh(&bat_priv->mcast.want_lists_lock);\r\nhlist_add_head_rcu(&orig->mcast_want_all_ipv4_node,\r\n&bat_priv->mcast.want_all_ipv4_list);\r\nspin_unlock_bh(&bat_priv->mcast.want_lists_lock);\r\n} else if (!(mcast_flags & BATADV_MCAST_WANT_ALL_IPV4) &&\r\norig->mcast_flags & BATADV_MCAST_WANT_ALL_IPV4) {\r\natomic_dec(&bat_priv->mcast.num_want_all_ipv4);\r\nspin_lock_bh(&bat_priv->mcast.want_lists_lock);\r\nhlist_del_rcu(&orig->mcast_want_all_ipv4_node);\r\nspin_unlock_bh(&bat_priv->mcast.want_lists_lock);\r\n}\r\n}\r\nstatic void batadv_mcast_want_ipv6_update(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig,\r\nuint8_t mcast_flags)\r\n{\r\nif (mcast_flags & BATADV_MCAST_WANT_ALL_IPV6 &&\r\n!(orig->mcast_flags & BATADV_MCAST_WANT_ALL_IPV6)) {\r\natomic_inc(&bat_priv->mcast.num_want_all_ipv6);\r\nspin_lock_bh(&bat_priv->mcast.want_lists_lock);\r\nhlist_add_head_rcu(&orig->mcast_want_all_ipv6_node,\r\n&bat_priv->mcast.want_all_ipv6_list);\r\nspin_unlock_bh(&bat_priv->mcast.want_lists_lock);\r\n} else if (!(mcast_flags & BATADV_MCAST_WANT_ALL_IPV6) &&\r\norig->mcast_flags & BATADV_MCAST_WANT_ALL_IPV6) {\r\natomic_dec(&bat_priv->mcast.num_want_all_ipv6);\r\nspin_lock_bh(&bat_priv->mcast.want_lists_lock);\r\nhlist_del_rcu(&orig->mcast_want_all_ipv6_node);\r\nspin_unlock_bh(&bat_priv->mcast.want_lists_lock);\r\n}\r\n}\r\nstatic void batadv_mcast_tvlv_ogm_handler_v1(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig,\r\nuint8_t flags,\r\nvoid *tvlv_value,\r\nuint16_t tvlv_value_len)\r\n{\r\nbool orig_mcast_enabled = !(flags & BATADV_TVLV_HANDLER_OGM_CIFNOTFND);\r\nuint8_t mcast_flags = BATADV_NO_FLAGS;\r\nbool orig_initialized;\r\norig_initialized = orig->capa_initialized & BATADV_ORIG_CAPA_HAS_MCAST;\r\nif (orig_mcast_enabled &&\r\n!(orig->capabilities & BATADV_ORIG_CAPA_HAS_MCAST)) {\r\nif (orig_initialized)\r\natomic_dec(&bat_priv->mcast.num_disabled);\r\norig->capabilities |= BATADV_ORIG_CAPA_HAS_MCAST;\r\n} else if (!orig_mcast_enabled &&\r\n(orig->capabilities & BATADV_ORIG_CAPA_HAS_MCAST ||\r\n!orig_initialized)) {\r\natomic_inc(&bat_priv->mcast.num_disabled);\r\norig->capabilities &= ~BATADV_ORIG_CAPA_HAS_MCAST;\r\n}\r\norig->capa_initialized |= BATADV_ORIG_CAPA_HAS_MCAST;\r\nif (orig_mcast_enabled && tvlv_value &&\r\n(tvlv_value_len >= sizeof(mcast_flags)))\r\nmcast_flags = *(uint8_t *)tvlv_value;\r\nbatadv_mcast_want_unsnoop_update(bat_priv, orig, mcast_flags);\r\nbatadv_mcast_want_ipv4_update(bat_priv, orig, mcast_flags);\r\nbatadv_mcast_want_ipv6_update(bat_priv, orig, mcast_flags);\r\norig->mcast_flags = mcast_flags;\r\n}\r\nvoid batadv_mcast_init(struct batadv_priv *bat_priv)\r\n{\r\nbatadv_tvlv_handler_register(bat_priv, batadv_mcast_tvlv_ogm_handler_v1,\r\nNULL, BATADV_TVLV_MCAST, 1,\r\nBATADV_TVLV_HANDLER_OGM_CIFNOTFND);\r\n}\r\nvoid batadv_mcast_free(struct batadv_priv *bat_priv)\r\n{\r\nbatadv_tvlv_container_unregister(bat_priv, BATADV_TVLV_MCAST, 1);\r\nbatadv_tvlv_handler_unregister(bat_priv, BATADV_TVLV_MCAST, 1);\r\nbatadv_mcast_mla_tt_retract(bat_priv, NULL);\r\n}\r\nvoid batadv_mcast_purge_orig(struct batadv_orig_node *orig)\r\n{\r\nstruct batadv_priv *bat_priv = orig->bat_priv;\r\nif (!(orig->capabilities & BATADV_ORIG_CAPA_HAS_MCAST) &&\r\norig->capa_initialized & BATADV_ORIG_CAPA_HAS_MCAST)\r\natomic_dec(&bat_priv->mcast.num_disabled);\r\nbatadv_mcast_want_unsnoop_update(bat_priv, orig, BATADV_NO_FLAGS);\r\nbatadv_mcast_want_ipv4_update(bat_priv, orig, BATADV_NO_FLAGS);\r\nbatadv_mcast_want_ipv6_update(bat_priv, orig, BATADV_NO_FLAGS);\r\n}
