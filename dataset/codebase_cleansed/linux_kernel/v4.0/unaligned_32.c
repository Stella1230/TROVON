static inline enum direction decode_direction(unsigned int insn)\r\n{\r\nunsigned long tmp = (insn >> 21) & 1;\r\nif(!tmp)\r\nreturn load;\r\nelse {\r\nif(((insn>>19)&0x3f) == 15)\r\nreturn both;\r\nelse\r\nreturn store;\r\n}\r\n}\r\nstatic inline int decode_access_size(unsigned int insn)\r\n{\r\ninsn = (insn >> 19) & 3;\r\nif(!insn)\r\nreturn 4;\r\nelse if(insn == 3)\r\nreturn 8;\r\nelse if(insn == 2)\r\nreturn 2;\r\nelse {\r\nprintk("Impossible unaligned trap. insn=%08x\n", insn);\r\ndie_if_kernel("Byte sized unaligned access?!?!", current->thread.kregs);\r\nreturn 4;\r\n}\r\n}\r\nstatic inline int decode_signedness(unsigned int insn)\r\n{\r\nreturn (insn & 0x400000);\r\n}\r\nstatic inline void maybe_flush_windows(unsigned int rs1, unsigned int rs2,\r\nunsigned int rd)\r\n{\r\nif(rs2 >= 16 || rs1 >= 16 || rd >= 16) {\r\n__asm__ __volatile__("save %sp, -0x40, %sp\n\t"\r\n"save %sp, -0x40, %sp\n\t"\r\n"save %sp, -0x40, %sp\n\t"\r\n"save %sp, -0x40, %sp\n\t"\r\n"save %sp, -0x40, %sp\n\t"\r\n"save %sp, -0x40, %sp\n\t"\r\n"save %sp, -0x40, %sp\n\t"\r\n"restore; restore; restore; restore;\n\t"\r\n"restore; restore; restore;\n\t");\r\n}\r\n}\r\nstatic inline int sign_extend_imm13(int imm)\r\n{\r\nreturn imm << 19 >> 19;\r\n}\r\nstatic inline unsigned long fetch_reg(unsigned int reg, struct pt_regs *regs)\r\n{\r\nstruct reg_window32 *win;\r\nif(reg < 16)\r\nreturn (!reg ? 0 : regs->u_regs[reg]);\r\nwin = (struct reg_window32 *) regs->u_regs[UREG_FP];\r\nreturn win->locals[reg - 16];\r\n}\r\nstatic inline unsigned long safe_fetch_reg(unsigned int reg, struct pt_regs *regs)\r\n{\r\nstruct reg_window32 __user *win;\r\nunsigned long ret;\r\nif (reg < 16)\r\nreturn (!reg ? 0 : regs->u_regs[reg]);\r\nwin = (struct reg_window32 __user *) regs->u_regs[UREG_FP];\r\nif ((unsigned long)win & 3)\r\nreturn -1;\r\nif (get_user(ret, &win->locals[reg - 16]))\r\nreturn -1;\r\nreturn ret;\r\n}\r\nstatic inline unsigned long *fetch_reg_addr(unsigned int reg, struct pt_regs *regs)\r\n{\r\nstruct reg_window32 *win;\r\nif(reg < 16)\r\nreturn &regs->u_regs[reg];\r\nwin = (struct reg_window32 *) regs->u_regs[UREG_FP];\r\nreturn &win->locals[reg - 16];\r\n}\r\nstatic unsigned long compute_effective_address(struct pt_regs *regs,\r\nunsigned int insn)\r\n{\r\nunsigned int rs1 = (insn >> 14) & 0x1f;\r\nunsigned int rs2 = insn & 0x1f;\r\nunsigned int rd = (insn >> 25) & 0x1f;\r\nif(insn & 0x2000) {\r\nmaybe_flush_windows(rs1, 0, rd);\r\nreturn (fetch_reg(rs1, regs) + sign_extend_imm13(insn));\r\n} else {\r\nmaybe_flush_windows(rs1, rs2, rd);\r\nreturn (fetch_reg(rs1, regs) + fetch_reg(rs2, regs));\r\n}\r\n}\r\nunsigned long safe_compute_effective_address(struct pt_regs *regs,\r\nunsigned int insn)\r\n{\r\nunsigned int rs1 = (insn >> 14) & 0x1f;\r\nunsigned int rs2 = insn & 0x1f;\r\nunsigned int rd = (insn >> 25) & 0x1f;\r\nif(insn & 0x2000) {\r\nmaybe_flush_windows(rs1, 0, rd);\r\nreturn (safe_fetch_reg(rs1, regs) + sign_extend_imm13(insn));\r\n} else {\r\nmaybe_flush_windows(rs1, rs2, rd);\r\nreturn (safe_fetch_reg(rs1, regs) + safe_fetch_reg(rs2, regs));\r\n}\r\n}\r\nstatic void unaligned_panic(char *str)\r\n{\r\npanic("%s", str);\r\n}\r\nstatic int do_int_store(int reg_num, int size, unsigned long *dst_addr,\r\nstruct pt_regs *regs)\r\n{\r\nunsigned long zero[2] = { 0, 0 };\r\nunsigned long *src_val;\r\nif (reg_num)\r\nsrc_val = fetch_reg_addr(reg_num, regs);\r\nelse {\r\nsrc_val = &zero[0];\r\nif (size == 8)\r\nzero[1] = fetch_reg(1, regs);\r\n}\r\nreturn __do_int_store(dst_addr, size, src_val);\r\n}\r\nstatic inline void advance(struct pt_regs *regs)\r\n{\r\nregs->pc = regs->npc;\r\nregs->npc += 4;\r\n}\r\nstatic inline int floating_point_load_or_store_p(unsigned int insn)\r\n{\r\nreturn (insn >> 24) & 1;\r\n}\r\nstatic inline int ok_for_kernel(unsigned int insn)\r\n{\r\nreturn !floating_point_load_or_store_p(insn);\r\n}\r\nstatic void kernel_mna_trap_fault(struct pt_regs *regs, unsigned int insn)\r\n{\r\nunsigned long g2 = regs->u_regs [UREG_G2];\r\nunsigned long fixup = search_extables_range(regs->pc, &g2);\r\nif (!fixup) {\r\nunsigned long address = compute_effective_address(regs, insn);\r\nif(address < PAGE_SIZE) {\r\nprintk(KERN_ALERT "Unable to handle kernel NULL pointer dereference in mna handler");\r\n} else\r\nprintk(KERN_ALERT "Unable to handle kernel paging request in mna handler");\r\nprintk(KERN_ALERT " at virtual address %08lx\n",address);\r\nprintk(KERN_ALERT "current->{mm,active_mm}->context = %08lx\n",\r\n(current->mm ? current->mm->context :\r\ncurrent->active_mm->context));\r\nprintk(KERN_ALERT "current->{mm,active_mm}->pgd = %08lx\n",\r\n(current->mm ? (unsigned long) current->mm->pgd :\r\n(unsigned long) current->active_mm->pgd));\r\ndie_if_kernel("Oops", regs);\r\n}\r\nregs->pc = fixup;\r\nregs->npc = regs->pc + 4;\r\nregs->u_regs [UREG_G2] = g2;\r\n}\r\nasmlinkage void kernel_unaligned_trap(struct pt_regs *regs, unsigned int insn)\r\n{\r\nenum direction dir = decode_direction(insn);\r\nint size = decode_access_size(insn);\r\nif(!ok_for_kernel(insn) || dir == both) {\r\nprintk("Unsupported unaligned load/store trap for kernel at <%08lx>.\n",\r\nregs->pc);\r\nunaligned_panic("Wheee. Kernel does fpu/atomic unaligned load/store.");\r\n} else {\r\nunsigned long addr = compute_effective_address(regs, insn);\r\nint err;\r\nperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);\r\nswitch (dir) {\r\ncase load:\r\nerr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\r\nregs),\r\nsize, (unsigned long *) addr,\r\ndecode_signedness(insn));\r\nbreak;\r\ncase store:\r\nerr = do_int_store(((insn>>25)&0x1f), size,\r\n(unsigned long *) addr, regs);\r\nbreak;\r\ndefault:\r\npanic("Impossible kernel unaligned trap.");\r\n}\r\nif (err)\r\nkernel_mna_trap_fault(regs, insn);\r\nelse\r\nadvance(regs);\r\n}\r\n}\r\nstatic inline int ok_for_user(struct pt_regs *regs, unsigned int insn,\r\nenum direction dir)\r\n{\r\nunsigned int reg;\r\nint check = (dir == load) ? VERIFY_READ : VERIFY_WRITE;\r\nint size = ((insn >> 19) & 3) == 3 ? 8 : 4;\r\nif ((regs->pc | regs->npc) & 3)\r\nreturn 0;\r\n#define WINREG_ADDR(regnum) \\r\n((void __user *)(((unsigned long *)regs->u_regs[UREG_FP])+(regnum)))\r\nreg = (insn >> 25) & 0x1f;\r\nif (reg >= 16) {\r\nif (!access_ok(check, WINREG_ADDR(reg - 16), size))\r\nreturn -EFAULT;\r\n}\r\nreg = (insn >> 14) & 0x1f;\r\nif (reg >= 16) {\r\nif (!access_ok(check, WINREG_ADDR(reg - 16), size))\r\nreturn -EFAULT;\r\n}\r\nif (!(insn & 0x2000)) {\r\nreg = (insn & 0x1f);\r\nif (reg >= 16) {\r\nif (!access_ok(check, WINREG_ADDR(reg - 16), size))\r\nreturn -EFAULT;\r\n}\r\n}\r\n#undef WINREG_ADDR\r\nreturn 0;\r\n}\r\nstatic void user_mna_trap_fault(struct pt_regs *regs, unsigned int insn)\r\n{\r\nsiginfo_t info;\r\ninfo.si_signo = SIGBUS;\r\ninfo.si_errno = 0;\r\ninfo.si_code = BUS_ADRALN;\r\ninfo.si_addr = (void __user *)safe_compute_effective_address(regs, insn);\r\ninfo.si_trapno = 0;\r\nsend_sig_info(SIGBUS, &info, current);\r\n}\r\nasmlinkage void user_unaligned_trap(struct pt_regs *regs, unsigned int insn)\r\n{\r\nenum direction dir;\r\nif(!(current->thread.flags & SPARC_FLAG_UNALIGNED) ||\r\n(((insn >> 30) & 3) != 3))\r\ngoto kill_user;\r\ndir = decode_direction(insn);\r\nif(!ok_for_user(regs, insn, dir)) {\r\ngoto kill_user;\r\n} else {\r\nint err, size = decode_access_size(insn);\r\nunsigned long addr;\r\nif(floating_point_load_or_store_p(insn)) {\r\nprintk("User FPU load/store unaligned unsupported.\n");\r\ngoto kill_user;\r\n}\r\naddr = compute_effective_address(regs, insn);\r\nperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);\r\nswitch(dir) {\r\ncase load:\r\nerr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\r\nregs),\r\nsize, (unsigned long *) addr,\r\ndecode_signedness(insn));\r\nbreak;\r\ncase store:\r\nerr = do_int_store(((insn>>25)&0x1f), size,\r\n(unsigned long *) addr, regs);\r\nbreak;\r\ncase both:\r\nprintk("Unaligned SWAP unsupported.\n");\r\nerr = -EFAULT;\r\nbreak;\r\ndefault:\r\nunaligned_panic("Impossible user unaligned trap.");\r\ngoto out;\r\n}\r\nif (err)\r\ngoto kill_user;\r\nelse\r\nadvance(regs);\r\ngoto out;\r\n}\r\nkill_user:\r\nuser_mna_trap_fault(regs, insn);\r\nout:\r\n;\r\n}
