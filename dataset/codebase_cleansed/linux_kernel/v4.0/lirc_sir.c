static inline unsigned int sinp(int offset)\r\n{\r\nreturn inb(io + offset);\r\n}\r\nstatic inline void soutp(int offset, int value)\r\n{\r\noutb(value, io + offset);\r\n}\r\nstatic void safe_udelay(unsigned long usecs)\r\n{\r\nwhile (usecs > MAX_UDELAY_US) {\r\nudelay(MAX_UDELAY_US);\r\nusecs -= MAX_UDELAY_US;\r\n}\r\nudelay(usecs);\r\n}\r\nstatic unsigned int lirc_poll(struct file *file, poll_table *wait)\r\n{\r\npoll_wait(file, &lirc_read_queue, wait);\r\nif (rx_head != rx_tail)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic ssize_t lirc_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nint n = 0;\r\nint retval = 0;\r\nDECLARE_WAITQUEUE(wait, current);\r\nif (count % sizeof(int))\r\nreturn -EINVAL;\r\nadd_wait_queue(&lirc_read_queue, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (n < count) {\r\nif (rx_head != rx_tail) {\r\nif (copy_to_user(buf + n,\r\nrx_buf + rx_head,\r\nsizeof(int))) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\nrx_head = (rx_head + 1) & (RBUF_LEN - 1);\r\nn += sizeof(int);\r\n} else {\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nschedule();\r\nset_current_state(TASK_INTERRUPTIBLE);\r\n}\r\n}\r\nremove_wait_queue(&lirc_read_queue, &wait);\r\nset_current_state(TASK_RUNNING);\r\nreturn n ? n : retval;\r\n}\r\nstatic ssize_t lirc_write(struct file *file, const char __user *buf, size_t n,\r\nloff_t *pos)\r\n{\r\nunsigned long flags;\r\nint i, count;\r\nint *tx_buf;\r\ncount = n / sizeof(int);\r\nif (n % sizeof(int) || count % 2 == 0)\r\nreturn -EINVAL;\r\ntx_buf = memdup_user(buf, n);\r\nif (IS_ERR(tx_buf))\r\nreturn PTR_ERR(tx_buf);\r\ni = 0;\r\nlocal_irq_save(flags);\r\nwhile (1) {\r\nif (i >= count)\r\nbreak;\r\nif (tx_buf[i])\r\nsend_pulse(tx_buf[i]);\r\ni++;\r\nif (i >= count)\r\nbreak;\r\nif (tx_buf[i])\r\nsend_space(tx_buf[i]);\r\ni++;\r\n}\r\nlocal_irq_restore(flags);\r\nkfree(tx_buf);\r\nreturn count;\r\n}\r\nstatic long lirc_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)\r\n{\r\nu32 __user *uptr = (u32 __user *)arg;\r\nint retval = 0;\r\nu32 value = 0;\r\nif (cmd == LIRC_GET_FEATURES)\r\nvalue = LIRC_CAN_SEND_PULSE | LIRC_CAN_REC_MODE2;\r\nelse if (cmd == LIRC_GET_SEND_MODE)\r\nvalue = LIRC_MODE_PULSE;\r\nelse if (cmd == LIRC_GET_REC_MODE)\r\nvalue = LIRC_MODE_MODE2;\r\nswitch (cmd) {\r\ncase LIRC_GET_FEATURES:\r\ncase LIRC_GET_SEND_MODE:\r\ncase LIRC_GET_REC_MODE:\r\nretval = put_user(value, uptr);\r\nbreak;\r\ncase LIRC_SET_SEND_MODE:\r\ncase LIRC_SET_REC_MODE:\r\nretval = get_user(value, uptr);\r\nbreak;\r\ndefault:\r\nretval = -ENOIOCTLCMD;\r\n}\r\nif (retval)\r\nreturn retval;\r\nif (cmd == LIRC_SET_REC_MODE) {\r\nif (value != LIRC_MODE_MODE2)\r\nretval = -ENOSYS;\r\n} else if (cmd == LIRC_SET_SEND_MODE) {\r\nif (value != LIRC_MODE_PULSE)\r\nretval = -ENOSYS;\r\n}\r\nreturn retval;\r\n}\r\nstatic void add_read_queue(int flag, unsigned long val)\r\n{\r\nunsigned int new_rx_tail;\r\nint newval;\r\npr_debug("add flag %d with val %lu\n", flag, val);\r\nnewval = val & PULSE_MASK;\r\nif (flag) {\r\nif (newval > TIME_CONST/2)\r\nnewval -= TIME_CONST/2;\r\nelse\r\nnewval = 1;\r\nnewval |= PULSE_BIT;\r\n} else {\r\nnewval += TIME_CONST/2;\r\n}\r\nnew_rx_tail = (rx_tail + 1) & (RBUF_LEN - 1);\r\nif (new_rx_tail == rx_head) {\r\npr_debug("Buffer overrun.\n");\r\nreturn;\r\n}\r\nrx_buf[rx_tail] = newval;\r\nrx_tail = new_rx_tail;\r\nwake_up_interruptible(&lirc_read_queue);\r\n}\r\nstatic int set_use_inc(void *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic void set_use_dec(void *data)\r\n{\r\n}\r\nstatic int init_chrdev(void)\r\n{\r\ndriver.dev = &lirc_sir_dev->dev;\r\ndriver.minor = lirc_register_driver(&driver);\r\nif (driver.minor < 0) {\r\npr_err("init_chrdev() failed.\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void drop_chrdev(void)\r\n{\r\nlirc_unregister_driver(driver.minor);\r\n}\r\nstatic long delta(struct timeval *tv1, struct timeval *tv2)\r\n{\r\nunsigned long deltv;\r\ndeltv = tv2->tv_sec - tv1->tv_sec;\r\nif (deltv > 15)\r\ndeltv = 0xFFFFFF;\r\nelse\r\ndeltv = deltv*1000000 +\r\ntv2->tv_usec -\r\ntv1->tv_usec;\r\nreturn deltv;\r\n}\r\nstatic void sir_timeout(unsigned long data)\r\n{\r\nunsigned long flags;\r\nunsigned long pulse_end;\r\nspin_lock_irqsave(&timer_lock, flags);\r\nif (last_value) {\r\noutb(UART_FCR_CLEAR_RCVR, io + UART_FCR);\r\npulse_end = delta(&last_tv, &last_intr_tv);\r\ndev_dbg(driver.dev, "timeout add %d for %lu usec\n",\r\nlast_value, pulse_end);\r\nadd_read_queue(last_value, pulse_end);\r\nlast_value = 0;\r\nlast_tv = last_intr_tv;\r\n}\r\nspin_unlock_irqrestore(&timer_lock, flags);\r\n}\r\nstatic irqreturn_t sir_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned char data;\r\nstruct timeval curr_tv;\r\nstatic unsigned long deltv;\r\nunsigned long deltintrtv;\r\nunsigned long flags;\r\nint iir, lsr;\r\nwhile ((iir = inb(io + UART_IIR) & UART_IIR_ID)) {\r\nswitch (iir&UART_IIR_ID) {\r\ncase UART_IIR_MSI:\r\n(void) inb(io + UART_MSR);\r\nbreak;\r\ncase UART_IIR_RLSI:\r\n(void) inb(io + UART_LSR);\r\nbreak;\r\ncase UART_IIR_THRI:\r\n#if 0\r\nif (lsr & UART_LSR_THRE)\r\noutb(data, io + UART_TX)\r\n#endif\r\nbreak;\r\ncase UART_IIR_RDI:\r\nspin_lock_irqsave(&timer_lock, flags);\r\ndo {\r\ndel_timer(&timerlist);\r\ndata = inb(io + UART_RX);\r\ndo_gettimeofday(&curr_tv);\r\ndeltv = delta(&last_tv, &curr_tv);\r\ndeltintrtv = delta(&last_intr_tv, &curr_tv);\r\ndev_dbg(driver.dev, "t %lu, d %d\n",\r\ndeltintrtv, (int)data);\r\nif (deltintrtv > TIME_CONST * threshold) {\r\nif (last_value) {\r\ndev_dbg(driver.dev, "GAP\n");\r\nadd_read_queue(last_value,\r\ndeltv -\r\ndeltintrtv);\r\nlast_value = 0;\r\nlast_tv.tv_sec =\r\nlast_intr_tv.tv_sec;\r\nlast_tv.tv_usec =\r\nlast_intr_tv.tv_usec;\r\ndeltv = deltintrtv;\r\n}\r\n}\r\ndata = 1;\r\nif (data ^ last_value) {\r\nadd_read_queue(last_value,\r\ndeltv-TIME_CONST);\r\nlast_value = data;\r\nlast_tv = curr_tv;\r\nif (last_tv.tv_usec >= TIME_CONST) {\r\nlast_tv.tv_usec -= TIME_CONST;\r\n} else {\r\nlast_tv.tv_sec--;\r\nlast_tv.tv_usec += 1000000 -\r\nTIME_CONST;\r\n}\r\n}\r\nlast_intr_tv = curr_tv;\r\nif (data) {\r\ntimerlist.expires = jiffies +\r\nSIR_TIMEOUT;\r\nadd_timer(&timerlist);\r\n}\r\nlsr = inb(io + UART_LSR);\r\n} while (lsr & UART_LSR_DR);\r\nspin_unlock_irqrestore(&timer_lock, flags);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn IRQ_RETVAL(IRQ_HANDLED);\r\n}\r\nstatic void send_space(unsigned long len)\r\n{\r\nsafe_udelay(len);\r\n}\r\nstatic void send_pulse(unsigned long len)\r\n{\r\nlong bytes_out = len / TIME_CONST;\r\nif (bytes_out == 0)\r\nbytes_out++;\r\nwhile (bytes_out--) {\r\noutb(PULSE, io + UART_TX);\r\nwhile (!(inb(io + UART_LSR) & UART_LSR_THRE))\r\n;\r\n}\r\n}\r\nstatic int init_hardware(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&hardware_lock, flags);\r\n#if defined(LIRC_SIR_TEKRAM)\r\nsoutp(UART_FCR,\r\nUART_FCR_CLEAR_RCVR|\r\nUART_FCR_CLEAR_XMIT|\r\nUART_FCR_TRIGGER_1);\r\nsoutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));\r\nsoutp(UART_IER, sinp(UART_IER) &\r\n(~(UART_IER_MSI|UART_IER_RLSI|UART_IER_THRI|UART_IER_RDI)));\r\nsoutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);\r\nsoutp(UART_DLM, 0);\r\nsoutp(UART_DLL, 12);\r\nsoutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);\r\nsafe_udelay(50*1000);\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_OUT2);\r\nudelay(1*1000);\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);\r\nudelay(100);\r\nsoutp(UART_MCR, UART_MCR_DTR|UART_MCR_OUT2);\r\nudelay(7);\r\nsoutp(UART_TX, TEKRAM_115200|TEKRAM_PW);\r\nudelay(1500);\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);\r\nudelay(50);\r\nudelay(1500);\r\npr_info("0x%02x\n", sinp(UART_RX));\r\nsoutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);\r\nsoutp(UART_DLM, 0);\r\nsoutp(UART_DLL, 1);\r\nsoutp(UART_LCR, UART_LCR_WLEN8);\r\nsoutp(UART_IER, sinp(UART_IER)|UART_IER_RDI);\r\n#else\r\noutb(0, io + UART_MCR);\r\noutb(0, io + UART_IER);\r\noutb(UART_LCR_DLAB | UART_LCR_WLEN7, io + UART_LCR);\r\noutb(1, io + UART_DLL); outb(0, io + UART_DLM);\r\noutb(UART_LCR_WLEN7, io + UART_LCR);\r\noutb(UART_FCR_ENABLE_FIFO, io + UART_FCR);\r\noutb(UART_IER_RDI, io + UART_IER);\r\noutb(UART_MCR_DTR|UART_MCR_RTS|UART_MCR_OUT2, io + UART_MCR);\r\n#ifdef LIRC_SIR_ACTISYS_ACT200L\r\ninit_act200();\r\n#elif defined(LIRC_SIR_ACTISYS_ACT220L)\r\ninit_act220();\r\n#endif\r\n#endif\r\nspin_unlock_irqrestore(&hardware_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void drop_hardware(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&hardware_lock, flags);\r\noutb(0, io + UART_IER);\r\nspin_unlock_irqrestore(&hardware_lock, flags);\r\n}\r\nstatic int init_port(void)\r\n{\r\nint retval;\r\nif (request_region(io, 8, LIRC_DRIVER_NAME) == NULL) {\r\npr_err("i/o port 0x%.4x already in use.\n", io);\r\nreturn -EBUSY;\r\n}\r\nretval = request_irq(irq, sir_interrupt, 0,\r\nLIRC_DRIVER_NAME, NULL);\r\nif (retval < 0) {\r\nrelease_region(io, 8);\r\npr_err("IRQ %d already in use.\n", irq);\r\nreturn retval;\r\n}\r\npr_info("I/O port 0x%.4x, IRQ %d.\n", io, irq);\r\ninit_timer(&timerlist);\r\ntimerlist.function = sir_timeout;\r\ntimerlist.data = 0xabadcafe;\r\nreturn 0;\r\n}\r\nstatic void drop_port(void)\r\n{\r\nfree_irq(irq, NULL);\r\ndel_timer_sync(&timerlist);\r\nrelease_region(io, 8);\r\n}\r\nstatic void init_act200(void)\r\n{\r\nint i;\r\n__u8 control[] = {\r\nACT200L_REG15,\r\nACT200L_REG13 | ACT200L_SHDW,\r\nACT200L_REG21 | ACT200L_EXCK | ACT200L_OSCL,\r\nACT200L_REG13,\r\nACT200L_REG7 | ACT200L_ENPOS,\r\nACT200L_REG6 | ACT200L_RS0 | ACT200L_RS1,\r\nACT200L_REG5 | ACT200L_RWIDL,\r\nACT200L_REG4 | ACT200L_OP0 | ACT200L_OP1 | ACT200L_BLKR,\r\nACT200L_REG3 | ACT200L_B0,\r\nACT200L_REG0 | ACT200L_TXEN | ACT200L_RXEN,\r\nACT200L_REG8 | (ACT200L_115200 & 0x0f),\r\nACT200L_REG9 | ((ACT200L_115200 >> 4) & 0x0f),\r\nACT200L_REG1 | ACT200L_LODB | ACT200L_WIDE\r\n};\r\nsoutp(UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN8);\r\nsoutp(UART_DLM, 0);\r\nsoutp(UART_DLL, 12);\r\nsoutp(UART_LCR, UART_LCR_WLEN8);\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);\r\nfor (i = 0; i < 50; i++)\r\nsafe_udelay(1000);\r\nsoutp(UART_MCR, UART_MCR_DTR|UART_MCR_OUT2);\r\nfor (i = 0; i < 25; i++)\r\nudelay(1000);\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);\r\nudelay(100);\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_OUT2);\r\nudelay(7);\r\nfor (i = 0; i < sizeof(control); i++) {\r\nsoutp(UART_TX, control[i]);\r\nudelay(1500);\r\n}\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);\r\nudelay(50);\r\nudelay(1500);\r\nsoutp(UART_LCR, sinp(UART_LCR) | UART_LCR_DLAB);\r\nsoutp(UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN7);\r\nsoutp(UART_DLM, 0);\r\nsoutp(UART_DLL, 1);\r\nsoutp(UART_LCR, sinp(UART_LCR) & (~UART_LCR_DLAB));\r\nsoutp(UART_LCR, UART_LCR_WLEN7);\r\nsoutp(UART_IER, sinp(UART_IER)|UART_IER_RDI);\r\n}\r\nvoid init_act220(void)\r\n{\r\nint i;\r\nsoutp(UART_LCR, UART_LCR_DLAB|UART_LCR_WLEN7);\r\nsoutp(UART_DLM, 0);\r\nsoutp(UART_DLL, 12);\r\nsoutp(UART_LCR, UART_LCR_WLEN7);\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_OUT2);\r\nudelay(10);\r\nsoutp(UART_MCR, UART_MCR_DTR|UART_MCR_RTS|UART_MCR_OUT2);\r\nfor (i = 0; i < 3; i++) {\r\nudelay(10);\r\nsoutp(UART_MCR, UART_MCR_DTR|UART_MCR_OUT2);\r\nudelay(10);\r\nsoutp(UART_MCR, UART_MCR_RTS|UART_MCR_DTR|UART_MCR_OUT2);\r\n}\r\nudelay(1500);\r\nsoutp(UART_LCR, UART_LCR_DLAB | UART_LCR_WLEN7);\r\nsoutp(UART_DLM, 0);\r\nsoutp(UART_DLL, 1);\r\nsoutp(UART_LCR, UART_LCR_WLEN7);\r\nsoutp(UART_IER, UART_IER_RDI);\r\n}\r\nstatic int init_lirc_sir(void)\r\n{\r\nint retval;\r\ninit_waitqueue_head(&lirc_read_queue);\r\nretval = init_port();\r\nif (retval < 0)\r\nreturn retval;\r\ninit_hardware();\r\npr_info("Installed.\n");\r\nreturn 0;\r\n}\r\nstatic int lirc_sir_probe(struct platform_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int lirc_sir_remove(struct platform_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init lirc_sir_init(void)\r\n{\r\nint retval;\r\nretval = platform_driver_register(&lirc_sir_driver);\r\nif (retval) {\r\npr_err("Platform driver register failed!\n");\r\nreturn -ENODEV;\r\n}\r\nlirc_sir_dev = platform_device_alloc("lirc_dev", 0);\r\nif (!lirc_sir_dev) {\r\npr_err("Platform device alloc failed!\n");\r\nretval = -ENOMEM;\r\ngoto pdev_alloc_fail;\r\n}\r\nretval = platform_device_add(lirc_sir_dev);\r\nif (retval) {\r\npr_err("Platform device add failed!\n");\r\nretval = -ENODEV;\r\ngoto pdev_add_fail;\r\n}\r\nretval = init_chrdev();\r\nif (retval < 0)\r\ngoto fail;\r\nretval = init_lirc_sir();\r\nif (retval) {\r\ndrop_chrdev();\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nplatform_device_del(lirc_sir_dev);\r\npdev_add_fail:\r\nplatform_device_put(lirc_sir_dev);\r\npdev_alloc_fail:\r\nplatform_driver_unregister(&lirc_sir_driver);\r\nreturn retval;\r\n}\r\nstatic void __exit lirc_sir_exit(void)\r\n{\r\ndrop_hardware();\r\ndrop_chrdev();\r\ndrop_port();\r\nplatform_device_unregister(lirc_sir_dev);\r\nplatform_driver_unregister(&lirc_sir_driver);\r\npr_info("Uninstalled.\n");\r\n}
