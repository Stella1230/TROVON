void add_cmdname(struct cmdnames *cmds, const char *name, size_t len)\r\n{\r\nstruct cmdname *ent = malloc(sizeof(*ent) + len + 1);\r\nent->len = len;\r\nmemcpy(ent->name, name, len);\r\nent->name[len] = 0;\r\nALLOC_GROW(cmds->names, cmds->cnt + 1, cmds->alloc);\r\ncmds->names[cmds->cnt++] = ent;\r\n}\r\nstatic void clean_cmdnames(struct cmdnames *cmds)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < cmds->cnt; ++i)\r\nzfree(&cmds->names[i]);\r\nzfree(&cmds->names);\r\ncmds->cnt = 0;\r\ncmds->alloc = 0;\r\n}\r\nstatic int cmdname_compare(const void *a_, const void *b_)\r\n{\r\nstruct cmdname *a = *(struct cmdname **)a_;\r\nstruct cmdname *b = *(struct cmdname **)b_;\r\nreturn strcmp(a->name, b->name);\r\n}\r\nstatic void uniq(struct cmdnames *cmds)\r\n{\r\nunsigned int i, j;\r\nif (!cmds->cnt)\r\nreturn;\r\nfor (i = j = 1; i < cmds->cnt; i++)\r\nif (strcmp(cmds->names[i]->name, cmds->names[i-1]->name))\r\ncmds->names[j++] = cmds->names[i];\r\ncmds->cnt = j;\r\n}\r\nvoid exclude_cmds(struct cmdnames *cmds, struct cmdnames *excludes)\r\n{\r\nsize_t ci, cj, ei;\r\nint cmp;\r\nci = cj = ei = 0;\r\nwhile (ci < cmds->cnt && ei < excludes->cnt) {\r\ncmp = strcmp(cmds->names[ci]->name, excludes->names[ei]->name);\r\nif (cmp < 0)\r\ncmds->names[cj++] = cmds->names[ci++];\r\nelse if (cmp == 0)\r\nci++, ei++;\r\nelse if (cmp > 0)\r\nei++;\r\n}\r\nwhile (ci < cmds->cnt)\r\ncmds->names[cj++] = cmds->names[ci++];\r\ncmds->cnt = cj;\r\n}\r\nstatic void pretty_print_string_list(struct cmdnames *cmds, int longest)\r\n{\r\nint cols = 1, rows;\r\nint space = longest + 1;\r\nstruct winsize win;\r\nint max_cols;\r\nint i, j;\r\nget_term_dimensions(&win);\r\nmax_cols = win.ws_col - 1;\r\nif (space < max_cols)\r\ncols = max_cols / space;\r\nrows = (cmds->cnt + cols - 1) / cols;\r\nfor (i = 0; i < rows; i++) {\r\nprintf(" ");\r\nfor (j = 0; j < cols; j++) {\r\nunsigned int n = j * rows + i;\r\nunsigned int size = space;\r\nif (n >= cmds->cnt)\r\nbreak;\r\nif (j == cols-1 || n + rows >= cmds->cnt)\r\nsize = 1;\r\nprintf("%-*s", size, cmds->names[n]->name);\r\n}\r\nputchar('\n');\r\n}\r\n}\r\nstatic int is_executable(const char *name)\r\n{\r\nstruct stat st;\r\nif (stat(name, &st) ||\r\n!S_ISREG(st.st_mode))\r\nreturn 0;\r\nreturn st.st_mode & S_IXUSR;\r\n}\r\nstatic void list_commands_in_dir(struct cmdnames *cmds,\r\nconst char *path,\r\nconst char *prefix)\r\n{\r\nint prefix_len;\r\nDIR *dir = opendir(path);\r\nstruct dirent *de;\r\nstruct strbuf buf = STRBUF_INIT;\r\nint len;\r\nif (!dir)\r\nreturn;\r\nif (!prefix)\r\nprefix = "perf-";\r\nprefix_len = strlen(prefix);\r\nstrbuf_addf(&buf, "%s/", path);\r\nlen = buf.len;\r\nwhile ((de = readdir(dir)) != NULL) {\r\nint entlen;\r\nif (prefixcmp(de->d_name, prefix))\r\ncontinue;\r\nstrbuf_setlen(&buf, len);\r\nstrbuf_addstr(&buf, de->d_name);\r\nif (!is_executable(buf.buf))\r\ncontinue;\r\nentlen = strlen(de->d_name) - prefix_len;\r\nif (has_extension(de->d_name, ".exe"))\r\nentlen -= 4;\r\nadd_cmdname(cmds, de->d_name + prefix_len, entlen);\r\n}\r\nclosedir(dir);\r\nstrbuf_release(&buf);\r\n}\r\nvoid load_command_list(const char *prefix,\r\nstruct cmdnames *main_cmds,\r\nstruct cmdnames *other_cmds)\r\n{\r\nconst char *env_path = getenv("PATH");\r\nconst char *exec_path = perf_exec_path();\r\nif (exec_path) {\r\nlist_commands_in_dir(main_cmds, exec_path, prefix);\r\nqsort(main_cmds->names, main_cmds->cnt,\r\nsizeof(*main_cmds->names), cmdname_compare);\r\nuniq(main_cmds);\r\n}\r\nif (env_path) {\r\nchar *paths, *path, *colon;\r\npath = paths = strdup(env_path);\r\nwhile (1) {\r\nif ((colon = strchr(path, PATH_SEP)))\r\n*colon = 0;\r\nif (!exec_path || strcmp(path, exec_path))\r\nlist_commands_in_dir(other_cmds, path, prefix);\r\nif (!colon)\r\nbreak;\r\npath = colon + 1;\r\n}\r\nfree(paths);\r\nqsort(other_cmds->names, other_cmds->cnt,\r\nsizeof(*other_cmds->names), cmdname_compare);\r\nuniq(other_cmds);\r\n}\r\nexclude_cmds(other_cmds, main_cmds);\r\n}\r\nvoid list_commands(const char *title, struct cmdnames *main_cmds,\r\nstruct cmdnames *other_cmds)\r\n{\r\nunsigned int i, longest = 0;\r\nfor (i = 0; i < main_cmds->cnt; i++)\r\nif (longest < main_cmds->names[i]->len)\r\nlongest = main_cmds->names[i]->len;\r\nfor (i = 0; i < other_cmds->cnt; i++)\r\nif (longest < other_cmds->names[i]->len)\r\nlongest = other_cmds->names[i]->len;\r\nif (main_cmds->cnt) {\r\nconst char *exec_path = perf_exec_path();\r\nprintf("available %s in '%s'\n", title, exec_path);\r\nprintf("----------------");\r\nmput_char('-', strlen(title) + strlen(exec_path));\r\nputchar('\n');\r\npretty_print_string_list(main_cmds, longest);\r\nputchar('\n');\r\n}\r\nif (other_cmds->cnt) {\r\nprintf("%s available from elsewhere on your $PATH\n", title);\r\nprintf("---------------------------------------");\r\nmput_char('-', strlen(title));\r\nputchar('\n');\r\npretty_print_string_list(other_cmds, longest);\r\nputchar('\n');\r\n}\r\n}\r\nint is_in_cmdlist(struct cmdnames *c, const char *s)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < c->cnt; i++)\r\nif (!strcmp(s, c->names[i]->name))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int perf_unknown_cmd_config(const char *var, const char *value, void *cb)\r\n{\r\nif (!strcmp(var, "help.autocorrect"))\r\nautocorrect = perf_config_int(var,value);\r\nif (!prefixcmp(var, "alias."))\r\nadd_cmdname(&aliases, var + 6, strlen(var + 6));\r\nreturn perf_default_config(var, value, cb);\r\n}\r\nstatic int levenshtein_compare(const void *p1, const void *p2)\r\n{\r\nconst struct cmdname *const *c1 = p1, *const *c2 = p2;\r\nconst char *s1 = (*c1)->name, *s2 = (*c2)->name;\r\nint l1 = (*c1)->len;\r\nint l2 = (*c2)->len;\r\nreturn l1 != l2 ? l1 - l2 : strcmp(s1, s2);\r\n}\r\nstatic void add_cmd_list(struct cmdnames *cmds, struct cmdnames *old)\r\n{\r\nunsigned int i;\r\nALLOC_GROW(cmds->names, cmds->cnt + old->cnt, cmds->alloc);\r\nfor (i = 0; i < old->cnt; i++)\r\ncmds->names[cmds->cnt++] = old->names[i];\r\nzfree(&old->names);\r\nold->cnt = 0;\r\n}\r\nconst char *help_unknown_cmd(const char *cmd)\r\n{\r\nunsigned int i, n = 0, best_similarity = 0;\r\nstruct cmdnames main_cmds, other_cmds;\r\nmemset(&main_cmds, 0, sizeof(main_cmds));\r\nmemset(&other_cmds, 0, sizeof(main_cmds));\r\nmemset(&aliases, 0, sizeof(aliases));\r\nperf_config(perf_unknown_cmd_config, NULL);\r\nload_command_list("perf-", &main_cmds, &other_cmds);\r\nadd_cmd_list(&main_cmds, &aliases);\r\nadd_cmd_list(&main_cmds, &other_cmds);\r\nqsort(main_cmds.names, main_cmds.cnt,\r\nsizeof(main_cmds.names), cmdname_compare);\r\nuniq(&main_cmds);\r\nif (main_cmds.cnt) {\r\nfor (i = 0; i < main_cmds.cnt; ++i)\r\nmain_cmds.names[i]->len =\r\nlevenshtein(cmd, main_cmds.names[i]->name, 0, 2, 1, 4);\r\nqsort(main_cmds.names, main_cmds.cnt,\r\nsizeof(*main_cmds.names), levenshtein_compare);\r\nbest_similarity = main_cmds.names[0]->len;\r\nn = 1;\r\nwhile (n < main_cmds.cnt && best_similarity == main_cmds.names[n]->len)\r\n++n;\r\n}\r\nif (autocorrect && n == 1) {\r\nconst char *assumed = main_cmds.names[0]->name;\r\nmain_cmds.names[0] = NULL;\r\nclean_cmdnames(&main_cmds);\r\nfprintf(stderr, "WARNING: You called a perf program named '%s', "\r\n"which does not exist.\n"\r\n"Continuing under the assumption that you meant '%s'\n",\r\ncmd, assumed);\r\nif (autocorrect > 0) {\r\nfprintf(stderr, "in %0.1f seconds automatically...\n",\r\n(float)autocorrect/10.0);\r\npoll(NULL, 0, autocorrect * 100);\r\n}\r\nreturn assumed;\r\n}\r\nfprintf(stderr, "perf: '%s' is not a perf-command. See 'perf --help'.\n", cmd);\r\nif (main_cmds.cnt && best_similarity < 6) {\r\nfprintf(stderr, "\nDid you mean %s?\n",\r\nn < 2 ? "this": "one of these");\r\nfor (i = 0; i < n; i++)\r\nfprintf(stderr, "\t%s\n", main_cmds.names[i]->name);\r\n}\r\nexit(1);\r\n}\r\nint cmd_version(int argc __maybe_unused, const char **argv __maybe_unused,\r\nconst char *prefix __maybe_unused)\r\n{\r\nprintf("perf version %s\n", perf_version_string);\r\nreturn 0;\r\n}
