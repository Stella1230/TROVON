static inline struct hp_sw_dh_data *get_hp_sw_data(struct scsi_device *sdev)\r\n{\r\nreturn container_of(sdev->scsi_dh_data, struct hp_sw_dh_data, dh_data);\r\n}\r\nstatic int tur_done(struct scsi_device *sdev, unsigned char *sense)\r\n{\r\nstruct scsi_sense_hdr sshdr;\r\nint ret;\r\nret = scsi_normalize_sense(sense, SCSI_SENSE_BUFFERSIZE, &sshdr);\r\nif (!ret) {\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: sending tur failed, no sense available\n",\r\nHP_SW_NAME);\r\nret = SCSI_DH_IO;\r\ngoto done;\r\n}\r\nswitch (sshdr.sense_key) {\r\ncase UNIT_ATTENTION:\r\nret = SCSI_DH_IMM_RETRY;\r\nbreak;\r\ncase NOT_READY:\r\nif ((sshdr.asc == 0x04) && (sshdr.ascq == 2)) {\r\nret = SCSI_DH_DEV_OFFLINED;\r\nbreak;\r\n}\r\ndefault:\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: sending tur failed, sense %x/%x/%x\n",\r\nHP_SW_NAME, sshdr.sense_key, sshdr.asc,\r\nsshdr.ascq);\r\nbreak;\r\n}\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int hp_sw_tur(struct scsi_device *sdev, struct hp_sw_dh_data *h)\r\n{\r\nstruct request *req;\r\nint ret;\r\nretry:\r\nreq = blk_get_request(sdev->request_queue, WRITE, GFP_NOIO);\r\nif (IS_ERR(req))\r\nreturn SCSI_DH_RES_TEMP_UNAVAIL;\r\nblk_rq_set_block_pc(req);\r\nreq->cmd_flags |= REQ_FAILFAST_DEV | REQ_FAILFAST_TRANSPORT |\r\nREQ_FAILFAST_DRIVER;\r\nreq->cmd_len = COMMAND_SIZE(TEST_UNIT_READY);\r\nreq->cmd[0] = TEST_UNIT_READY;\r\nreq->timeout = HP_SW_TIMEOUT;\r\nreq->sense = h->sense;\r\nmemset(req->sense, 0, SCSI_SENSE_BUFFERSIZE);\r\nreq->sense_len = 0;\r\nret = blk_execute_rq(req->q, NULL, req, 1);\r\nif (ret == -EIO) {\r\nif (req->sense_len > 0) {\r\nret = tur_done(sdev, h->sense);\r\n} else {\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: sending tur failed with %x\n",\r\nHP_SW_NAME, req->errors);\r\nret = SCSI_DH_IO;\r\n}\r\n} else {\r\nh->path_state = HP_SW_PATH_ACTIVE;\r\nret = SCSI_DH_OK;\r\n}\r\nif (ret == SCSI_DH_IMM_RETRY) {\r\nblk_put_request(req);\r\ngoto retry;\r\n}\r\nif (ret == SCSI_DH_DEV_OFFLINED) {\r\nh->path_state = HP_SW_PATH_PASSIVE;\r\nret = SCSI_DH_OK;\r\n}\r\nblk_put_request(req);\r\nreturn ret;\r\n}\r\nstatic int start_done(struct scsi_device *sdev, unsigned char *sense)\r\n{\r\nstruct scsi_sense_hdr sshdr;\r\nint rc;\r\nrc = scsi_normalize_sense(sense, SCSI_SENSE_BUFFERSIZE, &sshdr);\r\nif (!rc) {\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: sending start_stop_unit failed, "\r\n"no sense available\n",\r\nHP_SW_NAME);\r\nreturn SCSI_DH_IO;\r\n}\r\nswitch (sshdr.sense_key) {\r\ncase NOT_READY:\r\nif ((sshdr.asc == 0x04) && (sshdr.ascq == 3)) {\r\nrc = SCSI_DH_RETRY;\r\nbreak;\r\n}\r\ndefault:\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: sending start_stop_unit failed, sense %x/%x/%x\n",\r\nHP_SW_NAME, sshdr.sense_key, sshdr.asc,\r\nsshdr.ascq);\r\nrc = SCSI_DH_IO;\r\n}\r\nreturn rc;\r\n}\r\nstatic void start_stop_endio(struct request *req, int error)\r\n{\r\nstruct hp_sw_dh_data *h = req->end_io_data;\r\nunsigned err = SCSI_DH_OK;\r\nif (error || host_byte(req->errors) != DID_OK ||\r\nmsg_byte(req->errors) != COMMAND_COMPLETE) {\r\nsdev_printk(KERN_WARNING, h->sdev,\r\n"%s: sending start_stop_unit failed with %x\n",\r\nHP_SW_NAME, req->errors);\r\nerr = SCSI_DH_IO;\r\ngoto done;\r\n}\r\nif (req->sense_len > 0) {\r\nerr = start_done(h->sdev, h->sense);\r\nif (err == SCSI_DH_RETRY) {\r\nerr = SCSI_DH_IO;\r\nif (--h->retry_cnt) {\r\nblk_put_request(req);\r\nerr = hp_sw_start_stop(h);\r\nif (err == SCSI_DH_OK)\r\nreturn;\r\n}\r\n}\r\n}\r\ndone:\r\nreq->end_io_data = NULL;\r\n__blk_put_request(req->q, req);\r\nif (h->callback_fn) {\r\nh->callback_fn(h->callback_data, err);\r\nh->callback_fn = h->callback_data = NULL;\r\n}\r\nreturn;\r\n}\r\nstatic int hp_sw_start_stop(struct hp_sw_dh_data *h)\r\n{\r\nstruct request *req;\r\nreq = blk_get_request(h->sdev->request_queue, WRITE, GFP_ATOMIC);\r\nif (IS_ERR(req))\r\nreturn SCSI_DH_RES_TEMP_UNAVAIL;\r\nblk_rq_set_block_pc(req);\r\nreq->cmd_flags |= REQ_FAILFAST_DEV | REQ_FAILFAST_TRANSPORT |\r\nREQ_FAILFAST_DRIVER;\r\nreq->cmd_len = COMMAND_SIZE(START_STOP);\r\nreq->cmd[0] = START_STOP;\r\nreq->cmd[4] = 1;\r\nreq->timeout = HP_SW_TIMEOUT;\r\nreq->sense = h->sense;\r\nmemset(req->sense, 0, SCSI_SENSE_BUFFERSIZE);\r\nreq->sense_len = 0;\r\nreq->end_io_data = h;\r\nblk_execute_rq_nowait(req->q, NULL, req, 1, start_stop_endio);\r\nreturn SCSI_DH_OK;\r\n}\r\nstatic int hp_sw_prep_fn(struct scsi_device *sdev, struct request *req)\r\n{\r\nstruct hp_sw_dh_data *h = get_hp_sw_data(sdev);\r\nint ret = BLKPREP_OK;\r\nif (h->path_state != HP_SW_PATH_ACTIVE) {\r\nret = BLKPREP_KILL;\r\nreq->cmd_flags |= REQ_QUIET;\r\n}\r\nreturn ret;\r\n}\r\nstatic int hp_sw_activate(struct scsi_device *sdev,\r\nactivate_complete fn, void *data)\r\n{\r\nint ret = SCSI_DH_OK;\r\nstruct hp_sw_dh_data *h = get_hp_sw_data(sdev);\r\nret = hp_sw_tur(sdev, h);\r\nif (ret == SCSI_DH_OK && h->path_state == HP_SW_PATH_PASSIVE) {\r\nh->retry_cnt = h->retries;\r\nh->callback_fn = fn;\r\nh->callback_data = data;\r\nret = hp_sw_start_stop(h);\r\nif (ret == SCSI_DH_OK)\r\nreturn 0;\r\nh->callback_fn = h->callback_data = NULL;\r\n}\r\nif (fn)\r\nfn(data, ret);\r\nreturn 0;\r\n}\r\nstatic bool hp_sw_match(struct scsi_device *sdev)\r\n{\r\nint i;\r\nif (scsi_device_tpgs(sdev))\r\nreturn false;\r\nfor (i = 0; hp_sw_dh_data_list[i].vendor; i++) {\r\nif (!strncmp(sdev->vendor, hp_sw_dh_data_list[i].vendor,\r\nstrlen(hp_sw_dh_data_list[i].vendor)) &&\r\n!strncmp(sdev->model, hp_sw_dh_data_list[i].model,\r\nstrlen(hp_sw_dh_data_list[i].model))) {\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic struct scsi_dh_data *hp_sw_bus_attach(struct scsi_device *sdev)\r\n{\r\nstruct hp_sw_dh_data *h;\r\nint ret;\r\nh = kzalloc(sizeof(*h), GFP_KERNEL);\r\nif (!h)\r\nreturn ERR_PTR(-ENOMEM);\r\nh->path_state = HP_SW_PATH_UNINITIALIZED;\r\nh->retries = HP_SW_RETRIES;\r\nh->sdev = sdev;\r\nret = hp_sw_tur(sdev, h);\r\nif (ret != SCSI_DH_OK || h->path_state == HP_SW_PATH_UNINITIALIZED)\r\ngoto failed;\r\nsdev_printk(KERN_INFO, sdev, "%s: attached to %s path\n",\r\nHP_SW_NAME, h->path_state == HP_SW_PATH_ACTIVE?\r\n"active":"passive");\r\nreturn &h->dh_data;\r\nfailed:\r\nkfree(h);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic void hp_sw_bus_detach( struct scsi_device *sdev )\r\n{\r\nstruct hp_sw_dh_data *h = get_hp_sw_data(sdev);\r\nkfree(h);\r\n}\r\nstatic int __init hp_sw_init(void)\r\n{\r\nreturn scsi_register_device_handler(&hp_sw_dh);\r\n}\r\nstatic void __exit hp_sw_exit(void)\r\n{\r\nscsi_unregister_device_handler(&hp_sw_dh);\r\n}
