ssize_t pm_show_wakelocks(char *buf, bool show_active)\r\n{\r\nstruct rb_node *node;\r\nstruct wakelock *wl;\r\nchar *str = buf;\r\nchar *end = buf + PAGE_SIZE;\r\nmutex_lock(&wakelocks_lock);\r\nfor (node = rb_first(&wakelocks_tree); node; node = rb_next(node)) {\r\nwl = rb_entry(node, struct wakelock, node);\r\nif (wl->ws.active == show_active)\r\nstr += scnprintf(str, end - str, "%s ", wl->name);\r\n}\r\nif (str > buf)\r\nstr--;\r\nstr += scnprintf(str, end - str, "\n");\r\nmutex_unlock(&wakelocks_lock);\r\nreturn (str - buf);\r\n}\r\nstatic inline bool wakelocks_limit_exceeded(void)\r\n{\r\nreturn number_of_wakelocks > CONFIG_PM_WAKELOCKS_LIMIT;\r\n}\r\nstatic inline void increment_wakelocks_number(void)\r\n{\r\nnumber_of_wakelocks++;\r\n}\r\nstatic inline void decrement_wakelocks_number(void)\r\n{\r\nnumber_of_wakelocks--;\r\n}\r\nstatic inline bool wakelocks_limit_exceeded(void) { return false; }\r\nstatic inline void increment_wakelocks_number(void) {}\r\nstatic inline void decrement_wakelocks_number(void) {}\r\nstatic inline void wakelocks_lru_add(struct wakelock *wl)\r\n{\r\nlist_add(&wl->lru, &wakelocks_lru_list);\r\n}\r\nstatic inline void wakelocks_lru_most_recent(struct wakelock *wl)\r\n{\r\nlist_move(&wl->lru, &wakelocks_lru_list);\r\n}\r\nstatic void wakelocks_gc(void)\r\n{\r\nstruct wakelock *wl, *aux;\r\nktime_t now;\r\nif (++wakelocks_gc_count <= WL_GC_COUNT_MAX)\r\nreturn;\r\nnow = ktime_get();\r\nlist_for_each_entry_safe_reverse(wl, aux, &wakelocks_lru_list, lru) {\r\nu64 idle_time_ns;\r\nbool active;\r\nspin_lock_irq(&wl->ws.lock);\r\nidle_time_ns = ktime_to_ns(ktime_sub(now, wl->ws.last_time));\r\nactive = wl->ws.active;\r\nspin_unlock_irq(&wl->ws.lock);\r\nif (idle_time_ns < ((u64)WL_GC_TIME_SEC * NSEC_PER_SEC))\r\nbreak;\r\nif (!active) {\r\nwakeup_source_remove(&wl->ws);\r\nrb_erase(&wl->node, &wakelocks_tree);\r\nlist_del(&wl->lru);\r\nkfree(wl->name);\r\nkfree(wl);\r\ndecrement_wakelocks_number();\r\n}\r\n}\r\nwakelocks_gc_count = 0;\r\n}\r\nstatic inline void wakelocks_lru_add(struct wakelock *wl) {}\r\nstatic inline void wakelocks_lru_most_recent(struct wakelock *wl) {}\r\nstatic inline void wakelocks_gc(void) {}\r\nstatic struct wakelock *wakelock_lookup_add(const char *name, size_t len,\r\nbool add_if_not_found)\r\n{\r\nstruct rb_node **node = &wakelocks_tree.rb_node;\r\nstruct rb_node *parent = *node;\r\nstruct wakelock *wl;\r\nwhile (*node) {\r\nint diff;\r\nparent = *node;\r\nwl = rb_entry(*node, struct wakelock, node);\r\ndiff = strncmp(name, wl->name, len);\r\nif (diff == 0) {\r\nif (wl->name[len])\r\ndiff = -1;\r\nelse\r\nreturn wl;\r\n}\r\nif (diff < 0)\r\nnode = &(*node)->rb_left;\r\nelse\r\nnode = &(*node)->rb_right;\r\n}\r\nif (!add_if_not_found)\r\nreturn ERR_PTR(-EINVAL);\r\nif (wakelocks_limit_exceeded())\r\nreturn ERR_PTR(-ENOSPC);\r\nwl = kzalloc(sizeof(*wl), GFP_KERNEL);\r\nif (!wl)\r\nreturn ERR_PTR(-ENOMEM);\r\nwl->name = kstrndup(name, len, GFP_KERNEL);\r\nif (!wl->name) {\r\nkfree(wl);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nwl->ws.name = wl->name;\r\nwakeup_source_add(&wl->ws);\r\nrb_link_node(&wl->node, parent, node);\r\nrb_insert_color(&wl->node, &wakelocks_tree);\r\nwakelocks_lru_add(wl);\r\nincrement_wakelocks_number();\r\nreturn wl;\r\n}\r\nint pm_wake_lock(const char *buf)\r\n{\r\nconst char *str = buf;\r\nstruct wakelock *wl;\r\nu64 timeout_ns = 0;\r\nsize_t len;\r\nint ret = 0;\r\nif (!capable(CAP_BLOCK_SUSPEND))\r\nreturn -EPERM;\r\nwhile (*str && !isspace(*str))\r\nstr++;\r\nlen = str - buf;\r\nif (!len)\r\nreturn -EINVAL;\r\nif (*str && *str != '\n') {\r\nret = kstrtou64(skip_spaces(str), 10, &timeout_ns);\r\nif (ret)\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&wakelocks_lock);\r\nwl = wakelock_lookup_add(buf, len, true);\r\nif (IS_ERR(wl)) {\r\nret = PTR_ERR(wl);\r\ngoto out;\r\n}\r\nif (timeout_ns) {\r\nu64 timeout_ms = timeout_ns + NSEC_PER_MSEC - 1;\r\ndo_div(timeout_ms, NSEC_PER_MSEC);\r\n__pm_wakeup_event(&wl->ws, timeout_ms);\r\n} else {\r\n__pm_stay_awake(&wl->ws);\r\n}\r\nwakelocks_lru_most_recent(wl);\r\nout:\r\nmutex_unlock(&wakelocks_lock);\r\nreturn ret;\r\n}\r\nint pm_wake_unlock(const char *buf)\r\n{\r\nstruct wakelock *wl;\r\nsize_t len;\r\nint ret = 0;\r\nif (!capable(CAP_BLOCK_SUSPEND))\r\nreturn -EPERM;\r\nlen = strlen(buf);\r\nif (!len)\r\nreturn -EINVAL;\r\nif (buf[len-1] == '\n')\r\nlen--;\r\nif (!len)\r\nreturn -EINVAL;\r\nmutex_lock(&wakelocks_lock);\r\nwl = wakelock_lookup_add(buf, len, false);\r\nif (IS_ERR(wl)) {\r\nret = PTR_ERR(wl);\r\ngoto out;\r\n}\r\n__pm_relax(&wl->ws);\r\nwakelocks_lru_most_recent(wl);\r\nwakelocks_gc();\r\nout:\r\nmutex_unlock(&wakelocks_lock);\r\nreturn ret;\r\n}
