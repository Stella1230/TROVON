static void\r\n_set_debug(struct inf_hw *card)\r\n{\r\ncard->ipac.isac.dch.debug = debug;\r\ncard->ipac.hscx[0].bch.debug = debug;\r\ncard->ipac.hscx[1].bch.debug = debug;\r\n}\r\nstatic int\r\nset_debug(const char *val, struct kernel_param *kp)\r\n{\r\nint ret;\r\nstruct inf_hw *card;\r\nret = param_set_uint(val, kp);\r\nif (!ret) {\r\nread_lock(&card_lock);\r\nlist_for_each_entry(card, &Cards, list)\r\n_set_debug(card);\r\nread_unlock(&card_lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t\r\ndiva_irq(int intno, void *dev_id)\r\n{\r\nstruct inf_hw *hw = dev_id;\r\nu8 val;\r\nspin_lock(&hw->lock);\r\nval = inb((u32)hw->cfg.start + DIVA_PCI_CTRL);\r\nif (!(val & DIVA_IRQ_BIT)) {\r\nspin_unlock(&hw->lock);\r\nreturn IRQ_NONE;\r\n}\r\nhw->irqcnt++;\r\nmISDNipac_irq(&hw->ipac, irqloops);\r\nspin_unlock(&hw->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\ndiva20x_irq(int intno, void *dev_id)\r\n{\r\nstruct inf_hw *hw = dev_id;\r\nu8 val;\r\nspin_lock(&hw->lock);\r\nval = readb(hw->cfg.p);\r\nif (!(val & PITA_INT0_STATUS)) {\r\nspin_unlock(&hw->lock);\r\nreturn IRQ_NONE;\r\n}\r\nhw->irqcnt++;\r\nmISDNipac_irq(&hw->ipac, irqloops);\r\nwriteb(PITA_INT0_STATUS, hw->cfg.p);\r\nspin_unlock(&hw->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\ntiger_irq(int intno, void *dev_id)\r\n{\r\nstruct inf_hw *hw = dev_id;\r\nu8 val;\r\nspin_lock(&hw->lock);\r\nval = inb((u32)hw->cfg.start + TIGER_AUX_STATUS);\r\nif (val & TIGER_IRQ_BIT) {\r\nspin_unlock(&hw->lock);\r\nreturn IRQ_NONE;\r\n}\r\nhw->irqcnt++;\r\nmISDNipac_irq(&hw->ipac, irqloops);\r\nspin_unlock(&hw->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nelsa_irq(int intno, void *dev_id)\r\n{\r\nstruct inf_hw *hw = dev_id;\r\nu8 val;\r\nspin_lock(&hw->lock);\r\nval = inb((u32)hw->cfg.start + ELSA_IRQ_ADDR);\r\nif (!(val & ELSA_IRQ_MASK)) {\r\nspin_unlock(&hw->lock);\r\nreturn IRQ_NONE;\r\n}\r\nhw->irqcnt++;\r\nmISDNipac_irq(&hw->ipac, irqloops);\r\nspin_unlock(&hw->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nniccy_irq(int intno, void *dev_id)\r\n{\r\nstruct inf_hw *hw = dev_id;\r\nu32 val;\r\nspin_lock(&hw->lock);\r\nval = inl((u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);\r\nif (!(val & NICCY_IRQ_BIT)) {\r\nspin_unlock(&hw->lock);\r\nreturn IRQ_NONE;\r\n}\r\noutl(val, (u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);\r\nhw->irqcnt++;\r\nmISDNipac_irq(&hw->ipac, irqloops);\r\nspin_unlock(&hw->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\ngazel_irq(int intno, void *dev_id)\r\n{\r\nstruct inf_hw *hw = dev_id;\r\nirqreturn_t ret;\r\nspin_lock(&hw->lock);\r\nret = mISDNipac_irq(&hw->ipac, irqloops);\r\nspin_unlock(&hw->lock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t\r\nipac_irq(int intno, void *dev_id)\r\n{\r\nstruct inf_hw *hw = dev_id;\r\nu8 val;\r\nspin_lock(&hw->lock);\r\nval = hw->ipac.read_reg(hw, IPAC_ISTA);\r\nif (!(val & 0x3f)) {\r\nspin_unlock(&hw->lock);\r\nreturn IRQ_NONE;\r\n}\r\nhw->irqcnt++;\r\nmISDNipac_irq(&hw->ipac, irqloops);\r\nspin_unlock(&hw->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nenable_hwirq(struct inf_hw *hw)\r\n{\r\nu16 w;\r\nu32 val;\r\nswitch (hw->ci->typ) {\r\ncase INF_DIVA201:\r\ncase INF_DIVA202:\r\nwritel(PITA_INT0_ENABLE, hw->cfg.p);\r\nbreak;\r\ncase INF_SPEEDWIN:\r\ncase INF_SAPHIR3:\r\noutb(TIGER_IRQ_BIT, (u32)hw->cfg.start + TIGER_AUX_IRQMASK);\r\nbreak;\r\ncase INF_QS1000:\r\noutb(QS1000_IRQ_ON, (u32)hw->cfg.start + ELSA_IRQ_ADDR);\r\nbreak;\r\ncase INF_QS3000:\r\noutb(QS3000_IRQ_ON, (u32)hw->cfg.start + ELSA_IRQ_ADDR);\r\nbreak;\r\ncase INF_NICCY:\r\nval = inl((u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);\r\nval |= NICCY_IRQ_ENABLE;\r\noutl(val, (u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);\r\nbreak;\r\ncase INF_SCT_1:\r\nw = inw((u32)hw->cfg.start + SCT_PLX_IRQ_ADDR);\r\nw |= SCT_PLX_IRQ_ENABLE;\r\noutw(w, (u32)hw->cfg.start + SCT_PLX_IRQ_ADDR);\r\nbreak;\r\ncase INF_GAZEL_R685:\r\noutb(GAZEL_ISAC_EN + GAZEL_HSCX_EN + GAZEL_PCI_EN,\r\n(u32)hw->cfg.start + GAZEL_INCSR);\r\nbreak;\r\ncase INF_GAZEL_R753:\r\noutb(GAZEL_IPAC_EN + GAZEL_PCI_EN,\r\n(u32)hw->cfg.start + GAZEL_INCSR);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndisable_hwirq(struct inf_hw *hw)\r\n{\r\nu16 w;\r\nu32 val;\r\nswitch (hw->ci->typ) {\r\ncase INF_DIVA201:\r\ncase INF_DIVA202:\r\nwritel(0, hw->cfg.p);\r\nbreak;\r\ncase INF_SPEEDWIN:\r\ncase INF_SAPHIR3:\r\noutb(0, (u32)hw->cfg.start + TIGER_AUX_IRQMASK);\r\nbreak;\r\ncase INF_QS1000:\r\noutb(QS1000_IRQ_OFF, (u32)hw->cfg.start + ELSA_IRQ_ADDR);\r\nbreak;\r\ncase INF_QS3000:\r\noutb(QS3000_IRQ_OFF, (u32)hw->cfg.start + ELSA_IRQ_ADDR);\r\nbreak;\r\ncase INF_NICCY:\r\nval = inl((u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);\r\nval &= NICCY_IRQ_DISABLE;\r\noutl(val, (u32)hw->cfg.start + NICCY_IRQ_CTRL_REG);\r\nbreak;\r\ncase INF_SCT_1:\r\nw = inw((u32)hw->cfg.start + SCT_PLX_IRQ_ADDR);\r\nw &= (~SCT_PLX_IRQ_ENABLE);\r\noutw(w, (u32)hw->cfg.start + SCT_PLX_IRQ_ADDR);\r\nbreak;\r\ncase INF_GAZEL_R685:\r\ncase INF_GAZEL_R753:\r\noutb(0, (u32)hw->cfg.start + GAZEL_INCSR);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nipac_chip_reset(struct inf_hw *hw)\r\n{\r\nhw->ipac.write_reg(hw, IPAC_POTA2, 0x20);\r\nmdelay(5);\r\nhw->ipac.write_reg(hw, IPAC_POTA2, 0x00);\r\nmdelay(5);\r\nhw->ipac.write_reg(hw, IPAC_CONF, hw->ipac.conf);\r\nhw->ipac.write_reg(hw, IPAC_MASK, 0xc0);\r\n}\r\nstatic void\r\nreset_inf(struct inf_hw *hw)\r\n{\r\nu16 w;\r\nu32 val;\r\nif (debug & DEBUG_HW)\r\npr_notice("%s: resetting card\n", hw->name);\r\nswitch (hw->ci->typ) {\r\ncase INF_DIVA20:\r\ncase INF_DIVA20U:\r\noutb(0, (u32)hw->cfg.start + DIVA_PCI_CTRL);\r\nmdelay(10);\r\noutb(DIVA_RESET_BIT, (u32)hw->cfg.start + DIVA_PCI_CTRL);\r\nmdelay(10);\r\noutb(9, (u32)hw->cfg.start + 0x69);\r\noutb(DIVA_RESET_BIT | DIVA_LED_A,\r\n(u32)hw->cfg.start + DIVA_PCI_CTRL);\r\nbreak;\r\ncase INF_DIVA201:\r\nwritel(PITA_PARA_SOFTRESET | PITA_PARA_MPX_MODE,\r\nhw->cfg.p + PITA_MISC_REG);\r\nmdelay(1);\r\nwritel(PITA_PARA_MPX_MODE, hw->cfg.p + PITA_MISC_REG);\r\nmdelay(10);\r\nbreak;\r\ncase INF_DIVA202:\r\nwritel(PITA_PARA_SOFTRESET | PITA_PARA_MPX_MODE,\r\nhw->cfg.p + PITA_MISC_REG);\r\nmdelay(1);\r\nwritel(PITA_PARA_MPX_MODE | PITA_SER_SOFTRESET,\r\nhw->cfg.p + PITA_MISC_REG);\r\nmdelay(10);\r\nbreak;\r\ncase INF_SPEEDWIN:\r\ncase INF_SAPHIR3:\r\nipac_chip_reset(hw);\r\nhw->ipac.write_reg(hw, IPAC_ACFG, 0xff);\r\nhw->ipac.write_reg(hw, IPAC_AOE, 0x00);\r\nhw->ipac.write_reg(hw, IPAC_PCFG, 0x12);\r\nbreak;\r\ncase INF_QS1000:\r\ncase INF_QS3000:\r\nipac_chip_reset(hw);\r\nhw->ipac.write_reg(hw, IPAC_ACFG, 0x00);\r\nhw->ipac.write_reg(hw, IPAC_AOE, 0x3c);\r\nhw->ipac.write_reg(hw, IPAC_ATX, 0xff);\r\nbreak;\r\ncase INF_NICCY:\r\nbreak;\r\ncase INF_SCT_1:\r\nw = inw((u32)hw->cfg.start + SCT_PLX_RESET_ADDR);\r\nw &= (~SCT_PLX_RESET_BIT);\r\noutw(w, (u32)hw->cfg.start + SCT_PLX_RESET_ADDR);\r\nmdelay(10);\r\nw = inw((u32)hw->cfg.start + SCT_PLX_RESET_ADDR);\r\nw |= SCT_PLX_RESET_BIT;\r\noutw(w, (u32)hw->cfg.start + SCT_PLX_RESET_ADDR);\r\nmdelay(10);\r\nbreak;\r\ncase INF_GAZEL_R685:\r\nval = inl((u32)hw->cfg.start + GAZEL_CNTRL);\r\nval |= (GAZEL_RESET_9050 + GAZEL_RESET);\r\noutl(val, (u32)hw->cfg.start + GAZEL_CNTRL);\r\nval &= ~(GAZEL_RESET_9050 + GAZEL_RESET);\r\nmdelay(4);\r\noutl(val, (u32)hw->cfg.start + GAZEL_CNTRL);\r\nmdelay(10);\r\nhw->ipac.isac.adf2 = 0x87;\r\nhw->ipac.hscx[0].slot = 0x1f;\r\nhw->ipac.hscx[1].slot = 0x23;\r\nbreak;\r\ncase INF_GAZEL_R753:\r\nval = inl((u32)hw->cfg.start + GAZEL_CNTRL);\r\nval |= (GAZEL_RESET_9050 + GAZEL_RESET);\r\noutl(val, (u32)hw->cfg.start + GAZEL_CNTRL);\r\nval &= ~(GAZEL_RESET_9050 + GAZEL_RESET);\r\nmdelay(4);\r\noutl(val, (u32)hw->cfg.start + GAZEL_CNTRL);\r\nmdelay(10);\r\nipac_chip_reset(hw);\r\nhw->ipac.write_reg(hw, IPAC_ACFG, 0xff);\r\nhw->ipac.write_reg(hw, IPAC_AOE, 0x00);\r\nhw->ipac.conf = 0x01;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nenable_hwirq(hw);\r\n}\r\nstatic int\r\ninf_ctrl(struct inf_hw *hw, u32 cmd, u_long arg)\r\n{\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase HW_RESET_REQ:\r\nreset_inf(hw);\r\nbreak;\r\ndefault:\r\npr_info("%s: %s unknown command %x %lx\n",\r\nhw->name, __func__, cmd, arg);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\ninit_irq(struct inf_hw *hw)\r\n{\r\nint ret, cnt = 3;\r\nu_long flags;\r\nif (!hw->ci->irqfunc)\r\nreturn -EINVAL;\r\nret = request_irq(hw->irq, hw->ci->irqfunc, IRQF_SHARED, hw->name, hw);\r\nif (ret) {\r\npr_info("%s: couldn't get interrupt %d\n", hw->name, hw->irq);\r\nreturn ret;\r\n}\r\nwhile (cnt--) {\r\nspin_lock_irqsave(&hw->lock, flags);\r\nreset_inf(hw);\r\nret = hw->ipac.init(&hw->ipac);\r\nif (ret) {\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\npr_info("%s: ISAC init failed with %d\n",\r\nhw->name, ret);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nmsleep_interruptible(10);\r\nif (debug & DEBUG_HW)\r\npr_notice("%s: IRQ %d count %d\n", hw->name,\r\nhw->irq, hw->irqcnt);\r\nif (!hw->irqcnt) {\r\npr_info("%s: IRQ(%d) got no requests during init %d\n",\r\nhw->name, hw->irq, 3 - cnt);\r\n} else\r\nreturn 0;\r\n}\r\nfree_irq(hw->irq, hw);\r\nreturn -EIO;\r\n}\r\nstatic void\r\nrelease_io(struct inf_hw *hw)\r\n{\r\nif (hw->cfg.mode) {\r\nif (hw->cfg.p) {\r\nrelease_mem_region(hw->cfg.start, hw->cfg.size);\r\niounmap(hw->cfg.p);\r\n} else\r\nrelease_region(hw->cfg.start, hw->cfg.size);\r\nhw->cfg.mode = AM_NONE;\r\n}\r\nif (hw->addr.mode) {\r\nif (hw->addr.p) {\r\nrelease_mem_region(hw->addr.start, hw->addr.size);\r\niounmap(hw->addr.p);\r\n} else\r\nrelease_region(hw->addr.start, hw->addr.size);\r\nhw->addr.mode = AM_NONE;\r\n}\r\n}\r\nstatic int\r\nsetup_io(struct inf_hw *hw)\r\n{\r\nint err = 0;\r\nif (hw->ci->cfg_mode) {\r\nhw->cfg.start = pci_resource_start(hw->pdev, hw->ci->cfg_bar);\r\nhw->cfg.size = pci_resource_len(hw->pdev, hw->ci->cfg_bar);\r\nif (hw->ci->cfg_mode == AM_MEMIO) {\r\nif (!request_mem_region(hw->cfg.start, hw->cfg.size,\r\nhw->name))\r\nerr = -EBUSY;\r\n} else {\r\nif (!request_region(hw->cfg.start, hw->cfg.size,\r\nhw->name))\r\nerr = -EBUSY;\r\n}\r\nif (err) {\r\npr_info("mISDN: %s config port %lx (%lu bytes)"\r\n"already in use\n", hw->name,\r\n(ulong)hw->cfg.start, (ulong)hw->cfg.size);\r\nreturn err;\r\n}\r\nif (hw->ci->cfg_mode == AM_MEMIO)\r\nhw->cfg.p = ioremap(hw->cfg.start, hw->cfg.size);\r\nhw->cfg.mode = hw->ci->cfg_mode;\r\nif (debug & DEBUG_HW)\r\npr_notice("%s: IO cfg %lx (%lu bytes) mode%d\n",\r\nhw->name, (ulong)hw->cfg.start,\r\n(ulong)hw->cfg.size, hw->ci->cfg_mode);\r\n}\r\nif (hw->ci->addr_mode) {\r\nhw->addr.start = pci_resource_start(hw->pdev, hw->ci->addr_bar);\r\nhw->addr.size = pci_resource_len(hw->pdev, hw->ci->addr_bar);\r\nif (hw->ci->addr_mode == AM_MEMIO) {\r\nif (!request_mem_region(hw->addr.start, hw->addr.size,\r\nhw->name))\r\nerr = -EBUSY;\r\n} else {\r\nif (!request_region(hw->addr.start, hw->addr.size,\r\nhw->name))\r\nerr = -EBUSY;\r\n}\r\nif (err) {\r\npr_info("mISDN: %s address port %lx (%lu bytes)"\r\n"already in use\n", hw->name,\r\n(ulong)hw->addr.start, (ulong)hw->addr.size);\r\nreturn err;\r\n}\r\nif (hw->ci->addr_mode == AM_MEMIO)\r\nhw->addr.p = ioremap(hw->addr.start, hw->addr.size);\r\nhw->addr.mode = hw->ci->addr_mode;\r\nif (debug & DEBUG_HW)\r\npr_notice("%s: IO addr %lx (%lu bytes) mode%d\n",\r\nhw->name, (ulong)hw->addr.start,\r\n(ulong)hw->addr.size, hw->ci->addr_mode);\r\n}\r\nswitch (hw->ci->typ) {\r\ncase INF_DIVA20:\r\ncase INF_DIVA20U:\r\nhw->ipac.type = IPAC_TYPE_ISAC | IPAC_TYPE_HSCX;\r\nhw->isac.mode = hw->cfg.mode;\r\nhw->isac.a.io.ale = (u32)hw->cfg.start + DIVA_ISAC_ALE;\r\nhw->isac.a.io.port = (u32)hw->cfg.start + DIVA_ISAC_PORT;\r\nhw->hscx.mode = hw->cfg.mode;\r\nhw->hscx.a.io.ale = (u32)hw->cfg.start + DIVA_HSCX_ALE;\r\nhw->hscx.a.io.port = (u32)hw->cfg.start + DIVA_HSCX_PORT;\r\nbreak;\r\ncase INF_DIVA201:\r\nhw->ipac.type = IPAC_TYPE_IPAC;\r\nhw->ipac.isac.off = 0x80;\r\nhw->isac.mode = hw->addr.mode;\r\nhw->isac.a.p = hw->addr.p;\r\nhw->hscx.mode = hw->addr.mode;\r\nhw->hscx.a.p = hw->addr.p;\r\nbreak;\r\ncase INF_DIVA202:\r\nhw->ipac.type = IPAC_TYPE_IPACX;\r\nhw->isac.mode = hw->addr.mode;\r\nhw->isac.a.p = hw->addr.p;\r\nhw->hscx.mode = hw->addr.mode;\r\nhw->hscx.a.p = hw->addr.p;\r\nbreak;\r\ncase INF_SPEEDWIN:\r\ncase INF_SAPHIR3:\r\nhw->ipac.type = IPAC_TYPE_IPAC;\r\nhw->ipac.isac.off = 0x80;\r\nhw->isac.mode = hw->cfg.mode;\r\nhw->isac.a.io.ale = (u32)hw->cfg.start + TIGER_IPAC_ALE;\r\nhw->isac.a.io.port = (u32)hw->cfg.start + TIGER_IPAC_PORT;\r\nhw->hscx.mode = hw->cfg.mode;\r\nhw->hscx.a.io.ale = (u32)hw->cfg.start + TIGER_IPAC_ALE;\r\nhw->hscx.a.io.port = (u32)hw->cfg.start + TIGER_IPAC_PORT;\r\noutb(0xff, (ulong)hw->cfg.start);\r\nmdelay(1);\r\noutb(0x00, (ulong)hw->cfg.start);\r\nmdelay(1);\r\noutb(TIGER_IOMASK, (ulong)hw->cfg.start + TIGER_AUX_CTRL);\r\nbreak;\r\ncase INF_QS1000:\r\ncase INF_QS3000:\r\nhw->ipac.type = IPAC_TYPE_IPAC;\r\nhw->ipac.isac.off = 0x80;\r\nhw->isac.a.io.ale = (u32)hw->addr.start;\r\nhw->isac.a.io.port = (u32)hw->addr.start + 1;\r\nhw->isac.mode = hw->addr.mode;\r\nhw->hscx.a.io.ale = (u32)hw->addr.start;\r\nhw->hscx.a.io.port = (u32)hw->addr.start + 1;\r\nhw->hscx.mode = hw->addr.mode;\r\nbreak;\r\ncase INF_NICCY:\r\nhw->ipac.type = IPAC_TYPE_ISAC | IPAC_TYPE_HSCX;\r\nhw->isac.mode = hw->addr.mode;\r\nhw->isac.a.io.ale = (u32)hw->addr.start + NICCY_ISAC_ALE;\r\nhw->isac.a.io.port = (u32)hw->addr.start + NICCY_ISAC_PORT;\r\nhw->hscx.mode = hw->addr.mode;\r\nhw->hscx.a.io.ale = (u32)hw->addr.start + NICCY_HSCX_ALE;\r\nhw->hscx.a.io.port = (u32)hw->addr.start + NICCY_HSCX_PORT;\r\nbreak;\r\ncase INF_SCT_1:\r\nhw->ipac.type = IPAC_TYPE_IPAC;\r\nhw->ipac.isac.off = 0x80;\r\nhw->isac.a.io.ale = (u32)hw->addr.start;\r\nhw->isac.a.io.port = hw->isac.a.io.ale + 4;\r\nhw->isac.mode = hw->addr.mode;\r\nhw->hscx.a.io.ale = hw->isac.a.io.ale;\r\nhw->hscx.a.io.port = hw->isac.a.io.port;\r\nhw->hscx.mode = hw->addr.mode;\r\nbreak;\r\ncase INF_SCT_2:\r\nhw->ipac.type = IPAC_TYPE_IPAC;\r\nhw->ipac.isac.off = 0x80;\r\nhw->isac.a.io.ale = (u32)hw->addr.start + 0x08;\r\nhw->isac.a.io.port = hw->isac.a.io.ale + 4;\r\nhw->isac.mode = hw->addr.mode;\r\nhw->hscx.a.io.ale = hw->isac.a.io.ale;\r\nhw->hscx.a.io.port = hw->isac.a.io.port;\r\nhw->hscx.mode = hw->addr.mode;\r\nbreak;\r\ncase INF_SCT_3:\r\nhw->ipac.type = IPAC_TYPE_IPAC;\r\nhw->ipac.isac.off = 0x80;\r\nhw->isac.a.io.ale = (u32)hw->addr.start + 0x10;\r\nhw->isac.a.io.port = hw->isac.a.io.ale + 4;\r\nhw->isac.mode = hw->addr.mode;\r\nhw->hscx.a.io.ale = hw->isac.a.io.ale;\r\nhw->hscx.a.io.port = hw->isac.a.io.port;\r\nhw->hscx.mode = hw->addr.mode;\r\nbreak;\r\ncase INF_SCT_4:\r\nhw->ipac.type = IPAC_TYPE_IPAC;\r\nhw->ipac.isac.off = 0x80;\r\nhw->isac.a.io.ale = (u32)hw->addr.start + 0x20;\r\nhw->isac.a.io.port = hw->isac.a.io.ale + 4;\r\nhw->isac.mode = hw->addr.mode;\r\nhw->hscx.a.io.ale = hw->isac.a.io.ale;\r\nhw->hscx.a.io.port = hw->isac.a.io.port;\r\nhw->hscx.mode = hw->addr.mode;\r\nbreak;\r\ncase INF_GAZEL_R685:\r\nhw->ipac.type = IPAC_TYPE_ISAC | IPAC_TYPE_HSCX;\r\nhw->ipac.isac.off = 0x80;\r\nhw->isac.mode = hw->addr.mode;\r\nhw->isac.a.io.port = (u32)hw->addr.start;\r\nhw->hscx.mode = hw->addr.mode;\r\nhw->hscx.a.io.port = hw->isac.a.io.port;\r\nbreak;\r\ncase INF_GAZEL_R753:\r\nhw->ipac.type = IPAC_TYPE_IPAC;\r\nhw->ipac.isac.off = 0x80;\r\nhw->isac.mode = hw->addr.mode;\r\nhw->isac.a.io.ale = (u32)hw->addr.start;\r\nhw->isac.a.io.port = (u32)hw->addr.start + GAZEL_IPAC_DATA_PORT;\r\nhw->hscx.mode = hw->addr.mode;\r\nhw->hscx.a.io.ale = hw->isac.a.io.ale;\r\nhw->hscx.a.io.port = hw->isac.a.io.port;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (hw->isac.mode) {\r\ncase AM_MEMIO:\r\nASSIGN_FUNC_IPAC(MIO, hw->ipac);\r\nbreak;\r\ncase AM_IND_IO:\r\nASSIGN_FUNC_IPAC(IND, hw->ipac);\r\nbreak;\r\ncase AM_IO:\r\nASSIGN_FUNC_IPAC(IO, hw->ipac);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nrelease_card(struct inf_hw *card) {\r\nulong flags;\r\nint i;\r\nspin_lock_irqsave(&card->lock, flags);\r\ndisable_hwirq(card);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncard->ipac.isac.release(&card->ipac.isac);\r\nfree_irq(card->irq, card);\r\nmISDN_unregister_device(&card->ipac.isac.dch.dev);\r\nrelease_io(card);\r\nwrite_lock_irqsave(&card_lock, flags);\r\nlist_del(&card->list);\r\nwrite_unlock_irqrestore(&card_lock, flags);\r\nswitch (card->ci->typ) {\r\ncase INF_SCT_2:\r\ncase INF_SCT_3:\r\ncase INF_SCT_4:\r\nbreak;\r\ncase INF_SCT_1:\r\nfor (i = 0; i < 3; i++) {\r\nif (card->sc[i])\r\nrelease_card(card->sc[i]);\r\ncard->sc[i] = NULL;\r\n}\r\ndefault:\r\npci_disable_device(card->pdev);\r\npci_set_drvdata(card->pdev, NULL);\r\nbreak;\r\n}\r\nkfree(card);\r\ninf_cnt--;\r\n}\r\nstatic int\r\nsetup_instance(struct inf_hw *card)\r\n{\r\nint err;\r\nulong flags;\r\nsnprintf(card->name, MISDN_MAX_IDLEN - 1, "%s.%d", card->ci->name,\r\ninf_cnt + 1);\r\nwrite_lock_irqsave(&card_lock, flags);\r\nlist_add_tail(&card->list, &Cards);\r\nwrite_unlock_irqrestore(&card_lock, flags);\r\n_set_debug(card);\r\ncard->ipac.isac.name = card->name;\r\ncard->ipac.name = card->name;\r\ncard->ipac.owner = THIS_MODULE;\r\nspin_lock_init(&card->lock);\r\ncard->ipac.isac.hwlock = &card->lock;\r\ncard->ipac.hwlock = &card->lock;\r\ncard->ipac.ctrl = (void *)&inf_ctrl;\r\nerr = setup_io(card);\r\nif (err)\r\ngoto error_setup;\r\ncard->ipac.isac.dch.dev.Bprotocols =\r\nmISDNipac_init(&card->ipac, card);\r\nif (card->ipac.isac.dch.dev.Bprotocols == 0)\r\ngoto error_setup;\r\nerr = mISDN_register_device(&card->ipac.isac.dch.dev,\r\n&card->pdev->dev, card->name);\r\nif (err)\r\ngoto error;\r\nerr = init_irq(card);\r\nif (!err) {\r\ninf_cnt++;\r\npr_notice("Infineon %d cards installed\n", inf_cnt);\r\nreturn 0;\r\n}\r\nmISDN_unregister_device(&card->ipac.isac.dch.dev);\r\nerror:\r\ncard->ipac.release(&card->ipac);\r\nerror_setup:\r\nrelease_io(card);\r\nwrite_lock_irqsave(&card_lock, flags);\r\nlist_del(&card->list);\r\nwrite_unlock_irqrestore(&card_lock, flags);\r\nreturn err;\r\n}\r\nstatic const struct inf_cinfo *\r\nget_card_info(enum inf_types typ)\r\n{\r\nconst struct inf_cinfo *ci = inf_card_info;\r\nwhile (ci->typ != INF_NONE) {\r\nif (ci->typ == typ)\r\nreturn ci;\r\nci++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\ninf_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint err = -ENOMEM;\r\nstruct inf_hw *card;\r\ncard = kzalloc(sizeof(struct inf_hw), GFP_KERNEL);\r\nif (!card) {\r\npr_info("No memory for Infineon ISDN card\n");\r\nreturn err;\r\n}\r\ncard->pdev = pdev;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\nkfree(card);\r\nreturn err;\r\n}\r\ncard->ci = get_card_info(ent->driver_data);\r\nif (!card->ci) {\r\npr_info("mISDN: do not have informations about adapter at %s\n",\r\npci_name(pdev));\r\nkfree(card);\r\npci_disable_device(pdev);\r\nreturn -EINVAL;\r\n} else\r\npr_notice("mISDN: found adapter %s at %s\n",\r\ncard->ci->full, pci_name(pdev));\r\ncard->irq = pdev->irq;\r\npci_set_drvdata(pdev, card);\r\nerr = setup_instance(card);\r\nif (err) {\r\npci_disable_device(pdev);\r\nkfree(card);\r\npci_set_drvdata(pdev, NULL);\r\n} else if (ent->driver_data == INF_SCT_1) {\r\nint i;\r\nstruct inf_hw *sc;\r\nfor (i = 1; i < 4; i++) {\r\nsc = kzalloc(sizeof(struct inf_hw), GFP_KERNEL);\r\nif (!sc) {\r\nrelease_card(card);\r\npci_disable_device(pdev);\r\nreturn -ENOMEM;\r\n}\r\nsc->irq = card->irq;\r\nsc->pdev = card->pdev;\r\nsc->ci = card->ci + i;\r\nerr = setup_instance(sc);\r\nif (err) {\r\npci_disable_device(pdev);\r\nkfree(sc);\r\nrelease_card(card);\r\nbreak;\r\n} else\r\ncard->sc[i - 1] = sc;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic void\r\ninf_remove(struct pci_dev *pdev)\r\n{\r\nstruct inf_hw *card = pci_get_drvdata(pdev);\r\nif (card)\r\nrelease_card(card);\r\nelse\r\npr_debug("%s: drvdata already removed\n", __func__);\r\n}\r\nstatic int __init\r\ninfineon_init(void)\r\n{\r\nint err;\r\npr_notice("Infineon ISDN Driver Rev. %s\n", INFINEON_REV);\r\nerr = pci_register_driver(&infineon_driver);\r\nreturn err;\r\n}\r\nstatic void __exit\r\ninfineon_cleanup(void)\r\n{\r\npci_unregister_driver(&infineon_driver);\r\n}
