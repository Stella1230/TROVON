static bool acpi_property_value_ok(const union acpi_object *value)\r\n{\r\nint j;\r\nswitch (value->type) {\r\ncase ACPI_TYPE_INTEGER:\r\ncase ACPI_TYPE_STRING:\r\ncase ACPI_TYPE_LOCAL_REFERENCE:\r\nreturn true;\r\ncase ACPI_TYPE_PACKAGE:\r\nfor (j = 0; j < value->package.count; j++)\r\nswitch (value->package.elements[j].type) {\r\ncase ACPI_TYPE_INTEGER:\r\ncase ACPI_TYPE_STRING:\r\ncase ACPI_TYPE_LOCAL_REFERENCE:\r\ncontinue;\r\ndefault:\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool acpi_properties_format_valid(const union acpi_object *properties)\r\n{\r\nint i;\r\nfor (i = 0; i < properties->package.count; i++) {\r\nconst union acpi_object *property;\r\nproperty = &properties->package.elements[i];\r\nif (property->package.count != 2\r\n|| property->package.elements[0].type != ACPI_TYPE_STRING\r\n|| !acpi_property_value_ok(&property->package.elements[1]))\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void acpi_init_of_compatible(struct acpi_device *adev)\r\n{\r\nconst union acpi_object *of_compatible;\r\nstruct acpi_hardware_id *hwid;\r\nbool acpi_of = false;\r\nint ret;\r\nlist_for_each_entry(hwid, &adev->pnp.ids, list) {\r\nif (!strcmp(hwid->id, "PRP0001")) {\r\nacpi_of = true;\r\nbreak;\r\n}\r\n}\r\nif (!acpi_of)\r\nreturn;\r\nret = acpi_dev_get_property_array(adev, "compatible", ACPI_TYPE_STRING,\r\n&of_compatible);\r\nif (ret) {\r\nret = acpi_dev_get_property(adev, "compatible",\r\nACPI_TYPE_STRING, &of_compatible);\r\nif (ret) {\r\nacpi_handle_warn(adev->handle,\r\n"PRP0001 requires compatible property\n");\r\nreturn;\r\n}\r\n}\r\nadev->data.of_compatible = of_compatible;\r\n}\r\nvoid acpi_init_properties(struct acpi_device *adev)\r\n{\r\nstruct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };\r\nconst union acpi_object *desc;\r\nacpi_status status;\r\nint i;\r\nstatus = acpi_evaluate_object_typed(adev->handle, "_DSD", NULL, &buf,\r\nACPI_TYPE_PACKAGE);\r\nif (ACPI_FAILURE(status))\r\nreturn;\r\ndesc = buf.pointer;\r\nif (desc->package.count % 2)\r\ngoto fail;\r\nfor (i = 0; i < desc->package.count; i += 2) {\r\nconst union acpi_object *uuid, *properties;\r\nuuid = &desc->package.elements[i];\r\nproperties = &desc->package.elements[i + 1];\r\nif (uuid->type != ACPI_TYPE_BUFFER || uuid->buffer.length != 16\r\n|| properties->type != ACPI_TYPE_PACKAGE)\r\nbreak;\r\nif (memcmp(uuid->buffer.pointer, prp_uuid, sizeof(prp_uuid)))\r\ncontinue;\r\nif (!acpi_properties_format_valid(properties))\r\nbreak;\r\nadev->data.pointer = buf.pointer;\r\nadev->data.properties = properties;\r\nacpi_init_of_compatible(adev);\r\nreturn;\r\n}\r\nfail:\r\ndev_warn(&adev->dev, "Returned _DSD data is not valid, skipping\n");\r\nACPI_FREE(buf.pointer);\r\n}\r\nvoid acpi_free_properties(struct acpi_device *adev)\r\n{\r\nACPI_FREE((void *)adev->data.pointer);\r\nadev->data.of_compatible = NULL;\r\nadev->data.pointer = NULL;\r\nadev->data.properties = NULL;\r\n}\r\nint acpi_dev_get_property(struct acpi_device *adev, const char *name,\r\nacpi_object_type type, const union acpi_object **obj)\r\n{\r\nconst union acpi_object *properties;\r\nint i;\r\nif (!adev || !name)\r\nreturn -EINVAL;\r\nif (!adev->data.pointer || !adev->data.properties)\r\nreturn -ENODATA;\r\nproperties = adev->data.properties;\r\nfor (i = 0; i < properties->package.count; i++) {\r\nconst union acpi_object *propname, *propvalue;\r\nconst union acpi_object *property;\r\nproperty = &properties->package.elements[i];\r\npropname = &property->package.elements[0];\r\npropvalue = &property->package.elements[1];\r\nif (!strcmp(name, propname->string.pointer)) {\r\nif (type != ACPI_TYPE_ANY && propvalue->type != type)\r\nreturn -EPROTO;\r\nelse if (obj)\r\n*obj = propvalue;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENODATA;\r\n}\r\nint acpi_dev_get_property_array(struct acpi_device *adev, const char *name,\r\nacpi_object_type type,\r\nconst union acpi_object **obj)\r\n{\r\nconst union acpi_object *prop;\r\nint ret, i;\r\nret = acpi_dev_get_property(adev, name, ACPI_TYPE_PACKAGE, &prop);\r\nif (ret)\r\nreturn ret;\r\nif (type != ACPI_TYPE_ANY) {\r\nfor (i = 0; i < prop->package.count; i++)\r\nif (prop->package.elements[i].type != type)\r\nreturn -EPROTO;\r\n}\r\nif (obj)\r\n*obj = prop;\r\nreturn 0;\r\n}\r\nint acpi_dev_get_property_reference(struct acpi_device *adev,\r\nconst char *name, size_t index,\r\nstruct acpi_reference_args *args)\r\n{\r\nconst union acpi_object *element, *end;\r\nconst union acpi_object *obj;\r\nstruct acpi_device *device;\r\nint ret, idx = 0;\r\nret = acpi_dev_get_property(adev, name, ACPI_TYPE_ANY, &obj);\r\nif (ret)\r\nreturn ret;\r\nif (obj->type == ACPI_TYPE_LOCAL_REFERENCE) {\r\nif (index)\r\nreturn -EINVAL;\r\nret = acpi_bus_get_device(obj->reference.handle, &device);\r\nif (ret)\r\nreturn ret;\r\nargs->adev = device;\r\nargs->nargs = 0;\r\nreturn 0;\r\n}\r\nif (obj->type != ACPI_TYPE_PACKAGE || index >= obj->package.count)\r\nreturn -EPROTO;\r\nelement = obj->package.elements;\r\nend = element + obj->package.count;\r\nwhile (element < end) {\r\nu32 nargs, i;\r\nif (element->type != ACPI_TYPE_LOCAL_REFERENCE)\r\nreturn -EPROTO;\r\nret = acpi_bus_get_device(element->reference.handle, &device);\r\nif (ret)\r\nreturn -ENODEV;\r\nelement++;\r\nnargs = 0;\r\nfor (i = 0; element + i < end; i++) {\r\nint type = element[i].type;\r\nif (type == ACPI_TYPE_INTEGER)\r\nnargs++;\r\nelse if (type == ACPI_TYPE_LOCAL_REFERENCE)\r\nbreak;\r\nelse\r\nreturn -EPROTO;\r\n}\r\nif (idx++ == index) {\r\nargs->adev = device;\r\nargs->nargs = nargs;\r\nfor (i = 0; i < nargs; i++)\r\nargs->args[i] = element[i].integer.value;\r\nreturn 0;\r\n}\r\nelement += nargs;\r\n}\r\nreturn -EPROTO;\r\n}\r\nint acpi_dev_prop_get(struct acpi_device *adev, const char *propname,\r\nvoid **valptr)\r\n{\r\nreturn acpi_dev_get_property(adev, propname, ACPI_TYPE_ANY,\r\n(const union acpi_object **)valptr);\r\n}\r\nint acpi_dev_prop_read_single(struct acpi_device *adev, const char *propname,\r\nenum dev_prop_type proptype, void *val)\r\n{\r\nconst union acpi_object *obj;\r\nint ret;\r\nif (!val)\r\nreturn -EINVAL;\r\nif (proptype >= DEV_PROP_U8 && proptype <= DEV_PROP_U64) {\r\nret = acpi_dev_get_property(adev, propname, ACPI_TYPE_INTEGER, &obj);\r\nif (ret)\r\nreturn ret;\r\nswitch (proptype) {\r\ncase DEV_PROP_U8:\r\nif (obj->integer.value > U8_MAX)\r\nreturn -EOVERFLOW;\r\n*(u8 *)val = obj->integer.value;\r\nbreak;\r\ncase DEV_PROP_U16:\r\nif (obj->integer.value > U16_MAX)\r\nreturn -EOVERFLOW;\r\n*(u16 *)val = obj->integer.value;\r\nbreak;\r\ncase DEV_PROP_U32:\r\nif (obj->integer.value > U32_MAX)\r\nreturn -EOVERFLOW;\r\n*(u32 *)val = obj->integer.value;\r\nbreak;\r\ndefault:\r\n*(u64 *)val = obj->integer.value;\r\nbreak;\r\n}\r\n} else if (proptype == DEV_PROP_STRING) {\r\nret = acpi_dev_get_property(adev, propname, ACPI_TYPE_STRING, &obj);\r\nif (ret)\r\nreturn ret;\r\n*(char **)val = obj->string.pointer;\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int acpi_copy_property_array_u8(const union acpi_object *items, u8 *val,\r\nsize_t nval)\r\n{\r\nint i;\r\nfor (i = 0; i < nval; i++) {\r\nif (items[i].type != ACPI_TYPE_INTEGER)\r\nreturn -EPROTO;\r\nif (items[i].integer.value > U8_MAX)\r\nreturn -EOVERFLOW;\r\nval[i] = items[i].integer.value;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_copy_property_array_u16(const union acpi_object *items,\r\nu16 *val, size_t nval)\r\n{\r\nint i;\r\nfor (i = 0; i < nval; i++) {\r\nif (items[i].type != ACPI_TYPE_INTEGER)\r\nreturn -EPROTO;\r\nif (items[i].integer.value > U16_MAX)\r\nreturn -EOVERFLOW;\r\nval[i] = items[i].integer.value;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_copy_property_array_u32(const union acpi_object *items,\r\nu32 *val, size_t nval)\r\n{\r\nint i;\r\nfor (i = 0; i < nval; i++) {\r\nif (items[i].type != ACPI_TYPE_INTEGER)\r\nreturn -EPROTO;\r\nif (items[i].integer.value > U32_MAX)\r\nreturn -EOVERFLOW;\r\nval[i] = items[i].integer.value;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_copy_property_array_u64(const union acpi_object *items,\r\nu64 *val, size_t nval)\r\n{\r\nint i;\r\nfor (i = 0; i < nval; i++) {\r\nif (items[i].type != ACPI_TYPE_INTEGER)\r\nreturn -EPROTO;\r\nval[i] = items[i].integer.value;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acpi_copy_property_array_string(const union acpi_object *items,\r\nchar **val, size_t nval)\r\n{\r\nint i;\r\nfor (i = 0; i < nval; i++) {\r\nif (items[i].type != ACPI_TYPE_STRING)\r\nreturn -EPROTO;\r\nval[i] = items[i].string.pointer;\r\n}\r\nreturn 0;\r\n}\r\nint acpi_dev_prop_read(struct acpi_device *adev, const char *propname,\r\nenum dev_prop_type proptype, void *val, size_t nval)\r\n{\r\nconst union acpi_object *obj;\r\nconst union acpi_object *items;\r\nint ret;\r\nif (val && nval == 1) {\r\nret = acpi_dev_prop_read_single(adev, propname, proptype, val);\r\nif (!ret)\r\nreturn ret;\r\n}\r\nret = acpi_dev_get_property_array(adev, propname, ACPI_TYPE_ANY, &obj);\r\nif (ret)\r\nreturn ret;\r\nif (!val)\r\nreturn obj->package.count;\r\nelse if (nval <= 0)\r\nreturn -EINVAL;\r\nif (nval > obj->package.count)\r\nreturn -EOVERFLOW;\r\nitems = obj->package.elements;\r\nswitch (proptype) {\r\ncase DEV_PROP_U8:\r\nret = acpi_copy_property_array_u8(items, (u8 *)val, nval);\r\nbreak;\r\ncase DEV_PROP_U16:\r\nret = acpi_copy_property_array_u16(items, (u16 *)val, nval);\r\nbreak;\r\ncase DEV_PROP_U32:\r\nret = acpi_copy_property_array_u32(items, (u32 *)val, nval);\r\nbreak;\r\ncase DEV_PROP_U64:\r\nret = acpi_copy_property_array_u64(items, (u64 *)val, nval);\r\nbreak;\r\ncase DEV_PROP_STRING:\r\nret = acpi_copy_property_array_string(items, (char **)val, nval);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}
