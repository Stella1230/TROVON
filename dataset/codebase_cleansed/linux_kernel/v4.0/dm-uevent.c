static void dm_uevent_free(struct dm_uevent *event)\r\n{\r\nkmem_cache_free(_dm_event_cache, event);\r\n}\r\nstatic struct dm_uevent *dm_uevent_alloc(struct mapped_device *md)\r\n{\r\nstruct dm_uevent *event;\r\nevent = kmem_cache_zalloc(_dm_event_cache, GFP_ATOMIC);\r\nif (!event)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&event->elist);\r\nevent->md = md;\r\nreturn event;\r\n}\r\nstatic struct dm_uevent *dm_build_path_uevent(struct mapped_device *md,\r\nstruct dm_target *ti,\r\nenum kobject_action action,\r\nconst char *dm_action,\r\nconst char *path,\r\nunsigned nr_valid_paths)\r\n{\r\nstruct dm_uevent *event;\r\nevent = dm_uevent_alloc(md);\r\nif (!event) {\r\nDMERR("%s: dm_uevent_alloc() failed", __func__);\r\ngoto err_nomem;\r\n}\r\nevent->action = action;\r\nif (add_uevent_var(&event->ku_env, "DM_TARGET=%s", ti->type->name)) {\r\nDMERR("%s: add_uevent_var() for DM_TARGET failed",\r\n__func__);\r\ngoto err_add;\r\n}\r\nif (add_uevent_var(&event->ku_env, "DM_ACTION=%s", dm_action)) {\r\nDMERR("%s: add_uevent_var() for DM_ACTION failed",\r\n__func__);\r\ngoto err_add;\r\n}\r\nif (add_uevent_var(&event->ku_env, "DM_SEQNUM=%u",\r\ndm_next_uevent_seq(md))) {\r\nDMERR("%s: add_uevent_var() for DM_SEQNUM failed",\r\n__func__);\r\ngoto err_add;\r\n}\r\nif (add_uevent_var(&event->ku_env, "DM_PATH=%s", path)) {\r\nDMERR("%s: add_uevent_var() for DM_PATH failed", __func__);\r\ngoto err_add;\r\n}\r\nif (add_uevent_var(&event->ku_env, "DM_NR_VALID_PATHS=%d",\r\nnr_valid_paths)) {\r\nDMERR("%s: add_uevent_var() for DM_NR_VALID_PATHS failed",\r\n__func__);\r\ngoto err_add;\r\n}\r\nreturn event;\r\nerr_add:\r\ndm_uevent_free(event);\r\nerr_nomem:\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nvoid dm_send_uevents(struct list_head *events, struct kobject *kobj)\r\n{\r\nint r;\r\nstruct dm_uevent *event, *next;\r\nlist_for_each_entry_safe(event, next, events, elist) {\r\nlist_del_init(&event->elist);\r\nif (dm_copy_name_and_uuid(event->md, event->name,\r\nevent->uuid)) {\r\nDMINFO("%s: skipping sending uevent for lost device",\r\n__func__);\r\ngoto uevent_free;\r\n}\r\nif (add_uevent_var(&event->ku_env, "DM_NAME=%s", event->name)) {\r\nDMERR("%s: add_uevent_var() for DM_NAME failed",\r\n__func__);\r\ngoto uevent_free;\r\n}\r\nif (add_uevent_var(&event->ku_env, "DM_UUID=%s", event->uuid)) {\r\nDMERR("%s: add_uevent_var() for DM_UUID failed",\r\n__func__);\r\ngoto uevent_free;\r\n}\r\nr = kobject_uevent_env(kobj, event->action, event->ku_env.envp);\r\nif (r)\r\nDMERR("%s: kobject_uevent_env failed", __func__);\r\nuevent_free:\r\ndm_uevent_free(event);\r\n}\r\n}\r\nvoid dm_path_uevent(enum dm_uevent_type event_type, struct dm_target *ti,\r\nconst char *path, unsigned nr_valid_paths)\r\n{\r\nstruct mapped_device *md = dm_table_get_md(ti->table);\r\nstruct dm_uevent *event;\r\nif (event_type >= ARRAY_SIZE(_dm_uevent_type_names)) {\r\nDMERR("%s: Invalid event_type %d", __func__, event_type);\r\nreturn;\r\n}\r\nevent = dm_build_path_uevent(md, ti,\r\n_dm_uevent_type_names[event_type].action,\r\n_dm_uevent_type_names[event_type].name,\r\npath, nr_valid_paths);\r\nif (IS_ERR(event))\r\nreturn;\r\ndm_uevent_add(md, &event->elist);\r\n}\r\nint dm_uevent_init(void)\r\n{\r\n_dm_event_cache = KMEM_CACHE(dm_uevent, 0);\r\nif (!_dm_event_cache)\r\nreturn -ENOMEM;\r\nDMINFO("version 1.0.3");\r\nreturn 0;\r\n}\r\nvoid dm_uevent_exit(void)\r\n{\r\nkmem_cache_destroy(_dm_event_cache);\r\n}
