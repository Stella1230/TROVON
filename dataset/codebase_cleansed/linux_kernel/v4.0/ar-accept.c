static int rxrpc_busy(struct rxrpc_local *local, struct sockaddr_rxrpc *srx,\r\nstruct rxrpc_header *hdr)\r\n{\r\nstruct msghdr msg;\r\nstruct kvec iov[1];\r\nsize_t len;\r\nint ret;\r\n_enter("%d,,", local->debug_id);\r\nmsg.msg_name = &srx->transport.sin;\r\nmsg.msg_namelen = sizeof(srx->transport.sin);\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nmsg.msg_flags = 0;\r\nhdr->seq = 0;\r\nhdr->type = RXRPC_PACKET_TYPE_BUSY;\r\nhdr->flags = 0;\r\nhdr->userStatus = 0;\r\nhdr->_rsvd = 0;\r\niov[0].iov_base = hdr;\r\niov[0].iov_len = sizeof(*hdr);\r\nlen = iov[0].iov_len;\r\nhdr->serial = htonl(1);\r\n_proto("Tx BUSY %%%u", ntohl(hdr->serial));\r\nret = kernel_sendmsg(local->socket, &msg, iov, 1, len);\r\nif (ret < 0) {\r\n_leave(" = -EAGAIN [sendmsg failed: %d]", ret);\r\nreturn -EAGAIN;\r\n}\r\n_leave(" = 0");\r\nreturn 0;\r\n}\r\nstatic int rxrpc_accept_incoming_call(struct rxrpc_local *local,\r\nstruct rxrpc_sock *rx,\r\nstruct sk_buff *skb,\r\nstruct sockaddr_rxrpc *srx)\r\n{\r\nstruct rxrpc_connection *conn;\r\nstruct rxrpc_transport *trans;\r\nstruct rxrpc_skb_priv *sp, *nsp;\r\nstruct rxrpc_peer *peer;\r\nstruct rxrpc_call *call;\r\nstruct sk_buff *notification;\r\nint ret;\r\n_enter("");\r\nsp = rxrpc_skb(skb);\r\nnotification = alloc_skb(0, GFP_NOFS);\r\nif (!notification) {\r\n_debug("no memory");\r\nret = -ENOMEM;\r\ngoto error_nofree;\r\n}\r\nrxrpc_new_skb(notification);\r\nnotification->mark = RXRPC_SKB_MARK_NEW_CALL;\r\npeer = rxrpc_get_peer(srx, GFP_NOIO);\r\nif (IS_ERR(peer)) {\r\n_debug("no peer");\r\nret = -EBUSY;\r\ngoto error;\r\n}\r\ntrans = rxrpc_get_transport(local, peer, GFP_NOIO);\r\nrxrpc_put_peer(peer);\r\nif (IS_ERR(trans)) {\r\n_debug("no trans");\r\nret = -EBUSY;\r\ngoto error;\r\n}\r\nconn = rxrpc_incoming_connection(trans, &sp->hdr, GFP_NOIO);\r\nrxrpc_put_transport(trans);\r\nif (IS_ERR(conn)) {\r\n_debug("no conn");\r\nret = PTR_ERR(conn);\r\ngoto error;\r\n}\r\ncall = rxrpc_incoming_call(rx, conn, &sp->hdr, GFP_NOIO);\r\nrxrpc_put_connection(conn);\r\nif (IS_ERR(call)) {\r\n_debug("no call");\r\nret = PTR_ERR(call);\r\ngoto error;\r\n}\r\nread_lock_bh(&local->services_lock);\r\nif (rx->sk.sk_state == RXRPC_CLOSE)\r\ngoto invalid_service;\r\nwrite_lock(&rx->call_lock);\r\nif (!test_and_set_bit(RXRPC_CALL_INIT_ACCEPT, &call->flags)) {\r\nrxrpc_get_call(call);\r\nspin_lock(&call->conn->state_lock);\r\nif (sp->hdr.securityIndex > 0 &&\r\ncall->conn->state == RXRPC_CONN_SERVER_UNSECURED) {\r\n_debug("await conn sec");\r\nlist_add_tail(&call->accept_link, &rx->secureq);\r\ncall->conn->state = RXRPC_CONN_SERVER_CHALLENGING;\r\natomic_inc(&call->conn->usage);\r\nset_bit(RXRPC_CONN_CHALLENGE, &call->conn->events);\r\nrxrpc_queue_conn(call->conn);\r\n} else {\r\n_debug("conn ready");\r\ncall->state = RXRPC_CALL_SERVER_ACCEPTING;\r\nlist_add_tail(&call->accept_link, &rx->acceptq);\r\nrxrpc_get_call(call);\r\nnsp = rxrpc_skb(notification);\r\nnsp->call = call;\r\nASSERTCMP(atomic_read(&call->usage), >=, 3);\r\n_debug("notify");\r\nspin_lock(&call->lock);\r\nret = rxrpc_queue_rcv_skb(call, notification, true,\r\nfalse);\r\nspin_unlock(&call->lock);\r\nnotification = NULL;\r\nBUG_ON(ret < 0);\r\n}\r\nspin_unlock(&call->conn->state_lock);\r\n_debug("queued");\r\n}\r\nwrite_unlock(&rx->call_lock);\r\n_debug("process");\r\nrxrpc_fast_process_packet(call, skb);\r\n_debug("done");\r\nread_unlock_bh(&local->services_lock);\r\nrxrpc_free_skb(notification);\r\nrxrpc_put_call(call);\r\n_leave(" = 0");\r\nreturn 0;\r\ninvalid_service:\r\n_debug("invalid");\r\nread_unlock_bh(&local->services_lock);\r\nread_lock_bh(&call->state_lock);\r\nif (!test_bit(RXRPC_CALL_RELEASE, &call->flags) &&\r\n!test_and_set_bit(RXRPC_CALL_RELEASE, &call->events)) {\r\nrxrpc_get_call(call);\r\nrxrpc_queue_call(call);\r\n}\r\nread_unlock_bh(&call->state_lock);\r\nrxrpc_put_call(call);\r\nret = -ECONNREFUSED;\r\nerror:\r\nrxrpc_free_skb(notification);\r\nerror_nofree:\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nvoid rxrpc_accept_incoming_calls(struct work_struct *work)\r\n{\r\nstruct rxrpc_local *local =\r\ncontainer_of(work, struct rxrpc_local, acceptor);\r\nstruct rxrpc_skb_priv *sp;\r\nstruct sockaddr_rxrpc srx;\r\nstruct rxrpc_sock *rx;\r\nstruct sk_buff *skb;\r\n__be16 service_id;\r\nint ret;\r\n_enter("%d", local->debug_id);\r\nread_lock_bh(&rxrpc_local_lock);\r\nif (atomic_read(&local->usage) > 0)\r\nrxrpc_get_local(local);\r\nelse\r\nlocal = NULL;\r\nread_unlock_bh(&rxrpc_local_lock);\r\nif (!local) {\r\n_leave(" [local dead]");\r\nreturn;\r\n}\r\nprocess_next_packet:\r\nskb = skb_dequeue(&local->accept_queue);\r\nif (!skb) {\r\nrxrpc_put_local(local);\r\n_leave("\n");\r\nreturn;\r\n}\r\n_net("incoming call skb %p", skb);\r\nsp = rxrpc_skb(skb);\r\nmemset(&srx, 0, sizeof(srx));\r\nsrx.srx_family = AF_RXRPC;\r\nsrx.transport.family = local->srx.transport.family;\r\nsrx.transport_type = local->srx.transport_type;\r\nswitch (srx.transport.family) {\r\ncase AF_INET:\r\nsrx.transport_len = sizeof(struct sockaddr_in);\r\nsrx.transport.sin.sin_port = udp_hdr(skb)->source;\r\nsrx.transport.sin.sin_addr.s_addr = ip_hdr(skb)->saddr;\r\nbreak;\r\ndefault:\r\ngoto busy;\r\n}\r\nservice_id = sp->hdr.serviceId;\r\nread_lock_bh(&local->services_lock);\r\nlist_for_each_entry(rx, &local->services, listen_link) {\r\nif (rx->service_id == service_id &&\r\nrx->sk.sk_state != RXRPC_CLOSE)\r\ngoto found_service;\r\n}\r\nread_unlock_bh(&local->services_lock);\r\ngoto invalid_service;\r\nfound_service:\r\n_debug("found service %hd", ntohs(rx->service_id));\r\nif (sk_acceptq_is_full(&rx->sk))\r\ngoto backlog_full;\r\nsk_acceptq_added(&rx->sk);\r\nsock_hold(&rx->sk);\r\nread_unlock_bh(&local->services_lock);\r\nret = rxrpc_accept_incoming_call(local, rx, skb, &srx);\r\nif (ret < 0)\r\nsk_acceptq_removed(&rx->sk);\r\nsock_put(&rx->sk);\r\nswitch (ret) {\r\ncase -ECONNRESET:\r\ncase -ECONNABORTED:\r\ncase 0:\r\ngoto process_next_packet;\r\ncase -ECONNREFUSED:\r\ngoto invalid_service;\r\ncase -EBUSY:\r\ngoto busy;\r\ncase -EKEYREJECTED:\r\ngoto security_mismatch;\r\ndefault:\r\nBUG();\r\n}\r\nbacklog_full:\r\nread_unlock_bh(&local->services_lock);\r\nbusy:\r\nrxrpc_busy(local, &srx, &sp->hdr);\r\nrxrpc_free_skb(skb);\r\ngoto process_next_packet;\r\ninvalid_service:\r\nskb->priority = RX_INVALID_OPERATION;\r\nrxrpc_reject_packet(local, skb);\r\ngoto process_next_packet;\r\nsecurity_mismatch:\r\nskb->priority = RX_PROTOCOL_ERROR;\r\nrxrpc_reject_packet(local, skb);\r\ngoto process_next_packet;\r\n}\r\nstruct rxrpc_call *rxrpc_accept_call(struct rxrpc_sock *rx,\r\nunsigned long user_call_ID)\r\n{\r\nstruct rxrpc_call *call;\r\nstruct rb_node *parent, **pp;\r\nint ret;\r\n_enter(",%lx", user_call_ID);\r\nASSERT(!irqs_disabled());\r\nwrite_lock(&rx->call_lock);\r\nret = -ENODATA;\r\nif (list_empty(&rx->acceptq))\r\ngoto out;\r\nret = -EBADSLT;\r\npp = &rx->calls.rb_node;\r\nparent = NULL;\r\nwhile (*pp) {\r\nparent = *pp;\r\ncall = rb_entry(parent, struct rxrpc_call, sock_node);\r\nif (user_call_ID < call->user_call_ID)\r\npp = &(*pp)->rb_left;\r\nelse if (user_call_ID > call->user_call_ID)\r\npp = &(*pp)->rb_right;\r\nelse\r\ngoto out;\r\n}\r\ncall = list_entry(rx->acceptq.next, struct rxrpc_call, accept_link);\r\nlist_del_init(&call->accept_link);\r\nsk_acceptq_removed(&rx->sk);\r\nwrite_lock_bh(&call->state_lock);\r\nswitch (call->state) {\r\ncase RXRPC_CALL_SERVER_ACCEPTING:\r\ncall->state = RXRPC_CALL_SERVER_RECV_REQUEST;\r\nbreak;\r\ncase RXRPC_CALL_REMOTELY_ABORTED:\r\ncase RXRPC_CALL_LOCALLY_ABORTED:\r\nret = -ECONNABORTED;\r\ngoto out_release;\r\ncase RXRPC_CALL_NETWORK_ERROR:\r\nret = call->conn->error;\r\ngoto out_release;\r\ncase RXRPC_CALL_DEAD:\r\nret = -ETIME;\r\ngoto out_discard;\r\ndefault:\r\nBUG();\r\n}\r\ncall->user_call_ID = user_call_ID;\r\nrb_link_node(&call->sock_node, parent, pp);\r\nrb_insert_color(&call->sock_node, &rx->calls);\r\nif (test_and_set_bit(RXRPC_CALL_HAS_USERID, &call->flags))\r\nBUG();\r\nif (test_and_set_bit(RXRPC_CALL_ACCEPTED, &call->events))\r\nBUG();\r\nrxrpc_queue_call(call);\r\nrxrpc_get_call(call);\r\nwrite_unlock_bh(&call->state_lock);\r\nwrite_unlock(&rx->call_lock);\r\n_leave(" = %p{%d}", call, call->debug_id);\r\nreturn call;\r\nout_release:\r\n_debug("release %p", call);\r\nif (!test_bit(RXRPC_CALL_RELEASED, &call->flags) &&\r\n!test_and_set_bit(RXRPC_CALL_RELEASE, &call->events))\r\nrxrpc_queue_call(call);\r\nout_discard:\r\nwrite_unlock_bh(&call->state_lock);\r\n_debug("discard %p", call);\r\nout:\r\nwrite_unlock(&rx->call_lock);\r\n_leave(" = %d", ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nint rxrpc_reject_call(struct rxrpc_sock *rx)\r\n{\r\nstruct rxrpc_call *call;\r\nint ret;\r\n_enter("");\r\nASSERT(!irqs_disabled());\r\nwrite_lock(&rx->call_lock);\r\nret = -ENODATA;\r\nif (list_empty(&rx->acceptq))\r\ngoto out;\r\ncall = list_entry(rx->acceptq.next, struct rxrpc_call, accept_link);\r\nlist_del_init(&call->accept_link);\r\nsk_acceptq_removed(&rx->sk);\r\nwrite_lock_bh(&call->state_lock);\r\nswitch (call->state) {\r\ncase RXRPC_CALL_SERVER_ACCEPTING:\r\ncall->state = RXRPC_CALL_SERVER_BUSY;\r\nif (test_and_set_bit(RXRPC_CALL_REJECT_BUSY, &call->events))\r\nrxrpc_queue_call(call);\r\nret = 0;\r\ngoto out_release;\r\ncase RXRPC_CALL_REMOTELY_ABORTED:\r\ncase RXRPC_CALL_LOCALLY_ABORTED:\r\nret = -ECONNABORTED;\r\ngoto out_release;\r\ncase RXRPC_CALL_NETWORK_ERROR:\r\nret = call->conn->error;\r\ngoto out_release;\r\ncase RXRPC_CALL_DEAD:\r\nret = -ETIME;\r\ngoto out_discard;\r\ndefault:\r\nBUG();\r\n}\r\nout_release:\r\n_debug("release %p", call);\r\nif (!test_bit(RXRPC_CALL_RELEASED, &call->flags) &&\r\n!test_and_set_bit(RXRPC_CALL_RELEASE, &call->events))\r\nrxrpc_queue_call(call);\r\nout_discard:\r\nwrite_unlock_bh(&call->state_lock);\r\n_debug("discard %p", call);\r\nout:\r\nwrite_unlock(&rx->call_lock);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstruct rxrpc_call *rxrpc_kernel_accept_call(struct socket *sock,\r\nunsigned long user_call_ID)\r\n{\r\nstruct rxrpc_call *call;\r\n_enter(",%lx", user_call_ID);\r\ncall = rxrpc_accept_call(rxrpc_sk(sock->sk), user_call_ID);\r\n_leave(" = %p", call);\r\nreturn call;\r\n}\r\nint rxrpc_kernel_reject_call(struct socket *sock)\r\n{\r\nint ret;\r\n_enter("");\r\nret = rxrpc_reject_call(rxrpc_sk(sock->sk));\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}
