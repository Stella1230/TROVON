static void set_config_filename(const char *config_filename)\r\n{\r\nstatic char menu_backtitle[PATH_MAX+128];\r\nint size;\r\nsize = snprintf(menu_backtitle, sizeof(menu_backtitle),\r\n"%s - %s", config_filename, rootmenu.prompt->text);\r\nif (size >= sizeof(menu_backtitle))\r\nmenu_backtitle[sizeof(menu_backtitle)-1] = '\0';\r\nset_dialog_backtitle(menu_backtitle);\r\nsize = snprintf(filename, sizeof(filename), "%s", config_filename);\r\nif (size >= sizeof(filename))\r\nfilename[sizeof(filename)-1] = '\0';\r\n}\r\nstatic void set_subtitle(void)\r\n{\r\nstruct subtitle_part *sp;\r\nstruct subtitle_list *pos, *tmp;\r\nfor (pos = subtitles; pos != NULL; pos = tmp) {\r\ntmp = pos->next;\r\nfree(pos);\r\n}\r\nsubtitles = NULL;\r\nlist_for_each_entry(sp, &trail, entries) {\r\nif (sp->text) {\r\nif (pos) {\r\npos->next = xcalloc(1, sizeof(*pos));\r\npos = pos->next;\r\n} else {\r\nsubtitles = pos = xcalloc(1, sizeof(*pos));\r\n}\r\npos->text = sp->text;\r\n}\r\n}\r\nset_dialog_subtitles(subtitles);\r\n}\r\nstatic void reset_subtitle(void)\r\n{\r\nstruct subtitle_list *pos, *tmp;\r\nfor (pos = subtitles; pos != NULL; pos = tmp) {\r\ntmp = pos->next;\r\nfree(pos);\r\n}\r\nsubtitles = NULL;\r\nset_dialog_subtitles(subtitles);\r\n}\r\nstatic void update_text(char *buf, size_t start, size_t end, void *_data)\r\n{\r\nstruct search_data *data = _data;\r\nstruct jump_key *pos;\r\nint k = 0;\r\nlist_for_each_entry(pos, data->head, entries) {\r\nif (pos->offset >= start && pos->offset < end) {\r\nchar header[4];\r\nif (k < JUMP_NB) {\r\nint key = '0' + (pos->index % JUMP_NB) + 1;\r\nsprintf(header, "(%c)", key);\r\ndata->keys[k] = key;\r\ndata->targets[k] = pos->target;\r\nk++;\r\n} else {\r\nsprintf(header, " ");\r\n}\r\nmemcpy(buf + pos->offset, header, sizeof(header) - 1);\r\n}\r\n}\r\ndata->keys[k] = 0;\r\n}\r\nstatic void search_conf(void)\r\n{\r\nstruct symbol **sym_arr;\r\nstruct gstr res;\r\nstruct gstr title;\r\nchar *dialog_input;\r\nint dres, vscroll = 0, hscroll = 0;\r\nbool again;\r\nstruct gstr sttext;\r\nstruct subtitle_part stpart;\r\ntitle = str_new();\r\nstr_printf( &title, _("Enter (sub)string or regexp to search for "\r\n"(with or without \"%s\")"), CONFIG_);\r\nagain:\r\ndialog_clear();\r\ndres = dialog_inputbox(_("Search Configuration Parameter"),\r\nstr_get(&title),\r\n10, 75, "");\r\nswitch (dres) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nshow_helptext(_("Search Configuration"), search_help);\r\ngoto again;\r\ndefault:\r\nstr_free(&title);\r\nreturn;\r\n}\r\ndialog_input = dialog_input_result;\r\nif (strncasecmp(dialog_input_result, CONFIG_, strlen(CONFIG_)) == 0)\r\ndialog_input += strlen(CONFIG_);\r\nsttext = str_new();\r\nstr_printf(&sttext, "Search (%s)", dialog_input_result);\r\nstpart.text = str_get(&sttext);\r\nlist_add_tail(&stpart.entries, &trail);\r\nsym_arr = sym_re_search(dialog_input);\r\ndo {\r\nLIST_HEAD(head);\r\nstruct menu *targets[JUMP_NB];\r\nint keys[JUMP_NB + 1], i;\r\nstruct search_data data = {\r\n.head = &head,\r\n.targets = targets,\r\n.keys = keys,\r\n};\r\nstruct jump_key *pos, *tmp;\r\nres = get_relations_str(sym_arr, &head);\r\nset_subtitle();\r\ndres = show_textbox_ext(_("Search Results"), (char *)\r\nstr_get(&res), 0, 0, keys, &vscroll,\r\n&hscroll, &update_text, (void *)\r\n&data);\r\nagain = false;\r\nfor (i = 0; i < JUMP_NB && keys[i]; i++)\r\nif (dres == keys[i]) {\r\nconf(targets[i]->parent, targets[i]);\r\nagain = true;\r\n}\r\nstr_free(&res);\r\nlist_for_each_entry_safe(pos, tmp, &head, entries)\r\nfree(pos);\r\n} while (again);\r\nfree(sym_arr);\r\nstr_free(&title);\r\nlist_del(trail.prev);\r\nstr_free(&sttext);\r\n}\r\nstatic void build_conf(struct menu *menu)\r\n{\r\nstruct symbol *sym;\r\nstruct property *prop;\r\nstruct menu *child;\r\nint type, tmp, doint = 2;\r\ntristate val;\r\nchar ch;\r\nbool visible;\r\nvisible = menu_is_visible(menu);\r\nif (show_all_options && !menu_has_prompt(menu))\r\nreturn;\r\nelse if (!show_all_options && !visible)\r\nreturn;\r\nsym = menu->sym;\r\nprop = menu->prompt;\r\nif (!sym) {\r\nif (prop && menu != current_menu) {\r\nconst char *prompt = menu_get_prompt(menu);\r\nswitch (prop->type) {\r\ncase P_MENU:\r\nchild_count++;\r\nprompt = _(prompt);\r\nif (single_menu_mode) {\r\nitem_make("%s%*c%s",\r\nmenu->data ? "-->" : "++>",\r\nindent + 1, ' ', prompt);\r\n} else\r\nitem_make(" %*c%s %s",\r\nindent + 1, ' ', prompt,\r\nmenu_is_empty(menu) ? "----" : "--->");\r\nitem_set_tag('m');\r\nitem_set_data(menu);\r\nif (single_menu_mode && menu->data)\r\ngoto conf_childs;\r\nreturn;\r\ncase P_COMMENT:\r\nif (prompt) {\r\nchild_count++;\r\nitem_make(" %*c*** %s ***", indent + 1, ' ', _(prompt));\r\nitem_set_tag(':');\r\nitem_set_data(menu);\r\n}\r\nbreak;\r\ndefault:\r\nif (prompt) {\r\nchild_count++;\r\nitem_make("---%*c%s", indent + 1, ' ', _(prompt));\r\nitem_set_tag(':');\r\nitem_set_data(menu);\r\n}\r\n}\r\n} else\r\ndoint = 0;\r\ngoto conf_childs;\r\n}\r\ntype = sym_get_type(sym);\r\nif (sym_is_choice(sym)) {\r\nstruct symbol *def_sym = sym_get_choice_value(sym);\r\nstruct menu *def_menu = NULL;\r\nchild_count++;\r\nfor (child = menu->list; child; child = child->next) {\r\nif (menu_is_visible(child) && child->sym == def_sym)\r\ndef_menu = child;\r\n}\r\nval = sym_get_tristate_value(sym);\r\nif (sym_is_changable(sym)) {\r\nswitch (type) {\r\ncase S_BOOLEAN:\r\nitem_make("[%c]", val == no ? ' ' : '*');\r\nbreak;\r\ncase S_TRISTATE:\r\nswitch (val) {\r\ncase yes: ch = '*'; break;\r\ncase mod: ch = 'M'; break;\r\ndefault: ch = ' '; break;\r\n}\r\nitem_make("<%c>", ch);\r\nbreak;\r\n}\r\nitem_set_tag('t');\r\nitem_set_data(menu);\r\n} else {\r\nitem_make(" ");\r\nitem_set_tag(def_menu ? 't' : ':');\r\nitem_set_data(menu);\r\n}\r\nitem_add_str("%*c%s", indent + 1, ' ', _(menu_get_prompt(menu)));\r\nif (val == yes) {\r\nif (def_menu) {\r\nitem_add_str(" (%s)", _(menu_get_prompt(def_menu)));\r\nitem_add_str(" --->");\r\nif (def_menu->list) {\r\nindent += 2;\r\nbuild_conf(def_menu);\r\nindent -= 2;\r\n}\r\n}\r\nreturn;\r\n}\r\n} else {\r\nif (menu == current_menu) {\r\nitem_make("---%*c%s", indent + 1, ' ', _(menu_get_prompt(menu)));\r\nitem_set_tag(':');\r\nitem_set_data(menu);\r\ngoto conf_childs;\r\n}\r\nchild_count++;\r\nval = sym_get_tristate_value(sym);\r\nif (sym_is_choice_value(sym) && val == yes) {\r\nitem_make(" ");\r\nitem_set_tag(':');\r\nitem_set_data(menu);\r\n} else {\r\nswitch (type) {\r\ncase S_BOOLEAN:\r\nif (sym_is_changable(sym))\r\nitem_make("[%c]", val == no ? ' ' : '*');\r\nelse\r\nitem_make("-%c-", val == no ? ' ' : '*');\r\nitem_set_tag('t');\r\nitem_set_data(menu);\r\nbreak;\r\ncase S_TRISTATE:\r\nswitch (val) {\r\ncase yes: ch = '*'; break;\r\ncase mod: ch = 'M'; break;\r\ndefault: ch = ' '; break;\r\n}\r\nif (sym_is_changable(sym)) {\r\nif (sym->rev_dep.tri == mod)\r\nitem_make("{%c}", ch);\r\nelse\r\nitem_make("<%c>", ch);\r\n} else\r\nitem_make("-%c-", ch);\r\nitem_set_tag('t');\r\nitem_set_data(menu);\r\nbreak;\r\ndefault:\r\ntmp = 2 + strlen(sym_get_string_value(sym));\r\nitem_make("(%s)", sym_get_string_value(sym));\r\ntmp = indent - tmp + 4;\r\nif (tmp < 0)\r\ntmp = 0;\r\nitem_add_str("%*c%s%s", tmp, ' ', _(menu_get_prompt(menu)),\r\n(sym_has_value(sym) || !sym_is_changable(sym)) ?\r\n"" : _(" (NEW)"));\r\nitem_set_tag('s');\r\nitem_set_data(menu);\r\ngoto conf_childs;\r\n}\r\n}\r\nitem_add_str("%*c%s%s", indent + 1, ' ', _(menu_get_prompt(menu)),\r\n(sym_has_value(sym) || !sym_is_changable(sym)) ?\r\n"" : _(" (NEW)"));\r\nif (menu->prompt->type == P_MENU) {\r\nitem_add_str(" %s", menu_is_empty(menu) ? "----" : "--->");\r\nreturn;\r\n}\r\n}\r\nconf_childs:\r\nindent += doint;\r\nfor (child = menu->list; child; child = child->next)\r\nbuild_conf(child);\r\nindent -= doint;\r\n}\r\nstatic void conf(struct menu *menu, struct menu *active_menu)\r\n{\r\nstruct menu *submenu;\r\nconst char *prompt = menu_get_prompt(menu);\r\nstruct subtitle_part stpart;\r\nstruct symbol *sym;\r\nint res;\r\nint s_scroll = 0;\r\nif (menu != &rootmenu)\r\nstpart.text = menu_get_prompt(menu);\r\nelse\r\nstpart.text = NULL;\r\nlist_add_tail(&stpart.entries, &trail);\r\nwhile (1) {\r\nitem_reset();\r\ncurrent_menu = menu;\r\nbuild_conf(menu);\r\nif (!child_count)\r\nbreak;\r\nset_subtitle();\r\ndialog_clear();\r\nres = dialog_menu(prompt ? _(prompt) : _("Main Menu"),\r\n_(menu_instructions),\r\nactive_menu, &s_scroll);\r\nif (res == 1 || res == KEY_ESC || res == -ERRDISPLAYTOOSMALL)\r\nbreak;\r\nif (item_count() != 0) {\r\nif (!item_activate_selected())\r\ncontinue;\r\nif (!item_tag())\r\ncontinue;\r\n}\r\nsubmenu = item_data();\r\nactive_menu = item_data();\r\nif (submenu)\r\nsym = submenu->sym;\r\nelse\r\nsym = NULL;\r\nswitch (res) {\r\ncase 0:\r\nswitch (item_tag()) {\r\ncase 'm':\r\nif (single_menu_mode)\r\nsubmenu->data = (void *) (long) !submenu->data;\r\nelse\r\nconf(submenu, NULL);\r\nbreak;\r\ncase 't':\r\nif (sym_is_choice(sym) && sym_get_tristate_value(sym) == yes)\r\nconf_choice(submenu);\r\nelse if (submenu->prompt->type == P_MENU)\r\nconf(submenu, NULL);\r\nbreak;\r\ncase 's':\r\nconf_string(submenu);\r\nbreak;\r\n}\r\nbreak;\r\ncase 2:\r\nif (sym)\r\nshow_help(submenu);\r\nelse {\r\nreset_subtitle();\r\nshow_helptext(_("README"), _(mconf_readme));\r\n}\r\nbreak;\r\ncase 3:\r\nreset_subtitle();\r\nconf_save();\r\nbreak;\r\ncase 4:\r\nreset_subtitle();\r\nconf_load();\r\nbreak;\r\ncase 5:\r\nif (item_is_tag('t')) {\r\nif (sym_set_tristate_value(sym, yes))\r\nbreak;\r\nif (sym_set_tristate_value(sym, mod))\r\nshow_textbox(NULL, setmod_text, 6, 74);\r\n}\r\nbreak;\r\ncase 6:\r\nif (item_is_tag('t'))\r\nsym_set_tristate_value(sym, no);\r\nbreak;\r\ncase 7:\r\nif (item_is_tag('t'))\r\nsym_set_tristate_value(sym, mod);\r\nbreak;\r\ncase 8:\r\nif (item_is_tag('t'))\r\nsym_toggle_tristate_value(sym);\r\nelse if (item_is_tag('m'))\r\nconf(submenu, NULL);\r\nbreak;\r\ncase 9:\r\nsearch_conf();\r\nbreak;\r\ncase 10:\r\nshow_all_options = !show_all_options;\r\nbreak;\r\n}\r\n}\r\nlist_del(trail.prev);\r\n}\r\nstatic int show_textbox_ext(const char *title, char *text, int r, int c, int\r\n*keys, int *vscroll, int *hscroll, update_text_fn\r\nupdate_text, void *data)\r\n{\r\ndialog_clear();\r\nreturn dialog_textbox(title, text, r, c, keys, vscroll, hscroll,\r\nupdate_text, data);\r\n}\r\nstatic void show_textbox(const char *title, const char *text, int r, int c)\r\n{\r\nshow_textbox_ext(title, (char *) text, r, c, (int []) {0}, NULL, NULL,\r\nNULL, NULL);\r\n}\r\nstatic void show_helptext(const char *title, const char *text)\r\n{\r\nshow_textbox(title, text, 0, 0);\r\n}\r\nstatic void conf_message_callback(const char *fmt, va_list ap)\r\n{\r\nchar buf[PATH_MAX+1];\r\nvsnprintf(buf, sizeof(buf), fmt, ap);\r\nif (save_and_exit)\r\nprintf("%s", buf);\r\nelse\r\nshow_textbox(NULL, buf, 6, 60);\r\n}\r\nstatic void show_help(struct menu *menu)\r\n{\r\nstruct gstr help = str_new();\r\nhelp.max_width = getmaxx(stdscr) - 10;\r\nmenu_get_ext_help(menu, &help);\r\nshow_helptext(_(menu_get_prompt(menu)), str_get(&help));\r\nstr_free(&help);\r\n}\r\nstatic void conf_choice(struct menu *menu)\r\n{\r\nconst char *prompt = _(menu_get_prompt(menu));\r\nstruct menu *child;\r\nstruct symbol *active;\r\nactive = sym_get_choice_value(menu->sym);\r\nwhile (1) {\r\nint res;\r\nint selected;\r\nitem_reset();\r\ncurrent_menu = menu;\r\nfor (child = menu->list; child; child = child->next) {\r\nif (!menu_is_visible(child))\r\ncontinue;\r\nif (child->sym)\r\nitem_make("%s", _(menu_get_prompt(child)));\r\nelse {\r\nitem_make("*** %s ***", _(menu_get_prompt(child)));\r\nitem_set_tag(':');\r\n}\r\nitem_set_data(child);\r\nif (child->sym == active)\r\nitem_set_selected(1);\r\nif (child->sym == sym_get_choice_value(menu->sym))\r\nitem_set_tag('X');\r\n}\r\ndialog_clear();\r\nres = dialog_checklist(prompt ? _(prompt) : _("Main Menu"),\r\n_(radiolist_instructions),\r\nMENUBOX_HEIGTH_MIN,\r\nMENUBOX_WIDTH_MIN,\r\nCHECKLIST_HEIGTH_MIN);\r\nselected = item_activate_selected();\r\nswitch (res) {\r\ncase 0:\r\nif (selected) {\r\nchild = item_data();\r\nif (!child->sym)\r\nbreak;\r\nsym_set_tristate_value(child->sym, yes);\r\n}\r\nreturn;\r\ncase 1:\r\nif (selected) {\r\nchild = item_data();\r\nshow_help(child);\r\nactive = child->sym;\r\n} else\r\nshow_help(menu);\r\nbreak;\r\ncase KEY_ESC:\r\nreturn;\r\ncase -ERRDISPLAYTOOSMALL:\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void conf_string(struct menu *menu)\r\n{\r\nconst char *prompt = menu_get_prompt(menu);\r\nwhile (1) {\r\nint res;\r\nconst char *heading;\r\nswitch (sym_get_type(menu->sym)) {\r\ncase S_INT:\r\nheading = _(inputbox_instructions_int);\r\nbreak;\r\ncase S_HEX:\r\nheading = _(inputbox_instructions_hex);\r\nbreak;\r\ncase S_STRING:\r\nheading = _(inputbox_instructions_string);\r\nbreak;\r\ndefault:\r\nheading = _("Internal mconf error!");\r\n}\r\ndialog_clear();\r\nres = dialog_inputbox(prompt ? _(prompt) : _("Main Menu"),\r\nheading, 10, 75,\r\nsym_get_string_value(menu->sym));\r\nswitch (res) {\r\ncase 0:\r\nif (sym_set_string_value(menu->sym, dialog_input_result))\r\nreturn;\r\nshow_textbox(NULL, _("You have made an invalid entry."), 5, 43);\r\nbreak;\r\ncase 1:\r\nshow_help(menu);\r\nbreak;\r\ncase KEY_ESC:\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void conf_load(void)\r\n{\r\nwhile (1) {\r\nint res;\r\ndialog_clear();\r\nres = dialog_inputbox(NULL, load_config_text,\r\n11, 55, filename);\r\nswitch(res) {\r\ncase 0:\r\nif (!dialog_input_result[0])\r\nreturn;\r\nif (!conf_read(dialog_input_result)) {\r\nset_config_filename(dialog_input_result);\r\nsym_set_change_count(1);\r\nreturn;\r\n}\r\nshow_textbox(NULL, _("File does not exist!"), 5, 38);\r\nbreak;\r\ncase 1:\r\nshow_helptext(_("Load Alternate Configuration"), load_config_help);\r\nbreak;\r\ncase KEY_ESC:\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void conf_save(void)\r\n{\r\nwhile (1) {\r\nint res;\r\ndialog_clear();\r\nres = dialog_inputbox(NULL, save_config_text,\r\n11, 55, filename);\r\nswitch(res) {\r\ncase 0:\r\nif (!dialog_input_result[0])\r\nreturn;\r\nif (!conf_write(dialog_input_result)) {\r\nset_config_filename(dialog_input_result);\r\nreturn;\r\n}\r\nshow_textbox(NULL, _("Can't create file! Probably a nonexistent directory."), 5, 60);\r\nbreak;\r\ncase 1:\r\nshow_helptext(_("Save Alternate Configuration"), save_config_help);\r\nbreak;\r\ncase KEY_ESC:\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic int handle_exit(void)\r\n{\r\nint res;\r\nsave_and_exit = 1;\r\nreset_subtitle();\r\ndialog_clear();\r\nif (conf_get_changed())\r\nres = dialog_yesno(NULL,\r\n_("Do you wish to save your new configuration?\n"\r\n"(Press <ESC><ESC> to continue kernel configuration.)"),\r\n6, 60);\r\nelse\r\nres = -1;\r\nend_dialog(saved_x, saved_y);\r\nswitch (res) {\r\ncase 0:\r\nif (conf_write(filename)) {\r\nfprintf(stderr, _("\n\n"\r\n"Error while writing of the configuration.\n"\r\n"Your configuration changes were NOT saved."\r\n"\n\n"));\r\nreturn 1;\r\n}\r\ncase -1:\r\nprintf(_("\n\n"\r\n"*** End of the configuration.\n"\r\n"*** Execute 'make' to start the build or try 'make help'."\r\n"\n\n"));\r\nres = 0;\r\nbreak;\r\ndefault:\r\nfprintf(stderr, _("\n\n"\r\n"Your configuration changes were NOT saved."\r\n"\n\n"));\r\nif (res != KEY_ESC)\r\nres = 0;\r\n}\r\nreturn res;\r\n}\r\nstatic void sig_handler(int signo)\r\n{\r\nexit(handle_exit());\r\n}\r\nint main(int ac, char **av)\r\n{\r\nchar *mode;\r\nint res;\r\nsetlocale(LC_ALL, "");\r\nbindtextdomain(PACKAGE, LOCALEDIR);\r\ntextdomain(PACKAGE);\r\nsignal(SIGINT, sig_handler);\r\nconf_parse(av[1]);\r\nconf_read(NULL);\r\nmode = getenv("MENUCONFIG_MODE");\r\nif (mode) {\r\nif (!strcasecmp(mode, "single_menu"))\r\nsingle_menu_mode = 1;\r\n}\r\nif (init_dialog(NULL)) {\r\nfprintf(stderr, N_("Your display is too small to run Menuconfig!\n"));\r\nfprintf(stderr, N_("It must be at least 19 lines by 80 columns.\n"));\r\nreturn 1;\r\n}\r\nset_config_filename(conf_get_configname());\r\nconf_set_message_callback(conf_message_callback);\r\ndo {\r\nconf(&rootmenu, NULL);\r\nres = handle_exit();\r\n} while (res == KEY_ESC);\r\nreturn res;\r\n}
