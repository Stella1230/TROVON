static inline struct device *mic_dev(struct mic_vdev *mvdev)\r\n{\r\nreturn mvdev->vdev.dev.parent;\r\n}\r\nstatic u64 mic_get_features(struct virtio_device *vdev)\r\n{\r\nunsigned int i, bits;\r\nu32 features = 0;\r\nstruct mic_device_desc __iomem *desc = to_micvdev(vdev)->desc;\r\nu8 __iomem *in_features = mic_vq_features(desc);\r\nint feature_len = ioread8(&desc->feature_len);\r\nbits = min_t(unsigned, feature_len, sizeof(features)) * 8;\r\nfor (i = 0; i < bits; i++)\r\nif (ioread8(&in_features[i / 8]) & (BIT(i % 8)))\r\nfeatures |= BIT(i);\r\nreturn features;\r\n}\r\nstatic int mic_finalize_features(struct virtio_device *vdev)\r\n{\r\nunsigned int i, bits;\r\nstruct mic_device_desc __iomem *desc = to_micvdev(vdev)->desc;\r\nu8 feature_len = ioread8(&desc->feature_len);\r\nu8 __iomem *out_features =\r\nmic_vq_features(desc) + feature_len;\r\nvring_transport_features(vdev);\r\nBUG_ON((u32)vdev->features != vdev->features);\r\nmemset_io(out_features, 0, feature_len);\r\nbits = min_t(unsigned, feature_len,\r\nsizeof(vdev->features)) * 8;\r\nfor (i = 0; i < bits; i++) {\r\nif (__virtio_test_bit(vdev, i))\r\niowrite8(ioread8(&out_features[i / 8]) | (1 << (i % 8)),\r\n&out_features[i / 8]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mic_get(struct virtio_device *vdev, unsigned int offset,\r\nvoid *buf, unsigned len)\r\n{\r\nstruct mic_device_desc __iomem *desc = to_micvdev(vdev)->desc;\r\nif (offset + len > ioread8(&desc->config_len))\r\nreturn;\r\nmemcpy_fromio(buf, mic_vq_configspace(desc) + offset, len);\r\n}\r\nstatic void mic_set(struct virtio_device *vdev, unsigned int offset,\r\nconst void *buf, unsigned len)\r\n{\r\nstruct mic_device_desc __iomem *desc = to_micvdev(vdev)->desc;\r\nif (offset + len > ioread8(&desc->config_len))\r\nreturn;\r\nmemcpy_toio(mic_vq_configspace(desc) + offset, buf, len);\r\n}\r\nstatic u8 mic_get_status(struct virtio_device *vdev)\r\n{\r\nreturn ioread8(&to_micvdev(vdev)->desc->status);\r\n}\r\nstatic void mic_set_status(struct virtio_device *vdev, u8 status)\r\n{\r\nstruct mic_vdev *mvdev = to_micvdev(vdev);\r\nif (!status)\r\nreturn;\r\niowrite8(status, &mvdev->desc->status);\r\nmic_send_intr(mvdev->mdev, mvdev->c2h_vdev_db);\r\n}\r\nstatic void mic_reset_inform_host(struct virtio_device *vdev)\r\n{\r\nstruct mic_vdev *mvdev = to_micvdev(vdev);\r\nstruct mic_device_ctrl __iomem *dc = mvdev->dc;\r\nint retry;\r\niowrite8(0, &dc->host_ack);\r\niowrite8(1, &dc->vdev_reset);\r\nmic_send_intr(mvdev->mdev, mvdev->c2h_vdev_db);\r\nfor (retry = 100; retry--;) {\r\nif (ioread8(&dc->host_ack))\r\nbreak;\r\nmsleep(100);\r\n};\r\ndev_dbg(mic_dev(mvdev), "%s: retry: %d\n", __func__, retry);\r\niowrite8(0, &mvdev->desc->status);\r\n}\r\nstatic void mic_reset(struct virtio_device *vdev)\r\n{\r\nstruct mic_vdev *mvdev = to_micvdev(vdev);\r\ndev_dbg(mic_dev(mvdev), "%s: virtio id %d\n",\r\n__func__, vdev->id.device);\r\nmic_reset_inform_host(vdev);\r\ncomplete_all(&mvdev->reset_done);\r\n}\r\nstatic bool mic_notify(struct virtqueue *vq)\r\n{\r\nstruct mic_vdev *mvdev = vq->priv;\r\nmic_send_intr(mvdev->mdev, mvdev->c2h_vdev_db);\r\nreturn true;\r\n}\r\nstatic void mic_del_vq(struct virtqueue *vq, int n)\r\n{\r\nstruct mic_vdev *mvdev = to_micvdev(vq->vdev);\r\nstruct vring *vr = (struct vring *)(vq + 1);\r\nfree_pages((unsigned long) vr->used, get_order(mvdev->used_size[n]));\r\nvring_del_virtqueue(vq);\r\nmic_card_unmap(mvdev->mdev, mvdev->vr[n]);\r\nmvdev->vr[n] = NULL;\r\n}\r\nstatic void mic_del_vqs(struct virtio_device *vdev)\r\n{\r\nstruct mic_vdev *mvdev = to_micvdev(vdev);\r\nstruct virtqueue *vq, *n;\r\nint idx = 0;\r\ndev_dbg(mic_dev(mvdev), "%s\n", __func__);\r\nlist_for_each_entry_safe(vq, n, &vdev->vqs, list)\r\nmic_del_vq(vq, idx++);\r\n}\r\nstatic struct virtqueue *mic_find_vq(struct virtio_device *vdev,\r\nunsigned index,\r\nvoid (*callback)(struct virtqueue *vq),\r\nconst char *name)\r\n{\r\nstruct mic_vdev *mvdev = to_micvdev(vdev);\r\nstruct mic_vqconfig __iomem *vqconfig;\r\nstruct mic_vqconfig config;\r\nstruct virtqueue *vq;\r\nvoid __iomem *va;\r\nstruct _mic_vring_info __iomem *info;\r\nvoid *used;\r\nint vr_size, _vr_size, err, magic;\r\nstruct vring *vr;\r\nu8 type = ioread8(&mvdev->desc->type);\r\nif (index >= ioread8(&mvdev->desc->num_vq))\r\nreturn ERR_PTR(-ENOENT);\r\nif (!name)\r\nreturn ERR_PTR(-ENOENT);\r\nvqconfig = mic_vq_config(mvdev->desc) + index;\r\nmemcpy_fromio(&config, vqconfig, sizeof(config));\r\n_vr_size = vring_size(le16_to_cpu(config.num), MIC_VIRTIO_RING_ALIGN);\r\nvr_size = PAGE_ALIGN(_vr_size + sizeof(struct _mic_vring_info));\r\nva = mic_card_map(mvdev->mdev, le64_to_cpu(config.address), vr_size);\r\nif (!va)\r\nreturn ERR_PTR(-ENOMEM);\r\nmvdev->vr[index] = va;\r\nmemset_io(va, 0x0, _vr_size);\r\nvq = vring_new_virtqueue(index, le16_to_cpu(config.num),\r\nMIC_VIRTIO_RING_ALIGN, vdev, false,\r\n(void __force *)va, mic_notify, callback,\r\nname);\r\nif (!vq) {\r\nerr = -ENOMEM;\r\ngoto unmap;\r\n}\r\ninfo = va + _vr_size;\r\nmagic = ioread32(&info->magic);\r\nif (WARN(magic != MIC_MAGIC + type + index, "magic mismatch")) {\r\nerr = -EIO;\r\ngoto unmap;\r\n}\r\nmvdev->used_size[index] = PAGE_ALIGN(sizeof(__u16) * 3 +\r\nsizeof(struct vring_used_elem) *\r\nle16_to_cpu(config.num));\r\nused = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,\r\nget_order(mvdev->used_size[index]));\r\nif (!used) {\r\nerr = -ENOMEM;\r\ndev_err(mic_dev(mvdev), "%s %d err %d\n",\r\n__func__, __LINE__, err);\r\ngoto del_vq;\r\n}\r\niowrite64(virt_to_phys(used), &vqconfig->used_address);\r\nvr = (struct vring *)(vq + 1);\r\nvr->used = used;\r\nvq->priv = mvdev;\r\nreturn vq;\r\ndel_vq:\r\nvring_del_virtqueue(vq);\r\nunmap:\r\nmic_card_unmap(mvdev->mdev, mvdev->vr[index]);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int mic_find_vqs(struct virtio_device *vdev, unsigned nvqs,\r\nstruct virtqueue *vqs[],\r\nvq_callback_t *callbacks[],\r\nconst char *names[])\r\n{\r\nstruct mic_vdev *mvdev = to_micvdev(vdev);\r\nstruct mic_device_ctrl __iomem *dc = mvdev->dc;\r\nint i, err, retry;\r\nif (nvqs > ioread8(&mvdev->desc->num_vq))\r\nreturn -ENOENT;\r\nfor (i = 0; i < nvqs; ++i) {\r\ndev_dbg(mic_dev(mvdev), "%s: %d: %s\n",\r\n__func__, i, names[i]);\r\nvqs[i] = mic_find_vq(vdev, i, callbacks[i], names[i]);\r\nif (IS_ERR(vqs[i])) {\r\nerr = PTR_ERR(vqs[i]);\r\ngoto error;\r\n}\r\n}\r\niowrite8(1, &dc->used_address_updated);\r\nmic_send_intr(mvdev->mdev, mvdev->c2h_vdev_db);\r\nfor (retry = 100; retry--;) {\r\nif (!ioread8(&dc->used_address_updated))\r\nbreak;\r\nmsleep(100);\r\n};\r\ndev_dbg(mic_dev(mvdev), "%s: retry: %d\n", __func__, retry);\r\nif (!retry) {\r\nerr = -ENODEV;\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nmic_del_vqs(vdev);\r\nreturn err;\r\n}\r\nstatic irqreturn_t\r\nmic_virtio_intr_handler(int irq, void *data)\r\n{\r\nstruct mic_vdev *mvdev = data;\r\nstruct virtqueue *vq;\r\nmic_ack_interrupt(mvdev->mdev);\r\nlist_for_each_entry(vq, &mvdev->vdev.vqs, list)\r\nvring_interrupt(0, vq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mic_virtio_release_dev(struct device *_d)\r\n{\r\n}\r\nstatic int mic_add_device(struct mic_device_desc __iomem *d,\r\nunsigned int offset, struct mic_driver *mdrv)\r\n{\r\nstruct mic_vdev *mvdev;\r\nint ret;\r\nint virtio_db;\r\nu8 type = ioread8(&d->type);\r\nmvdev = kzalloc(sizeof(*mvdev), GFP_KERNEL);\r\nif (!mvdev) {\r\ndev_err(mdrv->dev, "Cannot allocate mic dev %u type %u\n",\r\noffset, type);\r\nreturn -ENOMEM;\r\n}\r\nmvdev->mdev = &mdrv->mdev;\r\nmvdev->vdev.dev.parent = mdrv->dev;\r\nmvdev->vdev.dev.release = mic_virtio_release_dev;\r\nmvdev->vdev.id.device = type;\r\nmvdev->vdev.config = &mic_vq_config_ops;\r\nmvdev->desc = d;\r\nmvdev->dc = (void __iomem *)d + mic_aligned_desc_size(d);\r\ninit_completion(&mvdev->reset_done);\r\nvirtio_db = mic_next_card_db();\r\nmvdev->virtio_cookie = mic_request_card_irq(mic_virtio_intr_handler,\r\nNULL, "virtio intr", mvdev, virtio_db);\r\nif (IS_ERR(mvdev->virtio_cookie)) {\r\nret = PTR_ERR(mvdev->virtio_cookie);\r\ngoto kfree;\r\n}\r\niowrite8((u8)virtio_db, &mvdev->dc->h2c_vdev_db);\r\nmvdev->c2h_vdev_db = ioread8(&mvdev->dc->c2h_vdev_db);\r\nret = register_virtio_device(&mvdev->vdev);\r\nif (ret) {\r\ndev_err(mic_dev(mvdev),\r\n"Failed to register mic device %u type %u\n",\r\noffset, type);\r\ngoto free_irq;\r\n}\r\niowrite64((u64)mvdev, &mvdev->dc->vdev);\r\ndev_dbg(mic_dev(mvdev), "%s: registered mic device %u type %u mvdev %p\n",\r\n__func__, offset, type, mvdev);\r\nreturn 0;\r\nfree_irq:\r\nmic_free_card_irq(mvdev->virtio_cookie, mvdev);\r\nkfree:\r\nkfree(mvdev);\r\nreturn ret;\r\n}\r\nstatic int mic_match_desc(struct device *dev, void *data)\r\n{\r\nstruct virtio_device *vdev = dev_to_virtio(dev);\r\nstruct mic_vdev *mvdev = to_micvdev(vdev);\r\nreturn mvdev->desc == (void __iomem *)data;\r\n}\r\nstatic void mic_handle_config_change(struct mic_device_desc __iomem *d,\r\nunsigned int offset, struct mic_driver *mdrv)\r\n{\r\nstruct mic_device_ctrl __iomem *dc\r\n= (void __iomem *)d + mic_aligned_desc_size(d);\r\nstruct mic_vdev *mvdev = (struct mic_vdev *)ioread64(&dc->vdev);\r\nif (ioread8(&dc->config_change) != MIC_VIRTIO_PARAM_CONFIG_CHANGED)\r\nreturn;\r\ndev_dbg(mdrv->dev, "%s %d\n", __func__, __LINE__);\r\nvirtio_config_changed(&mvdev->vdev);\r\niowrite8(1, &dc->guest_ack);\r\n}\r\nstatic int mic_remove_device(struct mic_device_desc __iomem *d,\r\nunsigned int offset, struct mic_driver *mdrv)\r\n{\r\nstruct mic_device_ctrl __iomem *dc\r\n= (void __iomem *)d + mic_aligned_desc_size(d);\r\nstruct mic_vdev *mvdev = (struct mic_vdev *)ioread64(&dc->vdev);\r\nu8 status;\r\nint ret = -1;\r\nif (ioread8(&dc->config_change) == MIC_VIRTIO_PARAM_DEV_REMOVE) {\r\ndev_dbg(mdrv->dev,\r\n"%s %d config_change %d type %d mvdev %p\n",\r\n__func__, __LINE__,\r\nioread8(&dc->config_change), ioread8(&d->type), mvdev);\r\nstatus = ioread8(&d->status);\r\nreinit_completion(&mvdev->reset_done);\r\nunregister_virtio_device(&mvdev->vdev);\r\nmic_free_card_irq(mvdev->virtio_cookie, mvdev);\r\nif (status & VIRTIO_CONFIG_S_DRIVER_OK)\r\nwait_for_completion(&mvdev->reset_done);\r\nkfree(mvdev);\r\niowrite8(1, &dc->guest_ack);\r\ndev_dbg(mdrv->dev, "%s %d guest_ack %d\n",\r\n__func__, __LINE__, ioread8(&dc->guest_ack));\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void mic_scan_devices(struct mic_driver *mdrv, bool remove)\r\n{\r\ns8 type;\r\nunsigned int i;\r\nstruct mic_device_desc __iomem *d;\r\nstruct mic_device_ctrl __iomem *dc;\r\nstruct device *dev;\r\nint ret;\r\nfor (i = sizeof(struct mic_bootparam); i < MIC_DP_SIZE;\r\ni += mic_total_desc_size(d)) {\r\nd = mdrv->dp + i;\r\ndc = (void __iomem *)d + mic_aligned_desc_size(d);\r\nrmb();\r\ntype = ioread8(&d->type);\r\nif (type == 0)\r\nbreak;\r\nif (type == -1)\r\ncontinue;\r\ndev = device_find_child(mdrv->dev, (void __force *)d,\r\nmic_match_desc);\r\nif (dev) {\r\nif (remove)\r\niowrite8(MIC_VIRTIO_PARAM_DEV_REMOVE,\r\n&dc->config_change);\r\nput_device(dev);\r\nmic_handle_config_change(d, i, mdrv);\r\nret = mic_remove_device(d, i, mdrv);\r\nif (!ret && !remove)\r\niowrite8(-1, &d->type);\r\nif (remove) {\r\niowrite8(0, &dc->config_change);\r\niowrite8(0, &dc->guest_ack);\r\n}\r\ncontinue;\r\n}\r\ndev_dbg(mdrv->dev, "%s %d Adding new virtio device %p\n",\r\n__func__, __LINE__, d);\r\nif (!remove)\r\nmic_add_device(d, i, mdrv);\r\n}\r\n}\r\nstatic void mic_hotplug_devices(struct work_struct *work)\r\n{\r\nstruct mic_driver *mdrv = container_of(work,\r\nstruct mic_driver, hotplug_work);\r\nmic_scan_devices(mdrv, !REMOVE_DEVICES);\r\n}\r\nstatic irqreturn_t\r\nmic_extint_handler(int irq, void *data)\r\n{\r\nstruct mic_driver *mdrv = (struct mic_driver *)data;\r\ndev_dbg(mdrv->dev, "%s %d hotplug work\n",\r\n__func__, __LINE__);\r\nmic_ack_interrupt(&mdrv->mdev);\r\nschedule_work(&mdrv->hotplug_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nint mic_devices_init(struct mic_driver *mdrv)\r\n{\r\nint rc;\r\nstruct mic_bootparam __iomem *bootparam;\r\nint config_db;\r\nINIT_WORK(&mdrv->hotplug_work, mic_hotplug_devices);\r\nmic_scan_devices(mdrv, !REMOVE_DEVICES);\r\nconfig_db = mic_next_card_db();\r\nvirtio_config_cookie = mic_request_card_irq(mic_extint_handler, NULL,\r\n"virtio_config_intr", mdrv,\r\nconfig_db);\r\nif (IS_ERR(virtio_config_cookie)) {\r\nrc = PTR_ERR(virtio_config_cookie);\r\ngoto exit;\r\n}\r\nbootparam = mdrv->dp;\r\niowrite8(config_db, &bootparam->h2c_config_db);\r\nreturn 0;\r\nexit:\r\nreturn rc;\r\n}\r\nvoid mic_devices_uninit(struct mic_driver *mdrv)\r\n{\r\nstruct mic_bootparam __iomem *bootparam = mdrv->dp;\r\niowrite8(-1, &bootparam->h2c_config_db);\r\nmic_free_card_irq(virtio_config_cookie, mdrv);\r\nflush_work(&mdrv->hotplug_work);\r\nmic_scan_devices(mdrv, REMOVE_DEVICES);\r\n}
