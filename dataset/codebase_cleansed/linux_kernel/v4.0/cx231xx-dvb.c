static inline void print_err_status(struct cx231xx *dev, int packet, int status)\r\n{\r\nchar *errmsg = "Unknown";\r\nswitch (status) {\r\ncase -ENOENT:\r\nerrmsg = "unlinked synchronuously";\r\nbreak;\r\ncase -ECONNRESET:\r\nerrmsg = "unlinked asynchronuously";\r\nbreak;\r\ncase -ENOSR:\r\nerrmsg = "Buffer error (overrun)";\r\nbreak;\r\ncase -EPIPE:\r\nerrmsg = "Stalled (device not responding)";\r\nbreak;\r\ncase -EOVERFLOW:\r\nerrmsg = "Babble (bad cable?)";\r\nbreak;\r\ncase -EPROTO:\r\nerrmsg = "Bit-stuff error (bad cable?)";\r\nbreak;\r\ncase -EILSEQ:\r\nerrmsg = "CRC/Timeout (could be anything)";\r\nbreak;\r\ncase -ETIME:\r\nerrmsg = "Device does not respond";\r\nbreak;\r\n}\r\nif (packet < 0) {\r\ndev_dbg(dev->dev,\r\n"URB status %d [%s].\n", status, errmsg);\r\n} else {\r\ndev_dbg(dev->dev,\r\n"URB packet %d, status %d [%s].\n",\r\npacket, status, errmsg);\r\n}\r\n}\r\nstatic inline int dvb_isoc_copy(struct cx231xx *dev, struct urb *urb)\r\n{\r\nint i;\r\nif (!dev)\r\nreturn 0;\r\nif (dev->state & DEV_DISCONNECTED)\r\nreturn 0;\r\nif (urb->status < 0) {\r\nprint_err_status(dev, -1, urb->status);\r\nif (urb->status == -ENOENT)\r\nreturn 0;\r\n}\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nint status = urb->iso_frame_desc[i].status;\r\nif (status < 0) {\r\nprint_err_status(dev, i, status);\r\nif (urb->iso_frame_desc[i].status != -EPROTO)\r\ncontinue;\r\n}\r\ndvb_dmx_swfilter(&dev->dvb->demux,\r\nurb->transfer_buffer +\r\nurb->iso_frame_desc[i].offset,\r\nurb->iso_frame_desc[i].actual_length);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int dvb_bulk_copy(struct cx231xx *dev, struct urb *urb)\r\n{\r\nif (!dev)\r\nreturn 0;\r\nif (dev->state & DEV_DISCONNECTED)\r\nreturn 0;\r\nif (urb->status < 0) {\r\nprint_err_status(dev, -1, urb->status);\r\nif (urb->status == -ENOENT)\r\nreturn 0;\r\n}\r\ndvb_dmx_swfilter(&dev->dvb->demux,\r\nurb->transfer_buffer, urb->actual_length);\r\nreturn 0;\r\n}\r\nstatic int start_streaming(struct cx231xx_dvb *dvb)\r\n{\r\nint rc;\r\nstruct cx231xx *dev = dvb->adapter.priv;\r\nif (dev->USE_ISO) {\r\ndev_dbg(dev->dev, "DVB transfer mode is ISO.\n");\r\ncx231xx_set_alt_setting(dev, INDEX_TS1, 4);\r\nrc = cx231xx_set_mode(dev, CX231XX_DIGITAL_MODE);\r\nif (rc < 0)\r\nreturn rc;\r\ndev->mode_tv = 1;\r\nreturn cx231xx_init_isoc(dev, CX231XX_DVB_MAX_PACKETS,\r\nCX231XX_DVB_NUM_BUFS,\r\ndev->ts1_mode.max_pkt_size,\r\ndvb_isoc_copy);\r\n} else {\r\ndev_dbg(dev->dev, "DVB transfer mode is BULK.\n");\r\ncx231xx_set_alt_setting(dev, INDEX_TS1, 0);\r\nrc = cx231xx_set_mode(dev, CX231XX_DIGITAL_MODE);\r\nif (rc < 0)\r\nreturn rc;\r\ndev->mode_tv = 1;\r\nreturn cx231xx_init_bulk(dev, CX231XX_DVB_MAX_PACKETS,\r\nCX231XX_DVB_NUM_BUFS,\r\ndev->ts1_mode.max_pkt_size,\r\ndvb_bulk_copy);\r\n}\r\n}\r\nstatic int stop_streaming(struct cx231xx_dvb *dvb)\r\n{\r\nstruct cx231xx *dev = dvb->adapter.priv;\r\nif (dev->USE_ISO)\r\ncx231xx_uninit_isoc(dev);\r\nelse\r\ncx231xx_uninit_bulk(dev);\r\ncx231xx_set_mode(dev, CX231XX_SUSPEND);\r\nreturn 0;\r\n}\r\nstatic int start_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct cx231xx_dvb *dvb = demux->priv;\r\nint rc, ret;\r\nif (!demux->dmx.frontend)\r\nreturn -EINVAL;\r\nmutex_lock(&dvb->lock);\r\ndvb->nfeeds++;\r\nrc = dvb->nfeeds;\r\nif (dvb->nfeeds == 1) {\r\nret = start_streaming(dvb);\r\nif (ret < 0)\r\nrc = ret;\r\n}\r\nmutex_unlock(&dvb->lock);\r\nreturn rc;\r\n}\r\nstatic int stop_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct cx231xx_dvb *dvb = demux->priv;\r\nint err = 0;\r\nmutex_lock(&dvb->lock);\r\ndvb->nfeeds--;\r\nif (0 == dvb->nfeeds)\r\nerr = stop_streaming(dvb);\r\nmutex_unlock(&dvb->lock);\r\nreturn err;\r\n}\r\nstatic int cx231xx_dvb_bus_ctrl(struct dvb_frontend *fe, int acquire)\r\n{\r\nstruct cx231xx *dev = fe->dvb->priv;\r\nif (acquire)\r\nreturn cx231xx_set_mode(dev, CX231XX_DIGITAL_MODE);\r\nelse\r\nreturn cx231xx_set_mode(dev, CX231XX_SUSPEND);\r\n}\r\nint cx231xx_set_analog_freq(struct cx231xx *dev, u32 freq)\r\n{\r\nif ((dev->dvb != NULL) && (dev->dvb->frontend != NULL)) {\r\nstruct dvb_tuner_ops *dops = &dev->dvb->frontend->ops.tuner_ops;\r\nif (dops->set_analog_params != NULL) {\r\nstruct analog_parameters params;\r\nparams.frequency = freq;\r\nparams.std = dev->norm;\r\nparams.mode = 0;\r\ndops->set_analog_params(dev->dvb->frontend, &params);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint cx231xx_reset_analog_tuner(struct cx231xx *dev)\r\n{\r\nint status = 0;\r\nif ((dev->dvb != NULL) && (dev->dvb->frontend != NULL)) {\r\nstruct dvb_tuner_ops *dops = &dev->dvb->frontend->ops.tuner_ops;\r\nif (dops->init != NULL && !dev->xc_fw_load_done) {\r\ndev_dbg(dev->dev,\r\n"Reloading firmware for XC5000\n");\r\nstatus = dops->init(dev->dvb->frontend);\r\nif (status == 0) {\r\ndev->xc_fw_load_done = 1;\r\ndev_dbg(dev->dev,\r\n"XC5000 firmware download completed\n");\r\n} else {\r\ndev->xc_fw_load_done = 0;\r\ndev_dbg(dev->dev,\r\n"XC5000 firmware download failed !!!\n");\r\n}\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int register_dvb(struct cx231xx_dvb *dvb,\r\nstruct module *module,\r\nstruct cx231xx *dev, struct device *device)\r\n{\r\nint result;\r\nmutex_init(&dvb->lock);\r\nresult = dvb_register_adapter(&dvb->adapter, dev->name, module, device,\r\nadapter_nr);\r\nif (result < 0) {\r\ndev_warn(dev->dev,\r\n"%s: dvb_register_adapter failed (errno = %d)\n",\r\ndev->name, result);\r\ngoto fail_adapter;\r\n}\r\ndvb->frontend->ops.ts_bus_ctrl = cx231xx_dvb_bus_ctrl;\r\ndvb->adapter.priv = dev;\r\nresult = dvb_register_frontend(&dvb->adapter, dvb->frontend);\r\nif (result < 0) {\r\ndev_warn(dev->dev,\r\n"%s: dvb_register_frontend failed (errno = %d)\n",\r\ndev->name, result);\r\ngoto fail_frontend;\r\n}\r\ndvb->demux.dmx.capabilities =\r\nDMX_TS_FILTERING | DMX_SECTION_FILTERING |\r\nDMX_MEMORY_BASED_FILTERING;\r\ndvb->demux.priv = dvb;\r\ndvb->demux.filternum = 256;\r\ndvb->demux.feednum = 256;\r\ndvb->demux.start_feed = start_feed;\r\ndvb->demux.stop_feed = stop_feed;\r\nresult = dvb_dmx_init(&dvb->demux);\r\nif (result < 0) {\r\ndev_warn(dev->dev,\r\n"%s: dvb_dmx_init failed (errno = %d)\n",\r\ndev->name, result);\r\ngoto fail_dmx;\r\n}\r\ndvb->dmxdev.filternum = 256;\r\ndvb->dmxdev.demux = &dvb->demux.dmx;\r\ndvb->dmxdev.capabilities = 0;\r\nresult = dvb_dmxdev_init(&dvb->dmxdev, &dvb->adapter);\r\nif (result < 0) {\r\ndev_warn(dev->dev,\r\n"%s: dvb_dmxdev_init failed (errno = %d)\n",\r\ndev->name, result);\r\ngoto fail_dmxdev;\r\n}\r\ndvb->fe_hw.source = DMX_FRONTEND_0;\r\nresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\nif (result < 0) {\r\ndev_warn(dev->dev,\r\n"%s: add_frontend failed (DMX_FRONTEND_0, errno = %d)\n",\r\ndev->name, result);\r\ngoto fail_fe_hw;\r\n}\r\ndvb->fe_mem.source = DMX_MEMORY_FE;\r\nresult = dvb->demux.dmx.add_frontend(&dvb->demux.dmx, &dvb->fe_mem);\r\nif (result < 0) {\r\ndev_warn(dev->dev,\r\n"%s: add_frontend failed (DMX_MEMORY_FE, errno = %d)\n",\r\ndev->name, result);\r\ngoto fail_fe_mem;\r\n}\r\nresult = dvb->demux.dmx.connect_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\nif (result < 0) {\r\ndev_warn(dev->dev,\r\n"%s: connect_frontend failed (errno = %d)\n",\r\ndev->name, result);\r\ngoto fail_fe_conn;\r\n}\r\ndvb_net_init(&dvb->adapter, &dvb->net, &dvb->demux.dmx);\r\nreturn 0;\r\nfail_fe_conn:\r\ndvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);\r\nfail_fe_mem:\r\ndvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\nfail_fe_hw:\r\ndvb_dmxdev_release(&dvb->dmxdev);\r\nfail_dmxdev:\r\ndvb_dmx_release(&dvb->demux);\r\nfail_dmx:\r\ndvb_unregister_frontend(dvb->frontend);\r\nfail_frontend:\r\ndvb_frontend_detach(dvb->frontend);\r\ndvb_unregister_adapter(&dvb->adapter);\r\nfail_adapter:\r\nreturn result;\r\n}\r\nstatic void unregister_dvb(struct cx231xx_dvb *dvb)\r\n{\r\nstruct i2c_client *client;\r\ndvb_net_release(&dvb->net);\r\ndvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_mem);\r\ndvb->demux.dmx.remove_frontend(&dvb->demux.dmx, &dvb->fe_hw);\r\ndvb_dmxdev_release(&dvb->dmxdev);\r\ndvb_dmx_release(&dvb->demux);\r\nclient = dvb->i2c_client_tuner;\r\nif (client) {\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\n}\r\ndvb_unregister_frontend(dvb->frontend);\r\ndvb_frontend_detach(dvb->frontend);\r\ndvb_unregister_adapter(&dvb->adapter);\r\n}\r\nstatic int dvb_init(struct cx231xx *dev)\r\n{\r\nint result = 0;\r\nstruct cx231xx_dvb *dvb;\r\nstruct i2c_adapter *tuner_i2c;\r\nstruct i2c_adapter *demod_i2c;\r\nif (!dev->board.has_dvb) {\r\nreturn 0;\r\n}\r\ndvb = kzalloc(sizeof(struct cx231xx_dvb), GFP_KERNEL);\r\nif (dvb == NULL) {\r\ndev_info(dev->dev,\r\n"cx231xx_dvb: memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->dvb = dvb;\r\ndev->cx231xx_set_analog_freq = cx231xx_set_analog_freq;\r\ndev->cx231xx_reset_analog_tuner = cx231xx_reset_analog_tuner;\r\ntuner_i2c = cx231xx_get_i2c_adap(dev, dev->board.tuner_i2c_master);\r\ndemod_i2c = cx231xx_get_i2c_adap(dev, dev->board.demod_i2c_master);\r\nmutex_lock(&dev->lock);\r\ncx231xx_set_mode(dev, CX231XX_DIGITAL_MODE);\r\ncx231xx_demod_reset(dev);\r\nswitch (dev->model) {\r\ncase CX231XX_BOARD_CNXT_CARRAERA:\r\ncase CX231XX_BOARD_CNXT_RDE_250:\r\ndev->dvb->frontend = dvb_attach(s5h1432_attach,\r\n&dvico_s5h1432_config,\r\ndemod_i2c);\r\nif (dev->dvb->frontend == NULL) {\r\ndev_err(dev->dev,\r\n"Failed to attach s5h1432 front end\n");\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\ndvb->frontend->callback = cx231xx_tuner_callback;\r\nif (!dvb_attach(xc5000_attach, dev->dvb->frontend,\r\ntuner_i2c,\r\n&cnxt_rde250_tunerconfig)) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nbreak;\r\ncase CX231XX_BOARD_CNXT_SHELBY:\r\ncase CX231XX_BOARD_CNXT_RDU_250:\r\ndev->dvb->frontend = dvb_attach(s5h1411_attach,\r\n&xc5000_s5h1411_config,\r\ndemod_i2c);\r\nif (dev->dvb->frontend == NULL) {\r\ndev_err(dev->dev,\r\n"Failed to attach s5h1411 front end\n");\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\ndvb->frontend->callback = cx231xx_tuner_callback;\r\nif (!dvb_attach(xc5000_attach, dev->dvb->frontend,\r\ntuner_i2c,\r\n&cnxt_rdu250_tunerconfig)) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nbreak;\r\ncase CX231XX_BOARD_CNXT_RDE_253S:\r\ndev->dvb->frontend = dvb_attach(s5h1432_attach,\r\n&dvico_s5h1432_config,\r\ndemod_i2c);\r\nif (dev->dvb->frontend == NULL) {\r\ndev_err(dev->dev,\r\n"Failed to attach s5h1432 front end\n");\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\ndvb->frontend->callback = cx231xx_tuner_callback;\r\nif (!dvb_attach(tda18271_attach, dev->dvb->frontend,\r\n0x60, tuner_i2c,\r\n&cnxt_rde253s_tunerconfig)) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nbreak;\r\ncase CX231XX_BOARD_CNXT_RDU_253S:\r\ncase CX231XX_BOARD_KWORLD_UB445_USB_HYBRID:\r\ndev->dvb->frontend = dvb_attach(s5h1411_attach,\r\n&tda18271_s5h1411_config,\r\ndemod_i2c);\r\nif (dev->dvb->frontend == NULL) {\r\ndev_err(dev->dev,\r\n"Failed to attach s5h1411 front end\n");\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\ndvb->frontend->callback = cx231xx_tuner_callback;\r\nif (!dvb_attach(tda18271_attach, dev->dvb->frontend,\r\n0x60, tuner_i2c,\r\n&cnxt_rde253s_tunerconfig)) {\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nbreak;\r\ncase CX231XX_BOARD_HAUPPAUGE_EXETER:\r\ndev_info(dev->dev,\r\n"%s: looking for tuner / demod on i2c bus: %d\n",\r\n__func__, i2c_adapter_id(tuner_i2c));\r\ndev->dvb->frontend = dvb_attach(lgdt3305_attach,\r\n&hcw_lgdt3305_config,\r\ntuner_i2c);\r\nif (dev->dvb->frontend == NULL) {\r\ndev_err(dev->dev,\r\n"Failed to attach LG3305 front end\n");\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\ndvb->frontend->callback = cx231xx_tuner_callback;\r\ndvb_attach(tda18271_attach, dev->dvb->frontend,\r\n0x60, tuner_i2c,\r\n&hcw_tda18271_config);\r\nbreak;\r\ncase CX231XX_BOARD_HAUPPAUGE_930C_HD_1113xx:\r\ndev->dvb->frontend = dvb_attach(si2165_attach,\r\n&hauppauge_930C_HD_1113xx_si2165_config,\r\ntuner_i2c\r\n);\r\nif (dev->dvb->frontend == NULL) {\r\ndev_err(dev->dev,\r\n"Failed to attach SI2165 front end\n");\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\ndev->dvb->frontend->ops.i2c_gate_ctrl = NULL;\r\ndvb->frontend->callback = cx231xx_tuner_callback;\r\ndvb_attach(tda18271_attach, dev->dvb->frontend,\r\n0x60,\r\ntuner_i2c,\r\n&hcw_tda18271_config);\r\ndev->cx231xx_reset_analog_tuner = NULL;\r\nbreak;\r\ncase CX231XX_BOARD_HAUPPAUGE_930C_HD_1114xx:\r\n{\r\nstruct i2c_client *client;\r\nstruct i2c_board_info info;\r\nstruct si2157_config si2157_config;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\ndev->dvb->frontend = dvb_attach(si2165_attach,\r\n&pctv_quatro_stick_1114xx_si2165_config,\r\ntuner_i2c\r\n);\r\nif (dev->dvb->frontend == NULL) {\r\ndev_err(dev->dev,\r\n"Failed to attach SI2165 front end\n");\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\ndev->dvb->frontend->ops.i2c_gate_ctrl = NULL;\r\ndvb->frontend->callback = cx231xx_tuner_callback;\r\nmemset(&si2157_config, 0, sizeof(si2157_config));\r\nsi2157_config.fe = dev->dvb->frontend;\r\nsi2157_config.inversion = true;\r\nstrlcpy(info.type, "si2157", I2C_NAME_SIZE);\r\ninfo.addr = 0x60;\r\ninfo.platform_data = &si2157_config;\r\nrequest_module("si2157");\r\nclient = i2c_new_device(\r\ntuner_i2c,\r\n&info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\ndvb_frontend_detach(dev->dvb->frontend);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\ndvb_frontend_detach(dev->dvb->frontend);\r\nresult = -ENODEV;\r\ngoto out_free;\r\n}\r\ndev->cx231xx_reset_analog_tuner = NULL;\r\ndev->dvb->i2c_client_tuner = client;\r\nbreak;\r\n}\r\ncase CX231XX_BOARD_PV_PLAYTV_USB_HYBRID:\r\ncase CX231XX_BOARD_KWORLD_UB430_USB_HYBRID:\r\ndev_info(dev->dev,\r\n"%s: looking for demod on i2c bus: %d\n",\r\n__func__, i2c_adapter_id(tuner_i2c));\r\ndev->dvb->frontend = dvb_attach(mb86a20s_attach,\r\n&pv_mb86a20s_config,\r\ndemod_i2c);\r\nif (dev->dvb->frontend == NULL) {\r\ndev_err(dev->dev,\r\n"Failed to attach mb86a20s demod\n");\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\ndvb->frontend->callback = cx231xx_tuner_callback;\r\ndvb_attach(tda18271_attach, dev->dvb->frontend,\r\n0x60, tuner_i2c,\r\n&pv_tda18271_config);\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev,\r\n"%s/2: The frontend of your DVB/ATSC card isn't supported yet\n",\r\ndev->name);\r\nbreak;\r\n}\r\nif (NULL == dvb->frontend) {\r\ndev_err(dev->dev,\r\n"%s/2: frontend initialization failed\n", dev->name);\r\nresult = -EINVAL;\r\ngoto out_free;\r\n}\r\nresult = register_dvb(dvb, THIS_MODULE, dev, dev->dev);\r\nif (result < 0)\r\ngoto out_free;\r\ndev_info(dev->dev, "Successfully loaded cx231xx-dvb\n");\r\nret:\r\ncx231xx_set_mode(dev, CX231XX_SUSPEND);\r\nmutex_unlock(&dev->lock);\r\nreturn result;\r\nout_free:\r\nkfree(dvb);\r\ndev->dvb = NULL;\r\ngoto ret;\r\n}\r\nstatic int dvb_fini(struct cx231xx *dev)\r\n{\r\nif (!dev->board.has_dvb) {\r\nreturn 0;\r\n}\r\nif (dev->dvb) {\r\nunregister_dvb(dev->dvb);\r\ndev->dvb = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init cx231xx_dvb_register(void)\r\n{\r\nreturn cx231xx_register_extension(&dvb_ops);\r\n}\r\nstatic void __exit cx231xx_dvb_unregister(void)\r\n{\r\ncx231xx_unregister_extension(&dvb_ops);\r\n}
