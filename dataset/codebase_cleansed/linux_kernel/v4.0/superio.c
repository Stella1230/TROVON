static irqreturn_t\r\nsuperio_interrupt(int parent_irq, void *devp)\r\n{\r\nu8 results;\r\nu8 local_irq;\r\noutb (OCW3_POLL,IC_PIC1+0);\r\nresults = inb(IC_PIC1+0);\r\nif ((results & 0x80) == 0) {\r\nreturn IRQ_NONE;\r\n}\r\nlocal_irq = results & 0x0f;\r\nif (local_irq == 2 || local_irq > 7) {\r\nprintk(KERN_ERR PFX "slave interrupted!\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (local_irq == 7) {\r\noutb(OCW3_ISR,IC_PIC1+0);\r\nresults = inb(IC_PIC1+0);\r\nif ((results & 0x80) == 0) {\r\nprintk(KERN_WARNING PFX "spurious interrupt!\n");\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\ngeneric_handle_irq(local_irq);\r\noutb((OCW2_SEOI|local_irq),IC_PIC1 + 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nsuperio_init(struct pci_dev *pcidev)\r\n{\r\nstruct superio_device *sio = &sio_dev;\r\nstruct pci_dev *pdev = sio->lio_pdev;\r\nu16 word;\r\nint ret;\r\nif (sio->suckyio_irq_enabled)\r\nreturn;\r\nBUG_ON(!pdev);\r\nBUG_ON(!sio->usb_pdev);\r\npdev->irq = sio->usb_pdev->irq;\r\nsio->usb_pdev->irq = superio_fixup_irq(sio->usb_pdev);\r\nprintk(KERN_INFO PFX "Found NS87560 Legacy I/O device at %s (IRQ %i)\n",\r\npci_name(pdev), pdev->irq);\r\npci_read_config_dword (pdev, SIO_SP1BAR, &sio->sp1_base);\r\nsio->sp1_base &= ~1;\r\nprintk(KERN_INFO PFX "Serial port 1 at 0x%x\n", sio->sp1_base);\r\npci_read_config_dword (pdev, SIO_SP2BAR, &sio->sp2_base);\r\nsio->sp2_base &= ~1;\r\nprintk(KERN_INFO PFX "Serial port 2 at 0x%x\n", sio->sp2_base);\r\npci_read_config_dword (pdev, SIO_PPBAR, &sio->pp_base);\r\nsio->pp_base &= ~1;\r\nprintk(KERN_INFO PFX "Parallel port at 0x%x\n", sio->pp_base);\r\npci_read_config_dword (pdev, SIO_FDCBAR, &sio->fdc_base);\r\nsio->fdc_base &= ~1;\r\nprintk(KERN_INFO PFX "Floppy controller at 0x%x\n", sio->fdc_base);\r\npci_read_config_dword (pdev, SIO_ACPIBAR, &sio->acpi_base);\r\nsio->acpi_base &= ~1;\r\nprintk(KERN_INFO PFX "ACPI at 0x%x\n", sio->acpi_base);\r\nrequest_region (IC_PIC1, 0x1f, "pic1");\r\nrequest_region (IC_PIC2, 0x1f, "pic2");\r\nrequest_region (sio->acpi_base, 0x1f, "acpi");\r\npci_read_config_word (pdev, PCI_COMMAND, &word);\r\nword |= PCI_COMMAND_SERR | PCI_COMMAND_PARITY | PCI_COMMAND_IO;\r\npci_write_config_word (pdev, PCI_COMMAND, word);\r\npci_set_master (pdev);\r\nret = pci_enable_device(pdev);\r\nBUG_ON(ret < 0);\r\npci_write_config_dword (pdev, 0x64, 0x82000000U);\r\npci_write_config_dword (pdev, TRIGGER_2, 0x07654300U);\r\npci_write_config_dword (pdev, CFG_IR_INTAB, 0x00001000U);\r\npci_write_config_dword (pdev, CFG_IR_USB, 0x4c880000U);\r\noutb (0x11,IC_PIC1+0);\r\noutb (0x00,IC_PIC1+1);\r\noutb (0x04,IC_PIC1+1);\r\noutb (0x01,IC_PIC1+1);\r\noutb (0xff,IC_PIC1+1);\r\noutb (0xc2,IC_PIC1+0);\r\noutb (0x11,IC_PIC2+0);\r\noutb (0x00,IC_PIC2+1);\r\noutb (0x02,IC_PIC2+1);\r\noutb (0x01,IC_PIC2+1);\r\noutb (0xff,IC_PIC1+1);\r\noutb (0x68,IC_PIC1+0);\r\noutb (0xff,IC_PIC1+1);\r\noutb(1, sio->acpi_base + USB_REG_CR);\r\nif (inb(sio->acpi_base + USB_REG_CR) & 1)\r\nprintk(KERN_INFO PFX "USB regulator enabled\n");\r\nelse\r\nprintk(KERN_ERR PFX "USB regulator not initialized!\n");\r\nif (request_irq(pdev->irq, superio_interrupt, 0,\r\nSUPERIO, (void *)sio)) {\r\nprintk(KERN_ERR PFX "could not get irq\n");\r\nBUG();\r\nreturn;\r\n}\r\nsio->suckyio_irq_enabled = 1;\r\n}\r\nstatic void superio_mask_irq(struct irq_data *d)\r\n{\r\nunsigned int irq = d->irq;\r\nu8 r8;\r\nif ((irq < 1) || (irq == 2) || (irq > 7)) {\r\nprintk(KERN_ERR PFX "Illegal irq number.\n");\r\nBUG();\r\nreturn;\r\n}\r\nr8 = inb(IC_PIC1+1);\r\nr8 |= (1 << irq);\r\noutb (r8,IC_PIC1+1);\r\n}\r\nstatic void superio_unmask_irq(struct irq_data *d)\r\n{\r\nunsigned int irq = d->irq;\r\nu8 r8;\r\nif ((irq < 1) || (irq == 2) || (irq > 7)) {\r\nprintk(KERN_ERR PFX "Illegal irq number (%d).\n", irq);\r\nBUG();\r\nreturn;\r\n}\r\nr8 = inb(IC_PIC1+1);\r\nr8 &= ~(1 << irq);\r\noutb (r8,IC_PIC1+1);\r\n}\r\nint superio_fixup_irq(struct pci_dev *pcidev)\r\n{\r\nint local_irq, i;\r\n#ifdef DEBUG_SUPERIO_INIT\r\nint fn;\r\nfn = PCI_FUNC(pcidev->devfn);\r\nif (expected_device[fn] != pcidev->device) {\r\nBUG();\r\nreturn -1;\r\n}\r\nprintk("superio_fixup_irq(%s) ven 0x%x dev 0x%x from %pf\n",\r\npci_name(pcidev),\r\npcidev->vendor, pcidev->device,\r\n__builtin_return_address(0));\r\n#endif\r\nfor (i = 0; i < 16; i++) {\r\nirq_set_chip_and_handler(i, &superio_interrupt_type,\r\nhandle_simple_irq);\r\n}\r\nswitch(pcidev->device) {\r\ncase PCI_DEVICE_ID_NS_87415:\r\nlocal_irq = IDE_IRQ;\r\nbreak;\r\ncase PCI_DEVICE_ID_NS_87560_LIO:\r\nsio_dev.lio_pdev = pcidev;\r\nreturn -1;\r\ncase PCI_DEVICE_ID_NS_87560_USB:\r\nsio_dev.usb_pdev = pcidev;\r\nlocal_irq = USB_IRQ;\r\nbreak;\r\ndefault:\r\nlocal_irq = -1;\r\nBUG();\r\nbreak;\r\n}\r\nreturn local_irq;\r\n}\r\nstatic void __init superio_serial_init(void)\r\n{\r\n#ifdef CONFIG_SERIAL_8250\r\nint retval;\r\nstruct uart_port serial_port;\r\nmemset(&serial_port, 0, sizeof(serial_port));\r\nserial_port.iotype = UPIO_PORT;\r\nserial_port.type = PORT_16550A;\r\nserial_port.uartclk = 115200*16;\r\nserial_port.flags = UPF_FIXED_PORT | UPF_FIXED_TYPE |\r\nUPF_BOOT_AUTOCONF;\r\nserial_port.iobase = sio_dev.sp1_base;\r\nserial_port.irq = SP1_IRQ;\r\nserial_port.line = 0;\r\nretval = early_serial_setup(&serial_port);\r\nif (retval < 0) {\r\nprintk(KERN_WARNING PFX "Register Serial #0 failed.\n");\r\nreturn;\r\n}\r\nserial_port.iobase = sio_dev.sp2_base;\r\nserial_port.irq = SP2_IRQ;\r\nserial_port.line = 1;\r\nretval = early_serial_setup(&serial_port);\r\nif (retval < 0)\r\nprintk(KERN_WARNING PFX "Register Serial #1 failed.\n");\r\n#endif\r\n}\r\nstatic void __init superio_parport_init(void)\r\n{\r\n#ifdef CONFIG_PARPORT_PC\r\nif (!parport_pc_probe_port(sio_dev.pp_base,\r\n0 ,\r\nPAR_IRQ,\r\nPARPORT_DMA_NONE ,\r\nNULL ,\r\n0 ))\r\nprintk(KERN_WARNING PFX "Probing parallel port failed.\n");\r\n#endif\r\n}\r\nstatic void superio_fixup_pci(struct pci_dev *pdev)\r\n{\r\nu8 prog;\r\npdev->class |= 0x5;\r\npci_write_config_byte(pdev, PCI_CLASS_PROG, pdev->class);\r\npci_read_config_byte(pdev, PCI_CLASS_PROG, &prog);\r\nprintk("PCI: Enabled native mode for NS87415 (pif=0x%x)\n", prog);\r\n}\r\nstatic int __init\r\nsuperio_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstruct superio_device *sio = &sio_dev;\r\nDBG_INIT("superio_probe(%s) ven 0x%x dev 0x%x sv 0x%x sd 0x%x class 0x%x\n",\r\npci_name(dev),\r\ndev->vendor, dev->device,\r\ndev->subsystem_vendor, dev->subsystem_device,\r\ndev->class);\r\nBUG_ON(!sio->suckyio_irq_enabled);\r\nif (dev->device == PCI_DEVICE_ID_NS_87560_LIO) {\r\nsuperio_parport_init();\r\nsuperio_serial_init();\r\nreturn 0;\r\n} else if (dev->device == PCI_DEVICE_ID_NS_87415) {\r\nDBG_INIT("superio_probe: ignoring IDE 87415\n");\r\n} else if (dev->device == PCI_DEVICE_ID_NS_87560_USB) {\r\nDBG_INIT("superio_probe: ignoring USB OHCI controller\n");\r\n} else {\r\nDBG_INIT("superio_probe: WTF? Fire Extinguisher?\n");\r\n}\r\nreturn -ENODEV;\r\n}
