static struct integrity_iint_cache *__integrity_iint_find(struct inode *inode)\r\n{\r\nstruct integrity_iint_cache *iint;\r\nstruct rb_node *n = integrity_iint_tree.rb_node;\r\nwhile (n) {\r\niint = rb_entry(n, struct integrity_iint_cache, rb_node);\r\nif (inode < iint->inode)\r\nn = n->rb_left;\r\nelse if (inode > iint->inode)\r\nn = n->rb_right;\r\nelse\r\nbreak;\r\n}\r\nif (!n)\r\nreturn NULL;\r\nreturn iint;\r\n}\r\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode)\r\n{\r\nstruct integrity_iint_cache *iint;\r\nif (!IS_IMA(inode))\r\nreturn NULL;\r\nread_lock(&integrity_iint_lock);\r\niint = __integrity_iint_find(inode);\r\nread_unlock(&integrity_iint_lock);\r\nreturn iint;\r\n}\r\nstatic void iint_free(struct integrity_iint_cache *iint)\r\n{\r\nkfree(iint->ima_hash);\r\niint->ima_hash = NULL;\r\niint->version = 0;\r\niint->flags = 0UL;\r\niint->ima_file_status = INTEGRITY_UNKNOWN;\r\niint->ima_mmap_status = INTEGRITY_UNKNOWN;\r\niint->ima_bprm_status = INTEGRITY_UNKNOWN;\r\niint->ima_module_status = INTEGRITY_UNKNOWN;\r\niint->evm_status = INTEGRITY_UNKNOWN;\r\nkmem_cache_free(iint_cache, iint);\r\n}\r\nstruct integrity_iint_cache *integrity_inode_get(struct inode *inode)\r\n{\r\nstruct rb_node **p;\r\nstruct rb_node *node, *parent = NULL;\r\nstruct integrity_iint_cache *iint, *test_iint;\r\niint = integrity_iint_find(inode);\r\nif (iint)\r\nreturn iint;\r\niint = kmem_cache_alloc(iint_cache, GFP_NOFS);\r\nif (!iint)\r\nreturn NULL;\r\nwrite_lock(&integrity_iint_lock);\r\np = &integrity_iint_tree.rb_node;\r\nwhile (*p) {\r\nparent = *p;\r\ntest_iint = rb_entry(parent, struct integrity_iint_cache,\r\nrb_node);\r\nif (inode < test_iint->inode)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\niint->inode = inode;\r\nnode = &iint->rb_node;\r\ninode->i_flags |= S_IMA;\r\nrb_link_node(node, parent, p);\r\nrb_insert_color(node, &integrity_iint_tree);\r\nwrite_unlock(&integrity_iint_lock);\r\nreturn iint;\r\n}\r\nvoid integrity_inode_free(struct inode *inode)\r\n{\r\nstruct integrity_iint_cache *iint;\r\nif (!IS_IMA(inode))\r\nreturn;\r\nwrite_lock(&integrity_iint_lock);\r\niint = __integrity_iint_find(inode);\r\nrb_erase(&iint->rb_node, &integrity_iint_tree);\r\nwrite_unlock(&integrity_iint_lock);\r\niint_free(iint);\r\n}\r\nstatic void init_once(void *foo)\r\n{\r\nstruct integrity_iint_cache *iint = foo;\r\nmemset(iint, 0, sizeof(*iint));\r\niint->version = 0;\r\niint->flags = 0UL;\r\niint->ima_file_status = INTEGRITY_UNKNOWN;\r\niint->ima_mmap_status = INTEGRITY_UNKNOWN;\r\niint->ima_bprm_status = INTEGRITY_UNKNOWN;\r\niint->ima_module_status = INTEGRITY_UNKNOWN;\r\niint->evm_status = INTEGRITY_UNKNOWN;\r\n}\r\nstatic int __init integrity_iintcache_init(void)\r\n{\r\niint_cache =\r\nkmem_cache_create("iint_cache", sizeof(struct integrity_iint_cache),\r\n0, SLAB_PANIC, init_once);\r\nreturn 0;\r\n}\r\nint integrity_kernel_read(struct file *file, loff_t offset,\r\nchar *addr, unsigned long count)\r\n{\r\nmm_segment_t old_fs;\r\nchar __user *buf = (char __user *)addr;\r\nssize_t ret;\r\nif (!(file->f_mode & FMODE_READ))\r\nreturn -EBADF;\r\nold_fs = get_fs();\r\nset_fs(get_ds());\r\nret = __vfs_read(file, buf, count, &offset);\r\nset_fs(old_fs);\r\nreturn ret;\r\n}\r\nint __init integrity_read_file(const char *path, char **data)\r\n{\r\nstruct file *file;\r\nloff_t size;\r\nchar *buf;\r\nint rc = -EINVAL;\r\nfile = filp_open(path, O_RDONLY, 0);\r\nif (IS_ERR(file)) {\r\nrc = PTR_ERR(file);\r\npr_err("Unable to open file: %s (%d)", path, rc);\r\nreturn rc;\r\n}\r\nsize = i_size_read(file_inode(file));\r\nif (size <= 0)\r\ngoto out;\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (!buf) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nrc = integrity_kernel_read(file, 0, buf, size);\r\nif (rc < 0)\r\nkfree(buf);\r\nelse if (rc != size)\r\nrc = -EIO;\r\nelse\r\n*data = buf;\r\nout:\r\nfput(file);\r\nreturn rc;\r\n}\r\nvoid __init integrity_load_keys(void)\r\n{\r\nima_load_x509();\r\n}
