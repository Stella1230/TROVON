static void wm8776_write_spi(struct oxygen *chip,\r\nunsigned int reg, unsigned int value)\r\n{\r\noxygen_write_spi(chip, OXYGEN_SPI_TRIGGER |\r\nOXYGEN_SPI_DATA_LENGTH_2 |\r\nOXYGEN_SPI_CLOCK_160 |\r\n(1 << OXYGEN_SPI_CODEC_SHIFT) |\r\nOXYGEN_SPI_CEN_LATCH_CLOCK_LO,\r\n(reg << 9) | value);\r\n}\r\nstatic void wm8776_write_i2c(struct oxygen *chip,\r\nunsigned int reg, unsigned int value)\r\n{\r\noxygen_write_i2c(chip, I2C_DEVICE_WM8776,\r\n(reg << 1) | (value >> 8), value);\r\n}\r\nstatic void wm8776_write(struct oxygen *chip,\r\nunsigned int reg, unsigned int value)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nif ((chip->model.function_flags & OXYGEN_FUNCTION_2WIRE_SPI_MASK) ==\r\nOXYGEN_FUNCTION_SPI)\r\nwm8776_write_spi(chip, reg, value);\r\nelse\r\nwm8776_write_i2c(chip, reg, value);\r\nif (reg < ARRAY_SIZE(data->wm8776_regs)) {\r\nif (reg >= WM8776_HPLVOL && reg <= WM8776_DACMASTER)\r\nvalue &= ~WM8776_UPDATE;\r\ndata->wm8776_regs[reg] = value;\r\n}\r\n}\r\nstatic void wm8776_write_cached(struct oxygen *chip,\r\nunsigned int reg, unsigned int value)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nif (reg >= ARRAY_SIZE(data->wm8776_regs) ||\r\nvalue != data->wm8776_regs[reg])\r\nwm8776_write(chip, reg, value);\r\n}\r\nstatic void wm8766_write(struct oxygen *chip,\r\nunsigned int reg, unsigned int value)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\noxygen_write_spi(chip, OXYGEN_SPI_TRIGGER |\r\nOXYGEN_SPI_DATA_LENGTH_2 |\r\nOXYGEN_SPI_CLOCK_160 |\r\n(0 << OXYGEN_SPI_CODEC_SHIFT) |\r\nOXYGEN_SPI_CEN_LATCH_CLOCK_LO,\r\n(reg << 9) | value);\r\nif (reg < ARRAY_SIZE(data->wm8766_regs)) {\r\nif ((reg >= WM8766_LDA1 && reg <= WM8766_RDA1) ||\r\n(reg >= WM8766_LDA2 && reg <= WM8766_MASTDA))\r\nvalue &= ~WM8766_UPDATE;\r\ndata->wm8766_regs[reg] = value;\r\n}\r\n}\r\nstatic void wm8766_write_cached(struct oxygen *chip,\r\nunsigned int reg, unsigned int value)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nif (reg >= ARRAY_SIZE(data->wm8766_regs) ||\r\nvalue != data->wm8766_regs[reg])\r\nwm8766_write(chip, reg, value);\r\n}\r\nstatic void wm8776_registers_init(struct oxygen *chip)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nwm8776_write(chip, WM8776_RESET, 0);\r\nwm8776_write(chip, WM8776_PHASESWAP, WM8776_PH_MASK);\r\nwm8776_write(chip, WM8776_DACCTRL1, WM8776_DZCEN |\r\nWM8776_PL_LEFT_LEFT | WM8776_PL_RIGHT_RIGHT);\r\nwm8776_write(chip, WM8776_DACMUTE, chip->dac_mute ? WM8776_DMUTE : 0);\r\nwm8776_write(chip, WM8776_DACIFCTRL,\r\nWM8776_DACFMT_LJUST | WM8776_DACWL_24);\r\nwm8776_write(chip, WM8776_ADCIFCTRL,\r\ndata->wm8776_regs[WM8776_ADCIFCTRL]);\r\nwm8776_write(chip, WM8776_MSTRCTRL, data->wm8776_regs[WM8776_MSTRCTRL]);\r\nwm8776_write(chip, WM8776_PWRDOWN, data->wm8776_regs[WM8776_PWRDOWN]);\r\nwm8776_write(chip, WM8776_HPLVOL, data->wm8776_regs[WM8776_HPLVOL]);\r\nwm8776_write(chip, WM8776_HPRVOL, data->wm8776_regs[WM8776_HPRVOL] |\r\nWM8776_UPDATE);\r\nwm8776_write(chip, WM8776_ADCLVOL, data->wm8776_regs[WM8776_ADCLVOL]);\r\nwm8776_write(chip, WM8776_ADCRVOL, data->wm8776_regs[WM8776_ADCRVOL]);\r\nwm8776_write(chip, WM8776_ADCMUX, data->wm8776_regs[WM8776_ADCMUX]);\r\nwm8776_write(chip, WM8776_DACLVOL, chip->dac_volume[0]);\r\nwm8776_write(chip, WM8776_DACRVOL, chip->dac_volume[1] | WM8776_UPDATE);\r\n}\r\nstatic void wm8766_registers_init(struct oxygen *chip)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nwm8766_write(chip, WM8766_RESET, 0);\r\nwm8766_write(chip, WM8766_DAC_CTRL, data->wm8766_regs[WM8766_DAC_CTRL]);\r\nwm8766_write(chip, WM8766_INT_CTRL, WM8766_FMT_LJUST | WM8766_IWL_24);\r\nwm8766_write(chip, WM8766_DAC_CTRL2,\r\nWM8766_ZCD | (chip->dac_mute ? WM8766_DMUTE_MASK : 0));\r\nwm8766_write(chip, WM8766_LDA1, chip->dac_volume[2]);\r\nwm8766_write(chip, WM8766_RDA1, chip->dac_volume[3]);\r\nwm8766_write(chip, WM8766_LDA2, chip->dac_volume[4]);\r\nwm8766_write(chip, WM8766_RDA2, chip->dac_volume[5]);\r\nwm8766_write(chip, WM8766_LDA3, chip->dac_volume[6]);\r\nwm8766_write(chip, WM8766_RDA3, chip->dac_volume[7] | WM8766_UPDATE);\r\n}\r\nstatic void wm8776_init(struct oxygen *chip)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\ndata->wm8776_regs[WM8776_HPLVOL] = (0x79 - 60) | WM8776_HPZCEN;\r\ndata->wm8776_regs[WM8776_HPRVOL] = (0x79 - 60) | WM8776_HPZCEN;\r\ndata->wm8776_regs[WM8776_ADCIFCTRL] =\r\nWM8776_ADCFMT_LJUST | WM8776_ADCWL_24 | WM8776_ADCMCLK;\r\ndata->wm8776_regs[WM8776_MSTRCTRL] =\r\nWM8776_ADCRATE_256 | WM8776_DACRATE_256;\r\ndata->wm8776_regs[WM8776_PWRDOWN] = WM8776_HPPD;\r\ndata->wm8776_regs[WM8776_ADCLVOL] = 0xa5 | WM8776_ZCA;\r\ndata->wm8776_regs[WM8776_ADCRVOL] = 0xa5 | WM8776_ZCA;\r\ndata->wm8776_regs[WM8776_ADCMUX] = 0x001;\r\nwm8776_registers_init(chip);\r\n}\r\nstatic void wm8766_init(struct oxygen *chip)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\ndata->wm8766_regs[WM8766_DAC_CTRL] =\r\nWM8766_PL_LEFT_LEFT | WM8766_PL_RIGHT_RIGHT;\r\nwm8766_registers_init(chip);\r\n}\r\nstatic void xonar_ds_handle_hp_jack(struct oxygen *chip)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nbool hp_plugged;\r\nunsigned int reg;\r\nmutex_lock(&chip->mutex);\r\nhp_plugged = !(oxygen_read16(chip, OXYGEN_GPIO_DATA) &\r\nGPIO_DS_HP_DETECT);\r\noxygen_write16_masked(chip, OXYGEN_GPIO_DATA,\r\nhp_plugged ? 0 : GPIO_DS_OUTPUT_FRONTLR,\r\nGPIO_DS_OUTPUT_FRONTLR);\r\nreg = data->wm8766_regs[WM8766_DAC_CTRL] & ~WM8766_MUTEALL;\r\nif (hp_plugged)\r\nreg |= WM8766_MUTEALL;\r\nwm8766_write_cached(chip, WM8766_DAC_CTRL, reg);\r\nsnd_jack_report(data->hp_jack, hp_plugged ? SND_JACK_HEADPHONE : 0);\r\nmutex_unlock(&chip->mutex);\r\n}\r\nstatic void xonar_ds_init(struct oxygen *chip)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\ndata->generic.anti_pop_delay = 300;\r\ndata->generic.output_enable_bit = GPIO_DS_OUTPUT_ENABLE;\r\nwm8776_init(chip);\r\nwm8766_init(chip);\r\noxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL,\r\nGPIO_DS_INPUT_ROUTE | GPIO_DS_OUTPUT_FRONTLR);\r\noxygen_clear_bits16(chip, OXYGEN_GPIO_CONTROL,\r\nGPIO_DS_HP_DETECT);\r\noxygen_set_bits16(chip, OXYGEN_GPIO_DATA, GPIO_DS_INPUT_ROUTE);\r\noxygen_set_bits16(chip, OXYGEN_GPIO_INTERRUPT_MASK, GPIO_DS_HP_DETECT);\r\nchip->interrupt_mask |= OXYGEN_INT_GPIO;\r\nxonar_enable_output(chip);\r\nsnd_jack_new(chip->card, "Headphone",\r\nSND_JACK_HEADPHONE, &data->hp_jack);\r\nxonar_ds_handle_hp_jack(chip);\r\nsnd_component_add(chip->card, "WM8776");\r\nsnd_component_add(chip->card, "WM8766");\r\n}\r\nstatic void xonar_hdav_slim_init(struct oxygen *chip)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\ndata->generic.anti_pop_delay = 300;\r\ndata->generic.output_enable_bit = GPIO_SLIM_OUTPUT_ENABLE;\r\nwm8776_init(chip);\r\noxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL,\r\nGPIO_SLIM_HDMI_DISABLE |\r\nGPIO_SLIM_FIRMWARE_CLK |\r\nGPIO_SLIM_FIRMWARE_DATA);\r\nxonar_hdmi_init(chip, &data->hdmi);\r\nxonar_enable_output(chip);\r\nsnd_component_add(chip->card, "WM8776");\r\n}\r\nstatic void xonar_ds_cleanup(struct oxygen *chip)\r\n{\r\nxonar_disable_output(chip);\r\nwm8776_write(chip, WM8776_RESET, 0);\r\n}\r\nstatic void xonar_hdav_slim_cleanup(struct oxygen *chip)\r\n{\r\nxonar_hdmi_cleanup(chip);\r\nxonar_disable_output(chip);\r\nwm8776_write(chip, WM8776_RESET, 0);\r\nmsleep(2);\r\n}\r\nstatic void xonar_ds_suspend(struct oxygen *chip)\r\n{\r\nxonar_ds_cleanup(chip);\r\n}\r\nstatic void xonar_hdav_slim_suspend(struct oxygen *chip)\r\n{\r\nxonar_hdav_slim_cleanup(chip);\r\n}\r\nstatic void xonar_ds_resume(struct oxygen *chip)\r\n{\r\nwm8776_registers_init(chip);\r\nwm8766_registers_init(chip);\r\nxonar_enable_output(chip);\r\nxonar_ds_handle_hp_jack(chip);\r\n}\r\nstatic void xonar_hdav_slim_resume(struct oxygen *chip)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nwm8776_registers_init(chip);\r\nxonar_hdmi_resume(chip, &data->hdmi);\r\nxonar_enable_output(chip);\r\n}\r\nstatic void wm8776_adc_hardware_filter(unsigned int channel,\r\nstruct snd_pcm_hardware *hardware)\r\n{\r\nif (channel == PCM_A) {\r\nhardware->rates = SNDRV_PCM_RATE_32000 |\r\nSNDRV_PCM_RATE_44100 |\r\nSNDRV_PCM_RATE_48000 |\r\nSNDRV_PCM_RATE_64000 |\r\nSNDRV_PCM_RATE_88200 |\r\nSNDRV_PCM_RATE_96000;\r\nhardware->rate_max = 96000;\r\n}\r\n}\r\nstatic void xonar_hdav_slim_hardware_filter(unsigned int channel,\r\nstruct snd_pcm_hardware *hardware)\r\n{\r\nwm8776_adc_hardware_filter(channel, hardware);\r\nxonar_hdmi_pcm_hardware_filter(channel, hardware);\r\n}\r\nstatic void set_wm87x6_dac_params(struct oxygen *chip,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\n}\r\nstatic void set_wm8776_adc_params(struct oxygen *chip,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nu16 reg;\r\nreg = WM8776_ADCRATE_256 | WM8776_DACRATE_256;\r\nif (params_rate(params) > 48000)\r\nreg |= WM8776_ADCOSR;\r\nwm8776_write_cached(chip, WM8776_MSTRCTRL, reg);\r\n}\r\nstatic void set_hdav_slim_dac_params(struct oxygen *chip,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nxonar_set_hdmi_params(chip, &data->hdmi, params);\r\n}\r\nstatic void update_wm8776_volume(struct oxygen *chip)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nu8 to_change;\r\nif (chip->dac_volume[0] == chip->dac_volume[1]) {\r\nif (chip->dac_volume[0] != data->wm8776_regs[WM8776_DACLVOL] ||\r\nchip->dac_volume[1] != data->wm8776_regs[WM8776_DACRVOL]) {\r\nwm8776_write(chip, WM8776_DACMASTER,\r\nchip->dac_volume[0] | WM8776_UPDATE);\r\ndata->wm8776_regs[WM8776_DACLVOL] = chip->dac_volume[0];\r\ndata->wm8776_regs[WM8776_DACRVOL] = chip->dac_volume[0];\r\n}\r\n} else {\r\nto_change = (chip->dac_volume[0] !=\r\ndata->wm8776_regs[WM8776_DACLVOL]) << 0;\r\nto_change |= (chip->dac_volume[1] !=\r\ndata->wm8776_regs[WM8776_DACLVOL]) << 1;\r\nif (to_change & 1)\r\nwm8776_write(chip, WM8776_DACLVOL, chip->dac_volume[0] |\r\n((to_change & 2) ? 0 : WM8776_UPDATE));\r\nif (to_change & 2)\r\nwm8776_write(chip, WM8776_DACRVOL,\r\nchip->dac_volume[1] | WM8776_UPDATE);\r\n}\r\n}\r\nstatic void update_wm87x6_volume(struct oxygen *chip)\r\n{\r\nstatic const u8 wm8766_regs[6] = {\r\nWM8766_LDA1, WM8766_RDA1,\r\nWM8766_LDA2, WM8766_RDA2,\r\nWM8766_LDA3, WM8766_RDA3,\r\n};\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nunsigned int i;\r\nu8 to_change;\r\nupdate_wm8776_volume(chip);\r\nif (chip->dac_volume[2] == chip->dac_volume[3] &&\r\nchip->dac_volume[2] == chip->dac_volume[4] &&\r\nchip->dac_volume[2] == chip->dac_volume[5] &&\r\nchip->dac_volume[2] == chip->dac_volume[6] &&\r\nchip->dac_volume[2] == chip->dac_volume[7]) {\r\nto_change = 0;\r\nfor (i = 0; i < 6; ++i)\r\nif (chip->dac_volume[2] !=\r\ndata->wm8766_regs[wm8766_regs[i]])\r\nto_change = 1;\r\nif (to_change) {\r\nwm8766_write(chip, WM8766_MASTDA,\r\nchip->dac_volume[2] | WM8766_UPDATE);\r\nfor (i = 0; i < 6; ++i)\r\ndata->wm8766_regs[wm8766_regs[i]] =\r\nchip->dac_volume[2];\r\n}\r\n} else {\r\nto_change = 0;\r\nfor (i = 0; i < 6; ++i)\r\nto_change |= (chip->dac_volume[2 + i] !=\r\ndata->wm8766_regs[wm8766_regs[i]]) << i;\r\nfor (i = 0; i < 6; ++i)\r\nif (to_change & (1 << i))\r\nwm8766_write(chip, wm8766_regs[i],\r\nchip->dac_volume[2 + i] |\r\n((to_change & (0x3e << i))\r\n? 0 : WM8766_UPDATE));\r\n}\r\n}\r\nstatic void update_wm8776_mute(struct oxygen *chip)\r\n{\r\nwm8776_write_cached(chip, WM8776_DACMUTE,\r\nchip->dac_mute ? WM8776_DMUTE : 0);\r\n}\r\nstatic void update_wm87x6_mute(struct oxygen *chip)\r\n{\r\nupdate_wm8776_mute(chip);\r\nwm8766_write_cached(chip, WM8766_DAC_CTRL2, WM8766_ZCD |\r\n(chip->dac_mute ? WM8766_DMUTE_MASK : 0));\r\n}\r\nstatic void update_wm8766_center_lfe_mix(struct oxygen *chip, bool mixed)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nunsigned int reg;\r\nreg = data->wm8766_regs[WM8766_DAC_CTRL] &\r\n~(WM8766_PL_LEFT_MASK | WM8766_PL_RIGHT_MASK);\r\nif (mixed)\r\nreg |= WM8766_PL_LEFT_LRMIX | WM8766_PL_RIGHT_LRMIX;\r\nelse\r\nreg |= WM8766_PL_LEFT_LEFT | WM8766_PL_RIGHT_RIGHT;\r\nwm8766_write_cached(chip, WM8766_DAC_CTRL, reg);\r\n}\r\nstatic void xonar_ds_gpio_changed(struct oxygen *chip)\r\n{\r\nxonar_ds_handle_hp_jack(chip);\r\n}\r\nstatic int wm8776_bit_switch_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nu16 bit = ctl->private_value & 0xffff;\r\nunsigned int reg_index = (ctl->private_value >> 16) & 0xff;\r\nbool invert = (ctl->private_value >> 24) & 1;\r\nvalue->value.integer.value[0] =\r\n((data->wm8776_regs[reg_index] & bit) != 0) ^ invert;\r\nreturn 0;\r\n}\r\nstatic int wm8776_bit_switch_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nu16 bit = ctl->private_value & 0xffff;\r\nu16 reg_value;\r\nunsigned int reg_index = (ctl->private_value >> 16) & 0xff;\r\nbool invert = (ctl->private_value >> 24) & 1;\r\nint changed;\r\nmutex_lock(&chip->mutex);\r\nreg_value = data->wm8776_regs[reg_index] & ~bit;\r\nif (value->value.integer.value[0] ^ invert)\r\nreg_value |= bit;\r\nchanged = reg_value != data->wm8776_regs[reg_index];\r\nif (changed)\r\nwm8776_write(chip, reg_index, reg_value);\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int wm8776_field_enum_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const hld[16] = {\r\n"0 ms", "2.67 ms", "5.33 ms", "10.6 ms",\r\n"21.3 ms", "42.7 ms", "85.3 ms", "171 ms",\r\n"341 ms", "683 ms", "1.37 s", "2.73 s",\r\n"5.46 s", "10.9 s", "21.8 s", "43.7 s",\r\n};\r\nstatic const char *const atk_lim[11] = {\r\n"0.25 ms", "0.5 ms", "1 ms", "2 ms",\r\n"4 ms", "8 ms", "16 ms", "32 ms",\r\n"64 ms", "128 ms", "256 ms",\r\n};\r\nstatic const char *const atk_alc[11] = {\r\n"8.40 ms", "16.8 ms", "33.6 ms", "67.2 ms",\r\n"134 ms", "269 ms", "538 ms", "1.08 s",\r\n"2.15 s", "4.3 s", "8.6 s",\r\n};\r\nstatic const char *const dcy_lim[11] = {\r\n"1.2 ms", "2.4 ms", "4.8 ms", "9.6 ms",\r\n"19.2 ms", "38.4 ms", "76.8 ms", "154 ms",\r\n"307 ms", "614 ms", "1.23 s",\r\n};\r\nstatic const char *const dcy_alc[11] = {\r\n"33.5 ms", "67.0 ms", "134 ms", "268 ms",\r\n"536 ms", "1.07 s", "2.14 s", "4.29 s",\r\n"8.58 s", "17.2 s", "34.3 s",\r\n};\r\nstatic const char *const tranwin[8] = {\r\n"0 us", "62.5 us", "125 us", "250 us",\r\n"500 us", "1 ms", "2 ms", "4 ms",\r\n};\r\nu8 max;\r\nconst char *const *names;\r\nmax = (ctl->private_value >> 12) & 0xf;\r\nswitch ((ctl->private_value >> 24) & 0x1f) {\r\ncase WM8776_ALCCTRL2:\r\nnames = hld;\r\nbreak;\r\ncase WM8776_ALCCTRL3:\r\nif (((ctl->private_value >> 20) & 0xf) == 0) {\r\nif (ctl->private_value & LC_CONTROL_LIMITER)\r\nnames = atk_lim;\r\nelse\r\nnames = atk_alc;\r\n} else {\r\nif (ctl->private_value & LC_CONTROL_LIMITER)\r\nnames = dcy_lim;\r\nelse\r\nnames = dcy_alc;\r\n}\r\nbreak;\r\ncase WM8776_LIMITER:\r\nnames = tranwin;\r\nbreak;\r\ndefault:\r\nreturn -ENXIO;\r\n}\r\nreturn snd_ctl_enum_info(info, 1, max + 1, names);\r\n}\r\nstatic int wm8776_field_volume_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\ninfo->count = 1;\r\ninfo->value.integer.min = (ctl->private_value >> 8) & 0xf;\r\ninfo->value.integer.max = (ctl->private_value >> 12) & 0xf;\r\nreturn 0;\r\n}\r\nstatic void wm8776_field_set_from_ctl(struct snd_kcontrol *ctl)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nunsigned int value, reg_index, mode;\r\nu8 min, max, shift;\r\nu16 mask, reg_value;\r\nbool invert;\r\nif ((data->wm8776_regs[WM8776_ALCCTRL1] & WM8776_LCSEL_MASK) ==\r\nWM8776_LCSEL_LIMITER)\r\nmode = LC_CONTROL_LIMITER;\r\nelse\r\nmode = LC_CONTROL_ALC;\r\nif (!(ctl->private_value & mode))\r\nreturn;\r\nvalue = ctl->private_value & 0xf;\r\nmin = (ctl->private_value >> 8) & 0xf;\r\nmax = (ctl->private_value >> 12) & 0xf;\r\nmask = (ctl->private_value >> 16) & 0xf;\r\nshift = (ctl->private_value >> 20) & 0xf;\r\nreg_index = (ctl->private_value >> 24) & 0x1f;\r\ninvert = (ctl->private_value >> 29) & 0x1;\r\nif (invert)\r\nvalue = max - (value - min);\r\nreg_value = data->wm8776_regs[reg_index];\r\nreg_value &= ~(mask << shift);\r\nreg_value |= value << shift;\r\nwm8776_write_cached(chip, reg_index, reg_value);\r\n}\r\nstatic int wm8776_field_set(struct snd_kcontrol *ctl, unsigned int value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nu8 min, max;\r\nint changed;\r\nmin = (ctl->private_value >> 8) & 0xf;\r\nmax = (ctl->private_value >> 12) & 0xf;\r\nif (value < min || value > max)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mutex);\r\nchanged = value != (ctl->private_value & 0xf);\r\nif (changed) {\r\nctl->private_value = (ctl->private_value & ~0xf) | value;\r\nwm8776_field_set_from_ctl(ctl);\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int wm8776_field_enum_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nvalue->value.enumerated.item[0] = ctl->private_value & 0xf;\r\nreturn 0;\r\n}\r\nstatic int wm8776_field_volume_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nvalue->value.integer.value[0] = ctl->private_value & 0xf;\r\nreturn 0;\r\n}\r\nstatic int wm8776_field_enum_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nreturn wm8776_field_set(ctl, value->value.enumerated.item[0]);\r\n}\r\nstatic int wm8776_field_volume_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nreturn wm8776_field_set(ctl, value->value.integer.value[0]);\r\n}\r\nstatic int wm8776_hp_vol_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\ninfo->count = 2;\r\ninfo->value.integer.min = 0x79 - 60;\r\ninfo->value.integer.max = 0x7f;\r\nreturn 0;\r\n}\r\nstatic int wm8776_hp_vol_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nmutex_lock(&chip->mutex);\r\nvalue->value.integer.value[0] =\r\ndata->wm8776_regs[WM8776_HPLVOL] & WM8776_HPATT_MASK;\r\nvalue->value.integer.value[1] =\r\ndata->wm8776_regs[WM8776_HPRVOL] & WM8776_HPATT_MASK;\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int wm8776_hp_vol_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nu8 to_update;\r\nmutex_lock(&chip->mutex);\r\nto_update = (value->value.integer.value[0] !=\r\n(data->wm8776_regs[WM8776_HPLVOL] & WM8776_HPATT_MASK))\r\n<< 0;\r\nto_update |= (value->value.integer.value[1] !=\r\n(data->wm8776_regs[WM8776_HPRVOL] & WM8776_HPATT_MASK))\r\n<< 1;\r\nif (value->value.integer.value[0] == value->value.integer.value[1]) {\r\nif (to_update) {\r\nwm8776_write(chip, WM8776_HPMASTER,\r\nvalue->value.integer.value[0] |\r\nWM8776_HPZCEN | WM8776_UPDATE);\r\ndata->wm8776_regs[WM8776_HPLVOL] =\r\nvalue->value.integer.value[0] | WM8776_HPZCEN;\r\ndata->wm8776_regs[WM8776_HPRVOL] =\r\nvalue->value.integer.value[0] | WM8776_HPZCEN;\r\n}\r\n} else {\r\nif (to_update & 1)\r\nwm8776_write(chip, WM8776_HPLVOL,\r\nvalue->value.integer.value[0] |\r\nWM8776_HPZCEN |\r\n((to_update & 2) ? 0 : WM8776_UPDATE));\r\nif (to_update & 2)\r\nwm8776_write(chip, WM8776_HPRVOL,\r\nvalue->value.integer.value[1] |\r\nWM8776_HPZCEN | WM8776_UPDATE);\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn to_update != 0;\r\n}\r\nstatic int wm8776_input_mux_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nunsigned int mux_bit = ctl->private_value;\r\nvalue->value.integer.value[0] =\r\n!!(data->wm8776_regs[WM8776_ADCMUX] & mux_bit);\r\nreturn 0;\r\n}\r\nstatic int wm8776_input_mux_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nstruct snd_kcontrol *other_ctl;\r\nunsigned int mux_bit = ctl->private_value;\r\nu16 reg;\r\nint changed;\r\nmutex_lock(&chip->mutex);\r\nreg = data->wm8776_regs[WM8776_ADCMUX];\r\nif (value->value.integer.value[0]) {\r\nreg |= mux_bit;\r\nmux_bit ^= 3;\r\nif (reg & mux_bit) {\r\nreg &= ~mux_bit;\r\nif (mux_bit == 1)\r\nother_ctl = data->line_adcmux_control;\r\nelse\r\nother_ctl = data->mic_adcmux_control;\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&other_ctl->id);\r\n}\r\n} else\r\nreg &= ~mux_bit;\r\nchanged = reg != data->wm8776_regs[WM8776_ADCMUX];\r\nif (changed) {\r\noxygen_write16_masked(chip, OXYGEN_GPIO_DATA,\r\nreg & 1 ? GPIO_DS_INPUT_ROUTE : 0,\r\nGPIO_DS_INPUT_ROUTE);\r\nwm8776_write(chip, WM8776_ADCMUX, reg);\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int wm8776_input_vol_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\ninfo->count = 2;\r\ninfo->value.integer.min = 0xa5;\r\ninfo->value.integer.max = 0xff;\r\nreturn 0;\r\n}\r\nstatic int wm8776_input_vol_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nmutex_lock(&chip->mutex);\r\nvalue->value.integer.value[0] =\r\ndata->wm8776_regs[WM8776_ADCLVOL] & WM8776_AGMASK;\r\nvalue->value.integer.value[1] =\r\ndata->wm8776_regs[WM8776_ADCRVOL] & WM8776_AGMASK;\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int wm8776_input_vol_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nint changed = 0;\r\nmutex_lock(&chip->mutex);\r\nchanged = (value->value.integer.value[0] !=\r\n(data->wm8776_regs[WM8776_ADCLVOL] & WM8776_AGMASK)) ||\r\n(value->value.integer.value[1] !=\r\n(data->wm8776_regs[WM8776_ADCRVOL] & WM8776_AGMASK));\r\nwm8776_write_cached(chip, WM8776_ADCLVOL,\r\nvalue->value.integer.value[0] | WM8776_ZCA);\r\nwm8776_write_cached(chip, WM8776_ADCRVOL,\r\nvalue->value.integer.value[1] | WM8776_ZCA);\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int wm8776_level_control_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[3] = {\r\n"None", "Peak Limiter", "Automatic Level Control"\r\n};\r\nreturn snd_ctl_enum_info(info, 1, 3, names);\r\n}\r\nstatic int wm8776_level_control_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nif (!(data->wm8776_regs[WM8776_ALCCTRL2] & WM8776_LCEN))\r\nvalue->value.enumerated.item[0] = 0;\r\nelse if ((data->wm8776_regs[WM8776_ALCCTRL1] & WM8776_LCSEL_MASK) ==\r\nWM8776_LCSEL_LIMITER)\r\nvalue->value.enumerated.item[0] = 1;\r\nelse\r\nvalue->value.enumerated.item[0] = 2;\r\nreturn 0;\r\n}\r\nstatic void activate_control(struct oxygen *chip,\r\nstruct snd_kcontrol *ctl, unsigned int mode)\r\n{\r\nunsigned int access;\r\nif (ctl->private_value & mode)\r\naccess = 0;\r\nelse\r\naccess = SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nif ((ctl->vd[0].access & SNDRV_CTL_ELEM_ACCESS_INACTIVE) != access) {\r\nctl->vd[0].access ^= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_INFO, &ctl->id);\r\n}\r\n}\r\nstatic int wm8776_level_control_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nunsigned int mode = 0, i;\r\nu16 ctrl1, ctrl2;\r\nint changed;\r\nif (value->value.enumerated.item[0] >= 3)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mutex);\r\nchanged = value->value.enumerated.item[0] != ctl->private_value;\r\nif (changed) {\r\nctl->private_value = value->value.enumerated.item[0];\r\nctrl1 = data->wm8776_regs[WM8776_ALCCTRL1];\r\nctrl2 = data->wm8776_regs[WM8776_ALCCTRL2];\r\nswitch (value->value.enumerated.item[0]) {\r\ndefault:\r\nwm8776_write_cached(chip, WM8776_ALCCTRL2,\r\nctrl2 & ~WM8776_LCEN);\r\nbreak;\r\ncase 1:\r\nwm8776_write_cached(chip, WM8776_ALCCTRL1,\r\n(ctrl1 & ~WM8776_LCSEL_MASK) |\r\nWM8776_LCSEL_LIMITER);\r\nwm8776_write_cached(chip, WM8776_ALCCTRL2,\r\nctrl2 | WM8776_LCEN);\r\nmode = LC_CONTROL_LIMITER;\r\nbreak;\r\ncase 2:\r\nwm8776_write_cached(chip, WM8776_ALCCTRL1,\r\n(ctrl1 & ~WM8776_LCSEL_MASK) |\r\nWM8776_LCSEL_ALC_STEREO);\r\nwm8776_write_cached(chip, WM8776_ALCCTRL2,\r\nctrl2 | WM8776_LCEN);\r\nmode = LC_CONTROL_ALC;\r\nbreak;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(data->lc_controls); ++i)\r\nactivate_control(chip, data->lc_controls[i], mode);\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int hpf_info(struct snd_kcontrol *ctl, struct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[2] = {\r\n"None", "High-pass Filter"\r\n};\r\nreturn snd_ctl_enum_info(info, 1, 2, names);\r\n}\r\nstatic int hpf_get(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nvalue->value.enumerated.item[0] =\r\n!(data->wm8776_regs[WM8776_ADCIFCTRL] & WM8776_ADCHPD);\r\nreturn 0;\r\n}\r\nstatic int hpf_put(struct snd_kcontrol *ctl, struct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nunsigned int reg;\r\nint changed;\r\nmutex_lock(&chip->mutex);\r\nreg = data->wm8776_regs[WM8776_ADCIFCTRL] & ~WM8776_ADCHPD;\r\nif (!value->value.enumerated.item[0])\r\nreg |= WM8776_ADCHPD;\r\nchanged = reg != data->wm8776_regs[WM8776_ADCIFCTRL];\r\nif (changed)\r\nwm8776_write(chip, WM8776_ADCIFCTRL, reg);\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int add_lc_controls(struct oxygen *chip)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nunsigned int i;\r\nstruct snd_kcontrol *ctl;\r\nint err;\r\nBUILD_BUG_ON(ARRAY_SIZE(lc_controls) != ARRAY_SIZE(data->lc_controls));\r\nfor (i = 0; i < ARRAY_SIZE(lc_controls); ++i) {\r\nctl = snd_ctl_new1(&lc_controls[i], chip);\r\nif (!ctl)\r\nreturn -ENOMEM;\r\nerr = snd_ctl_add(chip->card, ctl);\r\nif (err < 0)\r\nreturn err;\r\ndata->lc_controls[i] = ctl;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xonar_ds_mixer_init(struct oxygen *chip)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nunsigned int i;\r\nstruct snd_kcontrol *ctl;\r\nint err;\r\nfor (i = 0; i < ARRAY_SIZE(ds_controls); ++i) {\r\nctl = snd_ctl_new1(&ds_controls[i], chip);\r\nif (!ctl)\r\nreturn -ENOMEM;\r\nerr = snd_ctl_add(chip->card, ctl);\r\nif (err < 0)\r\nreturn err;\r\nif (!strcmp(ctl->id.name, "Line Capture Switch"))\r\ndata->line_adcmux_control = ctl;\r\nelse if (!strcmp(ctl->id.name, "Mic Capture Switch"))\r\ndata->mic_adcmux_control = ctl;\r\n}\r\nif (!data->line_adcmux_control || !data->mic_adcmux_control)\r\nreturn -ENXIO;\r\nreturn add_lc_controls(chip);\r\n}\r\nstatic int xonar_hdav_slim_mixer_init(struct oxygen *chip)\r\n{\r\nunsigned int i;\r\nstruct snd_kcontrol *ctl;\r\nint err;\r\nfor (i = 0; i < ARRAY_SIZE(hdav_slim_controls); ++i) {\r\nctl = snd_ctl_new1(&hdav_slim_controls[i], chip);\r\nif (!ctl)\r\nreturn -ENOMEM;\r\nerr = snd_ctl_add(chip->card, ctl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn add_lc_controls(chip);\r\n}\r\nstatic void dump_wm8776_registers(struct oxygen *chip,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nunsigned int i;\r\nsnd_iprintf(buffer, "\nWM8776:\n00:");\r\nfor (i = 0; i < 0x10; ++i)\r\nsnd_iprintf(buffer, " %03x", data->wm8776_regs[i]);\r\nsnd_iprintf(buffer, "\n10:");\r\nfor (i = 0x10; i < 0x17; ++i)\r\nsnd_iprintf(buffer, " %03x", data->wm8776_regs[i]);\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nstatic void dump_wm87x6_registers(struct oxygen *chip,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct xonar_wm87x6 *data = chip->model_data;\r\nunsigned int i;\r\ndump_wm8776_registers(chip, buffer);\r\nsnd_iprintf(buffer, "\nWM8766:\n00:");\r\nfor (i = 0; i < 0x10; ++i)\r\nsnd_iprintf(buffer, " %03x", data->wm8766_regs[i]);\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nint get_xonar_wm87x6_model(struct oxygen *chip,\r\nconst struct pci_device_id *id)\r\n{\r\nswitch (id->subdevice) {\r\ncase 0x838e:\r\nchip->model = model_xonar_ds;\r\nchip->model.shortname = "Xonar DS";\r\nbreak;\r\ncase 0x8522:\r\nchip->model = model_xonar_ds;\r\nchip->model.shortname = "Xonar DSX";\r\nbreak;\r\ncase 0x835e:\r\nchip->model = model_xonar_hdav_slim;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}
