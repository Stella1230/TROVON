static ssize_t gpio_direction_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gpio_desc *desc = dev_get_drvdata(dev);\r\nssize_t status;\r\nmutex_lock(&sysfs_lock);\r\nif (!test_bit(FLAG_EXPORT, &desc->flags)) {\r\nstatus = -EIO;\r\n} else {\r\ngpiod_get_direction(desc);\r\nstatus = sprintf(buf, "%s\n",\r\ntest_bit(FLAG_IS_OUT, &desc->flags)\r\n? "out" : "in");\r\n}\r\nmutex_unlock(&sysfs_lock);\r\nreturn status;\r\n}\r\nstatic ssize_t gpio_direction_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct gpio_desc *desc = dev_get_drvdata(dev);\r\nssize_t status;\r\nmutex_lock(&sysfs_lock);\r\nif (!test_bit(FLAG_EXPORT, &desc->flags))\r\nstatus = -EIO;\r\nelse if (sysfs_streq(buf, "high"))\r\nstatus = gpiod_direction_output_raw(desc, 1);\r\nelse if (sysfs_streq(buf, "out") || sysfs_streq(buf, "low"))\r\nstatus = gpiod_direction_output_raw(desc, 0);\r\nelse if (sysfs_streq(buf, "in"))\r\nstatus = gpiod_direction_input(desc);\r\nelse\r\nstatus = -EINVAL;\r\nmutex_unlock(&sysfs_lock);\r\nreturn status ? : size;\r\n}\r\nstatic ssize_t gpio_value_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct gpio_desc *desc = dev_get_drvdata(dev);\r\nssize_t status;\r\nmutex_lock(&sysfs_lock);\r\nif (!test_bit(FLAG_EXPORT, &desc->flags))\r\nstatus = -EIO;\r\nelse\r\nstatus = sprintf(buf, "%d\n", gpiod_get_value_cansleep(desc));\r\nmutex_unlock(&sysfs_lock);\r\nreturn status;\r\n}\r\nstatic ssize_t gpio_value_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct gpio_desc *desc = dev_get_drvdata(dev);\r\nssize_t status;\r\nmutex_lock(&sysfs_lock);\r\nif (!test_bit(FLAG_EXPORT, &desc->flags))\r\nstatus = -EIO;\r\nelse if (!test_bit(FLAG_IS_OUT, &desc->flags))\r\nstatus = -EPERM;\r\nelse {\r\nlong value;\r\nstatus = kstrtol(buf, 0, &value);\r\nif (status == 0) {\r\ngpiod_set_value_cansleep(desc, value);\r\nstatus = size;\r\n}\r\n}\r\nmutex_unlock(&sysfs_lock);\r\nreturn status;\r\n}\r\nstatic irqreturn_t gpio_sysfs_irq(int irq, void *priv)\r\n{\r\nstruct kernfs_node *value_sd = priv;\r\nsysfs_notify_dirent(value_sd);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int gpio_setup_irq(struct gpio_desc *desc, struct device *dev,\r\nunsigned long gpio_flags)\r\n{\r\nstruct kernfs_node *value_sd;\r\nunsigned long irq_flags;\r\nint ret, irq, id;\r\nif ((desc->flags & GPIO_TRIGGER_MASK) == gpio_flags)\r\nreturn 0;\r\nirq = gpiod_to_irq(desc);\r\nif (irq < 0)\r\nreturn -EIO;\r\nid = desc->flags >> ID_SHIFT;\r\nvalue_sd = idr_find(&dirent_idr, id);\r\nif (value_sd)\r\nfree_irq(irq, value_sd);\r\ndesc->flags &= ~GPIO_TRIGGER_MASK;\r\nif (!gpio_flags) {\r\ngpiochip_unlock_as_irq(desc->chip, gpio_chip_hwgpio(desc));\r\nret = 0;\r\ngoto free_id;\r\n}\r\nirq_flags = IRQF_SHARED;\r\nif (test_bit(FLAG_TRIG_FALL, &gpio_flags))\r\nirq_flags |= test_bit(FLAG_ACTIVE_LOW, &desc->flags) ?\r\nIRQF_TRIGGER_RISING : IRQF_TRIGGER_FALLING;\r\nif (test_bit(FLAG_TRIG_RISE, &gpio_flags))\r\nirq_flags |= test_bit(FLAG_ACTIVE_LOW, &desc->flags) ?\r\nIRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING;\r\nif (!value_sd) {\r\nvalue_sd = sysfs_get_dirent(dev->kobj.sd, "value");\r\nif (!value_sd) {\r\nret = -ENODEV;\r\ngoto err_out;\r\n}\r\nret = idr_alloc(&dirent_idr, value_sd, 1, 0, GFP_KERNEL);\r\nif (ret < 0)\r\ngoto free_sd;\r\nid = ret;\r\ndesc->flags &= GPIO_FLAGS_MASK;\r\ndesc->flags |= (unsigned long)id << ID_SHIFT;\r\nif (desc->flags >> ID_SHIFT != id) {\r\nret = -ERANGE;\r\ngoto free_id;\r\n}\r\n}\r\nret = request_any_context_irq(irq, gpio_sysfs_irq, irq_flags,\r\n"gpiolib", value_sd);\r\nif (ret < 0)\r\ngoto free_id;\r\nret = gpiochip_lock_as_irq(desc->chip, gpio_chip_hwgpio(desc));\r\nif (ret < 0) {\r\ngpiod_warn(desc, "failed to flag the GPIO for IRQ\n");\r\ngoto free_id;\r\n}\r\ndesc->flags |= gpio_flags;\r\nreturn 0;\r\nfree_id:\r\nidr_remove(&dirent_idr, id);\r\ndesc->flags &= GPIO_FLAGS_MASK;\r\nfree_sd:\r\nif (value_sd)\r\nsysfs_put(value_sd);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic ssize_t gpio_edge_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nconst struct gpio_desc *desc = dev_get_drvdata(dev);\r\nssize_t status;\r\nmutex_lock(&sysfs_lock);\r\nif (!test_bit(FLAG_EXPORT, &desc->flags))\r\nstatus = -EIO;\r\nelse {\r\nint i;\r\nstatus = 0;\r\nfor (i = 0; i < ARRAY_SIZE(trigger_types); i++)\r\nif ((desc->flags & GPIO_TRIGGER_MASK)\r\n== trigger_types[i].flags) {\r\nstatus = sprintf(buf, "%s\n",\r\ntrigger_types[i].name);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&sysfs_lock);\r\nreturn status;\r\n}\r\nstatic ssize_t gpio_edge_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct gpio_desc *desc = dev_get_drvdata(dev);\r\nssize_t status;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(trigger_types); i++)\r\nif (sysfs_streq(trigger_types[i].name, buf))\r\ngoto found;\r\nreturn -EINVAL;\r\nfound:\r\nmutex_lock(&sysfs_lock);\r\nif (!test_bit(FLAG_EXPORT, &desc->flags))\r\nstatus = -EIO;\r\nelse {\r\nstatus = gpio_setup_irq(desc, dev, trigger_types[i].flags);\r\nif (!status)\r\nstatus = size;\r\n}\r\nmutex_unlock(&sysfs_lock);\r\nreturn status;\r\n}\r\nstatic int sysfs_set_active_low(struct gpio_desc *desc, struct device *dev,\r\nint value)\r\n{\r\nint status = 0;\r\nif (!!test_bit(FLAG_ACTIVE_LOW, &desc->flags) == !!value)\r\nreturn 0;\r\nif (value)\r\nset_bit(FLAG_ACTIVE_LOW, &desc->flags);\r\nelse\r\nclear_bit(FLAG_ACTIVE_LOW, &desc->flags);\r\nif (dev != NULL && (!!test_bit(FLAG_TRIG_RISE, &desc->flags) ^\r\n!!test_bit(FLAG_TRIG_FALL, &desc->flags))) {\r\nunsigned long trigger_flags = desc->flags & GPIO_TRIGGER_MASK;\r\ngpio_setup_irq(desc, dev, 0);\r\nstatus = gpio_setup_irq(desc, dev, trigger_flags);\r\n}\r\nreturn status;\r\n}\r\nstatic ssize_t gpio_active_low_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nconst struct gpio_desc *desc = dev_get_drvdata(dev);\r\nssize_t status;\r\nmutex_lock(&sysfs_lock);\r\nif (!test_bit(FLAG_EXPORT, &desc->flags))\r\nstatus = -EIO;\r\nelse\r\nstatus = sprintf(buf, "%d\n",\r\n!!test_bit(FLAG_ACTIVE_LOW, &desc->flags));\r\nmutex_unlock(&sysfs_lock);\r\nreturn status;\r\n}\r\nstatic ssize_t gpio_active_low_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct gpio_desc *desc = dev_get_drvdata(dev);\r\nssize_t status;\r\nmutex_lock(&sysfs_lock);\r\nif (!test_bit(FLAG_EXPORT, &desc->flags)) {\r\nstatus = -EIO;\r\n} else {\r\nlong value;\r\nstatus = kstrtol(buf, 0, &value);\r\nif (status == 0)\r\nstatus = sysfs_set_active_low(desc, dev, value != 0);\r\n}\r\nmutex_unlock(&sysfs_lock);\r\nreturn status ? : size;\r\n}\r\nstatic umode_t gpio_is_visible(struct kobject *kobj, struct attribute *attr,\r\nint n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct gpio_desc *desc = dev_get_drvdata(dev);\r\numode_t mode = attr->mode;\r\nbool show_direction = test_bit(FLAG_SYSFS_DIR, &desc->flags);\r\nif (attr == &dev_attr_direction.attr) {\r\nif (!show_direction)\r\nmode = 0;\r\n} else if (attr == &dev_attr_edge.attr) {\r\nif (gpiod_to_irq(desc) < 0)\r\nmode = 0;\r\nif (!show_direction && test_bit(FLAG_IS_OUT, &desc->flags))\r\nmode = 0;\r\n}\r\nreturn mode;\r\n}\r\nstatic ssize_t chip_base_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nconst struct gpio_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", chip->base);\r\n}\r\nstatic ssize_t chip_label_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nconst struct gpio_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", chip->label ? : "");\r\n}\r\nstatic ssize_t chip_ngpio_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nconst struct gpio_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", chip->ngpio);\r\n}\r\nstatic ssize_t export_store(struct class *class,\r\nstruct class_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nlong gpio;\r\nstruct gpio_desc *desc;\r\nint status;\r\nstatus = kstrtol(buf, 0, &gpio);\r\nif (status < 0)\r\ngoto done;\r\ndesc = gpio_to_desc(gpio);\r\nif (!desc) {\r\npr_warn("%s: invalid GPIO %ld\n", __func__, gpio);\r\nreturn -EINVAL;\r\n}\r\nstatus = gpiod_request(desc, "sysfs");\r\nif (status < 0) {\r\nif (status == -EPROBE_DEFER)\r\nstatus = -ENODEV;\r\ngoto done;\r\n}\r\nstatus = gpiod_export(desc, true);\r\nif (status < 0)\r\ngpiod_free(desc);\r\nelse\r\nset_bit(FLAG_SYSFS, &desc->flags);\r\ndone:\r\nif (status)\r\npr_debug("%s: status %d\n", __func__, status);\r\nreturn status ? : len;\r\n}\r\nstatic ssize_t unexport_store(struct class *class,\r\nstruct class_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nlong gpio;\r\nstruct gpio_desc *desc;\r\nint status;\r\nstatus = kstrtol(buf, 0, &gpio);\r\nif (status < 0)\r\ngoto done;\r\ndesc = gpio_to_desc(gpio);\r\nif (!desc) {\r\npr_warn("%s: invalid GPIO %ld\n", __func__, gpio);\r\nreturn -EINVAL;\r\n}\r\nstatus = -EINVAL;\r\nif (test_and_clear_bit(FLAG_SYSFS, &desc->flags)) {\r\nstatus = 0;\r\ngpiod_free(desc);\r\n}\r\ndone:\r\nif (status)\r\npr_debug("%s: status %d\n", __func__, status);\r\nreturn status ? : len;\r\n}\r\nint gpiod_export(struct gpio_desc *desc, bool direction_may_change)\r\n{\r\nunsigned long flags;\r\nint status;\r\nconst char *ioname = NULL;\r\nstruct device *dev;\r\nint offset;\r\nif (!gpio_class.p) {\r\npr_debug("%s: called too early!\n", __func__);\r\nreturn -ENOENT;\r\n}\r\nif (!desc) {\r\npr_debug("%s: invalid gpio descriptor\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&sysfs_lock);\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nif (!test_bit(FLAG_REQUESTED, &desc->flags) ||\r\ntest_bit(FLAG_EXPORT, &desc->flags)) {\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\ngpiod_dbg(desc, "%s: unavailable (requested=%d, exported=%d)\n",\r\n__func__,\r\ntest_bit(FLAG_REQUESTED, &desc->flags),\r\ntest_bit(FLAG_EXPORT, &desc->flags));\r\nstatus = -EPERM;\r\ngoto fail_unlock;\r\n}\r\nif (desc->chip->direction_input && desc->chip->direction_output &&\r\ndirection_may_change) {\r\nset_bit(FLAG_SYSFS_DIR, &desc->flags);\r\n}\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\noffset = gpio_chip_hwgpio(desc);\r\nif (desc->chip->names && desc->chip->names[offset])\r\nioname = desc->chip->names[offset];\r\ndev = device_create_with_groups(&gpio_class, desc->chip->dev,\r\nMKDEV(0, 0), desc, gpio_groups,\r\nioname ? ioname : "gpio%u",\r\ndesc_to_gpio(desc));\r\nif (IS_ERR(dev)) {\r\nstatus = PTR_ERR(dev);\r\ngoto fail_unlock;\r\n}\r\nset_bit(FLAG_EXPORT, &desc->flags);\r\nmutex_unlock(&sysfs_lock);\r\nreturn 0;\r\nfail_unlock:\r\nmutex_unlock(&sysfs_lock);\r\ngpiod_dbg(desc, "%s: status %d\n", __func__, status);\r\nreturn status;\r\n}\r\nstatic int match_export(struct device *dev, const void *data)\r\n{\r\nreturn dev_get_drvdata(dev) == data;\r\n}\r\nint gpiod_export_link(struct device *dev, const char *name,\r\nstruct gpio_desc *desc)\r\n{\r\nint status = -EINVAL;\r\nif (!desc) {\r\npr_warn("%s: invalid GPIO\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&sysfs_lock);\r\nif (test_bit(FLAG_EXPORT, &desc->flags)) {\r\nstruct device *tdev;\r\ntdev = class_find_device(&gpio_class, NULL, desc, match_export);\r\nif (tdev != NULL) {\r\nstatus = sysfs_create_link(&dev->kobj, &tdev->kobj,\r\nname);\r\nput_device(tdev);\r\n} else {\r\nstatus = -ENODEV;\r\n}\r\n}\r\nmutex_unlock(&sysfs_lock);\r\nif (status)\r\ngpiod_dbg(desc, "%s: status %d\n", __func__, status);\r\nreturn status;\r\n}\r\nint gpiod_sysfs_set_active_low(struct gpio_desc *desc, int value)\r\n{\r\nstruct device *dev = NULL;\r\nint status = -EINVAL;\r\nif (!desc) {\r\npr_warn("%s: invalid GPIO\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&sysfs_lock);\r\nif (test_bit(FLAG_EXPORT, &desc->flags)) {\r\ndev = class_find_device(&gpio_class, NULL, desc, match_export);\r\nif (dev == NULL) {\r\nstatus = -ENODEV;\r\ngoto unlock;\r\n}\r\n}\r\nstatus = sysfs_set_active_low(desc, dev, value);\r\nput_device(dev);\r\nunlock:\r\nmutex_unlock(&sysfs_lock);\r\nif (status)\r\ngpiod_dbg(desc, "%s: status %d\n", __func__, status);\r\nreturn status;\r\n}\r\nvoid gpiod_unexport(struct gpio_desc *desc)\r\n{\r\nint status = 0;\r\nstruct device *dev = NULL;\r\nif (!desc) {\r\npr_warn("%s: invalid GPIO\n", __func__);\r\nreturn;\r\n}\r\nmutex_lock(&sysfs_lock);\r\nif (test_bit(FLAG_EXPORT, &desc->flags)) {\r\ndev = class_find_device(&gpio_class, NULL, desc, match_export);\r\nif (dev) {\r\ngpio_setup_irq(desc, dev, 0);\r\nclear_bit(FLAG_SYSFS_DIR, &desc->flags);\r\nclear_bit(FLAG_EXPORT, &desc->flags);\r\n} else\r\nstatus = -ENODEV;\r\n}\r\nmutex_unlock(&sysfs_lock);\r\nif (dev) {\r\ndevice_unregister(dev);\r\nput_device(dev);\r\n}\r\nif (status)\r\ngpiod_dbg(desc, "%s: status %d\n", __func__, status);\r\n}\r\nint gpiochip_export(struct gpio_chip *chip)\r\n{\r\nint status;\r\nstruct device *dev;\r\nif (!gpio_class.p)\r\nreturn 0;\r\nmutex_lock(&sysfs_lock);\r\ndev = device_create_with_groups(&gpio_class, chip->dev, MKDEV(0, 0),\r\nchip, gpiochip_groups,\r\n"gpiochip%d", chip->base);\r\nif (IS_ERR(dev))\r\nstatus = PTR_ERR(dev);\r\nelse\r\nstatus = 0;\r\nchip->exported = (status == 0);\r\nmutex_unlock(&sysfs_lock);\r\nif (status)\r\nchip_dbg(chip, "%s: status %d\n", __func__, status);\r\nreturn status;\r\n}\r\nvoid gpiochip_unexport(struct gpio_chip *chip)\r\n{\r\nint status;\r\nstruct device *dev;\r\nmutex_lock(&sysfs_lock);\r\ndev = class_find_device(&gpio_class, NULL, chip, match_export);\r\nif (dev) {\r\nput_device(dev);\r\ndevice_unregister(dev);\r\nchip->exported = false;\r\nstatus = 0;\r\n} else\r\nstatus = -ENODEV;\r\nmutex_unlock(&sysfs_lock);\r\nif (status)\r\nchip_dbg(chip, "%s: status %d\n", __func__, status);\r\n}\r\nstatic int __init gpiolib_sysfs_init(void)\r\n{\r\nint status;\r\nunsigned long flags;\r\nstruct gpio_chip *chip;\r\nstatus = class_register(&gpio_class);\r\nif (status < 0)\r\nreturn status;\r\nspin_lock_irqsave(&gpio_lock, flags);\r\nlist_for_each_entry(chip, &gpio_chips, list) {\r\nif (chip->exported)\r\ncontinue;\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nstatus = gpiochip_export(chip);\r\nspin_lock_irqsave(&gpio_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&gpio_lock, flags);\r\nreturn status;\r\n}
