void pvclock_set_flags(u8 flags)\r\n{\r\nvalid_flags = flags;\r\n}\r\nunsigned long pvclock_tsc_khz(struct pvclock_vcpu_time_info *src)\r\n{\r\nu64 pv_tsc_khz = 1000000ULL << 32;\r\ndo_div(pv_tsc_khz, src->tsc_to_system_mul);\r\nif (src->tsc_shift < 0)\r\npv_tsc_khz <<= -src->tsc_shift;\r\nelse\r\npv_tsc_khz >>= src->tsc_shift;\r\nreturn pv_tsc_khz;\r\n}\r\nvoid pvclock_touch_watchdogs(void)\r\n{\r\ntouch_softlockup_watchdog_sync();\r\nclocksource_touch_watchdog();\r\nrcu_cpu_stall_reset();\r\nreset_hung_task_detector();\r\n}\r\nvoid pvclock_resume(void)\r\n{\r\natomic64_set(&last_value, 0);\r\n}\r\nu8 pvclock_read_flags(struct pvclock_vcpu_time_info *src)\r\n{\r\nunsigned version;\r\ncycle_t ret;\r\nu8 flags;\r\ndo {\r\nversion = __pvclock_read_cycles(src, &ret, &flags);\r\n} while ((src->version & 1) || version != src->version);\r\nreturn flags & valid_flags;\r\n}\r\ncycle_t pvclock_clocksource_read(struct pvclock_vcpu_time_info *src)\r\n{\r\nunsigned version;\r\ncycle_t ret;\r\nu64 last;\r\nu8 flags;\r\ndo {\r\nversion = __pvclock_read_cycles(src, &ret, &flags);\r\n} while ((src->version & 1) || version != src->version);\r\nif (unlikely((flags & PVCLOCK_GUEST_STOPPED) != 0)) {\r\nsrc->flags &= ~PVCLOCK_GUEST_STOPPED;\r\npvclock_touch_watchdogs();\r\n}\r\nif ((valid_flags & PVCLOCK_TSC_STABLE_BIT) &&\r\n(flags & PVCLOCK_TSC_STABLE_BIT))\r\nreturn ret;\r\nlast = atomic64_read(&last_value);\r\ndo {\r\nif (ret < last)\r\nreturn last;\r\nlast = atomic64_cmpxchg(&last_value, last, ret);\r\n} while (unlikely(last != ret));\r\nreturn ret;\r\n}\r\nvoid pvclock_read_wallclock(struct pvclock_wall_clock *wall_clock,\r\nstruct pvclock_vcpu_time_info *vcpu_time,\r\nstruct timespec *ts)\r\n{\r\nu32 version;\r\nu64 delta;\r\nstruct timespec now;\r\ndo {\r\nversion = wall_clock->version;\r\nrmb();\r\nnow.tv_sec = wall_clock->sec;\r\nnow.tv_nsec = wall_clock->nsec;\r\nrmb();\r\n} while ((wall_clock->version & 1) || (version != wall_clock->version));\r\ndelta = pvclock_clocksource_read(vcpu_time);\r\ndelta += now.tv_sec * (u64)NSEC_PER_SEC + now.tv_nsec;\r\nnow.tv_nsec = do_div(delta, NSEC_PER_SEC);\r\nnow.tv_sec = delta;\r\nset_normalized_timespec(ts, now.tv_sec, now.tv_nsec);\r\n}\r\nint __init pvclock_init_vsyscall(struct pvclock_vsyscall_time_info *i,\r\nint size)\r\n{\r\nint idx;\r\nWARN_ON (size != PVCLOCK_VSYSCALL_NR_PAGES*PAGE_SIZE);\r\nfor (idx = 0; idx <= (PVCLOCK_FIXMAP_END-PVCLOCK_FIXMAP_BEGIN); idx++) {\r\n__set_fixmap(PVCLOCK_FIXMAP_BEGIN + idx,\r\n__pa(i) + (idx*PAGE_SIZE),\r\nPAGE_KERNEL_VVAR);\r\n}\r\nreturn 0;\r\n}
