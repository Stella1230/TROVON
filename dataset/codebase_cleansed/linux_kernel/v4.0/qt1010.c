static int qt1010_readreg(struct qt1010_priv *priv, u8 reg, u8 *val)\r\n{\r\nstruct i2c_msg msg[2] = {\r\n{ .addr = priv->cfg->i2c_address,\r\n.flags = 0, .buf = &reg, .len = 1 },\r\n{ .addr = priv->cfg->i2c_address,\r\n.flags = I2C_M_RD, .buf = val, .len = 1 },\r\n};\r\nif (i2c_transfer(priv->i2c, msg, 2) != 2) {\r\ndev_warn(&priv->i2c->dev, "%s: i2c rd failed reg=%02x\n",\r\nKBUILD_MODNAME, reg);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qt1010_writereg(struct qt1010_priv *priv, u8 reg, u8 val)\r\n{\r\nu8 buf[2] = { reg, val };\r\nstruct i2c_msg msg = { .addr = priv->cfg->i2c_address,\r\n.flags = 0, .buf = buf, .len = 2 };\r\nif (i2c_transfer(priv->i2c, &msg, 1) != 1) {\r\ndev_warn(&priv->i2c->dev, "%s: i2c wr failed reg=%02x\n",\r\nKBUILD_MODNAME, reg);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qt1010_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct qt1010_priv *priv;\r\nint err;\r\nu32 freq, div, mod1, mod2;\r\nu8 i, tmpval, reg05;\r\nqt1010_i2c_oper_t rd[48] = {\r\n{ QT1010_WR, 0x01, 0x80 },\r\n{ QT1010_WR, 0x02, 0x3f },\r\n{ QT1010_WR, 0x05, 0xff },\r\n{ QT1010_WR, 0x06, 0x44 },\r\n{ QT1010_WR, 0x07, 0xff },\r\n{ QT1010_WR, 0x08, 0x08 },\r\n{ QT1010_WR, 0x09, 0xff },\r\n{ QT1010_WR, 0x0a, 0xff },\r\n{ QT1010_WR, 0x0b, 0xff },\r\n{ QT1010_WR, 0x0c, 0xe1 },\r\n{ QT1010_WR, 0x1a, 0xff },\r\n{ QT1010_WR, 0x1b, 0x00 },\r\n{ QT1010_WR, 0x1c, 0x89 },\r\n{ QT1010_WR, 0x11, 0xff },\r\n{ QT1010_WR, 0x12, 0xff },\r\n{ QT1010_WR, 0x22, 0xff },\r\n{ QT1010_WR, 0x1e, 0x00 },\r\n{ QT1010_WR, 0x1e, 0xd0 },\r\n{ QT1010_RD, 0x22, 0xff },\r\n{ QT1010_WR, 0x1e, 0x00 },\r\n{ QT1010_RD, 0x05, 0xff },\r\n{ QT1010_RD, 0x22, 0xff },\r\n{ QT1010_WR, 0x23, 0xd0 },\r\n{ QT1010_WR, 0x1e, 0x00 },\r\n{ QT1010_WR, 0x1e, 0xe0 },\r\n{ QT1010_RD, 0x23, 0xff },\r\n{ QT1010_RD, 0x23, 0xff },\r\n{ QT1010_WR, 0x1e, 0x00 },\r\n{ QT1010_WR, 0x24, 0xd0 },\r\n{ QT1010_WR, 0x1e, 0x00 },\r\n{ QT1010_WR, 0x1e, 0xf0 },\r\n{ QT1010_RD, 0x24, 0xff },\r\n{ QT1010_WR, 0x1e, 0x00 },\r\n{ QT1010_WR, 0x14, 0x7f },\r\n{ QT1010_WR, 0x15, 0x7f },\r\n{ QT1010_WR, 0x05, 0xff },\r\n{ QT1010_WR, 0x06, 0x00 },\r\n{ QT1010_WR, 0x15, 0x1f },\r\n{ QT1010_WR, 0x16, 0xff },\r\n{ QT1010_WR, 0x18, 0xff },\r\n{ QT1010_WR, 0x1f, 0xff },\r\n{ QT1010_WR, 0x20, 0xff },\r\n{ QT1010_WR, 0x21, 0x53 },\r\n{ QT1010_WR, 0x25, 0xff },\r\n{ QT1010_WR, 0x26, 0x15 },\r\n{ QT1010_WR, 0x00, 0xff },\r\n{ QT1010_WR, 0x02, 0x00 },\r\n{ QT1010_WR, 0x01, 0x00 }\r\n};\r\n#define FREQ1 32000000\r\n#define FREQ2 4000000\r\npriv = fe->tuner_priv;\r\nfreq = c->frequency;\r\ndiv = (freq + QT1010_OFFSET) / QT1010_STEP;\r\nfreq = (div * QT1010_STEP) - QT1010_OFFSET;\r\nmod1 = (freq + QT1010_OFFSET) % FREQ1;\r\nmod2 = (freq + QT1010_OFFSET) % FREQ2;\r\npriv->frequency = freq;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (freq < 290000000) reg05 = 0x14;\r\nelse if (freq < 610000000) reg05 = 0x34;\r\nelse if (freq < 802000000) reg05 = 0x54;\r\nelse reg05 = 0x74;\r\nrd[2].val = reg05;\r\nrd[4].val = (freq + QT1010_OFFSET) / FREQ1;\r\nif (mod1 < 8000000) rd[6].val = 0x1d;\r\nelse rd[6].val = 0x1c;\r\nif (mod1 < 1*FREQ2) rd[7].val = 0x09;\r\nelse if (mod1 < 2*FREQ2) rd[7].val = 0x08;\r\nelse if (mod1 < 3*FREQ2) rd[7].val = 0x0f;\r\nelse if (mod1 < 4*FREQ2) rd[7].val = 0x0e;\r\nelse if (mod1 < 5*FREQ2) rd[7].val = 0x0d;\r\nelse if (mod1 < 6*FREQ2) rd[7].val = 0x0c;\r\nelse if (mod1 < 7*FREQ2) rd[7].val = 0x0b;\r\nelse rd[7].val = 0x0a;\r\nif (mod2 < 2000000) rd[8].val = 0x45;\r\nelse rd[8].val = 0x44;\r\ntmpval = 0x78;\r\nrd[10].val = tmpval-((mod2/QT1010_STEP)*0x08);\r\nrd[13].val = 0xfd;\r\nrd[14].val = 0x91;\r\nif (freq < 450000000) rd[15].val = 0xd0;\r\nelse if (freq < 482000000) rd[15].val = 0xd1;\r\nelse if (freq < 514000000) rd[15].val = 0xd4;\r\nelse if (freq < 546000000) rd[15].val = 0xd7;\r\nelse if (freq < 610000000) rd[15].val = 0xda;\r\nelse rd[15].val = 0xd0;\r\nrd[35].val = (reg05 & 0xf0);\r\nif (mod1 < 8000000) tmpval = 0x00;\r\nelse if (mod1 < 12000000) tmpval = 0x01;\r\nelse if (mod1 < 16000000) tmpval = 0x02;\r\nelse if (mod1 < 24000000) tmpval = 0x03;\r\nelse if (mod1 < 28000000) tmpval = 0x04;\r\nelse tmpval = 0x05;\r\nrd[40].val = (priv->reg1f_init_val + 0x0e + tmpval);\r\nif (mod1 < 8000000) tmpval = 0x00;\r\nelse if (mod1 < 12000000) tmpval = 0x01;\r\nelse if (mod1 < 20000000) tmpval = 0x02;\r\nelse if (mod1 < 24000000) tmpval = 0x03;\r\nelse if (mod1 < 28000000) tmpval = 0x04;\r\nelse tmpval = 0x05;\r\nrd[41].val = (priv->reg20_init_val + 0x0d + tmpval);\r\nrd[43].val = priv->reg25_init_val;\r\nrd[45].val = 0x92;\r\ndev_dbg(&priv->i2c->dev,\r\n"%s: freq:%u 05:%02x 07:%02x 09:%02x 0a:%02x 0b:%02x " \\r\n"1a:%02x 11:%02x 12:%02x 22:%02x 05:%02x 1f:%02x " \\r\n"20:%02x 25:%02x 00:%02x\n", __func__, \\r\nfreq, rd[2].val, rd[4].val, rd[6].val, rd[7].val, \\r\nrd[8].val, rd[10].val, rd[13].val, rd[14].val, \\r\nrd[15].val, rd[35].val, rd[40].val, rd[41].val, \\r\nrd[43].val, rd[45].val);\r\nfor (i = 0; i < ARRAY_SIZE(rd); i++) {\r\nif (rd[i].oper == QT1010_WR) {\r\nerr = qt1010_writereg(priv, rd[i].reg, rd[i].val);\r\n} else {\r\nerr = qt1010_readreg(priv, rd[i].reg, &tmpval);\r\n}\r\nif (err) return err;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\n}\r\nstatic int qt1010_init_meas1(struct qt1010_priv *priv,\r\nu8 oper, u8 reg, u8 reg_init_val, u8 *retval)\r\n{\r\nu8 i, val1, val2;\r\nint err;\r\nqt1010_i2c_oper_t i2c_data[] = {\r\n{ QT1010_WR, reg, reg_init_val },\r\n{ QT1010_WR, 0x1e, 0x00 },\r\n{ QT1010_WR, 0x1e, oper },\r\n{ QT1010_RD, reg, 0xff }\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(i2c_data); i++) {\r\nif (i2c_data[i].oper == QT1010_WR) {\r\nerr = qt1010_writereg(priv, i2c_data[i].reg,\r\ni2c_data[i].val);\r\n} else {\r\nerr = qt1010_readreg(priv, i2c_data[i].reg, &val2);\r\n}\r\nif (err) return err;\r\n}\r\ndo {\r\nval1 = val2;\r\nerr = qt1010_readreg(priv, reg, &val2);\r\nif (err) return err;\r\ndev_dbg(&priv->i2c->dev, "%s: compare reg:%02x %02x %02x\n",\r\n__func__, reg, val1, val2);\r\n} while (val1 != val2);\r\n*retval = val1;\r\nreturn qt1010_writereg(priv, 0x1e, 0x00);\r\n}\r\nstatic int qt1010_init_meas2(struct qt1010_priv *priv,\r\nu8 reg_init_val, u8 *retval)\r\n{\r\nu8 i, val;\r\nint err;\r\nqt1010_i2c_oper_t i2c_data[] = {\r\n{ QT1010_WR, 0x07, reg_init_val },\r\n{ QT1010_WR, 0x22, 0xd0 },\r\n{ QT1010_WR, 0x1e, 0x00 },\r\n{ QT1010_WR, 0x1e, 0xd0 },\r\n{ QT1010_RD, 0x22, 0xff },\r\n{ QT1010_WR, 0x1e, 0x00 },\r\n{ QT1010_WR, 0x22, 0xff }\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(i2c_data); i++) {\r\nif (i2c_data[i].oper == QT1010_WR) {\r\nerr = qt1010_writereg(priv, i2c_data[i].reg,\r\ni2c_data[i].val);\r\n} else {\r\nerr = qt1010_readreg(priv, i2c_data[i].reg, &val);\r\n}\r\nif (err) return err;\r\n}\r\n*retval = val;\r\nreturn 0;\r\n}\r\nstatic int qt1010_init(struct dvb_frontend *fe)\r\n{\r\nstruct qt1010_priv *priv = fe->tuner_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint err = 0;\r\nu8 i, tmpval, *valptr = NULL;\r\nqt1010_i2c_oper_t i2c_data[] = {\r\n{ QT1010_WR, 0x01, 0x80 },\r\n{ QT1010_WR, 0x0d, 0x84 },\r\n{ QT1010_WR, 0x0e, 0xb7 },\r\n{ QT1010_WR, 0x2a, 0x23 },\r\n{ QT1010_WR, 0x2c, 0xdc },\r\n{ QT1010_M1, 0x25, 0x40 },\r\n{ QT1010_M1, 0x81, 0xff },\r\n{ QT1010_WR, 0x2b, 0x70 },\r\n{ QT1010_WR, 0x2a, 0x23 },\r\n{ QT1010_M1, 0x26, 0x08 },\r\n{ QT1010_M1, 0x82, 0xff },\r\n{ QT1010_WR, 0x05, 0x14 },\r\n{ QT1010_WR, 0x06, 0x44 },\r\n{ QT1010_WR, 0x07, 0x28 },\r\n{ QT1010_WR, 0x08, 0x0b },\r\n{ QT1010_WR, 0x11, 0xfd },\r\n{ QT1010_M1, 0x22, 0x0d },\r\n{ QT1010_M1, 0xd0, 0xff },\r\n{ QT1010_WR, 0x06, 0x40 },\r\n{ QT1010_WR, 0x16, 0xf0 },\r\n{ QT1010_WR, 0x02, 0x38 },\r\n{ QT1010_WR, 0x03, 0x18 },\r\n{ QT1010_WR, 0x20, 0xe0 },\r\n{ QT1010_M1, 0x1f, 0x20 },\r\n{ QT1010_M1, 0x84, 0xff },\r\n{ QT1010_RD, 0x20, 0x20 },\r\n{ QT1010_WR, 0x03, 0x19 },\r\n{ QT1010_WR, 0x02, 0x3f },\r\n{ QT1010_WR, 0x21, 0x53 },\r\n{ QT1010_RD, 0x21, 0xff },\r\n{ QT1010_WR, 0x11, 0xfd },\r\n{ QT1010_WR, 0x05, 0x34 },\r\n{ QT1010_WR, 0x06, 0x44 },\r\n{ QT1010_WR, 0x08, 0x08 }\r\n};\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nfor (i = 0; i < ARRAY_SIZE(i2c_data); i++) {\r\nswitch (i2c_data[i].oper) {\r\ncase QT1010_WR:\r\nerr = qt1010_writereg(priv, i2c_data[i].reg,\r\ni2c_data[i].val);\r\nbreak;\r\ncase QT1010_RD:\r\nif (i2c_data[i].val == 0x20)\r\nvalptr = &priv->reg20_init_val;\r\nelse\r\nvalptr = &tmpval;\r\nerr = qt1010_readreg(priv, i2c_data[i].reg, valptr);\r\nbreak;\r\ncase QT1010_M1:\r\nif (i2c_data[i].val == 0x25)\r\nvalptr = &priv->reg25_init_val;\r\nelse if (i2c_data[i].val == 0x1f)\r\nvalptr = &priv->reg1f_init_val;\r\nelse\r\nvalptr = &tmpval;\r\nerr = qt1010_init_meas1(priv, i2c_data[i+1].reg,\r\ni2c_data[i].reg,\r\ni2c_data[i].val, valptr);\r\ni++;\r\nbreak;\r\n}\r\nif (err) return err;\r\n}\r\nfor (i = 0x31; i < 0x3a; i++)\r\nif ((err = qt1010_init_meas2(priv, i, &tmpval)))\r\nreturn err;\r\nif (!c->frequency)\r\nc->frequency = 545000000;\r\nreturn qt1010_set_params(fe);\r\n}\r\nstatic int qt1010_release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nstatic int qt1010_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct qt1010_priv *priv = fe->tuner_priv;\r\n*frequency = priv->frequency;\r\nreturn 0;\r\n}\r\nstatic int qt1010_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\n*frequency = 36125000;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend * qt1010_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c,\r\nstruct qt1010_config *cfg)\r\n{\r\nstruct qt1010_priv *priv = NULL;\r\nu8 id;\r\npriv = kzalloc(sizeof(struct qt1010_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\npriv->cfg = cfg;\r\npriv->i2c = i2c;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (qt1010_readreg(priv, 0x29, &id) != 0 || (id != 0x39)) {\r\nkfree(priv);\r\nreturn NULL;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\ndev_info(&priv->i2c->dev,\r\n"%s: Quantek QT1010 successfully identified\n",\r\nKBUILD_MODNAME);\r\nmemcpy(&fe->ops.tuner_ops, &qt1010_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = priv;\r\nreturn fe;\r\n}
