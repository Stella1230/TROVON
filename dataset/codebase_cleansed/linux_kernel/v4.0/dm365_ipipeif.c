static int\r\nipipeif_get_pack_mode(u32 in_pix_fmt)\r\n{\r\nswitch (in_pix_fmt) {\r\ncase MEDIA_BUS_FMT_SBGGR8_1X8:\r\ncase MEDIA_BUS_FMT_Y8_1X8:\r\ncase MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8:\r\ncase MEDIA_BUS_FMT_UV8_1X8:\r\nreturn IPIPEIF_5_1_PACK_8_BIT;\r\ncase MEDIA_BUS_FMT_SGRBG10_ALAW8_1X8:\r\nreturn IPIPEIF_5_1_PACK_8_BIT_A_LAW;\r\ncase MEDIA_BUS_FMT_SGRBG12_1X12:\r\nreturn IPIPEIF_5_1_PACK_16_BIT;\r\ncase MEDIA_BUS_FMT_SBGGR12_1X12:\r\nreturn IPIPEIF_5_1_PACK_12_BIT;\r\ndefault:\r\nreturn IPIPEIF_5_1_PACK_16_BIT;\r\n}\r\n}\r\nstatic inline u32 ipipeif_read(void *addr, u32 offset)\r\n{\r\nreturn readl(addr + offset);\r\n}\r\nstatic inline void ipipeif_write(u32 val, void *addr, u32 offset)\r\n{\r\nwritel(val, addr + offset);\r\n}\r\nstatic void ipipeif_config_dpc(void *addr, struct ipipeif_dpc *dpc)\r\n{\r\nu32 val = 0;\r\nif (dpc->en) {\r\nval = (dpc->en & 1) << IPIPEIF_DPC2_EN_SHIFT;\r\nval |= dpc->thr & IPIPEIF_DPC2_THR_MASK;\r\n}\r\nipipeif_write(val, addr, IPIPEIF_DPC2);\r\n}\r\nstatic int get_oneshot_mode(enum ipipeif_input_entity input)\r\n{\r\nif (input == IPIPEIF_INPUT_MEMORY)\r\nreturn IPIPEIF_MODE_ONE_SHOT;\r\nelse if (input == IPIPEIF_INPUT_ISIF)\r\nreturn IPIPEIF_MODE_CONTINUOUS;\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nipipeif_get_cfg_src1(struct vpfe_ipipeif_device *ipipeif)\r\n{\r\nstruct v4l2_mbus_framefmt *informat;\r\ninformat = &ipipeif->formats[IPIPEIF_PAD_SINK];\r\nif (ipipeif->input == IPIPEIF_INPUT_MEMORY &&\r\n(informat->code == MEDIA_BUS_FMT_Y8_1X8 ||\r\ninformat->code == MEDIA_BUS_FMT_UV8_1X8))\r\nreturn IPIPEIF_CCDC;\r\nreturn IPIPEIF_SRC1_PARALLEL_PORT;\r\n}\r\nstatic int\r\nipipeif_get_data_shift(struct vpfe_ipipeif_device *ipipeif)\r\n{\r\nstruct v4l2_mbus_framefmt *informat;\r\ninformat = &ipipeif->formats[IPIPEIF_PAD_SINK];\r\nswitch (informat->code) {\r\ncase MEDIA_BUS_FMT_SGRBG12_1X12:\r\nreturn IPIPEIF_5_1_BITS11_0;\r\ncase MEDIA_BUS_FMT_Y8_1X8:\r\ncase MEDIA_BUS_FMT_UV8_1X8:\r\nreturn IPIPEIF_5_1_BITS11_0;\r\ndefault:\r\nreturn IPIPEIF_5_1_BITS7_0;\r\n}\r\n}\r\nstatic enum ipipeif_input_source\r\nipipeif_get_source(struct vpfe_ipipeif_device *ipipeif)\r\n{\r\nstruct v4l2_mbus_framefmt *informat;\r\ninformat = &ipipeif->formats[IPIPEIF_PAD_SINK];\r\nif (ipipeif->input == IPIPEIF_INPUT_ISIF)\r\nreturn IPIPEIF_CCDC;\r\nif (informat->code == MEDIA_BUS_FMT_UYVY8_2X8)\r\nreturn IPIPEIF_SDRAM_YUV;\r\nreturn IPIPEIF_SDRAM_RAW;\r\n}\r\nvoid vpfe_ipipeif_ss_buffer_isr(struct vpfe_ipipeif_device *ipipeif)\r\n{\r\nstruct vpfe_video_device *video_in = &ipipeif->video_in;\r\nif (ipipeif->input != IPIPEIF_INPUT_MEMORY)\r\nreturn;\r\nspin_lock(&video_in->dma_queue_lock);\r\nvpfe_video_process_buffer_complete(video_in);\r\nvideo_in->state = VPFE_VIDEO_BUFFER_NOT_QUEUED;\r\nvpfe_video_schedule_next_buffer(video_in);\r\nspin_unlock(&video_in->dma_queue_lock);\r\n}\r\nint vpfe_ipipeif_decimation_enabled(struct vpfe_device *vpfe_dev)\r\n{\r\nstruct vpfe_ipipeif_device *ipipeif = &vpfe_dev->vpfe_ipipeif;\r\nreturn ipipeif->config.decimation;\r\n}\r\nint vpfe_ipipeif_get_rsz(struct vpfe_device *vpfe_dev)\r\n{\r\nstruct vpfe_ipipeif_device *ipipeif = &vpfe_dev->vpfe_ipipeif;\r\nreturn ipipeif->config.rsz;\r\n}\r\nstatic int ipipeif_hw_setup(struct v4l2_subdev *sd)\r\n{\r\nstruct vpfe_ipipeif_device *ipipeif = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *informat, *outformat;\r\nstruct ipipeif_params params = ipipeif->config;\r\nenum ipipeif_input_source ipipeif_source;\r\nu32 isif_port_if;\r\nvoid *ipipeif_base_addr;\r\nunsigned int val;\r\nint data_shift;\r\nint pack_mode;\r\nint source1;\r\nint tmp;\r\nipipeif_base_addr = ipipeif->ipipeif_base_addr;\r\nvpss_enable_clock(VPSS_IPIPEIF_CLOCK, 1);\r\ninformat = &ipipeif->formats[IPIPEIF_PAD_SINK];\r\noutformat = &ipipeif->formats[IPIPEIF_PAD_SOURCE];\r\ntmp = val = get_oneshot_mode(ipipeif->input);\r\nif (tmp < 0) {\r\npr_err("ipipeif: links setup required");\r\nreturn -EINVAL;\r\n}\r\nval = val << ONESHOT_SHIFT;\r\nipipeif_source = ipipeif_get_source(ipipeif);\r\nval |= ipipeif_source << INPSRC_SHIFT;\r\nval |= params.clock_select << CLKSEL_SHIFT;\r\nval |= params.avg_filter << AVGFILT_SHIFT;\r\nval |= params.decimation << DECIM_SHIFT;\r\npack_mode = ipipeif_get_pack_mode(informat->code);\r\nval |= pack_mode << PACK8IN_SHIFT;\r\nsource1 = ipipeif_get_cfg_src1(ipipeif);\r\nval |= source1 << INPSRC1_SHIFT;\r\ndata_shift = ipipeif_get_data_shift(ipipeif);\r\nif (ipipeif_source != IPIPEIF_SDRAM_YUV)\r\nval |= data_shift << DATASFT_SHIFT;\r\nelse\r\nval &= ~(RD_DATA_15_2 << DATASFT_SHIFT);\r\nipipeif_write(val, ipipeif_base_addr, IPIPEIF_CFG1);\r\nswitch (ipipeif_source) {\r\ncase IPIPEIF_CCDC:\r\nipipeif_write(ipipeif->gain, ipipeif_base_addr, IPIPEIF_GAIN);\r\nbreak;\r\ncase IPIPEIF_SDRAM_RAW:\r\ncase IPIPEIF_CCDC_DARKFM:\r\nipipeif_write(ipipeif->gain, ipipeif_base_addr, IPIPEIF_GAIN);\r\ncase IPIPEIF_SDRAM_YUV:\r\nval |= data_shift << DATASFT_SHIFT;\r\nipipeif_write(params.ppln, ipipeif_base_addr, IPIPEIF_PPLN);\r\nipipeif_write(params.lpfr, ipipeif_base_addr, IPIPEIF_LPFR);\r\nipipeif_write(informat->width, ipipeif_base_addr, IPIPEIF_HNUM);\r\nipipeif_write(informat->height,\r\nipipeif_base_addr, IPIPEIF_VNUM);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (params.decimation)\r\nipipeif_write(params.rsz, ipipeif_base_addr, IPIPEIF_RSZ);\r\nval = params.if_5_1.align_sync & 1;\r\nval <<= IPIPEIF_INIRSZ_ALNSYNC_SHIFT;\r\nval |= params.if_5_1.rsz_start & IPIPEIF_INIRSZ_MASK;\r\nipipeif_write(val, ipipeif_base_addr, IPIPEIF_INIRSZ);\r\nisif_port_if = informat->code;\r\nif (isif_port_if == MEDIA_BUS_FMT_Y8_1X8)\r\nisif_port_if = MEDIA_BUS_FMT_YUYV8_1X16;\r\nelse if (isif_port_if == MEDIA_BUS_FMT_UV8_1X8)\r\nisif_port_if = MEDIA_BUS_FMT_SGRBG12_1X12;\r\nswitch (ipipeif_source) {\r\ncase IPIPEIF_SDRAM_RAW:\r\nval = 0;\r\nif (outformat->code == MEDIA_BUS_FMT_SGRBG10_DPCM8_1X8) {\r\nval = 1;\r\nval |= (IPIPEIF_DPCM_8BIT_10BIT & 1) <<\r\nIPIPEIF_DPCM_BITS_SHIFT;\r\nval |= (ipipeif->dpcm_predictor & 1) <<\r\nIPIPEIF_DPCM_PRED_SHIFT;\r\n}\r\nipipeif_write(val, ipipeif_base_addr, IPIPEIF_DPCM);\r\nipipeif_config_dpc(ipipeif_base_addr, &params.if_5_1.dpc);\r\nipipeif_write(params.if_5_1.clip,\r\nipipeif_base_addr, IPIPEIF_OCLIP);\r\nval = ipipeif_read(ipipeif_base_addr, IPIPEIF_CFG2);\r\nswitch (isif_port_if) {\r\ncase MEDIA_BUS_FMT_YUYV8_1X16:\r\ncase MEDIA_BUS_FMT_UYVY8_2X8:\r\ncase MEDIA_BUS_FMT_Y8_1X8:\r\nRESETBIT(val, IPIPEIF_CFG2_YUV8_SHIFT);\r\nSETBIT(val, IPIPEIF_CFG2_YUV16_SHIFT);\r\nipipeif_write(val, ipipeif_base_addr, IPIPEIF_CFG2);\r\nbreak;\r\ndefault:\r\nRESETBIT(val, IPIPEIF_CFG2_YUV8_SHIFT);\r\nRESETBIT(val, IPIPEIF_CFG2_YUV16_SHIFT);\r\nipipeif_write(val, ipipeif_base_addr, IPIPEIF_CFG2);\r\nbreak;\r\n}\r\ncase IPIPEIF_SDRAM_YUV:\r\nif (params.clock_select == IPIPEIF_SDRAM_CLK) {\r\nval = ipipeif_read(ipipeif_base_addr, IPIPEIF_CLKDIV);\r\nval |= (params.if_5_1.clk_div.m - 1) <<\r\nIPIPEIF_CLKDIV_M_SHIFT;\r\nval |= (params.if_5_1.clk_div.n - 1);\r\nipipeif_write(val, ipipeif_base_addr, IPIPEIF_CLKDIV);\r\n}\r\nbreak;\r\ncase IPIPEIF_CCDC:\r\ncase IPIPEIF_CCDC_DARKFM:\r\nipipeif_config_dpc(ipipeif_base_addr, &params.if_5_1.dpc);\r\nval = 0;\r\nif (params.if_5_1.df_gain_en) {\r\nval = params.if_5_1.df_gain_thr &\r\nIPIPEIF_DF_GAIN_THR_MASK;\r\nipipeif_write(val, ipipeif_base_addr, IPIPEIF_DFSGTH);\r\nval = (params.if_5_1.df_gain_en & 1) <<\r\nIPIPEIF_DF_GAIN_EN_SHIFT;\r\nval |= params.if_5_1.df_gain &\r\nIPIPEIF_DF_GAIN_MASK;\r\n}\r\nipipeif_write(val, ipipeif_base_addr, IPIPEIF_DFSGVL);\r\nval = VPFE_PINPOL_POSITIVE << IPIPEIF_CFG2_HDPOL_SHIFT;\r\nval |= VPFE_PINPOL_POSITIVE << IPIPEIF_CFG2_VDPOL_SHIFT;\r\nswitch (isif_port_if) {\r\ncase MEDIA_BUS_FMT_YUYV8_1X16:\r\ncase MEDIA_BUS_FMT_YUYV10_1X20:\r\nRESETBIT(val, IPIPEIF_CFG2_YUV8_SHIFT);\r\nSETBIT(val, IPIPEIF_CFG2_YUV16_SHIFT);\r\nbreak;\r\ncase MEDIA_BUS_FMT_YUYV8_2X8:\r\ncase MEDIA_BUS_FMT_UYVY8_2X8:\r\ncase MEDIA_BUS_FMT_Y8_1X8:\r\ncase MEDIA_BUS_FMT_YUYV10_2X10:\r\nSETBIT(val, IPIPEIF_CFG2_YUV8_SHIFT);\r\nSETBIT(val, IPIPEIF_CFG2_YUV16_SHIFT);\r\nval |= IPIPEIF_CBCR_Y << IPIPEIF_CFG2_YUV8P_SHIFT;\r\nbreak;\r\ndefault:\r\nipipeif_write(params.if_5_1.clip, ipipeif_base_addr,\r\nIPIPEIF_OCLIP);\r\n}\r\nipipeif_write(val, ipipeif_base_addr, IPIPEIF_CFG2);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nipipeif_set_config(struct v4l2_subdev *sd, struct ipipeif_params *config)\r\n{\r\nstruct vpfe_ipipeif_device *ipipeif = v4l2_get_subdevdata(sd);\r\nstruct device *dev = ipipeif->subdev.v4l2_dev->dev;\r\nif (!config) {\r\ndev_err(dev, "Invalid configuration pointer\n");\r\nreturn -EINVAL;\r\n}\r\nipipeif->config.clock_select = config->clock_select;\r\nipipeif->config.ppln = config->ppln;\r\nipipeif->config.lpfr = config->lpfr;\r\nipipeif->config.rsz = config->rsz;\r\nipipeif->config.decimation = config->decimation;\r\nif (ipipeif->config.decimation &&\r\n(ipipeif->config.rsz < IPIPEIF_RSZ_MIN ||\r\nipipeif->config.rsz > IPIPEIF_RSZ_MAX)) {\r\ndev_err(dev, "rsz range is %d to %d\n",\r\nIPIPEIF_RSZ_MIN, IPIPEIF_RSZ_MAX);\r\nreturn -EINVAL;\r\n}\r\nipipeif->config.avg_filter = config->avg_filter;\r\nipipeif->config.if_5_1.df_gain_thr = config->if_5_1.df_gain_thr;\r\nipipeif->config.if_5_1.df_gain = config->if_5_1.df_gain;\r\nipipeif->config.if_5_1.df_gain_en = config->if_5_1.df_gain_en;\r\nipipeif->config.if_5_1.rsz_start = config->if_5_1.rsz_start;\r\nipipeif->config.if_5_1.align_sync = config->if_5_1.align_sync;\r\nipipeif->config.if_5_1.clip = config->if_5_1.clip;\r\nipipeif->config.if_5_1.dpc.en = config->if_5_1.dpc.en;\r\nipipeif->config.if_5_1.dpc.thr = config->if_5_1.dpc.thr;\r\nipipeif->config.if_5_1.clk_div.m = config->if_5_1.clk_div.m;\r\nipipeif->config.if_5_1.clk_div.n = config->if_5_1.clk_div.n;\r\nreturn 0;\r\n}\r\nstatic int\r\nipipeif_get_config(struct v4l2_subdev *sd, void __user *arg)\r\n{\r\nstruct vpfe_ipipeif_device *ipipeif = v4l2_get_subdevdata(sd);\r\nstruct ipipeif_params *config = arg;\r\nstruct device *dev = ipipeif->subdev.v4l2_dev->dev;\r\nif (!arg) {\r\ndev_err(dev, "Invalid configuration pointer\n");\r\nreturn -EINVAL;\r\n}\r\nconfig->clock_select = ipipeif->config.clock_select;\r\nconfig->ppln = ipipeif->config.ppln;\r\nconfig->lpfr = ipipeif->config.lpfr;\r\nconfig->rsz = ipipeif->config.rsz;\r\nconfig->decimation = ipipeif->config.decimation;\r\nconfig->avg_filter = ipipeif->config.avg_filter;\r\nconfig->if_5_1.df_gain_thr = ipipeif->config.if_5_1.df_gain_thr;\r\nconfig->if_5_1.df_gain = ipipeif->config.if_5_1.df_gain;\r\nconfig->if_5_1.df_gain_en = ipipeif->config.if_5_1.df_gain_en;\r\nconfig->if_5_1.rsz_start = ipipeif->config.if_5_1.rsz_start;\r\nconfig->if_5_1.align_sync = ipipeif->config.if_5_1.align_sync;\r\nconfig->if_5_1.clip = ipipeif->config.if_5_1.clip;\r\nconfig->if_5_1.dpc.en = ipipeif->config.if_5_1.dpc.en;\r\nconfig->if_5_1.dpc.thr = ipipeif->config.if_5_1.dpc.thr;\r\nconfig->if_5_1.clk_div.m = ipipeif->config.if_5_1.clk_div.m;\r\nconfig->if_5_1.clk_div.n = ipipeif->config.if_5_1.clk_div.n;\r\nreturn 0;\r\n}\r\nstatic long ipipeif_ioctl(struct v4l2_subdev *sd,\r\nunsigned int cmd, void *arg)\r\n{\r\nstruct ipipeif_params *config = arg;\r\nint ret = -ENOIOCTLCMD;\r\nswitch (cmd) {\r\ncase VIDIOC_VPFE_IPIPEIF_S_CONFIG:\r\nret = ipipeif_set_config(sd, config);\r\nbreak;\r\ncase VIDIOC_VPFE_IPIPEIF_G_CONFIG:\r\nret = ipipeif_get_config(sd, arg);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ipipeif_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct vpfe_ipipeif_device *ipipeif =\r\ncontainer_of(ctrl->handler, struct vpfe_ipipeif_device, ctrls);\r\nswitch (ctrl->id) {\r\ncase VPFE_CID_DPCM_PREDICTOR:\r\nipipeif->dpcm_predictor = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_GAIN:\r\nipipeif->gain = ctrl->val;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid vpfe_ipipeif_enable(struct vpfe_device *vpfe_dev)\r\n{\r\nstruct vpfe_ipipeif_device *ipipeif = &vpfe_dev->vpfe_ipipeif;\r\nvoid *ipipeif_base_addr = ipipeif->ipipeif_base_addr;\r\nunsigned char val;\r\nif (ipipeif->input != IPIPEIF_INPUT_MEMORY)\r\nreturn;\r\ndo {\r\nval = ipipeif_read(ipipeif_base_addr, IPIPEIF_ENABLE);\r\n} while (val & 0x1);\r\nipipeif_write(ENABLE_IPIPEIF, ipipeif_base_addr, IPIPEIF_ENABLE);\r\n}\r\nstatic int ipipeif_set_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct vpfe_ipipeif_device *ipipeif = v4l2_get_subdevdata(sd);\r\nstruct vpfe_device *vpfe_dev = to_vpfe_device(ipipeif);\r\nint ret = 0;\r\nif (!enable)\r\nreturn ret;\r\nret = ipipeif_hw_setup(sd);\r\nif (!ret)\r\nvpfe_ipipeif_enable(vpfe_dev);\r\nreturn ret;\r\n}\r\nstatic int ipipeif_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nswitch (code->pad) {\r\ncase IPIPEIF_PAD_SINK:\r\nif (code->index >= ARRAY_SIZE(ipipeif_input_fmts))\r\nreturn -EINVAL;\r\ncode->code = ipipeif_input_fmts[code->index];\r\nbreak;\r\ncase IPIPEIF_PAD_SOURCE:\r\nif (code->index >= ARRAY_SIZE(ipipeif_output_fmts))\r\nreturn -EINVAL;\r\ncode->code = ipipeif_output_fmts[code->index];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nipipeif_get_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct vpfe_ipipeif_device *ipipeif = v4l2_get_subdevdata(sd);\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\nfmt->format = ipipeif->formats[fmt->pad];\r\nelse\r\nfmt->format = *(v4l2_subdev_get_try_format(fh, fmt->pad));\r\nreturn 0;\r\n}\r\nstatic void\r\nipipeif_try_format(struct vpfe_ipipeif_device *ipipeif,\r\nstruct v4l2_subdev_fh *fh, unsigned int pad,\r\nstruct v4l2_mbus_framefmt *fmt,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nunsigned int max_out_height;\r\nunsigned int max_out_width;\r\nunsigned int i;\r\nmax_out_width = IPIPE_MAX_OUTPUT_WIDTH_A;\r\nmax_out_height = IPIPE_MAX_OUTPUT_HEIGHT_A;\r\nif (pad == IPIPEIF_PAD_SINK) {\r\nfor (i = 0; i < ARRAY_SIZE(ipipeif_input_fmts); i++)\r\nif (fmt->code == ipipeif_input_fmts[i])\r\nbreak;\r\nif (i >= ARRAY_SIZE(ipipeif_input_fmts))\r\nfmt->code = MEDIA_BUS_FMT_SGRBG12_1X12;\r\n} else if (pad == IPIPEIF_PAD_SOURCE) {\r\nfor (i = 0; i < ARRAY_SIZE(ipipeif_output_fmts); i++)\r\nif (fmt->code == ipipeif_output_fmts[i])\r\nbreak;\r\nif (i >= ARRAY_SIZE(ipipeif_output_fmts))\r\nfmt->code = MEDIA_BUS_FMT_UYVY8_2X8;\r\n}\r\nfmt->width = clamp_t(u32, fmt->width, MIN_OUT_HEIGHT, max_out_width);\r\nfmt->height = clamp_t(u32, fmt->height, MIN_OUT_WIDTH, max_out_height);\r\n}\r\nstatic int\r\nipipeif_enum_frame_size(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct vpfe_ipipeif_device *ipipeif = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt format;\r\nif (fse->index != 0)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = 1;\r\nformat.height = 1;\r\nipipeif_try_format(ipipeif, fh, fse->pad, &format,\r\nV4L2_SUBDEV_FORMAT_TRY);\r\nfse->min_width = format.width;\r\nfse->min_height = format.height;\r\nif (format.code != fse->code)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = -1;\r\nformat.height = -1;\r\nipipeif_try_format(ipipeif, fh, fse->pad, &format,\r\nV4L2_SUBDEV_FORMAT_TRY);\r\nfse->max_width = format.width;\r\nfse->max_height = format.height;\r\nreturn 0;\r\n}\r\nstatic struct v4l2_mbus_framefmt *\r\n__ipipeif_get_format(struct vpfe_ipipeif_device *ipipeif,\r\nstruct v4l2_subdev_fh *fh, unsigned int pad,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn v4l2_subdev_get_try_format(fh, pad);\r\nreturn &ipipeif->formats[pad];\r\n}\r\nstatic int\r\nipipeif_set_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct vpfe_ipipeif_device *ipipeif = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __ipipeif_get_format(ipipeif, fh, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nipipeif_try_format(ipipeif, fh, fmt->pad, &fmt->format, fmt->which);\r\n*format = fmt->format;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn 0;\r\nif (fmt->pad == IPIPEIF_PAD_SINK &&\r\nipipeif->input != IPIPEIF_INPUT_NONE)\r\nipipeif->formats[fmt->pad] = fmt->format;\r\nelse if (fmt->pad == IPIPEIF_PAD_SOURCE &&\r\nipipeif->output != IPIPEIF_OUTPUT_NONE)\r\nipipeif->formats[fmt->pad] = fmt->format;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void ipipeif_set_default_config(struct vpfe_ipipeif_device *ipipeif)\r\n{\r\n#define WIDTH_I 640\r\n#define HEIGHT_I 480\r\nconst struct ipipeif_params ipipeif_defaults = {\r\n.clock_select = IPIPEIF_SDRAM_CLK,\r\n.ppln = WIDTH_I + 8,\r\n.lpfr = HEIGHT_I + 10,\r\n.rsz = 16,\r\n.decimation = IPIPEIF_DECIMATION_OFF,\r\n.avg_filter = IPIPEIF_AVG_OFF,\r\n.if_5_1 = {\r\n.clk_div = {\r\n.m = 1,\r\n.n = 6\r\n},\r\n.clip = 4095,\r\n},\r\n};\r\nmemset(&ipipeif->config, 0, sizeof(struct ipipeif_params));\r\nmemcpy(&ipipeif->config, &ipipeif_defaults,\r\nsizeof(struct ipipeif_params));\r\n}\r\nstatic int\r\nipipeif_init_formats(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct vpfe_ipipeif_device *ipipeif = v4l2_get_subdevdata(sd);\r\nstruct v4l2_subdev_format format;\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = IPIPEIF_PAD_SINK;\r\nformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\r\nformat.format.code = MEDIA_BUS_FMT_SGRBG12_1X12;\r\nformat.format.width = IPIPE_MAX_OUTPUT_WIDTH_A;\r\nformat.format.height = IPIPE_MAX_OUTPUT_HEIGHT_A;\r\nipipeif_set_format(sd, fh, &format);\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = IPIPEIF_PAD_SOURCE;\r\nformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\r\nformat.format.code = MEDIA_BUS_FMT_UYVY8_2X8;\r\nformat.format.width = IPIPE_MAX_OUTPUT_WIDTH_A;\r\nformat.format.height = IPIPE_MAX_OUTPUT_HEIGHT_A;\r\nipipeif_set_format(sd, fh, &format);\r\nipipeif_set_default_config(ipipeif);\r\nreturn 0;\r\n}\r\nstatic int\r\nipipeif_video_in_queue(struct vpfe_device *vpfe_dev, unsigned long addr)\r\n{\r\nstruct vpfe_ipipeif_device *ipipeif = &vpfe_dev->vpfe_ipipeif;\r\nvoid *ipipeif_base_addr = ipipeif->ipipeif_base_addr;\r\nunsigned int adofs;\r\nu32 val;\r\nif (ipipeif->input != IPIPEIF_INPUT_MEMORY)\r\nreturn -EINVAL;\r\nswitch (ipipeif->formats[IPIPEIF_PAD_SINK].code) {\r\ncase MEDIA_BUS_FMT_Y8_1X8:\r\ncase MEDIA_BUS_FMT_UV8_1X8:\r\ncase MEDIA_BUS_FMT_YDYUYDYV8_1X16:\r\nadofs = ipipeif->formats[IPIPEIF_PAD_SINK].width;\r\nbreak;\r\ndefault:\r\nadofs = ipipeif->formats[IPIPEIF_PAD_SINK].width << 1;\r\nbreak;\r\n}\r\nadofs += 31;\r\nadofs &= ~0x1f;\r\nval = (adofs >> 5) & IPIPEIF_ADOFS_LSB_MASK;\r\nipipeif_write(val, ipipeif_base_addr, IPIPEIF_ADOFS);\r\nval = (addr >> IPIPEIF_ADDRL_SHIFT) & IPIPEIF_ADDRL_MASK;\r\nipipeif_write(val, ipipeif_base_addr, IPIPEIF_ADDRL);\r\nval = (addr >> IPIPEIF_ADDRU_SHIFT) & IPIPEIF_ADDRU_MASK;\r\nipipeif_write(val, ipipeif_base_addr, IPIPEIF_ADDRU);\r\nreturn 0;\r\n}\r\nstatic int\r\nipipeif_link_setup(struct media_entity *entity, const struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\nstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\r\nstruct vpfe_ipipeif_device *ipipeif = v4l2_get_subdevdata(sd);\r\nstruct vpfe_device *vpfe = to_vpfe_device(ipipeif);\r\nswitch (local->index | media_entity_type(remote->entity)) {\r\ncase IPIPEIF_PAD_SINK | MEDIA_ENT_T_DEVNODE:\r\nif (!(flags & MEDIA_LNK_FL_ENABLED)) {\r\nipipeif->input = IPIPEIF_INPUT_NONE;\r\nbreak;\r\n}\r\nipipeif->input = IPIPEIF_INPUT_MEMORY;\r\nbreak;\r\ncase IPIPEIF_PAD_SINK | MEDIA_ENT_T_V4L2_SUBDEV:\r\nif (!(flags & MEDIA_LNK_FL_ENABLED)) {\r\nipipeif->input = IPIPEIF_INPUT_NONE;\r\nbreak;\r\n}\r\nif (ipipeif->input != IPIPEIF_INPUT_NONE)\r\nreturn -EBUSY;\r\nipipeif->input = IPIPEIF_INPUT_ISIF;\r\nbreak;\r\ncase IPIPEIF_PAD_SOURCE | MEDIA_ENT_T_V4L2_SUBDEV:\r\nif (!(flags & MEDIA_LNK_FL_ENABLED)) {\r\nipipeif->output = IPIPEIF_OUTPUT_NONE;\r\nbreak;\r\n}\r\nif (remote->entity == &vpfe->vpfe_ipipe.subdev.entity)\r\nipipeif->output = IPIPEIF_OUTPUT_IPIPE;\r\nelse if (remote->entity == &vpfe->vpfe_resizer.\r\ncrop_resizer.subdev.entity)\r\nipipeif->output = IPIPEIF_OUTPUT_RESIZER;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid vpfe_ipipeif_unregister_entities(struct vpfe_ipipeif_device *ipipeif)\r\n{\r\nvpfe_video_unregister(&ipipeif->video_in);\r\nv4l2_device_unregister_subdev(&ipipeif->subdev);\r\nmedia_entity_cleanup(&ipipeif->subdev.entity);\r\n}\r\nint\r\nvpfe_ipipeif_register_entities(struct vpfe_ipipeif_device *ipipeif,\r\nstruct v4l2_device *vdev)\r\n{\r\nstruct vpfe_device *vpfe_dev = to_vpfe_device(ipipeif);\r\nunsigned int flags;\r\nint ret;\r\nret = v4l2_device_register_subdev(vdev, &ipipeif->subdev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = vpfe_video_register(&ipipeif->video_in, vdev);\r\nif (ret) {\r\npr_err("Failed to register ipipeif video-in device\n");\r\ngoto fail;\r\n}\r\nipipeif->video_in.vpfe_dev = vpfe_dev;\r\nflags = 0;\r\nret = media_entity_create_link(&ipipeif->video_in.video_dev.entity, 0,\r\n&ipipeif->subdev.entity, 0, flags);\r\nif (ret < 0)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nv4l2_device_unregister_subdev(&ipipeif->subdev);\r\nreturn ret;\r\n}\r\nint vpfe_ipipeif_init(struct vpfe_ipipeif_device *ipipeif,\r\nstruct platform_device *pdev)\r\n{\r\nstruct v4l2_subdev *sd = &ipipeif->subdev;\r\nstruct media_pad *pads = &ipipeif->pads[0];\r\nstruct media_entity *me = &sd->entity;\r\nstatic resource_size_t res_len;\r\nstruct resource *res;\r\nint ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 3);\r\nif (!res)\r\nreturn -ENOENT;\r\nres_len = resource_size(res);\r\nres = request_mem_region(res->start, res_len, res->name);\r\nif (!res)\r\nreturn -EBUSY;\r\nipipeif->ipipeif_base_addr = ioremap_nocache(res->start, res_len);\r\nif (!ipipeif->ipipeif_base_addr) {\r\nret = -EBUSY;\r\ngoto fail;\r\n}\r\nv4l2_subdev_init(sd, &ipipeif_v4l2_ops);\r\nsd->internal_ops = &ipipeif_v4l2_internal_ops;\r\nstrlcpy(sd->name, "DAVINCI IPIPEIF", sizeof(sd->name));\r\nsd->grp_id = 1 << 16;\r\nv4l2_set_subdevdata(sd, ipipeif);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_EVENTS | V4L2_SUBDEV_FL_HAS_DEVNODE;\r\npads[IPIPEIF_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\r\npads[IPIPEIF_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\r\nipipeif->input = IPIPEIF_INPUT_NONE;\r\nipipeif->output = IPIPEIF_OUTPUT_NONE;\r\nme->ops = &ipipeif_media_ops;\r\nret = media_entity_init(me, IPIPEIF_NUM_PADS, pads, 0);\r\nif (ret)\r\ngoto fail;\r\nv4l2_ctrl_handler_init(&ipipeif->ctrls, 2);\r\nv4l2_ctrl_new_std(&ipipeif->ctrls, &ipipeif_ctrl_ops,\r\nV4L2_CID_GAIN, 0,\r\nIPIPEIF_GAIN_HIGH, 1, IPIPEIF_DEFAULT_GAIN);\r\nv4l2_ctrl_new_custom(&ipipeif->ctrls, &vpfe_ipipeif_dpcm_pred, NULL);\r\nv4l2_ctrl_handler_setup(&ipipeif->ctrls);\r\nsd->ctrl_handler = &ipipeif->ctrls;\r\nipipeif->video_in.ops = &video_in_ops;\r\nipipeif->video_in.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nret = vpfe_video_init(&ipipeif->video_in, "IPIPEIF");\r\nif (ret) {\r\npr_err("Failed to init IPIPEIF video-in device\n");\r\ngoto fail;\r\n}\r\nipipeif_set_default_config(ipipeif);\r\nreturn 0;\r\nfail:\r\nrelease_mem_region(res->start, res_len);\r\nreturn ret;\r\n}\r\nvoid\r\nvpfe_ipipeif_cleanup(struct vpfe_ipipeif_device *ipipeif,\r\nstruct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nv4l2_ctrl_handler_free(&ipipeif->ctrls);\r\niounmap(ipipeif->ipipeif_base_addr);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 3);\r\nif (res)\r\nrelease_mem_region(res->start, resource_size(res));\r\n}
