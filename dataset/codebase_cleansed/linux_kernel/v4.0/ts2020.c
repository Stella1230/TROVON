static int ts2020_release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nstatic int ts2020_writereg(struct dvb_frontend *fe, int reg, int data)\r\n{\r\nstruct ts2020_priv *priv = fe->tuner_priv;\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = priv->i2c_address,\r\n.flags = 0,\r\n.buf = buf,\r\n.len = 2\r\n}\r\n};\r\nint err;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nerr = i2c_transfer(priv->i2c, msg, 1);\r\nif (err != 1) {\r\nprintk(KERN_ERR\r\n"%s: writereg error(err == %i, reg == 0x%02x, value == 0x%02x)\n",\r\n__func__, err, reg, data);\r\nreturn -EREMOTEIO;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\n}\r\nstatic int ts2020_readreg(struct dvb_frontend *fe, u8 reg)\r\n{\r\nstruct ts2020_priv *priv = fe->tuner_priv;\r\nint ret;\r\nu8 b0[] = { reg };\r\nu8 b1[] = { 0 };\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = priv->i2c_address,\r\n.flags = 0,\r\n.buf = b0,\r\n.len = 1\r\n}, {\r\n.addr = priv->i2c_address,\r\n.flags = I2C_M_RD,\r\n.buf = b1,\r\n.len = 1\r\n}\r\n};\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = i2c_transfer(priv->i2c, msg, 2);\r\nif (ret != 2) {\r\nprintk(KERN_ERR "%s: reg=0x%x(error=%d)\n",\r\n__func__, reg, ret);\r\nreturn ret;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn b1[0];\r\n}\r\nstatic int ts2020_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct ts2020_priv *priv = fe->tuner_priv;\r\nint ret;\r\nu8 buf[] = { 10, 0 };\r\nstruct i2c_msg msg = {\r\n.addr = priv->i2c_address,\r\n.flags = 0,\r\n.buf = buf,\r\n.len = 2\r\n};\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = i2c_transfer(priv->i2c, &msg, 1);\r\nif (ret != 1)\r\nprintk(KERN_ERR "%s: i2c error\n", __func__);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn (ret == 1) ? 0 : ret;\r\n}\r\nstatic int ts2020_init(struct dvb_frontend *fe)\r\n{\r\nstruct ts2020_priv *priv = fe->tuner_priv;\r\nts2020_writereg(fe, 0x42, 0x73);\r\nts2020_writereg(fe, 0x05, priv->clk_out_div);\r\nts2020_writereg(fe, 0x20, 0x27);\r\nts2020_writereg(fe, 0x07, 0x02);\r\nts2020_writereg(fe, 0x11, 0xff);\r\nts2020_writereg(fe, 0x60, 0xf9);\r\nts2020_writereg(fe, 0x08, 0x01);\r\nts2020_writereg(fe, 0x00, 0x41);\r\nreturn 0;\r\n}\r\nstatic int ts2020_tuner_gate_ctrl(struct dvb_frontend *fe, u8 offset)\r\n{\r\nint ret;\r\nret = ts2020_writereg(fe, 0x51, 0x1f - offset);\r\nret |= ts2020_writereg(fe, 0x51, 0x1f);\r\nret |= ts2020_writereg(fe, 0x50, offset);\r\nret |= ts2020_writereg(fe, 0x50, 0x00);\r\nmsleep(20);\r\nreturn ret;\r\n}\r\nstatic int ts2020_set_tuner_rf(struct dvb_frontend *fe)\r\n{\r\nint reg;\r\nreg = ts2020_readreg(fe, 0x3d);\r\nreg &= 0x7f;\r\nif (reg < 0x16)\r\nreg = 0xa1;\r\nelse if (reg == 0x16)\r\nreg = 0x99;\r\nelse\r\nreg = 0xf9;\r\nts2020_writereg(fe, 0x60, reg);\r\nreg = ts2020_tuner_gate_ctrl(fe, 0x08);\r\nreturn reg;\r\n}\r\nstatic int ts2020_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct ts2020_priv *priv = fe->tuner_priv;\r\nint ret;\r\nu32 frequency = c->frequency;\r\ns32 offset_khz;\r\nu32 symbol_rate = (c->symbol_rate / 1000);\r\nu32 f3db, gdiv28;\r\nu16 value, ndiv, lpf_coeff;\r\nu8 lpf_mxdiv, mlpf_max, mlpf_min, nlpf;\r\nu8 lo = 0x01, div4 = 0x0;\r\nif (frequency < priv->frequency_div) {\r\nlo |= 0x10;\r\ndiv4 = 0x1;\r\nndiv = (frequency * 14 * 4) / TS2020_XTAL_FREQ;\r\n} else\r\nndiv = (frequency * 14 * 2) / TS2020_XTAL_FREQ;\r\nndiv = ndiv + ndiv % 2;\r\nndiv = ndiv - 1024;\r\nret = ts2020_writereg(fe, 0x10, 0x80 | lo);\r\nret |= ts2020_writereg(fe, 0x01, (ndiv >> 8) & 0xf);\r\nret |= ts2020_writereg(fe, 0x02, ndiv & 0xff);\r\nret |= ts2020_writereg(fe, 0x03, 0x06);\r\nret |= ts2020_tuner_gate_ctrl(fe, 0x10);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nret = ts2020_writereg(fe, 0x10, lo);\r\nret |= ts2020_tuner_gate_ctrl(fe, 0x08);\r\nret |= ts2020_set_tuner_rf(fe);\r\ngdiv28 = (TS2020_XTAL_FREQ / 1000 * 1694 + 500) / 1000;\r\nret |= ts2020_writereg(fe, 0x04, gdiv28 & 0xff);\r\nret |= ts2020_tuner_gate_ctrl(fe, 0x04);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nvalue = ts2020_readreg(fe, 0x26);\r\nf3db = (symbol_rate * 135) / 200 + 2000;\r\nf3db += FREQ_OFFSET_LOW_SYM_RATE;\r\nif (f3db < 7000)\r\nf3db = 7000;\r\nif (f3db > 40000)\r\nf3db = 40000;\r\ngdiv28 = gdiv28 * 207 / (value * 2 + 151);\r\nmlpf_max = gdiv28 * 135 / 100;\r\nmlpf_min = gdiv28 * 78 / 100;\r\nif (mlpf_max > 63)\r\nmlpf_max = 63;\r\nlpf_coeff = 2766;\r\nnlpf = (f3db * gdiv28 * 2 / lpf_coeff /\r\n(TS2020_XTAL_FREQ / 1000) + 1) / 2;\r\nif (nlpf > 23)\r\nnlpf = 23;\r\nif (nlpf < 1)\r\nnlpf = 1;\r\nlpf_mxdiv = (nlpf * (TS2020_XTAL_FREQ / 1000)\r\n* lpf_coeff * 2 / f3db + 1) / 2;\r\nif (lpf_mxdiv < mlpf_min) {\r\nnlpf++;\r\nlpf_mxdiv = (nlpf * (TS2020_XTAL_FREQ / 1000)\r\n* lpf_coeff * 2 / f3db + 1) / 2;\r\n}\r\nif (lpf_mxdiv > mlpf_max)\r\nlpf_mxdiv = mlpf_max;\r\nret = ts2020_writereg(fe, 0x04, lpf_mxdiv);\r\nret |= ts2020_writereg(fe, 0x06, nlpf);\r\nret |= ts2020_tuner_gate_ctrl(fe, 0x04);\r\nret |= ts2020_tuner_gate_ctrl(fe, 0x01);\r\nmsleep(80);\r\noffset_khz = (ndiv - ndiv % 2 + 1024) * TS2020_XTAL_FREQ\r\n/ (6 + 8) / (div4 + 1) / 2;\r\npriv->frequency = offset_khz;\r\nreturn (ret < 0) ? -EINVAL : 0;\r\n}\r\nstatic int ts2020_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct ts2020_priv *priv = fe->tuner_priv;\r\n*frequency = priv->frequency;\r\nreturn 0;\r\n}\r\nstatic int ts2020_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *signal_strength)\r\n{\r\nu16 sig_reading, sig_strength;\r\nu8 rfgain, bbgain;\r\nrfgain = ts2020_readreg(fe, 0x3d) & 0x1f;\r\nbbgain = ts2020_readreg(fe, 0x21) & 0x1f;\r\nif (rfgain > 15)\r\nrfgain = 15;\r\nif (bbgain > 13)\r\nbbgain = 13;\r\nsig_reading = rfgain * 2 + bbgain * 3;\r\nsig_strength = 40 + (64 - sig_reading) * 50 / 64 ;\r\n*signal_strength = sig_strength * 1000;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *ts2020_attach(struct dvb_frontend *fe,\r\nconst struct ts2020_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct ts2020_priv *priv = NULL;\r\nu8 buf;\r\npriv = kzalloc(sizeof(struct ts2020_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\npriv->i2c_address = config->tuner_address;\r\npriv->i2c = i2c;\r\npriv->clk_out_div = config->clk_out_div;\r\npriv->frequency_div = config->frequency_div;\r\nfe->tuner_priv = priv;\r\nif (!priv->frequency_div)\r\npriv->frequency_div = 1060000;\r\nif ((0x03 & ts2020_readreg(fe, 0x00)) == 0x00) {\r\nts2020_writereg(fe, 0x00, 0x01);\r\nmsleep(2);\r\n}\r\nts2020_writereg(fe, 0x00, 0x03);\r\nmsleep(2);\r\nbuf = ts2020_readreg(fe, 0x00);\r\nif ((buf == 0x01) || (buf == 0x41) || (buf == 0x81))\r\nprintk(KERN_INFO "%s: Find tuner TS2020!\n", __func__);\r\nelse {\r\nprintk(KERN_ERR "%s: Read tuner reg[0] = %d\n", __func__, buf);\r\nkfree(priv);\r\nreturn NULL;\r\n}\r\nmemcpy(&fe->ops.tuner_ops, &ts2020_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nreturn fe;\r\n}
