static inline bool synth_writable(void)\r\n{\r\nreturn (inb_p(synth_port + UART_RX) & 0x10) != 0;\r\n}\r\nstatic inline bool synth_full(void)\r\n{\r\nreturn (inb_p(synth_port + UART_RX) & 0x80) == 0;\r\n}\r\nstatic char *oops(void)\r\n{\r\nint s1, s2, s3, s4;\r\ns1 = inb_p(synth_port);\r\ns2 = inb_p(synth_port+1);\r\ns3 = inb_p(synth_port+2);\r\ns4 = inb_p(synth_port+3);\r\npr_warn("synth timeout %d %d %d %d\n", s1, s2, s3, s4);\r\nreturn NULL;\r\n}\r\nstatic const char *synth_immediate(struct spk_synth *synth, const char *buf)\r\n{\r\nu_char ch;\r\nint timeout;\r\nwhile ((ch = *buf)) {\r\nif (ch == '\n')\r\nch = PROCSPEECH;\r\nif (synth_full())\r\nreturn buf;\r\ntimeout = 1000;\r\nwhile (synth_writable())\r\nif (--timeout <= 0)\r\nreturn oops();\r\noutb_p(ch, synth_port);\r\nudelay(70);\r\nbuf++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void do_catch_up(struct spk_synth *synth)\r\n{\r\nu_char ch;\r\nint timeout;\r\nunsigned long flags;\r\nunsigned long jiff_max;\r\nstruct var_t *jiffy_delta;\r\nstruct var_t *delay_time;\r\nstruct var_t *full_time;\r\nint delay_time_val;\r\nint full_time_val;\r\nint jiffy_delta_val;\r\njiffy_delta = spk_get_var(JIFFY);\r\ndelay_time = spk_get_var(DELAY);\r\nfull_time = spk_get_var(FULL);\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\njiffy_delta_val = jiffy_delta->u.n.value;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\njiff_max = jiffies + jiffy_delta_val;\r\nwhile (!kthread_should_stop()) {\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nif (speakup_info.flushing) {\r\nspeakup_info.flushing = 0;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nsynth->flush(synth);\r\ncontinue;\r\n}\r\nif (synth_buffer_empty()) {\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nbreak;\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nfull_time_val = full_time->u.n.value;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nif (synth_full()) {\r\nschedule_timeout(msecs_to_jiffies(full_time_val));\r\ncontinue;\r\n}\r\nset_current_state(TASK_RUNNING);\r\ntimeout = 1000;\r\nwhile (synth_writable())\r\nif (--timeout <= 0)\r\nbreak;\r\nif (timeout <= 0) {\r\noops();\r\nbreak;\r\n}\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nch = synth_buffer_getc();\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nif (ch == '\n')\r\nch = PROCSPEECH;\r\noutb_p(ch, synth_port);\r\nSWAIT;\r\nif (time_after_eq(jiffies, jiff_max) && (ch == SPACE)) {\r\ntimeout = 1000;\r\nwhile (synth_writable())\r\nif (--timeout <= 0)\r\nbreak;\r\nif (timeout <= 0) {\r\noops();\r\nbreak;\r\n}\r\noutb_p(PROCSPEECH, synth_port);\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\njiffy_delta_val = jiffy_delta->u.n.value;\r\ndelay_time_val = delay_time->u.n.value;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nschedule_timeout(msecs_to_jiffies(delay_time_val));\r\njiff_max = jiffies+jiffy_delta_val;\r\n}\r\n}\r\ntimeout = 1000;\r\nwhile (synth_writable())\r\nif (--timeout <= 0)\r\nbreak;\r\nif (timeout <= 0)\r\noops();\r\nelse\r\noutb_p(PROCSPEECH, synth_port);\r\n}\r\nstatic void synth_flush(struct spk_synth *synth)\r\n{\r\noutb_p(SYNTH_CLEAR, synth_port);\r\n}\r\nstatic int synth_probe(struct spk_synth *synth)\r\n{\r\nunsigned int port_val = 0;\r\nint i = 0;\r\npr_info("Probing for %s.\n", synth->long_name);\r\nif (port_forced) {\r\nsynth_port = port_forced;\r\npr_info("probe forced to %x by kernel command line\n",\r\nsynth_port);\r\nif (synth_request_region(synth_port-1, SYNTH_IO_EXTENT)) {\r\npr_warn("sorry, port already reserved\n");\r\nreturn -EBUSY;\r\n}\r\nport_val = inb(synth_port);\r\n} else {\r\nfor (i = 0; synth_portlist[i]; i++) {\r\nif (synth_request_region(synth_portlist[i],\r\nSYNTH_IO_EXTENT)) {\r\npr_warn\r\n("request_region: failed with 0x%x, %d\n",\r\nsynth_portlist[i], SYNTH_IO_EXTENT);\r\ncontinue;\r\n}\r\nport_val = inb(synth_portlist[i]);\r\nif (port_val == 0x80) {\r\nsynth_port = synth_portlist[i];\r\nbreak;\r\n}\r\n}\r\n}\r\nif (port_val != 0x80) {\r\npr_info("%s: not found\n", synth->long_name);\r\nsynth_release_region(synth_port, SYNTH_IO_EXTENT);\r\nsynth_port = 0;\r\nreturn -ENODEV;\r\n}\r\npr_info("%s: %03x-%03x, driver version %s,\n", synth->long_name,\r\nsynth_port, synth_port+SYNTH_IO_EXTENT-1,\r\nsynth->version);\r\nsynth->alive = 1;\r\nreturn 0;\r\n}\r\nstatic void keynote_release(void)\r\n{\r\nif (synth_port)\r\nsynth_release_region(synth_port, SYNTH_IO_EXTENT);\r\nsynth_port = 0;\r\n}\r\nstatic int __init keypc_init(void)\r\n{\r\nreturn synth_add(&synth_keypc);\r\n}\r\nstatic void __exit keypc_exit(void)\r\n{\r\nsynth_remove(&synth_keypc);\r\n}
