static inline struct si4713_usb_device *to_si4713_dev(struct v4l2_device *v4l2_dev)\r\n{\r\nreturn container_of(v4l2_dev, struct si4713_usb_device, v4l2_dev);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstruct si4713_usb_device *radio = video_drvdata(file);\r\nstrlcpy(v->driver, "radio-usb-si4713", sizeof(v->driver));\r\nstrlcpy(v->card, "Si4713 FM Transmitter", sizeof(v->card));\r\nusb_make_path(radio->usbdev, v->bus_info, sizeof(v->bus_info));\r\nv->device_caps = V4L2_CAP_MODULATOR | V4L2_CAP_RDS_OUTPUT;\r\nv->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_modulator(struct file *file, void *priv,\r\nstruct v4l2_modulator *vm)\r\n{\r\nstruct si4713_usb_device *radio = video_drvdata(file);\r\nreturn v4l2_subdev_call(radio->v4l2_subdev, tuner, g_modulator, vm);\r\n}\r\nstatic int vidioc_s_modulator(struct file *file, void *priv,\r\nconst struct v4l2_modulator *vm)\r\n{\r\nstruct si4713_usb_device *radio = video_drvdata(file);\r\nreturn v4l2_subdev_call(radio->v4l2_subdev, tuner, s_modulator, vm);\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *vf)\r\n{\r\nstruct si4713_usb_device *radio = video_drvdata(file);\r\nreturn v4l2_subdev_call(radio->v4l2_subdev, tuner, s_frequency, vf);\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *vf)\r\n{\r\nstruct si4713_usb_device *radio = video_drvdata(file);\r\nreturn v4l2_subdev_call(radio->v4l2_subdev, tuner, g_frequency, vf);\r\n}\r\nstatic void usb_si4713_video_device_release(struct v4l2_device *v4l2_dev)\r\n{\r\nstruct si4713_usb_device *radio = to_si4713_dev(v4l2_dev);\r\nstruct i2c_adapter *adapter = &radio->i2c_adapter;\r\ni2c_del_adapter(adapter);\r\nv4l2_device_unregister(&radio->v4l2_dev);\r\nkfree(radio->buffer);\r\nkfree(radio);\r\n}\r\nstatic int si4713_send_startup_command(struct si4713_usb_device *radio)\r\n{\r\nunsigned long until_jiffies = jiffies + usecs_to_jiffies(USB_RESP_TIMEOUT) + 1;\r\nu8 *buffer = radio->buffer;\r\nint retval;\r\nretval = usb_control_msg(radio->usbdev, usb_sndctrlpipe(radio->usbdev, 0),\r\n0x09, 0x21, 0x033f, 0, radio->buffer,\r\nBUFFER_LENGTH, USB_TIMEOUT);\r\nif (retval < 0)\r\nreturn retval;\r\nfor (;;) {\r\nretval = usb_control_msg(radio->usbdev, usb_rcvctrlpipe(radio->usbdev, 0),\r\n0x01, 0xa1, 0x033f, 0, radio->buffer,\r\nBUFFER_LENGTH, USB_TIMEOUT);\r\nif (retval < 0)\r\nreturn retval;\r\nif (!radio->buffer[1]) {\r\nswitch (buffer[1]) {\r\ncase 0x32:\r\nif (radio->buffer[2] == 0)\r\nreturn 0;\r\nbreak;\r\ncase 0x14:\r\ncase 0x12:\r\nif (radio->buffer[2] & SI4713_CTS)\r\nreturn 0;\r\nbreak;\r\ncase 0x06:\r\nif ((radio->buffer[2] & SI4713_CTS) && radio->buffer[9] == 0x08)\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nif (time_is_before_jiffies(until_jiffies))\r\nreturn -EIO;\r\nmsleep(3);\r\n}\r\nreturn retval;\r\n}\r\nstatic int si4713_start_seq(struct si4713_usb_device *radio)\r\n{\r\nint retval = 0;\r\nint i;\r\nradio->buffer[0] = 0x3f;\r\nfor (i = 0; i < ARRAY_SIZE(start_seq); i++) {\r\nint len = start_seq[i].len;\r\nconst u8 *payload = start_seq[i].payload;\r\nmemcpy(radio->buffer + 1, payload, len);\r\nmemset(radio->buffer + len + 1, 0, BUFFER_LENGTH - 1 - len);\r\nretval = si4713_send_startup_command(radio);\r\n}\r\nreturn retval;\r\n}\r\nstatic int send_command(struct si4713_usb_device *radio, u8 *payload, char *data, int len)\r\n{\r\nint retval;\r\nradio->buffer[0] = 0x3f;\r\nradio->buffer[1] = 0x06;\r\nmemcpy(radio->buffer + 2, payload, 3);\r\nmemcpy(radio->buffer + 5, data, len);\r\nmemset(radio->buffer + 5 + len, 0, BUFFER_LENGTH - 5 - len);\r\nretval = usb_control_msg(radio->usbdev, usb_sndctrlpipe(radio->usbdev, 0),\r\n0x09, 0x21, 0x033f, 0, radio->buffer,\r\nBUFFER_LENGTH, USB_TIMEOUT);\r\nreturn retval < 0 ? retval : 0;\r\n}\r\nstatic int si4713_i2c_read(struct si4713_usb_device *radio, char *data, int len)\r\n{\r\nunsigned long until_jiffies = jiffies + usecs_to_jiffies(USB_RESP_TIMEOUT) + 1;\r\nint retval;\r\nfor (;;) {\r\nretval = usb_control_msg(radio->usbdev,\r\nusb_rcvctrlpipe(radio->usbdev, 0),\r\n0x01, 0xa1, 0x033f, 0, radio->buffer,\r\nBUFFER_LENGTH, USB_TIMEOUT);\r\nif (retval < 0)\r\nreturn retval;\r\nif (radio->buffer[1] == 0 && (radio->buffer[2] & SI4713_CTS)) {\r\nmemcpy(data, radio->buffer + 2, len);\r\nreturn 0;\r\n}\r\nif (time_is_before_jiffies(until_jiffies)) {\r\ndata[0] = 0;\r\nreturn 0;\r\n}\r\nmsleep(3);\r\n}\r\n}\r\nstatic int si4713_i2c_write(struct si4713_usb_device *radio, char *data, int len)\r\n{\r\nint retval = -EINVAL;\r\nint i;\r\nif (len > BUFFER_LENGTH - 5)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(command_table); i++) {\r\nif (data[0] == command_table[i].command_id)\r\nretval = send_command(radio, command_table[i].payload,\r\ndata, len);\r\n}\r\nreturn retval < 0 ? retval : 0;\r\n}\r\nstatic int si4713_transfer(struct i2c_adapter *i2c_adapter,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct si4713_usb_device *radio = i2c_get_adapdata(i2c_adapter);\r\nint retval = -EINVAL;\r\nint i;\r\nif (num <= 0)\r\nreturn 0;\r\nfor (i = 0; i < num; i++) {\r\nif (msgs[i].flags & I2C_M_RD)\r\nretval = si4713_i2c_read(radio, msgs[i].buf, msgs[i].len);\r\nelse\r\nretval = si4713_i2c_write(radio, msgs[i].buf, msgs[i].len);\r\nif (retval)\r\nbreak;\r\n}\r\nreturn retval ? retval : num;\r\n}\r\nstatic u32 si4713_functionality(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int si4713_register_i2c_adapter(struct si4713_usb_device *radio)\r\n{\r\nradio->i2c_adapter = si4713_i2c_adapter_template;\r\nradio->i2c_adapter.dev.parent = &radio->usbdev->dev;\r\ni2c_set_adapdata(&radio->i2c_adapter, radio);\r\nreturn i2c_add_adapter(&radio->i2c_adapter);\r\n}\r\nstatic int usb_si4713_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct si4713_usb_device *radio;\r\nstruct i2c_adapter *adapter;\r\nstruct v4l2_subdev *sd;\r\nint retval = -ENOMEM;\r\ndev_info(&intf->dev, "Si4713 development board discovered: (%04X:%04X)\n",\r\nid->idVendor, id->idProduct);\r\nradio = kzalloc(sizeof(struct si4713_usb_device), GFP_KERNEL);\r\nif (radio)\r\nradio->buffer = kmalloc(BUFFER_LENGTH, GFP_KERNEL);\r\nif (!radio || !radio->buffer) {\r\ndev_err(&intf->dev, "kmalloc for si4713_usb_device failed\n");\r\nkfree(radio);\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&radio->lock);\r\nradio->usbdev = interface_to_usbdev(intf);\r\nradio->intf = intf;\r\nusb_set_intfdata(intf, &radio->v4l2_dev);\r\nretval = si4713_start_seq(radio);\r\nif (retval < 0)\r\ngoto err_v4l2;\r\nretval = v4l2_device_register(&intf->dev, &radio->v4l2_dev);\r\nif (retval < 0) {\r\ndev_err(&intf->dev, "couldn't register v4l2_device\n");\r\ngoto err_v4l2;\r\n}\r\nretval = si4713_register_i2c_adapter(radio);\r\nif (retval < 0) {\r\ndev_err(&intf->dev, "could not register i2c device\n");\r\ngoto err_i2cdev;\r\n}\r\nadapter = &radio->i2c_adapter;\r\nsd = v4l2_i2c_new_subdev_board(&radio->v4l2_dev, adapter,\r\n&si4713_board_info, NULL);\r\nradio->v4l2_subdev = sd;\r\nif (!sd) {\r\ndev_err(&intf->dev, "cannot get v4l2 subdevice\n");\r\nretval = -ENODEV;\r\ngoto del_adapter;\r\n}\r\nradio->vdev.ctrl_handler = sd->ctrl_handler;\r\nradio->v4l2_dev.release = usb_si4713_video_device_release;\r\nstrlcpy(radio->vdev.name, radio->v4l2_dev.name,\r\nsizeof(radio->vdev.name));\r\nradio->vdev.v4l2_dev = &radio->v4l2_dev;\r\nradio->vdev.fops = &usb_si4713_fops;\r\nradio->vdev.ioctl_ops = &usb_si4713_ioctl_ops;\r\nradio->vdev.lock = &radio->lock;\r\nradio->vdev.release = video_device_release_empty;\r\nradio->vdev.vfl_dir = VFL_DIR_TX;\r\nvideo_set_drvdata(&radio->vdev, radio);\r\nretval = video_register_device(&radio->vdev, VFL_TYPE_RADIO, -1);\r\nif (retval < 0) {\r\ndev_err(&intf->dev, "could not register video device\n");\r\ngoto del_adapter;\r\n}\r\ndev_info(&intf->dev, "V4L2 device registered as %s\n",\r\nvideo_device_node_name(&radio->vdev));\r\nreturn 0;\r\ndel_adapter:\r\ni2c_del_adapter(adapter);\r\nerr_i2cdev:\r\nv4l2_device_unregister(&radio->v4l2_dev);\r\nerr_v4l2:\r\nkfree(radio->buffer);\r\nkfree(radio);\r\nreturn retval;\r\n}\r\nstatic void usb_si4713_disconnect(struct usb_interface *intf)\r\n{\r\nstruct si4713_usb_device *radio = to_si4713_dev(usb_get_intfdata(intf));\r\ndev_info(&intf->dev, "Si4713 development board now disconnected\n");\r\nmutex_lock(&radio->lock);\r\nusb_set_intfdata(intf, NULL);\r\nvideo_unregister_device(&radio->vdev);\r\nv4l2_device_disconnect(&radio->v4l2_dev);\r\nmutex_unlock(&radio->lock);\r\nv4l2_device_put(&radio->v4l2_dev);\r\n}
