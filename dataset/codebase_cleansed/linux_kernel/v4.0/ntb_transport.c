static int ntb_match_bus(struct device *dev, struct device_driver *drv)\r\n{\r\nreturn !strncmp(dev_name(dev), drv->name, strlen(drv->name));\r\n}\r\nstatic int ntb_client_probe(struct device *dev)\r\n{\r\nconst struct ntb_client *drv = container_of(dev->driver,\r\nstruct ntb_client, driver);\r\nstruct pci_dev *pdev = container_of(dev->parent, struct pci_dev, dev);\r\nint rc = -EINVAL;\r\nget_device(dev);\r\nif (drv && drv->probe)\r\nrc = drv->probe(pdev);\r\nif (rc)\r\nput_device(dev);\r\nreturn rc;\r\n}\r\nstatic int ntb_client_remove(struct device *dev)\r\n{\r\nconst struct ntb_client *drv = container_of(dev->driver,\r\nstruct ntb_client, driver);\r\nstruct pci_dev *pdev = container_of(dev->parent, struct pci_dev, dev);\r\nif (drv && drv->remove)\r\ndrv->remove(pdev);\r\nput_device(dev);\r\nreturn 0;\r\n}\r\nstatic int ntb_bus_init(struct ntb_transport *nt)\r\n{\r\nif (list_empty(&ntb_transport_list)) {\r\nint rc = bus_register(&ntb_bus_type);\r\nif (rc)\r\nreturn rc;\r\n}\r\nlist_add(&nt->entry, &ntb_transport_list);\r\nreturn 0;\r\n}\r\nstatic void ntb_bus_remove(struct ntb_transport *nt)\r\n{\r\nstruct ntb_transport_client_dev *client_dev, *cd;\r\nlist_for_each_entry_safe(client_dev, cd, &nt->client_devs, entry) {\r\ndev_err(client_dev->dev.parent, "%s still attached to bus, removing\n",\r\ndev_name(&client_dev->dev));\r\nlist_del(&client_dev->entry);\r\ndevice_unregister(&client_dev->dev);\r\n}\r\nlist_del(&nt->entry);\r\nif (list_empty(&ntb_transport_list))\r\nbus_unregister(&ntb_bus_type);\r\n}\r\nstatic void ntb_client_release(struct device *dev)\r\n{\r\nstruct ntb_transport_client_dev *client_dev;\r\nclient_dev = container_of(dev, struct ntb_transport_client_dev, dev);\r\nkfree(client_dev);\r\n}\r\nvoid ntb_unregister_client_dev(char *device_name)\r\n{\r\nstruct ntb_transport_client_dev *client, *cd;\r\nstruct ntb_transport *nt;\r\nlist_for_each_entry(nt, &ntb_transport_list, entry)\r\nlist_for_each_entry_safe(client, cd, &nt->client_devs, entry)\r\nif (!strncmp(dev_name(&client->dev), device_name,\r\nstrlen(device_name))) {\r\nlist_del(&client->entry);\r\ndevice_unregister(&client->dev);\r\n}\r\n}\r\nint ntb_register_client_dev(char *device_name)\r\n{\r\nstruct ntb_transport_client_dev *client_dev;\r\nstruct ntb_transport *nt;\r\nint rc, i = 0;\r\nif (list_empty(&ntb_transport_list))\r\nreturn -ENODEV;\r\nlist_for_each_entry(nt, &ntb_transport_list, entry) {\r\nstruct device *dev;\r\nclient_dev = kzalloc(sizeof(struct ntb_transport_client_dev),\r\nGFP_KERNEL);\r\nif (!client_dev) {\r\nrc = -ENOMEM;\r\ngoto err;\r\n}\r\ndev = &client_dev->dev;\r\ndev_set_name(dev, "%s%d", device_name, i);\r\ndev->bus = &ntb_bus_type;\r\ndev->release = ntb_client_release;\r\ndev->parent = &ntb_query_pdev(nt->ndev)->dev;\r\nrc = device_register(dev);\r\nif (rc) {\r\nkfree(client_dev);\r\ngoto err;\r\n}\r\nlist_add_tail(&client_dev->entry, &nt->client_devs);\r\ni++;\r\n}\r\nreturn 0;\r\nerr:\r\nntb_unregister_client_dev(device_name);\r\nreturn rc;\r\n}\r\nint ntb_register_client(struct ntb_client *drv)\r\n{\r\ndrv->driver.bus = &ntb_bus_type;\r\nif (list_empty(&ntb_transport_list))\r\nreturn -ENODEV;\r\nreturn driver_register(&drv->driver);\r\n}\r\nvoid ntb_unregister_client(struct ntb_client *drv)\r\n{\r\ndriver_unregister(&drv->driver);\r\n}\r\nstatic ssize_t debugfs_read(struct file *filp, char __user *ubuf, size_t count,\r\nloff_t *offp)\r\n{\r\nstruct ntb_transport_qp *qp;\r\nchar *buf;\r\nssize_t ret, out_offset, out_count;\r\nout_count = 1000;\r\nbuf = kmalloc(out_count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nqp = filp->private_data;\r\nout_offset = 0;\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"NTB QP stats\n");\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_bytes - \t%llu\n", qp->rx_bytes);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_pkts - \t%llu\n", qp->rx_pkts);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_memcpy - \t%llu\n", qp->rx_memcpy);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_async - \t%llu\n", qp->rx_async);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_ring_empty - %llu\n", qp->rx_ring_empty);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_err_no_buf - %llu\n", qp->rx_err_no_buf);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_err_oflow - \t%llu\n", qp->rx_err_oflow);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_err_ver - \t%llu\n", qp->rx_err_ver);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_buff - \t%p\n", qp->rx_buff);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_index - \t%u\n", qp->rx_index);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"rx_max_entry - \t%u\n", qp->rx_max_entry);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"tx_bytes - \t%llu\n", qp->tx_bytes);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"tx_pkts - \t%llu\n", qp->tx_pkts);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"tx_memcpy - \t%llu\n", qp->tx_memcpy);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"tx_async - \t%llu\n", qp->tx_async);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"tx_ring_full - \t%llu\n", qp->tx_ring_full);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"tx_err_no_buf - %llu\n", qp->tx_err_no_buf);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"tx_mw - \t%p\n", qp->tx_mw);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"tx_index - \t%u\n", qp->tx_index);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"tx_max_entry - \t%u\n", qp->tx_max_entry);\r\nout_offset += snprintf(buf + out_offset, out_count - out_offset,\r\n"\nQP Link %s\n", (qp->qp_link == NTB_LINK_UP) ?\r\n"Up" : "Down");\r\nif (out_offset > out_count)\r\nout_offset = out_count;\r\nret = simple_read_from_buffer(ubuf, count, offp, buf, out_offset);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void ntb_list_add(spinlock_t *lock, struct list_head *entry,\r\nstruct list_head *list)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(lock, flags);\r\nlist_add_tail(entry, list);\r\nspin_unlock_irqrestore(lock, flags);\r\n}\r\nstatic struct ntb_queue_entry *ntb_list_rm(spinlock_t *lock,\r\nstruct list_head *list)\r\n{\r\nstruct ntb_queue_entry *entry;\r\nunsigned long flags;\r\nspin_lock_irqsave(lock, flags);\r\nif (list_empty(list)) {\r\nentry = NULL;\r\ngoto out;\r\n}\r\nentry = list_first_entry(list, struct ntb_queue_entry, entry);\r\nlist_del(&entry->entry);\r\nout:\r\nspin_unlock_irqrestore(lock, flags);\r\nreturn entry;\r\n}\r\nstatic void ntb_transport_setup_qp_mw(struct ntb_transport *nt,\r\nunsigned int qp_num)\r\n{\r\nstruct ntb_transport_qp *qp = &nt->qps[qp_num];\r\nunsigned int rx_size, num_qps_mw;\r\nu8 mw_num, mw_max;\r\nunsigned int i;\r\nmw_max = ntb_max_mw(nt->ndev);\r\nmw_num = QP_TO_MW(nt->ndev, qp_num);\r\nWARN_ON(nt->mw[mw_num].virt_addr == NULL);\r\nif (nt->max_qps % mw_max && mw_num + 1 < nt->max_qps / mw_max)\r\nnum_qps_mw = nt->max_qps / mw_max + 1;\r\nelse\r\nnum_qps_mw = nt->max_qps / mw_max;\r\nrx_size = (unsigned int) nt->mw[mw_num].size / num_qps_mw;\r\nqp->rx_buff = nt->mw[mw_num].virt_addr + qp_num / mw_max * rx_size;\r\nrx_size -= sizeof(struct ntb_rx_info);\r\nqp->remote_rx_info = qp->rx_buff + rx_size;\r\nqp->rx_max_frame = min(transport_mtu, rx_size / 2);\r\nqp->rx_max_entry = rx_size / qp->rx_max_frame;\r\nqp->rx_index = 0;\r\nqp->remote_rx_info->entry = qp->rx_max_entry - 1;\r\nfor (i = 0; i < qp->rx_max_entry; i++) {\r\nvoid *offset = qp->rx_buff + qp->rx_max_frame * (i + 1) -\r\nsizeof(struct ntb_payload_header);\r\nmemset(offset, 0, sizeof(struct ntb_payload_header));\r\n}\r\nqp->rx_pkts = 0;\r\nqp->tx_pkts = 0;\r\nqp->tx_index = 0;\r\n}\r\nstatic void ntb_free_mw(struct ntb_transport *nt, int num_mw)\r\n{\r\nstruct ntb_transport_mw *mw = &nt->mw[num_mw];\r\nstruct pci_dev *pdev = ntb_query_pdev(nt->ndev);\r\nif (!mw->virt_addr)\r\nreturn;\r\ndma_free_coherent(&pdev->dev, mw->size, mw->virt_addr, mw->dma_addr);\r\nmw->virt_addr = NULL;\r\n}\r\nstatic int ntb_set_mw(struct ntb_transport *nt, int num_mw, unsigned int size)\r\n{\r\nstruct ntb_transport_mw *mw = &nt->mw[num_mw];\r\nstruct pci_dev *pdev = ntb_query_pdev(nt->ndev);\r\nif (mw->size == ALIGN(size, 4096))\r\nreturn 0;\r\nif (mw->size != 0)\r\nntb_free_mw(nt, num_mw);\r\nmw->size = ALIGN(size, 4096);\r\nmw->virt_addr = dma_alloc_coherent(&pdev->dev, mw->size, &mw->dma_addr,\r\nGFP_KERNEL);\r\nif (!mw->virt_addr) {\r\nmw->size = 0;\r\ndev_err(&pdev->dev, "Unable to allocate MW buffer of size %d\n",\r\n(int) mw->size);\r\nreturn -ENOMEM;\r\n}\r\nif (!IS_ALIGNED(mw->dma_addr, mw->size)) {\r\ndev_err(&pdev->dev, "DMA memory %pad not aligned to BAR size\n",\r\n&mw->dma_addr);\r\nntb_free_mw(nt, num_mw);\r\nreturn -ENOMEM;\r\n}\r\nntb_set_mw_addr(nt->ndev, num_mw, mw->dma_addr);\r\nreturn 0;\r\n}\r\nstatic void ntb_qp_link_cleanup(struct ntb_transport_qp *qp)\r\n{\r\nstruct ntb_transport *nt = qp->transport;\r\nstruct pci_dev *pdev = ntb_query_pdev(nt->ndev);\r\nif (qp->qp_link == NTB_LINK_DOWN) {\r\ncancel_delayed_work_sync(&qp->link_work);\r\nreturn;\r\n}\r\nif (qp->event_handler)\r\nqp->event_handler(qp->cb_data, NTB_LINK_DOWN);\r\ndev_info(&pdev->dev, "qp %d: Link Down\n", qp->qp_num);\r\nqp->qp_link = NTB_LINK_DOWN;\r\n}\r\nstatic void ntb_qp_link_cleanup_work(struct work_struct *work)\r\n{\r\nstruct ntb_transport_qp *qp = container_of(work,\r\nstruct ntb_transport_qp,\r\nlink_cleanup);\r\nstruct ntb_transport *nt = qp->transport;\r\nntb_qp_link_cleanup(qp);\r\nif (nt->transport_link == NTB_LINK_UP)\r\nschedule_delayed_work(&qp->link_work,\r\nmsecs_to_jiffies(NTB_LINK_DOWN_TIMEOUT));\r\n}\r\nstatic void ntb_qp_link_down(struct ntb_transport_qp *qp)\r\n{\r\nschedule_work(&qp->link_cleanup);\r\n}\r\nstatic void ntb_transport_link_cleanup(struct ntb_transport *nt)\r\n{\r\nint i;\r\nfor (i = 0; i < nt->max_qps; i++)\r\nif (!test_bit(i, &nt->qp_bitmap))\r\nntb_qp_link_cleanup(&nt->qps[i]);\r\nif (nt->transport_link == NTB_LINK_DOWN)\r\ncancel_delayed_work_sync(&nt->link_work);\r\nelse\r\nnt->transport_link = NTB_LINK_DOWN;\r\nfor (i = 0; i < MAX_SPAD; i++)\r\nntb_write_local_spad(nt->ndev, i, 0);\r\n}\r\nstatic void ntb_transport_link_cleanup_work(struct work_struct *work)\r\n{\r\nstruct ntb_transport *nt = container_of(work, struct ntb_transport,\r\nlink_cleanup);\r\nntb_transport_link_cleanup(nt);\r\n}\r\nstatic void ntb_transport_event_callback(void *data, enum ntb_hw_event event)\r\n{\r\nstruct ntb_transport *nt = data;\r\nswitch (event) {\r\ncase NTB_EVENT_HW_LINK_UP:\r\nschedule_delayed_work(&nt->link_work, 0);\r\nbreak;\r\ncase NTB_EVENT_HW_LINK_DOWN:\r\nschedule_work(&nt->link_cleanup);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void ntb_transport_link_work(struct work_struct *work)\r\n{\r\nstruct ntb_transport *nt = container_of(work, struct ntb_transport,\r\nlink_work.work);\r\nstruct ntb_device *ndev = nt->ndev;\r\nstruct pci_dev *pdev = ntb_query_pdev(ndev);\r\nu32 val;\r\nint rc, i;\r\nfor (i = 0; i < ntb_max_mw(ndev); i++) {\r\nrc = ntb_write_remote_spad(ndev, MW0_SZ_HIGH + (i * 2),\r\nntb_get_mw_size(ndev, i) >> 32);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Error writing %u to remote spad %d\n",\r\n(u32)(ntb_get_mw_size(ndev, i) >> 32),\r\nMW0_SZ_HIGH + (i * 2));\r\ngoto out;\r\n}\r\nrc = ntb_write_remote_spad(ndev, MW0_SZ_LOW + (i * 2),\r\n(u32) ntb_get_mw_size(ndev, i));\r\nif (rc) {\r\ndev_err(&pdev->dev, "Error writing %u to remote spad %d\n",\r\n(u32) ntb_get_mw_size(ndev, i),\r\nMW0_SZ_LOW + (i * 2));\r\ngoto out;\r\n}\r\n}\r\nrc = ntb_write_remote_spad(ndev, NUM_MWS, ntb_max_mw(ndev));\r\nif (rc) {\r\ndev_err(&pdev->dev, "Error writing %x to remote spad %d\n",\r\nntb_max_mw(ndev), NUM_MWS);\r\ngoto out;\r\n}\r\nrc = ntb_write_remote_spad(ndev, NUM_QPS, nt->max_qps);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Error writing %x to remote spad %d\n",\r\nnt->max_qps, NUM_QPS);\r\ngoto out;\r\n}\r\nrc = ntb_write_remote_spad(ndev, VERSION, NTB_TRANSPORT_VERSION);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Error writing %x to remote spad %d\n",\r\nNTB_TRANSPORT_VERSION, VERSION);\r\ngoto out;\r\n}\r\nrc = ntb_read_remote_spad(ndev, VERSION, &val);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Error reading remote spad %d\n", VERSION);\r\ngoto out;\r\n}\r\nif (val != NTB_TRANSPORT_VERSION)\r\ngoto out;\r\ndev_dbg(&pdev->dev, "Remote version = %d\n", val);\r\nrc = ntb_read_remote_spad(ndev, NUM_QPS, &val);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Error reading remote spad %d\n", NUM_QPS);\r\ngoto out;\r\n}\r\nif (val != nt->max_qps)\r\ngoto out;\r\ndev_dbg(&pdev->dev, "Remote max number of qps = %d\n", val);\r\nrc = ntb_read_remote_spad(ndev, NUM_MWS, &val);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Error reading remote spad %d\n", NUM_MWS);\r\ngoto out;\r\n}\r\nif (val != ntb_max_mw(ndev))\r\ngoto out;\r\ndev_dbg(&pdev->dev, "Remote number of mws = %d\n", val);\r\nfor (i = 0; i < ntb_max_mw(ndev); i++) {\r\nu64 val64;\r\nrc = ntb_read_remote_spad(ndev, MW0_SZ_HIGH + (i * 2), &val);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Error reading remote spad %d\n",\r\nMW0_SZ_HIGH + (i * 2));\r\ngoto out1;\r\n}\r\nval64 = (u64) val << 32;\r\nrc = ntb_read_remote_spad(ndev, MW0_SZ_LOW + (i * 2), &val);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Error reading remote spad %d\n",\r\nMW0_SZ_LOW + (i * 2));\r\ngoto out1;\r\n}\r\nval64 |= val;\r\ndev_dbg(&pdev->dev, "Remote MW%d size = %llu\n", i, val64);\r\nrc = ntb_set_mw(nt, i, val64);\r\nif (rc)\r\ngoto out1;\r\n}\r\nnt->transport_link = NTB_LINK_UP;\r\nfor (i = 0; i < nt->max_qps; i++) {\r\nstruct ntb_transport_qp *qp = &nt->qps[i];\r\nntb_transport_setup_qp_mw(nt, i);\r\nif (qp->client_ready == NTB_LINK_UP)\r\nschedule_delayed_work(&qp->link_work, 0);\r\n}\r\nreturn;\r\nout1:\r\nfor (i = 0; i < ntb_max_mw(ndev); i++)\r\nntb_free_mw(nt, i);\r\nout:\r\nif (ntb_hw_link_status(ndev))\r\nschedule_delayed_work(&nt->link_work,\r\nmsecs_to_jiffies(NTB_LINK_DOWN_TIMEOUT));\r\n}\r\nstatic void ntb_qp_link_work(struct work_struct *work)\r\n{\r\nstruct ntb_transport_qp *qp = container_of(work,\r\nstruct ntb_transport_qp,\r\nlink_work.work);\r\nstruct pci_dev *pdev = ntb_query_pdev(qp->ndev);\r\nstruct ntb_transport *nt = qp->transport;\r\nint rc, val;\r\nWARN_ON(nt->transport_link != NTB_LINK_UP);\r\nrc = ntb_read_local_spad(nt->ndev, QP_LINKS, &val);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Error reading spad %d\n", QP_LINKS);\r\nreturn;\r\n}\r\nrc = ntb_write_remote_spad(nt->ndev, QP_LINKS, val | 1 << qp->qp_num);\r\nif (rc)\r\ndev_err(&pdev->dev, "Error writing %x to remote spad %d\n",\r\nval | 1 << qp->qp_num, QP_LINKS);\r\nrc = ntb_read_remote_spad(nt->ndev, QP_LINKS, &val);\r\nif (rc)\r\ndev_err(&pdev->dev, "Error reading remote spad %d\n", QP_LINKS);\r\ndev_dbg(&pdev->dev, "Remote QP link status = %x\n", val);\r\nif (1 << qp->qp_num & val) {\r\nqp->qp_link = NTB_LINK_UP;\r\ndev_info(&pdev->dev, "qp %d: Link Up\n", qp->qp_num);\r\nif (qp->event_handler)\r\nqp->event_handler(qp->cb_data, NTB_LINK_UP);\r\n} else if (nt->transport_link == NTB_LINK_UP)\r\nschedule_delayed_work(&qp->link_work,\r\nmsecs_to_jiffies(NTB_LINK_DOWN_TIMEOUT));\r\n}\r\nstatic int ntb_transport_init_queue(struct ntb_transport *nt,\r\nunsigned int qp_num)\r\n{\r\nstruct ntb_transport_qp *qp;\r\nunsigned int num_qps_mw, tx_size;\r\nu8 mw_num, mw_max;\r\nu64 qp_offset;\r\nmw_max = ntb_max_mw(nt->ndev);\r\nmw_num = QP_TO_MW(nt->ndev, qp_num);\r\nqp = &nt->qps[qp_num];\r\nqp->qp_num = qp_num;\r\nqp->transport = nt;\r\nqp->ndev = nt->ndev;\r\nqp->qp_link = NTB_LINK_DOWN;\r\nqp->client_ready = NTB_LINK_DOWN;\r\nqp->event_handler = NULL;\r\nif (nt->max_qps % mw_max && mw_num + 1 < nt->max_qps / mw_max)\r\nnum_qps_mw = nt->max_qps / mw_max + 1;\r\nelse\r\nnum_qps_mw = nt->max_qps / mw_max;\r\ntx_size = (unsigned int) ntb_get_mw_size(qp->ndev, mw_num) / num_qps_mw;\r\nqp_offset = qp_num / mw_max * tx_size;\r\nqp->tx_mw = ntb_get_mw_vbase(nt->ndev, mw_num) + qp_offset;\r\nif (!qp->tx_mw)\r\nreturn -EINVAL;\r\nqp->tx_mw_phys = ntb_get_mw_base(qp->ndev, mw_num) + qp_offset;\r\nif (!qp->tx_mw_phys)\r\nreturn -EINVAL;\r\ntx_size -= sizeof(struct ntb_rx_info);\r\nqp->rx_info = qp->tx_mw + tx_size;\r\nqp->tx_max_frame = min(transport_mtu, tx_size / 2);\r\nqp->tx_max_entry = tx_size / qp->tx_max_frame;\r\nif (ntb_query_debugfs(nt->ndev)) {\r\nchar debugfs_name[4];\r\nsnprintf(debugfs_name, 4, "qp%d", qp_num);\r\nqp->debugfs_dir = debugfs_create_dir(debugfs_name,\r\nntb_query_debugfs(nt->ndev));\r\nqp->debugfs_stats = debugfs_create_file("stats", S_IRUSR,\r\nqp->debugfs_dir, qp,\r\n&ntb_qp_debugfs_stats);\r\n}\r\nINIT_DELAYED_WORK(&qp->link_work, ntb_qp_link_work);\r\nINIT_WORK(&qp->link_cleanup, ntb_qp_link_cleanup_work);\r\nspin_lock_init(&qp->ntb_rx_pend_q_lock);\r\nspin_lock_init(&qp->ntb_rx_free_q_lock);\r\nspin_lock_init(&qp->ntb_tx_free_q_lock);\r\nINIT_LIST_HEAD(&qp->rx_pend_q);\r\nINIT_LIST_HEAD(&qp->rx_free_q);\r\nINIT_LIST_HEAD(&qp->tx_free_q);\r\nreturn 0;\r\n}\r\nint ntb_transport_init(struct pci_dev *pdev)\r\n{\r\nstruct ntb_transport *nt;\r\nint rc, i;\r\nnt = kzalloc(sizeof(struct ntb_transport), GFP_KERNEL);\r\nif (!nt)\r\nreturn -ENOMEM;\r\nnt->ndev = ntb_register_transport(pdev, nt);\r\nif (!nt->ndev) {\r\nrc = -EIO;\r\ngoto err;\r\n}\r\nnt->mw = kcalloc(ntb_max_mw(nt->ndev), sizeof(struct ntb_transport_mw),\r\nGFP_KERNEL);\r\nif (!nt->mw) {\r\nrc = -ENOMEM;\r\ngoto err1;\r\n}\r\nif (max_num_clients)\r\nnt->max_qps = min(ntb_max_cbs(nt->ndev), max_num_clients);\r\nelse\r\nnt->max_qps = min(ntb_max_cbs(nt->ndev), ntb_max_mw(nt->ndev));\r\nnt->qps = kcalloc(nt->max_qps, sizeof(struct ntb_transport_qp),\r\nGFP_KERNEL);\r\nif (!nt->qps) {\r\nrc = -ENOMEM;\r\ngoto err2;\r\n}\r\nnt->qp_bitmap = ((u64) 1 << nt->max_qps) - 1;\r\nfor (i = 0; i < nt->max_qps; i++) {\r\nrc = ntb_transport_init_queue(nt, i);\r\nif (rc)\r\ngoto err3;\r\n}\r\nINIT_DELAYED_WORK(&nt->link_work, ntb_transport_link_work);\r\nINIT_WORK(&nt->link_cleanup, ntb_transport_link_cleanup_work);\r\nrc = ntb_register_event_callback(nt->ndev,\r\nntb_transport_event_callback);\r\nif (rc)\r\ngoto err3;\r\nINIT_LIST_HEAD(&nt->client_devs);\r\nrc = ntb_bus_init(nt);\r\nif (rc)\r\ngoto err4;\r\nif (ntb_hw_link_status(nt->ndev))\r\nschedule_delayed_work(&nt->link_work, 0);\r\nreturn 0;\r\nerr4:\r\nntb_unregister_event_callback(nt->ndev);\r\nerr3:\r\nkfree(nt->qps);\r\nerr2:\r\nkfree(nt->mw);\r\nerr1:\r\nntb_unregister_transport(nt->ndev);\r\nerr:\r\nkfree(nt);\r\nreturn rc;\r\n}\r\nvoid ntb_transport_free(void *transport)\r\n{\r\nstruct ntb_transport *nt = transport;\r\nstruct ntb_device *ndev = nt->ndev;\r\nint i;\r\nntb_transport_link_cleanup(nt);\r\nfor (i = 0; i < nt->max_qps; i++) {\r\nif (!test_bit(i, &nt->qp_bitmap))\r\nntb_transport_free_queue(&nt->qps[i]);\r\ndebugfs_remove_recursive(nt->qps[i].debugfs_dir);\r\n}\r\nntb_bus_remove(nt);\r\ncancel_delayed_work_sync(&nt->link_work);\r\nntb_unregister_event_callback(ndev);\r\nfor (i = 0; i < ntb_max_mw(ndev); i++)\r\nntb_free_mw(nt, i);\r\nkfree(nt->qps);\r\nkfree(nt->mw);\r\nntb_unregister_transport(ndev);\r\nkfree(nt);\r\n}\r\nstatic void ntb_rx_copy_callback(void *data)\r\n{\r\nstruct ntb_queue_entry *entry = data;\r\nstruct ntb_transport_qp *qp = entry->qp;\r\nvoid *cb_data = entry->cb_data;\r\nunsigned int len = entry->len;\r\nstruct ntb_payload_header *hdr = entry->rx_hdr;\r\nwmb();\r\nhdr->flags = 0;\r\niowrite32(entry->index, &qp->rx_info->entry);\r\nntb_list_add(&qp->ntb_rx_free_q_lock, &entry->entry, &qp->rx_free_q);\r\nif (qp->rx_handler && qp->client_ready == NTB_LINK_UP)\r\nqp->rx_handler(qp, qp->cb_data, cb_data, len);\r\n}\r\nstatic void ntb_memcpy_rx(struct ntb_queue_entry *entry, void *offset)\r\n{\r\nvoid *buf = entry->buf;\r\nsize_t len = entry->len;\r\nmemcpy(buf, offset, len);\r\nntb_rx_copy_callback(entry);\r\n}\r\nstatic void ntb_async_rx(struct ntb_queue_entry *entry, void *offset,\r\nsize_t len)\r\n{\r\nstruct dma_async_tx_descriptor *txd;\r\nstruct ntb_transport_qp *qp = entry->qp;\r\nstruct dma_chan *chan = qp->dma_chan;\r\nstruct dma_device *device;\r\nsize_t pay_off, buff_off;\r\nstruct dmaengine_unmap_data *unmap;\r\ndma_cookie_t cookie;\r\nvoid *buf = entry->buf;\r\nentry->len = len;\r\nif (!chan)\r\ngoto err;\r\nif (len < copy_bytes)\r\ngoto err_wait;\r\ndevice = chan->device;\r\npay_off = (size_t) offset & ~PAGE_MASK;\r\nbuff_off = (size_t) buf & ~PAGE_MASK;\r\nif (!is_dma_copy_aligned(device, pay_off, buff_off, len))\r\ngoto err_wait;\r\nunmap = dmaengine_get_unmap_data(device->dev, 2, GFP_NOWAIT);\r\nif (!unmap)\r\ngoto err_wait;\r\nunmap->len = len;\r\nunmap->addr[0] = dma_map_page(device->dev, virt_to_page(offset),\r\npay_off, len, DMA_TO_DEVICE);\r\nif (dma_mapping_error(device->dev, unmap->addr[0]))\r\ngoto err_get_unmap;\r\nunmap->to_cnt = 1;\r\nunmap->addr[1] = dma_map_page(device->dev, virt_to_page(buf),\r\nbuff_off, len, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(device->dev, unmap->addr[1]))\r\ngoto err_get_unmap;\r\nunmap->from_cnt = 1;\r\ntxd = device->device_prep_dma_memcpy(chan, unmap->addr[1],\r\nunmap->addr[0], len,\r\nDMA_PREP_INTERRUPT);\r\nif (!txd)\r\ngoto err_get_unmap;\r\ntxd->callback = ntb_rx_copy_callback;\r\ntxd->callback_param = entry;\r\ndma_set_unmap(txd, unmap);\r\ncookie = dmaengine_submit(txd);\r\nif (dma_submit_error(cookie))\r\ngoto err_set_unmap;\r\ndmaengine_unmap_put(unmap);\r\nqp->last_cookie = cookie;\r\nqp->rx_async++;\r\nreturn;\r\nerr_set_unmap:\r\ndmaengine_unmap_put(unmap);\r\nerr_get_unmap:\r\ndmaengine_unmap_put(unmap);\r\nerr_wait:\r\ndma_sync_wait(chan, qp->last_cookie);\r\nerr:\r\nntb_memcpy_rx(entry, offset);\r\nqp->rx_memcpy++;\r\n}\r\nstatic int ntb_process_rxc(struct ntb_transport_qp *qp)\r\n{\r\nstruct ntb_payload_header *hdr;\r\nstruct ntb_queue_entry *entry;\r\nvoid *offset;\r\noffset = qp->rx_buff + qp->rx_max_frame * qp->rx_index;\r\nhdr = offset + qp->rx_max_frame - sizeof(struct ntb_payload_header);\r\nentry = ntb_list_rm(&qp->ntb_rx_pend_q_lock, &qp->rx_pend_q);\r\nif (!entry) {\r\ndev_dbg(&ntb_query_pdev(qp->ndev)->dev,\r\n"no buffer - HDR ver %u, len %d, flags %x\n",\r\nhdr->ver, hdr->len, hdr->flags);\r\nqp->rx_err_no_buf++;\r\nreturn -ENOMEM;\r\n}\r\nif (!(hdr->flags & DESC_DONE_FLAG)) {\r\nntb_list_add(&qp->ntb_rx_pend_q_lock, &entry->entry,\r\n&qp->rx_pend_q);\r\nqp->rx_ring_empty++;\r\nreturn -EAGAIN;\r\n}\r\nif (hdr->ver != (u32) qp->rx_pkts) {\r\ndev_dbg(&ntb_query_pdev(qp->ndev)->dev,\r\n"qp %d: version mismatch, expected %llu - got %u\n",\r\nqp->qp_num, qp->rx_pkts, hdr->ver);\r\nntb_list_add(&qp->ntb_rx_pend_q_lock, &entry->entry,\r\n&qp->rx_pend_q);\r\nqp->rx_err_ver++;\r\nreturn -EIO;\r\n}\r\nif (hdr->flags & LINK_DOWN_FLAG) {\r\nntb_qp_link_down(qp);\r\ngoto err;\r\n}\r\ndev_dbg(&ntb_query_pdev(qp->ndev)->dev,\r\n"rx offset %u, ver %u - %d payload received, buf size %d\n",\r\nqp->rx_index, hdr->ver, hdr->len, entry->len);\r\nqp->rx_bytes += hdr->len;\r\nqp->rx_pkts++;\r\nif (hdr->len > entry->len) {\r\nqp->rx_err_oflow++;\r\ndev_dbg(&ntb_query_pdev(qp->ndev)->dev,\r\n"RX overflow! Wanted %d got %d\n",\r\nhdr->len, entry->len);\r\ngoto err;\r\n}\r\nentry->index = qp->rx_index;\r\nentry->rx_hdr = hdr;\r\nntb_async_rx(entry, offset, hdr->len);\r\nout:\r\nqp->rx_index++;\r\nqp->rx_index %= qp->rx_max_entry;\r\nreturn 0;\r\nerr:\r\nntb_list_add(&qp->ntb_rx_pend_q_lock, &entry->entry, &qp->rx_pend_q);\r\nwmb();\r\nhdr->flags = 0;\r\niowrite32(qp->rx_index, &qp->rx_info->entry);\r\ngoto out;\r\n}\r\nstatic int ntb_transport_rxc_db(void *data, int db_num)\r\n{\r\nstruct ntb_transport_qp *qp = data;\r\nint rc, i;\r\ndev_dbg(&ntb_query_pdev(qp->ndev)->dev, "%s: doorbell %d received\n",\r\n__func__, db_num);\r\nfor (i = 0; i < qp->rx_max_entry; i++) {\r\nrc = ntb_process_rxc(qp);\r\nif (rc)\r\nbreak;\r\n}\r\nif (qp->dma_chan)\r\ndma_async_issue_pending(qp->dma_chan);\r\nreturn i;\r\n}\r\nstatic void ntb_tx_copy_callback(void *data)\r\n{\r\nstruct ntb_queue_entry *entry = data;\r\nstruct ntb_transport_qp *qp = entry->qp;\r\nstruct ntb_payload_header __iomem *hdr = entry->tx_hdr;\r\nwmb();\r\niowrite32(entry->flags | DESC_DONE_FLAG, &hdr->flags);\r\nntb_ring_doorbell(qp->ndev, qp->qp_num);\r\nif (entry->len > 0) {\r\nqp->tx_bytes += entry->len;\r\nif (qp->tx_handler)\r\nqp->tx_handler(qp, qp->cb_data, entry->cb_data,\r\nentry->len);\r\n}\r\nntb_list_add(&qp->ntb_tx_free_q_lock, &entry->entry, &qp->tx_free_q);\r\n}\r\nstatic void ntb_memcpy_tx(struct ntb_queue_entry *entry, void __iomem *offset)\r\n{\r\nmemcpy_toio(offset, entry->buf, entry->len);\r\nntb_tx_copy_callback(entry);\r\n}\r\nstatic void ntb_async_tx(struct ntb_transport_qp *qp,\r\nstruct ntb_queue_entry *entry)\r\n{\r\nstruct ntb_payload_header __iomem *hdr;\r\nstruct dma_async_tx_descriptor *txd;\r\nstruct dma_chan *chan = qp->dma_chan;\r\nstruct dma_device *device;\r\nsize_t dest_off, buff_off;\r\nstruct dmaengine_unmap_data *unmap;\r\ndma_addr_t dest;\r\ndma_cookie_t cookie;\r\nvoid __iomem *offset;\r\nsize_t len = entry->len;\r\nvoid *buf = entry->buf;\r\noffset = qp->tx_mw + qp->tx_max_frame * qp->tx_index;\r\nhdr = offset + qp->tx_max_frame - sizeof(struct ntb_payload_header);\r\nentry->tx_hdr = hdr;\r\niowrite32(entry->len, &hdr->len);\r\niowrite32((u32) qp->tx_pkts, &hdr->ver);\r\nif (!chan)\r\ngoto err;\r\nif (len < copy_bytes)\r\ngoto err;\r\ndevice = chan->device;\r\ndest = qp->tx_mw_phys + qp->tx_max_frame * qp->tx_index;\r\nbuff_off = (size_t) buf & ~PAGE_MASK;\r\ndest_off = (size_t) dest & ~PAGE_MASK;\r\nif (!is_dma_copy_aligned(device, buff_off, dest_off, len))\r\ngoto err;\r\nunmap = dmaengine_get_unmap_data(device->dev, 1, GFP_NOWAIT);\r\nif (!unmap)\r\ngoto err;\r\nunmap->len = len;\r\nunmap->addr[0] = dma_map_page(device->dev, virt_to_page(buf),\r\nbuff_off, len, DMA_TO_DEVICE);\r\nif (dma_mapping_error(device->dev, unmap->addr[0]))\r\ngoto err_get_unmap;\r\nunmap->to_cnt = 1;\r\ntxd = device->device_prep_dma_memcpy(chan, dest, unmap->addr[0], len,\r\nDMA_PREP_INTERRUPT);\r\nif (!txd)\r\ngoto err_get_unmap;\r\ntxd->callback = ntb_tx_copy_callback;\r\ntxd->callback_param = entry;\r\ndma_set_unmap(txd, unmap);\r\ncookie = dmaengine_submit(txd);\r\nif (dma_submit_error(cookie))\r\ngoto err_set_unmap;\r\ndmaengine_unmap_put(unmap);\r\ndma_async_issue_pending(chan);\r\nqp->tx_async++;\r\nreturn;\r\nerr_set_unmap:\r\ndmaengine_unmap_put(unmap);\r\nerr_get_unmap:\r\ndmaengine_unmap_put(unmap);\r\nerr:\r\nntb_memcpy_tx(entry, offset);\r\nqp->tx_memcpy++;\r\n}\r\nstatic int ntb_process_tx(struct ntb_transport_qp *qp,\r\nstruct ntb_queue_entry *entry)\r\n{\r\ndev_dbg(&ntb_query_pdev(qp->ndev)->dev, "%lld - tx %u, entry len %d flags %x buff %p\n",\r\nqp->tx_pkts, qp->tx_index, entry->len, entry->flags,\r\nentry->buf);\r\nif (qp->tx_index == qp->remote_rx_info->entry) {\r\nqp->tx_ring_full++;\r\nreturn -EAGAIN;\r\n}\r\nif (entry->len > qp->tx_max_frame - sizeof(struct ntb_payload_header)) {\r\nif (qp->tx_handler)\r\nqp->tx_handler(qp->cb_data, qp, NULL, -EIO);\r\nntb_list_add(&qp->ntb_tx_free_q_lock, &entry->entry,\r\n&qp->tx_free_q);\r\nreturn 0;\r\n}\r\nntb_async_tx(qp, entry);\r\nqp->tx_index++;\r\nqp->tx_index %= qp->tx_max_entry;\r\nqp->tx_pkts++;\r\nreturn 0;\r\n}\r\nstatic void ntb_send_link_down(struct ntb_transport_qp *qp)\r\n{\r\nstruct pci_dev *pdev = ntb_query_pdev(qp->ndev);\r\nstruct ntb_queue_entry *entry;\r\nint i, rc;\r\nif (qp->qp_link == NTB_LINK_DOWN)\r\nreturn;\r\nqp->qp_link = NTB_LINK_DOWN;\r\ndev_info(&pdev->dev, "qp %d: Link Down\n", qp->qp_num);\r\nfor (i = 0; i < NTB_LINK_DOWN_TIMEOUT; i++) {\r\nentry = ntb_list_rm(&qp->ntb_tx_free_q_lock, &qp->tx_free_q);\r\nif (entry)\r\nbreak;\r\nmsleep(100);\r\n}\r\nif (!entry)\r\nreturn;\r\nentry->cb_data = NULL;\r\nentry->buf = NULL;\r\nentry->len = 0;\r\nentry->flags = LINK_DOWN_FLAG;\r\nrc = ntb_process_tx(qp, entry);\r\nif (rc)\r\ndev_err(&pdev->dev, "ntb: QP%d unable to send linkdown msg\n",\r\nqp->qp_num);\r\n}\r\nstruct ntb_transport_qp *\r\nntb_transport_create_queue(void *data, struct pci_dev *pdev,\r\nconst struct ntb_queue_handlers *handlers)\r\n{\r\nstruct ntb_queue_entry *entry;\r\nstruct ntb_transport_qp *qp;\r\nstruct ntb_transport *nt;\r\nunsigned int free_queue;\r\nint rc, i;\r\nnt = ntb_find_transport(pdev);\r\nif (!nt)\r\ngoto err;\r\nfree_queue = ffs(nt->qp_bitmap);\r\nif (!free_queue)\r\ngoto err;\r\nfree_queue--;\r\nclear_bit(free_queue, &nt->qp_bitmap);\r\nqp = &nt->qps[free_queue];\r\nqp->cb_data = data;\r\nqp->rx_handler = handlers->rx_handler;\r\nqp->tx_handler = handlers->tx_handler;\r\nqp->event_handler = handlers->event_handler;\r\ndmaengine_get();\r\nqp->dma_chan = dma_find_channel(DMA_MEMCPY);\r\nif (!qp->dma_chan) {\r\ndmaengine_put();\r\ndev_info(&pdev->dev, "Unable to allocate DMA channel, using CPU instead\n");\r\n}\r\nfor (i = 0; i < NTB_QP_DEF_NUM_ENTRIES; i++) {\r\nentry = kzalloc(sizeof(struct ntb_queue_entry), GFP_ATOMIC);\r\nif (!entry)\r\ngoto err1;\r\nentry->qp = qp;\r\nntb_list_add(&qp->ntb_rx_free_q_lock, &entry->entry,\r\n&qp->rx_free_q);\r\n}\r\nfor (i = 0; i < NTB_QP_DEF_NUM_ENTRIES; i++) {\r\nentry = kzalloc(sizeof(struct ntb_queue_entry), GFP_ATOMIC);\r\nif (!entry)\r\ngoto err2;\r\nentry->qp = qp;\r\nntb_list_add(&qp->ntb_tx_free_q_lock, &entry->entry,\r\n&qp->tx_free_q);\r\n}\r\nrc = ntb_register_db_callback(qp->ndev, free_queue, qp,\r\nntb_transport_rxc_db);\r\nif (rc)\r\ngoto err2;\r\ndev_info(&pdev->dev, "NTB Transport QP %d created\n", qp->qp_num);\r\nreturn qp;\r\nerr2:\r\nwhile ((entry = ntb_list_rm(&qp->ntb_tx_free_q_lock, &qp->tx_free_q)))\r\nkfree(entry);\r\nerr1:\r\nwhile ((entry = ntb_list_rm(&qp->ntb_rx_free_q_lock, &qp->rx_free_q)))\r\nkfree(entry);\r\nif (qp->dma_chan)\r\ndmaengine_put();\r\nset_bit(free_queue, &nt->qp_bitmap);\r\nerr:\r\nreturn NULL;\r\n}\r\nvoid ntb_transport_free_queue(struct ntb_transport_qp *qp)\r\n{\r\nstruct pci_dev *pdev;\r\nstruct ntb_queue_entry *entry;\r\nif (!qp)\r\nreturn;\r\npdev = ntb_query_pdev(qp->ndev);\r\nif (qp->dma_chan) {\r\nstruct dma_chan *chan = qp->dma_chan;\r\nqp->dma_chan = NULL;\r\ndma_sync_wait(chan, qp->last_cookie);\r\ndmaengine_terminate_all(chan);\r\ndmaengine_put();\r\n}\r\nntb_unregister_db_callback(qp->ndev, qp->qp_num);\r\ncancel_delayed_work_sync(&qp->link_work);\r\nwhile ((entry = ntb_list_rm(&qp->ntb_rx_free_q_lock, &qp->rx_free_q)))\r\nkfree(entry);\r\nwhile ((entry = ntb_list_rm(&qp->ntb_rx_pend_q_lock, &qp->rx_pend_q))) {\r\ndev_warn(&pdev->dev, "Freeing item from a non-empty queue\n");\r\nkfree(entry);\r\n}\r\nwhile ((entry = ntb_list_rm(&qp->ntb_tx_free_q_lock, &qp->tx_free_q)))\r\nkfree(entry);\r\nset_bit(qp->qp_num, &qp->transport->qp_bitmap);\r\ndev_info(&pdev->dev, "NTB Transport QP %d freed\n", qp->qp_num);\r\n}\r\nvoid *ntb_transport_rx_remove(struct ntb_transport_qp *qp, unsigned int *len)\r\n{\r\nstruct ntb_queue_entry *entry;\r\nvoid *buf;\r\nif (!qp || qp->client_ready == NTB_LINK_UP)\r\nreturn NULL;\r\nentry = ntb_list_rm(&qp->ntb_rx_pend_q_lock, &qp->rx_pend_q);\r\nif (!entry)\r\nreturn NULL;\r\nbuf = entry->cb_data;\r\n*len = entry->len;\r\nntb_list_add(&qp->ntb_rx_free_q_lock, &entry->entry, &qp->rx_free_q);\r\nreturn buf;\r\n}\r\nint ntb_transport_rx_enqueue(struct ntb_transport_qp *qp, void *cb, void *data,\r\nunsigned int len)\r\n{\r\nstruct ntb_queue_entry *entry;\r\nif (!qp)\r\nreturn -EINVAL;\r\nentry = ntb_list_rm(&qp->ntb_rx_free_q_lock, &qp->rx_free_q);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->cb_data = cb;\r\nentry->buf = data;\r\nentry->len = len;\r\nntb_list_add(&qp->ntb_rx_pend_q_lock, &entry->entry, &qp->rx_pend_q);\r\nreturn 0;\r\n}\r\nint ntb_transport_tx_enqueue(struct ntb_transport_qp *qp, void *cb, void *data,\r\nunsigned int len)\r\n{\r\nstruct ntb_queue_entry *entry;\r\nint rc;\r\nif (!qp || qp->qp_link != NTB_LINK_UP || !len)\r\nreturn -EINVAL;\r\nentry = ntb_list_rm(&qp->ntb_tx_free_q_lock, &qp->tx_free_q);\r\nif (!entry) {\r\nqp->tx_err_no_buf++;\r\nreturn -ENOMEM;\r\n}\r\nentry->cb_data = cb;\r\nentry->buf = data;\r\nentry->len = len;\r\nentry->flags = 0;\r\nrc = ntb_process_tx(qp, entry);\r\nif (rc)\r\nntb_list_add(&qp->ntb_tx_free_q_lock, &entry->entry,\r\n&qp->tx_free_q);\r\nreturn rc;\r\n}\r\nvoid ntb_transport_link_up(struct ntb_transport_qp *qp)\r\n{\r\nif (!qp)\r\nreturn;\r\nqp->client_ready = NTB_LINK_UP;\r\nif (qp->transport->transport_link == NTB_LINK_UP)\r\nschedule_delayed_work(&qp->link_work, 0);\r\n}\r\nvoid ntb_transport_link_down(struct ntb_transport_qp *qp)\r\n{\r\nstruct pci_dev *pdev;\r\nint rc, val;\r\nif (!qp)\r\nreturn;\r\npdev = ntb_query_pdev(qp->ndev);\r\nqp->client_ready = NTB_LINK_DOWN;\r\nrc = ntb_read_local_spad(qp->ndev, QP_LINKS, &val);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Error reading spad %d\n", QP_LINKS);\r\nreturn;\r\n}\r\nrc = ntb_write_remote_spad(qp->ndev, QP_LINKS,\r\nval & ~(1 << qp->qp_num));\r\nif (rc)\r\ndev_err(&pdev->dev, "Error writing %x to remote spad %d\n",\r\nval & ~(1 << qp->qp_num), QP_LINKS);\r\nif (qp->qp_link == NTB_LINK_UP)\r\nntb_send_link_down(qp);\r\nelse\r\ncancel_delayed_work_sync(&qp->link_work);\r\n}\r\nbool ntb_transport_link_query(struct ntb_transport_qp *qp)\r\n{\r\nif (!qp)\r\nreturn false;\r\nreturn qp->qp_link == NTB_LINK_UP;\r\n}\r\nunsigned char ntb_transport_qp_num(struct ntb_transport_qp *qp)\r\n{\r\nif (!qp)\r\nreturn 0;\r\nreturn qp->qp_num;\r\n}\r\nunsigned int ntb_transport_max_size(struct ntb_transport_qp *qp)\r\n{\r\nunsigned int max;\r\nif (!qp)\r\nreturn 0;\r\nif (!qp->dma_chan)\r\nreturn qp->tx_max_frame - sizeof(struct ntb_payload_header);\r\nmax = qp->tx_max_frame - sizeof(struct ntb_payload_header);\r\nmax -= max % (1 << qp->dma_chan->device->copy_align);\r\nreturn max;\r\n}
