static int imx6q_set_target(struct cpufreq_policy *policy, unsigned int index)\r\n{\r\nstruct dev_pm_opp *opp;\r\nunsigned long freq_hz, volt, volt_old;\r\nunsigned int old_freq, new_freq;\r\nint ret;\r\nnew_freq = freq_table[index].frequency;\r\nfreq_hz = new_freq * 1000;\r\nold_freq = clk_get_rate(arm_clk) / 1000;\r\nrcu_read_lock();\r\nopp = dev_pm_opp_find_freq_ceil(cpu_dev, &freq_hz);\r\nif (IS_ERR(opp)) {\r\nrcu_read_unlock();\r\ndev_err(cpu_dev, "failed to find OPP for %ld\n", freq_hz);\r\nreturn PTR_ERR(opp);\r\n}\r\nvolt = dev_pm_opp_get_voltage(opp);\r\nrcu_read_unlock();\r\nvolt_old = regulator_get_voltage(arm_reg);\r\ndev_dbg(cpu_dev, "%u MHz, %ld mV --> %u MHz, %ld mV\n",\r\nold_freq / 1000, volt_old / 1000,\r\nnew_freq / 1000, volt / 1000);\r\nif (new_freq > old_freq) {\r\nif (!IS_ERR(pu_reg)) {\r\nret = regulator_set_voltage_tol(pu_reg, imx6_soc_volt[index], 0);\r\nif (ret) {\r\ndev_err(cpu_dev, "failed to scale vddpu up: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = regulator_set_voltage_tol(soc_reg, imx6_soc_volt[index], 0);\r\nif (ret) {\r\ndev_err(cpu_dev, "failed to scale vddsoc up: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_set_voltage_tol(arm_reg, volt, 0);\r\nif (ret) {\r\ndev_err(cpu_dev,\r\n"failed to scale vddarm up: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nclk_set_parent(step_clk, pll2_pfd2_396m_clk);\r\nclk_set_parent(pll1_sw_clk, step_clk);\r\nif (freq_hz > clk_get_rate(pll2_pfd2_396m_clk)) {\r\nclk_set_rate(pll1_sys_clk, new_freq * 1000);\r\nclk_set_parent(pll1_sw_clk, pll1_sys_clk);\r\n}\r\nret = clk_set_rate(arm_clk, new_freq * 1000);\r\nif (ret) {\r\ndev_err(cpu_dev, "failed to set clock rate: %d\n", ret);\r\nregulator_set_voltage_tol(arm_reg, volt_old, 0);\r\nreturn ret;\r\n}\r\nif (new_freq < old_freq) {\r\nret = regulator_set_voltage_tol(arm_reg, volt, 0);\r\nif (ret) {\r\ndev_warn(cpu_dev,\r\n"failed to scale vddarm down: %d\n", ret);\r\nret = 0;\r\n}\r\nret = regulator_set_voltage_tol(soc_reg, imx6_soc_volt[index], 0);\r\nif (ret) {\r\ndev_warn(cpu_dev, "failed to scale vddsoc down: %d\n", ret);\r\nret = 0;\r\n}\r\nif (!IS_ERR(pu_reg)) {\r\nret = regulator_set_voltage_tol(pu_reg, imx6_soc_volt[index], 0);\r\nif (ret) {\r\ndev_warn(cpu_dev, "failed to scale vddpu down: %d\n", ret);\r\nret = 0;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx6q_cpufreq_init(struct cpufreq_policy *policy)\r\n{\r\npolicy->clk = arm_clk;\r\nreturn cpufreq_generic_init(policy, freq_table, transition_latency);\r\n}\r\nstatic int imx6q_cpufreq_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np;\r\nstruct dev_pm_opp *opp;\r\nunsigned long min_volt, max_volt;\r\nint num, ret;\r\nconst struct property *prop;\r\nconst __be32 *val;\r\nu32 nr, i, j;\r\ncpu_dev = get_cpu_device(0);\r\nif (!cpu_dev) {\r\npr_err("failed to get cpu0 device\n");\r\nreturn -ENODEV;\r\n}\r\nnp = of_node_get(cpu_dev->of_node);\r\nif (!np) {\r\ndev_err(cpu_dev, "failed to find cpu0 node\n");\r\nreturn -ENOENT;\r\n}\r\narm_clk = clk_get(cpu_dev, "arm");\r\npll1_sys_clk = clk_get(cpu_dev, "pll1_sys");\r\npll1_sw_clk = clk_get(cpu_dev, "pll1_sw");\r\nstep_clk = clk_get(cpu_dev, "step");\r\npll2_pfd2_396m_clk = clk_get(cpu_dev, "pll2_pfd2_396m");\r\nif (IS_ERR(arm_clk) || IS_ERR(pll1_sys_clk) || IS_ERR(pll1_sw_clk) ||\r\nIS_ERR(step_clk) || IS_ERR(pll2_pfd2_396m_clk)) {\r\ndev_err(cpu_dev, "failed to get clocks\n");\r\nret = -ENOENT;\r\ngoto put_clk;\r\n}\r\narm_reg = regulator_get(cpu_dev, "arm");\r\npu_reg = regulator_get_optional(cpu_dev, "pu");\r\nsoc_reg = regulator_get(cpu_dev, "soc");\r\nif (IS_ERR(arm_reg) || IS_ERR(soc_reg)) {\r\ndev_err(cpu_dev, "failed to get regulators\n");\r\nret = -ENOENT;\r\ngoto put_reg;\r\n}\r\nnum = dev_pm_opp_get_opp_count(cpu_dev);\r\nif (num < 0) {\r\nret = of_init_opp_table(cpu_dev);\r\nif (ret < 0) {\r\ndev_err(cpu_dev, "failed to init OPP table: %d\n", ret);\r\ngoto put_reg;\r\n}\r\nfree_opp = true;\r\nnum = dev_pm_opp_get_opp_count(cpu_dev);\r\nif (num < 0) {\r\nret = num;\r\ndev_err(cpu_dev, "no OPP table is found: %d\n", ret);\r\ngoto out_free_opp;\r\n}\r\n}\r\nret = dev_pm_opp_init_cpufreq_table(cpu_dev, &freq_table);\r\nif (ret) {\r\ndev_err(cpu_dev, "failed to init cpufreq table: %d\n", ret);\r\ngoto put_reg;\r\n}\r\nimx6_soc_volt = devm_kzalloc(cpu_dev, sizeof(*imx6_soc_volt) * num, GFP_KERNEL);\r\nif (imx6_soc_volt == NULL) {\r\nret = -ENOMEM;\r\ngoto free_freq_table;\r\n}\r\nprop = of_find_property(np, "fsl,soc-operating-points", NULL);\r\nif (!prop || !prop->value)\r\ngoto soc_opp_out;\r\nnr = prop->length / sizeof(u32);\r\nif (nr % 2 || (nr / 2) < num)\r\ngoto soc_opp_out;\r\nfor (j = 0; j < num; j++) {\r\nval = prop->value;\r\nfor (i = 0; i < nr / 2; i++) {\r\nunsigned long freq = be32_to_cpup(val++);\r\nunsigned long volt = be32_to_cpup(val++);\r\nif (freq_table[j].frequency == freq) {\r\nimx6_soc_volt[soc_opp_count++] = volt;\r\nbreak;\r\n}\r\n}\r\n}\r\nsoc_opp_out:\r\nif (soc_opp_count != num) {\r\ndev_warn(cpu_dev, "can NOT find valid fsl,soc-operating-points property in dtb, use default value!\n");\r\nfor (j = 0; j < num; j++)\r\nimx6_soc_volt[j] = PU_SOC_VOLTAGE_NORMAL;\r\nif (freq_table[num - 1].frequency * 1000 == FREQ_1P2_GHZ)\r\nimx6_soc_volt[num - 1] = PU_SOC_VOLTAGE_HIGH;\r\n}\r\nif (of_property_read_u32(np, "clock-latency", &transition_latency))\r\ntransition_latency = CPUFREQ_ETERNAL;\r\nret = regulator_set_voltage_time(soc_reg, imx6_soc_volt[0], imx6_soc_volt[num - 1]);\r\nif (ret > 0)\r\ntransition_latency += ret * 1000;\r\nif (!IS_ERR(pu_reg)) {\r\nret = regulator_set_voltage_time(pu_reg, imx6_soc_volt[0], imx6_soc_volt[num - 1]);\r\nif (ret > 0)\r\ntransition_latency += ret * 1000;\r\n}\r\nrcu_read_lock();\r\nopp = dev_pm_opp_find_freq_exact(cpu_dev,\r\nfreq_table[0].frequency * 1000, true);\r\nmin_volt = dev_pm_opp_get_voltage(opp);\r\nopp = dev_pm_opp_find_freq_exact(cpu_dev,\r\nfreq_table[--num].frequency * 1000, true);\r\nmax_volt = dev_pm_opp_get_voltage(opp);\r\nrcu_read_unlock();\r\nret = regulator_set_voltage_time(arm_reg, min_volt, max_volt);\r\nif (ret > 0)\r\ntransition_latency += ret * 1000;\r\nret = cpufreq_register_driver(&imx6q_cpufreq_driver);\r\nif (ret) {\r\ndev_err(cpu_dev, "failed register driver: %d\n", ret);\r\ngoto free_freq_table;\r\n}\r\nof_node_put(np);\r\nreturn 0;\r\nfree_freq_table:\r\ndev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table);\r\nout_free_opp:\r\nif (free_opp)\r\nof_free_opp_table(cpu_dev);\r\nput_reg:\r\nif (!IS_ERR(arm_reg))\r\nregulator_put(arm_reg);\r\nif (!IS_ERR(pu_reg))\r\nregulator_put(pu_reg);\r\nif (!IS_ERR(soc_reg))\r\nregulator_put(soc_reg);\r\nput_clk:\r\nif (!IS_ERR(arm_clk))\r\nclk_put(arm_clk);\r\nif (!IS_ERR(pll1_sys_clk))\r\nclk_put(pll1_sys_clk);\r\nif (!IS_ERR(pll1_sw_clk))\r\nclk_put(pll1_sw_clk);\r\nif (!IS_ERR(step_clk))\r\nclk_put(step_clk);\r\nif (!IS_ERR(pll2_pfd2_396m_clk))\r\nclk_put(pll2_pfd2_396m_clk);\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\nstatic int imx6q_cpufreq_remove(struct platform_device *pdev)\r\n{\r\ncpufreq_unregister_driver(&imx6q_cpufreq_driver);\r\ndev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table);\r\nif (free_opp)\r\nof_free_opp_table(cpu_dev);\r\nregulator_put(arm_reg);\r\nif (!IS_ERR(pu_reg))\r\nregulator_put(pu_reg);\r\nregulator_put(soc_reg);\r\nclk_put(arm_clk);\r\nclk_put(pll1_sys_clk);\r\nclk_put(pll1_sw_clk);\r\nclk_put(step_clk);\r\nclk_put(pll2_pfd2_396m_clk);\r\nreturn 0;\r\n}
