static void _FWDownloadEnable(struct rtw_adapter *padapter, bool enable)\r\n{\r\nu8 tmp;\r\nif (enable) {\r\ntmp = rtl8723au_read8(padapter, REG_SYS_FUNC_EN + 1);\r\nrtl8723au_write8(padapter, REG_SYS_FUNC_EN + 1, tmp | 0x04);\r\ntmp = rtl8723au_read8(padapter, REG_MCUFWDL);\r\nrtl8723au_write8(padapter, REG_MCUFWDL, tmp | 0x01);\r\ntmp = rtl8723au_read8(padapter, REG_MCUFWDL + 2);\r\nrtl8723au_write8(padapter, REG_MCUFWDL + 2, tmp & 0xf7);\r\n} else {\r\ntmp = rtl8723au_read8(padapter, REG_MCUFWDL);\r\nrtl8723au_write8(padapter, REG_MCUFWDL, tmp & 0xfe);\r\nrtl8723au_write8(padapter, REG_MCUFWDL + 1, 0x00);\r\n}\r\n}\r\nstatic int\r\n_PageWrite(struct rtw_adapter *padapter, u32 page, void *buffer, u32 size)\r\n{\r\nu8 value8;\r\nu8 u8Page = (u8) (page & 0x07);\r\nif (size > MAX_PAGE_SIZE)\r\nreturn _FAIL;\r\nvalue8 = (rtl8723au_read8(padapter, REG_MCUFWDL + 2) & 0xF8) | u8Page;\r\nrtl8723au_write8(padapter, REG_MCUFWDL + 2, value8);\r\nreturn rtl8723au_writeN(padapter, FW_8723A_START_ADDRESS, size, buffer);\r\n}\r\nstatic int _WriteFW(struct rtw_adapter *padapter, void *buffer, u32 size)\r\n{\r\nint ret = _SUCCESS;\r\nu32 pageNums, remainSize;\r\nu32 page, offset;\r\nu8 *bufferPtr = (u8 *) buffer;\r\npageNums = size / MAX_PAGE_SIZE;\r\nremainSize = size % MAX_PAGE_SIZE;\r\nfor (page = 0; page < pageNums; page++) {\r\noffset = page * MAX_PAGE_SIZE;\r\nret = _PageWrite(padapter, page, bufferPtr + offset,\r\nMAX_PAGE_SIZE);\r\nif (ret == _FAIL)\r\ngoto exit;\r\n}\r\nif (remainSize) {\r\noffset = pageNums * MAX_PAGE_SIZE;\r\npage = pageNums;\r\nret = _PageWrite(padapter, page, bufferPtr + offset,\r\nremainSize);\r\nif (ret == _FAIL)\r\ngoto exit;\r\n}\r\nRT_TRACE(_module_hal_init_c_, _drv_info_,\r\n("_WriteFW Done- for Normal chip.\n"));\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int _FWFreeToGo(struct rtw_adapter *padapter)\r\n{\r\nu32 counter = 0;\r\nu32 value32;\r\ndo {\r\nvalue32 = rtl8723au_read32(padapter, REG_MCUFWDL);\r\nif (value32 & FWDL_ChkSum_rpt)\r\nbreak;\r\n} while (counter++ < POLLING_READY_TIMEOUT_COUNT);\r\nif (counter >= POLLING_READY_TIMEOUT_COUNT) {\r\nRT_TRACE(_module_hal_init_c_, _drv_err_,\r\n("%s: chksum report fail! REG_MCUFWDL:0x%08x\n",\r\n__func__, value32));\r\nreturn _FAIL;\r\n}\r\nRT_TRACE(_module_hal_init_c_, _drv_info_,\r\n("%s: Checksum report OK! REG_MCUFWDL:0x%08x\n", __func__,\r\nvalue32));\r\nvalue32 = rtl8723au_read32(padapter, REG_MCUFWDL);\r\nvalue32 |= MCUFWDL_RDY;\r\nvalue32 &= ~WINTINI_RDY;\r\nrtl8723au_write32(padapter, REG_MCUFWDL, value32);\r\ncounter = 0;\r\ndo {\r\nvalue32 = rtl8723au_read32(padapter, REG_MCUFWDL);\r\nif (value32 & WINTINI_RDY) {\r\nRT_TRACE(_module_hal_init_c_, _drv_info_,\r\n("%s: Polling FW ready success!! "\r\n"REG_MCUFWDL:0x%08x\n",\r\n__func__, value32));\r\nreturn _SUCCESS;\r\n}\r\nudelay(5);\r\n} while (counter++ < POLLING_READY_TIMEOUT_COUNT);\r\nRT_TRACE(_module_hal_init_c_, _drv_err_,\r\n("%s: Polling FW ready fail!! REG_MCUFWDL:0x%08x\n",\r\n__func__, value32));\r\nreturn _FAIL;\r\n}\r\nvoid rtl8723a_FirmwareSelfReset(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu8 u1bTmp;\r\nu8 Delay = 100;\r\nif (!(IS_FW_81xxC(padapter) &&\r\n((pHalData->FirmwareVersion < 0x21) ||\r\n(pHalData->FirmwareVersion == 0x21 &&\r\npHalData->FirmwareSubVersion < 0x01)))) {\r\nrtl8723au_write8(padapter, REG_HMETFR + 3, 0x20);\r\nu1bTmp = rtl8723au_read8(padapter, REG_SYS_FUNC_EN + 1);\r\nwhile (u1bTmp & BIT(2)) {\r\nDelay--;\r\nif (Delay == 0)\r\nbreak;\r\nudelay(50);\r\nu1bTmp = rtl8723au_read8(padapter, REG_SYS_FUNC_EN + 1);\r\n}\r\nRT_TRACE(_module_hal_init_c_, _drv_info_,\r\n("-%s: 8051 reset success (%d)\n", __func__,\r\nDelay));\r\nif ((Delay == 0)) {\r\nu1bTmp = rtl8723au_read8(padapter, REG_SYS_FUNC_EN + 1);\r\nrtl8723au_write8(padapter, REG_SYS_FUNC_EN + 1,\r\nu1bTmp & ~BIT(2));\r\n}\r\n}\r\n}\r\nint rtl8723a_FirmwareDownload(struct rtw_adapter *padapter)\r\n{\r\nint rtStatus = _SUCCESS;\r\nu8 writeFW_retry = 0;\r\nunsigned long fwdl_start_time;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct dvobj_priv *dvobj = adapter_to_dvobj(padapter);\r\nstruct device *device = dvobj_to_dev(dvobj);\r\nstruct rt_8723a_firmware_hdr *pFwHdr = NULL;\r\nconst struct firmware *fw;\r\nchar *fw_name;\r\nu8 *firmware_buf = NULL;\r\nu8 *buf;\r\nint fw_size;\r\nstatic int log_version;\r\nRT_TRACE(_module_hal_init_c_, _drv_info_, ("+%s\n", __func__));\r\nif (IS_8723A_A_CUT(pHalData->VersionID)) {\r\nfw_name = "rtlwifi/rtl8723aufw_A.bin";\r\nRT_TRACE(_module_hal_init_c_, _drv_info_,\r\n("rtl8723a_FirmwareDownload: R8723FwImageArray_UMC "\r\n"for RTL8723A A CUT\n"));\r\n} else if (IS_8723A_B_CUT(pHalData->VersionID)) {\r\nif (padapter->registrypriv.wifi_spec == 1) {\r\nfw_name = "rtlwifi/rtl8723aufw_B_NoBT.bin";\r\nDBG_8723A(" Rtl8723_FwUMCBCutImageArrayWithoutBT for "\r\n"RTL8723A B CUT\n");\r\n} else {\r\nif (rtl8723a_BT_coexist(padapter)) {\r\nfw_name = "rtlwifi/rtl8723aufw_B.bin";\r\nDBG_8723A(" Rtl8723_FwUMCBCutImageArrayWithBT "\r\n"for RTL8723A B CUT\n");\r\n} else {\r\nfw_name = "rtlwifi/rtl8723aufw_B_NoBT.bin";\r\nDBG_8723A(" Rtl8723_FwUMCBCutImageArrayWithout "\r\n"BT for RTL8723A B CUT\n");\r\n}\r\n}\r\n} else {\r\nRT_TRACE(_module_hal_init_c_, _drv_err_,\r\n("%s: unknow version!\n", __func__));\r\nrtStatus = _FAIL;\r\ngoto Exit;\r\n}\r\npr_info("rtl8723au: Loading firmware %s\n", fw_name);\r\nif (request_firmware(&fw, fw_name, device)) {\r\npr_err("rtl8723au: request_firmware load failed\n");\r\nrtStatus = _FAIL;\r\ngoto Exit;\r\n}\r\nif (!fw) {\r\npr_err("rtl8723au: Firmware %s not available\n", fw_name);\r\nrtStatus = _FAIL;\r\ngoto Exit;\r\n}\r\nfirmware_buf = kmemdup(fw->data, fw->size, GFP_KERNEL);\r\nif (!firmware_buf) {\r\nrtStatus = _FAIL;\r\ngoto Exit;\r\n}\r\nbuf = firmware_buf;\r\nfw_size = fw->size;\r\nrelease_firmware(fw);\r\npFwHdr = (struct rt_8723a_firmware_hdr *)firmware_buf;\r\npHalData->FirmwareVersion = le16_to_cpu(pFwHdr->Version);\r\npHalData->FirmwareSubVersion = pFwHdr->Subversion;\r\npHalData->FirmwareSignature = le16_to_cpu(pFwHdr->Signature);\r\nDBG_8723A("%s: fw_ver =%d fw_subver =%d sig = 0x%x\n",\r\n__func__, pHalData->FirmwareVersion,\r\npHalData->FirmwareSubVersion, pHalData->FirmwareSignature);\r\nif (!log_version++)\r\npr_info("%sFirmware Version %d, SubVersion %d, Signature "\r\n"0x%x\n", DRIVER_PREFIX, pHalData->FirmwareVersion,\r\npHalData->FirmwareSubVersion,\r\npHalData->FirmwareSignature);\r\nif (IS_FW_HEADER_EXIST(pFwHdr)) {\r\nbuf = buf + 32;\r\nfw_size = fw_size - 32;\r\n}\r\nif (rtl8723au_read8(padapter, REG_MCUFWDL) & RAM_DL_SEL) {\r\nrtl8723a_FirmwareSelfReset(padapter);\r\nrtl8723au_write8(padapter, REG_MCUFWDL, 0x00);\r\n}\r\n_FWDownloadEnable(padapter, true);\r\nfwdl_start_time = jiffies;\r\nwhile (1) {\r\nrtl8723au_write8(padapter, REG_MCUFWDL,\r\nrtl8723au_read8(padapter, REG_MCUFWDL) |\r\nFWDL_ChkSum_rpt);\r\nrtStatus = _WriteFW(padapter, buf, fw_size);\r\nif (rtStatus == _SUCCESS ||\r\n(jiffies_to_msecs(jiffies - fwdl_start_time) > 500 &&\r\nwriteFW_retry++ >= 3))\r\nbreak;\r\nDBG_8723A("%s writeFW_retry:%u, time after fwdl_start_time:"\r\n"%ums\n", __func__, writeFW_retry,\r\njiffies_to_msecs(jiffies - fwdl_start_time));\r\n}\r\n_FWDownloadEnable(padapter, false);\r\nif (_SUCCESS != rtStatus) {\r\nDBG_8723A("DL Firmware failed!\n");\r\ngoto Exit;\r\n}\r\nrtStatus = _FWFreeToGo(padapter);\r\nif (_SUCCESS != rtStatus) {\r\nRT_TRACE(_module_hal_init_c_, _drv_err_,\r\n("DL Firmware failed!\n"));\r\ngoto Exit;\r\n}\r\nRT_TRACE(_module_hal_init_c_, _drv_info_,\r\n("Firmware is ready to run!\n"));\r\nExit:\r\nkfree(firmware_buf);\r\nreturn rtStatus;\r\n}\r\nvoid rtl8723a_InitializeFirmwareVars(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\npadapter->pwrctrlpriv.bFwCurrentInPSMode = false;\r\npHalData->LastHMEBoxNum = 0;\r\n}\r\nstatic u8\r\nhal_EfuseSwitchToBank(struct rtw_adapter *padapter, u8 bank)\r\n{\r\nu8 bRet = false;\r\nu32 value32 = 0;\r\nDBG_8723A("%s: Efuse switch bank to %d\n", __func__, bank);\r\nvalue32 = rtl8723au_read32(padapter, EFUSE_TEST);\r\nbRet = true;\r\nswitch (bank) {\r\ncase 0:\r\nvalue32 = (value32 & ~EFUSE_SEL_MASK) |\r\nEFUSE_SEL(EFUSE_WIFI_SEL_0);\r\nbreak;\r\ncase 1:\r\nvalue32 = (value32 & ~EFUSE_SEL_MASK) |\r\nEFUSE_SEL(EFUSE_BT_SEL_0);\r\nbreak;\r\ncase 2:\r\nvalue32 = (value32 & ~EFUSE_SEL_MASK) |\r\nEFUSE_SEL(EFUSE_BT_SEL_1);\r\nbreak;\r\ncase 3:\r\nvalue32 = (value32 & ~EFUSE_SEL_MASK) |\r\nEFUSE_SEL(EFUSE_BT_SEL_2);\r\nbreak;\r\ndefault:\r\nvalue32 = (value32 & ~EFUSE_SEL_MASK) |\r\nEFUSE_SEL(EFUSE_WIFI_SEL_0);\r\nbRet = false;\r\nbreak;\r\n}\r\nrtl8723au_write32(padapter, EFUSE_TEST, value32);\r\nreturn bRet;\r\n}\r\nstatic void\r\nhal_ReadEFuse_WiFi(struct rtw_adapter *padapter,\r\nu16 _offset, u16 _size_byte, u8 *pbuf)\r\n{\r\nu8 *efuseTbl = NULL;\r\nu16 eFuse_Addr = 0;\r\nu8 offset, wden;\r\nu8 efuseHeader, efuseExtHdr, efuseData;\r\nu16 i, total, used;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif ((_offset + _size_byte) > EFUSE_MAP_LEN_8723A) {\r\nDBG_8723A("%s: Invalid offset(%#x) with read bytes(%#x)!!\n",\r\n__func__, _offset, _size_byte);\r\nreturn;\r\n}\r\nefuseTbl = kmalloc(EFUSE_MAP_LEN_8723A, GFP_KERNEL);\r\nif (efuseTbl == NULL) {\r\nDBG_8723A("%s: alloc efuseTbl fail!\n", __func__);\r\nreturn;\r\n}\r\nmemset(efuseTbl, 0xFF, EFUSE_MAP_LEN_8723A);\r\nhal_EfuseSwitchToBank(padapter, 0);\r\nwhile (AVAILABLE_EFUSE_ADDR(eFuse_Addr)) {\r\nReadEFuseByte23a(padapter, eFuse_Addr++, &efuseHeader);\r\nif (efuseHeader == 0xFF) {\r\nDBG_8723A("%s: data end at address =%#x\n", __func__,\r\neFuse_Addr);\r\nbreak;\r\n}\r\nif (EXT_HEADER(efuseHeader)) {\r\noffset = GET_HDR_OFFSET_2_0(efuseHeader);\r\nReadEFuseByte23a(padapter, eFuse_Addr++, &efuseExtHdr);\r\nif (ALL_WORDS_DISABLED(efuseExtHdr)) {\r\ncontinue;\r\n}\r\noffset |= ((efuseExtHdr & 0xF0) >> 1);\r\nwden = (efuseExtHdr & 0x0F);\r\n} else {\r\noffset = ((efuseHeader >> 4) & 0x0f);\r\nwden = (efuseHeader & 0x0f);\r\n}\r\nif (offset < EFUSE_MAX_SECTION_8723A) {\r\nu16 addr;\r\naddr = offset * PGPKT_DATA_SIZE;\r\nfor (i = 0; i < EFUSE_MAX_WORD_UNIT; i++) {\r\nif (!(wden & (0x01 << i))) {\r\nReadEFuseByte23a(padapter, eFuse_Addr++,\r\n&efuseData);\r\nefuseTbl[addr] = efuseData;\r\nReadEFuseByte23a(padapter, eFuse_Addr++,\r\n&efuseData);\r\nefuseTbl[addr + 1] = efuseData;\r\n}\r\naddr += 2;\r\n}\r\n} else {\r\nDBG_8723A(KERN_ERR "%s: offset(%d) is illegal!!\n",\r\n__func__, offset);\r\neFuse_Addr += Efuse_CalculateWordCnts23a(wden) * 2;\r\n}\r\n}\r\nfor (i = 0; i < _size_byte; i++)\r\npbuf[i] = efuseTbl[_offset + i];\r\nEFUSE_GetEfuseDefinition23a(padapter, EFUSE_WIFI,\r\nTYPE_AVAILABLE_EFUSE_BYTES_TOTAL, &total);\r\nused = eFuse_Addr - 1;\r\npHalData->EfuseUsedBytes = used;\r\nkfree(efuseTbl);\r\n}\r\nstatic void\r\nhal_ReadEFuse_BT(struct rtw_adapter *padapter,\r\nu16 _offset, u16 _size_byte, u8 *pbuf)\r\n{\r\nu8 *efuseTbl;\r\nu8 bank;\r\nu16 eFuse_Addr;\r\nu8 efuseHeader, efuseExtHdr, efuseData;\r\nu8 offset, wden;\r\nu16 i, total, used;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif ((_offset + _size_byte) > EFUSE_BT_MAP_LEN) {\r\nDBG_8723A("%s: Invalid offset(%#x) with read bytes(%#x)!!\n",\r\n__func__, _offset, _size_byte);\r\nreturn;\r\n}\r\nefuseTbl = kmalloc(EFUSE_BT_MAP_LEN, GFP_KERNEL);\r\nif (efuseTbl == NULL) {\r\nDBG_8723A("%s: efuseTbl malloc fail!\n", __func__);\r\nreturn;\r\n}\r\nmemset(efuseTbl, 0xFF, EFUSE_BT_MAP_LEN);\r\nEFUSE_GetEfuseDefinition23a(padapter, EFUSE_BT,\r\nTYPE_AVAILABLE_EFUSE_BYTES_BANK, &total);\r\nfor (bank = 1; bank < EFUSE_MAX_BANK; bank++) {\r\nif (hal_EfuseSwitchToBank(padapter, bank) == false) {\r\nDBG_8723A("%s: hal_EfuseSwitchToBank Fail!!\n",\r\n__func__);\r\ngoto exit;\r\n}\r\neFuse_Addr = 0;\r\nwhile (AVAILABLE_EFUSE_ADDR(eFuse_Addr)) {\r\nReadEFuseByte23a(padapter, eFuse_Addr++, &efuseHeader);\r\nif (efuseHeader == 0xFF)\r\nbreak;\r\nif (EXT_HEADER(efuseHeader)) {\r\noffset = GET_HDR_OFFSET_2_0(efuseHeader);\r\nReadEFuseByte23a(padapter, eFuse_Addr++,\r\n&efuseExtHdr);\r\nif (ALL_WORDS_DISABLED(efuseExtHdr)) {\r\ncontinue;\r\n}\r\noffset |= ((efuseExtHdr & 0xF0) >> 1);\r\nwden = (efuseExtHdr & 0x0F);\r\n} else {\r\noffset = ((efuseHeader >> 4) & 0x0f);\r\nwden = (efuseHeader & 0x0f);\r\n}\r\nif (offset < EFUSE_BT_MAX_SECTION) {\r\nu16 addr;\r\naddr = offset * PGPKT_DATA_SIZE;\r\nfor (i = 0; i < EFUSE_MAX_WORD_UNIT; i++) {\r\nif (!(wden & (0x01 << i))) {\r\nReadEFuseByte23a(padapter,\r\neFuse_Addr++,\r\n&efuseData);\r\nefuseTbl[addr] = efuseData;\r\nReadEFuseByte23a(padapter,\r\neFuse_Addr++,\r\n&efuseData);\r\nefuseTbl[addr + 1] = efuseData;\r\n}\r\naddr += 2;\r\n}\r\n} else {\r\nDBG_8723A(KERN_ERR\r\n"%s: offset(%d) is illegal!!\n",\r\n__func__, offset);\r\neFuse_Addr += Efuse_CalculateWordCnts23a(wden) * 2;\r\n}\r\n}\r\nif ((eFuse_Addr - 1) < total) {\r\nDBG_8723A("%s: bank(%d) data end at %#x\n",\r\n__func__, bank, eFuse_Addr - 1);\r\nbreak;\r\n}\r\n}\r\nhal_EfuseSwitchToBank(padapter, 0);\r\nfor (i = 0; i < _size_byte; i++)\r\npbuf[i] = efuseTbl[_offset + i];\r\nEFUSE_GetEfuseDefinition23a(padapter, EFUSE_BT,\r\nTYPE_AVAILABLE_EFUSE_BYTES_TOTAL, &total);\r\nused = (EFUSE_BT_REAL_BANK_CONTENT_LEN * (bank - 1)) + eFuse_Addr - 1;\r\npHalData->BTEfuseUsedBytes = used;\r\nexit:\r\nkfree(efuseTbl);\r\n}\r\nvoid\r\nrtl8723a_readefuse(struct rtw_adapter *padapter,\r\nu8 efuseType, u16 _offset, u16 _size_byte, u8 *pbuf)\r\n{\r\nif (efuseType == EFUSE_WIFI)\r\nhal_ReadEFuse_WiFi(padapter, _offset, _size_byte, pbuf);\r\nelse\r\nhal_ReadEFuse_BT(padapter, _offset, _size_byte, pbuf);\r\n}\r\nu16 rtl8723a_EfuseGetCurrentSize_WiFi(struct rtw_adapter *padapter)\r\n{\r\nu16 efuse_addr = 0;\r\nu8 hoffset = 0, hworden = 0;\r\nu8 efuse_data, word_cnts = 0;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nefuse_addr = pHalData->EfuseUsedBytes;\r\nDBG_8723A("%s: start_efuse_addr = 0x%X\n", __func__, efuse_addr);\r\nhal_EfuseSwitchToBank(padapter, 0);\r\nwhile (AVAILABLE_EFUSE_ADDR(efuse_addr)) {\r\nif (efuse_OneByteRead23a(padapter, efuse_addr, &efuse_data) ==\r\n_FAIL) {\r\nDBG_8723A(KERN_ERR "%s: efuse_OneByteRead23a Fail! "\r\n"addr = 0x%X !!\n", __func__, efuse_addr);\r\nbreak;\r\n}\r\nif (efuse_data == 0xFF)\r\nbreak;\r\nif (EXT_HEADER(efuse_data)) {\r\nhoffset = GET_HDR_OFFSET_2_0(efuse_data);\r\nefuse_addr++;\r\nefuse_OneByteRead23a(padapter, efuse_addr, &efuse_data);\r\nif (ALL_WORDS_DISABLED(efuse_data)) {\r\ncontinue;\r\n}\r\nhoffset |= ((efuse_data & 0xF0) >> 1);\r\nhworden = efuse_data & 0x0F;\r\n} else {\r\nhoffset = (efuse_data >> 4) & 0x0F;\r\nhworden = efuse_data & 0x0F;\r\n}\r\nword_cnts = Efuse_CalculateWordCnts23a(hworden);\r\nefuse_addr += (word_cnts * 2) + 1;\r\n}\r\npHalData->EfuseUsedBytes = efuse_addr;\r\nDBG_8723A("%s: CurrentSize =%d\n", __func__, efuse_addr);\r\nreturn efuse_addr;\r\n}\r\nu16 rtl8723a_EfuseGetCurrentSize_BT(struct rtw_adapter *padapter)\r\n{\r\nu16 btusedbytes;\r\nu16 efuse_addr;\r\nu8 bank, startBank;\r\nu8 hoffset = 0, hworden = 0;\r\nu8 efuse_data, word_cnts = 0;\r\nu16 retU2 = 0;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nbtusedbytes = pHalData->BTEfuseUsedBytes;\r\nefuse_addr = (u16) ((btusedbytes % EFUSE_BT_REAL_BANK_CONTENT_LEN));\r\nstartBank = (u8) (1 + (btusedbytes / EFUSE_BT_REAL_BANK_CONTENT_LEN));\r\nDBG_8723A("%s: start from bank =%d addr = 0x%X\n", __func__, startBank,\r\nefuse_addr);\r\nEFUSE_GetEfuseDefinition23a(padapter, EFUSE_BT,\r\nTYPE_AVAILABLE_EFUSE_BYTES_BANK, &retU2);\r\nfor (bank = startBank; bank < EFUSE_MAX_BANK; bank++) {\r\nif (hal_EfuseSwitchToBank(padapter, bank) == false) {\r\nDBG_8723A(KERN_ERR "%s: switch bank(%d) Fail!!\n",\r\n__func__, bank);\r\nbank = EFUSE_MAX_BANK;\r\nbreak;\r\n}\r\nif (bank != startBank)\r\nefuse_addr = 0;\r\nwhile (AVAILABLE_EFUSE_ADDR(efuse_addr)) {\r\nif (efuse_OneByteRead23a(padapter, efuse_addr,\r\n&efuse_data) == _FAIL) {\r\nDBG_8723A(KERN_ERR "%s: efuse_OneByteRead23a Fail!"\r\n" addr = 0x%X !!\n",\r\n__func__, efuse_addr);\r\nbank = EFUSE_MAX_BANK;\r\nbreak;\r\n}\r\nif (efuse_data == 0xFF)\r\nbreak;\r\nif (EXT_HEADER(efuse_data)) {\r\nhoffset = GET_HDR_OFFSET_2_0(efuse_data);\r\nefuse_addr++;\r\nefuse_OneByteRead23a(padapter, efuse_addr,\r\n&efuse_data);\r\nif (ALL_WORDS_DISABLED(efuse_data)) {\r\nefuse_addr++;\r\ncontinue;\r\n}\r\nhoffset |= ((efuse_data & 0xF0) >> 1);\r\nhworden = efuse_data & 0x0F;\r\n} else {\r\nhoffset = (efuse_data >> 4) & 0x0F;\r\nhworden = efuse_data & 0x0F;\r\n}\r\nword_cnts = Efuse_CalculateWordCnts23a(hworden);\r\nefuse_addr += (word_cnts * 2) + 1;\r\n}\r\nif (efuse_addr < retU2) {\r\nbreak;\r\n}\r\n}\r\nretU2 = ((bank - 1) * EFUSE_BT_REAL_BANK_CONTENT_LEN) + efuse_addr;\r\npHalData->BTEfuseUsedBytes = retU2;\r\nDBG_8723A("%s: CurrentSize =%d\n", __func__, retU2);\r\nreturn retU2;\r\n}\r\nvoid rtl8723a_read_chip_version(struct rtw_adapter *padapter)\r\n{\r\nu32 value32;\r\nstruct hal_version ChipVersion;\r\nstruct hal_data_8723a *pHalData;\r\npHalData = GET_HAL_DATA(padapter);\r\nvalue32 = rtl8723au_read32(padapter, REG_SYS_CFG);\r\nChipVersion.ICType = CHIP_8723A;\r\nChipVersion.ChipType = ((value32 & RTL_ID) ? TEST_CHIP : NORMAL_CHIP);\r\nChipVersion.RFType = RF_TYPE_1T1R;\r\nChipVersion.VendorType =\r\n((value32 & VENDOR_ID) ? CHIP_VENDOR_UMC : CHIP_VENDOR_TSMC);\r\nChipVersion.CUTVersion = (value32 & CHIP_VER_RTL_MASK) >> CHIP_VER_RTL_SHIFT;\r\npHalData->RegulatorMode = ((value32 & SPS_SEL) ?\r\nRT_LDO_REGULATOR : RT_SWITCHING_REGULATOR);\r\nvalue32 = rtl8723au_read32(padapter, REG_GPIO_OUTSTS);\r\nChipVersion.ROMVer = ((value32 & RF_RL_ID) >> 20);\r\npHalData->MultiFunc = RT_MULTI_FUNC_NONE;\r\nvalue32 = rtl8723au_read32(padapter, REG_MULTI_FUNC_CTRL);\r\npHalData->MultiFunc |=\r\n((value32 & WL_FUNC_EN) ? RT_MULTI_FUNC_WIFI : 0);\r\npHalData->MultiFunc |= ((value32 & BT_FUNC_EN) ? RT_MULTI_FUNC_BT : 0);\r\npHalData->MultiFunc |=\r\n((value32 & GPS_FUNC_EN) ? RT_MULTI_FUNC_GPS : 0);\r\npHalData->PolarityCtl =\r\n((value32 & WL_HWPDN_SL) ? RT_POLARITY_HIGH_ACT :\r\nRT_POLARITY_LOW_ACT);\r\ndump_chip_info23a(ChipVersion);\r\npHalData->VersionID = ChipVersion;\r\nif (IS_1T2R(ChipVersion))\r\npHalData->rf_type = RF_1T2R;\r\nelse if (IS_2T2R(ChipVersion))\r\npHalData->rf_type = RF_2T2R;\r\nelse\r\npHalData->rf_type = RF_1T1R;\r\nMSG_8723A("RF_Type is %x!!\n", pHalData->rf_type);\r\n}\r\nvoid SetBcnCtrlReg23a(struct rtw_adapter *padapter, u8 SetBits, u8 ClearBits)\r\n{\r\nu8 val8;\r\nval8 = rtl8723au_read8(padapter, REG_BCN_CTRL);\r\nval8 |= SetBits;\r\nval8 &= ~ClearBits;\r\nrtl8723au_write8(padapter, REG_BCN_CTRL, val8);\r\n}\r\nvoid rtl8723a_InitBeaconParameters(struct rtw_adapter *padapter)\r\n{\r\nrtl8723au_write16(padapter, REG_BCN_CTRL, 0x1010);\r\nrtl8723au_write16(padapter, REG_TBTT_PROHIBIT, 0x6404);\r\nif (check_fwstate(&padapter->mlmepriv, WIFI_STATION_STATE) == false)\r\nrtl8723au_write8(padapter, REG_DRVERLYINT,\r\nDRIVER_EARLY_INT_TIME);\r\nrtl8723au_write8(padapter, REG_BCNDMATIM, BCN_DMA_ATIME_INT_TIME);\r\nrtl8723au_write16(padapter, REG_BCNTCFG, 0x660F);\r\n}\r\nstatic void ResumeTxBeacon(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("+ResumeTxBeacon\n"));\r\npHalData->RegFwHwTxQCtrl |= BIT(6);\r\nrtl8723au_write8(padapter, REG_FWHW_TXQ_CTRL + 2,\r\npHalData->RegFwHwTxQCtrl);\r\nrtl8723au_write8(padapter, REG_TBTT_PROHIBIT + 1, 0xff);\r\npHalData->RegReg542 |= BIT(0);\r\nrtl8723au_write8(padapter, REG_TBTT_PROHIBIT + 2, pHalData->RegReg542);\r\n}\r\nstatic void StopTxBeacon(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_, ("+StopTxBeacon\n"));\r\npHalData->RegFwHwTxQCtrl &= ~BIT(6);\r\nrtl8723au_write8(padapter, REG_FWHW_TXQ_CTRL + 2,\r\npHalData->RegFwHwTxQCtrl);\r\nrtl8723au_write8(padapter, REG_TBTT_PROHIBIT + 1, 0x64);\r\npHalData->RegReg542 &= ~BIT(0);\r\nrtl8723au_write8(padapter, REG_TBTT_PROHIBIT + 2, pHalData->RegReg542);\r\n}\r\nstatic void _BeaconFunctionEnable(struct rtw_adapter *padapter, u8 Enable,\r\nu8 Linked)\r\n{\r\nSetBcnCtrlReg23a(padapter, DIS_TSF_UDT | EN_BCN_FUNCTION | DIS_BCNQ_SUB,\r\n0);\r\nrtl8723au_write8(padapter, REG_RD_CTRL + 1, 0x6F);\r\n}\r\nvoid rtl8723a_SetBeaconRelatedRegisters(struct rtw_adapter *padapter)\r\n{\r\nu32 value32;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\nrtl8723au_write16(padapter, REG_ATIMWND, 2);\r\nrtl8723au_write16(padapter, REG_BCN_INTERVAL, pmlmeinfo->bcn_interval);\r\nrtl8723a_InitBeaconParameters(padapter);\r\nrtl8723au_write8(padapter, REG_SLOT, 0x09);\r\nvalue32 = rtl8723au_read32(padapter, REG_TCR);\r\nvalue32 &= ~TSFRST;\r\nrtl8723au_write32(padapter, REG_TCR, value32);\r\nvalue32 |= TSFRST;\r\nrtl8723au_write32(padapter, REG_TCR, value32);\r\nif (check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE |\r\nWIFI_ADHOC_MASTER_STATE | WIFI_AP_STATE) == true) {\r\nrtl8723au_write8(padapter, REG_RXTSF_OFFSET_CCK, 0x50);\r\nrtl8723au_write8(padapter, REG_RXTSF_OFFSET_OFDM, 0x50);\r\n}\r\n_BeaconFunctionEnable(padapter, true, true);\r\nResumeTxBeacon(padapter);\r\nSetBcnCtrlReg23a(padapter, DIS_BCNQ_SUB, 0);\r\n}\r\nvoid rtl8723a_SetHalODMVar(struct rtw_adapter *Adapter,\r\nenum hal_odm_variable eVariable,\r\nvoid *pValue1, bool bSet)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(Adapter);\r\nstruct dm_odm_t *podmpriv = &pHalData->odmpriv;\r\nswitch (eVariable) {\r\ncase HAL_ODM_STA_INFO:\r\n{\r\nstruct sta_info *psta = (struct sta_info *)pValue1;\r\nif (bSet) {\r\nDBG_8723A("Set STA_(%d) info\n", psta->mac_id);\r\nODM_CmnInfoPtrArrayHook23a(podmpriv,\r\nODM_CMNINFO_STA_STATUS,\r\npsta->mac_id, psta);\r\n} else {\r\nDBG_8723A("Clean STA_(%d) info\n", psta->mac_id);\r\nODM_CmnInfoPtrArrayHook23a(podmpriv,\r\nODM_CMNINFO_STA_STATUS,\r\npsta->mac_id, NULL);\r\n}\r\n}\r\nbreak;\r\ncase HAL_ODM_P2P_STATE:\r\nODM_CmnInfoUpdate23a(podmpriv, ODM_CMNINFO_WIFI_DIRECT, bSet);\r\nbreak;\r\ncase HAL_ODM_WIFI_DISPLAY_STATE:\r\nODM_CmnInfoUpdate23a(podmpriv, ODM_CMNINFO_WIFI_DISPLAY, bSet);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid rtl8723a_notch_filter(struct rtw_adapter *adapter, bool enable)\r\n{\r\nif (enable) {\r\nDBG_8723A("Enable notch filter\n");\r\nrtl8723au_write8(adapter, rOFDM0_RxDSP + 1,\r\nrtl8723au_read8(adapter, rOFDM0_RxDSP + 1) |\r\nBIT(1));\r\n} else {\r\nDBG_8723A("Disable notch filter\n");\r\nrtl8723au_write8(adapter, rOFDM0_RxDSP + 1,\r\nrtl8723au_read8(adapter, rOFDM0_RxDSP + 1) &\r\n~BIT(1));\r\n}\r\n}\r\nbool c2h_id_filter_ccx_8723a(u8 id)\r\n{\r\nbool ret = false;\r\nif (id == C2H_CCX_TX_RPT)\r\nret = true;\r\nreturn ret;\r\n}\r\nint c2h_handler_8723a(struct rtw_adapter *padapter, struct c2h_evt_hdr *c2h_evt)\r\n{\r\nint ret = _SUCCESS;\r\nu8 i = 0;\r\nif (c2h_evt == NULL) {\r\nDBG_8723A("%s c2h_evt is NULL\n", __func__);\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nswitch (c2h_evt->id) {\r\ncase C2H_DBG:\r\nRT_TRACE(_module_hal_init_c_, _drv_info_,\r\n("C2HCommandHandler: %s\n", c2h_evt->payload));\r\nbreak;\r\ncase C2H_CCX_TX_RPT:\r\nhandle_txrpt_ccx_8723a(padapter, c2h_evt->payload);\r\nbreak;\r\ncase C2H_EXT_RA_RPT:\r\nbreak;\r\ncase C2H_HW_INFO_EXCH:\r\nRT_TRACE(_module_hal_init_c_, _drv_info_,\r\n("[BT], C2H_HW_INFO_EXCH\n"));\r\nfor (i = 0; i < c2h_evt->plen; i++) {\r\nRT_TRACE(_module_hal_init_c_, _drv_info_,\r\n("[BT], tmpBuf[%d]= 0x%x\n", i,\r\nc2h_evt->payload[i]));\r\n}\r\nbreak;\r\ncase C2H_C2H_H2C_TEST:\r\nRT_TRACE(_module_hal_init_c_, _drv_info_,\r\n("[BT], C2H_H2C_TEST\n"));\r\nRT_TRACE(_module_hal_init_c_, _drv_info_,\r\n("[BT], tmpBuf[0]/[1]/[2]/[3]/[4]= 0x%x/ 0x%x/ "\r\n"0x%x/ 0x%x/ 0x%x\n", c2h_evt->payload[0],\r\nc2h_evt->payload[1], c2h_evt->payload[2],\r\nc2h_evt->payload[3], c2h_evt->payload[4]));\r\nbreak;\r\ncase C2H_BT_INFO:\r\nDBG_8723A("%s , Got C2H_BT_INFO \n", __func__);\r\nrtl8723a_fw_c2h_BT_info(padapter,\r\nc2h_evt->payload, c2h_evt->plen);\r\nbreak;\r\ndefault:\r\nret = _FAIL;\r\nbreak;\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nvoid handle_txrpt_ccx_8723a(struct rtw_adapter *adapter, void *buf)\r\n{\r\nstruct txrpt_ccx_8723a *txrpt_ccx = buf;\r\nstruct submit_ctx *pack_tx_ops = &adapter->xmitpriv.ack_tx_ops;\r\nif (txrpt_ccx->int_ccx && adapter->xmitpriv.ack_tx) {\r\nif (txrpt_ccx->pkt_ok)\r\nrtw23a_sctx_done_err(&pack_tx_ops,\r\nRTW_SCTX_DONE_SUCCESS);\r\nelse\r\nrtw23a_sctx_done_err(&pack_tx_ops,\r\nRTW_SCTX_DONE_CCX_PKT_FAIL);\r\n}\r\n}\r\nvoid rtl8723a_InitAntenna_Selection(struct rtw_adapter *padapter)\r\n{\r\nu8 val;\r\nval = rtl8723au_read8(padapter, REG_LEDCFG2);\r\nval |= BIT(7);\r\nrtl8723au_write8(padapter, REG_LEDCFG2, val);\r\n}\r\nvoid rtl8723a_CheckAntenna_Selection(struct rtw_adapter *padapter)\r\n{\r\nu8 val;\r\nval = rtl8723au_read8(padapter, REG_LEDCFG2);\r\nif (!(val & BIT(7))) {\r\nval |= BIT(7);\r\nrtl8723au_write8(padapter, REG_LEDCFG2, val);\r\n}\r\n}\r\nvoid rtl8723a_DeinitAntenna_Selection(struct rtw_adapter *padapter)\r\n{\r\nu8 val;\r\nval = rtl8723au_read8(padapter, REG_LEDCFG2);\r\nval &= ~BIT(7);\r\nrtl8723au_write8(padapter, REG_LEDCFG2, val);\r\n}\r\nvoid rtl8723a_init_default_value(struct rtw_adapter *padapter)\r\n{\r\nstruct hal_data_8723a *pHalData;\r\nstruct dm_priv *pdmpriv;\r\nu8 i;\r\npHalData = GET_HAL_DATA(padapter);\r\npdmpriv = &pHalData->dmpriv;\r\npHalData->fw_ractrl = false;\r\npHalData->bIQKInitialized = false;\r\nif (!padapter->pwrctrlpriv.bkeepfwalive)\r\npHalData->LastHMEBoxNum = 0;\r\npHalData->bIQKInitialized = false;\r\npdmpriv->TM_Trigger = 0;\r\npdmpriv->ThermalValue_HP_index = 0;\r\nfor (i = 0; i < HP_THERMAL_NUM; i++)\r\npdmpriv->ThermalValue_HP[i] = 0;\r\npHalData->EfuseUsedBytes = 0;\r\npHalData->BTEfuseUsedBytes = 0;\r\n}\r\nu8 GetEEPROMSize8723A(struct rtw_adapter *padapter)\r\n{\r\nu8 size = 0;\r\nu32 cr;\r\ncr = rtl8723au_read16(padapter, REG_9346CR);\r\nsize = (cr & BOOT_FROM_EEPROM) ? 6 : 4;\r\nMSG_8723A("EEPROM type is %s\n", size == 4 ? "E-FUSE" : "93C46");\r\nreturn size;\r\n}\r\nstatic int _LLTWrite(struct rtw_adapter *padapter, u32 address, u32 data)\r\n{\r\nint status = _SUCCESS;\r\ns32 count = 0;\r\nu32 value = _LLT_INIT_ADDR(address) | _LLT_INIT_DATA(data) |\r\n_LLT_OP(_LLT_WRITE_ACCESS);\r\nu16 LLTReg = REG_LLT_INIT;\r\nrtl8723au_write32(padapter, LLTReg, value);\r\ndo {\r\nvalue = rtl8723au_read32(padapter, LLTReg);\r\nif (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value)) {\r\nbreak;\r\n}\r\nif (count > POLLING_LLT_THRESHOLD) {\r\nRT_TRACE(_module_hal_init_c_, _drv_err_,\r\n("Failed to polling write LLT done at "\r\n"address %d!\n", address));\r\nstatus = _FAIL;\r\nbreak;\r\n}\r\n} while (count++);\r\nreturn status;\r\n}\r\nint InitLLTTable23a(struct rtw_adapter *padapter, u32 boundary)\r\n{\r\nint status = _SUCCESS;\r\nu32 i;\r\nu32 txpktbuf_bndy = boundary;\r\nu32 Last_Entry_Of_TxPktBuf = LAST_ENTRY_OF_TX_PKT_BUFFER;\r\nfor (i = 0; i < (txpktbuf_bndy - 1); i++) {\r\nstatus = _LLTWrite(padapter, i, i + 1);\r\nif (status != _SUCCESS) {\r\nreturn status;\r\n}\r\n}\r\nstatus = _LLTWrite(padapter, (txpktbuf_bndy - 1), 0xFF);\r\nif (status != _SUCCESS) {\r\nreturn status;\r\n}\r\nfor (i = txpktbuf_bndy; i < Last_Entry_Of_TxPktBuf; i++) {\r\nstatus = _LLTWrite(padapter, i, (i + 1));\r\nif (_SUCCESS != status) {\r\nreturn status;\r\n}\r\n}\r\nstatus = _LLTWrite(padapter, Last_Entry_Of_TxPktBuf, txpktbuf_bndy);\r\nif (status != _SUCCESS) {\r\nreturn status;\r\n}\r\nreturn status;\r\n}\r\nstatic void _DisableGPIO(struct rtw_adapter *padapter)\r\n{\r\nu32 value32;\r\nu32 u4bTmp;\r\nrtl8723au_write16(padapter, REG_GPIO_PIN_CTRL + 2, 0x0000);\r\nvalue32 = rtl8723au_read32(padapter, REG_GPIO_PIN_CTRL) & 0xFFFF00FF;\r\nu4bTmp = value32 & 0x000000FF;\r\nvalue32 |= ((u4bTmp << 8) | 0x00FF0000);\r\nrtl8723au_write32(padapter, REG_GPIO_PIN_CTRL, value32);\r\nrtl8723au_write16(padapter, REG_GPIO_IO_SEL_2, 0x0000);\r\nvalue32 = rtl8723au_read32(padapter, REG_GPIO_PIN_CTRL_2) & 0xFFFF001F;\r\nu4bTmp = value32 & 0x0000001F;\r\nvalue32 |= ((u4bTmp << 8) | 0x001D0000);\r\nrtl8723au_write32(padapter, REG_GPIO_PIN_CTRL_2, value32);\r\nrtl8723au_write16(padapter, REG_LEDCFG0, 0x8080);\r\n}\r\nstatic void _DisableRFAFEAndResetBB8192C(struct rtw_adapter *padapter)\r\n{\r\nu8 value8;\r\nrtl8723au_write8(padapter, REG_TXPAUSE, 0xFF);\r\nPHY_SetRFReg(padapter, RF_PATH_A, 0x0, bMaskByte0, 0x0);\r\nvalue8 = APSDOFF;\r\nrtl8723au_write8(padapter, REG_APSD_CTRL, value8);\r\nvalue8 = FEN_USBD | FEN_USBA | FEN_BB_GLB_RSTn;\r\nrtl8723au_write8(padapter, REG_SYS_FUNC_EN, value8);\r\nvalue8 &= ~FEN_BB_GLB_RSTn;\r\nrtl8723au_write8(padapter, REG_SYS_FUNC_EN, value8);\r\n}\r\nstatic void _ResetDigitalProcedure1_92C(struct rtw_adapter *padapter,\r\nbool bWithoutHWSM)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (IS_FW_81xxC(padapter) && (pHalData->FirmwareVersion <= 0x20)) {\r\nu16 valu16;\r\nrtl8723au_write8(padapter, REG_MCUFWDL, 0);\r\nvalu16 = rtl8723au_read16(padapter, REG_SYS_FUNC_EN);\r\nrtl8723au_write16(padapter, REG_SYS_FUNC_EN,\r\nvalu16 & ~FEN_CPUEN);\r\nvalu16 = rtl8723au_read16(padapter, REG_SYS_FUNC_EN) & 0x0FFF;\r\nrtl8723au_write16(padapter, REG_SYS_FUNC_EN,\r\nvalu16 | FEN_HWPDN | FEN_ELDR);\r\nvalu16 = rtl8723au_read16(padapter, REG_SYS_FUNC_EN);\r\nrtl8723au_write16(padapter, REG_SYS_FUNC_EN,\r\nvalu16 | FEN_CPUEN);\r\n} else {\r\nu8 retry_cnts = 0;\r\nu8 val8;\r\nval8 = rtl8723au_read8(padapter, REG_MCUFWDL);\r\nif ((val8 & BIT(1)) && padapter->bFWReady) {\r\nrtl8723au_write8(padapter, REG_FWIMR, 0x20);\r\nrtl8723au_write8(padapter, REG_FTIMR, 0x00);\r\nrtl8723au_write8(padapter, REG_FSIMR, 0x00);\r\nrtl8723au_write8(padapter, REG_HMETFR + 3, 0x20);\r\nwhile ((retry_cnts++ < 100) &&\r\n(rtl8723au_read16(padapter, REG_SYS_FUNC_EN) &\r\nFEN_CPUEN)) {\r\nudelay(50);\r\n}\r\nif (retry_cnts >= 100) {\r\nrtl8723au_write8(padapter,\r\nREG_SYS_FUNC_EN + 1, 0x50);\r\nmdelay(10);\r\n}\r\n}\r\nrtl8723au_write8(padapter, REG_SYS_FUNC_EN + 1, 0x54);\r\nrtl8723au_write8(padapter, REG_MCUFWDL, 0);\r\n}\r\nif (bWithoutHWSM) {\r\nrtl8723au_write16(padapter, REG_SYS_CLKR, 0x70A3);\r\nrtl8723au_write8(padapter, REG_AFE_PLL_CTRL, 0x80);\r\nrtl8723au_write16(padapter, REG_AFE_XTAL_CTRL, 0x880F);\r\nrtl8723au_write8(padapter, REG_SYS_ISO_CTRL, 0xF9);\r\n} else {\r\nrtl8723au_write8(padapter, REG_RF_CTRL, 0x00);\r\n}\r\n}\r\nstatic void _ResetDigitalProcedure2(struct rtw_adapter *padapter)\r\n{\r\nrtl8723au_write16(padapter, REG_SYS_CLKR, 0x70a3);\r\nrtl8723au_write8(padapter, REG_SYS_ISO_CTRL + 1, 0x82);\r\n}\r\nstatic void _DisableAnalog(struct rtw_adapter *padapter, bool bWithoutHWSM)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu16 value16;\r\nu8 value8;\r\nif (bWithoutHWSM) {\r\nrtl8723au_write8(padapter, REG_LDOA15_CTRL, 0x04);\r\nvalue8 = rtl8723au_read8(padapter, REG_LDOV12D_CTRL);\r\nvalue8 &= ~LDV12_EN;\r\nrtl8723au_write8(padapter, REG_LDOV12D_CTRL, value8);\r\n}\r\nvalue8 = 0x23;\r\nif (IS_81xxC_VENDOR_UMC_B_CUT(pHalData->VersionID))\r\nvalue8 |= BIT(3);\r\nrtl8723au_write8(padapter, REG_SPS0_CTRL, value8);\r\nif (bWithoutHWSM) {\r\nvalue16 = APDM_HOST | AFSM_HSUS | PFM_ALDN;\r\n} else {\r\nvalue16 = APDM_HOST | AFSM_HSUS | PFM_ALDN;\r\n}\r\nrtl8723au_write16(padapter, REG_APS_FSMCO, value16);\r\nrtl8723au_write8(padapter, REG_RSV_CTRL, 0x0e);\r\n}\r\nint CardDisableHWSM(struct rtw_adapter *padapter, u8 resetMCU)\r\n{\r\nif (padapter->bSurpriseRemoved) {\r\nreturn _SUCCESS;\r\n}\r\n_DisableRFAFEAndResetBB8192C(padapter);\r\n_ResetDigitalProcedure1_92C(padapter, false);\r\n_DisableGPIO(padapter);\r\n_DisableAnalog(padapter, false);\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_,\r\n("======> Card disable finished.\n"));\r\nreturn _SUCCESS;\r\n}\r\nint CardDisableWithoutHWSM(struct rtw_adapter *padapter)\r\n{\r\nif (padapter->bSurpriseRemoved) {\r\nreturn _SUCCESS;\r\n}\r\n_DisableRFAFEAndResetBB8192C(padapter);\r\n_ResetDigitalProcedure1_92C(padapter, true);\r\n_DisableGPIO(padapter);\r\n_ResetDigitalProcedure2(padapter);\r\n_DisableAnalog(padapter, true);\r\nreturn _SUCCESS;\r\n}\r\nvoid Hal_InitPGData(struct rtw_adapter *padapter, u8 *PROMContent)\r\n{\r\nstruct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);\r\nif (!pEEPROM->bautoload_fail_flag) {\r\nif (!pEEPROM->EepromOrEfuse) {\r\nEFUSE_ShadowMapUpdate23a(padapter, EFUSE_WIFI);\r\nmemcpy(PROMContent, pEEPROM->efuse_eeprom_data,\r\nHWSET_MAX_SIZE);\r\n}\r\n} else {\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_notice_,\r\n("AutoLoad Fail reported from CR9346!!\n"));\r\nif (!pEEPROM->EepromOrEfuse)\r\nEFUSE_ShadowMapUpdate23a(padapter, EFUSE_WIFI);\r\nmemcpy(PROMContent, pEEPROM->efuse_eeprom_data,\r\nHWSET_MAX_SIZE);\r\n}\r\n}\r\nvoid Hal_EfuseParseIDCode(struct rtw_adapter *padapter, u8 *hwinfo)\r\n{\r\nstruct eeprom_priv *pEEPROM = GET_EEPROM_EFUSE_PRIV(padapter);\r\nu16 EEPROMId;\r\nEEPROMId = le16_to_cpu(*((u16 *) hwinfo));\r\nif (EEPROMId != RTL_EEPROM_ID) {\r\nDBG_8723A("EEPROM ID(%#x) is invalid!!\n", EEPROMId);\r\npEEPROM->bautoload_fail_flag = true;\r\n} else {\r\npEEPROM->bautoload_fail_flag = false;\r\n}\r\nRT_TRACE(_module_hal_init_c_, _drv_info_,\r\n("EEPROM ID = 0x%04x\n", EEPROMId));\r\n}\r\nstatic void Hal_EEValueCheck(u8 EEType, void *pInValue, void *pOutValue)\r\n{\r\nswitch (EEType) {\r\ncase EETYPE_TX_PWR:\r\n{\r\nu8 *pIn, *pOut;\r\npIn = (u8 *) pInValue;\r\npOut = (u8 *) pOutValue;\r\nif (*pIn <= 63)\r\n*pOut = *pIn;\r\nelse {\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_err_,\r\n("EETYPE_TX_PWR, value =%d is invalid, set "\r\n"to default = 0x%x\n",\r\n*pIn, EEPROM_Default_TxPowerLevel));\r\n*pOut = EEPROM_Default_TxPowerLevel;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nHal_ReadPowerValueFromPROM_8723A(struct txpowerinfo *pwrInfo,\r\nu8 *PROMContent, bool AutoLoadFail)\r\n{\r\nu32 rfPath, eeAddr, group, rfPathMax = 1;\r\nmemset(pwrInfo, 0, sizeof(*pwrInfo));\r\nif (AutoLoadFail) {\r\nfor (group = 0; group < MAX_CHNL_GROUP; group++) {\r\nfor (rfPath = 0; rfPath < rfPathMax; rfPath++) {\r\npwrInfo->CCKIndex[rfPath][group] =\r\nEEPROM_Default_TxPowerLevel;\r\npwrInfo->HT40_1SIndex[rfPath][group] =\r\nEEPROM_Default_TxPowerLevel;\r\npwrInfo->HT40_2SIndexDiff[rfPath][group] =\r\nEEPROM_Default_HT40_2SDiff;\r\npwrInfo->HT20IndexDiff[rfPath][group] =\r\nEEPROM_Default_HT20_Diff;\r\npwrInfo->OFDMIndexDiff[rfPath][group] =\r\nEEPROM_Default_LegacyHTTxPowerDiff;\r\npwrInfo->HT40MaxOffset[rfPath][group] =\r\nEEPROM_Default_HT40_PwrMaxOffset;\r\npwrInfo->HT20MaxOffset[rfPath][group] =\r\nEEPROM_Default_HT20_PwrMaxOffset;\r\n}\r\n}\r\npwrInfo->TSSI_A[0] = EEPROM_Default_TSSI;\r\nreturn;\r\n}\r\nfor (rfPath = 0; rfPath < rfPathMax; rfPath++) {\r\nfor (group = 0; group < MAX_CHNL_GROUP; group++) {\r\neeAddr =\r\nEEPROM_CCK_TX_PWR_INX_8723A + (rfPath * 3) + group;\r\nHal_EEValueCheck(EETYPE_TX_PWR, &PROMContent[eeAddr],\r\n&pwrInfo->CCKIndex[rfPath][group]);\r\neeAddr = EEPROM_HT40_1S_TX_PWR_INX_8723A +\r\n(rfPath * 3) + group;\r\nHal_EEValueCheck(EETYPE_TX_PWR, &PROMContent[eeAddr],\r\n&pwrInfo->HT40_1SIndex[rfPath][group]);\r\n}\r\n}\r\nfor (group = 0; group < MAX_CHNL_GROUP; group++) {\r\nfor (rfPath = 0; rfPath < rfPathMax; rfPath++) {\r\npwrInfo->HT40_2SIndexDiff[rfPath][group] = 0;\r\npwrInfo->HT20IndexDiff[rfPath][group] =\r\n(PROMContent\r\n[EEPROM_HT20_TX_PWR_INX_DIFF_8723A +\r\ngroup] >> (rfPath * 4)) & 0xF;\r\nif (pwrInfo->HT20IndexDiff[rfPath][group] & BIT(3))\r\npwrInfo->HT20IndexDiff[rfPath][group] |= 0xF0;\r\npwrInfo->OFDMIndexDiff[rfPath][group] =\r\n(PROMContent[EEPROM_OFDM_TX_PWR_INX_DIFF_8723A +\r\ngroup] >> (rfPath * 4)) & 0xF;\r\npwrInfo->HT40MaxOffset[rfPath][group] =\r\n(PROMContent[EEPROM_HT40_MAX_PWR_OFFSET_8723A +\r\ngroup] >> (rfPath * 4)) & 0xF;\r\npwrInfo->HT20MaxOffset[rfPath][group] =\r\n(PROMContent[EEPROM_HT20_MAX_PWR_OFFSET_8723A +\r\ngroup] >> (rfPath * 4)) & 0xF;\r\n}\r\n}\r\npwrInfo->TSSI_A[0] = PROMContent[EEPROM_TSSI_A_8723A];\r\n}\r\nstatic u8 Hal_GetChnlGroup(u8 chnl)\r\n{\r\nu8 group = 0;\r\nif (chnl < 3)\r\ngroup = 0;\r\nelse if (chnl < 9)\r\ngroup = 1;\r\nelse\r\ngroup = 2;\r\nreturn group;\r\n}\r\nvoid\r\nHal_EfuseParsetxpowerinfo_8723A(struct rtw_adapter *padapter,\r\nu8 *PROMContent, bool AutoLoadFail)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct txpowerinfo pwrInfo;\r\nu8 rfPath, ch, group, rfPathMax = 1;\r\nu8 pwr, diff;\r\nHal_ReadPowerValueFromPROM_8723A(&pwrInfo, PROMContent, AutoLoadFail);\r\nfor (rfPath = 0; rfPath < rfPathMax; rfPath++) {\r\nfor (ch = 0; ch < CHANNEL_MAX_NUMBER; ch++) {\r\ngroup = Hal_GetChnlGroup(ch);\r\npHalData->TxPwrLevelCck[rfPath][ch] =\r\npwrInfo.CCKIndex[rfPath][group];\r\npHalData->TxPwrLevelHT40_1S[rfPath][ch] =\r\npwrInfo.HT40_1SIndex[rfPath][group];\r\npHalData->TxPwrHt20Diff[rfPath][ch] =\r\npwrInfo.HT20IndexDiff[rfPath][group];\r\npHalData->TxPwrLegacyHtDiff[rfPath][ch] =\r\npwrInfo.OFDMIndexDiff[rfPath][group];\r\npHalData->PwrGroupHT20[rfPath][ch] =\r\npwrInfo.HT20MaxOffset[rfPath][group];\r\npHalData->PwrGroupHT40[rfPath][ch] =\r\npwrInfo.HT40MaxOffset[rfPath][group];\r\npwr = pwrInfo.HT40_1SIndex[rfPath][group];\r\ndiff = pwrInfo.HT40_2SIndexDiff[rfPath][group];\r\npHalData->TxPwrLevelHT40_2S[rfPath][ch] =\r\n(pwr > diff) ? (pwr - diff) : 0;\r\n}\r\n}\r\nfor (rfPath = 0; rfPath < RF_PATH_MAX; rfPath++) {\r\nfor (ch = 0; ch < CHANNEL_MAX_NUMBER; ch++) {\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_,\r\n("RF(%u)-Ch(%u) [CCK / HT40_1S / HT40_2S] = "\r\n"[0x%x / 0x%x / 0x%x]\n",\r\nrfPath, ch,\r\npHalData->TxPwrLevelCck[rfPath][ch],\r\npHalData->TxPwrLevelHT40_1S[rfPath][ch],\r\npHalData->TxPwrLevelHT40_2S[rfPath][ch]));\r\n}\r\n}\r\nfor (ch = 0; ch < CHANNEL_MAX_NUMBER; ch++) {\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_,\r\n("RF-A Ht20 to HT40 Diff[%u] = 0x%x(%d)\n", ch,\r\npHalData->TxPwrHt20Diff[RF_PATH_A][ch],\r\npHalData->TxPwrHt20Diff[RF_PATH_A][ch]));\r\n}\r\nfor (ch = 0; ch < CHANNEL_MAX_NUMBER; ch++)\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_,\r\n("RF-A Legacy to Ht40 Diff[%u] = 0x%x\n", ch,\r\npHalData->TxPwrLegacyHtDiff[RF_PATH_A][ch]));\r\nfor (ch = 0; ch < CHANNEL_MAX_NUMBER; ch++) {\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_,\r\n("RF-B Ht20 to HT40 Diff[%u] = 0x%x(%d)\n", ch,\r\npHalData->TxPwrHt20Diff[RF_PATH_B][ch],\r\npHalData->TxPwrHt20Diff[RF_PATH_B][ch]));\r\n}\r\nfor (ch = 0; ch < CHANNEL_MAX_NUMBER; ch++)\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_,\r\n("RF-B Legacy to HT40 Diff[%u] = 0x%x\n", ch,\r\npHalData->TxPwrLegacyHtDiff[RF_PATH_B][ch]));\r\nif (!AutoLoadFail) {\r\nstruct registry_priv *registry_par = &padapter->registrypriv;\r\nif (registry_par->regulatory_tid == 0xff) {\r\nif (PROMContent[RF_OPTION1_8723A] == 0xff)\r\npHalData->EEPROMRegulatory = 0;\r\nelse\r\npHalData->EEPROMRegulatory =\r\nPROMContent[RF_OPTION1_8723A] & 0x7;\r\n} else {\r\npHalData->EEPROMRegulatory =\r\nregistry_par->regulatory_tid;\r\n}\r\n} else {\r\npHalData->EEPROMRegulatory = 0;\r\n}\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_,\r\n("EEPROMRegulatory = 0x%x\n", pHalData->EEPROMRegulatory));\r\nif (!AutoLoadFail)\r\npHalData->bTXPowerDataReadFromEEPORM = true;\r\n}\r\nvoid\r\nHal_EfuseParseBTCoexistInfo_8723A(struct rtw_adapter *padapter,\r\nu8 *hwinfo, bool AutoLoadFail)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nu8 tempval;\r\nu32 tmpu4;\r\nif (!AutoLoadFail) {\r\ntmpu4 = rtl8723au_read32(padapter, REG_MULTI_FUNC_CTRL);\r\nif (tmpu4 & BT_FUNC_EN)\r\npHalData->EEPROMBluetoothCoexist = 1;\r\nelse\r\npHalData->EEPROMBluetoothCoexist = 0;\r\npHalData->EEPROMBluetoothType = BT_RTL8723A;\r\ntempval = hwinfo[RF_OPTION4_8723A];\r\npHalData->EEPROMBluetoothAntNum = (tempval & 0x1);\r\npHalData->EEPROMBluetoothAntIsolation = ((tempval & 0x10) >> 4);\r\npHalData->EEPROMBluetoothRadioShared = ((tempval & 0x20) >> 5);\r\n} else {\r\npHalData->EEPROMBluetoothCoexist = 0;\r\npHalData->EEPROMBluetoothType = BT_RTL8723A;\r\npHalData->EEPROMBluetoothAntNum = Ant_x2;\r\npHalData->EEPROMBluetoothAntIsolation = 0;\r\npHalData->EEPROMBluetoothRadioShared = BT_Radio_Shared;\r\n}\r\nrtl8723a_BT_init_hal_vars(padapter);\r\n}\r\nvoid\r\nHal_EfuseParseEEPROMVer(struct rtw_adapter *padapter,\r\nu8 *hwinfo, bool AutoLoadFail)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (!AutoLoadFail)\r\npHalData->EEPROMVersion = hwinfo[EEPROM_VERSION_8723A];\r\nelse\r\npHalData->EEPROMVersion = 1;\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_,\r\n("Hal_EfuseParseEEPROMVer(), EEVer = %d\n",\r\npHalData->EEPROMVersion));\r\n}\r\nvoid\r\nrtl8723a_EfuseParseChnlPlan(struct rtw_adapter *padapter,\r\nu8 *hwinfo, bool AutoLoadFail)\r\n{\r\npadapter->mlmepriv.ChannelPlan =\r\nhal_com_get_channel_plan23a(padapter, hwinfo ?\r\nhwinfo[EEPROM_ChannelPlan_8723A]:0xFF,\r\npadapter->registrypriv.channel_plan,\r\nRT_CHANNEL_DOMAIN_WORLD_WIDE_13,\r\nAutoLoadFail);\r\nDBG_8723A("mlmepriv.ChannelPlan = 0x%02x\n",\r\npadapter->mlmepriv.ChannelPlan);\r\n}\r\nvoid\r\nHal_EfuseParseCustomerID(struct rtw_adapter *padapter,\r\nu8 *hwinfo, bool AutoLoadFail)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (!AutoLoadFail) {\r\npHalData->EEPROMCustomerID = hwinfo[EEPROM_CustomID_8723A];\r\npHalData->EEPROMSubCustomerID =\r\nhwinfo[EEPROM_SubCustomID_8723A];\r\n} else {\r\npHalData->EEPROMCustomerID = 0;\r\npHalData->EEPROMSubCustomerID = 0;\r\n}\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_,\r\n("EEPROM Customer ID: 0x%2x\n", pHalData->EEPROMCustomerID));\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_,\r\n("EEPROM SubCustomer ID: 0x%02x\n",\r\npHalData->EEPROMSubCustomerID));\r\n}\r\nvoid\r\nHal_EfuseParseAntennaDiversity(struct rtw_adapter *padapter,\r\nu8 *hwinfo, bool AutoLoadFail)\r\n{\r\n}\r\nvoid\r\nHal_EfuseParseRateIndicationOption(struct rtw_adapter *padapter,\r\nu8 *hwinfo, bool AutoLoadFail)\r\n{\r\n}\r\nvoid\r\nHal_EfuseParseXtal_8723A(struct rtw_adapter *pAdapter,\r\nu8 *hwinfo, u8 AutoLoadFail)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(pAdapter);\r\nif (!AutoLoadFail) {\r\npHalData->CrystalCap = hwinfo[EEPROM_XTAL_K_8723A];\r\nif (pHalData->CrystalCap == 0xFF)\r\npHalData->CrystalCap = EEPROM_Default_CrystalCap_8723A;\r\n} else {\r\npHalData->CrystalCap = EEPROM_Default_CrystalCap_8723A;\r\n}\r\nRT_TRACE(_module_hci_hal_init_c_, _drv_info_,\r\n("%s: CrystalCap = 0x%2x\n", __func__,\r\npHalData->CrystalCap));\r\n}\r\nvoid\r\nHal_EfuseParseThermalMeter_8723A(struct rtw_adapter *padapter,\r\nu8 *PROMContent, bool AutoloadFail)\r\n{\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nif (!AutoloadFail)\r\npHalData->EEPROMThermalMeter =\r\nPROMContent[EEPROM_THERMAL_METER_8723A];\r\nelse\r\npHalData->EEPROMThermalMeter = EEPROM_Default_ThermalMeter;\r\nif ((pHalData->EEPROMThermalMeter == 0xff) || AutoloadFail) {\r\npHalData->bAPKThermalMeterIgnore = true;\r\npHalData->EEPROMThermalMeter = EEPROM_Default_ThermalMeter;\r\n}\r\nDBG_8723A("%s: ThermalMeter = 0x%x\n", __func__,\r\npHalData->EEPROMThermalMeter);\r\n}\r\nstatic void rtl8723a_cal_txdesc_chksum(struct tx_desc *ptxdesc)\r\n{\r\nu16 *usPtr = (u16 *) ptxdesc;\r\nu32 count = 16;\r\nu32 index;\r\nu16 checksum = 0;\r\nptxdesc->txdw7 &= cpu_to_le32(0xffff0000);\r\nfor (index = 0; index < count; index++) {\r\nchecksum ^= le16_to_cpu(*(usPtr + index));\r\n}\r\nptxdesc->txdw7 |= cpu_to_le32(checksum & 0x0000ffff);\r\n}\r\nvoid rtl8723a_fill_fake_txdesc(struct rtw_adapter *padapter, u8 *pDesc,\r\nu32 BufferLen, u8 IsPsPoll, u8 IsBTQosNull)\r\n{\r\nstruct tx_desc *ptxdesc;\r\nptxdesc = (struct tx_desc *)pDesc;\r\nmemset(pDesc, 0, TXDESC_SIZE);\r\nptxdesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);\r\nptxdesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE + OFFSET_SZ) <<\r\nOFFSET_SHT) & 0x00ff0000);\r\nptxdesc->txdw0 |= cpu_to_le32(BufferLen & 0x0000ffff);\r\nptxdesc->txdw1 |= cpu_to_le32((QSLT_MGNT << QSEL_SHT) & 0x00001f00);\r\nif (IsPsPoll) {\r\nptxdesc->txdw1 |= cpu_to_le32(NAVUSEHDR);\r\n} else {\r\nptxdesc->txdw4 |= cpu_to_le32(BIT(7));\r\nptxdesc->txdw3 |= cpu_to_le32((8 << 28));\r\n}\r\nif (true == IsBTQosNull) {\r\nptxdesc->txdw2 |= cpu_to_le32(BIT(23));\r\n}\r\nptxdesc->txdw4 |= cpu_to_le32(BIT(8));\r\nrtl8723a_cal_txdesc_chksum(ptxdesc);\r\n}\r\nvoid hw_var_set_opmode(struct rtw_adapter *padapter, u8 mode)\r\n{\r\nu8 val8;\r\nif (mode == MSR_INFRA || mode == MSR_NOLINK) {\r\nStopTxBeacon(padapter);\r\nval8 = DIS_TSF_UDT | EN_BCN_FUNCTION | DIS_ATIM;\r\nSetBcnCtrlReg23a(padapter, val8, ~val8);\r\n} else if (mode == MSR_ADHOC) {\r\nResumeTxBeacon(padapter);\r\nval8 = DIS_TSF_UDT | EN_BCN_FUNCTION | DIS_BCNQ_SUB;\r\nSetBcnCtrlReg23a(padapter, val8, ~val8);\r\n} else if (mode == MSR_AP) {\r\nrtl8723a_set_BTCoex_AP_mode_FwRsvdPkt_cmd(padapter);\r\nResumeTxBeacon(padapter);\r\nval8 = DIS_TSF_UDT | DIS_BCNQ_SUB;\r\nSetBcnCtrlReg23a(padapter, val8, ~val8);\r\nrtl8723au_write32(padapter, REG_RCR, 0x7000228e);\r\nrtl8723au_write16(padapter, REG_RXFLTMAP2, 0xFFFF);\r\nrtl8723au_write16(padapter, REG_RXFLTMAP1, 0x0400);\r\nrtl8723au_write8(padapter, REG_BCNDMATIM, 0x02);\r\nrtl8723au_write8(padapter, REG_DRVERLYINT, 0x05);\r\nrtl8723au_write8(padapter, REG_ATIMWND, 0x0a);\r\nrtl8723au_write16(padapter, REG_BCNTCFG, 0x00);\r\nrtl8723au_write16(padapter, REG_TBTT_PROHIBIT, 0xff04);\r\nrtl8723au_write16(padapter, REG_TSFTR_SYN_OFFSET, 0x7fff);\r\nrtl8723au_write8(padapter, REG_DUAL_TSF_RST, BIT(0));\r\nval8 = DIS_TSF_UDT | EN_BCN_FUNCTION |\r\nEN_TXBCN_RPT | DIS_BCNQ_SUB;\r\nSetBcnCtrlReg23a(padapter, val8, ~val8);\r\n}\r\nval8 = rtl8723au_read8(padapter, MSR);\r\nval8 = (val8 & 0xC) | mode;\r\nrtl8723au_write8(padapter, MSR, val8);\r\n}\r\nvoid hw_var_set_macaddr(struct rtw_adapter *padapter, u8 *val)\r\n{\r\nu8 idx = 0;\r\nu32 reg_macid;\r\nreg_macid = REG_MACID;\r\nfor (idx = 0; idx < 6; idx++)\r\nrtl8723au_write8(padapter, (reg_macid + idx), val[idx]);\r\n}\r\nvoid hw_var_set_bssid(struct rtw_adapter *padapter, u8 *val)\r\n{\r\nu8 idx = 0;\r\nu32 reg_bssid;\r\nreg_bssid = REG_BSSID;\r\nfor (idx = 0; idx < 6; idx++)\r\nrtl8723au_write8(padapter, (reg_bssid + idx), val[idx]);\r\n}\r\nvoid hw_var_set_correct_tsf(struct rtw_adapter *padapter)\r\n{\r\nu64 tsf;\r\nu32 reg_tsftr;\r\nstruct mlme_ext_priv *pmlmeext = &padapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &pmlmeext->mlmext_info;\r\ntsf = pmlmeext->TSFValue -\r\ndo_div(pmlmeext->TSFValue,\r\n(pmlmeinfo->bcn_interval * 1024)) - 1024;\r\nif (((pmlmeinfo->state & 0x03) == MSR_ADHOC) ||\r\n((pmlmeinfo->state & 0x03) == MSR_AP)) {\r\nStopTxBeacon(padapter);\r\n}\r\nreg_tsftr = REG_TSFTR;\r\nSetBcnCtrlReg23a(padapter, 0, EN_BCN_FUNCTION);\r\nrtl8723au_write32(padapter, reg_tsftr, tsf);\r\nrtl8723au_write32(padapter, reg_tsftr + 4, tsf >> 32);\r\nSetBcnCtrlReg23a(padapter, EN_BCN_FUNCTION, 0);\r\nif (((pmlmeinfo->state & 0x03) == MSR_ADHOC) ||\r\n((pmlmeinfo->state & 0x03) == MSR_AP))\r\nResumeTxBeacon(padapter);\r\n}\r\nvoid hw_var_set_mlme_disconnect(struct rtw_adapter *padapter)\r\n{\r\nrtl8723au_write16(padapter, REG_RXFLTMAP2, 0);\r\nrtl8723au_write8(padapter, REG_DUAL_TSF_RST, BIT(0));\r\nSetBcnCtrlReg23a(padapter, DIS_TSF_UDT, 0);\r\n}\r\nvoid hw_var_set_mlme_join(struct rtw_adapter *padapter, u8 type)\r\n{\r\nu8 RetryLimit = 0x30;\r\nstruct hal_data_8723a *pHalData = GET_HAL_DATA(padapter);\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nif (type == 0) {\r\nu32 v32;\r\nrtl8723au_write16(padapter, REG_RXFLTMAP2, 0xFFFF);\r\nv32 = rtl8723au_read32(padapter, REG_RCR);\r\nv32 |= RCR_CBSSID_DATA | RCR_CBSSID_BCN;\r\nrtl8723au_write32(padapter, REG_RCR, v32);\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == true)\r\nRetryLimit =\r\n(pHalData->CustomerID == RT_CID_CCX) ? 7 : 48;\r\nelse\r\nRetryLimit = 0x7;\r\n} else if (type == 1) {\r\nrtl8723au_write16(padapter, REG_RXFLTMAP2, 0);\r\n} else if (type == 2) {\r\nSetBcnCtrlReg23a(padapter, 0, DIS_TSF_UDT);\r\nif (check_fwstate(pmlmepriv,\r\nWIFI_ADHOC_STATE | WIFI_ADHOC_MASTER_STATE)) {\r\nrtl8723au_write8(padapter, 0x542, 0x02);\r\nRetryLimit = 0x7;\r\n}\r\n}\r\nrtl8723au_write16(padapter, REG_RL,\r\nRetryLimit << RETRY_LIMIT_SHORT_SHIFT | RetryLimit <<\r\nRETRY_LIMIT_LONG_SHIFT);\r\nswitch (type) {\r\ncase 0:\r\nrtl8723a_BT_wifiassociate_notify(padapter, true);\r\nbreak;\r\ncase 1:\r\nrtl8723a_BT_wifiassociate_notify(padapter, false);\r\nbreak;\r\ncase 2:\r\nbreak;\r\n}\r\n}
