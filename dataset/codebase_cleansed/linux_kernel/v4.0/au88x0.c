static void vortex_fix_latency(struct pci_dev *vortex)\r\n{\r\nint rc;\r\nif (!(rc = pci_write_config_byte(vortex, 0x40, 0xff))) {\r\ndev_info(&vortex->dev, "vortex latency is 0xff\n");\r\n} else {\r\ndev_warn(&vortex->dev,\r\n"could not set vortex latency: pci error 0x%x\n", rc);\r\n}\r\n}\r\nstatic void vortex_fix_agp_bridge(struct pci_dev *via)\r\n{\r\nint rc;\r\nu8 value;\r\nif (!(rc = pci_read_config_byte(via, 0x42, &value))\r\n&& ((value & 0x10)\r\n|| !(rc = pci_write_config_byte(via, 0x42, value | 0x10)))) {\r\ndev_info(&via->dev, "bridge config is 0x%x\n", value | 0x10);\r\n} else {\r\ndev_warn(&via->dev,\r\n"could not set vortex latency: pci error 0x%x\n", rc);\r\n}\r\n}\r\nstatic void snd_vortex_workaround(struct pci_dev *vortex, int fix)\r\n{\r\nstruct pci_dev *via = NULL;\r\nif (fix == 255) {\r\nvia = pci_get_device(PCI_VENDOR_ID_VIA,\r\nPCI_DEVICE_ID_VIA_8365_1, NULL);\r\nif (via == NULL) {\r\nvia = pci_get_device(PCI_VENDOR_ID_VIA,\r\nPCI_DEVICE_ID_VIA_82C598_1, NULL);\r\nif (via == NULL)\r\nvia = pci_get_device(PCI_VENDOR_ID_AMD,\r\nPCI_DEVICE_ID_AMD_FE_GATE_7007, NULL);\r\n}\r\nif (via) {\r\ndev_info(&vortex->dev,\r\n"Activating latency workaround...\n");\r\nvortex_fix_latency(vortex);\r\nvortex_fix_agp_bridge(via);\r\n}\r\n} else {\r\nif (fix & 0x1)\r\nvortex_fix_latency(vortex);\r\nif ((fix & 0x2) && (via = pci_get_device(PCI_VENDOR_ID_VIA,\r\nPCI_DEVICE_ID_VIA_8365_1, NULL)))\r\nvortex_fix_agp_bridge(via);\r\nif ((fix & 0x4) && (via = pci_get_device(PCI_VENDOR_ID_VIA,\r\nPCI_DEVICE_ID_VIA_82C598_1, NULL)))\r\nvortex_fix_agp_bridge(via);\r\nif ((fix & 0x8) && (via = pci_get_device(PCI_VENDOR_ID_AMD,\r\nPCI_DEVICE_ID_AMD_FE_GATE_7007, NULL)))\r\nvortex_fix_agp_bridge(via);\r\n}\r\npci_dev_put(via);\r\n}\r\nstatic int snd_vortex_dev_free(struct snd_device *device)\r\n{\r\nvortex_t *vortex = device->device_data;\r\nvortex_gameport_unregister(vortex);\r\nvortex_core_shutdown(vortex);\r\nfree_irq(vortex->irq, vortex);\r\niounmap(vortex->mmio);\r\npci_release_regions(vortex->pci_dev);\r\npci_disable_device(vortex->pci_dev);\r\nkfree(vortex);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_vortex_create(struct snd_card *card, struct pci_dev *pci, vortex_t ** rchip)\r\n{\r\nvortex_t *chip;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_vortex_dev_free,\r\n};\r\n*rchip = NULL;\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nif (pci_set_dma_mask(pci, DMA_BIT_MASK(32)) < 0 ||\r\npci_set_consistent_dma_mask(pci, DMA_BIT_MASK(32)) < 0) {\r\ndev_err(card->dev, "error to set DMA mask\n");\r\npci_disable_device(pci);\r\nreturn -ENXIO;\r\n}\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nchip->card = card;\r\nchip->pci_dev = pci;\r\nchip->io = pci_resource_start(pci, 0);\r\nchip->vendor = pci->vendor;\r\nchip->device = pci->device;\r\nchip->card = card;\r\nchip->irq = -1;\r\nif ((err = pci_request_regions(pci, CARD_NAME_SHORT)) != 0)\r\ngoto regions_out;\r\nchip->mmio = pci_ioremap_bar(pci, 0);\r\nif (!chip->mmio) {\r\ndev_err(card->dev, "MMIO area remap failed.\n");\r\nerr = -ENOMEM;\r\ngoto ioremap_out;\r\n}\r\nif ((err = vortex_core_init(chip)) != 0) {\r\ndev_err(card->dev, "hw core init failed\n");\r\ngoto core_out;\r\n}\r\nif ((err = request_irq(pci->irq, vortex_interrupt,\r\nIRQF_SHARED, KBUILD_MODNAME,\r\nchip)) != 0) {\r\ndev_err(card->dev, "cannot grab irq\n");\r\ngoto irq_out;\r\n}\r\nchip->irq = pci->irq;\r\npci_set_master(pci);\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\r\ngoto alloc_out;\r\n}\r\n*rchip = chip;\r\nreturn 0;\r\nalloc_out:\r\nfree_irq(chip->irq, chip);\r\nirq_out:\r\nvortex_core_shutdown(chip);\r\ncore_out:\r\niounmap(chip->mmio);\r\nioremap_out:\r\npci_release_regions(chip->pci_dev);\r\nregions_out:\r\npci_disable_device(chip->pci_dev);\r\nvortex_gameport_unregister(chip);\r\nkfree(chip);\r\nreturn err;\r\n}\r\nstatic int\r\nsnd_vortex_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nvortex_t *chip;\r\nint err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_new(&pci->dev, index[dev], id[dev], THIS_MODULE,\r\n0, &card);\r\nif (err < 0)\r\nreturn err;\r\nif ((err = snd_vortex_create(card, pci, &chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nsnd_vortex_workaround(pci, pcifix[dev]);\r\nstrcpy(card->driver, CARD_NAME_SHORT);\r\nsprintf(card->shortname, "Aureal Vortex %s", CARD_NAME_SHORT);\r\nsprintf(card->longname, "%s at 0x%lx irq %i",\r\ncard->shortname, chip->io, chip->irq);\r\nerr = snd_vortex_mixer(chip);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nerr = snd_vortex_new_pcm(chip, VORTEX_PCM_ADB, NR_PCM);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n#ifndef CHIP_AU8820\r\nif ((err = snd_vortex_new_pcm(chip, VORTEX_PCM_SPDIF, 1)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_vortex_new_pcm(chip, VORTEX_PCM_A3D, NR_A3D)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n#endif\r\n#ifndef CHIP_AU8810\r\nif ((err = snd_vortex_new_pcm(chip, VORTEX_PCM_WT, NR_WT)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n#endif\r\nif ((err = snd_vortex_midi(chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nvortex_gameport_register(chip);\r\n#if 0\r\nif (snd_seq_device_new(card, 1, SNDRV_SEQ_DEV_ID_VORTEX_SYNTH,\r\nsizeof(snd_vortex_synth_arg_t), &wave) < 0\r\n|| wave == NULL) {\r\ndev_err(card->dev, "Can't initialize Aureal wavetable synth\n");\r\n} else {\r\nsnd_vortex_synth_arg_t *arg;\r\narg = SNDRV_SEQ_DEVICE_ARGPTR(wave);\r\nstrcpy(wave->name, "Aureal Synth");\r\narg->hwptr = vortex;\r\narg->index = 1;\r\narg->seq_ports = seq_ports[dev];\r\narg->max_voices = max_synth_voices[dev];\r\n}\r\n#endif\r\nif ((err = pci_read_config_word(pci, PCI_DEVICE_ID,\r\n&(chip->device))) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = pci_read_config_word(pci, PCI_VENDOR_ID,\r\n&(chip->vendor))) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nchip->rev = pci->revision;\r\n#ifdef CHIP_AU8830\r\nif ((chip->rev) != 0xfe && (chip->rev) != 0xfa) {\r\ndev_alert(card->dev,\r\n"The revision (%x) of your card has not been seen before.\n",\r\nchip->rev);\r\ndev_alert(card->dev,\r\n"Please email the results of 'lspci -vv' to openvortex-dev@nongnu.org.\n");\r\nsnd_card_free(card);\r\nerr = -ENODEV;\r\nreturn err;\r\n}\r\n#endif\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nvortex_connect_default(chip, 1);\r\nvortex_enable_int(chip);\r\nreturn 0;\r\n}\r\nstatic void snd_vortex_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\n}
