int snd_hda_add_codec_preset(struct hda_codec_preset_list *preset)\r\n{\r\nmutex_lock(&preset_mutex);\r\nlist_add_tail(&preset->list, &hda_preset_tables);\r\nmutex_unlock(&preset_mutex);\r\nreturn 0;\r\n}\r\nint snd_hda_delete_codec_preset(struct hda_codec_preset_list *preset)\r\n{\r\nmutex_lock(&preset_mutex);\r\nlist_del(&preset->list);\r\nmutex_unlock(&preset_mutex);\r\nreturn 0;\r\n}\r\nstatic void hda_call_pm_notify(struct hda_codec *codec, bool power_up)\r\n{\r\nstruct hda_bus *bus = codec->bus;\r\nif ((power_up && codec->pm_up_notified) ||\r\n(!power_up && !codec->pm_up_notified))\r\nreturn;\r\nif (bus->ops.pm_notify)\r\nbus->ops.pm_notify(bus, power_up);\r\ncodec->pm_up_notified = power_up;\r\n}\r\nstatic inline void hda_keep_power_on(struct hda_codec *codec) {}\r\nconst char *snd_hda_get_jack_location(u32 cfg)\r\n{\r\nstatic char *bases[7] = {\r\n"N/A", "Rear", "Front", "Left", "Right", "Top", "Bottom",\r\n};\r\nstatic unsigned char specials_idx[] = {\r\n0x07, 0x08,\r\n0x17, 0x18, 0x19,\r\n0x37, 0x38\r\n};\r\nstatic char *specials[] = {\r\n"Rear Panel", "Drive Bar",\r\n"Riser", "HDMI", "ATAPI",\r\n"Mobile-In", "Mobile-Out"\r\n};\r\nint i;\r\ncfg = (cfg & AC_DEFCFG_LOCATION) >> AC_DEFCFG_LOCATION_SHIFT;\r\nif ((cfg & 0x0f) < 7)\r\nreturn bases[cfg & 0x0f];\r\nfor (i = 0; i < ARRAY_SIZE(specials_idx); i++) {\r\nif (cfg == specials_idx[i])\r\nreturn specials[i];\r\n}\r\nreturn "UNKNOWN";\r\n}\r\nconst char *snd_hda_get_jack_connectivity(u32 cfg)\r\n{\r\nstatic char *jack_locations[4] = { "Ext", "Int", "Sep", "Oth" };\r\nreturn jack_locations[(cfg >> (AC_DEFCFG_LOCATION_SHIFT + 4)) & 3];\r\n}\r\nconst char *snd_hda_get_jack_type(u32 cfg)\r\n{\r\nstatic char *jack_types[16] = {\r\n"Line Out", "Speaker", "HP Out", "CD",\r\n"SPDIF Out", "Digital Out", "Modem Line", "Modem Hand",\r\n"Line In", "Aux", "Mic", "Telephony",\r\n"SPDIF In", "Digital In", "Reserved", "Other"\r\n};\r\nreturn jack_types[(cfg & AC_DEFCFG_DEVICE)\r\n>> AC_DEFCFG_DEVICE_SHIFT];\r\n}\r\nstatic inline unsigned int\r\nmake_codec_cmd(struct hda_codec *codec, hda_nid_t nid, int flags,\r\nunsigned int verb, unsigned int parm)\r\n{\r\nu32 val;\r\nif ((codec->addr & ~0xf) || (nid & ~0x7f) ||\r\n(verb & ~0xfff) || (parm & ~0xffff)) {\r\ncodec_err(codec, "hda-codec: out of range cmd %x:%x:%x:%x\n",\r\ncodec->addr, nid, verb, parm);\r\nreturn ~0;\r\n}\r\nval = (u32)codec->addr << 28;\r\nval |= (u32)nid << 20;\r\nval |= verb << 8;\r\nval |= parm;\r\nreturn val;\r\n}\r\nstatic int codec_exec_verb(struct hda_codec *codec, unsigned int cmd,\r\nint flags, unsigned int *res)\r\n{\r\nstruct hda_bus *bus = codec->bus;\r\nint err;\r\nif (cmd == ~0)\r\nreturn -1;\r\nif (res)\r\n*res = -1;\r\nagain:\r\nsnd_hda_power_up(codec);\r\nmutex_lock(&bus->cmd_mutex);\r\nif (flags & HDA_RW_NO_RESPONSE_FALLBACK)\r\nbus->no_response_fallback = 1;\r\nfor (;;) {\r\ntrace_hda_send_cmd(codec, cmd);\r\nerr = bus->ops.command(bus, cmd);\r\nif (err != -EAGAIN)\r\nbreak;\r\nbus->ops.get_response(bus, codec->addr);\r\n}\r\nif (!err && res) {\r\n*res = bus->ops.get_response(bus, codec->addr);\r\ntrace_hda_get_response(codec, *res);\r\n}\r\nbus->no_response_fallback = 0;\r\nmutex_unlock(&bus->cmd_mutex);\r\nsnd_hda_power_down(codec);\r\nif (!codec_in_pm(codec) && res && *res == -1 && bus->rirb_error) {\r\nif (bus->response_reset) {\r\ncodec_dbg(codec,\r\n"resetting BUS due to fatal communication error\n");\r\ntrace_hda_bus_reset(bus);\r\nbus->ops.bus_reset(bus);\r\n}\r\ngoto again;\r\n}\r\nif (!err || codec_in_pm(codec))\r\nbus->response_reset = 0;\r\nreturn err;\r\n}\r\nunsigned int snd_hda_codec_read(struct hda_codec *codec, hda_nid_t nid,\r\nint flags,\r\nunsigned int verb, unsigned int parm)\r\n{\r\nunsigned cmd = make_codec_cmd(codec, nid, flags, verb, parm);\r\nunsigned int res;\r\nif (codec_exec_verb(codec, cmd, flags, &res))\r\nreturn -1;\r\nreturn res;\r\n}\r\nint snd_hda_codec_write(struct hda_codec *codec, hda_nid_t nid, int flags,\r\nunsigned int verb, unsigned int parm)\r\n{\r\nunsigned int cmd = make_codec_cmd(codec, nid, flags, verb, parm);\r\nunsigned int res;\r\nreturn codec_exec_verb(codec, cmd, flags,\r\ncodec->bus->sync_write ? &res : NULL);\r\n}\r\nvoid snd_hda_sequence_write(struct hda_codec *codec, const struct hda_verb *seq)\r\n{\r\nfor (; seq->nid; seq++)\r\nsnd_hda_codec_write(codec, seq->nid, 0, seq->verb, seq->param);\r\n}\r\nint snd_hda_get_sub_nodes(struct hda_codec *codec, hda_nid_t nid,\r\nhda_nid_t *start_id)\r\n{\r\nunsigned int parm;\r\nparm = snd_hda_param_read(codec, nid, AC_PAR_NODE_COUNT);\r\nif (parm == -1) {\r\n*start_id = 0;\r\nreturn 0;\r\n}\r\n*start_id = (parm >> 16) & 0x7fff;\r\nreturn (int)(parm & 0x7fff);\r\n}\r\nstatic struct hda_conn_list *\r\nlookup_conn_list(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct hda_conn_list *p;\r\nlist_for_each_entry(p, &codec->conn_list, list) {\r\nif (p->nid == nid)\r\nreturn p;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int add_conn_list(struct hda_codec *codec, hda_nid_t nid, int len,\r\nconst hda_nid_t *list)\r\n{\r\nstruct hda_conn_list *p;\r\np = kmalloc(sizeof(*p) + len * sizeof(hda_nid_t), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\np->len = len;\r\np->nid = nid;\r\nmemcpy(p->conns, list, len * sizeof(hda_nid_t));\r\nlist_add(&p->list, &codec->conn_list);\r\nreturn 0;\r\n}\r\nstatic void remove_conn_list(struct hda_codec *codec)\r\n{\r\nwhile (!list_empty(&codec->conn_list)) {\r\nstruct hda_conn_list *p;\r\np = list_first_entry(&codec->conn_list, typeof(*p), list);\r\nlist_del(&p->list);\r\nkfree(p);\r\n}\r\n}\r\nstatic int read_and_add_raw_conns(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nhda_nid_t list[32];\r\nhda_nid_t *result = list;\r\nint len;\r\nlen = snd_hda_get_raw_connections(codec, nid, list, ARRAY_SIZE(list));\r\nif (len == -ENOSPC) {\r\nlen = snd_hda_get_num_raw_conns(codec, nid);\r\nresult = kmalloc(sizeof(hda_nid_t) * len, GFP_KERNEL);\r\nif (!result)\r\nreturn -ENOMEM;\r\nlen = snd_hda_get_raw_connections(codec, nid, result, len);\r\n}\r\nif (len >= 0)\r\nlen = snd_hda_override_conn_list(codec, nid, len, result);\r\nif (result != list)\r\nkfree(result);\r\nreturn len;\r\n}\r\nint snd_hda_get_conn_list(struct hda_codec *codec, hda_nid_t nid,\r\nconst hda_nid_t **listp)\r\n{\r\nbool added = false;\r\nfor (;;) {\r\nint err;\r\nconst struct hda_conn_list *p;\r\np = lookup_conn_list(codec, nid);\r\nif (p) {\r\nif (listp)\r\n*listp = p->conns;\r\nreturn p->len;\r\n}\r\nif (snd_BUG_ON(added))\r\nreturn -EINVAL;\r\nerr = read_and_add_raw_conns(codec, nid);\r\nif (err < 0)\r\nreturn err;\r\nadded = true;\r\n}\r\n}\r\nint snd_hda_get_connections(struct hda_codec *codec, hda_nid_t nid,\r\nhda_nid_t *conn_list, int max_conns)\r\n{\r\nconst hda_nid_t *list;\r\nint len = snd_hda_get_conn_list(codec, nid, &list);\r\nif (len > 0 && conn_list) {\r\nif (len > max_conns) {\r\ncodec_err(codec, "Too many connections %d for NID 0x%x\n",\r\nlen, nid);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(conn_list, list, len * sizeof(hda_nid_t));\r\n}\r\nreturn len;\r\n}\r\nstatic unsigned int get_num_conns(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nunsigned int wcaps = get_wcaps(codec, nid);\r\nunsigned int parm;\r\nif (!(wcaps & AC_WCAP_CONN_LIST) &&\r\nget_wcaps_type(wcaps) != AC_WID_VOL_KNB)\r\nreturn 0;\r\nparm = snd_hda_param_read(codec, nid, AC_PAR_CONNLIST_LEN);\r\nif (parm == -1)\r\nparm = 0;\r\nreturn parm;\r\n}\r\nint snd_hda_get_num_raw_conns(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nreturn snd_hda_get_raw_connections(codec, nid, NULL, 0);\r\n}\r\nint snd_hda_get_raw_connections(struct hda_codec *codec, hda_nid_t nid,\r\nhda_nid_t *conn_list, int max_conns)\r\n{\r\nunsigned int parm;\r\nint i, conn_len, conns;\r\nunsigned int shift, num_elems, mask;\r\nhda_nid_t prev_nid;\r\nint null_count = 0;\r\nparm = get_num_conns(codec, nid);\r\nif (!parm)\r\nreturn 0;\r\nif (parm & AC_CLIST_LONG) {\r\nshift = 16;\r\nnum_elems = 2;\r\n} else {\r\nshift = 8;\r\nnum_elems = 4;\r\n}\r\nconn_len = parm & AC_CLIST_LENGTH;\r\nmask = (1 << (shift-1)) - 1;\r\nif (!conn_len)\r\nreturn 0;\r\nif (conn_len == 1) {\r\nparm = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_CONNECT_LIST, 0);\r\nif (parm == -1 && codec->bus->rirb_error)\r\nreturn -EIO;\r\nif (conn_list)\r\nconn_list[0] = parm & mask;\r\nreturn 1;\r\n}\r\nconns = 0;\r\nprev_nid = 0;\r\nfor (i = 0; i < conn_len; i++) {\r\nint range_val;\r\nhda_nid_t val, n;\r\nif (i % num_elems == 0) {\r\nparm = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_CONNECT_LIST, i);\r\nif (parm == -1 && codec->bus->rirb_error)\r\nreturn -EIO;\r\n}\r\nrange_val = !!(parm & (1 << (shift-1)));\r\nval = parm & mask;\r\nif (val == 0 && null_count++) {\r\ncodec_dbg(codec,\r\n"invalid CONNECT_LIST verb %x[%i]:%x\n",\r\nnid, i, parm);\r\nreturn 0;\r\n}\r\nparm >>= shift;\r\nif (range_val) {\r\nif (!prev_nid || prev_nid >= val) {\r\ncodec_warn(codec,\r\n"invalid dep_range_val %x:%x\n",\r\nprev_nid, val);\r\ncontinue;\r\n}\r\nfor (n = prev_nid + 1; n <= val; n++) {\r\nif (conn_list) {\r\nif (conns >= max_conns)\r\nreturn -ENOSPC;\r\nconn_list[conns] = n;\r\n}\r\nconns++;\r\n}\r\n} else {\r\nif (conn_list) {\r\nif (conns >= max_conns)\r\nreturn -ENOSPC;\r\nconn_list[conns] = val;\r\n}\r\nconns++;\r\n}\r\nprev_nid = val;\r\n}\r\nreturn conns;\r\n}\r\nint snd_hda_override_conn_list(struct hda_codec *codec, hda_nid_t nid, int len,\r\nconst hda_nid_t *list)\r\n{\r\nstruct hda_conn_list *p;\r\np = lookup_conn_list(codec, nid);\r\nif (p) {\r\nlist_del(&p->list);\r\nkfree(p);\r\n}\r\nreturn add_conn_list(codec, nid, len, list);\r\n}\r\nint snd_hda_get_conn_index(struct hda_codec *codec, hda_nid_t mux,\r\nhda_nid_t nid, int recursive)\r\n{\r\nconst hda_nid_t *conn;\r\nint i, nums;\r\nnums = snd_hda_get_conn_list(codec, mux, &conn);\r\nfor (i = 0; i < nums; i++)\r\nif (conn[i] == nid)\r\nreturn i;\r\nif (!recursive)\r\nreturn -1;\r\nif (recursive > 10) {\r\ncodec_dbg(codec, "too deep connection for 0x%x\n", nid);\r\nreturn -1;\r\n}\r\nrecursive++;\r\nfor (i = 0; i < nums; i++) {\r\nunsigned int type = get_wcaps_type(get_wcaps(codec, conn[i]));\r\nif (type == AC_WID_PIN || type == AC_WID_AUD_OUT)\r\ncontinue;\r\nif (snd_hda_get_conn_index(codec, conn[i], nid, recursive) >= 0)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic unsigned int get_num_devices(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nunsigned int wcaps = get_wcaps(codec, nid);\r\nunsigned int parm;\r\nif (!codec->dp_mst || !(wcaps & AC_WCAP_DIGITAL) ||\r\nget_wcaps_type(wcaps) != AC_WID_PIN)\r\nreturn 0;\r\nparm = snd_hda_param_read(codec, nid, AC_PAR_DEVLIST_LEN);\r\nif (parm == -1 && codec->bus->rirb_error)\r\nparm = 0;\r\nreturn parm & AC_DEV_LIST_LEN_MASK;\r\n}\r\nint snd_hda_get_devices(struct hda_codec *codec, hda_nid_t nid,\r\nu8 *dev_list, int max_devices)\r\n{\r\nunsigned int parm;\r\nint i, dev_len, devices;\r\nparm = get_num_devices(codec, nid);\r\nif (!parm)\r\nreturn 0;\r\ndev_len = parm + 1;\r\ndev_len = dev_len < max_devices ? dev_len : max_devices;\r\ndevices = 0;\r\nwhile (devices < dev_len) {\r\nparm = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_DEVICE_LIST, devices);\r\nif (parm == -1 && codec->bus->rirb_error)\r\nbreak;\r\nfor (i = 0; i < 8; i++) {\r\ndev_list[devices] = (u8)parm;\r\nparm >>= 4;\r\ndevices++;\r\nif (devices >= dev_len)\r\nbreak;\r\n}\r\n}\r\nreturn devices;\r\n}\r\nint snd_hda_queue_unsol_event(struct hda_bus *bus, u32 res, u32 res_ex)\r\n{\r\nstruct hda_bus_unsolicited *unsol;\r\nunsigned int wp;\r\nif (!bus || !bus->workq)\r\nreturn 0;\r\ntrace_hda_unsol_event(bus, res, res_ex);\r\nunsol = bus->unsol;\r\nif (!unsol)\r\nreturn 0;\r\nwp = (unsol->wp + 1) % HDA_UNSOL_QUEUE_SIZE;\r\nunsol->wp = wp;\r\nwp <<= 1;\r\nunsol->queue[wp] = res;\r\nunsol->queue[wp + 1] = res_ex;\r\nqueue_work(bus->workq, &unsol->work);\r\nreturn 0;\r\n}\r\nstatic void process_unsol_events(struct work_struct *work)\r\n{\r\nstruct hda_bus_unsolicited *unsol =\r\ncontainer_of(work, struct hda_bus_unsolicited, work);\r\nstruct hda_bus *bus = unsol->bus;\r\nstruct hda_codec *codec;\r\nunsigned int rp, caddr, res;\r\nwhile (unsol->rp != unsol->wp) {\r\nrp = (unsol->rp + 1) % HDA_UNSOL_QUEUE_SIZE;\r\nunsol->rp = rp;\r\nrp <<= 1;\r\nres = unsol->queue[rp];\r\ncaddr = unsol->queue[rp + 1];\r\nif (!(caddr & (1 << 4)))\r\ncontinue;\r\ncodec = bus->caddr_tbl[caddr & 0x0f];\r\nif (codec && codec->patch_ops.unsol_event)\r\ncodec->patch_ops.unsol_event(codec, res);\r\n}\r\n}\r\nstatic int init_unsol_queue(struct hda_bus *bus)\r\n{\r\nstruct hda_bus_unsolicited *unsol;\r\nif (bus->unsol)\r\nreturn 0;\r\nunsol = kzalloc(sizeof(*unsol), GFP_KERNEL);\r\nif (!unsol) {\r\ndev_err(bus->card->dev, "can't allocate unsolicited queue\n");\r\nreturn -ENOMEM;\r\n}\r\nINIT_WORK(&unsol->work, process_unsol_events);\r\nunsol->bus = bus;\r\nbus->unsol = unsol;\r\nreturn 0;\r\n}\r\nstatic void snd_hda_bus_free(struct hda_bus *bus)\r\n{\r\nif (!bus)\r\nreturn;\r\nWARN_ON(!list_empty(&bus->codec_list));\r\nif (bus->workq)\r\nflush_workqueue(bus->workq);\r\nkfree(bus->unsol);\r\nif (bus->ops.private_free)\r\nbus->ops.private_free(bus);\r\nif (bus->workq)\r\ndestroy_workqueue(bus->workq);\r\nkfree(bus);\r\n}\r\nstatic int snd_hda_bus_dev_free(struct snd_device *device)\r\n{\r\nsnd_hda_bus_free(device->device_data);\r\nreturn 0;\r\n}\r\nstatic int snd_hda_bus_dev_disconnect(struct snd_device *device)\r\n{\r\nstruct hda_bus *bus = device->device_data;\r\nbus->shutdown = 1;\r\nreturn 0;\r\n}\r\nint snd_hda_bus_new(struct snd_card *card,\r\nconst struct hda_bus_template *temp,\r\nstruct hda_bus **busp)\r\n{\r\nstruct hda_bus *bus;\r\nint err;\r\nstatic struct snd_device_ops dev_ops = {\r\n.dev_disconnect = snd_hda_bus_dev_disconnect,\r\n.dev_free = snd_hda_bus_dev_free,\r\n};\r\nif (snd_BUG_ON(!temp))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(!temp->ops.command || !temp->ops.get_response))\r\nreturn -EINVAL;\r\nif (busp)\r\n*busp = NULL;\r\nbus = kzalloc(sizeof(*bus), GFP_KERNEL);\r\nif (bus == NULL) {\r\ndev_err(card->dev, "can't allocate struct hda_bus\n");\r\nreturn -ENOMEM;\r\n}\r\nbus->card = card;\r\nbus->private_data = temp->private_data;\r\nbus->pci = temp->pci;\r\nbus->modelname = temp->modelname;\r\nbus->power_save = temp->power_save;\r\nbus->ops = temp->ops;\r\nmutex_init(&bus->cmd_mutex);\r\nmutex_init(&bus->prepare_mutex);\r\nINIT_LIST_HEAD(&bus->codec_list);\r\nsnprintf(bus->workq_name, sizeof(bus->workq_name),\r\n"hd-audio%d", card->number);\r\nbus->workq = create_singlethread_workqueue(bus->workq_name);\r\nif (!bus->workq) {\r\ndev_err(card->dev, "cannot create workqueue %s\n",\r\nbus->workq_name);\r\nkfree(bus);\r\nreturn -ENOMEM;\r\n}\r\nerr = snd_device_new(card, SNDRV_DEV_BUS, bus, &dev_ops);\r\nif (err < 0) {\r\nsnd_hda_bus_free(bus);\r\nreturn err;\r\n}\r\nif (busp)\r\n*busp = bus;\r\nreturn 0;\r\n}\r\nstatic const struct hda_codec_preset *\r\nfind_codec_preset(struct hda_codec *codec)\r\n{\r\nstruct hda_codec_preset_list *tbl;\r\nconst struct hda_codec_preset *preset;\r\nunsigned int mod_requested = 0;\r\nagain:\r\nmutex_lock(&preset_mutex);\r\nlist_for_each_entry(tbl, &hda_preset_tables, list) {\r\nif (!try_module_get(tbl->owner)) {\r\ncodec_err(codec, "cannot module_get\n");\r\ncontinue;\r\n}\r\nfor (preset = tbl->preset; preset->id; preset++) {\r\nu32 mask = preset->mask;\r\nif (preset->afg && preset->afg != codec->afg)\r\ncontinue;\r\nif (preset->mfg && preset->mfg != codec->mfg)\r\ncontinue;\r\nif (!mask)\r\nmask = ~0;\r\nif (preset->id == (codec->vendor_id & mask) &&\r\n(!preset->rev ||\r\npreset->rev == codec->revision_id)) {\r\nmutex_unlock(&preset_mutex);\r\ncodec->owner = tbl->owner;\r\nreturn preset;\r\n}\r\n}\r\nmodule_put(tbl->owner);\r\n}\r\nmutex_unlock(&preset_mutex);\r\nif (mod_requested < HDA_MODREQ_MAX_COUNT) {\r\nif (!mod_requested)\r\nrequest_module("snd-hda-codec-id:%08x",\r\ncodec->vendor_id);\r\nelse\r\nrequest_module("snd-hda-codec-id:%04x*",\r\n(codec->vendor_id >> 16) & 0xffff);\r\nmod_requested++;\r\ngoto again;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int get_codec_name(struct hda_codec *codec)\r\n{\r\nconst struct hda_vendor_id *c;\r\nconst char *vendor = NULL;\r\nu16 vendor_id = codec->vendor_id >> 16;\r\nchar tmp[16];\r\nif (codec->vendor_name)\r\ngoto get_chip_name;\r\nfor (c = hda_vendor_ids; c->id; c++) {\r\nif (c->id == vendor_id) {\r\nvendor = c->name;\r\nbreak;\r\n}\r\n}\r\nif (!vendor) {\r\nsprintf(tmp, "Generic %04x", vendor_id);\r\nvendor = tmp;\r\n}\r\ncodec->vendor_name = kstrdup(vendor, GFP_KERNEL);\r\nif (!codec->vendor_name)\r\nreturn -ENOMEM;\r\nget_chip_name:\r\nif (codec->chip_name)\r\nreturn 0;\r\nif (codec->preset && codec->preset->name)\r\ncodec->chip_name = kstrdup(codec->preset->name, GFP_KERNEL);\r\nelse {\r\nsprintf(tmp, "ID %x", codec->vendor_id & 0xffff);\r\ncodec->chip_name = kstrdup(tmp, GFP_KERNEL);\r\n}\r\nif (!codec->chip_name)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void setup_fg_nodes(struct hda_codec *codec)\r\n{\r\nint i, total_nodes, function_id;\r\nhda_nid_t nid;\r\ntotal_nodes = snd_hda_get_sub_nodes(codec, AC_NODE_ROOT, &nid);\r\nfor (i = 0; i < total_nodes; i++, nid++) {\r\nfunction_id = snd_hda_param_read(codec, nid,\r\nAC_PAR_FUNCTION_TYPE);\r\nswitch (function_id & 0xff) {\r\ncase AC_GRP_AUDIO_FUNCTION:\r\ncodec->afg = nid;\r\ncodec->afg_function_id = function_id & 0xff;\r\ncodec->afg_unsol = (function_id >> 8) & 1;\r\nbreak;\r\ncase AC_GRP_MODEM_FUNCTION:\r\ncodec->mfg = nid;\r\ncodec->mfg_function_id = function_id & 0xff;\r\ncodec->mfg_unsol = (function_id >> 8) & 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int read_widget_caps(struct hda_codec *codec, hda_nid_t fg_node)\r\n{\r\nint i;\r\nhda_nid_t nid;\r\ncodec->num_nodes = snd_hda_get_sub_nodes(codec, fg_node,\r\n&codec->start_nid);\r\ncodec->wcaps = kmalloc(codec->num_nodes * 4, GFP_KERNEL);\r\nif (!codec->wcaps)\r\nreturn -ENOMEM;\r\nnid = codec->start_nid;\r\nfor (i = 0; i < codec->num_nodes; i++, nid++)\r\ncodec->wcaps[i] = snd_hda_param_read(codec, nid,\r\nAC_PAR_AUDIO_WIDGET_CAP);\r\nreturn 0;\r\n}\r\nstatic int read_pin_defaults(struct hda_codec *codec)\r\n{\r\nint i;\r\nhda_nid_t nid = codec->start_nid;\r\nfor (i = 0; i < codec->num_nodes; i++, nid++) {\r\nstruct hda_pincfg *pin;\r\nunsigned int wcaps = get_wcaps(codec, nid);\r\nunsigned int wid_type = get_wcaps_type(wcaps);\r\nif (wid_type != AC_WID_PIN)\r\ncontinue;\r\npin = snd_array_new(&codec->init_pins);\r\nif (!pin)\r\nreturn -ENOMEM;\r\npin->nid = nid;\r\npin->cfg = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_CONFIG_DEFAULT, 0);\r\npin->ctrl = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_PIN_WIDGET_CONTROL,\r\n0);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct hda_pincfg *look_up_pincfg(struct hda_codec *codec,\r\nstruct snd_array *array,\r\nhda_nid_t nid)\r\n{\r\nint i;\r\nfor (i = 0; i < array->used; i++) {\r\nstruct hda_pincfg *pin = snd_array_elem(array, i);\r\nif (pin->nid == nid)\r\nreturn pin;\r\n}\r\nreturn NULL;\r\n}\r\nint snd_hda_add_pincfg(struct hda_codec *codec, struct snd_array *list,\r\nhda_nid_t nid, unsigned int cfg)\r\n{\r\nstruct hda_pincfg *pin;\r\npin = look_up_pincfg(codec, list, nid);\r\nif (!pin) {\r\npin = snd_array_new(list);\r\nif (!pin)\r\nreturn -ENOMEM;\r\npin->nid = nid;\r\n}\r\npin->cfg = cfg;\r\nreturn 0;\r\n}\r\nint snd_hda_codec_set_pincfg(struct hda_codec *codec,\r\nhda_nid_t nid, unsigned int cfg)\r\n{\r\nreturn snd_hda_add_pincfg(codec, &codec->driver_pins, nid, cfg);\r\n}\r\nunsigned int snd_hda_codec_get_pincfg(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct hda_pincfg *pin;\r\n#ifdef CONFIG_SND_HDA_RECONFIG\r\n{\r\nunsigned int cfg = 0;\r\nmutex_lock(&codec->user_mutex);\r\npin = look_up_pincfg(codec, &codec->user_pins, nid);\r\nif (pin)\r\ncfg = pin->cfg;\r\nmutex_unlock(&codec->user_mutex);\r\nif (cfg)\r\nreturn cfg;\r\n}\r\n#endif\r\npin = look_up_pincfg(codec, &codec->driver_pins, nid);\r\nif (pin)\r\nreturn pin->cfg;\r\npin = look_up_pincfg(codec, &codec->init_pins, nid);\r\nif (pin)\r\nreturn pin->cfg;\r\nreturn 0;\r\n}\r\nint snd_hda_codec_set_pin_target(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned int val)\r\n{\r\nstruct hda_pincfg *pin;\r\npin = look_up_pincfg(codec, &codec->init_pins, nid);\r\nif (!pin)\r\nreturn -EINVAL;\r\npin->target = val;\r\nreturn 0;\r\n}\r\nint snd_hda_codec_get_pin_target(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct hda_pincfg *pin;\r\npin = look_up_pincfg(codec, &codec->init_pins, nid);\r\nif (!pin)\r\nreturn 0;\r\nreturn pin->target;\r\n}\r\nvoid snd_hda_shutup_pins(struct hda_codec *codec)\r\n{\r\nint i;\r\nif (codec->bus->shutdown)\r\nreturn;\r\nfor (i = 0; i < codec->init_pins.used; i++) {\r\nstruct hda_pincfg *pin = snd_array_elem(&codec->init_pins, i);\r\nsnd_hda_codec_read(codec, pin->nid, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL, 0);\r\n}\r\ncodec->pins_shutup = 1;\r\n}\r\nstatic void restore_shutup_pins(struct hda_codec *codec)\r\n{\r\nint i;\r\nif (!codec->pins_shutup)\r\nreturn;\r\nif (codec->bus->shutdown)\r\nreturn;\r\nfor (i = 0; i < codec->init_pins.used; i++) {\r\nstruct hda_pincfg *pin = snd_array_elem(&codec->init_pins, i);\r\nsnd_hda_codec_write(codec, pin->nid, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL,\r\npin->ctrl);\r\n}\r\ncodec->pins_shutup = 0;\r\n}\r\nstatic void hda_jackpoll_work(struct work_struct *work)\r\n{\r\nstruct hda_codec *codec =\r\ncontainer_of(work, struct hda_codec, jackpoll_work.work);\r\nsnd_hda_jack_set_dirty_all(codec);\r\nsnd_hda_jack_poll_all(codec);\r\nif (!codec->jackpoll_interval)\r\nreturn;\r\nqueue_delayed_work(codec->bus->workq, &codec->jackpoll_work,\r\ncodec->jackpoll_interval);\r\n}\r\nstatic void free_init_pincfgs(struct hda_codec *codec)\r\n{\r\nsnd_array_free(&codec->driver_pins);\r\n#ifdef CONFIG_SND_HDA_RECONFIG\r\nsnd_array_free(&codec->user_pins);\r\n#endif\r\nsnd_array_free(&codec->init_pins);\r\n}\r\nstatic struct hda_cvt_setup *\r\nget_hda_cvt_setup(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct hda_cvt_setup *p;\r\nint i;\r\nfor (i = 0; i < codec->cvt_setups.used; i++) {\r\np = snd_array_elem(&codec->cvt_setups, i);\r\nif (p->nid == nid)\r\nreturn p;\r\n}\r\np = snd_array_new(&codec->cvt_setups);\r\nif (p)\r\np->nid = nid;\r\nreturn p;\r\n}\r\nstatic void unload_parser(struct hda_codec *codec)\r\n{\r\nif (codec->parser)\r\nsymbol_put_addr(codec->parser);\r\ncodec->parser = NULL;\r\n}\r\nstatic void snd_hda_codec_free(struct hda_codec *codec)\r\n{\r\nif (!codec)\r\nreturn;\r\ncancel_delayed_work_sync(&codec->jackpoll_work);\r\nsnd_hda_jack_tbl_clear(codec);\r\nfree_init_pincfgs(codec);\r\n#ifdef CONFIG_PM\r\ncancel_delayed_work(&codec->power_work);\r\nflush_workqueue(codec->bus->workq);\r\n#endif\r\nlist_del(&codec->list);\r\nsnd_array_free(&codec->mixers);\r\nsnd_array_free(&codec->nids);\r\nsnd_array_free(&codec->cvt_setups);\r\nsnd_array_free(&codec->spdif_out);\r\nremove_conn_list(codec);\r\ncodec->bus->caddr_tbl[codec->addr] = NULL;\r\nif (codec->patch_ops.free)\r\ncodec->patch_ops.free(codec);\r\nhda_call_pm_notify(codec, false);\r\nsnd_hda_sysfs_clear(codec);\r\nunload_parser(codec);\r\nmodule_put(codec->owner);\r\nfree_hda_cache(&codec->amp_cache);\r\nfree_hda_cache(&codec->cmd_cache);\r\nkfree(codec->vendor_name);\r\nkfree(codec->chip_name);\r\nkfree(codec->modelname);\r\nkfree(codec->wcaps);\r\ncodec->bus->num_codecs--;\r\nput_device(&codec->dev);\r\n}\r\nstatic int snd_hda_codec_dev_register(struct snd_device *device)\r\n{\r\nstruct hda_codec *codec = device->device_data;\r\nint err = device_add(&codec->dev);\r\nif (err < 0)\r\nreturn err;\r\nsnd_hda_register_beep_device(codec);\r\nreturn 0;\r\n}\r\nstatic int snd_hda_codec_dev_disconnect(struct snd_device *device)\r\n{\r\nstruct hda_codec *codec = device->device_data;\r\nsnd_hda_detach_beep_device(codec);\r\ndevice_del(&codec->dev);\r\nreturn 0;\r\n}\r\nstatic int snd_hda_codec_dev_free(struct snd_device *device)\r\n{\r\nsnd_hda_codec_free(device->device_data);\r\nreturn 0;\r\n}\r\nstatic void snd_hda_codec_dev_release(struct device *dev)\r\n{\r\nkfree(container_of(dev, struct hda_codec, dev));\r\n}\r\nint snd_hda_codec_new(struct hda_bus *bus,\r\nunsigned int codec_addr,\r\nstruct hda_codec **codecp)\r\n{\r\nstruct hda_codec *codec;\r\nchar component[31];\r\nhda_nid_t fg;\r\nint err;\r\nstatic struct snd_device_ops dev_ops = {\r\n.dev_register = snd_hda_codec_dev_register,\r\n.dev_disconnect = snd_hda_codec_dev_disconnect,\r\n.dev_free = snd_hda_codec_dev_free,\r\n};\r\nif (snd_BUG_ON(!bus))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(codec_addr > HDA_MAX_CODEC_ADDRESS))\r\nreturn -EINVAL;\r\nif (bus->caddr_tbl[codec_addr]) {\r\ndev_err(bus->card->dev,\r\n"address 0x%x is already occupied\n",\r\ncodec_addr);\r\nreturn -EBUSY;\r\n}\r\ncodec = kzalloc(sizeof(*codec), GFP_KERNEL);\r\nif (codec == NULL) {\r\ndev_err(bus->card->dev, "can't allocate struct hda_codec\n");\r\nreturn -ENOMEM;\r\n}\r\ndevice_initialize(&codec->dev);\r\ncodec->dev.parent = &bus->card->card_dev;\r\ncodec->dev.class = sound_class;\r\ncodec->dev.release = snd_hda_codec_dev_release;\r\ncodec->dev.groups = snd_hda_dev_attr_groups;\r\ndev_set_name(&codec->dev, "hdaudioC%dD%d", bus->card->number,\r\ncodec_addr);\r\ndev_set_drvdata(&codec->dev, codec);\r\ncodec->bus = bus;\r\ncodec->addr = codec_addr;\r\nmutex_init(&codec->spdif_mutex);\r\nmutex_init(&codec->control_mutex);\r\nmutex_init(&codec->hash_mutex);\r\ninit_hda_cache(&codec->amp_cache, sizeof(struct hda_amp_info));\r\ninit_hda_cache(&codec->cmd_cache, sizeof(struct hda_cache_head));\r\nsnd_array_init(&codec->mixers, sizeof(struct hda_nid_item), 32);\r\nsnd_array_init(&codec->nids, sizeof(struct hda_nid_item), 32);\r\nsnd_array_init(&codec->init_pins, sizeof(struct hda_pincfg), 16);\r\nsnd_array_init(&codec->driver_pins, sizeof(struct hda_pincfg), 16);\r\nsnd_array_init(&codec->cvt_setups, sizeof(struct hda_cvt_setup), 8);\r\nsnd_array_init(&codec->spdif_out, sizeof(struct hda_spdif_out), 16);\r\nsnd_array_init(&codec->jacktbl, sizeof(struct hda_jack_tbl), 16);\r\nsnd_array_init(&codec->verbs, sizeof(struct hda_verb *), 8);\r\nINIT_LIST_HEAD(&codec->conn_list);\r\nINIT_DELAYED_WORK(&codec->jackpoll_work, hda_jackpoll_work);\r\ncodec->depop_delay = -1;\r\ncodec->fixup_id = HDA_FIXUP_ID_NOT_SET;\r\n#ifdef CONFIG_PM\r\nspin_lock_init(&codec->power_lock);\r\nINIT_DELAYED_WORK(&codec->power_work, hda_power_work);\r\nhda_keep_power_on(codec);\r\n#endif\r\nsnd_hda_sysfs_init(codec);\r\nif (codec->bus->modelname) {\r\ncodec->modelname = kstrdup(codec->bus->modelname, GFP_KERNEL);\r\nif (!codec->modelname) {\r\nerr = -ENODEV;\r\ngoto error;\r\n}\r\n}\r\nlist_add_tail(&codec->list, &bus->codec_list);\r\nbus->num_codecs++;\r\nbus->caddr_tbl[codec_addr] = codec;\r\ncodec->vendor_id = snd_hda_param_read(codec, AC_NODE_ROOT,\r\nAC_PAR_VENDOR_ID);\r\nif (codec->vendor_id == -1)\r\ncodec->vendor_id = snd_hda_param_read(codec, AC_NODE_ROOT,\r\nAC_PAR_VENDOR_ID);\r\ncodec->subsystem_id = snd_hda_param_read(codec, AC_NODE_ROOT,\r\nAC_PAR_SUBSYSTEM_ID);\r\ncodec->revision_id = snd_hda_param_read(codec, AC_NODE_ROOT,\r\nAC_PAR_REV_ID);\r\nsetup_fg_nodes(codec);\r\nif (!codec->afg && !codec->mfg) {\r\ndev_err(bus->card->dev, "no AFG or MFG node found\n");\r\nerr = -ENODEV;\r\ngoto error;\r\n}\r\nfg = codec->afg ? codec->afg : codec->mfg;\r\nerr = read_widget_caps(codec, fg);\r\nif (err < 0) {\r\ndev_err(bus->card->dev, "cannot malloc\n");\r\ngoto error;\r\n}\r\nerr = read_pin_defaults(codec);\r\nif (err < 0)\r\ngoto error;\r\nif (!codec->subsystem_id) {\r\ncodec->subsystem_id =\r\nsnd_hda_codec_read(codec, fg, 0,\r\nAC_VERB_GET_SUBSYSTEM_ID, 0);\r\n}\r\n#ifdef CONFIG_PM\r\ncodec->d3_stop_clk = snd_hda_codec_get_supported_ps(codec, fg,\r\nAC_PWRST_CLKSTOP);\r\n#endif\r\ncodec->epss = snd_hda_codec_get_supported_ps(codec, fg,\r\nAC_PWRST_EPSS);\r\n#ifdef CONFIG_PM\r\nif (!codec->d3_stop_clk || !codec->epss)\r\nbus->power_keep_link_on = 1;\r\n#endif\r\nhda_set_power_state(codec, AC_PWRST_D0);\r\nsnd_hda_codec_proc_new(codec);\r\nsnd_hda_create_hwdep(codec);\r\nsprintf(component, "HDA:%08x,%08x,%08x", codec->vendor_id,\r\ncodec->subsystem_id, codec->revision_id);\r\nsnd_component_add(codec->bus->card, component);\r\nerr = snd_device_new(bus->card, SNDRV_DEV_CODEC, codec, &dev_ops);\r\nif (err < 0)\r\ngoto error;\r\nif (codecp)\r\n*codecp = codec;\r\nreturn 0;\r\nerror:\r\nsnd_hda_codec_free(codec);\r\nreturn err;\r\n}\r\nint snd_hda_codec_update_widgets(struct hda_codec *codec)\r\n{\r\nhda_nid_t fg;\r\nint err;\r\nkfree(codec->wcaps);\r\nfg = codec->afg ? codec->afg : codec->mfg;\r\nerr = read_widget_caps(codec, fg);\r\nif (err < 0) {\r\ncodec_err(codec, "cannot malloc\n");\r\nreturn err;\r\n}\r\nsnd_array_free(&codec->init_pins);\r\nerr = read_pin_defaults(codec);\r\nreturn err;\r\n}\r\nstatic bool is_likely_hdmi_codec(struct hda_codec *codec)\r\n{\r\nhda_nid_t nid = codec->start_nid;\r\nint i;\r\nfor (i = 0; i < codec->num_nodes; i++, nid++) {\r\nunsigned int wcaps = get_wcaps(codec, nid);\r\nswitch (get_wcaps_type(wcaps)) {\r\ncase AC_WID_AUD_IN:\r\nreturn false;\r\ncase AC_WID_AUD_OUT:\r\nif (!(wcaps & AC_WCAP_DIGITAL))\r\nreturn false;\r\nbreak;\r\n}\r\n}\r\nreturn true;\r\n}\r\nint snd_hda_codec_configure(struct hda_codec *codec)\r\n{\r\nint (*patch)(struct hda_codec *) = NULL;\r\nint err;\r\ncodec->preset = find_codec_preset(codec);\r\nif (!codec->vendor_name || !codec->chip_name) {\r\nerr = get_codec_name(codec);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (!is_generic_config(codec) && codec->preset)\r\npatch = codec->preset->patch;\r\nif (!patch) {\r\nunload_parser(codec);\r\nif (is_likely_hdmi_codec(codec)) {\r\n#if IS_MODULE(CONFIG_SND_HDA_CODEC_HDMI)\r\npatch = load_parser(codec, snd_hda_parse_hdmi_codec);\r\n#elif IS_BUILTIN(CONFIG_SND_HDA_CODEC_HDMI)\r\npatch = snd_hda_parse_hdmi_codec;\r\n#endif\r\n}\r\nif (!patch) {\r\n#if IS_MODULE(CONFIG_SND_HDA_GENERIC)\r\npatch = load_parser(codec, snd_hda_parse_generic_codec);\r\n#elif IS_BUILTIN(CONFIG_SND_HDA_GENERIC)\r\npatch = snd_hda_parse_generic_codec;\r\n#endif\r\n}\r\nif (!patch) {\r\ncodec_err(codec, "No codec parser is available\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nerr = patch(codec);\r\nif (err < 0) {\r\nunload_parser(codec);\r\nreturn err;\r\n}\r\nif (codec->patch_ops.unsol_event) {\r\nerr = init_unsol_queue(codec->bus);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (codec->afg || !*codec->bus->card->mixername)\r\nsnprintf(codec->bus->card->mixername,\r\nsizeof(codec->bus->card->mixername),\r\n"%s %s", codec->vendor_name, codec->chip_name);\r\nreturn 0;\r\n}\r\nstatic void update_pcm_stream_id(struct hda_codec *codec,\r\nstruct hda_cvt_setup *p, hda_nid_t nid,\r\nu32 stream_tag, int channel_id)\r\n{\r\nunsigned int oldval, newval;\r\nif (p->stream_tag != stream_tag || p->channel_id != channel_id) {\r\noldval = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_CONV, 0);\r\nnewval = (stream_tag << 4) | channel_id;\r\nif (oldval != newval)\r\nsnd_hda_codec_write(codec, nid, 0,\r\nAC_VERB_SET_CHANNEL_STREAMID,\r\nnewval);\r\np->stream_tag = stream_tag;\r\np->channel_id = channel_id;\r\n}\r\n}\r\nstatic void update_pcm_format(struct hda_codec *codec, struct hda_cvt_setup *p,\r\nhda_nid_t nid, int format)\r\n{\r\nunsigned int oldval;\r\nif (p->format_id != format) {\r\noldval = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_STREAM_FORMAT, 0);\r\nif (oldval != format) {\r\nmsleep(1);\r\nsnd_hda_codec_write(codec, nid, 0,\r\nAC_VERB_SET_STREAM_FORMAT,\r\nformat);\r\n}\r\np->format_id = format;\r\n}\r\n}\r\nvoid snd_hda_codec_setup_stream(struct hda_codec *codec, hda_nid_t nid,\r\nu32 stream_tag,\r\nint channel_id, int format)\r\n{\r\nstruct hda_codec *c;\r\nstruct hda_cvt_setup *p;\r\nint type;\r\nint i;\r\nif (!nid)\r\nreturn;\r\ncodec_dbg(codec,\r\n"hda_codec_setup_stream: NID=0x%x, stream=0x%x, channel=%d, format=0x%x\n",\r\nnid, stream_tag, channel_id, format);\r\np = get_hda_cvt_setup(codec, nid);\r\nif (!p)\r\nreturn;\r\nif (codec->pcm_format_first)\r\nupdate_pcm_format(codec, p, nid, format);\r\nupdate_pcm_stream_id(codec, p, nid, stream_tag, channel_id);\r\nif (!codec->pcm_format_first)\r\nupdate_pcm_format(codec, p, nid, format);\r\np->active = 1;\r\np->dirty = 0;\r\ntype = get_wcaps_type(get_wcaps(codec, nid));\r\nlist_for_each_entry(c, &codec->bus->codec_list, list) {\r\nfor (i = 0; i < c->cvt_setups.used; i++) {\r\np = snd_array_elem(&c->cvt_setups, i);\r\nif (!p->active && p->stream_tag == stream_tag &&\r\nget_wcaps_type(get_wcaps(c, p->nid)) == type)\r\np->dirty = 1;\r\n}\r\n}\r\n}\r\nvoid __snd_hda_codec_cleanup_stream(struct hda_codec *codec, hda_nid_t nid,\r\nint do_now)\r\n{\r\nstruct hda_cvt_setup *p;\r\nif (!nid)\r\nreturn;\r\nif (codec->no_sticky_stream)\r\ndo_now = 1;\r\ncodec_dbg(codec, "hda_codec_cleanup_stream: NID=0x%x\n", nid);\r\np = get_hda_cvt_setup(codec, nid);\r\nif (p) {\r\nif (do_now)\r\nreally_cleanup_stream(codec, p);\r\nelse\r\np->active = 0;\r\n}\r\n}\r\nstatic void really_cleanup_stream(struct hda_codec *codec,\r\nstruct hda_cvt_setup *q)\r\n{\r\nhda_nid_t nid = q->nid;\r\nif (q->stream_tag || q->channel_id)\r\nsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_CHANNEL_STREAMID, 0);\r\nif (q->format_id)\r\nsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_STREAM_FORMAT, 0\r\n);\r\nmemset(q, 0, sizeof(*q));\r\nq->nid = nid;\r\n}\r\nstatic void purify_inactive_streams(struct hda_codec *codec)\r\n{\r\nstruct hda_codec *c;\r\nint i;\r\nlist_for_each_entry(c, &codec->bus->codec_list, list) {\r\nfor (i = 0; i < c->cvt_setups.used; i++) {\r\nstruct hda_cvt_setup *p;\r\np = snd_array_elem(&c->cvt_setups, i);\r\nif (p->dirty)\r\nreally_cleanup_stream(c, p);\r\n}\r\n}\r\n}\r\nstatic void hda_cleanup_all_streams(struct hda_codec *codec)\r\n{\r\nint i;\r\nfor (i = 0; i < codec->cvt_setups.used; i++) {\r\nstruct hda_cvt_setup *p = snd_array_elem(&codec->cvt_setups, i);\r\nif (p->stream_tag)\r\nreally_cleanup_stream(codec, p);\r\n}\r\n}\r\nstatic void init_hda_cache(struct hda_cache_rec *cache,\r\nunsigned int record_size)\r\n{\r\nmemset(cache, 0, sizeof(*cache));\r\nmemset(cache->hash, 0xff, sizeof(cache->hash));\r\nsnd_array_init(&cache->buf, record_size, 64);\r\n}\r\nstatic void free_hda_cache(struct hda_cache_rec *cache)\r\n{\r\nsnd_array_free(&cache->buf);\r\n}\r\nstatic struct hda_cache_head *get_hash(struct hda_cache_rec *cache, u32 key)\r\n{\r\nu16 idx = key % (u16)ARRAY_SIZE(cache->hash);\r\nu16 cur = cache->hash[idx];\r\nstruct hda_cache_head *info;\r\nwhile (cur != 0xffff) {\r\ninfo = snd_array_elem(&cache->buf, cur);\r\nif (info->key == key)\r\nreturn info;\r\ncur = info->next;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct hda_cache_head *get_alloc_hash(struct hda_cache_rec *cache,\r\nu32 key)\r\n{\r\nstruct hda_cache_head *info = get_hash(cache, key);\r\nif (!info) {\r\nu16 idx, cur;\r\ninfo = snd_array_new(&cache->buf);\r\nif (!info)\r\nreturn NULL;\r\ncur = snd_array_index(&cache->buf, info);\r\ninfo->key = key;\r\ninfo->val = 0;\r\ninfo->dirty = 0;\r\nidx = key % (u16)ARRAY_SIZE(cache->hash);\r\ninfo->next = cache->hash[idx];\r\ncache->hash[idx] = cur;\r\n}\r\nreturn info;\r\n}\r\nstatic inline struct hda_amp_info *\r\nget_alloc_amp_hash(struct hda_codec *codec, u32 key)\r\n{\r\nreturn (struct hda_amp_info *)get_alloc_hash(&codec->amp_cache, key);\r\n}\r\nstatic int write_caps_hash(struct hda_codec *codec, u32 key, unsigned int val)\r\n{\r\nstruct hda_amp_info *info;\r\nmutex_lock(&codec->hash_mutex);\r\ninfo = get_alloc_amp_hash(codec, key);\r\nif (!info) {\r\nmutex_unlock(&codec->hash_mutex);\r\nreturn -EINVAL;\r\n}\r\ninfo->amp_caps = val;\r\ninfo->head.val |= INFO_AMP_CAPS;\r\nmutex_unlock(&codec->hash_mutex);\r\nreturn 0;\r\n}\r\nstatic unsigned int read_amp_cap(struct hda_codec *codec, hda_nid_t nid,\r\nint direction)\r\n{\r\nif (!(get_wcaps(codec, nid) & AC_WCAP_AMP_OVRD))\r\nnid = codec->afg;\r\nreturn snd_hda_param_read(codec, nid,\r\ndirection == HDA_OUTPUT ?\r\nAC_PAR_AMP_OUT_CAP : AC_PAR_AMP_IN_CAP);\r\n}\r\nu32 query_amp_caps(struct hda_codec *codec, hda_nid_t nid, int direction)\r\n{\r\nreturn query_caps_hash(codec, nid, direction,\r\nHDA_HASH_KEY(nid, direction, 0),\r\nread_amp_cap);\r\n}\r\nbool snd_hda_check_amp_caps(struct hda_codec *codec, hda_nid_t nid,\r\nint dir, unsigned int bits)\r\n{\r\nif (!nid)\r\nreturn false;\r\nif (get_wcaps(codec, nid) & (1 << (dir + 1)))\r\nif (query_amp_caps(codec, nid, dir) & bits)\r\nreturn true;\r\nreturn false;\r\n}\r\nint snd_hda_override_amp_caps(struct hda_codec *codec, hda_nid_t nid, int dir,\r\nunsigned int caps)\r\n{\r\nreturn write_caps_hash(codec, HDA_HASH_KEY(nid, dir, 0), caps);\r\n}\r\nstatic unsigned int read_pin_cap(struct hda_codec *codec, hda_nid_t nid,\r\nint dir)\r\n{\r\nreturn snd_hda_param_read(codec, nid, AC_PAR_PIN_CAP);\r\n}\r\nu32 snd_hda_query_pin_caps(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nreturn query_caps_hash(codec, nid, 0, HDA_HASH_PINCAP_KEY(nid),\r\nread_pin_cap);\r\n}\r\nint snd_hda_override_pin_caps(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned int caps)\r\n{\r\nreturn write_caps_hash(codec, HDA_HASH_PINCAP_KEY(nid), caps);\r\n}\r\nstatic struct hda_amp_info *\r\nupdate_amp_hash(struct hda_codec *codec, hda_nid_t nid, int ch,\r\nint direction, int index, bool init_only)\r\n{\r\nstruct hda_amp_info *info;\r\nunsigned int parm, val = 0;\r\nbool val_read = false;\r\nretry:\r\ninfo = get_alloc_amp_hash(codec, HDA_HASH_KEY(nid, direction, index));\r\nif (!info)\r\nreturn NULL;\r\nif (!(info->head.val & INFO_AMP_VOL(ch))) {\r\nif (!val_read) {\r\nmutex_unlock(&codec->hash_mutex);\r\nparm = ch ? AC_AMP_GET_RIGHT : AC_AMP_GET_LEFT;\r\nparm |= direction == HDA_OUTPUT ?\r\nAC_AMP_GET_OUTPUT : AC_AMP_GET_INPUT;\r\nparm |= index;\r\nval = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_AMP_GAIN_MUTE, parm);\r\nval &= 0xff;\r\nval_read = true;\r\nmutex_lock(&codec->hash_mutex);\r\ngoto retry;\r\n}\r\ninfo->vol[ch] = val;\r\ninfo->head.val |= INFO_AMP_VOL(ch);\r\n} else if (init_only)\r\nreturn NULL;\r\nreturn info;\r\n}\r\nstatic void put_vol_mute(struct hda_codec *codec, unsigned int amp_caps,\r\nhda_nid_t nid, int ch, int direction, int index,\r\nint val)\r\n{\r\nu32 parm;\r\nparm = ch ? AC_AMP_SET_RIGHT : AC_AMP_SET_LEFT;\r\nparm |= direction == HDA_OUTPUT ? AC_AMP_SET_OUTPUT : AC_AMP_SET_INPUT;\r\nparm |= index << AC_AMP_SET_INDEX_SHIFT;\r\nif ((val & HDA_AMP_MUTE) && !(amp_caps & AC_AMPCAP_MUTE) &&\r\n(amp_caps & AC_AMPCAP_MIN_MUTE))\r\n;\r\nelse\r\nparm |= val;\r\nsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_AMP_GAIN_MUTE, parm);\r\n}\r\nint snd_hda_codec_amp_read(struct hda_codec *codec, hda_nid_t nid, int ch,\r\nint direction, int index)\r\n{\r\nstruct hda_amp_info *info;\r\nunsigned int val = 0;\r\nmutex_lock(&codec->hash_mutex);\r\ninfo = update_amp_hash(codec, nid, ch, direction, index, false);\r\nif (info)\r\nval = info->vol[ch];\r\nmutex_unlock(&codec->hash_mutex);\r\nreturn val;\r\n}\r\nstatic int codec_amp_update(struct hda_codec *codec, hda_nid_t nid, int ch,\r\nint direction, int idx, int mask, int val,\r\nbool init_only)\r\n{\r\nstruct hda_amp_info *info;\r\nunsigned int caps;\r\nunsigned int cache_only;\r\nif (snd_BUG_ON(mask & ~0xff))\r\nmask &= 0xff;\r\nval &= mask;\r\nmutex_lock(&codec->hash_mutex);\r\ninfo = update_amp_hash(codec, nid, ch, direction, idx, init_only);\r\nif (!info) {\r\nmutex_unlock(&codec->hash_mutex);\r\nreturn 0;\r\n}\r\nval |= info->vol[ch] & ~mask;\r\nif (info->vol[ch] == val) {\r\nmutex_unlock(&codec->hash_mutex);\r\nreturn 0;\r\n}\r\ninfo->vol[ch] = val;\r\ncache_only = info->head.dirty = codec->cached_write;\r\ncaps = info->amp_caps;\r\nmutex_unlock(&codec->hash_mutex);\r\nif (!cache_only)\r\nput_vol_mute(codec, caps, nid, ch, direction, idx, val);\r\nreturn 1;\r\n}\r\nint snd_hda_codec_amp_update(struct hda_codec *codec, hda_nid_t nid, int ch,\r\nint direction, int idx, int mask, int val)\r\n{\r\nreturn codec_amp_update(codec, nid, ch, direction, idx, mask, val, false);\r\n}\r\nint snd_hda_codec_amp_stereo(struct hda_codec *codec, hda_nid_t nid,\r\nint direction, int idx, int mask, int val)\r\n{\r\nint ch, ret = 0;\r\nif (snd_BUG_ON(mask & ~0xff))\r\nmask &= 0xff;\r\nfor (ch = 0; ch < 2; ch++)\r\nret |= snd_hda_codec_amp_update(codec, nid, ch, direction,\r\nidx, mask, val);\r\nreturn ret;\r\n}\r\nint snd_hda_codec_amp_init(struct hda_codec *codec, hda_nid_t nid, int ch,\r\nint dir, int idx, int mask, int val)\r\n{\r\nreturn codec_amp_update(codec, nid, ch, dir, idx, mask, val, true);\r\n}\r\nint snd_hda_codec_amp_init_stereo(struct hda_codec *codec, hda_nid_t nid,\r\nint dir, int idx, int mask, int val)\r\n{\r\nint ch, ret = 0;\r\nif (snd_BUG_ON(mask & ~0xff))\r\nmask &= 0xff;\r\nfor (ch = 0; ch < 2; ch++)\r\nret |= snd_hda_codec_amp_init(codec, nid, ch, dir,\r\nidx, mask, val);\r\nreturn ret;\r\n}\r\nvoid snd_hda_codec_resume_amp(struct hda_codec *codec)\r\n{\r\nint i;\r\nmutex_lock(&codec->hash_mutex);\r\ncodec->cached_write = 0;\r\nfor (i = 0; i < codec->amp_cache.buf.used; i++) {\r\nstruct hda_amp_info *buffer;\r\nu32 key;\r\nhda_nid_t nid;\r\nunsigned int idx, dir, ch;\r\nstruct hda_amp_info info;\r\nbuffer = snd_array_elem(&codec->amp_cache.buf, i);\r\nif (!buffer->head.dirty)\r\ncontinue;\r\nbuffer->head.dirty = 0;\r\ninfo = *buffer;\r\nkey = info.head.key;\r\nif (!key)\r\ncontinue;\r\nnid = key & 0xff;\r\nidx = (key >> 16) & 0xff;\r\ndir = (key >> 24) & 0xff;\r\nfor (ch = 0; ch < 2; ch++) {\r\nif (!(info.head.val & INFO_AMP_VOL(ch)))\r\ncontinue;\r\nmutex_unlock(&codec->hash_mutex);\r\nput_vol_mute(codec, info.amp_caps, nid, ch, dir, idx,\r\ninfo.vol[ch]);\r\nmutex_lock(&codec->hash_mutex);\r\n}\r\n}\r\nmutex_unlock(&codec->hash_mutex);\r\n}\r\nstatic u32 get_amp_max_value(struct hda_codec *codec, hda_nid_t nid, int dir,\r\nunsigned int ofs)\r\n{\r\nu32 caps = query_amp_caps(codec, nid, dir);\r\ncaps = (caps & AC_AMPCAP_NUM_STEPS) >> AC_AMPCAP_NUM_STEPS_SHIFT;\r\nif (ofs < caps)\r\ncaps -= ofs;\r\nreturn caps;\r\n}\r\nint snd_hda_mixer_amp_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nu16 nid = get_amp_nid(kcontrol);\r\nu8 chs = get_amp_channels(kcontrol);\r\nint dir = get_amp_direction(kcontrol);\r\nunsigned int ofs = get_amp_offset(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = chs == 3 ? 2 : 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = get_amp_max_value(codec, nid, dir, ofs);\r\nif (!uinfo->value.integer.max) {\r\ncodec_warn(codec,\r\n"num_steps = 0 for NID=0x%x (ctl = %s)\n",\r\nnid, kcontrol->id.name);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline unsigned int\r\nread_amp_value(struct hda_codec *codec, hda_nid_t nid,\r\nint ch, int dir, int idx, unsigned int ofs)\r\n{\r\nunsigned int val;\r\nval = snd_hda_codec_amp_read(codec, nid, ch, dir, idx);\r\nval &= HDA_AMP_VOLMASK;\r\nif (val >= ofs)\r\nval -= ofs;\r\nelse\r\nval = 0;\r\nreturn val;\r\n}\r\nstatic inline int\r\nupdate_amp_value(struct hda_codec *codec, hda_nid_t nid,\r\nint ch, int dir, int idx, unsigned int ofs,\r\nunsigned int val)\r\n{\r\nunsigned int maxval;\r\nif (val > 0)\r\nval += ofs;\r\nmaxval = get_amp_max_value(codec, nid, dir, 0);\r\nif (val > maxval)\r\nval = maxval;\r\nreturn snd_hda_codec_amp_update(codec, nid, ch, dir, idx,\r\nHDA_AMP_VOLMASK, val);\r\n}\r\nint snd_hda_mixer_amp_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nint chs = get_amp_channels(kcontrol);\r\nint dir = get_amp_direction(kcontrol);\r\nint idx = get_amp_index(kcontrol);\r\nunsigned int ofs = get_amp_offset(kcontrol);\r\nlong *valp = ucontrol->value.integer.value;\r\nif (chs & 1)\r\n*valp++ = read_amp_value(codec, nid, 0, dir, idx, ofs);\r\nif (chs & 2)\r\n*valp = read_amp_value(codec, nid, 1, dir, idx, ofs);\r\nreturn 0;\r\n}\r\nint snd_hda_mixer_amp_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nint chs = get_amp_channels(kcontrol);\r\nint dir = get_amp_direction(kcontrol);\r\nint idx = get_amp_index(kcontrol);\r\nunsigned int ofs = get_amp_offset(kcontrol);\r\nlong *valp = ucontrol->value.integer.value;\r\nint change = 0;\r\nsnd_hda_power_up(codec);\r\nif (chs & 1) {\r\nchange = update_amp_value(codec, nid, 0, dir, idx, ofs, *valp);\r\nvalp++;\r\n}\r\nif (chs & 2)\r\nchange |= update_amp_value(codec, nid, 1, dir, idx, ofs, *valp);\r\nsnd_hda_power_down(codec);\r\nreturn change;\r\n}\r\nint snd_hda_mixer_amp_tlv(struct snd_kcontrol *kcontrol, int op_flag,\r\nunsigned int size, unsigned int __user *_tlv)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nint dir = get_amp_direction(kcontrol);\r\nunsigned int ofs = get_amp_offset(kcontrol);\r\nbool min_mute = get_amp_min_mute(kcontrol);\r\nu32 caps, val1, val2;\r\nif (size < 4 * sizeof(unsigned int))\r\nreturn -ENOMEM;\r\ncaps = query_amp_caps(codec, nid, dir);\r\nval2 = (caps & AC_AMPCAP_STEP_SIZE) >> AC_AMPCAP_STEP_SIZE_SHIFT;\r\nval2 = (val2 + 1) * 25;\r\nval1 = -((caps & AC_AMPCAP_OFFSET) >> AC_AMPCAP_OFFSET_SHIFT);\r\nval1 += ofs;\r\nval1 = ((int)val1) * ((int)val2);\r\nif (min_mute || (caps & AC_AMPCAP_MIN_MUTE))\r\nval2 |= TLV_DB_SCALE_MUTE;\r\nif (put_user(SNDRV_CTL_TLVT_DB_SCALE, _tlv))\r\nreturn -EFAULT;\r\nif (put_user(2 * sizeof(unsigned int), _tlv + 1))\r\nreturn -EFAULT;\r\nif (put_user(val1, _tlv + 2))\r\nreturn -EFAULT;\r\nif (put_user(val2, _tlv + 3))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nvoid snd_hda_set_vmaster_tlv(struct hda_codec *codec, hda_nid_t nid, int dir,\r\nunsigned int *tlv)\r\n{\r\nu32 caps;\r\nint nums, step;\r\ncaps = query_amp_caps(codec, nid, dir);\r\nnums = (caps & AC_AMPCAP_NUM_STEPS) >> AC_AMPCAP_NUM_STEPS_SHIFT;\r\nstep = (caps & AC_AMPCAP_STEP_SIZE) >> AC_AMPCAP_STEP_SIZE_SHIFT;\r\nstep = (step + 1) * 25;\r\ntlv[0] = SNDRV_CTL_TLVT_DB_SCALE;\r\ntlv[1] = 2 * sizeof(unsigned int);\r\ntlv[2] = -nums * step;\r\ntlv[3] = step;\r\n}\r\nstatic struct snd_kcontrol *\r\nfind_mixer_ctl(struct hda_codec *codec, const char *name, int dev, int idx)\r\n{\r\nstruct snd_ctl_elem_id id;\r\nmemset(&id, 0, sizeof(id));\r\nid.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nid.device = dev;\r\nid.index = idx;\r\nif (snd_BUG_ON(strlen(name) >= sizeof(id.name)))\r\nreturn NULL;\r\nstrcpy(id.name, name);\r\nreturn snd_ctl_find_id(codec->bus->card, &id);\r\n}\r\nstruct snd_kcontrol *snd_hda_find_mixer_ctl(struct hda_codec *codec,\r\nconst char *name)\r\n{\r\nreturn find_mixer_ctl(codec, name, 0, 0);\r\n}\r\nstatic int find_empty_mixer_ctl_idx(struct hda_codec *codec, const char *name,\r\nint start_idx)\r\n{\r\nint i, idx;\r\nfor (i = 0, idx = start_idx; i < 16; i++, idx++) {\r\nif (!find_mixer_ctl(codec, name, 0, idx))\r\nreturn idx;\r\n}\r\nreturn -EBUSY;\r\n}\r\nint snd_hda_ctl_add(struct hda_codec *codec, hda_nid_t nid,\r\nstruct snd_kcontrol *kctl)\r\n{\r\nint err;\r\nunsigned short flags = 0;\r\nstruct hda_nid_item *item;\r\nif (kctl->id.subdevice & HDA_SUBDEV_AMP_FLAG) {\r\nflags |= HDA_NID_ITEM_AMP;\r\nif (nid == 0)\r\nnid = get_amp_nid_(kctl->private_value);\r\n}\r\nif ((kctl->id.subdevice & HDA_SUBDEV_NID_FLAG) != 0 && nid == 0)\r\nnid = kctl->id.subdevice & 0xffff;\r\nif (kctl->id.subdevice & (HDA_SUBDEV_NID_FLAG|HDA_SUBDEV_AMP_FLAG))\r\nkctl->id.subdevice = 0;\r\nerr = snd_ctl_add(codec->bus->card, kctl);\r\nif (err < 0)\r\nreturn err;\r\nitem = snd_array_new(&codec->mixers);\r\nif (!item)\r\nreturn -ENOMEM;\r\nitem->kctl = kctl;\r\nitem->nid = nid;\r\nitem->flags = flags;\r\nreturn 0;\r\n}\r\nint snd_hda_add_nid(struct hda_codec *codec, struct snd_kcontrol *kctl,\r\nunsigned int index, hda_nid_t nid)\r\n{\r\nstruct hda_nid_item *item;\r\nif (nid > 0) {\r\nitem = snd_array_new(&codec->nids);\r\nif (!item)\r\nreturn -ENOMEM;\r\nitem->kctl = kctl;\r\nitem->index = index;\r\nitem->nid = nid;\r\nreturn 0;\r\n}\r\ncodec_err(codec, "no NID for mapping control %s:%d:%d\n",\r\nkctl->id.name, kctl->id.index, index);\r\nreturn -EINVAL;\r\n}\r\nvoid snd_hda_ctls_clear(struct hda_codec *codec)\r\n{\r\nint i;\r\nstruct hda_nid_item *items = codec->mixers.list;\r\nfor (i = 0; i < codec->mixers.used; i++)\r\nsnd_ctl_remove(codec->bus->card, items[i].kctl);\r\nsnd_array_free(&codec->mixers);\r\nsnd_array_free(&codec->nids);\r\n}\r\nint snd_hda_lock_devices(struct hda_bus *bus)\r\n{\r\nstruct snd_card *card = bus->card;\r\nstruct hda_codec *codec;\r\nspin_lock(&card->files_lock);\r\nif (card->shutdown)\r\ngoto err_unlock;\r\ncard->shutdown = 1;\r\nif (!list_empty(&card->ctl_files))\r\ngoto err_clear;\r\nlist_for_each_entry(codec, &bus->codec_list, list) {\r\nint pcm;\r\nfor (pcm = 0; pcm < codec->num_pcms; pcm++) {\r\nstruct hda_pcm *cpcm = &codec->pcm_info[pcm];\r\nif (!cpcm->pcm)\r\ncontinue;\r\nif (cpcm->pcm->streams[0].substream_opened ||\r\ncpcm->pcm->streams[1].substream_opened)\r\ngoto err_clear;\r\n}\r\n}\r\nspin_unlock(&card->files_lock);\r\nreturn 0;\r\nerr_clear:\r\ncard->shutdown = 0;\r\nerr_unlock:\r\nspin_unlock(&card->files_lock);\r\nreturn -EINVAL;\r\n}\r\nvoid snd_hda_unlock_devices(struct hda_bus *bus)\r\n{\r\nstruct snd_card *card = bus->card;\r\ncard = bus->card;\r\nspin_lock(&card->files_lock);\r\ncard->shutdown = 0;\r\nspin_unlock(&card->files_lock);\r\n}\r\nint snd_hda_codec_reset(struct hda_codec *codec)\r\n{\r\nstruct hda_bus *bus = codec->bus;\r\nstruct snd_card *card = bus->card;\r\nint i;\r\nif (snd_hda_lock_devices(bus) < 0)\r\nreturn -EBUSY;\r\ncancel_delayed_work_sync(&codec->jackpoll_work);\r\n#ifdef CONFIG_PM\r\ncancel_delayed_work_sync(&codec->power_work);\r\nflush_workqueue(bus->workq);\r\n#endif\r\nsnd_hda_ctls_clear(codec);\r\nfor (i = 0; i < codec->num_pcms; i++) {\r\nif (codec->pcm_info[i].pcm) {\r\nsnd_device_free(card, codec->pcm_info[i].pcm);\r\nclear_bit(codec->pcm_info[i].device,\r\nbus->pcm_dev_bits);\r\n}\r\n}\r\nsnd_hda_detach_beep_device(codec);\r\nif (codec->patch_ops.free)\r\ncodec->patch_ops.free(codec);\r\nmemset(&codec->patch_ops, 0, sizeof(codec->patch_ops));\r\nsnd_hda_jack_tbl_clear(codec);\r\ncodec->proc_widget_hook = NULL;\r\ncodec->spec = NULL;\r\nfree_hda_cache(&codec->amp_cache);\r\nfree_hda_cache(&codec->cmd_cache);\r\ninit_hda_cache(&codec->amp_cache, sizeof(struct hda_amp_info));\r\ninit_hda_cache(&codec->cmd_cache, sizeof(struct hda_cache_head));\r\nsnd_array_free(&codec->driver_pins);\r\nsnd_array_free(&codec->cvt_setups);\r\nsnd_array_free(&codec->spdif_out);\r\nsnd_array_free(&codec->verbs);\r\ncodec->num_pcms = 0;\r\ncodec->pcm_info = NULL;\r\ncodec->preset = NULL;\r\ncodec->slave_dig_outs = NULL;\r\ncodec->spdif_status_reset = 0;\r\nunload_parser(codec);\r\nmodule_put(codec->owner);\r\ncodec->owner = NULL;\r\nsnd_hda_unlock_devices(bus);\r\nreturn 0;\r\n}\r\nstatic int map_slaves(struct hda_codec *codec, const char * const *slaves,\r\nconst char *suffix, map_slave_func_t func, void *data)\r\n{\r\nstruct hda_nid_item *items;\r\nconst char * const *s;\r\nint i, err;\r\nitems = codec->mixers.list;\r\nfor (i = 0; i < codec->mixers.used; i++) {\r\nstruct snd_kcontrol *sctl = items[i].kctl;\r\nif (!sctl || sctl->id.iface != SNDRV_CTL_ELEM_IFACE_MIXER)\r\ncontinue;\r\nfor (s = slaves; *s; s++) {\r\nchar tmpname[sizeof(sctl->id.name)];\r\nconst char *name = *s;\r\nif (suffix) {\r\nsnprintf(tmpname, sizeof(tmpname), "%s %s",\r\nname, suffix);\r\nname = tmpname;\r\n}\r\nif (!strcmp(sctl->id.name, name)) {\r\nerr = func(codec, data, sctl);\r\nif (err)\r\nreturn err;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int check_slave_present(struct hda_codec *codec,\r\nvoid *data, struct snd_kcontrol *sctl)\r\n{\r\nreturn 1;\r\n}\r\nstatic int get_kctl_0dB_offset(struct hda_codec *codec,\r\nstruct snd_kcontrol *kctl, int *step_to_check)\r\n{\r\nint _tlv[4];\r\nconst int *tlv = NULL;\r\nint val = -1;\r\nif (kctl->vd[0].access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {\r\nmm_segment_t fs = get_fs();\r\nset_fs(get_ds());\r\nif (!kctl->tlv.c(kctl, 0, sizeof(_tlv), _tlv))\r\ntlv = _tlv;\r\nset_fs(fs);\r\n} else if (kctl->vd[0].access & SNDRV_CTL_ELEM_ACCESS_TLV_READ)\r\ntlv = kctl->tlv.p;\r\nif (tlv && tlv[0] == SNDRV_CTL_TLVT_DB_SCALE) {\r\nint step = tlv[3];\r\nstep &= ~TLV_DB_SCALE_MUTE;\r\nif (!step)\r\nreturn -1;\r\nif (*step_to_check && *step_to_check != step) {\r\ncodec_err(codec, "Mismatching dB step for vmaster slave (%d!=%d)\n",\r\n- *step_to_check, step);\r\nreturn -1;\r\n}\r\n*step_to_check = step;\r\nval = -tlv[2] / step;\r\n}\r\nreturn val;\r\n}\r\nstatic int put_kctl_with_value(struct snd_kcontrol *kctl, int val)\r\n{\r\nstruct snd_ctl_elem_value *ucontrol;\r\nucontrol = kzalloc(sizeof(*ucontrol), GFP_KERNEL);\r\nif (!ucontrol)\r\nreturn -ENOMEM;\r\nucontrol->value.integer.value[0] = val;\r\nucontrol->value.integer.value[1] = val;\r\nkctl->put(kctl, ucontrol);\r\nkfree(ucontrol);\r\nreturn 0;\r\n}\r\nstatic int init_slave_0dB(struct hda_codec *codec,\r\nvoid *data, struct snd_kcontrol *slave)\r\n{\r\nint offset = get_kctl_0dB_offset(codec, slave, data);\r\nif (offset > 0)\r\nput_kctl_with_value(slave, offset);\r\nreturn 0;\r\n}\r\nstatic int init_slave_unmute(struct hda_codec *codec,\r\nvoid *data, struct snd_kcontrol *slave)\r\n{\r\nreturn put_kctl_with_value(slave, 1);\r\n}\r\nstatic int add_slave(struct hda_codec *codec,\r\nvoid *data, struct snd_kcontrol *slave)\r\n{\r\nreturn snd_ctl_add_slave(data, slave);\r\n}\r\nint __snd_hda_add_vmaster(struct hda_codec *codec, char *name,\r\nunsigned int *tlv, const char * const *slaves,\r\nconst char *suffix, bool init_slave_vol,\r\nstruct snd_kcontrol **ctl_ret)\r\n{\r\nstruct snd_kcontrol *kctl;\r\nint err;\r\nif (ctl_ret)\r\n*ctl_ret = NULL;\r\nerr = map_slaves(codec, slaves, suffix, check_slave_present, NULL);\r\nif (err != 1) {\r\ncodec_dbg(codec, "No slave found for %s\n", name);\r\nreturn 0;\r\n}\r\nkctl = snd_ctl_make_virtual_master(name, tlv);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nerr = snd_hda_ctl_add(codec, 0, kctl);\r\nif (err < 0)\r\nreturn err;\r\nerr = map_slaves(codec, slaves, suffix, add_slave, kctl);\r\nif (err < 0)\r\nreturn err;\r\nput_kctl_with_value(kctl, 0);\r\nif (init_slave_vol) {\r\nint step = 0;\r\nmap_slaves(codec, slaves, suffix,\r\ntlv ? init_slave_0dB : init_slave_unmute, &step);\r\n}\r\nif (ctl_ret)\r\n*ctl_ret = kctl;\r\nreturn 0;\r\n}\r\nstatic int vmaster_mute_mode_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[] = {\r\n"On", "Off", "Follow Master"\r\n};\r\nreturn snd_ctl_enum_info(uinfo, 1, 3, texts);\r\n}\r\nstatic int vmaster_mute_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_vmaster_mute_hook *hook = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hook->mute_mode;\r\nreturn 0;\r\n}\r\nstatic int vmaster_mute_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_vmaster_mute_hook *hook = snd_kcontrol_chip(kcontrol);\r\nunsigned int old_mode = hook->mute_mode;\r\nhook->mute_mode = ucontrol->value.enumerated.item[0];\r\nif (hook->mute_mode > HDA_VMUTE_FOLLOW_MASTER)\r\nhook->mute_mode = HDA_VMUTE_FOLLOW_MASTER;\r\nif (old_mode == hook->mute_mode)\r\nreturn 0;\r\nsnd_hda_sync_vmaster_hook(hook);\r\nreturn 1;\r\n}\r\nint snd_hda_add_vmaster_hook(struct hda_codec *codec,\r\nstruct hda_vmaster_mute_hook *hook,\r\nbool expose_enum_ctl)\r\n{\r\nstruct snd_kcontrol *kctl;\r\nif (!hook->hook || !hook->sw_kctl)\r\nreturn 0;\r\nsnd_ctl_add_vmaster_hook(hook->sw_kctl, hook->hook, codec);\r\nhook->codec = codec;\r\nhook->mute_mode = HDA_VMUTE_FOLLOW_MASTER;\r\nif (!expose_enum_ctl)\r\nreturn 0;\r\nkctl = snd_ctl_new1(&vmaster_mute_mode, hook);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nreturn snd_hda_ctl_add(codec, 0, kctl);\r\n}\r\nvoid snd_hda_sync_vmaster_hook(struct hda_vmaster_mute_hook *hook)\r\n{\r\nif (!hook->hook || !hook->codec)\r\nreturn;\r\nif (hook->codec->bus->shutdown)\r\nreturn;\r\nswitch (hook->mute_mode) {\r\ncase HDA_VMUTE_FOLLOW_MASTER:\r\nsnd_ctl_sync_vmaster_hook(hook->sw_kctl);\r\nbreak;\r\ndefault:\r\nhook->hook(hook->codec, hook->mute_mode);\r\nbreak;\r\n}\r\n}\r\nint snd_hda_mixer_amp_switch_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint chs = get_amp_channels(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = chs == 3 ? 2 : 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nint snd_hda_mixer_amp_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nint chs = get_amp_channels(kcontrol);\r\nint dir = get_amp_direction(kcontrol);\r\nint idx = get_amp_index(kcontrol);\r\nlong *valp = ucontrol->value.integer.value;\r\nif (chs & 1)\r\n*valp++ = (snd_hda_codec_amp_read(codec, nid, 0, dir, idx) &\r\nHDA_AMP_MUTE) ? 0 : 1;\r\nif (chs & 2)\r\n*valp = (snd_hda_codec_amp_read(codec, nid, 1, dir, idx) &\r\nHDA_AMP_MUTE) ? 0 : 1;\r\nreturn 0;\r\n}\r\nint snd_hda_mixer_amp_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = get_amp_nid(kcontrol);\r\nint chs = get_amp_channels(kcontrol);\r\nint dir = get_amp_direction(kcontrol);\r\nint idx = get_amp_index(kcontrol);\r\nlong *valp = ucontrol->value.integer.value;\r\nint change = 0;\r\nsnd_hda_power_up(codec);\r\nif (chs & 1) {\r\nchange = snd_hda_codec_amp_update(codec, nid, 0, dir, idx,\r\nHDA_AMP_MUTE,\r\n*valp ? 0 : HDA_AMP_MUTE);\r\nvalp++;\r\n}\r\nif (chs & 2)\r\nchange |= snd_hda_codec_amp_update(codec, nid, 1, dir, idx,\r\nHDA_AMP_MUTE,\r\n*valp ? 0 : HDA_AMP_MUTE);\r\nhda_call_check_power_status(codec, nid);\r\nsnd_hda_power_down(codec);\r\nreturn change;\r\n}\r\nint snd_hda_mixer_bind_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nunsigned long pval;\r\nint err;\r\nmutex_lock(&codec->control_mutex);\r\npval = kcontrol->private_value;\r\nkcontrol->private_value = pval & ~AMP_VAL_IDX_MASK;\r\nerr = snd_hda_mixer_amp_switch_get(kcontrol, ucontrol);\r\nkcontrol->private_value = pval;\r\nmutex_unlock(&codec->control_mutex);\r\nreturn err;\r\n}\r\nint snd_hda_mixer_bind_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nunsigned long pval;\r\nint i, indices, err = 0, change = 0;\r\nmutex_lock(&codec->control_mutex);\r\npval = kcontrol->private_value;\r\nindices = (pval & AMP_VAL_IDX_MASK) >> AMP_VAL_IDX_SHIFT;\r\nfor (i = 0; i < indices; i++) {\r\nkcontrol->private_value = (pval & ~AMP_VAL_IDX_MASK) |\r\n(i << AMP_VAL_IDX_SHIFT);\r\nerr = snd_hda_mixer_amp_switch_put(kcontrol, ucontrol);\r\nif (err < 0)\r\nbreak;\r\nchange |= err;\r\n}\r\nkcontrol->private_value = pval;\r\nmutex_unlock(&codec->control_mutex);\r\nreturn err < 0 ? err : change;\r\n}\r\nint snd_hda_mixer_bind_ctls_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_bind_ctls *c;\r\nint err;\r\nmutex_lock(&codec->control_mutex);\r\nc = (struct hda_bind_ctls *)kcontrol->private_value;\r\nkcontrol->private_value = *c->values;\r\nerr = c->ops->info(kcontrol, uinfo);\r\nkcontrol->private_value = (long)c;\r\nmutex_unlock(&codec->control_mutex);\r\nreturn err;\r\n}\r\nint snd_hda_mixer_bind_ctls_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_bind_ctls *c;\r\nint err;\r\nmutex_lock(&codec->control_mutex);\r\nc = (struct hda_bind_ctls *)kcontrol->private_value;\r\nkcontrol->private_value = *c->values;\r\nerr = c->ops->get(kcontrol, ucontrol);\r\nkcontrol->private_value = (long)c;\r\nmutex_unlock(&codec->control_mutex);\r\nreturn err;\r\n}\r\nint snd_hda_mixer_bind_ctls_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_bind_ctls *c;\r\nunsigned long *vals;\r\nint err = 0, change = 0;\r\nmutex_lock(&codec->control_mutex);\r\nc = (struct hda_bind_ctls *)kcontrol->private_value;\r\nfor (vals = c->values; *vals; vals++) {\r\nkcontrol->private_value = *vals;\r\nerr = c->ops->put(kcontrol, ucontrol);\r\nif (err < 0)\r\nbreak;\r\nchange |= err;\r\n}\r\nkcontrol->private_value = (long)c;\r\nmutex_unlock(&codec->control_mutex);\r\nreturn err < 0 ? err : change;\r\n}\r\nint snd_hda_mixer_bind_tlv(struct snd_kcontrol *kcontrol, int op_flag,\r\nunsigned int size, unsigned int __user *tlv)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct hda_bind_ctls *c;\r\nint err;\r\nmutex_lock(&codec->control_mutex);\r\nc = (struct hda_bind_ctls *)kcontrol->private_value;\r\nkcontrol->private_value = *c->values;\r\nerr = c->ops->tlv(kcontrol, op_flag, size, tlv);\r\nkcontrol->private_value = (long)c;\r\nmutex_unlock(&codec->control_mutex);\r\nreturn err;\r\n}\r\nstatic int snd_hda_spdif_mask_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_hda_spdif_cmask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = IEC958_AES0_PROFESSIONAL |\r\nIEC958_AES0_NONAUDIO |\r\nIEC958_AES0_CON_EMPHASIS_5015 |\r\nIEC958_AES0_CON_NOT_COPYRIGHT;\r\nucontrol->value.iec958.status[1] = IEC958_AES1_CON_CATEGORY |\r\nIEC958_AES1_CON_ORIGINAL;\r\nreturn 0;\r\n}\r\nstatic int snd_hda_spdif_pmask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = IEC958_AES0_PROFESSIONAL |\r\nIEC958_AES0_NONAUDIO |\r\nIEC958_AES0_PRO_EMPHASIS_5015;\r\nreturn 0;\r\n}\r\nstatic int snd_hda_spdif_default_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nint idx = kcontrol->private_value;\r\nstruct hda_spdif_out *spdif;\r\nmutex_lock(&codec->spdif_mutex);\r\nspdif = snd_array_elem(&codec->spdif_out, idx);\r\nucontrol->value.iec958.status[0] = spdif->status & 0xff;\r\nucontrol->value.iec958.status[1] = (spdif->status >> 8) & 0xff;\r\nucontrol->value.iec958.status[2] = (spdif->status >> 16) & 0xff;\r\nucontrol->value.iec958.status[3] = (spdif->status >> 24) & 0xff;\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn 0;\r\n}\r\nstatic unsigned short convert_from_spdif_status(unsigned int sbits)\r\n{\r\nunsigned short val = 0;\r\nif (sbits & IEC958_AES0_PROFESSIONAL)\r\nval |= AC_DIG1_PROFESSIONAL;\r\nif (sbits & IEC958_AES0_NONAUDIO)\r\nval |= AC_DIG1_NONAUDIO;\r\nif (sbits & IEC958_AES0_PROFESSIONAL) {\r\nif ((sbits & IEC958_AES0_PRO_EMPHASIS) ==\r\nIEC958_AES0_PRO_EMPHASIS_5015)\r\nval |= AC_DIG1_EMPHASIS;\r\n} else {\r\nif ((sbits & IEC958_AES0_CON_EMPHASIS) ==\r\nIEC958_AES0_CON_EMPHASIS_5015)\r\nval |= AC_DIG1_EMPHASIS;\r\nif (!(sbits & IEC958_AES0_CON_NOT_COPYRIGHT))\r\nval |= AC_DIG1_COPYRIGHT;\r\nif (sbits & (IEC958_AES1_CON_ORIGINAL << 8))\r\nval |= AC_DIG1_LEVEL;\r\nval |= sbits & (IEC958_AES1_CON_CATEGORY << 8);\r\n}\r\nreturn val;\r\n}\r\nstatic unsigned int convert_to_spdif_status(unsigned short val)\r\n{\r\nunsigned int sbits = 0;\r\nif (val & AC_DIG1_NONAUDIO)\r\nsbits |= IEC958_AES0_NONAUDIO;\r\nif (val & AC_DIG1_PROFESSIONAL)\r\nsbits |= IEC958_AES0_PROFESSIONAL;\r\nif (sbits & IEC958_AES0_PROFESSIONAL) {\r\nif (val & AC_DIG1_EMPHASIS)\r\nsbits |= IEC958_AES0_PRO_EMPHASIS_5015;\r\n} else {\r\nif (val & AC_DIG1_EMPHASIS)\r\nsbits |= IEC958_AES0_CON_EMPHASIS_5015;\r\nif (!(val & AC_DIG1_COPYRIGHT))\r\nsbits |= IEC958_AES0_CON_NOT_COPYRIGHT;\r\nif (val & AC_DIG1_LEVEL)\r\nsbits |= (IEC958_AES1_CON_ORIGINAL << 8);\r\nsbits |= val & (0x7f << 8);\r\n}\r\nreturn sbits;\r\n}\r\nstatic void set_dig_out(struct hda_codec *codec, hda_nid_t nid,\r\nint verb, int val)\r\n{\r\nconst hda_nid_t *d;\r\nsnd_hda_codec_write_cache(codec, nid, 0, verb, val);\r\nd = codec->slave_dig_outs;\r\nif (!d)\r\nreturn;\r\nfor (; *d; d++)\r\nsnd_hda_codec_write_cache(codec, *d, 0, verb, val);\r\n}\r\nstatic inline void set_dig_out_convert(struct hda_codec *codec, hda_nid_t nid,\r\nint dig1, int dig2)\r\n{\r\nif (dig1 != -1)\r\nset_dig_out(codec, nid, AC_VERB_SET_DIGI_CONVERT_1, dig1);\r\nif (dig2 != -1)\r\nset_dig_out(codec, nid, AC_VERB_SET_DIGI_CONVERT_2, dig2);\r\n}\r\nstatic int snd_hda_spdif_default_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nint idx = kcontrol->private_value;\r\nstruct hda_spdif_out *spdif;\r\nhda_nid_t nid;\r\nunsigned short val;\r\nint change;\r\nmutex_lock(&codec->spdif_mutex);\r\nspdif = snd_array_elem(&codec->spdif_out, idx);\r\nnid = spdif->nid;\r\nspdif->status = ucontrol->value.iec958.status[0] |\r\n((unsigned int)ucontrol->value.iec958.status[1] << 8) |\r\n((unsigned int)ucontrol->value.iec958.status[2] << 16) |\r\n((unsigned int)ucontrol->value.iec958.status[3] << 24);\r\nval = convert_from_spdif_status(spdif->status);\r\nval |= spdif->ctls & 1;\r\nchange = spdif->ctls != val;\r\nspdif->ctls = val;\r\nif (change && nid != (u16)-1)\r\nset_dig_out_convert(codec, nid, val & 0xff, (val >> 8) & 0xff);\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn change;\r\n}\r\nstatic int snd_hda_spdif_out_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nint idx = kcontrol->private_value;\r\nstruct hda_spdif_out *spdif;\r\nmutex_lock(&codec->spdif_mutex);\r\nspdif = snd_array_elem(&codec->spdif_out, idx);\r\nucontrol->value.integer.value[0] = spdif->ctls & AC_DIG1_ENABLE;\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn 0;\r\n}\r\nstatic inline void set_spdif_ctls(struct hda_codec *codec, hda_nid_t nid,\r\nint dig1, int dig2)\r\n{\r\nset_dig_out_convert(codec, nid, dig1, dig2);\r\nif ((get_wcaps(codec, nid) & AC_WCAP_OUT_AMP) &&\r\n(dig1 & AC_DIG1_ENABLE))\r\nsnd_hda_codec_amp_stereo(codec, nid, HDA_OUTPUT, 0,\r\nHDA_AMP_MUTE, 0);\r\n}\r\nstatic int snd_hda_spdif_out_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nint idx = kcontrol->private_value;\r\nstruct hda_spdif_out *spdif;\r\nhda_nid_t nid;\r\nunsigned short val;\r\nint change;\r\nmutex_lock(&codec->spdif_mutex);\r\nspdif = snd_array_elem(&codec->spdif_out, idx);\r\nnid = spdif->nid;\r\nval = spdif->ctls & ~AC_DIG1_ENABLE;\r\nif (ucontrol->value.integer.value[0])\r\nval |= AC_DIG1_ENABLE;\r\nchange = spdif->ctls != val;\r\nspdif->ctls = val;\r\nif (change && nid != (u16)-1)\r\nset_spdif_ctls(codec, nid, val & 0xff, -1);\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn change;\r\n}\r\nint snd_hda_create_dig_out_ctls(struct hda_codec *codec,\r\nhda_nid_t associated_nid,\r\nhda_nid_t cvt_nid,\r\nint type)\r\n{\r\nint err;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_kcontrol_new *dig_mix;\r\nint idx = 0;\r\nconst int spdif_index = 16;\r\nstruct hda_spdif_out *spdif;\r\nstruct hda_bus *bus = codec->bus;\r\nif (bus->primary_dig_out_type == HDA_PCM_TYPE_HDMI &&\r\ntype == HDA_PCM_TYPE_SPDIF) {\r\nidx = spdif_index;\r\n} else if (bus->primary_dig_out_type == HDA_PCM_TYPE_SPDIF &&\r\ntype == HDA_PCM_TYPE_HDMI) {\r\nfor (dig_mix = dig_mixes; dig_mix->name; dig_mix++) {\r\nkctl = find_mixer_ctl(codec, dig_mix->name, 0, 0);\r\nif (!kctl)\r\nbreak;\r\nkctl->id.index = spdif_index;\r\n}\r\nbus->primary_dig_out_type = HDA_PCM_TYPE_HDMI;\r\n}\r\nif (!bus->primary_dig_out_type)\r\nbus->primary_dig_out_type = type;\r\nidx = find_empty_mixer_ctl_idx(codec, "IEC958 Playback Switch", idx);\r\nif (idx < 0) {\r\ncodec_err(codec, "too many IEC958 outputs\n");\r\nreturn -EBUSY;\r\n}\r\nspdif = snd_array_new(&codec->spdif_out);\r\nif (!spdif)\r\nreturn -ENOMEM;\r\nfor (dig_mix = dig_mixes; dig_mix->name; dig_mix++) {\r\nkctl = snd_ctl_new1(dig_mix, codec);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nkctl->id.index = idx;\r\nkctl->private_value = codec->spdif_out.used - 1;\r\nerr = snd_hda_ctl_add(codec, associated_nid, kctl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nspdif->nid = cvt_nid;\r\nspdif->ctls = snd_hda_codec_read(codec, cvt_nid, 0,\r\nAC_VERB_GET_DIGI_CONVERT_1, 0);\r\nspdif->status = convert_to_spdif_status(spdif->ctls);\r\nreturn 0;\r\n}\r\nstruct hda_spdif_out *snd_hda_spdif_out_of_nid(struct hda_codec *codec,\r\nhda_nid_t nid)\r\n{\r\nint i;\r\nfor (i = 0; i < codec->spdif_out.used; i++) {\r\nstruct hda_spdif_out *spdif =\r\nsnd_array_elem(&codec->spdif_out, i);\r\nif (spdif->nid == nid)\r\nreturn spdif;\r\n}\r\nreturn NULL;\r\n}\r\nvoid snd_hda_spdif_ctls_unassign(struct hda_codec *codec, int idx)\r\n{\r\nstruct hda_spdif_out *spdif;\r\nmutex_lock(&codec->spdif_mutex);\r\nspdif = snd_array_elem(&codec->spdif_out, idx);\r\nspdif->nid = (u16)-1;\r\nmutex_unlock(&codec->spdif_mutex);\r\n}\r\nvoid snd_hda_spdif_ctls_assign(struct hda_codec *codec, int idx, hda_nid_t nid)\r\n{\r\nstruct hda_spdif_out *spdif;\r\nunsigned short val;\r\nmutex_lock(&codec->spdif_mutex);\r\nspdif = snd_array_elem(&codec->spdif_out, idx);\r\nif (spdif->nid != nid) {\r\nspdif->nid = nid;\r\nval = spdif->ctls;\r\nset_spdif_ctls(codec, nid, val & 0xff, (val >> 8) & 0xff);\r\n}\r\nmutex_unlock(&codec->spdif_mutex);\r\n}\r\nstatic int spdif_share_sw_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_multi_out *mout = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = mout->share_spdif;\r\nreturn 0;\r\n}\r\nstatic int spdif_share_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_multi_out *mout = snd_kcontrol_chip(kcontrol);\r\nmout->share_spdif = !!ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nint snd_hda_create_spdif_share_sw(struct hda_codec *codec,\r\nstruct hda_multi_out *mout)\r\n{\r\nstruct snd_kcontrol *kctl;\r\nif (!mout->dig_out_nid)\r\nreturn 0;\r\nkctl = snd_ctl_new1(&spdif_share_sw, mout);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nreturn snd_hda_ctl_add(codec, mout->dig_out_nid, kctl);\r\n}\r\nstatic int snd_hda_spdif_in_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = codec->spdif_in_enable;\r\nreturn 0;\r\n}\r\nstatic int snd_hda_spdif_in_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value;\r\nunsigned int val = !!ucontrol->value.integer.value[0];\r\nint change;\r\nmutex_lock(&codec->spdif_mutex);\r\nchange = codec->spdif_in_enable != val;\r\nif (change) {\r\ncodec->spdif_in_enable = val;\r\nsnd_hda_codec_write_cache(codec, nid, 0,\r\nAC_VERB_SET_DIGI_CONVERT_1, val);\r\n}\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn change;\r\n}\r\nstatic int snd_hda_spdif_in_status_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nhda_nid_t nid = kcontrol->private_value;\r\nunsigned short val;\r\nunsigned int sbits;\r\nval = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_DIGI_CONVERT_1, 0);\r\nsbits = convert_to_spdif_status(val);\r\nucontrol->value.iec958.status[0] = sbits;\r\nucontrol->value.iec958.status[1] = sbits >> 8;\r\nucontrol->value.iec958.status[2] = sbits >> 16;\r\nucontrol->value.iec958.status[3] = sbits >> 24;\r\nreturn 0;\r\n}\r\nint snd_hda_create_spdif_in_ctls(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nint err;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_kcontrol_new *dig_mix;\r\nint idx;\r\nidx = find_empty_mixer_ctl_idx(codec, "IEC958 Capture Switch", 0);\r\nif (idx < 0) {\r\ncodec_err(codec, "too many IEC958 inputs\n");\r\nreturn -EBUSY;\r\n}\r\nfor (dig_mix = dig_in_ctls; dig_mix->name; dig_mix++) {\r\nkctl = snd_ctl_new1(dig_mix, codec);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nkctl->private_value = nid;\r\nerr = snd_hda_ctl_add(codec, nid, kctl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\ncodec->spdif_in_enable =\r\nsnd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_DIGI_CONVERT_1, 0) &\r\nAC_DIG1_ENABLE;\r\nreturn 0;\r\n}\r\nint snd_hda_codec_write_cache(struct hda_codec *codec, hda_nid_t nid,\r\nint flags, unsigned int verb, unsigned int parm)\r\n{\r\nint err;\r\nstruct hda_cache_head *c;\r\nu32 key;\r\nunsigned int cache_only;\r\ncache_only = codec->cached_write;\r\nif (!cache_only) {\r\nerr = snd_hda_codec_write(codec, nid, flags, verb, parm);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nverb = verb | (parm >> 8);\r\nparm &= 0xff;\r\nkey = build_cmd_cache_key(nid, verb);\r\nmutex_lock(&codec->bus->cmd_mutex);\r\nc = get_alloc_hash(&codec->cmd_cache, key);\r\nif (c) {\r\nc->val = parm;\r\nc->dirty = cache_only;\r\n}\r\nmutex_unlock(&codec->bus->cmd_mutex);\r\nreturn 0;\r\n}\r\nint snd_hda_codec_update_cache(struct hda_codec *codec, hda_nid_t nid,\r\nint flags, unsigned int verb, unsigned int parm)\r\n{\r\nstruct hda_cache_head *c;\r\nu32 key;\r\nverb = verb | (parm >> 8);\r\nparm &= 0xff;\r\nkey = build_cmd_cache_key(nid, verb);\r\nmutex_lock(&codec->bus->cmd_mutex);\r\nc = get_hash(&codec->cmd_cache, key);\r\nif (c && c->val == parm) {\r\nmutex_unlock(&codec->bus->cmd_mutex);\r\nreturn 0;\r\n}\r\nmutex_unlock(&codec->bus->cmd_mutex);\r\nreturn snd_hda_codec_write_cache(codec, nid, flags, verb, parm);\r\n}\r\nvoid snd_hda_codec_resume_cache(struct hda_codec *codec)\r\n{\r\nint i;\r\nmutex_lock(&codec->hash_mutex);\r\ncodec->cached_write = 0;\r\nfor (i = 0; i < codec->cmd_cache.buf.used; i++) {\r\nstruct hda_cache_head *buffer;\r\nu32 key;\r\nbuffer = snd_array_elem(&codec->cmd_cache.buf, i);\r\nkey = buffer->key;\r\nif (!key)\r\ncontinue;\r\nif (!buffer->dirty)\r\ncontinue;\r\nbuffer->dirty = 0;\r\nmutex_unlock(&codec->hash_mutex);\r\nsnd_hda_codec_write(codec, get_cmd_cache_nid(key), 0,\r\nget_cmd_cache_cmd(key), buffer->val);\r\nmutex_lock(&codec->hash_mutex);\r\n}\r\nmutex_unlock(&codec->hash_mutex);\r\n}\r\nvoid snd_hda_sequence_write_cache(struct hda_codec *codec,\r\nconst struct hda_verb *seq)\r\n{\r\nfor (; seq->nid; seq++)\r\nsnd_hda_codec_write_cache(codec, seq->nid, 0, seq->verb,\r\nseq->param);\r\n}\r\nvoid snd_hda_codec_flush_cache(struct hda_codec *codec)\r\n{\r\nsnd_hda_codec_resume_amp(codec);\r\nsnd_hda_codec_resume_cache(codec);\r\n}\r\nvoid snd_hda_codec_set_power_to_all(struct hda_codec *codec, hda_nid_t fg,\r\nunsigned int power_state)\r\n{\r\nhda_nid_t nid = codec->start_nid;\r\nint i;\r\nfor (i = 0; i < codec->num_nodes; i++, nid++) {\r\nunsigned int wcaps = get_wcaps(codec, nid);\r\nunsigned int state = power_state;\r\nif (!(wcaps & AC_WCAP_POWER))\r\ncontinue;\r\nif (codec->power_filter) {\r\nstate = codec->power_filter(codec, nid, power_state);\r\nif (state != power_state && power_state == AC_PWRST_D3)\r\ncontinue;\r\n}\r\nsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_POWER_STATE,\r\nstate);\r\n}\r\n}\r\nstatic bool snd_hda_codec_get_supported_ps(struct hda_codec *codec, hda_nid_t fg,\r\nunsigned int power_state)\r\n{\r\nint sup = snd_hda_param_read(codec, fg, AC_PAR_POWER_STATE);\r\nif (sup == -1)\r\nreturn false;\r\nif (sup & power_state)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic unsigned int hda_sync_power_state(struct hda_codec *codec,\r\nhda_nid_t fg,\r\nunsigned int power_state)\r\n{\r\nunsigned long end_time = jiffies + msecs_to_jiffies(500);\r\nunsigned int state, actual_state;\r\nfor (;;) {\r\nstate = snd_hda_codec_read(codec, fg, 0,\r\nAC_VERB_GET_POWER_STATE, 0);\r\nif (state & AC_PWRST_ERROR)\r\nbreak;\r\nactual_state = (state >> 4) & 0x0f;\r\nif (actual_state == power_state)\r\nbreak;\r\nif (time_after_eq(jiffies, end_time))\r\nbreak;\r\nmsleep(1);\r\n}\r\nreturn state;\r\n}\r\nunsigned int snd_hda_codec_eapd_power_filter(struct hda_codec *codec,\r\nhda_nid_t nid,\r\nunsigned int power_state)\r\n{\r\nif (nid == codec->afg || nid == codec->mfg)\r\nreturn power_state;\r\nif (power_state == AC_PWRST_D3 &&\r\nget_wcaps_type(get_wcaps(codec, nid)) == AC_WID_PIN &&\r\n(snd_hda_query_pin_caps(codec, nid) & AC_PINCAP_EAPD)) {\r\nint eapd = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_EAPD_BTLENABLE, 0);\r\nif (eapd & 0x02)\r\nreturn AC_PWRST_D0;\r\n}\r\nreturn power_state;\r\n}\r\nstatic unsigned int hda_set_power_state(struct hda_codec *codec,\r\nunsigned int power_state)\r\n{\r\nhda_nid_t fg = codec->afg ? codec->afg : codec->mfg;\r\nint count;\r\nunsigned int state;\r\nint flags = 0;\r\nif (power_state == AC_PWRST_D3) {\r\nif (codec->depop_delay < 0)\r\nmsleep(codec->epss ? 10 : 100);\r\nelse if (codec->depop_delay > 0)\r\nmsleep(codec->depop_delay);\r\nflags = HDA_RW_NO_RESPONSE_FALLBACK;\r\n}\r\nfor (count = 0; count < 10; count++) {\r\nif (codec->patch_ops.set_power_state)\r\ncodec->patch_ops.set_power_state(codec, fg,\r\npower_state);\r\nelse {\r\nstate = power_state;\r\nif (codec->power_filter)\r\nstate = codec->power_filter(codec, fg, state);\r\nif (state == power_state || power_state != AC_PWRST_D3)\r\nsnd_hda_codec_read(codec, fg, flags,\r\nAC_VERB_SET_POWER_STATE,\r\nstate);\r\nsnd_hda_codec_set_power_to_all(codec, fg, power_state);\r\n}\r\nstate = hda_sync_power_state(codec, fg, power_state);\r\nif (!(state & AC_PWRST_ERROR))\r\nbreak;\r\n}\r\nreturn state;\r\n}\r\nstatic void sync_power_up_states(struct hda_codec *codec)\r\n{\r\nhda_nid_t nid = codec->start_nid;\r\nint i;\r\nif (!codec->power_filter)\r\nreturn;\r\nfor (i = 0; i < codec->num_nodes; i++, nid++) {\r\nunsigned int wcaps = get_wcaps(codec, nid);\r\nunsigned int target;\r\nif (!(wcaps & AC_WCAP_POWER))\r\ncontinue;\r\ntarget = codec->power_filter(codec, nid, AC_PWRST_D0);\r\nif (target == AC_PWRST_D0)\r\ncontinue;\r\nif (!snd_hda_check_power_state(codec, nid, target))\r\nsnd_hda_codec_write(codec, nid, 0,\r\nAC_VERB_SET_POWER_STATE, target);\r\n}\r\n}\r\nstatic void hda_exec_init_verbs(struct hda_codec *codec)\r\n{\r\nif (codec->init_verbs.list)\r\nsnd_hda_sequence_write(codec, codec->init_verbs.list);\r\n}\r\nstatic inline void hda_exec_init_verbs(struct hda_codec *codec) {}\r\nstatic unsigned int hda_call_codec_suspend(struct hda_codec *codec, bool in_wq)\r\n{\r\nunsigned int state;\r\ncodec->in_pm = 1;\r\nif (codec->patch_ops.suspend)\r\ncodec->patch_ops.suspend(codec);\r\nhda_cleanup_all_streams(codec);\r\nstate = hda_set_power_state(codec, AC_PWRST_D3);\r\nif (!in_wq)\r\ncancel_delayed_work_sync(&codec->power_work);\r\nspin_lock(&codec->power_lock);\r\nsnd_hda_update_power_acct(codec);\r\ntrace_hda_power_down(codec);\r\ncodec->power_on = 0;\r\ncodec->power_transition = 0;\r\ncodec->power_jiffies = jiffies;\r\nspin_unlock(&codec->power_lock);\r\ncodec->in_pm = 0;\r\nreturn state;\r\n}\r\nstatic void hda_mark_cmd_cache_dirty(struct hda_codec *codec)\r\n{\r\nint i;\r\nfor (i = 0; i < codec->cmd_cache.buf.used; i++) {\r\nstruct hda_cache_head *cmd;\r\ncmd = snd_array_elem(&codec->cmd_cache.buf, i);\r\ncmd->dirty = 1;\r\n}\r\nfor (i = 0; i < codec->amp_cache.buf.used; i++) {\r\nstruct hda_amp_info *amp;\r\namp = snd_array_elem(&codec->amp_cache.buf, i);\r\namp->head.dirty = 1;\r\n}\r\n}\r\nstatic void hda_call_codec_resume(struct hda_codec *codec)\r\n{\r\ncodec->in_pm = 1;\r\nhda_mark_cmd_cache_dirty(codec);\r\nhda_keep_power_on(codec);\r\nhda_set_power_state(codec, AC_PWRST_D0);\r\nrestore_shutup_pins(codec);\r\nhda_exec_init_verbs(codec);\r\nsnd_hda_jack_set_dirty_all(codec);\r\nif (codec->patch_ops.resume)\r\ncodec->patch_ops.resume(codec);\r\nelse {\r\nif (codec->patch_ops.init)\r\ncodec->patch_ops.init(codec);\r\nsnd_hda_codec_resume_amp(codec);\r\nsnd_hda_codec_resume_cache(codec);\r\n}\r\nif (codec->jackpoll_interval)\r\nhda_jackpoll_work(&codec->jackpoll_work.work);\r\nelse\r\nsnd_hda_jack_report_sync(codec);\r\ncodec->in_pm = 0;\r\nsnd_hda_power_down(codec);\r\n}\r\nint snd_hda_build_controls(struct hda_bus *bus)\r\n{\r\nstruct hda_codec *codec;\r\nlist_for_each_entry(codec, &bus->codec_list, list) {\r\nint err = snd_hda_codec_build_controls(codec);\r\nif (err < 0) {\r\ncodec_err(codec,\r\n"cannot build controls for #%d (error %d)\n",\r\ncodec->addr, err);\r\nerr = snd_hda_codec_reset(codec);\r\nif (err < 0) {\r\ncodec_err(codec,\r\n"cannot revert codec\n");\r\nreturn err;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int add_std_chmaps(struct hda_codec *codec)\r\n{\r\nint i, str, err;\r\nfor (i = 0; i < codec->num_pcms; i++) {\r\nfor (str = 0; str < 2; str++) {\r\nstruct snd_pcm *pcm = codec->pcm_info[i].pcm;\r\nstruct hda_pcm_stream *hinfo =\r\n&codec->pcm_info[i].stream[str];\r\nstruct snd_pcm_chmap *chmap;\r\nconst struct snd_pcm_chmap_elem *elem;\r\nif (codec->pcm_info[i].own_chmap)\r\ncontinue;\r\nif (!pcm || !hinfo->substreams)\r\ncontinue;\r\nelem = hinfo->chmap ? hinfo->chmap : snd_pcm_std_chmaps;\r\nerr = snd_pcm_add_chmap_ctls(pcm, str, elem,\r\nhinfo->channels_max,\r\n0, &chmap);\r\nif (err < 0)\r\nreturn err;\r\nchmap->channel_mask = SND_PCM_CHMAP_MASK_2468;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint snd_hda_codec_build_controls(struct hda_codec *codec)\r\n{\r\nint err = 0;\r\nhda_exec_init_verbs(codec);\r\nif (codec->patch_ops.init)\r\nerr = codec->patch_ops.init(codec);\r\nif (!err && codec->patch_ops.build_controls)\r\nerr = codec->patch_ops.build_controls(codec);\r\nif (err < 0)\r\nreturn err;\r\nerr = add_std_chmaps(codec);\r\nif (err < 0)\r\nreturn err;\r\nif (codec->jackpoll_interval)\r\nhda_jackpoll_work(&codec->jackpoll_work.work);\r\nelse\r\nsnd_hda_jack_report_sync(codec);\r\nsync_power_up_states(codec);\r\nreturn 0;\r\n}\r\nunsigned int snd_hda_calc_stream_format(struct hda_codec *codec,\r\nunsigned int rate,\r\nunsigned int channels,\r\nunsigned int format,\r\nunsigned int maxbps,\r\nunsigned short spdif_ctls)\r\n{\r\nint i;\r\nunsigned int val = 0;\r\nfor (i = 0; rate_bits[i].hz; i++)\r\nif (rate_bits[i].hz == rate) {\r\nval = rate_bits[i].hda_fmt;\r\nbreak;\r\n}\r\nif (!rate_bits[i].hz) {\r\ncodec_dbg(codec, "invalid rate %d\n", rate);\r\nreturn 0;\r\n}\r\nif (channels == 0 || channels > 8) {\r\ncodec_dbg(codec, "invalid channels %d\n", channels);\r\nreturn 0;\r\n}\r\nval |= channels - 1;\r\nswitch (snd_pcm_format_width(format)) {\r\ncase 8:\r\nval |= AC_FMT_BITS_8;\r\nbreak;\r\ncase 16:\r\nval |= AC_FMT_BITS_16;\r\nbreak;\r\ncase 20:\r\ncase 24:\r\ncase 32:\r\nif (maxbps >= 32 || format == SNDRV_PCM_FORMAT_FLOAT_LE)\r\nval |= AC_FMT_BITS_32;\r\nelse if (maxbps >= 24)\r\nval |= AC_FMT_BITS_24;\r\nelse\r\nval |= AC_FMT_BITS_20;\r\nbreak;\r\ndefault:\r\ncodec_dbg(codec, "invalid format width %d\n",\r\nsnd_pcm_format_width(format));\r\nreturn 0;\r\n}\r\nif (spdif_ctls & AC_DIG1_NONAUDIO)\r\nval |= AC_FMT_TYPE_NON_PCM;\r\nreturn val;\r\n}\r\nstatic unsigned int get_pcm_param(struct hda_codec *codec, hda_nid_t nid,\r\nint dir)\r\n{\r\nunsigned int val = 0;\r\nif (nid != codec->afg &&\r\n(get_wcaps(codec, nid) & AC_WCAP_FORMAT_OVRD))\r\nval = snd_hda_param_read(codec, nid, AC_PAR_PCM);\r\nif (!val || val == -1)\r\nval = snd_hda_param_read(codec, codec->afg, AC_PAR_PCM);\r\nif (!val || val == -1)\r\nreturn 0;\r\nreturn val;\r\n}\r\nstatic unsigned int query_pcm_param(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nreturn query_caps_hash(codec, nid, 0, HDA_HASH_PARPCM_KEY(nid),\r\nget_pcm_param);\r\n}\r\nstatic unsigned int get_stream_param(struct hda_codec *codec, hda_nid_t nid,\r\nint dir)\r\n{\r\nunsigned int streams = snd_hda_param_read(codec, nid, AC_PAR_STREAM);\r\nif (!streams || streams == -1)\r\nstreams = snd_hda_param_read(codec, codec->afg, AC_PAR_STREAM);\r\nif (!streams || streams == -1)\r\nreturn 0;\r\nreturn streams;\r\n}\r\nstatic unsigned int query_stream_param(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nreturn query_caps_hash(codec, nid, 0, HDA_HASH_PARSTR_KEY(nid),\r\nget_stream_param);\r\n}\r\nint snd_hda_query_supported_pcm(struct hda_codec *codec, hda_nid_t nid,\r\nu32 *ratesp, u64 *formatsp, unsigned int *bpsp)\r\n{\r\nunsigned int i, val, wcaps;\r\nwcaps = get_wcaps(codec, nid);\r\nval = query_pcm_param(codec, nid);\r\nif (ratesp) {\r\nu32 rates = 0;\r\nfor (i = 0; i < AC_PAR_PCM_RATE_BITS; i++) {\r\nif (val & (1 << i))\r\nrates |= rate_bits[i].alsa_bits;\r\n}\r\nif (rates == 0) {\r\ncodec_err(codec,\r\n"rates == 0 (nid=0x%x, val=0x%x, ovrd=%i)\n",\r\nnid, val,\r\n(wcaps & AC_WCAP_FORMAT_OVRD) ? 1 : 0);\r\nreturn -EIO;\r\n}\r\n*ratesp = rates;\r\n}\r\nif (formatsp || bpsp) {\r\nu64 formats = 0;\r\nunsigned int streams, bps;\r\nstreams = query_stream_param(codec, nid);\r\nif (!streams)\r\nreturn -EIO;\r\nbps = 0;\r\nif (streams & AC_SUPFMT_PCM) {\r\nif (val & AC_SUPPCM_BITS_8) {\r\nformats |= SNDRV_PCM_FMTBIT_U8;\r\nbps = 8;\r\n}\r\nif (val & AC_SUPPCM_BITS_16) {\r\nformats |= SNDRV_PCM_FMTBIT_S16_LE;\r\nbps = 16;\r\n}\r\nif (wcaps & AC_WCAP_DIGITAL) {\r\nif (val & AC_SUPPCM_BITS_32)\r\nformats |= SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE;\r\nif (val & (AC_SUPPCM_BITS_20|AC_SUPPCM_BITS_24))\r\nformats |= SNDRV_PCM_FMTBIT_S32_LE;\r\nif (val & AC_SUPPCM_BITS_24)\r\nbps = 24;\r\nelse if (val & AC_SUPPCM_BITS_20)\r\nbps = 20;\r\n} else if (val & (AC_SUPPCM_BITS_20|AC_SUPPCM_BITS_24|\r\nAC_SUPPCM_BITS_32)) {\r\nformats |= SNDRV_PCM_FMTBIT_S32_LE;\r\nif (val & AC_SUPPCM_BITS_32)\r\nbps = 32;\r\nelse if (val & AC_SUPPCM_BITS_24)\r\nbps = 24;\r\nelse if (val & AC_SUPPCM_BITS_20)\r\nbps = 20;\r\n}\r\n}\r\n#if 0\r\nif (streams & AC_SUPFMT_FLOAT32) {\r\nformats |= SNDRV_PCM_FMTBIT_FLOAT_LE;\r\nif (!bps)\r\nbps = 32;\r\n}\r\n#endif\r\nif (streams == AC_SUPFMT_AC3) {\r\nformats |= SNDRV_PCM_FMTBIT_U8;\r\nbps = 8;\r\n}\r\nif (formats == 0) {\r\ncodec_err(codec,\r\n"formats == 0 (nid=0x%x, val=0x%x, ovrd=%i, streams=0x%x)\n",\r\nnid, val,\r\n(wcaps & AC_WCAP_FORMAT_OVRD) ? 1 : 0,\r\nstreams);\r\nreturn -EIO;\r\n}\r\nif (formatsp)\r\n*formatsp = formats;\r\nif (bpsp)\r\n*bpsp = bps;\r\n}\r\nreturn 0;\r\n}\r\nint snd_hda_is_supported_format(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned int format)\r\n{\r\nint i;\r\nunsigned int val = 0, rate, stream;\r\nval = query_pcm_param(codec, nid);\r\nif (!val)\r\nreturn 0;\r\nrate = format & 0xff00;\r\nfor (i = 0; i < AC_PAR_PCM_RATE_BITS; i++)\r\nif (rate_bits[i].hda_fmt == rate) {\r\nif (val & (1 << i))\r\nbreak;\r\nreturn 0;\r\n}\r\nif (i >= AC_PAR_PCM_RATE_BITS)\r\nreturn 0;\r\nstream = query_stream_param(codec, nid);\r\nif (!stream)\r\nreturn 0;\r\nif (stream & AC_SUPFMT_PCM) {\r\nswitch (format & 0xf0) {\r\ncase 0x00:\r\nif (!(val & AC_SUPPCM_BITS_8))\r\nreturn 0;\r\nbreak;\r\ncase 0x10:\r\nif (!(val & AC_SUPPCM_BITS_16))\r\nreturn 0;\r\nbreak;\r\ncase 0x20:\r\nif (!(val & AC_SUPPCM_BITS_20))\r\nreturn 0;\r\nbreak;\r\ncase 0x30:\r\nif (!(val & AC_SUPPCM_BITS_24))\r\nreturn 0;\r\nbreak;\r\ncase 0x40:\r\nif (!(val & AC_SUPPCM_BITS_32))\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\n} else {\r\n}\r\nreturn 1;\r\n}\r\nstatic int hda_pcm_default_open_close(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic int hda_pcm_default_prepare(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nsnd_hda_codec_setup_stream(codec, hinfo->nid, stream_tag, 0, format);\r\nreturn 0;\r\n}\r\nstatic int hda_pcm_default_cleanup(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nsnd_hda_codec_cleanup_stream(codec, hinfo->nid);\r\nreturn 0;\r\n}\r\nstatic int set_pcm_default_values(struct hda_codec *codec,\r\nstruct hda_pcm_stream *info)\r\n{\r\nint err;\r\nif (info->nid && (!info->rates || !info->formats)) {\r\nerr = snd_hda_query_supported_pcm(codec, info->nid,\r\ninfo->rates ? NULL : &info->rates,\r\ninfo->formats ? NULL : &info->formats,\r\ninfo->maxbps ? NULL : &info->maxbps);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (info->ops.open == NULL)\r\ninfo->ops.open = hda_pcm_default_open_close;\r\nif (info->ops.close == NULL)\r\ninfo->ops.close = hda_pcm_default_open_close;\r\nif (info->ops.prepare == NULL) {\r\nif (snd_BUG_ON(!info->nid))\r\nreturn -EINVAL;\r\ninfo->ops.prepare = hda_pcm_default_prepare;\r\n}\r\nif (info->ops.cleanup == NULL) {\r\nif (snd_BUG_ON(!info->nid))\r\nreturn -EINVAL;\r\ninfo->ops.cleanup = hda_pcm_default_cleanup;\r\n}\r\nreturn 0;\r\n}\r\nint snd_hda_codec_prepare(struct hda_codec *codec,\r\nstruct hda_pcm_stream *hinfo,\r\nunsigned int stream,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nint ret;\r\nmutex_lock(&codec->bus->prepare_mutex);\r\nret = hinfo->ops.prepare(hinfo, codec, stream, format, substream);\r\nif (ret >= 0)\r\npurify_inactive_streams(codec);\r\nmutex_unlock(&codec->bus->prepare_mutex);\r\nreturn ret;\r\n}\r\nvoid snd_hda_codec_cleanup(struct hda_codec *codec,\r\nstruct hda_pcm_stream *hinfo,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nmutex_lock(&codec->bus->prepare_mutex);\r\nhinfo->ops.cleanup(hinfo, codec, substream);\r\nmutex_unlock(&codec->bus->prepare_mutex);\r\n}\r\nstatic int get_empty_pcm_device(struct hda_bus *bus, unsigned int type)\r\n{\r\nstatic int audio_idx[HDA_PCM_NTYPES][5] = {\r\n[HDA_PCM_TYPE_AUDIO] = { 0, 2, 4, 5, -1 },\r\n[HDA_PCM_TYPE_SPDIF] = { 1, -1 },\r\n[HDA_PCM_TYPE_HDMI] = { 3, 7, 8, 9, -1 },\r\n[HDA_PCM_TYPE_MODEM] = { 6, -1 },\r\n};\r\nint i;\r\nif (type >= HDA_PCM_NTYPES) {\r\ndev_err(bus->card->dev, "Invalid PCM type %d\n", type);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; audio_idx[type][i] >= 0; i++) {\r\n#ifndef CONFIG_SND_DYNAMIC_MINORS\r\nif (audio_idx[type][i] >= 8)\r\nbreak;\r\n#endif\r\nif (!test_and_set_bit(audio_idx[type][i], bus->pcm_dev_bits))\r\nreturn audio_idx[type][i];\r\n}\r\n#ifdef CONFIG_SND_DYNAMIC_MINORS\r\nfor (i = 10; i < 32; i++) {\r\nif (!test_and_set_bit(i, bus->pcm_dev_bits))\r\nreturn i;\r\n}\r\n#endif\r\ndev_warn(bus->card->dev, "Too many %s devices\n",\r\nsnd_hda_pcm_type_name[type]);\r\n#ifndef CONFIG_SND_DYNAMIC_MINORS\r\ndev_warn(bus->card->dev,\r\n"Consider building the kernel with CONFIG_SND_DYNAMIC_MINORS=y\n");\r\n#endif\r\nreturn -EAGAIN;\r\n}\r\nstatic int snd_hda_attach_pcm(struct hda_codec *codec, struct hda_pcm *pcm)\r\n{\r\nstruct hda_bus *bus = codec->bus;\r\nstruct hda_pcm_stream *info;\r\nint stream, err;\r\nif (snd_BUG_ON(!pcm->name))\r\nreturn -EINVAL;\r\nfor (stream = 0; stream < 2; stream++) {\r\ninfo = &pcm->stream[stream];\r\nif (info->substreams) {\r\nerr = set_pcm_default_values(codec, info);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nreturn bus->ops.attach_pcm(bus, codec, pcm);\r\n}\r\nint snd_hda_codec_build_pcms(struct hda_codec *codec)\r\n{\r\nunsigned int pcm;\r\nint err;\r\nif (!codec->num_pcms) {\r\nif (!codec->patch_ops.build_pcms)\r\nreturn 0;\r\nerr = codec->patch_ops.build_pcms(codec);\r\nif (err < 0) {\r\ncodec_err(codec,\r\n"cannot build PCMs for #%d (error %d)\n",\r\ncodec->addr, err);\r\nerr = snd_hda_codec_reset(codec);\r\nif (err < 0) {\r\ncodec_err(codec,\r\n"cannot revert codec\n");\r\nreturn err;\r\n}\r\n}\r\n}\r\nfor (pcm = 0; pcm < codec->num_pcms; pcm++) {\r\nstruct hda_pcm *cpcm = &codec->pcm_info[pcm];\r\nint dev;\r\nif (!cpcm->stream[0].substreams && !cpcm->stream[1].substreams)\r\ncontinue;\r\nif (!cpcm->pcm) {\r\ndev = get_empty_pcm_device(codec->bus, cpcm->pcm_type);\r\nif (dev < 0)\r\ncontinue;\r\ncpcm->device = dev;\r\nerr = snd_hda_attach_pcm(codec, cpcm);\r\nif (err < 0) {\r\ncodec_err(codec,\r\n"cannot attach PCM stream %d for codec #%d\n",\r\ndev, codec->addr);\r\ncontinue;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint snd_hda_build_pcms(struct hda_bus *bus)\r\n{\r\nstruct hda_codec *codec;\r\nlist_for_each_entry(codec, &bus->codec_list, list) {\r\nint err = snd_hda_codec_build_pcms(codec);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint snd_hda_add_new_ctls(struct hda_codec *codec,\r\nconst struct snd_kcontrol_new *knew)\r\n{\r\nint err;\r\nfor (; knew->name; knew++) {\r\nstruct snd_kcontrol *kctl;\r\nint addr = 0, idx = 0;\r\nif (knew->iface == -1)\r\ncontinue;\r\nfor (;;) {\r\nkctl = snd_ctl_new1(knew, codec);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nif (addr > 0)\r\nkctl->id.device = addr;\r\nif (idx > 0)\r\nkctl->id.index = idx;\r\nerr = snd_hda_ctl_add(codec, 0, kctl);\r\nif (!err)\r\nbreak;\r\nif (!addr && codec->addr)\r\naddr = codec->addr;\r\nelse if (!idx && !knew->index) {\r\nidx = find_empty_mixer_ctl_idx(codec,\r\nknew->name, 0);\r\nif (idx <= 0)\r\nreturn err;\r\n} else\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void hda_power_work(struct work_struct *work)\r\n{\r\nstruct hda_codec *codec =\r\ncontainer_of(work, struct hda_codec, power_work.work);\r\nstruct hda_bus *bus = codec->bus;\r\nunsigned int state;\r\nspin_lock(&codec->power_lock);\r\nif (codec->power_transition > 0) {\r\nspin_unlock(&codec->power_lock);\r\nreturn;\r\n}\r\nif (!codec->power_on || codec->power_count) {\r\ncodec->power_transition = 0;\r\nspin_unlock(&codec->power_lock);\r\nreturn;\r\n}\r\nspin_unlock(&codec->power_lock);\r\nstate = hda_call_codec_suspend(codec, true);\r\nif (!bus->power_keep_link_on && (state & AC_PWRST_CLK_STOP_OK))\r\nhda_call_pm_notify(codec, false);\r\n}\r\nstatic void hda_keep_power_on(struct hda_codec *codec)\r\n{\r\nspin_lock(&codec->power_lock);\r\ncodec->power_count++;\r\ncodec->power_on = 1;\r\ncodec->power_jiffies = jiffies;\r\nspin_unlock(&codec->power_lock);\r\nhda_call_pm_notify(codec, true);\r\n}\r\nvoid snd_hda_update_power_acct(struct hda_codec *codec)\r\n{\r\nunsigned long delta = jiffies - codec->power_jiffies;\r\nif (codec->power_on)\r\ncodec->power_on_acct += delta;\r\nelse\r\ncodec->power_off_acct += delta;\r\ncodec->power_jiffies += delta;\r\n}\r\nstatic void __snd_hda_power_up(struct hda_codec *codec, bool wait_power_down)\r\n{\r\nif ((codec->power_on || codec->power_transition > 0) &&\r\n!(wait_power_down && codec->power_transition < 0))\r\nreturn;\r\nspin_unlock(&codec->power_lock);\r\ncancel_delayed_work_sync(&codec->power_work);\r\nspin_lock(&codec->power_lock);\r\nif (codec->power_on) {\r\nif (codec->power_transition < 0)\r\ncodec->power_transition = 0;\r\nreturn;\r\n}\r\ntrace_hda_power_up(codec);\r\nsnd_hda_update_power_acct(codec);\r\ncodec->power_on = 1;\r\ncodec->power_jiffies = jiffies;\r\ncodec->power_transition = 1;\r\nspin_unlock(&codec->power_lock);\r\nhda_call_codec_resume(codec);\r\nspin_lock(&codec->power_lock);\r\ncodec->power_transition = 0;\r\n}\r\nstatic void __snd_hda_power_down(struct hda_codec *codec)\r\n{\r\nif (!codec->power_on || codec->power_count || codec->power_transition)\r\nreturn;\r\nif (power_save(codec)) {\r\ncodec->power_transition = -1;\r\nqueue_delayed_work(codec->bus->workq, &codec->power_work,\r\nmsecs_to_jiffies(power_save(codec) * 1000));\r\n}\r\n}\r\nvoid snd_hda_power_save(struct hda_codec *codec, int delta, bool d3wait)\r\n{\r\nspin_lock(&codec->power_lock);\r\ncodec->power_count += delta;\r\ntrace_hda_power_count(codec);\r\nif (delta > 0)\r\n__snd_hda_power_up(codec, d3wait);\r\nelse\r\n__snd_hda_power_down(codec);\r\nspin_unlock(&codec->power_lock);\r\n}\r\nint snd_hda_check_amp_list_power(struct hda_codec *codec,\r\nstruct hda_loopback_check *check,\r\nhda_nid_t nid)\r\n{\r\nconst struct hda_amp_list *p;\r\nint ch, v;\r\nif (!check->amplist)\r\nreturn 0;\r\nfor (p = check->amplist; p->nid; p++) {\r\nif (p->nid == nid)\r\nbreak;\r\n}\r\nif (!p->nid)\r\nreturn 0;\r\nfor (p = check->amplist; p->nid; p++) {\r\nfor (ch = 0; ch < 2; ch++) {\r\nv = snd_hda_codec_amp_read(codec, p->nid, ch, p->dir,\r\np->idx);\r\nif (!(v & HDA_AMP_MUTE) && v > 0) {\r\nif (!check->power_on) {\r\ncheck->power_on = 1;\r\nsnd_hda_power_up(codec);\r\n}\r\nreturn 1;\r\n}\r\n}\r\n}\r\nif (check->power_on) {\r\ncheck->power_on = 0;\r\nsnd_hda_power_down(codec);\r\n}\r\nreturn 0;\r\n}\r\nint snd_hda_ch_mode_info(struct hda_codec *codec,\r\nstruct snd_ctl_elem_info *uinfo,\r\nconst struct hda_channel_mode *chmode,\r\nint num_chmodes)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = num_chmodes;\r\nif (uinfo->value.enumerated.item >= num_chmodes)\r\nuinfo->value.enumerated.item = num_chmodes - 1;\r\nsprintf(uinfo->value.enumerated.name, "%dch",\r\nchmode[uinfo->value.enumerated.item].channels);\r\nreturn 0;\r\n}\r\nint snd_hda_ch_mode_get(struct hda_codec *codec,\r\nstruct snd_ctl_elem_value *ucontrol,\r\nconst struct hda_channel_mode *chmode,\r\nint num_chmodes,\r\nint max_channels)\r\n{\r\nint i;\r\nfor (i = 0; i < num_chmodes; i++) {\r\nif (max_channels == chmode[i].channels) {\r\nucontrol->value.enumerated.item[0] = i;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint snd_hda_ch_mode_put(struct hda_codec *codec,\r\nstruct snd_ctl_elem_value *ucontrol,\r\nconst struct hda_channel_mode *chmode,\r\nint num_chmodes,\r\nint *max_channelsp)\r\n{\r\nunsigned int mode;\r\nmode = ucontrol->value.enumerated.item[0];\r\nif (mode >= num_chmodes)\r\nreturn -EINVAL;\r\nif (*max_channelsp == chmode[mode].channels)\r\nreturn 0;\r\n*max_channelsp = chmode[mode].channels;\r\nif (chmode[mode].sequence)\r\nsnd_hda_sequence_write_cache(codec, chmode[mode].sequence);\r\nreturn 1;\r\n}\r\nint snd_hda_input_mux_info(const struct hda_input_mux *imux,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nunsigned int index;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = imux->num_items;\r\nif (!imux->num_items)\r\nreturn 0;\r\nindex = uinfo->value.enumerated.item;\r\nif (index >= imux->num_items)\r\nindex = imux->num_items - 1;\r\nstrcpy(uinfo->value.enumerated.name, imux->items[index].label);\r\nreturn 0;\r\n}\r\nint snd_hda_input_mux_put(struct hda_codec *codec,\r\nconst struct hda_input_mux *imux,\r\nstruct snd_ctl_elem_value *ucontrol,\r\nhda_nid_t nid,\r\nunsigned int *cur_val)\r\n{\r\nunsigned int idx;\r\nif (!imux->num_items)\r\nreturn 0;\r\nidx = ucontrol->value.enumerated.item[0];\r\nif (idx >= imux->num_items)\r\nidx = imux->num_items - 1;\r\nif (*cur_val == idx)\r\nreturn 0;\r\nsnd_hda_codec_write_cache(codec, nid, 0, AC_VERB_SET_CONNECT_SEL,\r\nimux->items[idx].index);\r\n*cur_val = idx;\r\nreturn 1;\r\n}\r\nint snd_hda_enum_helper_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo,\r\nint num_items, const char * const *texts)\r\n{\r\nstatic const char * const texts_default[] = {\r\n"Disabled", "Enabled"\r\n};\r\nif (!texts || !num_items) {\r\nnum_items = 2;\r\ntexts = texts_default;\r\n}\r\nreturn snd_ctl_enum_info(uinfo, 1, num_items, texts);\r\n}\r\nstatic void setup_dig_out_stream(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned int stream_tag, unsigned int format)\r\n{\r\nstruct hda_spdif_out *spdif;\r\nunsigned int curr_fmt;\r\nbool reset;\r\nspdif = snd_hda_spdif_out_of_nid(codec, nid);\r\ncurr_fmt = snd_hda_codec_read(codec, nid, 0,\r\nAC_VERB_GET_STREAM_FORMAT, 0);\r\nreset = codec->spdif_status_reset &&\r\n(spdif->ctls & AC_DIG1_ENABLE) &&\r\ncurr_fmt != format;\r\nif (reset)\r\nset_dig_out_convert(codec, nid,\r\nspdif->ctls & ~AC_DIG1_ENABLE & 0xff,\r\n-1);\r\nsnd_hda_codec_setup_stream(codec, nid, stream_tag, 0, format);\r\nif (codec->slave_dig_outs) {\r\nconst hda_nid_t *d;\r\nfor (d = codec->slave_dig_outs; *d; d++)\r\nsnd_hda_codec_setup_stream(codec, *d, stream_tag, 0,\r\nformat);\r\n}\r\nif (reset)\r\nset_dig_out_convert(codec, nid,\r\nspdif->ctls & 0xff, -1);\r\n}\r\nstatic void cleanup_dig_out_stream(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nsnd_hda_codec_cleanup_stream(codec, nid);\r\nif (codec->slave_dig_outs) {\r\nconst hda_nid_t *d;\r\nfor (d = codec->slave_dig_outs; *d; d++)\r\nsnd_hda_codec_cleanup_stream(codec, *d);\r\n}\r\n}\r\nvoid snd_hda_bus_reboot_notify(struct hda_bus *bus)\r\n{\r\nstruct hda_codec *codec;\r\nif (!bus)\r\nreturn;\r\nlist_for_each_entry(codec, &bus->codec_list, list) {\r\nif (hda_codec_is_power_on(codec) &&\r\ncodec->patch_ops.reboot_notify)\r\ncodec->patch_ops.reboot_notify(codec);\r\n}\r\n}\r\nint snd_hda_multi_out_dig_open(struct hda_codec *codec,\r\nstruct hda_multi_out *mout)\r\n{\r\nmutex_lock(&codec->spdif_mutex);\r\nif (mout->dig_out_used == HDA_DIG_ANALOG_DUP)\r\ncleanup_dig_out_stream(codec, mout->dig_out_nid);\r\nmout->dig_out_used = HDA_DIG_EXCLUSIVE;\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn 0;\r\n}\r\nint snd_hda_multi_out_dig_prepare(struct hda_codec *codec,\r\nstruct hda_multi_out *mout,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nmutex_lock(&codec->spdif_mutex);\r\nsetup_dig_out_stream(codec, mout->dig_out_nid, stream_tag, format);\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn 0;\r\n}\r\nint snd_hda_multi_out_dig_cleanup(struct hda_codec *codec,\r\nstruct hda_multi_out *mout)\r\n{\r\nmutex_lock(&codec->spdif_mutex);\r\ncleanup_dig_out_stream(codec, mout->dig_out_nid);\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn 0;\r\n}\r\nint snd_hda_multi_out_dig_close(struct hda_codec *codec,\r\nstruct hda_multi_out *mout)\r\n{\r\nmutex_lock(&codec->spdif_mutex);\r\nmout->dig_out_used = 0;\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn 0;\r\n}\r\nint snd_hda_multi_out_analog_open(struct hda_codec *codec,\r\nstruct hda_multi_out *mout,\r\nstruct snd_pcm_substream *substream,\r\nstruct hda_pcm_stream *hinfo)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nruntime->hw.channels_max = mout->max_channels;\r\nif (mout->dig_out_nid) {\r\nif (!mout->analog_rates) {\r\nmout->analog_rates = hinfo->rates;\r\nmout->analog_formats = hinfo->formats;\r\nmout->analog_maxbps = hinfo->maxbps;\r\n} else {\r\nruntime->hw.rates = mout->analog_rates;\r\nruntime->hw.formats = mout->analog_formats;\r\nhinfo->maxbps = mout->analog_maxbps;\r\n}\r\nif (!mout->spdif_rates) {\r\nsnd_hda_query_supported_pcm(codec, mout->dig_out_nid,\r\n&mout->spdif_rates,\r\n&mout->spdif_formats,\r\n&mout->spdif_maxbps);\r\n}\r\nmutex_lock(&codec->spdif_mutex);\r\nif (mout->share_spdif) {\r\nif ((runtime->hw.rates & mout->spdif_rates) &&\r\n(runtime->hw.formats & mout->spdif_formats)) {\r\nruntime->hw.rates &= mout->spdif_rates;\r\nruntime->hw.formats &= mout->spdif_formats;\r\nif (mout->spdif_maxbps < hinfo->maxbps)\r\nhinfo->maxbps = mout->spdif_maxbps;\r\n} else {\r\nmout->share_spdif = 0;\r\n}\r\n}\r\nmutex_unlock(&codec->spdif_mutex);\r\n}\r\nreturn snd_pcm_hw_constraint_step(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, 2);\r\n}\r\nint snd_hda_multi_out_analog_prepare(struct hda_codec *codec,\r\nstruct hda_multi_out *mout,\r\nunsigned int stream_tag,\r\nunsigned int format,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nconst hda_nid_t *nids = mout->dac_nids;\r\nint chs = substream->runtime->channels;\r\nstruct hda_spdif_out *spdif;\r\nint i;\r\nmutex_lock(&codec->spdif_mutex);\r\nspdif = snd_hda_spdif_out_of_nid(codec, mout->dig_out_nid);\r\nif (mout->dig_out_nid && mout->share_spdif &&\r\nmout->dig_out_used != HDA_DIG_EXCLUSIVE) {\r\nif (chs == 2 &&\r\nsnd_hda_is_supported_format(codec, mout->dig_out_nid,\r\nformat) &&\r\n!(spdif->status & IEC958_AES0_NONAUDIO)) {\r\nmout->dig_out_used = HDA_DIG_ANALOG_DUP;\r\nsetup_dig_out_stream(codec, mout->dig_out_nid,\r\nstream_tag, format);\r\n} else {\r\nmout->dig_out_used = 0;\r\ncleanup_dig_out_stream(codec, mout->dig_out_nid);\r\n}\r\n}\r\nmutex_unlock(&codec->spdif_mutex);\r\nsnd_hda_codec_setup_stream(codec, nids[HDA_FRONT], stream_tag,\r\n0, format);\r\nif (!mout->no_share_stream &&\r\nmout->hp_nid && mout->hp_nid != nids[HDA_FRONT])\r\nsnd_hda_codec_setup_stream(codec, mout->hp_nid, stream_tag,\r\n0, format);\r\nfor (i = 0; i < ARRAY_SIZE(mout->hp_out_nid); i++)\r\nif (!mout->no_share_stream && mout->hp_out_nid[i])\r\nsnd_hda_codec_setup_stream(codec,\r\nmout->hp_out_nid[i],\r\nstream_tag, 0, format);\r\nfor (i = 1; i < mout->num_dacs; i++) {\r\nif (chs >= (i + 1) * 2)\r\nsnd_hda_codec_setup_stream(codec, nids[i], stream_tag,\r\ni * 2, format);\r\nelse if (!mout->no_share_stream)\r\nsnd_hda_codec_setup_stream(codec, nids[i], stream_tag,\r\n0, format);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(mout->extra_out_nid); i++) {\r\nint ch = 0;\r\nif (!mout->extra_out_nid[i])\r\nbreak;\r\nif (chs >= (i + 1) * 2)\r\nch = i * 2;\r\nelse if (!mout->no_share_stream)\r\nbreak;\r\nsnd_hda_codec_setup_stream(codec, mout->extra_out_nid[i],\r\nstream_tag, ch, format);\r\n}\r\nreturn 0;\r\n}\r\nint snd_hda_multi_out_analog_cleanup(struct hda_codec *codec,\r\nstruct hda_multi_out *mout)\r\n{\r\nconst hda_nid_t *nids = mout->dac_nids;\r\nint i;\r\nfor (i = 0; i < mout->num_dacs; i++)\r\nsnd_hda_codec_cleanup_stream(codec, nids[i]);\r\nif (mout->hp_nid)\r\nsnd_hda_codec_cleanup_stream(codec, mout->hp_nid);\r\nfor (i = 0; i < ARRAY_SIZE(mout->hp_out_nid); i++)\r\nif (mout->hp_out_nid[i])\r\nsnd_hda_codec_cleanup_stream(codec,\r\nmout->hp_out_nid[i]);\r\nfor (i = 0; i < ARRAY_SIZE(mout->extra_out_nid); i++)\r\nif (mout->extra_out_nid[i])\r\nsnd_hda_codec_cleanup_stream(codec,\r\nmout->extra_out_nid[i]);\r\nmutex_lock(&codec->spdif_mutex);\r\nif (mout->dig_out_nid && mout->dig_out_used == HDA_DIG_ANALOG_DUP) {\r\ncleanup_dig_out_stream(codec, mout->dig_out_nid);\r\nmout->dig_out_used = 0;\r\n}\r\nmutex_unlock(&codec->spdif_mutex);\r\nreturn 0;\r\n}\r\nunsigned int snd_hda_get_default_vref(struct hda_codec *codec, hda_nid_t pin)\r\n{\r\nunsigned int pincap;\r\nunsigned int oldval;\r\noldval = snd_hda_codec_read(codec, pin, 0,\r\nAC_VERB_GET_PIN_WIDGET_CONTROL, 0);\r\npincap = snd_hda_query_pin_caps(codec, pin);\r\npincap = (pincap & AC_PINCAP_VREF) >> AC_PINCAP_VREF_SHIFT;\r\nif ((pincap & AC_PINCAP_VREF_80) && oldval != PIN_VREF50)\r\nreturn AC_PINCTL_VREF_80;\r\nelse if (pincap & AC_PINCAP_VREF_50)\r\nreturn AC_PINCTL_VREF_50;\r\nelse if (pincap & AC_PINCAP_VREF_100)\r\nreturn AC_PINCTL_VREF_100;\r\nelse if (pincap & AC_PINCAP_VREF_GRD)\r\nreturn AC_PINCTL_VREF_GRD;\r\nreturn AC_PINCTL_VREF_HIZ;\r\n}\r\nunsigned int snd_hda_correct_pin_ctl(struct hda_codec *codec,\r\nhda_nid_t pin, unsigned int val)\r\n{\r\nstatic unsigned int cap_lists[][2] = {\r\n{ AC_PINCTL_VREF_100, AC_PINCAP_VREF_100 },\r\n{ AC_PINCTL_VREF_80, AC_PINCAP_VREF_80 },\r\n{ AC_PINCTL_VREF_50, AC_PINCAP_VREF_50 },\r\n{ AC_PINCTL_VREF_GRD, AC_PINCAP_VREF_GRD },\r\n};\r\nunsigned int cap;\r\nif (!val)\r\nreturn 0;\r\ncap = snd_hda_query_pin_caps(codec, pin);\r\nif (!cap)\r\nreturn val;\r\nif (val & AC_PINCTL_OUT_EN) {\r\nif (!(cap & AC_PINCAP_OUT))\r\nval &= ~(AC_PINCTL_OUT_EN | AC_PINCTL_HP_EN);\r\nelse if ((val & AC_PINCTL_HP_EN) && !(cap & AC_PINCAP_HP_DRV))\r\nval &= ~AC_PINCTL_HP_EN;\r\n}\r\nif (val & AC_PINCTL_IN_EN) {\r\nif (!(cap & AC_PINCAP_IN))\r\nval &= ~(AC_PINCTL_IN_EN | AC_PINCTL_VREFEN);\r\nelse {\r\nunsigned int vcap, vref;\r\nint i;\r\nvcap = (cap & AC_PINCAP_VREF) >> AC_PINCAP_VREF_SHIFT;\r\nvref = val & AC_PINCTL_VREFEN;\r\nfor (i = 0; i < ARRAY_SIZE(cap_lists); i++) {\r\nif (vref == cap_lists[i][0] &&\r\n!(vcap & cap_lists[i][1])) {\r\nif (i == ARRAY_SIZE(cap_lists) - 1)\r\nvref = AC_PINCTL_VREF_HIZ;\r\nelse\r\nvref = cap_lists[i + 1][0];\r\n}\r\n}\r\nval &= ~AC_PINCTL_VREFEN;\r\nval |= vref;\r\n}\r\n}\r\nreturn val;\r\n}\r\nint _snd_hda_set_pin_ctl(struct hda_codec *codec, hda_nid_t pin,\r\nunsigned int val, bool cached)\r\n{\r\nval = snd_hda_correct_pin_ctl(codec, pin, val);\r\nsnd_hda_codec_set_pin_target(codec, pin, val);\r\nif (cached)\r\nreturn snd_hda_codec_update_cache(codec, pin, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL, val);\r\nelse\r\nreturn snd_hda_codec_write(codec, pin, 0,\r\nAC_VERB_SET_PIN_WIDGET_CONTROL, val);\r\n}\r\nint snd_hda_add_imux_item(struct hda_codec *codec,\r\nstruct hda_input_mux *imux, const char *label,\r\nint index, int *type_idx)\r\n{\r\nint i, label_idx = 0;\r\nif (imux->num_items >= HDA_MAX_NUM_INPUTS) {\r\ncodec_err(codec, "hda_codec: Too many imux items!\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < imux->num_items; i++) {\r\nif (!strncmp(label, imux->items[i].label, strlen(label)))\r\nlabel_idx++;\r\n}\r\nif (type_idx)\r\n*type_idx = label_idx;\r\nif (label_idx > 0)\r\nsnprintf(imux->items[imux->num_items].label,\r\nsizeof(imux->items[imux->num_items].label),\r\n"%s %d", label, label_idx);\r\nelse\r\nstrlcpy(imux->items[imux->num_items].label, label,\r\nsizeof(imux->items[imux->num_items].label));\r\nimux->items[imux->num_items].index = index;\r\nimux->num_items++;\r\nreturn 0;\r\n}\r\nstatic void hda_async_suspend(void *data, async_cookie_t cookie)\r\n{\r\nhda_call_codec_suspend(data, false);\r\n}\r\nstatic void hda_async_resume(void *data, async_cookie_t cookie)\r\n{\r\nhda_call_codec_resume(data);\r\n}\r\nint snd_hda_suspend(struct hda_bus *bus)\r\n{\r\nstruct hda_codec *codec;\r\nASYNC_DOMAIN_EXCLUSIVE(domain);\r\nlist_for_each_entry(codec, &bus->codec_list, list) {\r\ncancel_delayed_work_sync(&codec->jackpoll_work);\r\nif (hda_codec_is_power_on(codec)) {\r\nif (bus->num_codecs > 1)\r\nasync_schedule_domain(hda_async_suspend, codec,\r\n&domain);\r\nelse\r\nhda_call_codec_suspend(codec, false);\r\n}\r\n}\r\nif (bus->num_codecs > 1)\r\nasync_synchronize_full_domain(&domain);\r\nreturn 0;\r\n}\r\nint snd_hda_resume(struct hda_bus *bus)\r\n{\r\nstruct hda_codec *codec;\r\nASYNC_DOMAIN_EXCLUSIVE(domain);\r\nlist_for_each_entry(codec, &bus->codec_list, list) {\r\nif (bus->num_codecs > 1)\r\nasync_schedule_domain(hda_async_resume, codec, &domain);\r\nelse\r\nhda_call_codec_resume(codec);\r\n}\r\nif (bus->num_codecs > 1)\r\nasync_synchronize_full_domain(&domain);\r\nreturn 0;\r\n}\r\nvoid *snd_array_new(struct snd_array *array)\r\n{\r\nif (snd_BUG_ON(!array->elem_size))\r\nreturn NULL;\r\nif (array->used >= array->alloced) {\r\nint num = array->alloced + array->alloc_align;\r\nint size = (num + 1) * array->elem_size;\r\nvoid *nlist;\r\nif (snd_BUG_ON(num >= 4096))\r\nreturn NULL;\r\nnlist = krealloc(array->list, size, GFP_KERNEL | __GFP_ZERO);\r\nif (!nlist)\r\nreturn NULL;\r\narray->list = nlist;\r\narray->alloced = num;\r\n}\r\nreturn snd_array_elem(array, array->used++);\r\n}\r\nvoid snd_array_free(struct snd_array *array)\r\n{\r\nkfree(array->list);\r\narray->used = 0;\r\narray->alloced = 0;\r\narray->list = NULL;\r\n}\r\nvoid snd_print_pcm_bits(int pcm, char *buf, int buflen)\r\n{\r\nstatic unsigned int bits[] = { 8, 16, 20, 24, 32 };\r\nint i, j;\r\nfor (i = 0, j = 0; i < ARRAY_SIZE(bits); i++)\r\nif (pcm & (AC_SUPPCM_BITS_8 << i))\r\nj += snprintf(buf + j, buflen - j, " %d", bits[i]);\r\nbuf[j] = '\0';\r\n}
