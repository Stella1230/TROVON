static inline u32 mei_txe_reg_read(void __iomem *base_addr,\r\nunsigned long offset)\r\n{\r\nreturn ioread32(base_addr + offset);\r\n}\r\nstatic inline void mei_txe_reg_write(void __iomem *base_addr,\r\nunsigned long offset, u32 value)\r\n{\r\niowrite32(value, base_addr + offset);\r\n}\r\nstatic inline u32 mei_txe_sec_reg_read_silent(struct mei_txe_hw *hw,\r\nunsigned long offset)\r\n{\r\nreturn mei_txe_reg_read(hw->mem_addr[SEC_BAR], offset);\r\n}\r\nstatic inline u32 mei_txe_sec_reg_read(struct mei_txe_hw *hw,\r\nunsigned long offset)\r\n{\r\nWARN(!hw->aliveness, "sec read: aliveness not asserted\n");\r\nreturn mei_txe_sec_reg_read_silent(hw, offset);\r\n}\r\nstatic inline void mei_txe_sec_reg_write_silent(struct mei_txe_hw *hw,\r\nunsigned long offset, u32 value)\r\n{\r\nmei_txe_reg_write(hw->mem_addr[SEC_BAR], offset, value);\r\n}\r\nstatic inline void mei_txe_sec_reg_write(struct mei_txe_hw *hw,\r\nunsigned long offset, u32 value)\r\n{\r\nWARN(!hw->aliveness, "sec write: aliveness not asserted\n");\r\nmei_txe_sec_reg_write_silent(hw, offset, value);\r\n}\r\nstatic inline u32 mei_txe_br_reg_read(struct mei_txe_hw *hw,\r\nunsigned long offset)\r\n{\r\nreturn mei_txe_reg_read(hw->mem_addr[BRIDGE_BAR], offset);\r\n}\r\nstatic inline void mei_txe_br_reg_write(struct mei_txe_hw *hw,\r\nunsigned long offset, u32 value)\r\n{\r\nmei_txe_reg_write(hw->mem_addr[BRIDGE_BAR], offset, value);\r\n}\r\nstatic bool mei_txe_aliveness_set(struct mei_device *dev, u32 req)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nbool do_req = hw->aliveness != req;\r\ndev_dbg(dev->dev, "Aliveness current=%d request=%d\n",\r\nhw->aliveness, req);\r\nif (do_req) {\r\ndev->pg_event = MEI_PG_EVENT_WAIT;\r\nmei_txe_br_reg_write(hw, SICR_HOST_ALIVENESS_REQ_REG, req);\r\n}\r\nreturn do_req;\r\n}\r\nstatic u32 mei_txe_aliveness_req_get(struct mei_device *dev)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nu32 reg;\r\nreg = mei_txe_br_reg_read(hw, SICR_HOST_ALIVENESS_REQ_REG);\r\nreturn reg & SICR_HOST_ALIVENESS_REQ_REQUESTED;\r\n}\r\nstatic u32 mei_txe_aliveness_get(struct mei_device *dev)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nu32 reg;\r\nreg = mei_txe_br_reg_read(hw, HICR_HOST_ALIVENESS_RESP_REG);\r\nreturn reg & HICR_HOST_ALIVENESS_RESP_ACK;\r\n}\r\nstatic int mei_txe_aliveness_poll(struct mei_device *dev, u32 expected)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nint t = 0;\r\ndo {\r\nhw->aliveness = mei_txe_aliveness_get(dev);\r\nif (hw->aliveness == expected) {\r\ndev->pg_event = MEI_PG_EVENT_IDLE;\r\ndev_dbg(dev->dev,\r\n"aliveness settled after %d msecs\n", t);\r\nreturn t;\r\n}\r\nmutex_unlock(&dev->device_lock);\r\nmsleep(MSEC_PER_SEC / 5);\r\nmutex_lock(&dev->device_lock);\r\nt += MSEC_PER_SEC / 5;\r\n} while (t < SEC_ALIVENESS_WAIT_TIMEOUT);\r\ndev->pg_event = MEI_PG_EVENT_IDLE;\r\ndev_err(dev->dev, "aliveness timed out\n");\r\nreturn -ETIME;\r\n}\r\nstatic int mei_txe_aliveness_wait(struct mei_device *dev, u32 expected)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nconst unsigned long timeout =\r\nmsecs_to_jiffies(SEC_ALIVENESS_WAIT_TIMEOUT);\r\nlong err;\r\nint ret;\r\nhw->aliveness = mei_txe_aliveness_get(dev);\r\nif (hw->aliveness == expected)\r\nreturn 0;\r\nmutex_unlock(&dev->device_lock);\r\nerr = wait_event_timeout(hw->wait_aliveness_resp,\r\ndev->pg_event == MEI_PG_EVENT_RECEIVED, timeout);\r\nmutex_lock(&dev->device_lock);\r\nhw->aliveness = mei_txe_aliveness_get(dev);\r\nret = hw->aliveness == expected ? 0 : -ETIME;\r\nif (ret)\r\ndev_warn(dev->dev, "aliveness timed out = %ld aliveness = %d event = %d\n",\r\nerr, hw->aliveness, dev->pg_event);\r\nelse\r\ndev_dbg(dev->dev, "aliveness settled after = %d msec aliveness = %d event = %d\n",\r\njiffies_to_msecs(timeout - err),\r\nhw->aliveness, dev->pg_event);\r\ndev->pg_event = MEI_PG_EVENT_IDLE;\r\nreturn ret;\r\n}\r\nint mei_txe_aliveness_set_sync(struct mei_device *dev, u32 req)\r\n{\r\nif (mei_txe_aliveness_set(dev, req))\r\nreturn mei_txe_aliveness_wait(dev, req);\r\nreturn 0;\r\n}\r\nstatic bool mei_txe_pg_is_enabled(struct mei_device *dev)\r\n{\r\nreturn true;\r\n}\r\nstatic inline enum mei_pg_state mei_txe_pg_state(struct mei_device *dev)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nreturn hw->aliveness ? MEI_PG_OFF : MEI_PG_ON;\r\n}\r\nstatic void mei_txe_input_ready_interrupt_enable(struct mei_device *dev)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nu32 hintmsk;\r\nhintmsk = mei_txe_sec_reg_read(hw, SEC_IPC_HOST_INT_MASK_REG);\r\nhintmsk |= SEC_IPC_HOST_INT_MASK_IN_RDY;\r\nmei_txe_sec_reg_write(hw, SEC_IPC_HOST_INT_MASK_REG, hintmsk);\r\n}\r\nstatic void mei_txe_input_doorbell_set(struct mei_txe_hw *hw)\r\n{\r\nclear_bit(TXE_INTR_IN_READY_BIT, &hw->intr_cause);\r\nmei_txe_sec_reg_write(hw, SEC_IPC_INPUT_DOORBELL_REG, 1);\r\n}\r\nstatic void mei_txe_output_ready_set(struct mei_txe_hw *hw)\r\n{\r\nmei_txe_br_reg_write(hw,\r\nSICR_SEC_IPC_OUTPUT_STATUS_REG,\r\nSEC_IPC_OUTPUT_STATUS_RDY);\r\n}\r\nstatic bool mei_txe_is_input_ready(struct mei_device *dev)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nu32 status;\r\nstatus = mei_txe_sec_reg_read(hw, SEC_IPC_INPUT_STATUS_REG);\r\nreturn !!(SEC_IPC_INPUT_STATUS_RDY & status);\r\n}\r\nstatic inline void mei_txe_intr_clear(struct mei_device *dev)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nmei_txe_sec_reg_write_silent(hw, SEC_IPC_HOST_INT_STATUS_REG,\r\nSEC_IPC_HOST_INT_STATUS_PENDING);\r\nmei_txe_br_reg_write(hw, HISR_REG, HISR_INT_STS_MSK);\r\nmei_txe_br_reg_write(hw, HHISR_REG, IPC_HHIER_MSK);\r\n}\r\nstatic void mei_txe_intr_disable(struct mei_device *dev)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nmei_txe_br_reg_write(hw, HHIER_REG, 0);\r\nmei_txe_br_reg_write(hw, HIER_REG, 0);\r\n}\r\nstatic void mei_txe_intr_enable(struct mei_device *dev)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nmei_txe_br_reg_write(hw, HHIER_REG, IPC_HHIER_MSK);\r\nmei_txe_br_reg_write(hw, HIER_REG, HIER_INT_EN_MSK);\r\n}\r\nstatic bool mei_txe_pending_interrupts(struct mei_device *dev)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nbool ret = (hw->intr_cause & (TXE_INTR_READINESS |\r\nTXE_INTR_ALIVENESS |\r\nTXE_INTR_IN_READY |\r\nTXE_INTR_OUT_DB));\r\nif (ret) {\r\ndev_dbg(dev->dev,\r\n"Pending Interrupts InReady=%01d Readiness=%01d, Aliveness=%01d, OutDoor=%01d\n",\r\n!!(hw->intr_cause & TXE_INTR_IN_READY),\r\n!!(hw->intr_cause & TXE_INTR_READINESS),\r\n!!(hw->intr_cause & TXE_INTR_ALIVENESS),\r\n!!(hw->intr_cause & TXE_INTR_OUT_DB));\r\n}\r\nreturn ret;\r\n}\r\nstatic void mei_txe_input_payload_write(struct mei_device *dev,\r\nunsigned long idx, u32 value)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nmei_txe_sec_reg_write(hw, SEC_IPC_INPUT_PAYLOAD_REG +\r\n(idx * sizeof(u32)), value);\r\n}\r\nstatic u32 mei_txe_out_data_read(const struct mei_device *dev,\r\nunsigned long idx)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nreturn mei_txe_br_reg_read(hw,\r\nBRIDGE_IPC_OUTPUT_PAYLOAD_REG + (idx * sizeof(u32)));\r\n}\r\nstatic void mei_txe_readiness_set_host_rdy(struct mei_device *dev)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nmei_txe_br_reg_write(hw,\r\nSICR_HOST_IPC_READINESS_REQ_REG,\r\nSICR_HOST_IPC_READINESS_HOST_RDY);\r\n}\r\nstatic void mei_txe_readiness_clear(struct mei_device *dev)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nmei_txe_br_reg_write(hw, SICR_HOST_IPC_READINESS_REQ_REG,\r\nSICR_HOST_IPC_READINESS_RDY_CLR);\r\n}\r\nstatic u32 mei_txe_readiness_get(struct mei_device *dev)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nreturn mei_txe_br_reg_read(hw, HICR_SEC_IPC_READINESS_REG);\r\n}\r\nstatic inline bool mei_txe_readiness_is_sec_rdy(u32 readiness)\r\n{\r\nreturn !!(readiness & HICR_SEC_IPC_READINESS_SEC_RDY);\r\n}\r\nstatic bool mei_txe_hw_is_ready(struct mei_device *dev)\r\n{\r\nu32 readiness = mei_txe_readiness_get(dev);\r\nreturn mei_txe_readiness_is_sec_rdy(readiness);\r\n}\r\nstatic inline bool mei_txe_host_is_ready(struct mei_device *dev)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nu32 reg = mei_txe_br_reg_read(hw, HICR_SEC_IPC_READINESS_REG);\r\nreturn !!(reg & HICR_SEC_IPC_READINESS_HOST_RDY);\r\n}\r\nstatic int mei_txe_readiness_wait(struct mei_device *dev)\r\n{\r\nif (mei_txe_hw_is_ready(dev))\r\nreturn 0;\r\nmutex_unlock(&dev->device_lock);\r\nwait_event_timeout(dev->wait_hw_ready, dev->recvd_hw_ready,\r\nmsecs_to_jiffies(SEC_RESET_WAIT_TIMEOUT));\r\nmutex_lock(&dev->device_lock);\r\nif (!dev->recvd_hw_ready) {\r\ndev_err(dev->dev, "wait for readiness failed\n");\r\nreturn -ETIME;\r\n}\r\ndev->recvd_hw_ready = false;\r\nreturn 0;\r\n}\r\nstatic int mei_txe_fw_status(struct mei_device *dev,\r\nstruct mei_fw_status *fw_status)\r\n{\r\nconst struct mei_fw_status *fw_src = &mei_txe_fw_sts;\r\nstruct pci_dev *pdev = to_pci_dev(dev->dev);\r\nint ret;\r\nint i;\r\nif (!fw_status)\r\nreturn -EINVAL;\r\nfw_status->count = fw_src->count;\r\nfor (i = 0; i < fw_src->count && i < MEI_FW_STATUS_MAX; i++) {\r\nret = pci_read_config_dword(pdev,\r\nfw_src->status[i], &fw_status->status[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mei_txe_hw_config(struct mei_device *dev)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\ndev->hbuf_depth = PAYLOAD_SIZE / 4;\r\nhw->aliveness = mei_txe_aliveness_get(dev);\r\nhw->readiness = mei_txe_readiness_get(dev);\r\ndev_dbg(dev->dev, "aliveness_resp = 0x%08x, readiness = 0x%08x.\n",\r\nhw->aliveness, hw->readiness);\r\n}\r\nstatic int mei_txe_write(struct mei_device *dev,\r\nstruct mei_msg_hdr *header, unsigned char *buf)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nunsigned long rem;\r\nunsigned long length;\r\nint slots = dev->hbuf_depth;\r\nu32 *reg_buf = (u32 *)buf;\r\nu32 dw_cnt;\r\nint i;\r\nif (WARN_ON(!header || !buf))\r\nreturn -EINVAL;\r\nlength = header->length;\r\ndev_dbg(dev->dev, MEI_HDR_FMT, MEI_HDR_PRM(header));\r\ndw_cnt = mei_data2slots(length);\r\nif (dw_cnt > slots)\r\nreturn -EMSGSIZE;\r\nif (WARN(!hw->aliveness, "txe write: aliveness not asserted\n"))\r\nreturn -EAGAIN;\r\nmei_txe_input_ready_interrupt_enable(dev);\r\nif (!mei_txe_is_input_ready(dev)) {\r\nchar fw_sts_str[MEI_FW_STATUS_STR_SZ];\r\nmei_fw_status_str(dev, fw_sts_str, MEI_FW_STATUS_STR_SZ);\r\ndev_err(dev->dev, "Input is not ready %s\n", fw_sts_str);\r\nreturn -EAGAIN;\r\n}\r\nmei_txe_input_payload_write(dev, 0, *((u32 *)header));\r\nfor (i = 0; i < length / 4; i++)\r\nmei_txe_input_payload_write(dev, i + 1, reg_buf[i]);\r\nrem = length & 0x3;\r\nif (rem > 0) {\r\nu32 reg = 0;\r\nmemcpy(&reg, &buf[length - rem], rem);\r\nmei_txe_input_payload_write(dev, i + 1, reg);\r\n}\r\nhw->slots = 0;\r\nmei_txe_input_doorbell_set(hw);\r\nreturn 0;\r\n}\r\nstatic size_t mei_txe_hbuf_max_len(const struct mei_device *dev)\r\n{\r\nreturn PAYLOAD_SIZE - sizeof(struct mei_msg_hdr);\r\n}\r\nstatic int mei_txe_hbuf_empty_slots(struct mei_device *dev)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nreturn hw->slots;\r\n}\r\nstatic int mei_txe_count_full_read_slots(struct mei_device *dev)\r\n{\r\nreturn PAYLOAD_SIZE / 4;\r\n}\r\nstatic u32 mei_txe_read_hdr(const struct mei_device *dev)\r\n{\r\nreturn mei_txe_out_data_read(dev, 0);\r\n}\r\nstatic int mei_txe_read(struct mei_device *dev,\r\nunsigned char *buf, unsigned long len)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nu32 *reg_buf, reg;\r\nu32 rem;\r\nu32 i;\r\nif (WARN_ON(!buf || !len))\r\nreturn -EINVAL;\r\nreg_buf = (u32 *)buf;\r\nrem = len & 0x3;\r\ndev_dbg(dev->dev, "buffer-length = %lu buf[0]0x%08X\n",\r\nlen, mei_txe_out_data_read(dev, 0));\r\nfor (i = 0; i < len / 4; i++) {\r\nreg = mei_txe_out_data_read(dev, i + 1);\r\ndev_dbg(dev->dev, "buf[%d] = 0x%08X\n", i, reg);\r\n*reg_buf++ = reg;\r\n}\r\nif (rem) {\r\nreg = mei_txe_out_data_read(dev, i + 1);\r\nmemcpy(reg_buf, &reg, rem);\r\n}\r\nmei_txe_output_ready_set(hw);\r\nreturn 0;\r\n}\r\nstatic int mei_txe_hw_reset(struct mei_device *dev, bool intr_enable)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nu32 aliveness_req;\r\n(void)mei_txe_sec_reg_read_silent(hw, SEC_IPC_INPUT_DOORBELL_REG);\r\naliveness_req = mei_txe_aliveness_req_get(dev);\r\nhw->aliveness = mei_txe_aliveness_get(dev);\r\nmei_txe_intr_disable(dev);\r\nif (aliveness_req != hw->aliveness)\r\nif (mei_txe_aliveness_poll(dev, aliveness_req) < 0) {\r\ndev_err(dev->dev, "wait for aliveness settle failed ... bailing out\n");\r\nreturn -EIO;\r\n}\r\nif (aliveness_req) {\r\nmei_txe_aliveness_set(dev, 0);\r\nif (mei_txe_aliveness_poll(dev, 0) < 0) {\r\ndev_err(dev->dev, "wait for aliveness failed ... bailing out\n");\r\nreturn -EIO;\r\n}\r\n}\r\nmei_txe_readiness_clear(dev);\r\nreturn 0;\r\n}\r\nstatic int mei_txe_hw_start(struct mei_device *dev)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nint ret;\r\nu32 hisr;\r\nmei_txe_intr_enable(dev);\r\nret = mei_txe_readiness_wait(dev);\r\nif (ret < 0) {\r\ndev_err(dev->dev, "waiting for readiness failed\n");\r\nreturn ret;\r\n}\r\nhisr = mei_txe_br_reg_read(hw, HISR_REG);\r\nif (hisr & HISR_INT_2_STS)\r\nmei_txe_br_reg_write(hw, HISR_REG, HISR_INT_2_STS);\r\nclear_bit(TXE_INTR_OUT_DB_BIT, &hw->intr_cause);\r\nret = mei_txe_aliveness_set_sync(dev, 1);\r\nif (ret < 0) {\r\ndev_err(dev->dev, "wait for aliveness failed ... bailing out\n");\r\nreturn ret;\r\n}\r\nmei_txe_input_ready_interrupt_enable(dev);\r\nmei_txe_output_ready_set(hw);\r\nmei_txe_readiness_set_host_rdy(dev);\r\nreturn 0;\r\n}\r\nstatic bool mei_txe_check_and_ack_intrs(struct mei_device *dev, bool do_ack)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nu32 hisr;\r\nu32 hhisr;\r\nu32 ipc_isr;\r\nu32 aliveness;\r\nbool generated;\r\nhhisr = mei_txe_br_reg_read(hw, HHISR_REG);\r\ngenerated = (hhisr & IPC_HHIER_MSK);\r\nif (!generated)\r\ngoto out;\r\nhisr = mei_txe_br_reg_read(hw, HISR_REG);\r\naliveness = mei_txe_aliveness_get(dev);\r\nif (hhisr & IPC_HHIER_SEC && aliveness)\r\nipc_isr = mei_txe_sec_reg_read_silent(hw,\r\nSEC_IPC_HOST_INT_STATUS_REG);\r\nelse\r\nipc_isr = 0;\r\ngenerated = generated ||\r\n(hisr & HISR_INT_STS_MSK) ||\r\n(ipc_isr & SEC_IPC_HOST_INT_STATUS_PENDING);\r\nif (generated && do_ack) {\r\nhw->intr_cause |= hisr & HISR_INT_STS_MSK;\r\nif (ipc_isr & SEC_IPC_HOST_INT_STATUS_IN_RDY)\r\nhw->intr_cause |= TXE_INTR_IN_READY;\r\nmei_txe_intr_disable(dev);\r\nmei_txe_sec_reg_write_silent(hw,\r\nSEC_IPC_HOST_INT_STATUS_REG, ipc_isr);\r\nmei_txe_br_reg_write(hw, HISR_REG, hisr);\r\nmei_txe_br_reg_write(hw, HHISR_REG, hhisr);\r\n}\r\nout:\r\nreturn generated;\r\n}\r\nirqreturn_t mei_txe_irq_quick_handler(int irq, void *dev_id)\r\n{\r\nstruct mei_device *dev = dev_id;\r\nif (mei_txe_check_and_ack_intrs(dev, true))\r\nreturn IRQ_WAKE_THREAD;\r\nreturn IRQ_NONE;\r\n}\r\nirqreturn_t mei_txe_irq_thread_handler(int irq, void *dev_id)\r\n{\r\nstruct mei_device *dev = (struct mei_device *) dev_id;\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nstruct mei_cl_cb complete_list;\r\ns32 slots;\r\nint rets = 0;\r\ndev_dbg(dev->dev, "irq thread: Interrupt Registers HHISR|HISR|SEC=%02X|%04X|%02X\n",\r\nmei_txe_br_reg_read(hw, HHISR_REG),\r\nmei_txe_br_reg_read(hw, HISR_REG),\r\nmei_txe_sec_reg_read_silent(hw, SEC_IPC_HOST_INT_STATUS_REG));\r\nmutex_lock(&dev->device_lock);\r\nmei_io_list_init(&complete_list);\r\nif (pci_dev_msi_enabled(to_pci_dev(dev->dev)))\r\nmei_txe_check_and_ack_intrs(dev, true);\r\nmei_txe_pending_interrupts(dev);\r\nhw->aliveness = mei_txe_aliveness_get(dev);\r\nhw->readiness = mei_txe_readiness_get(dev);\r\nif (test_and_clear_bit(TXE_INTR_READINESS_BIT, &hw->intr_cause)) {\r\ndev_dbg(dev->dev, "Readiness Interrupt was received...\n");\r\nif (mei_txe_readiness_is_sec_rdy(hw->readiness)) {\r\ndev_dbg(dev->dev, "we need to start the dev.\n");\r\ndev->recvd_hw_ready = true;\r\n} else {\r\ndev->recvd_hw_ready = false;\r\nif (dev->dev_state != MEI_DEV_RESETTING) {\r\ndev_warn(dev->dev, "FW not ready: resetting.\n");\r\nschedule_work(&dev->reset_work);\r\ngoto end;\r\n}\r\n}\r\nwake_up(&dev->wait_hw_ready);\r\n}\r\nif (test_and_clear_bit(TXE_INTR_ALIVENESS_BIT, &hw->intr_cause)) {\r\ndev_dbg(dev->dev,\r\n"Aliveness Interrupt: Status: %d\n", hw->aliveness);\r\ndev->pg_event = MEI_PG_EVENT_RECEIVED;\r\nif (waitqueue_active(&hw->wait_aliveness_resp))\r\nwake_up(&hw->wait_aliveness_resp);\r\n}\r\nslots = mei_count_full_read_slots(dev);\r\nif (test_and_clear_bit(TXE_INTR_OUT_DB_BIT, &hw->intr_cause)) {\r\nrets = mei_irq_read_handler(dev, &complete_list, &slots);\r\nif (rets && dev->dev_state != MEI_DEV_RESETTING) {\r\ndev_err(dev->dev,\r\n"mei_irq_read_handler ret = %d.\n", rets);\r\nschedule_work(&dev->reset_work);\r\ngoto end;\r\n}\r\n}\r\nif (test_and_clear_bit(TXE_INTR_IN_READY_BIT, &hw->intr_cause)) {\r\ndev->hbuf_is_ready = true;\r\nhw->slots = dev->hbuf_depth;\r\n}\r\nif (hw->aliveness && dev->hbuf_is_ready) {\r\ndev->hbuf_is_ready = mei_hbuf_is_ready(dev);\r\nrets = mei_irq_write_handler(dev, &complete_list);\r\nif (rets && rets != -EMSGSIZE)\r\ndev_err(dev->dev, "mei_irq_write_handler ret = %d.\n",\r\nrets);\r\ndev->hbuf_is_ready = mei_hbuf_is_ready(dev);\r\n}\r\nmei_irq_compl_handler(dev, &complete_list);\r\nend:\r\ndev_dbg(dev->dev, "interrupt thread end ret = %d\n", rets);\r\nmutex_unlock(&dev->device_lock);\r\nmei_enable_interrupts(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstruct mei_device *mei_txe_dev_init(struct pci_dev *pdev)\r\n{\r\nstruct mei_device *dev;\r\nstruct mei_txe_hw *hw;\r\ndev = kzalloc(sizeof(struct mei_device) +\r\nsizeof(struct mei_txe_hw), GFP_KERNEL);\r\nif (!dev)\r\nreturn NULL;\r\nmei_device_init(dev, &pdev->dev, &mei_txe_hw_ops);\r\nhw = to_txe_hw(dev);\r\ninit_waitqueue_head(&hw->wait_aliveness_resp);\r\nreturn dev;\r\n}\r\nint mei_txe_setup_satt2(struct mei_device *dev, phys_addr_t addr, u32 range)\r\n{\r\nstruct mei_txe_hw *hw = to_txe_hw(dev);\r\nu32 lo32 = lower_32_bits(addr);\r\nu32 hi32 = upper_32_bits(addr);\r\nu32 ctrl;\r\nif (hi32 & ~0xF)\r\nreturn -EINVAL;\r\nif (lo32 & 0xF)\r\nreturn -EINVAL;\r\nif (range & 0x4)\r\nreturn -EINVAL;\r\nif (range > SATT_RANGE_MAX)\r\nreturn -EINVAL;\r\nctrl = SATT2_CTRL_VALID_MSK;\r\nctrl |= hi32 << SATT2_CTRL_BR_BASE_ADDR_REG_SHIFT;\r\nmei_txe_br_reg_write(hw, SATT2_SAP_SIZE_REG, range);\r\nmei_txe_br_reg_write(hw, SATT2_BRG_BA_LSB_REG, lo32);\r\nmei_txe_br_reg_write(hw, SATT2_CTRL_REG, ctrl);\r\ndev_dbg(dev->dev, "SATT2: SAP_SIZE_OFFSET=0x%08X, BRG_BA_LSB_OFFSET=0x%08X, CTRL_OFFSET=0x%08X\n",\r\nrange, lo32, ctrl);\r\nreturn 0;\r\n}
