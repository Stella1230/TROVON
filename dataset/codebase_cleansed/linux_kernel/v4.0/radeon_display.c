static void avivo_crtc_load_lut(struct drm_crtc *crtc)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint i;\r\nDRM_DEBUG_KMS("%d\n", radeon_crtc->crtc_id);\r\nWREG32(AVIVO_DC_LUTA_CONTROL + radeon_crtc->crtc_offset, 0);\r\nWREG32(AVIVO_DC_LUTA_BLACK_OFFSET_BLUE + radeon_crtc->crtc_offset, 0);\r\nWREG32(AVIVO_DC_LUTA_BLACK_OFFSET_GREEN + radeon_crtc->crtc_offset, 0);\r\nWREG32(AVIVO_DC_LUTA_BLACK_OFFSET_RED + radeon_crtc->crtc_offset, 0);\r\nWREG32(AVIVO_DC_LUTA_WHITE_OFFSET_BLUE + radeon_crtc->crtc_offset, 0xffff);\r\nWREG32(AVIVO_DC_LUTA_WHITE_OFFSET_GREEN + radeon_crtc->crtc_offset, 0xffff);\r\nWREG32(AVIVO_DC_LUTA_WHITE_OFFSET_RED + radeon_crtc->crtc_offset, 0xffff);\r\nWREG32(AVIVO_DC_LUT_RW_SELECT, radeon_crtc->crtc_id);\r\nWREG32(AVIVO_DC_LUT_RW_MODE, 0);\r\nWREG32(AVIVO_DC_LUT_WRITE_EN_MASK, 0x0000003f);\r\nWREG8(AVIVO_DC_LUT_RW_INDEX, 0);\r\nfor (i = 0; i < 256; i++) {\r\nWREG32(AVIVO_DC_LUT_30_COLOR,\r\n(radeon_crtc->lut_r[i] << 20) |\r\n(radeon_crtc->lut_g[i] << 10) |\r\n(radeon_crtc->lut_b[i] << 0));\r\n}\r\nWREG32_P(AVIVO_D1GRPH_LUT_SEL + radeon_crtc->crtc_offset, radeon_crtc->crtc_id, ~1);\r\n}\r\nstatic void dce4_crtc_load_lut(struct drm_crtc *crtc)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint i;\r\nDRM_DEBUG_KMS("%d\n", radeon_crtc->crtc_id);\r\nWREG32(EVERGREEN_DC_LUT_CONTROL + radeon_crtc->crtc_offset, 0);\r\nWREG32(EVERGREEN_DC_LUT_BLACK_OFFSET_BLUE + radeon_crtc->crtc_offset, 0);\r\nWREG32(EVERGREEN_DC_LUT_BLACK_OFFSET_GREEN + radeon_crtc->crtc_offset, 0);\r\nWREG32(EVERGREEN_DC_LUT_BLACK_OFFSET_RED + radeon_crtc->crtc_offset, 0);\r\nWREG32(EVERGREEN_DC_LUT_WHITE_OFFSET_BLUE + radeon_crtc->crtc_offset, 0xffff);\r\nWREG32(EVERGREEN_DC_LUT_WHITE_OFFSET_GREEN + radeon_crtc->crtc_offset, 0xffff);\r\nWREG32(EVERGREEN_DC_LUT_WHITE_OFFSET_RED + radeon_crtc->crtc_offset, 0xffff);\r\nWREG32(EVERGREEN_DC_LUT_RW_MODE + radeon_crtc->crtc_offset, 0);\r\nWREG32(EVERGREEN_DC_LUT_WRITE_EN_MASK + radeon_crtc->crtc_offset, 0x00000007);\r\nWREG32(EVERGREEN_DC_LUT_RW_INDEX + radeon_crtc->crtc_offset, 0);\r\nfor (i = 0; i < 256; i++) {\r\nWREG32(EVERGREEN_DC_LUT_30_COLOR + radeon_crtc->crtc_offset,\r\n(radeon_crtc->lut_r[i] << 20) |\r\n(radeon_crtc->lut_g[i] << 10) |\r\n(radeon_crtc->lut_b[i] << 0));\r\n}\r\n}\r\nstatic void dce5_crtc_load_lut(struct drm_crtc *crtc)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint i;\r\nDRM_DEBUG_KMS("%d\n", radeon_crtc->crtc_id);\r\nWREG32(NI_INPUT_CSC_CONTROL + radeon_crtc->crtc_offset,\r\n(NI_INPUT_CSC_GRPH_MODE(NI_INPUT_CSC_BYPASS) |\r\nNI_INPUT_CSC_OVL_MODE(NI_INPUT_CSC_BYPASS)));\r\nWREG32(NI_PRESCALE_GRPH_CONTROL + radeon_crtc->crtc_offset,\r\nNI_GRPH_PRESCALE_BYPASS);\r\nWREG32(NI_PRESCALE_OVL_CONTROL + radeon_crtc->crtc_offset,\r\nNI_OVL_PRESCALE_BYPASS);\r\nWREG32(NI_INPUT_GAMMA_CONTROL + radeon_crtc->crtc_offset,\r\n(NI_GRPH_INPUT_GAMMA_MODE(NI_INPUT_GAMMA_USE_LUT) |\r\nNI_OVL_INPUT_GAMMA_MODE(NI_INPUT_GAMMA_USE_LUT)));\r\nWREG32(EVERGREEN_DC_LUT_CONTROL + radeon_crtc->crtc_offset, 0);\r\nWREG32(EVERGREEN_DC_LUT_BLACK_OFFSET_BLUE + radeon_crtc->crtc_offset, 0);\r\nWREG32(EVERGREEN_DC_LUT_BLACK_OFFSET_GREEN + radeon_crtc->crtc_offset, 0);\r\nWREG32(EVERGREEN_DC_LUT_BLACK_OFFSET_RED + radeon_crtc->crtc_offset, 0);\r\nWREG32(EVERGREEN_DC_LUT_WHITE_OFFSET_BLUE + radeon_crtc->crtc_offset, 0xffff);\r\nWREG32(EVERGREEN_DC_LUT_WHITE_OFFSET_GREEN + radeon_crtc->crtc_offset, 0xffff);\r\nWREG32(EVERGREEN_DC_LUT_WHITE_OFFSET_RED + radeon_crtc->crtc_offset, 0xffff);\r\nWREG32(EVERGREEN_DC_LUT_RW_MODE + radeon_crtc->crtc_offset, 0);\r\nWREG32(EVERGREEN_DC_LUT_WRITE_EN_MASK + radeon_crtc->crtc_offset, 0x00000007);\r\nWREG32(EVERGREEN_DC_LUT_RW_INDEX + radeon_crtc->crtc_offset, 0);\r\nfor (i = 0; i < 256; i++) {\r\nWREG32(EVERGREEN_DC_LUT_30_COLOR + radeon_crtc->crtc_offset,\r\n(radeon_crtc->lut_r[i] << 20) |\r\n(radeon_crtc->lut_g[i] << 10) |\r\n(radeon_crtc->lut_b[i] << 0));\r\n}\r\nWREG32(NI_DEGAMMA_CONTROL + radeon_crtc->crtc_offset,\r\n(NI_GRPH_DEGAMMA_MODE(NI_DEGAMMA_BYPASS) |\r\nNI_OVL_DEGAMMA_MODE(NI_DEGAMMA_BYPASS) |\r\nNI_ICON_DEGAMMA_MODE(NI_DEGAMMA_BYPASS) |\r\nNI_CURSOR_DEGAMMA_MODE(NI_DEGAMMA_BYPASS)));\r\nWREG32(NI_GAMUT_REMAP_CONTROL + radeon_crtc->crtc_offset,\r\n(NI_GRPH_GAMUT_REMAP_MODE(NI_GAMUT_REMAP_BYPASS) |\r\nNI_OVL_GAMUT_REMAP_MODE(NI_GAMUT_REMAP_BYPASS)));\r\nWREG32(NI_REGAMMA_CONTROL + radeon_crtc->crtc_offset,\r\n(NI_GRPH_REGAMMA_MODE(NI_REGAMMA_BYPASS) |\r\nNI_OVL_REGAMMA_MODE(NI_REGAMMA_BYPASS)));\r\nWREG32(NI_OUTPUT_CSC_CONTROL + radeon_crtc->crtc_offset,\r\n(NI_OUTPUT_CSC_GRPH_MODE(NI_OUTPUT_CSC_BYPASS) |\r\nNI_OUTPUT_CSC_OVL_MODE(NI_OUTPUT_CSC_BYPASS)));\r\nWREG32(0x6940 + radeon_crtc->crtc_offset, 0);\r\nif (ASIC_IS_DCE8(rdev)) {\r\nWREG32(CIK_ALPHA_CONTROL + radeon_crtc->crtc_offset,\r\nCIK_CURSOR_ALPHA_BLND_ENA);\r\n}\r\n}\r\nstatic void legacy_crtc_load_lut(struct drm_crtc *crtc)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint i;\r\nuint32_t dac2_cntl;\r\ndac2_cntl = RREG32(RADEON_DAC_CNTL2);\r\nif (radeon_crtc->crtc_id == 0)\r\ndac2_cntl &= (uint32_t)~RADEON_DAC2_PALETTE_ACC_CTL;\r\nelse\r\ndac2_cntl |= RADEON_DAC2_PALETTE_ACC_CTL;\r\nWREG32(RADEON_DAC_CNTL2, dac2_cntl);\r\nWREG8(RADEON_PALETTE_INDEX, 0);\r\nfor (i = 0; i < 256; i++) {\r\nWREG32(RADEON_PALETTE_30_DATA,\r\n(radeon_crtc->lut_r[i] << 20) |\r\n(radeon_crtc->lut_g[i] << 10) |\r\n(radeon_crtc->lut_b[i] << 0));\r\n}\r\n}\r\nvoid radeon_crtc_load_lut(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (!crtc->enabled)\r\nreturn;\r\nif (ASIC_IS_DCE5(rdev))\r\ndce5_crtc_load_lut(crtc);\r\nelse if (ASIC_IS_DCE4(rdev))\r\ndce4_crtc_load_lut(crtc);\r\nelse if (ASIC_IS_AVIVO(rdev))\r\navivo_crtc_load_lut(crtc);\r\nelse\r\nlegacy_crtc_load_lut(crtc);\r\n}\r\nvoid radeon_crtc_fb_gamma_set(struct drm_crtc *crtc, u16 red, u16 green,\r\nu16 blue, int regno)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nradeon_crtc->lut_r[regno] = red >> 6;\r\nradeon_crtc->lut_g[regno] = green >> 6;\r\nradeon_crtc->lut_b[regno] = blue >> 6;\r\n}\r\nvoid radeon_crtc_fb_gamma_get(struct drm_crtc *crtc, u16 *red, u16 *green,\r\nu16 *blue, int regno)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\n*red = radeon_crtc->lut_r[regno] << 6;\r\n*green = radeon_crtc->lut_g[regno] << 6;\r\n*blue = radeon_crtc->lut_b[regno] << 6;\r\n}\r\nstatic void radeon_crtc_gamma_set(struct drm_crtc *crtc, u16 *red, u16 *green,\r\nu16 *blue, uint32_t start, uint32_t size)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nint end = (start + size > 256) ? 256 : start + size, i;\r\nfor (i = start; i < end; i++) {\r\nradeon_crtc->lut_r[i] = red[i] >> 6;\r\nradeon_crtc->lut_g[i] = green[i] >> 6;\r\nradeon_crtc->lut_b[i] = blue[i] >> 6;\r\n}\r\nradeon_crtc_load_lut(crtc);\r\n}\r\nstatic void radeon_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\ndrm_crtc_cleanup(crtc);\r\ndestroy_workqueue(radeon_crtc->flip_queue);\r\nkfree(radeon_crtc);\r\n}\r\nstatic void radeon_unpin_work_func(struct work_struct *__work)\r\n{\r\nstruct radeon_flip_work *work =\r\ncontainer_of(__work, struct radeon_flip_work, unpin_work);\r\nint r;\r\nr = radeon_bo_reserve(work->old_rbo, false);\r\nif (likely(r == 0)) {\r\nr = radeon_bo_unpin(work->old_rbo);\r\nif (unlikely(r != 0)) {\r\nDRM_ERROR("failed to unpin buffer after flip\n");\r\n}\r\nradeon_bo_unreserve(work->old_rbo);\r\n} else\r\nDRM_ERROR("failed to reserve buffer after flip\n");\r\ndrm_gem_object_unreference_unlocked(&work->old_rbo->gem_base);\r\nkfree(work);\r\n}\r\nvoid radeon_crtc_handle_vblank(struct radeon_device *rdev, int crtc_id)\r\n{\r\nstruct radeon_crtc *radeon_crtc = rdev->mode_info.crtcs[crtc_id];\r\nunsigned long flags;\r\nu32 update_pending;\r\nint vpos, hpos;\r\nif (radeon_crtc == NULL)\r\nreturn;\r\nif ((radeon_use_pflipirq == 2) && ASIC_IS_DCE4(rdev))\r\nreturn;\r\nspin_lock_irqsave(&rdev->ddev->event_lock, flags);\r\nif (radeon_crtc->flip_status != RADEON_FLIP_SUBMITTED) {\r\nDRM_DEBUG_DRIVER("radeon_crtc->flip_status = %d != "\r\n"RADEON_FLIP_SUBMITTED(%d)\n",\r\nradeon_crtc->flip_status,\r\nRADEON_FLIP_SUBMITTED);\r\nspin_unlock_irqrestore(&rdev->ddev->event_lock, flags);\r\nreturn;\r\n}\r\nupdate_pending = radeon_page_flip_pending(rdev, crtc_id);\r\nif (update_pending &&\r\n(DRM_SCANOUTPOS_VALID & radeon_get_crtc_scanoutpos(rdev->ddev, crtc_id, 0,\r\n&vpos, &hpos, NULL, NULL)) &&\r\n((vpos >= (99 * rdev->mode_info.crtcs[crtc_id]->base.hwmode.crtc_vdisplay)/100) ||\r\n(vpos < 0 && !ASIC_IS_AVIVO(rdev)))) {\r\nupdate_pending = 0;\r\n}\r\nspin_unlock_irqrestore(&rdev->ddev->event_lock, flags);\r\nif (!update_pending)\r\nradeon_crtc_handle_flip(rdev, crtc_id);\r\n}\r\nvoid radeon_crtc_handle_flip(struct radeon_device *rdev, int crtc_id)\r\n{\r\nstruct radeon_crtc *radeon_crtc = rdev->mode_info.crtcs[crtc_id];\r\nstruct radeon_flip_work *work;\r\nunsigned long flags;\r\nif (radeon_crtc == NULL)\r\nreturn;\r\nspin_lock_irqsave(&rdev->ddev->event_lock, flags);\r\nwork = radeon_crtc->flip_work;\r\nif (radeon_crtc->flip_status != RADEON_FLIP_SUBMITTED) {\r\nDRM_DEBUG_DRIVER("radeon_crtc->flip_status = %d != "\r\n"RADEON_FLIP_SUBMITTED(%d)\n",\r\nradeon_crtc->flip_status,\r\nRADEON_FLIP_SUBMITTED);\r\nspin_unlock_irqrestore(&rdev->ddev->event_lock, flags);\r\nreturn;\r\n}\r\nradeon_crtc->flip_status = RADEON_FLIP_NONE;\r\nradeon_crtc->flip_work = NULL;\r\nif (work->event)\r\ndrm_send_vblank_event(rdev->ddev, crtc_id, work->event);\r\nspin_unlock_irqrestore(&rdev->ddev->event_lock, flags);\r\ndrm_vblank_put(rdev->ddev, radeon_crtc->crtc_id);\r\nradeon_irq_kms_pflip_irq_put(rdev, work->crtc_id);\r\nqueue_work(radeon_crtc->flip_queue, &work->unpin_work);\r\n}\r\nstatic void radeon_flip_work_func(struct work_struct *__work)\r\n{\r\nstruct radeon_flip_work *work =\r\ncontainer_of(__work, struct radeon_flip_work, flip_work);\r\nstruct radeon_device *rdev = work->rdev;\r\nstruct radeon_crtc *radeon_crtc = rdev->mode_info.crtcs[work->crtc_id];\r\nstruct drm_crtc *crtc = &radeon_crtc->base;\r\nunsigned long flags;\r\nint r;\r\ndown_read(&rdev->exclusive_lock);\r\nif (work->fence) {\r\nstruct radeon_fence *fence;\r\nfence = to_radeon_fence(work->fence);\r\nif (fence && fence->rdev == rdev) {\r\nr = radeon_fence_wait(fence, false);\r\nif (r == -EDEADLK) {\r\nup_read(&rdev->exclusive_lock);\r\ndo {\r\nr = radeon_gpu_reset(rdev);\r\n} while (r == -EAGAIN);\r\ndown_read(&rdev->exclusive_lock);\r\n}\r\n} else\r\nr = fence_wait(work->fence, false);\r\nif (r)\r\nDRM_ERROR("failed to wait on page flip fence (%d)!\n", r);\r\nfence_put(work->fence);\r\nwork->fence = NULL;\r\n}\r\nspin_lock_irqsave(&crtc->dev->event_lock, flags);\r\nradeon_irq_kms_pflip_irq_get(rdev, radeon_crtc->crtc_id);\r\nradeon_page_flip(rdev, radeon_crtc->crtc_id, work->base);\r\nradeon_crtc->flip_status = RADEON_FLIP_SUBMITTED;\r\nspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\r\nup_read(&rdev->exclusive_lock);\r\n}\r\nstatic int radeon_crtc_page_flip(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nstruct drm_pending_vblank_event *event,\r\nuint32_t page_flip_flags)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct radeon_framebuffer *old_radeon_fb;\r\nstruct radeon_framebuffer *new_radeon_fb;\r\nstruct drm_gem_object *obj;\r\nstruct radeon_flip_work *work;\r\nstruct radeon_bo *new_rbo;\r\nuint32_t tiling_flags, pitch_pixels;\r\nuint64_t base;\r\nunsigned long flags;\r\nint r;\r\nwork = kzalloc(sizeof *work, GFP_KERNEL);\r\nif (work == NULL)\r\nreturn -ENOMEM;\r\nINIT_WORK(&work->flip_work, radeon_flip_work_func);\r\nINIT_WORK(&work->unpin_work, radeon_unpin_work_func);\r\nwork->rdev = rdev;\r\nwork->crtc_id = radeon_crtc->crtc_id;\r\nwork->event = event;\r\nold_radeon_fb = to_radeon_framebuffer(crtc->primary->fb);\r\nobj = old_radeon_fb->obj;\r\ndrm_gem_object_reference(obj);\r\nwork->old_rbo = gem_to_radeon_bo(obj);\r\nnew_radeon_fb = to_radeon_framebuffer(fb);\r\nobj = new_radeon_fb->obj;\r\nnew_rbo = gem_to_radeon_bo(obj);\r\nDRM_DEBUG_DRIVER("flip-ioctl() cur_rbo = %p, new_rbo = %p\n",\r\nwork->old_rbo, new_rbo);\r\nr = radeon_bo_reserve(new_rbo, false);\r\nif (unlikely(r != 0)) {\r\nDRM_ERROR("failed to reserve new rbo buffer before flip\n");\r\ngoto cleanup;\r\n}\r\nr = radeon_bo_pin_restricted(new_rbo, RADEON_GEM_DOMAIN_VRAM,\r\nASIC_IS_AVIVO(rdev) ? 0 : 1 << 27, &base);\r\nif (unlikely(r != 0)) {\r\nradeon_bo_unreserve(new_rbo);\r\nr = -EINVAL;\r\nDRM_ERROR("failed to pin new rbo buffer before flip\n");\r\ngoto cleanup;\r\n}\r\nwork->fence = fence_get(reservation_object_get_excl(new_rbo->tbo.resv));\r\nradeon_bo_get_tiling_flags(new_rbo, &tiling_flags, NULL);\r\nradeon_bo_unreserve(new_rbo);\r\nif (!ASIC_IS_AVIVO(rdev)) {\r\nbase -= radeon_crtc->legacy_display_base_addr;\r\npitch_pixels = fb->pitches[0] / (fb->bits_per_pixel / 8);\r\nif (tiling_flags & RADEON_TILING_MACRO) {\r\nif (ASIC_IS_R300(rdev)) {\r\nbase &= ~0x7ff;\r\n} else {\r\nint byteshift = fb->bits_per_pixel >> 4;\r\nint tile_addr = (((crtc->y >> 3) * pitch_pixels + crtc->x) >> (8 - byteshift)) << 11;\r\nbase += tile_addr + ((crtc->x << byteshift) % 256) + ((crtc->y % 8) << 8);\r\n}\r\n} else {\r\nint offset = crtc->y * pitch_pixels + crtc->x;\r\nswitch (fb->bits_per_pixel) {\r\ncase 8:\r\ndefault:\r\noffset *= 1;\r\nbreak;\r\ncase 15:\r\ncase 16:\r\noffset *= 2;\r\nbreak;\r\ncase 24:\r\noffset *= 3;\r\nbreak;\r\ncase 32:\r\noffset *= 4;\r\nbreak;\r\n}\r\nbase += offset;\r\n}\r\nbase &= ~7;\r\n}\r\nwork->base = base;\r\nr = drm_vblank_get(crtc->dev, radeon_crtc->crtc_id);\r\nif (r) {\r\nDRM_ERROR("failed to get vblank before flip\n");\r\ngoto pflip_cleanup;\r\n}\r\nspin_lock_irqsave(&crtc->dev->event_lock, flags);\r\nif (radeon_crtc->flip_status != RADEON_FLIP_NONE) {\r\nDRM_DEBUG_DRIVER("flip queue: crtc already busy\n");\r\nspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\r\nr = -EBUSY;\r\ngoto vblank_cleanup;\r\n}\r\nradeon_crtc->flip_status = RADEON_FLIP_PENDING;\r\nradeon_crtc->flip_work = work;\r\ncrtc->primary->fb = fb;\r\nspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\r\nqueue_work(radeon_crtc->flip_queue, &work->flip_work);\r\nreturn 0;\r\nvblank_cleanup:\r\ndrm_vblank_put(crtc->dev, radeon_crtc->crtc_id);\r\npflip_cleanup:\r\nif (unlikely(radeon_bo_reserve(new_rbo, false) != 0)) {\r\nDRM_ERROR("failed to reserve new rbo in error path\n");\r\ngoto cleanup;\r\n}\r\nif (unlikely(radeon_bo_unpin(new_rbo) != 0)) {\r\nDRM_ERROR("failed to unpin new rbo in error path\n");\r\n}\r\nradeon_bo_unreserve(new_rbo);\r\ncleanup:\r\ndrm_gem_object_unreference_unlocked(&work->old_rbo->gem_base);\r\nfence_put(work->fence);\r\nkfree(work);\r\nreturn r;\r\n}\r\nstatic int\r\nradeon_crtc_set_config(struct drm_mode_set *set)\r\n{\r\nstruct drm_device *dev;\r\nstruct radeon_device *rdev;\r\nstruct drm_crtc *crtc;\r\nbool active = false;\r\nint ret;\r\nif (!set || !set->crtc)\r\nreturn -EINVAL;\r\ndev = set->crtc->dev;\r\nret = pm_runtime_get_sync(dev->dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = drm_crtc_helper_set_config(set);\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head)\r\nif (crtc->enabled)\r\nactive = true;\r\npm_runtime_mark_last_busy(dev->dev);\r\nrdev = dev->dev_private;\r\nif (active && !rdev->have_disp_power_ref) {\r\nrdev->have_disp_power_ref = true;\r\nreturn ret;\r\n}\r\nif (!active && rdev->have_disp_power_ref) {\r\npm_runtime_put_autosuspend(dev->dev);\r\nrdev->have_disp_power_ref = false;\r\n}\r\npm_runtime_put_autosuspend(dev->dev);\r\nreturn ret;\r\n}\r\nstatic void radeon_crtc_init(struct drm_device *dev, int index)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_crtc *radeon_crtc;\r\nint i;\r\nradeon_crtc = kzalloc(sizeof(struct radeon_crtc) + (RADEONFB_CONN_LIMIT * sizeof(struct drm_connector *)), GFP_KERNEL);\r\nif (radeon_crtc == NULL)\r\nreturn;\r\ndrm_crtc_init(dev, &radeon_crtc->base, &radeon_crtc_funcs);\r\ndrm_mode_crtc_set_gamma_size(&radeon_crtc->base, 256);\r\nradeon_crtc->crtc_id = index;\r\nradeon_crtc->flip_queue = create_singlethread_workqueue("radeon-crtc");\r\nrdev->mode_info.crtcs[index] = radeon_crtc;\r\nif (rdev->family >= CHIP_BONAIRE) {\r\nradeon_crtc->max_cursor_width = CIK_CURSOR_WIDTH;\r\nradeon_crtc->max_cursor_height = CIK_CURSOR_HEIGHT;\r\n} else {\r\nradeon_crtc->max_cursor_width = CURSOR_WIDTH;\r\nradeon_crtc->max_cursor_height = CURSOR_HEIGHT;\r\n}\r\ndev->mode_config.cursor_width = radeon_crtc->max_cursor_width;\r\ndev->mode_config.cursor_height = radeon_crtc->max_cursor_height;\r\n#if 0\r\nradeon_crtc->mode_set.crtc = &radeon_crtc->base;\r\nradeon_crtc->mode_set.connectors = (struct drm_connector **)(radeon_crtc + 1);\r\nradeon_crtc->mode_set.num_connectors = 0;\r\n#endif\r\nfor (i = 0; i < 256; i++) {\r\nradeon_crtc->lut_r[i] = i << 2;\r\nradeon_crtc->lut_g[i] = i << 2;\r\nradeon_crtc->lut_b[i] = i << 2;\r\n}\r\nif (rdev->is_atom_bios && (ASIC_IS_AVIVO(rdev) || radeon_r4xx_atom))\r\nradeon_atombios_init_crtc(dev, radeon_crtc);\r\nelse\r\nradeon_legacy_init_crtc(dev, radeon_crtc);\r\n}\r\nstatic void radeon_print_display_setup(struct drm_device *dev)\r\n{\r\nstruct drm_connector *connector;\r\nstruct radeon_connector *radeon_connector;\r\nstruct drm_encoder *encoder;\r\nstruct radeon_encoder *radeon_encoder;\r\nuint32_t devices;\r\nint i = 0;\r\nDRM_INFO("Radeon Display Connectors\n");\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nradeon_connector = to_radeon_connector(connector);\r\nDRM_INFO("Connector %d:\n", i);\r\nDRM_INFO(" %s\n", connector->name);\r\nif (radeon_connector->hpd.hpd != RADEON_HPD_NONE)\r\nDRM_INFO(" %s\n", hpd_names[radeon_connector->hpd.hpd]);\r\nif (radeon_connector->ddc_bus) {\r\nDRM_INFO(" DDC: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",\r\nradeon_connector->ddc_bus->rec.mask_clk_reg,\r\nradeon_connector->ddc_bus->rec.mask_data_reg,\r\nradeon_connector->ddc_bus->rec.a_clk_reg,\r\nradeon_connector->ddc_bus->rec.a_data_reg,\r\nradeon_connector->ddc_bus->rec.en_clk_reg,\r\nradeon_connector->ddc_bus->rec.en_data_reg,\r\nradeon_connector->ddc_bus->rec.y_clk_reg,\r\nradeon_connector->ddc_bus->rec.y_data_reg);\r\nif (radeon_connector->router.ddc_valid)\r\nDRM_INFO(" DDC Router 0x%x/0x%x\n",\r\nradeon_connector->router.ddc_mux_control_pin,\r\nradeon_connector->router.ddc_mux_state);\r\nif (radeon_connector->router.cd_valid)\r\nDRM_INFO(" Clock/Data Router 0x%x/0x%x\n",\r\nradeon_connector->router.cd_mux_control_pin,\r\nradeon_connector->router.cd_mux_state);\r\n} else {\r\nif (connector->connector_type == DRM_MODE_CONNECTOR_VGA ||\r\nconnector->connector_type == DRM_MODE_CONNECTOR_DVII ||\r\nconnector->connector_type == DRM_MODE_CONNECTOR_DVID ||\r\nconnector->connector_type == DRM_MODE_CONNECTOR_DVIA ||\r\nconnector->connector_type == DRM_MODE_CONNECTOR_HDMIA ||\r\nconnector->connector_type == DRM_MODE_CONNECTOR_HDMIB)\r\nDRM_INFO(" DDC: no ddc bus - possible BIOS bug - please report to xorg-driver-ati@lists.x.org\n");\r\n}\r\nDRM_INFO(" Encoders:\n");\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nradeon_encoder = to_radeon_encoder(encoder);\r\ndevices = radeon_encoder->devices & radeon_connector->devices;\r\nif (devices) {\r\nif (devices & ATOM_DEVICE_CRT1_SUPPORT)\r\nDRM_INFO(" CRT1: %s\n", encoder_names[radeon_encoder->encoder_id]);\r\nif (devices & ATOM_DEVICE_CRT2_SUPPORT)\r\nDRM_INFO(" CRT2: %s\n", encoder_names[radeon_encoder->encoder_id]);\r\nif (devices & ATOM_DEVICE_LCD1_SUPPORT)\r\nDRM_INFO(" LCD1: %s\n", encoder_names[radeon_encoder->encoder_id]);\r\nif (devices & ATOM_DEVICE_DFP1_SUPPORT)\r\nDRM_INFO(" DFP1: %s\n", encoder_names[radeon_encoder->encoder_id]);\r\nif (devices & ATOM_DEVICE_DFP2_SUPPORT)\r\nDRM_INFO(" DFP2: %s\n", encoder_names[radeon_encoder->encoder_id]);\r\nif (devices & ATOM_DEVICE_DFP3_SUPPORT)\r\nDRM_INFO(" DFP3: %s\n", encoder_names[radeon_encoder->encoder_id]);\r\nif (devices & ATOM_DEVICE_DFP4_SUPPORT)\r\nDRM_INFO(" DFP4: %s\n", encoder_names[radeon_encoder->encoder_id]);\r\nif (devices & ATOM_DEVICE_DFP5_SUPPORT)\r\nDRM_INFO(" DFP5: %s\n", encoder_names[radeon_encoder->encoder_id]);\r\nif (devices & ATOM_DEVICE_DFP6_SUPPORT)\r\nDRM_INFO(" DFP6: %s\n", encoder_names[radeon_encoder->encoder_id]);\r\nif (devices & ATOM_DEVICE_TV1_SUPPORT)\r\nDRM_INFO(" TV1: %s\n", encoder_names[radeon_encoder->encoder_id]);\r\nif (devices & ATOM_DEVICE_CV_SUPPORT)\r\nDRM_INFO(" CV: %s\n", encoder_names[radeon_encoder->encoder_id]);\r\n}\r\n}\r\ni++;\r\n}\r\n}\r\nstatic bool radeon_setup_enc_conn(struct drm_device *dev)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nbool ret = false;\r\nif (rdev->bios) {\r\nif (rdev->is_atom_bios) {\r\nret = radeon_get_atom_connector_info_from_supported_devices_table(dev);\r\nif (ret == false)\r\nret = radeon_get_atom_connector_info_from_object_table(dev);\r\n} else {\r\nret = radeon_get_legacy_connector_info_from_bios(dev);\r\nif (ret == false)\r\nret = radeon_get_legacy_connector_info_from_table(dev);\r\n}\r\n} else {\r\nif (!ASIC_IS_AVIVO(rdev))\r\nret = radeon_get_legacy_connector_info_from_table(dev);\r\n}\r\nif (ret) {\r\nradeon_setup_encoder_clones(dev);\r\nradeon_print_display_setup(dev);\r\n}\r\nreturn ret;\r\n}\r\nstatic void avivo_reduce_ratio(unsigned *nom, unsigned *den,\r\nunsigned nom_min, unsigned den_min)\r\n{\r\nunsigned tmp;\r\ntmp = gcd(*nom, *den);\r\n*nom /= tmp;\r\n*den /= tmp;\r\nif (*nom < nom_min) {\r\ntmp = DIV_ROUND_UP(nom_min, *nom);\r\n*nom *= tmp;\r\n*den *= tmp;\r\n}\r\nif (*den < den_min) {\r\ntmp = DIV_ROUND_UP(den_min, *den);\r\n*nom *= tmp;\r\n*den *= tmp;\r\n}\r\n}\r\nstatic void avivo_get_fb_ref_div(unsigned nom, unsigned den, unsigned post_div,\r\nunsigned fb_div_max, unsigned ref_div_max,\r\nunsigned *fb_div, unsigned *ref_div)\r\n{\r\nref_div_max = max(min(100 / post_div, ref_div_max), 1u);\r\n*ref_div = min(max(DIV_ROUND_CLOSEST(den, post_div), 1u), ref_div_max);\r\n*fb_div = DIV_ROUND_CLOSEST(nom * *ref_div * post_div, den);\r\nif (*fb_div > fb_div_max) {\r\n*ref_div = DIV_ROUND_CLOSEST(*ref_div * fb_div_max, *fb_div);\r\n*fb_div = fb_div_max;\r\n}\r\n}\r\nvoid radeon_compute_pll_avivo(struct radeon_pll *pll,\r\nu32 freq,\r\nu32 *dot_clock_p,\r\nu32 *fb_div_p,\r\nu32 *frac_fb_div_p,\r\nu32 *ref_div_p,\r\nu32 *post_div_p)\r\n{\r\nunsigned target_clock = pll->flags & RADEON_PLL_USE_FRAC_FB_DIV ?\r\nfreq : freq / 10;\r\nunsigned fb_div_min, fb_div_max, fb_div;\r\nunsigned post_div_min, post_div_max, post_div;\r\nunsigned ref_div_min, ref_div_max, ref_div;\r\nunsigned post_div_best, diff_best;\r\nunsigned nom, den;\r\nfb_div_min = pll->min_feedback_div;\r\nfb_div_max = pll->max_feedback_div;\r\nif (pll->flags & RADEON_PLL_USE_FRAC_FB_DIV) {\r\nfb_div_min *= 10;\r\nfb_div_max *= 10;\r\n}\r\nif (pll->flags & RADEON_PLL_USE_REF_DIV)\r\nref_div_min = pll->reference_div;\r\nelse\r\nref_div_min = pll->min_ref_div;\r\nif (pll->flags & RADEON_PLL_USE_FRAC_FB_DIV &&\r\npll->flags & RADEON_PLL_USE_REF_DIV)\r\nref_div_max = pll->reference_div;\r\nelse if (pll->flags & RADEON_PLL_PREFER_MINM_OVER_MAXP)\r\nref_div_max = min(pll->max_ref_div, 7u);\r\nelse\r\nref_div_max = pll->max_ref_div;\r\nif (pll->flags & RADEON_PLL_USE_POST_DIV) {\r\npost_div_min = pll->post_div;\r\npost_div_max = pll->post_div;\r\n} else {\r\nunsigned vco_min, vco_max;\r\nif (pll->flags & RADEON_PLL_IS_LCD) {\r\nvco_min = pll->lcd_pll_out_min;\r\nvco_max = pll->lcd_pll_out_max;\r\n} else {\r\nvco_min = pll->pll_out_min;\r\nvco_max = pll->pll_out_max;\r\n}\r\nif (pll->flags & RADEON_PLL_USE_FRAC_FB_DIV) {\r\nvco_min *= 10;\r\nvco_max *= 10;\r\n}\r\npost_div_min = vco_min / target_clock;\r\nif ((target_clock * post_div_min) < vco_min)\r\n++post_div_min;\r\nif (post_div_min < pll->min_post_div)\r\npost_div_min = pll->min_post_div;\r\npost_div_max = vco_max / target_clock;\r\nif ((target_clock * post_div_max) > vco_max)\r\n--post_div_max;\r\nif (post_div_max > pll->max_post_div)\r\npost_div_max = pll->max_post_div;\r\n}\r\nnom = target_clock;\r\nden = pll->reference_freq;\r\navivo_reduce_ratio(&nom, &den, fb_div_min, post_div_min);\r\nif (pll->flags & RADEON_PLL_PREFER_MINM_OVER_MAXP)\r\npost_div_best = post_div_min;\r\nelse\r\npost_div_best = post_div_max;\r\ndiff_best = ~0;\r\nfor (post_div = post_div_min; post_div <= post_div_max; ++post_div) {\r\nunsigned diff;\r\navivo_get_fb_ref_div(nom, den, post_div, fb_div_max,\r\nref_div_max, &fb_div, &ref_div);\r\ndiff = abs(target_clock - (pll->reference_freq * fb_div) /\r\n(ref_div * post_div));\r\nif (diff < diff_best || (diff == diff_best &&\r\n!(pll->flags & RADEON_PLL_PREFER_MINM_OVER_MAXP))) {\r\npost_div_best = post_div;\r\ndiff_best = diff;\r\n}\r\n}\r\npost_div = post_div_best;\r\navivo_get_fb_ref_div(nom, den, post_div, fb_div_max, ref_div_max,\r\n&fb_div, &ref_div);\r\navivo_reduce_ratio(&fb_div, &ref_div, fb_div_min, ref_div_min);\r\nif (pll->flags & RADEON_PLL_USE_FRAC_FB_DIV && (fb_div % 10)) {\r\nfb_div_min = max(fb_div_min, (9 - (fb_div % 10)) * 20 + 50);\r\nif (fb_div < fb_div_min) {\r\nunsigned tmp = DIV_ROUND_UP(fb_div_min, fb_div);\r\nfb_div *= tmp;\r\nref_div *= tmp;\r\n}\r\n}\r\nif (pll->flags & RADEON_PLL_USE_FRAC_FB_DIV) {\r\n*fb_div_p = fb_div / 10;\r\n*frac_fb_div_p = fb_div % 10;\r\n} else {\r\n*fb_div_p = fb_div;\r\n*frac_fb_div_p = 0;\r\n}\r\n*dot_clock_p = ((pll->reference_freq * *fb_div_p * 10) +\r\n(pll->reference_freq * *frac_fb_div_p)) /\r\n(ref_div * post_div * 10);\r\n*ref_div_p = ref_div;\r\n*post_div_p = post_div;\r\nDRM_DEBUG_KMS("%d - %d, pll dividers - fb: %d.%d ref: %d, post %d\n",\r\nfreq, *dot_clock_p * 10, *fb_div_p, *frac_fb_div_p,\r\nref_div, post_div);\r\n}\r\nstatic inline uint32_t radeon_div(uint64_t n, uint32_t d)\r\n{\r\nuint64_t mod;\r\nn += d / 2;\r\nmod = do_div(n, d);\r\nreturn n;\r\n}\r\nvoid radeon_compute_pll_legacy(struct radeon_pll *pll,\r\nuint64_t freq,\r\nuint32_t *dot_clock_p,\r\nuint32_t *fb_div_p,\r\nuint32_t *frac_fb_div_p,\r\nuint32_t *ref_div_p,\r\nuint32_t *post_div_p)\r\n{\r\nuint32_t min_ref_div = pll->min_ref_div;\r\nuint32_t max_ref_div = pll->max_ref_div;\r\nuint32_t min_post_div = pll->min_post_div;\r\nuint32_t max_post_div = pll->max_post_div;\r\nuint32_t min_fractional_feed_div = 0;\r\nuint32_t max_fractional_feed_div = 0;\r\nuint32_t best_vco = pll->best_vco;\r\nuint32_t best_post_div = 1;\r\nuint32_t best_ref_div = 1;\r\nuint32_t best_feedback_div = 1;\r\nuint32_t best_frac_feedback_div = 0;\r\nuint32_t best_freq = -1;\r\nuint32_t best_error = 0xffffffff;\r\nuint32_t best_vco_diff = 1;\r\nuint32_t post_div;\r\nu32 pll_out_min, pll_out_max;\r\nDRM_DEBUG_KMS("PLL freq %llu %u %u\n", freq, pll->min_ref_div, pll->max_ref_div);\r\nfreq = freq * 1000;\r\nif (pll->flags & RADEON_PLL_IS_LCD) {\r\npll_out_min = pll->lcd_pll_out_min;\r\npll_out_max = pll->lcd_pll_out_max;\r\n} else {\r\npll_out_min = pll->pll_out_min;\r\npll_out_max = pll->pll_out_max;\r\n}\r\nif (pll_out_min > 64800)\r\npll_out_min = 64800;\r\nif (pll->flags & RADEON_PLL_USE_REF_DIV)\r\nmin_ref_div = max_ref_div = pll->reference_div;\r\nelse {\r\nwhile (min_ref_div < max_ref_div-1) {\r\nuint32_t mid = (min_ref_div + max_ref_div) / 2;\r\nuint32_t pll_in = pll->reference_freq / mid;\r\nif (pll_in < pll->pll_in_min)\r\nmax_ref_div = mid;\r\nelse if (pll_in > pll->pll_in_max)\r\nmin_ref_div = mid;\r\nelse\r\nbreak;\r\n}\r\n}\r\nif (pll->flags & RADEON_PLL_USE_POST_DIV)\r\nmin_post_div = max_post_div = pll->post_div;\r\nif (pll->flags & RADEON_PLL_USE_FRAC_FB_DIV) {\r\nmin_fractional_feed_div = pll->min_frac_feedback_div;\r\nmax_fractional_feed_div = pll->max_frac_feedback_div;\r\n}\r\nfor (post_div = max_post_div; post_div >= min_post_div; --post_div) {\r\nuint32_t ref_div;\r\nif ((pll->flags & RADEON_PLL_NO_ODD_POST_DIV) && (post_div & 1))\r\ncontinue;\r\nif (pll->flags & RADEON_PLL_LEGACY) {\r\nif ((post_div == 5) ||\r\n(post_div == 7) ||\r\n(post_div == 9) ||\r\n(post_div == 10) ||\r\n(post_div == 11) ||\r\n(post_div == 13) ||\r\n(post_div == 14) ||\r\n(post_div == 15))\r\ncontinue;\r\n}\r\nfor (ref_div = min_ref_div; ref_div <= max_ref_div; ++ref_div) {\r\nuint32_t feedback_div, current_freq = 0, error, vco_diff;\r\nuint32_t pll_in = pll->reference_freq / ref_div;\r\nuint32_t min_feed_div = pll->min_feedback_div;\r\nuint32_t max_feed_div = pll->max_feedback_div + 1;\r\nif (pll_in < pll->pll_in_min || pll_in > pll->pll_in_max)\r\ncontinue;\r\nwhile (min_feed_div < max_feed_div) {\r\nuint32_t vco;\r\nuint32_t min_frac_feed_div = min_fractional_feed_div;\r\nuint32_t max_frac_feed_div = max_fractional_feed_div + 1;\r\nuint32_t frac_feedback_div;\r\nuint64_t tmp;\r\nfeedback_div = (min_feed_div + max_feed_div) / 2;\r\ntmp = (uint64_t)pll->reference_freq * feedback_div;\r\nvco = radeon_div(tmp, ref_div);\r\nif (vco < pll_out_min) {\r\nmin_feed_div = feedback_div + 1;\r\ncontinue;\r\n} else if (vco > pll_out_max) {\r\nmax_feed_div = feedback_div;\r\ncontinue;\r\n}\r\nwhile (min_frac_feed_div < max_frac_feed_div) {\r\nfrac_feedback_div = (min_frac_feed_div + max_frac_feed_div) / 2;\r\ntmp = (uint64_t)pll->reference_freq * 10000 * feedback_div;\r\ntmp += (uint64_t)pll->reference_freq * 1000 * frac_feedback_div;\r\ncurrent_freq = radeon_div(tmp, ref_div * post_div);\r\nif (pll->flags & RADEON_PLL_PREFER_CLOSEST_LOWER) {\r\nif (freq < current_freq)\r\nerror = 0xffffffff;\r\nelse\r\nerror = freq - current_freq;\r\n} else\r\nerror = abs(current_freq - freq);\r\nvco_diff = abs(vco - best_vco);\r\nif ((best_vco == 0 && error < best_error) ||\r\n(best_vco != 0 &&\r\n((best_error > 100 && error < best_error - 100) ||\r\n(abs(error - best_error) < 100 && vco_diff < best_vco_diff)))) {\r\nbest_post_div = post_div;\r\nbest_ref_div = ref_div;\r\nbest_feedback_div = feedback_div;\r\nbest_frac_feedback_div = frac_feedback_div;\r\nbest_freq = current_freq;\r\nbest_error = error;\r\nbest_vco_diff = vco_diff;\r\n} else if (current_freq == freq) {\r\nif (best_freq == -1) {\r\nbest_post_div = post_div;\r\nbest_ref_div = ref_div;\r\nbest_feedback_div = feedback_div;\r\nbest_frac_feedback_div = frac_feedback_div;\r\nbest_freq = current_freq;\r\nbest_error = error;\r\nbest_vco_diff = vco_diff;\r\n} else if (((pll->flags & RADEON_PLL_PREFER_LOW_REF_DIV) && (ref_div < best_ref_div)) ||\r\n((pll->flags & RADEON_PLL_PREFER_HIGH_REF_DIV) && (ref_div > best_ref_div)) ||\r\n((pll->flags & RADEON_PLL_PREFER_LOW_FB_DIV) && (feedback_div < best_feedback_div)) ||\r\n((pll->flags & RADEON_PLL_PREFER_HIGH_FB_DIV) && (feedback_div > best_feedback_div)) ||\r\n((pll->flags & RADEON_PLL_PREFER_LOW_POST_DIV) && (post_div < best_post_div)) ||\r\n((pll->flags & RADEON_PLL_PREFER_HIGH_POST_DIV) && (post_div > best_post_div))) {\r\nbest_post_div = post_div;\r\nbest_ref_div = ref_div;\r\nbest_feedback_div = feedback_div;\r\nbest_frac_feedback_div = frac_feedback_div;\r\nbest_freq = current_freq;\r\nbest_error = error;\r\nbest_vco_diff = vco_diff;\r\n}\r\n}\r\nif (current_freq < freq)\r\nmin_frac_feed_div = frac_feedback_div + 1;\r\nelse\r\nmax_frac_feed_div = frac_feedback_div;\r\n}\r\nif (current_freq < freq)\r\nmin_feed_div = feedback_div + 1;\r\nelse\r\nmax_feed_div = feedback_div;\r\n}\r\n}\r\n}\r\n*dot_clock_p = best_freq / 10000;\r\n*fb_div_p = best_feedback_div;\r\n*frac_fb_div_p = best_frac_feedback_div;\r\n*ref_div_p = best_ref_div;\r\n*post_div_p = best_post_div;\r\nDRM_DEBUG_KMS("%lld %d, pll dividers - fb: %d.%d ref: %d, post %d\n",\r\n(long long)freq,\r\nbest_freq / 1000, best_feedback_div, best_frac_feedback_div,\r\nbest_ref_div, best_post_div);\r\n}\r\nstatic void radeon_user_framebuffer_destroy(struct drm_framebuffer *fb)\r\n{\r\nstruct radeon_framebuffer *radeon_fb = to_radeon_framebuffer(fb);\r\nif (radeon_fb->obj) {\r\ndrm_gem_object_unreference_unlocked(radeon_fb->obj);\r\n}\r\ndrm_framebuffer_cleanup(fb);\r\nkfree(radeon_fb);\r\n}\r\nstatic int radeon_user_framebuffer_create_handle(struct drm_framebuffer *fb,\r\nstruct drm_file *file_priv,\r\nunsigned int *handle)\r\n{\r\nstruct radeon_framebuffer *radeon_fb = to_radeon_framebuffer(fb);\r\nreturn drm_gem_handle_create(file_priv, radeon_fb->obj, handle);\r\n}\r\nint\r\nradeon_framebuffer_init(struct drm_device *dev,\r\nstruct radeon_framebuffer *rfb,\r\nstruct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct drm_gem_object *obj)\r\n{\r\nint ret;\r\nrfb->obj = obj;\r\ndrm_helper_mode_fill_fb_struct(&rfb->base, mode_cmd);\r\nret = drm_framebuffer_init(dev, &rfb->base, &radeon_fb_funcs);\r\nif (ret) {\r\nrfb->obj = NULL;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct drm_framebuffer *\r\nradeon_user_framebuffer_create(struct drm_device *dev,\r\nstruct drm_file *file_priv,\r\nstruct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nstruct drm_gem_object *obj;\r\nstruct radeon_framebuffer *radeon_fb;\r\nint ret;\r\nobj = drm_gem_object_lookup(dev, file_priv, mode_cmd->handles[0]);\r\nif (obj == NULL) {\r\ndev_err(&dev->pdev->dev, "No GEM object associated to handle 0x%08X, "\r\n"can't create framebuffer\n", mode_cmd->handles[0]);\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nradeon_fb = kzalloc(sizeof(*radeon_fb), GFP_KERNEL);\r\nif (radeon_fb == NULL) {\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nret = radeon_framebuffer_init(dev, radeon_fb, mode_cmd, obj);\r\nif (ret) {\r\nkfree(radeon_fb);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn &radeon_fb->base;\r\n}\r\nstatic void radeon_output_poll_changed(struct drm_device *dev)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nradeon_fb_output_poll_changed(rdev);\r\n}\r\nstatic int radeon_modeset_create_props(struct radeon_device *rdev)\r\n{\r\nint sz;\r\nif (rdev->is_atom_bios) {\r\nrdev->mode_info.coherent_mode_property =\r\ndrm_property_create_range(rdev->ddev, 0 , "coherent", 0, 1);\r\nif (!rdev->mode_info.coherent_mode_property)\r\nreturn -ENOMEM;\r\n}\r\nif (!ASIC_IS_AVIVO(rdev)) {\r\nsz = ARRAY_SIZE(radeon_tmds_pll_enum_list);\r\nrdev->mode_info.tmds_pll_property =\r\ndrm_property_create_enum(rdev->ddev, 0,\r\n"tmds_pll",\r\nradeon_tmds_pll_enum_list, sz);\r\n}\r\nrdev->mode_info.load_detect_property =\r\ndrm_property_create_range(rdev->ddev, 0, "load detection", 0, 1);\r\nif (!rdev->mode_info.load_detect_property)\r\nreturn -ENOMEM;\r\ndrm_mode_create_scaling_mode_property(rdev->ddev);\r\nsz = ARRAY_SIZE(radeon_tv_std_enum_list);\r\nrdev->mode_info.tv_std_property =\r\ndrm_property_create_enum(rdev->ddev, 0,\r\n"tv standard",\r\nradeon_tv_std_enum_list, sz);\r\nsz = ARRAY_SIZE(radeon_underscan_enum_list);\r\nrdev->mode_info.underscan_property =\r\ndrm_property_create_enum(rdev->ddev, 0,\r\n"underscan",\r\nradeon_underscan_enum_list, sz);\r\nrdev->mode_info.underscan_hborder_property =\r\ndrm_property_create_range(rdev->ddev, 0,\r\n"underscan hborder", 0, 128);\r\nif (!rdev->mode_info.underscan_hborder_property)\r\nreturn -ENOMEM;\r\nrdev->mode_info.underscan_vborder_property =\r\ndrm_property_create_range(rdev->ddev, 0,\r\n"underscan vborder", 0, 128);\r\nif (!rdev->mode_info.underscan_vborder_property)\r\nreturn -ENOMEM;\r\nsz = ARRAY_SIZE(radeon_audio_enum_list);\r\nrdev->mode_info.audio_property =\r\ndrm_property_create_enum(rdev->ddev, 0,\r\n"audio",\r\nradeon_audio_enum_list, sz);\r\nsz = ARRAY_SIZE(radeon_dither_enum_list);\r\nrdev->mode_info.dither_property =\r\ndrm_property_create_enum(rdev->ddev, 0,\r\n"dither",\r\nradeon_dither_enum_list, sz);\r\nreturn 0;\r\n}\r\nvoid radeon_update_display_priority(struct radeon_device *rdev)\r\n{\r\nif ((radeon_disp_priority == 0) || (radeon_disp_priority > 2)) {\r\nif ((ASIC_IS_R300(rdev) || (rdev->family == CHIP_RV515)) &&\r\n!(rdev->flags & RADEON_IS_IGP))\r\nrdev->disp_priority = 2;\r\nelse\r\nrdev->disp_priority = 0;\r\n} else\r\nrdev->disp_priority = radeon_disp_priority;\r\n}\r\nstatic void radeon_afmt_init(struct radeon_device *rdev)\r\n{\r\nint i;\r\nfor (i = 0; i < RADEON_MAX_AFMT_BLOCKS; i++)\r\nrdev->mode_info.afmt[i] = NULL;\r\nif (ASIC_IS_NODCE(rdev)) {\r\n} else if (ASIC_IS_DCE4(rdev)) {\r\nstatic uint32_t eg_offsets[] = {\r\nEVERGREEN_CRTC0_REGISTER_OFFSET,\r\nEVERGREEN_CRTC1_REGISTER_OFFSET,\r\nEVERGREEN_CRTC2_REGISTER_OFFSET,\r\nEVERGREEN_CRTC3_REGISTER_OFFSET,\r\nEVERGREEN_CRTC4_REGISTER_OFFSET,\r\nEVERGREEN_CRTC5_REGISTER_OFFSET,\r\n0x13830 - 0x7030,\r\n};\r\nint num_afmt;\r\nif (ASIC_IS_DCE8(rdev))\r\nnum_afmt = 7;\r\nelse if (ASIC_IS_DCE6(rdev))\r\nnum_afmt = 6;\r\nelse if (ASIC_IS_DCE5(rdev))\r\nnum_afmt = 6;\r\nelse if (ASIC_IS_DCE41(rdev))\r\nnum_afmt = 2;\r\nelse\r\nnum_afmt = 6;\r\nBUG_ON(num_afmt > ARRAY_SIZE(eg_offsets));\r\nfor (i = 0; i < num_afmt; i++) {\r\nrdev->mode_info.afmt[i] = kzalloc(sizeof(struct radeon_afmt), GFP_KERNEL);\r\nif (rdev->mode_info.afmt[i]) {\r\nrdev->mode_info.afmt[i]->offset = eg_offsets[i];\r\nrdev->mode_info.afmt[i]->id = i;\r\n}\r\n}\r\n} else if (ASIC_IS_DCE3(rdev)) {\r\nrdev->mode_info.afmt[0] = kzalloc(sizeof(struct radeon_afmt), GFP_KERNEL);\r\nif (rdev->mode_info.afmt[0]) {\r\nrdev->mode_info.afmt[0]->offset = DCE3_HDMI_OFFSET0;\r\nrdev->mode_info.afmt[0]->id = 0;\r\n}\r\nrdev->mode_info.afmt[1] = kzalloc(sizeof(struct radeon_afmt), GFP_KERNEL);\r\nif (rdev->mode_info.afmt[1]) {\r\nrdev->mode_info.afmt[1]->offset = DCE3_HDMI_OFFSET1;\r\nrdev->mode_info.afmt[1]->id = 1;\r\n}\r\n} else if (ASIC_IS_DCE2(rdev)) {\r\nrdev->mode_info.afmt[0] = kzalloc(sizeof(struct radeon_afmt), GFP_KERNEL);\r\nif (rdev->mode_info.afmt[0]) {\r\nrdev->mode_info.afmt[0]->offset = DCE2_HDMI_OFFSET0;\r\nrdev->mode_info.afmt[0]->id = 0;\r\n}\r\nif (rdev->family >= CHIP_R600) {\r\nrdev->mode_info.afmt[1] = kzalloc(sizeof(struct radeon_afmt), GFP_KERNEL);\r\nif (rdev->mode_info.afmt[1]) {\r\nrdev->mode_info.afmt[1]->offset = DCE2_HDMI_OFFSET1;\r\nrdev->mode_info.afmt[1]->id = 1;\r\n}\r\n}\r\n}\r\n}\r\nstatic void radeon_afmt_fini(struct radeon_device *rdev)\r\n{\r\nint i;\r\nfor (i = 0; i < RADEON_MAX_AFMT_BLOCKS; i++) {\r\nkfree(rdev->mode_info.afmt[i]);\r\nrdev->mode_info.afmt[i] = NULL;\r\n}\r\n}\r\nint radeon_modeset_init(struct radeon_device *rdev)\r\n{\r\nint i;\r\nint ret;\r\ndrm_mode_config_init(rdev->ddev);\r\nrdev->mode_info.mode_config_initialized = true;\r\nrdev->ddev->mode_config.funcs = &radeon_mode_funcs;\r\nif (ASIC_IS_DCE5(rdev)) {\r\nrdev->ddev->mode_config.max_width = 16384;\r\nrdev->ddev->mode_config.max_height = 16384;\r\n} else if (ASIC_IS_AVIVO(rdev)) {\r\nrdev->ddev->mode_config.max_width = 8192;\r\nrdev->ddev->mode_config.max_height = 8192;\r\n} else {\r\nrdev->ddev->mode_config.max_width = 4096;\r\nrdev->ddev->mode_config.max_height = 4096;\r\n}\r\nrdev->ddev->mode_config.preferred_depth = 24;\r\nrdev->ddev->mode_config.prefer_shadow = 1;\r\nrdev->ddev->mode_config.fb_base = rdev->mc.aper_base;\r\nret = radeon_modeset_create_props(rdev);\r\nif (ret) {\r\nreturn ret;\r\n}\r\nradeon_i2c_init(rdev);\r\nif (!rdev->is_atom_bios) {\r\nradeon_combios_check_hardcoded_edid(rdev);\r\n}\r\nfor (i = 0; i < rdev->num_crtc; i++) {\r\nradeon_crtc_init(rdev->ddev, i);\r\n}\r\nret = radeon_setup_enc_conn(rdev->ddev);\r\nif (!ret) {\r\nreturn ret;\r\n}\r\nif (rdev->is_atom_bios) {\r\nradeon_atom_encoder_init(rdev);\r\nradeon_atom_disp_eng_pll_init(rdev);\r\n}\r\nradeon_hpd_init(rdev);\r\nradeon_afmt_init(rdev);\r\nradeon_fbdev_init(rdev);\r\ndrm_kms_helper_poll_init(rdev->ddev);\r\nif (rdev->pm.dpm_enabled) {\r\nret = radeon_pm_late_init(rdev);\r\nif (ret) {\r\nrdev->pm.dpm_enabled = false;\r\nDRM_ERROR("radeon_pm_late_init failed, disabling dpm\n");\r\n}\r\nradeon_pm_compute_clocks(rdev);\r\n}\r\nreturn 0;\r\n}\r\nvoid radeon_modeset_fini(struct radeon_device *rdev)\r\n{\r\nradeon_fbdev_fini(rdev);\r\nkfree(rdev->mode_info.bios_hardcoded_edid);\r\nif (rdev->mode_info.mode_config_initialized) {\r\nradeon_afmt_fini(rdev);\r\ndrm_kms_helper_poll_fini(rdev->ddev);\r\nradeon_hpd_fini(rdev);\r\ndrm_mode_config_cleanup(rdev->ddev);\r\nrdev->mode_info.mode_config_initialized = false;\r\n}\r\nradeon_i2c_fini(rdev);\r\n}\r\nstatic bool is_hdtv_mode(const struct drm_display_mode *mode)\r\n{\r\nif ((mode->vdisplay == 480 && mode->hdisplay == 720) ||\r\n(mode->vdisplay == 576) ||\r\n(mode->vdisplay == 720) ||\r\n(mode->vdisplay == 1080))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nbool radeon_crtc_scaling_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct drm_encoder *encoder;\r\nstruct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);\r\nstruct radeon_encoder *radeon_encoder;\r\nstruct drm_connector *connector;\r\nstruct radeon_connector *radeon_connector;\r\nbool first = true;\r\nu32 src_v = 1, dst_v = 1;\r\nu32 src_h = 1, dst_h = 1;\r\nradeon_crtc->h_border = 0;\r\nradeon_crtc->v_border = 0;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (encoder->crtc != crtc)\r\ncontinue;\r\nradeon_encoder = to_radeon_encoder(encoder);\r\nconnector = radeon_get_connector_for_encoder(encoder);\r\nradeon_connector = to_radeon_connector(connector);\r\nif (first) {\r\nif (radeon_encoder->rmx_type == RMX_OFF)\r\nradeon_crtc->rmx_type = RMX_OFF;\r\nelse if (mode->hdisplay < radeon_encoder->native_mode.hdisplay ||\r\nmode->vdisplay < radeon_encoder->native_mode.vdisplay)\r\nradeon_crtc->rmx_type = radeon_encoder->rmx_type;\r\nelse\r\nradeon_crtc->rmx_type = RMX_OFF;\r\nmemcpy(&radeon_crtc->native_mode,\r\n&radeon_encoder->native_mode,\r\nsizeof(struct drm_display_mode));\r\nsrc_v = crtc->mode.vdisplay;\r\ndst_v = radeon_crtc->native_mode.vdisplay;\r\nsrc_h = crtc->mode.hdisplay;\r\ndst_h = radeon_crtc->native_mode.hdisplay;\r\nif (ASIC_IS_AVIVO(rdev) &&\r\n(!(mode->flags & DRM_MODE_FLAG_INTERLACE)) &&\r\n((radeon_encoder->underscan_type == UNDERSCAN_ON) ||\r\n((radeon_encoder->underscan_type == UNDERSCAN_AUTO) &&\r\ndrm_detect_hdmi_monitor(radeon_connector_edid(connector)) &&\r\nis_hdtv_mode(mode)))) {\r\nif (radeon_encoder->underscan_hborder != 0)\r\nradeon_crtc->h_border = radeon_encoder->underscan_hborder;\r\nelse\r\nradeon_crtc->h_border = (mode->hdisplay >> 5) + 16;\r\nif (radeon_encoder->underscan_vborder != 0)\r\nradeon_crtc->v_border = radeon_encoder->underscan_vborder;\r\nelse\r\nradeon_crtc->v_border = (mode->vdisplay >> 5) + 16;\r\nradeon_crtc->rmx_type = RMX_FULL;\r\nsrc_v = crtc->mode.vdisplay;\r\ndst_v = crtc->mode.vdisplay - (radeon_crtc->v_border * 2);\r\nsrc_h = crtc->mode.hdisplay;\r\ndst_h = crtc->mode.hdisplay - (radeon_crtc->h_border * 2);\r\n}\r\nfirst = false;\r\n} else {\r\nif (radeon_crtc->rmx_type != radeon_encoder->rmx_type) {\r\nDRM_ERROR("Scaling not consistent across encoder.\n");\r\nreturn false;\r\n}\r\n}\r\n}\r\nif (radeon_crtc->rmx_type != RMX_OFF) {\r\nfixed20_12 a, b;\r\na.full = dfixed_const(src_v);\r\nb.full = dfixed_const(dst_v);\r\nradeon_crtc->vsc.full = dfixed_div(a, b);\r\na.full = dfixed_const(src_h);\r\nb.full = dfixed_const(dst_h);\r\nradeon_crtc->hsc.full = dfixed_div(a, b);\r\n} else {\r\nradeon_crtc->vsc.full = dfixed_const(1);\r\nradeon_crtc->hsc.full = dfixed_const(1);\r\n}\r\nreturn true;\r\n}\r\nint radeon_get_crtc_scanoutpos(struct drm_device *dev, int crtc, unsigned int flags,\r\nint *vpos, int *hpos, ktime_t *stime, ktime_t *etime)\r\n{\r\nu32 stat_crtc = 0, vbl = 0, position = 0;\r\nint vbl_start, vbl_end, vtotal, ret = 0;\r\nbool in_vbl = true;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (stime)\r\n*stime = ktime_get();\r\nif (ASIC_IS_DCE4(rdev)) {\r\nif (crtc == 0) {\r\nvbl = RREG32(EVERGREEN_CRTC_V_BLANK_START_END +\r\nEVERGREEN_CRTC0_REGISTER_OFFSET);\r\nposition = RREG32(EVERGREEN_CRTC_STATUS_POSITION +\r\nEVERGREEN_CRTC0_REGISTER_OFFSET);\r\nret |= DRM_SCANOUTPOS_VALID;\r\n}\r\nif (crtc == 1) {\r\nvbl = RREG32(EVERGREEN_CRTC_V_BLANK_START_END +\r\nEVERGREEN_CRTC1_REGISTER_OFFSET);\r\nposition = RREG32(EVERGREEN_CRTC_STATUS_POSITION +\r\nEVERGREEN_CRTC1_REGISTER_OFFSET);\r\nret |= DRM_SCANOUTPOS_VALID;\r\n}\r\nif (crtc == 2) {\r\nvbl = RREG32(EVERGREEN_CRTC_V_BLANK_START_END +\r\nEVERGREEN_CRTC2_REGISTER_OFFSET);\r\nposition = RREG32(EVERGREEN_CRTC_STATUS_POSITION +\r\nEVERGREEN_CRTC2_REGISTER_OFFSET);\r\nret |= DRM_SCANOUTPOS_VALID;\r\n}\r\nif (crtc == 3) {\r\nvbl = RREG32(EVERGREEN_CRTC_V_BLANK_START_END +\r\nEVERGREEN_CRTC3_REGISTER_OFFSET);\r\nposition = RREG32(EVERGREEN_CRTC_STATUS_POSITION +\r\nEVERGREEN_CRTC3_REGISTER_OFFSET);\r\nret |= DRM_SCANOUTPOS_VALID;\r\n}\r\nif (crtc == 4) {\r\nvbl = RREG32(EVERGREEN_CRTC_V_BLANK_START_END +\r\nEVERGREEN_CRTC4_REGISTER_OFFSET);\r\nposition = RREG32(EVERGREEN_CRTC_STATUS_POSITION +\r\nEVERGREEN_CRTC4_REGISTER_OFFSET);\r\nret |= DRM_SCANOUTPOS_VALID;\r\n}\r\nif (crtc == 5) {\r\nvbl = RREG32(EVERGREEN_CRTC_V_BLANK_START_END +\r\nEVERGREEN_CRTC5_REGISTER_OFFSET);\r\nposition = RREG32(EVERGREEN_CRTC_STATUS_POSITION +\r\nEVERGREEN_CRTC5_REGISTER_OFFSET);\r\nret |= DRM_SCANOUTPOS_VALID;\r\n}\r\n} else if (ASIC_IS_AVIVO(rdev)) {\r\nif (crtc == 0) {\r\nvbl = RREG32(AVIVO_D1CRTC_V_BLANK_START_END);\r\nposition = RREG32(AVIVO_D1CRTC_STATUS_POSITION);\r\nret |= DRM_SCANOUTPOS_VALID;\r\n}\r\nif (crtc == 1) {\r\nvbl = RREG32(AVIVO_D2CRTC_V_BLANK_START_END);\r\nposition = RREG32(AVIVO_D2CRTC_STATUS_POSITION);\r\nret |= DRM_SCANOUTPOS_VALID;\r\n}\r\n} else {\r\nif (crtc == 0) {\r\nvbl = (RREG32(RADEON_CRTC_V_TOTAL_DISP) &\r\nRADEON_CRTC_V_DISP) >> RADEON_CRTC_V_DISP_SHIFT;\r\nposition = (RREG32(RADEON_CRTC_VLINE_CRNT_VLINE) >> 16) & RADEON_CRTC_V_TOTAL;\r\nstat_crtc = RREG32(RADEON_CRTC_STATUS);\r\nif (!(stat_crtc & 1))\r\nin_vbl = false;\r\nret |= DRM_SCANOUTPOS_VALID;\r\n}\r\nif (crtc == 1) {\r\nvbl = (RREG32(RADEON_CRTC2_V_TOTAL_DISP) &\r\nRADEON_CRTC_V_DISP) >> RADEON_CRTC_V_DISP_SHIFT;\r\nposition = (RREG32(RADEON_CRTC2_VLINE_CRNT_VLINE) >> 16) & RADEON_CRTC_V_TOTAL;\r\nstat_crtc = RREG32(RADEON_CRTC2_STATUS);\r\nif (!(stat_crtc & 1))\r\nin_vbl = false;\r\nret |= DRM_SCANOUTPOS_VALID;\r\n}\r\n}\r\nif (etime)\r\n*etime = ktime_get();\r\n*vpos = position & 0x1fff;\r\n*hpos = (position >> 16) & 0x1fff;\r\nif (vbl > 0) {\r\nret |= DRM_SCANOUTPOS_ACCURATE;\r\nvbl_start = vbl & 0x1fff;\r\nvbl_end = (vbl >> 16) & 0x1fff;\r\n}\r\nelse {\r\nvbl_start = rdev->mode_info.crtcs[crtc]->base.hwmode.crtc_vdisplay;\r\nvbl_end = 0;\r\n}\r\nif ((*vpos < vbl_start) && (*vpos >= vbl_end))\r\nin_vbl = false;\r\nif (in_vbl && (*vpos >= vbl_start)) {\r\nvtotal = rdev->mode_info.crtcs[crtc]->base.hwmode.crtc_vtotal;\r\n*vpos = *vpos - vtotal;\r\n}\r\n*vpos = *vpos - vbl_end;\r\nif (in_vbl)\r\nret |= DRM_SCANOUTPOS_IN_VBLANK;\r\nif ((flags & DRM_CALLED_FROM_VBLIRQ) && !in_vbl) {\r\nvbl_start = rdev->mode_info.crtcs[crtc]->base.hwmode.crtc_vdisplay;\r\nvtotal = rdev->mode_info.crtcs[crtc]->base.hwmode.crtc_vtotal;\r\nif (vbl_start - *vpos < vtotal / 100) {\r\n*vpos -= vtotal;\r\nret |= 0x8;\r\n}\r\n}\r\nreturn ret;\r\n}
