static int gic_next_event(unsigned long delta, struct clock_event_device *evt)\r\n{\r\nu64 cnt;\r\nint res;\r\ncnt = gic_read_count();\r\ncnt += (u64)delta;\r\ngic_write_cpu_compare(cnt, cpumask_first(evt->cpumask));\r\nres = ((int)(gic_read_count() - cnt) >= 0) ? -ETIME : 0;\r\nreturn res;\r\n}\r\nstatic void gic_set_clock_mode(enum clock_event_mode mode,\r\nstruct clock_event_device *evt)\r\n{\r\n}\r\nstatic irqreturn_t gic_compare_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *cd = dev_id;\r\ngic_write_compare(gic_read_compare());\r\ncd->event_handler(cd);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void gic_clockevent_cpu_init(struct clock_event_device *cd)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\ncd->name = "MIPS GIC";\r\ncd->features = CLOCK_EVT_FEAT_ONESHOT |\r\nCLOCK_EVT_FEAT_C3STOP;\r\ncd->rating = 350;\r\ncd->irq = gic_timer_irq;\r\ncd->cpumask = cpumask_of(cpu);\r\ncd->set_next_event = gic_next_event;\r\ncd->set_mode = gic_set_clock_mode;\r\nclockevents_config_and_register(cd, gic_frequency, 0x300, 0x7fffffff);\r\nenable_percpu_irq(gic_timer_irq, IRQ_TYPE_NONE);\r\n}\r\nstatic void gic_clockevent_cpu_exit(struct clock_event_device *cd)\r\n{\r\ndisable_percpu_irq(gic_timer_irq);\r\n}\r\nstatic int gic_cpu_notifier(struct notifier_block *nb, unsigned long action,\r\nvoid *data)\r\n{\r\nswitch (action & ~CPU_TASKS_FROZEN) {\r\ncase CPU_STARTING:\r\ngic_clockevent_cpu_init(this_cpu_ptr(&gic_clockevent_device));\r\nbreak;\r\ncase CPU_DYING:\r\ngic_clockevent_cpu_exit(this_cpu_ptr(&gic_clockevent_device));\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int gic_clockevent_init(void)\r\n{\r\nif (!cpu_has_counter || !gic_frequency)\r\nreturn -ENXIO;\r\nsetup_percpu_irq(gic_timer_irq, &gic_compare_irqaction);\r\nregister_cpu_notifier(&gic_cpu_nb);\r\ngic_clockevent_cpu_init(this_cpu_ptr(&gic_clockevent_device));\r\nreturn 0;\r\n}\r\nstatic cycle_t gic_hpt_read(struct clocksource *cs)\r\n{\r\nreturn gic_read_count();\r\n}\r\nstatic void __init __gic_clocksource_init(void)\r\n{\r\ngic_clocksource.mask = CLOCKSOURCE_MASK(gic_get_count_width());\r\ngic_clocksource.rating = 200 + gic_frequency / 10000000;\r\nclocksource_register_hz(&gic_clocksource, gic_frequency);\r\ngic_clockevent_init();\r\n}\r\nvoid __init gic_clocksource_init(unsigned int frequency)\r\n{\r\ngic_frequency = frequency;\r\ngic_timer_irq = MIPS_GIC_IRQ_BASE +\r\nGIC_LOCAL_TO_HWIRQ(GIC_LOCAL_INT_COMPARE);\r\n__gic_clocksource_init();\r\n}\r\nstatic void __init gic_clocksource_of_init(struct device_node *node)\r\n{\r\nif (WARN_ON(!gic_present || !node->parent ||\r\n!of_device_is_compatible(node->parent, "mti,gic")))\r\nreturn;\r\nif (of_property_read_u32(node, "clock-frequency", &gic_frequency)) {\r\npr_err("GIC frequency not specified.\n");\r\nreturn;\r\n}\r\ngic_timer_irq = irq_of_parse_and_map(node, 0);\r\nif (!gic_timer_irq) {\r\npr_err("GIC timer IRQ not specified.\n");\r\nreturn;\r\n}\r\n__gic_clocksource_init();\r\n}
