static int sti_compositor_init_subdev(struct sti_compositor *compo,\r\nstruct sti_compositor_subdev_descriptor *desc,\r\nunsigned int array_size)\r\n{\r\nunsigned int i, mixer_id = 0, layer_id = 0;\r\nfor (i = 0; i < array_size; i++) {\r\nswitch (desc[i].type) {\r\ncase STI_MIXER_MAIN_SUBDEV:\r\ncase STI_MIXER_AUX_SUBDEV:\r\ncompo->mixer[mixer_id++] =\r\nsti_mixer_create(compo->dev, desc[i].id,\r\ncompo->regs + desc[i].offset);\r\nbreak;\r\ncase STI_GPD_SUBDEV:\r\ncase STI_VID_SUBDEV:\r\ncase STI_CURSOR_SUBDEV:\r\ncompo->layer[layer_id++] =\r\nsti_layer_create(compo->dev, desc[i].id,\r\ncompo->regs + desc[i].offset);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknow subdev compoment type\n");\r\nreturn 1;\r\n}\r\n}\r\ncompo->nb_mixers = mixer_id;\r\ncompo->nb_layers = layer_id;\r\nreturn 0;\r\n}\r\nstatic int sti_compositor_bind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct sti_compositor *compo = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\nunsigned int i, crtc = 0, plane = 0;\r\nstruct sti_drm_private *dev_priv = drm_dev->dev_private;\r\nstruct drm_plane *cursor = NULL;\r\nstruct drm_plane *primary = NULL;\r\ndev_priv->compo = compo;\r\nfor (i = 0; i < compo->nb_layers; i++) {\r\nif (compo->layer[i]) {\r\nenum sti_layer_desc desc = compo->layer[i]->desc;\r\nenum sti_layer_type type = desc & STI_LAYER_TYPE_MASK;\r\nenum drm_plane_type plane_type = DRM_PLANE_TYPE_OVERLAY;\r\nif (crtc < compo->nb_mixers)\r\nplane_type = DRM_PLANE_TYPE_PRIMARY;\r\nswitch (type) {\r\ncase STI_CUR:\r\ncursor = sti_drm_plane_init(drm_dev,\r\ncompo->layer[i],\r\n1, DRM_PLANE_TYPE_CURSOR);\r\nbreak;\r\ncase STI_GDP:\r\ncase STI_VID:\r\nprimary = sti_drm_plane_init(drm_dev,\r\ncompo->layer[i],\r\n(1 << compo->nb_mixers) - 1,\r\nplane_type);\r\nplane++;\r\nbreak;\r\ncase STI_BCK:\r\ncase STI_VDP:\r\nbreak;\r\n}\r\nif (crtc < compo->nb_mixers && primary) {\r\nsti_drm_crtc_init(drm_dev, compo->mixer[crtc],\r\nprimary, cursor);\r\ncrtc++;\r\ncursor = NULL;\r\nprimary = NULL;\r\n}\r\n}\r\n}\r\ndrm_vblank_init(drm_dev, crtc);\r\ndrm_dev->irq_enabled = 1;\r\nDRM_DEBUG_DRIVER("Initialized %d DRM CRTC(s) and %d DRM plane(s)\n",\r\ncrtc, plane);\r\nDRM_DEBUG_DRIVER("DRM plane(s) for VID/VDP not created yet\n");\r\nreturn 0;\r\n}\r\nstatic void sti_compositor_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\n}\r\nstatic int sti_compositor_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *vtg_np;\r\nstruct sti_compositor *compo;\r\nstruct resource *res;\r\nint err;\r\ncompo = devm_kzalloc(dev, sizeof(*compo), GFP_KERNEL);\r\nif (!compo) {\r\nDRM_ERROR("Failed to allocate compositor context\n");\r\nreturn -ENOMEM;\r\n}\r\ncompo->dev = dev;\r\ncompo->vtg_vblank_nb.notifier_call = sti_drm_crtc_vblank_cb;\r\nBUG_ON(!of_match_node(compositor_of_match, np)->data);\r\nmemcpy(&compo->data, of_match_node(compositor_of_match, np)->data,\r\nsizeof(struct sti_compositor_data));\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\nDRM_ERROR("Get memory resource failed\n");\r\nreturn -ENXIO;\r\n}\r\ncompo->regs = devm_ioremap(dev, res->start, resource_size(res));\r\nif (compo->regs == NULL) {\r\nDRM_ERROR("Register mapping failed\n");\r\nreturn -ENXIO;\r\n}\r\ncompo->clk_compo_main = devm_clk_get(dev, "compo_main");\r\nif (IS_ERR(compo->clk_compo_main)) {\r\nDRM_ERROR("Cannot get compo_main clock\n");\r\nreturn PTR_ERR(compo->clk_compo_main);\r\n}\r\ncompo->clk_compo_aux = devm_clk_get(dev, "compo_aux");\r\nif (IS_ERR(compo->clk_compo_aux)) {\r\nDRM_ERROR("Cannot get compo_aux clock\n");\r\nreturn PTR_ERR(compo->clk_compo_aux);\r\n}\r\ncompo->clk_pix_main = devm_clk_get(dev, "pix_main");\r\nif (IS_ERR(compo->clk_pix_main)) {\r\nDRM_ERROR("Cannot get pix_main clock\n");\r\nreturn PTR_ERR(compo->clk_pix_main);\r\n}\r\ncompo->clk_pix_aux = devm_clk_get(dev, "pix_aux");\r\nif (IS_ERR(compo->clk_pix_aux)) {\r\nDRM_ERROR("Cannot get pix_aux clock\n");\r\nreturn PTR_ERR(compo->clk_pix_aux);\r\n}\r\ncompo->rst_main = devm_reset_control_get(dev, "compo-main");\r\nif (!IS_ERR(compo->rst_main))\r\nreset_control_deassert(compo->rst_main);\r\ncompo->rst_aux = devm_reset_control_get(dev, "compo-aux");\r\nif (!IS_ERR(compo->rst_aux))\r\nreset_control_deassert(compo->rst_aux);\r\nvtg_np = of_parse_phandle(pdev->dev.of_node, "st,vtg", 0);\r\nif (vtg_np)\r\ncompo->vtg_main = of_vtg_find(vtg_np);\r\nvtg_np = of_parse_phandle(pdev->dev.of_node, "st,vtg", 1);\r\nif (vtg_np)\r\ncompo->vtg_aux = of_vtg_find(vtg_np);\r\nerr = sti_compositor_init_subdev(compo, compo->data.subdev_desc,\r\ncompo->data.nb_subdev);\r\nif (err)\r\nreturn err;\r\nplatform_set_drvdata(pdev, compo);\r\nreturn component_add(&pdev->dev, &sti_compositor_ops);\r\n}\r\nstatic int sti_compositor_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &sti_compositor_ops);\r\nreturn 0;\r\n}
