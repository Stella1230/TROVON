void ldlm_convert_policy_to_wire(ldlm_type_t type,\r\nconst ldlm_policy_data_t *lpolicy,\r\nldlm_wire_policy_data_t *wpolicy)\r\n{\r\nldlm_policy_local_to_wire_t convert;\r\nconvert = ldlm_policy_local_to_wire[type - LDLM_MIN_TYPE];\r\nconvert(lpolicy, wpolicy);\r\n}\r\nvoid ldlm_convert_policy_to_local(struct obd_export *exp, ldlm_type_t type,\r\nconst ldlm_wire_policy_data_t *wpolicy,\r\nldlm_policy_data_t *lpolicy)\r\n{\r\nldlm_policy_wire_to_local_t convert;\r\nint new_client;\r\nnew_client = (exp_connect_flags(exp) & OBD_CONNECT_FULL20) != 0;\r\nif (new_client)\r\nconvert = ldlm_policy_wire21_to_local[type - LDLM_MIN_TYPE];\r\nelse\r\nconvert = ldlm_policy_wire18_to_local[type - LDLM_MIN_TYPE];\r\nconvert(wpolicy, lpolicy);\r\n}\r\nchar *ldlm_it2str(int it)\r\n{\r\nswitch (it) {\r\ncase IT_OPEN:\r\nreturn "open";\r\ncase IT_CREAT:\r\nreturn "creat";\r\ncase (IT_OPEN | IT_CREAT):\r\nreturn "open|creat";\r\ncase IT_READDIR:\r\nreturn "readdir";\r\ncase IT_GETATTR:\r\nreturn "getattr";\r\ncase IT_LOOKUP:\r\nreturn "lookup";\r\ncase IT_UNLINK:\r\nreturn "unlink";\r\ncase IT_GETXATTR:\r\nreturn "getxattr";\r\ncase IT_LAYOUT:\r\nreturn "layout";\r\ndefault:\r\nCERROR("Unknown intent %d\n", it);\r\nreturn "UNKNOWN";\r\n}\r\n}\r\nvoid ldlm_register_intent(struct ldlm_namespace *ns, ldlm_res_policy arg)\r\n{\r\nns->ns_policy = arg;\r\n}\r\nstruct ldlm_lock *ldlm_lock_get(struct ldlm_lock *lock)\r\n{\r\natomic_inc(&lock->l_refc);\r\nreturn lock;\r\n}\r\nvoid ldlm_lock_put(struct ldlm_lock *lock)\r\n{\r\nLASSERT(lock->l_resource != LP_POISON);\r\nLASSERT(atomic_read(&lock->l_refc) > 0);\r\nif (atomic_dec_and_test(&lock->l_refc)) {\r\nstruct ldlm_resource *res;\r\nLDLM_DEBUG(lock,\r\n"final lock_put on destroyed lock, freeing it.");\r\nres = lock->l_resource;\r\nLASSERT(lock->l_flags & LDLM_FL_DESTROYED);\r\nLASSERT(list_empty(&lock->l_res_link));\r\nLASSERT(list_empty(&lock->l_pending_chain));\r\nlprocfs_counter_decr(ldlm_res_to_ns(res)->ns_stats,\r\nLDLM_NSS_LOCKS);\r\nlu_ref_del(&res->lr_reference, "lock", lock);\r\nldlm_resource_putref(res);\r\nlock->l_resource = NULL;\r\nif (lock->l_export) {\r\nclass_export_lock_put(lock->l_export, lock);\r\nlock->l_export = NULL;\r\n}\r\nif (lock->l_lvb_data != NULL)\r\nOBD_FREE(lock->l_lvb_data, lock->l_lvb_len);\r\nldlm_interval_free(ldlm_interval_detach(lock));\r\nlu_ref_fini(&lock->l_reference);\r\nOBD_FREE_RCU(lock, sizeof(*lock), &lock->l_handle);\r\n}\r\n}\r\nint ldlm_lock_remove_from_lru_nolock(struct ldlm_lock *lock)\r\n{\r\nint rc = 0;\r\nif (!list_empty(&lock->l_lru)) {\r\nstruct ldlm_namespace *ns = ldlm_lock_to_ns(lock);\r\nLASSERT(lock->l_resource->lr_type != LDLM_FLOCK);\r\nlist_del_init(&lock->l_lru);\r\nLASSERT(ns->ns_nr_unused > 0);\r\nns->ns_nr_unused--;\r\nrc = 1;\r\n}\r\nreturn rc;\r\n}\r\nint ldlm_lock_remove_from_lru(struct ldlm_lock *lock)\r\n{\r\nstruct ldlm_namespace *ns = ldlm_lock_to_ns(lock);\r\nint rc;\r\nif (lock->l_flags & LDLM_FL_NS_SRV) {\r\nLASSERT(list_empty(&lock->l_lru));\r\nreturn 0;\r\n}\r\nspin_lock(&ns->ns_lock);\r\nrc = ldlm_lock_remove_from_lru_nolock(lock);\r\nspin_unlock(&ns->ns_lock);\r\nreturn rc;\r\n}\r\nvoid ldlm_lock_add_to_lru_nolock(struct ldlm_lock *lock)\r\n{\r\nstruct ldlm_namespace *ns = ldlm_lock_to_ns(lock);\r\nlock->l_last_used = cfs_time_current();\r\nLASSERT(list_empty(&lock->l_lru));\r\nLASSERT(lock->l_resource->lr_type != LDLM_FLOCK);\r\nlist_add_tail(&lock->l_lru, &ns->ns_unused_list);\r\nif (lock->l_flags & LDLM_FL_SKIPPED)\r\nlock->l_flags &= ~LDLM_FL_SKIPPED;\r\nLASSERT(ns->ns_nr_unused >= 0);\r\nns->ns_nr_unused++;\r\n}\r\nvoid ldlm_lock_add_to_lru(struct ldlm_lock *lock)\r\n{\r\nstruct ldlm_namespace *ns = ldlm_lock_to_ns(lock);\r\nspin_lock(&ns->ns_lock);\r\nldlm_lock_add_to_lru_nolock(lock);\r\nspin_unlock(&ns->ns_lock);\r\n}\r\nvoid ldlm_lock_touch_in_lru(struct ldlm_lock *lock)\r\n{\r\nstruct ldlm_namespace *ns = ldlm_lock_to_ns(lock);\r\nif (lock->l_flags & LDLM_FL_NS_SRV) {\r\nLASSERT(list_empty(&lock->l_lru));\r\nreturn;\r\n}\r\nspin_lock(&ns->ns_lock);\r\nif (!list_empty(&lock->l_lru)) {\r\nldlm_lock_remove_from_lru_nolock(lock);\r\nldlm_lock_add_to_lru_nolock(lock);\r\n}\r\nspin_unlock(&ns->ns_lock);\r\n}\r\nint ldlm_lock_destroy_internal(struct ldlm_lock *lock)\r\n{\r\nif (lock->l_readers || lock->l_writers) {\r\nLDLM_ERROR(lock, "lock still has references");\r\nLBUG();\r\n}\r\nif (!list_empty(&lock->l_res_link)) {\r\nLDLM_ERROR(lock, "lock still on resource");\r\nLBUG();\r\n}\r\nif (lock->l_flags & LDLM_FL_DESTROYED) {\r\nLASSERT(list_empty(&lock->l_lru));\r\nreturn 0;\r\n}\r\nlock->l_flags |= LDLM_FL_DESTROYED;\r\nif (lock->l_export && lock->l_export->exp_lock_hash) {\r\ncfs_hash_del(lock->l_export->exp_lock_hash,\r\n&lock->l_remote_handle, &lock->l_exp_hash);\r\n}\r\nldlm_lock_remove_from_lru(lock);\r\nclass_handle_unhash(&lock->l_handle);\r\n#if 0\r\nif (lock->l_export)\r\nclass_export_put(lock->l_export);\r\nlock->l_export = NULL;\r\nif (lock->l_export && lock->l_completion_ast)\r\nlock->l_completion_ast(lock, 0);\r\n#endif\r\nreturn 1;\r\n}\r\nvoid ldlm_lock_destroy(struct ldlm_lock *lock)\r\n{\r\nint first;\r\nlock_res_and_lock(lock);\r\nfirst = ldlm_lock_destroy_internal(lock);\r\nunlock_res_and_lock(lock);\r\nif (first) {\r\nlu_ref_del(&lock->l_reference, "hash", lock);\r\nLDLM_LOCK_RELEASE(lock);\r\n}\r\n}\r\nvoid ldlm_lock_destroy_nolock(struct ldlm_lock *lock)\r\n{\r\nint first;\r\nfirst = ldlm_lock_destroy_internal(lock);\r\nif (first) {\r\nlu_ref_del(&lock->l_reference, "hash", lock);\r\nLDLM_LOCK_RELEASE(lock);\r\n}\r\n}\r\nstatic void lock_handle_addref(void *lock)\r\n{\r\nLDLM_LOCK_GET((struct ldlm_lock *)lock);\r\n}\r\nstatic void lock_handle_free(void *lock, int size)\r\n{\r\nLASSERT(size == sizeof(struct ldlm_lock));\r\nOBD_SLAB_FREE(lock, ldlm_lock_slab, size);\r\n}\r\nstatic struct ldlm_lock *ldlm_lock_new(struct ldlm_resource *resource)\r\n{\r\nstruct ldlm_lock *lock;\r\nif (resource == NULL)\r\nLBUG();\r\nOBD_SLAB_ALLOC_PTR_GFP(lock, ldlm_lock_slab, GFP_NOFS);\r\nif (lock == NULL)\r\nreturn NULL;\r\nspin_lock_init(&lock->l_lock);\r\nlock->l_resource = resource;\r\nlu_ref_add(&resource->lr_reference, "lock", lock);\r\natomic_set(&lock->l_refc, 2);\r\nINIT_LIST_HEAD(&lock->l_res_link);\r\nINIT_LIST_HEAD(&lock->l_lru);\r\nINIT_LIST_HEAD(&lock->l_pending_chain);\r\nINIT_LIST_HEAD(&lock->l_bl_ast);\r\nINIT_LIST_HEAD(&lock->l_cp_ast);\r\nINIT_LIST_HEAD(&lock->l_rk_ast);\r\ninit_waitqueue_head(&lock->l_waitq);\r\nlock->l_blocking_lock = NULL;\r\nINIT_LIST_HEAD(&lock->l_sl_mode);\r\nINIT_LIST_HEAD(&lock->l_sl_policy);\r\nINIT_HLIST_NODE(&lock->l_exp_hash);\r\nINIT_HLIST_NODE(&lock->l_exp_flock_hash);\r\nlprocfs_counter_incr(ldlm_res_to_ns(resource)->ns_stats,\r\nLDLM_NSS_LOCKS);\r\nINIT_LIST_HEAD(&lock->l_handle.h_link);\r\nclass_handle_hash(&lock->l_handle, &lock_handle_ops);\r\nlu_ref_init(&lock->l_reference);\r\nlu_ref_add(&lock->l_reference, "hash", lock);\r\nlock->l_callback_timeout = 0;\r\n#if LUSTRE_TRACKS_LOCK_EXP_REFS\r\nINIT_LIST_HEAD(&lock->l_exp_refs_link);\r\nlock->l_exp_refs_nr = 0;\r\nlock->l_exp_refs_target = NULL;\r\n#endif\r\nINIT_LIST_HEAD(&lock->l_exp_list);\r\nreturn lock;\r\n}\r\nint ldlm_lock_change_resource(struct ldlm_namespace *ns, struct ldlm_lock *lock,\r\nconst struct ldlm_res_id *new_resid)\r\n{\r\nstruct ldlm_resource *oldres = lock->l_resource;\r\nstruct ldlm_resource *newres;\r\nint type;\r\nLASSERT(ns_is_client(ns));\r\nlock_res_and_lock(lock);\r\nif (memcmp(new_resid, &lock->l_resource->lr_name,\r\nsizeof(lock->l_resource->lr_name)) == 0) {\r\nunlock_res_and_lock(lock);\r\nreturn 0;\r\n}\r\nLASSERT(new_resid->name[0] != 0);\r\nLASSERT(list_empty(&lock->l_res_link));\r\ntype = oldres->lr_type;\r\nunlock_res_and_lock(lock);\r\nnewres = ldlm_resource_get(ns, NULL, new_resid, type, 1);\r\nif (newres == NULL)\r\nreturn -ENOMEM;\r\nlu_ref_add(&newres->lr_reference, "lock", lock);\r\nspin_lock(&lock->l_lock);\r\noldres = lock->l_resource;\r\nif (oldres < newres) {\r\nlock_res(oldres);\r\nlock_res_nested(newres, LRT_NEW);\r\n} else {\r\nlock_res(newres);\r\nlock_res_nested(oldres, LRT_NEW);\r\n}\r\nLASSERT(memcmp(new_resid, &oldres->lr_name,\r\nsizeof(oldres->lr_name)) != 0);\r\nlock->l_resource = newres;\r\nunlock_res(oldres);\r\nunlock_res_and_lock(lock);\r\nlu_ref_del(&oldres->lr_reference, "lock", lock);\r\nldlm_resource_putref(oldres);\r\nreturn 0;\r\n}\r\nvoid ldlm_lock2handle(const struct ldlm_lock *lock, struct lustre_handle *lockh)\r\n{\r\nlockh->cookie = lock->l_handle.h_cookie;\r\n}\r\nstruct ldlm_lock *__ldlm_handle2lock(const struct lustre_handle *handle,\r\n__u64 flags)\r\n{\r\nstruct ldlm_lock *lock;\r\nLASSERT(handle);\r\nlock = class_handle2object(handle->cookie);\r\nif (lock == NULL)\r\nreturn NULL;\r\nif (flags == 0 && ((lock->l_flags & LDLM_FL_DESTROYED) == 0)) {\r\nlu_ref_add(&lock->l_reference, "handle", current);\r\nreturn lock;\r\n}\r\nlock_res_and_lock(lock);\r\nLASSERT(lock->l_resource != NULL);\r\nlu_ref_add_atomic(&lock->l_reference, "handle", current);\r\nif (unlikely(lock->l_flags & LDLM_FL_DESTROYED)) {\r\nunlock_res_and_lock(lock);\r\nCDEBUG(D_INFO, "lock already destroyed: lock %p\n", lock);\r\nLDLM_LOCK_PUT(lock);\r\nreturn NULL;\r\n}\r\nif (flags && (lock->l_flags & flags)) {\r\nunlock_res_and_lock(lock);\r\nLDLM_LOCK_PUT(lock);\r\nreturn NULL;\r\n}\r\nif (flags)\r\nlock->l_flags |= flags;\r\nunlock_res_and_lock(lock);\r\nreturn lock;\r\n}\r\nvoid ldlm_lock2desc(struct ldlm_lock *lock, struct ldlm_lock_desc *desc)\r\n{\r\nldlm_res2desc(lock->l_resource, &desc->l_resource);\r\ndesc->l_req_mode = lock->l_req_mode;\r\ndesc->l_granted_mode = lock->l_granted_mode;\r\nldlm_convert_policy_to_wire(lock->l_resource->lr_type,\r\n&lock->l_policy_data,\r\n&desc->l_policy_data);\r\n}\r\nvoid ldlm_add_bl_work_item(struct ldlm_lock *lock, struct ldlm_lock *new,\r\nstruct list_head *work_list)\r\n{\r\nif ((lock->l_flags & LDLM_FL_AST_SENT) == 0) {\r\nLDLM_DEBUG(lock, "lock incompatible; sending blocking AST.");\r\nlock->l_flags |= LDLM_FL_AST_SENT;\r\nif (new->l_flags & LDLM_FL_AST_DISCARD_DATA)\r\nlock->l_flags |= LDLM_FL_DISCARD_DATA;\r\nLASSERT(list_empty(&lock->l_bl_ast));\r\nlist_add(&lock->l_bl_ast, work_list);\r\nLDLM_LOCK_GET(lock);\r\nLASSERT(lock->l_blocking_lock == NULL);\r\nlock->l_blocking_lock = LDLM_LOCK_GET(new);\r\n}\r\n}\r\nvoid ldlm_add_cp_work_item(struct ldlm_lock *lock, struct list_head *work_list)\r\n{\r\nif ((lock->l_flags & LDLM_FL_CP_REQD) == 0) {\r\nlock->l_flags |= LDLM_FL_CP_REQD;\r\nLDLM_DEBUG(lock, "lock granted; sending completion AST.");\r\nLASSERT(list_empty(&lock->l_cp_ast));\r\nlist_add(&lock->l_cp_ast, work_list);\r\nLDLM_LOCK_GET(lock);\r\n}\r\n}\r\nvoid ldlm_add_ast_work_item(struct ldlm_lock *lock, struct ldlm_lock *new,\r\nstruct list_head *work_list)\r\n{\r\ncheck_res_locked(lock->l_resource);\r\nif (new)\r\nldlm_add_bl_work_item(lock, new, work_list);\r\nelse\r\nldlm_add_cp_work_item(lock, work_list);\r\n}\r\nvoid ldlm_lock_addref(struct lustre_handle *lockh, __u32 mode)\r\n{\r\nstruct ldlm_lock *lock;\r\nlock = ldlm_handle2lock(lockh);\r\nLASSERT(lock != NULL);\r\nldlm_lock_addref_internal(lock, mode);\r\nLDLM_LOCK_PUT(lock);\r\n}\r\nvoid ldlm_lock_addref_internal_nolock(struct ldlm_lock *lock, __u32 mode)\r\n{\r\nldlm_lock_remove_from_lru(lock);\r\nif (mode & (LCK_NL | LCK_CR | LCK_PR)) {\r\nlock->l_readers++;\r\nlu_ref_add_atomic(&lock->l_reference, "reader", lock);\r\n}\r\nif (mode & (LCK_EX | LCK_CW | LCK_PW | LCK_GROUP | LCK_COS)) {\r\nlock->l_writers++;\r\nlu_ref_add_atomic(&lock->l_reference, "writer", lock);\r\n}\r\nLDLM_LOCK_GET(lock);\r\nlu_ref_add_atomic(&lock->l_reference, "user", lock);\r\nLDLM_DEBUG(lock, "ldlm_lock_addref(%s)", ldlm_lockname[mode]);\r\n}\r\nint ldlm_lock_addref_try(struct lustre_handle *lockh, __u32 mode)\r\n{\r\nstruct ldlm_lock *lock;\r\nint result;\r\nresult = -EAGAIN;\r\nlock = ldlm_handle2lock(lockh);\r\nif (lock != NULL) {\r\nlock_res_and_lock(lock);\r\nif (lock->l_readers != 0 || lock->l_writers != 0 ||\r\n!(lock->l_flags & LDLM_FL_CBPENDING)) {\r\nldlm_lock_addref_internal_nolock(lock, mode);\r\nresult = 0;\r\n}\r\nunlock_res_and_lock(lock);\r\nLDLM_LOCK_PUT(lock);\r\n}\r\nreturn result;\r\n}\r\nvoid ldlm_lock_addref_internal(struct ldlm_lock *lock, __u32 mode)\r\n{\r\nlock_res_and_lock(lock);\r\nldlm_lock_addref_internal_nolock(lock, mode);\r\nunlock_res_and_lock(lock);\r\n}\r\nvoid ldlm_lock_decref_internal_nolock(struct ldlm_lock *lock, __u32 mode)\r\n{\r\nLDLM_DEBUG(lock, "ldlm_lock_decref(%s)", ldlm_lockname[mode]);\r\nif (mode & (LCK_NL | LCK_CR | LCK_PR)) {\r\nLASSERT(lock->l_readers > 0);\r\nlu_ref_del(&lock->l_reference, "reader", lock);\r\nlock->l_readers--;\r\n}\r\nif (mode & (LCK_EX | LCK_CW | LCK_PW | LCK_GROUP | LCK_COS)) {\r\nLASSERT(lock->l_writers > 0);\r\nlu_ref_del(&lock->l_reference, "writer", lock);\r\nlock->l_writers--;\r\n}\r\nlu_ref_del(&lock->l_reference, "user", lock);\r\nLDLM_LOCK_RELEASE(lock);\r\n}\r\nvoid ldlm_lock_decref_internal(struct ldlm_lock *lock, __u32 mode)\r\n{\r\nstruct ldlm_namespace *ns;\r\nlock_res_and_lock(lock);\r\nns = ldlm_lock_to_ns(lock);\r\nldlm_lock_decref_internal_nolock(lock, mode);\r\nif (lock->l_flags & LDLM_FL_LOCAL &&\r\n!lock->l_readers && !lock->l_writers) {\r\nCDEBUG(D_INFO, "forcing cancel of local lock\n");\r\nlock->l_flags |= LDLM_FL_CBPENDING;\r\n}\r\nif (!lock->l_readers && !lock->l_writers &&\r\n(lock->l_flags & LDLM_FL_CBPENDING)) {\r\nif ((lock->l_flags & LDLM_FL_NS_SRV) && lock->l_export)\r\nCERROR("FL_CBPENDING set on non-local lock--just a warning\n");\r\nLDLM_DEBUG(lock, "final decref done on cbpending lock");\r\nLDLM_LOCK_GET(lock);\r\nldlm_lock_remove_from_lru(lock);\r\nunlock_res_and_lock(lock);\r\nif (lock->l_flags & LDLM_FL_FAIL_LOC)\r\nOBD_RACE(OBD_FAIL_LDLM_CP_BL_RACE);\r\nif ((lock->l_flags & LDLM_FL_ATOMIC_CB) ||\r\nldlm_bl_to_thread_lock(ns, NULL, lock) != 0)\r\nldlm_handle_bl_callback(ns, NULL, lock);\r\n} else if (ns_is_client(ns) &&\r\n!lock->l_readers && !lock->l_writers &&\r\n!(lock->l_flags & LDLM_FL_NO_LRU) &&\r\n!(lock->l_flags & LDLM_FL_BL_AST)) {\r\nLDLM_DEBUG(lock, "add lock into lru list");\r\nldlm_lock_add_to_lru(lock);\r\nunlock_res_and_lock(lock);\r\nif (lock->l_flags & LDLM_FL_FAIL_LOC)\r\nOBD_RACE(OBD_FAIL_LDLM_CP_BL_RACE);\r\nif (!exp_connect_cancelset(lock->l_conn_export) &&\r\n!ns_connect_lru_resize(ns))\r\nldlm_cancel_lru(ns, 0, LCF_ASYNC, 0);\r\n} else {\r\nLDLM_DEBUG(lock, "do not add lock into lru list");\r\nunlock_res_and_lock(lock);\r\n}\r\n}\r\nvoid ldlm_lock_decref(struct lustre_handle *lockh, __u32 mode)\r\n{\r\nstruct ldlm_lock *lock = __ldlm_handle2lock(lockh, 0);\r\nLASSERTF(lock != NULL, "Non-existing lock: %#llx\n", lockh->cookie);\r\nldlm_lock_decref_internal(lock, mode);\r\nLDLM_LOCK_PUT(lock);\r\n}\r\nvoid ldlm_lock_decref_and_cancel(struct lustre_handle *lockh, __u32 mode)\r\n{\r\nstruct ldlm_lock *lock = __ldlm_handle2lock(lockh, 0);\r\nLASSERT(lock != NULL);\r\nLDLM_DEBUG(lock, "ldlm_lock_decref(%s)", ldlm_lockname[mode]);\r\nlock_res_and_lock(lock);\r\nlock->l_flags |= LDLM_FL_CBPENDING;\r\nunlock_res_and_lock(lock);\r\nldlm_lock_decref_internal(lock, mode);\r\nLDLM_LOCK_PUT(lock);\r\n}\r\nstatic void search_granted_lock(struct list_head *queue,\r\nstruct ldlm_lock *req,\r\nstruct sl_insert_point *prev)\r\n{\r\nstruct list_head *tmp;\r\nstruct ldlm_lock *lock, *mode_end, *policy_end;\r\nlist_for_each(tmp, queue) {\r\nlock = list_entry(tmp, struct ldlm_lock, l_res_link);\r\nmode_end = list_entry(lock->l_sl_mode.prev,\r\nstruct ldlm_lock, l_sl_mode);\r\nif (lock->l_req_mode != req->l_req_mode) {\r\ntmp = &mode_end->l_res_link;\r\ncontinue;\r\n}\r\nif (lock->l_resource->lr_type == LDLM_PLAIN) {\r\nprev->res_link = &mode_end->l_res_link;\r\nprev->mode_link = &mode_end->l_sl_mode;\r\nprev->policy_link = &req->l_sl_policy;\r\nreturn;\r\n} else if (lock->l_resource->lr_type == LDLM_IBITS) {\r\nfor (;;) {\r\npolicy_end =\r\nlist_entry(lock->l_sl_policy.prev,\r\nstruct ldlm_lock,\r\nl_sl_policy);\r\nif (lock->l_policy_data.l_inodebits.bits ==\r\nreq->l_policy_data.l_inodebits.bits) {\r\nprev->res_link =\r\n&policy_end->l_res_link;\r\nprev->mode_link =\r\n&policy_end->l_sl_mode;\r\nprev->policy_link =\r\n&policy_end->l_sl_policy;\r\nreturn;\r\n}\r\nif (policy_end == mode_end)\r\nbreak;\r\ntmp = policy_end->l_res_link.next;\r\nlock = list_entry(tmp, struct ldlm_lock,\r\nl_res_link);\r\n}\r\nprev->res_link = &mode_end->l_res_link;\r\nprev->mode_link = &mode_end->l_sl_mode;\r\nprev->policy_link = &req->l_sl_policy;\r\nreturn;\r\n} else {\r\nLDLM_ERROR(lock,\r\n"is not LDLM_PLAIN or LDLM_IBITS lock");\r\nLBUG();\r\n}\r\n}\r\nprev->res_link = queue->prev;\r\nprev->mode_link = &req->l_sl_mode;\r\nprev->policy_link = &req->l_sl_policy;\r\n}\r\nstatic void ldlm_granted_list_add_lock(struct ldlm_lock *lock,\r\nstruct sl_insert_point *prev)\r\n{\r\nstruct ldlm_resource *res = lock->l_resource;\r\ncheck_res_locked(res);\r\nldlm_resource_dump(D_INFO, res);\r\nLDLM_DEBUG(lock, "About to add lock:");\r\nif (lock->l_flags & LDLM_FL_DESTROYED) {\r\nCDEBUG(D_OTHER, "Lock destroyed, not adding to resource\n");\r\nreturn;\r\n}\r\nLASSERT(list_empty(&lock->l_res_link));\r\nLASSERT(list_empty(&lock->l_sl_mode));\r\nLASSERT(list_empty(&lock->l_sl_policy));\r\nif (&lock->l_res_link != prev->res_link)\r\nlist_add(&lock->l_res_link, prev->res_link);\r\nif (&lock->l_sl_mode != prev->mode_link)\r\nlist_add(&lock->l_sl_mode, prev->mode_link);\r\nif (&lock->l_sl_policy != prev->policy_link)\r\nlist_add(&lock->l_sl_policy, prev->policy_link);\r\n}\r\nstatic void ldlm_grant_lock_with_skiplist(struct ldlm_lock *lock)\r\n{\r\nstruct sl_insert_point prev;\r\nLASSERT(lock->l_req_mode == lock->l_granted_mode);\r\nsearch_granted_lock(&lock->l_resource->lr_granted, lock, &prev);\r\nldlm_granted_list_add_lock(lock, &prev);\r\n}\r\nvoid ldlm_grant_lock(struct ldlm_lock *lock, struct list_head *work_list)\r\n{\r\nstruct ldlm_resource *res = lock->l_resource;\r\ncheck_res_locked(res);\r\nlock->l_granted_mode = lock->l_req_mode;\r\nif (res->lr_type == LDLM_PLAIN || res->lr_type == LDLM_IBITS)\r\nldlm_grant_lock_with_skiplist(lock);\r\nelse if (res->lr_type == LDLM_EXTENT)\r\nldlm_extent_add_lock(res, lock);\r\nelse\r\nldlm_resource_add_lock(res, &res->lr_granted, lock);\r\nif (lock->l_granted_mode < res->lr_most_restr)\r\nres->lr_most_restr = lock->l_granted_mode;\r\nif (work_list && lock->l_completion_ast != NULL)\r\nldlm_add_ast_work_item(lock, NULL, work_list);\r\nldlm_pool_add(&ldlm_res_to_ns(res)->ns_pool, lock);\r\n}\r\nstatic struct ldlm_lock *search_queue(struct list_head *queue,\r\nldlm_mode_t *mode,\r\nldlm_policy_data_t *policy,\r\nstruct ldlm_lock *old_lock,\r\n__u64 flags, int unref)\r\n{\r\nstruct ldlm_lock *lock;\r\nstruct list_head *tmp;\r\nlist_for_each(tmp, queue) {\r\nldlm_mode_t match;\r\nlock = list_entry(tmp, struct ldlm_lock, l_res_link);\r\nif (lock == old_lock)\r\nbreak;\r\nif (ldlm_is_excl(lock))\r\ncontinue;\r\nif (lock->l_flags & LDLM_FL_CBPENDING &&\r\n!(flags & LDLM_FL_CBPENDING))\r\ncontinue;\r\nif (!unref && lock->l_flags & LDLM_FL_CBPENDING &&\r\nlock->l_readers == 0 && lock->l_writers == 0)\r\ncontinue;\r\nif (!(lock->l_req_mode & *mode))\r\ncontinue;\r\nmatch = lock->l_req_mode;\r\nif (lock->l_resource->lr_type == LDLM_EXTENT &&\r\n(lock->l_policy_data.l_extent.start >\r\npolicy->l_extent.start ||\r\nlock->l_policy_data.l_extent.end < policy->l_extent.end))\r\ncontinue;\r\nif (unlikely(match == LCK_GROUP) &&\r\nlock->l_resource->lr_type == LDLM_EXTENT &&\r\nlock->l_policy_data.l_extent.gid != policy->l_extent.gid)\r\ncontinue;\r\nif (lock->l_resource->lr_type == LDLM_IBITS &&\r\n((lock->l_policy_data.l_inodebits.bits &\r\npolicy->l_inodebits.bits) !=\r\npolicy->l_inodebits.bits))\r\ncontinue;\r\nif (!unref && (lock->l_flags & LDLM_FL_GONE_MASK))\r\ncontinue;\r\nif ((flags & LDLM_FL_LOCAL_ONLY) &&\r\n!(lock->l_flags & LDLM_FL_LOCAL))\r\ncontinue;\r\nif (flags & LDLM_FL_TEST_LOCK) {\r\nLDLM_LOCK_GET(lock);\r\nldlm_lock_touch_in_lru(lock);\r\n} else {\r\nldlm_lock_addref_internal_nolock(lock, match);\r\n}\r\n*mode = match;\r\nreturn lock;\r\n}\r\nreturn NULL;\r\n}\r\nvoid ldlm_lock_fail_match_locked(struct ldlm_lock *lock)\r\n{\r\nif ((lock->l_flags & LDLM_FL_FAIL_NOTIFIED) == 0) {\r\nlock->l_flags |= LDLM_FL_FAIL_NOTIFIED;\r\nwake_up_all(&lock->l_waitq);\r\n}\r\n}\r\nvoid ldlm_lock_fail_match(struct ldlm_lock *lock)\r\n{\r\nlock_res_and_lock(lock);\r\nldlm_lock_fail_match_locked(lock);\r\nunlock_res_and_lock(lock);\r\n}\r\nvoid ldlm_lock_allow_match_locked(struct ldlm_lock *lock)\r\n{\r\nlock->l_flags |= LDLM_FL_LVB_READY;\r\nwake_up_all(&lock->l_waitq);\r\n}\r\nvoid ldlm_lock_allow_match(struct ldlm_lock *lock)\r\n{\r\nlock_res_and_lock(lock);\r\nldlm_lock_allow_match_locked(lock);\r\nunlock_res_and_lock(lock);\r\n}\r\nldlm_mode_t ldlm_lock_match(struct ldlm_namespace *ns, __u64 flags,\r\nconst struct ldlm_res_id *res_id, ldlm_type_t type,\r\nldlm_policy_data_t *policy, ldlm_mode_t mode,\r\nstruct lustre_handle *lockh, int unref)\r\n{\r\nstruct ldlm_resource *res;\r\nstruct ldlm_lock *lock, *old_lock = NULL;\r\nint rc = 0;\r\nif (ns == NULL) {\r\nold_lock = ldlm_handle2lock(lockh);\r\nLASSERT(old_lock);\r\nns = ldlm_lock_to_ns(old_lock);\r\nres_id = &old_lock->l_resource->lr_name;\r\ntype = old_lock->l_resource->lr_type;\r\nmode = old_lock->l_req_mode;\r\n}\r\nres = ldlm_resource_get(ns, NULL, res_id, type, 0);\r\nif (res == NULL) {\r\nLASSERT(old_lock == NULL);\r\nreturn 0;\r\n}\r\nLDLM_RESOURCE_ADDREF(res);\r\nlock_res(res);\r\nlock = search_queue(&res->lr_granted, &mode, policy, old_lock,\r\nflags, unref);\r\nif (lock != NULL) {\r\nrc = 1;\r\ngoto out;\r\n}\r\nif (flags & LDLM_FL_BLOCK_GRANTED) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nlock = search_queue(&res->lr_converting, &mode, policy, old_lock,\r\nflags, unref);\r\nif (lock != NULL) {\r\nrc = 1;\r\ngoto out;\r\n}\r\nlock = search_queue(&res->lr_waiting, &mode, policy, old_lock,\r\nflags, unref);\r\nif (lock != NULL) {\r\nrc = 1;\r\ngoto out;\r\n}\r\nout:\r\nunlock_res(res);\r\nLDLM_RESOURCE_DELREF(res);\r\nldlm_resource_putref(res);\r\nif (lock) {\r\nldlm_lock2handle(lock, lockh);\r\nif ((flags & LDLM_FL_LVB_READY) &&\r\n(!(lock->l_flags & LDLM_FL_LVB_READY))) {\r\n__u64 wait_flags = LDLM_FL_LVB_READY |\r\nLDLM_FL_DESTROYED | LDLM_FL_FAIL_NOTIFIED;\r\nstruct l_wait_info lwi;\r\nif (lock->l_completion_ast) {\r\nint err = lock->l_completion_ast(lock,\r\nLDLM_FL_WAIT_NOREPROC,\r\nNULL);\r\nif (err) {\r\nif (flags & LDLM_FL_TEST_LOCK)\r\nLDLM_LOCK_RELEASE(lock);\r\nelse\r\nldlm_lock_decref_internal(lock,\r\nmode);\r\nrc = 0;\r\ngoto out2;\r\n}\r\n}\r\nlwi = LWI_TIMEOUT_INTR(cfs_time_seconds(obd_timeout),\r\nNULL, LWI_ON_SIGNAL_NOOP, NULL);\r\nl_wait_event(lock->l_waitq,\r\nlock->l_flags & wait_flags,\r\n&lwi);\r\nif (!(lock->l_flags & LDLM_FL_LVB_READY)) {\r\nif (flags & LDLM_FL_TEST_LOCK)\r\nLDLM_LOCK_RELEASE(lock);\r\nelse\r\nldlm_lock_decref_internal(lock, mode);\r\nrc = 0;\r\n}\r\n}\r\n}\r\nout2:\r\nif (rc) {\r\nLDLM_DEBUG(lock, "matched (%llu %llu)",\r\n(type == LDLM_PLAIN || type == LDLM_IBITS) ?\r\nres_id->name[2] : policy->l_extent.start,\r\n(type == LDLM_PLAIN || type == LDLM_IBITS) ?\r\nres_id->name[3] : policy->l_extent.end);\r\nif (lock->l_conn_export &&\r\nsptlrpc_import_check_ctx(\r\nclass_exp2cliimp(lock->l_conn_export))) {\r\nif (!(flags & LDLM_FL_TEST_LOCK))\r\nldlm_lock_decref_internal(lock, mode);\r\nrc = 0;\r\n}\r\nif (flags & LDLM_FL_TEST_LOCK)\r\nLDLM_LOCK_RELEASE(lock);\r\n} else if (!(flags & LDLM_FL_TEST_LOCK)) {\r\nLDLM_DEBUG_NOLOCK("not matched ns %p type %u mode %u res %llu/%llu (%llu %llu)",\r\nns, type, mode, res_id->name[0],\r\nres_id->name[1],\r\n(type == LDLM_PLAIN || type == LDLM_IBITS) ?\r\nres_id->name[2] : policy->l_extent.start,\r\n(type == LDLM_PLAIN || type == LDLM_IBITS) ?\r\nres_id->name[3] : policy->l_extent.end);\r\n}\r\nif (old_lock)\r\nLDLM_LOCK_PUT(old_lock);\r\nreturn rc ? mode : 0;\r\n}\r\nldlm_mode_t ldlm_revalidate_lock_handle(struct lustre_handle *lockh,\r\n__u64 *bits)\r\n{\r\nstruct ldlm_lock *lock;\r\nldlm_mode_t mode = 0;\r\nlock = ldlm_handle2lock(lockh);\r\nif (lock != NULL) {\r\nlock_res_and_lock(lock);\r\nif (lock->l_flags & LDLM_FL_GONE_MASK)\r\ngoto out;\r\nif (lock->l_flags & LDLM_FL_CBPENDING &&\r\nlock->l_readers == 0 && lock->l_writers == 0)\r\ngoto out;\r\nif (bits)\r\n*bits = lock->l_policy_data.l_inodebits.bits;\r\nmode = lock->l_granted_mode;\r\nldlm_lock_addref_internal_nolock(lock, mode);\r\n}\r\nout:\r\nif (lock != NULL) {\r\nunlock_res_and_lock(lock);\r\nLDLM_LOCK_PUT(lock);\r\n}\r\nreturn mode;\r\n}\r\nint ldlm_fill_lvb(struct ldlm_lock *lock, struct req_capsule *pill,\r\nenum req_location loc, void *data, int size)\r\n{\r\nvoid *lvb;\r\nLASSERT(data != NULL);\r\nLASSERT(size >= 0);\r\nswitch (lock->l_lvb_type) {\r\ncase LVB_T_OST:\r\nif (size == sizeof(struct ost_lvb)) {\r\nif (loc == RCL_CLIENT)\r\nlvb = req_capsule_client_swab_get(pill,\r\n&RMF_DLM_LVB,\r\nlustre_swab_ost_lvb);\r\nelse\r\nlvb = req_capsule_server_swab_get(pill,\r\n&RMF_DLM_LVB,\r\nlustre_swab_ost_lvb);\r\nif (unlikely(lvb == NULL)) {\r\nLDLM_ERROR(lock, "no LVB");\r\nreturn -EPROTO;\r\n}\r\nmemcpy(data, lvb, size);\r\n} else if (size == sizeof(struct ost_lvb_v1)) {\r\nstruct ost_lvb *olvb = data;\r\nif (loc == RCL_CLIENT)\r\nlvb = req_capsule_client_swab_get(pill,\r\n&RMF_DLM_LVB,\r\nlustre_swab_ost_lvb_v1);\r\nelse\r\nlvb = req_capsule_server_sized_swab_get(pill,\r\n&RMF_DLM_LVB, size,\r\nlustre_swab_ost_lvb_v1);\r\nif (unlikely(lvb == NULL)) {\r\nLDLM_ERROR(lock, "no LVB");\r\nreturn -EPROTO;\r\n}\r\nmemcpy(data, lvb, size);\r\nolvb->lvb_mtime_ns = 0;\r\nolvb->lvb_atime_ns = 0;\r\nolvb->lvb_ctime_ns = 0;\r\n} else {\r\nLDLM_ERROR(lock, "Replied unexpected ost LVB size %d",\r\nsize);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase LVB_T_LQUOTA:\r\nif (size == sizeof(struct lquota_lvb)) {\r\nif (loc == RCL_CLIENT)\r\nlvb = req_capsule_client_swab_get(pill,\r\n&RMF_DLM_LVB,\r\nlustre_swab_lquota_lvb);\r\nelse\r\nlvb = req_capsule_server_swab_get(pill,\r\n&RMF_DLM_LVB,\r\nlustre_swab_lquota_lvb);\r\nif (unlikely(lvb == NULL)) {\r\nLDLM_ERROR(lock, "no LVB");\r\nreturn -EPROTO;\r\n}\r\nmemcpy(data, lvb, size);\r\n} else {\r\nLDLM_ERROR(lock,\r\n"Replied unexpected lquota LVB size %d",\r\nsize);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase LVB_T_LAYOUT:\r\nif (size == 0)\r\nbreak;\r\nif (loc == RCL_CLIENT)\r\nlvb = req_capsule_client_get(pill, &RMF_DLM_LVB);\r\nelse\r\nlvb = req_capsule_server_get(pill, &RMF_DLM_LVB);\r\nif (unlikely(lvb == NULL)) {\r\nLDLM_ERROR(lock, "no LVB");\r\nreturn -EPROTO;\r\n}\r\nmemcpy(data, lvb, size);\r\nbreak;\r\ndefault:\r\nLDLM_ERROR(lock, "Unknown LVB type: %d\n", lock->l_lvb_type);\r\ndump_stack();\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstruct ldlm_lock *ldlm_lock_create(struct ldlm_namespace *ns,\r\nconst struct ldlm_res_id *res_id,\r\nldlm_type_t type,\r\nldlm_mode_t mode,\r\nconst struct ldlm_callback_suite *cbs,\r\nvoid *data, __u32 lvb_len,\r\nenum lvb_type lvb_type)\r\n{\r\nstruct ldlm_lock *lock;\r\nstruct ldlm_resource *res;\r\nres = ldlm_resource_get(ns, NULL, res_id, type, 1);\r\nif (res == NULL)\r\nreturn NULL;\r\nlock = ldlm_lock_new(res);\r\nif (lock == NULL)\r\nreturn NULL;\r\nlock->l_req_mode = mode;\r\nlock->l_ast_data = data;\r\nlock->l_pid = current_pid();\r\nif (ns_is_server(ns))\r\nlock->l_flags |= LDLM_FL_NS_SRV;\r\nif (cbs) {\r\nlock->l_blocking_ast = cbs->lcs_blocking;\r\nlock->l_completion_ast = cbs->lcs_completion;\r\nlock->l_glimpse_ast = cbs->lcs_glimpse;\r\n}\r\nlock->l_tree_node = NULL;\r\nif (type == LDLM_EXTENT) {\r\nif (ldlm_interval_alloc(lock) == NULL)\r\ngoto out;\r\n}\r\nif (lvb_len) {\r\nlock->l_lvb_len = lvb_len;\r\nOBD_ALLOC(lock->l_lvb_data, lvb_len);\r\nif (lock->l_lvb_data == NULL)\r\ngoto out;\r\n}\r\nlock->l_lvb_type = lvb_type;\r\nif (OBD_FAIL_CHECK(OBD_FAIL_LDLM_NEW_LOCK))\r\ngoto out;\r\nreturn lock;\r\nout:\r\nldlm_lock_destroy(lock);\r\nLDLM_LOCK_RELEASE(lock);\r\nreturn NULL;\r\n}\r\nldlm_error_t ldlm_lock_enqueue(struct ldlm_namespace *ns,\r\nstruct ldlm_lock **lockp,\r\nvoid *cookie, __u64 *flags)\r\n{\r\nstruct ldlm_lock *lock = *lockp;\r\nstruct ldlm_resource *res = lock->l_resource;\r\nint local = ns_is_client(ldlm_res_to_ns(res));\r\nldlm_error_t rc = ELDLM_OK;\r\nstruct ldlm_interval *node = NULL;\r\nlock->l_last_activity = get_seconds();\r\nif ((*flags & (LDLM_FL_HAS_INTENT|LDLM_FL_REPLAY)) == LDLM_FL_HAS_INTENT\r\n&& !local && ns->ns_policy) {\r\nrc = ns->ns_policy(ns, lockp, cookie, lock->l_req_mode, *flags,\r\nNULL);\r\nif (rc == ELDLM_LOCK_REPLACED) {\r\nif (lock != *lockp) {\r\nldlm_lock_destroy(lock);\r\nLDLM_LOCK_RELEASE(lock);\r\n}\r\n*flags |= LDLM_FL_LOCK_CHANGED;\r\nreturn 0;\r\n} else if (rc != ELDLM_OK ||\r\n(rc == ELDLM_OK && (*flags & LDLM_FL_INTENT_ONLY))) {\r\nldlm_lock_destroy(lock);\r\nreturn rc;\r\n}\r\n}\r\nif (!local && (*flags & LDLM_FL_REPLAY) && res->lr_type == LDLM_EXTENT)\r\nOBD_SLAB_ALLOC_PTR_GFP(node, ldlm_interval_slab, GFP_NOFS);\r\nlock_res_and_lock(lock);\r\nif (local && lock->l_req_mode == lock->l_granted_mode) {\r\n*flags &= ~(LDLM_FL_BLOCK_GRANTED |\r\nLDLM_FL_BLOCK_CONV | LDLM_FL_BLOCK_WAIT);\r\ngoto out;\r\n}\r\nldlm_resource_unlink_lock(lock);\r\nif (res->lr_type == LDLM_EXTENT && lock->l_tree_node == NULL) {\r\nif (node == NULL) {\r\nldlm_lock_destroy_nolock(lock);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nINIT_LIST_HEAD(&node->li_group);\r\nldlm_interval_attach(node, lock);\r\nnode = NULL;\r\n}\r\nlock->l_flags |= *flags & LDLM_FL_AST_DISCARD_DATA;\r\nif (local) {\r\nif (*flags & LDLM_FL_BLOCK_CONV)\r\nldlm_resource_add_lock(res, &res->lr_converting, lock);\r\nelse if (*flags & (LDLM_FL_BLOCK_WAIT | LDLM_FL_BLOCK_GRANTED))\r\nldlm_resource_add_lock(res, &res->lr_waiting, lock);\r\nelse\r\nldlm_grant_lock(lock, NULL);\r\ngoto out;\r\n} else {\r\nCERROR("This is client-side-only module, cannot handle LDLM_NAMESPACE_SERVER resource type lock.\n");\r\nLBUG();\r\n}\r\nout:\r\nunlock_res_and_lock(lock);\r\nif (node)\r\nOBD_SLAB_FREE(node, ldlm_interval_slab, sizeof(*node));\r\nreturn rc;\r\n}\r\nstatic int\r\nldlm_work_bl_ast_lock(struct ptlrpc_request_set *rqset, void *opaq)\r\n{\r\nstruct ldlm_cb_set_arg *arg = opaq;\r\nstruct ldlm_lock_desc d;\r\nint rc;\r\nstruct ldlm_lock *lock;\r\nif (list_empty(arg->list))\r\nreturn -ENOENT;\r\nlock = list_entry(arg->list->next, struct ldlm_lock, l_bl_ast);\r\nlock_res_and_lock(lock);\r\nlist_del_init(&lock->l_bl_ast);\r\nLASSERT(lock->l_flags & LDLM_FL_AST_SENT);\r\nLASSERT(lock->l_bl_ast_run == 0);\r\nLASSERT(lock->l_blocking_lock);\r\nlock->l_bl_ast_run++;\r\nunlock_res_and_lock(lock);\r\nldlm_lock2desc(lock->l_blocking_lock, &d);\r\nrc = lock->l_blocking_ast(lock, &d, (void *)arg, LDLM_CB_BLOCKING);\r\nLDLM_LOCK_RELEASE(lock->l_blocking_lock);\r\nlock->l_blocking_lock = NULL;\r\nLDLM_LOCK_RELEASE(lock);\r\nreturn rc;\r\n}\r\nstatic int\r\nldlm_work_cp_ast_lock(struct ptlrpc_request_set *rqset, void *opaq)\r\n{\r\nstruct ldlm_cb_set_arg *arg = opaq;\r\nint rc = 0;\r\nstruct ldlm_lock *lock;\r\nldlm_completion_callback completion_callback;\r\nif (list_empty(arg->list))\r\nreturn -ENOENT;\r\nlock = list_entry(arg->list->next, struct ldlm_lock, l_cp_ast);\r\nlock_res_and_lock(lock);\r\nlist_del_init(&lock->l_cp_ast);\r\nLASSERT(lock->l_flags & LDLM_FL_CP_REQD);\r\ncompletion_callback = lock->l_completion_ast;\r\nlock->l_flags &= ~LDLM_FL_CP_REQD;\r\nunlock_res_and_lock(lock);\r\nif (completion_callback != NULL)\r\nrc = completion_callback(lock, 0, (void *)arg);\r\nLDLM_LOCK_RELEASE(lock);\r\nreturn rc;\r\n}\r\nstatic int\r\nldlm_work_revoke_ast_lock(struct ptlrpc_request_set *rqset, void *opaq)\r\n{\r\nstruct ldlm_cb_set_arg *arg = opaq;\r\nstruct ldlm_lock_desc desc;\r\nint rc;\r\nstruct ldlm_lock *lock;\r\nif (list_empty(arg->list))\r\nreturn -ENOENT;\r\nlock = list_entry(arg->list->next, struct ldlm_lock, l_rk_ast);\r\nlist_del_init(&lock->l_rk_ast);\r\nldlm_lock2desc(lock, &desc);\r\ndesc.l_req_mode = LCK_EX;\r\ndesc.l_granted_mode = 0;\r\nrc = lock->l_blocking_ast(lock, &desc, (void *)arg, LDLM_CB_BLOCKING);\r\nLDLM_LOCK_RELEASE(lock);\r\nreturn rc;\r\n}\r\nint ldlm_work_gl_ast_lock(struct ptlrpc_request_set *rqset, void *opaq)\r\n{\r\nstruct ldlm_cb_set_arg *arg = opaq;\r\nstruct ldlm_glimpse_work *gl_work;\r\nstruct ldlm_lock *lock;\r\nint rc = 0;\r\nif (list_empty(arg->list))\r\nreturn -ENOENT;\r\ngl_work = list_entry(arg->list->next, struct ldlm_glimpse_work,\r\ngl_list);\r\nlist_del_init(&gl_work->gl_list);\r\nlock = gl_work->gl_lock;\r\narg->gl_desc = gl_work->gl_desc;\r\nif (lock->l_glimpse_ast(lock, (void *)arg) == 0)\r\nrc = 1;\r\nLDLM_LOCK_RELEASE(lock);\r\nif ((gl_work->gl_flags & LDLM_GL_WORK_NOFREE) == 0)\r\nOBD_FREE_PTR(gl_work);\r\nreturn rc;\r\n}\r\nint ldlm_run_ast_work(struct ldlm_namespace *ns, struct list_head *rpc_list,\r\nldlm_desc_ast_t ast_type)\r\n{\r\nstruct ldlm_cb_set_arg *arg;\r\nset_producer_func work_ast_lock;\r\nint rc;\r\nif (list_empty(rpc_list))\r\nreturn 0;\r\nOBD_ALLOC_PTR(arg);\r\nif (arg == NULL)\r\nreturn -ENOMEM;\r\natomic_set(&arg->restart, 0);\r\narg->list = rpc_list;\r\nswitch (ast_type) {\r\ncase LDLM_WORK_BL_AST:\r\narg->type = LDLM_BL_CALLBACK;\r\nwork_ast_lock = ldlm_work_bl_ast_lock;\r\nbreak;\r\ncase LDLM_WORK_CP_AST:\r\narg->type = LDLM_CP_CALLBACK;\r\nwork_ast_lock = ldlm_work_cp_ast_lock;\r\nbreak;\r\ncase LDLM_WORK_REVOKE_AST:\r\narg->type = LDLM_BL_CALLBACK;\r\nwork_ast_lock = ldlm_work_revoke_ast_lock;\r\nbreak;\r\ncase LDLM_WORK_GL_AST:\r\narg->type = LDLM_GL_CALLBACK;\r\nwork_ast_lock = ldlm_work_gl_ast_lock;\r\nbreak;\r\ndefault:\r\nLBUG();\r\n}\r\narg->set = ptlrpc_prep_fcset(ns->ns_max_parallel_ast ? : UINT_MAX,\r\nwork_ast_lock, arg);\r\nif (arg->set == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nptlrpc_set_wait(arg->set);\r\nptlrpc_set_destroy(arg->set);\r\nrc = atomic_read(&arg->restart) ? -ERESTART : 0;\r\ngoto out;\r\nout:\r\nOBD_FREE_PTR(arg);\r\nreturn rc;\r\n}\r\nstatic int reprocess_one_queue(struct ldlm_resource *res, void *closure)\r\n{\r\nldlm_reprocess_all(res);\r\nreturn LDLM_ITER_CONTINUE;\r\n}\r\nstatic int ldlm_reprocess_res(struct cfs_hash *hs, struct cfs_hash_bd *bd,\r\nstruct hlist_node *hnode, void *arg)\r\n{\r\nstruct ldlm_resource *res = cfs_hash_object(hs, hnode);\r\nint rc;\r\nrc = reprocess_one_queue(res, arg);\r\nreturn rc == LDLM_ITER_STOP;\r\n}\r\nvoid ldlm_reprocess_all_ns(struct ldlm_namespace *ns)\r\n{\r\nif (ns != NULL) {\r\ncfs_hash_for_each_nolock(ns->ns_rs_hash,\r\nldlm_reprocess_res, NULL);\r\n}\r\n}\r\nvoid ldlm_reprocess_all(struct ldlm_resource *res)\r\n{\r\nLIST_HEAD(rpc_list);\r\nif (!ns_is_client(ldlm_res_to_ns(res))) {\r\nCERROR("This is client-side-only module, cannot handle LDLM_NAMESPACE_SERVER resource type lock.\n");\r\nLBUG();\r\n}\r\n}\r\nvoid ldlm_cancel_callback(struct ldlm_lock *lock)\r\n{\r\ncheck_res_locked(lock->l_resource);\r\nif (!(lock->l_flags & LDLM_FL_CANCEL)) {\r\nlock->l_flags |= LDLM_FL_CANCEL;\r\nif (lock->l_blocking_ast) {\r\nunlock_res_and_lock(lock);\r\nlock->l_blocking_ast(lock, NULL, lock->l_ast_data,\r\nLDLM_CB_CANCELING);\r\nlock_res_and_lock(lock);\r\n} else {\r\nLDLM_DEBUG(lock, "no blocking ast");\r\n}\r\n}\r\nlock->l_flags |= LDLM_FL_BL_DONE;\r\n}\r\nvoid ldlm_unlink_lock_skiplist(struct ldlm_lock *req)\r\n{\r\nif (req->l_resource->lr_type != LDLM_PLAIN &&\r\nreq->l_resource->lr_type != LDLM_IBITS)\r\nreturn;\r\nlist_del_init(&req->l_sl_policy);\r\nlist_del_init(&req->l_sl_mode);\r\n}\r\nvoid ldlm_lock_cancel(struct ldlm_lock *lock)\r\n{\r\nstruct ldlm_resource *res;\r\nstruct ldlm_namespace *ns;\r\nlock_res_and_lock(lock);\r\nres = lock->l_resource;\r\nns = ldlm_res_to_ns(res);\r\nif (lock->l_readers || lock->l_writers) {\r\nLDLM_ERROR(lock, "lock still has references");\r\nLBUG();\r\n}\r\nif (lock->l_flags & LDLM_FL_WAITED)\r\nldlm_del_waiting_lock(lock);\r\nldlm_cancel_callback(lock);\r\nif (lock->l_flags & LDLM_FL_WAITED)\r\nldlm_del_waiting_lock(lock);\r\nldlm_resource_unlink_lock(lock);\r\nldlm_lock_destroy_nolock(lock);\r\nif (lock->l_granted_mode == lock->l_req_mode)\r\nldlm_pool_del(&ns->ns_pool, lock);\r\nlock->l_granted_mode = LCK_MINMODE;\r\nunlock_res_and_lock(lock);\r\n}\r\nint ldlm_lock_set_data(struct lustre_handle *lockh, void *data)\r\n{\r\nstruct ldlm_lock *lock = ldlm_handle2lock(lockh);\r\nint rc = -EINVAL;\r\nif (lock) {\r\nif (lock->l_ast_data == NULL)\r\nlock->l_ast_data = data;\r\nif (lock->l_ast_data == data)\r\nrc = 0;\r\nLDLM_LOCK_PUT(lock);\r\n}\r\nreturn rc;\r\n}\r\nint ldlm_cancel_locks_for_export_cb(struct cfs_hash *hs, struct cfs_hash_bd *bd,\r\nstruct hlist_node *hnode, void *data)\r\n{\r\nstruct export_cl_data *ecl = (struct export_cl_data *)data;\r\nstruct obd_export *exp = ecl->ecl_exp;\r\nstruct ldlm_lock *lock = cfs_hash_object(hs, hnode);\r\nstruct ldlm_resource *res;\r\nres = ldlm_resource_getref(lock->l_resource);\r\nLDLM_LOCK_GET(lock);\r\nLDLM_DEBUG(lock, "export %p", exp);\r\nldlm_res_lvbo_update(res, NULL, 1);\r\nldlm_lock_cancel(lock);\r\nldlm_reprocess_all(res);\r\nldlm_resource_putref(res);\r\nLDLM_LOCK_RELEASE(lock);\r\necl->ecl_loop++;\r\nif ((ecl->ecl_loop & -ecl->ecl_loop) == ecl->ecl_loop) {\r\nCDEBUG(D_INFO,\r\n"Cancel lock %p for export %p (loop %d), still have %d locks left on hash table.\n",\r\nlock, exp, ecl->ecl_loop,\r\natomic_read(&hs->hs_count));\r\n}\r\nreturn 0;\r\n}\r\nvoid ldlm_cancel_locks_for_export(struct obd_export *exp)\r\n{\r\nstruct export_cl_data ecl = {\r\n.ecl_exp = exp,\r\n.ecl_loop = 0,\r\n};\r\ncfs_hash_for_each_empty(exp->exp_lock_hash,\r\nldlm_cancel_locks_for_export_cb, &ecl);\r\n}\r\nvoid ldlm_lock_downgrade(struct ldlm_lock *lock, int new_mode)\r\n{\r\nLASSERT(lock->l_granted_mode & (LCK_PW | LCK_EX));\r\nLASSERT(new_mode == LCK_COS);\r\nlock_res_and_lock(lock);\r\nldlm_resource_unlink_lock(lock);\r\nldlm_pool_del(&ldlm_lock_to_ns(lock)->ns_pool, lock);\r\nlock->l_req_mode = new_mode;\r\nldlm_grant_lock(lock, NULL);\r\nunlock_res_and_lock(lock);\r\nldlm_reprocess_all(lock->l_resource);\r\n}\r\nstruct ldlm_resource *ldlm_lock_convert(struct ldlm_lock *lock, int new_mode,\r\n__u32 *flags)\r\n{\r\nLIST_HEAD(rpc_list);\r\nstruct ldlm_resource *res;\r\nstruct ldlm_namespace *ns;\r\nint granted = 0;\r\nstruct ldlm_interval *node;\r\nif (new_mode == lock->l_granted_mode) {\r\n*flags |= LDLM_FL_BLOCK_GRANTED;\r\nreturn lock->l_resource;\r\n}\r\nOBD_SLAB_ALLOC_PTR_GFP(node, ldlm_interval_slab, GFP_NOFS);\r\nif (node == NULL)\r\nreturn NULL;\r\nLASSERTF((new_mode == LCK_PW && lock->l_granted_mode == LCK_PR),\r\n"new_mode %u, granted %u\n", new_mode, lock->l_granted_mode);\r\nlock_res_and_lock(lock);\r\nres = lock->l_resource;\r\nns = ldlm_res_to_ns(res);\r\nlock->l_req_mode = new_mode;\r\nif (res->lr_type == LDLM_PLAIN || res->lr_type == LDLM_IBITS) {\r\nldlm_resource_unlink_lock(lock);\r\n} else {\r\nldlm_resource_unlink_lock(lock);\r\nif (res->lr_type == LDLM_EXTENT) {\r\nINIT_LIST_HEAD(&node->li_group);\r\nldlm_interval_attach(node, lock);\r\nnode = NULL;\r\n}\r\n}\r\nldlm_pool_del(&ns->ns_pool, lock);\r\nif (ns_is_client(ldlm_res_to_ns(res))) {\r\nif (*flags & (LDLM_FL_BLOCK_CONV | LDLM_FL_BLOCK_GRANTED)) {\r\nldlm_resource_add_lock(res, &res->lr_converting, lock);\r\n} else {\r\nLDLM_ERROR(lock, "Erroneous flags %x on local lock\n",\r\n*flags);\r\nLBUG();\r\nldlm_grant_lock(lock, &rpc_list);\r\ngranted = 1;\r\nif (lock->l_completion_ast)\r\nlock->l_completion_ast(lock, 0, NULL);\r\n}\r\n} else {\r\nCERROR("This is client-side-only module, cannot handle LDLM_NAMESPACE_SERVER resource type lock.\n");\r\nLBUG();\r\n}\r\nunlock_res_and_lock(lock);\r\nif (granted)\r\nldlm_run_ast_work(ns, &rpc_list, LDLM_WORK_CP_AST);\r\nif (node)\r\nOBD_SLAB_FREE(node, ldlm_interval_slab, sizeof(*node));\r\nreturn res;\r\n}\r\nvoid ldlm_lock_dump_handle(int level, struct lustre_handle *lockh)\r\n{\r\nstruct ldlm_lock *lock;\r\nif (!((libcfs_debug | D_ERROR) & level))\r\nreturn;\r\nlock = ldlm_handle2lock(lockh);\r\nif (lock == NULL)\r\nreturn;\r\nLDLM_DEBUG_LIMIT(level, lock, "###");\r\nLDLM_LOCK_PUT(lock);\r\n}\r\nvoid _ldlm_lock_debug(struct ldlm_lock *lock,\r\nstruct libcfs_debug_msg_data *msgdata,\r\nconst char *fmt, ...)\r\n{\r\nva_list args;\r\nstruct obd_export *exp = lock->l_export;\r\nstruct ldlm_resource *resource = lock->l_resource;\r\nchar *nid = "local";\r\nva_start(args, fmt);\r\nif (exp && exp->exp_connection) {\r\nnid = libcfs_nid2str(exp->exp_connection->c_peer.nid);\r\n} else if (exp && exp->exp_obd != NULL) {\r\nstruct obd_import *imp = exp->exp_obd->u.cli.cl_import;\r\nnid = libcfs_nid2str(imp->imp_connection->c_peer.nid);\r\n}\r\nif (resource == NULL) {\r\nlibcfs_debug_vmsg2(msgdata, fmt, args,\r\n" ns: \?\? lock: %p/%#llx lrc: %d/%d,%d mode: %s/%s res: \?\? rrc=\?\? type: \?\?\? flags: %#llx nid: %s remote: %#llx expref: %d pid: %u timeout: %lu lvb_type: %d\n",\r\nlock,\r\nlock->l_handle.h_cookie, atomic_read(&lock->l_refc),\r\nlock->l_readers, lock->l_writers,\r\nldlm_lockname[lock->l_granted_mode],\r\nldlm_lockname[lock->l_req_mode],\r\nlock->l_flags, nid, lock->l_remote_handle.cookie,\r\nexp ? atomic_read(&exp->exp_refcount) : -99,\r\nlock->l_pid, lock->l_callback_timeout, lock->l_lvb_type);\r\nva_end(args);\r\nreturn;\r\n}\r\nswitch (resource->lr_type) {\r\ncase LDLM_EXTENT:\r\nlibcfs_debug_vmsg2(msgdata, fmt, args,\r\n" ns: %s lock: %p/%#llx lrc: %d/%d,%d mode: %s/%s res: " DLDLMRES " rrc: %d type: %s [%llu->%llu] (req %llu->%llu) flags: %#llx nid: %s remote: %#llx expref: %d pid: %u timeout: %lu lvb_type: %d\n",\r\nldlm_lock_to_ns_name(lock), lock,\r\nlock->l_handle.h_cookie, atomic_read(&lock->l_refc),\r\nlock->l_readers, lock->l_writers,\r\nldlm_lockname[lock->l_granted_mode],\r\nldlm_lockname[lock->l_req_mode],\r\nPLDLMRES(resource),\r\natomic_read(&resource->lr_refcount),\r\nldlm_typename[resource->lr_type],\r\nlock->l_policy_data.l_extent.start,\r\nlock->l_policy_data.l_extent.end,\r\nlock->l_req_extent.start, lock->l_req_extent.end,\r\nlock->l_flags, nid, lock->l_remote_handle.cookie,\r\nexp ? atomic_read(&exp->exp_refcount) : -99,\r\nlock->l_pid, lock->l_callback_timeout,\r\nlock->l_lvb_type);\r\nbreak;\r\ncase LDLM_FLOCK:\r\nlibcfs_debug_vmsg2(msgdata, fmt, args,\r\n" ns: %s lock: %p/%#llx lrc: %d/%d,%d mode: %s/%s res: " DLDLMRES " rrc: %d type: %s pid: %d [%llu->%llu] flags: %#llx nid: %s remote: %#llx expref: %d pid: %u timeout: %lu\n",\r\nldlm_lock_to_ns_name(lock), lock,\r\nlock->l_handle.h_cookie, atomic_read(&lock->l_refc),\r\nlock->l_readers, lock->l_writers,\r\nldlm_lockname[lock->l_granted_mode],\r\nldlm_lockname[lock->l_req_mode],\r\nPLDLMRES(resource),\r\natomic_read(&resource->lr_refcount),\r\nldlm_typename[resource->lr_type],\r\nlock->l_policy_data.l_flock.pid,\r\nlock->l_policy_data.l_flock.start,\r\nlock->l_policy_data.l_flock.end,\r\nlock->l_flags, nid, lock->l_remote_handle.cookie,\r\nexp ? atomic_read(&exp->exp_refcount) : -99,\r\nlock->l_pid, lock->l_callback_timeout);\r\nbreak;\r\ncase LDLM_IBITS:\r\nlibcfs_debug_vmsg2(msgdata, fmt, args,\r\n" ns: %s lock: %p/%#llx lrc: %d/%d,%d mode: %s/%s res: " DLDLMRES " bits %#llx rrc: %d type: %s flags: %#llx nid: %s remote: %#llx expref: %d pid: %u timeout: %lu lvb_type: %d\n",\r\nldlm_lock_to_ns_name(lock),\r\nlock, lock->l_handle.h_cookie,\r\natomic_read(&lock->l_refc),\r\nlock->l_readers, lock->l_writers,\r\nldlm_lockname[lock->l_granted_mode],\r\nldlm_lockname[lock->l_req_mode],\r\nPLDLMRES(resource),\r\nlock->l_policy_data.l_inodebits.bits,\r\natomic_read(&resource->lr_refcount),\r\nldlm_typename[resource->lr_type],\r\nlock->l_flags, nid, lock->l_remote_handle.cookie,\r\nexp ? atomic_read(&exp->exp_refcount) : -99,\r\nlock->l_pid, lock->l_callback_timeout,\r\nlock->l_lvb_type);\r\nbreak;\r\ndefault:\r\nlibcfs_debug_vmsg2(msgdata, fmt, args,\r\n" ns: %s lock: %p/%#llx lrc: %d/%d,%d mode: %s/%s res: " DLDLMRES " rrc: %d type: %s flags: %#llx nid: %s remote: %#llx expref: %d pid: %u timeout: %lu lvb_type: %d\n",\r\nldlm_lock_to_ns_name(lock),\r\nlock, lock->l_handle.h_cookie,\r\natomic_read(&lock->l_refc),\r\nlock->l_readers, lock->l_writers,\r\nldlm_lockname[lock->l_granted_mode],\r\nldlm_lockname[lock->l_req_mode],\r\nPLDLMRES(resource),\r\natomic_read(&resource->lr_refcount),\r\nldlm_typename[resource->lr_type],\r\nlock->l_flags, nid, lock->l_remote_handle.cookie,\r\nexp ? atomic_read(&exp->exp_refcount) : -99,\r\nlock->l_pid, lock->l_callback_timeout,\r\nlock->l_lvb_type);\r\nbreak;\r\n}\r\nva_end(args);\r\n}
