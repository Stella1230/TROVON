static inline int bh1770_lux_interrupt_control(struct bh1770_chip *chip,\r\nint lux)\r\n{\r\nchip->int_mode_lux = lux;\r\nreturn i2c_smbus_write_byte_data(chip->client,\r\nBH1770_INTERRUPT,\r\n(lux << 1) | chip->int_mode_prox);\r\n}\r\nstatic inline int bh1770_prox_interrupt_control(struct bh1770_chip *chip,\r\nint ps)\r\n{\r\nchip->int_mode_prox = ps;\r\nreturn i2c_smbus_write_byte_data(chip->client,\r\nBH1770_INTERRUPT,\r\n(chip->int_mode_lux << 1) | (ps << 0));\r\n}\r\nstatic int bh1770_lux_rate(struct bh1770_chip *chip, int rate_index)\r\n{\r\nif (pm_runtime_suspended(&chip->client->dev))\r\nreturn 0;\r\nif (chip->prox_enable_count)\r\nrate_index = 0;\r\nreturn i2c_smbus_write_byte_data(chip->client,\r\nBH1770_ALS_MEAS_RATE,\r\nrate_index);\r\n}\r\nstatic int bh1770_prox_rate(struct bh1770_chip *chip, int mode)\r\n{\r\nint rate;\r\nrate = (mode == PROX_ABOVE_THRESHOLD) ?\r\nchip->prox_rate_threshold : chip->prox_rate;\r\nreturn i2c_smbus_write_byte_data(chip->client,\r\nBH1770_PS_MEAS_RATE,\r\nrate);\r\n}\r\nstatic inline int bh1770_led_cfg(struct bh1770_chip *chip)\r\n{\r\nreturn i2c_smbus_write_byte_data(chip->client,\r\nBH1770_I_LED,\r\n(BH1770_LED1 << 6) |\r\n(BH1770_LED_5mA << 3) |\r\nchip->prox_led);\r\n}\r\nstatic inline u8 bh1770_psraw_to_adjusted(struct bh1770_chip *chip, u8 psraw)\r\n{\r\nu16 adjusted;\r\nadjusted = (u16)(((u32)(psraw + chip->prox_const) * chip->prox_coef) /\r\nBH1770_COEF_SCALER);\r\nif (adjusted > BH1770_PROX_RANGE)\r\nadjusted = BH1770_PROX_RANGE;\r\nreturn adjusted;\r\n}\r\nstatic inline u8 bh1770_psadjusted_to_raw(struct bh1770_chip *chip, u8 ps)\r\n{\r\nu16 raw;\r\nraw = (((u32)ps * BH1770_COEF_SCALER) / chip->prox_coef);\r\nif (raw > chip->prox_const)\r\nraw = raw - chip->prox_const;\r\nelse\r\nraw = 0;\r\nreturn raw;\r\n}\r\nstatic int bh1770_prox_set_threshold(struct bh1770_chip *chip)\r\n{\r\nu8 tmp = 0;\r\nif (pm_runtime_suspended(&chip->client->dev))\r\nreturn 0;\r\ntmp = bh1770_psadjusted_to_raw(chip, chip->prox_threshold);\r\nchip->prox_threshold_hw = tmp;\r\nreturn i2c_smbus_write_byte_data(chip->client, BH1770_PS_TH_LED1,\r\ntmp);\r\n}\r\nstatic inline u16 bh1770_lux_raw_to_adjusted(struct bh1770_chip *chip, u16 raw)\r\n{\r\nu32 lux;\r\nlux = ((u32)raw * chip->lux_corr) / BH1770_LUX_CORR_SCALE;\r\nreturn min(lux, (u32)BH1770_LUX_RANGE);\r\n}\r\nstatic inline u16 bh1770_lux_adjusted_to_raw(struct bh1770_chip *chip,\r\nu16 adjusted)\r\n{\r\nreturn (u32)adjusted * BH1770_LUX_CORR_SCALE / chip->lux_corr;\r\n}\r\nstatic int bh1770_lux_update_thresholds(struct bh1770_chip *chip,\r\nu16 threshold_hi, u16 threshold_lo)\r\n{\r\nu8 data[4];\r\nint ret;\r\nif (pm_runtime_suspended(&chip->client->dev))\r\nreturn 0;\r\nif (threshold_hi != BH1770_LUX_RANGE && threshold_hi != 0)\r\nthreshold_hi = bh1770_lux_adjusted_to_raw(chip, threshold_hi);\r\nif (threshold_lo != BH1770_LUX_RANGE && threshold_lo != 0)\r\nthreshold_lo = bh1770_lux_adjusted_to_raw(chip, threshold_lo);\r\nif (chip->lux_thres_hi_onchip == threshold_hi &&\r\nchip->lux_thres_lo_onchip == threshold_lo)\r\nreturn 0;\r\nchip->lux_thres_hi_onchip = threshold_hi;\r\nchip->lux_thres_lo_onchip = threshold_lo;\r\ndata[0] = threshold_hi;\r\ndata[1] = threshold_hi >> 8;\r\ndata[2] = threshold_lo;\r\ndata[3] = threshold_lo >> 8;\r\nret = i2c_smbus_write_i2c_block_data(chip->client,\r\nBH1770_ALS_TH_UP_0,\r\nARRAY_SIZE(data),\r\ndata);\r\nreturn ret;\r\n}\r\nstatic int bh1770_lux_get_result(struct bh1770_chip *chip)\r\n{\r\nu16 data;\r\nint ret;\r\nret = i2c_smbus_read_byte_data(chip->client, BH1770_ALS_DATA_0);\r\nif (ret < 0)\r\nreturn ret;\r\ndata = ret & 0xff;\r\nret = i2c_smbus_read_byte_data(chip->client, BH1770_ALS_DATA_1);\r\nif (ret < 0)\r\nreturn ret;\r\nchip->lux_data_raw = data | ((ret & 0xff) << 8);\r\nreturn 0;\r\n}\r\nstatic u32 bh1770_get_corr_value(struct bh1770_chip *chip)\r\n{\r\nu32 tmp;\r\ntmp = (BH1770_LUX_CORR_SCALE * chip->lux_ga) / BH1770_LUX_GA_SCALE;\r\ntmp = (tmp * chip->lux_cf) / BH1770_LUX_CF_SCALE;\r\ntmp = (tmp * chip->lux_calib) / BH1770_CALIB_SCALER;\r\nreturn tmp;\r\n}\r\nstatic int bh1770_lux_read_result(struct bh1770_chip *chip)\r\n{\r\nbh1770_lux_get_result(chip);\r\nreturn bh1770_lux_raw_to_adjusted(chip, chip->lux_data_raw);\r\n}\r\nstatic int bh1770_chip_on(struct bh1770_chip *chip)\r\n{\r\nint ret = regulator_bulk_enable(ARRAY_SIZE(chip->regs),\r\nchip->regs);\r\nif (ret < 0)\r\nreturn ret;\r\nusleep_range(BH1770_STARTUP_DELAY, BH1770_STARTUP_DELAY * 2);\r\ni2c_smbus_write_byte_data(chip->client, BH1770_ALS_CONTROL,\r\nBH1770_SWRESET);\r\nusleep_range(BH1770_RESET_TIME, BH1770_RESET_TIME * 2);\r\nchip->lux_data_raw = 0;\r\nchip->prox_data = 0;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nBH1770_ALS_CONTROL, BH1770_STANDALONE);\r\nchip->lux_thres_hi_onchip = BH1770_LUX_RANGE;\r\nchip->lux_thres_lo_onchip = 0;\r\nreturn ret;\r\n}\r\nstatic void bh1770_chip_off(struct bh1770_chip *chip)\r\n{\r\ni2c_smbus_write_byte_data(chip->client,\r\nBH1770_INTERRUPT, BH1770_DISABLE);\r\ni2c_smbus_write_byte_data(chip->client,\r\nBH1770_ALS_CONTROL, BH1770_STANDBY);\r\ni2c_smbus_write_byte_data(chip->client,\r\nBH1770_PS_CONTROL, BH1770_STANDBY);\r\nregulator_bulk_disable(ARRAY_SIZE(chip->regs), chip->regs);\r\n}\r\nstatic int bh1770_prox_mode_control(struct bh1770_chip *chip)\r\n{\r\nif (chip->prox_enable_count) {\r\nchip->prox_force_update = true;\r\nbh1770_lux_rate(chip, chip->lux_rate_index);\r\nbh1770_prox_set_threshold(chip);\r\nbh1770_led_cfg(chip);\r\nbh1770_prox_rate(chip, PROX_BELOW_THRESHOLD);\r\nbh1770_prox_interrupt_control(chip, BH1770_ENABLE);\r\ni2c_smbus_write_byte_data(chip->client,\r\nBH1770_PS_CONTROL, BH1770_STANDALONE);\r\n} else {\r\nchip->prox_data = 0;\r\nbh1770_lux_rate(chip, chip->lux_rate_index);\r\nbh1770_prox_interrupt_control(chip, BH1770_DISABLE);\r\ni2c_smbus_write_byte_data(chip->client,\r\nBH1770_PS_CONTROL, BH1770_STANDBY);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bh1770_prox_read_result(struct bh1770_chip *chip)\r\n{\r\nint ret;\r\nbool above;\r\nu8 mode;\r\nret = i2c_smbus_read_byte_data(chip->client, BH1770_PS_DATA_LED1);\r\nif (ret < 0)\r\ngoto out;\r\nif (ret > chip->prox_threshold_hw)\r\nabove = true;\r\nelse\r\nabove = false;\r\nif (chip->lux_data_raw > PROX_IGNORE_LUX_LIMIT)\r\nret = 0;\r\nchip->prox_data = bh1770_psraw_to_adjusted(chip, ret);\r\nif (chip->prox_data >= chip->prox_abs_thres ||\r\nchip->prox_force_update)\r\nchip->prox_persistence_counter = chip->prox_persistence;\r\nchip->prox_force_update = false;\r\nif (likely(above)) {\r\nif (chip->prox_persistence_counter < chip->prox_persistence) {\r\nchip->prox_persistence_counter++;\r\nret = -ENODATA;\r\n} else {\r\nmode = PROX_ABOVE_THRESHOLD;\r\nret = 0;\r\n}\r\n} else {\r\nchip->prox_persistence_counter = 0;\r\nmode = PROX_BELOW_THRESHOLD;\r\nchip->prox_data = 0;\r\nret = 0;\r\n}\r\nif (ret == 0) {\r\nbh1770_prox_rate(chip, mode);\r\nsysfs_notify(&chip->client->dev.kobj, NULL, "prox0_raw");\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int bh1770_detect(struct bh1770_chip *chip)\r\n{\r\nstruct i2c_client *client = chip->client;\r\ns32 ret;\r\nu8 manu, part;\r\nret = i2c_smbus_read_byte_data(client, BH1770_MANUFACT_ID);\r\nif (ret < 0)\r\ngoto error;\r\nmanu = (u8)ret;\r\nret = i2c_smbus_read_byte_data(client, BH1770_PART_ID);\r\nif (ret < 0)\r\ngoto error;\r\npart = (u8)ret;\r\nchip->revision = (part & BH1770_REV_MASK) >> BH1770_REV_SHIFT;\r\nchip->prox_coef = BH1770_COEF_SCALER;\r\nchip->prox_const = 0;\r\nchip->lux_cf = BH1770_NEUTRAL_CF;\r\nif ((manu == BH1770_MANUFACT_ROHM) &&\r\n((part & BH1770_PART_MASK) == BH1770_PART)) {\r\nsnprintf(chip->chipname, sizeof(chip->chipname), "BH1770GLC");\r\nreturn 0;\r\n}\r\nif ((manu == BH1770_MANUFACT_OSRAM) &&\r\n((part & BH1770_PART_MASK) == BH1770_PART)) {\r\nsnprintf(chip->chipname, sizeof(chip->chipname), "SFH7770");\r\nchip->prox_coef = 819;\r\nchip->prox_const = 40;\r\nreturn 0;\r\n}\r\nret = -ENODEV;\r\nerror:\r\ndev_dbg(&client->dev, "BH1770 or SFH7770 not found\n");\r\nreturn ret;\r\n}\r\nstatic void bh1770_prox_work(struct work_struct *work)\r\n{\r\nstruct bh1770_chip *chip =\r\ncontainer_of(work, struct bh1770_chip, prox_work.work);\r\nmutex_lock(&chip->mutex);\r\nbh1770_prox_read_result(chip);\r\nmutex_unlock(&chip->mutex);\r\n}\r\nstatic irqreturn_t bh1770_irq(int irq, void *data)\r\n{\r\nstruct bh1770_chip *chip = data;\r\nint status;\r\nint rate = 0;\r\nmutex_lock(&chip->mutex);\r\nstatus = i2c_smbus_read_byte_data(chip->client, BH1770_ALS_PS_STATUS);\r\ni2c_smbus_read_byte_data(chip->client, BH1770_INTERRUPT);\r\nif (status & BH1770_INT_ALS_DATA) {\r\nbh1770_lux_get_result(chip);\r\nif (unlikely(chip->lux_wait_result)) {\r\nchip->lux_wait_result = false;\r\nwake_up(&chip->wait);\r\nbh1770_lux_update_thresholds(chip,\r\nchip->lux_threshold_hi,\r\nchip->lux_threshold_lo);\r\n}\r\n}\r\ni2c_smbus_write_byte_data(chip->client, BH1770_INTERRUPT,\r\n(0 << 1) | (0 << 0));\r\nif ((status & BH1770_INT_ALS_INT))\r\nsysfs_notify(&chip->client->dev.kobj, NULL, "lux0_input");\r\nif (chip->int_mode_prox && (status & BH1770_INT_LEDS_INT)) {\r\nrate = prox_rates_ms[chip->prox_rate_threshold];\r\nbh1770_prox_read_result(chip);\r\n}\r\ni2c_smbus_write_byte_data(chip->client, BH1770_INTERRUPT,\r\n(chip->int_mode_lux << 1) |\r\n(chip->int_mode_prox << 0));\r\nmutex_unlock(&chip->mutex);\r\nif (rate) {\r\ncancel_delayed_work_sync(&chip->prox_work);\r\nschedule_delayed_work(&chip->prox_work,\r\nmsecs_to_jiffies(rate + 50));\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic ssize_t bh1770_power_state_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nunsigned long value;\r\nssize_t ret;\r\nret = kstrtoul(buf, 0, &value);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&chip->mutex);\r\nif (value) {\r\npm_runtime_get_sync(dev);\r\nret = bh1770_lux_rate(chip, chip->lux_rate_index);\r\nif (ret < 0) {\r\npm_runtime_put(dev);\r\ngoto leave;\r\n}\r\nret = bh1770_lux_interrupt_control(chip, BH1770_ENABLE);\r\nif (ret < 0) {\r\npm_runtime_put(dev);\r\ngoto leave;\r\n}\r\nbh1770_lux_update_thresholds(chip, BH1770_LUX_DEF_THRES,\r\nBH1770_LUX_DEF_THRES);\r\nchip->lux_wait_result = true;\r\nbh1770_prox_mode_control(chip);\r\n} else if (!pm_runtime_suspended(dev)) {\r\npm_runtime_put(dev);\r\n}\r\nret = count;\r\nleave:\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t bh1770_power_state_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", !pm_runtime_suspended(dev));\r\n}\r\nstatic ssize_t bh1770_lux_result_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nssize_t ret;\r\nlong timeout;\r\nif (pm_runtime_suspended(dev))\r\nreturn -EIO;\r\ntimeout = wait_event_interruptible_timeout(chip->wait,\r\n!chip->lux_wait_result,\r\nmsecs_to_jiffies(BH1770_TIMEOUT));\r\nif (!timeout)\r\nreturn -EIO;\r\nmutex_lock(&chip->mutex);\r\nret = sprintf(buf, "%d\n", bh1770_lux_read_result(chip));\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t bh1770_lux_range_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", BH1770_LUX_RANGE);\r\n}\r\nstatic ssize_t bh1770_prox_enable_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nunsigned long value;\r\nint ret;\r\nret = kstrtoul(buf, 0, &value);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&chip->mutex);\r\nif (!chip->prox_enable_count)\r\nchip->prox_data = 0;\r\nif (value)\r\nchip->prox_enable_count++;\r\nelse if (chip->prox_enable_count > 0)\r\nchip->prox_enable_count--;\r\nelse\r\ngoto leave;\r\nif (!pm_runtime_suspended(dev))\r\nbh1770_prox_mode_control(chip);\r\nleave:\r\nmutex_unlock(&chip->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t bh1770_prox_enable_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nssize_t len;\r\nmutex_lock(&chip->mutex);\r\nlen = sprintf(buf, "%d\n", chip->prox_enable_count);\r\nmutex_unlock(&chip->mutex);\r\nreturn len;\r\n}\r\nstatic ssize_t bh1770_prox_result_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nssize_t ret;\r\nmutex_lock(&chip->mutex);\r\nif (chip->prox_enable_count && !pm_runtime_suspended(dev))\r\nret = sprintf(buf, "%d\n", chip->prox_data);\r\nelse\r\nret = -EIO;\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t bh1770_prox_range_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", BH1770_PROX_RANGE);\r\n}\r\nstatic ssize_t bh1770_get_prox_rate_avail(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint i;\r\nint pos = 0;\r\nfor (i = 0; i < ARRAY_SIZE(prox_rates_hz); i++)\r\npos += sprintf(buf + pos, "%d ", prox_rates_hz[i]);\r\nsprintf(buf + pos - 1, "\n");\r\nreturn pos;\r\n}\r\nstatic ssize_t bh1770_get_prox_rate_above(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", prox_rates_hz[chip->prox_rate_threshold]);\r\n}\r\nstatic ssize_t bh1770_get_prox_rate_below(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", prox_rates_hz[chip->prox_rate]);\r\n}\r\nstatic int bh1770_prox_rate_validate(int rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(prox_rates_hz) - 1; i++)\r\nif (rate >= prox_rates_hz[i])\r\nbreak;\r\nreturn i;\r\n}\r\nstatic ssize_t bh1770_set_prox_rate_above(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nunsigned long value;\r\nint ret;\r\nret = kstrtoul(buf, 0, &value);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&chip->mutex);\r\nchip->prox_rate_threshold = bh1770_prox_rate_validate(value);\r\nmutex_unlock(&chip->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t bh1770_set_prox_rate_below(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nunsigned long value;\r\nint ret;\r\nret = kstrtoul(buf, 0, &value);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&chip->mutex);\r\nchip->prox_rate = bh1770_prox_rate_validate(value);\r\nmutex_unlock(&chip->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t bh1770_get_prox_thres(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", chip->prox_threshold);\r\n}\r\nstatic ssize_t bh1770_set_prox_thres(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nunsigned long value;\r\nint ret;\r\nret = kstrtoul(buf, 0, &value);\r\nif (ret)\r\nreturn ret;\r\nif (value > BH1770_PROX_RANGE)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mutex);\r\nchip->prox_threshold = value;\r\nret = bh1770_prox_set_threshold(chip);\r\nmutex_unlock(&chip->mutex);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t bh1770_prox_persistence_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", chip->prox_persistence);\r\n}\r\nstatic ssize_t bh1770_prox_persistence_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nunsigned long value;\r\nint ret;\r\nret = kstrtoul(buf, 0, &value);\r\nif (ret)\r\nreturn ret;\r\nif (value > BH1770_PROX_MAX_PERSISTENCE)\r\nreturn -EINVAL;\r\nchip->prox_persistence = value;\r\nreturn len;\r\n}\r\nstatic ssize_t bh1770_prox_abs_thres_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", chip->prox_abs_thres);\r\n}\r\nstatic ssize_t bh1770_prox_abs_thres_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nunsigned long value;\r\nint ret;\r\nret = kstrtoul(buf, 0, &value);\r\nif (ret)\r\nreturn ret;\r\nif (value > BH1770_PROX_RANGE)\r\nreturn -EINVAL;\r\nchip->prox_abs_thres = value;\r\nreturn len;\r\n}\r\nstatic ssize_t bh1770_chip_id_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s rev %d\n", chip->chipname, chip->revision);\r\n}\r\nstatic ssize_t bh1770_lux_calib_default_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", BH1770_CALIB_SCALER);\r\n}\r\nstatic ssize_t bh1770_lux_calib_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nssize_t len;\r\nmutex_lock(&chip->mutex);\r\nlen = sprintf(buf, "%u\n", chip->lux_calib);\r\nmutex_unlock(&chip->mutex);\r\nreturn len;\r\n}\r\nstatic ssize_t bh1770_lux_calib_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nunsigned long value;\r\nu32 old_calib;\r\nu32 new_corr;\r\nint ret;\r\nret = kstrtoul(buf, 0, &value);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&chip->mutex);\r\nold_calib = chip->lux_calib;\r\nchip->lux_calib = value;\r\nnew_corr = bh1770_get_corr_value(chip);\r\nif (new_corr == 0) {\r\nchip->lux_calib = old_calib;\r\nmutex_unlock(&chip->mutex);\r\nreturn -EINVAL;\r\n}\r\nchip->lux_corr = new_corr;\r\nbh1770_lux_update_thresholds(chip, chip->lux_threshold_hi,\r\nchip->lux_threshold_lo);\r\nmutex_unlock(&chip->mutex);\r\nreturn len;\r\n}\r\nstatic ssize_t bh1770_get_lux_rate_avail(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint i;\r\nint pos = 0;\r\nfor (i = 0; i < ARRAY_SIZE(lux_rates_hz); i++)\r\npos += sprintf(buf + pos, "%d ", lux_rates_hz[i]);\r\nsprintf(buf + pos - 1, "\n");\r\nreturn pos;\r\n}\r\nstatic ssize_t bh1770_get_lux_rate(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", lux_rates_hz[chip->lux_rate_index]);\r\n}\r\nstatic ssize_t bh1770_set_lux_rate(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nunsigned long rate_hz;\r\nint ret, i;\r\nret = kstrtoul(buf, 0, &rate_hz);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < ARRAY_SIZE(lux_rates_hz) - 1; i++)\r\nif (rate_hz >= lux_rates_hz[i])\r\nbreak;\r\nmutex_lock(&chip->mutex);\r\nchip->lux_rate_index = i;\r\nret = bh1770_lux_rate(chip, i);\r\nmutex_unlock(&chip->mutex);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t bh1770_get_lux_thresh_above(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", chip->lux_threshold_hi);\r\n}\r\nstatic ssize_t bh1770_get_lux_thresh_below(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", chip->lux_threshold_lo);\r\n}\r\nstatic ssize_t bh1770_set_lux_thresh(struct bh1770_chip *chip, u16 *target,\r\nconst char *buf)\r\n{\r\nunsigned long thresh;\r\nint ret;\r\nret = kstrtoul(buf, 0, &thresh);\r\nif (ret)\r\nreturn ret;\r\nif (thresh > BH1770_LUX_RANGE)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mutex);\r\n*target = thresh;\r\nif (!chip->lux_wait_result)\r\nret = bh1770_lux_update_thresholds(chip,\r\nchip->lux_threshold_hi,\r\nchip->lux_threshold_lo);\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t bh1770_set_lux_thresh_above(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nint ret = bh1770_set_lux_thresh(chip, &chip->lux_threshold_hi, buf);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic ssize_t bh1770_set_lux_thresh_below(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct bh1770_chip *chip = dev_get_drvdata(dev);\r\nint ret = bh1770_set_lux_thresh(chip, &chip->lux_threshold_lo, buf);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic int bh1770_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct bh1770_chip *chip;\r\nint err;\r\nchip = devm_kzalloc(&client->dev, sizeof *chip, GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, chip);\r\nchip->client = client;\r\nmutex_init(&chip->mutex);\r\ninit_waitqueue_head(&chip->wait);\r\nINIT_DELAYED_WORK(&chip->prox_work, bh1770_prox_work);\r\nif (client->dev.platform_data == NULL) {\r\ndev_err(&client->dev, "platform data is mandatory\n");\r\nreturn -EINVAL;\r\n}\r\nchip->pdata = client->dev.platform_data;\r\nchip->lux_calib = BH1770_LUX_NEUTRAL_CALIB_VALUE;\r\nchip->lux_rate_index = BH1770_LUX_DEFAULT_RATE;\r\nchip->lux_threshold_lo = BH1770_LUX_DEF_THRES;\r\nchip->lux_threshold_hi = BH1770_LUX_DEF_THRES;\r\nif (chip->pdata->glass_attenuation == 0)\r\nchip->lux_ga = BH1770_NEUTRAL_GA;\r\nelse\r\nchip->lux_ga = chip->pdata->glass_attenuation;\r\nchip->prox_threshold = BH1770_PROX_DEF_THRES;\r\nchip->prox_led = chip->pdata->led_def_curr;\r\nchip->prox_abs_thres = BH1770_PROX_DEF_ABS_THRES;\r\nchip->prox_persistence = BH1770_DEFAULT_PERSISTENCE;\r\nchip->prox_rate_threshold = BH1770_PROX_DEF_RATE_THRESH;\r\nchip->prox_rate = BH1770_PROX_DEFAULT_RATE;\r\nchip->prox_data = 0;\r\nchip->regs[0].supply = reg_vcc;\r\nchip->regs[1].supply = reg_vleds;\r\nerr = devm_regulator_bulk_get(&client->dev,\r\nARRAY_SIZE(chip->regs), chip->regs);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Cannot get regulators\n");\r\nreturn err;\r\n}\r\nerr = regulator_bulk_enable(ARRAY_SIZE(chip->regs),\r\nchip->regs);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Cannot enable regulators\n");\r\nreturn err;\r\n}\r\nusleep_range(BH1770_STARTUP_DELAY, BH1770_STARTUP_DELAY * 2);\r\nerr = bh1770_detect(chip);\r\nif (err < 0)\r\ngoto fail0;\r\nbh1770_chip_on(chip);\r\npm_runtime_set_active(&client->dev);\r\npm_runtime_enable(&client->dev);\r\nchip->lux_corr = bh1770_get_corr_value(chip);\r\nif (chip->lux_corr == 0) {\r\ndev_err(&client->dev, "Improper correction values\n");\r\nerr = -EINVAL;\r\ngoto fail0;\r\n}\r\nif (chip->pdata->setup_resources) {\r\nerr = chip->pdata->setup_resources();\r\nif (err) {\r\nerr = -EINVAL;\r\ngoto fail0;\r\n}\r\n}\r\nerr = sysfs_create_group(&chip->client->dev.kobj,\r\n&bh1770_attribute_group);\r\nif (err < 0) {\r\ndev_err(&chip->client->dev, "Sysfs registration failed\n");\r\ngoto fail1;\r\n}\r\nerr = request_threaded_irq(client->irq, NULL,\r\nbh1770_irq,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT |\r\nIRQF_TRIGGER_LOW,\r\n"bh1770", chip);\r\nif (err) {\r\ndev_err(&client->dev, "could not get IRQ %d\n",\r\nclient->irq);\r\ngoto fail2;\r\n}\r\nregulator_bulk_disable(ARRAY_SIZE(chip->regs), chip->regs);\r\nreturn err;\r\nfail2:\r\nsysfs_remove_group(&chip->client->dev.kobj,\r\n&bh1770_attribute_group);\r\nfail1:\r\nif (chip->pdata->release_resources)\r\nchip->pdata->release_resources();\r\nfail0:\r\nregulator_bulk_disable(ARRAY_SIZE(chip->regs), chip->regs);\r\nreturn err;\r\n}\r\nstatic int bh1770_remove(struct i2c_client *client)\r\n{\r\nstruct bh1770_chip *chip = i2c_get_clientdata(client);\r\nfree_irq(client->irq, chip);\r\nsysfs_remove_group(&chip->client->dev.kobj,\r\n&bh1770_attribute_group);\r\nif (chip->pdata->release_resources)\r\nchip->pdata->release_resources();\r\ncancel_delayed_work_sync(&chip->prox_work);\r\nif (!pm_runtime_suspended(&client->dev))\r\nbh1770_chip_off(chip);\r\npm_runtime_disable(&client->dev);\r\npm_runtime_set_suspended(&client->dev);\r\nreturn 0;\r\n}\r\nstatic int bh1770_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = container_of(dev, struct i2c_client, dev);\r\nstruct bh1770_chip *chip = i2c_get_clientdata(client);\r\nbh1770_chip_off(chip);\r\nreturn 0;\r\n}\r\nstatic int bh1770_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = container_of(dev, struct i2c_client, dev);\r\nstruct bh1770_chip *chip = i2c_get_clientdata(client);\r\nint ret = 0;\r\nbh1770_chip_on(chip);\r\nif (!pm_runtime_suspended(dev)) {\r\nret = bh1770_lux_rate(chip, chip->lux_rate_index);\r\nret |= bh1770_lux_interrupt_control(chip, BH1770_ENABLE);\r\nbh1770_lux_update_thresholds(chip, BH1770_LUX_DEF_THRES,\r\nBH1770_LUX_DEF_THRES);\r\nchip->lux_wait_result = true;\r\nbh1770_prox_mode_control(chip);\r\n}\r\nreturn ret;\r\n}\r\nstatic int bh1770_runtime_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = container_of(dev, struct i2c_client, dev);\r\nstruct bh1770_chip *chip = i2c_get_clientdata(client);\r\nbh1770_chip_off(chip);\r\nreturn 0;\r\n}\r\nstatic int bh1770_runtime_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = container_of(dev, struct i2c_client, dev);\r\nstruct bh1770_chip *chip = i2c_get_clientdata(client);\r\nbh1770_chip_on(chip);\r\nreturn 0;\r\n}
