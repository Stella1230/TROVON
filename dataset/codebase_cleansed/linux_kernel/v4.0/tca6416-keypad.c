static int tca6416_write_reg(struct tca6416_keypad_chip *chip, int reg, u16 val)\r\n{\r\nint error;\r\nerror = chip->io_size > 8 ?\r\ni2c_smbus_write_word_data(chip->client, reg << 1, val) :\r\ni2c_smbus_write_byte_data(chip->client, reg, val);\r\nif (error < 0) {\r\ndev_err(&chip->client->dev,\r\n"%s failed, reg: %d, val: %d, error: %d\n",\r\n__func__, reg, val, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tca6416_read_reg(struct tca6416_keypad_chip *chip, int reg, u16 *val)\r\n{\r\nint retval;\r\nretval = chip->io_size > 8 ?\r\ni2c_smbus_read_word_data(chip->client, reg << 1) :\r\ni2c_smbus_read_byte_data(chip->client, reg);\r\nif (retval < 0) {\r\ndev_err(&chip->client->dev, "%s failed, reg: %d, error: %d\n",\r\n__func__, reg, retval);\r\nreturn retval;\r\n}\r\n*val = (u16)retval;\r\nreturn 0;\r\n}\r\nstatic void tca6416_keys_scan(struct tca6416_keypad_chip *chip)\r\n{\r\nstruct input_dev *input = chip->input;\r\nu16 reg_val, val;\r\nint error, i, pin_index;\r\nerror = tca6416_read_reg(chip, TCA6416_INPUT, &reg_val);\r\nif (error)\r\nreturn;\r\nreg_val &= chip->pinmask;\r\nval = reg_val ^ chip->reg_input;\r\nchip->reg_input = reg_val;\r\nfor (i = 0, pin_index = 0; i < 16; i++) {\r\nif (val & (1 << i)) {\r\nstruct tca6416_button *button = &chip->buttons[pin_index];\r\nunsigned int type = button->type ?: EV_KEY;\r\nint state = ((reg_val & (1 << i)) ? 1 : 0)\r\n^ button->active_low;\r\ninput_event(input, type, button->code, !!state);\r\ninput_sync(input);\r\n}\r\nif (chip->pinmask & (1 << i))\r\npin_index++;\r\n}\r\n}\r\nstatic irqreturn_t tca6416_keys_isr(int irq, void *dev_id)\r\n{\r\nstruct tca6416_keypad_chip *chip = dev_id;\r\ntca6416_keys_scan(chip);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tca6416_keys_work_func(struct work_struct *work)\r\n{\r\nstruct tca6416_keypad_chip *chip =\r\ncontainer_of(work, struct tca6416_keypad_chip, dwork.work);\r\ntca6416_keys_scan(chip);\r\nschedule_delayed_work(&chip->dwork, msecs_to_jiffies(100));\r\n}\r\nstatic int tca6416_keys_open(struct input_dev *dev)\r\n{\r\nstruct tca6416_keypad_chip *chip = input_get_drvdata(dev);\r\ntca6416_keys_scan(chip);\r\nif (chip->use_polling)\r\nschedule_delayed_work(&chip->dwork, msecs_to_jiffies(100));\r\nelse\r\nenable_irq(chip->irqnum);\r\nreturn 0;\r\n}\r\nstatic void tca6416_keys_close(struct input_dev *dev)\r\n{\r\nstruct tca6416_keypad_chip *chip = input_get_drvdata(dev);\r\nif (chip->use_polling)\r\ncancel_delayed_work_sync(&chip->dwork);\r\nelse\r\ndisable_irq(chip->irqnum);\r\n}\r\nstatic int tca6416_setup_registers(struct tca6416_keypad_chip *chip)\r\n{\r\nint error;\r\nerror = tca6416_read_reg(chip, TCA6416_OUTPUT, &chip->reg_output);\r\nif (error)\r\nreturn error;\r\nerror = tca6416_read_reg(chip, TCA6416_DIRECTION, &chip->reg_direction);\r\nif (error)\r\nreturn error;\r\nerror = tca6416_write_reg(chip, TCA6416_DIRECTION,\r\nchip->reg_direction | chip->pinmask);\r\nif (error)\r\nreturn error;\r\nerror = tca6416_read_reg(chip, TCA6416_DIRECTION, &chip->reg_direction);\r\nif (error)\r\nreturn error;\r\nerror = tca6416_read_reg(chip, TCA6416_INPUT, &chip->reg_input);\r\nif (error)\r\nreturn error;\r\nchip->reg_input &= chip->pinmask;\r\nreturn 0;\r\n}\r\nstatic int tca6416_keypad_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tca6416_keys_platform_data *pdata;\r\nstruct tca6416_keypad_chip *chip;\r\nstruct input_dev *input;\r\nint error;\r\nint i;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE)) {\r\ndev_err(&client->dev, "%s adapter not supported\n",\r\ndev_driver_string(&client->adapter->dev));\r\nreturn -ENODEV;\r\n}\r\npdata = dev_get_platdata(&client->dev);\r\nif (!pdata) {\r\ndev_dbg(&client->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\nchip = kzalloc(sizeof(struct tca6416_keypad_chip) +\r\npdata->nbuttons * sizeof(struct tca6416_button),\r\nGFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!chip || !input) {\r\nerror = -ENOMEM;\r\ngoto fail1;\r\n}\r\nchip->client = client;\r\nchip->input = input;\r\nchip->io_size = id->driver_data;\r\nchip->pinmask = pdata->pinmask;\r\nchip->use_polling = pdata->use_polling;\r\nINIT_DELAYED_WORK(&chip->dwork, tca6416_keys_work_func);\r\ninput->phys = "tca6416-keys/input0";\r\ninput->name = client->name;\r\ninput->dev.parent = &client->dev;\r\ninput->open = tca6416_keys_open;\r\ninput->close = tca6416_keys_close;\r\ninput->id.bustype = BUS_HOST;\r\ninput->id.vendor = 0x0001;\r\ninput->id.product = 0x0001;\r\ninput->id.version = 0x0100;\r\nif (pdata->rep)\r\n__set_bit(EV_REP, input->evbit);\r\nfor (i = 0; i < pdata->nbuttons; i++) {\r\nunsigned int type;\r\nchip->buttons[i] = pdata->buttons[i];\r\ntype = (pdata->buttons[i].type) ?: EV_KEY;\r\ninput_set_capability(input, type, pdata->buttons[i].code);\r\n}\r\ninput_set_drvdata(input, chip);\r\nerror = tca6416_setup_registers(chip);\r\nif (error)\r\ngoto fail1;\r\nif (!chip->use_polling) {\r\nif (pdata->irq_is_gpio)\r\nchip->irqnum = gpio_to_irq(client->irq);\r\nelse\r\nchip->irqnum = client->irq;\r\nerror = request_threaded_irq(chip->irqnum, NULL,\r\ntca6416_keys_isr,\r\nIRQF_TRIGGER_FALLING |\r\nIRQF_ONESHOT,\r\n"tca6416-keypad", chip);\r\nif (error) {\r\ndev_dbg(&client->dev,\r\n"Unable to claim irq %d; error %d\n",\r\nchip->irqnum, error);\r\ngoto fail1;\r\n}\r\ndisable_irq(chip->irqnum);\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_dbg(&client->dev,\r\n"Unable to register input device, error: %d\n", error);\r\ngoto fail2;\r\n}\r\ni2c_set_clientdata(client, chip);\r\ndevice_init_wakeup(&client->dev, 1);\r\nreturn 0;\r\nfail2:\r\nif (!chip->use_polling) {\r\nfree_irq(chip->irqnum, chip);\r\nenable_irq(chip->irqnum);\r\n}\r\nfail1:\r\ninput_free_device(input);\r\nkfree(chip);\r\nreturn error;\r\n}\r\nstatic int tca6416_keypad_remove(struct i2c_client *client)\r\n{\r\nstruct tca6416_keypad_chip *chip = i2c_get_clientdata(client);\r\nif (!chip->use_polling) {\r\nfree_irq(chip->irqnum, chip);\r\nenable_irq(chip->irqnum);\r\n}\r\ninput_unregister_device(chip->input);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int tca6416_keypad_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct tca6416_keypad_chip *chip = i2c_get_clientdata(client);\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(chip->irqnum);\r\nreturn 0;\r\n}\r\nstatic int tca6416_keypad_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct tca6416_keypad_chip *chip = i2c_get_clientdata(client);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(chip->irqnum);\r\nreturn 0;\r\n}\r\nstatic int __init tca6416_keypad_init(void)\r\n{\r\nreturn i2c_add_driver(&tca6416_keypad_driver);\r\n}\r\nstatic void __exit tca6416_keypad_exit(void)\r\n{\r\ni2c_del_driver(&tca6416_keypad_driver);\r\n}
