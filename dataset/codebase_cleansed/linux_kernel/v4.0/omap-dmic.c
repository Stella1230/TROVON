static inline void omap_dmic_write(struct omap_dmic *dmic, u16 reg, u32 val)\r\n{\r\nwritel_relaxed(val, dmic->io_base + reg);\r\n}\r\nstatic inline int omap_dmic_read(struct omap_dmic *dmic, u16 reg)\r\n{\r\nreturn readl_relaxed(dmic->io_base + reg);\r\n}\r\nstatic inline void omap_dmic_start(struct omap_dmic *dmic)\r\n{\r\nu32 ctrl = omap_dmic_read(dmic, OMAP_DMIC_CTRL_REG);\r\nomap_dmic_write(dmic, OMAP_DMIC_DMAENABLE_SET_REG,\r\nOMAP_DMIC_DMA_ENABLE);\r\nomap_dmic_write(dmic, OMAP_DMIC_CTRL_REG, ctrl | dmic->ch_enabled);\r\n}\r\nstatic inline void omap_dmic_stop(struct omap_dmic *dmic)\r\n{\r\nu32 ctrl = omap_dmic_read(dmic, OMAP_DMIC_CTRL_REG);\r\nomap_dmic_write(dmic, OMAP_DMIC_CTRL_REG,\r\nctrl & ~OMAP_DMIC_UP_ENABLE_MASK);\r\nomap_dmic_write(dmic, OMAP_DMIC_DMAENABLE_CLR_REG,\r\nOMAP_DMIC_DMA_ENABLE);\r\n}\r\nstatic inline int dmic_is_enabled(struct omap_dmic *dmic)\r\n{\r\nreturn omap_dmic_read(dmic, OMAP_DMIC_CTRL_REG) &\r\nOMAP_DMIC_UP_ENABLE_MASK;\r\n}\r\nstatic int omap_dmic_dai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct omap_dmic *dmic = snd_soc_dai_get_drvdata(dai);\r\nint ret = 0;\r\nmutex_lock(&dmic->mutex);\r\nif (!dai->active)\r\ndmic->active = 1;\r\nelse\r\nret = -EBUSY;\r\nmutex_unlock(&dmic->mutex);\r\nreturn ret;\r\n}\r\nstatic void omap_dmic_dai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct omap_dmic *dmic = snd_soc_dai_get_drvdata(dai);\r\nmutex_lock(&dmic->mutex);\r\nif (!dai->active)\r\ndmic->active = 0;\r\nmutex_unlock(&dmic->mutex);\r\n}\r\nstatic int omap_dmic_select_divider(struct omap_dmic *dmic, int sample_rate)\r\n{\r\nint divider = -EINVAL;\r\nif (sample_rate == 192000) {\r\nif (dmic->fclk_freq == 19200000 && dmic->out_freq == 3840000)\r\ndivider = 0x6;\r\nelse\r\ndev_err(dmic->dev,\r\n"invalid clock configuration for 192KHz\n");\r\nreturn divider;\r\n}\r\nswitch (dmic->out_freq) {\r\ncase 1536000:\r\nif (dmic->fclk_freq != 24576000)\r\ngoto div_err;\r\ndivider = 0x4;\r\nbreak;\r\ncase 2400000:\r\nswitch (dmic->fclk_freq) {\r\ncase 12000000:\r\ndivider = 0x5;\r\nbreak;\r\ncase 19200000:\r\ndivider = 0x0;\r\nbreak;\r\ncase 24000000:\r\ndivider = 0x2;\r\nbreak;\r\ndefault:\r\ngoto div_err;\r\n}\r\nbreak;\r\ncase 3072000:\r\nif (dmic->fclk_freq != 24576000)\r\ngoto div_err;\r\ndivider = 0x3;\r\nbreak;\r\ncase 3840000:\r\nif (dmic->fclk_freq != 19200000)\r\ngoto div_err;\r\ndivider = 0x1;\r\nbreak;\r\ndefault:\r\ndev_err(dmic->dev, "invalid out frequency: %dHz\n",\r\ndmic->out_freq);\r\nbreak;\r\n}\r\nreturn divider;\r\ndiv_err:\r\ndev_err(dmic->dev, "invalid out frequency %dHz for %dHz input\n",\r\ndmic->out_freq, dmic->fclk_freq);\r\nreturn -EINVAL;\r\n}\r\nstatic int omap_dmic_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct omap_dmic *dmic = snd_soc_dai_get_drvdata(dai);\r\nstruct snd_dmaengine_dai_dma_data *dma_data;\r\nint channels;\r\ndmic->clk_div = omap_dmic_select_divider(dmic, params_rate(params));\r\nif (dmic->clk_div < 0) {\r\ndev_err(dmic->dev, "no valid divider for %dHz from %dHz\n",\r\ndmic->out_freq, dmic->fclk_freq);\r\nreturn -EINVAL;\r\n}\r\ndmic->ch_enabled = 0;\r\nchannels = params_channels(params);\r\nswitch (channels) {\r\ncase 6:\r\ndmic->ch_enabled |= OMAP_DMIC_UP3_ENABLE;\r\ncase 4:\r\ndmic->ch_enabled |= OMAP_DMIC_UP2_ENABLE;\r\ncase 2:\r\ndmic->ch_enabled |= OMAP_DMIC_UP1_ENABLE;\r\nbreak;\r\ndefault:\r\ndev_err(dmic->dev, "invalid number of legacy channels\n");\r\nreturn -EINVAL;\r\n}\r\ndma_data = snd_soc_dai_get_dma_data(dai, substream);\r\ndma_data->maxburst = dmic->threshold * channels;\r\nreturn 0;\r\n}\r\nstatic int omap_dmic_dai_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct omap_dmic *dmic = snd_soc_dai_get_drvdata(dai);\r\nu32 ctrl;\r\nomap_dmic_write(dmic, OMAP_DMIC_FIFO_CTRL_REG, dmic->threshold);\r\nctrl = omap_dmic_read(dmic, OMAP_DMIC_CTRL_REG);\r\nctrl &= ~(OMAP_DMIC_FORMAT | OMAP_DMIC_POLAR_MASK);\r\nctrl |= (OMAP_DMICOUTFORMAT_LJUST | OMAP_DMIC_POLAR1 |\r\nOMAP_DMIC_POLAR2 | OMAP_DMIC_POLAR3);\r\nctrl &= ~OMAP_DMIC_CLK_DIV_MASK;\r\nctrl |= OMAP_DMIC_CLK_DIV(dmic->clk_div);\r\nomap_dmic_write(dmic, OMAP_DMIC_CTRL_REG, ctrl);\r\nomap_dmic_write(dmic, OMAP_DMIC_CTRL_REG,\r\nctrl | OMAP_DMICOUTFORMAT_LJUST | OMAP_DMIC_POLAR1 |\r\nOMAP_DMIC_POLAR2 | OMAP_DMIC_POLAR3);\r\nreturn 0;\r\n}\r\nstatic int omap_dmic_dai_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nstruct omap_dmic *dmic = snd_soc_dai_get_drvdata(dai);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nomap_dmic_start(dmic);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nomap_dmic_stop(dmic);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_dmic_select_fclk(struct omap_dmic *dmic, int clk_id,\r\nunsigned int freq)\r\n{\r\nstruct clk *parent_clk;\r\nchar *parent_clk_name;\r\nint ret = 0;\r\nswitch (freq) {\r\ncase 12000000:\r\ncase 19200000:\r\ncase 24000000:\r\ncase 24576000:\r\nbreak;\r\ndefault:\r\ndev_err(dmic->dev, "invalid input frequency: %dHz\n", freq);\r\ndmic->fclk_freq = 0;\r\nreturn -EINVAL;\r\n}\r\nif (dmic->sysclk == clk_id) {\r\ndmic->fclk_freq = freq;\r\nreturn 0;\r\n}\r\nif (dmic->active && dmic_is_enabled(dmic)) {\r\ndev_err(dmic->dev, "can't re-parent when DMIC active\n");\r\nreturn -EBUSY;\r\n}\r\nswitch (clk_id) {\r\ncase OMAP_DMIC_SYSCLK_PAD_CLKS:\r\nparent_clk_name = "pad_clks_ck";\r\nbreak;\r\ncase OMAP_DMIC_SYSCLK_SLIMBLUS_CLKS:\r\nparent_clk_name = "slimbus_clk";\r\nbreak;\r\ncase OMAP_DMIC_SYSCLK_SYNC_MUX_CLKS:\r\nparent_clk_name = "dmic_sync_mux_ck";\r\nbreak;\r\ndefault:\r\ndev_err(dmic->dev, "fclk clk_id (%d) not supported\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\nparent_clk = clk_get(dmic->dev, parent_clk_name);\r\nif (IS_ERR(parent_clk)) {\r\ndev_err(dmic->dev, "can't get %s\n", parent_clk_name);\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&dmic->mutex);\r\nif (dmic->active) {\r\npm_runtime_put_sync(dmic->dev);\r\nret = clk_set_parent(dmic->fclk, parent_clk);\r\npm_runtime_get_sync(dmic->dev);\r\n} else {\r\nret = clk_set_parent(dmic->fclk, parent_clk);\r\n}\r\nmutex_unlock(&dmic->mutex);\r\nif (ret < 0) {\r\ndev_err(dmic->dev, "re-parent failed\n");\r\ngoto err_busy;\r\n}\r\ndmic->sysclk = clk_id;\r\ndmic->fclk_freq = freq;\r\nerr_busy:\r\nclk_put(parent_clk);\r\nreturn ret;\r\n}\r\nstatic int omap_dmic_select_outclk(struct omap_dmic *dmic, int clk_id,\r\nunsigned int freq)\r\n{\r\nint ret = 0;\r\nif (clk_id != OMAP_DMIC_ABE_DMIC_CLK) {\r\ndev_err(dmic->dev, "output clk_id (%d) not supported\n",\r\nclk_id);\r\nreturn -EINVAL;\r\n}\r\nswitch (freq) {\r\ncase 1536000:\r\ncase 2400000:\r\ncase 3072000:\r\ncase 3840000:\r\ndmic->out_freq = freq;\r\nbreak;\r\ndefault:\r\ndev_err(dmic->dev, "invalid out frequency: %dHz\n", freq);\r\ndmic->out_freq = 0;\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int omap_dmic_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct omap_dmic *dmic = snd_soc_dai_get_drvdata(dai);\r\nif (dir == SND_SOC_CLOCK_IN)\r\nreturn omap_dmic_select_fclk(dmic, clk_id, freq);\r\nelse if (dir == SND_SOC_CLOCK_OUT)\r\nreturn omap_dmic_select_outclk(dmic, clk_id, freq);\r\ndev_err(dmic->dev, "invalid clock direction (%d)\n", dir);\r\nreturn -EINVAL;\r\n}\r\nstatic int omap_dmic_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct omap_dmic *dmic = snd_soc_dai_get_drvdata(dai);\r\npm_runtime_enable(dmic->dev);\r\npm_runtime_get_sync(dmic->dev);\r\nomap_dmic_write(dmic, OMAP_DMIC_CTRL_REG, 0x00);\r\npm_runtime_put_sync(dmic->dev);\r\ndmic->threshold = OMAP_DMIC_THRES_MAX - 3;\r\nsnd_soc_dai_init_dma_data(dai, NULL, &dmic->dma_data);\r\nreturn 0;\r\n}\r\nstatic int omap_dmic_remove(struct snd_soc_dai *dai)\r\n{\r\nstruct omap_dmic *dmic = snd_soc_dai_get_drvdata(dai);\r\npm_runtime_disable(dmic->dev);\r\nreturn 0;\r\n}\r\nstatic int asoc_dmic_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_dmic *dmic;\r\nstruct resource *res;\r\nint ret;\r\ndmic = devm_kzalloc(&pdev->dev, sizeof(struct omap_dmic), GFP_KERNEL);\r\nif (!dmic)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, dmic);\r\ndmic->dev = &pdev->dev;\r\ndmic->sysclk = OMAP_DMIC_SYSCLK_SYNC_MUX_CLKS;\r\nmutex_init(&dmic->mutex);\r\ndmic->fclk = devm_clk_get(dmic->dev, "fck");\r\nif (IS_ERR(dmic->fclk)) {\r\ndev_err(dmic->dev, "cant get fck\n");\r\nreturn -ENODEV;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dma");\r\nif (!res) {\r\ndev_err(dmic->dev, "invalid dma memory resource\n");\r\nreturn -ENODEV;\r\n}\r\ndmic->dma_data.addr = res->start + OMAP_DMIC_DATA_REG;\r\ndmic->dma_data.filter_data = "up_link";\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mpu");\r\ndmic->io_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(dmic->io_base))\r\nreturn PTR_ERR(dmic->io_base);\r\nret = devm_snd_soc_register_component(&pdev->dev,\r\n&omap_dmic_component,\r\n&omap_dmic_dai, 1);\r\nif (ret)\r\nreturn ret;\r\nret = omap_pcm_platform_register(&pdev->dev);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}
