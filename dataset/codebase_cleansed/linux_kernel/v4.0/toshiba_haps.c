static int toshiba_haps_reset_protection(acpi_handle handle)\r\n{\r\nacpi_status status;\r\nstatus = acpi_evaluate_object(handle, "RSSS", NULL, NULL);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("Unable to reset the HDD protection\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int toshiba_haps_protection_level(acpi_handle handle, int level)\r\n{\r\nacpi_status status;\r\nstatus = acpi_execute_simple_method(handle, "PTLV", level);\r\nif (ACPI_FAILURE(status)) {\r\npr_err("Error while setting the protection level\n");\r\nreturn -EIO;\r\n}\r\npr_info("HDD protection level set to: %d\n", level);\r\nreturn 0;\r\n}\r\nstatic ssize_t protection_level_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct toshiba_haps_dev *haps = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%i\n", haps->protection_level);\r\n}\r\nstatic ssize_t protection_level_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct toshiba_haps_dev *haps = dev_get_drvdata(dev);\r\nint level, ret;\r\nif (sscanf(buf, "%d", &level) != 1 || level < 0 || level > 3)\r\nreturn -EINVAL;\r\nret = toshiba_haps_protection_level(haps->acpi_dev->handle, level);\r\nif (ret != 0)\r\nreturn ret;\r\nhaps->protection_level = level;\r\nreturn count;\r\n}\r\nstatic ssize_t reset_protection_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct toshiba_haps_dev *haps = dev_get_drvdata(dev);\r\nint reset, ret;\r\nif (sscanf(buf, "%d", &reset) != 1 || reset != 1)\r\nreturn -EINVAL;\r\nret = toshiba_haps_reset_protection(haps->acpi_dev->handle);\r\nif (ret != 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic void toshiba_haps_notify(struct acpi_device *device, u32 event)\r\n{\r\npr_info("Received event: 0x%x", event);\r\nacpi_bus_generate_netlink_event(device->pnp.device_class,\r\ndev_name(&device->dev),\r\nevent, 0);\r\n}\r\nstatic int toshiba_haps_remove(struct acpi_device *device)\r\n{\r\nsysfs_remove_group(&device->dev.kobj, &haps_attr_group);\r\nif (toshiba_haps)\r\ntoshiba_haps = NULL;\r\nreturn 0;\r\n}\r\nstatic int toshiba_haps_available(acpi_handle handle)\r\n{\r\nacpi_status status;\r\nu64 hdd_present;\r\nstatus = acpi_evaluate_integer(handle, "_STA", NULL,\r\n&hdd_present);\r\nif (ACPI_FAILURE(status) || !hdd_present) {\r\npr_info("HDD protection not available or using SSD\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int toshiba_haps_add(struct acpi_device *acpi_dev)\r\n{\r\nstruct toshiba_haps_dev *haps;\r\nint ret;\r\nif (toshiba_haps)\r\nreturn -EBUSY;\r\nif (!toshiba_haps_available(acpi_dev->handle))\r\nreturn -ENODEV;\r\npr_info("Toshiba HDD Active Protection Sensor device\n");\r\nhaps = kzalloc(sizeof(struct toshiba_haps_dev), GFP_KERNEL);\r\nif (!haps)\r\nreturn -ENOMEM;\r\nhaps->acpi_dev = acpi_dev;\r\nhaps->protection_level = 2;\r\nacpi_dev->driver_data = haps;\r\ndev_set_drvdata(&acpi_dev->dev, haps);\r\nret = toshiba_haps_protection_level(acpi_dev->handle, 2);\r\nif (ret != 0)\r\nreturn ret;\r\nret = sysfs_create_group(&acpi_dev->dev.kobj, &haps_attr_group);\r\nif (ret)\r\nreturn ret;\r\ntoshiba_haps = haps;\r\nreturn 0;\r\n}\r\nstatic int toshiba_haps_suspend(struct device *device)\r\n{\r\nstruct toshiba_haps_dev *haps;\r\nint ret;\r\nhaps = acpi_driver_data(to_acpi_device(device));\r\nret = toshiba_haps_protection_level(haps->acpi_dev->handle, 0);\r\nreturn ret;\r\n}\r\nstatic int toshiba_haps_resume(struct device *device)\r\n{\r\nstruct toshiba_haps_dev *haps;\r\nint ret;\r\nhaps = acpi_driver_data(to_acpi_device(device));\r\nret = toshiba_haps_protection_level(haps->acpi_dev->handle,\r\nhaps->protection_level);\r\nret = toshiba_haps_reset_protection(haps->acpi_dev->handle);\r\nif (ret != 0)\r\nreturn ret;\r\nreturn ret;\r\n}
