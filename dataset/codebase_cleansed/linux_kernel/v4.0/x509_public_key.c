static int __init ca_keys_setup(char *str)\r\n{\r\nif (!str)\r\nreturn 1;\r\nif (strncmp(str, "id:", 3) == 0) {\r\nstruct asymmetric_key_id *p;\r\np = asymmetric_key_hex_to_key_id(str + 3);\r\nif (p == ERR_PTR(-EINVAL))\r\npr_err("Unparsable hex string in ca_keys\n");\r\nelse if (!IS_ERR(p))\r\nca_keyid = p;\r\n} else if (strcmp(str, "builtin") == 0) {\r\nuse_builtin_keys = true;\r\n}\r\nreturn 1;\r\n}\r\nstruct key *x509_request_asymmetric_key(struct key *keyring,\r\nconst struct asymmetric_key_id *kid,\r\nbool partial)\r\n{\r\nkey_ref_t key;\r\nchar *id, *p;\r\np = id = kmalloc(2 + 1 + kid->len * 2 + 1, GFP_KERNEL);\r\nif (!id)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (partial) {\r\n*p++ = 'i';\r\n*p++ = 'd';\r\n} else {\r\n*p++ = 'e';\r\n*p++ = 'x';\r\n}\r\n*p++ = ':';\r\np = bin2hex(p, kid->data, kid->len);\r\n*p = 0;\r\npr_debug("Look up: \"%s\"\n", id);\r\nkey = keyring_search(make_key_ref(keyring, 1),\r\n&key_type_asymmetric, id);\r\nif (IS_ERR(key))\r\npr_debug("Request for key '%s' err %ld\n", id, PTR_ERR(key));\r\nkfree(id);\r\nif (IS_ERR(key)) {\r\nswitch (PTR_ERR(key)) {\r\ncase -EACCES:\r\ncase -ENOTDIR:\r\ncase -EAGAIN:\r\nreturn ERR_PTR(-ENOKEY);\r\ndefault:\r\nreturn ERR_CAST(key);\r\n}\r\n}\r\npr_devel("<==%s() = 0 [%x]\n", __func__,\r\nkey_serial(key_ref_to_ptr(key)));\r\nreturn key_ref_to_ptr(key);\r\n}\r\nint x509_get_sig_params(struct x509_certificate *cert)\r\n{\r\nstruct crypto_shash *tfm;\r\nstruct shash_desc *desc;\r\nsize_t digest_size, desc_size;\r\nvoid *digest;\r\nint ret;\r\npr_devel("==>%s()\n", __func__);\r\nif (cert->unsupported_crypto)\r\nreturn -ENOPKG;\r\nif (cert->sig.rsa.s)\r\nreturn 0;\r\ncert->sig.rsa.s = mpi_read_raw_data(cert->raw_sig, cert->raw_sig_size);\r\nif (!cert->sig.rsa.s)\r\nreturn -ENOMEM;\r\ncert->sig.nr_mpi = 1;\r\ntfm = crypto_alloc_shash(hash_algo_name[cert->sig.pkey_hash_algo], 0, 0);\r\nif (IS_ERR(tfm)) {\r\nif (PTR_ERR(tfm) == -ENOENT) {\r\ncert->unsupported_crypto = true;\r\nreturn -ENOPKG;\r\n}\r\nreturn PTR_ERR(tfm);\r\n}\r\ndesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\r\ndigest_size = crypto_shash_digestsize(tfm);\r\nret = -ENOMEM;\r\ndigest = kzalloc(digest_size + desc_size, GFP_KERNEL);\r\nif (!digest)\r\ngoto error;\r\ncert->sig.digest = digest;\r\ncert->sig.digest_size = digest_size;\r\ndesc = digest + digest_size;\r\ndesc->tfm = tfm;\r\ndesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nret = crypto_shash_init(desc);\r\nif (ret < 0)\r\ngoto error;\r\nmight_sleep();\r\nret = crypto_shash_finup(desc, cert->tbs, cert->tbs_size, digest);\r\nerror:\r\ncrypto_free_shash(tfm);\r\npr_devel("<==%s() = %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint x509_check_signature(const struct public_key *pub,\r\nstruct x509_certificate *cert)\r\n{\r\nint ret;\r\npr_devel("==>%s()\n", __func__);\r\nret = x509_get_sig_params(cert);\r\nif (ret < 0)\r\nreturn ret;\r\nret = public_key_verify_signature(pub, &cert->sig);\r\nif (ret == -ENOPKG)\r\ncert->unsupported_crypto = true;\r\npr_debug("Cert Verification: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int x509_validate_trust(struct x509_certificate *cert,\r\nstruct key *trust_keyring)\r\n{\r\nstruct key *key;\r\nint ret = 1;\r\nif (!trust_keyring)\r\nreturn -EOPNOTSUPP;\r\nif (ca_keyid && !asymmetric_key_id_partial(cert->authority, ca_keyid))\r\nreturn -EPERM;\r\nkey = x509_request_asymmetric_key(trust_keyring, cert->authority,\r\nfalse);\r\nif (!IS_ERR(key)) {\r\nif (!use_builtin_keys\r\n|| test_bit(KEY_FLAG_BUILTIN, &key->flags))\r\nret = x509_check_signature(key->payload.data, cert);\r\nkey_put(key);\r\n}\r\nreturn ret;\r\n}\r\nstatic int x509_key_preparse(struct key_preparsed_payload *prep)\r\n{\r\nstruct asymmetric_key_ids *kids;\r\nstruct x509_certificate *cert;\r\nconst char *q;\r\nsize_t srlen, sulen;\r\nchar *desc = NULL, *p;\r\nint ret;\r\ncert = x509_cert_parse(prep->data, prep->datalen);\r\nif (IS_ERR(cert))\r\nreturn PTR_ERR(cert);\r\npr_devel("Cert Issuer: %s\n", cert->issuer);\r\npr_devel("Cert Subject: %s\n", cert->subject);\r\nif (cert->pub->pkey_algo >= PKEY_ALGO__LAST ||\r\ncert->sig.pkey_algo >= PKEY_ALGO__LAST ||\r\ncert->sig.pkey_hash_algo >= PKEY_HASH__LAST ||\r\n!pkey_algo[cert->pub->pkey_algo] ||\r\n!pkey_algo[cert->sig.pkey_algo] ||\r\n!hash_algo_name[cert->sig.pkey_hash_algo]) {\r\nret = -ENOPKG;\r\ngoto error_free_cert;\r\n}\r\npr_devel("Cert Key Algo: %s\n", pkey_algo_name[cert->pub->pkey_algo]);\r\npr_devel("Cert Valid From: %04ld-%02d-%02d %02d:%02d:%02d\n",\r\ncert->valid_from.tm_year + 1900, cert->valid_from.tm_mon + 1,\r\ncert->valid_from.tm_mday, cert->valid_from.tm_hour,\r\ncert->valid_from.tm_min, cert->valid_from.tm_sec);\r\npr_devel("Cert Valid To: %04ld-%02d-%02d %02d:%02d:%02d\n",\r\ncert->valid_to.tm_year + 1900, cert->valid_to.tm_mon + 1,\r\ncert->valid_to.tm_mday, cert->valid_to.tm_hour,\r\ncert->valid_to.tm_min, cert->valid_to.tm_sec);\r\npr_devel("Cert Signature: %s + %s\n",\r\npkey_algo_name[cert->sig.pkey_algo],\r\nhash_algo_name[cert->sig.pkey_hash_algo]);\r\ncert->pub->algo = pkey_algo[cert->pub->pkey_algo];\r\ncert->pub->id_type = PKEY_ID_X509;\r\nif (!cert->authority ||\r\nasymmetric_key_id_same(cert->skid, cert->authority)) {\r\nret = x509_check_signature(cert->pub, cert);\r\nif (ret < 0)\r\ngoto error_free_cert;\r\n} else if (!prep->trusted) {\r\nret = x509_validate_trust(cert, get_system_trusted_keyring());\r\nif (!ret)\r\nprep->trusted = 1;\r\n}\r\nsulen = strlen(cert->subject);\r\nif (cert->raw_skid) {\r\nsrlen = cert->raw_skid_size;\r\nq = cert->raw_skid;\r\n} else {\r\nsrlen = cert->raw_serial_size;\r\nq = cert->raw_serial;\r\n}\r\nif (srlen > 1 && *q == 0) {\r\nsrlen--;\r\nq++;\r\n}\r\nret = -ENOMEM;\r\ndesc = kmalloc(sulen + 2 + srlen * 2 + 1, GFP_KERNEL);\r\nif (!desc)\r\ngoto error_free_cert;\r\np = memcpy(desc, cert->subject, sulen);\r\np += sulen;\r\n*p++ = ':';\r\n*p++ = ' ';\r\np = bin2hex(p, q, srlen);\r\n*p = 0;\r\nkids = kmalloc(sizeof(struct asymmetric_key_ids), GFP_KERNEL);\r\nif (!kids)\r\ngoto error_free_desc;\r\nkids->id[0] = cert->id;\r\nkids->id[1] = cert->skid;\r\n__module_get(public_key_subtype.owner);\r\nprep->type_data[0] = &public_key_subtype;\r\nprep->type_data[1] = kids;\r\nprep->payload[0] = cert->pub;\r\nprep->description = desc;\r\nprep->quotalen = 100;\r\ncert->pub = NULL;\r\ncert->id = NULL;\r\ncert->skid = NULL;\r\ndesc = NULL;\r\nret = 0;\r\nerror_free_desc:\r\nkfree(desc);\r\nerror_free_cert:\r\nx509_free_certificate(cert);\r\nreturn ret;\r\n}\r\nstatic int __init x509_key_init(void)\r\n{\r\nreturn register_asymmetric_key_parser(&x509_key_parser);\r\n}\r\nstatic void __exit x509_key_exit(void)\r\n{\r\nunregister_asymmetric_key_parser(&x509_key_parser);\r\n}
