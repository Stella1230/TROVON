static int exynos_power_up(unsigned int cpu, unsigned int cluster)\r\n{\r\nunsigned int cpunr = cpu + (cluster * EXYNOS5420_CPUS_PER_CLUSTER);\r\npr_debug("%s: cpu %u cluster %u\n", __func__, cpu, cluster);\r\nif (cpu >= EXYNOS5420_CPUS_PER_CLUSTER ||\r\ncluster >= EXYNOS5420_NR_CLUSTERS)\r\nreturn -EINVAL;\r\nlocal_irq_disable();\r\narch_spin_lock(&exynos_mcpm_lock);\r\ncpu_use_count[cpu][cluster]++;\r\nif (cpu_use_count[cpu][cluster] == 1) {\r\nbool was_cluster_down =\r\n(exynos_cluster_usecnt(cluster) == 1);\r\nif (was_cluster_down)\r\nexynos_cluster_power_up(cluster);\r\nexynos_cpu_power_up(cpunr);\r\n} else if (cpu_use_count[cpu][cluster] != 2) {\r\nBUG();\r\n}\r\narch_spin_unlock(&exynos_mcpm_lock);\r\nlocal_irq_enable();\r\nreturn 0;\r\n}\r\nstatic void exynos_power_down(void)\r\n{\r\nunsigned int mpidr, cpu, cluster;\r\nbool last_man = false, skip_wfi = false;\r\nunsigned int cpunr;\r\nmpidr = read_cpuid_mpidr();\r\ncpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);\r\ncluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);\r\ncpunr = cpu + (cluster * EXYNOS5420_CPUS_PER_CLUSTER);\r\npr_debug("%s: cpu %u cluster %u\n", __func__, cpu, cluster);\r\nBUG_ON(cpu >= EXYNOS5420_CPUS_PER_CLUSTER ||\r\ncluster >= EXYNOS5420_NR_CLUSTERS);\r\n__mcpm_cpu_going_down(cpu, cluster);\r\narch_spin_lock(&exynos_mcpm_lock);\r\nBUG_ON(__mcpm_cluster_state(cluster) != CLUSTER_UP);\r\ncpu_use_count[cpu][cluster]--;\r\nif (cpu_use_count[cpu][cluster] == 0) {\r\nexynos_cpu_power_down(cpunr);\r\nif (exynos_cluster_unused(cluster)) {\r\nexynos_cluster_power_down(cluster);\r\nlast_man = true;\r\n}\r\n} else if (cpu_use_count[cpu][cluster] == 1) {\r\nskip_wfi = true;\r\n} else {\r\nBUG();\r\n}\r\nif (last_man && __mcpm_outbound_enter_critical(cpu, cluster)) {\r\narch_spin_unlock(&exynos_mcpm_lock);\r\nif (read_cpuid_part() == ARM_CPU_PART_CORTEX_A15) {\r\nasm volatile(\r\n"mcr p15, 1, %0, c15, c0, 3\n\t"\r\n"isb\n\t"\r\n"dsb"\r\n: : "r" (0x400));\r\n}\r\nexynos_v7_exit_coherency_flush(all);\r\ncci_disable_port_by_cpu(mpidr);\r\n__mcpm_outbound_leave_critical(cluster, CLUSTER_DOWN);\r\n} else {\r\narch_spin_unlock(&exynos_mcpm_lock);\r\nexynos_v7_exit_coherency_flush(louis);\r\n}\r\n__mcpm_cpu_down(cpu, cluster);\r\nif (!skip_wfi)\r\nwfi();\r\n}\r\nstatic int exynos_wait_for_powerdown(unsigned int cpu, unsigned int cluster)\r\n{\r\nunsigned int tries = 100;\r\nunsigned int cpunr = cpu + (cluster * EXYNOS5420_CPUS_PER_CLUSTER);\r\npr_debug("%s: cpu %u cluster %u\n", __func__, cpu, cluster);\r\nBUG_ON(cpu >= EXYNOS5420_CPUS_PER_CLUSTER ||\r\ncluster >= EXYNOS5420_NR_CLUSTERS);\r\nwhile (tries--) {\r\nif (ACCESS_ONCE(cpu_use_count[cpu][cluster]) == 0) {\r\nif ((exynos_cpu_power_state(cpunr) == 0))\r\nreturn 0;\r\n}\r\nmsleep(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void exynos_powered_up(void)\r\n{\r\nunsigned int mpidr, cpu, cluster;\r\nmpidr = read_cpuid_mpidr();\r\ncpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);\r\ncluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);\r\narch_spin_lock(&exynos_mcpm_lock);\r\nif (cpu_use_count[cpu][cluster] == 0)\r\ncpu_use_count[cpu][cluster] = 1;\r\narch_spin_unlock(&exynos_mcpm_lock);\r\n}\r\nstatic void exynos_suspend(u64 residency)\r\n{\r\nunsigned int mpidr, cpunr;\r\nexynos_power_down();\r\nmpidr = read_cpuid_mpidr();\r\ncpunr = exynos_pmu_cpunr(mpidr);\r\nexynos_cpu_power_up(cpunr);\r\n}\r\nstatic void __init exynos_mcpm_usage_count_init(void)\r\n{\r\nunsigned int mpidr, cpu, cluster;\r\nmpidr = read_cpuid_mpidr();\r\ncpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);\r\ncluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);\r\npr_debug("%s: cpu %u cluster %u\n", __func__, cpu, cluster);\r\nBUG_ON(cpu >= EXYNOS5420_CPUS_PER_CLUSTER ||\r\ncluster >= EXYNOS5420_NR_CLUSTERS);\r\ncpu_use_count[cpu][cluster] = 1;\r\n}\r\nstatic void __naked exynos_pm_power_up_setup(unsigned int affinity_level)\r\n{\r\nasm volatile ("\n"\r\n"cmp r0, #1\n"\r\n"bxne lr\n"\r\n"b cci_enable_port_for_self");\r\n}\r\nstatic void __init exynos_cache_off(void)\r\n{\r\nif (read_cpuid_part() == ARM_CPU_PART_CORTEX_A15) {\r\nasm volatile(\r\n"mcr p15, 1, %0, c15, c0, 3\n\t"\r\n"isb\n\t"\r\n"dsb"\r\n: : "r" (0x400));\r\n}\r\nexynos_v7_exit_coherency_flush(all);\r\n}\r\nstatic void exynos_mcpm_setup_entry_point(void)\r\n{\r\n__raw_writel(0xe59f0000, ns_sram_base_addr);\r\n__raw_writel(0xe12fff10, ns_sram_base_addr + 4);\r\n__raw_writel(virt_to_phys(mcpm_entry_point), ns_sram_base_addr + 8);\r\n}\r\nstatic int __init exynos_mcpm_init(void)\r\n{\r\nstruct device_node *node;\r\nunsigned int value, i;\r\nint ret;\r\nnode = of_find_matching_node(NULL, exynos_dt_mcpm_match);\r\nif (!node)\r\nreturn -ENODEV;\r\nof_node_put(node);\r\nif (!cci_probed())\r\nreturn -ENODEV;\r\nnode = of_find_compatible_node(NULL, NULL,\r\n"samsung,exynos4210-sysram-ns");\r\nif (!node)\r\nreturn -ENODEV;\r\nns_sram_base_addr = of_iomap(node, 0);\r\nof_node_put(node);\r\nif (!ns_sram_base_addr) {\r\npr_err("failed to map non-secure iRAM base address\n");\r\nreturn -ENOMEM;\r\n}\r\npmu_raw_writel(EXYNOS5420_SWRESET_KFC_SEL, S5P_PMU_SPARE3);\r\nexynos_mcpm_usage_count_init();\r\nret = mcpm_platform_register(&exynos_power_ops);\r\nif (!ret)\r\nret = mcpm_sync_init(exynos_pm_power_up_setup);\r\nif (!ret)\r\nret = mcpm_loopback(exynos_cache_off);\r\nif (ret) {\r\niounmap(ns_sram_base_addr);\r\nreturn ret;\r\n}\r\nmcpm_smp_set_ops();\r\npr_info("Exynos MCPM support installed\n");\r\nfor (i = 0; i < EXYNOS5420_NR_CLUSTERS; i++) {\r\nvalue = pmu_raw_readl(EXYNOS_COMMON_OPTION(i));\r\nvalue |= EXYNOS5420_ENABLE_AUTOMATIC_CORE_DOWN |\r\nEXYNOS5420_USE_ARM_CORE_DOWN_STATE |\r\nEXYNOS5420_USE_L2_COMMON_UP_STATE;\r\npmu_raw_writel(value, EXYNOS_COMMON_OPTION(i));\r\n}\r\nexynos_mcpm_setup_entry_point();\r\nregister_syscore_ops(&exynos_mcpm_syscore_ops);\r\nreturn ret;\r\n}
