static void wf_smu_create_cpu_fans(void)\r\n{\r\nstruct wf_cpu_pid_param pid_param;\r\nconst struct smu_sdbp_header *hdr;\r\nstruct smu_sdbp_cpupiddata *piddata;\r\nstruct smu_sdbp_fvt *fvt;\r\ns32 tmax, tdelta, maxpow, powadj;\r\nhdr = smu_get_sdb_partition(SMU_SDB_CPUPIDDATA_ID, NULL);\r\nif (hdr == 0) {\r\nprintk(KERN_WARNING "windfarm: CPU PID fan config not found "\r\n"max fan speed\n");\r\ngoto fail;\r\n}\r\npiddata = (struct smu_sdbp_cpupiddata *)&hdr[1];\r\nhdr = smu_get_sdb_partition(SMU_SDB_FVT_ID, NULL);\r\nif (hdr) {\r\nfvt = (struct smu_sdbp_fvt *)&hdr[1];\r\ntmax = ((s32)fvt->maxtemp) << 16;\r\n} else\r\ntmax = 0x5e0000;\r\nwf_smu_cpu_fans = kmalloc(sizeof(struct wf_smu_cpu_fans_state),\r\nGFP_KERNEL);\r\nif (wf_smu_cpu_fans == NULL)\r\ngoto fail;\r\nwf_smu_cpu_fans->ticks = 1;\r\npid_param.interval = WF_SMU_CPU_FANS_INTERVAL;\r\npid_param.history_len = piddata->history_len;\r\nif (pid_param.history_len > WF_CPU_PID_MAX_HISTORY) {\r\nprintk(KERN_WARNING "windfarm: History size overflow on "\r\n"CPU control loop (%d)\n", piddata->history_len);\r\npid_param.history_len = WF_CPU_PID_MAX_HISTORY;\r\n}\r\npid_param.gd = piddata->gd;\r\npid_param.gp = piddata->gp;\r\npid_param.gr = piddata->gr / pid_param.history_len;\r\ntdelta = ((s32)piddata->target_temp_delta) << 16;\r\nmaxpow = ((s32)piddata->max_power) << 16;\r\npowadj = ((s32)piddata->power_adj) << 16;\r\npid_param.tmax = tmax;\r\npid_param.ttarget = tmax - tdelta;\r\npid_param.pmaxadj = maxpow - powadj;\r\npid_param.min = wf_control_get_min(fan_cpu_main);\r\npid_param.max = wf_control_get_max(fan_cpu_main);\r\nwf_cpu_pid_init(&wf_smu_cpu_fans->pid, &pid_param);\r\nDBG("wf: CPU Fan control initialized.\n");\r\nDBG(" ttarged=%d.%03d, tmax=%d.%03d, min=%d RPM, max=%d RPM\n",\r\nFIX32TOPRINT(pid_param.ttarget), FIX32TOPRINT(pid_param.tmax),\r\npid_param.min, pid_param.max);\r\nreturn;\r\nfail:\r\nprintk(KERN_WARNING "windfarm: CPU fan config not found\n"\r\n"for this machine model, max fan speed\n");\r\nif (cpufreq_clamp)\r\nwf_control_set_max(cpufreq_clamp);\r\nif (fan_cpu_main)\r\nwf_control_set_max(fan_cpu_main);\r\n}\r\nstatic void wf_smu_cpu_fans_tick(struct wf_smu_cpu_fans_state *st)\r\n{\r\ns32 new_setpoint, temp, power;\r\nint rc;\r\nif (--st->ticks != 0) {\r\nif (wf_smu_readjust)\r\ngoto readjust;\r\nreturn;\r\n}\r\nst->ticks = WF_SMU_CPU_FANS_INTERVAL;\r\nrc = wf_sensor_get(sensor_cpu_temp, &temp);\r\nif (rc) {\r\nprintk(KERN_WARNING "windfarm: CPU temp sensor error %d\n",\r\nrc);\r\nwf_smu_failure_state |= FAILURE_SENSOR;\r\nreturn;\r\n}\r\nrc = wf_sensor_get(sensor_cpu_power, &power);\r\nif (rc) {\r\nprintk(KERN_WARNING "windfarm: CPU power sensor error %d\n",\r\nrc);\r\nwf_smu_failure_state |= FAILURE_SENSOR;\r\nreturn;\r\n}\r\nDBG("wf_smu: CPU Fans tick ! CPU temp: %d.%03d, power: %d.%03d\n",\r\nFIX32TOPRINT(temp), FIX32TOPRINT(power));\r\n#ifdef HACKED_OVERTEMP\r\nif (temp > 0x4a0000)\r\nwf_smu_failure_state |= FAILURE_OVERTEMP;\r\n#else\r\nif (temp > st->pid.param.tmax)\r\nwf_smu_failure_state |= FAILURE_OVERTEMP;\r\n#endif\r\nnew_setpoint = wf_cpu_pid_run(&st->pid, power, temp);\r\nDBG("wf_smu: new_setpoint: %d RPM\n", (int)new_setpoint);\r\nif (st->cpu_setpoint == new_setpoint)\r\nreturn;\r\nst->cpu_setpoint = new_setpoint;\r\nreadjust:\r\nif (fan_cpu_main && wf_smu_failure_state == 0) {\r\nrc = wf_control_set(fan_cpu_main, st->cpu_setpoint);\r\nif (rc) {\r\nprintk(KERN_WARNING "windfarm: CPU main fan"\r\n" error %d\n", rc);\r\nwf_smu_failure_state |= FAILURE_FAN;\r\n}\r\n}\r\nif (fan_cpu_second && wf_smu_failure_state == 0) {\r\nrc = wf_control_set(fan_cpu_second, st->cpu_setpoint);\r\nif (rc) {\r\nprintk(KERN_WARNING "windfarm: CPU second fan"\r\n" error %d\n", rc);\r\nwf_smu_failure_state |= FAILURE_FAN;\r\n}\r\n}\r\nif (fan_cpu_third && wf_smu_failure_state == 0) {\r\nrc = wf_control_set(fan_cpu_third, st->cpu_setpoint);\r\nif (rc) {\r\nprintk(KERN_WARNING "windfarm: CPU third fan"\r\n" error %d\n", rc);\r\nwf_smu_failure_state |= FAILURE_FAN;\r\n}\r\n}\r\n}\r\nstatic void wf_smu_create_drive_fans(void)\r\n{\r\nstruct wf_pid_param param = {\r\n.interval = 5,\r\n.history_len = 2,\r\n.gd = 0x01e00000,\r\n.gp = 0x00500000,\r\n.gr = 0x00000000,\r\n.itarget = 0x00200000,\r\n};\r\nwf_smu_drive_fans = kmalloc(sizeof(struct wf_smu_drive_fans_state),\r\nGFP_KERNEL);\r\nif (wf_smu_drive_fans == NULL) {\r\nprintk(KERN_WARNING "windfarm: Memory allocation error"\r\n" max fan speed\n");\r\ngoto fail;\r\n}\r\nwf_smu_drive_fans->ticks = 1;\r\nparam.additive = (fan_hd->type == WF_CONTROL_RPM_FAN);\r\nparam.min = wf_control_get_min(fan_hd);\r\nparam.max = wf_control_get_max(fan_hd);\r\nwf_pid_init(&wf_smu_drive_fans->pid, &param);\r\nDBG("wf: Drive Fan control initialized.\n");\r\nDBG(" itarged=%d.%03d, min=%d RPM, max=%d RPM\n",\r\nFIX32TOPRINT(param.itarget), param.min, param.max);\r\nreturn;\r\nfail:\r\nif (fan_hd)\r\nwf_control_set_max(fan_hd);\r\n}\r\nstatic void wf_smu_drive_fans_tick(struct wf_smu_drive_fans_state *st)\r\n{\r\ns32 new_setpoint, temp;\r\nint rc;\r\nif (--st->ticks != 0) {\r\nif (wf_smu_readjust)\r\ngoto readjust;\r\nreturn;\r\n}\r\nst->ticks = st->pid.param.interval;\r\nrc = wf_sensor_get(sensor_hd_temp, &temp);\r\nif (rc) {\r\nprintk(KERN_WARNING "windfarm: HD temp sensor error %d\n",\r\nrc);\r\nwf_smu_failure_state |= FAILURE_SENSOR;\r\nreturn;\r\n}\r\nDBG("wf_smu: Drive Fans tick ! HD temp: %d.%03d\n",\r\nFIX32TOPRINT(temp));\r\nif (temp > (st->pid.param.itarget + 0x50000))\r\nwf_smu_failure_state |= FAILURE_OVERTEMP;\r\nnew_setpoint = wf_pid_run(&st->pid, temp);\r\nDBG("wf_smu: new_setpoint: %d\n", (int)new_setpoint);\r\nif (st->setpoint == new_setpoint)\r\nreturn;\r\nst->setpoint = new_setpoint;\r\nreadjust:\r\nif (fan_hd && wf_smu_failure_state == 0) {\r\nrc = wf_control_set(fan_hd, st->setpoint);\r\nif (rc) {\r\nprintk(KERN_WARNING "windfarm: HD fan error %d\n",\r\nrc);\r\nwf_smu_failure_state |= FAILURE_FAN;\r\n}\r\n}\r\n}\r\nstatic void wf_smu_create_slots_fans(void)\r\n{\r\nstruct wf_pid_param param = {\r\n.interval = 1,\r\n.history_len = 8,\r\n.gd = 0x00000000,\r\n.gp = 0x00000000,\r\n.gr = 0x00020000,\r\n.itarget = 0x00000000\r\n};\r\nwf_smu_slots_fans = kmalloc(sizeof(struct wf_smu_slots_fans_state),\r\nGFP_KERNEL);\r\nif (wf_smu_slots_fans == NULL) {\r\nprintk(KERN_WARNING "windfarm: Memory allocation error"\r\n" max fan speed\n");\r\ngoto fail;\r\n}\r\nwf_smu_slots_fans->ticks = 1;\r\nparam.additive = (fan_slots->type == WF_CONTROL_RPM_FAN);\r\nparam.min = wf_control_get_min(fan_slots);\r\nparam.max = wf_control_get_max(fan_slots);\r\nwf_pid_init(&wf_smu_slots_fans->pid, &param);\r\nDBG("wf: Slots Fan control initialized.\n");\r\nDBG(" itarged=%d.%03d, min=%d RPM, max=%d RPM\n",\r\nFIX32TOPRINT(param.itarget), param.min, param.max);\r\nreturn;\r\nfail:\r\nif (fan_slots)\r\nwf_control_set_max(fan_slots);\r\n}\r\nstatic void wf_smu_slots_fans_tick(struct wf_smu_slots_fans_state *st)\r\n{\r\ns32 new_setpoint, power;\r\nint rc;\r\nif (--st->ticks != 0) {\r\nif (wf_smu_readjust)\r\ngoto readjust;\r\nreturn;\r\n}\r\nst->ticks = st->pid.param.interval;\r\nrc = wf_sensor_get(sensor_slots_power, &power);\r\nif (rc) {\r\nprintk(KERN_WARNING "windfarm: Slots power sensor error %d\n",\r\nrc);\r\nwf_smu_failure_state |= FAILURE_SENSOR;\r\nreturn;\r\n}\r\nDBG("wf_smu: Slots Fans tick ! Slots power: %d.%03d\n",\r\nFIX32TOPRINT(power));\r\n#if 0\r\nif (power > (st->pid.param.itarget + 0x50000))\r\nwf_smu_failure_state |= FAILURE_OVERTEMP;\r\n#endif\r\nnew_setpoint = wf_pid_run(&st->pid, power);\r\nDBG("wf_smu: new_setpoint: %d\n", (int)new_setpoint);\r\nif (st->setpoint == new_setpoint)\r\nreturn;\r\nst->setpoint = new_setpoint;\r\nreadjust:\r\nif (fan_slots && wf_smu_failure_state == 0) {\r\nrc = wf_control_set(fan_slots, st->setpoint);\r\nif (rc) {\r\nprintk(KERN_WARNING "windfarm: Slots fan error %d\n",\r\nrc);\r\nwf_smu_failure_state |= FAILURE_FAN;\r\n}\r\n}\r\n}\r\nstatic void wf_smu_tick(void)\r\n{\r\nunsigned int last_failure = wf_smu_failure_state;\r\nunsigned int new_failure;\r\nif (!wf_smu_started) {\r\nDBG("wf: creating control loops !\n");\r\nwf_smu_create_drive_fans();\r\nwf_smu_create_slots_fans();\r\nwf_smu_create_cpu_fans();\r\nwf_smu_started = 1;\r\n}\r\nif (wf_smu_skipping && --wf_smu_skipping)\r\nreturn;\r\nwf_smu_failure_state = 0;\r\nif (wf_smu_drive_fans)\r\nwf_smu_drive_fans_tick(wf_smu_drive_fans);\r\nif (wf_smu_slots_fans)\r\nwf_smu_slots_fans_tick(wf_smu_slots_fans);\r\nif (wf_smu_cpu_fans)\r\nwf_smu_cpu_fans_tick(wf_smu_cpu_fans);\r\nwf_smu_readjust = 0;\r\nnew_failure = wf_smu_failure_state & ~last_failure;\r\nif (wf_smu_failure_state && !last_failure) {\r\nif (cpufreq_clamp)\r\nwf_control_set_max(cpufreq_clamp);\r\nif (fan_cpu_main)\r\nwf_control_set_max(fan_cpu_main);\r\nif (fan_cpu_second)\r\nwf_control_set_max(fan_cpu_second);\r\nif (fan_cpu_third)\r\nwf_control_set_max(fan_cpu_third);\r\nif (fan_hd)\r\nwf_control_set_max(fan_hd);\r\nif (fan_slots)\r\nwf_control_set_max(fan_slots);\r\n}\r\nif (!wf_smu_failure_state && last_failure) {\r\nif (cpufreq_clamp)\r\nwf_control_set_min(cpufreq_clamp);\r\nwf_smu_readjust = 1;\r\n}\r\nif (new_failure & FAILURE_OVERTEMP) {\r\nwf_set_overtemp();\r\nwf_smu_skipping = 2;\r\nwf_smu_overtemp = true;\r\n}\r\nif (!wf_smu_failure_state && wf_smu_overtemp) {\r\nwf_clear_overtemp();\r\nwf_smu_overtemp = false;\r\n}\r\n}\r\nstatic void wf_smu_new_control(struct wf_control *ct)\r\n{\r\nif (wf_smu_all_controls_ok)\r\nreturn;\r\nif (fan_cpu_main == NULL && !strcmp(ct->name, "cpu-rear-fan-0")) {\r\nif (wf_get_control(ct) == 0)\r\nfan_cpu_main = ct;\r\n}\r\nif (fan_cpu_second == NULL && !strcmp(ct->name, "cpu-rear-fan-1")) {\r\nif (wf_get_control(ct) == 0)\r\nfan_cpu_second = ct;\r\n}\r\nif (fan_cpu_third == NULL && !strcmp(ct->name, "cpu-front-fan-0")) {\r\nif (wf_get_control(ct) == 0)\r\nfan_cpu_third = ct;\r\n}\r\nif (cpufreq_clamp == NULL && !strcmp(ct->name, "cpufreq-clamp")) {\r\nif (wf_get_control(ct) == 0)\r\ncpufreq_clamp = ct;\r\n}\r\nif (fan_hd == NULL && !strcmp(ct->name, "drive-bay-fan")) {\r\nif (wf_get_control(ct) == 0)\r\nfan_hd = ct;\r\n}\r\nif (fan_slots == NULL && !strcmp(ct->name, "slots-fan")) {\r\nif (wf_get_control(ct) == 0)\r\nfan_slots = ct;\r\n}\r\nif (fan_cpu_main && (fan_cpu_second || fan_cpu_third) && fan_hd &&\r\nfan_slots && cpufreq_clamp)\r\nwf_smu_all_controls_ok = 1;\r\n}\r\nstatic void wf_smu_new_sensor(struct wf_sensor *sr)\r\n{\r\nif (wf_smu_all_sensors_ok)\r\nreturn;\r\nif (sensor_cpu_power == NULL && !strcmp(sr->name, "cpu-power")) {\r\nif (wf_get_sensor(sr) == 0)\r\nsensor_cpu_power = sr;\r\n}\r\nif (sensor_cpu_temp == NULL && !strcmp(sr->name, "cpu-temp")) {\r\nif (wf_get_sensor(sr) == 0)\r\nsensor_cpu_temp = sr;\r\n}\r\nif (sensor_hd_temp == NULL && !strcmp(sr->name, "hd-temp")) {\r\nif (wf_get_sensor(sr) == 0)\r\nsensor_hd_temp = sr;\r\n}\r\nif (sensor_slots_power == NULL && !strcmp(sr->name, "slots-power")) {\r\nif (wf_get_sensor(sr) == 0)\r\nsensor_slots_power = sr;\r\n}\r\nif (sensor_cpu_power && sensor_cpu_temp &&\r\nsensor_hd_temp && sensor_slots_power)\r\nwf_smu_all_sensors_ok = 1;\r\n}\r\nstatic int wf_smu_notify(struct notifier_block *self,\r\nunsigned long event, void *data)\r\n{\r\nswitch(event) {\r\ncase WF_EVENT_NEW_CONTROL:\r\nDBG("wf: new control %s detected\n",\r\n((struct wf_control *)data)->name);\r\nwf_smu_new_control(data);\r\nwf_smu_readjust = 1;\r\nbreak;\r\ncase WF_EVENT_NEW_SENSOR:\r\nDBG("wf: new sensor %s detected\n",\r\n((struct wf_sensor *)data)->name);\r\nwf_smu_new_sensor(data);\r\nbreak;\r\ncase WF_EVENT_TICK:\r\nif (wf_smu_all_controls_ok && wf_smu_all_sensors_ok)\r\nwf_smu_tick();\r\n}\r\nreturn 0;\r\n}\r\nstatic int wf_init_pm(void)\r\n{\r\nprintk(KERN_INFO "windfarm: Initializing for Desktop G5 model\n");\r\nreturn 0;\r\n}\r\nstatic int wf_smu_probe(struct platform_device *ddev)\r\n{\r\nwf_register_client(&wf_smu_events);\r\nreturn 0;\r\n}\r\nstatic int wf_smu_remove(struct platform_device *ddev)\r\n{\r\nwf_unregister_client(&wf_smu_events);\r\nmsleep(1000);\r\nif (sensor_cpu_power)\r\nwf_put_sensor(sensor_cpu_power);\r\nif (sensor_cpu_temp)\r\nwf_put_sensor(sensor_cpu_temp);\r\nif (sensor_hd_temp)\r\nwf_put_sensor(sensor_hd_temp);\r\nif (sensor_slots_power)\r\nwf_put_sensor(sensor_slots_power);\r\nif (fan_cpu_main)\r\nwf_put_control(fan_cpu_main);\r\nif (fan_cpu_second)\r\nwf_put_control(fan_cpu_second);\r\nif (fan_cpu_third)\r\nwf_put_control(fan_cpu_third);\r\nif (fan_hd)\r\nwf_put_control(fan_hd);\r\nif (fan_slots)\r\nwf_put_control(fan_slots);\r\nif (cpufreq_clamp)\r\nwf_put_control(cpufreq_clamp);\r\nkfree(wf_smu_slots_fans);\r\nkfree(wf_smu_drive_fans);\r\nkfree(wf_smu_cpu_fans);\r\nreturn 0;\r\n}\r\nstatic int __init wf_smu_init(void)\r\n{\r\nint rc = -ENODEV;\r\nif (of_machine_is_compatible("PowerMac9,1"))\r\nrc = wf_init_pm();\r\nif (rc == 0) {\r\n#ifdef MODULE\r\nrequest_module("windfarm_smu_controls");\r\nrequest_module("windfarm_smu_sensors");\r\nrequest_module("windfarm_lm75_sensor");\r\nrequest_module("windfarm_cpufreq_clamp");\r\n#endif\r\nplatform_driver_register(&wf_smu_driver);\r\n}\r\nreturn rc;\r\n}\r\nstatic void __exit wf_smu_exit(void)\r\n{\r\nplatform_driver_unregister(&wf_smu_driver);\r\n}
