static loff_t get_loop_size(struct lloop_device *lo, struct file *file)\r\n{\r\nloff_t size, offset, loopsize;\r\nsize = i_size_read(file->f_mapping->host);\r\noffset = lo->lo_offset;\r\nloopsize = size - offset;\r\nif (lo->lo_sizelimit > 0 && lo->lo_sizelimit < loopsize)\r\nloopsize = lo->lo_sizelimit;\r\nreturn loopsize >> 9;\r\n}\r\nstatic int do_bio_lustrebacked(struct lloop_device *lo, struct bio *head)\r\n{\r\nconst struct lu_env *env = lo->lo_env;\r\nstruct cl_io *io = &lo->lo_io;\r\nstruct inode *inode = file_inode(lo->lo_backing_file);\r\nstruct cl_object *obj = ll_i2info(inode)->lli_clob;\r\npgoff_t offset;\r\nint ret;\r\nint rw;\r\nu32 page_count = 0;\r\nstruct bio_vec bvec;\r\nstruct bvec_iter iter;\r\nstruct bio *bio;\r\nssize_t bytes;\r\nstruct ll_dio_pages *pvec = &lo->lo_pvec;\r\nstruct page **pages = pvec->ldp_pages;\r\nloff_t *offsets = pvec->ldp_offsets;\r\ntruncate_inode_pages(inode->i_mapping, 0);\r\nmemset(io, 0, sizeof(*io));\r\nio->ci_obj = obj;\r\nret = cl_io_init(env, io, CIT_MISC, obj);\r\nif (ret)\r\nreturn io->ci_result;\r\nio->ci_lockreq = CILR_NEVER;\r\nLASSERT(head != NULL);\r\nrw = head->bi_rw;\r\nfor (bio = head; bio != NULL; bio = bio->bi_next) {\r\nLASSERT(rw == bio->bi_rw);\r\noffset = (pgoff_t)(bio->bi_iter.bi_sector << 9) + lo->lo_offset;\r\nbio_for_each_segment(bvec, bio, iter) {\r\nBUG_ON(bvec.bv_offset != 0);\r\nBUG_ON(bvec.bv_len != PAGE_CACHE_SIZE);\r\npages[page_count] = bvec.bv_page;\r\noffsets[page_count] = offset;\r\npage_count++;\r\noffset += bvec.bv_len;\r\n}\r\nLASSERT(page_count <= LLOOP_MAX_SEGMENTS);\r\n}\r\nll_stats_ops_tally(ll_i2sbi(inode),\r\n(rw == WRITE) ? LPROC_LL_BRW_WRITE : LPROC_LL_BRW_READ,\r\npage_count);\r\npvec->ldp_size = page_count << PAGE_CACHE_SHIFT;\r\npvec->ldp_nr = page_count;\r\nmutex_lock(&inode->i_mutex);\r\nbytes = ll_direct_rw_pages(env, io, rw, inode, pvec);\r\nmutex_unlock(&inode->i_mutex);\r\ncl_io_fini(env, io);\r\nreturn (bytes == pvec->ldp_size) ? 0 : (int)bytes;\r\n}\r\nstatic void loop_add_bio(struct lloop_device *lo, struct bio *bio)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&lo->lo_lock, flags);\r\nif (lo->lo_biotail) {\r\nlo->lo_biotail->bi_next = bio;\r\nlo->lo_biotail = bio;\r\n} else\r\nlo->lo_bio = lo->lo_biotail = bio;\r\nspin_unlock_irqrestore(&lo->lo_lock, flags);\r\natomic_inc(&lo->lo_pending);\r\nif (waitqueue_active(&lo->lo_bh_wait))\r\nwake_up(&lo->lo_bh_wait);\r\n}\r\nstatic unsigned int loop_get_bio(struct lloop_device *lo, struct bio **req)\r\n{\r\nstruct bio *first;\r\nstruct bio **bio;\r\nunsigned int count = 0;\r\nunsigned int page_count = 0;\r\nint rw;\r\nspin_lock_irq(&lo->lo_lock);\r\nfirst = lo->lo_bio;\r\nif (unlikely(first == NULL)) {\r\nspin_unlock_irq(&lo->lo_lock);\r\nreturn 0;\r\n}\r\nLASSERT(first->bi_vcnt <= LLOOP_MAX_SEGMENTS);\r\nrw = first->bi_rw;\r\nbio = &lo->lo_bio;\r\nwhile (*bio && (*bio)->bi_rw == rw) {\r\nCDEBUG(D_INFO, "bio sector %llu size %u count %u vcnt%u \n",\r\n(unsigned long long)(*bio)->bi_iter.bi_sector,\r\n(*bio)->bi_iter.bi_size,\r\npage_count, (*bio)->bi_vcnt);\r\nif (page_count + (*bio)->bi_vcnt > LLOOP_MAX_SEGMENTS)\r\nbreak;\r\npage_count += (*bio)->bi_vcnt;\r\ncount++;\r\nbio = &(*bio)->bi_next;\r\n}\r\nif (*bio) {\r\nlo->lo_bio = *bio;\r\n*bio = NULL;\r\n} else {\r\nlo->lo_biotail = NULL;\r\nlo->lo_bio = NULL;\r\n}\r\n*req = first;\r\nspin_unlock_irq(&lo->lo_lock);\r\nreturn count;\r\n}\r\nstatic void loop_make_request(struct request_queue *q, struct bio *old_bio)\r\n{\r\nstruct lloop_device *lo = q->queuedata;\r\nint rw = bio_rw(old_bio);\r\nint inactive;\r\nif (!lo)\r\ngoto err;\r\nCDEBUG(D_INFO, "submit bio sector %llu size %u\n",\r\n(unsigned long long)old_bio->bi_iter.bi_sector,\r\nold_bio->bi_iter.bi_size);\r\nspin_lock_irq(&lo->lo_lock);\r\ninactive = (lo->lo_state != LLOOP_BOUND);\r\nspin_unlock_irq(&lo->lo_lock);\r\nif (inactive)\r\ngoto err;\r\nif (rw == WRITE) {\r\nif (lo->lo_flags & LO_FLAGS_READ_ONLY)\r\ngoto err;\r\n} else if (rw == READA) {\r\nrw = READ;\r\n} else if (rw != READ) {\r\nCERROR("lloop: unknown command (%x)\n", rw);\r\ngoto err;\r\n}\r\nloop_add_bio(lo, old_bio);\r\nreturn;\r\nerr:\r\ncfs_bio_io_error(old_bio, old_bio->bi_iter.bi_size);\r\n}\r\nstatic inline void loop_handle_bio(struct lloop_device *lo, struct bio *bio)\r\n{\r\nint ret;\r\nret = do_bio_lustrebacked(lo, bio);\r\nwhile (bio) {\r\nstruct bio *tmp = bio->bi_next;\r\nbio->bi_next = NULL;\r\ncfs_bio_endio(bio, bio->bi_iter.bi_size, ret);\r\nbio = tmp;\r\n}\r\n}\r\nstatic inline int loop_active(struct lloop_device *lo)\r\n{\r\nreturn atomic_read(&lo->lo_pending) ||\r\n(lo->lo_state == LLOOP_RUNDOWN);\r\n}\r\nstatic int loop_thread(void *data)\r\n{\r\nstruct lloop_device *lo = data;\r\nstruct bio *bio;\r\nunsigned int count;\r\nunsigned long times = 0;\r\nunsigned long total_count = 0;\r\nstruct lu_env *env;\r\nint refcheck;\r\nint ret = 0;\r\nset_user_nice(current, MIN_NICE);\r\nlo->lo_state = LLOOP_BOUND;\r\nenv = cl_env_get(&refcheck);\r\nif (IS_ERR(env)) {\r\nret = PTR_ERR(env);\r\ngoto out;\r\n}\r\nlo->lo_env = env;\r\nmemset(&lo->lo_pvec, 0, sizeof(lo->lo_pvec));\r\nlo->lo_pvec.ldp_pages = lo->lo_requests[0].lrd_pages;\r\nlo->lo_pvec.ldp_offsets = lo->lo_requests[0].lrd_offsets;\r\nup(&lo->lo_sem);\r\nfor (;;) {\r\nwait_event(lo->lo_bh_wait, loop_active(lo));\r\nif (!atomic_read(&lo->lo_pending)) {\r\nint exiting = 0;\r\nspin_lock_irq(&lo->lo_lock);\r\nexiting = (lo->lo_state == LLOOP_RUNDOWN);\r\nspin_unlock_irq(&lo->lo_lock);\r\nif (exiting)\r\nbreak;\r\n}\r\nbio = NULL;\r\ncount = loop_get_bio(lo, &bio);\r\nif (!count) {\r\nCWARN("lloop(minor: %d): missing bio\n", lo->lo_number);\r\ncontinue;\r\n}\r\ntotal_count += count;\r\nif (total_count < count) {\r\ntotal_count = count;\r\ntimes = 1;\r\n} else {\r\ntimes++;\r\n}\r\nif ((times & 127) == 0) {\r\nCDEBUG(D_INFO, "total: %lu, count: %lu, avg: %lu\n",\r\ntotal_count, times, total_count / times);\r\n}\r\nLASSERT(bio != NULL);\r\nLASSERT(count <= atomic_read(&lo->lo_pending));\r\nloop_handle_bio(lo, bio);\r\natomic_sub(count, &lo->lo_pending);\r\n}\r\ncl_env_put(env, &refcheck);\r\nout:\r\nup(&lo->lo_sem);\r\nreturn ret;\r\n}\r\nstatic int loop_set_fd(struct lloop_device *lo, struct file *unused,\r\nstruct block_device *bdev, struct file *file)\r\n{\r\nstruct inode *inode;\r\nstruct address_space *mapping;\r\nint lo_flags = 0;\r\nint error;\r\nloff_t size;\r\nif (!try_module_get(THIS_MODULE))\r\nreturn -ENODEV;\r\nerror = -EBUSY;\r\nif (lo->lo_state != LLOOP_UNBOUND)\r\ngoto out;\r\nmapping = file->f_mapping;\r\ninode = mapping->host;\r\nerror = -EINVAL;\r\nif (!S_ISREG(inode->i_mode) || inode->i_sb->s_magic != LL_SUPER_MAGIC)\r\ngoto out;\r\nif (!(file->f_mode & FMODE_WRITE))\r\nlo_flags |= LO_FLAGS_READ_ONLY;\r\nsize = get_loop_size(lo, file);\r\nif ((loff_t)(sector_t)size != size) {\r\nerror = -EFBIG;\r\ngoto out;\r\n}\r\ntruncate_inode_pages(mapping, 0);\r\nset_device_ro(bdev, (lo_flags & LO_FLAGS_READ_ONLY) != 0);\r\nlo->lo_blocksize = PAGE_CACHE_SIZE;\r\nlo->lo_device = bdev;\r\nlo->lo_flags = lo_flags;\r\nlo->lo_backing_file = file;\r\nlo->lo_sizelimit = 0;\r\nlo->old_gfp_mask = mapping_gfp_mask(mapping);\r\nmapping_set_gfp_mask(mapping, lo->old_gfp_mask & ~(__GFP_IO|__GFP_FS));\r\nlo->lo_bio = lo->lo_biotail = NULL;\r\nblk_queue_make_request(lo->lo_queue, loop_make_request);\r\nlo->lo_queue->queuedata = lo;\r\nCLASSERT(PAGE_CACHE_SIZE < (1 << (sizeof(unsigned short) * 8)));\r\nblk_queue_logical_block_size(lo->lo_queue,\r\n(unsigned short)PAGE_CACHE_SIZE);\r\nblk_queue_max_hw_sectors(lo->lo_queue,\r\nLLOOP_MAX_SEGMENTS << (PAGE_CACHE_SHIFT - 9));\r\nblk_queue_max_segments(lo->lo_queue, LLOOP_MAX_SEGMENTS);\r\nset_capacity(disks[lo->lo_number], size);\r\nbd_set_size(bdev, size << 9);\r\nset_blocksize(bdev, lo->lo_blocksize);\r\nkthread_run(loop_thread, lo, "lloop%d", lo->lo_number);\r\ndown(&lo->lo_sem);\r\nreturn 0;\r\nout:\r\nmodule_put(THIS_MODULE);\r\nreturn error;\r\n}\r\nstatic int loop_clr_fd(struct lloop_device *lo, struct block_device *bdev,\r\nint count)\r\n{\r\nstruct file *filp = lo->lo_backing_file;\r\ngfp_t gfp = lo->old_gfp_mask;\r\nif (lo->lo_state != LLOOP_BOUND)\r\nreturn -ENXIO;\r\nif (lo->lo_refcnt > count)\r\nreturn -EBUSY;\r\nif (filp == NULL)\r\nreturn -EINVAL;\r\nspin_lock_irq(&lo->lo_lock);\r\nlo->lo_state = LLOOP_RUNDOWN;\r\nspin_unlock_irq(&lo->lo_lock);\r\nwake_up(&lo->lo_bh_wait);\r\ndown(&lo->lo_sem);\r\nlo->lo_backing_file = NULL;\r\nlo->lo_device = NULL;\r\nlo->lo_offset = 0;\r\nlo->lo_sizelimit = 0;\r\nlo->lo_flags = 0;\r\ninvalidate_bdev(bdev);\r\nset_capacity(disks[lo->lo_number], 0);\r\nbd_set_size(bdev, 0);\r\nmapping_set_gfp_mask(filp->f_mapping, gfp);\r\nlo->lo_state = LLOOP_UNBOUND;\r\nfput(filp);\r\nmodule_put(THIS_MODULE);\r\nreturn 0;\r\n}\r\nstatic int lo_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct lloop_device *lo = bdev->bd_disk->private_data;\r\nmutex_lock(&lo->lo_ctl_mutex);\r\nlo->lo_refcnt++;\r\nmutex_unlock(&lo->lo_ctl_mutex);\r\nreturn 0;\r\n}\r\nstatic void lo_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct lloop_device *lo = disk->private_data;\r\nmutex_lock(&lo->lo_ctl_mutex);\r\n--lo->lo_refcnt;\r\nmutex_unlock(&lo->lo_ctl_mutex);\r\n}\r\nstatic int lo_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct lloop_device *lo = bdev->bd_disk->private_data;\r\nstruct inode *inode = NULL;\r\nint err = 0;\r\nmutex_lock(&lloop_mutex);\r\nswitch (cmd) {\r\ncase LL_IOC_LLOOP_DETACH: {\r\nerr = loop_clr_fd(lo, bdev, 2);\r\nif (err == 0)\r\nblkdev_put(bdev, 0);\r\nbreak;\r\n}\r\ncase LL_IOC_LLOOP_INFO: {\r\nstruct lu_fid fid;\r\nif (lo->lo_backing_file == NULL) {\r\nerr = -ENOENT;\r\nbreak;\r\n}\r\nif (inode == NULL)\r\ninode = file_inode(lo->lo_backing_file);\r\nif (lo->lo_state == LLOOP_BOUND)\r\nfid = ll_i2info(inode)->lli_fid;\r\nelse\r\nfid_zero(&fid);\r\nif (copy_to_user((struct lu_fid *)arg, &fid, sizeof(fid)))\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nmutex_unlock(&lloop_mutex);\r\nreturn err;\r\n}\r\nstatic enum llioc_iter lloop_ioctl(struct inode *unused, struct file *file,\r\nunsigned int cmd, unsigned long arg,\r\nvoid *magic, int *rcp)\r\n{\r\nstruct lloop_device *lo = NULL;\r\nstruct block_device *bdev = NULL;\r\nint err = 0;\r\ndev_t dev;\r\nif (magic != ll_iocontrol_magic)\r\nreturn LLIOC_CONT;\r\nif (disks == NULL) {\r\nerr = -ENODEV;\r\ngoto out1;\r\n}\r\nCWARN("Enter llop_ioctl\n");\r\nmutex_lock(&lloop_mutex);\r\nswitch (cmd) {\r\ncase LL_IOC_LLOOP_ATTACH: {\r\nstruct lloop_device *lo_free = NULL;\r\nint i;\r\nfor (i = 0; i < max_loop; i++, lo = NULL) {\r\nlo = &loop_dev[i];\r\nif (lo->lo_state == LLOOP_UNBOUND) {\r\nif (!lo_free)\r\nlo_free = lo;\r\ncontinue;\r\n}\r\nif (file_inode(lo->lo_backing_file) == file_inode(file))\r\nbreak;\r\n}\r\nif (lo || !lo_free) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nlo = lo_free;\r\ndev = MKDEV(lloop_major, lo->lo_number);\r\nif (put_user((long)old_encode_dev(dev), (long *)arg)) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nbdev = blkdev_get_by_dev(dev, file->f_mode, NULL);\r\nif (IS_ERR(bdev)) {\r\nerr = PTR_ERR(bdev);\r\ngoto out;\r\n}\r\nget_file(file);\r\nerr = loop_set_fd(lo, NULL, bdev, file);\r\nif (err) {\r\nfput(file);\r\nblkdev_put(bdev, 0);\r\n}\r\nbreak;\r\n}\r\ncase LL_IOC_LLOOP_DETACH_BYDEV: {\r\nint minor;\r\ndev = old_decode_dev(arg);\r\nif (MAJOR(dev) != lloop_major) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nminor = MINOR(dev);\r\nif (minor > max_loop - 1) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nlo = &loop_dev[minor];\r\nif (lo->lo_state != LLOOP_BOUND) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nbdev = lo->lo_device;\r\nerr = loop_clr_fd(lo, bdev, 1);\r\nif (err == 0)\r\nblkdev_put(bdev, 0);\r\nbreak;\r\n}\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nout:\r\nmutex_unlock(&lloop_mutex);\r\nout1:\r\nif (rcp)\r\n*rcp = err;\r\nreturn LLIOC_STOP;\r\n}\r\nstatic int __init lloop_init(void)\r\n{\r\nint i;\r\nunsigned int cmdlist[] = {\r\nLL_IOC_LLOOP_ATTACH,\r\nLL_IOC_LLOOP_DETACH_BYDEV,\r\n};\r\nif (max_loop < 1 || max_loop > 256) {\r\nmax_loop = MAX_LOOP_DEFAULT;\r\nCWARN("lloop: invalid max_loop (must be between 1 and 256), using default (%u)\n",\r\nmax_loop);\r\n}\r\nlloop_major = register_blkdev(0, "lloop");\r\nif (lloop_major < 0)\r\nreturn -EIO;\r\nCDEBUG(D_CONFIG, "registered lloop major %d with %u minors\n",\r\nlloop_major, max_loop);\r\nll_iocontrol_magic = ll_iocontrol_register(lloop_ioctl, 2, cmdlist);\r\nif (ll_iocontrol_magic == NULL)\r\ngoto out_mem1;\r\nloop_dev = kcalloc(max_loop, sizeof(*loop_dev), GFP_KERNEL);\r\nif (!loop_dev)\r\ngoto out_mem1;\r\ndisks = kcalloc(max_loop, sizeof(*disks), GFP_KERNEL);\r\nif (!disks)\r\ngoto out_mem2;\r\nfor (i = 0; i < max_loop; i++) {\r\ndisks[i] = alloc_disk(1);\r\nif (!disks[i])\r\ngoto out_mem3;\r\n}\r\nmutex_init(&lloop_mutex);\r\nfor (i = 0; i < max_loop; i++) {\r\nstruct lloop_device *lo = &loop_dev[i];\r\nstruct gendisk *disk = disks[i];\r\nlo->lo_queue = blk_alloc_queue(GFP_KERNEL);\r\nif (!lo->lo_queue)\r\ngoto out_mem4;\r\nmutex_init(&lo->lo_ctl_mutex);\r\nsema_init(&lo->lo_sem, 0);\r\ninit_waitqueue_head(&lo->lo_bh_wait);\r\nlo->lo_number = i;\r\nspin_lock_init(&lo->lo_lock);\r\ndisk->major = lloop_major;\r\ndisk->first_minor = i;\r\ndisk->fops = &lo_fops;\r\nsprintf(disk->disk_name, "lloop%d", i);\r\ndisk->private_data = lo;\r\ndisk->queue = lo->lo_queue;\r\n}\r\nfor (i = 0; i < max_loop; i++)\r\nadd_disk(disks[i]);\r\nreturn 0;\r\nout_mem4:\r\nwhile (i--)\r\nblk_cleanup_queue(loop_dev[i].lo_queue);\r\ni = max_loop;\r\nout_mem3:\r\nwhile (i--)\r\nput_disk(disks[i]);\r\nOBD_FREE(disks, max_loop * sizeof(*disks));\r\nout_mem2:\r\nOBD_FREE(loop_dev, max_loop * sizeof(*loop_dev));\r\nout_mem1:\r\nunregister_blkdev(lloop_major, "lloop");\r\nll_iocontrol_unregister(ll_iocontrol_magic);\r\nCERROR("lloop: ran out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nstatic void lloop_exit(void)\r\n{\r\nint i;\r\nll_iocontrol_unregister(ll_iocontrol_magic);\r\nfor (i = 0; i < max_loop; i++) {\r\ndel_gendisk(disks[i]);\r\nblk_cleanup_queue(loop_dev[i].lo_queue);\r\nput_disk(disks[i]);\r\n}\r\nunregister_blkdev(lloop_major, "lloop");\r\nOBD_FREE(disks, max_loop * sizeof(*disks));\r\nOBD_FREE(loop_dev, max_loop * sizeof(*loop_dev));\r\n}
