static int pkg_temp_debugfs_init(void)\r\n{\r\nstruct dentry *d;\r\ndebugfs = debugfs_create_dir("pkg_temp_thermal", NULL);\r\nif (!debugfs)\r\nreturn -ENOENT;\r\nd = debugfs_create_u32("pkg_thres_interrupt", S_IRUGO, debugfs,\r\n(u32 *)&pkg_interrupt_cnt);\r\nif (!d)\r\ngoto err_out;\r\nd = debugfs_create_u32("pkg_thres_work", S_IRUGO, debugfs,\r\n(u32 *)&pkg_work_cnt);\r\nif (!d)\r\ngoto err_out;\r\nreturn 0;\r\nerr_out:\r\ndebugfs_remove_recursive(debugfs);\r\nreturn -ENOENT;\r\n}\r\nstatic struct phy_dev_entry\r\n*pkg_temp_thermal_get_phy_entry(unsigned int cpu)\r\n{\r\nu16 phys_proc_id = topology_physical_package_id(cpu);\r\nstruct phy_dev_entry *phy_ptr;\r\nmutex_lock(&phy_dev_list_mutex);\r\nlist_for_each_entry(phy_ptr, &phy_dev_list, list)\r\nif (phy_ptr->phys_proc_id == phys_proc_id) {\r\nmutex_unlock(&phy_dev_list_mutex);\r\nreturn phy_ptr;\r\n}\r\nmutex_unlock(&phy_dev_list_mutex);\r\nreturn NULL;\r\n}\r\nstatic int get_tj_max(int cpu, u32 *tj_max)\r\n{\r\nu32 eax, edx;\r\nu32 val;\r\nint err;\r\nerr = rdmsr_safe_on_cpu(cpu, MSR_IA32_TEMPERATURE_TARGET, &eax, &edx);\r\nif (err)\r\ngoto err_ret;\r\nelse {\r\nval = (eax >> 16) & 0xff;\r\nif (val)\r\n*tj_max = val * 1000;\r\nelse {\r\nerr = -EINVAL;\r\ngoto err_ret;\r\n}\r\n}\r\nreturn 0;\r\nerr_ret:\r\n*tj_max = 0;\r\nreturn err;\r\n}\r\nstatic int sys_get_curr_temp(struct thermal_zone_device *tzd, unsigned long *temp)\r\n{\r\nu32 eax, edx;\r\nstruct phy_dev_entry *phy_dev_entry;\r\nphy_dev_entry = tzd->devdata;\r\nrdmsr_on_cpu(phy_dev_entry->first_cpu, MSR_IA32_PACKAGE_THERM_STATUS,\r\n&eax, &edx);\r\nif (eax & 0x80000000) {\r\n*temp = phy_dev_entry->tj_max -\r\n((eax >> 16) & 0x7f) * 1000;\r\npr_debug("sys_get_curr_temp %ld\n", *temp);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int sys_get_trip_temp(struct thermal_zone_device *tzd,\r\nint trip, unsigned long *temp)\r\n{\r\nu32 eax, edx;\r\nstruct phy_dev_entry *phy_dev_entry;\r\nu32 mask, shift;\r\nunsigned long thres_reg_value;\r\nint ret;\r\nif (trip >= MAX_NUMBER_OF_TRIPS)\r\nreturn -EINVAL;\r\nphy_dev_entry = tzd->devdata;\r\nif (trip) {\r\nmask = THERM_MASK_THRESHOLD1;\r\nshift = THERM_SHIFT_THRESHOLD1;\r\n} else {\r\nmask = THERM_MASK_THRESHOLD0;\r\nshift = THERM_SHIFT_THRESHOLD0;\r\n}\r\nret = rdmsr_on_cpu(phy_dev_entry->first_cpu,\r\nMSR_IA32_PACKAGE_THERM_INTERRUPT, &eax, &edx);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nthres_reg_value = (eax & mask) >> shift;\r\nif (thres_reg_value)\r\n*temp = phy_dev_entry->tj_max - thres_reg_value * 1000;\r\nelse\r\n*temp = 0;\r\npr_debug("sys_get_trip_temp %ld\n", *temp);\r\nreturn 0;\r\n}\r\nstatic int sys_set_trip_temp(struct thermal_zone_device *tzd, int trip,\r\nunsigned long temp)\r\n{\r\nu32 l, h;\r\nstruct phy_dev_entry *phy_dev_entry;\r\nu32 mask, shift, intr;\r\nint ret;\r\nphy_dev_entry = tzd->devdata;\r\nif (trip >= MAX_NUMBER_OF_TRIPS || temp >= phy_dev_entry->tj_max)\r\nreturn -EINVAL;\r\nret = rdmsr_on_cpu(phy_dev_entry->first_cpu,\r\nMSR_IA32_PACKAGE_THERM_INTERRUPT,\r\n&l, &h);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nif (trip) {\r\nmask = THERM_MASK_THRESHOLD1;\r\nshift = THERM_SHIFT_THRESHOLD1;\r\nintr = THERM_INT_THRESHOLD1_ENABLE;\r\n} else {\r\nmask = THERM_MASK_THRESHOLD0;\r\nshift = THERM_SHIFT_THRESHOLD0;\r\nintr = THERM_INT_THRESHOLD0_ENABLE;\r\n}\r\nl &= ~mask;\r\nif (!temp)\r\nl &= ~intr;\r\nelse {\r\nl |= (phy_dev_entry->tj_max - temp)/1000 << shift;\r\nl |= intr;\r\n}\r\nreturn wrmsr_on_cpu(phy_dev_entry->first_cpu,\r\nMSR_IA32_PACKAGE_THERM_INTERRUPT,\r\nl, h);\r\n}\r\nstatic int sys_get_trip_type(struct thermal_zone_device *thermal,\r\nint trip, enum thermal_trip_type *type)\r\n{\r\n*type = THERMAL_TRIP_PASSIVE;\r\nreturn 0;\r\n}\r\nstatic bool pkg_temp_thermal_platform_thermal_rate_control(void)\r\n{\r\nreturn true;\r\n}\r\nstatic inline void enable_pkg_thres_interrupt(void)\r\n{\r\nu32 l, h;\r\nu8 thres_0, thres_1;\r\nrdmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\r\nthres_0 = (l & THERM_MASK_THRESHOLD0) >> THERM_SHIFT_THRESHOLD0;\r\nthres_1 = (l & THERM_MASK_THRESHOLD1) >> THERM_SHIFT_THRESHOLD1;\r\nif (thres_0)\r\nl |= THERM_INT_THRESHOLD0_ENABLE;\r\nif (thres_1)\r\nl |= THERM_INT_THRESHOLD1_ENABLE;\r\nwrmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\r\n}\r\nstatic inline void disable_pkg_thres_interrupt(void)\r\n{\r\nu32 l, h;\r\nrdmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT, l, h);\r\nwrmsr(MSR_IA32_PACKAGE_THERM_INTERRUPT,\r\nl & (~THERM_INT_THRESHOLD0_ENABLE) &\r\n(~THERM_INT_THRESHOLD1_ENABLE), h);\r\n}\r\nstatic void pkg_temp_thermal_threshold_work_fn(struct work_struct *work)\r\n{\r\n__u64 msr_val;\r\nint cpu = smp_processor_id();\r\nint phy_id = topology_physical_package_id(cpu);\r\nstruct phy_dev_entry *phdev = pkg_temp_thermal_get_phy_entry(cpu);\r\nbool notify = false;\r\nunsigned long flags;\r\nif (!phdev)\r\nreturn;\r\nspin_lock_irqsave(&pkg_work_lock, flags);\r\n++pkg_work_cnt;\r\nif (unlikely(phy_id > max_phy_id)) {\r\nspin_unlock_irqrestore(&pkg_work_lock, flags);\r\nreturn;\r\n}\r\npkg_work_scheduled[phy_id] = 0;\r\nspin_unlock_irqrestore(&pkg_work_lock, flags);\r\nenable_pkg_thres_interrupt();\r\nrdmsrl(MSR_IA32_PACKAGE_THERM_STATUS, msr_val);\r\nif (msr_val & THERM_LOG_THRESHOLD0) {\r\nwrmsrl(MSR_IA32_PACKAGE_THERM_STATUS,\r\nmsr_val & ~THERM_LOG_THRESHOLD0);\r\nnotify = true;\r\n}\r\nif (msr_val & THERM_LOG_THRESHOLD1) {\r\nwrmsrl(MSR_IA32_PACKAGE_THERM_STATUS,\r\nmsr_val & ~THERM_LOG_THRESHOLD1);\r\nnotify = true;\r\n}\r\nif (notify) {\r\npr_debug("thermal_zone_device_update\n");\r\nthermal_zone_device_update(phdev->tzone);\r\n}\r\n}\r\nstatic int pkg_temp_thermal_platform_thermal_notify(__u64 msr_val)\r\n{\r\nunsigned long flags;\r\nint cpu = smp_processor_id();\r\nint phy_id = topology_physical_package_id(cpu);\r\nspin_lock_irqsave(&pkg_work_lock, flags);\r\n++pkg_interrupt_cnt;\r\nif (unlikely(phy_id > max_phy_id) || unlikely(!pkg_work_scheduled) ||\r\npkg_work_scheduled[phy_id]) {\r\ndisable_pkg_thres_interrupt();\r\nspin_unlock_irqrestore(&pkg_work_lock, flags);\r\nreturn -EINVAL;\r\n}\r\npkg_work_scheduled[phy_id] = 1;\r\nspin_unlock_irqrestore(&pkg_work_lock, flags);\r\ndisable_pkg_thres_interrupt();\r\nschedule_delayed_work_on(cpu,\r\n&per_cpu(pkg_temp_thermal_threshold_work, cpu),\r\nmsecs_to_jiffies(notify_delay_ms));\r\nreturn 0;\r\n}\r\nstatic int find_siblings_cpu(int cpu)\r\n{\r\nint i;\r\nint id = topology_physical_package_id(cpu);\r\nfor_each_online_cpu(i)\r\nif (i != cpu && topology_physical_package_id(i) == id)\r\nreturn i;\r\nreturn 0;\r\n}\r\nstatic int pkg_temp_thermal_device_add(unsigned int cpu)\r\n{\r\nint err;\r\nu32 tj_max;\r\nstruct phy_dev_entry *phy_dev_entry;\r\nint thres_count;\r\nu32 eax, ebx, ecx, edx;\r\nu8 *temp;\r\nunsigned long flags;\r\ncpuid(6, &eax, &ebx, &ecx, &edx);\r\nthres_count = ebx & 0x07;\r\nif (!thres_count)\r\nreturn -ENODEV;\r\nif (topology_physical_package_id(cpu) > MAX_PKG_TEMP_ZONE_IDS)\r\nreturn -ENODEV;\r\nthres_count = clamp_val(thres_count, 0, MAX_NUMBER_OF_TRIPS);\r\nerr = get_tj_max(cpu, &tj_max);\r\nif (err)\r\ngoto err_ret;\r\nmutex_lock(&phy_dev_list_mutex);\r\nphy_dev_entry = kzalloc(sizeof(*phy_dev_entry), GFP_KERNEL);\r\nif (!phy_dev_entry) {\r\nerr = -ENOMEM;\r\ngoto err_ret_unlock;\r\n}\r\nspin_lock_irqsave(&pkg_work_lock, flags);\r\nif (topology_physical_package_id(cpu) > max_phy_id)\r\nmax_phy_id = topology_physical_package_id(cpu);\r\ntemp = krealloc(pkg_work_scheduled,\r\n(max_phy_id+1) * sizeof(u8), GFP_ATOMIC);\r\nif (!temp) {\r\nspin_unlock_irqrestore(&pkg_work_lock, flags);\r\nerr = -ENOMEM;\r\ngoto err_ret_free;\r\n}\r\npkg_work_scheduled = temp;\r\npkg_work_scheduled[topology_physical_package_id(cpu)] = 0;\r\nspin_unlock_irqrestore(&pkg_work_lock, flags);\r\nphy_dev_entry->phys_proc_id = topology_physical_package_id(cpu);\r\nphy_dev_entry->first_cpu = cpu;\r\nphy_dev_entry->tj_max = tj_max;\r\nphy_dev_entry->ref_cnt = 1;\r\nphy_dev_entry->tzone = thermal_zone_device_register("x86_pkg_temp",\r\nthres_count,\r\n(thres_count == MAX_NUMBER_OF_TRIPS) ?\r\n0x03 : 0x01,\r\nphy_dev_entry, &tzone_ops, &pkg_temp_tz_params, 0, 0);\r\nif (IS_ERR(phy_dev_entry->tzone)) {\r\nerr = PTR_ERR(phy_dev_entry->tzone);\r\ngoto err_ret_free;\r\n}\r\nrdmsr_on_cpu(cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT,\r\n&phy_dev_entry->start_pkg_therm_low,\r\n&phy_dev_entry->start_pkg_therm_high);\r\nlist_add_tail(&phy_dev_entry->list, &phy_dev_list);\r\npr_debug("pkg_temp_thermal_device_add :phy_id %d cpu %d\n",\r\nphy_dev_entry->phys_proc_id, cpu);\r\nmutex_unlock(&phy_dev_list_mutex);\r\nreturn 0;\r\nerr_ret_free:\r\nkfree(phy_dev_entry);\r\nerr_ret_unlock:\r\nmutex_unlock(&phy_dev_list_mutex);\r\nerr_ret:\r\nreturn err;\r\n}\r\nstatic int pkg_temp_thermal_device_remove(unsigned int cpu)\r\n{\r\nstruct phy_dev_entry *n;\r\nu16 phys_proc_id = topology_physical_package_id(cpu);\r\nstruct phy_dev_entry *phdev =\r\npkg_temp_thermal_get_phy_entry(cpu);\r\nif (!phdev)\r\nreturn -ENODEV;\r\nmutex_lock(&phy_dev_list_mutex);\r\nif (phdev->first_cpu == cpu) {\r\nphdev->first_cpu = find_siblings_cpu(cpu);\r\npr_debug("thermal_device_remove: first cpu switched %d\n",\r\nphdev->first_cpu);\r\n}\r\n--phdev->ref_cnt;\r\npr_debug("thermal_device_remove: pkg: %d cpu %d ref_cnt %d\n",\r\nphys_proc_id, cpu, phdev->ref_cnt);\r\nif (!phdev->ref_cnt)\r\nlist_for_each_entry_safe(phdev, n, &phy_dev_list, list) {\r\nif (phdev->phys_proc_id == phys_proc_id) {\r\nthermal_zone_device_unregister(phdev->tzone);\r\nlist_del(&phdev->list);\r\nkfree(phdev);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&phy_dev_list_mutex);\r\nreturn 0;\r\n}\r\nstatic int get_core_online(unsigned int cpu)\r\n{\r\nstruct cpuinfo_x86 *c = &cpu_data(cpu);\r\nstruct phy_dev_entry *phdev = pkg_temp_thermal_get_phy_entry(cpu);\r\nif (!phdev) {\r\nif (!cpu_has(c, X86_FEATURE_DTHERM) ||\r\n!cpu_has(c, X86_FEATURE_PTS))\r\nreturn -ENODEV;\r\nif (pkg_temp_thermal_device_add(cpu))\r\nreturn -ENODEV;\r\n} else {\r\nmutex_lock(&phy_dev_list_mutex);\r\n++phdev->ref_cnt;\r\npr_debug("get_core_online: cpu %d ref_cnt %d\n",\r\ncpu, phdev->ref_cnt);\r\nmutex_unlock(&phy_dev_list_mutex);\r\n}\r\nINIT_DELAYED_WORK(&per_cpu(pkg_temp_thermal_threshold_work, cpu),\r\npkg_temp_thermal_threshold_work_fn);\r\npr_debug("get_core_online: cpu %d successful\n", cpu);\r\nreturn 0;\r\n}\r\nstatic void put_core_offline(unsigned int cpu)\r\n{\r\nif (!pkg_temp_thermal_device_remove(cpu))\r\ncancel_delayed_work_sync(\r\n&per_cpu(pkg_temp_thermal_threshold_work, cpu));\r\npr_debug("put_core_offline: cpu %d\n", cpu);\r\n}\r\nstatic int pkg_temp_thermal_cpu_callback(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nunsigned int cpu = (unsigned long) hcpu;\r\nswitch (action) {\r\ncase CPU_ONLINE:\r\ncase CPU_DOWN_FAILED:\r\nget_core_online(cpu);\r\nbreak;\r\ncase CPU_DOWN_PREPARE:\r\nput_core_offline(cpu);\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init pkg_temp_thermal_init(void)\r\n{\r\nint i;\r\nif (!x86_match_cpu(pkg_temp_thermal_ids))\r\nreturn -ENODEV;\r\nspin_lock_init(&pkg_work_lock);\r\nplatform_thermal_package_notify =\r\npkg_temp_thermal_platform_thermal_notify;\r\nplatform_thermal_package_rate_control =\r\npkg_temp_thermal_platform_thermal_rate_control;\r\ncpu_notifier_register_begin();\r\nfor_each_online_cpu(i)\r\nif (get_core_online(i))\r\ngoto err_ret;\r\n__register_hotcpu_notifier(&pkg_temp_thermal_notifier);\r\ncpu_notifier_register_done();\r\npkg_temp_debugfs_init();\r\nreturn 0;\r\nerr_ret:\r\nfor_each_online_cpu(i)\r\nput_core_offline(i);\r\ncpu_notifier_register_done();\r\nkfree(pkg_work_scheduled);\r\nplatform_thermal_package_notify = NULL;\r\nplatform_thermal_package_rate_control = NULL;\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit pkg_temp_thermal_exit(void)\r\n{\r\nstruct phy_dev_entry *phdev, *n;\r\nint i;\r\ncpu_notifier_register_begin();\r\n__unregister_hotcpu_notifier(&pkg_temp_thermal_notifier);\r\nmutex_lock(&phy_dev_list_mutex);\r\nlist_for_each_entry_safe(phdev, n, &phy_dev_list, list) {\r\nwrmsr_on_cpu(phdev->first_cpu,\r\nMSR_IA32_PACKAGE_THERM_INTERRUPT,\r\nphdev->start_pkg_therm_low,\r\nphdev->start_pkg_therm_high);\r\nthermal_zone_device_unregister(phdev->tzone);\r\nlist_del(&phdev->list);\r\nkfree(phdev);\r\n}\r\nmutex_unlock(&phy_dev_list_mutex);\r\nplatform_thermal_package_notify = NULL;\r\nplatform_thermal_package_rate_control = NULL;\r\nfor_each_online_cpu(i)\r\ncancel_delayed_work_sync(\r\n&per_cpu(pkg_temp_thermal_threshold_work, i));\r\ncpu_notifier_register_done();\r\nkfree(pkg_work_scheduled);\r\ndebugfs_remove_recursive(debugfs);\r\n}
