static long\r\n__do_compat_cache_op(unsigned long start, unsigned long end)\r\n{\r\nlong ret;\r\ndo {\r\nunsigned long chunk = min(PAGE_SIZE, end - start);\r\nif (fatal_signal_pending(current))\r\nreturn 0;\r\nret = __flush_cache_user_range(start, start + chunk);\r\nif (ret)\r\nreturn ret;\r\ncond_resched();\r\nstart += chunk;\r\n} while (start < end);\r\nreturn 0;\r\n}\r\nstatic inline long\r\ndo_compat_cache_op(unsigned long start, unsigned long end, int flags)\r\n{\r\nif (end < start || flags)\r\nreturn -EINVAL;\r\nif (!access_ok(VERIFY_READ, start, end - start))\r\nreturn -EFAULT;\r\nreturn __do_compat_cache_op(start, end);\r\n}\r\nlong compat_arm_syscall(struct pt_regs *regs)\r\n{\r\nunsigned int no = regs->regs[7];\r\nswitch (no) {\r\ncase __ARM_NR_compat_cacheflush:\r\nreturn do_compat_cache_op(regs->regs[0], regs->regs[1], regs->regs[2]);\r\ncase __ARM_NR_compat_set_tls:\r\ncurrent->thread.tp_value = regs->regs[0];\r\nbarrier();\r\nasm ("msr tpidrro_el0, %0" : : "r" (regs->regs[0]));\r\nreturn 0;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\n}
