drm_dma_handle_t *drm_pci_alloc(struct drm_device * dev, size_t size, size_t align)\r\n{\r\ndrm_dma_handle_t *dmah;\r\nunsigned long addr;\r\nsize_t sz;\r\nif (align > size)\r\nreturn NULL;\r\ndmah = kmalloc(sizeof(drm_dma_handle_t), GFP_KERNEL);\r\nif (!dmah)\r\nreturn NULL;\r\ndmah->size = size;\r\ndmah->vaddr = dma_alloc_coherent(&dev->pdev->dev, size, &dmah->busaddr, GFP_KERNEL | __GFP_COMP);\r\nif (dmah->vaddr == NULL) {\r\nkfree(dmah);\r\nreturn NULL;\r\n}\r\nmemset(dmah->vaddr, 0, size);\r\nfor (addr = (unsigned long)dmah->vaddr, sz = size;\r\nsz > 0; addr += PAGE_SIZE, sz -= PAGE_SIZE) {\r\nSetPageReserved(virt_to_page((void *)addr));\r\n}\r\nreturn dmah;\r\n}\r\nvoid __drm_legacy_pci_free(struct drm_device * dev, drm_dma_handle_t * dmah)\r\n{\r\nunsigned long addr;\r\nsize_t sz;\r\nif (dmah->vaddr) {\r\nfor (addr = (unsigned long)dmah->vaddr, sz = dmah->size;\r\nsz > 0; addr += PAGE_SIZE, sz -= PAGE_SIZE) {\r\nClearPageReserved(virt_to_page((void *)addr));\r\n}\r\ndma_free_coherent(&dev->pdev->dev, dmah->size, dmah->vaddr,\r\ndmah->busaddr);\r\n}\r\n}\r\nvoid drm_pci_free(struct drm_device * dev, drm_dma_handle_t * dmah)\r\n{\r\n__drm_legacy_pci_free(dev, dmah);\r\nkfree(dmah);\r\n}\r\nstatic int drm_get_pci_domain(struct drm_device *dev)\r\n{\r\n#ifndef __alpha__\r\nif (dev->if_version < 0x10004)\r\nreturn 0;\r\n#endif\r\nreturn pci_domain_nr(dev->pdev->bus);\r\n}\r\nint drm_pci_set_busid(struct drm_device *dev, struct drm_master *master)\r\n{\r\nmaster->unique = kasprintf(GFP_KERNEL, "pci:%04x:%02x:%02x.%d",\r\ndrm_get_pci_domain(dev),\r\ndev->pdev->bus->number,\r\nPCI_SLOT(dev->pdev->devfn),\r\nPCI_FUNC(dev->pdev->devfn));\r\nif (!master->unique)\r\nreturn -ENOMEM;\r\nmaster->unique_len = strlen(master->unique);\r\nreturn 0;\r\n}\r\nint drm_pci_set_unique(struct drm_device *dev,\r\nstruct drm_master *master,\r\nstruct drm_unique *u)\r\n{\r\nint domain, bus, slot, func, ret;\r\nmaster->unique_len = u->unique_len;\r\nmaster->unique = kmalloc(master->unique_len + 1, GFP_KERNEL);\r\nif (!master->unique) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nif (copy_from_user(master->unique, u->unique, master->unique_len)) {\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nmaster->unique[master->unique_len] = '\0';\r\nret = sscanf(master->unique, "PCI:%d:%d:%d", &bus, &slot, &func);\r\nif (ret != 3) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndomain = bus >> 8;\r\nbus &= 0xff;\r\nif ((domain != drm_get_pci_domain(dev)) ||\r\n(bus != dev->pdev->bus->number) ||\r\n(slot != PCI_SLOT(dev->pdev->devfn)) ||\r\n(func != PCI_FUNC(dev->pdev->devfn))) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int drm_pci_irq_by_busid(struct drm_device *dev, struct drm_irq_busid *p)\r\n{\r\nif ((p->busnum >> 8) != drm_get_pci_domain(dev) ||\r\n(p->busnum & 0xff) != dev->pdev->bus->number ||\r\np->devnum != PCI_SLOT(dev->pdev->devfn) || p->funcnum != PCI_FUNC(dev->pdev->devfn))\r\nreturn -EINVAL;\r\np->irq = dev->pdev->irq;\r\nDRM_DEBUG("%d:%d:%d => IRQ %d\n", p->busnum, p->devnum, p->funcnum,\r\np->irq);\r\nreturn 0;\r\n}\r\nint drm_irq_by_busid(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_irq_busid *p = data;\r\nif (drm_core_check_feature(dev, DRIVER_MODESET))\r\nreturn -EINVAL;\r\nif (WARN_ON(!dev->pdev))\r\nreturn -EINVAL;\r\nif (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))\r\nreturn -EINVAL;\r\nreturn drm_pci_irq_by_busid(dev, p);\r\n}\r\nstatic void drm_pci_agp_init(struct drm_device *dev)\r\n{\r\nif (drm_core_check_feature(dev, DRIVER_USE_AGP)) {\r\nif (drm_pci_device_is_agp(dev))\r\ndev->agp = drm_agp_init(dev);\r\nif (dev->agp) {\r\ndev->agp->agp_mtrr = arch_phys_wc_add(\r\ndev->agp->agp_info.aper_base,\r\ndev->agp->agp_info.aper_size *\r\n1024 * 1024);\r\n}\r\n}\r\n}\r\nvoid drm_pci_agp_destroy(struct drm_device *dev)\r\n{\r\nif (dev->agp) {\r\narch_phys_wc_del(dev->agp->agp_mtrr);\r\ndrm_agp_clear(dev);\r\nkfree(dev->agp);\r\ndev->agp = NULL;\r\n}\r\n}\r\nint drm_get_pci_dev(struct pci_dev *pdev, const struct pci_device_id *ent,\r\nstruct drm_driver *driver)\r\n{\r\nstruct drm_device *dev;\r\nint ret;\r\nDRM_DEBUG("\n");\r\ndev = drm_dev_alloc(driver, &pdev->dev);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nret = pci_enable_device(pdev);\r\nif (ret)\r\ngoto err_free;\r\ndev->pdev = pdev;\r\n#ifdef __alpha__\r\ndev->hose = pdev->sysdata;\r\n#endif\r\nif (drm_core_check_feature(dev, DRIVER_MODESET))\r\npci_set_drvdata(pdev, dev);\r\ndrm_pci_agp_init(dev);\r\nret = drm_dev_register(dev, ent->driver_data);\r\nif (ret)\r\ngoto err_agp;\r\nDRM_INFO("Initialized %s %d.%d.%d %s for %s on minor %d\n",\r\ndriver->name, driver->major, driver->minor, driver->patchlevel,\r\ndriver->date, pci_name(pdev), dev->primary->index);\r\nif (!drm_core_check_feature(dev, DRIVER_MODESET))\r\nlist_add_tail(&dev->legacy_dev_list, &driver->legacy_dev_list);\r\nreturn 0;\r\nerr_agp:\r\ndrm_pci_agp_destroy(dev);\r\npci_disable_device(pdev);\r\nerr_free:\r\ndrm_dev_unref(dev);\r\nreturn ret;\r\n}\r\nint drm_pci_init(struct drm_driver *driver, struct pci_driver *pdriver)\r\n{\r\nstruct pci_dev *pdev = NULL;\r\nconst struct pci_device_id *pid;\r\nint i;\r\nDRM_DEBUG("\n");\r\nif (driver->driver_features & DRIVER_MODESET)\r\nreturn pci_register_driver(pdriver);\r\nINIT_LIST_HEAD(&driver->legacy_dev_list);\r\nfor (i = 0; pdriver->id_table[i].vendor != 0; i++) {\r\npid = &pdriver->id_table[i];\r\npdev = NULL;\r\nwhile ((pdev =\r\npci_get_subsys(pid->vendor, pid->device, pid->subvendor,\r\npid->subdevice, pdev)) != NULL) {\r\nif ((pdev->class & pid->class_mask) != pid->class)\r\ncontinue;\r\npci_dev_get(pdev);\r\ndrm_get_pci_dev(pdev, pid, driver);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint drm_pcie_get_speed_cap_mask(struct drm_device *dev, u32 *mask)\r\n{\r\nstruct pci_dev *root;\r\nu32 lnkcap, lnkcap2;\r\n*mask = 0;\r\nif (!dev->pdev)\r\nreturn -EINVAL;\r\nroot = dev->pdev->bus->self;\r\nif (root->vendor == PCI_VENDOR_ID_VIA ||\r\nroot->vendor == PCI_VENDOR_ID_SERVERWORKS)\r\nreturn -EINVAL;\r\npcie_capability_read_dword(root, PCI_EXP_LNKCAP, &lnkcap);\r\npcie_capability_read_dword(root, PCI_EXP_LNKCAP2, &lnkcap2);\r\nif (lnkcap2) {\r\nif (lnkcap2 & PCI_EXP_LNKCAP2_SLS_2_5GB)\r\n*mask |= DRM_PCIE_SPEED_25;\r\nif (lnkcap2 & PCI_EXP_LNKCAP2_SLS_5_0GB)\r\n*mask |= DRM_PCIE_SPEED_50;\r\nif (lnkcap2 & PCI_EXP_LNKCAP2_SLS_8_0GB)\r\n*mask |= DRM_PCIE_SPEED_80;\r\n} else {\r\nif (lnkcap & PCI_EXP_LNKCAP_SLS_2_5GB)\r\n*mask |= DRM_PCIE_SPEED_25;\r\nif (lnkcap & PCI_EXP_LNKCAP_SLS_5_0GB)\r\n*mask |= (DRM_PCIE_SPEED_25 | DRM_PCIE_SPEED_50);\r\n}\r\nDRM_INFO("probing gen 2 caps for device %x:%x = %x/%x\n", root->vendor, root->device, lnkcap, lnkcap2);\r\nreturn 0;\r\n}\r\nint drm_pci_init(struct drm_driver *driver, struct pci_driver *pdriver)\r\n{\r\nreturn -1;\r\n}\r\nvoid drm_pci_agp_destroy(struct drm_device *dev) {}\r\nint drm_irq_by_busid(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nreturn -EINVAL;\r\n}\r\nint drm_pci_set_unique(struct drm_device *dev,\r\nstruct drm_master *master,\r\nstruct drm_unique *u)\r\n{\r\nreturn -EINVAL;\r\n}\r\nvoid drm_pci_exit(struct drm_driver *driver, struct pci_driver *pdriver)\r\n{\r\nstruct drm_device *dev, *tmp;\r\nDRM_DEBUG("\n");\r\nif (driver->driver_features & DRIVER_MODESET) {\r\npci_unregister_driver(pdriver);\r\n} else {\r\nlist_for_each_entry_safe(dev, tmp, &driver->legacy_dev_list,\r\nlegacy_dev_list) {\r\nlist_del(&dev->legacy_dev_list);\r\ndrm_put_dev(dev);\r\n}\r\n}\r\nDRM_INFO("Module unloaded\n");\r\n}
