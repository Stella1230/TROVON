static void __import_set_state(struct obd_import *imp,\r\nenum lustre_imp_state state)\r\n{\r\nimp->imp_state = state;\r\nimp->imp_state_hist[imp->imp_state_hist_idx].ish_state = state;\r\nimp->imp_state_hist[imp->imp_state_hist_idx].ish_time =\r\nget_seconds();\r\nimp->imp_state_hist_idx = (imp->imp_state_hist_idx + 1) %\r\nIMP_STATE_HIST_LEN;\r\n}\r\nint ptlrpc_init_import(struct obd_import *imp)\r\n{\r\nspin_lock(&imp->imp_lock);\r\nimp->imp_generation++;\r\nimp->imp_state = LUSTRE_IMP_NEW;\r\nspin_unlock(&imp->imp_lock);\r\nreturn 0;\r\n}\r\nvoid deuuidify(char *uuid, const char *prefix, char **uuid_start, int *uuid_len)\r\n{\r\n*uuid_start = !prefix || strncmp(uuid, prefix, strlen(prefix))\r\n? uuid : uuid + strlen(prefix);\r\n*uuid_len = strlen(*uuid_start);\r\nif (*uuid_len < strlen(UUID_STR))\r\nreturn;\r\nif (!strncmp(*uuid_start + *uuid_len - strlen(UUID_STR),\r\nUUID_STR, strlen(UUID_STR)))\r\n*uuid_len -= strlen(UUID_STR);\r\n}\r\nint ptlrpc_set_import_discon(struct obd_import *imp, __u32 conn_cnt)\r\n{\r\nint rc = 0;\r\nspin_lock(&imp->imp_lock);\r\nif (imp->imp_state == LUSTRE_IMP_FULL &&\r\n(conn_cnt == 0 || conn_cnt == imp->imp_conn_cnt)) {\r\nchar *target_start;\r\nint target_len;\r\ndeuuidify(obd2cli_tgt(imp->imp_obd), NULL,\r\n&target_start, &target_len);\r\nif (imp->imp_replayable) {\r\nLCONSOLE_WARN("%s: Connection to %.*s (at %s) was lost; in progress operations using this service will wait for recovery to complete\n",\r\nimp->imp_obd->obd_name, target_len, target_start,\r\nlibcfs_nid2str(imp->imp_connection->c_peer.nid));\r\n} else {\r\nLCONSOLE_ERROR_MSG(0x166, "%s: Connection to %.*s (at %s) was lost; in progress operations using this service will fail\n",\r\nimp->imp_obd->obd_name,\r\ntarget_len, target_start,\r\nlibcfs_nid2str(imp->imp_connection->c_peer.nid));\r\n}\r\nIMPORT_SET_STATE_NOLOCK(imp, LUSTRE_IMP_DISCON);\r\nspin_unlock(&imp->imp_lock);\r\nif (obd_dump_on_timeout)\r\nlibcfs_debug_dumplog();\r\nobd_import_event(imp->imp_obd, imp, IMP_EVENT_DISCON);\r\nrc = 1;\r\n} else {\r\nspin_unlock(&imp->imp_lock);\r\nCDEBUG(D_HA, "%s: import %p already %s (conn %u, was %u): %s\n",\r\nimp->imp_client->cli_name, imp,\r\n(imp->imp_state == LUSTRE_IMP_FULL &&\r\nimp->imp_conn_cnt > conn_cnt) ?\r\n"reconnected" : "not connected", imp->imp_conn_cnt,\r\nconn_cnt, ptlrpc_import_state_name(imp->imp_state));\r\n}\r\nreturn rc;\r\n}\r\nstatic void ptlrpc_deactivate_and_unlock_import(struct obd_import *imp)\r\n{\r\nassert_spin_locked(&imp->imp_lock);\r\nCDEBUG(D_HA, "setting import %s INVALID\n", obd2cli_tgt(imp->imp_obd));\r\nimp->imp_invalid = 1;\r\nimp->imp_generation++;\r\nspin_unlock(&imp->imp_lock);\r\nptlrpc_abort_inflight(imp);\r\nobd_import_event(imp->imp_obd, imp, IMP_EVENT_INACTIVE);\r\n}\r\nvoid ptlrpc_deactivate_import(struct obd_import *imp)\r\n{\r\nspin_lock(&imp->imp_lock);\r\nptlrpc_deactivate_and_unlock_import(imp);\r\n}\r\nstatic unsigned int\r\nptlrpc_inflight_deadline(struct ptlrpc_request *req, time_t now)\r\n{\r\nlong dl;\r\nif (!(((req->rq_phase == RQ_PHASE_RPC) && !req->rq_waiting) ||\r\n(req->rq_phase == RQ_PHASE_BULK) ||\r\n(req->rq_phase == RQ_PHASE_NEW)))\r\nreturn 0;\r\nif (req->rq_timedout)\r\nreturn 0;\r\nif (req->rq_phase == RQ_PHASE_NEW)\r\ndl = req->rq_sent;\r\nelse\r\ndl = req->rq_deadline;\r\nif (dl <= now)\r\nreturn 0;\r\nreturn dl - now;\r\n}\r\nstatic unsigned int ptlrpc_inflight_timeout(struct obd_import *imp)\r\n{\r\ntime_t now = get_seconds();\r\nstruct list_head *tmp, *n;\r\nstruct ptlrpc_request *req;\r\nunsigned int timeout = 0;\r\nspin_lock(&imp->imp_lock);\r\nlist_for_each_safe(tmp, n, &imp->imp_sending_list) {\r\nreq = list_entry(tmp, struct ptlrpc_request, rq_list);\r\ntimeout = max(ptlrpc_inflight_deadline(req, now), timeout);\r\n}\r\nspin_unlock(&imp->imp_lock);\r\nreturn timeout;\r\n}\r\nvoid ptlrpc_invalidate_import(struct obd_import *imp)\r\n{\r\nstruct list_head *tmp, *n;\r\nstruct ptlrpc_request *req;\r\nstruct l_wait_info lwi;\r\nunsigned int timeout;\r\nint rc;\r\natomic_inc(&imp->imp_inval_count);\r\nif (!imp->imp_invalid || imp->imp_obd->obd_no_recov)\r\nptlrpc_deactivate_import(imp);\r\nCFS_FAIL_TIMEOUT(OBD_FAIL_MGS_CONNECT_NET, 3 * cfs_fail_val / 2);\r\nLASSERT(imp->imp_invalid);\r\ndo {\r\nif (!OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_LONG_REPL_UNLINK)) {\r\ntimeout = ptlrpc_inflight_timeout(imp);\r\ntimeout += timeout / 3;\r\nif (timeout == 0)\r\ntimeout = obd_timeout;\r\n} else {\r\ntimeout = 1;\r\n}\r\nCDEBUG(D_RPCTRACE,\r\n"Sleeping %d sec for inflight to error out\n",\r\ntimeout);\r\nlwi = LWI_TIMEOUT_INTERVAL(\r\ncfs_timeout_cap(cfs_time_seconds(timeout)),\r\n(timeout > 1)?cfs_time_seconds(1):cfs_time_seconds(1)/2,\r\nNULL, NULL);\r\nrc = l_wait_event(imp->imp_recovery_waitq,\r\n(atomic_read(&imp->imp_inflight) == 0),\r\n&lwi);\r\nif (rc) {\r\nconst char *cli_tgt = obd2cli_tgt(imp->imp_obd);\r\nCERROR("%s: rc = %d waiting for callback (%d != 0)\n",\r\ncli_tgt, rc,\r\natomic_read(&imp->imp_inflight));\r\nspin_lock(&imp->imp_lock);\r\nif (atomic_read(&imp->imp_inflight) == 0) {\r\nint count = atomic_read(&imp->imp_unregistering);\r\nLASSERTF(count == 0, "Some RPCs are still unregistering: %d\n",\r\ncount);\r\nrc = 0;\r\n} else {\r\nlist_for_each_safe(tmp, n,\r\n&imp->imp_sending_list) {\r\nreq = list_entry(tmp,\r\nstruct ptlrpc_request,\r\nrq_list);\r\nDEBUG_REQ(D_ERROR, req,\r\n"still on sending list");\r\n}\r\nlist_for_each_safe(tmp, n,\r\n&imp->imp_delayed_list) {\r\nreq = list_entry(tmp,\r\nstruct ptlrpc_request,\r\nrq_list);\r\nDEBUG_REQ(D_ERROR, req,\r\n"still on delayed list");\r\n}\r\nCERROR("%s: RPCs in \"%s\" phase found (%d). Network is sluggish? Waiting them to error out.\n",\r\ncli_tgt,\r\nptlrpc_phase2str(RQ_PHASE_UNREGISTERING),\r\natomic_read(&imp->\r\nimp_unregistering));\r\n}\r\nspin_unlock(&imp->imp_lock);\r\n}\r\n} while (rc != 0);\r\nLASSERT(atomic_read(&imp->imp_inflight) == 0);\r\nobd_import_event(imp->imp_obd, imp, IMP_EVENT_INVALIDATE);\r\nsptlrpc_import_flush_all_ctx(imp);\r\natomic_dec(&imp->imp_inval_count);\r\nwake_up_all(&imp->imp_recovery_waitq);\r\n}\r\nvoid ptlrpc_activate_import(struct obd_import *imp)\r\n{\r\nstruct obd_device *obd = imp->imp_obd;\r\nspin_lock(&imp->imp_lock);\r\nif (imp->imp_deactive != 0) {\r\nspin_unlock(&imp->imp_lock);\r\nreturn;\r\n}\r\nimp->imp_invalid = 0;\r\nspin_unlock(&imp->imp_lock);\r\nobd_import_event(obd, imp, IMP_EVENT_ACTIVE);\r\n}\r\nstatic void ptlrpc_pinger_force(struct obd_import *imp)\r\n{\r\nCDEBUG(D_HA, "%s: waking up pinger s:%s\n", obd2cli_tgt(imp->imp_obd),\r\nptlrpc_import_state_name(imp->imp_state));\r\nspin_lock(&imp->imp_lock);\r\nimp->imp_force_verify = 1;\r\nspin_unlock(&imp->imp_lock);\r\nif (imp->imp_state != LUSTRE_IMP_CONNECTING)\r\nptlrpc_pinger_wake_up();\r\n}\r\nvoid ptlrpc_fail_import(struct obd_import *imp, __u32 conn_cnt)\r\n{\r\nLASSERT(!imp->imp_dlm_fake);\r\nif (ptlrpc_set_import_discon(imp, conn_cnt)) {\r\nif (!imp->imp_replayable) {\r\nCDEBUG(D_HA, "import %s@%s for %s not replayable, auto-deactivating\n",\r\nobd2cli_tgt(imp->imp_obd),\r\nimp->imp_connection->c_remote_uuid.uuid,\r\nimp->imp_obd->obd_name);\r\nptlrpc_deactivate_import(imp);\r\n}\r\nptlrpc_pinger_force(imp);\r\n}\r\n}\r\nint ptlrpc_reconnect_import(struct obd_import *imp)\r\n{\r\n#ifdef ENABLE_PINGER\r\nstruct l_wait_info lwi;\r\nint secs = cfs_time_seconds(obd_timeout);\r\nint rc;\r\nptlrpc_pinger_force(imp);\r\nCDEBUG(D_HA, "%s: recovery started, waiting %u seconds\n",\r\nobd2cli_tgt(imp->imp_obd), secs);\r\nlwi = LWI_TIMEOUT(secs, NULL, NULL);\r\nrc = l_wait_event(imp->imp_recovery_waitq,\r\n!ptlrpc_import_in_recovery(imp), &lwi);\r\nCDEBUG(D_HA, "%s: recovery finished s:%s\n", obd2cli_tgt(imp->imp_obd),\r\nptlrpc_import_state_name(imp->imp_state));\r\nreturn rc;\r\n#else\r\nptlrpc_set_import_discon(imp, 0);\r\nptlrpc_invalidate_import(imp);\r\nptlrpc_disconnect_import(imp, 1);\r\nif (atomic_read(&imp->imp_inval_count) > 0) {\r\nint rc;\r\nstruct l_wait_info lwi = LWI_INTR(LWI_ON_SIGNAL_NOOP, NULL);\r\nrc = l_wait_event(imp->imp_recovery_waitq,\r\n(atomic_read(&imp->imp_inval_count) == 0),\r\n&lwi);\r\nif (rc)\r\nCERROR("Interrupted, inval=%d\n",\r\natomic_read(&imp->imp_inval_count));\r\n}\r\nimp->imp_obd->obd_no_recov = 0;\r\nptlrpc_activate_import(imp);\r\nptlrpc_recover_import(imp, NULL, 0);\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int import_select_connection(struct obd_import *imp)\r\n{\r\nstruct obd_import_conn *imp_conn = NULL, *conn;\r\nstruct obd_export *dlmexp;\r\nchar *target_start;\r\nint target_len, tried_all = 1;\r\nspin_lock(&imp->imp_lock);\r\nif (list_empty(&imp->imp_conn_list)) {\r\nCERROR("%s: no connections available\n",\r\nimp->imp_obd->obd_name);\r\nspin_unlock(&imp->imp_lock);\r\nreturn -EINVAL;\r\n}\r\nlist_for_each_entry(conn, &imp->imp_conn_list, oic_item) {\r\nCDEBUG(D_HA, "%s: connect to NID %s last attempt %llu\n",\r\nimp->imp_obd->obd_name,\r\nlibcfs_nid2str(conn->oic_conn->c_peer.nid),\r\nconn->oic_last_attempt);\r\nif ((conn->oic_last_attempt == 0) ||\r\ncfs_time_beforeq_64(conn->oic_last_attempt,\r\nimp->imp_last_success_conn)) {\r\nimp_conn = conn;\r\ntried_all = 0;\r\nbreak;\r\n}\r\nif (!imp_conn)\r\nimp_conn = conn;\r\nelse if (cfs_time_before_64(conn->oic_last_attempt,\r\nimp_conn->oic_last_attempt))\r\nimp_conn = conn;\r\n}\r\nif (!imp_conn || imp->imp_force_reconnect) {\r\nLASSERT(imp->imp_conn_current);\r\nimp_conn = imp->imp_conn_current;\r\ntried_all = 0;\r\n}\r\nLASSERT(imp_conn->oic_conn);\r\nif (tried_all && (imp->imp_conn_list.next == &imp_conn->oic_item)) {\r\nstruct adaptive_timeout *at = &imp->imp_at.iat_net_latency;\r\nif (at_get(at) < CONNECTION_SWITCH_MAX) {\r\nat_measured(at, at_get(at) + CONNECTION_SWITCH_INC);\r\nif (at_get(at) > CONNECTION_SWITCH_MAX)\r\nat_reset(at, CONNECTION_SWITCH_MAX);\r\n}\r\nLASSERT(imp_conn->oic_last_attempt);\r\nCDEBUG(D_HA, "%s: tried all connections, increasing latency to %ds\n",\r\nimp->imp_obd->obd_name, at_get(at));\r\n}\r\nimp_conn->oic_last_attempt = cfs_time_current_64();\r\nif (imp->imp_connection)\r\nptlrpc_connection_put(imp->imp_connection);\r\nimp->imp_connection = ptlrpc_connection_addref(imp_conn->oic_conn);\r\ndlmexp = class_conn2export(&imp->imp_dlm_handle);\r\nLASSERT(dlmexp != NULL);\r\nif (dlmexp->exp_connection)\r\nptlrpc_connection_put(dlmexp->exp_connection);\r\ndlmexp->exp_connection = ptlrpc_connection_addref(imp_conn->oic_conn);\r\nclass_export_put(dlmexp);\r\nif (imp->imp_conn_current != imp_conn) {\r\nif (imp->imp_conn_current) {\r\ndeuuidify(obd2cli_tgt(imp->imp_obd), NULL,\r\n&target_start, &target_len);\r\nCDEBUG(D_HA, "%s: Connection changing to %.*s (at %s)\n",\r\nimp->imp_obd->obd_name,\r\ntarget_len, target_start,\r\nlibcfs_nid2str(imp_conn->oic_conn->c_peer.nid));\r\n}\r\nimp->imp_conn_current = imp_conn;\r\n}\r\nCDEBUG(D_HA, "%s: import %p using connection %s/%s\n",\r\nimp->imp_obd->obd_name, imp, imp_conn->oic_uuid.uuid,\r\nlibcfs_nid2str(imp_conn->oic_conn->c_peer.nid));\r\nspin_unlock(&imp->imp_lock);\r\nreturn 0;\r\n}\r\nstatic int ptlrpc_first_transno(struct obd_import *imp, __u64 *transno)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct list_head *tmp;\r\nif (!list_empty(&imp->imp_committed_list)) {\r\ntmp = imp->imp_committed_list.next;\r\nreq = list_entry(tmp, struct ptlrpc_request, rq_replay_list);\r\n*transno = req->rq_transno;\r\nif (req->rq_transno == 0) {\r\nDEBUG_REQ(D_ERROR, req,\r\n"zero transno in committed_list");\r\nLBUG();\r\n}\r\nreturn 1;\r\n}\r\nif (!list_empty(&imp->imp_replay_list)) {\r\ntmp = imp->imp_replay_list.next;\r\nreq = list_entry(tmp, struct ptlrpc_request, rq_replay_list);\r\n*transno = req->rq_transno;\r\nif (req->rq_transno == 0) {\r\nDEBUG_REQ(D_ERROR, req, "zero transno in replay_list");\r\nLBUG();\r\n}\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint ptlrpc_connect_import(struct obd_import *imp)\r\n{\r\nstruct obd_device *obd = imp->imp_obd;\r\nint initial_connect = 0;\r\nint set_transno = 0;\r\n__u64 committed_before_reconnect = 0;\r\nstruct ptlrpc_request *request;\r\nchar *bufs[] = { NULL,\r\nobd2cli_tgt(imp->imp_obd),\r\nobd->obd_uuid.uuid,\r\n(char *)&imp->imp_dlm_handle,\r\n(char *)&imp->imp_connect_data };\r\nstruct ptlrpc_connect_async_args *aa;\r\nint rc;\r\nspin_lock(&imp->imp_lock);\r\nif (imp->imp_state == LUSTRE_IMP_CLOSED) {\r\nspin_unlock(&imp->imp_lock);\r\nCERROR("can't connect to a closed import\n");\r\nreturn -EINVAL;\r\n} else if (imp->imp_state == LUSTRE_IMP_FULL) {\r\nspin_unlock(&imp->imp_lock);\r\nCERROR("already connected\n");\r\nreturn 0;\r\n} else if (imp->imp_state == LUSTRE_IMP_CONNECTING) {\r\nspin_unlock(&imp->imp_lock);\r\nCERROR("already connecting\n");\r\nreturn -EALREADY;\r\n}\r\nIMPORT_SET_STATE_NOLOCK(imp, LUSTRE_IMP_CONNECTING);\r\nimp->imp_conn_cnt++;\r\nimp->imp_resend_replay = 0;\r\nif (!lustre_handle_is_used(&imp->imp_remote_handle))\r\ninitial_connect = 1;\r\nelse\r\ncommitted_before_reconnect = imp->imp_peer_committed_transno;\r\nset_transno = ptlrpc_first_transno(imp,\r\n&imp->imp_connect_data.ocd_transno);\r\nspin_unlock(&imp->imp_lock);\r\nrc = import_select_connection(imp);\r\nif (rc)\r\ngoto out;\r\nrc = sptlrpc_import_sec_adapt(imp, NULL, NULL);\r\nif (rc)\r\ngoto out;\r\nimp->imp_connect_data.ocd_connect_flags = imp->imp_connect_flags_orig;\r\nimp->imp_connect_data.ocd_version = LUSTRE_VERSION_CODE;\r\nimp->imp_msghdr_flags &= ~MSGHDR_AT_SUPPORT;\r\nimp->imp_msghdr_flags &= ~MSGHDR_CKSUM_INCOMPAT18;\r\nrc = obd_reconnect(NULL, imp->imp_obd->obd_self_export, obd,\r\n&obd->obd_uuid, &imp->imp_connect_data, NULL);\r\nif (rc)\r\ngoto out;\r\nrequest = ptlrpc_request_alloc(imp, &RQF_MDS_CONNECT);\r\nif (request == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nrc = ptlrpc_request_bufs_pack(request, LUSTRE_OBD_VERSION,\r\nimp->imp_connect_op, bufs, NULL);\r\nif (rc) {\r\nptlrpc_request_free(request);\r\ngoto out;\r\n}\r\nlustre_msg_set_service_time(request->rq_reqmsg,\r\nat_timeout2est(request->rq_timeout));\r\nrequest->rq_timeout = INITIAL_CONNECT_TIMEOUT;\r\nlustre_msg_set_timeout(request->rq_reqmsg, request->rq_timeout);\r\nlustre_msg_add_op_flags(request->rq_reqmsg, MSG_CONNECT_NEXT_VER);\r\nrequest->rq_no_resend = request->rq_no_delay = 1;\r\nrequest->rq_send_state = LUSTRE_IMP_CONNECTING;\r\nreq_capsule_set_size(&request->rq_pill, &RMF_CONNECT_DATA, RCL_SERVER,\r\nsizeof(struct obd_connect_data)+16*sizeof(__u64));\r\nptlrpc_request_set_replen(request);\r\nrequest->rq_interpret_reply = ptlrpc_connect_interpret;\r\nCLASSERT(sizeof(*aa) <= sizeof(request->rq_async_args));\r\naa = ptlrpc_req_async_args(request);\r\nmemset(aa, 0, sizeof(*aa));\r\naa->pcaa_peer_committed = committed_before_reconnect;\r\naa->pcaa_initial_connect = initial_connect;\r\nif (aa->pcaa_initial_connect) {\r\nspin_lock(&imp->imp_lock);\r\nimp->imp_replayable = 1;\r\nspin_unlock(&imp->imp_lock);\r\nlustre_msg_add_op_flags(request->rq_reqmsg,\r\nMSG_CONNECT_INITIAL);\r\n}\r\nif (set_transno)\r\nlustre_msg_add_op_flags(request->rq_reqmsg,\r\nMSG_CONNECT_TRANSNO);\r\nDEBUG_REQ(D_RPCTRACE, request, "(re)connect request (timeout %d)",\r\nrequest->rq_timeout);\r\nptlrpcd_add_req(request, PDL_POLICY_ROUND, -1);\r\nrc = 0;\r\nout:\r\nif (rc != 0) {\r\nIMPORT_SET_STATE(imp, LUSTRE_IMP_DISCON);\r\n}\r\nreturn rc;\r\n}\r\nstatic void ptlrpc_maybe_ping_import_soon(struct obd_import *imp)\r\n{\r\nint force_verify;\r\nspin_lock(&imp->imp_lock);\r\nforce_verify = imp->imp_force_verify != 0;\r\nspin_unlock(&imp->imp_lock);\r\nif (force_verify)\r\nptlrpc_pinger_wake_up();\r\n}\r\nstatic int ptlrpc_busy_reconnect(int rc)\r\n{\r\nreturn (rc == -EBUSY) || (rc == -EAGAIN);\r\n}\r\nstatic int ptlrpc_connect_interpret(const struct lu_env *env,\r\nstruct ptlrpc_request *request,\r\nvoid *data, int rc)\r\n{\r\nstruct ptlrpc_connect_async_args *aa = data;\r\nstruct obd_import *imp = request->rq_import;\r\nstruct client_obd *cli = &imp->imp_obd->u.cli;\r\nstruct lustre_handle old_hdl;\r\n__u64 old_connect_flags;\r\nint msg_flags;\r\nstruct obd_connect_data *ocd;\r\nstruct obd_export *exp;\r\nint ret;\r\nspin_lock(&imp->imp_lock);\r\nif (imp->imp_state == LUSTRE_IMP_CLOSED) {\r\nimp->imp_connect_tried = 1;\r\nspin_unlock(&imp->imp_lock);\r\nreturn 0;\r\n}\r\nif (rc) {\r\nimp->imp_force_reconnect = ptlrpc_busy_reconnect(rc);\r\nspin_unlock(&imp->imp_lock);\r\nptlrpc_maybe_ping_import_soon(imp);\r\ngoto out;\r\n}\r\nspin_unlock(&imp->imp_lock);\r\nLASSERT(imp->imp_conn_current);\r\nmsg_flags = lustre_msg_get_op_flags(request->rq_repmsg);\r\nret = req_capsule_get_size(&request->rq_pill, &RMF_CONNECT_DATA,\r\nRCL_SERVER);\r\nocd = req_capsule_server_sized_get(&request->rq_pill,\r\n&RMF_CONNECT_DATA, ret);\r\nif (ocd == NULL) {\r\nCERROR("%s: no connect data from server\n",\r\nimp->imp_obd->obd_name);\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\nspin_lock(&imp->imp_lock);\r\nimp->imp_pingable = 1;\r\nimp->imp_force_reconnect = 0;\r\nimp->imp_force_verify = 0;\r\nimp->imp_connect_data = *ocd;\r\nCDEBUG(D_HA, "%s: connect to target with instance %u\n",\r\nimp->imp_obd->obd_name, ocd->ocd_instance);\r\nexp = class_conn2export(&imp->imp_dlm_handle);\r\nspin_unlock(&imp->imp_lock);\r\nif ((ocd->ocd_connect_flags & imp->imp_connect_flags_orig) !=\r\nocd->ocd_connect_flags) {\r\nCERROR("%s: Server didn't granted asked subset of flags: asked=%#llx grranted=%#llx\n",\r\nimp->imp_obd->obd_name, imp->imp_connect_flags_orig,\r\nocd->ocd_connect_flags);\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\nif (!exp) {\r\nCERROR("%s: missing export after connect\n",\r\nimp->imp_obd->obd_name);\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nold_connect_flags = exp_connect_flags(exp);\r\nexp->exp_connect_data = *ocd;\r\nimp->imp_obd->obd_self_export->exp_connect_data = *ocd;\r\nclass_export_put(exp);\r\nobd_import_event(imp->imp_obd, imp, IMP_EVENT_OCD);\r\nif (aa->pcaa_initial_connect) {\r\nspin_lock(&imp->imp_lock);\r\nif (msg_flags & MSG_CONNECT_REPLAYABLE) {\r\nimp->imp_replayable = 1;\r\nspin_unlock(&imp->imp_lock);\r\nCDEBUG(D_HA, "connected to replayable target: %s\n",\r\nobd2cli_tgt(imp->imp_obd));\r\n} else {\r\nimp->imp_replayable = 0;\r\nspin_unlock(&imp->imp_lock);\r\n}\r\nimp->imp_remote_handle =\r\n*lustre_msg_get_handle(request->rq_repmsg);\r\nif (msg_flags & MSG_CONNECT_RECOVERING) {\r\nCDEBUG(D_HA, "connect to %s during recovery\n",\r\nobd2cli_tgt(imp->imp_obd));\r\nIMPORT_SET_STATE(imp, LUSTRE_IMP_REPLAY_LOCKS);\r\n} else {\r\nIMPORT_SET_STATE(imp, LUSTRE_IMP_FULL);\r\nptlrpc_activate_import(imp);\r\n}\r\nrc = 0;\r\ngoto finish;\r\n}\r\nif (MSG_CONNECT_RECONNECT & msg_flags) {\r\nmemset(&old_hdl, 0, sizeof(old_hdl));\r\nif (!memcmp(&old_hdl, lustre_msg_get_handle(request->rq_repmsg),\r\nsizeof(old_hdl))) {\r\nLCONSOLE_WARN("Reconnect to %s (at @%s) failed due bad handle %#llx\n",\r\nobd2cli_tgt(imp->imp_obd),\r\nimp->imp_connection->c_remote_uuid.uuid,\r\nimp->imp_dlm_handle.cookie);\r\nrc = -ENOTCONN;\r\ngoto out;\r\n}\r\nif (memcmp(&imp->imp_remote_handle,\r\nlustre_msg_get_handle(request->rq_repmsg),\r\nsizeof(imp->imp_remote_handle))) {\r\nint level = msg_flags & MSG_CONNECT_RECOVERING ?\r\nD_HA : D_WARNING;\r\nif ((MSG_CONNECT_RECOVERING & msg_flags)) {\r\nCDEBUG(level, "%s@%s changed server handle from %#llx to %#llx but is still in recovery\n",\r\nobd2cli_tgt(imp->imp_obd),\r\nimp->imp_connection->c_remote_uuid.uuid,\r\nimp->imp_remote_handle.cookie,\r\nlustre_msg_get_handle(\r\nrequest->rq_repmsg)->cookie);\r\n} else {\r\nLCONSOLE_WARN("Evicted from %s (at %s) after server handle changed from %#llx to %#llx\n",\r\nobd2cli_tgt(imp->imp_obd),\r\nimp->imp_connection-> \\r\nc_remote_uuid.uuid,\r\nimp->imp_remote_handle.cookie,\r\nlustre_msg_get_handle(\r\nrequest->rq_repmsg)->cookie);\r\n}\r\nimp->imp_remote_handle =\r\n*lustre_msg_get_handle(request->rq_repmsg);\r\nif (!(MSG_CONNECT_RECOVERING & msg_flags)) {\r\nIMPORT_SET_STATE(imp, LUSTRE_IMP_EVICTED);\r\nrc = 0;\r\ngoto finish;\r\n}\r\n} else {\r\nCDEBUG(D_HA, "reconnected to %s@%s after partition\n",\r\nobd2cli_tgt(imp->imp_obd),\r\nimp->imp_connection->c_remote_uuid.uuid);\r\n}\r\nif (imp->imp_invalid) {\r\nCDEBUG(D_HA, "%s: reconnected but import is invalid; marking evicted\n",\r\nimp->imp_obd->obd_name);\r\nIMPORT_SET_STATE(imp, LUSTRE_IMP_EVICTED);\r\n} else if (MSG_CONNECT_RECOVERING & msg_flags) {\r\nCDEBUG(D_HA, "%s: reconnected to %s during replay\n",\r\nimp->imp_obd->obd_name,\r\nobd2cli_tgt(imp->imp_obd));\r\nspin_lock(&imp->imp_lock);\r\nimp->imp_resend_replay = 1;\r\nspin_unlock(&imp->imp_lock);\r\nIMPORT_SET_STATE(imp, LUSTRE_IMP_REPLAY);\r\n} else {\r\nIMPORT_SET_STATE(imp, LUSTRE_IMP_RECOVER);\r\n}\r\n} else if ((MSG_CONNECT_RECOVERING & msg_flags) && !imp->imp_invalid) {\r\nLASSERT(imp->imp_replayable);\r\nimp->imp_remote_handle =\r\n*lustre_msg_get_handle(request->rq_repmsg);\r\nimp->imp_last_replay_transno = 0;\r\nIMPORT_SET_STATE(imp, LUSTRE_IMP_REPLAY);\r\n} else {\r\nDEBUG_REQ(D_HA, request, "%s: evicting (reconnect/recover flags not set: %x)",\r\nimp->imp_obd->obd_name, msg_flags);\r\nimp->imp_remote_handle =\r\n*lustre_msg_get_handle(request->rq_repmsg);\r\nIMPORT_SET_STATE(imp, LUSTRE_IMP_EVICTED);\r\n}\r\nif (!(imp->imp_replayable) != !(msg_flags & MSG_CONNECT_REPLAYABLE)) {\r\nCERROR("imp_replayable flag does not match server after reconnect. We should LBUG right here.\n");\r\n}\r\nif (lustre_msg_get_last_committed(request->rq_repmsg) > 0 &&\r\nlustre_msg_get_last_committed(request->rq_repmsg) <\r\naa->pcaa_peer_committed) {\r\nCERROR("%s went back in time (transno %lld was previously committed, server now claims %lld)! See https://bugzilla.lustre.org/show_bug.cgi?id=9646\n",\r\nobd2cli_tgt(imp->imp_obd), aa->pcaa_peer_committed,\r\nlustre_msg_get_last_committed(request->rq_repmsg));\r\n}\r\nfinish:\r\nrc = ptlrpc_import_recovery_state_machine(imp);\r\nif (rc != 0) {\r\nif (rc == -ENOTCONN) {\r\nCDEBUG(D_HA, "evicted/aborted by %s@%s during recovery; invalidating and reconnecting\n",\r\nobd2cli_tgt(imp->imp_obd),\r\nimp->imp_connection->c_remote_uuid.uuid);\r\nptlrpc_connect_import(imp);\r\nimp->imp_connect_tried = 1;\r\nreturn 0;\r\n}\r\n} else {\r\nspin_lock(&imp->imp_lock);\r\nlist_del(&imp->imp_conn_current->oic_item);\r\nlist_add(&imp->imp_conn_current->oic_item,\r\n&imp->imp_conn_list);\r\nimp->imp_last_success_conn =\r\nimp->imp_conn_current->oic_last_attempt;\r\nspin_unlock(&imp->imp_lock);\r\nif ((imp->imp_connect_flags_orig & OBD_CONNECT_IBITS) &&\r\n!(ocd->ocd_connect_flags & OBD_CONNECT_IBITS)) {\r\nLCONSOLE_WARN("%s: MDS %s does not support ibits lock, either very old or invalid: requested %llx, replied %llx\n",\r\nimp->imp_obd->obd_name,\r\nimp->imp_connection->c_remote_uuid.uuid,\r\nimp->imp_connect_flags_orig,\r\nocd->ocd_connect_flags);\r\nrc = -EPROTO;\r\ngoto out;\r\n}\r\nif ((ocd->ocd_connect_flags & OBD_CONNECT_VERSION) &&\r\n(ocd->ocd_version > LUSTRE_VERSION_CODE +\r\nLUSTRE_VERSION_OFFSET_WARN ||\r\nocd->ocd_version < LUSTRE_VERSION_CODE -\r\nLUSTRE_VERSION_OFFSET_WARN)) {\r\nconst char *older = "older. Consider upgrading server or downgrading client"\r\n;\r\nconst char *newer = "newer than client version. Consider upgrading client"\r\n;\r\nLCONSOLE_WARN("Server %s version (%d.%d.%d.%d) is much %s (%s)\n",\r\nobd2cli_tgt(imp->imp_obd),\r\nOBD_OCD_VERSION_MAJOR(ocd->ocd_version),\r\nOBD_OCD_VERSION_MINOR(ocd->ocd_version),\r\nOBD_OCD_VERSION_PATCH(ocd->ocd_version),\r\nOBD_OCD_VERSION_FIX(ocd->ocd_version),\r\nocd->ocd_version > LUSTRE_VERSION_CODE ?\r\nnewer : older, LUSTRE_VERSION_STRING);\r\n}\r\n#if LUSTRE_VERSION_CODE < OBD_OCD_VERSION(3, 2, 50, 0)\r\nif (unlikely((ocd->ocd_connect_flags & OBD_CONNECT_VERSION) &&\r\n!(ocd->ocd_connect_flags & OBD_CONNECT_MNE_SWAB) &&\r\nOBD_OCD_VERSION_MAJOR(ocd->ocd_version) == 2 &&\r\nOBD_OCD_VERSION_MINOR(ocd->ocd_version) == 2 &&\r\nOBD_OCD_VERSION_PATCH(ocd->ocd_version) < 55 &&\r\nstrcmp(imp->imp_obd->obd_type->typ_name,\r\nLUSTRE_MGC_NAME) == 0))\r\nimp->imp_need_mne_swab = 1;\r\nelse\r\nimp->imp_need_mne_swab = 0;\r\n#else\r\n#warning "LU-1644: Remove old OBD_CONNECT_MNE_SWAB fixup and imp_need_mne_swab"\r\n#endif\r\nif (ocd->ocd_connect_flags & OBD_CONNECT_CKSUM) {\r\nif ((ocd->ocd_cksum_types &\r\ncksum_types_supported_client()) == 0) {\r\nLCONSOLE_WARN("The negotiation of the checksum algorithm to use with server %s failed (%x/%x), disabling checksums\n",\r\nobd2cli_tgt(imp->imp_obd),\r\nocd->ocd_cksum_types,\r\ncksum_types_supported_client());\r\ncli->cl_checksum = 0;\r\ncli->cl_supp_cksum_types = OBD_CKSUM_ADLER;\r\n} else {\r\ncli->cl_supp_cksum_types = ocd->ocd_cksum_types;\r\n}\r\n} else {\r\ncli->cl_supp_cksum_types = OBD_CKSUM_ADLER;\r\n}\r\ncli->cl_cksum_type = cksum_type_select(cli->cl_supp_cksum_types);\r\nif (ocd->ocd_connect_flags & OBD_CONNECT_BRW_SIZE)\r\ncli->cl_max_pages_per_rpc =\r\nmin(ocd->ocd_brw_size >> PAGE_CACHE_SHIFT,\r\ncli->cl_max_pages_per_rpc);\r\nelse if (imp->imp_connect_op == MDS_CONNECT ||\r\nimp->imp_connect_op == MGS_CONNECT)\r\ncli->cl_max_pages_per_rpc = 1;\r\nif (old_connect_flags != exp_connect_flags(exp) ||\r\naa->pcaa_initial_connect) {\r\nCDEBUG(D_HA, "%s: Resetting ns_connect_flags to server flags: %#llx\n",\r\nimp->imp_obd->obd_name, ocd->ocd_connect_flags);\r\nimp->imp_obd->obd_namespace->ns_connect_flags =\r\nocd->ocd_connect_flags;\r\nimp->imp_obd->obd_namespace->ns_orig_connect_flags =\r\nocd->ocd_connect_flags;\r\n}\r\nif ((ocd->ocd_connect_flags & OBD_CONNECT_AT) &&\r\n(imp->imp_msg_magic == LUSTRE_MSG_MAGIC_V2))\r\nimp->imp_msghdr_flags |= MSGHDR_AT_SUPPORT;\r\nelse\r\nimp->imp_msghdr_flags &= ~MSGHDR_AT_SUPPORT;\r\nif ((ocd->ocd_connect_flags & OBD_CONNECT_FULL20) &&\r\n(imp->imp_msg_magic == LUSTRE_MSG_MAGIC_V2))\r\nimp->imp_msghdr_flags |= MSGHDR_CKSUM_INCOMPAT18;\r\nelse\r\nimp->imp_msghdr_flags &= ~MSGHDR_CKSUM_INCOMPAT18;\r\nLASSERT((cli->cl_max_pages_per_rpc <= PTLRPC_MAX_BRW_PAGES) &&\r\n(cli->cl_max_pages_per_rpc > 0));\r\n}\r\nout:\r\nimp->imp_connect_tried = 1;\r\nif (rc != 0) {\r\nIMPORT_SET_STATE(imp, LUSTRE_IMP_DISCON);\r\nif (rc == -EACCES) {\r\nimp->imp_obd->obd_no_recov = 1;\r\nptlrpc_deactivate_import(imp);\r\n}\r\nif (rc == -EPROTO) {\r\nstruct obd_connect_data *ocd;\r\nif (request->rq_repmsg == NULL)\r\nreturn -EPROTO;\r\nocd = req_capsule_server_get(&request->rq_pill,\r\n&RMF_CONNECT_DATA);\r\nif (ocd &&\r\n(ocd->ocd_connect_flags & OBD_CONNECT_VERSION) &&\r\n(ocd->ocd_version != LUSTRE_VERSION_CODE)) {\r\nLCONSOLE_ERROR_MSG(0x16a, "Server %s version (%d.%d.%d.%d) refused connection from this client with an incompatible version (%s). Client must be recompiled\n",\r\nobd2cli_tgt(imp->imp_obd),\r\nOBD_OCD_VERSION_MAJOR(ocd->ocd_version),\r\nOBD_OCD_VERSION_MINOR(ocd->ocd_version),\r\nOBD_OCD_VERSION_PATCH(ocd->ocd_version),\r\nOBD_OCD_VERSION_FIX(ocd->ocd_version),\r\nLUSTRE_VERSION_STRING);\r\nptlrpc_deactivate_import(imp);\r\nIMPORT_SET_STATE(imp, LUSTRE_IMP_CLOSED);\r\n}\r\nreturn -EPROTO;\r\n}\r\nptlrpc_maybe_ping_import_soon(imp);\r\nCDEBUG(D_HA, "recovery of %s on %s failed (%d)\n",\r\nobd2cli_tgt(imp->imp_obd),\r\n(char *)imp->imp_connection->c_remote_uuid.uuid, rc);\r\n}\r\nwake_up_all(&imp->imp_recovery_waitq);\r\nreturn rc;\r\n}\r\nstatic int completed_replay_interpret(const struct lu_env *env,\r\nstruct ptlrpc_request *req,\r\nvoid *data, int rc)\r\n{\r\natomic_dec(&req->rq_import->imp_replay_inflight);\r\nif (req->rq_status == 0 &&\r\n!req->rq_import->imp_vbr_failed) {\r\nptlrpc_import_recovery_state_machine(req->rq_import);\r\n} else {\r\nif (req->rq_import->imp_vbr_failed) {\r\nCDEBUG(D_WARNING,\r\n"%s: version recovery fails, reconnecting\n",\r\nreq->rq_import->imp_obd->obd_name);\r\n} else {\r\nCDEBUG(D_HA, "%s: LAST_REPLAY message error: %d, reconnecting\n",\r\nreq->rq_import->imp_obd->obd_name,\r\nreq->rq_status);\r\n}\r\nptlrpc_connect_import(req->rq_import);\r\n}\r\nreturn 0;\r\n}\r\nstatic int signal_completed_replay(struct obd_import *imp)\r\n{\r\nstruct ptlrpc_request *req;\r\nif (unlikely(OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_FINISH_REPLAY)))\r\nreturn 0;\r\nLASSERT(atomic_read(&imp->imp_replay_inflight) == 0);\r\natomic_inc(&imp->imp_replay_inflight);\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_OBD_PING, LUSTRE_OBD_VERSION,\r\nOBD_PING);\r\nif (req == NULL) {\r\natomic_dec(&imp->imp_replay_inflight);\r\nreturn -ENOMEM;\r\n}\r\nptlrpc_request_set_replen(req);\r\nreq->rq_send_state = LUSTRE_IMP_REPLAY_WAIT;\r\nlustre_msg_add_flags(req->rq_reqmsg,\r\nMSG_LOCK_REPLAY_DONE | MSG_REQ_REPLAY_DONE);\r\nif (AT_OFF)\r\nreq->rq_timeout *= 3;\r\nreq->rq_interpret_reply = completed_replay_interpret;\r\nptlrpcd_add_req(req, PDL_POLICY_ROUND, -1);\r\nreturn 0;\r\n}\r\nstatic int ptlrpc_invalidate_import_thread(void *data)\r\n{\r\nstruct obd_import *imp = data;\r\nunshare_fs_struct();\r\nCDEBUG(D_HA, "thread invalidate import %s to %s@%s\n",\r\nimp->imp_obd->obd_name, obd2cli_tgt(imp->imp_obd),\r\nimp->imp_connection->c_remote_uuid.uuid);\r\nptlrpc_invalidate_import(imp);\r\nif (obd_dump_on_eviction) {\r\nCERROR("dump the log upon eviction\n");\r\nlibcfs_debug_dumplog();\r\n}\r\nIMPORT_SET_STATE(imp, LUSTRE_IMP_RECOVER);\r\nptlrpc_import_recovery_state_machine(imp);\r\nclass_import_put(imp);\r\nreturn 0;\r\n}\r\nint ptlrpc_import_recovery_state_machine(struct obd_import *imp)\r\n{\r\nint rc = 0;\r\nint inflight;\r\nchar *target_start;\r\nint target_len;\r\nif (imp->imp_state == LUSTRE_IMP_EVICTED) {\r\ndeuuidify(obd2cli_tgt(imp->imp_obd), NULL,\r\n&target_start, &target_len);\r\nif (strcmp(imp->imp_obd->obd_type->typ_name,\r\nLUSTRE_MGC_NAME) != 0) {\r\nLCONSOLE_ERROR_MSG(0x167, "%s: This client was evicted by %.*s; in progress operations using this service will fail.\n",\r\nimp->imp_obd->obd_name, target_len,\r\ntarget_start);\r\n}\r\nCDEBUG(D_HA, "evicted from %s@%s; invalidating\n",\r\nobd2cli_tgt(imp->imp_obd),\r\nimp->imp_connection->c_remote_uuid.uuid);\r\nspin_lock(&imp->imp_lock);\r\nimp->imp_vbr_failed = 0;\r\nspin_unlock(&imp->imp_lock);\r\n{\r\nstruct task_struct *task;\r\nclass_import_get(imp);\r\ntask = kthread_run(ptlrpc_invalidate_import_thread, imp,\r\n"ll_imp_inval");\r\nif (IS_ERR(task)) {\r\nclass_import_put(imp);\r\nCERROR("error starting invalidate thread: %d\n", rc);\r\nrc = PTR_ERR(task);\r\n} else {\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\n}\r\nif (imp->imp_state == LUSTRE_IMP_REPLAY) {\r\nCDEBUG(D_HA, "replay requested by %s\n",\r\nobd2cli_tgt(imp->imp_obd));\r\nrc = ptlrpc_replay_next(imp, &inflight);\r\nif (inflight == 0 &&\r\natomic_read(&imp->imp_replay_inflight) == 0) {\r\nIMPORT_SET_STATE(imp, LUSTRE_IMP_REPLAY_LOCKS);\r\nrc = ldlm_replay_locks(imp);\r\nif (rc)\r\ngoto out;\r\n}\r\nrc = 0;\r\n}\r\nif (imp->imp_state == LUSTRE_IMP_REPLAY_LOCKS) {\r\nif (atomic_read(&imp->imp_replay_inflight) == 0) {\r\nIMPORT_SET_STATE(imp, LUSTRE_IMP_REPLAY_WAIT);\r\nrc = signal_completed_replay(imp);\r\nif (rc)\r\ngoto out;\r\n}\r\n}\r\nif (imp->imp_state == LUSTRE_IMP_REPLAY_WAIT) {\r\nif (atomic_read(&imp->imp_replay_inflight) == 0) {\r\nIMPORT_SET_STATE(imp, LUSTRE_IMP_RECOVER);\r\n}\r\n}\r\nif (imp->imp_state == LUSTRE_IMP_RECOVER) {\r\nCDEBUG(D_HA, "reconnected to %s@%s\n",\r\nobd2cli_tgt(imp->imp_obd),\r\nimp->imp_connection->c_remote_uuid.uuid);\r\nrc = ptlrpc_resend(imp);\r\nif (rc)\r\ngoto out;\r\nIMPORT_SET_STATE(imp, LUSTRE_IMP_FULL);\r\nptlrpc_activate_import(imp);\r\ndeuuidify(obd2cli_tgt(imp->imp_obd), NULL,\r\n&target_start, &target_len);\r\nLCONSOLE_INFO("%s: Connection restored to %.*s (at %s)\n",\r\nimp->imp_obd->obd_name,\r\ntarget_len, target_start,\r\nlibcfs_nid2str(imp->imp_connection->c_peer.nid));\r\n}\r\nif (imp->imp_state == LUSTRE_IMP_FULL) {\r\nwake_up_all(&imp->imp_recovery_waitq);\r\nptlrpc_wake_delayed(imp);\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nint ptlrpc_disconnect_import(struct obd_import *imp, int noclose)\r\n{\r\nstruct ptlrpc_request *req;\r\nint rq_opc, rc = 0;\r\nif (imp->imp_obd->obd_force)\r\ngoto set_state;\r\nswitch (imp->imp_connect_op) {\r\ncase OST_CONNECT:\r\nrq_opc = OST_DISCONNECT;\r\nbreak;\r\ncase MDS_CONNECT:\r\nrq_opc = MDS_DISCONNECT;\r\nbreak;\r\ncase MGS_CONNECT:\r\nrq_opc = MGS_DISCONNECT;\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nCERROR("%s: don't know how to disconnect from %s (connect_op %d): rc = %d\n",\r\nimp->imp_obd->obd_name, obd2cli_tgt(imp->imp_obd),\r\nimp->imp_connect_op, rc);\r\nreturn rc;\r\n}\r\nif (ptlrpc_import_in_recovery(imp)) {\r\nstruct l_wait_info lwi;\r\nlong timeout;\r\nif (AT_OFF) {\r\nif (imp->imp_server_timeout)\r\ntimeout = cfs_time_seconds(obd_timeout / 2);\r\nelse\r\ntimeout = cfs_time_seconds(obd_timeout);\r\n} else {\r\nint idx = import_at_get_index(imp,\r\nimp->imp_client->cli_request_portal);\r\ntimeout = cfs_time_seconds(\r\nat_get(&imp->imp_at.iat_service_estimate[idx]));\r\n}\r\nlwi = LWI_TIMEOUT_INTR(cfs_timeout_cap(timeout),\r\nback_to_sleep, LWI_ON_SIGNAL_NOOP, NULL);\r\nrc = l_wait_event(imp->imp_recovery_waitq,\r\n!ptlrpc_import_in_recovery(imp), &lwi);\r\n}\r\nspin_lock(&imp->imp_lock);\r\nif (imp->imp_state != LUSTRE_IMP_FULL)\r\ngoto out;\r\nspin_unlock(&imp->imp_lock);\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_MDS_DISCONNECT,\r\nLUSTRE_OBD_VERSION, rq_opc);\r\nif (req) {\r\nreq->rq_no_resend = 1;\r\nreq->rq_timeout = min_t(int, req->rq_timeout,\r\nINITIAL_CONNECT_TIMEOUT);\r\nIMPORT_SET_STATE(imp, LUSTRE_IMP_CONNECTING);\r\nreq->rq_send_state = LUSTRE_IMP_CONNECTING;\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nptlrpc_req_finished(req);\r\n}\r\nset_state:\r\nspin_lock(&imp->imp_lock);\r\nout:\r\nif (noclose)\r\nIMPORT_SET_STATE_NOLOCK(imp, LUSTRE_IMP_DISCON);\r\nelse\r\nIMPORT_SET_STATE_NOLOCK(imp, LUSTRE_IMP_CLOSED);\r\nmemset(&imp->imp_remote_handle, 0, sizeof(imp->imp_remote_handle));\r\nspin_unlock(&imp->imp_lock);\r\nif (rc == -ETIMEDOUT || rc == -ENOTCONN || rc == -ESHUTDOWN)\r\nrc = 0;\r\nreturn rc;\r\n}\r\nvoid ptlrpc_cleanup_imp(struct obd_import *imp)\r\n{\r\nspin_lock(&imp->imp_lock);\r\nIMPORT_SET_STATE_NOLOCK(imp, LUSTRE_IMP_CLOSED);\r\nimp->imp_generation++;\r\nspin_unlock(&imp->imp_lock);\r\nptlrpc_abort_inflight(imp);\r\n}\r\nint at_measured(struct adaptive_timeout *at, unsigned int val)\r\n{\r\nunsigned int old = at->at_current;\r\ntime_t now = get_seconds();\r\ntime_t binlimit = max_t(time_t, at_history / AT_BINS, 1);\r\nLASSERT(at);\r\nCDEBUG(D_OTHER, "add %u to %p time=%lu v=%u (%u %u %u %u)\n",\r\nval, at, now - at->at_binstart, at->at_current,\r\nat->at_hist[0], at->at_hist[1], at->at_hist[2], at->at_hist[3]);\r\nif (val == 0)\r\nreturn 0;\r\nspin_lock(&at->at_lock);\r\nif (unlikely(at->at_binstart == 0)) {\r\nat->at_current = val;\r\nat->at_worst_ever = val;\r\nat->at_worst_time = now;\r\nat->at_hist[0] = val;\r\nat->at_binstart = now;\r\n} else if (now - at->at_binstart < binlimit) {\r\nat->at_hist[0] = max(val, at->at_hist[0]);\r\nat->at_current = max(val, at->at_current);\r\n} else {\r\nint i, shift;\r\nunsigned int maxv = val;\r\nshift = (now - at->at_binstart) / binlimit;\r\nLASSERT(shift > 0);\r\nfor (i = AT_BINS - 1; i >= 0; i--) {\r\nif (i >= shift) {\r\nat->at_hist[i] = at->at_hist[i - shift];\r\nmaxv = max(maxv, at->at_hist[i]);\r\n} else {\r\nat->at_hist[i] = 0;\r\n}\r\n}\r\nat->at_hist[0] = val;\r\nat->at_current = maxv;\r\nat->at_binstart += shift * binlimit;\r\n}\r\nif (at->at_current > at->at_worst_ever) {\r\nat->at_worst_ever = at->at_current;\r\nat->at_worst_time = now;\r\n}\r\nif (at->at_flags & AT_FLG_NOHIST)\r\nat->at_current = val;\r\nif (at_max > 0)\r\nat->at_current = min(at->at_current, at_max);\r\nat->at_current = max(at->at_current, at_min);\r\nif (at->at_current != old)\r\nCDEBUG(D_OTHER, "AT %p change: old=%u new=%u delta=%d (val=%u) hist %u %u %u %u\n",\r\nat,\r\nold, at->at_current, at->at_current - old, val,\r\nat->at_hist[0], at->at_hist[1], at->at_hist[2],\r\nat->at_hist[3]);\r\nold = (at->at_current != old) ? old : 0;\r\nspin_unlock(&at->at_lock);\r\nreturn old;\r\n}\r\nint import_at_get_index(struct obd_import *imp, int portal)\r\n{\r\nstruct imp_at *at = &imp->imp_at;\r\nint i;\r\nfor (i = 0; i < IMP_AT_MAX_PORTALS; i++) {\r\nif (at->iat_portal[i] == portal)\r\nreturn i;\r\nif (at->iat_portal[i] == 0)\r\nbreak;\r\n}\r\nspin_lock(&imp->imp_lock);\r\nfor (; i < IMP_AT_MAX_PORTALS; i++) {\r\nif (at->iat_portal[i] == portal)\r\ngoto out;\r\nif (at->iat_portal[i] == 0)\r\nbreak;\r\n}\r\nLASSERT(i < IMP_AT_MAX_PORTALS);\r\nat->iat_portal[i] = portal;\r\nout:\r\nspin_unlock(&imp->imp_lock);\r\nreturn i;\r\n}
