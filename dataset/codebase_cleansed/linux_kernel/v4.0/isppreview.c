static void\r\npreview_config_luma_enhancement(struct isp_prev_device *prev,\r\nconst struct prev_params *params)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_luma *yt = &params->luma;\r\nunsigned int i;\r\nisp_reg_writel(isp, ISPPRV_YENH_TABLE_ADDR,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);\r\nfor (i = 0; i < OMAP3ISP_PREV_YENH_TBL_SIZE; i++) {\r\nisp_reg_writel(isp, yt->table[i],\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);\r\n}\r\n}\r\nstatic void\r\npreview_enable_luma_enhancement(struct isp_prev_device *prev, bool enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_YNENHEN);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_YNENHEN);\r\n}\r\nstatic void preview_enable_invalaw(struct isp_prev_device *prev, bool enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_INVALAW);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_INVALAW);\r\n}\r\nstatic void preview_config_hmed(struct isp_prev_device *prev,\r\nconst struct prev_params *params)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_hmed *hmed = &params->hmed;\r\nisp_reg_writel(isp, (hmed->odddist == 1 ? 0 : ISPPRV_HMED_ODDDIST) |\r\n(hmed->evendist == 1 ? 0 : ISPPRV_HMED_EVENDIST) |\r\n(hmed->thres << ISPPRV_HMED_THRESHOLD_SHIFT),\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_HMED);\r\n}\r\nstatic void preview_enable_hmed(struct isp_prev_device *prev, bool enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_HMEDEN);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_HMEDEN);\r\n}\r\nstatic void preview_config_cfa(struct isp_prev_device *prev,\r\nconst struct prev_params *params)\r\n{\r\nstatic const unsigned int cfa_coef_order[4][4] = {\r\n{ 0, 1, 2, 3 },\r\n{ 1, 0, 3, 2 },\r\n{ 2, 3, 0, 1 },\r\n{ 3, 2, 1, 0 },\r\n};\r\nconst unsigned int *order = cfa_coef_order[prev->params.cfa_order];\r\nconst struct omap3isp_prev_cfa *cfa = &params->cfa;\r\nstruct isp_device *isp = to_isp_device(prev);\r\nunsigned int i;\r\nunsigned int j;\r\nisp_reg_writel(isp,\r\n(cfa->gradthrs_vert << ISPPRV_CFA_GRADTH_VER_SHIFT) |\r\n(cfa->gradthrs_horz << ISPPRV_CFA_GRADTH_HOR_SHIFT),\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_CFA);\r\nisp_reg_writel(isp, ISPPRV_CFA_TABLE_ADDR,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);\r\nfor (i = 0; i < 4; ++i) {\r\nconst __u32 *block = cfa->table[order[i]];\r\nfor (j = 0; j < OMAP3ISP_PREV_CFA_BLK_SIZE; ++j)\r\nisp_reg_writel(isp, block[j], OMAP3_ISP_IOMEM_PREV,\r\nISPPRV_SET_TBL_DATA);\r\n}\r\n}\r\nstatic void\r\npreview_config_chroma_suppression(struct isp_prev_device *prev,\r\nconst struct prev_params *params)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_csup *cs = &params->csup;\r\nisp_reg_writel(isp,\r\ncs->gain | (cs->thres << ISPPRV_CSUP_THRES_SHIFT) |\r\n(cs->hypf_en << ISPPRV_CSUP_HPYF_SHIFT),\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_CSUP);\r\n}\r\nstatic void\r\npreview_enable_chroma_suppression(struct isp_prev_device *prev, bool enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_SUPEN);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_SUPEN);\r\n}\r\nstatic void\r\npreview_config_whitebalance(struct isp_prev_device *prev,\r\nconst struct prev_params *params)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_wbal *wbal = &params->wbal;\r\nu32 val;\r\nisp_reg_writel(isp, wbal->dgain, OMAP3_ISP_IOMEM_PREV, ISPPRV_WB_DGAIN);\r\nval = wbal->coef0 << ISPPRV_WBGAIN_COEF0_SHIFT;\r\nval |= wbal->coef1 << ISPPRV_WBGAIN_COEF1_SHIFT;\r\nval |= wbal->coef2 << ISPPRV_WBGAIN_COEF2_SHIFT;\r\nval |= wbal->coef3 << ISPPRV_WBGAIN_COEF3_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_WBGAIN);\r\nisp_reg_writel(isp,\r\nISPPRV_WBSEL_COEF0 << ISPPRV_WBSEL_N0_0_SHIFT |\r\nISPPRV_WBSEL_COEF1 << ISPPRV_WBSEL_N0_1_SHIFT |\r\nISPPRV_WBSEL_COEF0 << ISPPRV_WBSEL_N0_2_SHIFT |\r\nISPPRV_WBSEL_COEF1 << ISPPRV_WBSEL_N0_3_SHIFT |\r\nISPPRV_WBSEL_COEF2 << ISPPRV_WBSEL_N1_0_SHIFT |\r\nISPPRV_WBSEL_COEF3 << ISPPRV_WBSEL_N1_1_SHIFT |\r\nISPPRV_WBSEL_COEF2 << ISPPRV_WBSEL_N1_2_SHIFT |\r\nISPPRV_WBSEL_COEF3 << ISPPRV_WBSEL_N1_3_SHIFT |\r\nISPPRV_WBSEL_COEF0 << ISPPRV_WBSEL_N2_0_SHIFT |\r\nISPPRV_WBSEL_COEF1 << ISPPRV_WBSEL_N2_1_SHIFT |\r\nISPPRV_WBSEL_COEF0 << ISPPRV_WBSEL_N2_2_SHIFT |\r\nISPPRV_WBSEL_COEF1 << ISPPRV_WBSEL_N2_3_SHIFT |\r\nISPPRV_WBSEL_COEF2 << ISPPRV_WBSEL_N3_0_SHIFT |\r\nISPPRV_WBSEL_COEF3 << ISPPRV_WBSEL_N3_1_SHIFT |\r\nISPPRV_WBSEL_COEF2 << ISPPRV_WBSEL_N3_2_SHIFT |\r\nISPPRV_WBSEL_COEF3 << ISPPRV_WBSEL_N3_3_SHIFT,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_WBSEL);\r\n}\r\nstatic void\r\npreview_config_blkadj(struct isp_prev_device *prev,\r\nconst struct prev_params *params)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_blkadj *blkadj = &params->blkadj;\r\nisp_reg_writel(isp, (blkadj->blue << ISPPRV_BLKADJOFF_B_SHIFT) |\r\n(blkadj->green << ISPPRV_BLKADJOFF_G_SHIFT) |\r\n(blkadj->red << ISPPRV_BLKADJOFF_R_SHIFT),\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_BLKADJOFF);\r\n}\r\nstatic void\r\npreview_config_rgb_blending(struct isp_prev_device *prev,\r\nconst struct prev_params *params)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_rgbtorgb *rgbrgb = &params->rgb2rgb;\r\nu32 val;\r\nval = (rgbrgb->matrix[0][0] & 0xfff) << ISPPRV_RGB_MAT1_MTX_RR_SHIFT;\r\nval |= (rgbrgb->matrix[0][1] & 0xfff) << ISPPRV_RGB_MAT1_MTX_GR_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT1);\r\nval = (rgbrgb->matrix[0][2] & 0xfff) << ISPPRV_RGB_MAT2_MTX_BR_SHIFT;\r\nval |= (rgbrgb->matrix[1][0] & 0xfff) << ISPPRV_RGB_MAT2_MTX_RG_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT2);\r\nval = (rgbrgb->matrix[1][1] & 0xfff) << ISPPRV_RGB_MAT3_MTX_GG_SHIFT;\r\nval |= (rgbrgb->matrix[1][2] & 0xfff) << ISPPRV_RGB_MAT3_MTX_BG_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT3);\r\nval = (rgbrgb->matrix[2][0] & 0xfff) << ISPPRV_RGB_MAT4_MTX_RB_SHIFT;\r\nval |= (rgbrgb->matrix[2][1] & 0xfff) << ISPPRV_RGB_MAT4_MTX_GB_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT4);\r\nval = (rgbrgb->matrix[2][2] & 0xfff) << ISPPRV_RGB_MAT5_MTX_BB_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_MAT5);\r\nval = (rgbrgb->offset[0] & 0x3ff) << ISPPRV_RGB_OFF1_MTX_OFFR_SHIFT;\r\nval |= (rgbrgb->offset[1] & 0x3ff) << ISPPRV_RGB_OFF1_MTX_OFFG_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_OFF1);\r\nval = (rgbrgb->offset[2] & 0x3ff) << ISPPRV_RGB_OFF2_MTX_OFFB_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_RGB_OFF2);\r\n}\r\nstatic void\r\npreview_config_csc(struct isp_prev_device *prev,\r\nconst struct prev_params *params)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_csc *csc = &params->csc;\r\nu32 val;\r\nval = (csc->matrix[0][0] & 0x3ff) << ISPPRV_CSC0_RY_SHIFT;\r\nval |= (csc->matrix[0][1] & 0x3ff) << ISPPRV_CSC0_GY_SHIFT;\r\nval |= (csc->matrix[0][2] & 0x3ff) << ISPPRV_CSC0_BY_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC0);\r\nval = (csc->matrix[1][0] & 0x3ff) << ISPPRV_CSC1_RCB_SHIFT;\r\nval |= (csc->matrix[1][1] & 0x3ff) << ISPPRV_CSC1_GCB_SHIFT;\r\nval |= (csc->matrix[1][2] & 0x3ff) << ISPPRV_CSC1_BCB_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC1);\r\nval = (csc->matrix[2][0] & 0x3ff) << ISPPRV_CSC2_RCR_SHIFT;\r\nval |= (csc->matrix[2][1] & 0x3ff) << ISPPRV_CSC2_GCR_SHIFT;\r\nval |= (csc->matrix[2][2] & 0x3ff) << ISPPRV_CSC2_BCR_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC2);\r\nval = (csc->offset[0] & 0xff) << ISPPRV_CSC_OFFSET_Y_SHIFT;\r\nval |= (csc->offset[1] & 0xff) << ISPPRV_CSC_OFFSET_CB_SHIFT;\r\nval |= (csc->offset[2] & 0xff) << ISPPRV_CSC_OFFSET_CR_SHIFT;\r\nisp_reg_writel(isp, val, OMAP3_ISP_IOMEM_PREV, ISPPRV_CSC_OFFSET);\r\n}\r\nstatic void\r\npreview_config_yc_range(struct isp_prev_device *prev,\r\nconst struct prev_params *params)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_yclimit *yc = &params->yclimit;\r\nisp_reg_writel(isp,\r\nyc->maxC << ISPPRV_SETUP_YC_MAXC_SHIFT |\r\nyc->maxY << ISPPRV_SETUP_YC_MAXY_SHIFT |\r\nyc->minC << ISPPRV_SETUP_YC_MINC_SHIFT |\r\nyc->minY << ISPPRV_SETUP_YC_MINY_SHIFT,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SETUP_YC);\r\n}\r\nstatic void\r\npreview_config_dcor(struct isp_prev_device *prev,\r\nconst struct prev_params *params)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_dcor *dcor = &params->dcor;\r\nisp_reg_writel(isp, dcor->detect_correct[0],\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR0);\r\nisp_reg_writel(isp, dcor->detect_correct[1],\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR1);\r\nisp_reg_writel(isp, dcor->detect_correct[2],\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR2);\r\nisp_reg_writel(isp, dcor->detect_correct[3],\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_CDC_THR3);\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_DCCOUP,\r\ndcor->couplet_mode_en ? ISPPRV_PCR_DCCOUP : 0);\r\n}\r\nstatic void preview_enable_dcor(struct isp_prev_device *prev, bool enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_DCOREN);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_DCOREN);\r\n}\r\nstatic void\r\npreview_enable_drkframe_capture(struct isp_prev_device *prev, bool enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_DRKFCAP);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_DRKFCAP);\r\n}\r\nstatic void preview_enable_drkframe(struct isp_prev_device *prev, bool enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_DRKFEN);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_DRKFEN);\r\n}\r\nstatic void\r\npreview_config_noisefilter(struct isp_prev_device *prev,\r\nconst struct prev_params *params)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_nf *nf = &params->nf;\r\nunsigned int i;\r\nisp_reg_writel(isp, nf->spread, OMAP3_ISP_IOMEM_PREV, ISPPRV_NF);\r\nisp_reg_writel(isp, ISPPRV_NF_TABLE_ADDR,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);\r\nfor (i = 0; i < OMAP3ISP_PREV_NF_TBL_SIZE; i++) {\r\nisp_reg_writel(isp, nf->table[i],\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_DATA);\r\n}\r\n}\r\nstatic void\r\npreview_enable_noisefilter(struct isp_prev_device *prev, bool enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_NFEN);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_NFEN);\r\n}\r\nstatic void\r\npreview_config_gammacorrn(struct isp_prev_device *prev,\r\nconst struct prev_params *params)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct omap3isp_prev_gtables *gt = &params->gamma;\r\nunsigned int i;\r\nisp_reg_writel(isp, ISPPRV_REDGAMMA_TABLE_ADDR,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);\r\nfor (i = 0; i < OMAP3ISP_PREV_GAMMA_TBL_SIZE; i++)\r\nisp_reg_writel(isp, gt->red[i], OMAP3_ISP_IOMEM_PREV,\r\nISPPRV_SET_TBL_DATA);\r\nisp_reg_writel(isp, ISPPRV_GREENGAMMA_TABLE_ADDR,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);\r\nfor (i = 0; i < OMAP3ISP_PREV_GAMMA_TBL_SIZE; i++)\r\nisp_reg_writel(isp, gt->green[i], OMAP3_ISP_IOMEM_PREV,\r\nISPPRV_SET_TBL_DATA);\r\nisp_reg_writel(isp, ISPPRV_BLUEGAMMA_TABLE_ADDR,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_SET_TBL_ADDR);\r\nfor (i = 0; i < OMAP3ISP_PREV_GAMMA_TBL_SIZE; i++)\r\nisp_reg_writel(isp, gt->blue[i], OMAP3_ISP_IOMEM_PREV,\r\nISPPRV_SET_TBL_DATA);\r\n}\r\nstatic void\r\npreview_enable_gammacorrn(struct isp_prev_device *prev, bool enable)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (enable)\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_GAMMA_BYPASS);\r\nelse\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_GAMMA_BYPASS);\r\n}\r\nstatic void\r\npreview_config_contrast(struct isp_prev_device *prev,\r\nconst struct prev_params *params)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_CNT_BRT,\r\n0xff << ISPPRV_CNT_BRT_CNT_SHIFT,\r\nparams->contrast << ISPPRV_CNT_BRT_CNT_SHIFT);\r\n}\r\nstatic void\r\npreview_config_brightness(struct isp_prev_device *prev,\r\nconst struct prev_params *params)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_CNT_BRT,\r\n0xff << ISPPRV_CNT_BRT_BRT_SHIFT,\r\nparams->brightness << ISPPRV_CNT_BRT_BRT_SHIFT);\r\n}\r\nstatic void\r\npreview_update_contrast(struct isp_prev_device *prev, u8 contrast)\r\n{\r\nstruct prev_params *params;\r\nunsigned long flags;\r\nspin_lock_irqsave(&prev->params.lock, flags);\r\nparams = (prev->params.active & OMAP3ISP_PREV_CONTRAST)\r\n? &prev->params.params[0] : &prev->params.params[1];\r\nif (params->contrast != (contrast * ISPPRV_CONTRAST_UNITS)) {\r\nparams->contrast = contrast * ISPPRV_CONTRAST_UNITS;\r\nparams->update |= OMAP3ISP_PREV_CONTRAST;\r\n}\r\nspin_unlock_irqrestore(&prev->params.lock, flags);\r\n}\r\nstatic void\r\npreview_update_brightness(struct isp_prev_device *prev, u8 brightness)\r\n{\r\nstruct prev_params *params;\r\nunsigned long flags;\r\nspin_lock_irqsave(&prev->params.lock, flags);\r\nparams = (prev->params.active & OMAP3ISP_PREV_BRIGHTNESS)\r\n? &prev->params.params[0] : &prev->params.params[1];\r\nif (params->brightness != (brightness * ISPPRV_BRIGHT_UNITS)) {\r\nparams->brightness = brightness * ISPPRV_BRIGHT_UNITS;\r\nparams->update |= OMAP3ISP_PREV_BRIGHTNESS;\r\n}\r\nspin_unlock_irqrestore(&prev->params.lock, flags);\r\n}\r\nstatic u32\r\npreview_params_lock(struct isp_prev_device *prev, u32 update, bool shadow)\r\n{\r\nu32 active = prev->params.active;\r\nif (shadow) {\r\nprev->params.params[0].busy |= ~active & update;\r\nprev->params.params[1].busy |= active & update;\r\n} else {\r\nupdate = (prev->params.params[0].update & active)\r\n| (prev->params.params[1].update & ~active);\r\nprev->params.params[0].busy |= active & update;\r\nprev->params.params[1].busy |= ~active & update;\r\n}\r\nreturn update;\r\n}\r\nstatic void\r\npreview_params_unlock(struct isp_prev_device *prev, u32 update, bool shadow)\r\n{\r\nu32 active = prev->params.active;\r\nif (shadow) {\r\nprev->params.params[0].update |= (~active & update);\r\nprev->params.params[1].update |= (active & update);\r\nprev->params.params[0].busy &= active;\r\nprev->params.params[1].busy &= ~active;\r\n} else {\r\nprev->params.params[0].update &= ~(active & update);\r\nprev->params.params[1].update &= ~(~active & update);\r\nprev->params.params[0].busy &= ~active;\r\nprev->params.params[1].busy &= active;\r\n}\r\n}\r\nstatic void preview_params_switch(struct isp_prev_device *prev)\r\n{\r\nu32 to_switch;\r\nto_switch = (prev->params.params[0].update & ~prev->params.active)\r\n| (prev->params.params[1].update & prev->params.active);\r\nto_switch &= ~(prev->params.params[0].busy |\r\nprev->params.params[1].busy);\r\nif (to_switch == 0)\r\nreturn;\r\nprev->params.active ^= to_switch;\r\nprev->params.params[0].update &= ~(~prev->params.active & to_switch);\r\nprev->params.params[1].update &= ~(prev->params.active & to_switch);\r\n}\r\nstatic int preview_config(struct isp_prev_device *prev,\r\nstruct omap3isp_prev_update_config *cfg)\r\n{\r\nunsigned long flags;\r\nunsigned int i;\r\nint rval = 0;\r\nu32 update;\r\nu32 active;\r\nif (cfg->update == 0)\r\nreturn 0;\r\nspin_lock_irqsave(&prev->params.lock, flags);\r\npreview_params_lock(prev, cfg->update, true);\r\nactive = prev->params.active;\r\nspin_unlock_irqrestore(&prev->params.lock, flags);\r\nupdate = 0;\r\nfor (i = 0; i < ARRAY_SIZE(update_attrs); i++) {\r\nconst struct preview_update *attr = &update_attrs[i];\r\nstruct prev_params *params;\r\nunsigned int bit = 1 << i;\r\nif (attr->skip || !(cfg->update & bit))\r\ncontinue;\r\nparams = &prev->params.params[!!(active & bit)];\r\nif (cfg->flag & bit) {\r\nvoid __user *from = *(void * __user *)\r\n((void *)cfg + attr->config_offset);\r\nvoid *to = (void *)params + attr->param_offset;\r\nsize_t size = attr->param_size;\r\nif (to && from && size) {\r\nif (copy_from_user(to, from, size)) {\r\nrval = -EFAULT;\r\nbreak;\r\n}\r\n}\r\nparams->features |= bit;\r\n} else {\r\nparams->features &= ~bit;\r\n}\r\nupdate |= bit;\r\n}\r\nspin_lock_irqsave(&prev->params.lock, flags);\r\npreview_params_unlock(prev, update, true);\r\npreview_params_switch(prev);\r\nspin_unlock_irqrestore(&prev->params.lock, flags);\r\nreturn rval;\r\n}\r\nstatic void preview_setup_hw(struct isp_prev_device *prev, u32 update,\r\nu32 active)\r\n{\r\nunsigned int i;\r\nu32 features;\r\nif (update == 0)\r\nreturn;\r\nfeatures = (prev->params.params[0].features & active)\r\n| (prev->params.params[1].features & ~active);\r\nfor (i = 0; i < ARRAY_SIZE(update_attrs); i++) {\r\nconst struct preview_update *attr = &update_attrs[i];\r\nstruct prev_params *params;\r\nunsigned int bit = 1 << i;\r\nif (!(update & bit))\r\ncontinue;\r\nparams = &prev->params.params[!(active & bit)];\r\nif (params->features & bit) {\r\nif (attr->config)\r\nattr->config(prev, params);\r\nif (attr->enable)\r\nattr->enable(prev, true);\r\n} else {\r\nif (attr->enable)\r\nattr->enable(prev, false);\r\n}\r\n}\r\n}\r\nstatic void preview_config_ycpos(struct isp_prev_device *prev, u32 pixelcode)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nenum preview_ycpos_mode mode;\r\nswitch (pixelcode) {\r\ncase MEDIA_BUS_FMT_YUYV8_1X16:\r\nmode = YCPOS_CrYCbY;\r\nbreak;\r\ncase MEDIA_BUS_FMT_UYVY8_1X16:\r\nmode = YCPOS_YCrYCb;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_YCPOS_CrYCbY,\r\nmode << ISPPRV_PCR_YCPOS_SHIFT);\r\n}\r\nstatic void preview_config_averager(struct isp_prev_device *prev, u8 average)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nisp_reg_writel(isp, ISPPRV_AVE_EVENDIST_2 << ISPPRV_AVE_EVENDIST_SHIFT |\r\nISPPRV_AVE_ODDDIST_2 << ISPPRV_AVE_ODDDIST_SHIFT |\r\naverage, OMAP3_ISP_IOMEM_PREV, ISPPRV_AVE);\r\n}\r\nstatic void preview_config_input_format(struct isp_prev_device *prev,\r\nconst struct isp_format_info *info)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nstruct prev_params *params;\r\nif (info->width == 8)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_WIDTH);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_WIDTH);\r\nswitch (info->flavor) {\r\ncase MEDIA_BUS_FMT_SGRBG8_1X8:\r\nprev->params.cfa_order = 0;\r\nbreak;\r\ncase MEDIA_BUS_FMT_SRGGB8_1X8:\r\nprev->params.cfa_order = 1;\r\nbreak;\r\ncase MEDIA_BUS_FMT_SBGGR8_1X8:\r\nprev->params.cfa_order = 2;\r\nbreak;\r\ncase MEDIA_BUS_FMT_SGBRG8_1X8:\r\nprev->params.cfa_order = 3;\r\nbreak;\r\ndefault:\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_CFAEN);\r\nreturn;\r\n}\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR, ISPPRV_PCR_CFAEN);\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_CFAFMT_MASK, ISPPRV_PCR_CFAFMT_BAYER);\r\nparams = (prev->params.active & OMAP3ISP_PREV_CFA)\r\n? &prev->params.params[0] : &prev->params.params[1];\r\npreview_config_cfa(prev, params);\r\n}\r\nstatic void preview_config_input_size(struct isp_prev_device *prev, u32 active)\r\n{\r\nconst struct v4l2_mbus_framefmt *format = &prev->formats[PREV_PAD_SINK];\r\nstruct isp_device *isp = to_isp_device(prev);\r\nunsigned int sph = prev->crop.left;\r\nunsigned int eph = prev->crop.left + prev->crop.width - 1;\r\nunsigned int slv = prev->crop.top;\r\nunsigned int elv = prev->crop.top + prev->crop.height - 1;\r\nu32 features;\r\nif (format->code != MEDIA_BUS_FMT_Y8_1X8 &&\r\nformat->code != MEDIA_BUS_FMT_Y10_1X10) {\r\nsph -= 2;\r\neph += 2;\r\nslv -= 2;\r\nelv += 2;\r\n}\r\nfeatures = (prev->params.params[0].features & active)\r\n| (prev->params.params[1].features & ~active);\r\nif (features & (OMAP3ISP_PREV_DEFECT_COR | OMAP3ISP_PREV_NF)) {\r\nsph -= 2;\r\neph += 2;\r\nslv -= 2;\r\nelv += 2;\r\n}\r\nif (features & OMAP3ISP_PREV_HRZ_MED) {\r\nsph -= 2;\r\neph += 2;\r\n}\r\nif (features & (OMAP3ISP_PREV_CHROMA_SUPP | OMAP3ISP_PREV_LUMAENH))\r\nsph -= 2;\r\nisp_reg_writel(isp, (sph << ISPPRV_HORZ_INFO_SPH_SHIFT) | eph,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_HORZ_INFO);\r\nisp_reg_writel(isp, (slv << ISPPRV_VERT_INFO_SLV_SHIFT) | elv,\r\nOMAP3_ISP_IOMEM_PREV, ISPPRV_VERT_INFO);\r\n}\r\nstatic void\r\npreview_config_inlineoffset(struct isp_prev_device *prev, u32 offset)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nisp_reg_writel(isp, offset & 0xffff, OMAP3_ISP_IOMEM_PREV,\r\nISPPRV_RADR_OFFSET);\r\n}\r\nstatic void preview_set_inaddr(struct isp_prev_device *prev, u32 addr)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nisp_reg_writel(isp, addr, OMAP3_ISP_IOMEM_PREV, ISPPRV_RSDR_ADDR);\r\n}\r\nstatic void preview_config_outlineoffset(struct isp_prev_device *prev,\r\nu32 offset)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nisp_reg_writel(isp, offset & 0xffff, OMAP3_ISP_IOMEM_PREV,\r\nISPPRV_WADD_OFFSET);\r\n}\r\nstatic void preview_set_outaddr(struct isp_prev_device *prev, u32 addr)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nisp_reg_writel(isp, addr, OMAP3_ISP_IOMEM_PREV, ISPPRV_WSDR_ADDR);\r\n}\r\nstatic void preview_adjust_bandwidth(struct isp_prev_device *prev)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&prev->subdev.entity);\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct v4l2_mbus_framefmt *ifmt = &prev->formats[PREV_PAD_SINK];\r\nunsigned long l3_ick = pipe->l3_ick;\r\nstruct v4l2_fract *timeperframe;\r\nunsigned int cycles_per_frame;\r\nunsigned int requests_per_frame;\r\nunsigned int cycles_per_request;\r\nunsigned int minimum;\r\nunsigned int maximum;\r\nunsigned int value;\r\nif (prev->input != PREVIEW_INPUT_MEMORY) {\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_SDR_REQ_EXP,\r\nISPSBL_SDR_REQ_PRV_EXP_MASK);\r\nreturn;\r\n}\r\ncycles_per_request = div_u64((u64)l3_ick / 2 * 256 + pipe->max_rate - 1,\r\npipe->max_rate);\r\nminimum = DIV_ROUND_UP(cycles_per_request, 32);\r\ntimeperframe = &pipe->max_timeperframe;\r\nrequests_per_frame = DIV_ROUND_UP(ifmt->width * 2, 256) * ifmt->height;\r\ncycles_per_frame = div_u64((u64)l3_ick * timeperframe->numerator,\r\ntimeperframe->denominator);\r\ncycles_per_request = cycles_per_frame / requests_per_frame;\r\nmaximum = cycles_per_request / 32;\r\nvalue = max(minimum, maximum);\r\ndev_dbg(isp->dev, "%s: cycles per request = %u\n", __func__, value);\r\nisp_reg_clr_set(isp, OMAP3_ISP_IOMEM_SBL, ISPSBL_SDR_REQ_EXP,\r\nISPSBL_SDR_REQ_PRV_EXP_MASK,\r\nvalue << ISPSBL_SDR_REQ_PRV_EXP_SHIFT);\r\n}\r\nint omap3isp_preview_busy(struct isp_prev_device *prev)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nreturn isp_reg_readl(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR)\r\n& ISPPRV_PCR_BUSY;\r\n}\r\nvoid omap3isp_preview_restore_context(struct isp_device *isp)\r\n{\r\nstruct isp_prev_device *prev = &isp->isp_prev;\r\nconst u32 update = OMAP3ISP_PREV_FEATURES_END - 1;\r\nprev->params.params[0].update = prev->params.active & update;\r\nprev->params.params[1].update = ~prev->params.active & update;\r\npreview_setup_hw(prev, update, prev->params.active);\r\nprev->params.params[0].update = 0;\r\nprev->params.params[1].update = 0;\r\n}\r\nstatic void preview_print_status(struct isp_prev_device *prev)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\ndev_dbg(isp->dev, "-------------Preview Register dump----------\n");\r\nPREV_PRINT_REGISTER(isp, PCR);\r\nPREV_PRINT_REGISTER(isp, HORZ_INFO);\r\nPREV_PRINT_REGISTER(isp, VERT_INFO);\r\nPREV_PRINT_REGISTER(isp, RSDR_ADDR);\r\nPREV_PRINT_REGISTER(isp, RADR_OFFSET);\r\nPREV_PRINT_REGISTER(isp, DSDR_ADDR);\r\nPREV_PRINT_REGISTER(isp, DRKF_OFFSET);\r\nPREV_PRINT_REGISTER(isp, WSDR_ADDR);\r\nPREV_PRINT_REGISTER(isp, WADD_OFFSET);\r\nPREV_PRINT_REGISTER(isp, AVE);\r\nPREV_PRINT_REGISTER(isp, HMED);\r\nPREV_PRINT_REGISTER(isp, NF);\r\nPREV_PRINT_REGISTER(isp, WB_DGAIN);\r\nPREV_PRINT_REGISTER(isp, WBGAIN);\r\nPREV_PRINT_REGISTER(isp, WBSEL);\r\nPREV_PRINT_REGISTER(isp, CFA);\r\nPREV_PRINT_REGISTER(isp, BLKADJOFF);\r\nPREV_PRINT_REGISTER(isp, RGB_MAT1);\r\nPREV_PRINT_REGISTER(isp, RGB_MAT2);\r\nPREV_PRINT_REGISTER(isp, RGB_MAT3);\r\nPREV_PRINT_REGISTER(isp, RGB_MAT4);\r\nPREV_PRINT_REGISTER(isp, RGB_MAT5);\r\nPREV_PRINT_REGISTER(isp, RGB_OFF1);\r\nPREV_PRINT_REGISTER(isp, RGB_OFF2);\r\nPREV_PRINT_REGISTER(isp, CSC0);\r\nPREV_PRINT_REGISTER(isp, CSC1);\r\nPREV_PRINT_REGISTER(isp, CSC2);\r\nPREV_PRINT_REGISTER(isp, CSC_OFFSET);\r\nPREV_PRINT_REGISTER(isp, CNT_BRT);\r\nPREV_PRINT_REGISTER(isp, CSUP);\r\nPREV_PRINT_REGISTER(isp, SETUP_YC);\r\nPREV_PRINT_REGISTER(isp, SET_TBL_ADDR);\r\nPREV_PRINT_REGISTER(isp, CDC_THR0);\r\nPREV_PRINT_REGISTER(isp, CDC_THR1);\r\nPREV_PRINT_REGISTER(isp, CDC_THR2);\r\nPREV_PRINT_REGISTER(isp, CDC_THR3);\r\ndev_dbg(isp->dev, "--------------------------------------------\n");\r\n}\r\nstatic void preview_init_params(struct isp_prev_device *prev)\r\n{\r\nstruct prev_params *params;\r\nunsigned int i;\r\nspin_lock_init(&prev->params.lock);\r\nprev->params.active = ~0;\r\nprev->params.params[0].busy = 0;\r\nprev->params.params[0].update = OMAP3ISP_PREV_FEATURES_END - 1;\r\nprev->params.params[1].busy = 0;\r\nprev->params.params[1].update = 0;\r\nparams = &prev->params.params[0];\r\nparams->contrast = ISPPRV_CONTRAST_DEF * ISPPRV_CONTRAST_UNITS;\r\nparams->brightness = ISPPRV_BRIGHT_DEF * ISPPRV_BRIGHT_UNITS;\r\nparams->cfa.format = OMAP3ISP_CFAFMT_BAYER;\r\nmemcpy(params->cfa.table, cfa_coef_table,\r\nsizeof(params->cfa.table));\r\nparams->cfa.gradthrs_horz = FLR_CFA_GRADTHRS_HORZ;\r\nparams->cfa.gradthrs_vert = FLR_CFA_GRADTHRS_VERT;\r\nparams->csup.gain = FLR_CSUP_GAIN;\r\nparams->csup.thres = FLR_CSUP_THRES;\r\nparams->csup.hypf_en = 0;\r\nmemcpy(params->luma.table, luma_enhance_table,\r\nsizeof(params->luma.table));\r\nparams->nf.spread = FLR_NF_STRGTH;\r\nmemcpy(params->nf.table, noise_filter_table, sizeof(params->nf.table));\r\nparams->dcor.couplet_mode_en = 1;\r\nfor (i = 0; i < OMAP3ISP_PREV_DETECT_CORRECT_CHANNELS; i++)\r\nparams->dcor.detect_correct[i] = DEF_DETECT_CORRECT_VAL;\r\nmemcpy(params->gamma.blue, gamma_table, sizeof(params->gamma.blue));\r\nmemcpy(params->gamma.green, gamma_table, sizeof(params->gamma.green));\r\nmemcpy(params->gamma.red, gamma_table, sizeof(params->gamma.red));\r\nparams->wbal.dgain = FLR_WBAL_DGAIN;\r\nparams->wbal.coef0 = FLR_WBAL_COEF;\r\nparams->wbal.coef1 = FLR_WBAL_COEF;\r\nparams->wbal.coef2 = FLR_WBAL_COEF;\r\nparams->wbal.coef3 = FLR_WBAL_COEF;\r\nparams->blkadj.red = FLR_BLKADJ_RED;\r\nparams->blkadj.green = FLR_BLKADJ_GREEN;\r\nparams->blkadj.blue = FLR_BLKADJ_BLUE;\r\nparams->rgb2rgb = flr_rgb2rgb;\r\nparams->csc = flr_prev_csc;\r\nparams->yclimit.minC = ISPPRV_YC_MIN;\r\nparams->yclimit.maxC = ISPPRV_YC_MAX;\r\nparams->yclimit.minY = ISPPRV_YC_MIN;\r\nparams->yclimit.maxY = ISPPRV_YC_MAX;\r\nparams->features = OMAP3ISP_PREV_CFA | OMAP3ISP_PREV_DEFECT_COR\r\n| OMAP3ISP_PREV_NF | OMAP3ISP_PREV_GAMMA\r\n| OMAP3ISP_PREV_BLKADJ | OMAP3ISP_PREV_YC_LIMIT\r\n| OMAP3ISP_PREV_RGB2RGB | OMAP3ISP_PREV_COLOR_CONV\r\n| OMAP3ISP_PREV_WB | OMAP3ISP_PREV_BRIGHTNESS\r\n| OMAP3ISP_PREV_CONTRAST;\r\n}\r\nstatic unsigned int preview_max_out_width(struct isp_prev_device *prev)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nswitch (isp->revision) {\r\ncase ISP_REVISION_1_0:\r\nreturn PREV_MAX_OUT_WIDTH_REV_1;\r\ncase ISP_REVISION_2_0:\r\ndefault:\r\nreturn PREV_MAX_OUT_WIDTH_REV_2;\r\ncase ISP_REVISION_15_0:\r\nreturn PREV_MAX_OUT_WIDTH_REV_15;\r\n}\r\n}\r\nstatic void preview_configure(struct isp_prev_device *prev)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nconst struct isp_format_info *info;\r\nstruct v4l2_mbus_framefmt *format;\r\nunsigned long flags;\r\nu32 update;\r\nu32 active;\r\nspin_lock_irqsave(&prev->params.lock, flags);\r\nupdate = preview_params_lock(prev, 0, false);\r\nactive = prev->params.active;\r\nspin_unlock_irqrestore(&prev->params.lock, flags);\r\nformat = &prev->formats[PREV_PAD_SINK];\r\ninfo = omap3isp_video_format_info(format->code);\r\npreview_adjust_bandwidth(prev);\r\npreview_config_input_format(prev, info);\r\npreview_config_input_size(prev, active);\r\nif (prev->input == PREVIEW_INPUT_CCDC)\r\npreview_config_inlineoffset(prev, 0);\r\nelse\r\npreview_config_inlineoffset(prev, ALIGN(format->width, 0x20) *\r\ninfo->bpp);\r\npreview_setup_hw(prev, update, active);\r\nformat = &prev->formats[PREV_PAD_SOURCE];\r\nif (prev->output & PREVIEW_OUTPUT_MEMORY)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_SDRPORT);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_SDRPORT);\r\nif (prev->output & PREVIEW_OUTPUT_RESIZER)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_RSZPORT);\r\nelse\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_RSZPORT);\r\nif (prev->output & PREVIEW_OUTPUT_MEMORY)\r\npreview_config_outlineoffset(prev,\r\nALIGN(format->width, 0x10) * 2);\r\npreview_config_averager(prev, 0);\r\npreview_config_ycpos(prev, format->code);\r\nspin_lock_irqsave(&prev->params.lock, flags);\r\npreview_params_unlock(prev, update, false);\r\nspin_unlock_irqrestore(&prev->params.lock, flags);\r\n}\r\nstatic void preview_enable_oneshot(struct isp_prev_device *prev)\r\n{\r\nstruct isp_device *isp = to_isp_device(prev);\r\nif (prev->input == PREVIEW_INPUT_MEMORY)\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_SOURCE);\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_PREV, ISPPRV_PCR,\r\nISPPRV_PCR_EN | ISPPRV_PCR_ONESHOT);\r\n}\r\nvoid omap3isp_preview_isr_frame_sync(struct isp_prev_device *prev)\r\n{\r\nif (prev->state == ISP_PIPELINE_STREAM_CONTINUOUS &&\r\nprev->video_out.dmaqueue_flags & ISP_VIDEO_DMAQUEUE_QUEUED) {\r\npreview_enable_oneshot(prev);\r\nisp_video_dmaqueue_flags_clr(&prev->video_out);\r\n}\r\n}\r\nstatic void preview_isr_buffer(struct isp_prev_device *prev)\r\n{\r\nstruct isp_pipeline *pipe = to_isp_pipeline(&prev->subdev.entity);\r\nstruct isp_buffer *buffer;\r\nint restart = 0;\r\nif (prev->input == PREVIEW_INPUT_MEMORY) {\r\nbuffer = omap3isp_video_buffer_next(&prev->video_in);\r\nif (buffer != NULL)\r\npreview_set_inaddr(prev, buffer->dma);\r\npipe->state |= ISP_PIPELINE_IDLE_INPUT;\r\n}\r\nif (prev->output & PREVIEW_OUTPUT_MEMORY) {\r\nbuffer = omap3isp_video_buffer_next(&prev->video_out);\r\nif (buffer != NULL) {\r\npreview_set_outaddr(prev, buffer->dma);\r\nrestart = 1;\r\n}\r\npipe->state |= ISP_PIPELINE_IDLE_OUTPUT;\r\n}\r\nswitch (prev->state) {\r\ncase ISP_PIPELINE_STREAM_SINGLESHOT:\r\nif (isp_pipeline_ready(pipe))\r\nomap3isp_pipeline_set_stream(pipe,\r\nISP_PIPELINE_STREAM_SINGLESHOT);\r\nbreak;\r\ncase ISP_PIPELINE_STREAM_CONTINUOUS:\r\nif (restart)\r\npreview_enable_oneshot(prev);\r\nbreak;\r\ncase ISP_PIPELINE_STREAM_STOPPED:\r\ndefault:\r\nreturn;\r\n}\r\n}\r\nvoid omap3isp_preview_isr(struct isp_prev_device *prev)\r\n{\r\nunsigned long flags;\r\nu32 update;\r\nu32 active;\r\nif (omap3isp_module_sync_is_stopping(&prev->wait, &prev->stopping))\r\nreturn;\r\nspin_lock_irqsave(&prev->params.lock, flags);\r\npreview_params_switch(prev);\r\nupdate = preview_params_lock(prev, 0, false);\r\nactive = prev->params.active;\r\nspin_unlock_irqrestore(&prev->params.lock, flags);\r\npreview_setup_hw(prev, update, active);\r\npreview_config_input_size(prev, active);\r\nif (prev->input == PREVIEW_INPUT_MEMORY ||\r\nprev->output & PREVIEW_OUTPUT_MEMORY)\r\npreview_isr_buffer(prev);\r\nelse if (prev->state == ISP_PIPELINE_STREAM_CONTINUOUS)\r\npreview_enable_oneshot(prev);\r\nspin_lock_irqsave(&prev->params.lock, flags);\r\npreview_params_unlock(prev, update, false);\r\nspin_unlock_irqrestore(&prev->params.lock, flags);\r\n}\r\nstatic int preview_video_queue(struct isp_video *video,\r\nstruct isp_buffer *buffer)\r\n{\r\nstruct isp_prev_device *prev = &video->isp->isp_prev;\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\npreview_set_inaddr(prev, buffer->dma);\r\nif (video->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\npreview_set_outaddr(prev, buffer->dma);\r\nreturn 0;\r\n}\r\nstatic int preview_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct isp_prev_device *prev =\r\ncontainer_of(ctrl->handler, struct isp_prev_device, ctrls);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\npreview_update_brightness(prev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\npreview_update_contrast(prev, ctrl->val);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic long preview_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\r\n{\r\nstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\r\nswitch (cmd) {\r\ncase VIDIOC_OMAP3ISP_PRV_CFG:\r\nreturn preview_config(prev, arg);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic int preview_set_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\r\nstruct isp_video *video_out = &prev->video_out;\r\nstruct isp_device *isp = to_isp_device(prev);\r\nstruct device *dev = to_device(prev);\r\nif (prev->state == ISP_PIPELINE_STREAM_STOPPED) {\r\nif (enable == ISP_PIPELINE_STREAM_STOPPED)\r\nreturn 0;\r\nomap3isp_subclk_enable(isp, OMAP3_ISP_SUBCLK_PREVIEW);\r\npreview_configure(prev);\r\natomic_set(&prev->stopping, 0);\r\npreview_print_status(prev);\r\n}\r\nswitch (enable) {\r\ncase ISP_PIPELINE_STREAM_CONTINUOUS:\r\nif (prev->output & PREVIEW_OUTPUT_MEMORY)\r\nomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_PREVIEW_WRITE);\r\nif (video_out->dmaqueue_flags & ISP_VIDEO_DMAQUEUE_QUEUED ||\r\n!(prev->output & PREVIEW_OUTPUT_MEMORY))\r\npreview_enable_oneshot(prev);\r\nisp_video_dmaqueue_flags_clr(video_out);\r\nbreak;\r\ncase ISP_PIPELINE_STREAM_SINGLESHOT:\r\nif (prev->input == PREVIEW_INPUT_MEMORY)\r\nomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_PREVIEW_READ);\r\nif (prev->output & PREVIEW_OUTPUT_MEMORY)\r\nomap3isp_sbl_enable(isp, OMAP3_ISP_SBL_PREVIEW_WRITE);\r\npreview_enable_oneshot(prev);\r\nbreak;\r\ncase ISP_PIPELINE_STREAM_STOPPED:\r\nif (omap3isp_module_sync_idle(&sd->entity, &prev->wait,\r\n&prev->stopping))\r\ndev_dbg(dev, "%s: stop timeout.\n", sd->name);\r\nomap3isp_sbl_disable(isp, OMAP3_ISP_SBL_PREVIEW_READ);\r\nomap3isp_sbl_disable(isp, OMAP3_ISP_SBL_PREVIEW_WRITE);\r\nomap3isp_subclk_disable(isp, OMAP3_ISP_SUBCLK_PREVIEW);\r\nisp_video_dmaqueue_flags_clr(video_out);\r\nbreak;\r\n}\r\nprev->state = enable;\r\nreturn 0;\r\n}\r\nstatic struct v4l2_mbus_framefmt *\r\n__preview_get_format(struct isp_prev_device *prev, struct v4l2_subdev_fh *fh,\r\nunsigned int pad, enum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn v4l2_subdev_get_try_format(fh, pad);\r\nelse\r\nreturn &prev->formats[pad];\r\n}\r\nstatic struct v4l2_rect *\r\n__preview_get_crop(struct isp_prev_device *prev, struct v4l2_subdev_fh *fh,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nif (which == V4L2_SUBDEV_FORMAT_TRY)\r\nreturn v4l2_subdev_get_try_crop(fh, PREV_PAD_SINK);\r\nelse\r\nreturn &prev->crop;\r\n}\r\nstatic void preview_try_format(struct isp_prev_device *prev,\r\nstruct v4l2_subdev_fh *fh, unsigned int pad,\r\nstruct v4l2_mbus_framefmt *fmt,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nu32 pixelcode;\r\nstruct v4l2_rect *crop;\r\nunsigned int i;\r\nswitch (pad) {\r\ncase PREV_PAD_SINK:\r\nif (prev->input == PREVIEW_INPUT_MEMORY) {\r\nfmt->width = clamp_t(u32, fmt->width, PREV_MIN_IN_WIDTH,\r\npreview_max_out_width(prev));\r\nfmt->height = clamp_t(u32, fmt->height,\r\nPREV_MIN_IN_HEIGHT,\r\nPREV_MAX_IN_HEIGHT);\r\n}\r\nfmt->colorspace = V4L2_COLORSPACE_SRGB;\r\nfor (i = 0; i < ARRAY_SIZE(preview_input_fmts); i++) {\r\nif (fmt->code == preview_input_fmts[i])\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(preview_input_fmts))\r\nfmt->code = MEDIA_BUS_FMT_SGRBG10_1X10;\r\nbreak;\r\ncase PREV_PAD_SOURCE:\r\npixelcode = fmt->code;\r\n*fmt = *__preview_get_format(prev, fh, PREV_PAD_SINK, which);\r\nswitch (pixelcode) {\r\ncase MEDIA_BUS_FMT_YUYV8_1X16:\r\ncase MEDIA_BUS_FMT_UYVY8_1X16:\r\nfmt->code = pixelcode;\r\nbreak;\r\ndefault:\r\nfmt->code = MEDIA_BUS_FMT_YUYV8_1X16;\r\nbreak;\r\n}\r\ncrop = __preview_get_crop(prev, fh, which);\r\nfmt->width = crop->width;\r\nfmt->height = crop->height;\r\nfmt->colorspace = V4L2_COLORSPACE_JPEG;\r\nbreak;\r\n}\r\nfmt->field = V4L2_FIELD_NONE;\r\n}\r\nstatic void preview_try_crop(struct isp_prev_device *prev,\r\nconst struct v4l2_mbus_framefmt *sink,\r\nstruct v4l2_rect *crop)\r\n{\r\nunsigned int left = PREV_MARGIN_LEFT;\r\nunsigned int right = sink->width - PREV_MARGIN_RIGHT;\r\nunsigned int top = PREV_MARGIN_TOP;\r\nunsigned int bottom = sink->height - PREV_MARGIN_BOTTOM;\r\nif (prev->input == PREVIEW_INPUT_CCDC) {\r\nleft += 2;\r\nright -= 2;\r\n}\r\nif (sink->code != MEDIA_BUS_FMT_Y8_1X8 &&\r\nsink->code != MEDIA_BUS_FMT_Y10_1X10) {\r\nleft += 2;\r\nright -= 2;\r\ntop += 2;\r\nbottom -= 2;\r\n}\r\ncrop->left &= ~1;\r\ncrop->top &= ~1;\r\ncrop->left = clamp_t(u32, crop->left, left, right - PREV_MIN_OUT_WIDTH);\r\ncrop->top = clamp_t(u32, crop->top, top, bottom - PREV_MIN_OUT_HEIGHT);\r\ncrop->width = clamp_t(u32, crop->width, PREV_MIN_OUT_WIDTH,\r\nright - crop->left);\r\ncrop->height = clamp_t(u32, crop->height, PREV_MIN_OUT_HEIGHT,\r\nbottom - crop->top);\r\n}\r\nstatic int preview_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nswitch (code->pad) {\r\ncase PREV_PAD_SINK:\r\nif (code->index >= ARRAY_SIZE(preview_input_fmts))\r\nreturn -EINVAL;\r\ncode->code = preview_input_fmts[code->index];\r\nbreak;\r\ncase PREV_PAD_SOURCE:\r\nif (code->index >= ARRAY_SIZE(preview_output_fmts))\r\nreturn -EINVAL;\r\ncode->code = preview_output_fmts[code->index];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int preview_enum_frame_size(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt format;\r\nif (fse->index != 0)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = 1;\r\nformat.height = 1;\r\npreview_try_format(prev, fh, fse->pad, &format, V4L2_SUBDEV_FORMAT_TRY);\r\nfse->min_width = format.width;\r\nfse->min_height = format.height;\r\nif (format.code != fse->code)\r\nreturn -EINVAL;\r\nformat.code = fse->code;\r\nformat.width = -1;\r\nformat.height = -1;\r\npreview_try_format(prev, fh, fse->pad, &format, V4L2_SUBDEV_FORMAT_TRY);\r\nfse->max_width = format.width;\r\nfse->max_height = format.height;\r\nreturn 0;\r\n}\r\nstatic int preview_get_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nif (sel->pad != PREV_PAD_SINK)\r\nreturn -EINVAL;\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\nsel->r.width = INT_MAX;\r\nsel->r.height = INT_MAX;\r\nformat = __preview_get_format(prev, fh, PREV_PAD_SINK,\r\nsel->which);\r\npreview_try_crop(prev, format, &sel->r);\r\nbreak;\r\ncase V4L2_SEL_TGT_CROP:\r\nsel->r = *__preview_get_crop(prev, fh, sel->which);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int preview_set_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nif (sel->target != V4L2_SEL_TGT_CROP ||\r\nsel->pad != PREV_PAD_SINK)\r\nreturn -EINVAL;\r\nif (prev->state != ISP_PIPELINE_STREAM_STOPPED)\r\nreturn -EBUSY;\r\nif (sel->flags & V4L2_SEL_FLAG_KEEP_CONFIG) {\r\nsel->r = *__preview_get_crop(prev, fh, sel->which);\r\nreturn 0;\r\n}\r\nformat = __preview_get_format(prev, fh, PREV_PAD_SINK, sel->which);\r\npreview_try_crop(prev, format, &sel->r);\r\n*__preview_get_crop(prev, fh, sel->which) = sel->r;\r\nformat = __preview_get_format(prev, fh, PREV_PAD_SOURCE, sel->which);\r\npreview_try_format(prev, fh, PREV_PAD_SOURCE, format, sel->which);\r\nreturn 0;\r\n}\r\nstatic int preview_get_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = __preview_get_format(prev, fh, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nfmt->format = *format;\r\nreturn 0;\r\n}\r\nstatic int preview_set_format(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *format;\r\nstruct v4l2_rect *crop;\r\nformat = __preview_get_format(prev, fh, fmt->pad, fmt->which);\r\nif (format == NULL)\r\nreturn -EINVAL;\r\npreview_try_format(prev, fh, fmt->pad, &fmt->format, fmt->which);\r\n*format = fmt->format;\r\nif (fmt->pad == PREV_PAD_SINK) {\r\ncrop = __preview_get_crop(prev, fh, fmt->which);\r\ncrop->left = 0;\r\ncrop->top = 0;\r\ncrop->width = fmt->format.width;\r\ncrop->height = fmt->format.height;\r\npreview_try_crop(prev, &fmt->format, crop);\r\nformat = __preview_get_format(prev, fh, PREV_PAD_SOURCE,\r\nfmt->which);\r\npreview_try_format(prev, fh, PREV_PAD_SOURCE, format,\r\nfmt->which);\r\n}\r\nreturn 0;\r\n}\r\nstatic int preview_init_formats(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh)\r\n{\r\nstruct v4l2_subdev_format format;\r\nmemset(&format, 0, sizeof(format));\r\nformat.pad = PREV_PAD_SINK;\r\nformat.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;\r\nformat.format.code = MEDIA_BUS_FMT_SGRBG10_1X10;\r\nformat.format.width = 4096;\r\nformat.format.height = 4096;\r\npreview_set_format(sd, fh, &format);\r\nreturn 0;\r\n}\r\nstatic int preview_link_setup(struct media_entity *entity,\r\nconst struct media_pad *local,\r\nconst struct media_pad *remote, u32 flags)\r\n{\r\nstruct v4l2_subdev *sd = media_entity_to_v4l2_subdev(entity);\r\nstruct isp_prev_device *prev = v4l2_get_subdevdata(sd);\r\nswitch (local->index | media_entity_type(remote->entity)) {\r\ncase PREV_PAD_SINK | MEDIA_ENT_T_DEVNODE:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (prev->input == PREVIEW_INPUT_CCDC)\r\nreturn -EBUSY;\r\nprev->input = PREVIEW_INPUT_MEMORY;\r\n} else {\r\nif (prev->input == PREVIEW_INPUT_MEMORY)\r\nprev->input = PREVIEW_INPUT_NONE;\r\n}\r\nbreak;\r\ncase PREV_PAD_SINK | MEDIA_ENT_T_V4L2_SUBDEV:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (prev->input == PREVIEW_INPUT_MEMORY)\r\nreturn -EBUSY;\r\nprev->input = PREVIEW_INPUT_CCDC;\r\n} else {\r\nif (prev->input == PREVIEW_INPUT_CCDC)\r\nprev->input = PREVIEW_INPUT_NONE;\r\n}\r\nbreak;\r\ncase PREV_PAD_SOURCE | MEDIA_ENT_T_DEVNODE:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (prev->output & ~PREVIEW_OUTPUT_MEMORY)\r\nreturn -EBUSY;\r\nprev->output |= PREVIEW_OUTPUT_MEMORY;\r\n} else {\r\nprev->output &= ~PREVIEW_OUTPUT_MEMORY;\r\n}\r\nbreak;\r\ncase PREV_PAD_SOURCE | MEDIA_ENT_T_V4L2_SUBDEV:\r\nif (flags & MEDIA_LNK_FL_ENABLED) {\r\nif (prev->output & ~PREVIEW_OUTPUT_RESIZER)\r\nreturn -EBUSY;\r\nprev->output |= PREVIEW_OUTPUT_RESIZER;\r\n} else {\r\nprev->output &= ~PREVIEW_OUTPUT_RESIZER;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid omap3isp_preview_unregister_entities(struct isp_prev_device *prev)\r\n{\r\nv4l2_device_unregister_subdev(&prev->subdev);\r\nomap3isp_video_unregister(&prev->video_in);\r\nomap3isp_video_unregister(&prev->video_out);\r\n}\r\nint omap3isp_preview_register_entities(struct isp_prev_device *prev,\r\nstruct v4l2_device *vdev)\r\n{\r\nint ret;\r\nret = v4l2_device_register_subdev(vdev, &prev->subdev);\r\nif (ret < 0)\r\ngoto error;\r\nret = omap3isp_video_register(&prev->video_in, vdev);\r\nif (ret < 0)\r\ngoto error;\r\nret = omap3isp_video_register(&prev->video_out, vdev);\r\nif (ret < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nomap3isp_preview_unregister_entities(prev);\r\nreturn ret;\r\n}\r\nstatic int preview_init_entities(struct isp_prev_device *prev)\r\n{\r\nstruct v4l2_subdev *sd = &prev->subdev;\r\nstruct media_pad *pads = prev->pads;\r\nstruct media_entity *me = &sd->entity;\r\nint ret;\r\nprev->input = PREVIEW_INPUT_NONE;\r\nv4l2_subdev_init(sd, &preview_v4l2_ops);\r\nsd->internal_ops = &preview_v4l2_internal_ops;\r\nstrlcpy(sd->name, "OMAP3 ISP preview", sizeof(sd->name));\r\nsd->grp_id = 1 << 16;\r\nv4l2_set_subdevdata(sd, prev);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nv4l2_ctrl_handler_init(&prev->ctrls, 2);\r\nv4l2_ctrl_new_std(&prev->ctrls, &preview_ctrl_ops, V4L2_CID_BRIGHTNESS,\r\nISPPRV_BRIGHT_LOW, ISPPRV_BRIGHT_HIGH,\r\nISPPRV_BRIGHT_STEP, ISPPRV_BRIGHT_DEF);\r\nv4l2_ctrl_new_std(&prev->ctrls, &preview_ctrl_ops, V4L2_CID_CONTRAST,\r\nISPPRV_CONTRAST_LOW, ISPPRV_CONTRAST_HIGH,\r\nISPPRV_CONTRAST_STEP, ISPPRV_CONTRAST_DEF);\r\nv4l2_ctrl_handler_setup(&prev->ctrls);\r\nsd->ctrl_handler = &prev->ctrls;\r\npads[PREV_PAD_SINK].flags = MEDIA_PAD_FL_SINK\r\n| MEDIA_PAD_FL_MUST_CONNECT;\r\npads[PREV_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;\r\nme->ops = &preview_media_ops;\r\nret = media_entity_init(me, PREV_PADS_NUM, pads, 0);\r\nif (ret < 0)\r\nreturn ret;\r\npreview_init_formats(sd, NULL);\r\nprev->video_in.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nprev->video_in.ops = &preview_video_ops;\r\nprev->video_in.isp = to_isp_device(prev);\r\nprev->video_in.capture_mem = PAGE_ALIGN(4096 * 4096) * 2 * 3;\r\nprev->video_in.bpl_alignment = 64;\r\nprev->video_out.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nprev->video_out.ops = &preview_video_ops;\r\nprev->video_out.isp = to_isp_device(prev);\r\nprev->video_out.capture_mem = PAGE_ALIGN(4096 * 4096) * 2 * 3;\r\nprev->video_out.bpl_alignment = 32;\r\nret = omap3isp_video_init(&prev->video_in, "preview");\r\nif (ret < 0)\r\ngoto error_video_in;\r\nret = omap3isp_video_init(&prev->video_out, "preview");\r\nif (ret < 0)\r\ngoto error_video_out;\r\nret = media_entity_create_link(&prev->video_in.video.entity, 0,\r\n&prev->subdev.entity, PREV_PAD_SINK, 0);\r\nif (ret < 0)\r\ngoto error_link;\r\nret = media_entity_create_link(&prev->subdev.entity, PREV_PAD_SOURCE,\r\n&prev->video_out.video.entity, 0, 0);\r\nif (ret < 0)\r\ngoto error_link;\r\nreturn 0;\r\nerror_link:\r\nomap3isp_video_cleanup(&prev->video_out);\r\nerror_video_out:\r\nomap3isp_video_cleanup(&prev->video_in);\r\nerror_video_in:\r\nmedia_entity_cleanup(&prev->subdev.entity);\r\nreturn ret;\r\n}\r\nint omap3isp_preview_init(struct isp_device *isp)\r\n{\r\nstruct isp_prev_device *prev = &isp->isp_prev;\r\ninit_waitqueue_head(&prev->wait);\r\npreview_init_params(prev);\r\nreturn preview_init_entities(prev);\r\n}\r\nvoid omap3isp_preview_cleanup(struct isp_device *isp)\r\n{\r\nstruct isp_prev_device *prev = &isp->isp_prev;\r\nv4l2_ctrl_handler_free(&prev->ctrls);\r\nomap3isp_video_cleanup(&prev->video_in);\r\nomap3isp_video_cleanup(&prev->video_out);\r\nmedia_entity_cleanup(&prev->subdev.entity);\r\n}
