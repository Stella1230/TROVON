static u32 ehca_encode_hwpage_size(u32 pgsize)\r\n{\r\nint log = ilog2(pgsize);\r\nWARN_ON(log < 12 || log > 24 || log & 3);\r\nreturn (log - 12) / 4;\r\n}\r\nstatic u64 ehca_get_max_hwpage_size(struct ehca_shca *shca)\r\n{\r\nreturn rounddown_pow_of_two(shca->hca_cap_mr_pgsize);\r\n}\r\nstatic struct ehca_mr *ehca_mr_new(void)\r\n{\r\nstruct ehca_mr *me;\r\nme = kmem_cache_zalloc(mr_cache, GFP_KERNEL);\r\nif (me)\r\nspin_lock_init(&me->mrlock);\r\nelse\r\nehca_gen_err("alloc failed");\r\nreturn me;\r\n}\r\nstatic void ehca_mr_delete(struct ehca_mr *me)\r\n{\r\nkmem_cache_free(mr_cache, me);\r\n}\r\nstatic struct ehca_mw *ehca_mw_new(void)\r\n{\r\nstruct ehca_mw *me;\r\nme = kmem_cache_zalloc(mw_cache, GFP_KERNEL);\r\nif (me)\r\nspin_lock_init(&me->mwlock);\r\nelse\r\nehca_gen_err("alloc failed");\r\nreturn me;\r\n}\r\nstatic void ehca_mw_delete(struct ehca_mw *me)\r\n{\r\nkmem_cache_free(mw_cache, me);\r\n}\r\nstruct ib_mr *ehca_get_dma_mr(struct ib_pd *pd, int mr_access_flags)\r\n{\r\nstruct ib_mr *ib_mr;\r\nint ret;\r\nstruct ehca_mr *e_maxmr;\r\nstruct ehca_pd *e_pd = container_of(pd, struct ehca_pd, ib_pd);\r\nstruct ehca_shca *shca =\r\ncontainer_of(pd->device, struct ehca_shca, ib_device);\r\nif (shca->maxmr) {\r\ne_maxmr = ehca_mr_new();\r\nif (!e_maxmr) {\r\nehca_err(&shca->ib_device, "out of memory");\r\nib_mr = ERR_PTR(-ENOMEM);\r\ngoto get_dma_mr_exit0;\r\n}\r\nret = ehca_reg_maxmr(shca, e_maxmr,\r\n(void *)ehca_map_vaddr((void *)(KERNELBASE + PHYSICAL_START)),\r\nmr_access_flags, e_pd,\r\n&e_maxmr->ib.ib_mr.lkey,\r\n&e_maxmr->ib.ib_mr.rkey);\r\nif (ret) {\r\nehca_mr_delete(e_maxmr);\r\nib_mr = ERR_PTR(ret);\r\ngoto get_dma_mr_exit0;\r\n}\r\nib_mr = &e_maxmr->ib.ib_mr;\r\n} else {\r\nehca_err(&shca->ib_device, "no internal max-MR exist!");\r\nib_mr = ERR_PTR(-EINVAL);\r\ngoto get_dma_mr_exit0;\r\n}\r\nget_dma_mr_exit0:\r\nif (IS_ERR(ib_mr))\r\nehca_err(&shca->ib_device, "h_ret=%li pd=%p mr_access_flags=%x",\r\nPTR_ERR(ib_mr), pd, mr_access_flags);\r\nreturn ib_mr;\r\n}\r\nstruct ib_mr *ehca_reg_phys_mr(struct ib_pd *pd,\r\nstruct ib_phys_buf *phys_buf_array,\r\nint num_phys_buf,\r\nint mr_access_flags,\r\nu64 *iova_start)\r\n{\r\nstruct ib_mr *ib_mr;\r\nint ret;\r\nstruct ehca_mr *e_mr;\r\nstruct ehca_shca *shca =\r\ncontainer_of(pd->device, struct ehca_shca, ib_device);\r\nstruct ehca_pd *e_pd = container_of(pd, struct ehca_pd, ib_pd);\r\nu64 size;\r\nif ((num_phys_buf <= 0) || !phys_buf_array) {\r\nehca_err(pd->device, "bad input values: num_phys_buf=%x "\r\n"phys_buf_array=%p", num_phys_buf, phys_buf_array);\r\nib_mr = ERR_PTR(-EINVAL);\r\ngoto reg_phys_mr_exit0;\r\n}\r\nif (((mr_access_flags & IB_ACCESS_REMOTE_WRITE) &&\r\n!(mr_access_flags & IB_ACCESS_LOCAL_WRITE)) ||\r\n((mr_access_flags & IB_ACCESS_REMOTE_ATOMIC) &&\r\n!(mr_access_flags & IB_ACCESS_LOCAL_WRITE))) {\r\nehca_err(pd->device, "bad input values: mr_access_flags=%x",\r\nmr_access_flags);\r\nib_mr = ERR_PTR(-EINVAL);\r\ngoto reg_phys_mr_exit0;\r\n}\r\nret = ehca_mr_chk_buf_and_calc_size(phys_buf_array, num_phys_buf,\r\niova_start, &size);\r\nif (ret) {\r\nib_mr = ERR_PTR(ret);\r\ngoto reg_phys_mr_exit0;\r\n}\r\nif ((size == 0) ||\r\n(((u64)iova_start + size) < (u64)iova_start)) {\r\nehca_err(pd->device, "bad input values: size=%llx iova_start=%p",\r\nsize, iova_start);\r\nib_mr = ERR_PTR(-EINVAL);\r\ngoto reg_phys_mr_exit0;\r\n}\r\ne_mr = ehca_mr_new();\r\nif (!e_mr) {\r\nehca_err(pd->device, "out of memory");\r\nib_mr = ERR_PTR(-ENOMEM);\r\ngoto reg_phys_mr_exit0;\r\n}\r\nif (ehca_mr_is_maxmr(size, iova_start)) {\r\ne_mr->flags |= EHCA_MR_FLAG_MAXMR;\r\nret = ehca_reg_maxmr(shca, e_mr, iova_start, mr_access_flags,\r\ne_pd, &e_mr->ib.ib_mr.lkey,\r\n&e_mr->ib.ib_mr.rkey);\r\nif (ret) {\r\nib_mr = ERR_PTR(ret);\r\ngoto reg_phys_mr_exit1;\r\n}\r\n} else {\r\nstruct ehca_mr_pginfo pginfo;\r\nu32 num_kpages;\r\nu32 num_hwpages;\r\nu64 hw_pgsize;\r\nnum_kpages = NUM_CHUNKS(((u64)iova_start % PAGE_SIZE) + size,\r\nPAGE_SIZE);\r\nhw_pgsize = ehca_get_max_hwpage_size(shca);\r\nnum_hwpages = NUM_CHUNKS(((u64)iova_start % hw_pgsize) + size,\r\nhw_pgsize);\r\nmemset(&pginfo, 0, sizeof(pginfo));\r\npginfo.type = EHCA_MR_PGI_PHYS;\r\npginfo.num_kpages = num_kpages;\r\npginfo.hwpage_size = hw_pgsize;\r\npginfo.num_hwpages = num_hwpages;\r\npginfo.u.phy.num_phys_buf = num_phys_buf;\r\npginfo.u.phy.phys_buf_array = phys_buf_array;\r\npginfo.next_hwpage =\r\n((u64)iova_start & ~PAGE_MASK) / hw_pgsize;\r\nret = ehca_reg_mr(shca, e_mr, iova_start, size, mr_access_flags,\r\ne_pd, &pginfo, &e_mr->ib.ib_mr.lkey,\r\n&e_mr->ib.ib_mr.rkey, EHCA_REG_MR);\r\nif (ret) {\r\nib_mr = ERR_PTR(ret);\r\ngoto reg_phys_mr_exit1;\r\n}\r\n}\r\nreturn &e_mr->ib.ib_mr;\r\nreg_phys_mr_exit1:\r\nehca_mr_delete(e_mr);\r\nreg_phys_mr_exit0:\r\nif (IS_ERR(ib_mr))\r\nehca_err(pd->device, "h_ret=%li pd=%p phys_buf_array=%p "\r\n"num_phys_buf=%x mr_access_flags=%x iova_start=%p",\r\nPTR_ERR(ib_mr), pd, phys_buf_array,\r\nnum_phys_buf, mr_access_flags, iova_start);\r\nreturn ib_mr;\r\n}\r\nstruct ib_mr *ehca_reg_user_mr(struct ib_pd *pd, u64 start, u64 length,\r\nu64 virt, int mr_access_flags,\r\nstruct ib_udata *udata)\r\n{\r\nstruct ib_mr *ib_mr;\r\nstruct ehca_mr *e_mr;\r\nstruct ehca_shca *shca =\r\ncontainer_of(pd->device, struct ehca_shca, ib_device);\r\nstruct ehca_pd *e_pd = container_of(pd, struct ehca_pd, ib_pd);\r\nstruct ehca_mr_pginfo pginfo;\r\nint ret, page_shift;\r\nu32 num_kpages;\r\nu32 num_hwpages;\r\nu64 hwpage_size;\r\nif (!pd) {\r\nehca_gen_err("bad pd=%p", pd);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\nif (((mr_access_flags & IB_ACCESS_REMOTE_WRITE) &&\r\n!(mr_access_flags & IB_ACCESS_LOCAL_WRITE)) ||\r\n((mr_access_flags & IB_ACCESS_REMOTE_ATOMIC) &&\r\n!(mr_access_flags & IB_ACCESS_LOCAL_WRITE))) {\r\nehca_err(pd->device, "bad input values: mr_access_flags=%x",\r\nmr_access_flags);\r\nib_mr = ERR_PTR(-EINVAL);\r\ngoto reg_user_mr_exit0;\r\n}\r\nif (length == 0 || virt + length < virt) {\r\nehca_err(pd->device, "bad input values: length=%llx "\r\n"virt_base=%llx", length, virt);\r\nib_mr = ERR_PTR(-EINVAL);\r\ngoto reg_user_mr_exit0;\r\n}\r\ne_mr = ehca_mr_new();\r\nif (!e_mr) {\r\nehca_err(pd->device, "out of memory");\r\nib_mr = ERR_PTR(-ENOMEM);\r\ngoto reg_user_mr_exit0;\r\n}\r\ne_mr->umem = ib_umem_get(pd->uobject->context, start, length,\r\nmr_access_flags, 0);\r\nif (IS_ERR(e_mr->umem)) {\r\nib_mr = (void *)e_mr->umem;\r\ngoto reg_user_mr_exit1;\r\n}\r\nif (e_mr->umem->page_size != PAGE_SIZE) {\r\nehca_err(pd->device, "page size not supported, "\r\n"e_mr->umem->page_size=%x", e_mr->umem->page_size);\r\nib_mr = ERR_PTR(-EINVAL);\r\ngoto reg_user_mr_exit2;\r\n}\r\nnum_kpages = NUM_CHUNKS((virt % PAGE_SIZE) + length, PAGE_SIZE);\r\npage_shift = PAGE_SHIFT;\r\nif (e_mr->umem->hugetlb) {\r\npage_shift = (fls64(length - 1) + 3) & ~3;\r\npage_shift = min(max(page_shift, EHCA_MR_PGSHIFT4K),\r\nEHCA_MR_PGSHIFT16M);\r\n}\r\nhwpage_size = 1UL << page_shift;\r\nwhile (!(hwpage_size & shca->hca_cap_mr_pgsize))\r\nhwpage_size >>= 4;\r\nreg_user_mr_fallback:\r\nnum_hwpages = NUM_CHUNKS((virt % hwpage_size) + length, hwpage_size);\r\nmemset(&pginfo, 0, sizeof(pginfo));\r\npginfo.type = EHCA_MR_PGI_USER;\r\npginfo.hwpage_size = hwpage_size;\r\npginfo.num_kpages = num_kpages;\r\npginfo.num_hwpages = num_hwpages;\r\npginfo.u.usr.region = e_mr->umem;\r\npginfo.next_hwpage = ib_umem_offset(e_mr->umem) / hwpage_size;\r\npginfo.u.usr.next_sg = pginfo.u.usr.region->sg_head.sgl;\r\nret = ehca_reg_mr(shca, e_mr, (u64 *)virt, length, mr_access_flags,\r\ne_pd, &pginfo, &e_mr->ib.ib_mr.lkey,\r\n&e_mr->ib.ib_mr.rkey, EHCA_REG_MR);\r\nif (ret == -EINVAL && pginfo.hwpage_size > PAGE_SIZE) {\r\nehca_warn(pd->device, "failed to register mr "\r\n"with hwpage_size=%llx", hwpage_size);\r\nehca_info(pd->device, "try to register mr with "\r\n"kpage_size=%lx", PAGE_SIZE);\r\nhwpage_size = PAGE_SIZE;\r\ngoto reg_user_mr_fallback;\r\n}\r\nif (ret) {\r\nib_mr = ERR_PTR(ret);\r\ngoto reg_user_mr_exit2;\r\n}\r\nreturn &e_mr->ib.ib_mr;\r\nreg_user_mr_exit2:\r\nib_umem_release(e_mr->umem);\r\nreg_user_mr_exit1:\r\nehca_mr_delete(e_mr);\r\nreg_user_mr_exit0:\r\nif (IS_ERR(ib_mr))\r\nehca_err(pd->device, "rc=%li pd=%p mr_access_flags=%x udata=%p",\r\nPTR_ERR(ib_mr), pd, mr_access_flags, udata);\r\nreturn ib_mr;\r\n}\r\nint ehca_rereg_phys_mr(struct ib_mr *mr,\r\nint mr_rereg_mask,\r\nstruct ib_pd *pd,\r\nstruct ib_phys_buf *phys_buf_array,\r\nint num_phys_buf,\r\nint mr_access_flags,\r\nu64 *iova_start)\r\n{\r\nint ret;\r\nstruct ehca_shca *shca =\r\ncontainer_of(mr->device, struct ehca_shca, ib_device);\r\nstruct ehca_mr *e_mr = container_of(mr, struct ehca_mr, ib.ib_mr);\r\nu64 new_size;\r\nu64 *new_start;\r\nu32 new_acl;\r\nstruct ehca_pd *new_pd;\r\nu32 tmp_lkey, tmp_rkey;\r\nunsigned long sl_flags;\r\nu32 num_kpages = 0;\r\nu32 num_hwpages = 0;\r\nstruct ehca_mr_pginfo pginfo;\r\nif (!(mr_rereg_mask & IB_MR_REREG_TRANS)) {\r\nehca_err(mr->device, "rereg without IB_MR_REREG_TRANS not "\r\n"supported yet, mr_rereg_mask=%x", mr_rereg_mask);\r\nret = -EINVAL;\r\ngoto rereg_phys_mr_exit0;\r\n}\r\nif (mr_rereg_mask & IB_MR_REREG_PD) {\r\nif (!pd) {\r\nehca_err(mr->device, "rereg with bad pd, pd=%p "\r\n"mr_rereg_mask=%x", pd, mr_rereg_mask);\r\nret = -EINVAL;\r\ngoto rereg_phys_mr_exit0;\r\n}\r\n}\r\nif ((mr_rereg_mask &\r\n~(IB_MR_REREG_TRANS | IB_MR_REREG_PD | IB_MR_REREG_ACCESS)) ||\r\n(mr_rereg_mask == 0)) {\r\nret = -EINVAL;\r\ngoto rereg_phys_mr_exit0;\r\n}\r\nif (e_mr == shca->maxmr) {\r\nehca_err(mr->device, "rereg internal max-MR impossible, mr=%p "\r\n"shca->maxmr=%p mr->lkey=%x",\r\nmr, shca->maxmr, mr->lkey);\r\nret = -EINVAL;\r\ngoto rereg_phys_mr_exit0;\r\n}\r\nif (mr_rereg_mask & IB_MR_REREG_TRANS) {\r\nif (e_mr->flags & EHCA_MR_FLAG_FMR) {\r\nehca_err(mr->device, "not supported for FMR, mr=%p "\r\n"flags=%x", mr, e_mr->flags);\r\nret = -EINVAL;\r\ngoto rereg_phys_mr_exit0;\r\n}\r\nif (!phys_buf_array || num_phys_buf <= 0) {\r\nehca_err(mr->device, "bad input values mr_rereg_mask=%x"\r\n" phys_buf_array=%p num_phys_buf=%x",\r\nmr_rereg_mask, phys_buf_array, num_phys_buf);\r\nret = -EINVAL;\r\ngoto rereg_phys_mr_exit0;\r\n}\r\n}\r\nif ((mr_rereg_mask & IB_MR_REREG_ACCESS) &&\r\n(((mr_access_flags & IB_ACCESS_REMOTE_WRITE) &&\r\n!(mr_access_flags & IB_ACCESS_LOCAL_WRITE)) ||\r\n((mr_access_flags & IB_ACCESS_REMOTE_ATOMIC) &&\r\n!(mr_access_flags & IB_ACCESS_LOCAL_WRITE)))) {\r\nehca_err(mr->device, "bad input values: mr_rereg_mask=%x "\r\n"mr_access_flags=%x", mr_rereg_mask, mr_access_flags);\r\nret = -EINVAL;\r\ngoto rereg_phys_mr_exit0;\r\n}\r\nspin_lock_irqsave(&e_mr->mrlock, sl_flags);\r\nnew_start = e_mr->start;\r\nnew_size = e_mr->size;\r\nnew_acl = e_mr->acl;\r\nnew_pd = container_of(mr->pd, struct ehca_pd, ib_pd);\r\nif (mr_rereg_mask & IB_MR_REREG_TRANS) {\r\nu64 hw_pgsize = ehca_get_max_hwpage_size(shca);\r\nnew_start = iova_start;\r\nret = ehca_mr_chk_buf_and_calc_size(phys_buf_array,\r\nnum_phys_buf, iova_start,\r\n&new_size);\r\nif (ret)\r\ngoto rereg_phys_mr_exit1;\r\nif ((new_size == 0) ||\r\n(((u64)iova_start + new_size) < (u64)iova_start)) {\r\nehca_err(mr->device, "bad input values: new_size=%llx "\r\n"iova_start=%p", new_size, iova_start);\r\nret = -EINVAL;\r\ngoto rereg_phys_mr_exit1;\r\n}\r\nnum_kpages = NUM_CHUNKS(((u64)new_start % PAGE_SIZE) +\r\nnew_size, PAGE_SIZE);\r\nnum_hwpages = NUM_CHUNKS(((u64)new_start % hw_pgsize) +\r\nnew_size, hw_pgsize);\r\nmemset(&pginfo, 0, sizeof(pginfo));\r\npginfo.type = EHCA_MR_PGI_PHYS;\r\npginfo.num_kpages = num_kpages;\r\npginfo.hwpage_size = hw_pgsize;\r\npginfo.num_hwpages = num_hwpages;\r\npginfo.u.phy.num_phys_buf = num_phys_buf;\r\npginfo.u.phy.phys_buf_array = phys_buf_array;\r\npginfo.next_hwpage =\r\n((u64)iova_start & ~PAGE_MASK) / hw_pgsize;\r\n}\r\nif (mr_rereg_mask & IB_MR_REREG_ACCESS)\r\nnew_acl = mr_access_flags;\r\nif (mr_rereg_mask & IB_MR_REREG_PD)\r\nnew_pd = container_of(pd, struct ehca_pd, ib_pd);\r\nret = ehca_rereg_mr(shca, e_mr, new_start, new_size, new_acl,\r\nnew_pd, &pginfo, &tmp_lkey, &tmp_rkey);\r\nif (ret)\r\ngoto rereg_phys_mr_exit1;\r\nif (mr_rereg_mask & IB_MR_REREG_PD)\r\nmr->pd = pd;\r\nmr->lkey = tmp_lkey;\r\nmr->rkey = tmp_rkey;\r\nrereg_phys_mr_exit1:\r\nspin_unlock_irqrestore(&e_mr->mrlock, sl_flags);\r\nrereg_phys_mr_exit0:\r\nif (ret)\r\nehca_err(mr->device, "ret=%i mr=%p mr_rereg_mask=%x pd=%p "\r\n"phys_buf_array=%p num_phys_buf=%x mr_access_flags=%x "\r\n"iova_start=%p",\r\nret, mr, mr_rereg_mask, pd, phys_buf_array,\r\nnum_phys_buf, mr_access_flags, iova_start);\r\nreturn ret;\r\n}\r\nint ehca_query_mr(struct ib_mr *mr, struct ib_mr_attr *mr_attr)\r\n{\r\nint ret = 0;\r\nu64 h_ret;\r\nstruct ehca_shca *shca =\r\ncontainer_of(mr->device, struct ehca_shca, ib_device);\r\nstruct ehca_mr *e_mr = container_of(mr, struct ehca_mr, ib.ib_mr);\r\nunsigned long sl_flags;\r\nstruct ehca_mr_hipzout_parms hipzout;\r\nif ((e_mr->flags & EHCA_MR_FLAG_FMR)) {\r\nehca_err(mr->device, "not supported for FMR, mr=%p e_mr=%p "\r\n"e_mr->flags=%x", mr, e_mr, e_mr->flags);\r\nret = -EINVAL;\r\ngoto query_mr_exit0;\r\n}\r\nmemset(mr_attr, 0, sizeof(struct ib_mr_attr));\r\nspin_lock_irqsave(&e_mr->mrlock, sl_flags);\r\nh_ret = hipz_h_query_mr(shca->ipz_hca_handle, e_mr, &hipzout);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(mr->device, "hipz_mr_query failed, h_ret=%lli mr=%p "\r\n"hca_hndl=%llx mr_hndl=%llx lkey=%x",\r\nh_ret, mr, shca->ipz_hca_handle.handle,\r\ne_mr->ipz_mr_handle.handle, mr->lkey);\r\nret = ehca2ib_return_code(h_ret);\r\ngoto query_mr_exit1;\r\n}\r\nmr_attr->pd = mr->pd;\r\nmr_attr->device_virt_addr = hipzout.vaddr;\r\nmr_attr->size = hipzout.len;\r\nmr_attr->lkey = hipzout.lkey;\r\nmr_attr->rkey = hipzout.rkey;\r\nehca_mrmw_reverse_map_acl(&hipzout.acl, &mr_attr->mr_access_flags);\r\nquery_mr_exit1:\r\nspin_unlock_irqrestore(&e_mr->mrlock, sl_flags);\r\nquery_mr_exit0:\r\nif (ret)\r\nehca_err(mr->device, "ret=%i mr=%p mr_attr=%p",\r\nret, mr, mr_attr);\r\nreturn ret;\r\n}\r\nint ehca_dereg_mr(struct ib_mr *mr)\r\n{\r\nint ret = 0;\r\nu64 h_ret;\r\nstruct ehca_shca *shca =\r\ncontainer_of(mr->device, struct ehca_shca, ib_device);\r\nstruct ehca_mr *e_mr = container_of(mr, struct ehca_mr, ib.ib_mr);\r\nif ((e_mr->flags & EHCA_MR_FLAG_FMR)) {\r\nehca_err(mr->device, "not supported for FMR, mr=%p e_mr=%p "\r\n"e_mr->flags=%x", mr, e_mr, e_mr->flags);\r\nret = -EINVAL;\r\ngoto dereg_mr_exit0;\r\n} else if (e_mr == shca->maxmr) {\r\nehca_err(mr->device, "dereg internal max-MR impossible, mr=%p "\r\n"shca->maxmr=%p mr->lkey=%x",\r\nmr, shca->maxmr, mr->lkey);\r\nret = -EINVAL;\r\ngoto dereg_mr_exit0;\r\n}\r\nh_ret = hipz_h_free_resource_mr(shca->ipz_hca_handle, e_mr);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(mr->device, "hipz_free_mr failed, h_ret=%lli shca=%p "\r\n"e_mr=%p hca_hndl=%llx mr_hndl=%llx mr->lkey=%x",\r\nh_ret, shca, e_mr, shca->ipz_hca_handle.handle,\r\ne_mr->ipz_mr_handle.handle, mr->lkey);\r\nret = ehca2ib_return_code(h_ret);\r\ngoto dereg_mr_exit0;\r\n}\r\nif (e_mr->umem)\r\nib_umem_release(e_mr->umem);\r\nehca_mr_delete(e_mr);\r\ndereg_mr_exit0:\r\nif (ret)\r\nehca_err(mr->device, "ret=%i mr=%p", ret, mr);\r\nreturn ret;\r\n}\r\nstruct ib_mw *ehca_alloc_mw(struct ib_pd *pd, enum ib_mw_type type)\r\n{\r\nstruct ib_mw *ib_mw;\r\nu64 h_ret;\r\nstruct ehca_mw *e_mw;\r\nstruct ehca_pd *e_pd = container_of(pd, struct ehca_pd, ib_pd);\r\nstruct ehca_shca *shca =\r\ncontainer_of(pd->device, struct ehca_shca, ib_device);\r\nstruct ehca_mw_hipzout_parms hipzout;\r\nif (type != IB_MW_TYPE_1)\r\nreturn ERR_PTR(-EINVAL);\r\ne_mw = ehca_mw_new();\r\nif (!e_mw) {\r\nib_mw = ERR_PTR(-ENOMEM);\r\ngoto alloc_mw_exit0;\r\n}\r\nh_ret = hipz_h_alloc_resource_mw(shca->ipz_hca_handle, e_mw,\r\ne_pd->fw_pd, &hipzout);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(pd->device, "hipz_mw_allocate failed, h_ret=%lli "\r\n"shca=%p hca_hndl=%llx mw=%p",\r\nh_ret, shca, shca->ipz_hca_handle.handle, e_mw);\r\nib_mw = ERR_PTR(ehca2ib_return_code(h_ret));\r\ngoto alloc_mw_exit1;\r\n}\r\ne_mw->ipz_mw_handle = hipzout.handle;\r\ne_mw->ib_mw.rkey = hipzout.rkey;\r\nreturn &e_mw->ib_mw;\r\nalloc_mw_exit1:\r\nehca_mw_delete(e_mw);\r\nalloc_mw_exit0:\r\nif (IS_ERR(ib_mw))\r\nehca_err(pd->device, "h_ret=%li pd=%p", PTR_ERR(ib_mw), pd);\r\nreturn ib_mw;\r\n}\r\nint ehca_bind_mw(struct ib_qp *qp,\r\nstruct ib_mw *mw,\r\nstruct ib_mw_bind *mw_bind)\r\n{\r\nehca_gen_err("bind MW currently not supported by HCAD");\r\nreturn -EPERM;\r\n}\r\nint ehca_dealloc_mw(struct ib_mw *mw)\r\n{\r\nu64 h_ret;\r\nstruct ehca_shca *shca =\r\ncontainer_of(mw->device, struct ehca_shca, ib_device);\r\nstruct ehca_mw *e_mw = container_of(mw, struct ehca_mw, ib_mw);\r\nh_ret = hipz_h_free_resource_mw(shca->ipz_hca_handle, e_mw);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(mw->device, "hipz_free_mw failed, h_ret=%lli shca=%p "\r\n"mw=%p rkey=%x hca_hndl=%llx mw_hndl=%llx",\r\nh_ret, shca, mw, mw->rkey, shca->ipz_hca_handle.handle,\r\ne_mw->ipz_mw_handle.handle);\r\nreturn ehca2ib_return_code(h_ret);\r\n}\r\nehca_mw_delete(e_mw);\r\nreturn 0;\r\n}\r\nstruct ib_fmr *ehca_alloc_fmr(struct ib_pd *pd,\r\nint mr_access_flags,\r\nstruct ib_fmr_attr *fmr_attr)\r\n{\r\nstruct ib_fmr *ib_fmr;\r\nstruct ehca_shca *shca =\r\ncontainer_of(pd->device, struct ehca_shca, ib_device);\r\nstruct ehca_pd *e_pd = container_of(pd, struct ehca_pd, ib_pd);\r\nstruct ehca_mr *e_fmr;\r\nint ret;\r\nu32 tmp_lkey, tmp_rkey;\r\nstruct ehca_mr_pginfo pginfo;\r\nu64 hw_pgsize;\r\nif (((mr_access_flags & IB_ACCESS_REMOTE_WRITE) &&\r\n!(mr_access_flags & IB_ACCESS_LOCAL_WRITE)) ||\r\n((mr_access_flags & IB_ACCESS_REMOTE_ATOMIC) &&\r\n!(mr_access_flags & IB_ACCESS_LOCAL_WRITE))) {\r\nehca_err(pd->device, "bad input values: mr_access_flags=%x",\r\nmr_access_flags);\r\nib_fmr = ERR_PTR(-EINVAL);\r\ngoto alloc_fmr_exit0;\r\n}\r\nif (mr_access_flags & IB_ACCESS_MW_BIND) {\r\nehca_err(pd->device, "bad input values: mr_access_flags=%x",\r\nmr_access_flags);\r\nib_fmr = ERR_PTR(-EINVAL);\r\ngoto alloc_fmr_exit0;\r\n}\r\nif ((fmr_attr->max_pages == 0) || (fmr_attr->max_maps == 0)) {\r\nehca_err(pd->device, "bad input values: fmr_attr->max_pages=%x "\r\n"fmr_attr->max_maps=%x fmr_attr->page_shift=%x",\r\nfmr_attr->max_pages, fmr_attr->max_maps,\r\nfmr_attr->page_shift);\r\nib_fmr = ERR_PTR(-EINVAL);\r\ngoto alloc_fmr_exit0;\r\n}\r\nhw_pgsize = 1 << fmr_attr->page_shift;\r\nif (!(hw_pgsize & shca->hca_cap_mr_pgsize)) {\r\nehca_err(pd->device, "unsupported fmr_attr->page_shift=%x",\r\nfmr_attr->page_shift);\r\nib_fmr = ERR_PTR(-EINVAL);\r\ngoto alloc_fmr_exit0;\r\n}\r\ne_fmr = ehca_mr_new();\r\nif (!e_fmr) {\r\nib_fmr = ERR_PTR(-ENOMEM);\r\ngoto alloc_fmr_exit0;\r\n}\r\ne_fmr->flags |= EHCA_MR_FLAG_FMR;\r\nmemset(&pginfo, 0, sizeof(pginfo));\r\npginfo.hwpage_size = hw_pgsize;\r\nret = ehca_reg_mr(shca, e_fmr, NULL,\r\nfmr_attr->max_pages * (1 << fmr_attr->page_shift),\r\nmr_access_flags, e_pd, &pginfo,\r\n&tmp_lkey, &tmp_rkey, EHCA_REG_MR);\r\nif (ret) {\r\nib_fmr = ERR_PTR(ret);\r\ngoto alloc_fmr_exit1;\r\n}\r\ne_fmr->hwpage_size = hw_pgsize;\r\ne_fmr->fmr_page_size = 1 << fmr_attr->page_shift;\r\ne_fmr->fmr_max_pages = fmr_attr->max_pages;\r\ne_fmr->fmr_max_maps = fmr_attr->max_maps;\r\ne_fmr->fmr_map_cnt = 0;\r\nreturn &e_fmr->ib.ib_fmr;\r\nalloc_fmr_exit1:\r\nehca_mr_delete(e_fmr);\r\nalloc_fmr_exit0:\r\nreturn ib_fmr;\r\n}\r\nint ehca_map_phys_fmr(struct ib_fmr *fmr,\r\nu64 *page_list,\r\nint list_len,\r\nu64 iova)\r\n{\r\nint ret;\r\nstruct ehca_shca *shca =\r\ncontainer_of(fmr->device, struct ehca_shca, ib_device);\r\nstruct ehca_mr *e_fmr = container_of(fmr, struct ehca_mr, ib.ib_fmr);\r\nstruct ehca_pd *e_pd = container_of(fmr->pd, struct ehca_pd, ib_pd);\r\nstruct ehca_mr_pginfo pginfo;\r\nu32 tmp_lkey, tmp_rkey;\r\nif (!(e_fmr->flags & EHCA_MR_FLAG_FMR)) {\r\nehca_err(fmr->device, "not a FMR, e_fmr=%p e_fmr->flags=%x",\r\ne_fmr, e_fmr->flags);\r\nret = -EINVAL;\r\ngoto map_phys_fmr_exit0;\r\n}\r\nret = ehca_fmr_check_page_list(e_fmr, page_list, list_len);\r\nif (ret)\r\ngoto map_phys_fmr_exit0;\r\nif (iova % e_fmr->fmr_page_size) {\r\nehca_err(fmr->device, "bad iova, iova=%llx fmr_page_size=%x",\r\niova, e_fmr->fmr_page_size);\r\nret = -EINVAL;\r\ngoto map_phys_fmr_exit0;\r\n}\r\nif (e_fmr->fmr_map_cnt >= e_fmr->fmr_max_maps) {\r\nehca_info(fmr->device, "map limit exceeded, fmr=%p "\r\n"e_fmr->fmr_map_cnt=%x e_fmr->fmr_max_maps=%x",\r\nfmr, e_fmr->fmr_map_cnt, e_fmr->fmr_max_maps);\r\n}\r\nmemset(&pginfo, 0, sizeof(pginfo));\r\npginfo.type = EHCA_MR_PGI_FMR;\r\npginfo.num_kpages = list_len;\r\npginfo.hwpage_size = e_fmr->hwpage_size;\r\npginfo.num_hwpages =\r\nlist_len * e_fmr->fmr_page_size / pginfo.hwpage_size;\r\npginfo.u.fmr.page_list = page_list;\r\npginfo.next_hwpage =\r\n(iova & (e_fmr->fmr_page_size-1)) / pginfo.hwpage_size;\r\npginfo.u.fmr.fmr_pgsize = e_fmr->fmr_page_size;\r\nret = ehca_rereg_mr(shca, e_fmr, (u64 *)iova,\r\nlist_len * e_fmr->fmr_page_size,\r\ne_fmr->acl, e_pd, &pginfo, &tmp_lkey, &tmp_rkey);\r\nif (ret)\r\ngoto map_phys_fmr_exit0;\r\ne_fmr->fmr_map_cnt++;\r\ne_fmr->ib.ib_fmr.lkey = tmp_lkey;\r\ne_fmr->ib.ib_fmr.rkey = tmp_rkey;\r\nreturn 0;\r\nmap_phys_fmr_exit0:\r\nif (ret)\r\nehca_err(fmr->device, "ret=%i fmr=%p page_list=%p list_len=%x "\r\n"iova=%llx", ret, fmr, page_list, list_len, iova);\r\nreturn ret;\r\n}\r\nint ehca_unmap_fmr(struct list_head *fmr_list)\r\n{\r\nint ret = 0;\r\nstruct ib_fmr *ib_fmr;\r\nstruct ehca_shca *shca = NULL;\r\nstruct ehca_shca *prev_shca;\r\nstruct ehca_mr *e_fmr;\r\nu32 num_fmr = 0;\r\nu32 unmap_fmr_cnt = 0;\r\nlist_for_each_entry(ib_fmr, fmr_list, list) {\r\nprev_shca = shca;\r\nshca = container_of(ib_fmr->device, struct ehca_shca,\r\nib_device);\r\ne_fmr = container_of(ib_fmr, struct ehca_mr, ib.ib_fmr);\r\nif ((shca != prev_shca) && prev_shca) {\r\nehca_err(&shca->ib_device, "SHCA mismatch, shca=%p "\r\n"prev_shca=%p e_fmr=%p",\r\nshca, prev_shca, e_fmr);\r\nret = -EINVAL;\r\ngoto unmap_fmr_exit0;\r\n}\r\nif (!(e_fmr->flags & EHCA_MR_FLAG_FMR)) {\r\nehca_err(&shca->ib_device, "not a FMR, e_fmr=%p "\r\n"e_fmr->flags=%x", e_fmr, e_fmr->flags);\r\nret = -EINVAL;\r\ngoto unmap_fmr_exit0;\r\n}\r\nnum_fmr++;\r\n}\r\nlist_for_each_entry(ib_fmr, fmr_list, list) {\r\nunmap_fmr_cnt++;\r\ne_fmr = container_of(ib_fmr, struct ehca_mr, ib.ib_fmr);\r\nshca = container_of(ib_fmr->device, struct ehca_shca,\r\nib_device);\r\nret = ehca_unmap_one_fmr(shca, e_fmr);\r\nif (ret) {\r\nehca_err(&shca->ib_device, "unmap of one FMR failed, "\r\n"stop rest, e_fmr=%p num_fmr=%x "\r\n"unmap_fmr_cnt=%x lkey=%x", e_fmr, num_fmr,\r\nunmap_fmr_cnt, e_fmr->ib.ib_fmr.lkey);\r\ngoto unmap_fmr_exit0;\r\n}\r\n}\r\nunmap_fmr_exit0:\r\nif (ret)\r\nehca_gen_err("ret=%i fmr_list=%p num_fmr=%x unmap_fmr_cnt=%x",\r\nret, fmr_list, num_fmr, unmap_fmr_cnt);\r\nreturn ret;\r\n}\r\nint ehca_dealloc_fmr(struct ib_fmr *fmr)\r\n{\r\nint ret;\r\nu64 h_ret;\r\nstruct ehca_shca *shca =\r\ncontainer_of(fmr->device, struct ehca_shca, ib_device);\r\nstruct ehca_mr *e_fmr = container_of(fmr, struct ehca_mr, ib.ib_fmr);\r\nif (!(e_fmr->flags & EHCA_MR_FLAG_FMR)) {\r\nehca_err(fmr->device, "not a FMR, e_fmr=%p e_fmr->flags=%x",\r\ne_fmr, e_fmr->flags);\r\nret = -EINVAL;\r\ngoto free_fmr_exit0;\r\n}\r\nh_ret = hipz_h_free_resource_mr(shca->ipz_hca_handle, e_fmr);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(fmr->device, "hipz_free_mr failed, h_ret=%lli e_fmr=%p "\r\n"hca_hndl=%llx fmr_hndl=%llx fmr->lkey=%x",\r\nh_ret, e_fmr, shca->ipz_hca_handle.handle,\r\ne_fmr->ipz_mr_handle.handle, fmr->lkey);\r\nret = ehca2ib_return_code(h_ret);\r\ngoto free_fmr_exit0;\r\n}\r\nehca_mr_delete(e_fmr);\r\nreturn 0;\r\nfree_fmr_exit0:\r\nif (ret)\r\nehca_err(&shca->ib_device, "ret=%i fmr=%p", ret, fmr);\r\nreturn ret;\r\n}\r\nint ehca_reg_mr(struct ehca_shca *shca,\r\nstruct ehca_mr *e_mr,\r\nu64 *iova_start,\r\nu64 size,\r\nint acl,\r\nstruct ehca_pd *e_pd,\r\nstruct ehca_mr_pginfo *pginfo,\r\nu32 *lkey,\r\nu32 *rkey,\r\nenum ehca_reg_type reg_type)\r\n{\r\nint ret;\r\nu64 h_ret;\r\nu32 hipz_acl;\r\nstruct ehca_mr_hipzout_parms hipzout;\r\nehca_mrmw_map_acl(acl, &hipz_acl);\r\nehca_mrmw_set_pgsize_hipz_acl(pginfo->hwpage_size, &hipz_acl);\r\nif (ehca_use_hp_mr == 1)\r\nhipz_acl |= 0x00000001;\r\nh_ret = hipz_h_alloc_resource_mr(shca->ipz_hca_handle, e_mr,\r\n(u64)iova_start, size, hipz_acl,\r\ne_pd->fw_pd, &hipzout);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(&shca->ib_device, "hipz_alloc_mr failed, h_ret=%lli "\r\n"hca_hndl=%llx", h_ret, shca->ipz_hca_handle.handle);\r\nret = ehca2ib_return_code(h_ret);\r\ngoto ehca_reg_mr_exit0;\r\n}\r\ne_mr->ipz_mr_handle = hipzout.handle;\r\nif (reg_type == EHCA_REG_BUSMAP_MR)\r\nret = ehca_reg_bmap_mr_rpages(shca, e_mr, pginfo);\r\nelse if (reg_type == EHCA_REG_MR)\r\nret = ehca_reg_mr_rpages(shca, e_mr, pginfo);\r\nelse\r\nret = -EINVAL;\r\nif (ret)\r\ngoto ehca_reg_mr_exit1;\r\ne_mr->num_kpages = pginfo->num_kpages;\r\ne_mr->num_hwpages = pginfo->num_hwpages;\r\ne_mr->hwpage_size = pginfo->hwpage_size;\r\ne_mr->start = iova_start;\r\ne_mr->size = size;\r\ne_mr->acl = acl;\r\n*lkey = hipzout.lkey;\r\n*rkey = hipzout.rkey;\r\nreturn 0;\r\nehca_reg_mr_exit1:\r\nh_ret = hipz_h_free_resource_mr(shca->ipz_hca_handle, e_mr);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(&shca->ib_device, "h_ret=%lli shca=%p e_mr=%p "\r\n"iova_start=%p size=%llx acl=%x e_pd=%p lkey=%x "\r\n"pginfo=%p num_kpages=%llx num_hwpages=%llx ret=%i",\r\nh_ret, shca, e_mr, iova_start, size, acl, e_pd,\r\nhipzout.lkey, pginfo, pginfo->num_kpages,\r\npginfo->num_hwpages, ret);\r\nehca_err(&shca->ib_device, "internal error in ehca_reg_mr, "\r\n"not recoverable");\r\n}\r\nehca_reg_mr_exit0:\r\nif (ret)\r\nehca_err(&shca->ib_device, "ret=%i shca=%p e_mr=%p "\r\n"iova_start=%p size=%llx acl=%x e_pd=%p pginfo=%p "\r\n"num_kpages=%llx num_hwpages=%llx",\r\nret, shca, e_mr, iova_start, size, acl, e_pd, pginfo,\r\npginfo->num_kpages, pginfo->num_hwpages);\r\nreturn ret;\r\n}\r\nint ehca_reg_mr_rpages(struct ehca_shca *shca,\r\nstruct ehca_mr *e_mr,\r\nstruct ehca_mr_pginfo *pginfo)\r\n{\r\nint ret = 0;\r\nu64 h_ret;\r\nu32 rnum;\r\nu64 rpage;\r\nu32 i;\r\nu64 *kpage;\r\nif (!pginfo->num_hwpages)\r\nreturn 0;\r\nkpage = ehca_alloc_fw_ctrlblock(GFP_KERNEL);\r\nif (!kpage) {\r\nehca_err(&shca->ib_device, "kpage alloc failed");\r\nret = -ENOMEM;\r\ngoto ehca_reg_mr_rpages_exit0;\r\n}\r\nfor (i = 0; i < NUM_CHUNKS(pginfo->num_hwpages, MAX_RPAGES); i++) {\r\nif (i == NUM_CHUNKS(pginfo->num_hwpages, MAX_RPAGES) - 1) {\r\nrnum = pginfo->num_hwpages % MAX_RPAGES;\r\nif (rnum == 0)\r\nrnum = MAX_RPAGES;\r\n} else\r\nrnum = MAX_RPAGES;\r\nret = ehca_set_pagebuf(pginfo, rnum, kpage);\r\nif (ret) {\r\nehca_err(&shca->ib_device, "ehca_set_pagebuf "\r\n"bad rc, ret=%i rnum=%x kpage=%p",\r\nret, rnum, kpage);\r\ngoto ehca_reg_mr_rpages_exit1;\r\n}\r\nif (rnum > 1) {\r\nrpage = __pa(kpage);\r\nif (!rpage) {\r\nehca_err(&shca->ib_device, "kpage=%p i=%x",\r\nkpage, i);\r\nret = -EFAULT;\r\ngoto ehca_reg_mr_rpages_exit1;\r\n}\r\n} else\r\nrpage = *kpage;\r\nh_ret = hipz_h_register_rpage_mr(\r\nshca->ipz_hca_handle, e_mr,\r\nehca_encode_hwpage_size(pginfo->hwpage_size),\r\n0, rpage, rnum);\r\nif (i == NUM_CHUNKS(pginfo->num_hwpages, MAX_RPAGES) - 1) {\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(&shca->ib_device, "last "\r\n"hipz_reg_rpage_mr failed, h_ret=%lli "\r\n"e_mr=%p i=%x hca_hndl=%llx mr_hndl=%llx"\r\n" lkey=%x", h_ret, e_mr, i,\r\nshca->ipz_hca_handle.handle,\r\ne_mr->ipz_mr_handle.handle,\r\ne_mr->ib.ib_mr.lkey);\r\nret = ehca2ib_return_code(h_ret);\r\nbreak;\r\n} else\r\nret = 0;\r\n} else if (h_ret != H_PAGE_REGISTERED) {\r\nehca_err(&shca->ib_device, "hipz_reg_rpage_mr failed, "\r\n"h_ret=%lli e_mr=%p i=%x lkey=%x hca_hndl=%llx "\r\n"mr_hndl=%llx", h_ret, e_mr, i,\r\ne_mr->ib.ib_mr.lkey,\r\nshca->ipz_hca_handle.handle,\r\ne_mr->ipz_mr_handle.handle);\r\nret = ehca2ib_return_code(h_ret);\r\nbreak;\r\n} else\r\nret = 0;\r\n}\r\nehca_reg_mr_rpages_exit1:\r\nehca_free_fw_ctrlblock(kpage);\r\nehca_reg_mr_rpages_exit0:\r\nif (ret)\r\nehca_err(&shca->ib_device, "ret=%i shca=%p e_mr=%p pginfo=%p "\r\n"num_kpages=%llx num_hwpages=%llx", ret, shca, e_mr,\r\npginfo, pginfo->num_kpages, pginfo->num_hwpages);\r\nreturn ret;\r\n}\r\ninline int ehca_rereg_mr_rereg1(struct ehca_shca *shca,\r\nstruct ehca_mr *e_mr,\r\nu64 *iova_start,\r\nu64 size,\r\nu32 acl,\r\nstruct ehca_pd *e_pd,\r\nstruct ehca_mr_pginfo *pginfo,\r\nu32 *lkey,\r\nu32 *rkey)\r\n{\r\nint ret;\r\nu64 h_ret;\r\nu32 hipz_acl;\r\nu64 *kpage;\r\nu64 rpage;\r\nstruct ehca_mr_pginfo pginfo_save;\r\nstruct ehca_mr_hipzout_parms hipzout;\r\nehca_mrmw_map_acl(acl, &hipz_acl);\r\nehca_mrmw_set_pgsize_hipz_acl(pginfo->hwpage_size, &hipz_acl);\r\nkpage = ehca_alloc_fw_ctrlblock(GFP_KERNEL);\r\nif (!kpage) {\r\nehca_err(&shca->ib_device, "kpage alloc failed");\r\nret = -ENOMEM;\r\ngoto ehca_rereg_mr_rereg1_exit0;\r\n}\r\npginfo_save = *pginfo;\r\nret = ehca_set_pagebuf(pginfo, pginfo->num_hwpages, kpage);\r\nif (ret) {\r\nehca_err(&shca->ib_device, "set pagebuf failed, e_mr=%p "\r\n"pginfo=%p type=%x num_kpages=%llx num_hwpages=%llx "\r\n"kpage=%p", e_mr, pginfo, pginfo->type,\r\npginfo->num_kpages, pginfo->num_hwpages, kpage);\r\ngoto ehca_rereg_mr_rereg1_exit1;\r\n}\r\nrpage = __pa(kpage);\r\nif (!rpage) {\r\nehca_err(&shca->ib_device, "kpage=%p", kpage);\r\nret = -EFAULT;\r\ngoto ehca_rereg_mr_rereg1_exit1;\r\n}\r\nh_ret = hipz_h_reregister_pmr(shca->ipz_hca_handle, e_mr,\r\n(u64)iova_start, size, hipz_acl,\r\ne_pd->fw_pd, rpage, &hipzout);\r\nif (h_ret != H_SUCCESS) {\r\nehca_warn(&shca->ib_device, "hipz_h_reregister_pmr failed "\r\n"(Rereg1), h_ret=%lli e_mr=%p", h_ret, e_mr);\r\n*pginfo = pginfo_save;\r\nret = -EAGAIN;\r\n} else if ((u64 *)hipzout.vaddr != iova_start) {\r\nehca_err(&shca->ib_device, "PHYP changed iova_start in "\r\n"rereg_pmr, iova_start=%p iova_start_out=%llx e_mr=%p "\r\n"mr_handle=%llx lkey=%x lkey_out=%x", iova_start,\r\nhipzout.vaddr, e_mr, e_mr->ipz_mr_handle.handle,\r\ne_mr->ib.ib_mr.lkey, hipzout.lkey);\r\nret = -EFAULT;\r\n} else {\r\ne_mr->num_kpages = pginfo->num_kpages;\r\ne_mr->num_hwpages = pginfo->num_hwpages;\r\ne_mr->hwpage_size = pginfo->hwpage_size;\r\ne_mr->start = iova_start;\r\ne_mr->size = size;\r\ne_mr->acl = acl;\r\n*lkey = hipzout.lkey;\r\n*rkey = hipzout.rkey;\r\n}\r\nehca_rereg_mr_rereg1_exit1:\r\nehca_free_fw_ctrlblock(kpage);\r\nehca_rereg_mr_rereg1_exit0:\r\nif ( ret && (ret != -EAGAIN) )\r\nehca_err(&shca->ib_device, "ret=%i lkey=%x rkey=%x "\r\n"pginfo=%p num_kpages=%llx num_hwpages=%llx",\r\nret, *lkey, *rkey, pginfo, pginfo->num_kpages,\r\npginfo->num_hwpages);\r\nreturn ret;\r\n}\r\nint ehca_rereg_mr(struct ehca_shca *shca,\r\nstruct ehca_mr *e_mr,\r\nu64 *iova_start,\r\nu64 size,\r\nint acl,\r\nstruct ehca_pd *e_pd,\r\nstruct ehca_mr_pginfo *pginfo,\r\nu32 *lkey,\r\nu32 *rkey)\r\n{\r\nint ret = 0;\r\nu64 h_ret;\r\nint rereg_1_hcall = 1;\r\nint rereg_3_hcall = 0;\r\nif ((pginfo->num_hwpages > MAX_RPAGES) ||\r\n(e_mr->num_hwpages > MAX_RPAGES) ||\r\n(pginfo->num_hwpages > e_mr->num_hwpages)) {\r\nehca_dbg(&shca->ib_device, "Rereg3 case, "\r\n"pginfo->num_hwpages=%llx e_mr->num_hwpages=%x",\r\npginfo->num_hwpages, e_mr->num_hwpages);\r\nrereg_1_hcall = 0;\r\nrereg_3_hcall = 1;\r\n}\r\nif (e_mr->flags & EHCA_MR_FLAG_MAXMR) {\r\nrereg_1_hcall = 0;\r\nrereg_3_hcall = 1;\r\ne_mr->flags &= ~EHCA_MR_FLAG_MAXMR;\r\nehca_err(&shca->ib_device, "Rereg MR for max-MR! e_mr=%p",\r\ne_mr);\r\n}\r\nif (rereg_1_hcall) {\r\nret = ehca_rereg_mr_rereg1(shca, e_mr, iova_start, size,\r\nacl, e_pd, pginfo, lkey, rkey);\r\nif (ret) {\r\nif (ret == -EAGAIN)\r\nrereg_3_hcall = 1;\r\nelse\r\ngoto ehca_rereg_mr_exit0;\r\n}\r\n}\r\nif (rereg_3_hcall) {\r\nstruct ehca_mr save_mr;\r\nh_ret = hipz_h_free_resource_mr(shca->ipz_hca_handle, e_mr);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(&shca->ib_device, "hipz_free_mr failed, "\r\n"h_ret=%lli e_mr=%p hca_hndl=%llx mr_hndl=%llx "\r\n"mr->lkey=%x",\r\nh_ret, e_mr, shca->ipz_hca_handle.handle,\r\ne_mr->ipz_mr_handle.handle,\r\ne_mr->ib.ib_mr.lkey);\r\nret = ehca2ib_return_code(h_ret);\r\ngoto ehca_rereg_mr_exit0;\r\n}\r\nsave_mr = *e_mr;\r\nehca_mr_deletenew(e_mr);\r\ne_mr->flags = save_mr.flags;\r\ne_mr->hwpage_size = save_mr.hwpage_size;\r\ne_mr->fmr_page_size = save_mr.fmr_page_size;\r\ne_mr->fmr_max_pages = save_mr.fmr_max_pages;\r\ne_mr->fmr_max_maps = save_mr.fmr_max_maps;\r\ne_mr->fmr_map_cnt = save_mr.fmr_map_cnt;\r\nret = ehca_reg_mr(shca, e_mr, iova_start, size, acl,\r\ne_pd, pginfo, lkey, rkey, EHCA_REG_MR);\r\nif (ret) {\r\nu32 offset = (u64)(&e_mr->flags) - (u64)e_mr;\r\nmemcpy(&e_mr->flags, &(save_mr.flags),\r\nsizeof(struct ehca_mr) - offset);\r\ngoto ehca_rereg_mr_exit0;\r\n}\r\n}\r\nehca_rereg_mr_exit0:\r\nif (ret)\r\nehca_err(&shca->ib_device, "ret=%i shca=%p e_mr=%p "\r\n"iova_start=%p size=%llx acl=%x e_pd=%p pginfo=%p "\r\n"num_kpages=%llx lkey=%x rkey=%x rereg_1_hcall=%x "\r\n"rereg_3_hcall=%x", ret, shca, e_mr, iova_start, size,\r\nacl, e_pd, pginfo, pginfo->num_kpages, *lkey, *rkey,\r\nrereg_1_hcall, rereg_3_hcall);\r\nreturn ret;\r\n}\r\nint ehca_unmap_one_fmr(struct ehca_shca *shca,\r\nstruct ehca_mr *e_fmr)\r\n{\r\nint ret = 0;\r\nu64 h_ret;\r\nstruct ehca_pd *e_pd =\r\ncontainer_of(e_fmr->ib.ib_fmr.pd, struct ehca_pd, ib_pd);\r\nstruct ehca_mr save_fmr;\r\nu32 tmp_lkey, tmp_rkey;\r\nstruct ehca_mr_pginfo pginfo;\r\nstruct ehca_mr_hipzout_parms hipzout;\r\nstruct ehca_mr save_mr;\r\nif (e_fmr->fmr_max_pages <= MAX_RPAGES) {\r\nh_ret = hipz_h_reregister_pmr(shca->ipz_hca_handle, e_fmr, 0,\r\n0, 0, e_pd->fw_pd, 0, &hipzout);\r\nif (h_ret == H_SUCCESS) {\r\ne_fmr->start = NULL;\r\ne_fmr->size = 0;\r\ntmp_lkey = hipzout.lkey;\r\ntmp_rkey = hipzout.rkey;\r\nreturn 0;\r\n}\r\nehca_err(&shca->ib_device, "hipz_reregister_pmr failed "\r\n"(Rereg1), h_ret=%lli e_fmr=%p hca_hndl=%llx "\r\n"mr_hndl=%llx lkey=%x lkey_out=%x",\r\nh_ret, e_fmr, shca->ipz_hca_handle.handle,\r\ne_fmr->ipz_mr_handle.handle,\r\ne_fmr->ib.ib_fmr.lkey, hipzout.lkey);\r\n}\r\nh_ret = hipz_h_free_resource_mr(shca->ipz_hca_handle, e_fmr);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(&shca->ib_device, "hipz_free_mr failed, "\r\n"h_ret=%lli e_fmr=%p hca_hndl=%llx mr_hndl=%llx "\r\n"lkey=%x",\r\nh_ret, e_fmr, shca->ipz_hca_handle.handle,\r\ne_fmr->ipz_mr_handle.handle,\r\ne_fmr->ib.ib_fmr.lkey);\r\nret = ehca2ib_return_code(h_ret);\r\ngoto ehca_unmap_one_fmr_exit0;\r\n}\r\nsave_fmr = *e_fmr;\r\nehca_mr_deletenew(e_fmr);\r\ne_fmr->flags = save_fmr.flags;\r\ne_fmr->hwpage_size = save_fmr.hwpage_size;\r\ne_fmr->fmr_page_size = save_fmr.fmr_page_size;\r\ne_fmr->fmr_max_pages = save_fmr.fmr_max_pages;\r\ne_fmr->fmr_max_maps = save_fmr.fmr_max_maps;\r\ne_fmr->fmr_map_cnt = save_fmr.fmr_map_cnt;\r\ne_fmr->acl = save_fmr.acl;\r\nmemset(&pginfo, 0, sizeof(pginfo));\r\npginfo.type = EHCA_MR_PGI_FMR;\r\nret = ehca_reg_mr(shca, e_fmr, NULL,\r\n(e_fmr->fmr_max_pages * e_fmr->fmr_page_size),\r\ne_fmr->acl, e_pd, &pginfo, &tmp_lkey,\r\n&tmp_rkey, EHCA_REG_MR);\r\nif (ret) {\r\nu32 offset = (u64)(&e_fmr->flags) - (u64)e_fmr;\r\nmemcpy(&e_fmr->flags, &(save_mr.flags),\r\nsizeof(struct ehca_mr) - offset);\r\n}\r\nehca_unmap_one_fmr_exit0:\r\nif (ret)\r\nehca_err(&shca->ib_device, "ret=%i tmp_lkey=%x tmp_rkey=%x "\r\n"fmr_max_pages=%x",\r\nret, tmp_lkey, tmp_rkey, e_fmr->fmr_max_pages);\r\nreturn ret;\r\n}\r\nint ehca_reg_smr(struct ehca_shca *shca,\r\nstruct ehca_mr *e_origmr,\r\nstruct ehca_mr *e_newmr,\r\nu64 *iova_start,\r\nint acl,\r\nstruct ehca_pd *e_pd,\r\nu32 *lkey,\r\nu32 *rkey)\r\n{\r\nint ret = 0;\r\nu64 h_ret;\r\nu32 hipz_acl;\r\nstruct ehca_mr_hipzout_parms hipzout;\r\nehca_mrmw_map_acl(acl, &hipz_acl);\r\nehca_mrmw_set_pgsize_hipz_acl(e_origmr->hwpage_size, &hipz_acl);\r\nh_ret = hipz_h_register_smr(shca->ipz_hca_handle, e_newmr, e_origmr,\r\n(u64)iova_start, hipz_acl, e_pd->fw_pd,\r\n&hipzout);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(&shca->ib_device, "hipz_reg_smr failed, h_ret=%lli "\r\n"shca=%p e_origmr=%p e_newmr=%p iova_start=%p acl=%x "\r\n"e_pd=%p hca_hndl=%llx mr_hndl=%llx lkey=%x",\r\nh_ret, shca, e_origmr, e_newmr, iova_start, acl, e_pd,\r\nshca->ipz_hca_handle.handle,\r\ne_origmr->ipz_mr_handle.handle,\r\ne_origmr->ib.ib_mr.lkey);\r\nret = ehca2ib_return_code(h_ret);\r\ngoto ehca_reg_smr_exit0;\r\n}\r\ne_newmr->num_kpages = e_origmr->num_kpages;\r\ne_newmr->num_hwpages = e_origmr->num_hwpages;\r\ne_newmr->hwpage_size = e_origmr->hwpage_size;\r\ne_newmr->start = iova_start;\r\ne_newmr->size = e_origmr->size;\r\ne_newmr->acl = acl;\r\ne_newmr->ipz_mr_handle = hipzout.handle;\r\n*lkey = hipzout.lkey;\r\n*rkey = hipzout.rkey;\r\nreturn 0;\r\nehca_reg_smr_exit0:\r\nif (ret)\r\nehca_err(&shca->ib_device, "ret=%i shca=%p e_origmr=%p "\r\n"e_newmr=%p iova_start=%p acl=%x e_pd=%p",\r\nret, shca, e_origmr, e_newmr, iova_start, acl, e_pd);\r\nreturn ret;\r\n}\r\nstatic inline void *ehca_calc_sectbase(int top, int dir, int idx)\r\n{\r\nunsigned long ret = idx;\r\nret |= dir << EHCA_DIR_INDEX_SHIFT;\r\nret |= top << EHCA_TOP_INDEX_SHIFT;\r\nreturn __va(ret << SECTION_SIZE_BITS);\r\n}\r\nstatic u64 ehca_reg_mr_section(int top, int dir, int idx, u64 *kpage,\r\nstruct ehca_shca *shca, struct ehca_mr *mr,\r\nstruct ehca_mr_pginfo *pginfo)\r\n{\r\nu64 h_ret = 0;\r\nunsigned long page = 0;\r\nu64 rpage = __pa(kpage);\r\nint page_count;\r\nvoid *sectbase = ehca_calc_sectbase(top, dir, idx);\r\nif ((unsigned long)sectbase & (pginfo->hwpage_size - 1)) {\r\nehca_err(&shca->ib_device, "reg_mr_section will probably fail:"\r\n"hwpage_size does not fit to "\r\n"section start address");\r\n}\r\npage_count = EHCA_SECTSIZE / pginfo->hwpage_size;\r\nwhile (page < page_count) {\r\nu64 rnum;\r\nfor (rnum = 0; (rnum < MAX_RPAGES) && (page < page_count);\r\nrnum++) {\r\nvoid *pg = sectbase + ((page++) * pginfo->hwpage_size);\r\nkpage[rnum] = __pa(pg);\r\n}\r\nh_ret = hipz_h_register_rpage_mr(shca->ipz_hca_handle, mr,\r\nehca_encode_hwpage_size(pginfo->hwpage_size),\r\n0, rpage, rnum);\r\nif ((h_ret != H_SUCCESS) && (h_ret != H_PAGE_REGISTERED)) {\r\nehca_err(&shca->ib_device, "register_rpage_mr failed");\r\nreturn h_ret;\r\n}\r\n}\r\nreturn h_ret;\r\n}\r\nstatic u64 ehca_reg_mr_sections(int top, int dir, u64 *kpage,\r\nstruct ehca_shca *shca, struct ehca_mr *mr,\r\nstruct ehca_mr_pginfo *pginfo)\r\n{\r\nu64 hret = H_SUCCESS;\r\nint idx;\r\nfor (idx = 0; idx < EHCA_MAP_ENTRIES; idx++) {\r\nif (!ehca_bmap_valid(ehca_bmap->top[top]->dir[dir]->ent[idx]))\r\ncontinue;\r\nhret = ehca_reg_mr_section(top, dir, idx, kpage, shca, mr,\r\npginfo);\r\nif ((hret != H_SUCCESS) && (hret != H_PAGE_REGISTERED))\r\nreturn hret;\r\n}\r\nreturn hret;\r\n}\r\nstatic u64 ehca_reg_mr_dir_sections(int top, u64 *kpage, struct ehca_shca *shca,\r\nstruct ehca_mr *mr,\r\nstruct ehca_mr_pginfo *pginfo)\r\n{\r\nu64 hret = H_SUCCESS;\r\nint dir;\r\nfor (dir = 0; dir < EHCA_MAP_ENTRIES; dir++) {\r\nif (!ehca_bmap_valid(ehca_bmap->top[top]->dir[dir]))\r\ncontinue;\r\nhret = ehca_reg_mr_sections(top, dir, kpage, shca, mr, pginfo);\r\nif ((hret != H_SUCCESS) && (hret != H_PAGE_REGISTERED))\r\nreturn hret;\r\n}\r\nreturn hret;\r\n}\r\nint ehca_reg_internal_maxmr(\r\nstruct ehca_shca *shca,\r\nstruct ehca_pd *e_pd,\r\nstruct ehca_mr **e_maxmr)\r\n{\r\nint ret;\r\nstruct ehca_mr *e_mr;\r\nu64 *iova_start;\r\nu64 size_maxmr;\r\nstruct ehca_mr_pginfo pginfo;\r\nstruct ib_phys_buf ib_pbuf;\r\nu32 num_kpages;\r\nu32 num_hwpages;\r\nu64 hw_pgsize;\r\nif (!ehca_bmap) {\r\nret = -EFAULT;\r\ngoto ehca_reg_internal_maxmr_exit0;\r\n}\r\ne_mr = ehca_mr_new();\r\nif (!e_mr) {\r\nehca_err(&shca->ib_device, "out of memory");\r\nret = -ENOMEM;\r\ngoto ehca_reg_internal_maxmr_exit0;\r\n}\r\ne_mr->flags |= EHCA_MR_FLAG_MAXMR;\r\nsize_maxmr = ehca_mr_len;\r\niova_start = (u64 *)ehca_map_vaddr((void *)(KERNELBASE + PHYSICAL_START));\r\nib_pbuf.addr = 0;\r\nib_pbuf.size = size_maxmr;\r\nnum_kpages = NUM_CHUNKS(((u64)iova_start % PAGE_SIZE) + size_maxmr,\r\nPAGE_SIZE);\r\nhw_pgsize = ehca_get_max_hwpage_size(shca);\r\nnum_hwpages = NUM_CHUNKS(((u64)iova_start % hw_pgsize) + size_maxmr,\r\nhw_pgsize);\r\nmemset(&pginfo, 0, sizeof(pginfo));\r\npginfo.type = EHCA_MR_PGI_PHYS;\r\npginfo.num_kpages = num_kpages;\r\npginfo.num_hwpages = num_hwpages;\r\npginfo.hwpage_size = hw_pgsize;\r\npginfo.u.phy.num_phys_buf = 1;\r\npginfo.u.phy.phys_buf_array = &ib_pbuf;\r\nret = ehca_reg_mr(shca, e_mr, iova_start, size_maxmr, 0, e_pd,\r\n&pginfo, &e_mr->ib.ib_mr.lkey,\r\n&e_mr->ib.ib_mr.rkey, EHCA_REG_BUSMAP_MR);\r\nif (ret) {\r\nehca_err(&shca->ib_device, "reg of internal max MR failed, "\r\n"e_mr=%p iova_start=%p size_maxmr=%llx num_kpages=%x "\r\n"num_hwpages=%x", e_mr, iova_start, size_maxmr,\r\nnum_kpages, num_hwpages);\r\ngoto ehca_reg_internal_maxmr_exit1;\r\n}\r\ne_mr->ib.ib_mr.device = e_pd->ib_pd.device;\r\ne_mr->ib.ib_mr.pd = &e_pd->ib_pd;\r\ne_mr->ib.ib_mr.uobject = NULL;\r\natomic_inc(&(e_pd->ib_pd.usecnt));\r\natomic_set(&(e_mr->ib.ib_mr.usecnt), 0);\r\n*e_maxmr = e_mr;\r\nreturn 0;\r\nehca_reg_internal_maxmr_exit1:\r\nehca_mr_delete(e_mr);\r\nehca_reg_internal_maxmr_exit0:\r\nif (ret)\r\nehca_err(&shca->ib_device, "ret=%i shca=%p e_pd=%p e_maxmr=%p",\r\nret, shca, e_pd, e_maxmr);\r\nreturn ret;\r\n}\r\nint ehca_reg_maxmr(struct ehca_shca *shca,\r\nstruct ehca_mr *e_newmr,\r\nu64 *iova_start,\r\nint acl,\r\nstruct ehca_pd *e_pd,\r\nu32 *lkey,\r\nu32 *rkey)\r\n{\r\nu64 h_ret;\r\nstruct ehca_mr *e_origmr = shca->maxmr;\r\nu32 hipz_acl;\r\nstruct ehca_mr_hipzout_parms hipzout;\r\nehca_mrmw_map_acl(acl, &hipz_acl);\r\nehca_mrmw_set_pgsize_hipz_acl(e_origmr->hwpage_size, &hipz_acl);\r\nh_ret = hipz_h_register_smr(shca->ipz_hca_handle, e_newmr, e_origmr,\r\n(u64)iova_start, hipz_acl, e_pd->fw_pd,\r\n&hipzout);\r\nif (h_ret != H_SUCCESS) {\r\nehca_err(&shca->ib_device, "hipz_reg_smr failed, h_ret=%lli "\r\n"e_origmr=%p hca_hndl=%llx mr_hndl=%llx lkey=%x",\r\nh_ret, e_origmr, shca->ipz_hca_handle.handle,\r\ne_origmr->ipz_mr_handle.handle,\r\ne_origmr->ib.ib_mr.lkey);\r\nreturn ehca2ib_return_code(h_ret);\r\n}\r\ne_newmr->num_kpages = e_origmr->num_kpages;\r\ne_newmr->num_hwpages = e_origmr->num_hwpages;\r\ne_newmr->hwpage_size = e_origmr->hwpage_size;\r\ne_newmr->start = iova_start;\r\ne_newmr->size = e_origmr->size;\r\ne_newmr->acl = acl;\r\ne_newmr->ipz_mr_handle = hipzout.handle;\r\n*lkey = hipzout.lkey;\r\n*rkey = hipzout.rkey;\r\nreturn 0;\r\n}\r\nint ehca_dereg_internal_maxmr(struct ehca_shca *shca)\r\n{\r\nint ret;\r\nstruct ehca_mr *e_maxmr;\r\nstruct ib_pd *ib_pd;\r\nif (!shca->maxmr) {\r\nehca_err(&shca->ib_device, "bad call, shca=%p", shca);\r\nret = -EINVAL;\r\ngoto ehca_dereg_internal_maxmr_exit0;\r\n}\r\ne_maxmr = shca->maxmr;\r\nib_pd = e_maxmr->ib.ib_mr.pd;\r\nshca->maxmr = NULL;\r\nret = ehca_dereg_mr(&e_maxmr->ib.ib_mr);\r\nif (ret) {\r\nehca_err(&shca->ib_device, "dereg internal max-MR failed, "\r\n"ret=%i e_maxmr=%p shca=%p lkey=%x",\r\nret, e_maxmr, shca, e_maxmr->ib.ib_mr.lkey);\r\nshca->maxmr = e_maxmr;\r\ngoto ehca_dereg_internal_maxmr_exit0;\r\n}\r\natomic_dec(&ib_pd->usecnt);\r\nehca_dereg_internal_maxmr_exit0:\r\nif (ret)\r\nehca_err(&shca->ib_device, "ret=%i shca=%p shca->maxmr=%p",\r\nret, shca, shca->maxmr);\r\nreturn ret;\r\n}\r\nint ehca_mr_chk_buf_and_calc_size(struct ib_phys_buf *phys_buf_array,\r\nint num_phys_buf,\r\nu64 *iova_start,\r\nu64 *size)\r\n{\r\nstruct ib_phys_buf *pbuf = phys_buf_array;\r\nu64 size_count = 0;\r\nu32 i;\r\nif (num_phys_buf == 0) {\r\nehca_gen_err("bad phys buf array len, num_phys_buf=0");\r\nreturn -EINVAL;\r\n}\r\nif (((u64)iova_start & ~PAGE_MASK) != (pbuf->addr & ~PAGE_MASK)) {\r\nehca_gen_err("iova_start/addr mismatch, iova_start=%p "\r\n"pbuf->addr=%llx pbuf->size=%llx",\r\niova_start, pbuf->addr, pbuf->size);\r\nreturn -EINVAL;\r\n}\r\nif (((pbuf->addr + pbuf->size) % PAGE_SIZE) &&\r\n(num_phys_buf > 1)) {\r\nehca_gen_err("addr/size mismatch in 1st buf, pbuf->addr=%llx "\r\n"pbuf->size=%llx", pbuf->addr, pbuf->size);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < num_phys_buf; i++) {\r\nif ((i > 0) && (pbuf->addr % PAGE_SIZE)) {\r\nehca_gen_err("bad address, i=%x pbuf->addr=%llx "\r\n"pbuf->size=%llx",\r\ni, pbuf->addr, pbuf->size);\r\nreturn -EINVAL;\r\n}\r\nif (((i > 0) &&\r\n(i < (num_phys_buf - 1)) &&\r\n(pbuf->size % PAGE_SIZE)) || (pbuf->size == 0)) {\r\nehca_gen_err("bad size, i=%x pbuf->size=%llx",\r\ni, pbuf->size);\r\nreturn -EINVAL;\r\n}\r\nsize_count += pbuf->size;\r\npbuf++;\r\n}\r\n*size = size_count;\r\nreturn 0;\r\n}\r\nint ehca_fmr_check_page_list(struct ehca_mr *e_fmr,\r\nu64 *page_list,\r\nint list_len)\r\n{\r\nu32 i;\r\nu64 *page;\r\nif ((list_len == 0) || (list_len > e_fmr->fmr_max_pages)) {\r\nehca_gen_err("bad list_len, list_len=%x "\r\n"e_fmr->fmr_max_pages=%x fmr=%p",\r\nlist_len, e_fmr->fmr_max_pages, e_fmr);\r\nreturn -EINVAL;\r\n}\r\npage = page_list;\r\nfor (i = 0; i < list_len; i++) {\r\nif (*page % e_fmr->fmr_page_size) {\r\nehca_gen_err("bad page, i=%x *page=%llx page=%p fmr=%p "\r\n"fmr_page_size=%x", i, *page, page, e_fmr,\r\ne_fmr->fmr_page_size);\r\nreturn -EINVAL;\r\n}\r\npage++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ehca_set_pagebuf_user1(struct ehca_mr_pginfo *pginfo,\r\nu32 number,\r\nu64 *kpage)\r\n{\r\nint ret = 0;\r\nu64 pgaddr;\r\nu32 j = 0;\r\nint hwpages_per_kpage = PAGE_SIZE / pginfo->hwpage_size;\r\nstruct scatterlist **sg = &pginfo->u.usr.next_sg;\r\nwhile (*sg != NULL) {\r\npgaddr = page_to_pfn(sg_page(*sg))\r\n<< PAGE_SHIFT;\r\n*kpage = pgaddr + (pginfo->next_hwpage *\r\npginfo->hwpage_size);\r\nif (!(*kpage)) {\r\nehca_gen_err("pgaddr=%llx "\r\n"sg_dma_address=%llx "\r\n"entry=%llx next_hwpage=%llx",\r\npgaddr, (u64)sg_dma_address(*sg),\r\npginfo->u.usr.next_nmap,\r\npginfo->next_hwpage);\r\nreturn -EFAULT;\r\n}\r\n(pginfo->hwpage_cnt)++;\r\n(pginfo->next_hwpage)++;\r\nkpage++;\r\nif (pginfo->next_hwpage % hwpages_per_kpage == 0) {\r\n(pginfo->kpage_cnt)++;\r\n(pginfo->u.usr.next_nmap)++;\r\npginfo->next_hwpage = 0;\r\n*sg = sg_next(*sg);\r\n}\r\nj++;\r\nif (j >= number)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ehca_check_kpages_per_ate(struct scatterlist **sg,\r\nint num_pages,\r\nu64 *prev_pgaddr)\r\n{\r\nfor (; *sg && num_pages > 0; *sg = sg_next(*sg), num_pages--) {\r\nu64 pgaddr = page_to_pfn(sg_page(*sg)) << PAGE_SHIFT;\r\nif (ehca_debug_level >= 3)\r\nehca_gen_dbg("chunk_page=%llx value=%016llx", pgaddr,\r\n*(u64 *)__va(pgaddr));\r\nif (pgaddr - PAGE_SIZE != *prev_pgaddr) {\r\nehca_gen_err("uncontiguous page found pgaddr=%llx "\r\n"prev_pgaddr=%llx entries_left_in_hwpage=%x",\r\npgaddr, *prev_pgaddr, num_pages);\r\nreturn -EINVAL;\r\n}\r\n*prev_pgaddr = pgaddr;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ehca_set_pagebuf_user2(struct ehca_mr_pginfo *pginfo,\r\nu32 number,\r\nu64 *kpage)\r\n{\r\nint ret = 0;\r\nu64 pgaddr, prev_pgaddr;\r\nu32 j = 0;\r\nint kpages_per_hwpage = pginfo->hwpage_size / PAGE_SIZE;\r\nint nr_kpages = kpages_per_hwpage;\r\nstruct scatterlist **sg = &pginfo->u.usr.next_sg;\r\nwhile (*sg != NULL) {\r\nif (nr_kpages == kpages_per_hwpage) {\r\npgaddr = (page_to_pfn(sg_page(*sg))\r\n<< PAGE_SHIFT);\r\n*kpage = pgaddr;\r\nif (!(*kpage)) {\r\nehca_gen_err("pgaddr=%llx entry=%llx",\r\npgaddr, pginfo->u.usr.next_nmap);\r\nret = -EFAULT;\r\nreturn ret;\r\n}\r\nif (pgaddr & (pginfo->hwpage_size - 1)) {\r\nif (pginfo->hwpage_cnt) {\r\nehca_gen_err(\r\n"invalid alignment "\r\n"pgaddr=%llx entry=%llx "\r\n"mr_pgsize=%llx",\r\npgaddr, pginfo->u.usr.next_nmap,\r\npginfo->hwpage_size);\r\nret = -EFAULT;\r\nreturn ret;\r\n}\r\npginfo->kpage_cnt =\r\n(pgaddr &\r\n(pginfo->hwpage_size - 1)) >>\r\nPAGE_SHIFT;\r\nnr_kpages -= pginfo->kpage_cnt;\r\n*kpage = pgaddr &\r\n~(pginfo->hwpage_size - 1);\r\n}\r\nif (ehca_debug_level >= 3) {\r\nu64 val = *(u64 *)__va(pgaddr);\r\nehca_gen_dbg("kpage=%llx page=%llx "\r\n"value=%016llx",\r\n*kpage, pgaddr, val);\r\n}\r\nprev_pgaddr = pgaddr;\r\n*sg = sg_next(*sg);\r\npginfo->kpage_cnt++;\r\npginfo->u.usr.next_nmap++;\r\nnr_kpages--;\r\nif (!nr_kpages)\r\ngoto next_kpage;\r\ncontinue;\r\n}\r\nret = ehca_check_kpages_per_ate(sg, nr_kpages,\r\n&prev_pgaddr);\r\nif (ret)\r\nreturn ret;\r\npginfo->kpage_cnt += nr_kpages;\r\npginfo->u.usr.next_nmap += nr_kpages;\r\nnext_kpage:\r\nnr_kpages = kpages_per_hwpage;\r\n(pginfo->hwpage_cnt)++;\r\nkpage++;\r\nj++;\r\nif (j >= number)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ehca_set_pagebuf_phys(struct ehca_mr_pginfo *pginfo,\r\nu32 number, u64 *kpage)\r\n{\r\nint ret = 0;\r\nstruct ib_phys_buf *pbuf;\r\nu64 num_hw, offs_hw;\r\nu32 i = 0;\r\nwhile (i < number) {\r\npbuf = pginfo->u.phy.phys_buf_array + pginfo->u.phy.next_buf;\r\nnum_hw = NUM_CHUNKS((pbuf->addr % pginfo->hwpage_size) +\r\npbuf->size, pginfo->hwpage_size);\r\noffs_hw = (pbuf->addr & ~(pginfo->hwpage_size - 1)) /\r\npginfo->hwpage_size;\r\nwhile (pginfo->next_hwpage < offs_hw + num_hw) {\r\nif ((pginfo->kpage_cnt >= pginfo->num_kpages) ||\r\n(pginfo->hwpage_cnt >= pginfo->num_hwpages)) {\r\nehca_gen_err("kpage_cnt >= num_kpages, "\r\n"kpage_cnt=%llx num_kpages=%llx "\r\n"hwpage_cnt=%llx "\r\n"num_hwpages=%llx i=%x",\r\npginfo->kpage_cnt,\r\npginfo->num_kpages,\r\npginfo->hwpage_cnt,\r\npginfo->num_hwpages, i);\r\nreturn -EFAULT;\r\n}\r\n*kpage = (pbuf->addr & ~(pginfo->hwpage_size - 1)) +\r\n(pginfo->next_hwpage * pginfo->hwpage_size);\r\nif ( !(*kpage) && pbuf->addr ) {\r\nehca_gen_err("pbuf->addr=%llx pbuf->size=%llx "\r\n"next_hwpage=%llx", pbuf->addr,\r\npbuf->size, pginfo->next_hwpage);\r\nreturn -EFAULT;\r\n}\r\n(pginfo->hwpage_cnt)++;\r\n(pginfo->next_hwpage)++;\r\nif (PAGE_SIZE >= pginfo->hwpage_size) {\r\nif (pginfo->next_hwpage %\r\n(PAGE_SIZE / pginfo->hwpage_size) == 0)\r\n(pginfo->kpage_cnt)++;\r\n} else\r\npginfo->kpage_cnt += pginfo->hwpage_size /\r\nPAGE_SIZE;\r\nkpage++;\r\ni++;\r\nif (i >= number) break;\r\n}\r\nif (pginfo->next_hwpage >= offs_hw + num_hw) {\r\n(pginfo->u.phy.next_buf)++;\r\npginfo->next_hwpage = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int ehca_set_pagebuf_fmr(struct ehca_mr_pginfo *pginfo,\r\nu32 number, u64 *kpage)\r\n{\r\nint ret = 0;\r\nu64 *fmrlist;\r\nu32 i;\r\nfmrlist = pginfo->u.fmr.page_list + pginfo->u.fmr.next_listelem;\r\nfor (i = 0; i < number; i++) {\r\n*kpage = (*fmrlist & ~(pginfo->hwpage_size - 1)) +\r\npginfo->next_hwpage * pginfo->hwpage_size;\r\nif ( !(*kpage) ) {\r\nehca_gen_err("*fmrlist=%llx fmrlist=%p "\r\n"next_listelem=%llx next_hwpage=%llx",\r\n*fmrlist, fmrlist,\r\npginfo->u.fmr.next_listelem,\r\npginfo->next_hwpage);\r\nreturn -EFAULT;\r\n}\r\n(pginfo->hwpage_cnt)++;\r\nif (pginfo->u.fmr.fmr_pgsize >= pginfo->hwpage_size) {\r\nif (pginfo->next_hwpage %\r\n(pginfo->u.fmr.fmr_pgsize /\r\npginfo->hwpage_size) == 0) {\r\n(pginfo->kpage_cnt)++;\r\n(pginfo->u.fmr.next_listelem)++;\r\nfmrlist++;\r\npginfo->next_hwpage = 0;\r\n} else\r\n(pginfo->next_hwpage)++;\r\n} else {\r\nunsigned int cnt_per_hwpage = pginfo->hwpage_size /\r\npginfo->u.fmr.fmr_pgsize;\r\nunsigned int j;\r\nu64 prev = *kpage;\r\nfor (j = 1; j < cnt_per_hwpage; j++) {\r\nu64 p = fmrlist[j] & ~(pginfo->hwpage_size - 1);\r\nif (prev + pginfo->u.fmr.fmr_pgsize != p) {\r\nehca_gen_err("uncontiguous fmr pages "\r\n"found prev=%llx p=%llx "\r\n"idx=%x", prev, p, i + j);\r\nreturn -EINVAL;\r\n}\r\nprev = p;\r\n}\r\npginfo->kpage_cnt += cnt_per_hwpage;\r\npginfo->u.fmr.next_listelem += cnt_per_hwpage;\r\nfmrlist += cnt_per_hwpage;\r\n}\r\nkpage++;\r\n}\r\nreturn ret;\r\n}\r\nint ehca_set_pagebuf(struct ehca_mr_pginfo *pginfo,\r\nu32 number,\r\nu64 *kpage)\r\n{\r\nint ret;\r\nswitch (pginfo->type) {\r\ncase EHCA_MR_PGI_PHYS:\r\nret = ehca_set_pagebuf_phys(pginfo, number, kpage);\r\nbreak;\r\ncase EHCA_MR_PGI_USER:\r\nret = PAGE_SIZE >= pginfo->hwpage_size ?\r\nehca_set_pagebuf_user1(pginfo, number, kpage) :\r\nehca_set_pagebuf_user2(pginfo, number, kpage);\r\nbreak;\r\ncase EHCA_MR_PGI_FMR:\r\nret = ehca_set_pagebuf_fmr(pginfo, number, kpage);\r\nbreak;\r\ndefault:\r\nehca_gen_err("bad pginfo->type=%x", pginfo->type);\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint ehca_mr_is_maxmr(u64 size,\r\nu64 *iova_start)\r\n{\r\nif ((size == ehca_mr_len) &&\r\n(iova_start == (void *)ehca_map_vaddr((void *)(KERNELBASE + PHYSICAL_START)))) {\r\nehca_gen_dbg("this is a max-MR");\r\nreturn 1;\r\n} else\r\nreturn 0;\r\n}\r\nvoid ehca_mrmw_map_acl(int ib_acl,\r\nu32 *hipz_acl)\r\n{\r\n*hipz_acl = 0;\r\nif (ib_acl & IB_ACCESS_REMOTE_READ)\r\n*hipz_acl |= HIPZ_ACCESSCTRL_R_READ;\r\nif (ib_acl & IB_ACCESS_REMOTE_WRITE)\r\n*hipz_acl |= HIPZ_ACCESSCTRL_R_WRITE;\r\nif (ib_acl & IB_ACCESS_REMOTE_ATOMIC)\r\n*hipz_acl |= HIPZ_ACCESSCTRL_R_ATOMIC;\r\nif (ib_acl & IB_ACCESS_LOCAL_WRITE)\r\n*hipz_acl |= HIPZ_ACCESSCTRL_L_WRITE;\r\nif (ib_acl & IB_ACCESS_MW_BIND)\r\n*hipz_acl |= HIPZ_ACCESSCTRL_MW_BIND;\r\n}\r\nvoid ehca_mrmw_set_pgsize_hipz_acl(u32 pgsize, u32 *hipz_acl)\r\n{\r\n*hipz_acl |= (ehca_encode_hwpage_size(pgsize) << 24);\r\n}\r\nvoid ehca_mrmw_reverse_map_acl(const u32 *hipz_acl,\r\nint *ib_acl)\r\n{\r\n*ib_acl = 0;\r\nif (*hipz_acl & HIPZ_ACCESSCTRL_R_READ)\r\n*ib_acl |= IB_ACCESS_REMOTE_READ;\r\nif (*hipz_acl & HIPZ_ACCESSCTRL_R_WRITE)\r\n*ib_acl |= IB_ACCESS_REMOTE_WRITE;\r\nif (*hipz_acl & HIPZ_ACCESSCTRL_R_ATOMIC)\r\n*ib_acl |= IB_ACCESS_REMOTE_ATOMIC;\r\nif (*hipz_acl & HIPZ_ACCESSCTRL_L_WRITE)\r\n*ib_acl |= IB_ACCESS_LOCAL_WRITE;\r\nif (*hipz_acl & HIPZ_ACCESSCTRL_MW_BIND)\r\n*ib_acl |= IB_ACCESS_MW_BIND;\r\n}\r\nvoid ehca_mr_deletenew(struct ehca_mr *mr)\r\n{\r\nmr->flags = 0;\r\nmr->num_kpages = 0;\r\nmr->num_hwpages = 0;\r\nmr->acl = 0;\r\nmr->start = NULL;\r\nmr->fmr_page_size = 0;\r\nmr->fmr_max_pages = 0;\r\nmr->fmr_max_maps = 0;\r\nmr->fmr_map_cnt = 0;\r\nmemset(&mr->ipz_mr_handle, 0, sizeof(mr->ipz_mr_handle));\r\nmemset(&mr->galpas, 0, sizeof(mr->galpas));\r\n}\r\nint ehca_init_mrmw_cache(void)\r\n{\r\nmr_cache = kmem_cache_create("ehca_cache_mr",\r\nsizeof(struct ehca_mr), 0,\r\nSLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (!mr_cache)\r\nreturn -ENOMEM;\r\nmw_cache = kmem_cache_create("ehca_cache_mw",\r\nsizeof(struct ehca_mw), 0,\r\nSLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (!mw_cache) {\r\nkmem_cache_destroy(mr_cache);\r\nmr_cache = NULL;\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid ehca_cleanup_mrmw_cache(void)\r\n{\r\nif (mr_cache)\r\nkmem_cache_destroy(mr_cache);\r\nif (mw_cache)\r\nkmem_cache_destroy(mw_cache);\r\n}\r\nstatic inline int ehca_init_top_bmap(struct ehca_top_bmap *ehca_top_bmap,\r\nint dir)\r\n{\r\nif (!ehca_bmap_valid(ehca_top_bmap->dir[dir])) {\r\nehca_top_bmap->dir[dir] =\r\nkmalloc(sizeof(struct ehca_dir_bmap), GFP_KERNEL);\r\nif (!ehca_top_bmap->dir[dir])\r\nreturn -ENOMEM;\r\nmemset(ehca_top_bmap->dir[dir], 0xFF, EHCA_ENT_MAP_SIZE);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int ehca_init_bmap(struct ehca_bmap *ehca_bmap, int top, int dir)\r\n{\r\nif (!ehca_bmap_valid(ehca_bmap->top[top])) {\r\nehca_bmap->top[top] =\r\nkmalloc(sizeof(struct ehca_top_bmap), GFP_KERNEL);\r\nif (!ehca_bmap->top[top])\r\nreturn -ENOMEM;\r\nmemset(ehca_bmap->top[top], 0xFF, EHCA_DIR_MAP_SIZE);\r\n}\r\nreturn ehca_init_top_bmap(ehca_bmap->top[top], dir);\r\n}\r\nstatic inline int ehca_calc_index(unsigned long i, unsigned long s)\r\n{\r\nreturn (i >> s) & EHCA_INDEX_MASK;\r\n}\r\nvoid ehca_destroy_busmap(void)\r\n{\r\nint top, dir;\r\nif (!ehca_bmap)\r\nreturn;\r\nfor (top = 0; top < EHCA_MAP_ENTRIES; top++) {\r\nif (!ehca_bmap_valid(ehca_bmap->top[top]))\r\ncontinue;\r\nfor (dir = 0; dir < EHCA_MAP_ENTRIES; dir++) {\r\nif (!ehca_bmap_valid(ehca_bmap->top[top]->dir[dir]))\r\ncontinue;\r\nkfree(ehca_bmap->top[top]->dir[dir]);\r\n}\r\nkfree(ehca_bmap->top[top]);\r\n}\r\nkfree(ehca_bmap);\r\nehca_bmap = NULL;\r\n}\r\nstatic int ehca_update_busmap(unsigned long pfn, unsigned long nr_pages)\r\n{\r\nunsigned long i, start_section, end_section;\r\nint top, dir, idx;\r\nif (!nr_pages)\r\nreturn 0;\r\nif (!ehca_bmap) {\r\nehca_bmap = kmalloc(sizeof(struct ehca_bmap), GFP_KERNEL);\r\nif (!ehca_bmap)\r\nreturn -ENOMEM;\r\nmemset(ehca_bmap, 0xFF, EHCA_TOP_MAP_SIZE);\r\n}\r\nstart_section = (pfn * PAGE_SIZE) / EHCA_SECTSIZE;\r\nend_section = ((pfn + nr_pages) * PAGE_SIZE) / EHCA_SECTSIZE;\r\nfor (i = start_section; i < end_section; i++) {\r\nint ret;\r\ntop = ehca_calc_index(i, EHCA_TOP_INDEX_SHIFT);\r\ndir = ehca_calc_index(i, EHCA_DIR_INDEX_SHIFT);\r\nidx = i & EHCA_INDEX_MASK;\r\nret = ehca_init_bmap(ehca_bmap, top, dir);\r\nif (ret) {\r\nehca_destroy_busmap();\r\nreturn ret;\r\n}\r\nehca_bmap->top[top]->dir[dir]->ent[idx] = ehca_mr_len;\r\nehca_mr_len += EHCA_SECTSIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ehca_is_hugepage(unsigned long pfn)\r\n{\r\nint page_order;\r\nif (pfn & EHCA_HUGEPAGE_PFN_MASK)\r\nreturn 0;\r\npage_order = compound_order(pfn_to_page(pfn));\r\nif (page_order + PAGE_SHIFT != EHCA_HUGEPAGESHIFT)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int ehca_create_busmap_callback(unsigned long initial_pfn,\r\nunsigned long total_nr_pages, void *arg)\r\n{\r\nint ret;\r\nunsigned long pfn, start_pfn, end_pfn, nr_pages;\r\nif ((total_nr_pages * PAGE_SIZE) < EHCA_HUGEPAGE_SIZE)\r\nreturn ehca_update_busmap(initial_pfn, total_nr_pages);\r\nstart_pfn = initial_pfn;\r\nend_pfn = initial_pfn + total_nr_pages;\r\npfn = start_pfn;\r\nwhile (pfn < end_pfn) {\r\nif (ehca_is_hugepage(pfn)) {\r\nnr_pages = pfn - start_pfn;\r\nret = ehca_update_busmap(start_pfn, nr_pages);\r\nif (ret)\r\nreturn ret;\r\npfn += (EHCA_HUGEPAGE_SIZE / PAGE_SIZE);\r\nstart_pfn = pfn;\r\n} else\r\npfn += (EHCA_SECTSIZE / PAGE_SIZE);\r\n}\r\nnr_pages = pfn - start_pfn;\r\nreturn ehca_update_busmap(start_pfn, nr_pages);\r\n}\r\nint ehca_create_busmap(void)\r\n{\r\nint ret;\r\nehca_mr_len = 0;\r\nret = walk_system_ram_range(0, 1ULL << MAX_PHYSMEM_BITS, NULL,\r\nehca_create_busmap_callback);\r\nreturn ret;\r\n}\r\nstatic int ehca_reg_bmap_mr_rpages(struct ehca_shca *shca,\r\nstruct ehca_mr *e_mr,\r\nstruct ehca_mr_pginfo *pginfo)\r\n{\r\nint top;\r\nu64 hret, *kpage;\r\nkpage = ehca_alloc_fw_ctrlblock(GFP_KERNEL);\r\nif (!kpage) {\r\nehca_err(&shca->ib_device, "kpage alloc failed");\r\nreturn -ENOMEM;\r\n}\r\nfor (top = 0; top < EHCA_MAP_ENTRIES; top++) {\r\nif (!ehca_bmap_valid(ehca_bmap->top[top]))\r\ncontinue;\r\nhret = ehca_reg_mr_dir_sections(top, kpage, shca, e_mr, pginfo);\r\nif ((hret != H_PAGE_REGISTERED) && (hret != H_SUCCESS))\r\nbreak;\r\n}\r\nehca_free_fw_ctrlblock(kpage);\r\nif (hret == H_SUCCESS)\r\nreturn 0;\r\nelse {\r\nehca_err(&shca->ib_device, "ehca_reg_bmap_mr_rpages failed, "\r\n"h_ret=%lli e_mr=%p top=%x lkey=%x "\r\n"hca_hndl=%llx mr_hndl=%llx", hret, e_mr, top,\r\ne_mr->ib.ib_mr.lkey,\r\nshca->ipz_hca_handle.handle,\r\ne_mr->ipz_mr_handle.handle);\r\nreturn ehca2ib_return_code(hret);\r\n}\r\n}\r\nstatic u64 ehca_map_vaddr(void *caddr)\r\n{\r\nint top, dir, idx;\r\nunsigned long abs_addr, offset;\r\nu64 entry;\r\nif (!ehca_bmap)\r\nreturn EHCA_INVAL_ADDR;\r\nabs_addr = __pa(caddr);\r\ntop = ehca_calc_index(abs_addr, EHCA_TOP_INDEX_SHIFT + EHCA_SECTSHIFT);\r\nif (!ehca_bmap_valid(ehca_bmap->top[top]))\r\nreturn EHCA_INVAL_ADDR;\r\ndir = ehca_calc_index(abs_addr, EHCA_DIR_INDEX_SHIFT + EHCA_SECTSHIFT);\r\nif (!ehca_bmap_valid(ehca_bmap->top[top]->dir[dir]))\r\nreturn EHCA_INVAL_ADDR;\r\nidx = ehca_calc_index(abs_addr, EHCA_SECTSHIFT);\r\nentry = ehca_bmap->top[top]->dir[dir]->ent[idx];\r\nif (ehca_bmap_valid(entry)) {\r\noffset = (unsigned long)caddr & (EHCA_SECTSIZE - 1);\r\nreturn entry | offset;\r\n} else\r\nreturn EHCA_INVAL_ADDR;\r\n}\r\nstatic int ehca_dma_mapping_error(struct ib_device *dev, u64 dma_addr)\r\n{\r\nreturn dma_addr == EHCA_INVAL_ADDR;\r\n}\r\nstatic u64 ehca_dma_map_single(struct ib_device *dev, void *cpu_addr,\r\nsize_t size, enum dma_data_direction direction)\r\n{\r\nif (cpu_addr)\r\nreturn ehca_map_vaddr(cpu_addr);\r\nelse\r\nreturn EHCA_INVAL_ADDR;\r\n}\r\nstatic void ehca_dma_unmap_single(struct ib_device *dev, u64 addr, size_t size,\r\nenum dma_data_direction direction)\r\n{\r\n}\r\nstatic u64 ehca_dma_map_page(struct ib_device *dev, struct page *page,\r\nunsigned long offset, size_t size,\r\nenum dma_data_direction direction)\r\n{\r\nu64 addr;\r\nif (offset + size > PAGE_SIZE)\r\nreturn EHCA_INVAL_ADDR;\r\naddr = ehca_map_vaddr(page_address(page));\r\nif (!ehca_dma_mapping_error(dev, addr))\r\naddr += offset;\r\nreturn addr;\r\n}\r\nstatic void ehca_dma_unmap_page(struct ib_device *dev, u64 addr, size_t size,\r\nenum dma_data_direction direction)\r\n{\r\n}\r\nstatic int ehca_dma_map_sg(struct ib_device *dev, struct scatterlist *sgl,\r\nint nents, enum dma_data_direction direction)\r\n{\r\nstruct scatterlist *sg;\r\nint i;\r\nfor_each_sg(sgl, sg, nents, i) {\r\nu64 addr;\r\naddr = ehca_map_vaddr(sg_virt(sg));\r\nif (ehca_dma_mapping_error(dev, addr))\r\nreturn 0;\r\nsg->dma_address = addr;\r\nsg->dma_length = sg->length;\r\n}\r\nreturn nents;\r\n}\r\nstatic void ehca_dma_unmap_sg(struct ib_device *dev, struct scatterlist *sg,\r\nint nents, enum dma_data_direction direction)\r\n{\r\n}\r\nstatic void ehca_dma_sync_single_for_cpu(struct ib_device *dev, u64 addr,\r\nsize_t size,\r\nenum dma_data_direction dir)\r\n{\r\ndma_sync_single_for_cpu(dev->dma_device, addr, size, dir);\r\n}\r\nstatic void ehca_dma_sync_single_for_device(struct ib_device *dev, u64 addr,\r\nsize_t size,\r\nenum dma_data_direction dir)\r\n{\r\ndma_sync_single_for_device(dev->dma_device, addr, size, dir);\r\n}\r\nstatic void *ehca_dma_alloc_coherent(struct ib_device *dev, size_t size,\r\nu64 *dma_handle, gfp_t flag)\r\n{\r\nstruct page *p;\r\nvoid *addr = NULL;\r\nu64 dma_addr;\r\np = alloc_pages(flag, get_order(size));\r\nif (p) {\r\naddr = page_address(p);\r\ndma_addr = ehca_map_vaddr(addr);\r\nif (ehca_dma_mapping_error(dev, dma_addr)) {\r\nfree_pages((unsigned long)addr, get_order(size));\r\nreturn NULL;\r\n}\r\nif (dma_handle)\r\n*dma_handle = dma_addr;\r\nreturn addr;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void ehca_dma_free_coherent(struct ib_device *dev, size_t size,\r\nvoid *cpu_addr, u64 dma_handle)\r\n{\r\nif (cpu_addr && size)\r\nfree_pages((unsigned long)cpu_addr, get_order(size));\r\n}
