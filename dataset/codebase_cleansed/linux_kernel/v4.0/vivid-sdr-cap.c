static void vivid_thread_sdr_cap_tick(struct vivid_dev *dev)\r\n{\r\nstruct vivid_buffer *sdr_cap_buf = NULL;\r\ndprintk(dev, 1, "SDR Capture Thread Tick\n");\r\nif (dev->perc_dropped_buffers &&\r\nprandom_u32_max(100) < dev->perc_dropped_buffers)\r\nreturn;\r\nspin_lock(&dev->slock);\r\nif (!list_empty(&dev->sdr_cap_active)) {\r\nsdr_cap_buf = list_entry(dev->sdr_cap_active.next,\r\nstruct vivid_buffer, list);\r\nlist_del(&sdr_cap_buf->list);\r\n}\r\nspin_unlock(&dev->slock);\r\nif (sdr_cap_buf) {\r\nsdr_cap_buf->vb.v4l2_buf.sequence = dev->sdr_cap_seq_count;\r\nvivid_sdr_cap_process(dev, sdr_cap_buf);\r\nv4l2_get_timestamp(&sdr_cap_buf->vb.v4l2_buf.timestamp);\r\nsdr_cap_buf->vb.v4l2_buf.timestamp.tv_sec += dev->time_wrap_offset;\r\nvb2_buffer_done(&sdr_cap_buf->vb, dev->dqbuf_error ?\r\nVB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\r\ndev->dqbuf_error = false;\r\n}\r\n}\r\nstatic int vivid_thread_sdr_cap(void *data)\r\n{\r\nstruct vivid_dev *dev = data;\r\nu64 samples_since_start;\r\nu64 buffers_since_start;\r\nu64 next_jiffies_since_start;\r\nunsigned long jiffies_since_start;\r\nunsigned long cur_jiffies;\r\nunsigned wait_jiffies;\r\ndprintk(dev, 1, "SDR Capture Thread Start\n");\r\nset_freezable();\r\ndev->sdr_cap_seq_offset = 0;\r\nif (dev->seq_wrap)\r\ndev->sdr_cap_seq_offset = 0xffffff80U;\r\ndev->jiffies_sdr_cap = jiffies;\r\ndev->sdr_cap_seq_resync = false;\r\nfor (;;) {\r\ntry_to_freeze();\r\nif (kthread_should_stop())\r\nbreak;\r\nmutex_lock(&dev->mutex);\r\ncur_jiffies = jiffies;\r\nif (dev->sdr_cap_seq_resync) {\r\ndev->jiffies_sdr_cap = cur_jiffies;\r\ndev->sdr_cap_seq_offset = dev->sdr_cap_seq_count + 1;\r\ndev->sdr_cap_seq_count = 0;\r\ndev->sdr_cap_seq_resync = false;\r\n}\r\njiffies_since_start = cur_jiffies - dev->jiffies_sdr_cap;\r\nbuffers_since_start = (u64)jiffies_since_start * dev->sdr_adc_freq +\r\n(HZ * SDR_CAP_SAMPLES_PER_BUF) / 2;\r\ndo_div(buffers_since_start, HZ * SDR_CAP_SAMPLES_PER_BUF);\r\nif (jiffies_since_start > JIFFIES_RESYNC) {\r\ndev->jiffies_sdr_cap = cur_jiffies;\r\ndev->sdr_cap_seq_offset = buffers_since_start;\r\nbuffers_since_start = 0;\r\n}\r\ndev->sdr_cap_seq_count = buffers_since_start + dev->sdr_cap_seq_offset;\r\nvivid_thread_sdr_cap_tick(dev);\r\nmutex_unlock(&dev->mutex);\r\nsamples_since_start = buffers_since_start * SDR_CAP_SAMPLES_PER_BUF;\r\njiffies_since_start = jiffies - dev->jiffies_sdr_cap;\r\nsamples_since_start += SDR_CAP_SAMPLES_PER_BUF;\r\nnext_jiffies_since_start = samples_since_start * HZ +\r\ndev->sdr_adc_freq / 2;\r\ndo_div(next_jiffies_since_start, dev->sdr_adc_freq);\r\nif (next_jiffies_since_start < jiffies_since_start)\r\nnext_jiffies_since_start = jiffies_since_start;\r\nwait_jiffies = next_jiffies_since_start - jiffies_since_start;\r\nschedule_timeout_interruptible(wait_jiffies ? wait_jiffies : 1);\r\n}\r\ndprintk(dev, 1, "SDR Capture Thread End\n");\r\nreturn 0;\r\n}\r\nstatic int sdr_cap_queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,\r\nunsigned *nbuffers, unsigned *nplanes,\r\nunsigned sizes[], void *alloc_ctxs[])\r\n{\r\nsizes[0] = SDR_CAP_SAMPLES_PER_BUF * 2;\r\n*nplanes = 1;\r\nreturn 0;\r\n}\r\nstatic int sdr_cap_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\r\nunsigned size = SDR_CAP_SAMPLES_PER_BUF * 2;\r\ndprintk(dev, 1, "%s\n", __func__);\r\nif (dev->buf_prepare_error) {\r\ndev->buf_prepare_error = false;\r\nreturn -EINVAL;\r\n}\r\nif (vb2_plane_size(vb, 0) < size) {\r\ndprintk(dev, 1, "%s data will not fit into plane (%lu < %u)\n",\r\n__func__, vb2_plane_size(vb, 0), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, 0, size);\r\nreturn 0;\r\n}\r\nstatic void sdr_cap_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vivid_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vivid_buffer *buf = container_of(vb, struct vivid_buffer, vb);\r\ndprintk(dev, 1, "%s\n", __func__);\r\nspin_lock(&dev->slock);\r\nlist_add_tail(&buf->list, &dev->sdr_cap_active);\r\nspin_unlock(&dev->slock);\r\n}\r\nstatic int sdr_cap_start_streaming(struct vb2_queue *vq, unsigned count)\r\n{\r\nstruct vivid_dev *dev = vb2_get_drv_priv(vq);\r\nint err = 0;\r\ndprintk(dev, 1, "%s\n", __func__);\r\ndev->sdr_cap_seq_count = 0;\r\nif (dev->start_streaming_error) {\r\ndev->start_streaming_error = false;\r\nerr = -EINVAL;\r\n} else if (dev->kthread_sdr_cap == NULL) {\r\ndev->kthread_sdr_cap = kthread_run(vivid_thread_sdr_cap, dev,\r\n"%s-sdr-cap", dev->v4l2_dev.name);\r\nif (IS_ERR(dev->kthread_sdr_cap)) {\r\nv4l2_err(&dev->v4l2_dev, "kernel_thread() failed\n");\r\nerr = PTR_ERR(dev->kthread_sdr_cap);\r\ndev->kthread_sdr_cap = NULL;\r\n}\r\n}\r\nif (err) {\r\nstruct vivid_buffer *buf, *tmp;\r\nlist_for_each_entry_safe(buf, tmp, &dev->sdr_cap_active, list) {\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_QUEUED);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic void sdr_cap_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct vivid_dev *dev = vb2_get_drv_priv(vq);\r\nif (dev->kthread_sdr_cap == NULL)\r\nreturn;\r\nwhile (!list_empty(&dev->sdr_cap_active)) {\r\nstruct vivid_buffer *buf;\r\nbuf = list_entry(dev->sdr_cap_active.next, struct vivid_buffer, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\n}\r\nmutex_unlock(&dev->mutex);\r\nkthread_stop(dev->kthread_sdr_cap);\r\ndev->kthread_sdr_cap = NULL;\r\nmutex_lock(&dev->mutex);\r\n}\r\nint vivid_sdr_enum_freq_bands(struct file *file, void *fh, struct v4l2_frequency_band *band)\r\n{\r\nswitch (band->tuner) {\r\ncase 0:\r\nif (band->index >= ARRAY_SIZE(bands_adc))\r\nreturn -EINVAL;\r\n*band = bands_adc[band->index];\r\nreturn 0;\r\ncase 1:\r\nif (band->index >= ARRAY_SIZE(bands_fm))\r\nreturn -EINVAL;\r\n*band = bands_fm[band->index];\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint vivid_sdr_g_frequency(struct file *file, void *fh, struct v4l2_frequency *vf)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nswitch (vf->tuner) {\r\ncase 0:\r\nvf->frequency = dev->sdr_adc_freq;\r\nvf->type = V4L2_TUNER_ADC;\r\nreturn 0;\r\ncase 1:\r\nvf->frequency = dev->sdr_fm_freq;\r\nvf->type = V4L2_TUNER_RF;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint vivid_sdr_s_frequency(struct file *file, void *fh, const struct v4l2_frequency *vf)\r\n{\r\nstruct vivid_dev *dev = video_drvdata(file);\r\nunsigned freq = vf->frequency;\r\nunsigned band;\r\nswitch (vf->tuner) {\r\ncase 0:\r\nif (vf->type != V4L2_TUNER_ADC)\r\nreturn -EINVAL;\r\nif (freq < BAND_ADC_0)\r\nband = 0;\r\nelse if (freq < BAND_ADC_1)\r\nband = 1;\r\nelse\r\nband = 2;\r\nfreq = clamp_t(unsigned, freq,\r\nbands_adc[band].rangelow,\r\nbands_adc[band].rangehigh);\r\nif (vb2_is_streaming(&dev->vb_sdr_cap_q) &&\r\nfreq != dev->sdr_adc_freq) {\r\ndev->sdr_cap_seq_resync = true;\r\n}\r\ndev->sdr_adc_freq = freq;\r\nreturn 0;\r\ncase 1:\r\nif (vf->type != V4L2_TUNER_RF)\r\nreturn -EINVAL;\r\ndev->sdr_fm_freq = clamp_t(unsigned, freq,\r\nbands_fm[0].rangelow,\r\nbands_fm[0].rangehigh);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint vivid_sdr_g_tuner(struct file *file, void *fh, struct v4l2_tuner *vt)\r\n{\r\nswitch (vt->index) {\r\ncase 0:\r\nstrlcpy(vt->name, "ADC", sizeof(vt->name));\r\nvt->type = V4L2_TUNER_ADC;\r\nvt->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\r\nvt->rangelow = bands_adc[0].rangelow;\r\nvt->rangehigh = bands_adc[2].rangehigh;\r\nreturn 0;\r\ncase 1:\r\nstrlcpy(vt->name, "RF", sizeof(vt->name));\r\nvt->type = V4L2_TUNER_RF;\r\nvt->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\r\nvt->rangelow = bands_fm[0].rangelow;\r\nvt->rangehigh = bands_fm[0].rangehigh;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint vivid_sdr_s_tuner(struct file *file, void *fh, const struct v4l2_tuner *vt)\r\n{\r\nif (vt->index > 1)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint vidioc_enum_fmt_sdr_cap(struct file *file, void *fh, struct v4l2_fmtdesc *f)\r\n{\r\nif (f->index)\r\nreturn -EINVAL;\r\nf->pixelformat = V4L2_SDR_FMT_CU8;\r\nstrlcpy(f->description, "IQ U8", sizeof(f->description));\r\nreturn 0;\r\n}\r\nint vidioc_g_fmt_sdr_cap(struct file *file, void *fh, struct v4l2_format *f)\r\n{\r\nf->fmt.sdr.pixelformat = V4L2_SDR_FMT_CU8;\r\nf->fmt.sdr.buffersize = SDR_CAP_SAMPLES_PER_BUF * 2;\r\nmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\r\nreturn 0;\r\n}\r\nstatic s32 fixp_cos(unsigned int x)\r\n{\r\nu32 t2, t4, t6, t8;\r\nu16 period = x / FIXP_PI;\r\nif (period % 2)\r\nreturn -fixp_cos(x - FIXP_PI);\r\nx = x % FIXP_PI;\r\nif (x > FIXP_PI/2)\r\nreturn -fixp_cos(FIXP_PI/2 - (x % (FIXP_PI/2)));\r\nt2 = x*x/FIXP_FRAC/2;\r\nt4 = t2*x/FIXP_FRAC*x/FIXP_FRAC/3/4;\r\nt6 = t4*x/FIXP_FRAC*x/FIXP_FRAC/5/6;\r\nt8 = t6*x/FIXP_FRAC*x/FIXP_FRAC/7/8;\r\nreturn FIXP_FRAC-t2+t4-t6+t8;\r\n}\r\nstatic inline s32 fixp_sin(unsigned int x)\r\n{\r\nreturn -fixp_cos(x + (FIXP_PI / 2));\r\n}\r\nvoid vivid_sdr_cap_process(struct vivid_dev *dev, struct vivid_buffer *buf)\r\n{\r\nu8 *vbuf = vb2_plane_vaddr(&buf->vb, 0);\r\nunsigned long i;\r\nunsigned long plane_size = vb2_plane_size(&buf->vb, 0);\r\nint fixp_src_phase_step, fixp_i, fixp_q;\r\n#define BEEP_FREQ 1000\r\nfixp_src_phase_step = DIV_ROUND_CLOSEST(2 * FIXP_PI * BEEP_FREQ,\r\ndev->sdr_adc_freq);\r\nfor (i = 0; i < plane_size; i += 2) {\r\ndev->sdr_fixp_mod_phase += fixp_cos(dev->sdr_fixp_src_phase);\r\ndev->sdr_fixp_src_phase += fixp_src_phase_step;\r\nwhile (dev->sdr_fixp_mod_phase < (0 * FIXP_PI))\r\ndev->sdr_fixp_mod_phase += (2 * FIXP_PI);\r\nwhile (dev->sdr_fixp_mod_phase > (2 * FIXP_PI))\r\ndev->sdr_fixp_mod_phase -= (2 * FIXP_PI);\r\nwhile (dev->sdr_fixp_src_phase > (2 * FIXP_PI))\r\ndev->sdr_fixp_src_phase -= (2 * FIXP_PI);\r\nfixp_i = fixp_cos(dev->sdr_fixp_mod_phase);\r\nfixp_q = fixp_sin(dev->sdr_fixp_mod_phase);\r\nfixp_i = fixp_i * 1275 + FIXP_FRAC * 1275;\r\nfixp_q = fixp_q * 1275 + FIXP_FRAC * 1275;\r\n*vbuf++ = DIV_ROUND_CLOSEST(fixp_i, FIXP_FRAC * 10);\r\n*vbuf++ = DIV_ROUND_CLOSEST(fixp_q, FIXP_FRAC * 10);\r\n}\r\n}
