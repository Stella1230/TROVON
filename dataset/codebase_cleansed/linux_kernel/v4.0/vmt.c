static ssize_t vol_attribute_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\nstruct ubi_volume *vol = container_of(dev, struct ubi_volume, dev);\r\nstruct ubi_device *ubi;\r\nubi = ubi_get_device(vol->ubi->ubi_num);\r\nif (!ubi)\r\nreturn -ENODEV;\r\nspin_lock(&ubi->volumes_lock);\r\nif (!ubi->volumes[vol->vol_id]) {\r\nspin_unlock(&ubi->volumes_lock);\r\nubi_put_device(ubi);\r\nreturn -ENODEV;\r\n}\r\nvol->ref_count += 1;\r\nspin_unlock(&ubi->volumes_lock);\r\nif (attr == &attr_vol_reserved_ebs)\r\nret = sprintf(buf, "%d\n", vol->reserved_pebs);\r\nelse if (attr == &attr_vol_type) {\r\nconst char *tp;\r\nif (vol->vol_type == UBI_DYNAMIC_VOLUME)\r\ntp = "dynamic";\r\nelse\r\ntp = "static";\r\nret = sprintf(buf, "%s\n", tp);\r\n} else if (attr == &attr_vol_name)\r\nret = sprintf(buf, "%s\n", vol->name);\r\nelse if (attr == &attr_vol_corrupted)\r\nret = sprintf(buf, "%d\n", vol->corrupted);\r\nelse if (attr == &attr_vol_alignment)\r\nret = sprintf(buf, "%d\n", vol->alignment);\r\nelse if (attr == &attr_vol_usable_eb_size)\r\nret = sprintf(buf, "%d\n", vol->usable_leb_size);\r\nelse if (attr == &attr_vol_data_bytes)\r\nret = sprintf(buf, "%lld\n", vol->used_bytes);\r\nelse if (attr == &attr_vol_upd_marker)\r\nret = sprintf(buf, "%d\n", vol->upd_marker);\r\nelse\r\nret = -EINVAL;\r\nspin_lock(&ubi->volumes_lock);\r\nvol->ref_count -= 1;\r\nubi_assert(vol->ref_count >= 0);\r\nspin_unlock(&ubi->volumes_lock);\r\nubi_put_device(ubi);\r\nreturn ret;\r\n}\r\nstatic void vol_release(struct device *dev)\r\n{\r\nstruct ubi_volume *vol = container_of(dev, struct ubi_volume, dev);\r\nkfree(vol->eba_tbl);\r\nkfree(vol);\r\n}\r\nstatic int volume_sysfs_init(struct ubi_device *ubi, struct ubi_volume *vol)\r\n{\r\nint err;\r\nerr = device_create_file(&vol->dev, &attr_vol_reserved_ebs);\r\nif (err)\r\nreturn err;\r\nerr = device_create_file(&vol->dev, &attr_vol_type);\r\nif (err)\r\nreturn err;\r\nerr = device_create_file(&vol->dev, &attr_vol_name);\r\nif (err)\r\nreturn err;\r\nerr = device_create_file(&vol->dev, &attr_vol_corrupted);\r\nif (err)\r\nreturn err;\r\nerr = device_create_file(&vol->dev, &attr_vol_alignment);\r\nif (err)\r\nreturn err;\r\nerr = device_create_file(&vol->dev, &attr_vol_usable_eb_size);\r\nif (err)\r\nreturn err;\r\nerr = device_create_file(&vol->dev, &attr_vol_data_bytes);\r\nif (err)\r\nreturn err;\r\nerr = device_create_file(&vol->dev, &attr_vol_upd_marker);\r\nreturn err;\r\n}\r\nstatic void volume_sysfs_close(struct ubi_volume *vol)\r\n{\r\ndevice_remove_file(&vol->dev, &attr_vol_upd_marker);\r\ndevice_remove_file(&vol->dev, &attr_vol_data_bytes);\r\ndevice_remove_file(&vol->dev, &attr_vol_usable_eb_size);\r\ndevice_remove_file(&vol->dev, &attr_vol_alignment);\r\ndevice_remove_file(&vol->dev, &attr_vol_corrupted);\r\ndevice_remove_file(&vol->dev, &attr_vol_name);\r\ndevice_remove_file(&vol->dev, &attr_vol_type);\r\ndevice_remove_file(&vol->dev, &attr_vol_reserved_ebs);\r\ndevice_unregister(&vol->dev);\r\n}\r\nint ubi_create_volume(struct ubi_device *ubi, struct ubi_mkvol_req *req)\r\n{\r\nint i, err, vol_id = req->vol_id, do_free = 1;\r\nstruct ubi_volume *vol;\r\nstruct ubi_vtbl_record vtbl_rec;\r\ndev_t dev;\r\nif (ubi->ro_mode)\r\nreturn -EROFS;\r\nvol = kzalloc(sizeof(struct ubi_volume), GFP_KERNEL);\r\nif (!vol)\r\nreturn -ENOMEM;\r\nspin_lock(&ubi->volumes_lock);\r\nif (vol_id == UBI_VOL_NUM_AUTO) {\r\ndbg_gen("search for vacant volume ID");\r\nfor (i = 0; i < ubi->vtbl_slots; i++)\r\nif (!ubi->volumes[i]) {\r\nvol_id = i;\r\nbreak;\r\n}\r\nif (vol_id == UBI_VOL_NUM_AUTO) {\r\nubi_err(ubi, "out of volume IDs");\r\nerr = -ENFILE;\r\ngoto out_unlock;\r\n}\r\nreq->vol_id = vol_id;\r\n}\r\ndbg_gen("create device %d, volume %d, %llu bytes, type %d, name %s",\r\nubi->ubi_num, vol_id, (unsigned long long)req->bytes,\r\n(int)req->vol_type, req->name);\r\nerr = -EEXIST;\r\nif (ubi->volumes[vol_id]) {\r\nubi_err(ubi, "volume %d already exists", vol_id);\r\ngoto out_unlock;\r\n}\r\nfor (i = 0; i < ubi->vtbl_slots; i++)\r\nif (ubi->volumes[i] &&\r\nubi->volumes[i]->name_len == req->name_len &&\r\n!strcmp(ubi->volumes[i]->name, req->name)) {\r\nubi_err(ubi, "volume \"%s\" exists (ID %d)",\r\nreq->name, i);\r\ngoto out_unlock;\r\n}\r\nvol->usable_leb_size = ubi->leb_size - ubi->leb_size % req->alignment;\r\nvol->reserved_pebs += div_u64(req->bytes + vol->usable_leb_size - 1,\r\nvol->usable_leb_size);\r\nif (vol->reserved_pebs > ubi->avail_pebs) {\r\nubi_err(ubi, "not enough PEBs, only %d available",\r\nubi->avail_pebs);\r\nif (ubi->corr_peb_count)\r\nubi_err(ubi, "%d PEBs are corrupted and not used",\r\nubi->corr_peb_count);\r\nerr = -ENOSPC;\r\ngoto out_unlock;\r\n}\r\nubi->avail_pebs -= vol->reserved_pebs;\r\nubi->rsvd_pebs += vol->reserved_pebs;\r\nspin_unlock(&ubi->volumes_lock);\r\nvol->vol_id = vol_id;\r\nvol->alignment = req->alignment;\r\nvol->data_pad = ubi->leb_size % vol->alignment;\r\nvol->vol_type = req->vol_type;\r\nvol->name_len = req->name_len;\r\nmemcpy(vol->name, req->name, vol->name_len);\r\nvol->ubi = ubi;\r\nerr = ubi_wl_flush(ubi, vol_id, UBI_ALL);\r\nif (err)\r\ngoto out_acc;\r\nvol->eba_tbl = kmalloc(vol->reserved_pebs * sizeof(int), GFP_KERNEL);\r\nif (!vol->eba_tbl) {\r\nerr = -ENOMEM;\r\ngoto out_acc;\r\n}\r\nfor (i = 0; i < vol->reserved_pebs; i++)\r\nvol->eba_tbl[i] = UBI_LEB_UNMAPPED;\r\nif (vol->vol_type == UBI_DYNAMIC_VOLUME) {\r\nvol->used_ebs = vol->reserved_pebs;\r\nvol->last_eb_bytes = vol->usable_leb_size;\r\nvol->used_bytes =\r\n(long long)vol->used_ebs * vol->usable_leb_size;\r\n} else {\r\nvol->used_ebs = div_u64_rem(vol->used_bytes,\r\nvol->usable_leb_size,\r\n&vol->last_eb_bytes);\r\nif (vol->last_eb_bytes != 0)\r\nvol->used_ebs += 1;\r\nelse\r\nvol->last_eb_bytes = vol->usable_leb_size;\r\n}\r\ncdev_init(&vol->cdev, &ubi_vol_cdev_operations);\r\nvol->cdev.owner = THIS_MODULE;\r\ndev = MKDEV(MAJOR(ubi->cdev.dev), vol_id + 1);\r\nerr = cdev_add(&vol->cdev, dev, 1);\r\nif (err) {\r\nubi_err(ubi, "cannot add character device");\r\ngoto out_mapping;\r\n}\r\nvol->dev.release = vol_release;\r\nvol->dev.parent = &ubi->dev;\r\nvol->dev.devt = dev;\r\nvol->dev.class = ubi_class;\r\ndev_set_name(&vol->dev, "%s_%d", ubi->ubi_name, vol->vol_id);\r\nerr = device_register(&vol->dev);\r\nif (err) {\r\nubi_err(ubi, "cannot register device");\r\ngoto out_cdev;\r\n}\r\nerr = volume_sysfs_init(ubi, vol);\r\nif (err)\r\ngoto out_sysfs;\r\nmemset(&vtbl_rec, 0, sizeof(struct ubi_vtbl_record));\r\nvtbl_rec.reserved_pebs = cpu_to_be32(vol->reserved_pebs);\r\nvtbl_rec.alignment = cpu_to_be32(vol->alignment);\r\nvtbl_rec.data_pad = cpu_to_be32(vol->data_pad);\r\nvtbl_rec.name_len = cpu_to_be16(vol->name_len);\r\nif (vol->vol_type == UBI_DYNAMIC_VOLUME)\r\nvtbl_rec.vol_type = UBI_VID_DYNAMIC;\r\nelse\r\nvtbl_rec.vol_type = UBI_VID_STATIC;\r\nmemcpy(vtbl_rec.name, vol->name, vol->name_len);\r\nerr = ubi_change_vtbl_record(ubi, vol_id, &vtbl_rec);\r\nif (err)\r\ngoto out_sysfs;\r\nspin_lock(&ubi->volumes_lock);\r\nubi->volumes[vol_id] = vol;\r\nubi->vol_count += 1;\r\nspin_unlock(&ubi->volumes_lock);\r\nubi_volume_notify(ubi, vol, UBI_VOLUME_ADDED);\r\nself_check_volumes(ubi);\r\nreturn err;\r\nout_sysfs:\r\ndo_free = 0;\r\nget_device(&vol->dev);\r\nvolume_sysfs_close(vol);\r\nout_cdev:\r\ncdev_del(&vol->cdev);\r\nout_mapping:\r\nif (do_free)\r\nkfree(vol->eba_tbl);\r\nout_acc:\r\nspin_lock(&ubi->volumes_lock);\r\nubi->rsvd_pebs -= vol->reserved_pebs;\r\nubi->avail_pebs += vol->reserved_pebs;\r\nout_unlock:\r\nspin_unlock(&ubi->volumes_lock);\r\nif (do_free)\r\nkfree(vol);\r\nelse\r\nput_device(&vol->dev);\r\nubi_err(ubi, "cannot create volume %d, error %d", vol_id, err);\r\nreturn err;\r\n}\r\nint ubi_remove_volume(struct ubi_volume_desc *desc, int no_vtbl)\r\n{\r\nstruct ubi_volume *vol = desc->vol;\r\nstruct ubi_device *ubi = vol->ubi;\r\nint i, err, vol_id = vol->vol_id, reserved_pebs = vol->reserved_pebs;\r\ndbg_gen("remove device %d, volume %d", ubi->ubi_num, vol_id);\r\nubi_assert(desc->mode == UBI_EXCLUSIVE);\r\nubi_assert(vol == ubi->volumes[vol_id]);\r\nif (ubi->ro_mode)\r\nreturn -EROFS;\r\nspin_lock(&ubi->volumes_lock);\r\nif (vol->ref_count > 1) {\r\nerr = -EBUSY;\r\ngoto out_unlock;\r\n}\r\nubi->volumes[vol_id] = NULL;\r\nspin_unlock(&ubi->volumes_lock);\r\nif (!no_vtbl) {\r\nerr = ubi_change_vtbl_record(ubi, vol_id, NULL);\r\nif (err)\r\ngoto out_err;\r\n}\r\nfor (i = 0; i < vol->reserved_pebs; i++) {\r\nerr = ubi_eba_unmap_leb(ubi, vol, i);\r\nif (err)\r\ngoto out_err;\r\n}\r\ncdev_del(&vol->cdev);\r\nvolume_sysfs_close(vol);\r\nspin_lock(&ubi->volumes_lock);\r\nubi->rsvd_pebs -= reserved_pebs;\r\nubi->avail_pebs += reserved_pebs;\r\nubi_update_reserved(ubi);\r\nubi->vol_count -= 1;\r\nspin_unlock(&ubi->volumes_lock);\r\nubi_volume_notify(ubi, vol, UBI_VOLUME_REMOVED);\r\nif (!no_vtbl)\r\nself_check_volumes(ubi);\r\nreturn err;\r\nout_err:\r\nubi_err(ubi, "cannot remove volume %d, error %d", vol_id, err);\r\nspin_lock(&ubi->volumes_lock);\r\nubi->volumes[vol_id] = vol;\r\nout_unlock:\r\nspin_unlock(&ubi->volumes_lock);\r\nreturn err;\r\n}\r\nint ubi_resize_volume(struct ubi_volume_desc *desc, int reserved_pebs)\r\n{\r\nint i, err, pebs, *new_mapping;\r\nstruct ubi_volume *vol = desc->vol;\r\nstruct ubi_device *ubi = vol->ubi;\r\nstruct ubi_vtbl_record vtbl_rec;\r\nint vol_id = vol->vol_id;\r\nif (ubi->ro_mode)\r\nreturn -EROFS;\r\ndbg_gen("re-size device %d, volume %d to from %d to %d PEBs",\r\nubi->ubi_num, vol_id, vol->reserved_pebs, reserved_pebs);\r\nif (vol->vol_type == UBI_STATIC_VOLUME &&\r\nreserved_pebs < vol->used_ebs) {\r\nubi_err(ubi, "too small size %d, %d LEBs contain data",\r\nreserved_pebs, vol->used_ebs);\r\nreturn -EINVAL;\r\n}\r\nif (reserved_pebs == vol->reserved_pebs)\r\nreturn 0;\r\nnew_mapping = kmalloc(reserved_pebs * sizeof(int), GFP_KERNEL);\r\nif (!new_mapping)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < reserved_pebs; i++)\r\nnew_mapping[i] = UBI_LEB_UNMAPPED;\r\nspin_lock(&ubi->volumes_lock);\r\nif (vol->ref_count > 1) {\r\nspin_unlock(&ubi->volumes_lock);\r\nerr = -EBUSY;\r\ngoto out_free;\r\n}\r\nspin_unlock(&ubi->volumes_lock);\r\npebs = reserved_pebs - vol->reserved_pebs;\r\nif (pebs > 0) {\r\nspin_lock(&ubi->volumes_lock);\r\nif (pebs > ubi->avail_pebs) {\r\nubi_err(ubi, "not enough PEBs: requested %d, available %d",\r\npebs, ubi->avail_pebs);\r\nif (ubi->corr_peb_count)\r\nubi_err(ubi, "%d PEBs are corrupted and not used",\r\nubi->corr_peb_count);\r\nspin_unlock(&ubi->volumes_lock);\r\nerr = -ENOSPC;\r\ngoto out_free;\r\n}\r\nubi->avail_pebs -= pebs;\r\nubi->rsvd_pebs += pebs;\r\nfor (i = 0; i < vol->reserved_pebs; i++)\r\nnew_mapping[i] = vol->eba_tbl[i];\r\nkfree(vol->eba_tbl);\r\nvol->eba_tbl = new_mapping;\r\nspin_unlock(&ubi->volumes_lock);\r\n}\r\nvtbl_rec = ubi->vtbl[vol_id];\r\nvtbl_rec.reserved_pebs = cpu_to_be32(reserved_pebs);\r\nerr = ubi_change_vtbl_record(ubi, vol_id, &vtbl_rec);\r\nif (err)\r\ngoto out_acc;\r\nif (pebs < 0) {\r\nfor (i = 0; i < -pebs; i++) {\r\nerr = ubi_eba_unmap_leb(ubi, vol, reserved_pebs + i);\r\nif (err)\r\ngoto out_acc;\r\n}\r\nspin_lock(&ubi->volumes_lock);\r\nubi->rsvd_pebs += pebs;\r\nubi->avail_pebs -= pebs;\r\nubi_update_reserved(ubi);\r\nfor (i = 0; i < reserved_pebs; i++)\r\nnew_mapping[i] = vol->eba_tbl[i];\r\nkfree(vol->eba_tbl);\r\nvol->eba_tbl = new_mapping;\r\nspin_unlock(&ubi->volumes_lock);\r\n}\r\nvol->reserved_pebs = reserved_pebs;\r\nif (vol->vol_type == UBI_DYNAMIC_VOLUME) {\r\nvol->used_ebs = reserved_pebs;\r\nvol->last_eb_bytes = vol->usable_leb_size;\r\nvol->used_bytes =\r\n(long long)vol->used_ebs * vol->usable_leb_size;\r\n}\r\nubi_volume_notify(ubi, vol, UBI_VOLUME_RESIZED);\r\nself_check_volumes(ubi);\r\nreturn err;\r\nout_acc:\r\nif (pebs > 0) {\r\nspin_lock(&ubi->volumes_lock);\r\nubi->rsvd_pebs -= pebs;\r\nubi->avail_pebs += pebs;\r\nspin_unlock(&ubi->volumes_lock);\r\n}\r\nout_free:\r\nkfree(new_mapping);\r\nreturn err;\r\n}\r\nint ubi_rename_volumes(struct ubi_device *ubi, struct list_head *rename_list)\r\n{\r\nint err;\r\nstruct ubi_rename_entry *re;\r\nerr = ubi_vtbl_rename_volumes(ubi, rename_list);\r\nif (err)\r\nreturn err;\r\nlist_for_each_entry(re, rename_list, list) {\r\nif (re->remove) {\r\nerr = ubi_remove_volume(re->desc, 1);\r\nif (err)\r\nbreak;\r\n} else {\r\nstruct ubi_volume *vol = re->desc->vol;\r\nspin_lock(&ubi->volumes_lock);\r\nvol->name_len = re->new_name_len;\r\nmemcpy(vol->name, re->new_name, re->new_name_len + 1);\r\nspin_unlock(&ubi->volumes_lock);\r\nubi_volume_notify(ubi, vol, UBI_VOLUME_RENAMED);\r\n}\r\n}\r\nif (!err)\r\nself_check_volumes(ubi);\r\nreturn err;\r\n}\r\nint ubi_add_volume(struct ubi_device *ubi, struct ubi_volume *vol)\r\n{\r\nint err, vol_id = vol->vol_id;\r\ndev_t dev;\r\ndbg_gen("add volume %d", vol_id);\r\ncdev_init(&vol->cdev, &ubi_vol_cdev_operations);\r\nvol->cdev.owner = THIS_MODULE;\r\ndev = MKDEV(MAJOR(ubi->cdev.dev), vol->vol_id + 1);\r\nerr = cdev_add(&vol->cdev, dev, 1);\r\nif (err) {\r\nubi_err(ubi, "cannot add character device for volume %d, error %d",\r\nvol_id, err);\r\nreturn err;\r\n}\r\nvol->dev.release = vol_release;\r\nvol->dev.parent = &ubi->dev;\r\nvol->dev.devt = dev;\r\nvol->dev.class = ubi_class;\r\ndev_set_name(&vol->dev, "%s_%d", ubi->ubi_name, vol->vol_id);\r\nerr = device_register(&vol->dev);\r\nif (err)\r\ngoto out_cdev;\r\nerr = volume_sysfs_init(ubi, vol);\r\nif (err) {\r\ncdev_del(&vol->cdev);\r\nvolume_sysfs_close(vol);\r\nreturn err;\r\n}\r\nself_check_volumes(ubi);\r\nreturn err;\r\nout_cdev:\r\ncdev_del(&vol->cdev);\r\nreturn err;\r\n}\r\nvoid ubi_free_volume(struct ubi_device *ubi, struct ubi_volume *vol)\r\n{\r\ndbg_gen("free volume %d", vol->vol_id);\r\nubi->volumes[vol->vol_id] = NULL;\r\ncdev_del(&vol->cdev);\r\nvolume_sysfs_close(vol);\r\n}\r\nstatic int self_check_volume(struct ubi_device *ubi, int vol_id)\r\n{\r\nint idx = vol_id2idx(ubi, vol_id);\r\nint reserved_pebs, alignment, data_pad, vol_type, name_len, upd_marker;\r\nconst struct ubi_volume *vol;\r\nlong long n;\r\nconst char *name;\r\nspin_lock(&ubi->volumes_lock);\r\nreserved_pebs = be32_to_cpu(ubi->vtbl[vol_id].reserved_pebs);\r\nvol = ubi->volumes[idx];\r\nif (!vol) {\r\nif (reserved_pebs) {\r\nubi_err(ubi, "no volume info, but volume exists");\r\ngoto fail;\r\n}\r\nspin_unlock(&ubi->volumes_lock);\r\nreturn 0;\r\n}\r\nif (vol->reserved_pebs < 0 || vol->alignment < 0 || vol->data_pad < 0 ||\r\nvol->name_len < 0) {\r\nubi_err(ubi, "negative values");\r\ngoto fail;\r\n}\r\nif (vol->alignment > ubi->leb_size || vol->alignment == 0) {\r\nubi_err(ubi, "bad alignment");\r\ngoto fail;\r\n}\r\nn = vol->alignment & (ubi->min_io_size - 1);\r\nif (vol->alignment != 1 && n) {\r\nubi_err(ubi, "alignment is not multiple of min I/O unit");\r\ngoto fail;\r\n}\r\nn = ubi->leb_size % vol->alignment;\r\nif (vol->data_pad != n) {\r\nubi_err(ubi, "bad data_pad, has to be %lld", n);\r\ngoto fail;\r\n}\r\nif (vol->vol_type != UBI_DYNAMIC_VOLUME &&\r\nvol->vol_type != UBI_STATIC_VOLUME) {\r\nubi_err(ubi, "bad vol_type");\r\ngoto fail;\r\n}\r\nif (vol->upd_marker && vol->corrupted) {\r\nubi_err(ubi, "update marker and corrupted simultaneously");\r\ngoto fail;\r\n}\r\nif (vol->reserved_pebs > ubi->good_peb_count) {\r\nubi_err(ubi, "too large reserved_pebs");\r\ngoto fail;\r\n}\r\nn = ubi->leb_size - vol->data_pad;\r\nif (vol->usable_leb_size != ubi->leb_size - vol->data_pad) {\r\nubi_err(ubi, "bad usable_leb_size, has to be %lld", n);\r\ngoto fail;\r\n}\r\nif (vol->name_len > UBI_VOL_NAME_MAX) {\r\nubi_err(ubi, "too long volume name, max is %d",\r\nUBI_VOL_NAME_MAX);\r\ngoto fail;\r\n}\r\nn = strnlen(vol->name, vol->name_len + 1);\r\nif (n != vol->name_len) {\r\nubi_err(ubi, "bad name_len %lld", n);\r\ngoto fail;\r\n}\r\nn = (long long)vol->used_ebs * vol->usable_leb_size;\r\nif (vol->vol_type == UBI_DYNAMIC_VOLUME) {\r\nif (vol->corrupted) {\r\nubi_err(ubi, "corrupted dynamic volume");\r\ngoto fail;\r\n}\r\nif (vol->used_ebs != vol->reserved_pebs) {\r\nubi_err(ubi, "bad used_ebs");\r\ngoto fail;\r\n}\r\nif (vol->last_eb_bytes != vol->usable_leb_size) {\r\nubi_err(ubi, "bad last_eb_bytes");\r\ngoto fail;\r\n}\r\nif (vol->used_bytes != n) {\r\nubi_err(ubi, "bad used_bytes");\r\ngoto fail;\r\n}\r\n} else {\r\nif (vol->used_ebs < 0 || vol->used_ebs > vol->reserved_pebs) {\r\nubi_err(ubi, "bad used_ebs");\r\ngoto fail;\r\n}\r\nif (vol->last_eb_bytes < 0 ||\r\nvol->last_eb_bytes > vol->usable_leb_size) {\r\nubi_err(ubi, "bad last_eb_bytes");\r\ngoto fail;\r\n}\r\nif (vol->used_bytes < 0 || vol->used_bytes > n ||\r\nvol->used_bytes < n - vol->usable_leb_size) {\r\nubi_err(ubi, "bad used_bytes");\r\ngoto fail;\r\n}\r\n}\r\nalignment = be32_to_cpu(ubi->vtbl[vol_id].alignment);\r\ndata_pad = be32_to_cpu(ubi->vtbl[vol_id].data_pad);\r\nname_len = be16_to_cpu(ubi->vtbl[vol_id].name_len);\r\nupd_marker = ubi->vtbl[vol_id].upd_marker;\r\nname = &ubi->vtbl[vol_id].name[0];\r\nif (ubi->vtbl[vol_id].vol_type == UBI_VID_DYNAMIC)\r\nvol_type = UBI_DYNAMIC_VOLUME;\r\nelse\r\nvol_type = UBI_STATIC_VOLUME;\r\nif (alignment != vol->alignment || data_pad != vol->data_pad ||\r\nupd_marker != vol->upd_marker || vol_type != vol->vol_type ||\r\nname_len != vol->name_len || strncmp(name, vol->name, name_len)) {\r\nubi_err(ubi, "volume info is different");\r\ngoto fail;\r\n}\r\nspin_unlock(&ubi->volumes_lock);\r\nreturn 0;\r\nfail:\r\nubi_err(ubi, "self-check failed for volume %d", vol_id);\r\nif (vol)\r\nubi_dump_vol_info(vol);\r\nubi_dump_vtbl_record(&ubi->vtbl[vol_id], vol_id);\r\ndump_stack();\r\nspin_unlock(&ubi->volumes_lock);\r\nreturn -EINVAL;\r\n}\r\nstatic int self_check_volumes(struct ubi_device *ubi)\r\n{\r\nint i, err = 0;\r\nif (!ubi_dbg_chk_gen(ubi))\r\nreturn 0;\r\nfor (i = 0; i < ubi->vtbl_slots; i++) {\r\nerr = self_check_volume(ubi, i);\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}
