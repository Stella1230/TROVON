static int rose_header(struct sk_buff *skb, struct net_device *dev,\r\nunsigned short type,\r\nconst void *daddr, const void *saddr, unsigned int len)\r\n{\r\nunsigned char *buff = skb_push(skb, ROSE_MIN_LEN + 2);\r\n*buff++ = ROSE_GFI | ROSE_Q_BIT;\r\n*buff++ = 0x00;\r\n*buff++ = ROSE_DATA;\r\n*buff++ = 0x7F;\r\n*buff++ = AX25_P_IP;\r\nif (daddr != NULL)\r\nreturn 37;\r\nreturn -37;\r\n}\r\nstatic int rose_rebuild_header(struct sk_buff *skb)\r\n{\r\n#ifdef CONFIG_INET\r\nstruct net_device *dev = skb->dev;\r\nstruct net_device_stats *stats = &dev->stats;\r\nunsigned char *bp = (unsigned char *)skb->data;\r\nstruct sk_buff *skbn;\r\nunsigned int len;\r\nif (arp_find(bp + 7, skb)) {\r\nreturn 1;\r\n}\r\nif ((skbn = skb_clone(skb, GFP_ATOMIC)) == NULL) {\r\nkfree_skb(skb);\r\nreturn 1;\r\n}\r\nif (skb->sk != NULL)\r\nskb_set_owner_w(skbn, skb->sk);\r\nkfree_skb(skb);\r\nlen = skbn->len;\r\nif (!rose_route_frame(skbn, NULL)) {\r\nkfree_skb(skbn);\r\nstats->tx_errors++;\r\nreturn 1;\r\n}\r\nstats->tx_packets++;\r\nstats->tx_bytes += len;\r\n#endif\r\nreturn 1;\r\n}\r\nstatic int rose_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *sa = addr;\r\nint err;\r\nif (!memcmp(dev->dev_addr, sa->sa_data, dev->addr_len))\r\nreturn 0;\r\nif (dev->flags & IFF_UP) {\r\nerr = rose_add_loopback_node((rose_address *)sa->sa_data);\r\nif (err)\r\nreturn err;\r\nrose_del_loopback_node((rose_address *)dev->dev_addr);\r\n}\r\nmemcpy(dev->dev_addr, sa->sa_data, dev->addr_len);\r\nreturn 0;\r\n}\r\nstatic int rose_open(struct net_device *dev)\r\n{\r\nint err;\r\nerr = rose_add_loopback_node((rose_address *)dev->dev_addr);\r\nif (err)\r\nreturn err;\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int rose_close(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nrose_del_loopback_node((rose_address *)dev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t rose_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct net_device_stats *stats = &dev->stats;\r\nif (!netif_running(dev)) {\r\nprintk(KERN_ERR "ROSE: rose_xmit - called when iface is down\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\ndev_kfree_skb(skb);\r\nstats->tx_errors++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nvoid rose_setup(struct net_device *dev)\r\n{\r\ndev->mtu = ROSE_MAX_PACKET_SIZE - 2;\r\ndev->netdev_ops = &rose_netdev_ops;\r\ndev->header_ops = &rose_header_ops;\r\ndev->hard_header_len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN;\r\ndev->addr_len = ROSE_ADDR_LEN;\r\ndev->type = ARPHRD_ROSE;\r\ndev->flags = IFF_NOARP;\r\n}
