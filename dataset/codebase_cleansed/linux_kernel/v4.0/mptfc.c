static int\r\nmptfc_block_error_handler(struct scsi_cmnd *SCpnt,\r\nint (*func)(struct scsi_cmnd *SCpnt),\r\nconst char *caller)\r\n{\r\nMPT_SCSI_HOST *hd;\r\nstruct scsi_device *sdev = SCpnt->device;\r\nstruct Scsi_Host *shost = sdev->host;\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\r\nunsigned long flags;\r\nint ready;\r\nMPT_ADAPTER *ioc;\r\nint loops = 40;\r\nhd = shost_priv(SCpnt->device->host);\r\nioc = hd->ioc;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nwhile ((ready = fc_remote_port_chkready(rport) >> 16) == DID_IMM_RETRY\r\n|| (loops > 0 && ioc->active == 0)) {\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\ndfcprintk (ioc, printk(MYIOC_s_DEBUG_FMT\r\n"mptfc_block_error_handler.%d: %d:%llu, port status is "\r\n"%x, active flag %d, deferring %s recovery.\n",\r\nioc->name, ioc->sh->host_no,\r\nSCpnt->device->id, SCpnt->device->lun,\r\nready, ioc->active, caller));\r\nmsleep(1000);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nloops --;\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (ready == DID_NO_CONNECT || !SCpnt->device->hostdata\r\n|| ioc->active == 0) {\r\ndfcprintk (ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s.%d: %d:%llu, failing recovery, "\r\n"port state %x, active %d, vdevice %p.\n", caller,\r\nioc->name, ioc->sh->host_no,\r\nSCpnt->device->id, SCpnt->device->lun, ready,\r\nioc->active, SCpnt->device->hostdata));\r\nreturn FAILED;\r\n}\r\ndfcprintk (ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s.%d: %d:%llu, executing recovery.\n", caller,\r\nioc->name, ioc->sh->host_no,\r\nSCpnt->device->id, SCpnt->device->lun));\r\nreturn (*func)(SCpnt);\r\n}\r\nstatic int\r\nmptfc_abort(struct scsi_cmnd *SCpnt)\r\n{\r\nreturn\r\nmptfc_block_error_handler(SCpnt, mptscsih_abort, __func__);\r\n}\r\nstatic int\r\nmptfc_dev_reset(struct scsi_cmnd *SCpnt)\r\n{\r\nreturn\r\nmptfc_block_error_handler(SCpnt, mptscsih_dev_reset, __func__);\r\n}\r\nstatic int\r\nmptfc_bus_reset(struct scsi_cmnd *SCpnt)\r\n{\r\nreturn\r\nmptfc_block_error_handler(SCpnt, mptscsih_bus_reset, __func__);\r\n}\r\nstatic int\r\nmptfc_host_reset(struct scsi_cmnd *SCpnt)\r\n{\r\nreturn\r\nmptfc_block_error_handler(SCpnt, mptscsih_host_reset, __func__);\r\n}\r\nstatic void\r\nmptfc_set_rport_loss_tmo(struct fc_rport *rport, uint32_t timeout)\r\n{\r\nif (timeout > 0)\r\nrport->dev_loss_tmo = timeout;\r\nelse\r\nrport->dev_loss_tmo = mptfc_dev_loss_tmo;\r\n}\r\nstatic int\r\nmptfc_FcDevPage0_cmp_func(const void *a, const void *b)\r\n{\r\nFCDevicePage0_t **aa = (FCDevicePage0_t **)a;\r\nFCDevicePage0_t **bb = (FCDevicePage0_t **)b;\r\nif ((*aa)->CurrentBus == (*bb)->CurrentBus) {\r\nif ((*aa)->CurrentTargetID == (*bb)->CurrentTargetID)\r\nreturn 0;\r\nif ((*aa)->CurrentTargetID < (*bb)->CurrentTargetID)\r\nreturn -1;\r\nreturn 1;\r\n}\r\nif ((*aa)->CurrentBus < (*bb)->CurrentBus)\r\nreturn -1;\r\nreturn 1;\r\n}\r\nstatic int\r\nmptfc_GetFcDevPage0(MPT_ADAPTER *ioc, int ioc_port,\r\nvoid(*func)(MPT_ADAPTER *ioc,int channel, FCDevicePage0_t *arg))\r\n{\r\nConfigPageHeader_t hdr;\r\nCONFIGPARMS cfg;\r\nFCDevicePage0_t *ppage0_alloc, *fc;\r\ndma_addr_t page0_dma;\r\nint data_sz;\r\nint ii;\r\nFCDevicePage0_t *p0_array=NULL, *p_p0;\r\nFCDevicePage0_t **pp0_array=NULL, **p_pp0;\r\nint rc = -ENOMEM;\r\nU32 port_id = 0xffffff;\r\nint num_targ = 0;\r\nint max_bus = ioc->facts.MaxBuses;\r\nint max_targ;\r\nmax_targ = (ioc->facts.MaxDevices == 0) ? 256 : ioc->facts.MaxDevices;\r\ndata_sz = sizeof(FCDevicePage0_t) * max_bus * max_targ;\r\np_p0 = p0_array = kzalloc(data_sz, GFP_KERNEL);\r\nif (!p0_array)\r\ngoto out;\r\ndata_sz = sizeof(FCDevicePage0_t *) * max_bus * max_targ;\r\np_pp0 = pp0_array = kzalloc(data_sz, GFP_KERNEL);\r\nif (!pp0_array)\r\ngoto out;\r\ndo {\r\nhdr.PageVersion = 0;\r\nhdr.PageLength = 0;\r\nhdr.PageNumber = 0;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_FC_DEVICE;\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.physAddr = -1;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.pageAddr = port_id;\r\ncfg.timeout = 0;\r\nif ((rc = mpt_config(ioc, &cfg)) != 0)\r\nbreak;\r\nif (hdr.PageLength <= 0)\r\nbreak;\r\ndata_sz = hdr.PageLength * 4;\r\nppage0_alloc = pci_alloc_consistent(ioc->pcidev, data_sz,\r\n&page0_dma);\r\nrc = -ENOMEM;\r\nif (!ppage0_alloc)\r\nbreak;\r\ncfg.physAddr = page0_dma;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nif ((rc = mpt_config(ioc, &cfg)) == 0) {\r\nppage0_alloc->PortIdentifier =\r\nle32_to_cpu(ppage0_alloc->PortIdentifier);\r\nppage0_alloc->WWNN.Low =\r\nle32_to_cpu(ppage0_alloc->WWNN.Low);\r\nppage0_alloc->WWNN.High =\r\nle32_to_cpu(ppage0_alloc->WWNN.High);\r\nppage0_alloc->WWPN.Low =\r\nle32_to_cpu(ppage0_alloc->WWPN.Low);\r\nppage0_alloc->WWPN.High =\r\nle32_to_cpu(ppage0_alloc->WWPN.High);\r\nppage0_alloc->BBCredit =\r\nle16_to_cpu(ppage0_alloc->BBCredit);\r\nppage0_alloc->MaxRxFrameSize =\r\nle16_to_cpu(ppage0_alloc->MaxRxFrameSize);\r\nport_id = ppage0_alloc->PortIdentifier;\r\nnum_targ++;\r\n*p_p0 = *ppage0_alloc;\r\n*p_pp0++ = p_p0++;\r\n}\r\npci_free_consistent(ioc->pcidev, data_sz,\r\n(u8 *) ppage0_alloc, page0_dma);\r\nif (rc != 0)\r\nbreak;\r\n} while (port_id <= 0xff0000);\r\nif (num_targ) {\r\nif (num_targ > 1)\r\nsort (pp0_array, num_targ, sizeof(FCDevicePage0_t *),\r\nmptfc_FcDevPage0_cmp_func, NULL);\r\nfor (ii = 0; ii < num_targ; ii++) {\r\nfc = *(pp0_array+ii);\r\nfunc(ioc, ioc_port, fc);\r\n}\r\n}\r\nout:\r\nkfree(pp0_array);\r\nkfree(p0_array);\r\nreturn rc;\r\n}\r\nstatic int\r\nmptfc_generate_rport_ids(FCDevicePage0_t *pg0, struct fc_rport_identifiers *rid)\r\n{\r\nif (pg0->Flags & (MPI_FC_DEVICE_PAGE0_FLAGS_PLOGI_INVALID |\r\nMPI_FC_DEVICE_PAGE0_FLAGS_PRLI_INVALID))\r\nreturn -1;\r\nif (!(pg0->Flags & MPI_FC_DEVICE_PAGE0_FLAGS_TARGETID_BUS_VALID))\r\nreturn -1;\r\nif (!(pg0->Protocol & MPI_FC_DEVICE_PAGE0_PROT_FCP_TARGET))\r\nreturn -1;\r\nrid->node_name = ((u64)pg0->WWNN.High) << 32 | (u64)pg0->WWNN.Low;\r\nrid->port_name = ((u64)pg0->WWPN.High) << 32 | (u64)pg0->WWPN.Low;\r\nrid->port_id = pg0->PortIdentifier;\r\nrid->roles = FC_RPORT_ROLE_UNKNOWN;\r\nreturn 0;\r\n}\r\nstatic void\r\nmptfc_register_dev(MPT_ADAPTER *ioc, int channel, FCDevicePage0_t *pg0)\r\n{\r\nstruct fc_rport_identifiers rport_ids;\r\nstruct fc_rport *rport;\r\nstruct mptfc_rport_info *ri;\r\nint new_ri = 1;\r\nu64 pn, nn;\r\nVirtTarget *vtarget;\r\nu32 roles = FC_RPORT_ROLE_UNKNOWN;\r\nif (mptfc_generate_rport_ids(pg0, &rport_ids) < 0)\r\nreturn;\r\nroles |= FC_RPORT_ROLE_FCP_TARGET;\r\nif (pg0->Protocol & MPI_FC_DEVICE_PAGE0_PROT_FCP_INITIATOR)\r\nroles |= FC_RPORT_ROLE_FCP_INITIATOR;\r\nlist_for_each_entry(ri, &ioc->fc_rports, list) {\r\npn = (u64)ri->pg0.WWPN.High << 32 | (u64)ri->pg0.WWPN.Low;\r\nif (pn == rport_ids.port_name) {\r\nlist_move_tail(&ri->list, &ioc->fc_rports);\r\nnew_ri = 0;\r\nbreak;\r\n}\r\n}\r\nif (new_ri) {\r\nri = kzalloc(sizeof(struct mptfc_rport_info), GFP_KERNEL);\r\nif (!ri)\r\nreturn;\r\nlist_add_tail(&ri->list, &ioc->fc_rports);\r\n}\r\nri->pg0 = *pg0;\r\nri->flags &= ~MPT_RPORT_INFO_FLAGS_MISSING;\r\nif (!(ri->flags & MPT_RPORT_INFO_FLAGS_REGISTERED)) {\r\nri->flags |= MPT_RPORT_INFO_FLAGS_REGISTERED;\r\nrport = fc_remote_port_add(ioc->sh, channel, &rport_ids);\r\nif (rport) {\r\nri->rport = rport;\r\nif (new_ri)\r\nrport->dev_loss_tmo = mptfc_dev_loss_tmo;\r\nif (ri->starget) {\r\nvtarget = ri->starget->hostdata;\r\nif (vtarget) {\r\nvtarget->id = pg0->CurrentTargetID;\r\nvtarget->channel = pg0->CurrentBus;\r\nvtarget->deleted = 0;\r\n}\r\n}\r\n*((struct mptfc_rport_info **)rport->dd_data) = ri;\r\nfc_remote_port_rolechg(rport,roles);\r\npn = (u64)ri->pg0.WWPN.High << 32 | (u64)ri->pg0.WWPN.Low;\r\nnn = (u64)ri->pg0.WWNN.High << 32 | (u64)ri->pg0.WWNN.Low;\r\ndfcprintk (ioc, printk(MYIOC_s_DEBUG_FMT\r\n"mptfc_reg_dev.%d: %x, %llx / %llx, tid %d, "\r\n"rport tid %d, tmo %d\n",\r\nioc->name,\r\nioc->sh->host_no,\r\npg0->PortIdentifier,\r\n(unsigned long long)nn,\r\n(unsigned long long)pn,\r\npg0->CurrentTargetID,\r\nri->rport->scsi_target_id,\r\nri->rport->dev_loss_tmo));\r\n} else {\r\nlist_del(&ri->list);\r\nkfree(ri);\r\nri = NULL;\r\n}\r\n}\r\n}\r\nstatic void\r\nmptfc_target_destroy(struct scsi_target *starget)\r\n{\r\nstruct fc_rport *rport;\r\nstruct mptfc_rport_info *ri;\r\nrport = starget_to_rport(starget);\r\nif (rport) {\r\nri = *((struct mptfc_rport_info **)rport->dd_data);\r\nif (ri)\r\nri->starget = NULL;\r\n}\r\nkfree(starget->hostdata);\r\nstarget->hostdata = NULL;\r\n}\r\nstatic int\r\nmptfc_target_alloc(struct scsi_target *starget)\r\n{\r\nVirtTarget *vtarget;\r\nstruct fc_rport *rport;\r\nstruct mptfc_rport_info *ri;\r\nint rc;\r\nvtarget = kzalloc(sizeof(VirtTarget), GFP_KERNEL);\r\nif (!vtarget)\r\nreturn -ENOMEM;\r\nstarget->hostdata = vtarget;\r\nrc = -ENODEV;\r\nrport = starget_to_rport(starget);\r\nif (rport) {\r\nri = *((struct mptfc_rport_info **)rport->dd_data);\r\nif (ri) {\r\nvtarget->id = ri->pg0.CurrentTargetID;\r\nvtarget->channel = ri->pg0.CurrentBus;\r\nri->starget = starget;\r\nrc = 0;\r\n}\r\n}\r\nif (rc != 0) {\r\nkfree(vtarget);\r\nstarget->hostdata = NULL;\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\nmptfc_dump_lun_info(MPT_ADAPTER *ioc, struct fc_rport *rport, struct scsi_device *sdev,\r\nVirtTarget *vtarget)\r\n{\r\nu64 nn, pn;\r\nstruct mptfc_rport_info *ri;\r\nri = *((struct mptfc_rport_info **)rport->dd_data);\r\npn = (u64)ri->pg0.WWPN.High << 32 | (u64)ri->pg0.WWPN.Low;\r\nnn = (u64)ri->pg0.WWNN.High << 32 | (u64)ri->pg0.WWNN.Low;\r\ndfcprintk (ioc, printk(MYIOC_s_DEBUG_FMT\r\n"mptfc_slv_alloc.%d: num_luns %d, sdev.id %d, "\r\n"CurrentTargetID %d, %x %llx %llx\n",\r\nioc->name,\r\nsdev->host->host_no,\r\nvtarget->num_luns,\r\nsdev->id, ri->pg0.CurrentTargetID,\r\nri->pg0.PortIdentifier,\r\n(unsigned long long)pn,\r\n(unsigned long long)nn));\r\n}\r\nstatic int\r\nmptfc_slave_alloc(struct scsi_device *sdev)\r\n{\r\nMPT_SCSI_HOST *hd;\r\nVirtTarget *vtarget;\r\nVirtDevice *vdevice;\r\nstruct scsi_target *starget;\r\nstruct fc_rport *rport;\r\nMPT_ADAPTER *ioc;\r\nstarget = scsi_target(sdev);\r\nrport = starget_to_rport(starget);\r\nif (!rport || fc_remote_port_chkready(rport))\r\nreturn -ENXIO;\r\nhd = shost_priv(sdev->host);\r\nioc = hd->ioc;\r\nvdevice = kzalloc(sizeof(VirtDevice), GFP_KERNEL);\r\nif (!vdevice) {\r\nprintk(MYIOC_s_ERR_FMT "slave_alloc kmalloc(%zd) FAILED!\n",\r\nioc->name, sizeof(VirtDevice));\r\nreturn -ENOMEM;\r\n}\r\nsdev->hostdata = vdevice;\r\nvtarget = starget->hostdata;\r\nif (vtarget->num_luns == 0) {\r\nvtarget->ioc_id = ioc->id;\r\nvtarget->tflags = MPT_TARGET_FLAGS_Q_YES;\r\n}\r\nvdevice->vtarget = vtarget;\r\nvdevice->lun = sdev->lun;\r\nvtarget->num_luns++;\r\nmptfc_dump_lun_info(ioc, rport, sdev, vtarget);\r\nreturn 0;\r\n}\r\nstatic int\r\nmptfc_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *SCpnt)\r\n{\r\nstruct mptfc_rport_info *ri;\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(SCpnt->device));\r\nint err;\r\nVirtDevice *vdevice = SCpnt->device->hostdata;\r\nif (!vdevice || !vdevice->vtarget) {\r\nSCpnt->result = DID_NO_CONNECT << 16;\r\nSCpnt->scsi_done(SCpnt);\r\nreturn 0;\r\n}\r\nerr = fc_remote_port_chkready(rport);\r\nif (unlikely(err)) {\r\nSCpnt->result = err;\r\nSCpnt->scsi_done(SCpnt);\r\nreturn 0;\r\n}\r\nri = *((struct mptfc_rport_info **)rport->dd_data);\r\nif (unlikely(!ri)) {\r\nSCpnt->result = DID_IMM_RETRY << 16;\r\nSCpnt->scsi_done(SCpnt);\r\nreturn 0;\r\n}\r\nreturn mptscsih_qcmd(SCpnt);\r\n}\r\nstatic void\r\nmptfc_display_port_link_speed(MPT_ADAPTER *ioc, int portnum, FCPortPage0_t *pp0dest)\r\n{\r\nu8 old_speed, new_speed, state;\r\nchar *old, *new;\r\nif (portnum >= 2)\r\nreturn;\r\nold_speed = ioc->fc_link_speed[portnum];\r\nnew_speed = pp0dest->CurrentSpeed;\r\nstate = pp0dest->PortState;\r\nif (state != MPI_FCPORTPAGE0_PORTSTATE_OFFLINE &&\r\nnew_speed != MPI_FCPORTPAGE0_CURRENT_SPEED_UKNOWN) {\r\nold = old_speed == MPI_FCPORTPAGE0_CURRENT_SPEED_1GBIT ? "1 Gbps" :\r\nold_speed == MPI_FCPORTPAGE0_CURRENT_SPEED_2GBIT ? "2 Gbps" :\r\nold_speed == MPI_FCPORTPAGE0_CURRENT_SPEED_4GBIT ? "4 Gbps" :\r\n"Unknown";\r\nnew = new_speed == MPI_FCPORTPAGE0_CURRENT_SPEED_1GBIT ? "1 Gbps" :\r\nnew_speed == MPI_FCPORTPAGE0_CURRENT_SPEED_2GBIT ? "2 Gbps" :\r\nnew_speed == MPI_FCPORTPAGE0_CURRENT_SPEED_4GBIT ? "4 Gbps" :\r\n"Unknown";\r\nif (old_speed == 0)\r\nprintk(MYIOC_s_NOTE_FMT\r\n"FC Link Established, Speed = %s\n",\r\nioc->name, new);\r\nelse if (old_speed != new_speed)\r\nprintk(MYIOC_s_WARN_FMT\r\n"FC Link Speed Change, Old Speed = %s, New Speed = %s\n",\r\nioc->name, old, new);\r\nioc->fc_link_speed[portnum] = new_speed;\r\n}\r\n}\r\nstatic int\r\nmptfc_GetFcPortPage0(MPT_ADAPTER *ioc, int portnum)\r\n{\r\nConfigPageHeader_t hdr;\r\nCONFIGPARMS cfg;\r\nFCPortPage0_t *ppage0_alloc;\r\nFCPortPage0_t *pp0dest;\r\ndma_addr_t page0_dma;\r\nint data_sz;\r\nint copy_sz;\r\nint rc;\r\nint count = 400;\r\nif (portnum > 1)\r\nreturn -EINVAL;\r\nhdr.PageVersion = 0;\r\nhdr.PageLength = 0;\r\nhdr.PageNumber = 0;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_FC_PORT;\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.physAddr = -1;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.pageAddr = portnum;\r\ncfg.timeout = 0;\r\nif ((rc = mpt_config(ioc, &cfg)) != 0)\r\nreturn rc;\r\nif (hdr.PageLength == 0)\r\nreturn 0;\r\ndata_sz = hdr.PageLength * 4;\r\nrc = -ENOMEM;\r\nppage0_alloc = (FCPortPage0_t *) pci_alloc_consistent(ioc->pcidev, data_sz, &page0_dma);\r\nif (ppage0_alloc) {\r\ntry_again:\r\nmemset((u8 *)ppage0_alloc, 0, data_sz);\r\ncfg.physAddr = page0_dma;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nif ((rc = mpt_config(ioc, &cfg)) == 0) {\r\npp0dest = &ioc->fc_port_page0[portnum];\r\ncopy_sz = min_t(int, sizeof(FCPortPage0_t), data_sz);\r\nmemcpy(pp0dest, ppage0_alloc, copy_sz);\r\npp0dest->Flags = le32_to_cpu(pp0dest->Flags);\r\npp0dest->PortIdentifier = le32_to_cpu(pp0dest->PortIdentifier);\r\npp0dest->WWNN.Low = le32_to_cpu(pp0dest->WWNN.Low);\r\npp0dest->WWNN.High = le32_to_cpu(pp0dest->WWNN.High);\r\npp0dest->WWPN.Low = le32_to_cpu(pp0dest->WWPN.Low);\r\npp0dest->WWPN.High = le32_to_cpu(pp0dest->WWPN.High);\r\npp0dest->SupportedServiceClass = le32_to_cpu(pp0dest->SupportedServiceClass);\r\npp0dest->SupportedSpeeds = le32_to_cpu(pp0dest->SupportedSpeeds);\r\npp0dest->CurrentSpeed = le32_to_cpu(pp0dest->CurrentSpeed);\r\npp0dest->MaxFrameSize = le32_to_cpu(pp0dest->MaxFrameSize);\r\npp0dest->FabricWWNN.Low = le32_to_cpu(pp0dest->FabricWWNN.Low);\r\npp0dest->FabricWWNN.High = le32_to_cpu(pp0dest->FabricWWNN.High);\r\npp0dest->FabricWWPN.Low = le32_to_cpu(pp0dest->FabricWWPN.Low);\r\npp0dest->FabricWWPN.High = le32_to_cpu(pp0dest->FabricWWPN.High);\r\npp0dest->DiscoveredPortsCount = le32_to_cpu(pp0dest->DiscoveredPortsCount);\r\npp0dest->MaxInitiators = le32_to_cpu(pp0dest->MaxInitiators);\r\nif ((pp0dest->PortState == MPI_FCPORTPAGE0_PORTSTATE_UNKNOWN) ||\r\n(pp0dest->PortState == MPI_FCPORTPAGE0_PORTSTATE_ONLINE &&\r\n(pp0dest->Flags & MPI_FCPORTPAGE0_FLAGS_ATTACH_TYPE_MASK)\r\n== MPI_FCPORTPAGE0_FLAGS_ATTACH_NO_INIT)) {\r\nif (count-- > 0) {\r\nmsleep(100);\r\ngoto try_again;\r\n}\r\nprintk(MYIOC_s_INFO_FMT "Firmware discovery not"\r\n" complete.\n",\r\nioc->name);\r\n}\r\nmptfc_display_port_link_speed(ioc, portnum, pp0dest);\r\n}\r\npci_free_consistent(ioc->pcidev, data_sz, (u8 *) ppage0_alloc, page0_dma);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nmptfc_WriteFcPortPage1(MPT_ADAPTER *ioc, int portnum)\r\n{\r\nConfigPageHeader_t hdr;\r\nCONFIGPARMS cfg;\r\nint rc;\r\nif (portnum > 1)\r\nreturn -EINVAL;\r\nif (!(ioc->fc_data.fc_port_page1[portnum].data))\r\nreturn -EINVAL;\r\nhdr.PageVersion = 0;\r\nhdr.PageLength = 0;\r\nhdr.PageNumber = 1;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_FC_PORT;\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.physAddr = -1;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.pageAddr = portnum;\r\ncfg.timeout = 0;\r\nif ((rc = mpt_config(ioc, &cfg)) != 0)\r\nreturn rc;\r\nif (hdr.PageLength == 0)\r\nreturn -ENODEV;\r\nif (hdr.PageLength*4 != ioc->fc_data.fc_port_page1[portnum].pg_sz)\r\nreturn -EINVAL;\r\ncfg.physAddr = ioc->fc_data.fc_port_page1[portnum].dma;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_WRITE_CURRENT;\r\ncfg.dir = 1;\r\nrc = mpt_config(ioc, &cfg);\r\nreturn rc;\r\n}\r\nstatic int\r\nmptfc_GetFcPortPage1(MPT_ADAPTER *ioc, int portnum)\r\n{\r\nConfigPageHeader_t hdr;\r\nCONFIGPARMS cfg;\r\nFCPortPage1_t *page1_alloc;\r\ndma_addr_t page1_dma;\r\nint data_sz;\r\nint rc;\r\nif (portnum > 1)\r\nreturn -EINVAL;\r\nhdr.PageVersion = 0;\r\nhdr.PageLength = 0;\r\nhdr.PageNumber = 1;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_FC_PORT;\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.physAddr = -1;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.pageAddr = portnum;\r\ncfg.timeout = 0;\r\nif ((rc = mpt_config(ioc, &cfg)) != 0)\r\nreturn rc;\r\nif (hdr.PageLength == 0)\r\nreturn -ENODEV;\r\nstart_over:\r\nif (ioc->fc_data.fc_port_page1[portnum].data == NULL) {\r\ndata_sz = hdr.PageLength * 4;\r\nif (data_sz < sizeof(FCPortPage1_t))\r\ndata_sz = sizeof(FCPortPage1_t);\r\npage1_alloc = (FCPortPage1_t *) pci_alloc_consistent(ioc->pcidev,\r\ndata_sz,\r\n&page1_dma);\r\nif (!page1_alloc)\r\nreturn -ENOMEM;\r\n}\r\nelse {\r\npage1_alloc = ioc->fc_data.fc_port_page1[portnum].data;\r\npage1_dma = ioc->fc_data.fc_port_page1[portnum].dma;\r\ndata_sz = ioc->fc_data.fc_port_page1[portnum].pg_sz;\r\nif (hdr.PageLength * 4 > data_sz) {\r\nioc->fc_data.fc_port_page1[portnum].data = NULL;\r\npci_free_consistent(ioc->pcidev, data_sz, (u8 *)\r\npage1_alloc, page1_dma);\r\ngoto start_over;\r\n}\r\n}\r\nmemset(page1_alloc,0,data_sz);\r\ncfg.physAddr = page1_dma;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nif ((rc = mpt_config(ioc, &cfg)) == 0) {\r\nioc->fc_data.fc_port_page1[portnum].data = page1_alloc;\r\nioc->fc_data.fc_port_page1[portnum].pg_sz = data_sz;\r\nioc->fc_data.fc_port_page1[portnum].dma = page1_dma;\r\n}\r\nelse {\r\nioc->fc_data.fc_port_page1[portnum].data = NULL;\r\npci_free_consistent(ioc->pcidev, data_sz, (u8 *)\r\npage1_alloc, page1_dma);\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\nmptfc_SetFcPortPage1_defaults(MPT_ADAPTER *ioc)\r\n{\r\nint ii;\r\nFCPortPage1_t *pp1;\r\n#define MPTFC_FW_DEVICE_TIMEOUT (1)\r\n#define MPTFC_FW_IO_PEND_TIMEOUT (1)\r\n#define ON_FLAGS (MPI_FCPORTPAGE1_FLAGS_IMMEDIATE_ERROR_REPLY)\r\n#define OFF_FLAGS (MPI_FCPORTPAGE1_FLAGS_VERBOSE_RESCAN_EVENTS)\r\nfor (ii=0; ii<ioc->facts.NumberOfPorts; ii++) {\r\nif (mptfc_GetFcPortPage1(ioc, ii) != 0)\r\ncontinue;\r\npp1 = ioc->fc_data.fc_port_page1[ii].data;\r\nif ((pp1->InitiatorDeviceTimeout == MPTFC_FW_DEVICE_TIMEOUT)\r\n&& (pp1->InitiatorIoPendTimeout == MPTFC_FW_IO_PEND_TIMEOUT)\r\n&& ((pp1->Flags & ON_FLAGS) == ON_FLAGS)\r\n&& ((pp1->Flags & OFF_FLAGS) == 0))\r\ncontinue;\r\npp1->InitiatorDeviceTimeout = MPTFC_FW_DEVICE_TIMEOUT;\r\npp1->InitiatorIoPendTimeout = MPTFC_FW_IO_PEND_TIMEOUT;\r\npp1->Flags &= ~OFF_FLAGS;\r\npp1->Flags |= ON_FLAGS;\r\nmptfc_WriteFcPortPage1(ioc, ii);\r\n}\r\n}\r\nstatic void\r\nmptfc_init_host_attr(MPT_ADAPTER *ioc,int portnum)\r\n{\r\nunsigned class = 0;\r\nunsigned cos = 0;\r\nunsigned speed;\r\nunsigned port_type;\r\nunsigned port_state;\r\nFCPortPage0_t *pp0;\r\nstruct Scsi_Host *sh;\r\nchar *sn;\r\nif (portnum != 0)\r\nreturn;\r\npp0 = &ioc->fc_port_page0[portnum];\r\nsh = ioc->sh;\r\nsn = fc_host_symbolic_name(sh);\r\nsnprintf(sn, FC_SYMBOLIC_NAME_SIZE, "%s %s%08xh",\r\nioc->prod_name,\r\nMPT_FW_REV_MAGIC_ID_STRING,\r\nioc->facts.FWVersion.Word);\r\nfc_host_tgtid_bind_type(sh) = FC_TGTID_BIND_BY_WWPN;\r\nfc_host_maxframe_size(sh) = pp0->MaxFrameSize;\r\nfc_host_node_name(sh) =\r\n(u64)pp0->WWNN.High << 32 | (u64)pp0->WWNN.Low;\r\nfc_host_port_name(sh) =\r\n(u64)pp0->WWPN.High << 32 | (u64)pp0->WWPN.Low;\r\nfc_host_port_id(sh) = pp0->PortIdentifier;\r\nclass = pp0->SupportedServiceClass;\r\nif (class & MPI_FCPORTPAGE0_SUPPORT_CLASS_1)\r\ncos |= FC_COS_CLASS1;\r\nif (class & MPI_FCPORTPAGE0_SUPPORT_CLASS_2)\r\ncos |= FC_COS_CLASS2;\r\nif (class & MPI_FCPORTPAGE0_SUPPORT_CLASS_3)\r\ncos |= FC_COS_CLASS3;\r\nfc_host_supported_classes(sh) = cos;\r\nif (pp0->CurrentSpeed == MPI_FCPORTPAGE0_CURRENT_SPEED_1GBIT)\r\nspeed = FC_PORTSPEED_1GBIT;\r\nelse if (pp0->CurrentSpeed == MPI_FCPORTPAGE0_CURRENT_SPEED_2GBIT)\r\nspeed = FC_PORTSPEED_2GBIT;\r\nelse if (pp0->CurrentSpeed == MPI_FCPORTPAGE0_CURRENT_SPEED_4GBIT)\r\nspeed = FC_PORTSPEED_4GBIT;\r\nelse if (pp0->CurrentSpeed == MPI_FCPORTPAGE0_CURRENT_SPEED_10GBIT)\r\nspeed = FC_PORTSPEED_10GBIT;\r\nelse\r\nspeed = FC_PORTSPEED_UNKNOWN;\r\nfc_host_speed(sh) = speed;\r\nspeed = 0;\r\nif (pp0->SupportedSpeeds & MPI_FCPORTPAGE0_SUPPORT_1GBIT_SPEED)\r\nspeed |= FC_PORTSPEED_1GBIT;\r\nif (pp0->SupportedSpeeds & MPI_FCPORTPAGE0_SUPPORT_2GBIT_SPEED)\r\nspeed |= FC_PORTSPEED_2GBIT;\r\nif (pp0->SupportedSpeeds & MPI_FCPORTPAGE0_SUPPORT_4GBIT_SPEED)\r\nspeed |= FC_PORTSPEED_4GBIT;\r\nif (pp0->SupportedSpeeds & MPI_FCPORTPAGE0_SUPPORT_10GBIT_SPEED)\r\nspeed |= FC_PORTSPEED_10GBIT;\r\nfc_host_supported_speeds(sh) = speed;\r\nport_state = FC_PORTSTATE_UNKNOWN;\r\nif (pp0->PortState == MPI_FCPORTPAGE0_PORTSTATE_ONLINE)\r\nport_state = FC_PORTSTATE_ONLINE;\r\nelse if (pp0->PortState == MPI_FCPORTPAGE0_PORTSTATE_OFFLINE)\r\nport_state = FC_PORTSTATE_LINKDOWN;\r\nfc_host_port_state(sh) = port_state;\r\nport_type = FC_PORTTYPE_UNKNOWN;\r\nif (pp0->Flags & MPI_FCPORTPAGE0_FLAGS_ATTACH_POINT_TO_POINT)\r\nport_type = FC_PORTTYPE_PTP;\r\nelse if (pp0->Flags & MPI_FCPORTPAGE0_FLAGS_ATTACH_PRIVATE_LOOP)\r\nport_type = FC_PORTTYPE_LPORT;\r\nelse if (pp0->Flags & MPI_FCPORTPAGE0_FLAGS_ATTACH_PUBLIC_LOOP)\r\nport_type = FC_PORTTYPE_NLPORT;\r\nelse if (pp0->Flags & MPI_FCPORTPAGE0_FLAGS_ATTACH_FABRIC_DIRECT)\r\nport_type = FC_PORTTYPE_NPORT;\r\nfc_host_port_type(sh) = port_type;\r\nfc_host_fabric_name(sh) =\r\n(pp0->Flags & MPI_FCPORTPAGE0_FLAGS_FABRIC_WWN_VALID) ?\r\n(u64) pp0->FabricWWNN.High << 32 | (u64) pp0->FabricWWPN.Low :\r\n(u64)pp0->WWNN.High << 32 | (u64)pp0->WWNN.Low;\r\n}\r\nstatic void\r\nmptfc_link_status_change(struct work_struct *work)\r\n{\r\nMPT_ADAPTER *ioc =\r\ncontainer_of(work, MPT_ADAPTER, fc_rescan_work);\r\nint ii;\r\nfor (ii=0; ii < ioc->facts.NumberOfPorts; ii++)\r\n(void) mptfc_GetFcPortPage0(ioc, ii);\r\n}\r\nstatic void\r\nmptfc_setup_reset(struct work_struct *work)\r\n{\r\nMPT_ADAPTER *ioc =\r\ncontainer_of(work, MPT_ADAPTER, fc_setup_reset_work);\r\nu64 pn;\r\nstruct mptfc_rport_info *ri;\r\nstruct scsi_target *starget;\r\nVirtTarget *vtarget;\r\nlist_for_each_entry(ri, &ioc->fc_rports, list) {\r\nif (ri->flags & MPT_RPORT_INFO_FLAGS_REGISTERED) {\r\nri->flags &= ~MPT_RPORT_INFO_FLAGS_REGISTERED;\r\nfc_remote_port_delete(ri->rport);\r\nri->rport = NULL;\r\nstarget = ri->starget;\r\nif (starget) {\r\nvtarget = starget->hostdata;\r\nif (vtarget)\r\nvtarget->deleted = 1;\r\n}\r\npn = (u64)ri->pg0.WWPN.High << 32 |\r\n(u64)ri->pg0.WWPN.Low;\r\ndfcprintk (ioc, printk(MYIOC_s_DEBUG_FMT\r\n"mptfc_setup_reset.%d: %llx deleted\n",\r\nioc->name,\r\nioc->sh->host_no,\r\n(unsigned long long)pn));\r\n}\r\n}\r\n}\r\nstatic void\r\nmptfc_rescan_devices(struct work_struct *work)\r\n{\r\nMPT_ADAPTER *ioc =\r\ncontainer_of(work, MPT_ADAPTER, fc_rescan_work);\r\nint ii;\r\nu64 pn;\r\nstruct mptfc_rport_info *ri;\r\nstruct scsi_target *starget;\r\nVirtTarget *vtarget;\r\nlist_for_each_entry(ri, &ioc->fc_rports, list) {\r\nif (ri->flags & MPT_RPORT_INFO_FLAGS_REGISTERED) {\r\nri->flags |= MPT_RPORT_INFO_FLAGS_MISSING;\r\n}\r\n}\r\nfor (ii=0; ii < ioc->facts.NumberOfPorts; ii++) {\r\n(void) mptfc_GetFcPortPage0(ioc, ii);\r\nmptfc_init_host_attr(ioc, ii);\r\nmptfc_GetFcDevPage0(ioc, ii, mptfc_register_dev);\r\n}\r\nlist_for_each_entry(ri, &ioc->fc_rports, list) {\r\nif (ri->flags & MPT_RPORT_INFO_FLAGS_MISSING) {\r\nri->flags &= ~(MPT_RPORT_INFO_FLAGS_REGISTERED|\r\nMPT_RPORT_INFO_FLAGS_MISSING);\r\nfc_remote_port_delete(ri->rport);\r\nri->rport = NULL;\r\nstarget = ri->starget;\r\nif (starget) {\r\nvtarget = starget->hostdata;\r\nif (vtarget)\r\nvtarget->deleted = 1;\r\n}\r\npn = (u64)ri->pg0.WWPN.High << 32 |\r\n(u64)ri->pg0.WWPN.Low;\r\ndfcprintk (ioc, printk(MYIOC_s_DEBUG_FMT\r\n"mptfc_rescan.%d: %llx deleted\n",\r\nioc->name,\r\nioc->sh->host_no,\r\n(unsigned long long)pn));\r\n}\r\n}\r\n}\r\nstatic int\r\nmptfc_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct Scsi_Host *sh;\r\nMPT_SCSI_HOST *hd;\r\nMPT_ADAPTER *ioc;\r\nunsigned long flags;\r\nint ii;\r\nint numSGE = 0;\r\nint scale;\r\nint ioc_cap;\r\nint error=0;\r\nint r;\r\nif ((r = mpt_attach(pdev,id)) != 0)\r\nreturn r;\r\nioc = pci_get_drvdata(pdev);\r\nioc->DoneCtx = mptfcDoneCtx;\r\nioc->TaskCtx = mptfcTaskCtx;\r\nioc->InternalCtx = mptfcInternalCtx;\r\nif (ioc->last_state != MPI_IOC_STATE_OPERATIONAL) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"Skipping because it's not operational!\n",\r\nioc->name);\r\nerror = -ENODEV;\r\ngoto out_mptfc_probe;\r\n}\r\nif (!ioc->active) {\r\nprintk(MYIOC_s_WARN_FMT "Skipping because it's disabled!\n",\r\nioc->name);\r\nerror = -ENODEV;\r\ngoto out_mptfc_probe;\r\n}\r\nioc_cap = 0;\r\nfor (ii=0; ii < ioc->facts.NumberOfPorts; ii++) {\r\nif (ioc->pfacts[ii].ProtocolFlags &\r\nMPI_PORTFACTS_PROTOCOL_INITIATOR)\r\nioc_cap ++;\r\n}\r\nif (!ioc_cap) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"Skipping ioc=%p because SCSI Initiator mode is NOT enabled!\n",\r\nioc->name, ioc);\r\nreturn 0;\r\n}\r\nsh = scsi_host_alloc(&mptfc_driver_template, sizeof(MPT_SCSI_HOST));\r\nif (!sh) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"Unable to register controller with SCSI subsystem\n",\r\nioc->name);\r\nerror = -1;\r\ngoto out_mptfc_probe;\r\n}\r\nspin_lock_init(&ioc->fc_rescan_work_lock);\r\nINIT_WORK(&ioc->fc_rescan_work, mptfc_rescan_devices);\r\nINIT_WORK(&ioc->fc_setup_reset_work, mptfc_setup_reset);\r\nINIT_WORK(&ioc->fc_lsc_work, mptfc_link_status_change);\r\nspin_lock_irqsave(&ioc->FreeQlock, flags);\r\nioc->sh = sh;\r\nsh->io_port = 0;\r\nsh->n_io_port = 0;\r\nsh->irq = 0;\r\nsh->max_cmd_len = 16;\r\nsh->max_id = ioc->pfacts->MaxDevices;\r\nsh->max_lun = max_lun;\r\nsh->unique_id = ioc->id;\r\nscale = ioc->req_sz/ioc->SGE_size;\r\nif (ioc->sg_addr_size == sizeof(u64)) {\r\nnumSGE = (scale - 1) *\r\n(ioc->facts.MaxChainDepth-1) + scale +\r\n(ioc->req_sz - 60) / ioc->SGE_size;\r\n} else {\r\nnumSGE = 1 + (scale - 1) *\r\n(ioc->facts.MaxChainDepth-1) + scale +\r\n(ioc->req_sz - 64) / ioc->SGE_size;\r\n}\r\nif (numSGE < sh->sg_tablesize) {\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Resetting sg_tablesize to %d from %d\n",\r\nioc->name, numSGE, sh->sg_tablesize));\r\nsh->sg_tablesize = numSGE;\r\n}\r\nspin_unlock_irqrestore(&ioc->FreeQlock, flags);\r\nhd = shost_priv(sh);\r\nhd->ioc = ioc;\r\nioc->ScsiLookup = kcalloc(ioc->req_depth, sizeof(void *), GFP_ATOMIC);\r\nif (!ioc->ScsiLookup) {\r\nerror = -ENOMEM;\r\ngoto out_mptfc_probe;\r\n}\r\nspin_lock_init(&ioc->scsi_lookup_lock);\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT "ScsiLookup @ %p\n",\r\nioc->name, ioc->ScsiLookup));\r\nhd->last_queue_full = 0;\r\nsh->transportt = mptfc_transport_template;\r\nerror = scsi_add_host (sh, &ioc->pcidev->dev);\r\nif(error) {\r\ndprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"scsi_add_host failed\n", ioc->name));\r\ngoto out_mptfc_probe;\r\n}\r\nsnprintf(ioc->fc_rescan_work_q_name, sizeof(ioc->fc_rescan_work_q_name),\r\n"mptfc_wq_%d", sh->host_no);\r\nioc->fc_rescan_work_q =\r\ncreate_singlethread_workqueue(ioc->fc_rescan_work_q_name);\r\nif (!ioc->fc_rescan_work_q)\r\ngoto out_mptfc_probe;\r\nfor (ii=0; ii < ioc->facts.NumberOfPorts; ii++) {\r\n(void) mptfc_GetFcPortPage0(ioc, ii);\r\n}\r\nmptfc_SetFcPortPage1_defaults(ioc);\r\nqueue_work(ioc->fc_rescan_work_q, &ioc->fc_rescan_work);\r\nflush_workqueue(ioc->fc_rescan_work_q);\r\nreturn 0;\r\nout_mptfc_probe:\r\nmptscsih_remove(pdev);\r\nreturn error;\r\n}\r\nstatic int\r\nmptfc_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)\r\n{\r\nMPT_SCSI_HOST *hd;\r\nu8 event = le32_to_cpu(pEvReply->Event) & 0xFF;\r\nunsigned long flags;\r\nint rc=1;\r\nif (ioc->bus_type != FC)\r\nreturn 0;\r\ndevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT "MPT event (=%02Xh) routed to SCSI host driver!\n",\r\nioc->name, event));\r\nif (ioc->sh == NULL ||\r\n((hd = shost_priv(ioc->sh)) == NULL))\r\nreturn 1;\r\nswitch (event) {\r\ncase MPI_EVENT_RESCAN:\r\nspin_lock_irqsave(&ioc->fc_rescan_work_lock, flags);\r\nif (ioc->fc_rescan_work_q) {\r\nqueue_work(ioc->fc_rescan_work_q,\r\n&ioc->fc_rescan_work);\r\n}\r\nspin_unlock_irqrestore(&ioc->fc_rescan_work_lock, flags);\r\nbreak;\r\ncase MPI_EVENT_LINK_STATUS_CHANGE:\r\nspin_lock_irqsave(&ioc->fc_rescan_work_lock, flags);\r\nif (ioc->fc_rescan_work_q) {\r\nqueue_work(ioc->fc_rescan_work_q,\r\n&ioc->fc_lsc_work);\r\n}\r\nspin_unlock_irqrestore(&ioc->fc_rescan_work_lock, flags);\r\nbreak;\r\ndefault:\r\nrc = mptscsih_event_process(ioc,pEvReply);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nmptfc_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)\r\n{\r\nint rc;\r\nunsigned long flags;\r\nrc = mptscsih_ioc_reset(ioc,reset_phase);\r\nif ((ioc->bus_type != FC) || (!rc))\r\nreturn rc;\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n": IOC %s_reset routed to FC host driver!\n",ioc->name,\r\nreset_phase==MPT_IOC_SETUP_RESET ? "setup" : (\r\nreset_phase==MPT_IOC_PRE_RESET ? "pre" : "post")));\r\nif (reset_phase == MPT_IOC_SETUP_RESET) {\r\nspin_lock_irqsave(&ioc->fc_rescan_work_lock, flags);\r\nif (ioc->fc_rescan_work_q) {\r\nqueue_work(ioc->fc_rescan_work_q,\r\n&ioc->fc_setup_reset_work);\r\n}\r\nspin_unlock_irqrestore(&ioc->fc_rescan_work_lock, flags);\r\n}\r\nelse if (reset_phase == MPT_IOC_PRE_RESET) {\r\n}\r\nelse {\r\nmptfc_SetFcPortPage1_defaults(ioc);\r\nspin_lock_irqsave(&ioc->fc_rescan_work_lock, flags);\r\nif (ioc->fc_rescan_work_q) {\r\nqueue_work(ioc->fc_rescan_work_q,\r\n&ioc->fc_rescan_work);\r\n}\r\nspin_unlock_irqrestore(&ioc->fc_rescan_work_lock, flags);\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init\r\nmptfc_init(void)\r\n{\r\nint error;\r\nshow_mptmod_ver(my_NAME, my_VERSION);\r\nif (mptfc_dev_loss_tmo <= 0)\r\nmptfc_dev_loss_tmo = MPTFC_DEV_LOSS_TMO;\r\nmptfc_transport_template =\r\nfc_attach_transport(&mptfc_transport_functions);\r\nif (!mptfc_transport_template)\r\nreturn -ENODEV;\r\nmptfcDoneCtx = mpt_register(mptscsih_io_done, MPTFC_DRIVER,\r\n"mptscsih_scandv_complete");\r\nmptfcTaskCtx = mpt_register(mptscsih_taskmgmt_complete, MPTFC_DRIVER,\r\n"mptscsih_scandv_complete");\r\nmptfcInternalCtx = mpt_register(mptscsih_scandv_complete, MPTFC_DRIVER,\r\n"mptscsih_scandv_complete");\r\nmpt_event_register(mptfcDoneCtx, mptfc_event_process);\r\nmpt_reset_register(mptfcDoneCtx, mptfc_ioc_reset);\r\nerror = pci_register_driver(&mptfc_driver);\r\nif (error)\r\nfc_release_transport(mptfc_transport_template);\r\nreturn error;\r\n}\r\nstatic void mptfc_remove(struct pci_dev *pdev)\r\n{\r\nMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\r\nstruct mptfc_rport_info *p, *n;\r\nstruct workqueue_struct *work_q;\r\nunsigned long flags;\r\nint ii;\r\nif ((work_q=ioc->fc_rescan_work_q)) {\r\nspin_lock_irqsave(&ioc->fc_rescan_work_lock, flags);\r\nioc->fc_rescan_work_q = NULL;\r\nspin_unlock_irqrestore(&ioc->fc_rescan_work_lock, flags);\r\ndestroy_workqueue(work_q);\r\n}\r\nfc_remove_host(ioc->sh);\r\nlist_for_each_entry_safe(p, n, &ioc->fc_rports, list) {\r\nlist_del(&p->list);\r\nkfree(p);\r\n}\r\nfor (ii=0; ii<ioc->facts.NumberOfPorts; ii++) {\r\nif (ioc->fc_data.fc_port_page1[ii].data) {\r\npci_free_consistent(ioc->pcidev,\r\nioc->fc_data.fc_port_page1[ii].pg_sz,\r\n(u8 *) ioc->fc_data.fc_port_page1[ii].data,\r\nioc->fc_data.fc_port_page1[ii].dma);\r\nioc->fc_data.fc_port_page1[ii].data = NULL;\r\n}\r\n}\r\nmptscsih_remove(pdev);\r\n}\r\nstatic void __exit\r\nmptfc_exit(void)\r\n{\r\npci_unregister_driver(&mptfc_driver);\r\nfc_release_transport(mptfc_transport_template);\r\nmpt_reset_deregister(mptfcDoneCtx);\r\nmpt_event_deregister(mptfcDoneCtx);\r\nmpt_deregister(mptfcInternalCtx);\r\nmpt_deregister(mptfcTaskCtx);\r\nmpt_deregister(mptfcDoneCtx);\r\n}
