struct memregion *\r\nvisor_memregion_create(HOSTADDRESS physaddr, ulong nbytes)\r\n{\r\nstruct memregion *rc = NULL;\r\nstruct memregion *memregion = kzalloc(sizeof(*memregion),\r\nGFP_KERNEL | __GFP_NORETRY);\r\nif (memregion == NULL) {\r\nERRDRV("visor_memregion_create allocation failed");\r\nreturn NULL;\r\n}\r\nmemregion->physaddr = physaddr;\r\nmemregion->nbytes = nbytes;\r\nmemregion->overlapped = FALSE;\r\nif (!mapit(memregion)) {\r\nrc = NULL;\r\ngoto cleanup;\r\n}\r\nrc = memregion;\r\ncleanup:\r\nif (rc == NULL) {\r\nvisor_memregion_destroy(memregion);\r\nmemregion = NULL;\r\n}\r\nreturn rc;\r\n}\r\nstruct memregion *\r\nvisor_memregion_create_overlapped(struct memregion *parent, ulong offset,\r\nulong nbytes)\r\n{\r\nstruct memregion *memregion = NULL;\r\nif (parent == NULL) {\r\nERRDRV("%s parent is NULL", __func__);\r\nreturn NULL;\r\n}\r\nif (parent->mapped == NULL) {\r\nERRDRV("%s parent is not mapped!", __func__);\r\nreturn NULL;\r\n}\r\nif ((offset >= parent->nbytes) ||\r\n((offset + nbytes) >= parent->nbytes)) {\r\nERRDRV("%s range (%lu,%lu) out of parent range",\r\n__func__, offset, nbytes);\r\nreturn NULL;\r\n}\r\nmemregion = kzalloc(sizeof(*memregion), GFP_KERNEL|__GFP_NORETRY);\r\nif (memregion == NULL) {\r\nERRDRV("%s allocation failed", __func__);\r\nreturn NULL;\r\n}\r\nmemregion->physaddr = parent->physaddr + offset;\r\nmemregion->nbytes = nbytes;\r\nmemregion->mapped = ((u8 __iomem *)(parent->mapped)) + offset;\r\nmemregion->requested = FALSE;\r\nmemregion->overlapped = TRUE;\r\nreturn memregion;\r\n}\r\nstatic BOOL\r\nmapit(struct memregion *memregion)\r\n{\r\nulong physaddr = (ulong)(memregion->physaddr);\r\nulong nbytes = memregion->nbytes;\r\nmemregion->requested = FALSE;\r\nif (!request_mem_region(physaddr, nbytes, MYDRVNAME))\r\nERRDRV("cannot reserve channel memory @0x%lx for 0x%lx-- no big deal",\r\nphysaddr, nbytes);\r\nelse\r\nmemregion->requested = TRUE;\r\nmemregion->mapped = ioremap_cache(physaddr, nbytes);\r\nif (memregion->mapped == NULL) {\r\nERRDRV("cannot ioremap_cache channel memory @0x%lx for 0x%lx",\r\nphysaddr, nbytes);\r\nreturn FALSE;\r\n}\r\nreturn TRUE;\r\n}\r\nstatic void\r\nunmapit(struct memregion *memregion)\r\n{\r\nif (memregion->mapped != NULL) {\r\niounmap(memregion->mapped);\r\nmemregion->mapped = NULL;\r\n}\r\nif (memregion->requested) {\r\nrelease_mem_region((ulong)(memregion->physaddr),\r\nmemregion->nbytes);\r\nmemregion->requested = FALSE;\r\n}\r\n}\r\nHOSTADDRESS\r\nvisor_memregion_get_physaddr(struct memregion *memregion)\r\n{\r\nreturn memregion->physaddr;\r\n}\r\nulong\r\nvisor_memregion_get_nbytes(struct memregion *memregion)\r\n{\r\nreturn memregion->nbytes;\r\n}\r\nvoid __iomem *\r\nvisor_memregion_get_pointer(struct memregion *memregion)\r\n{\r\nreturn memregion->mapped;\r\n}\r\nint\r\nvisor_memregion_resize(struct memregion *memregion, ulong newsize)\r\n{\r\nif (newsize == memregion->nbytes)\r\nreturn 0;\r\nif (memregion->overlapped)\r\nmemregion->nbytes = newsize;\r\nelse {\r\nunmapit(memregion);\r\nmemregion->nbytes = newsize;\r\nif (!mapit(memregion))\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmemregion_readwrite(BOOL is_write,\r\nstruct memregion *memregion, ulong offset,\r\nvoid *local, ulong nbytes)\r\n{\r\nif (offset + nbytes > memregion->nbytes) {\r\nERRDRV("memregion_readwrite offset out of range!!");\r\nreturn -EIO;\r\n}\r\nif (is_write)\r\nmemcpy_toio(memregion->mapped + offset, local, nbytes);\r\nelse\r\nmemcpy_fromio(local, memregion->mapped + offset, nbytes);\r\nreturn 0;\r\n}\r\nint\r\nvisor_memregion_read(struct memregion *memregion, ulong offset, void *dest,\r\nulong nbytes)\r\n{\r\nreturn memregion_readwrite(FALSE, memregion, offset, dest, nbytes);\r\n}\r\nint\r\nvisor_memregion_write(struct memregion *memregion, ulong offset, void *src,\r\nulong nbytes)\r\n{\r\nreturn memregion_readwrite(TRUE, memregion, offset, src, nbytes);\r\n}\r\nvoid\r\nvisor_memregion_destroy(struct memregion *memregion)\r\n{\r\nif (memregion == NULL)\r\nreturn;\r\nif (!memregion->overlapped)\r\nunmapit(memregion);\r\nkfree(memregion);\r\n}
