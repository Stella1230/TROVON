static const char *brcmf_fws_get_tlv_name(enum brcmf_fws_tlv_type id)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(brcmf_fws_tlv_names); i++)\r\nif (brcmf_fws_tlv_names[i].id == id)\r\nreturn brcmf_fws_tlv_names[i].name;\r\nreturn "INVALID";\r\n}\r\nstatic const char *brcmf_fws_get_tlv_name(enum brcmf_fws_tlv_type id)\r\n{\r\nreturn "NODEBUG";\r\n}\r\nstatic int brcmf_fws_get_tlv_len(struct brcmf_fws_info *fws,\r\nenum brcmf_fws_tlv_type id)\r\n{\r\nswitch (id) {\r\nBRCMF_FWS_TLV_DEFLIST\r\ndefault:\r\nfws->stats.tlv_invalid_type++;\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void brcmf_fws_lock(struct brcmf_fws_info *fws)\r\n__acquires(&fws->spinlock\r\nstatic void brcmf_fws_unlock(struct brcmf_fws_info *fws)\r\n__releases(&fws->spinlock\r\nstatic bool brcmf_fws_ifidx_match(struct sk_buff *skb, void *arg)\r\n{\r\nu32 ifidx = brcmf_skb_if_flags_get_field(skb, INDEX);\r\nreturn ifidx == *(int *)arg;\r\n}\r\nstatic void brcmf_fws_psq_flush(struct brcmf_fws_info *fws, struct pktq *q,\r\nint ifidx)\r\n{\r\nbool (*matchfn)(struct sk_buff *, void *) = NULL;\r\nstruct sk_buff *skb;\r\nint prec;\r\nif (ifidx != -1)\r\nmatchfn = brcmf_fws_ifidx_match;\r\nfor (prec = 0; prec < q->num_prec; prec++) {\r\nskb = brcmu_pktq_pdeq_match(q, prec, matchfn, &ifidx);\r\nwhile (skb) {\r\nbrcmu_pkt_buf_free_skb(skb);\r\nskb = brcmu_pktq_pdeq_match(q, prec, matchfn, &ifidx);\r\n}\r\n}\r\n}\r\nstatic void brcmf_fws_hanger_init(struct brcmf_fws_hanger *hanger)\r\n{\r\nint i;\r\nmemset(hanger, 0, sizeof(*hanger));\r\nfor (i = 0; i < ARRAY_SIZE(hanger->items); i++)\r\nhanger->items[i].state = BRCMF_FWS_HANGER_ITEM_STATE_FREE;\r\n}\r\nstatic u32 brcmf_fws_hanger_get_free_slot(struct brcmf_fws_hanger *h)\r\n{\r\nu32 i;\r\ni = (h->slot_pos + 1) % BRCMF_FWS_HANGER_MAXITEMS;\r\nwhile (i != h->slot_pos) {\r\nif (h->items[i].state == BRCMF_FWS_HANGER_ITEM_STATE_FREE) {\r\nh->slot_pos = i;\r\ngoto done;\r\n}\r\ni++;\r\nif (i == BRCMF_FWS_HANGER_MAXITEMS)\r\ni = 0;\r\n}\r\nbrcmf_err("all slots occupied\n");\r\nh->failed_slotfind++;\r\ni = BRCMF_FWS_HANGER_MAXITEMS;\r\ndone:\r\nreturn i;\r\n}\r\nstatic int brcmf_fws_hanger_pushpkt(struct brcmf_fws_hanger *h,\r\nstruct sk_buff *pkt, u32 slot_id)\r\n{\r\nif (slot_id >= BRCMF_FWS_HANGER_MAXITEMS)\r\nreturn -ENOENT;\r\nif (h->items[slot_id].state != BRCMF_FWS_HANGER_ITEM_STATE_FREE) {\r\nbrcmf_err("slot is not free\n");\r\nh->failed_to_push++;\r\nreturn -EINVAL;\r\n}\r\nh->items[slot_id].state = BRCMF_FWS_HANGER_ITEM_STATE_INUSE;\r\nh->items[slot_id].pkt = pkt;\r\nh->pushed++;\r\nreturn 0;\r\n}\r\nstatic int brcmf_fws_hanger_poppkt(struct brcmf_fws_hanger *h,\r\nu32 slot_id, struct sk_buff **pktout,\r\nbool remove_item)\r\n{\r\nif (slot_id >= BRCMF_FWS_HANGER_MAXITEMS)\r\nreturn -ENOENT;\r\nif (h->items[slot_id].state == BRCMF_FWS_HANGER_ITEM_STATE_FREE) {\r\nbrcmf_err("entry not in use\n");\r\nh->failed_to_pop++;\r\nreturn -EINVAL;\r\n}\r\n*pktout = h->items[slot_id].pkt;\r\nif (remove_item) {\r\nh->items[slot_id].state = BRCMF_FWS_HANGER_ITEM_STATE_FREE;\r\nh->items[slot_id].pkt = NULL;\r\nh->popped++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int brcmf_fws_hanger_mark_suppressed(struct brcmf_fws_hanger *h,\r\nu32 slot_id)\r\n{\r\nif (slot_id >= BRCMF_FWS_HANGER_MAXITEMS)\r\nreturn -ENOENT;\r\nif (h->items[slot_id].state == BRCMF_FWS_HANGER_ITEM_STATE_FREE) {\r\nbrcmf_err("entry not in use\n");\r\nreturn -EINVAL;\r\n}\r\nh->items[slot_id].state = BRCMF_FWS_HANGER_ITEM_STATE_INUSE_SUPPRESSED;\r\nreturn 0;\r\n}\r\nstatic void brcmf_fws_hanger_cleanup(struct brcmf_fws_info *fws,\r\nbool (*fn)(struct sk_buff *, void *),\r\nint ifidx)\r\n{\r\nstruct brcmf_fws_hanger *h = &fws->hanger;\r\nstruct sk_buff *skb;\r\nint i;\r\nenum brcmf_fws_hanger_item_state s;\r\nfor (i = 0; i < ARRAY_SIZE(h->items); i++) {\r\ns = h->items[i].state;\r\nif (s == BRCMF_FWS_HANGER_ITEM_STATE_INUSE ||\r\ns == BRCMF_FWS_HANGER_ITEM_STATE_INUSE_SUPPRESSED) {\r\nskb = h->items[i].pkt;\r\nif (fn == NULL || fn(skb, &ifidx)) {\r\nif (s == BRCMF_FWS_HANGER_ITEM_STATE_INUSE)\r\nbrcmu_pkt_buf_free_skb(skb);\r\nh->items[i].state =\r\nBRCMF_FWS_HANGER_ITEM_STATE_FREE;\r\n}\r\n}\r\n}\r\n}\r\nstatic void brcmf_fws_macdesc_set_name(struct brcmf_fws_info *fws,\r\nstruct brcmf_fws_mac_descriptor *desc)\r\n{\r\nif (desc == &fws->desc.other)\r\nstrlcpy(desc->name, "MAC-OTHER", sizeof(desc->name));\r\nelse if (desc->mac_handle)\r\nscnprintf(desc->name, sizeof(desc->name), "MAC-%d:%d",\r\ndesc->mac_handle, desc->interface_id);\r\nelse\r\nscnprintf(desc->name, sizeof(desc->name), "MACIF:%d",\r\ndesc->interface_id);\r\n}\r\nstatic void brcmf_fws_macdesc_init(struct brcmf_fws_mac_descriptor *desc,\r\nu8 *addr, u8 ifidx)\r\n{\r\nbrcmf_dbg(TRACE,\r\n"enter: desc %p ea=%pM, ifidx=%u\n", desc, addr, ifidx);\r\ndesc->occupied = 1;\r\ndesc->state = BRCMF_FWS_STATE_OPEN;\r\ndesc->requested_credit = 0;\r\ndesc->requested_packet = 0;\r\ndesc->interface_id = ifidx;\r\ndesc->ac_bitmap = 0xff;\r\nif (addr)\r\nmemcpy(&desc->ea[0], addr, ETH_ALEN);\r\n}\r\nstatic\r\nvoid brcmf_fws_macdesc_deinit(struct brcmf_fws_mac_descriptor *desc)\r\n{\r\nbrcmf_dbg(TRACE,\r\n"enter: ea=%pM, ifidx=%u\n", desc->ea, desc->interface_id);\r\ndesc->occupied = 0;\r\ndesc->state = BRCMF_FWS_STATE_CLOSE;\r\ndesc->requested_credit = 0;\r\ndesc->requested_packet = 0;\r\n}\r\nstatic struct brcmf_fws_mac_descriptor *\r\nbrcmf_fws_macdesc_lookup(struct brcmf_fws_info *fws, u8 *ea)\r\n{\r\nstruct brcmf_fws_mac_descriptor *entry;\r\nint i;\r\nif (ea == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nentry = &fws->desc.nodes[0];\r\nfor (i = 0; i < ARRAY_SIZE(fws->desc.nodes); i++) {\r\nif (entry->occupied && !memcmp(entry->ea, ea, ETH_ALEN))\r\nreturn entry;\r\nentry++;\r\n}\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nstatic struct brcmf_fws_mac_descriptor*\r\nbrcmf_fws_macdesc_find(struct brcmf_fws_info *fws, struct brcmf_if *ifp, u8 *da)\r\n{\r\nstruct brcmf_fws_mac_descriptor *entry = &fws->desc.other;\r\nbool multicast;\r\nmulticast = is_multicast_ether_addr(da);\r\nif (multicast && ifp->fws_desc) {\r\nentry = ifp->fws_desc;\r\ngoto done;\r\n}\r\nentry = brcmf_fws_macdesc_lookup(fws, da);\r\nif (IS_ERR(entry))\r\nentry = ifp->fws_desc;\r\ndone:\r\nreturn entry;\r\n}\r\nstatic bool brcmf_fws_macdesc_closed(struct brcmf_fws_info *fws,\r\nstruct brcmf_fws_mac_descriptor *entry,\r\nint fifo)\r\n{\r\nstruct brcmf_fws_mac_descriptor *if_entry;\r\nbool closed;\r\nif (entry->mac_handle) {\r\nif_entry = &fws->desc.iface[entry->interface_id];\r\nif (if_entry->state == BRCMF_FWS_STATE_CLOSE)\r\nreturn true;\r\n}\r\nclosed = entry->state == BRCMF_FWS_STATE_CLOSE &&\r\n!entry->requested_credit && !entry->requested_packet;\r\nreturn closed || !(entry->ac_bitmap & BIT(fifo));\r\n}\r\nstatic void brcmf_fws_macdesc_cleanup(struct brcmf_fws_info *fws,\r\nstruct brcmf_fws_mac_descriptor *entry,\r\nint ifidx)\r\n{\r\nif (entry->occupied && (ifidx == -1 || ifidx == entry->interface_id)) {\r\nbrcmf_fws_psq_flush(fws, &entry->psq, ifidx);\r\nentry->occupied = !!(entry->psq.len);\r\n}\r\n}\r\nstatic void brcmf_fws_bus_txq_cleanup(struct brcmf_fws_info *fws,\r\nbool (*fn)(struct sk_buff *, void *),\r\nint ifidx)\r\n{\r\nstruct brcmf_fws_hanger_item *hi;\r\nstruct pktq *txq;\r\nstruct sk_buff *skb;\r\nint prec;\r\nu32 hslot;\r\ntxq = brcmf_bus_gettxq(fws->drvr->bus_if);\r\nif (IS_ERR(txq)) {\r\nbrcmf_dbg(TRACE, "no txq to clean up\n");\r\nreturn;\r\n}\r\nfor (prec = 0; prec < txq->num_prec; prec++) {\r\nskb = brcmu_pktq_pdeq_match(txq, prec, fn, &ifidx);\r\nwhile (skb) {\r\nhslot = brcmf_skb_htod_tag_get_field(skb, HSLOT);\r\nhi = &fws->hanger.items[hslot];\r\nWARN_ON(skb != hi->pkt);\r\nhi->state = BRCMF_FWS_HANGER_ITEM_STATE_FREE;\r\nbrcmu_pkt_buf_free_skb(skb);\r\nskb = brcmu_pktq_pdeq_match(txq, prec, fn, &ifidx);\r\n}\r\n}\r\n}\r\nstatic void brcmf_fws_cleanup(struct brcmf_fws_info *fws, int ifidx)\r\n{\r\nint i;\r\nstruct brcmf_fws_mac_descriptor *table;\r\nbool (*matchfn)(struct sk_buff *, void *) = NULL;\r\nif (fws == NULL)\r\nreturn;\r\nif (ifidx != -1)\r\nmatchfn = brcmf_fws_ifidx_match;\r\ntable = &fws->desc.nodes[0];\r\nfor (i = 0; i < ARRAY_SIZE(fws->desc.nodes); i++)\r\nbrcmf_fws_macdesc_cleanup(fws, &table[i], ifidx);\r\nbrcmf_fws_macdesc_cleanup(fws, &fws->desc.other, ifidx);\r\nbrcmf_fws_bus_txq_cleanup(fws, matchfn, ifidx);\r\nbrcmf_fws_hanger_cleanup(fws, matchfn, ifidx);\r\n}\r\nstatic u8 brcmf_fws_hdrpush(struct brcmf_fws_info *fws, struct sk_buff *skb)\r\n{\r\nstruct brcmf_fws_mac_descriptor *entry = brcmf_skbcb(skb)->mac;\r\nu8 *wlh;\r\nu16 data_offset = 0;\r\nu8 fillers;\r\n__le32 pkttag = cpu_to_le32(brcmf_skbcb(skb)->htod);\r\n__le16 pktseq = cpu_to_le16(brcmf_skbcb(skb)->htod_seq);\r\nbrcmf_dbg(TRACE, "enter: %s, idx=%d hslot=%d htod %X seq %X\n",\r\nentry->name, brcmf_skb_if_flags_get_field(skb, INDEX),\r\n(le32_to_cpu(pkttag) >> 8) & 0xffff,\r\nbrcmf_skbcb(skb)->htod, brcmf_skbcb(skb)->htod_seq);\r\nif (entry->send_tim_signal)\r\ndata_offset += 2 + BRCMF_FWS_TYPE_PENDING_TRAFFIC_BMP_LEN;\r\nif (BRCMF_FWS_MODE_GET_REUSESEQ(fws->mode))\r\ndata_offset += BRCMF_FWS_TYPE_SEQ_LEN;\r\ndata_offset += 2 + BRCMF_FWS_TYPE_PKTTAG_LEN;\r\nfillers = round_up(data_offset, 4) - data_offset;\r\ndata_offset += fillers;\r\nskb_push(skb, data_offset);\r\nwlh = skb->data;\r\nwlh[0] = BRCMF_FWS_TYPE_PKTTAG;\r\nwlh[1] = BRCMF_FWS_TYPE_PKTTAG_LEN;\r\nmemcpy(&wlh[2], &pkttag, sizeof(pkttag));\r\nif (BRCMF_FWS_MODE_GET_REUSESEQ(fws->mode)) {\r\nwlh[1] += BRCMF_FWS_TYPE_SEQ_LEN;\r\nmemcpy(&wlh[2 + BRCMF_FWS_TYPE_PKTTAG_LEN], &pktseq,\r\nsizeof(pktseq));\r\n}\r\nwlh += wlh[1] + 2;\r\nif (entry->send_tim_signal) {\r\nentry->send_tim_signal = 0;\r\nwlh[0] = BRCMF_FWS_TYPE_PENDING_TRAFFIC_BMP;\r\nwlh[1] = BRCMF_FWS_TYPE_PENDING_TRAFFIC_BMP_LEN;\r\nwlh[2] = entry->mac_handle;\r\nwlh[3] = entry->traffic_pending_bmp;\r\nbrcmf_dbg(TRACE, "adding TIM info: handle %d bmp 0x%X\n",\r\nentry->mac_handle, entry->traffic_pending_bmp);\r\nwlh += BRCMF_FWS_TYPE_PENDING_TRAFFIC_BMP_LEN + 2;\r\nentry->traffic_lastreported_bmp = entry->traffic_pending_bmp;\r\n}\r\nif (fillers)\r\nmemset(wlh, BRCMF_FWS_TYPE_FILLER, fillers);\r\nreturn (u8)(data_offset >> 2);\r\n}\r\nstatic bool brcmf_fws_tim_update(struct brcmf_fws_info *fws,\r\nstruct brcmf_fws_mac_descriptor *entry,\r\nint fifo, bool send_immediately)\r\n{\r\nstruct sk_buff *skb;\r\nstruct brcmf_skbuff_cb *skcb;\r\ns32 err;\r\nu32 len;\r\nu8 data_offset;\r\nint ifidx;\r\nif (brcmu_pktq_mlen(&entry->psq, 3 << (fifo * 2)) == 0)\r\nentry->traffic_pending_bmp &= ~NBITVAL(fifo);\r\nelse\r\nentry->traffic_pending_bmp |= NBITVAL(fifo);\r\nentry->send_tim_signal = false;\r\nif (entry->traffic_lastreported_bmp != entry->traffic_pending_bmp)\r\nentry->send_tim_signal = true;\r\nif (send_immediately && entry->send_tim_signal &&\r\nentry->state == BRCMF_FWS_STATE_CLOSE) {\r\nlen = BRCMF_FWS_TYPE_PKTTAG_LEN + 2 +\r\nBRCMF_FWS_TYPE_SEQ_LEN +\r\nBRCMF_FWS_TYPE_PENDING_TRAFFIC_BMP_LEN + 2 +\r\n4 + fws->drvr->hdrlen;\r\nskb = brcmu_pkt_buf_get_skb(len);\r\nif (skb == NULL)\r\nreturn false;\r\nskb_pull(skb, len);\r\nskcb = brcmf_skbcb(skb);\r\nskcb->mac = entry;\r\nskcb->state = BRCMF_FWS_SKBSTATE_TIM;\r\nskcb->htod = 0;\r\nskcb->htod_seq = 0;\r\ndata_offset = brcmf_fws_hdrpush(fws, skb);\r\nifidx = brcmf_skb_if_flags_get_field(skb, INDEX);\r\nbrcmf_fws_unlock(fws);\r\nerr = brcmf_proto_txdata(fws->drvr, ifidx, data_offset, skb);\r\nbrcmf_fws_lock(fws);\r\nif (err)\r\nbrcmu_pkt_buf_free_skb(skb);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void\r\nbrcmf_fws_flow_control_check(struct brcmf_fws_info *fws, struct pktq *pq,\r\nu8 if_id)\r\n{\r\nstruct brcmf_if *ifp = fws->drvr->iflist[!if_id ? 0 : if_id + 1];\r\nif (WARN_ON(!ifp))\r\nreturn;\r\nif ((ifp->netif_stop & BRCMF_NETIF_STOP_REASON_FWS_FC) &&\r\npq->len <= BRCMF_FWS_FLOWCONTROL_LOWATER)\r\nbrcmf_txflowblock_if(ifp,\r\nBRCMF_NETIF_STOP_REASON_FWS_FC, false);\r\nif (!(ifp->netif_stop & BRCMF_NETIF_STOP_REASON_FWS_FC) &&\r\npq->len >= BRCMF_FWS_FLOWCONTROL_HIWATER) {\r\nfws->stats.fws_flow_block++;\r\nbrcmf_txflowblock_if(ifp, BRCMF_NETIF_STOP_REASON_FWS_FC, true);\r\n}\r\nreturn;\r\n}\r\nstatic int brcmf_fws_rssi_indicate(struct brcmf_fws_info *fws, s8 rssi)\r\n{\r\nbrcmf_dbg(CTL, "rssi %d\n", rssi);\r\nreturn 0;\r\n}\r\nstatic\r\nint brcmf_fws_macdesc_indicate(struct brcmf_fws_info *fws, u8 type, u8 *data)\r\n{\r\nstruct brcmf_fws_mac_descriptor *entry, *existing;\r\nu8 mac_handle;\r\nu8 ifidx;\r\nu8 *addr;\r\nmac_handle = *data++;\r\nifidx = *data++;\r\naddr = data;\r\nentry = &fws->desc.nodes[mac_handle & 0x1F];\r\nif (type == BRCMF_FWS_TYPE_MACDESC_DEL) {\r\nif (entry->occupied) {\r\nbrcmf_dbg(TRACE, "deleting %s mac %pM\n",\r\nentry->name, addr);\r\nbrcmf_fws_lock(fws);\r\nbrcmf_fws_macdesc_cleanup(fws, entry, -1);\r\nbrcmf_fws_macdesc_deinit(entry);\r\nbrcmf_fws_unlock(fws);\r\n} else\r\nfws->stats.mac_update_failed++;\r\nreturn 0;\r\n}\r\nexisting = brcmf_fws_macdesc_lookup(fws, addr);\r\nif (IS_ERR(existing)) {\r\nif (!entry->occupied) {\r\nbrcmf_fws_lock(fws);\r\nentry->mac_handle = mac_handle;\r\nbrcmf_fws_macdesc_init(entry, addr, ifidx);\r\nbrcmf_fws_macdesc_set_name(fws, entry);\r\nbrcmu_pktq_init(&entry->psq, BRCMF_FWS_PSQ_PREC_COUNT,\r\nBRCMF_FWS_PSQ_LEN);\r\nbrcmf_fws_unlock(fws);\r\nbrcmf_dbg(TRACE, "add %s mac %pM\n", entry->name, addr);\r\n} else {\r\nfws->stats.mac_update_failed++;\r\n}\r\n} else {\r\nif (entry != existing) {\r\nbrcmf_dbg(TRACE, "copy mac %s\n", existing->name);\r\nbrcmf_fws_lock(fws);\r\nmemcpy(entry, existing,\r\noffsetof(struct brcmf_fws_mac_descriptor, psq));\r\nentry->mac_handle = mac_handle;\r\nbrcmf_fws_macdesc_deinit(existing);\r\nbrcmf_fws_macdesc_set_name(fws, entry);\r\nbrcmf_fws_unlock(fws);\r\nbrcmf_dbg(TRACE, "relocate %s mac %pM\n", entry->name,\r\naddr);\r\n} else {\r\nbrcmf_dbg(TRACE, "use existing\n");\r\nWARN_ON(entry->mac_handle != mac_handle);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int brcmf_fws_macdesc_state_indicate(struct brcmf_fws_info *fws,\r\nu8 type, u8 *data)\r\n{\r\nstruct brcmf_fws_mac_descriptor *entry;\r\nu8 mac_handle;\r\nint ret;\r\nmac_handle = data[0];\r\nentry = &fws->desc.nodes[mac_handle & 0x1F];\r\nif (!entry->occupied) {\r\nfws->stats.mac_ps_update_failed++;\r\nreturn -ESRCH;\r\n}\r\nbrcmf_fws_lock(fws);\r\nentry->requested_credit = 0;\r\nentry->requested_packet = 0;\r\nif (type == BRCMF_FWS_TYPE_MAC_OPEN) {\r\nentry->state = BRCMF_FWS_STATE_OPEN;\r\nret = BRCMF_FWS_RET_OK_SCHEDULE;\r\n} else {\r\nentry->state = BRCMF_FWS_STATE_CLOSE;\r\nbrcmf_fws_tim_update(fws, entry, BRCMF_FWS_FIFO_AC_BK, false);\r\nbrcmf_fws_tim_update(fws, entry, BRCMF_FWS_FIFO_AC_BE, false);\r\nbrcmf_fws_tim_update(fws, entry, BRCMF_FWS_FIFO_AC_VI, false);\r\nbrcmf_fws_tim_update(fws, entry, BRCMF_FWS_FIFO_AC_VO, true);\r\nret = BRCMF_FWS_RET_OK_NOSCHEDULE;\r\n}\r\nbrcmf_fws_unlock(fws);\r\nreturn ret;\r\n}\r\nstatic int brcmf_fws_interface_state_indicate(struct brcmf_fws_info *fws,\r\nu8 type, u8 *data)\r\n{\r\nstruct brcmf_fws_mac_descriptor *entry;\r\nu8 ifidx;\r\nint ret;\r\nifidx = data[0];\r\nif (ifidx >= BRCMF_MAX_IFS) {\r\nret = -ERANGE;\r\ngoto fail;\r\n}\r\nentry = &fws->desc.iface[ifidx];\r\nif (!entry->occupied) {\r\nret = -ESRCH;\r\ngoto fail;\r\n}\r\nbrcmf_dbg(TRACE, "%s (%d): %s\n", brcmf_fws_get_tlv_name(type), type,\r\nentry->name);\r\nbrcmf_fws_lock(fws);\r\nswitch (type) {\r\ncase BRCMF_FWS_TYPE_INTERFACE_OPEN:\r\nentry->state = BRCMF_FWS_STATE_OPEN;\r\nret = BRCMF_FWS_RET_OK_SCHEDULE;\r\nbreak;\r\ncase BRCMF_FWS_TYPE_INTERFACE_CLOSE:\r\nentry->state = BRCMF_FWS_STATE_CLOSE;\r\nret = BRCMF_FWS_RET_OK_NOSCHEDULE;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbrcmf_fws_unlock(fws);\r\ngoto fail;\r\n}\r\nbrcmf_fws_unlock(fws);\r\nreturn ret;\r\nfail:\r\nfws->stats.if_update_failed++;\r\nreturn ret;\r\n}\r\nstatic int brcmf_fws_request_indicate(struct brcmf_fws_info *fws, u8 type,\r\nu8 *data)\r\n{\r\nstruct brcmf_fws_mac_descriptor *entry;\r\nentry = &fws->desc.nodes[data[1] & 0x1F];\r\nif (!entry->occupied) {\r\nif (type == BRCMF_FWS_TYPE_MAC_REQUEST_CREDIT)\r\nfws->stats.credit_request_failed++;\r\nelse\r\nfws->stats.packet_request_failed++;\r\nreturn -ESRCH;\r\n}\r\nbrcmf_dbg(TRACE, "%s (%d): %s cnt %d bmp %d\n",\r\nbrcmf_fws_get_tlv_name(type), type, entry->name,\r\ndata[0], data[2]);\r\nbrcmf_fws_lock(fws);\r\nif (type == BRCMF_FWS_TYPE_MAC_REQUEST_CREDIT)\r\nentry->requested_credit = data[0];\r\nelse\r\nentry->requested_packet = data[0];\r\nentry->ac_bitmap = data[2];\r\nbrcmf_fws_unlock(fws);\r\nreturn BRCMF_FWS_RET_OK_SCHEDULE;\r\n}\r\nstatic void\r\nbrcmf_fws_macdesc_use_req_credit(struct brcmf_fws_mac_descriptor *entry,\r\nstruct sk_buff *skb)\r\n{\r\nif (entry->requested_credit > 0) {\r\nentry->requested_credit--;\r\nbrcmf_skb_if_flags_set_field(skb, REQUESTED, 1);\r\nbrcmf_skb_if_flags_set_field(skb, REQ_CREDIT, 1);\r\nif (entry->state != BRCMF_FWS_STATE_CLOSE)\r\nbrcmf_err("requested credit set while mac not closed!\n");\r\n} else if (entry->requested_packet > 0) {\r\nentry->requested_packet--;\r\nbrcmf_skb_if_flags_set_field(skb, REQUESTED, 1);\r\nbrcmf_skb_if_flags_set_field(skb, REQ_CREDIT, 0);\r\nif (entry->state != BRCMF_FWS_STATE_CLOSE)\r\nbrcmf_err("requested packet set while mac not closed!\n");\r\n} else {\r\nbrcmf_skb_if_flags_set_field(skb, REQUESTED, 0);\r\nbrcmf_skb_if_flags_set_field(skb, REQ_CREDIT, 0);\r\n}\r\n}\r\nstatic void brcmf_fws_macdesc_return_req_credit(struct sk_buff *skb)\r\n{\r\nstruct brcmf_fws_mac_descriptor *entry = brcmf_skbcb(skb)->mac;\r\nif ((brcmf_skb_if_flags_get_field(skb, REQ_CREDIT)) &&\r\n(entry->state == BRCMF_FWS_STATE_CLOSE))\r\nentry->requested_credit++;\r\n}\r\nstatic void brcmf_fws_return_credits(struct brcmf_fws_info *fws,\r\nu8 fifo, u8 credits)\r\n{\r\nint lender_ac;\r\nint *borrowed;\r\nint *fifo_credit;\r\nif (!credits)\r\nreturn;\r\nfws->fifo_credit_map |= 1 << fifo;\r\nif ((fifo == BRCMF_FWS_FIFO_AC_BE) &&\r\n(fws->credits_borrowed[0])) {\r\nfor (lender_ac = BRCMF_FWS_FIFO_AC_VO; lender_ac >= 0;\r\nlender_ac--) {\r\nborrowed = &fws->credits_borrowed[lender_ac];\r\nif (*borrowed) {\r\nfws->fifo_credit_map |= (1 << lender_ac);\r\nfifo_credit = &fws->fifo_credit[lender_ac];\r\nif (*borrowed >= credits) {\r\n*borrowed -= credits;\r\n*fifo_credit += credits;\r\nreturn;\r\n} else {\r\ncredits -= *borrowed;\r\n*fifo_credit += *borrowed;\r\n*borrowed = 0;\r\n}\r\n}\r\n}\r\n}\r\nfws->fifo_credit[fifo] += credits;\r\n}\r\nstatic void brcmf_fws_schedule_deq(struct brcmf_fws_info *fws)\r\n{\r\nif ((fws->fifo_credit_map & fws->fifo_delay_map) ||\r\n(!brcmf_fws_fc_active(fws) && fws->fifo_delay_map))\r\nqueue_work(fws->fws_wq, &fws->fws_dequeue_work);\r\n}\r\nstatic int brcmf_fws_enq(struct brcmf_fws_info *fws,\r\nenum brcmf_fws_skb_state state, int fifo,\r\nstruct sk_buff *p)\r\n{\r\nint prec = 2 * fifo;\r\nu32 *qfull_stat = &fws->stats.delayq_full_error;\r\nstruct brcmf_fws_mac_descriptor *entry;\r\nstruct pktq *pq;\r\nstruct sk_buff_head *queue;\r\nstruct sk_buff *p_head;\r\nstruct sk_buff *p_tail;\r\nu32 fr_new;\r\nu32 fr_compare;\r\nentry = brcmf_skbcb(p)->mac;\r\nif (entry == NULL) {\r\nbrcmf_err("no mac descriptor found for skb %p\n", p);\r\nreturn -ENOENT;\r\n}\r\nbrcmf_dbg(DATA, "enter: fifo %d skb %p\n", fifo, p);\r\nif (state == BRCMF_FWS_SKBSTATE_SUPPRESSED) {\r\nprec += 1;\r\nqfull_stat = &fws->stats.supprq_full_error;\r\npq = &entry->psq;\r\nif (pktq_full(pq) || pktq_pfull(pq, prec)) {\r\n*qfull_stat += 1;\r\nreturn -ENFILE;\r\n}\r\nqueue = &pq->q[prec].skblist;\r\np_head = skb_peek(queue);\r\np_tail = skb_peek_tail(queue);\r\nfr_new = brcmf_skb_htod_tag_get_field(p, FREERUN);\r\nwhile (p_head != p_tail) {\r\nfr_compare = brcmf_skb_htod_tag_get_field(p_tail,\r\nFREERUN);\r\nif (((fr_new > fr_compare) &&\r\n((fr_new - fr_compare) < 128)) ||\r\n((fr_new < fr_compare) &&\r\n((fr_compare - fr_new) > 128)))\r\nbreak;\r\np_tail = skb_queue_prev(queue, p_tail);\r\n}\r\nif (p_tail == NULL) {\r\n__skb_queue_tail(queue, p);\r\n} else {\r\nfr_compare = brcmf_skb_htod_tag_get_field(p_tail,\r\nFREERUN);\r\nif (((fr_new > fr_compare) &&\r\n((fr_new - fr_compare) < 128)) ||\r\n((fr_new < fr_compare) &&\r\n((fr_compare - fr_new) > 128))) {\r\n__skb_queue_after(queue, p_tail, p);\r\n} else {\r\n__skb_insert(p, p_tail->prev, p_tail, queue);\r\n}\r\n}\r\npq->len++;\r\nif (pq->hi_prec < prec)\r\npq->hi_prec = (u8) prec;\r\n} else if (brcmu_pktq_penq(&entry->psq, prec, p) == NULL) {\r\n*qfull_stat += 1;\r\nreturn -ENFILE;\r\n}\r\nfws->fifo_delay_map |= 1 << fifo;\r\nfws->fifo_enqpkt[fifo]++;\r\nbrcmf_skbcb(p)->state = state;\r\nbrcmf_fws_tim_update(fws, entry, fifo, true);\r\nbrcmf_fws_flow_control_check(fws, &entry->psq,\r\nbrcmf_skb_if_flags_get_field(p, INDEX));\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *brcmf_fws_deq(struct brcmf_fws_info *fws, int fifo)\r\n{\r\nstruct brcmf_fws_mac_descriptor *table;\r\nstruct brcmf_fws_mac_descriptor *entry;\r\nstruct sk_buff *p;\r\nint num_nodes;\r\nint node_pos;\r\nint prec_out;\r\nint pmsk;\r\nint i;\r\ntable = (struct brcmf_fws_mac_descriptor *)&fws->desc;\r\nnum_nodes = sizeof(fws->desc) / sizeof(struct brcmf_fws_mac_descriptor);\r\nnode_pos = fws->deq_node_pos[fifo];\r\nfor (i = 0; i < num_nodes; i++) {\r\nentry = &table[(node_pos + i) % num_nodes];\r\nif (!entry->occupied ||\r\nbrcmf_fws_macdesc_closed(fws, entry, fifo))\r\ncontinue;\r\nif (entry->suppressed)\r\npmsk = 2;\r\nelse\r\npmsk = 3;\r\np = brcmu_pktq_mdeq(&entry->psq, pmsk << (fifo * 2), &prec_out);\r\nif (p == NULL) {\r\nif (entry->suppressed) {\r\nif (entry->suppr_transit_count)\r\ncontinue;\r\nentry->suppressed = false;\r\np = brcmu_pktq_mdeq(&entry->psq,\r\n1 << (fifo * 2), &prec_out);\r\n}\r\n}\r\nif (p == NULL)\r\ncontinue;\r\nbrcmf_fws_macdesc_use_req_credit(entry, p);\r\nfws->deq_node_pos[fifo] = (node_pos + i + 1) % num_nodes;\r\nbrcmf_fws_flow_control_check(fws, &entry->psq,\r\nbrcmf_skb_if_flags_get_field(p,\r\nINDEX)\r\n);\r\nbrcmf_fws_tim_update(fws, entry, fifo, false);\r\nfws->fifo_enqpkt[fifo]--;\r\nif (fws->fifo_enqpkt[fifo] == 0)\r\nfws->fifo_delay_map &= ~(1 << fifo);\r\ngoto done;\r\n}\r\np = NULL;\r\ndone:\r\nbrcmf_dbg(DATA, "exit: fifo %d skb %p\n", fifo, p);\r\nreturn p;\r\n}\r\nstatic int brcmf_fws_txstatus_suppressed(struct brcmf_fws_info *fws, int fifo,\r\nstruct sk_buff *skb, u8 ifidx,\r\nu32 genbit, u16 seq)\r\n{\r\nstruct brcmf_fws_mac_descriptor *entry = brcmf_skbcb(skb)->mac;\r\nu32 hslot;\r\nint ret;\r\nhslot = brcmf_skb_htod_tag_get_field(skb, HSLOT);\r\nif (!entry->suppressed) {\r\nentry->suppressed = true;\r\nentry->suppr_transit_count = entry->transit_count;\r\nbrcmf_dbg(DATA, "suppress %s: transit %d\n",\r\nentry->name, entry->transit_count);\r\n}\r\nentry->generation = genbit;\r\nbrcmf_skb_htod_tag_set_field(skb, GENERATION, genbit);\r\nbrcmf_skbcb(skb)->htod_seq = seq;\r\nif (brcmf_skb_htod_seq_get_field(skb, FROMFW)) {\r\nbrcmf_skb_htod_seq_set_field(skb, FROMDRV, 1);\r\nbrcmf_skb_htod_seq_set_field(skb, FROMFW, 0);\r\n} else {\r\nbrcmf_skb_htod_seq_set_field(skb, FROMDRV, 0);\r\n}\r\nret = brcmf_fws_enq(fws, BRCMF_FWS_SKBSTATE_SUPPRESSED, fifo, skb);\r\nif (ret != 0) {\r\nbrcmf_fws_hanger_poppkt(&fws->hanger, hslot, &skb, true);\r\n} else {\r\nbrcmf_fws_hanger_mark_suppressed(&fws->hanger, hslot);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nbrcmf_fws_txs_process(struct brcmf_fws_info *fws, u8 flags, u32 hslot,\r\nu32 genbit, u16 seq)\r\n{\r\nu32 fifo;\r\nint ret;\r\nbool remove_from_hanger = true;\r\nstruct sk_buff *skb;\r\nstruct brcmf_skbuff_cb *skcb;\r\nstruct brcmf_fws_mac_descriptor *entry = NULL;\r\nu8 ifidx;\r\nbrcmf_dbg(DATA, "flags %d\n", flags);\r\nif (flags == BRCMF_FWS_TXSTATUS_DISCARD)\r\nfws->stats.txs_discard++;\r\nelse if (flags == BRCMF_FWS_TXSTATUS_CORE_SUPPRESS) {\r\nfws->stats.txs_supp_core++;\r\nremove_from_hanger = false;\r\n} else if (flags == BRCMF_FWS_TXSTATUS_FW_PS_SUPPRESS) {\r\nfws->stats.txs_supp_ps++;\r\nremove_from_hanger = false;\r\n} else if (flags == BRCMF_FWS_TXSTATUS_FW_TOSSED)\r\nfws->stats.txs_tossed++;\r\nelse if (flags == BRCMF_FWS_TXSTATUS_HOST_TOSSED)\r\nfws->stats.txs_host_tossed++;\r\nelse\r\nbrcmf_err("unexpected txstatus\n");\r\nret = brcmf_fws_hanger_poppkt(&fws->hanger, hslot, &skb,\r\nremove_from_hanger);\r\nif (ret != 0) {\r\nbrcmf_err("no packet in hanger slot: hslot=%d\n", hslot);\r\nreturn ret;\r\n}\r\nskcb = brcmf_skbcb(skb);\r\nentry = skcb->mac;\r\nif (WARN_ON(!entry)) {\r\nbrcmu_pkt_buf_free_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nentry->transit_count--;\r\nif (entry->suppressed && entry->suppr_transit_count)\r\nentry->suppr_transit_count--;\r\nbrcmf_dbg(DATA, "%s flags %d htod %X seq %X\n", entry->name, flags,\r\nskcb->htod, seq);\r\nfifo = brcmf_skb_htod_tag_get_field(skb, FIFO);\r\nif ((fws->fcmode == BRCMF_FWS_FCMODE_IMPLIED_CREDIT) ||\r\n(brcmf_skb_if_flags_get_field(skb, REQ_CREDIT)) ||\r\n(flags == BRCMF_FWS_TXSTATUS_HOST_TOSSED)) {\r\nbrcmf_fws_return_credits(fws, fifo, 1);\r\nbrcmf_fws_schedule_deq(fws);\r\n}\r\nbrcmf_fws_macdesc_return_req_credit(skb);\r\nif (brcmf_proto_hdrpull(fws->drvr, false, &ifidx, skb)) {\r\nbrcmu_pkt_buf_free_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nif (!remove_from_hanger)\r\nret = brcmf_fws_txstatus_suppressed(fws, fifo, skb, ifidx,\r\ngenbit, seq);\r\nif (remove_from_hanger || ret)\r\nbrcmf_txfinalize(fws->drvr, skb, ifidx, true);\r\nreturn 0;\r\n}\r\nstatic int brcmf_fws_fifocreditback_indicate(struct brcmf_fws_info *fws,\r\nu8 *data)\r\n{\r\nint i;\r\nif (fws->fcmode != BRCMF_FWS_FCMODE_EXPLICIT_CREDIT) {\r\nbrcmf_dbg(INFO, "ignored\n");\r\nreturn BRCMF_FWS_RET_OK_NOSCHEDULE;\r\n}\r\nbrcmf_dbg(DATA, "enter: data %pM\n", data);\r\nbrcmf_fws_lock(fws);\r\nfor (i = 0; i < BRCMF_FWS_FIFO_COUNT; i++)\r\nbrcmf_fws_return_credits(fws, i, data[i]);\r\nbrcmf_dbg(DATA, "map: credit %x delay %x\n", fws->fifo_credit_map,\r\nfws->fifo_delay_map);\r\nbrcmf_fws_unlock(fws);\r\nreturn BRCMF_FWS_RET_OK_SCHEDULE;\r\n}\r\nstatic int brcmf_fws_txstatus_indicate(struct brcmf_fws_info *fws, u8 *data)\r\n{\r\n__le32 status_le;\r\n__le16 seq_le;\r\nu32 status;\r\nu32 hslot;\r\nu32 genbit;\r\nu8 flags;\r\nu16 seq;\r\nfws->stats.txs_indicate++;\r\nmemcpy(&status_le, data, sizeof(status_le));\r\nstatus = le32_to_cpu(status_le);\r\nflags = brcmf_txstatus_get_field(status, FLAGS);\r\nhslot = brcmf_txstatus_get_field(status, HSLOT);\r\ngenbit = brcmf_txstatus_get_field(status, GENERATION);\r\nif (BRCMF_FWS_MODE_GET_REUSESEQ(fws->mode)) {\r\nmemcpy(&seq_le, &data[BRCMF_FWS_TYPE_PKTTAG_LEN],\r\nsizeof(seq_le));\r\nseq = le16_to_cpu(seq_le);\r\n} else {\r\nseq = 0;\r\n}\r\nbrcmf_fws_lock(fws);\r\nbrcmf_fws_txs_process(fws, flags, hslot, genbit, seq);\r\nbrcmf_fws_unlock(fws);\r\nreturn BRCMF_FWS_RET_OK_NOSCHEDULE;\r\n}\r\nstatic int brcmf_fws_dbg_seqnum_check(struct brcmf_fws_info *fws, u8 *data)\r\n{\r\n__le32 timestamp;\r\nmemcpy(&timestamp, &data[2], sizeof(timestamp));\r\nbrcmf_dbg(CTL, "received: seq %d, timestamp %d\n", data[1],\r\nle32_to_cpu(timestamp));\r\nreturn 0;\r\n}\r\nstatic int brcmf_fws_notify_credit_map(struct brcmf_if *ifp,\r\nconst struct brcmf_event_msg *e,\r\nvoid *data)\r\n{\r\nstruct brcmf_fws_info *fws = ifp->drvr->fws;\r\nint i;\r\nu8 *credits = data;\r\nif (e->datalen < BRCMF_FWS_FIFO_COUNT) {\r\nbrcmf_err("event payload too small (%d)\n", e->datalen);\r\nreturn -EINVAL;\r\n}\r\nif (fws->creditmap_received)\r\nreturn 0;\r\nfws->creditmap_received = true;\r\nbrcmf_dbg(TRACE, "enter: credits %pM\n", credits);\r\nbrcmf_fws_lock(fws);\r\nfor (i = 0; i < ARRAY_SIZE(fws->fifo_credit); i++) {\r\nif (*credits)\r\nfws->fifo_credit_map |= 1 << i;\r\nelse\r\nfws->fifo_credit_map &= ~(1 << i);\r\nfws->fifo_credit[i] = *credits++;\r\n}\r\nbrcmf_fws_schedule_deq(fws);\r\nbrcmf_fws_unlock(fws);\r\nreturn 0;\r\n}\r\nstatic int brcmf_fws_notify_bcmc_credit_support(struct brcmf_if *ifp,\r\nconst struct brcmf_event_msg *e,\r\nvoid *data)\r\n{\r\nstruct brcmf_fws_info *fws = ifp->drvr->fws;\r\nbrcmf_fws_lock(fws);\r\nif (fws)\r\nfws->bcmc_credit_check = true;\r\nbrcmf_fws_unlock(fws);\r\nreturn 0;\r\n}\r\nint brcmf_fws_hdrpull(struct brcmf_pub *drvr, int ifidx, s16 signal_len,\r\nstruct sk_buff *skb)\r\n{\r\nstruct brcmf_skb_reorder_data *rd;\r\nstruct brcmf_fws_info *fws = drvr->fws;\r\nu8 *signal_data;\r\ns16 data_len;\r\nu8 type;\r\nu8 len;\r\nu8 *data;\r\ns32 status;\r\ns32 err;\r\nbrcmf_dbg(HDRS, "enter: ifidx %d, skblen %u, sig %d\n",\r\nifidx, skb->len, signal_len);\r\nWARN_ON(signal_len > skb->len);\r\nif (!signal_len)\r\nreturn 0;\r\nif ((!fws) || (!fws->fw_signals)) {\r\nskb_pull(skb, signal_len);\r\nreturn 0;\r\n}\r\nfws->stats.header_pulls++;\r\ndata_len = signal_len;\r\nsignal_data = skb->data;\r\nstatus = BRCMF_FWS_RET_OK_NOSCHEDULE;\r\nwhile (data_len > 0) {\r\ntype = signal_data[0];\r\nif (type == BRCMF_FWS_TYPE_FILLER) {\r\nsignal_data += 1;\r\ndata_len -= 1;\r\ncontinue;\r\n}\r\nlen = signal_data[1];\r\ndata = signal_data + 2;\r\nbrcmf_dbg(HDRS, "tlv type=%s (%d), len=%d (%d)\n",\r\nbrcmf_fws_get_tlv_name(type), type, len,\r\nbrcmf_fws_get_tlv_len(fws, type));\r\nif (data_len < len + 2)\r\nbreak;\r\nif (len < brcmf_fws_get_tlv_len(fws, type))\r\nbreak;\r\nerr = BRCMF_FWS_RET_OK_NOSCHEDULE;\r\nswitch (type) {\r\ncase BRCMF_FWS_TYPE_COMP_TXSTATUS:\r\nbreak;\r\ncase BRCMF_FWS_TYPE_HOST_REORDER_RXPKTS:\r\nrd = (struct brcmf_skb_reorder_data *)skb->cb;\r\nrd->reorder = data;\r\nbreak;\r\ncase BRCMF_FWS_TYPE_MACDESC_ADD:\r\ncase BRCMF_FWS_TYPE_MACDESC_DEL:\r\nbrcmf_fws_macdesc_indicate(fws, type, data);\r\nbreak;\r\ncase BRCMF_FWS_TYPE_MAC_OPEN:\r\ncase BRCMF_FWS_TYPE_MAC_CLOSE:\r\nerr = brcmf_fws_macdesc_state_indicate(fws, type, data);\r\nbreak;\r\ncase BRCMF_FWS_TYPE_INTERFACE_OPEN:\r\ncase BRCMF_FWS_TYPE_INTERFACE_CLOSE:\r\nerr = brcmf_fws_interface_state_indicate(fws, type,\r\ndata);\r\nbreak;\r\ncase BRCMF_FWS_TYPE_MAC_REQUEST_CREDIT:\r\ncase BRCMF_FWS_TYPE_MAC_REQUEST_PACKET:\r\nerr = brcmf_fws_request_indicate(fws, type, data);\r\nbreak;\r\ncase BRCMF_FWS_TYPE_TXSTATUS:\r\nbrcmf_fws_txstatus_indicate(fws, data);\r\nbreak;\r\ncase BRCMF_FWS_TYPE_FIFO_CREDITBACK:\r\nerr = brcmf_fws_fifocreditback_indicate(fws, data);\r\nbreak;\r\ncase BRCMF_FWS_TYPE_RSSI:\r\nbrcmf_fws_rssi_indicate(fws, *data);\r\nbreak;\r\ncase BRCMF_FWS_TYPE_TRANS_ID:\r\nbrcmf_fws_dbg_seqnum_check(fws, data);\r\nbreak;\r\ncase BRCMF_FWS_TYPE_PKTTAG:\r\ncase BRCMF_FWS_TYPE_PENDING_TRAFFIC_BMP:\r\ndefault:\r\nfws->stats.tlv_invalid_type++;\r\nbreak;\r\n}\r\nif (err == BRCMF_FWS_RET_OK_SCHEDULE)\r\nstatus = BRCMF_FWS_RET_OK_SCHEDULE;\r\nsignal_data += len + 2;\r\ndata_len -= len + 2;\r\n}\r\nif (data_len != 0)\r\nfws->stats.tlv_parse_failed++;\r\nif (status == BRCMF_FWS_RET_OK_SCHEDULE)\r\nbrcmf_fws_schedule_deq(fws);\r\nskb_pull(skb, signal_len);\r\nif (skb->len == 0)\r\nfws->stats.header_only_pkt++;\r\nreturn 0;\r\n}\r\nstatic u8 brcmf_fws_precommit_skb(struct brcmf_fws_info *fws, int fifo,\r\nstruct sk_buff *p)\r\n{\r\nstruct brcmf_skbuff_cb *skcb = brcmf_skbcb(p);\r\nstruct brcmf_fws_mac_descriptor *entry = skcb->mac;\r\nu8 flags;\r\nif (skcb->state != BRCMF_FWS_SKBSTATE_SUPPRESSED)\r\nbrcmf_skb_htod_tag_set_field(p, GENERATION, entry->generation);\r\nflags = BRCMF_FWS_HTOD_FLAG_PKTFROMHOST;\r\nif (brcmf_skb_if_flags_get_field(p, REQUESTED)) {\r\nflags |= BRCMF_FWS_HTOD_FLAG_PKT_REQUESTED;\r\n}\r\nbrcmf_skb_htod_tag_set_field(p, FLAGS, flags);\r\nreturn brcmf_fws_hdrpush(fws, p);\r\n}\r\nstatic void brcmf_fws_rollback_toq(struct brcmf_fws_info *fws,\r\nstruct sk_buff *skb, int fifo)\r\n{\r\nstruct brcmf_fws_mac_descriptor *entry;\r\nstruct sk_buff *pktout;\r\nint qidx, hslot;\r\nint rc = 0;\r\nentry = brcmf_skbcb(skb)->mac;\r\nif (entry->occupied) {\r\nqidx = 2 * fifo;\r\nif (brcmf_skbcb(skb)->state == BRCMF_FWS_SKBSTATE_SUPPRESSED)\r\nqidx++;\r\npktout = brcmu_pktq_penq_head(&entry->psq, qidx, skb);\r\nif (pktout == NULL) {\r\nbrcmf_err("%s queue %d full\n", entry->name, qidx);\r\nrc = -ENOSPC;\r\n}\r\n} else {\r\nbrcmf_err("%s entry removed\n", entry->name);\r\nrc = -ENOENT;\r\n}\r\nif (rc) {\r\nfws->stats.rollback_failed++;\r\nhslot = brcmf_skb_htod_tag_get_field(skb, HSLOT);\r\nbrcmf_fws_txs_process(fws, BRCMF_FWS_TXSTATUS_HOST_TOSSED,\r\nhslot, 0, 0);\r\n} else {\r\nfws->stats.rollback_success++;\r\nbrcmf_fws_return_credits(fws, fifo, 1);\r\nbrcmf_fws_macdesc_return_req_credit(skb);\r\n}\r\n}\r\nstatic int brcmf_fws_borrow_credit(struct brcmf_fws_info *fws)\r\n{\r\nint lender_ac;\r\nif (time_after(fws->borrow_defer_timestamp, jiffies)) {\r\nfws->fifo_credit_map &= ~(1 << BRCMF_FWS_FIFO_AC_BE);\r\nreturn -ENAVAIL;\r\n}\r\nfor (lender_ac = 0; lender_ac <= BRCMF_FWS_FIFO_AC_VO; lender_ac++) {\r\nif (fws->fifo_credit[lender_ac]) {\r\nfws->credits_borrowed[lender_ac]++;\r\nfws->fifo_credit[lender_ac]--;\r\nif (fws->fifo_credit[lender_ac] == 0)\r\nfws->fifo_credit_map &= ~(1 << lender_ac);\r\nfws->fifo_credit_map |= (1 << BRCMF_FWS_FIFO_AC_BE);\r\nbrcmf_dbg(DATA, "borrow credit from: %d\n", lender_ac);\r\nreturn 0;\r\n}\r\n}\r\nfws->fifo_credit_map &= ~(1 << BRCMF_FWS_FIFO_AC_BE);\r\nreturn -ENAVAIL;\r\n}\r\nstatic int brcmf_fws_commit_skb(struct brcmf_fws_info *fws, int fifo,\r\nstruct sk_buff *skb)\r\n{\r\nstruct brcmf_skbuff_cb *skcb = brcmf_skbcb(skb);\r\nstruct brcmf_fws_mac_descriptor *entry;\r\nint rc;\r\nu8 ifidx;\r\nu8 data_offset;\r\nentry = skcb->mac;\r\nif (IS_ERR(entry))\r\nreturn PTR_ERR(entry);\r\ndata_offset = brcmf_fws_precommit_skb(fws, fifo, skb);\r\nentry->transit_count++;\r\nif (entry->suppressed)\r\nentry->suppr_transit_count++;\r\nifidx = brcmf_skb_if_flags_get_field(skb, INDEX);\r\nbrcmf_fws_unlock(fws);\r\nrc = brcmf_proto_txdata(fws->drvr, ifidx, data_offset, skb);\r\nbrcmf_fws_lock(fws);\r\nbrcmf_dbg(DATA, "%s flags %X htod %X bus_tx %d\n", entry->name,\r\nskcb->if_flags, skcb->htod, rc);\r\nif (rc < 0) {\r\nentry->transit_count--;\r\nif (entry->suppressed)\r\nentry->suppr_transit_count--;\r\nbrcmf_proto_hdrpull(fws->drvr, false, &ifidx, skb);\r\ngoto rollback;\r\n}\r\nfws->stats.pkt2bus++;\r\nfws->stats.send_pkts[fifo]++;\r\nif (brcmf_skb_if_flags_get_field(skb, REQUESTED))\r\nfws->stats.requested_sent[fifo]++;\r\nreturn rc;\r\nrollback:\r\nbrcmf_fws_rollback_toq(fws, skb, fifo);\r\nreturn rc;\r\n}\r\nstatic int brcmf_fws_assign_htod(struct brcmf_fws_info *fws, struct sk_buff *p,\r\nint fifo)\r\n{\r\nstruct brcmf_skbuff_cb *skcb = brcmf_skbcb(p);\r\nint rc, hslot;\r\nskcb->htod = 0;\r\nskcb->htod_seq = 0;\r\nhslot = brcmf_fws_hanger_get_free_slot(&fws->hanger);\r\nbrcmf_skb_htod_tag_set_field(p, HSLOT, hslot);\r\nbrcmf_skb_htod_tag_set_field(p, FREERUN, skcb->mac->seq[fifo]);\r\nbrcmf_skb_htod_tag_set_field(p, FIFO, fifo);\r\nrc = brcmf_fws_hanger_pushpkt(&fws->hanger, p, hslot);\r\nif (!rc)\r\nskcb->mac->seq[fifo]++;\r\nelse\r\nfws->stats.generic_error++;\r\nreturn rc;\r\n}\r\nint brcmf_fws_process_skb(struct brcmf_if *ifp, struct sk_buff *skb)\r\n{\r\nstruct brcmf_pub *drvr = ifp->drvr;\r\nstruct brcmf_fws_info *fws = drvr->fws;\r\nstruct brcmf_skbuff_cb *skcb = brcmf_skbcb(skb);\r\nstruct ethhdr *eh = (struct ethhdr *)(skb->data);\r\nint fifo = BRCMF_FWS_FIFO_BCMC;\r\nbool multicast = is_multicast_ether_addr(eh->h_dest);\r\nint rc = 0;\r\nbrcmf_dbg(DATA, "tx proto=0x%X\n", ntohs(eh->h_proto));\r\nif (!skb->priority)\r\nskb->priority = cfg80211_classify8021d(skb, NULL);\r\ndrvr->tx_multicast += !!multicast;\r\nif (fws->avoid_queueing) {\r\nrc = brcmf_proto_txdata(drvr, ifp->ifidx, 0, skb);\r\nif (rc < 0)\r\nbrcmf_txfinalize(drvr, skb, ifp->ifidx, false);\r\nreturn rc;\r\n}\r\nskcb->if_flags = 0;\r\nskcb->state = BRCMF_FWS_SKBSTATE_NEW;\r\nbrcmf_skb_if_flags_set_field(skb, INDEX, ifp->ifidx);\r\nif (!multicast)\r\nfifo = brcmf_fws_prio2fifo[skb->priority];\r\nbrcmf_fws_lock(fws);\r\nif (fifo != BRCMF_FWS_FIFO_AC_BE && fifo < BRCMF_FWS_FIFO_BCMC)\r\nfws->borrow_defer_timestamp = jiffies +\r\nBRCMF_FWS_BORROW_DEFER_PERIOD;\r\nskcb->mac = brcmf_fws_macdesc_find(fws, ifp, eh->h_dest);\r\nbrcmf_dbg(DATA, "%s mac %pM multi %d fifo %d\n", skcb->mac->name,\r\neh->h_dest, multicast, fifo);\r\nif (!brcmf_fws_assign_htod(fws, skb, fifo)) {\r\nbrcmf_fws_enq(fws, BRCMF_FWS_SKBSTATE_DELAYED, fifo, skb);\r\nbrcmf_fws_schedule_deq(fws);\r\n} else {\r\nbrcmf_err("drop skb: no hanger slot\n");\r\nbrcmf_txfinalize(drvr, skb, ifp->ifidx, false);\r\nrc = -ENOMEM;\r\n}\r\nbrcmf_fws_unlock(fws);\r\nreturn rc;\r\n}\r\nvoid brcmf_fws_reset_interface(struct brcmf_if *ifp)\r\n{\r\nstruct brcmf_fws_mac_descriptor *entry = ifp->fws_desc;\r\nbrcmf_dbg(TRACE, "enter: idx=%d\n", ifp->bssidx);\r\nif (!entry)\r\nreturn;\r\nbrcmf_fws_macdesc_init(entry, ifp->mac_addr, ifp->ifidx);\r\n}\r\nvoid brcmf_fws_add_interface(struct brcmf_if *ifp)\r\n{\r\nstruct brcmf_fws_info *fws = ifp->drvr->fws;\r\nstruct brcmf_fws_mac_descriptor *entry;\r\nif (!ifp->ndev)\r\nreturn;\r\nentry = &fws->desc.iface[ifp->ifidx];\r\nifp->fws_desc = entry;\r\nbrcmf_fws_macdesc_init(entry, ifp->mac_addr, ifp->ifidx);\r\nbrcmf_fws_macdesc_set_name(fws, entry);\r\nbrcmu_pktq_init(&entry->psq, BRCMF_FWS_PSQ_PREC_COUNT,\r\nBRCMF_FWS_PSQ_LEN);\r\nbrcmf_dbg(TRACE, "added %s\n", entry->name);\r\n}\r\nvoid brcmf_fws_del_interface(struct brcmf_if *ifp)\r\n{\r\nstruct brcmf_fws_mac_descriptor *entry = ifp->fws_desc;\r\nif (!entry)\r\nreturn;\r\nbrcmf_fws_lock(ifp->drvr->fws);\r\nifp->fws_desc = NULL;\r\nbrcmf_dbg(TRACE, "deleting %s\n", entry->name);\r\nbrcmf_fws_macdesc_deinit(entry);\r\nbrcmf_fws_cleanup(ifp->drvr->fws, ifp->ifidx);\r\nbrcmf_fws_unlock(ifp->drvr->fws);\r\n}\r\nstatic void brcmf_fws_dequeue_worker(struct work_struct *worker)\r\n{\r\nstruct brcmf_fws_info *fws;\r\nstruct brcmf_pub *drvr;\r\nstruct sk_buff *skb;\r\nint fifo;\r\nu32 hslot;\r\nu32 ifidx;\r\nint ret;\r\nfws = container_of(worker, struct brcmf_fws_info, fws_dequeue_work);\r\ndrvr = fws->drvr;\r\nbrcmf_fws_lock(fws);\r\nfor (fifo = BRCMF_FWS_FIFO_BCMC; fifo >= 0 && !fws->bus_flow_blocked;\r\nfifo--) {\r\nif (!brcmf_fws_fc_active(fws)) {\r\nwhile ((skb = brcmf_fws_deq(fws, fifo)) != NULL) {\r\nhslot = brcmf_skb_htod_tag_get_field(skb,\r\nHSLOT);\r\nbrcmf_fws_hanger_poppkt(&fws->hanger, hslot,\r\n&skb, true);\r\nifidx = brcmf_skb_if_flags_get_field(skb,\r\nINDEX);\r\nbrcmf_fws_unlock(fws);\r\nret = brcmf_proto_txdata(drvr, ifidx, 0, skb);\r\nbrcmf_fws_lock(fws);\r\nif (ret < 0)\r\nbrcmf_txfinalize(drvr, skb, ifidx,\r\nfalse);\r\nif (fws->bus_flow_blocked)\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nwhile ((fws->fifo_credit[fifo]) || ((!fws->bcmc_credit_check) &&\r\n(fifo == BRCMF_FWS_FIFO_BCMC))) {\r\nskb = brcmf_fws_deq(fws, fifo);\r\nif (!skb)\r\nbreak;\r\nfws->fifo_credit[fifo]--;\r\nif (brcmf_fws_commit_skb(fws, fifo, skb))\r\nbreak;\r\nif (fws->bus_flow_blocked)\r\nbreak;\r\n}\r\nif ((fifo == BRCMF_FWS_FIFO_AC_BE) &&\r\n(fws->fifo_credit[fifo] == 0) &&\r\n(!fws->bus_flow_blocked)) {\r\nwhile (brcmf_fws_borrow_credit(fws) == 0) {\r\nskb = brcmf_fws_deq(fws, fifo);\r\nif (!skb) {\r\nbrcmf_fws_return_credits(fws, fifo, 1);\r\nbreak;\r\n}\r\nif (brcmf_fws_commit_skb(fws, fifo, skb))\r\nbreak;\r\nif (fws->bus_flow_blocked)\r\nbreak;\r\n}\r\n}\r\n}\r\nbrcmf_fws_unlock(fws);\r\n}\r\nstatic int brcmf_debugfs_fws_stats_read(struct seq_file *seq, void *data)\r\n{\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(seq->private);\r\nstruct brcmf_fws_stats *fwstats = &bus_if->drvr->fws->stats;\r\nseq_printf(seq,\r\n"header_pulls: %u\n"\r\n"header_only_pkt: %u\n"\r\n"tlv_parse_failed: %u\n"\r\n"tlv_invalid_type: %u\n"\r\n"mac_update_fails: %u\n"\r\n"ps_update_fails: %u\n"\r\n"if_update_fails: %u\n"\r\n"pkt2bus: %u\n"\r\n"generic_error: %u\n"\r\n"rollback_success: %u\n"\r\n"rollback_failed: %u\n"\r\n"delayq_full: %u\n"\r\n"supprq_full: %u\n"\r\n"txs_indicate: %u\n"\r\n"txs_discard: %u\n"\r\n"txs_suppr_core: %u\n"\r\n"txs_suppr_ps: %u\n"\r\n"txs_tossed: %u\n"\r\n"txs_host_tossed: %u\n"\r\n"bus_flow_block: %u\n"\r\n"fws_flow_block: %u\n"\r\n"send_pkts: BK:%u BE:%u VO:%u VI:%u BCMC:%u\n"\r\n"requested_sent: BK:%u BE:%u VO:%u VI:%u BCMC:%u\n",\r\nfwstats->header_pulls,\r\nfwstats->header_only_pkt,\r\nfwstats->tlv_parse_failed,\r\nfwstats->tlv_invalid_type,\r\nfwstats->mac_update_failed,\r\nfwstats->mac_ps_update_failed,\r\nfwstats->if_update_failed,\r\nfwstats->pkt2bus,\r\nfwstats->generic_error,\r\nfwstats->rollback_success,\r\nfwstats->rollback_failed,\r\nfwstats->delayq_full_error,\r\nfwstats->supprq_full_error,\r\nfwstats->txs_indicate,\r\nfwstats->txs_discard,\r\nfwstats->txs_supp_core,\r\nfwstats->txs_supp_ps,\r\nfwstats->txs_tossed,\r\nfwstats->txs_host_tossed,\r\nfwstats->bus_flow_block,\r\nfwstats->fws_flow_block,\r\nfwstats->send_pkts[0], fwstats->send_pkts[1],\r\nfwstats->send_pkts[2], fwstats->send_pkts[3],\r\nfwstats->send_pkts[4],\r\nfwstats->requested_sent[0],\r\nfwstats->requested_sent[1],\r\nfwstats->requested_sent[2],\r\nfwstats->requested_sent[3],\r\nfwstats->requested_sent[4]);\r\nreturn 0;\r\n}\r\nstatic int brcmf_debugfs_fws_stats_read(struct seq_file *seq, void *data)\r\n{\r\nreturn 0;\r\n}\r\nint brcmf_fws_init(struct brcmf_pub *drvr)\r\n{\r\nstruct brcmf_fws_info *fws;\r\nu32 tlv = BRCMF_FWS_FLAGS_RSSI_SIGNALS;\r\nint rc;\r\nu32 mode;\r\ndrvr->fws = kzalloc(sizeof(*(drvr->fws)), GFP_KERNEL);\r\nif (!drvr->fws) {\r\nrc = -ENOMEM;\r\ngoto fail;\r\n}\r\nfws = drvr->fws;\r\nspin_lock_init(&fws->spinlock);\r\nfws->drvr = drvr;\r\nfws->fcmode = fcmode;\r\nif ((drvr->bus_if->always_use_fws_queue == false) &&\r\n(fcmode == BRCMF_FWS_FCMODE_NONE)) {\r\nfws->avoid_queueing = true;\r\nbrcmf_dbg(INFO, "FWS queueing will be avoided\n");\r\nreturn 0;\r\n}\r\nfws->fws_wq = create_singlethread_workqueue("brcmf_fws_wq");\r\nif (fws->fws_wq == NULL) {\r\nbrcmf_err("workqueue creation failed\n");\r\nrc = -EBADF;\r\ngoto fail;\r\n}\r\nINIT_WORK(&fws->fws_dequeue_work, brcmf_fws_dequeue_worker);\r\nif (fws->fcmode != BRCMF_FWS_FCMODE_NONE)\r\ntlv |= BRCMF_FWS_FLAGS_XONXOFF_SIGNALS |\r\nBRCMF_FWS_FLAGS_CREDIT_STATUS_SIGNALS |\r\nBRCMF_FWS_FLAGS_HOST_PROPTXSTATUS_ACTIVE |\r\nBRCMF_FWS_FLAGS_HOST_RXREORDER_ACTIVE;\r\nrc = brcmf_fweh_register(drvr, BRCMF_E_FIFO_CREDIT_MAP,\r\nbrcmf_fws_notify_credit_map);\r\nif (rc < 0) {\r\nbrcmf_err("register credit map handler failed\n");\r\ngoto fail;\r\n}\r\nrc = brcmf_fweh_register(drvr, BRCMF_E_BCMC_CREDIT_SUPPORT,\r\nbrcmf_fws_notify_bcmc_credit_support);\r\nif (rc < 0) {\r\nbrcmf_err("register bcmc credit handler failed\n");\r\nbrcmf_fweh_unregister(drvr, BRCMF_E_FIFO_CREDIT_MAP);\r\ngoto fail;\r\n}\r\nfws->fw_signals = true;\r\nif (brcmf_fil_iovar_int_set(drvr->iflist[0], "tlv", tlv)) {\r\nbrcmf_err("failed to set bdcv2 tlv signaling\n");\r\nfws->fcmode = BRCMF_FWS_FCMODE_NONE;\r\nfws->fw_signals = false;\r\n}\r\nif (brcmf_fil_iovar_int_set(drvr->iflist[0], "ampdu_hostreorder", 1))\r\nbrcmf_dbg(INFO, "enabling AMPDU host-reorder failed\n");\r\nif (brcmf_fil_iovar_int_get(drvr->iflist[0], "wlfc_mode", &mode) == 0) {\r\nif (BRCMF_FWS_MODE_GET_REUSESEQ(mode)) {\r\nmode = 0;\r\nBRCMF_FWS_MODE_SET_REUSESEQ(mode, 1);\r\nif (brcmf_fil_iovar_int_set(drvr->iflist[0],\r\n"wlfc_mode", mode) == 0) {\r\nBRCMF_FWS_MODE_SET_REUSESEQ(fws->mode, 1);\r\n}\r\n}\r\n}\r\nbrcmf_fws_hanger_init(&fws->hanger);\r\nbrcmf_fws_macdesc_init(&fws->desc.other, NULL, 0);\r\nbrcmf_fws_macdesc_set_name(fws, &fws->desc.other);\r\nbrcmu_pktq_init(&fws->desc.other.psq, BRCMF_FWS_PSQ_PREC_COUNT,\r\nBRCMF_FWS_PSQ_LEN);\r\nbrcmf_debugfs_add_entry(drvr, "fws_stats",\r\nbrcmf_debugfs_fws_stats_read);\r\nbrcmf_dbg(INFO, "%s bdcv2 tlv signaling [%x]\n",\r\nfws->fw_signals ? "enabled" : "disabled", tlv);\r\nreturn 0;\r\nfail:\r\nbrcmf_fws_deinit(drvr);\r\nreturn rc;\r\n}\r\nvoid brcmf_fws_deinit(struct brcmf_pub *drvr)\r\n{\r\nstruct brcmf_fws_info *fws = drvr->fws;\r\nif (!fws)\r\nreturn;\r\nif (drvr->fws->fws_wq)\r\ndestroy_workqueue(drvr->fws->fws_wq);\r\nbrcmf_fws_lock(fws);\r\nbrcmf_fws_cleanup(fws, -1);\r\ndrvr->fws = NULL;\r\nbrcmf_fws_unlock(fws);\r\nkfree(fws);\r\n}\r\nbool brcmf_fws_fc_active(struct brcmf_fws_info *fws)\r\n{\r\nif (!fws->creditmap_received)\r\nreturn false;\r\nreturn fws->fcmode != BRCMF_FWS_FCMODE_NONE;\r\n}\r\nvoid brcmf_fws_bustxfail(struct brcmf_fws_info *fws, struct sk_buff *skb)\r\n{\r\nu32 hslot;\r\nif (brcmf_skbcb(skb)->state == BRCMF_FWS_SKBSTATE_TIM) {\r\nbrcmu_pkt_buf_free_skb(skb);\r\nreturn;\r\n}\r\nbrcmf_fws_lock(fws);\r\nhslot = brcmf_skb_htod_tag_get_field(skb, HSLOT);\r\nbrcmf_fws_txs_process(fws, BRCMF_FWS_TXSTATUS_HOST_TOSSED, hslot, 0, 0);\r\nbrcmf_fws_unlock(fws);\r\n}\r\nvoid brcmf_fws_bus_blocked(struct brcmf_pub *drvr, bool flow_blocked)\r\n{\r\nstruct brcmf_fws_info *fws = drvr->fws;\r\nfws->bus_flow_blocked = flow_blocked;\r\nif (!flow_blocked)\r\nbrcmf_fws_schedule_deq(fws);\r\nelse\r\nfws->stats.bus_flow_block++;\r\n}
