static void sh2a_flush_oc_line(unsigned long v, int way)\r\n{\r\nunsigned long addr = (v & 0x000007f0) | (way << 11);\r\nunsigned long data;\r\ndata = __raw_readl(CACHE_OC_ADDRESS_ARRAY | addr);\r\nif ((data & CACHE_PHYSADDR_MASK) == (v & CACHE_PHYSADDR_MASK)) {\r\ndata &= ~SH_CACHE_UPDATED;\r\n__raw_writel(data, CACHE_OC_ADDRESS_ARRAY | addr);\r\n}\r\n}\r\nstatic void sh2a_invalidate_line(unsigned long cache_addr, unsigned long v)\r\n{\r\nunsigned long addr = (v & 0x000007f0) | SH_CACHE_ASSOC;\r\n__raw_writel((addr & CACHE_PHYSADDR_MASK), cache_addr | addr);\r\n}\r\nstatic void sh2a__flush_wback_region(void *start, int size)\r\n{\r\n#ifdef CONFIG_CACHE_WRITEBACK\r\nunsigned long v;\r\nunsigned long begin, end;\r\nunsigned long flags;\r\nint nr_ways;\r\nbegin = (unsigned long)start & ~(L1_CACHE_BYTES-1);\r\nend = ((unsigned long)start + size + L1_CACHE_BYTES-1)\r\n& ~(L1_CACHE_BYTES-1);\r\nnr_ways = current_cpu_data.dcache.ways;\r\nlocal_irq_save(flags);\r\njump_to_uncached();\r\nif (((end - begin) >> PAGE_SHIFT) >= MAX_OCACHE_PAGES) {\r\nbegin = CACHE_OC_ADDRESS_ARRAY;\r\nend = begin + (nr_ways * current_cpu_data.dcache.way_size);\r\nfor (v = begin; v < end; v += L1_CACHE_BYTES) {\r\nunsigned long data = __raw_readl(v);\r\nif (data & SH_CACHE_UPDATED)\r\n__raw_writel(data & ~SH_CACHE_UPDATED, v);\r\n}\r\n} else {\r\nint way;\r\nfor (way = 0; way < nr_ways; way++) {\r\nfor (v = begin; v < end; v += L1_CACHE_BYTES)\r\nsh2a_flush_oc_line(v, way);\r\n}\r\n}\r\nback_to_cached();\r\nlocal_irq_restore(flags);\r\n#endif\r\n}\r\nstatic void sh2a__flush_purge_region(void *start, int size)\r\n{\r\nunsigned long v;\r\nunsigned long begin, end;\r\nunsigned long flags;\r\nbegin = (unsigned long)start & ~(L1_CACHE_BYTES-1);\r\nend = ((unsigned long)start + size + L1_CACHE_BYTES-1)\r\n& ~(L1_CACHE_BYTES-1);\r\nlocal_irq_save(flags);\r\njump_to_uncached();\r\nfor (v = begin; v < end; v+=L1_CACHE_BYTES) {\r\n#ifdef CONFIG_CACHE_WRITEBACK\r\nint way;\r\nint nr_ways = current_cpu_data.dcache.ways;\r\nfor (way = 0; way < nr_ways; way++)\r\nsh2a_flush_oc_line(v, way);\r\n#endif\r\nsh2a_invalidate_line(CACHE_OC_ADDRESS_ARRAY, v);\r\n}\r\nback_to_cached();\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void sh2a__flush_invalidate_region(void *start, int size)\r\n{\r\nunsigned long v;\r\nunsigned long begin, end;\r\nunsigned long flags;\r\nbegin = (unsigned long)start & ~(L1_CACHE_BYTES-1);\r\nend = ((unsigned long)start + size + L1_CACHE_BYTES-1)\r\n& ~(L1_CACHE_BYTES-1);\r\nlocal_irq_save(flags);\r\njump_to_uncached();\r\nif (((end - begin) >> PAGE_SHIFT) >= MAX_OCACHE_PAGES) {\r\n__raw_writel(__raw_readl(SH_CCR) | CCR_OCACHE_INVALIDATE,\r\nSH_CCR);\r\n} else {\r\nfor (v = begin; v < end; v += L1_CACHE_BYTES)\r\nsh2a_invalidate_line(CACHE_OC_ADDRESS_ARRAY, v);\r\n}\r\nback_to_cached();\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void sh2a_flush_icache_range(void *args)\r\n{\r\nstruct flusher_data *data = args;\r\nunsigned long start, end;\r\nunsigned long v;\r\nunsigned long flags;\r\nstart = data->addr1 & ~(L1_CACHE_BYTES-1);\r\nend = (data->addr2 + L1_CACHE_BYTES-1) & ~(L1_CACHE_BYTES-1);\r\n#ifdef CONFIG_CACHE_WRITEBACK\r\nsh2a__flush_wback_region((void *)start, end-start);\r\n#endif\r\nlocal_irq_save(flags);\r\njump_to_uncached();\r\nif (((end - start) >> PAGE_SHIFT) >= MAX_ICACHE_PAGES) {\r\n__raw_writel(__raw_readl(SH_CCR) | CCR_ICACHE_INVALIDATE,\r\nSH_CCR);\r\n} else {\r\nfor (v = start; v < end; v += L1_CACHE_BYTES)\r\nsh2a_invalidate_line(CACHE_IC_ADDRESS_ARRAY, v);\r\n}\r\nback_to_cached();\r\nlocal_irq_restore(flags);\r\n}\r\nvoid __init sh2a_cache_init(void)\r\n{\r\nlocal_flush_icache_range = sh2a_flush_icache_range;\r\n__flush_wback_region = sh2a__flush_wback_region;\r\n__flush_purge_region = sh2a__flush_purge_region;\r\n__flush_invalidate_region = sh2a__flush_invalidate_region;\r\n}
