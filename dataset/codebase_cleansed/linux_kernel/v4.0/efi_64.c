static void __init early_code_mapping_set_exec(int executable)\r\n{\r\nefi_memory_desc_t *md;\r\nvoid *p;\r\nif (!(__supported_pte_mask & _PAGE_NX))\r\nreturn;\r\nfor (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {\r\nmd = p;\r\nif (md->type == EFI_RUNTIME_SERVICES_CODE ||\r\nmd->type == EFI_BOOT_SERVICES_CODE)\r\nefi_set_executable(md, executable);\r\n}\r\n}\r\nvoid __init efi_call_phys_prolog(void)\r\n{\r\nunsigned long vaddress;\r\nint pgd;\r\nint n_pgds;\r\nif (!efi_enabled(EFI_OLD_MEMMAP))\r\nreturn;\r\nearly_code_mapping_set_exec(1);\r\nlocal_irq_save(efi_flags);\r\nn_pgds = DIV_ROUND_UP((max_pfn << PAGE_SHIFT), PGDIR_SIZE);\r\nsave_pgd = kmalloc(n_pgds * sizeof(pgd_t), GFP_KERNEL);\r\nfor (pgd = 0; pgd < n_pgds; pgd++) {\r\nsave_pgd[pgd] = *pgd_offset_k(pgd * PGDIR_SIZE);\r\nvaddress = (unsigned long)__va(pgd * PGDIR_SIZE);\r\nset_pgd(pgd_offset_k(pgd * PGDIR_SIZE), *pgd_offset_k(vaddress));\r\n}\r\n__flush_tlb_all();\r\n}\r\nvoid __init efi_call_phys_epilog(void)\r\n{\r\nint pgd;\r\nint n_pgds = DIV_ROUND_UP((max_pfn << PAGE_SHIFT) , PGDIR_SIZE);\r\nif (!efi_enabled(EFI_OLD_MEMMAP))\r\nreturn;\r\nfor (pgd = 0; pgd < n_pgds; pgd++)\r\nset_pgd(pgd_offset_k(pgd * PGDIR_SIZE), save_pgd[pgd]);\r\nkfree(save_pgd);\r\n__flush_tlb_all();\r\nlocal_irq_restore(efi_flags);\r\nearly_code_mapping_set_exec(0);\r\n}\r\nvoid efi_sync_low_kernel_mappings(void)\r\n{\r\nunsigned num_pgds;\r\npgd_t *pgd = (pgd_t *)__va(real_mode_header->trampoline_pgd);\r\nif (efi_enabled(EFI_OLD_MEMMAP))\r\nreturn;\r\nnum_pgds = pgd_index(MODULES_END - 1) - pgd_index(PAGE_OFFSET);\r\nmemcpy(pgd + pgd_index(PAGE_OFFSET),\r\ninit_mm.pgd + pgd_index(PAGE_OFFSET),\r\nsizeof(pgd_t) * num_pgds);\r\n}\r\nint __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)\r\n{\r\nunsigned long text;\r\nstruct page *page;\r\nunsigned npages;\r\npgd_t *pgd;\r\nif (efi_enabled(EFI_OLD_MEMMAP))\r\nreturn 0;\r\nefi_scratch.efi_pgt = (pgd_t *)(unsigned long)real_mode_header->trampoline_pgd;\r\npgd = __va(efi_scratch.efi_pgt);\r\nif (kernel_map_pages_in_pgd(pgd, pa_memmap, pa_memmap, num_pages, _PAGE_NX)) {\r\npr_err("Error ident-mapping new memmap (0x%lx)!\n", pa_memmap);\r\nreturn 1;\r\n}\r\nefi_scratch.use_pgd = true;\r\nif (!IS_ENABLED(CONFIG_EFI_MIXED))\r\nreturn 0;\r\npage = alloc_page(GFP_KERNEL|__GFP_DMA32);\r\nif (!page)\r\npanic("Unable to allocate EFI runtime stack < 4GB\n");\r\nefi_scratch.phys_stack = virt_to_phys(page_address(page));\r\nefi_scratch.phys_stack += PAGE_SIZE;\r\nnpages = (_end - _text) >> PAGE_SHIFT;\r\ntext = __pa(_text);\r\nif (kernel_map_pages_in_pgd(pgd, text >> PAGE_SHIFT, text, npages, 0)) {\r\npr_err("Failed to map kernel text 1:1\n");\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid __init efi_cleanup_page_tables(unsigned long pa_memmap, unsigned num_pages)\r\n{\r\npgd_t *pgd = (pgd_t *)__va(real_mode_header->trampoline_pgd);\r\nkernel_unmap_pages_in_pgd(pgd, pa_memmap, num_pages);\r\n}\r\nstatic void __init __map_region(efi_memory_desc_t *md, u64 va)\r\n{\r\npgd_t *pgd = (pgd_t *)__va(real_mode_header->trampoline_pgd);\r\nunsigned long pf = 0;\r\nif (!(md->attribute & EFI_MEMORY_WB))\r\npf |= _PAGE_PCD;\r\nif (kernel_map_pages_in_pgd(pgd, md->phys_addr, va, md->num_pages, pf))\r\npr_warn("Error mapping PA 0x%llx -> VA 0x%llx!\n",\r\nmd->phys_addr, va);\r\n}\r\nvoid __init efi_map_region(efi_memory_desc_t *md)\r\n{\r\nunsigned long size = md->num_pages << PAGE_SHIFT;\r\nu64 pa = md->phys_addr;\r\nif (efi_enabled(EFI_OLD_MEMMAP))\r\nreturn old_map_region(md);\r\n__map_region(md, md->phys_addr);\r\nif (!efi_is_native () && IS_ENABLED(CONFIG_EFI_MIXED)) {\r\nmd->virt_addr = md->phys_addr;\r\nreturn;\r\n}\r\nefi_va -= size;\r\nif (!(pa & (PMD_SIZE - 1))) {\r\nefi_va &= PMD_MASK;\r\n} else {\r\nu64 pa_offset = pa & (PMD_SIZE - 1);\r\nu64 prev_va = efi_va;\r\nefi_va = (efi_va & PMD_MASK) + pa_offset;\r\nif (efi_va > prev_va)\r\nefi_va -= PMD_SIZE;\r\n}\r\nif (efi_va < EFI_VA_END) {\r\npr_warn(FW_WARN "VA address range overflow!\n");\r\nreturn;\r\n}\r\n__map_region(md, efi_va);\r\nmd->virt_addr = efi_va;\r\n}\r\nvoid __init efi_map_region_fixed(efi_memory_desc_t *md)\r\n{\r\n__map_region(md, md->virt_addr);\r\n}\r\nvoid __iomem *__init efi_ioremap(unsigned long phys_addr, unsigned long size,\r\nu32 type, u64 attribute)\r\n{\r\nunsigned long last_map_pfn;\r\nif (type == EFI_MEMORY_MAPPED_IO)\r\nreturn ioremap(phys_addr, size);\r\nlast_map_pfn = init_memory_mapping(phys_addr, phys_addr + size);\r\nif ((last_map_pfn << PAGE_SHIFT) < phys_addr + size) {\r\nunsigned long top = last_map_pfn << PAGE_SHIFT;\r\nefi_ioremap(top, size - (top - phys_addr), type, attribute);\r\n}\r\nif (!(attribute & EFI_MEMORY_WB))\r\nefi_memory_uc((u64)(unsigned long)__va(phys_addr), size);\r\nreturn (void __iomem *)__va(phys_addr);\r\n}\r\nvoid __init parse_efi_setup(u64 phys_addr, u32 data_len)\r\n{\r\nefi_setup = phys_addr + sizeof(struct setup_data);\r\n}\r\nvoid __init efi_runtime_mkexec(void)\r\n{\r\nif (!efi_enabled(EFI_OLD_MEMMAP))\r\nreturn;\r\nif (__supported_pte_mask & _PAGE_NX)\r\nruntime_code_page_mkexec();\r\n}\r\nvoid __init efi_dump_pagetable(void)\r\n{\r\n#ifdef CONFIG_EFI_PGT_DUMP\r\npgd_t *pgd = (pgd_t *)__va(real_mode_header->trampoline_pgd);\r\nptdump_walk_pgd_level(NULL, pgd);\r\n#endif\r\n}\r\nefi_status_t efi_thunk_set_virtual_address_map(\r\nvoid *phys_set_virtual_address_map,\r\nunsigned long memory_map_size,\r\nunsigned long descriptor_size,\r\nu32 descriptor_version,\r\nefi_memory_desc_t *virtual_map)\r\n{\r\nefi_status_t status;\r\nunsigned long flags;\r\nu32 func;\r\nefi_sync_low_kernel_mappings();\r\nlocal_irq_save(flags);\r\nefi_scratch.prev_cr3 = read_cr3();\r\nwrite_cr3((unsigned long)efi_scratch.efi_pgt);\r\n__flush_tlb_all();\r\nfunc = (u32)(unsigned long)phys_set_virtual_address_map;\r\nstatus = efi64_thunk(func, memory_map_size, descriptor_size,\r\ndescriptor_version, virtual_map);\r\nwrite_cr3(efi_scratch.prev_cr3);\r\n__flush_tlb_all();\r\nlocal_irq_restore(flags);\r\nreturn status;\r\n}\r\nstatic efi_status_t efi_thunk_get_time(efi_time_t *tm, efi_time_cap_t *tc)\r\n{\r\nefi_status_t status;\r\nu32 phys_tm, phys_tc;\r\nspin_lock(&rtc_lock);\r\nphys_tm = virt_to_phys(tm);\r\nphys_tc = virt_to_phys(tc);\r\nstatus = efi_thunk(get_time, phys_tm, phys_tc);\r\nspin_unlock(&rtc_lock);\r\nreturn status;\r\n}\r\nstatic efi_status_t efi_thunk_set_time(efi_time_t *tm)\r\n{\r\nefi_status_t status;\r\nu32 phys_tm;\r\nspin_lock(&rtc_lock);\r\nphys_tm = virt_to_phys(tm);\r\nstatus = efi_thunk(set_time, phys_tm);\r\nspin_unlock(&rtc_lock);\r\nreturn status;\r\n}\r\nstatic efi_status_t\r\nefi_thunk_get_wakeup_time(efi_bool_t *enabled, efi_bool_t *pending,\r\nefi_time_t *tm)\r\n{\r\nefi_status_t status;\r\nu32 phys_enabled, phys_pending, phys_tm;\r\nspin_lock(&rtc_lock);\r\nphys_enabled = virt_to_phys(enabled);\r\nphys_pending = virt_to_phys(pending);\r\nphys_tm = virt_to_phys(tm);\r\nstatus = efi_thunk(get_wakeup_time, phys_enabled,\r\nphys_pending, phys_tm);\r\nspin_unlock(&rtc_lock);\r\nreturn status;\r\n}\r\nstatic efi_status_t\r\nefi_thunk_set_wakeup_time(efi_bool_t enabled, efi_time_t *tm)\r\n{\r\nefi_status_t status;\r\nu32 phys_tm;\r\nspin_lock(&rtc_lock);\r\nphys_tm = virt_to_phys(tm);\r\nstatus = efi_thunk(set_wakeup_time, enabled, phys_tm);\r\nspin_unlock(&rtc_lock);\r\nreturn status;\r\n}\r\nstatic efi_status_t\r\nefi_thunk_get_variable(efi_char16_t *name, efi_guid_t *vendor,\r\nu32 *attr, unsigned long *data_size, void *data)\r\n{\r\nefi_status_t status;\r\nu32 phys_name, phys_vendor, phys_attr;\r\nu32 phys_data_size, phys_data;\r\nphys_data_size = virt_to_phys(data_size);\r\nphys_vendor = virt_to_phys(vendor);\r\nphys_name = virt_to_phys(name);\r\nphys_attr = virt_to_phys(attr);\r\nphys_data = virt_to_phys(data);\r\nstatus = efi_thunk(get_variable, phys_name, phys_vendor,\r\nphys_attr, phys_data_size, phys_data);\r\nreturn status;\r\n}\r\nstatic efi_status_t\r\nefi_thunk_set_variable(efi_char16_t *name, efi_guid_t *vendor,\r\nu32 attr, unsigned long data_size, void *data)\r\n{\r\nu32 phys_name, phys_vendor, phys_data;\r\nefi_status_t status;\r\nphys_name = virt_to_phys(name);\r\nphys_vendor = virt_to_phys(vendor);\r\nphys_data = virt_to_phys(data);\r\nstatus = efi_thunk(set_variable, phys_name, phys_vendor,\r\nattr, data_size, phys_data);\r\nreturn status;\r\n}\r\nstatic efi_status_t\r\nefi_thunk_get_next_variable(unsigned long *name_size,\r\nefi_char16_t *name,\r\nefi_guid_t *vendor)\r\n{\r\nefi_status_t status;\r\nu32 phys_name_size, phys_name, phys_vendor;\r\nphys_name_size = virt_to_phys(name_size);\r\nphys_vendor = virt_to_phys(vendor);\r\nphys_name = virt_to_phys(name);\r\nstatus = efi_thunk(get_next_variable, phys_name_size,\r\nphys_name, phys_vendor);\r\nreturn status;\r\n}\r\nstatic efi_status_t\r\nefi_thunk_get_next_high_mono_count(u32 *count)\r\n{\r\nefi_status_t status;\r\nu32 phys_count;\r\nphys_count = virt_to_phys(count);\r\nstatus = efi_thunk(get_next_high_mono_count, phys_count);\r\nreturn status;\r\n}\r\nstatic void\r\nefi_thunk_reset_system(int reset_type, efi_status_t status,\r\nunsigned long data_size, efi_char16_t *data)\r\n{\r\nu32 phys_data;\r\nphys_data = virt_to_phys(data);\r\nefi_thunk(reset_system, reset_type, status, data_size, phys_data);\r\n}\r\nstatic efi_status_t\r\nefi_thunk_update_capsule(efi_capsule_header_t **capsules,\r\nunsigned long count, unsigned long sg_list)\r\n{\r\nreturn EFI_UNSUPPORTED;\r\n}\r\nstatic efi_status_t\r\nefi_thunk_query_variable_info(u32 attr, u64 *storage_space,\r\nu64 *remaining_space,\r\nu64 *max_variable_size)\r\n{\r\nefi_status_t status;\r\nu32 phys_storage, phys_remaining, phys_max;\r\nif (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)\r\nreturn EFI_UNSUPPORTED;\r\nphys_storage = virt_to_phys(storage_space);\r\nphys_remaining = virt_to_phys(remaining_space);\r\nphys_max = virt_to_phys(max_variable_size);\r\nstatus = efi_thunk(query_variable_info, attr, phys_storage,\r\nphys_remaining, phys_max);\r\nreturn status;\r\n}\r\nstatic efi_status_t\r\nefi_thunk_query_capsule_caps(efi_capsule_header_t **capsules,\r\nunsigned long count, u64 *max_size,\r\nint *reset_type)\r\n{\r\nreturn EFI_UNSUPPORTED;\r\n}\r\nvoid efi_thunk_runtime_setup(void)\r\n{\r\nefi.get_time = efi_thunk_get_time;\r\nefi.set_time = efi_thunk_set_time;\r\nefi.get_wakeup_time = efi_thunk_get_wakeup_time;\r\nefi.set_wakeup_time = efi_thunk_set_wakeup_time;\r\nefi.get_variable = efi_thunk_get_variable;\r\nefi.get_next_variable = efi_thunk_get_next_variable;\r\nefi.set_variable = efi_thunk_set_variable;\r\nefi.get_next_high_mono_count = efi_thunk_get_next_high_mono_count;\r\nefi.reset_system = efi_thunk_reset_system;\r\nefi.query_variable_info = efi_thunk_query_variable_info;\r\nefi.update_capsule = efi_thunk_update_capsule;\r\nefi.query_capsule_caps = efi_thunk_query_capsule_caps;\r\n}
