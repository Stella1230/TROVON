static inline void xoutb(unsigned char val, unsigned short port)\r\n{\r\npr_debug("outb(val=%.2x,port=%.4x)\n", val, port);\r\noutb(val, port);\r\n}\r\nstatic inline unsigned char xinb(unsigned short port)\r\n{\r\nunsigned char val;\r\nval = inb(port);\r\npr_debug("%.2x=inb(%.4x)\n", val, port);\r\nreturn val;\r\n}\r\nstatic void cm4040_do_poll(unsigned long dummy)\r\n{\r\nstruct reader_dev *dev = (struct reader_dev *) dummy;\r\nunsigned int obs = xinb(dev->p_dev->resource[0]->start\r\n+ REG_OFFSET_BUFFER_STATUS);\r\nif ((obs & BSR_BULK_IN_FULL)) {\r\nset_bit(BS_READABLE, &dev->buffer_status);\r\nDEBUGP(4, dev, "waking up read_wait\n");\r\nwake_up_interruptible(&dev->read_wait);\r\n} else\r\nclear_bit(BS_READABLE, &dev->buffer_status);\r\nif (!(obs & BSR_BULK_OUT_FULL)) {\r\nset_bit(BS_WRITABLE, &dev->buffer_status);\r\nDEBUGP(4, dev, "waking up write_wait\n");\r\nwake_up_interruptible(&dev->write_wait);\r\n} else\r\nclear_bit(BS_WRITABLE, &dev->buffer_status);\r\nif (dev->buffer_status)\r\nwake_up_interruptible(&dev->poll_wait);\r\nmod_timer(&dev->poll_timer, jiffies + POLL_PERIOD);\r\n}\r\nstatic void cm4040_stop_poll(struct reader_dev *dev)\r\n{\r\ndel_timer_sync(&dev->poll_timer);\r\n}\r\nstatic int wait_for_bulk_out_ready(struct reader_dev *dev)\r\n{\r\nint i, rc;\r\nint iobase = dev->p_dev->resource[0]->start;\r\nfor (i = 0; i < POLL_LOOP_COUNT; i++) {\r\nif ((xinb(iobase + REG_OFFSET_BUFFER_STATUS)\r\n& BSR_BULK_OUT_FULL) == 0) {\r\nDEBUGP(4, dev, "BulkOut empty (i=%d)\n", i);\r\nreturn 1;\r\n}\r\n}\r\nDEBUGP(4, dev, "wait_event_interruptible_timeout(timeout=%ld\n",\r\ndev->timeout);\r\nrc = wait_event_interruptible_timeout(dev->write_wait,\r\ntest_and_clear_bit(BS_WRITABLE,\r\n&dev->buffer_status),\r\ndev->timeout);\r\nif (rc > 0)\r\nDEBUGP(4, dev, "woke up: BulkOut empty\n");\r\nelse if (rc == 0)\r\nDEBUGP(4, dev, "woke up: BulkOut full, returning 0 :(\n");\r\nelse if (rc < 0)\r\nDEBUGP(4, dev, "woke up: signal arrived\n");\r\nreturn rc;\r\n}\r\nstatic int write_sync_reg(unsigned char val, struct reader_dev *dev)\r\n{\r\nint iobase = dev->p_dev->resource[0]->start;\r\nint rc;\r\nrc = wait_for_bulk_out_ready(dev);\r\nif (rc <= 0)\r\nreturn rc;\r\nxoutb(val, iobase + REG_OFFSET_SYNC_CONTROL);\r\nrc = wait_for_bulk_out_ready(dev);\r\nif (rc <= 0)\r\nreturn rc;\r\nreturn 1;\r\n}\r\nstatic int wait_for_bulk_in_ready(struct reader_dev *dev)\r\n{\r\nint i, rc;\r\nint iobase = dev->p_dev->resource[0]->start;\r\nfor (i = 0; i < POLL_LOOP_COUNT; i++) {\r\nif ((xinb(iobase + REG_OFFSET_BUFFER_STATUS)\r\n& BSR_BULK_IN_FULL) == BSR_BULK_IN_FULL) {\r\nDEBUGP(3, dev, "BulkIn full (i=%d)\n", i);\r\nreturn 1;\r\n}\r\n}\r\nDEBUGP(4, dev, "wait_event_interruptible_timeout(timeout=%ld\n",\r\ndev->timeout);\r\nrc = wait_event_interruptible_timeout(dev->read_wait,\r\ntest_and_clear_bit(BS_READABLE,\r\n&dev->buffer_status),\r\ndev->timeout);\r\nif (rc > 0)\r\nDEBUGP(4, dev, "woke up: BulkIn full\n");\r\nelse if (rc == 0)\r\nDEBUGP(4, dev, "woke up: BulkIn not full, returning 0 :(\n");\r\nelse if (rc < 0)\r\nDEBUGP(4, dev, "woke up: signal arrived\n");\r\nreturn rc;\r\n}\r\nstatic ssize_t cm4040_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct reader_dev *dev = filp->private_data;\r\nint iobase = dev->p_dev->resource[0]->start;\r\nsize_t bytes_to_read;\r\nunsigned long i;\r\nsize_t min_bytes_to_read;\r\nint rc;\r\nunsigned char uc;\r\nDEBUGP(2, dev, "-> cm4040_read(%s,%d)\n", current->comm, current->pid);\r\nif (count == 0)\r\nreturn 0;\r\nif (count < 10)\r\nreturn -EFAULT;\r\nif (filp->f_flags & O_NONBLOCK) {\r\nDEBUGP(4, dev, "filep->f_flags O_NONBLOCK set\n");\r\nDEBUGP(2, dev, "<- cm4040_read (failure)\n");\r\nreturn -EAGAIN;\r\n}\r\nif (!pcmcia_dev_present(dev->p_dev))\r\nreturn -ENODEV;\r\nfor (i = 0; i < 5; i++) {\r\nrc = wait_for_bulk_in_ready(dev);\r\nif (rc <= 0) {\r\nDEBUGP(5, dev, "wait_for_bulk_in_ready rc=%.2x\n", rc);\r\nDEBUGP(2, dev, "<- cm4040_read (failed)\n");\r\nif (rc == -ERESTARTSYS)\r\nreturn rc;\r\nreturn -EIO;\r\n}\r\ndev->r_buf[i] = xinb(iobase + REG_OFFSET_BULK_IN);\r\n#ifdef CM4040_DEBUG\r\npr_debug("%lu:%2x ", i, dev->r_buf[i]);\r\n}\r\npr_debug("\n");\r\n#else\r\n}\r\nssize_t cm4040_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct reader_dev *dev = filp->private_data;\r\nint iobase = dev->p_dev->resource[0]->start;\r\nssize_t rc;\r\nint i;\r\nunsigned int bytes_to_write;\r\nDEBUGP(2, dev, "-> cm4040_write(%s,%d)\n", current->comm, current->pid);\r\nif (count == 0) {\r\nDEBUGP(2, dev, "<- cm4040_write empty read (successfully)\n");\r\nreturn 0;\r\n}\r\nif ((count < 5) || (count > READ_WRITE_BUFFER_SIZE)) {\r\nDEBUGP(2, dev, "<- cm4040_write buffersize=%Zd < 5\n", count);\r\nreturn -EIO;\r\n}\r\nif (filp->f_flags & O_NONBLOCK) {\r\nDEBUGP(4, dev, "filep->f_flags O_NONBLOCK set\n");\r\nDEBUGP(4, dev, "<- cm4040_write (failure)\n");\r\nreturn -EAGAIN;\r\n}\r\nif (!pcmcia_dev_present(dev->p_dev))\r\nreturn -ENODEV;\r\nbytes_to_write = count;\r\nif (copy_from_user(dev->s_buf, buf, bytes_to_write))\r\nreturn -EFAULT;\r\nswitch (dev->s_buf[0]) {\r\ncase CMD_PC_TO_RDR_XFRBLOCK:\r\ncase CMD_PC_TO_RDR_SECURE:\r\ncase CMD_PC_TO_RDR_TEST_SECURE:\r\ncase CMD_PC_TO_RDR_OK_SECURE:\r\ndev->timeout = CCID_DRIVER_BULK_DEFAULT_TIMEOUT;\r\nbreak;\r\ncase CMD_PC_TO_RDR_ICCPOWERON:\r\ndev->timeout = CCID_DRIVER_ASYNC_POWERUP_TIMEOUT;\r\nbreak;\r\ncase CMD_PC_TO_RDR_GETSLOTSTATUS:\r\ncase CMD_PC_TO_RDR_ICCPOWEROFF:\r\ncase CMD_PC_TO_RDR_GETPARAMETERS:\r\ncase CMD_PC_TO_RDR_RESETPARAMETERS:\r\ncase CMD_PC_TO_RDR_SETPARAMETERS:\r\ncase CMD_PC_TO_RDR_ESCAPE:\r\ncase CMD_PC_TO_RDR_ICCCLOCK:\r\ndefault:\r\ndev->timeout = CCID_DRIVER_MINIMUM_TIMEOUT;\r\nbreak;\r\n}\r\nrc = write_sync_reg(SCR_HOST_TO_READER_START, dev);\r\nif (rc <= 0) {\r\nDEBUGP(5, dev, "write_sync_reg c=%.2Zx\n", rc);\r\nDEBUGP(2, dev, "<- cm4040_write (failed)\n");\r\nif (rc == -ERESTARTSYS)\r\nreturn rc;\r\nelse\r\nreturn -EIO;\r\n}\r\nDEBUGP(4, dev, "start \n");\r\nfor (i = 0; i < bytes_to_write; i++) {\r\nrc = wait_for_bulk_out_ready(dev);\r\nif (rc <= 0) {\r\nDEBUGP(5, dev, "wait_for_bulk_out_ready rc=%.2Zx\n",\r\nrc);\r\nDEBUGP(2, dev, "<- cm4040_write (failed)\n");\r\nif (rc == -ERESTARTSYS)\r\nreturn rc;\r\nelse\r\nreturn -EIO;\r\n}\r\nxoutb(dev->s_buf[i],iobase + REG_OFFSET_BULK_OUT);\r\n}\r\nDEBUGP(4, dev, "end\n");\r\nrc = write_sync_reg(SCR_HOST_TO_READER_DONE, dev);\r\nif (rc <= 0) {\r\nDEBUGP(5, dev, "write_sync_reg c=%.2Zx\n", rc);\r\nDEBUGP(2, dev, "<- cm4040_write (failed)\n");\r\nif (rc == -ERESTARTSYS)\r\nreturn rc;\r\nelse\r\nreturn -EIO;\r\n}\r\nDEBUGP(2, dev, "<- cm4040_write (successfully)\n");\r\nreturn count;\r\n}\r\nstatic unsigned int cm4040_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct reader_dev *dev = filp->private_data;\r\nunsigned int mask = 0;\r\npoll_wait(filp, &dev->poll_wait, wait);\r\nif (test_and_clear_bit(BS_READABLE, &dev->buffer_status))\r\nmask |= POLLIN | POLLRDNORM;\r\nif (test_and_clear_bit(BS_WRITABLE, &dev->buffer_status))\r\nmask |= POLLOUT | POLLWRNORM;\r\nDEBUGP(2, dev, "<- cm4040_poll(%u)\n", mask);\r\nreturn mask;\r\n}\r\nstatic int cm4040_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct reader_dev *dev;\r\nstruct pcmcia_device *link;\r\nint minor = iminor(inode);\r\nint ret;\r\nif (minor >= CM_MAX_DEV)\r\nreturn -ENODEV;\r\nmutex_lock(&cm4040_mutex);\r\nlink = dev_table[minor];\r\nif (link == NULL || !pcmcia_dev_present(link)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (link->open) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\ndev = link->priv;\r\nfilp->private_data = dev;\r\nif (filp->f_flags & O_NONBLOCK) {\r\nDEBUGP(4, dev, "filep->f_flags O_NONBLOCK set\n");\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nlink->open = 1;\r\ndev->poll_timer.data = (unsigned long) dev;\r\nmod_timer(&dev->poll_timer, jiffies + POLL_PERIOD);\r\nDEBUGP(2, dev, "<- cm4040_open (successfully)\n");\r\nret = nonseekable_open(inode, filp);\r\nout:\r\nmutex_unlock(&cm4040_mutex);\r\nreturn ret;\r\n}\r\nstatic int cm4040_close(struct inode *inode, struct file *filp)\r\n{\r\nstruct reader_dev *dev = filp->private_data;\r\nstruct pcmcia_device *link;\r\nint minor = iminor(inode);\r\nDEBUGP(2, dev, "-> cm4040_close(maj/min=%d.%d)\n", imajor(inode),\r\niminor(inode));\r\nif (minor >= CM_MAX_DEV)\r\nreturn -ENODEV;\r\nlink = dev_table[minor];\r\nif (link == NULL)\r\nreturn -ENODEV;\r\ncm4040_stop_poll(dev);\r\nlink->open = 0;\r\nwake_up(&dev->devq);\r\nDEBUGP(2, dev, "<- cm4040_close\n");\r\nreturn 0;\r\n}\r\nstatic void cm4040_reader_release(struct pcmcia_device *link)\r\n{\r\nstruct reader_dev *dev = link->priv;\r\nDEBUGP(3, dev, "-> cm4040_reader_release\n");\r\nwhile (link->open) {\r\nDEBUGP(3, dev, KERN_INFO MODULE_NAME ": delaying release "\r\n"until process has terminated\n");\r\nwait_event(dev->devq, (link->open == 0));\r\n}\r\nDEBUGP(3, dev, "<- cm4040_reader_release\n");\r\nreturn;\r\n}\r\nstatic int cm4040_config_check(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nreturn pcmcia_request_io(p_dev);\r\n}\r\nstatic int reader_config(struct pcmcia_device *link, int devno)\r\n{\r\nstruct reader_dev *dev;\r\nint fail_rc;\r\nlink->config_flags |= CONF_AUTO_SET_IO;\r\nif (pcmcia_loop_config(link, cm4040_config_check, NULL))\r\ngoto cs_release;\r\nfail_rc = pcmcia_enable_device(link);\r\nif (fail_rc != 0) {\r\ndev_printk(KERN_INFO, &link->dev,\r\n"pcmcia_enable_device failed 0x%x\n",\r\nfail_rc);\r\ngoto cs_release;\r\n}\r\ndev = link->priv;\r\nDEBUGP(2, dev, "device " DEVICE_NAME "%d at %pR\n", devno,\r\nlink->resource[0]);\r\nDEBUGP(2, dev, "<- reader_config (succ)\n");\r\nreturn 0;\r\ncs_release:\r\nreader_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic void reader_release(struct pcmcia_device *link)\r\n{\r\ncm4040_reader_release(link);\r\npcmcia_disable_device(link);\r\n}\r\nstatic int reader_probe(struct pcmcia_device *link)\r\n{\r\nstruct reader_dev *dev;\r\nint i, ret;\r\nfor (i = 0; i < CM_MAX_DEV; i++) {\r\nif (dev_table[i] == NULL)\r\nbreak;\r\n}\r\nif (i == CM_MAX_DEV)\r\nreturn -ENODEV;\r\ndev = kzalloc(sizeof(struct reader_dev), GFP_KERNEL);\r\nif (dev == NULL)\r\nreturn -ENOMEM;\r\ndev->timeout = CCID_DRIVER_MINIMUM_TIMEOUT;\r\ndev->buffer_status = 0;\r\nlink->priv = dev;\r\ndev->p_dev = link;\r\ndev_table[i] = link;\r\ninit_waitqueue_head(&dev->devq);\r\ninit_waitqueue_head(&dev->poll_wait);\r\ninit_waitqueue_head(&dev->read_wait);\r\ninit_waitqueue_head(&dev->write_wait);\r\nsetup_timer(&dev->poll_timer, cm4040_do_poll, 0);\r\nret = reader_config(link, i);\r\nif (ret) {\r\ndev_table[i] = NULL;\r\nkfree(dev);\r\nreturn ret;\r\n}\r\ndevice_create(cmx_class, NULL, MKDEV(major, i), NULL, "cmx%d", i);\r\nreturn 0;\r\n}\r\nstatic void reader_detach(struct pcmcia_device *link)\r\n{\r\nstruct reader_dev *dev = link->priv;\r\nint devno;\r\nfor (devno = 0; devno < CM_MAX_DEV; devno++) {\r\nif (dev_table[devno] == link)\r\nbreak;\r\n}\r\nif (devno == CM_MAX_DEV)\r\nreturn;\r\nreader_release(link);\r\ndev_table[devno] = NULL;\r\nkfree(dev);\r\ndevice_destroy(cmx_class, MKDEV(major, devno));\r\nreturn;\r\n}\r\nstatic int __init cm4040_init(void)\r\n{\r\nint rc;\r\ncmx_class = class_create(THIS_MODULE, "cardman_4040");\r\nif (IS_ERR(cmx_class))\r\nreturn PTR_ERR(cmx_class);\r\nmajor = register_chrdev(0, DEVICE_NAME, &reader_fops);\r\nif (major < 0) {\r\nprintk(KERN_WARNING MODULE_NAME\r\n": could not get major number\n");\r\nclass_destroy(cmx_class);\r\nreturn major;\r\n}\r\nrc = pcmcia_register_driver(&reader_driver);\r\nif (rc < 0) {\r\nunregister_chrdev(major, DEVICE_NAME);\r\nclass_destroy(cmx_class);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit cm4040_exit(void)\r\n{\r\npcmcia_unregister_driver(&reader_driver);\r\nunregister_chrdev(major, DEVICE_NAME);\r\nclass_destroy(cmx_class);\r\n}
