static void\r\ncommon_reg_setup(struct op_register_config *reg,\r\nstruct op_counter_config *ctr,\r\nstruct op_system_config *sys,\r\nint cbox1_ofs, int cbox2_ofs)\r\n{\r\nint i, ctl, reset, need_reset;\r\nctl = 0;\r\nfor (i = 0; i < 3; ++i) {\r\nunsigned long event = ctr[i].event;\r\nif (!ctr[i].enabled)\r\ncontinue;\r\nif (i == 2) {\r\nif (event == 0)\r\nevent = 12+48;\r\nelse if (event == 2+41)\r\nevent = 4+65;\r\n}\r\nif (event < 2)\r\nctl |= event << 31;\r\nelse if (event < 24)\r\n;\r\nelse if (event < 40)\r\nctl |= (event - 24) << 4;\r\nelse if (event < 48)\r\nctl |= (event - 40) << cbox1_ofs | 15 << 4;\r\nelse if (event < 64)\r\nctl |= event - 48;\r\nelse if (event < 72)\r\nctl |= (event - 64) << cbox2_ofs | 15;\r\n}\r\nreg->mux_select = ctl;\r\nctl = 0;\r\nctl |= !sys->enable_pal << 9;\r\nctl |= !sys->enable_kernel << 8;\r\nctl |= !sys->enable_user << 30;\r\nreg->proc_mode = ctl;\r\nctl = reset = need_reset = 0;\r\nfor (i = 0; i < 3; ++i) {\r\nunsigned long max, hilo, count = ctr[i].count;\r\nif (!ctr[i].enabled)\r\ncontinue;\r\nif (count <= 256)\r\ncount = 256, hilo = 3, max = 256;\r\nelse {\r\nmax = (i == 2 ? 16384 : 65536);\r\nhilo = 2;\r\nif (count > max)\r\ncount = max;\r\n}\r\nctr[i].count = count;\r\nctl |= hilo << (8 - i*2);\r\nreset |= (max - count) << (48 - 16*i);\r\nif (count != max)\r\nneed_reset |= 1 << i;\r\n}\r\nreg->freq = ctl;\r\nreg->reset_values = reset;\r\nreg->need_reset = need_reset;\r\n}\r\nstatic void\r\nev5_reg_setup(struct op_register_config *reg,\r\nstruct op_counter_config *ctr,\r\nstruct op_system_config *sys)\r\n{\r\ncommon_reg_setup(reg, ctr, sys, 19, 22);\r\n}\r\nstatic void\r\npca56_reg_setup(struct op_register_config *reg,\r\nstruct op_counter_config *ctr,\r\nstruct op_system_config *sys)\r\n{\r\ncommon_reg_setup(reg, ctr, sys, 8, 11);\r\n}\r\nstatic void\r\nev5_cpu_setup (void *x)\r\n{\r\nstruct op_register_config *reg = x;\r\nwrperfmon(2, reg->mux_select);\r\nwrperfmon(3, reg->proc_mode);\r\nwrperfmon(4, reg->freq);\r\nwrperfmon(6, reg->reset_values);\r\n}\r\nstatic void\r\nev5_reset_ctr(struct op_register_config *reg, unsigned long ctr)\r\n{\r\nunsigned long values, mask, not_pk, reset_values;\r\nmask = (ctr == 0 ? 0xfffful << 48\r\n: ctr == 1 ? 0xfffful << 32\r\n: 0x3fff << 16);\r\nnot_pk = 1 << 9 | 1 << 8;\r\nreset_values = reg->reset_values;\r\nif ((reg->proc_mode & not_pk) == not_pk) {\r\nvalues = wrperfmon(5, 0);\r\nvalues = (reset_values & mask) | (values & ~mask & -2);\r\nwrperfmon(6, values);\r\n} else {\r\nwrperfmon(0, -1);\r\nvalues = wrperfmon(5, 0);\r\nvalues = (reset_values & mask) | (values & ~mask & -2);\r\nwrperfmon(6, values);\r\nwrperfmon(1, reg->enable);\r\n}\r\n}\r\nstatic void\r\nev5_handle_interrupt(unsigned long which, struct pt_regs *regs,\r\nstruct op_counter_config *ctr)\r\n{\r\noprofile_add_sample(regs, which);\r\n}
