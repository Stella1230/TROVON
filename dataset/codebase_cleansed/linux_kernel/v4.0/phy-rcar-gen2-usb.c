static int __rcar_gen2_usbhs_phy_enable(void __iomem *base)\r\n{\r\nu32 val;\r\nint i;\r\nval = ioread32(base + USBHS_UGCTRL_REG);\r\nval &= ~USBHS_UGCTRL_PLLRESET;\r\niowrite32(val, base + USBHS_UGCTRL_REG);\r\nval = ioread16(base + USBHS_LPSTS_REG);\r\nval |= USBHS_LPSTS_SUSPM;\r\niowrite16(val, base + USBHS_LPSTS_REG);\r\nfor (i = 0; i < 20; i++) {\r\nval = ioread32(base + USBHS_UGSTS_REG);\r\nif ((val & USBHS_UGSTS_LOCK) == USBHS_UGSTS_LOCK) {\r\nval = ioread32(base + USBHS_UGCTRL_REG);\r\nval |= USBHS_UGCTRL_CONNECT;\r\niowrite32(val, base + USBHS_UGCTRL_REG);\r\nreturn 0;\r\n}\r\nudelay(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int __rcar_gen2_usbhs_phy_disable(void __iomem *base)\r\n{\r\nu32 val;\r\nval = ioread32(base + USBHS_UGCTRL_REG);\r\nval &= ~USBHS_UGCTRL_CONNECT;\r\niowrite32(val, base + USBHS_UGCTRL_REG);\r\nval = ioread16(base + USBHS_LPSTS_REG);\r\nval &= ~USBHS_LPSTS_SUSPM;\r\niowrite16(val, base + USBHS_LPSTS_REG);\r\nval = ioread32(base + USBHS_UGCTRL_REG);\r\nval |= USBHS_UGCTRL_PLLRESET;\r\niowrite32(val, base + USBHS_UGCTRL_REG);\r\nreturn 0;\r\n}\r\nstatic void __rcar_gen2_usb_phy_init(struct rcar_gen2_usb_phy_priv *priv)\r\n{\r\nu32 val;\r\nclk_prepare_enable(priv->clk);\r\nval = ioread32(priv->base + USBHS_UGCTRL2_REG);\r\nval &= ~(USBHS_UGCTRL2_USB0_HS | USBHS_UGCTRL2_USB2_SS);\r\nval |= priv->ugctrl2;\r\niowrite32(val, priv->base + USBHS_UGCTRL2_REG);\r\n}\r\nstatic void __rcar_gen2_usb_phy_shutdown(struct rcar_gen2_usb_phy_priv *priv)\r\n{\r\n__rcar_gen2_usbhs_phy_disable(priv->base);\r\nclk_disable_unprepare(priv->clk);\r\n}\r\nstatic int rcar_gen2_usb_phy_set_suspend(struct usb_phy *phy, int suspend)\r\n{\r\nstruct rcar_gen2_usb_phy_priv *priv = usb_phy_to_priv(phy);\r\nunsigned long flags;\r\nint retval;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nretval = suspend ? __rcar_gen2_usbhs_phy_disable(priv->base) :\r\n__rcar_gen2_usbhs_phy_enable(priv->base);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int rcar_gen2_usb_phy_init(struct usb_phy *phy)\r\n{\r\nstruct rcar_gen2_usb_phy_priv *priv = usb_phy_to_priv(phy);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (!priv->usecount++)\r\n__rcar_gen2_usb_phy_init(priv);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void rcar_gen2_usb_phy_shutdown(struct usb_phy *phy)\r\n{\r\nstruct rcar_gen2_usb_phy_priv *priv = usb_phy_to_priv(phy);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (!priv->usecount) {\r\ndev_warn(phy->dev, "Trying to disable phy with 0 usecount\n");\r\ngoto out;\r\n}\r\nif (!--priv->usecount)\r\n__rcar_gen2_usb_phy_shutdown(priv);\r\nout:\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic int rcar_gen2_usb_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct rcar_gen2_phy_platform_data *pdata;\r\nstruct rcar_gen2_usb_phy_priv *priv;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nstruct clk *clk;\r\nint retval;\r\npdata = dev_get_platdata(dev);\r\nif (!pdata) {\r\ndev_err(dev, "No platform data\n");\r\nreturn -EINVAL;\r\n}\r\nclk = devm_clk_get(dev, "usbhs");\r\nif (IS_ERR(clk)) {\r\ndev_err(dev, "Can't get the clock\n");\r\nreturn PTR_ERR(clk);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&priv->lock);\r\npriv->clk = clk;\r\npriv->base = base;\r\npriv->ugctrl2 = pdata->chan0_pci ?\r\nUSBHS_UGCTRL2_USB0_PCI : USBHS_UGCTRL2_USB0_HS;\r\npriv->ugctrl2 |= pdata->chan2_pci ?\r\nUSBHS_UGCTRL2_USB2_PCI : USBHS_UGCTRL2_USB2_SS;\r\npriv->phy.dev = dev;\r\npriv->phy.label = dev_name(dev);\r\npriv->phy.init = rcar_gen2_usb_phy_init;\r\npriv->phy.shutdown = rcar_gen2_usb_phy_shutdown;\r\npriv->phy.set_suspend = rcar_gen2_usb_phy_set_suspend;\r\nretval = usb_add_phy_dev(&priv->phy);\r\nif (retval < 0) {\r\ndev_err(dev, "Failed to add USB phy\n");\r\nreturn retval;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nreturn retval;\r\n}\r\nstatic int rcar_gen2_usb_phy_remove(struct platform_device *pdev)\r\n{\r\nstruct rcar_gen2_usb_phy_priv *priv = platform_get_drvdata(pdev);\r\nusb_remove_phy(&priv->phy);\r\nreturn 0;\r\n}
