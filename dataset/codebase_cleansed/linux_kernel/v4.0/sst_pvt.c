int sst_shim_write(void __iomem *addr, int offset, int value)\r\n{\r\nwritel(value, addr + offset);\r\nreturn 0;\r\n}\r\nu32 sst_shim_read(void __iomem *addr, int offset)\r\n{\r\nreturn readl(addr + offset);\r\n}\r\nu64 sst_reg_read64(void __iomem *addr, int offset)\r\n{\r\nu64 val = 0;\r\nmemcpy_fromio(&val, addr + offset, sizeof(val));\r\nreturn val;\r\n}\r\nint sst_shim_write64(void __iomem *addr, int offset, u64 value)\r\n{\r\nmemcpy_toio(addr + offset, &value, sizeof(value));\r\nreturn 0;\r\n}\r\nu64 sst_shim_read64(void __iomem *addr, int offset)\r\n{\r\nu64 val = 0;\r\nmemcpy_fromio(&val, addr + offset, sizeof(val));\r\nreturn val;\r\n}\r\nvoid sst_set_fw_state_locked(\r\nstruct intel_sst_drv *sst_drv_ctx, int sst_state)\r\n{\r\nmutex_lock(&sst_drv_ctx->sst_lock);\r\nsst_drv_ctx->sst_state = sst_state;\r\nmutex_unlock(&sst_drv_ctx->sst_lock);\r\n}\r\nint sst_wait_interruptible(struct intel_sst_drv *sst_drv_ctx,\r\nstruct sst_block *block)\r\n{\r\nint retval = 0;\r\nif (!wait_event_interruptible(sst_drv_ctx->wait_queue,\r\nblock->condition)) {\r\nif (block->ret_code < 0) {\r\ndev_err(sst_drv_ctx->dev,\r\n"stream failed %d\n", block->ret_code);\r\nretval = -EBUSY;\r\n} else {\r\ndev_dbg(sst_drv_ctx->dev, "event up\n");\r\nretval = 0;\r\n}\r\n} else {\r\ndev_err(sst_drv_ctx->dev, "signal interrupted\n");\r\nretval = -EINTR;\r\n}\r\nreturn retval;\r\n}\r\nunsigned long long read_shim_data(struct intel_sst_drv *sst, int addr)\r\n{\r\nunsigned long long val = 0;\r\nswitch (sst->dev_id) {\r\ncase SST_MRFLD_PCI_ID:\r\ncase SST_BYT_ACPI_ID:\r\nval = sst_shim_read64(sst->shim, addr);\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nvoid write_shim_data(struct intel_sst_drv *sst, int addr,\r\nunsigned long long data)\r\n{\r\nswitch (sst->dev_id) {\r\ncase SST_MRFLD_PCI_ID:\r\ncase SST_BYT_ACPI_ID:\r\nsst_shim_write64(sst->shim, addr, (u64) data);\r\nbreak;\r\n}\r\n}\r\nint sst_wait_timeout(struct intel_sst_drv *sst_drv_ctx, struct sst_block *block)\r\n{\r\nint retval = 0;\r\ndev_dbg(sst_drv_ctx->dev,\r\n"waiting for condition %x ipc %d drv_id %d\n",\r\nblock->condition, block->msg_id, block->drv_id);\r\nif (wait_event_timeout(sst_drv_ctx->wait_queue,\r\nblock->condition,\r\nmsecs_to_jiffies(SST_BLOCK_TIMEOUT))) {\r\ndev_dbg(sst_drv_ctx->dev, "Event wake %x\n",\r\nblock->condition);\r\ndev_dbg(sst_drv_ctx->dev, "message ret: %d\n",\r\nblock->ret_code);\r\nretval = -block->ret_code;\r\n} else {\r\nblock->on = false;\r\ndev_err(sst_drv_ctx->dev,\r\n"Wait timed-out condition:%#x, msg_id:%#x fw_state %#x\n",\r\nblock->condition, block->msg_id, sst_drv_ctx->sst_state);\r\nsst_drv_ctx->sst_state = SST_RESET;\r\nretval = -EBUSY;\r\n}\r\nreturn retval;\r\n}\r\nint sst_create_ipc_msg(struct ipc_post **arg, bool large)\r\n{\r\nstruct ipc_post *msg;\r\nmsg = kzalloc(sizeof(struct ipc_post), GFP_ATOMIC);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nif (large) {\r\nmsg->mailbox_data = kzalloc(SST_MAILBOX_SIZE, GFP_ATOMIC);\r\nif (!msg->mailbox_data) {\r\nkfree(msg);\r\nreturn -ENOMEM;\r\n}\r\n} else {\r\nmsg->mailbox_data = NULL;\r\n}\r\nmsg->is_large = large;\r\n*arg = msg;\r\nreturn 0;\r\n}\r\nint sst_create_block_and_ipc_msg(struct ipc_post **arg, bool large,\r\nstruct intel_sst_drv *sst_drv_ctx, struct sst_block **block,\r\nu32 msg_id, u32 drv_id)\r\n{\r\nint retval = 0;\r\nretval = sst_create_ipc_msg(arg, large);\r\nif (retval)\r\nreturn retval;\r\n*block = sst_create_block(sst_drv_ctx, msg_id, drv_id);\r\nif (*block == NULL) {\r\nkfree(*arg);\r\nreturn -ENOMEM;\r\n}\r\nreturn retval;\r\n}\r\nvoid sst_clean_stream(struct stream_info *stream)\r\n{\r\nstream->status = STREAM_UN_INIT;\r\nstream->prev = STREAM_UN_INIT;\r\nmutex_lock(&stream->lock);\r\nstream->cumm_bytes = 0;\r\nmutex_unlock(&stream->lock);\r\n}\r\nint sst_prepare_and_post_msg(struct intel_sst_drv *sst,\r\nint task_id, int ipc_msg, int cmd_id, int pipe_id,\r\nsize_t mbox_data_len, const void *mbox_data, void **data,\r\nbool large, bool fill_dsp, bool sync, bool response)\r\n{\r\nstruct ipc_post *msg = NULL;\r\nstruct ipc_dsp_hdr dsp_hdr;\r\nstruct sst_block *block;\r\nint ret = 0, pvt_id;\r\npvt_id = sst_assign_pvt_id(sst);\r\nif (pvt_id < 0)\r\nreturn pvt_id;\r\nif (response)\r\nret = sst_create_block_and_ipc_msg(\r\n&msg, large, sst, &block, ipc_msg, pvt_id);\r\nelse\r\nret = sst_create_ipc_msg(&msg, large);\r\nif (ret < 0) {\r\ntest_and_clear_bit(pvt_id, &sst->pvt_id);\r\nreturn -ENOMEM;\r\n}\r\ndev_dbg(sst->dev, "pvt_id = %d, pipe id = %d, task = %d ipc_msg: %d\n",\r\npvt_id, pipe_id, task_id, ipc_msg);\r\nsst_fill_header_mrfld(&msg->mrfld_header, ipc_msg,\r\ntask_id, large, pvt_id);\r\nmsg->mrfld_header.p.header_low_payload = sizeof(dsp_hdr) + mbox_data_len;\r\nmsg->mrfld_header.p.header_high.part.res_rqd = !sync;\r\ndev_dbg(sst->dev, "header:%x\n",\r\nmsg->mrfld_header.p.header_high.full);\r\ndev_dbg(sst->dev, "response rqd: %x",\r\nmsg->mrfld_header.p.header_high.part.res_rqd);\r\ndev_dbg(sst->dev, "msg->mrfld_header.p.header_low_payload:%d",\r\nmsg->mrfld_header.p.header_low_payload);\r\nif (fill_dsp) {\r\nsst_fill_header_dsp(&dsp_hdr, cmd_id, pipe_id, mbox_data_len);\r\nmemcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));\r\nif (mbox_data_len) {\r\nmemcpy(msg->mailbox_data + sizeof(dsp_hdr),\r\nmbox_data, mbox_data_len);\r\n}\r\n}\r\nif (sync)\r\nsst->ops->post_message(sst, msg, true);\r\nelse\r\nsst_add_to_dispatch_list_and_post(sst, msg);\r\nif (response) {\r\nret = sst_wait_timeout(sst, block);\r\nif (ret < 0) {\r\ngoto out;\r\n} else if(block->data) {\r\nif (!data)\r\ngoto out;\r\n*data = kzalloc(block->size, GFP_KERNEL);\r\nif (!(*data)) {\r\nret = -ENOMEM;\r\ngoto out;\r\n} else\r\nmemcpy(data, (void *) block->data, block->size);\r\n}\r\n}\r\nout:\r\nif (response)\r\nsst_free_block(sst, block);\r\ntest_and_clear_bit(pvt_id, &sst->pvt_id);\r\nreturn ret;\r\n}\r\nint sst_pm_runtime_put(struct intel_sst_drv *sst_drv)\r\n{\r\nint ret;\r\npm_runtime_mark_last_busy(sst_drv->dev);\r\nret = pm_runtime_put_autosuspend(sst_drv->dev);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nvoid sst_fill_header_mrfld(union ipc_header_mrfld *header,\r\nint msg, int task_id, int large, int drv_id)\r\n{\r\nheader->full = 0;\r\nheader->p.header_high.part.msg_id = msg;\r\nheader->p.header_high.part.task_id = task_id;\r\nheader->p.header_high.part.large = large;\r\nheader->p.header_high.part.drv_id = drv_id;\r\nheader->p.header_high.part.done = 0;\r\nheader->p.header_high.part.busy = 1;\r\nheader->p.header_high.part.res_rqd = 1;\r\n}\r\nvoid sst_fill_header_dsp(struct ipc_dsp_hdr *dsp, int msg,\r\nint pipe_id, int len)\r\n{\r\ndsp->cmd_id = msg;\r\ndsp->mod_index_id = 0xff;\r\ndsp->pipe_id = pipe_id;\r\ndsp->length = len;\r\ndsp->mod_id = 0;\r\n}\r\nint sst_assign_pvt_id(struct intel_sst_drv *drv)\r\n{\r\nint local;\r\nspin_lock(&drv->block_lock);\r\nlocal = ffz(drv->pvt_id);\r\ndev_dbg(drv->dev, "pvt_id assigned --> %d\n", local);\r\nif (local >= SST_MAX_BLOCKS){\r\nspin_unlock(&drv->block_lock);\r\ndev_err(drv->dev, "PVT _ID error: no free id blocks ");\r\nreturn -EINVAL;\r\n}\r\nchange_bit(local, &drv->pvt_id);\r\nspin_unlock(&drv->block_lock);\r\nreturn local;\r\n}\r\nvoid sst_init_stream(struct stream_info *stream,\r\nint codec, int sst_id, int ops, u8 slot)\r\n{\r\nstream->status = STREAM_INIT;\r\nstream->prev = STREAM_UN_INIT;\r\nstream->ops = ops;\r\n}\r\nint sst_validate_strid(\r\nstruct intel_sst_drv *sst_drv_ctx, int str_id)\r\n{\r\nif (str_id <= 0 || str_id > sst_drv_ctx->info.max_streams) {\r\ndev_err(sst_drv_ctx->dev,\r\n"SST ERR: invalid stream id : %d, max %d\n",\r\nstr_id, sst_drv_ctx->info.max_streams);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstruct stream_info *get_stream_info(\r\nstruct intel_sst_drv *sst_drv_ctx, int str_id)\r\n{\r\nif (sst_validate_strid(sst_drv_ctx, str_id))\r\nreturn NULL;\r\nreturn &sst_drv_ctx->streams[str_id];\r\n}\r\nint get_stream_id_mrfld(struct intel_sst_drv *sst_drv_ctx,\r\nu32 pipe_id)\r\n{\r\nint i;\r\nfor (i = 1; i <= sst_drv_ctx->info.max_streams; i++)\r\nif (pipe_id == sst_drv_ctx->streams[i].pipe_id)\r\nreturn i;\r\ndev_dbg(sst_drv_ctx->dev, "no such pipe_id(%u)", pipe_id);\r\nreturn -1;\r\n}\r\nu32 relocate_imr_addr_mrfld(u32 base_addr)\r\n{\r\nbase_addr = MRFLD_FW_VIRTUAL_BASE + (base_addr % (512 * 1024 * 1024));\r\nreturn base_addr;\r\n}\r\nvoid sst_add_to_dispatch_list_and_post(struct intel_sst_drv *sst,\r\nstruct ipc_post *msg)\r\n{\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&sst->ipc_spin_lock, irq_flags);\r\nlist_add_tail(&msg->node, &sst->ipc_dispatch_list);\r\nspin_unlock_irqrestore(&sst->ipc_spin_lock, irq_flags);\r\nsst->ops->post_message(sst, NULL, false);\r\n}
