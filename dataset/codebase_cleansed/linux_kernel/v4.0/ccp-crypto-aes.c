static int ccp_aes_complete(struct crypto_async_request *async_req, int ret)\r\n{\r\nstruct ablkcipher_request *req = ablkcipher_request_cast(async_req);\r\nstruct ccp_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\r\nstruct ccp_aes_req_ctx *rctx = ablkcipher_request_ctx(req);\r\nif (ret)\r\nreturn ret;\r\nif (ctx->u.aes.mode != CCP_AES_MODE_ECB)\r\nmemcpy(req->info, rctx->iv, AES_BLOCK_SIZE);\r\nreturn 0;\r\n}\r\nstatic int ccp_aes_setkey(struct crypto_ablkcipher *tfm, const u8 *key,\r\nunsigned int key_len)\r\n{\r\nstruct ccp_ctx *ctx = crypto_tfm_ctx(crypto_ablkcipher_tfm(tfm));\r\nstruct ccp_crypto_ablkcipher_alg *alg =\r\nccp_crypto_ablkcipher_alg(crypto_ablkcipher_tfm(tfm));\r\nswitch (key_len) {\r\ncase AES_KEYSIZE_128:\r\nctx->u.aes.type = CCP_AES_TYPE_128;\r\nbreak;\r\ncase AES_KEYSIZE_192:\r\nctx->u.aes.type = CCP_AES_TYPE_192;\r\nbreak;\r\ncase AES_KEYSIZE_256:\r\nctx->u.aes.type = CCP_AES_TYPE_256;\r\nbreak;\r\ndefault:\r\ncrypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nctx->u.aes.mode = alg->mode;\r\nctx->u.aes.key_len = key_len;\r\nmemcpy(ctx->u.aes.key, key, key_len);\r\nsg_init_one(&ctx->u.aes.key_sg, ctx->u.aes.key, key_len);\r\nreturn 0;\r\n}\r\nstatic int ccp_aes_crypt(struct ablkcipher_request *req, bool encrypt)\r\n{\r\nstruct ccp_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\r\nstruct ccp_aes_req_ctx *rctx = ablkcipher_request_ctx(req);\r\nstruct scatterlist *iv_sg = NULL;\r\nunsigned int iv_len = 0;\r\nint ret;\r\nif (!ctx->u.aes.key_len)\r\nreturn -EINVAL;\r\nif (((ctx->u.aes.mode == CCP_AES_MODE_ECB) ||\r\n(ctx->u.aes.mode == CCP_AES_MODE_CBC) ||\r\n(ctx->u.aes.mode == CCP_AES_MODE_CFB)) &&\r\n(req->nbytes & (AES_BLOCK_SIZE - 1)))\r\nreturn -EINVAL;\r\nif (ctx->u.aes.mode != CCP_AES_MODE_ECB) {\r\nif (!req->info)\r\nreturn -EINVAL;\r\nmemcpy(rctx->iv, req->info, AES_BLOCK_SIZE);\r\niv_sg = &rctx->iv_sg;\r\niv_len = AES_BLOCK_SIZE;\r\nsg_init_one(iv_sg, rctx->iv, iv_len);\r\n}\r\nmemset(&rctx->cmd, 0, sizeof(rctx->cmd));\r\nINIT_LIST_HEAD(&rctx->cmd.entry);\r\nrctx->cmd.engine = CCP_ENGINE_AES;\r\nrctx->cmd.u.aes.type = ctx->u.aes.type;\r\nrctx->cmd.u.aes.mode = ctx->u.aes.mode;\r\nrctx->cmd.u.aes.action =\r\n(encrypt) ? CCP_AES_ACTION_ENCRYPT : CCP_AES_ACTION_DECRYPT;\r\nrctx->cmd.u.aes.key = &ctx->u.aes.key_sg;\r\nrctx->cmd.u.aes.key_len = ctx->u.aes.key_len;\r\nrctx->cmd.u.aes.iv = iv_sg;\r\nrctx->cmd.u.aes.iv_len = iv_len;\r\nrctx->cmd.u.aes.src = req->src;\r\nrctx->cmd.u.aes.src_len = req->nbytes;\r\nrctx->cmd.u.aes.dst = req->dst;\r\nret = ccp_crypto_enqueue_request(&req->base, &rctx->cmd);\r\nreturn ret;\r\n}\r\nstatic int ccp_aes_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn ccp_aes_crypt(req, true);\r\n}\r\nstatic int ccp_aes_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn ccp_aes_crypt(req, false);\r\n}\r\nstatic int ccp_aes_cra_init(struct crypto_tfm *tfm)\r\n{\r\nstruct ccp_ctx *ctx = crypto_tfm_ctx(tfm);\r\nctx->complete = ccp_aes_complete;\r\nctx->u.aes.key_len = 0;\r\ntfm->crt_ablkcipher.reqsize = sizeof(struct ccp_aes_req_ctx);\r\nreturn 0;\r\n}\r\nstatic void ccp_aes_cra_exit(struct crypto_tfm *tfm)\r\n{\r\n}\r\nstatic int ccp_aes_rfc3686_complete(struct crypto_async_request *async_req,\r\nint ret)\r\n{\r\nstruct ablkcipher_request *req = ablkcipher_request_cast(async_req);\r\nstruct ccp_aes_req_ctx *rctx = ablkcipher_request_ctx(req);\r\nreq->info = rctx->rfc3686_info;\r\nreturn ccp_aes_complete(async_req, ret);\r\n}\r\nstatic int ccp_aes_rfc3686_setkey(struct crypto_ablkcipher *tfm, const u8 *key,\r\nunsigned int key_len)\r\n{\r\nstruct ccp_ctx *ctx = crypto_tfm_ctx(crypto_ablkcipher_tfm(tfm));\r\nif (key_len < CTR_RFC3686_NONCE_SIZE)\r\nreturn -EINVAL;\r\nkey_len -= CTR_RFC3686_NONCE_SIZE;\r\nmemcpy(ctx->u.aes.nonce, key + key_len, CTR_RFC3686_NONCE_SIZE);\r\nreturn ccp_aes_setkey(tfm, key, key_len);\r\n}\r\nstatic int ccp_aes_rfc3686_crypt(struct ablkcipher_request *req, bool encrypt)\r\n{\r\nstruct ccp_ctx *ctx = crypto_tfm_ctx(req->base.tfm);\r\nstruct ccp_aes_req_ctx *rctx = ablkcipher_request_ctx(req);\r\nu8 *iv;\r\niv = rctx->rfc3686_iv;\r\nmemcpy(iv, ctx->u.aes.nonce, CTR_RFC3686_NONCE_SIZE);\r\niv += CTR_RFC3686_NONCE_SIZE;\r\nmemcpy(iv, req->info, CTR_RFC3686_IV_SIZE);\r\niv += CTR_RFC3686_IV_SIZE;\r\n*(__be32 *)iv = cpu_to_be32(1);\r\nrctx->rfc3686_info = req->info;\r\nreq->info = rctx->rfc3686_iv;\r\nreturn ccp_aes_crypt(req, encrypt);\r\n}\r\nstatic int ccp_aes_rfc3686_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn ccp_aes_rfc3686_crypt(req, true);\r\n}\r\nstatic int ccp_aes_rfc3686_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn ccp_aes_rfc3686_crypt(req, false);\r\n}\r\nstatic int ccp_aes_rfc3686_cra_init(struct crypto_tfm *tfm)\r\n{\r\nstruct ccp_ctx *ctx = crypto_tfm_ctx(tfm);\r\nctx->complete = ccp_aes_rfc3686_complete;\r\nctx->u.aes.key_len = 0;\r\ntfm->crt_ablkcipher.reqsize = sizeof(struct ccp_aes_req_ctx);\r\nreturn 0;\r\n}\r\nstatic void ccp_aes_rfc3686_cra_exit(struct crypto_tfm *tfm)\r\n{\r\n}\r\nstatic int ccp_register_aes_alg(struct list_head *head,\r\nconst struct ccp_aes_def *def)\r\n{\r\nstruct ccp_crypto_ablkcipher_alg *ccp_alg;\r\nstruct crypto_alg *alg;\r\nint ret;\r\nccp_alg = kzalloc(sizeof(*ccp_alg), GFP_KERNEL);\r\nif (!ccp_alg)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&ccp_alg->entry);\r\nccp_alg->mode = def->mode;\r\nalg = &ccp_alg->alg;\r\n*alg = *def->alg_defaults;\r\nsnprintf(alg->cra_name, CRYPTO_MAX_ALG_NAME, "%s", def->name);\r\nsnprintf(alg->cra_driver_name, CRYPTO_MAX_ALG_NAME, "%s",\r\ndef->driver_name);\r\nalg->cra_blocksize = def->blocksize;\r\nalg->cra_ablkcipher.ivsize = def->ivsize;\r\nret = crypto_register_alg(alg);\r\nif (ret) {\r\npr_err("%s ablkcipher algorithm registration error (%d)\n",\r\nalg->cra_name, ret);\r\nkfree(ccp_alg);\r\nreturn ret;\r\n}\r\nlist_add(&ccp_alg->entry, head);\r\nreturn 0;\r\n}\r\nint ccp_register_aes_algs(struct list_head *head)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < ARRAY_SIZE(aes_algs); i++) {\r\nret = ccp_register_aes_alg(head, &aes_algs[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
