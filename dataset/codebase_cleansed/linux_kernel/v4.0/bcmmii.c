static int bcmgenet_mii_read(struct mii_bus *bus, int phy_id, int location)\r\n{\r\nint ret;\r\nstruct net_device *dev = bus->priv;\r\nstruct bcmgenet_priv *priv = netdev_priv(dev);\r\nu32 reg;\r\nbcmgenet_umac_writel(priv, (MDIO_RD | (phy_id << MDIO_PMD_SHIFT) |\r\n(location << MDIO_REG_SHIFT)), UMAC_MDIO_CMD);\r\nreg = bcmgenet_umac_readl(priv, UMAC_MDIO_CMD);\r\nreg |= MDIO_START_BUSY;\r\nbcmgenet_umac_writel(priv, reg, UMAC_MDIO_CMD);\r\nwait_event_timeout(priv->wq,\r\n!(bcmgenet_umac_readl(priv, UMAC_MDIO_CMD)\r\n& MDIO_START_BUSY),\r\nHZ / 100);\r\nret = bcmgenet_umac_readl(priv, UMAC_MDIO_CMD);\r\nif (ret & MDIO_READ_FAIL)\r\nreturn -EIO;\r\nreturn ret & 0xffff;\r\n}\r\nstatic int bcmgenet_mii_write(struct mii_bus *bus, int phy_id,\r\nint location, u16 val)\r\n{\r\nstruct net_device *dev = bus->priv;\r\nstruct bcmgenet_priv *priv = netdev_priv(dev);\r\nu32 reg;\r\nbcmgenet_umac_writel(priv, (MDIO_WR | (phy_id << MDIO_PMD_SHIFT) |\r\n(location << MDIO_REG_SHIFT) | (0xffff & val)),\r\nUMAC_MDIO_CMD);\r\nreg = bcmgenet_umac_readl(priv, UMAC_MDIO_CMD);\r\nreg |= MDIO_START_BUSY;\r\nbcmgenet_umac_writel(priv, reg, UMAC_MDIO_CMD);\r\nwait_event_timeout(priv->wq,\r\n!(bcmgenet_umac_readl(priv, UMAC_MDIO_CMD) &\r\nMDIO_START_BUSY),\r\nHZ / 100);\r\nreturn 0;\r\n}\r\nvoid bcmgenet_mii_setup(struct net_device *dev)\r\n{\r\nstruct bcmgenet_priv *priv = netdev_priv(dev);\r\nstruct phy_device *phydev = priv->phydev;\r\nu32 reg, cmd_bits = 0;\r\nbool status_changed = false;\r\nif (priv->old_link != phydev->link) {\r\nstatus_changed = true;\r\npriv->old_link = phydev->link;\r\n}\r\nif (phydev->link) {\r\nif (priv->old_speed != phydev->speed) {\r\nstatus_changed = true;\r\npriv->old_speed = phydev->speed;\r\n}\r\nif (priv->old_duplex != phydev->duplex) {\r\nstatus_changed = true;\r\npriv->old_duplex = phydev->duplex;\r\n}\r\nif (priv->old_pause != phydev->pause) {\r\nstatus_changed = true;\r\npriv->old_pause = phydev->pause;\r\n}\r\nif (!status_changed)\r\nreturn;\r\nif (phydev->speed == SPEED_1000)\r\ncmd_bits = UMAC_SPEED_1000;\r\nelse if (phydev->speed == SPEED_100)\r\ncmd_bits = UMAC_SPEED_100;\r\nelse\r\ncmd_bits = UMAC_SPEED_10;\r\ncmd_bits <<= CMD_SPEED_SHIFT;\r\nif (phydev->duplex != DUPLEX_FULL)\r\ncmd_bits |= CMD_HD_EN;\r\nif (!phydev->pause)\r\ncmd_bits |= CMD_RX_PAUSE_IGNORE | CMD_TX_PAUSE_IGNORE;\r\nreg = bcmgenet_ext_readl(priv, EXT_RGMII_OOB_CTRL);\r\nreg &= ~OOB_DISABLE;\r\nreg |= RGMII_LINK;\r\nbcmgenet_ext_writel(priv, reg, EXT_RGMII_OOB_CTRL);\r\nreg = bcmgenet_umac_readl(priv, UMAC_CMD);\r\nreg &= ~((CMD_SPEED_MASK << CMD_SPEED_SHIFT) |\r\nCMD_HD_EN |\r\nCMD_RX_PAUSE_IGNORE | CMD_TX_PAUSE_IGNORE);\r\nreg |= cmd_bits;\r\nbcmgenet_umac_writel(priv, reg, UMAC_CMD);\r\n} else {\r\nif (!status_changed)\r\nreturn;\r\nnetif_carrier_off(dev);\r\n}\r\nphy_print_status(phydev);\r\n}\r\nvoid bcmgenet_mii_reset(struct net_device *dev)\r\n{\r\nstruct bcmgenet_priv *priv = netdev_priv(dev);\r\nif (priv->phydev) {\r\nphy_init_hw(priv->phydev);\r\nphy_start_aneg(priv->phydev);\r\n}\r\n}\r\nstatic void bcmgenet_ephy_power_up(struct net_device *dev)\r\n{\r\nstruct bcmgenet_priv *priv = netdev_priv(dev);\r\nu32 reg = 0;\r\nif (!GENET_IS_V4(priv))\r\nreturn;\r\nreg = bcmgenet_ext_readl(priv, EXT_GPHY_CTRL);\r\nreg &= ~(EXT_CFG_IDDQ_BIAS | EXT_CFG_PWR_DOWN);\r\nreg |= EXT_GPHY_RESET;\r\nbcmgenet_ext_writel(priv, reg, EXT_GPHY_CTRL);\r\nmdelay(2);\r\nreg &= ~EXT_GPHY_RESET;\r\nbcmgenet_ext_writel(priv, reg, EXT_GPHY_CTRL);\r\nudelay(20);\r\n}\r\nstatic void bcmgenet_internal_phy_setup(struct net_device *dev)\r\n{\r\nstruct bcmgenet_priv *priv = netdev_priv(dev);\r\nu32 reg;\r\nbcmgenet_ephy_power_up(dev);\r\nreg = bcmgenet_ext_readl(priv, EXT_EXT_PWR_MGMT);\r\nreg |= EXT_PWR_DN_EN_LD;\r\nbcmgenet_ext_writel(priv, reg, EXT_EXT_PWR_MGMT);\r\nbcmgenet_mii_reset(dev);\r\n}\r\nstatic void bcmgenet_moca_phy_setup(struct bcmgenet_priv *priv)\r\n{\r\nu32 reg;\r\nreg = bcmgenet_sys_readl(priv, SYS_PORT_CTRL);\r\nreg |= LED_ACT_SOURCE_MAC;\r\nbcmgenet_sys_writel(priv, reg, SYS_PORT_CTRL);\r\n}\r\nint bcmgenet_mii_config(struct net_device *dev, bool init)\r\n{\r\nstruct bcmgenet_priv *priv = netdev_priv(dev);\r\nstruct phy_device *phydev = priv->phydev;\r\nstruct device *kdev = &priv->pdev->dev;\r\nconst char *phy_name = NULL;\r\nu32 id_mode_dis = 0;\r\nu32 port_ctrl;\r\nu32 reg;\r\npriv->ext_phy = !phy_is_internal(priv->phydev) &&\r\n(priv->phy_interface != PHY_INTERFACE_MODE_MOCA);\r\nif (phy_is_internal(priv->phydev))\r\npriv->phy_interface = PHY_INTERFACE_MODE_NA;\r\nswitch (priv->phy_interface) {\r\ncase PHY_INTERFACE_MODE_NA:\r\ncase PHY_INTERFACE_MODE_MOCA:\r\nif (GENET_IS_V4(priv))\r\nport_ctrl = PORT_MODE_INT_GPHY;\r\nelse\r\nport_ctrl = PORT_MODE_INT_EPHY;\r\nbcmgenet_sys_writel(priv, port_ctrl, SYS_PORT_CTRL);\r\nif (phy_is_internal(priv->phydev)) {\r\nphy_name = "internal PHY";\r\nbcmgenet_internal_phy_setup(dev);\r\n} else if (priv->phy_interface == PHY_INTERFACE_MODE_MOCA) {\r\nphy_name = "MoCA";\r\nbcmgenet_moca_phy_setup(priv);\r\n}\r\nbreak;\r\ncase PHY_INTERFACE_MODE_MII:\r\nphy_name = "external MII";\r\nphydev->supported &= PHY_BASIC_FEATURES;\r\nbcmgenet_sys_writel(priv,\r\nPORT_MODE_EXT_EPHY, SYS_PORT_CTRL);\r\nbreak;\r\ncase PHY_INTERFACE_MODE_REVMII:\r\nphy_name = "external RvMII";\r\nif ((priv->phydev->supported & PHY_BASIC_FEATURES) ==\r\nPHY_BASIC_FEATURES)\r\nport_ctrl = PORT_MODE_EXT_RVMII_25;\r\nelse\r\nport_ctrl = PORT_MODE_EXT_RVMII_50;\r\nbcmgenet_sys_writel(priv, port_ctrl, SYS_PORT_CTRL);\r\nbreak;\r\ncase PHY_INTERFACE_MODE_RGMII:\r\nid_mode_dis = BIT(16);\r\ncase PHY_INTERFACE_MODE_RGMII_TXID:\r\nif (id_mode_dis)\r\nphy_name = "external RGMII (no delay)";\r\nelse\r\nphy_name = "external RGMII (TX delay)";\r\nreg = bcmgenet_ext_readl(priv, EXT_RGMII_OOB_CTRL);\r\nreg |= RGMII_MODE_EN | id_mode_dis;\r\nbcmgenet_ext_writel(priv, reg, EXT_RGMII_OOB_CTRL);\r\nbcmgenet_sys_writel(priv,\r\nPORT_MODE_EXT_GPHY, SYS_PORT_CTRL);\r\nbreak;\r\ndefault:\r\ndev_err(kdev, "unknown phy mode: %d\n", priv->phy_interface);\r\nreturn -EINVAL;\r\n}\r\nif (init)\r\ndev_info(kdev, "configuring instance for %s\n", phy_name);\r\nreturn 0;\r\n}\r\nstatic int bcmgenet_mii_probe(struct net_device *dev)\r\n{\r\nstruct bcmgenet_priv *priv = netdev_priv(dev);\r\nstruct device_node *dn = priv->pdev->dev.of_node;\r\nstruct phy_device *phydev;\r\nu32 phy_flags;\r\nint ret;\r\nphy_flags = priv->gphy_rev;\r\npriv->old_link = -1;\r\npriv->old_speed = -1;\r\npriv->old_duplex = -1;\r\npriv->old_pause = -1;\r\nif (dn) {\r\nif (priv->phydev) {\r\npr_info("PHY already attached\n");\r\nreturn 0;\r\n}\r\nif (!priv->phy_dn && of_phy_is_fixed_link(dn)) {\r\nret = of_phy_register_fixed_link(dn);\r\nif (ret)\r\nreturn ret;\r\npriv->phy_dn = of_node_get(dn);\r\n}\r\nphydev = of_phy_connect(dev, priv->phy_dn, bcmgenet_mii_setup,\r\nphy_flags, priv->phy_interface);\r\nif (!phydev) {\r\npr_err("could not attach to PHY\n");\r\nreturn -ENODEV;\r\n}\r\n} else {\r\nphydev = priv->phydev;\r\nphydev->dev_flags = phy_flags;\r\nret = phy_connect_direct(dev, phydev, bcmgenet_mii_setup,\r\npriv->phy_interface);\r\nif (ret) {\r\npr_err("could not attach to PHY\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\npriv->phydev = phydev;\r\nret = bcmgenet_mii_config(dev, true);\r\nif (ret) {\r\nphy_disconnect(priv->phydev);\r\nreturn ret;\r\n}\r\nphydev->advertising = phydev->supported;\r\nif (phy_is_internal(priv->phydev))\r\npriv->mii_bus->irq[phydev->addr] = PHY_IGNORE_INTERRUPT;\r\nelse\r\npriv->mii_bus->irq[phydev->addr] = PHY_POLL;\r\npr_info("attached PHY at address %d [%s]\n",\r\nphydev->addr, phydev->drv->name);\r\nreturn 0;\r\n}\r\nstatic int bcmgenet_mii_alloc(struct bcmgenet_priv *priv)\r\n{\r\nstruct mii_bus *bus;\r\nif (priv->mii_bus)\r\nreturn 0;\r\npriv->mii_bus = mdiobus_alloc();\r\nif (!priv->mii_bus) {\r\npr_err("failed to allocate\n");\r\nreturn -ENOMEM;\r\n}\r\nbus = priv->mii_bus;\r\nbus->priv = priv->dev;\r\nbus->name = "bcmgenet MII bus";\r\nbus->parent = &priv->pdev->dev;\r\nbus->read = bcmgenet_mii_read;\r\nbus->write = bcmgenet_mii_write;\r\nsnprintf(bus->id, MII_BUS_ID_SIZE, "%s-%d",\r\npriv->pdev->name, priv->pdev->id);\r\nbus->irq = kcalloc(PHY_MAX_ADDR, sizeof(int), GFP_KERNEL);\r\nif (!bus->irq) {\r\nmdiobus_free(priv->mii_bus);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcmgenet_mii_of_init(struct bcmgenet_priv *priv)\r\n{\r\nstruct device_node *dn = priv->pdev->dev.of_node;\r\nstruct device *kdev = &priv->pdev->dev;\r\nstruct device_node *mdio_dn;\r\nchar *compat;\r\nint ret;\r\ncompat = kasprintf(GFP_KERNEL, "brcm,genet-mdio-v%d", priv->version);\r\nif (!compat)\r\nreturn -ENOMEM;\r\nmdio_dn = of_find_compatible_node(dn, NULL, compat);\r\nkfree(compat);\r\nif (!mdio_dn) {\r\ndev_err(kdev, "unable to find MDIO bus node\n");\r\nreturn -ENODEV;\r\n}\r\nret = of_mdiobus_register(priv->mii_bus, mdio_dn);\r\nif (ret) {\r\ndev_err(kdev, "failed to register MDIO bus\n");\r\nreturn ret;\r\n}\r\npriv->phy_dn = of_parse_phandle(dn, "phy-handle", 0);\r\npriv->phy_interface = of_get_phy_mode(dn);\r\nreturn 0;\r\n}\r\nstatic int bcmgenet_mii_pd_init(struct bcmgenet_priv *priv)\r\n{\r\nstruct device *kdev = &priv->pdev->dev;\r\nstruct bcmgenet_platform_data *pd = kdev->platform_data;\r\nstruct mii_bus *mdio = priv->mii_bus;\r\nstruct phy_device *phydev;\r\nint ret;\r\nif (pd->phy_interface != PHY_INTERFACE_MODE_MOCA && pd->mdio_enabled) {\r\nif (pd->phy_address >= 0 && pd->phy_address < PHY_MAX_ADDR)\r\nmdio->phy_mask = ~(1 << pd->phy_address);\r\nelse\r\nmdio->phy_mask = 0;\r\nret = mdiobus_register(mdio);\r\nif (ret) {\r\ndev_err(kdev, "failed to register MDIO bus\n");\r\nreturn ret;\r\n}\r\nif (pd->phy_address >= 0 && pd->phy_address < PHY_MAX_ADDR)\r\nphydev = mdio->phy_map[pd->phy_address];\r\nelse\r\nphydev = phy_find_first(mdio);\r\nif (!phydev) {\r\ndev_err(kdev, "failed to register PHY device\n");\r\nmdiobus_unregister(mdio);\r\nreturn -ENODEV;\r\n}\r\n} else {\r\nstruct fixed_phy_status fphy_status = {\r\n.link = 1,\r\n.speed = pd->phy_speed,\r\n.duplex = pd->phy_duplex,\r\n.pause = 0,\r\n.asym_pause = 0,\r\n};\r\nphydev = fixed_phy_register(PHY_POLL, &fphy_status, NULL);\r\nif (!phydev || IS_ERR(phydev)) {\r\ndev_err(kdev, "failed to register fixed PHY device\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\npriv->phydev = phydev;\r\npriv->phy_interface = pd->phy_interface;\r\nreturn 0;\r\n}\r\nstatic int bcmgenet_mii_bus_init(struct bcmgenet_priv *priv)\r\n{\r\nstruct device_node *dn = priv->pdev->dev.of_node;\r\nif (dn)\r\nreturn bcmgenet_mii_of_init(priv);\r\nelse\r\nreturn bcmgenet_mii_pd_init(priv);\r\n}\r\nint bcmgenet_mii_init(struct net_device *dev)\r\n{\r\nstruct bcmgenet_priv *priv = netdev_priv(dev);\r\nint ret;\r\nret = bcmgenet_mii_alloc(priv);\r\nif (ret)\r\nreturn ret;\r\nret = bcmgenet_mii_bus_init(priv);\r\nif (ret)\r\ngoto out_free;\r\nret = bcmgenet_mii_probe(dev);\r\nif (ret)\r\ngoto out;\r\nreturn 0;\r\nout:\r\nof_node_put(priv->phy_dn);\r\nmdiobus_unregister(priv->mii_bus);\r\nout_free:\r\nkfree(priv->mii_bus->irq);\r\nmdiobus_free(priv->mii_bus);\r\nreturn ret;\r\n}\r\nvoid bcmgenet_mii_exit(struct net_device *dev)\r\n{\r\nstruct bcmgenet_priv *priv = netdev_priv(dev);\r\nof_node_put(priv->phy_dn);\r\nmdiobus_unregister(priv->mii_bus);\r\nkfree(priv->mii_bus->irq);\r\nmdiobus_free(priv->mii_bus);\r\n}
