static void ipaq_micro_trigger_tx(struct ipaq_micro *micro)\r\n{\r\nstruct ipaq_micro_txdev *tx = &micro->tx;\r\nstruct ipaq_micro_msg *msg = micro->msg;\r\nint i, bp;\r\nu8 checksum;\r\nu32 val;\r\nbp = 0;\r\ntx->buf[bp++] = CHAR_SOF;\r\nchecksum = ((msg->id & 0x0f) << 4) | (msg->tx_len & 0x0f);\r\ntx->buf[bp++] = checksum;\r\nfor (i = 0; i < msg->tx_len; i++) {\r\ntx->buf[bp++] = msg->tx_data[i];\r\nchecksum += msg->tx_data[i];\r\n}\r\ntx->buf[bp++] = checksum;\r\ntx->len = bp;\r\ntx->index = 0;\r\nprint_hex_dump(KERN_DEBUG, "data: ", DUMP_PREFIX_OFFSET, 16, 1,\r\ntx->buf, tx->len, true);\r\nval = readl(micro->base + UTCR3);\r\nval |= UTCR3_TIE;\r\nwritel(val, micro->base + UTCR3);\r\n}\r\nint ipaq_micro_tx_msg(struct ipaq_micro *micro, struct ipaq_micro_msg *msg)\r\n{\r\nunsigned long flags;\r\ndev_dbg(micro->dev, "TX msg: %02x, %d bytes\n", msg->id, msg->tx_len);\r\nspin_lock_irqsave(&micro->lock, flags);\r\nif (micro->msg) {\r\nlist_add_tail(&msg->node, &micro->queue);\r\nspin_unlock_irqrestore(&micro->lock, flags);\r\nreturn 0;\r\n}\r\nmicro->msg = msg;\r\nipaq_micro_trigger_tx(micro);\r\nspin_unlock_irqrestore(&micro->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void micro_rx_msg(struct ipaq_micro *micro, u8 id, int len, u8 *data)\r\n{\r\nint i;\r\ndev_dbg(micro->dev, "RX msg: %02x, %d bytes\n", id, len);\r\nspin_lock(&micro->lock);\r\nswitch (id) {\r\ncase MSG_VERSION:\r\ncase MSG_EEPROM_READ:\r\ncase MSG_EEPROM_WRITE:\r\ncase MSG_BACKLIGHT:\r\ncase MSG_NOTIFY_LED:\r\ncase MSG_THERMAL_SENSOR:\r\ncase MSG_BATTERY:\r\nif (micro->msg && micro->msg->id == id) {\r\nstruct ipaq_micro_msg *msg = micro->msg;\r\nmemcpy(msg->rx_data, data, len);\r\nmsg->rx_len = len;\r\ncomplete(&micro->msg->ack);\r\nif (!list_empty(&micro->queue)) {\r\nmicro->msg = list_entry(micro->queue.next,\r\nstruct ipaq_micro_msg,\r\nnode);\r\nlist_del_init(&micro->msg->node);\r\nipaq_micro_trigger_tx(micro);\r\n} else\r\nmicro->msg = NULL;\r\ndev_dbg(micro->dev, "OK RX message 0x%02x\n", id);\r\n} else {\r\ndev_err(micro->dev,\r\n"out of band RX message 0x%02x\n", id);\r\nif (!micro->msg)\r\ndev_info(micro->dev, "no message queued\n");\r\nelse\r\ndev_info(micro->dev, "expected message %02x\n",\r\nmicro->msg->id);\r\n}\r\nbreak;\r\ncase MSG_KEYBOARD:\r\nif (micro->key)\r\nmicro->key(micro->key_data, len, data);\r\nelse\r\ndev_dbg(micro->dev, "key message ignored, no handle\n");\r\nbreak;\r\ncase MSG_TOUCHSCREEN:\r\nif (micro->ts)\r\nmicro->ts(micro->ts_data, len, data);\r\nelse\r\ndev_dbg(micro->dev, "touchscreen message ignored, no handle\n");\r\nbreak;\r\ndefault:\r\ndev_err(micro->dev,\r\n"unknown msg %d [%d] ", id, len);\r\nfor (i = 0; i < len; ++i)\r\npr_cont("0x%02x ", data[i]);\r\npr_cont("\n");\r\n}\r\nspin_unlock(&micro->lock);\r\n}\r\nstatic void micro_process_char(struct ipaq_micro *micro, u8 ch)\r\n{\r\nstruct ipaq_micro_rxdev *rx = &micro->rx;\r\nswitch (rx->state) {\r\ncase STATE_SOF:\r\nif (ch == CHAR_SOF)\r\nrx->state = STATE_ID;\r\nbreak;\r\ncase STATE_ID:\r\nrx->id = (ch & 0xf0) >> 4;\r\nrx->len = (ch & 0x0f);\r\nrx->index = 0;\r\nrx->chksum = ch;\r\nrx->state = (rx->len > 0) ? STATE_DATA : STATE_CHKSUM;\r\nbreak;\r\ncase STATE_DATA:\r\nrx->chksum += ch;\r\nrx->buf[rx->index] = ch;\r\nif (++rx->index == rx->len)\r\nrx->state = STATE_CHKSUM;\r\nbreak;\r\ncase STATE_CHKSUM:\r\nif (ch == rx->chksum)\r\nmicro_rx_msg(micro, rx->id, rx->len, rx->buf);\r\nrx->state = STATE_SOF;\r\nbreak;\r\n}\r\n}\r\nstatic void micro_rx_chars(struct ipaq_micro *micro)\r\n{\r\nu32 status, ch;\r\nwhile ((status = readl(micro->base + UTSR1)) & UTSR1_RNE) {\r\nch = readl(micro->base + UTDR);\r\nif (status & UTSR1_PRE)\r\ndev_err(micro->dev, "rx: parity error\n");\r\nelse if (status & UTSR1_FRE)\r\ndev_err(micro->dev, "rx: framing error\n");\r\nelse if (status & UTSR1_ROR)\r\ndev_err(micro->dev, "rx: overrun error\n");\r\nmicro_process_char(micro, ch);\r\n}\r\n}\r\nstatic void ipaq_micro_get_version(struct ipaq_micro *micro)\r\n{\r\nstruct ipaq_micro_msg msg = {\r\n.id = MSG_VERSION,\r\n};\r\nipaq_micro_tx_msg_sync(micro, &msg);\r\nif (msg.rx_len == 4) {\r\nmemcpy(micro->version, msg.rx_data, 4);\r\nmicro->version[4] = '\0';\r\n} else if (msg.rx_len == 9) {\r\nmemcpy(micro->version, msg.rx_data, 4);\r\nmicro->version[4] = '\0';\r\n} else {\r\ndev_err(micro->dev,\r\n"illegal version message %d bytes\n", msg.rx_len);\r\n}\r\n}\r\nstatic void ipaq_micro_eeprom_read(struct ipaq_micro *micro,\r\nu8 address, u8 len, u8 *data)\r\n{\r\nstruct ipaq_micro_msg msg = {\r\n.id = MSG_EEPROM_READ,\r\n};\r\nu8 i;\r\nfor (i = 0; i < len; i++) {\r\nmsg.tx_data[0] = address + i;\r\nmsg.tx_data[1] = 1;\r\nmsg.tx_len = 2;\r\nipaq_micro_tx_msg_sync(micro, &msg);\r\nmemcpy(data + (i * 2), msg.rx_data, 2);\r\n}\r\n}\r\nstatic char *ipaq_micro_str(u8 *wchar, u8 len)\r\n{\r\nchar retstr[256];\r\nu8 i;\r\nfor (i = 0; i < len / 2; i++)\r\nretstr[i] = wchar[i * 2];\r\nreturn kstrdup(retstr, GFP_KERNEL);\r\n}\r\nstatic u16 ipaq_micro_to_u16(u8 *data)\r\n{\r\nreturn data[1] << 8 | data[0];\r\n}\r\nstatic void ipaq_micro_eeprom_dump(struct ipaq_micro *micro)\r\n{\r\nu8 dump[256];\r\nchar *str;\r\nipaq_micro_eeprom_read(micro, 0, 128, dump);\r\nstr = ipaq_micro_str(dump, 10);\r\nif (str) {\r\ndev_info(micro->dev, "HM version %s\n", str);\r\nkfree(str);\r\n}\r\nstr = ipaq_micro_str(dump+10, 40);\r\nif (str) {\r\ndev_info(micro->dev, "serial number: %s\n", str);\r\nadd_device_randomness(str, strlen(str));\r\nkfree(str);\r\n}\r\nstr = ipaq_micro_str(dump+50, 20);\r\nif (str) {\r\ndev_info(micro->dev, "module ID: %s\n", str);\r\nkfree(str);\r\n}\r\nstr = ipaq_micro_str(dump+70, 10);\r\nif (str) {\r\ndev_info(micro->dev, "product revision: %s\n", str);\r\nkfree(str);\r\n}\r\ndev_info(micro->dev, "product ID: %u\n", ipaq_micro_to_u16(dump+80));\r\ndev_info(micro->dev, "frame rate: %u fps\n",\r\nipaq_micro_to_u16(dump+82));\r\ndev_info(micro->dev, "page mode: %u\n", ipaq_micro_to_u16(dump+84));\r\ndev_info(micro->dev, "country ID: %u\n", ipaq_micro_to_u16(dump+86));\r\ndev_info(micro->dev, "color display: %s\n",\r\nipaq_micro_to_u16(dump+88) ? "yes" : "no");\r\ndev_info(micro->dev, "ROM size: %u MiB\n", ipaq_micro_to_u16(dump+90));\r\ndev_info(micro->dev, "RAM size: %u KiB\n", ipaq_micro_to_u16(dump+92));\r\ndev_info(micro->dev, "screen: %u x %u\n",\r\nipaq_micro_to_u16(dump+94), ipaq_micro_to_u16(dump+96));\r\nprint_hex_dump(KERN_DEBUG, "eeprom: ", DUMP_PREFIX_OFFSET, 16, 1,\r\ndump, 256, true);\r\n}\r\nstatic void micro_tx_chars(struct ipaq_micro *micro)\r\n{\r\nstruct ipaq_micro_txdev *tx = &micro->tx;\r\nu32 val;\r\nwhile ((tx->index < tx->len) &&\r\n(readl(micro->base + UTSR1) & UTSR1_TNF)) {\r\nwritel(tx->buf[tx->index], micro->base + UTDR);\r\ntx->index++;\r\n}\r\nval = readl(micro->base + UTCR3);\r\nval &= ~UTCR3_TIE;\r\nwritel(val, micro->base + UTCR3);\r\n}\r\nstatic void micro_reset_comm(struct ipaq_micro *micro)\r\n{\r\nstruct ipaq_micro_rxdev *rx = &micro->rx;\r\nu32 val;\r\nif (micro->msg)\r\ncomplete(&micro->msg->ack);\r\nrx->state = STATE_SOF;\r\nwritel(0x01, micro->sdlc + 0x0);\r\nwritel(0x0, micro->base + UTCR3);\r\nwritel(UTCR0_8BitData | UTCR0_1StpBit, micro->base + UTCR0);\r\nwritel(0x0, micro->base + UTCR1);\r\nwritel(0x1, micro->base + UTCR2);\r\nwritel(0xff, micro->base + UTSR0);\r\nwritel(UTCR3_TXE | UTCR3_RXE | UTCR3_RIE, micro->base + UTCR3);\r\nval = readl(micro->base + UTCR3);\r\nval &= ~UTCR3_TIE;\r\nwritel(val, micro->base + UTCR3);\r\n}\r\nstatic irqreturn_t micro_serial_isr(int irq, void *dev_id)\r\n{\r\nstruct ipaq_micro *micro = dev_id;\r\nstruct ipaq_micro_txdev *tx = &micro->tx;\r\nu32 status;\r\nstatus = readl(micro->base + UTSR0);\r\ndo {\r\nif (status & (UTSR0_RID | UTSR0_RFS)) {\r\nif (status & UTSR0_RID)\r\nwritel(UTSR0_RID, micro->base + UTSR0);\r\nmicro_rx_chars(micro);\r\n}\r\nif (status & (UTSR0_RBB | UTSR0_REB))\r\nwritel(status & (UTSR0_RBB | UTSR0_REB),\r\nmicro->base + UTSR0);\r\nif (status & UTSR0_TFS)\r\nmicro_tx_chars(micro);\r\nstatus = readl(micro->base + UTSR0);\r\n} while (((tx->index < tx->len) && (status & UTSR0_TFS)) ||\r\n(status & (UTSR0_RFS | UTSR0_RID)));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int micro_resume(struct device *dev)\r\n{\r\nstruct ipaq_micro *micro = dev_get_drvdata(dev);\r\nmicro_reset_comm(micro);\r\nmdelay(10);\r\nreturn 0;\r\n}\r\nstatic int micro_probe(struct platform_device *pdev)\r\n{\r\nstruct ipaq_micro *micro;\r\nstruct resource *res;\r\nint ret;\r\nint irq;\r\nmicro = devm_kzalloc(&pdev->dev, sizeof(*micro), GFP_KERNEL);\r\nif (!micro)\r\nreturn -ENOMEM;\r\nmicro->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -EINVAL;\r\nmicro->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(micro->base))\r\nreturn PTR_ERR(micro->base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!res)\r\nreturn -EINVAL;\r\nmicro->sdlc = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(micro->sdlc))\r\nreturn PTR_ERR(micro->sdlc);\r\nmicro_reset_comm(micro);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!irq)\r\nreturn -EINVAL;\r\nret = devm_request_irq(&pdev->dev, irq, micro_serial_isr,\r\nIRQF_SHARED, "ipaq-micro",\r\nmicro);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to grab serial port IRQ\n");\r\nreturn ret;\r\n} else\r\ndev_info(&pdev->dev, "grabbed serial port IRQ\n");\r\nspin_lock_init(&micro->lock);\r\nINIT_LIST_HEAD(&micro->queue);\r\nplatform_set_drvdata(pdev, micro);\r\nret = mfd_add_devices(&pdev->dev, pdev->id, micro_cells,\r\nARRAY_SIZE(micro_cells), NULL, 0, NULL);\r\nif (ret) {\r\ndev_err(&pdev->dev, "error adding MFD cells");\r\nreturn ret;\r\n}\r\nipaq_micro_get_version(micro);\r\ndev_info(&pdev->dev, "Atmel micro ASIC version %s\n", micro->version);\r\nipaq_micro_eeprom_dump(micro);\r\nreturn 0;\r\n}\r\nstatic int micro_remove(struct platform_device *pdev)\r\n{\r\nstruct ipaq_micro *micro = platform_get_drvdata(pdev);\r\nu32 val;\r\nmfd_remove_devices(&pdev->dev);\r\nval = readl(micro->base + UTCR3);\r\nval &= ~(UTCR3_RXE | UTCR3_RIE);\r\nval &= ~(UTCR3_TXE | UTCR3_TIE);\r\nwritel(val, micro->base + UTCR3);\r\nreturn 0;\r\n}
