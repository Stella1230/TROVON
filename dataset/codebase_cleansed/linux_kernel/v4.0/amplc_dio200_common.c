static unsigned char clk_gat_sce(unsigned int which, unsigned int chan,\r\nunsigned int source)\r\n{\r\nreturn (which << 5) | (chan << 3) |\r\n((source & 030) << 3) | (source & 007);\r\n}\r\nstatic unsigned char clk_sce(unsigned int which, unsigned int chan,\r\nunsigned int source)\r\n{\r\nreturn clk_gat_sce(which, chan, source);\r\n}\r\nstatic unsigned char gat_sce(unsigned int which, unsigned int chan,\r\nunsigned int source)\r\n{\r\nreturn clk_gat_sce(which, chan, source);\r\n}\r\nstatic unsigned char dio200_read8(struct comedi_device *dev,\r\nunsigned int offset)\r\n{\r\nconst struct dio200_board *board = dev->board_ptr;\r\nif (board->is_pcie)\r\noffset <<= 3;\r\nif (dev->mmio)\r\nreturn readb(dev->mmio + offset);\r\nreturn inb(dev->iobase + offset);\r\n}\r\nstatic void dio200_write8(struct comedi_device *dev,\r\nunsigned int offset, unsigned char val)\r\n{\r\nconst struct dio200_board *board = dev->board_ptr;\r\nif (board->is_pcie)\r\noffset <<= 3;\r\nif (dev->mmio)\r\nwriteb(val, dev->mmio + offset);\r\nelse\r\noutb(val, dev->iobase + offset);\r\n}\r\nstatic unsigned int dio200_read32(struct comedi_device *dev,\r\nunsigned int offset)\r\n{\r\nconst struct dio200_board *board = dev->board_ptr;\r\nif (board->is_pcie)\r\noffset <<= 3;\r\nif (dev->mmio)\r\nreturn readl(dev->mmio + offset);\r\nreturn inl(dev->iobase + offset);\r\n}\r\nstatic void dio200_write32(struct comedi_device *dev,\r\nunsigned int offset, unsigned int val)\r\n{\r\nconst struct dio200_board *board = dev->board_ptr;\r\nif (board->is_pcie)\r\noffset <<= 3;\r\nif (dev->mmio)\r\nwritel(val, dev->mmio + offset);\r\nelse\r\noutl(val, dev->iobase + offset);\r\n}\r\nstatic int dio200_subdev_intr_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nconst struct dio200_board *board = dev->board_ptr;\r\nstruct dio200_subdev_intr *subpriv = s->private;\r\nif (board->has_int_sce) {\r\ndata[1] = dio200_read8(dev, subpriv->ofs) & subpriv->valid_isns;\r\n} else {\r\ndata[0] = 0;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic void dio200_stop_intr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nconst struct dio200_board *board = dev->board_ptr;\r\nstruct dio200_subdev_intr *subpriv = s->private;\r\nsubpriv->active = false;\r\nsubpriv->enabled_isns = 0;\r\nif (board->has_int_sce)\r\ndio200_write8(dev, subpriv->ofs, 0);\r\n}\r\nstatic void dio200_start_intr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nconst struct dio200_board *board = dev->board_ptr;\r\nstruct dio200_subdev_intr *subpriv = s->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int n;\r\nunsigned isn_bits;\r\nisn_bits = 0;\r\nif (cmd->chanlist) {\r\nfor (n = 0; n < cmd->chanlist_len; n++)\r\nisn_bits |= (1U << CR_CHAN(cmd->chanlist[n]));\r\n}\r\nisn_bits &= subpriv->valid_isns;\r\nsubpriv->enabled_isns = isn_bits;\r\nif (board->has_int_sce)\r\ndio200_write8(dev, subpriv->ofs, isn_bits);\r\n}\r\nstatic int dio200_inttrig_start_intr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct dio200_subdev_intr *subpriv = s->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned long flags;\r\nif (trig_num != cmd->start_arg)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&subpriv->spinlock, flags);\r\ns->async->inttrig = NULL;\r\nif (subpriv->active)\r\ndio200_start_intr(dev, s);\r\nspin_unlock_irqrestore(&subpriv->spinlock, flags);\r\nreturn 1;\r\n}\r\nstatic void dio200_read_scan_intr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int triggered)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned short val;\r\nunsigned int n, ch;\r\nval = 0;\r\nfor (n = 0; n < cmd->chanlist_len; n++) {\r\nch = CR_CHAN(cmd->chanlist[n]);\r\nif (triggered & (1U << ch))\r\nval |= (1U << n);\r\n}\r\ncomedi_buf_write_samples(s, &val, 1);\r\nif (cmd->stop_src == TRIG_COUNT &&\r\ns->async->scans_done >= cmd->stop_arg)\r\ns->async->events |= COMEDI_CB_EOA;\r\n}\r\nstatic int dio200_handle_read_intr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nconst struct dio200_board *board = dev->board_ptr;\r\nstruct dio200_subdev_intr *subpriv = s->private;\r\nunsigned triggered;\r\nunsigned intstat;\r\nunsigned cur_enabled;\r\nunsigned long flags;\r\ntriggered = 0;\r\nspin_lock_irqsave(&subpriv->spinlock, flags);\r\nif (board->has_int_sce) {\r\ncur_enabled = subpriv->enabled_isns;\r\nwhile ((intstat = (dio200_read8(dev, subpriv->ofs) &\r\nsubpriv->valid_isns & ~triggered)) != 0) {\r\ntriggered |= intstat;\r\ncur_enabled &= ~triggered;\r\ndio200_write8(dev, subpriv->ofs, cur_enabled);\r\n}\r\n} else {\r\ntriggered = subpriv->enabled_isns;\r\n}\r\nif (triggered) {\r\ncur_enabled = subpriv->enabled_isns;\r\nif (board->has_int_sce)\r\ndio200_write8(dev, subpriv->ofs, cur_enabled);\r\nif (subpriv->active) {\r\nif (triggered & subpriv->enabled_isns)\r\ndio200_read_scan_intr(dev, s, triggered);\r\n}\r\n}\r\nspin_unlock_irqrestore(&subpriv->spinlock, flags);\r\ncomedi_handle_events(dev, s);\r\nreturn (triggered != 0);\r\n}\r\nstatic int dio200_subdev_intr_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct dio200_subdev_intr *subpriv = s->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&subpriv->spinlock, flags);\r\nif (subpriv->active)\r\ndio200_stop_intr(dev, s);\r\nspin_unlock_irqrestore(&subpriv->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int dio200_subdev_intr_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nerr |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_INT);\r\nerr |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);\r\nerr |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= cfc_check_trigger_is_unique(cmd->start_src);\r\nerr |= cfc_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nreturn 0;\r\n}\r\nstatic int dio200_subdev_intr_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nstruct dio200_subdev_intr *subpriv = s->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&subpriv->spinlock, flags);\r\nsubpriv->active = true;\r\nif (cmd->start_src == TRIG_INT)\r\ns->async->inttrig = dio200_inttrig_start_intr;\r\nelse\r\ndio200_start_intr(dev, s);\r\nspin_unlock_irqrestore(&subpriv->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int dio200_subdev_intr_init(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int offset,\r\nunsigned valid_isns)\r\n{\r\nconst struct dio200_board *board = dev->board_ptr;\r\nstruct dio200_subdev_intr *subpriv;\r\nsubpriv = comedi_alloc_spriv(s, sizeof(*subpriv));\r\nif (!subpriv)\r\nreturn -ENOMEM;\r\nsubpriv->ofs = offset;\r\nsubpriv->valid_isns = valid_isns;\r\nspin_lock_init(&subpriv->spinlock);\r\nif (board->has_int_sce)\r\ndio200_write8(dev, subpriv->ofs, 0);\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE | SDF_CMD_READ | SDF_PACKED;\r\nif (board->has_int_sce) {\r\ns->n_chan = DIO200_MAX_ISNS;\r\ns->len_chanlist = DIO200_MAX_ISNS;\r\n} else {\r\ns->n_chan = 1;\r\ns->len_chanlist = 1;\r\n}\r\ns->range_table = &range_digital;\r\ns->maxdata = 1;\r\ns->insn_bits = dio200_subdev_intr_insn_bits;\r\ns->do_cmdtest = dio200_subdev_intr_cmdtest;\r\ns->do_cmd = dio200_subdev_intr_cmd;\r\ns->cancel = dio200_subdev_intr_cancel;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t dio200_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nint handled;\r\nif (!dev->attached)\r\nreturn IRQ_NONE;\r\nhandled = dio200_handle_read_intr(dev, s);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic unsigned int dio200_subdev_8254_read_chan(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chan)\r\n{\r\nstruct dio200_subdev_8254 *subpriv = s->private;\r\nunsigned int val;\r\nval = chan << 6;\r\ndio200_write8(dev, subpriv->ofs + i8254_control_reg, val);\r\nval = dio200_read8(dev, subpriv->ofs + chan);\r\nval += dio200_read8(dev, subpriv->ofs + chan) << 8;\r\nreturn val;\r\n}\r\nstatic void dio200_subdev_8254_write_chan(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chan,\r\nunsigned int count)\r\n{\r\nstruct dio200_subdev_8254 *subpriv = s->private;\r\ndio200_write8(dev, subpriv->ofs + chan, count & 0xff);\r\ndio200_write8(dev, subpriv->ofs + chan, (count >> 8) & 0xff);\r\n}\r\nstatic void dio200_subdev_8254_set_mode(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chan,\r\nunsigned int mode)\r\n{\r\nstruct dio200_subdev_8254 *subpriv = s->private;\r\nunsigned int byte;\r\nbyte = chan << 6;\r\nbyte |= 0x30;\r\nbyte |= (mode & 0xf);\r\ndio200_write8(dev, subpriv->ofs + i8254_control_reg, byte);\r\n}\r\nstatic unsigned int dio200_subdev_8254_status(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chan)\r\n{\r\nstruct dio200_subdev_8254 *subpriv = s->private;\r\ndio200_write8(dev, subpriv->ofs + i8254_control_reg,\r\n0xe0 | (2 << chan));\r\nreturn dio200_read8(dev, subpriv->ofs + chan);\r\n}\r\nstatic int dio200_subdev_8254_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct dio200_subdev_8254 *subpriv = s->private;\r\nint chan = CR_CHAN(insn->chanspec);\r\nunsigned int n;\r\nunsigned long flags;\r\nfor (n = 0; n < insn->n; n++) {\r\nspin_lock_irqsave(&subpriv->spinlock, flags);\r\ndata[n] = dio200_subdev_8254_read_chan(dev, s, chan);\r\nspin_unlock_irqrestore(&subpriv->spinlock, flags);\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int dio200_subdev_8254_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct dio200_subdev_8254 *subpriv = s->private;\r\nint chan = CR_CHAN(insn->chanspec);\r\nunsigned int n;\r\nunsigned long flags;\r\nfor (n = 0; n < insn->n; n++) {\r\nspin_lock_irqsave(&subpriv->spinlock, flags);\r\ndio200_subdev_8254_write_chan(dev, s, chan, data[n]);\r\nspin_unlock_irqrestore(&subpriv->spinlock, flags);\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int dio200_subdev_8254_set_gate_src(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int counter_number,\r\nunsigned int gate_src)\r\n{\r\nconst struct dio200_board *board = dev->board_ptr;\r\nstruct dio200_subdev_8254 *subpriv = s->private;\r\nunsigned char byte;\r\nif (!board->has_clk_gat_sce)\r\nreturn -1;\r\nif (counter_number > 2)\r\nreturn -1;\r\nif (gate_src > (board->is_pcie ? 31 : 7))\r\nreturn -1;\r\nsubpriv->gate_src[counter_number] = gate_src;\r\nbyte = gat_sce(subpriv->which, counter_number, gate_src);\r\ndio200_write8(dev, subpriv->gat_sce_ofs, byte);\r\nreturn 0;\r\n}\r\nstatic int dio200_subdev_8254_get_gate_src(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int counter_number)\r\n{\r\nconst struct dio200_board *board = dev->board_ptr;\r\nstruct dio200_subdev_8254 *subpriv = s->private;\r\nif (!board->has_clk_gat_sce)\r\nreturn -1;\r\nif (counter_number > 2)\r\nreturn -1;\r\nreturn subpriv->gate_src[counter_number];\r\n}\r\nstatic int dio200_subdev_8254_set_clock_src(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int counter_number,\r\nunsigned int clock_src)\r\n{\r\nconst struct dio200_board *board = dev->board_ptr;\r\nstruct dio200_subdev_8254 *subpriv = s->private;\r\nunsigned char byte;\r\nif (!board->has_clk_gat_sce)\r\nreturn -1;\r\nif (counter_number > 2)\r\nreturn -1;\r\nif (clock_src > (board->is_pcie ? 31 : 7))\r\nreturn -1;\r\nsubpriv->clock_src[counter_number] = clock_src;\r\nbyte = clk_sce(subpriv->which, counter_number, clock_src);\r\ndio200_write8(dev, subpriv->clk_sce_ofs, byte);\r\nreturn 0;\r\n}\r\nstatic int dio200_subdev_8254_get_clock_src(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int counter_number,\r\nunsigned int *period_ns)\r\n{\r\nconst struct dio200_board *board = dev->board_ptr;\r\nstruct dio200_subdev_8254 *subpriv = s->private;\r\nunsigned clock_src;\r\nif (!board->has_clk_gat_sce)\r\nreturn -1;\r\nif (counter_number > 2)\r\nreturn -1;\r\nclock_src = subpriv->clock_src[counter_number];\r\n*period_ns = clock_period[clock_src];\r\nreturn clock_src;\r\n}\r\nstatic int dio200_subdev_8254_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct dio200_subdev_8254 *subpriv = s->private;\r\nint ret = 0;\r\nint chan = CR_CHAN(insn->chanspec);\r\nunsigned long flags;\r\nspin_lock_irqsave(&subpriv->spinlock, flags);\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_SET_COUNTER_MODE:\r\nif (data[1] > (I8254_MODE5 | I8254_BCD))\r\nret = -EINVAL;\r\nelse\r\ndio200_subdev_8254_set_mode(dev, s, chan, data[1]);\r\nbreak;\r\ncase INSN_CONFIG_8254_READ_STATUS:\r\ndata[1] = dio200_subdev_8254_status(dev, s, chan);\r\nbreak;\r\ncase INSN_CONFIG_SET_GATE_SRC:\r\nret = dio200_subdev_8254_set_gate_src(dev, s, chan, data[2]);\r\nif (ret < 0)\r\nret = -EINVAL;\r\nbreak;\r\ncase INSN_CONFIG_GET_GATE_SRC:\r\nret = dio200_subdev_8254_get_gate_src(dev, s, chan);\r\nif (ret < 0) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndata[2] = ret;\r\nbreak;\r\ncase INSN_CONFIG_SET_CLOCK_SRC:\r\nret = dio200_subdev_8254_set_clock_src(dev, s, chan, data[1]);\r\nif (ret < 0)\r\nret = -EINVAL;\r\nbreak;\r\ncase INSN_CONFIG_GET_CLOCK_SRC:\r\nret = dio200_subdev_8254_get_clock_src(dev, s, chan, &data[2]);\r\nif (ret < 0) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ndata[1] = ret;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&subpriv->spinlock, flags);\r\nreturn ret < 0 ? ret : insn->n;\r\n}\r\nstatic int dio200_subdev_8254_init(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int offset)\r\n{\r\nconst struct dio200_board *board = dev->board_ptr;\r\nstruct dio200_subdev_8254 *subpriv;\r\nunsigned int chan;\r\nsubpriv = comedi_alloc_spriv(s, sizeof(*subpriv));\r\nif (!subpriv)\r\nreturn -ENOMEM;\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = 3;\r\ns->maxdata = 0xFFFF;\r\ns->insn_read = dio200_subdev_8254_read;\r\ns->insn_write = dio200_subdev_8254_write;\r\ns->insn_config = dio200_subdev_8254_config;\r\nspin_lock_init(&subpriv->spinlock);\r\nsubpriv->ofs = offset;\r\nif (board->has_clk_gat_sce) {\r\nsubpriv->clk_sce_ofs = DIO200_XCLK_SCE + (offset >> 3);\r\nsubpriv->gat_sce_ofs = DIO200_XGAT_SCE + (offset >> 3);\r\nsubpriv->which = (offset >> 2) & 1;\r\n}\r\nfor (chan = 0; chan < 3; chan++) {\r\ndio200_subdev_8254_set_mode(dev, s, chan,\r\nI8254_MODE0 | I8254_BINARY);\r\nif (board->has_clk_gat_sce) {\r\ndio200_subdev_8254_set_gate_src(dev, s, chan, 0);\r\ndio200_subdev_8254_set_clock_src(dev, s, chan, 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void dio200_subdev_8255_set_dir(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct dio200_subdev_8255 *subpriv = s->private;\r\nint config;\r\nconfig = I8255_CTRL_CW;\r\nif (!(s->io_bits & 0x0000ff))\r\nconfig |= I8255_CTRL_A_IO;\r\nif (!(s->io_bits & 0x00ff00))\r\nconfig |= I8255_CTRL_B_IO;\r\nif (!(s->io_bits & 0x0f0000))\r\nconfig |= I8255_CTRL_C_LO_IO;\r\nif (!(s->io_bits & 0xf00000))\r\nconfig |= I8255_CTRL_C_HI_IO;\r\ndio200_write8(dev, subpriv->ofs + I8255_CTRL_REG, config);\r\n}\r\nstatic int dio200_subdev_8255_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct dio200_subdev_8255 *subpriv = s->private;\r\nunsigned int mask;\r\nunsigned int val;\r\nmask = comedi_dio_update_state(s, data);\r\nif (mask) {\r\nif (mask & 0xff)\r\ndio200_write8(dev, subpriv->ofs + I8255_DATA_A_REG,\r\ns->state & 0xff);\r\nif (mask & 0xff00)\r\ndio200_write8(dev, subpriv->ofs + I8255_DATA_B_REG,\r\n(s->state >> 8) & 0xff);\r\nif (mask & 0xff0000)\r\ndio200_write8(dev, subpriv->ofs + I8255_DATA_C_REG,\r\n(s->state >> 16) & 0xff);\r\n}\r\nval = dio200_read8(dev, subpriv->ofs + I8255_DATA_A_REG);\r\nval |= dio200_read8(dev, subpriv->ofs + I8255_DATA_B_REG) << 8;\r\nval |= dio200_read8(dev, subpriv->ofs + I8255_DATA_C_REG) << 16;\r\ndata[1] = val;\r\nreturn insn->n;\r\n}\r\nstatic int dio200_subdev_8255_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int mask;\r\nint ret;\r\nif (chan < 8)\r\nmask = 0x0000ff;\r\nelse if (chan < 16)\r\nmask = 0x00ff00;\r\nelse if (chan < 20)\r\nmask = 0x0f0000;\r\nelse\r\nmask = 0xf00000;\r\nret = comedi_dio_insn_config(dev, s, insn, data, mask);\r\nif (ret)\r\nreturn ret;\r\ndio200_subdev_8255_set_dir(dev, s);\r\nreturn insn->n;\r\n}\r\nstatic int dio200_subdev_8255_init(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int offset)\r\n{\r\nstruct dio200_subdev_8255 *subpriv;\r\nsubpriv = comedi_alloc_spriv(s, sizeof(*subpriv));\r\nif (!subpriv)\r\nreturn -ENOMEM;\r\nsubpriv->ofs = offset;\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 24;\r\ns->range_table = &range_digital;\r\ns->maxdata = 1;\r\ns->insn_bits = dio200_subdev_8255_bits;\r\ns->insn_config = dio200_subdev_8255_config;\r\ndio200_subdev_8255_set_dir(dev, s);\r\nreturn 0;\r\n}\r\nstatic int dio200_subdev_timer_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int n;\r\nfor (n = 0; n < insn->n; n++)\r\ndata[n] = dio200_read32(dev, DIO200_TS_COUNT);\r\nreturn n;\r\n}\r\nstatic void dio200_subdev_timer_reset(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned int clock;\r\nclock = dio200_read32(dev, DIO200_TS_CONFIG) & TS_CONFIG_CLK_SRC_MASK;\r\ndio200_write32(dev, DIO200_TS_CONFIG, clock | TS_CONFIG_RESET);\r\ndio200_write32(dev, DIO200_TS_CONFIG, clock);\r\n}\r\nstatic void dio200_subdev_timer_get_clock_src(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int *src,\r\nunsigned int *period)\r\n{\r\nunsigned int clk;\r\nclk = dio200_read32(dev, DIO200_TS_CONFIG) & TS_CONFIG_CLK_SRC_MASK;\r\n*src = clk;\r\n*period = (clk < ARRAY_SIZE(ts_clock_period)) ?\r\nts_clock_period[clk] : 0;\r\n}\r\nstatic int dio200_subdev_timer_set_clock_src(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int src)\r\n{\r\nif (src > TS_CONFIG_MAX_CLK_SRC)\r\nreturn -EINVAL;\r\ndio200_write32(dev, DIO200_TS_CONFIG, src);\r\nreturn 0;\r\n}\r\nstatic int dio200_subdev_timer_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint ret = 0;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_RESET:\r\ndio200_subdev_timer_reset(dev, s);\r\nbreak;\r\ncase INSN_CONFIG_SET_CLOCK_SRC:\r\nret = dio200_subdev_timer_set_clock_src(dev, s, data[1]);\r\nif (ret < 0)\r\nret = -EINVAL;\r\nbreak;\r\ncase INSN_CONFIG_GET_CLOCK_SRC:\r\ndio200_subdev_timer_get_clock_src(dev, s, &data[1], &data[2]);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret < 0 ? ret : insn->n;\r\n}\r\nvoid amplc_dio200_set_enhance(struct comedi_device *dev, unsigned char val)\r\n{\r\ndio200_write8(dev, DIO200_ENHANCE, val);\r\n}\r\nint amplc_dio200_common_attach(struct comedi_device *dev, unsigned int irq,\r\nunsigned long req_irq_flags)\r\n{\r\nconst struct dio200_board *board = dev->board_ptr;\r\nstruct comedi_subdevice *s;\r\nunsigned int n;\r\nint ret;\r\nret = comedi_alloc_subdevices(dev, board->n_subdevs);\r\nif (ret)\r\nreturn ret;\r\nfor (n = 0; n < dev->n_subdevices; n++) {\r\ns = &dev->subdevices[n];\r\nswitch (board->sdtype[n]) {\r\ncase sd_8254:\r\nret = dio200_subdev_8254_init(dev, s,\r\nboard->sdinfo[n]);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase sd_8255:\r\nret = dio200_subdev_8255_init(dev, s,\r\nboard->sdinfo[n]);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase sd_intr:\r\nif (irq && !dev->read_subdev) {\r\nret = dio200_subdev_intr_init(dev, s,\r\nDIO200_INT_SCE,\r\nboard->sdinfo[n]);\r\nif (ret < 0)\r\nreturn ret;\r\ndev->read_subdev = s;\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\nbreak;\r\ncase sd_timer:\r\ns->type = COMEDI_SUBD_TIMER;\r\ns->subdev_flags = SDF_READABLE | SDF_LSAMPL;\r\ns->n_chan = 1;\r\ns->maxdata = 0xffffffff;\r\ns->insn_read = dio200_subdev_timer_read;\r\ns->insn_config = dio200_subdev_timer_config;\r\nbreak;\r\ndefault:\r\ns->type = COMEDI_SUBD_UNUSED;\r\nbreak;\r\n}\r\n}\r\nif (irq && dev->read_subdev) {\r\nif (request_irq(irq, dio200_interrupt, req_irq_flags,\r\ndev->board_name, dev) >= 0) {\r\ndev->irq = irq;\r\n} else {\r\ndev_warn(dev->class_dev,\r\n"warning! irq %u unavailable!\n", irq);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init amplc_dio200_common_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit amplc_dio200_common_exit(void)\r\n{\r\n}
