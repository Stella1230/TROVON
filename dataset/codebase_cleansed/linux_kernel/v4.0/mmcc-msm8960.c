static int pix_rdi_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nint i;\r\nint ret = 0;\r\nu32 val;\r\nstruct clk_pix_rdi *rdi = to_clk_pix_rdi(hw);\r\nstruct clk *clk = hw->clk;\r\nint num_parents = __clk_get_num_parents(hw->clk);\r\nfor (i = 0; i < num_parents; i++) {\r\nret = clk_prepare_enable(clk_get_parent_by_index(clk, i));\r\nif (ret)\r\ngoto err;\r\n}\r\nif (index == 2)\r\nval = rdi->s2_mask;\r\nelse\r\nval = 0;\r\nregmap_update_bits(rdi->clkr.regmap, rdi->s2_reg, rdi->s2_mask, val);\r\nudelay(1);\r\nif (index == 1)\r\nval = rdi->s_mask;\r\nelse\r\nval = 0;\r\nregmap_update_bits(rdi->clkr.regmap, rdi->s_reg, rdi->s_mask, val);\r\nudelay(1);\r\nerr:\r\nfor (i--; i >= 0; i--)\r\nclk_disable_unprepare(clk_get_parent_by_index(clk, i));\r\nreturn ret;\r\n}\r\nstatic u8 pix_rdi_get_parent(struct clk_hw *hw)\r\n{\r\nu32 val;\r\nstruct clk_pix_rdi *rdi = to_clk_pix_rdi(hw);\r\nregmap_read(rdi->clkr.regmap, rdi->s2_reg, &val);\r\nif (val & rdi->s2_mask)\r\nreturn 2;\r\nregmap_read(rdi->clkr.regmap, rdi->s_reg, &val);\r\nif (val & rdi->s_mask)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int mmcc_msm8960_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct regmap *regmap;\r\nbool is_8064;\r\nstruct device *dev = &pdev->dev;\r\nmatch = of_match_device(mmcc_msm8960_match_table, dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nis_8064 = of_device_is_compatible(dev->of_node, "qcom,mmcc-apq8064");\r\nif (is_8064) {\r\ngfx3d_src.freq_tbl = clk_tbl_gfx3d_8064;\r\ngfx3d_src.clkr.hw.init = &gfx3d_8064_init;\r\ngfx3d_src.s[0].parent_map = mmcc_pxo_pll8_pll2_pll15_map;\r\ngfx3d_src.s[1].parent_map = mmcc_pxo_pll8_pll2_pll15_map;\r\n}\r\nregmap = qcom_cc_map(pdev, match->data);\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nclk_pll_configure_sr(&pll15, regmap, &pll15_config, false);\r\nreturn qcom_cc_really_probe(pdev, match->data, regmap);\r\n}\r\nstatic int mmcc_msm8960_remove(struct platform_device *pdev)\r\n{\r\nqcom_cc_remove(pdev);\r\nreturn 0;\r\n}
