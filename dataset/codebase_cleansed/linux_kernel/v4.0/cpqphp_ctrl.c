static void long_delay(int delay)\r\n{\r\nmsleep_interruptible(jiffies_to_msecs(delay));\r\n}\r\nstatic u8 handle_switch_change(u8 change, struct controller *ctrl)\r\n{\r\nint hp_slot;\r\nu8 rc = 0;\r\nu16 temp_word;\r\nstruct pci_func *func;\r\nstruct event_info *taskInfo;\r\nif (!change)\r\nreturn 0;\r\ndbg("cpqsbd: Switch interrupt received.\n");\r\nfor (hp_slot = 0; hp_slot < 6; hp_slot++) {\r\nif (change & (0x1L << hp_slot)) {\r\nfunc = cpqhp_slot_find(ctrl->bus,\r\n(hp_slot + ctrl->slot_device_offset), 0);\r\ntaskInfo = &(ctrl->event_queue[ctrl->next_event]);\r\nctrl->next_event = (ctrl->next_event + 1) % 10;\r\ntaskInfo->hp_slot = hp_slot;\r\nrc++;\r\ntemp_word = ctrl->ctrl_int_comp >> 16;\r\nfunc->presence_save = (temp_word >> hp_slot) & 0x01;\r\nfunc->presence_save |= (temp_word >> (hp_slot + 7)) & 0x02;\r\nif (ctrl->ctrl_int_comp & (0x1L << hp_slot)) {\r\nfunc->switch_save = 0;\r\ntaskInfo->event_type = INT_SWITCH_OPEN;\r\n} else {\r\nfunc->switch_save = 0x10;\r\ntaskInfo->event_type = INT_SWITCH_CLOSE;\r\n}\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic struct slot *cpqhp_find_slot(struct controller *ctrl, u8 device)\r\n{\r\nstruct slot *slot = ctrl->slot;\r\nwhile (slot && (slot->device != device))\r\nslot = slot->next;\r\nreturn slot;\r\n}\r\nstatic u8 handle_presence_change(u16 change, struct controller *ctrl)\r\n{\r\nint hp_slot;\r\nu8 rc = 0;\r\nu8 temp_byte;\r\nu16 temp_word;\r\nstruct pci_func *func;\r\nstruct event_info *taskInfo;\r\nstruct slot *p_slot;\r\nif (!change)\r\nreturn 0;\r\ndbg("cpqsbd: Presence/Notify input change.\n");\r\ndbg(" Changed bits are 0x%4.4x\n", change );\r\nfor (hp_slot = 0; hp_slot < 6; hp_slot++) {\r\nif (change & (0x0101 << hp_slot)) {\r\nfunc = cpqhp_slot_find(ctrl->bus,\r\n(hp_slot + ctrl->slot_device_offset), 0);\r\ntaskInfo = &(ctrl->event_queue[ctrl->next_event]);\r\nctrl->next_event = (ctrl->next_event + 1) % 10;\r\ntaskInfo->hp_slot = hp_slot;\r\nrc++;\r\np_slot = cpqhp_find_slot(ctrl, hp_slot + (readb(ctrl->hpc_reg + SLOT_MASK) >> 4));\r\nif (!p_slot)\r\nreturn 0;\r\nif (func->switch_save && (ctrl->push_button == 1)) {\r\ntemp_word = ctrl->ctrl_int_comp >> 16;\r\ntemp_byte = (temp_word >> hp_slot) & 0x01;\r\ntemp_byte |= (temp_word >> (hp_slot + 7)) & 0x02;\r\nif (temp_byte != func->presence_save) {\r\ndbg("hp_slot %d button pressed\n", hp_slot);\r\ntaskInfo->event_type = INT_BUTTON_PRESS;\r\n} else {\r\ndbg("hp_slot %d button released\n", hp_slot);\r\ntaskInfo->event_type = INT_BUTTON_RELEASE;\r\nif ((p_slot->state == BLINKINGON_STATE)\r\n|| (p_slot->state == BLINKINGOFF_STATE)) {\r\ntaskInfo->event_type = INT_BUTTON_CANCEL;\r\ndbg("hp_slot %d button cancel\n", hp_slot);\r\n} else if ((p_slot->state == POWERON_STATE)\r\n|| (p_slot->state == POWEROFF_STATE)) {\r\ntaskInfo->event_type = INT_BUTTON_IGNORE;\r\ndbg("hp_slot %d button ignore\n", hp_slot);\r\n}\r\n}\r\n} else {\r\ntemp_word = ctrl->ctrl_int_comp >> 16;\r\nfunc->presence_save = (temp_word >> hp_slot) & 0x01;\r\nfunc->presence_save |= (temp_word >> (hp_slot + 7)) & 0x02;\r\nif ((!(ctrl->ctrl_int_comp & (0x010000 << hp_slot))) ||\r\n(!(ctrl->ctrl_int_comp & (0x01000000 << hp_slot)))) {\r\ntaskInfo->event_type = INT_PRESENCE_ON;\r\n} else {\r\ntaskInfo->event_type = INT_PRESENCE_OFF;\r\n}\r\n}\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic u8 handle_power_fault(u8 change, struct controller *ctrl)\r\n{\r\nint hp_slot;\r\nu8 rc = 0;\r\nstruct pci_func *func;\r\nstruct event_info *taskInfo;\r\nif (!change)\r\nreturn 0;\r\ninfo("power fault interrupt\n");\r\nfor (hp_slot = 0; hp_slot < 6; hp_slot++) {\r\nif (change & (0x01 << hp_slot)) {\r\nfunc = cpqhp_slot_find(ctrl->bus,\r\n(hp_slot + ctrl->slot_device_offset), 0);\r\ntaskInfo = &(ctrl->event_queue[ctrl->next_event]);\r\nctrl->next_event = (ctrl->next_event + 1) % 10;\r\ntaskInfo->hp_slot = hp_slot;\r\nrc++;\r\nif (ctrl->ctrl_int_comp & (0x00000100 << hp_slot)) {\r\nfunc->status = 0x00;\r\ntaskInfo->event_type = INT_POWER_FAULT_CLEAR;\r\n} else {\r\ntaskInfo->event_type = INT_POWER_FAULT;\r\nif (ctrl->rev < 4) {\r\namber_LED_on (ctrl, hp_slot);\r\ngreen_LED_off (ctrl, hp_slot);\r\nset_SOGO (ctrl);\r\n} else {\r\nfunc->status = 0xFF;\r\ninfo("power fault bit %x set\n", hp_slot);\r\n}\r\n}\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int sort_by_size(struct pci_resource **head)\r\n{\r\nstruct pci_resource *current_res;\r\nstruct pci_resource *next_res;\r\nint out_of_order = 1;\r\nif (!(*head))\r\nreturn 1;\r\nif (!((*head)->next))\r\nreturn 0;\r\nwhile (out_of_order) {\r\nout_of_order = 0;\r\nif (((*head)->next) &&\r\n((*head)->length > (*head)->next->length)) {\r\nout_of_order++;\r\ncurrent_res = *head;\r\n*head = (*head)->next;\r\ncurrent_res->next = (*head)->next;\r\n(*head)->next = current_res;\r\n}\r\ncurrent_res = *head;\r\nwhile (current_res->next && current_res->next->next) {\r\nif (current_res->next->length > current_res->next->next->length) {\r\nout_of_order++;\r\nnext_res = current_res->next;\r\ncurrent_res->next = current_res->next->next;\r\ncurrent_res = current_res->next;\r\nnext_res->next = current_res->next;\r\ncurrent_res->next = next_res;\r\n} else\r\ncurrent_res = current_res->next;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sort_by_max_size(struct pci_resource **head)\r\n{\r\nstruct pci_resource *current_res;\r\nstruct pci_resource *next_res;\r\nint out_of_order = 1;\r\nif (!(*head))\r\nreturn 1;\r\nif (!((*head)->next))\r\nreturn 0;\r\nwhile (out_of_order) {\r\nout_of_order = 0;\r\nif (((*head)->next) &&\r\n((*head)->length < (*head)->next->length)) {\r\nout_of_order++;\r\ncurrent_res = *head;\r\n*head = (*head)->next;\r\ncurrent_res->next = (*head)->next;\r\n(*head)->next = current_res;\r\n}\r\ncurrent_res = *head;\r\nwhile (current_res->next && current_res->next->next) {\r\nif (current_res->next->length < current_res->next->next->length) {\r\nout_of_order++;\r\nnext_res = current_res->next;\r\ncurrent_res->next = current_res->next->next;\r\ncurrent_res = current_res->next;\r\nnext_res->next = current_res->next;\r\ncurrent_res->next = next_res;\r\n} else\r\ncurrent_res = current_res->next;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct pci_resource *do_pre_bridge_resource_split(struct pci_resource **head,\r\nstruct pci_resource **orig_head, u32 alignment)\r\n{\r\nstruct pci_resource *prevnode = NULL;\r\nstruct pci_resource *node;\r\nstruct pci_resource *split_node;\r\nu32 rc;\r\nu32 temp_dword;\r\ndbg("do_pre_bridge_resource_split\n");\r\nif (!(*head) || !(*orig_head))\r\nreturn NULL;\r\nrc = cpqhp_resource_sort_and_combine(head);\r\nif (rc)\r\nreturn NULL;\r\nif ((*head)->base != (*orig_head)->base)\r\nreturn NULL;\r\nif ((*head)->length == (*orig_head)->length)\r\nreturn NULL;\r\nnode = *head;\r\nif (node->length & (alignment -1)) {\r\nsplit_node = kmalloc(sizeof(*split_node), GFP_KERNEL);\r\nif (!split_node)\r\nreturn NULL;\r\ntemp_dword = (node->length | (alignment-1)) + 1 - alignment;\r\nsplit_node->base = node->base;\r\nsplit_node->length = temp_dword;\r\nnode->length -= temp_dword;\r\nnode->base += split_node->length;\r\n*head = split_node;\r\nsplit_node->next = node;\r\n}\r\nif (node->length < alignment)\r\nreturn NULL;\r\nif (*head == node) {\r\n*head = node->next;\r\n} else {\r\nprevnode = *head;\r\nwhile (prevnode->next != node)\r\nprevnode = prevnode->next;\r\nprevnode->next = node->next;\r\n}\r\nnode->next = NULL;\r\nreturn node;\r\n}\r\nstatic struct pci_resource *do_bridge_resource_split(struct pci_resource **head, u32 alignment)\r\n{\r\nstruct pci_resource *prevnode = NULL;\r\nstruct pci_resource *node;\r\nu32 rc;\r\nu32 temp_dword;\r\nrc = cpqhp_resource_sort_and_combine(head);\r\nif (rc)\r\nreturn NULL;\r\nnode = *head;\r\nwhile (node->next) {\r\nprevnode = node;\r\nnode = node->next;\r\nkfree(prevnode);\r\n}\r\nif (node->length < alignment)\r\ngoto error;\r\nif (node->base & (alignment - 1)) {\r\ntemp_dword = (node->base | (alignment-1)) + 1;\r\nif ((node->length - (temp_dword - node->base)) < alignment)\r\ngoto error;\r\nnode->length -= (temp_dword - node->base);\r\nnode->base = temp_dword;\r\n}\r\nif (node->length & (alignment - 1))\r\ngoto error;\r\nreturn node;\r\nerror:\r\nkfree(node);\r\nreturn NULL;\r\n}\r\nstatic struct pci_resource *get_io_resource(struct pci_resource **head, u32 size)\r\n{\r\nstruct pci_resource *prevnode;\r\nstruct pci_resource *node;\r\nstruct pci_resource *split_node;\r\nu32 temp_dword;\r\nif (!(*head))\r\nreturn NULL;\r\nif (cpqhp_resource_sort_and_combine(head))\r\nreturn NULL;\r\nif (sort_by_size(head))\r\nreturn NULL;\r\nfor (node = *head; node; node = node->next) {\r\nif (node->length < size)\r\ncontinue;\r\nif (node->base & (size - 1)) {\r\ntemp_dword = (node->base | (size-1)) + 1;\r\nif ((node->length - (temp_dword - node->base)) < size)\r\ncontinue;\r\nsplit_node = kmalloc(sizeof(*split_node), GFP_KERNEL);\r\nif (!split_node)\r\nreturn NULL;\r\nsplit_node->base = node->base;\r\nsplit_node->length = temp_dword - node->base;\r\nnode->base = temp_dword;\r\nnode->length -= split_node->length;\r\nsplit_node->next = node->next;\r\nnode->next = split_node;\r\n}\r\nif (node->length > size) {\r\nsplit_node = kmalloc(sizeof(*split_node), GFP_KERNEL);\r\nif (!split_node)\r\nreturn NULL;\r\nsplit_node->base = node->base + size;\r\nsplit_node->length = node->length - size;\r\nnode->length = size;\r\nsplit_node->next = node->next;\r\nnode->next = split_node;\r\n}\r\nif (node->base & 0x300L)\r\ncontinue;\r\nif (*head == node) {\r\n*head = node->next;\r\n} else {\r\nprevnode = *head;\r\nwhile (prevnode->next != node)\r\nprevnode = prevnode->next;\r\nprevnode->next = node->next;\r\n}\r\nnode->next = NULL;\r\nbreak;\r\n}\r\nreturn node;\r\n}\r\nstatic struct pci_resource *get_max_resource(struct pci_resource **head, u32 size)\r\n{\r\nstruct pci_resource *max;\r\nstruct pci_resource *temp;\r\nstruct pci_resource *split_node;\r\nu32 temp_dword;\r\nif (cpqhp_resource_sort_and_combine(head))\r\nreturn NULL;\r\nif (sort_by_max_size(head))\r\nreturn NULL;\r\nfor (max = *head; max; max = max->next) {\r\nif (max->length < size)\r\ncontinue;\r\nif (max->base & (size - 1)) {\r\ntemp_dword = (max->base | (size-1)) + 1;\r\nif ((max->length - (temp_dword - max->base)) < size)\r\ncontinue;\r\nsplit_node = kmalloc(sizeof(*split_node), GFP_KERNEL);\r\nif (!split_node)\r\nreturn NULL;\r\nsplit_node->base = max->base;\r\nsplit_node->length = temp_dword - max->base;\r\nmax->base = temp_dword;\r\nmax->length -= split_node->length;\r\nsplit_node->next = max->next;\r\nmax->next = split_node;\r\n}\r\nif ((max->base + max->length) & (size - 1)) {\r\nsplit_node = kmalloc(sizeof(*split_node), GFP_KERNEL);\r\nif (!split_node)\r\nreturn NULL;\r\ntemp_dword = ((max->base + max->length) & ~(size - 1));\r\nsplit_node->base = temp_dword;\r\nsplit_node->length = max->length + max->base\r\n- split_node->base;\r\nmax->length -= split_node->length;\r\nsplit_node->next = max->next;\r\nmax->next = split_node;\r\n}\r\nif (max->length < size)\r\ncontinue;\r\ntemp = *head;\r\nif (temp == max) {\r\n*head = max->next;\r\n} else {\r\nwhile (temp && temp->next != max)\r\ntemp = temp->next;\r\nif (temp)\r\ntemp->next = max->next;\r\n}\r\nmax->next = NULL;\r\nbreak;\r\n}\r\nreturn max;\r\n}\r\nstatic struct pci_resource *get_resource(struct pci_resource **head, u32 size)\r\n{\r\nstruct pci_resource *prevnode;\r\nstruct pci_resource *node;\r\nstruct pci_resource *split_node;\r\nu32 temp_dword;\r\nif (cpqhp_resource_sort_and_combine(head))\r\nreturn NULL;\r\nif (sort_by_size(head))\r\nreturn NULL;\r\nfor (node = *head; node; node = node->next) {\r\ndbg("%s: req_size =%x node=%p, base=%x, length=%x\n",\r\n__func__, size, node, node->base, node->length);\r\nif (node->length < size)\r\ncontinue;\r\nif (node->base & (size - 1)) {\r\ndbg("%s: not aligned\n", __func__);\r\ntemp_dword = (node->base | (size-1)) + 1;\r\nif ((node->length - (temp_dword - node->base)) < size)\r\ncontinue;\r\nsplit_node = kmalloc(sizeof(*split_node), GFP_KERNEL);\r\nif (!split_node)\r\nreturn NULL;\r\nsplit_node->base = node->base;\r\nsplit_node->length = temp_dword - node->base;\r\nnode->base = temp_dword;\r\nnode->length -= split_node->length;\r\nsplit_node->next = node->next;\r\nnode->next = split_node;\r\n}\r\nif (node->length > size) {\r\ndbg("%s: too big\n", __func__);\r\nsplit_node = kmalloc(sizeof(*split_node), GFP_KERNEL);\r\nif (!split_node)\r\nreturn NULL;\r\nsplit_node->base = node->base + size;\r\nsplit_node->length = node->length - size;\r\nnode->length = size;\r\nsplit_node->next = node->next;\r\nnode->next = split_node;\r\n}\r\ndbg("%s: got one!!!\n", __func__);\r\nif (*head == node) {\r\n*head = node->next;\r\n} else {\r\nprevnode = *head;\r\nwhile (prevnode->next != node)\r\nprevnode = prevnode->next;\r\nprevnode->next = node->next;\r\n}\r\nnode->next = NULL;\r\nbreak;\r\n}\r\nreturn node;\r\n}\r\nint cpqhp_resource_sort_and_combine(struct pci_resource **head)\r\n{\r\nstruct pci_resource *node1;\r\nstruct pci_resource *node2;\r\nint out_of_order = 1;\r\ndbg("%s: head = %p, *head = %p\n", __func__, head, *head);\r\nif (!(*head))\r\nreturn 1;\r\ndbg("*head->next = %p\n",(*head)->next);\r\nif (!(*head)->next)\r\nreturn 0;\r\ndbg("*head->base = 0x%x\n",(*head)->base);\r\ndbg("*head->next->base = 0x%x\n",(*head)->next->base);\r\nwhile (out_of_order) {\r\nout_of_order = 0;\r\nif (((*head)->next) &&\r\n((*head)->base > (*head)->next->base)) {\r\nnode1 = *head;\r\n(*head) = (*head)->next;\r\nnode1->next = (*head)->next;\r\n(*head)->next = node1;\r\nout_of_order++;\r\n}\r\nnode1 = (*head);\r\nwhile (node1->next && node1->next->next) {\r\nif (node1->next->base > node1->next->next->base) {\r\nout_of_order++;\r\nnode2 = node1->next;\r\nnode1->next = node1->next->next;\r\nnode1 = node1->next;\r\nnode2->next = node1->next;\r\nnode1->next = node2;\r\n} else\r\nnode1 = node1->next;\r\n}\r\n}\r\nnode1 = *head;\r\nwhile (node1 && node1->next) {\r\nif ((node1->base + node1->length) == node1->next->base) {\r\ndbg("8..\n");\r\nnode1->length += node1->next->length;\r\nnode2 = node1->next;\r\nnode1->next = node1->next->next;\r\nkfree(node2);\r\n} else\r\nnode1 = node1->next;\r\n}\r\nreturn 0;\r\n}\r\nirqreturn_t cpqhp_ctrl_intr(int IRQ, void *data)\r\n{\r\nstruct controller *ctrl = data;\r\nu8 schedule_flag = 0;\r\nu8 reset;\r\nu16 misc;\r\nu32 Diff;\r\nu32 temp_dword;\r\nmisc = readw(ctrl->hpc_reg + MISC);\r\nif (!(misc & 0x000C))\r\nreturn IRQ_NONE;\r\nif (misc & 0x0004) {\r\nmisc |= 0x0004;\r\nwritew(misc, ctrl->hpc_reg + MISC);\r\nmisc = readw(ctrl->hpc_reg + MISC);\r\ndbg ("%s - waking up\n", __func__);\r\nwake_up_interruptible(&ctrl->queue);\r\n}\r\nif (misc & 0x0008) {\r\nDiff = readl(ctrl->hpc_reg + INT_INPUT_CLEAR) ^ ctrl->ctrl_int_comp;\r\nctrl->ctrl_int_comp = readl(ctrl->hpc_reg + INT_INPUT_CLEAR);\r\nwritel(Diff, ctrl->hpc_reg + INT_INPUT_CLEAR);\r\ntemp_dword = readl(ctrl->hpc_reg + INT_INPUT_CLEAR);\r\nif (!Diff)\r\nwritel(0xFFFFFFFF, ctrl->hpc_reg + INT_INPUT_CLEAR);\r\nschedule_flag += handle_switch_change((u8)(Diff & 0xFFL), ctrl);\r\nschedule_flag += handle_presence_change((u16)((Diff & 0xFFFF0000L) >> 16), ctrl);\r\nschedule_flag += handle_power_fault((u8)((Diff & 0xFF00L) >> 8), ctrl);\r\n}\r\nreset = readb(ctrl->hpc_reg + RESET_FREQ_MODE);\r\nif (reset & 0x40) {\r\nreset &= 0xCF;\r\nwriteb(reset, ctrl->hpc_reg + RESET_FREQ_MODE);\r\nreset = readb(ctrl->hpc_reg + RESET_FREQ_MODE);\r\nwake_up_interruptible(&ctrl->queue);\r\n}\r\nif (schedule_flag) {\r\nwake_up_process(cpqhp_event_thread);\r\ndbg("Waking even thread");\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstruct pci_func *cpqhp_slot_create(u8 busnumber)\r\n{\r\nstruct pci_func *new_slot;\r\nstruct pci_func *next;\r\nnew_slot = kzalloc(sizeof(*new_slot), GFP_KERNEL);\r\nif (new_slot == NULL)\r\nreturn new_slot;\r\nnew_slot->next = NULL;\r\nnew_slot->configured = 1;\r\nif (cpqhp_slot_list[busnumber] == NULL) {\r\ncpqhp_slot_list[busnumber] = new_slot;\r\n} else {\r\nnext = cpqhp_slot_list[busnumber];\r\nwhile (next->next != NULL)\r\nnext = next->next;\r\nnext->next = new_slot;\r\n}\r\nreturn new_slot;\r\n}\r\nstatic int slot_remove(struct pci_func *old_slot)\r\n{\r\nstruct pci_func *next;\r\nif (old_slot == NULL)\r\nreturn 1;\r\nnext = cpqhp_slot_list[old_slot->bus];\r\nif (next == NULL)\r\nreturn 1;\r\nif (next == old_slot) {\r\ncpqhp_slot_list[old_slot->bus] = old_slot->next;\r\ncpqhp_destroy_board_resources(old_slot);\r\nkfree(old_slot);\r\nreturn 0;\r\n}\r\nwhile ((next->next != old_slot) && (next->next != NULL))\r\nnext = next->next;\r\nif (next->next == old_slot) {\r\nnext->next = old_slot->next;\r\ncpqhp_destroy_board_resources(old_slot);\r\nkfree(old_slot);\r\nreturn 0;\r\n} else\r\nreturn 2;\r\n}\r\nstatic int bridge_slot_remove(struct pci_func *bridge)\r\n{\r\nu8 subordinateBus, secondaryBus;\r\nu8 tempBus;\r\nstruct pci_func *next;\r\nsecondaryBus = (bridge->config_space[0x06] >> 8) & 0xFF;\r\nsubordinateBus = (bridge->config_space[0x06] >> 16) & 0xFF;\r\nfor (tempBus = secondaryBus; tempBus <= subordinateBus; tempBus++) {\r\nnext = cpqhp_slot_list[tempBus];\r\nwhile (!slot_remove(next))\r\nnext = cpqhp_slot_list[tempBus];\r\n}\r\nnext = cpqhp_slot_list[bridge->bus];\r\nif (next == NULL)\r\nreturn 1;\r\nif (next == bridge) {\r\ncpqhp_slot_list[bridge->bus] = bridge->next;\r\ngoto out;\r\n}\r\nwhile ((next->next != bridge) && (next->next != NULL))\r\nnext = next->next;\r\nif (next->next != bridge)\r\nreturn 2;\r\nnext->next = bridge->next;\r\nout:\r\nkfree(bridge);\r\nreturn 0;\r\n}\r\nstruct pci_func *cpqhp_slot_find(u8 bus, u8 device, u8 index)\r\n{\r\nint found = -1;\r\nstruct pci_func *func;\r\nfunc = cpqhp_slot_list[bus];\r\nif ((func == NULL) || ((func->device == device) && (index == 0)))\r\nreturn func;\r\nif (func->device == device)\r\nfound++;\r\nwhile (func->next != NULL) {\r\nfunc = func->next;\r\nif (func->device == device)\r\nfound++;\r\nif (found == index)\r\nreturn func;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int is_bridge(struct pci_func *func)\r\n{\r\nif (((func->config_space[0x03] >> 16) & 0xFF) == 0x01)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic u8 set_controller_speed(struct controller *ctrl, u8 adapter_speed, u8 hp_slot)\r\n{\r\nstruct slot *slot;\r\nstruct pci_bus *bus = ctrl->pci_bus;\r\nu8 reg;\r\nu8 slot_power = readb(ctrl->hpc_reg + SLOT_POWER);\r\nu16 reg16;\r\nu32 leds = readl(ctrl->hpc_reg + LED_CONTROL);\r\nif (bus->cur_bus_speed == adapter_speed)\r\nreturn 0;\r\nfor (slot = ctrl->slot; slot; slot = slot->next) {\r\nif (slot->device == (hp_slot + ctrl->slot_device_offset))\r\ncontinue;\r\nif (!slot->hotplug_slot || !slot->hotplug_slot->info)\r\ncontinue;\r\nif (slot->hotplug_slot->info->adapter_status == 0)\r\ncontinue;\r\nif (bus->cur_bus_speed < adapter_speed)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nif ((bus->cur_bus_speed > adapter_speed) && (!ctrl->pcix_speed_capability))\r\nreturn 1;\r\nif ((bus->cur_bus_speed < adapter_speed) && (!ctrl->pcix_speed_capability))\r\nreturn 0;\r\nif (bus->max_bus_speed < adapter_speed) {\r\nif (bus->cur_bus_speed == bus->max_bus_speed)\r\nreturn 0;\r\nadapter_speed = bus->max_bus_speed;\r\n}\r\nwritel(0x0L, ctrl->hpc_reg + LED_CONTROL);\r\nwriteb(0x00, ctrl->hpc_reg + SLOT_ENABLE);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq(ctrl);\r\nif (adapter_speed != PCI_SPEED_133MHz_PCIX)\r\nreg = 0xF5;\r\nelse\r\nreg = 0xF4;\r\npci_write_config_byte(ctrl->pci_dev, 0x41, reg);\r\nreg16 = readw(ctrl->hpc_reg + NEXT_CURR_FREQ);\r\nreg16 &= ~0x000F;\r\nswitch (adapter_speed) {\r\ncase(PCI_SPEED_133MHz_PCIX):\r\nreg = 0x75;\r\nreg16 |= 0xB;\r\nbreak;\r\ncase(PCI_SPEED_100MHz_PCIX):\r\nreg = 0x74;\r\nreg16 |= 0xA;\r\nbreak;\r\ncase(PCI_SPEED_66MHz_PCIX):\r\nreg = 0x73;\r\nreg16 |= 0x9;\r\nbreak;\r\ncase(PCI_SPEED_66MHz):\r\nreg = 0x73;\r\nreg16 |= 0x1;\r\nbreak;\r\ndefault:\r\nreg = 0x71;\r\nbreak;\r\n}\r\nreg16 |= 0xB << 12;\r\nwritew(reg16, ctrl->hpc_reg + NEXT_CURR_FREQ);\r\nmdelay(5);\r\nwritel(0, ctrl->hpc_reg + INT_MASK);\r\npci_write_config_byte(ctrl->pci_dev, 0x41, reg);\r\nreg = ~0xF;\r\npci_read_config_byte(ctrl->pci_dev, 0x43, &reg);\r\npci_write_config_byte(ctrl->pci_dev, 0x43, reg);\r\nif (((bus->cur_bus_speed == PCI_SPEED_66MHz) && (adapter_speed == PCI_SPEED_66MHz_PCIX)) ||\r\n((bus->cur_bus_speed == PCI_SPEED_66MHz_PCIX) && (adapter_speed == PCI_SPEED_66MHz)))\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq(ctrl);\r\nmdelay(1100);\r\nwritel(leds, ctrl->hpc_reg + LED_CONTROL);\r\nwriteb(slot_power, ctrl->hpc_reg + SLOT_ENABLE);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq(ctrl);\r\nbus->cur_bus_speed = adapter_speed;\r\nslot = cpqhp_find_slot(ctrl, hp_slot + ctrl->slot_device_offset);\r\ninfo("Successfully changed frequency/mode for adapter in slot %d\n",\r\nslot->number);\r\nreturn 0;\r\n}\r\nstatic u32 board_replaced(struct pci_func *func, struct controller *ctrl)\r\n{\r\nstruct pci_bus *bus = ctrl->pci_bus;\r\nu8 hp_slot;\r\nu8 temp_byte;\r\nu8 adapter_speed;\r\nu32 rc = 0;\r\nhp_slot = func->device - ctrl->slot_device_offset;\r\nif (readl(ctrl->hpc_reg + INT_INPUT_CLEAR) & (0x01L << hp_slot))\r\nrc = INTERLOCK_OPEN;\r\nelse if (is_slot_enabled (ctrl, hp_slot))\r\nrc = CARD_FUNCTIONING;\r\nelse {\r\nmutex_lock(&ctrl->crit_sect);\r\nenable_slot_power (ctrl, hp_slot);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq (ctrl);\r\ntemp_byte = readb(ctrl->hpc_reg + SLOT_POWER);\r\nwriteb(0x00, ctrl->hpc_reg + SLOT_POWER);\r\nwriteb(temp_byte, ctrl->hpc_reg + SLOT_POWER);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq (ctrl);\r\nadapter_speed = get_adapter_speed(ctrl, hp_slot);\r\nif (bus->cur_bus_speed != adapter_speed)\r\nif (set_controller_speed(ctrl, adapter_speed, hp_slot))\r\nrc = WRONG_BUS_FREQUENCY;\r\ndisable_slot_power (ctrl, hp_slot);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq (ctrl);\r\nmutex_unlock(&ctrl->crit_sect);\r\nif (rc)\r\nreturn rc;\r\nmutex_lock(&ctrl->crit_sect);\r\nslot_enable (ctrl, hp_slot);\r\ngreen_LED_blink (ctrl, hp_slot);\r\namber_LED_off (ctrl, hp_slot);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq (ctrl);\r\nmutex_unlock(&ctrl->crit_sect);\r\nlong_delay(1*HZ);\r\nif (func->status == 0xFF) {\r\nrc = POWER_FAILURE;\r\nfunc->status = 0;\r\n} else\r\nrc = cpqhp_valid_replace(ctrl, func);\r\nif (!rc) {\r\nrc = cpqhp_configure_board(ctrl, func);\r\nmutex_lock(&ctrl->crit_sect);\r\namber_LED_on (ctrl, hp_slot);\r\ngreen_LED_off (ctrl, hp_slot);\r\nslot_disable (ctrl, hp_slot);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq (ctrl);\r\nmutex_unlock(&ctrl->crit_sect);\r\nif (rc)\r\nreturn rc;\r\nelse\r\nreturn 1;\r\n} else {\r\nmutex_lock(&ctrl->crit_sect);\r\namber_LED_on (ctrl, hp_slot);\r\ngreen_LED_off (ctrl, hp_slot);\r\nslot_disable (ctrl, hp_slot);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq (ctrl);\r\nmutex_unlock(&ctrl->crit_sect);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic u32 board_added(struct pci_func *func, struct controller *ctrl)\r\n{\r\nu8 hp_slot;\r\nu8 temp_byte;\r\nu8 adapter_speed;\r\nint index;\r\nu32 temp_register = 0xFFFFFFFF;\r\nu32 rc = 0;\r\nstruct pci_func *new_slot = NULL;\r\nstruct pci_bus *bus = ctrl->pci_bus;\r\nstruct slot *p_slot;\r\nstruct resource_lists res_lists;\r\nhp_slot = func->device - ctrl->slot_device_offset;\r\ndbg("%s: func->device, slot_offset, hp_slot = %d, %d ,%d\n",\r\n__func__, func->device, ctrl->slot_device_offset, hp_slot);\r\nmutex_lock(&ctrl->crit_sect);\r\nenable_slot_power(ctrl, hp_slot);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq (ctrl);\r\ntemp_byte = readb(ctrl->hpc_reg + SLOT_POWER);\r\nwriteb(0x00, ctrl->hpc_reg + SLOT_POWER);\r\nwriteb(temp_byte, ctrl->hpc_reg + SLOT_POWER);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq (ctrl);\r\nadapter_speed = get_adapter_speed(ctrl, hp_slot);\r\nif (bus->cur_bus_speed != adapter_speed)\r\nif (set_controller_speed(ctrl, adapter_speed, hp_slot))\r\nrc = WRONG_BUS_FREQUENCY;\r\ndisable_slot_power (ctrl, hp_slot);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq(ctrl);\r\nmutex_unlock(&ctrl->crit_sect);\r\nif (rc)\r\nreturn rc;\r\np_slot = cpqhp_find_slot(ctrl, hp_slot + ctrl->slot_device_offset);\r\ndbg("%s: before down\n", __func__);\r\nmutex_lock(&ctrl->crit_sect);\r\ndbg("%s: after down\n", __func__);\r\ndbg("%s: before slot_enable\n", __func__);\r\nslot_enable (ctrl, hp_slot);\r\ndbg("%s: before green_LED_blink\n", __func__);\r\ngreen_LED_blink (ctrl, hp_slot);\r\ndbg("%s: before amber_LED_blink\n", __func__);\r\namber_LED_off (ctrl, hp_slot);\r\ndbg("%s: before set_SOGO\n", __func__);\r\nset_SOGO(ctrl);\r\ndbg("%s: before wait_for_ctrl_irq\n", __func__);\r\nwait_for_ctrl_irq (ctrl);\r\ndbg("%s: after wait_for_ctrl_irq\n", __func__);\r\ndbg("%s: before up\n", __func__);\r\nmutex_unlock(&ctrl->crit_sect);\r\ndbg("%s: after up\n", __func__);\r\ndbg("%s: before long_delay\n", __func__);\r\nlong_delay(1*HZ);\r\ndbg("%s: after long_delay\n", __func__);\r\ndbg("%s: func status = %x\n", __func__, func->status);\r\nif (func->status == 0xFF) {\r\ntemp_register = 0xFFFFFFFF;\r\ndbg("%s: temp register set to %x by power fault\n", __func__, temp_register);\r\nrc = POWER_FAILURE;\r\nfunc->status = 0;\r\n} else {\r\nctrl->pci_bus->number = func->bus;\r\nrc = pci_bus_read_config_dword (ctrl->pci_bus, PCI_DEVFN(func->device, func->function), PCI_VENDOR_ID, &temp_register);\r\ndbg("%s: pci_read_config_dword returns %d\n", __func__, rc);\r\ndbg("%s: temp_register is %x\n", __func__, temp_register);\r\nif (rc != 0) {\r\ntemp_register = 0xFFFFFFFF;\r\ndbg("%s: temp register set to %x by error\n", __func__, temp_register);\r\n}\r\nrc = NO_ADAPTER_PRESENT;\r\n}\r\nif (temp_register != 0xFFFFFFFF) {\r\nres_lists.io_head = ctrl->io_head;\r\nres_lists.mem_head = ctrl->mem_head;\r\nres_lists.p_mem_head = ctrl->p_mem_head;\r\nres_lists.bus_head = ctrl->bus_head;\r\nres_lists.irqs = NULL;\r\nrc = configure_new_device(ctrl, func, 0, &res_lists);\r\ndbg("%s: back from configure_new_device\n", __func__);\r\nctrl->io_head = res_lists.io_head;\r\nctrl->mem_head = res_lists.mem_head;\r\nctrl->p_mem_head = res_lists.p_mem_head;\r\nctrl->bus_head = res_lists.bus_head;\r\ncpqhp_resource_sort_and_combine(&(ctrl->mem_head));\r\ncpqhp_resource_sort_and_combine(&(ctrl->p_mem_head));\r\ncpqhp_resource_sort_and_combine(&(ctrl->io_head));\r\ncpqhp_resource_sort_and_combine(&(ctrl->bus_head));\r\nif (rc) {\r\nmutex_lock(&ctrl->crit_sect);\r\namber_LED_on (ctrl, hp_slot);\r\ngreen_LED_off (ctrl, hp_slot);\r\nslot_disable (ctrl, hp_slot);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq (ctrl);\r\nmutex_unlock(&ctrl->crit_sect);\r\nreturn rc;\r\n} else {\r\ncpqhp_save_slot_config(ctrl, func);\r\n}\r\nfunc->status = 0;\r\nfunc->switch_save = 0x10;\r\nfunc->is_a_board = 0x01;\r\ndbg("%s: configure linux pci_dev structure\n", __func__);\r\nindex = 0;\r\ndo {\r\nnew_slot = cpqhp_slot_find(ctrl->bus, func->device, index++);\r\nif (new_slot && !new_slot->pci_dev)\r\ncpqhp_configure_device(ctrl, new_slot);\r\n} while (new_slot);\r\nmutex_lock(&ctrl->crit_sect);\r\ngreen_LED_on (ctrl, hp_slot);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq (ctrl);\r\nmutex_unlock(&ctrl->crit_sect);\r\n} else {\r\nmutex_lock(&ctrl->crit_sect);\r\namber_LED_on (ctrl, hp_slot);\r\ngreen_LED_off (ctrl, hp_slot);\r\nslot_disable (ctrl, hp_slot);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq (ctrl);\r\nmutex_unlock(&ctrl->crit_sect);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 remove_board(struct pci_func *func, u32 replace_flag, struct controller *ctrl)\r\n{\r\nint index;\r\nu8 skip = 0;\r\nu8 device;\r\nu8 hp_slot;\r\nu8 temp_byte;\r\nu32 rc;\r\nstruct resource_lists res_lists;\r\nstruct pci_func *temp_func;\r\nif (cpqhp_unconfigure_device(func))\r\nreturn 1;\r\ndevice = func->device;\r\nhp_slot = func->device - ctrl->slot_device_offset;\r\ndbg("In %s, hp_slot = %d\n", __func__, hp_slot);\r\nif (replace_flag || !ctrl->add_support)\r\nrc = cpqhp_save_base_addr_length(ctrl, func);\r\nelse if (!func->bus_head && !func->mem_head &&\r\n!func->p_mem_head && !func->io_head) {\r\nindex = 0;\r\ntemp_func = cpqhp_slot_find(func->bus, func->device, index++);\r\nwhile (temp_func) {\r\nif (temp_func->bus_head || temp_func->mem_head\r\n|| temp_func->p_mem_head || temp_func->io_head) {\r\nskip = 1;\r\nbreak;\r\n}\r\ntemp_func = cpqhp_slot_find(temp_func->bus, temp_func->device, index++);\r\n}\r\nif (!skip)\r\nrc = cpqhp_save_used_resources(ctrl, func);\r\n}\r\nif (func->is_a_board)\r\nfunc->status = 0x01;\r\nfunc->configured = 0;\r\nmutex_lock(&ctrl->crit_sect);\r\ngreen_LED_off (ctrl, hp_slot);\r\nslot_disable (ctrl, hp_slot);\r\nset_SOGO(ctrl);\r\ntemp_byte = readb(ctrl->hpc_reg + SLOT_SERR);\r\ntemp_byte &= ~(0x01 << hp_slot);\r\nwriteb(temp_byte, ctrl->hpc_reg + SLOT_SERR);\r\nwait_for_ctrl_irq (ctrl);\r\nmutex_unlock(&ctrl->crit_sect);\r\nif (!replace_flag && ctrl->add_support) {\r\nwhile (func) {\r\nres_lists.io_head = ctrl->io_head;\r\nres_lists.mem_head = ctrl->mem_head;\r\nres_lists.p_mem_head = ctrl->p_mem_head;\r\nres_lists.bus_head = ctrl->bus_head;\r\ncpqhp_return_board_resources(func, &res_lists);\r\nctrl->io_head = res_lists.io_head;\r\nctrl->mem_head = res_lists.mem_head;\r\nctrl->p_mem_head = res_lists.p_mem_head;\r\nctrl->bus_head = res_lists.bus_head;\r\ncpqhp_resource_sort_and_combine(&(ctrl->mem_head));\r\ncpqhp_resource_sort_and_combine(&(ctrl->p_mem_head));\r\ncpqhp_resource_sort_and_combine(&(ctrl->io_head));\r\ncpqhp_resource_sort_and_combine(&(ctrl->bus_head));\r\nif (is_bridge(func)) {\r\nbridge_slot_remove(func);\r\n} else\r\nslot_remove(func);\r\nfunc = cpqhp_slot_find(ctrl->bus, device, 0);\r\n}\r\nfunc = cpqhp_slot_create(ctrl->bus);\r\nif (func == NULL)\r\nreturn 1;\r\nfunc->bus = ctrl->bus;\r\nfunc->device = device;\r\nfunc->function = 0;\r\nfunc->configured = 0;\r\nfunc->switch_save = 0x10;\r\nfunc->is_a_board = 0;\r\nfunc->p_task_event = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pushbutton_helper_thread(unsigned long data)\r\n{\r\npushbutton_pending = data;\r\nwake_up_process(cpqhp_event_thread);\r\n}\r\nstatic int event_thread(void *data)\r\n{\r\nstruct controller *ctrl;\r\nwhile (1) {\r\ndbg("!!!!event_thread sleeping\n");\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule();\r\nif (kthread_should_stop())\r\nbreak;\r\nif (pushbutton_pending)\r\ncpqhp_pushbutton_thread(pushbutton_pending);\r\nelse\r\nfor (ctrl = cpqhp_ctrl_list; ctrl; ctrl=ctrl->next)\r\ninterrupt_event_handler(ctrl);\r\n}\r\ndbg("event_thread signals exit\n");\r\nreturn 0;\r\n}\r\nint cpqhp_event_start_thread(void)\r\n{\r\ncpqhp_event_thread = kthread_run(event_thread, NULL, "phpd_event");\r\nif (IS_ERR(cpqhp_event_thread)) {\r\nerr ("Can't start up our event thread\n");\r\nreturn PTR_ERR(cpqhp_event_thread);\r\n}\r\nreturn 0;\r\n}\r\nvoid cpqhp_event_stop_thread(void)\r\n{\r\nkthread_stop(cpqhp_event_thread);\r\n}\r\nstatic int update_slot_info(struct controller *ctrl, struct slot *slot)\r\n{\r\nstruct hotplug_slot_info *info;\r\nint result;\r\ninfo = kmalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->power_status = get_slot_enabled(ctrl, slot);\r\ninfo->attention_status = cpq_get_attention_status(ctrl, slot);\r\ninfo->latch_status = cpq_get_latch_status(ctrl, slot);\r\ninfo->adapter_status = get_presence_status(ctrl, slot);\r\nresult = pci_hp_change_slot_info(slot->hotplug_slot, info);\r\nkfree (info);\r\nreturn result;\r\n}\r\nstatic void interrupt_event_handler(struct controller *ctrl)\r\n{\r\nint loop = 0;\r\nint change = 1;\r\nstruct pci_func *func;\r\nu8 hp_slot;\r\nstruct slot *p_slot;\r\nwhile (change) {\r\nchange = 0;\r\nfor (loop = 0; loop < 10; loop++) {\r\nif (ctrl->event_queue[loop].event_type != 0) {\r\nhp_slot = ctrl->event_queue[loop].hp_slot;\r\nfunc = cpqhp_slot_find(ctrl->bus, (hp_slot + ctrl->slot_device_offset), 0);\r\nif (!func)\r\nreturn;\r\np_slot = cpqhp_find_slot(ctrl, hp_slot + ctrl->slot_device_offset);\r\nif (!p_slot)\r\nreturn;\r\ndbg("hp_slot %d, func %p, p_slot %p\n",\r\nhp_slot, func, p_slot);\r\nif (ctrl->event_queue[loop].event_type == INT_BUTTON_PRESS) {\r\ndbg("button pressed\n");\r\n} else if (ctrl->event_queue[loop].event_type ==\r\nINT_BUTTON_CANCEL) {\r\ndbg("button cancel\n");\r\ndel_timer(&p_slot->task_event);\r\nmutex_lock(&ctrl->crit_sect);\r\nif (p_slot->state == BLINKINGOFF_STATE) {\r\ndbg("turn on green LED\n");\r\ngreen_LED_on (ctrl, hp_slot);\r\n} else if (p_slot->state == BLINKINGON_STATE) {\r\ndbg("turn off green LED\n");\r\ngreen_LED_off (ctrl, hp_slot);\r\n}\r\ninfo(msg_button_cancel, p_slot->number);\r\np_slot->state = STATIC_STATE;\r\namber_LED_off (ctrl, hp_slot);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq (ctrl);\r\nmutex_unlock(&ctrl->crit_sect);\r\n}\r\nelse if (ctrl->event_queue[loop].event_type == INT_BUTTON_RELEASE) {\r\ndbg("button release\n");\r\nif (is_slot_enabled (ctrl, hp_slot)) {\r\ndbg("slot is on\n");\r\np_slot->state = BLINKINGOFF_STATE;\r\ninfo(msg_button_off, p_slot->number);\r\n} else {\r\ndbg("slot is off\n");\r\np_slot->state = BLINKINGON_STATE;\r\ninfo(msg_button_on, p_slot->number);\r\n}\r\nmutex_lock(&ctrl->crit_sect);\r\ndbg("blink green LED and turn off amber\n");\r\namber_LED_off (ctrl, hp_slot);\r\ngreen_LED_blink (ctrl, hp_slot);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq (ctrl);\r\nmutex_unlock(&ctrl->crit_sect);\r\ninit_timer(&p_slot->task_event);\r\np_slot->hp_slot = hp_slot;\r\np_slot->ctrl = ctrl;\r\np_slot->task_event.expires = jiffies + 5 * HZ;\r\np_slot->task_event.function = pushbutton_helper_thread;\r\np_slot->task_event.data = (u32) p_slot;\r\ndbg("add_timer p_slot = %p\n", p_slot);\r\nadd_timer(&p_slot->task_event);\r\n}\r\nelse if (ctrl->event_queue[loop].event_type == INT_POWER_FAULT) {\r\ndbg("power fault\n");\r\n} else {\r\nupdate_slot_info(ctrl, p_slot);\r\n}\r\nctrl->event_queue[loop].event_type = 0;\r\nchange = 1;\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nvoid cpqhp_pushbutton_thread(unsigned long slot)\r\n{\r\nu8 hp_slot;\r\nu8 device;\r\nstruct pci_func *func;\r\nstruct slot *p_slot = (struct slot *) slot;\r\nstruct controller *ctrl = (struct controller *) p_slot->ctrl;\r\npushbutton_pending = 0;\r\nhp_slot = p_slot->hp_slot;\r\ndevice = p_slot->device;\r\nif (is_slot_enabled(ctrl, hp_slot)) {\r\np_slot->state = POWEROFF_STATE;\r\nfunc = cpqhp_slot_find(p_slot->bus, p_slot->device, 0);\r\ndbg("In power_down_board, func = %p, ctrl = %p\n", func, ctrl);\r\nif (!func) {\r\ndbg("Error! func NULL in %s\n", __func__);\r\nreturn ;\r\n}\r\nif (cpqhp_process_SS(ctrl, func) != 0) {\r\namber_LED_on(ctrl, hp_slot);\r\ngreen_LED_on(ctrl, hp_slot);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq(ctrl);\r\n}\r\np_slot->state = STATIC_STATE;\r\n} else {\r\np_slot->state = POWERON_STATE;\r\nfunc = cpqhp_slot_find(p_slot->bus, p_slot->device, 0);\r\ndbg("In add_board, func = %p, ctrl = %p\n", func, ctrl);\r\nif (!func) {\r\ndbg("Error! func NULL in %s\n", __func__);\r\nreturn ;\r\n}\r\nif (ctrl != NULL) {\r\nif (cpqhp_process_SI(ctrl, func) != 0) {\r\namber_LED_on(ctrl, hp_slot);\r\ngreen_LED_off(ctrl, hp_slot);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq (ctrl);\r\n}\r\n}\r\np_slot->state = STATIC_STATE;\r\n}\r\nreturn;\r\n}\r\nint cpqhp_process_SI(struct controller *ctrl, struct pci_func *func)\r\n{\r\nu8 device, hp_slot;\r\nu16 temp_word;\r\nu32 tempdword;\r\nint rc;\r\nstruct slot *p_slot;\r\nint physical_slot = 0;\r\ntempdword = 0;\r\ndevice = func->device;\r\nhp_slot = device - ctrl->slot_device_offset;\r\np_slot = cpqhp_find_slot(ctrl, device);\r\nif (p_slot)\r\nphysical_slot = p_slot->number;\r\ntempdword = readl(ctrl->hpc_reg + INT_INPUT_CLEAR);\r\nif (tempdword & (0x01 << hp_slot))\r\nreturn 1;\r\nif (func->is_a_board) {\r\nrc = board_replaced(func, ctrl);\r\n} else {\r\nslot_remove(func);\r\nfunc = cpqhp_slot_create(ctrl->bus);\r\nif (func == NULL)\r\nreturn 1;\r\nfunc->bus = ctrl->bus;\r\nfunc->device = device;\r\nfunc->function = 0;\r\nfunc->configured = 0;\r\nfunc->is_a_board = 1;\r\ntemp_word = ctrl->ctrl_int_comp >> 16;\r\nfunc->presence_save = (temp_word >> hp_slot) & 0x01;\r\nfunc->presence_save |= (temp_word >> (hp_slot + 7)) & 0x02;\r\nif (ctrl->ctrl_int_comp & (0x1L << hp_slot)) {\r\nfunc->switch_save = 0;\r\n} else {\r\nfunc->switch_save = 0x10;\r\n}\r\nrc = board_added(func, ctrl);\r\nif (rc) {\r\nif (is_bridge(func)) {\r\nbridge_slot_remove(func);\r\n} else\r\nslot_remove(func);\r\nfunc = cpqhp_slot_create(ctrl->bus);\r\nif (func == NULL)\r\nreturn 1;\r\nfunc->bus = ctrl->bus;\r\nfunc->device = device;\r\nfunc->function = 0;\r\nfunc->configured = 0;\r\nfunc->is_a_board = 0;\r\ntemp_word = ctrl->ctrl_int_comp >> 16;\r\nfunc->presence_save = (temp_word >> hp_slot) & 0x01;\r\nfunc->presence_save |=\r\n(temp_word >> (hp_slot + 7)) & 0x02;\r\nif (ctrl->ctrl_int_comp & (0x1L << hp_slot)) {\r\nfunc->switch_save = 0;\r\n} else {\r\nfunc->switch_save = 0x10;\r\n}\r\n}\r\n}\r\nif (rc)\r\ndbg("%s: rc = %d\n", __func__, rc);\r\nif (p_slot)\r\nupdate_slot_info(ctrl, p_slot);\r\nreturn rc;\r\n}\r\nint cpqhp_process_SS(struct controller *ctrl, struct pci_func *func)\r\n{\r\nu8 device, class_code, header_type, BCR;\r\nu8 index = 0;\r\nu8 replace_flag;\r\nu32 rc = 0;\r\nunsigned int devfn;\r\nstruct slot *p_slot;\r\nstruct pci_bus *pci_bus = ctrl->pci_bus;\r\nint physical_slot=0;\r\ndevice = func->device;\r\nfunc = cpqhp_slot_find(ctrl->bus, device, index++);\r\np_slot = cpqhp_find_slot(ctrl, device);\r\nif (p_slot)\r\nphysical_slot = p_slot->number;\r\nwhile (func && !rc) {\r\npci_bus->number = func->bus;\r\ndevfn = PCI_DEVFN(func->device, func->function);\r\nrc = pci_bus_read_config_byte (pci_bus, devfn, 0x0B, &class_code);\r\nif (rc)\r\nreturn rc;\r\nif (class_code == PCI_BASE_CLASS_DISPLAY) {\r\nrc = REMOVE_NOT_SUPPORTED;\r\n} else {\r\nrc = pci_bus_read_config_byte (pci_bus, devfn, PCI_HEADER_TYPE, &header_type);\r\nif (rc)\r\nreturn rc;\r\nif ((header_type & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {\r\nrc = pci_bus_read_config_byte (pci_bus, devfn, PCI_BRIDGE_CONTROL, &BCR);\r\nif (rc)\r\nreturn rc;\r\nif (BCR & PCI_BRIDGE_CTL_VGA)\r\nrc = REMOVE_NOT_SUPPORTED;\r\n}\r\n}\r\nfunc = cpqhp_slot_find(ctrl->bus, device, index++);\r\n}\r\nfunc = cpqhp_slot_find(ctrl->bus, device, 0);\r\nif ((func != NULL) && !rc) {\r\nreplace_flag = !(ctrl->add_support);\r\nrc = remove_board(func, replace_flag, ctrl);\r\n} else if (!rc) {\r\nrc = 1;\r\n}\r\nif (p_slot)\r\nupdate_slot_info(ctrl, p_slot);\r\nreturn rc;\r\n}\r\nstatic void switch_leds(struct controller *ctrl, const int num_of_slots,\r\nu32 *work_LED, const int direction)\r\n{\r\nint loop;\r\nfor (loop = 0; loop < num_of_slots; loop++) {\r\nif (direction)\r\n*work_LED = *work_LED >> 1;\r\nelse\r\n*work_LED = *work_LED << 1;\r\nwritel(*work_LED, ctrl->hpc_reg + LED_CONTROL);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq(ctrl);\r\nlong_delay((2*HZ)/10);\r\n}\r\n}\r\nint cpqhp_hardware_test(struct controller *ctrl, int test_num)\r\n{\r\nu32 save_LED;\r\nu32 work_LED;\r\nint loop;\r\nint num_of_slots;\r\nnum_of_slots = readb(ctrl->hpc_reg + SLOT_MASK) & 0x0f;\r\nswitch (test_num) {\r\ncase 1:\r\nsave_LED = readl(ctrl->hpc_reg + LED_CONTROL);\r\nwork_LED = 0x01010101;\r\nswitch_leds(ctrl, num_of_slots, &work_LED, 0);\r\nswitch_leds(ctrl, num_of_slots, &work_LED, 1);\r\nswitch_leds(ctrl, num_of_slots, &work_LED, 0);\r\nswitch_leds(ctrl, num_of_slots, &work_LED, 1);\r\nwork_LED = 0x01010000;\r\nwritel(work_LED, ctrl->hpc_reg + LED_CONTROL);\r\nswitch_leds(ctrl, num_of_slots, &work_LED, 0);\r\nswitch_leds(ctrl, num_of_slots, &work_LED, 1);\r\nwork_LED = 0x00000101;\r\nwritel(work_LED, ctrl->hpc_reg + LED_CONTROL);\r\nswitch_leds(ctrl, num_of_slots, &work_LED, 0);\r\nswitch_leds(ctrl, num_of_slots, &work_LED, 1);\r\nwork_LED = 0x01010000;\r\nwritel(work_LED, ctrl->hpc_reg + LED_CONTROL);\r\nfor (loop = 0; loop < num_of_slots; loop++) {\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq (ctrl);\r\nlong_delay((3*HZ)/10);\r\nwork_LED = work_LED >> 16;\r\nwritel(work_LED, ctrl->hpc_reg + LED_CONTROL);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq (ctrl);\r\nlong_delay((3*HZ)/10);\r\nwork_LED = work_LED << 16;\r\nwritel(work_LED, ctrl->hpc_reg + LED_CONTROL);\r\nwork_LED = work_LED << 1;\r\nwritel(work_LED, ctrl->hpc_reg + LED_CONTROL);\r\n}\r\nwritel(save_LED, ctrl->hpc_reg + LED_CONTROL);\r\nset_SOGO(ctrl);\r\nwait_for_ctrl_irq (ctrl);\r\nbreak;\r\ncase 2:\r\nbreak;\r\ncase 3:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 configure_new_device(struct controller *ctrl, struct pci_func *func,\r\nu8 behind_bridge, struct resource_lists *resources)\r\n{\r\nu8 temp_byte, function, max_functions, stop_it;\r\nint rc;\r\nu32 ID;\r\nstruct pci_func *new_slot;\r\nint index;\r\nnew_slot = func;\r\ndbg("%s\n", __func__);\r\nctrl->pci_bus->number = func->bus;\r\nrc = pci_bus_read_config_byte (ctrl->pci_bus, PCI_DEVFN(func->device, func->function), 0x0E, &temp_byte);\r\nif (rc) {\r\ndbg("%s: rc = %d\n", __func__, rc);\r\nreturn rc;\r\n}\r\nif (temp_byte & 0x80)\r\nmax_functions = 8;\r\nelse\r\nmax_functions = 1;\r\nfunction = 0;\r\ndo {\r\nrc = configure_new_function(ctrl, new_slot, behind_bridge, resources);\r\nif (rc) {\r\ndbg("configure_new_function failed %d\n",rc);\r\nindex = 0;\r\nwhile (new_slot) {\r\nnew_slot = cpqhp_slot_find(new_slot->bus, new_slot->device, index++);\r\nif (new_slot)\r\ncpqhp_return_board_resources(new_slot, resources);\r\n}\r\nreturn rc;\r\n}\r\nfunction++;\r\nstop_it = 0;\r\nwhile ((function < max_functions) && (!stop_it)) {\r\npci_bus_read_config_dword (ctrl->pci_bus, PCI_DEVFN(func->device, function), 0x00, &ID);\r\nif (ID == 0xFFFFFFFF) {\r\nfunction++;\r\n} else {\r\nnew_slot = cpqhp_slot_create(func->bus);\r\nif (new_slot == NULL)\r\nreturn 1;\r\nnew_slot->bus = func->bus;\r\nnew_slot->device = func->device;\r\nnew_slot->function = function;\r\nnew_slot->is_a_board = 1;\r\nnew_slot->status = 0;\r\nstop_it++;\r\n}\r\n}\r\n} while (function < max_functions);\r\ndbg("returning from configure_new_device\n");\r\nreturn 0;\r\n}\r\nstatic int configure_new_function(struct controller *ctrl, struct pci_func *func,\r\nu8 behind_bridge,\r\nstruct resource_lists *resources)\r\n{\r\nint cloop;\r\nu8 IRQ = 0;\r\nu8 temp_byte;\r\nu8 device;\r\nu8 class_code;\r\nu16 command;\r\nu16 temp_word;\r\nu32 temp_dword;\r\nu32 rc;\r\nu32 temp_register;\r\nu32 base;\r\nu32 ID;\r\nunsigned int devfn;\r\nstruct pci_resource *mem_node;\r\nstruct pci_resource *p_mem_node;\r\nstruct pci_resource *io_node;\r\nstruct pci_resource *bus_node;\r\nstruct pci_resource *hold_mem_node;\r\nstruct pci_resource *hold_p_mem_node;\r\nstruct pci_resource *hold_IO_node;\r\nstruct pci_resource *hold_bus_node;\r\nstruct irq_mapping irqs;\r\nstruct pci_func *new_slot;\r\nstruct pci_bus *pci_bus;\r\nstruct resource_lists temp_resources;\r\npci_bus = ctrl->pci_bus;\r\npci_bus->number = func->bus;\r\ndevfn = PCI_DEVFN(func->device, func->function);\r\nrc = pci_bus_read_config_byte(pci_bus, devfn, PCI_HEADER_TYPE, &temp_byte);\r\nif (rc)\r\nreturn rc;\r\nif ((temp_byte & 0x7F) == PCI_HEADER_TYPE_BRIDGE) {\r\ndbg("set Primary bus = %d\n", func->bus);\r\nrc = pci_bus_write_config_byte(pci_bus, devfn, PCI_PRIMARY_BUS, func->bus);\r\nif (rc)\r\nreturn rc;\r\ndbg("find ranges of buses to use\n");\r\nbus_node = get_max_resource(&(resources->bus_head), 1);\r\nif (!bus_node)\r\nreturn -ENOMEM;\r\ntemp_byte = bus_node->base;\r\ndbg("set Secondary bus = %d\n", bus_node->base);\r\nrc = pci_bus_write_config_byte(pci_bus, devfn, PCI_SECONDARY_BUS, temp_byte);\r\nif (rc)\r\nreturn rc;\r\ntemp_byte = bus_node->base + bus_node->length - 1;\r\ndbg("set subordinate bus = %d\n", bus_node->base + bus_node->length - 1);\r\nrc = pci_bus_write_config_byte(pci_bus, devfn, PCI_SUBORDINATE_BUS, temp_byte);\r\nif (rc)\r\nreturn rc;\r\ntemp_byte = 0x40;\r\nrc = pci_bus_write_config_byte(pci_bus, devfn, PCI_SEC_LATENCY_TIMER, temp_byte);\r\nif (rc)\r\nreturn rc;\r\nrc = pci_bus_write_config_byte(pci_bus, devfn, PCI_LATENCY_TIMER, temp_byte);\r\nif (rc)\r\nreturn rc;\r\ntemp_byte = 0x08;\r\nrc = pci_bus_write_config_byte(pci_bus, devfn, PCI_CACHE_LINE_SIZE, temp_byte);\r\nif (rc)\r\nreturn rc;\r\nio_node = get_max_resource(&(resources->io_head), 0x1000);\r\nif (!io_node)\r\nreturn -ENOMEM;\r\nmem_node = get_max_resource(&(resources->mem_head), 0x100000);\r\nif (!mem_node)\r\nreturn -ENOMEM;\r\np_mem_node = get_max_resource(&(resources->p_mem_head), 0x100000);\r\nif (!p_mem_node)\r\nreturn -ENOMEM;\r\ndbg("Setup the IO, memory, and prefetchable windows\n");\r\ndbg("io_node\n");\r\ndbg("(base, len, next) (%x, %x, %p)\n", io_node->base,\r\nio_node->length, io_node->next);\r\ndbg("mem_node\n");\r\ndbg("(base, len, next) (%x, %x, %p)\n", mem_node->base,\r\nmem_node->length, mem_node->next);\r\ndbg("p_mem_node\n");\r\ndbg("(base, len, next) (%x, %x, %p)\n", p_mem_node->base,\r\np_mem_node->length, p_mem_node->next);\r\nif (!resources->irqs) {\r\nirqs.barber_pole = 0;\r\nirqs.interrupt[0] = 0;\r\nirqs.interrupt[1] = 0;\r\nirqs.interrupt[2] = 0;\r\nirqs.interrupt[3] = 0;\r\nirqs.valid_INT = 0;\r\n} else {\r\nirqs.barber_pole = resources->irqs->barber_pole;\r\nirqs.interrupt[0] = resources->irqs->interrupt[0];\r\nirqs.interrupt[1] = resources->irqs->interrupt[1];\r\nirqs.interrupt[2] = resources->irqs->interrupt[2];\r\nirqs.interrupt[3] = resources->irqs->interrupt[3];\r\nirqs.valid_INT = resources->irqs->valid_INT;\r\n}\r\ntemp_resources.bus_head = bus_node;\r\ntemp_resources.io_head = io_node;\r\ntemp_resources.mem_head = mem_node;\r\ntemp_resources.p_mem_head = p_mem_node;\r\ntemp_resources.irqs = &irqs;\r\nhold_bus_node = kmalloc(sizeof(*hold_bus_node), GFP_KERNEL);\r\nhold_IO_node = kmalloc(sizeof(*hold_IO_node), GFP_KERNEL);\r\nhold_mem_node = kmalloc(sizeof(*hold_mem_node), GFP_KERNEL);\r\nhold_p_mem_node = kmalloc(sizeof(*hold_p_mem_node), GFP_KERNEL);\r\nif (!hold_bus_node || !hold_IO_node || !hold_mem_node || !hold_p_mem_node) {\r\nkfree(hold_bus_node);\r\nkfree(hold_IO_node);\r\nkfree(hold_mem_node);\r\nkfree(hold_p_mem_node);\r\nreturn 1;\r\n}\r\nmemcpy(hold_bus_node, bus_node, sizeof(struct pci_resource));\r\nbus_node->base += 1;\r\nbus_node->length -= 1;\r\nbus_node->next = NULL;\r\nmemcpy(hold_IO_node, io_node, sizeof(struct pci_resource));\r\nio_node->next = NULL;\r\ntemp_byte = io_node->base >> 8;\r\nrc = pci_bus_write_config_byte(pci_bus, devfn, PCI_IO_BASE, temp_byte);\r\ntemp_byte = (io_node->base + io_node->length - 1) >> 8;\r\nrc = pci_bus_write_config_byte(pci_bus, devfn, PCI_IO_LIMIT, temp_byte);\r\nmemcpy(hold_mem_node, mem_node, sizeof(struct pci_resource));\r\nmem_node->next = NULL;\r\ntemp_word = mem_node->base >> 16;\r\nrc = pci_bus_write_config_word(pci_bus, devfn, PCI_MEMORY_BASE, temp_word);\r\ntemp_word = (mem_node->base + mem_node->length - 1) >> 16;\r\nrc = pci_bus_write_config_word(pci_bus, devfn, PCI_MEMORY_LIMIT, temp_word);\r\nmemcpy(hold_p_mem_node, p_mem_node, sizeof(struct pci_resource));\r\np_mem_node->next = NULL;\r\ntemp_word = p_mem_node->base >> 16;\r\nrc = pci_bus_write_config_word (pci_bus, devfn, PCI_PREF_MEMORY_BASE, temp_word);\r\ntemp_word = (p_mem_node->base + p_mem_node->length - 1) >> 16;\r\nrc = pci_bus_write_config_word (pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, temp_word);\r\nirqs.barber_pole--;\r\nrc = 0;\r\nfor (device = 0; (device <= 0x1F) && !rc; device++) {\r\nirqs.barber_pole = (irqs.barber_pole + 1) & 0x03;\r\nID = 0xFFFFFFFF;\r\npci_bus->number = hold_bus_node->base;\r\npci_bus_read_config_dword (pci_bus, PCI_DEVFN(device, 0), 0x00, &ID);\r\npci_bus->number = func->bus;\r\nif (ID != 0xFFFFFFFF) {\r\nnew_slot = cpqhp_slot_create(hold_bus_node->base);\r\nif (new_slot == NULL) {\r\nrc = -ENOMEM;\r\ncontinue;\r\n}\r\nnew_slot->bus = hold_bus_node->base;\r\nnew_slot->device = device;\r\nnew_slot->function = 0;\r\nnew_slot->is_a_board = 1;\r\nnew_slot->status = 0;\r\nrc = configure_new_device(ctrl, new_slot, 1, &temp_resources);\r\ndbg("configure_new_device rc=0x%x\n",rc);\r\n}\r\n}\r\nif (rc)\r\ngoto free_and_out;\r\nif (resources->irqs) {\r\nresources->irqs->interrupt[0] = irqs.interrupt[0];\r\nresources->irqs->interrupt[1] = irqs.interrupt[1];\r\nresources->irqs->interrupt[2] = irqs.interrupt[2];\r\nresources->irqs->interrupt[3] = irqs.interrupt[3];\r\nresources->irqs->valid_INT = irqs.valid_INT;\r\n} else if (!behind_bridge) {\r\nfor (cloop = 0; cloop < 4; cloop++) {\r\nif (irqs.valid_INT & (0x01 << cloop)) {\r\nrc = cpqhp_set_irq(func->bus, func->device,\r\ncloop + 1, irqs.interrupt[cloop]);\r\nif (rc)\r\ngoto free_and_out;\r\n}\r\n}\r\n}\r\nif (bus_node && temp_resources.bus_head) {\r\nhold_bus_node->length = bus_node->base - hold_bus_node->base;\r\nhold_bus_node->next = func->bus_head;\r\nfunc->bus_head = hold_bus_node;\r\ntemp_byte = temp_resources.bus_head->base - 1;\r\nrc = pci_bus_write_config_byte (pci_bus, devfn, PCI_SUBORDINATE_BUS, temp_byte);\r\nif (temp_resources.bus_head->length == 0) {\r\nkfree(temp_resources.bus_head);\r\ntemp_resources.bus_head = NULL;\r\n} else {\r\nreturn_resource(&(resources->bus_head), temp_resources.bus_head);\r\n}\r\n}\r\nif (hold_IO_node && temp_resources.io_head) {\r\nio_node = do_pre_bridge_resource_split(&(temp_resources.io_head),\r\n&hold_IO_node, 0x1000);\r\nif (io_node) {\r\nhold_IO_node->base = io_node->base + io_node->length;\r\ntemp_byte = (hold_IO_node->base) >> 8;\r\nrc = pci_bus_write_config_word (pci_bus, devfn, PCI_IO_BASE, temp_byte);\r\nreturn_resource(&(resources->io_head), io_node);\r\n}\r\nio_node = do_bridge_resource_split(&(temp_resources.io_head), 0x1000);\r\nif (io_node) {\r\nhold_IO_node->length = io_node->base - hold_IO_node->base;\r\nif (hold_IO_node->length) {\r\nhold_IO_node->next = func->io_head;\r\nfunc->io_head = hold_IO_node;\r\ntemp_byte = (io_node->base - 1) >> 8;\r\nrc = pci_bus_write_config_byte (pci_bus, devfn, PCI_IO_LIMIT, temp_byte);\r\nreturn_resource(&(resources->io_head), io_node);\r\n} else {\r\ntemp_word = 0x0000;\r\nrc = pci_bus_write_config_word (pci_bus, devfn, PCI_IO_LIMIT, temp_word);\r\nreturn_resource(&(resources->io_head), io_node);\r\nkfree(hold_IO_node);\r\n}\r\n} else {\r\nhold_IO_node->next = func->io_head;\r\nfunc->io_head = hold_IO_node;\r\n}\r\n} else if (hold_IO_node) {\r\nhold_IO_node->next = func->io_head;\r\nfunc->io_head = hold_IO_node;\r\n}\r\nif (hold_mem_node && temp_resources.mem_head) {\r\nmem_node = do_pre_bridge_resource_split(&(temp_resources. mem_head),\r\n&hold_mem_node, 0x100000);\r\nif (mem_node) {\r\nhold_mem_node->base = mem_node->base + mem_node->length;\r\ntemp_word = (hold_mem_node->base) >> 16;\r\nrc = pci_bus_write_config_word (pci_bus, devfn, PCI_MEMORY_BASE, temp_word);\r\nreturn_resource(&(resources->mem_head), mem_node);\r\n}\r\nmem_node = do_bridge_resource_split(&(temp_resources.mem_head), 0x100000);\r\nif (mem_node) {\r\nhold_mem_node->length = mem_node->base - hold_mem_node->base;\r\nif (hold_mem_node->length) {\r\nhold_mem_node->next = func->mem_head;\r\nfunc->mem_head = hold_mem_node;\r\ntemp_word = (mem_node->base - 1) >> 16;\r\nrc = pci_bus_write_config_word (pci_bus, devfn, PCI_MEMORY_LIMIT, temp_word);\r\nreturn_resource(&(resources->mem_head), mem_node);\r\n} else {\r\ntemp_word = 0x0000;\r\nrc = pci_bus_write_config_word (pci_bus, devfn, PCI_MEMORY_LIMIT, temp_word);\r\nreturn_resource(&(resources->mem_head), mem_node);\r\nkfree(hold_mem_node);\r\n}\r\n} else {\r\nhold_mem_node->next = func->mem_head;\r\nfunc->mem_head = hold_mem_node;\r\n}\r\n} else if (hold_mem_node) {\r\nhold_mem_node->next = func->mem_head;\r\nfunc->mem_head = hold_mem_node;\r\n}\r\nif (temp_resources.p_mem_head) {\r\np_mem_node = do_pre_bridge_resource_split(&(temp_resources.p_mem_head),\r\n&hold_p_mem_node, 0x100000);\r\nif (p_mem_node) {\r\nhold_p_mem_node->base = p_mem_node->base + p_mem_node->length;\r\ntemp_word = (hold_p_mem_node->base) >> 16;\r\nrc = pci_bus_write_config_word (pci_bus, devfn, PCI_PREF_MEMORY_BASE, temp_word);\r\nreturn_resource(&(resources->p_mem_head), p_mem_node);\r\n}\r\np_mem_node = do_bridge_resource_split(&(temp_resources.p_mem_head), 0x100000);\r\nif (p_mem_node) {\r\nhold_p_mem_node->length = p_mem_node->base - hold_p_mem_node->base;\r\nif (hold_p_mem_node->length) {\r\nhold_p_mem_node->next = func->p_mem_head;\r\nfunc->p_mem_head = hold_p_mem_node;\r\ntemp_word = (p_mem_node->base - 1) >> 16;\r\nrc = pci_bus_write_config_word (pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, temp_word);\r\nreturn_resource(&(resources->p_mem_head), p_mem_node);\r\n} else {\r\ntemp_word = 0x0000;\r\nrc = pci_bus_write_config_word (pci_bus, devfn, PCI_PREF_MEMORY_LIMIT, temp_word);\r\nreturn_resource(&(resources->p_mem_head), p_mem_node);\r\nkfree(hold_p_mem_node);\r\n}\r\n} else {\r\nhold_p_mem_node->next = func->p_mem_head;\r\nfunc->p_mem_head = hold_p_mem_node;\r\n}\r\n} else if (hold_p_mem_node) {\r\nhold_p_mem_node->next = func->p_mem_head;\r\nfunc->p_mem_head = hold_p_mem_node;\r\n}\r\ncommand = 0x0157;\r\nrc = pci_bus_write_config_word (pci_bus, devfn, PCI_COMMAND, command);\r\ncommand = 0x07;\r\nrc = pci_bus_write_config_word (pci_bus, devfn, PCI_BRIDGE_CONTROL, command);\r\n} else if ((temp_byte & 0x7F) == PCI_HEADER_TYPE_NORMAL) {\r\nrc = pci_bus_read_config_byte (pci_bus, devfn, 0x0B, &class_code);\r\nif (class_code == PCI_BASE_CLASS_DISPLAY) {\r\nreturn DEVICE_TYPE_NOT_SUPPORTED;\r\n}\r\nfor (cloop = 0x10; cloop <= 0x24; cloop += 4) {\r\ntemp_register = 0xFFFFFFFF;\r\ndbg("CND: bus=%d, devfn=%d, offset=%d\n", pci_bus->number, devfn, cloop);\r\nrc = pci_bus_write_config_dword (pci_bus, devfn, cloop, temp_register);\r\nrc = pci_bus_read_config_dword (pci_bus, devfn, cloop, &temp_register);\r\ndbg("CND: base = 0x%x\n", temp_register);\r\nif (temp_register) {\r\nif ((temp_register & 0x03L) == 0x01) {\r\nbase = temp_register & 0xFFFFFFFC;\r\nbase = ~base + 1;\r\ndbg("CND: length = 0x%x\n", base);\r\nio_node = get_io_resource(&(resources->io_head), base);\r\ndbg("Got io_node start = %8.8x, length = %8.8x next (%p)\n",\r\nio_node->base, io_node->length, io_node->next);\r\ndbg("func (%p) io_head (%p)\n", func, func->io_head);\r\nif (io_node) {\r\nbase = io_node->base;\r\nio_node->next = func->io_head;\r\nfunc->io_head = io_node;\r\n} else\r\nreturn -ENOMEM;\r\n} else if ((temp_register & 0x0BL) == 0x08) {\r\nbase = temp_register & 0xFFFFFFF0;\r\nbase = ~base + 1;\r\ndbg("CND: length = 0x%x\n", base);\r\np_mem_node = get_resource(&(resources->p_mem_head), base);\r\nif (p_mem_node) {\r\nbase = p_mem_node->base;\r\np_mem_node->next = func->p_mem_head;\r\nfunc->p_mem_head = p_mem_node;\r\n} else\r\nreturn -ENOMEM;\r\n} else if ((temp_register & 0x0BL) == 0x00) {\r\nbase = temp_register & 0xFFFFFFF0;\r\nbase = ~base + 1;\r\ndbg("CND: length = 0x%x\n", base);\r\nmem_node = get_resource(&(resources->mem_head), base);\r\nif (mem_node) {\r\nbase = mem_node->base;\r\nmem_node->next = func->mem_head;\r\nfunc->mem_head = mem_node;\r\n} else\r\nreturn -ENOMEM;\r\n} else {\r\nreturn NOT_ENOUGH_RESOURCES;\r\n}\r\nrc = pci_bus_write_config_dword(pci_bus, devfn, cloop, base);\r\nif ((temp_register & 0x07L) == 0x04) {\r\ncloop += 4;\r\nbase = 0;\r\nrc = pci_bus_write_config_dword(pci_bus, devfn, cloop, base);\r\n}\r\n}\r\n}\r\nif (cpqhp_legacy_mode) {\r\nrc = pci_bus_read_config_byte (pci_bus, devfn,\r\nPCI_INTERRUPT_PIN, &temp_byte);\r\nif (temp_byte && resources->irqs &&\r\n(resources->irqs->valid_INT &\r\n(0x01 << ((temp_byte + resources->irqs->barber_pole - 1) & 0x03)))) {\r\nIRQ = resources->irqs->interrupt[(temp_byte +\r\nresources->irqs->barber_pole - 1) & 0x03];\r\n} else {\r\nrc = pci_bus_read_config_byte (pci_bus, devfn, 0x0B, &class_code);\r\nif (class_code == PCI_BASE_CLASS_STORAGE)\r\nIRQ = cpqhp_disk_irq;\r\nelse\r\nIRQ = cpqhp_nic_irq;\r\n}\r\nrc = pci_bus_write_config_byte (pci_bus, devfn, PCI_INTERRUPT_LINE, IRQ);\r\n}\r\nif (!behind_bridge) {\r\nrc = cpqhp_set_irq(func->bus, func->device, temp_byte, IRQ);\r\nif (rc)\r\nreturn 1;\r\n} else {\r\nresources->irqs->interrupt[(temp_byte + resources->irqs->barber_pole - 1) & 0x03] = IRQ;\r\nresources->irqs->valid_INT |= 0x01 << (temp_byte + resources->irqs->barber_pole - 1) & 0x03;\r\n}\r\ntemp_byte = 0x40;\r\nrc = pci_bus_write_config_byte(pci_bus, devfn,\r\nPCI_LATENCY_TIMER, temp_byte);\r\ntemp_byte = 0x08;\r\nrc = pci_bus_write_config_byte(pci_bus, devfn,\r\nPCI_CACHE_LINE_SIZE, temp_byte);\r\ntemp_dword = 0x00L;\r\nrc = pci_bus_write_config_word(pci_bus, devfn,\r\nPCI_ROM_ADDRESS, temp_dword);\r\ntemp_word = 0x0157;\r\nrc = pci_bus_write_config_word (pci_bus, devfn,\r\nPCI_COMMAND, temp_word);\r\n} else {\r\nreturn DEVICE_TYPE_NOT_SUPPORTED;\r\n}\r\nfunc->configured = 1;\r\nreturn 0;\r\nfree_and_out:\r\ncpqhp_destroy_resource_list (&temp_resources);\r\nreturn_resource(&(resources-> bus_head), hold_bus_node);\r\nreturn_resource(&(resources-> io_head), hold_IO_node);\r\nreturn_resource(&(resources-> mem_head), hold_mem_node);\r\nreturn_resource(&(resources-> p_mem_head), hold_p_mem_node);\r\nreturn rc;\r\n}
