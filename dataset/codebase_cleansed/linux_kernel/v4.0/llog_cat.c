static int llog_cat_new_log(const struct lu_env *env,\r\nstruct llog_handle *cathandle,\r\nstruct llog_handle *loghandle,\r\nstruct thandle *th)\r\n{\r\nstruct llog_log_hdr *llh;\r\nstruct llog_logid_rec rec = { { 0 }, };\r\nint rc, index, bitmap_size;\r\nllh = cathandle->lgh_hdr;\r\nbitmap_size = LLOG_BITMAP_SIZE(llh);\r\nindex = (cathandle->lgh_last_idx + 1) % bitmap_size;\r\nif (llh->llh_cat_idx == index) {\r\nCERROR("no free catalog slots for log...\n");\r\nreturn -ENOSPC;\r\n}\r\nif (OBD_FAIL_CHECK(OBD_FAIL_MDS_LLOG_CREATE_FAILED))\r\nreturn -ENOSPC;\r\nrc = llog_create(env, loghandle, th);\r\nif (rc == -EEXIST) {\r\nreturn 0;\r\n} else if (rc != 0) {\r\nCERROR("%s: can't create new plain llog in catalog: rc = %d\n",\r\nloghandle->lgh_ctxt->loc_obd->obd_name, rc);\r\nreturn rc;\r\n}\r\nrc = llog_init_handle(env, loghandle,\r\nLLOG_F_IS_PLAIN | LLOG_F_ZAP_WHEN_EMPTY,\r\n&cathandle->lgh_hdr->llh_tgtuuid);\r\nif (rc)\r\ngoto out_destroy;\r\nif (index == 0)\r\nindex = 1;\r\nspin_lock(&loghandle->lgh_hdr_lock);\r\nllh->llh_count++;\r\nif (ext2_set_bit(index, llh->llh_bitmap)) {\r\nCERROR("argh, index %u already set in log bitmap?\n",\r\nindex);\r\nspin_unlock(&loghandle->lgh_hdr_lock);\r\nLBUG();\r\n}\r\nspin_unlock(&loghandle->lgh_hdr_lock);\r\ncathandle->lgh_last_idx = index;\r\nllh->llh_tail.lrt_index = index;\r\nCDEBUG(D_RPCTRACE,\r\n"new recovery log "DOSTID":%x for index %u of catalog"\r\nDOSTID"\n", POSTID(&loghandle->lgh_id.lgl_oi),\r\nloghandle->lgh_id.lgl_ogen, index,\r\nPOSTID(&cathandle->lgh_id.lgl_oi));\r\nrec.lid_hdr.lrh_len = sizeof(rec);\r\nrec.lid_hdr.lrh_index = index;\r\nrec.lid_hdr.lrh_type = LLOG_LOGID_MAGIC;\r\nrec.lid_id = loghandle->lgh_id;\r\nrec.lid_tail.lrt_len = sizeof(rec);\r\nrec.lid_tail.lrt_index = index;\r\nrc = llog_write_rec(env, cathandle, &rec.lid_hdr,\r\n&loghandle->u.phd.phd_cookie, 1, NULL, index, th);\r\nif (rc < 0)\r\ngoto out_destroy;\r\nloghandle->lgh_hdr->llh_cat_idx = index;\r\nreturn 0;\r\nout_destroy:\r\nllog_destroy(env, loghandle);\r\nreturn rc;\r\n}\r\nint llog_cat_id2handle(const struct lu_env *env, struct llog_handle *cathandle,\r\nstruct llog_handle **res, struct llog_logid *logid)\r\n{\r\nstruct llog_handle *loghandle;\r\nint rc = 0;\r\nif (cathandle == NULL)\r\nreturn -EBADF;\r\ndown_write(&cathandle->lgh_lock);\r\nlist_for_each_entry(loghandle, &cathandle->u.chd.chd_head,\r\nu.phd.phd_entry) {\r\nstruct llog_logid *cgl = &loghandle->lgh_id;\r\nif (ostid_id(&cgl->lgl_oi) == ostid_id(&logid->lgl_oi) &&\r\nostid_seq(&cgl->lgl_oi) == ostid_seq(&logid->lgl_oi)) {\r\nif (cgl->lgl_ogen != logid->lgl_ogen) {\r\nCERROR("%s: log "DOSTID" generation %x != %x\n",\r\nloghandle->lgh_ctxt->loc_obd->obd_name,\r\nPOSTID(&logid->lgl_oi), cgl->lgl_ogen,\r\nlogid->lgl_ogen);\r\ncontinue;\r\n}\r\nloghandle->u.phd.phd_cat_handle = cathandle;\r\nup_write(&cathandle->lgh_lock);\r\nrc = 0;\r\ngoto out;\r\n}\r\n}\r\nup_write(&cathandle->lgh_lock);\r\nrc = llog_open(env, cathandle->lgh_ctxt, &loghandle, logid, NULL,\r\nLLOG_OPEN_EXISTS);\r\nif (rc < 0) {\r\nCERROR("%s: error opening log id "DOSTID":%x: rc = %d\n",\r\ncathandle->lgh_ctxt->loc_obd->obd_name,\r\nPOSTID(&logid->lgl_oi), logid->lgl_ogen, rc);\r\nreturn rc;\r\n}\r\nrc = llog_init_handle(env, loghandle, LLOG_F_IS_PLAIN, NULL);\r\nif (rc < 0) {\r\nllog_close(env, loghandle);\r\nloghandle = NULL;\r\nreturn rc;\r\n}\r\ndown_write(&cathandle->lgh_lock);\r\nlist_add(&loghandle->u.phd.phd_entry, &cathandle->u.chd.chd_head);\r\nup_write(&cathandle->lgh_lock);\r\nloghandle->u.phd.phd_cat_handle = cathandle;\r\nloghandle->u.phd.phd_cookie.lgc_lgl = cathandle->lgh_id;\r\nloghandle->u.phd.phd_cookie.lgc_index =\r\nloghandle->lgh_hdr->llh_cat_idx;\r\nout:\r\nllog_handle_get(loghandle);\r\n*res = loghandle;\r\nreturn 0;\r\n}\r\nint llog_cat_close(const struct lu_env *env, struct llog_handle *cathandle)\r\n{\r\nstruct llog_handle *loghandle, *n;\r\nint rc;\r\nlist_for_each_entry_safe(loghandle, n, &cathandle->u.chd.chd_head,\r\nu.phd.phd_entry) {\r\nstruct llog_log_hdr *llh = loghandle->lgh_hdr;\r\nint index;\r\nlist_del_init(&loghandle->u.phd.phd_entry);\r\nllh = loghandle->lgh_hdr;\r\nif (loghandle->lgh_obj != NULL && llh != NULL &&\r\n(llh->llh_flags & LLOG_F_ZAP_WHEN_EMPTY) &&\r\n(llh->llh_count == 1)) {\r\nrc = llog_destroy(env, loghandle);\r\nif (rc)\r\nCERROR("%s: failure destroying log during cleanup: rc = %d\n",\r\nloghandle->lgh_ctxt->loc_obd->obd_name,\r\nrc);\r\nindex = loghandle->u.phd.phd_cookie.lgc_index;\r\nllog_cat_cleanup(env, cathandle, NULL, index);\r\n}\r\nllog_close(env, loghandle);\r\n}\r\nif (cathandle->lgh_ctxt->loc_handle == cathandle)\r\ncathandle->lgh_ctxt->loc_handle = NULL;\r\nrc = llog_close(env, cathandle);\r\nreturn rc;\r\n}\r\nstatic struct llog_handle *llog_cat_current_log(struct llog_handle *cathandle,\r\nstruct thandle *th)\r\n{\r\nstruct llog_handle *loghandle = NULL;\r\ndown_read_nested(&cathandle->lgh_lock, LLOGH_CAT);\r\nloghandle = cathandle->u.chd.chd_current_log;\r\nif (loghandle) {\r\nstruct llog_log_hdr *llh;\r\ndown_write_nested(&loghandle->lgh_lock, LLOGH_LOG);\r\nllh = loghandle->lgh_hdr;\r\nif (llh == NULL ||\r\nloghandle->lgh_last_idx < LLOG_BITMAP_SIZE(llh) - 1) {\r\nup_read(&cathandle->lgh_lock);\r\nreturn loghandle;\r\n} else {\r\nup_write(&loghandle->lgh_lock);\r\n}\r\n}\r\nup_read(&cathandle->lgh_lock);\r\ndown_write_nested(&cathandle->lgh_lock, LLOGH_CAT);\r\nloghandle = cathandle->u.chd.chd_current_log;\r\nif (loghandle) {\r\nstruct llog_log_hdr *llh;\r\ndown_write_nested(&loghandle->lgh_lock, LLOGH_LOG);\r\nllh = loghandle->lgh_hdr;\r\nLASSERT(llh);\r\nif (loghandle->lgh_last_idx < LLOG_BITMAP_SIZE(llh) - 1) {\r\nup_write(&cathandle->lgh_lock);\r\nreturn loghandle;\r\n} else {\r\nup_write(&loghandle->lgh_lock);\r\n}\r\n}\r\nCDEBUG(D_INODE, "use next log\n");\r\nloghandle = cathandle->u.chd.chd_next_log;\r\ncathandle->u.chd.chd_current_log = loghandle;\r\ncathandle->u.chd.chd_next_log = NULL;\r\ndown_write_nested(&loghandle->lgh_lock, LLOGH_LOG);\r\nup_write(&cathandle->lgh_lock);\r\nLASSERT(loghandle);\r\nreturn loghandle;\r\n}\r\nint llog_cat_add_rec(const struct lu_env *env, struct llog_handle *cathandle,\r\nstruct llog_rec_hdr *rec, struct llog_cookie *reccookie,\r\nvoid *buf, struct thandle *th)\r\n{\r\nstruct llog_handle *loghandle;\r\nint rc;\r\nLASSERT(rec->lrh_len <= LLOG_CHUNK_SIZE);\r\nloghandle = llog_cat_current_log(cathandle, th);\r\nLASSERT(!IS_ERR(loghandle));\r\nif (!llog_exist(loghandle)) {\r\nrc = llog_cat_new_log(env, cathandle, loghandle, th);\r\nif (rc < 0) {\r\nup_write(&loghandle->lgh_lock);\r\nreturn rc;\r\n}\r\n}\r\nrc = llog_write_rec(env, loghandle, rec, reccookie, 1, buf, -1, th);\r\nif (rc < 0)\r\nCDEBUG_LIMIT(rc == -ENOSPC ? D_HA : D_ERROR,\r\n"llog_write_rec %d: lh=%p\n", rc, loghandle);\r\nup_write(&loghandle->lgh_lock);\r\nif (rc == -ENOSPC) {\r\nloghandle = llog_cat_current_log(cathandle, th);\r\nLASSERT(!IS_ERR(loghandle));\r\nif (!llog_exist(loghandle)) {\r\nrc = llog_cat_new_log(env, cathandle, loghandle, th);\r\nif (rc < 0) {\r\nup_write(&loghandle->lgh_lock);\r\nreturn rc;\r\n}\r\n}\r\nrc = llog_write_rec(env, loghandle, rec, reccookie, 1, buf,\r\n-1, th);\r\nif (rc < 0)\r\nCERROR("llog_write_rec %d: lh=%p\n", rc, loghandle);\r\nup_write(&loghandle->lgh_lock);\r\n}\r\nreturn rc;\r\n}\r\nint llog_cat_declare_add_rec(const struct lu_env *env,\r\nstruct llog_handle *cathandle,\r\nstruct llog_rec_hdr *rec, struct thandle *th)\r\n{\r\nstruct llog_handle *loghandle, *next;\r\nint rc = 0;\r\nif (cathandle->u.chd.chd_current_log == NULL) {\r\ndown_write(&cathandle->lgh_lock);\r\nif (cathandle->u.chd.chd_current_log == NULL) {\r\nrc = llog_open(env, cathandle->lgh_ctxt, &loghandle,\r\nNULL, NULL, LLOG_OPEN_NEW);\r\nif (rc == 0) {\r\ncathandle->u.chd.chd_current_log = loghandle;\r\nlist_add_tail(&loghandle->u.phd.phd_entry,\r\n&cathandle->u.chd.chd_head);\r\n}\r\n}\r\nup_write(&cathandle->lgh_lock);\r\n} else if (cathandle->u.chd.chd_next_log == NULL) {\r\ndown_write(&cathandle->lgh_lock);\r\nif (cathandle->u.chd.chd_next_log == NULL) {\r\nrc = llog_open(env, cathandle->lgh_ctxt, &loghandle,\r\nNULL, NULL, LLOG_OPEN_NEW);\r\nif (rc == 0) {\r\ncathandle->u.chd.chd_next_log = loghandle;\r\nlist_add_tail(&loghandle->u.phd.phd_entry,\r\n&cathandle->u.chd.chd_head);\r\n}\r\n}\r\nup_write(&cathandle->lgh_lock);\r\n}\r\nif (rc)\r\ngoto out;\r\nif (!llog_exist(cathandle->u.chd.chd_current_log)) {\r\nrc = llog_declare_create(env, cathandle->u.chd.chd_current_log,\r\nth);\r\nif (rc)\r\ngoto out;\r\nllog_declare_write_rec(env, cathandle, NULL, -1, th);\r\n}\r\nrc = llog_declare_write_rec(env, cathandle->u.chd.chd_current_log,\r\nrec, -1, th);\r\nif (rc)\r\ngoto out;\r\nnext = cathandle->u.chd.chd_next_log;\r\nif (next) {\r\nif (!llog_exist(next)) {\r\nrc = llog_declare_create(env, next, th);\r\nllog_declare_write_rec(env, cathandle, NULL, -1, th);\r\n}\r\nllog_declare_write_rec(env, next, rec, -1, th);\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nint llog_cat_add(const struct lu_env *env, struct llog_handle *cathandle,\r\nstruct llog_rec_hdr *rec, struct llog_cookie *reccookie,\r\nvoid *buf)\r\n{\r\nstruct llog_ctxt *ctxt;\r\nstruct dt_device *dt;\r\nstruct thandle *th = NULL;\r\nint rc;\r\nctxt = cathandle->lgh_ctxt;\r\nLASSERT(ctxt);\r\nLASSERT(ctxt->loc_exp);\r\nif (cathandle->lgh_obj != NULL) {\r\ndt = ctxt->loc_exp->exp_obd->obd_lvfs_ctxt.dt;\r\nLASSERT(dt);\r\nth = dt_trans_create(env, dt);\r\nif (IS_ERR(th))\r\nreturn PTR_ERR(th);\r\nrc = llog_cat_declare_add_rec(env, cathandle, rec, th);\r\nif (rc)\r\ngoto out_trans;\r\nrc = dt_trans_start_local(env, dt, th);\r\nif (rc)\r\ngoto out_trans;\r\nrc = llog_cat_add_rec(env, cathandle, rec, reccookie, buf, th);\r\nout_trans:\r\ndt_trans_stop(env, dt, th);\r\n} else {\r\nLASSERT(cathandle->lgh_file != NULL);\r\nrc = llog_cat_declare_add_rec(env, cathandle, rec, th);\r\nif (rc == 0)\r\nrc = llog_cat_add_rec(env, cathandle, rec, reccookie,\r\nbuf, th);\r\n}\r\nreturn rc;\r\n}\r\nint llog_cat_cancel_records(const struct lu_env *env,\r\nstruct llog_handle *cathandle, int count,\r\nstruct llog_cookie *cookies)\r\n{\r\nint i, index, rc = 0, failed = 0;\r\nfor (i = 0; i < count; i++, cookies++) {\r\nstruct llog_handle *loghandle;\r\nstruct llog_logid *lgl = &cookies->lgc_lgl;\r\nint lrc;\r\nrc = llog_cat_id2handle(env, cathandle, &loghandle, lgl);\r\nif (rc) {\r\nCERROR("%s: cannot find handle for llog "DOSTID": %d\n",\r\ncathandle->lgh_ctxt->loc_obd->obd_name,\r\nPOSTID(&lgl->lgl_oi), rc);\r\nfailed++;\r\ncontinue;\r\n}\r\nlrc = llog_cancel_rec(env, loghandle, cookies->lgc_index);\r\nif (lrc == 1) {\r\nindex = loghandle->u.phd.phd_cookie.lgc_index;\r\nrc = llog_cat_cleanup(env, cathandle, loghandle,\r\nindex);\r\n} else if (lrc == -ENOENT) {\r\nif (rc == 0)\r\nrc = lrc;\r\n} else if (lrc < 0) {\r\nfailed++;\r\nrc = lrc;\r\n}\r\nllog_handle_put(loghandle);\r\n}\r\nif (rc)\r\nCERROR("%s: fail to cancel %d of %d llog-records: rc = %d\n",\r\ncathandle->lgh_ctxt->loc_obd->obd_name, failed, count,\r\nrc);\r\nreturn rc;\r\n}\r\nint llog_cat_process_cb(const struct lu_env *env, struct llog_handle *cat_llh,\r\nstruct llog_rec_hdr *rec, void *data)\r\n{\r\nstruct llog_process_data *d = data;\r\nstruct llog_logid_rec *lir = (struct llog_logid_rec *)rec;\r\nstruct llog_handle *llh;\r\nint rc;\r\nif (rec->lrh_type != LLOG_LOGID_MAGIC) {\r\nCERROR("invalid record in catalog\n");\r\nreturn -EINVAL;\r\n}\r\nCDEBUG(D_HA, "processing log "DOSTID":%x at index %u of catalog "\r\nDOSTID"\n", POSTID(&lir->lid_id.lgl_oi), lir->lid_id.lgl_ogen,\r\nrec->lrh_index, POSTID(&cat_llh->lgh_id.lgl_oi));\r\nrc = llog_cat_id2handle(env, cat_llh, &llh, &lir->lid_id);\r\nif (rc) {\r\nCERROR("%s: cannot find handle for llog "DOSTID": %d\n",\r\ncat_llh->lgh_ctxt->loc_obd->obd_name,\r\nPOSTID(&lir->lid_id.lgl_oi), rc);\r\nreturn rc;\r\n}\r\nif (rec->lrh_index < d->lpd_startcat)\r\nrc = 0;\r\nelse if (d->lpd_startidx > 0) {\r\nstruct llog_process_cat_data cd;\r\ncd.lpcd_first_idx = d->lpd_startidx;\r\ncd.lpcd_last_idx = 0;\r\nrc = llog_process_or_fork(env, llh, d->lpd_cb, d->lpd_data,\r\n&cd, false);\r\nd->lpd_startidx = 0;\r\n} else {\r\nrc = llog_process_or_fork(env, llh, d->lpd_cb, d->lpd_data,\r\nNULL, false);\r\n}\r\nllog_handle_put(llh);\r\nreturn rc;\r\n}\r\nint llog_cat_process_or_fork(const struct lu_env *env,\r\nstruct llog_handle *cat_llh,\r\nllog_cb_t cb, void *data, int startcat,\r\nint startidx, bool fork)\r\n{\r\nstruct llog_process_data d;\r\nstruct llog_log_hdr *llh = cat_llh->lgh_hdr;\r\nint rc;\r\nLASSERT(llh->llh_flags & LLOG_F_IS_CAT);\r\nd.lpd_data = data;\r\nd.lpd_cb = cb;\r\nd.lpd_startcat = startcat;\r\nd.lpd_startidx = startidx;\r\nif (llh->llh_cat_idx > cat_llh->lgh_last_idx) {\r\nstruct llog_process_cat_data cd;\r\nCWARN("catlog "DOSTID" crosses index zero\n",\r\nPOSTID(&cat_llh->lgh_id.lgl_oi));\r\ncd.lpcd_first_idx = llh->llh_cat_idx;\r\ncd.lpcd_last_idx = 0;\r\nrc = llog_process_or_fork(env, cat_llh, llog_cat_process_cb,\r\n&d, &cd, fork);\r\nif (rc != 0)\r\nreturn rc;\r\ncd.lpcd_first_idx = 0;\r\ncd.lpcd_last_idx = cat_llh->lgh_last_idx;\r\nrc = llog_process_or_fork(env, cat_llh, llog_cat_process_cb,\r\n&d, &cd, fork);\r\n} else {\r\nrc = llog_process_or_fork(env, cat_llh, llog_cat_process_cb,\r\n&d, NULL, fork);\r\n}\r\nreturn rc;\r\n}\r\nint llog_cat_process(const struct lu_env *env, struct llog_handle *cat_llh,\r\nllog_cb_t cb, void *data, int startcat, int startidx)\r\n{\r\nreturn llog_cat_process_or_fork(env, cat_llh, cb, data, startcat,\r\nstartidx, false);\r\n}\r\nstatic int llog_cat_reverse_process_cb(const struct lu_env *env,\r\nstruct llog_handle *cat_llh,\r\nstruct llog_rec_hdr *rec, void *data)\r\n{\r\nstruct llog_process_data *d = data;\r\nstruct llog_logid_rec *lir = (struct llog_logid_rec *)rec;\r\nstruct llog_handle *llh;\r\nint rc;\r\nif (le32_to_cpu(rec->lrh_type) != LLOG_LOGID_MAGIC) {\r\nCERROR("invalid record in catalog\n");\r\nreturn -EINVAL;\r\n}\r\nCDEBUG(D_HA, "processing log "DOSTID":%x at index %u of catalog "\r\nDOSTID"\n", POSTID(&lir->lid_id.lgl_oi), lir->lid_id.lgl_ogen,\r\nle32_to_cpu(rec->lrh_index), POSTID(&cat_llh->lgh_id.lgl_oi));\r\nrc = llog_cat_id2handle(env, cat_llh, &llh, &lir->lid_id);\r\nif (rc) {\r\nCERROR("%s: cannot find handle for llog "DOSTID": %d\n",\r\ncat_llh->lgh_ctxt->loc_obd->obd_name,\r\nPOSTID(&lir->lid_id.lgl_oi), rc);\r\nreturn rc;\r\n}\r\nrc = llog_reverse_process(env, llh, d->lpd_cb, d->lpd_data, NULL);\r\nllog_handle_put(llh);\r\nreturn rc;\r\n}\r\nint llog_cat_reverse_process(const struct lu_env *env,\r\nstruct llog_handle *cat_llh,\r\nllog_cb_t cb, void *data)\r\n{\r\nstruct llog_process_data d;\r\nstruct llog_process_cat_data cd;\r\nstruct llog_log_hdr *llh = cat_llh->lgh_hdr;\r\nint rc;\r\nLASSERT(llh->llh_flags & LLOG_F_IS_CAT);\r\nd.lpd_data = data;\r\nd.lpd_cb = cb;\r\nif (llh->llh_cat_idx > cat_llh->lgh_last_idx) {\r\nCWARN("catalog "DOSTID" crosses index zero\n",\r\nPOSTID(&cat_llh->lgh_id.lgl_oi));\r\ncd.lpcd_first_idx = 0;\r\ncd.lpcd_last_idx = cat_llh->lgh_last_idx;\r\nrc = llog_reverse_process(env, cat_llh,\r\nllog_cat_reverse_process_cb,\r\n&d, &cd);\r\nif (rc != 0)\r\nreturn rc;\r\ncd.lpcd_first_idx = le32_to_cpu(llh->llh_cat_idx);\r\ncd.lpcd_last_idx = 0;\r\nrc = llog_reverse_process(env, cat_llh,\r\nllog_cat_reverse_process_cb,\r\n&d, &cd);\r\n} else {\r\nrc = llog_reverse_process(env, cat_llh,\r\nllog_cat_reverse_process_cb,\r\n&d, NULL);\r\n}\r\nreturn rc;\r\n}\r\nint llog_cat_set_first_idx(struct llog_handle *cathandle, int index)\r\n{\r\nstruct llog_log_hdr *llh = cathandle->lgh_hdr;\r\nint i, bitmap_size, idx;\r\nbitmap_size = LLOG_BITMAP_SIZE(llh);\r\nif (llh->llh_cat_idx == (index - 1)) {\r\nidx = llh->llh_cat_idx + 1;\r\nllh->llh_cat_idx = idx;\r\nif (idx == cathandle->lgh_last_idx)\r\ngoto out;\r\nfor (i = (index + 1) % bitmap_size;\r\ni != cathandle->lgh_last_idx;\r\ni = (i + 1) % bitmap_size) {\r\nif (!ext2_test_bit(i, llh->llh_bitmap)) {\r\nidx = llh->llh_cat_idx + 1;\r\nllh->llh_cat_idx = idx;\r\n} else if (i == 0) {\r\nllh->llh_cat_idx = 0;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nout:\r\nCDEBUG(D_RPCTRACE, "set catlog "DOSTID" first idx %u\n",\r\nPOSTID(&cathandle->lgh_id.lgl_oi), llh->llh_cat_idx);\r\n}\r\nreturn 0;\r\n}\r\nint llog_cat_cleanup(const struct lu_env *env, struct llog_handle *cathandle,\r\nstruct llog_handle *loghandle, int index)\r\n{\r\nint rc;\r\nLASSERT(index);\r\nif (loghandle != NULL) {\r\ndown_write(&cathandle->lgh_lock);\r\nif (cathandle->u.chd.chd_current_log == loghandle)\r\ncathandle->u.chd.chd_current_log = NULL;\r\nlist_del_init(&loghandle->u.phd.phd_entry);\r\nup_write(&cathandle->lgh_lock);\r\nLASSERT(index == loghandle->u.phd.phd_cookie.lgc_index);\r\nllog_close(env, loghandle);\r\n}\r\nllog_cat_set_first_idx(cathandle, index);\r\nrc = llog_cancel_rec(env, cathandle, index);\r\nif (rc == 0)\r\nCDEBUG(D_HA, "cancel plain log at index %u of catalog " DOSTID "\n",\r\nindex, POSTID(&cathandle->lgh_id.lgl_oi));\r\nreturn rc;\r\n}\r\nint cat_cancel_cb(const struct lu_env *env, struct llog_handle *cathandle,\r\nstruct llog_rec_hdr *rec, void *data)\r\n{\r\nstruct llog_logid_rec *lir = (struct llog_logid_rec *)rec;\r\nstruct llog_handle *loghandle;\r\nstruct llog_log_hdr *llh;\r\nint rc;\r\nif (rec->lrh_type != LLOG_LOGID_MAGIC) {\r\nCERROR("invalid record in catalog\n");\r\nreturn -EINVAL;\r\n}\r\nCDEBUG(D_HA, "processing log "DOSTID":%x at index %u of catalog "\r\nDOSTID"\n", POSTID(&lir->lid_id.lgl_oi), lir->lid_id.lgl_ogen,\r\nrec->lrh_index, POSTID(&cathandle->lgh_id.lgl_oi));\r\nrc = llog_cat_id2handle(env, cathandle, &loghandle, &lir->lid_id);\r\nif (rc) {\r\nCERROR("%s: cannot find handle for llog "DOSTID": %d\n",\r\ncathandle->lgh_ctxt->loc_obd->obd_name,\r\nPOSTID(&lir->lid_id.lgl_oi), rc);\r\nif (rc == -ENOENT || rc == -ESTALE) {\r\nllog_cat_cleanup(env, cathandle, NULL, rec->lrh_index);\r\n}\r\nreturn rc;\r\n}\r\nllh = loghandle->lgh_hdr;\r\nif ((llh->llh_flags & LLOG_F_ZAP_WHEN_EMPTY) &&\r\n(llh->llh_count == 1)) {\r\nrc = llog_destroy(env, loghandle);\r\nif (rc)\r\nCERROR("%s: fail to destroy empty log: rc = %d\n",\r\nloghandle->lgh_ctxt->loc_obd->obd_name, rc);\r\nllog_cat_cleanup(env, cathandle, loghandle,\r\nloghandle->u.phd.phd_cookie.lgc_index);\r\n}\r\nllog_handle_put(loghandle);\r\nreturn rc;\r\n}\r\nint llog_cat_init_and_process(const struct lu_env *env,\r\nstruct llog_handle *llh)\r\n{\r\nint rc;\r\nrc = llog_init_handle(env, llh, LLOG_F_IS_CAT, NULL);\r\nif (rc)\r\nreturn rc;\r\nrc = llog_process_or_fork(env, llh, cat_cancel_cb, NULL, NULL, false);\r\nif (rc)\r\nCERROR("%s: llog_process() with cat_cancel_cb failed: rc = %d\n",\r\nllh->lgh_ctxt->loc_obd->obd_name, rc);\r\nreturn 0;\r\n}
