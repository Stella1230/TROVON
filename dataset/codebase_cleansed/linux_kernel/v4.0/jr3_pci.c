static struct jr3_pci_poll_delay poll_delay_min_max(int min, int max)\r\n{\r\nstruct jr3_pci_poll_delay result;\r\nresult.min = min;\r\nresult.max = max;\r\nreturn result;\r\n}\r\nstatic int is_complete(struct jr3_channel __iomem *channel)\r\n{\r\nreturn get_s16(&channel->command_word0) == 0;\r\n}\r\nstatic void set_transforms(struct jr3_channel __iomem *channel,\r\nstruct jr3_pci_transform transf, short num)\r\n{\r\nint i;\r\nnum &= 0x000f;\r\nfor (i = 0; i < 8; i++) {\r\nset_u16(&channel->transforms[num].link[i].link_type,\r\ntransf.link[i].link_type);\r\nudelay(1);\r\nset_s16(&channel->transforms[num].link[i].link_amount,\r\ntransf.link[i].link_amount);\r\nudelay(1);\r\nif (transf.link[i].link_type == end_x_form)\r\nbreak;\r\n}\r\n}\r\nstatic void use_transform(struct jr3_channel __iomem *channel,\r\nshort transf_num)\r\n{\r\nset_s16(&channel->command_word0, 0x0500 + (transf_num & 0x000f));\r\n}\r\nstatic void use_offset(struct jr3_channel __iomem *channel, short offset_num)\r\n{\r\nset_s16(&channel->command_word0, 0x0600 + (offset_num & 0x000f));\r\n}\r\nstatic void set_offset(struct jr3_channel __iomem *channel)\r\n{\r\nset_s16(&channel->command_word0, 0x0700);\r\n}\r\nstatic void set_full_scales(struct jr3_channel __iomem *channel,\r\nstruct six_axis_t full_scale)\r\n{\r\nset_s16(&channel->full_scale.fx, full_scale.fx);\r\nset_s16(&channel->full_scale.fy, full_scale.fy);\r\nset_s16(&channel->full_scale.fz, full_scale.fz);\r\nset_s16(&channel->full_scale.mx, full_scale.mx);\r\nset_s16(&channel->full_scale.my, full_scale.my);\r\nset_s16(&channel->full_scale.mz, full_scale.mz);\r\nset_s16(&channel->command_word0, 0x0a00);\r\n}\r\nstatic struct six_axis_t get_min_full_scales(struct jr3_channel __iomem\r\n*channel)\r\n{\r\nstruct six_axis_t result;\r\nresult.fx = get_s16(&channel->min_full_scale.fx);\r\nresult.fy = get_s16(&channel->min_full_scale.fy);\r\nresult.fz = get_s16(&channel->min_full_scale.fz);\r\nresult.mx = get_s16(&channel->min_full_scale.mx);\r\nresult.my = get_s16(&channel->min_full_scale.my);\r\nresult.mz = get_s16(&channel->min_full_scale.mz);\r\nreturn result;\r\n}\r\nstatic struct six_axis_t get_max_full_scales(struct jr3_channel __iomem\r\n*channel)\r\n{\r\nstruct six_axis_t result;\r\nresult.fx = get_s16(&channel->max_full_scale.fx);\r\nresult.fy = get_s16(&channel->max_full_scale.fy);\r\nresult.fz = get_s16(&channel->max_full_scale.fz);\r\nresult.mx = get_s16(&channel->max_full_scale.mx);\r\nresult.my = get_s16(&channel->max_full_scale.my);\r\nresult.mz = get_s16(&channel->max_full_scale.mz);\r\nreturn result;\r\n}\r\nstatic unsigned int jr3_pci_ai_read_chan(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int chan)\r\n{\r\nstruct jr3_pci_subdev_private *spriv = s->private;\r\nunsigned int val = 0;\r\nif (spriv->state != state_jr3_done)\r\nreturn 0;\r\nif (chan < 56) {\r\nunsigned int axis = chan % 8;\r\nunsigned filter = chan / 8;\r\nswitch (axis) {\r\ncase 0:\r\nval = get_s16(&spriv->channel->filter[filter].fx);\r\nbreak;\r\ncase 1:\r\nval = get_s16(&spriv->channel->filter[filter].fy);\r\nbreak;\r\ncase 2:\r\nval = get_s16(&spriv->channel->filter[filter].fz);\r\nbreak;\r\ncase 3:\r\nval = get_s16(&spriv->channel->filter[filter].mx);\r\nbreak;\r\ncase 4:\r\nval = get_s16(&spriv->channel->filter[filter].my);\r\nbreak;\r\ncase 5:\r\nval = get_s16(&spriv->channel->filter[filter].mz);\r\nbreak;\r\ncase 6:\r\nval = get_s16(&spriv->channel->filter[filter].v1);\r\nbreak;\r\ncase 7:\r\nval = get_s16(&spriv->channel->filter[filter].v2);\r\nbreak;\r\n}\r\nval += 0x4000;\r\n} else if (chan == 56) {\r\nval = get_u16(&spriv->channel->model_no);\r\n} else if (chan == 57) {\r\nval = get_u16(&spriv->channel->serial_no);\r\n}\r\nreturn val;\r\n}\r\nstatic int jr3_pci_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct jr3_pci_subdev_private *spriv = s->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nu16 errors;\r\nint i;\r\nif (!spriv)\r\nreturn -EINVAL;\r\nerrors = get_u16(&spriv->channel->errors);\r\nif (spriv->state != state_jr3_done ||\r\n(errors & (watch_dog | watch_dog2 | sensor_change))) {\r\nif (spriv->state == state_jr3_done) {\r\nspriv->state = state_jr3_poll;\r\n}\r\nreturn -EAGAIN;\r\n}\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = jr3_pci_ai_read_chan(dev, s, chan);\r\nreturn insn->n;\r\n}\r\nstatic int jr3_pci_open(struct comedi_device *dev)\r\n{\r\nstruct jr3_pci_subdev_private *spriv;\r\nstruct comedi_subdevice *s;\r\nint i;\r\ndev_dbg(dev->class_dev, "jr3_pci_open\n");\r\nfor (i = 0; i < dev->n_subdevices; i++) {\r\ns = &dev->subdevices[i];\r\nspriv = s->private;\r\nif (spriv)\r\ndev_dbg(dev->class_dev, "serial: %p %d (%d)\n",\r\nspriv, spriv->serial_no, s->index);\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_idm_word(const u8 *data, size_t size, int *pos,\r\nunsigned int *val)\r\n{\r\nint result = 0;\r\nint value;\r\nif (pos && val) {\r\nfor (; *pos < size && !isxdigit(data[*pos]); (*pos)++)\r\n;\r\n*val = 0;\r\nfor (; *pos < size; (*pos)++) {\r\nvalue = hex_to_bin(data[*pos]);\r\nif (value >= 0) {\r\nresult = 1;\r\n*val = (*val << 4) + value;\r\n} else {\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int jr3_check_firmware(struct comedi_device *dev,\r\nconst u8 *data, size_t size)\r\n{\r\nint more = 1;\r\nint pos = 0;\r\nwhile (more) {\r\nunsigned int count = 0;\r\nunsigned int addr = 0;\r\nmore = more && read_idm_word(data, size, &pos, &count);\r\nif (more && count == 0xffff)\r\nreturn 0;\r\nmore = more && read_idm_word(data, size, &pos, &addr);\r\nwhile (more && count > 0) {\r\nunsigned int dummy = 0;\r\nmore = more && read_idm_word(data, size, &pos, &dummy);\r\ncount--;\r\n}\r\n}\r\nreturn -ENODATA;\r\n}\r\nstatic void jr3_write_firmware(struct comedi_device *dev,\r\nint subdev, const u8 *data, size_t size)\r\n{\r\nstruct jr3_pci_dev_private *devpriv = dev->private;\r\nstruct jr3_t __iomem *iobase = devpriv->iobase;\r\nu32 __iomem *lo;\r\nu32 __iomem *hi;\r\nint more = 1;\r\nint pos = 0;\r\nwhile (more) {\r\nunsigned int count = 0;\r\nunsigned int addr = 0;\r\nmore = more && read_idm_word(data, size, &pos, &count);\r\nif (more && count == 0xffff)\r\nreturn;\r\nmore = more && read_idm_word(data, size, &pos, &addr);\r\ndev_dbg(dev->class_dev, "Loading#%d %4.4x bytes at %4.4x\n",\r\nsubdev, count, addr);\r\nwhile (more && count > 0) {\r\nif (addr & 0x4000) {\r\nunsigned int data1 = 0;\r\nmore = more &&\r\nread_idm_word(data, size, &pos, &data1);\r\ncount--;\r\n} else {\r\nunsigned int data1 = 0;\r\nunsigned int data2 = 0;\r\nlo = &iobase->channel[subdev].program_lo[addr];\r\nhi = &iobase->channel[subdev].program_hi[addr];\r\nmore = more &&\r\nread_idm_word(data, size, &pos, &data1);\r\nmore = more &&\r\nread_idm_word(data, size, &pos, &data2);\r\ncount -= 2;\r\nif (more) {\r\nset_u16(lo, data1);\r\nudelay(1);\r\nset_u16(hi, data2);\r\nudelay(1);\r\n}\r\n}\r\naddr++;\r\n}\r\n}\r\n}\r\nstatic int jr3_download_firmware(struct comedi_device *dev,\r\nconst u8 *data, size_t size,\r\nunsigned long context)\r\n{\r\nint subdev;\r\nint ret;\r\nret = jr3_check_firmware(dev, data, size);\r\nif (ret)\r\nreturn ret;\r\nfor (subdev = 0; subdev < dev->n_subdevices; subdev++)\r\njr3_write_firmware(dev, subdev, data, size);\r\nreturn 0;\r\n}\r\nstatic struct jr3_pci_poll_delay jr3_pci_poll_subdevice(struct comedi_subdevice *s)\r\n{\r\nstruct jr3_pci_subdev_private *spriv = s->private;\r\nstruct jr3_pci_poll_delay result = poll_delay_min_max(1000, 2000);\r\nstruct jr3_channel __iomem *channel;\r\nu16 model_no;\r\nu16 serial_no;\r\nint errors;\r\nint i;\r\nif (!spriv)\r\nreturn result;\r\nchannel = spriv->channel;\r\nerrors = get_u16(&channel->errors);\r\nif (errors != spriv->errors)\r\nspriv->errors = errors;\r\nif (errors & (watch_dog | watch_dog2 | sensor_change))\r\nspriv->state = state_jr3_poll;\r\nswitch (spriv->state) {\r\ncase state_jr3_poll:\r\nmodel_no = get_u16(&channel->model_no);\r\nserial_no = get_u16(&channel->serial_no);\r\nif ((errors & (watch_dog | watch_dog2)) ||\r\nmodel_no == 0 || serial_no == 0) {\r\n} else {\r\nspriv->retries = 0;\r\nspriv->state = state_jr3_init_wait_for_offset;\r\n}\r\nbreak;\r\ncase state_jr3_init_wait_for_offset:\r\nspriv->retries++;\r\nif (spriv->retries < 10) {\r\n} else {\r\nstruct jr3_pci_transform transf;\r\nspriv->model_no = get_u16(&channel->model_no);\r\nspriv->serial_no = get_u16(&channel->serial_no);\r\nfor (i = 0; i < ARRAY_SIZE(transf.link); i++) {\r\ntransf.link[i].link_type = (enum link_types)0;\r\ntransf.link[i].link_amount = 0;\r\n}\r\nset_transforms(channel, transf, 0);\r\nuse_transform(channel, 0);\r\nspriv->state = state_jr3_init_transform_complete;\r\nresult = poll_delay_min_max(20, 100);\r\n}\r\nbreak;\r\ncase state_jr3_init_transform_complete:\r\nif (!is_complete(channel)) {\r\nresult = poll_delay_min_max(20, 100);\r\n} else {\r\nstruct six_axis_t min_full_scale;\r\nstruct six_axis_t max_full_scale;\r\nmin_full_scale = get_min_full_scales(channel);\r\nmax_full_scale = get_max_full_scales(channel);\r\nset_full_scales(channel, max_full_scale);\r\nspriv->state = state_jr3_init_set_full_scale_complete;\r\nresult = poll_delay_min_max(20, 100);\r\n}\r\nbreak;\r\ncase state_jr3_init_set_full_scale_complete:\r\nif (!is_complete(channel)) {\r\nresult = poll_delay_min_max(20, 100);\r\n} else {\r\nstruct force_array __iomem *fs = &channel->full_scale;\r\nspriv->range[0].range.min = -get_s16(&fs->fx) * 1000;\r\nspriv->range[0].range.max = get_s16(&fs->fx) * 1000;\r\nspriv->range[1].range.min = -get_s16(&fs->fy) * 1000;\r\nspriv->range[1].range.max = get_s16(&fs->fy) * 1000;\r\nspriv->range[2].range.min = -get_s16(&fs->fz) * 1000;\r\nspriv->range[2].range.max = get_s16(&fs->fz) * 1000;\r\nspriv->range[3].range.min = -get_s16(&fs->mx) * 100;\r\nspriv->range[3].range.max = get_s16(&fs->mx) * 100;\r\nspriv->range[4].range.min = -get_s16(&fs->my) * 100;\r\nspriv->range[4].range.max = get_s16(&fs->my) * 100;\r\nspriv->range[5].range.min = -get_s16(&fs->mz) * 100;\r\nspriv->range[5].range.max = get_s16(&fs->mz) * 100;\r\nspriv->range[6].range.min = -get_s16(&fs->v1) * 100;\r\nspriv->range[6].range.max = get_s16(&fs->v1) * 100;\r\nspriv->range[7].range.min = -get_s16(&fs->v2) * 100;\r\nspriv->range[7].range.max = get_s16(&fs->v2) * 100;\r\nspriv->range[8].range.min = 0;\r\nspriv->range[8].range.max = 65535;\r\nuse_offset(channel, 0);\r\nspriv->state = state_jr3_init_use_offset_complete;\r\nresult = poll_delay_min_max(40, 100);\r\n}\r\nbreak;\r\ncase state_jr3_init_use_offset_complete:\r\nif (!is_complete(channel)) {\r\nresult = poll_delay_min_max(20, 100);\r\n} else {\r\nset_s16(&channel->offsets.fx, 0);\r\nset_s16(&channel->offsets.fy, 0);\r\nset_s16(&channel->offsets.fz, 0);\r\nset_s16(&channel->offsets.mx, 0);\r\nset_s16(&channel->offsets.my, 0);\r\nset_s16(&channel->offsets.mz, 0);\r\nset_offset(channel);\r\nspriv->state = state_jr3_done;\r\n}\r\nbreak;\r\ncase state_jr3_done:\r\nresult = poll_delay_min_max(10000, 20000);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic void jr3_pci_poll_dev(unsigned long data)\r\n{\r\nstruct comedi_device *dev = (struct comedi_device *)data;\r\nstruct jr3_pci_dev_private *devpriv = dev->private;\r\nstruct jr3_pci_subdev_private *spriv;\r\nstruct comedi_subdevice *s;\r\nunsigned long flags;\r\nunsigned long now;\r\nint delay;\r\nint i;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndelay = 1000;\r\nnow = jiffies;\r\nfor (i = 0; i < dev->n_subdevices; i++) {\r\ns = &dev->subdevices[i];\r\nspriv = s->private;\r\nif (now > spriv->next_time_min) {\r\nstruct jr3_pci_poll_delay sub_delay;\r\nsub_delay = jr3_pci_poll_subdevice(s);\r\nspriv->next_time_min = jiffies +\r\nmsecs_to_jiffies(sub_delay.min);\r\nspriv->next_time_max = jiffies +\r\nmsecs_to_jiffies(sub_delay.max);\r\nif (sub_delay.max && sub_delay.max < delay)\r\ndelay = sub_delay.max;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ndevpriv->timer.expires = jiffies + msecs_to_jiffies(delay);\r\nadd_timer(&devpriv->timer);\r\n}\r\nstatic struct jr3_pci_subdev_private *\r\njr3_pci_alloc_spriv(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct jr3_pci_dev_private *devpriv = dev->private;\r\nstruct jr3_pci_subdev_private *spriv;\r\nint j;\r\nint k;\r\nspriv = comedi_alloc_spriv(s, sizeof(*spriv));\r\nif (!spriv)\r\nreturn NULL;\r\nspriv->channel = &devpriv->iobase->channel[s->index].data;\r\nfor (j = 0; j < 8; j++) {\r\nspriv->range[j].length = 1;\r\nspriv->range[j].range.min = -1000000;\r\nspriv->range[j].range.max = 1000000;\r\nfor (k = 0; k < 7; k++) {\r\nspriv->range_table_list[j + k * 8] =\r\n(struct comedi_lrange *)&spriv->range[j];\r\nspriv->maxdata_list[j + k * 8] = 0x7fff;\r\n}\r\n}\r\nspriv->range[8].length = 1;\r\nspriv->range[8].range.min = 0;\r\nspriv->range[8].range.max = 65536;\r\nspriv->range_table_list[56] = (struct comedi_lrange *)&spriv->range[8];\r\nspriv->range_table_list[57] = (struct comedi_lrange *)&spriv->range[8];\r\nspriv->maxdata_list[56] = 0xffff;\r\nspriv->maxdata_list[57] = 0xffff;\r\ndev_dbg(dev->class_dev, "p->channel %p %p (%tx)\n",\r\nspriv->channel, devpriv->iobase,\r\n((char __iomem *)spriv->channel -\r\n(char __iomem *)devpriv->iobase));\r\nreturn spriv;\r\n}\r\nstatic int jr3_pci_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nstatic const struct jr3_pci_board *board;\r\nstruct jr3_pci_dev_private *devpriv;\r\nstruct jr3_pci_subdev_private *spriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nint i;\r\nif (sizeof(struct jr3_channel) != 0xc00) {\r\ndev_err(dev->class_dev,\r\n"sizeof(struct jr3_channel) = %x [expected %x]\n",\r\n(unsigned)sizeof(struct jr3_channel), 0xc00);\r\nreturn -EINVAL;\r\n}\r\nif (context < ARRAY_SIZE(jr3_pci_boards))\r\nboard = &jr3_pci_boards[context];\r\nif (!board)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\ninit_timer(&devpriv->timer);\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\ndevpriv->iobase = pci_ioremap_bar(pcidev, 0);\r\nif (!devpriv->iobase)\r\nreturn -ENOMEM;\r\nret = comedi_alloc_subdevices(dev, board->n_subdevs);\r\nif (ret)\r\nreturn ret;\r\ndev->open = jr3_pci_open;\r\nfor (i = 0; i < dev->n_subdevices; i++) {\r\ns = &dev->subdevices[i];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND;\r\ns->n_chan = 8 * 7 + 2;\r\ns->insn_read = jr3_pci_ai_insn_read;\r\nspriv = jr3_pci_alloc_spriv(dev, s);\r\nif (spriv) {\r\ns->range_table_list = spriv->range_table_list;\r\ns->maxdata_list = spriv->maxdata_list;\r\n}\r\n}\r\nwritel(0, &devpriv->iobase->channel[0].reset);\r\nret = comedi_load_firmware(dev, &comedi_to_pci_dev(dev)->dev,\r\n"comedi/jr3pci.idm",\r\njr3_download_firmware, 0);\r\ndev_dbg(dev->class_dev, "Firmare load %d\n", ret);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep_interruptible(25);\r\nfor (i = 0; i < 0x18; i++) {\r\ndev_dbg(dev->class_dev, "%c\n",\r\nget_u16(&devpriv->iobase->channel[0].\r\ndata.copyright[i]) >> 8);\r\n}\r\nfor (i = 0; i < dev->n_subdevices; i++) {\r\ns = &dev->subdevices[i];\r\nspriv = s->private;\r\nspriv->next_time_min = jiffies + msecs_to_jiffies(500);\r\nspriv->next_time_max = jiffies + msecs_to_jiffies(2000);\r\n}\r\ndevpriv->timer.data = (unsigned long)dev;\r\ndevpriv->timer.function = jr3_pci_poll_dev;\r\ndevpriv->timer.expires = jiffies + msecs_to_jiffies(1000);\r\nadd_timer(&devpriv->timer);\r\nreturn 0;\r\n}\r\nstatic void jr3_pci_detach(struct comedi_device *dev)\r\n{\r\nstruct jr3_pci_dev_private *devpriv = dev->private;\r\nif (devpriv) {\r\ndel_timer_sync(&devpriv->timer);\r\nif (devpriv->iobase)\r\niounmap(devpriv->iobase);\r\n}\r\ncomedi_pci_disable(dev);\r\n}\r\nstatic int jr3_pci_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &jr3_pci_driver, id->driver_data);\r\n}
