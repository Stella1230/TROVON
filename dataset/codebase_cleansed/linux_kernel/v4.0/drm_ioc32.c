static int compat_drm_version(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_version32_t v32;\r\nstruct drm_version __user *version;\r\nint err;\r\nif (copy_from_user(&v32, (void __user *)arg, sizeof(v32)))\r\nreturn -EFAULT;\r\nversion = compat_alloc_user_space(sizeof(*version));\r\nif (!access_ok(VERIFY_WRITE, version, sizeof(*version)))\r\nreturn -EFAULT;\r\nif (__put_user(v32.name_len, &version->name_len)\r\n|| __put_user((void __user *)(unsigned long)v32.name,\r\n&version->name)\r\n|| __put_user(v32.date_len, &version->date_len)\r\n|| __put_user((void __user *)(unsigned long)v32.date,\r\n&version->date)\r\n|| __put_user(v32.desc_len, &version->desc_len)\r\n|| __put_user((void __user *)(unsigned long)v32.desc,\r\n&version->desc))\r\nreturn -EFAULT;\r\nerr = drm_ioctl(file,\r\nDRM_IOCTL_VERSION, (unsigned long)version);\r\nif (err)\r\nreturn err;\r\nif (__get_user(v32.version_major, &version->version_major)\r\n|| __get_user(v32.version_minor, &version->version_minor)\r\n|| __get_user(v32.version_patchlevel, &version->version_patchlevel)\r\n|| __get_user(v32.name_len, &version->name_len)\r\n|| __get_user(v32.date_len, &version->date_len)\r\n|| __get_user(v32.desc_len, &version->desc_len))\r\nreturn -EFAULT;\r\nif (copy_to_user((void __user *)arg, &v32, sizeof(v32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int compat_drm_getunique(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_unique32_t uq32;\r\nstruct drm_unique __user *u;\r\nint err;\r\nif (copy_from_user(&uq32, (void __user *)arg, sizeof(uq32)))\r\nreturn -EFAULT;\r\nu = compat_alloc_user_space(sizeof(*u));\r\nif (!access_ok(VERIFY_WRITE, u, sizeof(*u)))\r\nreturn -EFAULT;\r\nif (__put_user(uq32.unique_len, &u->unique_len)\r\n|| __put_user((void __user *)(unsigned long)uq32.unique,\r\n&u->unique))\r\nreturn -EFAULT;\r\nerr = drm_ioctl(file, DRM_IOCTL_GET_UNIQUE, (unsigned long)u);\r\nif (err)\r\nreturn err;\r\nif (__get_user(uq32.unique_len, &u->unique_len))\r\nreturn -EFAULT;\r\nif (copy_to_user((void __user *)arg, &uq32, sizeof(uq32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int compat_drm_setunique(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_unique32_t uq32;\r\nstruct drm_unique __user *u;\r\nif (copy_from_user(&uq32, (void __user *)arg, sizeof(uq32)))\r\nreturn -EFAULT;\r\nu = compat_alloc_user_space(sizeof(*u));\r\nif (!access_ok(VERIFY_WRITE, u, sizeof(*u)))\r\nreturn -EFAULT;\r\nif (__put_user(uq32.unique_len, &u->unique_len)\r\n|| __put_user((void __user *)(unsigned long)uq32.unique,\r\n&u->unique))\r\nreturn -EFAULT;\r\nreturn drm_ioctl(file, DRM_IOCTL_SET_UNIQUE, (unsigned long)u);\r\n}\r\nstatic int compat_drm_getmap(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_map32_t __user *argp = (void __user *)arg;\r\ndrm_map32_t m32;\r\nstruct drm_map __user *map;\r\nint idx, err;\r\nvoid *handle;\r\nif (get_user(idx, &argp->offset))\r\nreturn -EFAULT;\r\nmap = compat_alloc_user_space(sizeof(*map));\r\nif (!access_ok(VERIFY_WRITE, map, sizeof(*map)))\r\nreturn -EFAULT;\r\nif (__put_user(idx, &map->offset))\r\nreturn -EFAULT;\r\nerr = drm_ioctl(file, DRM_IOCTL_GET_MAP, (unsigned long)map);\r\nif (err)\r\nreturn err;\r\nif (__get_user(m32.offset, &map->offset)\r\n|| __get_user(m32.size, &map->size)\r\n|| __get_user(m32.type, &map->type)\r\n|| __get_user(m32.flags, &map->flags)\r\n|| __get_user(handle, &map->handle)\r\n|| __get_user(m32.mtrr, &map->mtrr))\r\nreturn -EFAULT;\r\nm32.handle = (unsigned long)handle;\r\nif (copy_to_user(argp, &m32, sizeof(m32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int compat_drm_addmap(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_map32_t __user *argp = (void __user *)arg;\r\ndrm_map32_t m32;\r\nstruct drm_map __user *map;\r\nint err;\r\nvoid *handle;\r\nif (copy_from_user(&m32, argp, sizeof(m32)))\r\nreturn -EFAULT;\r\nmap = compat_alloc_user_space(sizeof(*map));\r\nif (!access_ok(VERIFY_WRITE, map, sizeof(*map)))\r\nreturn -EFAULT;\r\nif (__put_user(m32.offset, &map->offset)\r\n|| __put_user(m32.size, &map->size)\r\n|| __put_user(m32.type, &map->type)\r\n|| __put_user(m32.flags, &map->flags))\r\nreturn -EFAULT;\r\nerr = drm_ioctl(file, DRM_IOCTL_ADD_MAP, (unsigned long)map);\r\nif (err)\r\nreturn err;\r\nif (__get_user(m32.offset, &map->offset)\r\n|| __get_user(m32.mtrr, &map->mtrr)\r\n|| __get_user(handle, &map->handle))\r\nreturn -EFAULT;\r\nm32.handle = (unsigned long)handle;\r\nif (m32.handle != (unsigned long)handle)\r\nprintk_ratelimited(KERN_ERR "compat_drm_addmap truncated handle"\r\n" %p for type %d offset %x\n",\r\nhandle, m32.type, m32.offset);\r\nif (copy_to_user(argp, &m32, sizeof(m32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int compat_drm_rmmap(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_map32_t __user *argp = (void __user *)arg;\r\nstruct drm_map __user *map;\r\nu32 handle;\r\nif (get_user(handle, &argp->handle))\r\nreturn -EFAULT;\r\nmap = compat_alloc_user_space(sizeof(*map));\r\nif (!access_ok(VERIFY_WRITE, map, sizeof(*map)))\r\nreturn -EFAULT;\r\nif (__put_user((void *)(unsigned long)handle, &map->handle))\r\nreturn -EFAULT;\r\nreturn drm_ioctl(file, DRM_IOCTL_RM_MAP, (unsigned long)map);\r\n}\r\nstatic int compat_drm_getclient(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_client32_t c32;\r\ndrm_client32_t __user *argp = (void __user *)arg;\r\nstruct drm_client __user *client;\r\nint idx, err;\r\nif (get_user(idx, &argp->idx))\r\nreturn -EFAULT;\r\nclient = compat_alloc_user_space(sizeof(*client));\r\nif (!access_ok(VERIFY_WRITE, client, sizeof(*client)))\r\nreturn -EFAULT;\r\nif (__put_user(idx, &client->idx))\r\nreturn -EFAULT;\r\nerr = drm_ioctl(file, DRM_IOCTL_GET_CLIENT, (unsigned long)client);\r\nif (err)\r\nreturn err;\r\nif (__get_user(c32.idx, &client->idx)\r\n|| __get_user(c32.auth, &client->auth)\r\n|| __get_user(c32.pid, &client->pid)\r\n|| __get_user(c32.uid, &client->uid)\r\n|| __get_user(c32.magic, &client->magic)\r\n|| __get_user(c32.iocs, &client->iocs))\r\nreturn -EFAULT;\r\nif (copy_to_user(argp, &c32, sizeof(c32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int compat_drm_getstats(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_stats32_t s32;\r\ndrm_stats32_t __user *argp = (void __user *)arg;\r\nstruct drm_stats __user *stats;\r\nint i, err;\r\nstats = compat_alloc_user_space(sizeof(*stats));\r\nif (!access_ok(VERIFY_WRITE, stats, sizeof(*stats)))\r\nreturn -EFAULT;\r\nerr = drm_ioctl(file, DRM_IOCTL_GET_STATS, (unsigned long)stats);\r\nif (err)\r\nreturn err;\r\nif (__get_user(s32.count, &stats->count))\r\nreturn -EFAULT;\r\nfor (i = 0; i < 15; ++i)\r\nif (__get_user(s32.data[i].value, &stats->data[i].value)\r\n|| __get_user(s32.data[i].type, &stats->data[i].type))\r\nreturn -EFAULT;\r\nif (copy_to_user(argp, &s32, sizeof(s32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int compat_drm_addbufs(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_buf_desc32_t __user *argp = (void __user *)arg;\r\nstruct drm_buf_desc __user *buf;\r\nint err;\r\nunsigned long agp_start;\r\nbuf = compat_alloc_user_space(sizeof(*buf));\r\nif (!access_ok(VERIFY_WRITE, buf, sizeof(*buf))\r\n|| !access_ok(VERIFY_WRITE, argp, sizeof(*argp)))\r\nreturn -EFAULT;\r\nif (__copy_in_user(buf, argp, offsetof(drm_buf_desc32_t, agp_start))\r\n|| __get_user(agp_start, &argp->agp_start)\r\n|| __put_user(agp_start, &buf->agp_start))\r\nreturn -EFAULT;\r\nerr = drm_ioctl(file, DRM_IOCTL_ADD_BUFS, (unsigned long)buf);\r\nif (err)\r\nreturn err;\r\nif (__copy_in_user(argp, buf, offsetof(drm_buf_desc32_t, agp_start))\r\n|| __get_user(agp_start, &buf->agp_start)\r\n|| __put_user(agp_start, &argp->agp_start))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int compat_drm_markbufs(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_buf_desc32_t b32;\r\ndrm_buf_desc32_t __user *argp = (void __user *)arg;\r\nstruct drm_buf_desc __user *buf;\r\nif (copy_from_user(&b32, argp, sizeof(b32)))\r\nreturn -EFAULT;\r\nbuf = compat_alloc_user_space(sizeof(*buf));\r\nif (!access_ok(VERIFY_WRITE, buf, sizeof(*buf)))\r\nreturn -EFAULT;\r\nif (__put_user(b32.size, &buf->size)\r\n|| __put_user(b32.low_mark, &buf->low_mark)\r\n|| __put_user(b32.high_mark, &buf->high_mark))\r\nreturn -EFAULT;\r\nreturn drm_ioctl(file, DRM_IOCTL_MARK_BUFS, (unsigned long)buf);\r\n}\r\nstatic int compat_drm_infobufs(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_buf_info32_t req32;\r\ndrm_buf_info32_t __user *argp = (void __user *)arg;\r\ndrm_buf_desc32_t __user *to;\r\nstruct drm_buf_info __user *request;\r\nstruct drm_buf_desc __user *list;\r\nsize_t nbytes;\r\nint i, err;\r\nint count, actual;\r\nif (copy_from_user(&req32, argp, sizeof(req32)))\r\nreturn -EFAULT;\r\ncount = req32.count;\r\nto = (drm_buf_desc32_t __user *) (unsigned long)req32.list;\r\nif (count < 0)\r\ncount = 0;\r\nif (count > 0\r\n&& !access_ok(VERIFY_WRITE, to, count * sizeof(drm_buf_desc32_t)))\r\nreturn -EFAULT;\r\nnbytes = sizeof(*request) + count * sizeof(struct drm_buf_desc);\r\nrequest = compat_alloc_user_space(nbytes);\r\nif (!access_ok(VERIFY_WRITE, request, nbytes))\r\nreturn -EFAULT;\r\nlist = (struct drm_buf_desc *) (request + 1);\r\nif (__put_user(count, &request->count)\r\n|| __put_user(list, &request->list))\r\nreturn -EFAULT;\r\nerr = drm_ioctl(file, DRM_IOCTL_INFO_BUFS, (unsigned long)request);\r\nif (err)\r\nreturn err;\r\nif (__get_user(actual, &request->count))\r\nreturn -EFAULT;\r\nif (count >= actual)\r\nfor (i = 0; i < actual; ++i)\r\nif (__copy_in_user(&to[i], &list[i],\r\noffsetof(struct drm_buf_desc, flags)))\r\nreturn -EFAULT;\r\nif (__put_user(actual, &argp->count))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int compat_drm_mapbufs(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_buf_map32_t __user *argp = (void __user *)arg;\r\ndrm_buf_map32_t req32;\r\ndrm_buf_pub32_t __user *list32;\r\nstruct drm_buf_map __user *request;\r\nstruct drm_buf_pub __user *list;\r\nint i, err;\r\nint count, actual;\r\nsize_t nbytes;\r\nvoid __user *addr;\r\nif (copy_from_user(&req32, argp, sizeof(req32)))\r\nreturn -EFAULT;\r\ncount = req32.count;\r\nlist32 = (void __user *)(unsigned long)req32.list;\r\nif (count < 0)\r\nreturn -EINVAL;\r\nnbytes = sizeof(*request) + count * sizeof(struct drm_buf_pub);\r\nrequest = compat_alloc_user_space(nbytes);\r\nif (!access_ok(VERIFY_WRITE, request, nbytes))\r\nreturn -EFAULT;\r\nlist = (struct drm_buf_pub *) (request + 1);\r\nif (__put_user(count, &request->count)\r\n|| __put_user(list, &request->list))\r\nreturn -EFAULT;\r\nerr = drm_ioctl(file, DRM_IOCTL_MAP_BUFS, (unsigned long)request);\r\nif (err)\r\nreturn err;\r\nif (__get_user(actual, &request->count))\r\nreturn -EFAULT;\r\nif (count >= actual)\r\nfor (i = 0; i < actual; ++i)\r\nif (__copy_in_user(&list32[i], &list[i],\r\noffsetof(struct drm_buf_pub, address))\r\n|| __get_user(addr, &list[i].address)\r\n|| __put_user((unsigned long)addr,\r\n&list32[i].address))\r\nreturn -EFAULT;\r\nif (__put_user(actual, &argp->count)\r\n|| __get_user(addr, &request->virtual)\r\n|| __put_user((unsigned long)addr, &argp->virtual))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int compat_drm_freebufs(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_buf_free32_t req32;\r\nstruct drm_buf_free __user *request;\r\ndrm_buf_free32_t __user *argp = (void __user *)arg;\r\nif (copy_from_user(&req32, argp, sizeof(req32)))\r\nreturn -EFAULT;\r\nrequest = compat_alloc_user_space(sizeof(*request));\r\nif (!access_ok(VERIFY_WRITE, request, sizeof(*request)))\r\nreturn -EFAULT;\r\nif (__put_user(req32.count, &request->count)\r\n|| __put_user((int __user *)(unsigned long)req32.list,\r\n&request->list))\r\nreturn -EFAULT;\r\nreturn drm_ioctl(file, DRM_IOCTL_FREE_BUFS, (unsigned long)request);\r\n}\r\nstatic int compat_drm_setsareactx(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_ctx_priv_map32_t req32;\r\nstruct drm_ctx_priv_map __user *request;\r\ndrm_ctx_priv_map32_t __user *argp = (void __user *)arg;\r\nif (copy_from_user(&req32, argp, sizeof(req32)))\r\nreturn -EFAULT;\r\nrequest = compat_alloc_user_space(sizeof(*request));\r\nif (!access_ok(VERIFY_WRITE, request, sizeof(*request)))\r\nreturn -EFAULT;\r\nif (__put_user(req32.ctx_id, &request->ctx_id)\r\n|| __put_user((void *)(unsigned long)req32.handle,\r\n&request->handle))\r\nreturn -EFAULT;\r\nreturn drm_ioctl(file, DRM_IOCTL_SET_SAREA_CTX, (unsigned long)request);\r\n}\r\nstatic int compat_drm_getsareactx(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct drm_ctx_priv_map __user *request;\r\ndrm_ctx_priv_map32_t __user *argp = (void __user *)arg;\r\nint err;\r\nunsigned int ctx_id;\r\nvoid *handle;\r\nif (!access_ok(VERIFY_WRITE, argp, sizeof(*argp))\r\n|| __get_user(ctx_id, &argp->ctx_id))\r\nreturn -EFAULT;\r\nrequest = compat_alloc_user_space(sizeof(*request));\r\nif (!access_ok(VERIFY_WRITE, request, sizeof(*request)))\r\nreturn -EFAULT;\r\nif (__put_user(ctx_id, &request->ctx_id))\r\nreturn -EFAULT;\r\nerr = drm_ioctl(file, DRM_IOCTL_GET_SAREA_CTX, (unsigned long)request);\r\nif (err)\r\nreturn err;\r\nif (__get_user(handle, &request->handle)\r\n|| __put_user((unsigned long)handle, &argp->handle))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int compat_drm_resctx(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_ctx_res32_t __user *argp = (void __user *)arg;\r\ndrm_ctx_res32_t res32;\r\nstruct drm_ctx_res __user *res;\r\nint err;\r\nif (copy_from_user(&res32, argp, sizeof(res32)))\r\nreturn -EFAULT;\r\nres = compat_alloc_user_space(sizeof(*res));\r\nif (!access_ok(VERIFY_WRITE, res, sizeof(*res)))\r\nreturn -EFAULT;\r\nif (__put_user(res32.count, &res->count)\r\n|| __put_user((struct drm_ctx __user *) (unsigned long)res32.contexts,\r\n&res->contexts))\r\nreturn -EFAULT;\r\nerr = drm_ioctl(file, DRM_IOCTL_RES_CTX, (unsigned long)res);\r\nif (err)\r\nreturn err;\r\nif (__get_user(res32.count, &res->count)\r\n|| __put_user(res32.count, &argp->count))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int compat_drm_dma(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_dma32_t d32;\r\ndrm_dma32_t __user *argp = (void __user *)arg;\r\nstruct drm_dma __user *d;\r\nint err;\r\nif (copy_from_user(&d32, argp, sizeof(d32)))\r\nreturn -EFAULT;\r\nd = compat_alloc_user_space(sizeof(*d));\r\nif (!access_ok(VERIFY_WRITE, d, sizeof(*d)))\r\nreturn -EFAULT;\r\nif (__put_user(d32.context, &d->context)\r\n|| __put_user(d32.send_count, &d->send_count)\r\n|| __put_user((int __user *)(unsigned long)d32.send_indices,\r\n&d->send_indices)\r\n|| __put_user((int __user *)(unsigned long)d32.send_sizes,\r\n&d->send_sizes)\r\n|| __put_user(d32.flags, &d->flags)\r\n|| __put_user(d32.request_count, &d->request_count)\r\n|| __put_user((int __user *)(unsigned long)d32.request_indices,\r\n&d->request_indices)\r\n|| __put_user((int __user *)(unsigned long)d32.request_sizes,\r\n&d->request_sizes))\r\nreturn -EFAULT;\r\nerr = drm_ioctl(file, DRM_IOCTL_DMA, (unsigned long)d);\r\nif (err)\r\nreturn err;\r\nif (__get_user(d32.request_size, &d->request_size)\r\n|| __get_user(d32.granted_count, &d->granted_count)\r\n|| __put_user(d32.request_size, &argp->request_size)\r\n|| __put_user(d32.granted_count, &argp->granted_count))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int compat_drm_agp_enable(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_agp_mode32_t __user *argp = (void __user *)arg;\r\ndrm_agp_mode32_t m32;\r\nstruct drm_agp_mode __user *mode;\r\nif (get_user(m32.mode, &argp->mode))\r\nreturn -EFAULT;\r\nmode = compat_alloc_user_space(sizeof(*mode));\r\nif (put_user(m32.mode, &mode->mode))\r\nreturn -EFAULT;\r\nreturn drm_ioctl(file, DRM_IOCTL_AGP_ENABLE, (unsigned long)mode);\r\n}\r\nstatic int compat_drm_agp_info(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_agp_info32_t __user *argp = (void __user *)arg;\r\ndrm_agp_info32_t i32;\r\nstruct drm_agp_info __user *info;\r\nint err;\r\ninfo = compat_alloc_user_space(sizeof(*info));\r\nif (!access_ok(VERIFY_WRITE, info, sizeof(*info)))\r\nreturn -EFAULT;\r\nerr = drm_ioctl(file, DRM_IOCTL_AGP_INFO, (unsigned long)info);\r\nif (err)\r\nreturn err;\r\nif (__get_user(i32.agp_version_major, &info->agp_version_major)\r\n|| __get_user(i32.agp_version_minor, &info->agp_version_minor)\r\n|| __get_user(i32.mode, &info->mode)\r\n|| __get_user(i32.aperture_base, &info->aperture_base)\r\n|| __get_user(i32.aperture_size, &info->aperture_size)\r\n|| __get_user(i32.memory_allowed, &info->memory_allowed)\r\n|| __get_user(i32.memory_used, &info->memory_used)\r\n|| __get_user(i32.id_vendor, &info->id_vendor)\r\n|| __get_user(i32.id_device, &info->id_device))\r\nreturn -EFAULT;\r\nif (copy_to_user(argp, &i32, sizeof(i32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int compat_drm_agp_alloc(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_agp_buffer32_t __user *argp = (void __user *)arg;\r\ndrm_agp_buffer32_t req32;\r\nstruct drm_agp_buffer __user *request;\r\nint err;\r\nif (copy_from_user(&req32, argp, sizeof(req32)))\r\nreturn -EFAULT;\r\nrequest = compat_alloc_user_space(sizeof(*request));\r\nif (!access_ok(VERIFY_WRITE, request, sizeof(*request))\r\n|| __put_user(req32.size, &request->size)\r\n|| __put_user(req32.type, &request->type))\r\nreturn -EFAULT;\r\nerr = drm_ioctl(file, DRM_IOCTL_AGP_ALLOC, (unsigned long)request);\r\nif (err)\r\nreturn err;\r\nif (__get_user(req32.handle, &request->handle)\r\n|| __get_user(req32.physical, &request->physical)\r\n|| copy_to_user(argp, &req32, sizeof(req32))) {\r\ndrm_ioctl(file, DRM_IOCTL_AGP_FREE, (unsigned long)request);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int compat_drm_agp_free(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_agp_buffer32_t __user *argp = (void __user *)arg;\r\nstruct drm_agp_buffer __user *request;\r\nu32 handle;\r\nrequest = compat_alloc_user_space(sizeof(*request));\r\nif (!access_ok(VERIFY_WRITE, request, sizeof(*request))\r\n|| get_user(handle, &argp->handle)\r\n|| __put_user(handle, &request->handle))\r\nreturn -EFAULT;\r\nreturn drm_ioctl(file, DRM_IOCTL_AGP_FREE, (unsigned long)request);\r\n}\r\nstatic int compat_drm_agp_bind(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_agp_binding32_t __user *argp = (void __user *)arg;\r\ndrm_agp_binding32_t req32;\r\nstruct drm_agp_binding __user *request;\r\nif (copy_from_user(&req32, argp, sizeof(req32)))\r\nreturn -EFAULT;\r\nrequest = compat_alloc_user_space(sizeof(*request));\r\nif (!access_ok(VERIFY_WRITE, request, sizeof(*request))\r\n|| __put_user(req32.handle, &request->handle)\r\n|| __put_user(req32.offset, &request->offset))\r\nreturn -EFAULT;\r\nreturn drm_ioctl(file, DRM_IOCTL_AGP_BIND, (unsigned long)request);\r\n}\r\nstatic int compat_drm_agp_unbind(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_agp_binding32_t __user *argp = (void __user *)arg;\r\nstruct drm_agp_binding __user *request;\r\nu32 handle;\r\nrequest = compat_alloc_user_space(sizeof(*request));\r\nif (!access_ok(VERIFY_WRITE, request, sizeof(*request))\r\n|| get_user(handle, &argp->handle)\r\n|| __put_user(handle, &request->handle))\r\nreturn -EFAULT;\r\nreturn drm_ioctl(file, DRM_IOCTL_AGP_UNBIND, (unsigned long)request);\r\n}\r\nstatic int compat_drm_sg_alloc(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_scatter_gather32_t __user *argp = (void __user *)arg;\r\nstruct drm_scatter_gather __user *request;\r\nint err;\r\nunsigned long x;\r\nrequest = compat_alloc_user_space(sizeof(*request));\r\nif (!access_ok(VERIFY_WRITE, request, sizeof(*request))\r\n|| !access_ok(VERIFY_WRITE, argp, sizeof(*argp))\r\n|| __get_user(x, &argp->size)\r\n|| __put_user(x, &request->size))\r\nreturn -EFAULT;\r\nerr = drm_ioctl(file, DRM_IOCTL_SG_ALLOC, (unsigned long)request);\r\nif (err)\r\nreturn err;\r\nif (__get_user(x, &request->handle)\r\n|| __put_user(x >> PAGE_SHIFT, &argp->handle))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int compat_drm_sg_free(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_scatter_gather32_t __user *argp = (void __user *)arg;\r\nstruct drm_scatter_gather __user *request;\r\nunsigned long x;\r\nrequest = compat_alloc_user_space(sizeof(*request));\r\nif (!access_ok(VERIFY_WRITE, request, sizeof(*request))\r\n|| !access_ok(VERIFY_WRITE, argp, sizeof(*argp))\r\n|| __get_user(x, &argp->handle)\r\n|| __put_user(x << PAGE_SHIFT, &request->handle))\r\nreturn -EFAULT;\r\nreturn drm_ioctl(file, DRM_IOCTL_SG_FREE, (unsigned long)request);\r\n}\r\nstatic int compat_drm_update_draw(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_update_draw32_t update32;\r\nstruct drm_update_draw __user *request;\r\nint err;\r\nif (copy_from_user(&update32, (void __user *)arg, sizeof(update32)))\r\nreturn -EFAULT;\r\nrequest = compat_alloc_user_space(sizeof(*request));\r\nif (!access_ok(VERIFY_WRITE, request, sizeof(*request)) ||\r\n__put_user(update32.handle, &request->handle) ||\r\n__put_user(update32.type, &request->type) ||\r\n__put_user(update32.num, &request->num) ||\r\n__put_user(update32.data, &request->data))\r\nreturn -EFAULT;\r\nerr = drm_ioctl(file, DRM_IOCTL_UPDATE_DRAW, (unsigned long)request);\r\nreturn err;\r\n}\r\nstatic int compat_drm_wait_vblank(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\ndrm_wait_vblank32_t __user *argp = (void __user *)arg;\r\ndrm_wait_vblank32_t req32;\r\nunion drm_wait_vblank __user *request;\r\nint err;\r\nif (copy_from_user(&req32, argp, sizeof(req32)))\r\nreturn -EFAULT;\r\nrequest = compat_alloc_user_space(sizeof(*request));\r\nif (!access_ok(VERIFY_WRITE, request, sizeof(*request))\r\n|| __put_user(req32.request.type, &request->request.type)\r\n|| __put_user(req32.request.sequence, &request->request.sequence)\r\n|| __put_user(req32.request.signal, &request->request.signal))\r\nreturn -EFAULT;\r\nerr = drm_ioctl(file, DRM_IOCTL_WAIT_VBLANK, (unsigned long)request);\r\nif (err)\r\nreturn err;\r\nif (__get_user(req32.reply.type, &request->reply.type)\r\n|| __get_user(req32.reply.sequence, &request->reply.sequence)\r\n|| __get_user(req32.reply.tval_sec, &request->reply.tval_sec)\r\n|| __get_user(req32.reply.tval_usec, &request->reply.tval_usec))\r\nreturn -EFAULT;\r\nif (copy_to_user(argp, &req32, sizeof(req32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nlong drm_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nunsigned int nr = DRM_IOCTL_NR(cmd);\r\ndrm_ioctl_compat_t *fn;\r\nint ret;\r\nif (nr >= ARRAY_SIZE(drm_compat_ioctls))\r\nreturn drm_ioctl(filp, cmd, arg);\r\nfn = drm_compat_ioctls[nr];\r\nif (fn != NULL)\r\nret = (*fn) (filp, cmd, arg);\r\nelse\r\nret = drm_ioctl(filp, cmd, arg);\r\nreturn ret;\r\n}
