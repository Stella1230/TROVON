static struct llog_ctxt *llog_new_ctxt(struct obd_device *obd)\r\n{\r\nstruct llog_ctxt *ctxt;\r\nOBD_ALLOC_PTR(ctxt);\r\nif (!ctxt)\r\nreturn NULL;\r\nctxt->loc_obd = obd;\r\natomic_set(&ctxt->loc_refcount, 1);\r\nreturn ctxt;\r\n}\r\nstatic void llog_ctxt_destroy(struct llog_ctxt *ctxt)\r\n{\r\nif (ctxt->loc_exp) {\r\nclass_export_put(ctxt->loc_exp);\r\nctxt->loc_exp = NULL;\r\n}\r\nif (ctxt->loc_imp) {\r\nclass_import_put(ctxt->loc_imp);\r\nctxt->loc_imp = NULL;\r\n}\r\nOBD_FREE_PTR(ctxt);\r\n}\r\nint __llog_ctxt_put(const struct lu_env *env, struct llog_ctxt *ctxt)\r\n{\r\nstruct obd_llog_group *olg = ctxt->loc_olg;\r\nstruct obd_device *obd;\r\nint rc = 0;\r\nspin_lock(&olg->olg_lock);\r\nif (!atomic_dec_and_test(&ctxt->loc_refcount)) {\r\nspin_unlock(&olg->olg_lock);\r\nreturn rc;\r\n}\r\nolg->olg_ctxts[ctxt->loc_idx] = NULL;\r\nspin_unlock(&olg->olg_lock);\r\nobd = ctxt->loc_obd;\r\nspin_lock(&obd->obd_dev_lock);\r\nspin_unlock(&obd->obd_dev_lock);\r\nLASSERTF(obd->obd_starting == 1 ||\r\nobd->obd_stopping == 1 || obd->obd_set_up == 0,\r\n"wrong obd state: %d/%d/%d\n", !!obd->obd_starting,\r\n!!obd->obd_stopping, !!obd->obd_set_up);\r\nif (CTXTP(ctxt, cleanup))\r\nrc = CTXTP(ctxt, cleanup)(env, ctxt);\r\nllog_ctxt_destroy(ctxt);\r\nwake_up(&olg->olg_waitq);\r\nreturn rc;\r\n}\r\nint llog_cleanup(const struct lu_env *env, struct llog_ctxt *ctxt)\r\n{\r\nstruct l_wait_info lwi = LWI_INTR(LWI_ON_SIGNAL_NOOP, NULL);\r\nstruct obd_llog_group *olg;\r\nint rc, idx;\r\nLASSERT(ctxt != NULL);\r\nLASSERT(ctxt != LP_POISON);\r\nolg = ctxt->loc_olg;\r\nLASSERT(olg != NULL);\r\nLASSERT(olg != LP_POISON);\r\nidx = ctxt->loc_idx;\r\nLASSERT(atomic_read(&ctxt->loc_refcount) < LI_POISON);\r\nLASSERT(atomic_read(&ctxt->loc_refcount) > 1);\r\nllog_ctxt_put(ctxt);\r\nrc = __llog_ctxt_put(env, ctxt);\r\nif (rc)\r\nCERROR("Error %d while cleaning up ctxt %p\n",\r\nrc, ctxt);\r\nl_wait_event(olg->olg_waitq,\r\nllog_group_ctxt_null(olg, idx), &lwi);\r\nreturn rc;\r\n}\r\nint llog_setup(const struct lu_env *env, struct obd_device *obd,\r\nstruct obd_llog_group *olg, int index,\r\nstruct obd_device *disk_obd, struct llog_operations *op)\r\n{\r\nstruct llog_ctxt *ctxt;\r\nint rc = 0;\r\nif (index < 0 || index >= LLOG_MAX_CTXTS)\r\nreturn -EINVAL;\r\nLASSERT(olg != NULL);\r\nctxt = llog_new_ctxt(obd);\r\nif (!ctxt)\r\nreturn -ENOMEM;\r\nctxt->loc_obd = obd;\r\nctxt->loc_olg = olg;\r\nctxt->loc_idx = index;\r\nctxt->loc_logops = op;\r\nmutex_init(&ctxt->loc_mutex);\r\nctxt->loc_exp = class_export_get(disk_obd->obd_self_export);\r\nctxt->loc_flags = LLOG_CTXT_FLAG_UNINITIALIZED;\r\nrc = llog_group_set_ctxt(olg, ctxt, index);\r\nif (rc) {\r\nllog_ctxt_destroy(ctxt);\r\nif (rc == -EEXIST) {\r\nctxt = llog_group_get_ctxt(olg, index);\r\nif (ctxt) {\r\nCDEBUG(D_CONFIG, "obd %s ctxt %d already set up\n",\r\nobd->obd_name, index);\r\nLASSERT(ctxt->loc_olg == olg);\r\nLASSERT(ctxt->loc_obd == obd);\r\nLASSERT(ctxt->loc_exp == disk_obd->obd_self_export);\r\nLASSERT(ctxt->loc_logops == op);\r\nllog_ctxt_put(ctxt);\r\n}\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nif (op->lop_setup) {\r\nif (OBD_FAIL_CHECK(OBD_FAIL_OBD_LLOG_SETUP))\r\nrc = -EOPNOTSUPP;\r\nelse\r\nrc = op->lop_setup(env, obd, olg, index, disk_obd);\r\n}\r\nif (rc) {\r\nCERROR("%s: ctxt %d lop_setup=%p failed: rc = %d\n",\r\nobd->obd_name, index, op->lop_setup, rc);\r\nllog_group_clear_ctxt(olg, index);\r\nllog_ctxt_destroy(ctxt);\r\n} else {\r\nCDEBUG(D_CONFIG, "obd %s ctxt %d is initialized\n",\r\nobd->obd_name, index);\r\nctxt->loc_flags &= ~LLOG_CTXT_FLAG_UNINITIALIZED;\r\n}\r\nreturn rc;\r\n}\r\nint llog_sync(struct llog_ctxt *ctxt, struct obd_export *exp, int flags)\r\n{\r\nint rc = 0;\r\nif (!ctxt)\r\nreturn 0;\r\nif (CTXTP(ctxt, sync))\r\nrc = CTXTP(ctxt, sync)(ctxt, exp, flags);\r\nreturn rc;\r\n}\r\nint llog_cancel(const struct lu_env *env, struct llog_ctxt *ctxt,\r\nstruct llog_cookie *cookies, int flags)\r\n{\r\nint rc;\r\nif (!ctxt) {\r\nCERROR("No ctxt\n");\r\nreturn -ENODEV;\r\n}\r\nCTXT_CHECK_OP(ctxt, cancel, -EOPNOTSUPP);\r\nrc = CTXTP(ctxt, cancel)(env, ctxt, cookies, flags);\r\nreturn rc;\r\n}\r\nint llog_info_init(void)\r\n{\r\nllog_key_init_generic(&llog_thread_key, NULL);\r\nlu_context_key_register(&llog_thread_key);\r\nreturn 0;\r\n}\r\nvoid llog_info_fini(void)\r\n{\r\nlu_context_key_degister(&llog_thread_key);\r\n}
