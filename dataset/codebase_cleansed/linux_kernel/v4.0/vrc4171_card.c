static inline uint16_t vrc4171_get_irq_status(void)\r\n{\r\nreturn inw(INTERRUPT_STATUS);\r\n}\r\nstatic inline void vrc4171_set_multifunction_pin(vrc4171_slotb_t config)\r\n{\r\nuint16_t config1;\r\nconfig1 = inw(CONFIGURATION1);\r\nconfig1 &= ~SLOTB_CONFIG;\r\nswitch (config) {\r\ncase SLOTB_IS_NONE:\r\nconfig1 |= SLOTB_NONE;\r\nbreak;\r\ncase SLOTB_IS_PCCARD:\r\nconfig1 |= SLOTB_PCCARD;\r\nbreak;\r\ncase SLOTB_IS_CF:\r\nconfig1 |= SLOTB_CF;\r\nbreak;\r\ncase SLOTB_IS_FLASHROM:\r\nconfig1 |= SLOTB_FLASHROM;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\noutw(config1, CONFIGURATION1);\r\n}\r\nstatic inline uint8_t exca_read_byte(int slot, uint8_t index)\r\n{\r\nif (slot == CARD_SLOTB)\r\nindex += CARD_SLOTB_OFFSET;\r\noutb(index, CARD_CONTROLLER_INDEX);\r\nreturn inb(CARD_CONTROLLER_DATA);\r\n}\r\nstatic inline uint16_t exca_read_word(int slot, uint8_t index)\r\n{\r\nuint16_t data;\r\nif (slot == CARD_SLOTB)\r\nindex += CARD_SLOTB_OFFSET;\r\noutb(index++, CARD_CONTROLLER_INDEX);\r\ndata = inb(CARD_CONTROLLER_DATA);\r\noutb(index, CARD_CONTROLLER_INDEX);\r\ndata |= ((uint16_t)inb(CARD_CONTROLLER_DATA)) << 8;\r\nreturn data;\r\n}\r\nstatic inline uint8_t exca_write_byte(int slot, uint8_t index, uint8_t data)\r\n{\r\nif (slot == CARD_SLOTB)\r\nindex += CARD_SLOTB_OFFSET;\r\noutb(index, CARD_CONTROLLER_INDEX);\r\noutb(data, CARD_CONTROLLER_DATA);\r\nreturn data;\r\n}\r\nstatic inline uint16_t exca_write_word(int slot, uint8_t index, uint16_t data)\r\n{\r\nif (slot == CARD_SLOTB)\r\nindex += CARD_SLOTB_OFFSET;\r\noutb(index++, CARD_CONTROLLER_INDEX);\r\noutb(data, CARD_CONTROLLER_DATA);\r\noutb(index, CARD_CONTROLLER_INDEX);\r\noutb((uint8_t)(data >> 8), CARD_CONTROLLER_DATA);\r\nreturn data;\r\n}\r\nstatic inline int search_nonuse_irq(void)\r\n{\r\nint i;\r\nfor (i = 0; i < 16; i++) {\r\nif (vrc4171_irq_mask & (1 << i)) {\r\nvrc4171_irq_mask &= ~(1 << i);\r\nreturn i;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int pccard_init(struct pcmcia_socket *sock)\r\n{\r\nvrc4171_socket_t *socket;\r\nunsigned int slot;\r\nsock->features |= SS_CAP_PCCARD | SS_CAP_PAGE_REGS;\r\nsock->irq_mask = 0;\r\nsock->map_size = 0x1000;\r\nsock->pci_irq = vrc4171_irq;\r\nslot = sock->sock;\r\nsocket = &vrc4171_sockets[slot];\r\nsocket->csc_irq = search_nonuse_irq();\r\nsocket->io_irq = search_nonuse_irq();\r\nspin_lock_init(&socket->lock);\r\nreturn 0;\r\n}\r\nstatic int pccard_get_status(struct pcmcia_socket *sock, u_int *value)\r\n{\r\nunsigned int slot;\r\nuint8_t status, sense;\r\nu_int val = 0;\r\nif (sock == NULL || sock->sock >= CARD_MAX_SLOTS || value == NULL)\r\nreturn -EINVAL;\r\nslot = sock->sock;\r\nstatus = exca_read_byte(slot, I365_STATUS);\r\nif (exca_read_byte(slot, I365_INTCTL) & I365_PC_IOCARD) {\r\nif (status & I365_CS_STSCHG)\r\nval |= SS_STSCHG;\r\n} else {\r\nif (!(status & I365_CS_BVD1))\r\nval |= SS_BATDEAD;\r\nelse if ((status & (I365_CS_BVD1 | I365_CS_BVD2)) == I365_CS_BVD1)\r\nval |= SS_BATWARN;\r\n}\r\nif ((status & I365_CS_DETECT) == I365_CS_DETECT)\r\nval |= SS_DETECT;\r\nif (status & I365_CS_WRPROT)\r\nval |= SS_WRPROT;\r\nif (status & I365_CS_READY)\r\nval |= SS_READY;\r\nif (status & I365_CS_POWERON)\r\nval |= SS_POWERON;\r\nsense = exca_read_byte(slot, CARD_VOLTAGE_SENSE);\r\nswitch (sense) {\r\ncase VCC_3VORXV_CAPABLE:\r\nval |= SS_3VCARD | SS_XVCARD;\r\nbreak;\r\ncase VCC_XV_ONLY:\r\nval |= SS_XVCARD;\r\nbreak;\r\ncase VCC_3V_CAPABLE:\r\nval |= SS_3VCARD;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n*value = val;\r\nreturn 0;\r\n}\r\nstatic inline uint8_t set_Vcc_value(u_char Vcc)\r\n{\r\nswitch (Vcc) {\r\ncase 33:\r\nreturn VCC_3V;\r\ncase 50:\r\nreturn VCC_5V;\r\n}\r\nreturn VCC_3V;\r\n}\r\nstatic int pccard_set_socket(struct pcmcia_socket *sock, socket_state_t *state)\r\n{\r\nvrc4171_socket_t *socket;\r\nunsigned int slot;\r\nuint8_t voltage, power, control, cscint;\r\nif (sock == NULL || sock->sock >= CARD_MAX_SLOTS ||\r\n(state->Vpp != state->Vcc && state->Vpp != 0) ||\r\n(state->Vcc != 50 && state->Vcc != 33 && state->Vcc != 0))\r\nreturn -EINVAL;\r\nslot = sock->sock;\r\nsocket = &vrc4171_sockets[slot];\r\nspin_lock_irq(&socket->lock);\r\nvoltage = set_Vcc_value(state->Vcc);\r\nexca_write_byte(slot, CARD_VOLTAGE_SELECT, voltage);\r\npower = POWER_ENABLE;\r\nif (state->Vpp == state->Vcc)\r\npower |= VPP_GET_VCC;\r\nif (state->flags & SS_OUTPUT_ENA)\r\npower |= I365_PWR_OUT;\r\nexca_write_byte(slot, I365_POWER, power);\r\ncontrol = 0;\r\nif (state->io_irq != 0)\r\ncontrol |= socket->io_irq;\r\nif (state->flags & SS_IOCARD)\r\ncontrol |= I365_PC_IOCARD;\r\nif (state->flags & SS_RESET)\r\ncontrol &= ~I365_PC_RESET;\r\nelse\r\ncontrol |= I365_PC_RESET;\r\nexca_write_byte(slot, I365_INTCTL, control);\r\ncscint = 0;\r\nexca_write_byte(slot, I365_CSCINT, cscint);\r\nexca_read_byte(slot, I365_CSC);\r\nif (state->csc_mask != 0)\r\ncscint |= socket->csc_irq << 8;\r\nif (state->flags & SS_IOCARD) {\r\nif (state->csc_mask & SS_STSCHG)\r\ncscint |= I365_CSC_STSCHG;\r\n} else {\r\nif (state->csc_mask & SS_BATDEAD)\r\ncscint |= I365_CSC_BVD1;\r\nif (state->csc_mask & SS_BATWARN)\r\ncscint |= I365_CSC_BVD2;\r\n}\r\nif (state->csc_mask & SS_READY)\r\ncscint |= I365_CSC_READY;\r\nif (state->csc_mask & SS_DETECT)\r\ncscint |= I365_CSC_DETECT;\r\nexca_write_byte(slot, I365_CSCINT, cscint);\r\nspin_unlock_irq(&socket->lock);\r\nreturn 0;\r\n}\r\nstatic int pccard_set_io_map(struct pcmcia_socket *sock, struct pccard_io_map *io)\r\n{\r\nunsigned int slot;\r\nuint8_t ioctl, addrwin;\r\nu_char map;\r\nif (sock == NULL || sock->sock >= CARD_MAX_SLOTS ||\r\nio == NULL || io->map >= IO_MAX_MAPS ||\r\nio->start > 0xffff || io->stop > 0xffff || io->start > io->stop)\r\nreturn -EINVAL;\r\nslot = sock->sock;\r\nmap = io->map;\r\naddrwin = exca_read_byte(slot, I365_ADDRWIN);\r\nif (addrwin & I365_ENA_IO(map)) {\r\naddrwin &= ~I365_ENA_IO(map);\r\nexca_write_byte(slot, I365_ADDRWIN, addrwin);\r\n}\r\nexca_write_word(slot, I365_IO(map)+I365_W_START, io->start);\r\nexca_write_word(slot, I365_IO(map)+I365_W_STOP, io->stop);\r\nioctl = 0;\r\nif (io->speed > 0)\r\nioctl |= I365_IOCTL_WAIT(map);\r\nif (io->flags & MAP_16BIT)\r\nioctl |= I365_IOCTL_16BIT(map);\r\nif (io->flags & MAP_AUTOSZ)\r\nioctl |= I365_IOCTL_IOCS16(map);\r\nif (io->flags & MAP_0WS)\r\nioctl |= I365_IOCTL_0WS(map);\r\nexca_write_byte(slot, I365_IOCTL, ioctl);\r\nif (io->flags & MAP_ACTIVE) {\r\naddrwin |= I365_ENA_IO(map);\r\nexca_write_byte(slot, I365_ADDRWIN, addrwin);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pccard_set_mem_map(struct pcmcia_socket *sock, struct pccard_mem_map *mem)\r\n{\r\nunsigned int slot;\r\nuint16_t start, stop, offset;\r\nuint8_t addrwin;\r\nu_char map;\r\nif (sock == NULL || sock->sock >= CARD_MAX_SLOTS ||\r\nmem == NULL || mem->map >= MEM_MAX_MAPS ||\r\nmem->res->start < CARD_MEM_START || mem->res->start > CARD_MEM_END ||\r\nmem->res->end < CARD_MEM_START || mem->res->end > CARD_MEM_END ||\r\nmem->res->start > mem->res->end ||\r\nmem->card_start > CARD_MAX_MEM_OFFSET ||\r\nmem->speed > CARD_MAX_MEM_SPEED)\r\nreturn -EINVAL;\r\nslot = sock->sock;\r\nmap = mem->map;\r\naddrwin = exca_read_byte(slot, I365_ADDRWIN);\r\nif (addrwin & I365_ENA_MEM(map)) {\r\naddrwin &= ~I365_ENA_MEM(map);\r\nexca_write_byte(slot, I365_ADDRWIN, addrwin);\r\n}\r\nstart = (mem->res->start >> 12) & 0x3fff;\r\nif (mem->flags & MAP_16BIT)\r\nstart |= I365_MEM_16BIT;\r\nexca_write_word(slot, I365_MEM(map)+I365_W_START, start);\r\nstop = (mem->res->end >> 12) & 0x3fff;\r\nswitch (mem->speed) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nstop |= I365_MEM_WS0;\r\nbreak;\r\ncase 2:\r\nstop |= I365_MEM_WS1;\r\nbreak;\r\ndefault:\r\nstop |= I365_MEM_WS0 | I365_MEM_WS1;\r\nbreak;\r\n}\r\nexca_write_word(slot, I365_MEM(map)+I365_W_STOP, stop);\r\noffset = (mem->card_start >> 12) & 0x3fff;\r\nif (mem->flags & MAP_ATTRIB)\r\noffset |= I365_MEM_REG;\r\nif (mem->flags & MAP_WRPROT)\r\noffset |= I365_MEM_WRPROT;\r\nexca_write_word(slot, I365_MEM(map)+I365_W_OFF, offset);\r\nif (mem->flags & MAP_ACTIVE) {\r\naddrwin |= I365_ENA_MEM(map);\r\nexca_write_byte(slot, I365_ADDRWIN, addrwin);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline unsigned int get_events(int slot)\r\n{\r\nunsigned int events = 0;\r\nuint8_t status, csc;\r\nstatus = exca_read_byte(slot, I365_STATUS);\r\ncsc = exca_read_byte(slot, I365_CSC);\r\nif (exca_read_byte(slot, I365_INTCTL) & I365_PC_IOCARD) {\r\nif ((csc & I365_CSC_STSCHG) && (status & I365_CS_STSCHG))\r\nevents |= SS_STSCHG;\r\n} else {\r\nif (csc & (I365_CSC_BVD1 | I365_CSC_BVD2)) {\r\nif (!(status & I365_CS_BVD1))\r\nevents |= SS_BATDEAD;\r\nelse if ((status & (I365_CS_BVD1 | I365_CS_BVD2)) == I365_CS_BVD1)\r\nevents |= SS_BATWARN;\r\n}\r\n}\r\nif ((csc & I365_CSC_READY) && (status & I365_CS_READY))\r\nevents |= SS_READY;\r\nif ((csc & I365_CSC_DETECT) && ((status & I365_CS_DETECT) == I365_CS_DETECT))\r\nevents |= SS_DETECT;\r\nreturn events;\r\n}\r\nstatic irqreturn_t pccard_interrupt(int irq, void *dev_id)\r\n{\r\nvrc4171_socket_t *socket;\r\nunsigned int events;\r\nirqreturn_t retval = IRQ_NONE;\r\nuint16_t status;\r\nstatus = vrc4171_get_irq_status();\r\nif (status & IRQ_A) {\r\nsocket = &vrc4171_sockets[CARD_SLOTA];\r\nif (socket->slot == SLOT_INITIALIZED) {\r\nif (status & (1 << socket->csc_irq)) {\r\nevents = get_events(CARD_SLOTA);\r\nif (events != 0) {\r\npcmcia_parse_events(&socket->pcmcia_socket, events);\r\nretval = IRQ_HANDLED;\r\n}\r\n}\r\n}\r\n}\r\nif (status & IRQ_B) {\r\nsocket = &vrc4171_sockets[CARD_SLOTB];\r\nif (socket->slot == SLOT_INITIALIZED) {\r\nif (status & (1 << socket->csc_irq)) {\r\nevents = get_events(CARD_SLOTB);\r\nif (events != 0) {\r\npcmcia_parse_events(&socket->pcmcia_socket, events);\r\nretval = IRQ_HANDLED;\r\n}\r\n}\r\n}\r\n}\r\nreturn retval;\r\n}\r\nstatic inline void reserve_using_irq(int slot)\r\n{\r\nunsigned int irq;\r\nirq = exca_read_byte(slot, I365_INTCTL);\r\nirq &= 0x0f;\r\nvrc4171_irq_mask &= ~(1 << irq);\r\nirq = exca_read_byte(slot, I365_CSCINT);\r\nirq = (irq & 0xf0) >> 4;\r\nvrc4171_irq_mask &= ~(1 << irq);\r\n}\r\nstatic int vrc4171_add_sockets(void)\r\n{\r\nvrc4171_socket_t *socket;\r\nint slot, retval;\r\nfor (slot = 0; slot < CARD_MAX_SLOTS; slot++) {\r\nif (slot == CARD_SLOTB && vrc4171_slotb == SLOTB_IS_NONE)\r\ncontinue;\r\nsocket = &vrc4171_sockets[slot];\r\nif (socket->slot != SLOT_PROBE) {\r\nuint8_t addrwin;\r\nswitch (socket->slot) {\r\ncase SLOT_NOPROBE_MEM:\r\naddrwin = exca_read_byte(slot, I365_ADDRWIN);\r\naddrwin &= 0x1f;\r\nexca_write_byte(slot, I365_ADDRWIN, addrwin);\r\nbreak;\r\ncase SLOT_NOPROBE_IO:\r\naddrwin = exca_read_byte(slot, I365_ADDRWIN);\r\naddrwin &= 0xc0;\r\nexca_write_byte(slot, I365_ADDRWIN, addrwin);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreserve_using_irq(slot);\r\ncontinue;\r\n}\r\nsprintf(socket->name, "NEC VRC4171 Card Slot %1c", 'A' + slot);\r\nsocket->pcmcia_socket.dev.parent = &vrc4171_card_device.dev;\r\nsocket->pcmcia_socket.ops = &vrc4171_pccard_operations;\r\nsocket->pcmcia_socket.owner = THIS_MODULE;\r\nretval = pcmcia_register_socket(&socket->pcmcia_socket);\r\nif (retval < 0)\r\nreturn retval;\r\nexca_write_byte(slot, I365_ADDRWIN, 0);\r\nexca_write_byte(slot, GLOBAL_CONTROL, 0);\r\nsocket->slot = SLOT_INITIALIZED;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vrc4171_remove_sockets(void)\r\n{\r\nvrc4171_socket_t *socket;\r\nint slot;\r\nfor (slot = 0; slot < CARD_MAX_SLOTS; slot++) {\r\nif (slot == CARD_SLOTB && vrc4171_slotb == SLOTB_IS_NONE)\r\ncontinue;\r\nsocket = &vrc4171_sockets[slot];\r\nif (socket->slot == SLOT_INITIALIZED)\r\npcmcia_unregister_socket(&socket->pcmcia_socket);\r\nsocket->slot = SLOT_PROBE;\r\n}\r\n}\r\nstatic int vrc4171_card_setup(char *options)\r\n{\r\nif (options == NULL || *options == '\0')\r\nreturn 1;\r\nif (strncmp(options, "irq:", 4) == 0) {\r\nint irq;\r\noptions += 4;\r\nirq = simple_strtoul(options, &options, 0);\r\nif (irq >= 0 && irq < nr_irqs)\r\nvrc4171_irq = irq;\r\nif (*options != ',')\r\nreturn 1;\r\noptions++;\r\n}\r\nif (strncmp(options, "slota:", 6) == 0) {\r\noptions += 6;\r\nif (*options != '\0') {\r\nif (strncmp(options, "memnoprobe", 10) == 0) {\r\nvrc4171_sockets[CARD_SLOTA].slot = SLOT_NOPROBE_MEM;\r\noptions += 10;\r\n} else if (strncmp(options, "ionoprobe", 9) == 0) {\r\nvrc4171_sockets[CARD_SLOTA].slot = SLOT_NOPROBE_IO;\r\noptions += 9;\r\n} else if ( strncmp(options, "noprobe", 7) == 0) {\r\nvrc4171_sockets[CARD_SLOTA].slot = SLOT_NOPROBE_ALL;\r\noptions += 7;\r\n}\r\nif (*options != ',')\r\nreturn 1;\r\noptions++;\r\n} else\r\nreturn 1;\r\n}\r\nif (strncmp(options, "slotb:", 6) == 0) {\r\noptions += 6;\r\nif (*options != '\0') {\r\nif (strncmp(options, "pccard", 6) == 0) {\r\nvrc4171_slotb = SLOTB_IS_PCCARD;\r\noptions += 6;\r\n} else if (strncmp(options, "cf", 2) == 0) {\r\nvrc4171_slotb = SLOTB_IS_CF;\r\noptions += 2;\r\n} else if (strncmp(options, "flashrom", 8) == 0) {\r\nvrc4171_slotb = SLOTB_IS_FLASHROM;\r\noptions += 8;\r\n} else if (strncmp(options, "none", 4) == 0) {\r\nvrc4171_slotb = SLOTB_IS_NONE;\r\noptions += 4;\r\n}\r\nif (*options != ',')\r\nreturn 1;\r\noptions++;\r\nif (strncmp(options, "memnoprobe", 10) == 0)\r\nvrc4171_sockets[CARD_SLOTB].slot = SLOT_NOPROBE_MEM;\r\nif (strncmp(options, "ionoprobe", 9) == 0)\r\nvrc4171_sockets[CARD_SLOTB].slot = SLOT_NOPROBE_IO;\r\nif (strncmp(options, "noprobe", 7) == 0)\r\nvrc4171_sockets[CARD_SLOTB].slot = SLOT_NOPROBE_ALL;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int vrc4171_card_init(void)\r\n{\r\nint retval;\r\nretval = platform_driver_register(&vrc4171_card_driver);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = platform_device_register(&vrc4171_card_device);\r\nif (retval < 0) {\r\nplatform_driver_unregister(&vrc4171_card_driver);\r\nreturn retval;\r\n}\r\nvrc4171_set_multifunction_pin(vrc4171_slotb);\r\nretval = vrc4171_add_sockets();\r\nif (retval == 0)\r\nretval = request_irq(vrc4171_irq, pccard_interrupt, IRQF_SHARED,\r\nvrc4171_card_name, vrc4171_sockets);\r\nif (retval < 0) {\r\nvrc4171_remove_sockets();\r\nplatform_device_unregister(&vrc4171_card_device);\r\nplatform_driver_unregister(&vrc4171_card_driver);\r\nreturn retval;\r\n}\r\nprintk(KERN_INFO "%s, connected to IRQ %d\n",\r\nvrc4171_card_driver.driver.name, vrc4171_irq);\r\nreturn 0;\r\n}\r\nstatic void vrc4171_card_exit(void)\r\n{\r\nfree_irq(vrc4171_irq, vrc4171_sockets);\r\nvrc4171_remove_sockets();\r\nplatform_device_unregister(&vrc4171_card_device);\r\nplatform_driver_unregister(&vrc4171_card_driver);\r\n}
