void intc_irq_xlate_set(unsigned int irq, intc_enum id, struct intc_desc_int *d)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&intc_big_lock, flags);\r\nintc_irq_xlate[irq].enum_id = id;\r\nintc_irq_xlate[irq].desc = d;\r\nraw_spin_unlock_irqrestore(&intc_big_lock, flags);\r\n}\r\nstruct intc_map_entry *intc_irq_xlate_get(unsigned int irq)\r\n{\r\nreturn intc_irq_xlate + irq;\r\n}\r\nint intc_irq_lookup(const char *chipname, intc_enum enum_id)\r\n{\r\nstruct intc_map_entry *ptr;\r\nstruct intc_desc_int *d;\r\nint irq = -1;\r\nlist_for_each_entry(d, &intc_list, list) {\r\nint tagged;\r\nif (strcmp(d->chip.name, chipname) != 0)\r\ncontinue;\r\ntagged = radix_tree_tag_get(&d->tree, enum_id,\r\nINTC_TAG_VIRQ_NEEDS_ALLOC);\r\nif (unlikely(tagged))\r\nbreak;\r\nptr = radix_tree_lookup(&d->tree, enum_id);\r\nif (ptr) {\r\nirq = ptr - intc_irq_xlate;\r\nbreak;\r\n}\r\n}\r\nreturn irq;\r\n}\r\nstatic int add_virq_to_pirq(unsigned int irq, unsigned int virq)\r\n{\r\nstruct intc_virq_list **last, *entry;\r\nstruct irq_data *data = irq_get_irq_data(irq);\r\nlast = (struct intc_virq_list **)&data->handler_data;\r\nfor_each_virq(entry, data->handler_data) {\r\nif (entry->irq == virq)\r\nreturn 0;\r\nlast = &entry->next;\r\n}\r\nentry = kzalloc(sizeof(struct intc_virq_list), GFP_ATOMIC);\r\nif (!entry) {\r\npr_err("can't allocate VIRQ mapping for %d\n", virq);\r\nreturn -ENOMEM;\r\n}\r\nentry->irq = virq;\r\n*last = entry;\r\nreturn 0;\r\n}\r\nstatic void intc_virq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct irq_data *data = irq_get_irq_data(irq);\r\nstruct irq_chip *chip = irq_data_get_irq_chip(data);\r\nstruct intc_virq_list *entry, *vlist = irq_data_get_irq_handler_data(data);\r\nstruct intc_desc_int *d = get_intc_desc(irq);\r\nchip->irq_mask_ack(data);\r\nfor_each_virq(entry, vlist) {\r\nunsigned long addr, handle;\r\nhandle = (unsigned long)irq_get_handler_data(entry->irq);\r\naddr = INTC_REG(d, _INTC_ADDR_E(handle), 0);\r\nif (intc_reg_fns[_INTC_FN(handle)](addr, handle, 0))\r\ngeneric_handle_irq(entry->irq);\r\n}\r\nchip->irq_unmask(data);\r\n}\r\nstatic unsigned long __init intc_subgroup_data(struct intc_subgroup *subgroup,\r\nstruct intc_desc_int *d,\r\nunsigned int index)\r\n{\r\nunsigned int fn = REG_FN_TEST_BASE + (subgroup->reg_width >> 3) - 1;\r\nreturn _INTC_MK(fn, MODE_ENABLE_REG, intc_get_reg(d, subgroup->reg),\r\n0, 1, (subgroup->reg_width - 1) - index);\r\n}\r\nstatic void __init intc_subgroup_init_one(struct intc_desc *desc,\r\nstruct intc_desc_int *d,\r\nstruct intc_subgroup *subgroup)\r\n{\r\nstruct intc_map_entry *mapped;\r\nunsigned int pirq;\r\nunsigned long flags;\r\nint i;\r\nmapped = radix_tree_lookup(&d->tree, subgroup->parent_id);\r\nif (!mapped) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\npirq = mapped - intc_irq_xlate;\r\nraw_spin_lock_irqsave(&d->lock, flags);\r\nfor (i = 0; i < ARRAY_SIZE(subgroup->enum_ids); i++) {\r\nstruct intc_subgroup_entry *entry;\r\nint err;\r\nif (!subgroup->enum_ids[i])\r\ncontinue;\r\nentry = kmalloc(sizeof(*entry), GFP_NOWAIT);\r\nif (!entry)\r\nbreak;\r\nentry->pirq = pirq;\r\nentry->enum_id = subgroup->enum_ids[i];\r\nentry->handle = intc_subgroup_data(subgroup, d, i);\r\nerr = radix_tree_insert(&d->tree, entry->enum_id, entry);\r\nif (unlikely(err < 0))\r\nbreak;\r\nradix_tree_tag_set(&d->tree, entry->enum_id,\r\nINTC_TAG_VIRQ_NEEDS_ALLOC);\r\n}\r\nraw_spin_unlock_irqrestore(&d->lock, flags);\r\n}\r\nvoid __init intc_subgroup_init(struct intc_desc *desc, struct intc_desc_int *d)\r\n{\r\nint i;\r\nif (!desc->hw.subgroups)\r\nreturn;\r\nfor (i = 0; i < desc->hw.nr_subgroups; i++)\r\nintc_subgroup_init_one(desc, d, desc->hw.subgroups + i);\r\n}\r\nstatic void __init intc_subgroup_map(struct intc_desc_int *d)\r\n{\r\nstruct intc_subgroup_entry *entries[32];\r\nunsigned long flags;\r\nunsigned int nr_found;\r\nint i;\r\nraw_spin_lock_irqsave(&d->lock, flags);\r\nrestart:\r\nnr_found = radix_tree_gang_lookup_tag_slot(&d->tree,\r\n(void ***)entries, 0, ARRAY_SIZE(entries),\r\nINTC_TAG_VIRQ_NEEDS_ALLOC);\r\nfor (i = 0; i < nr_found; i++) {\r\nstruct intc_subgroup_entry *entry;\r\nint irq;\r\nentry = radix_tree_deref_slot((void **)entries[i]);\r\nif (unlikely(!entry))\r\ncontinue;\r\nif (radix_tree_deref_retry(entry))\r\ngoto restart;\r\nirq = irq_alloc_desc(numa_node_id());\r\nif (unlikely(irq < 0)) {\r\npr_err("no more free IRQs, bailing..\n");\r\nbreak;\r\n}\r\nactivate_irq(irq);\r\npr_info("Setting up a chained VIRQ from %d -> %d\n",\r\nirq, entry->pirq);\r\nintc_irq_xlate_set(irq, entry->enum_id, d);\r\nirq_set_chip_and_handler_name(irq, irq_get_chip(entry->pirq),\r\nhandle_simple_irq, "virq");\r\nirq_set_chip_data(irq, irq_get_chip_data(entry->pirq));\r\nirq_set_handler_data(irq, (void *)entry->handle);\r\nirq_set_nothread(irq);\r\nirq_set_chained_handler(entry->pirq, intc_virq_handler);\r\nadd_virq_to_pirq(entry->pirq, irq);\r\nradix_tree_tag_clear(&d->tree, entry->enum_id,\r\nINTC_TAG_VIRQ_NEEDS_ALLOC);\r\nradix_tree_replace_slot((void **)entries[i],\r\n&intc_irq_xlate[irq]);\r\n}\r\nraw_spin_unlock_irqrestore(&d->lock, flags);\r\n}\r\nvoid __init intc_finalize(void)\r\n{\r\nstruct intc_desc_int *d;\r\nlist_for_each_entry(d, &intc_list, list)\r\nif (radix_tree_tagged(&d->tree, INTC_TAG_VIRQ_NEEDS_ALLOC))\r\nintc_subgroup_map(d);\r\n}
