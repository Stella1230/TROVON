static unsigned usb_stream_next_packet_size(struct usb_stream_kernel *sk)\r\n{\r\nstruct usb_stream *s = sk->s;\r\nsk->out_phase_peeked = (sk->out_phase & 0xffff) + sk->freqn;\r\nreturn (sk->out_phase_peeked >> 16) * s->cfg.frame_size;\r\n}\r\nstatic void playback_prep_freqn(struct usb_stream_kernel *sk, struct urb *urb)\r\n{\r\nstruct usb_stream *s = sk->s;\r\nint pack, lb = 0;\r\nfor (pack = 0; pack < sk->n_o_ps; pack++) {\r\nint l = usb_stream_next_packet_size(sk);\r\nif (s->idle_outsize + lb + l > s->period_size)\r\ngoto check;\r\nsk->out_phase = sk->out_phase_peeked;\r\nurb->iso_frame_desc[pack].offset = lb;\r\nurb->iso_frame_desc[pack].length = l;\r\nlb += l;\r\n}\r\nsnd_printdd(KERN_DEBUG "%i\n", lb);\r\ncheck:\r\nurb->number_of_packets = pack;\r\nurb->transfer_buffer_length = lb;\r\ns->idle_outsize += lb - s->period_size;\r\nsnd_printdd(KERN_DEBUG "idle=%i ul=%i ps=%i\n", s->idle_outsize,\r\nlb, s->period_size);\r\n}\r\nstatic void init_pipe_urbs(struct usb_stream_kernel *sk, unsigned use_packsize,\r\nstruct urb **urbs, char *transfer,\r\nstruct usb_device *dev, int pipe)\r\n{\r\nint u, p;\r\nint maxpacket = use_packsize ?\r\nuse_packsize : usb_maxpacket(dev, pipe, usb_pipeout(pipe));\r\nint transfer_length = maxpacket * sk->n_o_ps;\r\nfor (u = 0; u < USB_STREAM_NURBS;\r\n++u, transfer += transfer_length) {\r\nstruct urb *urb = urbs[u];\r\nstruct usb_iso_packet_descriptor *desc;\r\nurb->transfer_buffer = transfer;\r\nurb->dev = dev;\r\nurb->pipe = pipe;\r\nurb->number_of_packets = sk->n_o_ps;\r\nurb->context = sk;\r\nurb->interval = 1;\r\nif (usb_pipeout(pipe))\r\ncontinue;\r\nurb->transfer_buffer_length = transfer_length;\r\ndesc = urb->iso_frame_desc;\r\ndesc->offset = 0;\r\ndesc->length = maxpacket;\r\nfor (p = 1; p < sk->n_o_ps; ++p) {\r\ndesc[p].offset = desc[p - 1].offset + maxpacket;\r\ndesc[p].length = maxpacket;\r\n}\r\n}\r\n}\r\nstatic void init_urbs(struct usb_stream_kernel *sk, unsigned use_packsize,\r\nstruct usb_device *dev, int in_pipe, int out_pipe)\r\n{\r\nstruct usb_stream *s = sk->s;\r\nchar *indata = (char *)s + sizeof(*s) +\r\nsizeof(struct usb_stream_packet) *\r\ns->inpackets;\r\nint u;\r\nfor (u = 0; u < USB_STREAM_NURBS; ++u) {\r\nsk->inurb[u] = usb_alloc_urb(sk->n_o_ps, GFP_KERNEL);\r\nsk->outurb[u] = usb_alloc_urb(sk->n_o_ps, GFP_KERNEL);\r\n}\r\ninit_pipe_urbs(sk, use_packsize, sk->inurb, indata, dev, in_pipe);\r\ninit_pipe_urbs(sk, use_packsize, sk->outurb, sk->write_page, dev,\r\nout_pipe);\r\n}\r\nstatic inline unsigned get_usb_full_speed_rate(unsigned rate)\r\n{\r\nreturn ((rate << 13) + 62) / 125;\r\n}\r\nstatic inline unsigned get_usb_high_speed_rate(unsigned rate)\r\n{\r\nreturn ((rate << 10) + 62) / 125;\r\n}\r\nvoid usb_stream_free(struct usb_stream_kernel *sk)\r\n{\r\nstruct usb_stream *s;\r\nunsigned u;\r\nfor (u = 0; u < USB_STREAM_NURBS; ++u) {\r\nusb_free_urb(sk->inurb[u]);\r\nsk->inurb[u] = NULL;\r\nusb_free_urb(sk->outurb[u]);\r\nsk->outurb[u] = NULL;\r\n}\r\ns = sk->s;\r\nif (!s)\r\nreturn;\r\nfree_pages((unsigned long)sk->write_page, get_order(s->write_size));\r\nsk->write_page = NULL;\r\nfree_pages((unsigned long)s, get_order(s->read_size));\r\nsk->s = NULL;\r\n}\r\nstruct usb_stream *usb_stream_new(struct usb_stream_kernel *sk,\r\nstruct usb_device *dev,\r\nunsigned in_endpoint, unsigned out_endpoint,\r\nunsigned sample_rate, unsigned use_packsize,\r\nunsigned period_frames, unsigned frame_size)\r\n{\r\nint packets, max_packsize;\r\nint in_pipe, out_pipe;\r\nint read_size = sizeof(struct usb_stream);\r\nint write_size;\r\nint usb_frames = dev->speed == USB_SPEED_HIGH ? 8000 : 1000;\r\nint pg;\r\nin_pipe = usb_rcvisocpipe(dev, in_endpoint);\r\nout_pipe = usb_sndisocpipe(dev, out_endpoint);\r\nmax_packsize = use_packsize ?\r\nuse_packsize : usb_maxpacket(dev, in_pipe, 0);\r\npackets = period_frames * usb_frames / sample_rate + 1;\r\nif (dev->speed == USB_SPEED_HIGH)\r\npackets = (packets + 7) & ~7;\r\nread_size += packets * USB_STREAM_URBDEPTH *\r\n(max_packsize + sizeof(struct usb_stream_packet));\r\nmax_packsize = usb_maxpacket(dev, out_pipe, 1);\r\nwrite_size = max_packsize * packets * USB_STREAM_URBDEPTH;\r\nif (read_size >= 256*PAGE_SIZE || write_size >= 256*PAGE_SIZE) {\r\nsnd_printk(KERN_WARNING "a size exceeds 128*PAGE_SIZE\n");\r\ngoto out;\r\n}\r\npg = get_order(read_size);\r\nsk->s = (void *) __get_free_pages(GFP_KERNEL|__GFP_COMP|__GFP_ZERO, pg);\r\nif (!sk->s) {\r\nsnd_printk(KERN_WARNING "couldn't __get_free_pages()\n");\r\ngoto out;\r\n}\r\nsk->s->cfg.version = USB_STREAM_INTERFACE_VERSION;\r\nsk->s->read_size = read_size;\r\nsk->s->cfg.sample_rate = sample_rate;\r\nsk->s->cfg.frame_size = frame_size;\r\nsk->n_o_ps = packets;\r\nsk->s->inpackets = packets * USB_STREAM_URBDEPTH;\r\nsk->s->cfg.period_frames = period_frames;\r\nsk->s->period_size = frame_size * period_frames;\r\nsk->s->write_size = write_size;\r\npg = get_order(write_size);\r\nsk->write_page =\r\n(void *)__get_free_pages(GFP_KERNEL|__GFP_COMP|__GFP_ZERO, pg);\r\nif (!sk->write_page) {\r\nsnd_printk(KERN_WARNING "couldn't __get_free_pages()\n");\r\nusb_stream_free(sk);\r\nreturn NULL;\r\n}\r\nif (dev->speed == USB_SPEED_FULL)\r\nsk->freqn = get_usb_full_speed_rate(sample_rate);\r\nelse\r\nsk->freqn = get_usb_high_speed_rate(sample_rate);\r\ninit_urbs(sk, use_packsize, dev, in_pipe, out_pipe);\r\nsk->s->state = usb_stream_stopped;\r\nout:\r\nreturn sk->s;\r\n}\r\nstatic bool balance_check(struct usb_stream_kernel *sk, struct urb *urb)\r\n{\r\nbool r;\r\nif (unlikely(urb->status)) {\r\nif (urb->status != -ESHUTDOWN && urb->status != -ENOENT)\r\nsnd_printk(KERN_WARNING "status=%i\n", urb->status);\r\nsk->iso_frame_balance = 0x7FFFFFFF;\r\nreturn false;\r\n}\r\nr = sk->iso_frame_balance == 0;\r\nif (!r)\r\nsk->i_urb = urb;\r\nreturn r;\r\n}\r\nstatic bool balance_playback(struct usb_stream_kernel *sk, struct urb *urb)\r\n{\r\nsk->iso_frame_balance += urb->number_of_packets;\r\nreturn balance_check(sk, urb);\r\n}\r\nstatic bool balance_capture(struct usb_stream_kernel *sk, struct urb *urb)\r\n{\r\nsk->iso_frame_balance -= urb->number_of_packets;\r\nreturn balance_check(sk, urb);\r\n}\r\nstatic void subs_set_complete(struct urb **urbs, void (*complete)(struct urb *))\r\n{\r\nint u;\r\nfor (u = 0; u < USB_STREAM_NURBS; u++) {\r\nstruct urb *urb = urbs[u];\r\nurb->complete = complete;\r\n}\r\n}\r\nstatic int usb_stream_prepare_playback(struct usb_stream_kernel *sk,\r\nstruct urb *inurb)\r\n{\r\nstruct usb_stream *s = sk->s;\r\nstruct urb *io;\r\nstruct usb_iso_packet_descriptor *id, *od;\r\nint p = 0, lb = 0, l = 0;\r\nio = sk->idle_outurb;\r\nod = io->iso_frame_desc;\r\nfor (; s->sync_packet < 0; ++p, ++s->sync_packet) {\r\nstruct urb *ii = sk->completed_inurb;\r\nid = ii->iso_frame_desc +\r\nii->number_of_packets + s->sync_packet;\r\nl = id->actual_length;\r\nod[p].length = l;\r\nod[p].offset = lb;\r\nlb += l;\r\n}\r\nfor (;\r\ns->sync_packet < inurb->number_of_packets && p < sk->n_o_ps;\r\n++p, ++s->sync_packet) {\r\nl = inurb->iso_frame_desc[s->sync_packet].actual_length;\r\nif (s->idle_outsize + lb + l > s->period_size)\r\ngoto check_ok;\r\nod[p].length = l;\r\nod[p].offset = lb;\r\nlb += l;\r\n}\r\ncheck_ok:\r\ns->sync_packet -= inurb->number_of_packets;\r\nif (unlikely(s->sync_packet < -2 || s->sync_packet > 0)) {\r\nsnd_printk(KERN_WARNING "invalid sync_packet = %i;"\r\n" p=%i nop=%i %i %x %x %x > %x\n",\r\ns->sync_packet, p, inurb->number_of_packets,\r\ns->idle_outsize + lb + l,\r\ns->idle_outsize, lb, l,\r\ns->period_size);\r\nreturn -1;\r\n}\r\nif (unlikely(lb % s->cfg.frame_size)) {\r\nsnd_printk(KERN_WARNING"invalid outsize = %i\n",\r\nlb);\r\nreturn -1;\r\n}\r\ns->idle_outsize += lb - s->period_size;\r\nio->number_of_packets = p;\r\nio->transfer_buffer_length = lb;\r\nif (s->idle_outsize <= 0)\r\nreturn 0;\r\nsnd_printk(KERN_WARNING "idle=%i\n", s->idle_outsize);\r\nreturn -1;\r\n}\r\nstatic void prepare_inurb(int number_of_packets, struct urb *iu)\r\n{\r\nstruct usb_iso_packet_descriptor *id;\r\nint p;\r\niu->number_of_packets = number_of_packets;\r\nid = iu->iso_frame_desc;\r\nid->offset = 0;\r\nfor (p = 0; p < iu->number_of_packets - 1; ++p)\r\nid[p + 1].offset = id[p].offset + id[p].length;\r\niu->transfer_buffer_length =\r\nid[0].length * iu->number_of_packets;\r\n}\r\nstatic int submit_urbs(struct usb_stream_kernel *sk,\r\nstruct urb *inurb, struct urb *outurb)\r\n{\r\nint err;\r\nprepare_inurb(sk->idle_outurb->number_of_packets, sk->idle_inurb);\r\nerr = usb_submit_urb(sk->idle_inurb, GFP_ATOMIC);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "%i\n", err);\r\nreturn err;\r\n}\r\nsk->idle_inurb = sk->completed_inurb;\r\nsk->completed_inurb = inurb;\r\nerr = usb_submit_urb(sk->idle_outurb, GFP_ATOMIC);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "%i\n", err);\r\nreturn err;\r\n}\r\nsk->idle_outurb = sk->completed_outurb;\r\nsk->completed_outurb = outurb;\r\nreturn 0;\r\n}\r\nstatic void loop_back(struct usb_stream *s)\r\n{\r\nchar *i, *o;\r\nint il, ol, l, p;\r\nstruct urb *iu;\r\nstruct usb_iso_packet_descriptor *id;\r\no = s->playback1st_to;\r\nol = s->playback1st_size;\r\nl = 0;\r\nif (s->insplit_pack >= 0) {\r\niu = sk->idle_inurb;\r\nid = iu->iso_frame_desc;\r\np = s->insplit_pack;\r\n} else\r\ngoto second;\r\nloop:\r\nfor (; p < iu->number_of_packets && l < s->period_size; ++p) {\r\ni = iu->transfer_buffer + id[p].offset;\r\nil = id[p].actual_length;\r\nif (l + il > s->period_size)\r\nil = s->period_size - l;\r\nif (il <= ol) {\r\nmemcpy(o, i, il);\r\no += il;\r\nol -= il;\r\n} else {\r\nmemcpy(o, i, ol);\r\nsingen_6pack(o, ol);\r\no = s->playback_to;\r\nmemcpy(o, i + ol, il - ol);\r\no += il - ol;\r\nol = s->period_size - s->playback1st_size;\r\n}\r\nl += il;\r\n}\r\nif (iu == sk->completed_inurb) {\r\nif (l != s->period_size)\r\nprintk(KERN_DEBUG"%s:%i %i\n", __func__, __LINE__,\r\nl/(int)s->cfg.frame_size);\r\nreturn;\r\n}\r\nsecond:\r\niu = sk->completed_inurb;\r\nid = iu->iso_frame_desc;\r\np = 0;\r\ngoto loop;\r\n}\r\nstatic void loop_back(struct usb_stream *s)\r\n{\r\n}\r\nstatic void stream_idle(struct usb_stream_kernel *sk,\r\nstruct urb *inurb, struct urb *outurb)\r\n{\r\nstruct usb_stream *s = sk->s;\r\nint l, p;\r\nint insize = s->idle_insize;\r\nint urb_size = 0;\r\ns->inpacket_split = s->next_inpacket_split;\r\ns->inpacket_split_at = s->next_inpacket_split_at;\r\ns->next_inpacket_split = -1;\r\ns->next_inpacket_split_at = 0;\r\nfor (p = 0; p < inurb->number_of_packets; ++p) {\r\nstruct usb_iso_packet_descriptor *id = inurb->iso_frame_desc;\r\nl = id[p].actual_length;\r\nif (unlikely(l == 0 || id[p].status)) {\r\nsnd_printk(KERN_WARNING "underrun, status=%u\n",\r\nid[p].status);\r\ngoto err_out;\r\n}\r\ns->inpacket_head++;\r\ns->inpacket_head %= s->inpackets;\r\nif (s->inpacket_split == -1)\r\ns->inpacket_split = s->inpacket_head;\r\ns->inpacket[s->inpacket_head].offset =\r\nid[p].offset + (inurb->transfer_buffer - (void *)s);\r\ns->inpacket[s->inpacket_head].length = l;\r\nif (insize + l > s->period_size &&\r\ns->next_inpacket_split == -1) {\r\ns->next_inpacket_split = s->inpacket_head;\r\ns->next_inpacket_split_at = s->period_size - insize;\r\n}\r\ninsize += l;\r\nurb_size += l;\r\n}\r\ns->idle_insize += urb_size - s->period_size;\r\nif (s->idle_insize < 0) {\r\nsnd_printk(KERN_WARNING "%i\n",\r\n(s->idle_insize)/(int)s->cfg.frame_size);\r\ngoto err_out;\r\n}\r\ns->insize_done += urb_size;\r\nl = s->idle_outsize;\r\ns->outpacket[0].offset = (sk->idle_outurb->transfer_buffer -\r\nsk->write_page) - l;\r\nif (usb_stream_prepare_playback(sk, inurb) < 0)\r\ngoto err_out;\r\ns->outpacket[0].length = sk->idle_outurb->transfer_buffer_length + l;\r\ns->outpacket[1].offset = sk->completed_outurb->transfer_buffer -\r\nsk->write_page;\r\nif (submit_urbs(sk, inurb, outurb) < 0)\r\ngoto err_out;\r\nloop_back(s);\r\ns->periods_done++;\r\nwake_up_all(&sk->sleep);\r\nreturn;\r\nerr_out:\r\ns->state = usb_stream_xrun;\r\nwake_up_all(&sk->sleep);\r\n}\r\nstatic void i_capture_idle(struct urb *urb)\r\n{\r\nstruct usb_stream_kernel *sk = urb->context;\r\nif (balance_capture(sk, urb))\r\nstream_idle(sk, urb, sk->i_urb);\r\n}\r\nstatic void i_playback_idle(struct urb *urb)\r\n{\r\nstruct usb_stream_kernel *sk = urb->context;\r\nif (balance_playback(sk, urb))\r\nstream_idle(sk, sk->i_urb, urb);\r\n}\r\nstatic void stream_start(struct usb_stream_kernel *sk,\r\nstruct urb *inurb, struct urb *outurb)\r\n{\r\nstruct usb_stream *s = sk->s;\r\nif (s->state >= usb_stream_sync1) {\r\nint l, p, max_diff, max_diff_0;\r\nint urb_size = 0;\r\nunsigned frames_per_packet, min_frames = 0;\r\nframes_per_packet = (s->period_size - s->idle_insize);\r\nframes_per_packet <<= 8;\r\nframes_per_packet /=\r\ns->cfg.frame_size * inurb->number_of_packets;\r\nframes_per_packet++;\r\nmax_diff_0 = s->cfg.frame_size;\r\nif (s->cfg.period_frames >= 256)\r\nmax_diff_0 <<= 1;\r\nif (s->cfg.period_frames >= 1024)\r\nmax_diff_0 <<= 1;\r\nmax_diff = max_diff_0;\r\nfor (p = 0; p < inurb->number_of_packets; ++p) {\r\nint diff;\r\nl = inurb->iso_frame_desc[p].actual_length;\r\nurb_size += l;\r\nmin_frames += frames_per_packet;\r\ndiff = urb_size -\r\n(min_frames >> 8) * s->cfg.frame_size;\r\nif (diff < max_diff) {\r\nsnd_printdd(KERN_DEBUG "%i %i %i %i\n",\r\ns->insize_done,\r\nurb_size / (int)s->cfg.frame_size,\r\ninurb->number_of_packets, diff);\r\nmax_diff = diff;\r\n}\r\n}\r\ns->idle_insize -= max_diff - max_diff_0;\r\ns->idle_insize += urb_size - s->period_size;\r\nif (s->idle_insize < 0) {\r\nsnd_printk(KERN_WARNING "%i %i %i\n",\r\ns->idle_insize, urb_size, s->period_size);\r\nreturn;\r\n} else if (s->idle_insize == 0) {\r\ns->next_inpacket_split =\r\n(s->inpacket_head + 1) % s->inpackets;\r\ns->next_inpacket_split_at = 0;\r\n} else {\r\nunsigned split = s->inpacket_head;\r\nl = s->idle_insize;\r\nwhile (l > s->inpacket[split].length) {\r\nl -= s->inpacket[split].length;\r\nif (split == 0)\r\nsplit = s->inpackets - 1;\r\nelse\r\nsplit--;\r\n}\r\ns->next_inpacket_split = split;\r\ns->next_inpacket_split_at =\r\ns->inpacket[split].length - l;\r\n}\r\ns->insize_done += urb_size;\r\nif (usb_stream_prepare_playback(sk, inurb) < 0)\r\nreturn;\r\n} else\r\nplayback_prep_freqn(sk, sk->idle_outurb);\r\nif (submit_urbs(sk, inurb, outurb) < 0)\r\nreturn;\r\nif (s->state == usb_stream_sync1 && s->insize_done > 360000) {\r\ns->state = usb_stream_ready;\r\nsubs_set_complete(sk->inurb, i_capture_idle);\r\nsubs_set_complete(sk->outurb, i_playback_idle);\r\n}\r\n}\r\nstatic void i_capture_start(struct urb *urb)\r\n{\r\nstruct usb_iso_packet_descriptor *id = urb->iso_frame_desc;\r\nstruct usb_stream_kernel *sk = urb->context;\r\nstruct usb_stream *s = sk->s;\r\nint p;\r\nint empty = 0;\r\nif (urb->status) {\r\nsnd_printk(KERN_WARNING "status=%i\n", urb->status);\r\nreturn;\r\n}\r\nfor (p = 0; p < urb->number_of_packets; ++p) {\r\nint l = id[p].actual_length;\r\nif (l < s->cfg.frame_size) {\r\n++empty;\r\nif (s->state >= usb_stream_sync0) {\r\nsnd_printk(KERN_WARNING "%i\n", l);\r\nreturn;\r\n}\r\n}\r\ns->inpacket_head++;\r\ns->inpacket_head %= s->inpackets;\r\ns->inpacket[s->inpacket_head].offset =\r\nid[p].offset + (urb->transfer_buffer - (void *)s);\r\ns->inpacket[s->inpacket_head].length = l;\r\n}\r\n#ifdef SHOW_EMPTY\r\nif (empty) {\r\nprintk(KERN_DEBUG"%s:%i: %i", __func__, __LINE__,\r\nurb->iso_frame_desc[0].actual_length);\r\nfor (pack = 1; pack < urb->number_of_packets; ++pack) {\r\nint l = urb->iso_frame_desc[pack].actual_length;\r\nprintk(" %i", l);\r\n}\r\nprintk("\n");\r\n}\r\n#endif\r\nif (!empty && s->state < usb_stream_sync1)\r\n++s->state;\r\nif (balance_capture(sk, urb))\r\nstream_start(sk, urb, sk->i_urb);\r\n}\r\nstatic void i_playback_start(struct urb *urb)\r\n{\r\nstruct usb_stream_kernel *sk = urb->context;\r\nif (balance_playback(sk, urb))\r\nstream_start(sk, sk->i_urb, urb);\r\n}\r\nint usb_stream_start(struct usb_stream_kernel *sk)\r\n{\r\nstruct usb_stream *s = sk->s;\r\nint frame = 0, iters = 0;\r\nint u, err;\r\nint try = 0;\r\nif (s->state != usb_stream_stopped)\r\nreturn -EAGAIN;\r\nsubs_set_complete(sk->inurb, i_capture_start);\r\nsubs_set_complete(sk->outurb, i_playback_start);\r\nmemset(sk->write_page, 0, s->write_size);\r\ndotry:\r\ns->insize_done = 0;\r\ns->idle_insize = 0;\r\ns->idle_outsize = 0;\r\ns->sync_packet = -1;\r\ns->inpacket_head = -1;\r\nsk->iso_frame_balance = 0;\r\n++try;\r\nfor (u = 0; u < 2; u++) {\r\nstruct urb *inurb = sk->inurb[u];\r\nstruct urb *outurb = sk->outurb[u];\r\nplayback_prep_freqn(sk, outurb);\r\ninurb->number_of_packets = outurb->number_of_packets;\r\ninurb->transfer_buffer_length =\r\ninurb->number_of_packets *\r\ninurb->iso_frame_desc[0].length;\r\nif (u == 0) {\r\nint now;\r\nstruct usb_device *dev = inurb->dev;\r\nframe = usb_get_current_frame_number(dev);\r\ndo {\r\nnow = usb_get_current_frame_number(dev);\r\n++iters;\r\n} while (now > -1 && now == frame);\r\n}\r\nerr = usb_submit_urb(inurb, GFP_ATOMIC);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR"usb_submit_urb(sk->inurb[%i])"\r\n" returned %i\n", u, err);\r\nreturn err;\r\n}\r\nerr = usb_submit_urb(outurb, GFP_ATOMIC);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR"usb_submit_urb(sk->outurb[%i])"\r\n" returned %i\n", u, err);\r\nreturn err;\r\n}\r\nif (inurb->start_frame != outurb->start_frame) {\r\nsnd_printd(KERN_DEBUG\r\n"u[%i] start_frames differ in:%u out:%u\n",\r\nu, inurb->start_frame, outurb->start_frame);\r\ngoto check_retry;\r\n}\r\n}\r\nsnd_printdd(KERN_DEBUG "%i %i\n", frame, iters);\r\ntry = 0;\r\ncheck_retry:\r\nif (try) {\r\nusb_stream_stop(sk);\r\nif (try < 5) {\r\nmsleep(1500);\r\nsnd_printd(KERN_DEBUG "goto dotry;\n");\r\ngoto dotry;\r\n}\r\nsnd_printk(KERN_WARNING"couldn't start"\r\n" all urbs on the same start_frame.\n");\r\nreturn -EFAULT;\r\n}\r\nsk->idle_inurb = sk->inurb[USB_STREAM_NURBS - 2];\r\nsk->idle_outurb = sk->outurb[USB_STREAM_NURBS - 2];\r\nsk->completed_inurb = sk->inurb[USB_STREAM_NURBS - 1];\r\nsk->completed_outurb = sk->outurb[USB_STREAM_NURBS - 1];\r\n{\r\nint wait_ms = 3000;\r\nwhile (s->state != usb_stream_ready && wait_ms > 0) {\r\nsnd_printdd(KERN_DEBUG "%i\n", s->state);\r\nmsleep(200);\r\nwait_ms -= 200;\r\n}\r\n}\r\nreturn s->state == usb_stream_ready ? 0 : -EFAULT;\r\n}\r\nvoid usb_stream_stop(struct usb_stream_kernel *sk)\r\n{\r\nint u;\r\nif (!sk->s)\r\nreturn;\r\nfor (u = 0; u < USB_STREAM_NURBS; ++u) {\r\nusb_kill_urb(sk->inurb[u]);\r\nusb_kill_urb(sk->outurb[u]);\r\n}\r\nsk->s->state = usb_stream_stopped;\r\nmsleep(400);\r\n}
