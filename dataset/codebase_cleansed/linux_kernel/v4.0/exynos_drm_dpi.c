static inline struct exynos_dpi *display_to_dpi(struct exynos_drm_display *d)\r\n{\r\nreturn container_of(d, struct exynos_dpi, display);\r\n}\r\nstatic enum drm_connector_status\r\nexynos_dpi_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct exynos_dpi *ctx = connector_to_dpi(connector);\r\nif (ctx->panel && !ctx->panel->connector)\r\ndrm_panel_attach(ctx->panel, &ctx->connector);\r\nreturn connector_status_connected;\r\n}\r\nstatic void exynos_dpi_connector_destroy(struct drm_connector *connector)\r\n{\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\n}\r\nstatic int exynos_dpi_get_modes(struct drm_connector *connector)\r\n{\r\nstruct exynos_dpi *ctx = connector_to_dpi(connector);\r\nif (ctx->vm) {\r\nstruct drm_display_mode *mode;\r\nmode = drm_mode_create(connector->dev);\r\nif (!mode) {\r\nDRM_ERROR("failed to create a new display mode\n");\r\nreturn 0;\r\n}\r\ndrm_display_mode_from_videomode(ctx->vm, mode);\r\nmode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_probed_add(connector, mode);\r\nreturn 1;\r\n}\r\nif (ctx->panel)\r\nreturn ctx->panel->funcs->get_modes(ctx->panel);\r\nreturn 0;\r\n}\r\nstatic struct drm_encoder *\r\nexynos_dpi_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct exynos_dpi *ctx = connector_to_dpi(connector);\r\nreturn ctx->encoder;\r\n}\r\nstatic int exynos_dpi_create_connector(struct exynos_drm_display *display,\r\nstruct drm_encoder *encoder)\r\n{\r\nstruct exynos_dpi *ctx = display_to_dpi(display);\r\nstruct drm_connector *connector = &ctx->connector;\r\nint ret;\r\nctx->encoder = encoder;\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nret = drm_connector_init(encoder->dev, connector,\r\n&exynos_dpi_connector_funcs,\r\nDRM_MODE_CONNECTOR_VGA);\r\nif (ret) {\r\nDRM_ERROR("failed to initialize connector with drm\n");\r\nreturn ret;\r\n}\r\ndrm_connector_helper_add(connector, &exynos_dpi_connector_helper_funcs);\r\ndrm_connector_register(connector);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nreturn 0;\r\n}\r\nstatic void exynos_dpi_poweron(struct exynos_dpi *ctx)\r\n{\r\nif (ctx->panel) {\r\ndrm_panel_prepare(ctx->panel);\r\ndrm_panel_enable(ctx->panel);\r\n}\r\n}\r\nstatic void exynos_dpi_poweroff(struct exynos_dpi *ctx)\r\n{\r\nif (ctx->panel) {\r\ndrm_panel_disable(ctx->panel);\r\ndrm_panel_unprepare(ctx->panel);\r\n}\r\n}\r\nstatic void exynos_dpi_dpms(struct exynos_drm_display *display, int mode)\r\n{\r\nstruct exynos_dpi *ctx = display_to_dpi(display);\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nif (ctx->dpms_mode != DRM_MODE_DPMS_ON)\r\nexynos_dpi_poweron(ctx);\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ncase DRM_MODE_DPMS_OFF:\r\nif (ctx->dpms_mode == DRM_MODE_DPMS_ON)\r\nexynos_dpi_poweroff(ctx);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nctx->dpms_mode = mode;\r\n}\r\nstatic struct device_node *\r\nof_get_child_by_name_reg(struct device_node *parent, const char *name, u32 reg)\r\n{\r\nstruct device_node *np;\r\nfor_each_child_of_node(parent, np) {\r\nu32 r;\r\nif (!np->name || of_node_cmp(np->name, name))\r\ncontinue;\r\nif (of_property_read_u32(np, "reg", &r) < 0)\r\nr = 0;\r\nif (reg == r)\r\nbreak;\r\n}\r\nreturn np;\r\n}\r\nstatic struct device_node *of_graph_get_port_by_reg(struct device_node *parent,\r\nu32 reg)\r\n{\r\nstruct device_node *ports, *port;\r\nports = of_get_child_by_name(parent, "ports");\r\nif (ports)\r\nparent = ports;\r\nport = of_get_child_by_name_reg(parent, "port", reg);\r\nof_node_put(ports);\r\nreturn port;\r\n}\r\nstatic struct device_node *\r\nof_graph_get_endpoint_by_reg(struct device_node *port, u32 reg)\r\n{\r\nreturn of_get_child_by_name_reg(port, "endpoint", reg);\r\n}\r\nstatic struct device_node *\r\nof_graph_get_remote_port_parent(const struct device_node *node)\r\n{\r\nstruct device_node *np;\r\nunsigned int depth;\r\nnp = of_parse_phandle(node, "remote-endpoint", 0);\r\nfor (depth = 3; depth && np; depth--) {\r\nnp = of_get_next_parent(np);\r\nif (depth == 2 && of_node_cmp(np->name, "ports"))\r\nbreak;\r\n}\r\nreturn np;\r\n}\r\nstatic struct device_node *exynos_dpi_of_find_panel_node(struct device *dev)\r\n{\r\nstruct device_node *np, *ep;\r\nnp = of_graph_get_port_by_reg(dev->of_node, FIMD_PORT_RGB);\r\nif (!np)\r\nreturn NULL;\r\nep = of_graph_get_endpoint_by_reg(np, 0);\r\nof_node_put(np);\r\nif (!ep)\r\nreturn NULL;\r\nnp = of_graph_get_remote_port_parent(ep);\r\nof_node_put(ep);\r\nreturn np;\r\n}\r\nstatic int exynos_dpi_parse_dt(struct exynos_dpi *ctx)\r\n{\r\nstruct device *dev = ctx->dev;\r\nstruct device_node *dn = dev->of_node;\r\nstruct device_node *np;\r\nctx->panel_node = exynos_dpi_of_find_panel_node(dev);\r\nnp = of_get_child_by_name(dn, "display-timings");\r\nif (np) {\r\nstruct videomode *vm;\r\nint ret;\r\nof_node_put(np);\r\nvm = devm_kzalloc(dev, sizeof(*ctx->vm), GFP_KERNEL);\r\nif (!vm)\r\nreturn -ENOMEM;\r\nret = of_get_videomode(dn, vm, 0);\r\nif (ret < 0) {\r\ndevm_kfree(dev, vm);\r\nreturn ret;\r\n}\r\nctx->vm = vm;\r\nreturn 0;\r\n}\r\nif (!ctx->panel_node)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstruct exynos_drm_display *exynos_dpi_probe(struct device *dev)\r\n{\r\nstruct exynos_dpi *ctx;\r\nint ret;\r\nctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn ERR_PTR(-ENOMEM);\r\nctx->display.type = EXYNOS_DISPLAY_TYPE_LCD;\r\nctx->display.ops = &exynos_dpi_display_ops;\r\nctx->dev = dev;\r\nctx->dpms_mode = DRM_MODE_DPMS_OFF;\r\nret = exynos_drm_component_add(dev,\r\nEXYNOS_DEVICE_TYPE_CONNECTOR,\r\nctx->display.type);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nret = exynos_dpi_parse_dt(ctx);\r\nif (ret < 0) {\r\ndevm_kfree(dev, ctx);\r\ngoto err_del_component;\r\n}\r\nif (ctx->panel_node) {\r\nctx->panel = of_drm_find_panel(ctx->panel_node);\r\nif (!ctx->panel) {\r\nexynos_drm_component_del(dev,\r\nEXYNOS_DEVICE_TYPE_CONNECTOR);\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\n}\r\n}\r\nreturn &ctx->display;\r\nerr_del_component:\r\nexynos_drm_component_del(dev, EXYNOS_DEVICE_TYPE_CONNECTOR);\r\nreturn NULL;\r\n}\r\nint exynos_dpi_remove(struct exynos_drm_display *display)\r\n{\r\nstruct exynos_dpi *ctx = display_to_dpi(display);\r\nexynos_dpi_dpms(&ctx->display, DRM_MODE_DPMS_OFF);\r\nif (ctx->panel)\r\ndrm_panel_detach(ctx->panel);\r\nexynos_drm_component_del(ctx->dev, EXYNOS_DEVICE_TYPE_CONNECTOR);\r\nreturn 0;\r\n}
