static inline void __init mxc_init_imx_uart(void)\r\n{\r\nmxc_iomux_setup_multiple_pins(uart_pins, ARRAY_SIZE(uart_pins),\r\n"uart-0");\r\nimx31_add_imx_uart0(&uart_pdata);\r\n}\r\nstatic int __init qong_init_dnet(void)\r\n{\r\nint ret;\r\ndnet_resources[1].start =\r\ngpio_to_irq(IOMUX_TO_GPIO(MX31_PIN_DTR_DCE1));\r\ndnet_resources[1].end =\r\ngpio_to_irq(IOMUX_TO_GPIO(MX31_PIN_DTR_DCE1));\r\nret = platform_device_register(&dnet_device);\r\nreturn ret;\r\n}\r\nstatic void qong_init_nor_mtd(void)\r\n{\r\n(void)platform_device_register(&qong_nor_mtd_device);\r\n}\r\nstatic void qong_nand_cmd_ctrl(struct mtd_info *mtd, int cmd, unsigned int ctrl)\r\n{\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nif (ctrl & NAND_CLE)\r\nwriteb(cmd, nand_chip->IO_ADDR_W + (1 << 24));\r\nelse\r\nwriteb(cmd, nand_chip->IO_ADDR_W + (1 << 23));\r\n}\r\nstatic int qong_nand_device_ready(struct mtd_info *mtd)\r\n{\r\nreturn gpio_get_value(IOMUX_TO_GPIO(MX31_PIN_NFRB));\r\n}\r\nstatic void qong_nand_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\nif (chip >= 0)\r\ngpio_set_value(IOMUX_TO_GPIO(MX31_PIN_NFCE_B), 0);\r\nelse\r\ngpio_set_value(IOMUX_TO_GPIO(MX31_PIN_NFCE_B), 1);\r\n}\r\nstatic void __init qong_init_nand_mtd(void)\r\n{\r\n__raw_writel(0x00004f00, MX31_IO_ADDRESS(MX31_WEIM_CSCRxU(3)));\r\n__raw_writel(0x20013b31, MX31_IO_ADDRESS(MX31_WEIM_CSCRxL(3)));\r\n__raw_writel(0x00020800, MX31_IO_ADDRESS(MX31_WEIM_CSCRxA(3)));\r\nmxc_iomux_set_gpr(MUX_SDCTL_CSD1_SEL, true);\r\nmxc_iomux_mode(IOMUX_MODE(MX31_PIN_NFCE_B, IOMUX_CONFIG_GPIO));\r\nif (!gpio_request(IOMUX_TO_GPIO(MX31_PIN_NFCE_B), "nand_enable"))\r\ngpio_direction_output(IOMUX_TO_GPIO(MX31_PIN_NFCE_B), 0);\r\nmxc_iomux_mode(IOMUX_MODE(MX31_PIN_NFRB, IOMUX_CONFIG_GPIO));\r\nif (!gpio_request(IOMUX_TO_GPIO(MX31_PIN_NFRB), "nand_rdy"))\r\ngpio_direction_input(IOMUX_TO_GPIO(MX31_PIN_NFRB));\r\nmxc_iomux_mode(IOMUX_MODE(MX31_PIN_NFWP_B, IOMUX_CONFIG_GPIO));\r\nif (!gpio_request(IOMUX_TO_GPIO(MX31_PIN_NFWP_B), "nand_wp"))\r\ngpio_direction_input(IOMUX_TO_GPIO(MX31_PIN_NFWP_B));\r\nplatform_device_register(&qong_nand_device);\r\n}\r\nstatic void __init qong_init_fpga(void)\r\n{\r\nvoid __iomem *regs;\r\nu32 fpga_ver;\r\nregs = ioremap(QONG_FPGA_CTRL_BASEADDR, QONG_FPGA_CTRL_SIZE);\r\nif (!regs) {\r\nprintk(KERN_ERR "%s: failed to map registers, aborting.\n",\r\n__func__);\r\nreturn;\r\n}\r\nfpga_ver = readl(regs + QONG_FPGA_CTRL_VERSION);\r\niounmap(regs);\r\nprintk(KERN_INFO "Qong FPGA version %d.%d.%d\n",\r\n(fpga_ver & 0xF000) >> 12,\r\n(fpga_ver & 0x0F00) >> 8, fpga_ver & 0x00FF);\r\nif (fpga_ver < QONG_FPGA_VERSION(0, 8, 7)) {\r\nprintk(KERN_ERR "qong: Unexpected FPGA version, FPGA-based "\r\n"devices won't be registered!\n");\r\nreturn;\r\n}\r\nqong_init_nand_mtd();\r\nqong_init_dnet();\r\n}\r\nstatic void __init qong_init(void)\r\n{\r\nimx31_soc_init();\r\nmxc_init_imx_uart();\r\nqong_init_nor_mtd();\r\nqong_init_fpga();\r\nimx31_add_imx2_wdt();\r\n}\r\nstatic void __init qong_timer_init(void)\r\n{\r\nmx31_clocks_init(26000000);\r\n}
