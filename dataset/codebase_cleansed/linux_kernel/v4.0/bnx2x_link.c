static u32 bnx2x_bits_en(struct bnx2x *bp, u32 reg, u32 bits)\r\n{\r\nu32 val = REG_RD(bp, reg);\r\nval |= bits;\r\nREG_WR(bp, reg, val);\r\nreturn val;\r\n}\r\nstatic u32 bnx2x_bits_dis(struct bnx2x *bp, u32 reg, u32 bits)\r\n{\r\nu32 val = REG_RD(bp, reg);\r\nval &= ~bits;\r\nREG_WR(bp, reg, val);\r\nreturn val;\r\n}\r\nstatic int bnx2x_check_lfa(struct link_params *params)\r\n{\r\nu32 link_status, cfg_idx, lfa_mask, cfg_size;\r\nu32 cur_speed_cap_mask, cur_req_fc_auto_adv, additional_config;\r\nu32 saved_val, req_val, eee_status;\r\nstruct bnx2x *bp = params->bp;\r\nadditional_config =\r\nREG_RD(bp, params->lfa_base +\r\noffsetof(struct shmem_lfa, additional_config));\r\nif (additional_config & NO_LFA_DUE_TO_DCC_MASK) {\r\nDP(NETIF_MSG_LINK, "No LFA due to DCC flap after clp exit\n");\r\nREG_WR(bp, params->lfa_base +\r\noffsetof(struct shmem_lfa, additional_config),\r\nadditional_config & ~NO_LFA_DUE_TO_DCC_MASK);\r\nreturn LFA_DCC_LFA_DISABLED;\r\n}\r\nlink_status = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\nport_mb[params->port].link_status));\r\nif (!(link_status & LINK_STATUS_LINK_UP))\r\nreturn LFA_LINK_DOWN;\r\nif (params->feature_config_flags & FEATURE_CONFIG_BOOT_FROM_SAN)\r\nreturn 0;\r\nif (params->loopback_mode)\r\nreturn LFA_LOOPBACK_ENABLED;\r\nif (!params->lfa_base)\r\nreturn LFA_MFW_IS_TOO_OLD;\r\nif (params->num_phys == 3) {\r\ncfg_size = 2;\r\nlfa_mask = 0xffffffff;\r\n} else {\r\ncfg_size = 1;\r\nlfa_mask = 0xffff;\r\n}\r\nsaved_val = REG_RD(bp, params->lfa_base +\r\noffsetof(struct shmem_lfa, req_duplex));\r\nreq_val = params->req_duplex[0] | (params->req_duplex[1] << 16);\r\nif ((saved_val & lfa_mask) != (req_val & lfa_mask)) {\r\nDP(NETIF_MSG_LINK, "Duplex mismatch %x vs. %x\n",\r\n(saved_val & lfa_mask), (req_val & lfa_mask));\r\nreturn LFA_DUPLEX_MISMATCH;\r\n}\r\nsaved_val = REG_RD(bp, params->lfa_base +\r\noffsetof(struct shmem_lfa, req_flow_ctrl));\r\nreq_val = params->req_flow_ctrl[0] | (params->req_flow_ctrl[1] << 16);\r\nif ((saved_val & lfa_mask) != (req_val & lfa_mask)) {\r\nDP(NETIF_MSG_LINK, "Flow control mismatch %x vs. %x\n",\r\n(saved_val & lfa_mask), (req_val & lfa_mask));\r\nreturn LFA_FLOW_CTRL_MISMATCH;\r\n}\r\nsaved_val = REG_RD(bp, params->lfa_base +\r\noffsetof(struct shmem_lfa, req_line_speed));\r\nreq_val = params->req_line_speed[0] | (params->req_line_speed[1] << 16);\r\nif ((saved_val & lfa_mask) != (req_val & lfa_mask)) {\r\nDP(NETIF_MSG_LINK, "Link speed mismatch %x vs. %x\n",\r\n(saved_val & lfa_mask), (req_val & lfa_mask));\r\nreturn LFA_LINK_SPEED_MISMATCH;\r\n}\r\nfor (cfg_idx = 0; cfg_idx < cfg_size; cfg_idx++) {\r\ncur_speed_cap_mask = REG_RD(bp, params->lfa_base +\r\noffsetof(struct shmem_lfa,\r\nspeed_cap_mask[cfg_idx]));\r\nif (cur_speed_cap_mask != params->speed_cap_mask[cfg_idx]) {\r\nDP(NETIF_MSG_LINK, "Speed Cap mismatch %x vs. %x\n",\r\ncur_speed_cap_mask,\r\nparams->speed_cap_mask[cfg_idx]);\r\nreturn LFA_SPEED_CAP_MISMATCH;\r\n}\r\n}\r\ncur_req_fc_auto_adv =\r\nREG_RD(bp, params->lfa_base +\r\noffsetof(struct shmem_lfa, additional_config)) &\r\nREQ_FC_AUTO_ADV_MASK;\r\nif ((u16)cur_req_fc_auto_adv != params->req_fc_auto_adv) {\r\nDP(NETIF_MSG_LINK, "Flow Ctrl AN mismatch %x vs. %x\n",\r\ncur_req_fc_auto_adv, params->req_fc_auto_adv);\r\nreturn LFA_FLOW_CTRL_MISMATCH;\r\n}\r\neee_status = REG_RD(bp, params->shmem2_base +\r\noffsetof(struct shmem2_region,\r\neee_status[params->port]));\r\nif (((eee_status & SHMEM_EEE_LPI_REQUESTED_BIT) ^\r\n(params->eee_mode & EEE_MODE_ENABLE_LPI)) ||\r\n((eee_status & SHMEM_EEE_REQUESTED_BIT) ^\r\n(params->eee_mode & EEE_MODE_ADV_LPI))) {\r\nDP(NETIF_MSG_LINK, "EEE mismatch %x vs. %x\n", params->eee_mode,\r\neee_status);\r\nreturn LFA_EEE_MISMATCH;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2x_get_epio(struct bnx2x *bp, u32 epio_pin, u32 *en)\r\n{\r\nu32 epio_mask, gp_oenable;\r\n*en = 0;\r\nif (epio_pin > 31) {\r\nDP(NETIF_MSG_LINK, "Invalid EPIO pin %d to get\n", epio_pin);\r\nreturn;\r\n}\r\nepio_mask = 1 << epio_pin;\r\ngp_oenable = REG_RD(bp, MCP_REG_MCPR_GP_OENABLE);\r\nREG_WR(bp, MCP_REG_MCPR_GP_OENABLE, gp_oenable & ~epio_mask);\r\n*en = (REG_RD(bp, MCP_REG_MCPR_GP_INPUTS) & epio_mask) >> epio_pin;\r\n}\r\nstatic void bnx2x_set_epio(struct bnx2x *bp, u32 epio_pin, u32 en)\r\n{\r\nu32 epio_mask, gp_output, gp_oenable;\r\nif (epio_pin > 31) {\r\nDP(NETIF_MSG_LINK, "Invalid EPIO pin %d to set\n", epio_pin);\r\nreturn;\r\n}\r\nDP(NETIF_MSG_LINK, "Setting EPIO pin %d to %d\n", epio_pin, en);\r\nepio_mask = 1 << epio_pin;\r\ngp_output = REG_RD(bp, MCP_REG_MCPR_GP_OUTPUTS);\r\nif (en)\r\ngp_output |= epio_mask;\r\nelse\r\ngp_output &= ~epio_mask;\r\nREG_WR(bp, MCP_REG_MCPR_GP_OUTPUTS, gp_output);\r\ngp_oenable = REG_RD(bp, MCP_REG_MCPR_GP_OENABLE);\r\nREG_WR(bp, MCP_REG_MCPR_GP_OENABLE, gp_oenable | epio_mask);\r\n}\r\nstatic void bnx2x_set_cfg_pin(struct bnx2x *bp, u32 pin_cfg, u32 val)\r\n{\r\nif (pin_cfg == PIN_CFG_NA)\r\nreturn;\r\nif (pin_cfg >= PIN_CFG_EPIO0) {\r\nbnx2x_set_epio(bp, pin_cfg - PIN_CFG_EPIO0, val);\r\n} else {\r\nu8 gpio_num = (pin_cfg - PIN_CFG_GPIO0_P0) & 0x3;\r\nu8 gpio_port = (pin_cfg - PIN_CFG_GPIO0_P0) >> 2;\r\nbnx2x_set_gpio(bp, gpio_num, (u8)val, gpio_port);\r\n}\r\n}\r\nstatic u32 bnx2x_get_cfg_pin(struct bnx2x *bp, u32 pin_cfg, u32 *val)\r\n{\r\nif (pin_cfg == PIN_CFG_NA)\r\nreturn -EINVAL;\r\nif (pin_cfg >= PIN_CFG_EPIO0) {\r\nbnx2x_get_epio(bp, pin_cfg - PIN_CFG_EPIO0, val);\r\n} else {\r\nu8 gpio_num = (pin_cfg - PIN_CFG_GPIO0_P0) & 0x3;\r\nu8 gpio_port = (pin_cfg - PIN_CFG_GPIO0_P0) >> 2;\r\n*val = bnx2x_get_gpio(bp, gpio_num, gpio_port);\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2x_ets_e2e3a0_disabled(struct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nDP(NETIF_MSG_LINK, "ETS E2E3 disabled configuration\n");\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_PRIORITY_CLIENT, 0x4688);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT, 0x7);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_IS_SUBJECT2WFQ, 0);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_NUM_STRICT_ARB_SLOTS, 0x100);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_CREDIT_MAP, 0);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_0, 0);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_1, 0);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_0, 0);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_1, 0);\r\nREG_WR(bp, PBF_REG_HIGH_PRIORITY_COS_NUM, 0);\r\nREG_WR(bp, PBF_REG_ETS_ENABLED, 0);\r\nREG_WR(bp, PBF_REG_COS0_WEIGHT, 0x2710);\r\nREG_WR(bp, PBF_REG_COS1_WEIGHT, 0x2710);\r\nREG_WR(bp, PBF_REG_COS0_UPPER_BOUND, 0x989680);\r\nREG_WR(bp, PBF_REG_COS1_UPPER_BOUND, 0x989680);\r\nREG_WR(bp, PBF_REG_NUM_STRICT_ARB_SLOTS, 0);\r\n}\r\nstatic u32 bnx2x_ets_get_min_w_val_nig(const struct link_vars *vars)\r\n{\r\nu32 min_w_val = 0;\r\nif (vars->link_up) {\r\nif (vars->line_speed == SPEED_20000)\r\nmin_w_val = ETS_E3B0_NIG_MIN_W_VAL_20GBPS;\r\nelse\r\nmin_w_val = ETS_E3B0_NIG_MIN_W_VAL_UP_TO_10GBPS;\r\n} else\r\nmin_w_val = ETS_E3B0_NIG_MIN_W_VAL_20GBPS;\r\nreturn min_w_val;\r\n}\r\nstatic u32 bnx2x_ets_get_credit_upper_bound(const u32 min_w_val)\r\n{\r\nconst u32 credit_upper_bound = (u32)MAXVAL((150 * min_w_val),\r\nMAX_PACKET_SIZE);\r\nreturn credit_upper_bound;\r\n}\r\nstatic void bnx2x_ets_e3b0_set_credit_upper_bound_nig(\r\nconst struct link_params *params,\r\nconst u32 min_w_val)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nconst u8 port = params->port;\r\nconst u32 credit_upper_bound =\r\nbnx2x_ets_get_credit_upper_bound(min_w_val);\r\nREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_0 :\r\nNIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_0, credit_upper_bound);\r\nREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_1 :\r\nNIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_1, credit_upper_bound);\r\nREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_2 :\r\nNIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_2, credit_upper_bound);\r\nREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_3 :\r\nNIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_3, credit_upper_bound);\r\nREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_4 :\r\nNIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_4, credit_upper_bound);\r\nREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_5 :\r\nNIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_5, credit_upper_bound);\r\nif (!port) {\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_6,\r\ncredit_upper_bound);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_7,\r\ncredit_upper_bound);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_8,\r\ncredit_upper_bound);\r\n}\r\n}\r\nstatic void bnx2x_ets_e3b0_nig_disabled(const struct link_params *params,\r\nconst struct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nconst u8 port = params->port;\r\nconst u32 min_w_val = bnx2x_ets_get_min_w_val_nig(vars);\r\nif (port) {\r\nREG_WR(bp, NIG_REG_P1_TX_ARB_PRIORITY_CLIENT2_LSB, 0x543210);\r\nREG_WR(bp, NIG_REG_P1_TX_ARB_PRIORITY_CLIENT2_MSB, 0x0);\r\n} else {\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_PRIORITY_CLIENT2_LSB, 0x76543210);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_PRIORITY_CLIENT2_MSB, 0x8);\r\n}\r\nREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_NUM_STRICT_ARB_SLOTS :\r\nNIG_REG_P1_TX_ARB_NUM_STRICT_ARB_SLOTS, 0x100);\r\nif (port) {\r\nREG_WR(bp, NIG_REG_P1_TX_ARB_CLIENT_CREDIT_MAP2_LSB, 0x210543);\r\nREG_WR(bp, NIG_REG_P1_TX_ARB_CLIENT_CREDIT_MAP2_MSB, 0x0);\r\n} else {\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_CREDIT_MAP2_LSB,\r\n0x43210876);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_CREDIT_MAP2_MSB, 0x5);\r\n}\r\nif (port)\r\nREG_WR(bp, NIG_REG_P1_TX_ARB_CLIENT_IS_STRICT, 0x3f);\r\nelse\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT, 0x1ff);\r\nREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CLIENT_IS_SUBJECT2WFQ :\r\nNIG_REG_P0_TX_ARB_CLIENT_IS_SUBJECT2WFQ, 0);\r\nREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_0 :\r\nNIG_REG_P0_TX_ARB_CREDIT_WEIGHT_0, 0x0);\r\nREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_1 :\r\nNIG_REG_P0_TX_ARB_CREDIT_WEIGHT_1, 0x0);\r\nREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_2 :\r\nNIG_REG_P0_TX_ARB_CREDIT_WEIGHT_2, 0x0);\r\nREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_3 :\r\nNIG_REG_P0_TX_ARB_CREDIT_WEIGHT_3, 0x0);\r\nREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_4 :\r\nNIG_REG_P0_TX_ARB_CREDIT_WEIGHT_4, 0x0);\r\nREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_5 :\r\nNIG_REG_P0_TX_ARB_CREDIT_WEIGHT_5, 0x0);\r\nif (!port) {\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_6, 0x0);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_7, 0x0);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_8, 0x0);\r\n}\r\nbnx2x_ets_e3b0_set_credit_upper_bound_nig(params, min_w_val);\r\n}\r\nstatic void bnx2x_ets_e3b0_set_credit_upper_bound_pbf(\r\nconst struct link_params *params,\r\nconst u32 min_w_val)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nconst u32 credit_upper_bound =\r\nbnx2x_ets_get_credit_upper_bound(min_w_val);\r\nconst u8 port = params->port;\r\nu32 base_upper_bound = 0;\r\nu8 max_cos = 0;\r\nu8 i = 0;\r\nif (!port) {\r\nbase_upper_bound = PBF_REG_COS0_UPPER_BOUND_P0;\r\nmax_cos = DCBX_E3B0_MAX_NUM_COS_PORT0;\r\n} else {\r\nbase_upper_bound = PBF_REG_COS0_UPPER_BOUND_P1;\r\nmax_cos = DCBX_E3B0_MAX_NUM_COS_PORT1;\r\n}\r\nfor (i = 0; i < max_cos; i++)\r\nREG_WR(bp, base_upper_bound + (i << 2), credit_upper_bound);\r\n}\r\nstatic void bnx2x_ets_e3b0_pbf_disabled(const struct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nconst u8 port = params->port;\r\nconst u32 min_w_val_pbf = ETS_E3B0_PBF_MIN_W_VAL;\r\nu8 i = 0;\r\nu32 base_weight = 0;\r\nu8 max_cos = 0;\r\nif (port)\r\nREG_WR(bp, PBF_REG_ETS_ARB_PRIORITY_CLIENT_P1 , 0x688);\r\nelse\r\nREG_WR(bp, PBF_REG_ETS_ARB_PRIORITY_CLIENT_P0 , 0x2C688);\r\nif (port)\r\nREG_WR(bp, PBF_REG_ETS_ARB_CLIENT_CREDIT_MAP_P1, 0x688);\r\nelse\r\nREG_WR(bp, PBF_REG_ETS_ARB_CLIENT_CREDIT_MAP_P0, 0x2C688);\r\nREG_WR(bp, (port) ? PBF_REG_ETS_ARB_NUM_STRICT_ARB_SLOTS_P1 :\r\nPBF_REG_ETS_ARB_NUM_STRICT_ARB_SLOTS_P0 , 0x100);\r\nREG_WR(bp, (port) ? PBF_REG_ETS_ARB_CLIENT_IS_STRICT_P1 :\r\nPBF_REG_ETS_ARB_CLIENT_IS_STRICT_P0 , 0);\r\nREG_WR(bp, (port) ? PBF_REG_ETS_ARB_CLIENT_IS_SUBJECT2WFQ_P1 :\r\nPBF_REG_ETS_ARB_CLIENT_IS_SUBJECT2WFQ_P0 , 0);\r\nif (!port) {\r\nbase_weight = PBF_REG_COS0_WEIGHT_P0;\r\nmax_cos = DCBX_E3B0_MAX_NUM_COS_PORT0;\r\n} else {\r\nbase_weight = PBF_REG_COS0_WEIGHT_P1;\r\nmax_cos = DCBX_E3B0_MAX_NUM_COS_PORT1;\r\n}\r\nfor (i = 0; i < max_cos; i++)\r\nREG_WR(bp, base_weight + (0x4 * i), 0);\r\nbnx2x_ets_e3b0_set_credit_upper_bound_pbf(params, min_w_val_pbf);\r\n}\r\nstatic int bnx2x_ets_e3b0_disabled(const struct link_params *params,\r\nconst struct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nif (!CHIP_IS_E3B0(bp)) {\r\nDP(NETIF_MSG_LINK,\r\n"bnx2x_ets_e3b0_disabled the chip isn't E3B0\n");\r\nreturn -EINVAL;\r\n}\r\nbnx2x_ets_e3b0_nig_disabled(params, vars);\r\nbnx2x_ets_e3b0_pbf_disabled(params);\r\nreturn 0;\r\n}\r\nint bnx2x_ets_disabled(struct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nint bnx2x_status = 0;\r\nif ((CHIP_IS_E2(bp)) || (CHIP_IS_E3A0(bp)))\r\nbnx2x_ets_e2e3a0_disabled(params);\r\nelse if (CHIP_IS_E3B0(bp))\r\nbnx2x_status = bnx2x_ets_e3b0_disabled(params, vars);\r\nelse {\r\nDP(NETIF_MSG_LINK, "bnx2x_ets_disabled - chip not supported\n");\r\nreturn -EINVAL;\r\n}\r\nreturn bnx2x_status;\r\n}\r\nstatic int bnx2x_ets_e3b0_cli_map(const struct link_params *params,\r\nconst struct bnx2x_ets_params *ets_params,\r\nconst u8 cos_sp_bitmap,\r\nconst u8 cos_bw_bitmap)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nconst u8 port = params->port;\r\nconst u8 nig_cli_sp_bitmap = 0x7 | (cos_sp_bitmap << 3);\r\nconst u8 pbf_cli_sp_bitmap = cos_sp_bitmap;\r\nconst u8 nig_cli_subject2wfq_bitmap = cos_bw_bitmap << 3;\r\nconst u8 pbf_cli_subject2wfq_bitmap = cos_bw_bitmap;\r\nREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CLIENT_IS_STRICT :\r\nNIG_REG_P0_TX_ARB_CLIENT_IS_STRICT, nig_cli_sp_bitmap);\r\nREG_WR(bp, (port) ? PBF_REG_ETS_ARB_CLIENT_IS_STRICT_P1 :\r\nPBF_REG_ETS_ARB_CLIENT_IS_STRICT_P0 , pbf_cli_sp_bitmap);\r\nREG_WR(bp, (port) ? NIG_REG_P1_TX_ARB_CLIENT_IS_SUBJECT2WFQ :\r\nNIG_REG_P0_TX_ARB_CLIENT_IS_SUBJECT2WFQ,\r\nnig_cli_subject2wfq_bitmap);\r\nREG_WR(bp, (port) ? PBF_REG_ETS_ARB_CLIENT_IS_SUBJECT2WFQ_P1 :\r\nPBF_REG_ETS_ARB_CLIENT_IS_SUBJECT2WFQ_P0,\r\npbf_cli_subject2wfq_bitmap);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_ets_e3b0_set_cos_bw(struct bnx2x *bp,\r\nconst u8 cos_entry,\r\nconst u32 min_w_val_nig,\r\nconst u32 min_w_val_pbf,\r\nconst u16 total_bw,\r\nconst u8 bw,\r\nconst u8 port)\r\n{\r\nu32 nig_reg_adress_crd_weight = 0;\r\nu32 pbf_reg_adress_crd_weight = 0;\r\nconst u32 cos_bw_nig = ((bw ? bw : 1) * min_w_val_nig) / total_bw;\r\nconst u32 cos_bw_pbf = ((bw ? bw : 1) * min_w_val_pbf) / total_bw;\r\nswitch (cos_entry) {\r\ncase 0:\r\nnig_reg_adress_crd_weight =\r\n(port) ? NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_0 :\r\nNIG_REG_P0_TX_ARB_CREDIT_WEIGHT_0;\r\npbf_reg_adress_crd_weight = (port) ?\r\nPBF_REG_COS0_WEIGHT_P1 : PBF_REG_COS0_WEIGHT_P0;\r\nbreak;\r\ncase 1:\r\nnig_reg_adress_crd_weight = (port) ?\r\nNIG_REG_P1_TX_ARB_CREDIT_WEIGHT_1 :\r\nNIG_REG_P0_TX_ARB_CREDIT_WEIGHT_1;\r\npbf_reg_adress_crd_weight = (port) ?\r\nPBF_REG_COS1_WEIGHT_P1 : PBF_REG_COS1_WEIGHT_P0;\r\nbreak;\r\ncase 2:\r\nnig_reg_adress_crd_weight = (port) ?\r\nNIG_REG_P1_TX_ARB_CREDIT_WEIGHT_2 :\r\nNIG_REG_P0_TX_ARB_CREDIT_WEIGHT_2;\r\npbf_reg_adress_crd_weight = (port) ?\r\nPBF_REG_COS2_WEIGHT_P1 : PBF_REG_COS2_WEIGHT_P0;\r\nbreak;\r\ncase 3:\r\nif (port)\r\nreturn -EINVAL;\r\nnig_reg_adress_crd_weight =\r\nNIG_REG_P0_TX_ARB_CREDIT_WEIGHT_3;\r\npbf_reg_adress_crd_weight =\r\nPBF_REG_COS3_WEIGHT_P0;\r\nbreak;\r\ncase 4:\r\nif (port)\r\nreturn -EINVAL;\r\nnig_reg_adress_crd_weight =\r\nNIG_REG_P0_TX_ARB_CREDIT_WEIGHT_4;\r\npbf_reg_adress_crd_weight = PBF_REG_COS4_WEIGHT_P0;\r\nbreak;\r\ncase 5:\r\nif (port)\r\nreturn -EINVAL;\r\nnig_reg_adress_crd_weight =\r\nNIG_REG_P0_TX_ARB_CREDIT_WEIGHT_5;\r\npbf_reg_adress_crd_weight = PBF_REG_COS5_WEIGHT_P0;\r\nbreak;\r\n}\r\nREG_WR(bp, nig_reg_adress_crd_weight, cos_bw_nig);\r\nREG_WR(bp, pbf_reg_adress_crd_weight, cos_bw_pbf);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_ets_e3b0_get_total_bw(\r\nconst struct link_params *params,\r\nstruct bnx2x_ets_params *ets_params,\r\nu16 *total_bw)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 cos_idx = 0;\r\nu8 is_bw_cos_exist = 0;\r\n*total_bw = 0 ;\r\nfor (cos_idx = 0; cos_idx < ets_params->num_of_cos; cos_idx++) {\r\nif (ets_params->cos[cos_idx].state == bnx2x_cos_state_bw) {\r\nis_bw_cos_exist = 1;\r\nif (!ets_params->cos[cos_idx].params.bw_params.bw) {\r\nDP(NETIF_MSG_LINK, "bnx2x_ets_E3B0_config BW"\r\n"was set to 0\n");\r\nets_params->cos[cos_idx].params.bw_params.bw\r\n= 1;\r\n}\r\n*total_bw +=\r\nets_params->cos[cos_idx].params.bw_params.bw;\r\n}\r\n}\r\nif ((is_bw_cos_exist == 1) && (*total_bw != 100)) {\r\nif (*total_bw == 0) {\r\nDP(NETIF_MSG_LINK,\r\n"bnx2x_ets_E3B0_config total BW shouldn't be 0\n");\r\nreturn -EINVAL;\r\n}\r\nDP(NETIF_MSG_LINK,\r\n"bnx2x_ets_E3B0_config total BW should be 100\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2x_ets_e3b0_sp_pri_to_cos_init(u8 *sp_pri_to_cos)\r\n{\r\nu8 pri = 0;\r\nfor (pri = 0; pri < DCBX_MAX_NUM_COS; pri++)\r\nsp_pri_to_cos[pri] = DCBX_INVALID_COS;\r\n}\r\nstatic int bnx2x_ets_e3b0_sp_pri_to_cos_set(const struct link_params *params,\r\nu8 *sp_pri_to_cos, const u8 pri,\r\nconst u8 cos_entry)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nconst u8 port = params->port;\r\nconst u8 max_num_of_cos = (port) ? DCBX_E3B0_MAX_NUM_COS_PORT1 :\r\nDCBX_E3B0_MAX_NUM_COS_PORT0;\r\nif (pri >= max_num_of_cos) {\r\nDP(NETIF_MSG_LINK, "bnx2x_ets_e3b0_sp_pri_to_cos_set invalid "\r\n"parameter Illegal strict priority\n");\r\nreturn -EINVAL;\r\n}\r\nif (sp_pri_to_cos[pri] != DCBX_INVALID_COS) {\r\nDP(NETIF_MSG_LINK, "bnx2x_ets_e3b0_sp_pri_to_cos_set invalid "\r\n"parameter There can't be two COS's with "\r\n"the same strict pri\n");\r\nreturn -EINVAL;\r\n}\r\nsp_pri_to_cos[pri] = cos_entry;\r\nreturn 0;\r\n}\r\nstatic u64 bnx2x_e3b0_sp_get_pri_cli_reg(const u8 cos, const u8 cos_offset,\r\nconst u8 pri_set,\r\nconst u8 pri_offset,\r\nconst u8 entry_size)\r\n{\r\nu64 pri_cli_nig = 0;\r\npri_cli_nig = ((u64)(cos + cos_offset)) << (entry_size *\r\n(pri_set + pri_offset));\r\nreturn pri_cli_nig;\r\n}\r\nstatic u64 bnx2x_e3b0_sp_get_pri_cli_reg_nig(const u8 cos, const u8 pri_set)\r\n{\r\nconst u8 nig_cos_offset = 3;\r\nconst u8 nig_pri_offset = 3;\r\nreturn bnx2x_e3b0_sp_get_pri_cli_reg(cos, nig_cos_offset, pri_set,\r\nnig_pri_offset, 4);\r\n}\r\nstatic u64 bnx2x_e3b0_sp_get_pri_cli_reg_pbf(const u8 cos, const u8 pri_set)\r\n{\r\nconst u8 pbf_cos_offset = 0;\r\nconst u8 pbf_pri_offset = 0;\r\nreturn bnx2x_e3b0_sp_get_pri_cli_reg(cos, pbf_cos_offset, pri_set,\r\npbf_pri_offset, 3);\r\n}\r\nstatic int bnx2x_ets_e3b0_sp_set_pri_cli_reg(const struct link_params *params,\r\nu8 *sp_pri_to_cos)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 i = 0;\r\nconst u8 port = params->port;\r\nu64 pri_cli_nig = 0x210;\r\nu32 pri_cli_pbf = 0x0;\r\nu8 pri_set = 0;\r\nu8 pri_bitmask = 0;\r\nconst u8 max_num_of_cos = (port) ? DCBX_E3B0_MAX_NUM_COS_PORT1 :\r\nDCBX_E3B0_MAX_NUM_COS_PORT0;\r\nu8 cos_bit_to_set = (1 << max_num_of_cos) - 1;\r\nfor (i = 0; i < max_num_of_cos; i++) {\r\nif (sp_pri_to_cos[i] != DCBX_INVALID_COS) {\r\nif (sp_pri_to_cos[i] >= DCBX_MAX_NUM_COS) {\r\nDP(NETIF_MSG_LINK,\r\n"bnx2x_ets_e3b0_sp_set_pri_cli_reg "\r\n"invalid cos entry\n");\r\nreturn -EINVAL;\r\n}\r\npri_cli_nig |= bnx2x_e3b0_sp_get_pri_cli_reg_nig(\r\nsp_pri_to_cos[i], pri_set);\r\npri_cli_pbf |= bnx2x_e3b0_sp_get_pri_cli_reg_pbf(\r\nsp_pri_to_cos[i], pri_set);\r\npri_bitmask = 1 << sp_pri_to_cos[i];\r\nif (!(pri_bitmask & cos_bit_to_set)) {\r\nDP(NETIF_MSG_LINK,\r\n"bnx2x_ets_e3b0_sp_set_pri_cli_reg "\r\n"invalid There can't be two COS's with"\r\n" the same strict pri\n");\r\nreturn -EINVAL;\r\n}\r\ncos_bit_to_set &= ~pri_bitmask;\r\npri_set++;\r\n}\r\n}\r\nfor (i = 0; i < max_num_of_cos; i++) {\r\npri_bitmask = 1 << i;\r\nif (pri_bitmask & cos_bit_to_set) {\r\npri_cli_nig |= bnx2x_e3b0_sp_get_pri_cli_reg_nig(\r\ni, pri_set);\r\npri_cli_pbf |= bnx2x_e3b0_sp_get_pri_cli_reg_pbf(\r\ni, pri_set);\r\ncos_bit_to_set &= ~pri_bitmask;\r\npri_set++;\r\n}\r\n}\r\nif (pri_set != max_num_of_cos) {\r\nDP(NETIF_MSG_LINK, "bnx2x_ets_e3b0_sp_set_pri_cli_reg not all "\r\n"entries were set\n");\r\nreturn -EINVAL;\r\n}\r\nif (port) {\r\nREG_WR(bp, NIG_REG_P1_TX_ARB_PRIORITY_CLIENT2_LSB,\r\n(u32)pri_cli_nig);\r\nREG_WR(bp, PBF_REG_ETS_ARB_PRIORITY_CLIENT_P1 , pri_cli_pbf);\r\n} else {\r\nconst u32 pri_cli_nig_lsb = (u32) (pri_cli_nig);\r\nconst u32 pri_cli_nig_msb = (u32) ((pri_cli_nig >> 32) & 0xF);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_PRIORITY_CLIENT2_LSB,\r\npri_cli_nig_lsb);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_PRIORITY_CLIENT2_MSB,\r\npri_cli_nig_msb);\r\nREG_WR(bp, PBF_REG_ETS_ARB_PRIORITY_CLIENT_P0 , pri_cli_pbf);\r\n}\r\nreturn 0;\r\n}\r\nint bnx2x_ets_e3b0_config(const struct link_params *params,\r\nconst struct link_vars *vars,\r\nstruct bnx2x_ets_params *ets_params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nint bnx2x_status = 0;\r\nconst u8 port = params->port;\r\nu16 total_bw = 0;\r\nconst u32 min_w_val_nig = bnx2x_ets_get_min_w_val_nig(vars);\r\nconst u32 min_w_val_pbf = ETS_E3B0_PBF_MIN_W_VAL;\r\nu8 cos_bw_bitmap = 0;\r\nu8 cos_sp_bitmap = 0;\r\nu8 sp_pri_to_cos[DCBX_MAX_NUM_COS] = {0};\r\nconst u8 max_num_of_cos = (port) ? DCBX_E3B0_MAX_NUM_COS_PORT1 :\r\nDCBX_E3B0_MAX_NUM_COS_PORT0;\r\nu8 cos_entry = 0;\r\nif (!CHIP_IS_E3B0(bp)) {\r\nDP(NETIF_MSG_LINK,\r\n"bnx2x_ets_e3b0_disabled the chip isn't E3B0\n");\r\nreturn -EINVAL;\r\n}\r\nif ((ets_params->num_of_cos > max_num_of_cos)) {\r\nDP(NETIF_MSG_LINK, "bnx2x_ets_E3B0_config the number of COS "\r\n"isn't supported\n");\r\nreturn -EINVAL;\r\n}\r\nbnx2x_ets_e3b0_sp_pri_to_cos_init(sp_pri_to_cos);\r\nbnx2x_status = bnx2x_ets_e3b0_get_total_bw(params, ets_params,\r\n&total_bw);\r\nif (bnx2x_status) {\r\nDP(NETIF_MSG_LINK,\r\n"bnx2x_ets_E3B0_config get_total_bw failed\n");\r\nreturn -EINVAL;\r\n}\r\nbnx2x_ets_e3b0_set_credit_upper_bound_nig(params, min_w_val_nig);\r\nbnx2x_ets_e3b0_set_credit_upper_bound_pbf(params, min_w_val_pbf);\r\nfor (cos_entry = 0; cos_entry < ets_params->num_of_cos; cos_entry++) {\r\nif (bnx2x_cos_state_bw == ets_params->cos[cos_entry].state) {\r\ncos_bw_bitmap |= (1 << cos_entry);\r\nbnx2x_status = bnx2x_ets_e3b0_set_cos_bw(\r\nbp, cos_entry, min_w_val_nig, min_w_val_pbf,\r\ntotal_bw,\r\nets_params->cos[cos_entry].params.bw_params.bw,\r\nport);\r\n} else if (bnx2x_cos_state_strict ==\r\nets_params->cos[cos_entry].state){\r\ncos_sp_bitmap |= (1 << cos_entry);\r\nbnx2x_status = bnx2x_ets_e3b0_sp_pri_to_cos_set(\r\nparams,\r\nsp_pri_to_cos,\r\nets_params->cos[cos_entry].params.sp_params.pri,\r\ncos_entry);\r\n} else {\r\nDP(NETIF_MSG_LINK,\r\n"bnx2x_ets_e3b0_config cos state not valid\n");\r\nreturn -EINVAL;\r\n}\r\nif (bnx2x_status) {\r\nDP(NETIF_MSG_LINK,\r\n"bnx2x_ets_e3b0_config set cos bw failed\n");\r\nreturn bnx2x_status;\r\n}\r\n}\r\nbnx2x_status = bnx2x_ets_e3b0_sp_set_pri_cli_reg(params,\r\nsp_pri_to_cos);\r\nif (bnx2x_status) {\r\nDP(NETIF_MSG_LINK,\r\n"bnx2x_ets_E3B0_config set_pri_cli_reg failed\n");\r\nreturn bnx2x_status;\r\n}\r\nbnx2x_status = bnx2x_ets_e3b0_cli_map(params, ets_params,\r\ncos_sp_bitmap,\r\ncos_bw_bitmap);\r\nif (bnx2x_status) {\r\nDP(NETIF_MSG_LINK, "bnx2x_ets_E3B0_config SP failed\n");\r\nreturn bnx2x_status;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2x_ets_bw_limit_common(const struct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nDP(NETIF_MSG_LINK, "ETS enabled BW limit configuration\n");\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_IS_SUBJECT2WFQ, 0x18);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_CREDIT_MAP, 0x111A);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_0,\r\nETS_BW_LIMIT_CREDIT_UPPER_BOUND);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_1,\r\nETS_BW_LIMIT_CREDIT_UPPER_BOUND);\r\nREG_WR(bp, PBF_REG_ETS_ENABLED, 1);\r\nREG_WR(bp, PBF_REG_NUM_STRICT_ARB_SLOTS, 0);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT, 0x7);\r\nREG_WR(bp, PBF_REG_COS0_UPPER_BOUND,\r\nETS_BW_LIMIT_CREDIT_UPPER_BOUND);\r\nREG_WR(bp, PBF_REG_COS1_UPPER_BOUND,\r\nETS_BW_LIMIT_CREDIT_UPPER_BOUND);\r\n}\r\nvoid bnx2x_ets_bw_limit(const struct link_params *params, const u32 cos0_bw,\r\nconst u32 cos1_bw)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nconst u32 total_bw = cos0_bw + cos1_bw;\r\nu32 cos0_credit_weight = 0;\r\nu32 cos1_credit_weight = 0;\r\nDP(NETIF_MSG_LINK, "ETS enabled BW limit configuration\n");\r\nif ((!total_bw) ||\r\n(!cos0_bw) ||\r\n(!cos1_bw)) {\r\nDP(NETIF_MSG_LINK, "Total BW can't be zero\n");\r\nreturn;\r\n}\r\ncos0_credit_weight = (cos0_bw * ETS_BW_LIMIT_CREDIT_WEIGHT)/\r\ntotal_bw;\r\ncos1_credit_weight = (cos1_bw * ETS_BW_LIMIT_CREDIT_WEIGHT)/\r\ntotal_bw;\r\nbnx2x_ets_bw_limit_common(params);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_0, cos0_credit_weight);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_1, cos1_credit_weight);\r\nREG_WR(bp, PBF_REG_COS0_WEIGHT, cos0_credit_weight);\r\nREG_WR(bp, PBF_REG_COS1_WEIGHT, cos1_credit_weight);\r\n}\r\nint bnx2x_ets_strict(const struct link_params *params, const u8 strict_cos)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu32 val = 0;\r\nDP(NETIF_MSG_LINK, "ETS enabled strict configuration\n");\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT, 0x1F);\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_NUM_STRICT_ARB_SLOTS, 0x100);\r\nREG_WR(bp, PBF_REG_ETS_ENABLED, 0);\r\nREG_WR(bp, PBF_REG_NUM_STRICT_ARB_SLOTS, 0x100);\r\nREG_WR(bp, PBF_REG_HIGH_PRIORITY_COS_NUM, strict_cos);\r\nval = (!strict_cos) ? 0x2318 : 0x22E0;\r\nREG_WR(bp, NIG_REG_P0_TX_ARB_PRIORITY_CLIENT, val);\r\nreturn 0;\r\n}\r\nstatic void bnx2x_update_pfc_xmac(struct link_params *params,\r\nstruct link_vars *vars,\r\nu8 is_lb)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu32 xmac_base;\r\nu32 pause_val, pfc0_val, pfc1_val;\r\nxmac_base = (params->port) ? GRCBASE_XMAC1 : GRCBASE_XMAC0;\r\npause_val = 0x18000;\r\npfc0_val = 0xFFFF8000;\r\npfc1_val = 0x2;\r\nif (!(params->feature_config_flags &\r\nFEATURE_CONFIG_PFC_ENABLED)) {\r\nif (vars->flow_ctrl & BNX2X_FLOW_CTRL_RX)\r\npause_val |= XMAC_PAUSE_CTRL_REG_RX_PAUSE_EN;\r\nif (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX)\r\npause_val |= XMAC_PAUSE_CTRL_REG_TX_PAUSE_EN;\r\n} else {\r\npfc1_val |= XMAC_PFC_CTRL_HI_REG_PFC_REFRESH_EN |\r\nXMAC_PFC_CTRL_HI_REG_PFC_STATS_EN |\r\nXMAC_PFC_CTRL_HI_REG_RX_PFC_EN |\r\nXMAC_PFC_CTRL_HI_REG_TX_PFC_EN |\r\nXMAC_PFC_CTRL_HI_REG_FORCE_PFC_XON;\r\nREG_WR(bp, xmac_base + XMAC_REG_PAUSE_CTRL, pause_val);\r\nREG_WR(bp, xmac_base + XMAC_REG_PFC_CTRL, pfc0_val);\r\nREG_WR(bp, xmac_base + XMAC_REG_PFC_CTRL_HI, pfc1_val);\r\npfc1_val &= ~XMAC_PFC_CTRL_HI_REG_FORCE_PFC_XON;\r\n}\r\nREG_WR(bp, xmac_base + XMAC_REG_PAUSE_CTRL, pause_val);\r\nREG_WR(bp, xmac_base + XMAC_REG_PFC_CTRL, pfc0_val);\r\nREG_WR(bp, xmac_base + XMAC_REG_PFC_CTRL_HI, pfc1_val);\r\nREG_WR(bp, xmac_base + XMAC_REG_CTRL_SA_LO,\r\n((params->mac_addr[2] << 24) |\r\n(params->mac_addr[3] << 16) |\r\n(params->mac_addr[4] << 8) |\r\n(params->mac_addr[5])));\r\nREG_WR(bp, xmac_base + XMAC_REG_CTRL_SA_HI,\r\n((params->mac_addr[0] << 8) |\r\n(params->mac_addr[1])));\r\nudelay(30);\r\n}\r\nstatic void bnx2x_set_mdio_clk(struct bnx2x *bp, u32 chip_id,\r\nu32 emac_base)\r\n{\r\nu32 new_mode, cur_mode;\r\nu32 clc_cnt;\r\ncur_mode = REG_RD(bp, emac_base + EMAC_REG_EMAC_MDIO_MODE);\r\nif (USES_WARPCORE(bp))\r\nclc_cnt = 74L << EMAC_MDIO_MODE_CLOCK_CNT_BITSHIFT;\r\nelse\r\nclc_cnt = 49L << EMAC_MDIO_MODE_CLOCK_CNT_BITSHIFT;\r\nif (((cur_mode & EMAC_MDIO_MODE_CLOCK_CNT) == clc_cnt) &&\r\n(cur_mode & (EMAC_MDIO_MODE_CLAUSE_45)))\r\nreturn;\r\nnew_mode = cur_mode &\r\n~(EMAC_MDIO_MODE_AUTO_POLL | EMAC_MDIO_MODE_CLOCK_CNT);\r\nnew_mode |= clc_cnt;\r\nnew_mode |= (EMAC_MDIO_MODE_CLAUSE_45);\r\nDP(NETIF_MSG_LINK, "Changing emac_mode from 0x%x to 0x%x\n",\r\ncur_mode, new_mode);\r\nREG_WR(bp, emac_base + EMAC_REG_EMAC_MDIO_MODE, new_mode);\r\nudelay(40);\r\n}\r\nstatic void bnx2x_set_mdio_emac_per_phy(struct bnx2x *bp,\r\nstruct link_params *params)\r\n{\r\nu8 phy_index;\r\nfor (phy_index = INT_PHY; phy_index < params->num_phys;\r\nphy_index++)\r\nbnx2x_set_mdio_clk(bp, params->chip_id,\r\nparams->phy[phy_index].mdio_ctrl);\r\n}\r\nstatic u8 bnx2x_is_4_port_mode(struct bnx2x *bp)\r\n{\r\nu32 port4mode_ovwr_val;\r\nport4mode_ovwr_val = REG_RD(bp, MISC_REG_PORT4MODE_EN_OVWR);\r\nif (port4mode_ovwr_val & (1<<0)) {\r\nreturn ((port4mode_ovwr_val & (1<<1)) == (1<<1));\r\n}\r\nreturn (u8)REG_RD(bp, MISC_REG_PORT4MODE_EN);\r\n}\r\nstatic void bnx2x_emac_init(struct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 port = params->port;\r\nu32 emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;\r\nu32 val;\r\nu16 timeout;\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\r\n(MISC_REGISTERS_RESET_REG_2_RST_EMAC0_HARD_CORE << port));\r\nudelay(5);\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,\r\n(MISC_REGISTERS_RESET_REG_2_RST_EMAC0_HARD_CORE << port));\r\nval = REG_RD(bp, emac_base + EMAC_REG_EMAC_MODE);\r\nEMAC_WR(bp, EMAC_REG_EMAC_MODE, (val | EMAC_MODE_RESET));\r\ntimeout = 200;\r\ndo {\r\nval = REG_RD(bp, emac_base + EMAC_REG_EMAC_MODE);\r\nDP(NETIF_MSG_LINK, "EMAC reset reg is %u\n", val);\r\nif (!timeout) {\r\nDP(NETIF_MSG_LINK, "EMAC timeout!\n");\r\nreturn;\r\n}\r\ntimeout--;\r\n} while (val & EMAC_MODE_RESET);\r\nbnx2x_set_mdio_emac_per_phy(bp, params);\r\nval = ((params->mac_addr[0] << 8) |\r\nparams->mac_addr[1]);\r\nEMAC_WR(bp, EMAC_REG_EMAC_MAC_MATCH, val);\r\nval = ((params->mac_addr[2] << 24) |\r\n(params->mac_addr[3] << 16) |\r\n(params->mac_addr[4] << 8) |\r\nparams->mac_addr[5]);\r\nEMAC_WR(bp, EMAC_REG_EMAC_MAC_MATCH + 4, val);\r\n}\r\nstatic void bnx2x_set_xumac_nig(struct link_params *params,\r\nu16 tx_pause_en,\r\nu8 enable)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nREG_WR(bp, params->port ? NIG_REG_P1_MAC_IN_EN : NIG_REG_P0_MAC_IN_EN,\r\nenable);\r\nREG_WR(bp, params->port ? NIG_REG_P1_MAC_OUT_EN : NIG_REG_P0_MAC_OUT_EN,\r\nenable);\r\nREG_WR(bp, params->port ? NIG_REG_P1_MAC_PAUSE_OUT_EN :\r\nNIG_REG_P0_MAC_PAUSE_OUT_EN, tx_pause_en);\r\n}\r\nstatic void bnx2x_set_umac_rxtx(struct link_params *params, u8 en)\r\n{\r\nu32 umac_base = params->port ? GRCBASE_UMAC1 : GRCBASE_UMAC0;\r\nu32 val;\r\nstruct bnx2x *bp = params->bp;\r\nif (!(REG_RD(bp, MISC_REG_RESET_REG_2) &\r\n(MISC_REGISTERS_RESET_REG_2_UMAC0 << params->port)))\r\nreturn;\r\nval = REG_RD(bp, umac_base + UMAC_REG_COMMAND_CONFIG);\r\nif (en)\r\nval |= (UMAC_COMMAND_CONFIG_REG_TX_ENA |\r\nUMAC_COMMAND_CONFIG_REG_RX_ENA);\r\nelse\r\nval &= ~(UMAC_COMMAND_CONFIG_REG_TX_ENA |\r\nUMAC_COMMAND_CONFIG_REG_RX_ENA);\r\nREG_WR(bp, umac_base + UMAC_REG_COMMAND_CONFIG, val);\r\n}\r\nstatic void bnx2x_umac_enable(struct link_params *params,\r\nstruct link_vars *vars, u8 lb)\r\n{\r\nu32 val;\r\nu32 umac_base = params->port ? GRCBASE_UMAC1 : GRCBASE_UMAC0;\r\nstruct bnx2x *bp = params->bp;\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\r\n(MISC_REGISTERS_RESET_REG_2_UMAC0 << params->port));\r\nusleep_range(1000, 2000);\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,\r\n(MISC_REGISTERS_RESET_REG_2_UMAC0 << params->port));\r\nDP(NETIF_MSG_LINK, "enabling UMAC\n");\r\nREG_WR(bp, NIG_REG_EGRESS_EMAC0_PORT + params->port*4, 1);\r\nval = UMAC_COMMAND_CONFIG_REG_PROMIS_EN |\r\nUMAC_COMMAND_CONFIG_REG_PAD_EN |\r\nUMAC_COMMAND_CONFIG_REG_SW_RESET |\r\nUMAC_COMMAND_CONFIG_REG_NO_LGTH_CHECK;\r\nswitch (vars->line_speed) {\r\ncase SPEED_10:\r\nval |= (0<<2);\r\nbreak;\r\ncase SPEED_100:\r\nval |= (1<<2);\r\nbreak;\r\ncase SPEED_1000:\r\nval |= (2<<2);\r\nbreak;\r\ncase SPEED_2500:\r\nval |= (3<<2);\r\nbreak;\r\ndefault:\r\nDP(NETIF_MSG_LINK, "Invalid speed for UMAC %d\n",\r\nvars->line_speed);\r\nbreak;\r\n}\r\nif (!(vars->flow_ctrl & BNX2X_FLOW_CTRL_TX))\r\nval |= UMAC_COMMAND_CONFIG_REG_IGNORE_TX_PAUSE;\r\nif (!(vars->flow_ctrl & BNX2X_FLOW_CTRL_RX))\r\nval |= UMAC_COMMAND_CONFIG_REG_PAUSE_IGNORE;\r\nif (vars->duplex == DUPLEX_HALF)\r\nval |= UMAC_COMMAND_CONFIG_REG_HD_ENA;\r\nREG_WR(bp, umac_base + UMAC_REG_COMMAND_CONFIG, val);\r\nudelay(50);\r\nif (vars->eee_status & SHMEM_EEE_ADV_STATUS_MASK) {\r\nDP(NETIF_MSG_LINK, "configured UMAC for EEE\n");\r\nREG_WR(bp, umac_base + UMAC_REG_UMAC_EEE_CTRL,\r\nUMAC_UMAC_EEE_CTRL_REG_EEE_EN);\r\nREG_WR(bp, umac_base + UMAC_REG_EEE_WAKE_TIMER, 0x11);\r\n} else {\r\nREG_WR(bp, umac_base + UMAC_REG_UMAC_EEE_CTRL, 0x0);\r\n}\r\nREG_WR(bp, umac_base + UMAC_REG_MAC_ADDR0,\r\n((params->mac_addr[2] << 24) |\r\n(params->mac_addr[3] << 16) |\r\n(params->mac_addr[4] << 8) |\r\n(params->mac_addr[5])));\r\nREG_WR(bp, umac_base + UMAC_REG_MAC_ADDR1,\r\n((params->mac_addr[0] << 8) |\r\n(params->mac_addr[1])));\r\nval &= ~UMAC_COMMAND_CONFIG_REG_PAD_EN;\r\nval |= UMAC_COMMAND_CONFIG_REG_TX_ENA |\r\nUMAC_COMMAND_CONFIG_REG_RX_ENA;\r\nREG_WR(bp, umac_base + UMAC_REG_COMMAND_CONFIG, val);\r\nudelay(50);\r\nval &= ~UMAC_COMMAND_CONFIG_REG_SW_RESET;\r\nif (lb)\r\nval |= UMAC_COMMAND_CONFIG_REG_LOOP_ENA;\r\nREG_WR(bp, umac_base + UMAC_REG_COMMAND_CONFIG, val);\r\nREG_WR(bp, umac_base + UMAC_REG_MAXFR, 0x2710);\r\nbnx2x_set_xumac_nig(params,\r\n((vars->flow_ctrl & BNX2X_FLOW_CTRL_TX) != 0), 1);\r\nvars->mac_type = MAC_TYPE_UMAC;\r\n}\r\nstatic void bnx2x_xmac_init(struct link_params *params, u32 max_speed)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu32 is_port4mode = bnx2x_is_4_port_mode(bp);\r\nif (((CHIP_NUM(bp) == CHIP_NUM_57840_4_10) ||\r\n(CHIP_NUM(bp) == CHIP_NUM_57840_2_20) ||\r\n(CHIP_NUM(bp) == CHIP_NUM_57840_OBSOLETE)) &&\r\nis_port4mode &&\r\n(REG_RD(bp, MISC_REG_RESET_REG_2) &\r\nMISC_REGISTERS_RESET_REG_2_XMAC)) {\r\nDP(NETIF_MSG_LINK,\r\n"XMAC already out of reset in 4-port mode\n");\r\nreturn;\r\n}\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\r\nMISC_REGISTERS_RESET_REG_2_XMAC);\r\nusleep_range(1000, 2000);\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,\r\nMISC_REGISTERS_RESET_REG_2_XMAC);\r\nif (is_port4mode) {\r\nDP(NETIF_MSG_LINK, "Init XMAC to 2 ports x 10G per path\n");\r\nREG_WR(bp, MISC_REG_XMAC_CORE_PORT_MODE, 1);\r\nREG_WR(bp, MISC_REG_XMAC_PHY_PORT_MODE, 3);\r\n} else {\r\nREG_WR(bp, MISC_REG_XMAC_CORE_PORT_MODE, 0);\r\nif (max_speed == SPEED_10000) {\r\nDP(NETIF_MSG_LINK,\r\n"Init XMAC to 10G x 1 port per path\n");\r\nREG_WR(bp, MISC_REG_XMAC_PHY_PORT_MODE, 3);\r\n} else {\r\nDP(NETIF_MSG_LINK,\r\n"Init XMAC to 20G x 2 ports per path\n");\r\nREG_WR(bp, MISC_REG_XMAC_PHY_PORT_MODE, 1);\r\n}\r\n}\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\r\nMISC_REGISTERS_RESET_REG_2_XMAC_SOFT);\r\nusleep_range(1000, 2000);\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,\r\nMISC_REGISTERS_RESET_REG_2_XMAC_SOFT);\r\n}\r\nstatic void bnx2x_set_xmac_rxtx(struct link_params *params, u8 en)\r\n{\r\nu8 port = params->port;\r\nstruct bnx2x *bp = params->bp;\r\nu32 pfc_ctrl, xmac_base = (port) ? GRCBASE_XMAC1 : GRCBASE_XMAC0;\r\nu32 val;\r\nif (REG_RD(bp, MISC_REG_RESET_REG_2) &\r\nMISC_REGISTERS_RESET_REG_2_XMAC) {\r\npfc_ctrl = REG_RD(bp, xmac_base + XMAC_REG_PFC_CTRL_HI);\r\nREG_WR(bp, xmac_base + XMAC_REG_PFC_CTRL_HI,\r\n(pfc_ctrl & ~(1<<1)));\r\nREG_WR(bp, xmac_base + XMAC_REG_PFC_CTRL_HI,\r\n(pfc_ctrl | (1<<1)));\r\nDP(NETIF_MSG_LINK, "Disable XMAC on port %x\n", port);\r\nval = REG_RD(bp, xmac_base + XMAC_REG_CTRL);\r\nif (en)\r\nval |= (XMAC_CTRL_REG_TX_EN | XMAC_CTRL_REG_RX_EN);\r\nelse\r\nval &= ~(XMAC_CTRL_REG_TX_EN | XMAC_CTRL_REG_RX_EN);\r\nREG_WR(bp, xmac_base + XMAC_REG_CTRL, val);\r\n}\r\n}\r\nstatic int bnx2x_xmac_enable(struct link_params *params,\r\nstruct link_vars *vars, u8 lb)\r\n{\r\nu32 val, xmac_base;\r\nstruct bnx2x *bp = params->bp;\r\nDP(NETIF_MSG_LINK, "enabling XMAC\n");\r\nxmac_base = (params->port) ? GRCBASE_XMAC1 : GRCBASE_XMAC0;\r\nbnx2x_xmac_init(params, vars->line_speed);\r\nREG_WR(bp, NIG_REG_EGRESS_EMAC0_PORT + params->port*4, 0);\r\nif (!(params->phy[INT_PHY].flags & FLAGS_TX_ERROR_CHECK)) {\r\nREG_WR(bp, xmac_base + XMAC_REG_RX_LSS_CTRL,\r\n(XMAC_RX_LSS_CTRL_REG_LOCAL_FAULT_DISABLE |\r\nXMAC_RX_LSS_CTRL_REG_REMOTE_FAULT_DISABLE));\r\nREG_WR(bp, xmac_base + XMAC_REG_CLEAR_RX_LSS_STATUS, 0);\r\nREG_WR(bp, xmac_base + XMAC_REG_CLEAR_RX_LSS_STATUS,\r\nXMAC_CLEAR_RX_LSS_STATUS_REG_CLEAR_LOCAL_FAULT_STATUS |\r\nXMAC_CLEAR_RX_LSS_STATUS_REG_CLEAR_REMOTE_FAULT_STATUS);\r\n}\r\nREG_WR(bp, xmac_base + XMAC_REG_RX_MAX_SIZE, 0x2710);\r\nREG_WR(bp, xmac_base + XMAC_REG_TX_CTRL, 0xC800);\r\nbnx2x_update_pfc_xmac(params, vars, 0);\r\nif (vars->eee_status & SHMEM_EEE_ADV_STATUS_MASK) {\r\nDP(NETIF_MSG_LINK, "Setting XMAC for EEE\n");\r\nREG_WR(bp, xmac_base + XMAC_REG_EEE_TIMERS_HI, 0x1380008);\r\nREG_WR(bp, xmac_base + XMAC_REG_EEE_CTRL, 0x1);\r\n} else {\r\nREG_WR(bp, xmac_base + XMAC_REG_EEE_CTRL, 0x0);\r\n}\r\nval = XMAC_CTRL_REG_TX_EN | XMAC_CTRL_REG_RX_EN;\r\nif ((vars->line_speed == SPEED_20000) &&\r\n(params->phy[INT_PHY].supported &\r\nSUPPORTED_20000baseKR2_Full))\r\nval |= XMAC_CTRL_REG_XLGMII_ALIGN_ENB;\r\nif (lb)\r\nval |= XMAC_CTRL_REG_LINE_LOCAL_LPBK;\r\nREG_WR(bp, xmac_base + XMAC_REG_CTRL, val);\r\nbnx2x_set_xumac_nig(params,\r\n((vars->flow_ctrl & BNX2X_FLOW_CTRL_TX) != 0), 1);\r\nvars->mac_type = MAC_TYPE_XMAC;\r\nreturn 0;\r\n}\r\nstatic int bnx2x_emac_enable(struct link_params *params,\r\nstruct link_vars *vars, u8 lb)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 port = params->port;\r\nu32 emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;\r\nu32 val;\r\nDP(NETIF_MSG_LINK, "enabling EMAC\n");\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\r\n(MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port));\r\nREG_WR(bp, NIG_REG_EGRESS_EMAC0_PORT + port*4, 1);\r\nif (vars->phy_flags & PHY_XGXS_FLAG) {\r\nu32 ser_lane = ((params->lane_config &\r\nPORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK) >>\r\nPORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT);\r\nDP(NETIF_MSG_LINK, "XGXS\n");\r\nREG_WR(bp, NIG_REG_XGXS_LANE_SEL_P0 + port*4, ser_lane);\r\nREG_WR(bp, NIG_REG_XGXS_SERDES0_MODE_SEL + port*4, 1);\r\n} else {\r\nDP(NETIF_MSG_LINK, "SerDes\n");\r\nREG_WR(bp, NIG_REG_XGXS_SERDES0_MODE_SEL + port*4, 0);\r\n}\r\nbnx2x_bits_en(bp, emac_base + EMAC_REG_EMAC_RX_MODE,\r\nEMAC_RX_MODE_RESET);\r\nbnx2x_bits_en(bp, emac_base + EMAC_REG_EMAC_TX_MODE,\r\nEMAC_TX_MODE_RESET);\r\nbnx2x_bits_dis(bp, emac_base + EMAC_REG_EMAC_RX_MODE,\r\nEMAC_RX_MODE_FLOW_EN);\r\nbnx2x_bits_dis(bp, emac_base + EMAC_REG_EMAC_TX_MODE,\r\n(EMAC_TX_MODE_EXT_PAUSE_EN |\r\nEMAC_TX_MODE_FLOW_EN));\r\nif (!(params->feature_config_flags &\r\nFEATURE_CONFIG_PFC_ENABLED)) {\r\nif (vars->flow_ctrl & BNX2X_FLOW_CTRL_RX)\r\nbnx2x_bits_en(bp, emac_base +\r\nEMAC_REG_EMAC_RX_MODE,\r\nEMAC_RX_MODE_FLOW_EN);\r\nif (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX)\r\nbnx2x_bits_en(bp, emac_base +\r\nEMAC_REG_EMAC_TX_MODE,\r\n(EMAC_TX_MODE_EXT_PAUSE_EN |\r\nEMAC_TX_MODE_FLOW_EN));\r\n} else\r\nbnx2x_bits_en(bp, emac_base + EMAC_REG_EMAC_TX_MODE,\r\nEMAC_TX_MODE_FLOW_EN);\r\nval = REG_RD(bp, emac_base + EMAC_REG_EMAC_RX_MODE);\r\nval |= EMAC_RX_MODE_KEEP_VLAN_TAG | EMAC_RX_MODE_PROMISCUOUS;\r\nEMAC_WR(bp, EMAC_REG_RX_PFC_MODE, 0);\r\nif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED) {\r\nDP(NETIF_MSG_LINK, "PFC is enabled\n");\r\nEMAC_WR(bp, EMAC_REG_RX_PFC_MODE,\r\nEMAC_REG_RX_PFC_MODE_RX_EN |\r\nEMAC_REG_RX_PFC_MODE_TX_EN |\r\nEMAC_REG_RX_PFC_MODE_PRIORITIES);\r\nEMAC_WR(bp, EMAC_REG_RX_PFC_PARAM,\r\n((0x0101 <<\r\nEMAC_REG_RX_PFC_PARAM_OPCODE_BITSHIFT) |\r\n(0x00ff <<\r\nEMAC_REG_RX_PFC_PARAM_PRIORITY_EN_BITSHIFT)));\r\nval |= EMAC_RX_MODE_KEEP_MAC_CONTROL;\r\n}\r\nEMAC_WR(bp, EMAC_REG_EMAC_RX_MODE, val);\r\nval = REG_RD(bp, emac_base + EMAC_REG_EMAC_MODE);\r\nif (lb)\r\nval |= 0x810;\r\nelse\r\nval &= ~0x810;\r\nEMAC_WR(bp, EMAC_REG_EMAC_MODE, val);\r\nREG_WR(bp, NIG_REG_NIG_EMAC0_EN + port*4, 1);\r\nEMAC_WR(bp, EMAC_REG_EMAC_RX_MTU_SIZE,\r\n(EMAC_RX_MTU_SIZE_JUMBO_ENA |\r\n(ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVREHEAD)));\r\nREG_WR(bp, NIG_REG_NIG_INGRESS_EMAC0_NO_CRC + port*4, 0x1);\r\nREG_WR(bp, NIG_REG_BMAC0_IN_EN + port*4, 0x0);\r\nREG_WR(bp, NIG_REG_BMAC0_PAUSE_OUT_EN + port*4, 0x0);\r\nREG_WR(bp, NIG_REG_BMAC0_OUT_EN + port*4, 0x0);\r\nREG_WR(bp, NIG_REG_EMAC0_IN_EN + port*4, 0x1);\r\nval = 0;\r\nif ((params->feature_config_flags &\r\nFEATURE_CONFIG_PFC_ENABLED) ||\r\n(vars->flow_ctrl & BNX2X_FLOW_CTRL_TX))\r\nval = 1;\r\nREG_WR(bp, NIG_REG_EMAC0_PAUSE_OUT_EN + port*4, val);\r\nREG_WR(bp, NIG_REG_EGRESS_EMAC0_OUT_EN + port*4, 0x1);\r\nREG_WR(bp, NIG_REG_BMAC0_REGS_OUT_EN + port*4, 0x0);\r\nvars->mac_type = MAC_TYPE_EMAC;\r\nreturn 0;\r\n}\r\nstatic void bnx2x_update_pfc_bmac1(struct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nu32 wb_data[2];\r\nstruct bnx2x *bp = params->bp;\r\nu32 bmac_addr = params->port ? NIG_REG_INGRESS_BMAC1_MEM :\r\nNIG_REG_INGRESS_BMAC0_MEM;\r\nu32 val = 0x14;\r\nif ((!(params->feature_config_flags &\r\nFEATURE_CONFIG_PFC_ENABLED)) &&\r\n(vars->flow_ctrl & BNX2X_FLOW_CTRL_RX))\r\nval |= (1<<5);\r\nwb_data[0] = val;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_RX_CONTROL, wb_data, 2);\r\nval = 0xc0;\r\nif (!(params->feature_config_flags &\r\nFEATURE_CONFIG_PFC_ENABLED) &&\r\n(vars->flow_ctrl & BNX2X_FLOW_CTRL_TX))\r\nval |= 0x800000;\r\nwb_data[0] = val;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_TX_CONTROL, wb_data, 2);\r\n}\r\nstatic void bnx2x_update_pfc_bmac2(struct link_params *params,\r\nstruct link_vars *vars,\r\nu8 is_lb)\r\n{\r\nu32 wb_data[2];\r\nstruct bnx2x *bp = params->bp;\r\nu32 bmac_addr = params->port ? NIG_REG_INGRESS_BMAC1_MEM :\r\nNIG_REG_INGRESS_BMAC0_MEM;\r\nu32 val = 0x14;\r\nif ((!(params->feature_config_flags &\r\nFEATURE_CONFIG_PFC_ENABLED)) &&\r\n(vars->flow_ctrl & BNX2X_FLOW_CTRL_RX))\r\nval |= (1<<5);\r\nwb_data[0] = val;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_RX_CONTROL, wb_data, 2);\r\nudelay(30);\r\nval = 0xc0;\r\nif (!(params->feature_config_flags &\r\nFEATURE_CONFIG_PFC_ENABLED) &&\r\n(vars->flow_ctrl & BNX2X_FLOW_CTRL_TX))\r\nval |= 0x800000;\r\nwb_data[0] = val;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_TX_CONTROL, wb_data, 2);\r\nif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED) {\r\nDP(NETIF_MSG_LINK, "PFC is enabled\n");\r\nwb_data[0] = 0x0;\r\nwb_data[0] |= (1<<0);\r\nwb_data[0] |= (1<<1);\r\nwb_data[0] |= (1<<2);\r\nwb_data[0] |= (1<<3);\r\nwb_data[0] |= (1<<5);\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_PFC_CONTROL,\r\nwb_data, 2);\r\nwb_data[0] &= ~(1<<2);\r\n} else {\r\nDP(NETIF_MSG_LINK, "PFC is disabled\n");\r\nwb_data[0] = 0x8;\r\nwb_data[1] = 0;\r\n}\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_PFC_CONTROL, wb_data, 2);\r\nval = 0x8000;\r\nif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED)\r\nval |= (1<<16);\r\nwb_data[0] = val;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_TX_PAUSE_CONTROL,\r\nwb_data, 2);\r\nval = 0x3;\r\nif (is_lb) {\r\nval |= 0x4;\r\nDP(NETIF_MSG_LINK, "enable bmac loopback\n");\r\n}\r\nif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED)\r\nval |= ((1<<6)|(1<<5));\r\nwb_data[0] = val;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_BMAC_CONTROL, wb_data, 2);\r\n}\r\nstatic int bnx2x_pfc_nig_rx_priority_mask(struct bnx2x *bp,\r\nu8 cos_entry,\r\nu32 priority_mask, u8 port)\r\n{\r\nu32 nig_reg_rx_priority_mask_add = 0;\r\nswitch (cos_entry) {\r\ncase 0:\r\nnig_reg_rx_priority_mask_add = (port) ?\r\nNIG_REG_P1_RX_COS0_PRIORITY_MASK :\r\nNIG_REG_P0_RX_COS0_PRIORITY_MASK;\r\nbreak;\r\ncase 1:\r\nnig_reg_rx_priority_mask_add = (port) ?\r\nNIG_REG_P1_RX_COS1_PRIORITY_MASK :\r\nNIG_REG_P0_RX_COS1_PRIORITY_MASK;\r\nbreak;\r\ncase 2:\r\nnig_reg_rx_priority_mask_add = (port) ?\r\nNIG_REG_P1_RX_COS2_PRIORITY_MASK :\r\nNIG_REG_P0_RX_COS2_PRIORITY_MASK;\r\nbreak;\r\ncase 3:\r\nif (port)\r\nreturn -EINVAL;\r\nnig_reg_rx_priority_mask_add = NIG_REG_P0_RX_COS3_PRIORITY_MASK;\r\nbreak;\r\ncase 4:\r\nif (port)\r\nreturn -EINVAL;\r\nnig_reg_rx_priority_mask_add = NIG_REG_P0_RX_COS4_PRIORITY_MASK;\r\nbreak;\r\ncase 5:\r\nif (port)\r\nreturn -EINVAL;\r\nnig_reg_rx_priority_mask_add = NIG_REG_P0_RX_COS5_PRIORITY_MASK;\r\nbreak;\r\n}\r\nREG_WR(bp, nig_reg_rx_priority_mask_add, priority_mask);\r\nreturn 0;\r\n}\r\nstatic void bnx2x_update_mng(struct link_params *params, u32 link_status)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nREG_WR(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\nport_mb[params->port].link_status), link_status);\r\n}\r\nstatic void bnx2x_update_link_attr(struct link_params *params, u32 link_attr)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nif (SHMEM2_HAS(bp, link_attr_sync))\r\nREG_WR(bp, params->shmem2_base +\r\noffsetof(struct shmem2_region,\r\nlink_attr_sync[params->port]), link_attr);\r\n}\r\nstatic void bnx2x_update_pfc_nig(struct link_params *params,\r\nstruct link_vars *vars,\r\nstruct bnx2x_nig_brb_pfc_port_params *nig_params)\r\n{\r\nu32 xcm_mask = 0, ppp_enable = 0, pause_enable = 0, llfc_out_en = 0;\r\nu32 llfc_enable = 0, xcm_out_en = 0, hwpfc_enable = 0;\r\nu32 pkt_priority_to_cos = 0;\r\nstruct bnx2x *bp = params->bp;\r\nu8 port = params->port;\r\nint set_pfc = params->feature_config_flags &\r\nFEATURE_CONFIG_PFC_ENABLED;\r\nDP(NETIF_MSG_LINK, "updating pfc nig parameters\n");\r\nxcm_mask = REG_RD(bp, port ? NIG_REG_LLH1_XCM_MASK :\r\nNIG_REG_LLH0_XCM_MASK);\r\nif (set_pfc) {\r\npause_enable = 0;\r\nllfc_out_en = 0;\r\nllfc_enable = 0;\r\nif (CHIP_IS_E3(bp))\r\nppp_enable = 0;\r\nelse\r\nppp_enable = 1;\r\nxcm_mask &= ~(port ? NIG_LLH1_XCM_MASK_REG_LLH1_XCM_MASK_BCN :\r\nNIG_LLH0_XCM_MASK_REG_LLH0_XCM_MASK_BCN);\r\nxcm_out_en = 0;\r\nhwpfc_enable = 1;\r\n} else {\r\nif (nig_params) {\r\nllfc_out_en = nig_params->llfc_out_en;\r\nllfc_enable = nig_params->llfc_enable;\r\npause_enable = nig_params->pause_enable;\r\n} else\r\npause_enable = 1;\r\nxcm_mask |= (port ? NIG_LLH1_XCM_MASK_REG_LLH1_XCM_MASK_BCN :\r\nNIG_LLH0_XCM_MASK_REG_LLH0_XCM_MASK_BCN);\r\nxcm_out_en = 1;\r\n}\r\nif (CHIP_IS_E3(bp))\r\nREG_WR(bp, port ? NIG_REG_BRB1_PAUSE_IN_EN :\r\nNIG_REG_BRB0_PAUSE_IN_EN, pause_enable);\r\nREG_WR(bp, port ? NIG_REG_LLFC_OUT_EN_1 :\r\nNIG_REG_LLFC_OUT_EN_0, llfc_out_en);\r\nREG_WR(bp, port ? NIG_REG_LLFC_ENABLE_1 :\r\nNIG_REG_LLFC_ENABLE_0, llfc_enable);\r\nREG_WR(bp, port ? NIG_REG_PAUSE_ENABLE_1 :\r\nNIG_REG_PAUSE_ENABLE_0, pause_enable);\r\nREG_WR(bp, port ? NIG_REG_PPP_ENABLE_1 :\r\nNIG_REG_PPP_ENABLE_0, ppp_enable);\r\nREG_WR(bp, port ? NIG_REG_LLH1_XCM_MASK :\r\nNIG_REG_LLH0_XCM_MASK, xcm_mask);\r\nREG_WR(bp, port ? NIG_REG_LLFC_EGRESS_SRC_ENABLE_1 :\r\nNIG_REG_LLFC_EGRESS_SRC_ENABLE_0, 0x7);\r\nREG_WR(bp, port ? NIG_REG_XCM1_OUT_EN :\r\nNIG_REG_XCM0_OUT_EN, xcm_out_en);\r\nREG_WR(bp, port ? NIG_REG_P1_HWPFC_ENABLE :\r\nNIG_REG_P0_HWPFC_ENABLE, hwpfc_enable);\r\nif (nig_params) {\r\nu8 i = 0;\r\npkt_priority_to_cos = nig_params->pkt_priority_to_cos;\r\nfor (i = 0; i < nig_params->num_of_rx_cos_priority_mask; i++)\r\nbnx2x_pfc_nig_rx_priority_mask(bp, i,\r\nnig_params->rx_cos_priority_mask[i], port);\r\nREG_WR(bp, port ? NIG_REG_LLFC_HIGH_PRIORITY_CLASSES_1 :\r\nNIG_REG_LLFC_HIGH_PRIORITY_CLASSES_0,\r\nnig_params->llfc_high_priority_classes);\r\nREG_WR(bp, port ? NIG_REG_LLFC_LOW_PRIORITY_CLASSES_1 :\r\nNIG_REG_LLFC_LOW_PRIORITY_CLASSES_0,\r\nnig_params->llfc_low_priority_classes);\r\n}\r\nREG_WR(bp, port ? NIG_REG_P1_PKT_PRIORITY_TO_COS :\r\nNIG_REG_P0_PKT_PRIORITY_TO_COS,\r\npkt_priority_to_cos);\r\n}\r\nint bnx2x_update_pfc(struct link_params *params,\r\nstruct link_vars *vars,\r\nstruct bnx2x_nig_brb_pfc_port_params *pfc_params)\r\n{\r\nu32 val;\r\nstruct bnx2x *bp = params->bp;\r\nu8 bmac_loopback = (params->loopback_mode == LOOPBACK_BMAC);\r\nif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED)\r\nvars->link_status |= LINK_STATUS_PFC_ENABLED;\r\nelse\r\nvars->link_status &= ~LINK_STATUS_PFC_ENABLED;\r\nbnx2x_update_mng(params, vars->link_status);\r\nbnx2x_update_pfc_nig(params, vars, pfc_params);\r\nif (!vars->link_up)\r\nreturn 0;\r\nDP(NETIF_MSG_LINK, "About to update PFC in BMAC\n");\r\nif (CHIP_IS_E3(bp)) {\r\nif (vars->mac_type == MAC_TYPE_XMAC)\r\nbnx2x_update_pfc_xmac(params, vars, 0);\r\n} else {\r\nval = REG_RD(bp, MISC_REG_RESET_REG_2);\r\nif ((val &\r\n(MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << params->port))\r\n== 0) {\r\nDP(NETIF_MSG_LINK, "About to update PFC in EMAC\n");\r\nbnx2x_emac_enable(params, vars, 0);\r\nreturn 0;\r\n}\r\nif (CHIP_IS_E2(bp))\r\nbnx2x_update_pfc_bmac2(params, vars, bmac_loopback);\r\nelse\r\nbnx2x_update_pfc_bmac1(params, vars);\r\nval = 0;\r\nif ((params->feature_config_flags &\r\nFEATURE_CONFIG_PFC_ENABLED) ||\r\n(vars->flow_ctrl & BNX2X_FLOW_CTRL_TX))\r\nval = 1;\r\nREG_WR(bp, NIG_REG_BMAC0_PAUSE_OUT_EN + params->port*4, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_bmac1_enable(struct link_params *params,\r\nstruct link_vars *vars,\r\nu8 is_lb)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 port = params->port;\r\nu32 bmac_addr = port ? NIG_REG_INGRESS_BMAC1_MEM :\r\nNIG_REG_INGRESS_BMAC0_MEM;\r\nu32 wb_data[2];\r\nu32 val;\r\nDP(NETIF_MSG_LINK, "Enabling BigMAC1\n");\r\nwb_data[0] = 0x3c;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_BMAC_XGXS_CONTROL,\r\nwb_data, 2);\r\nwb_data[0] = ((params->mac_addr[2] << 24) |\r\n(params->mac_addr[3] << 16) |\r\n(params->mac_addr[4] << 8) |\r\nparams->mac_addr[5]);\r\nwb_data[1] = ((params->mac_addr[0] << 8) |\r\nparams->mac_addr[1]);\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_TX_SOURCE_ADDR, wb_data, 2);\r\nval = 0x3;\r\nif (is_lb) {\r\nval |= 0x4;\r\nDP(NETIF_MSG_LINK, "enable bmac loopback\n");\r\n}\r\nwb_data[0] = val;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_BMAC_CONTROL, wb_data, 2);\r\nwb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVREHEAD;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_RX_MAX_SIZE, wb_data, 2);\r\nbnx2x_update_pfc_bmac1(params, vars);\r\nwb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVREHEAD;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_TX_MAX_SIZE, wb_data, 2);\r\nwb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVREHEAD;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_CNT_MAX_SIZE, wb_data, 2);\r\nwb_data[0] = 0x1000200;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_RX_LLFC_MSG_FLDS,\r\nwb_data, 2);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_bmac2_enable(struct link_params *params,\r\nstruct link_vars *vars,\r\nu8 is_lb)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 port = params->port;\r\nu32 bmac_addr = port ? NIG_REG_INGRESS_BMAC1_MEM :\r\nNIG_REG_INGRESS_BMAC0_MEM;\r\nu32 wb_data[2];\r\nDP(NETIF_MSG_LINK, "Enabling BigMAC2\n");\r\nwb_data[0] = 0;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_BMAC_CONTROL, wb_data, 2);\r\nudelay(30);\r\nwb_data[0] = 0x3c;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_BMAC_XGXS_CONTROL,\r\nwb_data, 2);\r\nudelay(30);\r\nwb_data[0] = ((params->mac_addr[2] << 24) |\r\n(params->mac_addr[3] << 16) |\r\n(params->mac_addr[4] << 8) |\r\nparams->mac_addr[5]);\r\nwb_data[1] = ((params->mac_addr[0] << 8) |\r\nparams->mac_addr[1]);\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_TX_SOURCE_ADDR,\r\nwb_data, 2);\r\nudelay(30);\r\nwb_data[0] = 0x1000200;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_RX_LLFC_MSG_FLDS,\r\nwb_data, 2);\r\nudelay(30);\r\nwb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVREHEAD;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_RX_MAX_SIZE, wb_data, 2);\r\nudelay(30);\r\nwb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVREHEAD;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_TX_MAX_SIZE, wb_data, 2);\r\nudelay(30);\r\nwb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVREHEAD - 2;\r\nwb_data[1] = 0;\r\nREG_WR_DMAE(bp, bmac_addr + BIGMAC2_REGISTER_CNT_MAX_SIZE, wb_data, 2);\r\nudelay(30);\r\nbnx2x_update_pfc_bmac2(params, vars, is_lb);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_bmac_enable(struct link_params *params,\r\nstruct link_vars *vars,\r\nu8 is_lb, u8 reset_bmac)\r\n{\r\nint rc = 0;\r\nu8 port = params->port;\r\nstruct bnx2x *bp = params->bp;\r\nu32 val;\r\nif (reset_bmac) {\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\r\n(MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port));\r\nusleep_range(1000, 2000);\r\n}\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,\r\n(MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port));\r\nREG_WR(bp, NIG_REG_BMAC0_REGS_OUT_EN + port*4, 0x1);\r\nif (CHIP_IS_E2(bp))\r\nrc = bnx2x_bmac2_enable(params, vars, is_lb);\r\nelse\r\nrc = bnx2x_bmac1_enable(params, vars, is_lb);\r\nREG_WR(bp, NIG_REG_XGXS_SERDES0_MODE_SEL + port*4, 0x1);\r\nREG_WR(bp, NIG_REG_XGXS_LANE_SEL_P0 + port*4, 0x0);\r\nREG_WR(bp, NIG_REG_EGRESS_EMAC0_PORT + port*4, 0x0);\r\nval = 0;\r\nif ((params->feature_config_flags &\r\nFEATURE_CONFIG_PFC_ENABLED) ||\r\n(vars->flow_ctrl & BNX2X_FLOW_CTRL_TX))\r\nval = 1;\r\nREG_WR(bp, NIG_REG_BMAC0_PAUSE_OUT_EN + port*4, val);\r\nREG_WR(bp, NIG_REG_EGRESS_EMAC0_OUT_EN + port*4, 0x0);\r\nREG_WR(bp, NIG_REG_EMAC0_IN_EN + port*4, 0x0);\r\nREG_WR(bp, NIG_REG_EMAC0_PAUSE_OUT_EN + port*4, 0x0);\r\nREG_WR(bp, NIG_REG_BMAC0_IN_EN + port*4, 0x1);\r\nREG_WR(bp, NIG_REG_BMAC0_OUT_EN + port*4, 0x1);\r\nvars->mac_type = MAC_TYPE_BMAC;\r\nreturn rc;\r\n}\r\nstatic void bnx2x_set_bmac_rx(struct bnx2x *bp, u32 chip_id, u8 port, u8 en)\r\n{\r\nu32 bmac_addr = port ? NIG_REG_INGRESS_BMAC1_MEM :\r\nNIG_REG_INGRESS_BMAC0_MEM;\r\nu32 wb_data[2];\r\nu32 nig_bmac_enable = REG_RD(bp, NIG_REG_BMAC0_REGS_OUT_EN + port*4);\r\nif (CHIP_IS_E2(bp))\r\nbmac_addr += BIGMAC2_REGISTER_BMAC_CONTROL;\r\nelse\r\nbmac_addr += BIGMAC_REGISTER_BMAC_CONTROL;\r\nif (REG_RD(bp, MISC_REG_RESET_REG_2) &\r\n(MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port) &&\r\nnig_bmac_enable) {\r\nREG_RD_DMAE(bp, bmac_addr, wb_data, 2);\r\nif (en)\r\nwb_data[0] |= BMAC_CONTROL_RX_ENABLE;\r\nelse\r\nwb_data[0] &= ~BMAC_CONTROL_RX_ENABLE;\r\nREG_WR_DMAE(bp, bmac_addr, wb_data, 2);\r\nusleep_range(1000, 2000);\r\n}\r\n}\r\nstatic int bnx2x_pbf_update(struct link_params *params, u32 flow_ctrl,\r\nu32 line_speed)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 port = params->port;\r\nu32 init_crd, crd;\r\nu32 count = 1000;\r\nREG_WR(bp, PBF_REG_DISABLE_NEW_TASK_PROC_P0 + port*4, 0x1);\r\ninit_crd = REG_RD(bp, PBF_REG_P0_INIT_CRD + port*4);\r\ncrd = REG_RD(bp, PBF_REG_P0_CREDIT + port*8);\r\nDP(NETIF_MSG_LINK, "init_crd 0x%x crd 0x%x\n", init_crd, crd);\r\nwhile ((init_crd != crd) && count) {\r\nusleep_range(5000, 10000);\r\ncrd = REG_RD(bp, PBF_REG_P0_CREDIT + port*8);\r\ncount--;\r\n}\r\ncrd = REG_RD(bp, PBF_REG_P0_CREDIT + port*8);\r\nif (init_crd != crd) {\r\nDP(NETIF_MSG_LINK, "BUG! init_crd 0x%x != crd 0x%x\n",\r\ninit_crd, crd);\r\nreturn -EINVAL;\r\n}\r\nif (flow_ctrl & BNX2X_FLOW_CTRL_RX ||\r\nline_speed == SPEED_10 ||\r\nline_speed == SPEED_100 ||\r\nline_speed == SPEED_1000 ||\r\nline_speed == SPEED_2500) {\r\nREG_WR(bp, PBF_REG_P0_PAUSE_ENABLE + port*4, 1);\r\nREG_WR(bp, PBF_REG_P0_ARB_THRSH + port*4, 0);\r\ninit_crd = 778;\r\n} else {\r\nu32 thresh = (ETH_MAX_JUMBO_PACKET_SIZE +\r\nETH_OVREHEAD)/16;\r\nREG_WR(bp, PBF_REG_P0_PAUSE_ENABLE + port*4, 0);\r\nREG_WR(bp, PBF_REG_P0_ARB_THRSH + port*4, thresh);\r\nswitch (line_speed) {\r\ncase SPEED_10000:\r\ninit_crd = thresh + 553 - 22;\r\nbreak;\r\ndefault:\r\nDP(NETIF_MSG_LINK, "Invalid line_speed 0x%x\n",\r\nline_speed);\r\nreturn -EINVAL;\r\n}\r\n}\r\nREG_WR(bp, PBF_REG_P0_INIT_CRD + port*4, init_crd);\r\nDP(NETIF_MSG_LINK, "PBF updated to speed %d credit %d\n",\r\nline_speed, init_crd);\r\nREG_WR(bp, PBF_REG_INIT_P0 + port*4, 0x1);\r\nusleep_range(5000, 10000);\r\nREG_WR(bp, PBF_REG_INIT_P0 + port*4, 0x0);\r\nREG_WR(bp, PBF_REG_DISABLE_NEW_TASK_PROC_P0 + port*4, 0x0);\r\nreturn 0;\r\n}\r\nstatic u32 bnx2x_get_emac_base(struct bnx2x *bp,\r\nu32 mdc_mdio_access, u8 port)\r\n{\r\nu32 emac_base = 0;\r\nswitch (mdc_mdio_access) {\r\ncase SHARED_HW_CFG_MDC_MDIO_ACCESS1_PHY_TYPE:\r\nbreak;\r\ncase SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC0:\r\nif (REG_RD(bp, NIG_REG_PORT_SWAP))\r\nemac_base = GRCBASE_EMAC1;\r\nelse\r\nemac_base = GRCBASE_EMAC0;\r\nbreak;\r\ncase SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC1:\r\nif (REG_RD(bp, NIG_REG_PORT_SWAP))\r\nemac_base = GRCBASE_EMAC0;\r\nelse\r\nemac_base = GRCBASE_EMAC1;\r\nbreak;\r\ncase SHARED_HW_CFG_MDC_MDIO_ACCESS1_BOTH:\r\nemac_base = (port) ? GRCBASE_EMAC1 : GRCBASE_EMAC0;\r\nbreak;\r\ncase SHARED_HW_CFG_MDC_MDIO_ACCESS1_SWAPPED:\r\nemac_base = (port) ? GRCBASE_EMAC0 : GRCBASE_EMAC1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn emac_base;\r\n}\r\nstatic int bnx2x_cl22_write(struct bnx2x *bp,\r\nstruct bnx2x_phy *phy,\r\nu16 reg, u16 val)\r\n{\r\nu32 tmp, mode;\r\nu8 i;\r\nint rc = 0;\r\nmode = REG_RD(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE);\r\nREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE,\r\nmode & ~EMAC_MDIO_MODE_CLAUSE_45);\r\ntmp = ((phy->addr << 21) | (reg << 16) | val |\r\nEMAC_MDIO_COMM_COMMAND_WRITE_22 |\r\nEMAC_MDIO_COMM_START_BUSY);\r\nREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, tmp);\r\nfor (i = 0; i < 50; i++) {\r\nudelay(10);\r\ntmp = REG_RD(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM);\r\nif (!(tmp & EMAC_MDIO_COMM_START_BUSY)) {\r\nudelay(5);\r\nbreak;\r\n}\r\n}\r\nif (tmp & EMAC_MDIO_COMM_START_BUSY) {\r\nDP(NETIF_MSG_LINK, "write phy register failed\n");\r\nrc = -EFAULT;\r\n}\r\nREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE, mode);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_cl22_read(struct bnx2x *bp,\r\nstruct bnx2x_phy *phy,\r\nu16 reg, u16 *ret_val)\r\n{\r\nu32 val, mode;\r\nu16 i;\r\nint rc = 0;\r\nmode = REG_RD(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE);\r\nREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE,\r\nmode & ~EMAC_MDIO_MODE_CLAUSE_45);\r\nval = ((phy->addr << 21) | (reg << 16) |\r\nEMAC_MDIO_COMM_COMMAND_READ_22 |\r\nEMAC_MDIO_COMM_START_BUSY);\r\nREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, val);\r\nfor (i = 0; i < 50; i++) {\r\nudelay(10);\r\nval = REG_RD(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM);\r\nif (!(val & EMAC_MDIO_COMM_START_BUSY)) {\r\n*ret_val = (u16)(val & EMAC_MDIO_COMM_DATA);\r\nudelay(5);\r\nbreak;\r\n}\r\n}\r\nif (val & EMAC_MDIO_COMM_START_BUSY) {\r\nDP(NETIF_MSG_LINK, "read phy register failed\n");\r\n*ret_val = 0;\r\nrc = -EFAULT;\r\n}\r\nREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE, mode);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_cl45_read(struct bnx2x *bp, struct bnx2x_phy *phy,\r\nu8 devad, u16 reg, u16 *ret_val)\r\n{\r\nu32 val;\r\nu16 i;\r\nint rc = 0;\r\nu32 chip_id;\r\nif (phy->flags & FLAGS_MDC_MDIO_WA_G) {\r\nchip_id = (REG_RD(bp, MISC_REG_CHIP_NUM) << 16) |\r\n((REG_RD(bp, MISC_REG_CHIP_REV) & 0xf) << 12);\r\nbnx2x_set_mdio_clk(bp, chip_id, phy->mdio_ctrl);\r\n}\r\nif (phy->flags & FLAGS_MDC_MDIO_WA_B0)\r\nbnx2x_bits_en(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_STATUS,\r\nEMAC_MDIO_STATUS_10MB);\r\nval = ((phy->addr << 21) | (devad << 16) | reg |\r\nEMAC_MDIO_COMM_COMMAND_ADDRESS |\r\nEMAC_MDIO_COMM_START_BUSY);\r\nREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, val);\r\nfor (i = 0; i < 50; i++) {\r\nudelay(10);\r\nval = REG_RD(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM);\r\nif (!(val & EMAC_MDIO_COMM_START_BUSY)) {\r\nudelay(5);\r\nbreak;\r\n}\r\n}\r\nif (val & EMAC_MDIO_COMM_START_BUSY) {\r\nDP(NETIF_MSG_LINK, "read phy register failed\n");\r\nnetdev_err(bp->dev, "MDC/MDIO access timeout\n");\r\n*ret_val = 0;\r\nrc = -EFAULT;\r\n} else {\r\nval = ((phy->addr << 21) | (devad << 16) |\r\nEMAC_MDIO_COMM_COMMAND_READ_45 |\r\nEMAC_MDIO_COMM_START_BUSY);\r\nREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, val);\r\nfor (i = 0; i < 50; i++) {\r\nudelay(10);\r\nval = REG_RD(bp, phy->mdio_ctrl +\r\nEMAC_REG_EMAC_MDIO_COMM);\r\nif (!(val & EMAC_MDIO_COMM_START_BUSY)) {\r\n*ret_val = (u16)(val & EMAC_MDIO_COMM_DATA);\r\nbreak;\r\n}\r\n}\r\nif (val & EMAC_MDIO_COMM_START_BUSY) {\r\nDP(NETIF_MSG_LINK, "read phy register failed\n");\r\nnetdev_err(bp->dev, "MDC/MDIO access timeout\n");\r\n*ret_val = 0;\r\nrc = -EFAULT;\r\n}\r\n}\r\nif (phy->flags & FLAGS_MDC_MDIO_WA) {\r\nphy->flags ^= FLAGS_DUMMY_READ;\r\nif (phy->flags & FLAGS_DUMMY_READ) {\r\nu16 temp_val;\r\nbnx2x_cl45_read(bp, phy, devad, 0xf, &temp_val);\r\n}\r\n}\r\nif (phy->flags & FLAGS_MDC_MDIO_WA_B0)\r\nbnx2x_bits_dis(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_STATUS,\r\nEMAC_MDIO_STATUS_10MB);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_cl45_write(struct bnx2x *bp, struct bnx2x_phy *phy,\r\nu8 devad, u16 reg, u16 val)\r\n{\r\nu32 tmp;\r\nu8 i;\r\nint rc = 0;\r\nu32 chip_id;\r\nif (phy->flags & FLAGS_MDC_MDIO_WA_G) {\r\nchip_id = (REG_RD(bp, MISC_REG_CHIP_NUM) << 16) |\r\n((REG_RD(bp, MISC_REG_CHIP_REV) & 0xf) << 12);\r\nbnx2x_set_mdio_clk(bp, chip_id, phy->mdio_ctrl);\r\n}\r\nif (phy->flags & FLAGS_MDC_MDIO_WA_B0)\r\nbnx2x_bits_en(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_STATUS,\r\nEMAC_MDIO_STATUS_10MB);\r\ntmp = ((phy->addr << 21) | (devad << 16) | reg |\r\nEMAC_MDIO_COMM_COMMAND_ADDRESS |\r\nEMAC_MDIO_COMM_START_BUSY);\r\nREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, tmp);\r\nfor (i = 0; i < 50; i++) {\r\nudelay(10);\r\ntmp = REG_RD(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM);\r\nif (!(tmp & EMAC_MDIO_COMM_START_BUSY)) {\r\nudelay(5);\r\nbreak;\r\n}\r\n}\r\nif (tmp & EMAC_MDIO_COMM_START_BUSY) {\r\nDP(NETIF_MSG_LINK, "write phy register failed\n");\r\nnetdev_err(bp->dev, "MDC/MDIO access timeout\n");\r\nrc = -EFAULT;\r\n} else {\r\ntmp = ((phy->addr << 21) | (devad << 16) | val |\r\nEMAC_MDIO_COMM_COMMAND_WRITE_45 |\r\nEMAC_MDIO_COMM_START_BUSY);\r\nREG_WR(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, tmp);\r\nfor (i = 0; i < 50; i++) {\r\nudelay(10);\r\ntmp = REG_RD(bp, phy->mdio_ctrl +\r\nEMAC_REG_EMAC_MDIO_COMM);\r\nif (!(tmp & EMAC_MDIO_COMM_START_BUSY)) {\r\nudelay(5);\r\nbreak;\r\n}\r\n}\r\nif (tmp & EMAC_MDIO_COMM_START_BUSY) {\r\nDP(NETIF_MSG_LINK, "write phy register failed\n");\r\nnetdev_err(bp->dev, "MDC/MDIO access timeout\n");\r\nrc = -EFAULT;\r\n}\r\n}\r\nif (phy->flags & FLAGS_MDC_MDIO_WA) {\r\nphy->flags ^= FLAGS_DUMMY_READ;\r\nif (phy->flags & FLAGS_DUMMY_READ) {\r\nu16 temp_val;\r\nbnx2x_cl45_read(bp, phy, devad, 0xf, &temp_val);\r\n}\r\n}\r\nif (phy->flags & FLAGS_MDC_MDIO_WA_B0)\r\nbnx2x_bits_dis(bp, phy->mdio_ctrl + EMAC_REG_EMAC_MDIO_STATUS,\r\nEMAC_MDIO_STATUS_10MB);\r\nreturn rc;\r\n}\r\nstatic u8 bnx2x_eee_has_cap(struct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nif (REG_RD(bp, params->shmem2_base) <=\r\noffsetof(struct shmem2_region, eee_status[params->port]))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int bnx2x_eee_nvram_to_time(u32 nvram_mode, u32 *idle_timer)\r\n{\r\nswitch (nvram_mode) {\r\ncase PORT_FEAT_CFG_EEE_POWER_MODE_BALANCED:\r\n*idle_timer = EEE_MODE_NVRAM_BALANCED_TIME;\r\nbreak;\r\ncase PORT_FEAT_CFG_EEE_POWER_MODE_AGGRESSIVE:\r\n*idle_timer = EEE_MODE_NVRAM_AGGRESSIVE_TIME;\r\nbreak;\r\ncase PORT_FEAT_CFG_EEE_POWER_MODE_LOW_LATENCY:\r\n*idle_timer = EEE_MODE_NVRAM_LATENCY_TIME;\r\nbreak;\r\ndefault:\r\n*idle_timer = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_eee_time_to_nvram(u32 idle_timer, u32 *nvram_mode)\r\n{\r\nswitch (idle_timer) {\r\ncase EEE_MODE_NVRAM_BALANCED_TIME:\r\n*nvram_mode = PORT_FEAT_CFG_EEE_POWER_MODE_BALANCED;\r\nbreak;\r\ncase EEE_MODE_NVRAM_AGGRESSIVE_TIME:\r\n*nvram_mode = PORT_FEAT_CFG_EEE_POWER_MODE_AGGRESSIVE;\r\nbreak;\r\ncase EEE_MODE_NVRAM_LATENCY_TIME:\r\n*nvram_mode = PORT_FEAT_CFG_EEE_POWER_MODE_LOW_LATENCY;\r\nbreak;\r\ndefault:\r\n*nvram_mode = PORT_FEAT_CFG_EEE_POWER_MODE_DISABLED;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 bnx2x_eee_calc_timer(struct link_params *params)\r\n{\r\nu32 eee_mode, eee_idle;\r\nstruct bnx2x *bp = params->bp;\r\nif (params->eee_mode & EEE_MODE_OVERRIDE_NVRAM) {\r\nif (params->eee_mode & EEE_MODE_OUTPUT_TIME) {\r\neee_idle = params->eee_mode & EEE_MODE_TIMER_MASK;\r\n} else {\r\nif (bnx2x_eee_nvram_to_time(params->eee_mode &\r\nEEE_MODE_NVRAM_MASK,\r\n&eee_idle))\r\nreturn 0;\r\n}\r\n} else {\r\neee_mode = ((REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region, dev_info.\r\nport_feature_config[params->port].\r\neee_power_mode)) &\r\nPORT_FEAT_CFG_EEE_POWER_MODE_MASK) >>\r\nPORT_FEAT_CFG_EEE_POWER_MODE_SHIFT);\r\nif (bnx2x_eee_nvram_to_time(eee_mode, &eee_idle))\r\nreturn 0;\r\n}\r\nreturn eee_idle;\r\n}\r\nstatic int bnx2x_eee_set_timers(struct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nu32 eee_idle = 0, eee_mode;\r\nstruct bnx2x *bp = params->bp;\r\neee_idle = bnx2x_eee_calc_timer(params);\r\nif (eee_idle) {\r\nREG_WR(bp, MISC_REG_CPMU_LP_IDLE_THR_P0 + (params->port << 2),\r\neee_idle);\r\n} else if ((params->eee_mode & EEE_MODE_ENABLE_LPI) &&\r\n(params->eee_mode & EEE_MODE_OVERRIDE_NVRAM) &&\r\n(params->eee_mode & EEE_MODE_OUTPUT_TIME)) {\r\nDP(NETIF_MSG_LINK, "Error: Tx LPI is enabled with timer 0\n");\r\nreturn -EINVAL;\r\n}\r\nvars->eee_status &= ~(SHMEM_EEE_TIMER_MASK | SHMEM_EEE_TIME_OUTPUT_BIT);\r\nif (params->eee_mode & EEE_MODE_OUTPUT_TIME) {\r\neee_idle >>= 4;\r\nvars->eee_status |= (eee_idle & SHMEM_EEE_TIMER_MASK) |\r\nSHMEM_EEE_TIME_OUTPUT_BIT;\r\n} else {\r\nif (bnx2x_eee_time_to_nvram(eee_idle, &eee_mode))\r\nreturn -EINVAL;\r\nvars->eee_status |= eee_mode;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_eee_initial_config(struct link_params *params,\r\nstruct link_vars *vars, u8 mode)\r\n{\r\nvars->eee_status |= ((u32) mode) << SHMEM_EEE_SUPPORTED_SHIFT;\r\nif (params->eee_mode & EEE_MODE_ENABLE_LPI)\r\nvars->eee_status |= SHMEM_EEE_LPI_REQUESTED_BIT;\r\nelse\r\nvars->eee_status &= ~SHMEM_EEE_LPI_REQUESTED_BIT;\r\nif (params->eee_mode & EEE_MODE_ADV_LPI)\r\nvars->eee_status |= SHMEM_EEE_REQUESTED_BIT;\r\nelse\r\nvars->eee_status &= ~SHMEM_EEE_REQUESTED_BIT;\r\nreturn bnx2x_eee_set_timers(params, vars);\r\n}\r\nstatic int bnx2x_eee_disable(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nREG_WR(bp, MISC_REG_CPMU_LP_FW_ENABLE_P0 + (params->port << 2), 0);\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_EEE_ADV, 0x0);\r\nvars->eee_status &= ~SHMEM_EEE_ADV_STATUS_MASK;\r\nreturn 0;\r\n}\r\nstatic int bnx2x_eee_advertise(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars, u8 modes)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 val = 0;\r\nREG_WR(bp, MISC_REG_CPMU_LP_MASK_EXT_P0 + (params->port << 2), 0xfc20);\r\nif (modes & SHMEM_EEE_10G_ADV) {\r\nDP(NETIF_MSG_LINK, "Advertise 10GBase-T EEE\n");\r\nval |= 0x8;\r\n}\r\nif (modes & SHMEM_EEE_1G_ADV) {\r\nDP(NETIF_MSG_LINK, "Advertise 1GBase-T EEE\n");\r\nval |= 0x4;\r\n}\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_EEE_ADV, val);\r\nvars->eee_status &= ~SHMEM_EEE_ADV_STATUS_MASK;\r\nvars->eee_status |= (modes << SHMEM_EEE_ADV_STATUS_SHIFT);\r\nreturn 0;\r\n}\r\nstatic void bnx2x_update_mng_eee(struct link_params *params, u32 eee_status)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nif (bnx2x_eee_has_cap(params))\r\nREG_WR(bp, params->shmem2_base +\r\noffsetof(struct shmem2_region,\r\neee_status[params->port]), eee_status);\r\n}\r\nstatic void bnx2x_eee_an_resolve(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 adv = 0, lp = 0;\r\nu32 lp_adv = 0;\r\nu8 neg = 0;\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_EEE_ADV, &adv);\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_LP_EEE_ADV, &lp);\r\nif (lp & 0x2) {\r\nlp_adv |= SHMEM_EEE_100M_ADV;\r\nif (adv & 0x2) {\r\nif (vars->line_speed == SPEED_100)\r\nneg = 1;\r\nDP(NETIF_MSG_LINK, "EEE negotiated - 100M\n");\r\n}\r\n}\r\nif (lp & 0x14) {\r\nlp_adv |= SHMEM_EEE_1G_ADV;\r\nif (adv & 0x14) {\r\nif (vars->line_speed == SPEED_1000)\r\nneg = 1;\r\nDP(NETIF_MSG_LINK, "EEE negotiated - 1G\n");\r\n}\r\n}\r\nif (lp & 0x68) {\r\nlp_adv |= SHMEM_EEE_10G_ADV;\r\nif (adv & 0x68) {\r\nif (vars->line_speed == SPEED_10000)\r\nneg = 1;\r\nDP(NETIF_MSG_LINK, "EEE negotiated - 10G\n");\r\n}\r\n}\r\nvars->eee_status &= ~SHMEM_EEE_LP_ADV_STATUS_MASK;\r\nvars->eee_status |= (lp_adv << SHMEM_EEE_LP_ADV_STATUS_SHIFT);\r\nif (neg) {\r\nDP(NETIF_MSG_LINK, "EEE is active\n");\r\nvars->eee_status |= SHMEM_EEE_ACTIVE_BIT;\r\n}\r\n}\r\nstatic void bnx2x_bsc_module_sel(struct link_params *params)\r\n{\r\nint idx;\r\nu32 board_cfg, sfp_ctrl;\r\nu32 i2c_pins[I2C_SWITCH_WIDTH], i2c_val[I2C_SWITCH_WIDTH];\r\nstruct bnx2x *bp = params->bp;\r\nu8 port = params->port;\r\nboard_cfg = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.shared_hw_config.board));\r\ni2c_pins[I2C_BSC0] = board_cfg & SHARED_HW_CFG_E3_I2C_MUX0_MASK;\r\ni2c_pins[I2C_BSC1] = (board_cfg & SHARED_HW_CFG_E3_I2C_MUX1_MASK) >>\r\nSHARED_HW_CFG_E3_I2C_MUX1_SHIFT;\r\nsfp_ctrl = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[port].e3_cmn_pin_cfg));\r\ni2c_val[I2C_BSC0] = (sfp_ctrl & PORT_HW_CFG_E3_I2C_MUX0_MASK) > 0;\r\ni2c_val[I2C_BSC1] = (sfp_ctrl & PORT_HW_CFG_E3_I2C_MUX1_MASK) > 0;\r\nDP(NETIF_MSG_LINK, "Setting BSC switch\n");\r\nfor (idx = 0; idx < I2C_SWITCH_WIDTH; idx++)\r\nbnx2x_set_cfg_pin(bp, i2c_pins[idx], i2c_val[idx]);\r\n}\r\nstatic int bnx2x_bsc_read(struct link_params *params,\r\nstruct bnx2x *bp,\r\nu8 sl_devid,\r\nu16 sl_addr,\r\nu8 lc_addr,\r\nu8 xfer_cnt,\r\nu32 *data_array)\r\n{\r\nu32 val, i;\r\nint rc = 0;\r\nif (xfer_cnt > 16) {\r\nDP(NETIF_MSG_LINK, "invalid xfer_cnt %d. Max is 16 bytes\n",\r\nxfer_cnt);\r\nreturn -EINVAL;\r\n}\r\nbnx2x_bsc_module_sel(params);\r\nxfer_cnt = 16 - lc_addr;\r\nval = REG_RD(bp, MCP_REG_MCPR_IMC_COMMAND);\r\nval |= MCPR_IMC_COMMAND_ENABLE;\r\nREG_WR(bp, MCP_REG_MCPR_IMC_COMMAND, val);\r\nval = (sl_devid << 16) | sl_addr;\r\nREG_WR(bp, MCP_REG_MCPR_IMC_SLAVE_CONTROL, val);\r\nval = (MCPR_IMC_COMMAND_ENABLE) |\r\n(MCPR_IMC_COMMAND_WRITE_OP <<\r\nMCPR_IMC_COMMAND_OPERATION_BITSHIFT) |\r\n(lc_addr << MCPR_IMC_COMMAND_TRANSFER_ADDRESS_BITSHIFT) | (0);\r\nREG_WR(bp, MCP_REG_MCPR_IMC_COMMAND, val);\r\ni = 0;\r\nval = REG_RD(bp, MCP_REG_MCPR_IMC_COMMAND);\r\nwhile (((val >> MCPR_IMC_COMMAND_IMC_STATUS_BITSHIFT) & 0x3) != 1) {\r\nudelay(10);\r\nval = REG_RD(bp, MCP_REG_MCPR_IMC_COMMAND);\r\nif (i++ > 1000) {\r\nDP(NETIF_MSG_LINK, "wr 0 byte timed out after %d try\n",\r\ni);\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\n}\r\nif (rc == -EFAULT)\r\nreturn rc;\r\nval = (MCPR_IMC_COMMAND_ENABLE) |\r\n(MCPR_IMC_COMMAND_READ_OP <<\r\nMCPR_IMC_COMMAND_OPERATION_BITSHIFT) |\r\n(lc_addr << MCPR_IMC_COMMAND_TRANSFER_ADDRESS_BITSHIFT) |\r\n(xfer_cnt);\r\nREG_WR(bp, MCP_REG_MCPR_IMC_COMMAND, val);\r\ni = 0;\r\nval = REG_RD(bp, MCP_REG_MCPR_IMC_COMMAND);\r\nwhile (((val >> MCPR_IMC_COMMAND_IMC_STATUS_BITSHIFT) & 0x3) != 1) {\r\nudelay(10);\r\nval = REG_RD(bp, MCP_REG_MCPR_IMC_COMMAND);\r\nif (i++ > 1000) {\r\nDP(NETIF_MSG_LINK, "rd op timed out after %d try\n", i);\r\nrc = -EFAULT;\r\nbreak;\r\n}\r\n}\r\nif (rc == -EFAULT)\r\nreturn rc;\r\nfor (i = (lc_addr >> 2); i < 4; i++) {\r\ndata_array[i] = REG_RD(bp, (MCP_REG_MCPR_IMC_DATAREG0 + i*4));\r\n#ifdef __BIG_ENDIAN\r\ndata_array[i] = ((data_array[i] & 0x000000ff) << 24) |\r\n((data_array[i] & 0x0000ff00) << 8) |\r\n((data_array[i] & 0x00ff0000) >> 8) |\r\n((data_array[i] & 0xff000000) >> 24);\r\n#endif\r\n}\r\nreturn rc;\r\n}\r\nstatic void bnx2x_cl45_read_or_write(struct bnx2x *bp, struct bnx2x_phy *phy,\r\nu8 devad, u16 reg, u16 or_val)\r\n{\r\nu16 val;\r\nbnx2x_cl45_read(bp, phy, devad, reg, &val);\r\nbnx2x_cl45_write(bp, phy, devad, reg, val | or_val);\r\n}\r\nstatic void bnx2x_cl45_read_and_write(struct bnx2x *bp,\r\nstruct bnx2x_phy *phy,\r\nu8 devad, u16 reg, u16 and_val)\r\n{\r\nu16 val;\r\nbnx2x_cl45_read(bp, phy, devad, reg, &val);\r\nbnx2x_cl45_write(bp, phy, devad, reg, val & and_val);\r\n}\r\nint bnx2x_phy_read(struct link_params *params, u8 phy_addr,\r\nu8 devad, u16 reg, u16 *ret_val)\r\n{\r\nu8 phy_index;\r\nfor (phy_index = 0; phy_index < params->num_phys; phy_index++) {\r\nif (params->phy[phy_index].addr == phy_addr) {\r\nreturn bnx2x_cl45_read(params->bp,\r\n&params->phy[phy_index], devad,\r\nreg, ret_val);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nint bnx2x_phy_write(struct link_params *params, u8 phy_addr,\r\nu8 devad, u16 reg, u16 val)\r\n{\r\nu8 phy_index;\r\nfor (phy_index = 0; phy_index < params->num_phys; phy_index++) {\r\nif (params->phy[phy_index].addr == phy_addr) {\r\nreturn bnx2x_cl45_write(params->bp,\r\n&params->phy[phy_index], devad,\r\nreg, val);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic u8 bnx2x_get_warpcore_lane(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nu8 lane = 0;\r\nstruct bnx2x *bp = params->bp;\r\nu32 path_swap, path_swap_ovr;\r\nu8 path, port;\r\npath = BP_PATH(bp);\r\nport = params->port;\r\nif (bnx2x_is_4_port_mode(bp)) {\r\nu32 port_swap, port_swap_ovr;\r\npath_swap_ovr = REG_RD(bp, MISC_REG_FOUR_PORT_PATH_SWAP_OVWR);\r\nif (path_swap_ovr & 0x1)\r\npath_swap = (path_swap_ovr & 0x2);\r\nelse\r\npath_swap = REG_RD(bp, MISC_REG_FOUR_PORT_PATH_SWAP);\r\nif (path_swap)\r\npath = path ^ 1;\r\nport_swap_ovr = REG_RD(bp, MISC_REG_FOUR_PORT_PORT_SWAP_OVWR);\r\nif (port_swap_ovr & 0x1)\r\nport_swap = (port_swap_ovr & 0x2);\r\nelse\r\nport_swap = REG_RD(bp, MISC_REG_FOUR_PORT_PORT_SWAP);\r\nif (port_swap)\r\nport = port ^ 1;\r\nlane = (port<<1) + path;\r\n} else {\r\npath_swap_ovr =\r\nREG_RD(bp, MISC_REG_TWO_PORT_PATH_SWAP_OVWR);\r\nif (path_swap_ovr & 0x1) {\r\npath_swap = (path_swap_ovr & 0x2);\r\n} else {\r\npath_swap =\r\nREG_RD(bp, MISC_REG_TWO_PORT_PATH_SWAP);\r\n}\r\nif (path_swap)\r\npath = path ^ 1;\r\nlane = path << 1 ;\r\n}\r\nreturn lane;\r\n}\r\nstatic void bnx2x_set_aer_mmd(struct link_params *params,\r\nstruct bnx2x_phy *phy)\r\n{\r\nu32 ser_lane;\r\nu16 offset, aer_val;\r\nstruct bnx2x *bp = params->bp;\r\nser_lane = ((params->lane_config &\r\nPORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK) >>\r\nPORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT);\r\noffset = (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) ?\r\n(phy->addr + ser_lane) : 0;\r\nif (USES_WARPCORE(bp)) {\r\naer_val = bnx2x_get_warpcore_lane(phy, params);\r\nif (phy->flags & FLAGS_WC_DUAL_MODE)\r\naer_val = (aer_val >> 1) | 0x200;\r\n} else if (CHIP_IS_E2(bp))\r\naer_val = 0x3800 + offset - 1;\r\nelse\r\naer_val = 0x3800 + offset;\r\nCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\r\nMDIO_AER_BLOCK_AER_REG, aer_val);\r\n}\r\nstatic void bnx2x_set_serdes_access(struct bnx2x *bp, u8 port)\r\n{\r\nu32 emac_base = (port) ? GRCBASE_EMAC1 : GRCBASE_EMAC0;\r\nREG_WR(bp, NIG_REG_SERDES0_CTRL_MD_ST + port*0x10, 1);\r\nREG_WR(bp, emac_base + EMAC_REG_EMAC_MDIO_COMM, 0x245f8000);\r\nudelay(500);\r\nREG_WR(bp, emac_base + EMAC_REG_EMAC_MDIO_COMM, 0x245d000f);\r\nudelay(500);\r\nREG_WR(bp, NIG_REG_SERDES0_CTRL_MD_ST + port*0x10, 0);\r\n}\r\nstatic void bnx2x_serdes_deassert(struct bnx2x *bp, u8 port)\r\n{\r\nu32 val;\r\nDP(NETIF_MSG_LINK, "bnx2x_serdes_deassert\n");\r\nval = SERDES_RESET_BITS << (port*16);\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_3_CLEAR, val);\r\nudelay(500);\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_3_SET, val);\r\nbnx2x_set_serdes_access(bp, port);\r\nREG_WR(bp, NIG_REG_SERDES0_CTRL_MD_DEVAD + port*0x10,\r\nDEFAULT_PHY_DEV_ADDR);\r\n}\r\nstatic void bnx2x_xgxs_specific_func(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nu32 action)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nswitch (action) {\r\ncase PHY_INIT:\r\nREG_WR(bp, NIG_REG_XGXS0_CTRL_MD_ST + params->port*0x18, 0);\r\nREG_WR(bp, NIG_REG_XGXS0_CTRL_MD_DEVAD + params->port*0x18,\r\nphy->def_md_devad);\r\nbreak;\r\n}\r\n}\r\nstatic void bnx2x_xgxs_deassert(struct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 port;\r\nu32 val;\r\nDP(NETIF_MSG_LINK, "bnx2x_xgxs_deassert\n");\r\nport = params->port;\r\nval = XGXS_RESET_BITS << (port*16);\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_3_CLEAR, val);\r\nudelay(500);\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_3_SET, val);\r\nbnx2x_xgxs_specific_func(&params->phy[INT_PHY], params,\r\nPHY_INIT);\r\n}\r\nstatic void bnx2x_calc_ieee_aneg_adv(struct bnx2x_phy *phy,\r\nstruct link_params *params, u16 *ieee_fc)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\n*ieee_fc = MDIO_COMBO_IEEE0_AUTO_NEG_ADV_FULL_DUPLEX;\r\nswitch (phy->req_flow_ctrl) {\r\ncase BNX2X_FLOW_CTRL_AUTO:\r\nswitch (params->req_fc_auto_adv) {\r\ncase BNX2X_FLOW_CTRL_BOTH:\r\n*ieee_fc |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH;\r\nbreak;\r\ncase BNX2X_FLOW_CTRL_RX:\r\ncase BNX2X_FLOW_CTRL_TX:\r\n*ieee_fc |=\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase BNX2X_FLOW_CTRL_TX:\r\n*ieee_fc |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC;\r\nbreak;\r\ncase BNX2X_FLOW_CTRL_RX:\r\ncase BNX2X_FLOW_CTRL_BOTH:\r\n*ieee_fc |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH;\r\nbreak;\r\ncase BNX2X_FLOW_CTRL_NONE:\r\ndefault:\r\n*ieee_fc |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_NONE;\r\nbreak;\r\n}\r\nDP(NETIF_MSG_LINK, "ieee_fc = 0x%x\n", *ieee_fc);\r\n}\r\nstatic void set_phy_vars(struct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 actual_phy_idx, phy_index, link_cfg_idx;\r\nu8 phy_config_swapped = params->multi_phy_config &\r\nPORT_HW_CFG_PHY_SWAPPED_ENABLED;\r\nfor (phy_index = INT_PHY; phy_index < params->num_phys;\r\nphy_index++) {\r\nlink_cfg_idx = LINK_CONFIG_IDX(phy_index);\r\nactual_phy_idx = phy_index;\r\nif (phy_config_swapped) {\r\nif (phy_index == EXT_PHY1)\r\nactual_phy_idx = EXT_PHY2;\r\nelse if (phy_index == EXT_PHY2)\r\nactual_phy_idx = EXT_PHY1;\r\n}\r\nparams->phy[actual_phy_idx].req_flow_ctrl =\r\nparams->req_flow_ctrl[link_cfg_idx];\r\nparams->phy[actual_phy_idx].req_line_speed =\r\nparams->req_line_speed[link_cfg_idx];\r\nparams->phy[actual_phy_idx].speed_cap_mask =\r\nparams->speed_cap_mask[link_cfg_idx];\r\nparams->phy[actual_phy_idx].req_duplex =\r\nparams->req_duplex[link_cfg_idx];\r\nif (params->req_line_speed[link_cfg_idx] ==\r\nSPEED_AUTO_NEG)\r\nvars->link_status |= LINK_STATUS_AUTO_NEGOTIATE_ENABLED;\r\nDP(NETIF_MSG_LINK, "req_flow_ctrl %x, req_line_speed %x,"\r\n" speed_cap_mask %x\n",\r\nparams->phy[actual_phy_idx].req_flow_ctrl,\r\nparams->phy[actual_phy_idx].req_line_speed,\r\nparams->phy[actual_phy_idx].speed_cap_mask);\r\n}\r\n}\r\nstatic void bnx2x_ext_phy_set_pause(struct link_params *params,\r\nstruct bnx2x_phy *phy,\r\nstruct link_vars *vars)\r\n{\r\nu16 val;\r\nstruct bnx2x *bp = params->bp;\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_ADV_PAUSE, &val);\r\nval &= ~MDIO_AN_REG_ADV_PAUSE_BOTH;\r\nbnx2x_calc_ieee_aneg_adv(phy, params, &vars->ieee_fc);\r\nif ((vars->ieee_fc &\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) ==\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) {\r\nval |= MDIO_AN_REG_ADV_PAUSE_ASYMMETRIC;\r\n}\r\nif ((vars->ieee_fc &\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) ==\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) {\r\nval |= MDIO_AN_REG_ADV_PAUSE_PAUSE;\r\n}\r\nDP(NETIF_MSG_LINK, "Ext phy AN advertize 0x%x\n", val);\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_ADV_PAUSE, val);\r\n}\r\nstatic void bnx2x_pause_resolve(struct link_vars *vars, u32 pause_result)\r\n{\r\nswitch (pause_result) {\r\ncase 0xb:\r\nvars->flow_ctrl = BNX2X_FLOW_CTRL_TX;\r\nbreak;\r\ncase 0xe:\r\nvars->flow_ctrl = BNX2X_FLOW_CTRL_RX;\r\nbreak;\r\ncase 0x5:\r\ncase 0x7:\r\ncase 0xd:\r\ncase 0xf:\r\nvars->flow_ctrl = BNX2X_FLOW_CTRL_BOTH;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (pause_result & (1<<0))\r\nvars->link_status |= LINK_STATUS_LINK_PARTNER_SYMMETRIC_PAUSE;\r\nif (pause_result & (1<<1))\r\nvars->link_status |= LINK_STATUS_LINK_PARTNER_ASYMMETRIC_PAUSE;\r\n}\r\nstatic void bnx2x_ext_phy_update_adv_fc(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nu16 ld_pause;\r\nu16 lp_pause;\r\nu16 pause_result;\r\nstruct bnx2x *bp = params->bp;\r\nif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE) {\r\nbnx2x_cl22_read(bp, phy, 0x4, &ld_pause);\r\nbnx2x_cl22_read(bp, phy, 0x5, &lp_pause);\r\n} else if (CHIP_IS_E3(bp) &&\r\nSINGLE_MEDIA_DIRECT(params)) {\r\nu8 lane = bnx2x_get_warpcore_lane(phy, params);\r\nu16 gp_status, gp_mask;\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_WC_REG_GP2_STATUS_GP_2_4,\r\n&gp_status);\r\ngp_mask = (MDIO_WC_REG_GP2_STATUS_GP_2_4_CL73_AN_CMPL |\r\nMDIO_WC_REG_GP2_STATUS_GP_2_4_CL37_LP_AN_CAP) <<\r\nlane;\r\nif ((gp_status & gp_mask) == gp_mask) {\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_AN_REG_ADV_PAUSE, &ld_pause);\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_AN_REG_LP_AUTO_NEG, &lp_pause);\r\n} else {\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_AN_REG_CL37_FC_LD, &ld_pause);\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_AN_REG_CL37_FC_LP, &lp_pause);\r\nld_pause = ((ld_pause &\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH)\r\n<< 3);\r\nlp_pause = ((lp_pause &\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH)\r\n<< 3);\r\n}\r\n} else {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD,\r\nMDIO_AN_REG_ADV_PAUSE, &ld_pause);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD,\r\nMDIO_AN_REG_LP_AUTO_NEG, &lp_pause);\r\n}\r\npause_result = (ld_pause &\r\nMDIO_AN_REG_ADV_PAUSE_MASK) >> 8;\r\npause_result |= (lp_pause &\r\nMDIO_AN_REG_ADV_PAUSE_MASK) >> 10;\r\nDP(NETIF_MSG_LINK, "Ext PHY pause result 0x%x\n", pause_result);\r\nbnx2x_pause_resolve(vars, pause_result);\r\n}\r\nstatic u8 bnx2x_ext_phy_resolve_fc(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nu8 ret = 0;\r\nvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\r\nif (phy->req_flow_ctrl != BNX2X_FLOW_CTRL_AUTO) {\r\nif (phy->req_line_speed == SPEED_AUTO_NEG)\r\nbnx2x_ext_phy_update_adv_fc(phy, params, vars);\r\nvars->flow_ctrl = phy->req_flow_ctrl;\r\n} else if (phy->req_line_speed != SPEED_AUTO_NEG)\r\nvars->flow_ctrl = params->req_fc_auto_adv;\r\nelse if (vars->link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE) {\r\nret = 1;\r\nbnx2x_ext_phy_update_adv_fc(phy, params, vars);\r\n}\r\nreturn ret;\r\n}\r\nstatic void bnx2x_warpcore_enable_AN_KR2(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 i;\r\nstatic struct bnx2x_reg_set reg_set[] = {\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL5, 0xa157},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL7, 0xcbe2},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL6, 0x7537},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL9, 0xa157},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_RX_CTRL11, 0xcbe2},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_RX_CTRL10, 0x7537},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_USERB0_CTRL, 0x000a},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_BAM_CTRL1, 0x6400},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_BAM_CTRL3, 0x0620},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_BAM_CODE_FIELD, 0x0157},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_OUI1, 0x6464},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_OUI2, 0x3150},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_OUI3, 0x3150},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_LD_BAM_CODE, 0x0157},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_LD_UD_CODE, 0x0620}\r\n};\r\nDP(NETIF_MSG_LINK, "Enabling 20G-KR2\n");\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_CL49_USERB0_CTRL, (3<<6));\r\nfor (i = 0; i < ARRAY_SIZE(reg_set); i++)\r\nbnx2x_cl45_write(bp, phy, reg_set[i].devad, reg_set[i].reg,\r\nreg_set[i].val);\r\nparams->link_attr_sync |= LINK_ATTR_SYNC_KR2_ENABLE;\r\nbnx2x_update_link_attr(params, params->link_attr_sync);\r\n}\r\nstatic void bnx2x_disable_kr2(struct link_params *params,\r\nstruct link_vars *vars,\r\nstruct bnx2x_phy *phy)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nint i;\r\nstatic struct bnx2x_reg_set reg_set[] = {\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL5, 0x7690},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL7, 0xe647},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL6, 0xc4f0},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_TX_CTRL9, 0x7690},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_RX_CTRL11, 0xe647},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL82_USERB1_RX_CTRL10, 0xc4f0},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_USERB0_CTRL, 0x000c},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_BAM_CTRL1, 0x6000},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_BAM_CTRL3, 0x0000},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL73_BAM_CODE_FIELD, 0x0002},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_OUI1, 0x0000},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_OUI2, 0x0af7},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_OUI3, 0x0af7},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_LD_BAM_CODE, 0x0002},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_ETA_CL73_LD_UD_CODE, 0x0000}\r\n};\r\nDP(NETIF_MSG_LINK, "Disabling 20G-KR2\n");\r\nfor (i = 0; i < ARRAY_SIZE(reg_set); i++)\r\nbnx2x_cl45_write(bp, phy, reg_set[i].devad, reg_set[i].reg,\r\nreg_set[i].val);\r\nparams->link_attr_sync &= ~LINK_ATTR_SYNC_KR2_ENABLE;\r\nbnx2x_update_link_attr(params, params->link_attr_sync);\r\nvars->check_kr2_recovery_cnt = CHECK_KR2_RECOVERY_CNT;\r\n}\r\nstatic void bnx2x_warpcore_set_lpi_passthrough(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nDP(NETIF_MSG_LINK, "Configure WC for LPI pass through\n");\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_EEE_COMBO_CONTROL0, 0x7c);\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_DIGITAL4_MISC5, 0xc000);\r\n}\r\nstatic void bnx2x_warpcore_restart_AN_KR(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 lane = bnx2x_get_warpcore_lane(phy, params);\r\nCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\r\nMDIO_AER_BLOCK_AER_REG, lane);\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_WC_REG_IEEE0BLK_MIICNTL, 0x1200);\r\nbnx2x_set_aer_mmd(params, phy);\r\n}\r\nstatic void bnx2x_warpcore_enable_AN_KR(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars) {\r\nu16 lane, i, cl72_ctrl, an_adv = 0, val;\r\nu32 wc_lane_config;\r\nstruct bnx2x *bp = params->bp;\r\nstatic struct bnx2x_reg_set reg_set[] = {\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2, 0x7},\r\n{MDIO_PMA_DEVAD, MDIO_WC_REG_IEEE0BLK_AUTONEGNP, 0x0},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_RX66_CONTROL, 0x7415},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_MISC2, 0x6190},\r\n{MDIO_AN_DEVAD, MDIO_WC_REG_IEEE0BLK_MIICNTL, 0},\r\n{MDIO_PMA_DEVAD, MDIO_WC_REG_PMD_KR_CONTROL, 0x2},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL72_USERB0_CL72_TX_FIR_TAP, 0},\r\n};\r\nDP(NETIF_MSG_LINK, "Enable Auto Negotiation for KR\n");\r\nfor (i = 0; i < ARRAY_SIZE(reg_set); i++)\r\nbnx2x_cl45_write(bp, phy, reg_set[i].devad, reg_set[i].reg,\r\nreg_set[i].val);\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL, &cl72_ctrl);\r\ncl72_ctrl &= 0x08ff;\r\ncl72_ctrl |= 0x3800;\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL, cl72_ctrl);\r\nif (((vars->line_speed == SPEED_AUTO_NEG) &&\r\n(phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)) ||\r\n(vars->line_speed == SPEED_1000)) {\r\nu16 addr = MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2;\r\nan_adv |= (1<<5);\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD, addr, 0x1);\r\nDP(NETIF_MSG_LINK, "Advertize 1G\n");\r\n}\r\nif (((vars->line_speed == SPEED_AUTO_NEG) &&\r\n(phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)) ||\r\n(vars->line_speed == SPEED_10000)) {\r\nan_adv |= (1<<7);\r\nCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\r\nMDIO_AER_BLOCK_AER_REG, 0);\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_WC_REG_PAR_DET_10G_CTRL, 1);\r\nbnx2x_set_aer_mmd(params, phy);\r\nDP(NETIF_MSG_LINK, "Advertize 10G\n");\r\n}\r\nlane = bnx2x_get_warpcore_lane(phy, params);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_TX0_TX_DRIVER + 0x10*lane,\r\nWC_TX_DRIVER(0x02, 0x06, 0x09));\r\nif (phy->flags & FLAGS_WC_DUAL_MODE)\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_TX0_TX_DRIVER + 0x10*(lane+1),\r\nWC_TX_DRIVER(0x02, 0x06, 0x09));\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_CL72_USERB0_CL72_OS_DEF_CTRL,\r\n0x03f0);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_CL72_USERB0_CL72_2P5_DEF_CTRL,\r\n0x03f0);\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_WC_REG_AN_IEEE1BLK_AN_ADVERTISEMENT1, an_adv);\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_WC_REG_AN_IEEE1BLK_AN_ADVERTISEMENT2,\r\n(MDIO_WC_REG_AN_IEEE1BLK_AN_ADV2_FEC_ABILITY |\r\nMDIO_WC_REG_AN_IEEE1BLK_AN_ADV2_FEC_REQ));\r\nif (REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region, dev_info.\r\nport_hw_config[params->port].default_cfg)) &\r\nPORT_HW_CFG_ENABLE_BAM_ON_KR_ENABLED) {\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_DIGITAL6_MP5_NEXTPAGECTRL,\r\n1);\r\nDP(NETIF_MSG_LINK, "Enable CL37 BAM on KR\n");\r\n}\r\nbnx2x_ext_phy_set_pause(params, phy, vars);\r\nvars->rx_tx_asic_rst = MAX_KR_LINK_RETRY;\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_DIGITAL5_MISC7, 0x100);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_DIGITAL3_UP1, 0x1f);\r\nif (((phy->req_line_speed == SPEED_AUTO_NEG) &&\r\n(phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_20G)) ||\r\n(phy->req_line_speed == SPEED_20000)) {\r\nCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\r\nMDIO_AER_BLOCK_AER_REG, lane);\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_RX1_PCI_CTRL + (0x10*lane),\r\n(1<<11));\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_XGXS_X2_CONTROL3, 0x7);\r\nbnx2x_set_aer_mmd(params, phy);\r\nbnx2x_warpcore_enable_AN_KR2(phy, params, vars);\r\n} else {\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1, 0x10);\r\nwc_lane_config = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region, dev_info.\r\nshared_hw_config.wc_lane_config));\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_RX0_PCI_CTRL + (lane << 4), &val);\r\nval |= 1 << 11;\r\nif (wc_lane_config &\r\n(SHARED_HW_CFG_RX_LANE0_POL_FLIP_ENABLED << lane))\r\nval |= 3 << 2;\r\nelse\r\nval &= ~(3 << 2);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_RX0_PCI_CTRL + (lane << 4),\r\nval);\r\nbnx2x_disable_kr2(params, vars, phy);\r\n}\r\nbnx2x_warpcore_restart_AN_KR(phy, params);\r\n}\r\nstatic void bnx2x_warpcore_set_10G_KR(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 val16, i, lane;\r\nstatic struct bnx2x_reg_set reg_set[] = {\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2, 0x7},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL,\r\n0x3f00},\r\n{MDIO_AN_DEVAD, MDIO_WC_REG_AN_IEEE1BLK_AN_ADVERTISEMENT1, 0},\r\n{MDIO_AN_DEVAD, MDIO_WC_REG_IEEE0BLK_MIICNTL, 0x0},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_DIGITAL3_UP1, 0x1},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_DIGITAL5_MISC7, 0xa},\r\n{MDIO_PMA_DEVAD, MDIO_WC_REG_PMD_KR_CONTROL, 0x2}\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(reg_set); i++)\r\nbnx2x_cl45_write(bp, phy, reg_set[i].devad, reg_set[i].reg,\r\nreg_set[i].val);\r\nlane = bnx2x_get_warpcore_lane(phy, params);\r\nCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\r\nMDIO_AER_BLOCK_AER_REG, 0);\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_XGXSBLK1_LANECTRL0, &val16);\r\nval16 &= ~(0x0011 << lane);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_XGXSBLK1_LANECTRL0, val16);\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_XGXSBLK1_LANECTRL1, &val16);\r\nval16 |= (0x0303 << (lane << 1));\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_XGXSBLK1_LANECTRL1, val16);\r\nbnx2x_set_aer_mmd(params, phy);\r\nbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD,\r\nMDIO_WC_REG_IEEE0BLK_MIICNTL, 0x2040);\r\nbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD,\r\nMDIO_WC_REG_IEEE0BLK_AUTONEGNP, 0xB);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_SERDESDIGITAL_MISC2, 0x30);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_TX66_CONTROL, 0x9);\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_RX66_CONTROL, 0xF9);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_IEEE0BLK_MIICNTL, 0x4000);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_IEEE0BLK_MIICNTL, 0x0);\r\n}\r\nstatic void bnx2x_warpcore_set_10G_XFI(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nu8 is_xfi)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 misc1_val, tap_val, tx_driver_val, lane, val;\r\nu32 cfg_tap_val, tx_drv_brdct, tx_equal;\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_DSC2B0_DSC_MISC_CTRL0, 0x8000);\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X3, 0x1);\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0);\r\nbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_FX100_CTRL1, 0xFFFA);\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_FX100_CTRL3, 0x0080);\r\nbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_DIGITAL4_MISC3, 0xFF7F);\r\nbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1,\r\n0xFFEE);\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2, &val);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2,\r\n((val | 0x0006) & 0xFFFE));\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_SERDESDIGITAL_MISC1, &misc1_val);\r\nmisc1_val &= ~(0x1f);\r\nif (is_xfi) {\r\nmisc1_val |= 0x5;\r\ntap_val = WC_TX_FIR(0x08, 0x37, 0x00);\r\ntx_driver_val = WC_TX_DRIVER(0x00, 0x02, 0x03);\r\n} else {\r\ncfg_tap_val = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region, dev_info.\r\nport_hw_config[params->port].\r\nsfi_tap_values));\r\ntx_equal = cfg_tap_val & PORT_HW_CFG_TX_EQUALIZATION_MASK;\r\ntx_drv_brdct = (cfg_tap_val &\r\nPORT_HW_CFG_TX_DRV_BROADCAST_MASK) >>\r\nPORT_HW_CFG_TX_DRV_BROADCAST_SHIFT;\r\nmisc1_val |= 0x9;\r\nif (tx_equal)\r\ntap_val = (u16)tx_equal;\r\nelse\r\ntap_val = WC_TX_FIR(0x0f, 0x2b, 0x02);\r\nif (tx_drv_brdct)\r\ntx_driver_val = WC_TX_DRIVER(0x03, (u16)tx_drv_brdct,\r\n0x06);\r\nelse\r\ntx_driver_val = WC_TX_DRIVER(0x03, 0x02, 0x06);\r\n}\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_SERDESDIGITAL_MISC1, misc1_val);\r\nlane = bnx2x_get_warpcore_lane(phy, params);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_TX_FIR_TAP,\r\ntap_val | MDIO_WC_REG_TX_FIR_TAP_ENABLE);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_TX0_TX_DRIVER + 0x10*lane,\r\ntx_driver_val);\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1, 0xd);\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_DIGITAL4_MISC3, 0x8080);\r\nbnx2x_warpcore_set_lpi_passthrough(phy, params);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_IEEE0BLK_MIICNTL, 0x100);\r\nbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X3,\r\n0xFFFE);\r\nbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_DSC2B0_DSC_MISC_CTRL0, 0x7FFF);\r\n}\r\nstatic void bnx2x_warpcore_set_20G_force_KR2(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nu16 val;\r\nstruct bnx2x *bp = params->bp;\r\nCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\r\nMDIO_AER_BLOCK_AER_REG, 0);\r\nbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_XGXSBLK0_XGXSCONTROL, ~(1<<13));\r\nbnx2x_set_aer_mmd(params, phy);\r\nbnx2x_cl45_read_and_write(bp, phy, MDIO_PMA_DEVAD,\r\nMDIO_WC_REG_PMD_KR_CONTROL, ~(1<<1));\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_AN_REG_CTRL, 0);\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_CL73_USERB0_CTRL, &val);\r\nval &= ~(1<<5);\r\nval |= (1<<6);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_CL73_USERB0_CTRL, val);\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_SERDESDIGITAL_MISC1, 0x1f);\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_DIGITAL4_MISC3, (1<<7));\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL, &val);\r\nval &= ~(3<<14);\r\nval |= (1<<15);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL, val);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_CL72_USERB0_CL72_TX_FIR_TAP, 0x835A);\r\nCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\r\nMDIO_AER_BLOCK_AER_REG, 0);\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_XGXSBLK0_XGXSCONTROL, (1<<13));\r\nbnx2x_set_aer_mmd(params, phy);\r\n}\r\nstatic void bnx2x_warpcore_set_20G_DXGXS(struct bnx2x *bp,\r\nstruct bnx2x_phy *phy,\r\nu16 lane)\r\n{\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_RX0_ANARXCONTROL1G, 0x90);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_RX2_ANARXCONTROL1G, 0x90);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_RX66_SCW0, 0xE070);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_RX66_SCW1, 0xC0D0);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_RX66_SCW2, 0xA0B0);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_RX66_SCW3, 0x8090);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_RX66_SCW0_MASK, 0xF0F0);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_RX66_SCW1_MASK, 0xF0F0);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_RX66_SCW2_MASK, 0xF0F0);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_RX66_SCW3_MASK, 0xF0F0);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_SERDESDIGITAL_MISC1, 0x6008);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_DIGITAL4_MISC3, 0x8088);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_TX_FIR_TAP,\r\n(WC_TX_FIR(0x12, 0x2d, 0x00) |\r\nMDIO_WC_REG_TX_FIR_TAP_ENABLE));\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_TX0_TX_DRIVER + 0x10*lane,\r\nWC_TX_DRIVER(0x02, 0x02, 0x02));\r\n}\r\nstatic void bnx2x_warpcore_set_sgmii_speed(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nu8 fiber_mode,\r\nu8 always_autoneg)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 val16, digctrl_kx1, digctrl_kx2;\r\nbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_RX66_CONTROL, ~(3<<13));\r\nbnx2x_warpcore_set_lpi_passthrough(phy, params);\r\nif (always_autoneg || phy->req_line_speed == SPEED_AUTO_NEG) {\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_COMBO_IEEE0_MIICTRL,\r\n0x1000);\r\nDP(NETIF_MSG_LINK, "set SGMII AUTONEG\n");\r\n} else {\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_COMBO_IEEE0_MIICTRL, &val16);\r\nval16 &= 0xcebf;\r\nswitch (phy->req_line_speed) {\r\ncase SPEED_10:\r\nbreak;\r\ncase SPEED_100:\r\nval16 |= 0x2000;\r\nbreak;\r\ncase SPEED_1000:\r\nval16 |= 0x0040;\r\nbreak;\r\ndefault:\r\nDP(NETIF_MSG_LINK,\r\n"Speed not supported: 0x%x\n", phy->req_line_speed);\r\nreturn;\r\n}\r\nif (phy->req_duplex == DUPLEX_FULL)\r\nval16 |= 0x0100;\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_COMBO_IEEE0_MIICTRL, val16);\r\nDP(NETIF_MSG_LINK, "set SGMII force speed %d\n",\r\nphy->req_line_speed);\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_COMBO_IEEE0_MIICTRL, &val16);\r\nDP(NETIF_MSG_LINK, " (readback) %x\n", val16);\r\n}\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1, &digctrl_kx1);\r\nif (fiber_mode)\r\ndigctrl_kx1 = 1;\r\nelse\r\ndigctrl_kx1 &= 0xff4a;\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1,\r\ndigctrl_kx1);\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2, &digctrl_kx2);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2,\r\n(digctrl_kx2 & ~(1<<2)));\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2,\r\n(digctrl_kx2 | (1<<2)));\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1,\r\n(digctrl_kx1 | 0x10));\r\n}\r\nstatic void bnx2x_warpcore_reset_lane(struct bnx2x *bp,\r\nstruct bnx2x_phy *phy,\r\nu8 reset)\r\n{\r\nu16 val;\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_DIGITAL5_MISC6, &val);\r\nif (reset)\r\nval |= 0xC000;\r\nelse\r\nval &= 0x3FFF;\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_DIGITAL5_MISC6, val);\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_DIGITAL5_MISC6, &val);\r\n}\r\nstatic void bnx2x_warpcore_clear_regs(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nu16 lane)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 i;\r\nstatic struct bnx2x_reg_set wc_regs[] = {\r\n{MDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_FX100_CTRL1, 0x014a},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_FX100_CTRL3, 0x0800},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_DIGITAL4_MISC3, 0x8008},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1,\r\n0x0195},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2,\r\n0x0007},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X3,\r\n0x0002},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_SERDESDIGITAL_MISC1, 0x6000},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_TX_FIR_TAP, 0x0000},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_IEEE0BLK_MIICNTL, 0x2040},\r\n{MDIO_WC_DEVAD, MDIO_WC_REG_COMBO_IEEE0_MIICTRL, 0x0140}\r\n};\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_RX66_CONTROL, (3<<13));\r\nfor (i = 0; i < ARRAY_SIZE(wc_regs); i++)\r\nbnx2x_cl45_write(bp, phy, wc_regs[i].devad, wc_regs[i].reg,\r\nwc_regs[i].val);\r\nlane = bnx2x_get_warpcore_lane(phy, params);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_TX0_TX_DRIVER + 0x10*lane, 0x0990);\r\n}\r\nstatic int bnx2x_get_mod_abs_int_cfg(struct bnx2x *bp,\r\nu32 chip_id,\r\nu32 shmem_base, u8 port,\r\nu8 *gpio_num, u8 *gpio_port)\r\n{\r\nu32 cfg_pin;\r\n*gpio_num = 0;\r\n*gpio_port = 0;\r\nif (CHIP_IS_E3(bp)) {\r\ncfg_pin = (REG_RD(bp, shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[port].e3_sfp_ctrl)) &\r\nPORT_HW_CFG_E3_MOD_ABS_MASK) >>\r\nPORT_HW_CFG_E3_MOD_ABS_SHIFT;\r\nif ((cfg_pin < PIN_CFG_GPIO0_P0) ||\r\n(cfg_pin > PIN_CFG_GPIO3_P1)) {\r\nDP(NETIF_MSG_LINK,\r\n"No cfg pin %x for module detect indication\n",\r\ncfg_pin);\r\nreturn -EINVAL;\r\n}\r\n*gpio_num = (cfg_pin - PIN_CFG_GPIO0_P0) & 0x3;\r\n*gpio_port = (cfg_pin - PIN_CFG_GPIO0_P0) >> 2;\r\n} else {\r\n*gpio_num = MISC_REGISTERS_GPIO_3;\r\n*gpio_port = port;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_is_sfp_module_plugged(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 gpio_num, gpio_port;\r\nu32 gpio_val;\r\nif (bnx2x_get_mod_abs_int_cfg(bp, params->chip_id,\r\nparams->shmem_base, params->port,\r\n&gpio_num, &gpio_port) != 0)\r\nreturn 0;\r\ngpio_val = bnx2x_get_gpio(bp, gpio_num, gpio_port);\r\nif (gpio_val == 0)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int bnx2x_warpcore_get_sigdet(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nu16 gp2_status_reg0, lane;\r\nstruct bnx2x *bp = params->bp;\r\nlane = bnx2x_get_warpcore_lane(phy, params);\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD, MDIO_WC_REG_GP2_STATUS_GP_2_0,\r\n&gp2_status_reg0);\r\nreturn (gp2_status_reg0 >> (8+lane)) & 0x1;\r\n}\r\nstatic void bnx2x_warpcore_config_runtime(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu32 serdes_net_if;\r\nu16 gp_status1 = 0, lnkup = 0, lnkup_kr = 0;\r\nvars->turn_to_run_wc_rt = vars->turn_to_run_wc_rt ? 0 : 1;\r\nif (!vars->turn_to_run_wc_rt)\r\nreturn;\r\nif (vars->rx_tx_asic_rst) {\r\nu16 lane = bnx2x_get_warpcore_lane(phy, params);\r\nserdes_net_if = (REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region, dev_info.\r\nport_hw_config[params->port].default_cfg)) &\r\nPORT_HW_CFG_NET_SERDES_IF_MASK);\r\nswitch (serdes_net_if) {\r\ncase PORT_HW_CFG_NET_SERDES_IF_KR:\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD, 0x81d1,\r\n&gp_status1);\r\nlnkup = (gp_status1 >> (8+lane)) & 0x1;\r\nlnkup_kr = (gp_status1 >> (12+lane)) & 0x1;\r\nif (lnkup_kr || lnkup) {\r\nvars->rx_tx_asic_rst = 0;\r\n} else {\r\nbnx2x_warpcore_reset_lane(bp, phy, 1);\r\nbnx2x_warpcore_reset_lane(bp, phy, 0);\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_WC_REG_IEEE0BLK_MIICNTL, 0x1200);\r\nvars->rx_tx_asic_rst--;\r\nDP(NETIF_MSG_LINK, "0x%x retry left\n",\r\nvars->rx_tx_asic_rst);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void bnx2x_warpcore_config_sfi(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nu16 lane = bnx2x_get_warpcore_lane(phy, params);\r\nstruct bnx2x *bp = params->bp;\r\nbnx2x_warpcore_clear_regs(phy, params, lane);\r\nif ((params->req_line_speed[LINK_CONFIG_IDX(INT_PHY)] ==\r\nSPEED_10000) &&\r\n(phy->media_type != ETH_PHY_SFP_1G_FIBER)) {\r\nDP(NETIF_MSG_LINK, "Setting 10G SFI\n");\r\nbnx2x_warpcore_set_10G_XFI(phy, params, 0);\r\n} else {\r\nDP(NETIF_MSG_LINK, "Setting 1G Fiber\n");\r\nbnx2x_warpcore_set_sgmii_speed(phy, params, 1, 0);\r\n}\r\n}\r\nstatic void bnx2x_sfp_e3_set_transmitter(struct link_params *params,\r\nstruct bnx2x_phy *phy,\r\nu8 tx_en)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu32 cfg_pin;\r\nu8 port = params->port;\r\ncfg_pin = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[port].e3_sfp_ctrl)) &\r\nPORT_HW_CFG_E3_TX_LASER_MASK;\r\nDP(NETIF_MSG_LINK, "Setting WC TX to %d\n", tx_en);\r\nbnx2x_set_cfg_pin(bp, cfg_pin, tx_en ^ 1);\r\nif (phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_20G)\r\nbnx2x_set_cfg_pin(bp, cfg_pin + 3, tx_en ^ 1);\r\n}\r\nstatic void bnx2x_warpcore_config_init(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu32 serdes_net_if;\r\nu8 fiber_mode;\r\nu16 lane = bnx2x_get_warpcore_lane(phy, params);\r\nserdes_net_if = (REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region, dev_info.\r\nport_hw_config[params->port].default_cfg)) &\r\nPORT_HW_CFG_NET_SERDES_IF_MASK);\r\nDP(NETIF_MSG_LINK, "Begin Warpcore init, link_speed %d, "\r\n"serdes_net_if = 0x%x\n",\r\nvars->line_speed, serdes_net_if);\r\nbnx2x_set_aer_mmd(params, phy);\r\nbnx2x_warpcore_reset_lane(bp, phy, 1);\r\nvars->phy_flags |= PHY_XGXS_FLAG;\r\nif ((serdes_net_if == PORT_HW_CFG_NET_SERDES_IF_SGMII) ||\r\n(phy->req_line_speed &&\r\n((phy->req_line_speed == SPEED_100) ||\r\n(phy->req_line_speed == SPEED_10)))) {\r\nvars->phy_flags |= PHY_SGMII_FLAG;\r\nDP(NETIF_MSG_LINK, "Setting SGMII mode\n");\r\nbnx2x_warpcore_clear_regs(phy, params, lane);\r\nbnx2x_warpcore_set_sgmii_speed(phy, params, 0, 1);\r\n} else {\r\nswitch (serdes_net_if) {\r\ncase PORT_HW_CFG_NET_SERDES_IF_KR:\r\nif (params->loopback_mode != LOOPBACK_EXT)\r\nbnx2x_warpcore_enable_AN_KR(phy, params, vars);\r\nelse {\r\nDP(NETIF_MSG_LINK, "Setting KR 10G-Force\n");\r\nbnx2x_warpcore_set_10G_KR(phy, params, vars);\r\n}\r\nbreak;\r\ncase PORT_HW_CFG_NET_SERDES_IF_XFI:\r\nbnx2x_warpcore_clear_regs(phy, params, lane);\r\nif (vars->line_speed == SPEED_10000) {\r\nDP(NETIF_MSG_LINK, "Setting 10G XFI\n");\r\nbnx2x_warpcore_set_10G_XFI(phy, params, 1);\r\n} else {\r\nif (SINGLE_MEDIA_DIRECT(params)) {\r\nDP(NETIF_MSG_LINK, "1G Fiber\n");\r\nfiber_mode = 1;\r\n} else {\r\nDP(NETIF_MSG_LINK, "10/100/1G SGMII\n");\r\nfiber_mode = 0;\r\n}\r\nbnx2x_warpcore_set_sgmii_speed(phy,\r\nparams,\r\nfiber_mode,\r\n0);\r\n}\r\nbreak;\r\ncase PORT_HW_CFG_NET_SERDES_IF_SFI:\r\nif ((params->loopback_mode == LOOPBACK_NONE) ||\r\n(params->loopback_mode == LOOPBACK_EXT)) {\r\nif (bnx2x_is_sfp_module_plugged(phy, params))\r\nbnx2x_sfp_module_detection(phy, params);\r\nelse\r\nbnx2x_sfp_e3_set_transmitter(params,\r\nphy, 1);\r\n}\r\nbnx2x_warpcore_config_sfi(phy, params);\r\nbreak;\r\ncase PORT_HW_CFG_NET_SERDES_IF_DXGXS:\r\nif (vars->line_speed != SPEED_20000) {\r\nDP(NETIF_MSG_LINK, "Speed not supported yet\n");\r\nreturn;\r\n}\r\nDP(NETIF_MSG_LINK, "Setting 20G DXGXS\n");\r\nbnx2x_warpcore_set_20G_DXGXS(bp, phy, lane);\r\nbnx2x_sfp_module_detection(phy, params);\r\nbreak;\r\ncase PORT_HW_CFG_NET_SERDES_IF_KR2:\r\nif (!params->loopback_mode) {\r\nbnx2x_warpcore_enable_AN_KR(phy, params, vars);\r\n} else {\r\nDP(NETIF_MSG_LINK, "Setting KR 20G-Force\n");\r\nbnx2x_warpcore_set_20G_force_KR2(phy, params);\r\n}\r\nbreak;\r\ndefault:\r\nDP(NETIF_MSG_LINK,\r\n"Unsupported Serdes Net Interface 0x%x\n",\r\nserdes_net_if);\r\nreturn;\r\n}\r\n}\r\nbnx2x_warpcore_reset_lane(bp, phy, 0);\r\nDP(NETIF_MSG_LINK, "Exit config init\n");\r\n}\r\nstatic void bnx2x_warpcore_link_reset(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 val16, lane;\r\nbnx2x_sfp_e3_set_transmitter(params, phy, 0);\r\nbnx2x_set_mdio_emac_per_phy(bp, params);\r\nbnx2x_set_aer_mmd(params, phy);\r\nbnx2x_warpcore_reset_lane(bp, phy, 1);\r\nbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_COMBO_IEEE0_MIICTRL, 0xBFFF);\r\nbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_IEEE0BLK_MIICNTL, 0xfffe);\r\nCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\r\nMDIO_AER_BLOCK_AER_REG, 0);\r\nbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_XGXSBLK0_XGXSCONTROL,\r\n~0x10);\r\nbnx2x_cl45_read_and_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_XGXSBLK1_LANECTRL2, 0xff00);\r\nlane = bnx2x_get_warpcore_lane(phy, params);\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_XGXSBLK1_LANECTRL0, &val16);\r\nval16 |= (0x11 << lane);\r\nif (phy->flags & FLAGS_WC_DUAL_MODE)\r\nval16 |= (0x22 << lane);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_XGXSBLK1_LANECTRL0, val16);\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_XGXSBLK1_LANECTRL1, &val16);\r\nval16 &= ~(0x0303 << (lane << 1));\r\nval16 |= (0x0101 << (lane << 1));\r\nif (phy->flags & FLAGS_WC_DUAL_MODE) {\r\nval16 &= ~(0x0c0c << (lane << 1));\r\nval16 |= (0x0404 << (lane << 1));\r\n}\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_XGXSBLK1_LANECTRL1, val16);\r\nbnx2x_set_aer_mmd(params, phy);\r\n}\r\nstatic void bnx2x_set_warpcore_loopback(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 val16;\r\nu32 lane;\r\nDP(NETIF_MSG_LINK, "Setting Warpcore loopback type %x, speed %d\n",\r\nparams->loopback_mode, phy->req_line_speed);\r\nif (phy->req_line_speed < SPEED_10000 ||\r\nphy->supported & SUPPORTED_20000baseKR2_Full) {\r\nCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\r\nMDIO_AER_BLOCK_AER_REG, 0);\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_XGXSBLK0_XGXSCONTROL,\r\n0x10);\r\nlane = bnx2x_get_warpcore_lane(phy, params);\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_XGXSBLK1_LANECTRL2, &val16);\r\nval16 |= (1<<lane);\r\nif (phy->flags & FLAGS_WC_DUAL_MODE)\r\nval16 |= (2<<lane);\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_XGXSBLK1_LANECTRL2,\r\nval16);\r\nbnx2x_set_aer_mmd(params, phy);\r\n} else {\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_COMBO_IEEE0_MIICTRL,\r\n0x4000);\r\nbnx2x_cl45_read_or_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_IEEE0BLK_MIICNTL, 0x1);\r\n}\r\n}\r\nstatic void bnx2x_sync_link(struct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 link_10g_plus;\r\nif (vars->link_status & LINK_STATUS_PHYSICAL_LINK_FLAG)\r\nvars->phy_flags |= PHY_PHYSICAL_LINK_FLAG;\r\nvars->link_up = (vars->link_status & LINK_STATUS_LINK_UP);\r\nif (vars->link_up) {\r\nDP(NETIF_MSG_LINK, "phy link up\n");\r\nvars->phy_link_up = 1;\r\nvars->duplex = DUPLEX_FULL;\r\nswitch (vars->link_status &\r\nLINK_STATUS_SPEED_AND_DUPLEX_MASK) {\r\ncase LINK_10THD:\r\nvars->duplex = DUPLEX_HALF;\r\ncase LINK_10TFD:\r\nvars->line_speed = SPEED_10;\r\nbreak;\r\ncase LINK_100TXHD:\r\nvars->duplex = DUPLEX_HALF;\r\ncase LINK_100T4:\r\ncase LINK_100TXFD:\r\nvars->line_speed = SPEED_100;\r\nbreak;\r\ncase LINK_1000THD:\r\nvars->duplex = DUPLEX_HALF;\r\ncase LINK_1000TFD:\r\nvars->line_speed = SPEED_1000;\r\nbreak;\r\ncase LINK_2500THD:\r\nvars->duplex = DUPLEX_HALF;\r\ncase LINK_2500TFD:\r\nvars->line_speed = SPEED_2500;\r\nbreak;\r\ncase LINK_10GTFD:\r\nvars->line_speed = SPEED_10000;\r\nbreak;\r\ncase LINK_20GTFD:\r\nvars->line_speed = SPEED_20000;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nvars->flow_ctrl = 0;\r\nif (vars->link_status & LINK_STATUS_TX_FLOW_CONTROL_ENABLED)\r\nvars->flow_ctrl |= BNX2X_FLOW_CTRL_TX;\r\nif (vars->link_status & LINK_STATUS_RX_FLOW_CONTROL_ENABLED)\r\nvars->flow_ctrl |= BNX2X_FLOW_CTRL_RX;\r\nif (!vars->flow_ctrl)\r\nvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\r\nif (vars->line_speed &&\r\n((vars->line_speed == SPEED_10) ||\r\n(vars->line_speed == SPEED_100))) {\r\nvars->phy_flags |= PHY_SGMII_FLAG;\r\n} else {\r\nvars->phy_flags &= ~PHY_SGMII_FLAG;\r\n}\r\nif (vars->line_speed &&\r\nUSES_WARPCORE(bp) &&\r\n(vars->line_speed == SPEED_1000))\r\nvars->phy_flags |= PHY_SGMII_FLAG;\r\nlink_10g_plus = (vars->line_speed >= SPEED_10000);\r\nif (link_10g_plus) {\r\nif (USES_WARPCORE(bp))\r\nvars->mac_type = MAC_TYPE_XMAC;\r\nelse\r\nvars->mac_type = MAC_TYPE_BMAC;\r\n} else {\r\nif (USES_WARPCORE(bp))\r\nvars->mac_type = MAC_TYPE_UMAC;\r\nelse\r\nvars->mac_type = MAC_TYPE_EMAC;\r\n}\r\n} else {\r\nDP(NETIF_MSG_LINK, "phy link down\n");\r\nvars->phy_link_up = 0;\r\nvars->line_speed = 0;\r\nvars->duplex = DUPLEX_FULL;\r\nvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\r\nvars->mac_type = MAC_TYPE_NONE;\r\nif (vars->link_status & LINK_STATUS_PHYSICAL_LINK_FLAG)\r\nvars->phy_flags |= PHY_HALF_OPEN_CONN_FLAG;\r\nif (vars->link_status & LINK_STATUS_SFP_TX_FAULT)\r\nvars->phy_flags |= PHY_SFP_TX_FAULT_FLAG;\r\n}\r\n}\r\nvoid bnx2x_link_status_update(struct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 port = params->port;\r\nu32 sync_offset, media_types;\r\nset_phy_vars(params, vars);\r\nvars->link_status = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\nport_mb[port].link_status));\r\nif (params->loopback_mode != LOOPBACK_NONE &&\r\nparams->loopback_mode != LOOPBACK_EXT)\r\nvars->link_status |= LINK_STATUS_LINK_UP;\r\nif (bnx2x_eee_has_cap(params))\r\nvars->eee_status = REG_RD(bp, params->shmem2_base +\r\noffsetof(struct shmem2_region,\r\neee_status[params->port]));\r\nvars->phy_flags = PHY_XGXS_FLAG;\r\nbnx2x_sync_link(params, vars);\r\nsync_offset = params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[port].media_type);\r\nmedia_types = REG_RD(bp, sync_offset);\r\nparams->phy[INT_PHY].media_type =\r\n(media_types & PORT_HW_CFG_MEDIA_TYPE_PHY0_MASK) >>\r\nPORT_HW_CFG_MEDIA_TYPE_PHY0_SHIFT;\r\nparams->phy[EXT_PHY1].media_type =\r\n(media_types & PORT_HW_CFG_MEDIA_TYPE_PHY1_MASK) >>\r\nPORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT;\r\nparams->phy[EXT_PHY2].media_type =\r\n(media_types & PORT_HW_CFG_MEDIA_TYPE_PHY2_MASK) >>\r\nPORT_HW_CFG_MEDIA_TYPE_PHY2_SHIFT;\r\nDP(NETIF_MSG_LINK, "media_types = 0x%x\n", media_types);\r\nsync_offset = params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[port].aeu_int_mask);\r\nvars->aeu_int_mask = REG_RD(bp, sync_offset);\r\nif (vars->link_status & LINK_STATUS_PFC_ENABLED)\r\nparams->feature_config_flags |=\r\nFEATURE_CONFIG_PFC_ENABLED;\r\nelse\r\nparams->feature_config_flags &=\r\n~FEATURE_CONFIG_PFC_ENABLED;\r\nif (SHMEM2_HAS(bp, link_attr_sync))\r\nparams->link_attr_sync = SHMEM2_RD(bp,\r\nlink_attr_sync[params->port]);\r\nDP(NETIF_MSG_LINK, "link_status 0x%x phy_link_up %x int_mask 0x%x\n",\r\nvars->link_status, vars->phy_link_up, vars->aeu_int_mask);\r\nDP(NETIF_MSG_LINK, "line_speed %x duplex %x flow_ctrl 0x%x\n",\r\nvars->line_speed, vars->duplex, vars->flow_ctrl);\r\n}\r\nstatic void bnx2x_set_master_ln(struct link_params *params,\r\nstruct bnx2x_phy *phy)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 new_master_ln, ser_lane;\r\nser_lane = ((params->lane_config &\r\nPORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK) >>\r\nPORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT);\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_XGXS_BLOCK2,\r\nMDIO_XGXS_BLOCK2_TEST_MODE_LANE,\r\n&new_master_ln);\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_XGXS_BLOCK2 ,\r\nMDIO_XGXS_BLOCK2_TEST_MODE_LANE,\r\n(new_master_ln | ser_lane));\r\n}\r\nstatic int bnx2x_reset_unicore(struct link_params *params,\r\nstruct bnx2x_phy *phy,\r\nu8 set_serdes)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 mii_control;\r\nu16 i;\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_COMBO_IEEE0,\r\nMDIO_COMBO_IEEE0_MII_CONTROL, &mii_control);\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_COMBO_IEEE0,\r\nMDIO_COMBO_IEEE0_MII_CONTROL,\r\n(mii_control |\r\nMDIO_COMBO_IEEO_MII_CONTROL_RESET));\r\nif (set_serdes)\r\nbnx2x_set_serdes_access(bp, params->port);\r\nfor (i = 0; i < MDIO_ACCESS_TIMEOUT; i++) {\r\nudelay(5);\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_COMBO_IEEE0,\r\nMDIO_COMBO_IEEE0_MII_CONTROL,\r\n&mii_control);\r\nif (!(mii_control & MDIO_COMBO_IEEO_MII_CONTROL_RESET)) {\r\nudelay(5);\r\nreturn 0;\r\n}\r\n}\r\nnetdev_err(bp->dev, "Warning: PHY was not initialized,"\r\n" Port %d\n",\r\nparams->port);\r\nDP(NETIF_MSG_LINK, "BUG! XGXS is still in reset!\n");\r\nreturn -EINVAL;\r\n}\r\nstatic void bnx2x_set_swap_lanes(struct link_params *params,\r\nstruct bnx2x_phy *phy)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 rx_lane_swap, tx_lane_swap;\r\nrx_lane_swap = ((params->lane_config &\r\nPORT_HW_CFG_LANE_SWAP_CFG_RX_MASK) >>\r\nPORT_HW_CFG_LANE_SWAP_CFG_RX_SHIFT);\r\ntx_lane_swap = ((params->lane_config &\r\nPORT_HW_CFG_LANE_SWAP_CFG_TX_MASK) >>\r\nPORT_HW_CFG_LANE_SWAP_CFG_TX_SHIFT);\r\nif (rx_lane_swap != 0x1b) {\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_XGXS_BLOCK2,\r\nMDIO_XGXS_BLOCK2_RX_LN_SWAP,\r\n(rx_lane_swap |\r\nMDIO_XGXS_BLOCK2_RX_LN_SWAP_ENABLE |\r\nMDIO_XGXS_BLOCK2_RX_LN_SWAP_FORCE_ENABLE));\r\n} else {\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_XGXS_BLOCK2,\r\nMDIO_XGXS_BLOCK2_RX_LN_SWAP, 0);\r\n}\r\nif (tx_lane_swap != 0x1b) {\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_XGXS_BLOCK2,\r\nMDIO_XGXS_BLOCK2_TX_LN_SWAP,\r\n(tx_lane_swap |\r\nMDIO_XGXS_BLOCK2_TX_LN_SWAP_ENABLE));\r\n} else {\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_XGXS_BLOCK2,\r\nMDIO_XGXS_BLOCK2_TX_LN_SWAP, 0);\r\n}\r\n}\r\nstatic void bnx2x_set_parallel_detection(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 control2;\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_SERDES_DIGITAL,\r\nMDIO_SERDES_DIGITAL_A_1000X_CONTROL2,\r\n&control2);\r\nif (phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)\r\ncontrol2 |= MDIO_SERDES_DIGITAL_A_1000X_CONTROL2_PRL_DT_EN;\r\nelse\r\ncontrol2 &= ~MDIO_SERDES_DIGITAL_A_1000X_CONTROL2_PRL_DT_EN;\r\nDP(NETIF_MSG_LINK, "phy->speed_cap_mask = 0x%x, control2 = 0x%x\n",\r\nphy->speed_cap_mask, control2);\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_SERDES_DIGITAL,\r\nMDIO_SERDES_DIGITAL_A_1000X_CONTROL2,\r\ncontrol2);\r\nif ((phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) &&\r\n(phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10G)) {\r\nDP(NETIF_MSG_LINK, "XGXS\n");\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_10G_PARALLEL_DETECT,\r\nMDIO_10G_PARALLEL_DETECT_PAR_DET_10G_LINK,\r\nMDIO_10G_PARALLEL_DETECT_PAR_DET_10G_LINK_CNT);\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_10G_PARALLEL_DETECT,\r\nMDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL,\r\n&control2);\r\ncontrol2 |=\r\nMDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL_PARDET10G_EN;\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_10G_PARALLEL_DETECT,\r\nMDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL,\r\ncontrol2);\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_XGXS_BLOCK2,\r\nMDIO_XGXS_BLOCK2_UNICORE_MODE_10G,\r\nMDIO_XGXS_BLOCK2_UNICORE_MODE_10G_CX4_XGXS |\r\nMDIO_XGXS_BLOCK2_UNICORE_MODE_10G_HIGIG_XGXS);\r\n}\r\n}\r\nstatic void bnx2x_set_autoneg(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars,\r\nu8 enable_cl73)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 reg_val;\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_COMBO_IEEE0,\r\nMDIO_COMBO_IEEE0_MII_CONTROL, &reg_val);\r\nif (vars->line_speed == SPEED_AUTO_NEG)\r\nreg_val |= MDIO_COMBO_IEEO_MII_CONTROL_AN_EN;\r\nelse\r\nreg_val &= ~(MDIO_COMBO_IEEO_MII_CONTROL_AN_EN |\r\nMDIO_COMBO_IEEO_MII_CONTROL_RESTART_AN);\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_COMBO_IEEE0,\r\nMDIO_COMBO_IEEE0_MII_CONTROL, reg_val);\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_SERDES_DIGITAL,\r\nMDIO_SERDES_DIGITAL_A_1000X_CONTROL1, &reg_val);\r\nreg_val &= ~(MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_SIGNAL_DETECT_EN |\r\nMDIO_SERDES_DIGITAL_A_1000X_CONTROL1_INVERT_SIGNAL_DETECT);\r\nreg_val |= MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_FIBER_MODE;\r\nif (vars->line_speed == SPEED_AUTO_NEG)\r\nreg_val |= MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_AUTODET;\r\nelse\r\nreg_val &= ~MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_AUTODET;\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_SERDES_DIGITAL,\r\nMDIO_SERDES_DIGITAL_A_1000X_CONTROL1, reg_val);\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_BAM_NEXT_PAGE,\r\nMDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL,\r\n&reg_val);\r\nif (vars->line_speed == SPEED_AUTO_NEG) {\r\nreg_val |= (MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_BAM_MODE |\r\nMDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_TETON_AN);\r\n} else {\r\nreg_val &= ~(MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_BAM_MODE |\r\nMDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_TETON_AN);\r\n}\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_BAM_NEXT_PAGE,\r\nMDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL,\r\nreg_val);\r\nif (enable_cl73) {\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_CL73_USERB0,\r\nMDIO_CL73_USERB0_CL73_UCTRL,\r\n0xe);\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_CL73_USERB0,\r\nMDIO_CL73_USERB0_CL73_BAM_CTRL1,\r\nMDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_EN |\r\nMDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_STATION_MNGR_EN |\r\nMDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_NP_AFTER_BP_EN);\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_CL73_IEEEB1,\r\nMDIO_CL73_IEEEB1_AN_ADV2,\r\n&reg_val);\r\nif (phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10G)\r\nreg_val |= MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KX4;\r\nif (phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_1G)\r\nreg_val |= MDIO_CL73_IEEEB1_AN_ADV2_ADVR_1000M_KX;\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_CL73_IEEEB1,\r\nMDIO_CL73_IEEEB1_AN_ADV2,\r\nreg_val);\r\nreg_val = MDIO_CL73_IEEEB0_CL73_AN_CONTROL_AN_EN;\r\n} else\r\nreg_val = 0;\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_CL73_IEEEB0,\r\nMDIO_CL73_IEEEB0_CL73_AN_CONTROL, reg_val);\r\n}\r\nstatic void bnx2x_program_serdes(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 reg_val;\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_COMBO_IEEE0,\r\nMDIO_COMBO_IEEE0_MII_CONTROL, &reg_val);\r\nreg_val &= ~(MDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX |\r\nMDIO_COMBO_IEEO_MII_CONTROL_AN_EN |\r\nMDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_MASK);\r\nif (phy->req_duplex == DUPLEX_FULL)\r\nreg_val |= MDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX;\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_COMBO_IEEE0,\r\nMDIO_COMBO_IEEE0_MII_CONTROL, reg_val);\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_SERDES_DIGITAL,\r\nMDIO_SERDES_DIGITAL_MISC1, &reg_val);\r\nDP(NETIF_MSG_LINK, "MDIO_REG_BANK_SERDES_DIGITAL = 0x%x\n", reg_val);\r\nreg_val &= ~(MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_MASK |\r\nMDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_SEL);\r\nif (!((vars->line_speed == SPEED_1000) ||\r\n(vars->line_speed == SPEED_100) ||\r\n(vars->line_speed == SPEED_10))) {\r\nreg_val |= (MDIO_SERDES_DIGITAL_MISC1_REFCLK_SEL_156_25M |\r\nMDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_SEL);\r\nif (vars->line_speed == SPEED_10000)\r\nreg_val |=\r\nMDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_10G_CX4;\r\n}\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_SERDES_DIGITAL,\r\nMDIO_SERDES_DIGITAL_MISC1, reg_val);\r\n}\r\nstatic void bnx2x_set_brcm_cl37_advertisement(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 val = 0;\r\nif (phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G)\r\nval |= MDIO_OVER_1G_UP1_2_5G;\r\nif (phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)\r\nval |= MDIO_OVER_1G_UP1_10G;\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_OVER_1G,\r\nMDIO_OVER_1G_UP1, val);\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_OVER_1G,\r\nMDIO_OVER_1G_UP3, 0x400);\r\n}\r\nstatic void bnx2x_set_ieee_aneg_advertisement(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nu16 ieee_fc)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 val;\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_COMBO_IEEE0,\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV, ieee_fc);\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_CL73_IEEEB1,\r\nMDIO_CL73_IEEEB1_AN_ADV1, &val);\r\nval &= ~MDIO_CL73_IEEEB1_AN_ADV1_PAUSE_BOTH;\r\nval |= ((ieee_fc<<3) & MDIO_CL73_IEEEB1_AN_ADV1_PAUSE_MASK);\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_CL73_IEEEB1,\r\nMDIO_CL73_IEEEB1_AN_ADV1, val);\r\n}\r\nstatic void bnx2x_restart_autoneg(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nu8 enable_cl73)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 mii_control;\r\nDP(NETIF_MSG_LINK, "bnx2x_restart_autoneg\n");\r\nif (enable_cl73) {\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_CL73_IEEEB0,\r\nMDIO_CL73_IEEEB0_CL73_AN_CONTROL,\r\n&mii_control);\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_CL73_IEEEB0,\r\nMDIO_CL73_IEEEB0_CL73_AN_CONTROL,\r\n(mii_control |\r\nMDIO_CL73_IEEEB0_CL73_AN_CONTROL_AN_EN |\r\nMDIO_CL73_IEEEB0_CL73_AN_CONTROL_RESTART_AN));\r\n} else {\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_COMBO_IEEE0,\r\nMDIO_COMBO_IEEE0_MII_CONTROL,\r\n&mii_control);\r\nDP(NETIF_MSG_LINK,\r\n"bnx2x_restart_autoneg mii_control before = 0x%x\n",\r\nmii_control);\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_COMBO_IEEE0,\r\nMDIO_COMBO_IEEE0_MII_CONTROL,\r\n(mii_control |\r\nMDIO_COMBO_IEEO_MII_CONTROL_AN_EN |\r\nMDIO_COMBO_IEEO_MII_CONTROL_RESTART_AN));\r\n}\r\n}\r\nstatic void bnx2x_initialize_sgmii_process(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 control1;\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_SERDES_DIGITAL,\r\nMDIO_SERDES_DIGITAL_A_1000X_CONTROL1,\r\n&control1);\r\ncontrol1 |= MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_INVERT_SIGNAL_DETECT;\r\ncontrol1 &= ~(MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_FIBER_MODE |\r\nMDIO_SERDES_DIGITAL_A_1000X_CONTROL1_AUTODET |\r\nMDIO_SERDES_DIGITAL_A_1000X_CONTROL1_MSTR_MODE);\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_SERDES_DIGITAL,\r\nMDIO_SERDES_DIGITAL_A_1000X_CONTROL1,\r\ncontrol1);\r\nif (!(vars->line_speed == SPEED_AUTO_NEG)) {\r\nu16 mii_control;\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_COMBO_IEEE0,\r\nMDIO_COMBO_IEEE0_MII_CONTROL,\r\n&mii_control);\r\nmii_control &= ~(MDIO_COMBO_IEEO_MII_CONTROL_AN_EN |\r\nMDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_MASK|\r\nMDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX);\r\nswitch (vars->line_speed) {\r\ncase SPEED_100:\r\nmii_control |=\r\nMDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_100;\r\nbreak;\r\ncase SPEED_1000:\r\nmii_control |=\r\nMDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_1000;\r\nbreak;\r\ncase SPEED_10:\r\nbreak;\r\ndefault:\r\nDP(NETIF_MSG_LINK, "Invalid line_speed 0x%x\n",\r\nvars->line_speed);\r\nbreak;\r\n}\r\nif (phy->req_duplex == DUPLEX_FULL)\r\nmii_control |=\r\nMDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX;\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_COMBO_IEEE0,\r\nMDIO_COMBO_IEEE0_MII_CONTROL,\r\nmii_control);\r\n} else {\r\nbnx2x_restart_autoneg(phy, params, 0);\r\n}\r\n}\r\nstatic int bnx2x_direct_parallel_detect_used(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 pd_10g, status2_1000x;\r\nif (phy->req_line_speed != SPEED_AUTO_NEG)\r\nreturn 0;\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_SERDES_DIGITAL,\r\nMDIO_SERDES_DIGITAL_A_1000X_STATUS2,\r\n&status2_1000x);\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_SERDES_DIGITAL,\r\nMDIO_SERDES_DIGITAL_A_1000X_STATUS2,\r\n&status2_1000x);\r\nif (status2_1000x & MDIO_SERDES_DIGITAL_A_1000X_STATUS2_AN_DISABLED) {\r\nDP(NETIF_MSG_LINK, "1G parallel detect link on port %d\n",\r\nparams->port);\r\nreturn 1;\r\n}\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_10G_PARALLEL_DETECT,\r\nMDIO_10G_PARALLEL_DETECT_PAR_DET_10G_STATUS,\r\n&pd_10g);\r\nif (pd_10g & MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_STATUS_PD_LINK) {\r\nDP(NETIF_MSG_LINK, "10G parallel detect link on port %d\n",\r\nparams->port);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2x_update_adv_fc(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars,\r\nu32 gp_status)\r\n{\r\nu16 ld_pause;\r\nu16 lp_pause;\r\nu16 pause_result;\r\nstruct bnx2x *bp = params->bp;\r\nif ((gp_status &\r\n(MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_AUTONEG_COMPLETE |\r\nMDIO_GP_STATUS_TOP_AN_STATUS1_CL73_MR_LP_NP_AN_ABLE)) ==\r\n(MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_AUTONEG_COMPLETE |\r\nMDIO_GP_STATUS_TOP_AN_STATUS1_CL73_MR_LP_NP_AN_ABLE)) {\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_CL73_IEEEB1,\r\nMDIO_CL73_IEEEB1_AN_ADV1,\r\n&ld_pause);\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_CL73_IEEEB1,\r\nMDIO_CL73_IEEEB1_AN_LP_ADV1,\r\n&lp_pause);\r\npause_result = (ld_pause &\r\nMDIO_CL73_IEEEB1_AN_ADV1_PAUSE_MASK) >> 8;\r\npause_result |= (lp_pause &\r\nMDIO_CL73_IEEEB1_AN_LP_ADV1_PAUSE_MASK) >> 10;\r\nDP(NETIF_MSG_LINK, "pause_result CL73 0x%x\n", pause_result);\r\n} else {\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_COMBO_IEEE0,\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV,\r\n&ld_pause);\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_COMBO_IEEE0,\r\nMDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1,\r\n&lp_pause);\r\npause_result = (ld_pause &\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_MASK)>>5;\r\npause_result |= (lp_pause &\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_MASK)>>7;\r\nDP(NETIF_MSG_LINK, "pause_result CL37 0x%x\n", pause_result);\r\n}\r\nbnx2x_pause_resolve(vars, pause_result);\r\n}\r\nstatic void bnx2x_flow_ctrl_resolve(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars,\r\nu32 gp_status)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\r\nif (phy->req_flow_ctrl != BNX2X_FLOW_CTRL_AUTO) {\r\nif (phy->req_line_speed == SPEED_AUTO_NEG)\r\nbnx2x_update_adv_fc(phy, params, vars, gp_status);\r\nvars->flow_ctrl = phy->req_flow_ctrl;\r\n} else if (phy->req_line_speed != SPEED_AUTO_NEG)\r\nvars->flow_ctrl = params->req_fc_auto_adv;\r\nelse if ((gp_status & MDIO_AN_CL73_OR_37_COMPLETE) &&\r\n(!(vars->phy_flags & PHY_SGMII_FLAG))) {\r\nif (bnx2x_direct_parallel_detect_used(phy, params)) {\r\nvars->flow_ctrl = params->req_fc_auto_adv;\r\nreturn;\r\n}\r\nbnx2x_update_adv_fc(phy, params, vars, gp_status);\r\n}\r\nDP(NETIF_MSG_LINK, "flow_ctrl 0x%x\n", vars->flow_ctrl);\r\n}\r\nstatic void bnx2x_check_fallback_to_cl37(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 rx_status, ustat_val, cl37_fsm_received;\r\nDP(NETIF_MSG_LINK, "bnx2x_check_fallback_to_cl37\n");\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_RX0,\r\nMDIO_RX0_RX_STATUS,\r\n&rx_status);\r\nif ((rx_status & MDIO_RX0_RX_STATUS_SIGDET) !=\r\n(MDIO_RX0_RX_STATUS_SIGDET)) {\r\nDP(NETIF_MSG_LINK, "Signal is not detected. Restoring CL73."\r\n"rx_status(0x80b0) = 0x%x\n", rx_status);\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_CL73_IEEEB0,\r\nMDIO_CL73_IEEEB0_CL73_AN_CONTROL,\r\nMDIO_CL73_IEEEB0_CL73_AN_CONTROL_AN_EN);\r\nreturn;\r\n}\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_CL73_USERB0,\r\nMDIO_CL73_USERB0_CL73_USTAT1,\r\n&ustat_val);\r\nif ((ustat_val &\r\n(MDIO_CL73_USERB0_CL73_USTAT1_LINK_STATUS_CHECK |\r\nMDIO_CL73_USERB0_CL73_USTAT1_AN_GOOD_CHECK_BAM37)) !=\r\n(MDIO_CL73_USERB0_CL73_USTAT1_LINK_STATUS_CHECK |\r\nMDIO_CL73_USERB0_CL73_USTAT1_AN_GOOD_CHECK_BAM37)) {\r\nDP(NETIF_MSG_LINK, "CL73 state-machine is not stable. "\r\n"ustat_val(0x8371) = 0x%x\n", ustat_val);\r\nreturn;\r\n}\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_REMOTE_PHY,\r\nMDIO_REMOTE_PHY_MISC_RX_STATUS,\r\n&cl37_fsm_received);\r\nif ((cl37_fsm_received &\r\n(MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_OVER1G_MSG |\r\nMDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_BRCM_OUI_MSG)) !=\r\n(MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_OVER1G_MSG |\r\nMDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_BRCM_OUI_MSG)) {\r\nDP(NETIF_MSG_LINK, "No CL37 FSM were received. "\r\n"misc_rx_status(0x8330) = 0x%x\n",\r\ncl37_fsm_received);\r\nreturn;\r\n}\r\nCL22_WR_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_CL73_IEEEB0,\r\nMDIO_CL73_IEEEB0_CL73_AN_CONTROL,\r\n0);\r\nbnx2x_restart_autoneg(phy, params, 0);\r\nDP(NETIF_MSG_LINK, "Disabling CL73, and restarting CL37 autoneg\n");\r\n}\r\nstatic void bnx2x_xgxs_an_resolve(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars,\r\nu32 gp_status)\r\n{\r\nif (gp_status & MDIO_AN_CL73_OR_37_COMPLETE)\r\nvars->link_status |=\r\nLINK_STATUS_AUTO_NEGOTIATE_COMPLETE;\r\nif (bnx2x_direct_parallel_detect_used(phy, params))\r\nvars->link_status |=\r\nLINK_STATUS_PARALLEL_DETECTION_USED;\r\n}\r\nstatic int bnx2x_get_link_speed_duplex(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars,\r\nu16 is_link_up,\r\nu16 speed_mask,\r\nu16 is_duplex)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nif (phy->req_line_speed == SPEED_AUTO_NEG)\r\nvars->link_status |= LINK_STATUS_AUTO_NEGOTIATE_ENABLED;\r\nif (is_link_up) {\r\nDP(NETIF_MSG_LINK, "phy link up\n");\r\nvars->phy_link_up = 1;\r\nvars->link_status |= LINK_STATUS_LINK_UP;\r\nswitch (speed_mask) {\r\ncase GP_STATUS_10M:\r\nvars->line_speed = SPEED_10;\r\nif (is_duplex == DUPLEX_FULL)\r\nvars->link_status |= LINK_10TFD;\r\nelse\r\nvars->link_status |= LINK_10THD;\r\nbreak;\r\ncase GP_STATUS_100M:\r\nvars->line_speed = SPEED_100;\r\nif (is_duplex == DUPLEX_FULL)\r\nvars->link_status |= LINK_100TXFD;\r\nelse\r\nvars->link_status |= LINK_100TXHD;\r\nbreak;\r\ncase GP_STATUS_1G:\r\ncase GP_STATUS_1G_KX:\r\nvars->line_speed = SPEED_1000;\r\nif (is_duplex == DUPLEX_FULL)\r\nvars->link_status |= LINK_1000TFD;\r\nelse\r\nvars->link_status |= LINK_1000THD;\r\nbreak;\r\ncase GP_STATUS_2_5G:\r\nvars->line_speed = SPEED_2500;\r\nif (is_duplex == DUPLEX_FULL)\r\nvars->link_status |= LINK_2500TFD;\r\nelse\r\nvars->link_status |= LINK_2500THD;\r\nbreak;\r\ncase GP_STATUS_5G:\r\ncase GP_STATUS_6G:\r\nDP(NETIF_MSG_LINK,\r\n"link speed unsupported gp_status 0x%x\n",\r\nspeed_mask);\r\nreturn -EINVAL;\r\ncase GP_STATUS_10G_KX4:\r\ncase GP_STATUS_10G_HIG:\r\ncase GP_STATUS_10G_CX4:\r\ncase GP_STATUS_10G_KR:\r\ncase GP_STATUS_10G_SFI:\r\ncase GP_STATUS_10G_XFI:\r\nvars->line_speed = SPEED_10000;\r\nvars->link_status |= LINK_10GTFD;\r\nbreak;\r\ncase GP_STATUS_20G_DXGXS:\r\ncase GP_STATUS_20G_KR2:\r\nvars->line_speed = SPEED_20000;\r\nvars->link_status |= LINK_20GTFD;\r\nbreak;\r\ndefault:\r\nDP(NETIF_MSG_LINK,\r\n"link speed unsupported gp_status 0x%x\n",\r\nspeed_mask);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nDP(NETIF_MSG_LINK, "phy link down\n");\r\nvars->phy_link_up = 0;\r\nvars->duplex = DUPLEX_FULL;\r\nvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\r\nvars->mac_type = MAC_TYPE_NONE;\r\n}\r\nDP(NETIF_MSG_LINK, " phy_link_up %x line_speed %d\n",\r\nvars->phy_link_up, vars->line_speed);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_link_settings_status(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 gp_status, duplex = DUPLEX_HALF, link_up = 0, speed_mask;\r\nint rc = 0;\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_GP_STATUS,\r\nMDIO_GP_STATUS_TOP_AN_STATUS1,\r\n&gp_status);\r\nif (gp_status & MDIO_GP_STATUS_TOP_AN_STATUS1_DUPLEX_STATUS)\r\nduplex = DUPLEX_FULL;\r\nif (gp_status & MDIO_GP_STATUS_TOP_AN_STATUS1_LINK_STATUS)\r\nlink_up = 1;\r\nspeed_mask = gp_status & GP_STATUS_SPEED_MASK;\r\nDP(NETIF_MSG_LINK, "gp_status 0x%x, is_link_up %d, speed_mask 0x%x\n",\r\ngp_status, link_up, speed_mask);\r\nrc = bnx2x_get_link_speed_duplex(phy, params, vars, link_up, speed_mask,\r\nduplex);\r\nif (rc == -EINVAL)\r\nreturn rc;\r\nif (gp_status & MDIO_GP_STATUS_TOP_AN_STATUS1_LINK_STATUS) {\r\nif (SINGLE_MEDIA_DIRECT(params)) {\r\nvars->duplex = duplex;\r\nbnx2x_flow_ctrl_resolve(phy, params, vars, gp_status);\r\nif (phy->req_line_speed == SPEED_AUTO_NEG)\r\nbnx2x_xgxs_an_resolve(phy, params, vars,\r\ngp_status);\r\n}\r\n} else {\r\nif ((phy->req_line_speed == SPEED_AUTO_NEG) &&\r\nSINGLE_MEDIA_DIRECT(params)) {\r\nbnx2x_check_fallback_to_cl37(phy, params);\r\n}\r\n}\r\nif (SINGLE_MEDIA_DIRECT(params) &&\r\n(vars->link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE)) {\r\nu16 val;\r\nCL22_RD_OVER_CL45(bp, phy, MDIO_REG_BANK_CL73_IEEEB1,\r\nMDIO_CL73_IEEEB1_AN_LP_ADV2, &val);\r\nif (val & MDIO_CL73_IEEEB1_AN_ADV2_ADVR_1000M_KX)\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE;\r\nif (val & (MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KX4 |\r\nMDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KR))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\r\nCL22_RD_OVER_CL45(bp, phy, MDIO_REG_BANK_OVER_1G,\r\nMDIO_OVER_1G_LP_UP1, &val);\r\nif (val & MDIO_OVER_1G_UP1_2_5G)\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_2500XFD_CAPABLE;\r\nif (val & (MDIO_OVER_1G_UP1_10G | MDIO_OVER_1G_UP1_10GH))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\r\n}\r\nDP(NETIF_MSG_LINK, "duplex %x flow_ctrl 0x%x link_status 0x%x\n",\r\nvars->duplex, vars->flow_ctrl, vars->link_status);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_warpcore_read_status(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 lane;\r\nu16 gp_status1, gp_speed, link_up, duplex = DUPLEX_FULL;\r\nint rc = 0;\r\nlane = bnx2x_get_warpcore_lane(phy, params);\r\nif ((params->loopback_mode) &&\r\n(phy->flags & FLAGS_WC_DUAL_MODE)) {\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_DIGITAL5_LINK_STATUS, &link_up);\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_DIGITAL5_LINK_STATUS, &link_up);\r\nlink_up &= 0x1;\r\n} else if ((phy->req_line_speed > SPEED_10000) &&\r\n(phy->supported & SUPPORTED_20000baseMLD2_Full)) {\r\nu16 temp_link_up;\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\n1, &temp_link_up);\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\n1, &link_up);\r\nDP(NETIF_MSG_LINK, "PCS RX link status = 0x%x-->0x%x\n",\r\ntemp_link_up, link_up);\r\nlink_up &= (1<<2);\r\nif (link_up)\r\nbnx2x_ext_phy_resolve_fc(phy, params, vars);\r\n} else {\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_GP2_STATUS_GP_2_1,\r\n&gp_status1);\r\nDP(NETIF_MSG_LINK, "0x81d1 = 0x%x\n", gp_status1);\r\nlink_up = ((gp_status1 >> 8) |\r\n(gp_status1 >> 12) |\r\n(gp_status1)) &\r\n(1 << lane);\r\nif (phy->supported & SUPPORTED_20000baseKR2_Full) {\r\nu16 an_link;\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_AN_REG_STATUS, &an_link);\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_AN_REG_STATUS, &an_link);\r\nlink_up |= (an_link & (1<<2));\r\n}\r\nif (link_up && SINGLE_MEDIA_DIRECT(params)) {\r\nu16 pd, gp_status4;\r\nif (phy->req_line_speed == SPEED_AUTO_NEG) {\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_GP2_STATUS_GP_2_4,\r\n&gp_status4);\r\nif (gp_status4 & ((1<<12)<<lane))\r\nvars->link_status |=\r\nLINK_STATUS_AUTO_NEGOTIATE_COMPLETE;\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_PAR_DET_10G_STATUS,\r\n&pd);\r\nif (pd & (1<<15))\r\nvars->link_status |=\r\nLINK_STATUS_PARALLEL_DETECTION_USED;\r\n}\r\nbnx2x_ext_phy_resolve_fc(phy, params, vars);\r\nvars->duplex = duplex;\r\n}\r\n}\r\nif ((vars->link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE) &&\r\nSINGLE_MEDIA_DIRECT(params)) {\r\nu16 val;\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_AN_REG_LP_AUTO_NEG2, &val);\r\nif (val & MDIO_CL73_IEEEB1_AN_ADV2_ADVR_1000M_KX)\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE;\r\nif (val & (MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KX4 |\r\nMDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KR))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_DIGITAL3_LP_UP1, &val);\r\nif (val & MDIO_OVER_1G_UP1_2_5G)\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_2500XFD_CAPABLE;\r\nif (val & (MDIO_OVER_1G_UP1_10G | MDIO_OVER_1G_UP1_10GH))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\r\n}\r\nif (lane < 2) {\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_GP2_STATUS_GP_2_2, &gp_speed);\r\n} else {\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_GP2_STATUS_GP_2_3, &gp_speed);\r\n}\r\nDP(NETIF_MSG_LINK, "lane %d gp_speed 0x%x\n", lane, gp_speed);\r\nif ((lane & 1) == 0)\r\ngp_speed <<= 8;\r\ngp_speed &= 0x3f00;\r\nlink_up = !!link_up;\r\nrc = bnx2x_get_link_speed_duplex(phy, params, vars, link_up, gp_speed,\r\nduplex);\r\nif ((!link_up) && (phy->media_type == ETH_PHY_KR) &&\r\n(!(phy->flags & FLAGS_WC_DUAL_MODE)))\r\nvars->rx_tx_asic_rst = MAX_KR_LINK_RETRY;\r\nDP(NETIF_MSG_LINK, "duplex %x flow_ctrl 0x%x link_status 0x%x\n",\r\nvars->duplex, vars->flow_ctrl, vars->link_status);\r\nreturn rc;\r\n}\r\nstatic void bnx2x_set_gmii_tx_driver(struct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nstruct bnx2x_phy *phy = &params->phy[INT_PHY];\r\nu16 lp_up2;\r\nu16 tx_driver;\r\nu16 bank;\r\nCL22_RD_OVER_CL45(bp, phy,\r\nMDIO_REG_BANK_OVER_1G,\r\nMDIO_OVER_1G_LP_UP2, &lp_up2);\r\nlp_up2 = (((lp_up2 & MDIO_OVER_1G_LP_UP2_PREEMPHASIS_MASK) >>\r\nMDIO_OVER_1G_LP_UP2_PREEMPHASIS_SHIFT) <<\r\nMDIO_TX0_TX_DRIVER_PREEMPHASIS_SHIFT);\r\nif (lp_up2 == 0)\r\nreturn;\r\nfor (bank = MDIO_REG_BANK_TX0; bank <= MDIO_REG_BANK_TX3;\r\nbank += (MDIO_REG_BANK_TX1 - MDIO_REG_BANK_TX0)) {\r\nCL22_RD_OVER_CL45(bp, phy,\r\nbank,\r\nMDIO_TX0_TX_DRIVER, &tx_driver);\r\nif (lp_up2 !=\r\n(tx_driver & MDIO_TX0_TX_DRIVER_PREEMPHASIS_MASK)) {\r\ntx_driver &= ~MDIO_TX0_TX_DRIVER_PREEMPHASIS_MASK;\r\ntx_driver |= lp_up2;\r\nCL22_WR_OVER_CL45(bp, phy,\r\nbank,\r\nMDIO_TX0_TX_DRIVER, tx_driver);\r\n}\r\n}\r\n}\r\nstatic int bnx2x_emac_program(struct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 port = params->port;\r\nu16 mode = 0;\r\nDP(NETIF_MSG_LINK, "setting link speed & duplex\n");\r\nbnx2x_bits_dis(bp, GRCBASE_EMAC0 + port*0x400 +\r\nEMAC_REG_EMAC_MODE,\r\n(EMAC_MODE_25G_MODE |\r\nEMAC_MODE_PORT_MII_10M |\r\nEMAC_MODE_HALF_DUPLEX));\r\nswitch (vars->line_speed) {\r\ncase SPEED_10:\r\nmode |= EMAC_MODE_PORT_MII_10M;\r\nbreak;\r\ncase SPEED_100:\r\nmode |= EMAC_MODE_PORT_MII;\r\nbreak;\r\ncase SPEED_1000:\r\nmode |= EMAC_MODE_PORT_GMII;\r\nbreak;\r\ncase SPEED_2500:\r\nmode |= (EMAC_MODE_25G_MODE | EMAC_MODE_PORT_GMII);\r\nbreak;\r\ndefault:\r\nDP(NETIF_MSG_LINK, "Invalid line_speed 0x%x\n",\r\nvars->line_speed);\r\nreturn -EINVAL;\r\n}\r\nif (vars->duplex == DUPLEX_HALF)\r\nmode |= EMAC_MODE_HALF_DUPLEX;\r\nbnx2x_bits_en(bp,\r\nGRCBASE_EMAC0 + port*0x400 + EMAC_REG_EMAC_MODE,\r\nmode);\r\nbnx2x_set_led(params, vars, LED_MODE_OPER, vars->line_speed);\r\nreturn 0;\r\n}\r\nstatic void bnx2x_set_preemphasis(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nu16 bank, i = 0;\r\nstruct bnx2x *bp = params->bp;\r\nfor (bank = MDIO_REG_BANK_RX0, i = 0; bank <= MDIO_REG_BANK_RX3;\r\nbank += (MDIO_REG_BANK_RX1-MDIO_REG_BANK_RX0), i++) {\r\nCL22_WR_OVER_CL45(bp, phy,\r\nbank,\r\nMDIO_RX0_RX_EQ_BOOST,\r\nphy->rx_preemphasis[i]);\r\n}\r\nfor (bank = MDIO_REG_BANK_TX0, i = 0; bank <= MDIO_REG_BANK_TX3;\r\nbank += (MDIO_REG_BANK_TX1 - MDIO_REG_BANK_TX0), i++) {\r\nCL22_WR_OVER_CL45(bp, phy,\r\nbank,\r\nMDIO_TX0_TX_DRIVER,\r\nphy->tx_preemphasis[i]);\r\n}\r\n}\r\nstatic void bnx2x_xgxs_config_init(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 enable_cl73 = (SINGLE_MEDIA_DIRECT(params) ||\r\n(params->loopback_mode == LOOPBACK_XGXS));\r\nif (!(vars->phy_flags & PHY_SGMII_FLAG)) {\r\nif (SINGLE_MEDIA_DIRECT(params) &&\r\n(params->feature_config_flags &\r\nFEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED))\r\nbnx2x_set_preemphasis(phy, params);\r\nif (vars->line_speed != SPEED_AUTO_NEG ||\r\n(SINGLE_MEDIA_DIRECT(params) &&\r\nparams->loopback_mode == LOOPBACK_EXT)) {\r\nDP(NETIF_MSG_LINK, "not SGMII, no AN\n");\r\nbnx2x_set_autoneg(phy, params, vars, 0);\r\nbnx2x_program_serdes(phy, params, vars);\r\n} else {\r\nDP(NETIF_MSG_LINK, "not SGMII, AN\n");\r\nbnx2x_set_brcm_cl37_advertisement(phy, params);\r\nbnx2x_set_ieee_aneg_advertisement(phy, params,\r\nvars->ieee_fc);\r\nbnx2x_set_autoneg(phy, params, vars, enable_cl73);\r\nbnx2x_restart_autoneg(phy, params, enable_cl73);\r\n}\r\n} else {\r\nDP(NETIF_MSG_LINK, "SGMII\n");\r\nbnx2x_initialize_sgmii_process(phy, params, vars);\r\n}\r\n}\r\nstatic int bnx2x_prepare_xgxs(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nint rc;\r\nvars->phy_flags |= PHY_XGXS_FLAG;\r\nif ((phy->req_line_speed &&\r\n((phy->req_line_speed == SPEED_100) ||\r\n(phy->req_line_speed == SPEED_10))) ||\r\n(!phy->req_line_speed &&\r\n(phy->speed_cap_mask >=\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL) &&\r\n(phy->speed_cap_mask <\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_1G)) ||\r\n(phy->type == PORT_HW_CFG_SERDES_EXT_PHY_TYPE_DIRECT_SD))\r\nvars->phy_flags |= PHY_SGMII_FLAG;\r\nelse\r\nvars->phy_flags &= ~PHY_SGMII_FLAG;\r\nbnx2x_calc_ieee_aneg_adv(phy, params, &vars->ieee_fc);\r\nbnx2x_set_aer_mmd(params, phy);\r\nif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT)\r\nbnx2x_set_master_ln(params, phy);\r\nrc = bnx2x_reset_unicore(params, phy, 0);\r\nif (rc)\r\nreturn rc;\r\nbnx2x_set_aer_mmd(params, phy);\r\nif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) {\r\nbnx2x_set_master_ln(params, phy);\r\nbnx2x_set_swap_lanes(params, phy);\r\n}\r\nreturn rc;\r\n}\r\nstatic u16 bnx2x_wait_reset_complete(struct bnx2x *bp,\r\nstruct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nu16 cnt, ctrl;\r\nfor (cnt = 0; cnt < 1000; cnt++) {\r\nif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE)\r\nbnx2x_cl22_read(bp, phy,\r\nMDIO_PMA_REG_CTRL, &ctrl);\r\nelse\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_CTRL, &ctrl);\r\nif (!(ctrl & (1<<15)))\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nif (cnt == 1000)\r\nnetdev_err(bp->dev, "Warning: PHY was not initialized,"\r\n" Port %d\n",\r\nparams->port);\r\nDP(NETIF_MSG_LINK, "control reg 0x%x (after %d ms)\n", ctrl, cnt);\r\nreturn cnt;\r\n}\r\nstatic void bnx2x_link_int_enable(struct link_params *params)\r\n{\r\nu8 port = params->port;\r\nu32 mask;\r\nstruct bnx2x *bp = params->bp;\r\nif (CHIP_IS_E3(bp)) {\r\nmask = NIG_MASK_XGXS0_LINK_STATUS;\r\nif (!(SINGLE_MEDIA_DIRECT(params)))\r\nmask |= NIG_MASK_MI_INT;\r\n} else if (params->switch_cfg == SWITCH_CFG_10G) {\r\nmask = (NIG_MASK_XGXS0_LINK10G |\r\nNIG_MASK_XGXS0_LINK_STATUS);\r\nDP(NETIF_MSG_LINK, "enabled XGXS interrupt\n");\r\nif (!(SINGLE_MEDIA_DIRECT(params)) &&\r\nparams->phy[INT_PHY].type !=\r\nPORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE) {\r\nmask |= NIG_MASK_MI_INT;\r\nDP(NETIF_MSG_LINK, "enabled external phy int\n");\r\n}\r\n} else {\r\nmask = NIG_MASK_SERDES0_LINK_STATUS;\r\nDP(NETIF_MSG_LINK, "enabled SerDes interrupt\n");\r\nif (!(SINGLE_MEDIA_DIRECT(params)) &&\r\nparams->phy[INT_PHY].type !=\r\nPORT_HW_CFG_SERDES_EXT_PHY_TYPE_NOT_CONN) {\r\nmask |= NIG_MASK_MI_INT;\r\nDP(NETIF_MSG_LINK, "enabled external phy int\n");\r\n}\r\n}\r\nbnx2x_bits_en(bp,\r\nNIG_REG_MASK_INTERRUPT_PORT0 + port*4,\r\nmask);\r\nDP(NETIF_MSG_LINK, "port %x, is_xgxs %x, int_status 0x%x\n", port,\r\n(params->switch_cfg == SWITCH_CFG_10G),\r\nREG_RD(bp, NIG_REG_STATUS_INTERRUPT_PORT0 + port*4));\r\nDP(NETIF_MSG_LINK, " int_mask 0x%x, MI_INT %x, SERDES_LINK %x\n",\r\nREG_RD(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4),\r\nREG_RD(bp, NIG_REG_EMAC0_STATUS_MISC_MI_INT + port*0x18),\r\nREG_RD(bp, NIG_REG_SERDES0_STATUS_LINK_STATUS+port*0x3c));\r\nDP(NETIF_MSG_LINK, " 10G %x, XGXS_LINK %x\n",\r\nREG_RD(bp, NIG_REG_XGXS0_STATUS_LINK10G + port*0x68),\r\nREG_RD(bp, NIG_REG_XGXS0_STATUS_LINK_STATUS + port*0x68));\r\n}\r\nstatic void bnx2x_rearm_latch_signal(struct bnx2x *bp, u8 port,\r\nu8 exp_mi_int)\r\n{\r\nu32 latch_status = 0;\r\nlatch_status = REG_RD(bp,\r\nNIG_REG_LATCH_STATUS_0 + port*8);\r\nDP(NETIF_MSG_LINK, "latch_status = 0x%x\n", latch_status);\r\nif (exp_mi_int)\r\nbnx2x_bits_en(bp,\r\nNIG_REG_STATUS_INTERRUPT_PORT0\r\n+ port*4,\r\nNIG_STATUS_EMAC0_MI_INT);\r\nelse\r\nbnx2x_bits_dis(bp,\r\nNIG_REG_STATUS_INTERRUPT_PORT0\r\n+ port*4,\r\nNIG_STATUS_EMAC0_MI_INT);\r\nif (latch_status & 1) {\r\nREG_WR(bp, NIG_REG_LATCH_STATUS_0 + port*8,\r\n(latch_status & 0xfffe) | (latch_status & 1));\r\n}\r\n}\r\nstatic void bnx2x_link_int_ack(struct link_params *params,\r\nstruct link_vars *vars, u8 is_10g_plus)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 port = params->port;\r\nu32 mask;\r\nbnx2x_bits_dis(bp, NIG_REG_STATUS_INTERRUPT_PORT0 + port*4,\r\n(NIG_STATUS_XGXS0_LINK10G |\r\nNIG_STATUS_XGXS0_LINK_STATUS |\r\nNIG_STATUS_SERDES0_LINK_STATUS));\r\nif (vars->phy_link_up) {\r\nif (USES_WARPCORE(bp))\r\nmask = NIG_STATUS_XGXS0_LINK_STATUS;\r\nelse {\r\nif (is_10g_plus)\r\nmask = NIG_STATUS_XGXS0_LINK10G;\r\nelse if (params->switch_cfg == SWITCH_CFG_10G) {\r\nu32 ser_lane =\r\n((params->lane_config &\r\nPORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK) >>\r\nPORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT);\r\nmask = ((1 << ser_lane) <<\r\nNIG_STATUS_XGXS0_LINK_STATUS_SIZE);\r\n} else\r\nmask = NIG_STATUS_SERDES0_LINK_STATUS;\r\n}\r\nDP(NETIF_MSG_LINK, "Ack link up interrupt with mask 0x%x\n",\r\nmask);\r\nbnx2x_bits_en(bp,\r\nNIG_REG_STATUS_INTERRUPT_PORT0 + port*4,\r\nmask);\r\n}\r\n}\r\nstatic int bnx2x_format_ver(u32 num, u8 *str, u16 *len)\r\n{\r\nu8 *str_ptr = str;\r\nu32 mask = 0xf0000000;\r\nu8 shift = 8*4;\r\nu8 digit;\r\nu8 remove_leading_zeros = 1;\r\nif (*len < 10) {\r\n*str_ptr = '\0';\r\n(*len)--;\r\nreturn -EINVAL;\r\n}\r\nwhile (shift > 0) {\r\nshift -= 4;\r\ndigit = ((num & mask) >> shift);\r\nif (digit == 0 && remove_leading_zeros) {\r\nmask = mask >> 4;\r\ncontinue;\r\n} else if (digit < 0xa)\r\n*str_ptr = digit + '0';\r\nelse\r\n*str_ptr = digit - 0xa + 'a';\r\nremove_leading_zeros = 0;\r\nstr_ptr++;\r\n(*len)--;\r\nmask = mask >> 4;\r\nif (shift == 4*4) {\r\n*str_ptr = '.';\r\nstr_ptr++;\r\n(*len)--;\r\nremove_leading_zeros = 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_null_format_ver(u32 spirom_ver, u8 *str, u16 *len)\r\n{\r\nstr[0] = '\0';\r\n(*len)--;\r\nreturn 0;\r\n}\r\nint bnx2x_get_ext_phy_fw_version(struct link_params *params, u8 *version,\r\nu16 len)\r\n{\r\nstruct bnx2x *bp;\r\nu32 spirom_ver = 0;\r\nint status = 0;\r\nu8 *ver_p = version;\r\nu16 remain_len = len;\r\nif (version == NULL || params == NULL)\r\nreturn -EINVAL;\r\nbp = params->bp;\r\nversion[0] = '\0';\r\nspirom_ver = REG_RD(bp, params->phy[EXT_PHY1].ver_addr);\r\nif (params->phy[EXT_PHY1].format_fw_ver) {\r\nstatus |= params->phy[EXT_PHY1].format_fw_ver(spirom_ver,\r\nver_p,\r\n&remain_len);\r\nver_p += (len - remain_len);\r\n}\r\nif ((params->num_phys == MAX_PHYS) &&\r\n(params->phy[EXT_PHY2].ver_addr != 0)) {\r\nspirom_ver = REG_RD(bp, params->phy[EXT_PHY2].ver_addr);\r\nif (params->phy[EXT_PHY2].format_fw_ver) {\r\n*ver_p = '/';\r\nver_p++;\r\nremain_len--;\r\nstatus |= params->phy[EXT_PHY2].format_fw_ver(\r\nspirom_ver,\r\nver_p,\r\n&remain_len);\r\nver_p = version + (len - remain_len);\r\n}\r\n}\r\n*ver_p = '\0';\r\nreturn status;\r\n}\r\nstatic void bnx2x_set_xgxs_loopback(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nu8 port = params->port;\r\nstruct bnx2x *bp = params->bp;\r\nif (phy->req_line_speed != SPEED_1000) {\r\nu32 md_devad = 0;\r\nDP(NETIF_MSG_LINK, "XGXS 10G loopback enable\n");\r\nif (!CHIP_IS_E3(bp)) {\r\nmd_devad = REG_RD(bp, (NIG_REG_XGXS0_CTRL_MD_DEVAD +\r\nport*0x18));\r\nREG_WR(bp, NIG_REG_XGXS0_CTRL_MD_DEVAD + port*0x18,\r\n0x5);\r\n}\r\nbnx2x_cl45_write(bp, phy,\r\n5,\r\n(MDIO_REG_BANK_AER_BLOCK +\r\n(MDIO_AER_BLOCK_AER_REG & 0xf)),\r\n0x2800);\r\nbnx2x_cl45_write(bp, phy,\r\n5,\r\n(MDIO_REG_BANK_CL73_IEEEB0 +\r\n(MDIO_CL73_IEEEB0_CL73_AN_CONTROL & 0xf)),\r\n0x6041);\r\nmsleep(200);\r\nbnx2x_set_aer_mmd(params, phy);\r\nif (!CHIP_IS_E3(bp)) {\r\nREG_WR(bp, NIG_REG_XGXS0_CTRL_MD_DEVAD + port*0x18,\r\nmd_devad);\r\n}\r\n} else {\r\nu16 mii_ctrl;\r\nDP(NETIF_MSG_LINK, "XGXS 1G loopback enable\n");\r\nbnx2x_cl45_read(bp, phy, 5,\r\n(MDIO_REG_BANK_COMBO_IEEE0 +\r\n(MDIO_COMBO_IEEE0_MII_CONTROL & 0xf)),\r\n&mii_ctrl);\r\nbnx2x_cl45_write(bp, phy, 5,\r\n(MDIO_REG_BANK_COMBO_IEEE0 +\r\n(MDIO_COMBO_IEEE0_MII_CONTROL & 0xf)),\r\nmii_ctrl |\r\nMDIO_COMBO_IEEO_MII_CONTROL_LOOPBACK);\r\n}\r\n}\r\nint bnx2x_set_led(struct link_params *params,\r\nstruct link_vars *vars, u8 mode, u32 speed)\r\n{\r\nu8 port = params->port;\r\nu16 hw_led_mode = params->hw_led_mode;\r\nint rc = 0;\r\nu8 phy_idx;\r\nu32 tmp;\r\nu32 emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;\r\nstruct bnx2x *bp = params->bp;\r\nDP(NETIF_MSG_LINK, "bnx2x_set_led: port %x, mode %d\n", port, mode);\r\nDP(NETIF_MSG_LINK, "speed 0x%x, hw_led_mode 0x%x\n",\r\nspeed, hw_led_mode);\r\nfor (phy_idx = EXT_PHY1; phy_idx < MAX_PHYS; phy_idx++) {\r\nif (params->phy[phy_idx].set_link_led) {\r\nparams->phy[phy_idx].set_link_led(\r\n&params->phy[phy_idx], params, mode);\r\n}\r\n}\r\nswitch (mode) {\r\ncase LED_MODE_FRONT_PANEL_OFF:\r\ncase LED_MODE_OFF:\r\nREG_WR(bp, NIG_REG_LED_10G_P0 + port*4, 0);\r\nREG_WR(bp, NIG_REG_LED_MODE_P0 + port*4,\r\nSHARED_HW_CFG_LED_MAC1);\r\ntmp = EMAC_RD(bp, EMAC_REG_EMAC_LED);\r\nif (params->phy[EXT_PHY1].type ==\r\nPORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE)\r\ntmp &= ~(EMAC_LED_1000MB_OVERRIDE |\r\nEMAC_LED_100MB_OVERRIDE |\r\nEMAC_LED_10MB_OVERRIDE);\r\nelse\r\ntmp |= EMAC_LED_OVERRIDE;\r\nEMAC_WR(bp, EMAC_REG_EMAC_LED, tmp);\r\nbreak;\r\ncase LED_MODE_OPER:\r\nif (!vars->link_up)\r\nbreak;\r\ncase LED_MODE_ON:\r\nif (((params->phy[EXT_PHY1].type ==\r\nPORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727) ||\r\n(params->phy[EXT_PHY1].type ==\r\nPORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722)) &&\r\nCHIP_IS_E2(bp) && params->num_phys == 2) {\r\nif (mode == LED_MODE_ON ||\r\nspeed == SPEED_10000){\r\nREG_WR(bp, NIG_REG_LED_MODE_P0 + port*4, 0);\r\nREG_WR(bp, NIG_REG_LED_10G_P0 + port*4, 1);\r\ntmp = EMAC_RD(bp, EMAC_REG_EMAC_LED);\r\nEMAC_WR(bp, EMAC_REG_EMAC_LED,\r\n(tmp | EMAC_LED_OVERRIDE));\r\nif (mode == LED_MODE_ON)\r\nreturn rc;\r\n}\r\n} else if (SINGLE_MEDIA_DIRECT(params)) {\r\nif ((!CHIP_IS_E3(bp)) ||\r\n(CHIP_IS_E3(bp) &&\r\nmode == LED_MODE_ON))\r\nREG_WR(bp, NIG_REG_LED_10G_P0 + port*4, 1);\r\nif (CHIP_IS_E1x(bp) ||\r\nCHIP_IS_E2(bp) ||\r\n(mode == LED_MODE_ON))\r\nREG_WR(bp, NIG_REG_LED_MODE_P0 + port*4, 0);\r\nelse\r\nREG_WR(bp, NIG_REG_LED_MODE_P0 + port*4,\r\nhw_led_mode);\r\n} else if ((params->phy[EXT_PHY1].type ==\r\nPORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE) &&\r\n(mode == LED_MODE_ON)) {\r\nREG_WR(bp, NIG_REG_LED_MODE_P0 + port*4, 0);\r\ntmp = EMAC_RD(bp, EMAC_REG_EMAC_LED);\r\nEMAC_WR(bp, EMAC_REG_EMAC_LED, tmp |\r\nEMAC_LED_OVERRIDE | EMAC_LED_1000MB_OVERRIDE);\r\nbreak;\r\n} else {\r\nu32 nig_led_mode = ((params->hw_led_mode <<\r\nSHARED_HW_CFG_LED_MODE_SHIFT) ==\r\nSHARED_HW_CFG_LED_EXTPHY2) ?\r\n(SHARED_HW_CFG_LED_PHY1 >>\r\nSHARED_HW_CFG_LED_MODE_SHIFT) : hw_led_mode;\r\nREG_WR(bp, NIG_REG_LED_MODE_P0 + port*4,\r\nnig_led_mode);\r\n}\r\nREG_WR(bp, NIG_REG_LED_CONTROL_OVERRIDE_TRAFFIC_P0 + port*4, 0);\r\nif (CHIP_IS_E3(bp))\r\nREG_WR(bp, NIG_REG_LED_CONTROL_BLINK_RATE_P0 + port*4,\r\nLED_BLINK_RATE_VAL_E3);\r\nelse\r\nREG_WR(bp, NIG_REG_LED_CONTROL_BLINK_RATE_P0 + port*4,\r\nLED_BLINK_RATE_VAL_E1X_E2);\r\nREG_WR(bp, NIG_REG_LED_CONTROL_BLINK_RATE_ENA_P0 +\r\nport*4, 1);\r\ntmp = EMAC_RD(bp, EMAC_REG_EMAC_LED);\r\nEMAC_WR(bp, EMAC_REG_EMAC_LED,\r\n(tmp & (~EMAC_LED_OVERRIDE)));\r\nif (CHIP_IS_E1(bp) &&\r\n((speed == SPEED_2500) ||\r\n(speed == SPEED_1000) ||\r\n(speed == SPEED_100) ||\r\n(speed == SPEED_10))) {\r\nREG_WR(bp, NIG_REG_LED_CONTROL_OVERRIDE_TRAFFIC_P0\r\n+ port*4, 1);\r\nREG_WR(bp, NIG_REG_LED_CONTROL_TRAFFIC_P0 +\r\nport*4, 0);\r\nREG_WR(bp, NIG_REG_LED_CONTROL_BLINK_TRAFFIC_P0 +\r\nport*4, 1);\r\n}\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nDP(NETIF_MSG_LINK, "bnx2x_set_led: Invalid led mode %d\n",\r\nmode);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nint bnx2x_test_link(struct link_params *params, struct link_vars *vars,\r\nu8 is_serdes)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 gp_status = 0, phy_index = 0;\r\nu8 ext_phy_link_up = 0, serdes_phy_type;\r\nstruct link_vars temp_vars;\r\nstruct bnx2x_phy *int_phy = &params->phy[INT_PHY];\r\nif (CHIP_IS_E3(bp)) {\r\nu16 link_up;\r\nif (params->req_line_speed[LINK_CONFIG_IDX(INT_PHY)]\r\n> SPEED_10000) {\r\nbnx2x_cl45_read(bp, int_phy, MDIO_WC_DEVAD,\r\n1, &link_up);\r\nbnx2x_cl45_read(bp, int_phy, MDIO_WC_DEVAD,\r\n1, &link_up);\r\nlink_up &= (1<<2);\r\n} else {\r\nu8 lane = bnx2x_get_warpcore_lane(int_phy, params);\r\nbnx2x_cl45_read(bp, int_phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_GP2_STATUS_GP_2_1,\r\n&gp_status);\r\ngp_status = ((gp_status >> 8) & 0xf) |\r\n((gp_status >> 12) & 0xf);\r\nlink_up = gp_status & (1 << lane);\r\n}\r\nif (!link_up)\r\nreturn -ESRCH;\r\n} else {\r\nCL22_RD_OVER_CL45(bp, int_phy,\r\nMDIO_REG_BANK_GP_STATUS,\r\nMDIO_GP_STATUS_TOP_AN_STATUS1,\r\n&gp_status);\r\nif (!(gp_status & MDIO_GP_STATUS_TOP_AN_STATUS1_LINK_STATUS))\r\nreturn -ESRCH;\r\n}\r\nif (params->loopback_mode == LOOPBACK_XGXS)\r\nreturn 0;\r\nswitch (params->num_phys) {\r\ncase 1:\r\nreturn 0;\r\ncase 2:\r\next_phy_link_up = params->phy[EXT_PHY1].read_status(\r\n&params->phy[EXT_PHY1],\r\nparams, &temp_vars);\r\nbreak;\r\ncase 3:\r\nfor (phy_index = EXT_PHY1; phy_index < params->num_phys;\r\nphy_index++) {\r\nserdes_phy_type = ((params->phy[phy_index].media_type ==\r\nETH_PHY_SFPP_10G_FIBER) ||\r\n(params->phy[phy_index].media_type ==\r\nETH_PHY_SFP_1G_FIBER) ||\r\n(params->phy[phy_index].media_type ==\r\nETH_PHY_XFP_FIBER) ||\r\n(params->phy[phy_index].media_type ==\r\nETH_PHY_DA_TWINAX));\r\nif (is_serdes != serdes_phy_type)\r\ncontinue;\r\nif (params->phy[phy_index].read_status) {\r\next_phy_link_up |=\r\nparams->phy[phy_index].read_status(\r\n&params->phy[phy_index],\r\nparams, &temp_vars);\r\n}\r\n}\r\nbreak;\r\n}\r\nif (ext_phy_link_up)\r\nreturn 0;\r\nreturn -ESRCH;\r\n}\r\nstatic int bnx2x_link_initialize(struct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nu8 phy_index, non_ext_phy;\r\nstruct bnx2x *bp = params->bp;\r\nvars->line_speed = params->phy[INT_PHY].req_line_speed;\r\nif (!USES_WARPCORE(bp))\r\nbnx2x_prepare_xgxs(&params->phy[INT_PHY], params, vars);\r\nnon_ext_phy = (SINGLE_MEDIA_DIRECT(params) ||\r\n(params->loopback_mode == LOOPBACK_XGXS));\r\nif (non_ext_phy ||\r\n(params->phy[EXT_PHY1].flags & FLAGS_INIT_XGXS_FIRST) ||\r\n(params->loopback_mode == LOOPBACK_EXT_PHY)) {\r\nstruct bnx2x_phy *phy = &params->phy[INT_PHY];\r\nif (vars->line_speed == SPEED_AUTO_NEG &&\r\n(CHIP_IS_E1x(bp) ||\r\nCHIP_IS_E2(bp)))\r\nbnx2x_set_parallel_detection(phy, params);\r\nif (params->phy[INT_PHY].config_init)\r\nparams->phy[INT_PHY].config_init(phy, params, vars);\r\n}\r\nvars->line_speed = params->phy[INT_PHY].req_line_speed;\r\nif (non_ext_phy) {\r\nif (params->phy[INT_PHY].supported &\r\nSUPPORTED_FIBRE)\r\nvars->link_status |= LINK_STATUS_SERDES_LINK;\r\n} else {\r\nfor (phy_index = EXT_PHY1; phy_index < params->num_phys;\r\nphy_index++) {\r\nif (params->phy[phy_index].supported &\r\nSUPPORTED_FIBRE)\r\nvars->link_status |= LINK_STATUS_SERDES_LINK;\r\nif (phy_index == EXT_PHY2 &&\r\n(bnx2x_phy_selection(params) ==\r\nPORT_HW_CFG_PHY_SELECTION_FIRST_PHY)) {\r\nDP(NETIF_MSG_LINK,\r\n"Not initializing second phy\n");\r\ncontinue;\r\n}\r\nparams->phy[phy_index].config_init(\r\n&params->phy[phy_index],\r\nparams, vars);\r\n}\r\n}\r\nbnx2x_bits_dis(bp, NIG_REG_STATUS_INTERRUPT_PORT0 +\r\nparams->port*4,\r\n(NIG_STATUS_XGXS0_LINK10G |\r\nNIG_STATUS_XGXS0_LINK_STATUS |\r\nNIG_STATUS_SERDES0_LINK_STATUS |\r\nNIG_MASK_MI_INT));\r\nreturn 0;\r\n}\r\nstatic void bnx2x_int_link_reset(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nREG_WR(params->bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_3_CLEAR,\r\n(0x1ff << (params->port*16)));\r\n}\r\nstatic void bnx2x_common_ext_link_reset(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 gpio_port;\r\nif (CHIP_IS_E2(bp))\r\ngpio_port = BP_PATH(bp);\r\nelse\r\ngpio_port = params->port;\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,\r\nMISC_REGISTERS_GPIO_OUTPUT_LOW,\r\ngpio_port);\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\r\nMISC_REGISTERS_GPIO_OUTPUT_LOW,\r\ngpio_port);\r\nDP(NETIF_MSG_LINK, "reset external PHY\n");\r\n}\r\nstatic int bnx2x_update_link_down(struct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 port = params->port;\r\nDP(NETIF_MSG_LINK, "Port %x: Link is down\n", port);\r\nbnx2x_set_led(params, vars, LED_MODE_OFF, 0);\r\nvars->phy_flags &= ~PHY_PHYSICAL_LINK_FLAG;\r\nvars->mac_type = MAC_TYPE_NONE;\r\nvars->link_status &= ~LINK_UPDATE_MASK;\r\nvars->line_speed = 0;\r\nbnx2x_update_mng(params, vars->link_status);\r\nREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + port*4, 1);\r\nif (!CHIP_IS_E3(bp))\r\nREG_WR(bp, NIG_REG_NIG_EMAC0_EN + port*4, 0);\r\nusleep_range(10000, 20000);\r\nif (CHIP_IS_E1x(bp) ||\r\nCHIP_IS_E2(bp))\r\nbnx2x_set_bmac_rx(bp, params->chip_id, params->port, 0);\r\nif (CHIP_IS_E3(bp)) {\r\nREG_WR(bp, MISC_REG_CPMU_LP_FW_ENABLE_P0 + (params->port << 2),\r\n0);\r\nREG_WR(bp, MISC_REG_CPMU_LP_MASK_ENT_P0 + (params->port << 2),\r\n0);\r\nvars->eee_status &= ~(SHMEM_EEE_LP_ADV_STATUS_MASK |\r\nSHMEM_EEE_ACTIVE_BIT);\r\nbnx2x_update_mng_eee(params, vars->eee_status);\r\nbnx2x_set_xmac_rxtx(params, 0);\r\nbnx2x_set_umac_rxtx(params, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_update_link_up(struct link_params *params,\r\nstruct link_vars *vars,\r\nu8 link_10g)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 phy_idx, port = params->port;\r\nint rc = 0;\r\nvars->link_status |= (LINK_STATUS_LINK_UP |\r\nLINK_STATUS_PHYSICAL_LINK_FLAG);\r\nvars->phy_flags |= PHY_PHYSICAL_LINK_FLAG;\r\nif (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX)\r\nvars->link_status |=\r\nLINK_STATUS_TX_FLOW_CONTROL_ENABLED;\r\nif (vars->flow_ctrl & BNX2X_FLOW_CTRL_RX)\r\nvars->link_status |=\r\nLINK_STATUS_RX_FLOW_CONTROL_ENABLED;\r\nif (USES_WARPCORE(bp)) {\r\nif (link_10g) {\r\nif (bnx2x_xmac_enable(params, vars, 0) ==\r\n-ESRCH) {\r\nDP(NETIF_MSG_LINK, "Found errors on XMAC\n");\r\nvars->link_up = 0;\r\nvars->phy_flags |= PHY_HALF_OPEN_CONN_FLAG;\r\nvars->link_status &= ~LINK_STATUS_LINK_UP;\r\n}\r\n} else\r\nbnx2x_umac_enable(params, vars, 0);\r\nbnx2x_set_led(params, vars,\r\nLED_MODE_OPER, vars->line_speed);\r\nif ((vars->eee_status & SHMEM_EEE_ACTIVE_BIT) &&\r\n(vars->eee_status & SHMEM_EEE_LPI_REQUESTED_BIT)) {\r\nDP(NETIF_MSG_LINK, "Enabling LPI assertion\n");\r\nREG_WR(bp, MISC_REG_CPMU_LP_FW_ENABLE_P0 +\r\n(params->port << 2), 1);\r\nREG_WR(bp, MISC_REG_CPMU_LP_DR_ENABLE, 1);\r\nREG_WR(bp, MISC_REG_CPMU_LP_MASK_ENT_P0 +\r\n(params->port << 2), 0xfc20);\r\n}\r\n}\r\nif ((CHIP_IS_E1x(bp) ||\r\nCHIP_IS_E2(bp))) {\r\nif (link_10g) {\r\nif (bnx2x_bmac_enable(params, vars, 0, 1) ==\r\n-ESRCH) {\r\nDP(NETIF_MSG_LINK, "Found errors on BMAC\n");\r\nvars->link_up = 0;\r\nvars->phy_flags |= PHY_HALF_OPEN_CONN_FLAG;\r\nvars->link_status &= ~LINK_STATUS_LINK_UP;\r\n}\r\nbnx2x_set_led(params, vars,\r\nLED_MODE_OPER, SPEED_10000);\r\n} else {\r\nrc = bnx2x_emac_program(params, vars);\r\nbnx2x_emac_enable(params, vars, 0);\r\nif ((vars->link_status &\r\nLINK_STATUS_AUTO_NEGOTIATE_COMPLETE)\r\n&& (!(vars->phy_flags & PHY_SGMII_FLAG)) &&\r\nSINGLE_MEDIA_DIRECT(params))\r\nbnx2x_set_gmii_tx_driver(params);\r\n}\r\n}\r\nif (CHIP_IS_E1x(bp))\r\nrc |= bnx2x_pbf_update(params, vars->flow_ctrl,\r\nvars->line_speed);\r\nREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + port*4, 0);\r\nbnx2x_update_mng(params, vars->link_status);\r\nbnx2x_update_mng_eee(params, vars->eee_status);\r\nfor (phy_idx = INT_PHY; phy_idx < MAX_PHYS; phy_idx++) {\r\nif (params->phy[phy_idx].flags & FLAGS_TX_ERROR_CHECK) {\r\nbnx2x_check_half_open_conn(params, vars, 0);\r\nbreak;\r\n}\r\n}\r\nmsleep(20);\r\nreturn rc;\r\n}\r\nint bnx2x_link_update(struct link_params *params, struct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nstruct link_vars phy_vars[MAX_PHYS];\r\nu8 port = params->port;\r\nu8 link_10g_plus, phy_index;\r\nu8 ext_phy_link_up = 0, cur_link_up;\r\nint rc = 0;\r\nu8 is_mi_int = 0;\r\nu16 ext_phy_line_speed = 0, prev_line_speed = vars->line_speed;\r\nu8 active_external_phy = INT_PHY;\r\nvars->phy_flags &= ~PHY_HALF_OPEN_CONN_FLAG;\r\nvars->link_status &= ~LINK_UPDATE_MASK;\r\nfor (phy_index = INT_PHY; phy_index < params->num_phys;\r\nphy_index++) {\r\nphy_vars[phy_index].flow_ctrl = 0;\r\nphy_vars[phy_index].link_status = 0;\r\nphy_vars[phy_index].line_speed = 0;\r\nphy_vars[phy_index].duplex = DUPLEX_FULL;\r\nphy_vars[phy_index].phy_link_up = 0;\r\nphy_vars[phy_index].link_up = 0;\r\nphy_vars[phy_index].fault_detected = 0;\r\nphy_vars[phy_index].eee_status = vars->eee_status;\r\n}\r\nif (USES_WARPCORE(bp))\r\nbnx2x_set_aer_mmd(params, &params->phy[INT_PHY]);\r\nDP(NETIF_MSG_LINK, "port %x, XGXS?%x, int_status 0x%x\n",\r\nport, (vars->phy_flags & PHY_XGXS_FLAG),\r\nREG_RD(bp, NIG_REG_STATUS_INTERRUPT_PORT0 + port*4));\r\nis_mi_int = (u8)(REG_RD(bp, NIG_REG_EMAC0_STATUS_MISC_MI_INT +\r\nport*0x18) > 0);\r\nDP(NETIF_MSG_LINK, "int_mask 0x%x MI_INT %x, SERDES_LINK %x\n",\r\nREG_RD(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4),\r\nis_mi_int,\r\nREG_RD(bp, NIG_REG_SERDES0_STATUS_LINK_STATUS + port*0x3c));\r\nDP(NETIF_MSG_LINK, " 10G %x, XGXS_LINK %x\n",\r\nREG_RD(bp, NIG_REG_XGXS0_STATUS_LINK10G + port*0x68),\r\nREG_RD(bp, NIG_REG_XGXS0_STATUS_LINK_STATUS + port*0x68));\r\nif (!CHIP_IS_E3(bp))\r\nREG_WR(bp, NIG_REG_NIG_EMAC0_EN + port*4, 0);\r\nfor (phy_index = EXT_PHY1; phy_index < params->num_phys;\r\nphy_index++) {\r\nstruct bnx2x_phy *phy = &params->phy[phy_index];\r\nif (!phy->read_status)\r\ncontinue;\r\ncur_link_up = phy->read_status(phy, params,\r\n&phy_vars[phy_index]);\r\nif (cur_link_up) {\r\nDP(NETIF_MSG_LINK, "phy in index %d link is up\n",\r\nphy_index);\r\n} else {\r\nDP(NETIF_MSG_LINK, "phy in index %d link is down\n",\r\nphy_index);\r\ncontinue;\r\n}\r\nif (!ext_phy_link_up) {\r\next_phy_link_up = 1;\r\nactive_external_phy = phy_index;\r\n} else {\r\nswitch (bnx2x_phy_selection(params)) {\r\ncase PORT_HW_CFG_PHY_SELECTION_HARDWARE_DEFAULT:\r\ncase PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY:\r\nactive_external_phy = EXT_PHY1;\r\nbreak;\r\ncase PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY:\r\nactive_external_phy = EXT_PHY2;\r\nbreak;\r\ndefault:\r\nDP(NETIF_MSG_LINK, "Invalid link indication"\r\n"mpc=0x%x. DISABLING LINK !!!\n",\r\nparams->multi_phy_config);\r\next_phy_link_up = 0;\r\nbreak;\r\n}\r\n}\r\n}\r\nprev_line_speed = vars->line_speed;\r\nif (params->phy[INT_PHY].read_status)\r\nparams->phy[INT_PHY].read_status(\r\n&params->phy[INT_PHY],\r\nparams, vars);\r\nif (active_external_phy > INT_PHY) {\r\nvars->flow_ctrl = phy_vars[active_external_phy].flow_ctrl;\r\nvars->link_status |= phy_vars[active_external_phy].link_status;\r\nif (active_external_phy == EXT_PHY1) {\r\nif (params->phy[EXT_PHY2].phy_specific_func) {\r\nDP(NETIF_MSG_LINK,\r\n"Disabling TX on EXT_PHY2\n");\r\nparams->phy[EXT_PHY2].phy_specific_func(\r\n&params->phy[EXT_PHY2],\r\nparams, DISABLE_TX);\r\n}\r\n}\r\next_phy_line_speed = phy_vars[active_external_phy].line_speed;\r\nvars->duplex = phy_vars[active_external_phy].duplex;\r\nif (params->phy[active_external_phy].supported &\r\nSUPPORTED_FIBRE)\r\nvars->link_status |= LINK_STATUS_SERDES_LINK;\r\nelse\r\nvars->link_status &= ~LINK_STATUS_SERDES_LINK;\r\nvars->eee_status = phy_vars[active_external_phy].eee_status;\r\nDP(NETIF_MSG_LINK, "Active external phy selected: %x\n",\r\nactive_external_phy);\r\n}\r\nfor (phy_index = EXT_PHY1; phy_index < params->num_phys;\r\nphy_index++) {\r\nif (params->phy[phy_index].flags &\r\nFLAGS_REARM_LATCH_SIGNAL) {\r\nbnx2x_rearm_latch_signal(bp, port,\r\nphy_index ==\r\nactive_external_phy);\r\nbreak;\r\n}\r\n}\r\nDP(NETIF_MSG_LINK, "vars->flow_ctrl = 0x%x, vars->link_status = 0x%x,"\r\n" ext_phy_line_speed = %d\n", vars->flow_ctrl,\r\nvars->link_status, ext_phy_line_speed);\r\nif (vars->phy_link_up) {\r\nif (!(SINGLE_MEDIA_DIRECT(params)) && ext_phy_link_up &&\r\n(ext_phy_line_speed != vars->line_speed)) {\r\nDP(NETIF_MSG_LINK, "Internal link speed %d is"\r\n" different than the external"\r\n" link speed %d\n", vars->line_speed,\r\next_phy_line_speed);\r\nvars->phy_link_up = 0;\r\n} else if (prev_line_speed != vars->line_speed) {\r\nREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4,\r\n0);\r\nusleep_range(1000, 2000);\r\n}\r\n}\r\nlink_10g_plus = (vars->line_speed >= SPEED_10000);\r\nbnx2x_link_int_ack(params, vars, link_10g_plus);\r\nif (!(SINGLE_MEDIA_DIRECT(params))) {\r\nDP(NETIF_MSG_LINK, "ext_phy_link_up = %d, int_link_up = %d,"\r\n" init_preceding = %d\n", ext_phy_link_up,\r\nvars->phy_link_up,\r\nparams->phy[EXT_PHY1].flags &\r\nFLAGS_INIT_XGXS_FIRST);\r\nif (!(params->phy[EXT_PHY1].flags &\r\nFLAGS_INIT_XGXS_FIRST)\r\n&& ext_phy_link_up && !vars->phy_link_up) {\r\nvars->line_speed = ext_phy_line_speed;\r\nif (vars->line_speed < SPEED_1000)\r\nvars->phy_flags |= PHY_SGMII_FLAG;\r\nelse\r\nvars->phy_flags &= ~PHY_SGMII_FLAG;\r\nif (params->phy[INT_PHY].config_init)\r\nparams->phy[INT_PHY].config_init(\r\n&params->phy[INT_PHY], params,\r\nvars);\r\n}\r\n}\r\nvars->link_up = (vars->phy_link_up &&\r\n(ext_phy_link_up ||\r\nSINGLE_MEDIA_DIRECT(params)) &&\r\n(phy_vars[active_external_phy].fault_detected == 0));\r\nif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED)\r\nvars->link_status |= LINK_STATUS_PFC_ENABLED;\r\nelse\r\nvars->link_status &= ~LINK_STATUS_PFC_ENABLED;\r\nif (vars->link_up)\r\nrc = bnx2x_update_link_up(params, vars, link_10g_plus);\r\nelse\r\nrc = bnx2x_update_link_down(params, vars);\r\nif (params->feature_config_flags & FEATURE_CONFIG_BC_SUPPORTS_AFEX)\r\nbnx2x_fw_command(bp, DRV_MSG_CODE_LINK_STATUS_CHANGED, 0);\r\nreturn rc;\r\n}\r\nvoid bnx2x_ext_phy_hw_reset(struct bnx2x *bp, u8 port)\r\n{\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,\r\nMISC_REGISTERS_GPIO_OUTPUT_LOW, port);\r\nusleep_range(1000, 2000);\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,\r\nMISC_REGISTERS_GPIO_OUTPUT_HIGH, port);\r\n}\r\nstatic void bnx2x_save_spirom_version(struct bnx2x *bp, u8 port,\r\nu32 spirom_ver, u32 ver_addr)\r\n{\r\nDP(NETIF_MSG_LINK, "FW version 0x%x:0x%x for port %d\n",\r\n(u16)(spirom_ver>>16), (u16)spirom_ver, port);\r\nif (ver_addr)\r\nREG_WR(bp, ver_addr, spirom_ver);\r\n}\r\nstatic void bnx2x_save_bcm_spirom_ver(struct bnx2x *bp,\r\nstruct bnx2x_phy *phy,\r\nu8 port)\r\n{\r\nu16 fw_ver1, fw_ver2;\r\nbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_ROM_VER1, &fw_ver1);\r\nbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_ROM_VER2, &fw_ver2);\r\nbnx2x_save_spirom_version(bp, port, (u32)(fw_ver1<<16 | fw_ver2),\r\nphy->ver_addr);\r\n}\r\nstatic void bnx2x_ext_phy_10G_an_resolve(struct bnx2x *bp,\r\nstruct bnx2x_phy *phy,\r\nstruct link_vars *vars)\r\n{\r\nu16 val;\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD,\r\nMDIO_AN_REG_STATUS, &val);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD,\r\nMDIO_AN_REG_STATUS, &val);\r\nif (val & (1<<5))\r\nvars->link_status |= LINK_STATUS_AUTO_NEGOTIATE_COMPLETE;\r\nif ((val & (1<<0)) == 0)\r\nvars->link_status |= LINK_STATUS_PARALLEL_DETECTION_USED;\r\n}\r\nstatic void bnx2x_8073_resolve_fc(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nif (phy->req_line_speed == SPEED_10 ||\r\nphy->req_line_speed == SPEED_100) {\r\nvars->flow_ctrl = phy->req_flow_ctrl;\r\nreturn;\r\n}\r\nif (bnx2x_ext_phy_resolve_fc(phy, params, vars) &&\r\n(vars->flow_ctrl == BNX2X_FLOW_CTRL_NONE)) {\r\nu16 pause_result;\r\nu16 ld_pause;\r\nu16 lp_pause;\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD,\r\nMDIO_AN_REG_CL37_FC_LD, &ld_pause);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD,\r\nMDIO_AN_REG_CL37_FC_LP, &lp_pause);\r\npause_result = (ld_pause &\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) >> 5;\r\npause_result |= (lp_pause &\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) >> 7;\r\nbnx2x_pause_resolve(vars, pause_result);\r\nDP(NETIF_MSG_LINK, "Ext PHY CL37 pause result 0x%x\n",\r\npause_result);\r\n}\r\n}\r\nstatic int bnx2x_8073_8727_external_rom_boot(struct bnx2x *bp,\r\nstruct bnx2x_phy *phy,\r\nu8 port)\r\n{\r\nu32 count = 0;\r\nu16 fw_ver1, fw_msgout;\r\nint rc = 0;\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_GEN_CTRL,\r\n0x0001);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_GEN_CTRL,\r\n0x008c);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_MISC_CTRL1, 0x0001);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_GEN_CTRL,\r\nMDIO_PMA_REG_GEN_CTRL_ROM_MICRO_RESET);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_GEN_CTRL,\r\nMDIO_PMA_REG_GEN_CTRL_ROM_RESET_INTERNAL_MP);\r\nmsleep(100);\r\ndo {\r\ncount++;\r\nif (count > 300) {\r\nDP(NETIF_MSG_LINK,\r\n"bnx2x_8073_8727_external_rom_boot port %x:"\r\n"Download failed. fw version = 0x%x\n",\r\nport, fw_ver1);\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_ROM_VER1, &fw_ver1);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_M8051_MSGOUT_REG, &fw_msgout);\r\nusleep_range(1000, 2000);\r\n} while (fw_ver1 == 0 || fw_ver1 == 0x4321 ||\r\n((fw_msgout & 0xff) != 0x03 && (phy->type ==\r\nPORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073)));\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_MISC_CTRL1, 0x0000);\r\nbnx2x_save_bcm_spirom_ver(bp, phy, port);\r\nDP(NETIF_MSG_LINK,\r\n"bnx2x_8073_8727_external_rom_boot port %x:"\r\n"Download complete. fw version = 0x%x\n",\r\nport, fw_ver1);\r\nreturn rc;\r\n}\r\nstatic int bnx2x_8073_is_snr_needed(struct bnx2x *bp, struct bnx2x_phy *phy)\r\n{\r\nu16 val;\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8073_CHIP_REV, &val);\r\nif (val != 1) {\r\nreturn 0;\r\n}\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_ROM_VER2, &val);\r\nif (val != 0x102)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int bnx2x_8073_xaui_wa(struct bnx2x *bp, struct bnx2x_phy *phy)\r\n{\r\nu16 val, cnt, cnt1 ;\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8073_CHIP_REV, &val);\r\nif (val > 0) {\r\nreturn 0;\r\n}\r\nfor (cnt = 0; cnt < 1000; cnt++) {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8073_SPEED_LINK_STATUS,\r\n&val);\r\nif (!(val & (1<<14)) || !(val & (1<<13))) {\r\nDP(NETIF_MSG_LINK, "XAUI work-around not required\n");\r\nreturn 0;\r\n} else if (!(val & (1<<15))) {\r\nDP(NETIF_MSG_LINK, "bit 15 went off\n");\r\nfor (cnt1 = 0; cnt1 < 1000; cnt1++) {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8073_XAUI_WA, &val);\r\nif (val & (1<<15)) {\r\nDP(NETIF_MSG_LINK,\r\n"XAUI workaround has completed\n");\r\nreturn 0;\r\n}\r\nusleep_range(3000, 6000);\r\n}\r\nbreak;\r\n}\r\nusleep_range(3000, 6000);\r\n}\r\nDP(NETIF_MSG_LINK, "Warning: XAUI work-around timeout !!!\n");\r\nreturn -EINVAL;\r\n}\r\nstatic void bnx2x_807x_force_10G(struct bnx2x *bp, struct bnx2x_phy *phy)\r\n{\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0x2040);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_10G_CTRL2, 0x000b);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_BCM_CTRL, 0x0000);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0x0000);\r\n}\r\nstatic void bnx2x_8073_set_pause_cl37(struct link_params *params,\r\nstruct bnx2x_phy *phy,\r\nstruct link_vars *vars)\r\n{\r\nu16 cl37_val;\r\nstruct bnx2x *bp = params->bp;\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LD, &cl37_val);\r\ncl37_val &= ~MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH;\r\nbnx2x_calc_ieee_aneg_adv(phy, params, &vars->ieee_fc);\r\nif ((vars->ieee_fc &\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_SYMMETRIC) ==\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_SYMMETRIC) {\r\ncl37_val |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_SYMMETRIC;\r\n}\r\nif ((vars->ieee_fc &\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) ==\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) {\r\ncl37_val |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC;\r\n}\r\nif ((vars->ieee_fc &\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) ==\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) {\r\ncl37_val |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH;\r\n}\r\nDP(NETIF_MSG_LINK,\r\n"Ext phy AN advertize cl37 0x%x\n", cl37_val);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LD, cl37_val);\r\nmsleep(500);\r\n}\r\nstatic void bnx2x_8073_specific_func(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nu32 action)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nswitch (action) {\r\ncase PHY_INIT:\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXCTRL, (1<<2));\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 0x0004);\r\nbreak;\r\n}\r\n}\r\nstatic int bnx2x_8073_config_init(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 val = 0, tmp1;\r\nu8 gpio_port;\r\nDP(NETIF_MSG_LINK, "Init 8073\n");\r\nif (CHIP_IS_E2(bp))\r\ngpio_port = BP_PATH(bp);\r\nelse\r\ngpio_port = params->port;\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\r\nMISC_REGISTERS_GPIO_OUTPUT_HIGH, gpio_port);\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,\r\nMISC_REGISTERS_GPIO_OUTPUT_HIGH, gpio_port);\r\nbnx2x_8073_specific_func(phy, params, PHY_INIT);\r\nbnx2x_8073_set_pause_cl37(params, phy, vars);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_M8051_MSGOUT_REG, &tmp1);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXSTAT, &tmp1);\r\nDP(NETIF_MSG_LINK, "Before rom RX_ALARM(port1): 0x%x\n", tmp1);\r\nif (params->lane_config & PORT_HW_CFG_SWAP_PHY_POLARITY_ENABLED) {\r\nDP(NETIF_MSG_LINK, "Swapping polarity for the 8073\n");\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8073_OPT_DIGITAL_CTRL, &val);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8073_OPT_DIGITAL_CTRL,\r\n(val | (3<<9)));\r\n}\r\nif (REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region, dev_info.\r\nport_hw_config[params->port].default_cfg)) &\r\nPORT_HW_CFG_ENABLE_BAM_ON_KR_ENABLED) {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD,\r\nMDIO_AN_REG_8073_BAM, &val);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD,\r\nMDIO_AN_REG_8073_BAM, val | 1);\r\nDP(NETIF_MSG_LINK, "Enable CL37 BAM on KR\n");\r\n}\r\nif (params->loopback_mode == LOOPBACK_EXT) {\r\nbnx2x_807x_force_10G(bp, phy);\r\nDP(NETIF_MSG_LINK, "Forced speed 10G on 807X\n");\r\nreturn 0;\r\n} else {\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_BCM_CTRL, 0x0002);\r\n}\r\nif (phy->req_line_speed != SPEED_AUTO_NEG) {\r\nif (phy->req_line_speed == SPEED_10000) {\r\nval = (1<<7);\r\n} else if (phy->req_line_speed == SPEED_2500) {\r\nval = (1<<5);\r\n} else\r\nval = (1<<5);\r\n} else {\r\nval = 0;\r\nif (phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10G)\r\nval |= (1<<7);\r\nif (phy->speed_cap_mask &\r\n(PORT_HW_CFG_SPEED_CAPABILITY_D0_1G |\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G))\r\nval |= (1<<5);\r\nDP(NETIF_MSG_LINK, "807x autoneg val = 0x%x\n", val);\r\n}\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_ADV, val);\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_8073_2_5G, &tmp1);\r\nif (((phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G) &&\r\n(phy->req_line_speed == SPEED_AUTO_NEG)) ||\r\n(phy->req_line_speed == SPEED_2500)) {\r\nu16 phy_ver;\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_8073_CHIP_REV,\r\n&phy_ver);\r\nDP(NETIF_MSG_LINK, "Add 2.5G\n");\r\nif (phy_ver > 0)\r\ntmp1 |= 1;\r\nelse\r\ntmp1 &= 0xfffe;\r\n} else {\r\nDP(NETIF_MSG_LINK, "Disable 2.5G\n");\r\ntmp1 &= 0xfffe;\r\n}\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_8073_2_5G, tmp1);\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LD, &tmp1);\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LD,\r\n(tmp1 | ((phy->req_duplex == DUPLEX_FULL) ?\r\n0x20 : 0x40)));\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_CL37_AN, 0x1000);\r\nif (bnx2x_8073_is_snr_needed(bp, phy))\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_EDC_FFE_MAIN,\r\n0xFB0C);\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_ADV2, &tmp1);\r\ntmp1 |= (1<<15);\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_ADV2, tmp1);\r\nbnx2x_ext_phy_set_pause(params, phy, vars);\r\nmsleep(500);\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0x1200);\r\nDP(NETIF_MSG_LINK, "807x Autoneg Restart: Advertise 1G=%x, 10G=%x\n",\r\n((val & (1<<5)) > 0), ((val & (1<<7)) > 0));\r\nreturn 0;\r\n}\r\nstatic u8 bnx2x_8073_read_status(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 link_up = 0;\r\nu16 val1, val2;\r\nu16 link_status = 0;\r\nu16 an1000_status = 0;\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_STAT, &val1);\r\nDP(NETIF_MSG_LINK, "8703 LASI status 0x%x\n", val1);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PCS_DEVAD, MDIO_PCS_REG_STATUS, &val2);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PCS_DEVAD, MDIO_PCS_REG_STATUS, &val1);\r\nDP(NETIF_MSG_LINK, "807x PCS status 0x%x->0x%x\n", val2, val1);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_M8051_MSGOUT_REG, &val1);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXSTAT, &val2);\r\nDP(NETIF_MSG_LINK, "KR 0x9003 0x%x\n", val2);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PCS_DEVAD, MDIO_PCS_REG_STATUS, &val2);\r\nDP(NETIF_MSG_LINK, "KR PCS status 0x%x\n", val2);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_STATUS, &val2);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_STATUS, &val1);\r\nlink_up = ((val1 & 4) == 4);\r\nDP(NETIF_MSG_LINK, "PMA_REG_STATUS=0x%x\n", val1);\r\nif (link_up &&\r\n((phy->req_line_speed != SPEED_10000))) {\r\nif (bnx2x_8073_xaui_wa(bp, phy) != 0)\r\nreturn 0;\r\n}\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_LINK_STATUS, &an1000_status);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_LINK_STATUS, &an1000_status);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_STATUS, &val2);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_STATUS, &val1);\r\nDP(NETIF_MSG_LINK, "KR PMA status 0x%x->0x%x,"\r\n"an_link_status=0x%x\n", val2, val1, an1000_status);\r\nlink_up = (((val1 & 4) == 4) || (an1000_status & (1<<1)));\r\nif (link_up && bnx2x_8073_is_snr_needed(bp, phy)) {\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_PLL_BANDWIDTH,\r\n0x26BC);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_CDR_BANDWIDTH,\r\n0x0333);\r\n}\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_8073_SPEED_LINK_STATUS,\r\n&link_status);\r\nif ((link_status & (1<<2)) && (!(link_status & (1<<15)))) {\r\nlink_up = 1;\r\nvars->line_speed = SPEED_10000;\r\nDP(NETIF_MSG_LINK, "port %x: External link up in 10G\n",\r\nparams->port);\r\n} else if ((link_status & (1<<1)) && (!(link_status & (1<<14)))) {\r\nlink_up = 1;\r\nvars->line_speed = SPEED_2500;\r\nDP(NETIF_MSG_LINK, "port %x: External link up in 2.5G\n",\r\nparams->port);\r\n} else if ((link_status & (1<<0)) && (!(link_status & (1<<13)))) {\r\nlink_up = 1;\r\nvars->line_speed = SPEED_1000;\r\nDP(NETIF_MSG_LINK, "port %x: External link up in 1G\n",\r\nparams->port);\r\n} else {\r\nlink_up = 0;\r\nDP(NETIF_MSG_LINK, "port %x: External link is down\n",\r\nparams->port);\r\n}\r\nif (link_up) {\r\nif (params->lane_config &\r\nPORT_HW_CFG_SWAP_PHY_POLARITY_ENABLED) {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_XS_DEVAD,\r\nMDIO_XS_REG_8073_RX_CTRL_PCIE, &val1);\r\nif (vars->line_speed == SPEED_1000) {\r\nDP(NETIF_MSG_LINK, "Swapping 1G polarity for"\r\n"the 8073\n");\r\nval1 |= (1<<3);\r\n} else\r\nval1 &= ~(1<<3);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_XS_DEVAD,\r\nMDIO_XS_REG_8073_RX_CTRL_PCIE,\r\nval1);\r\n}\r\nbnx2x_ext_phy_10G_an_resolve(bp, phy, vars);\r\nbnx2x_8073_resolve_fc(phy, params, vars);\r\nvars->duplex = DUPLEX_FULL;\r\n}\r\nif (vars->link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE) {\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_AN_REG_LP_AUTO_NEG2, &val1);\r\nif (val1 & (1<<5))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE;\r\nif (val1 & (1<<7))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\r\n}\r\nreturn link_up;\r\n}\r\nstatic void bnx2x_8073_link_reset(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 gpio_port;\r\nif (CHIP_IS_E2(bp))\r\ngpio_port = BP_PATH(bp);\r\nelse\r\ngpio_port = params->port;\r\nDP(NETIF_MSG_LINK, "Setting 8073 port %d into low power mode\n",\r\ngpio_port);\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\r\nMISC_REGISTERS_GPIO_OUTPUT_LOW,\r\ngpio_port);\r\n}\r\nstatic int bnx2x_8705_config_init(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nDP(NETIF_MSG_LINK, "init 8705\n");\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\r\nMISC_REGISTERS_GPIO_OUTPUT_HIGH, params->port);\r\nbnx2x_ext_phy_hw_reset(bp, params->port);\r\nbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0xa040);\r\nbnx2x_wait_reset_complete(bp, phy, params);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_MISC_CTRL, 0x8288);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_PHY_IDENTIFIER, 0x7fbf);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_CMU_PLL_BYPASS, 0x0100);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_WIS_DEVAD, MDIO_WIS_REG_LASI_CNTL, 0x1);\r\nbnx2x_save_spirom_version(bp, params->port, params->shmem_base, 0);\r\nreturn 0;\r\n}\r\nstatic u8 bnx2x_8705_read_status(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nu8 link_up = 0;\r\nu16 val1, rx_sd;\r\nstruct bnx2x *bp = params->bp;\r\nDP(NETIF_MSG_LINK, "read status 8705\n");\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_WIS_DEVAD, MDIO_WIS_REG_LASI_STATUS, &val1);\r\nDP(NETIF_MSG_LINK, "8705 LASI status 0x%x\n", val1);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_WIS_DEVAD, MDIO_WIS_REG_LASI_STATUS, &val1);\r\nDP(NETIF_MSG_LINK, "8705 LASI status 0x%x\n", val1);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_RX_SD, &rx_sd);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, 0xc809, &val1);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, 0xc809, &val1);\r\nDP(NETIF_MSG_LINK, "8705 1.c809 val=0x%x\n", val1);\r\nlink_up = ((rx_sd & 0x1) && (val1 & (1<<9)) && ((val1 & (1<<8)) == 0));\r\nif (link_up) {\r\nvars->line_speed = SPEED_10000;\r\nbnx2x_ext_phy_resolve_fc(phy, params, vars);\r\n}\r\nreturn link_up;\r\n}\r\nstatic void bnx2x_set_disable_pmd_transmit(struct link_params *params,\r\nstruct bnx2x_phy *phy,\r\nu8 pmd_dis)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nif (pmd_dis) {\r\nif (params->feature_config_flags &\r\nFEATURE_CONFIG_BC_SUPPORTS_SFP_TX_DISABLED)\r\nDP(NETIF_MSG_LINK, "Disabling PMD transmitter\n");\r\nelse {\r\nDP(NETIF_MSG_LINK, "NOT disabling PMD transmitter\n");\r\nreturn;\r\n}\r\n} else\r\nDP(NETIF_MSG_LINK, "Enabling PMD transmitter\n");\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_TX_DISABLE, pmd_dis);\r\n}\r\nstatic u8 bnx2x_get_gpio_port(struct link_params *params)\r\n{\r\nu8 gpio_port;\r\nu32 swap_val, swap_override;\r\nstruct bnx2x *bp = params->bp;\r\nif (CHIP_IS_E2(bp))\r\ngpio_port = BP_PATH(bp);\r\nelse\r\ngpio_port = params->port;\r\nswap_val = REG_RD(bp, NIG_REG_PORT_SWAP);\r\nswap_override = REG_RD(bp, NIG_REG_STRAP_OVERRIDE);\r\nreturn gpio_port ^ (swap_val && swap_override);\r\n}\r\nstatic void bnx2x_sfp_e1e2_set_transmitter(struct link_params *params,\r\nstruct bnx2x_phy *phy,\r\nu8 tx_en)\r\n{\r\nu16 val;\r\nu8 port = params->port;\r\nstruct bnx2x *bp = params->bp;\r\nu32 tx_en_mode;\r\ntx_en_mode = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[port].sfp_ctrl)) &\r\nPORT_HW_CFG_TX_LASER_MASK;\r\nDP(NETIF_MSG_LINK, "Setting transmitter tx_en=%x for port %x "\r\n"mode = %x\n", tx_en, port, tx_en_mode);\r\nswitch (tx_en_mode) {\r\ncase PORT_HW_CFG_TX_LASER_MDIO:\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_PHY_IDENTIFIER,\r\n&val);\r\nif (tx_en)\r\nval &= ~(1<<15);\r\nelse\r\nval |= (1<<15);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_PHY_IDENTIFIER,\r\nval);\r\nbreak;\r\ncase PORT_HW_CFG_TX_LASER_GPIO0:\r\ncase PORT_HW_CFG_TX_LASER_GPIO1:\r\ncase PORT_HW_CFG_TX_LASER_GPIO2:\r\ncase PORT_HW_CFG_TX_LASER_GPIO3:\r\n{\r\nu16 gpio_pin;\r\nu8 gpio_port, gpio_mode;\r\nif (tx_en)\r\ngpio_mode = MISC_REGISTERS_GPIO_OUTPUT_HIGH;\r\nelse\r\ngpio_mode = MISC_REGISTERS_GPIO_OUTPUT_LOW;\r\ngpio_pin = tx_en_mode - PORT_HW_CFG_TX_LASER_GPIO0;\r\ngpio_port = bnx2x_get_gpio_port(params);\r\nbnx2x_set_gpio(bp, gpio_pin, gpio_mode, gpio_port);\r\nbreak;\r\n}\r\ndefault:\r\nDP(NETIF_MSG_LINK, "Invalid TX_LASER_MDIO 0x%x\n", tx_en_mode);\r\nbreak;\r\n}\r\n}\r\nstatic void bnx2x_sfp_set_transmitter(struct link_params *params,\r\nstruct bnx2x_phy *phy,\r\nu8 tx_en)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nDP(NETIF_MSG_LINK, "Setting SFP+ transmitter to %d\n", tx_en);\r\nif (CHIP_IS_E3(bp))\r\nbnx2x_sfp_e3_set_transmitter(params, phy, tx_en);\r\nelse\r\nbnx2x_sfp_e1e2_set_transmitter(params, phy, tx_en);\r\n}\r\nstatic int bnx2x_8726_read_sfp_module_eeprom(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nu8 dev_addr, u16 addr, u8 byte_cnt,\r\nu8 *o_buf, u8 is_init)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 val = 0;\r\nu16 i;\r\nif (byte_cnt > SFP_EEPROM_PAGE_SIZE) {\r\nDP(NETIF_MSG_LINK,\r\n"Reading from eeprom is limited to 0xf\n");\r\nreturn -EINVAL;\r\n}\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_SFP_TWO_WIRE_BYTE_CNT,\r\n(byte_cnt | (dev_addr << 8)));\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_SFP_TWO_WIRE_MEM_ADDR,\r\naddr);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_SFP_TWO_WIRE_CTRL,\r\n0x2c0f);\r\nfor (i = 0; i < 100; i++) {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_SFP_TWO_WIRE_CTRL, &val);\r\nif ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) ==\r\nMDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE)\r\nbreak;\r\nudelay(5);\r\n}\r\nif ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) !=\r\nMDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE) {\r\nDP(NETIF_MSG_LINK,\r\n"Got bad status 0x%x when reading from SFP+ EEPROM\n",\r\n(val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK));\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < byte_cnt; i++) {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8726_TWO_WIRE_DATA_BUF + i, &val);\r\no_buf[i] = (u8)(val & MDIO_PMA_REG_8726_TWO_WIRE_DATA_MASK);\r\n}\r\nfor (i = 0; i < 100; i++) {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_SFP_TWO_WIRE_CTRL, &val);\r\nif ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) ==\r\nMDIO_PMA_REG_SFP_TWO_WIRE_STATUS_IDLE)\r\nreturn 0;\r\nusleep_range(1000, 2000);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void bnx2x_warpcore_power_module(struct link_params *params,\r\nu8 power)\r\n{\r\nu32 pin_cfg;\r\nstruct bnx2x *bp = params->bp;\r\npin_cfg = (REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[params->port].e3_sfp_ctrl)) &\r\nPORT_HW_CFG_E3_PWR_DIS_MASK) >>\r\nPORT_HW_CFG_E3_PWR_DIS_SHIFT;\r\nif (pin_cfg == PIN_CFG_NA)\r\nreturn;\r\nDP(NETIF_MSG_LINK, "Setting SFP+ module power to %d using pin cfg %d\n",\r\npower, pin_cfg);\r\nbnx2x_set_cfg_pin(bp, pin_cfg, power ^ 1);\r\n}\r\nstatic int bnx2x_warpcore_read_sfp_module_eeprom(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nu8 dev_addr,\r\nu16 addr, u8 byte_cnt,\r\nu8 *o_buf, u8 is_init)\r\n{\r\nint rc = 0;\r\nu8 i, j = 0, cnt = 0;\r\nu32 data_array[4];\r\nu16 addr32;\r\nstruct bnx2x *bp = params->bp;\r\nif (byte_cnt > SFP_EEPROM_PAGE_SIZE) {\r\nDP(NETIF_MSG_LINK,\r\n"Reading from eeprom is limited to 16 bytes\n");\r\nreturn -EINVAL;\r\n}\r\naddr32 = addr & (~0x3);\r\ndo {\r\nif ((!is_init) && (cnt == I2C_WA_PWR_ITER)) {\r\nbnx2x_warpcore_power_module(params, 0);\r\nusleep_range(1000, 2000);\r\nbnx2x_warpcore_power_module(params, 1);\r\n}\r\nrc = bnx2x_bsc_read(params, bp, dev_addr, addr32, 0, byte_cnt,\r\ndata_array);\r\n} while ((rc != 0) && (++cnt < I2C_WA_RETRY_CNT));\r\nif (rc == 0) {\r\nfor (i = (addr - addr32); i < byte_cnt + (addr - addr32); i++) {\r\no_buf[j] = *((u8 *)data_array + i);\r\nj++;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int bnx2x_8727_read_sfp_module_eeprom(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nu8 dev_addr, u16 addr, u8 byte_cnt,\r\nu8 *o_buf, u8 is_init)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 val, i;\r\nif (byte_cnt > SFP_EEPROM_PAGE_SIZE) {\r\nDP(NETIF_MSG_LINK,\r\n"Reading from eeprom is limited to 0xf\n");\r\nreturn -EINVAL;\r\n}\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8727_TWO_WIRE_SLAVE_ADDR,\r\n((dev_addr << 8) | 1));\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_SFP_TWO_WIRE_CTRL,\r\n&val);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_SFP_TWO_WIRE_BYTE_CNT,\r\n((byte_cnt < 2) ? 2 : byte_cnt));\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_SFP_TWO_WIRE_MEM_ADDR,\r\naddr);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\n0x8004,\r\nMDIO_PMA_REG_8727_TWO_WIRE_DATA_BUF);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_SFP_TWO_WIRE_CTRL,\r\n0x8002);\r\nusleep_range(1000, 2000);\r\nfor (i = 0; i < 100; i++) {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_SFP_TWO_WIRE_CTRL, &val);\r\nif ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) ==\r\nMDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE)\r\nbreak;\r\nudelay(5);\r\n}\r\nif ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) !=\r\nMDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE) {\r\nDP(NETIF_MSG_LINK,\r\n"Got bad status 0x%x when reading from SFP+ EEPROM\n",\r\n(val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK));\r\nreturn -EFAULT;\r\n}\r\nfor (i = 0; i < byte_cnt; i++) {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8727_TWO_WIRE_DATA_BUF + i, &val);\r\no_buf[i] = (u8)(val & MDIO_PMA_REG_8727_TWO_WIRE_DATA_MASK);\r\n}\r\nfor (i = 0; i < 100; i++) {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_SFP_TWO_WIRE_CTRL, &val);\r\nif ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) ==\r\nMDIO_PMA_REG_SFP_TWO_WIRE_STATUS_IDLE)\r\nreturn 0;\r\nusleep_range(1000, 2000);\r\n}\r\nreturn -EINVAL;\r\n}\r\nint bnx2x_read_sfp_module_eeprom(struct bnx2x_phy *phy,\r\nstruct link_params *params, u8 dev_addr,\r\nu16 addr, u16 byte_cnt, u8 *o_buf)\r\n{\r\nint rc = 0;\r\nstruct bnx2x *bp = params->bp;\r\nu8 xfer_size;\r\nu8 *user_data = o_buf;\r\nread_sfp_module_eeprom_func_p read_func;\r\nif ((dev_addr != 0xa0) && (dev_addr != 0xa2)) {\r\nDP(NETIF_MSG_LINK, "invalid dev_addr 0x%x\n", dev_addr);\r\nreturn -EINVAL;\r\n}\r\nswitch (phy->type) {\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:\r\nread_func = bnx2x_8726_read_sfp_module_eeprom;\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722:\r\nread_func = bnx2x_8727_read_sfp_module_eeprom;\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT:\r\nread_func = bnx2x_warpcore_read_sfp_module_eeprom;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nwhile (!rc && (byte_cnt > 0)) {\r\nxfer_size = (byte_cnt > SFP_EEPROM_PAGE_SIZE) ?\r\nSFP_EEPROM_PAGE_SIZE : byte_cnt;\r\nrc = read_func(phy, params, dev_addr, addr, xfer_size,\r\nuser_data, 0);\r\nbyte_cnt -= xfer_size;\r\nuser_data += xfer_size;\r\naddr += xfer_size;\r\n}\r\nreturn rc;\r\n}\r\nstatic int bnx2x_get_edc_mode(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nu16 *edc_mode)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu32 sync_offset = 0, phy_idx, media_types;\r\nu8 val[SFP_EEPROM_FC_TX_TECH_ADDR + 1], check_limiting_mode = 0;\r\n*edc_mode = EDC_MODE_LIMITING;\r\nphy->media_type = ETH_PHY_UNSPECIFIED;\r\nif (bnx2x_read_sfp_module_eeprom(phy,\r\nparams,\r\nI2C_DEV_ADDR_A0,\r\n0,\r\nSFP_EEPROM_FC_TX_TECH_ADDR + 1,\r\n(u8 *)val) != 0) {\r\nDP(NETIF_MSG_LINK, "Failed to read from SFP+ module EEPROM\n");\r\nreturn -EINVAL;\r\n}\r\nparams->link_attr_sync &= ~LINK_SFP_EEPROM_COMP_CODE_MASK;\r\nparams->link_attr_sync |= val[SFP_EEPROM_10G_COMP_CODE_ADDR] <<\r\nLINK_SFP_EEPROM_COMP_CODE_SHIFT;\r\nbnx2x_update_link_attr(params, params->link_attr_sync);\r\nswitch (val[SFP_EEPROM_CON_TYPE_ADDR]) {\r\ncase SFP_EEPROM_CON_TYPE_VAL_COPPER:\r\n{\r\nu8 copper_module_type;\r\nphy->media_type = ETH_PHY_DA_TWINAX;\r\ncopper_module_type = val[SFP_EEPROM_FC_TX_TECH_ADDR];\r\nif (copper_module_type &\r\nSFP_EEPROM_FC_TX_TECH_BITMASK_COPPER_ACTIVE) {\r\nDP(NETIF_MSG_LINK, "Active Copper cable detected\n");\r\nif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT)\r\n*edc_mode = EDC_MODE_ACTIVE_DAC;\r\nelse\r\ncheck_limiting_mode = 1;\r\n} else {\r\n*edc_mode = EDC_MODE_PASSIVE_DAC;\r\nif (copper_module_type &\r\nSFP_EEPROM_FC_TX_TECH_BITMASK_COPPER_PASSIVE) {\r\nDP(NETIF_MSG_LINK,\r\n"Passive Copper cable detected\n");\r\n} else {\r\nDP(NETIF_MSG_LINK,\r\n"Unknown copper-cable-type\n");\r\n}\r\n}\r\nbreak;\r\n}\r\ncase SFP_EEPROM_CON_TYPE_VAL_UNKNOWN:\r\ncase SFP_EEPROM_CON_TYPE_VAL_LC:\r\ncase SFP_EEPROM_CON_TYPE_VAL_RJ45:\r\ncheck_limiting_mode = 1;\r\nif (((val[SFP_EEPROM_10G_COMP_CODE_ADDR] &\r\n(SFP_EEPROM_10G_COMP_CODE_SR_MASK |\r\nSFP_EEPROM_10G_COMP_CODE_LR_MASK |\r\nSFP_EEPROM_10G_COMP_CODE_LRM_MASK)) == 0) &&\r\n(val[SFP_EEPROM_1G_COMP_CODE_ADDR] != 0)) {\r\nDP(NETIF_MSG_LINK, "1G SFP module detected\n");\r\nphy->media_type = ETH_PHY_SFP_1G_FIBER;\r\nif (phy->req_line_speed != SPEED_1000) {\r\nu8 gport = params->port;\r\nphy->req_line_speed = SPEED_1000;\r\nif (!CHIP_IS_E1x(bp)) {\r\ngport = BP_PATH(bp) +\r\n(params->port << 1);\r\n}\r\nnetdev_err(bp->dev,\r\n"Warning: Link speed was forced to 1000Mbps. Current SFP module in port %d is not compliant with 10G Ethernet\n",\r\ngport);\r\n}\r\nif (val[SFP_EEPROM_1G_COMP_CODE_ADDR] &\r\nSFP_EEPROM_1G_COMP_CODE_BASE_T) {\r\nbnx2x_sfp_set_transmitter(params, phy, 0);\r\nmsleep(40);\r\nbnx2x_sfp_set_transmitter(params, phy, 1);\r\n}\r\n} else {\r\nint idx, cfg_idx = 0;\r\nDP(NETIF_MSG_LINK, "10G Optic module detected\n");\r\nfor (idx = INT_PHY; idx < MAX_PHYS; idx++) {\r\nif (params->phy[idx].type == phy->type) {\r\ncfg_idx = LINK_CONFIG_IDX(idx);\r\nbreak;\r\n}\r\n}\r\nphy->media_type = ETH_PHY_SFPP_10G_FIBER;\r\nphy->req_line_speed = params->req_line_speed[cfg_idx];\r\n}\r\nbreak;\r\ndefault:\r\nDP(NETIF_MSG_LINK, "Unable to determine module type 0x%x !!!\n",\r\nval[SFP_EEPROM_CON_TYPE_ADDR]);\r\nreturn -EINVAL;\r\n}\r\nsync_offset = params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[params->port].media_type);\r\nmedia_types = REG_RD(bp, sync_offset);\r\nfor (phy_idx = INT_PHY; phy_idx < MAX_PHYS; phy_idx++) {\r\nif (&(params->phy[phy_idx]) == phy) {\r\nmedia_types &= ~(PORT_HW_CFG_MEDIA_TYPE_PHY0_MASK <<\r\n(PORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT * phy_idx));\r\nmedia_types |= ((phy->media_type &\r\nPORT_HW_CFG_MEDIA_TYPE_PHY0_MASK) <<\r\n(PORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT * phy_idx));\r\nbreak;\r\n}\r\n}\r\nREG_WR(bp, sync_offset, media_types);\r\nif (check_limiting_mode) {\r\nu8 options[SFP_EEPROM_OPTIONS_SIZE];\r\nif (bnx2x_read_sfp_module_eeprom(phy,\r\nparams,\r\nI2C_DEV_ADDR_A0,\r\nSFP_EEPROM_OPTIONS_ADDR,\r\nSFP_EEPROM_OPTIONS_SIZE,\r\noptions) != 0) {\r\nDP(NETIF_MSG_LINK,\r\n"Failed to read Option field from module EEPROM\n");\r\nreturn -EINVAL;\r\n}\r\nif ((options[0] & SFP_EEPROM_OPTIONS_LINEAR_RX_OUT_MASK))\r\n*edc_mode = EDC_MODE_LINEAR;\r\nelse\r\n*edc_mode = EDC_MODE_LIMITING;\r\n}\r\nDP(NETIF_MSG_LINK, "EDC mode is set to 0x%x\n", *edc_mode);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_verify_sfp_module(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu32 val, cmd;\r\nu32 fw_resp, fw_cmd_param;\r\nchar vendor_name[SFP_EEPROM_VENDOR_NAME_SIZE+1];\r\nchar vendor_pn[SFP_EEPROM_PART_NO_SIZE+1];\r\nphy->flags &= ~FLAGS_SFP_NOT_APPROVED;\r\nval = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region, dev_info.\r\nport_feature_config[params->port].config));\r\nif ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) ==\r\nPORT_FEAT_CFG_OPT_MDL_ENFRCMNT_NO_ENFORCEMENT) {\r\nDP(NETIF_MSG_LINK, "NOT enforcing module verification\n");\r\nreturn 0;\r\n}\r\nif (params->feature_config_flags &\r\nFEATURE_CONFIG_BC_SUPPORTS_DUAL_PHY_OPT_MDL_VRFY) {\r\ncmd = DRV_MSG_CODE_VRFY_SPECIFIC_PHY_OPT_MDL;\r\n} else if (params->feature_config_flags &\r\nFEATURE_CONFIG_BC_SUPPORTS_OPT_MDL_VRFY) {\r\nif (DUAL_MEDIA(params)) {\r\nDP(NETIF_MSG_LINK,\r\n"FW does not support OPT MDL verification\n");\r\nreturn -EINVAL;\r\n}\r\ncmd = DRV_MSG_CODE_VRFY_FIRST_PHY_OPT_MDL;\r\n} else {\r\nDP(NETIF_MSG_LINK,\r\n"FW does not support OPT MDL verification\n");\r\nreturn -EINVAL;\r\n}\r\nfw_cmd_param = FW_PARAM_SET(phy->addr, phy->type, phy->mdio_ctrl);\r\nfw_resp = bnx2x_fw_command(bp, cmd, fw_cmd_param);\r\nif (fw_resp == FW_MSG_CODE_VRFY_OPT_MDL_SUCCESS) {\r\nDP(NETIF_MSG_LINK, "Approved module\n");\r\nreturn 0;\r\n}\r\nif (bnx2x_read_sfp_module_eeprom(phy,\r\nparams,\r\nI2C_DEV_ADDR_A0,\r\nSFP_EEPROM_VENDOR_NAME_ADDR,\r\nSFP_EEPROM_VENDOR_NAME_SIZE,\r\n(u8 *)vendor_name))\r\nvendor_name[0] = '\0';\r\nelse\r\nvendor_name[SFP_EEPROM_VENDOR_NAME_SIZE] = '\0';\r\nif (bnx2x_read_sfp_module_eeprom(phy,\r\nparams,\r\nI2C_DEV_ADDR_A0,\r\nSFP_EEPROM_PART_NO_ADDR,\r\nSFP_EEPROM_PART_NO_SIZE,\r\n(u8 *)vendor_pn))\r\nvendor_pn[0] = '\0';\r\nelse\r\nvendor_pn[SFP_EEPROM_PART_NO_SIZE] = '\0';\r\nnetdev_err(bp->dev, "Warning: Unqualified SFP+ module detected,"\r\n" Port %d from %s part number %s\n",\r\nparams->port, vendor_name, vendor_pn);\r\nif ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) !=\r\nPORT_FEAT_CFG_OPT_MDL_ENFRCMNT_WARNING_MSG)\r\nphy->flags |= FLAGS_SFP_NOT_APPROVED;\r\nreturn -EINVAL;\r\n}\r\nstatic int bnx2x_wait_for_sfp_module_initialized(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nu8 val;\r\nint rc;\r\nstruct bnx2x *bp = params->bp;\r\nu16 timeout;\r\nfor (timeout = 0; timeout < 60; timeout++) {\r\nif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT)\r\nrc = bnx2x_warpcore_read_sfp_module_eeprom(\r\nphy, params, I2C_DEV_ADDR_A0, 1, 1, &val,\r\n1);\r\nelse\r\nrc = bnx2x_read_sfp_module_eeprom(phy, params,\r\nI2C_DEV_ADDR_A0,\r\n1, 1, &val);\r\nif (rc == 0) {\r\nDP(NETIF_MSG_LINK,\r\n"SFP+ module initialization took %d ms\n",\r\ntimeout * 5);\r\nreturn 0;\r\n}\r\nusleep_range(5000, 10000);\r\n}\r\nrc = bnx2x_read_sfp_module_eeprom(phy, params, I2C_DEV_ADDR_A0,\r\n1, 1, &val);\r\nreturn rc;\r\n}\r\nstatic void bnx2x_8727_power_module(struct bnx2x *bp,\r\nstruct bnx2x_phy *phy,\r\nu8 is_power_up) {\r\nu16 val;\r\nif (phy->flags & FLAGS_NOC)\r\nreturn;\r\nif (is_power_up)\r\nval = (1<<4);\r\nelse\r\nval = (1<<1);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8727_GPIO_CTRL,\r\nval);\r\n}\r\nstatic int bnx2x_8726_set_limiting_mode(struct bnx2x *bp,\r\nstruct bnx2x_phy *phy,\r\nu16 edc_mode)\r\n{\r\nu16 cur_limiting_mode;\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_ROM_VER2,\r\n&cur_limiting_mode);\r\nDP(NETIF_MSG_LINK, "Current Limiting mode is 0x%x\n",\r\ncur_limiting_mode);\r\nif (edc_mode == EDC_MODE_LIMITING) {\r\nDP(NETIF_MSG_LINK, "Setting LIMITING MODE\n");\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_ROM_VER2,\r\nEDC_MODE_LIMITING);\r\n} else {\r\nDP(NETIF_MSG_LINK, "Setting LRM MODE\n");\r\nif (cur_limiting_mode != EDC_MODE_LIMITING)\r\nreturn 0;\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_LRM_MODE,\r\n0);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_ROM_VER2,\r\n0x128);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_MISC_CTRL0,\r\n0x4008);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_LRM_MODE,\r\n0xaaaa);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_8727_set_limiting_mode(struct bnx2x *bp,\r\nstruct bnx2x_phy *phy,\r\nu16 edc_mode)\r\n{\r\nu16 phy_identifier;\r\nu16 rom_ver2_val;\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_PHY_IDENTIFIER,\r\n&phy_identifier);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_PHY_IDENTIFIER,\r\n(phy_identifier & ~(1<<9)));\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_ROM_VER2,\r\n&rom_ver2_val);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_ROM_VER2,\r\n(rom_ver2_val & 0xff00) | (edc_mode & 0x00ff));\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_PHY_IDENTIFIER,\r\n(phy_identifier | (1<<9)));\r\nreturn 0;\r\n}\r\nstatic void bnx2x_8727_specific_func(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nu32 action)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 val;\r\nswitch (action) {\r\ncase DISABLE_TX:\r\nbnx2x_sfp_set_transmitter(params, phy, 0);\r\nbreak;\r\ncase ENABLE_TX:\r\nif (!(phy->flags & FLAGS_SFP_NOT_APPROVED))\r\nbnx2x_sfp_set_transmitter(params, phy, 1);\r\nbreak;\r\ncase PHY_INIT:\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXCTRL,\r\n(1<<2) | (1<<5));\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_TXCTRL,\r\n0);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 0x0006);\r\nbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8727_PCS_OPT_CTRL,\r\n&val);\r\nval |= (1<<12);\r\nif (phy->flags & FLAGS_NOC)\r\nval |= (3<<5);\r\nif (!(phy->flags & FLAGS_NOC))\r\nval &= 0xff8f;\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_8727_PCS_OPT_CTRL,\r\nval);\r\nbreak;\r\ndefault:\r\nDP(NETIF_MSG_LINK, "Function 0x%x not supported by 8727\n",\r\naction);\r\nreturn;\r\n}\r\n}\r\nstatic void bnx2x_set_e1e2_module_fault_led(struct link_params *params,\r\nu8 gpio_mode)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu32 fault_led_gpio = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[params->port].sfp_ctrl)) &\r\nPORT_HW_CFG_FAULT_MODULE_LED_MASK;\r\nswitch (fault_led_gpio) {\r\ncase PORT_HW_CFG_FAULT_MODULE_LED_DISABLED:\r\nreturn;\r\ncase PORT_HW_CFG_FAULT_MODULE_LED_GPIO0:\r\ncase PORT_HW_CFG_FAULT_MODULE_LED_GPIO1:\r\ncase PORT_HW_CFG_FAULT_MODULE_LED_GPIO2:\r\ncase PORT_HW_CFG_FAULT_MODULE_LED_GPIO3:\r\n{\r\nu8 gpio_port = bnx2x_get_gpio_port(params);\r\nu16 gpio_pin = fault_led_gpio -\r\nPORT_HW_CFG_FAULT_MODULE_LED_GPIO0;\r\nDP(NETIF_MSG_LINK, "Set fault module-detected led "\r\n"pin %x port %x mode %x\n",\r\ngpio_pin, gpio_port, gpio_mode);\r\nbnx2x_set_gpio(bp, gpio_pin, gpio_mode, gpio_port);\r\n}\r\nbreak;\r\ndefault:\r\nDP(NETIF_MSG_LINK, "Error: Invalid fault led mode 0x%x\n",\r\nfault_led_gpio);\r\n}\r\n}\r\nstatic void bnx2x_set_e3_module_fault_led(struct link_params *params,\r\nu8 gpio_mode)\r\n{\r\nu32 pin_cfg;\r\nu8 port = params->port;\r\nstruct bnx2x *bp = params->bp;\r\npin_cfg = (REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[port].e3_sfp_ctrl)) &\r\nPORT_HW_CFG_E3_FAULT_MDL_LED_MASK) >>\r\nPORT_HW_CFG_E3_FAULT_MDL_LED_SHIFT;\r\nDP(NETIF_MSG_LINK, "Setting Fault LED to %d using pin cfg %d\n",\r\ngpio_mode, pin_cfg);\r\nbnx2x_set_cfg_pin(bp, pin_cfg, gpio_mode);\r\n}\r\nstatic void bnx2x_set_sfp_module_fault_led(struct link_params *params,\r\nu8 gpio_mode)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nDP(NETIF_MSG_LINK, "Setting SFP+ module fault LED to %d\n", gpio_mode);\r\nif (CHIP_IS_E3(bp)) {\r\nbnx2x_set_e3_module_fault_led(params, gpio_mode);\r\n} else\r\nbnx2x_set_e1e2_module_fault_led(params, gpio_mode);\r\n}\r\nstatic void bnx2x_warpcore_hw_reset(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nbnx2x_warpcore_power_module(params, 0);\r\nREG_WR(bp, MISC_REG_WC0_RESET, 0x0c0e);\r\nREG_WR(bp, MISC_REG_LCPLL_E40_PWRDWN, 1);\r\nREG_WR(bp, MISC_REG_LCPLL_E40_RESETB_ANA, 0);\r\nREG_WR(bp, MISC_REG_LCPLL_E40_RESETB_DIG, 0);\r\n}\r\nstatic void bnx2x_power_sfp_module(struct link_params *params,\r\nstruct bnx2x_phy *phy,\r\nu8 power)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nDP(NETIF_MSG_LINK, "Setting SFP+ power to %x\n", power);\r\nswitch (phy->type) {\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722:\r\nbnx2x_8727_power_module(params->bp, phy, power);\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT:\r\nbnx2x_warpcore_power_module(params, power);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void bnx2x_warpcore_set_limiting_mode(struct link_params *params,\r\nstruct bnx2x_phy *phy,\r\nu16 edc_mode)\r\n{\r\nu16 val = 0;\r\nu16 mode = MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE_DEFAULT;\r\nstruct bnx2x *bp = params->bp;\r\nu8 lane = bnx2x_get_warpcore_lane(phy, params);\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE, &val);\r\nval &= ~(0xf << (lane << 2));\r\nswitch (edc_mode) {\r\ncase EDC_MODE_LINEAR:\r\ncase EDC_MODE_LIMITING:\r\nmode = MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE_DEFAULT;\r\nbreak;\r\ncase EDC_MODE_PASSIVE_DAC:\r\ncase EDC_MODE_ACTIVE_DAC:\r\nmode = MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE_SFP_DAC;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nval |= (mode << (lane << 2));\r\nbnx2x_cl45_write(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE, val);\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE, &val);\r\nbnx2x_warpcore_reset_lane(bp, phy, 1);\r\nbnx2x_warpcore_reset_lane(bp, phy, 0);\r\n}\r\nstatic void bnx2x_set_limiting_mode(struct link_params *params,\r\nstruct bnx2x_phy *phy,\r\nu16 edc_mode)\r\n{\r\nswitch (phy->type) {\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:\r\nbnx2x_8726_set_limiting_mode(params->bp, phy, edc_mode);\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722:\r\nbnx2x_8727_set_limiting_mode(params->bp, phy, edc_mode);\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT:\r\nbnx2x_warpcore_set_limiting_mode(params, phy, edc_mode);\r\nbreak;\r\n}\r\n}\r\nstatic int bnx2x_sfp_module_detection(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 edc_mode;\r\nint rc = 0;\r\nu32 val = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region, dev_info.\r\nport_feature_config[params->port].config));\r\nbnx2x_sfp_set_transmitter(params, phy, 1);\r\nDP(NETIF_MSG_LINK, "SFP+ module plugged in/out detected on port %d\n",\r\nparams->port);\r\nbnx2x_power_sfp_module(params, phy, 1);\r\nif (bnx2x_get_edc_mode(phy, params, &edc_mode) != 0) {\r\nDP(NETIF_MSG_LINK, "Failed to get valid module type\n");\r\nreturn -EINVAL;\r\n} else if (bnx2x_verify_sfp_module(phy, params) != 0) {\r\nDP(NETIF_MSG_LINK, "Module verification failed!!\n");\r\nrc = -EINVAL;\r\nbnx2x_set_sfp_module_fault_led(params,\r\nMISC_REGISTERS_GPIO_HIGH);\r\nif ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) ==\r\nPORT_FEAT_CFG_OPT_MDL_ENFRCMNT_POWER_DOWN) {\r\nDP(NETIF_MSG_LINK, "Shutdown SFP+ module!!\n");\r\nbnx2x_power_sfp_module(params, phy, 0);\r\nreturn rc;\r\n}\r\n} else {\r\nbnx2x_set_sfp_module_fault_led(params, MISC_REGISTERS_GPIO_LOW);\r\n}\r\nbnx2x_set_limiting_mode(params, phy, edc_mode);\r\nif ((rc) &&\r\n((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) ==\r\nPORT_FEAT_CFG_OPT_MDL_ENFRCMNT_DISABLE_TX_LASER))\r\nbnx2x_sfp_set_transmitter(params, phy, 0);\r\nreturn rc;\r\n}\r\nvoid bnx2x_handle_module_detect_int(struct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nstruct bnx2x_phy *phy;\r\nu32 gpio_val;\r\nu8 gpio_num, gpio_port;\r\nif (CHIP_IS_E3(bp)) {\r\nphy = &params->phy[INT_PHY];\r\nbnx2x_sfp_set_transmitter(params, phy, 1);\r\n} else {\r\nphy = &params->phy[EXT_PHY1];\r\n}\r\nif (bnx2x_get_mod_abs_int_cfg(bp, params->chip_id, params->shmem_base,\r\nparams->port, &gpio_num, &gpio_port) ==\r\n-EINVAL) {\r\nDP(NETIF_MSG_LINK, "Failed to get MOD_ABS interrupt config\n");\r\nreturn;\r\n}\r\nbnx2x_set_sfp_module_fault_led(params, MISC_REGISTERS_GPIO_HIGH);\r\ngpio_val = bnx2x_get_gpio(bp, gpio_num, gpio_port);\r\nif (gpio_val == 0) {\r\nbnx2x_set_mdio_emac_per_phy(bp, params);\r\nbnx2x_set_aer_mmd(params, phy);\r\nbnx2x_power_sfp_module(params, phy, 1);\r\nbnx2x_set_gpio_int(bp, gpio_num,\r\nMISC_REGISTERS_GPIO_INT_OUTPUT_CLR,\r\ngpio_port);\r\nif (bnx2x_wait_for_sfp_module_initialized(phy, params) == 0) {\r\nbnx2x_sfp_module_detection(phy, params);\r\nif (CHIP_IS_E3(bp)) {\r\nu16 rx_tx_in_reset;\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_WC_DEVAD,\r\nMDIO_WC_REG_DIGITAL5_MISC6,\r\n&rx_tx_in_reset);\r\nif ((!rx_tx_in_reset) &&\r\n(params->link_flags &\r\nPHY_INITIALIZED)) {\r\nbnx2x_warpcore_reset_lane(bp, phy, 1);\r\nbnx2x_warpcore_config_sfi(phy, params);\r\nbnx2x_warpcore_reset_lane(bp, phy, 0);\r\n}\r\n}\r\n} else {\r\nDP(NETIF_MSG_LINK, "SFP+ module is not initialized\n");\r\n}\r\n} else {\r\nbnx2x_set_gpio_int(bp, gpio_num,\r\nMISC_REGISTERS_GPIO_INT_OUTPUT_SET,\r\ngpio_port);\r\nphy->media_type = ETH_PHY_NOT_PRESENT;\r\n}\r\n}\r\nstatic void bnx2x_sfp_mask_fault(struct bnx2x *bp,\r\nstruct bnx2x_phy *phy,\r\nu16 alarm_status_offset,\r\nu16 alarm_ctrl_offset)\r\n{\r\nu16 alarm_status, val;\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, alarm_status_offset,\r\n&alarm_status);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, alarm_status_offset,\r\n&alarm_status);\r\nbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD, alarm_ctrl_offset, &val);\r\nif (alarm_status & (1<<0))\r\nval &= ~(1<<0);\r\nelse\r\nval |= (1<<0);\r\nbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, alarm_ctrl_offset, val);\r\n}\r\nstatic u8 bnx2x_8706_8726_read_status(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nu8 link_up = 0;\r\nu16 val1, val2, rx_sd, pcs_status;\r\nstruct bnx2x *bp = params->bp;\r\nDP(NETIF_MSG_LINK, "XGXS 8706/8726\n");\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXSTAT, &val2);\r\nbnx2x_sfp_mask_fault(bp, phy, MDIO_PMA_LASI_TXSTAT,\r\nMDIO_PMA_LASI_TXCTRL);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_STAT, &val1);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_STAT, &val2);\r\nDP(NETIF_MSG_LINK, "8706/8726 LASI status 0x%x--> 0x%x\n", val1, val2);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_RX_SD, &rx_sd);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PCS_DEVAD, MDIO_PCS_REG_STATUS, &pcs_status);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_LINK_STATUS, &val2);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_LINK_STATUS, &val2);\r\nDP(NETIF_MSG_LINK, "8706/8726 rx_sd 0x%x pcs_status 0x%x 1Gbps"\r\n" link_status 0x%x\n", rx_sd, pcs_status, val2);\r\nlink_up = ((rx_sd & pcs_status & 0x1) || (val2 & (1<<1)));\r\nif (link_up) {\r\nif (val2 & (1<<1))\r\nvars->line_speed = SPEED_1000;\r\nelse\r\nvars->line_speed = SPEED_10000;\r\nbnx2x_ext_phy_resolve_fc(phy, params, vars);\r\nvars->duplex = DUPLEX_FULL;\r\n}\r\nif (vars->line_speed == SPEED_10000) {\r\nbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\r\nMDIO_PMA_LASI_TXSTAT, &val1);\r\nbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\r\nMDIO_PMA_LASI_TXSTAT, &val1);\r\nif (val1 & (1<<0))\r\nvars->fault_detected = 1;\r\n}\r\nreturn link_up;\r\n}\r\nstatic u8 bnx2x_8706_config_init(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nu32 tx_en_mode;\r\nu16 cnt, val, tmp1;\r\nstruct bnx2x *bp = params->bp;\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\r\nMISC_REGISTERS_GPIO_OUTPUT_HIGH, params->port);\r\nbnx2x_ext_phy_hw_reset(bp, params->port);\r\nbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0xa040);\r\nbnx2x_wait_reset_complete(bp, phy, params);\r\nfor (cnt = 0; cnt < 100; cnt++) {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_ROM_VER1, &val);\r\nif (val)\r\nbreak;\r\nusleep_range(10000, 20000);\r\n}\r\nDP(NETIF_MSG_LINK, "XGXS 8706 is initialized after %d ms\n", cnt);\r\nif ((params->feature_config_flags &\r\nFEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED)) {\r\nu8 i;\r\nu16 reg;\r\nfor (i = 0; i < 4; i++) {\r\nreg = MDIO_XS_8706_REG_BANK_RX0 +\r\ni*(MDIO_XS_8706_REG_BANK_RX1 -\r\nMDIO_XS_8706_REG_BANK_RX0);\r\nbnx2x_cl45_read(bp, phy, MDIO_XS_DEVAD, reg, &val);\r\nval &= ~0x7;\r\nval |= (phy->rx_preemphasis[i] & 0x7);\r\nDP(NETIF_MSG_LINK, "Setting RX Equalizer to BCM8706"\r\n" reg 0x%x <-- val 0x%x\n", reg, val);\r\nbnx2x_cl45_write(bp, phy, MDIO_XS_DEVAD, reg, val);\r\n}\r\n}\r\nif (phy->req_line_speed == SPEED_10000) {\r\nDP(NETIF_MSG_LINK, "XGXS 8706 force 10Gbps\n");\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_DIGITAL_CTRL, 0x400);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_TXCTRL,\r\n0);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 3);\r\n} else {\r\nDP(NETIF_MSG_LINK, "XGXS 8706 AutoNeg\n");\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_CL37_CL73, 0x040c);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LP, 0x0020);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_CL37_AN, 0x1000);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_ADV, (1<<5));\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0x1200);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXCTRL,\r\n0x0400);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL,\r\n0x0004);\r\n}\r\nbnx2x_save_bcm_spirom_ver(bp, phy, params->port);\r\ntx_en_mode = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[params->port].sfp_ctrl))\r\n& PORT_HW_CFG_TX_LASER_MASK;\r\nif (tx_en_mode == PORT_HW_CFG_TX_LASER_GPIO0) {\r\nDP(NETIF_MSG_LINK, "Enabling TXONOFF_PWRDN_DIS\n");\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_DIGITAL_CTRL, &tmp1);\r\ntmp1 |= 0x1;\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_DIGITAL_CTRL, tmp1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_8706_read_status(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nreturn bnx2x_8706_8726_read_status(phy, params, vars);\r\n}\r\nstatic void bnx2x_8726_config_loopback(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nDP(NETIF_MSG_LINK, "PMA/PMD ext_phy_loopback: 8726\n");\r\nbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0x0001);\r\n}\r\nstatic void bnx2x_8726_external_rom_boot(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nmsleep(100);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_GEN_CTRL, 0x018B);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_GEN_CTRL,\r\nMDIO_PMA_REG_GEN_CTRL_ROM_MICRO_RESET);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_MISC_CTRL1, 0x0001);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_GEN_CTRL,\r\nMDIO_PMA_REG_GEN_CTRL_ROM_RESET_INTERNAL_MP);\r\nmsleep(150);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_MISC_CTRL1, 0x0000);\r\nmsleep(200);\r\nbnx2x_save_bcm_spirom_ver(bp, phy, params->port);\r\n}\r\nstatic u8 bnx2x_8726_read_status(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 val1;\r\nu8 link_up = bnx2x_8706_8726_read_status(phy, params, vars);\r\nif (link_up) {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_PHY_IDENTIFIER,\r\n&val1);\r\nif (val1 & (1<<15)) {\r\nDP(NETIF_MSG_LINK, "Tx is disabled\n");\r\nlink_up = 0;\r\nvars->line_speed = 0;\r\n}\r\n}\r\nreturn link_up;\r\n}\r\nstatic int bnx2x_8726_config_init(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nDP(NETIF_MSG_LINK, "Initializing BCM8726\n");\r\nbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 1<<15);\r\nbnx2x_wait_reset_complete(bp, phy, params);\r\nbnx2x_8726_external_rom_boot(phy, params);\r\nbnx2x_sfp_module_detection(phy, params);\r\nif (phy->req_line_speed == SPEED_1000) {\r\nDP(NETIF_MSG_LINK, "Setting 1G force\n");\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0x40);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_10G_CTRL2, 0xD);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 0x5);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXCTRL,\r\n0x400);\r\n} else if ((phy->req_line_speed == SPEED_AUTO_NEG) &&\r\n(phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_1G) &&\r\n((phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10G) !=\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10G)) {\r\nDP(NETIF_MSG_LINK, "Setting 1G clause37\n");\r\nbnx2x_ext_phy_set_pause(params, phy, vars);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_ADV, 0x20);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_CL37_CL73, 0x040c);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_CL37_FC_LD, 0x0020);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_CL37_AN, 0x1000);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0x1200);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 0x4);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXCTRL,\r\n0x400);\r\n} else {\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 1);\r\n}\r\nif ((params->feature_config_flags &\r\nFEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED)) {\r\nDP(NETIF_MSG_LINK,\r\n"Setting TX_CTRL1 0x%x, TX_CTRL2 0x%x\n",\r\nphy->tx_preemphasis[0],\r\nphy->tx_preemphasis[1]);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8726_TX_CTRL1,\r\nphy->tx_preemphasis[0]);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8726_TX_CTRL2,\r\nphy->tx_preemphasis[1]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2x_8726_link_reset(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nDP(NETIF_MSG_LINK, "bnx2x_8726_link_reset port %d\n", params->port);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_GEN_CTRL, 0x0001);\r\n}\r\nstatic void bnx2x_8727_set_link_led(struct bnx2x_phy *phy,\r\nstruct link_params *params, u8 mode)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 led_mode_bitmask = 0;\r\nu16 gpio_pins_bitmask = 0;\r\nu16 val;\r\nif (!(phy->flags & FLAGS_NOC))\r\nreturn;\r\nswitch (mode) {\r\ncase LED_MODE_FRONT_PANEL_OFF:\r\ncase LED_MODE_OFF:\r\nled_mode_bitmask = 0;\r\ngpio_pins_bitmask = 0x03;\r\nbreak;\r\ncase LED_MODE_ON:\r\nled_mode_bitmask = 0;\r\ngpio_pins_bitmask = 0x02;\r\nbreak;\r\ncase LED_MODE_OPER:\r\nled_mode_bitmask = 0x60;\r\ngpio_pins_bitmask = 0x11;\r\nbreak;\r\n}\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8727_PCS_OPT_CTRL,\r\n&val);\r\nval &= 0xff8f;\r\nval |= led_mode_bitmask;\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8727_PCS_OPT_CTRL,\r\nval);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8727_GPIO_CTRL,\r\n&val);\r\nval &= 0xffe0;\r\nval |= gpio_pins_bitmask;\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8727_GPIO_CTRL,\r\nval);\r\n}\r\nstatic void bnx2x_8727_hw_reset(struct bnx2x_phy *phy,\r\nstruct link_params *params) {\r\nu32 swap_val, swap_override;\r\nu8 port;\r\nstruct bnx2x *bp = params->bp;\r\nswap_val = REG_RD(bp, NIG_REG_PORT_SWAP);\r\nswap_override = REG_RD(bp, NIG_REG_STRAP_OVERRIDE);\r\nport = (swap_val && swap_override) ^ 1;\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,\r\nMISC_REGISTERS_GPIO_OUTPUT_LOW, port);\r\n}\r\nstatic void bnx2x_8727_config_speed(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 tmp1, val;\r\nif ((phy->req_line_speed == SPEED_1000) ||\r\n(phy->media_type == ETH_PHY_SFP_1G_FIBER)) {\r\nDP(NETIF_MSG_LINK, "Setting 1G force\n");\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0x40);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_10G_CTRL2, 0xD);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_10G_CTRL2, &tmp1);\r\nDP(NETIF_MSG_LINK, "1.7 = 0x%x\n", tmp1);\r\nif (DUAL_MEDIA(params)) {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8727_PCS_GP, &val);\r\nval |= (3<<10);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8727_PCS_GP, val);\r\n}\r\n} else if ((phy->req_line_speed == SPEED_AUTO_NEG) &&\r\n((phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_1G)) &&\r\n((phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10G) !=\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10G)) {\r\nDP(NETIF_MSG_LINK, "Setting 1G clause37\n");\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_8727_MISC_CTRL, 0);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_CL37_AN, 0x1300);\r\n} else {\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_8727_MISC_CTRL,\r\n0x0020);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_CL37_AN, 0x0100);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0x2040);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_10G_CTRL2,\r\n0x0008);\r\n}\r\n}\r\nstatic int bnx2x_8727_config_init(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nu32 tx_en_mode;\r\nu16 tmp1, mod_abs, tmp2;\r\nstruct bnx2x *bp = params->bp;\r\nbnx2x_wait_reset_complete(bp, phy, params);\r\nDP(NETIF_MSG_LINK, "Initializing BCM8727\n");\r\nbnx2x_8727_specific_func(phy, params, PHY_INIT);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_PHY_IDENTIFIER, &mod_abs);\r\nmod_abs &= ~(1<<8);\r\nif (!(phy->flags & FLAGS_NOC))\r\nmod_abs &= ~(1<<9);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_PHY_IDENTIFIER, mod_abs);\r\nbnx2x_set_disable_pmd_transmit(params, phy, 0);\r\nbnx2x_8727_power_module(bp, phy, 1);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_M8051_MSGOUT_REG, &tmp1);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXSTAT, &tmp1);\r\nbnx2x_8727_config_speed(phy, params);\r\nif ((params->feature_config_flags &\r\nFEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED)) {\r\nDP(NETIF_MSG_LINK, "Setting TX_CTRL1 0x%x, TX_CTRL2 0x%x\n",\r\nphy->tx_preemphasis[0],\r\nphy->tx_preemphasis[1]);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_8727_TX_CTRL1,\r\nphy->tx_preemphasis[0]);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_8727_TX_CTRL2,\r\nphy->tx_preemphasis[1]);\r\n}\r\ntx_en_mode = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[params->port].sfp_ctrl))\r\n& PORT_HW_CFG_TX_LASER_MASK;\r\nif (tx_en_mode == PORT_HW_CFG_TX_LASER_GPIO0) {\r\nDP(NETIF_MSG_LINK, "Enabling TXONOFF_PWRDN_DIS\n");\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_8727_OPT_CFG_REG, &tmp2);\r\ntmp2 |= 0x1000;\r\ntmp2 &= 0xFFEF;\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_8727_OPT_CFG_REG, tmp2);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_PHY_IDENTIFIER,\r\n&tmp2);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_PHY_IDENTIFIER,\r\n(tmp2 & 0x7fff));\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2x_8727_handle_mod_abs(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 mod_abs, rx_alarm_status;\r\nu32 val = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region, dev_info.\r\nport_feature_config[params->port].\r\nconfig));\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_PHY_IDENTIFIER, &mod_abs);\r\nif (mod_abs & (1<<8)) {\r\nDP(NETIF_MSG_LINK,\r\n"MOD_ABS indication show module is absent\n");\r\nphy->media_type = ETH_PHY_NOT_PRESENT;\r\nmod_abs &= ~(1<<8);\r\nif (!(phy->flags & FLAGS_NOC))\r\nmod_abs &= ~(1<<9);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_PHY_IDENTIFIER, mod_abs);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_LASI_RXSTAT, &rx_alarm_status);\r\n} else {\r\nDP(NETIF_MSG_LINK,\r\n"MOD_ABS indication show module is present\n");\r\nmod_abs |= (1<<8);\r\nif (!(phy->flags & FLAGS_NOC))\r\nmod_abs |= (1<<9);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_PHY_IDENTIFIER, mod_abs);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_LASI_RXSTAT, &rx_alarm_status);\r\nif ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) ==\r\nPORT_FEAT_CFG_OPT_MDL_ENFRCMNT_DISABLE_TX_LASER)\r\nbnx2x_sfp_set_transmitter(params, phy, 0);\r\nif (bnx2x_wait_for_sfp_module_initialized(phy, params) == 0)\r\nbnx2x_sfp_module_detection(phy, params);\r\nelse\r\nDP(NETIF_MSG_LINK, "SFP+ module is not initialized\n");\r\nbnx2x_8727_config_speed(phy, params);\r\n}\r\nDP(NETIF_MSG_LINK, "8727 RX_ALARM_STATUS 0x%x\n",\r\nrx_alarm_status);\r\n}\r\nstatic u8 bnx2x_8727_read_status(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 link_up = 0, oc_port = params->port;\r\nu16 link_status = 0;\r\nu16 rx_alarm_status, lasi_ctrl, val1;\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL,\r\n&lasi_ctrl);\r\nif (!lasi_ctrl)\r\nreturn 0;\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXSTAT,\r\n&rx_alarm_status);\r\nvars->line_speed = 0;\r\nDP(NETIF_MSG_LINK, "8727 RX_ALARM_STATUS 0x%x\n", rx_alarm_status);\r\nbnx2x_sfp_mask_fault(bp, phy, MDIO_PMA_LASI_TXSTAT,\r\nMDIO_PMA_LASI_TXCTRL);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_STAT, &val1);\r\nDP(NETIF_MSG_LINK, "8727 LASI status 0x%x\n", val1);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_M8051_MSGOUT_REG, &val1);\r\nif (!(phy->flags & FLAGS_NOC) && !(rx_alarm_status & (1<<5))) {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_8727_GPIO_CTRL,\r\n&val1);\r\nif ((val1 & (1<<8)) == 0) {\r\nif (!CHIP_IS_E1x(bp))\r\noc_port = BP_PATH(bp) + (params->port << 1);\r\nDP(NETIF_MSG_LINK,\r\n"8727 Power fault has been detected on port %d\n",\r\noc_port);\r\nnetdev_err(bp->dev, "Error: Power fault on Port %d has "\r\n"been detected and the power to "\r\n"that SFP+ module has been removed "\r\n"to prevent failure of the card. "\r\n"Please remove the SFP+ module and "\r\n"restart the system to clear this "\r\n"error.\n",\r\noc_port);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_LASI_RXCTRL, (1<<5));\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_PHY_IDENTIFIER, &val1);\r\nval1 |= (1<<8);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_PHY_IDENTIFIER, val1);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_LASI_RXSTAT, &rx_alarm_status);\r\nbnx2x_8727_power_module(params->bp, phy, 0);\r\nreturn 0;\r\n}\r\n}\r\nif (rx_alarm_status & (1<<5)) {\r\nbnx2x_8727_handle_mod_abs(phy, params);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_RXCTRL,\r\n((1<<5) | (1<<2)));\r\n}\r\nif (!(phy->flags & FLAGS_SFP_NOT_APPROVED)) {\r\nDP(NETIF_MSG_LINK, "Enabling 8727 TX laser\n");\r\nbnx2x_sfp_set_transmitter(params, phy, 1);\r\n} else {\r\nDP(NETIF_MSG_LINK, "Tx is disabled\n");\r\nreturn 0;\r\n}\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8073_SPEED_LINK_STATUS, &link_status);\r\nif ((link_status & (1<<2)) && (!(link_status & (1<<15)))) {\r\nlink_up = 1;\r\nvars->line_speed = SPEED_10000;\r\nDP(NETIF_MSG_LINK, "port %x: External link up in 10G\n",\r\nparams->port);\r\n} else if ((link_status & (1<<0)) && (!(link_status & (1<<13)))) {\r\nlink_up = 1;\r\nvars->line_speed = SPEED_1000;\r\nDP(NETIF_MSG_LINK, "port %x: External link up in 1G\n",\r\nparams->port);\r\n} else {\r\nlink_up = 0;\r\nDP(NETIF_MSG_LINK, "port %x: External link is down\n",\r\nparams->port);\r\n}\r\nif (vars->line_speed == SPEED_10000) {\r\nbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\r\nMDIO_PMA_LASI_TXSTAT, &val1);\r\nbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD,\r\nMDIO_PMA_LASI_TXSTAT, &val1);\r\nif (val1 & (1<<0)) {\r\nvars->fault_detected = 1;\r\n}\r\n}\r\nif (link_up) {\r\nbnx2x_ext_phy_resolve_fc(phy, params, vars);\r\nvars->duplex = DUPLEX_FULL;\r\nDP(NETIF_MSG_LINK, "duplex = 0x%x\n", vars->duplex);\r\n}\r\nif ((DUAL_MEDIA(params)) &&\r\n(phy->req_line_speed == SPEED_1000)) {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8727_PCS_GP, &val1);\r\nif (link_up)\r\nval1 &= ~(3<<10);\r\nelse\r\nval1 |= (3<<10);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8727_PCS_GP, val1);\r\n}\r\nreturn link_up;\r\n}\r\nstatic void bnx2x_8727_link_reset(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nbnx2x_set_disable_pmd_transmit(params, phy, 1);\r\nbnx2x_sfp_set_transmitter(params, phy, 0);\r\nbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 0);\r\n}\r\nstatic void bnx2x_save_848xx_spirom_version(struct bnx2x_phy *phy,\r\nstruct bnx2x *bp,\r\nu8 port)\r\n{\r\nu16 val, fw_ver2, cnt, i;\r\nstatic struct bnx2x_reg_set reg_set[] = {\r\n{MDIO_PMA_DEVAD, 0xA819, 0x0014},\r\n{MDIO_PMA_DEVAD, 0xA81A, 0xc200},\r\n{MDIO_PMA_DEVAD, 0xA81B, 0x0000},\r\n{MDIO_PMA_DEVAD, 0xA81C, 0x0300},\r\n{MDIO_PMA_DEVAD, 0xA817, 0x0009}\r\n};\r\nu16 fw_ver1;\r\nif ((phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833) ||\r\n(phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834)) {\r\nbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD, 0x400f, &fw_ver1);\r\nbnx2x_save_spirom_version(bp, port, fw_ver1 & 0xfff,\r\nphy->ver_addr);\r\n} else {\r\nfor (i = 0; i < ARRAY_SIZE(reg_set); i++)\r\nbnx2x_cl45_write(bp, phy, reg_set[i].devad,\r\nreg_set[i].reg, reg_set[i].val);\r\nfor (cnt = 0; cnt < 100; cnt++) {\r\nbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD, 0xA818, &val);\r\nif (val & 1)\r\nbreak;\r\nudelay(5);\r\n}\r\nif (cnt == 100) {\r\nDP(NETIF_MSG_LINK, "Unable to read 848xx "\r\n"phy fw version(1)\n");\r\nbnx2x_save_spirom_version(bp, port, 0,\r\nphy->ver_addr);\r\nreturn;\r\n}\r\nbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, 0xA819, 0x0000);\r\nbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, 0xA81A, 0xc200);\r\nbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, 0xA817, 0x000A);\r\nfor (cnt = 0; cnt < 100; cnt++) {\r\nbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD, 0xA818, &val);\r\nif (val & 1)\r\nbreak;\r\nudelay(5);\r\n}\r\nif (cnt == 100) {\r\nDP(NETIF_MSG_LINK, "Unable to read 848xx phy fw "\r\n"version(2)\n");\r\nbnx2x_save_spirom_version(bp, port, 0,\r\nphy->ver_addr);\r\nreturn;\r\n}\r\nbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD, 0xA81B, &fw_ver1);\r\nbnx2x_cl45_read(bp, phy, MDIO_PMA_DEVAD, 0xA81C, &fw_ver2);\r\nbnx2x_save_spirom_version(bp, port, (fw_ver2<<16) | fw_ver1,\r\nphy->ver_addr);\r\n}\r\n}\r\nstatic void bnx2x_848xx_set_led(struct bnx2x *bp,\r\nstruct bnx2x_phy *phy)\r\n{\r\nu16 val, offset, i;\r\nstatic struct bnx2x_reg_set reg_set[] = {\r\n{MDIO_PMA_DEVAD, MDIO_PMA_REG_8481_LED1_MASK, 0x0080},\r\n{MDIO_PMA_DEVAD, MDIO_PMA_REG_8481_LED2_MASK, 0x0018},\r\n{MDIO_PMA_DEVAD, MDIO_PMA_REG_8481_LED3_MASK, 0x0006},\r\n{MDIO_PMA_DEVAD, MDIO_PMA_REG_8481_LED3_BLINK, 0x0000},\r\n{MDIO_PMA_DEVAD, MDIO_PMA_REG_84823_CTL_SLOW_CLK_CNT_HIGH,\r\nMDIO_PMA_REG_84823_BLINK_RATE_VAL_15P9HZ},\r\n{MDIO_AN_DEVAD, 0xFFFB, 0xFFFD}\r\n};\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LINK_SIGNAL, &val);\r\nval &= 0xFE00;\r\nval |= 0x0092;\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LINK_SIGNAL, val);\r\nfor (i = 0; i < ARRAY_SIZE(reg_set); i++)\r\nbnx2x_cl45_write(bp, phy, reg_set[i].devad, reg_set[i].reg,\r\nreg_set[i].val);\r\nif ((phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833) ||\r\n(phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834))\r\noffset = MDIO_PMA_REG_84833_CTL_LED_CTL_1;\r\nelse\r\noffset = MDIO_PMA_REG_84823_CTL_LED_CTL_1;\r\nbnx2x_cl45_read_or_write(bp, phy,\r\nMDIO_PMA_DEVAD, offset,\r\nMDIO_PMA_REG_84823_LED3_STRETCH_EN);\r\n}\r\nstatic void bnx2x_848xx_specific_func(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nu32 action)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nswitch (action) {\r\ncase PHY_INIT:\r\nif ((phy->type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833) &&\r\n(phy->type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834)) {\r\nbnx2x_save_848xx_spirom_version(phy, bp, params->port);\r\n}\r\nbnx2x_bits_en(bp, NIG_REG_LATCH_BC_0 + params->port*4,\r\n1 << NIG_LATCH_BC_ENABLE_MI_INT);\r\nbnx2x_848xx_set_led(bp, phy);\r\nbreak;\r\n}\r\n}\r\nstatic int bnx2x_848xx_cmn_config_init(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 autoneg_val, an_1000_val, an_10_100_val;\r\nbnx2x_848xx_specific_func(phy, params, PHY_INIT);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 0x0000);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_8481_1000T_CTRL,\r\n&an_1000_val);\r\nbnx2x_ext_phy_set_pause(params, phy, vars);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD,\r\nMDIO_AN_REG_8481_LEGACY_AN_ADV,\r\n&an_10_100_val);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_8481_LEGACY_MII_CTRL,\r\n&autoneg_val);\r\nautoneg_val &= ~((1<<6) | (1<<8) | (1<<9) | (1<<12) | (1<<13));\r\nan_10_100_val &= ~((1<<5) | (1<<6) | (1<<7) | (1<<8));\r\nif (((phy->req_line_speed == SPEED_AUTO_NEG) &&\r\n(phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_1G)) ||\r\n(phy->req_line_speed == SPEED_1000)) {\r\nan_1000_val |= (1<<8);\r\nautoneg_val |= (1<<9 | 1<<12);\r\nif (phy->req_duplex == DUPLEX_FULL)\r\nan_1000_val |= (1<<9);\r\nDP(NETIF_MSG_LINK, "Advertising 1G\n");\r\n} else\r\nan_1000_val &= ~((1<<8) | (1<<9));\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_8481_1000T_CTRL,\r\nan_1000_val);\r\nif (phy->req_line_speed == SPEED_AUTO_NEG) {\r\nif (phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL) {\r\nautoneg_val |= (1<<9 | 1<<12);\r\nan_10_100_val |= (1<<8);\r\nDP(NETIF_MSG_LINK, "Advertising 100M-FD\n");\r\n}\r\nif (phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF) {\r\nautoneg_val |= (1<<9 | 1<<12);\r\nan_10_100_val |= (1<<7);\r\nDP(NETIF_MSG_LINK, "Advertising 100M-HD\n");\r\n}\r\nif ((phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL) &&\r\n(phy->supported & SUPPORTED_10baseT_Full)) {\r\nan_10_100_val |= (1<<6);\r\nautoneg_val |= (1<<9 | 1<<12);\r\nDP(NETIF_MSG_LINK, "Advertising 10M-FD\n");\r\n}\r\nif ((phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF) &&\r\n(phy->supported & SUPPORTED_10baseT_Half)) {\r\nan_10_100_val |= (1<<5);\r\nautoneg_val |= (1<<9 | 1<<12);\r\nDP(NETIF_MSG_LINK, "Advertising 10M-HD\n");\r\n}\r\n}\r\nif ((phy->req_line_speed == SPEED_100) &&\r\n(phy->supported &\r\n(SUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full))) {\r\nautoneg_val |= (1<<13);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_8481_AUX_CTRL,\r\n(1<<15 | 1<<9 | 7<<0));\r\nan_10_100_val |= (1<<8) | (1<<7);\r\nDP(NETIF_MSG_LINK, "Setting 100M force\n");\r\n}\r\nif ((phy->req_line_speed == SPEED_10) &&\r\n(phy->supported &\r\n(SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full))) {\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_8481_AUX_CTRL,\r\n(1<<15 | 1<<9 | 7<<0));\r\nDP(NETIF_MSG_LINK, "Setting 10M force\n");\r\n}\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_8481_LEGACY_AN_ADV,\r\nan_10_100_val);\r\nif (phy->req_duplex == DUPLEX_FULL)\r\nautoneg_val |= (1<<8);\r\nif (((phy->type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833) &&\r\n(phy->type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834)) ||\r\n((autoneg_val & (1<<12)) == 0))\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD,\r\nMDIO_AN_REG_8481_LEGACY_MII_CTRL, autoneg_val);\r\nif (((phy->req_line_speed == SPEED_AUTO_NEG) &&\r\n(phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10G)) ||\r\n(phy->req_line_speed == SPEED_10000)) {\r\nDP(NETIF_MSG_LINK, "Advertising 10G\n");\r\nbnx2x_cl45_read_or_write(\r\nbp, phy,\r\nMDIO_AN_DEVAD,\r\nMDIO_AN_REG_8481_10GBASE_T_AN_CTRL,\r\n0x1000);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_CTRL,\r\n0x3200);\r\n} else\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD,\r\nMDIO_AN_REG_8481_10GBASE_T_AN_CTRL,\r\n1);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_8481_config_init(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\r\nMISC_REGISTERS_GPIO_OUTPUT_HIGH, params->port);\r\nbnx2x_ext_phy_hw_reset(bp, params->port);\r\nbnx2x_wait_reset_complete(bp, phy, params);\r\nbnx2x_cl45_write(bp, phy, MDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 1<<15);\r\nreturn bnx2x_848xx_cmn_config_init(phy, params, vars);\r\n}\r\nstatic int bnx2x_84833_cmd_hdlr(struct bnx2x_phy *phy,\r\nstruct link_params *params, u16 fw_cmd,\r\nu16 cmd_args[], int argc)\r\n{\r\nint idx;\r\nu16 val;\r\nstruct bnx2x *bp = params->bp;\r\nbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\r\nMDIO_84833_CMD_HDLR_STATUS,\r\nPHY84833_STATUS_CMD_OPEN_OVERRIDE);\r\nfor (idx = 0; idx < PHY84833_CMDHDLR_WAIT; idx++) {\r\nbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\r\nMDIO_84833_CMD_HDLR_STATUS, &val);\r\nif (val == PHY84833_STATUS_CMD_OPEN_FOR_CMDS)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nif (idx >= PHY84833_CMDHDLR_WAIT) {\r\nDP(NETIF_MSG_LINK, "FW cmd: FW not ready.\n");\r\nreturn -EINVAL;\r\n}\r\nfor (idx = 0; idx < argc; idx++) {\r\nbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\r\nMDIO_84833_CMD_HDLR_DATA1 + idx,\r\ncmd_args[idx]);\r\n}\r\nbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\r\nMDIO_84833_CMD_HDLR_COMMAND, fw_cmd);\r\nfor (idx = 0; idx < PHY84833_CMDHDLR_WAIT; idx++) {\r\nbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\r\nMDIO_84833_CMD_HDLR_STATUS, &val);\r\nif ((val == PHY84833_STATUS_CMD_COMPLETE_PASS) ||\r\n(val == PHY84833_STATUS_CMD_COMPLETE_ERROR))\r\nbreak;\r\nusleep_range(1000, 2000);\r\n}\r\nif ((idx >= PHY84833_CMDHDLR_WAIT) ||\r\n(val == PHY84833_STATUS_CMD_COMPLETE_ERROR)) {\r\nDP(NETIF_MSG_LINK, "FW cmd failed.\n");\r\nreturn -EINVAL;\r\n}\r\nfor (idx = 0; idx < argc; idx++) {\r\nbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\r\nMDIO_84833_CMD_HDLR_DATA1 + idx,\r\n&cmd_args[idx]);\r\n}\r\nbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\r\nMDIO_84833_CMD_HDLR_STATUS,\r\nPHY84833_STATUS_CMD_CLEAR_COMPLETE);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_84833_pair_swap_cfg(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nu32 pair_swap;\r\nu16 data[PHY84833_CMDHDLR_MAX_ARGS];\r\nint status;\r\nstruct bnx2x *bp = params->bp;\r\npair_swap = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[params->port].xgbt_phy_cfg)) &\r\nPORT_HW_CFG_RJ45_PAIR_SWAP_MASK;\r\nif (pair_swap == 0)\r\nreturn 0;\r\ndata[1] = (u16)pair_swap;\r\nstatus = bnx2x_84833_cmd_hdlr(phy, params,\r\nPHY84833_CMD_SET_PAIR_SWAP, data, PHY84833_CMDHDLR_MAX_ARGS);\r\nif (status == 0)\r\nDP(NETIF_MSG_LINK, "Pairswap OK, val=0x%x\n", data[1]);\r\nreturn status;\r\n}\r\nstatic u8 bnx2x_84833_get_reset_gpios(struct bnx2x *bp,\r\nu32 shmem_base_path[],\r\nu32 chip_id)\r\n{\r\nu32 reset_pin[2];\r\nu32 idx;\r\nu8 reset_gpios;\r\nif (CHIP_IS_E3(bp)) {\r\nfor (idx = 0; idx < 2; idx++) {\r\nreset_pin[idx] = REG_RD(bp, shmem_base_path[idx] +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[0].e3_cmn_pin_cfg));\r\nreset_pin[idx] = (reset_pin[idx] &\r\nPORT_HW_CFG_E3_PHY_RESET_MASK) >>\r\nPORT_HW_CFG_E3_PHY_RESET_SHIFT;\r\nreset_pin[idx] -= PIN_CFG_GPIO0_P0;\r\nreset_pin[idx] = (1 << reset_pin[idx]);\r\n}\r\nreset_gpios = (u8)(reset_pin[0] | reset_pin[1]);\r\n} else {\r\nfor (idx = 0; idx < 2; idx++) {\r\nreset_pin[idx] = REG_RD(bp, shmem_base_path[idx] +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[0].default_cfg));\r\nreset_pin[idx] &= PORT_HW_CFG_EXT_PHY_GPIO_RST_MASK;\r\nreset_pin[idx] -= PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO0_P0;\r\nreset_pin[idx] >>= PORT_HW_CFG_EXT_PHY_GPIO_RST_SHIFT;\r\nreset_pin[idx] = (1 << reset_pin[idx]);\r\n}\r\nreset_gpios = (u8)(reset_pin[0] | reset_pin[1]);\r\n}\r\nreturn reset_gpios;\r\n}\r\nstatic int bnx2x_84833_hw_reset_phy(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 reset_gpios;\r\nu32 other_shmem_base_addr = REG_RD(bp, params->shmem2_base +\r\noffsetof(struct shmem2_region,\r\nother_shmem_base_addr));\r\nu32 shmem_base_path[2];\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_AN_REG_8481_LEGACY_MII_CTRL,\r\nMDIO_AN_REG_8481_MII_CTRL_FORCE_1G);\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_AN_REG_8481_1G_100T_EXT_CTRL,\r\nMIDO_AN_REG_8481_EXT_CTRL_FORCE_LEDS_OFF);\r\nshmem_base_path[0] = params->shmem_base;\r\nshmem_base_path[1] = other_shmem_base_addr;\r\nreset_gpios = bnx2x_84833_get_reset_gpios(bp, shmem_base_path,\r\nparams->chip_id);\r\nbnx2x_set_mult_gpio(bp, reset_gpios, MISC_REGISTERS_GPIO_OUTPUT_LOW);\r\nudelay(10);\r\nDP(NETIF_MSG_LINK, "84833 hw reset on pin values 0x%x\n",\r\nreset_gpios);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_8483x_disable_eee(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nint rc;\r\nstruct bnx2x *bp = params->bp;\r\nu16 cmd_args = 0;\r\nDP(NETIF_MSG_LINK, "Don't Advertise 10GBase-T EEE\n");\r\nrc = bnx2x_84833_cmd_hdlr(phy, params,\r\nPHY84833_CMD_SET_EEE_MODE, &cmd_args, 1);\r\nif (rc) {\r\nDP(NETIF_MSG_LINK, "EEE disable failed.\n");\r\nreturn rc;\r\n}\r\nreturn bnx2x_eee_disable(phy, params, vars);\r\n}\r\nstatic int bnx2x_8483x_enable_eee(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nint rc;\r\nstruct bnx2x *bp = params->bp;\r\nu16 cmd_args = 1;\r\nrc = bnx2x_84833_cmd_hdlr(phy, params,\r\nPHY84833_CMD_SET_EEE_MODE, &cmd_args, 1);\r\nif (rc) {\r\nDP(NETIF_MSG_LINK, "EEE enable failed.\n");\r\nreturn rc;\r\n}\r\nreturn bnx2x_eee_advertise(phy, params, vars, SHMEM_EEE_10G_ADV);\r\n}\r\nstatic int bnx2x_848x3_config_init(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 port, initialize = 1;\r\nu16 val;\r\nu32 actual_phy_selection;\r\nu16 cmd_args[PHY84833_CMDHDLR_MAX_ARGS];\r\nint rc = 0;\r\nusleep_range(1000, 2000);\r\nif (!(CHIP_IS_E1x(bp)))\r\nport = BP_PATH(bp);\r\nelse\r\nport = params->port;\r\nif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823) {\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_3,\r\nMISC_REGISTERS_GPIO_OUTPUT_HIGH,\r\nport);\r\n} else {\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_CTRL, 0x8000);\r\n}\r\nbnx2x_wait_reset_complete(bp, phy, params);\r\nmsleep(50);\r\nif ((phy->type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833) &&\r\n(phy->type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834)) {\r\nu16 temp;\r\ntemp = vars->line_speed;\r\nvars->line_speed = SPEED_10000;\r\nbnx2x_set_autoneg(&params->phy[INT_PHY], params, vars, 0);\r\nbnx2x_program_serdes(&params->phy[INT_PHY], params, vars);\r\nvars->line_speed = temp;\r\n}\r\nbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\r\nMDIO_CTL_REG_84823_MEDIA, &val);\r\nval &= ~(MDIO_CTL_REG_84823_MEDIA_MAC_MASK |\r\nMDIO_CTL_REG_84823_MEDIA_LINE_MASK |\r\nMDIO_CTL_REG_84823_MEDIA_COPPER_CORE_DOWN |\r\nMDIO_CTL_REG_84823_MEDIA_PRIORITY_MASK |\r\nMDIO_CTL_REG_84823_MEDIA_FIBER_1G);\r\nif (CHIP_IS_E3(bp)) {\r\nval &= ~(MDIO_CTL_REG_84823_MEDIA_MAC_MASK |\r\nMDIO_CTL_REG_84823_MEDIA_LINE_MASK);\r\n} else {\r\nval |= (MDIO_CTL_REG_84823_CTRL_MAC_XFI |\r\nMDIO_CTL_REG_84823_MEDIA_LINE_XAUI_L);\r\n}\r\nactual_phy_selection = bnx2x_phy_selection(params);\r\nswitch (actual_phy_selection) {\r\ncase PORT_HW_CFG_PHY_SELECTION_HARDWARE_DEFAULT:\r\nbreak;\r\ncase PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY:\r\nval |= MDIO_CTL_REG_84823_MEDIA_PRIORITY_COPPER;\r\nbreak;\r\ncase PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY:\r\nval |= MDIO_CTL_REG_84823_MEDIA_PRIORITY_FIBER;\r\nbreak;\r\ncase PORT_HW_CFG_PHY_SELECTION_FIRST_PHY:\r\nbreak;\r\ncase PORT_HW_CFG_PHY_SELECTION_SECOND_PHY:\r\nval |= MDIO_CTL_REG_84823_MEDIA_COPPER_CORE_DOWN;\r\ninitialize = 0;\r\nbreak;\r\n}\r\nif (params->phy[EXT_PHY2].req_line_speed == SPEED_1000)\r\nval |= MDIO_CTL_REG_84823_MEDIA_FIBER_1G;\r\nbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\r\nMDIO_CTL_REG_84823_MEDIA, val);\r\nDP(NETIF_MSG_LINK, "Multi_phy config = 0x%x, Media control = 0x%x\n",\r\nparams->multi_phy_config, val);\r\nif ((phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833) ||\r\n(phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834)) {\r\nbnx2x_84833_pair_swap_cfg(phy, params, vars);\r\ncmd_args[0] = 0x0;\r\ncmd_args[1] = 0x0;\r\ncmd_args[2] = PHY84833_CONSTANT_LATENCY + 1;\r\ncmd_args[3] = PHY84833_CONSTANT_LATENCY;\r\nrc = bnx2x_84833_cmd_hdlr(phy, params,\r\nPHY84833_CMD_SET_EEE_MODE, cmd_args,\r\nPHY84833_CMDHDLR_MAX_ARGS);\r\nif (rc)\r\nDP(NETIF_MSG_LINK, "Cfg AutogrEEEn failed.\n");\r\n}\r\nif (initialize)\r\nrc = bnx2x_848xx_cmn_config_init(phy, params, vars);\r\nelse\r\nbnx2x_save_848xx_spirom_version(phy, bp, params->port);\r\nif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823) {\r\nu32 cms_enable = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[params->port].default_cfg)) &\r\nPORT_HW_CFG_ENABLE_CMS_MASK;\r\nbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\r\nMDIO_CTL_REG_84823_USER_CTRL_REG, &val);\r\nif (cms_enable)\r\nval |= MDIO_CTL_REG_84823_USER_CTRL_CMS;\r\nelse\r\nval &= ~MDIO_CTL_REG_84823_USER_CTRL_CMS;\r\nbnx2x_cl45_write(bp, phy, MDIO_CTL_DEVAD,\r\nMDIO_CTL_REG_84823_USER_CTRL_REG, val);\r\n}\r\nbnx2x_cl45_read(bp, phy, MDIO_CTL_DEVAD,\r\nMDIO_84833_TOP_CFG_FW_REV, &val);\r\nif ((val >= MDIO_84833_TOP_CFG_FW_EEE) &&\r\n(val != MDIO_84833_TOP_CFG_FW_NO_EEE) &&\r\nbnx2x_eee_has_cap(params)) {\r\nrc = bnx2x_eee_initial_config(params, vars, SHMEM_EEE_10G_ADV);\r\nif (rc) {\r\nDP(NETIF_MSG_LINK, "Failed to configure EEE timers\n");\r\nbnx2x_8483x_disable_eee(phy, params, vars);\r\nreturn rc;\r\n}\r\nif ((phy->req_duplex == DUPLEX_FULL) &&\r\n(params->eee_mode & EEE_MODE_ADV_LPI) &&\r\n(bnx2x_eee_calc_timer(params) ||\r\n!(params->eee_mode & EEE_MODE_ENABLE_LPI)))\r\nrc = bnx2x_8483x_enable_eee(phy, params, vars);\r\nelse\r\nrc = bnx2x_8483x_disable_eee(phy, params, vars);\r\nif (rc) {\r\nDP(NETIF_MSG_LINK, "Failed to set EEE advertisement\n");\r\nreturn rc;\r\n}\r\n} else {\r\nvars->eee_status &= ~SHMEM_EEE_SUPPORTED_MASK;\r\n}\r\nif ((phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833) ||\r\n(phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834)) {\r\nbnx2x_cl45_read_and_write(bp, phy,\r\nMDIO_CTL_DEVAD,\r\nMDIO_84833_TOP_CFG_XGPHY_STRAP1,\r\n(u16)~MDIO_84833_SUPER_ISOLATE);\r\n}\r\nreturn rc;\r\n}\r\nstatic u8 bnx2x_848xx_read_status(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 val, val1, val2;\r\nu8 link_up = 0;\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD, 0xFFFA, &val1);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_8481_PMD_SIGNAL,\r\n&val2);\r\nDP(NETIF_MSG_LINK, "BCM848xx: PMD_SIGNAL 1.a811 = 0x%x\n", val2);\r\nif (val2 & (1<<11)) {\r\nvars->line_speed = SPEED_10000;\r\nvars->duplex = DUPLEX_FULL;\r\nlink_up = 1;\r\nbnx2x_ext_phy_10G_an_resolve(bp, phy, vars);\r\n} else {\r\nu16 legacy_status, legacy_speed;\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD,\r\nMDIO_AN_REG_8481_EXPANSION_REG_ACCESS, 0xf42);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD,\r\nMDIO_AN_REG_8481_EXPANSION_REG_RD_RW,\r\n&legacy_status);\r\nDP(NETIF_MSG_LINK, "Legacy speed status = 0x%x\n",\r\nlegacy_status);\r\nlink_up = ((legacy_status & (1<<11)) == (1<<11));\r\nlegacy_speed = (legacy_status & (3<<9));\r\nif (legacy_speed == (0<<9))\r\nvars->line_speed = SPEED_10;\r\nelse if (legacy_speed == (1<<9))\r\nvars->line_speed = SPEED_100;\r\nelse if (legacy_speed == (2<<9))\r\nvars->line_speed = SPEED_1000;\r\nelse {\r\nvars->line_speed = 0;\r\nlink_up = 0;\r\n}\r\nif (link_up) {\r\nif (legacy_status & (1<<8))\r\nvars->duplex = DUPLEX_FULL;\r\nelse\r\nvars->duplex = DUPLEX_HALF;\r\nDP(NETIF_MSG_LINK,\r\n"Link is up in %dMbps, is_duplex_full= %d\n",\r\nvars->line_speed,\r\n(vars->duplex == DUPLEX_FULL));\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD,\r\nMDIO_AN_REG_8481_LEGACY_MII_STATUS,\r\n&val);\r\nif (val & (1<<5))\r\nvars->link_status |=\r\nLINK_STATUS_AUTO_NEGOTIATE_COMPLETE;\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD,\r\nMDIO_AN_REG_8481_LEGACY_AN_EXPANSION,\r\n&val);\r\nif ((val & (1<<0)) == 0)\r\nvars->link_status |=\r\nLINK_STATUS_PARALLEL_DETECTION_USED;\r\n}\r\n}\r\nif (link_up) {\r\nDP(NETIF_MSG_LINK, "BCM848x3: link speed is %d\n",\r\nvars->line_speed);\r\nbnx2x_ext_phy_resolve_fc(phy, params, vars);\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_AN_REG_CL37_FC_LP, &val);\r\nif (val & (1<<5))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_10THD_CAPABLE;\r\nif (val & (1<<6))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_10TFD_CAPABLE;\r\nif (val & (1<<7))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_100TXHD_CAPABLE;\r\nif (val & (1<<8))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_100TXFD_CAPABLE;\r\nif (val & (1<<9))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_100T4_CAPABLE;\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_AN_REG_1000T_STATUS, &val);\r\nif (val & (1<<10))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_1000THD_CAPABLE;\r\nif (val & (1<<11))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE;\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_AN_REG_MASTER_STATUS, &val);\r\nif (val & (1<<11))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\r\nif ((phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833) ||\r\n(phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834))\r\nbnx2x_eee_an_resolve(phy, params, vars);\r\n}\r\nreturn link_up;\r\n}\r\nstatic int bnx2x_848xx_format_ver(u32 raw_ver, u8 *str, u16 *len)\r\n{\r\nint status = 0;\r\nu32 spirom_ver;\r\nspirom_ver = ((raw_ver & 0xF80) >> 7) << 16 | (raw_ver & 0x7F);\r\nstatus = bnx2x_format_ver(spirom_ver, str, len);\r\nreturn status;\r\n}\r\nstatic void bnx2x_8481_hw_reset(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nbnx2x_set_gpio(params->bp, MISC_REGISTERS_GPIO_1,\r\nMISC_REGISTERS_GPIO_OUTPUT_LOW, 0);\r\nbnx2x_set_gpio(params->bp, MISC_REGISTERS_GPIO_1,\r\nMISC_REGISTERS_GPIO_OUTPUT_LOW, 1);\r\n}\r\nstatic void bnx2x_8481_link_reset(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nbnx2x_cl45_write(params->bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_CTRL, 0x0000);\r\nbnx2x_cl45_write(params->bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 1);\r\n}\r\nstatic void bnx2x_848x3_link_reset(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 port;\r\nu16 val16;\r\nif (!(CHIP_IS_E1x(bp)))\r\nport = BP_PATH(bp);\r\nelse\r\nport = params->port;\r\nif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823) {\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_3,\r\nMISC_REGISTERS_GPIO_OUTPUT_LOW,\r\nport);\r\n} else {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_CTL_DEVAD,\r\nMDIO_84833_TOP_CFG_XGPHY_STRAP1, &val16);\r\nval16 |= MDIO_84833_SUPER_ISOLATE;\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_CTL_DEVAD,\r\nMDIO_84833_TOP_CFG_XGPHY_STRAP1, val16);\r\n}\r\n}\r\nstatic void bnx2x_848xx_set_link_led(struct bnx2x_phy *phy,\r\nstruct link_params *params, u8 mode)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 val;\r\nu8 port;\r\nif (!(CHIP_IS_E1x(bp)))\r\nport = BP_PATH(bp);\r\nelse\r\nport = params->port;\r\nswitch (mode) {\r\ncase LED_MODE_OFF:\r\nDP(NETIF_MSG_LINK, "Port 0x%x: LED MODE OFF\n", port);\r\nif ((params->hw_led_mode << SHARED_HW_CFG_LED_MODE_SHIFT) ==\r\nSHARED_HW_CFG_LED_EXTPHY1) {\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED1_MASK,\r\n0x0);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED2_MASK,\r\n0x0);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED3_MASK,\r\n0x0);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED5_MASK,\r\n0x0);\r\n} else {\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED1_MASK,\r\n0x0);\r\n}\r\nbreak;\r\ncase LED_MODE_FRONT_PANEL_OFF:\r\nDP(NETIF_MSG_LINK, "Port 0x%x: LED MODE FRONT PANEL OFF\n",\r\nport);\r\nif ((params->hw_led_mode << SHARED_HW_CFG_LED_MODE_SHIFT) ==\r\nSHARED_HW_CFG_LED_EXTPHY1) {\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED1_MASK,\r\n0x0);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED2_MASK,\r\n0x0);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED3_MASK,\r\n0x0);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED5_MASK,\r\n0x20);\r\n} else {\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED1_MASK,\r\n0x0);\r\nif (phy->type ==\r\nPORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834) {\r\nif (REG_RD(bp, NIG_REG_MASK_INTERRUPT_PORT0 +\r\nparams->port*4) &\r\nNIG_MASK_MI_INT) {\r\nparams->link_flags |=\r\nLINK_FLAGS_INT_DISABLED;\r\nbnx2x_bits_dis(\r\nbp,\r\nNIG_REG_MASK_INTERRUPT_PORT0 +\r\nparams->port*4,\r\nNIG_MASK_MI_INT);\r\n}\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_SIGNAL_MASK,\r\n0x0);\r\n}\r\n}\r\nbreak;\r\ncase LED_MODE_ON:\r\nDP(NETIF_MSG_LINK, "Port 0x%x: LED MODE ON\n", port);\r\nif ((params->hw_led_mode << SHARED_HW_CFG_LED_MODE_SHIFT) ==\r\nSHARED_HW_CFG_LED_EXTPHY1) {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LINK_SIGNAL,\r\n&val);\r\nval &= 0x8000;\r\nval |= 0x2492;\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LINK_SIGNAL,\r\nval);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED1_MASK,\r\n0x0);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED2_MASK,\r\n0x20);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED3_MASK,\r\n0x20);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED5_MASK,\r\n0x0);\r\n} else {\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED1_MASK,\r\n0x20);\r\nif (phy->type ==\r\nPORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834) {\r\nif (REG_RD(bp, NIG_REG_MASK_INTERRUPT_PORT0 +\r\nparams->port*4) &\r\nNIG_MASK_MI_INT) {\r\nparams->link_flags |=\r\nLINK_FLAGS_INT_DISABLED;\r\nbnx2x_bits_dis(\r\nbp,\r\nNIG_REG_MASK_INTERRUPT_PORT0 +\r\nparams->port*4,\r\nNIG_MASK_MI_INT);\r\n}\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_SIGNAL_MASK,\r\n0x20);\r\n}\r\n}\r\nbreak;\r\ncase LED_MODE_OPER:\r\nDP(NETIF_MSG_LINK, "Port 0x%x: LED MODE OPER\n", port);\r\nif ((params->hw_led_mode << SHARED_HW_CFG_LED_MODE_SHIFT) ==\r\nSHARED_HW_CFG_LED_EXTPHY1) {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LINK_SIGNAL,\r\n&val);\r\nif (!((val &\r\nMDIO_PMA_REG_8481_LINK_SIGNAL_LED4_ENABLE_MASK)\r\n>> MDIO_PMA_REG_8481_LINK_SIGNAL_LED4_ENABLE_SHIFT)) {\r\nDP(NETIF_MSG_LINK, "Setting LINK_SIGNAL\n");\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LINK_SIGNAL,\r\n0xa492);\r\n}\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED1_MASK,\r\n0x10);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED2_MASK,\r\n0x80);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED3_MASK,\r\n0x98);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED5_MASK,\r\n0x40);\r\n} else {\r\nval = ((params->hw_led_mode <<\r\nSHARED_HW_CFG_LED_MODE_SHIFT) ==\r\nSHARED_HW_CFG_LED_EXTPHY2) ? 0x98 : 0x80;\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LED1_MASK,\r\nval);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LINK_SIGNAL,\r\n&val);\r\nval &= ~(7<<6);\r\nval |= (1<<6);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_LINK_SIGNAL,\r\nval);\r\nif (phy->type ==\r\nPORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834) {\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_8481_SIGNAL_MASK,\r\n0x40);\r\nif (params->link_flags &\r\nLINK_FLAGS_INT_DISABLED) {\r\nbnx2x_link_int_enable(params);\r\nparams->link_flags &=\r\n~LINK_FLAGS_INT_DISABLED;\r\n}\r\n}\r\n}\r\nbreak;\r\n}\r\nif (CHIP_IS_E3(bp)) {\r\nbnx2x_cl45_read(bp, phy, MDIO_WC_DEVAD,\r\nMDIO_WC_REG_GP2_STATUS_GP_2_1, &val);\r\n}\r\n}\r\nstatic void bnx2x_54618se_specific_func(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nu32 action)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 temp;\r\nswitch (action) {\r\ncase PHY_INIT:\r\nbnx2x_cl22_write(bp, phy,\r\nMDIO_REG_GPHY_SHADOW,\r\nMDIO_REG_GPHY_SHADOW_LED_SEL2);\r\nbnx2x_cl22_read(bp, phy,\r\nMDIO_REG_GPHY_SHADOW,\r\n&temp);\r\ntemp &= ~(0xf << 4);\r\ntemp |= (0x6 << 4);\r\nbnx2x_cl22_write(bp, phy,\r\nMDIO_REG_GPHY_SHADOW,\r\nMDIO_REG_GPHY_SHADOW_WR_ENA | temp);\r\nbnx2x_cl22_write(bp, phy,\r\nMDIO_REG_INTR_MASK,\r\n~MDIO_REG_INTR_MASK_LINK_STATUS);\r\nbreak;\r\n}\r\n}\r\nstatic int bnx2x_54618se_config_init(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 port;\r\nu16 autoneg_val, an_1000_val, an_10_100_val, fc_val, temp;\r\nu32 cfg_pin;\r\nDP(NETIF_MSG_LINK, "54618SE cfg init\n");\r\nusleep_range(1000, 2000);\r\nport = params->port;\r\ncfg_pin = (REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[port].e3_cmn_pin_cfg)) &\r\nPORT_HW_CFG_E3_PHY_RESET_MASK) >>\r\nPORT_HW_CFG_E3_PHY_RESET_SHIFT;\r\nbnx2x_set_cfg_pin(bp, cfg_pin, 1);\r\nmsleep(50);\r\nbnx2x_cl22_write(bp, phy,\r\nMDIO_PMA_REG_CTRL, 0x8000);\r\nbnx2x_wait_reset_complete(bp, phy, params);\r\nmsleep(50);\r\nbnx2x_54618se_specific_func(phy, params, PHY_INIT);\r\nbnx2x_cl22_write(bp, phy,\r\nMDIO_REG_GPHY_SHADOW,\r\nMDIO_REG_GPHY_SHADOW_AUTO_DET_MED);\r\nbnx2x_cl22_read(bp, phy,\r\nMDIO_REG_GPHY_SHADOW,\r\n&temp);\r\ntemp |= MDIO_REG_GPHY_SHADOW_INVERT_FIB_SD;\r\nbnx2x_cl22_write(bp, phy,\r\nMDIO_REG_GPHY_SHADOW,\r\nMDIO_REG_GPHY_SHADOW_WR_ENA | temp);\r\nbnx2x_calc_ieee_aneg_adv(phy, params, &vars->ieee_fc);\r\nfc_val = 0;\r\nif ((vars->ieee_fc & MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) ==\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC)\r\nfc_val |= MDIO_AN_REG_ADV_PAUSE_ASYMMETRIC;\r\nif ((vars->ieee_fc & MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) ==\r\nMDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH)\r\nfc_val |= MDIO_AN_REG_ADV_PAUSE_PAUSE;\r\nbnx2x_cl22_read(bp, phy,\r\n0x09,\r\n&an_1000_val);\r\nbnx2x_cl22_read(bp, phy,\r\n0x04,\r\n&an_10_100_val);\r\nbnx2x_cl22_read(bp, phy,\r\nMDIO_PMA_REG_CTRL,\r\n&autoneg_val);\r\nautoneg_val &= ~((1<<6) | (1<<8) | (1<<9) | (1<<12) | (1<<13));\r\nan_10_100_val &= ~((1<<5) | (1<<6) | (1<<7) | (1<<8) | (1<<10) |\r\n(1<<11));\r\nif (((phy->req_line_speed == SPEED_AUTO_NEG) &&\r\n(phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_1G)) ||\r\n(phy->req_line_speed == SPEED_1000)) {\r\nan_1000_val |= (1<<8);\r\nautoneg_val |= (1<<9 | 1<<12);\r\nif (phy->req_duplex == DUPLEX_FULL)\r\nan_1000_val |= (1<<9);\r\nDP(NETIF_MSG_LINK, "Advertising 1G\n");\r\n} else\r\nan_1000_val &= ~((1<<8) | (1<<9));\r\nbnx2x_cl22_write(bp, phy,\r\n0x09,\r\nan_1000_val);\r\nbnx2x_cl22_read(bp, phy,\r\n0x09,\r\n&an_1000_val);\r\nif (phy->req_line_speed == SPEED_AUTO_NEG) {\r\nif (phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF) {\r\nan_10_100_val |= (1<<5);\r\nautoneg_val |= (1<<9 | 1<<12);\r\nDP(NETIF_MSG_LINK, "Advertising 10M-HD\n");\r\n}\r\nif (phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL) {\r\nan_10_100_val |= (1<<6);\r\nautoneg_val |= (1<<9 | 1<<12);\r\nDP(NETIF_MSG_LINK, "Advertising 10M-FD\n");\r\n}\r\nif (phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF) {\r\nan_10_100_val |= (1<<7);\r\nautoneg_val |= (1<<9 | 1<<12);\r\nDP(NETIF_MSG_LINK, "Advertising 100M-HD\n");\r\n}\r\nif (phy->speed_cap_mask &\r\nPORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL) {\r\nan_10_100_val |= (1<<8);\r\nautoneg_val |= (1<<9 | 1<<12);\r\nDP(NETIF_MSG_LINK, "Advertising 100M-FD\n");\r\n}\r\n}\r\nif (phy->req_line_speed == SPEED_100) {\r\nautoneg_val |= (1<<13);\r\nbnx2x_cl22_write(bp, phy,\r\n0x18,\r\n(1<<15 | 1<<9 | 7<<0));\r\nDP(NETIF_MSG_LINK, "Setting 100M force\n");\r\n}\r\nif (phy->req_line_speed == SPEED_10) {\r\nbnx2x_cl22_write(bp, phy,\r\n0x18,\r\n(1<<15 | 1<<9 | 7<<0));\r\nDP(NETIF_MSG_LINK, "Setting 10M force\n");\r\n}\r\nif ((phy->flags & FLAGS_EEE) && bnx2x_eee_has_cap(params)) {\r\nint rc;\r\nbnx2x_cl22_write(bp, phy, MDIO_REG_GPHY_EXP_ACCESS,\r\nMDIO_REG_GPHY_EXP_ACCESS_TOP |\r\nMDIO_REG_GPHY_EXP_TOP_2K_BUF);\r\nbnx2x_cl22_read(bp, phy, MDIO_REG_GPHY_EXP_ACCESS_GATE, &temp);\r\ntemp &= 0xfffe;\r\nbnx2x_cl22_write(bp, phy, MDIO_REG_GPHY_EXP_ACCESS_GATE, temp);\r\nrc = bnx2x_eee_initial_config(params, vars, SHMEM_EEE_1G_ADV);\r\nif (rc) {\r\nDP(NETIF_MSG_LINK, "Failed to configure EEE timers\n");\r\nbnx2x_eee_disable(phy, params, vars);\r\n} else if ((params->eee_mode & EEE_MODE_ADV_LPI) &&\r\n(phy->req_duplex == DUPLEX_FULL) &&\r\n(bnx2x_eee_calc_timer(params) ||\r\n!(params->eee_mode & EEE_MODE_ENABLE_LPI))) {\r\nbnx2x_eee_advertise(phy, params, vars,\r\nSHMEM_EEE_1G_ADV);\r\n} else {\r\nDP(NETIF_MSG_LINK, "Don't Advertise 1GBase-T EEE\n");\r\nbnx2x_eee_disable(phy, params, vars);\r\n}\r\n} else {\r\nvars->eee_status &= ~SHMEM_EEE_1G_ADV <<\r\nSHMEM_EEE_SUPPORTED_SHIFT;\r\nif (phy->flags & FLAGS_EEE) {\r\nif (params->feature_config_flags &\r\nFEATURE_CONFIG_AUTOGREEEN_ENABLED) {\r\ntemp = 6;\r\nDP(NETIF_MSG_LINK, "Enabling Auto-GrEEEn\n");\r\n} else {\r\ntemp = 0;\r\nDP(NETIF_MSG_LINK, "Don't Adv. EEE\n");\r\n}\r\nbnx2x_cl45_write(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_AN_REG_EEE_ADV, temp);\r\n}\r\n}\r\nbnx2x_cl22_write(bp, phy,\r\n0x04,\r\nan_10_100_val | fc_val);\r\nif (phy->req_duplex == DUPLEX_FULL)\r\nautoneg_val |= (1<<8);\r\nbnx2x_cl22_write(bp, phy,\r\nMDIO_PMA_REG_CTRL, autoneg_val);\r\nreturn 0;\r\n}\r\nstatic void bnx2x_5461x_set_link_led(struct bnx2x_phy *phy,\r\nstruct link_params *params, u8 mode)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 temp;\r\nbnx2x_cl22_write(bp, phy,\r\nMDIO_REG_GPHY_SHADOW,\r\nMDIO_REG_GPHY_SHADOW_LED_SEL1);\r\nbnx2x_cl22_read(bp, phy,\r\nMDIO_REG_GPHY_SHADOW,\r\n&temp);\r\ntemp &= 0xff00;\r\nDP(NETIF_MSG_LINK, "54618x set link led (mode=%x)\n", mode);\r\nswitch (mode) {\r\ncase LED_MODE_FRONT_PANEL_OFF:\r\ncase LED_MODE_OFF:\r\ntemp |= 0x00ee;\r\nbreak;\r\ncase LED_MODE_OPER:\r\ntemp |= 0x0001;\r\nbreak;\r\ncase LED_MODE_ON:\r\ntemp |= 0x00ff;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbnx2x_cl22_write(bp, phy,\r\nMDIO_REG_GPHY_SHADOW,\r\nMDIO_REG_GPHY_SHADOW_WR_ENA | temp);\r\nreturn;\r\n}\r\nstatic void bnx2x_54618se_link_reset(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu32 cfg_pin;\r\nu8 port;\r\nbnx2x_cl22_write(bp, phy, MDIO_PMA_REG_CTRL, 0x800);\r\nport = params->port;\r\ncfg_pin = (REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[port].e3_cmn_pin_cfg)) &\r\nPORT_HW_CFG_E3_PHY_RESET_MASK) >>\r\nPORT_HW_CFG_E3_PHY_RESET_SHIFT;\r\nbnx2x_set_cfg_pin(bp, cfg_pin, 0);\r\n}\r\nstatic u8 bnx2x_54618se_read_status(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 val;\r\nu8 link_up = 0;\r\nu16 legacy_status, legacy_speed;\r\nbnx2x_cl22_read(bp, phy,\r\nMDIO_REG_GPHY_AUX_STATUS,\r\n&legacy_status);\r\nDP(NETIF_MSG_LINK, "54618SE read_status: 0x%x\n", legacy_status);\r\nbnx2x_cl22_read(bp, phy,\r\nMDIO_REG_INTR_STATUS,\r\n&val);\r\nlink_up = ((legacy_status & (1<<2)) == (1<<2));\r\nif (link_up) {\r\nlegacy_speed = (legacy_status & (7<<8));\r\nif (legacy_speed == (7<<8)) {\r\nvars->line_speed = SPEED_1000;\r\nvars->duplex = DUPLEX_FULL;\r\n} else if (legacy_speed == (6<<8)) {\r\nvars->line_speed = SPEED_1000;\r\nvars->duplex = DUPLEX_HALF;\r\n} else if (legacy_speed == (5<<8)) {\r\nvars->line_speed = SPEED_100;\r\nvars->duplex = DUPLEX_FULL;\r\n}\r\nelse if (legacy_speed == (3<<8)) {\r\nvars->line_speed = SPEED_100;\r\nvars->duplex = DUPLEX_HALF;\r\n} else if (legacy_speed == (2<<8)) {\r\nvars->line_speed = SPEED_10;\r\nvars->duplex = DUPLEX_FULL;\r\n} else if (legacy_speed == (1<<8)) {\r\nvars->line_speed = SPEED_10;\r\nvars->duplex = DUPLEX_HALF;\r\n} else\r\nvars->line_speed = 0;\r\nDP(NETIF_MSG_LINK,\r\n"Link is up in %dMbps, is_duplex_full= %d\n",\r\nvars->line_speed,\r\n(vars->duplex == DUPLEX_FULL));\r\nbnx2x_cl22_read(bp, phy,\r\n0x01,\r\n&val);\r\nif (val & (1<<5))\r\nvars->link_status |=\r\nLINK_STATUS_AUTO_NEGOTIATE_COMPLETE;\r\nbnx2x_cl22_read(bp, phy,\r\n0x06,\r\n&val);\r\nif ((val & (1<<0)) == 0)\r\nvars->link_status |=\r\nLINK_STATUS_PARALLEL_DETECTION_USED;\r\nDP(NETIF_MSG_LINK, "BCM54618SE: link speed is %d\n",\r\nvars->line_speed);\r\nbnx2x_ext_phy_resolve_fc(phy, params, vars);\r\nif (vars->link_status & LINK_STATUS_AUTO_NEGOTIATE_COMPLETE) {\r\nbnx2x_cl22_read(bp, phy, 0x5, &val);\r\nif (val & (1<<5))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_10THD_CAPABLE;\r\nif (val & (1<<6))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_10TFD_CAPABLE;\r\nif (val & (1<<7))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_100TXHD_CAPABLE;\r\nif (val & (1<<8))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_100TXFD_CAPABLE;\r\nif (val & (1<<9))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_100T4_CAPABLE;\r\nbnx2x_cl22_read(bp, phy, 0xa, &val);\r\nif (val & (1<<10))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_1000THD_CAPABLE;\r\nif (val & (1<<11))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE;\r\nif ((phy->flags & FLAGS_EEE) &&\r\nbnx2x_eee_has_cap(params))\r\nbnx2x_eee_an_resolve(phy, params, vars);\r\n}\r\n}\r\nreturn link_up;\r\n}\r\nstatic void bnx2x_54618se_config_loopback(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 val;\r\nu32 umac_base = params->port ? GRCBASE_UMAC1 : GRCBASE_UMAC0;\r\nDP(NETIF_MSG_LINK, "2PMA/PMD ext_phy_loopback: 54618se\n");\r\nbnx2x_cl22_write(bp, phy, 0x09, 3<<11);\r\nbnx2x_cl22_read(bp, phy, 0x00, &val);\r\nval &= ~((1<<6) | (1<<12) | (1<<13));\r\nval |= (1<<6) | (1<<8);\r\nbnx2x_cl22_write(bp, phy, 0x00, val);\r\nbnx2x_cl22_write(bp, phy, 0x18, 7);\r\nbnx2x_cl22_read(bp, phy, 0x18, &val);\r\nbnx2x_cl22_write(bp, phy, 0x18, val | (1<<10) | (1<<15));\r\nREG_WR(bp, NIG_REG_EGRESS_EMAC0_PORT + params->port*4, 1);\r\nREG_WR(bp, umac_base + UMAC_REG_MAXFR, 0x2710);\r\n}\r\nstatic void bnx2x_7101_config_loopback(struct bnx2x_phy *phy,\r\nstruct link_params *params)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_XS_DEVAD, MDIO_XS_SFX7101_XGXS_TEST1, 0x100);\r\n}\r\nstatic int bnx2x_7101_config_init(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nu16 fw_ver1, fw_ver2, val;\r\nstruct bnx2x *bp = params->bp;\r\nDP(NETIF_MSG_LINK, "Setting the SFX7101 LASI indication\n");\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\r\nMISC_REGISTERS_GPIO_OUTPUT_HIGH, params->port);\r\nbnx2x_ext_phy_hw_reset(bp, params->port);\r\nbnx2x_wait_reset_complete(bp, phy, params);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_CTRL, 0x1);\r\nDP(NETIF_MSG_LINK, "Setting the SFX7101 LED to blink on traffic\n");\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_7107_LED_CNTL, (1<<3));\r\nbnx2x_ext_phy_set_pause(params, phy, vars);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_CTRL, &val);\r\nval |= 0x200;\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_CTRL, val);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_7101_VER1, &fw_ver1);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_7101_VER2, &fw_ver2);\r\nbnx2x_save_spirom_version(bp, params->port,\r\n(u32)(fw_ver1<<16 | fw_ver2), phy->ver_addr);\r\nreturn 0;\r\n}\r\nstatic u8 bnx2x_7101_read_status(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 link_up;\r\nu16 val1, val2;\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_STAT, &val2);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_LASI_STAT, &val1);\r\nDP(NETIF_MSG_LINK, "10G-base-T LASI status 0x%x->0x%x\n",\r\nval2, val1);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_STATUS, &val2);\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_STATUS, &val1);\r\nDP(NETIF_MSG_LINK, "10G-base-T PMA status 0x%x->0x%x\n",\r\nval2, val1);\r\nlink_up = ((val1 & 4) == 4);\r\nif (link_up) {\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_AN_DEVAD, MDIO_AN_REG_MASTER_STATUS,\r\n&val2);\r\nvars->line_speed = SPEED_10000;\r\nvars->duplex = DUPLEX_FULL;\r\nDP(NETIF_MSG_LINK, "SFX7101 AN status 0x%x->Master=%x\n",\r\nval2, (val2 & (1<<14)));\r\nbnx2x_ext_phy_10G_an_resolve(bp, phy, vars);\r\nbnx2x_ext_phy_resolve_fc(phy, params, vars);\r\nif (val2 & (1<<11))\r\nvars->link_status |=\r\nLINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE;\r\n}\r\nreturn link_up;\r\n}\r\nstatic int bnx2x_7101_format_ver(u32 spirom_ver, u8 *str, u16 *len)\r\n{\r\nif (*len < 5)\r\nreturn -EINVAL;\r\nstr[0] = (spirom_ver & 0xFF);\r\nstr[1] = (spirom_ver & 0xFF00) >> 8;\r\nstr[2] = (spirom_ver & 0xFF0000) >> 16;\r\nstr[3] = (spirom_ver & 0xFF000000) >> 24;\r\nstr[4] = '\0';\r\n*len -= 5;\r\nreturn 0;\r\n}\r\nvoid bnx2x_sfx7101_sp_sw_reset(struct bnx2x *bp, struct bnx2x_phy *phy)\r\n{\r\nu16 val, cnt;\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_7101_RESET, &val);\r\nfor (cnt = 0; cnt < 10; cnt++) {\r\nmsleep(50);\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_7101_RESET,\r\n(val | (1<<15)));\r\nbnx2x_cl45_read(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_7101_RESET, &val);\r\nif ((val & (1<<15)) == 0)\r\nbreak;\r\n}\r\n}\r\nstatic void bnx2x_7101_hw_reset(struct bnx2x_phy *phy,\r\nstruct link_params *params) {\r\nbnx2x_set_gpio(params->bp, MISC_REGISTERS_GPIO_2,\r\nMISC_REGISTERS_GPIO_OUTPUT_LOW, params->port);\r\nbnx2x_set_gpio(params->bp, MISC_REGISTERS_GPIO_1,\r\nMISC_REGISTERS_GPIO_OUTPUT_LOW, params->port);\r\n}\r\nstatic void bnx2x_7101_set_link_led(struct bnx2x_phy *phy,\r\nstruct link_params *params, u8 mode)\r\n{\r\nu16 val = 0;\r\nstruct bnx2x *bp = params->bp;\r\nswitch (mode) {\r\ncase LED_MODE_FRONT_PANEL_OFF:\r\ncase LED_MODE_OFF:\r\nval = 2;\r\nbreak;\r\ncase LED_MODE_ON:\r\nval = 1;\r\nbreak;\r\ncase LED_MODE_OPER:\r\nval = 0;\r\nbreak;\r\n}\r\nbnx2x_cl45_write(bp, phy,\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_7107_LINK_LED_CNTL,\r\nval);\r\n}\r\nstatic void bnx2x_populate_preemphasis(struct bnx2x *bp, u32 shmem_base,\r\nstruct bnx2x_phy *phy, u8 port,\r\nu8 phy_index)\r\n{\r\nu32 rx = 0, tx = 0, i;\r\nfor (i = 0; i < 2; i++) {\r\nif (phy_index == INT_PHY || phy_index == EXT_PHY1) {\r\nrx = REG_RD(bp, shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[port].xgxs_config_rx[i<<1]));\r\ntx = REG_RD(bp, shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[port].xgxs_config_tx[i<<1]));\r\n} else {\r\nrx = REG_RD(bp, shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[port].xgxs_config2_rx[i<<1]));\r\ntx = REG_RD(bp, shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[port].xgxs_config2_rx[i<<1]));\r\n}\r\nphy->rx_preemphasis[i << 1] = ((rx>>16) & 0xffff);\r\nphy->rx_preemphasis[(i << 1) + 1] = (rx & 0xffff);\r\nphy->tx_preemphasis[i << 1] = ((tx>>16) & 0xffff);\r\nphy->tx_preemphasis[(i << 1) + 1] = (tx & 0xffff);\r\n}\r\n}\r\nstatic u32 bnx2x_get_ext_phy_config(struct bnx2x *bp, u32 shmem_base,\r\nu8 phy_index, u8 port)\r\n{\r\nu32 ext_phy_config = 0;\r\nswitch (phy_index) {\r\ncase EXT_PHY1:\r\next_phy_config = REG_RD(bp, shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[port].external_phy_config));\r\nbreak;\r\ncase EXT_PHY2:\r\next_phy_config = REG_RD(bp, shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[port].external_phy_config2));\r\nbreak;\r\ndefault:\r\nDP(NETIF_MSG_LINK, "Invalid phy_index %d\n", phy_index);\r\nreturn -EINVAL;\r\n}\r\nreturn ext_phy_config;\r\n}\r\nstatic int bnx2x_populate_int_phy(struct bnx2x *bp, u32 shmem_base, u8 port,\r\nstruct bnx2x_phy *phy)\r\n{\r\nu32 phy_addr;\r\nu32 chip_id;\r\nu32 switch_cfg = (REG_RD(bp, shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_feature_config[port].link_config)) &\r\nPORT_FEATURE_CONNECTED_SWITCH_MASK);\r\nchip_id = (REG_RD(bp, MISC_REG_CHIP_NUM) << 16) |\r\n((REG_RD(bp, MISC_REG_CHIP_REV) & 0xf) << 12);\r\nDP(NETIF_MSG_LINK, ":chip_id = 0x%x\n", chip_id);\r\nif (USES_WARPCORE(bp)) {\r\nu32 serdes_net_if;\r\nphy_addr = REG_RD(bp,\r\nMISC_REG_WC0_CTRL_PHY_ADDR);\r\n*phy = phy_warpcore;\r\nif (REG_RD(bp, MISC_REG_PORT4MODE_EN_OVWR) == 0x3)\r\nphy->flags |= FLAGS_4_PORT_MODE;\r\nelse\r\nphy->flags &= ~FLAGS_4_PORT_MODE;\r\nserdes_net_if = (REG_RD(bp, shmem_base +\r\noffsetof(struct shmem_region, dev_info.\r\nport_hw_config[port].default_cfg)) &\r\nPORT_HW_CFG_NET_SERDES_IF_MASK);\r\nswitch (serdes_net_if) {\r\ncase PORT_HW_CFG_NET_SERDES_IF_SGMII:\r\nphy->supported &= (SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_1000baseT_Full |\r\nSUPPORTED_FIBRE |\r\nSUPPORTED_Autoneg |\r\nSUPPORTED_Pause |\r\nSUPPORTED_Asym_Pause);\r\nphy->media_type = ETH_PHY_BASE_T;\r\nbreak;\r\ncase PORT_HW_CFG_NET_SERDES_IF_XFI:\r\nphy->supported &= (SUPPORTED_1000baseT_Full |\r\nSUPPORTED_10000baseT_Full |\r\nSUPPORTED_FIBRE |\r\nSUPPORTED_Pause |\r\nSUPPORTED_Asym_Pause);\r\nphy->media_type = ETH_PHY_XFP_FIBER;\r\nbreak;\r\ncase PORT_HW_CFG_NET_SERDES_IF_SFI:\r\nphy->supported &= (SUPPORTED_1000baseT_Full |\r\nSUPPORTED_10000baseT_Full |\r\nSUPPORTED_FIBRE |\r\nSUPPORTED_Pause |\r\nSUPPORTED_Asym_Pause);\r\nphy->media_type = ETH_PHY_SFPP_10G_FIBER;\r\nbreak;\r\ncase PORT_HW_CFG_NET_SERDES_IF_KR:\r\nphy->media_type = ETH_PHY_KR;\r\nphy->supported &= (SUPPORTED_1000baseT_Full |\r\nSUPPORTED_10000baseT_Full |\r\nSUPPORTED_FIBRE |\r\nSUPPORTED_Autoneg |\r\nSUPPORTED_Pause |\r\nSUPPORTED_Asym_Pause);\r\nbreak;\r\ncase PORT_HW_CFG_NET_SERDES_IF_DXGXS:\r\nphy->media_type = ETH_PHY_KR;\r\nphy->flags |= FLAGS_WC_DUAL_MODE;\r\nphy->supported &= (SUPPORTED_20000baseMLD2_Full |\r\nSUPPORTED_FIBRE |\r\nSUPPORTED_Pause |\r\nSUPPORTED_Asym_Pause);\r\nbreak;\r\ncase PORT_HW_CFG_NET_SERDES_IF_KR2:\r\nphy->media_type = ETH_PHY_KR;\r\nphy->flags |= FLAGS_WC_DUAL_MODE;\r\nphy->supported &= (SUPPORTED_20000baseKR2_Full |\r\nSUPPORTED_10000baseT_Full |\r\nSUPPORTED_1000baseT_Full |\r\nSUPPORTED_Autoneg |\r\nSUPPORTED_FIBRE |\r\nSUPPORTED_Pause |\r\nSUPPORTED_Asym_Pause);\r\nphy->flags &= ~FLAGS_TX_ERROR_CHECK;\r\nbreak;\r\ndefault:\r\nDP(NETIF_MSG_LINK, "Unknown WC interface type 0x%x\n",\r\nserdes_net_if);\r\nbreak;\r\n}\r\nif (CHIP_REV(bp) == CHIP_REV_Ax)\r\nphy->flags |= FLAGS_MDC_MDIO_WA;\r\nelse\r\nphy->flags |= FLAGS_MDC_MDIO_WA_B0;\r\n} else {\r\nswitch (switch_cfg) {\r\ncase SWITCH_CFG_1G:\r\nphy_addr = REG_RD(bp,\r\nNIG_REG_SERDES0_CTRL_PHY_ADDR +\r\nport * 0x10);\r\n*phy = phy_serdes;\r\nbreak;\r\ncase SWITCH_CFG_10G:\r\nphy_addr = REG_RD(bp,\r\nNIG_REG_XGXS0_CTRL_PHY_ADDR +\r\nport * 0x18);\r\n*phy = phy_xgxs;\r\nbreak;\r\ndefault:\r\nDP(NETIF_MSG_LINK, "Invalid switch_cfg\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nphy->addr = (u8)phy_addr;\r\nphy->mdio_ctrl = bnx2x_get_emac_base(bp,\r\nSHARED_HW_CFG_MDC_MDIO_ACCESS1_BOTH,\r\nport);\r\nif (CHIP_IS_E2(bp))\r\nphy->def_md_devad = E2_DEFAULT_PHY_DEV_ADDR;\r\nelse\r\nphy->def_md_devad = DEFAULT_PHY_DEV_ADDR;\r\nDP(NETIF_MSG_LINK, "Internal phy port=%d, addr=0x%x, mdio_ctl=0x%x\n",\r\nport, phy->addr, phy->mdio_ctrl);\r\nbnx2x_populate_preemphasis(bp, shmem_base, phy, port, INT_PHY);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_populate_ext_phy(struct bnx2x *bp,\r\nu8 phy_index,\r\nu32 shmem_base,\r\nu32 shmem2_base,\r\nu8 port,\r\nstruct bnx2x_phy *phy)\r\n{\r\nu32 ext_phy_config, phy_type, config2;\r\nu32 mdc_mdio_access = SHARED_HW_CFG_MDC_MDIO_ACCESS1_BOTH;\r\next_phy_config = bnx2x_get_ext_phy_config(bp, shmem_base,\r\nphy_index, port);\r\nphy_type = XGXS_EXT_PHY_TYPE(ext_phy_config);\r\nswitch (phy_type) {\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073:\r\nmdc_mdio_access = SHARED_HW_CFG_MDC_MDIO_ACCESS1_SWAPPED;\r\n*phy = phy_8073;\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705:\r\n*phy = phy_8705;\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706:\r\n*phy = phy_8706;\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:\r\nmdc_mdio_access = SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC1;\r\n*phy = phy_8726;\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727_NOC:\r\nmdc_mdio_access = SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC1;\r\n*phy = phy_8727;\r\nphy->flags |= FLAGS_NOC;\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722:\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:\r\nmdc_mdio_access = SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC1;\r\n*phy = phy_8727;\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481:\r\n*phy = phy_8481;\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823:\r\n*phy = phy_84823;\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833:\r\n*phy = phy_84833;\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834:\r\n*phy = phy_84834;\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54616:\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE:\r\n*phy = phy_54618se;\r\nif (phy_type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE)\r\nphy->flags |= FLAGS_EEE;\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101:\r\n*phy = phy_7101;\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE:\r\n*phy = phy_null;\r\nreturn -EINVAL;\r\ndefault:\r\n*phy = phy_null;\r\nif ((phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) &&\r\n(phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nphy->addr = XGXS_EXT_PHY_ADDR(ext_phy_config);\r\nbnx2x_populate_preemphasis(bp, shmem_base, phy, port, phy_index);\r\nconfig2 = REG_RD(bp, shmem_base + offsetof(struct shmem_region,\r\ndev_info.shared_hw_config.config2));\r\nif (phy_index == EXT_PHY1) {\r\nphy->ver_addr = shmem_base + offsetof(struct shmem_region,\r\nport_mb[port].ext_phy_fw_version);\r\nif (config2 & SHARED_HW_CFG_MDC_MDIO_ACCESS1_MASK)\r\nmdc_mdio_access = config2 &\r\nSHARED_HW_CFG_MDC_MDIO_ACCESS1_MASK;\r\n} else {\r\nu32 size = REG_RD(bp, shmem2_base);\r\nif (size >\r\noffsetof(struct shmem2_region, ext_phy_fw_version2)) {\r\nphy->ver_addr = shmem2_base +\r\noffsetof(struct shmem2_region,\r\next_phy_fw_version2[port]);\r\n}\r\nif (config2 & SHARED_HW_CFG_MDC_MDIO_ACCESS2_MASK)\r\nmdc_mdio_access = (config2 &\r\nSHARED_HW_CFG_MDC_MDIO_ACCESS2_MASK) >>\r\n(SHARED_HW_CFG_MDC_MDIO_ACCESS2_SHIFT -\r\nSHARED_HW_CFG_MDC_MDIO_ACCESS1_SHIFT);\r\n}\r\nphy->mdio_ctrl = bnx2x_get_emac_base(bp, mdc_mdio_access, port);\r\nif (((phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833) ||\r\n(phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834)) &&\r\n(phy->ver_addr)) {\r\nu32 raw_ver = REG_RD(bp, phy->ver_addr);\r\nif (((raw_ver & 0x7F) <= 39) &&\r\n(((raw_ver & 0xF80) >> 7) <= 1))\r\nphy->supported &= ~(SUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full);\r\n}\r\nDP(NETIF_MSG_LINK, "phy_type 0x%x port %d found in index %d\n",\r\nphy_type, port, phy_index);\r\nDP(NETIF_MSG_LINK, " addr=0x%x, mdio_ctl=0x%x\n",\r\nphy->addr, phy->mdio_ctrl);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_populate_phy(struct bnx2x *bp, u8 phy_index, u32 shmem_base,\r\nu32 shmem2_base, u8 port, struct bnx2x_phy *phy)\r\n{\r\nint status = 0;\r\nphy->type = PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN;\r\nif (phy_index == INT_PHY)\r\nreturn bnx2x_populate_int_phy(bp, shmem_base, port, phy);\r\nstatus = bnx2x_populate_ext_phy(bp, phy_index, shmem_base, shmem2_base,\r\nport, phy);\r\nreturn status;\r\n}\r\nstatic void bnx2x_phy_def_cfg(struct link_params *params,\r\nstruct bnx2x_phy *phy,\r\nu8 phy_index)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu32 link_config;\r\nif (phy_index == EXT_PHY2) {\r\nlink_config = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region, dev_info.\r\nport_feature_config[params->port].link_config2));\r\nphy->speed_cap_mask = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.\r\nport_hw_config[params->port].speed_capability_mask2));\r\n} else {\r\nlink_config = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region, dev_info.\r\nport_feature_config[params->port].link_config));\r\nphy->speed_cap_mask = REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.\r\nport_hw_config[params->port].speed_capability_mask));\r\n}\r\nDP(NETIF_MSG_LINK,\r\n"Default config phy idx %x cfg 0x%x speed_cap_mask 0x%x\n",\r\nphy_index, link_config, phy->speed_cap_mask);\r\nphy->req_duplex = DUPLEX_FULL;\r\nswitch (link_config & PORT_FEATURE_LINK_SPEED_MASK) {\r\ncase PORT_FEATURE_LINK_SPEED_10M_HALF:\r\nphy->req_duplex = DUPLEX_HALF;\r\ncase PORT_FEATURE_LINK_SPEED_10M_FULL:\r\nphy->req_line_speed = SPEED_10;\r\nbreak;\r\ncase PORT_FEATURE_LINK_SPEED_100M_HALF:\r\nphy->req_duplex = DUPLEX_HALF;\r\ncase PORT_FEATURE_LINK_SPEED_100M_FULL:\r\nphy->req_line_speed = SPEED_100;\r\nbreak;\r\ncase PORT_FEATURE_LINK_SPEED_1G:\r\nphy->req_line_speed = SPEED_1000;\r\nbreak;\r\ncase PORT_FEATURE_LINK_SPEED_2_5G:\r\nphy->req_line_speed = SPEED_2500;\r\nbreak;\r\ncase PORT_FEATURE_LINK_SPEED_10G_CX4:\r\nphy->req_line_speed = SPEED_10000;\r\nbreak;\r\ndefault:\r\nphy->req_line_speed = SPEED_AUTO_NEG;\r\nbreak;\r\n}\r\nswitch (link_config & PORT_FEATURE_FLOW_CONTROL_MASK) {\r\ncase PORT_FEATURE_FLOW_CONTROL_AUTO:\r\nphy->req_flow_ctrl = BNX2X_FLOW_CTRL_AUTO;\r\nbreak;\r\ncase PORT_FEATURE_FLOW_CONTROL_TX:\r\nphy->req_flow_ctrl = BNX2X_FLOW_CTRL_TX;\r\nbreak;\r\ncase PORT_FEATURE_FLOW_CONTROL_RX:\r\nphy->req_flow_ctrl = BNX2X_FLOW_CTRL_RX;\r\nbreak;\r\ncase PORT_FEATURE_FLOW_CONTROL_BOTH:\r\nphy->req_flow_ctrl = BNX2X_FLOW_CTRL_BOTH;\r\nbreak;\r\ndefault:\r\nphy->req_flow_ctrl = BNX2X_FLOW_CTRL_NONE;\r\nbreak;\r\n}\r\n}\r\nu32 bnx2x_phy_selection(struct link_params *params)\r\n{\r\nu32 phy_config_swapped, prio_cfg;\r\nu32 return_cfg = PORT_HW_CFG_PHY_SELECTION_HARDWARE_DEFAULT;\r\nphy_config_swapped = params->multi_phy_config &\r\nPORT_HW_CFG_PHY_SWAPPED_ENABLED;\r\nprio_cfg = params->multi_phy_config &\r\nPORT_HW_CFG_PHY_SELECTION_MASK;\r\nif (phy_config_swapped) {\r\nswitch (prio_cfg) {\r\ncase PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY:\r\nreturn_cfg = PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY;\r\nbreak;\r\ncase PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY:\r\nreturn_cfg = PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY;\r\nbreak;\r\ncase PORT_HW_CFG_PHY_SELECTION_SECOND_PHY:\r\nreturn_cfg = PORT_HW_CFG_PHY_SELECTION_FIRST_PHY;\r\nbreak;\r\ncase PORT_HW_CFG_PHY_SELECTION_FIRST_PHY:\r\nreturn_cfg = PORT_HW_CFG_PHY_SELECTION_SECOND_PHY;\r\nbreak;\r\n}\r\n} else\r\nreturn_cfg = prio_cfg;\r\nreturn return_cfg;\r\n}\r\nint bnx2x_phy_probe(struct link_params *params)\r\n{\r\nu8 phy_index, actual_phy_idx;\r\nu32 phy_config_swapped, sync_offset, media_types;\r\nstruct bnx2x *bp = params->bp;\r\nstruct bnx2x_phy *phy;\r\nparams->num_phys = 0;\r\nDP(NETIF_MSG_LINK, "Begin phy probe\n");\r\nphy_config_swapped = params->multi_phy_config &\r\nPORT_HW_CFG_PHY_SWAPPED_ENABLED;\r\nfor (phy_index = INT_PHY; phy_index < MAX_PHYS;\r\nphy_index++) {\r\nactual_phy_idx = phy_index;\r\nif (phy_config_swapped) {\r\nif (phy_index == EXT_PHY1)\r\nactual_phy_idx = EXT_PHY2;\r\nelse if (phy_index == EXT_PHY2)\r\nactual_phy_idx = EXT_PHY1;\r\n}\r\nDP(NETIF_MSG_LINK, "phy_config_swapped %x, phy_index %x,"\r\n" actual_phy_idx %x\n", phy_config_swapped,\r\nphy_index, actual_phy_idx);\r\nphy = &params->phy[actual_phy_idx];\r\nif (bnx2x_populate_phy(bp, phy_index, params->shmem_base,\r\nparams->shmem2_base, params->port,\r\nphy) != 0) {\r\nparams->num_phys = 0;\r\nDP(NETIF_MSG_LINK, "phy probe failed in phy index %d\n",\r\nphy_index);\r\nfor (phy_index = INT_PHY;\r\nphy_index < MAX_PHYS;\r\nphy_index++)\r\n*phy = phy_null;\r\nreturn -EINVAL;\r\n}\r\nif (phy->type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN)\r\nbreak;\r\nif (params->feature_config_flags &\r\nFEATURE_CONFIG_DISABLE_REMOTE_FAULT_DET)\r\nphy->flags &= ~FLAGS_TX_ERROR_CHECK;\r\nif (!(params->feature_config_flags &\r\nFEATURE_CONFIG_MT_SUPPORT))\r\nphy->flags |= FLAGS_MDC_MDIO_WA_G;\r\nsync_offset = params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[params->port].media_type);\r\nmedia_types = REG_RD(bp, sync_offset);\r\nif ((media_types & (PORT_HW_CFG_MEDIA_TYPE_PHY0_MASK <<\r\n(PORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT *\r\nactual_phy_idx))) == 0) {\r\nmedia_types |= ((phy->media_type &\r\nPORT_HW_CFG_MEDIA_TYPE_PHY0_MASK) <<\r\n(PORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT *\r\nactual_phy_idx));\r\n}\r\nREG_WR(bp, sync_offset, media_types);\r\nbnx2x_phy_def_cfg(params, phy, phy_index);\r\nparams->num_phys++;\r\n}\r\nDP(NETIF_MSG_LINK, "End phy probe. #phys found %x\n", params->num_phys);\r\nreturn 0;\r\n}\r\nstatic void bnx2x_init_bmac_loopback(struct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nvars->link_up = 1;\r\nvars->line_speed = SPEED_10000;\r\nvars->duplex = DUPLEX_FULL;\r\nvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\r\nvars->mac_type = MAC_TYPE_BMAC;\r\nvars->phy_flags = PHY_XGXS_FLAG;\r\nbnx2x_xgxs_deassert(params);\r\nbnx2x_bmac_enable(params, vars, 1, 1);\r\nREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\r\n}\r\nstatic void bnx2x_init_emac_loopback(struct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nvars->link_up = 1;\r\nvars->line_speed = SPEED_1000;\r\nvars->duplex = DUPLEX_FULL;\r\nvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\r\nvars->mac_type = MAC_TYPE_EMAC;\r\nvars->phy_flags = PHY_XGXS_FLAG;\r\nbnx2x_xgxs_deassert(params);\r\nbnx2x_emac_enable(params, vars, 1);\r\nbnx2x_emac_program(params, vars);\r\nREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\r\n}\r\nstatic void bnx2x_init_xmac_loopback(struct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nvars->link_up = 1;\r\nif (!params->req_line_speed[0])\r\nvars->line_speed = SPEED_10000;\r\nelse\r\nvars->line_speed = params->req_line_speed[0];\r\nvars->duplex = DUPLEX_FULL;\r\nvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\r\nvars->mac_type = MAC_TYPE_XMAC;\r\nvars->phy_flags = PHY_XGXS_FLAG;\r\nbnx2x_set_aer_mmd(params, &params->phy[0]);\r\nbnx2x_warpcore_reset_lane(bp, &params->phy[0], 0);\r\nparams->phy[INT_PHY].config_loopback(\r\n&params->phy[INT_PHY],\r\nparams);\r\nbnx2x_xmac_enable(params, vars, 1);\r\nREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\r\n}\r\nstatic void bnx2x_init_umac_loopback(struct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nvars->link_up = 1;\r\nvars->line_speed = SPEED_1000;\r\nvars->duplex = DUPLEX_FULL;\r\nvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\r\nvars->mac_type = MAC_TYPE_UMAC;\r\nvars->phy_flags = PHY_XGXS_FLAG;\r\nbnx2x_umac_enable(params, vars, 1);\r\nREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\r\n}\r\nstatic void bnx2x_init_xgxs_loopback(struct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nstruct bnx2x_phy *int_phy = &params->phy[INT_PHY];\r\nvars->link_up = 1;\r\nvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\r\nvars->duplex = DUPLEX_FULL;\r\nif (params->req_line_speed[0] == SPEED_1000)\r\nvars->line_speed = SPEED_1000;\r\nelse if ((params->req_line_speed[0] == SPEED_20000) ||\r\n(int_phy->flags & FLAGS_WC_DUAL_MODE))\r\nvars->line_speed = SPEED_20000;\r\nelse\r\nvars->line_speed = SPEED_10000;\r\nif (!USES_WARPCORE(bp))\r\nbnx2x_xgxs_deassert(params);\r\nbnx2x_link_initialize(params, vars);\r\nif (params->req_line_speed[0] == SPEED_1000) {\r\nif (USES_WARPCORE(bp))\r\nbnx2x_umac_enable(params, vars, 0);\r\nelse {\r\nbnx2x_emac_program(params, vars);\r\nbnx2x_emac_enable(params, vars, 0);\r\n}\r\n} else {\r\nif (USES_WARPCORE(bp))\r\nbnx2x_xmac_enable(params, vars, 0);\r\nelse\r\nbnx2x_bmac_enable(params, vars, 0, 1);\r\n}\r\nif (params->loopback_mode == LOOPBACK_XGXS) {\r\nint_phy->config_loopback(int_phy, params);\r\n} else {\r\nu8 phy_index;\r\nfor (phy_index = EXT_PHY1;\r\nphy_index < params->num_phys; phy_index++)\r\nif (params->phy[phy_index].config_loopback)\r\nparams->phy[phy_index].config_loopback(\r\n&params->phy[phy_index],\r\nparams);\r\n}\r\nREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\r\nbnx2x_set_led(params, vars, LED_MODE_OPER, vars->line_speed);\r\n}\r\nvoid bnx2x_set_rx_filter(struct link_params *params, u8 en)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 val = en * 0x1F;\r\nif (!CHIP_IS_E1x(bp))\r\nval |= en * 0x20;\r\nREG_WR(bp, NIG_REG_LLH0_BRB1_DRV_MASK + params->port*4, val);\r\nif (!CHIP_IS_E1(bp)) {\r\nREG_WR(bp, NIG_REG_LLH0_BRB1_DRV_MASK_MF + params->port*4,\r\nen*0x3);\r\n}\r\nREG_WR(bp, (params->port ? NIG_REG_LLH1_BRB1_NOT_MCP :\r\nNIG_REG_LLH0_BRB1_NOT_MCP), en);\r\n}\r\nstatic int bnx2x_avoid_link_flap(struct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nu32 phy_idx;\r\nu32 dont_clear_stat, lfa_sts;\r\nstruct bnx2x *bp = params->bp;\r\nbnx2x_set_mdio_emac_per_phy(bp, params);\r\nbnx2x_link_status_update(params, vars);\r\nfor (phy_idx = INT_PHY; phy_idx < params->num_phys; phy_idx++) {\r\nstruct bnx2x_phy *phy = &params->phy[phy_idx];\r\nif (phy->phy_specific_func) {\r\nDP(NETIF_MSG_LINK, "Calling PHY specific func\n");\r\nphy->phy_specific_func(phy, params, PHY_INIT);\r\n}\r\nif ((phy->media_type == ETH_PHY_SFPP_10G_FIBER) ||\r\n(phy->media_type == ETH_PHY_SFP_1G_FIBER) ||\r\n(phy->media_type == ETH_PHY_DA_TWINAX))\r\nbnx2x_verify_sfp_module(phy, params);\r\n}\r\nlfa_sts = REG_RD(bp, params->lfa_base +\r\noffsetof(struct shmem_lfa,\r\nlfa_sts));\r\ndont_clear_stat = lfa_sts & SHMEM_LFA_DONT_CLEAR_STAT;\r\nif (CHIP_IS_E3(bp)) {\r\nif (!dont_clear_stat) {\r\nREG_WR(bp, GRCBASE_MISC +\r\nMISC_REGISTERS_RESET_REG_2_CLEAR,\r\n(MISC_REGISTERS_RESET_REG_2_MSTAT0 <<\r\nparams->port));\r\nREG_WR(bp, GRCBASE_MISC +\r\nMISC_REGISTERS_RESET_REG_2_SET,\r\n(MISC_REGISTERS_RESET_REG_2_MSTAT0 <<\r\nparams->port));\r\n}\r\nif (vars->line_speed < SPEED_10000)\r\nbnx2x_umac_enable(params, vars, 0);\r\nelse\r\nbnx2x_xmac_enable(params, vars, 0);\r\n} else {\r\nif (vars->line_speed < SPEED_10000)\r\nbnx2x_emac_enable(params, vars, 0);\r\nelse\r\nbnx2x_bmac_enable(params, vars, 0, !dont_clear_stat);\r\n}\r\nlfa_sts = ((lfa_sts & ~LINK_FLAP_AVOIDANCE_COUNT_MASK) |\r\n(((((lfa_sts & LINK_FLAP_AVOIDANCE_COUNT_MASK) >>\r\nLINK_FLAP_AVOIDANCE_COUNT_OFFSET) + 1) & 0xff)\r\n<< LINK_FLAP_AVOIDANCE_COUNT_OFFSET));\r\nlfa_sts &= ~LFA_LINK_FLAP_REASON_MASK;\r\nREG_WR(bp, params->lfa_base +\r\noffsetof(struct shmem_lfa, lfa_sts), lfa_sts);\r\nREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\r\nbnx2x_link_int_enable(params);\r\nreturn 0;\r\n}\r\nstatic void bnx2x_cannot_avoid_link_flap(struct link_params *params,\r\nstruct link_vars *vars,\r\nint lfa_status)\r\n{\r\nu32 lfa_sts, cfg_idx, tmp_val;\r\nstruct bnx2x *bp = params->bp;\r\nbnx2x_link_reset(params, vars, 1);\r\nif (!params->lfa_base)\r\nreturn;\r\nREG_WR(bp, params->lfa_base +\r\noffsetof(struct shmem_lfa, req_duplex),\r\nparams->req_duplex[0] | (params->req_duplex[1] << 16));\r\nREG_WR(bp, params->lfa_base +\r\noffsetof(struct shmem_lfa, req_flow_ctrl),\r\nparams->req_flow_ctrl[0] | (params->req_flow_ctrl[1] << 16));\r\nREG_WR(bp, params->lfa_base +\r\noffsetof(struct shmem_lfa, req_line_speed),\r\nparams->req_line_speed[0] | (params->req_line_speed[1] << 16));\r\nfor (cfg_idx = 0; cfg_idx < SHMEM_LINK_CONFIG_SIZE; cfg_idx++) {\r\nREG_WR(bp, params->lfa_base +\r\noffsetof(struct shmem_lfa,\r\nspeed_cap_mask[cfg_idx]),\r\nparams->speed_cap_mask[cfg_idx]);\r\n}\r\ntmp_val = REG_RD(bp, params->lfa_base +\r\noffsetof(struct shmem_lfa, additional_config));\r\ntmp_val &= ~REQ_FC_AUTO_ADV_MASK;\r\ntmp_val |= params->req_fc_auto_adv;\r\nREG_WR(bp, params->lfa_base +\r\noffsetof(struct shmem_lfa, additional_config), tmp_val);\r\nlfa_sts = REG_RD(bp, params->lfa_base +\r\noffsetof(struct shmem_lfa, lfa_sts));\r\nlfa_sts &= ~SHMEM_LFA_DONT_CLEAR_STAT;\r\nlfa_sts &= ~LFA_LINK_FLAP_REASON_MASK;\r\nlfa_sts |= ((lfa_status & LFA_LINK_FLAP_REASON_MASK) <<\r\nLFA_LINK_FLAP_REASON_OFFSET);\r\nlfa_sts = ((lfa_sts & ~LINK_FLAP_COUNT_MASK) |\r\n(((((lfa_sts & LINK_FLAP_COUNT_MASK) >>\r\nLINK_FLAP_COUNT_OFFSET) + 1) & 0xff)\r\n<< LINK_FLAP_COUNT_OFFSET));\r\nREG_WR(bp, params->lfa_base +\r\noffsetof(struct shmem_lfa, lfa_sts), lfa_sts);\r\n}\r\nint bnx2x_phy_init(struct link_params *params, struct link_vars *vars)\r\n{\r\nint lfa_status;\r\nstruct bnx2x *bp = params->bp;\r\nDP(NETIF_MSG_LINK, "Phy Initialization started\n");\r\nDP(NETIF_MSG_LINK, "(1) req_speed %d, req_flowctrl %d\n",\r\nparams->req_line_speed[0], params->req_flow_ctrl[0]);\r\nDP(NETIF_MSG_LINK, "(2) req_speed %d, req_flowctrl %d\n",\r\nparams->req_line_speed[1], params->req_flow_ctrl[1]);\r\nDP(NETIF_MSG_LINK, "req_adv_flow_ctrl 0x%x\n", params->req_fc_auto_adv);\r\nvars->link_status = 0;\r\nvars->phy_link_up = 0;\r\nvars->link_up = 0;\r\nvars->line_speed = 0;\r\nvars->duplex = DUPLEX_FULL;\r\nvars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;\r\nvars->mac_type = MAC_TYPE_NONE;\r\nvars->phy_flags = 0;\r\nvars->check_kr2_recovery_cnt = 0;\r\nparams->link_flags = PHY_INITIALIZED;\r\nbnx2x_set_rx_filter(params, 1);\r\nlfa_status = bnx2x_check_lfa(params);\r\nif (lfa_status == 0) {\r\nDP(NETIF_MSG_LINK, "Link Flap Avoidance in progress\n");\r\nreturn bnx2x_avoid_link_flap(params, vars);\r\n}\r\nDP(NETIF_MSG_LINK, "Cannot avoid link flap lfa_sta=0x%x\n",\r\nlfa_status);\r\nbnx2x_cannot_avoid_link_flap(params, vars, lfa_status);\r\nbnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 + params->port*4,\r\n(NIG_MASK_XGXS0_LINK_STATUS |\r\nNIG_MASK_XGXS0_LINK10G |\r\nNIG_MASK_SERDES0_LINK_STATUS |\r\nNIG_MASK_MI_INT));\r\nbnx2x_emac_init(params, vars);\r\nif (params->feature_config_flags & FEATURE_CONFIG_PFC_ENABLED)\r\nvars->link_status |= LINK_STATUS_PFC_ENABLED;\r\nif (params->num_phys == 0) {\r\nDP(NETIF_MSG_LINK, "No phy found for initialization !!\n");\r\nreturn -EINVAL;\r\n}\r\nset_phy_vars(params, vars);\r\nDP(NETIF_MSG_LINK, "Num of phys on board: %d\n", params->num_phys);\r\nswitch (params->loopback_mode) {\r\ncase LOOPBACK_BMAC:\r\nbnx2x_init_bmac_loopback(params, vars);\r\nbreak;\r\ncase LOOPBACK_EMAC:\r\nbnx2x_init_emac_loopback(params, vars);\r\nbreak;\r\ncase LOOPBACK_XMAC:\r\nbnx2x_init_xmac_loopback(params, vars);\r\nbreak;\r\ncase LOOPBACK_UMAC:\r\nbnx2x_init_umac_loopback(params, vars);\r\nbreak;\r\ncase LOOPBACK_XGXS:\r\ncase LOOPBACK_EXT_PHY:\r\nbnx2x_init_xgxs_loopback(params, vars);\r\nbreak;\r\ndefault:\r\nif (!CHIP_IS_E3(bp)) {\r\nif (params->switch_cfg == SWITCH_CFG_10G)\r\nbnx2x_xgxs_deassert(params);\r\nelse\r\nbnx2x_serdes_deassert(bp, params->port);\r\n}\r\nbnx2x_link_initialize(params, vars);\r\nmsleep(30);\r\nbnx2x_link_int_enable(params);\r\nbreak;\r\n}\r\nbnx2x_update_mng(params, vars->link_status);\r\nbnx2x_update_mng_eee(params, vars->eee_status);\r\nreturn 0;\r\n}\r\nint bnx2x_link_reset(struct link_params *params, struct link_vars *vars,\r\nu8 reset_ext_phy)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 phy_index, port = params->port, clear_latch_ind = 0;\r\nDP(NETIF_MSG_LINK, "Resetting the link of port %d\n", port);\r\nvars->link_status = 0;\r\nbnx2x_update_mng(params, vars->link_status);\r\nvars->eee_status &= ~(SHMEM_EEE_LP_ADV_STATUS_MASK |\r\nSHMEM_EEE_ACTIVE_BIT);\r\nbnx2x_update_mng_eee(params, vars->eee_status);\r\nbnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4,\r\n(NIG_MASK_XGXS0_LINK_STATUS |\r\nNIG_MASK_XGXS0_LINK10G |\r\nNIG_MASK_SERDES0_LINK_STATUS |\r\nNIG_MASK_MI_INT));\r\nREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + port*4, 1);\r\nif (!CHIP_IS_E3(bp)) {\r\nREG_WR(bp, NIG_REG_BMAC0_OUT_EN + port*4, 0);\r\nREG_WR(bp, NIG_REG_EGRESS_EMAC0_OUT_EN + port*4, 0);\r\n}\r\nif (!CHIP_IS_E3(bp)) {\r\nbnx2x_set_bmac_rx(bp, params->chip_id, port, 0);\r\n} else {\r\nbnx2x_set_xmac_rxtx(params, 0);\r\nbnx2x_set_umac_rxtx(params, 0);\r\n}\r\nif (!CHIP_IS_E3(bp))\r\nREG_WR(bp, NIG_REG_NIG_EMAC0_EN + port*4, 0);\r\nusleep_range(10000, 20000);\r\nbnx2x_set_mdio_emac_per_phy(bp, params);\r\nbnx2x_set_led(params, vars, LED_MODE_OFF, 0);\r\nif (reset_ext_phy) {\r\nfor (phy_index = EXT_PHY1; phy_index < params->num_phys;\r\nphy_index++) {\r\nif (params->phy[phy_index].link_reset) {\r\nbnx2x_set_aer_mmd(params,\r\n&params->phy[phy_index]);\r\nparams->phy[phy_index].link_reset(\r\n&params->phy[phy_index],\r\nparams);\r\n}\r\nif (params->phy[phy_index].flags &\r\nFLAGS_REARM_LATCH_SIGNAL)\r\nclear_latch_ind = 1;\r\n}\r\n}\r\nif (clear_latch_ind) {\r\nbnx2x_rearm_latch_signal(bp, port, 0);\r\nbnx2x_bits_dis(bp, NIG_REG_LATCH_BC_0 + port*4,\r\n1 << NIG_LATCH_BC_ENABLE_MI_INT);\r\n}\r\nif (params->phy[INT_PHY].link_reset)\r\nparams->phy[INT_PHY].link_reset(\r\n&params->phy[INT_PHY], params);\r\nif (!CHIP_IS_E3(bp)) {\r\nREG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,\r\n(MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port));\r\nREG_WR(bp, NIG_REG_BMAC0_IN_EN + port*4, 0);\r\nREG_WR(bp, NIG_REG_EMAC0_IN_EN + port*4, 0);\r\n} else {\r\nu32 xmac_base = (params->port) ? GRCBASE_XMAC1 : GRCBASE_XMAC0;\r\nbnx2x_set_xumac_nig(params, 0, 0);\r\nif (REG_RD(bp, MISC_REG_RESET_REG_2) &\r\nMISC_REGISTERS_RESET_REG_2_XMAC)\r\nREG_WR(bp, xmac_base + XMAC_REG_CTRL,\r\nXMAC_CTRL_REG_SOFT_RESET);\r\n}\r\nvars->link_up = 0;\r\nvars->phy_flags = 0;\r\nreturn 0;\r\n}\r\nint bnx2x_lfa_reset(struct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nvars->link_up = 0;\r\nvars->phy_flags = 0;\r\nparams->link_flags &= ~PHY_INITIALIZED;\r\nif (!params->lfa_base)\r\nreturn bnx2x_link_reset(params, vars, 1);\r\nREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 1);\r\nif (!CHIP_IS_E3(bp))\r\nbnx2x_set_bmac_rx(bp, params->chip_id, params->port, 0);\r\nif (CHIP_IS_E3(bp)) {\r\nbnx2x_set_xmac_rxtx(params, 0);\r\nbnx2x_set_umac_rxtx(params, 0);\r\n}\r\nusleep_range(10000, 20000);\r\nbnx2x_set_rx_filter(params, 0);\r\nif (!CHIP_IS_E3(bp))\r\nbnx2x_set_bmac_rx(bp, params->chip_id, params->port, 1);\r\nif (CHIP_IS_E3(bp)) {\r\nbnx2x_set_xmac_rxtx(params, 1);\r\nbnx2x_set_umac_rxtx(params, 1);\r\n}\r\nREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_8073_common_init_phy(struct bnx2x *bp,\r\nu32 shmem_base_path[],\r\nu32 shmem2_base_path[], u8 phy_index,\r\nu32 chip_id)\r\n{\r\nstruct bnx2x_phy phy[PORT_MAX];\r\nstruct bnx2x_phy *phy_blk[PORT_MAX];\r\nu16 val;\r\ns8 port = 0;\r\ns8 port_of_path = 0;\r\nu32 swap_val, swap_override;\r\nswap_val = REG_RD(bp, NIG_REG_PORT_SWAP);\r\nswap_override = REG_RD(bp, NIG_REG_STRAP_OVERRIDE);\r\nport ^= (swap_val && swap_override);\r\nbnx2x_ext_phy_hw_reset(bp, port);\r\nfor (port = PORT_MAX - 1; port >= PORT_0; port--) {\r\nu32 shmem_base, shmem2_base;\r\nif (CHIP_IS_E1x(bp)) {\r\nshmem_base = shmem_base_path[0];\r\nshmem2_base = shmem2_base_path[0];\r\nport_of_path = port;\r\n} else {\r\nshmem_base = shmem_base_path[port];\r\nshmem2_base = shmem2_base_path[port];\r\nport_of_path = 0;\r\n}\r\nif (bnx2x_populate_phy(bp, phy_index, shmem_base, shmem2_base,\r\nport_of_path, &phy[port]) !=\r\n0) {\r\nDP(NETIF_MSG_LINK, "populate_phy failed\n");\r\nreturn -EINVAL;\r\n}\r\nbnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 +\r\nport_of_path*4,\r\n(NIG_MASK_XGXS0_LINK_STATUS |\r\nNIG_MASK_XGXS0_LINK10G |\r\nNIG_MASK_SERDES0_LINK_STATUS |\r\nNIG_MASK_MI_INT));\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\r\nMISC_REGISTERS_GPIO_OUTPUT_HIGH,\r\nport);\r\nbnx2x_cl45_write(bp, &phy[port],\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_CTRL,\r\n1<<15);\r\n}\r\nmsleep(150);\r\nif (phy[PORT_0].addr & 0x1) {\r\nphy_blk[PORT_0] = &(phy[PORT_1]);\r\nphy_blk[PORT_1] = &(phy[PORT_0]);\r\n} else {\r\nphy_blk[PORT_0] = &(phy[PORT_0]);\r\nphy_blk[PORT_1] = &(phy[PORT_1]);\r\n}\r\nfor (port = PORT_MAX - 1; port >= PORT_0; port--) {\r\nif (CHIP_IS_E1x(bp))\r\nport_of_path = port;\r\nelse\r\nport_of_path = 0;\r\nDP(NETIF_MSG_LINK, "Loading spirom for phy address 0x%x\n",\r\nphy_blk[port]->addr);\r\nif (bnx2x_8073_8727_external_rom_boot(bp, phy_blk[port],\r\nport_of_path))\r\nreturn -EINVAL;\r\nbnx2x_cl45_read(bp, phy_blk[port],\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_TX_POWER_DOWN, &val);\r\nbnx2x_cl45_write(bp, phy_blk[port],\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_TX_POWER_DOWN,\r\n(val | 1<<10));\r\n}\r\nmsleep(600);\r\nfor (port = PORT_MAX - 1; port >= PORT_0; port--) {\r\nbnx2x_cl45_read(bp, phy_blk[port],\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_TX_POWER_DOWN, &val);\r\nbnx2x_cl45_write(bp, phy_blk[port],\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_TX_POWER_DOWN, (val & (~(1<<10))));\r\nusleep_range(15000, 30000);\r\nbnx2x_cl45_read(bp, phy_blk[port],\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_EDC_FFE_MAIN, &val);\r\nbnx2x_cl45_write(bp, phy_blk[port],\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_EDC_FFE_MAIN, (val | (1<<12)));\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,\r\nMISC_REGISTERS_GPIO_OUTPUT_LOW, port);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_8726_common_init_phy(struct bnx2x *bp,\r\nu32 shmem_base_path[],\r\nu32 shmem2_base_path[], u8 phy_index,\r\nu32 chip_id)\r\n{\r\nu32 val;\r\ns8 port;\r\nstruct bnx2x_phy phy;\r\nval = REG_RD(bp, MISC_REG_GPIO_EVENT_EN);\r\nval |= ((1<<MISC_REGISTERS_GPIO_3)|\r\n(1<<(MISC_REGISTERS_GPIO_3 + MISC_REGISTERS_GPIO_PORT_SHIFT)));\r\nREG_WR(bp, MISC_REG_GPIO_EVENT_EN, val);\r\nbnx2x_ext_phy_hw_reset(bp, 0);\r\nusleep_range(5000, 10000);\r\nfor (port = 0; port < PORT_MAX; port++) {\r\nu32 shmem_base, shmem2_base;\r\nif (CHIP_IS_E1x(bp)) {\r\nshmem_base = shmem_base_path[0];\r\nshmem2_base = shmem2_base_path[0];\r\n} else {\r\nshmem_base = shmem_base_path[port];\r\nshmem2_base = shmem2_base_path[port];\r\n}\r\nif (bnx2x_populate_phy(bp, phy_index, shmem_base, shmem2_base,\r\nport, &phy) !=\r\n0) {\r\nDP(NETIF_MSG_LINK, "populate phy failed\n");\r\nreturn -EINVAL;\r\n}\r\nbnx2x_cl45_write(bp, &phy,\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_GEN_CTRL, 0x0001);\r\nbnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_0,\r\nMISC_REGISTERS_GPIO_HIGH,\r\nport);\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2x_get_ext_phy_reset_gpio(struct bnx2x *bp, u32 shmem_base,\r\nu8 *io_gpio, u8 *io_port)\r\n{\r\nu32 phy_gpio_reset = REG_RD(bp, shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[PORT_0].default_cfg));\r\nswitch (phy_gpio_reset) {\r\ncase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO0_P0:\r\n*io_gpio = 0;\r\n*io_port = 0;\r\nbreak;\r\ncase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO1_P0:\r\n*io_gpio = 1;\r\n*io_port = 0;\r\nbreak;\r\ncase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO2_P0:\r\n*io_gpio = 2;\r\n*io_port = 0;\r\nbreak;\r\ncase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO3_P0:\r\n*io_gpio = 3;\r\n*io_port = 0;\r\nbreak;\r\ncase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO0_P1:\r\n*io_gpio = 0;\r\n*io_port = 1;\r\nbreak;\r\ncase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO1_P1:\r\n*io_gpio = 1;\r\n*io_port = 1;\r\nbreak;\r\ncase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO2_P1:\r\n*io_gpio = 2;\r\n*io_port = 1;\r\nbreak;\r\ncase PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO3_P1:\r\n*io_gpio = 3;\r\n*io_port = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int bnx2x_8727_common_init_phy(struct bnx2x *bp,\r\nu32 shmem_base_path[],\r\nu32 shmem2_base_path[], u8 phy_index,\r\nu32 chip_id)\r\n{\r\ns8 port, reset_gpio;\r\nu32 swap_val, swap_override;\r\nstruct bnx2x_phy phy[PORT_MAX];\r\nstruct bnx2x_phy *phy_blk[PORT_MAX];\r\ns8 port_of_path;\r\nswap_val = REG_RD(bp, NIG_REG_PORT_SWAP);\r\nswap_override = REG_RD(bp, NIG_REG_STRAP_OVERRIDE);\r\nreset_gpio = MISC_REGISTERS_GPIO_1;\r\nport = 1;\r\nbnx2x_get_ext_phy_reset_gpio(bp, shmem_base_path[0],\r\n(u8 *)&reset_gpio, (u8 *)&port);\r\nport ^= (swap_val && swap_override);\r\nbnx2x_set_gpio(bp, reset_gpio, MISC_REGISTERS_GPIO_OUTPUT_LOW,\r\nport);\r\nusleep_range(1000, 2000);\r\nbnx2x_set_gpio(bp, reset_gpio, MISC_REGISTERS_GPIO_OUTPUT_HIGH,\r\nport);\r\nusleep_range(5000, 10000);\r\nfor (port = PORT_MAX - 1; port >= PORT_0; port--) {\r\nu32 shmem_base, shmem2_base;\r\nif (CHIP_IS_E1x(bp)) {\r\nshmem_base = shmem_base_path[0];\r\nshmem2_base = shmem2_base_path[0];\r\nport_of_path = port;\r\n} else {\r\nshmem_base = shmem_base_path[port];\r\nshmem2_base = shmem2_base_path[port];\r\nport_of_path = 0;\r\n}\r\nif (bnx2x_populate_phy(bp, phy_index, shmem_base, shmem2_base,\r\nport_of_path, &phy[port]) !=\r\n0) {\r\nDP(NETIF_MSG_LINK, "populate phy failed\n");\r\nreturn -EINVAL;\r\n}\r\nbnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 +\r\nport_of_path*4,\r\n(NIG_MASK_XGXS0_LINK_STATUS |\r\nNIG_MASK_XGXS0_LINK10G |\r\nNIG_MASK_SERDES0_LINK_STATUS |\r\nNIG_MASK_MI_INT));\r\nbnx2x_cl45_write(bp, &phy[port],\r\nMDIO_PMA_DEVAD, MDIO_PMA_REG_CTRL, 1<<15);\r\n}\r\nmsleep(150);\r\nif (phy[PORT_0].addr & 0x1) {\r\nphy_blk[PORT_0] = &(phy[PORT_1]);\r\nphy_blk[PORT_1] = &(phy[PORT_0]);\r\n} else {\r\nphy_blk[PORT_0] = &(phy[PORT_0]);\r\nphy_blk[PORT_1] = &(phy[PORT_1]);\r\n}\r\nfor (port = PORT_MAX - 1; port >= PORT_0; port--) {\r\nif (CHIP_IS_E1x(bp))\r\nport_of_path = port;\r\nelse\r\nport_of_path = 0;\r\nDP(NETIF_MSG_LINK, "Loading spirom for phy address 0x%x\n",\r\nphy_blk[port]->addr);\r\nif (bnx2x_8073_8727_external_rom_boot(bp, phy_blk[port],\r\nport_of_path))\r\nreturn -EINVAL;\r\nbnx2x_cl45_write(bp, phy_blk[port],\r\nMDIO_PMA_DEVAD,\r\nMDIO_PMA_REG_TX_DISABLE, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bnx2x_84833_common_init_phy(struct bnx2x *bp,\r\nu32 shmem_base_path[],\r\nu32 shmem2_base_path[],\r\nu8 phy_index,\r\nu32 chip_id)\r\n{\r\nu8 reset_gpios;\r\nreset_gpios = bnx2x_84833_get_reset_gpios(bp, shmem_base_path, chip_id);\r\nbnx2x_set_mult_gpio(bp, reset_gpios, MISC_REGISTERS_GPIO_OUTPUT_LOW);\r\nudelay(10);\r\nbnx2x_set_mult_gpio(bp, reset_gpios, MISC_REGISTERS_GPIO_OUTPUT_HIGH);\r\nDP(NETIF_MSG_LINK, "84833 reset pulse on pin values 0x%x\n",\r\nreset_gpios);\r\nreturn 0;\r\n}\r\nstatic int bnx2x_ext_phy_common_init(struct bnx2x *bp, u32 shmem_base_path[],\r\nu32 shmem2_base_path[], u8 phy_index,\r\nu32 ext_phy_type, u32 chip_id)\r\n{\r\nint rc = 0;\r\nswitch (ext_phy_type) {\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073:\r\nrc = bnx2x_8073_common_init_phy(bp, shmem_base_path,\r\nshmem2_base_path,\r\nphy_index, chip_id);\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722:\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727_NOC:\r\nrc = bnx2x_8727_common_init_phy(bp, shmem_base_path,\r\nshmem2_base_path,\r\nphy_index, chip_id);\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:\r\nrc = bnx2x_8726_common_init_phy(bp, shmem_base_path,\r\nshmem2_base_path,\r\nphy_index, chip_id);\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833:\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834:\r\nrc = bnx2x_84833_common_init_phy(bp, shmem_base_path,\r\nshmem2_base_path,\r\nphy_index, chip_id);\r\nbreak;\r\ncase PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE:\r\nrc = -EINVAL;\r\nbreak;\r\ndefault:\r\nDP(NETIF_MSG_LINK,\r\n"ext_phy 0x%x common init not required\n",\r\next_phy_type);\r\nbreak;\r\n}\r\nif (rc)\r\nnetdev_err(bp->dev, "Warning: PHY was not initialized,"\r\n" Port %d\n",\r\n0);\r\nreturn rc;\r\n}\r\nint bnx2x_common_init_phy(struct bnx2x *bp, u32 shmem_base_path[],\r\nu32 shmem2_base_path[], u32 chip_id)\r\n{\r\nint rc = 0;\r\nu32 phy_ver, val;\r\nu8 phy_index = 0;\r\nu32 ext_phy_type, ext_phy_config;\r\nbnx2x_set_mdio_clk(bp, chip_id, GRCBASE_EMAC0);\r\nbnx2x_set_mdio_clk(bp, chip_id, GRCBASE_EMAC1);\r\nDP(NETIF_MSG_LINK, "Begin common phy init\n");\r\nif (CHIP_IS_E3(bp)) {\r\nval = REG_RD(bp, MISC_REG_GEN_PURP_HWG);\r\nREG_WR(bp, MISC_REG_GEN_PURP_HWG, val | 1);\r\n}\r\nphy_ver = REG_RD(bp, shmem_base_path[0] +\r\noffsetof(struct shmem_region,\r\nport_mb[PORT_0].ext_phy_fw_version));\r\nif (phy_ver) {\r\nDP(NETIF_MSG_LINK, "Not doing common init; phy ver is 0x%x\n",\r\nphy_ver);\r\nreturn 0;\r\n}\r\nfor (phy_index = EXT_PHY1; phy_index < MAX_PHYS;\r\nphy_index++) {\r\next_phy_config = bnx2x_get_ext_phy_config(bp,\r\nshmem_base_path[0],\r\nphy_index, 0);\r\next_phy_type = XGXS_EXT_PHY_TYPE(ext_phy_config);\r\nrc |= bnx2x_ext_phy_common_init(bp, shmem_base_path,\r\nshmem2_base_path,\r\nphy_index, ext_phy_type,\r\nchip_id);\r\n}\r\nreturn rc;\r\n}\r\nstatic void bnx2x_check_over_curr(struct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu32 cfg_pin;\r\nu8 port = params->port;\r\nu32 pin_val;\r\ncfg_pin = (REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[port].e3_cmn_pin_cfg1)) &\r\nPORT_HW_CFG_E3_OVER_CURRENT_MASK) >>\r\nPORT_HW_CFG_E3_OVER_CURRENT_SHIFT;\r\nif (bnx2x_get_cfg_pin(bp, cfg_pin, &pin_val) != 0)\r\nreturn;\r\nif (!pin_val) {\r\nif ((vars->phy_flags & PHY_OVER_CURRENT_FLAG) == 0) {\r\nnetdev_err(bp->dev, "Error: Power fault on Port %d has"\r\n" been detected and the power to "\r\n"that SFP+ module has been removed"\r\n" to prevent failure of the card."\r\n" Please remove the SFP+ module and"\r\n" restart the system to clear this"\r\n" error.\n",\r\nparams->port);\r\nvars->phy_flags |= PHY_OVER_CURRENT_FLAG;\r\nbnx2x_warpcore_power_module(params, 0);\r\n}\r\n} else\r\nvars->phy_flags &= ~PHY_OVER_CURRENT_FLAG;\r\n}\r\nstatic u8 bnx2x_analyze_link_error(struct link_params *params,\r\nstruct link_vars *vars, u32 status,\r\nu32 phy_flag, u32 link_flag, u8 notify)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu8 led_mode;\r\nu32 old_status = (vars->phy_flags & phy_flag) ? 1 : 0;\r\nif ((status ^ old_status) == 0)\r\nreturn 0;\r\nswitch (phy_flag) {\r\ncase PHY_HALF_OPEN_CONN_FLAG:\r\nDP(NETIF_MSG_LINK, "Analyze Remote Fault\n");\r\nbreak;\r\ncase PHY_SFP_TX_FAULT_FLAG:\r\nDP(NETIF_MSG_LINK, "Analyze TX Fault\n");\r\nbreak;\r\ndefault:\r\nDP(NETIF_MSG_LINK, "Analyze UNKNOWN\n");\r\n}\r\nDP(NETIF_MSG_LINK, "Link changed:[%x %x]->%x\n", vars->link_up,\r\nold_status, status);\r\nif ((vars->phy_flags & PHY_PHYSICAL_LINK_FLAG) == 0)\r\nreturn 1;\r\nif (status) {\r\nvars->link_status &= ~LINK_STATUS_LINK_UP;\r\nvars->link_status |= link_flag;\r\nvars->link_up = 0;\r\nvars->phy_flags |= phy_flag;\r\nREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 1);\r\nled_mode = LED_MODE_OFF;\r\n} else {\r\nvars->link_status |= LINK_STATUS_LINK_UP;\r\nvars->link_status &= ~link_flag;\r\nvars->link_up = 1;\r\nvars->phy_flags &= ~phy_flag;\r\nled_mode = LED_MODE_OPER;\r\nREG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);\r\n}\r\nbnx2x_sync_link(params, vars);\r\nbnx2x_set_led(params, vars, led_mode, SPEED_10000);\r\nbnx2x_update_mng(params, vars->link_status);\r\nvars->periodic_flags |= PERIODIC_FLAGS_LINK_EVENT;\r\nif (notify)\r\nbnx2x_notify_link_changed(bp);\r\nreturn 1;\r\n}\r\nstatic int bnx2x_check_half_open_conn(struct link_params *params,\r\nstruct link_vars *vars,\r\nu8 notify)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu32 lss_status = 0;\r\nu32 mac_base;\r\nif (((vars->phy_flags & PHY_PHYSICAL_LINK_FLAG) == 0) ||\r\n(REG_RD(bp, NIG_REG_EGRESS_EMAC0_PORT + params->port*4)))\r\nreturn 0;\r\nif (CHIP_IS_E3(bp) &&\r\n(REG_RD(bp, MISC_REG_RESET_REG_2) &\r\n(MISC_REGISTERS_RESET_REG_2_XMAC))) {\r\nmac_base = (params->port) ? GRCBASE_XMAC1 : GRCBASE_XMAC0;\r\nREG_WR(bp, mac_base + XMAC_REG_CLEAR_RX_LSS_STATUS, 0);\r\nREG_WR(bp, mac_base + XMAC_REG_CLEAR_RX_LSS_STATUS,\r\nXMAC_CLEAR_RX_LSS_STATUS_REG_CLEAR_LOCAL_FAULT_STATUS |\r\nXMAC_CLEAR_RX_LSS_STATUS_REG_CLEAR_REMOTE_FAULT_STATUS);\r\nif (REG_RD(bp, mac_base + XMAC_REG_RX_LSS_STATUS))\r\nlss_status = 1;\r\nbnx2x_analyze_link_error(params, vars, lss_status,\r\nPHY_HALF_OPEN_CONN_FLAG,\r\nLINK_STATUS_NONE, notify);\r\n} else if (REG_RD(bp, MISC_REG_RESET_REG_2) &\r\n(MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << params->port)) {\r\nu32 lss_status_reg;\r\nu32 wb_data[2];\r\nmac_base = params->port ? NIG_REG_INGRESS_BMAC1_MEM :\r\nNIG_REG_INGRESS_BMAC0_MEM;\r\nif (CHIP_IS_E2(bp))\r\nlss_status_reg = BIGMAC2_REGISTER_RX_LSS_STAT;\r\nelse\r\nlss_status_reg = BIGMAC_REGISTER_RX_LSS_STATUS;\r\nREG_RD_DMAE(bp, mac_base + lss_status_reg, wb_data, 2);\r\nlss_status = (wb_data[0] > 0);\r\nbnx2x_analyze_link_error(params, vars, lss_status,\r\nPHY_HALF_OPEN_CONN_FLAG,\r\nLINK_STATUS_NONE, notify);\r\n}\r\nreturn 0;\r\n}\r\nstatic void bnx2x_sfp_tx_fault_detection(struct bnx2x_phy *phy,\r\nstruct link_params *params,\r\nstruct link_vars *vars)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu32 cfg_pin, value = 0;\r\nu8 led_change, port = params->port;\r\ncfg_pin = (REG_RD(bp, params->shmem_base + offsetof(struct shmem_region,\r\ndev_info.port_hw_config[port].e3_cmn_pin_cfg)) &\r\nPORT_HW_CFG_E3_TX_FAULT_MASK) >>\r\nPORT_HW_CFG_E3_TX_FAULT_SHIFT;\r\nif (bnx2x_get_cfg_pin(bp, cfg_pin, &value)) {\r\nDP(NETIF_MSG_LINK, "Failed to read pin 0x%02x\n", cfg_pin);\r\nreturn;\r\n}\r\nled_change = bnx2x_analyze_link_error(params, vars, value,\r\nPHY_SFP_TX_FAULT_FLAG,\r\nLINK_STATUS_SFP_TX_FAULT, 1);\r\nif (led_change) {\r\nu8 led_mode;\r\nif (vars->phy_flags & PHY_SFP_TX_FAULT_FLAG) {\r\nled_mode = MISC_REGISTERS_GPIO_HIGH;\r\nvars->link_status |= LINK_STATUS_SFP_TX_FAULT;\r\n} else {\r\nled_mode = MISC_REGISTERS_GPIO_LOW;\r\nvars->link_status &= ~LINK_STATUS_SFP_TX_FAULT;\r\n}\r\nif (!(phy->flags & FLAGS_SFP_NOT_APPROVED)) {\r\nDP(NETIF_MSG_LINK, "Change TX_Fault LED: ->%x\n",\r\nled_mode);\r\nbnx2x_set_e3_module_fault_led(params, led_mode);\r\n}\r\n}\r\n}\r\nstatic void bnx2x_kr2_recovery(struct link_params *params,\r\nstruct link_vars *vars,\r\nstruct bnx2x_phy *phy)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nDP(NETIF_MSG_LINK, "KR2 recovery\n");\r\nbnx2x_warpcore_enable_AN_KR2(phy, params, vars);\r\nbnx2x_warpcore_restart_AN_KR(phy, params);\r\n}\r\nstatic void bnx2x_check_kr2_wa(struct link_params *params,\r\nstruct link_vars *vars,\r\nstruct bnx2x_phy *phy)\r\n{\r\nstruct bnx2x *bp = params->bp;\r\nu16 base_page, next_page, not_kr2_device, lane;\r\nint sigdet;\r\nif (vars->check_kr2_recovery_cnt > 0) {\r\nvars->check_kr2_recovery_cnt--;\r\nreturn;\r\n}\r\nsigdet = bnx2x_warpcore_get_sigdet(phy, params);\r\nif (!sigdet) {\r\nif (!(params->link_attr_sync & LINK_ATTR_SYNC_KR2_ENABLE)) {\r\nbnx2x_kr2_recovery(params, vars, phy);\r\nDP(NETIF_MSG_LINK, "No sigdet\n");\r\n}\r\nreturn;\r\n}\r\nlane = bnx2x_get_warpcore_lane(phy, params);\r\nCL22_WR_OVER_CL45(bp, phy, MDIO_REG_BANK_AER_BLOCK,\r\nMDIO_AER_BLOCK_AER_REG, lane);\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_AN_REG_LP_AUTO_NEG, &base_page);\r\nbnx2x_cl45_read(bp, phy, MDIO_AN_DEVAD,\r\nMDIO_AN_REG_LP_AUTO_NEG2, &next_page);\r\nbnx2x_set_aer_mmd(params, phy);\r\nif (base_page == 0) {\r\nif (!(params->link_attr_sync & LINK_ATTR_SYNC_KR2_ENABLE)) {\r\nbnx2x_kr2_recovery(params, vars, phy);\r\nDP(NETIF_MSG_LINK, "No BP\n");\r\n}\r\nreturn;\r\n}\r\nnot_kr2_device = (((base_page & 0x8000) == 0) ||\r\n(((base_page & 0x8000) &&\r\n((next_page & 0xe0) == 0x20))));\r\nif (!(params->link_attr_sync & LINK_ATTR_SYNC_KR2_ENABLE)) {\r\nif (!not_kr2_device) {\r\nDP(NETIF_MSG_LINK, "BP=0x%x, NP=0x%x\n", base_page,\r\nnext_page);\r\nbnx2x_kr2_recovery(params, vars, phy);\r\n}\r\nreturn;\r\n}\r\nif (not_kr2_device) {\r\nDP(NETIF_MSG_LINK, "BP=0x%x, NP=0x%x\n", base_page, next_page);\r\nbnx2x_disable_kr2(params, vars, phy);\r\nbnx2x_warpcore_restart_AN_KR(phy, params);\r\nreturn;\r\n}\r\n}\r\nvoid bnx2x_period_func(struct link_params *params, struct link_vars *vars)\r\n{\r\nu16 phy_idx;\r\nstruct bnx2x *bp = params->bp;\r\nfor (phy_idx = INT_PHY; phy_idx < MAX_PHYS; phy_idx++) {\r\nif (params->phy[phy_idx].flags & FLAGS_TX_ERROR_CHECK) {\r\nbnx2x_set_aer_mmd(params, &params->phy[phy_idx]);\r\nif (bnx2x_check_half_open_conn(params, vars, 1) !=\r\n0)\r\nDP(NETIF_MSG_LINK, "Fault detection failed\n");\r\nbreak;\r\n}\r\n}\r\nif (CHIP_IS_E3(bp)) {\r\nstruct bnx2x_phy *phy = &params->phy[INT_PHY];\r\nbnx2x_set_aer_mmd(params, phy);\r\nif ((phy->supported & SUPPORTED_20000baseKR2_Full) &&\r\n(phy->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_20G))\r\nbnx2x_check_kr2_wa(params, vars, phy);\r\nbnx2x_check_over_curr(params, vars);\r\nif (vars->rx_tx_asic_rst)\r\nbnx2x_warpcore_config_runtime(phy, params, vars);\r\nif ((REG_RD(bp, params->shmem_base +\r\noffsetof(struct shmem_region, dev_info.\r\nport_hw_config[params->port].default_cfg))\r\n& PORT_HW_CFG_NET_SERDES_IF_MASK) ==\r\nPORT_HW_CFG_NET_SERDES_IF_SFI) {\r\nif (bnx2x_is_sfp_module_plugged(phy, params)) {\r\nbnx2x_sfp_tx_fault_detection(phy, params, vars);\r\n} else if (vars->link_status &\r\nLINK_STATUS_SFP_TX_FAULT) {\r\nvars->link_status &= ~LINK_STATUS_SFP_TX_FAULT;\r\nvars->phy_flags &= ~PHY_SFP_TX_FAULT_FLAG;\r\nbnx2x_update_mng(params, vars->link_status);\r\n}\r\n}\r\n}\r\n}\r\nu8 bnx2x_fan_failure_det_req(struct bnx2x *bp,\r\nu32 shmem_base,\r\nu32 shmem2_base,\r\nu8 port)\r\n{\r\nu8 phy_index, fan_failure_det_req = 0;\r\nstruct bnx2x_phy phy;\r\nfor (phy_index = EXT_PHY1; phy_index < MAX_PHYS;\r\nphy_index++) {\r\nif (bnx2x_populate_phy(bp, phy_index, shmem_base, shmem2_base,\r\nport, &phy)\r\n!= 0) {\r\nDP(NETIF_MSG_LINK, "populate phy failed\n");\r\nreturn 0;\r\n}\r\nfan_failure_det_req |= (phy.flags &\r\nFLAGS_FAN_FAILURE_DET_REQ);\r\n}\r\nreturn fan_failure_det_req;\r\n}\r\nvoid bnx2x_hw_reset_phy(struct link_params *params)\r\n{\r\nu8 phy_index;\r\nstruct bnx2x *bp = params->bp;\r\nbnx2x_update_mng(params, 0);\r\nbnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 + params->port*4,\r\n(NIG_MASK_XGXS0_LINK_STATUS |\r\nNIG_MASK_XGXS0_LINK10G |\r\nNIG_MASK_SERDES0_LINK_STATUS |\r\nNIG_MASK_MI_INT));\r\nfor (phy_index = INT_PHY; phy_index < MAX_PHYS;\r\nphy_index++) {\r\nif (params->phy[phy_index].hw_reset) {\r\nparams->phy[phy_index].hw_reset(\r\n&params->phy[phy_index],\r\nparams);\r\nparams->phy[phy_index] = phy_null;\r\n}\r\n}\r\n}\r\nvoid bnx2x_init_mod_abs_int(struct bnx2x *bp, struct link_vars *vars,\r\nu32 chip_id, u32 shmem_base, u32 shmem2_base,\r\nu8 port)\r\n{\r\nu8 gpio_num = 0xff, gpio_port = 0xff, phy_index;\r\nu32 val;\r\nu32 offset, aeu_mask, swap_val, swap_override, sync_offset;\r\nif (CHIP_IS_E3(bp)) {\r\nif (bnx2x_get_mod_abs_int_cfg(bp, chip_id,\r\nshmem_base,\r\nport,\r\n&gpio_num,\r\n&gpio_port) != 0)\r\nreturn;\r\n} else {\r\nstruct bnx2x_phy phy;\r\nfor (phy_index = EXT_PHY1; phy_index < MAX_PHYS;\r\nphy_index++) {\r\nif (bnx2x_populate_phy(bp, phy_index, shmem_base,\r\nshmem2_base, port, &phy)\r\n!= 0) {\r\nDP(NETIF_MSG_LINK, "populate phy failed\n");\r\nreturn;\r\n}\r\nif (phy.type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726) {\r\ngpio_num = MISC_REGISTERS_GPIO_3;\r\ngpio_port = port;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (gpio_num == 0xff)\r\nreturn;\r\nbnx2x_set_gpio(bp, gpio_num, MISC_REGISTERS_GPIO_INPUT_HI_Z, gpio_port);\r\nswap_val = REG_RD(bp, NIG_REG_PORT_SWAP);\r\nswap_override = REG_RD(bp, NIG_REG_STRAP_OVERRIDE);\r\ngpio_port ^= (swap_val && swap_override);\r\nvars->aeu_int_mask = AEU_INPUTS_ATTN_BITS_GPIO0_FUNCTION_0 <<\r\n(gpio_num + (gpio_port << 2));\r\nsync_offset = shmem_base +\r\noffsetof(struct shmem_region,\r\ndev_info.port_hw_config[port].aeu_int_mask);\r\nREG_WR(bp, sync_offset, vars->aeu_int_mask);\r\nDP(NETIF_MSG_LINK, "Setting MOD_ABS (GPIO%d_P%d) AEU to 0x%x\n",\r\ngpio_num, gpio_port, vars->aeu_int_mask);\r\nif (port == 0)\r\noffset = MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0;\r\nelse\r\noffset = MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0;\r\naeu_mask = REG_RD(bp, offset);\r\naeu_mask |= vars->aeu_int_mask;\r\nREG_WR(bp, offset, aeu_mask);\r\nval = REG_RD(bp, MISC_REG_GPIO_EVENT_EN);\r\nval |= 1 << (gpio_num + (gpio_port << 2));\r\nREG_WR(bp, MISC_REG_GPIO_EVENT_EN, val);\r\n}
