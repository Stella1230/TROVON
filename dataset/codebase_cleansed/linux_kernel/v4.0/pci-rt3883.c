static inline struct rt3883_pci_controller *\r\npci_bus_to_rt3883_controller(struct pci_bus *bus)\r\n{\r\nstruct pci_controller *hose;\r\nhose = (struct pci_controller *) bus->sysdata;\r\nreturn container_of(hose, struct rt3883_pci_controller, pci_controller);\r\n}\r\nstatic inline u32 rt3883_pci_r32(struct rt3883_pci_controller *rpc,\r\nunsigned reg)\r\n{\r\nreturn ioread32(rpc->base + reg);\r\n}\r\nstatic inline void rt3883_pci_w32(struct rt3883_pci_controller *rpc,\r\nu32 val, unsigned reg)\r\n{\r\niowrite32(val, rpc->base + reg);\r\n}\r\nstatic inline u32 rt3883_pci_get_cfgaddr(unsigned int bus, unsigned int slot,\r\nunsigned int func, unsigned int where)\r\n{\r\nreturn (bus << 16) | (slot << 11) | (func << 8) | (where & 0xfc) |\r\n0x80000000;\r\n}\r\nstatic u32 rt3883_pci_read_cfg32(struct rt3883_pci_controller *rpc,\r\nunsigned bus, unsigned slot,\r\nunsigned func, unsigned reg)\r\n{\r\nunsigned long flags;\r\nu32 address;\r\nu32 ret;\r\naddress = rt3883_pci_get_cfgaddr(bus, slot, func, reg);\r\nrt3883_pci_w32(rpc, address, RT3883_PCI_REG_CFGADDR);\r\nret = rt3883_pci_r32(rpc, RT3883_PCI_REG_CFGDATA);\r\nreturn ret;\r\n}\r\nstatic void rt3883_pci_write_cfg32(struct rt3883_pci_controller *rpc,\r\nunsigned bus, unsigned slot,\r\nunsigned func, unsigned reg, u32 val)\r\n{\r\nunsigned long flags;\r\nu32 address;\r\naddress = rt3883_pci_get_cfgaddr(bus, slot, func, reg);\r\nrt3883_pci_w32(rpc, address, RT3883_PCI_REG_CFGADDR);\r\nrt3883_pci_w32(rpc, val, RT3883_PCI_REG_CFGDATA);\r\n}\r\nstatic void rt3883_pci_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct rt3883_pci_controller *rpc;\r\nu32 pending;\r\nrpc = irq_get_handler_data(irq);\r\npending = rt3883_pci_r32(rpc, RT3883_PCI_REG_PCIINT) &\r\nrt3883_pci_r32(rpc, RT3883_PCI_REG_PCIENA);\r\nif (!pending) {\r\nspurious_interrupt();\r\nreturn;\r\n}\r\nwhile (pending) {\r\nunsigned bit = __ffs(pending);\r\nirq = irq_find_mapping(rpc->irq_domain, bit);\r\ngeneric_handle_irq(irq);\r\npending &= ~BIT(bit);\r\n}\r\n}\r\nstatic void rt3883_pci_irq_unmask(struct irq_data *d)\r\n{\r\nstruct rt3883_pci_controller *rpc;\r\nu32 t;\r\nrpc = irq_data_get_irq_chip_data(d);\r\nt = rt3883_pci_r32(rpc, RT3883_PCI_REG_PCIENA);\r\nrt3883_pci_w32(rpc, t | BIT(d->hwirq), RT3883_PCI_REG_PCIENA);\r\nrt3883_pci_r32(rpc, RT3883_PCI_REG_PCIENA);\r\n}\r\nstatic void rt3883_pci_irq_mask(struct irq_data *d)\r\n{\r\nstruct rt3883_pci_controller *rpc;\r\nu32 t;\r\nrpc = irq_data_get_irq_chip_data(d);\r\nt = rt3883_pci_r32(rpc, RT3883_PCI_REG_PCIENA);\r\nrt3883_pci_w32(rpc, t & ~BIT(d->hwirq), RT3883_PCI_REG_PCIENA);\r\nrt3883_pci_r32(rpc, RT3883_PCI_REG_PCIENA);\r\n}\r\nstatic int rt3883_pci_irq_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hw)\r\n{\r\nirq_set_chip_and_handler(irq, &rt3883_pci_irq_chip, handle_level_irq);\r\nirq_set_chip_data(irq, d->host_data);\r\nreturn 0;\r\n}\r\nstatic int rt3883_pci_irq_init(struct device *dev,\r\nstruct rt3883_pci_controller *rpc)\r\n{\r\nint irq;\r\nirq = irq_of_parse_and_map(rpc->intc_of_node, 0);\r\nif (irq == 0) {\r\ndev_err(dev, "%s has no IRQ",\r\nof_node_full_name(rpc->intc_of_node));\r\nreturn -EINVAL;\r\n}\r\nrt3883_pci_w32(rpc, 0, RT3883_PCI_REG_PCIENA);\r\nrpc->irq_domain =\r\nirq_domain_add_linear(rpc->intc_of_node, RT3883_PCI_IRQ_COUNT,\r\n&rt3883_pci_irq_domain_ops,\r\nrpc);\r\nif (!rpc->irq_domain) {\r\ndev_err(dev, "unable to add IRQ domain\n");\r\nreturn -ENODEV;\r\n}\r\nirq_set_handler_data(irq, rpc);\r\nirq_set_chained_handler(irq, rt3883_pci_irq_handler);\r\nreturn 0;\r\n}\r\nstatic int rt3883_pci_config_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nstruct rt3883_pci_controller *rpc;\r\nunsigned long flags;\r\nu32 address;\r\nu32 data;\r\nrpc = pci_bus_to_rt3883_controller(bus);\r\nif (!rpc->pcie_ready && bus->number == 1)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\naddress = rt3883_pci_get_cfgaddr(bus->number, PCI_SLOT(devfn),\r\nPCI_FUNC(devfn), where);\r\nrt3883_pci_w32(rpc, address, RT3883_PCI_REG_CFGADDR);\r\ndata = rt3883_pci_r32(rpc, RT3883_PCI_REG_CFGDATA);\r\nswitch (size) {\r\ncase 1:\r\n*val = (data >> ((where & 3) << 3)) & 0xff;\r\nbreak;\r\ncase 2:\r\n*val = (data >> ((where & 3) << 3)) & 0xffff;\r\nbreak;\r\ncase 4:\r\n*val = data;\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int rt3883_pci_config_write(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nstruct rt3883_pci_controller *rpc;\r\nunsigned long flags;\r\nu32 address;\r\nu32 data;\r\nrpc = pci_bus_to_rt3883_controller(bus);\r\nif (!rpc->pcie_ready && bus->number == 1)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\naddress = rt3883_pci_get_cfgaddr(bus->number, PCI_SLOT(devfn),\r\nPCI_FUNC(devfn), where);\r\nrt3883_pci_w32(rpc, address, RT3883_PCI_REG_CFGADDR);\r\ndata = rt3883_pci_r32(rpc, RT3883_PCI_REG_CFGDATA);\r\nswitch (size) {\r\ncase 1:\r\ndata = (data & ~(0xff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nbreak;\r\ncase 2:\r\ndata = (data & ~(0xffff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nbreak;\r\ncase 4:\r\ndata = val;\r\nbreak;\r\n}\r\nrt3883_pci_w32(rpc, data, RT3883_PCI_REG_CFGDATA);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic void rt3883_pci_preinit(struct rt3883_pci_controller *rpc, unsigned mode)\r\n{\r\nu32 syscfg1;\r\nu32 rstctrl;\r\nu32 clkcfg1;\r\nu32 t;\r\nrstctrl = rt_sysc_r32(RT3883_SYSC_REG_RSTCTRL);\r\nsyscfg1 = rt_sysc_r32(RT3883_SYSC_REG_SYSCFG1);\r\nclkcfg1 = rt_sysc_r32(RT3883_SYSC_REG_CLKCFG1);\r\nif (mode & RT3883_PCI_MODE_PCIE) {\r\nrstctrl |= RT3883_RSTCTRL_PCIE;\r\nrt_sysc_w32(rstctrl, RT3883_SYSC_REG_RSTCTRL);\r\nsyscfg1 &= ~(0x30);\r\nsyscfg1 |= (2 << 4);\r\nrt_sysc_w32(syscfg1, RT3883_SYSC_REG_SYSCFG1);\r\nt = rt_sysc_r32(RT3883_SYSC_REG_PCIE_CLK_GEN0);\r\nt &= ~BIT(31);\r\nrt_sysc_w32(t, RT3883_SYSC_REG_PCIE_CLK_GEN0);\r\nt = rt_sysc_r32(RT3883_SYSC_REG_PCIE_CLK_GEN1);\r\nt &= 0x80ffffff;\r\nrt_sysc_w32(t, RT3883_SYSC_REG_PCIE_CLK_GEN1);\r\nt = rt_sysc_r32(RT3883_SYSC_REG_PCIE_CLK_GEN1);\r\nt |= 0xa << 24;\r\nrt_sysc_w32(t, RT3883_SYSC_REG_PCIE_CLK_GEN1);\r\nt = rt_sysc_r32(RT3883_SYSC_REG_PCIE_CLK_GEN0);\r\nt |= BIT(31);\r\nrt_sysc_w32(t, RT3883_SYSC_REG_PCIE_CLK_GEN0);\r\nmsleep(50);\r\nrstctrl &= ~RT3883_RSTCTRL_PCIE;\r\nrt_sysc_w32(rstctrl, RT3883_SYSC_REG_RSTCTRL);\r\n}\r\nsyscfg1 |= (RT3883_SYSCFG1_PCIE_RC_MODE | RT3883_SYSCFG1_PCI_HOST_MODE);\r\nclkcfg1 &= ~(RT3883_CLKCFG1_PCI_CLK_EN | RT3883_CLKCFG1_PCIE_CLK_EN);\r\nif (mode & RT3883_PCI_MODE_PCI) {\r\nclkcfg1 |= RT3883_CLKCFG1_PCI_CLK_EN;\r\nrstctrl &= ~RT3883_RSTCTRL_PCI;\r\n}\r\nif (mode & RT3883_PCI_MODE_PCIE) {\r\nclkcfg1 |= RT3883_CLKCFG1_PCIE_CLK_EN;\r\nrstctrl &= ~RT3883_RSTCTRL_PCIE;\r\n}\r\nrt_sysc_w32(syscfg1, RT3883_SYSC_REG_SYSCFG1);\r\nrt_sysc_w32(rstctrl, RT3883_SYSC_REG_RSTCTRL);\r\nrt_sysc_w32(clkcfg1, RT3883_SYSC_REG_CLKCFG1);\r\nmsleep(500);\r\nt = (RT3883_P2P_BR_DEVNUM << RT3883_PCICFG_P2P_BR_DEVNUM_S);\r\nrt3883_pci_w32(rpc, t, RT3883_PCI_REG_PCICFG);\r\nrt3883_pci_r32(rpc, RT3883_PCI_REG_PCICFG);\r\nmsleep(500);\r\nif (mode & RT3883_PCI_MODE_PCIE) {\r\nmsleep(500);\r\nt = rt3883_pci_r32(rpc, RT3883_PCI_REG_STATUS(1));\r\nrpc->pcie_ready = t & BIT(0);\r\nif (!rpc->pcie_ready) {\r\nt = rt_sysc_r32(RT3883_SYSC_REG_RSTCTRL);\r\nt |= RT3883_RSTCTRL_PCIE;\r\nrt_sysc_w32(t, RT3883_SYSC_REG_RSTCTRL);\r\nt &= ~RT3883_RSTCTRL_PCIE;\r\nrt_sysc_w32(t, RT3883_SYSC_REG_RSTCTRL);\r\nt = rt_sysc_r32(RT3883_SYSC_REG_CLKCFG1);\r\nt &= ~RT3883_CLKCFG1_PCIE_CLK_EN;\r\nrt_sysc_w32(t, RT3883_SYSC_REG_CLKCFG1);\r\nt = rt_sysc_r32(RT3883_SYSC_REG_PCIE_CLK_GEN0);\r\nt &= ~0xf000c080;\r\nrt_sysc_w32(t, RT3883_SYSC_REG_PCIE_CLK_GEN0);\r\n}\r\n}\r\nrt3883_pci_w32(rpc, 0x79, RT3883_PCI_REG_ARBCTL);\r\n}\r\nstatic int rt3883_pci_probe(struct platform_device *pdev)\r\n{\r\nstruct rt3883_pci_controller *rpc;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct resource *res;\r\nstruct device_node *child;\r\nu32 val;\r\nint err;\r\nint mode;\r\nrpc = devm_kzalloc(dev, sizeof(*rpc), GFP_KERNEL);\r\nif (!rpc)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrpc->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(rpc->base))\r\nreturn PTR_ERR(rpc->base);\r\nfor_each_child_of_node(np, child) {\r\nif (of_get_property(child, "interrupt-controller", NULL) &&\r\nof_node_get(child)) {\r\nrpc->intc_of_node = child;\r\nbreak;\r\n}\r\n}\r\nif (!rpc->intc_of_node) {\r\ndev_err(dev, "%s has no %s child node",\r\nof_node_full_name(rpc->intc_of_node),\r\n"interrupt controller");\r\nreturn -EINVAL;\r\n}\r\nfor_each_child_of_node(np, child) {\r\nif (child->type &&\r\nof_node_cmp(child->type, "pci") == 0 &&\r\nof_node_get(child)) {\r\nrpc->pci_controller.of_node = child;\r\nbreak;\r\n}\r\n}\r\nif (!rpc->pci_controller.of_node) {\r\ndev_err(dev, "%s has no %s child node",\r\nof_node_full_name(rpc->intc_of_node),\r\n"PCI host bridge");\r\nerr = -EINVAL;\r\ngoto err_put_intc_node;\r\n}\r\nmode = RT3883_PCI_MODE_NONE;\r\nfor_each_available_child_of_node(rpc->pci_controller.of_node, child) {\r\nint devfn;\r\nif (!child->type ||\r\nof_node_cmp(child->type, "pci") != 0)\r\ncontinue;\r\ndevfn = of_pci_get_devfn(child);\r\nif (devfn < 0)\r\ncontinue;\r\nswitch (PCI_SLOT(devfn)) {\r\ncase 1:\r\nmode |= RT3883_PCI_MODE_PCIE;\r\nbreak;\r\ncase 17:\r\ncase 18:\r\nmode |= RT3883_PCI_MODE_PCI;\r\nbreak;\r\n}\r\n}\r\nif (mode == RT3883_PCI_MODE_NONE) {\r\ndev_err(dev, "unable to determine PCI mode\n");\r\nerr = -EINVAL;\r\ngoto err_put_hb_node;\r\n}\r\ndev_info(dev, "mode:%s%s\n",\r\n(mode & RT3883_PCI_MODE_PCI) ? " PCI" : "",\r\n(mode & RT3883_PCI_MODE_PCIE) ? " PCIe" : "");\r\nrt3883_pci_preinit(rpc, mode);\r\nrpc->pci_controller.pci_ops = &rt3883_pci_ops;\r\nrpc->pci_controller.io_resource = &rpc->io_res;\r\nrpc->pci_controller.mem_resource = &rpc->mem_res;\r\npci_load_of_ranges(&rpc->pci_controller,\r\nrpc->pci_controller.of_node);\r\nrt3883_pci_w32(rpc, rpc->mem_res.start, RT3883_PCI_REG_MEMBASE);\r\nrt3883_pci_w32(rpc, rpc->io_res.start, RT3883_PCI_REG_IOBASE);\r\nioport_resource.start = rpc->io_res.start;\r\nioport_resource.end = rpc->io_res.end;\r\nrt3883_pci_w32(rpc, 0x03ff0000, RT3883_PCI_REG_BAR0SETUP(0));\r\nrt3883_pci_w32(rpc, RT3883_MEMORY_BASE, RT3883_PCI_REG_IMBASEBAR0(0));\r\nrt3883_pci_w32(rpc, 0x08021814, RT3883_PCI_REG_ID(0));\r\nrt3883_pci_w32(rpc, 0x00800001, RT3883_PCI_REG_CLASS(0));\r\nrt3883_pci_w32(rpc, 0x28801814, RT3883_PCI_REG_SUBID(0));\r\nrt3883_pci_w32(rpc, 0x03ff0000, RT3883_PCI_REG_BAR0SETUP(1));\r\nrt3883_pci_w32(rpc, RT3883_MEMORY_BASE, RT3883_PCI_REG_IMBASEBAR0(1));\r\nrt3883_pci_w32(rpc, 0x08021814, RT3883_PCI_REG_ID(1));\r\nrt3883_pci_w32(rpc, 0x06040001, RT3883_PCI_REG_CLASS(1));\r\nrt3883_pci_w32(rpc, 0x28801814, RT3883_PCI_REG_SUBID(1));\r\nerr = rt3883_pci_irq_init(dev, rpc);\r\nif (err)\r\ngoto err_put_hb_node;\r\nval = rt3883_pci_read_cfg32(rpc, 0, 0x01, 0, PCI_COMMAND);\r\nval |= PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER;\r\nrt3883_pci_write_cfg32(rpc, 0, 0x01, 0, PCI_COMMAND, val);\r\nval = rt3883_pci_read_cfg32(rpc, 0, 0x00, 0, PCI_COMMAND);\r\nval |= PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER;\r\nrt3883_pci_write_cfg32(rpc, 0, 0x00, 0, PCI_COMMAND, val);\r\nif (mode == RT3883_PCI_MODE_PCIE) {\r\nrt3883_pci_w32(rpc, 0x03ff0001, RT3883_PCI_REG_BAR0SETUP(0));\r\nrt3883_pci_w32(rpc, 0x03ff0001, RT3883_PCI_REG_BAR0SETUP(1));\r\nrt3883_pci_write_cfg32(rpc, 0, RT3883_P2P_BR_DEVNUM, 0,\r\nPCI_BASE_ADDRESS_0,\r\nRT3883_MEMORY_BASE);\r\nrt3883_pci_read_cfg32(rpc, 0, RT3883_P2P_BR_DEVNUM, 0,\r\nPCI_BASE_ADDRESS_0);\r\n} else {\r\nrt3883_pci_write_cfg32(rpc, 0, RT3883_P2P_BR_DEVNUM, 0,\r\nPCI_IO_BASE, 0x00000101);\r\n}\r\nregister_pci_controller(&rpc->pci_controller);\r\nreturn 0;\r\nerr_put_hb_node:\r\nof_node_put(rpc->pci_controller.of_node);\r\nerr_put_intc_node:\r\nof_node_put(rpc->intc_of_node);\r\nreturn err;\r\n}\r\nint __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nreturn of_irq_parse_and_map_pci(dev, slot, pin);\r\n}\r\nint pcibios_plat_dev_init(struct pci_dev *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init rt3883_pci_init(void)\r\n{\r\nreturn platform_driver_register(&rt3883_pci_driver);\r\n}
