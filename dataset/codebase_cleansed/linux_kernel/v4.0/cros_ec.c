int cros_ec_prepare_tx(struct cros_ec_device *ec_dev,\r\nstruct cros_ec_command *msg)\r\n{\r\nuint8_t *out;\r\nint csum, i;\r\nBUG_ON(msg->outsize > EC_PROTO2_MAX_PARAM_SIZE);\r\nout = ec_dev->dout;\r\nout[0] = EC_CMD_VERSION0 + msg->version;\r\nout[1] = msg->command;\r\nout[2] = msg->outsize;\r\ncsum = out[0] + out[1] + out[2];\r\nfor (i = 0; i < msg->outsize; i++)\r\ncsum += out[EC_MSG_TX_HEADER_BYTES + i] = msg->outdata[i];\r\nout[EC_MSG_TX_HEADER_BYTES + msg->outsize] = (uint8_t)(csum & 0xff);\r\nreturn EC_MSG_TX_PROTO_BYTES + msg->outsize;\r\n}\r\nint cros_ec_check_result(struct cros_ec_device *ec_dev,\r\nstruct cros_ec_command *msg)\r\n{\r\nswitch (msg->result) {\r\ncase EC_RES_SUCCESS:\r\nreturn 0;\r\ncase EC_RES_IN_PROGRESS:\r\ndev_dbg(ec_dev->dev, "command 0x%02x in progress\n",\r\nmsg->command);\r\nreturn -EAGAIN;\r\ndefault:\r\ndev_dbg(ec_dev->dev, "command 0x%02x returned %d\n",\r\nmsg->command, msg->result);\r\nreturn 0;\r\n}\r\n}\r\nint cros_ec_cmd_xfer(struct cros_ec_device *ec_dev,\r\nstruct cros_ec_command *msg)\r\n{\r\nint ret;\r\nmutex_lock(&ec_dev->lock);\r\nret = ec_dev->cmd_xfer(ec_dev, msg);\r\nif (msg->result == EC_RES_IN_PROGRESS) {\r\nint i;\r\nstruct cros_ec_command status_msg;\r\nstruct ec_response_get_comms_status status;\r\nstatus_msg.version = 0;\r\nstatus_msg.command = EC_CMD_GET_COMMS_STATUS;\r\nstatus_msg.outdata = NULL;\r\nstatus_msg.outsize = 0;\r\nstatus_msg.indata = (uint8_t *)&status;\r\nstatus_msg.insize = sizeof(status);\r\nfor (i = 0; i < EC_COMMAND_RETRIES; i++) {\r\nusleep_range(10000, 11000);\r\nret = ec_dev->cmd_xfer(ec_dev, &status_msg);\r\nif (ret < 0)\r\nbreak;\r\nmsg->result = status_msg.result;\r\nif (status_msg.result != EC_RES_SUCCESS)\r\nbreak;\r\nif (!(status.flags & EC_COMMS_STATUS_PROCESSING))\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&ec_dev->lock);\r\nreturn ret;\r\n}\r\nint cros_ec_register(struct cros_ec_device *ec_dev)\r\n{\r\nstruct device *dev = ec_dev->dev;\r\nint err = 0;\r\nif (ec_dev->din_size) {\r\nec_dev->din = devm_kzalloc(dev, ec_dev->din_size, GFP_KERNEL);\r\nif (!ec_dev->din)\r\nreturn -ENOMEM;\r\n}\r\nif (ec_dev->dout_size) {\r\nec_dev->dout = devm_kzalloc(dev, ec_dev->dout_size, GFP_KERNEL);\r\nif (!ec_dev->dout)\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&ec_dev->lock);\r\nerr = mfd_add_devices(dev, 0, cros_devs,\r\nARRAY_SIZE(cros_devs),\r\nNULL, ec_dev->irq, NULL);\r\nif (err) {\r\ndev_err(dev, "failed to add mfd devices\n");\r\nreturn err;\r\n}\r\ndev_info(dev, "Chrome EC device registered\n");\r\nreturn 0;\r\n}\r\nint cros_ec_remove(struct cros_ec_device *ec_dev)\r\n{\r\nmfd_remove_devices(ec_dev->dev);\r\nreturn 0;\r\n}\r\nint cros_ec_suspend(struct cros_ec_device *ec_dev)\r\n{\r\nstruct device *dev = ec_dev->dev;\r\nif (device_may_wakeup(dev))\r\nec_dev->wake_enabled = !enable_irq_wake(ec_dev->irq);\r\ndisable_irq(ec_dev->irq);\r\nec_dev->was_wake_device = ec_dev->wake_enabled;\r\nreturn 0;\r\n}\r\nint cros_ec_resume(struct cros_ec_device *ec_dev)\r\n{\r\nenable_irq(ec_dev->irq);\r\nif (ec_dev->wake_enabled) {\r\ndisable_irq_wake(ec_dev->irq);\r\nec_dev->wake_enabled = 0;\r\n}\r\nreturn 0;\r\n}
