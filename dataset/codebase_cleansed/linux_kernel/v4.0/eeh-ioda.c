static int ioda_eeh_event(struct notifier_block *nb,\r\nunsigned long events, void *change)\r\n{\r\nuint64_t changed_evts = (uint64_t)change;\r\nif (!(changed_evts & OPAL_EVENT_PCI_ERROR) ||\r\n!(events & OPAL_EVENT_PCI_ERROR))\r\nreturn 0;\r\nif (eeh_enabled())\r\neeh_send_failure_event(NULL);\r\nelse\r\nopal_notifier_update_evt(OPAL_EVENT_PCI_ERROR, 0x0ul);\r\nreturn 0;\r\n}\r\nstatic ssize_t ioda_eeh_ei_write(struct file *filp,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct pci_controller *hose = filp->private_data;\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct eeh_dev *edev;\r\nstruct eeh_pe *pe;\r\nint pe_no, type, func;\r\nunsigned long addr, mask;\r\nchar buf[50];\r\nint ret;\r\nif (!phb->eeh_ops || !phb->eeh_ops->err_inject)\r\nreturn -ENXIO;\r\nret = simple_write_to_buffer(buf, sizeof(buf), ppos, user_buf, count);\r\nif (!ret)\r\nreturn -EFAULT;\r\nret = sscanf(buf, "%x:%x:%x:%lx:%lx",\r\n&pe_no, &type, &func, &addr, &mask);\r\nif (ret != 5)\r\nreturn -EINVAL;\r\nedev = kzalloc(sizeof(*edev), GFP_KERNEL);\r\nif (!edev)\r\nreturn -ENOMEM;\r\nedev->phb = hose;\r\nedev->pe_config_addr = pe_no;\r\npe = eeh_pe_get(edev);\r\nkfree(edev);\r\nif (!pe)\r\nreturn -ENODEV;\r\nret = phb->eeh_ops->err_inject(pe, type, func, addr, mask);\r\nreturn ret < 0 ? ret : count;\r\n}\r\nstatic int ioda_eeh_dbgfs_set(void *data, int offset, u64 val)\r\n{\r\nstruct pci_controller *hose = data;\r\nstruct pnv_phb *phb = hose->private_data;\r\nout_be64(phb->regs + offset, val);\r\nreturn 0;\r\n}\r\nstatic int ioda_eeh_dbgfs_get(void *data, int offset, u64 *val)\r\n{\r\nstruct pci_controller *hose = data;\r\nstruct pnv_phb *phb = hose->private_data;\r\n*val = in_be64(phb->regs + offset);\r\nreturn 0;\r\n}\r\nstatic int ioda_eeh_outb_dbgfs_set(void *data, u64 val)\r\n{\r\nreturn ioda_eeh_dbgfs_set(data, 0xD10, val);\r\n}\r\nstatic int ioda_eeh_outb_dbgfs_get(void *data, u64 *val)\r\n{\r\nreturn ioda_eeh_dbgfs_get(data, 0xD10, val);\r\n}\r\nstatic int ioda_eeh_inbA_dbgfs_set(void *data, u64 val)\r\n{\r\nreturn ioda_eeh_dbgfs_set(data, 0xD90, val);\r\n}\r\nstatic int ioda_eeh_inbA_dbgfs_get(void *data, u64 *val)\r\n{\r\nreturn ioda_eeh_dbgfs_get(data, 0xD90, val);\r\n}\r\nstatic int ioda_eeh_inbB_dbgfs_set(void *data, u64 val)\r\n{\r\nreturn ioda_eeh_dbgfs_set(data, 0xE10, val);\r\n}\r\nstatic int ioda_eeh_inbB_dbgfs_get(void *data, u64 *val)\r\n{\r\nreturn ioda_eeh_dbgfs_get(data, 0xE10, val);\r\n}\r\nstatic int ioda_eeh_post_init(struct pci_controller *hose)\r\n{\r\nstruct pnv_phb *phb = hose->private_data;\r\nint ret;\r\nif (!ioda_eeh_nb_init) {\r\nret = opal_notifier_register(&ioda_eeh_nb);\r\nif (ret) {\r\npr_err("%s: Can't register OPAL event notifier (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nioda_eeh_nb_init = 1;\r\n}\r\n#ifdef CONFIG_DEBUG_FS\r\nif (!phb->has_dbgfs && phb->dbgfs) {\r\nphb->has_dbgfs = 1;\r\ndebugfs_create_file("err_injct", 0200,\r\nphb->dbgfs, hose,\r\n&ioda_eeh_ei_fops);\r\ndebugfs_create_file("err_injct_outbound", 0600,\r\nphb->dbgfs, hose,\r\n&ioda_eeh_outb_dbgfs_ops);\r\ndebugfs_create_file("err_injct_inboundA", 0600,\r\nphb->dbgfs, hose,\r\n&ioda_eeh_inbA_dbgfs_ops);\r\ndebugfs_create_file("err_injct_inboundB", 0600,\r\nphb->dbgfs, hose,\r\n&ioda_eeh_inbB_dbgfs_ops);\r\n}\r\n#endif\r\nif (eeh_enabled())\r\nphb->flags |= PNV_PHB_FLAG_EEH;\r\nelse\r\nphb->flags &= ~PNV_PHB_FLAG_EEH;\r\nreturn 0;\r\n}\r\nstatic int ioda_eeh_set_option(struct eeh_pe *pe, int option)\r\n{\r\nstruct pci_controller *hose = pe->phb;\r\nstruct pnv_phb *phb = hose->private_data;\r\nbool freeze_pe = false;\r\nint enable, ret = 0;\r\ns64 rc;\r\nif (pe->addr < 0 || pe->addr >= phb->ioda.total_pe) {\r\npr_err("%s: PE address %x out of range [0, %x] "\r\n"on PHB#%x\n",\r\n__func__, pe->addr, phb->ioda.total_pe,\r\nhose->global_number);\r\nreturn -EINVAL;\r\n}\r\nswitch (option) {\r\ncase EEH_OPT_DISABLE:\r\nreturn -EPERM;\r\ncase EEH_OPT_ENABLE:\r\nreturn 0;\r\ncase EEH_OPT_THAW_MMIO:\r\nenable = OPAL_EEH_ACTION_CLEAR_FREEZE_MMIO;\r\nbreak;\r\ncase EEH_OPT_THAW_DMA:\r\nenable = OPAL_EEH_ACTION_CLEAR_FREEZE_DMA;\r\nbreak;\r\ncase EEH_OPT_FREEZE_PE:\r\nfreeze_pe = true;\r\nenable = OPAL_EEH_ACTION_SET_FREEZE_ALL;\r\nbreak;\r\ndefault:\r\npr_warn("%s: Invalid option %d\n",\r\n__func__, option);\r\nreturn -EINVAL;\r\n}\r\nif (freeze_pe) {\r\nif (phb->freeze_pe) {\r\nphb->freeze_pe(phb, pe->addr);\r\n} else {\r\nrc = opal_pci_eeh_freeze_set(phb->opal_id,\r\npe->addr,\r\nenable);\r\nif (rc != OPAL_SUCCESS) {\r\npr_warn("%s: Failure %lld freezing "\r\n"PHB#%x-PE#%x\n",\r\n__func__, rc,\r\nphb->hose->global_number, pe->addr);\r\nret = -EIO;\r\n}\r\n}\r\n} else {\r\nif (phb->unfreeze_pe) {\r\nret = phb->unfreeze_pe(phb, pe->addr, enable);\r\n} else {\r\nrc = opal_pci_eeh_freeze_clear(phb->opal_id,\r\npe->addr,\r\nenable);\r\nif (rc != OPAL_SUCCESS) {\r\npr_warn("%s: Failure %lld enable %d "\r\n"for PHB#%x-PE#%x\n",\r\n__func__, rc, option,\r\nphb->hose->global_number, pe->addr);\r\nret = -EIO;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void ioda_eeh_phb_diag(struct eeh_pe *pe)\r\n{\r\nstruct pnv_phb *phb = pe->phb->private_data;\r\nlong rc;\r\nrc = opal_pci_get_phb_diag_data2(phb->opal_id, pe->data,\r\nPNV_PCI_DIAG_BUF_SIZE);\r\nif (rc != OPAL_SUCCESS)\r\npr_warn("%s: Failed to get diag-data for PHB#%x (%ld)\n",\r\n__func__, pe->phb->global_number, rc);\r\n}\r\nstatic int ioda_eeh_get_phb_state(struct eeh_pe *pe)\r\n{\r\nstruct pnv_phb *phb = pe->phb->private_data;\r\nu8 fstate;\r\n__be16 pcierr;\r\ns64 rc;\r\nint result = 0;\r\nrc = opal_pci_eeh_freeze_status(phb->opal_id,\r\npe->addr,\r\n&fstate,\r\n&pcierr,\r\nNULL);\r\nif (rc != OPAL_SUCCESS) {\r\npr_warn("%s: Failure %lld getting PHB#%x state\n",\r\n__func__, rc, phb->hose->global_number);\r\nreturn EEH_STATE_NOT_SUPPORT;\r\n}\r\nif (be16_to_cpu(pcierr) != OPAL_EEH_PHB_ERROR) {\r\nresult = (EEH_STATE_MMIO_ACTIVE |\r\nEEH_STATE_DMA_ACTIVE |\r\nEEH_STATE_MMIO_ENABLED |\r\nEEH_STATE_DMA_ENABLED);\r\n} else if (!(pe->state & EEH_PE_ISOLATED)) {\r\neeh_pe_state_mark(pe, EEH_PE_ISOLATED);\r\nioda_eeh_phb_diag(pe);\r\nif (eeh_has_flag(EEH_EARLY_DUMP_LOG))\r\npnv_pci_dump_phb_diag_data(pe->phb, pe->data);\r\n}\r\nreturn result;\r\n}\r\nstatic int ioda_eeh_get_pe_state(struct eeh_pe *pe)\r\n{\r\nstruct pnv_phb *phb = pe->phb->private_data;\r\nu8 fstate;\r\n__be16 pcierr;\r\ns64 rc;\r\nint result;\r\nif (pe->state & EEH_PE_RESET) {\r\nresult = (EEH_STATE_MMIO_ACTIVE |\r\nEEH_STATE_DMA_ACTIVE |\r\nEEH_STATE_MMIO_ENABLED |\r\nEEH_STATE_DMA_ENABLED);\r\nreturn result;\r\n}\r\nif (phb->get_pe_state) {\r\nfstate = phb->get_pe_state(phb, pe->addr);\r\n} else {\r\nrc = opal_pci_eeh_freeze_status(phb->opal_id,\r\npe->addr,\r\n&fstate,\r\n&pcierr,\r\nNULL);\r\nif (rc != OPAL_SUCCESS) {\r\npr_warn("%s: Failure %lld getting PHB#%x-PE%x state\n",\r\n__func__, rc, phb->hose->global_number, pe->addr);\r\nreturn EEH_STATE_NOT_SUPPORT;\r\n}\r\n}\r\nswitch (fstate) {\r\ncase OPAL_EEH_STOPPED_NOT_FROZEN:\r\nresult = (EEH_STATE_MMIO_ACTIVE |\r\nEEH_STATE_DMA_ACTIVE |\r\nEEH_STATE_MMIO_ENABLED |\r\nEEH_STATE_DMA_ENABLED);\r\nbreak;\r\ncase OPAL_EEH_STOPPED_MMIO_FREEZE:\r\nresult = (EEH_STATE_DMA_ACTIVE |\r\nEEH_STATE_DMA_ENABLED);\r\nbreak;\r\ncase OPAL_EEH_STOPPED_DMA_FREEZE:\r\nresult = (EEH_STATE_MMIO_ACTIVE |\r\nEEH_STATE_MMIO_ENABLED);\r\nbreak;\r\ncase OPAL_EEH_STOPPED_MMIO_DMA_FREEZE:\r\nresult = 0;\r\nbreak;\r\ncase OPAL_EEH_STOPPED_RESET:\r\nresult = EEH_STATE_RESET_ACTIVE;\r\nbreak;\r\ncase OPAL_EEH_STOPPED_TEMP_UNAVAIL:\r\nresult = EEH_STATE_UNAVAILABLE;\r\nbreak;\r\ncase OPAL_EEH_STOPPED_PERM_UNAVAIL:\r\nresult = EEH_STATE_NOT_SUPPORT;\r\nbreak;\r\ndefault:\r\nresult = EEH_STATE_NOT_SUPPORT;\r\npr_warn("%s: Invalid PHB#%x-PE#%x state %x\n",\r\n__func__, phb->hose->global_number,\r\npe->addr, fstate);\r\n}\r\nif (!(result & EEH_STATE_NOT_SUPPORT) &&\r\n!(result & EEH_STATE_UNAVAILABLE) &&\r\n!(result & EEH_STATE_MMIO_ACTIVE) &&\r\n!(result & EEH_STATE_DMA_ACTIVE) &&\r\n!(pe->state & EEH_PE_ISOLATED)) {\r\nif (phb->freeze_pe)\r\nphb->freeze_pe(phb, pe->addr);\r\neeh_pe_state_mark(pe, EEH_PE_ISOLATED);\r\nioda_eeh_phb_diag(pe);\r\nif (eeh_has_flag(EEH_EARLY_DUMP_LOG))\r\npnv_pci_dump_phb_diag_data(pe->phb, pe->data);\r\n}\r\nreturn result;\r\n}\r\nstatic int ioda_eeh_get_state(struct eeh_pe *pe)\r\n{\r\nstruct pnv_phb *phb = pe->phb->private_data;\r\nif (pe->addr < 0 ||\r\npe->addr >= phb->ioda.total_pe) {\r\npr_warn("%s: PHB#%x-PE#%x out of range [0, %x]\n",\r\n__func__, phb->hose->global_number,\r\npe->addr, phb->ioda.total_pe);\r\nreturn EEH_STATE_NOT_SUPPORT;\r\n}\r\nif (pe->type & EEH_PE_PHB)\r\nreturn ioda_eeh_get_phb_state(pe);\r\nreturn ioda_eeh_get_pe_state(pe);\r\n}\r\nstatic s64 ioda_eeh_phb_poll(struct pnv_phb *phb)\r\n{\r\ns64 rc = OPAL_HARDWARE;\r\nwhile (1) {\r\nrc = opal_pci_poll(phb->opal_id);\r\nif (rc <= 0)\r\nbreak;\r\nif (system_state < SYSTEM_RUNNING)\r\nudelay(1000 * rc);\r\nelse\r\nmsleep(rc);\r\n}\r\nreturn rc;\r\n}\r\nint ioda_eeh_phb_reset(struct pci_controller *hose, int option)\r\n{\r\nstruct pnv_phb *phb = hose->private_data;\r\ns64 rc = OPAL_HARDWARE;\r\npr_debug("%s: Reset PHB#%x, option=%d\n",\r\n__func__, hose->global_number, option);\r\nif (option == EEH_RESET_FUNDAMENTAL ||\r\noption == EEH_RESET_HOT)\r\nrc = opal_pci_reset(phb->opal_id,\r\nOPAL_RESET_PHB_COMPLETE,\r\nOPAL_ASSERT_RESET);\r\nelse if (option == EEH_RESET_DEACTIVATE)\r\nrc = opal_pci_reset(phb->opal_id,\r\nOPAL_RESET_PHB_COMPLETE,\r\nOPAL_DEASSERT_RESET);\r\nif (rc < 0)\r\ngoto out;\r\nrc = ioda_eeh_phb_poll(phb);\r\nif (option == EEH_RESET_DEACTIVATE) {\r\nif (system_state < SYSTEM_RUNNING)\r\nudelay(1000 * EEH_PE_RST_SETTLE_TIME);\r\nelse\r\nmsleep(EEH_PE_RST_SETTLE_TIME);\r\n}\r\nout:\r\nif (rc != OPAL_SUCCESS)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int ioda_eeh_root_reset(struct pci_controller *hose, int option)\r\n{\r\nstruct pnv_phb *phb = hose->private_data;\r\ns64 rc = OPAL_SUCCESS;\r\npr_debug("%s: Reset PHB#%x, option=%d\n",\r\n__func__, hose->global_number, option);\r\nif (option == EEH_RESET_FUNDAMENTAL)\r\nrc = opal_pci_reset(phb->opal_id,\r\nOPAL_RESET_PCI_FUNDAMENTAL,\r\nOPAL_ASSERT_RESET);\r\nelse if (option == EEH_RESET_HOT)\r\nrc = opal_pci_reset(phb->opal_id,\r\nOPAL_RESET_PCI_HOT,\r\nOPAL_ASSERT_RESET);\r\nelse if (option == EEH_RESET_DEACTIVATE)\r\nrc = opal_pci_reset(phb->opal_id,\r\nOPAL_RESET_PCI_HOT,\r\nOPAL_DEASSERT_RESET);\r\nif (rc < 0)\r\ngoto out;\r\nrc = ioda_eeh_phb_poll(phb);\r\nif (option == EEH_RESET_DEACTIVATE)\r\nmsleep(EEH_PE_RST_SETTLE_TIME);\r\nout:\r\nif (rc != OPAL_SUCCESS)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int ioda_eeh_bridge_reset(struct pci_dev *dev, int option)\r\n{\r\nstruct device_node *dn = pci_device_to_OF_node(dev);\r\nstruct eeh_dev *edev = of_node_to_eeh_dev(dn);\r\nint aer = edev ? edev->aer_cap : 0;\r\nu32 ctrl;\r\npr_debug("%s: Reset PCI bus %04x:%02x with option %d\n",\r\n__func__, pci_domain_nr(dev->bus),\r\ndev->bus->number, option);\r\nswitch (option) {\r\ncase EEH_RESET_FUNDAMENTAL:\r\ncase EEH_RESET_HOT:\r\nif (aer) {\r\neeh_ops->read_config(dn, aer + PCI_ERR_UNCOR_MASK,\r\n4, &ctrl);\r\nctrl |= PCI_ERR_UNC_SURPDN;\r\neeh_ops->write_config(dn, aer + PCI_ERR_UNCOR_MASK,\r\n4, ctrl);\r\n}\r\neeh_ops->read_config(dn, PCI_BRIDGE_CONTROL, 2, &ctrl);\r\nctrl |= PCI_BRIDGE_CTL_BUS_RESET;\r\neeh_ops->write_config(dn, PCI_BRIDGE_CONTROL, 2, ctrl);\r\nmsleep(EEH_PE_RST_HOLD_TIME);\r\nbreak;\r\ncase EEH_RESET_DEACTIVATE:\r\neeh_ops->read_config(dn, PCI_BRIDGE_CONTROL, 2, &ctrl);\r\nctrl &= ~PCI_BRIDGE_CTL_BUS_RESET;\r\neeh_ops->write_config(dn, PCI_BRIDGE_CONTROL, 2, ctrl);\r\nmsleep(EEH_PE_RST_SETTLE_TIME);\r\nif (aer) {\r\neeh_ops->read_config(dn, aer + PCI_ERR_UNCOR_MASK,\r\n4, &ctrl);\r\nctrl &= ~PCI_ERR_UNC_SURPDN;\r\neeh_ops->write_config(dn, aer + PCI_ERR_UNCOR_MASK,\r\n4, ctrl);\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid pnv_pci_reset_secondary_bus(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *hose;\r\nif (pci_is_root_bus(dev->bus)) {\r\nhose = pci_bus_to_host(dev->bus);\r\nioda_eeh_root_reset(hose, EEH_RESET_HOT);\r\nioda_eeh_root_reset(hose, EEH_RESET_DEACTIVATE);\r\n} else {\r\nioda_eeh_bridge_reset(dev, EEH_RESET_HOT);\r\nioda_eeh_bridge_reset(dev, EEH_RESET_DEACTIVATE);\r\n}\r\n}\r\nstatic int ioda_eeh_reset(struct eeh_pe *pe, int option)\r\n{\r\nstruct pci_controller *hose = pe->phb;\r\nstruct pci_bus *bus;\r\nint ret;\r\nif (pe->type & EEH_PE_PHB) {\r\nret = ioda_eeh_phb_reset(hose, option);\r\n} else {\r\nstruct pnv_phb *phb;\r\ns64 rc;\r\nphb = hose->private_data;\r\nif (phb->model == PNV_PHB_MODEL_P7IOC &&\r\n(option == EEH_RESET_HOT ||\r\noption == EEH_RESET_FUNDAMENTAL)) {\r\nrc = opal_pci_reset(phb->opal_id,\r\nOPAL_RESET_PHB_ERROR,\r\nOPAL_ASSERT_RESET);\r\nif (rc != OPAL_SUCCESS) {\r\npr_warn("%s: Failure %lld clearing "\r\n"error injection registers\n",\r\n__func__, rc);\r\nreturn -EIO;\r\n}\r\n}\r\nbus = eeh_pe_bus_get(pe);\r\nif (pci_is_root_bus(bus) ||\r\npci_is_root_bus(bus->parent))\r\nret = ioda_eeh_root_reset(hose, option);\r\nelse\r\nret = ioda_eeh_bridge_reset(bus->self, option);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ioda_eeh_get_log(struct eeh_pe *pe, int severity,\r\nchar *drv_log, unsigned long len)\r\n{\r\nif (!eeh_has_flag(EEH_EARLY_DUMP_LOG))\r\npnv_pci_dump_phb_diag_data(pe->phb, pe->data);\r\nreturn 0;\r\n}\r\nstatic int ioda_eeh_configure_bridge(struct eeh_pe *pe)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ioda_eeh_err_inject(struct eeh_pe *pe, int type, int func,\r\nunsigned long addr, unsigned long mask)\r\n{\r\nstruct pci_controller *hose = pe->phb;\r\nstruct pnv_phb *phb = hose->private_data;\r\ns64 ret;\r\nif (type != OPAL_ERR_INJECT_TYPE_IOA_BUS_ERR &&\r\ntype != OPAL_ERR_INJECT_TYPE_IOA_BUS_ERR64) {\r\npr_warn("%s: Invalid error type %d\n",\r\n__func__, type);\r\nreturn -ERANGE;\r\n}\r\nif (func < OPAL_ERR_INJECT_FUNC_IOA_LD_MEM_ADDR ||\r\nfunc > OPAL_ERR_INJECT_FUNC_IOA_DMA_WR_TARGET) {\r\npr_warn("%s: Invalid error function %d\n",\r\n__func__, func);\r\nreturn -ERANGE;\r\n}\r\nif (!opal_check_token(OPAL_PCI_ERR_INJECT)) {\r\npr_warn("%s: Firmware doesn't support error injection\n",\r\n__func__);\r\nreturn -ENXIO;\r\n}\r\nret = opal_pci_err_inject(phb->opal_id, pe->addr,\r\ntype, func, addr, mask);\r\nif (ret != OPAL_SUCCESS) {\r\npr_warn("%s: Failure %lld injecting error "\r\n"%d-%d to PHB#%x-PE#%x\n",\r\n__func__, ret, type, func,\r\nhose->global_number, pe->addr);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ioda_eeh_hub_diag_common(struct OpalIoP7IOCErrorData *data)\r\n{\r\nif (data->gemXfir || data->gemRfir ||\r\ndata->gemRirqfir || data->gemMask || data->gemRwof)\r\npr_info(" GEM: %016llx %016llx %016llx %016llx %016llx\n",\r\nbe64_to_cpu(data->gemXfir),\r\nbe64_to_cpu(data->gemRfir),\r\nbe64_to_cpu(data->gemRirqfir),\r\nbe64_to_cpu(data->gemMask),\r\nbe64_to_cpu(data->gemRwof));\r\nif (data->lemFir || data->lemErrMask ||\r\ndata->lemAction0 || data->lemAction1 || data->lemWof)\r\npr_info(" LEM: %016llx %016llx %016llx %016llx %016llx\n",\r\nbe64_to_cpu(data->lemFir),\r\nbe64_to_cpu(data->lemErrMask),\r\nbe64_to_cpu(data->lemAction0),\r\nbe64_to_cpu(data->lemAction1),\r\nbe64_to_cpu(data->lemWof));\r\n}\r\nstatic void ioda_eeh_hub_diag(struct pci_controller *hose)\r\n{\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct OpalIoP7IOCErrorData *data = &phb->diag.hub_diag;\r\nlong rc;\r\nrc = opal_pci_get_hub_diag_data(phb->hub_id, data, sizeof(*data));\r\nif (rc != OPAL_SUCCESS) {\r\npr_warn("%s: Failed to get HUB#%llx diag-data (%ld)\n",\r\n__func__, phb->hub_id, rc);\r\nreturn;\r\n}\r\nswitch (data->type) {\r\ncase OPAL_P7IOC_DIAG_TYPE_RGC:\r\npr_info("P7IOC diag-data for RGC\n\n");\r\nioda_eeh_hub_diag_common(data);\r\nif (data->rgc.rgcStatus || data->rgc.rgcLdcp)\r\npr_info(" RGC: %016llx %016llx\n",\r\nbe64_to_cpu(data->rgc.rgcStatus),\r\nbe64_to_cpu(data->rgc.rgcLdcp));\r\nbreak;\r\ncase OPAL_P7IOC_DIAG_TYPE_BI:\r\npr_info("P7IOC diag-data for BI %s\n\n",\r\ndata->bi.biDownbound ? "Downbound" : "Upbound");\r\nioda_eeh_hub_diag_common(data);\r\nif (data->bi.biLdcp0 || data->bi.biLdcp1 ||\r\ndata->bi.biLdcp2 || data->bi.biFenceStatus)\r\npr_info(" BI: %016llx %016llx %016llx %016llx\n",\r\nbe64_to_cpu(data->bi.biLdcp0),\r\nbe64_to_cpu(data->bi.biLdcp1),\r\nbe64_to_cpu(data->bi.biLdcp2),\r\nbe64_to_cpu(data->bi.biFenceStatus));\r\nbreak;\r\ncase OPAL_P7IOC_DIAG_TYPE_CI:\r\npr_info("P7IOC diag-data for CI Port %d\n\n",\r\ndata->ci.ciPort);\r\nioda_eeh_hub_diag_common(data);\r\nif (data->ci.ciPortStatus || data->ci.ciPortLdcp)\r\npr_info(" CI: %016llx %016llx\n",\r\nbe64_to_cpu(data->ci.ciPortStatus),\r\nbe64_to_cpu(data->ci.ciPortLdcp));\r\nbreak;\r\ncase OPAL_P7IOC_DIAG_TYPE_MISC:\r\npr_info("P7IOC diag-data for MISC\n\n");\r\nioda_eeh_hub_diag_common(data);\r\nbreak;\r\ncase OPAL_P7IOC_DIAG_TYPE_I2C:\r\npr_info("P7IOC diag-data for I2C\n\n");\r\nioda_eeh_hub_diag_common(data);\r\nbreak;\r\ndefault:\r\npr_warn("%s: Invalid type of HUB#%llx diag-data (%d)\n",\r\n__func__, phb->hub_id, data->type);\r\n}\r\n}\r\nstatic int ioda_eeh_get_pe(struct pci_controller *hose,\r\nu16 pe_no, struct eeh_pe **pe)\r\n{\r\nstruct pnv_phb *phb = hose->private_data;\r\nstruct pnv_ioda_pe *pnv_pe;\r\nstruct eeh_pe *dev_pe;\r\nstruct eeh_dev edev;\r\npnv_pe = &phb->ioda.pe_array[pe_no];\r\nif (pnv_pe->flags & PNV_IODA_PE_SLAVE) {\r\npnv_pe = pnv_pe->master;\r\nWARN_ON(!pnv_pe ||\r\n!(pnv_pe->flags & PNV_IODA_PE_MASTER));\r\npe_no = pnv_pe->pe_number;\r\n}\r\nmemset(&edev, 0, sizeof(struct eeh_dev));\r\nedev.phb = hose;\r\nedev.pe_config_addr = pe_no;\r\ndev_pe = eeh_pe_get(&edev);\r\nif (!dev_pe)\r\nreturn -EEXIST;\r\n*pe = dev_pe;\r\nif (!(dev_pe->state & EEH_PE_ISOLATED))\r\nphb->freeze_pe(phb, pe_no);\r\ndev_pe = dev_pe->parent;\r\nwhile (dev_pe && !(dev_pe->type & EEH_PE_PHB)) {\r\nint ret;\r\nint active_flags = (EEH_STATE_MMIO_ACTIVE |\r\nEEH_STATE_DMA_ACTIVE);\r\nret = eeh_ops->get_state(dev_pe, NULL);\r\nif (ret <= 0 || (ret & active_flags) == active_flags) {\r\ndev_pe = dev_pe->parent;\r\ncontinue;\r\n}\r\n*pe = dev_pe;\r\nif (!(dev_pe->state & EEH_PE_ISOLATED))\r\nphb->freeze_pe(phb, dev_pe->addr);\r\ndev_pe = dev_pe->parent;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ioda_eeh_next_error(struct eeh_pe **pe)\r\n{\r\nstruct pci_controller *hose;\r\nstruct pnv_phb *phb;\r\nstruct eeh_pe *phb_pe, *parent_pe;\r\n__be64 frozen_pe_no;\r\n__be16 err_type, severity;\r\nint active_flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);\r\nlong rc;\r\nint state, ret = EEH_NEXT_ERR_NONE;\r\neeh_remove_event(NULL, false);\r\nopal_notifier_update_evt(OPAL_EVENT_PCI_ERROR, 0x0ul);\r\nlist_for_each_entry(hose, &hose_list, list_node) {\r\nphb = hose->private_data;\r\nphb_pe = eeh_phb_pe_get(hose);\r\nif (!phb_pe || (phb_pe->state & EEH_PE_ISOLATED))\r\ncontinue;\r\nrc = opal_pci_next_error(phb->opal_id,\r\n&frozen_pe_no, &err_type, &severity);\r\nif (rc != OPAL_SUCCESS) {\r\npr_devel("%s: Invalid return value on "\r\n"PHB#%x (0x%lx) from opal_pci_next_error",\r\n__func__, hose->global_number, rc);\r\ncontinue;\r\n}\r\nif (be16_to_cpu(err_type) == OPAL_EEH_NO_ERROR ||\r\nbe16_to_cpu(severity) == OPAL_EEH_SEV_NO_ERROR) {\r\npr_devel("%s: No error found on PHB#%x\n",\r\n__func__, hose->global_number);\r\ncontinue;\r\n}\r\npr_devel("%s: Error (%d, %d, %llu) on PHB#%x\n",\r\n__func__, be16_to_cpu(err_type), be16_to_cpu(severity),\r\nbe64_to_cpu(frozen_pe_no), hose->global_number);\r\nswitch (be16_to_cpu(err_type)) {\r\ncase OPAL_EEH_IOC_ERROR:\r\nif (be16_to_cpu(severity) == OPAL_EEH_SEV_IOC_DEAD) {\r\npr_err("EEH: dead IOC detected\n");\r\nret = EEH_NEXT_ERR_DEAD_IOC;\r\n} else if (be16_to_cpu(severity) == OPAL_EEH_SEV_INF) {\r\npr_info("EEH: IOC informative error "\r\n"detected\n");\r\nioda_eeh_hub_diag(hose);\r\nret = EEH_NEXT_ERR_NONE;\r\n}\r\nbreak;\r\ncase OPAL_EEH_PHB_ERROR:\r\nif (be16_to_cpu(severity) == OPAL_EEH_SEV_PHB_DEAD) {\r\n*pe = phb_pe;\r\npr_err("EEH: dead PHB#%x detected, "\r\n"location: %s\n",\r\nhose->global_number,\r\neeh_pe_loc_get(phb_pe));\r\nret = EEH_NEXT_ERR_DEAD_PHB;\r\n} else if (be16_to_cpu(severity) ==\r\nOPAL_EEH_SEV_PHB_FENCED) {\r\n*pe = phb_pe;\r\npr_err("EEH: Fenced PHB#%x detected, "\r\n"location: %s\n",\r\nhose->global_number,\r\neeh_pe_loc_get(phb_pe));\r\nret = EEH_NEXT_ERR_FENCED_PHB;\r\n} else if (be16_to_cpu(severity) == OPAL_EEH_SEV_INF) {\r\npr_info("EEH: PHB#%x informative error "\r\n"detected, location: %s\n",\r\nhose->global_number,\r\neeh_pe_loc_get(phb_pe));\r\nioda_eeh_phb_diag(phb_pe);\r\npnv_pci_dump_phb_diag_data(hose, phb_pe->data);\r\nret = EEH_NEXT_ERR_NONE;\r\n}\r\nbreak;\r\ncase OPAL_EEH_PE_ERROR:\r\nif (ioda_eeh_get_pe(hose,\r\nbe64_to_cpu(frozen_pe_no), pe)) {\r\npr_info("EEH: Clear non-existing PHB#%x-PE#%llx\n",\r\nhose->global_number, frozen_pe_no);\r\npr_info("EEH: PHB location: %s\n",\r\neeh_pe_loc_get(phb_pe));\r\nopal_pci_eeh_freeze_clear(phb->opal_id, frozen_pe_no,\r\nOPAL_EEH_ACTION_CLEAR_FREEZE_ALL);\r\nret = EEH_NEXT_ERR_NONE;\r\n} else if ((*pe)->state & EEH_PE_ISOLATED ||\r\neeh_pe_passed(*pe)) {\r\nret = EEH_NEXT_ERR_NONE;\r\n} else {\r\npr_err("EEH: Frozen PE#%x on PHB#%x detected\n",\r\n(*pe)->addr, (*pe)->phb->global_number);\r\npr_err("EEH: PE location: %s, PHB location: %s\n",\r\neeh_pe_loc_get(*pe), eeh_pe_loc_get(phb_pe));\r\nret = EEH_NEXT_ERR_FROZEN_PE;\r\n}\r\nbreak;\r\ndefault:\r\npr_warn("%s: Unexpected error type %d\n",\r\n__func__, be16_to_cpu(err_type));\r\n}\r\nif ((ret == EEH_NEXT_ERR_FROZEN_PE ||\r\nret == EEH_NEXT_ERR_FENCED_PHB) &&\r\n!((*pe)->state & EEH_PE_ISOLATED)) {\r\neeh_pe_state_mark(*pe, EEH_PE_ISOLATED);\r\nioda_eeh_phb_diag(*pe);\r\nif (eeh_has_flag(EEH_EARLY_DUMP_LOG))\r\npnv_pci_dump_phb_diag_data((*pe)->phb,\r\n(*pe)->data);\r\n}\r\nif (ret == EEH_NEXT_ERR_FROZEN_PE) {\r\nparent_pe = (*pe)->parent;\r\nwhile (parent_pe) {\r\nif (parent_pe->type & EEH_PE_PHB)\r\nbreak;\r\nstate = ioda_eeh_get_state(parent_pe);\r\nif (state > 0 &&\r\n(state & active_flags) != active_flags)\r\n*pe = parent_pe;\r\nparent_pe = parent_pe->parent;\r\n}\r\neeh_pe_state_mark(*pe, EEH_PE_ISOLATED);\r\n}\r\nif (ret > EEH_NEXT_ERR_INF)\r\nbreak;\r\n}\r\nreturn ret;\r\n}
