static int fpga_dma_init(struct fpga_dev *priv, int nr_pages)\r\n{\r\nstruct page *pg;\r\nint i;\r\npriv->vaddr = vmalloc_32(nr_pages << PAGE_SHIFT);\r\nif (NULL == priv->vaddr) {\r\npr_debug("vmalloc_32(%d pages) failed\n", nr_pages);\r\nreturn -ENOMEM;\r\n}\r\npr_debug("vmalloc is at addr 0x%08lx, size=%d\n",\r\n(unsigned long)priv->vaddr,\r\nnr_pages << PAGE_SHIFT);\r\nmemset(priv->vaddr, 0, nr_pages << PAGE_SHIFT);\r\npriv->nr_pages = nr_pages;\r\npriv->sglist = vzalloc(priv->nr_pages * sizeof(*priv->sglist));\r\nif (NULL == priv->sglist)\r\ngoto vzalloc_err;\r\nsg_init_table(priv->sglist, priv->nr_pages);\r\nfor (i = 0; i < priv->nr_pages; i++) {\r\npg = vmalloc_to_page(priv->vaddr + i * PAGE_SIZE);\r\nif (NULL == pg)\r\ngoto vmalloc_to_page_err;\r\nsg_set_page(&priv->sglist[i], pg, PAGE_SIZE, 0);\r\n}\r\nreturn 0;\r\nvmalloc_to_page_err:\r\nvfree(priv->sglist);\r\npriv->sglist = NULL;\r\nvzalloc_err:\r\nvfree(priv->vaddr);\r\npriv->vaddr = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic int fpga_dma_map(struct fpga_dev *priv)\r\n{\r\npriv->sglen = dma_map_sg(priv->dev, priv->sglist,\r\npriv->nr_pages, DMA_TO_DEVICE);\r\nif (0 == priv->sglen) {\r\npr_warn("%s: dma_map_sg failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fpga_dma_unmap(struct fpga_dev *priv)\r\n{\r\nif (!priv->sglen)\r\nreturn 0;\r\ndma_unmap_sg(priv->dev, priv->sglist, priv->sglen, DMA_TO_DEVICE);\r\npriv->sglen = 0;\r\nreturn 0;\r\n}\r\nstatic void fpga_drop_firmware_data(struct fpga_dev *priv)\r\n{\r\nvfree(priv->sglist);\r\nvfree(priv->vaddr);\r\npriv->buf_allocated = false;\r\npriv->bytes = 0;\r\n}\r\nstatic void fpga_dev_remove(struct kref *ref)\r\n{\r\nstruct fpga_dev *priv = container_of(ref, struct fpga_dev, ref);\r\nfpga_drop_firmware_data(priv);\r\nmutex_destroy(&priv->lock);\r\nkfree(priv);\r\n}\r\nstatic void ledtrig_fpga_programmed(bool enabled)\r\n{\r\nif (enabled)\r\nled_trigger_event(ledtrig_fpga, LED_FULL);\r\nelse\r\nled_trigger_event(ledtrig_fpga, LED_OFF);\r\n}\r\nstatic int fpga_fifo_size(void __iomem *regs)\r\n{\r\nreturn ioread32be(regs + FPGA_CONFIG_FIFO_SIZE);\r\n}\r\nstatic int fpga_config_error(void __iomem *regs)\r\n{\r\nreturn ioread32be(regs + FPGA_CONFIG_STATUS) & CFG_STATUS_ERR_MASK;\r\n}\r\nstatic int fpga_fifo_empty(void __iomem *regs)\r\n{\r\nreturn ioread32be(regs + FPGA_CONFIG_FIFO_USED) == 0;\r\n}\r\nstatic void fpga_fifo_write(void __iomem *regs, u32 val)\r\n{\r\niowrite32be(val, regs + FPGA_FIFO_ADDRESS);\r\n}\r\nstatic void fpga_set_byte_count(void __iomem *regs, u32 count)\r\n{\r\niowrite32be(count, regs + FPGA_CONFIG_TOTAL_BYTE_COUNT);\r\n}\r\nstatic void fpga_programmer_enable(struct fpga_dev *priv, bool dma)\r\n{\r\nu32 val;\r\nval = (dma) ? (CFG_CTL_ENABLE | CFG_CTL_DMA) : CFG_CTL_ENABLE;\r\niowrite32be(val, priv->regs + FPGA_CONFIG_CONTROL);\r\n}\r\nstatic void fpga_programmer_disable(struct fpga_dev *priv)\r\n{\r\niowrite32be(0x0, priv->regs + FPGA_CONFIG_CONTROL);\r\n}\r\nstatic void fpga_dump_registers(struct fpga_dev *priv)\r\n{\r\nu32 control, status, size, used, total, curr;\r\nif (priv->status == 0)\r\nreturn;\r\ncontrol = ioread32be(priv->regs + FPGA_CONFIG_CONTROL);\r\nstatus = ioread32be(priv->regs + FPGA_CONFIG_STATUS);\r\nsize = ioread32be(priv->regs + FPGA_CONFIG_FIFO_SIZE);\r\nused = ioread32be(priv->regs + FPGA_CONFIG_FIFO_USED);\r\ntotal = ioread32be(priv->regs + FPGA_CONFIG_TOTAL_BYTE_COUNT);\r\ncurr = ioread32be(priv->regs + FPGA_CONFIG_CUR_BYTE_COUNT);\r\ndev_err(priv->dev, "Configuration failed, dumping status registers\n");\r\ndev_err(priv->dev, "Control: 0x%.8x\n", control);\r\ndev_err(priv->dev, "Status: 0x%.8x\n", status);\r\ndev_err(priv->dev, "FIFO Size: 0x%.8x\n", size);\r\ndev_err(priv->dev, "FIFO Used: 0x%.8x\n", used);\r\ndev_err(priv->dev, "FIFO Total: 0x%.8x\n", total);\r\ndev_err(priv->dev, "FIFO Curr: 0x%.8x\n", curr);\r\n}\r\nstatic bool fpga_power_good(struct fpga_dev *priv)\r\n{\r\nu8 val;\r\nval = ioread8(priv->regs + CTL_PWR_STATUS);\r\nif (val & PWR_STATUS_ERROR_MASK)\r\nreturn false;\r\nreturn val == PWR_STATUS_GOOD;\r\n}\r\nstatic void fpga_disable_power_supplies(struct fpga_dev *priv)\r\n{\r\nunsigned long start;\r\nu8 val;\r\niowrite8(0x0, priv->regs + CTL_PWR_CONTROL);\r\nmsleep(500);\r\nstart = jiffies;\r\nwhile (time_before(jiffies, start + HZ)) {\r\nval = ioread8(priv->regs + CTL_PWR_STATUS);\r\nif (!(val & PWR_STATUS_GOOD))\r\nbreak;\r\nusleep_range(5000, 10000);\r\n}\r\nval = ioread8(priv->regs + CTL_PWR_STATUS);\r\nif (val & PWR_STATUS_GOOD) {\r\ndev_err(priv->dev, "power disable failed: "\r\n"power goods: status 0x%.2x\n", val);\r\n}\r\nif (val & PWR_STATUS_ERROR_MASK) {\r\ndev_err(priv->dev, "power disable failed: "\r\n"alarm bit set: status 0x%.2x\n", val);\r\n}\r\n}\r\nstatic int fpga_enable_power_supplies(struct fpga_dev *priv)\r\n{\r\nunsigned long start = jiffies;\r\nif (fpga_power_good(priv)) {\r\ndev_dbg(priv->dev, "power was already good\n");\r\nreturn 0;\r\n}\r\niowrite8(PWR_CONTROL_ENABLE, priv->regs + CTL_PWR_CONTROL);\r\nwhile (time_before(jiffies, start + HZ)) {\r\nif (fpga_power_good(priv))\r\nreturn 0;\r\nusleep_range(5000, 10000);\r\n}\r\nreturn fpga_power_good(priv) ? 0 : -ETIMEDOUT;\r\n}\r\nstatic bool fpga_power_enabled(struct fpga_dev *priv)\r\n{\r\nu8 val;\r\nval = ioread8(priv->regs + CTL_PWR_CONTROL);\r\nif (val & PWR_CONTROL_ENABLE)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool fpga_running(struct fpga_dev *priv)\r\n{\r\nif (!fpga_power_good(priv))\r\nreturn false;\r\nreturn ioread32be(priv->regs + FPGA_CONFIG_STATUS) & (1 << 18);\r\n}\r\nstatic int fpga_program_block(struct fpga_dev *priv, void *buf, size_t count)\r\n{\r\nu32 *data = buf;\r\nint size = fpga_fifo_size(priv->regs);\r\nint i, len;\r\nunsigned long timeout;\r\nBUG_ON(count % 4 != 0);\r\nwhile (count > 0) {\r\nlen = min_t(size_t, count, size);\r\ntimeout = jiffies + HZ / 4;\r\nfor (i = 0; i < len / 4; i++)\r\nfpga_fifo_write(priv->regs, data[i]);\r\ncount -= len;\r\ndata += len / 4;\r\nwhile (true) {\r\nif (fpga_fifo_empty(priv->regs)) {\r\nbreak;\r\n} else {\r\ndev_dbg(priv->dev, "Fifo not empty\n");\r\ncpu_relax();\r\n}\r\nif (fpga_config_error(priv->regs)) {\r\ndev_err(priv->dev, "Error detected\n");\r\nreturn -EIO;\r\n}\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(priv->dev, "Fifo drain timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nusleep_range(5000, 10000);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic noinline int fpga_program_cpu(struct fpga_dev *priv)\r\n{\r\nint ret;\r\nfpga_programmer_disable(priv);\r\nfpga_set_byte_count(priv->regs, priv->bytes);\r\ndev_dbg(priv->dev, "total byte count %u bytes\n", priv->bytes);\r\nfpga_programmer_enable(priv, false);\r\ndev_dbg(priv->dev, "enabled the controller\n");\r\nret = fpga_program_block(priv, priv->vaddr, priv->bytes);\r\nif (ret)\r\ngoto out_disable_controller;\r\nret = wait_for_completion_timeout(&priv->completion, 2 * HZ);\r\nif (!ret) {\r\ndev_err(priv->dev, "Timed out waiting for completion\n");\r\nret = -ETIMEDOUT;\r\ngoto out_disable_controller;\r\n}\r\nret = priv->status;\r\nout_disable_controller:\r\nfpga_programmer_disable(priv);\r\nreturn ret;\r\n}\r\nstatic noinline int fpga_program_dma(struct fpga_dev *priv)\r\n{\r\nstruct dma_chan *chan = priv->chan;\r\nstruct dma_async_tx_descriptor *tx;\r\nsize_t num_pages, len, avail = 0;\r\nstruct dma_slave_config config;\r\nstruct scatterlist *sg;\r\nstruct sg_table table;\r\ndma_cookie_t cookie;\r\nint ret, i;\r\nfpga_programmer_disable(priv);\r\nnum_pages = DIV_ROUND_UP(priv->bytes, FIFO_MAX_LEN);\r\nret = sg_alloc_table(&table, num_pages, GFP_KERNEL);\r\nif (ret) {\r\ndev_err(priv->dev, "Unable to allocate dst scatterlist\n");\r\nret = -ENOMEM;\r\ngoto out_return;\r\n}\r\navail = priv->bytes;\r\nfor_each_sg(table.sgl, sg, num_pages, i) {\r\nlen = min_t(size_t, avail, FIFO_MAX_LEN);\r\nsg_dma_address(sg) = FIFO_DMA_ADDRESS;\r\nsg_dma_len(sg) = len;\r\navail -= len;\r\n}\r\nret = fpga_dma_map(priv);\r\nif (ret) {\r\ndev_err(priv->dev, "Unable to map buffer for DMA\n");\r\ngoto out_free_table;\r\n}\r\nmemset(&config, 0, sizeof(config));\r\nconfig.direction = DMA_MEM_TO_DEV;\r\nconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nconfig.dst_maxburst = fpga_fifo_size(priv->regs) / 2 / 4;\r\nret = dmaengine_slave_config(chan, &config);\r\nif (ret) {\r\ndev_err(priv->dev, "DMA slave configuration failed\n");\r\ngoto out_dma_unmap;\r\n}\r\nret = fsl_dma_external_start(chan, 1);\r\nif (ret) {\r\ndev_err(priv->dev, "DMA external control setup failed\n");\r\ngoto out_dma_unmap;\r\n}\r\ntx = dmaengine_prep_dma_sg(chan, table.sgl, num_pages,\r\npriv->sglist, priv->sglen, 0);\r\nif (!tx) {\r\ndev_err(priv->dev, "Unable to prep DMA transaction\n");\r\nret = -ENOMEM;\r\ngoto out_dma_unmap;\r\n}\r\ncookie = tx->tx_submit(tx);\r\nif (dma_submit_error(cookie)) {\r\ndev_err(priv->dev, "Unable to submit DMA transaction\n");\r\nret = -ENOMEM;\r\ngoto out_dma_unmap;\r\n}\r\ndma_async_issue_pending(chan);\r\nfpga_set_byte_count(priv->regs, priv->bytes);\r\ndev_dbg(priv->dev, "total byte count %u bytes\n", priv->bytes);\r\nfpga_programmer_enable(priv, true);\r\ndev_dbg(priv->dev, "enabled the controller\n");\r\nret = wait_for_completion_timeout(&priv->completion, 2 * HZ);\r\nif (!ret) {\r\ndev_err(priv->dev, "Timed out waiting for completion\n");\r\nret = -ETIMEDOUT;\r\ngoto out_disable_controller;\r\n}\r\nret = priv->status;\r\nout_disable_controller:\r\nfpga_programmer_disable(priv);\r\nout_dma_unmap:\r\nfpga_dma_unmap(priv);\r\nout_free_table:\r\nsg_free_table(&table);\r\nout_return:\r\nreturn ret;\r\n}\r\nstatic irqreturn_t fpga_irq(int irq, void *dev_id)\r\n{\r\nstruct fpga_dev *priv = dev_id;\r\npriv->status = fpga_config_error(priv->regs) ? -EIO : 0;\r\ndev_dbg(priv->dev, "INTERRUPT status %d\n", priv->status);\r\nfpga_dump_registers(priv);\r\nfpga_programmer_disable(priv);\r\ncomplete(&priv->completion);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fpga_do_stop(struct fpga_dev *priv)\r\n{\r\nu32 val;\r\nledtrig_fpga_programmed(false);\r\nval = CFG_CTL_ENABLE | CFG_CTL_RESET;\r\niowrite32be(val, priv->regs + FPGA_CONFIG_CONTROL);\r\niowrite32be(0x0, priv->regs + FPGA_CONFIG_CONTROL);\r\nreturn 0;\r\n}\r\nstatic noinline int fpga_do_program(struct fpga_dev *priv)\r\n{\r\nint ret;\r\nif (priv->bytes != priv->fw_size) {\r\ndev_err(priv->dev, "Incorrect bitfile size: got %zu bytes, "\r\n"should be %zu bytes\n",\r\npriv->bytes, priv->fw_size);\r\nreturn -EINVAL;\r\n}\r\nif (!fpga_power_enabled(priv)) {\r\ndev_err(priv->dev, "Power not enabled\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fpga_power_good(priv)) {\r\ndev_err(priv->dev, "Power not good\n");\r\nreturn -EINVAL;\r\n}\r\nledtrig_fpga_programmed(false);\r\nret = fpga_program_dma(priv);\r\nif (ret) {\r\ndev_warn(priv->dev, "Falling back to CPU programming\n");\r\nret = fpga_program_cpu(priv);\r\n}\r\nif (ret) {\r\ndev_err(priv->dev, "Unable to program FPGA's\n");\r\nreturn ret;\r\n}\r\nfpga_drop_firmware_data(priv);\r\ndev_dbg(priv->dev, "FPGA programming successful\n");\r\nledtrig_fpga_programmed(true);\r\nreturn 0;\r\n}\r\nstatic int fpga_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct fpga_dev *priv = container_of(filp->private_data,\r\nstruct fpga_dev, miscdev);\r\nunsigned int nr_pages;\r\nint ret;\r\nret = mutex_lock_interruptible(&priv->lock);\r\nif (ret)\r\nreturn ret;\r\nfilp->private_data = priv;\r\nkref_get(&priv->ref);\r\nif (filp->f_flags & O_TRUNC)\r\npriv->bytes = 0;\r\nif (priv->buf_allocated)\r\nreturn 0;\r\nnr_pages = DIV_ROUND_UP(priv->fw_size, PAGE_SIZE);\r\nret = fpga_dma_init(priv, nr_pages);\r\nif (ret) {\r\ndev_err(priv->dev, "unable to allocate data buffer\n");\r\nmutex_unlock(&priv->lock);\r\nkref_put(&priv->ref, fpga_dev_remove);\r\nreturn ret;\r\n}\r\npriv->buf_allocated = true;\r\nreturn 0;\r\n}\r\nstatic int fpga_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct fpga_dev *priv = filp->private_data;\r\nmutex_unlock(&priv->lock);\r\nkref_put(&priv->ref, fpga_dev_remove);\r\nreturn 0;\r\n}\r\nstatic ssize_t fpga_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nstruct fpga_dev *priv = filp->private_data;\r\nif (priv->bytes >= priv->fw_size)\r\nreturn -ENOSPC;\r\ncount = min_t(size_t, priv->fw_size - priv->bytes, count);\r\nif (copy_from_user(priv->vaddr + priv->bytes, buf, count))\r\nreturn -EFAULT;\r\npriv->bytes += count;\r\nreturn count;\r\n}\r\nstatic ssize_t fpga_read(struct file *filp, char __user *buf, size_t count,\r\nloff_t *f_pos)\r\n{\r\nstruct fpga_dev *priv = filp->private_data;\r\nreturn simple_read_from_buffer(buf, count, f_pos,\r\npriv->vaddr, priv->bytes);\r\n}\r\nstatic loff_t fpga_llseek(struct file *filp, loff_t offset, int origin)\r\n{\r\nstruct fpga_dev *priv = filp->private_data;\r\nif ((filp->f_flags & O_ACCMODE) != O_RDONLY)\r\nreturn -EINVAL;\r\nreturn fixed_size_llseek(filp, offset, origin, priv->fw_size);\r\n}\r\nstatic ssize_t pfail_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fpga_dev *priv = dev_get_drvdata(dev);\r\nu8 val;\r\nval = ioread8(priv->regs + CTL_PWR_FAIL);\r\nreturn snprintf(buf, PAGE_SIZE, "0x%.2x\n", val);\r\n}\r\nstatic ssize_t pgood_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fpga_dev *priv = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", fpga_power_good(priv));\r\n}\r\nstatic ssize_t penable_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fpga_dev *priv = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", fpga_power_enabled(priv));\r\n}\r\nstatic ssize_t penable_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fpga_dev *priv = dev_get_drvdata(dev);\r\nunsigned long val;\r\nint ret;\r\nret = kstrtoul(buf, 0, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val) {\r\nret = fpga_enable_power_supplies(priv);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nfpga_do_stop(priv);\r\nfpga_disable_power_supplies(priv);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t program_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct fpga_dev *priv = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", fpga_running(priv));\r\n}\r\nstatic ssize_t program_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fpga_dev *priv = dev_get_drvdata(dev);\r\nunsigned long val;\r\nint ret;\r\nret = kstrtoul(buf, 0, &val);\r\nif (ret)\r\nreturn ret;\r\nif (mutex_lock_interruptible(&priv->lock))\r\nreturn -ERESTARTSYS;\r\nret = val ? fpga_do_program(priv) : fpga_do_stop(priv);\r\nif (ret)\r\ngoto out_unlock;\r\nret = count;\r\nout_unlock:\r\nmutex_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic bool dma_filter(struct dma_chan *chan, void *data)\r\n{\r\nreturn chan->chan_id == 0 && chan->device->dev_id == 0;\r\n}\r\nstatic int fpga_of_remove(struct platform_device *op)\r\n{\r\nstruct fpga_dev *priv = platform_get_drvdata(op);\r\nstruct device *this_device = priv->miscdev.this_device;\r\nsysfs_remove_group(&this_device->kobj, &fpga_attr_group);\r\nmisc_deregister(&priv->miscdev);\r\nfree_irq(priv->irq, priv);\r\nirq_dispose_mapping(priv->irq);\r\nfpga_disable_power_supplies(priv);\r\niounmap(priv->immr);\r\niounmap(priv->regs);\r\ndma_release_channel(priv->chan);\r\nkref_put(&priv->ref, fpga_dev_remove);\r\nreturn 0;\r\n}\r\nstatic int fpga_of_probe(struct platform_device *op)\r\n{\r\nstruct device_node *of_node = op->dev.of_node;\r\nstruct device *this_device;\r\nstruct fpga_dev *priv;\r\ndma_cap_mask_t mask;\r\nu32 ver;\r\nint ret;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&op->dev, "Unable to allocate private data\n");\r\nret = -ENOMEM;\r\ngoto out_return;\r\n}\r\npriv->miscdev.minor = MISC_DYNAMIC_MINOR;\r\npriv->miscdev.name = drv_name;\r\npriv->miscdev.fops = &fpga_fops;\r\nkref_init(&priv->ref);\r\nplatform_set_drvdata(op, priv);\r\npriv->dev = &op->dev;\r\nmutex_init(&priv->lock);\r\ninit_completion(&priv->completion);\r\ndev_set_drvdata(priv->dev, priv);\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_MEMCPY, mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndma_cap_set(DMA_SG, mask);\r\npriv->chan = dma_request_channel(mask, dma_filter, NULL);\r\nif (!priv->chan) {\r\ndev_err(&op->dev, "Unable to acquire DMA channel #0\n");\r\nret = -ENODEV;\r\ngoto out_free_priv;\r\n}\r\npriv->regs = of_iomap(of_node, 0);\r\nif (!priv->regs) {\r\ndev_err(&op->dev, "Unable to ioremap registers\n");\r\nret = -ENOMEM;\r\ngoto out_dma_release_channel;\r\n}\r\npriv->immr = ioremap(get_immrbase(), 0x100000);\r\nif (!priv->immr) {\r\ndev_err(&op->dev, "Unable to ioremap IMMR\n");\r\nret = -ENOMEM;\r\ngoto out_unmap_regs;\r\n}\r\nif ((ioread32be(priv->immr + 0x114) & 0xE00) != 0xE00) {\r\ndev_err(&op->dev, "External DMA control not configured\n");\r\nret = -ENODEV;\r\ngoto out_unmap_immr;\r\n}\r\nver = ioread8(priv->regs + CTL_CPLD_VERSION);\r\nif (ver != 0x02 && ver != 0x03) {\r\ndev_err(&op->dev, "CTL-CPLD is not version 0x02 or 0x03!\n");\r\nret = -ENODEV;\r\ngoto out_unmap_immr;\r\n}\r\nver = ioread32be(priv->regs + SYS_REG_VERSION);\r\npriv->fw_size = (ver & (1 << 18)) ? FW_SIZE_EP2S130 : FW_SIZE_EP2S90;\r\npriv->irq = irq_of_parse_and_map(of_node, 0);\r\nif (priv->irq == NO_IRQ) {\r\ndev_err(&op->dev, "Unable to find IRQ line\n");\r\nret = -ENODEV;\r\ngoto out_unmap_immr;\r\n}\r\nret = request_irq(priv->irq, fpga_irq, IRQF_SHARED, drv_name, priv);\r\nif (ret) {\r\ndev_err(&op->dev, "Unable to request IRQ %d\n", priv->irq);\r\nret = -ENODEV;\r\ngoto out_irq_dispose_mapping;\r\n}\r\nfpga_do_stop(priv);\r\nret = misc_register(&priv->miscdev);\r\nif (ret) {\r\ndev_err(&op->dev, "Unable to register miscdevice\n");\r\ngoto out_free_irq;\r\n}\r\nthis_device = priv->miscdev.this_device;\r\ndev_set_drvdata(this_device, priv);\r\nret = sysfs_create_group(&this_device->kobj, &fpga_attr_group);\r\nif (ret) {\r\ndev_err(&op->dev, "Unable to create sysfs files\n");\r\ngoto out_misc_deregister;\r\n}\r\ndev_info(priv->dev, "CARMA FPGA Programmer: %s rev%s with %s FPGAs\n",\r\n(ver & (1 << 17)) ? "Correlator" : "Digitizer",\r\n(ver & (1 << 16)) ? "B" : "A",\r\n(ver & (1 << 18)) ? "EP2S130" : "EP2S90");\r\nreturn 0;\r\nout_misc_deregister:\r\nmisc_deregister(&priv->miscdev);\r\nout_free_irq:\r\nfree_irq(priv->irq, priv);\r\nout_irq_dispose_mapping:\r\nirq_dispose_mapping(priv->irq);\r\nout_unmap_immr:\r\niounmap(priv->immr);\r\nout_unmap_regs:\r\niounmap(priv->regs);\r\nout_dma_release_channel:\r\ndma_release_channel(priv->chan);\r\nout_free_priv:\r\nkref_put(&priv->ref, fpga_dev_remove);\r\nout_return:\r\nreturn ret;\r\n}\r\nstatic int __init fpga_init(void)\r\n{\r\nled_trigger_register_simple("fpga", &ledtrig_fpga);\r\nreturn platform_driver_register(&fpga_of_driver);\r\n}\r\nstatic void __exit fpga_exit(void)\r\n{\r\nplatform_driver_unregister(&fpga_of_driver);\r\nled_trigger_unregister_simple(ledtrig_fpga);\r\n}
