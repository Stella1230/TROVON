static long\r\nhwdep_read_resp_buf(struct snd_efw *efw, char __user *buf, long remained,\r\nloff_t *offset)\r\n{\r\nunsigned int length, till_end, type;\r\nstruct snd_efw_transaction *t;\r\nlong count = 0;\r\nif (remained < sizeof(type) + sizeof(struct snd_efw_transaction))\r\nreturn -ENOSPC;\r\ntype = SNDRV_FIREWIRE_EVENT_EFW_RESPONSE;\r\nif (copy_to_user(buf, &type, sizeof(type)))\r\nreturn -EFAULT;\r\nremained -= sizeof(type);\r\nbuf += sizeof(type);\r\nwhile (efw->resp_queues > 0) {\r\nt = (struct snd_efw_transaction *)(efw->pull_ptr);\r\nlength = be32_to_cpu(t->length) * sizeof(__be32);\r\nif (remained < length)\r\nbreak;\r\nwhile (length > 0) {\r\ntill_end = snd_efw_resp_buf_size -\r\n(unsigned int)(efw->pull_ptr - efw->resp_buf);\r\ntill_end = min_t(unsigned int, length, till_end);\r\nif (copy_to_user(buf, efw->pull_ptr, till_end))\r\nreturn -EFAULT;\r\nefw->pull_ptr += till_end;\r\nif (efw->pull_ptr >= efw->resp_buf +\r\nsnd_efw_resp_buf_size)\r\nefw->pull_ptr -= snd_efw_resp_buf_size;\r\nlength -= till_end;\r\nbuf += till_end;\r\ncount += till_end;\r\nremained -= till_end;\r\n}\r\nefw->resp_queues--;\r\n}\r\nreturn count;\r\n}\r\nstatic long\r\nhwdep_read_locked(struct snd_efw *efw, char __user *buf, long count,\r\nloff_t *offset)\r\n{\r\nunion snd_firewire_event event;\r\nmemset(&event, 0, sizeof(event));\r\nevent.lock_status.type = SNDRV_FIREWIRE_EVENT_LOCK_STATUS;\r\nevent.lock_status.status = (efw->dev_lock_count > 0);\r\nefw->dev_lock_changed = false;\r\ncount = min_t(long, count, sizeof(event.lock_status));\r\nif (copy_to_user(buf, &event, count))\r\nreturn -EFAULT;\r\nreturn count;\r\n}\r\nstatic long\r\nhwdep_read(struct snd_hwdep *hwdep, char __user *buf, long count,\r\nloff_t *offset)\r\n{\r\nstruct snd_efw *efw = hwdep->private_data;\r\nDEFINE_WAIT(wait);\r\nspin_lock_irq(&efw->lock);\r\nwhile ((!efw->dev_lock_changed) && (efw->resp_queues == 0)) {\r\nprepare_to_wait(&efw->hwdep_wait, &wait, TASK_INTERRUPTIBLE);\r\nspin_unlock_irq(&efw->lock);\r\nschedule();\r\nfinish_wait(&efw->hwdep_wait, &wait);\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nspin_lock_irq(&efw->lock);\r\n}\r\nif (efw->dev_lock_changed)\r\ncount = hwdep_read_locked(efw, buf, count, offset);\r\nelse if (efw->resp_queues > 0)\r\ncount = hwdep_read_resp_buf(efw, buf, count, offset);\r\nspin_unlock_irq(&efw->lock);\r\nreturn count;\r\n}\r\nstatic long\r\nhwdep_write(struct snd_hwdep *hwdep, const char __user *data, long count,\r\nloff_t *offset)\r\n{\r\nstruct snd_efw *efw = hwdep->private_data;\r\nu32 seqnum;\r\nu8 *buf;\r\nif (count < sizeof(struct snd_efw_transaction) ||\r\nSND_EFW_RESPONSE_MAXIMUM_BYTES < count)\r\nreturn -EINVAL;\r\nbuf = memdup_user(data, count);\r\nif (IS_ERR(buf))\r\nreturn PTR_ERR(buf);\r\nseqnum = be32_to_cpu(((struct snd_efw_transaction *)buf)->seqnum);\r\nif (seqnum > SND_EFW_TRANSACTION_USER_SEQNUM_MAX) {\r\ncount = -EINVAL;\r\ngoto end;\r\n}\r\nif (snd_efw_transaction_cmd(efw->unit, buf, count) < 0)\r\ncount = -EIO;\r\nend:\r\nkfree(buf);\r\nreturn count;\r\n}\r\nstatic unsigned int\r\nhwdep_poll(struct snd_hwdep *hwdep, struct file *file, poll_table *wait)\r\n{\r\nstruct snd_efw *efw = hwdep->private_data;\r\nunsigned int events;\r\npoll_wait(file, &efw->hwdep_wait, wait);\r\nspin_lock_irq(&efw->lock);\r\nif (efw->dev_lock_changed || (efw->resp_queues > 0))\r\nevents = POLLIN | POLLRDNORM;\r\nelse\r\nevents = 0;\r\nspin_unlock_irq(&efw->lock);\r\nreturn events | POLLOUT;\r\n}\r\nstatic int\r\nhwdep_get_info(struct snd_efw *efw, void __user *arg)\r\n{\r\nstruct fw_device *dev = fw_parent_device(efw->unit);\r\nstruct snd_firewire_get_info info;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.type = SNDRV_FIREWIRE_TYPE_FIREWORKS;\r\ninfo.card = dev->card->index;\r\n*(__be32 *)&info.guid[0] = cpu_to_be32(dev->config_rom[3]);\r\n*(__be32 *)&info.guid[4] = cpu_to_be32(dev->config_rom[4]);\r\nstrlcpy(info.device_name, dev_name(&dev->device),\r\nsizeof(info.device_name));\r\nif (copy_to_user(arg, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nhwdep_lock(struct snd_efw *efw)\r\n{\r\nint err;\r\nspin_lock_irq(&efw->lock);\r\nif (efw->dev_lock_count == 0) {\r\nefw->dev_lock_count = -1;\r\nerr = 0;\r\n} else {\r\nerr = -EBUSY;\r\n}\r\nspin_unlock_irq(&efw->lock);\r\nreturn err;\r\n}\r\nstatic int\r\nhwdep_unlock(struct snd_efw *efw)\r\n{\r\nint err;\r\nspin_lock_irq(&efw->lock);\r\nif (efw->dev_lock_count == -1) {\r\nefw->dev_lock_count = 0;\r\nerr = 0;\r\n} else {\r\nerr = -EBADFD;\r\n}\r\nspin_unlock_irq(&efw->lock);\r\nreturn err;\r\n}\r\nstatic int\r\nhwdep_release(struct snd_hwdep *hwdep, struct file *file)\r\n{\r\nstruct snd_efw *efw = hwdep->private_data;\r\nspin_lock_irq(&efw->lock);\r\nif (efw->dev_lock_count == -1)\r\nefw->dev_lock_count = 0;\r\nspin_unlock_irq(&efw->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nhwdep_ioctl(struct snd_hwdep *hwdep, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct snd_efw *efw = hwdep->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_FIREWIRE_IOCTL_GET_INFO:\r\nreturn hwdep_get_info(efw, (void __user *)arg);\r\ncase SNDRV_FIREWIRE_IOCTL_LOCK:\r\nreturn hwdep_lock(efw);\r\ncase SNDRV_FIREWIRE_IOCTL_UNLOCK:\r\nreturn hwdep_unlock(efw);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic int\r\nhwdep_compat_ioctl(struct snd_hwdep *hwdep, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn hwdep_ioctl(hwdep, file, cmd,\r\n(unsigned long)compat_ptr(arg));\r\n}\r\nint snd_efw_create_hwdep_device(struct snd_efw *efw)\r\n{\r\nstruct snd_hwdep *hwdep;\r\nint err;\r\nerr = snd_hwdep_new(efw->card, "Fireworks", 0, &hwdep);\r\nif (err < 0)\r\ngoto end;\r\nstrcpy(hwdep->name, "Fireworks");\r\nhwdep->iface = SNDRV_HWDEP_IFACE_FW_FIREWORKS;\r\nhwdep->ops = hwdep_ops;\r\nhwdep->private_data = efw;\r\nhwdep->exclusive = true;\r\nend:\r\nreturn err;\r\n}
