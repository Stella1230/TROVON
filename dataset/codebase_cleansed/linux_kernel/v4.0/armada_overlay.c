static void\r\narmada_ovl_update_attr(struct armada_plane_properties *prop,\r\nstruct armada_crtc *dcrtc)\r\n{\r\nwritel_relaxed(prop->colorkey_yr, dcrtc->base + LCD_SPU_COLORKEY_Y);\r\nwritel_relaxed(prop->colorkey_ug, dcrtc->base + LCD_SPU_COLORKEY_U);\r\nwritel_relaxed(prop->colorkey_vb, dcrtc->base + LCD_SPU_COLORKEY_V);\r\nwritel_relaxed(prop->brightness << 16 | prop->contrast,\r\ndcrtc->base + LCD_SPU_CONTRAST);\r\nwritel_relaxed(prop->saturation << 16,\r\ndcrtc->base + LCD_SPU_SATURATION);\r\nwritel_relaxed(0x00002000, dcrtc->base + LCD_SPU_CBSH_HUE);\r\nspin_lock_irq(&dcrtc->irq_lock);\r\narmada_updatel(prop->colorkey_mode | CFG_ALPHAM_GRA,\r\nCFG_CKMODE_MASK | CFG_ALPHAM_MASK | CFG_ALPHA_MASK,\r\ndcrtc->base + LCD_SPU_DMA_CTRL1);\r\narmada_updatel(ADV_GRACOLORKEY, 0, dcrtc->base + LCD_SPU_ADV_REG);\r\nspin_unlock_irq(&dcrtc->irq_lock);\r\n}\r\nstatic void armada_plane_vbl(struct armada_crtc *dcrtc, void *data)\r\n{\r\nstruct armada_plane *dplane = data;\r\nstruct drm_framebuffer *fb;\r\narmada_drm_crtc_update_regs(dcrtc, dplane->vbl.regs);\r\nspin_lock(&dplane->lock);\r\nfb = dplane->old_fb;\r\ndplane->old_fb = NULL;\r\nspin_unlock(&dplane->lock);\r\nif (fb)\r\narmada_drm_queue_unref_work(dcrtc->crtc.dev, fb);\r\n}\r\nstatic unsigned armada_limit(int start, unsigned size, unsigned max)\r\n{\r\nint end = start + size;\r\nif (end < 0)\r\nreturn 0;\r\nif (start < 0)\r\nstart = 0;\r\nreturn (unsigned)end > max ? max - start : end - start;\r\n}\r\nstatic int\r\narmada_plane_update(struct drm_plane *plane, struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nint crtc_x, int crtc_y, unsigned crtc_w, unsigned crtc_h,\r\nuint32_t src_x, uint32_t src_y, uint32_t src_w, uint32_t src_h)\r\n{\r\nstruct armada_plane *dplane = drm_to_armada_plane(plane);\r\nstruct armada_crtc *dcrtc = drm_to_armada_crtc(crtc);\r\nuint32_t val, ctrl0;\r\nunsigned idx = 0;\r\nint ret;\r\ncrtc_w = armada_limit(crtc_x, crtc_w, dcrtc->crtc.mode.hdisplay);\r\ncrtc_h = armada_limit(crtc_y, crtc_h, dcrtc->crtc.mode.vdisplay);\r\nctrl0 = CFG_DMA_FMT(drm_fb_to_armada_fb(fb)->fmt) |\r\nCFG_DMA_MOD(drm_fb_to_armada_fb(fb)->mod) |\r\nCFG_CBSH_ENA | CFG_DMA_HSMOOTH | CFG_DMA_ENA;\r\nif (crtc_w == 0 || crtc_h == 0) {\r\nctrl0 &= ~CFG_DMA_ENA;\r\n}\r\nif (!dcrtc->plane) {\r\ndcrtc->plane = plane;\r\narmada_ovl_update_attr(&dplane->prop, dcrtc);\r\n}\r\nif (plane->fb == fb && dplane->ctrl0 == ctrl0) {\r\nval = (src_h & 0xffff0000) | src_w >> 16;\r\ndplane->src_hw = val;\r\nwritel_relaxed(val, dcrtc->base + LCD_SPU_DMA_HPXL_VLN);\r\nval = crtc_h << 16 | crtc_w;\r\ndplane->dst_hw = val;\r\nwritel_relaxed(val, dcrtc->base + LCD_SPU_DZM_HPXL_VLN);\r\nval = crtc_y << 16 | crtc_x;\r\ndplane->dst_yx = val;\r\nwritel_relaxed(val, dcrtc->base + LCD_SPU_DMA_OVSA_HPXL_VLN);\r\nreturn 0;\r\n} else if (~dplane->ctrl0 & ctrl0 & CFG_DMA_ENA) {\r\narmada_updatel(0, CFG_PDWN16x66 | CFG_PDWN32x66,\r\ndcrtc->base + LCD_SPU_SRAM_PARA1);\r\n}\r\nret = wait_event_timeout(dplane->vbl.wait,\r\nlist_empty(&dplane->vbl.update.node),\r\nHZ/25);\r\nif (ret < 0)\r\nreturn ret;\r\nif (plane->fb != fb) {\r\nstruct armada_gem_object *obj = drm_fb_obj(fb);\r\nuint32_t sy, su, sv;\r\ndrm_framebuffer_reference(fb);\r\nif (plane->fb) {\r\nstruct drm_framebuffer *older_fb;\r\nspin_lock_irq(&dplane->lock);\r\nolder_fb = dplane->old_fb;\r\ndplane->old_fb = plane->fb;\r\nspin_unlock_irq(&dplane->lock);\r\nif (older_fb)\r\narmada_drm_queue_unref_work(dcrtc->crtc.dev,\r\nolder_fb);\r\n}\r\nsrc_y >>= 16;\r\nsrc_x >>= 16;\r\nsy = obj->dev_addr + fb->offsets[0] + src_y * fb->pitches[0] +\r\nsrc_x * fb->bits_per_pixel / 8;\r\nsu = obj->dev_addr + fb->offsets[1] + src_y * fb->pitches[1] +\r\nsrc_x;\r\nsv = obj->dev_addr + fb->offsets[2] + src_y * fb->pitches[2] +\r\nsrc_x;\r\narmada_reg_queue_set(dplane->vbl.regs, idx, sy,\r\nLCD_SPU_DMA_START_ADDR_Y0);\r\narmada_reg_queue_set(dplane->vbl.regs, idx, su,\r\nLCD_SPU_DMA_START_ADDR_U0);\r\narmada_reg_queue_set(dplane->vbl.regs, idx, sv,\r\nLCD_SPU_DMA_START_ADDR_V0);\r\narmada_reg_queue_set(dplane->vbl.regs, idx, sy,\r\nLCD_SPU_DMA_START_ADDR_Y1);\r\narmada_reg_queue_set(dplane->vbl.regs, idx, su,\r\nLCD_SPU_DMA_START_ADDR_U1);\r\narmada_reg_queue_set(dplane->vbl.regs, idx, sv,\r\nLCD_SPU_DMA_START_ADDR_V1);\r\nval = fb->pitches[0] << 16 | fb->pitches[0];\r\narmada_reg_queue_set(dplane->vbl.regs, idx, val,\r\nLCD_SPU_DMA_PITCH_YC);\r\nval = fb->pitches[1] << 16 | fb->pitches[2];\r\narmada_reg_queue_set(dplane->vbl.regs, idx, val,\r\nLCD_SPU_DMA_PITCH_UV);\r\n}\r\nval = (src_h & 0xffff0000) | src_w >> 16;\r\nif (dplane->src_hw != val) {\r\ndplane->src_hw = val;\r\narmada_reg_queue_set(dplane->vbl.regs, idx, val,\r\nLCD_SPU_DMA_HPXL_VLN);\r\n}\r\nval = crtc_h << 16 | crtc_w;\r\nif (dplane->dst_hw != val) {\r\ndplane->dst_hw = val;\r\narmada_reg_queue_set(dplane->vbl.regs, idx, val,\r\nLCD_SPU_DZM_HPXL_VLN);\r\n}\r\nval = crtc_y << 16 | crtc_x;\r\nif (dplane->dst_yx != val) {\r\ndplane->dst_yx = val;\r\narmada_reg_queue_set(dplane->vbl.regs, idx, val,\r\nLCD_SPU_DMA_OVSA_HPXL_VLN);\r\n}\r\nif (dplane->ctrl0 != ctrl0) {\r\ndplane->ctrl0 = ctrl0;\r\narmada_reg_queue_mod(dplane->vbl.regs, idx, ctrl0,\r\nCFG_CBSH_ENA | CFG_DMAFORMAT | CFG_DMA_FTOGGLE |\r\nCFG_DMA_HSMOOTH | CFG_DMA_TSTMODE |\r\nCFG_DMA_MOD(CFG_SWAPRB | CFG_SWAPUV | CFG_SWAPYU |\r\nCFG_YUV2RGB) | CFG_DMA_ENA,\r\nLCD_SPU_DMA_CTRL0);\r\n}\r\nif (idx) {\r\narmada_reg_queue_end(dplane->vbl.regs, idx);\r\narmada_drm_vbl_event_add(dcrtc, &dplane->vbl.update);\r\n}\r\nreturn 0;\r\n}\r\nstatic int armada_plane_disable(struct drm_plane *plane)\r\n{\r\nstruct armada_plane *dplane = drm_to_armada_plane(plane);\r\nstruct drm_framebuffer *fb;\r\nstruct armada_crtc *dcrtc;\r\nif (!dplane->base.crtc)\r\nreturn 0;\r\ndcrtc = drm_to_armada_crtc(dplane->base.crtc);\r\ndcrtc->plane = NULL;\r\nspin_lock_irq(&dcrtc->irq_lock);\r\narmada_drm_vbl_event_remove(dcrtc, &dplane->vbl.update);\r\narmada_updatel(0, CFG_DMA_ENA, dcrtc->base + LCD_SPU_DMA_CTRL0);\r\ndplane->ctrl0 = 0;\r\nspin_unlock_irq(&dcrtc->irq_lock);\r\narmada_updatel(CFG_PDWN16x66 | CFG_PDWN32x66, 0,\r\ndcrtc->base + LCD_SPU_SRAM_PARA1);\r\nif (plane->fb)\r\ndrm_framebuffer_unreference(plane->fb);\r\nspin_lock_irq(&dplane->lock);\r\nfb = dplane->old_fb;\r\ndplane->old_fb = NULL;\r\nspin_unlock_irq(&dplane->lock);\r\nif (fb)\r\ndrm_framebuffer_unreference(fb);\r\nreturn 0;\r\n}\r\nstatic void armada_plane_destroy(struct drm_plane *plane)\r\n{\r\nkfree(plane);\r\n}\r\nstatic int armada_plane_set_property(struct drm_plane *plane,\r\nstruct drm_property *property, uint64_t val)\r\n{\r\nstruct armada_private *priv = plane->dev->dev_private;\r\nstruct armada_plane *dplane = drm_to_armada_plane(plane);\r\nbool update_attr = false;\r\nif (property == priv->colorkey_prop) {\r\n#define CCC(v) ((v) << 24 | (v) << 16 | (v) << 8)\r\ndplane->prop.colorkey_yr = CCC(K2R(val));\r\ndplane->prop.colorkey_ug = CCC(K2G(val));\r\ndplane->prop.colorkey_vb = CCC(K2B(val));\r\n#undef CCC\r\nupdate_attr = true;\r\n} else if (property == priv->colorkey_min_prop) {\r\ndplane->prop.colorkey_yr &= ~0x00ff0000;\r\ndplane->prop.colorkey_yr |= K2R(val) << 16;\r\ndplane->prop.colorkey_ug &= ~0x00ff0000;\r\ndplane->prop.colorkey_ug |= K2G(val) << 16;\r\ndplane->prop.colorkey_vb &= ~0x00ff0000;\r\ndplane->prop.colorkey_vb |= K2B(val) << 16;\r\nupdate_attr = true;\r\n} else if (property == priv->colorkey_max_prop) {\r\ndplane->prop.colorkey_yr &= ~0xff000000;\r\ndplane->prop.colorkey_yr |= K2R(val) << 24;\r\ndplane->prop.colorkey_ug &= ~0xff000000;\r\ndplane->prop.colorkey_ug |= K2G(val) << 24;\r\ndplane->prop.colorkey_vb &= ~0xff000000;\r\ndplane->prop.colorkey_vb |= K2B(val) << 24;\r\nupdate_attr = true;\r\n} else if (property == priv->colorkey_val_prop) {\r\ndplane->prop.colorkey_yr &= ~0x0000ff00;\r\ndplane->prop.colorkey_yr |= K2R(val) << 8;\r\ndplane->prop.colorkey_ug &= ~0x0000ff00;\r\ndplane->prop.colorkey_ug |= K2G(val) << 8;\r\ndplane->prop.colorkey_vb &= ~0x0000ff00;\r\ndplane->prop.colorkey_vb |= K2B(val) << 8;\r\nupdate_attr = true;\r\n} else if (property == priv->colorkey_alpha_prop) {\r\ndplane->prop.colorkey_yr &= ~0x000000ff;\r\ndplane->prop.colorkey_yr |= K2R(val);\r\ndplane->prop.colorkey_ug &= ~0x000000ff;\r\ndplane->prop.colorkey_ug |= K2G(val);\r\ndplane->prop.colorkey_vb &= ~0x000000ff;\r\ndplane->prop.colorkey_vb |= K2B(val);\r\nupdate_attr = true;\r\n} else if (property == priv->colorkey_mode_prop) {\r\ndplane->prop.colorkey_mode &= ~CFG_CKMODE_MASK;\r\ndplane->prop.colorkey_mode |= CFG_CKMODE(val);\r\nupdate_attr = true;\r\n} else if (property == priv->brightness_prop) {\r\ndplane->prop.brightness = val - 256;\r\nupdate_attr = true;\r\n} else if (property == priv->contrast_prop) {\r\ndplane->prop.contrast = val;\r\nupdate_attr = true;\r\n} else if (property == priv->saturation_prop) {\r\ndplane->prop.saturation = val;\r\nupdate_attr = true;\r\n}\r\nif (update_attr && dplane->base.crtc)\r\narmada_ovl_update_attr(&dplane->prop,\r\ndrm_to_armada_crtc(dplane->base.crtc));\r\nreturn 0;\r\n}\r\nstatic int armada_overlay_create_properties(struct drm_device *dev)\r\n{\r\nstruct armada_private *priv = dev->dev_private;\r\nif (priv->colorkey_prop)\r\nreturn 0;\r\npriv->colorkey_prop = drm_property_create_range(dev, 0,\r\n"colorkey", 0, 0xffffff);\r\npriv->colorkey_min_prop = drm_property_create_range(dev, 0,\r\n"colorkey_min", 0, 0xffffff);\r\npriv->colorkey_max_prop = drm_property_create_range(dev, 0,\r\n"colorkey_max", 0, 0xffffff);\r\npriv->colorkey_val_prop = drm_property_create_range(dev, 0,\r\n"colorkey_val", 0, 0xffffff);\r\npriv->colorkey_alpha_prop = drm_property_create_range(dev, 0,\r\n"colorkey_alpha", 0, 0xffffff);\r\npriv->colorkey_mode_prop = drm_property_create_enum(dev, 0,\r\n"colorkey_mode",\r\narmada_drm_colorkey_enum_list,\r\nARRAY_SIZE(armada_drm_colorkey_enum_list));\r\npriv->brightness_prop = drm_property_create_range(dev, 0,\r\n"brightness", 0, 256 + 255);\r\npriv->contrast_prop = drm_property_create_range(dev, 0,\r\n"contrast", 0, 0x7fff);\r\npriv->saturation_prop = drm_property_create_range(dev, 0,\r\n"saturation", 0, 0x7fff);\r\nif (!priv->colorkey_prop)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint armada_overlay_plane_create(struct drm_device *dev, unsigned long crtcs)\r\n{\r\nstruct armada_private *priv = dev->dev_private;\r\nstruct drm_mode_object *mobj;\r\nstruct armada_plane *dplane;\r\nint ret;\r\nret = armada_overlay_create_properties(dev);\r\nif (ret)\r\nreturn ret;\r\ndplane = kzalloc(sizeof(*dplane), GFP_KERNEL);\r\nif (!dplane)\r\nreturn -ENOMEM;\r\nspin_lock_init(&dplane->lock);\r\ninit_waitqueue_head(&dplane->vbl.wait);\r\narmada_drm_vbl_event_init(&dplane->vbl.update, armada_plane_vbl,\r\ndplane);\r\ndrm_plane_init(dev, &dplane->base, crtcs, &armada_plane_funcs,\r\narmada_formats, ARRAY_SIZE(armada_formats), false);\r\ndplane->prop.colorkey_yr = 0xfefefe00;\r\ndplane->prop.colorkey_ug = 0x01010100;\r\ndplane->prop.colorkey_vb = 0x01010100;\r\ndplane->prop.colorkey_mode = CFG_CKMODE(CKMODE_RGB);\r\ndplane->prop.brightness = 0;\r\ndplane->prop.contrast = 0x4000;\r\ndplane->prop.saturation = 0x4000;\r\nmobj = &dplane->base.base;\r\ndrm_object_attach_property(mobj, priv->colorkey_prop,\r\n0x0101fe);\r\ndrm_object_attach_property(mobj, priv->colorkey_min_prop,\r\n0x0101fe);\r\ndrm_object_attach_property(mobj, priv->colorkey_max_prop,\r\n0x0101fe);\r\ndrm_object_attach_property(mobj, priv->colorkey_val_prop,\r\n0x0101fe);\r\ndrm_object_attach_property(mobj, priv->colorkey_alpha_prop,\r\n0x000000);\r\ndrm_object_attach_property(mobj, priv->colorkey_mode_prop,\r\nCKMODE_RGB);\r\ndrm_object_attach_property(mobj, priv->brightness_prop, 256);\r\ndrm_object_attach_property(mobj, priv->contrast_prop,\r\ndplane->prop.contrast);\r\ndrm_object_attach_property(mobj, priv->saturation_prop,\r\ndplane->prop.saturation);\r\nreturn 0;\r\n}
