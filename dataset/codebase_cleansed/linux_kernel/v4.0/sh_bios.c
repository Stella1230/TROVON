static inline long sh_bios_call(long func, long arg0, long arg1, long arg2,\r\nlong arg3)\r\n{\r\nregister long r0 __asm__("r0") = func;\r\nregister long r4 __asm__("r4") = arg0;\r\nregister long r5 __asm__("r5") = arg1;\r\nregister long r6 __asm__("r6") = arg2;\r\nregister long r7 __asm__("r7") = arg3;\r\nif (!gdb_vbr_vector)\r\nreturn -ENOSYS;\r\n__asm__ __volatile__("trapa #0x3f":"=z"(r0)\r\n:"0"(r0), "r"(r4), "r"(r5), "r"(r6), "r"(r7)\r\n:"memory");\r\nreturn r0;\r\n}\r\nvoid sh_bios_console_write(const char *buf, unsigned int len)\r\n{\r\nsh_bios_call(BIOS_CALL_CONSOLE_WRITE, (long)buf, (long)len, 0, 0);\r\n}\r\nvoid sh_bios_gdb_detach(void)\r\n{\r\nsh_bios_call(BIOS_CALL_GDB_DETACH, 0, 0, 0, 0);\r\n}\r\nvoid sh_bios_get_node_addr(unsigned char *node_addr)\r\n{\r\nsh_bios_call(BIOS_CALL_ETH_NODE_ADDR, 0, (long)node_addr, 0, 0);\r\n}\r\nvoid sh_bios_shutdown(unsigned int how)\r\n{\r\nsh_bios_call(BIOS_CALL_SHUTDOWN, how, 0, 0, 0);\r\n}\r\nvoid sh_bios_vbr_init(void)\r\n{\r\nunsigned long vbr;\r\nif (unlikely(gdb_vbr_vector))\r\nreturn;\r\n__asm__ __volatile__ ("stc vbr, %0" : "=r" (vbr));\r\nif (vbr) {\r\ngdb_vbr_vector = (void *)(vbr + 0x100);\r\nprintk(KERN_NOTICE "Setting GDB trap vector to %p\n",\r\ngdb_vbr_vector);\r\n} else\r\nprintk(KERN_NOTICE "SH-BIOS not detected\n");\r\n}\r\nvoid sh_bios_vbr_reload(void)\r\n{\r\nif (gdb_vbr_vector)\r\n__asm__ __volatile__ (\r\n"ldc %0, vbr"\r\n:\r\n: "r" (((unsigned long) gdb_vbr_vector) - 0x100)\r\n: "memory"\r\n);\r\n}\r\nstatic void sh_console_write(struct console *co, const char *s,\r\nunsigned count)\r\n{\r\nsh_bios_console_write(s, count);\r\n}\r\nstatic int __init sh_console_setup(struct console *co, char *options)\r\n{\r\nint cflag = CREAD | HUPCL | CLOCAL;\r\ncflag |= B115200 | CS8 | 0;\r\nco->cflag = cflag;\r\nreturn 0;\r\n}\r\nstatic int __init setup_early_printk(char *buf)\r\n{\r\nint keep_early = 0;\r\nif (!buf)\r\nreturn 0;\r\nif (strstr(buf, "keep"))\r\nkeep_early = 1;\r\nif (!strncmp(buf, "bios", 4))\r\nearly_console = &bios_console;\r\nif (likely(early_console)) {\r\nif (keep_early)\r\nearly_console->flags &= ~CON_BOOT;\r\nelse\r\nearly_console->flags |= CON_BOOT;\r\nregister_console(early_console);\r\n}\r\nreturn 0;\r\n}
