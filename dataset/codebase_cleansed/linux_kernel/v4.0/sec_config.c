const char *sptlrpc_part2name(enum lustre_sec_part part)\r\n{\r\nswitch (part) {\r\ncase LUSTRE_SP_CLI:\r\nreturn "cli";\r\ncase LUSTRE_SP_MDT:\r\nreturn "mdt";\r\ncase LUSTRE_SP_OST:\r\nreturn "ost";\r\ncase LUSTRE_SP_MGC:\r\nreturn "mgc";\r\ncase LUSTRE_SP_MGS:\r\nreturn "mgs";\r\ncase LUSTRE_SP_ANY:\r\nreturn "any";\r\ndefault:\r\nreturn "err";\r\n}\r\n}\r\nenum lustre_sec_part sptlrpc_target_sec_part(struct obd_device *obd)\r\n{\r\nconst char *type = obd->obd_type->typ_name;\r\nif (!strcmp(type, LUSTRE_MDT_NAME))\r\nreturn LUSTRE_SP_MDT;\r\nif (!strcmp(type, LUSTRE_OST_NAME))\r\nreturn LUSTRE_SP_OST;\r\nif (!strcmp(type, LUSTRE_MGS_NAME))\r\nreturn LUSTRE_SP_MGS;\r\nCERROR("unknown target %p(%s)\n", obd, type);\r\nreturn LUSTRE_SP_ANY;\r\n}\r\nint sptlrpc_parse_flavor(const char *str, struct sptlrpc_flavor *flvr)\r\n{\r\nchar buf[32];\r\nchar *bulk, *alg;\r\nmemset(flvr, 0, sizeof(*flvr));\r\nif (str == NULL || str[0] == '\0') {\r\nflvr->sf_rpc = SPTLRPC_FLVR_INVALID;\r\nreturn 0;\r\n}\r\nstrncpy(buf, str, sizeof(buf));\r\nbuf[sizeof(buf) - 1] = '\0';\r\nbulk = strchr(buf, '-');\r\nif (bulk)\r\n*bulk++ = '\0';\r\nflvr->sf_rpc = sptlrpc_name2flavor_base(buf);\r\nif (flvr->sf_rpc == SPTLRPC_FLVR_INVALID)\r\ngoto err_out;\r\nif (flvr->sf_rpc == SPTLRPC_FLVR_PLAIN) {\r\nflvr->u_bulk.hash.hash_alg = BULK_HASH_ALG_ADLER32;\r\nif (bulk) {\r\nalg = strchr(bulk, ':');\r\nif (alg == NULL)\r\ngoto err_out;\r\n*alg++ = '\0';\r\nif (strcmp(bulk, "hash"))\r\ngoto err_out;\r\nflvr->u_bulk.hash.hash_alg = sptlrpc_get_hash_alg(alg);\r\nif (flvr->u_bulk.hash.hash_alg >= BULK_HASH_ALG_MAX)\r\ngoto err_out;\r\n}\r\nif (flvr->u_bulk.hash.hash_alg == BULK_HASH_ALG_NULL)\r\nflvr_set_bulk_svc(&flvr->sf_rpc, SPTLRPC_BULK_SVC_NULL);\r\nelse\r\nflvr_set_bulk_svc(&flvr->sf_rpc, SPTLRPC_BULK_SVC_INTG);\r\n} else {\r\nif (bulk)\r\ngoto err_out;\r\n}\r\nflvr->sf_flags = 0;\r\nreturn 0;\r\nerr_out:\r\nCERROR("invalid flavor string: %s\n", str);\r\nreturn -EINVAL;\r\n}\r\nstatic void get_default_flavor(struct sptlrpc_flavor *sf)\r\n{\r\nmemset(sf, 0, sizeof(*sf));\r\nsf->sf_rpc = SPTLRPC_FLVR_NULL;\r\nsf->sf_flags = 0;\r\n}\r\nstatic void sptlrpc_rule_init(struct sptlrpc_rule *rule)\r\n{\r\nrule->sr_netid = LNET_NIDNET(LNET_NID_ANY);\r\nrule->sr_from = LUSTRE_SP_ANY;\r\nrule->sr_to = LUSTRE_SP_ANY;\r\nrule->sr_padding = 0;\r\nget_default_flavor(&rule->sr_flvr);\r\n}\r\nint sptlrpc_parse_rule(char *param, struct sptlrpc_rule *rule)\r\n{\r\nchar *flavor, *dir;\r\nint rc;\r\nsptlrpc_rule_init(rule);\r\nflavor = strchr(param, '=');\r\nif (flavor == NULL) {\r\nCERROR("invalid param, no '='\n");\r\nreturn -EINVAL;\r\n}\r\n*flavor++ = '\0';\r\ndir = strchr(param, '.');\r\nif (dir)\r\n*dir++ = '\0';\r\nif (strcmp(param, "default")) {\r\nrule->sr_netid = libcfs_str2net(param);\r\nif (rule->sr_netid == LNET_NIDNET(LNET_NID_ANY)) {\r\nCERROR("invalid network name: %s\n", param);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (dir) {\r\nif (!strcmp(dir, "mdt2ost")) {\r\nrule->sr_from = LUSTRE_SP_MDT;\r\nrule->sr_to = LUSTRE_SP_OST;\r\n} else if (!strcmp(dir, "mdt2mdt")) {\r\nrule->sr_from = LUSTRE_SP_MDT;\r\nrule->sr_to = LUSTRE_SP_MDT;\r\n} else if (!strcmp(dir, "cli2ost")) {\r\nrule->sr_from = LUSTRE_SP_CLI;\r\nrule->sr_to = LUSTRE_SP_OST;\r\n} else if (!strcmp(dir, "cli2mdt")) {\r\nrule->sr_from = LUSTRE_SP_CLI;\r\nrule->sr_to = LUSTRE_SP_MDT;\r\n} else {\r\nCERROR("invalid rule dir segment: %s\n", dir);\r\nreturn -EINVAL;\r\n}\r\n}\r\nrc = sptlrpc_parse_flavor(flavor, &rule->sr_flvr);\r\nif (rc)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nvoid sptlrpc_rule_set_free(struct sptlrpc_rule_set *rset)\r\n{\r\nLASSERT(rset->srs_nslot ||\r\n(rset->srs_nrule == 0 && rset->srs_rules == NULL));\r\nif (rset->srs_nslot) {\r\nOBD_FREE(rset->srs_rules,\r\nrset->srs_nslot * sizeof(*rset->srs_rules));\r\nsptlrpc_rule_set_init(rset);\r\n}\r\n}\r\nint sptlrpc_rule_set_expand(struct sptlrpc_rule_set *rset)\r\n{\r\nstruct sptlrpc_rule *rules;\r\nint nslot;\r\nmight_sleep();\r\nif (rset->srs_nrule < rset->srs_nslot)\r\nreturn 0;\r\nnslot = rset->srs_nslot + 8;\r\nOBD_ALLOC(rules, nslot * sizeof(*rset->srs_rules));\r\nif (rules == NULL)\r\nreturn -ENOMEM;\r\nif (rset->srs_nrule) {\r\nLASSERT(rset->srs_nslot && rset->srs_rules);\r\nmemcpy(rules, rset->srs_rules,\r\nrset->srs_nrule * sizeof(*rset->srs_rules));\r\nOBD_FREE(rset->srs_rules,\r\nrset->srs_nslot * sizeof(*rset->srs_rules));\r\n}\r\nrset->srs_rules = rules;\r\nrset->srs_nslot = nslot;\r\nreturn 0;\r\n}\r\nstatic inline int rule_spec_dir(struct sptlrpc_rule *rule)\r\n{\r\nreturn (rule->sr_from != LUSTRE_SP_ANY ||\r\nrule->sr_to != LUSTRE_SP_ANY);\r\n}\r\nstatic inline int rule_spec_net(struct sptlrpc_rule *rule)\r\n{\r\nreturn (rule->sr_netid != LNET_NIDNET(LNET_NID_ANY));\r\n}\r\nstatic inline int rule_match_dir(struct sptlrpc_rule *r1,\r\nstruct sptlrpc_rule *r2)\r\n{\r\nreturn (r1->sr_from == r2->sr_from && r1->sr_to == r2->sr_to);\r\n}\r\nstatic inline int rule_match_net(struct sptlrpc_rule *r1,\r\nstruct sptlrpc_rule *r2)\r\n{\r\nreturn (r1->sr_netid == r2->sr_netid);\r\n}\r\nint sptlrpc_rule_set_merge(struct sptlrpc_rule_set *rset,\r\nstruct sptlrpc_rule *rule)\r\n{\r\nstruct sptlrpc_rule *p = rset->srs_rules;\r\nint spec_dir, spec_net;\r\nint rc, n, match = 0;\r\nmight_sleep();\r\nspec_net = rule_spec_net(rule);\r\nspec_dir = rule_spec_dir(rule);\r\nfor (n = 0; n < rset->srs_nrule; n++) {\r\np = &rset->srs_rules[n];\r\nif (!rule_match_net(p, rule)) {\r\nif (spec_net) {\r\nif (rule_spec_net(p))\r\ncontinue;\r\nelse\r\nbreak;\r\n} else {\r\ncontinue;\r\n}\r\n}\r\nif (!rule_match_dir(p, rule)) {\r\nif (spec_dir) {\r\nif (rule_spec_dir(p))\r\ncontinue;\r\nelse\r\nbreak;\r\n} else {\r\ncontinue;\r\n}\r\n}\r\nmatch = 1;\r\nbreak;\r\n}\r\nif (match) {\r\nLASSERT(n >= 0 && n < rset->srs_nrule);\r\nif (rule->sr_flvr.sf_rpc == SPTLRPC_FLVR_INVALID) {\r\nif (n < rset->srs_nrule - 1)\r\nmemmove(&rset->srs_rules[n],\r\n&rset->srs_rules[n + 1],\r\n(rset->srs_nrule - n - 1) *\r\nsizeof(*rule));\r\nrset->srs_nrule--;\r\n} else {\r\nmemcpy(&rset->srs_rules[n], rule, sizeof(*rule));\r\n}\r\n} else {\r\nLASSERT(n >= 0 && n <= rset->srs_nrule);\r\nif (rule->sr_flvr.sf_rpc != SPTLRPC_FLVR_INVALID) {\r\nrc = sptlrpc_rule_set_expand(rset);\r\nif (rc)\r\nreturn rc;\r\nif (n < rset->srs_nrule)\r\nmemmove(&rset->srs_rules[n + 1],\r\n&rset->srs_rules[n],\r\n(rset->srs_nrule - n) * sizeof(*rule));\r\nmemcpy(&rset->srs_rules[n], rule, sizeof(*rule));\r\nrset->srs_nrule++;\r\n} else {\r\nCDEBUG(D_CONFIG, "ignore the unmatched deletion\n");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint sptlrpc_rule_set_choose(struct sptlrpc_rule_set *rset,\r\nenum lustre_sec_part from,\r\nenum lustre_sec_part to,\r\nlnet_nid_t nid,\r\nstruct sptlrpc_flavor *sf)\r\n{\r\nstruct sptlrpc_rule *r;\r\nint n;\r\nfor (n = 0; n < rset->srs_nrule; n++) {\r\nr = &rset->srs_rules[n];\r\nif (LNET_NIDNET(nid) != LNET_NIDNET(LNET_NID_ANY) &&\r\nr->sr_netid != LNET_NIDNET(LNET_NID_ANY) &&\r\nLNET_NIDNET(nid) != r->sr_netid)\r\ncontinue;\r\nif (from != LUSTRE_SP_ANY && r->sr_from != LUSTRE_SP_ANY &&\r\nfrom != r->sr_from)\r\ncontinue;\r\nif (to != LUSTRE_SP_ANY && r->sr_to != LUSTRE_SP_ANY &&\r\nto != r->sr_to)\r\ncontinue;\r\n*sf = r->sr_flvr;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid sptlrpc_rule_set_dump(struct sptlrpc_rule_set *rset)\r\n{\r\nstruct sptlrpc_rule *r;\r\nint n;\r\nfor (n = 0; n < rset->srs_nrule; n++) {\r\nr = &rset->srs_rules[n];\r\nCDEBUG(D_SEC, "<%02d> from %x to %x, net %x, rpc %x\n", n,\r\nr->sr_from, r->sr_to, r->sr_netid, r->sr_flvr.sf_rpc);\r\n}\r\n}\r\nstatic inline int is_hex(char c)\r\n{\r\nreturn ((c >= '0' && c <= '9') ||\r\n(c >= 'a' && c <= 'f'));\r\n}\r\nstatic void target2fsname(const char *tgt, char *fsname, int buflen)\r\n{\r\nconst char *ptr;\r\nint len;\r\nptr = strrchr(tgt, '-');\r\nif (ptr) {\r\nif ((strncmp(ptr, "-MDT", 4) != 0 &&\r\nstrncmp(ptr, "-OST", 4) != 0) ||\r\n!is_hex(ptr[4]) || !is_hex(ptr[5]) ||\r\n!is_hex(ptr[6]) || !is_hex(ptr[7]))\r\nptr = NULL;\r\n}\r\nif (ptr == NULL)\r\nlen = strlen(tgt);\r\nelse\r\nlen = ptr - tgt;\r\nlen = min(len, buflen - 1);\r\nmemcpy(fsname, tgt, len);\r\nfsname[len] = '\0';\r\n}\r\nstatic void sptlrpc_conf_free_rsets(struct sptlrpc_conf *conf)\r\n{\r\nstruct sptlrpc_conf_tgt *conf_tgt, *conf_tgt_next;\r\nsptlrpc_rule_set_free(&conf->sc_rset);\r\nlist_for_each_entry_safe(conf_tgt, conf_tgt_next,\r\n&conf->sc_tgts, sct_list) {\r\nsptlrpc_rule_set_free(&conf_tgt->sct_rset);\r\nlist_del(&conf_tgt->sct_list);\r\nOBD_FREE_PTR(conf_tgt);\r\n}\r\nLASSERT(list_empty(&conf->sc_tgts));\r\nconf->sc_updated = 0;\r\nconf->sc_local = 0;\r\n}\r\nstatic void sptlrpc_conf_free(struct sptlrpc_conf *conf)\r\n{\r\nCDEBUG(D_SEC, "free sptlrpc conf %s\n", conf->sc_fsname);\r\nsptlrpc_conf_free_rsets(conf);\r\nlist_del(&conf->sc_list);\r\nOBD_FREE_PTR(conf);\r\n}\r\nstatic\r\nstruct sptlrpc_conf_tgt *sptlrpc_conf_get_tgt(struct sptlrpc_conf *conf,\r\nconst char *name,\r\nint create)\r\n{\r\nstruct sptlrpc_conf_tgt *conf_tgt;\r\nlist_for_each_entry(conf_tgt, &conf->sc_tgts, sct_list) {\r\nif (strcmp(conf_tgt->sct_name, name) == 0)\r\nreturn conf_tgt;\r\n}\r\nif (!create)\r\nreturn NULL;\r\nOBD_ALLOC_PTR(conf_tgt);\r\nif (conf_tgt) {\r\nstrlcpy(conf_tgt->sct_name, name, sizeof(conf_tgt->sct_name));\r\nsptlrpc_rule_set_init(&conf_tgt->sct_rset);\r\nlist_add(&conf_tgt->sct_list, &conf->sc_tgts);\r\n}\r\nreturn conf_tgt;\r\n}\r\nstatic\r\nstruct sptlrpc_conf *sptlrpc_conf_get(const char *fsname,\r\nint create)\r\n{\r\nstruct sptlrpc_conf *conf;\r\nlist_for_each_entry(conf, &sptlrpc_confs, sc_list) {\r\nif (strcmp(conf->sc_fsname, fsname) == 0)\r\nreturn conf;\r\n}\r\nif (!create)\r\nreturn NULL;\r\nOBD_ALLOC_PTR(conf);\r\nif (conf == NULL)\r\nreturn NULL;\r\nstrcpy(conf->sc_fsname, fsname);\r\nsptlrpc_rule_set_init(&conf->sc_rset);\r\nINIT_LIST_HEAD(&conf->sc_tgts);\r\nlist_add(&conf->sc_list, &sptlrpc_confs);\r\nCDEBUG(D_SEC, "create sptlrpc conf %s\n", conf->sc_fsname);\r\nreturn conf;\r\n}\r\nstatic int sptlrpc_conf_merge_rule(struct sptlrpc_conf *conf,\r\nconst char *target,\r\nstruct sptlrpc_rule *rule)\r\n{\r\nstruct sptlrpc_conf_tgt *conf_tgt;\r\nstruct sptlrpc_rule_set *rule_set;\r\nif (strcmp(conf->sc_fsname, target) == 0) {\r\nrule_set = &conf->sc_rset;\r\n} else {\r\nconf_tgt = sptlrpc_conf_get_tgt(conf, target, 1);\r\nif (conf_tgt) {\r\nrule_set = &conf_tgt->sct_rset;\r\n} else {\r\nCERROR("out of memory, can't merge rule!\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn sptlrpc_rule_set_merge(rule_set, rule);\r\n}\r\nstatic int __sptlrpc_process_config(struct lustre_cfg *lcfg,\r\nstruct sptlrpc_conf *conf)\r\n{\r\nchar *target, *param;\r\nchar fsname[MTI_NAME_MAXLEN];\r\nstruct sptlrpc_rule rule;\r\nint rc;\r\ntarget = lustre_cfg_string(lcfg, 1);\r\nif (target == NULL) {\r\nCERROR("missing target name\n");\r\nreturn -EINVAL;\r\n}\r\nparam = lustre_cfg_string(lcfg, 2);\r\nif (param == NULL) {\r\nCERROR("missing parameter\n");\r\nreturn -EINVAL;\r\n}\r\nCDEBUG(D_SEC, "processing rule: %s.%s\n", target, param);\r\nif (strncmp(param, PARAM_SRPC_FLVR, sizeof(PARAM_SRPC_FLVR) - 1) != 0) {\r\nCERROR("Invalid sptlrpc parameter: %s\n", param);\r\nreturn -EINVAL;\r\n}\r\nparam += sizeof(PARAM_SRPC_FLVR) - 1;\r\nrc = sptlrpc_parse_rule(param, &rule);\r\nif (rc)\r\nreturn -EINVAL;\r\nif (conf == NULL) {\r\ntarget2fsname(target, fsname, sizeof(fsname));\r\nmutex_lock(&sptlrpc_conf_lock);\r\nconf = sptlrpc_conf_get(fsname, 0);\r\nif (conf == NULL) {\r\nCERROR("can't find conf\n");\r\nrc = -ENOMEM;\r\n} else {\r\nrc = sptlrpc_conf_merge_rule(conf, target, &rule);\r\n}\r\nmutex_unlock(&sptlrpc_conf_lock);\r\n} else {\r\nLASSERT(mutex_is_locked(&sptlrpc_conf_lock));\r\nrc = sptlrpc_conf_merge_rule(conf, target, &rule);\r\n}\r\nif (rc == 0)\r\nconf->sc_modified++;\r\nreturn rc;\r\n}\r\nint sptlrpc_process_config(struct lustre_cfg *lcfg)\r\n{\r\nreturn __sptlrpc_process_config(lcfg, NULL);\r\n}\r\nstatic int logname2fsname(const char *logname, char *buf, int buflen)\r\n{\r\nchar *ptr;\r\nint len;\r\nptr = strrchr(logname, '-');\r\nif (ptr == NULL || strcmp(ptr, "-sptlrpc")) {\r\nCERROR("%s is not a sptlrpc config log\n", logname);\r\nreturn -EINVAL;\r\n}\r\nlen = min((int) (ptr - logname), buflen - 1);\r\nmemcpy(buf, logname, len);\r\nbuf[len] = '\0';\r\nreturn 0;\r\n}\r\nvoid sptlrpc_conf_log_update_begin(const char *logname)\r\n{\r\nstruct sptlrpc_conf *conf;\r\nchar fsname[16];\r\nif (logname2fsname(logname, fsname, sizeof(fsname)))\r\nreturn;\r\nmutex_lock(&sptlrpc_conf_lock);\r\nconf = sptlrpc_conf_get(fsname, 0);\r\nif (conf) {\r\nif (conf->sc_local) {\r\nLASSERT(conf->sc_updated == 0);\r\nsptlrpc_conf_free_rsets(conf);\r\n}\r\nconf->sc_modified = 0;\r\n}\r\nmutex_unlock(&sptlrpc_conf_lock);\r\n}\r\nvoid sptlrpc_conf_log_update_end(const char *logname)\r\n{\r\nstruct sptlrpc_conf *conf;\r\nchar fsname[16];\r\nif (logname2fsname(logname, fsname, sizeof(fsname)))\r\nreturn;\r\nmutex_lock(&sptlrpc_conf_lock);\r\nconf = sptlrpc_conf_get(fsname, 0);\r\nif (conf) {\r\nif (conf->sc_updated == 0)\r\nconf->sc_modified++;\r\nconf->sc_updated = 1;\r\n}\r\nmutex_unlock(&sptlrpc_conf_lock);\r\n}\r\nvoid sptlrpc_conf_log_start(const char *logname)\r\n{\r\nchar fsname[16];\r\nif (logname2fsname(logname, fsname, sizeof(fsname)))\r\nreturn;\r\nmutex_lock(&sptlrpc_conf_lock);\r\nsptlrpc_conf_get(fsname, 1);\r\nmutex_unlock(&sptlrpc_conf_lock);\r\n}\r\nvoid sptlrpc_conf_log_stop(const char *logname)\r\n{\r\nstruct sptlrpc_conf *conf;\r\nchar fsname[16];\r\nif (logname2fsname(logname, fsname, sizeof(fsname)))\r\nreturn;\r\nmutex_lock(&sptlrpc_conf_lock);\r\nconf = sptlrpc_conf_get(fsname, 0);\r\nif (conf)\r\nsptlrpc_conf_free(conf);\r\nmutex_unlock(&sptlrpc_conf_lock);\r\n}\r\nstatic inline void flavor_set_flags(struct sptlrpc_flavor *sf,\r\nenum lustre_sec_part from,\r\nenum lustre_sec_part to,\r\nunsigned int fl_udesc)\r\n{\r\nif (sf->sf_rpc == SPTLRPC_FLVR_NULL)\r\nreturn;\r\nif (from == LUSTRE_SP_MDT) {\r\nsf->sf_flags |= PTLRPC_SEC_FL_ROOTONLY;\r\n} else if (from == LUSTRE_SP_CLI && to == LUSTRE_SP_OST) {\r\nsf->sf_flags |= PTLRPC_SEC_FL_ROOTONLY | PTLRPC_SEC_FL_BULK;\r\n} else if (from == LUSTRE_SP_CLI && to == LUSTRE_SP_MDT) {\r\nif (fl_udesc && sf->sf_rpc != SPTLRPC_FLVR_NULL)\r\nsf->sf_flags |= PTLRPC_SEC_FL_UDESC;\r\n}\r\n}\r\nvoid sptlrpc_conf_choose_flavor(enum lustre_sec_part from,\r\nenum lustre_sec_part to,\r\nstruct obd_uuid *target,\r\nlnet_nid_t nid,\r\nstruct sptlrpc_flavor *sf)\r\n{\r\nstruct sptlrpc_conf *conf;\r\nstruct sptlrpc_conf_tgt *conf_tgt;\r\nchar name[MTI_NAME_MAXLEN];\r\nint len, rc = 0;\r\ntarget2fsname(target->uuid, name, sizeof(name));\r\nmutex_lock(&sptlrpc_conf_lock);\r\nconf = sptlrpc_conf_get(name, 0);\r\nif (conf == NULL)\r\ngoto out;\r\nlen = strlen(target->uuid);\r\nLASSERT(len > 5);\r\nmemcpy(name, target->uuid, len - 5);\r\nname[len - 5] = '\0';\r\nconf_tgt = sptlrpc_conf_get_tgt(conf, name, 0);\r\nif (conf_tgt) {\r\nrc = sptlrpc_rule_set_choose(&conf_tgt->sct_rset,\r\nfrom, to, nid, sf);\r\nif (rc)\r\ngoto out;\r\n}\r\nrc = sptlrpc_rule_set_choose(&conf->sc_rset, from, to, nid, sf);\r\nout:\r\nmutex_unlock(&sptlrpc_conf_lock);\r\nif (rc == 0)\r\nget_default_flavor(sf);\r\nflavor_set_flags(sf, from, to, 1);\r\n}\r\nvoid sptlrpc_target_choose_flavor(struct sptlrpc_rule_set *rset,\r\nenum lustre_sec_part from,\r\nlnet_nid_t nid,\r\nstruct sptlrpc_flavor *sf)\r\n{\r\nif (sptlrpc_rule_set_choose(rset, from, LUSTRE_SP_ANY, nid, sf) == 0)\r\nget_default_flavor(sf);\r\n}\r\nvoid sptlrpc_conf_client_adapt(struct obd_device *obd)\r\n{\r\nstruct obd_import *imp;\r\nLASSERT(strcmp(obd->obd_type->typ_name, LUSTRE_MDC_NAME) == 0 ||\r\nstrcmp(obd->obd_type->typ_name, LUSTRE_OSC_NAME) == 0);\r\nCDEBUG(D_SEC, "obd %s\n", obd->u.cli.cl_target_uuid.uuid);\r\ndown_read(&obd->u.cli.cl_sem);\r\nimp = obd->u.cli.cl_import;\r\nif (imp) {\r\nspin_lock(&imp->imp_lock);\r\nif (imp->imp_sec)\r\nimp->imp_sec_expire = get_seconds() +\r\nSEC_ADAPT_DELAY;\r\nspin_unlock(&imp->imp_lock);\r\n}\r\nup_read(&obd->u.cli.cl_sem);\r\n}\r\nint sptlrpc_conf_init(void)\r\n{\r\nmutex_init(&sptlrpc_conf_lock);\r\nreturn 0;\r\n}\r\nvoid sptlrpc_conf_fini(void)\r\n{\r\nstruct sptlrpc_conf *conf, *conf_next;\r\nmutex_lock(&sptlrpc_conf_lock);\r\nlist_for_each_entry_safe(conf, conf_next, &sptlrpc_confs, sc_list) {\r\nsptlrpc_conf_free(conf);\r\n}\r\nLASSERT(list_empty(&sptlrpc_confs));\r\nmutex_unlock(&sptlrpc_conf_lock);\r\n}
