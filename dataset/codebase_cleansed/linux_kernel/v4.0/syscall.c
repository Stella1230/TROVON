static struct bpf_map *find_and_alloc_map(union bpf_attr *attr)\r\n{\r\nstruct bpf_map_type_list *tl;\r\nstruct bpf_map *map;\r\nlist_for_each_entry(tl, &bpf_map_types, list_node) {\r\nif (tl->type == attr->map_type) {\r\nmap = tl->ops->map_alloc(attr);\r\nif (IS_ERR(map))\r\nreturn map;\r\nmap->ops = tl->ops;\r\nmap->map_type = attr->map_type;\r\nreturn map;\r\n}\r\n}\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nvoid bpf_register_map_type(struct bpf_map_type_list *tl)\r\n{\r\nlist_add(&tl->list_node, &bpf_map_types);\r\n}\r\nstatic void bpf_map_free_deferred(struct work_struct *work)\r\n{\r\nstruct bpf_map *map = container_of(work, struct bpf_map, work);\r\nmap->ops->map_free(map);\r\n}\r\nvoid bpf_map_put(struct bpf_map *map)\r\n{\r\nif (atomic_dec_and_test(&map->refcnt)) {\r\nINIT_WORK(&map->work, bpf_map_free_deferred);\r\nschedule_work(&map->work);\r\n}\r\n}\r\nstatic int bpf_map_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct bpf_map *map = filp->private_data;\r\nbpf_map_put(map);\r\nreturn 0;\r\n}\r\nstatic int map_create(union bpf_attr *attr)\r\n{\r\nstruct bpf_map *map;\r\nint err;\r\nerr = CHECK_ATTR(BPF_MAP_CREATE);\r\nif (err)\r\nreturn -EINVAL;\r\nmap = find_and_alloc_map(attr);\r\nif (IS_ERR(map))\r\nreturn PTR_ERR(map);\r\natomic_set(&map->refcnt, 1);\r\nerr = anon_inode_getfd("bpf-map", &bpf_map_fops, map, O_RDWR | O_CLOEXEC);\r\nif (err < 0)\r\ngoto free_map;\r\nreturn err;\r\nfree_map:\r\nmap->ops->map_free(map);\r\nreturn err;\r\n}\r\nstruct bpf_map *bpf_map_get(struct fd f)\r\n{\r\nstruct bpf_map *map;\r\nif (!f.file)\r\nreturn ERR_PTR(-EBADF);\r\nif (f.file->f_op != &bpf_map_fops) {\r\nfdput(f);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nmap = f.file->private_data;\r\nreturn map;\r\n}\r\nstatic void __user *u64_to_ptr(__u64 val)\r\n{\r\nreturn (void __user *) (unsigned long) val;\r\n}\r\nstatic int map_lookup_elem(union bpf_attr *attr)\r\n{\r\nvoid __user *ukey = u64_to_ptr(attr->key);\r\nvoid __user *uvalue = u64_to_ptr(attr->value);\r\nint ufd = attr->map_fd;\r\nstruct fd f = fdget(ufd);\r\nstruct bpf_map *map;\r\nvoid *key, *value, *ptr;\r\nint err;\r\nif (CHECK_ATTR(BPF_MAP_LOOKUP_ELEM))\r\nreturn -EINVAL;\r\nmap = bpf_map_get(f);\r\nif (IS_ERR(map))\r\nreturn PTR_ERR(map);\r\nerr = -ENOMEM;\r\nkey = kmalloc(map->key_size, GFP_USER);\r\nif (!key)\r\ngoto err_put;\r\nerr = -EFAULT;\r\nif (copy_from_user(key, ukey, map->key_size) != 0)\r\ngoto free_key;\r\nerr = -ENOMEM;\r\nvalue = kmalloc(map->value_size, GFP_USER);\r\nif (!value)\r\ngoto free_key;\r\nrcu_read_lock();\r\nptr = map->ops->map_lookup_elem(map, key);\r\nif (ptr)\r\nmemcpy(value, ptr, map->value_size);\r\nrcu_read_unlock();\r\nerr = -ENOENT;\r\nif (!ptr)\r\ngoto free_value;\r\nerr = -EFAULT;\r\nif (copy_to_user(uvalue, value, map->value_size) != 0)\r\ngoto free_value;\r\nerr = 0;\r\nfree_value:\r\nkfree(value);\r\nfree_key:\r\nkfree(key);\r\nerr_put:\r\nfdput(f);\r\nreturn err;\r\n}\r\nstatic int map_update_elem(union bpf_attr *attr)\r\n{\r\nvoid __user *ukey = u64_to_ptr(attr->key);\r\nvoid __user *uvalue = u64_to_ptr(attr->value);\r\nint ufd = attr->map_fd;\r\nstruct fd f = fdget(ufd);\r\nstruct bpf_map *map;\r\nvoid *key, *value;\r\nint err;\r\nif (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))\r\nreturn -EINVAL;\r\nmap = bpf_map_get(f);\r\nif (IS_ERR(map))\r\nreturn PTR_ERR(map);\r\nerr = -ENOMEM;\r\nkey = kmalloc(map->key_size, GFP_USER);\r\nif (!key)\r\ngoto err_put;\r\nerr = -EFAULT;\r\nif (copy_from_user(key, ukey, map->key_size) != 0)\r\ngoto free_key;\r\nerr = -ENOMEM;\r\nvalue = kmalloc(map->value_size, GFP_USER);\r\nif (!value)\r\ngoto free_key;\r\nerr = -EFAULT;\r\nif (copy_from_user(value, uvalue, map->value_size) != 0)\r\ngoto free_value;\r\nrcu_read_lock();\r\nerr = map->ops->map_update_elem(map, key, value, attr->flags);\r\nrcu_read_unlock();\r\nfree_value:\r\nkfree(value);\r\nfree_key:\r\nkfree(key);\r\nerr_put:\r\nfdput(f);\r\nreturn err;\r\n}\r\nstatic int map_delete_elem(union bpf_attr *attr)\r\n{\r\nvoid __user *ukey = u64_to_ptr(attr->key);\r\nint ufd = attr->map_fd;\r\nstruct fd f = fdget(ufd);\r\nstruct bpf_map *map;\r\nvoid *key;\r\nint err;\r\nif (CHECK_ATTR(BPF_MAP_DELETE_ELEM))\r\nreturn -EINVAL;\r\nmap = bpf_map_get(f);\r\nif (IS_ERR(map))\r\nreturn PTR_ERR(map);\r\nerr = -ENOMEM;\r\nkey = kmalloc(map->key_size, GFP_USER);\r\nif (!key)\r\ngoto err_put;\r\nerr = -EFAULT;\r\nif (copy_from_user(key, ukey, map->key_size) != 0)\r\ngoto free_key;\r\nrcu_read_lock();\r\nerr = map->ops->map_delete_elem(map, key);\r\nrcu_read_unlock();\r\nfree_key:\r\nkfree(key);\r\nerr_put:\r\nfdput(f);\r\nreturn err;\r\n}\r\nstatic int map_get_next_key(union bpf_attr *attr)\r\n{\r\nvoid __user *ukey = u64_to_ptr(attr->key);\r\nvoid __user *unext_key = u64_to_ptr(attr->next_key);\r\nint ufd = attr->map_fd;\r\nstruct fd f = fdget(ufd);\r\nstruct bpf_map *map;\r\nvoid *key, *next_key;\r\nint err;\r\nif (CHECK_ATTR(BPF_MAP_GET_NEXT_KEY))\r\nreturn -EINVAL;\r\nmap = bpf_map_get(f);\r\nif (IS_ERR(map))\r\nreturn PTR_ERR(map);\r\nerr = -ENOMEM;\r\nkey = kmalloc(map->key_size, GFP_USER);\r\nif (!key)\r\ngoto err_put;\r\nerr = -EFAULT;\r\nif (copy_from_user(key, ukey, map->key_size) != 0)\r\ngoto free_key;\r\nerr = -ENOMEM;\r\nnext_key = kmalloc(map->key_size, GFP_USER);\r\nif (!next_key)\r\ngoto free_key;\r\nrcu_read_lock();\r\nerr = map->ops->map_get_next_key(map, key, next_key);\r\nrcu_read_unlock();\r\nif (err)\r\ngoto free_next_key;\r\nerr = -EFAULT;\r\nif (copy_to_user(unext_key, next_key, map->key_size) != 0)\r\ngoto free_next_key;\r\nerr = 0;\r\nfree_next_key:\r\nkfree(next_key);\r\nfree_key:\r\nkfree(key);\r\nerr_put:\r\nfdput(f);\r\nreturn err;\r\n}\r\nstatic int find_prog_type(enum bpf_prog_type type, struct bpf_prog *prog)\r\n{\r\nstruct bpf_prog_type_list *tl;\r\nlist_for_each_entry(tl, &bpf_prog_types, list_node) {\r\nif (tl->type == type) {\r\nprog->aux->ops = tl->ops;\r\nprog->aux->prog_type = type;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid bpf_register_prog_type(struct bpf_prog_type_list *tl)\r\n{\r\nlist_add(&tl->list_node, &bpf_prog_types);\r\n}\r\nstatic void fixup_bpf_calls(struct bpf_prog *prog)\r\n{\r\nconst struct bpf_func_proto *fn;\r\nint i;\r\nfor (i = 0; i < prog->len; i++) {\r\nstruct bpf_insn *insn = &prog->insnsi[i];\r\nif (insn->code == (BPF_JMP | BPF_CALL)) {\r\nBUG_ON(!prog->aux->ops->get_func_proto);\r\nfn = prog->aux->ops->get_func_proto(insn->imm);\r\nBUG_ON(!fn->func);\r\ninsn->imm = fn->func - __bpf_call_base;\r\n}\r\n}\r\n}\r\nstatic void free_used_maps(struct bpf_prog_aux *aux)\r\n{\r\nint i;\r\nfor (i = 0; i < aux->used_map_cnt; i++)\r\nbpf_map_put(aux->used_maps[i]);\r\nkfree(aux->used_maps);\r\n}\r\nvoid bpf_prog_put(struct bpf_prog *prog)\r\n{\r\nif (atomic_dec_and_test(&prog->aux->refcnt)) {\r\nfree_used_maps(prog->aux);\r\nbpf_prog_free(prog);\r\n}\r\n}\r\nstatic int bpf_prog_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct bpf_prog *prog = filp->private_data;\r\nbpf_prog_put(prog);\r\nreturn 0;\r\n}\r\nstatic struct bpf_prog *get_prog(struct fd f)\r\n{\r\nstruct bpf_prog *prog;\r\nif (!f.file)\r\nreturn ERR_PTR(-EBADF);\r\nif (f.file->f_op != &bpf_prog_fops) {\r\nfdput(f);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nprog = f.file->private_data;\r\nreturn prog;\r\n}\r\nstruct bpf_prog *bpf_prog_get(u32 ufd)\r\n{\r\nstruct fd f = fdget(ufd);\r\nstruct bpf_prog *prog;\r\nprog = get_prog(f);\r\nif (IS_ERR(prog))\r\nreturn prog;\r\natomic_inc(&prog->aux->refcnt);\r\nfdput(f);\r\nreturn prog;\r\n}\r\nstatic int bpf_prog_load(union bpf_attr *attr)\r\n{\r\nenum bpf_prog_type type = attr->prog_type;\r\nstruct bpf_prog *prog;\r\nint err;\r\nchar license[128];\r\nbool is_gpl;\r\nif (CHECK_ATTR(BPF_PROG_LOAD))\r\nreturn -EINVAL;\r\nif (strncpy_from_user(license, u64_to_ptr(attr->license),\r\nsizeof(license) - 1) < 0)\r\nreturn -EFAULT;\r\nlicense[sizeof(license) - 1] = 0;\r\nis_gpl = license_is_gpl_compatible(license);\r\nif (attr->insn_cnt >= BPF_MAXINSNS)\r\nreturn -EINVAL;\r\nprog = bpf_prog_alloc(bpf_prog_size(attr->insn_cnt), GFP_USER);\r\nif (!prog)\r\nreturn -ENOMEM;\r\nprog->len = attr->insn_cnt;\r\nerr = -EFAULT;\r\nif (copy_from_user(prog->insns, u64_to_ptr(attr->insns),\r\nprog->len * sizeof(struct bpf_insn)) != 0)\r\ngoto free_prog;\r\nprog->orig_prog = NULL;\r\nprog->jited = false;\r\natomic_set(&prog->aux->refcnt, 1);\r\nprog->aux->is_gpl_compatible = is_gpl;\r\nerr = find_prog_type(type, prog);\r\nif (err < 0)\r\ngoto free_prog;\r\nerr = bpf_check(prog, attr);\r\nif (err < 0)\r\ngoto free_used_maps;\r\nfixup_bpf_calls(prog);\r\nbpf_prog_select_runtime(prog);\r\nerr = anon_inode_getfd("bpf-prog", &bpf_prog_fops, prog, O_RDWR | O_CLOEXEC);\r\nif (err < 0)\r\ngoto free_used_maps;\r\nreturn err;\r\nfree_used_maps:\r\nfree_used_maps(prog->aux);\r\nfree_prog:\r\nbpf_prog_free(prog);\r\nreturn err;\r\n}
