static int\r\nnfs4_file_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct nfs_open_context *ctx;\r\nstruct dentry *dentry = filp->f_path.dentry;\r\nstruct dentry *parent = NULL;\r\nstruct inode *dir;\r\nunsigned openflags = filp->f_flags;\r\nstruct iattr attr;\r\nint opened = 0;\r\nint err;\r\ndprintk("NFS: open file(%pd2)\n", dentry);\r\nif ((openflags & O_ACCMODE) == 3)\r\nopenflags--;\r\nopenflags &= ~(O_CREAT|O_EXCL);\r\nparent = dget_parent(dentry);\r\ndir = parent->d_inode;\r\nctx = alloc_nfs_open_context(filp->f_path.dentry, filp->f_mode);\r\nerr = PTR_ERR(ctx);\r\nif (IS_ERR(ctx))\r\ngoto out;\r\nattr.ia_valid = ATTR_OPEN;\r\nif (openflags & O_TRUNC) {\r\nattr.ia_valid |= ATTR_SIZE;\r\nattr.ia_size = 0;\r\nnfs_wb_all(inode);\r\n}\r\ninode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, &opened);\r\nif (IS_ERR(inode)) {\r\nerr = PTR_ERR(inode);\r\nswitch (err) {\r\ncase -EPERM:\r\ncase -EACCES:\r\ncase -EDQUOT:\r\ncase -ENOSPC:\r\ncase -EROFS:\r\ngoto out_put_ctx;\r\ndefault:\r\ngoto out_drop;\r\n}\r\n}\r\nif (inode != dentry->d_inode)\r\ngoto out_drop;\r\nnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\r\nnfs_file_set_open_context(filp, ctx);\r\nnfs_fscache_open_file(inode, filp);\r\nerr = 0;\r\nout_put_ctx:\r\nput_nfs_open_context(ctx);\r\nout:\r\ndput(parent);\r\nreturn err;\r\nout_drop:\r\nd_drop(dentry);\r\nerr = -EOPENSTALE;\r\ngoto out_put_ctx;\r\n}\r\nstatic int\r\nnfs4_file_fsync(struct file *file, loff_t start, loff_t end, int datasync)\r\n{\r\nint ret;\r\nstruct inode *inode = file_inode(file);\r\ndo {\r\nret = filemap_write_and_wait_range(inode->i_mapping, start, end);\r\nif (ret != 0)\r\nbreak;\r\nmutex_lock(&inode->i_mutex);\r\nret = nfs_file_fsync_commit(file, start, end, datasync);\r\nif (!ret)\r\nret = pnfs_layoutcommit_inode(inode, true);\r\nmutex_unlock(&inode->i_mutex);\r\nstart = 0;\r\nend = LLONG_MAX;\r\n} while (ret == -EAGAIN);\r\nreturn ret;\r\n}\r\nstatic loff_t nfs4_file_llseek(struct file *filep, loff_t offset, int whence)\r\n{\r\nloff_t ret;\r\nswitch (whence) {\r\ncase SEEK_HOLE:\r\ncase SEEK_DATA:\r\nret = nfs42_proc_llseek(filep, offset, whence);\r\nif (ret != -ENOTSUPP)\r\nreturn ret;\r\ndefault:\r\nreturn nfs_file_llseek(filep, offset, whence);\r\n}\r\n}\r\nstatic long nfs42_fallocate(struct file *filep, int mode, loff_t offset, loff_t len)\r\n{\r\nstruct inode *inode = file_inode(filep);\r\nlong ret;\r\nif (!S_ISREG(inode->i_mode))\r\nreturn -EOPNOTSUPP;\r\nif ((mode != 0) && (mode != (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE)))\r\nreturn -EOPNOTSUPP;\r\nret = inode_newsize_ok(inode, offset + len);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&inode->i_mutex);\r\nif (mode & FALLOC_FL_PUNCH_HOLE)\r\nret = nfs42_proc_deallocate(filep, offset, len);\r\nelse\r\nret = nfs42_proc_allocate(filep, offset, len);\r\nmutex_unlock(&inode->i_mutex);\r\nnfs_zap_caches(inode);\r\nreturn ret;\r\n}
