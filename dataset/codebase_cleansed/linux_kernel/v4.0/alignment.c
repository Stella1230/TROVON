static bool cpu_is_v6_unaligned(void)\r\n{\r\nreturn cpu_architecture() >= CPU_ARCH_ARMv6 && get_cr() & CR_U;\r\n}\r\nstatic int safe_usermode(int new_usermode, bool warn)\r\n{\r\nif (cpu_is_v6_unaligned() && !(new_usermode & (UM_FIXUP | UM_SIGNAL))) {\r\nnew_usermode |= UM_FIXUP;\r\nif (warn)\r\npr_warn("alignment: ignoring faults is unsafe on this CPU. Defaulting to fixup mode.\n");\r\n}\r\nreturn new_usermode;\r\n}\r\nstatic int alignment_proc_show(struct seq_file *m, void *v)\r\n{\r\nseq_printf(m, "User:\t\t%lu\n", ai_user);\r\nseq_printf(m, "System:\t\t%lu (%pF)\n", ai_sys, ai_sys_last_pc);\r\nseq_printf(m, "Skipped:\t%lu\n", ai_skipped);\r\nseq_printf(m, "Half:\t\t%lu\n", ai_half);\r\nseq_printf(m, "Word:\t\t%lu\n", ai_word);\r\nif (cpu_architecture() >= CPU_ARCH_ARMv5TE)\r\nseq_printf(m, "DWord:\t\t%lu\n", ai_dword);\r\nseq_printf(m, "Multi:\t\t%lu\n", ai_multi);\r\nseq_printf(m, "User faults:\t%i (%s)\n", ai_usermode,\r\nusermode_action[ai_usermode]);\r\nreturn 0;\r\n}\r\nstatic int alignment_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, alignment_proc_show, NULL);\r\n}\r\nstatic ssize_t alignment_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nchar mode;\r\nif (count > 0) {\r\nif (get_user(mode, buffer))\r\nreturn -EFAULT;\r\nif (mode >= '0' && mode <= '5')\r\nai_usermode = safe_usermode(mode - '0', true);\r\n}\r\nreturn count;\r\n}\r\nstatic void\r\ndo_alignment_finish_ldst(unsigned long addr, unsigned long instr, struct pt_regs *regs, union offset_union offset)\r\n{\r\nif (!LDST_U_BIT(instr))\r\noffset.un = -offset.un;\r\nif (!LDST_P_BIT(instr))\r\naddr += offset.un;\r\nif (!LDST_P_BIT(instr) || LDST_W_BIT(instr))\r\nregs->uregs[RN_BITS(instr)] = addr;\r\n}\r\nstatic int\r\ndo_alignment_ldrhstrh(unsigned long addr, unsigned long instr, struct pt_regs *regs)\r\n{\r\nunsigned int rd = RD_BITS(instr);\r\nai_half += 1;\r\nif (user_mode(regs))\r\ngoto user;\r\nif (LDST_L_BIT(instr)) {\r\nunsigned long val;\r\nget16_unaligned_check(val, addr);\r\nif (instr & 0x40)\r\nval = (signed long)((signed short) val);\r\nregs->uregs[rd] = val;\r\n} else\r\nput16_unaligned_check(regs->uregs[rd], addr);\r\nreturn TYPE_LDST;\r\nuser:\r\nif (LDST_L_BIT(instr)) {\r\nunsigned long val;\r\nget16t_unaligned_check(val, addr);\r\nif (instr & 0x40)\r\nval = (signed long)((signed short) val);\r\nregs->uregs[rd] = val;\r\n} else\r\nput16t_unaligned_check(regs->uregs[rd], addr);\r\nreturn TYPE_LDST;\r\nfault:\r\nreturn TYPE_FAULT;\r\n}\r\nstatic int\r\ndo_alignment_ldrdstrd(unsigned long addr, unsigned long instr,\r\nstruct pt_regs *regs)\r\n{\r\nunsigned int rd = RD_BITS(instr);\r\nunsigned int rd2;\r\nint load;\r\nif ((instr & 0xfe000000) == 0xe8000000) {\r\nrd2 = (instr >> 8) & 0xf;\r\nload = !!(LDST_L_BIT(instr));\r\n} else if (((rd & 1) == 1) || (rd == 14))\r\ngoto bad;\r\nelse {\r\nload = ((instr & 0xf0) == 0xd0);\r\nrd2 = rd + 1;\r\n}\r\nai_dword += 1;\r\nif (user_mode(regs))\r\ngoto user;\r\nif (load) {\r\nunsigned long val;\r\nget32_unaligned_check(val, addr);\r\nregs->uregs[rd] = val;\r\nget32_unaligned_check(val, addr + 4);\r\nregs->uregs[rd2] = val;\r\n} else {\r\nput32_unaligned_check(regs->uregs[rd], addr);\r\nput32_unaligned_check(regs->uregs[rd2], addr + 4);\r\n}\r\nreturn TYPE_LDST;\r\nuser:\r\nif (load) {\r\nunsigned long val;\r\nget32t_unaligned_check(val, addr);\r\nregs->uregs[rd] = val;\r\nget32t_unaligned_check(val, addr + 4);\r\nregs->uregs[rd2] = val;\r\n} else {\r\nput32t_unaligned_check(regs->uregs[rd], addr);\r\nput32t_unaligned_check(regs->uregs[rd2], addr + 4);\r\n}\r\nreturn TYPE_LDST;\r\nbad:\r\nreturn TYPE_ERROR;\r\nfault:\r\nreturn TYPE_FAULT;\r\n}\r\nstatic int\r\ndo_alignment_ldrstr(unsigned long addr, unsigned long instr, struct pt_regs *regs)\r\n{\r\nunsigned int rd = RD_BITS(instr);\r\nai_word += 1;\r\nif ((!LDST_P_BIT(instr) && LDST_W_BIT(instr)) || user_mode(regs))\r\ngoto trans;\r\nif (LDST_L_BIT(instr)) {\r\nunsigned int val;\r\nget32_unaligned_check(val, addr);\r\nregs->uregs[rd] = val;\r\n} else\r\nput32_unaligned_check(regs->uregs[rd], addr);\r\nreturn TYPE_LDST;\r\ntrans:\r\nif (LDST_L_BIT(instr)) {\r\nunsigned int val;\r\nget32t_unaligned_check(val, addr);\r\nregs->uregs[rd] = val;\r\n} else\r\nput32t_unaligned_check(regs->uregs[rd], addr);\r\nreturn TYPE_LDST;\r\nfault:\r\nreturn TYPE_FAULT;\r\n}\r\nstatic int\r\ndo_alignment_ldmstm(unsigned long addr, unsigned long instr, struct pt_regs *regs)\r\n{\r\nunsigned int rd, rn, correction, nr_regs, regbits;\r\nunsigned long eaddr, newaddr;\r\nif (LDM_S_BIT(instr))\r\ngoto bad;\r\ncorrection = 4;\r\nregs->ARM_pc += correction;\r\nai_multi += 1;\r\nnr_regs = hweight16(REGMASK_BITS(instr)) * 4;\r\nrn = RN_BITS(instr);\r\nnewaddr = eaddr = regs->uregs[rn];\r\nif (!LDST_U_BIT(instr))\r\nnr_regs = -nr_regs;\r\nnewaddr += nr_regs;\r\nif (!LDST_U_BIT(instr))\r\neaddr = newaddr;\r\nif (LDST_P_EQ_U(instr))\r\neaddr += 4;\r\n#if !(defined CONFIG_CPU_ARM922T) && !(defined CONFIG_CPU_ARM920T)\r\nif (addr != eaddr) {\r\npr_err("LDMSTM: PC = %08lx, instr = %08lx, "\r\n"addr = %08lx, eaddr = %08lx\n",\r\ninstruction_pointer(regs), instr, addr, eaddr);\r\nshow_regs(regs);\r\n}\r\n#endif\r\nif (user_mode(regs)) {\r\nfor (regbits = REGMASK_BITS(instr), rd = 0; regbits;\r\nregbits >>= 1, rd += 1)\r\nif (regbits & 1) {\r\nif (LDST_L_BIT(instr)) {\r\nunsigned int val;\r\nget32t_unaligned_check(val, eaddr);\r\nregs->uregs[rd] = val;\r\n} else\r\nput32t_unaligned_check(regs->uregs[rd], eaddr);\r\neaddr += 4;\r\n}\r\n} else {\r\nfor (regbits = REGMASK_BITS(instr), rd = 0; regbits;\r\nregbits >>= 1, rd += 1)\r\nif (regbits & 1) {\r\nif (LDST_L_BIT(instr)) {\r\nunsigned int val;\r\nget32_unaligned_check(val, eaddr);\r\nregs->uregs[rd] = val;\r\n} else\r\nput32_unaligned_check(regs->uregs[rd], eaddr);\r\neaddr += 4;\r\n}\r\n}\r\nif (LDST_W_BIT(instr))\r\nregs->uregs[rn] = newaddr;\r\nif (!LDST_L_BIT(instr) || !(REGMASK_BITS(instr) & (1 << 15)))\r\nregs->ARM_pc -= correction;\r\nreturn TYPE_DONE;\r\nfault:\r\nregs->ARM_pc -= correction;\r\nreturn TYPE_FAULT;\r\nbad:\r\npr_err("Alignment trap: not handling ldm with s-bit set\n");\r\nreturn TYPE_ERROR;\r\n}\r\nstatic unsigned long\r\nthumb2arm(u16 tinstr)\r\n{\r\nu32 L = (tinstr & (1<<11)) >> 11;\r\nswitch ((tinstr & 0xf800) >> 11) {\r\ncase 0x6000 >> 11:\r\ncase 0x6800 >> 11:\r\ncase 0x7000 >> 11:\r\ncase 0x7800 >> 11:\r\nreturn 0xe5800000 |\r\n((tinstr & (1<<12)) << (22-12)) |\r\n(L<<20) |\r\n((tinstr & (7<<0)) << (12-0)) |\r\n((tinstr & (7<<3)) << (16-3)) |\r\n((tinstr & (31<<6)) >>\r\n(6 - ((tinstr & (1<<12)) ? 0 : 2)));\r\ncase 0x8000 >> 11:\r\ncase 0x8800 >> 11:\r\nreturn 0xe1c000b0 |\r\n(L<<20) |\r\n((tinstr & (7<<0)) << (12-0)) |\r\n((tinstr & (7<<3)) << (16-3)) |\r\n((tinstr & (7<<6)) >> (6-1)) |\r\n((tinstr & (3<<9)) >> (9-8));\r\ncase 0x5000 >> 11:\r\ncase 0x5800 >> 11:\r\n{\r\nstatic const u32 subset[8] = {\r\n0xe7800000,\r\n0xe18000b0,\r\n0xe7c00000,\r\n0xe19000d0,\r\n0xe7900000,\r\n0xe19000b0,\r\n0xe7d00000,\r\n0xe19000f0\r\n};\r\nreturn subset[(tinstr & (7<<9)) >> 9] |\r\n((tinstr & (7<<0)) << (12-0)) |\r\n((tinstr & (7<<3)) << (16-3)) |\r\n((tinstr & (7<<6)) >> (6-0));\r\n}\r\ncase 0x4800 >> 11:\r\nreturn 0xe59f0000 |\r\n((tinstr & (7<<8)) << (12-8)) |\r\n((tinstr & 255) << (2-0));\r\ncase 0x9000 >> 11:\r\ncase 0x9800 >> 11:\r\nreturn 0xe58d0000 |\r\n(L<<20) |\r\n((tinstr & (7<<8)) << (12-8)) |\r\n((tinstr & 255) << 2);\r\ncase 0xc000 >> 11:\r\ncase 0xc800 >> 11:\r\n{\r\nu32 Rn = (tinstr & (7<<8)) >> 8;\r\nu32 W = ((L<<Rn) & (tinstr&255)) ? 0 : 1<<21;\r\nreturn 0xe8800000 | W | (L<<20) | (Rn<<16) |\r\n(tinstr&255);\r\n}\r\ncase 0xb000 >> 11:\r\ncase 0xb800 >> 11:\r\nif ((tinstr & (3 << 9)) == 0x0400) {\r\nstatic const u32 subset[4] = {\r\n0xe92d0000,\r\n0xe92d4000,\r\n0xe8bd0000,\r\n0xe8bd8000\r\n};\r\nreturn subset[(L<<1) | ((tinstr & (1<<8)) >> 8)] |\r\n(tinstr & 255);\r\n}\r\ndefault:\r\nreturn BAD_INSTR;\r\n}\r\n}\r\nstatic void *\r\ndo_alignment_t32_to_handler(unsigned long *pinstr, struct pt_regs *regs,\r\nunion offset_union *poffset)\r\n{\r\nunsigned long instr = *pinstr;\r\nu16 tinst1 = (instr >> 16) & 0xffff;\r\nu16 tinst2 = instr & 0xffff;\r\nswitch (tinst1 & 0xffe0) {\r\ncase 0xe880:\r\ncase 0xe8a0:\r\ncase 0xe900:\r\ncase 0xe920:\r\nreturn do_alignment_ldmstm;\r\ncase 0xf840:\r\nif (RN_BITS(instr) == 13 && (tinst2 & 0x09ff) == 0x0904) {\r\nu32 L = !!(LDST_L_BIT(instr));\r\nconst u32 subset[2] = {\r\n0xe92d0000,\r\n0xe8bd0000,\r\n};\r\n*pinstr = subset[L] | (1<<RD_BITS(instr));\r\nreturn do_alignment_ldmstm;\r\n}\r\nbreak;\r\ncase 0xe860:\r\ncase 0xe960:\r\ncase 0xe8e0:\r\ncase 0xe9e0:\r\npoffset->un = (tinst2 & 0xff) << 2;\r\ncase 0xe940:\r\ncase 0xe9c0:\r\nreturn do_alignment_ldrdstrd;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\ndo_alignment(unsigned long addr, unsigned int fsr, struct pt_regs *regs)\r\n{\r\nunion offset_union uninitialized_var(offset);\r\nunsigned long instr = 0, instrptr;\r\nint (*handler)(unsigned long addr, unsigned long instr, struct pt_regs *regs);\r\nunsigned int type;\r\nunsigned int fault;\r\nu16 tinstr = 0;\r\nint isize = 4;\r\nint thumb2_32b = 0;\r\nif (interrupts_enabled(regs))\r\nlocal_irq_enable();\r\ninstrptr = instruction_pointer(regs);\r\nif (thumb_mode(regs)) {\r\nu16 *ptr = (u16 *)(instrptr & ~1);\r\nfault = probe_kernel_address(ptr, tinstr);\r\ntinstr = __mem_to_opcode_thumb16(tinstr);\r\nif (!fault) {\r\nif (cpu_architecture() >= CPU_ARCH_ARMv7 &&\r\nIS_T32(tinstr)) {\r\nu16 tinst2 = 0;\r\nfault = probe_kernel_address(ptr + 1, tinst2);\r\ntinst2 = __mem_to_opcode_thumb16(tinst2);\r\ninstr = __opcode_thumb32_compose(tinstr, tinst2);\r\nthumb2_32b = 1;\r\n} else {\r\nisize = 2;\r\ninstr = thumb2arm(tinstr);\r\n}\r\n}\r\n} else {\r\nfault = probe_kernel_address(instrptr, instr);\r\ninstr = __mem_to_opcode_arm(instr);\r\n}\r\nif (fault) {\r\ntype = TYPE_FAULT;\r\ngoto bad_or_fault;\r\n}\r\nif (user_mode(regs))\r\ngoto user;\r\nai_sys += 1;\r\nai_sys_last_pc = (void *)instruction_pointer(regs);\r\nfixup:\r\nregs->ARM_pc += isize;\r\nswitch (CODING_BITS(instr)) {\r\ncase 0x00000000:\r\nif (LDSTHD_I_BIT(instr))\r\noffset.un = (instr & 0xf00) >> 4 | (instr & 15);\r\nelse\r\noffset.un = regs->uregs[RM_BITS(instr)];\r\nif ((instr & 0x000000f0) == 0x000000b0 ||\r\n(instr & 0x001000f0) == 0x001000f0)\r\nhandler = do_alignment_ldrhstrh;\r\nelse if ((instr & 0x001000f0) == 0x000000d0 ||\r\n(instr & 0x001000f0) == 0x000000f0)\r\nhandler = do_alignment_ldrdstrd;\r\nelse if ((instr & 0x01f00ff0) == 0x01000090)\r\ngoto swp;\r\nelse\r\ngoto bad;\r\nbreak;\r\ncase 0x04000000:\r\nif (COND_BITS(instr) == 0xf0000000)\r\ngoto bad;\r\noffset.un = OFFSET_BITS(instr);\r\nhandler = do_alignment_ldrstr;\r\nbreak;\r\ncase 0x06000000:\r\noffset.un = regs->uregs[RM_BITS(instr)];\r\nif (IS_SHIFT(instr)) {\r\nunsigned int shiftval = SHIFT_BITS(instr);\r\nswitch(SHIFT_TYPE(instr)) {\r\ncase SHIFT_LSL:\r\noffset.un <<= shiftval;\r\nbreak;\r\ncase SHIFT_LSR:\r\noffset.un >>= shiftval;\r\nbreak;\r\ncase SHIFT_ASR:\r\noffset.sn >>= shiftval;\r\nbreak;\r\ncase SHIFT_RORRRX:\r\nif (shiftval == 0) {\r\noffset.un >>= 1;\r\nif (regs->ARM_cpsr & PSR_C_BIT)\r\noffset.un |= 1 << 31;\r\n} else\r\noffset.un = offset.un >> shiftval |\r\noffset.un << (32 - shiftval);\r\nbreak;\r\n}\r\n}\r\nhandler = do_alignment_ldrstr;\r\nbreak;\r\ncase 0x08000000:\r\nif (thumb2_32b) {\r\noffset.un = 0;\r\nhandler = do_alignment_t32_to_handler(&instr, regs, &offset);\r\n} else {\r\noffset.un = 0;\r\nhandler = do_alignment_ldmstm;\r\n}\r\nbreak;\r\ndefault:\r\ngoto bad;\r\n}\r\nif (!handler)\r\ngoto bad;\r\ntype = handler(addr, instr, regs);\r\nif (type == TYPE_ERROR || type == TYPE_FAULT) {\r\nregs->ARM_pc -= isize;\r\ngoto bad_or_fault;\r\n}\r\nif (type == TYPE_LDST)\r\ndo_alignment_finish_ldst(addr, instr, regs, offset);\r\nreturn 0;\r\nbad_or_fault:\r\nif (type == TYPE_ERROR)\r\ngoto bad;\r\ndo_bad_area(addr, fsr, regs);\r\nreturn 0;\r\nswp:\r\npr_err("Alignment trap: not handling swp instruction\n");\r\nbad:\r\npr_err("Alignment trap: not handling instruction "\r\n"%0*lx at [<%08lx>]\n",\r\nisize << 1,\r\nisize == 2 ? tinstr : instr, instrptr);\r\nai_skipped += 1;\r\nreturn 1;\r\nuser:\r\nai_user += 1;\r\nif (ai_usermode & UM_WARN)\r\nprintk("Alignment trap: %s (%d) PC=0x%08lx Instr=0x%0*lx "\r\n"Address=0x%08lx FSR 0x%03x\n", current->comm,\r\ntask_pid_nr(current), instrptr,\r\nisize << 1,\r\nisize == 2 ? tinstr : instr,\r\naddr, fsr);\r\nif (ai_usermode & UM_FIXUP)\r\ngoto fixup;\r\nif (ai_usermode & UM_SIGNAL) {\r\nsiginfo_t si;\r\nsi.si_signo = SIGBUS;\r\nsi.si_errno = 0;\r\nsi.si_code = BUS_ADRALN;\r\nsi.si_addr = (void __user *)addr;\r\nforce_sig_info(si.si_signo, &si, current);\r\n} else {\r\nraw_local_irq_disable();\r\nif (!(current_thread_info()->flags & _TIF_WORK_MASK))\r\nset_cr(cr_no_alignment);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init noalign_setup(char *__unused)\r\n{\r\nset_cr(__clear_cr(CR_A));\r\nreturn 1;\r\n}\r\nstatic int __init alignment_init(void)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\nstruct proc_dir_entry *res;\r\nres = proc_create("cpu/alignment", S_IWUSR | S_IRUGO, NULL,\r\n&alignment_proc_fops);\r\nif (!res)\r\nreturn -ENOMEM;\r\n#endif\r\nif (cpu_is_v6_unaligned()) {\r\nset_cr(__clear_cr(CR_A));\r\nai_usermode = safe_usermode(ai_usermode, false);\r\n}\r\ncr_no_alignment = get_cr() & ~CR_A;\r\nhook_fault_code(FAULT_CODE_ALIGNMENT, do_alignment, SIGBUS, BUS_ADRALN,\r\n"alignment exception");\r\nif (cpu_architecture() <= CPU_ARCH_ARMv6) {\r\nhook_fault_code(3, do_alignment, SIGBUS, BUS_ADRALN,\r\n"alignment exception");\r\n}\r\nreturn 0;\r\n}
