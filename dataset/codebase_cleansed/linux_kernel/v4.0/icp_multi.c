static void setup_channel_list(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int *chanlist, unsigned int n_chan)\r\n{\r\nstruct icp_multi_private *devpriv = dev->private;\r\nunsigned int i, range, chanprog;\r\nunsigned int diff;\r\ndevpriv->act_chanlist_len = n_chan;\r\ndevpriv->act_chanlist_pos = 0;\r\nfor (i = 0; i < n_chan; i++) {\r\nchanprog = CR_CHAN(chanlist[i]);\r\nif (CR_AREF(chanlist[i]) == AREF_DIFF) {\r\ndiff = 1;\r\nchanprog &= 0x0007;\r\n} else {\r\ndiff = 0;\r\nchanprog &= 0x000f;\r\n}\r\ndevpriv->AdcCmdStatus &= 0xf00f;\r\nif (diff) {\r\ndevpriv->AdcCmdStatus |= (chanprog << 9);\r\ndevpriv->AdcCmdStatus |= ADC_DI;\r\n} else\r\ndevpriv->AdcCmdStatus |= (chanprog << 8);\r\nrange = range_codes_analog[CR_RANGE(chanlist[i])];\r\ndevpriv->AdcCmdStatus |= range;\r\nwritew(devpriv->AdcCmdStatus, dev->mmio + ICP_MULTI_ADC_CSR);\r\n}\r\n}\r\nstatic int icp_multi_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nstatus = readw(dev->mmio + ICP_MULTI_ADC_CSR);\r\nif ((status & ADC_BSY) == 0)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int icp_multi_insn_read_ai(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct icp_multi_private *devpriv = dev->private;\r\nint ret = 0;\r\nint n;\r\ndevpriv->IntEnable &= ~ADC_READY;\r\nwritew(devpriv->IntEnable, dev->mmio + ICP_MULTI_INT_EN);\r\ndevpriv->IntStatus |= ADC_READY;\r\nwritew(devpriv->IntStatus, dev->mmio + ICP_MULTI_INT_STAT);\r\nsetup_channel_list(dev, s, &insn->chanspec, 1);\r\nfor (n = 0; n < insn->n; n++) {\r\ndevpriv->AdcCmdStatus |= ADC_ST;\r\nwritew(devpriv->AdcCmdStatus, dev->mmio + ICP_MULTI_ADC_CSR);\r\ndevpriv->AdcCmdStatus &= ~ADC_ST;\r\nudelay(1);\r\nret = comedi_timeout(dev, s, insn, icp_multi_ai_eoc, 0);\r\nif (ret)\r\nbreak;\r\ndata[n] = (readw(dev->mmio + ICP_MULTI_AI) >> 4) & 0x0fff;\r\n}\r\ndevpriv->IntEnable &= ~ADC_READY;\r\nwritew(devpriv->IntEnable, dev->mmio + ICP_MULTI_INT_EN);\r\ndevpriv->IntStatus |= ADC_READY;\r\nwritew(devpriv->IntStatus, dev->mmio + ICP_MULTI_INT_STAT);\r\nreturn ret ? ret : n;\r\n}\r\nstatic int icp_multi_ao_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nstatus = readw(dev->mmio + ICP_MULTI_DAC_CSR);\r\nif ((status & DAC_BSY) == 0)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic int icp_multi_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct icp_multi_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int range = CR_RANGE(insn->chanspec);\r\nint i;\r\ndevpriv->IntEnable &= ~DAC_READY;\r\nwritew(devpriv->IntEnable, dev->mmio + ICP_MULTI_INT_EN);\r\ndevpriv->IntStatus |= DAC_READY;\r\nwritew(devpriv->IntStatus, dev->mmio + ICP_MULTI_INT_STAT);\r\ndevpriv->DacCmdStatus &= 0xfccf;\r\ndevpriv->DacCmdStatus |= range_codes_analog[range];\r\ndevpriv->DacCmdStatus |= (chan << 8);\r\nwritew(devpriv->DacCmdStatus, dev->mmio + ICP_MULTI_DAC_CSR);\r\nfor (i = 0; i < insn->n; i++) {\r\nunsigned int val = data[i];\r\nint ret;\r\nret = comedi_timeout(dev, s, insn, icp_multi_ao_eoc, 0);\r\nif (ret) {\r\ndevpriv->IntEnable &= ~DAC_READY;\r\nwritew(devpriv->IntEnable,\r\ndev->mmio + ICP_MULTI_INT_EN);\r\ndevpriv->IntStatus |= DAC_READY;\r\nwritew(devpriv->IntStatus,\r\ndev->mmio + ICP_MULTI_INT_STAT);\r\nreturn ret;\r\n}\r\nwritew(val, dev->mmio + ICP_MULTI_AO);\r\ndevpriv->DacCmdStatus |= DAC_ST;\r\nwritew(devpriv->DacCmdStatus, dev->mmio + ICP_MULTI_DAC_CSR);\r\ndevpriv->DacCmdStatus &= ~DAC_ST;\r\ns->readback[chan] = val;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int icp_multi_insn_bits_di(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ndata[1] = readw(dev->mmio + ICP_MULTI_DI);\r\nreturn insn->n;\r\n}\r\nstatic int icp_multi_insn_bits_do(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data))\r\nwritew(s->state, dev->mmio + ICP_MULTI_DO);\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic int icp_multi_insn_read_ctr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic int icp_multi_insn_write_ctr(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic irqreturn_t interrupt_service_icp_multi(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nint int_no;\r\nint_no = readw(dev->mmio + ICP_MULTI_INT_STAT) & Status_IRQ;\r\nif (!int_no)\r\nreturn IRQ_NONE;\r\nswitch (int_no) {\r\ncase ADC_READY:\r\nbreak;\r\ncase DAC_READY:\r\nbreak;\r\ncase DOUT_ERROR:\r\nbreak;\r\ncase DIN_STATUS:\r\nbreak;\r\ncase CIE0:\r\nbreak;\r\ncase CIE1:\r\nbreak;\r\ncase CIE2:\r\nbreak;\r\ncase CIE3:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int icp_multi_reset(struct comedi_device *dev)\r\n{\r\nstruct icp_multi_private *devpriv = dev->private;\r\nunsigned int i;\r\nwritew(0, dev->mmio + ICP_MULTI_INT_EN);\r\nwritew(0x00ff, dev->mmio + ICP_MULTI_INT_STAT);\r\nfor (i = 0; i < 4; i++) {\r\ndevpriv->DacCmdStatus &= 0xfcce;\r\ndevpriv->DacCmdStatus |= (i << 8);\r\nwritew(0, dev->mmio + ICP_MULTI_AO);\r\ndevpriv->DacCmdStatus |= DAC_ST;\r\nwritew(devpriv->DacCmdStatus, dev->mmio + ICP_MULTI_DAC_CSR);\r\nudelay(1);\r\n}\r\nwritew(0, dev->mmio + ICP_MULTI_DO);\r\nreturn 0;\r\n}\r\nstatic int icp_multi_auto_attach(struct comedi_device *dev,\r\nunsigned long context_unused)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nstruct icp_multi_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\ndev->mmio = pci_ioremap_bar(pcidev, 2);\r\nif (!dev->mmio)\r\nreturn -ENOMEM;\r\nret = comedi_alloc_subdevices(dev, 5);\r\nif (ret)\r\nreturn ret;\r\nicp_multi_reset(dev);\r\nif (pcidev->irq) {\r\nret = request_irq(pcidev->irq, interrupt_service_icp_multi,\r\nIRQF_SHARED, dev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = pcidev->irq;\r\n}\r\ns = &dev->subdevices[0];\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;\r\ns->n_chan = 16;\r\ns->maxdata = 0x0fff;\r\ns->len_chanlist = 16;\r\ns->range_table = &range_analog;\r\ns->insn_read = icp_multi_insn_read_ai;\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;\r\ns->n_chan = 4;\r\ns->maxdata = 0x0fff;\r\ns->len_chanlist = 4;\r\ns->range_table = &range_analog;\r\ns->insn_write = icp_multi_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 16;\r\ns->maxdata = 1;\r\ns->len_chanlist = 16;\r\ns->range_table = &range_digital;\r\ns->insn_bits = icp_multi_insn_bits_di;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 8;\r\ns->maxdata = 1;\r\ns->len_chanlist = 8;\r\ns->range_table = &range_digital;\r\ns->insn_bits = icp_multi_insn_bits_do;\r\ns = &dev->subdevices[4];\r\ns->type = COMEDI_SUBD_COUNTER;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 0xffff;\r\ns->len_chanlist = 4;\r\ns->state = 0;\r\ns->insn_read = icp_multi_insn_read_ctr;\r\ns->insn_write = icp_multi_insn_write_ctr;\r\nreturn 0;\r\n}\r\nstatic void icp_multi_detach(struct comedi_device *dev)\r\n{\r\nif (dev->mmio)\r\nicp_multi_reset(dev);\r\ncomedi_pci_detach(dev);\r\n}\r\nstatic int icp_multi_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &icp_multi_driver, id->driver_data);\r\n}
