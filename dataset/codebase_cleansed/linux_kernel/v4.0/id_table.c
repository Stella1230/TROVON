u32 c4iw_id_alloc(struct c4iw_id_table *alloc)\r\n{\r\nunsigned long flags;\r\nu32 obj;\r\nspin_lock_irqsave(&alloc->lock, flags);\r\nobj = find_next_zero_bit(alloc->table, alloc->max, alloc->last);\r\nif (obj >= alloc->max)\r\nobj = find_first_zero_bit(alloc->table, alloc->max);\r\nif (obj < alloc->max) {\r\nif (alloc->flags & C4IW_ID_TABLE_F_RANDOM)\r\nalloc->last += prandom_u32() % RANDOM_SKIP;\r\nelse\r\nalloc->last = obj + 1;\r\nif (alloc->last >= alloc->max)\r\nalloc->last = 0;\r\nset_bit(obj, alloc->table);\r\nobj += alloc->start;\r\n} else\r\nobj = -1;\r\nspin_unlock_irqrestore(&alloc->lock, flags);\r\nreturn obj;\r\n}\r\nvoid c4iw_id_free(struct c4iw_id_table *alloc, u32 obj)\r\n{\r\nunsigned long flags;\r\nobj -= alloc->start;\r\nBUG_ON((int)obj < 0);\r\nspin_lock_irqsave(&alloc->lock, flags);\r\nclear_bit(obj, alloc->table);\r\nspin_unlock_irqrestore(&alloc->lock, flags);\r\n}\r\nint c4iw_id_table_alloc(struct c4iw_id_table *alloc, u32 start, u32 num,\r\nu32 reserved, u32 flags)\r\n{\r\nint i;\r\nalloc->start = start;\r\nalloc->flags = flags;\r\nif (flags & C4IW_ID_TABLE_F_RANDOM)\r\nalloc->last = prandom_u32() % RANDOM_SKIP;\r\nelse\r\nalloc->last = 0;\r\nalloc->max = num;\r\nspin_lock_init(&alloc->lock);\r\nalloc->table = kmalloc(BITS_TO_LONGS(num) * sizeof(long),\r\nGFP_KERNEL);\r\nif (!alloc->table)\r\nreturn -ENOMEM;\r\nbitmap_zero(alloc->table, num);\r\nif (!(alloc->flags & C4IW_ID_TABLE_F_EMPTY))\r\nfor (i = 0; i < reserved; ++i)\r\nset_bit(i, alloc->table);\r\nreturn 0;\r\n}\r\nvoid c4iw_id_table_free(struct c4iw_id_table *alloc)\r\n{\r\nkfree(alloc->table);\r\n}
