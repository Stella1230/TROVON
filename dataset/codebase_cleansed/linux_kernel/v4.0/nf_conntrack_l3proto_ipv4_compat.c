static struct hlist_nulls_node *ct_get_first(struct seq_file *seq)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nstruct ct_iter_state *st = seq->private;\r\nstruct hlist_nulls_node *n;\r\nfor (st->bucket = 0;\r\nst->bucket < net->ct.htable_size;\r\nst->bucket++) {\r\nn = rcu_dereference(\r\nhlist_nulls_first_rcu(&net->ct.hash[st->bucket]));\r\nif (!is_a_nulls(n))\r\nreturn n;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct hlist_nulls_node *ct_get_next(struct seq_file *seq,\r\nstruct hlist_nulls_node *head)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nstruct ct_iter_state *st = seq->private;\r\nhead = rcu_dereference(hlist_nulls_next_rcu(head));\r\nwhile (is_a_nulls(head)) {\r\nif (likely(get_nulls_value(head) == st->bucket)) {\r\nif (++st->bucket >= net->ct.htable_size)\r\nreturn NULL;\r\n}\r\nhead = rcu_dereference(\r\nhlist_nulls_first_rcu(&net->ct.hash[st->bucket]));\r\n}\r\nreturn head;\r\n}\r\nstatic struct hlist_nulls_node *ct_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct hlist_nulls_node *head = ct_get_first(seq);\r\nif (head)\r\nwhile (pos && (head = ct_get_next(seq, head)))\r\npos--;\r\nreturn pos ? NULL : head;\r\n}\r\nstatic void *ct_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nrcu_read_lock();\r\nreturn ct_get_idx(seq, *pos);\r\n}\r\nstatic void *ct_seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn ct_get_next(s, v);\r\n}\r\nstatic void ct_seq_stop(struct seq_file *s, void *v)\r\n__releases(RCU)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic void ct_show_secctx(struct seq_file *s, const struct nf_conn *ct)\r\n{\r\nint ret;\r\nu32 len;\r\nchar *secctx;\r\nret = security_secid_to_secctx(ct->secmark, &secctx, &len);\r\nif (ret)\r\nreturn;\r\nseq_printf(s, "secctx=%s ", secctx);\r\nsecurity_release_secctx(secctx, len);\r\n}\r\nstatic inline void ct_show_secctx(struct seq_file *s, const struct nf_conn *ct)\r\n{\r\n}\r\nstatic int ct_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct nf_conntrack_tuple_hash *hash = v;\r\nstruct nf_conn *ct = nf_ct_tuplehash_to_ctrack(hash);\r\nconst struct nf_conntrack_l3proto *l3proto;\r\nconst struct nf_conntrack_l4proto *l4proto;\r\nint ret = 0;\r\nNF_CT_ASSERT(ct);\r\nif (unlikely(!atomic_inc_not_zero(&ct->ct_general.use)))\r\nreturn 0;\r\nif (NF_CT_DIRECTION(hash))\r\ngoto release;\r\nif (nf_ct_l3num(ct) != AF_INET)\r\ngoto release;\r\nl3proto = __nf_ct_l3proto_find(nf_ct_l3num(ct));\r\nNF_CT_ASSERT(l3proto);\r\nl4proto = __nf_ct_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));\r\nNF_CT_ASSERT(l4proto);\r\nret = -ENOSPC;\r\nseq_printf(s, "%-8s %u %ld ",\r\nl4proto->name, nf_ct_protonum(ct),\r\ntimer_pending(&ct->timeout)\r\n? (long)(ct->timeout.expires - jiffies)/HZ : 0);\r\nif (l4proto->print_conntrack)\r\nl4proto->print_conntrack(s, ct);\r\nif (seq_has_overflowed(s))\r\ngoto release;\r\nprint_tuple(s, &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple,\r\nl3proto, l4proto);\r\nif (seq_has_overflowed(s))\r\ngoto release;\r\nif (seq_print_acct(s, ct, IP_CT_DIR_ORIGINAL))\r\ngoto release;\r\nif (!(test_bit(IPS_SEEN_REPLY_BIT, &ct->status)))\r\nseq_printf(s, "[UNREPLIED] ");\r\nprint_tuple(s, &ct->tuplehash[IP_CT_DIR_REPLY].tuple,\r\nl3proto, l4proto);\r\nif (seq_has_overflowed(s))\r\ngoto release;\r\nif (seq_print_acct(s, ct, IP_CT_DIR_REPLY))\r\ngoto release;\r\nif (test_bit(IPS_ASSURED_BIT, &ct->status))\r\nseq_printf(s, "[ASSURED] ");\r\n#ifdef CONFIG_NF_CONNTRACK_MARK\r\nseq_printf(s, "mark=%u ", ct->mark);\r\n#endif\r\nct_show_secctx(s, ct);\r\nseq_printf(s, "use=%u\n", atomic_read(&ct->ct_general.use));\r\nif (seq_has_overflowed(s))\r\ngoto release;\r\nret = 0;\r\nrelease:\r\nnf_ct_put(ct);\r\nreturn ret;\r\n}\r\nstatic int ct_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &ct_seq_ops,\r\nsizeof(struct ct_iter_state));\r\n}\r\nstatic struct hlist_node *ct_expect_get_first(struct seq_file *seq)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nstruct ct_expect_iter_state *st = seq->private;\r\nstruct hlist_node *n;\r\nfor (st->bucket = 0; st->bucket < nf_ct_expect_hsize; st->bucket++) {\r\nn = rcu_dereference(\r\nhlist_first_rcu(&net->ct.expect_hash[st->bucket]));\r\nif (n)\r\nreturn n;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct hlist_node *ct_expect_get_next(struct seq_file *seq,\r\nstruct hlist_node *head)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nstruct ct_expect_iter_state *st = seq->private;\r\nhead = rcu_dereference(hlist_next_rcu(head));\r\nwhile (head == NULL) {\r\nif (++st->bucket >= nf_ct_expect_hsize)\r\nreturn NULL;\r\nhead = rcu_dereference(\r\nhlist_first_rcu(&net->ct.expect_hash[st->bucket]));\r\n}\r\nreturn head;\r\n}\r\nstatic struct hlist_node *ct_expect_get_idx(struct seq_file *seq, loff_t pos)\r\n{\r\nstruct hlist_node *head = ct_expect_get_first(seq);\r\nif (head)\r\nwhile (pos && (head = ct_expect_get_next(seq, head)))\r\npos--;\r\nreturn pos ? NULL : head;\r\n}\r\nstatic void *exp_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nrcu_read_lock();\r\nreturn ct_expect_get_idx(seq, *pos);\r\n}\r\nstatic void *exp_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn ct_expect_get_next(seq, v);\r\n}\r\nstatic void exp_seq_stop(struct seq_file *seq, void *v)\r\n__releases(RCU)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic int exp_seq_show(struct seq_file *s, void *v)\r\n{\r\nstruct nf_conntrack_expect *exp;\r\nconst struct hlist_node *n = v;\r\nexp = hlist_entry(n, struct nf_conntrack_expect, hnode);\r\nif (exp->tuple.src.l3num != AF_INET)\r\nreturn 0;\r\nif (exp->timeout.function)\r\nseq_printf(s, "%ld ", timer_pending(&exp->timeout)\r\n? (long)(exp->timeout.expires - jiffies)/HZ : 0);\r\nelse\r\nseq_printf(s, "- ");\r\nseq_printf(s, "proto=%u ", exp->tuple.dst.protonum);\r\nprint_tuple(s, &exp->tuple,\r\n__nf_ct_l3proto_find(exp->tuple.src.l3num),\r\n__nf_ct_l4proto_find(exp->tuple.src.l3num,\r\nexp->tuple.dst.protonum));\r\nreturn seq_putc(s, '\n');\r\n}\r\nstatic int exp_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &exp_seq_ops,\r\nsizeof(struct ct_expect_iter_state));\r\n}\r\nstatic void *ct_cpu_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nint cpu;\r\nif (*pos == 0)\r\nreturn SEQ_START_TOKEN;\r\nfor (cpu = *pos-1; cpu < nr_cpu_ids; ++cpu) {\r\nif (!cpu_possible(cpu))\r\ncontinue;\r\n*pos = cpu+1;\r\nreturn per_cpu_ptr(net->ct.stat, cpu);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *ct_cpu_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nint cpu;\r\nfor (cpu = *pos; cpu < nr_cpu_ids; ++cpu) {\r\nif (!cpu_possible(cpu))\r\ncontinue;\r\n*pos = cpu+1;\r\nreturn per_cpu_ptr(net->ct.stat, cpu);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void ct_cpu_seq_stop(struct seq_file *seq, void *v)\r\n{\r\n}\r\nstatic int ct_cpu_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nunsigned int nr_conntracks = atomic_read(&net->ct.count);\r\nconst struct ip_conntrack_stat *st = v;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_printf(seq, "entries searched found new invalid ignore delete delete_list insert insert_failed drop early_drop icmp_error expect_new expect_create expect_delete search_restart\n");\r\nreturn 0;\r\n}\r\nseq_printf(seq, "%08x %08x %08x %08x %08x %08x %08x %08x "\r\n"%08x %08x %08x %08x %08x %08x %08x %08x %08x\n",\r\nnr_conntracks,\r\nst->searched,\r\nst->found,\r\nst->new,\r\nst->invalid,\r\nst->ignore,\r\nst->delete,\r\nst->delete_list,\r\nst->insert,\r\nst->insert_failed,\r\nst->drop,\r\nst->early_drop,\r\nst->error,\r\nst->expect_new,\r\nst->expect_create,\r\nst->expect_delete,\r\nst->search_restart\r\n);\r\nreturn 0;\r\n}\r\nstatic int ct_cpu_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &ct_cpu_seq_ops,\r\nsizeof(struct seq_net_private));\r\n}\r\nstatic int __net_init ip_conntrack_net_init(struct net *net)\r\n{\r\nstruct proc_dir_entry *proc, *proc_exp, *proc_stat;\r\nproc = proc_create("ip_conntrack", 0440, net->proc_net, &ct_file_ops);\r\nif (!proc)\r\ngoto err1;\r\nproc_exp = proc_create("ip_conntrack_expect", 0440, net->proc_net,\r\n&ip_exp_file_ops);\r\nif (!proc_exp)\r\ngoto err2;\r\nproc_stat = proc_create("ip_conntrack", S_IRUGO,\r\nnet->proc_net_stat, &ct_cpu_seq_fops);\r\nif (!proc_stat)\r\ngoto err3;\r\nreturn 0;\r\nerr3:\r\nremove_proc_entry("ip_conntrack_expect", net->proc_net);\r\nerr2:\r\nremove_proc_entry("ip_conntrack", net->proc_net);\r\nerr1:\r\nreturn -ENOMEM;\r\n}\r\nstatic void __net_exit ip_conntrack_net_exit(struct net *net)\r\n{\r\nremove_proc_entry("ip_conntrack", net->proc_net_stat);\r\nremove_proc_entry("ip_conntrack_expect", net->proc_net);\r\nremove_proc_entry("ip_conntrack", net->proc_net);\r\n}\r\nint __init nf_conntrack_ipv4_compat_init(void)\r\n{\r\nreturn register_pernet_subsys(&ip_conntrack_net_ops);\r\n}\r\nvoid __exit nf_conntrack_ipv4_compat_fini(void)\r\n{\r\nunregister_pernet_subsys(&ip_conntrack_net_ops);\r\n}
