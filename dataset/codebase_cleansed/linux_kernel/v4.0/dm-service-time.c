static struct selector *alloc_selector(void)\r\n{\r\nstruct selector *s = kmalloc(sizeof(*s), GFP_KERNEL);\r\nif (s) {\r\nINIT_LIST_HEAD(&s->valid_paths);\r\nINIT_LIST_HEAD(&s->failed_paths);\r\n}\r\nreturn s;\r\n}\r\nstatic int st_create(struct path_selector *ps, unsigned argc, char **argv)\r\n{\r\nstruct selector *s = alloc_selector();\r\nif (!s)\r\nreturn -ENOMEM;\r\nps->context = s;\r\nreturn 0;\r\n}\r\nstatic void free_paths(struct list_head *paths)\r\n{\r\nstruct path_info *pi, *next;\r\nlist_for_each_entry_safe(pi, next, paths, list) {\r\nlist_del(&pi->list);\r\nkfree(pi);\r\n}\r\n}\r\nstatic void st_destroy(struct path_selector *ps)\r\n{\r\nstruct selector *s = ps->context;\r\nfree_paths(&s->valid_paths);\r\nfree_paths(&s->failed_paths);\r\nkfree(s);\r\nps->context = NULL;\r\n}\r\nstatic int st_status(struct path_selector *ps, struct dm_path *path,\r\nstatus_type_t type, char *result, unsigned maxlen)\r\n{\r\nunsigned sz = 0;\r\nstruct path_info *pi;\r\nif (!path)\r\nDMEMIT("0 ");\r\nelse {\r\npi = path->pscontext;\r\nswitch (type) {\r\ncase STATUSTYPE_INFO:\r\nDMEMIT("%d %u ", atomic_read(&pi->in_flight_size),\r\npi->relative_throughput);\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\nDMEMIT("%u %u ", pi->repeat_count,\r\npi->relative_throughput);\r\nbreak;\r\n}\r\n}\r\nreturn sz;\r\n}\r\nstatic int st_add_path(struct path_selector *ps, struct dm_path *path,\r\nint argc, char **argv, char **error)\r\n{\r\nstruct selector *s = ps->context;\r\nstruct path_info *pi;\r\nunsigned repeat_count = ST_MIN_IO;\r\nunsigned relative_throughput = 1;\r\nchar dummy;\r\nif (argc > 2) {\r\n*error = "service-time ps: incorrect number of arguments";\r\nreturn -EINVAL;\r\n}\r\nif (argc && (sscanf(argv[0], "%u%c", &repeat_count, &dummy) != 1)) {\r\n*error = "service-time ps: invalid repeat count";\r\nreturn -EINVAL;\r\n}\r\nif ((argc == 2) &&\r\n(sscanf(argv[1], "%u%c", &relative_throughput, &dummy) != 1 ||\r\nrelative_throughput > ST_MAX_RELATIVE_THROUGHPUT)) {\r\n*error = "service-time ps: invalid relative_throughput value";\r\nreturn -EINVAL;\r\n}\r\npi = kmalloc(sizeof(*pi), GFP_KERNEL);\r\nif (!pi) {\r\n*error = "service-time ps: Error allocating path context";\r\nreturn -ENOMEM;\r\n}\r\npi->path = path;\r\npi->repeat_count = repeat_count;\r\npi->relative_throughput = relative_throughput;\r\natomic_set(&pi->in_flight_size, 0);\r\npath->pscontext = pi;\r\nlist_add_tail(&pi->list, &s->valid_paths);\r\nreturn 0;\r\n}\r\nstatic void st_fail_path(struct path_selector *ps, struct dm_path *path)\r\n{\r\nstruct selector *s = ps->context;\r\nstruct path_info *pi = path->pscontext;\r\nlist_move(&pi->list, &s->failed_paths);\r\n}\r\nstatic int st_reinstate_path(struct path_selector *ps, struct dm_path *path)\r\n{\r\nstruct selector *s = ps->context;\r\nstruct path_info *pi = path->pscontext;\r\nlist_move_tail(&pi->list, &s->valid_paths);\r\nreturn 0;\r\n}\r\nstatic int st_compare_load(struct path_info *pi1, struct path_info *pi2,\r\nsize_t incoming)\r\n{\r\nsize_t sz1, sz2, st1, st2;\r\nsz1 = atomic_read(&pi1->in_flight_size);\r\nsz2 = atomic_read(&pi2->in_flight_size);\r\nif (pi1->relative_throughput == pi2->relative_throughput)\r\nreturn sz1 - sz2;\r\nif (sz1 == sz2 ||\r\n!pi1->relative_throughput || !pi2->relative_throughput)\r\nreturn pi2->relative_throughput - pi1->relative_throughput;\r\nsz1 += incoming;\r\nsz2 += incoming;\r\nif (unlikely(sz1 >= ST_MAX_INFLIGHT_SIZE ||\r\nsz2 >= ST_MAX_INFLIGHT_SIZE)) {\r\nsz1 >>= ST_MAX_RELATIVE_THROUGHPUT_SHIFT;\r\nsz2 >>= ST_MAX_RELATIVE_THROUGHPUT_SHIFT;\r\n}\r\nst1 = sz1 * pi2->relative_throughput;\r\nst2 = sz2 * pi1->relative_throughput;\r\nif (st1 != st2)\r\nreturn st1 - st2;\r\nreturn pi2->relative_throughput - pi1->relative_throughput;\r\n}\r\nstatic struct dm_path *st_select_path(struct path_selector *ps,\r\nunsigned *repeat_count, size_t nr_bytes)\r\n{\r\nstruct selector *s = ps->context;\r\nstruct path_info *pi = NULL, *best = NULL;\r\nif (list_empty(&s->valid_paths))\r\nreturn NULL;\r\nlist_move_tail(s->valid_paths.next, &s->valid_paths);\r\nlist_for_each_entry(pi, &s->valid_paths, list)\r\nif (!best || (st_compare_load(pi, best, nr_bytes) < 0))\r\nbest = pi;\r\nif (!best)\r\nreturn NULL;\r\n*repeat_count = best->repeat_count;\r\nreturn best->path;\r\n}\r\nstatic int st_start_io(struct path_selector *ps, struct dm_path *path,\r\nsize_t nr_bytes)\r\n{\r\nstruct path_info *pi = path->pscontext;\r\natomic_add(nr_bytes, &pi->in_flight_size);\r\nreturn 0;\r\n}\r\nstatic int st_end_io(struct path_selector *ps, struct dm_path *path,\r\nsize_t nr_bytes)\r\n{\r\nstruct path_info *pi = path->pscontext;\r\natomic_sub(nr_bytes, &pi->in_flight_size);\r\nreturn 0;\r\n}\r\nstatic int __init dm_st_init(void)\r\n{\r\nint r = dm_register_path_selector(&st_ps);\r\nif (r < 0)\r\nDMERR("register failed %d", r);\r\nDMINFO("version " ST_VERSION " loaded");\r\nreturn r;\r\n}\r\nstatic void __exit dm_st_exit(void)\r\n{\r\nint r = dm_unregister_path_selector(&st_ps);\r\nif (r < 0)\r\nDMERR("unregister failed %d", r);\r\n}
