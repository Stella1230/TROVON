static unsigned at91_twi_read(struct at91_twi_dev *dev, unsigned reg)\r\n{\r\nreturn readl_relaxed(dev->base + reg);\r\n}\r\nstatic void at91_twi_write(struct at91_twi_dev *dev, unsigned reg, unsigned val)\r\n{\r\nwritel_relaxed(val, dev->base + reg);\r\n}\r\nstatic void at91_disable_twi_interrupts(struct at91_twi_dev *dev)\r\n{\r\nat91_twi_write(dev, AT91_TWI_IDR,\r\nAT91_TWI_TXCOMP | AT91_TWI_RXRDY | AT91_TWI_TXRDY);\r\n}\r\nstatic void at91_twi_irq_save(struct at91_twi_dev *dev)\r\n{\r\ndev->imr = at91_twi_read(dev, AT91_TWI_IMR) & 0x7;\r\nat91_disable_twi_interrupts(dev);\r\n}\r\nstatic void at91_twi_irq_restore(struct at91_twi_dev *dev)\r\n{\r\nat91_twi_write(dev, AT91_TWI_IER, dev->imr);\r\n}\r\nstatic void at91_init_twi_bus(struct at91_twi_dev *dev)\r\n{\r\nat91_disable_twi_interrupts(dev);\r\nat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_SWRST);\r\nat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_MSEN);\r\nat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_SVDIS);\r\nat91_twi_write(dev, AT91_TWI_CWGR, dev->twi_cwgr_reg);\r\n}\r\nstatic void at91_calc_twi_clock(struct at91_twi_dev *dev, int twi_clk)\r\n{\r\nint ckdiv, cdiv, div;\r\nstruct at91_twi_pdata *pdata = dev->pdata;\r\nint offset = pdata->clk_offset;\r\nint max_ckdiv = pdata->clk_max_div;\r\ndiv = max(0, (int)DIV_ROUND_UP(clk_get_rate(dev->clk),\r\n2 * twi_clk) - offset);\r\nckdiv = fls(div >> 8);\r\ncdiv = div >> ckdiv;\r\nif (ckdiv > max_ckdiv) {\r\ndev_warn(dev->dev, "%d exceeds ckdiv max value which is %d.\n",\r\nckdiv, max_ckdiv);\r\nckdiv = max_ckdiv;\r\ncdiv = 255;\r\n}\r\ndev->twi_cwgr_reg = (ckdiv << 16) | (cdiv << 8) | cdiv;\r\ndev_dbg(dev->dev, "cdiv %d ckdiv %d\n", cdiv, ckdiv);\r\n}\r\nstatic void at91_twi_dma_cleanup(struct at91_twi_dev *dev)\r\n{\r\nstruct at91_twi_dma *dma = &dev->dma;\r\nat91_twi_irq_save(dev);\r\nif (dma->xfer_in_progress) {\r\nif (dma->direction == DMA_FROM_DEVICE)\r\ndmaengine_terminate_all(dma->chan_rx);\r\nelse\r\ndmaengine_terminate_all(dma->chan_tx);\r\ndma->xfer_in_progress = false;\r\n}\r\nif (dma->buf_mapped) {\r\ndma_unmap_single(dev->dev, sg_dma_address(&dma->sg),\r\ndev->buf_len, dma->direction);\r\ndma->buf_mapped = false;\r\n}\r\nat91_twi_irq_restore(dev);\r\n}\r\nstatic void at91_twi_write_next_byte(struct at91_twi_dev *dev)\r\n{\r\nif (dev->buf_len <= 0)\r\nreturn;\r\nat91_twi_write(dev, AT91_TWI_THR, *dev->buf);\r\nif (--dev->buf_len == 0)\r\nat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_STOP);\r\ndev_dbg(dev->dev, "wrote 0x%x, to go %d\n", *dev->buf, dev->buf_len);\r\n++dev->buf;\r\n}\r\nstatic void at91_twi_write_data_dma_callback(void *data)\r\n{\r\nstruct at91_twi_dev *dev = (struct at91_twi_dev *)data;\r\ndma_unmap_single(dev->dev, sg_dma_address(&dev->dma.sg),\r\ndev->buf_len, DMA_TO_DEVICE);\r\nat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_STOP);\r\n}\r\nstatic void at91_twi_write_data_dma(struct at91_twi_dev *dev)\r\n{\r\ndma_addr_t dma_addr;\r\nstruct dma_async_tx_descriptor *txdesc;\r\nstruct at91_twi_dma *dma = &dev->dma;\r\nstruct dma_chan *chan_tx = dma->chan_tx;\r\nif (dev->buf_len <= 0)\r\nreturn;\r\ndma->direction = DMA_TO_DEVICE;\r\nat91_twi_irq_save(dev);\r\ndma_addr = dma_map_single(dev->dev, dev->buf, dev->buf_len,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(dev->dev, dma_addr)) {\r\ndev_err(dev->dev, "dma map failed\n");\r\nreturn;\r\n}\r\ndma->buf_mapped = true;\r\nat91_twi_irq_restore(dev);\r\nsg_dma_len(&dma->sg) = dev->buf_len;\r\nsg_dma_address(&dma->sg) = dma_addr;\r\ntxdesc = dmaengine_prep_slave_sg(chan_tx, &dma->sg, 1, DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!txdesc) {\r\ndev_err(dev->dev, "dma prep slave sg failed\n");\r\ngoto error;\r\n}\r\ntxdesc->callback = at91_twi_write_data_dma_callback;\r\ntxdesc->callback_param = dev;\r\ndma->xfer_in_progress = true;\r\ndmaengine_submit(txdesc);\r\ndma_async_issue_pending(chan_tx);\r\nreturn;\r\nerror:\r\nat91_twi_dma_cleanup(dev);\r\n}\r\nstatic void at91_twi_read_next_byte(struct at91_twi_dev *dev)\r\n{\r\nif (dev->buf_len <= 0)\r\nreturn;\r\n*dev->buf = at91_twi_read(dev, AT91_TWI_RHR) & 0xff;\r\n--dev->buf_len;\r\nif (dev->recv_len_abort)\r\nreturn;\r\nif (unlikely(dev->msg->flags & I2C_M_RECV_LEN)) {\r\nif (*dev->buf <= I2C_SMBUS_BLOCK_MAX && *dev->buf > 0) {\r\ndev->msg->flags &= ~I2C_M_RECV_LEN;\r\ndev->buf_len += *dev->buf;\r\ndev->msg->len = dev->buf_len + 1;\r\ndev_dbg(dev->dev, "received block length %d\n",\r\ndev->buf_len);\r\n} else {\r\ndev->recv_len_abort = true;\r\ndev->buf_len = 1;\r\n}\r\n}\r\nif (dev->buf_len == 1)\r\nat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_STOP);\r\ndev_dbg(dev->dev, "read 0x%x, to go %d\n", *dev->buf, dev->buf_len);\r\n++dev->buf;\r\n}\r\nstatic void at91_twi_read_data_dma_callback(void *data)\r\n{\r\nstruct at91_twi_dev *dev = (struct at91_twi_dev *)data;\r\ndma_unmap_single(dev->dev, sg_dma_address(&dev->dma.sg),\r\ndev->buf_len, DMA_FROM_DEVICE);\r\ndev->buf += dev->buf_len - 2;\r\ndev->buf_len = 2;\r\nat91_twi_write(dev, AT91_TWI_IER, AT91_TWI_RXRDY);\r\n}\r\nstatic void at91_twi_read_data_dma(struct at91_twi_dev *dev)\r\n{\r\ndma_addr_t dma_addr;\r\nstruct dma_async_tx_descriptor *rxdesc;\r\nstruct at91_twi_dma *dma = &dev->dma;\r\nstruct dma_chan *chan_rx = dma->chan_rx;\r\ndma->direction = DMA_FROM_DEVICE;\r\nat91_twi_irq_save(dev);\r\ndma_addr = dma_map_single(dev->dev, dev->buf, dev->buf_len - 2,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(dev->dev, dma_addr)) {\r\ndev_err(dev->dev, "dma map failed\n");\r\nreturn;\r\n}\r\ndma->buf_mapped = true;\r\nat91_twi_irq_restore(dev);\r\ndma->sg.dma_address = dma_addr;\r\nsg_dma_len(&dma->sg) = dev->buf_len - 2;\r\nrxdesc = dmaengine_prep_slave_sg(chan_rx, &dma->sg, 1, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!rxdesc) {\r\ndev_err(dev->dev, "dma prep slave sg failed\n");\r\ngoto error;\r\n}\r\nrxdesc->callback = at91_twi_read_data_dma_callback;\r\nrxdesc->callback_param = dev;\r\ndma->xfer_in_progress = true;\r\ndmaengine_submit(rxdesc);\r\ndma_async_issue_pending(dma->chan_rx);\r\nreturn;\r\nerror:\r\nat91_twi_dma_cleanup(dev);\r\n}\r\nstatic irqreturn_t atmel_twi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct at91_twi_dev *dev = dev_id;\r\nconst unsigned status = at91_twi_read(dev, AT91_TWI_SR);\r\nconst unsigned irqstatus = status & at91_twi_read(dev, AT91_TWI_IMR);\r\nif (!irqstatus)\r\nreturn IRQ_NONE;\r\nelse if (irqstatus & AT91_TWI_RXRDY)\r\nat91_twi_read_next_byte(dev);\r\nelse if (irqstatus & AT91_TWI_TXRDY)\r\nat91_twi_write_next_byte(dev);\r\ndev->transfer_status |= status;\r\nif (irqstatus & AT91_TWI_TXCOMP) {\r\nat91_disable_twi_interrupts(dev);\r\ncomplete(&dev->cmd_complete);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int at91_do_twi_transfer(struct at91_twi_dev *dev)\r\n{\r\nint ret;\r\nbool has_unre_flag = dev->pdata->has_unre_flag;\r\ndev_dbg(dev->dev, "transfer: %s %d bytes.\n",\r\n(dev->msg->flags & I2C_M_RD) ? "read" : "write", dev->buf_len);\r\nreinit_completion(&dev->cmd_complete);\r\ndev->transfer_status = 0;\r\nif (!dev->buf_len) {\r\nat91_twi_write(dev, AT91_TWI_CR, AT91_TWI_QUICK);\r\nat91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);\r\n} else if (dev->msg->flags & I2C_M_RD) {\r\nunsigned start_flags = AT91_TWI_START;\r\nif (at91_twi_read(dev, AT91_TWI_SR) & AT91_TWI_RXRDY) {\r\ndev_err(dev->dev, "RXRDY still set!");\r\nat91_twi_read(dev, AT91_TWI_RHR);\r\n}\r\nif (dev->buf_len <= 1 && !(dev->msg->flags & I2C_M_RECV_LEN))\r\nstart_flags |= AT91_TWI_STOP;\r\nat91_twi_write(dev, AT91_TWI_CR, start_flags);\r\nif (dev->use_dma && (dev->buf_len > AT91_I2C_DMA_THRESHOLD)) {\r\nat91_twi_read_data_dma(dev);\r\nat91_twi_write(dev, AT91_TWI_IER,\r\nAT91_TWI_TXCOMP);\r\n} else\r\nat91_twi_write(dev, AT91_TWI_IER,\r\nAT91_TWI_TXCOMP | AT91_TWI_RXRDY);\r\n} else {\r\nif (dev->use_dma && (dev->buf_len > AT91_I2C_DMA_THRESHOLD)) {\r\nat91_twi_write_data_dma(dev);\r\nat91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);\r\n} else {\r\nat91_twi_write_next_byte(dev);\r\nat91_twi_write(dev, AT91_TWI_IER,\r\nAT91_TWI_TXCOMP | AT91_TWI_TXRDY);\r\n}\r\n}\r\nret = wait_for_completion_timeout(&dev->cmd_complete,\r\ndev->adapter.timeout);\r\nif (ret == 0) {\r\ndev_err(dev->dev, "controller timed out\n");\r\nat91_init_twi_bus(dev);\r\nret = -ETIMEDOUT;\r\ngoto error;\r\n}\r\nif (dev->transfer_status & AT91_TWI_NACK) {\r\ndev_dbg(dev->dev, "received nack\n");\r\nret = -EREMOTEIO;\r\ngoto error;\r\n}\r\nif (dev->transfer_status & AT91_TWI_OVRE) {\r\ndev_err(dev->dev, "overrun while reading\n");\r\nret = -EIO;\r\ngoto error;\r\n}\r\nif (has_unre_flag && dev->transfer_status & AT91_TWI_UNRE) {\r\ndev_err(dev->dev, "underrun while writing\n");\r\nret = -EIO;\r\ngoto error;\r\n}\r\nif (dev->recv_len_abort) {\r\ndev_err(dev->dev, "invalid smbus block length recvd\n");\r\nret = -EPROTO;\r\ngoto error;\r\n}\r\ndev_dbg(dev->dev, "transfer complete\n");\r\nreturn 0;\r\nerror:\r\nat91_twi_dma_cleanup(dev);\r\nreturn ret;\r\n}\r\nstatic int at91_twi_xfer(struct i2c_adapter *adap, struct i2c_msg *msg, int num)\r\n{\r\nstruct at91_twi_dev *dev = i2c_get_adapdata(adap);\r\nint ret;\r\nunsigned int_addr_flag = 0;\r\nstruct i2c_msg *m_start = msg;\r\ndev_dbg(&adap->dev, "at91_xfer: processing %d messages:\n", num);\r\nret = pm_runtime_get_sync(dev->dev);\r\nif (ret < 0)\r\ngoto out;\r\nif (num > 2) {\r\ndev_err(dev->dev,\r\n"cannot handle more than two concatenated messages.\n");\r\nret = 0;\r\ngoto out;\r\n} else if (num == 2) {\r\nint internal_address = 0;\r\nint i;\r\nif (msg->flags & I2C_M_RD) {\r\ndev_err(dev->dev, "first transfer must be write.\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (msg->len > 3) {\r\ndev_err(dev->dev, "first message size must be <= 3.\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nm_start = &msg[1];\r\nfor (i = 0; i < msg->len; ++i) {\r\nconst unsigned addr = msg->buf[msg->len - 1 - i];\r\ninternal_address |= addr << (8 * i);\r\nint_addr_flag += AT91_TWI_IADRSZ_1;\r\n}\r\nat91_twi_write(dev, AT91_TWI_IADR, internal_address);\r\n}\r\nat91_twi_write(dev, AT91_TWI_MMR, (m_start->addr << 16) | int_addr_flag\r\n| ((m_start->flags & I2C_M_RD) ? AT91_TWI_MREAD : 0));\r\ndev->buf_len = m_start->len;\r\ndev->buf = m_start->buf;\r\ndev->msg = m_start;\r\ndev->recv_len_abort = false;\r\nret = at91_do_twi_transfer(dev);\r\nret = (ret < 0) ? ret : num;\r\nout:\r\npm_runtime_mark_last_busy(dev->dev);\r\npm_runtime_put_autosuspend(dev->dev);\r\nreturn ret;\r\n}\r\nstatic u32 at91_twi_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL\r\n| I2C_FUNC_SMBUS_READ_BLOCK_DATA;\r\n}\r\nstatic int at91_twi_configure_dma(struct at91_twi_dev *dev, u32 phy_addr)\r\n{\r\nint ret = 0;\r\nstruct dma_slave_config slave_config;\r\nstruct at91_twi_dma *dma = &dev->dma;\r\nmemset(&slave_config, 0, sizeof(slave_config));\r\nslave_config.src_addr = (dma_addr_t)phy_addr + AT91_TWI_RHR;\r\nslave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nslave_config.src_maxburst = 1;\r\nslave_config.dst_addr = (dma_addr_t)phy_addr + AT91_TWI_THR;\r\nslave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nslave_config.dst_maxburst = 1;\r\nslave_config.device_fc = false;\r\ndma->chan_tx = dma_request_slave_channel_reason(dev->dev, "tx");\r\nif (IS_ERR(dma->chan_tx)) {\r\nret = PTR_ERR(dma->chan_tx);\r\ndma->chan_tx = NULL;\r\ngoto error;\r\n}\r\ndma->chan_rx = dma_request_slave_channel_reason(dev->dev, "rx");\r\nif (IS_ERR(dma->chan_rx)) {\r\nret = PTR_ERR(dma->chan_rx);\r\ndma->chan_rx = NULL;\r\ngoto error;\r\n}\r\nslave_config.direction = DMA_MEM_TO_DEV;\r\nif (dmaengine_slave_config(dma->chan_tx, &slave_config)) {\r\ndev_err(dev->dev, "failed to configure tx channel\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nslave_config.direction = DMA_DEV_TO_MEM;\r\nif (dmaengine_slave_config(dma->chan_rx, &slave_config)) {\r\ndev_err(dev->dev, "failed to configure rx channel\n");\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nsg_init_table(&dma->sg, 1);\r\ndma->buf_mapped = false;\r\ndma->xfer_in_progress = false;\r\ndev->use_dma = true;\r\ndev_info(dev->dev, "using %s (tx) and %s (rx) for DMA transfers\n",\r\ndma_chan_name(dma->chan_tx), dma_chan_name(dma->chan_rx));\r\nreturn ret;\r\nerror:\r\nif (ret != -EPROBE_DEFER)\r\ndev_info(dev->dev, "can't use DMA, error %d\n", ret);\r\nif (dma->chan_rx)\r\ndma_release_channel(dma->chan_rx);\r\nif (dma->chan_tx)\r\ndma_release_channel(dma->chan_tx);\r\nreturn ret;\r\n}\r\nstatic struct at91_twi_pdata *at91_twi_get_driver_data(\r\nstruct platform_device *pdev)\r\n{\r\nif (pdev->dev.of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(atmel_twi_dt_ids, pdev->dev.of_node);\r\nif (!match)\r\nreturn NULL;\r\nreturn (struct at91_twi_pdata *)match->data;\r\n}\r\nreturn (struct at91_twi_pdata *) platform_get_device_id(pdev)->driver_data;\r\n}\r\nstatic int at91_twi_probe(struct platform_device *pdev)\r\n{\r\nstruct at91_twi_dev *dev;\r\nstruct resource *mem;\r\nint rc;\r\nu32 phy_addr;\r\nu32 bus_clk_rate;\r\ndev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ninit_completion(&dev->cmd_complete);\r\ndev->dev = &pdev->dev;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem)\r\nreturn -ENODEV;\r\nphy_addr = mem->start;\r\ndev->pdata = at91_twi_get_driver_data(pdev);\r\nif (!dev->pdata)\r\nreturn -ENODEV;\r\ndev->base = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(dev->base))\r\nreturn PTR_ERR(dev->base);\r\ndev->irq = platform_get_irq(pdev, 0);\r\nif (dev->irq < 0)\r\nreturn dev->irq;\r\nrc = devm_request_irq(&pdev->dev, dev->irq, atmel_twi_interrupt, 0,\r\ndev_name(dev->dev), dev);\r\nif (rc) {\r\ndev_err(dev->dev, "Cannot get irq %d: %d\n", dev->irq, rc);\r\nreturn rc;\r\n}\r\nplatform_set_drvdata(pdev, dev);\r\ndev->clk = devm_clk_get(dev->dev, NULL);\r\nif (IS_ERR(dev->clk)) {\r\ndev_err(dev->dev, "no clock defined\n");\r\nreturn -ENODEV;\r\n}\r\nclk_prepare_enable(dev->clk);\r\nif (dev->dev->of_node) {\r\nrc = at91_twi_configure_dma(dev, phy_addr);\r\nif (rc == -EPROBE_DEFER)\r\nreturn rc;\r\n}\r\nrc = of_property_read_u32(dev->dev->of_node, "clock-frequency",\r\n&bus_clk_rate);\r\nif (rc)\r\nbus_clk_rate = DEFAULT_TWI_CLK_HZ;\r\nat91_calc_twi_clock(dev, bus_clk_rate);\r\nat91_init_twi_bus(dev);\r\nsnprintf(dev->adapter.name, sizeof(dev->adapter.name), "AT91");\r\ni2c_set_adapdata(&dev->adapter, dev);\r\ndev->adapter.owner = THIS_MODULE;\r\ndev->adapter.class = I2C_CLASS_DEPRECATED;\r\ndev->adapter.algo = &at91_twi_algorithm;\r\ndev->adapter.dev.parent = dev->dev;\r\ndev->adapter.nr = pdev->id;\r\ndev->adapter.timeout = AT91_I2C_TIMEOUT;\r\ndev->adapter.dev.of_node = pdev->dev.of_node;\r\npm_runtime_set_autosuspend_delay(dev->dev, AUTOSUSPEND_TIMEOUT);\r\npm_runtime_use_autosuspend(dev->dev);\r\npm_runtime_set_active(dev->dev);\r\npm_runtime_enable(dev->dev);\r\nrc = i2c_add_numbered_adapter(&dev->adapter);\r\nif (rc) {\r\ndev_err(dev->dev, "Adapter %s registration failed\n",\r\ndev->adapter.name);\r\nclk_disable_unprepare(dev->clk);\r\npm_runtime_disable(dev->dev);\r\npm_runtime_set_suspended(dev->dev);\r\nreturn rc;\r\n}\r\ndev_info(dev->dev, "AT91 i2c bus driver.\n");\r\nreturn 0;\r\n}\r\nstatic int at91_twi_remove(struct platform_device *pdev)\r\n{\r\nstruct at91_twi_dev *dev = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&dev->adapter);\r\nclk_disable_unprepare(dev->clk);\r\npm_runtime_disable(dev->dev);\r\npm_runtime_set_suspended(dev->dev);\r\nreturn 0;\r\n}\r\nstatic int at91_twi_runtime_suspend(struct device *dev)\r\n{\r\nstruct at91_twi_dev *twi_dev = dev_get_drvdata(dev);\r\nclk_disable_unprepare(twi_dev->clk);\r\npinctrl_pm_select_sleep_state(dev);\r\nreturn 0;\r\n}\r\nstatic int at91_twi_runtime_resume(struct device *dev)\r\n{\r\nstruct at91_twi_dev *twi_dev = dev_get_drvdata(dev);\r\npinctrl_pm_select_default_state(dev);\r\nreturn clk_prepare_enable(twi_dev->clk);\r\n}\r\nstatic int at91_twi_suspend_noirq(struct device *dev)\r\n{\r\nif (!pm_runtime_status_suspended(dev))\r\nat91_twi_runtime_suspend(dev);\r\nreturn 0;\r\n}\r\nstatic int at91_twi_resume_noirq(struct device *dev)\r\n{\r\nint ret;\r\nif (!pm_runtime_status_suspended(dev)) {\r\nret = at91_twi_runtime_resume(dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\npm_runtime_mark_last_busy(dev);\r\npm_request_autosuspend(dev);\r\nreturn 0;\r\n}\r\nstatic int __init at91_twi_init(void)\r\n{\r\nreturn platform_driver_register(&at91_twi_driver);\r\n}\r\nstatic void __exit at91_twi_exit(void)\r\n{\r\nplatform_driver_unregister(&at91_twi_driver);\r\n}
