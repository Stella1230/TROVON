static s32 fm10k_iov_msg_error(struct fm10k_hw *hw, u32 **results,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nstruct fm10k_vf_info *vf_info = (struct fm10k_vf_info *)mbx;\r\nstruct fm10k_intfc *interface = hw->back;\r\nstruct pci_dev *pdev = interface->pdev;\r\ndev_err(&pdev->dev, "Unknown message ID %u on VF %d\n",\r\n**results & FM10K_TLV_ID_MASK, vf_info->vf_idx);\r\nreturn fm10k_tlv_msg_error(hw, results, mbx);\r\n}\r\ns32 fm10k_iov_event(struct fm10k_intfc *interface)\r\n{\r\nstruct fm10k_hw *hw = &interface->hw;\r\nstruct fm10k_iov_data *iov_data;\r\ns64 mbicr, vflre;\r\nint i;\r\nif (!ACCESS_ONCE(interface->iov_data))\r\nreturn 0;\r\nrcu_read_lock();\r\niov_data = interface->iov_data;\r\nif (!iov_data)\r\ngoto read_unlock;\r\nif (!(fm10k_read_reg(hw, FM10K_EICR) & FM10K_EICR_VFLR))\r\ngoto process_mbx;\r\ndo {\r\nvflre = fm10k_read_reg(hw, FM10K_PFVFLRE(0));\r\nvflre <<= 32;\r\nvflre |= fm10k_read_reg(hw, FM10K_PFVFLRE(1));\r\nvflre = (vflre << 32) | (vflre >> 32);\r\nvflre |= fm10k_read_reg(hw, FM10K_PFVFLRE(0));\r\ni = iov_data->num_vfs;\r\nfor (vflre <<= 64 - i; vflre && i--; vflre += vflre) {\r\nstruct fm10k_vf_info *vf_info = &iov_data->vf_info[i];\r\nif (vflre >= 0)\r\ncontinue;\r\nhw->iov.ops.reset_resources(hw, vf_info);\r\nvf_info->mbx.ops.connect(hw, &vf_info->mbx);\r\n}\r\n} while (i != iov_data->num_vfs);\r\nprocess_mbx:\r\nmbicr = fm10k_read_reg(hw, FM10K_MBICR(1));\r\nmbicr <<= 32;\r\nmbicr |= fm10k_read_reg(hw, FM10K_MBICR(0));\r\ni = iov_data->next_vf_mbx ? : iov_data->num_vfs;\r\nfor (mbicr <<= 64 - i; i--; mbicr += mbicr) {\r\nstruct fm10k_mbx_info *mbx = &iov_data->vf_info[i].mbx;\r\nif (mbicr >= 0)\r\ncontinue;\r\nif (!hw->mbx.ops.tx_ready(&hw->mbx, FM10K_VFMBX_MSG_MTU))\r\nbreak;\r\nmbx->ops.process(hw, mbx);\r\n}\r\nif (i >= 0) {\r\niov_data->next_vf_mbx = i + 1;\r\n} else if (iov_data->next_vf_mbx) {\r\niov_data->next_vf_mbx = 0;\r\ngoto process_mbx;\r\n}\r\nread_unlock:\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\ns32 fm10k_iov_mbx(struct fm10k_intfc *interface)\r\n{\r\nstruct fm10k_hw *hw = &interface->hw;\r\nstruct fm10k_iov_data *iov_data;\r\nint i;\r\nif (!ACCESS_ONCE(interface->iov_data))\r\nreturn 0;\r\nrcu_read_lock();\r\niov_data = interface->iov_data;\r\nif (!iov_data)\r\ngoto read_unlock;\r\nfm10k_mbx_lock(interface);\r\nprocess_mbx:\r\nfor (i = iov_data->next_vf_mbx ? : iov_data->num_vfs; i--;) {\r\nstruct fm10k_vf_info *vf_info = &iov_data->vf_info[i];\r\nstruct fm10k_mbx_info *mbx = &vf_info->mbx;\r\nu16 glort = vf_info->glort;\r\nif (vf_info->vf_flags && !fm10k_glort_valid_pf(hw, glort))\r\nhw->iov.ops.reset_lport(hw, vf_info);\r\nif (!mbx->timeout) {\r\nhw->iov.ops.reset_resources(hw, vf_info);\r\nmbx->ops.connect(hw, mbx);\r\n}\r\nif (mbx->ops.tx_complete(mbx) && !mbx->ops.rx_ready(mbx))\r\ncontinue;\r\nif (!hw->mbx.ops.tx_ready(&hw->mbx, FM10K_VFMBX_MSG_MTU))\r\nbreak;\r\nmbx->ops.process(hw, mbx);\r\n}\r\nif (i >= 0) {\r\niov_data->next_vf_mbx = i + 1;\r\n} else if (iov_data->next_vf_mbx) {\r\niov_data->next_vf_mbx = 0;\r\ngoto process_mbx;\r\n}\r\nfm10k_mbx_unlock(interface);\r\nread_unlock:\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nvoid fm10k_iov_suspend(struct pci_dev *pdev)\r\n{\r\nstruct fm10k_intfc *interface = pci_get_drvdata(pdev);\r\nstruct fm10k_iov_data *iov_data = interface->iov_data;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nint num_vfs, i;\r\nnum_vfs = iov_data ? iov_data->num_vfs : 0;\r\nfm10k_write_reg(hw, FM10K_DGLORTMAP(fm10k_dglort_vf_rss),\r\nFM10K_DGLORTMAP_NONE);\r\nfor (i = 0; i < num_vfs; i++) {\r\nstruct fm10k_vf_info *vf_info = &iov_data->vf_info[i];\r\nhw->iov.ops.reset_resources(hw, vf_info);\r\nhw->iov.ops.reset_lport(hw, vf_info);\r\n}\r\n}\r\nint fm10k_iov_resume(struct pci_dev *pdev)\r\n{\r\nstruct fm10k_intfc *interface = pci_get_drvdata(pdev);\r\nstruct fm10k_iov_data *iov_data = interface->iov_data;\r\nstruct fm10k_dglort_cfg dglort = { 0 };\r\nstruct fm10k_hw *hw = &interface->hw;\r\nint num_vfs, i;\r\nnum_vfs = iov_data ? iov_data->num_vfs : 0;\r\nif (!iov_data)\r\nreturn -ENOMEM;\r\nhw->iov.ops.assign_resources(hw, num_vfs, num_vfs);\r\ndglort.glort = hw->mac.dglort_map & FM10K_DGLORTMAP_NONE;\r\ndglort.idx = fm10k_dglort_vf_rss;\r\ndglort.inner_rss = 1;\r\ndglort.rss_l = fls(fm10k_queues_per_pool(hw) - 1);\r\ndglort.queue_b = fm10k_vf_queue_index(hw, 0);\r\ndglort.vsi_l = fls(hw->iov.total_vfs - 1);\r\ndglort.vsi_b = 1;\r\nhw->mac.ops.configure_dglort_map(hw, &dglort);\r\nfor (i = 0; i < num_vfs; i++) {\r\nstruct fm10k_vf_info *vf_info = &iov_data->vf_info[i];\r\nif (i == ((~hw->mac.dglort_map) >> FM10K_DGLORTMAP_MASK_SHIFT))\r\nbreak;\r\nhw->iov.ops.set_lport(hw, vf_info, i,\r\nFM10K_VF_FLAG_MULTI_CAPABLE);\r\nvf_info->sw_vid = hw->mac.default_vid;\r\nhw->iov.ops.assign_default_mac_vlan(hw, vf_info);\r\nvf_info->mbx.ops.connect(hw, &vf_info->mbx);\r\n}\r\nreturn 0;\r\n}\r\ns32 fm10k_iov_update_pvid(struct fm10k_intfc *interface, u16 glort, u16 pvid)\r\n{\r\nstruct fm10k_iov_data *iov_data = interface->iov_data;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nstruct fm10k_vf_info *vf_info;\r\nu16 vf_idx = (glort - hw->mac.dglort_map) & FM10K_DGLORTMAP_NONE;\r\nif (!iov_data)\r\nreturn FM10K_ERR_PARAM;\r\nif (vf_idx >= iov_data->num_vfs)\r\nreturn FM10K_ERR_PARAM;\r\nvf_info = &iov_data->vf_info[vf_idx];\r\nif (vf_info->sw_vid != pvid) {\r\nvf_info->sw_vid = pvid;\r\nhw->iov.ops.assign_default_mac_vlan(hw, vf_info);\r\n}\r\nreturn 0;\r\n}\r\nstatic void fm10k_iov_free_data(struct pci_dev *pdev)\r\n{\r\nstruct fm10k_intfc *interface = pci_get_drvdata(pdev);\r\nif (!interface->iov_data)\r\nreturn;\r\nfm10k_iov_suspend(pdev);\r\nkfree_rcu(interface->iov_data, rcu);\r\ninterface->iov_data = NULL;\r\n}\r\nstatic s32 fm10k_iov_alloc_data(struct pci_dev *pdev, int num_vfs)\r\n{\r\nstruct fm10k_intfc *interface = pci_get_drvdata(pdev);\r\nstruct fm10k_iov_data *iov_data = interface->iov_data;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nsize_t size;\r\nint i, err;\r\nif (iov_data)\r\nreturn -EBUSY;\r\nif (!hw->iov.ops.assign_resources)\r\nreturn -ENODEV;\r\nif (!num_vfs)\r\nreturn 0;\r\nsize = offsetof(struct fm10k_iov_data, vf_info[num_vfs]);\r\niov_data = kzalloc(size, GFP_KERNEL);\r\nif (!iov_data)\r\nreturn -ENOMEM;\r\niov_data->num_vfs = num_vfs;\r\nfor (i = 0; i < num_vfs; i++) {\r\nstruct fm10k_vf_info *vf_info = &iov_data->vf_info[i];\r\nvf_info->vsi = i + 1;\r\nvf_info->vf_idx = i;\r\nerr = fm10k_pfvf_mbx_init(hw, &vf_info->mbx, iov_mbx_data, i);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"Unable to initialize SR-IOV mailbox\n");\r\nkfree(iov_data);\r\nreturn err;\r\n}\r\n}\r\ninterface->iov_data = iov_data;\r\nfm10k_iov_resume(pdev);\r\nreturn 0;\r\n}\r\nvoid fm10k_iov_disable(struct pci_dev *pdev)\r\n{\r\nif (pci_num_vf(pdev) && pci_vfs_assigned(pdev))\r\ndev_err(&pdev->dev,\r\n"Cannot disable SR-IOV while VFs are assigned\n");\r\nelse\r\npci_disable_sriov(pdev);\r\nfm10k_iov_free_data(pdev);\r\n}\r\nstatic void fm10k_disable_aer_comp_abort(struct pci_dev *pdev)\r\n{\r\nu32 err_sev;\r\nint pos;\r\npos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_ERR);\r\nif (!pos)\r\nreturn;\r\npci_read_config_dword(pdev, pos + PCI_ERR_UNCOR_SEVER, &err_sev);\r\nerr_sev &= ~PCI_ERR_UNC_COMP_ABORT;\r\npci_write_config_dword(pdev, pos + PCI_ERR_UNCOR_SEVER, err_sev);\r\n}\r\nint fm10k_iov_configure(struct pci_dev *pdev, int num_vfs)\r\n{\r\nint current_vfs = pci_num_vf(pdev);\r\nint err = 0;\r\nif (current_vfs && pci_vfs_assigned(pdev)) {\r\ndev_err(&pdev->dev,\r\n"Cannot modify SR-IOV while VFs are assigned\n");\r\nnum_vfs = current_vfs;\r\n} else {\r\npci_disable_sriov(pdev);\r\nfm10k_iov_free_data(pdev);\r\n}\r\nerr = fm10k_iov_alloc_data(pdev, num_vfs);\r\nif (err)\r\nreturn err;\r\nif (num_vfs && (num_vfs != current_vfs)) {\r\nfm10k_disable_aer_comp_abort(pdev);\r\nerr = pci_enable_sriov(pdev, num_vfs);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"Enable PCI SR-IOV failed: %d\n", err);\r\nreturn err;\r\n}\r\n}\r\nreturn num_vfs;\r\n}\r\nint fm10k_ndo_set_vf_mac(struct net_device *netdev, int vf_idx, u8 *mac)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(netdev);\r\nstruct fm10k_iov_data *iov_data = interface->iov_data;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nstruct fm10k_vf_info *vf_info;\r\nif (!iov_data || vf_idx >= iov_data->num_vfs)\r\nreturn -EINVAL;\r\nif (!is_zero_ether_addr(mac) && !is_valid_ether_addr(mac))\r\nreturn -EINVAL;\r\nvf_info = &iov_data->vf_info[vf_idx];\r\nether_addr_copy(vf_info->mac, mac);\r\nfm10k_mbx_lock(interface);\r\nhw->iov.ops.assign_default_mac_vlan(hw, vf_info);\r\nfm10k_mbx_unlock(interface);\r\nreturn 0;\r\n}\r\nint fm10k_ndo_set_vf_vlan(struct net_device *netdev, int vf_idx, u16 vid,\r\nu8 qos)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(netdev);\r\nstruct fm10k_iov_data *iov_data = interface->iov_data;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nstruct fm10k_vf_info *vf_info;\r\nif (!iov_data || vf_idx >= iov_data->num_vfs)\r\nreturn -EINVAL;\r\nif (qos || (vid > (VLAN_VID_MASK - 1)))\r\nreturn -EINVAL;\r\nvf_info = &iov_data->vf_info[vf_idx];\r\nif (vf_info->pf_vid == vid)\r\nreturn 0;\r\nvf_info->pf_vid = vid;\r\nfm10k_mbx_lock(interface);\r\nhw->mac.ops.update_vlan(hw, FM10K_VLAN_ALL, vf_info->vsi, false);\r\nhw->iov.ops.assign_default_mac_vlan(hw, vf_info);\r\nfm10k_mbx_unlock(interface);\r\nreturn 0;\r\n}\r\nint fm10k_ndo_set_vf_bw(struct net_device *netdev, int vf_idx, int unused,\r\nint rate)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(netdev);\r\nstruct fm10k_iov_data *iov_data = interface->iov_data;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nif (!iov_data || vf_idx >= iov_data->num_vfs)\r\nreturn -EINVAL;\r\nif (rate && ((rate < FM10K_VF_TC_MIN) || rate > FM10K_VF_TC_MAX))\r\nreturn -EINVAL;\r\niov_data->vf_info[vf_idx].rate = rate;\r\nhw->iov.ops.configure_tc(hw, vf_idx, rate);\r\nreturn 0;\r\n}\r\nint fm10k_ndo_get_vf_config(struct net_device *netdev,\r\nint vf_idx, struct ifla_vf_info *ivi)\r\n{\r\nstruct fm10k_intfc *interface = netdev_priv(netdev);\r\nstruct fm10k_iov_data *iov_data = interface->iov_data;\r\nstruct fm10k_vf_info *vf_info;\r\nif (!iov_data || vf_idx >= iov_data->num_vfs)\r\nreturn -EINVAL;\r\nvf_info = &iov_data->vf_info[vf_idx];\r\nivi->vf = vf_idx;\r\nivi->max_tx_rate = vf_info->rate;\r\nivi->min_tx_rate = 0;\r\nether_addr_copy(ivi->mac, vf_info->mac);\r\nivi->vlan = vf_info->pf_vid;\r\nivi->qos = 0;\r\nreturn 0;\r\n}
