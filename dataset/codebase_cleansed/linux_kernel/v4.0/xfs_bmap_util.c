xfs_daddr_t\r\nxfs_fsb_to_db(struct xfs_inode *ip, xfs_fsblock_t fsb)\r\n{\r\nreturn (XFS_IS_REALTIME_INODE(ip) ? \\r\n(xfs_daddr_t)XFS_FSB_TO_BB((ip)->i_mount, (fsb)) : \\r\nXFS_FSB_TO_DADDR((ip)->i_mount, (fsb)));\r\n}\r\nint\r\nxfs_bmap_finish(\r\nxfs_trans_t **tp,\r\nxfs_bmap_free_t *flist,\r\nint *committed)\r\n{\r\nxfs_efd_log_item_t *efd;\r\nxfs_efi_log_item_t *efi;\r\nint error;\r\nxfs_bmap_free_item_t *free;\r\nstruct xfs_trans_res tres;\r\nxfs_mount_t *mp;\r\nxfs_bmap_free_item_t *next;\r\nxfs_trans_t *ntp;\r\nASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\r\nif (flist->xbf_count == 0) {\r\n*committed = 0;\r\nreturn 0;\r\n}\r\nntp = *tp;\r\nefi = xfs_trans_get_efi(ntp, flist->xbf_count);\r\nfor (free = flist->xbf_first; free; free = free->xbfi_next)\r\nxfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\r\nfree->xbfi_blockcount);\r\ntres.tr_logres = ntp->t_log_res;\r\ntres.tr_logcount = ntp->t_log_count;\r\ntres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\r\nntp = xfs_trans_dup(*tp);\r\nerror = xfs_trans_commit(*tp, 0);\r\n*tp = ntp;\r\n*committed = 1;\r\nif (error)\r\nreturn error;\r\nxfs_log_ticket_put(ntp->t_ticket);\r\nerror = xfs_trans_reserve(ntp, &tres, 0, 0);\r\nif (error)\r\nreturn error;\r\nefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\r\nfor (free = flist->xbf_first; free != NULL; free = next) {\r\nnext = free->xbfi_next;\r\nif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\r\nfree->xbfi_blockcount))) {\r\nmp = ntp->t_mountp;\r\nif (!XFS_FORCED_SHUTDOWN(mp))\r\nxfs_force_shutdown(mp,\r\n(error == -EFSCORRUPTED) ?\r\nSHUTDOWN_CORRUPT_INCORE :\r\nSHUTDOWN_META_IO_ERROR);\r\nreturn error;\r\n}\r\nxfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\r\nfree->xbfi_blockcount);\r\nxfs_bmap_del_free(flist, NULL, free);\r\n}\r\nreturn 0;\r\n}\r\nint\r\nxfs_bmap_rtalloc(\r\nstruct xfs_bmalloca *ap)\r\n{\r\nxfs_alloctype_t atype = 0;\r\nint error;\r\nxfs_mount_t *mp;\r\nxfs_extlen_t prod = 0;\r\nxfs_extlen_t ralen = 0;\r\nxfs_extlen_t align;\r\nxfs_rtblock_t rtb;\r\nmp = ap->ip->i_mount;\r\nalign = xfs_get_extsz_hint(ap->ip);\r\nprod = align / mp->m_sb.sb_rextsize;\r\nerror = xfs_bmap_extsize_align(mp, &ap->got, &ap->prev,\r\nalign, 1, ap->eof, 0,\r\nap->conv, &ap->offset, &ap->length);\r\nif (error)\r\nreturn error;\r\nASSERT(ap->length);\r\nASSERT(ap->length % mp->m_sb.sb_rextsize == 0);\r\nif (do_mod(ap->offset, align) || ap->length % align)\r\nprod = 1;\r\nralen = ap->length / mp->m_sb.sb_rextsize;\r\nif (ralen * mp->m_sb.sb_rextsize >= MAXEXTLEN)\r\nralen = MAXEXTLEN / mp->m_sb.sb_rextsize;\r\nxfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(ap->tp, mp->m_rbmip, XFS_ILOCK_EXCL);\r\nif (ap->eof && ap->offset == 0) {\r\nxfs_rtblock_t uninitialized_var(rtx);\r\nerror = xfs_rtpick_extent(mp, ap->tp, ralen, &rtx);\r\nif (error)\r\nreturn error;\r\nap->blkno = rtx * mp->m_sb.sb_rextsize;\r\n} else {\r\nap->blkno = 0;\r\n}\r\nxfs_bmap_adjacent(ap);\r\natype = ap->blkno == 0 ? XFS_ALLOCTYPE_ANY_AG : XFS_ALLOCTYPE_NEAR_BNO;\r\ndo_div(ap->blkno, mp->m_sb.sb_rextsize);\r\nrtb = ap->blkno;\r\nap->length = ralen;\r\nif ((error = xfs_rtallocate_extent(ap->tp, ap->blkno, 1, ap->length,\r\n&ralen, atype, ap->wasdel, prod, &rtb)))\r\nreturn error;\r\nif (rtb == NULLFSBLOCK && prod > 1 &&\r\n(error = xfs_rtallocate_extent(ap->tp, ap->blkno, 1,\r\nap->length, &ralen, atype,\r\nap->wasdel, 1, &rtb)))\r\nreturn error;\r\nap->blkno = rtb;\r\nif (ap->blkno != NULLFSBLOCK) {\r\nap->blkno *= mp->m_sb.sb_rextsize;\r\nralen *= mp->m_sb.sb_rextsize;\r\nap->length = ralen;\r\nap->ip->i_d.di_nblocks += ralen;\r\nxfs_trans_log_inode(ap->tp, ap->ip, XFS_ILOG_CORE);\r\nif (ap->wasdel)\r\nap->ip->i_delayed_blks -= ralen;\r\nxfs_trans_mod_dquot_byino(ap->tp, ap->ip,\r\nap->wasdel ? XFS_TRANS_DQ_DELRTBCOUNT :\r\nXFS_TRANS_DQ_RTBCOUNT, (long) ralen);\r\n} else {\r\nap->length = 0;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nxfs_bmap_eof(\r\nstruct xfs_inode *ip,\r\nxfs_fileoff_t endoff,\r\nint whichfork,\r\nint *eof)\r\n{\r\nstruct xfs_bmbt_irec rec;\r\nint error;\r\nerror = xfs_bmap_last_extent(NULL, ip, whichfork, &rec, eof);\r\nif (error || *eof)\r\nreturn error;\r\n*eof = endoff >= rec.br_startoff + rec.br_blockcount;\r\nreturn 0;\r\n}\r\nSTATIC void\r\nxfs_bmap_count_leaves(\r\nxfs_ifork_t *ifp,\r\nxfs_extnum_t idx,\r\nint numrecs,\r\nint *count)\r\n{\r\nint b;\r\nfor (b = 0; b < numrecs; b++) {\r\nxfs_bmbt_rec_host_t *frp = xfs_iext_get_ext(ifp, idx + b);\r\n*count += xfs_bmbt_get_blockcount(frp);\r\n}\r\n}\r\nSTATIC void\r\nxfs_bmap_disk_count_leaves(\r\nstruct xfs_mount *mp,\r\nstruct xfs_btree_block *block,\r\nint numrecs,\r\nint *count)\r\n{\r\nint b;\r\nxfs_bmbt_rec_t *frp;\r\nfor (b = 1; b <= numrecs; b++) {\r\nfrp = XFS_BMBT_REC_ADDR(mp, block, b);\r\n*count += xfs_bmbt_disk_get_blockcount(frp);\r\n}\r\n}\r\nSTATIC int\r\nxfs_bmap_count_tree(\r\nxfs_mount_t *mp,\r\nxfs_trans_t *tp,\r\nxfs_ifork_t *ifp,\r\nxfs_fsblock_t blockno,\r\nint levelin,\r\nint *count)\r\n{\r\nint error;\r\nxfs_buf_t *bp, *nbp;\r\nint level = levelin;\r\n__be64 *pp;\r\nxfs_fsblock_t bno = blockno;\r\nxfs_fsblock_t nextbno;\r\nstruct xfs_btree_block *block, *nextblock;\r\nint numrecs;\r\nerror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp, XFS_BMAP_BTREE_REF,\r\n&xfs_bmbt_buf_ops);\r\nif (error)\r\nreturn error;\r\n*count += 1;\r\nblock = XFS_BUF_TO_BLOCK(bp);\r\nif (--level) {\r\nnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\r\nwhile (nextbno != NULLFSBLOCK) {\r\nerror = xfs_btree_read_bufl(mp, tp, nextbno, 0, &nbp,\r\nXFS_BMAP_BTREE_REF,\r\n&xfs_bmbt_buf_ops);\r\nif (error)\r\nreturn error;\r\n*count += 1;\r\nnextblock = XFS_BUF_TO_BLOCK(nbp);\r\nnextbno = be64_to_cpu(nextblock->bb_u.l.bb_rightsib);\r\nxfs_trans_brelse(tp, nbp);\r\n}\r\npp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\r\nbno = be64_to_cpu(*pp);\r\nif (unlikely((error =\r\nxfs_bmap_count_tree(mp, tp, ifp, bno, level, count)) < 0)) {\r\nxfs_trans_brelse(tp, bp);\r\nXFS_ERROR_REPORT("xfs_bmap_count_tree(1)",\r\nXFS_ERRLEVEL_LOW, mp);\r\nreturn -EFSCORRUPTED;\r\n}\r\nxfs_trans_brelse(tp, bp);\r\n} else {\r\nfor (;;) {\r\nnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\r\nnumrecs = be16_to_cpu(block->bb_numrecs);\r\nxfs_bmap_disk_count_leaves(mp, block, numrecs, count);\r\nxfs_trans_brelse(tp, bp);\r\nif (nextbno == NULLFSBLOCK)\r\nbreak;\r\nbno = nextbno;\r\nerror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp,\r\nXFS_BMAP_BTREE_REF,\r\n&xfs_bmbt_buf_ops);\r\nif (error)\r\nreturn error;\r\n*count += 1;\r\nblock = XFS_BUF_TO_BLOCK(bp);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nxfs_bmap_count_blocks(\r\nxfs_trans_t *tp,\r\nxfs_inode_t *ip,\r\nint whichfork,\r\nint *count)\r\n{\r\nstruct xfs_btree_block *block;\r\nxfs_fsblock_t bno;\r\nxfs_ifork_t *ifp;\r\nint level;\r\nxfs_mount_t *mp;\r\n__be64 *pp;\r\nbno = NULLFSBLOCK;\r\nmp = ip->i_mount;\r\nifp = XFS_IFORK_PTR(ip, whichfork);\r\nif ( XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS ) {\r\nxfs_bmap_count_leaves(ifp, 0,\r\nifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t),\r\ncount);\r\nreturn 0;\r\n}\r\nblock = ifp->if_broot;\r\nlevel = be16_to_cpu(block->bb_level);\r\nASSERT(level > 0);\r\npp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, 1, ifp->if_broot_bytes);\r\nbno = be64_to_cpu(*pp);\r\nASSERT(bno != NULLFSBLOCK);\r\nASSERT(XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount);\r\nASSERT(XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks);\r\nif (unlikely(xfs_bmap_count_tree(mp, tp, ifp, bno, level, count) < 0)) {\r\nXFS_ERROR_REPORT("xfs_bmap_count_blocks(2)", XFS_ERRLEVEL_LOW,\r\nmp);\r\nreturn -EFSCORRUPTED;\r\n}\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_getbmapx_fix_eof_hole(\r\nxfs_inode_t *ip,\r\nstruct getbmapx *out,\r\nint prealloced,\r\n__int64_t end,\r\nxfs_fsblock_t startblock)\r\n{\r\n__int64_t fixlen;\r\nxfs_mount_t *mp;\r\nxfs_ifork_t *ifp;\r\nxfs_extnum_t lastx;\r\nxfs_fileoff_t fileblock;\r\nif (startblock == HOLESTARTBLOCK) {\r\nmp = ip->i_mount;\r\nout->bmv_block = -1;\r\nfixlen = XFS_FSB_TO_BB(mp, XFS_B_TO_FSB(mp, XFS_ISIZE(ip)));\r\nfixlen -= out->bmv_offset;\r\nif (prealloced && out->bmv_offset + out->bmv_length == end) {\r\nif (fixlen <= 0)\r\nreturn 0;\r\nout->bmv_length = fixlen;\r\n}\r\n} else {\r\nif (startblock == DELAYSTARTBLOCK)\r\nout->bmv_block = -2;\r\nelse\r\nout->bmv_block = xfs_fsb_to_db(ip, startblock);\r\nfileblock = XFS_BB_TO_FSB(ip->i_mount, out->bmv_offset);\r\nifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\r\nif (xfs_iext_bno_to_ext(ifp, fileblock, &lastx) &&\r\n(lastx == (ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t))-1))\r\nout->bmv_oflags |= BMV_OF_LAST;\r\n}\r\nreturn 1;\r\n}\r\nint\r\nxfs_getbmap(\r\nxfs_inode_t *ip,\r\nstruct getbmapx *bmv,\r\nxfs_bmap_format_t formatter,\r\nvoid *arg)\r\n{\r\n__int64_t bmvend;\r\nint error = 0;\r\n__int64_t fixlen;\r\nint i;\r\nint lock;\r\nxfs_bmbt_irec_t *map;\r\nxfs_mount_t *mp;\r\nint nex;\r\nint nexleft;\r\nint subnex;\r\nint nmap;\r\nstruct getbmapx *out;\r\nint whichfork;\r\nint prealloced;\r\nint iflags;\r\nint bmapi_flags;\r\nint cur_ext = 0;\r\nmp = ip->i_mount;\r\niflags = bmv->bmv_iflags;\r\nwhichfork = iflags & BMV_IF_ATTRFORK ? XFS_ATTR_FORK : XFS_DATA_FORK;\r\nif (whichfork == XFS_ATTR_FORK) {\r\nif (XFS_IFORK_Q(ip)) {\r\nif (ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS &&\r\nip->i_d.di_aformat != XFS_DINODE_FMT_BTREE &&\r\nip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)\r\nreturn -EINVAL;\r\n} else if (unlikely(\r\nip->i_d.di_aformat != 0 &&\r\nip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS)) {\r\nXFS_ERROR_REPORT("xfs_getbmap", XFS_ERRLEVEL_LOW,\r\nip->i_mount);\r\nreturn -EFSCORRUPTED;\r\n}\r\nprealloced = 0;\r\nfixlen = 1LL << 32;\r\n} else {\r\nif (ip->i_d.di_format != XFS_DINODE_FMT_EXTENTS &&\r\nip->i_d.di_format != XFS_DINODE_FMT_BTREE &&\r\nip->i_d.di_format != XFS_DINODE_FMT_LOCAL)\r\nreturn -EINVAL;\r\nif (xfs_get_extsz_hint(ip) ||\r\nip->i_d.di_flags & (XFS_DIFLAG_PREALLOC|XFS_DIFLAG_APPEND)){\r\nprealloced = 1;\r\nfixlen = mp->m_super->s_maxbytes;\r\n} else {\r\nprealloced = 0;\r\nfixlen = XFS_ISIZE(ip);\r\n}\r\n}\r\nif (bmv->bmv_length == -1) {\r\nfixlen = XFS_FSB_TO_BB(mp, XFS_B_TO_FSB(mp, fixlen));\r\nbmv->bmv_length =\r\nmax_t(__int64_t, fixlen - bmv->bmv_offset, 0);\r\n} else if (bmv->bmv_length == 0) {\r\nbmv->bmv_entries = 0;\r\nreturn 0;\r\n} else if (bmv->bmv_length < 0) {\r\nreturn -EINVAL;\r\n}\r\nnex = bmv->bmv_count - 1;\r\nif (nex <= 0)\r\nreturn -EINVAL;\r\nbmvend = bmv->bmv_offset + bmv->bmv_length;\r\nif (bmv->bmv_count > ULONG_MAX / sizeof(struct getbmapx))\r\nreturn -ENOMEM;\r\nout = kmem_zalloc_large(bmv->bmv_count * sizeof(struct getbmapx), 0);\r\nif (!out)\r\nreturn -ENOMEM;\r\nxfs_ilock(ip, XFS_IOLOCK_SHARED);\r\nif (whichfork == XFS_DATA_FORK) {\r\nif (!(iflags & BMV_IF_DELALLOC) &&\r\n(ip->i_delayed_blks || XFS_ISIZE(ip) > ip->i_d.di_size)) {\r\nerror = filemap_write_and_wait(VFS_I(ip)->i_mapping);\r\nif (error)\r\ngoto out_unlock_iolock;\r\n}\r\nlock = xfs_ilock_data_map_shared(ip);\r\n} else {\r\nlock = xfs_ilock_attr_map_shared(ip);\r\n}\r\nif (nex > XFS_IFORK_NEXTENTS(ip, whichfork) * 2 + 1)\r\nnex = XFS_IFORK_NEXTENTS(ip, whichfork) * 2 + 1;\r\nbmapi_flags = xfs_bmapi_aflag(whichfork);\r\nif (!(iflags & BMV_IF_PREALLOC))\r\nbmapi_flags |= XFS_BMAPI_IGSTATE;\r\nerror = -ENOMEM;\r\nsubnex = 16;\r\nmap = kmem_alloc(subnex * sizeof(*map), KM_MAYFAIL | KM_NOFS);\r\nif (!map)\r\ngoto out_unlock_ilock;\r\nbmv->bmv_entries = 0;\r\nif (XFS_IFORK_NEXTENTS(ip, whichfork) == 0 &&\r\n(whichfork == XFS_ATTR_FORK || !(iflags & BMV_IF_DELALLOC))) {\r\nerror = 0;\r\ngoto out_free_map;\r\n}\r\nnexleft = nex;\r\ndo {\r\nnmap = (nexleft > subnex) ? subnex : nexleft;\r\nerror = xfs_bmapi_read(ip, XFS_BB_TO_FSBT(mp, bmv->bmv_offset),\r\nXFS_BB_TO_FSB(mp, bmv->bmv_length),\r\nmap, &nmap, bmapi_flags);\r\nif (error)\r\ngoto out_free_map;\r\nASSERT(nmap <= subnex);\r\nfor (i = 0; i < nmap && nexleft && bmv->bmv_length; i++) {\r\nout[cur_ext].bmv_oflags = 0;\r\nif (map[i].br_state == XFS_EXT_UNWRITTEN)\r\nout[cur_ext].bmv_oflags |= BMV_OF_PREALLOC;\r\nelse if (map[i].br_startblock == DELAYSTARTBLOCK)\r\nout[cur_ext].bmv_oflags |= BMV_OF_DELALLOC;\r\nout[cur_ext].bmv_offset =\r\nXFS_FSB_TO_BB(mp, map[i].br_startoff);\r\nout[cur_ext].bmv_length =\r\nXFS_FSB_TO_BB(mp, map[i].br_blockcount);\r\nout[cur_ext].bmv_unused1 = 0;\r\nout[cur_ext].bmv_unused2 = 0;\r\nif (map[i].br_startblock == DELAYSTARTBLOCK &&\r\nmap[i].br_startoff <= XFS_B_TO_FSB(mp, XFS_ISIZE(ip)))\r\nASSERT((iflags & BMV_IF_DELALLOC) != 0);\r\nif (map[i].br_startblock == HOLESTARTBLOCK &&\r\nwhichfork == XFS_ATTR_FORK) {\r\nout[cur_ext].bmv_oflags |= BMV_OF_LAST;\r\ngoto out_free_map;\r\n}\r\nif (!xfs_getbmapx_fix_eof_hole(ip, &out[cur_ext],\r\nprealloced, bmvend,\r\nmap[i].br_startblock))\r\ngoto out_free_map;\r\nbmv->bmv_offset =\r\nout[cur_ext].bmv_offset +\r\nout[cur_ext].bmv_length;\r\nbmv->bmv_length =\r\nmax_t(__int64_t, 0, bmvend - bmv->bmv_offset);\r\nif ((iflags & BMV_IF_NO_HOLES) &&\r\nmap[i].br_startblock == HOLESTARTBLOCK) {\r\nmemset(&out[cur_ext], 0, sizeof(out[cur_ext]));\r\ncontinue;\r\n}\r\nnexleft--;\r\nbmv->bmv_entries++;\r\ncur_ext++;\r\n}\r\n} while (nmap && nexleft && bmv->bmv_length);\r\nout_free_map:\r\nkmem_free(map);\r\nout_unlock_ilock:\r\nxfs_iunlock(ip, lock);\r\nout_unlock_iolock:\r\nxfs_iunlock(ip, XFS_IOLOCK_SHARED);\r\nfor (i = 0; i < cur_ext; i++) {\r\nint full = 0;\r\nerror = formatter(&arg, &out[i], &full);\r\nif (error || full)\r\nbreak;\r\n}\r\nkmem_free(out);\r\nreturn error;\r\n}\r\nint\r\nxfs_bmap_punch_delalloc_range(\r\nstruct xfs_inode *ip,\r\nxfs_fileoff_t start_fsb,\r\nxfs_fileoff_t length)\r\n{\r\nxfs_fileoff_t remaining = length;\r\nint error = 0;\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\r\ndo {\r\nint done;\r\nxfs_bmbt_irec_t imap;\r\nint nimaps = 1;\r\nxfs_fsblock_t firstblock;\r\nxfs_bmap_free_t flist;\r\nerror = xfs_bmapi_read(ip, start_fsb, 1, &imap, &nimaps,\r\nXFS_BMAPI_ENTIRE);\r\nif (error) {\r\nif (!XFS_FORCED_SHUTDOWN(ip->i_mount)) {\r\nxfs_alert(ip->i_mount,\r\n"Failed delalloc mapping lookup ino %lld fsb %lld.",\r\nip->i_ino, start_fsb);\r\n}\r\nbreak;\r\n}\r\nif (!nimaps) {\r\ngoto next_block;\r\n}\r\nif (imap.br_startblock != DELAYSTARTBLOCK) {\r\ngoto next_block;\r\n}\r\nWARN_ON(imap.br_blockcount == 0);\r\nxfs_bmap_init(&flist, &firstblock);\r\nerror = xfs_bunmapi(NULL, ip, start_fsb, 1, 0, 1, &firstblock,\r\n&flist, &done);\r\nif (error)\r\nbreak;\r\nASSERT(!flist.xbf_count && !flist.xbf_first);\r\nnext_block:\r\nstart_fsb++;\r\nremaining--;\r\n} while(remaining > 0);\r\nreturn error;\r\n}\r\nbool\r\nxfs_can_free_eofblocks(struct xfs_inode *ip, bool force)\r\n{\r\nif (!S_ISREG(ip->i_d.di_mode))\r\nreturn false;\r\nif (VFS_I(ip)->i_size == 0 &&\r\nVFS_I(ip)->i_mapping->nrpages == 0 &&\r\nip->i_delayed_blks == 0)\r\nreturn false;\r\nif (!(ip->i_df.if_flags & XFS_IFEXTENTS))\r\nreturn false;\r\nif (ip->i_d.di_flags & (XFS_DIFLAG_PREALLOC | XFS_DIFLAG_APPEND))\r\nif (!force || ip->i_delayed_blks == 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nint\r\nxfs_free_eofblocks(\r\nxfs_mount_t *mp,\r\nxfs_inode_t *ip,\r\nbool need_iolock)\r\n{\r\nxfs_trans_t *tp;\r\nint error;\r\nxfs_fileoff_t end_fsb;\r\nxfs_fileoff_t last_fsb;\r\nxfs_filblks_t map_len;\r\nint nimaps;\r\nxfs_bmbt_irec_t imap;\r\nend_fsb = XFS_B_TO_FSB(mp, (xfs_ufsize_t)XFS_ISIZE(ip));\r\nlast_fsb = XFS_B_TO_FSB(mp, mp->m_super->s_maxbytes);\r\nif (last_fsb <= end_fsb)\r\nreturn 0;\r\nmap_len = last_fsb - end_fsb;\r\nnimaps = 1;\r\nxfs_ilock(ip, XFS_ILOCK_SHARED);\r\nerror = xfs_bmapi_read(ip, end_fsb, map_len, &imap, &nimaps, 0);\r\nxfs_iunlock(ip, XFS_ILOCK_SHARED);\r\nif (!error && (nimaps != 0) &&\r\n(imap.br_startblock != HOLESTARTBLOCK ||\r\nip->i_delayed_blks)) {\r\nerror = xfs_qm_dqattach(ip, 0);\r\nif (error)\r\nreturn error;\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\r\nif (need_iolock) {\r\nif (!xfs_ilock_nowait(ip, XFS_IOLOCK_EXCL)) {\r\nxfs_trans_cancel(tp, 0);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nerror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\r\nif (error) {\r\nASSERT(XFS_FORCED_SHUTDOWN(mp));\r\nxfs_trans_cancel(tp, 0);\r\nif (need_iolock)\r\nxfs_iunlock(ip, XFS_IOLOCK_EXCL);\r\nreturn error;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, ip, 0);\r\nerror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK,\r\nXFS_ISIZE(ip));\r\nif (error) {\r\nxfs_trans_cancel(tp,\r\n(XFS_TRANS_RELEASE_LOG_RES |\r\nXFS_TRANS_ABORT));\r\n} else {\r\nerror = xfs_trans_commit(tp,\r\nXFS_TRANS_RELEASE_LOG_RES);\r\nif (!error)\r\nxfs_inode_clear_eofblocks_tag(ip);\r\n}\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nif (need_iolock)\r\nxfs_iunlock(ip, XFS_IOLOCK_EXCL);\r\n}\r\nreturn error;\r\n}\r\nint\r\nxfs_alloc_file_space(\r\nstruct xfs_inode *ip,\r\nxfs_off_t offset,\r\nxfs_off_t len,\r\nint alloc_type)\r\n{\r\nxfs_mount_t *mp = ip->i_mount;\r\nxfs_off_t count;\r\nxfs_filblks_t allocated_fsb;\r\nxfs_filblks_t allocatesize_fsb;\r\nxfs_extlen_t extsz, temp;\r\nxfs_fileoff_t startoffset_fsb;\r\nxfs_fsblock_t firstfsb;\r\nint nimaps;\r\nint quota_flag;\r\nint rt;\r\nxfs_trans_t *tp;\r\nxfs_bmbt_irec_t imaps[1], *imapp;\r\nxfs_bmap_free_t free_list;\r\nuint qblocks, resblks, resrtextents;\r\nint committed;\r\nint error;\r\ntrace_xfs_alloc_file_space(ip);\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn -EIO;\r\nerror = xfs_qm_dqattach(ip, 0);\r\nif (error)\r\nreturn error;\r\nif (len <= 0)\r\nreturn -EINVAL;\r\nrt = XFS_IS_REALTIME_INODE(ip);\r\nextsz = xfs_get_extsz_hint(ip);\r\ncount = len;\r\nimapp = &imaps[0];\r\nnimaps = 1;\r\nstartoffset_fsb = XFS_B_TO_FSBT(mp, offset);\r\nallocatesize_fsb = XFS_B_TO_FSB(mp, count);\r\nwhile (allocatesize_fsb && !error) {\r\nxfs_fileoff_t s, e;\r\nif (unlikely(extsz)) {\r\ns = startoffset_fsb;\r\ndo_div(s, extsz);\r\ns *= extsz;\r\ne = startoffset_fsb + allocatesize_fsb;\r\nif ((temp = do_mod(startoffset_fsb, extsz)))\r\ne += temp;\r\nif ((temp = do_mod(e, extsz)))\r\ne += extsz - temp;\r\n} else {\r\ns = 0;\r\ne = allocatesize_fsb;\r\n}\r\nresblks = min_t(xfs_fileoff_t, (e - s), (MAXEXTLEN * nimaps));\r\nif (unlikely(rt)) {\r\nresrtextents = qblocks = resblks;\r\nresrtextents /= mp->m_sb.sb_rextsize;\r\nresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\r\nquota_flag = XFS_QMOPT_RES_RTBLKS;\r\n} else {\r\nresrtextents = 0;\r\nresblks = qblocks = XFS_DIOSTRAT_SPACE_RES(mp, resblks);\r\nquota_flag = XFS_QMOPT_RES_REGBLKS;\r\n}\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\r\nerror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\r\nresblks, resrtextents);\r\nif (error) {\r\nASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\r\nxfs_trans_cancel(tp, 0);\r\nbreak;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nerror = xfs_trans_reserve_quota_nblks(tp, ip, qblocks,\r\n0, quota_flag);\r\nif (error)\r\ngoto error1;\r\nxfs_trans_ijoin(tp, ip, 0);\r\nxfs_bmap_init(&free_list, &firstfsb);\r\nerror = xfs_bmapi_write(tp, ip, startoffset_fsb,\r\nallocatesize_fsb, alloc_type, &firstfsb,\r\n0, imapp, &nimaps, &free_list);\r\nif (error) {\r\ngoto error0;\r\n}\r\nerror = xfs_bmap_finish(&tp, &free_list, &committed);\r\nif (error) {\r\ngoto error0;\r\n}\r\nerror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nif (error) {\r\nbreak;\r\n}\r\nallocated_fsb = imapp->br_blockcount;\r\nif (nimaps == 0) {\r\nerror = -ENOSPC;\r\nbreak;\r\n}\r\nstartoffset_fsb += allocated_fsb;\r\nallocatesize_fsb -= allocated_fsb;\r\n}\r\nreturn error;\r\nerror0:\r\nxfs_bmap_cancel(&free_list);\r\nxfs_trans_unreserve_quota_nblks(tp, ip, (long)qblocks, 0, quota_flag);\r\nerror1:\r\nxfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_zero_remaining_bytes(\r\nxfs_inode_t *ip,\r\nxfs_off_t startoff,\r\nxfs_off_t endoff)\r\n{\r\nxfs_bmbt_irec_t imap;\r\nxfs_fileoff_t offset_fsb;\r\nxfs_off_t lastoffset;\r\nxfs_off_t offset;\r\nxfs_buf_t *bp;\r\nxfs_mount_t *mp = ip->i_mount;\r\nint nimap;\r\nint error = 0;\r\nif (startoff >= XFS_ISIZE(ip))\r\nreturn 0;\r\nif (endoff > XFS_ISIZE(ip))\r\nendoff = XFS_ISIZE(ip);\r\nfor (offset = startoff; offset <= endoff; offset = lastoffset + 1) {\r\nuint lock_mode;\r\noffset_fsb = XFS_B_TO_FSBT(mp, offset);\r\nnimap = 1;\r\nlock_mode = xfs_ilock_data_map_shared(ip);\r\nerror = xfs_bmapi_read(ip, offset_fsb, 1, &imap, &nimap, 0);\r\nxfs_iunlock(ip, lock_mode);\r\nif (error || nimap < 1)\r\nbreak;\r\nASSERT(imap.br_blockcount >= 1);\r\nASSERT(imap.br_startoff == offset_fsb);\r\nlastoffset = XFS_FSB_TO_B(mp, imap.br_startoff + 1) - 1;\r\nif (lastoffset > endoff)\r\nlastoffset = endoff;\r\nif (imap.br_startblock == HOLESTARTBLOCK)\r\ncontinue;\r\nASSERT(imap.br_startblock != DELAYSTARTBLOCK);\r\nif (imap.br_state == XFS_EXT_UNWRITTEN)\r\ncontinue;\r\nerror = xfs_buf_read_uncached(XFS_IS_REALTIME_INODE(ip) ?\r\nmp->m_rtdev_targp : mp->m_ddev_targp,\r\nxfs_fsb_to_db(ip, imap.br_startblock),\r\nBTOBB(mp->m_sb.sb_blocksize),\r\n0, &bp, NULL);\r\nif (error)\r\nreturn error;\r\nmemset(bp->b_addr +\r\n(offset - XFS_FSB_TO_B(mp, imap.br_startoff)),\r\n0, lastoffset - offset + 1);\r\nerror = xfs_bwrite(bp);\r\nxfs_buf_relse(bp);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn error;\r\n}\r\nint\r\nxfs_free_file_space(\r\nstruct xfs_inode *ip,\r\nxfs_off_t offset,\r\nxfs_off_t len)\r\n{\r\nint committed;\r\nint done;\r\nxfs_fileoff_t endoffset_fsb;\r\nint error;\r\nxfs_fsblock_t firstfsb;\r\nxfs_bmap_free_t free_list;\r\nxfs_bmbt_irec_t imap;\r\nxfs_off_t ioffset;\r\nxfs_off_t iendoffset;\r\nxfs_extlen_t mod=0;\r\nxfs_mount_t *mp;\r\nint nimap;\r\nuint resblks;\r\nxfs_off_t rounding;\r\nint rt;\r\nxfs_fileoff_t startoffset_fsb;\r\nxfs_trans_t *tp;\r\nmp = ip->i_mount;\r\ntrace_xfs_free_file_space(ip);\r\nerror = xfs_qm_dqattach(ip, 0);\r\nif (error)\r\nreturn error;\r\nerror = 0;\r\nif (len <= 0)\r\nreturn error;\r\nrt = XFS_IS_REALTIME_INODE(ip);\r\nstartoffset_fsb = XFS_B_TO_FSB(mp, offset);\r\nendoffset_fsb = XFS_B_TO_FSBT(mp, offset + len);\r\ninode_dio_wait(VFS_I(ip));\r\nrounding = max_t(xfs_off_t, 1 << mp->m_sb.sb_blocklog, PAGE_CACHE_SIZE);\r\nioffset = round_down(offset, rounding);\r\niendoffset = round_up(offset + len, rounding) - 1;\r\nerror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping, ioffset,\r\niendoffset);\r\nif (error)\r\ngoto out;\r\ntruncate_pagecache_range(VFS_I(ip), ioffset, iendoffset);\r\nif (rt && !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\r\nnimap = 1;\r\nerror = xfs_bmapi_read(ip, startoffset_fsb, 1,\r\n&imap, &nimap, 0);\r\nif (error)\r\ngoto out;\r\nASSERT(nimap == 0 || nimap == 1);\r\nif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\r\nxfs_daddr_t block;\r\nASSERT(imap.br_startblock != DELAYSTARTBLOCK);\r\nblock = imap.br_startblock;\r\nmod = do_div(block, mp->m_sb.sb_rextsize);\r\nif (mod)\r\nstartoffset_fsb += mp->m_sb.sb_rextsize - mod;\r\n}\r\nnimap = 1;\r\nerror = xfs_bmapi_read(ip, endoffset_fsb - 1, 1,\r\n&imap, &nimap, 0);\r\nif (error)\r\ngoto out;\r\nASSERT(nimap == 0 || nimap == 1);\r\nif (nimap && imap.br_startblock != HOLESTARTBLOCK) {\r\nASSERT(imap.br_startblock != DELAYSTARTBLOCK);\r\nmod++;\r\nif (mod && (mod != mp->m_sb.sb_rextsize))\r\nendoffset_fsb -= mod;\r\n}\r\n}\r\nif ((done = (endoffset_fsb <= startoffset_fsb)))\r\nerror = xfs_zero_remaining_bytes(ip, offset, offset + len - 1);\r\nelse {\r\nif (offset < XFS_FSB_TO_B(mp, startoffset_fsb))\r\nerror = xfs_zero_remaining_bytes(ip, offset,\r\nXFS_FSB_TO_B(mp, startoffset_fsb) - 1);\r\nif (!error &&\r\nXFS_FSB_TO_B(mp, endoffset_fsb) < offset + len)\r\nerror = xfs_zero_remaining_bytes(ip,\r\nXFS_FSB_TO_B(mp, endoffset_fsb),\r\noffset + len - 1);\r\n}\r\nresblks = XFS_DIOSTRAT_SPACE_RES(mp, 0);\r\nwhile (!error && !done) {\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\r\nerror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write, resblks, 0);\r\nif (error) {\r\nASSERT(error == -ENOSPC || XFS_FORCED_SHUTDOWN(mp));\r\nxfs_trans_cancel(tp, 0);\r\nbreak;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nerror = xfs_trans_reserve_quota(tp, mp,\r\nip->i_udquot, ip->i_gdquot, ip->i_pdquot,\r\nresblks, 0, XFS_QMOPT_RES_REGBLKS);\r\nif (error)\r\ngoto error1;\r\nxfs_trans_ijoin(tp, ip, 0);\r\nxfs_bmap_init(&free_list, &firstfsb);\r\nerror = xfs_bunmapi(tp, ip, startoffset_fsb,\r\nendoffset_fsb - startoffset_fsb,\r\n0, 2, &firstfsb, &free_list, &done);\r\nif (error) {\r\ngoto error0;\r\n}\r\nerror = xfs_bmap_finish(&tp, &free_list, &committed);\r\nif (error) {\r\ngoto error0;\r\n}\r\nerror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\n}\r\nout:\r\nreturn error;\r\nerror0:\r\nxfs_bmap_cancel(&free_list);\r\nerror1:\r\nxfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\ngoto out;\r\n}\r\nint\r\nxfs_zero_file_space(\r\nstruct xfs_inode *ip,\r\nxfs_off_t offset,\r\nxfs_off_t len)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nuint blksize;\r\nint error;\r\ntrace_xfs_zero_file_space(ip);\r\nblksize = 1 << mp->m_sb.sb_blocklog;\r\nerror = xfs_free_file_space(ip, offset, len);\r\nif (error)\r\ngoto out;\r\nerror = xfs_alloc_file_space(ip, round_down(offset, blksize),\r\nround_up(offset + len, blksize) -\r\nround_down(offset, blksize),\r\nXFS_BMAPI_PREALLOC);\r\nout:\r\nreturn error;\r\n}\r\nint\r\nxfs_collapse_file_space(\r\nstruct xfs_inode *ip,\r\nxfs_off_t offset,\r\nxfs_off_t len)\r\n{\r\nint done = 0;\r\nstruct xfs_mount *mp = ip->i_mount;\r\nstruct xfs_trans *tp;\r\nint error;\r\nstruct xfs_bmap_free free_list;\r\nxfs_fsblock_t first_block;\r\nint committed;\r\nxfs_fileoff_t start_fsb;\r\nxfs_fileoff_t next_fsb;\r\nxfs_fileoff_t shift_fsb;\r\nASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\r\ntrace_xfs_collapse_file_space(ip);\r\nnext_fsb = XFS_B_TO_FSB(mp, offset + len);\r\nshift_fsb = XFS_B_TO_FSB(mp, len);\r\nerror = xfs_free_file_space(ip, offset, len);\r\nif (error)\r\nreturn error;\r\nif (xfs_can_free_eofblocks(ip, true)) {\r\nerror = xfs_free_eofblocks(mp, ip, false);\r\nif (error)\r\nreturn error;\r\n}\r\nerror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\r\noffset + len, -1);\r\nif (error)\r\nreturn error;\r\nerror = invalidate_inode_pages2_range(VFS_I(ip)->i_mapping,\r\n(offset + len) >> PAGE_CACHE_SHIFT, -1);\r\nif (error)\r\nreturn error;\r\nwhile (!error && !done) {\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_DIOSTRAT);\r\nerror = xfs_trans_reserve(tp, &M_RES(mp)->tr_write,\r\nXFS_DIOSTRAT_SPACE_RES(mp, 0), 0);\r\nif (error) {\r\nxfs_trans_cancel(tp, 0);\r\nbreak;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nerror = xfs_trans_reserve_quota(tp, mp, ip->i_udquot,\r\nip->i_gdquot, ip->i_pdquot,\r\nXFS_DIOSTRAT_SPACE_RES(mp, 0), 0,\r\nXFS_QMOPT_RES_REGBLKS);\r\nif (error)\r\ngoto out;\r\nxfs_trans_ijoin(tp, ip, 0);\r\nxfs_bmap_init(&free_list, &first_block);\r\nstart_fsb = next_fsb;\r\nerror = xfs_bmap_shift_extents(tp, ip, start_fsb, shift_fsb,\r\n&done, &next_fsb, &first_block, &free_list,\r\nXFS_BMAP_MAX_SHIFT_EXTENTS);\r\nif (error)\r\ngoto out;\r\nerror = xfs_bmap_finish(&tp, &free_list, &committed);\r\nif (error)\r\ngoto out;\r\nerror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\n}\r\nreturn error;\r\nout:\r\nxfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nreturn error;\r\n}\r\nstatic int\r\nxfs_swap_extents_check_format(\r\nxfs_inode_t *ip,\r\nxfs_inode_t *tip)\r\n{\r\nif (ip->i_d.di_format == XFS_DINODE_FMT_LOCAL ||\r\ntip->i_d.di_format == XFS_DINODE_FMT_LOCAL)\r\nreturn -EINVAL;\r\nif (ip->i_d.di_nextents < tip->i_d.di_nextents)\r\nreturn -EINVAL;\r\nif (ip->i_d.di_format == XFS_DINODE_FMT_EXTENTS &&\r\ntip->i_d.di_format == XFS_DINODE_FMT_BTREE)\r\nreturn -EINVAL;\r\nif (tip->i_d.di_format == XFS_DINODE_FMT_EXTENTS &&\r\nXFS_IFORK_NEXTENTS(tip, XFS_DATA_FORK) >\r\nXFS_IFORK_MAXEXT(ip, XFS_DATA_FORK))\r\nreturn -EINVAL;\r\nif (ip->i_d.di_format == XFS_DINODE_FMT_EXTENTS &&\r\nXFS_IFORK_NEXTENTS(ip, XFS_DATA_FORK) >\r\nXFS_IFORK_MAXEXT(tip, XFS_DATA_FORK))\r\nreturn -EINVAL;\r\nif (tip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\r\nif (XFS_IFORK_BOFF(ip) &&\r\nXFS_BMAP_BMDR_SPACE(tip->i_df.if_broot) > XFS_IFORK_BOFF(ip))\r\nreturn -EINVAL;\r\nif (XFS_IFORK_NEXTENTS(tip, XFS_DATA_FORK) <=\r\nXFS_IFORK_MAXEXT(ip, XFS_DATA_FORK))\r\nreturn -EINVAL;\r\n}\r\nif (ip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\r\nif (XFS_IFORK_BOFF(tip) &&\r\nXFS_BMAP_BMDR_SPACE(ip->i_df.if_broot) > XFS_IFORK_BOFF(tip))\r\nreturn -EINVAL;\r\nif (XFS_IFORK_NEXTENTS(ip, XFS_DATA_FORK) <=\r\nXFS_IFORK_MAXEXT(tip, XFS_DATA_FORK))\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nxfs_swap_extent_flush(\r\nstruct xfs_inode *ip)\r\n{\r\nint error;\r\nerror = filemap_write_and_wait(VFS_I(ip)->i_mapping);\r\nif (error)\r\nreturn error;\r\ntruncate_pagecache_range(VFS_I(ip), 0, -1);\r\nif (VFS_I(ip)->i_mapping->nrpages)\r\nreturn -EINVAL;\r\nif (mapping_mapped(VFS_I(ip)->i_mapping))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nint\r\nxfs_swap_extents(\r\nxfs_inode_t *ip,\r\nxfs_inode_t *tip,\r\nxfs_swapext_t *sxp)\r\n{\r\nxfs_mount_t *mp = ip->i_mount;\r\nxfs_trans_t *tp;\r\nxfs_bstat_t *sbp = &sxp->sx_stat;\r\nxfs_ifork_t *tempifp, *ifp, *tifp;\r\nint src_log_flags, target_log_flags;\r\nint error = 0;\r\nint aforkblks = 0;\r\nint taforkblks = 0;\r\n__uint64_t tmp;\r\nint lock_flags;\r\ntempifp = kmem_alloc(sizeof(xfs_ifork_t), KM_MAYFAIL);\r\nif (!tempifp) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nlock_flags = XFS_IOLOCK_EXCL;\r\nxfs_lock_two_inodes(ip, tip, XFS_IOLOCK_EXCL);\r\nif ((ip->i_d.di_mode & S_IFMT) != (tip->i_d.di_mode & S_IFMT)) {\r\nerror = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nif (XFS_IS_REALTIME_INODE(ip) != XFS_IS_REALTIME_INODE(tip)) {\r\nerror = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nerror = xfs_swap_extent_flush(ip);\r\nif (error)\r\ngoto out_unlock;\r\nerror = xfs_swap_extent_flush(tip);\r\nif (error)\r\ngoto out_unlock;\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_SWAPEXT);\r\nerror = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);\r\nif (error) {\r\nxfs_trans_cancel(tp, 0);\r\ngoto out_unlock;\r\n}\r\nxfs_lock_two_inodes(ip, tip, XFS_ILOCK_EXCL);\r\nlock_flags |= XFS_ILOCK_EXCL;\r\nif (sxp->sx_offset != 0 ||\r\nsxp->sx_length != ip->i_d.di_size ||\r\nsxp->sx_length != tip->i_d.di_size) {\r\nerror = -EFAULT;\r\ngoto out_trans_cancel;\r\n}\r\ntrace_xfs_swap_extent_before(ip, 0);\r\ntrace_xfs_swap_extent_before(tip, 1);\r\nerror = xfs_swap_extents_check_format(ip, tip);\r\nif (error) {\r\nxfs_notice(mp,\r\n"%s: inode 0x%llx format is incompatible for exchanging.",\r\n__func__, ip->i_ino);\r\ngoto out_trans_cancel;\r\n}\r\nif ((sbp->bs_ctime.tv_sec != VFS_I(ip)->i_ctime.tv_sec) ||\r\n(sbp->bs_ctime.tv_nsec != VFS_I(ip)->i_ctime.tv_nsec) ||\r\n(sbp->bs_mtime.tv_sec != VFS_I(ip)->i_mtime.tv_sec) ||\r\n(sbp->bs_mtime.tv_nsec != VFS_I(ip)->i_mtime.tv_nsec)) {\r\nerror = -EBUSY;\r\ngoto out_trans_cancel;\r\n}\r\nif ( ((XFS_IFORK_Q(ip) != 0) && (ip->i_d.di_anextents > 0)) &&\r\n(ip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)) {\r\nerror = xfs_bmap_count_blocks(tp, ip, XFS_ATTR_FORK, &aforkblks);\r\nif (error)\r\ngoto out_trans_cancel;\r\n}\r\nif ( ((XFS_IFORK_Q(tip) != 0) && (tip->i_d.di_anextents > 0)) &&\r\n(tip->i_d.di_aformat != XFS_DINODE_FMT_LOCAL)) {\r\nerror = xfs_bmap_count_blocks(tp, tip, XFS_ATTR_FORK,\r\n&taforkblks);\r\nif (error)\r\ngoto out_trans_cancel;\r\n}\r\nxfs_trans_ijoin(tp, ip, lock_flags);\r\nxfs_trans_ijoin(tp, tip, lock_flags);\r\nsrc_log_flags = XFS_ILOG_CORE;\r\ntarget_log_flags = XFS_ILOG_CORE;\r\nif (ip->i_d.di_version == 3 &&\r\nip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\r\ntarget_log_flags |= XFS_ILOG_DOWNER;\r\nerror = xfs_bmbt_change_owner(tp, ip, XFS_DATA_FORK,\r\ntip->i_ino, NULL);\r\nif (error)\r\ngoto out_trans_cancel;\r\n}\r\nif (tip->i_d.di_version == 3 &&\r\ntip->i_d.di_format == XFS_DINODE_FMT_BTREE) {\r\nsrc_log_flags |= XFS_ILOG_DOWNER;\r\nerror = xfs_bmbt_change_owner(tp, tip, XFS_DATA_FORK,\r\nip->i_ino, NULL);\r\nif (error)\r\ngoto out_trans_cancel;\r\n}\r\nifp = &ip->i_df;\r\ntifp = &tip->i_df;\r\n*tempifp = *ifp;\r\n*ifp = *tifp;\r\n*tifp = *tempifp;\r\ntmp = (__uint64_t)ip->i_d.di_nblocks;\r\nip->i_d.di_nblocks = tip->i_d.di_nblocks - taforkblks + aforkblks;\r\ntip->i_d.di_nblocks = tmp + taforkblks - aforkblks;\r\ntmp = (__uint64_t) ip->i_d.di_nextents;\r\nip->i_d.di_nextents = tip->i_d.di_nextents;\r\ntip->i_d.di_nextents = tmp;\r\ntmp = (__uint64_t) ip->i_d.di_format;\r\nip->i_d.di_format = tip->i_d.di_format;\r\ntip->i_d.di_format = tmp;\r\nASSERT(tip->i_delayed_blks == 0);\r\ntip->i_delayed_blks = ip->i_delayed_blks;\r\nip->i_delayed_blks = 0;\r\nswitch (ip->i_d.di_format) {\r\ncase XFS_DINODE_FMT_EXTENTS:\r\nif (ip->i_d.di_nextents <= XFS_INLINE_EXTS) {\r\nifp->if_u1.if_extents =\r\nifp->if_u2.if_inline_ext;\r\n}\r\nsrc_log_flags |= XFS_ILOG_DEXT;\r\nbreak;\r\ncase XFS_DINODE_FMT_BTREE:\r\nASSERT(ip->i_d.di_version < 3 ||\r\n(src_log_flags & XFS_ILOG_DOWNER));\r\nsrc_log_flags |= XFS_ILOG_DBROOT;\r\nbreak;\r\n}\r\nswitch (tip->i_d.di_format) {\r\ncase XFS_DINODE_FMT_EXTENTS:\r\nif (tip->i_d.di_nextents <= XFS_INLINE_EXTS) {\r\ntifp->if_u1.if_extents =\r\ntifp->if_u2.if_inline_ext;\r\n}\r\ntarget_log_flags |= XFS_ILOG_DEXT;\r\nbreak;\r\ncase XFS_DINODE_FMT_BTREE:\r\ntarget_log_flags |= XFS_ILOG_DBROOT;\r\nASSERT(tip->i_d.di_version < 3 ||\r\n(target_log_flags & XFS_ILOG_DOWNER));\r\nbreak;\r\n}\r\nxfs_trans_log_inode(tp, ip, src_log_flags);\r\nxfs_trans_log_inode(tp, tip, target_log_flags);\r\nif (mp->m_flags & XFS_MOUNT_WSYNC)\r\nxfs_trans_set_sync(tp);\r\nerror = xfs_trans_commit(tp, 0);\r\ntrace_xfs_swap_extent_after(ip, 0);\r\ntrace_xfs_swap_extent_after(tip, 1);\r\nout:\r\nkmem_free(tempifp);\r\nreturn error;\r\nout_unlock:\r\nxfs_iunlock(ip, lock_flags);\r\nxfs_iunlock(tip, lock_flags);\r\ngoto out;\r\nout_trans_cancel:\r\nxfs_trans_cancel(tp, 0);\r\ngoto out_unlock;\r\n}
