int arizona_clk32k_enable(struct arizona *arizona)\r\n{\r\nint ret = 0;\r\nmutex_lock(&arizona->clk_lock);\r\narizona->clk32k_ref++;\r\nif (arizona->clk32k_ref == 1) {\r\nswitch (arizona->pdata.clk32k_src) {\r\ncase ARIZONA_32KZ_MCLK1:\r\nret = pm_runtime_get_sync(arizona->dev);\r\nif (ret != 0)\r\ngoto out;\r\nbreak;\r\n}\r\nret = regmap_update_bits(arizona->regmap, ARIZONA_CLOCK_32K_1,\r\nARIZONA_CLK_32K_ENA,\r\nARIZONA_CLK_32K_ENA);\r\n}\r\nout:\r\nif (ret != 0)\r\narizona->clk32k_ref--;\r\nmutex_unlock(&arizona->clk_lock);\r\nreturn ret;\r\n}\r\nint arizona_clk32k_disable(struct arizona *arizona)\r\n{\r\nint ret = 0;\r\nmutex_lock(&arizona->clk_lock);\r\nBUG_ON(arizona->clk32k_ref <= 0);\r\narizona->clk32k_ref--;\r\nif (arizona->clk32k_ref == 0) {\r\nregmap_update_bits(arizona->regmap, ARIZONA_CLOCK_32K_1,\r\nARIZONA_CLK_32K_ENA, 0);\r\nswitch (arizona->pdata.clk32k_src) {\r\ncase ARIZONA_32KZ_MCLK1:\r\npm_runtime_put_sync(arizona->dev);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&arizona->clk_lock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t arizona_clkgen_err(int irq, void *data)\r\n{\r\nstruct arizona *arizona = data;\r\ndev_err(arizona->dev, "CLKGEN error\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t arizona_underclocked(int irq, void *data)\r\n{\r\nstruct arizona *arizona = data;\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(arizona->regmap, ARIZONA_INTERRUPT_RAW_STATUS_8,\r\n&val);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to read underclock status: %d\n",\r\nret);\r\nreturn IRQ_NONE;\r\n}\r\nif (val & ARIZONA_AIF3_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "AIF3 underclocked\n");\r\nif (val & ARIZONA_AIF2_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "AIF2 underclocked\n");\r\nif (val & ARIZONA_AIF1_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "AIF1 underclocked\n");\r\nif (val & ARIZONA_ISRC3_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "ISRC3 underclocked\n");\r\nif (val & ARIZONA_ISRC2_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "ISRC2 underclocked\n");\r\nif (val & ARIZONA_ISRC1_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "ISRC1 underclocked\n");\r\nif (val & ARIZONA_FX_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "FX underclocked\n");\r\nif (val & ARIZONA_ASRC_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "ASRC underclocked\n");\r\nif (val & ARIZONA_DAC_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "DAC underclocked\n");\r\nif (val & ARIZONA_ADC_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "ADC underclocked\n");\r\nif (val & ARIZONA_MIXER_UNDERCLOCKED_STS)\r\ndev_err(arizona->dev, "Mixer dropped sample\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t arizona_overclocked(int irq, void *data)\r\n{\r\nstruct arizona *arizona = data;\r\nunsigned int val[2];\r\nint ret;\r\nret = regmap_bulk_read(arizona->regmap, ARIZONA_INTERRUPT_RAW_STATUS_6,\r\n&val[0], 2);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to read overclock status: %d\n",\r\nret);\r\nreturn IRQ_NONE;\r\n}\r\nif (val[0] & ARIZONA_PWM_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "PWM overclocked\n");\r\nif (val[0] & ARIZONA_FX_CORE_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "FX core overclocked\n");\r\nif (val[0] & ARIZONA_DAC_SYS_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "DAC SYS overclocked\n");\r\nif (val[0] & ARIZONA_DAC_WARP_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "DAC WARP overclocked\n");\r\nif (val[0] & ARIZONA_ADC_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "ADC overclocked\n");\r\nif (val[0] & ARIZONA_MIXER_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "Mixer overclocked\n");\r\nif (val[0] & ARIZONA_AIF3_SYNC_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "AIF3 overclocked\n");\r\nif (val[0] & ARIZONA_AIF2_SYNC_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "AIF2 overclocked\n");\r\nif (val[0] & ARIZONA_AIF1_SYNC_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "AIF1 overclocked\n");\r\nif (val[0] & ARIZONA_PAD_CTRL_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "Pad control overclocked\n");\r\nif (val[1] & ARIZONA_SLIMBUS_SUBSYS_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "Slimbus subsystem overclocked\n");\r\nif (val[1] & ARIZONA_SLIMBUS_ASYNC_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "Slimbus async overclocked\n");\r\nif (val[1] & ARIZONA_SLIMBUS_SYNC_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "Slimbus sync overclocked\n");\r\nif (val[1] & ARIZONA_ASRC_ASYNC_SYS_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "ASRC async system overclocked\n");\r\nif (val[1] & ARIZONA_ASRC_ASYNC_WARP_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "ASRC async WARP overclocked\n");\r\nif (val[1] & ARIZONA_ASRC_SYNC_SYS_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "ASRC sync system overclocked\n");\r\nif (val[1] & ARIZONA_ASRC_SYNC_WARP_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "ASRC sync WARP overclocked\n");\r\nif (val[1] & ARIZONA_ADSP2_1_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "DSP1 overclocked\n");\r\nif (val[1] & ARIZONA_ISRC3_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "ISRC3 overclocked\n");\r\nif (val[1] & ARIZONA_ISRC2_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "ISRC2 overclocked\n");\r\nif (val[1] & ARIZONA_ISRC1_OVERCLOCKED_STS)\r\ndev_err(arizona->dev, "ISRC1 overclocked\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int arizona_poll_reg(struct arizona *arizona,\r\nint timeout, unsigned int reg,\r\nunsigned int mask, unsigned int target)\r\n{\r\nunsigned int val = 0;\r\nint ret, i;\r\nfor (i = 0; i < timeout; i++) {\r\nret = regmap_read(arizona->regmap, reg, &val);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to read reg %u: %d\n",\r\nreg, ret);\r\ncontinue;\r\n}\r\nif ((val & mask) == target)\r\nreturn 0;\r\nmsleep(1);\r\n}\r\ndev_err(arizona->dev, "Polling reg %u timed out: %x\n", reg, val);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int arizona_wait_for_boot(struct arizona *arizona)\r\n{\r\nint ret;\r\nret = arizona_poll_reg(arizona, 5, ARIZONA_INTERRUPT_RAW_STATUS_5,\r\nARIZONA_BOOT_DONE_STS, ARIZONA_BOOT_DONE_STS);\r\nif (!ret)\r\nregmap_write(arizona->regmap, ARIZONA_INTERRUPT_STATUS_5,\r\nARIZONA_BOOT_DONE_STS);\r\npm_runtime_mark_last_busy(arizona->dev);\r\nreturn ret;\r\n}\r\nstatic int arizona_apply_hardware_patch(struct arizona* arizona)\r\n{\r\nunsigned int fll, sysclk;\r\nint ret, err;\r\nret = regmap_read(arizona->regmap, ARIZONA_FLL1_CONTROL_1, &fll);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to cache FLL settings: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = regmap_read(arizona->regmap, ARIZONA_SYSTEM_CLOCK_1, &sysclk);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to cache SYSCLK settings: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = regmap_write(arizona->regmap, ARIZONA_FLL1_CONTROL_1,\r\nARIZONA_FLL1_ENA | ARIZONA_FLL1_FREERUN);\r\nif (ret != 0) {\r\ndev_err(arizona->dev,\r\n"Failed to start FLL in freerunning mode: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = arizona_poll_reg(arizona, 25, ARIZONA_INTERRUPT_RAW_STATUS_5,\r\nARIZONA_FLL1_CLOCK_OK_STS,\r\nARIZONA_FLL1_CLOCK_OK_STS);\r\nif (ret != 0) {\r\nret = -ETIMEDOUT;\r\ngoto err_fll;\r\n}\r\nret = regmap_write(arizona->regmap, ARIZONA_SYSTEM_CLOCK_1, 0x0144);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to start SYSCLK: %d\n", ret);\r\ngoto err_fll;\r\n}\r\nret = regmap_write(arizona->regmap, ARIZONA_WRITE_SEQUENCER_CTRL_0,\r\nARIZONA_WSEQ_ENA | ARIZONA_WSEQ_START | 160);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to start write sequencer: %d\n",\r\nret);\r\ngoto err_sysclk;\r\n}\r\nret = arizona_poll_reg(arizona, 5, ARIZONA_WRITE_SEQUENCER_CTRL_1,\r\nARIZONA_WSEQ_BUSY, 0);\r\nif (ret != 0) {\r\nregmap_write(arizona->regmap, ARIZONA_WRITE_SEQUENCER_CTRL_0,\r\nARIZONA_WSEQ_ABORT);\r\nret = -ETIMEDOUT;\r\n}\r\nerr_sysclk:\r\nerr = regmap_write(arizona->regmap, ARIZONA_SYSTEM_CLOCK_1, sysclk);\r\nif (err != 0) {\r\ndev_err(arizona->dev,\r\n"Failed to re-apply old SYSCLK settings: %d\n",\r\nerr);\r\n}\r\nerr_fll:\r\nerr = regmap_write(arizona->regmap, ARIZONA_FLL1_CONTROL_1, fll);\r\nif (err != 0) {\r\ndev_err(arizona->dev,\r\n"Failed to re-apply old FLL settings: %d\n",\r\nerr);\r\n}\r\nif (ret != 0)\r\nreturn ret;\r\nelse\r\nreturn err;\r\n}\r\nstatic int arizona_runtime_resume(struct device *dev)\r\n{\r\nstruct arizona *arizona = dev_get_drvdata(dev);\r\nint ret;\r\ndev_dbg(arizona->dev, "Leaving AoD mode\n");\r\nret = regulator_enable(arizona->dcvdd);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to enable DCVDD: %d\n", ret);\r\nreturn ret;\r\n}\r\nregcache_cache_only(arizona->regmap, false);\r\nswitch (arizona->type) {\r\ncase WM5102:\r\nif (arizona->external_dcvdd) {\r\nret = regmap_update_bits(arizona->regmap,\r\nARIZONA_ISOLATION_CONTROL,\r\nARIZONA_ISOLATE_DCVDD1, 0);\r\nif (ret != 0) {\r\ndev_err(arizona->dev,\r\n"Failed to connect DCVDD: %d\n", ret);\r\ngoto err;\r\n}\r\n}\r\nret = wm5102_patch(arizona);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to apply patch: %d\n",\r\nret);\r\ngoto err;\r\n}\r\nret = arizona_apply_hardware_patch(arizona);\r\nif (ret != 0) {\r\ndev_err(arizona->dev,\r\n"Failed to apply hardware patch: %d\n",\r\nret);\r\ngoto err;\r\n}\r\nbreak;\r\ndefault:\r\nret = arizona_wait_for_boot(arizona);\r\nif (ret != 0) {\r\ngoto err;\r\n}\r\nif (arizona->external_dcvdd) {\r\nret = regmap_update_bits(arizona->regmap,\r\nARIZONA_ISOLATION_CONTROL,\r\nARIZONA_ISOLATE_DCVDD1, 0);\r\nif (ret != 0) {\r\ndev_err(arizona->dev,\r\n"Failed to connect DCVDD: %d\n", ret);\r\ngoto err;\r\n}\r\n}\r\nbreak;\r\n}\r\nret = regcache_sync(arizona->regmap);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to restore register cache\n");\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nregcache_cache_only(arizona->regmap, true);\r\nregulator_disable(arizona->dcvdd);\r\nreturn ret;\r\n}\r\nstatic int arizona_runtime_suspend(struct device *dev)\r\n{\r\nstruct arizona *arizona = dev_get_drvdata(dev);\r\nint ret;\r\ndev_dbg(arizona->dev, "Entering AoD mode\n");\r\nif (arizona->external_dcvdd) {\r\nret = regmap_update_bits(arizona->regmap,\r\nARIZONA_ISOLATION_CONTROL,\r\nARIZONA_ISOLATE_DCVDD1,\r\nARIZONA_ISOLATE_DCVDD1);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to isolate DCVDD: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nregcache_cache_only(arizona->regmap, true);\r\nregcache_mark_dirty(arizona->regmap);\r\nregulator_disable(arizona->dcvdd);\r\nreturn 0;\r\n}\r\nstatic int arizona_suspend(struct device *dev)\r\n{\r\nstruct arizona *arizona = dev_get_drvdata(dev);\r\ndev_dbg(arizona->dev, "Suspend, disabling IRQ\n");\r\ndisable_irq(arizona->irq);\r\nreturn 0;\r\n}\r\nstatic int arizona_suspend_late(struct device *dev)\r\n{\r\nstruct arizona *arizona = dev_get_drvdata(dev);\r\ndev_dbg(arizona->dev, "Late suspend, reenabling IRQ\n");\r\nenable_irq(arizona->irq);\r\nreturn 0;\r\n}\r\nstatic int arizona_resume_noirq(struct device *dev)\r\n{\r\nstruct arizona *arizona = dev_get_drvdata(dev);\r\ndev_dbg(arizona->dev, "Early resume, disabling IRQ\n");\r\ndisable_irq(arizona->irq);\r\nreturn 0;\r\n}\r\nstatic int arizona_resume(struct device *dev)\r\n{\r\nstruct arizona *arizona = dev_get_drvdata(dev);\r\ndev_dbg(arizona->dev, "Late resume, reenabling IRQ\n");\r\nenable_irq(arizona->irq);\r\nreturn 0;\r\n}\r\nunsigned long arizona_of_get_type(struct device *dev)\r\n{\r\nconst struct of_device_id *id = of_match_device(arizona_of_match, dev);\r\nif (id)\r\nreturn (unsigned long)id->data;\r\nelse\r\nreturn 0;\r\n}\r\nint arizona_of_get_named_gpio(struct arizona *arizona, const char *prop,\r\nbool mandatory)\r\n{\r\nint gpio;\r\ngpio = of_get_named_gpio(arizona->dev->of_node, prop, 0);\r\nif (gpio < 0) {\r\nif (mandatory)\r\ndev_err(arizona->dev,\r\n"Mandatory DT gpio %s missing/malformed: %d\n",\r\nprop, gpio);\r\ngpio = 0;\r\n}\r\nreturn gpio;\r\n}\r\nstatic int arizona_of_get_core_pdata(struct arizona *arizona)\r\n{\r\nstruct arizona_pdata *pdata = &arizona->pdata;\r\nstruct property *prop;\r\nconst __be32 *cur;\r\nu32 val;\r\nint ret, i;\r\nint count = 0;\r\npdata->reset = arizona_of_get_named_gpio(arizona, "wlf,reset", true);\r\nret = of_property_read_u32_array(arizona->dev->of_node,\r\n"wlf,gpio-defaults",\r\narizona->pdata.gpio_defaults,\r\nARRAY_SIZE(arizona->pdata.gpio_defaults));\r\nif (ret >= 0) {\r\nfor (i = 0; i < ARRAY_SIZE(arizona->pdata.gpio_defaults); i++) {\r\nif (arizona->pdata.gpio_defaults[i] > 0xffff)\r\narizona->pdata.gpio_defaults[i] = 0;\r\nelse if (arizona->pdata.gpio_defaults[i] == 0)\r\narizona->pdata.gpio_defaults[i] = 0x10000;\r\n}\r\n} else {\r\ndev_err(arizona->dev, "Failed to parse GPIO defaults: %d\n",\r\nret);\r\n}\r\nof_property_for_each_u32(arizona->dev->of_node, "wlf,inmode", prop,\r\ncur, val) {\r\nif (count == ARRAY_SIZE(arizona->pdata.inmode))\r\nbreak;\r\narizona->pdata.inmode[count] = val;\r\ncount++;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int arizona_of_get_core_pdata(struct arizona *arizona)\r\n{\r\nreturn 0;\r\n}\r\nint arizona_dev_init(struct arizona *arizona)\r\n{\r\nstruct device *dev = arizona->dev;\r\nconst char *type_name;\r\nunsigned int reg, val;\r\nint (*apply_patch)(struct arizona *) = NULL;\r\nint ret, i;\r\ndev_set_drvdata(arizona->dev, arizona);\r\nmutex_init(&arizona->clk_lock);\r\nif (dev_get_platdata(arizona->dev))\r\nmemcpy(&arizona->pdata, dev_get_platdata(arizona->dev),\r\nsizeof(arizona->pdata));\r\nelse\r\narizona_of_get_core_pdata(arizona);\r\nregcache_cache_only(arizona->regmap, true);\r\nswitch (arizona->type) {\r\ncase WM5102:\r\ncase WM5110:\r\ncase WM8997:\r\nfor (i = 0; i < ARRAY_SIZE(wm5102_core_supplies); i++)\r\narizona->core_supplies[i].supply\r\n= wm5102_core_supplies[i];\r\narizona->num_core_supplies = ARRAY_SIZE(wm5102_core_supplies);\r\nbreak;\r\ndefault:\r\ndev_err(arizona->dev, "Unknown device type %d\n",\r\narizona->type);\r\nreturn -EINVAL;\r\n}\r\narizona->external_dcvdd = true;\r\nret = mfd_add_devices(arizona->dev, -1, early_devs,\r\nARRAY_SIZE(early_devs), NULL, 0, NULL);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to add early children: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_regulator_bulk_get(dev, arizona->num_core_supplies,\r\narizona->core_supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to request core supplies: %d\n",\r\nret);\r\ngoto err_early;\r\n}\r\narizona->dcvdd = regulator_get(arizona->dev, "DCVDD");\r\nif (IS_ERR(arizona->dcvdd)) {\r\nret = PTR_ERR(arizona->dcvdd);\r\ndev_err(dev, "Failed to request DCVDD: %d\n", ret);\r\ngoto err_early;\r\n}\r\nif (arizona->pdata.reset) {\r\nret = gpio_request_one(arizona->pdata.reset,\r\nGPIOF_DIR_OUT | GPIOF_INIT_LOW,\r\n"arizona /RESET");\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to request /RESET: %d\n", ret);\r\ngoto err_dcvdd;\r\n}\r\n}\r\nret = regulator_bulk_enable(arizona->num_core_supplies,\r\narizona->core_supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable core supplies: %d\n",\r\nret);\r\ngoto err_dcvdd;\r\n}\r\nret = regulator_enable(arizona->dcvdd);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable DCVDD: %d\n", ret);\r\ngoto err_enable;\r\n}\r\nif (arizona->pdata.reset) {\r\ngpio_set_value_cansleep(arizona->pdata.reset, 1);\r\nmsleep(1);\r\n}\r\nregcache_cache_only(arizona->regmap, false);\r\nret = regmap_read(arizona->regmap, ARIZONA_SOFTWARE_RESET, &reg);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to read ID register: %d\n", ret);\r\ngoto err_reset;\r\n}\r\nswitch (reg) {\r\ncase 0x5102:\r\ncase 0x5110:\r\ncase 0x8997:\r\nbreak;\r\ndefault:\r\ndev_err(arizona->dev, "Unknown device ID: %x\n", reg);\r\ngoto err_reset;\r\n}\r\nif (!arizona->pdata.reset) {\r\nregcache_mark_dirty(arizona->regmap);\r\nret = regmap_write(arizona->regmap, ARIZONA_SOFTWARE_RESET, 0);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to reset device: %d\n", ret);\r\ngoto err_reset;\r\n}\r\nmsleep(1);\r\nret = regcache_sync(arizona->regmap);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to sync device: %d\n", ret);\r\ngoto err_reset;\r\n}\r\n}\r\nswitch (arizona->type) {\r\ncase WM5102:\r\nret = regmap_read(arizona->regmap,\r\nARIZONA_WRITE_SEQUENCER_CTRL_3, &val);\r\nif (ret != 0)\r\ndev_err(dev,\r\n"Failed to check write sequencer state: %d\n",\r\nret);\r\nelse if (val & 0x01)\r\nbreak;\r\ndefault:\r\nret = arizona_wait_for_boot(arizona);\r\nif (ret != 0) {\r\ndev_err(arizona->dev,\r\n"Device failed initial boot: %d\n", ret);\r\ngoto err_reset;\r\n}\r\nbreak;\r\n}\r\nret = regmap_read(arizona->regmap, ARIZONA_SOFTWARE_RESET, &reg);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to read ID register: %d\n", ret);\r\ngoto err_reset;\r\n}\r\nret = regmap_read(arizona->regmap, ARIZONA_DEVICE_REVISION,\r\n&arizona->rev);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to read revision register: %d\n", ret);\r\ngoto err_reset;\r\n}\r\narizona->rev &= ARIZONA_DEVICE_REVISION_MASK;\r\nswitch (reg) {\r\n#ifdef CONFIG_MFD_WM5102\r\ncase 0x5102:\r\ntype_name = "WM5102";\r\nif (arizona->type != WM5102) {\r\ndev_err(arizona->dev, "WM5102 registered as %d\n",\r\narizona->type);\r\narizona->type = WM5102;\r\n}\r\napply_patch = wm5102_patch;\r\narizona->rev &= 0x7;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_MFD_WM5110\r\ncase 0x5110:\r\ntype_name = "WM5110";\r\nif (arizona->type != WM5110) {\r\ndev_err(arizona->dev, "WM5110 registered as %d\n",\r\narizona->type);\r\narizona->type = WM5110;\r\n}\r\napply_patch = wm5110_patch;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_MFD_WM8997\r\ncase 0x8997:\r\ntype_name = "WM8997";\r\nif (arizona->type != WM8997) {\r\ndev_err(arizona->dev, "WM8997 registered as %d\n",\r\narizona->type);\r\narizona->type = WM8997;\r\n}\r\napply_patch = wm8997_patch;\r\nbreak;\r\n#endif\r\ndefault:\r\ndev_err(arizona->dev, "Unknown device ID %x\n", reg);\r\ngoto err_reset;\r\n}\r\ndev_info(dev, "%s revision %c\n", type_name, arizona->rev + 'A');\r\nif (apply_patch) {\r\nret = apply_patch(arizona);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to apply patch: %d\n",\r\nret);\r\ngoto err_reset;\r\n}\r\nswitch (arizona->type) {\r\ncase WM5102:\r\nret = arizona_apply_hardware_patch(arizona);\r\nif (ret != 0) {\r\ndev_err(arizona->dev,\r\n"Failed to apply hardware patch: %d\n",\r\nret);\r\ngoto err_reset;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(arizona->pdata.gpio_defaults); i++) {\r\nif (!arizona->pdata.gpio_defaults[i])\r\ncontinue;\r\nregmap_write(arizona->regmap, ARIZONA_GPIO1_CTRL + i,\r\narizona->pdata.gpio_defaults[i]);\r\n}\r\npm_runtime_set_autosuspend_delay(arizona->dev, 100);\r\npm_runtime_use_autosuspend(arizona->dev);\r\npm_runtime_enable(arizona->dev);\r\nif (!arizona->pdata.clk32k_src)\r\narizona->pdata.clk32k_src = ARIZONA_32KZ_MCLK2;\r\nswitch (arizona->pdata.clk32k_src) {\r\ncase ARIZONA_32KZ_MCLK1:\r\ncase ARIZONA_32KZ_MCLK2:\r\nregmap_update_bits(arizona->regmap, ARIZONA_CLOCK_32K_1,\r\nARIZONA_CLK_32K_SRC_MASK,\r\narizona->pdata.clk32k_src - 1);\r\narizona_clk32k_enable(arizona);\r\nbreak;\r\ncase ARIZONA_32KZ_NONE:\r\nregmap_update_bits(arizona->regmap, ARIZONA_CLOCK_32K_1,\r\nARIZONA_CLK_32K_SRC_MASK, 2);\r\nbreak;\r\ndefault:\r\ndev_err(arizona->dev, "Invalid 32kHz clock source: %d\n",\r\narizona->pdata.clk32k_src);\r\nret = -EINVAL;\r\ngoto err_reset;\r\n}\r\nfor (i = 0; i < ARIZONA_MAX_MICBIAS; i++) {\r\nif (!arizona->pdata.micbias[i].mV &&\r\n!arizona->pdata.micbias[i].bypass)\r\ncontinue;\r\nif (!arizona->pdata.micbias[i].mV)\r\narizona->pdata.micbias[i].mV = 2800;\r\nval = (arizona->pdata.micbias[i].mV - 1500) / 100;\r\nval <<= ARIZONA_MICB1_LVL_SHIFT;\r\nif (arizona->pdata.micbias[i].ext_cap)\r\nval |= ARIZONA_MICB1_EXT_CAP;\r\nif (arizona->pdata.micbias[i].discharge)\r\nval |= ARIZONA_MICB1_DISCH;\r\nif (arizona->pdata.micbias[i].soft_start)\r\nval |= ARIZONA_MICB1_RATE;\r\nif (arizona->pdata.micbias[i].bypass)\r\nval |= ARIZONA_MICB1_BYPASS;\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_MIC_BIAS_CTRL_1 + i,\r\nARIZONA_MICB1_LVL_MASK |\r\nARIZONA_MICB1_EXT_CAP |\r\nARIZONA_MICB1_DISCH |\r\nARIZONA_MICB1_BYPASS |\r\nARIZONA_MICB1_RATE, val);\r\n}\r\nfor (i = 0; i < ARIZONA_MAX_INPUT; i++) {\r\nval = arizona->pdata.dmic_ref[i]\r\n<< ARIZONA_IN1_DMIC_SUP_SHIFT;\r\nval |= arizona->pdata.inmode[i] << ARIZONA_IN1_MODE_SHIFT;\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_IN1L_CONTROL + (i * 8),\r\nARIZONA_IN1_DMIC_SUP_MASK |\r\nARIZONA_IN1_MODE_MASK, val);\r\n}\r\nfor (i = 0; i < ARIZONA_MAX_OUTPUT; i++) {\r\nif (arizona->pdata.out_mono[i])\r\nval = ARIZONA_OUT1_MONO;\r\nelse\r\nval = 0;\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_OUTPUT_PATH_CONFIG_1L + (i * 8),\r\nARIZONA_OUT1_MONO, val);\r\n}\r\nfor (i = 0; i < ARIZONA_MAX_PDM_SPK; i++) {\r\nif (arizona->pdata.spk_mute[i])\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_PDM_SPK1_CTRL_1 + (i * 2),\r\nARIZONA_SPK1_MUTE_ENDIAN_MASK |\r\nARIZONA_SPK1_MUTE_SEQ1_MASK,\r\narizona->pdata.spk_mute[i]);\r\nif (arizona->pdata.spk_fmt[i])\r\nregmap_update_bits(arizona->regmap,\r\nARIZONA_PDM_SPK1_CTRL_2 + (i * 2),\r\nARIZONA_SPK1_FMT_MASK,\r\narizona->pdata.spk_fmt[i]);\r\n}\r\nret = arizona_irq_init(arizona);\r\nif (ret != 0)\r\ngoto err_reset;\r\narizona_request_irq(arizona, ARIZONA_IRQ_CLKGEN_ERR, "CLKGEN error",\r\narizona_clkgen_err, arizona);\r\narizona_request_irq(arizona, ARIZONA_IRQ_OVERCLOCKED, "Overclocked",\r\narizona_overclocked, arizona);\r\narizona_request_irq(arizona, ARIZONA_IRQ_UNDERCLOCKED, "Underclocked",\r\narizona_underclocked, arizona);\r\nswitch (arizona->type) {\r\ncase WM5102:\r\nret = mfd_add_devices(arizona->dev, -1, wm5102_devs,\r\nARRAY_SIZE(wm5102_devs), NULL, 0, NULL);\r\nbreak;\r\ncase WM5110:\r\nret = mfd_add_devices(arizona->dev, -1, wm5110_devs,\r\nARRAY_SIZE(wm5110_devs), NULL, 0, NULL);\r\nbreak;\r\ncase WM8997:\r\nret = mfd_add_devices(arizona->dev, -1, wm8997_devs,\r\nARRAY_SIZE(wm8997_devs), NULL, 0, NULL);\r\nbreak;\r\n}\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to add subdevices: %d\n", ret);\r\ngoto err_irq;\r\n}\r\n#ifdef CONFIG_PM\r\nregulator_disable(arizona->dcvdd);\r\n#endif\r\nreturn 0;\r\nerr_irq:\r\narizona_irq_exit(arizona);\r\nerr_reset:\r\nif (arizona->pdata.reset) {\r\ngpio_set_value_cansleep(arizona->pdata.reset, 0);\r\ngpio_free(arizona->pdata.reset);\r\n}\r\nregulator_disable(arizona->dcvdd);\r\nerr_enable:\r\nregulator_bulk_disable(arizona->num_core_supplies,\r\narizona->core_supplies);\r\nerr_dcvdd:\r\nregulator_put(arizona->dcvdd);\r\nerr_early:\r\nmfd_remove_devices(dev);\r\nreturn ret;\r\n}\r\nint arizona_dev_exit(struct arizona *arizona)\r\n{\r\npm_runtime_disable(arizona->dev);\r\nregulator_disable(arizona->dcvdd);\r\nregulator_put(arizona->dcvdd);\r\nmfd_remove_devices(arizona->dev);\r\narizona_free_irq(arizona, ARIZONA_IRQ_UNDERCLOCKED, arizona);\r\narizona_free_irq(arizona, ARIZONA_IRQ_OVERCLOCKED, arizona);\r\narizona_free_irq(arizona, ARIZONA_IRQ_CLKGEN_ERR, arizona);\r\narizona_irq_exit(arizona);\r\nif (arizona->pdata.reset)\r\ngpio_set_value_cansleep(arizona->pdata.reset, 0);\r\nregulator_bulk_disable(arizona->num_core_supplies,\r\narizona->core_supplies);\r\nreturn 0;\r\n}
