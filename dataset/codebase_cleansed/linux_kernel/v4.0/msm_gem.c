static dma_addr_t physaddr(struct drm_gem_object *obj)\r\n{\r\nstruct msm_gem_object *msm_obj = to_msm_bo(obj);\r\nstruct msm_drm_private *priv = obj->dev->dev_private;\r\nreturn (((dma_addr_t)msm_obj->vram_node->start) << PAGE_SHIFT) +\r\npriv->vram.paddr;\r\n}\r\nstatic struct page **get_pages_vram(struct drm_gem_object *obj,\r\nint npages)\r\n{\r\nstruct msm_gem_object *msm_obj = to_msm_bo(obj);\r\nstruct msm_drm_private *priv = obj->dev->dev_private;\r\ndma_addr_t paddr;\r\nstruct page **p;\r\nint ret, i;\r\np = drm_malloc_ab(npages, sizeof(struct page *));\r\nif (!p)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = drm_mm_insert_node(&priv->vram.mm, msm_obj->vram_node,\r\nnpages, 0, DRM_MM_SEARCH_DEFAULT);\r\nif (ret) {\r\ndrm_free_large(p);\r\nreturn ERR_PTR(ret);\r\n}\r\npaddr = physaddr(obj);\r\nfor (i = 0; i < npages; i++) {\r\np[i] = phys_to_page(paddr);\r\npaddr += PAGE_SIZE;\r\n}\r\nreturn p;\r\n}\r\nstatic struct page **get_pages(struct drm_gem_object *obj)\r\n{\r\nstruct msm_gem_object *msm_obj = to_msm_bo(obj);\r\nif (!msm_obj->pages) {\r\nstruct drm_device *dev = obj->dev;\r\nstruct page **p;\r\nint npages = obj->size >> PAGE_SHIFT;\r\nif (iommu_present(&platform_bus_type))\r\np = drm_gem_get_pages(obj);\r\nelse\r\np = get_pages_vram(obj, npages);\r\nif (IS_ERR(p)) {\r\ndev_err(dev->dev, "could not get pages: %ld\n",\r\nPTR_ERR(p));\r\nreturn p;\r\n}\r\nmsm_obj->sgt = drm_prime_pages_to_sg(p, npages);\r\nif (IS_ERR(msm_obj->sgt)) {\r\ndev_err(dev->dev, "failed to allocate sgt\n");\r\nreturn ERR_CAST(msm_obj->sgt);\r\n}\r\nmsm_obj->pages = p;\r\nif (msm_obj->flags & (MSM_BO_WC|MSM_BO_UNCACHED))\r\ndma_map_sg(dev->dev, msm_obj->sgt->sgl,\r\nmsm_obj->sgt->nents, DMA_BIDIRECTIONAL);\r\n}\r\nreturn msm_obj->pages;\r\n}\r\nstatic void put_pages(struct drm_gem_object *obj)\r\n{\r\nstruct msm_gem_object *msm_obj = to_msm_bo(obj);\r\nif (msm_obj->pages) {\r\nif (msm_obj->flags & (MSM_BO_WC|MSM_BO_UNCACHED))\r\ndma_unmap_sg(obj->dev->dev, msm_obj->sgt->sgl,\r\nmsm_obj->sgt->nents, DMA_BIDIRECTIONAL);\r\nsg_free_table(msm_obj->sgt);\r\nkfree(msm_obj->sgt);\r\nif (iommu_present(&platform_bus_type))\r\ndrm_gem_put_pages(obj, msm_obj->pages, true, false);\r\nelse {\r\ndrm_mm_remove_node(msm_obj->vram_node);\r\ndrm_free_large(msm_obj->pages);\r\n}\r\nmsm_obj->pages = NULL;\r\n}\r\n}\r\nstruct page **msm_gem_get_pages(struct drm_gem_object *obj)\r\n{\r\nstruct drm_device *dev = obj->dev;\r\nstruct page **p;\r\nmutex_lock(&dev->struct_mutex);\r\np = get_pages(obj);\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn p;\r\n}\r\nvoid msm_gem_put_pages(struct drm_gem_object *obj)\r\n{\r\n}\r\nint msm_gem_mmap_obj(struct drm_gem_object *obj,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct msm_gem_object *msm_obj = to_msm_bo(obj);\r\nvma->vm_flags &= ~VM_PFNMAP;\r\nvma->vm_flags |= VM_MIXEDMAP;\r\nif (msm_obj->flags & MSM_BO_WC) {\r\nvma->vm_page_prot = pgprot_writecombine(vm_get_page_prot(vma->vm_flags));\r\n} else if (msm_obj->flags & MSM_BO_UNCACHED) {\r\nvma->vm_page_prot = pgprot_noncached(vm_get_page_prot(vma->vm_flags));\r\n} else {\r\nfput(vma->vm_file);\r\nget_file(obj->filp);\r\nvma->vm_pgoff = 0;\r\nvma->vm_file = obj->filp;\r\nvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\r\n}\r\nreturn 0;\r\n}\r\nint msm_gem_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nint ret;\r\nret = drm_gem_mmap(filp, vma);\r\nif (ret) {\r\nDBG("mmap failed: %d", ret);\r\nreturn ret;\r\n}\r\nreturn msm_gem_mmap_obj(vma->vm_private_data, vma);\r\n}\r\nint msm_gem_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nstruct drm_gem_object *obj = vma->vm_private_data;\r\nstruct drm_device *dev = obj->dev;\r\nstruct page **pages;\r\nunsigned long pfn;\r\npgoff_t pgoff;\r\nint ret;\r\nret = mutex_lock_interruptible(&dev->struct_mutex);\r\nif (ret)\r\ngoto out;\r\npages = get_pages(obj);\r\nif (IS_ERR(pages)) {\r\nret = PTR_ERR(pages);\r\ngoto out_unlock;\r\n}\r\npgoff = ((unsigned long)vmf->virtual_address -\r\nvma->vm_start) >> PAGE_SHIFT;\r\npfn = page_to_pfn(pages[pgoff]);\r\nVERB("Inserting %p pfn %lx, pa %lx", vmf->virtual_address,\r\npfn, pfn << PAGE_SHIFT);\r\nret = vm_insert_mixed(vma, (unsigned long)vmf->virtual_address, pfn);\r\nout_unlock:\r\nmutex_unlock(&dev->struct_mutex);\r\nout:\r\nswitch (ret) {\r\ncase -EAGAIN:\r\ncase 0:\r\ncase -ERESTARTSYS:\r\ncase -EINTR:\r\ncase -EBUSY:\r\nreturn VM_FAULT_NOPAGE;\r\ncase -ENOMEM:\r\nreturn VM_FAULT_OOM;\r\ndefault:\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\n}\r\nstatic uint64_t mmap_offset(struct drm_gem_object *obj)\r\n{\r\nstruct drm_device *dev = obj->dev;\r\nint ret;\r\nWARN_ON(!mutex_is_locked(&dev->struct_mutex));\r\nret = drm_gem_create_mmap_offset(obj);\r\nif (ret) {\r\ndev_err(dev->dev, "could not allocate mmap offset\n");\r\nreturn 0;\r\n}\r\nreturn drm_vma_node_offset_addr(&obj->vma_node);\r\n}\r\nuint64_t msm_gem_mmap_offset(struct drm_gem_object *obj)\r\n{\r\nuint64_t offset;\r\nmutex_lock(&obj->dev->struct_mutex);\r\noffset = mmap_offset(obj);\r\nmutex_unlock(&obj->dev->struct_mutex);\r\nreturn offset;\r\n}\r\nint msm_gem_get_iova_locked(struct drm_gem_object *obj, int id,\r\nuint32_t *iova)\r\n{\r\nstruct msm_gem_object *msm_obj = to_msm_bo(obj);\r\nint ret = 0;\r\nif (!msm_obj->domain[id].iova) {\r\nstruct msm_drm_private *priv = obj->dev->dev_private;\r\nstruct page **pages = get_pages(obj);\r\nif (IS_ERR(pages))\r\nreturn PTR_ERR(pages);\r\nif (iommu_present(&platform_bus_type)) {\r\nstruct msm_mmu *mmu = priv->mmus[id];\r\nuint32_t offset;\r\nif (WARN_ON(!mmu))\r\nreturn -EINVAL;\r\noffset = (uint32_t)mmap_offset(obj);\r\nret = mmu->funcs->map(mmu, offset, msm_obj->sgt,\r\nobj->size, IOMMU_READ | IOMMU_WRITE);\r\nmsm_obj->domain[id].iova = offset;\r\n} else {\r\nmsm_obj->domain[id].iova = physaddr(obj);\r\n}\r\n}\r\nif (!ret)\r\n*iova = msm_obj->domain[id].iova;\r\nreturn ret;\r\n}\r\nint msm_gem_get_iova(struct drm_gem_object *obj, int id, uint32_t *iova)\r\n{\r\nstruct msm_gem_object *msm_obj = to_msm_bo(obj);\r\nint ret;\r\nif (msm_obj->domain[id].iova) {\r\n*iova = msm_obj->domain[id].iova;\r\nreturn 0;\r\n}\r\nmutex_lock(&obj->dev->struct_mutex);\r\nret = msm_gem_get_iova_locked(obj, id, iova);\r\nmutex_unlock(&obj->dev->struct_mutex);\r\nreturn ret;\r\n}\r\nuint32_t msm_gem_iova(struct drm_gem_object *obj, int id)\r\n{\r\nstruct msm_gem_object *msm_obj = to_msm_bo(obj);\r\nWARN_ON(!msm_obj->domain[id].iova);\r\nreturn msm_obj->domain[id].iova;\r\n}\r\nvoid msm_gem_put_iova(struct drm_gem_object *obj, int id)\r\n{\r\n}\r\nint msm_gem_dumb_create(struct drm_file *file, struct drm_device *dev,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nargs->pitch = align_pitch(args->width, args->bpp);\r\nargs->size = PAGE_ALIGN(args->pitch * args->height);\r\nreturn msm_gem_new_handle(dev, file, args->size,\r\nMSM_BO_SCANOUT | MSM_BO_WC, &args->handle);\r\n}\r\nint msm_gem_dumb_map_offset(struct drm_file *file, struct drm_device *dev,\r\nuint32_t handle, uint64_t *offset)\r\n{\r\nstruct drm_gem_object *obj;\r\nint ret = 0;\r\nobj = drm_gem_object_lookup(dev, file, handle);\r\nif (obj == NULL) {\r\nret = -ENOENT;\r\ngoto fail;\r\n}\r\n*offset = msm_gem_mmap_offset(obj);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nfail:\r\nreturn ret;\r\n}\r\nvoid *msm_gem_vaddr_locked(struct drm_gem_object *obj)\r\n{\r\nstruct msm_gem_object *msm_obj = to_msm_bo(obj);\r\nWARN_ON(!mutex_is_locked(&obj->dev->struct_mutex));\r\nif (!msm_obj->vaddr) {\r\nstruct page **pages = get_pages(obj);\r\nif (IS_ERR(pages))\r\nreturn ERR_CAST(pages);\r\nmsm_obj->vaddr = vmap(pages, obj->size >> PAGE_SHIFT,\r\nVM_MAP, pgprot_writecombine(PAGE_KERNEL));\r\n}\r\nreturn msm_obj->vaddr;\r\n}\r\nvoid *msm_gem_vaddr(struct drm_gem_object *obj)\r\n{\r\nvoid *ret;\r\nmutex_lock(&obj->dev->struct_mutex);\r\nret = msm_gem_vaddr_locked(obj);\r\nmutex_unlock(&obj->dev->struct_mutex);\r\nreturn ret;\r\n}\r\nint msm_gem_queue_inactive_cb(struct drm_gem_object *obj,\r\nstruct msm_fence_cb *cb)\r\n{\r\nstruct msm_gem_object *msm_obj = to_msm_bo(obj);\r\nuint32_t fence = msm_gem_fence(msm_obj,\r\nMSM_PREP_READ | MSM_PREP_WRITE);\r\nreturn msm_queue_fence_cb(obj->dev, cb, fence);\r\n}\r\nvoid msm_gem_move_to_active(struct drm_gem_object *obj,\r\nstruct msm_gpu *gpu, bool write, uint32_t fence)\r\n{\r\nstruct msm_gem_object *msm_obj = to_msm_bo(obj);\r\nmsm_obj->gpu = gpu;\r\nif (write)\r\nmsm_obj->write_fence = fence;\r\nelse\r\nmsm_obj->read_fence = fence;\r\nlist_del_init(&msm_obj->mm_list);\r\nlist_add_tail(&msm_obj->mm_list, &gpu->active_list);\r\n}\r\nvoid msm_gem_move_to_inactive(struct drm_gem_object *obj)\r\n{\r\nstruct drm_device *dev = obj->dev;\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nstruct msm_gem_object *msm_obj = to_msm_bo(obj);\r\nWARN_ON(!mutex_is_locked(&dev->struct_mutex));\r\nmsm_obj->gpu = NULL;\r\nmsm_obj->read_fence = 0;\r\nmsm_obj->write_fence = 0;\r\nlist_del_init(&msm_obj->mm_list);\r\nlist_add_tail(&msm_obj->mm_list, &priv->inactive_list);\r\n}\r\nint msm_gem_cpu_prep(struct drm_gem_object *obj, uint32_t op,\r\nstruct timespec *timeout)\r\n{\r\nstruct drm_device *dev = obj->dev;\r\nstruct msm_gem_object *msm_obj = to_msm_bo(obj);\r\nint ret = 0;\r\nif (is_active(msm_obj)) {\r\nuint32_t fence = msm_gem_fence(msm_obj, op);\r\nif (op & MSM_PREP_NOSYNC)\r\ntimeout = NULL;\r\nret = msm_wait_fence_interruptable(dev, fence, timeout);\r\n}\r\nreturn ret;\r\n}\r\nint msm_gem_cpu_fini(struct drm_gem_object *obj)\r\n{\r\nreturn 0;\r\n}\r\nvoid msm_gem_describe(struct drm_gem_object *obj, struct seq_file *m)\r\n{\r\nstruct drm_device *dev = obj->dev;\r\nstruct msm_gem_object *msm_obj = to_msm_bo(obj);\r\nuint64_t off = drm_vma_node_start(&obj->vma_node);\r\nWARN_ON(!mutex_is_locked(&dev->struct_mutex));\r\nseq_printf(m, "%08x: %c(r=%u,w=%u) %2d (%2d) %08llx %p %d\n",\r\nmsm_obj->flags, is_active(msm_obj) ? 'A' : 'I',\r\nmsm_obj->read_fence, msm_obj->write_fence,\r\nobj->name, obj->refcount.refcount.counter,\r\noff, msm_obj->vaddr, obj->size);\r\n}\r\nvoid msm_gem_describe_objects(struct list_head *list, struct seq_file *m)\r\n{\r\nstruct msm_gem_object *msm_obj;\r\nint count = 0;\r\nsize_t size = 0;\r\nlist_for_each_entry(msm_obj, list, mm_list) {\r\nstruct drm_gem_object *obj = &msm_obj->base;\r\nseq_printf(m, " ");\r\nmsm_gem_describe(obj, m);\r\ncount++;\r\nsize += obj->size;\r\n}\r\nseq_printf(m, "Total %d objects, %zu bytes\n", count, size);\r\n}\r\nvoid msm_gem_free_object(struct drm_gem_object *obj)\r\n{\r\nstruct drm_device *dev = obj->dev;\r\nstruct msm_drm_private *priv = obj->dev->dev_private;\r\nstruct msm_gem_object *msm_obj = to_msm_bo(obj);\r\nint id;\r\nWARN_ON(!mutex_is_locked(&dev->struct_mutex));\r\nWARN_ON(is_active(msm_obj));\r\nlist_del(&msm_obj->mm_list);\r\nfor (id = 0; id < ARRAY_SIZE(msm_obj->domain); id++) {\r\nstruct msm_mmu *mmu = priv->mmus[id];\r\nif (mmu && msm_obj->domain[id].iova) {\r\nuint32_t offset = msm_obj->domain[id].iova;\r\nmmu->funcs->unmap(mmu, offset, msm_obj->sgt, obj->size);\r\n}\r\n}\r\nif (obj->import_attach) {\r\nif (msm_obj->vaddr)\r\ndma_buf_vunmap(obj->import_attach->dmabuf, msm_obj->vaddr);\r\nif (msm_obj->pages)\r\ndrm_free_large(msm_obj->pages);\r\n} else {\r\nvunmap(msm_obj->vaddr);\r\nput_pages(obj);\r\n}\r\nif (msm_obj->resv == &msm_obj->_resv)\r\nreservation_object_fini(msm_obj->resv);\r\ndrm_gem_object_release(obj);\r\nkfree(msm_obj);\r\n}\r\nint msm_gem_new_handle(struct drm_device *dev, struct drm_file *file,\r\nuint32_t size, uint32_t flags, uint32_t *handle)\r\n{\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nret = mutex_lock_interruptible(&dev->struct_mutex);\r\nif (ret)\r\nreturn ret;\r\nobj = msm_gem_new(dev, size, flags);\r\nmutex_unlock(&dev->struct_mutex);\r\nif (IS_ERR(obj))\r\nreturn PTR_ERR(obj);\r\nret = drm_gem_handle_create(file, obj, handle);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ret;\r\n}\r\nstatic int msm_gem_new_impl(struct drm_device *dev,\r\nuint32_t size, uint32_t flags,\r\nstruct drm_gem_object **obj)\r\n{\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nstruct msm_gem_object *msm_obj;\r\nunsigned sz;\r\nswitch (flags & MSM_BO_CACHE_MASK) {\r\ncase MSM_BO_UNCACHED:\r\ncase MSM_BO_CACHED:\r\ncase MSM_BO_WC:\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "invalid cache flag: %x\n",\r\n(flags & MSM_BO_CACHE_MASK));\r\nreturn -EINVAL;\r\n}\r\nsz = sizeof(*msm_obj);\r\nif (!iommu_present(&platform_bus_type))\r\nsz += sizeof(struct drm_mm_node);\r\nmsm_obj = kzalloc(sz, GFP_KERNEL);\r\nif (!msm_obj)\r\nreturn -ENOMEM;\r\nif (!iommu_present(&platform_bus_type))\r\nmsm_obj->vram_node = (void *)&msm_obj[1];\r\nmsm_obj->flags = flags;\r\nmsm_obj->resv = &msm_obj->_resv;\r\nreservation_object_init(msm_obj->resv);\r\nINIT_LIST_HEAD(&msm_obj->submit_entry);\r\nlist_add_tail(&msm_obj->mm_list, &priv->inactive_list);\r\n*obj = &msm_obj->base;\r\nreturn 0;\r\n}\r\nstruct drm_gem_object *msm_gem_new(struct drm_device *dev,\r\nuint32_t size, uint32_t flags)\r\n{\r\nstruct drm_gem_object *obj = NULL;\r\nint ret;\r\nWARN_ON(!mutex_is_locked(&dev->struct_mutex));\r\nsize = PAGE_ALIGN(size);\r\nret = msm_gem_new_impl(dev, size, flags, &obj);\r\nif (ret)\r\ngoto fail;\r\nif (iommu_present(&platform_bus_type)) {\r\nret = drm_gem_object_init(dev, obj, size);\r\nif (ret)\r\ngoto fail;\r\n} else {\r\ndrm_gem_private_object_init(dev, obj, size);\r\n}\r\nreturn obj;\r\nfail:\r\nif (obj)\r\ndrm_gem_object_unreference(obj);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct drm_gem_object *msm_gem_import(struct drm_device *dev,\r\nuint32_t size, struct sg_table *sgt)\r\n{\r\nstruct msm_gem_object *msm_obj;\r\nstruct drm_gem_object *obj;\r\nint ret, npages;\r\nif (!iommu_present(&platform_bus_type)) {\r\ndev_err(dev->dev, "cannot import without IOMMU\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nsize = PAGE_ALIGN(size);\r\nret = msm_gem_new_impl(dev, size, MSM_BO_WC, &obj);\r\nif (ret)\r\ngoto fail;\r\ndrm_gem_private_object_init(dev, obj, size);\r\nnpages = size / PAGE_SIZE;\r\nmsm_obj = to_msm_bo(obj);\r\nmsm_obj->sgt = sgt;\r\nmsm_obj->pages = drm_malloc_ab(npages, sizeof(struct page *));\r\nif (!msm_obj->pages) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nret = drm_prime_sg_to_page_addr_arrays(sgt, msm_obj->pages, NULL, npages);\r\nif (ret)\r\ngoto fail;\r\nreturn obj;\r\nfail:\r\nif (obj)\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ERR_PTR(ret);\r\n}
