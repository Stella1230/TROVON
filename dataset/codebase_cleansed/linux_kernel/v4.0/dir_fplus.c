static int\r\nadfs_fplus_read(struct super_block *sb, unsigned int id, unsigned int sz, struct adfs_dir *dir)\r\n{\r\nstruct adfs_bigdirheader *h;\r\nstruct adfs_bigdirtail *t;\r\nunsigned long block;\r\nunsigned int blk, size;\r\nint i, ret = -EIO;\r\ndir->nr_buffers = 0;\r\ndir->bh_fplus = &dir->bh[0];\r\nblock = __adfs_block_map(sb, id, 0);\r\nif (!block) {\r\nadfs_error(sb, "dir object %X has a hole at offset 0", id);\r\ngoto out;\r\n}\r\ndir->bh_fplus[0] = sb_bread(sb, block);\r\nif (!dir->bh_fplus[0])\r\ngoto out;\r\ndir->nr_buffers += 1;\r\nh = (struct adfs_bigdirheader *)dir->bh_fplus[0]->b_data;\r\nsize = le32_to_cpu(h->bigdirsize);\r\nif (size != sz) {\r\nprintk(KERN_WARNING "adfs: adfs_fplus_read:"\r\n" directory header size %X\n"\r\n" does not match directory size %X\n",\r\nsize, sz);\r\n}\r\nif (h->bigdirversion[0] != 0 || h->bigdirversion[1] != 0 ||\r\nh->bigdirversion[2] != 0 || size & 2047 ||\r\nh->bigdirstartname != cpu_to_le32(BIGDIRSTARTNAME)) {\r\nprintk(KERN_WARNING "adfs: dir object %X has"\r\n" malformed dir header\n", id);\r\ngoto out;\r\n}\r\nsize >>= sb->s_blocksize_bits;\r\nif (size > ARRAY_SIZE(dir->bh)) {\r\nstruct buffer_head **bh_fplus =\r\nkcalloc(size, sizeof(struct buffer_head *),\r\nGFP_KERNEL);\r\nif (!bh_fplus) {\r\nadfs_error(sb, "not enough memory for"\r\n" dir object %X (%d blocks)", id, size);\r\ngoto out;\r\n}\r\ndir->bh_fplus = bh_fplus;\r\ndir->bh_fplus[0] = dir->bh[0];\r\n}\r\nfor (blk = 1; blk < size; blk++) {\r\nblock = __adfs_block_map(sb, id, blk);\r\nif (!block) {\r\nadfs_error(sb, "dir object %X has a hole at offset %d", id, blk);\r\ngoto out;\r\n}\r\ndir->bh_fplus[blk] = sb_bread(sb, block);\r\nif (!dir->bh_fplus[blk]) {\r\nadfs_error(sb, "dir object %x failed read for offset %d, mapped block %lX",\r\nid, blk, block);\r\ngoto out;\r\n}\r\ndir->nr_buffers += 1;\r\n}\r\nt = (struct adfs_bigdirtail *)\r\n(dir->bh_fplus[size - 1]->b_data + (sb->s_blocksize - 8));\r\nif (t->bigdirendname != cpu_to_le32(BIGDIRENDNAME) ||\r\nt->bigdirendmasseq != h->startmasseq ||\r\nt->reserved[0] != 0 || t->reserved[1] != 0) {\r\nprintk(KERN_WARNING "adfs: dir object %X has "\r\n"malformed dir end\n", id);\r\ngoto out;\r\n}\r\ndir->parent_id = le32_to_cpu(h->bigdirparent);\r\ndir->sb = sb;\r\nreturn 0;\r\nout:\r\nif (dir->bh_fplus) {\r\nfor (i = 0; i < dir->nr_buffers; i++)\r\nbrelse(dir->bh_fplus[i]);\r\nif (&dir->bh[0] != dir->bh_fplus)\r\nkfree(dir->bh_fplus);\r\ndir->bh_fplus = NULL;\r\n}\r\ndir->nr_buffers = 0;\r\ndir->sb = NULL;\r\nreturn ret;\r\n}\r\nstatic int\r\nadfs_fplus_setpos(struct adfs_dir *dir, unsigned int fpos)\r\n{\r\nstruct adfs_bigdirheader *h =\r\n(struct adfs_bigdirheader *) dir->bh_fplus[0]->b_data;\r\nint ret = -ENOENT;\r\nif (fpos <= le32_to_cpu(h->bigdirentries)) {\r\ndir->pos = fpos;\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void\r\ndir_memcpy(struct adfs_dir *dir, unsigned int offset, void *to, int len)\r\n{\r\nstruct super_block *sb = dir->sb;\r\nunsigned int buffer, partial, remainder;\r\nbuffer = offset >> sb->s_blocksize_bits;\r\noffset &= sb->s_blocksize - 1;\r\npartial = sb->s_blocksize - offset;\r\nif (partial >= len)\r\nmemcpy(to, dir->bh_fplus[buffer]->b_data + offset, len);\r\nelse {\r\nchar *c = (char *)to;\r\nremainder = len - partial;\r\nmemcpy(c,\r\ndir->bh_fplus[buffer]->b_data + offset,\r\npartial);\r\nmemcpy(c + partial,\r\ndir->bh_fplus[buffer + 1]->b_data,\r\nremainder);\r\n}\r\n}\r\nstatic int\r\nadfs_fplus_getnext(struct adfs_dir *dir, struct object_info *obj)\r\n{\r\nstruct adfs_bigdirheader *h =\r\n(struct adfs_bigdirheader *) dir->bh_fplus[0]->b_data;\r\nstruct adfs_bigdirentry bde;\r\nunsigned int offset;\r\nint i, ret = -ENOENT;\r\nif (dir->pos >= le32_to_cpu(h->bigdirentries))\r\ngoto out;\r\noffset = offsetof(struct adfs_bigdirheader, bigdirname);\r\noffset += ((le32_to_cpu(h->bigdirnamelen) + 4) & ~3);\r\noffset += dir->pos * sizeof(struct adfs_bigdirentry);\r\ndir_memcpy(dir, offset, &bde, sizeof(struct adfs_bigdirentry));\r\nobj->loadaddr = le32_to_cpu(bde.bigdirload);\r\nobj->execaddr = le32_to_cpu(bde.bigdirexec);\r\nobj->size = le32_to_cpu(bde.bigdirlen);\r\nobj->file_id = le32_to_cpu(bde.bigdirindaddr);\r\nobj->attr = le32_to_cpu(bde.bigdirattr);\r\nobj->name_len = le32_to_cpu(bde.bigdirobnamelen);\r\noffset = offsetof(struct adfs_bigdirheader, bigdirname);\r\noffset += ((le32_to_cpu(h->bigdirnamelen) + 4) & ~3);\r\noffset += le32_to_cpu(h->bigdirentries) * sizeof(struct adfs_bigdirentry);\r\noffset += le32_to_cpu(bde.bigdirobnameptr);\r\ndir_memcpy(dir, offset, obj->name, obj->name_len);\r\nfor (i = 0; i < obj->name_len; i++)\r\nif (obj->name[i] == '/')\r\nobj->name[i] = '.';\r\nobj->filetype = -1;\r\nif ((0 == (obj->attr & ADFS_NDA_DIRECTORY)) &&\r\n(0xfff00000 == (0xfff00000 & obj->loadaddr))) {\r\nobj->filetype = (__u16) ((0x000fff00 & obj->loadaddr) >> 8);\r\nif (ADFS_SB(dir->sb)->s_ftsuffix)\r\nobj->name_len +=\r\nappend_filetype_suffix(\r\n&obj->name[obj->name_len],\r\nobj->filetype);\r\n}\r\ndir->pos += 1;\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\nadfs_fplus_sync(struct adfs_dir *dir)\r\n{\r\nint err = 0;\r\nint i;\r\nfor (i = dir->nr_buffers - 1; i >= 0; i--) {\r\nstruct buffer_head *bh = dir->bh_fplus[i];\r\nsync_dirty_buffer(bh);\r\nif (buffer_req(bh) && !buffer_uptodate(bh))\r\nerr = -EIO;\r\n}\r\nreturn err;\r\n}\r\nstatic void\r\nadfs_fplus_free(struct adfs_dir *dir)\r\n{\r\nint i;\r\nif (dir->bh_fplus) {\r\nfor (i = 0; i < dir->nr_buffers; i++)\r\nbrelse(dir->bh_fplus[i]);\r\nif (&dir->bh[0] != dir->bh_fplus)\r\nkfree(dir->bh_fplus);\r\ndir->bh_fplus = NULL;\r\n}\r\ndir->nr_buffers = 0;\r\ndir->sb = NULL;\r\n}
