STATIC int\r\nxfs_readlink_bmap(\r\nstruct xfs_inode *ip,\r\nchar *link)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nstruct xfs_bmbt_irec mval[XFS_SYMLINK_MAPS];\r\nstruct xfs_buf *bp;\r\nxfs_daddr_t d;\r\nchar *cur_chunk;\r\nint pathlen = ip->i_d.di_size;\r\nint nmaps = XFS_SYMLINK_MAPS;\r\nint byte_cnt;\r\nint n;\r\nint error = 0;\r\nint fsblocks = 0;\r\nint offset;\r\nfsblocks = xfs_symlink_blocks(mp, pathlen);\r\nerror = xfs_bmapi_read(ip, 0, fsblocks, mval, &nmaps, 0);\r\nif (error)\r\ngoto out;\r\noffset = 0;\r\nfor (n = 0; n < nmaps; n++) {\r\nd = XFS_FSB_TO_DADDR(mp, mval[n].br_startblock);\r\nbyte_cnt = XFS_FSB_TO_B(mp, mval[n].br_blockcount);\r\nbp = xfs_buf_read(mp->m_ddev_targp, d, BTOBB(byte_cnt), 0,\r\n&xfs_symlink_buf_ops);\r\nif (!bp)\r\nreturn -ENOMEM;\r\nerror = bp->b_error;\r\nif (error) {\r\nxfs_buf_ioerror_alert(bp, __func__);\r\nxfs_buf_relse(bp);\r\nif (error == -EFSBADCRC)\r\nerror = -EFSCORRUPTED;\r\ngoto out;\r\n}\r\nbyte_cnt = XFS_SYMLINK_BUF_SPACE(mp, byte_cnt);\r\nif (pathlen < byte_cnt)\r\nbyte_cnt = pathlen;\r\ncur_chunk = bp->b_addr;\r\nif (xfs_sb_version_hascrc(&mp->m_sb)) {\r\nif (!xfs_symlink_hdr_ok(ip->i_ino, offset,\r\nbyte_cnt, bp)) {\r\nerror = -EFSCORRUPTED;\r\nxfs_alert(mp,\r\n"symlink header does not match required off/len/owner (0x%x/Ox%x,0x%llx)",\r\noffset, byte_cnt, ip->i_ino);\r\nxfs_buf_relse(bp);\r\ngoto out;\r\n}\r\ncur_chunk += sizeof(struct xfs_dsymlink_hdr);\r\n}\r\nmemcpy(link + offset, bp->b_addr, byte_cnt);\r\npathlen -= byte_cnt;\r\noffset += byte_cnt;\r\nxfs_buf_relse(bp);\r\n}\r\nASSERT(pathlen == 0);\r\nlink[ip->i_d.di_size] = '\0';\r\nerror = 0;\r\nout:\r\nreturn error;\r\n}\r\nint\r\nxfs_readlink(\r\nstruct xfs_inode *ip,\r\nchar *link)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nxfs_fsize_t pathlen;\r\nint error = 0;\r\ntrace_xfs_readlink(ip);\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn -EIO;\r\nxfs_ilock(ip, XFS_ILOCK_SHARED);\r\npathlen = ip->i_d.di_size;\r\nif (!pathlen)\r\ngoto out;\r\nif (pathlen < 0 || pathlen > MAXPATHLEN) {\r\nxfs_alert(mp, "%s: inode (%llu) bad symlink length (%lld)",\r\n__func__, (unsigned long long) ip->i_ino,\r\n(long long) pathlen);\r\nASSERT(0);\r\nerror = -EFSCORRUPTED;\r\ngoto out;\r\n}\r\nif (ip->i_df.if_flags & XFS_IFINLINE) {\r\nmemcpy(link, ip->i_df.if_u1.if_data, pathlen);\r\nlink[pathlen] = '\0';\r\n} else {\r\nerror = xfs_readlink_bmap(ip, link);\r\n}\r\nout:\r\nxfs_iunlock(ip, XFS_ILOCK_SHARED);\r\nreturn error;\r\n}\r\nint\r\nxfs_symlink(\r\nstruct xfs_inode *dp,\r\nstruct xfs_name *link_name,\r\nconst char *target_path,\r\numode_t mode,\r\nstruct xfs_inode **ipp)\r\n{\r\nstruct xfs_mount *mp = dp->i_mount;\r\nstruct xfs_trans *tp = NULL;\r\nstruct xfs_inode *ip = NULL;\r\nint error = 0;\r\nint pathlen;\r\nstruct xfs_bmap_free free_list;\r\nxfs_fsblock_t first_block;\r\nbool unlock_dp_on_error = false;\r\nuint cancel_flags;\r\nint committed;\r\nxfs_fileoff_t first_fsb;\r\nxfs_filblks_t fs_blocks;\r\nint nmaps;\r\nstruct xfs_bmbt_irec mval[XFS_SYMLINK_MAPS];\r\nxfs_daddr_t d;\r\nconst char *cur_chunk;\r\nint byte_cnt;\r\nint n;\r\nxfs_buf_t *bp;\r\nprid_t prid;\r\nstruct xfs_dquot *udqp = NULL;\r\nstruct xfs_dquot *gdqp = NULL;\r\nstruct xfs_dquot *pdqp = NULL;\r\nuint resblks;\r\n*ipp = NULL;\r\ntrace_xfs_symlink(dp, link_name);\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn -EIO;\r\npathlen = strlen(target_path);\r\nif (pathlen >= MAXPATHLEN)\r\nreturn -ENAMETOOLONG;\r\nudqp = gdqp = NULL;\r\nprid = xfs_get_initial_prid(dp);\r\nerror = xfs_qm_vop_dqalloc(dp,\r\nxfs_kuid_to_uid(current_fsuid()),\r\nxfs_kgid_to_gid(current_fsgid()), prid,\r\nXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT,\r\n&udqp, &gdqp, &pdqp);\r\nif (error)\r\ngoto std_return;\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_SYMLINK);\r\ncancel_flags = XFS_TRANS_RELEASE_LOG_RES;\r\nif (pathlen <= XFS_LITINO(mp, dp->i_d.di_version))\r\nfs_blocks = 0;\r\nelse\r\nfs_blocks = xfs_symlink_blocks(mp, pathlen);\r\nresblks = XFS_SYMLINK_SPACE_RES(mp, link_name->len, fs_blocks);\r\nerror = xfs_trans_reserve(tp, &M_RES(mp)->tr_symlink, resblks, 0);\r\nif (error == -ENOSPC && fs_blocks == 0) {\r\nresblks = 0;\r\nerror = xfs_trans_reserve(tp, &M_RES(mp)->tr_symlink, 0, 0);\r\n}\r\nif (error) {\r\ncancel_flags = 0;\r\ngoto error_return;\r\n}\r\nxfs_ilock(dp, XFS_ILOCK_EXCL | XFS_ILOCK_PARENT);\r\nunlock_dp_on_error = true;\r\nif (dp->i_d.di_flags & XFS_DIFLAG_NOSYMLINKS) {\r\nerror = -EPERM;\r\ngoto error_return;\r\n}\r\nerror = xfs_trans_reserve_quota(tp, mp, udqp, gdqp,\r\npdqp, resblks, 1, 0);\r\nif (error)\r\ngoto error_return;\r\nif (!resblks) {\r\nerror = xfs_dir_canenter(tp, dp, link_name);\r\nif (error)\r\ngoto error_return;\r\n}\r\nxfs_bmap_init(&free_list, &first_block);\r\nerror = xfs_dir_ialloc(&tp, dp, S_IFLNK | (mode & ~S_IFMT), 1, 0,\r\nprid, resblks > 0, &ip, NULL);\r\nif (error) {\r\nif (error == -ENOSPC)\r\ngoto error_return;\r\ngoto error1;\r\n}\r\nxfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\r\nunlock_dp_on_error = false;\r\nxfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp, pdqp);\r\nif (resblks)\r\nresblks -= XFS_IALLOC_SPACE_RES(mp);\r\nif (pathlen <= XFS_IFORK_DSIZE(ip)) {\r\nxfs_idata_realloc(ip, pathlen, XFS_DATA_FORK);\r\nmemcpy(ip->i_df.if_u1.if_data, target_path, pathlen);\r\nip->i_d.di_size = pathlen;\r\nip->i_df.if_flags &= ~(XFS_IFEXTENTS | XFS_IFBROOT);\r\nip->i_df.if_flags |= XFS_IFINLINE;\r\nip->i_d.di_format = XFS_DINODE_FMT_LOCAL;\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_DDATA | XFS_ILOG_CORE);\r\n} else {\r\nint offset;\r\nfirst_fsb = 0;\r\nnmaps = XFS_SYMLINK_MAPS;\r\nerror = xfs_bmapi_write(tp, ip, first_fsb, fs_blocks,\r\nXFS_BMAPI_METADATA, &first_block, resblks,\r\nmval, &nmaps, &free_list);\r\nif (error)\r\ngoto error2;\r\nif (resblks)\r\nresblks -= fs_blocks;\r\nip->i_d.di_size = pathlen;\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\ncur_chunk = target_path;\r\noffset = 0;\r\nfor (n = 0; n < nmaps; n++) {\r\nchar *buf;\r\nd = XFS_FSB_TO_DADDR(mp, mval[n].br_startblock);\r\nbyte_cnt = XFS_FSB_TO_B(mp, mval[n].br_blockcount);\r\nbp = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,\r\nBTOBB(byte_cnt), 0);\r\nif (!bp) {\r\nerror = -ENOMEM;\r\ngoto error2;\r\n}\r\nbp->b_ops = &xfs_symlink_buf_ops;\r\nbyte_cnt = XFS_SYMLINK_BUF_SPACE(mp, byte_cnt);\r\nbyte_cnt = min(byte_cnt, pathlen);\r\nbuf = bp->b_addr;\r\nbuf += xfs_symlink_hdr_set(mp, ip->i_ino, offset,\r\nbyte_cnt, bp);\r\nmemcpy(buf, cur_chunk, byte_cnt);\r\ncur_chunk += byte_cnt;\r\npathlen -= byte_cnt;\r\noffset += byte_cnt;\r\nxfs_trans_buf_set_type(tp, bp, XFS_BLFT_SYMLINK_BUF);\r\nxfs_trans_log_buf(tp, bp, 0, (buf + byte_cnt - 1) -\r\n(char *)bp->b_addr);\r\n}\r\nASSERT(pathlen == 0);\r\n}\r\nerror = xfs_dir_createname(tp, dp, link_name, ip->i_ino,\r\n&first_block, &free_list, resblks);\r\nif (error)\r\ngoto error2;\r\nxfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\r\nxfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\r\nif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {\r\nxfs_trans_set_sync(tp);\r\n}\r\nerror = xfs_bmap_finish(&tp, &free_list, &committed);\r\nif (error) {\r\ngoto error2;\r\n}\r\nerror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\r\nxfs_qm_dqrele(udqp);\r\nxfs_qm_dqrele(gdqp);\r\nxfs_qm_dqrele(pdqp);\r\n*ipp = ip;\r\nreturn 0;\r\nerror2:\r\nIRELE(ip);\r\nerror1:\r\nxfs_bmap_cancel(&free_list);\r\ncancel_flags |= XFS_TRANS_ABORT;\r\nerror_return:\r\nxfs_trans_cancel(tp, cancel_flags);\r\nxfs_qm_dqrele(udqp);\r\nxfs_qm_dqrele(gdqp);\r\nxfs_qm_dqrele(pdqp);\r\nif (unlock_dp_on_error)\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nstd_return:\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_inactive_symlink_rmt(\r\nstruct xfs_inode *ip)\r\n{\r\nxfs_buf_t *bp;\r\nint committed;\r\nint done;\r\nint error;\r\nxfs_fsblock_t first_block;\r\nxfs_bmap_free_t free_list;\r\nint i;\r\nxfs_mount_t *mp;\r\nxfs_bmbt_irec_t mval[XFS_SYMLINK_MAPS];\r\nint nmaps;\r\nint size;\r\nxfs_trans_t *tp;\r\nmp = ip->i_mount;\r\nASSERT(ip->i_df.if_flags & XFS_IFEXTENTS);\r\nASSERT(ip->i_d.di_nextents > 0 && ip->i_d.di_nextents <= 2);\r\ntp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\r\nerror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\r\nif (error) {\r\nxfs_trans_cancel(tp, 0);\r\nreturn error;\r\n}\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, ip, 0);\r\nsize = (int)ip->i_d.di_size;\r\nip->i_d.di_size = 0;\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\ndone = 0;\r\nxfs_bmap_init(&free_list, &first_block);\r\nnmaps = ARRAY_SIZE(mval);\r\nerror = xfs_bmapi_read(ip, 0, xfs_symlink_blocks(mp, size),\r\nmval, &nmaps, 0);\r\nif (error)\r\ngoto error_trans_cancel;\r\nfor (i = 0; i < nmaps; i++) {\r\nbp = xfs_trans_get_buf(tp, mp->m_ddev_targp,\r\nXFS_FSB_TO_DADDR(mp, mval[i].br_startblock),\r\nXFS_FSB_TO_BB(mp, mval[i].br_blockcount), 0);\r\nif (!bp) {\r\nerror = -ENOMEM;\r\ngoto error_bmap_cancel;\r\n}\r\nxfs_trans_binval(tp, bp);\r\n}\r\nerror = xfs_bunmapi(tp, ip, 0, size, XFS_BMAPI_METADATA, nmaps,\r\n&first_block, &free_list, &done);\r\nif (error)\r\ngoto error_bmap_cancel;\r\nASSERT(done);\r\nerror = xfs_bmap_finish(&tp, &free_list, &committed);\r\nif (error)\r\ngoto error_bmap_cancel;\r\nASSERT(committed);\r\nxfs_trans_ijoin(tp, ip, 0);\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\nerror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\r\nif (error) {\r\nASSERT(XFS_FORCED_SHUTDOWN(mp));\r\ngoto error_unlock;\r\n}\r\nif (ip->i_df.if_bytes)\r\nxfs_idata_realloc(ip, -ip->i_df.if_bytes, XFS_DATA_FORK);\r\nASSERT(ip->i_df.if_bytes == 0);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nreturn 0;\r\nerror_bmap_cancel:\r\nxfs_bmap_cancel(&free_list);\r\nerror_trans_cancel:\r\nxfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\r\nerror_unlock:\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nreturn error;\r\n}\r\nint\r\nxfs_inactive_symlink(\r\nstruct xfs_inode *ip)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nint pathlen;\r\ntrace_xfs_inactive_symlink(ip);\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn -EIO;\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\npathlen = (int)ip->i_d.di_size;\r\nif (!pathlen) {\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nreturn 0;\r\n}\r\nif (pathlen < 0 || pathlen > MAXPATHLEN) {\r\nxfs_alert(mp, "%s: inode (0x%llx) bad symlink length (%d)",\r\n__func__, (unsigned long long)ip->i_ino, pathlen);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nASSERT(0);\r\nreturn -EFSCORRUPTED;\r\n}\r\nif (ip->i_df.if_flags & XFS_IFINLINE) {\r\nif (ip->i_df.if_bytes > 0)\r\nxfs_idata_realloc(ip, -(ip->i_df.if_bytes),\r\nXFS_DATA_FORK);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nASSERT(ip->i_df.if_bytes == 0);\r\nreturn 0;\r\n}\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nreturn xfs_inactive_symlink_rmt(ip);\r\n}
