static void bcd2000_dump_buffer(const char *prefix, const char *buf, int len)\r\n{\r\nprint_hex_dump(KERN_DEBUG, prefix,\r\nDUMP_PREFIX_NONE, 16, 1,\r\nbuf, len, false);\r\n}\r\nstatic void bcd2000_dump_buffer(const char *prefix, const char *buf, int len) {}\r\nstatic int bcd2000_midi_input_open(struct snd_rawmidi_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bcd2000_midi_input_close(struct snd_rawmidi_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic void bcd2000_midi_input_trigger(struct snd_rawmidi_substream *substream,\r\nint up)\r\n{\r\nstruct bcd2000 *bcd2k = substream->rmidi->private_data;\r\nbcd2k->midi_receive_substream = up ? substream : NULL;\r\n}\r\nstatic void bcd2000_midi_handle_input(struct bcd2000 *bcd2k,\r\nconst unsigned char *buf, unsigned int buf_len)\r\n{\r\nunsigned int payload_length, tocopy;\r\nstruct snd_rawmidi_substream *midi_receive_substream;\r\nmidi_receive_substream = ACCESS_ONCE(bcd2k->midi_receive_substream);\r\nif (!midi_receive_substream)\r\nreturn;\r\nbcd2000_dump_buffer(PREFIX "received from device: ", buf, buf_len);\r\nif (buf_len < 2)\r\nreturn;\r\npayload_length = buf[0];\r\nif (payload_length == 0)\r\nreturn;\r\ntocopy = min(payload_length, buf_len-1);\r\nbcd2000_dump_buffer(PREFIX "sending to userspace: ",\r\n&buf[1], tocopy);\r\nsnd_rawmidi_receive(midi_receive_substream,\r\n&buf[1], tocopy);\r\n}\r\nstatic void bcd2000_midi_send(struct bcd2000 *bcd2k)\r\n{\r\nint len, ret;\r\nstruct snd_rawmidi_substream *midi_out_substream;\r\nBUILD_BUG_ON(sizeof(device_cmd_prefix) >= BUFSIZE);\r\nmidi_out_substream = ACCESS_ONCE(bcd2k->midi_out_substream);\r\nif (!midi_out_substream)\r\nreturn;\r\nmemcpy(bcd2k->midi_out_buf, device_cmd_prefix,\r\nsizeof(device_cmd_prefix));\r\nlen = snd_rawmidi_transmit(midi_out_substream,\r\nbcd2k->midi_out_buf + 3, BUFSIZE - 3);\r\nif (len < 0)\r\ndev_err(&bcd2k->dev->dev, "%s: snd_rawmidi_transmit error %d\n",\r\n__func__, len);\r\nif (len <= 0)\r\nreturn;\r\nbcd2k->midi_out_buf[2] = len;\r\nbcd2k->midi_out_urb->transfer_buffer_length = BUFSIZE;\r\nbcd2000_dump_buffer(PREFIX "sending to device: ",\r\nbcd2k->midi_out_buf, len+3);\r\nret = usb_submit_urb(bcd2k->midi_out_urb, GFP_ATOMIC);\r\nif (ret < 0)\r\ndev_err(&bcd2k->dev->dev, PREFIX\r\n"%s (%p): usb_submit_urb() failed, ret=%d, len=%d\n",\r\n__func__, midi_out_substream, ret, len);\r\nelse\r\nbcd2k->midi_out_active = 1;\r\n}\r\nstatic int bcd2000_midi_output_open(struct snd_rawmidi_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic int bcd2000_midi_output_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct bcd2000 *bcd2k = substream->rmidi->private_data;\r\nif (bcd2k->midi_out_active) {\r\nusb_kill_urb(bcd2k->midi_out_urb);\r\nbcd2k->midi_out_active = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bcd2000_midi_output_trigger(struct snd_rawmidi_substream *substream,\r\nint up)\r\n{\r\nstruct bcd2000 *bcd2k = substream->rmidi->private_data;\r\nif (up) {\r\nbcd2k->midi_out_substream = substream;\r\nif (!bcd2k->midi_out_active)\r\nbcd2000_midi_send(bcd2k);\r\n} else {\r\nbcd2k->midi_out_substream = NULL;\r\n}\r\n}\r\nstatic void bcd2000_output_complete(struct urb *urb)\r\n{\r\nstruct bcd2000 *bcd2k = urb->context;\r\nbcd2k->midi_out_active = 0;\r\nif (urb->status)\r\ndev_warn(&urb->dev->dev,\r\nPREFIX "output urb->status: %d\n", urb->status);\r\nif (urb->status == -ESHUTDOWN)\r\nreturn;\r\nbcd2000_midi_send(bcd2k);\r\n}\r\nstatic void bcd2000_input_complete(struct urb *urb)\r\n{\r\nint ret;\r\nstruct bcd2000 *bcd2k = urb->context;\r\nif (urb->status)\r\ndev_warn(&urb->dev->dev,\r\nPREFIX "input urb->status: %i\n", urb->status);\r\nif (!bcd2k || urb->status == -ESHUTDOWN)\r\nreturn;\r\nif (urb->actual_length > 0)\r\nbcd2000_midi_handle_input(bcd2k, urb->transfer_buffer,\r\nurb->actual_length);\r\nret = usb_submit_urb(bcd2k->midi_in_urb, GFP_ATOMIC);\r\nif (ret < 0)\r\ndev_err(&bcd2k->dev->dev, PREFIX\r\n"%s: usb_submit_urb() failed, ret=%d\n",\r\n__func__, ret);\r\n}\r\nstatic void bcd2000_init_device(struct bcd2000 *bcd2k)\r\n{\r\nint ret;\r\ninit_usb_anchor(&bcd2k->anchor);\r\nusb_anchor_urb(bcd2k->midi_out_urb, &bcd2k->anchor);\r\nusb_anchor_urb(bcd2k->midi_in_urb, &bcd2k->anchor);\r\nmemcpy(bcd2k->midi_out_buf, bcd2000_init_sequence, 52);\r\nbcd2k->midi_out_urb->transfer_buffer_length = 52;\r\nret = usb_submit_urb(bcd2k->midi_out_urb, GFP_KERNEL);\r\nif (ret < 0)\r\ndev_err(&bcd2k->dev->dev, PREFIX\r\n"%s: usb_submit_urb() out failed, ret=%d: ",\r\n__func__, ret);\r\nelse\r\nbcd2k->midi_out_active = 1;\r\nret = usb_submit_urb(bcd2k->midi_in_urb, GFP_KERNEL);\r\nif (ret < 0)\r\ndev_err(&bcd2k->dev->dev, PREFIX\r\n"%s: usb_submit_urb() in failed, ret=%d: ",\r\n__func__, ret);\r\nusb_wait_anchor_empty_timeout(&bcd2k->anchor, 1000);\r\n}\r\nstatic int bcd2000_init_midi(struct bcd2000 *bcd2k)\r\n{\r\nint ret;\r\nstruct snd_rawmidi *rmidi;\r\nret = snd_rawmidi_new(bcd2k->card, bcd2k->card->shortname, 0,\r\n1,\r\n1,\r\n&rmidi);\r\nif (ret < 0)\r\nreturn ret;\r\nstrlcpy(rmidi->name, bcd2k->card->shortname, sizeof(rmidi->name));\r\nrmidi->info_flags = SNDRV_RAWMIDI_INFO_DUPLEX;\r\nrmidi->private_data = bcd2k;\r\nrmidi->info_flags |= SNDRV_RAWMIDI_INFO_OUTPUT;\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT,\r\n&bcd2000_midi_output);\r\nrmidi->info_flags |= SNDRV_RAWMIDI_INFO_INPUT;\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT,\r\n&bcd2000_midi_input);\r\nbcd2k->rmidi = rmidi;\r\nbcd2k->midi_in_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nbcd2k->midi_out_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!bcd2k->midi_in_urb || !bcd2k->midi_out_urb) {\r\ndev_err(&bcd2k->dev->dev, PREFIX "usb_alloc_urb failed\n");\r\nreturn -ENOMEM;\r\n}\r\nusb_fill_int_urb(bcd2k->midi_in_urb, bcd2k->dev,\r\nusb_rcvintpipe(bcd2k->dev, 0x81),\r\nbcd2k->midi_in_buf, BUFSIZE,\r\nbcd2000_input_complete, bcd2k, 1);\r\nusb_fill_int_urb(bcd2k->midi_out_urb, bcd2k->dev,\r\nusb_sndintpipe(bcd2k->dev, 0x1),\r\nbcd2k->midi_out_buf, BUFSIZE,\r\nbcd2000_output_complete, bcd2k, 1);\r\nbcd2000_init_device(bcd2k);\r\nreturn 0;\r\n}\r\nstatic void bcd2000_free_usb_related_resources(struct bcd2000 *bcd2k,\r\nstruct usb_interface *interface)\r\n{\r\nusb_free_urb(bcd2k->midi_out_urb);\r\nusb_free_urb(bcd2k->midi_in_urb);\r\nif (bcd2k->intf) {\r\nusb_set_intfdata(bcd2k->intf, NULL);\r\nbcd2k->intf = NULL;\r\n}\r\n}\r\nstatic int bcd2000_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *usb_id)\r\n{\r\nstruct snd_card *card;\r\nstruct bcd2000 *bcd2k;\r\nunsigned int card_index;\r\nchar usb_path[32];\r\nint err;\r\nmutex_lock(&devices_mutex);\r\nfor (card_index = 0; card_index < SNDRV_CARDS; ++card_index)\r\nif (!test_bit(card_index, devices_used))\r\nbreak;\r\nif (card_index >= SNDRV_CARDS) {\r\nmutex_unlock(&devices_mutex);\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_new(&interface->dev, index[card_index], id[card_index],\r\nTHIS_MODULE, sizeof(*bcd2k), &card);\r\nif (err < 0) {\r\nmutex_unlock(&devices_mutex);\r\nreturn err;\r\n}\r\nbcd2k = card->private_data;\r\nbcd2k->dev = interface_to_usbdev(interface);\r\nbcd2k->card = card;\r\nbcd2k->card_index = card_index;\r\nbcd2k->intf = interface;\r\nsnd_card_set_dev(card, &interface->dev);\r\nstrncpy(card->driver, "snd-bcd2000", sizeof(card->driver));\r\nstrncpy(card->shortname, "BCD2000", sizeof(card->shortname));\r\nusb_make_path(bcd2k->dev, usb_path, sizeof(usb_path));\r\nsnprintf(bcd2k->card->longname, sizeof(bcd2k->card->longname),\r\n"Behringer BCD2000 at %s",\r\nusb_path);\r\nerr = bcd2000_init_midi(bcd2k);\r\nif (err < 0)\r\ngoto probe_error;\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto probe_error;\r\nusb_set_intfdata(interface, bcd2k);\r\nset_bit(card_index, devices_used);\r\nmutex_unlock(&devices_mutex);\r\nreturn 0;\r\nprobe_error:\r\ndev_info(&bcd2k->dev->dev, PREFIX "error during probing");\r\nbcd2000_free_usb_related_resources(bcd2k, interface);\r\nsnd_card_free(card);\r\nmutex_unlock(&devices_mutex);\r\nreturn err;\r\n}\r\nstatic void bcd2000_disconnect(struct usb_interface *interface)\r\n{\r\nstruct bcd2000 *bcd2k = usb_get_intfdata(interface);\r\nif (!bcd2k)\r\nreturn;\r\nmutex_lock(&devices_mutex);\r\nsnd_card_disconnect(bcd2k->card);\r\nbcd2000_free_usb_related_resources(bcd2k, interface);\r\nclear_bit(bcd2k->card_index, devices_used);\r\nsnd_card_free_when_closed(bcd2k->card);\r\nmutex_unlock(&devices_mutex);\r\n}
