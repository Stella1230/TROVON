static int sunxi_restart_handle(struct notifier_block *this, unsigned long mode,\r\nvoid *cmd)\r\n{\r\nstruct sunxi_wdt_dev *sunxi_wdt = container_of(this,\r\nstruct sunxi_wdt_dev,\r\nrestart_handler);\r\nvoid __iomem *wdt_base = sunxi_wdt->wdt_base;\r\nconst struct sunxi_wdt_reg *regs = sunxi_wdt->wdt_regs;\r\nu32 val;\r\nval = readl(wdt_base + regs->wdt_cfg);\r\nval &= ~(regs->wdt_reset_mask);\r\nval |= regs->wdt_reset_val;\r\nwritel(val, wdt_base + regs->wdt_cfg);\r\nval = readl(wdt_base + regs->wdt_mode);\r\nval &= ~(WDT_TIMEOUT_MASK << regs->wdt_timeout_shift);\r\nval |= WDT_MODE_EN;\r\nwritel(val, wdt_base + regs->wdt_mode);\r\nwritel(WDT_CTRL_RELOAD, wdt_base + regs->wdt_ctrl);\r\nwhile (1) {\r\nmdelay(5);\r\nval = readl(wdt_base + regs->wdt_mode);\r\nval |= WDT_MODE_EN;\r\nwritel(val, wdt_base + regs->wdt_mode);\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int sunxi_wdt_ping(struct watchdog_device *wdt_dev)\r\n{\r\nstruct sunxi_wdt_dev *sunxi_wdt = watchdog_get_drvdata(wdt_dev);\r\nvoid __iomem *wdt_base = sunxi_wdt->wdt_base;\r\nconst struct sunxi_wdt_reg *regs = sunxi_wdt->wdt_regs;\r\nwritel(WDT_CTRL_RELOAD, wdt_base + regs->wdt_ctrl);\r\nreturn 0;\r\n}\r\nstatic int sunxi_wdt_set_timeout(struct watchdog_device *wdt_dev,\r\nunsigned int timeout)\r\n{\r\nstruct sunxi_wdt_dev *sunxi_wdt = watchdog_get_drvdata(wdt_dev);\r\nvoid __iomem *wdt_base = sunxi_wdt->wdt_base;\r\nconst struct sunxi_wdt_reg *regs = sunxi_wdt->wdt_regs;\r\nu32 reg;\r\nif (wdt_timeout_map[timeout] == 0)\r\ntimeout++;\r\nsunxi_wdt->wdt_dev.timeout = timeout;\r\nreg = readl(wdt_base + regs->wdt_mode);\r\nreg &= ~(WDT_TIMEOUT_MASK << regs->wdt_timeout_shift);\r\nreg |= wdt_timeout_map[timeout] << regs->wdt_timeout_shift;\r\nwritel(reg, wdt_base + regs->wdt_mode);\r\nsunxi_wdt_ping(wdt_dev);\r\nreturn 0;\r\n}\r\nstatic int sunxi_wdt_stop(struct watchdog_device *wdt_dev)\r\n{\r\nstruct sunxi_wdt_dev *sunxi_wdt = watchdog_get_drvdata(wdt_dev);\r\nvoid __iomem *wdt_base = sunxi_wdt->wdt_base;\r\nconst struct sunxi_wdt_reg *regs = sunxi_wdt->wdt_regs;\r\nwritel(0, wdt_base + regs->wdt_mode);\r\nreturn 0;\r\n}\r\nstatic int sunxi_wdt_start(struct watchdog_device *wdt_dev)\r\n{\r\nu32 reg;\r\nstruct sunxi_wdt_dev *sunxi_wdt = watchdog_get_drvdata(wdt_dev);\r\nvoid __iomem *wdt_base = sunxi_wdt->wdt_base;\r\nconst struct sunxi_wdt_reg *regs = sunxi_wdt->wdt_regs;\r\nint ret;\r\nret = sunxi_wdt_set_timeout(&sunxi_wdt->wdt_dev,\r\nsunxi_wdt->wdt_dev.timeout);\r\nif (ret < 0)\r\nreturn ret;\r\nreg = readl(wdt_base + regs->wdt_cfg);\r\nreg &= ~(regs->wdt_reset_mask);\r\nreg |= ~(regs->wdt_reset_val);\r\nwritel(reg, wdt_base + regs->wdt_cfg);\r\nreg = readl(wdt_base + regs->wdt_mode);\r\nreg |= WDT_MODE_EN;\r\nwritel(reg, wdt_base + regs->wdt_mode);\r\nreturn 0;\r\n}\r\nstatic int sunxi_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct sunxi_wdt_dev *sunxi_wdt;\r\nconst struct of_device_id *device;\r\nstruct resource *res;\r\nint err;\r\nsunxi_wdt = devm_kzalloc(&pdev->dev, sizeof(*sunxi_wdt), GFP_KERNEL);\r\nif (!sunxi_wdt)\r\nreturn -EINVAL;\r\nplatform_set_drvdata(pdev, sunxi_wdt);\r\ndevice = of_match_device(sunxi_wdt_dt_ids, &pdev->dev);\r\nif (!device)\r\nreturn -ENODEV;\r\nsunxi_wdt->wdt_regs = device->data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nsunxi_wdt->wdt_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(sunxi_wdt->wdt_base))\r\nreturn PTR_ERR(sunxi_wdt->wdt_base);\r\nsunxi_wdt->wdt_dev.info = &sunxi_wdt_info;\r\nsunxi_wdt->wdt_dev.ops = &sunxi_wdt_ops;\r\nsunxi_wdt->wdt_dev.timeout = WDT_MAX_TIMEOUT;\r\nsunxi_wdt->wdt_dev.max_timeout = WDT_MAX_TIMEOUT;\r\nsunxi_wdt->wdt_dev.min_timeout = WDT_MIN_TIMEOUT;\r\nsunxi_wdt->wdt_dev.parent = &pdev->dev;\r\nwatchdog_init_timeout(&sunxi_wdt->wdt_dev, timeout, &pdev->dev);\r\nwatchdog_set_nowayout(&sunxi_wdt->wdt_dev, nowayout);\r\nwatchdog_set_drvdata(&sunxi_wdt->wdt_dev, sunxi_wdt);\r\nsunxi_wdt_stop(&sunxi_wdt->wdt_dev);\r\nerr = watchdog_register_device(&sunxi_wdt->wdt_dev);\r\nif (unlikely(err))\r\nreturn err;\r\nsunxi_wdt->restart_handler.notifier_call = sunxi_restart_handle;\r\nsunxi_wdt->restart_handler.priority = 128;\r\nerr = register_restart_handler(&sunxi_wdt->restart_handler);\r\nif (err)\r\ndev_err(&pdev->dev,\r\n"cannot register restart handler (err=%d)\n", err);\r\ndev_info(&pdev->dev, "Watchdog enabled (timeout=%d sec, nowayout=%d)",\r\nsunxi_wdt->wdt_dev.timeout, nowayout);\r\nreturn 0;\r\n}\r\nstatic int sunxi_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct sunxi_wdt_dev *sunxi_wdt = platform_get_drvdata(pdev);\r\nunregister_restart_handler(&sunxi_wdt->restart_handler);\r\nwatchdog_unregister_device(&sunxi_wdt->wdt_dev);\r\nwatchdog_set_drvdata(&sunxi_wdt->wdt_dev, NULL);\r\nreturn 0;\r\n}\r\nstatic void sunxi_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nstruct sunxi_wdt_dev *sunxi_wdt = platform_get_drvdata(pdev);\r\nsunxi_wdt_stop(&sunxi_wdt->wdt_dev);\r\n}
