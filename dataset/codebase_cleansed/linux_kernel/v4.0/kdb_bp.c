static void kdb_setsinglestep(struct pt_regs *regs)\r\n{\r\nKDB_STATE_SET(DOING_SS);\r\n}\r\nstatic char *kdb_bptype(kdb_bp_t *bp)\r\n{\r\nif (bp->bp_type < 0 || bp->bp_type > 4)\r\nreturn "";\r\nreturn kdb_rwtypes[bp->bp_type];\r\n}\r\nstatic int kdb_parsebp(int argc, const char **argv, int *nextargp, kdb_bp_t *bp)\r\n{\r\nint nextarg = *nextargp;\r\nint diag;\r\nbp->bph_length = 1;\r\nif ((argc + 1) != nextarg) {\r\nif (strncasecmp(argv[nextarg], "datar", sizeof("datar")) == 0)\r\nbp->bp_type = BP_ACCESS_WATCHPOINT;\r\nelse if (strncasecmp(argv[nextarg], "dataw", sizeof("dataw")) == 0)\r\nbp->bp_type = BP_WRITE_WATCHPOINT;\r\nelse if (strncasecmp(argv[nextarg], "inst", sizeof("inst")) == 0)\r\nbp->bp_type = BP_HARDWARE_BREAKPOINT;\r\nelse\r\nreturn KDB_ARGCOUNT;\r\nbp->bph_length = 1;\r\nnextarg++;\r\nif ((argc + 1) != nextarg) {\r\nunsigned long len;\r\ndiag = kdbgetularg((char *)argv[nextarg],\r\n&len);\r\nif (diag)\r\nreturn diag;\r\nif (len > 8)\r\nreturn KDB_BADLENGTH;\r\nbp->bph_length = len;\r\nnextarg++;\r\n}\r\nif ((argc + 1) != nextarg)\r\nreturn KDB_ARGCOUNT;\r\n}\r\n*nextargp = nextarg;\r\nreturn 0;\r\n}\r\nstatic int _kdb_bp_remove(kdb_bp_t *bp)\r\n{\r\nint ret = 1;\r\nif (!bp->bp_installed)\r\nreturn ret;\r\nif (!bp->bp_type)\r\nret = dbg_remove_sw_break(bp->bp_addr);\r\nelse\r\nret = arch_kgdb_ops.remove_hw_breakpoint(bp->bp_addr,\r\nbp->bph_length,\r\nbp->bp_type);\r\nif (ret == 0)\r\nbp->bp_installed = 0;\r\nreturn ret;\r\n}\r\nstatic void kdb_handle_bp(struct pt_regs *regs, kdb_bp_t *bp)\r\n{\r\nif (KDB_DEBUG(BP))\r\nkdb_printf("regs->ip = 0x%lx\n", instruction_pointer(regs));\r\nkdb_setsinglestep(regs);\r\nbp->bp_delay = 0;\r\nbp->bp_delayed = 1;\r\n}\r\nstatic int _kdb_bp_install(struct pt_regs *regs, kdb_bp_t *bp)\r\n{\r\nint ret;\r\nif (KDB_DEBUG(BP))\r\nkdb_printf("%s: bp_installed %d\n",\r\n__func__, bp->bp_installed);\r\nif (!KDB_STATE(SSBPT))\r\nbp->bp_delay = 0;\r\nif (bp->bp_installed)\r\nreturn 1;\r\nif (bp->bp_delay || (bp->bp_delayed && KDB_STATE(DOING_SS))) {\r\nif (KDB_DEBUG(BP))\r\nkdb_printf("%s: delayed bp\n", __func__);\r\nkdb_handle_bp(regs, bp);\r\nreturn 0;\r\n}\r\nif (!bp->bp_type)\r\nret = dbg_set_sw_break(bp->bp_addr);\r\nelse\r\nret = arch_kgdb_ops.set_hw_breakpoint(bp->bp_addr,\r\nbp->bph_length,\r\nbp->bp_type);\r\nif (ret == 0) {\r\nbp->bp_installed = 1;\r\n} else {\r\nkdb_printf("%s: failed to set breakpoint at 0x%lx\n",\r\n__func__, bp->bp_addr);\r\n#ifdef CONFIG_DEBUG_RODATA\r\nif (!bp->bp_type) {\r\nkdb_printf("Software breakpoints are unavailable.\n"\r\n" Change the kernel CONFIG_DEBUG_RODATA=n\n"\r\n" OR use hw breaks: help bph\n");\r\n}\r\n#endif\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid kdb_bp_install(struct pt_regs *regs)\r\n{\r\nint i;\r\nfor (i = 0; i < KDB_MAXBPT; i++) {\r\nkdb_bp_t *bp = &kdb_breakpoints[i];\r\nif (KDB_DEBUG(BP)) {\r\nkdb_printf("%s: bp %d bp_enabled %d\n",\r\n__func__, i, bp->bp_enabled);\r\n}\r\nif (bp->bp_enabled)\r\n_kdb_bp_install(regs, bp);\r\n}\r\n}\r\nvoid kdb_bp_remove(void)\r\n{\r\nint i;\r\nfor (i = KDB_MAXBPT - 1; i >= 0; i--) {\r\nkdb_bp_t *bp = &kdb_breakpoints[i];\r\nif (KDB_DEBUG(BP)) {\r\nkdb_printf("%s: bp %d bp_enabled %d\n",\r\n__func__, i, bp->bp_enabled);\r\n}\r\nif (bp->bp_enabled)\r\n_kdb_bp_remove(bp);\r\n}\r\n}\r\nstatic void kdb_printbp(kdb_bp_t *bp, int i)\r\n{\r\nkdb_printf("%s ", kdb_bptype(bp));\r\nkdb_printf("BP #%d at ", i);\r\nkdb_symbol_print(bp->bp_addr, NULL, KDB_SP_DEFAULT);\r\nif (bp->bp_enabled)\r\nkdb_printf("\n is enabled");\r\nelse\r\nkdb_printf("\n is disabled");\r\nkdb_printf("\taddr at %016lx, hardtype=%d installed=%d\n",\r\nbp->bp_addr, bp->bp_type, bp->bp_installed);\r\nkdb_printf("\n");\r\n}\r\nstatic int kdb_bp(int argc, const char **argv)\r\n{\r\nint i, bpno;\r\nkdb_bp_t *bp, *bp_check;\r\nint diag;\r\nchar *symname = NULL;\r\nlong offset = 0ul;\r\nint nextarg;\r\nkdb_bp_t template = {0};\r\nif (argc == 0) {\r\nfor (bpno = 0, bp = kdb_breakpoints; bpno < KDB_MAXBPT;\r\nbpno++, bp++) {\r\nif (bp->bp_free)\r\ncontinue;\r\nkdb_printbp(bp, bpno);\r\n}\r\nreturn 0;\r\n}\r\nnextarg = 1;\r\ndiag = kdbgetaddrarg(argc, argv, &nextarg, &template.bp_addr,\r\n&offset, &symname);\r\nif (diag)\r\nreturn diag;\r\nif (!template.bp_addr)\r\nreturn KDB_BADINT;\r\nfor (bpno = 0, bp = kdb_breakpoints; bpno < KDB_MAXBPT; bpno++, bp++) {\r\nif (bp->bp_free)\r\nbreak;\r\n}\r\nif (bpno == KDB_MAXBPT)\r\nreturn KDB_TOOMANYBPT;\r\nif (strcmp(argv[0], "bph") == 0) {\r\ntemplate.bp_type = BP_HARDWARE_BREAKPOINT;\r\ndiag = kdb_parsebp(argc, argv, &nextarg, &template);\r\nif (diag)\r\nreturn diag;\r\n} else {\r\ntemplate.bp_type = BP_BREAKPOINT;\r\n}\r\nfor (i = 0, bp_check = kdb_breakpoints; i < KDB_MAXBPT;\r\ni++, bp_check++) {\r\nif (!bp_check->bp_free &&\r\nbp_check->bp_addr == template.bp_addr) {\r\nkdb_printf("You already have a breakpoint at "\r\nkdb_bfd_vma_fmt0 "\n", template.bp_addr);\r\nreturn KDB_DUPBPT;\r\n}\r\n}\r\ntemplate.bp_enabled = 1;\r\n*bp = template;\r\nbp->bp_free = 0;\r\nkdb_printbp(bp, bpno);\r\nreturn 0;\r\n}\r\nstatic int kdb_bc(int argc, const char **argv)\r\n{\r\nunsigned long addr;\r\nkdb_bp_t *bp = NULL;\r\nint lowbp = KDB_MAXBPT;\r\nint highbp = 0;\r\nint done = 0;\r\nint i;\r\nint diag = 0;\r\nint cmd;\r\n#define KDBCMD_BC 0\r\n#define KDBCMD_BE 1\r\n#define KDBCMD_BD 2\r\nif (strcmp(argv[0], "be") == 0)\r\ncmd = KDBCMD_BE;\r\nelse if (strcmp(argv[0], "bd") == 0)\r\ncmd = KDBCMD_BD;\r\nelse\r\ncmd = KDBCMD_BC;\r\nif (argc != 1)\r\nreturn KDB_ARGCOUNT;\r\nif (strcmp(argv[1], "*") == 0) {\r\nlowbp = 0;\r\nhighbp = KDB_MAXBPT;\r\n} else {\r\ndiag = kdbgetularg(argv[1], &addr);\r\nif (diag)\r\nreturn diag;\r\nif (addr < KDB_MAXBPT) {\r\nbp = &kdb_breakpoints[addr];\r\nlowbp = highbp = addr;\r\nhighbp++;\r\n} else {\r\nfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT;\r\ni++, bp++) {\r\nif (bp->bp_addr == addr) {\r\nlowbp = highbp = i;\r\nhighbp++;\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nfor (bp = &kdb_breakpoints[lowbp], i = lowbp;\r\ni < highbp;\r\ni++, bp++) {\r\nif (bp->bp_free)\r\ncontinue;\r\ndone++;\r\nswitch (cmd) {\r\ncase KDBCMD_BC:\r\nbp->bp_enabled = 0;\r\nkdb_printf("Breakpoint %d at "\r\nkdb_bfd_vma_fmt " cleared\n",\r\ni, bp->bp_addr);\r\nbp->bp_addr = 0;\r\nbp->bp_free = 1;\r\nbreak;\r\ncase KDBCMD_BE:\r\nbp->bp_enabled = 1;\r\nkdb_printf("Breakpoint %d at "\r\nkdb_bfd_vma_fmt " enabled",\r\ni, bp->bp_addr);\r\nkdb_printf("\n");\r\nbreak;\r\ncase KDBCMD_BD:\r\nif (!bp->bp_enabled)\r\nbreak;\r\nbp->bp_enabled = 0;\r\nkdb_printf("Breakpoint %d at "\r\nkdb_bfd_vma_fmt " disabled\n",\r\ni, bp->bp_addr);\r\nbreak;\r\n}\r\nif (bp->bp_delay && (cmd == KDBCMD_BC || cmd == KDBCMD_BD)) {\r\nbp->bp_delay = 0;\r\nKDB_STATE_CLEAR(SSBPT);\r\n}\r\n}\r\nreturn (!done) ? KDB_BPTNOTFOUND : 0;\r\n}\r\nstatic int kdb_ss(int argc, const char **argv)\r\n{\r\nif (argc != 0)\r\nreturn KDB_ARGCOUNT;\r\nKDB_STATE_SET(DOING_SS);\r\nreturn KDB_CMD_SS;\r\n}\r\nvoid __init kdb_initbptab(void)\r\n{\r\nint i;\r\nkdb_bp_t *bp;\r\nmemset(&kdb_breakpoints, '\0', sizeof(kdb_breakpoints));\r\nfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT; i++, bp++)\r\nbp->bp_free = 1;\r\nkdb_register_flags("bp", kdb_bp, "[<vaddr>]",\r\n"Set/Display breakpoints", 0,\r\nKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\r\nkdb_register_flags("bl", kdb_bp, "[<vaddr>]",\r\n"Display breakpoints", 0,\r\nKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\r\nif (arch_kgdb_ops.flags & KGDB_HW_BREAKPOINT)\r\nkdb_register_flags("bph", kdb_bp, "[<vaddr>]",\r\n"[datar [length]|dataw [length]] Set hw brk", 0,\r\nKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\r\nkdb_register_flags("bc", kdb_bc, "<bpnum>",\r\n"Clear Breakpoint", 0,\r\nKDB_ENABLE_FLOW_CTRL);\r\nkdb_register_flags("be", kdb_bc, "<bpnum>",\r\n"Enable Breakpoint", 0,\r\nKDB_ENABLE_FLOW_CTRL);\r\nkdb_register_flags("bd", kdb_bc, "<bpnum>",\r\n"Disable Breakpoint", 0,\r\nKDB_ENABLE_FLOW_CTRL);\r\nkdb_register_flags("ss", kdb_ss, "",\r\n"Single Step", 1,\r\nKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\r\n}
