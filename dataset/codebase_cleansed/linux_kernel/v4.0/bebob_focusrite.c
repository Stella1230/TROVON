static inline int\r\nsaffire_read_block(struct snd_bebob *bebob, u64 offset,\r\nu32 *buf, unsigned int size)\r\n{\r\nunsigned int i;\r\nint err;\r\n__be32 *tmp = (__be32 *)buf;\r\nerr = snd_fw_transaction(bebob->unit, TCODE_READ_BLOCK_REQUEST,\r\nSAFFIRE_ADDRESS_BASE + offset,\r\ntmp, size, 0);\r\nif (err < 0)\r\ngoto end;\r\nfor (i = 0; i < size / sizeof(u32); i++)\r\nbuf[i] = be32_to_cpu(tmp[i]);\r\nend:\r\nreturn err;\r\n}\r\nstatic inline int\r\nsaffire_read_quad(struct snd_bebob *bebob, u64 offset, u32 *value)\r\n{\r\nint err;\r\n__be32 tmp;\r\nerr = snd_fw_transaction(bebob->unit, TCODE_READ_QUADLET_REQUEST,\r\nSAFFIRE_ADDRESS_BASE + offset,\r\n&tmp, sizeof(__be32), 0);\r\nif (err < 0)\r\ngoto end;\r\n*value = be32_to_cpu(tmp);\r\nend:\r\nreturn err;\r\n}\r\nstatic inline int\r\nsaffire_write_quad(struct snd_bebob *bebob, u64 offset, u32 value)\r\n{\r\n__be32 data = cpu_to_be32(value);\r\nreturn snd_fw_transaction(bebob->unit, TCODE_WRITE_QUADLET_REQUEST,\r\nSAFFIRE_ADDRESS_BASE + offset,\r\n&data, sizeof(__be32), 0);\r\n}\r\nstatic int\r\nsaffirepro_both_clk_freq_get(struct snd_bebob *bebob, unsigned int *rate)\r\n{\r\nu32 id;\r\nint err;\r\nerr = saffire_read_quad(bebob, SAFFIREPRO_RATE_NOREBOOT, &id);\r\nif (err < 0)\r\ngoto end;\r\nif (id >= ARRAY_SIZE(rates))\r\nerr = -EIO;\r\nelse\r\n*rate = rates[id];\r\nend:\r\nreturn err;\r\n}\r\nstatic int\r\nsaffirepro_both_clk_freq_set(struct snd_bebob *bebob, unsigned int rate)\r\n{\r\nu32 id;\r\nfor (id = 0; id < ARRAY_SIZE(rates); id++) {\r\nif (rates[id] == rate)\r\nbreak;\r\n}\r\nif (id == ARRAY_SIZE(rates))\r\nreturn -EINVAL;\r\nreturn saffire_write_quad(bebob, SAFFIREPRO_RATE_NOREBOOT, id);\r\n}\r\nstatic int\r\nsaffirepro_both_clk_src_get(struct snd_bebob *bebob, unsigned int *id)\r\n{\r\nint err;\r\nu32 value;\r\nconst signed char *map;\r\nerr = saffire_read_quad(bebob, SAFFIREPRO_OFFSET_CLOCK_SOURCE, &value);\r\nif (err < 0)\r\ngoto end;\r\nif (bebob->spec->clock->labels == saffirepro_10_clk_src_labels)\r\nmap = saffirepro_clk_maps[0];\r\nelse\r\nmap = saffirepro_clk_maps[1];\r\nif (value >= SAFFIREPRO_CLOCK_SOURCE_COUNT || map[value] < 0) {\r\nerr = -EIO;\r\ngoto end;\r\n}\r\n*id = (unsigned int)map[value];\r\nend:\r\nreturn err;\r\n}\r\nstatic int\r\nsaffire_both_clk_src_get(struct snd_bebob *bebob, unsigned int *id)\r\n{\r\nint err;\r\nu32 value;\r\nerr = saffire_read_quad(bebob, SAFFIRE_OFFSET_CLOCK_SOURCE, &value);\r\nif (err >= 0)\r\n*id = 0xff & value;\r\nreturn err;\r\n}\r\nstatic int\r\nsaffire_meter_get(struct snd_bebob *bebob, u32 *buf, unsigned int size)\r\n{\r\nstruct snd_bebob_meter_spec *spec = bebob->spec->meter;\r\nunsigned int channels;\r\nu64 offset;\r\nint err;\r\nif (spec->labels == saffire_le_meter_labels)\r\noffset = SAFFIRE_LE_OFFSET_METER;\r\nelse\r\noffset = SAFFIRE_OFFSET_METER;\r\nchannels = spec->num * 2;\r\nif (size < channels * sizeof(u32))\r\nreturn -EIO;\r\nerr = saffire_read_block(bebob, offset, buf, size);\r\nif (err >= 0 && spec->labels == saffire_le_meter_labels) {\r\nswap(buf[1], buf[3]);\r\nswap(buf[2], buf[3]);\r\nswap(buf[3], buf[4]);\r\nswap(buf[7], buf[10]);\r\nswap(buf[8], buf[10]);\r\nswap(buf[9], buf[11]);\r\nswap(buf[11], buf[12]);\r\nswap(buf[15], buf[16]);\r\n}\r\nreturn err;\r\n}
