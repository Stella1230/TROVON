u16 fm10k_read_pci_cfg_word(struct fm10k_hw *hw, u32 reg)\r\n{\r\nstruct fm10k_intfc *interface = hw->back;\r\nu16 value = 0;\r\nif (FM10K_REMOVED(hw->hw_addr))\r\nreturn ~value;\r\npci_read_config_word(interface->pdev, reg, &value);\r\nif (value == 0xFFFF)\r\nfm10k_write_flush(hw);\r\nreturn value;\r\n}\r\nu32 fm10k_read_reg(struct fm10k_hw *hw, int reg)\r\n{\r\nu32 __iomem *hw_addr = ACCESS_ONCE(hw->hw_addr);\r\nu32 value = 0;\r\nif (FM10K_REMOVED(hw_addr))\r\nreturn ~value;\r\nvalue = readl(&hw_addr[reg]);\r\nif (!(~value) && (!reg || !(~readl(hw_addr)))) {\r\nstruct fm10k_intfc *interface = hw->back;\r\nstruct net_device *netdev = interface->netdev;\r\nhw->hw_addr = NULL;\r\nnetif_device_detach(netdev);\r\nnetdev_err(netdev, "PCIe link lost, device now detached\n");\r\n}\r\nreturn value;\r\n}\r\nstatic int fm10k_hw_ready(struct fm10k_intfc *interface)\r\n{\r\nstruct fm10k_hw *hw = &interface->hw;\r\nfm10k_write_flush(hw);\r\nreturn FM10K_REMOVED(hw->hw_addr) ? -ENODEV : 0;\r\n}\r\nvoid fm10k_service_event_schedule(struct fm10k_intfc *interface)\r\n{\r\nif (!test_bit(__FM10K_SERVICE_DISABLE, &interface->state) &&\r\n!test_and_set_bit(__FM10K_SERVICE_SCHED, &interface->state))\r\nschedule_work(&interface->service_task);\r\n}\r\nstatic void fm10k_service_event_complete(struct fm10k_intfc *interface)\r\n{\r\nBUG_ON(!test_bit(__FM10K_SERVICE_SCHED, &interface->state));\r\nsmp_mb__before_atomic();\r\nclear_bit(__FM10K_SERVICE_SCHED, &interface->state);\r\n}\r\nstatic void fm10k_service_timer(unsigned long data)\r\n{\r\nstruct fm10k_intfc *interface = (struct fm10k_intfc *)data;\r\nmod_timer(&interface->service_timer, (HZ * 2) + jiffies);\r\nfm10k_service_event_schedule(interface);\r\n}\r\nstatic void fm10k_detach_subtask(struct fm10k_intfc *interface)\r\n{\r\nstruct net_device *netdev = interface->netdev;\r\nif (netif_device_present(netdev) || interface->hw.hw_addr)\r\nreturn;\r\nrtnl_lock();\r\nif (netif_running(netdev))\r\ndev_close(netdev);\r\nrtnl_unlock();\r\n}\r\nstatic void fm10k_reinit(struct fm10k_intfc *interface)\r\n{\r\nstruct net_device *netdev = interface->netdev;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nint err;\r\nWARN_ON(in_interrupt());\r\nnetdev->trans_start = jiffies;\r\nwhile (test_and_set_bit(__FM10K_RESETTING, &interface->state))\r\nusleep_range(1000, 2000);\r\nrtnl_lock();\r\nfm10k_iov_suspend(interface->pdev);\r\nif (netif_running(netdev))\r\nfm10k_close(netdev);\r\nfm10k_mbx_free_irq(interface);\r\ninterface->last_reset = jiffies + (10 * HZ);\r\nerr = hw->mac.ops.reset_hw(hw) ? : hw->mac.ops.init_hw(hw);\r\nif (err)\r\ndev_err(&interface->pdev->dev, "init_hw failed: %d\n", err);\r\nfm10k_mbx_request_irq(interface);\r\nfm10k_ts_reset(interface);\r\nif (netif_running(netdev))\r\nfm10k_open(netdev);\r\nfm10k_iov_resume(interface->pdev);\r\nrtnl_unlock();\r\nclear_bit(__FM10K_RESETTING, &interface->state);\r\n}\r\nstatic void fm10k_reset_subtask(struct fm10k_intfc *interface)\r\n{\r\nif (!(interface->flags & FM10K_FLAG_RESET_REQUESTED))\r\nreturn;\r\ninterface->flags &= ~FM10K_FLAG_RESET_REQUESTED;\r\nnetdev_err(interface->netdev, "Reset interface\n");\r\ninterface->tx_timeout_count++;\r\nfm10k_reinit(interface);\r\n}\r\nstatic void fm10k_configure_swpri_map(struct fm10k_intfc *interface)\r\n{\r\nstruct net_device *netdev = interface->netdev;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nint i;\r\ninterface->flags &= ~FM10K_FLAG_SWPRI_CONFIG;\r\nif (hw->mac.type != fm10k_mac_pf)\r\nreturn;\r\nfor (i = 0; i < FM10K_SWPRI_MAX; i++)\r\nfm10k_write_reg(hw, FM10K_SWPRI_MAP(i),\r\nnetdev_get_prio_tc_map(netdev, i));\r\n}\r\nstatic void fm10k_watchdog_update_host_state(struct fm10k_intfc *interface)\r\n{\r\nstruct fm10k_hw *hw = &interface->hw;\r\ns32 err;\r\nif (test_bit(__FM10K_LINK_DOWN, &interface->state)) {\r\ninterface->host_ready = false;\r\nif (time_is_after_jiffies(interface->link_down_event))\r\nreturn;\r\nclear_bit(__FM10K_LINK_DOWN, &interface->state);\r\n}\r\nif (interface->flags & FM10K_FLAG_SWPRI_CONFIG) {\r\nif (rtnl_trylock()) {\r\nfm10k_configure_swpri_map(interface);\r\nrtnl_unlock();\r\n}\r\n}\r\nfm10k_mbx_lock(interface);\r\nerr = hw->mac.ops.get_host_state(hw, &interface->host_ready);\r\nif (err && time_is_before_jiffies(interface->last_reset))\r\ninterface->flags |= FM10K_FLAG_RESET_REQUESTED;\r\nfm10k_mbx_unlock(interface);\r\n}\r\nstatic void fm10k_mbx_subtask(struct fm10k_intfc *interface)\r\n{\r\nfm10k_watchdog_update_host_state(interface);\r\nfm10k_iov_mbx(interface);\r\n}\r\nstatic void fm10k_watchdog_host_is_ready(struct fm10k_intfc *interface)\r\n{\r\nstruct net_device *netdev = interface->netdev;\r\nif (netif_carrier_ok(netdev))\r\nreturn;\r\nnetif_info(interface, drv, netdev, "NIC Link is up\n");\r\nnetif_carrier_on(netdev);\r\nnetif_tx_wake_all_queues(netdev);\r\n}\r\nstatic void fm10k_watchdog_host_not_ready(struct fm10k_intfc *interface)\r\n{\r\nstruct net_device *netdev = interface->netdev;\r\nif (!netif_carrier_ok(netdev))\r\nreturn;\r\nnetif_info(interface, drv, netdev, "NIC Link is down\n");\r\nnetif_carrier_off(netdev);\r\nnetif_tx_stop_all_queues(netdev);\r\n}\r\nvoid fm10k_update_stats(struct fm10k_intfc *interface)\r\n{\r\nstruct net_device_stats *net_stats = &interface->netdev->stats;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nu64 rx_errors = 0, rx_csum_errors = 0, tx_csum_errors = 0;\r\nu64 restart_queue = 0, tx_busy = 0, alloc_failed = 0;\r\nu64 rx_bytes_nic = 0, rx_pkts_nic = 0, rx_drops_nic = 0;\r\nu64 tx_bytes_nic = 0, tx_pkts_nic = 0;\r\nu64 bytes, pkts;\r\nint i;\r\ninterface->next_stats_update = jiffies + HZ;\r\nfor (bytes = 0, pkts = 0, i = 0; i < interface->num_tx_queues; i++) {\r\nstruct fm10k_ring *tx_ring = interface->tx_ring[i];\r\nrestart_queue += tx_ring->tx_stats.restart_queue;\r\ntx_busy += tx_ring->tx_stats.tx_busy;\r\ntx_csum_errors += tx_ring->tx_stats.csum_err;\r\nbytes += tx_ring->stats.bytes;\r\npkts += tx_ring->stats.packets;\r\n}\r\ninterface->restart_queue = restart_queue;\r\ninterface->tx_busy = tx_busy;\r\nnet_stats->tx_bytes = bytes;\r\nnet_stats->tx_packets = pkts;\r\ninterface->tx_csum_errors = tx_csum_errors;\r\nfor (bytes = 0, pkts = 0, i = 0; i < interface->num_rx_queues; i++) {\r\nstruct fm10k_ring *rx_ring = interface->rx_ring[i];\r\nbytes += rx_ring->stats.bytes;\r\npkts += rx_ring->stats.packets;\r\nalloc_failed += rx_ring->rx_stats.alloc_failed;\r\nrx_csum_errors += rx_ring->rx_stats.csum_err;\r\nrx_errors += rx_ring->rx_stats.errors;\r\n}\r\nnet_stats->rx_bytes = bytes;\r\nnet_stats->rx_packets = pkts;\r\ninterface->alloc_failed = alloc_failed;\r\ninterface->rx_csum_errors = rx_csum_errors;\r\ninterface->rx_errors = rx_errors;\r\nhw->mac.ops.update_hw_stats(hw, &interface->stats);\r\nfor (i = 0; i < FM10K_MAX_QUEUES_PF; i++) {\r\nstruct fm10k_hw_stats_q *q = &interface->stats.q[i];\r\ntx_bytes_nic += q->tx_bytes.count;\r\ntx_pkts_nic += q->tx_packets.count;\r\nrx_bytes_nic += q->rx_bytes.count;\r\nrx_pkts_nic += q->rx_packets.count;\r\nrx_drops_nic += q->rx_drops.count;\r\n}\r\ninterface->tx_bytes_nic = tx_bytes_nic;\r\ninterface->tx_packets_nic = tx_pkts_nic;\r\ninterface->rx_bytes_nic = rx_bytes_nic;\r\ninterface->rx_packets_nic = rx_pkts_nic;\r\ninterface->rx_drops_nic = rx_drops_nic;\r\nnet_stats->rx_errors = interface->stats.xec.count;\r\nnet_stats->rx_dropped = interface->stats.nodesc_drop.count;\r\n}\r\nstatic void fm10k_watchdog_flush_tx(struct fm10k_intfc *interface)\r\n{\r\nint some_tx_pending = 0;\r\nint i;\r\nif (netif_carrier_ok(interface->netdev))\r\nreturn;\r\nfor (i = 0; i < interface->num_tx_queues; i++) {\r\nstruct fm10k_ring *tx_ring = interface->tx_ring[i];\r\nif (tx_ring->next_to_use != tx_ring->next_to_clean) {\r\nsome_tx_pending = 1;\r\nbreak;\r\n}\r\n}\r\nif (some_tx_pending)\r\ninterface->flags |= FM10K_FLAG_RESET_REQUESTED;\r\n}\r\nstatic void fm10k_watchdog_subtask(struct fm10k_intfc *interface)\r\n{\r\nif (test_bit(__FM10K_DOWN, &interface->state) ||\r\ntest_bit(__FM10K_RESETTING, &interface->state))\r\nreturn;\r\nif (interface->host_ready)\r\nfm10k_watchdog_host_is_ready(interface);\r\nelse\r\nfm10k_watchdog_host_not_ready(interface);\r\nif (time_is_before_jiffies(interface->next_stats_update))\r\nfm10k_update_stats(interface);\r\nfm10k_watchdog_flush_tx(interface);\r\n}\r\nstatic void fm10k_check_hang_subtask(struct fm10k_intfc *interface)\r\n{\r\nint i;\r\nif (test_bit(__FM10K_DOWN, &interface->state) ||\r\ntest_bit(__FM10K_RESETTING, &interface->state))\r\nreturn;\r\nif (time_is_after_eq_jiffies(interface->next_tx_hang_check))\r\nreturn;\r\ninterface->next_tx_hang_check = jiffies + (2 * HZ);\r\nif (netif_carrier_ok(interface->netdev)) {\r\nfor (i = 0; i < interface->num_tx_queues; i++)\r\nset_check_for_tx_hang(interface->tx_ring[i]);\r\nfor (i = 0; i < interface->num_q_vectors; i++) {\r\nstruct fm10k_q_vector *qv = interface->q_vector[i];\r\nif (!qv->tx.count && !qv->rx.count)\r\ncontinue;\r\nwritel(FM10K_ITR_ENABLE | FM10K_ITR_PENDING2, qv->itr);\r\n}\r\n}\r\n}\r\nstatic void fm10k_service_task(struct work_struct *work)\r\n{\r\nstruct fm10k_intfc *interface;\r\ninterface = container_of(work, struct fm10k_intfc, service_task);\r\nfm10k_mbx_subtask(interface);\r\nfm10k_detach_subtask(interface);\r\nfm10k_reset_subtask(interface);\r\nfm10k_watchdog_subtask(interface);\r\nfm10k_check_hang_subtask(interface);\r\nfm10k_ts_tx_subtask(interface);\r\nfm10k_service_event_complete(interface);\r\n}\r\nstatic void fm10k_configure_tx_ring(struct fm10k_intfc *interface,\r\nstruct fm10k_ring *ring)\r\n{\r\nstruct fm10k_hw *hw = &interface->hw;\r\nu64 tdba = ring->dma;\r\nu32 size = ring->count * sizeof(struct fm10k_tx_desc);\r\nu32 txint = FM10K_INT_MAP_DISABLE;\r\nu32 txdctl = FM10K_TXDCTL_ENABLE | (1 << FM10K_TXDCTL_MAX_TIME_SHIFT);\r\nu8 reg_idx = ring->reg_idx;\r\nfm10k_write_reg(hw, FM10K_TXDCTL(reg_idx), 0);\r\nfm10k_write_flush(hw);\r\nfm10k_write_reg(hw, FM10K_TDBAL(reg_idx), tdba & DMA_BIT_MASK(32));\r\nfm10k_write_reg(hw, FM10K_TDBAH(reg_idx), tdba >> 32);\r\nfm10k_write_reg(hw, FM10K_TDLEN(reg_idx), size);\r\nfm10k_write_reg(hw, FM10K_TDH(reg_idx), 0);\r\nfm10k_write_reg(hw, FM10K_TDT(reg_idx), 0);\r\nring->tail = &interface->uc_addr[FM10K_TDT(reg_idx)];\r\nring->next_to_clean = 0;\r\nring->next_to_use = 0;\r\nif (ring->q_vector) {\r\ntxint = ring->q_vector->v_idx + NON_Q_VECTORS(hw);\r\ntxint |= FM10K_INT_MAP_TIMER0;\r\n}\r\nfm10k_write_reg(hw, FM10K_TXINT(reg_idx), txint);\r\nfm10k_write_reg(hw, FM10K_PFVTCTL(reg_idx),\r\nFM10K_PFVTCTL_FTAG_DESC_ENABLE);\r\nfm10k_write_reg(hw, FM10K_TXDCTL(reg_idx), txdctl);\r\n}\r\nstatic void fm10k_enable_tx_ring(struct fm10k_intfc *interface,\r\nstruct fm10k_ring *ring)\r\n{\r\nstruct fm10k_hw *hw = &interface->hw;\r\nint wait_loop = 10;\r\nu32 txdctl;\r\nu8 reg_idx = ring->reg_idx;\r\nif (fm10k_read_reg(hw, FM10K_TXDCTL(reg_idx)) & FM10K_TXDCTL_ENABLE)\r\nreturn;\r\ndo {\r\nusleep_range(1000, 2000);\r\ntxdctl = fm10k_read_reg(hw, FM10K_TXDCTL(reg_idx));\r\n} while (!(txdctl & FM10K_TXDCTL_ENABLE) && --wait_loop);\r\nif (!wait_loop)\r\nnetif_err(interface, drv, interface->netdev,\r\n"Could not enable Tx Queue %d\n", reg_idx);\r\n}\r\nstatic void fm10k_configure_tx(struct fm10k_intfc *interface)\r\n{\r\nint i;\r\nfor (i = 0; i < interface->num_tx_queues; i++)\r\nfm10k_configure_tx_ring(interface, interface->tx_ring[i]);\r\nfor (i = 0; i < interface->num_tx_queues; i++)\r\nfm10k_enable_tx_ring(interface, interface->tx_ring[i]);\r\n}\r\nstatic void fm10k_configure_rx_ring(struct fm10k_intfc *interface,\r\nstruct fm10k_ring *ring)\r\n{\r\nu64 rdba = ring->dma;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nu32 size = ring->count * sizeof(union fm10k_rx_desc);\r\nu32 rxqctl = FM10K_RXQCTL_ENABLE | FM10K_RXQCTL_PF;\r\nu32 rxdctl = FM10K_RXDCTL_WRITE_BACK_MIN_DELAY;\r\nu32 srrctl = FM10K_SRRCTL_BUFFER_CHAINING_EN;\r\nu32 rxint = FM10K_INT_MAP_DISABLE;\r\nu8 rx_pause = interface->rx_pause;\r\nu8 reg_idx = ring->reg_idx;\r\nfm10k_write_reg(hw, FM10K_RXQCTL(reg_idx), 0);\r\nfm10k_write_flush(hw);\r\nfm10k_write_reg(hw, FM10K_RDBAL(reg_idx), rdba & DMA_BIT_MASK(32));\r\nfm10k_write_reg(hw, FM10K_RDBAH(reg_idx), rdba >> 32);\r\nfm10k_write_reg(hw, FM10K_RDLEN(reg_idx), size);\r\nfm10k_write_reg(hw, FM10K_RDH(reg_idx), 0);\r\nfm10k_write_reg(hw, FM10K_RDT(reg_idx), 0);\r\nring->tail = &interface->uc_addr[FM10K_RDT(reg_idx)];\r\nring->next_to_clean = 0;\r\nring->next_to_use = 0;\r\nring->next_to_alloc = 0;\r\nsrrctl |= FM10K_RX_BUFSZ >> FM10K_SRRCTL_BSIZEPKT_SHIFT;\r\nsrrctl |= FM10K_SRRCTL_LOOPBACK_SUPPRESS;\r\nfm10k_write_reg(hw, FM10K_SRRCTL(reg_idx), srrctl);\r\n#ifdef CONFIG_DCB\r\nif (interface->pfc_en)\r\nrx_pause = interface->pfc_en;\r\n#endif\r\nif (!(rx_pause & (1 << ring->qos_pc)))\r\nrxdctl |= FM10K_RXDCTL_DROP_ON_EMPTY;\r\nfm10k_write_reg(hw, FM10K_RXDCTL(reg_idx), rxdctl);\r\nring->vid = hw->mac.default_vid;\r\nif (ring->q_vector) {\r\nrxint = ring->q_vector->v_idx + NON_Q_VECTORS(hw);\r\nrxint |= FM10K_INT_MAP_TIMER1;\r\n}\r\nfm10k_write_reg(hw, FM10K_RXINT(reg_idx), rxint);\r\nfm10k_write_reg(hw, FM10K_RXQCTL(reg_idx), rxqctl);\r\nfm10k_alloc_rx_buffers(ring, fm10k_desc_unused(ring));\r\n}\r\nvoid fm10k_update_rx_drop_en(struct fm10k_intfc *interface)\r\n{\r\nstruct fm10k_hw *hw = &interface->hw;\r\nu8 rx_pause = interface->rx_pause;\r\nint i;\r\n#ifdef CONFIG_DCB\r\nif (interface->pfc_en)\r\nrx_pause = interface->pfc_en;\r\n#endif\r\nfor (i = 0; i < interface->num_rx_queues; i++) {\r\nstruct fm10k_ring *ring = interface->rx_ring[i];\r\nu32 rxdctl = FM10K_RXDCTL_WRITE_BACK_MIN_DELAY;\r\nu8 reg_idx = ring->reg_idx;\r\nif (!(rx_pause & (1 << ring->qos_pc)))\r\nrxdctl |= FM10K_RXDCTL_DROP_ON_EMPTY;\r\nfm10k_write_reg(hw, FM10K_RXDCTL(reg_idx), rxdctl);\r\n}\r\n}\r\nstatic void fm10k_configure_dglort(struct fm10k_intfc *interface)\r\n{\r\nstruct fm10k_dglort_cfg dglort = { 0 };\r\nstruct fm10k_hw *hw = &interface->hw;\r\nint i;\r\nu32 mrqc;\r\nfor (i = 0; i < FM10K_RSSRK_SIZE; i++)\r\nfm10k_write_reg(hw, FM10K_RSSRK(0, i), interface->rssrk[i]);\r\nfor (i = 0; i < FM10K_RETA_SIZE; i++)\r\nfm10k_write_reg(hw, FM10K_RETA(0, i), interface->reta[i]);\r\nmrqc = FM10K_MRQC_IPV4 |\r\nFM10K_MRQC_TCP_IPV4 |\r\nFM10K_MRQC_IPV6 |\r\nFM10K_MRQC_TCP_IPV6;\r\nif (interface->flags & FM10K_FLAG_RSS_FIELD_IPV4_UDP)\r\nmrqc |= FM10K_MRQC_UDP_IPV4;\r\nif (interface->flags & FM10K_FLAG_RSS_FIELD_IPV6_UDP)\r\nmrqc |= FM10K_MRQC_UDP_IPV6;\r\nfm10k_write_reg(hw, FM10K_MRQC(0), mrqc);\r\ndglort.inner_rss = 1;\r\ndglort.rss_l = fls(interface->ring_feature[RING_F_RSS].mask);\r\ndglort.pc_l = fls(interface->ring_feature[RING_F_QOS].mask);\r\nhw->mac.ops.configure_dglort_map(hw, &dglort);\r\nif (interface->glort_count > 64) {\r\nmemset(&dglort, 0, sizeof(dglort));\r\ndglort.inner_rss = 1;\r\ndglort.glort = interface->glort + 64;\r\ndglort.idx = fm10k_dglort_pf_queue;\r\ndglort.queue_l = fls(interface->num_rx_queues - 1);\r\nhw->mac.ops.configure_dglort_map(hw, &dglort);\r\n}\r\nmemset(&dglort, 0, sizeof(dglort));\r\ndglort.inner_rss = 1;\r\ndglort.glort = interface->glort;\r\ndglort.rss_l = fls(interface->ring_feature[RING_F_RSS].mask);\r\ndglort.pc_l = fls(interface->ring_feature[RING_F_QOS].mask);\r\ndglort.idx = fm10k_dglort_pf_rss;\r\nif (interface->l2_accel)\r\ndglort.shared_l = fls(interface->l2_accel->size);\r\nhw->mac.ops.configure_dglort_map(hw, &dglort);\r\n}\r\nstatic void fm10k_configure_rx(struct fm10k_intfc *interface)\r\n{\r\nint i;\r\nfm10k_configure_swpri_map(interface);\r\nfm10k_configure_dglort(interface);\r\nfor (i = 0; i < interface->num_rx_queues; i++)\r\nfm10k_configure_rx_ring(interface, interface->rx_ring[i]);\r\n}\r\nstatic void fm10k_napi_enable_all(struct fm10k_intfc *interface)\r\n{\r\nstruct fm10k_q_vector *q_vector;\r\nint q_idx;\r\nfor (q_idx = 0; q_idx < interface->num_q_vectors; q_idx++) {\r\nq_vector = interface->q_vector[q_idx];\r\nnapi_enable(&q_vector->napi);\r\n}\r\n}\r\nstatic irqreturn_t fm10k_msix_clean_rings(int irq, void *data)\r\n{\r\nstruct fm10k_q_vector *q_vector = data;\r\nif (q_vector->rx.count || q_vector->tx.count)\r\nnapi_schedule(&q_vector->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t fm10k_msix_mbx_vf(int irq, void *data)\r\n{\r\nstruct fm10k_intfc *interface = data;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nstruct fm10k_mbx_info *mbx = &hw->mbx;\r\nfm10k_write_reg(hw, FM10K_VFITR(FM10K_MBX_VECTOR),\r\nFM10K_ITR_ENABLE | FM10K_MBX_INT_DELAY);\r\nif (fm10k_mbx_trylock(interface)) {\r\nmbx->ops.process(hw, mbx);\r\nfm10k_mbx_unlock(interface);\r\n}\r\nhw->mac.get_host_state = 1;\r\nfm10k_service_event_schedule(interface);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void fm10k_print_fault(struct fm10k_intfc *interface, int type,\r\nstruct fm10k_fault *fault)\r\n{\r\nstruct pci_dev *pdev = interface->pdev;\r\nchar *error;\r\nswitch (type) {\r\ncase FM10K_PCA_FAULT:\r\nswitch (fault->type) {\r\ndefault:\r\nerror = "Unknown PCA error";\r\nbreak;\r\nFM10K_ERR_MSG(PCA_NO_FAULT);\r\nFM10K_ERR_MSG(PCA_UNMAPPED_ADDR);\r\nFM10K_ERR_MSG(PCA_BAD_QACCESS_PF);\r\nFM10K_ERR_MSG(PCA_BAD_QACCESS_VF);\r\nFM10K_ERR_MSG(PCA_MALICIOUS_REQ);\r\nFM10K_ERR_MSG(PCA_POISONED_TLP);\r\nFM10K_ERR_MSG(PCA_TLP_ABORT);\r\n}\r\nbreak;\r\ncase FM10K_THI_FAULT:\r\nswitch (fault->type) {\r\ndefault:\r\nerror = "Unknown THI error";\r\nbreak;\r\nFM10K_ERR_MSG(THI_NO_FAULT);\r\nFM10K_ERR_MSG(THI_MAL_DIS_Q_FAULT);\r\n}\r\nbreak;\r\ncase FM10K_FUM_FAULT:\r\nswitch (fault->type) {\r\ndefault:\r\nerror = "Unknown FUM error";\r\nbreak;\r\nFM10K_ERR_MSG(FUM_NO_FAULT);\r\nFM10K_ERR_MSG(FUM_UNMAPPED_ADDR);\r\nFM10K_ERR_MSG(FUM_BAD_VF_QACCESS);\r\nFM10K_ERR_MSG(FUM_ADD_DECODE_ERR);\r\nFM10K_ERR_MSG(FUM_RO_ERROR);\r\nFM10K_ERR_MSG(FUM_QPRC_CRC_ERROR);\r\nFM10K_ERR_MSG(FUM_CSR_TIMEOUT);\r\nFM10K_ERR_MSG(FUM_INVALID_TYPE);\r\nFM10K_ERR_MSG(FUM_INVALID_LENGTH);\r\nFM10K_ERR_MSG(FUM_INVALID_BE);\r\nFM10K_ERR_MSG(FUM_INVALID_ALIGN);\r\n}\r\nbreak;\r\ndefault:\r\nerror = "Undocumented fault";\r\nbreak;\r\n}\r\ndev_warn(&pdev->dev,\r\n"%s Address: 0x%llx SpecInfo: 0x%x Func: %02x.%0x\n",\r\nerror, fault->address, fault->specinfo,\r\nPCI_SLOT(fault->func), PCI_FUNC(fault->func));\r\n}\r\nstatic void fm10k_report_fault(struct fm10k_intfc *interface, u32 eicr)\r\n{\r\nstruct fm10k_hw *hw = &interface->hw;\r\nstruct fm10k_fault fault = { 0 };\r\nint type, err;\r\nfor (eicr &= FM10K_EICR_FAULT_MASK, type = FM10K_PCA_FAULT;\r\neicr;\r\neicr >>= 1, type += FM10K_FAULT_SIZE) {\r\nif (!(eicr & 0x1))\r\ncontinue;\r\nerr = hw->mac.ops.get_fault(hw, type, &fault);\r\nif (err) {\r\ndev_err(&interface->pdev->dev,\r\n"error reading fault\n");\r\ncontinue;\r\n}\r\nfm10k_print_fault(interface, type, &fault);\r\n}\r\n}\r\nstatic void fm10k_reset_drop_on_empty(struct fm10k_intfc *interface, u32 eicr)\r\n{\r\nstruct fm10k_hw *hw = &interface->hw;\r\nconst u32 rxdctl = FM10K_RXDCTL_WRITE_BACK_MIN_DELAY;\r\nu32 maxholdq;\r\nint q;\r\nif (!(eicr & FM10K_EICR_MAXHOLDTIME))\r\nreturn;\r\nmaxholdq = fm10k_read_reg(hw, FM10K_MAXHOLDQ(7));\r\nif (maxholdq)\r\nfm10k_write_reg(hw, FM10K_MAXHOLDQ(7), maxholdq);\r\nfor (q = 255;;) {\r\nif (maxholdq & (1 << 31)) {\r\nif (q < FM10K_MAX_QUEUES_PF) {\r\ninterface->rx_overrun_pf++;\r\nfm10k_write_reg(hw, FM10K_RXDCTL(q), rxdctl);\r\n} else {\r\ninterface->rx_overrun_vf++;\r\n}\r\n}\r\nmaxholdq *= 2;\r\nif (!maxholdq)\r\nq &= ~(32 - 1);\r\nif (!q)\r\nbreak;\r\nif (q-- % 32)\r\ncontinue;\r\nmaxholdq = fm10k_read_reg(hw, FM10K_MAXHOLDQ(q / 32));\r\nif (maxholdq)\r\nfm10k_write_reg(hw, FM10K_MAXHOLDQ(q / 32), maxholdq);\r\n}\r\n}\r\nstatic irqreturn_t fm10k_msix_mbx_pf(int irq, void *data)\r\n{\r\nstruct fm10k_intfc *interface = data;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nstruct fm10k_mbx_info *mbx = &hw->mbx;\r\nu32 eicr;\r\neicr = fm10k_read_reg(hw, FM10K_EICR);\r\nfm10k_write_reg(hw, FM10K_EICR, eicr & (FM10K_EICR_MAILBOX |\r\nFM10K_EICR_SWITCHREADY |\r\nFM10K_EICR_SWITCHNOTREADY));\r\nfm10k_report_fault(interface, eicr);\r\nfm10k_reset_drop_on_empty(interface, eicr);\r\nif (fm10k_mbx_trylock(interface)) {\r\nmbx->ops.process(hw, mbx);\r\nfm10k_iov_event(interface);\r\nfm10k_mbx_unlock(interface);\r\n}\r\nif (eicr & FM10K_EICR_SWITCHNOTREADY) {\r\ninterface->link_down_event = jiffies + (4 * HZ);\r\nset_bit(__FM10K_LINK_DOWN, &interface->state);\r\nhw->mac.dglort_map = FM10K_DGLORTMAP_NONE;\r\n}\r\nhw->mac.get_host_state = 1;\r\nfm10k_service_event_schedule(interface);\r\nfm10k_write_reg(hw, FM10K_ITR(FM10K_MBX_VECTOR),\r\nFM10K_ITR_ENABLE | FM10K_MBX_INT_DELAY);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid fm10k_mbx_free_irq(struct fm10k_intfc *interface)\r\n{\r\nstruct msix_entry *entry = &interface->msix_entries[FM10K_MBX_VECTOR];\r\nstruct fm10k_hw *hw = &interface->hw;\r\nint itr_reg;\r\nhw->mbx.ops.disconnect(hw, &hw->mbx);\r\nif (hw->mac.type == fm10k_mac_pf) {\r\nfm10k_write_reg(hw, FM10K_EIMR,\r\nFM10K_EIMR_DISABLE(PCA_FAULT) |\r\nFM10K_EIMR_DISABLE(FUM_FAULT) |\r\nFM10K_EIMR_DISABLE(MAILBOX) |\r\nFM10K_EIMR_DISABLE(SWITCHREADY) |\r\nFM10K_EIMR_DISABLE(SWITCHNOTREADY) |\r\nFM10K_EIMR_DISABLE(SRAMERROR) |\r\nFM10K_EIMR_DISABLE(VFLR) |\r\nFM10K_EIMR_DISABLE(MAXHOLDTIME));\r\nitr_reg = FM10K_ITR(FM10K_MBX_VECTOR);\r\n} else {\r\nitr_reg = FM10K_VFITR(FM10K_MBX_VECTOR);\r\n}\r\nfm10k_write_reg(hw, itr_reg, FM10K_ITR_MASK_SET);\r\nfree_irq(entry->vector, interface);\r\n}\r\nstatic s32 fm10k_mbx_mac_addr(struct fm10k_hw *hw, u32 **results,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nbool vlan_override = hw->mac.vlan_override;\r\nu16 default_vid = hw->mac.default_vid;\r\nstruct fm10k_intfc *interface;\r\ns32 err;\r\nerr = fm10k_msg_mac_vlan_vf(hw, results, mbx);\r\nif (err)\r\nreturn err;\r\ninterface = container_of(hw, struct fm10k_intfc, hw);\r\nif (is_valid_ether_addr(hw->mac.perm_addr) &&\r\nmemcmp(hw->mac.perm_addr, hw->mac.addr, ETH_ALEN))\r\ninterface->flags |= FM10K_FLAG_RESET_REQUESTED;\r\nif ((vlan_override != hw->mac.vlan_override) ||\r\n(default_vid != hw->mac.default_vid))\r\ninterface->flags |= FM10K_FLAG_RESET_REQUESTED;\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_1588_msg_vf(struct fm10k_hw *hw, u32 **results,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nstruct fm10k_intfc *interface;\r\nu64 timestamp;\r\ns32 err;\r\nerr = fm10k_tlv_attr_get_u64(results[FM10K_1588_MSG_TIMESTAMP],\r\n&timestamp);\r\nif (err)\r\nreturn err;\r\ninterface = container_of(hw, struct fm10k_intfc, hw);\r\nfm10k_ts_tx_hwtstamp(interface, 0, timestamp);\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_mbx_error(struct fm10k_hw *hw, u32 **results,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nstruct fm10k_intfc *interface;\r\nstruct pci_dev *pdev;\r\ninterface = container_of(hw, struct fm10k_intfc, hw);\r\npdev = interface->pdev;\r\ndev_err(&pdev->dev, "Unknown message ID %u\n",\r\n**results & FM10K_TLV_ID_MASK);\r\nreturn 0;\r\n}\r\nstatic int fm10k_mbx_request_irq_vf(struct fm10k_intfc *interface)\r\n{\r\nstruct msix_entry *entry = &interface->msix_entries[FM10K_MBX_VECTOR];\r\nstruct net_device *dev = interface->netdev;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nint err;\r\nu32 itr = FM10K_INT_MAP_TIMER0 | entry->entry;\r\nerr = hw->mbx.ops.register_handlers(&hw->mbx, vf_mbx_data);\r\nif (err)\r\nreturn err;\r\nerr = request_irq(entry->vector, fm10k_msix_mbx_vf, 0,\r\ndev->name, interface);\r\nif (err) {\r\nnetif_err(interface, probe, dev,\r\n"request_irq for msix_mbx failed: %d\n", err);\r\nreturn err;\r\n}\r\nfm10k_write_reg(hw, FM10K_VFINT_MAP, itr);\r\nfm10k_write_reg(hw, FM10K_VFITR(entry->entry), FM10K_ITR_ENABLE);\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_lport_map(struct fm10k_hw *hw, u32 **results,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nstruct fm10k_intfc *interface;\r\nu32 dglort_map = hw->mac.dglort_map;\r\ns32 err;\r\nerr = fm10k_msg_lport_map_pf(hw, results, mbx);\r\nif (err)\r\nreturn err;\r\ninterface = container_of(hw, struct fm10k_intfc, hw);\r\nif (dglort_map != hw->mac.dglort_map)\r\ninterface->flags |= FM10K_FLAG_RESET_REQUESTED;\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_update_pvid(struct fm10k_hw *hw, u32 **results,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nstruct fm10k_intfc *interface;\r\nu16 glort, pvid;\r\nu32 pvid_update;\r\ns32 err;\r\nerr = fm10k_tlv_attr_get_u32(results[FM10K_PF_ATTR_ID_UPDATE_PVID],\r\n&pvid_update);\r\nif (err)\r\nreturn err;\r\nglort = FM10K_MSG_HDR_FIELD_GET(pvid_update, UPDATE_PVID_GLORT);\r\npvid = FM10K_MSG_HDR_FIELD_GET(pvid_update, UPDATE_PVID_PVID);\r\nif (!fm10k_glort_valid_pf(hw, glort))\r\nreturn FM10K_ERR_PARAM;\r\nif (pvid >= FM10K_VLAN_TABLE_VID_MAX)\r\nreturn FM10K_ERR_PARAM;\r\ninterface = container_of(hw, struct fm10k_intfc, hw);\r\nerr = fm10k_iov_update_pvid(interface, glort, pvid);\r\nif (!err)\r\nreturn 0;\r\nif (pvid != hw->mac.default_vid)\r\ninterface->flags |= FM10K_FLAG_RESET_REQUESTED;\r\nhw->mac.default_vid = pvid;\r\nreturn 0;\r\n}\r\nstatic s32 fm10k_1588_msg_pf(struct fm10k_hw *hw, u32 **results,\r\nstruct fm10k_mbx_info *mbx)\r\n{\r\nstruct fm10k_swapi_1588_timestamp timestamp;\r\nstruct fm10k_iov_data *iov_data;\r\nstruct fm10k_intfc *interface;\r\nu16 sglort, vf_idx;\r\ns32 err;\r\nerr = fm10k_tlv_attr_get_le_struct(\r\nresults[FM10K_PF_ATTR_ID_1588_TIMESTAMP],\r\n&timestamp, sizeof(timestamp));\r\nif (err)\r\nreturn err;\r\ninterface = container_of(hw, struct fm10k_intfc, hw);\r\nif (timestamp.dglort) {\r\nfm10k_ts_tx_hwtstamp(interface, timestamp.dglort,\r\nle64_to_cpu(timestamp.egress));\r\nreturn 0;\r\n}\r\nif (!timestamp.sglort)\r\nreturn FM10K_ERR_PARAM;\r\nsglort = le16_to_cpu(timestamp.sglort);\r\nif (!fm10k_glort_valid_pf(hw, sglort))\r\nreturn FM10K_ERR_PARAM;\r\nif (sglort == interface->glort) {\r\nfm10k_ts_tx_hwtstamp(interface, 0,\r\nle64_to_cpu(timestamp.ingress));\r\nreturn 0;\r\n}\r\nif (!ACCESS_ONCE(interface->iov_data))\r\nreturn FM10K_ERR_PARAM;\r\nrcu_read_lock();\r\niov_data = interface->iov_data;\r\nvf_idx = (hw->mac.dglort_map & FM10K_DGLORTMAP_NONE) - sglort;\r\nif (!iov_data || vf_idx >= iov_data->num_vfs) {\r\nerr = FM10K_ERR_PARAM;\r\ngoto err_unlock;\r\n}\r\nerr = hw->iov.ops.report_timestamp(hw, &iov_data->vf_info[vf_idx],\r\nle64_to_cpu(timestamp.ingress));\r\nerr_unlock:\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic int fm10k_mbx_request_irq_pf(struct fm10k_intfc *interface)\r\n{\r\nstruct msix_entry *entry = &interface->msix_entries[FM10K_MBX_VECTOR];\r\nstruct net_device *dev = interface->netdev;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nint err;\r\nu32 mbx_itr = FM10K_INT_MAP_TIMER0 | entry->entry;\r\nu32 other_itr = FM10K_INT_MAP_IMMEDIATE | entry->entry;\r\nerr = hw->mbx.ops.register_handlers(&hw->mbx, pf_mbx_data);\r\nif (err)\r\nreturn err;\r\nerr = request_irq(entry->vector, fm10k_msix_mbx_pf, 0,\r\ndev->name, interface);\r\nif (err) {\r\nnetif_err(interface, probe, dev,\r\n"request_irq for msix_mbx failed: %d\n", err);\r\nreturn err;\r\n}\r\nfm10k_write_reg(hw, FM10K_INT_MAP(fm10k_int_PCIeFault), other_itr);\r\nfm10k_write_reg(hw, FM10K_INT_MAP(fm10k_int_SwitchUpDown), other_itr);\r\nfm10k_write_reg(hw, FM10K_INT_MAP(fm10k_int_SRAM), other_itr);\r\nfm10k_write_reg(hw, FM10K_INT_MAP(fm10k_int_MaxHoldTime), other_itr);\r\nfm10k_write_reg(hw, FM10K_INT_MAP(fm10k_int_VFLR), other_itr);\r\nfm10k_write_reg(hw, FM10K_INT_MAP(fm10k_int_Mailbox), mbx_itr);\r\nfm10k_write_reg(hw, FM10K_EIMR, FM10K_EIMR_ENABLE(PCA_FAULT) |\r\nFM10K_EIMR_ENABLE(FUM_FAULT) |\r\nFM10K_EIMR_ENABLE(MAILBOX) |\r\nFM10K_EIMR_ENABLE(SWITCHREADY) |\r\nFM10K_EIMR_ENABLE(SWITCHNOTREADY) |\r\nFM10K_EIMR_ENABLE(SRAMERROR) |\r\nFM10K_EIMR_ENABLE(VFLR) |\r\nFM10K_EIMR_ENABLE(MAXHOLDTIME));\r\nfm10k_write_reg(hw, FM10K_ITR(entry->entry), FM10K_ITR_ENABLE);\r\nreturn 0;\r\n}\r\nint fm10k_mbx_request_irq(struct fm10k_intfc *interface)\r\n{\r\nstruct fm10k_hw *hw = &interface->hw;\r\nint err;\r\nif (hw->mac.type == fm10k_mac_pf)\r\nerr = fm10k_mbx_request_irq_pf(interface);\r\nelse\r\nerr = fm10k_mbx_request_irq_vf(interface);\r\nif (!err)\r\nerr = hw->mbx.ops.connect(hw, &hw->mbx);\r\nreturn err;\r\n}\r\nvoid fm10k_qv_free_irq(struct fm10k_intfc *interface)\r\n{\r\nint vector = interface->num_q_vectors;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nstruct msix_entry *entry;\r\nentry = &interface->msix_entries[NON_Q_VECTORS(hw) + vector];\r\nwhile (vector) {\r\nstruct fm10k_q_vector *q_vector;\r\nvector--;\r\nentry--;\r\nq_vector = interface->q_vector[vector];\r\nif (!q_vector->tx.count && !q_vector->rx.count)\r\ncontinue;\r\nwritel(FM10K_ITR_MASK_SET, q_vector->itr);\r\nfree_irq(entry->vector, q_vector);\r\n}\r\n}\r\nint fm10k_qv_request_irq(struct fm10k_intfc *interface)\r\n{\r\nstruct net_device *dev = interface->netdev;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nstruct msix_entry *entry;\r\nint ri = 0, ti = 0;\r\nint vector, err;\r\nentry = &interface->msix_entries[NON_Q_VECTORS(hw)];\r\nfor (vector = 0; vector < interface->num_q_vectors; vector++) {\r\nstruct fm10k_q_vector *q_vector = interface->q_vector[vector];\r\nif (q_vector->tx.count && q_vector->rx.count) {\r\nsnprintf(q_vector->name, sizeof(q_vector->name) - 1,\r\n"%s-TxRx-%d", dev->name, ri++);\r\nti++;\r\n} else if (q_vector->rx.count) {\r\nsnprintf(q_vector->name, sizeof(q_vector->name) - 1,\r\n"%s-rx-%d", dev->name, ri++);\r\n} else if (q_vector->tx.count) {\r\nsnprintf(q_vector->name, sizeof(q_vector->name) - 1,\r\n"%s-tx-%d", dev->name, ti++);\r\n} else {\r\ncontinue;\r\n}\r\nq_vector->itr = (hw->mac.type == fm10k_mac_pf) ?\r\n&interface->uc_addr[FM10K_ITR(entry->entry)] :\r\n&interface->uc_addr[FM10K_VFITR(entry->entry)];\r\nerr = request_irq(entry->vector, &fm10k_msix_clean_rings, 0,\r\nq_vector->name, q_vector);\r\nif (err) {\r\nnetif_err(interface, probe, dev,\r\n"request_irq failed for MSIX interrupt Error: %d\n",\r\nerr);\r\ngoto err_out;\r\n}\r\nwritel(FM10K_ITR_ENABLE, q_vector->itr);\r\nentry++;\r\n}\r\nreturn 0;\r\nerr_out:\r\nwhile (vector) {\r\nstruct fm10k_q_vector *q_vector;\r\nentry--;\r\nvector--;\r\nq_vector = interface->q_vector[vector];\r\nif (!q_vector->tx.count && !q_vector->rx.count)\r\ncontinue;\r\nwritel(FM10K_ITR_MASK_SET, q_vector->itr);\r\nfree_irq(entry->vector, q_vector);\r\n}\r\nreturn err;\r\n}\r\nvoid fm10k_up(struct fm10k_intfc *interface)\r\n{\r\nstruct fm10k_hw *hw = &interface->hw;\r\nhw->mac.ops.start_hw(hw);\r\nfm10k_configure_tx(interface);\r\nfm10k_configure_rx(interface);\r\nhw->mac.ops.update_int_moderator(hw);\r\nclear_bit(__FM10K_DOWN, &interface->state);\r\nfm10k_napi_enable_all(interface);\r\nfm10k_restore_rx_state(interface);\r\nnetif_tx_start_all_queues(interface->netdev);\r\nhw->mac.get_host_state = 1;\r\nmod_timer(&interface->service_timer, jiffies);\r\n}\r\nstatic void fm10k_napi_disable_all(struct fm10k_intfc *interface)\r\n{\r\nstruct fm10k_q_vector *q_vector;\r\nint q_idx;\r\nfor (q_idx = 0; q_idx < interface->num_q_vectors; q_idx++) {\r\nq_vector = interface->q_vector[q_idx];\r\nnapi_disable(&q_vector->napi);\r\n}\r\n}\r\nvoid fm10k_down(struct fm10k_intfc *interface)\r\n{\r\nstruct net_device *netdev = interface->netdev;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nset_bit(__FM10K_DOWN, &interface->state);\r\nnetif_carrier_off(netdev);\r\nnetif_tx_stop_all_queues(netdev);\r\nnetif_tx_disable(netdev);\r\nfm10k_reset_rx_state(interface);\r\nusleep_range(10000, 20000);\r\nfm10k_napi_disable_all(interface);\r\ndel_timer_sync(&interface->service_timer);\r\nfm10k_update_stats(interface);\r\nhw->mac.ops.stop_hw(hw);\r\nfm10k_clean_all_tx_rings(interface);\r\n}\r\nstatic int fm10k_sw_init(struct fm10k_intfc *interface,\r\nconst struct pci_device_id *ent)\r\n{\r\nconst struct fm10k_info *fi = fm10k_info_tbl[ent->driver_data];\r\nstruct fm10k_hw *hw = &interface->hw;\r\nstruct pci_dev *pdev = interface->pdev;\r\nstruct net_device *netdev = interface->netdev;\r\nu32 rss_key[FM10K_RSSRK_SIZE];\r\nunsigned int rss;\r\nint err;\r\nhw->back = interface;\r\nhw->hw_addr = interface->uc_addr;\r\nhw->vendor_id = pdev->vendor;\r\nhw->device_id = pdev->device;\r\nhw->revision_id = pdev->revision;\r\nhw->subsystem_vendor_id = pdev->subsystem_vendor;\r\nhw->subsystem_device_id = pdev->subsystem_device;\r\nmemcpy(&hw->mac.ops, fi->mac_ops, sizeof(hw->mac.ops));\r\nhw->mac.type = fi->mac;\r\nif (fi->iov_ops)\r\nmemcpy(&hw->iov.ops, fi->iov_ops, sizeof(hw->iov.ops));\r\nrss = min_t(int, FM10K_MAX_RSS_INDICES, num_online_cpus());\r\ninterface->ring_feature[RING_F_RSS].limit = rss;\r\nfi->get_invariants(hw);\r\nif (hw->mac.ops.get_bus_info)\r\nhw->mac.ops.get_bus_info(hw);\r\nif (hw->mac.ops.set_dma_mask)\r\nhw->mac.ops.set_dma_mask(hw, dma_get_mask(&pdev->dev));\r\nif (dma_get_mask(&pdev->dev) > DMA_BIT_MASK(32)) {\r\nnetdev->features |= NETIF_F_HIGHDMA;\r\nnetdev->vlan_features |= NETIF_F_HIGHDMA;\r\n}\r\ninterface->last_reset = jiffies + (10 * HZ);\r\nerr = hw->mac.ops.reset_hw(hw) ? : hw->mac.ops.init_hw(hw);\r\nif (err) {\r\ndev_err(&pdev->dev, "init_hw failed: %d\n", err);\r\nreturn err;\r\n}\r\nhw->mac.ops.update_hw_stats(hw, &interface->stats);\r\npci_sriov_set_totalvfs(pdev, hw->iov.total_vfs);\r\neth_random_addr(hw->mac.addr);\r\nerr = hw->mac.ops.read_mac_addr(hw);\r\nif (err) {\r\ndev_warn(&pdev->dev,\r\n"Failed to obtain MAC address defaulting to random\n");\r\nnetdev->addr_assign_type |= NET_ADDR_RANDOM;\r\n}\r\nmemcpy(netdev->dev_addr, hw->mac.addr, netdev->addr_len);\r\nmemcpy(netdev->perm_addr, hw->mac.addr, netdev->addr_len);\r\nif (!is_valid_ether_addr(netdev->perm_addr)) {\r\ndev_err(&pdev->dev, "Invalid MAC Address\n");\r\nreturn -EIO;\r\n}\r\nif (fm10k_read_reg(hw, FM10K_CTRL) & FM10K_CTRL_BAR4_ALLOWED)\r\ninterface->sw_addr = ioremap(pci_resource_start(pdev, 4),\r\npci_resource_len(pdev, 4));\r\nhw->sw_addr = interface->sw_addr;\r\nif (hw->mac.type != fm10k_mac_pf) {\r\nnetdev->hw_enc_features = 0;\r\nnetdev->features &= ~NETIF_F_GSO_UDP_TUNNEL;\r\nnetdev->hw_features &= ~NETIF_F_GSO_UDP_TUNNEL;\r\n}\r\nfm10k_dcbnl_set_ops(netdev);\r\nset_bit(__FM10K_SERVICE_DISABLE, &interface->state);\r\nsetup_timer(&interface->service_timer, &fm10k_service_timer,\r\n(unsigned long)interface);\r\nINIT_WORK(&interface->service_task, fm10k_service_task);\r\nfm10k_ts_init(interface);\r\ninterface->tx_ring_count = FM10K_DEFAULT_TXD;\r\ninterface->rx_ring_count = FM10K_DEFAULT_RXD;\r\ninterface->tx_itr = FM10K_ITR_10K;\r\ninterface->rx_itr = FM10K_ITR_ADAPTIVE | FM10K_ITR_20K;\r\nINIT_LIST_HEAD(&interface->vxlan_port);\r\nnetdev_rss_key_fill(rss_key, sizeof(rss_key));\r\nmemcpy(interface->rssrk, rss_key, sizeof(rss_key));\r\nset_bit(__FM10K_DOWN, &interface->state);\r\nreturn 0;\r\n}\r\nstatic void fm10k_slot_warn(struct fm10k_intfc *interface)\r\n{\r\nstruct device *dev = &interface->pdev->dev;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nif (hw->mac.ops.is_slot_appropriate(hw))\r\nreturn;\r\ndev_warn(dev,\r\n"For optimal performance, a %s %s slot is recommended.\n",\r\n(hw->bus_caps.width == fm10k_bus_width_pcie_x1 ? "x1" :\r\nhw->bus_caps.width == fm10k_bus_width_pcie_x4 ? "x4" :\r\n"x8"),\r\n(hw->bus_caps.speed == fm10k_bus_speed_2500 ? "2.5GT/s" :\r\nhw->bus_caps.speed == fm10k_bus_speed_5000 ? "5.0GT/s" :\r\n"8.0GT/s"));\r\ndev_warn(dev,\r\n"A slot with more lanes and/or higher speed is suggested.\n");\r\n}\r\nstatic int fm10k_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct net_device *netdev;\r\nstruct fm10k_intfc *interface;\r\nstruct fm10k_hw *hw;\r\nint err;\r\nu64 dma_mask;\r\nerr = pci_enable_device_mem(pdev);\r\nif (err)\r\nreturn err;\r\ndma_mask = DMA_BIT_MASK(48) | dma_get_required_mask(&pdev->dev);\r\nif ((dma_mask <= DMA_BIT_MASK(32)) ||\r\ndma_set_mask_and_coherent(&pdev->dev, dma_mask)) {\r\ndma_mask &= DMA_BIT_MASK(32);\r\nerr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\r\nerr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\r\nif (err) {\r\nerr = dma_set_coherent_mask(&pdev->dev,\r\nDMA_BIT_MASK(32));\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"No usable DMA configuration, aborting\n");\r\ngoto err_dma;\r\n}\r\n}\r\n}\r\nerr = pci_request_selected_regions(pdev,\r\npci_select_bars(pdev,\r\nIORESOURCE_MEM),\r\nfm10k_driver_name);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"pci_request_selected_regions failed 0x%x\n", err);\r\ngoto err_pci_reg;\r\n}\r\npci_enable_pcie_error_reporting(pdev);\r\npci_set_master(pdev);\r\npci_save_state(pdev);\r\nnetdev = fm10k_alloc_netdev();\r\nif (!netdev) {\r\nerr = -ENOMEM;\r\ngoto err_alloc_netdev;\r\n}\r\nSET_NETDEV_DEV(netdev, &pdev->dev);\r\ninterface = netdev_priv(netdev);\r\npci_set_drvdata(pdev, interface);\r\ninterface->netdev = netdev;\r\ninterface->pdev = pdev;\r\nhw = &interface->hw;\r\ninterface->uc_addr = ioremap(pci_resource_start(pdev, 0),\r\nFM10K_UC_ADDR_SIZE);\r\nif (!interface->uc_addr) {\r\nerr = -EIO;\r\ngoto err_ioremap;\r\n}\r\nerr = fm10k_sw_init(interface, ent);\r\nif (err)\r\ngoto err_sw_init;\r\nfm10k_dbg_intfc_init(interface);\r\nerr = fm10k_init_queueing_scheme(interface);\r\nif (err)\r\ngoto err_sw_init;\r\nerr = fm10k_mbx_request_irq(interface);\r\nif (err)\r\ngoto err_mbx_interrupt;\r\nerr = fm10k_hw_ready(interface);\r\nif (err)\r\ngoto err_register;\r\nerr = register_netdev(netdev);\r\nif (err)\r\ngoto err_register;\r\nnetif_carrier_off(netdev);\r\nnetif_tx_stop_all_queues(netdev);\r\nfm10k_ptp_register(interface);\r\ndev_info(&pdev->dev, "(PCI Express:%s Width: %s Payload: %s)\n",\r\n(hw->bus.speed == fm10k_bus_speed_8000 ? "8.0GT/s" :\r\nhw->bus.speed == fm10k_bus_speed_5000 ? "5.0GT/s" :\r\nhw->bus.speed == fm10k_bus_speed_2500 ? "2.5GT/s" :\r\n"Unknown"),\r\n(hw->bus.width == fm10k_bus_width_pcie_x8 ? "x8" :\r\nhw->bus.width == fm10k_bus_width_pcie_x4 ? "x4" :\r\nhw->bus.width == fm10k_bus_width_pcie_x1 ? "x1" :\r\n"Unknown"),\r\n(hw->bus.payload == fm10k_bus_payload_128 ? "128B" :\r\nhw->bus.payload == fm10k_bus_payload_256 ? "256B" :\r\nhw->bus.payload == fm10k_bus_payload_512 ? "512B" :\r\n"Unknown"));\r\nfm10k_slot_warn(interface);\r\nfm10k_iov_configure(pdev, 0);\r\nclear_bit(__FM10K_SERVICE_DISABLE, &interface->state);\r\nreturn 0;\r\nerr_register:\r\nfm10k_mbx_free_irq(interface);\r\nerr_mbx_interrupt:\r\nfm10k_clear_queueing_scheme(interface);\r\nerr_sw_init:\r\nif (interface->sw_addr)\r\niounmap(interface->sw_addr);\r\niounmap(interface->uc_addr);\r\nerr_ioremap:\r\nfree_netdev(netdev);\r\nerr_alloc_netdev:\r\npci_release_selected_regions(pdev,\r\npci_select_bars(pdev, IORESOURCE_MEM));\r\nerr_pci_reg:\r\nerr_dma:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void fm10k_remove(struct pci_dev *pdev)\r\n{\r\nstruct fm10k_intfc *interface = pci_get_drvdata(pdev);\r\nstruct net_device *netdev = interface->netdev;\r\nset_bit(__FM10K_SERVICE_DISABLE, &interface->state);\r\ncancel_work_sync(&interface->service_task);\r\nif (netdev->reg_state == NETREG_REGISTERED)\r\nunregister_netdev(netdev);\r\nfm10k_ptp_unregister(interface);\r\nfm10k_iov_disable(pdev);\r\nfm10k_mbx_free_irq(interface);\r\nfm10k_clear_queueing_scheme(interface);\r\nfm10k_dbg_intfc_exit(interface);\r\nif (interface->sw_addr)\r\niounmap(interface->sw_addr);\r\niounmap(interface->uc_addr);\r\nfree_netdev(netdev);\r\npci_release_selected_regions(pdev,\r\npci_select_bars(pdev, IORESOURCE_MEM));\r\npci_disable_pcie_error_reporting(pdev);\r\npci_disable_device(pdev);\r\n}\r\nstatic int fm10k_resume(struct pci_dev *pdev)\r\n{\r\nstruct fm10k_intfc *interface = pci_get_drvdata(pdev);\r\nstruct net_device *netdev = interface->netdev;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nu32 err;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\npci_save_state(pdev);\r\nerr = pci_enable_device_mem(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot enable PCI device from suspend\n");\r\nreturn err;\r\n}\r\npci_set_master(pdev);\r\npci_wake_from_d3(pdev, false);\r\nhw->hw_addr = interface->uc_addr;\r\nerr = hw->mac.ops.init_hw(&interface->hw);\r\nif (err)\r\nreturn err;\r\nhw->mac.ops.rebind_hw_stats(hw, &interface->stats);\r\nfm10k_ts_reset(interface);\r\nrtnl_lock();\r\nerr = fm10k_init_queueing_scheme(interface);\r\nif (!err) {\r\nfm10k_mbx_request_irq(interface);\r\nif (netif_running(netdev))\r\nerr = fm10k_open(netdev);\r\n}\r\nrtnl_unlock();\r\nif (err)\r\nreturn err;\r\nfm10k_iov_resume(pdev);\r\nnetif_device_attach(netdev);\r\nreturn 0;\r\n}\r\nstatic int fm10k_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct fm10k_intfc *interface = pci_get_drvdata(pdev);\r\nstruct net_device *netdev = interface->netdev;\r\nint err = 0;\r\nnetif_device_detach(netdev);\r\nfm10k_iov_suspend(pdev);\r\nrtnl_lock();\r\nif (netif_running(netdev))\r\nfm10k_close(netdev);\r\nfm10k_mbx_free_irq(interface);\r\nfm10k_clear_queueing_scheme(interface);\r\nrtnl_unlock();\r\nerr = pci_save_state(pdev);\r\nif (err)\r\nreturn err;\r\npci_disable_device(pdev);\r\npci_wake_from_d3(pdev, false);\r\npci_set_power_state(pdev, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic pci_ers_result_t fm10k_io_error_detected(struct pci_dev *pdev,\r\npci_channel_state_t state)\r\n{\r\nstruct fm10k_intfc *interface = pci_get_drvdata(pdev);\r\nstruct net_device *netdev = interface->netdev;\r\nnetif_device_detach(netdev);\r\nif (state == pci_channel_io_perm_failure)\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\nif (netif_running(netdev))\r\nfm10k_close(netdev);\r\nfm10k_mbx_free_irq(interface);\r\npci_disable_device(pdev);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\nstatic pci_ers_result_t fm10k_io_slot_reset(struct pci_dev *pdev)\r\n{\r\nstruct fm10k_intfc *interface = pci_get_drvdata(pdev);\r\npci_ers_result_t result;\r\nif (pci_enable_device_mem(pdev)) {\r\ndev_err(&pdev->dev,\r\n"Cannot re-enable PCI device after reset.\n");\r\nresult = PCI_ERS_RESULT_DISCONNECT;\r\n} else {\r\npci_set_master(pdev);\r\npci_restore_state(pdev);\r\npci_save_state(pdev);\r\npci_wake_from_d3(pdev, false);\r\ninterface->hw.hw_addr = interface->uc_addr;\r\ninterface->flags |= FM10K_FLAG_RESET_REQUESTED;\r\nfm10k_service_event_schedule(interface);\r\nresult = PCI_ERS_RESULT_RECOVERED;\r\n}\r\npci_cleanup_aer_uncorrect_error_status(pdev);\r\nreturn result;\r\n}\r\nstatic void fm10k_io_resume(struct pci_dev *pdev)\r\n{\r\nstruct fm10k_intfc *interface = pci_get_drvdata(pdev);\r\nstruct net_device *netdev = interface->netdev;\r\nstruct fm10k_hw *hw = &interface->hw;\r\nint err = 0;\r\nhw->mac.ops.init_hw(&interface->hw);\r\nhw->mac.ops.rebind_hw_stats(hw, &interface->stats);\r\nfm10k_mbx_request_irq(interface);\r\nfm10k_ts_reset(interface);\r\nif (netif_running(netdev))\r\nerr = fm10k_open(netdev);\r\nerr = err ? : fm10k_hw_ready(interface);\r\nif (!err)\r\nnetif_device_attach(netdev);\r\n}\r\nint fm10k_register_pci_driver(void)\r\n{\r\nreturn pci_register_driver(&fm10k_driver);\r\n}\r\nvoid fm10k_unregister_pci_driver(void)\r\n{\r\npci_unregister_driver(&fm10k_driver);\r\n}
