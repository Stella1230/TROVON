static void bf5xx_dma_irq(void *data)\r\n{\r\nstruct snd_pcm_substream *pcm = data;\r\nsnd_pcm_period_elapsed(pcm);\r\n}\r\nstatic int bf5xx_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nunsigned int buffer_size = params_buffer_bytes(params);\r\nstruct bf5xx_i2s_pcm_data *dma_data;\r\ndma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nif (dma_data->tdm_mode)\r\nbuffer_size = buffer_size / params_channels(params) * 8;\r\nreturn snd_pcm_lib_malloc_pages(substream, buffer_size);\r\n}\r\nstatic int bf5xx_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int bf5xx_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct sport_device *sport = runtime->private_data;\r\nint period_bytes = frames_to_bytes(runtime, runtime->period_size);\r\nstruct bf5xx_i2s_pcm_data *dma_data;\r\ndma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nif (dma_data->tdm_mode)\r\nperiod_bytes = period_bytes / runtime->channels * 8;\r\npr_debug("%s enter\n", __func__);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nsport_set_tx_callback(sport, bf5xx_dma_irq, substream);\r\nsport_config_tx_dma(sport, runtime->dma_area,\r\nruntime->periods, period_bytes);\r\n} else {\r\nsport_set_rx_callback(sport, bf5xx_dma_irq, substream);\r\nsport_config_rx_dma(sport, runtime->dma_area,\r\nruntime->periods, period_bytes);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bf5xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct sport_device *sport = runtime->private_data;\r\nint ret = 0;\r\npr_debug("%s enter\n", __func__);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nsport_tx_start(sport);\r\nelse\r\nsport_rx_start(sport);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nsport_tx_stop(sport);\r\nelse\r\nsport_rx_stop(sport);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic snd_pcm_uframes_t bf5xx_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct sport_device *sport = runtime->private_data;\r\nunsigned int diff;\r\nsnd_pcm_uframes_t frames;\r\nstruct bf5xx_i2s_pcm_data *dma_data;\r\ndma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\npr_debug("%s enter\n", __func__);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ndiff = sport_curr_offset_tx(sport);\r\n} else {\r\ndiff = sport_curr_offset_rx(sport);\r\n}\r\nif (diff == snd_pcm_lib_buffer_bytes(substream))\r\ndiff = 0;\r\nframes = bytes_to_frames(substream->runtime, diff);\r\nif (dma_data->tdm_mode)\r\nframes = frames * runtime->channels / 8;\r\nreturn frames;\r\n}\r\nstatic int bf5xx_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *cpu_dai = rtd->cpu_dai;\r\nstruct sport_device *sport_handle = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_dma_buffer *buf = &substream->dma_buffer;\r\nstruct bf5xx_i2s_pcm_data *dma_data;\r\nint ret;\r\ndma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\npr_debug("%s enter\n", __func__);\r\nsnd_soc_set_runtime_hwparams(substream, &bf5xx_pcm_hardware);\r\nif (dma_data->tdm_mode)\r\nruntime->hw.buffer_bytes_max /= 4;\r\nelse\r\nruntime->hw.info |= SNDRV_PCM_INFO_MMAP;\r\nret = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret < 0)\r\ngoto out;\r\nif (sport_handle != NULL) {\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nsport_handle->tx_buf = buf->area;\r\nelse\r\nsport_handle->rx_buf = buf->area;\r\nruntime->private_data = sport_handle;\r\n} else {\r\npr_err("sport_handle is NULL\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int bf5xx_pcm_mmap(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsize_t size = vma->vm_end - vma->vm_start;\r\nvma->vm_start = (unsigned long)runtime->dma_area;\r\nvma->vm_end = vma->vm_start + size;\r\nvma->vm_flags |= VM_SHARED;\r\nreturn 0 ;\r\n}\r\nstatic int bf5xx_pcm_copy(struct snd_pcm_substream *substream, int channel,\r\nsnd_pcm_uframes_t pos, void *buf, snd_pcm_uframes_t count)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int sample_size = runtime->sample_bits / 8;\r\nstruct bf5xx_i2s_pcm_data *dma_data;\r\nunsigned int i;\r\nvoid *src, *dst;\r\ndma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nif (dma_data->tdm_mode) {\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nsrc = buf;\r\ndst = runtime->dma_area;\r\ndst += pos * sample_size * 8;\r\nwhile (count--) {\r\nfor (i = 0; i < runtime->channels; i++) {\r\nmemcpy(dst + dma_data->map[i] *\r\nsample_size, src, sample_size);\r\nsrc += sample_size;\r\n}\r\ndst += 8 * sample_size;\r\n}\r\n} else {\r\nsrc = runtime->dma_area;\r\nsrc += pos * sample_size * 8;\r\ndst = buf;\r\nwhile (count--) {\r\nfor (i = 0; i < runtime->channels; i++) {\r\nmemcpy(dst, src + dma_data->map[i] *\r\nsample_size, sample_size);\r\ndst += sample_size;\r\n}\r\nsrc += 8 * sample_size;\r\n}\r\n}\r\n} else {\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nsrc = buf;\r\ndst = runtime->dma_area;\r\ndst += frames_to_bytes(runtime, pos);\r\n} else {\r\nsrc = runtime->dma_area;\r\nsrc += frames_to_bytes(runtime, pos);\r\ndst = buf;\r\n}\r\nmemcpy(dst, src, frames_to_bytes(runtime, count));\r\n}\r\nreturn 0;\r\n}\r\nstatic int bf5xx_pcm_silence(struct snd_pcm_substream *substream,\r\nint channel, snd_pcm_uframes_t pos, snd_pcm_uframes_t count)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int sample_size = runtime->sample_bits / 8;\r\nvoid *buf = runtime->dma_area;\r\nstruct bf5xx_i2s_pcm_data *dma_data;\r\nunsigned int offset, samples;\r\ndma_data = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nif (dma_data->tdm_mode) {\r\noffset = pos * 8 * sample_size;\r\nsamples = count * 8;\r\n} else {\r\noffset = frames_to_bytes(runtime, pos);\r\nsamples = count * runtime->channels;\r\n}\r\nsnd_pcm_format_set_silence(runtime->format, buf + offset, samples);\r\nreturn 0;\r\n}\r\nstatic int bf5xx_pcm_i2s_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_card *card = rtd->card->snd_card;\r\nsize_t size = bf5xx_pcm_hardware.buffer_bytes_max;\r\nint ret;\r\npr_debug("%s enter\n", __func__);\r\nret = dma_coerce_mask_and_coherent(card->dev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\nreturn snd_pcm_lib_preallocate_pages_for_all(rtd->pcm,\r\nSNDRV_DMA_TYPE_DEV, card->dev, size, size);\r\n}\r\nstatic int bfin_i2s_soc_platform_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_platform(&pdev->dev, &bf5xx_i2s_soc_platform);\r\n}\r\nstatic int bfin_i2s_soc_platform_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nreturn 0;\r\n}
