static void zlib_comp_exit(struct zlib_ctx *ctx)\r\n{\r\nstruct z_stream_s *stream = &ctx->comp_stream;\r\nif (stream->workspace) {\r\nzlib_deflateEnd(stream);\r\nvfree(stream->workspace);\r\nstream->workspace = NULL;\r\n}\r\n}\r\nstatic void zlib_decomp_exit(struct zlib_ctx *ctx)\r\n{\r\nstruct z_stream_s *stream = &ctx->decomp_stream;\r\nif (stream->workspace) {\r\nzlib_inflateEnd(stream);\r\nvfree(stream->workspace);\r\nstream->workspace = NULL;\r\n}\r\n}\r\nstatic int zlib_init(struct crypto_tfm *tfm)\r\n{\r\nreturn 0;\r\n}\r\nstatic void zlib_exit(struct crypto_tfm *tfm)\r\n{\r\nstruct zlib_ctx *ctx = crypto_tfm_ctx(tfm);\r\nzlib_comp_exit(ctx);\r\nzlib_decomp_exit(ctx);\r\n}\r\nstatic int zlib_compress_setup(struct crypto_pcomp *tfm, void *params,\r\nunsigned int len)\r\n{\r\nstruct zlib_ctx *ctx = crypto_tfm_ctx(crypto_pcomp_tfm(tfm));\r\nstruct z_stream_s *stream = &ctx->comp_stream;\r\nstruct nlattr *tb[ZLIB_COMP_MAX + 1];\r\nint window_bits, mem_level;\r\nsize_t workspacesize;\r\nint ret;\r\nret = nla_parse(tb, ZLIB_COMP_MAX, params, len, NULL);\r\nif (ret)\r\nreturn ret;\r\nzlib_comp_exit(ctx);\r\nwindow_bits = tb[ZLIB_COMP_WINDOWBITS]\r\n? nla_get_u32(tb[ZLIB_COMP_WINDOWBITS])\r\n: MAX_WBITS;\r\nmem_level = tb[ZLIB_COMP_MEMLEVEL]\r\n? nla_get_u32(tb[ZLIB_COMP_MEMLEVEL])\r\n: DEF_MEM_LEVEL;\r\nworkspacesize = zlib_deflate_workspacesize(window_bits, mem_level);\r\nstream->workspace = vzalloc(workspacesize);\r\nif (!stream->workspace)\r\nreturn -ENOMEM;\r\nret = zlib_deflateInit2(stream,\r\ntb[ZLIB_COMP_LEVEL]\r\n? nla_get_u32(tb[ZLIB_COMP_LEVEL])\r\n: Z_DEFAULT_COMPRESSION,\r\ntb[ZLIB_COMP_METHOD]\r\n? nla_get_u32(tb[ZLIB_COMP_METHOD])\r\n: Z_DEFLATED,\r\nwindow_bits,\r\nmem_level,\r\ntb[ZLIB_COMP_STRATEGY]\r\n? nla_get_u32(tb[ZLIB_COMP_STRATEGY])\r\n: Z_DEFAULT_STRATEGY);\r\nif (ret != Z_OK) {\r\nvfree(stream->workspace);\r\nstream->workspace = NULL;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zlib_compress_init(struct crypto_pcomp *tfm)\r\n{\r\nint ret;\r\nstruct zlib_ctx *dctx = crypto_tfm_ctx(crypto_pcomp_tfm(tfm));\r\nstruct z_stream_s *stream = &dctx->comp_stream;\r\nret = zlib_deflateReset(stream);\r\nif (ret != Z_OK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int zlib_compress_update(struct crypto_pcomp *tfm,\r\nstruct comp_request *req)\r\n{\r\nint ret;\r\nstruct zlib_ctx *dctx = crypto_tfm_ctx(crypto_pcomp_tfm(tfm));\r\nstruct z_stream_s *stream = &dctx->comp_stream;\r\npr_debug("avail_in %u, avail_out %u\n", req->avail_in, req->avail_out);\r\nstream->next_in = req->next_in;\r\nstream->avail_in = req->avail_in;\r\nstream->next_out = req->next_out;\r\nstream->avail_out = req->avail_out;\r\nret = zlib_deflate(stream, Z_NO_FLUSH);\r\nswitch (ret) {\r\ncase Z_OK:\r\nbreak;\r\ncase Z_BUF_ERROR:\r\npr_debug("zlib_deflate could not make progress\n");\r\nreturn -EAGAIN;\r\ndefault:\r\npr_debug("zlib_deflate failed %d\n", ret);\r\nreturn -EINVAL;\r\n}\r\nret = req->avail_out - stream->avail_out;\r\npr_debug("avail_in %lu, avail_out %lu (consumed %lu, produced %u)\n",\r\nstream->avail_in, stream->avail_out,\r\nreq->avail_in - stream->avail_in, ret);\r\nreq->next_in = stream->next_in;\r\nreq->avail_in = stream->avail_in;\r\nreq->next_out = stream->next_out;\r\nreq->avail_out = stream->avail_out;\r\nreturn ret;\r\n}\r\nstatic int zlib_compress_final(struct crypto_pcomp *tfm,\r\nstruct comp_request *req)\r\n{\r\nint ret;\r\nstruct zlib_ctx *dctx = crypto_tfm_ctx(crypto_pcomp_tfm(tfm));\r\nstruct z_stream_s *stream = &dctx->comp_stream;\r\npr_debug("avail_in %u, avail_out %u\n", req->avail_in, req->avail_out);\r\nstream->next_in = req->next_in;\r\nstream->avail_in = req->avail_in;\r\nstream->next_out = req->next_out;\r\nstream->avail_out = req->avail_out;\r\nret = zlib_deflate(stream, Z_FINISH);\r\nif (ret != Z_STREAM_END) {\r\npr_debug("zlib_deflate failed %d\n", ret);\r\nreturn -EINVAL;\r\n}\r\nret = req->avail_out - stream->avail_out;\r\npr_debug("avail_in %lu, avail_out %lu (consumed %lu, produced %u)\n",\r\nstream->avail_in, stream->avail_out,\r\nreq->avail_in - stream->avail_in, ret);\r\nreq->next_in = stream->next_in;\r\nreq->avail_in = stream->avail_in;\r\nreq->next_out = stream->next_out;\r\nreq->avail_out = stream->avail_out;\r\nreturn ret;\r\n}\r\nstatic int zlib_decompress_setup(struct crypto_pcomp *tfm, void *params,\r\nunsigned int len)\r\n{\r\nstruct zlib_ctx *ctx = crypto_tfm_ctx(crypto_pcomp_tfm(tfm));\r\nstruct z_stream_s *stream = &ctx->decomp_stream;\r\nstruct nlattr *tb[ZLIB_DECOMP_MAX + 1];\r\nint ret = 0;\r\nret = nla_parse(tb, ZLIB_DECOMP_MAX, params, len, NULL);\r\nif (ret)\r\nreturn ret;\r\nzlib_decomp_exit(ctx);\r\nctx->decomp_windowBits = tb[ZLIB_DECOMP_WINDOWBITS]\r\n? nla_get_u32(tb[ZLIB_DECOMP_WINDOWBITS])\r\n: DEF_WBITS;\r\nstream->workspace = vzalloc(zlib_inflate_workspacesize());\r\nif (!stream->workspace)\r\nreturn -ENOMEM;\r\nret = zlib_inflateInit2(stream, ctx->decomp_windowBits);\r\nif (ret != Z_OK) {\r\nvfree(stream->workspace);\r\nstream->workspace = NULL;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zlib_decompress_init(struct crypto_pcomp *tfm)\r\n{\r\nint ret;\r\nstruct zlib_ctx *dctx = crypto_tfm_ctx(crypto_pcomp_tfm(tfm));\r\nstruct z_stream_s *stream = &dctx->decomp_stream;\r\nret = zlib_inflateReset(stream);\r\nif (ret != Z_OK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int zlib_decompress_update(struct crypto_pcomp *tfm,\r\nstruct comp_request *req)\r\n{\r\nint ret;\r\nstruct zlib_ctx *dctx = crypto_tfm_ctx(crypto_pcomp_tfm(tfm));\r\nstruct z_stream_s *stream = &dctx->decomp_stream;\r\npr_debug("avail_in %u, avail_out %u\n", req->avail_in, req->avail_out);\r\nstream->next_in = req->next_in;\r\nstream->avail_in = req->avail_in;\r\nstream->next_out = req->next_out;\r\nstream->avail_out = req->avail_out;\r\nret = zlib_inflate(stream, Z_SYNC_FLUSH);\r\nswitch (ret) {\r\ncase Z_OK:\r\ncase Z_STREAM_END:\r\nbreak;\r\ncase Z_BUF_ERROR:\r\npr_debug("zlib_inflate could not make progress\n");\r\nreturn -EAGAIN;\r\ndefault:\r\npr_debug("zlib_inflate failed %d\n", ret);\r\nreturn -EINVAL;\r\n}\r\nret = req->avail_out - stream->avail_out;\r\npr_debug("avail_in %lu, avail_out %lu (consumed %lu, produced %u)\n",\r\nstream->avail_in, stream->avail_out,\r\nreq->avail_in - stream->avail_in, ret);\r\nreq->next_in = stream->next_in;\r\nreq->avail_in = stream->avail_in;\r\nreq->next_out = stream->next_out;\r\nreq->avail_out = stream->avail_out;\r\nreturn ret;\r\n}\r\nstatic int zlib_decompress_final(struct crypto_pcomp *tfm,\r\nstruct comp_request *req)\r\n{\r\nint ret;\r\nstruct zlib_ctx *dctx = crypto_tfm_ctx(crypto_pcomp_tfm(tfm));\r\nstruct z_stream_s *stream = &dctx->decomp_stream;\r\npr_debug("avail_in %u, avail_out %u\n", req->avail_in, req->avail_out);\r\nstream->next_in = req->next_in;\r\nstream->avail_in = req->avail_in;\r\nstream->next_out = req->next_out;\r\nstream->avail_out = req->avail_out;\r\nif (dctx->decomp_windowBits < 0) {\r\nret = zlib_inflate(stream, Z_SYNC_FLUSH);\r\nif (ret == Z_OK && !stream->avail_in && stream->avail_out) {\r\nconst void *saved_next_in = stream->next_in;\r\nu8 zerostuff = 0;\r\nstream->next_in = &zerostuff;\r\nstream->avail_in = 1;\r\nret = zlib_inflate(stream, Z_FINISH);\r\nstream->next_in = saved_next_in;\r\nstream->avail_in = 0;\r\n}\r\n} else\r\nret = zlib_inflate(stream, Z_FINISH);\r\nif (ret != Z_STREAM_END) {\r\npr_debug("zlib_inflate failed %d\n", ret);\r\nreturn -EINVAL;\r\n}\r\nret = req->avail_out - stream->avail_out;\r\npr_debug("avail_in %lu, avail_out %lu (consumed %lu, produced %u)\n",\r\nstream->avail_in, stream->avail_out,\r\nreq->avail_in - stream->avail_in, ret);\r\nreq->next_in = stream->next_in;\r\nreq->avail_in = stream->avail_in;\r\nreq->next_out = stream->next_out;\r\nreq->avail_out = stream->avail_out;\r\nreturn ret;\r\n}\r\nstatic int __init zlib_mod_init(void)\r\n{\r\nreturn crypto_register_pcomp(&zlib_alg);\r\n}\r\nstatic void __exit zlib_mod_fini(void)\r\n{\r\ncrypto_unregister_pcomp(&zlib_alg);\r\n}
