static inline struct pci_dev *ctrl_dev(struct controller *ctrl)\r\n{\r\nreturn ctrl->pcie->port;\r\n}\r\nstatic void int_poll_timeout(unsigned long data)\r\n{\r\nstruct controller *ctrl = (struct controller *)data;\r\npcie_isr(0, ctrl);\r\ninit_timer(&ctrl->poll_timer);\r\nif (!pciehp_poll_time)\r\npciehp_poll_time = 2;\r\nstart_int_poll_timer(ctrl, pciehp_poll_time);\r\n}\r\nstatic void start_int_poll_timer(struct controller *ctrl, int sec)\r\n{\r\nif ((sec <= 0) || (sec > 60))\r\nsec = 2;\r\nctrl->poll_timer.function = &int_poll_timeout;\r\nctrl->poll_timer.data = (unsigned long)ctrl;\r\nctrl->poll_timer.expires = jiffies + sec * HZ;\r\nadd_timer(&ctrl->poll_timer);\r\n}\r\nstatic inline int pciehp_request_irq(struct controller *ctrl)\r\n{\r\nint retval, irq = ctrl->pcie->irq;\r\nif (pciehp_poll_mode) {\r\ninit_timer(&ctrl->poll_timer);\r\nstart_int_poll_timer(ctrl, 10);\r\nreturn 0;\r\n}\r\nretval = request_irq(irq, pcie_isr, IRQF_SHARED, MY_NAME, ctrl);\r\nif (retval)\r\nctrl_err(ctrl, "Cannot get irq %d for the hotplug controller\n",\r\nirq);\r\nreturn retval;\r\n}\r\nstatic inline void pciehp_free_irq(struct controller *ctrl)\r\n{\r\nif (pciehp_poll_mode)\r\ndel_timer_sync(&ctrl->poll_timer);\r\nelse\r\nfree_irq(ctrl->pcie->irq, ctrl);\r\n}\r\nstatic int pcie_poll_cmd(struct controller *ctrl, int timeout)\r\n{\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nu16 slot_status;\r\npcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);\r\nif (slot_status & PCI_EXP_SLTSTA_CC) {\r\npcie_capability_write_word(pdev, PCI_EXP_SLTSTA,\r\nPCI_EXP_SLTSTA_CC);\r\nreturn 1;\r\n}\r\nwhile (timeout > 0) {\r\nmsleep(10);\r\ntimeout -= 10;\r\npcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);\r\nif (slot_status & PCI_EXP_SLTSTA_CC) {\r\npcie_capability_write_word(pdev, PCI_EXP_SLTSTA,\r\nPCI_EXP_SLTSTA_CC);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcie_wait_cmd(struct controller *ctrl)\r\n{\r\nunsigned int msecs = pciehp_poll_mode ? 2500 : 1000;\r\nunsigned long duration = msecs_to_jiffies(msecs);\r\nunsigned long cmd_timeout = ctrl->cmd_started + duration;\r\nunsigned long now, timeout;\r\nint rc;\r\nif (NO_CMD_CMPL(ctrl))\r\nreturn;\r\nif (!ctrl->cmd_busy)\r\nreturn;\r\nnow = jiffies;\r\nif (time_before_eq(cmd_timeout, now))\r\ntimeout = 1;\r\nelse\r\ntimeout = cmd_timeout - now;\r\nif (ctrl->slot_ctrl & PCI_EXP_SLTCTL_HPIE &&\r\nctrl->slot_ctrl & PCI_EXP_SLTCTL_CCIE)\r\nrc = wait_event_timeout(ctrl->queue, !ctrl->cmd_busy, timeout);\r\nelse\r\nrc = pcie_poll_cmd(ctrl, jiffies_to_msecs(timeout));\r\nif (!rc)\r\nctrl_info(ctrl, "Timeout on hotplug command %#06x (issued %u msec ago)\n",\r\nctrl->slot_ctrl,\r\njiffies_to_msecs(jiffies - ctrl->cmd_started));\r\n}\r\nstatic void pcie_write_cmd(struct controller *ctrl, u16 cmd, u16 mask)\r\n{\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nu16 slot_ctrl;\r\nmutex_lock(&ctrl->ctrl_lock);\r\npcie_wait_cmd(ctrl);\r\npcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &slot_ctrl);\r\nslot_ctrl &= ~mask;\r\nslot_ctrl |= (cmd & mask);\r\nctrl->cmd_busy = 1;\r\nsmp_mb();\r\npcie_capability_write_word(pdev, PCI_EXP_SLTCTL, slot_ctrl);\r\nctrl->cmd_started = jiffies;\r\nctrl->slot_ctrl = slot_ctrl;\r\nmutex_unlock(&ctrl->ctrl_lock);\r\n}\r\nbool pciehp_check_link_active(struct controller *ctrl)\r\n{\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nu16 lnk_status;\r\nbool ret;\r\npcie_capability_read_word(pdev, PCI_EXP_LNKSTA, &lnk_status);\r\nret = !!(lnk_status & PCI_EXP_LNKSTA_DLLLA);\r\nif (ret)\r\nctrl_dbg(ctrl, "%s: lnk_status = %x\n", __func__, lnk_status);\r\nreturn ret;\r\n}\r\nstatic void __pcie_wait_link_active(struct controller *ctrl, bool active)\r\n{\r\nint timeout = 1000;\r\nif (pciehp_check_link_active(ctrl) == active)\r\nreturn;\r\nwhile (timeout > 0) {\r\nmsleep(10);\r\ntimeout -= 10;\r\nif (pciehp_check_link_active(ctrl) == active)\r\nreturn;\r\n}\r\nctrl_dbg(ctrl, "Data Link Layer Link Active not %s in 1000 msec\n",\r\nactive ? "set" : "cleared");\r\n}\r\nstatic void pcie_wait_link_active(struct controller *ctrl)\r\n{\r\n__pcie_wait_link_active(ctrl, true);\r\n}\r\nstatic bool pci_bus_check_dev(struct pci_bus *bus, int devfn)\r\n{\r\nu32 l;\r\nint count = 0;\r\nint delay = 1000, step = 20;\r\nbool found = false;\r\ndo {\r\nfound = pci_bus_read_dev_vendor_id(bus, devfn, &l, 0);\r\ncount++;\r\nif (found)\r\nbreak;\r\nmsleep(step);\r\ndelay -= step;\r\n} while (delay > 0);\r\nif (count > 1 && pciehp_debug)\r\nprintk(KERN_DEBUG "pci %04x:%02x:%02x.%d id reading try %d times with interval %d ms to get %08x\n",\r\npci_domain_nr(bus), bus->number, PCI_SLOT(devfn),\r\nPCI_FUNC(devfn), count, step, l);\r\nreturn found;\r\n}\r\nint pciehp_check_link_status(struct controller *ctrl)\r\n{\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nbool found;\r\nu16 lnk_status;\r\nif (ctrl->link_active_reporting)\r\npcie_wait_link_active(ctrl);\r\nelse\r\nmsleep(1000);\r\nmsleep(100);\r\nfound = pci_bus_check_dev(ctrl->pcie->port->subordinate,\r\nPCI_DEVFN(0, 0));\r\npcie_capability_read_word(pdev, PCI_EXP_LNKSTA, &lnk_status);\r\nctrl_dbg(ctrl, "%s: lnk_status = %x\n", __func__, lnk_status);\r\nif ((lnk_status & PCI_EXP_LNKSTA_LT) ||\r\n!(lnk_status & PCI_EXP_LNKSTA_NLW)) {\r\nctrl_err(ctrl, "Link Training Error occurs\n");\r\nreturn -1;\r\n}\r\npcie_update_link_speed(ctrl->pcie->port->subordinate, lnk_status);\r\nif (!found)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int __pciehp_link_set(struct controller *ctrl, bool enable)\r\n{\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nu16 lnk_ctrl;\r\npcie_capability_read_word(pdev, PCI_EXP_LNKCTL, &lnk_ctrl);\r\nif (enable)\r\nlnk_ctrl &= ~PCI_EXP_LNKCTL_LD;\r\nelse\r\nlnk_ctrl |= PCI_EXP_LNKCTL_LD;\r\npcie_capability_write_word(pdev, PCI_EXP_LNKCTL, lnk_ctrl);\r\nctrl_dbg(ctrl, "%s: lnk_ctrl = %x\n", __func__, lnk_ctrl);\r\nreturn 0;\r\n}\r\nstatic int pciehp_link_enable(struct controller *ctrl)\r\n{\r\nreturn __pciehp_link_set(ctrl, true);\r\n}\r\nvoid pciehp_get_attention_status(struct slot *slot, u8 *status)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nu16 slot_ctrl;\r\npcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &slot_ctrl);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x, value read %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_ctrl);\r\nswitch (slot_ctrl & PCI_EXP_SLTCTL_AIC) {\r\ncase PCI_EXP_SLTCTL_ATTN_IND_ON:\r\n*status = 1;\r\nbreak;\r\ncase PCI_EXP_SLTCTL_ATTN_IND_BLINK:\r\n*status = 2;\r\nbreak;\r\ncase PCI_EXP_SLTCTL_ATTN_IND_OFF:\r\n*status = 0;\r\nbreak;\r\ndefault:\r\n*status = 0xFF;\r\nbreak;\r\n}\r\n}\r\nvoid pciehp_get_power_status(struct slot *slot, u8 *status)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nu16 slot_ctrl;\r\npcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &slot_ctrl);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x value read %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_ctrl);\r\nswitch (slot_ctrl & PCI_EXP_SLTCTL_PCC) {\r\ncase PCI_EXP_SLTCTL_PWR_ON:\r\n*status = 1;\r\nbreak;\r\ncase PCI_EXP_SLTCTL_PWR_OFF:\r\n*status = 0;\r\nbreak;\r\ndefault:\r\n*status = 0xFF;\r\nbreak;\r\n}\r\n}\r\nvoid pciehp_get_latch_status(struct slot *slot, u8 *status)\r\n{\r\nstruct pci_dev *pdev = ctrl_dev(slot->ctrl);\r\nu16 slot_status;\r\npcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);\r\n*status = !!(slot_status & PCI_EXP_SLTSTA_MRLSS);\r\n}\r\nvoid pciehp_get_adapter_status(struct slot *slot, u8 *status)\r\n{\r\nstruct pci_dev *pdev = ctrl_dev(slot->ctrl);\r\nu16 slot_status;\r\npcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);\r\n*status = !!(slot_status & PCI_EXP_SLTSTA_PDS);\r\n}\r\nint pciehp_query_power_fault(struct slot *slot)\r\n{\r\nstruct pci_dev *pdev = ctrl_dev(slot->ctrl);\r\nu16 slot_status;\r\npcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);\r\nreturn !!(slot_status & PCI_EXP_SLTSTA_PFD);\r\n}\r\nvoid pciehp_set_attention_status(struct slot *slot, u8 value)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu16 slot_cmd;\r\nif (!ATTN_LED(ctrl))\r\nreturn;\r\nswitch (value) {\r\ncase 0:\r\nslot_cmd = PCI_EXP_SLTCTL_ATTN_IND_OFF;\r\nbreak;\r\ncase 1:\r\nslot_cmd = PCI_EXP_SLTCTL_ATTN_IND_ON;\r\nbreak;\r\ncase 2:\r\nslot_cmd = PCI_EXP_SLTCTL_ATTN_IND_BLINK;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\npcie_write_cmd(ctrl, slot_cmd, PCI_EXP_SLTCTL_AIC);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_cmd);\r\n}\r\nvoid pciehp_green_led_on(struct slot *slot)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nif (!PWR_LED(ctrl))\r\nreturn;\r\npcie_write_cmd(ctrl, PCI_EXP_SLTCTL_PWR_IND_ON, PCI_EXP_SLTCTL_PIC);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL,\r\nPCI_EXP_SLTCTL_PWR_IND_ON);\r\n}\r\nvoid pciehp_green_led_off(struct slot *slot)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nif (!PWR_LED(ctrl))\r\nreturn;\r\npcie_write_cmd(ctrl, PCI_EXP_SLTCTL_PWR_IND_OFF, PCI_EXP_SLTCTL_PIC);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL,\r\nPCI_EXP_SLTCTL_PWR_IND_OFF);\r\n}\r\nvoid pciehp_green_led_blink(struct slot *slot)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nif (!PWR_LED(ctrl))\r\nreturn;\r\npcie_write_cmd(ctrl, PCI_EXP_SLTCTL_PWR_IND_BLINK, PCI_EXP_SLTCTL_PIC);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL,\r\nPCI_EXP_SLTCTL_PWR_IND_BLINK);\r\n}\r\nint pciehp_power_on_slot(struct slot *slot)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nu16 slot_status;\r\nint retval;\r\npcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);\r\nif (slot_status & PCI_EXP_SLTSTA_PFD)\r\npcie_capability_write_word(pdev, PCI_EXP_SLTSTA,\r\nPCI_EXP_SLTSTA_PFD);\r\nctrl->power_fault_detected = 0;\r\npcie_write_cmd(ctrl, PCI_EXP_SLTCTL_PWR_ON, PCI_EXP_SLTCTL_PCC);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL,\r\nPCI_EXP_SLTCTL_PWR_ON);\r\nretval = pciehp_link_enable(ctrl);\r\nif (retval)\r\nctrl_err(ctrl, "%s: Can not enable the link!\n", __func__);\r\nreturn retval;\r\n}\r\nvoid pciehp_power_off_slot(struct slot *slot)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\npcie_write_cmd(ctrl, PCI_EXP_SLTCTL_PWR_OFF, PCI_EXP_SLTCTL_PCC);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL,\r\nPCI_EXP_SLTCTL_PWR_OFF);\r\n}\r\nstatic irqreturn_t pcie_isr(int irq, void *dev_id)\r\n{\r\nstruct controller *ctrl = (struct controller *)dev_id;\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nstruct pci_bus *subordinate = pdev->subordinate;\r\nstruct pci_dev *dev;\r\nstruct slot *slot = ctrl->slot;\r\nu16 detected, intr_loc;\r\nintr_loc = 0;\r\ndo {\r\npcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &detected);\r\ndetected &= (PCI_EXP_SLTSTA_ABP | PCI_EXP_SLTSTA_PFD |\r\nPCI_EXP_SLTSTA_MRLSC | PCI_EXP_SLTSTA_PDC |\r\nPCI_EXP_SLTSTA_CC | PCI_EXP_SLTSTA_DLLSC);\r\ndetected &= ~intr_loc;\r\nintr_loc |= detected;\r\nif (!intr_loc)\r\nreturn IRQ_NONE;\r\nif (detected)\r\npcie_capability_write_word(pdev, PCI_EXP_SLTSTA,\r\nintr_loc);\r\n} while (detected);\r\nctrl_dbg(ctrl, "%s: intr_loc %x\n", __func__, intr_loc);\r\nif (intr_loc & PCI_EXP_SLTSTA_CC) {\r\nctrl->cmd_busy = 0;\r\nsmp_mb();\r\nwake_up(&ctrl->queue);\r\n}\r\nif (subordinate) {\r\nlist_for_each_entry(dev, &subordinate->devices, bus_list) {\r\nif (dev->ignore_hotplug) {\r\nctrl_dbg(ctrl, "ignoring hotplug event %#06x (%s requested no hotplug)\n",\r\nintr_loc, pci_name(dev));\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\n}\r\nif (!(intr_loc & ~PCI_EXP_SLTSTA_CC))\r\nreturn IRQ_HANDLED;\r\nif (intr_loc & PCI_EXP_SLTSTA_MRLSC)\r\npciehp_handle_switch_change(slot);\r\nif (intr_loc & PCI_EXP_SLTSTA_ABP)\r\npciehp_handle_attention_button(slot);\r\nif (intr_loc & PCI_EXP_SLTSTA_PDC)\r\npciehp_handle_presence_change(slot);\r\nif ((intr_loc & PCI_EXP_SLTSTA_PFD) && !ctrl->power_fault_detected) {\r\nctrl->power_fault_detected = 1;\r\npciehp_handle_power_fault(slot);\r\n}\r\nif (intr_loc & PCI_EXP_SLTSTA_DLLSC)\r\npciehp_handle_linkstate_change(slot);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid pcie_enable_notification(struct controller *ctrl)\r\n{\r\nu16 cmd, mask;\r\ncmd = PCI_EXP_SLTCTL_DLLSCE;\r\nif (ATTN_BUTTN(ctrl))\r\ncmd |= PCI_EXP_SLTCTL_ABPE;\r\nelse\r\ncmd |= PCI_EXP_SLTCTL_PDCE;\r\nif (MRL_SENS(ctrl))\r\ncmd |= PCI_EXP_SLTCTL_MRLSCE;\r\nif (!pciehp_poll_mode)\r\ncmd |= PCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_CCIE;\r\nmask = (PCI_EXP_SLTCTL_PDCE | PCI_EXP_SLTCTL_ABPE |\r\nPCI_EXP_SLTCTL_MRLSCE | PCI_EXP_SLTCTL_PFDE |\r\nPCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_CCIE |\r\nPCI_EXP_SLTCTL_DLLSCE);\r\npcie_write_cmd(ctrl, cmd, mask);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, cmd);\r\n}\r\nstatic void pcie_disable_notification(struct controller *ctrl)\r\n{\r\nu16 mask;\r\nmask = (PCI_EXP_SLTCTL_PDCE | PCI_EXP_SLTCTL_ABPE |\r\nPCI_EXP_SLTCTL_MRLSCE | PCI_EXP_SLTCTL_PFDE |\r\nPCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_CCIE |\r\nPCI_EXP_SLTCTL_DLLSCE);\r\npcie_write_cmd(ctrl, 0, mask);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, 0);\r\n}\r\nint pciehp_reset_slot(struct slot *slot, int probe)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nu16 stat_mask = 0, ctrl_mask = 0;\r\nif (probe)\r\nreturn 0;\r\nif (!ATTN_BUTTN(ctrl)) {\r\nctrl_mask |= PCI_EXP_SLTCTL_PDCE;\r\nstat_mask |= PCI_EXP_SLTSTA_PDC;\r\n}\r\nctrl_mask |= PCI_EXP_SLTCTL_DLLSCE;\r\nstat_mask |= PCI_EXP_SLTSTA_DLLSC;\r\npcie_write_cmd(ctrl, 0, ctrl_mask);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, 0);\r\nif (pciehp_poll_mode)\r\ndel_timer_sync(&ctrl->poll_timer);\r\npci_reset_bridge_secondary_bus(ctrl->pcie->port);\r\npcie_capability_write_word(pdev, PCI_EXP_SLTSTA, stat_mask);\r\npcie_write_cmd(ctrl, ctrl_mask, ctrl_mask);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, ctrl_mask);\r\nif (pciehp_poll_mode)\r\nint_poll_timeout(ctrl->poll_timer.data);\r\nreturn 0;\r\n}\r\nint pcie_init_notification(struct controller *ctrl)\r\n{\r\nif (pciehp_request_irq(ctrl))\r\nreturn -1;\r\npcie_enable_notification(ctrl);\r\nctrl->notification_enabled = 1;\r\nreturn 0;\r\n}\r\nstatic void pcie_shutdown_notification(struct controller *ctrl)\r\n{\r\nif (ctrl->notification_enabled) {\r\npcie_disable_notification(ctrl);\r\npciehp_free_irq(ctrl);\r\nctrl->notification_enabled = 0;\r\n}\r\n}\r\nstatic int pcie_init_slot(struct controller *ctrl)\r\n{\r\nstruct slot *slot;\r\nslot = kzalloc(sizeof(*slot), GFP_KERNEL);\r\nif (!slot)\r\nreturn -ENOMEM;\r\nslot->wq = alloc_workqueue("pciehp-%u", 0, 0, PSN(ctrl));\r\nif (!slot->wq)\r\ngoto abort;\r\nslot->ctrl = ctrl;\r\nmutex_init(&slot->lock);\r\nmutex_init(&slot->hotplug_lock);\r\nINIT_DELAYED_WORK(&slot->work, pciehp_queue_pushbutton_work);\r\nctrl->slot = slot;\r\nreturn 0;\r\nabort:\r\nkfree(slot);\r\nreturn -ENOMEM;\r\n}\r\nstatic void pcie_cleanup_slot(struct controller *ctrl)\r\n{\r\nstruct slot *slot = ctrl->slot;\r\ncancel_delayed_work(&slot->work);\r\ndestroy_workqueue(slot->wq);\r\nkfree(slot);\r\n}\r\nstatic inline void dbg_ctrl(struct controller *ctrl)\r\n{\r\nint i;\r\nu16 reg16;\r\nstruct pci_dev *pdev = ctrl->pcie->port;\r\nif (!pciehp_debug)\r\nreturn;\r\nctrl_info(ctrl, "Hotplug Controller:\n");\r\nctrl_info(ctrl, " Seg/Bus/Dev/Func/IRQ : %s IRQ %d\n",\r\npci_name(pdev), pdev->irq);\r\nctrl_info(ctrl, " Vendor ID : 0x%04x\n", pdev->vendor);\r\nctrl_info(ctrl, " Device ID : 0x%04x\n", pdev->device);\r\nctrl_info(ctrl, " Subsystem ID : 0x%04x\n",\r\npdev->subsystem_device);\r\nctrl_info(ctrl, " Subsystem Vendor ID : 0x%04x\n",\r\npdev->subsystem_vendor);\r\nctrl_info(ctrl, " PCIe Cap offset : 0x%02x\n",\r\npci_pcie_cap(pdev));\r\nfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\r\nif (!pci_resource_len(pdev, i))\r\ncontinue;\r\nctrl_info(ctrl, " PCI resource [%d] : %pR\n",\r\ni, &pdev->resource[i]);\r\n}\r\nctrl_info(ctrl, "Slot Capabilities : 0x%08x\n", ctrl->slot_cap);\r\nctrl_info(ctrl, " Physical Slot Number : %d\n", PSN(ctrl));\r\nctrl_info(ctrl, " Attention Button : %3s\n",\r\nATTN_BUTTN(ctrl) ? "yes" : "no");\r\nctrl_info(ctrl, " Power Controller : %3s\n",\r\nPOWER_CTRL(ctrl) ? "yes" : "no");\r\nctrl_info(ctrl, " MRL Sensor : %3s\n",\r\nMRL_SENS(ctrl) ? "yes" : "no");\r\nctrl_info(ctrl, " Attention Indicator : %3s\n",\r\nATTN_LED(ctrl) ? "yes" : "no");\r\nctrl_info(ctrl, " Power Indicator : %3s\n",\r\nPWR_LED(ctrl) ? "yes" : "no");\r\nctrl_info(ctrl, " Hot-Plug Surprise : %3s\n",\r\nHP_SUPR_RM(ctrl) ? "yes" : "no");\r\nctrl_info(ctrl, " EMI Present : %3s\n",\r\nEMI(ctrl) ? "yes" : "no");\r\nctrl_info(ctrl, " Command Completed : %3s\n",\r\nNO_CMD_CMPL(ctrl) ? "no" : "yes");\r\npcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &reg16);\r\nctrl_info(ctrl, "Slot Status : 0x%04x\n", reg16);\r\npcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &reg16);\r\nctrl_info(ctrl, "Slot Control : 0x%04x\n", reg16);\r\n}\r\nstruct controller *pcie_init(struct pcie_device *dev)\r\n{\r\nstruct controller *ctrl;\r\nu32 slot_cap, link_cap;\r\nstruct pci_dev *pdev = dev->port;\r\nctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL);\r\nif (!ctrl) {\r\ndev_err(&dev->device, "%s: Out of memory\n", __func__);\r\ngoto abort;\r\n}\r\nctrl->pcie = dev;\r\npcie_capability_read_dword(pdev, PCI_EXP_SLTCAP, &slot_cap);\r\nctrl->slot_cap = slot_cap;\r\nmutex_init(&ctrl->ctrl_lock);\r\ninit_waitqueue_head(&ctrl->queue);\r\ndbg_ctrl(ctrl);\r\npcie_capability_read_dword(pdev, PCI_EXP_LNKCAP, &link_cap);\r\nif (link_cap & PCI_EXP_LNKCAP_DLLLARC) {\r\nctrl_dbg(ctrl, "Link Active Reporting supported\n");\r\nctrl->link_active_reporting = 1;\r\n}\r\npcie_capability_write_word(pdev, PCI_EXP_SLTSTA,\r\nPCI_EXP_SLTSTA_ABP | PCI_EXP_SLTSTA_PFD |\r\nPCI_EXP_SLTSTA_MRLSC | PCI_EXP_SLTSTA_PDC |\r\nPCI_EXP_SLTSTA_CC | PCI_EXP_SLTSTA_DLLSC);\r\nctrl_info(ctrl, "Slot #%d AttnBtn%c AttnInd%c PwrInd%c PwrCtrl%c MRL%c Interlock%c NoCompl%c LLActRep%c\n",\r\n(slot_cap & PCI_EXP_SLTCAP_PSN) >> 19,\r\nFLAG(slot_cap, PCI_EXP_SLTCAP_ABP),\r\nFLAG(slot_cap, PCI_EXP_SLTCAP_AIP),\r\nFLAG(slot_cap, PCI_EXP_SLTCAP_PIP),\r\nFLAG(slot_cap, PCI_EXP_SLTCAP_PCP),\r\nFLAG(slot_cap, PCI_EXP_SLTCAP_MRLSP),\r\nFLAG(slot_cap, PCI_EXP_SLTCAP_EIP),\r\nFLAG(slot_cap, PCI_EXP_SLTCAP_NCCS),\r\nFLAG(link_cap, PCI_EXP_LNKCAP_DLLLARC));\r\nif (pcie_init_slot(ctrl))\r\ngoto abort_ctrl;\r\nreturn ctrl;\r\nabort_ctrl:\r\nkfree(ctrl);\r\nabort:\r\nreturn NULL;\r\n}\r\nvoid pciehp_release_ctrl(struct controller *ctrl)\r\n{\r\npcie_shutdown_notification(ctrl);\r\npcie_cleanup_slot(ctrl);\r\nkfree(ctrl);\r\n}
