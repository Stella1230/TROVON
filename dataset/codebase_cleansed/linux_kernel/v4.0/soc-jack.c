int snd_soc_jack_new(struct snd_soc_codec *codec, const char *id, int type,\r\nstruct snd_soc_jack *jack)\r\n{\r\nmutex_init(&jack->mutex);\r\njack->codec = codec;\r\nINIT_LIST_HEAD(&jack->pins);\r\nINIT_LIST_HEAD(&jack->jack_zones);\r\nBLOCKING_INIT_NOTIFIER_HEAD(&jack->notifier);\r\nreturn snd_jack_new(codec->component.card->snd_card, id, type, &jack->jack);\r\n}\r\nvoid snd_soc_jack_report(struct snd_soc_jack *jack, int status, int mask)\r\n{\r\nstruct snd_soc_codec *codec;\r\nstruct snd_soc_dapm_context *dapm;\r\nstruct snd_soc_jack_pin *pin;\r\nunsigned int sync = 0;\r\nint enable;\r\ntrace_snd_soc_jack_report(jack, mask, status);\r\nif (!jack)\r\nreturn;\r\ncodec = jack->codec;\r\ndapm = &codec->dapm;\r\nmutex_lock(&jack->mutex);\r\njack->status &= ~mask;\r\njack->status |= status & mask;\r\ntrace_snd_soc_jack_notify(jack, status);\r\nlist_for_each_entry(pin, &jack->pins, list) {\r\nenable = pin->mask & jack->status;\r\nif (pin->invert)\r\nenable = !enable;\r\nif (enable)\r\nsnd_soc_dapm_enable_pin(dapm, pin->pin);\r\nelse\r\nsnd_soc_dapm_disable_pin(dapm, pin->pin);\r\nsync = 1;\r\n}\r\nblocking_notifier_call_chain(&jack->notifier, jack->status, jack);\r\nif (sync)\r\nsnd_soc_dapm_sync(dapm);\r\nsnd_jack_report(jack->jack, jack->status);\r\nmutex_unlock(&jack->mutex);\r\n}\r\nint snd_soc_jack_add_zones(struct snd_soc_jack *jack, int count,\r\nstruct snd_soc_jack_zone *zones)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nINIT_LIST_HEAD(&zones[i].list);\r\nlist_add(&(zones[i].list), &jack->jack_zones);\r\n}\r\nreturn 0;\r\n}\r\nint snd_soc_jack_get_type(struct snd_soc_jack *jack, int micbias_voltage)\r\n{\r\nstruct snd_soc_jack_zone *zone;\r\nlist_for_each_entry(zone, &jack->jack_zones, list) {\r\nif (micbias_voltage >= zone->min_mv &&\r\nmicbias_voltage < zone->max_mv)\r\nreturn zone->jack_type;\r\n}\r\nreturn 0;\r\n}\r\nint snd_soc_jack_add_pins(struct snd_soc_jack *jack, int count,\r\nstruct snd_soc_jack_pin *pins)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nif (!pins[i].pin) {\r\ndev_err(jack->codec->dev, "ASoC: No name for pin %d\n",\r\ni);\r\nreturn -EINVAL;\r\n}\r\nif (!pins[i].mask) {\r\ndev_err(jack->codec->dev, "ASoC: No mask for pin %d"\r\n" (%s)\n", i, pins[i].pin);\r\nreturn -EINVAL;\r\n}\r\nINIT_LIST_HEAD(&pins[i].list);\r\nlist_add(&(pins[i].list), &jack->pins);\r\n}\r\nsnd_soc_jack_report(jack, 0, 0);\r\nreturn 0;\r\n}\r\nvoid snd_soc_jack_notifier_register(struct snd_soc_jack *jack,\r\nstruct notifier_block *nb)\r\n{\r\nblocking_notifier_chain_register(&jack->notifier, nb);\r\n}\r\nvoid snd_soc_jack_notifier_unregister(struct snd_soc_jack *jack,\r\nstruct notifier_block *nb)\r\n{\r\nblocking_notifier_chain_unregister(&jack->notifier, nb);\r\n}\r\nstatic void snd_soc_jack_gpio_detect(struct snd_soc_jack_gpio *gpio)\r\n{\r\nstruct snd_soc_jack *jack = gpio->jack;\r\nint enable;\r\nint report;\r\nenable = gpiod_get_value_cansleep(gpio->desc);\r\nif (gpio->invert)\r\nenable = !enable;\r\nif (enable)\r\nreport = gpio->report;\r\nelse\r\nreport = 0;\r\nif (gpio->jack_status_check)\r\nreport = gpio->jack_status_check(gpio->data);\r\nsnd_soc_jack_report(jack, report, gpio->report);\r\n}\r\nstatic irqreturn_t gpio_handler(int irq, void *data)\r\n{\r\nstruct snd_soc_jack_gpio *gpio = data;\r\nstruct device *dev = gpio->jack->codec->component.card->dev;\r\ntrace_snd_soc_jack_irq(gpio->name);\r\nif (device_may_wakeup(dev))\r\npm_wakeup_event(dev, gpio->debounce_time + 50);\r\nqueue_delayed_work(system_power_efficient_wq, &gpio->work,\r\nmsecs_to_jiffies(gpio->debounce_time));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void gpio_work(struct work_struct *work)\r\n{\r\nstruct snd_soc_jack_gpio *gpio;\r\ngpio = container_of(work, struct snd_soc_jack_gpio, work.work);\r\nsnd_soc_jack_gpio_detect(gpio);\r\n}\r\nint snd_soc_jack_add_gpios(struct snd_soc_jack *jack, int count,\r\nstruct snd_soc_jack_gpio *gpios)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < count; i++) {\r\nif (!gpios[i].name) {\r\ndev_err(jack->codec->dev,\r\n"ASoC: No name for gpio at index %d\n", i);\r\nret = -EINVAL;\r\ngoto undo;\r\n}\r\nif (gpios[i].gpiod_dev) {\r\ngpios[i].desc = gpiod_get_index(gpios[i].gpiod_dev,\r\ngpios[i].name,\r\ngpios[i].idx, GPIOD_IN);\r\nif (IS_ERR(gpios[i].desc)) {\r\nret = PTR_ERR(gpios[i].desc);\r\ndev_err(gpios[i].gpiod_dev,\r\n"ASoC: Cannot get gpio at index %d: %d",\r\ni, ret);\r\ngoto undo;\r\n}\r\n} else {\r\nif (!gpio_is_valid(gpios[i].gpio)) {\r\ndev_err(jack->codec->dev,\r\n"ASoC: Invalid gpio %d\n",\r\ngpios[i].gpio);\r\nret = -EINVAL;\r\ngoto undo;\r\n}\r\nret = gpio_request_one(gpios[i].gpio, GPIOF_IN,\r\ngpios[i].name);\r\nif (ret)\r\ngoto undo;\r\ngpios[i].desc = gpio_to_desc(gpios[i].gpio);\r\n}\r\nINIT_DELAYED_WORK(&gpios[i].work, gpio_work);\r\ngpios[i].jack = jack;\r\nret = request_any_context_irq(gpiod_to_irq(gpios[i].desc),\r\ngpio_handler,\r\nIRQF_TRIGGER_RISING |\r\nIRQF_TRIGGER_FALLING,\r\ngpios[i].name,\r\n&gpios[i]);\r\nif (ret < 0)\r\ngoto err;\r\nif (gpios[i].wake) {\r\nret = irq_set_irq_wake(gpiod_to_irq(gpios[i].desc), 1);\r\nif (ret != 0)\r\ndev_err(jack->codec->dev,\r\n"ASoC: Failed to mark GPIO at index %d as wake source: %d\n",\r\ni, ret);\r\n}\r\ngpiod_export(gpios[i].desc, false);\r\nschedule_delayed_work(&gpios[i].work,\r\nmsecs_to_jiffies(gpios[i].debounce_time));\r\n}\r\nreturn 0;\r\nerr:\r\ngpio_free(gpios[i].gpio);\r\nundo:\r\nsnd_soc_jack_free_gpios(jack, i, gpios);\r\nreturn ret;\r\n}\r\nint snd_soc_jack_add_gpiods(struct device *gpiod_dev,\r\nstruct snd_soc_jack *jack,\r\nint count, struct snd_soc_jack_gpio *gpios)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++)\r\ngpios[i].gpiod_dev = gpiod_dev;\r\nreturn snd_soc_jack_add_gpios(jack, count, gpios);\r\n}\r\nvoid snd_soc_jack_free_gpios(struct snd_soc_jack *jack, int count,\r\nstruct snd_soc_jack_gpio *gpios)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\ngpiod_unexport(gpios[i].desc);\r\nfree_irq(gpiod_to_irq(gpios[i].desc), &gpios[i]);\r\ncancel_delayed_work_sync(&gpios[i].work);\r\ngpiod_put(gpios[i].desc);\r\ngpios[i].jack = NULL;\r\n}\r\n}
