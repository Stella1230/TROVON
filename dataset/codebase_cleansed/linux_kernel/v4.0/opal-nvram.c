static ssize_t opal_nvram_size(void)\r\n{\r\nreturn nvram_size;\r\n}\r\nstatic ssize_t opal_nvram_read(char *buf, size_t count, loff_t *index)\r\n{\r\ns64 rc;\r\nint off;\r\nif (*index >= nvram_size)\r\nreturn 0;\r\noff = *index;\r\nif ((off + count) > nvram_size)\r\ncount = nvram_size - off;\r\nrc = opal_read_nvram(__pa(buf), count, off);\r\nif (rc != OPAL_SUCCESS)\r\nreturn -EIO;\r\n*index += count;\r\nreturn count;\r\n}\r\nstatic ssize_t opal_nvram_write(char *buf, size_t count, loff_t *index)\r\n{\r\ns64 rc = OPAL_BUSY;\r\nint off;\r\nif (*index >= nvram_size)\r\nreturn 0;\r\noff = *index;\r\nif ((off + count) > nvram_size)\r\ncount = nvram_size - off;\r\nwhile (rc == OPAL_BUSY || rc == OPAL_BUSY_EVENT) {\r\nrc = opal_write_nvram(__pa(buf), count, off);\r\nif (rc == OPAL_BUSY_EVENT)\r\nopal_poll_events(NULL);\r\n}\r\n*index += count;\r\nreturn count;\r\n}\r\nvoid __init opal_nvram_init(void)\r\n{\r\nstruct device_node *np;\r\nconst __be32 *nbytes_p;\r\nnp = of_find_compatible_node(NULL, NULL, "ibm,opal-nvram");\r\nif (np == NULL)\r\nreturn;\r\nnbytes_p = of_get_property(np, "#bytes", NULL);\r\nif (!nbytes_p) {\r\nof_node_put(np);\r\nreturn;\r\n}\r\nnvram_size = be32_to_cpup(nbytes_p);\r\npr_info("OPAL nvram setup, %u bytes\n", nvram_size);\r\nof_node_put(np);\r\nppc_md.nvram_read = opal_nvram_read;\r\nppc_md.nvram_write = opal_nvram_write;\r\nppc_md.nvram_size = opal_nvram_size;\r\n}
