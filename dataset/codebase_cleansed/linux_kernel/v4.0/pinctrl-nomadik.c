static void __nmk_gpio_set_mode(struct nmk_gpio_chip *nmk_chip,\r\nunsigned offset, int gpio_mode)\r\n{\r\nu32 bit = 1 << offset;\r\nu32 afunc, bfunc;\r\nafunc = readl(nmk_chip->addr + NMK_GPIO_AFSLA) & ~bit;\r\nbfunc = readl(nmk_chip->addr + NMK_GPIO_AFSLB) & ~bit;\r\nif (gpio_mode & NMK_GPIO_ALT_A)\r\nafunc |= bit;\r\nif (gpio_mode & NMK_GPIO_ALT_B)\r\nbfunc |= bit;\r\nwritel(afunc, nmk_chip->addr + NMK_GPIO_AFSLA);\r\nwritel(bfunc, nmk_chip->addr + NMK_GPIO_AFSLB);\r\n}\r\nstatic void __nmk_gpio_set_slpm(struct nmk_gpio_chip *nmk_chip,\r\nunsigned offset, enum nmk_gpio_slpm mode)\r\n{\r\nu32 bit = 1 << offset;\r\nu32 slpm;\r\nslpm = readl(nmk_chip->addr + NMK_GPIO_SLPC);\r\nif (mode == NMK_GPIO_SLPM_NOCHANGE)\r\nslpm |= bit;\r\nelse\r\nslpm &= ~bit;\r\nwritel(slpm, nmk_chip->addr + NMK_GPIO_SLPC);\r\n}\r\nstatic void __nmk_gpio_set_pull(struct nmk_gpio_chip *nmk_chip,\r\nunsigned offset, enum nmk_gpio_pull pull)\r\n{\r\nu32 bit = 1 << offset;\r\nu32 pdis;\r\npdis = readl(nmk_chip->addr + NMK_GPIO_PDIS);\r\nif (pull == NMK_GPIO_PULL_NONE) {\r\npdis |= bit;\r\nnmk_chip->pull_up &= ~bit;\r\n} else {\r\npdis &= ~bit;\r\n}\r\nwritel(pdis, nmk_chip->addr + NMK_GPIO_PDIS);\r\nif (pull == NMK_GPIO_PULL_UP) {\r\nnmk_chip->pull_up |= bit;\r\nwritel(bit, nmk_chip->addr + NMK_GPIO_DATS);\r\n} else if (pull == NMK_GPIO_PULL_DOWN) {\r\nnmk_chip->pull_up &= ~bit;\r\nwritel(bit, nmk_chip->addr + NMK_GPIO_DATC);\r\n}\r\n}\r\nstatic void __nmk_gpio_set_lowemi(struct nmk_gpio_chip *nmk_chip,\r\nunsigned offset, bool lowemi)\r\n{\r\nu32 bit = BIT(offset);\r\nbool enabled = nmk_chip->lowemi & bit;\r\nif (lowemi == enabled)\r\nreturn;\r\nif (lowemi)\r\nnmk_chip->lowemi |= bit;\r\nelse\r\nnmk_chip->lowemi &= ~bit;\r\nwritel_relaxed(nmk_chip->lowemi,\r\nnmk_chip->addr + NMK_GPIO_LOWEMI);\r\n}\r\nstatic void __nmk_gpio_make_input(struct nmk_gpio_chip *nmk_chip,\r\nunsigned offset)\r\n{\r\nwritel(1 << offset, nmk_chip->addr + NMK_GPIO_DIRC);\r\n}\r\nstatic void __nmk_gpio_set_output(struct nmk_gpio_chip *nmk_chip,\r\nunsigned offset, int val)\r\n{\r\nif (val)\r\nwritel(1 << offset, nmk_chip->addr + NMK_GPIO_DATS);\r\nelse\r\nwritel(1 << offset, nmk_chip->addr + NMK_GPIO_DATC);\r\n}\r\nstatic void __nmk_gpio_make_output(struct nmk_gpio_chip *nmk_chip,\r\nunsigned offset, int val)\r\n{\r\nwritel(1 << offset, nmk_chip->addr + NMK_GPIO_DIRS);\r\n__nmk_gpio_set_output(nmk_chip, offset, val);\r\n}\r\nstatic void __nmk_gpio_set_mode_safe(struct nmk_gpio_chip *nmk_chip,\r\nunsigned offset, int gpio_mode,\r\nbool glitch)\r\n{\r\nu32 rwimsc = nmk_chip->rwimsc;\r\nu32 fwimsc = nmk_chip->fwimsc;\r\nif (glitch && nmk_chip->set_ioforce) {\r\nu32 bit = BIT(offset);\r\nwritel(rwimsc & ~bit, nmk_chip->addr + NMK_GPIO_RWIMSC);\r\nwritel(fwimsc & ~bit, nmk_chip->addr + NMK_GPIO_FWIMSC);\r\nnmk_chip->set_ioforce(true);\r\n}\r\n__nmk_gpio_set_mode(nmk_chip, offset, gpio_mode);\r\nif (glitch && nmk_chip->set_ioforce) {\r\nnmk_chip->set_ioforce(false);\r\nwritel(rwimsc, nmk_chip->addr + NMK_GPIO_RWIMSC);\r\nwritel(fwimsc, nmk_chip->addr + NMK_GPIO_FWIMSC);\r\n}\r\n}\r\nstatic void\r\nnmk_gpio_disable_lazy_irq(struct nmk_gpio_chip *nmk_chip, unsigned offset)\r\n{\r\nu32 falling = nmk_chip->fimsc & BIT(offset);\r\nu32 rising = nmk_chip->rimsc & BIT(offset);\r\nint gpio = nmk_chip->chip.base + offset;\r\nint irq = irq_find_mapping(nmk_chip->chip.irqdomain, offset);\r\nstruct irq_data *d = irq_get_irq_data(irq);\r\nif (!rising && !falling)\r\nreturn;\r\nif (!d || !irqd_irq_disabled(d))\r\nreturn;\r\nif (rising) {\r\nnmk_chip->rimsc &= ~BIT(offset);\r\nwritel_relaxed(nmk_chip->rimsc,\r\nnmk_chip->addr + NMK_GPIO_RIMSC);\r\n}\r\nif (falling) {\r\nnmk_chip->fimsc &= ~BIT(offset);\r\nwritel_relaxed(nmk_chip->fimsc,\r\nnmk_chip->addr + NMK_GPIO_FIMSC);\r\n}\r\ndev_dbg(nmk_chip->chip.dev, "%d: clearing interrupt mask\n", gpio);\r\n}\r\nstatic void nmk_write_masked(void __iomem *reg, u32 mask, u32 value)\r\n{\r\nu32 val;\r\nval = readl(reg);\r\nval = ((val & ~mask) | (value & mask));\r\nwritel(val, reg);\r\n}\r\nstatic void nmk_prcm_altcx_set_mode(struct nmk_pinctrl *npct,\r\nunsigned offset, unsigned alt_num)\r\n{\r\nint i;\r\nu16 reg;\r\nu8 bit;\r\nu8 alt_index;\r\nconst struct prcm_gpiocr_altcx_pin_desc *pin_desc;\r\nconst u16 *gpiocr_regs;\r\nif (!npct->prcm_base)\r\nreturn;\r\nif (alt_num > PRCM_IDX_GPIOCR_ALTC_MAX) {\r\ndev_err(npct->dev, "PRCM GPIOCR: alternate-C%i is invalid\n",\r\nalt_num);\r\nreturn;\r\n}\r\nfor (i = 0 ; i < npct->soc->npins_altcx ; i++) {\r\nif (npct->soc->altcx_pins[i].pin == offset)\r\nbreak;\r\n}\r\nif (i == npct->soc->npins_altcx) {\r\ndev_dbg(npct->dev, "PRCM GPIOCR: pin %i is not found\n",\r\noffset);\r\nreturn;\r\n}\r\npin_desc = npct->soc->altcx_pins + i;\r\ngpiocr_regs = npct->soc->prcm_gpiocr_registers;\r\nif (!alt_num) {\r\nfor (i = 0 ; i < PRCM_IDX_GPIOCR_ALTC_MAX ; i++) {\r\nif (pin_desc->altcx[i].used == true) {\r\nreg = gpiocr_regs[pin_desc->altcx[i].reg_index];\r\nbit = pin_desc->altcx[i].control_bit;\r\nif (readl(npct->prcm_base + reg) & BIT(bit)) {\r\nnmk_write_masked(npct->prcm_base + reg, BIT(bit), 0);\r\ndev_dbg(npct->dev,\r\n"PRCM GPIOCR: pin %i: alternate-C%i has been disabled\n",\r\noffset, i+1);\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nalt_index = alt_num - 1;\r\nif (pin_desc->altcx[alt_index].used == false) {\r\ndev_warn(npct->dev,\r\n"PRCM GPIOCR: pin %i: alternate-C%i does not exist\n",\r\noffset, alt_num);\r\nreturn;\r\n}\r\nfor (i = 0 ; i < PRCM_IDX_GPIOCR_ALTC_MAX ; i++) {\r\nif (i == alt_index)\r\ncontinue;\r\nif (pin_desc->altcx[i].used == true) {\r\nreg = gpiocr_regs[pin_desc->altcx[i].reg_index];\r\nbit = pin_desc->altcx[i].control_bit;\r\nif (readl(npct->prcm_base + reg) & BIT(bit)) {\r\nnmk_write_masked(npct->prcm_base + reg, BIT(bit), 0);\r\ndev_dbg(npct->dev,\r\n"PRCM GPIOCR: pin %i: alternate-C%i has been disabled\n",\r\noffset, i+1);\r\n}\r\n}\r\n}\r\nreg = gpiocr_regs[pin_desc->altcx[alt_index].reg_index];\r\nbit = pin_desc->altcx[alt_index].control_bit;\r\ndev_dbg(npct->dev, "PRCM GPIOCR: pin %i: alternate-C%i has been selected\n",\r\noffset, alt_index+1);\r\nnmk_write_masked(npct->prcm_base + reg, BIT(bit), BIT(bit));\r\n}\r\nstatic void nmk_gpio_glitch_slpm_init(unsigned int *slpm)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_BANKS; i++) {\r\nstruct nmk_gpio_chip *chip = nmk_gpio_chips[i];\r\nunsigned int temp = slpm[i];\r\nif (!chip)\r\nbreak;\r\nclk_enable(chip->clk);\r\nslpm[i] = readl(chip->addr + NMK_GPIO_SLPC);\r\nwritel(temp, chip->addr + NMK_GPIO_SLPC);\r\n}\r\n}\r\nstatic void nmk_gpio_glitch_slpm_restore(unsigned int *slpm)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_BANKS; i++) {\r\nstruct nmk_gpio_chip *chip = nmk_gpio_chips[i];\r\nif (!chip)\r\nbreak;\r\nwritel(slpm[i], chip->addr + NMK_GPIO_SLPC);\r\nclk_disable(chip->clk);\r\n}\r\n}\r\nstatic int __maybe_unused nmk_prcm_gpiocr_get_mode(struct pinctrl_dev *pctldev, int gpio)\r\n{\r\nint i;\r\nu16 reg;\r\nu8 bit;\r\nstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct prcm_gpiocr_altcx_pin_desc *pin_desc;\r\nconst u16 *gpiocr_regs;\r\nif (!npct->prcm_base)\r\nreturn NMK_GPIO_ALT_C;\r\nfor (i = 0; i < npct->soc->npins_altcx; i++) {\r\nif (npct->soc->altcx_pins[i].pin == gpio)\r\nbreak;\r\n}\r\nif (i == npct->soc->npins_altcx)\r\nreturn NMK_GPIO_ALT_C;\r\npin_desc = npct->soc->altcx_pins + i;\r\ngpiocr_regs = npct->soc->prcm_gpiocr_registers;\r\nfor (i = 0; i < PRCM_IDX_GPIOCR_ALTC_MAX; i++) {\r\nif (pin_desc->altcx[i].used == true) {\r\nreg = gpiocr_regs[pin_desc->altcx[i].reg_index];\r\nbit = pin_desc->altcx[i].control_bit;\r\nif (readl(npct->prcm_base + reg) & BIT(bit))\r\nreturn NMK_GPIO_ALT_C+i+1;\r\n}\r\n}\r\nreturn NMK_GPIO_ALT_C;\r\n}\r\nint nmk_gpio_get_mode(int gpio)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip;\r\nu32 afunc, bfunc, bit;\r\nnmk_chip = nmk_gpio_chips[gpio / NMK_GPIO_PER_CHIP];\r\nif (!nmk_chip)\r\nreturn -EINVAL;\r\nbit = 1 << (gpio % NMK_GPIO_PER_CHIP);\r\nclk_enable(nmk_chip->clk);\r\nafunc = readl(nmk_chip->addr + NMK_GPIO_AFSLA) & bit;\r\nbfunc = readl(nmk_chip->addr + NMK_GPIO_AFSLB) & bit;\r\nclk_disable(nmk_chip->clk);\r\nreturn (afunc ? NMK_GPIO_ALT_A : 0) | (bfunc ? NMK_GPIO_ALT_B : 0);\r\n}\r\nstatic inline int nmk_gpio_get_bitmask(int gpio)\r\n{\r\nreturn 1 << (gpio % NMK_GPIO_PER_CHIP);\r\n}\r\nstatic void nmk_gpio_irq_ack(struct irq_data *d)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\r\nstruct nmk_gpio_chip *nmk_chip = container_of(chip, struct nmk_gpio_chip, chip);\r\nclk_enable(nmk_chip->clk);\r\nwritel(nmk_gpio_get_bitmask(d->hwirq), nmk_chip->addr + NMK_GPIO_IC);\r\nclk_disable(nmk_chip->clk);\r\n}\r\nstatic void __nmk_gpio_irq_modify(struct nmk_gpio_chip *nmk_chip,\r\nint gpio, enum nmk_gpio_irq_type which,\r\nbool enable)\r\n{\r\nu32 bitmask = nmk_gpio_get_bitmask(gpio);\r\nu32 *rimscval;\r\nu32 *fimscval;\r\nu32 rimscreg;\r\nu32 fimscreg;\r\nif (which == NORMAL) {\r\nrimscreg = NMK_GPIO_RIMSC;\r\nfimscreg = NMK_GPIO_FIMSC;\r\nrimscval = &nmk_chip->rimsc;\r\nfimscval = &nmk_chip->fimsc;\r\n} else {\r\nrimscreg = NMK_GPIO_RWIMSC;\r\nfimscreg = NMK_GPIO_FWIMSC;\r\nrimscval = &nmk_chip->rwimsc;\r\nfimscval = &nmk_chip->fwimsc;\r\n}\r\nif (nmk_chip->edge_rising & bitmask) {\r\nif (enable)\r\n*rimscval |= bitmask;\r\nelse\r\n*rimscval &= ~bitmask;\r\nwritel(*rimscval, nmk_chip->addr + rimscreg);\r\n}\r\nif (nmk_chip->edge_falling & bitmask) {\r\nif (enable)\r\n*fimscval |= bitmask;\r\nelse\r\n*fimscval &= ~bitmask;\r\nwritel(*fimscval, nmk_chip->addr + fimscreg);\r\n}\r\n}\r\nstatic void __nmk_gpio_set_wake(struct nmk_gpio_chip *nmk_chip,\r\nint gpio, bool on)\r\n{\r\nif (nmk_chip->sleepmode && on) {\r\n__nmk_gpio_set_slpm(nmk_chip, gpio % NMK_GPIO_PER_CHIP,\r\nNMK_GPIO_SLPM_WAKEUP_ENABLE);\r\n}\r\n__nmk_gpio_irq_modify(nmk_chip, gpio, WAKE, on);\r\n}\r\nstatic int nmk_gpio_irq_maskunmask(struct irq_data *d, bool enable)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip;\r\nunsigned long flags;\r\nu32 bitmask;\r\nnmk_chip = irq_data_get_irq_chip_data(d);\r\nbitmask = nmk_gpio_get_bitmask(d->hwirq);\r\nif (!nmk_chip)\r\nreturn -EINVAL;\r\nclk_enable(nmk_chip->clk);\r\nspin_lock_irqsave(&nmk_gpio_slpm_lock, flags);\r\nspin_lock(&nmk_chip->lock);\r\n__nmk_gpio_irq_modify(nmk_chip, d->hwirq, NORMAL, enable);\r\nif (!(nmk_chip->real_wake & bitmask))\r\n__nmk_gpio_set_wake(nmk_chip, d->hwirq, enable);\r\nspin_unlock(&nmk_chip->lock);\r\nspin_unlock_irqrestore(&nmk_gpio_slpm_lock, flags);\r\nclk_disable(nmk_chip->clk);\r\nreturn 0;\r\n}\r\nstatic void nmk_gpio_irq_mask(struct irq_data *d)\r\n{\r\nnmk_gpio_irq_maskunmask(d, false);\r\n}\r\nstatic void nmk_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nnmk_gpio_irq_maskunmask(d, true);\r\n}\r\nstatic int nmk_gpio_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip;\r\nunsigned long flags;\r\nu32 bitmask;\r\nnmk_chip = irq_data_get_irq_chip_data(d);\r\nif (!nmk_chip)\r\nreturn -EINVAL;\r\nbitmask = nmk_gpio_get_bitmask(d->hwirq);\r\nclk_enable(nmk_chip->clk);\r\nspin_lock_irqsave(&nmk_gpio_slpm_lock, flags);\r\nspin_lock(&nmk_chip->lock);\r\nif (irqd_irq_disabled(d))\r\n__nmk_gpio_set_wake(nmk_chip, d->hwirq, on);\r\nif (on)\r\nnmk_chip->real_wake |= bitmask;\r\nelse\r\nnmk_chip->real_wake &= ~bitmask;\r\nspin_unlock(&nmk_chip->lock);\r\nspin_unlock_irqrestore(&nmk_gpio_slpm_lock, flags);\r\nclk_disable(nmk_chip->clk);\r\nreturn 0;\r\n}\r\nstatic int nmk_gpio_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nbool enabled = !irqd_irq_disabled(d);\r\nbool wake = irqd_is_wakeup_set(d);\r\nstruct nmk_gpio_chip *nmk_chip;\r\nunsigned long flags;\r\nu32 bitmask;\r\nnmk_chip = irq_data_get_irq_chip_data(d);\r\nbitmask = nmk_gpio_get_bitmask(d->hwirq);\r\nif (!nmk_chip)\r\nreturn -EINVAL;\r\nif (type & IRQ_TYPE_LEVEL_HIGH)\r\nreturn -EINVAL;\r\nif (type & IRQ_TYPE_LEVEL_LOW)\r\nreturn -EINVAL;\r\nclk_enable(nmk_chip->clk);\r\nspin_lock_irqsave(&nmk_chip->lock, flags);\r\nif (enabled)\r\n__nmk_gpio_irq_modify(nmk_chip, d->hwirq, NORMAL, false);\r\nif (enabled || wake)\r\n__nmk_gpio_irq_modify(nmk_chip, d->hwirq, WAKE, false);\r\nnmk_chip->edge_rising &= ~bitmask;\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nnmk_chip->edge_rising |= bitmask;\r\nnmk_chip->edge_falling &= ~bitmask;\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nnmk_chip->edge_falling |= bitmask;\r\nif (enabled)\r\n__nmk_gpio_irq_modify(nmk_chip, d->hwirq, NORMAL, true);\r\nif (enabled || wake)\r\n__nmk_gpio_irq_modify(nmk_chip, d->hwirq, WAKE, true);\r\nspin_unlock_irqrestore(&nmk_chip->lock, flags);\r\nclk_disable(nmk_chip->clk);\r\nreturn 0;\r\n}\r\nstatic unsigned int nmk_gpio_irq_startup(struct irq_data *d)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip = irq_data_get_irq_chip_data(d);\r\nclk_enable(nmk_chip->clk);\r\nnmk_gpio_irq_unmask(d);\r\nreturn 0;\r\n}\r\nstatic void nmk_gpio_irq_shutdown(struct irq_data *d)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip = irq_data_get_irq_chip_data(d);\r\nnmk_gpio_irq_mask(d);\r\nclk_disable(nmk_chip->clk);\r\n}\r\nstatic void __nmk_gpio_irq_handler(unsigned int irq, struct irq_desc *desc,\r\nu32 status)\r\n{\r\nstruct irq_chip *host_chip = irq_get_chip(irq);\r\nstruct gpio_chip *chip = irq_desc_get_handler_data(desc);\r\nchained_irq_enter(host_chip, desc);\r\nwhile (status) {\r\nint bit = __ffs(status);\r\ngeneric_handle_irq(irq_find_mapping(chip->irqdomain, bit));\r\nstatus &= ~BIT(bit);\r\n}\r\nchained_irq_exit(host_chip, desc);\r\n}\r\nstatic void nmk_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct gpio_chip *chip = irq_desc_get_handler_data(desc);\r\nstruct nmk_gpio_chip *nmk_chip = container_of(chip, struct nmk_gpio_chip, chip);\r\nu32 status;\r\nclk_enable(nmk_chip->clk);\r\nstatus = readl(nmk_chip->addr + NMK_GPIO_IS);\r\nclk_disable(nmk_chip->clk);\r\n__nmk_gpio_irq_handler(irq, desc, status);\r\n}\r\nstatic void nmk_gpio_latent_irq_handler(unsigned int irq,\r\nstruct irq_desc *desc)\r\n{\r\nstruct gpio_chip *chip = irq_desc_get_handler_data(desc);\r\nstruct nmk_gpio_chip *nmk_chip = container_of(chip, struct nmk_gpio_chip, chip);\r\nu32 status = nmk_chip->get_latent_status(nmk_chip->bank);\r\n__nmk_gpio_irq_handler(irq, desc, status);\r\n}\r\nstatic int nmk_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nint gpio = chip->base + offset;\r\nreturn pinctrl_request_gpio(gpio);\r\n}\r\nstatic void nmk_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nint gpio = chip->base + offset;\r\npinctrl_free_gpio(gpio);\r\n}\r\nstatic int nmk_gpio_make_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip =\r\ncontainer_of(chip, struct nmk_gpio_chip, chip);\r\nclk_enable(nmk_chip->clk);\r\nwritel(1 << offset, nmk_chip->addr + NMK_GPIO_DIRC);\r\nclk_disable(nmk_chip->clk);\r\nreturn 0;\r\n}\r\nstatic int nmk_gpio_get_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip =\r\ncontainer_of(chip, struct nmk_gpio_chip, chip);\r\nu32 bit = 1 << offset;\r\nint value;\r\nclk_enable(nmk_chip->clk);\r\nvalue = (readl(nmk_chip->addr + NMK_GPIO_DAT) & bit) != 0;\r\nclk_disable(nmk_chip->clk);\r\nreturn value;\r\n}\r\nstatic void nmk_gpio_set_output(struct gpio_chip *chip, unsigned offset,\r\nint val)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip =\r\ncontainer_of(chip, struct nmk_gpio_chip, chip);\r\nclk_enable(nmk_chip->clk);\r\n__nmk_gpio_set_output(nmk_chip, offset, val);\r\nclk_disable(nmk_chip->clk);\r\n}\r\nstatic int nmk_gpio_make_output(struct gpio_chip *chip, unsigned offset,\r\nint val)\r\n{\r\nstruct nmk_gpio_chip *nmk_chip =\r\ncontainer_of(chip, struct nmk_gpio_chip, chip);\r\nclk_enable(nmk_chip->clk);\r\n__nmk_gpio_make_output(nmk_chip, offset, val);\r\nclk_disable(nmk_chip->clk);\r\nreturn 0;\r\n}\r\nstatic void nmk_gpio_dbg_show_one(struct seq_file *s,\r\nstruct pinctrl_dev *pctldev, struct gpio_chip *chip,\r\nunsigned offset, unsigned gpio)\r\n{\r\nconst char *label = gpiochip_is_requested(chip, offset);\r\nstruct nmk_gpio_chip *nmk_chip =\r\ncontainer_of(chip, struct nmk_gpio_chip, chip);\r\nint mode;\r\nbool is_out;\r\nbool data_out;\r\nbool pull;\r\nu32 bit = 1 << offset;\r\nconst char *modes[] = {\r\n[NMK_GPIO_ALT_GPIO] = "gpio",\r\n[NMK_GPIO_ALT_A] = "altA",\r\n[NMK_GPIO_ALT_B] = "altB",\r\n[NMK_GPIO_ALT_C] = "altC",\r\n[NMK_GPIO_ALT_C+1] = "altC1",\r\n[NMK_GPIO_ALT_C+2] = "altC2",\r\n[NMK_GPIO_ALT_C+3] = "altC3",\r\n[NMK_GPIO_ALT_C+4] = "altC4",\r\n};\r\nconst char *pulls[] = {\r\n"none ",\r\n"pull down",\r\n"pull up ",\r\n};\r\nclk_enable(nmk_chip->clk);\r\nis_out = !!(readl(nmk_chip->addr + NMK_GPIO_DIR) & bit);\r\npull = !(readl(nmk_chip->addr + NMK_GPIO_PDIS) & bit);\r\ndata_out = !!(readl(nmk_chip->addr + NMK_GPIO_DAT) & bit);\r\nmode = nmk_gpio_get_mode(gpio);\r\nif ((mode == NMK_GPIO_ALT_C) && pctldev)\r\nmode = nmk_prcm_gpiocr_get_mode(pctldev, gpio);\r\nif (is_out) {\r\nseq_printf(s, " gpio-%-3d (%-20.20s) out %s %s",\r\ngpio,\r\nlabel ?: "(none)",\r\ndata_out ? "hi" : "lo",\r\n(mode < 0) ? "unknown" : modes[mode]);\r\n} else {\r\nint irq = gpio_to_irq(gpio);\r\nstruct irq_desc *desc = irq_to_desc(irq);\r\nint pullidx = 0;\r\nif (pull)\r\npullidx = data_out ? 1 : 2;\r\nseq_printf(s, " gpio-%-3d (%-20.20s) in %s %s",\r\ngpio,\r\nlabel ?: "(none)",\r\npulls[pullidx],\r\n(mode < 0) ? "unknown" : modes[mode]);\r\nif (irq > 0 && desc && desc->action) {\r\nchar *trigger;\r\nu32 bitmask = nmk_gpio_get_bitmask(gpio);\r\nif (nmk_chip->edge_rising & bitmask)\r\ntrigger = "edge-rising";\r\nelse if (nmk_chip->edge_falling & bitmask)\r\ntrigger = "edge-falling";\r\nelse\r\ntrigger = "edge-undefined";\r\nseq_printf(s, " irq-%d %s%s",\r\nirq, trigger,\r\nirqd_is_wakeup_set(&desc->irq_data)\r\n? " wakeup" : "");\r\n}\r\n}\r\nclk_disable(nmk_chip->clk);\r\n}\r\nstatic void nmk_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nunsigned i;\r\nunsigned gpio = chip->base;\r\nfor (i = 0; i < chip->ngpio; i++, gpio++) {\r\nnmk_gpio_dbg_show_one(s, NULL, chip, i, gpio);\r\nseq_printf(s, "\n");\r\n}\r\n}\r\nstatic inline void nmk_gpio_dbg_show_one(struct seq_file *s,\r\nstruct pinctrl_dev *pctldev,\r\nstruct gpio_chip *chip,\r\nunsigned offset, unsigned gpio)\r\n{\r\n}\r\nvoid nmk_gpio_clocks_enable(void)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_BANKS; i++) {\r\nstruct nmk_gpio_chip *chip = nmk_gpio_chips[i];\r\nif (!chip)\r\ncontinue;\r\nclk_enable(chip->clk);\r\n}\r\n}\r\nvoid nmk_gpio_clocks_disable(void)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_BANKS; i++) {\r\nstruct nmk_gpio_chip *chip = nmk_gpio_chips[i];\r\nif (!chip)\r\ncontinue;\r\nclk_disable(chip->clk);\r\n}\r\n}\r\nvoid nmk_gpio_wakeups_suspend(void)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_BANKS; i++) {\r\nstruct nmk_gpio_chip *chip = nmk_gpio_chips[i];\r\nif (!chip)\r\nbreak;\r\nclk_enable(chip->clk);\r\nwritel(chip->rwimsc & chip->real_wake,\r\nchip->addr + NMK_GPIO_RWIMSC);\r\nwritel(chip->fwimsc & chip->real_wake,\r\nchip->addr + NMK_GPIO_FWIMSC);\r\nclk_disable(chip->clk);\r\n}\r\n}\r\nvoid nmk_gpio_wakeups_resume(void)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_BANKS; i++) {\r\nstruct nmk_gpio_chip *chip = nmk_gpio_chips[i];\r\nif (!chip)\r\nbreak;\r\nclk_enable(chip->clk);\r\nwritel(chip->rwimsc, chip->addr + NMK_GPIO_RWIMSC);\r\nwritel(chip->fwimsc, chip->addr + NMK_GPIO_FWIMSC);\r\nclk_disable(chip->clk);\r\n}\r\n}\r\nvoid nmk_gpio_read_pull(int gpio_bank, u32 *pull_up)\r\n{\r\nif (gpio_bank < NUM_BANKS) {\r\nstruct nmk_gpio_chip *chip = nmk_gpio_chips[gpio_bank];\r\nif (!chip)\r\nreturn;\r\n*pull_up = chip->pull_up;\r\n}\r\n}\r\nstatic int nmk_gpio_probe(struct platform_device *dev)\r\n{\r\nstruct device_node *np = dev->dev.of_node;\r\nstruct nmk_gpio_chip *nmk_chip;\r\nstruct gpio_chip *chip;\r\nstruct resource *res;\r\nstruct clk *clk;\r\nint latent_irq;\r\nbool supports_sleepmode;\r\nvoid __iomem *base;\r\nint irq;\r\nint ret;\r\nif (of_get_property(np, "st,supports-sleepmode", NULL))\r\nsupports_sleepmode = true;\r\nelse\r\nsupports_sleepmode = false;\r\nif (of_property_read_u32(np, "gpio-bank", &dev->id)) {\r\ndev_err(&dev->dev, "gpio-bank property not found\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(dev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nlatent_irq = platform_get_irq(dev, 1);\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&dev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nclk = devm_clk_get(&dev->dev, NULL);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nclk_prepare(clk);\r\nnmk_chip = devm_kzalloc(&dev->dev, sizeof(*nmk_chip), GFP_KERNEL);\r\nif (!nmk_chip)\r\nreturn -ENOMEM;\r\nnmk_chip->bank = dev->id;\r\nnmk_chip->clk = clk;\r\nnmk_chip->addr = base;\r\nnmk_chip->chip = nmk_gpio_template;\r\nnmk_chip->parent_irq = irq;\r\nnmk_chip->latent_parent_irq = latent_irq;\r\nnmk_chip->sleepmode = supports_sleepmode;\r\nspin_lock_init(&nmk_chip->lock);\r\nchip = &nmk_chip->chip;\r\nchip->base = dev->id * NMK_GPIO_PER_CHIP;\r\nchip->ngpio = NMK_GPIO_PER_CHIP;\r\nchip->label = dev_name(&dev->dev);\r\nchip->dev = &dev->dev;\r\nchip->owner = THIS_MODULE;\r\nclk_enable(nmk_chip->clk);\r\nnmk_chip->lowemi = readl_relaxed(nmk_chip->addr + NMK_GPIO_LOWEMI);\r\nclk_disable(nmk_chip->clk);\r\nchip->of_node = np;\r\nret = gpiochip_add(&nmk_chip->chip);\r\nif (ret)\r\nreturn ret;\r\nBUG_ON(nmk_chip->bank >= ARRAY_SIZE(nmk_gpio_chips));\r\nnmk_gpio_chips[nmk_chip->bank] = nmk_chip;\r\nplatform_set_drvdata(dev, nmk_chip);\r\nret = gpiochip_irqchip_add(&nmk_chip->chip,\r\n&nmk_gpio_irq_chip,\r\n0,\r\nhandle_edge_irq,\r\nIRQ_TYPE_EDGE_FALLING);\r\nif (ret) {\r\ndev_err(&dev->dev, "could not add irqchip\n");\r\ngpiochip_remove(&nmk_chip->chip);\r\nreturn -ENODEV;\r\n}\r\ngpiochip_set_chained_irqchip(&nmk_chip->chip,\r\n&nmk_gpio_irq_chip,\r\nnmk_chip->parent_irq,\r\nnmk_gpio_irq_handler);\r\nif (nmk_chip->latent_parent_irq > 0)\r\ngpiochip_set_chained_irqchip(&nmk_chip->chip,\r\n&nmk_gpio_irq_chip,\r\nnmk_chip->latent_parent_irq,\r\nnmk_gpio_latent_irq_handler);\r\ndev_info(&dev->dev, "at address %p\n", nmk_chip->addr);\r\nreturn 0;\r\n}\r\nstatic int nmk_get_groups_cnt(struct pinctrl_dev *pctldev)\r\n{\r\nstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\r\nreturn npct->soc->ngroups;\r\n}\r\nstatic const char *nmk_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\r\nreturn npct->soc->groups[selector].name;\r\n}\r\nstatic int nmk_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = npct->soc->groups[selector].pins;\r\n*num_pins = npct->soc->groups[selector].npins;\r\nreturn 0;\r\n}\r\nstatic struct pinctrl_gpio_range *\r\nnmk_match_gpio_range(struct pinctrl_dev *pctldev, unsigned offset)\r\n{\r\nstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\r\nint i;\r\nfor (i = 0; i < npct->soc->gpio_num_ranges; i++) {\r\nstruct pinctrl_gpio_range *range;\r\nrange = &npct->soc->gpio_ranges[i];\r\nif (offset >= range->pin_base &&\r\noffset <= (range->pin_base + range->npins - 1))\r\nreturn range;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void nmk_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\r\nunsigned offset)\r\n{\r\nstruct pinctrl_gpio_range *range;\r\nstruct gpio_chip *chip;\r\nrange = nmk_match_gpio_range(pctldev, offset);\r\nif (!range || !range->gc) {\r\nseq_printf(s, "invalid pin offset");\r\nreturn;\r\n}\r\nchip = range->gc;\r\nnmk_gpio_dbg_show_one(s, pctldev, chip, offset - chip->base, offset);\r\n}\r\nstatic int nmk_dt_add_map_mux(struct pinctrl_map **map, unsigned *reserved_maps,\r\nunsigned *num_maps, const char *group,\r\nconst char *function)\r\n{\r\nif (*num_maps == *reserved_maps)\r\nreturn -ENOSPC;\r\n(*map)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;\r\n(*map)[*num_maps].data.mux.group = group;\r\n(*map)[*num_maps].data.mux.function = function;\r\n(*num_maps)++;\r\nreturn 0;\r\n}\r\nstatic int nmk_dt_add_map_configs(struct pinctrl_map **map,\r\nunsigned *reserved_maps,\r\nunsigned *num_maps, const char *group,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nunsigned long *dup_configs;\r\nif (*num_maps == *reserved_maps)\r\nreturn -ENOSPC;\r\ndup_configs = kmemdup(configs, num_configs * sizeof(*dup_configs),\r\nGFP_KERNEL);\r\nif (!dup_configs)\r\nreturn -ENOMEM;\r\n(*map)[*num_maps].type = PIN_MAP_TYPE_CONFIGS_PIN;\r\n(*map)[*num_maps].data.configs.group_or_pin = group;\r\n(*map)[*num_maps].data.configs.configs = dup_configs;\r\n(*map)[*num_maps].data.configs.num_configs = num_configs;\r\n(*num_maps)++;\r\nreturn 0;\r\n}\r\nstatic int nmk_dt_pin_config(int index, int val, unsigned long *config)\r\n{\r\nint ret = 0;\r\nif (nmk_cfg_params[index].choice == NULL)\r\n*config = nmk_cfg_params[index].config;\r\nelse {\r\nif (val < nmk_cfg_params[index].size) {\r\n*config = nmk_cfg_params[index].config |\r\nnmk_cfg_params[index].choice[val];\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic const char *nmk_find_pin_name(struct pinctrl_dev *pctldev, const char *pin_name)\r\n{\r\nint i, pin_number;\r\nstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\r\nif (sscanf((char *)pin_name, "GPIO%d", &pin_number) == 1)\r\nfor (i = 0; i < npct->soc->npins; i++)\r\nif (npct->soc->pins[i].number == pin_number)\r\nreturn npct->soc->pins[i].name;\r\nreturn NULL;\r\n}\r\nstatic bool nmk_pinctrl_dt_get_config(struct device_node *np,\r\nunsigned long *configs)\r\n{\r\nbool has_config = 0;\r\nunsigned long cfg = 0;\r\nint i, val, ret;\r\nfor (i = 0; i < ARRAY_SIZE(nmk_cfg_params); i++) {\r\nret = of_property_read_u32(np,\r\nnmk_cfg_params[i].property, &val);\r\nif (ret != -EINVAL) {\r\nif (nmk_dt_pin_config(i, val, &cfg) == 0) {\r\n*configs |= cfg;\r\nhas_config = 1;\r\n}\r\n}\r\n}\r\nreturn has_config;\r\n}\r\nstatic int nmk_pinctrl_dt_subnode_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map,\r\nunsigned *reserved_maps,\r\nunsigned *num_maps)\r\n{\r\nint ret;\r\nconst char *function = NULL;\r\nunsigned long configs = 0;\r\nbool has_config = 0;\r\nstruct property *prop;\r\nstruct device_node *np_config;\r\nret = of_property_read_string(np, "function", &function);\r\nif (ret >= 0) {\r\nconst char *group;\r\nret = of_property_count_strings(np, "groups");\r\nif (ret < 0)\r\ngoto exit;\r\nret = pinctrl_utils_reserve_map(pctldev, map,\r\nreserved_maps,\r\nnum_maps, ret);\r\nif (ret < 0)\r\ngoto exit;\r\nof_property_for_each_string(np, "groups", prop, group) {\r\nret = nmk_dt_add_map_mux(map, reserved_maps, num_maps,\r\ngroup, function);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\n}\r\nhas_config = nmk_pinctrl_dt_get_config(np, &configs);\r\nnp_config = of_parse_phandle(np, "ste,config", 0);\r\nif (np_config)\r\nhas_config |= nmk_pinctrl_dt_get_config(np_config, &configs);\r\nif (has_config) {\r\nconst char *gpio_name;\r\nconst char *pin;\r\nret = of_property_count_strings(np, "pins");\r\nif (ret < 0)\r\ngoto exit;\r\nret = pinctrl_utils_reserve_map(pctldev, map,\r\nreserved_maps,\r\nnum_maps, ret);\r\nif (ret < 0)\r\ngoto exit;\r\nof_property_for_each_string(np, "pins", prop, pin) {\r\ngpio_name = nmk_find_pin_name(pctldev, pin);\r\nret = nmk_dt_add_map_configs(map, reserved_maps,\r\nnum_maps,\r\ngpio_name, &configs, 1);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\n}\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int nmk_pinctrl_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np_config,\r\nstruct pinctrl_map **map, unsigned *num_maps)\r\n{\r\nunsigned reserved_maps;\r\nstruct device_node *np;\r\nint ret;\r\nreserved_maps = 0;\r\n*map = NULL;\r\n*num_maps = 0;\r\nfor_each_child_of_node(np_config, np) {\r\nret = nmk_pinctrl_dt_subnode_to_map(pctldev, np, map,\r\n&reserved_maps, num_maps);\r\nif (ret < 0) {\r\npinctrl_utils_dt_free_map(pctldev, *map, *num_maps);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int nmk_pmx_get_funcs_cnt(struct pinctrl_dev *pctldev)\r\n{\r\nstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\r\nreturn npct->soc->nfunctions;\r\n}\r\nstatic const char *nmk_pmx_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\r\nreturn npct->soc->functions[function].name;\r\n}\r\nstatic int nmk_pmx_get_func_groups(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = npct->soc->functions[function].groups;\r\n*num_groups = npct->soc->functions[function].ngroups;\r\nreturn 0;\r\n}\r\nstatic int nmk_pmx_set(struct pinctrl_dev *pctldev, unsigned function,\r\nunsigned group)\r\n{\r\nstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct nmk_pingroup *g;\r\nstatic unsigned int slpm[NUM_BANKS];\r\nunsigned long flags = 0;\r\nbool glitch;\r\nint ret = -EINVAL;\r\nint i;\r\ng = &npct->soc->groups[group];\r\nif (g->altsetting < 0)\r\nreturn -EINVAL;\r\ndev_dbg(npct->dev, "enable group %s, %u pins\n", g->name, g->npins);\r\nglitch = ((g->altsetting & NMK_GPIO_ALT_C) == NMK_GPIO_ALT_C);\r\nif (glitch) {\r\nspin_lock_irqsave(&nmk_gpio_slpm_lock, flags);\r\nmemset(slpm, 0xff, sizeof(slpm));\r\nfor (i = 0; i < g->npins; i++)\r\nslpm[g->pins[i] / NMK_GPIO_PER_CHIP] &= ~BIT(g->pins[i]);\r\nnmk_gpio_glitch_slpm_init(slpm);\r\n}\r\nfor (i = 0; i < g->npins; i++) {\r\nstruct pinctrl_gpio_range *range;\r\nstruct nmk_gpio_chip *nmk_chip;\r\nstruct gpio_chip *chip;\r\nunsigned bit;\r\nrange = nmk_match_gpio_range(pctldev, g->pins[i]);\r\nif (!range) {\r\ndev_err(npct->dev,\r\n"invalid pin offset %d in group %s at index %d\n",\r\ng->pins[i], g->name, i);\r\ngoto out_glitch;\r\n}\r\nif (!range->gc) {\r\ndev_err(npct->dev, "GPIO chip missing in range for pin offset %d in group %s at index %d\n",\r\ng->pins[i], g->name, i);\r\ngoto out_glitch;\r\n}\r\nchip = range->gc;\r\nnmk_chip = container_of(chip, struct nmk_gpio_chip, chip);\r\ndev_dbg(npct->dev, "setting pin %d to altsetting %d\n", g->pins[i], g->altsetting);\r\nclk_enable(nmk_chip->clk);\r\nbit = g->pins[i] % NMK_GPIO_PER_CHIP;\r\nnmk_gpio_disable_lazy_irq(nmk_chip, bit);\r\n__nmk_gpio_set_mode_safe(nmk_chip, bit,\r\n(g->altsetting & NMK_GPIO_ALT_C), glitch);\r\nclk_disable(nmk_chip->clk);\r\nif ((g->altsetting & NMK_GPIO_ALT_C) == NMK_GPIO_ALT_C)\r\nnmk_prcm_altcx_set_mode(npct, g->pins[i],\r\ng->altsetting >> NMK_GPIO_ALT_CX_SHIFT);\r\n}\r\nret = 0;\r\nout_glitch:\r\nif (glitch) {\r\nnmk_gpio_glitch_slpm_restore(slpm);\r\nspin_unlock_irqrestore(&nmk_gpio_slpm_lock, flags);\r\n}\r\nreturn ret;\r\n}\r\nstatic int nmk_gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\r\nstruct nmk_gpio_chip *nmk_chip;\r\nstruct gpio_chip *chip;\r\nunsigned bit;\r\nif (!range) {\r\ndev_err(npct->dev, "invalid range\n");\r\nreturn -EINVAL;\r\n}\r\nif (!range->gc) {\r\ndev_err(npct->dev, "missing GPIO chip in range\n");\r\nreturn -EINVAL;\r\n}\r\nchip = range->gc;\r\nnmk_chip = container_of(chip, struct nmk_gpio_chip, chip);\r\ndev_dbg(npct->dev, "enable pin %u as GPIO\n", offset);\r\nclk_enable(nmk_chip->clk);\r\nbit = offset % NMK_GPIO_PER_CHIP;\r\n__nmk_gpio_set_mode(nmk_chip, bit, NMK_GPIO_ALT_GPIO);\r\nclk_disable(nmk_chip->clk);\r\nreturn 0;\r\n}\r\nstatic void nmk_gpio_disable_free(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\r\ndev_dbg(npct->dev, "disable pin %u as GPIO\n", offset);\r\n}\r\nstatic int nmk_pin_config_get(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *config)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int nmk_pin_config_set(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nstatic const char *pullnames[] = {\r\n[NMK_GPIO_PULL_NONE] = "none",\r\n[NMK_GPIO_PULL_UP] = "up",\r\n[NMK_GPIO_PULL_DOWN] = "down",\r\n[3] = "??"\r\n};\r\nstatic const char *slpmnames[] = {\r\n[NMK_GPIO_SLPM_INPUT] = "input/wakeup",\r\n[NMK_GPIO_SLPM_NOCHANGE] = "no-change/no-wakeup",\r\n};\r\nstruct nmk_pinctrl *npct = pinctrl_dev_get_drvdata(pctldev);\r\nstruct nmk_gpio_chip *nmk_chip;\r\nstruct pinctrl_gpio_range *range;\r\nstruct gpio_chip *chip;\r\nunsigned bit;\r\npin_cfg_t cfg;\r\nint pull, slpm, output, val, i;\r\nbool lowemi, gpiomode, sleep;\r\nrange = nmk_match_gpio_range(pctldev, pin);\r\nif (!range) {\r\ndev_err(npct->dev, "invalid pin offset %d\n", pin);\r\nreturn -EINVAL;\r\n}\r\nif (!range->gc) {\r\ndev_err(npct->dev, "GPIO chip missing in range for pin %d\n",\r\npin);\r\nreturn -EINVAL;\r\n}\r\nchip = range->gc;\r\nnmk_chip = container_of(chip, struct nmk_gpio_chip, chip);\r\nfor (i = 0; i < num_configs; i++) {\r\ncfg = (pin_cfg_t) configs[i];\r\npull = PIN_PULL(cfg);\r\nslpm = PIN_SLPM(cfg);\r\noutput = PIN_DIR(cfg);\r\nval = PIN_VAL(cfg);\r\nlowemi = PIN_LOWEMI(cfg);\r\ngpiomode = PIN_GPIOMODE(cfg);\r\nsleep = PIN_SLEEPMODE(cfg);\r\nif (sleep) {\r\nint slpm_pull = PIN_SLPM_PULL(cfg);\r\nint slpm_output = PIN_SLPM_DIR(cfg);\r\nint slpm_val = PIN_SLPM_VAL(cfg);\r\ngpiomode = true;\r\nif (slpm_pull)\r\npull = slpm_pull - 1;\r\nif (slpm_output)\r\noutput = slpm_output - 1;\r\nif (slpm_val)\r\nval = slpm_val - 1;\r\ndev_dbg(nmk_chip->chip.dev,\r\n"pin %d: sleep pull %s, dir %s, val %s\n",\r\npin,\r\nslpm_pull ? pullnames[pull] : "same",\r\nslpm_output ? (output ? "output" : "input")\r\n: "same",\r\nslpm_val ? (val ? "high" : "low") : "same");\r\n}\r\ndev_dbg(nmk_chip->chip.dev,\r\n"pin %d [%#lx]: pull %s, slpm %s (%s%s), lowemi %s\n",\r\npin, cfg, pullnames[pull], slpmnames[slpm],\r\noutput ? "output " : "input",\r\noutput ? (val ? "high" : "low") : "",\r\nlowemi ? "on" : "off");\r\nclk_enable(nmk_chip->clk);\r\nbit = pin % NMK_GPIO_PER_CHIP;\r\nif (gpiomode)\r\n__nmk_gpio_set_mode(nmk_chip, bit, NMK_GPIO_ALT_GPIO);\r\nif (output)\r\n__nmk_gpio_make_output(nmk_chip, bit, val);\r\nelse {\r\n__nmk_gpio_make_input(nmk_chip, bit);\r\n__nmk_gpio_set_pull(nmk_chip, bit, pull);\r\n}\r\n__nmk_gpio_set_lowemi(nmk_chip, bit, lowemi);\r\n__nmk_gpio_set_slpm(nmk_chip, bit, slpm);\r\nclk_disable(nmk_chip->clk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int nmk_pinctrl_suspend(struct device *dev)\r\n{\r\nstruct nmk_pinctrl *npct;\r\nnpct = dev_get_drvdata(dev);\r\nif (!npct)\r\nreturn -EINVAL;\r\nreturn pinctrl_force_sleep(npct->pctl);\r\n}\r\nstatic int nmk_pinctrl_resume(struct device *dev)\r\n{\r\nstruct nmk_pinctrl *npct;\r\nnpct = dev_get_drvdata(dev);\r\nif (!npct)\r\nreturn -EINVAL;\r\nreturn pinctrl_force_default(npct->pctl);\r\n}\r\nstatic int nmk_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *prcm_np;\r\nstruct nmk_pinctrl *npct;\r\nunsigned int version = 0;\r\nint i;\r\nnpct = devm_kzalloc(&pdev->dev, sizeof(*npct), GFP_KERNEL);\r\nif (!npct)\r\nreturn -ENOMEM;\r\nmatch = of_match_device(nmk_pinctrl_match, &pdev->dev);\r\nif (!match)\r\nreturn -ENODEV;\r\nversion = (unsigned int) match->data;\r\nif (version == PINCTRL_NMK_STN8815)\r\nnmk_pinctrl_stn8815_init(&npct->soc);\r\nif (version == PINCTRL_NMK_DB8500)\r\nnmk_pinctrl_db8500_init(&npct->soc);\r\nif (version == PINCTRL_NMK_DB8540)\r\nnmk_pinctrl_db8540_init(&npct->soc);\r\nprcm_np = of_parse_phandle(np, "prcm", 0);\r\nif (prcm_np)\r\nnpct->prcm_base = of_iomap(prcm_np, 0);\r\nif (!npct->prcm_base) {\r\nif (version == PINCTRL_NMK_STN8815) {\r\ndev_info(&pdev->dev,\r\n"No PRCM base, "\r\n"assuming no ALT-Cx control is available\n");\r\n} else {\r\ndev_err(&pdev->dev, "missing PRCM base address\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nfor (i = 0; i < npct->soc->gpio_num_ranges; i++) {\r\nif (!nmk_gpio_chips[npct->soc->gpio_ranges[i].id]) {\r\ndev_warn(&pdev->dev, "GPIO chip %d not registered yet\n", i);\r\nreturn -EPROBE_DEFER;\r\n}\r\nnpct->soc->gpio_ranges[i].gc = &nmk_gpio_chips[npct->soc->gpio_ranges[i].id]->chip;\r\n}\r\nnmk_pinctrl_desc.pins = npct->soc->pins;\r\nnmk_pinctrl_desc.npins = npct->soc->npins;\r\nnpct->dev = &pdev->dev;\r\nnpct->pctl = pinctrl_register(&nmk_pinctrl_desc, &pdev->dev, npct);\r\nif (!npct->pctl) {\r\ndev_err(&pdev->dev, "could not register Nomadik pinctrl driver\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < npct->soc->gpio_num_ranges; i++)\r\npinctrl_add_gpio_range(npct->pctl, &npct->soc->gpio_ranges[i]);\r\nplatform_set_drvdata(pdev, npct);\r\ndev_info(&pdev->dev, "initialized Nomadik pin control driver\n");\r\nreturn 0;\r\n}\r\nstatic int __init nmk_gpio_init(void)\r\n{\r\nint ret;\r\nret = platform_driver_register(&nmk_gpio_driver);\r\nif (ret)\r\nreturn ret;\r\nreturn platform_driver_register(&nmk_pinctrl_driver);\r\n}
