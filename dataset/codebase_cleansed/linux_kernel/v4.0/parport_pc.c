static void frob_econtrol(struct parport *pb, unsigned char m,\r\nunsigned char v)\r\n{\r\nunsigned char ectr = 0;\r\nif (m != 0xff)\r\nectr = inb(ECONTROL(pb));\r\nDPRINTK(KERN_DEBUG "frob_econtrol(%02x,%02x): %02x -> %02x\n",\r\nm, v, ectr, (ectr & ~m) ^ v);\r\noutb((ectr & ~m) ^ v, ECONTROL(pb));\r\n}\r\nstatic inline void frob_set_mode(struct parport *p, int mode)\r\n{\r\nfrob_econtrol(p, ECR_MODE_MASK, mode << 5);\r\n}\r\nstatic int change_mode(struct parport *p, int m)\r\n{\r\nconst struct parport_pc_private *priv = p->physport->private_data;\r\nunsigned char oecr;\r\nint mode;\r\nDPRINTK(KERN_INFO "parport change_mode ECP-ISA to mode 0x%02x\n", m);\r\nif (!priv->ecr) {\r\nprintk(KERN_DEBUG "change_mode: but there's no ECR!\n");\r\nreturn 0;\r\n}\r\noecr = inb(ECONTROL(p));\r\nmode = (oecr >> 5) & 0x7;\r\nif (mode == m)\r\nreturn 0;\r\nif (mode >= 2 && !(priv->ctr & 0x20)) {\r\nunsigned long expire = jiffies + p->physport->cad->timeout;\r\nint counter;\r\nswitch (mode) {\r\ncase ECR_PPF:\r\ncase ECR_ECP:\r\nfor (counter = 0; counter < 40; counter++) {\r\nif (inb(ECONTROL(p)) & 0x01)\r\nbreak;\r\nif (signal_pending(current))\r\nbreak;\r\nudelay(5);\r\n}\r\nwhile (!(inb(ECONTROL(p)) & 0x01)) {\r\nif (time_after_eq(jiffies, expire))\r\nreturn -EBUSY;\r\nschedule_timeout_interruptible(\r\nmsecs_to_jiffies(10));\r\nif (signal_pending(current))\r\nbreak;\r\n}\r\n}\r\n}\r\nif (mode >= 2 && m >= 2) {\r\noecr &= ~(7 << 5);\r\noecr |= ECR_PS2 << 5;\r\nECR_WRITE(p, oecr);\r\n}\r\noecr &= ~(7 << 5);\r\noecr |= m << 5;\r\nECR_WRITE(p, oecr);\r\nreturn 0;\r\n}\r\nstatic int clear_epp_timeout(struct parport *pb)\r\n{\r\nunsigned char r;\r\nif (!(parport_pc_read_status(pb) & 0x01))\r\nreturn 1;\r\nparport_pc_read_status(pb);\r\nr = parport_pc_read_status(pb);\r\noutb(r | 0x01, STATUS(pb));\r\noutb(r & 0xfe, STATUS(pb));\r\nr = parport_pc_read_status(pb);\r\nreturn !(r & 0x01);\r\n}\r\nstatic void parport_pc_init_state(struct pardevice *dev,\r\nstruct parport_state *s)\r\n{\r\ns->u.pc.ctr = 0xc;\r\nif (dev->irq_func &&\r\ndev->port->irq != PARPORT_IRQ_NONE)\r\ns->u.pc.ctr |= 0x10;\r\ns->u.pc.ecr = 0x34;\r\n}\r\nstatic void parport_pc_save_state(struct parport *p, struct parport_state *s)\r\n{\r\nconst struct parport_pc_private *priv = p->physport->private_data;\r\ns->u.pc.ctr = priv->ctr;\r\nif (priv->ecr)\r\ns->u.pc.ecr = inb(ECONTROL(p));\r\n}\r\nstatic void parport_pc_restore_state(struct parport *p,\r\nstruct parport_state *s)\r\n{\r\nstruct parport_pc_private *priv = p->physport->private_data;\r\nregister unsigned char c = s->u.pc.ctr & priv->ctr_writable;\r\noutb(c, CONTROL(p));\r\npriv->ctr = c;\r\nif (priv->ecr)\r\nECR_WRITE(p, s->u.pc.ecr);\r\n}\r\nstatic size_t parport_pc_epp_read_data(struct parport *port, void *buf,\r\nsize_t length, int flags)\r\n{\r\nsize_t got = 0;\r\nif (flags & PARPORT_W91284PIC) {\r\nunsigned char status;\r\nsize_t left = length;\r\nstatus = inb(STATUS(port));\r\nwhile (!(status & 0x08) && got < length) {\r\nif (left >= 16 && (status & 0x20) && !(status & 0x08)) {\r\nif (!((long)buf & 0x03))\r\ninsl(EPPDATA(port), buf, 4);\r\nelse\r\ninsb(EPPDATA(port), buf, 16);\r\nbuf += 16;\r\ngot += 16;\r\nleft -= 16;\r\n} else {\r\n*((char *)buf) = inb(EPPDATA(port));\r\nbuf++;\r\ngot++;\r\nleft--;\r\n}\r\nstatus = inb(STATUS(port));\r\nif (status & 0x01) {\r\nprintk(KERN_DEBUG\r\n"%s: EPP timeout occurred while talking to w91284pic (should not have done)\n", port->name);\r\nclear_epp_timeout(port);\r\n}\r\n}\r\nreturn got;\r\n}\r\nif ((flags & PARPORT_EPP_FAST) && (length > 1)) {\r\nif (!(((long)buf | length) & 0x03))\r\ninsl(EPPDATA(port), buf, (length >> 2));\r\nelse\r\ninsb(EPPDATA(port), buf, length);\r\nif (inb(STATUS(port)) & 0x01) {\r\nclear_epp_timeout(port);\r\nreturn -EIO;\r\n}\r\nreturn length;\r\n}\r\nfor (; got < length; got++) {\r\n*((char *)buf) = inb(EPPDATA(port));\r\nbuf++;\r\nif (inb(STATUS(port)) & 0x01) {\r\nclear_epp_timeout(port);\r\nbreak;\r\n}\r\n}\r\nreturn got;\r\n}\r\nstatic size_t parport_pc_epp_write_data(struct parport *port, const void *buf,\r\nsize_t length, int flags)\r\n{\r\nsize_t written = 0;\r\nif ((flags & PARPORT_EPP_FAST) && (length > 1)) {\r\nif (!(((long)buf | length) & 0x03))\r\noutsl(EPPDATA(port), buf, (length >> 2));\r\nelse\r\noutsb(EPPDATA(port), buf, length);\r\nif (inb(STATUS(port)) & 0x01) {\r\nclear_epp_timeout(port);\r\nreturn -EIO;\r\n}\r\nreturn length;\r\n}\r\nfor (; written < length; written++) {\r\noutb(*((char *)buf), EPPDATA(port));\r\nbuf++;\r\nif (inb(STATUS(port)) & 0x01) {\r\nclear_epp_timeout(port);\r\nbreak;\r\n}\r\n}\r\nreturn written;\r\n}\r\nstatic size_t parport_pc_epp_read_addr(struct parport *port, void *buf,\r\nsize_t length, int flags)\r\n{\r\nsize_t got = 0;\r\nif ((flags & PARPORT_EPP_FAST) && (length > 1)) {\r\ninsb(EPPADDR(port), buf, length);\r\nif (inb(STATUS(port)) & 0x01) {\r\nclear_epp_timeout(port);\r\nreturn -EIO;\r\n}\r\nreturn length;\r\n}\r\nfor (; got < length; got++) {\r\n*((char *)buf) = inb(EPPADDR(port));\r\nbuf++;\r\nif (inb(STATUS(port)) & 0x01) {\r\nclear_epp_timeout(port);\r\nbreak;\r\n}\r\n}\r\nreturn got;\r\n}\r\nstatic size_t parport_pc_epp_write_addr(struct parport *port,\r\nconst void *buf, size_t length,\r\nint flags)\r\n{\r\nsize_t written = 0;\r\nif ((flags & PARPORT_EPP_FAST) && (length > 1)) {\r\noutsb(EPPADDR(port), buf, length);\r\nif (inb(STATUS(port)) & 0x01) {\r\nclear_epp_timeout(port);\r\nreturn -EIO;\r\n}\r\nreturn length;\r\n}\r\nfor (; written < length; written++) {\r\noutb(*((char *)buf), EPPADDR(port));\r\nbuf++;\r\nif (inb(STATUS(port)) & 0x01) {\r\nclear_epp_timeout(port);\r\nbreak;\r\n}\r\n}\r\nreturn written;\r\n}\r\nstatic size_t parport_pc_ecpepp_read_data(struct parport *port, void *buf,\r\nsize_t length, int flags)\r\n{\r\nsize_t got;\r\nfrob_set_mode(port, ECR_EPP);\r\nparport_pc_data_reverse(port);\r\nparport_pc_write_control(port, 0x4);\r\ngot = parport_pc_epp_read_data(port, buf, length, flags);\r\nfrob_set_mode(port, ECR_PS2);\r\nreturn got;\r\n}\r\nstatic size_t parport_pc_ecpepp_write_data(struct parport *port,\r\nconst void *buf, size_t length,\r\nint flags)\r\n{\r\nsize_t written;\r\nfrob_set_mode(port, ECR_EPP);\r\nparport_pc_write_control(port, 0x4);\r\nparport_pc_data_forward(port);\r\nwritten = parport_pc_epp_write_data(port, buf, length, flags);\r\nfrob_set_mode(port, ECR_PS2);\r\nreturn written;\r\n}\r\nstatic size_t parport_pc_ecpepp_read_addr(struct parport *port, void *buf,\r\nsize_t length, int flags)\r\n{\r\nsize_t got;\r\nfrob_set_mode(port, ECR_EPP);\r\nparport_pc_data_reverse(port);\r\nparport_pc_write_control(port, 0x4);\r\ngot = parport_pc_epp_read_addr(port, buf, length, flags);\r\nfrob_set_mode(port, ECR_PS2);\r\nreturn got;\r\n}\r\nstatic size_t parport_pc_ecpepp_write_addr(struct parport *port,\r\nconst void *buf, size_t length,\r\nint flags)\r\n{\r\nsize_t written;\r\nfrob_set_mode(port, ECR_EPP);\r\nparport_pc_write_control(port, 0x4);\r\nparport_pc_data_forward(port);\r\nwritten = parport_pc_epp_write_addr(port, buf, length, flags);\r\nfrob_set_mode(port, ECR_PS2);\r\nreturn written;\r\n}\r\nstatic size_t parport_pc_fifo_write_block_pio(struct parport *port,\r\nconst void *buf, size_t length)\r\n{\r\nint ret = 0;\r\nconst unsigned char *bufp = buf;\r\nsize_t left = length;\r\nunsigned long expire = jiffies + port->physport->cad->timeout;\r\nconst int fifo = FIFO(port);\r\nint poll_for = 8;\r\nconst struct parport_pc_private *priv = port->physport->private_data;\r\nconst int fifo_depth = priv->fifo_depth;\r\nport = port->physport;\r\nparport_pc_disable_irq(port);\r\nfrob_econtrol(port, (1<<4) | (1<<2), (1<<4) | (1<<2));\r\nparport_pc_data_forward(port);\r\nwhile (left) {\r\nunsigned char byte;\r\nunsigned char ecrval = inb(ECONTROL(port));\r\nint i = 0;\r\nif (need_resched() && time_before(jiffies, expire))\r\nschedule();\r\nif (port->waithead) {\r\nprintk(KERN_DEBUG "Somebody wants the port\n");\r\nbreak;\r\n}\r\nif (ecrval & 0x02) {\r\nECR_WRITE(port, ecrval & ~(1<<2));\r\nfalse_alarm:\r\nret = parport_wait_event(port, HZ);\r\nif (ret < 0)\r\nbreak;\r\nret = 0;\r\nif (!time_before(jiffies, expire)) {\r\nprintk(KERN_DEBUG "FIFO write timed out\n");\r\nbreak;\r\n}\r\necrval = inb(ECONTROL(port));\r\nif (!(ecrval & (1<<2))) {\r\nif (need_resched() &&\r\ntime_before(jiffies, expire))\r\nschedule();\r\ngoto false_alarm;\r\n}\r\ncontinue;\r\n}\r\nexpire = jiffies + port->cad->timeout;\r\npoll:\r\nif (signal_pending(current))\r\nbreak;\r\nif (ecrval & 0x01) {\r\nconst int n = left < fifo_depth ? left : fifo_depth;\r\noutsb(fifo, bufp, n);\r\nbufp += n;\r\nleft -= n;\r\nif (i < (poll_for - 2))\r\npoll_for--;\r\ncontinue;\r\n} else if (i++ < poll_for) {\r\nudelay(10);\r\necrval = inb(ECONTROL(port));\r\ngoto poll;\r\n}\r\nbyte = *bufp++;\r\noutb(byte, fifo);\r\nleft--;\r\n}\r\ndump_parport_state("leave fifo_write_block_pio", port);\r\nreturn length - left;\r\n}\r\nstatic size_t parport_pc_fifo_write_block_dma(struct parport *port,\r\nconst void *buf, size_t length)\r\n{\r\nint ret = 0;\r\nunsigned long dmaflag;\r\nsize_t left = length;\r\nconst struct parport_pc_private *priv = port->physport->private_data;\r\nstruct device *dev = port->physport->dev;\r\ndma_addr_t dma_addr, dma_handle;\r\nsize_t maxlen = 0x10000;\r\nunsigned long start = (unsigned long) buf;\r\nunsigned long end = (unsigned long) buf + length - 1;\r\ndump_parport_state("enter fifo_write_block_dma", port);\r\nif (end < MAX_DMA_ADDRESS) {\r\nif ((start ^ end) & ~0xffffUL)\r\nmaxlen = 0x10000 - (start & 0xffff);\r\ndma_addr = dma_handle = dma_map_single(dev, (void *)buf, length,\r\nDMA_TO_DEVICE);\r\n} else {\r\nmaxlen = PAGE_SIZE;\r\ndma_addr = priv->dma_handle;\r\ndma_handle = 0;\r\n}\r\nport = port->physport;\r\nparport_pc_disable_irq(port);\r\nfrob_econtrol(port, (1<<4) | (1<<2), (1<<4) | (1<<2));\r\nparport_pc_data_forward(port);\r\nwhile (left) {\r\nunsigned long expire = jiffies + port->physport->cad->timeout;\r\nsize_t count = left;\r\nif (count > maxlen)\r\ncount = maxlen;\r\nif (!dma_handle)\r\nmemcpy(priv->dma_buf, buf, count);\r\ndmaflag = claim_dma_lock();\r\ndisable_dma(port->dma);\r\nclear_dma_ff(port->dma);\r\nset_dma_mode(port->dma, DMA_MODE_WRITE);\r\nset_dma_addr(port->dma, dma_addr);\r\nset_dma_count(port->dma, count);\r\nfrob_econtrol(port, 1<<3, 1<<3);\r\nfrob_econtrol(port, 1<<2, 0);\r\nenable_dma(port->dma);\r\nrelease_dma_lock(dmaflag);\r\nleft -= count;\r\nbuf += count;\r\nif (dma_handle)\r\ndma_addr += count;\r\nfalse_alarm:\r\nret = parport_wait_event(port, HZ);\r\nif (ret < 0)\r\nbreak;\r\nret = 0;\r\nif (!time_before(jiffies, expire)) {\r\nprintk(KERN_DEBUG "DMA write timed out\n");\r\nbreak;\r\n}\r\nif (!(inb(ECONTROL(port)) & (1<<2))) {\r\ncond_resched();\r\ngoto false_alarm;\r\n}\r\ndmaflag = claim_dma_lock();\r\ndisable_dma(port->dma);\r\nclear_dma_ff(port->dma);\r\ncount = get_dma_residue(port->dma);\r\nrelease_dma_lock(dmaflag);\r\ncond_resched();\r\nif (port->waithead) {\r\nprintk(KERN_DEBUG "Somebody wants the port\n");\r\nbreak;\r\n}\r\nbuf -= count;\r\nleft += count;\r\nif (dma_handle)\r\ndma_addr -= count;\r\n}\r\ndmaflag = claim_dma_lock();\r\ndisable_dma(port->dma);\r\nclear_dma_ff(port->dma);\r\nleft += get_dma_residue(port->dma);\r\nrelease_dma_lock(dmaflag);\r\nfrob_econtrol(port, 1<<3, 0);\r\nif (dma_handle)\r\ndma_unmap_single(dev, dma_handle, length, DMA_TO_DEVICE);\r\ndump_parport_state("leave fifo_write_block_dma", port);\r\nreturn length - left;\r\n}\r\nstatic inline size_t parport_pc_fifo_write_block(struct parport *port,\r\nconst void *buf, size_t length)\r\n{\r\n#ifdef HAS_DMA\r\nif (port->dma != PARPORT_DMA_NONE)\r\nreturn parport_pc_fifo_write_block_dma(port, buf, length);\r\n#endif\r\nreturn parport_pc_fifo_write_block_pio(port, buf, length);\r\n}\r\nstatic size_t parport_pc_compat_write_block_pio(struct parport *port,\r\nconst void *buf, size_t length,\r\nint flags)\r\n{\r\nsize_t written;\r\nint r;\r\nunsigned long expire;\r\nconst struct parport_pc_private *priv = port->physport->private_data;\r\nif (port->physport->cad->timeout <= PARPORT_INACTIVITY_O_NONBLOCK)\r\nreturn parport_ieee1284_write_compat(port, buf,\r\nlength, flags);\r\nparport_pc_data_forward(port);\r\nparport_pc_frob_control(port, PARPORT_CONTROL_STROBE, 0);\r\nr = change_mode(port, ECR_PPF);\r\nif (r)\r\nprintk(KERN_DEBUG "%s: Warning change_mode ECR_PPF failed\n",\r\nport->name);\r\nport->physport->ieee1284.phase = IEEE1284_PH_FWD_DATA;\r\nwritten = parport_pc_fifo_write_block(port, buf, length);\r\nexpire = jiffies + (priv->fifo_depth * HZ * 4);\r\ndo {\r\nr = change_mode(port, ECR_PS2);\r\nif (r != -EBUSY)\r\nbreak;\r\n} while (time_before(jiffies, expire));\r\nif (r == -EBUSY) {\r\nprintk(KERN_DEBUG "%s: FIFO is stuck\n", port->name);\r\nfrob_set_mode(port, ECR_TST);\r\nfor (written -= priv->fifo_depth; ; written++) {\r\nif (inb(ECONTROL(port)) & 0x2) {\r\nbreak;\r\n}\r\noutb(0, FIFO(port));\r\n}\r\nfrob_set_mode(port, ECR_PS2);\r\n}\r\nr = parport_wait_peripheral(port,\r\nPARPORT_STATUS_BUSY,\r\nPARPORT_STATUS_BUSY);\r\nif (r)\r\nprintk(KERN_DEBUG\r\n"%s: BUSY timeout (%d) in compat_write_block_pio\n",\r\nport->name, r);\r\nport->physport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\r\nreturn written;\r\n}\r\nstatic size_t parport_pc_ecp_write_block_pio(struct parport *port,\r\nconst void *buf, size_t length,\r\nint flags)\r\n{\r\nsize_t written;\r\nint r;\r\nunsigned long expire;\r\nconst struct parport_pc_private *priv = port->physport->private_data;\r\nif (port->physport->cad->timeout <= PARPORT_INACTIVITY_O_NONBLOCK)\r\nreturn parport_ieee1284_ecp_write_data(port, buf,\r\nlength, flags);\r\nif (port->physport->ieee1284.phase != IEEE1284_PH_FWD_IDLE) {\r\nparport_frob_control(port,\r\nPARPORT_CONTROL_INIT\r\n| PARPORT_CONTROL_AUTOFD,\r\nPARPORT_CONTROL_INIT\r\n| PARPORT_CONTROL_AUTOFD);\r\nr = parport_wait_peripheral(port,\r\nPARPORT_STATUS_PAPEROUT,\r\nPARPORT_STATUS_PAPEROUT);\r\nif (r) {\r\nprintk(KERN_DEBUG "%s: PError timeout (%d) "\r\n"in ecp_write_block_pio\n", port->name, r);\r\n}\r\n}\r\nparport_pc_data_forward(port);\r\nparport_pc_frob_control(port,\r\nPARPORT_CONTROL_STROBE |\r\nPARPORT_CONTROL_AUTOFD,\r\n0);\r\nr = change_mode(port, ECR_ECP);\r\nif (r)\r\nprintk(KERN_DEBUG "%s: Warning change_mode ECR_ECP failed\n",\r\nport->name);\r\nport->physport->ieee1284.phase = IEEE1284_PH_FWD_DATA;\r\nwritten = parport_pc_fifo_write_block(port, buf, length);\r\nexpire = jiffies + (priv->fifo_depth * (HZ * 4));\r\ndo {\r\nr = change_mode(port, ECR_PS2);\r\nif (r != -EBUSY)\r\nbreak;\r\n} while (time_before(jiffies, expire));\r\nif (r == -EBUSY) {\r\nprintk(KERN_DEBUG "%s: FIFO is stuck\n", port->name);\r\nfrob_set_mode(port, ECR_TST);\r\nfor (written -= priv->fifo_depth; ; written++) {\r\nif (inb(ECONTROL(port)) & 0x2) {\r\nbreak;\r\n}\r\noutb(0, FIFO(port));\r\n}\r\nfrob_set_mode(port, ECR_PS2);\r\nparport_pc_data_reverse(port);\r\nudelay(5);\r\nparport_frob_control(port, PARPORT_CONTROL_INIT, 0);\r\nr = parport_wait_peripheral(port, PARPORT_STATUS_PAPEROUT, 0);\r\nif (r)\r\nprintk(KERN_DEBUG "%s: PE,1 timeout (%d) "\r\n"in ecp_write_block_pio\n", port->name, r);\r\nparport_frob_control(port,\r\nPARPORT_CONTROL_INIT,\r\nPARPORT_CONTROL_INIT);\r\nr = parport_wait_peripheral(port,\r\nPARPORT_STATUS_PAPEROUT,\r\nPARPORT_STATUS_PAPEROUT);\r\nif (r)\r\nprintk(KERN_DEBUG "%s: PE,2 timeout (%d) "\r\n"in ecp_write_block_pio\n", port->name, r);\r\n}\r\nr = parport_wait_peripheral(port,\r\nPARPORT_STATUS_BUSY,\r\nPARPORT_STATUS_BUSY);\r\nif (r)\r\nprintk(KERN_DEBUG\r\n"%s: BUSY timeout (%d) in ecp_write_block_pio\n",\r\nport->name, r);\r\nport->physport->ieee1284.phase = IEEE1284_PH_FWD_IDLE;\r\nreturn written;\r\n}\r\nstatic struct superio_struct *find_free_superio(void)\r\n{\r\nint i;\r\nfor (i = 0; i < NR_SUPERIOS; i++)\r\nif (superios[i].io == 0)\r\nreturn &superios[i];\r\nreturn NULL;\r\n}\r\nstatic void show_parconfig_smsc37c669(int io, int key)\r\n{\r\nint cr1, cr4, cra, cr23, cr26, cr27;\r\nstruct superio_struct *s;\r\nstatic const char *const modes[] = {\r\n"SPP and Bidirectional (PS/2)",\r\n"EPP and SPP",\r\n"ECP",\r\n"ECP and EPP" };\r\noutb(key, io);\r\noutb(key, io);\r\noutb(1, io);\r\ncr1 = inb(io + 1);\r\noutb(4, io);\r\ncr4 = inb(io + 1);\r\noutb(0x0a, io);\r\ncra = inb(io + 1);\r\noutb(0x23, io);\r\ncr23 = inb(io + 1);\r\noutb(0x26, io);\r\ncr26 = inb(io + 1);\r\noutb(0x27, io);\r\ncr27 = inb(io + 1);\r\noutb(0xaa, io);\r\nif (verbose_probing) {\r\nprintk(KERN_INFO\r\n"SMSC 37c669 LPT Config: cr_1=0x%02x, 4=0x%02x, "\r\n"A=0x%2x, 23=0x%02x, 26=0x%02x, 27=0x%02x\n",\r\ncr1, cr4, cra, cr23, cr26, cr27);\r\nprintk(KERN_INFO\r\n"SMSC LPT Config: io=0x%04x, irq=%c, dma=%c, fifo threshold=%d\n",\r\ncr23 * 4,\r\n(cr27 & 0x0f) ? 'A' - 1 + (cr27 & 0x0f) : '-',\r\n(cr26 & 0x0f) ? 'A' - 1 + (cr26 & 0x0f) : '-',\r\ncra & 0x0f);\r\nprintk(KERN_INFO "SMSC LPT Config: enabled=%s power=%s\n",\r\n(cr23 * 4 >= 0x100) ? "yes" : "no",\r\n(cr1 & 4) ? "yes" : "no");\r\nprintk(KERN_INFO\r\n"SMSC LPT Config: Port mode=%s, EPP version =%s\n",\r\n(cr1 & 0x08) ? "Standard mode only (SPP)"\r\n: modes[cr4 & 0x03],\r\n(cr4 & 0x40) ? "1.7" : "1.9");\r\n}\r\nif (cr23 * 4 >= 0x100) {\r\ns = find_free_superio();\r\nif (s == NULL)\r\nprintk(KERN_INFO "Super-IO: too many chips!\n");\r\nelse {\r\nint d;\r\nswitch (cr23 * 4) {\r\ncase 0x3bc:\r\ns->io = 0x3bc;\r\ns->irq = 7;\r\nbreak;\r\ncase 0x378:\r\ns->io = 0x378;\r\ns->irq = 7;\r\nbreak;\r\ncase 0x278:\r\ns->io = 0x278;\r\ns->irq = 5;\r\n}\r\nd = (cr26 & 0x0f);\r\nif (d == 1 || d == 3)\r\ns->dma = d;\r\nelse\r\ns->dma = PARPORT_DMA_NONE;\r\n}\r\n}\r\n}\r\nstatic void show_parconfig_winbond(int io, int key)\r\n{\r\nint cr30, cr60, cr61, cr70, cr74, crf0;\r\nstruct superio_struct *s;\r\nstatic const char *const modes[] = {\r\n"Standard (SPP) and Bidirectional(PS/2)",\r\n"EPP-1.9 and SPP",\r\n"ECP",\r\n"ECP and EPP-1.9",\r\n"Standard (SPP)",\r\n"EPP-1.7 and SPP",\r\n"undefined!",\r\n"ECP and EPP-1.7" };\r\nstatic char *const irqtypes[] = {\r\n"pulsed low, high-Z",\r\n"follows nACK" };\r\noutb(key, io);\r\noutb(key, io);\r\noutb(0x07, io);\r\noutb(0x01, io + 1);\r\noutb(0x30, io);\r\ncr30 = inb(io + 1);\r\noutb(0x60, io);\r\ncr60 = inb(io + 1);\r\noutb(0x61, io);\r\ncr61 = inb(io + 1);\r\noutb(0x70, io);\r\ncr70 = inb(io + 1);\r\noutb(0x74, io);\r\ncr74 = inb(io + 1);\r\noutb(0xf0, io);\r\ncrf0 = inb(io + 1);\r\noutb(0xaa, io);\r\nif (verbose_probing) {\r\nprintk(KERN_INFO\r\n"Winbond LPT Config: cr_30=%02x 60,61=%02x%02x 70=%02x 74=%02x, f0=%02x\n",\r\ncr30, cr60, cr61, cr70, cr74, crf0);\r\nprintk(KERN_INFO "Winbond LPT Config: active=%s, io=0x%02x%02x irq=%d, ",\r\n(cr30 & 0x01) ? "yes" : "no", cr60, cr61, cr70 & 0x0f);\r\nif ((cr74 & 0x07) > 3)\r\nprintk("dma=none\n");\r\nelse\r\nprintk("dma=%d\n", cr74 & 0x07);\r\nprintk(KERN_INFO\r\n"Winbond LPT Config: irqtype=%s, ECP fifo threshold=%d\n",\r\nirqtypes[crf0>>7], (crf0>>3)&0x0f);\r\nprintk(KERN_INFO "Winbond LPT Config: Port mode=%s\n",\r\nmodes[crf0 & 0x07]);\r\n}\r\nif (cr30 & 0x01) {\r\ns = find_free_superio();\r\nif (s == NULL)\r\nprintk(KERN_INFO "Super-IO: too many chips!\n");\r\nelse {\r\ns->io = (cr60 << 8) | cr61;\r\ns->irq = cr70 & 0x0f;\r\ns->dma = (((cr74 & 0x07) > 3) ?\r\nPARPORT_DMA_NONE : (cr74 & 0x07));\r\n}\r\n}\r\n}\r\nstatic void decode_winbond(int efer, int key, int devid, int devrev, int oldid)\r\n{\r\nconst char *type = "unknown";\r\nint id, progif = 2;\r\nif (devid == devrev)\r\nreturn;\r\nid = (devid << 8) | devrev;\r\nif (id == 0x9771)\r\ntype = "83977F/AF";\r\nelse if (id == 0x9773)\r\ntype = "83977TF / SMSC 97w33x/97w34x";\r\nelse if (id == 0x9774)\r\ntype = "83977ATF";\r\nelse if ((id & ~0x0f) == 0x5270)\r\ntype = "83977CTF / SMSC 97w36x";\r\nelse if ((id & ~0x0f) == 0x52f0)\r\ntype = "83977EF / SMSC 97w35x";\r\nelse if ((id & ~0x0f) == 0x5210)\r\ntype = "83627";\r\nelse if ((id & ~0x0f) == 0x6010)\r\ntype = "83697HF";\r\nelse if ((oldid & 0x0f) == 0x0a) {\r\ntype = "83877F";\r\nprogif = 1;\r\n} else if ((oldid & 0x0f) == 0x0b) {\r\ntype = "83877AF";\r\nprogif = 1;\r\n} else if ((oldid & 0x0f) == 0x0c) {\r\ntype = "83877TF";\r\nprogif = 1;\r\n} else if ((oldid & 0x0f) == 0x0d) {\r\ntype = "83877ATF";\r\nprogif = 1;\r\n} else\r\nprogif = 0;\r\nif (verbose_probing)\r\nprintk(KERN_INFO "Winbond chip at EFER=0x%x key=0x%02x "\r\n"devid=%02x devrev=%02x oldid=%02x type=%s\n",\r\nefer, key, devid, devrev, oldid, type);\r\nif (progif == 2)\r\nshow_parconfig_winbond(efer, key);\r\n}\r\nstatic void decode_smsc(int efer, int key, int devid, int devrev)\r\n{\r\nconst char *type = "unknown";\r\nvoid (*func)(int io, int key);\r\nint id;\r\nif (devid == devrev)\r\nreturn;\r\nfunc = NULL;\r\nid = (devid << 8) | devrev;\r\nif (id == 0x0302) {\r\ntype = "37c669";\r\nfunc = show_parconfig_smsc37c669;\r\n} else if (id == 0x6582)\r\ntype = "37c665IR";\r\nelse if (devid == 0x65)\r\ntype = "37c665GT";\r\nelse if (devid == 0x66)\r\ntype = "37c666GT";\r\nif (verbose_probing)\r\nprintk(KERN_INFO "SMSC chip at EFER=0x%x "\r\n"key=0x%02x devid=%02x devrev=%02x type=%s\n",\r\nefer, key, devid, devrev, type);\r\nif (func)\r\nfunc(efer, key);\r\n}\r\nstatic void winbond_check(int io, int key)\r\n{\r\nint origval, devid, devrev, oldid, x_devid, x_devrev, x_oldid;\r\nif (!request_region(io, 3, __func__))\r\nreturn;\r\norigval = inb(io);\r\noutb(0x20, io);\r\nx_devid = inb(io + 1);\r\noutb(0x21, io);\r\nx_devrev = inb(io + 1);\r\noutb(0x09, io);\r\nx_oldid = inb(io + 1);\r\noutb(key, io);\r\noutb(key, io);\r\noutb(0x20, io);\r\ndevid = inb(io + 1);\r\noutb(0x21, io);\r\ndevrev = inb(io + 1);\r\noutb(0x09, io);\r\noldid = inb(io + 1);\r\noutb(0xaa, io);\r\noutb(origval, io);\r\nif ((x_devid == devid) && (x_devrev == devrev) && (x_oldid == oldid))\r\ngoto out;\r\ndecode_winbond(io, key, devid, devrev, oldid);\r\nout:\r\nrelease_region(io, 3);\r\n}\r\nstatic void winbond_check2(int io, int key)\r\n{\r\nint origval[3], devid, devrev, oldid, x_devid, x_devrev, x_oldid;\r\nif (!request_region(io, 3, __func__))\r\nreturn;\r\norigval[0] = inb(io);\r\norigval[1] = inb(io + 1);\r\norigval[2] = inb(io + 2);\r\noutb(0x20, io + 2);\r\nx_devid = inb(io + 2);\r\noutb(0x21, io + 1);\r\nx_devrev = inb(io + 2);\r\noutb(0x09, io + 1);\r\nx_oldid = inb(io + 2);\r\noutb(key, io);\r\noutb(0x20, io + 2);\r\ndevid = inb(io + 2);\r\noutb(0x21, io + 1);\r\ndevrev = inb(io + 2);\r\noutb(0x09, io + 1);\r\noldid = inb(io + 2);\r\noutb(0xaa, io);\r\noutb(origval[0], io);\r\noutb(origval[1], io + 1);\r\noutb(origval[2], io + 2);\r\nif (x_devid == devid && x_devrev == devrev && x_oldid == oldid)\r\ngoto out;\r\ndecode_winbond(io, key, devid, devrev, oldid);\r\nout:\r\nrelease_region(io, 3);\r\n}\r\nstatic void smsc_check(int io, int key)\r\n{\r\nint origval, id, rev, oldid, oldrev, x_id, x_rev, x_oldid, x_oldrev;\r\nif (!request_region(io, 3, __func__))\r\nreturn;\r\norigval = inb(io);\r\noutb(0x0d, io);\r\nx_oldid = inb(io + 1);\r\noutb(0x0e, io);\r\nx_oldrev = inb(io + 1);\r\noutb(0x20, io);\r\nx_id = inb(io + 1);\r\noutb(0x21, io);\r\nx_rev = inb(io + 1);\r\noutb(key, io);\r\noutb(key, io);\r\noutb(0x0d, io);\r\noldid = inb(io + 1);\r\noutb(0x0e, io);\r\noldrev = inb(io + 1);\r\noutb(0x20, io);\r\nid = inb(io + 1);\r\noutb(0x21, io);\r\nrev = inb(io + 1);\r\noutb(0xaa, io);\r\noutb(origval, io);\r\nif (x_id == id && x_oldrev == oldrev &&\r\nx_oldid == oldid && x_rev == rev)\r\ngoto out;\r\ndecode_smsc(io, key, oldid, oldrev);\r\nout:\r\nrelease_region(io, 3);\r\n}\r\nstatic void detect_and_report_winbond(void)\r\n{\r\nif (verbose_probing)\r\nprintk(KERN_DEBUG "Winbond Super-IO detection, now testing ports 3F0,370,250,4E,2E ...\n");\r\nwinbond_check(0x3f0, 0x87);\r\nwinbond_check(0x370, 0x87);\r\nwinbond_check(0x2e , 0x87);\r\nwinbond_check(0x4e , 0x87);\r\nwinbond_check(0x3f0, 0x86);\r\nwinbond_check2(0x250, 0x88);\r\nwinbond_check2(0x250, 0x89);\r\n}\r\nstatic void detect_and_report_smsc(void)\r\n{\r\nif (verbose_probing)\r\nprintk(KERN_DEBUG "SMSC Super-IO detection, now testing Ports 2F0, 370 ...\n");\r\nsmsc_check(0x3f0, 0x55);\r\nsmsc_check(0x370, 0x55);\r\nsmsc_check(0x3f0, 0x44);\r\nsmsc_check(0x370, 0x44);\r\n}\r\nstatic void detect_and_report_it87(void)\r\n{\r\nu16 dev;\r\nu8 origval, r;\r\nif (verbose_probing)\r\nprintk(KERN_DEBUG "IT8705 Super-IO detection, now testing port 2E ...\n");\r\nif (!request_muxed_region(0x2e, 2, __func__))\r\nreturn;\r\norigval = inb(0x2e);\r\noutb(0x87, 0x2e);\r\noutb(0x01, 0x2e);\r\noutb(0x55, 0x2e);\r\noutb(0x55, 0x2e);\r\noutb(0x20, 0x2e);\r\ndev = inb(0x2f) << 8;\r\noutb(0x21, 0x2e);\r\ndev |= inb(0x2f);\r\nif (dev == 0x8712 || dev == 0x8705 || dev == 0x8715 ||\r\ndev == 0x8716 || dev == 0x8718 || dev == 0x8726) {\r\nprintk(KERN_INFO "IT%04X SuperIO detected.\n", dev);\r\noutb(0x07, 0x2E);\r\noutb(0x03, 0x2F);\r\noutb(0xF0, 0x2E);\r\nr = inb(0x2f);\r\noutb(0xF0, 0x2E);\r\noutb(r | 8, 0x2F);\r\noutb(0x02, 0x2E);\r\noutb(0x02, 0x2F);\r\n} else {\r\noutb(origval, 0x2e);\r\n}\r\nrelease_region(0x2e, 2);\r\n}\r\nstatic struct superio_struct *find_superio(struct parport *p)\r\n{\r\nint i;\r\nfor (i = 0; i < NR_SUPERIOS; i++)\r\nif (superios[i].io != p->base)\r\nreturn &superios[i];\r\nreturn NULL;\r\n}\r\nstatic int get_superio_dma(struct parport *p)\r\n{\r\nstruct superio_struct *s = find_superio(p);\r\nif (s)\r\nreturn s->dma;\r\nreturn PARPORT_DMA_NONE;\r\n}\r\nstatic int get_superio_irq(struct parport *p)\r\n{\r\nstruct superio_struct *s = find_superio(p);\r\nif (s)\r\nreturn s->irq;\r\nreturn PARPORT_IRQ_NONE;\r\n}\r\nstatic int parport_SPP_supported(struct parport *pb)\r\n{\r\nunsigned char r, w;\r\nclear_epp_timeout(pb);\r\nw = 0xc;\r\noutb(w, CONTROL(pb));\r\nr = inb(CONTROL(pb));\r\nif ((r & 0xf) == w) {\r\nw = 0xe;\r\noutb(w, CONTROL(pb));\r\nr = inb(CONTROL(pb));\r\noutb(0xc, CONTROL(pb));\r\nif ((r & 0xf) == w)\r\nreturn PARPORT_MODE_PCSPP;\r\n}\r\nif (user_specified)\r\nprintk(KERN_INFO "parport 0x%lx (WARNING): CTR: "\r\n"wrote 0x%02x, read 0x%02x\n", pb->base, w, r);\r\nw = 0xaa;\r\nparport_pc_write_data(pb, w);\r\nr = parport_pc_read_data(pb);\r\nif (r == w) {\r\nw = 0x55;\r\nparport_pc_write_data(pb, w);\r\nr = parport_pc_read_data(pb);\r\nif (r == w)\r\nreturn PARPORT_MODE_PCSPP;\r\n}\r\nif (user_specified) {\r\nprintk(KERN_INFO "parport 0x%lx (WARNING): DATA: "\r\n"wrote 0x%02x, read 0x%02x\n", pb->base, w, r);\r\nprintk(KERN_INFO "parport 0x%lx: You gave this address, "\r\n"but there is probably no parallel port there!\n",\r\npb->base);\r\n}\r\nif (user_specified)\r\nreturn PARPORT_MODE_PCSPP;\r\nreturn 0;\r\n}\r\nstatic int parport_ECR_present(struct parport *pb)\r\n{\r\nstruct parport_pc_private *priv = pb->private_data;\r\nunsigned char r = 0xc;\r\noutb(r, CONTROL(pb));\r\nif ((inb(ECONTROL(pb)) & 0x3) == (r & 0x3)) {\r\noutb(r ^ 0x2, CONTROL(pb));\r\nr = inb(CONTROL(pb));\r\nif ((inb(ECONTROL(pb)) & 0x2) == (r & 0x2))\r\ngoto no_reg;\r\n}\r\nif ((inb(ECONTROL(pb)) & 0x3) != 0x1)\r\ngoto no_reg;\r\nECR_WRITE(pb, 0x34);\r\nif (inb(ECONTROL(pb)) != 0x35)\r\ngoto no_reg;\r\npriv->ecr = 1;\r\noutb(0xc, CONTROL(pb));\r\nfrob_set_mode(pb, ECR_SPP);\r\nreturn 1;\r\nno_reg:\r\noutb(0xc, CONTROL(pb));\r\nreturn 0;\r\n}\r\nstatic int parport_PS2_supported(struct parport *pb)\r\n{\r\nint ok = 0;\r\nclear_epp_timeout(pb);\r\nparport_pc_data_reverse(pb);\r\nparport_pc_write_data(pb, 0x55);\r\nif (parport_pc_read_data(pb) != 0x55)\r\nok++;\r\nparport_pc_write_data(pb, 0xaa);\r\nif (parport_pc_read_data(pb) != 0xaa)\r\nok++;\r\nparport_pc_data_forward(pb);\r\nif (ok) {\r\npb->modes |= PARPORT_MODE_TRISTATE;\r\n} else {\r\nstruct parport_pc_private *priv = pb->private_data;\r\npriv->ctr_writable &= ~0x20;\r\n}\r\nreturn ok;\r\n}\r\nstatic int parport_ECP_supported(struct parport *pb)\r\n{\r\nint i;\r\nint config, configb;\r\nint pword;\r\nstruct parport_pc_private *priv = pb->private_data;\r\nstatic const int intrline[] = { 0, 7, 9, 10, 11, 14, 15, 5 };\r\nif (!priv->ecr)\r\nreturn 0;\r\nECR_WRITE(pb, ECR_SPP << 5);\r\nECR_WRITE(pb, ECR_TST << 5);\r\nfor (i = 0; i < 1024 && !(inb(ECONTROL(pb)) & 0x02); i++)\r\noutb(0xaa, FIFO(pb));\r\nif (i == 1024) {\r\nECR_WRITE(pb, ECR_SPP << 5);\r\nreturn 0;\r\n}\r\npriv->fifo_depth = i;\r\nif (verbose_probing)\r\nprintk(KERN_DEBUG "0x%lx: FIFO is %d bytes\n", pb->base, i);\r\nfrob_econtrol(pb, 1<<2, 1<<2);\r\nfrob_econtrol(pb, 1<<2, 0);\r\nfor (i = 1; i <= priv->fifo_depth; i++) {\r\ninb(FIFO(pb));\r\nudelay(50);\r\nif (inb(ECONTROL(pb)) & (1<<2))\r\nbreak;\r\n}\r\nif (i <= priv->fifo_depth) {\r\nif (verbose_probing)\r\nprintk(KERN_DEBUG "0x%lx: writeIntrThreshold is %d\n",\r\npb->base, i);\r\n} else\r\ni = 0;\r\npriv->writeIntrThreshold = i;\r\nfrob_set_mode(pb, ECR_PS2);\r\nparport_pc_data_reverse(pb);\r\nfrob_set_mode(pb, ECR_TST);\r\nfrob_econtrol(pb, 1<<2, 1<<2);\r\nfrob_econtrol(pb, 1<<2, 0);\r\nfor (i = 1; i <= priv->fifo_depth; i++) {\r\noutb(0xaa, FIFO(pb));\r\nif (inb(ECONTROL(pb)) & (1<<2))\r\nbreak;\r\n}\r\nif (i <= priv->fifo_depth) {\r\nif (verbose_probing)\r\nprintk(KERN_INFO "0x%lx: readIntrThreshold is %d\n",\r\npb->base, i);\r\n} else\r\ni = 0;\r\npriv->readIntrThreshold = i;\r\nECR_WRITE(pb, ECR_SPP << 5);\r\nECR_WRITE(pb, 0xf4);\r\nconfig = inb(CONFIGA(pb));\r\npword = (config >> 4) & 0x7;\r\nswitch (pword) {\r\ncase 0:\r\npword = 2;\r\nprintk(KERN_WARNING "0x%lx: Unsupported pword size!\n",\r\npb->base);\r\nbreak;\r\ncase 2:\r\npword = 4;\r\nprintk(KERN_WARNING "0x%lx: Unsupported pword size!\n",\r\npb->base);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "0x%lx: Unknown implementation ID\n",\r\npb->base);\r\ncase 1:\r\npword = 1;\r\n}\r\npriv->pword = pword;\r\nif (verbose_probing) {\r\nprintk(KERN_DEBUG "0x%lx: PWord is %d bits\n",\r\npb->base, 8 * pword);\r\nprintk(KERN_DEBUG "0x%lx: Interrupts are ISA-%s\n", pb->base,\r\nconfig & 0x80 ? "Level" : "Pulses");\r\nconfigb = inb(CONFIGB(pb));\r\nprintk(KERN_DEBUG "0x%lx: ECP port cfgA=0x%02x cfgB=0x%02x\n",\r\npb->base, config, configb);\r\nprintk(KERN_DEBUG "0x%lx: ECP settings irq=", pb->base);\r\nif ((configb >> 3) & 0x07)\r\nprintk("%d", intrline[(configb >> 3) & 0x07]);\r\nelse\r\nprintk("<none or set by other means>");\r\nprintk(" dma=");\r\nif ((configb & 0x03) == 0x00)\r\nprintk("<none or set by other means>\n");\r\nelse\r\nprintk("%d\n", configb & 0x07);\r\n}\r\nfrob_set_mode(pb, ECR_SPP);\r\nreturn 1;\r\n}\r\nstatic int intel_bug_present_check_epp(struct parport *pb)\r\n{\r\nconst struct parport_pc_private *priv = pb->private_data;\r\nint bug_present = 0;\r\nif (priv->ecr) {\r\nunsigned char ecr = inb(ECONTROL(pb));\r\nunsigned char i;\r\nfor (i = 0x00; i < 0x80; i += 0x20) {\r\nECR_WRITE(pb, i);\r\nif (clear_epp_timeout(pb)) {\r\nbug_present = 1;\r\nbreak;\r\n}\r\n}\r\nECR_WRITE(pb, ecr);\r\n}\r\nreturn bug_present;\r\n}\r\nstatic int intel_bug_present(struct parport *pb)\r\n{\r\nif (pb->dev != NULL) {\r\nreturn 0;\r\n}\r\nreturn intel_bug_present_check_epp(pb);\r\n}\r\nstatic int intel_bug_present(struct parport *pb)\r\n{\r\nreturn 0;\r\n}\r\nstatic int parport_ECPPS2_supported(struct parport *pb)\r\n{\r\nconst struct parport_pc_private *priv = pb->private_data;\r\nint result;\r\nunsigned char oecr;\r\nif (!priv->ecr)\r\nreturn 0;\r\noecr = inb(ECONTROL(pb));\r\nECR_WRITE(pb, ECR_PS2 << 5);\r\nresult = parport_PS2_supported(pb);\r\nECR_WRITE(pb, oecr);\r\nreturn result;\r\n}\r\nstatic int parport_EPP_supported(struct parport *pb)\r\n{\r\nif (!clear_epp_timeout(pb))\r\nreturn 0;\r\nif (intel_bug_present(pb))\r\nreturn 0;\r\npb->modes |= PARPORT_MODE_EPP;\r\npb->ops->epp_read_data = parport_pc_epp_read_data;\r\npb->ops->epp_write_data = parport_pc_epp_write_data;\r\npb->ops->epp_read_addr = parport_pc_epp_read_addr;\r\npb->ops->epp_write_addr = parport_pc_epp_write_addr;\r\nreturn 1;\r\n}\r\nstatic int parport_ECPEPP_supported(struct parport *pb)\r\n{\r\nstruct parport_pc_private *priv = pb->private_data;\r\nint result;\r\nunsigned char oecr;\r\nif (!priv->ecr)\r\nreturn 0;\r\noecr = inb(ECONTROL(pb));\r\nECR_WRITE(pb, 0x80);\r\noutb(0x04, CONTROL(pb));\r\nresult = parport_EPP_supported(pb);\r\nECR_WRITE(pb, oecr);\r\nif (result) {\r\npb->ops->epp_read_data = parport_pc_ecpepp_read_data;\r\npb->ops->epp_write_data = parport_pc_ecpepp_write_data;\r\npb->ops->epp_read_addr = parport_pc_ecpepp_read_addr;\r\npb->ops->epp_write_addr = parport_pc_ecpepp_write_addr;\r\n}\r\nreturn result;\r\n}\r\nstatic int parport_PS2_supported(struct parport *pb) { return 0; }\r\nstatic int parport_ECP_supported(struct parport *pb)\r\n{\r\nreturn 0;\r\n}\r\nstatic int parport_EPP_supported(struct parport *pb)\r\n{\r\nreturn 0;\r\n}\r\nstatic int parport_ECPEPP_supported(struct parport *pb)\r\n{\r\nreturn 0;\r\n}\r\nstatic int parport_ECPPS2_supported(struct parport *pb)\r\n{\r\nreturn 0;\r\n}\r\nstatic int programmable_irq_support(struct parport *pb)\r\n{\r\nint irq, intrLine;\r\nunsigned char oecr = inb(ECONTROL(pb));\r\nstatic const int lookup[8] = {\r\nPARPORT_IRQ_NONE, 7, 9, 10, 11, 14, 15, 5\r\n};\r\nECR_WRITE(pb, ECR_CNF << 5);\r\nintrLine = (inb(CONFIGB(pb)) >> 3) & 0x07;\r\nirq = lookup[intrLine];\r\nECR_WRITE(pb, oecr);\r\nreturn irq;\r\n}\r\nstatic int irq_probe_ECP(struct parport *pb)\r\n{\r\nint i;\r\nunsigned long irqs;\r\nirqs = probe_irq_on();\r\nECR_WRITE(pb, ECR_SPP << 5);\r\nECR_WRITE(pb, (ECR_TST << 5) | 0x04);\r\nECR_WRITE(pb, ECR_TST << 5);\r\nfor (i = 0; i < 1024 && !(inb(ECONTROL(pb)) & 0x02) ; i++)\r\noutb(0xaa, FIFO(pb));\r\npb->irq = probe_irq_off(irqs);\r\nECR_WRITE(pb, ECR_SPP << 5);\r\nif (pb->irq <= 0)\r\npb->irq = PARPORT_IRQ_NONE;\r\nreturn pb->irq;\r\n}\r\nstatic int irq_probe_EPP(struct parport *pb)\r\n{\r\n#ifndef ADVANCED_DETECT\r\nreturn PARPORT_IRQ_NONE;\r\n#else\r\nint irqs;\r\nunsigned char oecr;\r\nif (pb->modes & PARPORT_MODE_PCECR)\r\noecr = inb(ECONTROL(pb));\r\nirqs = probe_irq_on();\r\nif (pb->modes & PARPORT_MODE_PCECR)\r\nfrob_econtrol(pb, 0x10, 0x10);\r\nclear_epp_timeout(pb);\r\nparport_pc_frob_control(pb, 0x20, 0x20);\r\nparport_pc_frob_control(pb, 0x10, 0x10);\r\nclear_epp_timeout(pb);\r\nparport_pc_read_epp(pb);\r\nudelay(20);\r\npb->irq = probe_irq_off(irqs);\r\nif (pb->modes & PARPORT_MODE_PCECR)\r\nECR_WRITE(pb, oecr);\r\nparport_pc_write_control(pb, 0xc);\r\nif (pb->irq <= 0)\r\npb->irq = PARPORT_IRQ_NONE;\r\nreturn pb->irq;\r\n#endif\r\n}\r\nstatic int irq_probe_SPP(struct parport *pb)\r\n{\r\nreturn PARPORT_IRQ_NONE;\r\n}\r\nstatic int parport_irq_probe(struct parport *pb)\r\n{\r\nstruct parport_pc_private *priv = pb->private_data;\r\nif (priv->ecr) {\r\npb->irq = programmable_irq_support(pb);\r\nif (pb->irq == PARPORT_IRQ_NONE)\r\npb->irq = irq_probe_ECP(pb);\r\n}\r\nif ((pb->irq == PARPORT_IRQ_NONE) && priv->ecr &&\r\n(pb->modes & PARPORT_MODE_EPP))\r\npb->irq = irq_probe_EPP(pb);\r\nclear_epp_timeout(pb);\r\nif (pb->irq == PARPORT_IRQ_NONE && (pb->modes & PARPORT_MODE_EPP))\r\npb->irq = irq_probe_EPP(pb);\r\nclear_epp_timeout(pb);\r\nif (pb->irq == PARPORT_IRQ_NONE)\r\npb->irq = irq_probe_SPP(pb);\r\nif (pb->irq == PARPORT_IRQ_NONE)\r\npb->irq = get_superio_irq(pb);\r\nreturn pb->irq;\r\n}\r\nstatic int programmable_dma_support(struct parport *p)\r\n{\r\nunsigned char oecr = inb(ECONTROL(p));\r\nint dma;\r\nfrob_set_mode(p, ECR_CNF);\r\ndma = inb(CONFIGB(p)) & 0x07;\r\nif ((dma & 0x03) == 0)\r\ndma = PARPORT_DMA_NONE;\r\nECR_WRITE(p, oecr);\r\nreturn dma;\r\n}\r\nstatic int parport_dma_probe(struct parport *p)\r\n{\r\nconst struct parport_pc_private *priv = p->private_data;\r\nif (priv->ecr)\r\np->dma = programmable_dma_support(p);\r\nif (p->dma == PARPORT_DMA_NONE) {\r\np->dma = get_superio_dma(p);\r\n}\r\nreturn p->dma;\r\n}\r\nstruct parport *parport_pc_probe_port(unsigned long int base,\r\nunsigned long int base_hi,\r\nint irq, int dma,\r\nstruct device *dev,\r\nint irqflags)\r\n{\r\nstruct parport_pc_private *priv;\r\nstruct parport_operations *ops;\r\nstruct parport *p;\r\nint probedirq = PARPORT_IRQ_NONE;\r\nstruct resource *base_res;\r\nstruct resource *ECR_res = NULL;\r\nstruct resource *EPP_res = NULL;\r\nstruct platform_device *pdev = NULL;\r\nint ret;\r\nif (!dev) {\r\npdev = platform_device_register_simple("parport_pc",\r\nbase, NULL, 0);\r\nif (IS_ERR(pdev))\r\nreturn NULL;\r\ndev = &pdev->dev;\r\nret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(24));\r\nif (ret) {\r\ndev_err(dev, "Unable to set coherent dma mask: disabling DMA\n");\r\ndma = PARPORT_DMA_NONE;\r\n}\r\n}\r\nops = kmalloc(sizeof(struct parport_operations), GFP_KERNEL);\r\nif (!ops)\r\ngoto out1;\r\npriv = kmalloc(sizeof(struct parport_pc_private), GFP_KERNEL);\r\nif (!priv)\r\ngoto out2;\r\np = parport_register_port(base, irq, dma, ops);\r\nif (!p)\r\ngoto out3;\r\nbase_res = request_region(base, 3, p->name);\r\nif (!base_res)\r\ngoto out4;\r\nmemcpy(ops, &parport_pc_ops, sizeof(struct parport_operations));\r\npriv->ctr = 0xc;\r\npriv->ctr_writable = ~0x10;\r\npriv->ecr = 0;\r\npriv->fifo_depth = 0;\r\npriv->dma_buf = NULL;\r\npriv->dma_handle = 0;\r\nINIT_LIST_HEAD(&priv->list);\r\npriv->port = p;\r\np->dev = dev;\r\np->base_hi = base_hi;\r\np->modes = PARPORT_MODE_PCSPP | PARPORT_MODE_SAFEININT;\r\np->private_data = priv;\r\nif (base_hi) {\r\nECR_res = request_region(base_hi, 3, p->name);\r\nif (ECR_res)\r\nparport_ECR_present(p);\r\n}\r\nif (base != 0x3bc) {\r\nEPP_res = request_region(base+0x3, 5, p->name);\r\nif (EPP_res)\r\nif (!parport_EPP_supported(p))\r\nparport_ECPEPP_supported(p);\r\n}\r\nif (!parport_SPP_supported(p))\r\ngoto out5;\r\nif (priv->ecr)\r\nparport_ECPPS2_supported(p);\r\nelse\r\nparport_PS2_supported(p);\r\np->size = (p->modes & PARPORT_MODE_EPP) ? 8 : 3;\r\nprintk(KERN_INFO "%s: PC-style at 0x%lx", p->name, p->base);\r\nif (p->base_hi && priv->ecr)\r\nprintk(KERN_CONT " (0x%lx)", p->base_hi);\r\nif (p->irq == PARPORT_IRQ_AUTO) {\r\np->irq = PARPORT_IRQ_NONE;\r\nparport_irq_probe(p);\r\n} else if (p->irq == PARPORT_IRQ_PROBEONLY) {\r\np->irq = PARPORT_IRQ_NONE;\r\nparport_irq_probe(p);\r\nprobedirq = p->irq;\r\np->irq = PARPORT_IRQ_NONE;\r\n}\r\nif (p->irq != PARPORT_IRQ_NONE) {\r\nprintk(KERN_CONT ", irq %d", p->irq);\r\npriv->ctr_writable |= 0x10;\r\nif (p->dma == PARPORT_DMA_AUTO) {\r\np->dma = PARPORT_DMA_NONE;\r\nparport_dma_probe(p);\r\n}\r\n}\r\nif (p->dma == PARPORT_DMA_AUTO)\r\np->dma = PARPORT_DMA_NONE;\r\n#ifdef CONFIG_PARPORT_PC_FIFO\r\nif (parport_ECP_supported(p) &&\r\np->dma != PARPORT_DMA_NOFIFO &&\r\npriv->fifo_depth > 0 && p->irq != PARPORT_IRQ_NONE) {\r\np->modes |= PARPORT_MODE_ECP | PARPORT_MODE_COMPAT;\r\np->ops->compat_write_data = parport_pc_compat_write_block_pio;\r\n#ifdef CONFIG_PARPORT_1284\r\np->ops->ecp_write_data = parport_pc_ecp_write_block_pio;\r\n#endif\r\nif (p->dma != PARPORT_DMA_NONE) {\r\nprintk(KERN_CONT ", dma %d", p->dma);\r\np->modes |= PARPORT_MODE_DMA;\r\n} else\r\nprintk(KERN_CONT ", using FIFO");\r\n} else\r\np->dma = PARPORT_DMA_NONE;\r\n#endif\r\nprintk(KERN_CONT " [");\r\n#define printmode(x) \\r\n{\\r\nif (p->modes & PARPORT_MODE_##x) {\\r\nprintk(KERN_CONT "%s%s", f ? "," : "", #x);\\r\nf++;\\r\n} \\r\n}\r\n{\r\nint f = 0;\r\nprintmode(PCSPP);\r\nprintmode(TRISTATE);\r\nprintmode(COMPAT)\r\nprintmode(EPP);\r\nprintmode(ECP);\r\nprintmode(DMA);\r\n}\r\n#undef printmode\r\n#ifndef CONFIG_PARPORT_1284\r\nprintk(KERN_CONT "(,...)");\r\n#endif\r\nprintk(KERN_CONT "]\n");\r\nif (probedirq != PARPORT_IRQ_NONE)\r\nprintk(KERN_INFO "%s: irq %d detected\n", p->name, probedirq);\r\nif (ECR_res && (p->modes & PARPORT_MODE_ECP) == 0) {\r\nrelease_region(base_hi, 3);\r\nECR_res = NULL;\r\n}\r\nif (EPP_res && (p->modes & PARPORT_MODE_EPP) == 0) {\r\nrelease_region(base+3, 5);\r\nEPP_res = NULL;\r\n}\r\nif (p->irq != PARPORT_IRQ_NONE) {\r\nif (request_irq(p->irq, parport_irq_handler,\r\nirqflags, p->name, p)) {\r\nprintk(KERN_WARNING "%s: irq %d in use, "\r\n"resorting to polled operation\n",\r\np->name, p->irq);\r\np->irq = PARPORT_IRQ_NONE;\r\np->dma = PARPORT_DMA_NONE;\r\n}\r\n#ifdef CONFIG_PARPORT_PC_FIFO\r\n#ifdef HAS_DMA\r\nif (p->dma != PARPORT_DMA_NONE) {\r\nif (request_dma(p->dma, p->name)) {\r\nprintk(KERN_WARNING "%s: dma %d in use, "\r\n"resorting to PIO operation\n",\r\np->name, p->dma);\r\np->dma = PARPORT_DMA_NONE;\r\n} else {\r\npriv->dma_buf =\r\ndma_alloc_coherent(dev,\r\nPAGE_SIZE,\r\n&priv->dma_handle,\r\nGFP_KERNEL);\r\nif (!priv->dma_buf) {\r\nprintk(KERN_WARNING "%s: "\r\n"cannot get buffer for DMA, "\r\n"resorting to PIO operation\n",\r\np->name);\r\nfree_dma(p->dma);\r\np->dma = PARPORT_DMA_NONE;\r\n}\r\n}\r\n}\r\n#endif\r\n#endif\r\n}\r\nif (priv->ecr)\r\nECR_WRITE(p, 0x34);\r\nparport_pc_write_data(p, 0);\r\nparport_pc_data_forward(p);\r\nspin_lock(&ports_lock);\r\nlist_add(&priv->list, &ports_list);\r\nspin_unlock(&ports_lock);\r\nparport_announce_port(p);\r\nreturn p;\r\nout5:\r\nif (ECR_res)\r\nrelease_region(base_hi, 3);\r\nif (EPP_res)\r\nrelease_region(base+0x3, 5);\r\nrelease_region(base, 3);\r\nout4:\r\nparport_put_port(p);\r\nout3:\r\nkfree(priv);\r\nout2:\r\nkfree(ops);\r\nout1:\r\nif (pdev)\r\nplatform_device_unregister(pdev);\r\nreturn NULL;\r\n}\r\nvoid parport_pc_unregister_port(struct parport *p)\r\n{\r\nstruct parport_pc_private *priv = p->private_data;\r\nstruct parport_operations *ops = p->ops;\r\nparport_remove_port(p);\r\nspin_lock(&ports_lock);\r\nlist_del_init(&priv->list);\r\nspin_unlock(&ports_lock);\r\n#if defined(CONFIG_PARPORT_PC_FIFO) && defined(HAS_DMA)\r\nif (p->dma != PARPORT_DMA_NONE)\r\nfree_dma(p->dma);\r\n#endif\r\nif (p->irq != PARPORT_IRQ_NONE)\r\nfree_irq(p->irq, p);\r\nrelease_region(p->base, 3);\r\nif (p->size > 3)\r\nrelease_region(p->base + 3, p->size - 3);\r\nif (p->modes & PARPORT_MODE_ECP)\r\nrelease_region(p->base_hi, 3);\r\n#if defined(CONFIG_PARPORT_PC_FIFO) && defined(HAS_DMA)\r\nif (priv->dma_buf)\r\ndma_free_coherent(p->physport->dev, PAGE_SIZE,\r\npriv->dma_buf,\r\npriv->dma_handle);\r\n#endif\r\nkfree(p->private_data);\r\nparport_put_port(p);\r\nkfree(ops);\r\n}\r\nstatic int sio_ite_8872_probe(struct pci_dev *pdev, int autoirq, int autodma,\r\nconst struct parport_pc_via_data *via)\r\n{\r\nshort inta_addr[6] = { 0x2A0, 0x2C0, 0x220, 0x240, 0x1E0 };\r\nu32 ite8872set;\r\nu32 ite8872_lpt, ite8872_lpthi;\r\nu8 ite8872_irq, type;\r\nint irq;\r\nint i;\r\nDPRINTK(KERN_DEBUG "sio_ite_8872_probe()\n");\r\nfor (i = 0; i < 5; i++) {\r\nif (request_region(inta_addr[i], 32, "it887x")) {\r\nint test;\r\npci_write_config_dword(pdev, 0x60,\r\n0xe5000000 | inta_addr[i]);\r\npci_write_config_dword(pdev, 0x78,\r\n0x00000000 | inta_addr[i]);\r\ntest = inb(inta_addr[i]);\r\nif (test != 0xff)\r\nbreak;\r\nrelease_region(inta_addr[i], 32);\r\n}\r\n}\r\nif (i >= 5) {\r\nprintk(KERN_INFO "parport_pc: cannot find ITE8872 INTA\n");\r\nreturn 0;\r\n}\r\ntype = inb(inta_addr[i] + 0x18);\r\ntype &= 0x0f;\r\nswitch (type) {\r\ncase 0x2:\r\nprintk(KERN_INFO "parport_pc: ITE8871 found (1P)\n");\r\nite8872set = 0x64200000;\r\nbreak;\r\ncase 0xa:\r\nprintk(KERN_INFO "parport_pc: ITE8875 found (1P)\n");\r\nite8872set = 0x64200000;\r\nbreak;\r\ncase 0xe:\r\nprintk(KERN_INFO "parport_pc: ITE8872 found (2S1P)\n");\r\nite8872set = 0x64e00000;\r\nbreak;\r\ncase 0x6:\r\nprintk(KERN_INFO "parport_pc: ITE8873 found (1S)\n");\r\nrelease_region(inta_addr[i], 32);\r\nreturn 0;\r\ncase 0x8:\r\nprintk(KERN_INFO "parport_pc: ITE8874 found (2S)\n");\r\nrelease_region(inta_addr[i], 32);\r\nreturn 0;\r\ndefault:\r\nprintk(KERN_INFO "parport_pc: unknown ITE887x\n");\r\nprintk(KERN_INFO "parport_pc: please mail 'lspci -nvv' "\r\n"output to Rich.Liu@ite.com.tw\n");\r\nrelease_region(inta_addr[i], 32);\r\nreturn 0;\r\n}\r\npci_read_config_byte(pdev, 0x3c, &ite8872_irq);\r\npci_read_config_dword(pdev, 0x1c, &ite8872_lpt);\r\nite8872_lpt &= 0x0000ff00;\r\npci_read_config_dword(pdev, 0x20, &ite8872_lpthi);\r\nite8872_lpthi &= 0x0000ff00;\r\npci_write_config_dword(pdev, 0x6c, 0xe3000000 | ite8872_lpt);\r\npci_write_config_dword(pdev, 0x70, 0xe3000000 | ite8872_lpthi);\r\npci_write_config_dword(pdev, 0x80, (ite8872_lpthi<<16) | ite8872_lpt);\r\npci_write_config_dword(pdev, 0x9c,\r\nite8872set | (ite8872_irq * 0x11111));\r\nDPRINTK(KERN_DEBUG "ITE887x: The IRQ is %d.\n", ite8872_irq);\r\nDPRINTK(KERN_DEBUG "ITE887x: The PARALLEL I/O port is 0x%x.\n",\r\nite8872_lpt);\r\nDPRINTK(KERN_DEBUG "ITE887x: The PARALLEL I/O porthi is 0x%x.\n",\r\nite8872_lpthi);\r\nirq = ite8872_irq;\r\nif (autoirq != PARPORT_IRQ_AUTO)\r\nirq = PARPORT_IRQ_NONE;\r\nrelease_region(inta_addr[i], 32);\r\nif (parport_pc_probe_port(ite8872_lpt, ite8872_lpthi,\r\nirq, PARPORT_DMA_NONE, &pdev->dev, 0)) {\r\nprintk(KERN_INFO\r\n"parport_pc: ITE 8872 parallel port: io=0x%X",\r\nite8872_lpt);\r\nif (irq != PARPORT_IRQ_NONE)\r\nprintk(", irq=%d", irq);\r\nprintk("\n");\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sio_via_probe(struct pci_dev *pdev, int autoirq, int autodma,\r\nconst struct parport_pc_via_data *via)\r\n{\r\nu8 tmp, tmp2, siofunc;\r\nu8 ppcontrol = 0;\r\nint dma, irq;\r\nunsigned port1, port2;\r\nunsigned have_epp = 0;\r\nprintk(KERN_DEBUG "parport_pc: VIA 686A/8231 detected\n");\r\nswitch (parport_init_mode) {\r\ncase 1:\r\nprintk(KERN_DEBUG "parport_pc: setting SPP mode\n");\r\nsiofunc = VIA_FUNCTION_PARPORT_SPP;\r\nbreak;\r\ncase 2:\r\nprintk(KERN_DEBUG "parport_pc: setting PS/2 mode\n");\r\nsiofunc = VIA_FUNCTION_PARPORT_SPP;\r\nppcontrol = VIA_PARPORT_BIDIR;\r\nbreak;\r\ncase 3:\r\nprintk(KERN_DEBUG "parport_pc: setting EPP mode\n");\r\nsiofunc = VIA_FUNCTION_PARPORT_EPP;\r\nppcontrol = VIA_PARPORT_BIDIR;\r\nhave_epp = 1;\r\nbreak;\r\ncase 4:\r\nprintk(KERN_DEBUG "parport_pc: setting ECP mode\n");\r\nsiofunc = VIA_FUNCTION_PARPORT_ECP;\r\nppcontrol = VIA_PARPORT_BIDIR;\r\nbreak;\r\ncase 5:\r\nprintk(KERN_DEBUG "parport_pc: setting EPP+ECP mode\n");\r\nsiofunc = VIA_FUNCTION_PARPORT_ECP;\r\nppcontrol = VIA_PARPORT_BIDIR|VIA_PARPORT_ECPEPP;\r\nhave_epp = 1;\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG\r\n"parport_pc: probing current configuration\n");\r\nsiofunc = VIA_FUNCTION_PROBE;\r\nbreak;\r\n}\r\npci_read_config_byte(pdev, via->via_pci_superio_config_reg, &tmp);\r\ntmp |= via->via_pci_superio_config_data;\r\npci_write_config_byte(pdev, via->via_pci_superio_config_reg, tmp);\r\noutb(via->viacfg_function, VIA_CONFIG_INDEX);\r\ntmp = inb(VIA_CONFIG_DATA);\r\noutb(via->viacfg_parport_control, VIA_CONFIG_INDEX);\r\ntmp2 = inb(VIA_CONFIG_DATA);\r\nif (siofunc == VIA_FUNCTION_PROBE) {\r\nsiofunc = tmp & VIA_FUNCTION_PARPORT_DISABLE;\r\nppcontrol = tmp2;\r\n} else {\r\ntmp &= ~VIA_FUNCTION_PARPORT_DISABLE;\r\ntmp |= siofunc;\r\noutb(via->viacfg_function, VIA_CONFIG_INDEX);\r\noutb(tmp, VIA_CONFIG_DATA);\r\ntmp2 &= ~(VIA_PARPORT_BIDIR|VIA_PARPORT_ECPEPP);\r\ntmp2 |= ppcontrol;\r\noutb(via->viacfg_parport_control, VIA_CONFIG_INDEX);\r\noutb(tmp2, VIA_CONFIG_DATA);\r\n}\r\noutb(via->viacfg_parport_base, VIA_CONFIG_INDEX);\r\nport1 = inb(VIA_CONFIG_DATA) << 2;\r\nprintk(KERN_DEBUG "parport_pc: Current parallel port base: 0x%X\n",\r\nport1);\r\nif (port1 == 0x3BC && have_epp) {\r\noutb(via->viacfg_parport_base, VIA_CONFIG_INDEX);\r\noutb((0x378 >> 2), VIA_CONFIG_DATA);\r\nprintk(KERN_DEBUG\r\n"parport_pc: Parallel port base changed to 0x378\n");\r\nport1 = 0x378;\r\n}\r\npci_read_config_byte(pdev, via->via_pci_superio_config_reg, &tmp);\r\ntmp &= ~via->via_pci_superio_config_data;\r\npci_write_config_byte(pdev, via->via_pci_superio_config_reg, tmp);\r\nif (siofunc == VIA_FUNCTION_PARPORT_DISABLE) {\r\nprintk(KERN_INFO "parport_pc: VIA parallel port disabled in BIOS\n");\r\nreturn 0;\r\n}\r\npci_read_config_byte(pdev, via->via_pci_parport_irq_reg, &tmp);\r\nirq = ((tmp & VIA_IRQCONTROL_PARALLEL) >> 4);\r\nif (siofunc == VIA_FUNCTION_PARPORT_ECP) {\r\npci_read_config_byte(pdev, via->via_pci_parport_dma_reg, &tmp);\r\ndma = ((tmp & VIA_DMACONTROL_PARALLEL) >> 2);\r\n} else\r\ndma = PARPORT_DMA_NONE;\r\nif (autoirq == PARPORT_IRQ_NONE) {\r\nirq = PARPORT_IRQ_NONE;\r\ndma = PARPORT_DMA_NONE;\r\n}\r\nif (autodma == PARPORT_DMA_NONE)\r\ndma = PARPORT_DMA_NONE;\r\nswitch (port1) {\r\ncase 0x3bc:\r\nport2 = 0x7bc; break;\r\ncase 0x378:\r\nport2 = 0x778; break;\r\ncase 0x278:\r\nport2 = 0x678; break;\r\ndefault:\r\nprintk(KERN_INFO\r\n"parport_pc: Weird VIA parport base 0x%X, ignoring\n",\r\nport1);\r\nreturn 0;\r\n}\r\nswitch (irq) {\r\ncase 0:\r\ncase 2:\r\ncase 8:\r\ncase 13:\r\nirq = PARPORT_IRQ_NONE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (parport_pc_probe_port(port1, port2, irq, dma, &pdev->dev, 0)) {\r\nprintk(KERN_INFO\r\n"parport_pc: VIA parallel port: io=0x%X", port1);\r\nif (irq != PARPORT_IRQ_NONE)\r\nprintk(", irq=%d", irq);\r\nif (dma != PARPORT_DMA_NONE)\r\nprintk(", dma=%d", dma);\r\nprintk("\n");\r\nreturn 1;\r\n}\r\nprintk(KERN_WARNING "parport_pc: Strange, can't probe VIA parallel port: io=0x%X, irq=%d, dma=%d\n",\r\nport1, irq, dma);\r\nreturn 0;\r\n}\r\nstatic int parport_pc_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nint err, count, n, i = id->driver_data;\r\nstruct pci_parport_data *data;\r\nif (i < last_sio)\r\nreturn 0;\r\ni -= last_sio;\r\ncount = 0;\r\nerr = pci_enable_device(dev);\r\nif (err)\r\nreturn err;\r\ndata = kmalloc(sizeof(struct pci_parport_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nif (cards[i].preinit_hook &&\r\ncards[i].preinit_hook(dev, PARPORT_IRQ_NONE, PARPORT_DMA_NONE)) {\r\nkfree(data);\r\nreturn -ENODEV;\r\n}\r\nfor (n = 0; n < cards[i].numports; n++) {\r\nint lo = cards[i].addr[n].lo;\r\nint hi = cards[i].addr[n].hi;\r\nint irq;\r\nunsigned long io_lo, io_hi;\r\nio_lo = pci_resource_start(dev, lo);\r\nio_hi = 0;\r\nif ((hi >= 0) && (hi <= 6))\r\nio_hi = pci_resource_start(dev, hi);\r\nelse if (hi > 6)\r\nio_lo += hi;\r\nirq = dev->irq;\r\nif (irq == IRQ_NONE) {\r\nprintk(KERN_DEBUG\r\n"PCI parallel port detected: %04x:%04x, I/O at %#lx(%#lx)\n",\r\nid->vendor, id->device, io_lo, io_hi);\r\nirq = PARPORT_IRQ_NONE;\r\n} else {\r\nprintk(KERN_DEBUG\r\n"PCI parallel port detected: %04x:%04x, I/O at %#lx(%#lx), IRQ %d\n",\r\nid->vendor, id->device, io_lo, io_hi, irq);\r\n}\r\ndata->ports[count] =\r\nparport_pc_probe_port(io_lo, io_hi, irq,\r\nPARPORT_DMA_NONE, &dev->dev,\r\nIRQF_SHARED);\r\nif (data->ports[count])\r\ncount++;\r\n}\r\ndata->num = count;\r\nif (cards[i].postinit_hook)\r\ncards[i].postinit_hook(dev, count == 0);\r\nif (count) {\r\npci_set_drvdata(dev, data);\r\nreturn 0;\r\n}\r\nkfree(data);\r\nreturn -ENODEV;\r\n}\r\nstatic void parport_pc_pci_remove(struct pci_dev *dev)\r\n{\r\nstruct pci_parport_data *data = pci_get_drvdata(dev);\r\nint i;\r\nif (data) {\r\nfor (i = data->num - 1; i >= 0; i--)\r\nparport_pc_unregister_port(data->ports[i]);\r\nkfree(data);\r\n}\r\n}\r\nstatic int __init parport_pc_init_superio(int autoirq, int autodma)\r\n{\r\nconst struct pci_device_id *id;\r\nstruct pci_dev *pdev = NULL;\r\nint ret = 0;\r\nfor_each_pci_dev(pdev) {\r\nid = pci_match_id(parport_pc_pci_tbl, pdev);\r\nif (id == NULL || id->driver_data >= last_sio)\r\ncontinue;\r\nif (parport_pc_superio_info[id->driver_data].probe(\r\npdev, autoirq, autodma,\r\nparport_pc_superio_info[id->driver_data].via)) {\r\nret++;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init parport_pc_init_superio(int autoirq, int autodma)\r\n{\r\nreturn 0;\r\n}\r\nstatic int parport_pc_pnp_probe(struct pnp_dev *dev,\r\nconst struct pnp_device_id *id)\r\n{\r\nstruct parport *pdata;\r\nunsigned long io_lo, io_hi;\r\nint dma, irq;\r\nif (pnp_port_valid(dev, 0) &&\r\n!(pnp_port_flags(dev, 0) & IORESOURCE_DISABLED)) {\r\nio_lo = pnp_port_start(dev, 0);\r\n} else\r\nreturn -EINVAL;\r\nif (pnp_port_valid(dev, 1) &&\r\n!(pnp_port_flags(dev, 1) & IORESOURCE_DISABLED)) {\r\nio_hi = pnp_port_start(dev, 1);\r\n} else\r\nio_hi = 0;\r\nif (pnp_irq_valid(dev, 0) &&\r\n!(pnp_irq_flags(dev, 0) & IORESOURCE_DISABLED)) {\r\nirq = pnp_irq(dev, 0);\r\n} else\r\nirq = PARPORT_IRQ_NONE;\r\nif (pnp_dma_valid(dev, 0) &&\r\n!(pnp_dma_flags(dev, 0) & IORESOURCE_DISABLED)) {\r\ndma = pnp_dma(dev, 0);\r\n} else\r\ndma = PARPORT_DMA_NONE;\r\ndev_info(&dev->dev, "reported by %s\n", dev->protocol->name);\r\npdata = parport_pc_probe_port(io_lo, io_hi, irq, dma, &dev->dev, 0);\r\nif (pdata == NULL)\r\nreturn -ENODEV;\r\npnp_set_drvdata(dev, pdata);\r\nreturn 0;\r\n}\r\nstatic void parport_pc_pnp_remove(struct pnp_dev *dev)\r\n{\r\nstruct parport *pdata = (struct parport *)pnp_get_drvdata(dev);\r\nif (!pdata)\r\nreturn;\r\nparport_pc_unregister_port(pdata);\r\n}\r\nstatic int parport_pc_platform_probe(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __init parport_pc_find_ports(int autoirq, int autodma)\r\n{\r\nint count = 0, err;\r\n#ifdef CONFIG_PARPORT_PC_SUPERIO\r\ndetect_and_report_it87();\r\ndetect_and_report_winbond();\r\ndetect_and_report_smsc();\r\n#endif\r\ncount += parport_pc_init_superio(autoirq, autodma);\r\nif (!count) {\r\nerr = pnp_register_driver(&parport_pc_pnp_driver);\r\nif (!err)\r\npnp_registered_parport = 1;\r\n}\r\nparport_pc_find_nonpci_ports(autoirq, autodma);\r\nerr = pci_register_driver(&parport_pc_pci_driver);\r\nif (!err)\r\npci_registered_parport = 1;\r\n}\r\nstatic int __init parport_parse_param(const char *s, int *val,\r\nint automatic, int none, int nofifo)\r\n{\r\nif (!s)\r\nreturn 0;\r\nif (!strncmp(s, "auto", 4))\r\n*val = automatic;\r\nelse if (!strncmp(s, "none", 4))\r\n*val = none;\r\nelse if (nofifo && !strncmp(s, "nofifo", 6))\r\n*val = nofifo;\r\nelse {\r\nchar *ep;\r\nunsigned long r = simple_strtoul(s, &ep, 0);\r\nif (ep != s)\r\n*val = r;\r\nelse {\r\nprintk(KERN_ERR "parport: bad specifier `%s'\n", s);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init parport_parse_irq(const char *irqstr, int *val)\r\n{\r\nreturn parport_parse_param(irqstr, val, PARPORT_IRQ_AUTO,\r\nPARPORT_IRQ_NONE, 0);\r\n}\r\nstatic int __init parport_parse_dma(const char *dmastr, int *val)\r\n{\r\nreturn parport_parse_param(dmastr, val, PARPORT_DMA_AUTO,\r\nPARPORT_DMA_NONE, PARPORT_DMA_NOFIFO);\r\n}\r\nstatic int __init parport_init_mode_setup(char *str)\r\n{\r\nprintk(KERN_DEBUG\r\n"parport_pc.c: Specified parameter parport_init_mode=%s\n", str);\r\nif (!strcmp(str, "spp"))\r\nparport_init_mode = 1;\r\nif (!strcmp(str, "ps2"))\r\nparport_init_mode = 2;\r\nif (!strcmp(str, "epp"))\r\nparport_init_mode = 3;\r\nif (!strcmp(str, "ecp"))\r\nparport_init_mode = 4;\r\nif (!strcmp(str, "ecpepp"))\r\nparport_init_mode = 5;\r\nreturn 1;\r\n}\r\nstatic int __init parse_parport_params(void)\r\n{\r\nunsigned int i;\r\nint val;\r\n#ifdef CONFIG_PCI\r\nif (init_mode)\r\nparport_init_mode_setup(init_mode);\r\n#endif\r\nfor (i = 0; i < PARPORT_PC_MAX_PORTS && io[i]; i++) {\r\nif (parport_parse_irq(irq[i], &val))\r\nreturn 1;\r\nirqval[i] = val;\r\nif (parport_parse_dma(dma[i], &val))\r\nreturn 1;\r\ndmaval[i] = val;\r\n}\r\nif (!io[0]) {\r\nif (irq[0] && !parport_parse_irq(irq[0], &val))\r\nswitch (val) {\r\ncase PARPORT_IRQ_NONE:\r\ncase PARPORT_IRQ_AUTO:\r\nirqval[0] = val;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"parport_pc: irq specified "\r\n"without base address. Use 'io=' "\r\n"to specify one\n");\r\n}\r\nif (dma[0] && !parport_parse_dma(dma[0], &val))\r\nswitch (val) {\r\ncase PARPORT_DMA_NONE:\r\ncase PARPORT_DMA_AUTO:\r\ndmaval[0] = val;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"parport_pc: dma specified "\r\n"without base address. Use 'io=' "\r\n"to specify one\n");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init parport_setup(char *str)\r\n{\r\nchar *endptr;\r\nchar *sep;\r\nint val;\r\nif (!str || !*str || (*str == '0' && !*(str+1))) {\r\nio[0] = PARPORT_DISABLE;\r\nreturn 1;\r\n}\r\nif (!strncmp(str, "auto", 4)) {\r\nirqval[0] = PARPORT_IRQ_AUTO;\r\ndmaval[0] = PARPORT_DMA_AUTO;\r\nreturn 1;\r\n}\r\nval = simple_strtoul(str, &endptr, 0);\r\nif (endptr == str) {\r\nprintk(KERN_WARNING "parport=%s not understood\n", str);\r\nreturn 1;\r\n}\r\nif (parport_setup_ptr == PARPORT_PC_MAX_PORTS) {\r\nprintk(KERN_ERR "parport=%s ignored, too many ports\n", str);\r\nreturn 1;\r\n}\r\nio[parport_setup_ptr] = val;\r\nirqval[parport_setup_ptr] = PARPORT_IRQ_NONE;\r\ndmaval[parport_setup_ptr] = PARPORT_DMA_NONE;\r\nsep = strchr(str, ',');\r\nif (sep++) {\r\nif (parport_parse_irq(sep, &val))\r\nreturn 1;\r\nirqval[parport_setup_ptr] = val;\r\nsep = strchr(sep, ',');\r\nif (sep++) {\r\nif (parport_parse_dma(sep, &val))\r\nreturn 1;\r\ndmaval[parport_setup_ptr] = val;\r\n}\r\n}\r\nparport_setup_ptr++;\r\nreturn 1;\r\n}\r\nstatic int __init parse_parport_params(void)\r\n{\r\nreturn io[0] == PARPORT_DISABLE;\r\n}\r\nstatic int __init parport_pc_init(void)\r\n{\r\nint err;\r\nif (parse_parport_params())\r\nreturn -EINVAL;\r\nerr = platform_driver_register(&parport_pc_platform_driver);\r\nif (err)\r\nreturn err;\r\nif (io[0]) {\r\nint i;\r\nuser_specified = 1;\r\nfor (i = 0; i < PARPORT_PC_MAX_PORTS; i++) {\r\nif (!io[i])\r\nbreak;\r\nif (io_hi[i] == PARPORT_IOHI_AUTO)\r\nio_hi[i] = 0x400 + io[i];\r\nparport_pc_probe_port(io[i], io_hi[i],\r\nirqval[i], dmaval[i], NULL, 0);\r\n}\r\n} else\r\nparport_pc_find_ports(irqval[0], dmaval[0]);\r\nreturn 0;\r\n}\r\nstatic void __exit parport_pc_exit(void)\r\n{\r\nif (pci_registered_parport)\r\npci_unregister_driver(&parport_pc_pci_driver);\r\nif (pnp_registered_parport)\r\npnp_unregister_driver(&parport_pc_pnp_driver);\r\nplatform_driver_unregister(&parport_pc_platform_driver);\r\nwhile (!list_empty(&ports_list)) {\r\nstruct parport_pc_private *priv;\r\nstruct parport *port;\r\nstruct device *dev;\r\npriv = list_entry(ports_list.next,\r\nstruct parport_pc_private, list);\r\nport = priv->port;\r\ndev = port->dev;\r\nparport_pc_unregister_port(port);\r\nif (dev && dev->bus == &platform_bus_type)\r\nplatform_device_unregister(to_platform_device(dev));\r\n}\r\n}
