static void stat64_to_hostfs(const struct stat64 *buf, struct hostfs_stat *p)\r\n{\r\np->ino = buf->st_ino;\r\np->mode = buf->st_mode;\r\np->nlink = buf->st_nlink;\r\np->uid = buf->st_uid;\r\np->gid = buf->st_gid;\r\np->size = buf->st_size;\r\np->atime.tv_sec = buf->st_atime;\r\np->atime.tv_nsec = 0;\r\np->ctime.tv_sec = buf->st_ctime;\r\np->ctime.tv_nsec = 0;\r\np->mtime.tv_sec = buf->st_mtime;\r\np->mtime.tv_nsec = 0;\r\np->blksize = buf->st_blksize;\r\np->blocks = buf->st_blocks;\r\np->maj = os_major(buf->st_rdev);\r\np->min = os_minor(buf->st_rdev);\r\n}\r\nint stat_file(const char *path, struct hostfs_stat *p, int fd)\r\n{\r\nstruct stat64 buf;\r\nif (fd >= 0) {\r\nif (fstat64(fd, &buf) < 0)\r\nreturn -errno;\r\n} else if (lstat64(path, &buf) < 0) {\r\nreturn -errno;\r\n}\r\nstat64_to_hostfs(&buf, p);\r\nreturn 0;\r\n}\r\nint access_file(char *path, int r, int w, int x)\r\n{\r\nint mode = 0;\r\nif (r)\r\nmode = R_OK;\r\nif (w)\r\nmode |= W_OK;\r\nif (x)\r\nmode |= X_OK;\r\nif (access(path, mode) != 0)\r\nreturn -errno;\r\nelse return 0;\r\n}\r\nint open_file(char *path, int r, int w, int append)\r\n{\r\nint mode = 0, fd;\r\nif (r && !w)\r\nmode = O_RDONLY;\r\nelse if (!r && w)\r\nmode = O_WRONLY;\r\nelse if (r && w)\r\nmode = O_RDWR;\r\nelse panic("Impossible mode in open_file");\r\nif (append)\r\nmode |= O_APPEND;\r\nfd = open64(path, mode);\r\nif (fd < 0)\r\nreturn -errno;\r\nelse return fd;\r\n}\r\nvoid *open_dir(char *path, int *err_out)\r\n{\r\nDIR *dir;\r\ndir = opendir(path);\r\n*err_out = errno;\r\nreturn dir;\r\n}\r\nchar *read_dir(void *stream, unsigned long long *pos,\r\nunsigned long long *ino_out, int *len_out,\r\nunsigned int *type_out)\r\n{\r\nDIR *dir = stream;\r\nstruct dirent *ent;\r\nseekdir(dir, *pos);\r\nent = readdir(dir);\r\nif (ent == NULL)\r\nreturn NULL;\r\n*len_out = strlen(ent->d_name);\r\n*ino_out = ent->d_ino;\r\n*type_out = ent->d_type;\r\n*pos = telldir(dir);\r\nreturn ent->d_name;\r\n}\r\nint read_file(int fd, unsigned long long *offset, char *buf, int len)\r\n{\r\nint n;\r\nn = pread64(fd, buf, len, *offset);\r\nif (n < 0)\r\nreturn -errno;\r\n*offset += n;\r\nreturn n;\r\n}\r\nint write_file(int fd, unsigned long long *offset, const char *buf, int len)\r\n{\r\nint n;\r\nn = pwrite64(fd, buf, len, *offset);\r\nif (n < 0)\r\nreturn -errno;\r\n*offset += n;\r\nreturn n;\r\n}\r\nint lseek_file(int fd, long long offset, int whence)\r\n{\r\nint ret;\r\nret = lseek64(fd, offset, whence);\r\nif (ret < 0)\r\nreturn -errno;\r\nreturn 0;\r\n}\r\nint fsync_file(int fd, int datasync)\r\n{\r\nint ret;\r\nif (datasync)\r\nret = fdatasync(fd);\r\nelse\r\nret = fsync(fd);\r\nif (ret < 0)\r\nreturn -errno;\r\nreturn 0;\r\n}\r\nint replace_file(int oldfd, int fd)\r\n{\r\nreturn dup2(oldfd, fd);\r\n}\r\nvoid close_file(void *stream)\r\n{\r\nclose(*((int *) stream));\r\n}\r\nvoid close_dir(void *stream)\r\n{\r\nclosedir(stream);\r\n}\r\nint file_create(char *name, int ur, int uw, int ux, int gr,\r\nint gw, int gx, int or, int ow, int ox)\r\n{\r\nint mode, fd;\r\nmode = 0;\r\nmode |= ur ? S_IRUSR : 0;\r\nmode |= uw ? S_IWUSR : 0;\r\nmode |= ux ? S_IXUSR : 0;\r\nmode |= gr ? S_IRGRP : 0;\r\nmode |= gw ? S_IWGRP : 0;\r\nmode |= gx ? S_IXGRP : 0;\r\nmode |= or ? S_IROTH : 0;\r\nmode |= ow ? S_IWOTH : 0;\r\nmode |= ox ? S_IXOTH : 0;\r\nfd = open64(name, O_CREAT | O_RDWR, mode);\r\nif (fd < 0)\r\nreturn -errno;\r\nreturn fd;\r\n}\r\nint set_attr(const char *file, struct hostfs_iattr *attrs, int fd)\r\n{\r\nstruct hostfs_stat st;\r\nstruct timeval times[2];\r\nint err, ma;\r\nif (attrs->ia_valid & HOSTFS_ATTR_MODE) {\r\nif (fd >= 0) {\r\nif (fchmod(fd, attrs->ia_mode) != 0)\r\nreturn -errno;\r\n} else if (chmod(file, attrs->ia_mode) != 0) {\r\nreturn -errno;\r\n}\r\n}\r\nif (attrs->ia_valid & HOSTFS_ATTR_UID) {\r\nif (fd >= 0) {\r\nif (fchown(fd, attrs->ia_uid, -1))\r\nreturn -errno;\r\n} else if (chown(file, attrs->ia_uid, -1)) {\r\nreturn -errno;\r\n}\r\n}\r\nif (attrs->ia_valid & HOSTFS_ATTR_GID) {\r\nif (fd >= 0) {\r\nif (fchown(fd, -1, attrs->ia_gid))\r\nreturn -errno;\r\n} else if (chown(file, -1, attrs->ia_gid)) {\r\nreturn -errno;\r\n}\r\n}\r\nif (attrs->ia_valid & HOSTFS_ATTR_SIZE) {\r\nif (fd >= 0) {\r\nif (ftruncate(fd, attrs->ia_size))\r\nreturn -errno;\r\n} else if (truncate(file, attrs->ia_size)) {\r\nreturn -errno;\r\n}\r\n}\r\nma = (HOSTFS_ATTR_ATIME_SET | HOSTFS_ATTR_MTIME_SET);\r\nif (attrs->ia_valid & ma) {\r\nerr = stat_file(file, &st, fd);\r\nif (err != 0)\r\nreturn err;\r\ntimes[0].tv_sec = st.atime.tv_sec;\r\ntimes[0].tv_usec = st.atime.tv_nsec / 1000;\r\ntimes[1].tv_sec = st.mtime.tv_sec;\r\ntimes[1].tv_usec = st.mtime.tv_nsec / 1000;\r\nif (attrs->ia_valid & HOSTFS_ATTR_ATIME_SET) {\r\ntimes[0].tv_sec = attrs->ia_atime.tv_sec;\r\ntimes[0].tv_usec = attrs->ia_atime.tv_nsec / 1000;\r\n}\r\nif (attrs->ia_valid & HOSTFS_ATTR_MTIME_SET) {\r\ntimes[1].tv_sec = attrs->ia_mtime.tv_sec;\r\ntimes[1].tv_usec = attrs->ia_mtime.tv_nsec / 1000;\r\n}\r\nif (fd >= 0) {\r\nif (futimes(fd, times) != 0)\r\nreturn -errno;\r\n} else if (utimes(file, times) != 0) {\r\nreturn -errno;\r\n}\r\n}\r\nif (attrs->ia_valid & (HOSTFS_ATTR_ATIME | HOSTFS_ATTR_MTIME)) {\r\nerr = stat_file(file, &st, fd);\r\nattrs->ia_atime = st.atime;\r\nattrs->ia_mtime = st.mtime;\r\nif (err != 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint make_symlink(const char *from, const char *to)\r\n{\r\nint err;\r\nerr = symlink(to, from);\r\nif (err)\r\nreturn -errno;\r\nreturn 0;\r\n}\r\nint unlink_file(const char *file)\r\n{\r\nint err;\r\nerr = unlink(file);\r\nif (err)\r\nreturn -errno;\r\nreturn 0;\r\n}\r\nint do_mkdir(const char *file, int mode)\r\n{\r\nint err;\r\nerr = mkdir(file, mode);\r\nif (err)\r\nreturn -errno;\r\nreturn 0;\r\n}\r\nint do_rmdir(const char *file)\r\n{\r\nint err;\r\nerr = rmdir(file);\r\nif (err)\r\nreturn -errno;\r\nreturn 0;\r\n}\r\nint do_mknod(const char *file, int mode, unsigned int major, unsigned int minor)\r\n{\r\nint err;\r\nerr = mknod(file, mode, os_makedev(major, minor));\r\nif (err)\r\nreturn -errno;\r\nreturn 0;\r\n}\r\nint link_file(const char *to, const char *from)\r\n{\r\nint err;\r\nerr = link(to, from);\r\nif (err)\r\nreturn -errno;\r\nreturn 0;\r\n}\r\nint hostfs_do_readlink(char *file, char *buf, int size)\r\n{\r\nint n;\r\nn = readlink(file, buf, size);\r\nif (n < 0)\r\nreturn -errno;\r\nif (n < size)\r\nbuf[n] = '\0';\r\nreturn n;\r\n}\r\nint rename_file(char *from, char *to)\r\n{\r\nint err;\r\nerr = rename(from, to);\r\nif (err < 0)\r\nreturn -errno;\r\nreturn 0;\r\n}\r\nint rename2_file(char *from, char *to, unsigned int flags)\r\n{\r\nint err;\r\n#ifndef SYS_renameat2\r\n# ifdef __x86_64__\r\n# define SYS_renameat2 316\r\n# endif\r\n# ifdef __i386__\r\n# define SYS_renameat2 353\r\n# endif\r\n#endif\r\n#ifdef SYS_renameat2\r\nerr = syscall(SYS_renameat2, AT_FDCWD, from, AT_FDCWD, to, flags);\r\nif (err < 0) {\r\nif (errno != ENOSYS)\r\nreturn -errno;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n#else\r\nreturn -EINVAL;\r\n#endif\r\n}\r\nint do_statfs(char *root, long *bsize_out, long long *blocks_out,\r\nlong long *bfree_out, long long *bavail_out,\r\nlong long *files_out, long long *ffree_out,\r\nvoid *fsid_out, int fsid_size, long *namelen_out)\r\n{\r\nstruct statfs64 buf;\r\nint err;\r\nerr = statfs64(root, &buf);\r\nif (err < 0)\r\nreturn -errno;\r\n*bsize_out = buf.f_bsize;\r\n*blocks_out = buf.f_blocks;\r\n*bfree_out = buf.f_bfree;\r\n*bavail_out = buf.f_bavail;\r\n*files_out = buf.f_files;\r\n*ffree_out = buf.f_ffree;\r\nmemcpy(fsid_out, &buf.f_fsid,\r\nsizeof(buf.f_fsid) > fsid_size ? fsid_size :\r\nsizeof(buf.f_fsid));\r\n*namelen_out = buf.f_namelen;\r\nreturn 0;\r\n}
