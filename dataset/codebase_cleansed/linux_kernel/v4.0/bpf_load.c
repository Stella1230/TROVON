static int load_and_attach(const char *event, struct bpf_insn *prog, int size)\r\n{\r\nint fd;\r\nbool is_socket = strncmp(event, "socket", 6) == 0;\r\nif (!is_socket)\r\nreturn -1;\r\nfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER,\r\nprog, size, license);\r\nif (fd < 0) {\r\nprintf("bpf_prog_load() err=%d\n%s", errno, bpf_log_buf);\r\nreturn -1;\r\n}\r\nprog_fd[prog_cnt++] = fd;\r\nreturn 0;\r\n}\r\nstatic int load_maps(struct bpf_map_def *maps, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len / sizeof(struct bpf_map_def); i++) {\r\nmap_fd[i] = bpf_create_map(maps[i].type,\r\nmaps[i].key_size,\r\nmaps[i].value_size,\r\nmaps[i].max_entries);\r\nif (map_fd[i] < 0)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_sec(Elf *elf, int i, GElf_Ehdr *ehdr, char **shname,\r\nGElf_Shdr *shdr, Elf_Data **data)\r\n{\r\nElf_Scn *scn;\r\nscn = elf_getscn(elf, i);\r\nif (!scn)\r\nreturn 1;\r\nif (gelf_getshdr(scn, shdr) != shdr)\r\nreturn 2;\r\n*shname = elf_strptr(elf, ehdr->e_shstrndx, shdr->sh_name);\r\nif (!*shname || !shdr->sh_size)\r\nreturn 3;\r\n*data = elf_getdata(scn, 0);\r\nif (!*data || elf_getdata(scn, *data) != NULL)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int parse_relo_and_apply(Elf_Data *data, Elf_Data *symbols,\r\nGElf_Shdr *shdr, struct bpf_insn *insn)\r\n{\r\nint i, nrels;\r\nnrels = shdr->sh_size / shdr->sh_entsize;\r\nfor (i = 0; i < nrels; i++) {\r\nGElf_Sym sym;\r\nGElf_Rel rel;\r\nunsigned int insn_idx;\r\ngelf_getrel(data, i, &rel);\r\ninsn_idx = rel.r_offset / sizeof(struct bpf_insn);\r\ngelf_getsym(symbols, GELF_R_SYM(rel.r_info), &sym);\r\nif (insn[insn_idx].code != (BPF_LD | BPF_IMM | BPF_DW)) {\r\nprintf("invalid relo for insn[%d].code 0x%x\n",\r\ninsn_idx, insn[insn_idx].code);\r\nreturn 1;\r\n}\r\ninsn[insn_idx].src_reg = BPF_PSEUDO_MAP_FD;\r\ninsn[insn_idx].imm = map_fd[sym.st_value / sizeof(struct bpf_map_def)];\r\n}\r\nreturn 0;\r\n}\r\nint load_bpf_file(char *path)\r\n{\r\nint fd, i;\r\nElf *elf;\r\nGElf_Ehdr ehdr;\r\nGElf_Shdr shdr, shdr_prog;\r\nElf_Data *data, *data_prog, *symbols = NULL;\r\nchar *shname, *shname_prog;\r\nif (elf_version(EV_CURRENT) == EV_NONE)\r\nreturn 1;\r\nfd = open(path, O_RDONLY, 0);\r\nif (fd < 0)\r\nreturn 1;\r\nelf = elf_begin(fd, ELF_C_READ, NULL);\r\nif (!elf)\r\nreturn 1;\r\nif (gelf_getehdr(elf, &ehdr) != &ehdr)\r\nreturn 1;\r\nfor (i = 1; i < ehdr.e_shnum; i++) {\r\nif (get_sec(elf, i, &ehdr, &shname, &shdr, &data))\r\ncontinue;\r\nif (0)\r\nprintf("section %d:%s data %p size %zd link %d flags %d\n",\r\ni, shname, data->d_buf, data->d_size,\r\nshdr.sh_link, (int) shdr.sh_flags);\r\nif (strcmp(shname, "license") == 0) {\r\nprocessed_sec[i] = true;\r\nmemcpy(license, data->d_buf, data->d_size);\r\n} else if (strcmp(shname, "maps") == 0) {\r\nprocessed_sec[i] = true;\r\nif (load_maps(data->d_buf, data->d_size))\r\nreturn 1;\r\n} else if (shdr.sh_type == SHT_SYMTAB) {\r\nsymbols = data;\r\n}\r\n}\r\nfor (i = 1; i < ehdr.e_shnum; i++) {\r\nif (get_sec(elf, i, &ehdr, &shname, &shdr, &data))\r\ncontinue;\r\nif (shdr.sh_type == SHT_REL) {\r\nstruct bpf_insn *insns;\r\nif (get_sec(elf, shdr.sh_info, &ehdr, &shname_prog,\r\n&shdr_prog, &data_prog))\r\ncontinue;\r\ninsns = (struct bpf_insn *) data_prog->d_buf;\r\nprocessed_sec[shdr.sh_info] = true;\r\nprocessed_sec[i] = true;\r\nif (parse_relo_and_apply(data, symbols, &shdr, insns))\r\ncontinue;\r\nif (memcmp(shname_prog, "events/", 7) == 0 ||\r\nmemcmp(shname_prog, "socket", 6) == 0)\r\nload_and_attach(shname_prog, insns, data_prog->d_size);\r\n}\r\n}\r\nfor (i = 1; i < ehdr.e_shnum; i++) {\r\nif (processed_sec[i])\r\ncontinue;\r\nif (get_sec(elf, i, &ehdr, &shname, &shdr, &data))\r\ncontinue;\r\nif (memcmp(shname, "events/", 7) == 0 ||\r\nmemcmp(shname, "socket", 6) == 0)\r\nload_and_attach(shname, data->d_buf, data->d_size);\r\n}\r\nclose(fd);\r\nreturn 0;\r\n}
