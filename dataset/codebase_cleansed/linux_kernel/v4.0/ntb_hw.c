static int is_ntb_xeon(struct ntb_device *ndev)\r\n{\r\nswitch (ndev->pdev->device) {\r\ncase PCI_DEVICE_ID_INTEL_NTB_SS_JSF:\r\ncase PCI_DEVICE_ID_INTEL_NTB_SS_SNB:\r\ncase PCI_DEVICE_ID_INTEL_NTB_SS_IVT:\r\ncase PCI_DEVICE_ID_INTEL_NTB_SS_HSX:\r\ncase PCI_DEVICE_ID_INTEL_NTB_PS_JSF:\r\ncase PCI_DEVICE_ID_INTEL_NTB_PS_SNB:\r\ncase PCI_DEVICE_ID_INTEL_NTB_PS_IVT:\r\ncase PCI_DEVICE_ID_INTEL_NTB_PS_HSX:\r\ncase PCI_DEVICE_ID_INTEL_NTB_B2B_JSF:\r\ncase PCI_DEVICE_ID_INTEL_NTB_B2B_SNB:\r\ncase PCI_DEVICE_ID_INTEL_NTB_B2B_IVT:\r\ncase PCI_DEVICE_ID_INTEL_NTB_B2B_HSX:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int is_ntb_atom(struct ntb_device *ndev)\r\n{\r\nswitch (ndev->pdev->device) {\r\ncase PCI_DEVICE_ID_INTEL_NTB_B2B_BWD:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ntb_set_errata_flags(struct ntb_device *ndev)\r\n{\r\nswitch (ndev->pdev->device) {\r\ncase PCI_DEVICE_ID_INTEL_NTB_SS_JSF:\r\ncase PCI_DEVICE_ID_INTEL_NTB_SS_SNB:\r\ncase PCI_DEVICE_ID_INTEL_NTB_SS_IVT:\r\ncase PCI_DEVICE_ID_INTEL_NTB_SS_HSX:\r\ncase PCI_DEVICE_ID_INTEL_NTB_PS_JSF:\r\ncase PCI_DEVICE_ID_INTEL_NTB_PS_SNB:\r\ncase PCI_DEVICE_ID_INTEL_NTB_PS_IVT:\r\ncase PCI_DEVICE_ID_INTEL_NTB_PS_HSX:\r\ncase PCI_DEVICE_ID_INTEL_NTB_B2B_JSF:\r\ncase PCI_DEVICE_ID_INTEL_NTB_B2B_SNB:\r\ncase PCI_DEVICE_ID_INTEL_NTB_B2B_IVT:\r\ncase PCI_DEVICE_ID_INTEL_NTB_B2B_HSX:\r\nndev->wa_flags |= WA_SNB_ERR;\r\nbreak;\r\n}\r\n}\r\nint ntb_register_event_callback(struct ntb_device *ndev,\r\nvoid (*func)(void *handle,\r\nenum ntb_hw_event event))\r\n{\r\nif (ndev->event_cb)\r\nreturn -EINVAL;\r\nndev->event_cb = func;\r\nreturn 0;\r\n}\r\nvoid ntb_unregister_event_callback(struct ntb_device *ndev)\r\n{\r\nndev->event_cb = NULL;\r\n}\r\nstatic void ntb_irq_work(unsigned long data)\r\n{\r\nstruct ntb_db_cb *db_cb = (struct ntb_db_cb *)data;\r\nint rc;\r\nrc = db_cb->callback(db_cb->data, db_cb->db_num);\r\nif (rc)\r\ntasklet_schedule(&db_cb->irq_work);\r\nelse {\r\nstruct ntb_device *ndev = db_cb->ndev;\r\nunsigned long mask;\r\nmask = readw(ndev->reg_ofs.ldb_mask);\r\nclear_bit(db_cb->db_num * ndev->bits_per_vector, &mask);\r\nwritew(mask, ndev->reg_ofs.ldb_mask);\r\n}\r\n}\r\nint ntb_register_db_callback(struct ntb_device *ndev, unsigned int idx,\r\nvoid *data, int (*func)(void *data, int db_num))\r\n{\r\nunsigned long mask;\r\nif (idx >= ndev->max_cbs || ndev->db_cb[idx].callback) {\r\ndev_warn(&ndev->pdev->dev, "Invalid Index.\n");\r\nreturn -EINVAL;\r\n}\r\nndev->db_cb[idx].callback = func;\r\nndev->db_cb[idx].data = data;\r\nndev->db_cb[idx].ndev = ndev;\r\ntasklet_init(&ndev->db_cb[idx].irq_work, ntb_irq_work,\r\n(unsigned long) &ndev->db_cb[idx]);\r\nmask = readw(ndev->reg_ofs.ldb_mask);\r\nclear_bit(idx * ndev->bits_per_vector, &mask);\r\nwritew(mask, ndev->reg_ofs.ldb_mask);\r\nreturn 0;\r\n}\r\nvoid ntb_unregister_db_callback(struct ntb_device *ndev, unsigned int idx)\r\n{\r\nunsigned long mask;\r\nif (idx >= ndev->max_cbs || !ndev->db_cb[idx].callback)\r\nreturn;\r\nmask = readw(ndev->reg_ofs.ldb_mask);\r\nset_bit(idx * ndev->bits_per_vector, &mask);\r\nwritew(mask, ndev->reg_ofs.ldb_mask);\r\ntasklet_disable(&ndev->db_cb[idx].irq_work);\r\nndev->db_cb[idx].callback = NULL;\r\n}\r\nvoid *ntb_find_transport(struct pci_dev *pdev)\r\n{\r\nstruct ntb_device *ndev = pci_get_drvdata(pdev);\r\nreturn ndev->ntb_transport;\r\n}\r\nstruct ntb_device *ntb_register_transport(struct pci_dev *pdev, void *transport)\r\n{\r\nstruct ntb_device *ndev = pci_get_drvdata(pdev);\r\nif (ndev->ntb_transport)\r\nreturn NULL;\r\nndev->ntb_transport = transport;\r\nreturn ndev;\r\n}\r\nvoid ntb_unregister_transport(struct ntb_device *ndev)\r\n{\r\nint i;\r\nif (!ndev->ntb_transport)\r\nreturn;\r\nfor (i = 0; i < ndev->max_cbs; i++)\r\nntb_unregister_db_callback(ndev, i);\r\nntb_unregister_event_callback(ndev);\r\nndev->ntb_transport = NULL;\r\n}\r\nint ntb_write_local_spad(struct ntb_device *ndev, unsigned int idx, u32 val)\r\n{\r\nif (idx >= ndev->limits.max_spads)\r\nreturn -EINVAL;\r\ndev_dbg(&ndev->pdev->dev, "Writing %x to local scratch pad index %d\n",\r\nval, idx);\r\nwritel(val, ndev->reg_ofs.spad_read + idx * 4);\r\nreturn 0;\r\n}\r\nint ntb_read_local_spad(struct ntb_device *ndev, unsigned int idx, u32 *val)\r\n{\r\nif (idx >= ndev->limits.max_spads)\r\nreturn -EINVAL;\r\n*val = readl(ndev->reg_ofs.spad_write + idx * 4);\r\ndev_dbg(&ndev->pdev->dev,\r\n"Reading %x from local scratch pad index %d\n", *val, idx);\r\nreturn 0;\r\n}\r\nint ntb_write_remote_spad(struct ntb_device *ndev, unsigned int idx, u32 val)\r\n{\r\nif (idx >= ndev->limits.max_spads)\r\nreturn -EINVAL;\r\ndev_dbg(&ndev->pdev->dev, "Writing %x to remote scratch pad index %d\n",\r\nval, idx);\r\nwritel(val, ndev->reg_ofs.spad_write + idx * 4);\r\nreturn 0;\r\n}\r\nint ntb_read_remote_spad(struct ntb_device *ndev, unsigned int idx, u32 *val)\r\n{\r\nif (idx >= ndev->limits.max_spads)\r\nreturn -EINVAL;\r\n*val = readl(ndev->reg_ofs.spad_read + idx * 4);\r\ndev_dbg(&ndev->pdev->dev,\r\n"Reading %x from remote scratch pad index %d\n", *val, idx);\r\nreturn 0;\r\n}\r\nresource_size_t ntb_get_mw_base(struct ntb_device *ndev, unsigned int mw)\r\n{\r\nif (mw >= ntb_max_mw(ndev))\r\nreturn 0;\r\nreturn pci_resource_start(ndev->pdev, MW_TO_BAR(mw));\r\n}\r\nvoid __iomem *ntb_get_mw_vbase(struct ntb_device *ndev, unsigned int mw)\r\n{\r\nif (mw >= ntb_max_mw(ndev))\r\nreturn NULL;\r\nreturn ndev->mw[mw].vbase;\r\n}\r\nu64 ntb_get_mw_size(struct ntb_device *ndev, unsigned int mw)\r\n{\r\nif (mw >= ntb_max_mw(ndev))\r\nreturn 0;\r\nreturn ndev->mw[mw].bar_sz;\r\n}\r\nvoid ntb_set_mw_addr(struct ntb_device *ndev, unsigned int mw, u64 addr)\r\n{\r\nif (mw >= ntb_max_mw(ndev))\r\nreturn;\r\ndev_dbg(&ndev->pdev->dev, "Writing addr %Lx to BAR %d\n", addr,\r\nMW_TO_BAR(mw));\r\nndev->mw[mw].phys_addr = addr;\r\nswitch (MW_TO_BAR(mw)) {\r\ncase NTB_BAR_23:\r\nwriteq(addr, ndev->reg_ofs.bar2_xlat);\r\nbreak;\r\ncase NTB_BAR_4:\r\nif (ndev->split_bar)\r\nwritel(addr, ndev->reg_ofs.bar4_xlat);\r\nelse\r\nwriteq(addr, ndev->reg_ofs.bar4_xlat);\r\nbreak;\r\ncase NTB_BAR_5:\r\nwritel(addr, ndev->reg_ofs.bar5_xlat);\r\nbreak;\r\n}\r\n}\r\nvoid ntb_ring_doorbell(struct ntb_device *ndev, unsigned int db)\r\n{\r\ndev_dbg(&ndev->pdev->dev, "%s: ringing doorbell %d\n", __func__, db);\r\nif (ndev->hw_type == BWD_HW)\r\nwriteq((u64) 1 << db, ndev->reg_ofs.rdb);\r\nelse\r\nwritew(((1 << ndev->bits_per_vector) - 1) <<\r\n(db * ndev->bits_per_vector), ndev->reg_ofs.rdb);\r\n}\r\nstatic void bwd_recover_link(struct ntb_device *ndev)\r\n{\r\nu32 status;\r\nwriteb(0xe0, ndev->reg_base + BWD_MODPHY_PCSREG6);\r\nwriteb(0x40, ndev->reg_base + BWD_MODPHY_PCSREG4);\r\nwriteb(0x60, ndev->reg_base + BWD_MODPHY_PCSREG4);\r\nwriteb(0x60, ndev->reg_base + BWD_MODPHY_PCSREG6);\r\nmsleep(100);\r\nstatus = readl(ndev->reg_base + BWD_ERRCORSTS_OFFSET);\r\ndev_dbg(&ndev->pdev->dev, "ERRCORSTS = %x\n", status);\r\nstatus &= PCI_ERR_COR_REP_ROLL;\r\nwritel(status, ndev->reg_base + BWD_ERRCORSTS_OFFSET);\r\nstatus = readl(ndev->reg_base + BWD_LTSSMERRSTS0_OFFSET);\r\ndev_dbg(&ndev->pdev->dev, "LTSSMERRSTS0 = %x\n", status);\r\nstatus |= BWD_LTSSMERRSTS0_UNEXPECTEDEI;\r\nwritel(status, ndev->reg_base + BWD_LTSSMERRSTS0_OFFSET);\r\nstatus = readl(ndev->reg_base + BWD_DESKEWSTS_OFFSET);\r\ndev_dbg(&ndev->pdev->dev, "DESKEWSTS = %x\n", status);\r\nstatus |= BWD_DESKEWSTS_DBERR;\r\nwritel(status, ndev->reg_base + BWD_DESKEWSTS_OFFSET);\r\nstatus = readl(ndev->reg_base + BWD_IBSTERRRCRVSTS0_OFFSET);\r\ndev_dbg(&ndev->pdev->dev, "IBSTERRRCRVSTS0 = %x\n", status);\r\nstatus &= BWD_IBIST_ERR_OFLOW;\r\nwritel(status, ndev->reg_base + BWD_IBSTERRRCRVSTS0_OFFSET);\r\nstatus = readl(ndev->reg_base + BWD_LTSSMSTATEJMP_OFFSET);\r\ndev_dbg(&ndev->pdev->dev, "LTSSMSTATEJMP = %x\n", status);\r\nstatus &= ~BWD_LTSSMSTATEJMP_FORCEDETECT;\r\nwritel(status, ndev->reg_base + BWD_LTSSMSTATEJMP_OFFSET);\r\n}\r\nstatic void ntb_link_event(struct ntb_device *ndev, int link_state)\r\n{\r\nunsigned int event;\r\nif (ndev->link_status == link_state)\r\nreturn;\r\nif (link_state == NTB_LINK_UP) {\r\nu16 status;\r\ndev_info(&ndev->pdev->dev, "Link Up\n");\r\nndev->link_status = NTB_LINK_UP;\r\nevent = NTB_EVENT_HW_LINK_UP;\r\nif (is_ntb_atom(ndev) ||\r\nndev->conn_type == NTB_CONN_TRANSPARENT)\r\nstatus = readw(ndev->reg_ofs.lnk_stat);\r\nelse {\r\nint rc = pci_read_config_word(ndev->pdev,\r\nSNB_LINK_STATUS_OFFSET,\r\n&status);\r\nif (rc)\r\nreturn;\r\n}\r\nndev->link_width = (status & NTB_LINK_WIDTH_MASK) >> 4;\r\nndev->link_speed = (status & NTB_LINK_SPEED_MASK);\r\ndev_info(&ndev->pdev->dev, "Link Width %d, Link Speed %d\n",\r\nndev->link_width, ndev->link_speed);\r\n} else {\r\ndev_info(&ndev->pdev->dev, "Link Down\n");\r\nndev->link_status = NTB_LINK_DOWN;\r\nevent = NTB_EVENT_HW_LINK_DOWN;\r\n}\r\nif (ndev->event_cb)\r\nndev->event_cb(ndev->ntb_transport, event);\r\n}\r\nstatic int ntb_link_status(struct ntb_device *ndev)\r\n{\r\nint link_state;\r\nif (is_ntb_atom(ndev)) {\r\nu32 ntb_cntl;\r\nntb_cntl = readl(ndev->reg_ofs.lnk_cntl);\r\nif (ntb_cntl & BWD_CNTL_LINK_DOWN)\r\nlink_state = NTB_LINK_DOWN;\r\nelse\r\nlink_state = NTB_LINK_UP;\r\n} else {\r\nu16 status;\r\nint rc;\r\nrc = pci_read_config_word(ndev->pdev, SNB_LINK_STATUS_OFFSET,\r\n&status);\r\nif (rc)\r\nreturn rc;\r\nif (status & NTB_LINK_STATUS_ACTIVE)\r\nlink_state = NTB_LINK_UP;\r\nelse\r\nlink_state = NTB_LINK_DOWN;\r\n}\r\nntb_link_event(ndev, link_state);\r\nreturn 0;\r\n}\r\nstatic void bwd_link_recovery(struct work_struct *work)\r\n{\r\nstruct ntb_device *ndev = container_of(work, struct ntb_device,\r\nlr_timer.work);\r\nu32 status32;\r\nbwd_recover_link(ndev);\r\nmsleep(BWD_LINK_RECOVERY_TIME + prandom_u32() % BWD_LINK_RECOVERY_TIME);\r\nstatus32 = readl(ndev->reg_base + BWD_LTSSMSTATEJMP_OFFSET);\r\nif (status32 & BWD_LTSSMSTATEJMP_FORCEDETECT)\r\ngoto retry;\r\nstatus32 = readl(ndev->reg_base + BWD_IBSTERRRCRVSTS0_OFFSET);\r\nif (status32 & BWD_IBIST_ERR_OFLOW)\r\ngoto retry;\r\nstatus32 = readl(ndev->reg_ofs.lnk_cntl);\r\nif (!(status32 & BWD_CNTL_LINK_DOWN)) {\r\nunsigned char speed, width;\r\nu16 status16;\r\nstatus16 = readw(ndev->reg_ofs.lnk_stat);\r\nwidth = (status16 & NTB_LINK_WIDTH_MASK) >> 4;\r\nspeed = (status16 & NTB_LINK_SPEED_MASK);\r\nif (ndev->link_width != width || ndev->link_speed != speed)\r\ngoto retry;\r\n}\r\nschedule_delayed_work(&ndev->hb_timer, NTB_HB_TIMEOUT);\r\nreturn;\r\nretry:\r\nschedule_delayed_work(&ndev->lr_timer, NTB_HB_TIMEOUT);\r\n}\r\nstatic void bwd_link_poll(struct work_struct *work)\r\n{\r\nstruct ntb_device *ndev = container_of(work, struct ntb_device,\r\nhb_timer.work);\r\nunsigned long ts = jiffies;\r\nif (ts > ndev->last_ts + NTB_HB_TIMEOUT) {\r\nint rc = ntb_link_status(ndev);\r\nif (rc)\r\ndev_err(&ndev->pdev->dev,\r\n"Error determining link status\n");\r\nif (ndev->link_status == NTB_LINK_DOWN) {\r\nu32 status32 = readl(ndev->reg_base +\r\nBWD_LTSSMSTATEJMP_OFFSET);\r\nif (status32 & BWD_LTSSMSTATEJMP_FORCEDETECT) {\r\nschedule_delayed_work(&ndev->lr_timer, 0);\r\nreturn;\r\n}\r\n}\r\n}\r\nschedule_delayed_work(&ndev->hb_timer, NTB_HB_TIMEOUT);\r\n}\r\nstatic int ntb_xeon_setup(struct ntb_device *ndev)\r\n{\r\nswitch (ndev->conn_type) {\r\ncase NTB_CONN_B2B:\r\nndev->reg_ofs.ldb = ndev->reg_base + SNB_PDOORBELL_OFFSET;\r\nndev->reg_ofs.ldb_mask = ndev->reg_base + SNB_PDBMSK_OFFSET;\r\nndev->reg_ofs.spad_read = ndev->reg_base + SNB_SPAD_OFFSET;\r\nndev->reg_ofs.bar2_xlat = ndev->reg_base + SNB_SBAR2XLAT_OFFSET;\r\nndev->reg_ofs.bar4_xlat = ndev->reg_base + SNB_SBAR4XLAT_OFFSET;\r\nif (ndev->split_bar)\r\nndev->reg_ofs.bar5_xlat =\r\nndev->reg_base + SNB_SBAR5XLAT_OFFSET;\r\nndev->limits.max_spads = SNB_MAX_B2B_SPADS;\r\nif (ndev->wa_flags & WA_SNB_ERR) {\r\nif (!ndev->mw[ndev->limits.max_mw - 1].bar_sz)\r\nreturn -EINVAL;\r\nndev->limits.max_db_bits = SNB_MAX_DB_BITS;\r\nndev->reg_ofs.spad_write =\r\nndev->mw[ndev->limits.max_mw - 1].vbase +\r\nSNB_SPAD_OFFSET;\r\nndev->reg_ofs.rdb =\r\nndev->mw[ndev->limits.max_mw - 1].vbase +\r\nSNB_PDOORBELL_OFFSET;\r\nwriteq(ndev->mw[1].bar_sz + 0x1000, ndev->reg_base +\r\nSNB_PBAR4LMT_OFFSET);\r\nndev->limits.max_mw = SNB_ERRATA_MAX_MW;\r\n} else {\r\nndev->limits.max_db_bits = SNB_MAX_DB_BITS - 1;\r\nndev->reg_ofs.spad_write = ndev->reg_base +\r\nSNB_B2B_SPAD_OFFSET;\r\nndev->reg_ofs.rdb = ndev->reg_base +\r\nSNB_B2B_DOORBELL_OFFSET;\r\nwriteq(0, ndev->reg_base + SNB_PBAR4LMT_OFFSET);\r\nif (ndev->split_bar)\r\nndev->limits.max_mw = HSX_SPLITBAR_MAX_MW;\r\nelse\r\nndev->limits.max_mw = SNB_MAX_MW;\r\n}\r\nif (ndev->dev_type == NTB_DEV_USD) {\r\nwriteq(SNB_MBAR23_DSD_ADDR, ndev->reg_base +\r\nSNB_PBAR2XLAT_OFFSET);\r\nif (ndev->wa_flags & WA_SNB_ERR)\r\nwriteq(SNB_MBAR01_DSD_ADDR, ndev->reg_base +\r\nSNB_PBAR4XLAT_OFFSET);\r\nelse {\r\nif (ndev->split_bar) {\r\nwritel(SNB_MBAR4_DSD_ADDR,\r\nndev->reg_base +\r\nSNB_PBAR4XLAT_OFFSET);\r\nwritel(SNB_MBAR5_DSD_ADDR,\r\nndev->reg_base +\r\nSNB_PBAR5XLAT_OFFSET);\r\n} else\r\nwriteq(SNB_MBAR4_DSD_ADDR,\r\nndev->reg_base +\r\nSNB_PBAR4XLAT_OFFSET);\r\nwritel(SNB_MBAR01_DSD_ADDR & 0xffffffff,\r\nndev->reg_base + SNB_B2B_XLAT_OFFSETL);\r\nwritel(SNB_MBAR01_DSD_ADDR >> 32,\r\nndev->reg_base + SNB_B2B_XLAT_OFFSETU);\r\n}\r\nwriteq(SNB_MBAR01_USD_ADDR, ndev->reg_base +\r\nSNB_SBAR0BASE_OFFSET);\r\nwriteq(SNB_MBAR23_USD_ADDR, ndev->reg_base +\r\nSNB_SBAR2BASE_OFFSET);\r\nif (ndev->split_bar) {\r\nwritel(SNB_MBAR4_USD_ADDR, ndev->reg_base +\r\nSNB_SBAR4BASE_OFFSET);\r\nwritel(SNB_MBAR5_USD_ADDR, ndev->reg_base +\r\nSNB_SBAR5BASE_OFFSET);\r\n} else\r\nwriteq(SNB_MBAR4_USD_ADDR, ndev->reg_base +\r\nSNB_SBAR4BASE_OFFSET);\r\n} else {\r\nwriteq(SNB_MBAR23_USD_ADDR, ndev->reg_base +\r\nSNB_PBAR2XLAT_OFFSET);\r\nif (ndev->wa_flags & WA_SNB_ERR)\r\nwriteq(SNB_MBAR01_USD_ADDR, ndev->reg_base +\r\nSNB_PBAR4XLAT_OFFSET);\r\nelse {\r\nif (ndev->split_bar) {\r\nwritel(SNB_MBAR4_USD_ADDR,\r\nndev->reg_base +\r\nSNB_PBAR4XLAT_OFFSET);\r\nwritel(SNB_MBAR5_USD_ADDR,\r\nndev->reg_base +\r\nSNB_PBAR5XLAT_OFFSET);\r\n} else\r\nwriteq(SNB_MBAR4_USD_ADDR,\r\nndev->reg_base +\r\nSNB_PBAR4XLAT_OFFSET);\r\nwritel(SNB_MBAR01_USD_ADDR & 0xffffffff,\r\nndev->reg_base + SNB_B2B_XLAT_OFFSETL);\r\nwritel(SNB_MBAR01_USD_ADDR >> 32,\r\nndev->reg_base + SNB_B2B_XLAT_OFFSETU);\r\n}\r\nwriteq(SNB_MBAR01_DSD_ADDR, ndev->reg_base +\r\nSNB_SBAR0BASE_OFFSET);\r\nwriteq(SNB_MBAR23_DSD_ADDR, ndev->reg_base +\r\nSNB_SBAR2BASE_OFFSET);\r\nif (ndev->split_bar) {\r\nwritel(SNB_MBAR4_DSD_ADDR, ndev->reg_base +\r\nSNB_SBAR4BASE_OFFSET);\r\nwritel(SNB_MBAR5_DSD_ADDR, ndev->reg_base +\r\nSNB_SBAR5BASE_OFFSET);\r\n} else\r\nwriteq(SNB_MBAR4_DSD_ADDR, ndev->reg_base +\r\nSNB_SBAR4BASE_OFFSET);\r\n}\r\nbreak;\r\ncase NTB_CONN_RP:\r\nif (ndev->wa_flags & WA_SNB_ERR) {\r\ndev_err(&ndev->pdev->dev,\r\n"NTB-RP disabled due to hardware errata.\n");\r\nreturn -EINVAL;\r\n}\r\nndev->limits.max_spads = SNB_MAX_COMPAT_SPADS / 2;\r\nndev->limits.max_db_bits = SNB_MAX_DB_BITS;\r\nndev->reg_ofs.rdb = ndev->reg_base + SNB_SDOORBELL_OFFSET;\r\nndev->reg_ofs.ldb = ndev->reg_base + SNB_PDOORBELL_OFFSET;\r\nndev->reg_ofs.ldb_mask = ndev->reg_base + SNB_PDBMSK_OFFSET;\r\nndev->reg_ofs.spad_write = ndev->reg_base + SNB_SPAD_OFFSET +\r\nndev->limits.max_spads * 4;\r\nndev->reg_ofs.spad_read = ndev->reg_base + SNB_SPAD_OFFSET;\r\nndev->reg_ofs.bar2_xlat = ndev->reg_base + SNB_SBAR2XLAT_OFFSET;\r\nndev->reg_ofs.bar4_xlat = ndev->reg_base + SNB_SBAR4XLAT_OFFSET;\r\nif (ndev->split_bar) {\r\nndev->reg_ofs.bar5_xlat =\r\nndev->reg_base + SNB_SBAR5XLAT_OFFSET;\r\nndev->limits.max_mw = HSX_SPLITBAR_MAX_MW;\r\n} else\r\nndev->limits.max_mw = SNB_MAX_MW;\r\nbreak;\r\ncase NTB_CONN_TRANSPARENT:\r\nif (ndev->wa_flags & WA_SNB_ERR) {\r\ndev_err(&ndev->pdev->dev,\r\n"NTB-TRANSPARENT disabled due to hardware errata.\n");\r\nreturn -EINVAL;\r\n}\r\nndev->limits.max_spads = SNB_MAX_COMPAT_SPADS / 2;\r\nndev->limits.max_db_bits = SNB_MAX_DB_BITS;\r\nndev->reg_ofs.rdb = ndev->reg_base + SNB_PDOORBELL_OFFSET;\r\nndev->reg_ofs.ldb = ndev->reg_base + SNB_SDOORBELL_OFFSET;\r\nndev->reg_ofs.ldb_mask = ndev->reg_base + SNB_SDBMSK_OFFSET;\r\nndev->reg_ofs.spad_write = ndev->reg_base + SNB_SPAD_OFFSET;\r\nndev->reg_ofs.spad_read = ndev->reg_base + SNB_SPAD_OFFSET +\r\nndev->limits.max_spads * 4;\r\nndev->reg_ofs.bar2_xlat = ndev->reg_base + SNB_PBAR2XLAT_OFFSET;\r\nndev->reg_ofs.bar4_xlat = ndev->reg_base + SNB_PBAR4XLAT_OFFSET;\r\nif (ndev->split_bar) {\r\nndev->reg_ofs.bar5_xlat =\r\nndev->reg_base + SNB_PBAR5XLAT_OFFSET;\r\nndev->limits.max_mw = HSX_SPLITBAR_MAX_MW;\r\n} else\r\nndev->limits.max_mw = SNB_MAX_MW;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nndev->reg_ofs.lnk_cntl = ndev->reg_base + SNB_NTBCNTL_OFFSET;\r\nndev->reg_ofs.lnk_stat = ndev->reg_base + SNB_SLINK_STATUS_OFFSET;\r\nndev->reg_ofs.spci_cmd = ndev->reg_base + SNB_PCICMD_OFFSET;\r\nndev->limits.msix_cnt = SNB_MSIX_CNT;\r\nndev->bits_per_vector = SNB_DB_BITS_PER_VEC;\r\nreturn 0;\r\n}\r\nstatic int ntb_bwd_setup(struct ntb_device *ndev)\r\n{\r\nint rc;\r\nu32 val;\r\nndev->hw_type = BWD_HW;\r\nrc = pci_read_config_dword(ndev->pdev, NTB_PPD_OFFSET, &val);\r\nif (rc)\r\nreturn rc;\r\nswitch ((val & BWD_PPD_CONN_TYPE) >> 8) {\r\ncase NTB_CONN_B2B:\r\nndev->conn_type = NTB_CONN_B2B;\r\nbreak;\r\ncase NTB_CONN_RP:\r\ndefault:\r\ndev_err(&ndev->pdev->dev, "Unsupported NTB configuration\n");\r\nreturn -EINVAL;\r\n}\r\nif (val & BWD_PPD_DEV_TYPE)\r\nndev->dev_type = NTB_DEV_DSD;\r\nelse\r\nndev->dev_type = NTB_DEV_USD;\r\nrc = pci_write_config_dword(ndev->pdev, NTB_PPD_OFFSET,\r\nval | BWD_PPD_INIT_LINK);\r\nif (rc)\r\nreturn rc;\r\nndev->reg_ofs.ldb = ndev->reg_base + BWD_PDOORBELL_OFFSET;\r\nndev->reg_ofs.ldb_mask = ndev->reg_base + BWD_PDBMSK_OFFSET;\r\nndev->reg_ofs.rdb = ndev->reg_base + BWD_B2B_DOORBELL_OFFSET;\r\nndev->reg_ofs.bar2_xlat = ndev->reg_base + BWD_SBAR2XLAT_OFFSET;\r\nndev->reg_ofs.bar4_xlat = ndev->reg_base + BWD_SBAR4XLAT_OFFSET;\r\nndev->reg_ofs.lnk_cntl = ndev->reg_base + BWD_NTBCNTL_OFFSET;\r\nndev->reg_ofs.lnk_stat = ndev->reg_base + BWD_LINK_STATUS_OFFSET;\r\nndev->reg_ofs.spad_read = ndev->reg_base + BWD_SPAD_OFFSET;\r\nndev->reg_ofs.spad_write = ndev->reg_base + BWD_B2B_SPAD_OFFSET;\r\nndev->reg_ofs.spci_cmd = ndev->reg_base + BWD_PCICMD_OFFSET;\r\nndev->limits.max_mw = BWD_MAX_MW;\r\nndev->limits.max_spads = BWD_MAX_SPADS;\r\nndev->limits.max_db_bits = BWD_MAX_DB_BITS;\r\nndev->limits.msix_cnt = BWD_MSIX_CNT;\r\nndev->bits_per_vector = BWD_DB_BITS_PER_VEC;\r\nINIT_DELAYED_WORK(&ndev->hb_timer, bwd_link_poll);\r\nINIT_DELAYED_WORK(&ndev->lr_timer, bwd_link_recovery);\r\nschedule_delayed_work(&ndev->hb_timer, NTB_HB_TIMEOUT);\r\nreturn 0;\r\n}\r\nstatic int ntb_device_setup(struct ntb_device *ndev)\r\n{\r\nint rc;\r\nif (is_ntb_xeon(ndev))\r\nrc = ntb_xeon_setup(ndev);\r\nelse if (is_ntb_atom(ndev))\r\nrc = ntb_bwd_setup(ndev);\r\nelse\r\nrc = -ENODEV;\r\nif (rc)\r\nreturn rc;\r\nif (ndev->conn_type == NTB_CONN_B2B)\r\nwritew(PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER,\r\nndev->reg_ofs.spci_cmd);\r\nreturn 0;\r\n}\r\nstatic void ntb_device_free(struct ntb_device *ndev)\r\n{\r\nif (is_ntb_atom(ndev)) {\r\ncancel_delayed_work_sync(&ndev->hb_timer);\r\ncancel_delayed_work_sync(&ndev->lr_timer);\r\n}\r\n}\r\nstatic irqreturn_t bwd_callback_msix_irq(int irq, void *data)\r\n{\r\nstruct ntb_db_cb *db_cb = data;\r\nstruct ntb_device *ndev = db_cb->ndev;\r\nunsigned long mask;\r\ndev_dbg(&ndev->pdev->dev, "MSI-X irq %d received for DB %d\n", irq,\r\ndb_cb->db_num);\r\nmask = readw(ndev->reg_ofs.ldb_mask);\r\nset_bit(db_cb->db_num * ndev->bits_per_vector, &mask);\r\nwritew(mask, ndev->reg_ofs.ldb_mask);\r\ntasklet_schedule(&db_cb->irq_work);\r\nndev->last_ts = jiffies;\r\nwriteq((u64) 1 << db_cb->db_num, ndev->reg_ofs.ldb);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t xeon_callback_msix_irq(int irq, void *data)\r\n{\r\nstruct ntb_db_cb *db_cb = data;\r\nstruct ntb_device *ndev = db_cb->ndev;\r\nunsigned long mask;\r\ndev_dbg(&ndev->pdev->dev, "MSI-X irq %d received for DB %d\n", irq,\r\ndb_cb->db_num);\r\nmask = readw(ndev->reg_ofs.ldb_mask);\r\nset_bit(db_cb->db_num * ndev->bits_per_vector, &mask);\r\nwritew(mask, ndev->reg_ofs.ldb_mask);\r\ntasklet_schedule(&db_cb->irq_work);\r\nwritew(((1 << ndev->bits_per_vector) - 1) <<\r\n(db_cb->db_num * ndev->bits_per_vector), ndev->reg_ofs.ldb);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t xeon_event_msix_irq(int irq, void *dev)\r\n{\r\nstruct ntb_device *ndev = dev;\r\nint rc;\r\ndev_dbg(&ndev->pdev->dev, "MSI-X irq %d received for Events\n", irq);\r\nrc = ntb_link_status(ndev);\r\nif (rc)\r\ndev_err(&ndev->pdev->dev, "Error determining link status\n");\r\nwritew(1 << SNB_LINK_DB, ndev->reg_ofs.ldb);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ntb_interrupt(int irq, void *dev)\r\n{\r\nstruct ntb_device *ndev = dev;\r\nunsigned int i = 0;\r\nif (is_ntb_atom(ndev)) {\r\nu64 ldb = readq(ndev->reg_ofs.ldb);\r\ndev_dbg(&ndev->pdev->dev, "irq %d - ldb = %Lx\n", irq, ldb);\r\nwhile (ldb) {\r\ni = __ffs(ldb);\r\nldb &= ldb - 1;\r\nbwd_callback_msix_irq(irq, &ndev->db_cb[i]);\r\n}\r\n} else {\r\nu16 ldb = readw(ndev->reg_ofs.ldb);\r\ndev_dbg(&ndev->pdev->dev, "irq %d - ldb = %x\n", irq, ldb);\r\nif (ldb & SNB_DB_HW_LINK) {\r\nxeon_event_msix_irq(irq, dev);\r\nldb &= ~SNB_DB_HW_LINK;\r\n}\r\nwhile (ldb) {\r\ni = __ffs(ldb);\r\nldb &= ldb - 1;\r\nxeon_callback_msix_irq(irq, &ndev->db_cb[i]);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ntb_setup_snb_msix(struct ntb_device *ndev, int msix_entries)\r\n{\r\nstruct pci_dev *pdev = ndev->pdev;\r\nstruct msix_entry *msix;\r\nint rc, i;\r\nif (msix_entries < ndev->limits.msix_cnt)\r\nreturn -ENOSPC;\r\nrc = pci_enable_msix_exact(pdev, ndev->msix_entries, msix_entries);\r\nif (rc < 0)\r\nreturn rc;\r\nfor (i = 0; i < msix_entries; i++) {\r\nmsix = &ndev->msix_entries[i];\r\nWARN_ON(!msix->vector);\r\nif (i == msix_entries - 1) {\r\nrc = request_irq(msix->vector,\r\nxeon_event_msix_irq, 0,\r\n"ntb-event-msix", ndev);\r\nif (rc)\r\ngoto err;\r\n} else {\r\nrc = request_irq(msix->vector,\r\nxeon_callback_msix_irq, 0,\r\n"ntb-callback-msix",\r\n&ndev->db_cb[i]);\r\nif (rc)\r\ngoto err;\r\n}\r\n}\r\nndev->num_msix = msix_entries;\r\nndev->max_cbs = msix_entries - 1;\r\nreturn 0;\r\nerr:\r\nwhile (--i >= 0) {\r\nmsix = &ndev->msix_entries[i];\r\nfree_irq(msix->vector, &ndev->db_cb[i]);\r\n}\r\npci_disable_msix(pdev);\r\nndev->num_msix = 0;\r\nreturn rc;\r\n}\r\nstatic int ntb_setup_bwd_msix(struct ntb_device *ndev, int msix_entries)\r\n{\r\nstruct pci_dev *pdev = ndev->pdev;\r\nstruct msix_entry *msix;\r\nint rc, i;\r\nmsix_entries = pci_enable_msix_range(pdev, ndev->msix_entries,\r\n1, msix_entries);\r\nif (msix_entries < 0)\r\nreturn msix_entries;\r\nfor (i = 0; i < msix_entries; i++) {\r\nmsix = &ndev->msix_entries[i];\r\nWARN_ON(!msix->vector);\r\nrc = request_irq(msix->vector, bwd_callback_msix_irq, 0,\r\n"ntb-callback-msix", &ndev->db_cb[i]);\r\nif (rc)\r\ngoto err;\r\n}\r\nndev->num_msix = msix_entries;\r\nndev->max_cbs = msix_entries;\r\nreturn 0;\r\nerr:\r\nwhile (--i >= 0)\r\nfree_irq(msix->vector, &ndev->db_cb[i]);\r\npci_disable_msix(pdev);\r\nndev->num_msix = 0;\r\nreturn rc;\r\n}\r\nstatic int ntb_setup_msix(struct ntb_device *ndev)\r\n{\r\nstruct pci_dev *pdev = ndev->pdev;\r\nint msix_entries;\r\nint rc, i;\r\nmsix_entries = pci_msix_vec_count(pdev);\r\nif (msix_entries < 0) {\r\nrc = msix_entries;\r\ngoto err;\r\n} else if (msix_entries > ndev->limits.msix_cnt) {\r\nrc = -EINVAL;\r\ngoto err;\r\n}\r\nndev->msix_entries = kmalloc(sizeof(struct msix_entry) * msix_entries,\r\nGFP_KERNEL);\r\nif (!ndev->msix_entries) {\r\nrc = -ENOMEM;\r\ngoto err;\r\n}\r\nfor (i = 0; i < msix_entries; i++)\r\nndev->msix_entries[i].entry = i;\r\nif (is_ntb_atom(ndev))\r\nrc = ntb_setup_bwd_msix(ndev, msix_entries);\r\nelse\r\nrc = ntb_setup_snb_msix(ndev, msix_entries);\r\nif (rc)\r\ngoto err1;\r\nreturn 0;\r\nerr1:\r\nkfree(ndev->msix_entries);\r\nerr:\r\ndev_err(&pdev->dev, "Error allocating MSI-X interrupt\n");\r\nreturn rc;\r\n}\r\nstatic int ntb_setup_msi(struct ntb_device *ndev)\r\n{\r\nstruct pci_dev *pdev = ndev->pdev;\r\nint rc;\r\nrc = pci_enable_msi(pdev);\r\nif (rc)\r\nreturn rc;\r\nrc = request_irq(pdev->irq, ntb_interrupt, 0, "ntb-msi", ndev);\r\nif (rc) {\r\npci_disable_msi(pdev);\r\ndev_err(&pdev->dev, "Error allocating MSI interrupt\n");\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ntb_setup_intx(struct ntb_device *ndev)\r\n{\r\nstruct pci_dev *pdev = ndev->pdev;\r\nint rc;\r\npci_msi_off(pdev);\r\npci_intx(pdev, 1);\r\nrc = request_irq(pdev->irq, ntb_interrupt, IRQF_SHARED, "ntb-intx",\r\nndev);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int ntb_setup_interrupts(struct ntb_device *ndev)\r\n{\r\nint rc;\r\nif (is_ntb_atom(ndev))\r\nwriteq(~0, ndev->reg_ofs.ldb_mask);\r\nelse {\r\nu16 var = 1 << SNB_LINK_DB;\r\nwritew(~var, ndev->reg_ofs.ldb_mask);\r\n}\r\nrc = ntb_setup_msix(ndev);\r\nif (!rc)\r\ngoto done;\r\nndev->bits_per_vector = 1;\r\nndev->max_cbs = ndev->limits.max_db_bits;\r\nrc = ntb_setup_msi(ndev);\r\nif (!rc)\r\ngoto done;\r\nrc = ntb_setup_intx(ndev);\r\nif (rc) {\r\ndev_err(&ndev->pdev->dev, "no usable interrupts\n");\r\nreturn rc;\r\n}\r\ndone:\r\nreturn 0;\r\n}\r\nstatic void ntb_free_interrupts(struct ntb_device *ndev)\r\n{\r\nstruct pci_dev *pdev = ndev->pdev;\r\nif (is_ntb_atom(ndev))\r\nwriteq(~0, ndev->reg_ofs.ldb_mask);\r\nelse\r\nwritew(~0, ndev->reg_ofs.ldb_mask);\r\nif (ndev->num_msix) {\r\nstruct msix_entry *msix;\r\nu32 i;\r\nfor (i = 0; i < ndev->num_msix; i++) {\r\nmsix = &ndev->msix_entries[i];\r\nif (is_ntb_xeon(ndev) && i == ndev->num_msix - 1)\r\nfree_irq(msix->vector, ndev);\r\nelse\r\nfree_irq(msix->vector, &ndev->db_cb[i]);\r\n}\r\npci_disable_msix(pdev);\r\nkfree(ndev->msix_entries);\r\n} else {\r\nfree_irq(pdev->irq, ndev);\r\nif (pci_dev_msi_enabled(pdev))\r\npci_disable_msi(pdev);\r\n}\r\n}\r\nstatic int ntb_create_callbacks(struct ntb_device *ndev)\r\n{\r\nint i;\r\nndev->db_cb = kcalloc(ndev->limits.max_db_bits,\r\nsizeof(struct ntb_db_cb),\r\nGFP_KERNEL);\r\nif (!ndev->db_cb)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ndev->limits.max_db_bits; i++) {\r\nndev->db_cb[i].db_num = i;\r\nndev->db_cb[i].ndev = ndev;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ntb_free_callbacks(struct ntb_device *ndev)\r\n{\r\nint i;\r\nfor (i = 0; i < ndev->limits.max_db_bits; i++)\r\nntb_unregister_db_callback(ndev, i);\r\nkfree(ndev->db_cb);\r\n}\r\nstatic ssize_t ntb_debugfs_read(struct file *filp, char __user *ubuf,\r\nsize_t count, loff_t *offp)\r\n{\r\nstruct ntb_device *ndev;\r\nchar *buf;\r\nssize_t ret, offset, out_count;\r\nout_count = 500;\r\nbuf = kmalloc(out_count, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nndev = filp->private_data;\r\noffset = 0;\r\noffset += snprintf(buf + offset, out_count - offset,\r\n"NTB Device Information:\n");\r\noffset += snprintf(buf + offset, out_count - offset,\r\n"Connection Type - \t\t%s\n",\r\nndev->conn_type == NTB_CONN_TRANSPARENT ?\r\n"Transparent" : (ndev->conn_type == NTB_CONN_B2B) ?\r\n"Back to back" : "Root Port");\r\noffset += snprintf(buf + offset, out_count - offset,\r\n"Device Type - \t\t\t%s\n",\r\nndev->dev_type == NTB_DEV_USD ?\r\n"DSD/USP" : "USD/DSP");\r\noffset += snprintf(buf + offset, out_count - offset,\r\n"Max Number of Callbacks - \t%u\n",\r\nntb_max_cbs(ndev));\r\noffset += snprintf(buf + offset, out_count - offset,\r\n"Link Status - \t\t\t%s\n",\r\nntb_hw_link_status(ndev) ? "Up" : "Down");\r\nif (ntb_hw_link_status(ndev)) {\r\noffset += snprintf(buf + offset, out_count - offset,\r\n"Link Speed - \t\t\tPCI-E Gen %u\n",\r\nndev->link_speed);\r\noffset += snprintf(buf + offset, out_count - offset,\r\n"Link Width - \t\t\tx%u\n",\r\nndev->link_width);\r\n}\r\nif (is_ntb_xeon(ndev)) {\r\nu32 status32;\r\nu16 status16;\r\nint rc;\r\noffset += snprintf(buf + offset, out_count - offset,\r\n"\nNTB Device Statistics:\n");\r\noffset += snprintf(buf + offset, out_count - offset,\r\n"Upstream Memory Miss - \t%u\n",\r\nreadw(ndev->reg_base +\r\nSNB_USMEMMISS_OFFSET));\r\noffset += snprintf(buf + offset, out_count - offset,\r\n"\nNTB Hardware Errors:\n");\r\nrc = pci_read_config_word(ndev->pdev, SNB_DEVSTS_OFFSET,\r\n&status16);\r\nif (!rc)\r\noffset += snprintf(buf + offset, out_count - offset,\r\n"DEVSTS - \t%#06x\n", status16);\r\nrc = pci_read_config_word(ndev->pdev, SNB_LINK_STATUS_OFFSET,\r\n&status16);\r\nif (!rc)\r\noffset += snprintf(buf + offset, out_count - offset,\r\n"LNKSTS - \t%#06x\n", status16);\r\nrc = pci_read_config_dword(ndev->pdev, SNB_UNCERRSTS_OFFSET,\r\n&status32);\r\nif (!rc)\r\noffset += snprintf(buf + offset, out_count - offset,\r\n"UNCERRSTS - \t%#010x\n", status32);\r\nrc = pci_read_config_dword(ndev->pdev, SNB_CORERRSTS_OFFSET,\r\n&status32);\r\nif (!rc)\r\noffset += snprintf(buf + offset, out_count - offset,\r\n"CORERRSTS - \t%#010x\n", status32);\r\n}\r\nif (offset > out_count)\r\noffset = out_count;\r\nret = simple_read_from_buffer(ubuf, count, offp, buf, offset);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void ntb_setup_debugfs(struct ntb_device *ndev)\r\n{\r\nif (!debugfs_initialized())\r\nreturn;\r\nif (!debugfs_dir)\r\ndebugfs_dir = debugfs_create_dir(KBUILD_MODNAME, NULL);\r\nndev->debugfs_dir = debugfs_create_dir(pci_name(ndev->pdev),\r\ndebugfs_dir);\r\nif (ndev->debugfs_dir)\r\nndev->debugfs_info = debugfs_create_file("info", S_IRUSR,\r\nndev->debugfs_dir,\r\nndev,\r\n&ntb_debugfs_info);\r\n}\r\nstatic void ntb_free_debugfs(struct ntb_device *ndev)\r\n{\r\ndebugfs_remove_recursive(ndev->debugfs_dir);\r\nif (debugfs_dir && simple_empty(debugfs_dir)) {\r\ndebugfs_remove_recursive(debugfs_dir);\r\ndebugfs_dir = NULL;\r\n}\r\n}\r\nstatic void ntb_hw_link_up(struct ntb_device *ndev)\r\n{\r\nif (ndev->conn_type == NTB_CONN_TRANSPARENT)\r\nntb_link_event(ndev, NTB_LINK_UP);\r\nelse {\r\nu32 ntb_cntl;\r\nntb_cntl = readl(ndev->reg_ofs.lnk_cntl);\r\nntb_cntl &= ~(NTB_CNTL_LINK_DISABLE | NTB_CNTL_CFG_LOCK);\r\nntb_cntl |= NTB_CNTL_P2S_BAR23_SNOOP | NTB_CNTL_S2P_BAR23_SNOOP;\r\nntb_cntl |= NTB_CNTL_P2S_BAR4_SNOOP | NTB_CNTL_S2P_BAR4_SNOOP;\r\nif (ndev->split_bar)\r\nntb_cntl |= NTB_CNTL_P2S_BAR5_SNOOP |\r\nNTB_CNTL_S2P_BAR5_SNOOP;\r\nwritel(ntb_cntl, ndev->reg_ofs.lnk_cntl);\r\n}\r\n}\r\nstatic void ntb_hw_link_down(struct ntb_device *ndev)\r\n{\r\nu32 ntb_cntl;\r\nif (ndev->conn_type == NTB_CONN_TRANSPARENT) {\r\nntb_link_event(ndev, NTB_LINK_DOWN);\r\nreturn;\r\n}\r\nntb_cntl = readl(ndev->reg_ofs.lnk_cntl);\r\nntb_cntl &= ~(NTB_CNTL_P2S_BAR23_SNOOP | NTB_CNTL_S2P_BAR23_SNOOP);\r\nntb_cntl &= ~(NTB_CNTL_P2S_BAR4_SNOOP | NTB_CNTL_S2P_BAR4_SNOOP);\r\nif (ndev->split_bar)\r\nntb_cntl &= ~(NTB_CNTL_P2S_BAR5_SNOOP |\r\nNTB_CNTL_S2P_BAR5_SNOOP);\r\nntb_cntl |= NTB_CNTL_LINK_DISABLE | NTB_CNTL_CFG_LOCK;\r\nwritel(ntb_cntl, ndev->reg_ofs.lnk_cntl);\r\n}\r\nstatic void ntb_max_mw_detect(struct ntb_device *ndev)\r\n{\r\nif (ndev->split_bar)\r\nndev->limits.max_mw = HSX_SPLITBAR_MAX_MW;\r\nelse\r\nndev->limits.max_mw = SNB_MAX_MW;\r\n}\r\nstatic int ntb_xeon_detect(struct ntb_device *ndev)\r\n{\r\nint rc, bars_mask;\r\nu32 bars;\r\nu8 ppd;\r\nndev->hw_type = SNB_HW;\r\nrc = pci_read_config_byte(ndev->pdev, NTB_PPD_OFFSET, &ppd);\r\nif (rc)\r\nreturn -EIO;\r\nif (ppd & SNB_PPD_DEV_TYPE)\r\nndev->dev_type = NTB_DEV_USD;\r\nelse\r\nndev->dev_type = NTB_DEV_DSD;\r\nndev->split_bar = (ppd & SNB_PPD_SPLIT_BAR) ? 1 : 0;\r\nswitch (ppd & SNB_PPD_CONN_TYPE) {\r\ncase NTB_CONN_B2B:\r\ndev_info(&ndev->pdev->dev, "Conn Type = B2B\n");\r\nndev->conn_type = NTB_CONN_B2B;\r\nbreak;\r\ncase NTB_CONN_RP:\r\ndev_info(&ndev->pdev->dev, "Conn Type = RP\n");\r\nndev->conn_type = NTB_CONN_RP;\r\nbreak;\r\ncase NTB_CONN_TRANSPARENT:\r\ndev_info(&ndev->pdev->dev, "Conn Type = TRANSPARENT\n");\r\nndev->conn_type = NTB_CONN_TRANSPARENT;\r\nndev->dev_type = NTB_DEV_USD;\r\nbars_mask = pci_select_bars(ndev->pdev, IORESOURCE_MEM);\r\nbars = hweight32(bars_mask);\r\nif (bars == (HSX_SPLITBAR_MAX_MW + 1))\r\nndev->split_bar = 1;\r\nbreak;\r\ndefault:\r\ndev_err(&ndev->pdev->dev, "Unknown PPD %x\n", ppd);\r\nreturn -ENODEV;\r\n}\r\nntb_max_mw_detect(ndev);\r\nreturn 0;\r\n}\r\nstatic int ntb_atom_detect(struct ntb_device *ndev)\r\n{\r\nint rc;\r\nu32 ppd;\r\nndev->hw_type = BWD_HW;\r\nrc = pci_read_config_dword(ndev->pdev, NTB_PPD_OFFSET, &ppd);\r\nif (rc)\r\nreturn rc;\r\nswitch ((ppd & BWD_PPD_CONN_TYPE) >> 8) {\r\ncase NTB_CONN_B2B:\r\ndev_info(&ndev->pdev->dev, "Conn Type = B2B\n");\r\nndev->conn_type = NTB_CONN_B2B;\r\nbreak;\r\ncase NTB_CONN_RP:\r\ndefault:\r\ndev_err(&ndev->pdev->dev, "Unsupported NTB configuration\n");\r\nreturn -EINVAL;\r\n}\r\nif (ppd & BWD_PPD_DEV_TYPE)\r\nndev->dev_type = NTB_DEV_DSD;\r\nelse\r\nndev->dev_type = NTB_DEV_USD;\r\nreturn 0;\r\n}\r\nstatic int ntb_device_detect(struct ntb_device *ndev)\r\n{\r\nint rc;\r\nif (is_ntb_xeon(ndev))\r\nrc = ntb_xeon_detect(ndev);\r\nelse if (is_ntb_atom(ndev))\r\nrc = ntb_atom_detect(ndev);\r\nelse\r\nrc = -ENODEV;\r\ndev_info(&ndev->pdev->dev, "Device Type = %s\n",\r\nndev->dev_type == NTB_DEV_USD ? "USD/DSP" : "DSD/USP");\r\nreturn 0;\r\n}\r\nstatic int ntb_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct ntb_device *ndev;\r\nint rc, i;\r\nndev = kzalloc(sizeof(struct ntb_device), GFP_KERNEL);\r\nif (!ndev)\r\nreturn -ENOMEM;\r\nndev->pdev = pdev;\r\nntb_set_errata_flags(ndev);\r\nndev->link_status = NTB_LINK_DOWN;\r\npci_set_drvdata(pdev, ndev);\r\nntb_setup_debugfs(ndev);\r\nrc = pci_enable_device(pdev);\r\nif (rc)\r\ngoto err;\r\npci_set_master(ndev->pdev);\r\nrc = ntb_device_detect(ndev);\r\nif (rc)\r\ngoto err;\r\nndev->mw = kcalloc(ndev->limits.max_mw, sizeof(struct ntb_mw),\r\nGFP_KERNEL);\r\nif (!ndev->mw) {\r\nrc = -ENOMEM;\r\ngoto err1;\r\n}\r\nif (ndev->split_bar)\r\nrc = pci_request_selected_regions(pdev, NTB_SPLITBAR_MASK,\r\nKBUILD_MODNAME);\r\nelse\r\nrc = pci_request_selected_regions(pdev, NTB_BAR_MASK,\r\nKBUILD_MODNAME);\r\nif (rc)\r\ngoto err2;\r\nndev->reg_base = pci_ioremap_bar(pdev, NTB_BAR_MMIO);\r\nif (!ndev->reg_base) {\r\ndev_warn(&pdev->dev, "Cannot remap BAR 0\n");\r\nrc = -EIO;\r\ngoto err3;\r\n}\r\nfor (i = 0; i < ndev->limits.max_mw; i++) {\r\nndev->mw[i].bar_sz = pci_resource_len(pdev, MW_TO_BAR(i));\r\nif ((ndev->wa_flags & WA_SNB_ERR) &&\r\n(i == (ndev->limits.max_mw - 1))) {\r\nndev->mw[i].vbase =\r\nioremap_nocache(pci_resource_start(pdev,\r\nMW_TO_BAR(i)),\r\nndev->mw[i].bar_sz);\r\n} else {\r\nndev->mw[i].vbase =\r\nioremap_wc(pci_resource_start(pdev,\r\nMW_TO_BAR(i)),\r\nndev->mw[i].bar_sz);\r\n}\r\ndev_info(&pdev->dev, "MW %d size %llu\n", i,\r\n(unsigned long long) ndev->mw[i].bar_sz);\r\nif (!ndev->mw[i].vbase) {\r\ndev_warn(&pdev->dev, "Cannot remap BAR %d\n",\r\nMW_TO_BAR(i));\r\nrc = -EIO;\r\ngoto err3;\r\n}\r\n}\r\nrc = pci_set_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (rc) {\r\nrc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc)\r\ngoto err4;\r\ndev_warn(&pdev->dev, "Cannot DMA highmem\n");\r\n}\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));\r\nif (rc) {\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc)\r\ngoto err4;\r\ndev_warn(&pdev->dev, "Cannot DMA consistent highmem\n");\r\n}\r\nrc = ntb_device_setup(ndev);\r\nif (rc)\r\ngoto err4;\r\nrc = ntb_create_callbacks(ndev);\r\nif (rc)\r\ngoto err5;\r\nrc = ntb_setup_interrupts(ndev);\r\nif (rc)\r\ngoto err6;\r\nfor (i = 0; i < ndev->limits.max_spads; i++) {\r\nntb_write_local_spad(ndev, i, 0);\r\nntb_write_remote_spad(ndev, i, 0);\r\n}\r\nrc = ntb_transport_init(pdev);\r\nif (rc)\r\ngoto err7;\r\nntb_hw_link_up(ndev);\r\nreturn 0;\r\nerr7:\r\nntb_free_interrupts(ndev);\r\nerr6:\r\nntb_free_callbacks(ndev);\r\nerr5:\r\nntb_device_free(ndev);\r\nerr4:\r\nfor (i--; i >= 0; i--)\r\niounmap(ndev->mw[i].vbase);\r\niounmap(ndev->reg_base);\r\nerr3:\r\nif (ndev->split_bar)\r\npci_release_selected_regions(pdev, NTB_SPLITBAR_MASK);\r\nelse\r\npci_release_selected_regions(pdev, NTB_BAR_MASK);\r\nerr2:\r\nkfree(ndev->mw);\r\nerr1:\r\npci_disable_device(pdev);\r\nerr:\r\nntb_free_debugfs(ndev);\r\nkfree(ndev);\r\ndev_err(&pdev->dev, "Error loading %s module\n", KBUILD_MODNAME);\r\nreturn rc;\r\n}\r\nstatic void ntb_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct ntb_device *ndev = pci_get_drvdata(pdev);\r\nint i;\r\nntb_hw_link_down(ndev);\r\nntb_transport_free(ndev->ntb_transport);\r\nntb_free_interrupts(ndev);\r\nntb_free_callbacks(ndev);\r\nntb_device_free(ndev);\r\nif (ndev->hw_type == SNB_HW)\r\nntb_max_mw_detect(ndev);\r\nfor (i = 0; i < ndev->limits.max_mw; i++)\r\niounmap(ndev->mw[i].vbase);\r\nkfree(ndev->mw);\r\niounmap(ndev->reg_base);\r\nif (ndev->split_bar)\r\npci_release_selected_regions(pdev, NTB_SPLITBAR_MASK);\r\nelse\r\npci_release_selected_regions(pdev, NTB_BAR_MASK);\r\npci_disable_device(pdev);\r\nntb_free_debugfs(ndev);\r\nkfree(ndev);\r\n}
