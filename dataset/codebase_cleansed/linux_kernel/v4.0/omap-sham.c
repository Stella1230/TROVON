static inline u32 omap_sham_read(struct omap_sham_dev *dd, u32 offset)\r\n{\r\nreturn __raw_readl(dd->io_base + offset);\r\n}\r\nstatic inline void omap_sham_write(struct omap_sham_dev *dd,\r\nu32 offset, u32 value)\r\n{\r\n__raw_writel(value, dd->io_base + offset);\r\n}\r\nstatic inline void omap_sham_write_mask(struct omap_sham_dev *dd, u32 address,\r\nu32 value, u32 mask)\r\n{\r\nu32 val;\r\nval = omap_sham_read(dd, address);\r\nval &= ~mask;\r\nval |= value;\r\nomap_sham_write(dd, address, val);\r\n}\r\nstatic inline int omap_sham_wait(struct omap_sham_dev *dd, u32 offset, u32 bit)\r\n{\r\nunsigned long timeout = jiffies + DEFAULT_TIMEOUT_INTERVAL;\r\nwhile (!(omap_sham_read(dd, offset) & bit)) {\r\nif (time_is_before_jiffies(timeout))\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_sham_copy_hash_omap2(struct ahash_request *req, int out)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nstruct omap_sham_dev *dd = ctx->dd;\r\nu32 *hash = (u32 *)ctx->digest;\r\nint i;\r\nfor (i = 0; i < dd->pdata->digest_size / sizeof(u32); i++) {\r\nif (out)\r\nhash[i] = omap_sham_read(dd, SHA_REG_IDIGEST(dd, i));\r\nelse\r\nomap_sham_write(dd, SHA_REG_IDIGEST(dd, i), hash[i]);\r\n}\r\n}\r\nstatic void omap_sham_copy_hash_omap4(struct ahash_request *req, int out)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nstruct omap_sham_dev *dd = ctx->dd;\r\nint i;\r\nif (ctx->flags & BIT(FLAGS_HMAC)) {\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(dd->req);\r\nstruct omap_sham_ctx *tctx = crypto_ahash_ctx(tfm);\r\nstruct omap_sham_hmac_ctx *bctx = tctx->base;\r\nu32 *opad = (u32 *)bctx->opad;\r\nfor (i = 0; i < dd->pdata->digest_size / sizeof(u32); i++) {\r\nif (out)\r\nopad[i] = omap_sham_read(dd,\r\nSHA_REG_ODIGEST(dd, i));\r\nelse\r\nomap_sham_write(dd, SHA_REG_ODIGEST(dd, i),\r\nopad[i]);\r\n}\r\n}\r\nomap_sham_copy_hash_omap2(req, out);\r\n}\r\nstatic void omap_sham_copy_ready_hash(struct ahash_request *req)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nu32 *in = (u32 *)ctx->digest;\r\nu32 *hash = (u32 *)req->result;\r\nint i, d, big_endian = 0;\r\nif (!hash)\r\nreturn;\r\nswitch (ctx->flags & FLAGS_MODE_MASK) {\r\ncase FLAGS_MODE_MD5:\r\nd = MD5_DIGEST_SIZE / sizeof(u32);\r\nbreak;\r\ncase FLAGS_MODE_SHA1:\r\nif (test_bit(FLAGS_BE32_SHA1, &ctx->dd->flags))\r\nbig_endian = 1;\r\nd = SHA1_DIGEST_SIZE / sizeof(u32);\r\nbreak;\r\ncase FLAGS_MODE_SHA224:\r\nd = SHA224_DIGEST_SIZE / sizeof(u32);\r\nbreak;\r\ncase FLAGS_MODE_SHA256:\r\nd = SHA256_DIGEST_SIZE / sizeof(u32);\r\nbreak;\r\ncase FLAGS_MODE_SHA384:\r\nd = SHA384_DIGEST_SIZE / sizeof(u32);\r\nbreak;\r\ncase FLAGS_MODE_SHA512:\r\nd = SHA512_DIGEST_SIZE / sizeof(u32);\r\nbreak;\r\ndefault:\r\nd = 0;\r\n}\r\nif (big_endian)\r\nfor (i = 0; i < d; i++)\r\nhash[i] = be32_to_cpu(in[i]);\r\nelse\r\nfor (i = 0; i < d; i++)\r\nhash[i] = le32_to_cpu(in[i]);\r\n}\r\nstatic int omap_sham_hw_init(struct omap_sham_dev *dd)\r\n{\r\npm_runtime_get_sync(dd->dev);\r\nif (!test_bit(FLAGS_INIT, &dd->flags)) {\r\nset_bit(FLAGS_INIT, &dd->flags);\r\ndd->err = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_sham_write_ctrl_omap2(struct omap_sham_dev *dd, size_t length,\r\nint final, int dma)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(dd->req);\r\nu32 val = length << 5, mask;\r\nif (likely(ctx->digcnt))\r\nomap_sham_write(dd, SHA_REG_DIGCNT(dd), ctx->digcnt);\r\nomap_sham_write_mask(dd, SHA_REG_MASK(dd),\r\nSHA_REG_MASK_IT_EN | (dma ? SHA_REG_MASK_DMA_EN : 0),\r\nSHA_REG_MASK_IT_EN | SHA_REG_MASK_DMA_EN);\r\nif ((ctx->flags & FLAGS_MODE_MASK) == FLAGS_MODE_SHA1)\r\nval |= SHA_REG_CTRL_ALGO;\r\nif (!ctx->digcnt)\r\nval |= SHA_REG_CTRL_ALGO_CONST;\r\nif (final)\r\nval |= SHA_REG_CTRL_CLOSE_HASH;\r\nmask = SHA_REG_CTRL_ALGO_CONST | SHA_REG_CTRL_CLOSE_HASH |\r\nSHA_REG_CTRL_ALGO | SHA_REG_CTRL_LENGTH;\r\nomap_sham_write_mask(dd, SHA_REG_CTRL, val, mask);\r\n}\r\nstatic void omap_sham_trigger_omap2(struct omap_sham_dev *dd, size_t length)\r\n{\r\n}\r\nstatic int omap_sham_poll_irq_omap2(struct omap_sham_dev *dd)\r\n{\r\nreturn omap_sham_wait(dd, SHA_REG_CTRL, SHA_REG_CTRL_INPUT_READY);\r\n}\r\nstatic int get_block_size(struct omap_sham_reqctx *ctx)\r\n{\r\nint d;\r\nswitch (ctx->flags & FLAGS_MODE_MASK) {\r\ncase FLAGS_MODE_MD5:\r\ncase FLAGS_MODE_SHA1:\r\nd = SHA1_BLOCK_SIZE;\r\nbreak;\r\ncase FLAGS_MODE_SHA224:\r\ncase FLAGS_MODE_SHA256:\r\nd = SHA256_BLOCK_SIZE;\r\nbreak;\r\ncase FLAGS_MODE_SHA384:\r\ncase FLAGS_MODE_SHA512:\r\nd = SHA512_BLOCK_SIZE;\r\nbreak;\r\ndefault:\r\nd = 0;\r\n}\r\nreturn d;\r\n}\r\nstatic void omap_sham_write_n(struct omap_sham_dev *dd, u32 offset,\r\nu32 *value, int count)\r\n{\r\nfor (; count--; value++, offset += 4)\r\nomap_sham_write(dd, offset, *value);\r\n}\r\nstatic void omap_sham_write_ctrl_omap4(struct omap_sham_dev *dd, size_t length,\r\nint final, int dma)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(dd->req);\r\nu32 val, mask;\r\nval = (ctx->flags & FLAGS_MODE_MASK) >> (FLAGS_MODE_SHIFT);\r\nif (!ctx->digcnt) {\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(dd->req);\r\nstruct omap_sham_ctx *tctx = crypto_ahash_ctx(tfm);\r\nstruct omap_sham_hmac_ctx *bctx = tctx->base;\r\nint bs, nr_dr;\r\nval |= SHA_REG_MODE_ALGO_CONSTANT;\r\nif (ctx->flags & BIT(FLAGS_HMAC)) {\r\nbs = get_block_size(ctx);\r\nnr_dr = bs / (2 * sizeof(u32));\r\nval |= SHA_REG_MODE_HMAC_KEY_PROC;\r\nomap_sham_write_n(dd, SHA_REG_ODIGEST(dd, 0),\r\n(u32 *)bctx->ipad, nr_dr);\r\nomap_sham_write_n(dd, SHA_REG_IDIGEST(dd, 0),\r\n(u32 *)bctx->ipad + nr_dr, nr_dr);\r\nctx->digcnt += bs;\r\n}\r\n}\r\nif (final) {\r\nval |= SHA_REG_MODE_CLOSE_HASH;\r\nif (ctx->flags & BIT(FLAGS_HMAC))\r\nval |= SHA_REG_MODE_HMAC_OUTER_HASH;\r\n}\r\nmask = SHA_REG_MODE_ALGO_CONSTANT | SHA_REG_MODE_CLOSE_HASH |\r\nSHA_REG_MODE_ALGO_MASK | SHA_REG_MODE_HMAC_OUTER_HASH |\r\nSHA_REG_MODE_HMAC_KEY_PROC;\r\ndev_dbg(dd->dev, "ctrl: %08x, flags: %08lx\n", val, ctx->flags);\r\nomap_sham_write_mask(dd, SHA_REG_MODE(dd), val, mask);\r\nomap_sham_write(dd, SHA_REG_IRQENA, SHA_REG_IRQENA_OUTPUT_RDY);\r\nomap_sham_write_mask(dd, SHA_REG_MASK(dd),\r\nSHA_REG_MASK_IT_EN |\r\n(dma ? SHA_REG_MASK_DMA_EN : 0),\r\nSHA_REG_MASK_IT_EN | SHA_REG_MASK_DMA_EN);\r\n}\r\nstatic void omap_sham_trigger_omap4(struct omap_sham_dev *dd, size_t length)\r\n{\r\nomap_sham_write(dd, SHA_REG_LENGTH(dd), length);\r\n}\r\nstatic int omap_sham_poll_irq_omap4(struct omap_sham_dev *dd)\r\n{\r\nreturn omap_sham_wait(dd, SHA_REG_IRQSTATUS,\r\nSHA_REG_IRQSTATUS_INPUT_RDY);\r\n}\r\nstatic int omap_sham_xmit_cpu(struct omap_sham_dev *dd, const u8 *buf,\r\nsize_t length, int final)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(dd->req);\r\nint count, len32, bs32, offset = 0;\r\nconst u32 *buffer = (const u32 *)buf;\r\ndev_dbg(dd->dev, "xmit_cpu: digcnt: %d, length: %d, final: %d\n",\r\nctx->digcnt, length, final);\r\ndd->pdata->write_ctrl(dd, length, final, 0);\r\ndd->pdata->trigger(dd, length);\r\nctx->digcnt += length;\r\nif (final)\r\nset_bit(FLAGS_FINAL, &dd->flags);\r\nset_bit(FLAGS_CPU, &dd->flags);\r\nlen32 = DIV_ROUND_UP(length, sizeof(u32));\r\nbs32 = get_block_size(ctx) / sizeof(u32);\r\nwhile (len32) {\r\nif (dd->pdata->poll_irq(dd))\r\nreturn -ETIMEDOUT;\r\nfor (count = 0; count < min(len32, bs32); count++, offset++)\r\nomap_sham_write(dd, SHA_REG_DIN(dd, count),\r\nbuffer[offset]);\r\nlen32 -= min(len32, bs32);\r\n}\r\nreturn -EINPROGRESS;\r\n}\r\nstatic void omap_sham_dma_callback(void *param)\r\n{\r\nstruct omap_sham_dev *dd = param;\r\nset_bit(FLAGS_DMA_READY, &dd->flags);\r\ntasklet_schedule(&dd->done_task);\r\n}\r\nstatic int omap_sham_xmit_dma(struct omap_sham_dev *dd, dma_addr_t dma_addr,\r\nsize_t length, int final, int is_sg)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(dd->req);\r\nstruct dma_async_tx_descriptor *tx;\r\nstruct dma_slave_config cfg;\r\nint len32, ret, dma_min = get_block_size(ctx);\r\ndev_dbg(dd->dev, "xmit_dma: digcnt: %d, length: %d, final: %d\n",\r\nctx->digcnt, length, final);\r\nmemset(&cfg, 0, sizeof(cfg));\r\ncfg.dst_addr = dd->phys_base + SHA_REG_DIN(dd, 0);\r\ncfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ncfg.dst_maxburst = dma_min / DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nret = dmaengine_slave_config(dd->dma_lch, &cfg);\r\nif (ret) {\r\npr_err("omap-sham: can't configure dmaengine slave: %d\n", ret);\r\nreturn ret;\r\n}\r\nlen32 = DIV_ROUND_UP(length, dma_min) * dma_min;\r\nif (is_sg) {\r\nsg_init_table(&ctx->sgl, 1);\r\nctx->sgl.page_link = ctx->sg->page_link;\r\nctx->sgl.offset = ctx->sg->offset;\r\nsg_dma_len(&ctx->sgl) = len32;\r\nsg_dma_address(&ctx->sgl) = sg_dma_address(ctx->sg);\r\ntx = dmaengine_prep_slave_sg(dd->dma_lch, &ctx->sgl, 1,\r\nDMA_MEM_TO_DEV, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\n} else {\r\ntx = dmaengine_prep_slave_single(dd->dma_lch, dma_addr, len32,\r\nDMA_MEM_TO_DEV, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\n}\r\nif (!tx) {\r\ndev_err(dd->dev, "prep_slave_sg/single() failed\n");\r\nreturn -EINVAL;\r\n}\r\ntx->callback = omap_sham_dma_callback;\r\ntx->callback_param = dd;\r\ndd->pdata->write_ctrl(dd, length, final, 1);\r\nctx->digcnt += length;\r\nif (final)\r\nset_bit(FLAGS_FINAL, &dd->flags);\r\nset_bit(FLAGS_DMA_ACTIVE, &dd->flags);\r\ndmaengine_submit(tx);\r\ndma_async_issue_pending(dd->dma_lch);\r\ndd->pdata->trigger(dd, length);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic size_t omap_sham_append_buffer(struct omap_sham_reqctx *ctx,\r\nconst u8 *data, size_t length)\r\n{\r\nsize_t count = min(length, ctx->buflen - ctx->bufcnt);\r\ncount = min(count, ctx->total);\r\nif (count <= 0)\r\nreturn 0;\r\nmemcpy(ctx->buffer + ctx->bufcnt, data, count);\r\nctx->bufcnt += count;\r\nreturn count;\r\n}\r\nstatic size_t omap_sham_append_sg(struct omap_sham_reqctx *ctx)\r\n{\r\nsize_t count;\r\nconst u8 *vaddr;\r\nwhile (ctx->sg) {\r\nvaddr = kmap_atomic(sg_page(ctx->sg));\r\ncount = omap_sham_append_buffer(ctx,\r\nvaddr + ctx->offset,\r\nctx->sg->length - ctx->offset);\r\nkunmap_atomic((void *)vaddr);\r\nif (!count)\r\nbreak;\r\nctx->offset += count;\r\nctx->total -= count;\r\nif (ctx->offset == ctx->sg->length) {\r\nctx->sg = sg_next(ctx->sg);\r\nif (ctx->sg)\r\nctx->offset = 0;\r\nelse\r\nctx->total = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_sham_xmit_dma_map(struct omap_sham_dev *dd,\r\nstruct omap_sham_reqctx *ctx,\r\nsize_t length, int final)\r\n{\r\nint ret;\r\nctx->dma_addr = dma_map_single(dd->dev, ctx->buffer, ctx->buflen,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(dd->dev, ctx->dma_addr)) {\r\ndev_err(dd->dev, "dma %u bytes error\n", ctx->buflen);\r\nreturn -EINVAL;\r\n}\r\nctx->flags &= ~BIT(FLAGS_SG);\r\nret = omap_sham_xmit_dma(dd, ctx->dma_addr, length, final, 0);\r\nif (ret != -EINPROGRESS)\r\ndma_unmap_single(dd->dev, ctx->dma_addr, ctx->buflen,\r\nDMA_TO_DEVICE);\r\nreturn ret;\r\n}\r\nstatic int omap_sham_update_dma_slow(struct omap_sham_dev *dd)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(dd->req);\r\nunsigned int final;\r\nsize_t count;\r\nomap_sham_append_sg(ctx);\r\nfinal = (ctx->flags & BIT(FLAGS_FINUP)) && !ctx->total;\r\ndev_dbg(dd->dev, "slow: bufcnt: %u, digcnt: %d, final: %d\n",\r\nctx->bufcnt, ctx->digcnt, final);\r\nif (final || (ctx->bufcnt == ctx->buflen && ctx->total)) {\r\ncount = ctx->bufcnt;\r\nctx->bufcnt = 0;\r\nreturn omap_sham_xmit_dma_map(dd, ctx, count, final);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_sham_update_dma_start(struct omap_sham_dev *dd)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(dd->req);\r\nunsigned int length, final, tail;\r\nstruct scatterlist *sg;\r\nint ret, bs;\r\nif (!ctx->total)\r\nreturn 0;\r\nif (ctx->bufcnt || ctx->offset)\r\nreturn omap_sham_update_dma_slow(dd);\r\nif (ctx->total < get_block_size(ctx))\r\nreturn omap_sham_update_dma_slow(dd);\r\ndev_dbg(dd->dev, "fast: digcnt: %d, bufcnt: %u, total: %u\n",\r\nctx->digcnt, ctx->bufcnt, ctx->total);\r\nsg = ctx->sg;\r\nbs = get_block_size(ctx);\r\nif (!SG_AA(sg))\r\nreturn omap_sham_update_dma_slow(dd);\r\nif (!sg_is_last(sg) && !SG_SA(sg, bs))\r\nreturn omap_sham_update_dma_slow(dd);\r\nlength = min(ctx->total, sg->length);\r\nif (sg_is_last(sg)) {\r\nif (!(ctx->flags & BIT(FLAGS_FINUP))) {\r\ntail = length & (bs - 1);\r\nif (!tail)\r\ntail = bs;\r\nlength -= tail;\r\n}\r\n}\r\nif (!dma_map_sg(dd->dev, ctx->sg, 1, DMA_TO_DEVICE)) {\r\ndev_err(dd->dev, "dma_map_sg error\n");\r\nreturn -EINVAL;\r\n}\r\nctx->flags |= BIT(FLAGS_SG);\r\nctx->total -= length;\r\nctx->offset = length;\r\nfinal = (ctx->flags & BIT(FLAGS_FINUP)) && !ctx->total;\r\nret = omap_sham_xmit_dma(dd, sg_dma_address(ctx->sg), length, final, 1);\r\nif (ret != -EINPROGRESS)\r\ndma_unmap_sg(dd->dev, ctx->sg, 1, DMA_TO_DEVICE);\r\nreturn ret;\r\n}\r\nstatic int omap_sham_update_cpu(struct omap_sham_dev *dd)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(dd->req);\r\nint bufcnt, final;\r\nif (!ctx->total)\r\nreturn 0;\r\nomap_sham_append_sg(ctx);\r\nfinal = (ctx->flags & BIT(FLAGS_FINUP)) && !ctx->total;\r\ndev_dbg(dd->dev, "cpu: bufcnt: %u, digcnt: %d, final: %d\n",\r\nctx->bufcnt, ctx->digcnt, final);\r\nif (final || (ctx->bufcnt == ctx->buflen && ctx->total)) {\r\nbufcnt = ctx->bufcnt;\r\nctx->bufcnt = 0;\r\nreturn omap_sham_xmit_cpu(dd, ctx->buffer, bufcnt, final);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_sham_update_dma_stop(struct omap_sham_dev *dd)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(dd->req);\r\ndmaengine_terminate_all(dd->dma_lch);\r\nif (ctx->flags & BIT(FLAGS_SG)) {\r\ndma_unmap_sg(dd->dev, ctx->sg, 1, DMA_TO_DEVICE);\r\nif (ctx->sg->length == ctx->offset) {\r\nctx->sg = sg_next(ctx->sg);\r\nif (ctx->sg)\r\nctx->offset = 0;\r\n}\r\n} else {\r\ndma_unmap_single(dd->dev, ctx->dma_addr, ctx->buflen,\r\nDMA_TO_DEVICE);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_sham_init(struct ahash_request *req)\r\n{\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct omap_sham_ctx *tctx = crypto_ahash_ctx(tfm);\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nstruct omap_sham_dev *dd = NULL, *tmp;\r\nint bs = 0;\r\nspin_lock_bh(&sham.lock);\r\nif (!tctx->dd) {\r\nlist_for_each_entry(tmp, &sham.dev_list, list) {\r\ndd = tmp;\r\nbreak;\r\n}\r\ntctx->dd = dd;\r\n} else {\r\ndd = tctx->dd;\r\n}\r\nspin_unlock_bh(&sham.lock);\r\nctx->dd = dd;\r\nctx->flags = 0;\r\ndev_dbg(dd->dev, "init: digest size: %d\n",\r\ncrypto_ahash_digestsize(tfm));\r\nswitch (crypto_ahash_digestsize(tfm)) {\r\ncase MD5_DIGEST_SIZE:\r\nctx->flags |= FLAGS_MODE_MD5;\r\nbs = SHA1_BLOCK_SIZE;\r\nbreak;\r\ncase SHA1_DIGEST_SIZE:\r\nctx->flags |= FLAGS_MODE_SHA1;\r\nbs = SHA1_BLOCK_SIZE;\r\nbreak;\r\ncase SHA224_DIGEST_SIZE:\r\nctx->flags |= FLAGS_MODE_SHA224;\r\nbs = SHA224_BLOCK_SIZE;\r\nbreak;\r\ncase SHA256_DIGEST_SIZE:\r\nctx->flags |= FLAGS_MODE_SHA256;\r\nbs = SHA256_BLOCK_SIZE;\r\nbreak;\r\ncase SHA384_DIGEST_SIZE:\r\nctx->flags |= FLAGS_MODE_SHA384;\r\nbs = SHA384_BLOCK_SIZE;\r\nbreak;\r\ncase SHA512_DIGEST_SIZE:\r\nctx->flags |= FLAGS_MODE_SHA512;\r\nbs = SHA512_BLOCK_SIZE;\r\nbreak;\r\n}\r\nctx->bufcnt = 0;\r\nctx->digcnt = 0;\r\nctx->buflen = BUFLEN;\r\nif (tctx->flags & BIT(FLAGS_HMAC)) {\r\nif (!test_bit(FLAGS_AUTO_XOR, &dd->flags)) {\r\nstruct omap_sham_hmac_ctx *bctx = tctx->base;\r\nmemcpy(ctx->buffer, bctx->ipad, bs);\r\nctx->bufcnt = bs;\r\n}\r\nctx->flags |= BIT(FLAGS_HMAC);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_sham_update_req(struct omap_sham_dev *dd)\r\n{\r\nstruct ahash_request *req = dd->req;\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nint err;\r\ndev_dbg(dd->dev, "update_req: total: %u, digcnt: %d, finup: %d\n",\r\nctx->total, ctx->digcnt, (ctx->flags & BIT(FLAGS_FINUP)) != 0);\r\nif (ctx->flags & BIT(FLAGS_CPU))\r\nerr = omap_sham_update_cpu(dd);\r\nelse\r\nerr = omap_sham_update_dma_start(dd);\r\ndev_dbg(dd->dev, "update: err: %d, digcnt: %d\n", err, ctx->digcnt);\r\nreturn err;\r\n}\r\nstatic int omap_sham_final_req(struct omap_sham_dev *dd)\r\n{\r\nstruct ahash_request *req = dd->req;\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nint err = 0, use_dma = 1;\r\nif ((ctx->bufcnt <= get_block_size(ctx)) || dd->polling_mode)\r\nuse_dma = 0;\r\nif (use_dma)\r\nerr = omap_sham_xmit_dma_map(dd, ctx, ctx->bufcnt, 1);\r\nelse\r\nerr = omap_sham_xmit_cpu(dd, ctx->buffer, ctx->bufcnt, 1);\r\nctx->bufcnt = 0;\r\ndev_dbg(dd->dev, "final_req: err: %d\n", err);\r\nreturn err;\r\n}\r\nstatic int omap_sham_finish_hmac(struct ahash_request *req)\r\n{\r\nstruct omap_sham_ctx *tctx = crypto_tfm_ctx(req->base.tfm);\r\nstruct omap_sham_hmac_ctx *bctx = tctx->base;\r\nint bs = crypto_shash_blocksize(bctx->shash);\r\nint ds = crypto_shash_digestsize(bctx->shash);\r\nSHASH_DESC_ON_STACK(shash, bctx->shash);\r\nshash->tfm = bctx->shash;\r\nshash->flags = 0;\r\nreturn crypto_shash_init(shash) ?:\r\ncrypto_shash_update(shash, bctx->opad, bs) ?:\r\ncrypto_shash_finup(shash, req->result, ds, req->result);\r\n}\r\nstatic int omap_sham_finish(struct ahash_request *req)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nstruct omap_sham_dev *dd = ctx->dd;\r\nint err = 0;\r\nif (ctx->digcnt) {\r\nomap_sham_copy_ready_hash(req);\r\nif ((ctx->flags & BIT(FLAGS_HMAC)) &&\r\n!test_bit(FLAGS_AUTO_XOR, &dd->flags))\r\nerr = omap_sham_finish_hmac(req);\r\n}\r\ndev_dbg(dd->dev, "digcnt: %d, bufcnt: %d\n", ctx->digcnt, ctx->bufcnt);\r\nreturn err;\r\n}\r\nstatic void omap_sham_finish_req(struct ahash_request *req, int err)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nstruct omap_sham_dev *dd = ctx->dd;\r\nif (!err) {\r\ndd->pdata->copy_hash(req, 1);\r\nif (test_bit(FLAGS_FINAL, &dd->flags))\r\nerr = omap_sham_finish(req);\r\n} else {\r\nctx->flags |= BIT(FLAGS_ERROR);\r\n}\r\ndd->flags &= ~(BIT(FLAGS_BUSY) | BIT(FLAGS_FINAL) | BIT(FLAGS_CPU) |\r\nBIT(FLAGS_DMA_READY) | BIT(FLAGS_OUTPUT_READY));\r\npm_runtime_put(dd->dev);\r\nif (req->base.complete)\r\nreq->base.complete(&req->base, err);\r\ntasklet_schedule(&dd->done_task);\r\n}\r\nstatic int omap_sham_handle_queue(struct omap_sham_dev *dd,\r\nstruct ahash_request *req)\r\n{\r\nstruct crypto_async_request *async_req, *backlog;\r\nstruct omap_sham_reqctx *ctx;\r\nunsigned long flags;\r\nint err = 0, ret = 0;\r\nspin_lock_irqsave(&dd->lock, flags);\r\nif (req)\r\nret = ahash_enqueue_request(&dd->queue, req);\r\nif (test_bit(FLAGS_BUSY, &dd->flags)) {\r\nspin_unlock_irqrestore(&dd->lock, flags);\r\nreturn ret;\r\n}\r\nbacklog = crypto_get_backlog(&dd->queue);\r\nasync_req = crypto_dequeue_request(&dd->queue);\r\nif (async_req)\r\nset_bit(FLAGS_BUSY, &dd->flags);\r\nspin_unlock_irqrestore(&dd->lock, flags);\r\nif (!async_req)\r\nreturn ret;\r\nif (backlog)\r\nbacklog->complete(backlog, -EINPROGRESS);\r\nreq = ahash_request_cast(async_req);\r\ndd->req = req;\r\nctx = ahash_request_ctx(req);\r\ndev_dbg(dd->dev, "handling new req, op: %lu, nbytes: %d\n",\r\nctx->op, req->nbytes);\r\nerr = omap_sham_hw_init(dd);\r\nif (err)\r\ngoto err1;\r\nif (ctx->digcnt)\r\ndd->pdata->copy_hash(req, 0);\r\nif (ctx->op == OP_UPDATE) {\r\nerr = omap_sham_update_req(dd);\r\nif (err != -EINPROGRESS && (ctx->flags & BIT(FLAGS_FINUP)))\r\nerr = omap_sham_final_req(dd);\r\n} else if (ctx->op == OP_FINAL) {\r\nerr = omap_sham_final_req(dd);\r\n}\r\nerr1:\r\nif (err != -EINPROGRESS)\r\nomap_sham_finish_req(req, err);\r\ndev_dbg(dd->dev, "exit, err: %d\n", err);\r\nreturn ret;\r\n}\r\nstatic int omap_sham_enqueue(struct ahash_request *req, unsigned int op)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nstruct omap_sham_ctx *tctx = crypto_tfm_ctx(req->base.tfm);\r\nstruct omap_sham_dev *dd = tctx->dd;\r\nctx->op = op;\r\nreturn omap_sham_handle_queue(dd, req);\r\n}\r\nstatic int omap_sham_update(struct ahash_request *req)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nstruct omap_sham_dev *dd = ctx->dd;\r\nint bs = get_block_size(ctx);\r\nif (!req->nbytes)\r\nreturn 0;\r\nctx->total = req->nbytes;\r\nctx->sg = req->src;\r\nctx->offset = 0;\r\nif (ctx->flags & BIT(FLAGS_FINUP)) {\r\nif ((ctx->digcnt + ctx->bufcnt + ctx->total) < 9) {\r\nomap_sham_append_sg(ctx);\r\nreturn 0;\r\n} else if ((ctx->bufcnt + ctx->total <= bs) ||\r\ndd->polling_mode) {\r\nctx->flags |= BIT(FLAGS_CPU);\r\n}\r\n} else if (ctx->bufcnt + ctx->total < ctx->buflen) {\r\nomap_sham_append_sg(ctx);\r\nreturn 0;\r\n}\r\nif (dd->polling_mode)\r\nctx->flags |= BIT(FLAGS_CPU);\r\nreturn omap_sham_enqueue(req, OP_UPDATE);\r\n}\r\nstatic int omap_sham_shash_digest(struct crypto_shash *tfm, u32 flags,\r\nconst u8 *data, unsigned int len, u8 *out)\r\n{\r\nSHASH_DESC_ON_STACK(shash, tfm);\r\nshash->tfm = tfm;\r\nshash->flags = flags & CRYPTO_TFM_REQ_MAY_SLEEP;\r\nreturn crypto_shash_digest(shash, data, len, out);\r\n}\r\nstatic int omap_sham_final_shash(struct ahash_request *req)\r\n{\r\nstruct omap_sham_ctx *tctx = crypto_tfm_ctx(req->base.tfm);\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nreturn omap_sham_shash_digest(tctx->fallback, req->base.flags,\r\nctx->buffer, ctx->bufcnt, req->result);\r\n}\r\nstatic int omap_sham_final(struct ahash_request *req)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nctx->flags |= BIT(FLAGS_FINUP);\r\nif (ctx->flags & BIT(FLAGS_ERROR))\r\nreturn 0;\r\nif ((ctx->digcnt + ctx->bufcnt) < 9)\r\nreturn omap_sham_final_shash(req);\r\nelse if (ctx->bufcnt)\r\nreturn omap_sham_enqueue(req, OP_FINAL);\r\nreturn omap_sham_finish(req);\r\n}\r\nstatic int omap_sham_finup(struct ahash_request *req)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nint err1, err2;\r\nctx->flags |= BIT(FLAGS_FINUP);\r\nerr1 = omap_sham_update(req);\r\nif (err1 == -EINPROGRESS || err1 == -EBUSY)\r\nreturn err1;\r\nerr2 = omap_sham_final(req);\r\nreturn err1 ?: err2;\r\n}\r\nstatic int omap_sham_digest(struct ahash_request *req)\r\n{\r\nreturn omap_sham_init(req) ?: omap_sham_finup(req);\r\n}\r\nstatic int omap_sham_setkey(struct crypto_ahash *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct omap_sham_ctx *tctx = crypto_ahash_ctx(tfm);\r\nstruct omap_sham_hmac_ctx *bctx = tctx->base;\r\nint bs = crypto_shash_blocksize(bctx->shash);\r\nint ds = crypto_shash_digestsize(bctx->shash);\r\nstruct omap_sham_dev *dd = NULL, *tmp;\r\nint err, i;\r\nspin_lock_bh(&sham.lock);\r\nif (!tctx->dd) {\r\nlist_for_each_entry(tmp, &sham.dev_list, list) {\r\ndd = tmp;\r\nbreak;\r\n}\r\ntctx->dd = dd;\r\n} else {\r\ndd = tctx->dd;\r\n}\r\nspin_unlock_bh(&sham.lock);\r\nerr = crypto_shash_setkey(tctx->fallback, key, keylen);\r\nif (err)\r\nreturn err;\r\nif (keylen > bs) {\r\nerr = omap_sham_shash_digest(bctx->shash,\r\ncrypto_shash_get_flags(bctx->shash),\r\nkey, keylen, bctx->ipad);\r\nif (err)\r\nreturn err;\r\nkeylen = ds;\r\n} else {\r\nmemcpy(bctx->ipad, key, keylen);\r\n}\r\nmemset(bctx->ipad + keylen, 0, bs - keylen);\r\nif (!test_bit(FLAGS_AUTO_XOR, &dd->flags)) {\r\nmemcpy(bctx->opad, bctx->ipad, bs);\r\nfor (i = 0; i < bs; i++) {\r\nbctx->ipad[i] ^= 0x36;\r\nbctx->opad[i] ^= 0x5c;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int omap_sham_cra_init_alg(struct crypto_tfm *tfm, const char *alg_base)\r\n{\r\nstruct omap_sham_ctx *tctx = crypto_tfm_ctx(tfm);\r\nconst char *alg_name = crypto_tfm_alg_name(tfm);\r\ntctx->fallback = crypto_alloc_shash(alg_name, 0,\r\nCRYPTO_ALG_NEED_FALLBACK);\r\nif (IS_ERR(tctx->fallback)) {\r\npr_err("omap-sham: fallback driver '%s' "\r\n"could not be loaded.\n", alg_name);\r\nreturn PTR_ERR(tctx->fallback);\r\n}\r\ncrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\r\nsizeof(struct omap_sham_reqctx) + BUFLEN);\r\nif (alg_base) {\r\nstruct omap_sham_hmac_ctx *bctx = tctx->base;\r\ntctx->flags |= BIT(FLAGS_HMAC);\r\nbctx->shash = crypto_alloc_shash(alg_base, 0,\r\nCRYPTO_ALG_NEED_FALLBACK);\r\nif (IS_ERR(bctx->shash)) {\r\npr_err("omap-sham: base driver '%s' "\r\n"could not be loaded.\n", alg_base);\r\ncrypto_free_shash(tctx->fallback);\r\nreturn PTR_ERR(bctx->shash);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_sham_cra_init(struct crypto_tfm *tfm)\r\n{\r\nreturn omap_sham_cra_init_alg(tfm, NULL);\r\n}\r\nstatic int omap_sham_cra_sha1_init(struct crypto_tfm *tfm)\r\n{\r\nreturn omap_sham_cra_init_alg(tfm, "sha1");\r\n}\r\nstatic int omap_sham_cra_sha224_init(struct crypto_tfm *tfm)\r\n{\r\nreturn omap_sham_cra_init_alg(tfm, "sha224");\r\n}\r\nstatic int omap_sham_cra_sha256_init(struct crypto_tfm *tfm)\r\n{\r\nreturn omap_sham_cra_init_alg(tfm, "sha256");\r\n}\r\nstatic int omap_sham_cra_md5_init(struct crypto_tfm *tfm)\r\n{\r\nreturn omap_sham_cra_init_alg(tfm, "md5");\r\n}\r\nstatic int omap_sham_cra_sha384_init(struct crypto_tfm *tfm)\r\n{\r\nreturn omap_sham_cra_init_alg(tfm, "sha384");\r\n}\r\nstatic int omap_sham_cra_sha512_init(struct crypto_tfm *tfm)\r\n{\r\nreturn omap_sham_cra_init_alg(tfm, "sha512");\r\n}\r\nstatic void omap_sham_cra_exit(struct crypto_tfm *tfm)\r\n{\r\nstruct omap_sham_ctx *tctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_shash(tctx->fallback);\r\ntctx->fallback = NULL;\r\nif (tctx->flags & BIT(FLAGS_HMAC)) {\r\nstruct omap_sham_hmac_ctx *bctx = tctx->base;\r\ncrypto_free_shash(bctx->shash);\r\n}\r\n}\r\nstatic void omap_sham_done_task(unsigned long data)\r\n{\r\nstruct omap_sham_dev *dd = (struct omap_sham_dev *)data;\r\nint err = 0;\r\nif (!test_bit(FLAGS_BUSY, &dd->flags)) {\r\nomap_sham_handle_queue(dd, NULL);\r\nreturn;\r\n}\r\nif (test_bit(FLAGS_CPU, &dd->flags)) {\r\nif (test_and_clear_bit(FLAGS_OUTPUT_READY, &dd->flags)) {\r\nerr = omap_sham_update_cpu(dd);\r\nif (err != -EINPROGRESS)\r\ngoto finish;\r\n}\r\n} else if (test_bit(FLAGS_DMA_READY, &dd->flags)) {\r\nif (test_and_clear_bit(FLAGS_DMA_ACTIVE, &dd->flags)) {\r\nomap_sham_update_dma_stop(dd);\r\nif (dd->err) {\r\nerr = dd->err;\r\ngoto finish;\r\n}\r\n}\r\nif (test_and_clear_bit(FLAGS_OUTPUT_READY, &dd->flags)) {\r\nclear_bit(FLAGS_DMA_READY, &dd->flags);\r\nerr = omap_sham_update_dma_start(dd);\r\nif (err != -EINPROGRESS)\r\ngoto finish;\r\n}\r\n}\r\nreturn;\r\nfinish:\r\ndev_dbg(dd->dev, "update done: err: %d\n", err);\r\nomap_sham_finish_req(dd->req, err);\r\n}\r\nstatic irqreturn_t omap_sham_irq_common(struct omap_sham_dev *dd)\r\n{\r\nif (!test_bit(FLAGS_BUSY, &dd->flags)) {\r\ndev_warn(dd->dev, "Interrupt when no active requests.\n");\r\n} else {\r\nset_bit(FLAGS_OUTPUT_READY, &dd->flags);\r\ntasklet_schedule(&dd->done_task);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t omap_sham_irq_omap2(int irq, void *dev_id)\r\n{\r\nstruct omap_sham_dev *dd = dev_id;\r\nif (unlikely(test_bit(FLAGS_FINAL, &dd->flags)))\r\nomap_sham_write_mask(dd, SHA_REG_CTRL, 0, SHA_REG_CTRL_LENGTH);\r\nomap_sham_write_mask(dd, SHA_REG_CTRL, SHA_REG_CTRL_OUTPUT_READY,\r\nSHA_REG_CTRL_OUTPUT_READY);\r\nomap_sham_read(dd, SHA_REG_CTRL);\r\nreturn omap_sham_irq_common(dd);\r\n}\r\nstatic irqreturn_t omap_sham_irq_omap4(int irq, void *dev_id)\r\n{\r\nstruct omap_sham_dev *dd = dev_id;\r\nomap_sham_write_mask(dd, SHA_REG_MASK(dd), 0, SHA_REG_MASK_IT_EN);\r\nreturn omap_sham_irq_common(dd);\r\n}\r\nstatic int omap_sham_get_res_of(struct omap_sham_dev *dd,\r\nstruct device *dev, struct resource *res)\r\n{\r\nstruct device_node *node = dev->of_node;\r\nconst struct of_device_id *match;\r\nint err = 0;\r\nmatch = of_match_device(of_match_ptr(omap_sham_of_match), dev);\r\nif (!match) {\r\ndev_err(dev, "no compatible OF match\n");\r\nerr = -EINVAL;\r\ngoto err;\r\n}\r\nerr = of_address_to_resource(node, 0, res);\r\nif (err < 0) {\r\ndev_err(dev, "can't translate OF node address\n");\r\nerr = -EINVAL;\r\ngoto err;\r\n}\r\ndd->irq = irq_of_parse_and_map(node, 0);\r\nif (!dd->irq) {\r\ndev_err(dev, "can't translate OF irq value\n");\r\nerr = -EINVAL;\r\ngoto err;\r\n}\r\ndd->dma = -1;\r\ndd->pdata = match->data;\r\nerr:\r\nreturn err;\r\n}\r\nstatic int omap_sham_get_res_of(struct omap_sham_dev *dd,\r\nstruct device *dev, struct resource *res)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int omap_sham_get_res_pdev(struct omap_sham_dev *dd,\r\nstruct platform_device *pdev, struct resource *res)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *r;\r\nint err = 0;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(dev, "no MEM resource info\n");\r\nerr = -ENODEV;\r\ngoto err;\r\n}\r\nmemcpy(res, r, sizeof(*res));\r\ndd->irq = platform_get_irq(pdev, 0);\r\nif (dd->irq < 0) {\r\ndev_err(dev, "no IRQ resource info\n");\r\nerr = dd->irq;\r\ngoto err;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (!r) {\r\ndev_err(dev, "no DMA resource info\n");\r\nerr = -ENODEV;\r\ngoto err;\r\n}\r\ndd->dma = r->start;\r\ndd->pdata = &omap_sham_pdata_omap2;\r\nerr:\r\nreturn err;\r\n}\r\nstatic int omap_sham_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_sham_dev *dd;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource res;\r\ndma_cap_mask_t mask;\r\nint err, i, j;\r\nu32 rev;\r\ndd = devm_kzalloc(dev, sizeof(struct omap_sham_dev), GFP_KERNEL);\r\nif (dd == NULL) {\r\ndev_err(dev, "unable to alloc data struct.\n");\r\nerr = -ENOMEM;\r\ngoto data_err;\r\n}\r\ndd->dev = dev;\r\nplatform_set_drvdata(pdev, dd);\r\nINIT_LIST_HEAD(&dd->list);\r\nspin_lock_init(&dd->lock);\r\ntasklet_init(&dd->done_task, omap_sham_done_task, (unsigned long)dd);\r\ncrypto_init_queue(&dd->queue, OMAP_SHAM_QUEUE_LENGTH);\r\nerr = (dev->of_node) ? omap_sham_get_res_of(dd, dev, &res) :\r\nomap_sham_get_res_pdev(dd, pdev, &res);\r\nif (err)\r\ngoto data_err;\r\ndd->io_base = devm_ioremap_resource(dev, &res);\r\nif (IS_ERR(dd->io_base)) {\r\nerr = PTR_ERR(dd->io_base);\r\ngoto data_err;\r\n}\r\ndd->phys_base = res.start;\r\nerr = devm_request_irq(dev, dd->irq, dd->pdata->intr_hdlr,\r\nIRQF_TRIGGER_NONE, dev_name(dev), dd);\r\nif (err) {\r\ndev_err(dev, "unable to request irq %d, err = %d\n",\r\ndd->irq, err);\r\ngoto data_err;\r\n}\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndd->dma_lch = dma_request_slave_channel_compat(mask, omap_dma_filter_fn,\r\n&dd->dma, dev, "rx");\r\nif (!dd->dma_lch) {\r\ndd->polling_mode = 1;\r\ndev_dbg(dev, "using polling mode instead of dma\n");\r\n}\r\ndd->flags |= dd->pdata->flags;\r\npm_runtime_enable(dev);\r\npm_runtime_get_sync(dev);\r\nrev = omap_sham_read(dd, SHA_REG_REV(dd));\r\npm_runtime_put_sync(&pdev->dev);\r\ndev_info(dev, "hw accel on OMAP rev %u.%u\n",\r\n(rev & dd->pdata->major_mask) >> dd->pdata->major_shift,\r\n(rev & dd->pdata->minor_mask) >> dd->pdata->minor_shift);\r\nspin_lock(&sham.lock);\r\nlist_add_tail(&dd->list, &sham.dev_list);\r\nspin_unlock(&sham.lock);\r\nfor (i = 0; i < dd->pdata->algs_info_size; i++) {\r\nfor (j = 0; j < dd->pdata->algs_info[i].size; j++) {\r\nerr = crypto_register_ahash(\r\n&dd->pdata->algs_info[i].algs_list[j]);\r\nif (err)\r\ngoto err_algs;\r\ndd->pdata->algs_info[i].registered++;\r\n}\r\n}\r\nreturn 0;\r\nerr_algs:\r\nfor (i = dd->pdata->algs_info_size - 1; i >= 0; i--)\r\nfor (j = dd->pdata->algs_info[i].registered - 1; j >= 0; j--)\r\ncrypto_unregister_ahash(\r\n&dd->pdata->algs_info[i].algs_list[j]);\r\npm_runtime_disable(dev);\r\nif (dd->dma_lch)\r\ndma_release_channel(dd->dma_lch);\r\ndata_err:\r\ndev_err(dev, "initialization failed.\n");\r\nreturn err;\r\n}\r\nstatic int omap_sham_remove(struct platform_device *pdev)\r\n{\r\nstatic struct omap_sham_dev *dd;\r\nint i, j;\r\ndd = platform_get_drvdata(pdev);\r\nif (!dd)\r\nreturn -ENODEV;\r\nspin_lock(&sham.lock);\r\nlist_del(&dd->list);\r\nspin_unlock(&sham.lock);\r\nfor (i = dd->pdata->algs_info_size - 1; i >= 0; i--)\r\nfor (j = dd->pdata->algs_info[i].registered - 1; j >= 0; j--)\r\ncrypto_unregister_ahash(\r\n&dd->pdata->algs_info[i].algs_list[j]);\r\ntasklet_kill(&dd->done_task);\r\npm_runtime_disable(&pdev->dev);\r\nif (dd->dma_lch)\r\ndma_release_channel(dd->dma_lch);\r\nreturn 0;\r\n}\r\nstatic int omap_sham_suspend(struct device *dev)\r\n{\r\npm_runtime_put_sync(dev);\r\nreturn 0;\r\n}\r\nstatic int omap_sham_resume(struct device *dev)\r\n{\r\npm_runtime_get_sync(dev);\r\nreturn 0;\r\n}
