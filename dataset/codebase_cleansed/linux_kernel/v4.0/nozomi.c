static inline struct nozomi *get_dc_by_tty(const struct tty_struct *tty)\r\n{\r\nreturn tty ? ndevs[tty->index / MAX_PORT] : NULL;\r\n}\r\nstatic inline struct port *get_port_by_tty(const struct tty_struct *tty)\r\n{\r\nstruct nozomi *ndev = get_dc_by_tty(tty);\r\nreturn ndev ? &ndev->port[tty->index % MAX_PORT] : NULL;\r\n}\r\nstatic void read_mem32(u32 *buf, const void __iomem *mem_addr_start,\r\nu32 size_bytes)\r\n{\r\nu32 i = 0;\r\nconst u32 __iomem *ptr = mem_addr_start;\r\nu16 *buf16;\r\nif (unlikely(!ptr || !buf))\r\ngoto out;\r\nswitch (size_bytes) {\r\ncase 2:\r\nbuf16 = (u16 *) buf;\r\n*buf16 = __le16_to_cpu(readw(ptr));\r\ngoto out;\r\nbreak;\r\ncase 4:\r\n*(buf) = __le32_to_cpu(readl(ptr));\r\ngoto out;\r\nbreak;\r\n}\r\nwhile (i < size_bytes) {\r\nif (size_bytes - i == 2) {\r\nbuf16 = (u16 *) buf;\r\n*(buf16) = __le16_to_cpu(readw(ptr));\r\ni += 2;\r\n} else {\r\n*(buf) = __le32_to_cpu(readl(ptr));\r\ni += 4;\r\n}\r\nbuf++;\r\nptr++;\r\n}\r\nout:\r\nreturn;\r\n}\r\nstatic u32 write_mem32(void __iomem *mem_addr_start, const u32 *buf,\r\nu32 size_bytes)\r\n{\r\nu32 i = 0;\r\nu32 __iomem *ptr = mem_addr_start;\r\nconst u16 *buf16;\r\nif (unlikely(!ptr || !buf))\r\nreturn 0;\r\nswitch (size_bytes) {\r\ncase 2:\r\nbuf16 = (const u16 *)buf;\r\nwritew(__cpu_to_le16(*buf16), ptr);\r\nreturn 2;\r\nbreak;\r\ncase 1:\r\ncase 4:\r\nwritel(__cpu_to_le32(*buf), ptr);\r\nreturn 4;\r\nbreak;\r\n}\r\nwhile (i < size_bytes) {\r\nif (size_bytes - i == 2) {\r\nbuf16 = (const u16 *)buf;\r\nwritew(__cpu_to_le16(*buf16), ptr);\r\ni += 2;\r\n} else {\r\nwritel(__cpu_to_le32(*buf), ptr);\r\ni += 4;\r\n}\r\nbuf++;\r\nptr++;\r\n}\r\nreturn i;\r\n}\r\nstatic void nozomi_setup_memory(struct nozomi *dc)\r\n{\r\nvoid __iomem *offset = dc->base_addr + dc->config_table.dl_start;\r\nconst u16 buff_offset = 4;\r\ndc->port[PORT_MDM].dl_addr[CH_A] = offset;\r\ndc->port[PORT_MDM].dl_addr[CH_B] =\r\n(offset += dc->config_table.dl_mdm_len1);\r\ndc->port[PORT_MDM].dl_size[CH_A] =\r\ndc->config_table.dl_mdm_len1 - buff_offset;\r\ndc->port[PORT_MDM].dl_size[CH_B] =\r\ndc->config_table.dl_mdm_len2 - buff_offset;\r\ndc->port[PORT_DIAG].dl_addr[CH_A] =\r\n(offset += dc->config_table.dl_mdm_len2);\r\ndc->port[PORT_DIAG].dl_size[CH_A] =\r\ndc->config_table.dl_diag_len1 - buff_offset;\r\ndc->port[PORT_DIAG].dl_addr[CH_B] =\r\n(offset += dc->config_table.dl_diag_len1);\r\ndc->port[PORT_DIAG].dl_size[CH_B] =\r\ndc->config_table.dl_diag_len2 - buff_offset;\r\ndc->port[PORT_APP1].dl_addr[CH_A] =\r\n(offset += dc->config_table.dl_diag_len2);\r\ndc->port[PORT_APP1].dl_size[CH_A] =\r\ndc->config_table.dl_app1_len - buff_offset;\r\ndc->port[PORT_APP2].dl_addr[CH_A] =\r\n(offset += dc->config_table.dl_app1_len);\r\ndc->port[PORT_APP2].dl_size[CH_A] =\r\ndc->config_table.dl_app2_len - buff_offset;\r\ndc->port[PORT_CTRL].dl_addr[CH_A] =\r\n(offset += dc->config_table.dl_app2_len);\r\ndc->port[PORT_CTRL].dl_size[CH_A] =\r\ndc->config_table.dl_ctrl_len - buff_offset;\r\noffset = dc->base_addr + dc->config_table.ul_start;\r\ndc->port[PORT_MDM].ul_addr[CH_A] = offset;\r\ndc->port[PORT_MDM].ul_size[CH_A] =\r\ndc->config_table.ul_mdm_len1 - buff_offset;\r\ndc->port[PORT_MDM].ul_addr[CH_B] =\r\n(offset += dc->config_table.ul_mdm_len1);\r\ndc->port[PORT_MDM].ul_size[CH_B] =\r\ndc->config_table.ul_mdm_len2 - buff_offset;\r\ndc->port[PORT_DIAG].ul_addr[CH_A] =\r\n(offset += dc->config_table.ul_mdm_len2);\r\ndc->port[PORT_DIAG].ul_size[CH_A] =\r\ndc->config_table.ul_diag_len - buff_offset;\r\ndc->port[PORT_APP1].ul_addr[CH_A] =\r\n(offset += dc->config_table.ul_diag_len);\r\ndc->port[PORT_APP1].ul_size[CH_A] =\r\ndc->config_table.ul_app1_len - buff_offset;\r\ndc->port[PORT_APP2].ul_addr[CH_A] =\r\n(offset += dc->config_table.ul_app1_len);\r\ndc->port[PORT_APP2].ul_size[CH_A] =\r\ndc->config_table.ul_app2_len - buff_offset;\r\ndc->port[PORT_CTRL].ul_addr[CH_A] =\r\n(offset += dc->config_table.ul_app2_len);\r\ndc->port[PORT_CTRL].ul_size[CH_A] =\r\ndc->config_table.ul_ctrl_len - buff_offset;\r\n}\r\nstatic void dump_table(const struct nozomi *dc)\r\n{\r\nDBG3("signature: 0x%08X", dc->config_table.signature);\r\nDBG3("version: 0x%04X", dc->config_table.version);\r\nDBG3("product_information: 0x%04X", \\r\ndc->config_table.product_information);\r\nDBG3("toggle enabled: %d", dc->config_table.toggle.enabled);\r\nDBG3("toggle up_mdm: %d", dc->config_table.toggle.mdm_ul);\r\nDBG3("toggle dl_mdm: %d", dc->config_table.toggle.mdm_dl);\r\nDBG3("toggle dl_dbg: %d", dc->config_table.toggle.diag_dl);\r\nDBG3("dl_start: 0x%04X", dc->config_table.dl_start);\r\nDBG3("dl_mdm_len0: 0x%04X, %d", dc->config_table.dl_mdm_len1,\r\ndc->config_table.dl_mdm_len1);\r\nDBG3("dl_mdm_len1: 0x%04X, %d", dc->config_table.dl_mdm_len2,\r\ndc->config_table.dl_mdm_len2);\r\nDBG3("dl_diag_len0: 0x%04X, %d", dc->config_table.dl_diag_len1,\r\ndc->config_table.dl_diag_len1);\r\nDBG3("dl_diag_len1: 0x%04X, %d", dc->config_table.dl_diag_len2,\r\ndc->config_table.dl_diag_len2);\r\nDBG3("dl_app1_len: 0x%04X, %d", dc->config_table.dl_app1_len,\r\ndc->config_table.dl_app1_len);\r\nDBG3("dl_app2_len: 0x%04X, %d", dc->config_table.dl_app2_len,\r\ndc->config_table.dl_app2_len);\r\nDBG3("dl_ctrl_len: 0x%04X, %d", dc->config_table.dl_ctrl_len,\r\ndc->config_table.dl_ctrl_len);\r\nDBG3("ul_start: 0x%04X, %d", dc->config_table.ul_start,\r\ndc->config_table.ul_start);\r\nDBG3("ul_mdm_len[0]: 0x%04X, %d", dc->config_table.ul_mdm_len1,\r\ndc->config_table.ul_mdm_len1);\r\nDBG3("ul_mdm_len[1]: 0x%04X, %d", dc->config_table.ul_mdm_len2,\r\ndc->config_table.ul_mdm_len2);\r\nDBG3("ul_diag_len: 0x%04X, %d", dc->config_table.ul_diag_len,\r\ndc->config_table.ul_diag_len);\r\nDBG3("ul_app1_len: 0x%04X, %d", dc->config_table.ul_app1_len,\r\ndc->config_table.ul_app1_len);\r\nDBG3("ul_app2_len: 0x%04X, %d", dc->config_table.ul_app2_len,\r\ndc->config_table.ul_app2_len);\r\nDBG3("ul_ctrl_len: 0x%04X, %d", dc->config_table.ul_ctrl_len,\r\ndc->config_table.ul_ctrl_len);\r\n}\r\nstatic inline void dump_table(const struct nozomi *dc) { }\r\nstatic int nozomi_read_config_table(struct nozomi *dc)\r\n{\r\nread_mem32((u32 *) &dc->config_table, dc->base_addr + 0,\r\nsizeof(struct config_table));\r\nif (dc->config_table.signature != CONFIG_MAGIC) {\r\ndev_err(&dc->pdev->dev, "ConfigTable Bad! 0x%08X != 0x%08X\n",\r\ndc->config_table.signature, CONFIG_MAGIC);\r\nreturn 0;\r\n}\r\nif ((dc->config_table.version == 0)\r\n|| (dc->config_table.toggle.enabled == TOGGLE_VALID)) {\r\nint i;\r\nDBG1("Second phase, configuring card");\r\nnozomi_setup_memory(dc);\r\ndc->port[PORT_MDM].toggle_ul = dc->config_table.toggle.mdm_ul;\r\ndc->port[PORT_MDM].toggle_dl = dc->config_table.toggle.mdm_dl;\r\ndc->port[PORT_DIAG].toggle_dl = dc->config_table.toggle.diag_dl;\r\nDBG1("toggle ports: MDM UL:%d MDM DL:%d, DIAG DL:%d",\r\ndc->port[PORT_MDM].toggle_ul,\r\ndc->port[PORT_MDM].toggle_dl, dc->port[PORT_DIAG].toggle_dl);\r\ndump_table(dc);\r\nfor (i = PORT_MDM; i < MAX_PORT; i++) {\r\nmemset(&dc->port[i].ctrl_dl, 0, sizeof(struct ctrl_dl));\r\nmemset(&dc->port[i].ctrl_ul, 0, sizeof(struct ctrl_ul));\r\n}\r\ndc->last_ier = dc->last_ier | CTRL_DL;\r\nwritew(dc->last_ier, dc->reg_ier);\r\ndc->state = NOZOMI_STATE_ALLOCATED;\r\ndev_info(&dc->pdev->dev, "Initialization OK!\n");\r\nreturn 1;\r\n}\r\nif ((dc->config_table.version > 0)\r\n&& (dc->config_table.toggle.enabled != TOGGLE_VALID)) {\r\nu32 offset = 0;\r\nDBG1("First phase: pushing upload buffers, clearing download");\r\ndev_info(&dc->pdev->dev, "Version of card: %d\n",\r\ndc->config_table.version);\r\nnozomi_setup_memory(dc);\r\nwrite_mem32(dc->port[PORT_MDM].ul_addr[CH_A],\r\n(u32 *) &offset, 4);\r\nwrite_mem32(dc->port[PORT_MDM].ul_addr[CH_B],\r\n(u32 *) &offset, 4);\r\nwritew(MDM_UL | DIAG_DL | MDM_DL, dc->reg_fcr);\r\nDBG1("First phase done");\r\n}\r\nreturn 1;\r\n}\r\nstatic void enable_transmit_ul(enum port_type port, struct nozomi *dc)\r\n{\r\nstatic const u16 mask[] = {MDM_UL, DIAG_UL, APP1_UL, APP2_UL, CTRL_UL};\r\nif (port < NOZOMI_MAX_PORTS) {\r\ndc->last_ier |= mask[port];\r\nwritew(dc->last_ier, dc->reg_ier);\r\n} else {\r\ndev_err(&dc->pdev->dev, "Called with wrong port?\n");\r\n}\r\n}\r\nstatic void disable_transmit_ul(enum port_type port, struct nozomi *dc)\r\n{\r\nstatic const u16 mask[] =\r\n{~MDM_UL, ~DIAG_UL, ~APP1_UL, ~APP2_UL, ~CTRL_UL};\r\nif (port < NOZOMI_MAX_PORTS) {\r\ndc->last_ier &= mask[port];\r\nwritew(dc->last_ier, dc->reg_ier);\r\n} else {\r\ndev_err(&dc->pdev->dev, "Called with wrong port?\n");\r\n}\r\n}\r\nstatic void enable_transmit_dl(enum port_type port, struct nozomi *dc)\r\n{\r\nstatic const u16 mask[] = {MDM_DL, DIAG_DL, APP1_DL, APP2_DL, CTRL_DL};\r\nif (port < NOZOMI_MAX_PORTS) {\r\ndc->last_ier |= mask[port];\r\nwritew(dc->last_ier, dc->reg_ier);\r\n} else {\r\ndev_err(&dc->pdev->dev, "Called with wrong port?\n");\r\n}\r\n}\r\nstatic void disable_transmit_dl(enum port_type port, struct nozomi *dc)\r\n{\r\nstatic const u16 mask[] =\r\n{~MDM_DL, ~DIAG_DL, ~APP1_DL, ~APP2_DL, ~CTRL_DL};\r\nif (port < NOZOMI_MAX_PORTS) {\r\ndc->last_ier &= mask[port];\r\nwritew(dc->last_ier, dc->reg_ier);\r\n} else {\r\ndev_err(&dc->pdev->dev, "Called with wrong port?\n");\r\n}\r\n}\r\nstatic int send_data(enum port_type index, struct nozomi *dc)\r\n{\r\nu32 size = 0;\r\nstruct port *port = &dc->port[index];\r\nconst u8 toggle = port->toggle_ul;\r\nvoid __iomem *addr = port->ul_addr[toggle];\r\nconst u32 ul_size = port->ul_size[toggle];\r\nsize = kfifo_out(&port->fifo_ul, dc->send_buf,\r\nul_size < SEND_BUF_MAX ? ul_size : SEND_BUF_MAX);\r\nif (size == 0) {\r\nDBG4("No more data to send, disable link:");\r\nreturn 0;\r\n}\r\nwrite_mem32(addr, (u32 *) &size, 4);\r\nwrite_mem32(addr + 4, (u32 *) dc->send_buf, size);\r\ntty_port_tty_wakeup(&port->port);\r\nreturn 1;\r\n}\r\nstatic int receive_data(enum port_type index, struct nozomi *dc)\r\n{\r\nu8 buf[RECEIVE_BUF_MAX] = { 0 };\r\nint size;\r\nu32 offset = 4;\r\nstruct port *port = &dc->port[index];\r\nvoid __iomem *addr = port->dl_addr[port->toggle_dl];\r\nstruct tty_struct *tty = tty_port_tty_get(&port->port);\r\nint i, ret;\r\nread_mem32((u32 *) &size, addr, 4);\r\nif (tty && test_bit(TTY_THROTTLED, &tty->flags)) {\r\nDBG1("No room in tty, don't read data, don't ack interrupt, "\r\n"disable interrupt");\r\ndisable_transmit_dl(index, dc);\r\nret = 0;\r\ngoto put;\r\n}\r\nif (unlikely(size == 0)) {\r\ndev_err(&dc->pdev->dev, "size == 0?\n");\r\nret = 1;\r\ngoto put;\r\n}\r\nwhile (size > 0) {\r\nread_mem32((u32 *) buf, addr + offset, RECEIVE_BUF_MAX);\r\nif (size == 1) {\r\ntty_insert_flip_char(&port->port, buf[0], TTY_NORMAL);\r\nsize = 0;\r\n} else if (size < RECEIVE_BUF_MAX) {\r\nsize -= tty_insert_flip_string(&port->port,\r\n(char *)buf, size);\r\n} else {\r\ni = tty_insert_flip_string(&port->port,\r\n(char *)buf, RECEIVE_BUF_MAX);\r\nsize -= i;\r\noffset += i;\r\n}\r\n}\r\nset_bit(index, &dc->flip);\r\nret = 1;\r\nput:\r\ntty_kref_put(tty);\r\nreturn ret;\r\n}\r\nstatic char *interrupt2str(u16 interrupt)\r\n{\r\nstatic char buf[TMP_BUF_MAX];\r\nchar *p = buf;\r\ninterrupt & MDM_DL1 ? p += snprintf(p, TMP_BUF_MAX, "MDM_DL1 ") : NULL;\r\ninterrupt & MDM_DL2 ? p += snprintf(p, TMP_BUF_MAX - (p - buf),\r\n"MDM_DL2 ") : NULL;\r\ninterrupt & MDM_UL1 ? p += snprintf(p, TMP_BUF_MAX - (p - buf),\r\n"MDM_UL1 ") : NULL;\r\ninterrupt & MDM_UL2 ? p += snprintf(p, TMP_BUF_MAX - (p - buf),\r\n"MDM_UL2 ") : NULL;\r\ninterrupt & DIAG_DL1 ? p += snprintf(p, TMP_BUF_MAX - (p - buf),\r\n"DIAG_DL1 ") : NULL;\r\ninterrupt & DIAG_DL2 ? p += snprintf(p, TMP_BUF_MAX - (p - buf),\r\n"DIAG_DL2 ") : NULL;\r\ninterrupt & DIAG_UL ? p += snprintf(p, TMP_BUF_MAX - (p - buf),\r\n"DIAG_UL ") : NULL;\r\ninterrupt & APP1_DL ? p += snprintf(p, TMP_BUF_MAX - (p - buf),\r\n"APP1_DL ") : NULL;\r\ninterrupt & APP2_DL ? p += snprintf(p, TMP_BUF_MAX - (p - buf),\r\n"APP2_DL ") : NULL;\r\ninterrupt & APP1_UL ? p += snprintf(p, TMP_BUF_MAX - (p - buf),\r\n"APP1_UL ") : NULL;\r\ninterrupt & APP2_UL ? p += snprintf(p, TMP_BUF_MAX - (p - buf),\r\n"APP2_UL ") : NULL;\r\ninterrupt & CTRL_DL ? p += snprintf(p, TMP_BUF_MAX - (p - buf),\r\n"CTRL_DL ") : NULL;\r\ninterrupt & CTRL_UL ? p += snprintf(p, TMP_BUF_MAX - (p - buf),\r\n"CTRL_UL ") : NULL;\r\ninterrupt & RESET ? p += snprintf(p, TMP_BUF_MAX - (p - buf),\r\n"RESET ") : NULL;\r\nreturn buf;\r\n}\r\nstatic int receive_flow_control(struct nozomi *dc)\r\n{\r\nenum port_type port = PORT_MDM;\r\nstruct ctrl_dl ctrl_dl;\r\nstruct ctrl_dl old_ctrl;\r\nu16 enable_ier = 0;\r\nread_mem32((u32 *) &ctrl_dl, dc->port[PORT_CTRL].dl_addr[CH_A], 2);\r\nswitch (ctrl_dl.port) {\r\ncase CTRL_CMD:\r\nDBG1("The Base Band sends this value as a response to a "\r\n"request for IMSI detach sent over the control "\r\n"channel uplink (see section 7.6.1).");\r\nbreak;\r\ncase CTRL_MDM:\r\nport = PORT_MDM;\r\nenable_ier = MDM_DL;\r\nbreak;\r\ncase CTRL_DIAG:\r\nport = PORT_DIAG;\r\nenable_ier = DIAG_DL;\r\nbreak;\r\ncase CTRL_APP1:\r\nport = PORT_APP1;\r\nenable_ier = APP1_DL;\r\nbreak;\r\ncase CTRL_APP2:\r\nport = PORT_APP2;\r\nenable_ier = APP2_DL;\r\nif (dc->state == NOZOMI_STATE_ALLOCATED) {\r\ndc->state = NOZOMI_STATE_READY;\r\ndev_info(&dc->pdev->dev, "Device READY!\n");\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(&dc->pdev->dev,\r\n"ERROR: flow control received for non-existing port\n");\r\nreturn 0;\r\n}\r\nDBG1("0x%04X->0x%04X", *((u16 *)&dc->port[port].ctrl_dl),\r\n*((u16 *)&ctrl_dl));\r\nold_ctrl = dc->port[port].ctrl_dl;\r\ndc->port[port].ctrl_dl = ctrl_dl;\r\nif (old_ctrl.CTS == 1 && ctrl_dl.CTS == 0) {\r\nDBG1("Disable interrupt (0x%04X) on port: %d",\r\nenable_ier, port);\r\ndisable_transmit_ul(port, dc);\r\n} else if (old_ctrl.CTS == 0 && ctrl_dl.CTS == 1) {\r\nif (kfifo_len(&dc->port[port].fifo_ul)) {\r\nDBG1("Enable interrupt (0x%04X) on port: %d",\r\nenable_ier, port);\r\nDBG1("Data in buffer [%d], enable transmit! ",\r\nkfifo_len(&dc->port[port].fifo_ul));\r\nenable_transmit_ul(port, dc);\r\n} else {\r\nDBG1("No data in buffer...");\r\n}\r\n}\r\nif (*(u16 *)&old_ctrl == *(u16 *)&ctrl_dl) {\r\nDBG1(" No change in mctrl");\r\nreturn 1;\r\n}\r\nif (old_ctrl.CTS != ctrl_dl.CTS)\r\ndc->port[port].tty_icount.cts++;\r\nif (old_ctrl.DSR != ctrl_dl.DSR)\r\ndc->port[port].tty_icount.dsr++;\r\nif (old_ctrl.RI != ctrl_dl.RI)\r\ndc->port[port].tty_icount.rng++;\r\nif (old_ctrl.DCD != ctrl_dl.DCD)\r\ndc->port[port].tty_icount.dcd++;\r\nwake_up_interruptible(&dc->port[port].tty_wait);\r\nDBG1("port: %d DCD(%d), CTS(%d), RI(%d), DSR(%d)",\r\nport,\r\ndc->port[port].tty_icount.dcd, dc->port[port].tty_icount.cts,\r\ndc->port[port].tty_icount.rng, dc->port[port].tty_icount.dsr);\r\nreturn 1;\r\n}\r\nstatic enum ctrl_port_type port2ctrl(enum port_type port,\r\nconst struct nozomi *dc)\r\n{\r\nswitch (port) {\r\ncase PORT_MDM:\r\nreturn CTRL_MDM;\r\ncase PORT_DIAG:\r\nreturn CTRL_DIAG;\r\ncase PORT_APP1:\r\nreturn CTRL_APP1;\r\ncase PORT_APP2:\r\nreturn CTRL_APP2;\r\ndefault:\r\ndev_err(&dc->pdev->dev,\r\n"ERROR: send flow control " \\r\n"received for non-existing port\n");\r\n}\r\nreturn CTRL_ERROR;\r\n}\r\nstatic int send_flow_control(struct nozomi *dc)\r\n{\r\nu32 i, more_flow_control_to_be_updated = 0;\r\nu16 *ctrl;\r\nfor (i = PORT_MDM; i < MAX_PORT; i++) {\r\nif (dc->port[i].update_flow_control) {\r\nif (more_flow_control_to_be_updated) {\r\nreturn 1;\r\n}\r\ndc->port[i].ctrl_ul.port = port2ctrl(i, dc);\r\nctrl = (u16 *)&dc->port[i].ctrl_ul;\r\nwrite_mem32(dc->port[PORT_CTRL].ul_addr[0], \\r\n(u32 *) ctrl, 2);\r\ndc->port[i].update_flow_control = 0;\r\nmore_flow_control_to_be_updated = 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int handle_data_dl(struct nozomi *dc, enum port_type port, u8 *toggle,\r\nu16 read_iir, u16 mask1, u16 mask2)\r\n{\r\nif (*toggle == 0 && read_iir & mask1) {\r\nif (receive_data(port, dc)) {\r\nwritew(mask1, dc->reg_fcr);\r\n*toggle = !(*toggle);\r\n}\r\nif (read_iir & mask2) {\r\nif (receive_data(port, dc)) {\r\nwritew(mask2, dc->reg_fcr);\r\n*toggle = !(*toggle);\r\n}\r\n}\r\n} else if (*toggle == 1 && read_iir & mask2) {\r\nif (receive_data(port, dc)) {\r\nwritew(mask2, dc->reg_fcr);\r\n*toggle = !(*toggle);\r\n}\r\nif (read_iir & mask1) {\r\nif (receive_data(port, dc)) {\r\nwritew(mask1, dc->reg_fcr);\r\n*toggle = !(*toggle);\r\n}\r\n}\r\n} else {\r\ndev_err(&dc->pdev->dev, "port out of sync!, toggle:%d\n",\r\n*toggle);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int handle_data_ul(struct nozomi *dc, enum port_type port, u16 read_iir)\r\n{\r\nu8 *toggle = &(dc->port[port].toggle_ul);\r\nif (*toggle == 0 && read_iir & MDM_UL1) {\r\ndc->last_ier &= ~MDM_UL;\r\nwritew(dc->last_ier, dc->reg_ier);\r\nif (send_data(port, dc)) {\r\nwritew(MDM_UL1, dc->reg_fcr);\r\ndc->last_ier = dc->last_ier | MDM_UL;\r\nwritew(dc->last_ier, dc->reg_ier);\r\n*toggle = !*toggle;\r\n}\r\nif (read_iir & MDM_UL2) {\r\ndc->last_ier &= ~MDM_UL;\r\nwritew(dc->last_ier, dc->reg_ier);\r\nif (send_data(port, dc)) {\r\nwritew(MDM_UL2, dc->reg_fcr);\r\ndc->last_ier = dc->last_ier | MDM_UL;\r\nwritew(dc->last_ier, dc->reg_ier);\r\n*toggle = !*toggle;\r\n}\r\n}\r\n} else if (*toggle == 1 && read_iir & MDM_UL2) {\r\ndc->last_ier &= ~MDM_UL;\r\nwritew(dc->last_ier, dc->reg_ier);\r\nif (send_data(port, dc)) {\r\nwritew(MDM_UL2, dc->reg_fcr);\r\ndc->last_ier = dc->last_ier | MDM_UL;\r\nwritew(dc->last_ier, dc->reg_ier);\r\n*toggle = !*toggle;\r\n}\r\nif (read_iir & MDM_UL1) {\r\ndc->last_ier &= ~MDM_UL;\r\nwritew(dc->last_ier, dc->reg_ier);\r\nif (send_data(port, dc)) {\r\nwritew(MDM_UL1, dc->reg_fcr);\r\ndc->last_ier = dc->last_ier | MDM_UL;\r\nwritew(dc->last_ier, dc->reg_ier);\r\n*toggle = !*toggle;\r\n}\r\n}\r\n} else {\r\nwritew(read_iir & MDM_UL, dc->reg_fcr);\r\ndev_err(&dc->pdev->dev, "port out of sync!\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic irqreturn_t interrupt_handler(int irq, void *dev_id)\r\n{\r\nstruct nozomi *dc = dev_id;\r\nunsigned int a;\r\nu16 read_iir;\r\nif (!dc)\r\nreturn IRQ_NONE;\r\nspin_lock(&dc->spin_mutex);\r\nread_iir = readw(dc->reg_iir);\r\nif (read_iir == (u16)-1)\r\ngoto none;\r\nread_iir &= dc->last_ier;\r\nif (read_iir == 0)\r\ngoto none;\r\nDBG4("%s irq:0x%04X, prev:0x%04X", interrupt2str(read_iir), read_iir,\r\ndc->last_ier);\r\nif (read_iir & RESET) {\r\nif (unlikely(!nozomi_read_config_table(dc))) {\r\ndc->last_ier = 0x0;\r\nwritew(dc->last_ier, dc->reg_ier);\r\ndev_err(&dc->pdev->dev, "Could not read status from "\r\n"card, we should disable interface\n");\r\n} else {\r\nwritew(RESET, dc->reg_fcr);\r\n}\r\ngoto exit_handler;\r\n}\r\nif (read_iir & CTRL_UL) {\r\nDBG1("CTRL_UL");\r\ndc->last_ier &= ~CTRL_UL;\r\nwritew(dc->last_ier, dc->reg_ier);\r\nif (send_flow_control(dc)) {\r\nwritew(CTRL_UL, dc->reg_fcr);\r\ndc->last_ier = dc->last_ier | CTRL_UL;\r\nwritew(dc->last_ier, dc->reg_ier);\r\n}\r\n}\r\nif (read_iir & CTRL_DL) {\r\nreceive_flow_control(dc);\r\nwritew(CTRL_DL, dc->reg_fcr);\r\n}\r\nif (read_iir & MDM_DL) {\r\nif (!handle_data_dl(dc, PORT_MDM,\r\n&(dc->port[PORT_MDM].toggle_dl), read_iir,\r\nMDM_DL1, MDM_DL2)) {\r\ndev_err(&dc->pdev->dev, "MDM_DL out of sync!\n");\r\ngoto exit_handler;\r\n}\r\n}\r\nif (read_iir & MDM_UL) {\r\nif (!handle_data_ul(dc, PORT_MDM, read_iir)) {\r\ndev_err(&dc->pdev->dev, "MDM_UL out of sync!\n");\r\ngoto exit_handler;\r\n}\r\n}\r\nif (read_iir & DIAG_DL) {\r\nif (!handle_data_dl(dc, PORT_DIAG,\r\n&(dc->port[PORT_DIAG].toggle_dl), read_iir,\r\nDIAG_DL1, DIAG_DL2)) {\r\ndev_err(&dc->pdev->dev, "DIAG_DL out of sync!\n");\r\ngoto exit_handler;\r\n}\r\n}\r\nif (read_iir & DIAG_UL) {\r\ndc->last_ier &= ~DIAG_UL;\r\nwritew(dc->last_ier, dc->reg_ier);\r\nif (send_data(PORT_DIAG, dc)) {\r\nwritew(DIAG_UL, dc->reg_fcr);\r\ndc->last_ier = dc->last_ier | DIAG_UL;\r\nwritew(dc->last_ier, dc->reg_ier);\r\n}\r\n}\r\nif (read_iir & APP1_DL) {\r\nif (receive_data(PORT_APP1, dc))\r\nwritew(APP1_DL, dc->reg_fcr);\r\n}\r\nif (read_iir & APP1_UL) {\r\ndc->last_ier &= ~APP1_UL;\r\nwritew(dc->last_ier, dc->reg_ier);\r\nif (send_data(PORT_APP1, dc)) {\r\nwritew(APP1_UL, dc->reg_fcr);\r\ndc->last_ier = dc->last_ier | APP1_UL;\r\nwritew(dc->last_ier, dc->reg_ier);\r\n}\r\n}\r\nif (read_iir & APP2_DL) {\r\nif (receive_data(PORT_APP2, dc))\r\nwritew(APP2_DL, dc->reg_fcr);\r\n}\r\nif (read_iir & APP2_UL) {\r\ndc->last_ier &= ~APP2_UL;\r\nwritew(dc->last_ier, dc->reg_ier);\r\nif (send_data(PORT_APP2, dc)) {\r\nwritew(APP2_UL, dc->reg_fcr);\r\ndc->last_ier = dc->last_ier | APP2_UL;\r\nwritew(dc->last_ier, dc->reg_ier);\r\n}\r\n}\r\nexit_handler:\r\nspin_unlock(&dc->spin_mutex);\r\nfor (a = 0; a < NOZOMI_MAX_PORTS; a++)\r\nif (test_and_clear_bit(a, &dc->flip))\r\ntty_flip_buffer_push(&dc->port[a].port);\r\nreturn IRQ_HANDLED;\r\nnone:\r\nspin_unlock(&dc->spin_mutex);\r\nreturn IRQ_NONE;\r\n}\r\nstatic void nozomi_get_card_type(struct nozomi *dc)\r\n{\r\nint i;\r\nu32 size = 0;\r\nfor (i = 0; i < 6; i++)\r\nsize += pci_resource_len(dc->pdev, i);\r\ndc->card_type = size == 2048 ? F32_2 : F32_8;\r\ndev_info(&dc->pdev->dev, "Card type is: %d\n", dc->card_type);\r\n}\r\nstatic void nozomi_setup_private_data(struct nozomi *dc)\r\n{\r\nvoid __iomem *offset = dc->base_addr + dc->card_type / 2;\r\nunsigned int i;\r\ndc->reg_fcr = (void __iomem *)(offset + R_FCR);\r\ndc->reg_iir = (void __iomem *)(offset + R_IIR);\r\ndc->reg_ier = (void __iomem *)(offset + R_IER);\r\ndc->last_ier = 0;\r\ndc->flip = 0;\r\ndc->port[PORT_MDM].token_dl = MDM_DL;\r\ndc->port[PORT_DIAG].token_dl = DIAG_DL;\r\ndc->port[PORT_APP1].token_dl = APP1_DL;\r\ndc->port[PORT_APP2].token_dl = APP2_DL;\r\nfor (i = 0; i < MAX_PORT; i++)\r\ninit_waitqueue_head(&dc->port[i].tty_wait);\r\n}\r\nstatic ssize_t card_type_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nconst struct nozomi *dc = pci_get_drvdata(to_pci_dev(dev));\r\nreturn sprintf(buf, "%d\n", dc->card_type);\r\n}\r\nstatic ssize_t open_ttys_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nconst struct nozomi *dc = pci_get_drvdata(to_pci_dev(dev));\r\nreturn sprintf(buf, "%u\n", dc->open_ttys);\r\n}\r\nstatic void make_sysfs_files(struct nozomi *dc)\r\n{\r\nif (device_create_file(&dc->pdev->dev, &dev_attr_card_type))\r\ndev_err(&dc->pdev->dev,\r\n"Could not create sysfs file for card_type\n");\r\nif (device_create_file(&dc->pdev->dev, &dev_attr_open_ttys))\r\ndev_err(&dc->pdev->dev,\r\n"Could not create sysfs file for open_ttys\n");\r\n}\r\nstatic void remove_sysfs_files(struct nozomi *dc)\r\n{\r\ndevice_remove_file(&dc->pdev->dev, &dev_attr_card_type);\r\ndevice_remove_file(&dc->pdev->dev, &dev_attr_open_ttys);\r\n}\r\nstatic int nozomi_card_init(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nresource_size_t start;\r\nint ret;\r\nstruct nozomi *dc = NULL;\r\nint ndev_idx;\r\nint i;\r\ndev_dbg(&pdev->dev, "Init, new card found\n");\r\nfor (ndev_idx = 0; ndev_idx < ARRAY_SIZE(ndevs); ndev_idx++)\r\nif (!ndevs[ndev_idx])\r\nbreak;\r\nif (ndev_idx >= ARRAY_SIZE(ndevs)) {\r\ndev_err(&pdev->dev, "no free tty range for this card left\n");\r\nret = -EIO;\r\ngoto err;\r\n}\r\ndc = kzalloc(sizeof(struct nozomi), GFP_KERNEL);\r\nif (unlikely(!dc)) {\r\ndev_err(&pdev->dev, "Could not allocate memory\n");\r\nret = -ENOMEM;\r\ngoto err_free;\r\n}\r\ndc->pdev = pdev;\r\nret = pci_enable_device(dc->pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to enable PCI Device\n");\r\ngoto err_free;\r\n}\r\nret = pci_request_regions(dc->pdev, NOZOMI_NAME);\r\nif (ret) {\r\ndev_err(&pdev->dev, "I/O address 0x%04x already in use\n",\r\n(int) 0);\r\ngoto err_disable_device;\r\n}\r\nstart = pci_resource_start(dc->pdev, 0);\r\nif (start == 0) {\r\ndev_err(&pdev->dev, "No I/O address for card detected\n");\r\nret = -ENODEV;\r\ngoto err_rel_regs;\r\n}\r\nnozomi_get_card_type(dc);\r\ndc->base_addr = ioremap_nocache(start, dc->card_type);\r\nif (!dc->base_addr) {\r\ndev_err(&pdev->dev, "Unable to map card MMIO\n");\r\nret = -ENODEV;\r\ngoto err_rel_regs;\r\n}\r\ndc->send_buf = kmalloc(SEND_BUF_MAX, GFP_KERNEL);\r\nif (!dc->send_buf) {\r\ndev_err(&pdev->dev, "Could not allocate send buffer?\n");\r\nret = -ENOMEM;\r\ngoto err_free_sbuf;\r\n}\r\nfor (i = PORT_MDM; i < MAX_PORT; i++) {\r\nif (kfifo_alloc(&dc->port[i].fifo_ul, FIFO_BUFFER_SIZE_UL,\r\nGFP_KERNEL)) {\r\ndev_err(&pdev->dev,\r\n"Could not allocate kfifo buffer\n");\r\nret = -ENOMEM;\r\ngoto err_free_kfifo;\r\n}\r\n}\r\nspin_lock_init(&dc->spin_mutex);\r\nnozomi_setup_private_data(dc);\r\ndc->last_ier = 0;\r\nwritew(dc->last_ier, dc->reg_ier);\r\nret = request_irq(pdev->irq, &interrupt_handler, IRQF_SHARED,\r\nNOZOMI_NAME, dc);\r\nif (unlikely(ret)) {\r\ndev_err(&pdev->dev, "can't request irq %d\n", pdev->irq);\r\ngoto err_free_kfifo;\r\n}\r\nDBG1("base_addr: %p", dc->base_addr);\r\nmake_sysfs_files(dc);\r\ndc->index_start = ndev_idx * MAX_PORT;\r\nndevs[ndev_idx] = dc;\r\npci_set_drvdata(pdev, dc);\r\ndc->last_ier = RESET;\r\niowrite16(dc->last_ier, dc->reg_ier);\r\ndc->state = NOZOMI_STATE_ENABLED;\r\nfor (i = 0; i < MAX_PORT; i++) {\r\nstruct device *tty_dev;\r\nstruct port *port = &dc->port[i];\r\nport->dc = dc;\r\ntty_port_init(&port->port);\r\nport->port.ops = &noz_tty_port_ops;\r\ntty_dev = tty_port_register_device(&port->port, ntty_driver,\r\ndc->index_start + i, &pdev->dev);\r\nif (IS_ERR(tty_dev)) {\r\nret = PTR_ERR(tty_dev);\r\ndev_err(&pdev->dev, "Could not allocate tty?\n");\r\ntty_port_destroy(&port->port);\r\ngoto err_free_tty;\r\n}\r\n}\r\nreturn 0;\r\nerr_free_tty:\r\nfor (i = 0; i < MAX_PORT; ++i) {\r\ntty_unregister_device(ntty_driver, dc->index_start + i);\r\ntty_port_destroy(&dc->port[i].port);\r\n}\r\nerr_free_kfifo:\r\nfor (i = 0; i < MAX_PORT; i++)\r\nkfifo_free(&dc->port[i].fifo_ul);\r\nerr_free_sbuf:\r\nkfree(dc->send_buf);\r\niounmap(dc->base_addr);\r\nerr_rel_regs:\r\npci_release_regions(pdev);\r\nerr_disable_device:\r\npci_disable_device(pdev);\r\nerr_free:\r\nkfree(dc);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void tty_exit(struct nozomi *dc)\r\n{\r\nunsigned int i;\r\nDBG1(" ");\r\nfor (i = 0; i < MAX_PORT; ++i)\r\ntty_port_tty_hangup(&dc->port[i].port, false);\r\nwhile (dc->open_ttys)\r\nmsleep(1);\r\nfor (i = 0; i < MAX_PORT; ++i) {\r\ntty_unregister_device(ntty_driver, dc->index_start + i);\r\ntty_port_destroy(&dc->port[i].port);\r\n}\r\n}\r\nstatic void nozomi_card_exit(struct pci_dev *pdev)\r\n{\r\nint i;\r\nstruct ctrl_ul ctrl;\r\nstruct nozomi *dc = pci_get_drvdata(pdev);\r\ndc->last_ier = 0;\r\nwritew(dc->last_ier, dc->reg_ier);\r\ntty_exit(dc);\r\nctrl.port = 0x00;\r\nctrl.reserved = 0;\r\nctrl.RTS = 0;\r\nctrl.DTR = 1;\r\nDBG1("sending flow control 0x%04X", *((u16 *)&ctrl));\r\nwrite_mem32(dc->port[PORT_CTRL].ul_addr[0], (u32 *)&ctrl, 2);\r\nwritew(CTRL_UL, dc->reg_fcr);\r\nremove_sysfs_files(dc);\r\nfree_irq(pdev->irq, dc);\r\nfor (i = 0; i < MAX_PORT; i++)\r\nkfifo_free(&dc->port[i].fifo_ul);\r\nkfree(dc->send_buf);\r\niounmap(dc->base_addr);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nndevs[dc->index_start / MAX_PORT] = NULL;\r\nkfree(dc);\r\n}\r\nstatic void set_rts(const struct tty_struct *tty, int rts)\r\n{\r\nstruct port *port = get_port_by_tty(tty);\r\nport->ctrl_ul.RTS = rts;\r\nport->update_flow_control = 1;\r\nenable_transmit_ul(PORT_CTRL, get_dc_by_tty(tty));\r\n}\r\nstatic void set_dtr(const struct tty_struct *tty, int dtr)\r\n{\r\nstruct port *port = get_port_by_tty(tty);\r\nDBG1("SETTING DTR index: %d, dtr: %d", tty->index, dtr);\r\nport->ctrl_ul.DTR = dtr;\r\nport->update_flow_control = 1;\r\nenable_transmit_ul(PORT_CTRL, get_dc_by_tty(tty));\r\n}\r\nstatic int ntty_install(struct tty_driver *driver, struct tty_struct *tty)\r\n{\r\nstruct port *port = get_port_by_tty(tty);\r\nstruct nozomi *dc = get_dc_by_tty(tty);\r\nint ret;\r\nif (!port || !dc || dc->state != NOZOMI_STATE_READY)\r\nreturn -ENODEV;\r\nret = tty_standard_install(driver, tty);\r\nif (ret == 0)\r\ntty->driver_data = port;\r\nreturn ret;\r\n}\r\nstatic void ntty_cleanup(struct tty_struct *tty)\r\n{\r\ntty->driver_data = NULL;\r\n}\r\nstatic int ntty_activate(struct tty_port *tport, struct tty_struct *tty)\r\n{\r\nstruct port *port = container_of(tport, struct port, port);\r\nstruct nozomi *dc = port->dc;\r\nunsigned long flags;\r\nDBG1("open: %d", port->token_dl);\r\nspin_lock_irqsave(&dc->spin_mutex, flags);\r\ndc->last_ier = dc->last_ier | port->token_dl;\r\nwritew(dc->last_ier, dc->reg_ier);\r\ndc->open_ttys++;\r\nspin_unlock_irqrestore(&dc->spin_mutex, flags);\r\nprintk("noz: activated %d: %p\n", tty->index, tport);\r\nreturn 0;\r\n}\r\nstatic int ntty_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct port *port = tty->driver_data;\r\nreturn tty_port_open(&port->port, tty, filp);\r\n}\r\nstatic void ntty_shutdown(struct tty_port *tport)\r\n{\r\nstruct port *port = container_of(tport, struct port, port);\r\nstruct nozomi *dc = port->dc;\r\nunsigned long flags;\r\nDBG1("close: %d", port->token_dl);\r\nspin_lock_irqsave(&dc->spin_mutex, flags);\r\ndc->last_ier &= ~(port->token_dl);\r\nwritew(dc->last_ier, dc->reg_ier);\r\ndc->open_ttys--;\r\nspin_unlock_irqrestore(&dc->spin_mutex, flags);\r\nprintk("noz: shutdown %p\n", tport);\r\n}\r\nstatic void ntty_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct port *port = tty->driver_data;\r\nif (port)\r\ntty_port_close(&port->port, tty, filp);\r\n}\r\nstatic void ntty_hangup(struct tty_struct *tty)\r\n{\r\nstruct port *port = tty->driver_data;\r\ntty_port_hangup(&port->port);\r\n}\r\nstatic int ntty_write(struct tty_struct *tty, const unsigned char *buffer,\r\nint count)\r\n{\r\nint rval = -EINVAL;\r\nstruct nozomi *dc = get_dc_by_tty(tty);\r\nstruct port *port = tty->driver_data;\r\nunsigned long flags;\r\nif (!dc || !port)\r\nreturn -ENODEV;\r\nrval = kfifo_in(&port->fifo_ul, (unsigned char *)buffer, count);\r\nspin_lock_irqsave(&dc->spin_mutex, flags);\r\nif (port == &(dc->port[PORT_MDM])) {\r\nif (port->ctrl_dl.CTS) {\r\nDBG4("Enable interrupt");\r\nenable_transmit_ul(tty->index % MAX_PORT, dc);\r\n} else {\r\ndev_err(&dc->pdev->dev,\r\n"CTS not active on modem port?\n");\r\n}\r\n} else {\r\nenable_transmit_ul(tty->index % MAX_PORT, dc);\r\n}\r\nspin_unlock_irqrestore(&dc->spin_mutex, flags);\r\nreturn rval;\r\n}\r\nstatic int ntty_write_room(struct tty_struct *tty)\r\n{\r\nstruct port *port = tty->driver_data;\r\nint room = 4096;\r\nconst struct nozomi *dc = get_dc_by_tty(tty);\r\nif (dc)\r\nroom = kfifo_avail(&port->fifo_ul);\r\nreturn room;\r\n}\r\nstatic int ntty_tiocmget(struct tty_struct *tty)\r\n{\r\nconst struct port *port = tty->driver_data;\r\nconst struct ctrl_dl *ctrl_dl = &port->ctrl_dl;\r\nconst struct ctrl_ul *ctrl_ul = &port->ctrl_ul;\r\nreturn (ctrl_ul->RTS ? TIOCM_RTS : 0) |\r\n(ctrl_ul->DTR ? TIOCM_DTR : 0) |\r\n(ctrl_dl->DCD ? TIOCM_CAR : 0) |\r\n(ctrl_dl->RI ? TIOCM_RNG : 0) |\r\n(ctrl_dl->DSR ? TIOCM_DSR : 0) |\r\n(ctrl_dl->CTS ? TIOCM_CTS : 0);\r\n}\r\nstatic int ntty_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct nozomi *dc = get_dc_by_tty(tty);\r\nunsigned long flags;\r\nspin_lock_irqsave(&dc->spin_mutex, flags);\r\nif (set & TIOCM_RTS)\r\nset_rts(tty, 1);\r\nelse if (clear & TIOCM_RTS)\r\nset_rts(tty, 0);\r\nif (set & TIOCM_DTR)\r\nset_dtr(tty, 1);\r\nelse if (clear & TIOCM_DTR)\r\nset_dtr(tty, 0);\r\nspin_unlock_irqrestore(&dc->spin_mutex, flags);\r\nreturn 0;\r\n}\r\nstatic int ntty_cflags_changed(struct port *port, unsigned long flags,\r\nstruct async_icount *cprev)\r\n{\r\nconst struct async_icount cnow = port->tty_icount;\r\nint ret;\r\nret = ((flags & TIOCM_RNG) && (cnow.rng != cprev->rng)) ||\r\n((flags & TIOCM_DSR) && (cnow.dsr != cprev->dsr)) ||\r\n((flags & TIOCM_CD) && (cnow.dcd != cprev->dcd)) ||\r\n((flags & TIOCM_CTS) && (cnow.cts != cprev->cts));\r\n*cprev = cnow;\r\nreturn ret;\r\n}\r\nstatic int ntty_tiocgicount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nstruct port *port = tty->driver_data;\r\nconst struct async_icount cnow = port->tty_icount;\r\nicount->cts = cnow.cts;\r\nicount->dsr = cnow.dsr;\r\nicount->rng = cnow.rng;\r\nicount->dcd = cnow.dcd;\r\nicount->rx = cnow.rx;\r\nicount->tx = cnow.tx;\r\nicount->frame = cnow.frame;\r\nicount->overrun = cnow.overrun;\r\nicount->parity = cnow.parity;\r\nicount->brk = cnow.brk;\r\nicount->buf_overrun = cnow.buf_overrun;\r\nreturn 0;\r\n}\r\nstatic int ntty_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct port *port = tty->driver_data;\r\nint rval = -ENOIOCTLCMD;\r\nDBG1("******** IOCTL, cmd: %d", cmd);\r\nswitch (cmd) {\r\ncase TIOCMIWAIT: {\r\nstruct async_icount cprev = port->tty_icount;\r\nrval = wait_event_interruptible(port->tty_wait,\r\nntty_cflags_changed(port, arg, &cprev));\r\nbreak;\r\n}\r\ndefault:\r\nDBG1("ERR: 0x%08X, %d", cmd, cmd);\r\nbreak;\r\n}\r\nreturn rval;\r\n}\r\nstatic void ntty_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct nozomi *dc = get_dc_by_tty(tty);\r\nunsigned long flags;\r\nDBG1("UNTHROTTLE");\r\nspin_lock_irqsave(&dc->spin_mutex, flags);\r\nenable_transmit_dl(tty->index % MAX_PORT, dc);\r\nset_rts(tty, 1);\r\nspin_unlock_irqrestore(&dc->spin_mutex, flags);\r\n}\r\nstatic void ntty_throttle(struct tty_struct *tty)\r\n{\r\nstruct nozomi *dc = get_dc_by_tty(tty);\r\nunsigned long flags;\r\nDBG1("THROTTLE");\r\nspin_lock_irqsave(&dc->spin_mutex, flags);\r\nset_rts(tty, 0);\r\nspin_unlock_irqrestore(&dc->spin_mutex, flags);\r\n}\r\nstatic s32 ntty_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct port *port = tty->driver_data;\r\nstruct nozomi *dc = get_dc_by_tty(tty);\r\ns32 rval = 0;\r\nif (unlikely(!dc || !port)) {\r\ngoto exit_in_buffer;\r\n}\r\nrval = kfifo_len(&port->fifo_ul);\r\nexit_in_buffer:\r\nreturn rval;\r\n}\r\nstatic __init int nozomi_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "Initializing %s\n", VERSION_STRING);\r\nntty_driver = alloc_tty_driver(NTTY_TTY_MAXMINORS);\r\nif (!ntty_driver)\r\nreturn -ENOMEM;\r\nntty_driver->driver_name = NOZOMI_NAME_TTY;\r\nntty_driver->name = "noz";\r\nntty_driver->major = 0;\r\nntty_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\nntty_driver->subtype = SERIAL_TYPE_NORMAL;\r\nntty_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\r\nntty_driver->init_termios = tty_std_termios;\r\nntty_driver->init_termios.c_cflag = B115200 | CS8 | CREAD | \\r\nHUPCL | CLOCAL;\r\nntty_driver->init_termios.c_ispeed = 115200;\r\nntty_driver->init_termios.c_ospeed = 115200;\r\ntty_set_operations(ntty_driver, &tty_ops);\r\nret = tty_register_driver(ntty_driver);\r\nif (ret) {\r\nprintk(KERN_ERR "Nozomi: failed to register ntty driver\n");\r\ngoto free_tty;\r\n}\r\nret = pci_register_driver(&nozomi_driver);\r\nif (ret) {\r\nprintk(KERN_ERR "Nozomi: can't register pci driver\n");\r\ngoto unr_tty;\r\n}\r\nreturn 0;\r\nunr_tty:\r\ntty_unregister_driver(ntty_driver);\r\nfree_tty:\r\nput_tty_driver(ntty_driver);\r\nreturn ret;\r\n}\r\nstatic __exit void nozomi_exit(void)\r\n{\r\nprintk(KERN_INFO "Unloading %s\n", DRIVER_DESC);\r\npci_unregister_driver(&nozomi_driver);\r\ntty_unregister_driver(ntty_driver);\r\nput_tty_driver(ntty_driver);\r\n}
