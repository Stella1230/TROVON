static int hose_mmap_page_range(struct pci_controller *hose,\r\nstruct vm_area_struct *vma,\r\nenum pci_mmap_state mmap_type, int sparse)\r\n{\r\nunsigned long base;\r\nif (mmap_type == pci_mmap_mem)\r\nbase = sparse ? hose->sparse_mem_base : hose->dense_mem_base;\r\nelse\r\nbase = sparse ? hose->sparse_io_base : hose->dense_io_base;\r\nvma->vm_pgoff += base >> PAGE_SHIFT;\r\nreturn io_remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,\r\nvma->vm_end - vma->vm_start,\r\nvma->vm_page_prot);\r\n}\r\nstatic int __pci_mmap_fits(struct pci_dev *pdev, int num,\r\nstruct vm_area_struct *vma, int sparse)\r\n{\r\nunsigned long nr, start, size;\r\nint shift = sparse ? 5 : 0;\r\nnr = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;\r\nstart = vma->vm_pgoff;\r\nsize = ((pci_resource_len(pdev, num) - 1) >> (PAGE_SHIFT - shift)) + 1;\r\nif (start < size && size - start >= nr)\r\nreturn 1;\r\nWARN(1, "process \"%s\" tried to map%s 0x%08lx-0x%08lx on %s BAR %d "\r\n"(size 0x%08lx)\n",\r\ncurrent->comm, sparse ? " sparse" : "", start, start + nr,\r\npci_name(pdev), num, size);\r\nreturn 0;\r\n}\r\nstatic int pci_mmap_resource(struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nstruct vm_area_struct *vma, int sparse)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(container_of(kobj,\r\nstruct device, kobj));\r\nstruct resource *res = attr->private;\r\nenum pci_mmap_state mmap_type;\r\nstruct pci_bus_region bar;\r\nint i;\r\nfor (i = 0; i < PCI_ROM_RESOURCE; i++)\r\nif (res == &pdev->resource[i])\r\nbreak;\r\nif (i >= PCI_ROM_RESOURCE)\r\nreturn -ENODEV;\r\nif (!__pci_mmap_fits(pdev, i, vma, sparse))\r\nreturn -EINVAL;\r\nif (iomem_is_exclusive(res->start))\r\nreturn -EINVAL;\r\npcibios_resource_to_bus(pdev->bus, &bar, res);\r\nvma->vm_pgoff += bar.start >> (PAGE_SHIFT - (sparse ? 5 : 0));\r\nmmap_type = res->flags & IORESOURCE_MEM ? pci_mmap_mem : pci_mmap_io;\r\nreturn hose_mmap_page_range(pdev->sysdata, vma, mmap_type, sparse);\r\n}\r\nstatic int pci_mmap_resource_sparse(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nstruct vm_area_struct *vma)\r\n{\r\nreturn pci_mmap_resource(kobj, attr, vma, 1);\r\n}\r\nstatic int pci_mmap_resource_dense(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *attr,\r\nstruct vm_area_struct *vma)\r\n{\r\nreturn pci_mmap_resource(kobj, attr, vma, 0);\r\n}\r\nvoid pci_remove_resource_files(struct pci_dev *pdev)\r\n{\r\nint i;\r\nfor (i = 0; i < PCI_ROM_RESOURCE; i++) {\r\nstruct bin_attribute *res_attr;\r\nres_attr = pdev->res_attr[i];\r\nif (res_attr) {\r\nsysfs_remove_bin_file(&pdev->dev.kobj, res_attr);\r\nkfree(res_attr);\r\n}\r\nres_attr = pdev->res_attr_wc[i];\r\nif (res_attr) {\r\nsysfs_remove_bin_file(&pdev->dev.kobj, res_attr);\r\nkfree(res_attr);\r\n}\r\n}\r\n}\r\nstatic int sparse_mem_mmap_fits(struct pci_dev *pdev, int num)\r\n{\r\nstruct pci_bus_region bar;\r\nstruct pci_controller *hose = pdev->sysdata;\r\nlong dense_offset;\r\nunsigned long sparse_size;\r\npcibios_resource_to_bus(pdev->bus, &bar, &pdev->resource[num]);\r\ndense_offset = (long)(hose->dense_mem_base - hose->sparse_mem_base);\r\nsparse_size = dense_offset >= 0x400000000UL ? 0x20000000 : 0x8000000;\r\nreturn bar.end < sparse_size;\r\n}\r\nstatic int pci_create_one_attr(struct pci_dev *pdev, int num, char *name,\r\nchar *suffix, struct bin_attribute *res_attr,\r\nunsigned long sparse)\r\n{\r\nsize_t size = pci_resource_len(pdev, num);\r\nsprintf(name, "resource%d%s", num, suffix);\r\nres_attr->mmap = sparse ? pci_mmap_resource_sparse :\r\npci_mmap_resource_dense;\r\nres_attr->attr.name = name;\r\nres_attr->attr.mode = S_IRUSR | S_IWUSR;\r\nres_attr->size = sparse ? size << 5 : size;\r\nres_attr->private = &pdev->resource[num];\r\nreturn sysfs_create_bin_file(&pdev->dev.kobj, res_attr);\r\n}\r\nstatic int pci_create_attr(struct pci_dev *pdev, int num)\r\n{\r\nint retval, nlen1, nlen2 = 0, res_count = 1;\r\nunsigned long sparse_base, dense_base;\r\nstruct bin_attribute *attr;\r\nstruct pci_controller *hose = pdev->sysdata;\r\nchar *suffix, *attr_name;\r\nsuffix = "";\r\nnlen1 = 10;\r\nif (pdev->resource[num].flags & IORESOURCE_MEM) {\r\nsparse_base = hose->sparse_mem_base;\r\ndense_base = hose->dense_mem_base;\r\nif (sparse_base && !sparse_mem_mmap_fits(pdev, num)) {\r\nsparse_base = 0;\r\nsuffix = "_dense";\r\nnlen1 = 16;\r\n}\r\n} else {\r\nsparse_base = hose->sparse_io_base;\r\ndense_base = hose->dense_io_base;\r\n}\r\nif (sparse_base) {\r\nsuffix = "_sparse";\r\nnlen1 = 17;\r\nif (dense_base) {\r\nnlen2 = 16;\r\nres_count = 2;\r\n}\r\n}\r\nattr = kzalloc(sizeof(*attr) * res_count + nlen1 + nlen2, GFP_ATOMIC);\r\nif (!attr)\r\nreturn -ENOMEM;\r\nattr_name = (char *)(attr + res_count);\r\npdev->res_attr[num] = attr;\r\nretval = pci_create_one_attr(pdev, num, attr_name, suffix, attr,\r\nsparse_base);\r\nif (retval || res_count == 1)\r\nreturn retval;\r\nattr_name += nlen1;\r\nattr++;\r\npdev->res_attr_wc[num] = attr;\r\nreturn pci_create_one_attr(pdev, num, attr_name, "_dense", attr, 0);\r\n}\r\nint pci_create_resource_files(struct pci_dev *pdev)\r\n{\r\nint i;\r\nint retval;\r\nfor (i = 0; i < PCI_ROM_RESOURCE; i++) {\r\nif (!pci_resource_len(pdev, i))\r\ncontinue;\r\nretval = pci_create_attr(pdev, i);\r\nif (retval) {\r\npci_remove_resource_files(pdev);\r\nreturn retval;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __legacy_mmap_fits(struct pci_controller *hose,\r\nstruct vm_area_struct *vma,\r\nunsigned long res_size, int sparse)\r\n{\r\nunsigned long nr, start, size;\r\nnr = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;\r\nstart = vma->vm_pgoff;\r\nsize = ((res_size - 1) >> PAGE_SHIFT) + 1;\r\nif (start < size && size - start >= nr)\r\nreturn 1;\r\nWARN(1, "process \"%s\" tried to map%s 0x%08lx-0x%08lx on hose %d "\r\n"(size 0x%08lx)\n",\r\ncurrent->comm, sparse ? " sparse" : "", start, start + nr,\r\nhose->index, size);\r\nreturn 0;\r\n}\r\nstatic inline int has_sparse(struct pci_controller *hose,\r\nenum pci_mmap_state mmap_type)\r\n{\r\nunsigned long base;\r\nbase = (mmap_type == pci_mmap_mem) ? hose->sparse_mem_base :\r\nhose->sparse_io_base;\r\nreturn base != 0;\r\n}\r\nint pci_mmap_legacy_page_range(struct pci_bus *bus, struct vm_area_struct *vma,\r\nenum pci_mmap_state mmap_type)\r\n{\r\nstruct pci_controller *hose = bus->sysdata;\r\nint sparse = has_sparse(hose, mmap_type);\r\nunsigned long res_size;\r\nres_size = (mmap_type == pci_mmap_mem) ? bus->legacy_mem->size :\r\nbus->legacy_io->size;\r\nif (!__legacy_mmap_fits(hose, vma, res_size, sparse))\r\nreturn -EINVAL;\r\nreturn hose_mmap_page_range(hose, vma, mmap_type, sparse);\r\n}\r\nvoid pci_adjust_legacy_attr(struct pci_bus *bus, enum pci_mmap_state mmap_type)\r\n{\r\nstruct pci_controller *hose = bus->sysdata;\r\nif (!has_sparse(hose, mmap_type))\r\nreturn;\r\nif (mmap_type == pci_mmap_mem) {\r\nbus->legacy_mem->attr.name = "legacy_mem_sparse";\r\nbus->legacy_mem->size <<= 5;\r\n} else {\r\nbus->legacy_io->attr.name = "legacy_io_sparse";\r\nbus->legacy_io->size <<= 5;\r\n}\r\nreturn;\r\n}\r\nint pci_legacy_read(struct pci_bus *bus, loff_t port, u32 *val, size_t size)\r\n{\r\nstruct pci_controller *hose = bus->sysdata;\r\nport += hose->io_space->start;\r\nswitch(size) {\r\ncase 1:\r\n*((u8 *)val) = inb(port);\r\nreturn 1;\r\ncase 2:\r\nif (port & 1)\r\nreturn -EINVAL;\r\n*((u16 *)val) = inw(port);\r\nreturn 2;\r\ncase 4:\r\nif (port & 3)\r\nreturn -EINVAL;\r\n*((u32 *)val) = inl(port);\r\nreturn 4;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint pci_legacy_write(struct pci_bus *bus, loff_t port, u32 val, size_t size)\r\n{\r\nstruct pci_controller *hose = bus->sysdata;\r\nport += hose->io_space->start;\r\nswitch(size) {\r\ncase 1:\r\noutb(port, val);\r\nreturn 1;\r\ncase 2:\r\nif (port & 1)\r\nreturn -EINVAL;\r\noutw(port, val);\r\nreturn 2;\r\ncase 4:\r\nif (port & 3)\r\nreturn -EINVAL;\r\noutl(port, val);\r\nreturn 4;\r\n}\r\nreturn -EINVAL;\r\n}
