struct ssc_device *ssc_request(unsigned int ssc_num)\r\n{\r\nint ssc_valid = 0;\r\nstruct ssc_device *ssc;\r\nspin_lock(&user_lock);\r\nlist_for_each_entry(ssc, &ssc_list, list) {\r\nif (ssc->pdev->dev.of_node) {\r\nif (of_alias_get_id(ssc->pdev->dev.of_node, "ssc")\r\n== ssc_num) {\r\nssc_valid = 1;\r\nbreak;\r\n}\r\n} else if (ssc->pdev->id == ssc_num) {\r\nssc_valid = 1;\r\nbreak;\r\n}\r\n}\r\nif (!ssc_valid) {\r\nspin_unlock(&user_lock);\r\npr_err("ssc: ssc%d platform device is missing\n", ssc_num);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nif (ssc->user) {\r\nspin_unlock(&user_lock);\r\ndev_dbg(&ssc->pdev->dev, "module busy\n");\r\nreturn ERR_PTR(-EBUSY);\r\n}\r\nssc->user++;\r\nspin_unlock(&user_lock);\r\nclk_prepare(ssc->clk);\r\nreturn ssc;\r\n}\r\nvoid ssc_free(struct ssc_device *ssc)\r\n{\r\nbool disable_clk = true;\r\nspin_lock(&user_lock);\r\nif (ssc->user)\r\nssc->user--;\r\nelse {\r\ndisable_clk = false;\r\ndev_dbg(&ssc->pdev->dev, "device already free\n");\r\n}\r\nspin_unlock(&user_lock);\r\nif (disable_clk)\r\nclk_unprepare(ssc->clk);\r\n}\r\nstatic inline const struct atmel_ssc_platform_data * __init\r\natmel_ssc_get_driver_data(struct platform_device *pdev)\r\n{\r\nif (pdev->dev.of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(atmel_ssc_dt_ids, pdev->dev.of_node);\r\nif (match == NULL)\r\nreturn NULL;\r\nreturn match->data;\r\n}\r\nreturn (struct atmel_ssc_platform_data *)\r\nplatform_get_device_id(pdev)->driver_data;\r\n}\r\nstatic int ssc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *regs;\r\nstruct ssc_device *ssc;\r\nconst struct atmel_ssc_platform_data *plat_dat;\r\nssc = devm_kzalloc(&pdev->dev, sizeof(struct ssc_device), GFP_KERNEL);\r\nif (!ssc) {\r\ndev_dbg(&pdev->dev, "out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nssc->pdev = pdev;\r\nplat_dat = atmel_ssc_get_driver_data(pdev);\r\nif (!plat_dat)\r\nreturn -ENODEV;\r\nssc->pdata = (struct atmel_ssc_platform_data *)plat_dat;\r\nif (pdev->dev.of_node) {\r\nstruct device_node *np = pdev->dev.of_node;\r\nssc->clk_from_rk_pin =\r\nof_property_read_bool(np, "atmel,clk-from-rk-pin");\r\n}\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nssc->regs = devm_ioremap_resource(&pdev->dev, regs);\r\nif (IS_ERR(ssc->regs))\r\nreturn PTR_ERR(ssc->regs);\r\nssc->phybase = regs->start;\r\nssc->clk = devm_clk_get(&pdev->dev, "pclk");\r\nif (IS_ERR(ssc->clk)) {\r\ndev_dbg(&pdev->dev, "no pclk clock defined\n");\r\nreturn -ENXIO;\r\n}\r\nclk_prepare_enable(ssc->clk);\r\nssc_writel(ssc->regs, IDR, -1);\r\nssc_readl(ssc->regs, SR);\r\nclk_disable_unprepare(ssc->clk);\r\nssc->irq = platform_get_irq(pdev, 0);\r\nif (!ssc->irq) {\r\ndev_dbg(&pdev->dev, "could not get irq\n");\r\nreturn -ENXIO;\r\n}\r\nspin_lock(&user_lock);\r\nlist_add_tail(&ssc->list, &ssc_list);\r\nspin_unlock(&user_lock);\r\nplatform_set_drvdata(pdev, ssc);\r\ndev_info(&pdev->dev, "Atmel SSC device at 0x%p (irq %d)\n",\r\nssc->regs, ssc->irq);\r\nreturn 0;\r\n}\r\nstatic int ssc_remove(struct platform_device *pdev)\r\n{\r\nstruct ssc_device *ssc = platform_get_drvdata(pdev);\r\nspin_lock(&user_lock);\r\nlist_del(&ssc->list);\r\nspin_unlock(&user_lock);\r\nreturn 0;\r\n}
