STATIC int\r\nxfs_attr_args_init(\r\nstruct xfs_da_args *args,\r\nstruct xfs_inode *dp,\r\nconst unsigned char *name,\r\nint flags)\r\n{\r\nif (!name)\r\nreturn -EINVAL;\r\nmemset(args, 0, sizeof(*args));\r\nargs->geo = dp->i_mount->m_attr_geo;\r\nargs->whichfork = XFS_ATTR_FORK;\r\nargs->dp = dp;\r\nargs->flags = flags;\r\nargs->name = name;\r\nargs->namelen = strlen((const char *)name);\r\nif (args->namelen >= MAXNAMELEN)\r\nreturn -EFAULT;\r\nargs->hashval = xfs_da_hashname(args->name, args->namelen);\r\nreturn 0;\r\n}\r\nint\r\nxfs_inode_hasattr(\r\nstruct xfs_inode *ip)\r\n{\r\nif (!XFS_IFORK_Q(ip) ||\r\n(ip->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\r\nip->i_d.di_anextents == 0))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nint\r\nxfs_attr_get(\r\nstruct xfs_inode *ip,\r\nconst unsigned char *name,\r\nunsigned char *value,\r\nint *valuelenp,\r\nint flags)\r\n{\r\nstruct xfs_da_args args;\r\nuint lock_mode;\r\nint error;\r\nXFS_STATS_INC(xs_attr_get);\r\nif (XFS_FORCED_SHUTDOWN(ip->i_mount))\r\nreturn -EIO;\r\nif (!xfs_inode_hasattr(ip))\r\nreturn -ENOATTR;\r\nerror = xfs_attr_args_init(&args, ip, name, flags);\r\nif (error)\r\nreturn error;\r\nargs.value = value;\r\nargs.valuelen = *valuelenp;\r\nlock_mode = xfs_ilock_attr_map_shared(ip);\r\nif (!xfs_inode_hasattr(ip))\r\nerror = -ENOATTR;\r\nelse if (ip->i_d.di_aformat == XFS_DINODE_FMT_LOCAL)\r\nerror = xfs_attr_shortform_getvalue(&args);\r\nelse if (xfs_bmap_one_block(ip, XFS_ATTR_FORK))\r\nerror = xfs_attr_leaf_get(&args);\r\nelse\r\nerror = xfs_attr_node_get(&args);\r\nxfs_iunlock(ip, lock_mode);\r\n*valuelenp = args.valuelen;\r\nreturn error == -EEXIST ? 0 : error;\r\n}\r\nSTATIC int\r\nxfs_attr_calc_size(\r\nstruct xfs_da_args *args,\r\nint *local)\r\n{\r\nstruct xfs_mount *mp = args->dp->i_mount;\r\nint size;\r\nint nblks;\r\nsize = xfs_attr_leaf_newentsize(args, local);\r\nnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\r\nif (*local) {\r\nif (size > (args->geo->blksize / 2)) {\r\nnblks *= 2;\r\n}\r\n} else {\r\nuint dblocks = xfs_attr3_rmt_blocks(mp, args->valuelen);\r\nnblks += dblocks;\r\nnblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);\r\n}\r\nreturn nblks;\r\n}\r\nint\r\nxfs_attr_set(\r\nstruct xfs_inode *dp,\r\nconst unsigned char *name,\r\nunsigned char *value,\r\nint valuelen,\r\nint flags)\r\n{\r\nstruct xfs_mount *mp = dp->i_mount;\r\nstruct xfs_da_args args;\r\nstruct xfs_bmap_free flist;\r\nstruct xfs_trans_res tres;\r\nxfs_fsblock_t firstblock;\r\nint rsvd = (flags & ATTR_ROOT) != 0;\r\nint error, err2, committed, local;\r\nXFS_STATS_INC(xs_attr_set);\r\nif (XFS_FORCED_SHUTDOWN(dp->i_mount))\r\nreturn -EIO;\r\nerror = xfs_attr_args_init(&args, dp, name, flags);\r\nif (error)\r\nreturn error;\r\nargs.value = value;\r\nargs.valuelen = valuelen;\r\nargs.firstblock = &firstblock;\r\nargs.flist = &flist;\r\nargs.op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\r\nargs.total = xfs_attr_calc_size(&args, &local);\r\nerror = xfs_qm_dqattach(dp, 0);\r\nif (error)\r\nreturn error;\r\nif (XFS_IFORK_Q(dp) == 0) {\r\nint sf_size = sizeof(xfs_attr_sf_hdr_t) +\r\nXFS_ATTR_SF_ENTSIZE_BYNAME(args.namelen, valuelen);\r\nerror = xfs_bmap_add_attrfork(dp, sf_size, rsvd);\r\nif (error)\r\nreturn error;\r\n}\r\nargs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_SET);\r\nif (rsvd)\r\nargs.trans->t_flags |= XFS_TRANS_RESERVE;\r\ntres.tr_logres = M_RES(mp)->tr_attrsetm.tr_logres +\r\nM_RES(mp)->tr_attrsetrt.tr_logres * args.total;\r\ntres.tr_logcount = XFS_ATTRSET_LOG_COUNT;\r\ntres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\r\nerror = xfs_trans_reserve(args.trans, &tres, args.total, 0);\r\nif (error) {\r\nxfs_trans_cancel(args.trans, 0);\r\nreturn error;\r\n}\r\nxfs_ilock(dp, XFS_ILOCK_EXCL);\r\nerror = xfs_trans_reserve_quota_nblks(args.trans, dp, args.total, 0,\r\nrsvd ? XFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\r\nXFS_QMOPT_RES_REGBLKS);\r\nif (error) {\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nxfs_trans_cancel(args.trans, XFS_TRANS_RELEASE_LOG_RES);\r\nreturn error;\r\n}\r\nxfs_trans_ijoin(args.trans, dp, 0);\r\nif (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL ||\r\n(dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS &&\r\ndp->i_d.di_anextents == 0)) {\r\nif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS)\r\nxfs_attr_shortform_create(&args);\r\nerror = xfs_attr_shortform_addname(&args);\r\nif (error != -ENOSPC) {\r\nASSERT(args.trans != NULL);\r\nif (mp->m_flags & XFS_MOUNT_WSYNC)\r\nxfs_trans_set_sync(args.trans);\r\nif (!error && (flags & ATTR_KERNOTIME) == 0) {\r\nxfs_trans_ichgtime(args.trans, dp,\r\nXFS_ICHGTIME_CHG);\r\n}\r\nerr2 = xfs_trans_commit(args.trans,\r\nXFS_TRANS_RELEASE_LOG_RES);\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nreturn error ? error : err2;\r\n}\r\nxfs_bmap_init(args.flist, args.firstblock);\r\nerror = xfs_attr_shortform_to_leaf(&args);\r\nif (!error) {\r\nerror = xfs_bmap_finish(&args.trans, args.flist,\r\n&committed);\r\n}\r\nif (error) {\r\nASSERT(committed);\r\nargs.trans = NULL;\r\nxfs_bmap_cancel(&flist);\r\ngoto out;\r\n}\r\nif (committed)\r\nxfs_trans_ijoin(args.trans, dp, 0);\r\nerror = xfs_trans_roll(&args.trans, dp);\r\nif (error)\r\ngoto out;\r\n}\r\nif (xfs_bmap_one_block(dp, XFS_ATTR_FORK))\r\nerror = xfs_attr_leaf_addname(&args);\r\nelse\r\nerror = xfs_attr_node_addname(&args);\r\nif (error)\r\ngoto out;\r\nif (mp->m_flags & XFS_MOUNT_WSYNC)\r\nxfs_trans_set_sync(args.trans);\r\nif ((flags & ATTR_KERNOTIME) == 0)\r\nxfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\r\nxfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\r\nerror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nreturn error;\r\nout:\r\nif (args.trans) {\r\nxfs_trans_cancel(args.trans,\r\nXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\r\n}\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nreturn error;\r\n}\r\nint\r\nxfs_attr_remove(\r\nstruct xfs_inode *dp,\r\nconst unsigned char *name,\r\nint flags)\r\n{\r\nstruct xfs_mount *mp = dp->i_mount;\r\nstruct xfs_da_args args;\r\nstruct xfs_bmap_free flist;\r\nxfs_fsblock_t firstblock;\r\nint error;\r\nXFS_STATS_INC(xs_attr_remove);\r\nif (XFS_FORCED_SHUTDOWN(dp->i_mount))\r\nreturn -EIO;\r\nif (!xfs_inode_hasattr(dp))\r\nreturn -ENOATTR;\r\nerror = xfs_attr_args_init(&args, dp, name, flags);\r\nif (error)\r\nreturn error;\r\nargs.firstblock = &firstblock;\r\nargs.flist = &flist;\r\nargs.op_flags = XFS_DA_OP_OKNOENT;\r\nerror = xfs_qm_dqattach(dp, 0);\r\nif (error)\r\nreturn error;\r\nargs.trans = xfs_trans_alloc(mp, XFS_TRANS_ATTR_RM);\r\nif (flags & ATTR_ROOT)\r\nargs.trans->t_flags |= XFS_TRANS_RESERVE;\r\nerror = xfs_trans_reserve(args.trans, &M_RES(mp)->tr_attrrm,\r\nXFS_ATTRRM_SPACE_RES(mp), 0);\r\nif (error) {\r\nxfs_trans_cancel(args.trans, 0);\r\nreturn error;\r\n}\r\nxfs_ilock(dp, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(args.trans, dp, 0);\r\nif (!xfs_inode_hasattr(dp)) {\r\nerror = -ENOATTR;\r\n} else if (dp->i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {\r\nASSERT(dp->i_afp->if_flags & XFS_IFINLINE);\r\nerror = xfs_attr_shortform_remove(&args);\r\n} else if (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\r\nerror = xfs_attr_leaf_removename(&args);\r\n} else {\r\nerror = xfs_attr_node_removename(&args);\r\n}\r\nif (error)\r\ngoto out;\r\nif (mp->m_flags & XFS_MOUNT_WSYNC)\r\nxfs_trans_set_sync(args.trans);\r\nif ((flags & ATTR_KERNOTIME) == 0)\r\nxfs_trans_ichgtime(args.trans, dp, XFS_ICHGTIME_CHG);\r\nxfs_trans_log_inode(args.trans, dp, XFS_ILOG_CORE);\r\nerror = xfs_trans_commit(args.trans, XFS_TRANS_RELEASE_LOG_RES);\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nreturn error;\r\nout:\r\nif (args.trans) {\r\nxfs_trans_cancel(args.trans,\r\nXFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);\r\n}\r\nxfs_iunlock(dp, XFS_ILOCK_EXCL);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_attr_shortform_addname(xfs_da_args_t *args)\r\n{\r\nint newsize, forkoff, retval;\r\ntrace_xfs_attr_sf_addname(args);\r\nretval = xfs_attr_shortform_lookup(args);\r\nif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\r\nreturn retval;\r\n} else if (retval == -EEXIST) {\r\nif (args->flags & ATTR_CREATE)\r\nreturn retval;\r\nretval = xfs_attr_shortform_remove(args);\r\nASSERT(retval == 0);\r\n}\r\nif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\r\nargs->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\r\nreturn -ENOSPC;\r\nnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\r\nnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\r\nforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\r\nif (!forkoff)\r\nreturn -ENOSPC;\r\nxfs_attr_shortform_add(args, forkoff);\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_attr_leaf_addname(xfs_da_args_t *args)\r\n{\r\nxfs_inode_t *dp;\r\nstruct xfs_buf *bp;\r\nint retval, error, committed, forkoff;\r\ntrace_xfs_attr_leaf_addname(args);\r\ndp = args->dp;\r\nargs->blkno = 0;\r\nerror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\r\nif (error)\r\nreturn error;\r\nretval = xfs_attr3_leaf_lookup_int(bp, args);\r\nif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\r\nxfs_trans_brelse(args->trans, bp);\r\nreturn retval;\r\n} else if (retval == -EEXIST) {\r\nif (args->flags & ATTR_CREATE) {\r\nxfs_trans_brelse(args->trans, bp);\r\nreturn retval;\r\n}\r\ntrace_xfs_attr_leaf_replace(args);\r\nargs->op_flags |= XFS_DA_OP_RENAME;\r\nargs->blkno2 = args->blkno;\r\nargs->index2 = args->index;\r\nargs->rmtblkno2 = args->rmtblkno;\r\nargs->rmtblkcnt2 = args->rmtblkcnt;\r\nargs->rmtvaluelen2 = args->rmtvaluelen;\r\nargs->rmtblkno = 0;\r\nargs->rmtblkcnt = 0;\r\nargs->rmtvaluelen = 0;\r\n}\r\nretval = xfs_attr3_leaf_add(bp, args);\r\nif (retval == -ENOSPC) {\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nerror = xfs_attr3_leaf_to_node(args);\r\nif (!error) {\r\nerror = xfs_bmap_finish(&args->trans, args->flist,\r\n&committed);\r\n}\r\nif (error) {\r\nASSERT(committed);\r\nargs->trans = NULL;\r\nxfs_bmap_cancel(args->flist);\r\nreturn error;\r\n}\r\nif (committed)\r\nxfs_trans_ijoin(args->trans, dp, 0);\r\nerror = xfs_trans_roll(&args->trans, dp);\r\nif (error)\r\nreturn error;\r\nerror = xfs_attr_node_addname(args);\r\nreturn error;\r\n}\r\nerror = xfs_trans_roll(&args->trans, dp);\r\nif (error)\r\nreturn error;\r\nif (args->rmtblkno > 0) {\r\nerror = xfs_attr_rmtval_set(args);\r\nif (error)\r\nreturn error;\r\n}\r\nif (args->op_flags & XFS_DA_OP_RENAME) {\r\nerror = xfs_attr3_leaf_flipflags(args);\r\nif (error)\r\nreturn error;\r\nargs->index = args->index2;\r\nargs->blkno = args->blkno2;\r\nargs->rmtblkno = args->rmtblkno2;\r\nargs->rmtblkcnt = args->rmtblkcnt2;\r\nargs->rmtvaluelen = args->rmtvaluelen2;\r\nif (args->rmtblkno) {\r\nerror = xfs_attr_rmtval_remove(args);\r\nif (error)\r\nreturn error;\r\n}\r\nerror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno,\r\n-1, &bp);\r\nif (error)\r\nreturn error;\r\nxfs_attr3_leaf_remove(bp, args);\r\nif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nerror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\r\nif (!error) {\r\nerror = xfs_bmap_finish(&args->trans,\r\nargs->flist,\r\n&committed);\r\n}\r\nif (error) {\r\nASSERT(committed);\r\nargs->trans = NULL;\r\nxfs_bmap_cancel(args->flist);\r\nreturn error;\r\n}\r\nif (committed)\r\nxfs_trans_ijoin(args->trans, dp, 0);\r\n}\r\nerror = xfs_trans_roll(&args->trans, dp);\r\n} else if (args->rmtblkno > 0) {\r\nerror = xfs_attr3_leaf_clearflag(args);\r\n}\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_attr_leaf_removename(xfs_da_args_t *args)\r\n{\r\nxfs_inode_t *dp;\r\nstruct xfs_buf *bp;\r\nint error, committed, forkoff;\r\ntrace_xfs_attr_leaf_removename(args);\r\ndp = args->dp;\r\nargs->blkno = 0;\r\nerror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\r\nif (error)\r\nreturn error;\r\nerror = xfs_attr3_leaf_lookup_int(bp, args);\r\nif (error == -ENOATTR) {\r\nxfs_trans_brelse(args->trans, bp);\r\nreturn error;\r\n}\r\nxfs_attr3_leaf_remove(bp, args);\r\nif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nerror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\r\nif (!error) {\r\nerror = xfs_bmap_finish(&args->trans, args->flist,\r\n&committed);\r\n}\r\nif (error) {\r\nASSERT(committed);\r\nargs->trans = NULL;\r\nxfs_bmap_cancel(args->flist);\r\nreturn error;\r\n}\r\nif (committed)\r\nxfs_trans_ijoin(args->trans, dp, 0);\r\n}\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_attr_leaf_get(xfs_da_args_t *args)\r\n{\r\nstruct xfs_buf *bp;\r\nint error;\r\ntrace_xfs_attr_leaf_get(args);\r\nargs->blkno = 0;\r\nerror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\r\nif (error)\r\nreturn error;\r\nerror = xfs_attr3_leaf_lookup_int(bp, args);\r\nif (error != -EEXIST) {\r\nxfs_trans_brelse(args->trans, bp);\r\nreturn error;\r\n}\r\nerror = xfs_attr3_leaf_getvalue(bp, args);\r\nxfs_trans_brelse(args->trans, bp);\r\nif (!error && (args->rmtblkno > 0) && !(args->flags & ATTR_KERNOVAL)) {\r\nerror = xfs_attr_rmtval_get(args);\r\n}\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_attr_node_addname(xfs_da_args_t *args)\r\n{\r\nxfs_da_state_t *state;\r\nxfs_da_state_blk_t *blk;\r\nxfs_inode_t *dp;\r\nxfs_mount_t *mp;\r\nint committed, retval, error;\r\ntrace_xfs_attr_node_addname(args);\r\ndp = args->dp;\r\nmp = dp->i_mount;\r\nrestart:\r\nstate = xfs_da_state_alloc();\r\nstate->args = args;\r\nstate->mp = mp;\r\nerror = xfs_da3_node_lookup_int(state, &retval);\r\nif (error)\r\ngoto out;\r\nblk = &state->path.blk[ state->path.active-1 ];\r\nASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\r\nif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\r\ngoto out;\r\n} else if (retval == -EEXIST) {\r\nif (args->flags & ATTR_CREATE)\r\ngoto out;\r\ntrace_xfs_attr_node_replace(args);\r\nargs->op_flags |= XFS_DA_OP_RENAME;\r\nargs->blkno2 = args->blkno;\r\nargs->index2 = args->index;\r\nargs->rmtblkno2 = args->rmtblkno;\r\nargs->rmtblkcnt2 = args->rmtblkcnt;\r\nargs->rmtvaluelen2 = args->rmtvaluelen;\r\nargs->rmtblkno = 0;\r\nargs->rmtblkcnt = 0;\r\nargs->rmtvaluelen = 0;\r\n}\r\nretval = xfs_attr3_leaf_add(blk->bp, state->args);\r\nif (retval == -ENOSPC) {\r\nif (state->path.active == 1) {\r\nxfs_da_state_free(state);\r\nstate = NULL;\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nerror = xfs_attr3_leaf_to_node(args);\r\nif (!error) {\r\nerror = xfs_bmap_finish(&args->trans,\r\nargs->flist,\r\n&committed);\r\n}\r\nif (error) {\r\nASSERT(committed);\r\nargs->trans = NULL;\r\nxfs_bmap_cancel(args->flist);\r\ngoto out;\r\n}\r\nif (committed)\r\nxfs_trans_ijoin(args->trans, dp, 0);\r\nerror = xfs_trans_roll(&args->trans, dp);\r\nif (error)\r\ngoto out;\r\ngoto restart;\r\n}\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nerror = xfs_da3_split(state);\r\nif (!error) {\r\nerror = xfs_bmap_finish(&args->trans, args->flist,\r\n&committed);\r\n}\r\nif (error) {\r\nASSERT(committed);\r\nargs->trans = NULL;\r\nxfs_bmap_cancel(args->flist);\r\ngoto out;\r\n}\r\nif (committed)\r\nxfs_trans_ijoin(args->trans, dp, 0);\r\n} else {\r\nxfs_da3_fixhashpath(state, &state->path);\r\n}\r\nxfs_da_state_free(state);\r\nstate = NULL;\r\nerror = xfs_trans_roll(&args->trans, dp);\r\nif (error)\r\ngoto out;\r\nif (args->rmtblkno > 0) {\r\nerror = xfs_attr_rmtval_set(args);\r\nif (error)\r\nreturn error;\r\n}\r\nif (args->op_flags & XFS_DA_OP_RENAME) {\r\nerror = xfs_attr3_leaf_flipflags(args);\r\nif (error)\r\ngoto out;\r\nargs->index = args->index2;\r\nargs->blkno = args->blkno2;\r\nargs->rmtblkno = args->rmtblkno2;\r\nargs->rmtblkcnt = args->rmtblkcnt2;\r\nargs->rmtvaluelen = args->rmtvaluelen2;\r\nif (args->rmtblkno) {\r\nerror = xfs_attr_rmtval_remove(args);\r\nif (error)\r\nreturn error;\r\n}\r\nargs->flags |= XFS_ATTR_INCOMPLETE;\r\nstate = xfs_da_state_alloc();\r\nstate->args = args;\r\nstate->mp = mp;\r\nstate->inleaf = 0;\r\nerror = xfs_da3_node_lookup_int(state, &retval);\r\nif (error)\r\ngoto out;\r\nblk = &state->path.blk[ state->path.active-1 ];\r\nASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\r\nerror = xfs_attr3_leaf_remove(blk->bp, args);\r\nxfs_da3_fixhashpath(state, &state->path);\r\nif (retval && (state->path.active > 1)) {\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nerror = xfs_da3_join(state);\r\nif (!error) {\r\nerror = xfs_bmap_finish(&args->trans,\r\nargs->flist,\r\n&committed);\r\n}\r\nif (error) {\r\nASSERT(committed);\r\nargs->trans = NULL;\r\nxfs_bmap_cancel(args->flist);\r\ngoto out;\r\n}\r\nif (committed)\r\nxfs_trans_ijoin(args->trans, dp, 0);\r\n}\r\nerror = xfs_trans_roll(&args->trans, dp);\r\nif (error)\r\ngoto out;\r\n} else if (args->rmtblkno > 0) {\r\nerror = xfs_attr3_leaf_clearflag(args);\r\nif (error)\r\ngoto out;\r\n}\r\nretval = error = 0;\r\nout:\r\nif (state)\r\nxfs_da_state_free(state);\r\nif (error)\r\nreturn error;\r\nreturn retval;\r\n}\r\nSTATIC int\r\nxfs_attr_node_removename(xfs_da_args_t *args)\r\n{\r\nxfs_da_state_t *state;\r\nxfs_da_state_blk_t *blk;\r\nxfs_inode_t *dp;\r\nstruct xfs_buf *bp;\r\nint retval, error, committed, forkoff;\r\ntrace_xfs_attr_node_removename(args);\r\ndp = args->dp;\r\nstate = xfs_da_state_alloc();\r\nstate->args = args;\r\nstate->mp = dp->i_mount;\r\nerror = xfs_da3_node_lookup_int(state, &retval);\r\nif (error || (retval != -EEXIST)) {\r\nif (error == 0)\r\nerror = retval;\r\ngoto out;\r\n}\r\nblk = &state->path.blk[ state->path.active-1 ];\r\nASSERT(blk->bp != NULL);\r\nASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\r\nif (args->rmtblkno > 0) {\r\nerror = xfs_attr_fillstate(state);\r\nif (error)\r\ngoto out;\r\nerror = xfs_attr3_leaf_setflag(args);\r\nif (error)\r\ngoto out;\r\nerror = xfs_attr_rmtval_remove(args);\r\nif (error)\r\ngoto out;\r\nerror = xfs_attr_refillstate(state);\r\nif (error)\r\ngoto out;\r\n}\r\nblk = &state->path.blk[ state->path.active-1 ];\r\nASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\r\nretval = xfs_attr3_leaf_remove(blk->bp, args);\r\nxfs_da3_fixhashpath(state, &state->path);\r\nif (retval && (state->path.active > 1)) {\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nerror = xfs_da3_join(state);\r\nif (!error) {\r\nerror = xfs_bmap_finish(&args->trans, args->flist,\r\n&committed);\r\n}\r\nif (error) {\r\nASSERT(committed);\r\nargs->trans = NULL;\r\nxfs_bmap_cancel(args->flist);\r\ngoto out;\r\n}\r\nif (committed)\r\nxfs_trans_ijoin(args->trans, dp, 0);\r\nerror = xfs_trans_roll(&args->trans, dp);\r\nif (error)\r\ngoto out;\r\n}\r\nif (xfs_bmap_one_block(dp, XFS_ATTR_FORK)) {\r\nASSERT(state->path.active == 1);\r\nASSERT(state->path.blk[0].bp);\r\nstate->path.blk[0].bp = NULL;\r\nerror = xfs_attr3_leaf_read(args->trans, args->dp, 0, -1, &bp);\r\nif (error)\r\ngoto out;\r\nif ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {\r\nxfs_bmap_init(args->flist, args->firstblock);\r\nerror = xfs_attr3_leaf_to_shortform(bp, args, forkoff);\r\nif (!error) {\r\nerror = xfs_bmap_finish(&args->trans,\r\nargs->flist,\r\n&committed);\r\n}\r\nif (error) {\r\nASSERT(committed);\r\nargs->trans = NULL;\r\nxfs_bmap_cancel(args->flist);\r\ngoto out;\r\n}\r\nif (committed)\r\nxfs_trans_ijoin(args->trans, dp, 0);\r\n} else\r\nxfs_trans_brelse(args->trans, bp);\r\n}\r\nerror = 0;\r\nout:\r\nxfs_da_state_free(state);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_attr_fillstate(xfs_da_state_t *state)\r\n{\r\nxfs_da_state_path_t *path;\r\nxfs_da_state_blk_t *blk;\r\nint level;\r\ntrace_xfs_attr_fillstate(state->args);\r\npath = &state->path;\r\nASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\r\nfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\r\nif (blk->bp) {\r\nblk->disk_blkno = XFS_BUF_ADDR(blk->bp);\r\nblk->bp = NULL;\r\n} else {\r\nblk->disk_blkno = 0;\r\n}\r\n}\r\npath = &state->altpath;\r\nASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\r\nfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\r\nif (blk->bp) {\r\nblk->disk_blkno = XFS_BUF_ADDR(blk->bp);\r\nblk->bp = NULL;\r\n} else {\r\nblk->disk_blkno = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_attr_refillstate(xfs_da_state_t *state)\r\n{\r\nxfs_da_state_path_t *path;\r\nxfs_da_state_blk_t *blk;\r\nint level, error;\r\ntrace_xfs_attr_refillstate(state->args);\r\npath = &state->path;\r\nASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\r\nfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\r\nif (blk->disk_blkno) {\r\nerror = xfs_da3_node_read(state->args->trans,\r\nstate->args->dp,\r\nblk->blkno, blk->disk_blkno,\r\n&blk->bp, XFS_ATTR_FORK);\r\nif (error)\r\nreturn error;\r\n} else {\r\nblk->bp = NULL;\r\n}\r\n}\r\npath = &state->altpath;\r\nASSERT((path->active >= 0) && (path->active < XFS_DA_NODE_MAXDEPTH));\r\nfor (blk = path->blk, level = 0; level < path->active; blk++, level++) {\r\nif (blk->disk_blkno) {\r\nerror = xfs_da3_node_read(state->args->trans,\r\nstate->args->dp,\r\nblk->blkno, blk->disk_blkno,\r\n&blk->bp, XFS_ATTR_FORK);\r\nif (error)\r\nreturn error;\r\n} else {\r\nblk->bp = NULL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_attr_node_get(xfs_da_args_t *args)\r\n{\r\nxfs_da_state_t *state;\r\nxfs_da_state_blk_t *blk;\r\nint error, retval;\r\nint i;\r\ntrace_xfs_attr_node_get(args);\r\nstate = xfs_da_state_alloc();\r\nstate->args = args;\r\nstate->mp = args->dp->i_mount;\r\nerror = xfs_da3_node_lookup_int(state, &retval);\r\nif (error) {\r\nretval = error;\r\n} else if (retval == -EEXIST) {\r\nblk = &state->path.blk[ state->path.active-1 ];\r\nASSERT(blk->bp != NULL);\r\nASSERT(blk->magic == XFS_ATTR_LEAF_MAGIC);\r\nretval = xfs_attr3_leaf_getvalue(blk->bp, args);\r\nif (!retval && (args->rmtblkno > 0)\r\n&& !(args->flags & ATTR_KERNOVAL)) {\r\nretval = xfs_attr_rmtval_get(args);\r\n}\r\n}\r\nfor (i = 0; i < state->path.active; i++) {\r\nxfs_trans_brelse(args->trans, state->path.blk[i].bp);\r\nstate->path.blk[i].bp = NULL;\r\n}\r\nxfs_da_state_free(state);\r\nreturn retval;\r\n}
