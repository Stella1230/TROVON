static void ps3disk_scatter_gather(struct ps3_storage_device *dev,\r\nstruct request *req, int gather)\r\n{\r\nunsigned int offset = 0;\r\nstruct req_iterator iter;\r\nstruct bio_vec bvec;\r\nunsigned int i = 0;\r\nsize_t size;\r\nvoid *buf;\r\nrq_for_each_segment(bvec, req, iter) {\r\nunsigned long flags;\r\ndev_dbg(&dev->sbd.core, "%s:%u: bio %u: %u sectors from %lu\n",\r\n__func__, __LINE__, i, bio_sectors(iter.bio),\r\niter.bio->bi_iter.bi_sector);\r\nsize = bvec.bv_len;\r\nbuf = bvec_kmap_irq(&bvec, &flags);\r\nif (gather)\r\nmemcpy(dev->bounce_buf+offset, buf, size);\r\nelse\r\nmemcpy(buf, dev->bounce_buf+offset, size);\r\noffset += size;\r\nflush_kernel_dcache_page(bvec.bv_page);\r\nbvec_kunmap_irq(buf, &flags);\r\ni++;\r\n}\r\n}\r\nstatic int ps3disk_submit_request_sg(struct ps3_storage_device *dev,\r\nstruct request *req)\r\n{\r\nstruct ps3disk_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\r\nint write = rq_data_dir(req), res;\r\nconst char *op = write ? "write" : "read";\r\nu64 start_sector, sectors;\r\nunsigned int region_id = dev->regions[dev->region_idx].id;\r\n#ifdef DEBUG\r\nunsigned int n = 0;\r\nstruct bio_vec bv;\r\nstruct req_iterator iter;\r\nrq_for_each_segment(bv, req, iter)\r\nn++;\r\ndev_dbg(&dev->sbd.core,\r\n"%s:%u: %s req has %u bvecs for %u sectors\n",\r\n__func__, __LINE__, op, n, blk_rq_sectors(req));\r\n#endif\r\nstart_sector = blk_rq_pos(req) * priv->blocking_factor;\r\nsectors = blk_rq_sectors(req) * priv->blocking_factor;\r\ndev_dbg(&dev->sbd.core, "%s:%u: %s %llu sectors starting at %llu\n",\r\n__func__, __LINE__, op, sectors, start_sector);\r\nif (write) {\r\nps3disk_scatter_gather(dev, req, 1);\r\nres = lv1_storage_write(dev->sbd.dev_id, region_id,\r\nstart_sector, sectors, 0,\r\ndev->bounce_lpar, &dev->tag);\r\n} else {\r\nres = lv1_storage_read(dev->sbd.dev_id, region_id,\r\nstart_sector, sectors, 0,\r\ndev->bounce_lpar, &dev->tag);\r\n}\r\nif (res) {\r\ndev_err(&dev->sbd.core, "%s:%u: %s failed %d\n", __func__,\r\n__LINE__, op, res);\r\n__blk_end_request_all(req, -EIO);\r\nreturn 0;\r\n}\r\npriv->req = req;\r\nreturn 1;\r\n}\r\nstatic int ps3disk_submit_flush_request(struct ps3_storage_device *dev,\r\nstruct request *req)\r\n{\r\nstruct ps3disk_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\r\nu64 res;\r\ndev_dbg(&dev->sbd.core, "%s:%u: flush request\n", __func__, __LINE__);\r\nres = lv1_storage_send_device_command(dev->sbd.dev_id,\r\nLV1_STORAGE_ATA_HDDOUT, 0, 0, 0,\r\n0, &dev->tag);\r\nif (res) {\r\ndev_err(&dev->sbd.core, "%s:%u: sync cache failed 0x%llx\n",\r\n__func__, __LINE__, res);\r\n__blk_end_request_all(req, -EIO);\r\nreturn 0;\r\n}\r\npriv->req = req;\r\nreturn 1;\r\n}\r\nstatic void ps3disk_do_request(struct ps3_storage_device *dev,\r\nstruct request_queue *q)\r\n{\r\nstruct request *req;\r\ndev_dbg(&dev->sbd.core, "%s:%u\n", __func__, __LINE__);\r\nwhile ((req = blk_fetch_request(q))) {\r\nif (req->cmd_flags & REQ_FLUSH) {\r\nif (ps3disk_submit_flush_request(dev, req))\r\nbreak;\r\n} else if (req->cmd_type == REQ_TYPE_FS) {\r\nif (ps3disk_submit_request_sg(dev, req))\r\nbreak;\r\n} else {\r\nblk_dump_rq_flags(req, DEVICE_NAME " bad request");\r\n__blk_end_request_all(req, -EIO);\r\ncontinue;\r\n}\r\n}\r\n}\r\nstatic void ps3disk_request(struct request_queue *q)\r\n{\r\nstruct ps3_storage_device *dev = q->queuedata;\r\nstruct ps3disk_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\r\nif (priv->req) {\r\ndev_dbg(&dev->sbd.core, "%s:%u busy\n", __func__, __LINE__);\r\nreturn;\r\n}\r\nps3disk_do_request(dev, q);\r\n}\r\nstatic irqreturn_t ps3disk_interrupt(int irq, void *data)\r\n{\r\nstruct ps3_storage_device *dev = data;\r\nstruct ps3disk_private *priv;\r\nstruct request *req;\r\nint res, read, error;\r\nu64 tag, status;\r\nconst char *op;\r\nres = lv1_storage_get_async_status(dev->sbd.dev_id, &tag, &status);\r\nif (tag != dev->tag)\r\ndev_err(&dev->sbd.core,\r\n"%s:%u: tag mismatch, got %llx, expected %llx\n",\r\n__func__, __LINE__, tag, dev->tag);\r\nif (res) {\r\ndev_err(&dev->sbd.core, "%s:%u: res=%d status=0x%llx\n",\r\n__func__, __LINE__, res, status);\r\nreturn IRQ_HANDLED;\r\n}\r\npriv = ps3_system_bus_get_drvdata(&dev->sbd);\r\nreq = priv->req;\r\nif (!req) {\r\ndev_dbg(&dev->sbd.core,\r\n"%s:%u non-block layer request completed\n", __func__,\r\n__LINE__);\r\ndev->lv1_status = status;\r\ncomplete(&dev->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (req->cmd_flags & REQ_FLUSH) {\r\nread = 0;\r\nop = "flush";\r\n} else {\r\nread = !rq_data_dir(req);\r\nop = read ? "read" : "write";\r\n}\r\nif (status) {\r\ndev_dbg(&dev->sbd.core, "%s:%u: %s failed 0x%llx\n", __func__,\r\n__LINE__, op, status);\r\nerror = -EIO;\r\n} else {\r\ndev_dbg(&dev->sbd.core, "%s:%u: %s completed\n", __func__,\r\n__LINE__, op);\r\nerror = 0;\r\nif (read)\r\nps3disk_scatter_gather(dev, req, 0);\r\n}\r\nspin_lock(&priv->lock);\r\n__blk_end_request_all(req, error);\r\npriv->req = NULL;\r\nps3disk_do_request(dev, priv->queue);\r\nspin_unlock(&priv->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ps3disk_sync_cache(struct ps3_storage_device *dev)\r\n{\r\nu64 res;\r\ndev_dbg(&dev->sbd.core, "%s:%u: sync cache\n", __func__, __LINE__);\r\nres = ps3stor_send_command(dev, LV1_STORAGE_ATA_HDDOUT, 0, 0, 0, 0);\r\nif (res) {\r\ndev_err(&dev->sbd.core, "%s:%u: sync cache failed 0x%llx\n",\r\n__func__, __LINE__, res);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void swap_buf_le16(u16 *buf, unsigned int buf_words)\r\n{\r\n#ifdef __BIG_ENDIAN\r\nunsigned int i;\r\nfor (i = 0; i < buf_words; i++)\r\nbuf[i] = le16_to_cpu(buf[i]);\r\n#endif\r\n}\r\nstatic u64 ata_id_n_sectors(const u16 *id)\r\n{\r\nif (ata_id_has_lba(id)) {\r\nif (ata_id_has_lba48(id))\r\nreturn ata_id_u64(id, 100);\r\nelse\r\nreturn ata_id_u32(id, 60);\r\n} else {\r\nif (ata_id_current_chs_valid(id))\r\nreturn ata_id_u32(id, 57);\r\nelse\r\nreturn id[1] * id[3] * id[6];\r\n}\r\n}\r\nstatic void ata_id_string(const u16 *id, unsigned char *s, unsigned int ofs,\r\nunsigned int len)\r\n{\r\nunsigned int c;\r\nwhile (len > 0) {\r\nc = id[ofs] >> 8;\r\n*s = c;\r\ns++;\r\nc = id[ofs] & 0xff;\r\n*s = c;\r\ns++;\r\nofs++;\r\nlen -= 2;\r\n}\r\n}\r\nstatic void ata_id_c_string(const u16 *id, unsigned char *s, unsigned int ofs,\r\nunsigned int len)\r\n{\r\nunsigned char *p;\r\nWARN_ON(!(len & 1));\r\nata_id_string(id, s, ofs, len - 1);\r\np = s + strnlen(s, len - 1);\r\nwhile (p > s && p[-1] == ' ')\r\np--;\r\n*p = '\0';\r\n}\r\nstatic int ps3disk_identify(struct ps3_storage_device *dev)\r\n{\r\nstruct ps3disk_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\r\nstruct lv1_ata_cmnd_block ata_cmnd;\r\nu16 *id = dev->bounce_buf;\r\nu64 res;\r\ndev_dbg(&dev->sbd.core, "%s:%u: identify disk\n", __func__, __LINE__);\r\nmemset(&ata_cmnd, 0, sizeof(struct lv1_ata_cmnd_block));\r\nata_cmnd.command = ATA_CMD_ID_ATA;\r\nata_cmnd.sector_count = 1;\r\nata_cmnd.size = ata_cmnd.arglen = ATA_ID_WORDS * 2;\r\nata_cmnd.buffer = dev->bounce_lpar;\r\nata_cmnd.proto = PIO_DATA_IN_PROTO;\r\nata_cmnd.in_out = DIR_READ;\r\nres = ps3stor_send_command(dev, LV1_STORAGE_SEND_ATA_COMMAND,\r\nps3_mm_phys_to_lpar(__pa(&ata_cmnd)),\r\nsizeof(ata_cmnd), ata_cmnd.buffer,\r\nata_cmnd.arglen);\r\nif (res) {\r\ndev_err(&dev->sbd.core, "%s:%u: identify disk failed 0x%llx\n",\r\n__func__, __LINE__, res);\r\nreturn -EIO;\r\n}\r\nswap_buf_le16(id, ATA_ID_WORDS);\r\npriv->raw_capacity = ata_id_n_sectors(id);\r\nata_id_c_string(id, priv->model, ATA_ID_PROD, sizeof(priv->model));\r\nreturn 0;\r\n}\r\nstatic int ps3disk_probe(struct ps3_system_bus_device *_dev)\r\n{\r\nstruct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);\r\nstruct ps3disk_private *priv;\r\nint error;\r\nunsigned int devidx;\r\nstruct request_queue *queue;\r\nstruct gendisk *gendisk;\r\nif (dev->blk_size < 512) {\r\ndev_err(&dev->sbd.core,\r\n"%s:%u: cannot handle block size %llu\n", __func__,\r\n__LINE__, dev->blk_size);\r\nreturn -EINVAL;\r\n}\r\nBUILD_BUG_ON(PS3DISK_MAX_DISKS > BITS_PER_LONG);\r\nmutex_lock(&ps3disk_mask_mutex);\r\ndevidx = find_first_zero_bit(&ps3disk_mask, PS3DISK_MAX_DISKS);\r\nif (devidx >= PS3DISK_MAX_DISKS) {\r\ndev_err(&dev->sbd.core, "%s:%u: Too many disks\n", __func__,\r\n__LINE__);\r\nmutex_unlock(&ps3disk_mask_mutex);\r\nreturn -ENOSPC;\r\n}\r\n__set_bit(devidx, &ps3disk_mask);\r\nmutex_unlock(&ps3disk_mask_mutex);\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\nerror = -ENOMEM;\r\ngoto fail;\r\n}\r\nps3_system_bus_set_drvdata(_dev, priv);\r\nspin_lock_init(&priv->lock);\r\ndev->bounce_size = BOUNCE_SIZE;\r\ndev->bounce_buf = kmalloc(BOUNCE_SIZE, GFP_DMA);\r\nif (!dev->bounce_buf) {\r\nerror = -ENOMEM;\r\ngoto fail_free_priv;\r\n}\r\nerror = ps3stor_setup(dev, ps3disk_interrupt);\r\nif (error)\r\ngoto fail_free_bounce;\r\nps3disk_identify(dev);\r\nqueue = blk_init_queue(ps3disk_request, &priv->lock);\r\nif (!queue) {\r\ndev_err(&dev->sbd.core, "%s:%u: blk_init_queue failed\n",\r\n__func__, __LINE__);\r\nerror = -ENOMEM;\r\ngoto fail_teardown;\r\n}\r\npriv->queue = queue;\r\nqueue->queuedata = dev;\r\nblk_queue_bounce_limit(queue, BLK_BOUNCE_HIGH);\r\nblk_queue_max_hw_sectors(queue, dev->bounce_size >> 9);\r\nblk_queue_segment_boundary(queue, -1UL);\r\nblk_queue_dma_alignment(queue, dev->blk_size-1);\r\nblk_queue_logical_block_size(queue, dev->blk_size);\r\nblk_queue_flush(queue, REQ_FLUSH);\r\nblk_queue_max_segments(queue, -1);\r\nblk_queue_max_segment_size(queue, dev->bounce_size);\r\ngendisk = alloc_disk(PS3DISK_MINORS);\r\nif (!gendisk) {\r\ndev_err(&dev->sbd.core, "%s:%u: alloc_disk failed\n", __func__,\r\n__LINE__);\r\nerror = -ENOMEM;\r\ngoto fail_cleanup_queue;\r\n}\r\npriv->gendisk = gendisk;\r\ngendisk->major = ps3disk_major;\r\ngendisk->first_minor = devidx * PS3DISK_MINORS;\r\ngendisk->fops = &ps3disk_fops;\r\ngendisk->queue = queue;\r\ngendisk->private_data = dev;\r\ngendisk->driverfs_dev = &dev->sbd.core;\r\nsnprintf(gendisk->disk_name, sizeof(gendisk->disk_name), PS3DISK_NAME,\r\ndevidx+'a');\r\npriv->blocking_factor = dev->blk_size >> 9;\r\nset_capacity(gendisk,\r\ndev->regions[dev->region_idx].size*priv->blocking_factor);\r\ndev_info(&dev->sbd.core,\r\n"%s is a %s (%llu MiB total, %lu MiB for OtherOS)\n",\r\ngendisk->disk_name, priv->model, priv->raw_capacity >> 11,\r\nget_capacity(gendisk) >> 11);\r\nadd_disk(gendisk);\r\nreturn 0;\r\nfail_cleanup_queue:\r\nblk_cleanup_queue(queue);\r\nfail_teardown:\r\nps3stor_teardown(dev);\r\nfail_free_bounce:\r\nkfree(dev->bounce_buf);\r\nfail_free_priv:\r\nkfree(priv);\r\nps3_system_bus_set_drvdata(_dev, NULL);\r\nfail:\r\nmutex_lock(&ps3disk_mask_mutex);\r\n__clear_bit(devidx, &ps3disk_mask);\r\nmutex_unlock(&ps3disk_mask_mutex);\r\nreturn error;\r\n}\r\nstatic int ps3disk_remove(struct ps3_system_bus_device *_dev)\r\n{\r\nstruct ps3_storage_device *dev = to_ps3_storage_device(&_dev->core);\r\nstruct ps3disk_private *priv = ps3_system_bus_get_drvdata(&dev->sbd);\r\nmutex_lock(&ps3disk_mask_mutex);\r\n__clear_bit(MINOR(disk_devt(priv->gendisk)) / PS3DISK_MINORS,\r\n&ps3disk_mask);\r\nmutex_unlock(&ps3disk_mask_mutex);\r\ndel_gendisk(priv->gendisk);\r\nblk_cleanup_queue(priv->queue);\r\nput_disk(priv->gendisk);\r\ndev_notice(&dev->sbd.core, "Synchronizing disk cache\n");\r\nps3disk_sync_cache(dev);\r\nps3stor_teardown(dev);\r\nkfree(dev->bounce_buf);\r\nkfree(priv);\r\nps3_system_bus_set_drvdata(_dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init ps3disk_init(void)\r\n{\r\nint error;\r\nif (!firmware_has_feature(FW_FEATURE_PS3_LV1))\r\nreturn -ENODEV;\r\nerror = register_blkdev(0, DEVICE_NAME);\r\nif (error <= 0) {\r\nprintk(KERN_ERR "%s:%u: register_blkdev failed %d\n", __func__,\r\n__LINE__, error);\r\nreturn error;\r\n}\r\nps3disk_major = error;\r\npr_info("%s:%u: registered block device major %d\n", __func__,\r\n__LINE__, ps3disk_major);\r\nerror = ps3_system_bus_driver_register(&ps3disk);\r\nif (error)\r\nunregister_blkdev(ps3disk_major, DEVICE_NAME);\r\nreturn error;\r\n}\r\nstatic void __exit ps3disk_exit(void)\r\n{\r\nps3_system_bus_driver_unregister(&ps3disk);\r\nunregister_blkdev(ps3disk_major, DEVICE_NAME);\r\n}
