int handle_perf_interrupt(struct pt_regs *regs, int fault)\r\n{\r\nint retval;\r\nif (!perf_irq)\r\npanic("Unexpected PERF_COUNT interrupt %d\n", fault);\r\nnmi_enter();\r\nretval = perf_irq(regs, fault);\r\nnmi_exit();\r\nreturn retval;\r\n}\r\nperf_irq_t reserve_pmc_hardware(perf_irq_t new_perf_irq)\r\n{\r\nreturn cmpxchg(&perf_irq, NULL, new_perf_irq);\r\n}\r\nvoid release_pmc_hardware(void)\r\n{\r\nperf_irq = NULL;\r\n}\r\nunsigned long\r\npmc_get_overflow(void)\r\n{\r\nunsigned long status;\r\nstatus = __insn_mfspr(SPR_PERF_COUNT_STS);\r\nstatus |= __insn_mfspr(SPR_AUX_PERF_COUNT_STS) << TILE_BASE_COUNTERS;\r\nreturn status;\r\n}\r\nvoid\r\npmc_ack_overflow(unsigned long status)\r\n{\r\n__insn_mtspr(SPR_PERF_COUNT_STS, status);\r\n__insn_mtspr(SPR_AUX_PERF_COUNT_STS, status >> TILE_BASE_COUNTERS);\r\n}\r\nstatic inline unsigned long long pmc_mask(void)\r\n{\r\nunsigned long long mask = 1ULL << INT_PERF_COUNT;\r\nmask |= 1ULL << INT_AUX_PERF_COUNT;\r\nreturn mask;\r\n}\r\nvoid unmask_pmc_interrupts(void)\r\n{\r\ninterrupt_mask_reset_mask(pmc_mask());\r\n}\r\nvoid mask_pmc_interrupts(void)\r\n{\r\ninterrupt_mask_set_mask(pmc_mask());\r\n}
