static void s390_handle_damage(char *msg)\r\n{\r\nsmp_send_stop();\r\ndisabled_wait((unsigned long) __builtin_return_address(0));\r\nwhile (1);\r\n}\r\nvoid s390_handle_mcck(void)\r\n{\r\nunsigned long flags;\r\nstruct mcck_struct mcck;\r\nlocal_irq_save(flags);\r\nlocal_mcck_disable();\r\nmcck = *this_cpu_ptr(&cpu_mcck);\r\nmemset(this_cpu_ptr(&cpu_mcck), 0, sizeof(mcck));\r\nclear_cpu_flag(CIF_MCCK_PENDING);\r\nlocal_mcck_enable();\r\nlocal_irq_restore(flags);\r\nif (mcck.channel_report)\r\ncrw_handle_channel_report();\r\nif (mcck.warning) {\r\nstatic int mchchk_wng_posted = 0;\r\n__ctl_clear_bit(14, 24);\r\nif (xchg(&mchchk_wng_posted, 1) == 0)\r\nkill_cad_pid(SIGPWR, 1);\r\n}\r\nif (mcck.kill_task) {\r\nlocal_irq_enable();\r\nprintk(KERN_EMERG "mcck: Terminating task because of machine "\r\n"malfunction (code 0x%016llx).\n", mcck.mcck_code);\r\nprintk(KERN_EMERG "mcck: task: %s, pid: %d.\n",\r\ncurrent->comm, current->pid);\r\ndo_exit(SIGSEGV);\r\n}\r\n}\r\nstatic int notrace s390_revalidate_registers(struct mci *mci)\r\n{\r\nint kill_task;\r\nu64 zero;\r\nvoid *fpt_save_area, *fpt_creg_save_area;\r\nkill_task = 0;\r\nzero = 0;\r\nif (!mci->gr) {\r\nkill_task = 1;\r\n}\r\nif (!mci->fp) {\r\nkill_task = 1;\r\n}\r\n#ifndef CONFIG_64BIT\r\nasm volatile(\r\n" ld 0,0(%0)\n"\r\n" ld 2,8(%0)\n"\r\n" ld 4,16(%0)\n"\r\n" ld 6,24(%0)"\r\n: : "a" (&S390_lowcore.floating_pt_save_area));\r\n#endif\r\nif (MACHINE_HAS_IEEE) {\r\n#ifdef CONFIG_64BIT\r\nfpt_save_area = &S390_lowcore.floating_pt_save_area;\r\nfpt_creg_save_area = &S390_lowcore.fpt_creg_save_area;\r\n#else\r\nfpt_save_area = (void *) S390_lowcore.extended_save_area_addr;\r\nfpt_creg_save_area = fpt_save_area + 128;\r\n#endif\r\nif (!mci->fc) {\r\nasm volatile("lfpc 0(%0)" : : "a" (&zero), "m" (zero));\r\nkill_task = 1;\r\n} else\r\nasm volatile("lfpc 0(%0)" : : "a" (fpt_creg_save_area));\r\nasm volatile(\r\n" ld 0,0(%0)\n"\r\n" ld 1,8(%0)\n"\r\n" ld 2,16(%0)\n"\r\n" ld 3,24(%0)\n"\r\n" ld 4,32(%0)\n"\r\n" ld 5,40(%0)\n"\r\n" ld 6,48(%0)\n"\r\n" ld 7,56(%0)\n"\r\n" ld 8,64(%0)\n"\r\n" ld 9,72(%0)\n"\r\n" ld 10,80(%0)\n"\r\n" ld 11,88(%0)\n"\r\n" ld 12,96(%0)\n"\r\n" ld 13,104(%0)\n"\r\n" ld 14,112(%0)\n"\r\n" ld 15,120(%0)\n"\r\n: : "a" (fpt_save_area));\r\n}\r\n#ifdef CONFIG_64BIT\r\nif (MACHINE_HAS_VX && current->thread.vxrs) {\r\nif (!mci->vr) {\r\nkill_task = 1;\r\n}\r\nrestore_vx_regs((__vector128 *)\r\nS390_lowcore.vector_save_area_addr);\r\n}\r\n#endif\r\nasm volatile(\r\n" lam 0,15,0(%0)"\r\n: : "a" (&S390_lowcore.access_regs_save_area));\r\nif (!mci->ar) {\r\nkill_task = 1;\r\n}\r\nif (!mci->cr) {\r\ns390_handle_damage("invalid control registers.");\r\n} else {\r\n#ifdef CONFIG_64BIT\r\nasm volatile(\r\n" lctlg 0,15,0(%0)"\r\n: : "a" (&S390_lowcore.cregs_save_area));\r\n#else\r\nasm volatile(\r\n" lctl 0,15,0(%0)"\r\n: : "a" (&S390_lowcore.cregs_save_area));\r\n#endif\r\n}\r\n#ifdef CONFIG_64BIT\r\nif (!mci->pr)\r\nasm volatile(\r\n" sr 0,0\n"\r\n" sckpf"\r\n: : : "0", "cc");\r\nelse\r\nasm volatile(\r\n" l 0,0(%0)\n"\r\n" sckpf"\r\n: : "a" (&S390_lowcore.tod_progreg_save_area)\r\n: "0", "cc");\r\n#endif\r\nset_clock_comparator(S390_lowcore.clock_comparator);\r\nif (!mci->wp)\r\ns390_handle_damage("old psw invalid.");\r\nif (!mci->ms || !mci->pm || !mci->ia)\r\nkill_task = 1;\r\nreturn kill_task;\r\n}\r\nvoid notrace s390_do_machine_check(struct pt_regs *regs)\r\n{\r\nstatic int ipd_count;\r\nstatic DEFINE_SPINLOCK(ipd_lock);\r\nstatic unsigned long long last_ipd;\r\nstruct mcck_struct *mcck;\r\nunsigned long long tmp;\r\nstruct mci *mci;\r\nint umode;\r\nnmi_enter();\r\ninc_irq_stat(NMI_NMI);\r\nmci = (struct mci *) &S390_lowcore.mcck_interruption_code;\r\nmcck = this_cpu_ptr(&cpu_mcck);\r\numode = user_mode(regs);\r\nif (mci->sd) {\r\ns390_handle_damage("received system damage machine check.");\r\n}\r\nif (mci->pd) {\r\nif (mci->b) {\r\nu64 z_mcic, o_mcic, t_mcic;\r\n#ifdef CONFIG_64BIT\r\nz_mcic = (1ULL<<63 | 1ULL<<59 | 1ULL<<29);\r\no_mcic = (1ULL<<43 | 1ULL<<42 | 1ULL<<41 | 1ULL<<40 |\r\n1ULL<<36 | 1ULL<<35 | 1ULL<<34 | 1ULL<<32 |\r\n1ULL<<30 | 1ULL<<21 | 1ULL<<20 | 1ULL<<17 |\r\n1ULL<<16);\r\n#else\r\nz_mcic = (1ULL<<63 | 1ULL<<59 | 1ULL<<57 | 1ULL<<50 |\r\n1ULL<<29);\r\no_mcic = (1ULL<<43 | 1ULL<<42 | 1ULL<<41 | 1ULL<<40 |\r\n1ULL<<36 | 1ULL<<35 | 1ULL<<34 | 1ULL<<32 |\r\n1ULL<<30 | 1ULL<<20 | 1ULL<<17 | 1ULL<<16);\r\n#endif\r\nt_mcic = *(u64 *)mci;\r\nif (((t_mcic & z_mcic) != 0) ||\r\n((t_mcic & o_mcic) != o_mcic)) {\r\ns390_handle_damage("processing backup machine "\r\n"check with damage.");\r\n}\r\nspin_lock(&ipd_lock);\r\ntmp = get_tod_clock();\r\nif (((tmp - last_ipd) >> 12) < MAX_IPD_TIME)\r\nipd_count++;\r\nelse\r\nipd_count = 1;\r\nlast_ipd = tmp;\r\nif (ipd_count == MAX_IPD_COUNT)\r\ns390_handle_damage("too many ipd retries.");\r\nspin_unlock(&ipd_lock);\r\n} else {\r\ns390_handle_damage("received instruction processing "\r\n"damage machine check.");\r\n}\r\n}\r\nif (s390_revalidate_registers(mci)) {\r\nif (umode) {\r\nmcck->kill_task = 1;\r\nmcck->mcck_code = *(unsigned long long *) mci;\r\nset_cpu_flag(CIF_MCCK_PENDING);\r\n} else {\r\ns390_handle_damage("unable to revalidate registers.");\r\n}\r\n}\r\nif (mci->cd) {\r\ns390_handle_damage("TOD clock damaged");\r\n}\r\nif (mci->ed && mci->ec) {\r\nif (S390_lowcore.external_damage_code & (1U << ED_ETR_SYNC))\r\netr_sync_check();\r\nif (S390_lowcore.external_damage_code & (1U << ED_ETR_SWITCH))\r\netr_switch_to_local();\r\nif (S390_lowcore.external_damage_code & (1U << ED_STP_SYNC))\r\nstp_sync_check();\r\nif (S390_lowcore.external_damage_code & (1U << ED_STP_ISLAND))\r\nstp_island_check();\r\n}\r\nif (mci->se)\r\ns390_handle_damage("received storage error uncorrected "\r\n"machine check.");\r\nif (mci->ke)\r\ns390_handle_damage("received storage key-error uncorrected "\r\n"machine check.");\r\nif (mci->ds && mci->fa)\r\ns390_handle_damage("received storage degradation machine "\r\n"check.");\r\nif (mci->cp) {\r\nmcck->channel_report = 1;\r\nset_cpu_flag(CIF_MCCK_PENDING);\r\n}\r\nif (mci->w) {\r\nmcck->warning = 1;\r\nset_cpu_flag(CIF_MCCK_PENDING);\r\n}\r\nnmi_exit();\r\n}\r\nstatic int __init machine_check_init(void)\r\n{\r\nctl_set_bit(14, 25);\r\nctl_set_bit(14, 27);\r\nctl_set_bit(14, 24);\r\nreturn 0;\r\n}
