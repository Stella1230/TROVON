static unsigned long pllc01_recalc(struct clk *clk)\r\n{\r\nunsigned long mult = 1;\r\nif (__raw_readl(PLLC01CR) & (1 << 14))\r\nmult = ((__raw_readl(clk->enable_reg) >> 24) & 0x7f) + 1;\r\nreturn clk->parent->rate * mult;\r\n}\r\nstatic int usb24s_enable(struct clk *clk)\r\n{\r\n__raw_writel(__raw_readl(USBCKCR) & ~(1 << 8), USBCKCR);\r\nreturn 0;\r\n}\r\nstatic void usb24s_disable(struct clk *clk)\r\n{\r\n__raw_writel(__raw_readl(USBCKCR) | (1 << 8), USBCKCR);\r\n}\r\nstatic int usb24s_set_parent(struct clk *clk, struct clk *parent)\r\n{\r\nint i, ret;\r\nu32 val;\r\nif (!clk->parent_table || !clk->parent_num)\r\nreturn -EINVAL;\r\nfor (i = 0; i < clk->parent_num; i++)\r\nif (clk->parent_table[i] == parent)\r\nbreak;\r\nif (i == clk->parent_num)\r\nreturn -ENODEV;\r\nret = clk_reparent(clk, parent);\r\nif (ret < 0)\r\nreturn ret;\r\nval = __raw_readl(USBCKCR);\r\nval &= ~(1 << 7);\r\nval |= i << 7;\r\n__raw_writel(val, USBCKCR);\r\nreturn 0;\r\n}\r\nstatic unsigned long usb24_recalc(struct clk *clk)\r\n{\r\nreturn clk->parent->rate /\r\n((__raw_readl(USBCKCR) & (1 << 6)) ? 1 : 2);\r\n}\r\nstatic int usb24_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nu32 val;\r\nval = __raw_readl(USBCKCR);\r\nval &= ~(1 << 6);\r\nval |= (rate > (clk->parent->rate / 4) * 3) << 6;\r\n__raw_writel(val, USBCKCR);\r\nreturn 0;\r\n}\r\nstatic void div4_kick(struct clk *clk)\r\n{\r\nunsigned long value;\r\nvalue = __raw_readl(FRQCRB);\r\nvalue |= (1 << 31);\r\n__raw_writel(value, FRQCRB);\r\n}\r\nstatic unsigned long hdmi12_recalc(struct clk *clk)\r\n{\r\nu32 val = __raw_readl(HDMICKCR);\r\nint shift = (int)clk->priv;\r\nval >>= shift;\r\nval &= 0x3;\r\nreturn clk->parent->rate / (1 << val);\r\n}\r\nstatic int hdmi12_set_rate(struct clk *clk, unsigned long rate)\r\n{\r\nu32 val, mask;\r\nint i, shift;\r\nfor (i = 0; i < 3; i++)\r\nif (rate == clk->parent->rate / (1 << i))\r\ngoto find;\r\nreturn -ENODEV;\r\nfind:\r\nshift = (int)clk->priv;\r\nval = __raw_readl(HDMICKCR);\r\nmask = ~(0x3 << shift);\r\nval = (val & mask) | i << shift;\r\n__raw_writel(val, HDMICKCR);\r\nreturn 0;\r\n}\r\nvoid __init r8a7740_clock_init(u8 md_ck)\r\n{\r\nint k, ret = 0;\r\nif (md_ck & MD_CK1)\r\nsystem_clk.parent = &extal1_div2_clk;\r\nelse\r\nsystem_clk.parent = &extal1_clk;\r\nswitch (md_ck & (MD_CK2 | MD_CK1)) {\r\ncase MD_CK2 | MD_CK1:\r\nr_clk.parent = &extal1_div2048_clk;\r\nbreak;\r\ncase MD_CK2:\r\nr_clk.parent = &extal1_div1024_clk;\r\nbreak;\r\ncase MD_CK1:\r\ndefault:\r\nr_clk.parent = &extalr_clk;\r\nbreak;\r\n}\r\nfor (k = 0; !ret && (k < ARRAY_SIZE(main_clks)); k++)\r\nret = clk_register(main_clks[k]);\r\nif (!ret)\r\nret = sh_clk_div4_register(div4_clks, DIV4_NR, &div4_table);\r\nif (!ret)\r\nret = sh_clk_div6_register(div6_clks, DIV6_NR);\r\nif (!ret)\r\nret = sh_clk_div6_reparent_register(div6_reparent_clks,\r\nDIV6_REPARENT_NR);\r\nif (!ret)\r\nret = sh_clk_mstp_register(mstp_clks, MSTP_NR);\r\nfor (k = 0; !ret && (k < ARRAY_SIZE(late_main_clks)); k++)\r\nret = clk_register(late_main_clks[k]);\r\nif (!ret)\r\nret = sh_clk_fsidiv_register(fsidivs, FSIDIV_REPARENT_NR);\r\nclkdev_add_table(lookups, ARRAY_SIZE(lookups));\r\nif (!ret)\r\nshmobile_clk_init();\r\nelse\r\npanic("failed to setup r8a7740 clocks\n");\r\n}
