static void gpmc_write_reg(int idx, u32 val)\r\n{\r\nwritel_relaxed(val, gpmc_base + idx);\r\n}\r\nstatic u32 gpmc_read_reg(int idx)\r\n{\r\nreturn readl_relaxed(gpmc_base + idx);\r\n}\r\nvoid gpmc_cs_write_reg(int cs, int idx, u32 val)\r\n{\r\nvoid __iomem *reg_addr;\r\nreg_addr = gpmc_base + GPMC_CS0_OFFSET + (cs * GPMC_CS_SIZE) + idx;\r\nwritel_relaxed(val, reg_addr);\r\n}\r\nstatic u32 gpmc_cs_read_reg(int cs, int idx)\r\n{\r\nvoid __iomem *reg_addr;\r\nreg_addr = gpmc_base + GPMC_CS0_OFFSET + (cs * GPMC_CS_SIZE) + idx;\r\nreturn readl_relaxed(reg_addr);\r\n}\r\nstatic unsigned long gpmc_get_fclk_period(void)\r\n{\r\nunsigned long rate = clk_get_rate(gpmc_l3_clk);\r\nrate /= 1000;\r\nrate = 1000000000 / rate;\r\nreturn rate;\r\n}\r\nstatic unsigned int gpmc_ns_to_ticks(unsigned int time_ns)\r\n{\r\nunsigned long tick_ps;\r\ntick_ps = gpmc_get_fclk_period();\r\nreturn (time_ns * 1000 + tick_ps - 1) / tick_ps;\r\n}\r\nstatic unsigned int gpmc_ps_to_ticks(unsigned int time_ps)\r\n{\r\nunsigned long tick_ps;\r\ntick_ps = gpmc_get_fclk_period();\r\nreturn (time_ps + tick_ps - 1) / tick_ps;\r\n}\r\nunsigned int gpmc_ticks_to_ns(unsigned int ticks)\r\n{\r\nreturn ticks * gpmc_get_fclk_period() / 1000;\r\n}\r\nstatic unsigned int gpmc_ticks_to_ps(unsigned int ticks)\r\n{\r\nreturn ticks * gpmc_get_fclk_period();\r\n}\r\nstatic unsigned int gpmc_round_ps_to_ticks(unsigned int time_ps)\r\n{\r\nunsigned long ticks = gpmc_ps_to_ticks(time_ps);\r\nreturn ticks * gpmc_get_fclk_period();\r\n}\r\nstatic inline void gpmc_cs_modify_reg(int cs, int reg, u32 mask, bool value)\r\n{\r\nu32 l;\r\nl = gpmc_cs_read_reg(cs, reg);\r\nif (value)\r\nl |= mask;\r\nelse\r\nl &= ~mask;\r\ngpmc_cs_write_reg(cs, reg, l);\r\n}\r\nstatic void gpmc_cs_bool_timings(int cs, const struct gpmc_bool_timings *p)\r\n{\r\ngpmc_cs_modify_reg(cs, GPMC_CS_CONFIG1,\r\nGPMC_CONFIG1_TIME_PARA_GRAN,\r\np->time_para_granularity);\r\ngpmc_cs_modify_reg(cs, GPMC_CS_CONFIG2,\r\nGPMC_CONFIG2_CSEXTRADELAY, p->cs_extra_delay);\r\ngpmc_cs_modify_reg(cs, GPMC_CS_CONFIG3,\r\nGPMC_CONFIG3_ADVEXTRADELAY, p->adv_extra_delay);\r\ngpmc_cs_modify_reg(cs, GPMC_CS_CONFIG4,\r\nGPMC_CONFIG4_OEEXTRADELAY, p->oe_extra_delay);\r\ngpmc_cs_modify_reg(cs, GPMC_CS_CONFIG4,\r\nGPMC_CONFIG4_OEEXTRADELAY, p->we_extra_delay);\r\ngpmc_cs_modify_reg(cs, GPMC_CS_CONFIG6,\r\nGPMC_CONFIG6_CYCLE2CYCLESAMECSEN,\r\np->cycle2cyclesamecsen);\r\ngpmc_cs_modify_reg(cs, GPMC_CS_CONFIG6,\r\nGPMC_CONFIG6_CYCLE2CYCLEDIFFCSEN,\r\np->cycle2cyclediffcsen);\r\n}\r\nstatic int get_gpmc_timing_reg(int cs, int reg, int st_bit, int end_bit,\r\nbool raw, bool noval, int shift,\r\nconst char *name)\r\n{\r\nu32 l;\r\nint nr_bits, max_value, mask;\r\nl = gpmc_cs_read_reg(cs, reg);\r\nnr_bits = end_bit - st_bit + 1;\r\nmax_value = (1 << nr_bits) - 1;\r\nmask = max_value << st_bit;\r\nl = (l & mask) >> st_bit;\r\nif (shift)\r\nl = (shift << l);\r\nif (noval && (l == 0))\r\nreturn 0;\r\nif (!raw) {\r\nunsigned int time_ns_min, time_ns, time_ns_max;\r\ntime_ns_min = gpmc_ticks_to_ns(l ? l - 1 : 0);\r\ntime_ns = gpmc_ticks_to_ns(l);\r\ntime_ns_max = gpmc_ticks_to_ns(l + 1 > max_value ?\r\nmax_value : l + 1);\r\npr_info("gpmc,%s = <%u> (%u - %u ns, %i ticks)\n",\r\nname, time_ns, time_ns_min, time_ns_max, l);\r\n} else {\r\npr_info("gpmc,%s = <%u>\n", name, l);\r\n}\r\nreturn l;\r\n}\r\nstatic void gpmc_show_regs(int cs, const char *desc)\r\n{\r\npr_info("gpmc cs%i %s:\n", cs, desc);\r\nGPMC_PRINT_CONFIG(cs, GPMC_CS_CONFIG1);\r\nGPMC_PRINT_CONFIG(cs, GPMC_CS_CONFIG2);\r\nGPMC_PRINT_CONFIG(cs, GPMC_CS_CONFIG3);\r\nGPMC_PRINT_CONFIG(cs, GPMC_CS_CONFIG4);\r\nGPMC_PRINT_CONFIG(cs, GPMC_CS_CONFIG5);\r\nGPMC_PRINT_CONFIG(cs, GPMC_CS_CONFIG6);\r\n}\r\nstatic void gpmc_cs_show_timings(int cs, const char *desc)\r\n{\r\ngpmc_show_regs(cs, desc);\r\npr_info("gpmc cs%i access configuration:\n", cs);\r\nGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG1, 4, 4, "time-para-granularity");\r\nGPMC_GET_RAW(GPMC_CS_CONFIG1, 8, 9, "mux-add-data");\r\nGPMC_GET_RAW(GPMC_CS_CONFIG1, 12, 13, "device-width");\r\nGPMC_GET_RAW(GPMC_CS_CONFIG1, 16, 17, "wait-pin");\r\nGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG1, 21, 21, "wait-on-write");\r\nGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG1, 22, 22, "wait-on-read");\r\nGPMC_GET_RAW_SHIFT(GPMC_CS_CONFIG1, 23, 24, 4, "burst-length");\r\nGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG1, 27, 27, "sync-write");\r\nGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG1, 28, 28, "burst-write");\r\nGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG1, 29, 29, "gpmc,sync-read");\r\nGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG1, 30, 30, "burst-read");\r\nGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG1, 31, 31, "burst-wrap");\r\nGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG2, 7, 7, "cs-extra-delay");\r\nGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG3, 7, 7, "adv-extra-delay");\r\nGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG4, 23, 23, "we-extra-delay");\r\nGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG4, 7, 7, "oe-extra-delay");\r\nGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG6, 7, 7, "cycle2cycle-samecsen");\r\nGPMC_GET_RAW_BOOL(GPMC_CS_CONFIG6, 6, 6, "cycle2cycle-diffcsen");\r\npr_info("gpmc cs%i timings configuration:\n", cs);\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG2, 0, 3, "cs-on-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG2, 8, 12, "cs-rd-off-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG2, 16, 20, "cs-wr-off-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG3, 0, 3, "adv-on-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG3, 8, 12, "adv-rd-off-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG3, 16, 20, "adv-wr-off-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG4, 0, 3, "oe-on-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG4, 8, 12, "oe-off-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG4, 16, 19, "we-on-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG4, 24, 28, "we-off-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG5, 0, 4, "rd-cycle-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG5, 8, 12, "wr-cycle-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG5, 16, 20, "access-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG5, 24, 27, "page-burst-access-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG6, 0, 3, "bus-turnaround-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG6, 8, 11, "cycle2cycle-delay-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG1, 18, 19, "wait-monitoring-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG1, 25, 26, "clk-activation-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG6, 16, 19, "wr-data-mux-bus-ns");\r\nGPMC_GET_TICKS(GPMC_CS_CONFIG6, 24, 28, "wr-access-ns");\r\n}\r\nstatic inline void gpmc_cs_show_timings(int cs, const char *desc)\r\n{\r\n}\r\nstatic int set_gpmc_timing_reg(int cs, int reg, int st_bit, int end_bit,\r\nint time, const char *name)\r\n{\r\nu32 l;\r\nint ticks, mask, nr_bits;\r\nif (time == 0)\r\nticks = 0;\r\nelse\r\nticks = gpmc_ns_to_ticks(time);\r\nnr_bits = end_bit - st_bit + 1;\r\nmask = (1 << nr_bits) - 1;\r\nif (ticks > mask) {\r\npr_err("%s: GPMC error! CS%d: %s: %d ns, %d ticks > %d\n",\r\n__func__, cs, name, time, ticks, mask);\r\nreturn -1;\r\n}\r\nl = gpmc_cs_read_reg(cs, reg);\r\n#ifdef DEBUG\r\nprintk(KERN_INFO\r\n"GPMC CS%d: %-10s: %3d ticks, %3lu ns (was %3i ticks) %3d ns\n",\r\ncs, name, ticks, gpmc_get_fclk_period() * ticks / 1000,\r\n(l >> st_bit) & mask, time);\r\n#endif\r\nl &= ~(mask << st_bit);\r\nl |= ticks << st_bit;\r\ngpmc_cs_write_reg(cs, reg, l);\r\nreturn 0;\r\n}\r\nint gpmc_calc_divider(unsigned int sync_clk)\r\n{\r\nint div;\r\nu32 l;\r\nl = sync_clk + (gpmc_get_fclk_period() - 1);\r\ndiv = l / gpmc_get_fclk_period();\r\nif (div > 4)\r\nreturn -1;\r\nif (div <= 0)\r\ndiv = 1;\r\nreturn div;\r\n}\r\nint gpmc_cs_set_timings(int cs, const struct gpmc_timings *t)\r\n{\r\nint div;\r\nu32 l;\r\ngpmc_cs_show_timings(cs, "before gpmc_cs_set_timings");\r\ndiv = gpmc_calc_divider(t->sync_clk);\r\nif (div < 0)\r\nreturn div;\r\nGPMC_SET_ONE(GPMC_CS_CONFIG2, 0, 3, cs_on);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG2, 8, 12, cs_rd_off);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG2, 16, 20, cs_wr_off);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG3, 0, 3, adv_on);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG3, 8, 12, adv_rd_off);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG3, 16, 20, adv_wr_off);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG4, 0, 3, oe_on);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG4, 8, 12, oe_off);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG4, 16, 19, we_on);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG4, 24, 28, we_off);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG5, 0, 4, rd_cycle);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG5, 8, 12, wr_cycle);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG5, 16, 20, access);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG5, 24, 27, page_burst_access);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG6, 0, 3, bus_turnaround);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG6, 8, 11, cycle2cycle_delay);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG1, 18, 19, wait_monitoring);\r\nGPMC_SET_ONE(GPMC_CS_CONFIG1, 25, 26, clk_activation);\r\nif (gpmc_capability & GPMC_HAS_WR_DATA_MUX_BUS)\r\nGPMC_SET_ONE(GPMC_CS_CONFIG6, 16, 19, wr_data_mux_bus);\r\nif (gpmc_capability & GPMC_HAS_WR_ACCESS)\r\nGPMC_SET_ONE(GPMC_CS_CONFIG6, 24, 28, wr_access);\r\nl = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);\r\nif (l & (GPMC_CONFIG1_READTYPE_SYNC | GPMC_CONFIG1_WRITETYPE_SYNC)) {\r\n#ifdef DEBUG\r\nprintk(KERN_INFO "GPMC CS%d CLK period is %lu ns (div %d)\n",\r\ncs, (div * gpmc_get_fclk_period()) / 1000, div);\r\n#endif\r\nl &= ~0x03;\r\nl |= (div - 1);\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG1, l);\r\n}\r\ngpmc_cs_bool_timings(cs, &t->bool_timings);\r\ngpmc_cs_show_timings(cs, "after gpmc_cs_set_timings");\r\nreturn 0;\r\n}\r\nstatic int gpmc_cs_set_memconf(int cs, u32 base, u32 size)\r\n{\r\nu32 l;\r\nu32 mask;\r\nif (base & (size - 1))\r\nreturn -EINVAL;\r\nmask = (1 << GPMC_SECTION_SHIFT) - size;\r\nl = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG7);\r\nl &= ~0x3f;\r\nl = (base >> GPMC_CHUNK_SHIFT) & 0x3f;\r\nl &= ~(0x0f << 8);\r\nl |= ((mask >> GPMC_CHUNK_SHIFT) & 0x0f) << 8;\r\nl |= GPMC_CONFIG7_CSVALID;\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG7, l);\r\nreturn 0;\r\n}\r\nstatic void gpmc_cs_enable_mem(int cs)\r\n{\r\nu32 l;\r\nl = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG7);\r\nl |= GPMC_CONFIG7_CSVALID;\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG7, l);\r\n}\r\nstatic void gpmc_cs_disable_mem(int cs)\r\n{\r\nu32 l;\r\nl = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG7);\r\nl &= ~GPMC_CONFIG7_CSVALID;\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG7, l);\r\n}\r\nstatic void gpmc_cs_get_memconf(int cs, u32 *base, u32 *size)\r\n{\r\nu32 l;\r\nu32 mask;\r\nl = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG7);\r\n*base = (l & 0x3f) << GPMC_CHUNK_SHIFT;\r\nmask = (l >> 8) & 0x0f;\r\n*size = (1 << GPMC_SECTION_SHIFT) - (mask << GPMC_CHUNK_SHIFT);\r\n}\r\nstatic int gpmc_cs_mem_enabled(int cs)\r\n{\r\nu32 l;\r\nl = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG7);\r\nreturn l & GPMC_CONFIG7_CSVALID;\r\n}\r\nstatic void gpmc_cs_set_reserved(int cs, int reserved)\r\n{\r\nstruct gpmc_cs_data *gpmc = &gpmc_cs[cs];\r\ngpmc->flags |= GPMC_CS_RESERVED;\r\n}\r\nstatic bool gpmc_cs_reserved(int cs)\r\n{\r\nstruct gpmc_cs_data *gpmc = &gpmc_cs[cs];\r\nreturn gpmc->flags & GPMC_CS_RESERVED;\r\n}\r\nstatic void gpmc_cs_set_name(int cs, const char *name)\r\n{\r\nstruct gpmc_cs_data *gpmc = &gpmc_cs[cs];\r\ngpmc->name = name;\r\n}\r\nconst char *gpmc_cs_get_name(int cs)\r\n{\r\nstruct gpmc_cs_data *gpmc = &gpmc_cs[cs];\r\nreturn gpmc->name;\r\n}\r\nstatic unsigned long gpmc_mem_align(unsigned long size)\r\n{\r\nint order;\r\nsize = (size - 1) >> (GPMC_CHUNK_SHIFT - 1);\r\norder = GPMC_CHUNK_SHIFT - 1;\r\ndo {\r\nsize >>= 1;\r\norder++;\r\n} while (size);\r\nsize = 1 << order;\r\nreturn size;\r\n}\r\nstatic int gpmc_cs_insert_mem(int cs, unsigned long base, unsigned long size)\r\n{\r\nstruct gpmc_cs_data *gpmc = &gpmc_cs[cs];\r\nstruct resource *res = &gpmc->mem;\r\nint r;\r\nsize = gpmc_mem_align(size);\r\nspin_lock(&gpmc_mem_lock);\r\nres->start = base;\r\nres->end = base + size - 1;\r\nr = request_resource(&gpmc_mem_root, res);\r\nspin_unlock(&gpmc_mem_lock);\r\nreturn r;\r\n}\r\nstatic int gpmc_cs_delete_mem(int cs)\r\n{\r\nstruct gpmc_cs_data *gpmc = &gpmc_cs[cs];\r\nstruct resource *res = &gpmc->mem;\r\nint r;\r\nspin_lock(&gpmc_mem_lock);\r\nr = release_resource(res);\r\nres->start = 0;\r\nres->end = 0;\r\nspin_unlock(&gpmc_mem_lock);\r\nreturn r;\r\n}\r\nstatic int gpmc_cs_remap(int cs, u32 base)\r\n{\r\nint ret;\r\nu32 old_base, size;\r\nif (cs > gpmc_cs_num) {\r\npr_err("%s: requested chip-select is disabled\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nbase &= ~(SZ_16M - 1);\r\ngpmc_cs_get_memconf(cs, &old_base, &size);\r\nif (base == old_base)\r\nreturn 0;\r\nret = gpmc_cs_delete_mem(cs);\r\nif (ret < 0)\r\nreturn ret;\r\nret = gpmc_cs_insert_mem(cs, base, size);\r\nif (ret < 0)\r\nreturn ret;\r\nret = gpmc_cs_set_memconf(cs, base, size);\r\nreturn ret;\r\n}\r\nint gpmc_cs_request(int cs, unsigned long size, unsigned long *base)\r\n{\r\nstruct gpmc_cs_data *gpmc = &gpmc_cs[cs];\r\nstruct resource *res = &gpmc->mem;\r\nint r = -1;\r\nif (cs > gpmc_cs_num) {\r\npr_err("%s: requested chip-select is disabled\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nsize = gpmc_mem_align(size);\r\nif (size > (1 << GPMC_SECTION_SHIFT))\r\nreturn -ENOMEM;\r\nspin_lock(&gpmc_mem_lock);\r\nif (gpmc_cs_reserved(cs)) {\r\nr = -EBUSY;\r\ngoto out;\r\n}\r\nif (gpmc_cs_mem_enabled(cs))\r\nr = adjust_resource(res, res->start & ~(size - 1), size);\r\nif (r < 0)\r\nr = allocate_resource(&gpmc_mem_root, res, size, 0, ~0,\r\nsize, NULL, NULL);\r\nif (r < 0)\r\ngoto out;\r\ngpmc_cs_disable_mem(cs);\r\nr = gpmc_cs_set_memconf(cs, res->start, resource_size(res));\r\nif (r < 0) {\r\nrelease_resource(res);\r\ngoto out;\r\n}\r\ngpmc_cs_enable_mem(cs);\r\n*base = res->start;\r\ngpmc_cs_set_reserved(cs, 1);\r\nout:\r\nspin_unlock(&gpmc_mem_lock);\r\nreturn r;\r\n}\r\nvoid gpmc_cs_free(int cs)\r\n{\r\nstruct gpmc_cs_data *gpmc = &gpmc_cs[cs];\r\nstruct resource *res = &gpmc->mem;\r\nspin_lock(&gpmc_mem_lock);\r\nif (cs >= gpmc_cs_num || cs < 0 || !gpmc_cs_reserved(cs)) {\r\nprintk(KERN_ERR "Trying to free non-reserved GPMC CS%d\n", cs);\r\nBUG();\r\nspin_unlock(&gpmc_mem_lock);\r\nreturn;\r\n}\r\ngpmc_cs_disable_mem(cs);\r\nif (res->flags)\r\nrelease_resource(res);\r\ngpmc_cs_set_reserved(cs, 0);\r\nspin_unlock(&gpmc_mem_lock);\r\n}\r\nint gpmc_configure(int cmd, int wval)\r\n{\r\nu32 regval;\r\nswitch (cmd) {\r\ncase GPMC_ENABLE_IRQ:\r\ngpmc_write_reg(GPMC_IRQENABLE, wval);\r\nbreak;\r\ncase GPMC_SET_IRQ_STATUS:\r\ngpmc_write_reg(GPMC_IRQSTATUS, wval);\r\nbreak;\r\ncase GPMC_CONFIG_WP:\r\nregval = gpmc_read_reg(GPMC_CONFIG);\r\nif (wval)\r\nregval &= ~GPMC_CONFIG_WRITEPROTECT;\r\nelse\r\nregval |= GPMC_CONFIG_WRITEPROTECT;\r\ngpmc_write_reg(GPMC_CONFIG, regval);\r\nbreak;\r\ndefault:\r\npr_err("%s: command not supported\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid gpmc_update_nand_reg(struct gpmc_nand_regs *reg, int cs)\r\n{\r\nint i;\r\nreg->gpmc_status = gpmc_base + GPMC_STATUS;\r\nreg->gpmc_nand_command = gpmc_base + GPMC_CS0_OFFSET +\r\nGPMC_CS_NAND_COMMAND + GPMC_CS_SIZE * cs;\r\nreg->gpmc_nand_address = gpmc_base + GPMC_CS0_OFFSET +\r\nGPMC_CS_NAND_ADDRESS + GPMC_CS_SIZE * cs;\r\nreg->gpmc_nand_data = gpmc_base + GPMC_CS0_OFFSET +\r\nGPMC_CS_NAND_DATA + GPMC_CS_SIZE * cs;\r\nreg->gpmc_prefetch_config1 = gpmc_base + GPMC_PREFETCH_CONFIG1;\r\nreg->gpmc_prefetch_config2 = gpmc_base + GPMC_PREFETCH_CONFIG2;\r\nreg->gpmc_prefetch_control = gpmc_base + GPMC_PREFETCH_CONTROL;\r\nreg->gpmc_prefetch_status = gpmc_base + GPMC_PREFETCH_STATUS;\r\nreg->gpmc_ecc_config = gpmc_base + GPMC_ECC_CONFIG;\r\nreg->gpmc_ecc_control = gpmc_base + GPMC_ECC_CONTROL;\r\nreg->gpmc_ecc_size_config = gpmc_base + GPMC_ECC_SIZE_CONFIG;\r\nreg->gpmc_ecc1_result = gpmc_base + GPMC_ECC1_RESULT;\r\nfor (i = 0; i < GPMC_BCH_NUM_REMAINDER; i++) {\r\nreg->gpmc_bch_result0[i] = gpmc_base + GPMC_ECC_BCH_RESULT_0 +\r\nGPMC_BCH_SIZE * i;\r\nreg->gpmc_bch_result1[i] = gpmc_base + GPMC_ECC_BCH_RESULT_1 +\r\nGPMC_BCH_SIZE * i;\r\nreg->gpmc_bch_result2[i] = gpmc_base + GPMC_ECC_BCH_RESULT_2 +\r\nGPMC_BCH_SIZE * i;\r\nreg->gpmc_bch_result3[i] = gpmc_base + GPMC_ECC_BCH_RESULT_3 +\r\nGPMC_BCH_SIZE * i;\r\nreg->gpmc_bch_result4[i] = gpmc_base + GPMC_ECC_BCH_RESULT_4 +\r\ni * GPMC_BCH_SIZE;\r\nreg->gpmc_bch_result5[i] = gpmc_base + GPMC_ECC_BCH_RESULT_5 +\r\ni * GPMC_BCH_SIZE;\r\nreg->gpmc_bch_result6[i] = gpmc_base + GPMC_ECC_BCH_RESULT_6 +\r\ni * GPMC_BCH_SIZE;\r\n}\r\n}\r\nint gpmc_get_client_irq(unsigned irq_config)\r\n{\r\nint i;\r\nif (hweight32(irq_config) > 1)\r\nreturn 0;\r\nfor (i = 0; i < GPMC_NR_IRQ; i++)\r\nif (gpmc_client_irq[i].bitmask & irq_config)\r\nreturn gpmc_client_irq[i].irq;\r\nreturn 0;\r\n}\r\nstatic int gpmc_irq_endis(unsigned irq, bool endis)\r\n{\r\nint i;\r\nu32 regval;\r\nfor (i = 0; i < GPMC_NR_IRQ; i++)\r\nif (irq == gpmc_client_irq[i].irq) {\r\nregval = gpmc_read_reg(GPMC_IRQENABLE);\r\nif (endis)\r\nregval |= gpmc_client_irq[i].bitmask;\r\nelse\r\nregval &= ~gpmc_client_irq[i].bitmask;\r\ngpmc_write_reg(GPMC_IRQENABLE, regval);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void gpmc_irq_disable(struct irq_data *p)\r\n{\r\ngpmc_irq_endis(p->irq, false);\r\n}\r\nstatic void gpmc_irq_enable(struct irq_data *p)\r\n{\r\ngpmc_irq_endis(p->irq, true);\r\n}\r\nstatic void gpmc_irq_noop(struct irq_data *data) { }\r\nstatic unsigned int gpmc_irq_noop_ret(struct irq_data *data) { return 0; }\r\nstatic int gpmc_setup_irq(void)\r\n{\r\nint i;\r\nu32 regval;\r\nif (!gpmc_irq)\r\nreturn -EINVAL;\r\ngpmc_irq_start = irq_alloc_descs(-1, 0, GPMC_NR_IRQ, 0);\r\nif (gpmc_irq_start < 0) {\r\npr_err("irq_alloc_descs failed\n");\r\nreturn gpmc_irq_start;\r\n}\r\ngpmc_irq_chip.name = "gpmc";\r\ngpmc_irq_chip.irq_startup = gpmc_irq_noop_ret;\r\ngpmc_irq_chip.irq_enable = gpmc_irq_enable;\r\ngpmc_irq_chip.irq_disable = gpmc_irq_disable;\r\ngpmc_irq_chip.irq_shutdown = gpmc_irq_noop;\r\ngpmc_irq_chip.irq_ack = gpmc_irq_noop;\r\ngpmc_irq_chip.irq_mask = gpmc_irq_noop;\r\ngpmc_irq_chip.irq_unmask = gpmc_irq_noop;\r\ngpmc_client_irq[0].bitmask = GPMC_IRQ_FIFOEVENTENABLE;\r\ngpmc_client_irq[1].bitmask = GPMC_IRQ_COUNT_EVENT;\r\nfor (i = 0; i < GPMC_NR_IRQ; i++) {\r\ngpmc_client_irq[i].irq = gpmc_irq_start + i;\r\nirq_set_chip_and_handler(gpmc_client_irq[i].irq,\r\n&gpmc_irq_chip, handle_simple_irq);\r\nset_irq_flags(gpmc_client_irq[i].irq,\r\nIRQF_VALID | IRQF_NOAUTOEN);\r\n}\r\ngpmc_write_reg(GPMC_IRQENABLE, 0);\r\nregval = gpmc_read_reg(GPMC_IRQSTATUS);\r\ngpmc_write_reg(GPMC_IRQSTATUS, regval);\r\nreturn request_irq(gpmc_irq, gpmc_handle_irq, 0, "gpmc", NULL);\r\n}\r\nstatic int gpmc_free_irq(void)\r\n{\r\nint i;\r\nif (gpmc_irq)\r\nfree_irq(gpmc_irq, NULL);\r\nfor (i = 0; i < GPMC_NR_IRQ; i++) {\r\nirq_set_handler(gpmc_client_irq[i].irq, NULL);\r\nirq_set_chip(gpmc_client_irq[i].irq, &no_irq_chip);\r\nirq_modify_status(gpmc_client_irq[i].irq, 0, 0);\r\n}\r\nirq_free_descs(gpmc_irq_start, GPMC_NR_IRQ);\r\nreturn 0;\r\n}\r\nstatic void gpmc_mem_exit(void)\r\n{\r\nint cs;\r\nfor (cs = 0; cs < gpmc_cs_num; cs++) {\r\nif (!gpmc_cs_mem_enabled(cs))\r\ncontinue;\r\ngpmc_cs_delete_mem(cs);\r\n}\r\n}\r\nstatic void gpmc_mem_init(void)\r\n{\r\nint cs;\r\ngpmc_mem_root.start = SZ_1M;\r\ngpmc_mem_root.end = GPMC_MEM_END;\r\nfor (cs = 0; cs < gpmc_cs_num; cs++) {\r\nu32 base, size;\r\nif (!gpmc_cs_mem_enabled(cs))\r\ncontinue;\r\ngpmc_cs_get_memconf(cs, &base, &size);\r\nif (gpmc_cs_insert_mem(cs, base, size)) {\r\npr_warn("%s: disabling cs %d mapped at 0x%x-0x%x\n",\r\n__func__, cs, base, base + size);\r\ngpmc_cs_disable_mem(cs);\r\n}\r\n}\r\n}\r\nstatic u32 gpmc_round_ps_to_sync_clk(u32 time_ps, u32 sync_clk)\r\n{\r\nu32 temp;\r\nint div;\r\ndiv = gpmc_calc_divider(sync_clk);\r\ntemp = gpmc_ps_to_ticks(time_ps);\r\ntemp = (temp + div - 1) / div;\r\nreturn gpmc_ticks_to_ps(temp * div);\r\n}\r\nstatic int gpmc_calc_sync_read_timings(struct gpmc_timings *gpmc_t,\r\nstruct gpmc_device_timings *dev_t,\r\nbool mux)\r\n{\r\nu32 temp;\r\ntemp = dev_t->t_avdp_r;\r\nif (mux) {\r\ntemp = max_t(u32, temp, gpmc_t->clk_activation + dev_t->t_avdh);\r\ntemp = max_t(u32, gpmc_t->adv_on + gpmc_ticks_to_ps(1), temp);\r\n}\r\ngpmc_t->adv_rd_off = gpmc_round_ps_to_ticks(temp);\r\ntemp = dev_t->t_oeasu;\r\nif (mux) {\r\ntemp = max_t(u32, temp, gpmc_t->clk_activation + dev_t->t_ach);\r\ntemp = max_t(u32, temp, gpmc_t->adv_rd_off +\r\ngpmc_ticks_to_ps(dev_t->cyc_aavdh_oe));\r\n}\r\ngpmc_t->oe_on = gpmc_round_ps_to_ticks(temp);\r\ntemp = max_t(u32, dev_t->t_iaa, dev_t->cyc_iaa * gpmc_t->sync_clk);\r\ntemp += gpmc_t->clk_activation;\r\nif (dev_t->cyc_oe)\r\ntemp = max_t(u32, temp, gpmc_t->oe_on +\r\ngpmc_ticks_to_ps(dev_t->cyc_oe));\r\ngpmc_t->access = gpmc_round_ps_to_ticks(temp);\r\ngpmc_t->oe_off = gpmc_t->access + gpmc_ticks_to_ps(1);\r\ngpmc_t->cs_rd_off = gpmc_t->oe_off;\r\ntemp = max_t(u32, dev_t->t_cez_r, dev_t->t_oez);\r\ntemp = gpmc_round_ps_to_sync_clk(temp, gpmc_t->sync_clk) +\r\ngpmc_t->access;\r\nif (dev_t->t_ce_rdyz)\r\ntemp = max_t(u32, temp, gpmc_t->cs_rd_off + dev_t->t_ce_rdyz);\r\ngpmc_t->rd_cycle = gpmc_round_ps_to_ticks(temp);\r\nreturn 0;\r\n}\r\nstatic int gpmc_calc_sync_write_timings(struct gpmc_timings *gpmc_t,\r\nstruct gpmc_device_timings *dev_t,\r\nbool mux)\r\n{\r\nu32 temp;\r\ntemp = dev_t->t_avdp_w;\r\nif (mux) {\r\ntemp = max_t(u32, temp,\r\ngpmc_t->clk_activation + dev_t->t_avdh);\r\ntemp = max_t(u32, gpmc_t->adv_on + gpmc_ticks_to_ps(1), temp);\r\n}\r\ngpmc_t->adv_wr_off = gpmc_round_ps_to_ticks(temp);\r\ntemp = max_t(u32, dev_t->t_weasu,\r\ngpmc_t->clk_activation + dev_t->t_rdyo);\r\nif (mux) {\r\ntemp = max_t(u32, temp,\r\ngpmc_t->adv_wr_off + dev_t->t_aavdh);\r\ntemp = max_t(u32, temp, gpmc_t->adv_wr_off +\r\ngpmc_ticks_to_ps(dev_t->cyc_aavdh_we));\r\n}\r\ngpmc_t->wr_data_mux_bus = gpmc_round_ps_to_ticks(temp);\r\nif (gpmc_capability & GPMC_HAS_WR_DATA_MUX_BUS)\r\ngpmc_t->we_on = gpmc_round_ps_to_ticks(dev_t->t_weasu);\r\nelse\r\ngpmc_t->we_on = gpmc_t->wr_data_mux_bus;\r\ngpmc_t->wr_access = gpmc_t->access;\r\ntemp = gpmc_t->we_on + dev_t->t_wpl;\r\ntemp = max_t(u32, temp,\r\ngpmc_t->wr_access + gpmc_ticks_to_ps(1));\r\ntemp = max_t(u32, temp,\r\ngpmc_t->we_on + gpmc_ticks_to_ps(dev_t->cyc_wpl));\r\ngpmc_t->we_off = gpmc_round_ps_to_ticks(temp);\r\ngpmc_t->cs_wr_off = gpmc_round_ps_to_ticks(gpmc_t->we_off +\r\ndev_t->t_wph);\r\ntemp = gpmc_round_ps_to_sync_clk(dev_t->t_cez_w, gpmc_t->sync_clk);\r\ntemp += gpmc_t->wr_access;\r\nif (dev_t->t_ce_rdyz)\r\ntemp = max_t(u32, temp,\r\ngpmc_t->cs_wr_off + dev_t->t_ce_rdyz);\r\ngpmc_t->wr_cycle = gpmc_round_ps_to_ticks(temp);\r\nreturn 0;\r\n}\r\nstatic int gpmc_calc_async_read_timings(struct gpmc_timings *gpmc_t,\r\nstruct gpmc_device_timings *dev_t,\r\nbool mux)\r\n{\r\nu32 temp;\r\ntemp = dev_t->t_avdp_r;\r\nif (mux)\r\ntemp = max_t(u32, gpmc_t->adv_on + gpmc_ticks_to_ps(1), temp);\r\ngpmc_t->adv_rd_off = gpmc_round_ps_to_ticks(temp);\r\ntemp = dev_t->t_oeasu;\r\nif (mux)\r\ntemp = max_t(u32, temp,\r\ngpmc_t->adv_rd_off + dev_t->t_aavdh);\r\ngpmc_t->oe_on = gpmc_round_ps_to_ticks(temp);\r\ntemp = max_t(u32, dev_t->t_iaa,\r\ngpmc_t->oe_on + dev_t->t_oe);\r\ntemp = max_t(u32, temp,\r\ngpmc_t->cs_on + dev_t->t_ce);\r\ntemp = max_t(u32, temp,\r\ngpmc_t->adv_on + dev_t->t_aa);\r\ngpmc_t->access = gpmc_round_ps_to_ticks(temp);\r\ngpmc_t->oe_off = gpmc_t->access + gpmc_ticks_to_ps(1);\r\ngpmc_t->cs_rd_off = gpmc_t->oe_off;\r\ntemp = max_t(u32, dev_t->t_rd_cycle,\r\ngpmc_t->cs_rd_off + dev_t->t_cez_r);\r\ntemp = max_t(u32, temp, gpmc_t->oe_off + dev_t->t_oez);\r\ngpmc_t->rd_cycle = gpmc_round_ps_to_ticks(temp);\r\nreturn 0;\r\n}\r\nstatic int gpmc_calc_async_write_timings(struct gpmc_timings *gpmc_t,\r\nstruct gpmc_device_timings *dev_t,\r\nbool mux)\r\n{\r\nu32 temp;\r\ntemp = dev_t->t_avdp_w;\r\nif (mux)\r\ntemp = max_t(u32, gpmc_t->adv_on + gpmc_ticks_to_ps(1), temp);\r\ngpmc_t->adv_wr_off = gpmc_round_ps_to_ticks(temp);\r\ntemp = dev_t->t_weasu;\r\nif (mux) {\r\ntemp = max_t(u32, temp, gpmc_t->adv_wr_off + dev_t->t_aavdh);\r\ntemp = max_t(u32, temp, gpmc_t->adv_wr_off +\r\ngpmc_ticks_to_ps(dev_t->cyc_aavdh_we));\r\n}\r\ngpmc_t->wr_data_mux_bus = gpmc_round_ps_to_ticks(temp);\r\nif (gpmc_capability & GPMC_HAS_WR_DATA_MUX_BUS)\r\ngpmc_t->we_on = gpmc_round_ps_to_ticks(dev_t->t_weasu);\r\nelse\r\ngpmc_t->we_on = gpmc_t->wr_data_mux_bus;\r\ntemp = gpmc_t->we_on + dev_t->t_wpl;\r\ngpmc_t->we_off = gpmc_round_ps_to_ticks(temp);\r\ngpmc_t->cs_wr_off = gpmc_round_ps_to_ticks(gpmc_t->we_off +\r\ndev_t->t_wph);\r\ntemp = max_t(u32, dev_t->t_wr_cycle,\r\ngpmc_t->cs_wr_off + dev_t->t_cez_w);\r\ngpmc_t->wr_cycle = gpmc_round_ps_to_ticks(temp);\r\nreturn 0;\r\n}\r\nstatic int gpmc_calc_sync_common_timings(struct gpmc_timings *gpmc_t,\r\nstruct gpmc_device_timings *dev_t)\r\n{\r\nu32 temp;\r\ngpmc_t->sync_clk = gpmc_calc_divider(dev_t->clk) *\r\ngpmc_get_fclk_period();\r\ngpmc_t->page_burst_access = gpmc_round_ps_to_sync_clk(\r\ndev_t->t_bacc,\r\ngpmc_t->sync_clk);\r\ntemp = max_t(u32, dev_t->t_ces, dev_t->t_avds);\r\ngpmc_t->clk_activation = gpmc_round_ps_to_ticks(temp);\r\nif (gpmc_calc_divider(gpmc_t->sync_clk) != 1)\r\nreturn 0;\r\nif (dev_t->ce_xdelay)\r\ngpmc_t->bool_timings.cs_extra_delay = true;\r\nif (dev_t->avd_xdelay)\r\ngpmc_t->bool_timings.adv_extra_delay = true;\r\nif (dev_t->oe_xdelay)\r\ngpmc_t->bool_timings.oe_extra_delay = true;\r\nif (dev_t->we_xdelay)\r\ngpmc_t->bool_timings.we_extra_delay = true;\r\nreturn 0;\r\n}\r\nstatic int gpmc_calc_common_timings(struct gpmc_timings *gpmc_t,\r\nstruct gpmc_device_timings *dev_t,\r\nbool sync)\r\n{\r\nu32 temp;\r\ngpmc_t->cs_on = gpmc_round_ps_to_ticks(dev_t->t_ceasu);\r\ntemp = dev_t->t_avdasu;\r\nif (dev_t->t_ce_avd)\r\ntemp = max_t(u32, temp,\r\ngpmc_t->cs_on + dev_t->t_ce_avd);\r\ngpmc_t->adv_on = gpmc_round_ps_to_ticks(temp);\r\nif (sync)\r\ngpmc_calc_sync_common_timings(gpmc_t, dev_t);\r\nreturn 0;\r\n}\r\nstatic void gpmc_convert_ps_to_ns(struct gpmc_timings *t)\r\n{\r\nt->cs_on /= 1000;\r\nt->cs_rd_off /= 1000;\r\nt->cs_wr_off /= 1000;\r\nt->adv_on /= 1000;\r\nt->adv_rd_off /= 1000;\r\nt->adv_wr_off /= 1000;\r\nt->we_on /= 1000;\r\nt->we_off /= 1000;\r\nt->oe_on /= 1000;\r\nt->oe_off /= 1000;\r\nt->page_burst_access /= 1000;\r\nt->access /= 1000;\r\nt->rd_cycle /= 1000;\r\nt->wr_cycle /= 1000;\r\nt->bus_turnaround /= 1000;\r\nt->cycle2cycle_delay /= 1000;\r\nt->wait_monitoring /= 1000;\r\nt->clk_activation /= 1000;\r\nt->wr_access /= 1000;\r\nt->wr_data_mux_bus /= 1000;\r\n}\r\nint gpmc_calc_timings(struct gpmc_timings *gpmc_t,\r\nstruct gpmc_settings *gpmc_s,\r\nstruct gpmc_device_timings *dev_t)\r\n{\r\nbool mux = false, sync = false;\r\nif (gpmc_s) {\r\nmux = gpmc_s->mux_add_data ? true : false;\r\nsync = (gpmc_s->sync_read || gpmc_s->sync_write);\r\n}\r\nmemset(gpmc_t, 0, sizeof(*gpmc_t));\r\ngpmc_calc_common_timings(gpmc_t, dev_t, sync);\r\nif (gpmc_s && gpmc_s->sync_read)\r\ngpmc_calc_sync_read_timings(gpmc_t, dev_t, mux);\r\nelse\r\ngpmc_calc_async_read_timings(gpmc_t, dev_t, mux);\r\nif (gpmc_s && gpmc_s->sync_write)\r\ngpmc_calc_sync_write_timings(gpmc_t, dev_t, mux);\r\nelse\r\ngpmc_calc_async_write_timings(gpmc_t, dev_t, mux);\r\ngpmc_convert_ps_to_ns(gpmc_t);\r\nreturn 0;\r\n}\r\nint gpmc_cs_program_settings(int cs, struct gpmc_settings *p)\r\n{\r\nu32 config1;\r\nif ((!p->device_width) || (p->device_width > GPMC_DEVWIDTH_16BIT)) {\r\npr_err("%s: invalid width %d!", __func__, p->device_width);\r\nreturn -EINVAL;\r\n}\r\nif (p->device_nand && p->mux_add_data) {\r\npr_err("%s: invalid configuration!\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif ((p->mux_add_data > GPMC_MUX_AD) ||\r\n((p->mux_add_data == GPMC_MUX_AAD) &&\r\n!(gpmc_capability & GPMC_HAS_MUX_AAD))) {\r\npr_err("%s: invalid multiplex configuration!\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (p->burst_read || p->burst_write) {\r\nswitch (p->burst_len) {\r\ncase GPMC_BURST_4:\r\ncase GPMC_BURST_8:\r\ncase GPMC_BURST_16:\r\nbreak;\r\ndefault:\r\npr_err("%s: invalid page/burst-length (%d)\n",\r\n__func__, p->burst_len);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (p->wait_pin > gpmc_nr_waitpins) {\r\npr_err("%s: invalid wait-pin (%d)\n", __func__, p->wait_pin);\r\nreturn -EINVAL;\r\n}\r\nconfig1 = GPMC_CONFIG1_DEVICESIZE((p->device_width - 1));\r\nif (p->sync_read)\r\nconfig1 |= GPMC_CONFIG1_READTYPE_SYNC;\r\nif (p->sync_write)\r\nconfig1 |= GPMC_CONFIG1_WRITETYPE_SYNC;\r\nif (p->wait_on_read)\r\nconfig1 |= GPMC_CONFIG1_WAIT_READ_MON;\r\nif (p->wait_on_write)\r\nconfig1 |= GPMC_CONFIG1_WAIT_WRITE_MON;\r\nif (p->wait_on_read || p->wait_on_write)\r\nconfig1 |= GPMC_CONFIG1_WAIT_PIN_SEL(p->wait_pin);\r\nif (p->device_nand)\r\nconfig1 |= GPMC_CONFIG1_DEVICETYPE(GPMC_DEVICETYPE_NAND);\r\nif (p->mux_add_data)\r\nconfig1 |= GPMC_CONFIG1_MUXTYPE(p->mux_add_data);\r\nif (p->burst_read)\r\nconfig1 |= GPMC_CONFIG1_READMULTIPLE_SUPP;\r\nif (p->burst_write)\r\nconfig1 |= GPMC_CONFIG1_WRITEMULTIPLE_SUPP;\r\nif (p->burst_read || p->burst_write) {\r\nconfig1 |= GPMC_CONFIG1_PAGE_LEN(p->burst_len >> 3);\r\nconfig1 |= p->burst_wrap ? GPMC_CONFIG1_WRAPBURST_SUPP : 0;\r\n}\r\ngpmc_cs_write_reg(cs, GPMC_CS_CONFIG1, config1);\r\nreturn 0;\r\n}\r\nvoid gpmc_read_settings_dt(struct device_node *np, struct gpmc_settings *p)\r\n{\r\nmemset(p, 0, sizeof(struct gpmc_settings));\r\np->sync_read = of_property_read_bool(np, "gpmc,sync-read");\r\np->sync_write = of_property_read_bool(np, "gpmc,sync-write");\r\nof_property_read_u32(np, "gpmc,device-width", &p->device_width);\r\nof_property_read_u32(np, "gpmc,mux-add-data", &p->mux_add_data);\r\nif (!of_property_read_u32(np, "gpmc,burst-length", &p->burst_len)) {\r\np->burst_wrap = of_property_read_bool(np, "gpmc,burst-wrap");\r\np->burst_read = of_property_read_bool(np, "gpmc,burst-read");\r\np->burst_write = of_property_read_bool(np, "gpmc,burst-write");\r\nif (!p->burst_read && !p->burst_write)\r\npr_warn("%s: page/burst-length set but not used!\n",\r\n__func__);\r\n}\r\nif (!of_property_read_u32(np, "gpmc,wait-pin", &p->wait_pin)) {\r\np->wait_on_read = of_property_read_bool(np,\r\n"gpmc,wait-on-read");\r\np->wait_on_write = of_property_read_bool(np,\r\n"gpmc,wait-on-write");\r\nif (!p->wait_on_read && !p->wait_on_write)\r\npr_debug("%s: rd/wr wait monitoring not enabled!\n",\r\n__func__);\r\n}\r\n}\r\nstatic void __maybe_unused gpmc_read_timings_dt(struct device_node *np,\r\nstruct gpmc_timings *gpmc_t)\r\n{\r\nstruct gpmc_bool_timings *p;\r\nif (!np || !gpmc_t)\r\nreturn;\r\nmemset(gpmc_t, 0, sizeof(*gpmc_t));\r\nof_property_read_u32(np, "gpmc,sync-clk-ps", &gpmc_t->sync_clk);\r\nof_property_read_u32(np, "gpmc,cs-on-ns", &gpmc_t->cs_on);\r\nof_property_read_u32(np, "gpmc,cs-rd-off-ns", &gpmc_t->cs_rd_off);\r\nof_property_read_u32(np, "gpmc,cs-wr-off-ns", &gpmc_t->cs_wr_off);\r\nof_property_read_u32(np, "gpmc,adv-on-ns", &gpmc_t->adv_on);\r\nof_property_read_u32(np, "gpmc,adv-rd-off-ns", &gpmc_t->adv_rd_off);\r\nof_property_read_u32(np, "gpmc,adv-wr-off-ns", &gpmc_t->adv_wr_off);\r\nof_property_read_u32(np, "gpmc,we-on-ns", &gpmc_t->we_on);\r\nof_property_read_u32(np, "gpmc,we-off-ns", &gpmc_t->we_off);\r\nof_property_read_u32(np, "gpmc,oe-on-ns", &gpmc_t->oe_on);\r\nof_property_read_u32(np, "gpmc,oe-off-ns", &gpmc_t->oe_off);\r\nof_property_read_u32(np, "gpmc,page-burst-access-ns",\r\n&gpmc_t->page_burst_access);\r\nof_property_read_u32(np, "gpmc,access-ns", &gpmc_t->access);\r\nof_property_read_u32(np, "gpmc,rd-cycle-ns", &gpmc_t->rd_cycle);\r\nof_property_read_u32(np, "gpmc,wr-cycle-ns", &gpmc_t->wr_cycle);\r\nof_property_read_u32(np, "gpmc,bus-turnaround-ns",\r\n&gpmc_t->bus_turnaround);\r\nof_property_read_u32(np, "gpmc,cycle2cycle-delay-ns",\r\n&gpmc_t->cycle2cycle_delay);\r\nof_property_read_u32(np, "gpmc,wait-monitoring-ns",\r\n&gpmc_t->wait_monitoring);\r\nof_property_read_u32(np, "gpmc,clk-activation-ns",\r\n&gpmc_t->clk_activation);\r\nof_property_read_u32(np, "gpmc,wr-access-ns", &gpmc_t->wr_access);\r\nof_property_read_u32(np, "gpmc,wr-data-mux-bus-ns",\r\n&gpmc_t->wr_data_mux_bus);\r\np = &gpmc_t->bool_timings;\r\np->cycle2cyclediffcsen =\r\nof_property_read_bool(np, "gpmc,cycle2cycle-diffcsen");\r\np->cycle2cyclesamecsen =\r\nof_property_read_bool(np, "gpmc,cycle2cycle-samecsen");\r\np->we_extra_delay = of_property_read_bool(np, "gpmc,we-extra-delay");\r\np->oe_extra_delay = of_property_read_bool(np, "gpmc,oe-extra-delay");\r\np->adv_extra_delay = of_property_read_bool(np, "gpmc,adv-extra-delay");\r\np->cs_extra_delay = of_property_read_bool(np, "gpmc,cs-extra-delay");\r\np->time_para_granularity =\r\nof_property_read_bool(np, "gpmc,time-para-granularity");\r\n}\r\nstatic int gpmc_probe_nand_child(struct platform_device *pdev,\r\nstruct device_node *child)\r\n{\r\nu32 val;\r\nconst char *s;\r\nstruct gpmc_timings gpmc_t;\r\nstruct omap_nand_platform_data *gpmc_nand_data;\r\nif (of_property_read_u32(child, "reg", &val) < 0) {\r\ndev_err(&pdev->dev, "%s has no 'reg' property\n",\r\nchild->full_name);\r\nreturn -ENODEV;\r\n}\r\ngpmc_nand_data = devm_kzalloc(&pdev->dev, sizeof(*gpmc_nand_data),\r\nGFP_KERNEL);\r\nif (!gpmc_nand_data)\r\nreturn -ENOMEM;\r\ngpmc_nand_data->cs = val;\r\ngpmc_nand_data->of_node = child;\r\ngpmc_nand_data->elm_of_node = of_parse_phandle(child, "ti,elm-id", 0);\r\nif (gpmc_nand_data->elm_of_node == NULL)\r\ngpmc_nand_data->elm_of_node =\r\nof_parse_phandle(child, "elm_id", 0);\r\nif (of_property_read_string(child, "ti,nand-ecc-opt", &s)) {\r\npr_err("%s: ti,nand-ecc-opt not found\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (!strcmp(s, "sw"))\r\ngpmc_nand_data->ecc_opt = OMAP_ECC_HAM1_CODE_SW;\r\nelse if (!strcmp(s, "ham1") ||\r\n!strcmp(s, "hw") || !strcmp(s, "hw-romcode"))\r\ngpmc_nand_data->ecc_opt =\r\nOMAP_ECC_HAM1_CODE_HW;\r\nelse if (!strcmp(s, "bch4"))\r\nif (gpmc_nand_data->elm_of_node)\r\ngpmc_nand_data->ecc_opt =\r\nOMAP_ECC_BCH4_CODE_HW;\r\nelse\r\ngpmc_nand_data->ecc_opt =\r\nOMAP_ECC_BCH4_CODE_HW_DETECTION_SW;\r\nelse if (!strcmp(s, "bch8"))\r\nif (gpmc_nand_data->elm_of_node)\r\ngpmc_nand_data->ecc_opt =\r\nOMAP_ECC_BCH8_CODE_HW;\r\nelse\r\ngpmc_nand_data->ecc_opt =\r\nOMAP_ECC_BCH8_CODE_HW_DETECTION_SW;\r\nelse if (!strcmp(s, "bch16"))\r\nif (gpmc_nand_data->elm_of_node)\r\ngpmc_nand_data->ecc_opt =\r\nOMAP_ECC_BCH16_CODE_HW;\r\nelse\r\npr_err("%s: BCH16 requires ELM support\n", __func__);\r\nelse\r\npr_err("%s: ti,nand-ecc-opt invalid value\n", __func__);\r\nif (!of_property_read_string(child, "ti,nand-xfer-type", &s))\r\nfor (val = 0; val < ARRAY_SIZE(nand_xfer_types); val++)\r\nif (!strcasecmp(s, nand_xfer_types[val])) {\r\ngpmc_nand_data->xfer_type = val;\r\nbreak;\r\n}\r\ngpmc_nand_data->flash_bbt = of_get_nand_on_flash_bbt(child);\r\nval = of_get_nand_bus_width(child);\r\nif (val == 16)\r\ngpmc_nand_data->devsize = NAND_BUSWIDTH_16;\r\ngpmc_read_timings_dt(child, &gpmc_t);\r\ngpmc_nand_init(gpmc_nand_data, &gpmc_t);\r\nreturn 0;\r\n}\r\nstatic int gpmc_probe_nand_child(struct platform_device *pdev,\r\nstruct device_node *child)\r\n{\r\nreturn 0;\r\n}\r\nstatic int gpmc_probe_onenand_child(struct platform_device *pdev,\r\nstruct device_node *child)\r\n{\r\nu32 val;\r\nstruct omap_onenand_platform_data *gpmc_onenand_data;\r\nif (of_property_read_u32(child, "reg", &val) < 0) {\r\ndev_err(&pdev->dev, "%s has no 'reg' property\n",\r\nchild->full_name);\r\nreturn -ENODEV;\r\n}\r\ngpmc_onenand_data = devm_kzalloc(&pdev->dev, sizeof(*gpmc_onenand_data),\r\nGFP_KERNEL);\r\nif (!gpmc_onenand_data)\r\nreturn -ENOMEM;\r\ngpmc_onenand_data->cs = val;\r\ngpmc_onenand_data->of_node = child;\r\ngpmc_onenand_data->dma_channel = -1;\r\nif (!of_property_read_u32(child, "dma-channel", &val))\r\ngpmc_onenand_data->dma_channel = val;\r\ngpmc_onenand_init(gpmc_onenand_data);\r\nreturn 0;\r\n}\r\nstatic int gpmc_probe_onenand_child(struct platform_device *pdev,\r\nstruct device_node *child)\r\n{\r\nreturn 0;\r\n}\r\nstatic int gpmc_probe_generic_child(struct platform_device *pdev,\r\nstruct device_node *child)\r\n{\r\nstruct gpmc_settings gpmc_s;\r\nstruct gpmc_timings gpmc_t;\r\nstruct resource res;\r\nunsigned long base;\r\nconst char *name;\r\nint ret, cs;\r\nu32 val;\r\nif (of_property_read_u32(child, "reg", &cs) < 0) {\r\ndev_err(&pdev->dev, "%s has no 'reg' property\n",\r\nchild->full_name);\r\nreturn -ENODEV;\r\n}\r\nif (of_address_to_resource(child, 0, &res) < 0) {\r\ndev_err(&pdev->dev, "%s has malformed 'reg' property\n",\r\nchild->full_name);\r\nreturn -ENODEV;\r\n}\r\nname = gpmc_cs_get_name(cs);\r\nif (name && child->name && of_node_cmp(child->name, name) == 0)\r\ngoto no_timings;\r\nret = gpmc_cs_request(cs, resource_size(&res), &base);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "cannot request GPMC CS %d\n", cs);\r\nreturn ret;\r\n}\r\ngpmc_cs_set_name(cs, child->name);\r\ngpmc_read_settings_dt(child, &gpmc_s);\r\ngpmc_read_timings_dt(child, &gpmc_t);\r\nif (!gpmc_t.cs_rd_off) {\r\nWARN(1, "enable GPMC debug to configure .dts timings for CS%i\n",\r\ncs);\r\ngpmc_cs_show_timings(cs,\r\n"please add GPMC bootloader timings to .dts");\r\ngoto no_timings;\r\n}\r\ngpmc_cs_disable_mem(cs);\r\nret = gpmc_cs_remap(cs, res.start);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "cannot remap GPMC CS %d to %pa\n",\r\ncs, &res.start);\r\ngoto err;\r\n}\r\nret = of_property_read_u32(child, "bank-width", &gpmc_s.device_width);\r\nif (ret < 0)\r\ngoto err;\r\nret = gpmc_cs_program_settings(cs, &gpmc_s);\r\nif (ret < 0)\r\ngoto err;\r\nret = gpmc_cs_set_timings(cs, &gpmc_t);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to set gpmc timings for: %s\n",\r\nchild->name);\r\ngoto err;\r\n}\r\nval = gpmc_read_reg(GPMC_CONFIG);\r\nval &= ~GPMC_CONFIG_LIMITEDADDRESS;\r\ngpmc_write_reg(GPMC_CONFIG, val);\r\ngpmc_cs_enable_mem(cs);\r\nno_timings:\r\nif (of_platform_device_create(child, NULL, &pdev->dev))\r\nreturn 0;\r\ndev_err(&pdev->dev, "failed to create gpmc child %s\n", child->name);\r\nret = -ENODEV;\r\nerr:\r\ngpmc_cs_free(cs);\r\nreturn ret;\r\n}\r\nstatic int gpmc_probe_dt(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct device_node *child;\r\nconst struct of_device_id *of_id =\r\nof_match_device(gpmc_dt_ids, &pdev->dev);\r\nif (!of_id)\r\nreturn 0;\r\nret = of_property_read_u32(pdev->dev.of_node, "gpmc,num-cs",\r\n&gpmc_cs_num);\r\nif (ret < 0) {\r\npr_err("%s: number of chip-selects not defined\n", __func__);\r\nreturn ret;\r\n} else if (gpmc_cs_num < 1) {\r\npr_err("%s: all chip-selects are disabled\n", __func__);\r\nreturn -EINVAL;\r\n} else if (gpmc_cs_num > GPMC_CS_NUM) {\r\npr_err("%s: number of supported chip-selects cannot be > %d\n",\r\n__func__, GPMC_CS_NUM);\r\nreturn -EINVAL;\r\n}\r\nret = of_property_read_u32(pdev->dev.of_node, "gpmc,num-waitpins",\r\n&gpmc_nr_waitpins);\r\nif (ret < 0) {\r\npr_err("%s: number of wait pins not found!\n", __func__);\r\nreturn ret;\r\n}\r\nfor_each_available_child_of_node(pdev->dev.of_node, child) {\r\nif (!child->name)\r\ncontinue;\r\nif (of_node_cmp(child->name, "nand") == 0)\r\nret = gpmc_probe_nand_child(pdev, child);\r\nelse if (of_node_cmp(child->name, "onenand") == 0)\r\nret = gpmc_probe_onenand_child(pdev, child);\r\nelse if (of_node_cmp(child->name, "ethernet") == 0 ||\r\nof_node_cmp(child->name, "nor") == 0 ||\r\nof_node_cmp(child->name, "uart") == 0)\r\nret = gpmc_probe_generic_child(pdev, child);\r\nif (WARN(ret < 0, "%s: probing gpmc child %s failed\n",\r\n__func__, child->full_name))\r\nof_node_put(child);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpmc_probe_dt(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int gpmc_probe(struct platform_device *pdev)\r\n{\r\nint rc;\r\nu32 l;\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL)\r\nreturn -ENOENT;\r\nphys_base = res->start;\r\nmem_size = resource_size(res);\r\ngpmc_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(gpmc_base))\r\nreturn PTR_ERR(gpmc_base);\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res == NULL)\r\ndev_warn(&pdev->dev, "Failed to get resource: irq\n");\r\nelse\r\ngpmc_irq = res->start;\r\ngpmc_l3_clk = devm_clk_get(&pdev->dev, "fck");\r\nif (IS_ERR(gpmc_l3_clk)) {\r\ndev_err(&pdev->dev, "Failed to get GPMC fck\n");\r\ngpmc_irq = 0;\r\nreturn PTR_ERR(gpmc_l3_clk);\r\n}\r\nif (!clk_get_rate(gpmc_l3_clk)) {\r\ndev_err(&pdev->dev, "Invalid GPMC fck clock rate\n");\r\nreturn -EINVAL;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\ngpmc_dev = &pdev->dev;\r\nl = gpmc_read_reg(GPMC_REVISION);\r\nif (GPMC_REVISION_MAJOR(l) > 0x4)\r\ngpmc_capability = GPMC_HAS_WR_ACCESS | GPMC_HAS_WR_DATA_MUX_BUS;\r\nif (GPMC_REVISION_MAJOR(l) > 0x5)\r\ngpmc_capability |= GPMC_HAS_MUX_AAD;\r\ndev_info(gpmc_dev, "GPMC revision %d.%d\n", GPMC_REVISION_MAJOR(l),\r\nGPMC_REVISION_MINOR(l));\r\ngpmc_mem_init();\r\nif (gpmc_setup_irq() < 0)\r\ndev_warn(gpmc_dev, "gpmc_setup_irq failed\n");\r\nif (!pdev->dev.of_node) {\r\ngpmc_cs_num = GPMC_CS_NUM;\r\ngpmc_nr_waitpins = GPMC_NR_WAITPINS;\r\n}\r\nrc = gpmc_probe_dt(pdev);\r\nif (rc < 0) {\r\npm_runtime_put_sync(&pdev->dev);\r\ndev_err(gpmc_dev, "failed to probe DT parameters\n");\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpmc_remove(struct platform_device *pdev)\r\n{\r\ngpmc_free_irq();\r\ngpmc_mem_exit();\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\ngpmc_dev = NULL;\r\nreturn 0;\r\n}\r\nstatic int gpmc_suspend(struct device *dev)\r\n{\r\nomap3_gpmc_save_context();\r\npm_runtime_put_sync(dev);\r\nreturn 0;\r\n}\r\nstatic int gpmc_resume(struct device *dev)\r\n{\r\npm_runtime_get_sync(dev);\r\nomap3_gpmc_restore_context();\r\nreturn 0;\r\n}\r\nstatic __init int gpmc_init(void)\r\n{\r\nreturn platform_driver_register(&gpmc_driver);\r\n}\r\nstatic __exit void gpmc_exit(void)\r\n{\r\nplatform_driver_unregister(&gpmc_driver);\r\n}\r\nstatic irqreturn_t gpmc_handle_irq(int irq, void *dev)\r\n{\r\nint i;\r\nu32 regval;\r\nregval = gpmc_read_reg(GPMC_IRQSTATUS);\r\nif (!regval)\r\nreturn IRQ_NONE;\r\nfor (i = 0; i < GPMC_NR_IRQ; i++)\r\nif (regval & gpmc_client_irq[i].bitmask)\r\ngeneric_handle_irq(gpmc_client_irq[i].irq);\r\ngpmc_write_reg(GPMC_IRQSTATUS, regval);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid omap3_gpmc_save_context(void)\r\n{\r\nint i;\r\ngpmc_context.sysconfig = gpmc_read_reg(GPMC_SYSCONFIG);\r\ngpmc_context.irqenable = gpmc_read_reg(GPMC_IRQENABLE);\r\ngpmc_context.timeout_ctrl = gpmc_read_reg(GPMC_TIMEOUT_CONTROL);\r\ngpmc_context.config = gpmc_read_reg(GPMC_CONFIG);\r\ngpmc_context.prefetch_config1 = gpmc_read_reg(GPMC_PREFETCH_CONFIG1);\r\ngpmc_context.prefetch_config2 = gpmc_read_reg(GPMC_PREFETCH_CONFIG2);\r\ngpmc_context.prefetch_control = gpmc_read_reg(GPMC_PREFETCH_CONTROL);\r\nfor (i = 0; i < gpmc_cs_num; i++) {\r\ngpmc_context.cs_context[i].is_valid = gpmc_cs_mem_enabled(i);\r\nif (gpmc_context.cs_context[i].is_valid) {\r\ngpmc_context.cs_context[i].config1 =\r\ngpmc_cs_read_reg(i, GPMC_CS_CONFIG1);\r\ngpmc_context.cs_context[i].config2 =\r\ngpmc_cs_read_reg(i, GPMC_CS_CONFIG2);\r\ngpmc_context.cs_context[i].config3 =\r\ngpmc_cs_read_reg(i, GPMC_CS_CONFIG3);\r\ngpmc_context.cs_context[i].config4 =\r\ngpmc_cs_read_reg(i, GPMC_CS_CONFIG4);\r\ngpmc_context.cs_context[i].config5 =\r\ngpmc_cs_read_reg(i, GPMC_CS_CONFIG5);\r\ngpmc_context.cs_context[i].config6 =\r\ngpmc_cs_read_reg(i, GPMC_CS_CONFIG6);\r\ngpmc_context.cs_context[i].config7 =\r\ngpmc_cs_read_reg(i, GPMC_CS_CONFIG7);\r\n}\r\n}\r\n}\r\nvoid omap3_gpmc_restore_context(void)\r\n{\r\nint i;\r\ngpmc_write_reg(GPMC_SYSCONFIG, gpmc_context.sysconfig);\r\ngpmc_write_reg(GPMC_IRQENABLE, gpmc_context.irqenable);\r\ngpmc_write_reg(GPMC_TIMEOUT_CONTROL, gpmc_context.timeout_ctrl);\r\ngpmc_write_reg(GPMC_CONFIG, gpmc_context.config);\r\ngpmc_write_reg(GPMC_PREFETCH_CONFIG1, gpmc_context.prefetch_config1);\r\ngpmc_write_reg(GPMC_PREFETCH_CONFIG2, gpmc_context.prefetch_config2);\r\ngpmc_write_reg(GPMC_PREFETCH_CONTROL, gpmc_context.prefetch_control);\r\nfor (i = 0; i < gpmc_cs_num; i++) {\r\nif (gpmc_context.cs_context[i].is_valid) {\r\ngpmc_cs_write_reg(i, GPMC_CS_CONFIG1,\r\ngpmc_context.cs_context[i].config1);\r\ngpmc_cs_write_reg(i, GPMC_CS_CONFIG2,\r\ngpmc_context.cs_context[i].config2);\r\ngpmc_cs_write_reg(i, GPMC_CS_CONFIG3,\r\ngpmc_context.cs_context[i].config3);\r\ngpmc_cs_write_reg(i, GPMC_CS_CONFIG4,\r\ngpmc_context.cs_context[i].config4);\r\ngpmc_cs_write_reg(i, GPMC_CS_CONFIG5,\r\ngpmc_context.cs_context[i].config5);\r\ngpmc_cs_write_reg(i, GPMC_CS_CONFIG6,\r\ngpmc_context.cs_context[i].config6);\r\ngpmc_cs_write_reg(i, GPMC_CS_CONFIG7,\r\ngpmc_context.cs_context[i].config7);\r\n}\r\n}\r\n}
