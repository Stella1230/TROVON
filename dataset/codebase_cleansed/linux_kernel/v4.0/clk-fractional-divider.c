static unsigned long clk_fd_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_fractional_divider *fd = to_clk_fd(hw);\r\nunsigned long flags = 0;\r\nu32 val, m, n;\r\nu64 ret;\r\nif (fd->lock)\r\nspin_lock_irqsave(fd->lock, flags);\r\nval = clk_readl(fd->reg);\r\nif (fd->lock)\r\nspin_unlock_irqrestore(fd->lock, flags);\r\nm = (val & fd->mmask) >> fd->mshift;\r\nn = (val & fd->nmask) >> fd->nshift;\r\nret = (u64)parent_rate * m;\r\ndo_div(ret, n);\r\nreturn ret;\r\n}\r\nstatic long clk_fd_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_fractional_divider *fd = to_clk_fd(hw);\r\nunsigned maxn = (fd->nmask >> fd->nshift) + 1;\r\nunsigned div;\r\nif (!rate || rate >= *prate)\r\nreturn *prate;\r\ndiv = gcd(*prate, rate);\r\nwhile ((*prate / div) > maxn) {\r\ndiv <<= 1;\r\nrate <<= 1;\r\n}\r\nreturn rate;\r\n}\r\nstatic int clk_fd_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_fractional_divider *fd = to_clk_fd(hw);\r\nunsigned long flags = 0;\r\nunsigned long div;\r\nunsigned n, m;\r\nu32 val;\r\ndiv = gcd(parent_rate, rate);\r\nm = rate / div;\r\nn = parent_rate / div;\r\nif (fd->lock)\r\nspin_lock_irqsave(fd->lock, flags);\r\nval = clk_readl(fd->reg);\r\nval &= ~(fd->mmask | fd->nmask);\r\nval |= (m << fd->mshift) | (n << fd->nshift);\r\nclk_writel(val, fd->reg);\r\nif (fd->lock)\r\nspin_unlock_irqrestore(fd->lock, flags);\r\nreturn 0;\r\n}\r\nstruct clk *clk_register_fractional_divider(struct device *dev,\r\nconst char *name, const char *parent_name, unsigned long flags,\r\nvoid __iomem *reg, u8 mshift, u8 mwidth, u8 nshift, u8 nwidth,\r\nu8 clk_divider_flags, spinlock_t *lock)\r\n{\r\nstruct clk_fractional_divider *fd;\r\nstruct clk_init_data init;\r\nstruct clk *clk;\r\nfd = kzalloc(sizeof(*fd), GFP_KERNEL);\r\nif (!fd) {\r\ndev_err(dev, "could not allocate fractional divider clk\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = name;\r\ninit.ops = &clk_fractional_divider_ops;\r\ninit.flags = flags | CLK_IS_BASIC;\r\ninit.parent_names = parent_name ? &parent_name : NULL;\r\ninit.num_parents = parent_name ? 1 : 0;\r\nfd->reg = reg;\r\nfd->mshift = mshift;\r\nfd->mmask = (BIT(mwidth) - 1) << mshift;\r\nfd->nshift = nshift;\r\nfd->nmask = (BIT(nwidth) - 1) << nshift;\r\nfd->flags = clk_divider_flags;\r\nfd->lock = lock;\r\nfd->hw.init = &init;\r\nclk = clk_register(dev, &fd->hw);\r\nif (IS_ERR(clk))\r\nkfree(fd);\r\nreturn clk;\r\n}
