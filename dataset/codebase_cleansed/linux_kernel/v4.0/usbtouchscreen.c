static int e2i_init(struct usbtouch_usb *usbtouch)\r\n{\r\nint ret;\r\nstruct usb_device *udev = interface_to_usbdev(usbtouch->interface);\r\nret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\n0x01, 0x02, 0x0000, 0x0081,\r\nNULL, 0, USB_CTRL_SET_TIMEOUT);\r\ndev_dbg(&usbtouch->interface->dev,\r\n"%s - usb_control_msg - E2I_RESET - bytes|err: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nstatic int e2i_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\r\n{\r\nint tmp = (pkt[0] << 8) | pkt[1];\r\ndev->x = (pkt[2] << 8) | pkt[3];\r\ndev->y = (pkt[4] << 8) | pkt[5];\r\ntmp = tmp - 0xA000;\r\ndev->touch = (tmp > 0);\r\ndev->press = (tmp > 0 ? tmp : 0);\r\nreturn 1;\r\n}\r\nstatic int egalax_init(struct usbtouch_usb *usbtouch)\r\n{\r\nint ret, i;\r\nunsigned char *buf;\r\nstruct usb_device *udev = interface_to_usbdev(usbtouch->interface);\r\nbuf = kmalloc(3, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nbuf[0] = EGALAX_PKT_TYPE_DIAG;\r\nbuf[1] = 1;\r\nbuf[2] = 'A';\r\nfor (i = 0; i < 3; i++) {\r\nret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, 0, buf, 3,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (ret >= 0) {\r\nret = 0;\r\nbreak;\r\n}\r\nif (ret != -EPIPE)\r\nbreak;\r\n}\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int egalax_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\r\n{\r\nif ((pkt[0] & EGALAX_PKT_TYPE_MASK) != EGALAX_PKT_TYPE_REPT)\r\nreturn 0;\r\ndev->x = ((pkt[3] & 0x0F) << 7) | (pkt[4] & 0x7F);\r\ndev->y = ((pkt[1] & 0x0F) << 7) | (pkt[2] & 0x7F);\r\ndev->touch = pkt[0] & 0x01;\r\nreturn 1;\r\n}\r\nstatic int egalax_get_pkt_len(unsigned char *buf, int len)\r\n{\r\nswitch (buf[0] & EGALAX_PKT_TYPE_MASK) {\r\ncase EGALAX_PKT_TYPE_REPT:\r\nreturn 5;\r\ncase EGALAX_PKT_TYPE_DIAG:\r\nif (len < 2)\r\nreturn -1;\r\nreturn buf[1] + 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int etouch_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\r\n{\r\nif ((pkt[0] & ETOUCH_PKT_TYPE_MASK) != ETOUCH_PKT_TYPE_REPT &&\r\n(pkt[0] & ETOUCH_PKT_TYPE_MASK) != ETOUCH_PKT_TYPE_REPT2)\r\nreturn 0;\r\ndev->x = ((pkt[1] & 0x1F) << 7) | (pkt[2] & 0x7F);\r\ndev->y = ((pkt[3] & 0x1F) << 7) | (pkt[4] & 0x7F);\r\ndev->touch = pkt[0] & 0x01;\r\nreturn 1;\r\n}\r\nstatic int etouch_get_pkt_len(unsigned char *buf, int len)\r\n{\r\nswitch (buf[0] & ETOUCH_PKT_TYPE_MASK) {\r\ncase ETOUCH_PKT_TYPE_REPT:\r\ncase ETOUCH_PKT_TYPE_REPT2:\r\nreturn 5;\r\ncase ETOUCH_PKT_TYPE_DIAG:\r\nif (len < 2)\r\nreturn -1;\r\nreturn buf[1] + 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int panjit_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\r\n{\r\ndev->x = ((pkt[2] & 0x0F) << 8) | pkt[1];\r\ndev->y = ((pkt[4] & 0x0F) << 8) | pkt[3];\r\ndev->touch = pkt[0] & 0x01;\r\nreturn 1;\r\n}\r\nstatic int mtouch_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\r\n{\r\nif (hwcalib_xy) {\r\ndev->x = (pkt[4] << 8) | pkt[3];\r\ndev->y = 0xffff - ((pkt[6] << 8) | pkt[5]);\r\n} else {\r\ndev->x = (pkt[8] << 8) | pkt[7];\r\ndev->y = (pkt[10] << 8) | pkt[9];\r\n}\r\ndev->touch = (pkt[2] & 0x40) ? 1 : 0;\r\nreturn 1;\r\n}\r\nstatic int mtouch_init(struct usbtouch_usb *usbtouch)\r\n{\r\nint ret, i;\r\nstruct usb_device *udev = interface_to_usbdev(usbtouch->interface);\r\nret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nMTOUCHUSB_RESET,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n1, 0, NULL, 0, USB_CTRL_SET_TIMEOUT);\r\ndev_dbg(&usbtouch->interface->dev,\r\n"%s - usb_control_msg - MTOUCHUSB_RESET - bytes|err: %d\n",\r\n__func__, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(150);\r\nfor (i = 0; i < 3; i++) {\r\nret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\nMTOUCHUSB_ASYNC_REPORT,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n1, 1, NULL, 0, USB_CTRL_SET_TIMEOUT);\r\ndev_dbg(&usbtouch->interface->dev,\r\n"%s - usb_control_msg - MTOUCHUSB_ASYNC_REPORT - bytes|err: %d\n",\r\n__func__, ret);\r\nif (ret >= 0)\r\nbreak;\r\nif (ret != -EPIPE)\r\nreturn ret;\r\n}\r\nif (hwcalib_xy) {\r\ninput_set_abs_params(usbtouch->input, ABS_X, 0, 0xffff, 0, 0);\r\ninput_set_abs_params(usbtouch->input, ABS_Y, 0, 0xffff, 0, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int itm_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\r\n{\r\nint touch;\r\ndev->press = ((pkt[2] & 0x01) << 7) | (pkt[5] & 0x7F);\r\ntouch = ~pkt[7] & 0x20;\r\nif (!touch) {\r\nif (dev->touch) {\r\ndev->touch = 0;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\ndev->x = ((pkt[0] & 0x1F) << 7) | (pkt[3] & 0x7F);\r\ndev->y = ((pkt[1] & 0x1F) << 7) | (pkt[4] & 0x7F);\r\ndev->touch = touch;\r\nreturn 1;\r\n}\r\nstatic int eturbo_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\r\n{\r\nunsigned int shift;\r\nif (!(pkt[0] & 0x80))\r\nreturn 0;\r\nshift = (6 - (pkt[0] & 0x03));\r\ndev->x = ((pkt[3] << 7) | pkt[4]) >> shift;\r\ndev->y = ((pkt[1] << 7) | pkt[2]) >> shift;\r\ndev->touch = (pkt[0] & 0x10) ? 1 : 0;\r\nreturn 1;\r\n}\r\nstatic int eturbo_get_pkt_len(unsigned char *buf, int len)\r\n{\r\nif (buf[0] & 0x80)\r\nreturn 5;\r\nif (buf[0] == 0x01)\r\nreturn 3;\r\nreturn 0;\r\n}\r\nstatic int gunze_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\r\n{\r\nif (!(pkt[0] & 0x80) || ((pkt[1] | pkt[2] | pkt[3]) & 0x80))\r\nreturn 0;\r\ndev->x = ((pkt[0] & 0x1F) << 7) | (pkt[2] & 0x7F);\r\ndev->y = ((pkt[1] & 0x1F) << 7) | (pkt[3] & 0x7F);\r\ndev->touch = pkt[0] & 0x20;\r\nreturn 1;\r\n}\r\nstatic int dmc_tsc10_init(struct usbtouch_usb *usbtouch)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(usbtouch->interface);\r\nint ret = -ENOMEM;\r\nunsigned char *buf;\r\nbuf = kmalloc(2, GFP_NOIO);\r\nif (!buf)\r\ngoto err_nobuf;\r\nbuf[0] = buf[1] = 0xFF;\r\nret = usb_control_msg(dev, usb_rcvctrlpipe (dev, 0),\r\nTSC10_CMD_RESET,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, 0, buf, 2, USB_CTRL_SET_TIMEOUT);\r\nif (ret < 0)\r\ngoto err_out;\r\nif (buf[0] != 0x06) {\r\nret = -ENODEV;\r\ngoto err_out;\r\n}\r\nbuf[0] = buf[1] = 0xFF;\r\nret = usb_control_msg(dev, usb_rcvctrlpipe (dev, 0),\r\nTSC10_CMD_RATE,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nTSC10_RATE_150, 0, buf, 2, USB_CTRL_SET_TIMEOUT);\r\nif (ret < 0)\r\ngoto err_out;\r\nif ((buf[0] != 0x06) && (buf[0] != 0x15 || buf[1] != 0x01)) {\r\nret = -ENODEV;\r\ngoto err_out;\r\n}\r\nret = usb_control_msg(dev, usb_rcvctrlpipe (dev, 0),\r\nTSC10_CMD_DATA1,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, 0, NULL, 0, USB_CTRL_SET_TIMEOUT);\r\nerr_out:\r\nkfree(buf);\r\nerr_nobuf:\r\nreturn ret;\r\n}\r\nstatic int dmc_tsc10_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\r\n{\r\ndev->x = ((pkt[2] & 0x03) << 8) | pkt[1];\r\ndev->y = ((pkt[4] & 0x03) << 8) | pkt[3];\r\ndev->touch = pkt[0] & 0x01;\r\nreturn 1;\r\n}\r\nstatic int irtouch_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\r\n{\r\ndev->x = (pkt[3] << 8) | pkt[2];\r\ndev->y = (pkt[5] << 8) | pkt[4];\r\ndev->touch = (pkt[1] & 0x03) ? 1 : 0;\r\nreturn 1;\r\n}\r\nstatic int tc45usb_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\r\n{\r\ndev->x = ((pkt[2] & 0x0F) << 8) | pkt[1];\r\ndev->y = ((pkt[4] & 0x0F) << 8) | pkt[3];\r\ndev->touch = pkt[0] & 0x01;\r\nreturn 1;\r\n}\r\nstatic int idealtek_get_pkt_len(unsigned char *buf, int len)\r\n{\r\nif (buf[0] & 0x80)\r\nreturn 5;\r\nif (buf[0] == 0x01)\r\nreturn len;\r\nreturn 0;\r\n}\r\nstatic int idealtek_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\r\n{\r\nswitch (pkt[0] & 0x98) {\r\ncase 0x88:\r\ndev->x = (pkt[1] << 5) | (pkt[2] >> 2);\r\ndev->y = (pkt[3] << 5) | (pkt[4] >> 2);\r\ndev->touch = (pkt[0] & 0x40) ? 1 : 0;\r\nreturn 1;\r\ncase 0x98:\r\ndev->x = (pkt[2] << 5) | (pkt[1] >> 2);\r\ndev->y = (pkt[4] << 5) | (pkt[3] >> 2);\r\ndev->touch = (pkt[0] & 0x40) ? 1 : 0;\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int general_touch_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\r\n{\r\ndev->x = (pkt[2] << 8) | pkt[1];\r\ndev->y = (pkt[4] << 8) | pkt[3];\r\ndev->press = pkt[5] & 0xff;\r\ndev->touch = pkt[0] & 0x01;\r\nreturn 1;\r\n}\r\nstatic int gotop_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\r\n{\r\ndev->x = ((pkt[1] & 0x38) << 4) | pkt[2];\r\ndev->y = ((pkt[1] & 0x07) << 7) | pkt[3];\r\ndev->touch = pkt[0] & 0x01;\r\nreturn 1;\r\n}\r\nstatic int jastec_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\r\n{\r\ndev->x = ((pkt[0] & 0x3f) << 6) | (pkt[2] & 0x3f);\r\ndev->y = ((pkt[1] & 0x3f) << 6) | (pkt[3] & 0x3f);\r\ndev->touch = (pkt[0] & 0x40) >> 6;\r\nreturn 1;\r\n}\r\nstatic int zytronic_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\r\n{\r\nstruct usb_interface *intf = dev->interface;\r\nswitch (pkt[0]) {\r\ncase 0x3A:\r\ndev_dbg(&intf->dev, "%s: Command response %d\n", __func__, pkt[1]);\r\nbreak;\r\ncase 0xC0:\r\ndev->x = (pkt[1] & 0x7f) | ((pkt[2] & 0x07) << 7);\r\ndev->y = (pkt[3] & 0x7f) | ((pkt[4] & 0x07) << 7);\r\ndev->touch = 1;\r\ndev_dbg(&intf->dev, "%s: down %d,%d\n", __func__, dev->x, dev->y);\r\nreturn 1;\r\ncase 0x80:\r\ndev->x = (pkt[1] & 0x7f) | ((pkt[2] & 0x07) << 7);\r\ndev->y = (pkt[3] & 0x7f) | ((pkt[4] & 0x07) << 7);\r\ndev->touch = 0;\r\ndev_dbg(&intf->dev, "%s: up %d,%d\n", __func__, dev->x, dev->y);\r\nreturn 1;\r\ndefault:\r\ndev_dbg(&intf->dev, "%s: Unknown return %d\n", __func__, pkt[0]);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void nexio_ack_complete(struct urb *urb)\r\n{\r\n}\r\nstatic int nexio_alloc(struct usbtouch_usb *usbtouch)\r\n{\r\nstruct nexio_priv *priv;\r\nint ret = -ENOMEM;\r\nusbtouch->priv = kmalloc(sizeof(struct nexio_priv), GFP_KERNEL);\r\nif (!usbtouch->priv)\r\ngoto out_buf;\r\npriv = usbtouch->priv;\r\npriv->ack_buf = kmemdup(nexio_ack_pkt, sizeof(nexio_ack_pkt),\r\nGFP_KERNEL);\r\nif (!priv->ack_buf)\r\ngoto err_priv;\r\npriv->ack = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!priv->ack) {\r\ndev_dbg(&usbtouch->interface->dev,\r\n"%s - usb_alloc_urb failed: usbtouch->ack\n", __func__);\r\ngoto err_ack_buf;\r\n}\r\nreturn 0;\r\nerr_ack_buf:\r\nkfree(priv->ack_buf);\r\nerr_priv:\r\nkfree(priv);\r\nout_buf:\r\nreturn ret;\r\n}\r\nstatic int nexio_init(struct usbtouch_usb *usbtouch)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(usbtouch->interface);\r\nstruct usb_host_interface *interface = usbtouch->interface->cur_altsetting;\r\nstruct nexio_priv *priv = usbtouch->priv;\r\nint ret = -ENOMEM;\r\nint actual_len, i;\r\nunsigned char *buf;\r\nchar *firmware_ver = NULL, *device_name = NULL;\r\nint input_ep = 0, output_ep = 0;\r\nfor (i = 0; i < interface->desc.bNumEndpoints; i++) {\r\nif (!input_ep &&\r\nusb_endpoint_dir_in(&interface->endpoint[i].desc))\r\ninput_ep = interface->endpoint[i].desc.bEndpointAddress;\r\nif (!output_ep &&\r\nusb_endpoint_dir_out(&interface->endpoint[i].desc))\r\noutput_ep = interface->endpoint[i].desc.bEndpointAddress;\r\n}\r\nif (!input_ep || !output_ep)\r\nreturn -ENXIO;\r\nbuf = kmalloc(NEXIO_BUFSIZE, GFP_NOIO);\r\nif (!buf)\r\ngoto out_buf;\r\nfor (i = 0; i < 2; i++) {\r\nret = usb_bulk_msg(dev, usb_rcvbulkpipe(dev, input_ep),\r\nbuf, NEXIO_BUFSIZE, &actual_len,\r\nNEXIO_TIMEOUT);\r\nif (ret < 0)\r\ngoto out_buf;\r\n}\r\nmemcpy(buf, nexio_init_pkt, sizeof(nexio_init_pkt));\r\nret = usb_bulk_msg(dev, usb_sndbulkpipe(dev, output_ep),\r\nbuf, sizeof(nexio_init_pkt), &actual_len,\r\nNEXIO_TIMEOUT);\r\nif (ret < 0)\r\ngoto out_buf;\r\nfor (i = 0; i < 3; i++) {\r\nmemset(buf, 0, NEXIO_BUFSIZE);\r\nret = usb_bulk_msg(dev, usb_rcvbulkpipe(dev, input_ep),\r\nbuf, NEXIO_BUFSIZE, &actual_len,\r\nNEXIO_TIMEOUT);\r\nif (ret < 0 || actual_len < 1 || buf[1] != actual_len)\r\ncontinue;\r\nswitch (buf[0]) {\r\ncase 0x83:\r\nif (!firmware_ver)\r\nfirmware_ver = kstrdup(&buf[2], GFP_NOIO);\r\nbreak;\r\ncase 0x84:\r\nif (!device_name)\r\ndevice_name = kstrdup(&buf[2], GFP_NOIO);\r\nbreak;\r\n}\r\n}\r\nprintk(KERN_INFO "Nexio device: %s, firmware version: %s\n",\r\ndevice_name, firmware_ver);\r\nkfree(firmware_ver);\r\nkfree(device_name);\r\nusb_fill_bulk_urb(priv->ack, dev, usb_sndbulkpipe(dev, output_ep),\r\npriv->ack_buf, sizeof(nexio_ack_pkt),\r\nnexio_ack_complete, usbtouch);\r\nret = 0;\r\nout_buf:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void nexio_exit(struct usbtouch_usb *usbtouch)\r\n{\r\nstruct nexio_priv *priv = usbtouch->priv;\r\nusb_kill_urb(priv->ack);\r\nusb_free_urb(priv->ack);\r\nkfree(priv->ack_buf);\r\nkfree(priv);\r\n}\r\nstatic int nexio_read_data(struct usbtouch_usb *usbtouch, unsigned char *pkt)\r\n{\r\nstruct nexio_touch_packet *packet = (void *) pkt;\r\nstruct nexio_priv *priv = usbtouch->priv;\r\nunsigned int data_len = be16_to_cpu(packet->data_len);\r\nunsigned int x_len = be16_to_cpu(packet->x_len);\r\nunsigned int y_len = be16_to_cpu(packet->y_len);\r\nint x, y, begin_x, begin_y, end_x, end_y, w, h, ret;\r\nif ((pkt[0] & 0xe0) != 0xe0)\r\nreturn 0;\r\nif (data_len > 0xff)\r\ndata_len -= 0x100;\r\nif (x_len > 0xff)\r\nx_len -= 0x80;\r\nret = usb_submit_urb(priv->ack, GFP_ATOMIC);\r\nif (!usbtouch->type->max_xc) {\r\nusbtouch->type->max_xc = 2 * x_len;\r\ninput_set_abs_params(usbtouch->input, ABS_X,\r\n0, usbtouch->type->max_xc, 0, 0);\r\nusbtouch->type->max_yc = 2 * y_len;\r\ninput_set_abs_params(usbtouch->input, ABS_Y,\r\n0, usbtouch->type->max_yc, 0, 0);\r\n}\r\nbegin_x = end_x = begin_y = end_y = -1;\r\nfor (x = 0; x < x_len; x++) {\r\nif (begin_x == -1 && packet->data[x] > NEXIO_THRESHOLD) {\r\nbegin_x = x;\r\ncontinue;\r\n}\r\nif (end_x == -1 && begin_x != -1 && packet->data[x] < NEXIO_THRESHOLD) {\r\nend_x = x - 1;\r\nfor (y = x_len; y < data_len; y++) {\r\nif (begin_y == -1 && packet->data[y] > NEXIO_THRESHOLD) {\r\nbegin_y = y - x_len;\r\ncontinue;\r\n}\r\nif (end_y == -1 &&\r\nbegin_y != -1 && packet->data[y] < NEXIO_THRESHOLD) {\r\nend_y = y - 1 - x_len;\r\nw = end_x - begin_x;\r\nh = end_y - begin_y;\r\n#if 0\r\ninput_report_abs(usbtouch->input,\r\nABS_MT_TOUCH_MAJOR, max(w,h));\r\ninput_report_abs(usbtouch->input,\r\nABS_MT_TOUCH_MINOR, min(x,h));\r\ninput_report_abs(usbtouch->input,\r\nABS_MT_POSITION_X, 2*begin_x+w);\r\ninput_report_abs(usbtouch->input,\r\nABS_MT_POSITION_Y, 2*begin_y+h);\r\ninput_report_abs(usbtouch->input,\r\nABS_MT_ORIENTATION, w > h);\r\ninput_mt_sync(usbtouch->input);\r\n#endif\r\nusbtouch->x = 2 * begin_x + w;\r\nusbtouch->y = 2 * begin_y + h;\r\nusbtouch->touch = packet->flags & 0x01;\r\nbegin_y = end_y = -1;\r\nreturn 1;\r\n}\r\n}\r\nbegin_x = end_x = -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int elo_read_data(struct usbtouch_usb *dev, unsigned char *pkt)\r\n{\r\ndev->x = (pkt[3] << 8) | pkt[2];\r\ndev->y = (pkt[5] << 8) | pkt[4];\r\ndev->touch = pkt[6] > 0;\r\ndev->press = pkt[6];\r\nreturn 1;\r\n}\r\nstatic void usbtouch_process_pkt(struct usbtouch_usb *usbtouch,\r\nunsigned char *pkt, int len)\r\n{\r\nstruct usbtouch_device_info *type = usbtouch->type;\r\nif (!type->read_data(usbtouch, pkt))\r\nreturn;\r\ninput_report_key(usbtouch->input, BTN_TOUCH, usbtouch->touch);\r\nif (swap_xy) {\r\ninput_report_abs(usbtouch->input, ABS_X, usbtouch->y);\r\ninput_report_abs(usbtouch->input, ABS_Y, usbtouch->x);\r\n} else {\r\ninput_report_abs(usbtouch->input, ABS_X, usbtouch->x);\r\ninput_report_abs(usbtouch->input, ABS_Y, usbtouch->y);\r\n}\r\nif (type->max_press)\r\ninput_report_abs(usbtouch->input, ABS_PRESSURE, usbtouch->press);\r\ninput_sync(usbtouch->input);\r\n}\r\nstatic void usbtouch_process_multi(struct usbtouch_usb *usbtouch,\r\nunsigned char *pkt, int len)\r\n{\r\nunsigned char *buffer;\r\nint pkt_len, pos, buf_len, tmp;\r\nif (unlikely(usbtouch->buf_len)) {\r\npkt_len = usbtouch->type->get_pkt_len(\r\nusbtouch->buffer, usbtouch->buf_len);\r\nif (unlikely(!pkt_len))\r\ngoto out_flush_buf;\r\nif (unlikely(pkt_len < 0)) {\r\nint append = -pkt_len;\r\nif (unlikely(append > len))\r\nappend = len;\r\nif (usbtouch->buf_len + append >= usbtouch->type->rept_size)\r\ngoto out_flush_buf;\r\nmemcpy(usbtouch->buffer + usbtouch->buf_len, pkt, append);\r\nusbtouch->buf_len += append;\r\npkt_len = usbtouch->type->get_pkt_len(\r\nusbtouch->buffer, usbtouch->buf_len);\r\nif (pkt_len < 0)\r\nreturn;\r\n}\r\ntmp = pkt_len - usbtouch->buf_len;\r\nif (usbtouch->buf_len + tmp >= usbtouch->type->rept_size)\r\ngoto out_flush_buf;\r\nmemcpy(usbtouch->buffer + usbtouch->buf_len, pkt, tmp);\r\nusbtouch_process_pkt(usbtouch, usbtouch->buffer, pkt_len);\r\nbuffer = pkt + tmp;\r\nbuf_len = len - tmp;\r\n} else {\r\nbuffer = pkt;\r\nbuf_len = len;\r\n}\r\npos = 0;\r\nwhile (pos < buf_len) {\r\npkt_len = usbtouch->type->get_pkt_len(buffer + pos,\r\nbuf_len - pos);\r\nif (unlikely(!pkt_len)) {\r\npos++;\r\ncontinue;\r\n}\r\nif (likely((pkt_len > 0) && (pkt_len <= buf_len - pos))) {\r\nusbtouch_process_pkt(usbtouch, buffer + pos, pkt_len);\r\n} else {\r\nmemcpy(usbtouch->buffer, buffer + pos, buf_len - pos);\r\nusbtouch->buf_len = buf_len - pos;\r\nreturn;\r\n}\r\npos += pkt_len;\r\n}\r\nout_flush_buf:\r\nusbtouch->buf_len = 0;\r\nreturn;\r\n}\r\nstatic void usbtouch_irq(struct urb *urb)\r\n{\r\nstruct usbtouch_usb *usbtouch = urb->context;\r\nstruct device *dev = &usbtouch->interface->dev;\r\nint retval;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ETIME:\r\ndev_dbg(dev,\r\n"%s - urb timed out - was the device unplugged?\n",\r\n__func__);\r\nreturn;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ncase -EPIPE:\r\ndev_dbg(dev, "%s - urb shutting down with status: %d\n",\r\n__func__, urb->status);\r\nreturn;\r\ndefault:\r\ndev_dbg(dev, "%s - nonzero urb status received: %d\n",\r\n__func__, urb->status);\r\ngoto exit;\r\n}\r\nusbtouch->type->process_pkt(usbtouch, usbtouch->data, urb->actual_length);\r\nexit:\r\nusb_mark_last_busy(interface_to_usbdev(usbtouch->interface));\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(dev, "%s - usb_submit_urb failed with result: %d\n",\r\n__func__, retval);\r\n}\r\nstatic int usbtouch_open(struct input_dev *input)\r\n{\r\nstruct usbtouch_usb *usbtouch = input_get_drvdata(input);\r\nint r;\r\nusbtouch->irq->dev = interface_to_usbdev(usbtouch->interface);\r\nr = usb_autopm_get_interface(usbtouch->interface) ? -EIO : 0;\r\nif (r < 0)\r\ngoto out;\r\nif (!usbtouch->type->irq_always) {\r\nif (usb_submit_urb(usbtouch->irq, GFP_KERNEL)) {\r\nr = -EIO;\r\ngoto out_put;\r\n}\r\n}\r\nusbtouch->interface->needs_remote_wakeup = 1;\r\nout_put:\r\nusb_autopm_put_interface(usbtouch->interface);\r\nout:\r\nreturn r;\r\n}\r\nstatic void usbtouch_close(struct input_dev *input)\r\n{\r\nstruct usbtouch_usb *usbtouch = input_get_drvdata(input);\r\nint r;\r\nif (!usbtouch->type->irq_always)\r\nusb_kill_urb(usbtouch->irq);\r\nr = usb_autopm_get_interface(usbtouch->interface);\r\nusbtouch->interface->needs_remote_wakeup = 0;\r\nif (!r)\r\nusb_autopm_put_interface(usbtouch->interface);\r\n}\r\nstatic int usbtouch_suspend\r\n(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct usbtouch_usb *usbtouch = usb_get_intfdata(intf);\r\nusb_kill_urb(usbtouch->irq);\r\nreturn 0;\r\n}\r\nstatic int usbtouch_resume(struct usb_interface *intf)\r\n{\r\nstruct usbtouch_usb *usbtouch = usb_get_intfdata(intf);\r\nstruct input_dev *input = usbtouch->input;\r\nint result = 0;\r\nmutex_lock(&input->mutex);\r\nif (input->users || usbtouch->type->irq_always)\r\nresult = usb_submit_urb(usbtouch->irq, GFP_NOIO);\r\nmutex_unlock(&input->mutex);\r\nreturn result;\r\n}\r\nstatic int usbtouch_reset_resume(struct usb_interface *intf)\r\n{\r\nstruct usbtouch_usb *usbtouch = usb_get_intfdata(intf);\r\nstruct input_dev *input = usbtouch->input;\r\nint err = 0;\r\nif (usbtouch->type->init) {\r\nerr = usbtouch->type->init(usbtouch);\r\nif (err) {\r\ndev_dbg(&intf->dev,\r\n"%s - type->init() failed, err: %d\n",\r\n__func__, err);\r\nreturn err;\r\n}\r\n}\r\nmutex_lock(&input->mutex);\r\nif (input->users)\r\nerr = usb_submit_urb(usbtouch->irq, GFP_NOIO);\r\nmutex_unlock(&input->mutex);\r\nreturn err;\r\n}\r\nstatic void usbtouch_free_buffers(struct usb_device *udev,\r\nstruct usbtouch_usb *usbtouch)\r\n{\r\nusb_free_coherent(udev, usbtouch->data_size,\r\nusbtouch->data, usbtouch->data_dma);\r\nkfree(usbtouch->buffer);\r\n}\r\nstatic struct usb_endpoint_descriptor *\r\nusbtouch_get_input_endpoint(struct usb_host_interface *interface)\r\n{\r\nint i;\r\nfor (i = 0; i < interface->desc.bNumEndpoints; i++)\r\nif (usb_endpoint_dir_in(&interface->endpoint[i].desc))\r\nreturn &interface->endpoint[i].desc;\r\nreturn NULL;\r\n}\r\nstatic int usbtouch_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usbtouch_usb *usbtouch;\r\nstruct input_dev *input_dev;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct usbtouch_device_info *type;\r\nint err = -ENOMEM;\r\nif (id->driver_info == DEVTYPE_IGNORE)\r\nreturn -ENODEV;\r\nendpoint = usbtouch_get_input_endpoint(intf->cur_altsetting);\r\nif (!endpoint)\r\nreturn -ENXIO;\r\nusbtouch = kzalloc(sizeof(struct usbtouch_usb), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!usbtouch || !input_dev)\r\ngoto out_free;\r\ntype = &usbtouch_dev_info[id->driver_info];\r\nusbtouch->type = type;\r\nif (!type->process_pkt)\r\ntype->process_pkt = usbtouch_process_pkt;\r\nusbtouch->data_size = type->rept_size;\r\nif (type->get_pkt_len) {\r\nusbtouch->data_size = min(usbtouch->data_size,\r\nusb_endpoint_maxp(endpoint));\r\n}\r\nusbtouch->data = usb_alloc_coherent(udev, usbtouch->data_size,\r\nGFP_KERNEL, &usbtouch->data_dma);\r\nif (!usbtouch->data)\r\ngoto out_free;\r\nif (type->get_pkt_len) {\r\nusbtouch->buffer = kmalloc(type->rept_size, GFP_KERNEL);\r\nif (!usbtouch->buffer)\r\ngoto out_free_buffers;\r\n}\r\nusbtouch->irq = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!usbtouch->irq) {\r\ndev_dbg(&intf->dev,\r\n"%s - usb_alloc_urb failed: usbtouch->irq\n", __func__);\r\ngoto out_free_buffers;\r\n}\r\nusbtouch->interface = intf;\r\nusbtouch->input = input_dev;\r\nif (udev->manufacturer)\r\nstrlcpy(usbtouch->name, udev->manufacturer, sizeof(usbtouch->name));\r\nif (udev->product) {\r\nif (udev->manufacturer)\r\nstrlcat(usbtouch->name, " ", sizeof(usbtouch->name));\r\nstrlcat(usbtouch->name, udev->product, sizeof(usbtouch->name));\r\n}\r\nif (!strlen(usbtouch->name))\r\nsnprintf(usbtouch->name, sizeof(usbtouch->name),\r\n"USB Touchscreen %04x:%04x",\r\nle16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct));\r\nusb_make_path(udev, usbtouch->phys, sizeof(usbtouch->phys));\r\nstrlcat(usbtouch->phys, "/input0", sizeof(usbtouch->phys));\r\ninput_dev->name = usbtouch->name;\r\ninput_dev->phys = usbtouch->phys;\r\nusb_to_input_id(udev, &input_dev->id);\r\ninput_dev->dev.parent = &intf->dev;\r\ninput_set_drvdata(input_dev, usbtouch);\r\ninput_dev->open = usbtouch_open;\r\ninput_dev->close = usbtouch_close;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\ninput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(input_dev, ABS_X, type->min_xc, type->max_xc, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, type->min_yc, type->max_yc, 0, 0);\r\nif (type->max_press)\r\ninput_set_abs_params(input_dev, ABS_PRESSURE, type->min_press,\r\ntype->max_press, 0, 0);\r\nif (usb_endpoint_type(endpoint) == USB_ENDPOINT_XFER_INT)\r\nusb_fill_int_urb(usbtouch->irq, udev,\r\nusb_rcvintpipe(udev, endpoint->bEndpointAddress),\r\nusbtouch->data, usbtouch->data_size,\r\nusbtouch_irq, usbtouch, endpoint->bInterval);\r\nelse\r\nusb_fill_bulk_urb(usbtouch->irq, udev,\r\nusb_rcvbulkpipe(udev, endpoint->bEndpointAddress),\r\nusbtouch->data, usbtouch->data_size,\r\nusbtouch_irq, usbtouch);\r\nusbtouch->irq->dev = udev;\r\nusbtouch->irq->transfer_dma = usbtouch->data_dma;\r\nusbtouch->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nif (type->alloc) {\r\nerr = type->alloc(usbtouch);\r\nif (err) {\r\ndev_dbg(&intf->dev,\r\n"%s - type->alloc() failed, err: %d\n",\r\n__func__, err);\r\ngoto out_free_urb;\r\n}\r\n}\r\nif (type->init) {\r\nerr = type->init(usbtouch);\r\nif (err) {\r\ndev_dbg(&intf->dev,\r\n"%s - type->init() failed, err: %d\n",\r\n__func__, err);\r\ngoto out_do_exit;\r\n}\r\n}\r\nerr = input_register_device(usbtouch->input);\r\nif (err) {\r\ndev_dbg(&intf->dev,\r\n"%s - input_register_device failed, err: %d\n",\r\n__func__, err);\r\ngoto out_do_exit;\r\n}\r\nusb_set_intfdata(intf, usbtouch);\r\nif (usbtouch->type->irq_always) {\r\nusb_autopm_get_interface(intf);\r\nerr = usb_submit_urb(usbtouch->irq, GFP_KERNEL);\r\nif (err) {\r\nusb_autopm_put_interface(intf);\r\ndev_err(&intf->dev,\r\n"%s - usb_submit_urb failed with result: %d\n",\r\n__func__, err);\r\ngoto out_unregister_input;\r\n}\r\n}\r\nreturn 0;\r\nout_unregister_input:\r\ninput_unregister_device(input_dev);\r\ninput_dev = NULL;\r\nout_do_exit:\r\nif (type->exit)\r\ntype->exit(usbtouch);\r\nout_free_urb:\r\nusb_free_urb(usbtouch->irq);\r\nout_free_buffers:\r\nusbtouch_free_buffers(udev, usbtouch);\r\nout_free:\r\ninput_free_device(input_dev);\r\nkfree(usbtouch);\r\nreturn err;\r\n}\r\nstatic void usbtouch_disconnect(struct usb_interface *intf)\r\n{\r\nstruct usbtouch_usb *usbtouch = usb_get_intfdata(intf);\r\nif (!usbtouch)\r\nreturn;\r\ndev_dbg(&intf->dev,\r\n"%s - usbtouch is initialized, cleaning up\n", __func__);\r\nusb_set_intfdata(intf, NULL);\r\ninput_unregister_device(usbtouch->input);\r\nusb_free_urb(usbtouch->irq);\r\nif (usbtouch->type->exit)\r\nusbtouch->type->exit(usbtouch);\r\nusbtouch_free_buffers(interface_to_usbdev(intf), usbtouch);\r\nkfree(usbtouch);\r\n}
