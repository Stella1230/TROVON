static ssize_t twl_sysfs_aen_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *outbuf, loff_t offset, size_t count)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nTW_Device_Extension *tw_dev = (TW_Device_Extension *)shost->hostdata;\r\nunsigned long flags = 0;\r\nssize_t ret;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nspin_lock_irqsave(tw_dev->host->host_lock, flags);\r\nret = memory_read_from_buffer(outbuf, count, &offset, tw_dev->event_queue[0], sizeof(TW_Event) * TW_Q_LENGTH);\r\nspin_unlock_irqrestore(tw_dev->host->host_lock, flags);\r\nreturn ret;\r\n}\r\nstatic ssize_t twl_sysfs_compat_info(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *outbuf, loff_t offset, size_t count)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nTW_Device_Extension *tw_dev = (TW_Device_Extension *)shost->hostdata;\r\nunsigned long flags = 0;\r\nssize_t ret;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nspin_lock_irqsave(tw_dev->host->host_lock, flags);\r\nret = memory_read_from_buffer(outbuf, count, &offset, &tw_dev->tw_compat_info, sizeof(TW_Compatibility_Info));\r\nspin_unlock_irqrestore(tw_dev->host->host_lock, flags);\r\nreturn ret;\r\n}\r\nstatic ssize_t twl_show_stats(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *host = class_to_shost(dev);\r\nTW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;\r\nunsigned long flags = 0;\r\nssize_t len;\r\nspin_lock_irqsave(tw_dev->host->host_lock, flags);\r\nlen = snprintf(buf, PAGE_SIZE, "3w-sas Driver version: %s\n"\r\n"Current commands posted: %4d\n"\r\n"Max commands posted: %4d\n"\r\n"Last sgl length: %4d\n"\r\n"Max sgl length: %4d\n"\r\n"Last sector count: %4d\n"\r\n"Max sector count: %4d\n"\r\n"SCSI Host Resets: %4d\n"\r\n"AEN's: %4d\n",\r\nTW_DRIVER_VERSION,\r\ntw_dev->posted_request_count,\r\ntw_dev->max_posted_request_count,\r\ntw_dev->sgl_entries,\r\ntw_dev->max_sgl_entries,\r\ntw_dev->sector_count,\r\ntw_dev->max_sector_count,\r\ntw_dev->num_resets,\r\ntw_dev->aen_count);\r\nspin_unlock_irqrestore(tw_dev->host->host_lock, flags);\r\nreturn len;\r\n}\r\nstatic char *twl_aen_severity_lookup(unsigned char severity_code)\r\n{\r\nchar *retval = NULL;\r\nif ((severity_code < (unsigned char) TW_AEN_SEVERITY_ERROR) ||\r\n(severity_code > (unsigned char) TW_AEN_SEVERITY_DEBUG))\r\ngoto out;\r\nretval = twl_aen_severity_table[severity_code];\r\nout:\r\nreturn retval;\r\n}\r\nstatic void twl_aen_queue_event(TW_Device_Extension *tw_dev, TW_Command_Apache_Header *header)\r\n{\r\nu32 local_time;\r\nstruct timeval time;\r\nTW_Event *event;\r\nunsigned short aen;\r\nchar host[16];\r\nchar *error_str;\r\ntw_dev->aen_count++;\r\nevent = tw_dev->event_queue[tw_dev->error_index];\r\nhost[0] = '\0';\r\nif (tw_dev->host)\r\nsprintf(host, " scsi%d:", tw_dev->host->host_no);\r\naen = le16_to_cpu(header->status_block.error);\r\nmemset(event, 0, sizeof(TW_Event));\r\nevent->severity = TW_SEV_OUT(header->status_block.severity__reserved);\r\ndo_gettimeofday(&time);\r\nlocal_time = (u32)(time.tv_sec - (sys_tz.tz_minuteswest * 60));\r\nevent->time_stamp_sec = local_time;\r\nevent->aen_code = aen;\r\nevent->retrieved = TW_AEN_NOT_RETRIEVED;\r\nevent->sequence_id = tw_dev->error_sequence_id;\r\ntw_dev->error_sequence_id++;\r\nerror_str = &(header->err_specific_desc[strlen(header->err_specific_desc)+1]);\r\nheader->err_specific_desc[sizeof(header->err_specific_desc) - 1] = '\0';\r\nevent->parameter_len = strlen(header->err_specific_desc);\r\nmemcpy(event->parameter_data, header->err_specific_desc, event->parameter_len + 1 + strlen(error_str));\r\nif (event->severity != TW_AEN_SEVERITY_DEBUG)\r\nprintk(KERN_WARNING "3w-sas:%s AEN: %s (0x%02X:0x%04X): %s:%s.\n",\r\nhost,\r\ntwl_aen_severity_lookup(TW_SEV_OUT(header->status_block.severity__reserved)),\r\nTW_MESSAGE_SOURCE_CONTROLLER_EVENT, aen, error_str,\r\nheader->err_specific_desc);\r\nelse\r\ntw_dev->aen_count--;\r\ntw_dev->error_index = (tw_dev->error_index + 1 ) % TW_Q_LENGTH;\r\n}\r\nstatic int twl_post_command_packet(TW_Device_Extension *tw_dev, int request_id)\r\n{\r\ndma_addr_t command_que_value;\r\ncommand_que_value = tw_dev->command_packet_phys[request_id];\r\ncommand_que_value += TW_COMMAND_OFFSET;\r\nwritel((u32)((u64)command_que_value >> 32), TWL_HIBQPH_REG_ADDR(tw_dev));\r\nwritel((u32)(command_que_value | TWL_PULL_MODE), TWL_HIBQPL_REG_ADDR(tw_dev));\r\ntw_dev->state[request_id] = TW_S_POSTED;\r\ntw_dev->posted_request_count++;\r\nif (tw_dev->posted_request_count > tw_dev->max_posted_request_count)\r\ntw_dev->max_posted_request_count = tw_dev->posted_request_count;\r\nreturn 0;\r\n}\r\nstatic int twl_map_scsi_sg_data(TW_Device_Extension *tw_dev, int request_id)\r\n{\r\nint use_sg;\r\nstruct scsi_cmnd *cmd = tw_dev->srb[request_id];\r\nuse_sg = scsi_dma_map(cmd);\r\nif (!use_sg)\r\nreturn 0;\r\nelse if (use_sg < 0) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x1, "Failed to map scatter gather list");\r\nreturn 0;\r\n}\r\ncmd->SCp.phase = TW_PHASE_SGLIST;\r\ncmd->SCp.have_data_in = use_sg;\r\nreturn use_sg;\r\n}\r\nstatic int twl_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id, char *cdb, int use_sg, TW_SG_Entry_ISO *sglistarg)\r\n{\r\nTW_Command_Full *full_command_packet;\r\nTW_Command_Apache *command_packet;\r\nint i, sg_count;\r\nstruct scsi_cmnd *srb = NULL;\r\nstruct scatterlist *sglist = NULL, *sg;\r\nint retval = 1;\r\nif (tw_dev->srb[request_id]) {\r\nsrb = tw_dev->srb[request_id];\r\nif (scsi_sglist(srb))\r\nsglist = scsi_sglist(srb);\r\n}\r\nfull_command_packet = tw_dev->command_packet_virt[request_id];\r\nfull_command_packet->header.header_desc.size_header = 128;\r\nfull_command_packet->header.status_block.error = 0;\r\nfull_command_packet->header.status_block.severity__reserved = 0;\r\ncommand_packet = &full_command_packet->command.newcommand;\r\ncommand_packet->status = 0;\r\ncommand_packet->opcode__reserved = TW_OPRES_IN(0, TW_OP_EXECUTE_SCSI);\r\nif (!cdb)\r\nmemcpy(command_packet->cdb, srb->cmnd, TW_MAX_CDB_LEN);\r\nelse\r\nmemcpy(command_packet->cdb, cdb, TW_MAX_CDB_LEN);\r\nif (srb) {\r\ncommand_packet->unit = srb->device->id;\r\ncommand_packet->request_id__lunl =\r\ncpu_to_le16(TW_REQ_LUN_IN(srb->device->lun, request_id));\r\n} else {\r\ncommand_packet->request_id__lunl =\r\ncpu_to_le16(TW_REQ_LUN_IN(0, request_id));\r\ncommand_packet->unit = 0;\r\n}\r\ncommand_packet->sgl_offset = 16;\r\nif (!sglistarg) {\r\nif (scsi_sg_count(srb)) {\r\nsg_count = twl_map_scsi_sg_data(tw_dev, request_id);\r\nif (sg_count == 0)\r\ngoto out;\r\nscsi_for_each_sg(srb, sg, sg_count, i) {\r\ncommand_packet->sg_list[i].address = TW_CPU_TO_SGL(sg_dma_address(sg));\r\ncommand_packet->sg_list[i].length = TW_CPU_TO_SGL(sg_dma_len(sg));\r\n}\r\ncommand_packet->sgl_entries__lunh = cpu_to_le16(TW_REQ_LUN_IN((srb->device->lun >> 4), scsi_sg_count(tw_dev->srb[request_id])));\r\n}\r\n} else {\r\nfor (i = 0; i < use_sg; i++) {\r\ncommand_packet->sg_list[i].address = TW_CPU_TO_SGL(sglistarg[i].address);\r\ncommand_packet->sg_list[i].length = TW_CPU_TO_SGL(sglistarg[i].length);\r\n}\r\ncommand_packet->sgl_entries__lunh = cpu_to_le16(TW_REQ_LUN_IN(0, use_sg));\r\n}\r\nif (srb) {\r\ntw_dev->sector_count = scsi_bufflen(srb) / 512;\r\nif (tw_dev->sector_count > tw_dev->max_sector_count)\r\ntw_dev->max_sector_count = tw_dev->sector_count;\r\ntw_dev->sgl_entries = scsi_sg_count(srb);\r\nif (tw_dev->sgl_entries > tw_dev->max_sgl_entries)\r\ntw_dev->max_sgl_entries = tw_dev->sgl_entries;\r\n}\r\nretval = twl_post_command_packet(tw_dev, request_id);\r\nout:\r\nreturn retval;\r\n}\r\nstatic int twl_aen_read_queue(TW_Device_Extension *tw_dev, int request_id)\r\n{\r\nchar cdb[TW_MAX_CDB_LEN];\r\nTW_SG_Entry_ISO sglist[1];\r\nTW_Command_Full *full_command_packet;\r\nint retval = 1;\r\nfull_command_packet = tw_dev->command_packet_virt[request_id];\r\nmemset(full_command_packet, 0, sizeof(TW_Command_Full));\r\nmemset(&cdb, 0, TW_MAX_CDB_LEN);\r\ncdb[0] = REQUEST_SENSE;\r\ncdb[4] = TW_ALLOCATION_LENGTH;\r\nmemset(&sglist, 0, sizeof(TW_SG_Entry_ISO));\r\nsglist[0].length = TW_SECTOR_SIZE;\r\nsglist[0].address = tw_dev->generic_buffer_phys[request_id];\r\ntw_dev->srb[request_id] = NULL;\r\nif (twl_scsiop_execute_scsi(tw_dev, request_id, cdb, 1, sglist)) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x2, "Post failed while reading AEN queue");\r\ngoto out;\r\n}\r\nretval = 0;\r\nout:\r\nreturn retval;\r\n}\r\nstatic void twl_aen_sync_time(TW_Device_Extension *tw_dev, int request_id)\r\n{\r\nu32 schedulertime;\r\nstruct timeval utc;\r\nTW_Command_Full *full_command_packet;\r\nTW_Command *command_packet;\r\nTW_Param_Apache *param;\r\nu32 local_time;\r\nfull_command_packet = tw_dev->command_packet_virt[request_id];\r\nmemset(full_command_packet, 0, sizeof(TW_Command_Full));\r\ncommand_packet = &full_command_packet->command.oldcommand;\r\ncommand_packet->opcode__sgloffset = TW_OPSGL_IN(2, TW_OP_SET_PARAM);\r\ncommand_packet->request_id = request_id;\r\ncommand_packet->byte8_offset.param.sgl[0].address = TW_CPU_TO_SGL(tw_dev->generic_buffer_phys[request_id]);\r\ncommand_packet->byte8_offset.param.sgl[0].length = TW_CPU_TO_SGL(TW_SECTOR_SIZE);\r\ncommand_packet->size = TW_COMMAND_SIZE;\r\ncommand_packet->byte6_offset.parameter_count = cpu_to_le16(1);\r\nparam = (TW_Param_Apache *)tw_dev->generic_buffer_virt[request_id];\r\nmemset(param, 0, TW_SECTOR_SIZE);\r\nparam->table_id = cpu_to_le16(TW_TIMEKEEP_TABLE | 0x8000);\r\nparam->parameter_id = cpu_to_le16(0x3);\r\nparam->parameter_size_bytes = cpu_to_le16(4);\r\ndo_gettimeofday(&utc);\r\nlocal_time = (u32)(utc.tv_sec - (sys_tz.tz_minuteswest * 60));\r\nschedulertime = local_time - (3 * 86400);\r\nschedulertime = cpu_to_le32(schedulertime % 604800);\r\nmemcpy(param->data, &schedulertime, sizeof(u32));\r\ntw_dev->srb[request_id] = NULL;\r\ntwl_post_command_packet(tw_dev, request_id);\r\n}\r\nstatic void twl_get_request_id(TW_Device_Extension *tw_dev, int *request_id)\r\n{\r\n*request_id = tw_dev->free_queue[tw_dev->free_head];\r\ntw_dev->free_head = (tw_dev->free_head + 1) % TW_Q_LENGTH;\r\ntw_dev->state[*request_id] = TW_S_STARTED;\r\n}\r\nstatic void twl_free_request_id(TW_Device_Extension *tw_dev, int request_id)\r\n{\r\ntw_dev->free_queue[tw_dev->free_tail] = request_id;\r\ntw_dev->state[request_id] = TW_S_FINISHED;\r\ntw_dev->free_tail = (tw_dev->free_tail + 1) % TW_Q_LENGTH;\r\n}\r\nstatic int twl_aen_complete(TW_Device_Extension *tw_dev, int request_id)\r\n{\r\nTW_Command_Full *full_command_packet;\r\nTW_Command *command_packet;\r\nTW_Command_Apache_Header *header;\r\nunsigned short aen;\r\nint retval = 1;\r\nheader = (TW_Command_Apache_Header *)tw_dev->generic_buffer_virt[request_id];\r\ntw_dev->posted_request_count--;\r\naen = le16_to_cpu(header->status_block.error);\r\nfull_command_packet = tw_dev->command_packet_virt[request_id];\r\ncommand_packet = &full_command_packet->command.oldcommand;\r\nif (TW_OP_OUT(command_packet->opcode__sgloffset) == TW_OP_SET_PARAM) {\r\nif (twl_aen_read_queue(tw_dev, request_id))\r\ngoto out2;\r\nelse {\r\nretval = 0;\r\ngoto out;\r\n}\r\n}\r\nswitch (aen) {\r\ncase TW_AEN_QUEUE_EMPTY:\r\nbreak;\r\ncase TW_AEN_SYNC_TIME_WITH_HOST:\r\ntwl_aen_sync_time(tw_dev, request_id);\r\nretval = 0;\r\ngoto out;\r\ndefault:\r\ntwl_aen_queue_event(tw_dev, header);\r\nif (twl_aen_read_queue(tw_dev, request_id))\r\ngoto out2;\r\nelse {\r\nretval = 0;\r\ngoto out;\r\n}\r\n}\r\nretval = 0;\r\nout2:\r\ntw_dev->state[request_id] = TW_S_COMPLETED;\r\ntwl_free_request_id(tw_dev, request_id);\r\nclear_bit(TW_IN_ATTENTION_LOOP, &tw_dev->flags);\r\nout:\r\nreturn retval;\r\n}\r\nstatic int twl_poll_response(TW_Device_Extension *tw_dev, int request_id, int seconds)\r\n{\r\nunsigned long before;\r\ndma_addr_t mfa;\r\nu32 regh, regl;\r\nu32 response;\r\nint retval = 1;\r\nint found = 0;\r\nbefore = jiffies;\r\nwhile (!found) {\r\nif (sizeof(dma_addr_t) > 4) {\r\nregh = readl(TWL_HOBQPH_REG_ADDR(tw_dev));\r\nregl = readl(TWL_HOBQPL_REG_ADDR(tw_dev));\r\nmfa = ((u64)regh << 32) | regl;\r\n} else\r\nmfa = readl(TWL_HOBQPL_REG_ADDR(tw_dev));\r\nresponse = (u32)mfa;\r\nif (TW_RESID_OUT(response) == request_id)\r\nfound = 1;\r\nif (time_after(jiffies, before + HZ * seconds))\r\ngoto out;\r\nmsleep(50);\r\n}\r\nretval = 0;\r\nout:\r\nreturn retval;\r\n}\r\nstatic int twl_aen_drain_queue(TW_Device_Extension *tw_dev, int no_check_reset)\r\n{\r\nint request_id = 0;\r\nchar cdb[TW_MAX_CDB_LEN];\r\nTW_SG_Entry_ISO sglist[1];\r\nint finished = 0, count = 0;\r\nTW_Command_Full *full_command_packet;\r\nTW_Command_Apache_Header *header;\r\nunsigned short aen;\r\nint first_reset = 0, queue = 0, retval = 1;\r\nif (no_check_reset)\r\nfirst_reset = 0;\r\nelse\r\nfirst_reset = 1;\r\nfull_command_packet = tw_dev->command_packet_virt[request_id];\r\nmemset(full_command_packet, 0, sizeof(TW_Command_Full));\r\nmemset(&cdb, 0, TW_MAX_CDB_LEN);\r\ncdb[0] = REQUEST_SENSE;\r\ncdb[4] = TW_ALLOCATION_LENGTH;\r\nmemset(&sglist, 0, sizeof(TW_SG_Entry_ISO));\r\nsglist[0].length = TW_SECTOR_SIZE;\r\nsglist[0].address = tw_dev->generic_buffer_phys[request_id];\r\ntw_dev->srb[request_id] = NULL;\r\ndo {\r\nif (twl_scsiop_execute_scsi(tw_dev, request_id, cdb, 1, sglist)) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x3, "Error posting request sense");\r\ngoto out;\r\n}\r\nif (twl_poll_response(tw_dev, request_id, 30)) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x4, "No valid response while draining AEN queue");\r\ntw_dev->posted_request_count--;\r\ngoto out;\r\n}\r\ntw_dev->posted_request_count--;\r\nheader = (TW_Command_Apache_Header *)tw_dev->generic_buffer_virt[request_id];\r\naen = le16_to_cpu(header->status_block.error);\r\nqueue = 0;\r\ncount++;\r\nswitch (aen) {\r\ncase TW_AEN_QUEUE_EMPTY:\r\nif (first_reset != 1)\r\ngoto out;\r\nelse\r\nfinished = 1;\r\nbreak;\r\ncase TW_AEN_SOFT_RESET:\r\nif (first_reset == 0)\r\nfirst_reset = 1;\r\nelse\r\nqueue = 1;\r\nbreak;\r\ncase TW_AEN_SYNC_TIME_WITH_HOST:\r\nbreak;\r\ndefault:\r\nqueue = 1;\r\n}\r\nif (queue)\r\ntwl_aen_queue_event(tw_dev, header);\r\n} while ((finished == 0) && (count < TW_MAX_AEN_DRAIN));\r\nif (count == TW_MAX_AEN_DRAIN)\r\ngoto out;\r\nretval = 0;\r\nout:\r\ntw_dev->state[request_id] = TW_S_INITIAL;\r\nreturn retval;\r\n}\r\nstatic int twl_allocate_memory(TW_Device_Extension *tw_dev, int size, int which)\r\n{\r\nint i;\r\ndma_addr_t dma_handle;\r\nunsigned long *cpu_addr;\r\nint retval = 1;\r\ncpu_addr = pci_zalloc_consistent(tw_dev->tw_pci_dev, size * TW_Q_LENGTH,\r\n&dma_handle);\r\nif (!cpu_addr) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x5, "Memory allocation failed");\r\ngoto out;\r\n}\r\nfor (i = 0; i < TW_Q_LENGTH; i++) {\r\nswitch(which) {\r\ncase 0:\r\ntw_dev->command_packet_phys[i] = dma_handle+(i*size);\r\ntw_dev->command_packet_virt[i] = (TW_Command_Full *)((unsigned char *)cpu_addr + (i*size));\r\nbreak;\r\ncase 1:\r\ntw_dev->generic_buffer_phys[i] = dma_handle+(i*size);\r\ntw_dev->generic_buffer_virt[i] = (unsigned long *)((unsigned char *)cpu_addr + (i*size));\r\nbreak;\r\ncase 2:\r\ntw_dev->sense_buffer_phys[i] = dma_handle+(i*size);\r\ntw_dev->sense_buffer_virt[i] = (TW_Command_Apache_Header *)((unsigned char *)cpu_addr + (i*size));\r\nbreak;\r\n}\r\n}\r\nretval = 0;\r\nout:\r\nreturn retval;\r\n}\r\nstatic void twl_load_sgl(TW_Device_Extension *tw_dev, TW_Command_Full *full_command_packet, int request_id, dma_addr_t dma_handle, int length)\r\n{\r\nTW_Command *oldcommand;\r\nTW_Command_Apache *newcommand;\r\nTW_SG_Entry_ISO *sgl;\r\nunsigned int pae = 0;\r\nif ((sizeof(long) < 8) && (sizeof(dma_addr_t) > 4))\r\npae = 1;\r\nif (TW_OP_OUT(full_command_packet->command.newcommand.opcode__reserved) == TW_OP_EXECUTE_SCSI) {\r\nnewcommand = &full_command_packet->command.newcommand;\r\nnewcommand->request_id__lunl =\r\ncpu_to_le16(TW_REQ_LUN_IN(TW_LUN_OUT(newcommand->request_id__lunl), request_id));\r\nif (length) {\r\nnewcommand->sg_list[0].address = TW_CPU_TO_SGL(dma_handle + sizeof(TW_Ioctl_Buf_Apache) - 1);\r\nnewcommand->sg_list[0].length = TW_CPU_TO_SGL(length);\r\n}\r\nnewcommand->sgl_entries__lunh =\r\ncpu_to_le16(TW_REQ_LUN_IN(TW_LUN_OUT(newcommand->sgl_entries__lunh), length ? 1 : 0));\r\n} else {\r\noldcommand = &full_command_packet->command.oldcommand;\r\noldcommand->request_id = request_id;\r\nif (TW_SGL_OUT(oldcommand->opcode__sgloffset)) {\r\nsgl = (TW_SG_Entry_ISO *)((u32 *)oldcommand+oldcommand->size - (sizeof(TW_SG_Entry_ISO)/4) + pae + (sizeof(dma_addr_t) > 4 ? 1 : 0));\r\nsgl->address = TW_CPU_TO_SGL(dma_handle + sizeof(TW_Ioctl_Buf_Apache) - 1);\r\nsgl->length = TW_CPU_TO_SGL(length);\r\noldcommand->size += pae;\r\noldcommand->size += sizeof(dma_addr_t) > 4 ? 1 : 0;\r\n}\r\n}\r\n}\r\nstatic long twl_chrdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nlong timeout;\r\nunsigned long *cpu_addr, data_buffer_length_adjusted = 0, flags = 0;\r\ndma_addr_t dma_handle;\r\nint request_id = 0;\r\nTW_Ioctl_Driver_Command driver_command;\r\nstruct inode *inode = file_inode(file);\r\nTW_Ioctl_Buf_Apache *tw_ioctl;\r\nTW_Command_Full *full_command_packet;\r\nTW_Device_Extension *tw_dev = twl_device_extension_list[iminor(inode)];\r\nint retval = -EFAULT;\r\nvoid __user *argp = (void __user *)arg;\r\nmutex_lock(&twl_chrdev_mutex);\r\nif (mutex_lock_interruptible(&tw_dev->ioctl_lock)) {\r\nretval = -EINTR;\r\ngoto out;\r\n}\r\nif (copy_from_user(&driver_command, argp, sizeof(TW_Ioctl_Driver_Command)))\r\ngoto out2;\r\nif (driver_command.buffer_length > TW_MAX_SECTORS * 2048) {\r\nretval = -EINVAL;\r\ngoto out2;\r\n}\r\ndata_buffer_length_adjusted = (driver_command.buffer_length + 511) & ~511;\r\ncpu_addr = dma_alloc_coherent(&tw_dev->tw_pci_dev->dev, data_buffer_length_adjusted+sizeof(TW_Ioctl_Buf_Apache) - 1, &dma_handle, GFP_KERNEL);\r\nif (!cpu_addr) {\r\nretval = -ENOMEM;\r\ngoto out2;\r\n}\r\ntw_ioctl = (TW_Ioctl_Buf_Apache *)cpu_addr;\r\nif (copy_from_user(tw_ioctl, argp, driver_command.buffer_length + sizeof(TW_Ioctl_Buf_Apache) - 1))\r\ngoto out3;\r\nswitch (cmd) {\r\ncase TW_IOCTL_FIRMWARE_PASS_THROUGH:\r\nspin_lock_irqsave(tw_dev->host->host_lock, flags);\r\ntwl_get_request_id(tw_dev, &request_id);\r\ntw_dev->srb[request_id] = NULL;\r\ntw_dev->chrdev_request_id = request_id;\r\nfull_command_packet = (TW_Command_Full *)&tw_ioctl->firmware_command;\r\ntwl_load_sgl(tw_dev, full_command_packet, request_id, dma_handle, data_buffer_length_adjusted);\r\nmemcpy(tw_dev->command_packet_virt[request_id], &(tw_ioctl->firmware_command), sizeof(TW_Command_Full));\r\ntwl_post_command_packet(tw_dev, request_id);\r\nspin_unlock_irqrestore(tw_dev->host->host_lock, flags);\r\ntimeout = TW_IOCTL_CHRDEV_TIMEOUT*HZ;\r\ntimeout = wait_event_timeout(tw_dev->ioctl_wqueue, tw_dev->chrdev_request_id == TW_IOCTL_CHRDEV_FREE, timeout);\r\nif (tw_dev->chrdev_request_id != TW_IOCTL_CHRDEV_FREE) {\r\nprintk(KERN_WARNING "3w-sas: scsi%d: WARNING: (0x%02X:0x%04X): Character ioctl (0x%x) timed out, resetting card.\n",\r\ntw_dev->host->host_no, TW_DRIVER, 0x6,\r\ncmd);\r\nretval = -EIO;\r\ntwl_reset_device_extension(tw_dev, 1);\r\ngoto out3;\r\n}\r\nmemcpy(&(tw_ioctl->firmware_command), tw_dev->command_packet_virt[request_id], sizeof(TW_Command_Full));\r\nspin_lock_irqsave(tw_dev->host->host_lock, flags);\r\ntw_dev->posted_request_count--;\r\ntw_dev->state[request_id] = TW_S_COMPLETED;\r\ntwl_free_request_id(tw_dev, request_id);\r\nspin_unlock_irqrestore(tw_dev->host->host_lock, flags);\r\nbreak;\r\ndefault:\r\nretval = -ENOTTY;\r\ngoto out3;\r\n}\r\nif (copy_to_user(argp, tw_ioctl, sizeof(TW_Ioctl_Buf_Apache) + driver_command.buffer_length - 1) == 0)\r\nretval = 0;\r\nout3:\r\ndma_free_coherent(&tw_dev->tw_pci_dev->dev, data_buffer_length_adjusted+sizeof(TW_Ioctl_Buf_Apache) - 1, cpu_addr, dma_handle);\r\nout2:\r\nmutex_unlock(&tw_dev->ioctl_lock);\r\nout:\r\nmutex_unlock(&twl_chrdev_mutex);\r\nreturn retval;\r\n}\r\nstatic int twl_chrdev_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned int minor_number;\r\nint retval = -ENODEV;\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nretval = -EACCES;\r\ngoto out;\r\n}\r\nminor_number = iminor(inode);\r\nif (minor_number >= twl_device_extension_count)\r\ngoto out;\r\nretval = 0;\r\nout:\r\nreturn retval;\r\n}\r\nstatic int twl_fill_sense(TW_Device_Extension *tw_dev, int i, int request_id, int copy_sense, int print_host)\r\n{\r\nTW_Command_Apache_Header *header;\r\nTW_Command_Full *full_command_packet;\r\nunsigned short error;\r\nchar *error_str;\r\nint retval = 1;\r\nheader = tw_dev->sense_buffer_virt[i];\r\nfull_command_packet = tw_dev->command_packet_virt[request_id];\r\nerror_str = &(header->err_specific_desc[strlen(header->err_specific_desc) + 1]);\r\nerror = le16_to_cpu(header->status_block.error);\r\nif ((error != TW_ERROR_LOGICAL_UNIT_NOT_SUPPORTED) && (error != TW_ERROR_UNIT_OFFLINE) && (error != TW_ERROR_INVALID_FIELD_IN_CDB)) {\r\nif (print_host)\r\nprintk(KERN_WARNING "3w-sas: scsi%d: ERROR: (0x%02X:0x%04X): %s:%s.\n",\r\ntw_dev->host->host_no,\r\nTW_MESSAGE_SOURCE_CONTROLLER_ERROR,\r\nheader->status_block.error,\r\nerror_str,\r\nheader->err_specific_desc);\r\nelse\r\nprintk(KERN_WARNING "3w-sas: ERROR: (0x%02X:0x%04X): %s:%s.\n",\r\nTW_MESSAGE_SOURCE_CONTROLLER_ERROR,\r\nheader->status_block.error,\r\nerror_str,\r\nheader->err_specific_desc);\r\n}\r\nif (copy_sense) {\r\nmemcpy(tw_dev->srb[request_id]->sense_buffer, header->sense_data, TW_SENSE_DATA_LENGTH);\r\ntw_dev->srb[request_id]->result = (full_command_packet->command.newcommand.status << 1);\r\ngoto out;\r\n}\r\nout:\r\nreturn retval;\r\n}\r\nstatic void twl_free_device_extension(TW_Device_Extension *tw_dev)\r\n{\r\nif (tw_dev->command_packet_virt[0])\r\npci_free_consistent(tw_dev->tw_pci_dev,\r\nsizeof(TW_Command_Full)*TW_Q_LENGTH,\r\ntw_dev->command_packet_virt[0],\r\ntw_dev->command_packet_phys[0]);\r\nif (tw_dev->generic_buffer_virt[0])\r\npci_free_consistent(tw_dev->tw_pci_dev,\r\nTW_SECTOR_SIZE*TW_Q_LENGTH,\r\ntw_dev->generic_buffer_virt[0],\r\ntw_dev->generic_buffer_phys[0]);\r\nif (tw_dev->sense_buffer_virt[0])\r\npci_free_consistent(tw_dev->tw_pci_dev,\r\nsizeof(TW_Command_Apache_Header)*\r\nTW_Q_LENGTH,\r\ntw_dev->sense_buffer_virt[0],\r\ntw_dev->sense_buffer_phys[0]);\r\nkfree(tw_dev->event_queue[0]);\r\n}\r\nstatic void *twl_get_param(TW_Device_Extension *tw_dev, int request_id, int table_id, int parameter_id, int parameter_size_bytes)\r\n{\r\nTW_Command_Full *full_command_packet;\r\nTW_Command *command_packet;\r\nTW_Param_Apache *param;\r\nvoid *retval = NULL;\r\nfull_command_packet = tw_dev->command_packet_virt[request_id];\r\nmemset(full_command_packet, 0, sizeof(TW_Command_Full));\r\ncommand_packet = &full_command_packet->command.oldcommand;\r\ncommand_packet->opcode__sgloffset = TW_OPSGL_IN(2, TW_OP_GET_PARAM);\r\ncommand_packet->size = TW_COMMAND_SIZE;\r\ncommand_packet->request_id = request_id;\r\ncommand_packet->byte6_offset.block_count = cpu_to_le16(1);\r\nparam = (TW_Param_Apache *)tw_dev->generic_buffer_virt[request_id];\r\nmemset(param, 0, TW_SECTOR_SIZE);\r\nparam->table_id = cpu_to_le16(table_id | 0x8000);\r\nparam->parameter_id = cpu_to_le16(parameter_id);\r\nparam->parameter_size_bytes = cpu_to_le16(parameter_size_bytes);\r\ncommand_packet->byte8_offset.param.sgl[0].address = TW_CPU_TO_SGL(tw_dev->generic_buffer_phys[request_id]);\r\ncommand_packet->byte8_offset.param.sgl[0].length = TW_CPU_TO_SGL(TW_SECTOR_SIZE);\r\ntwl_post_command_packet(tw_dev, request_id);\r\nif (twl_poll_response(tw_dev, request_id, 30))\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x7, "No valid response during get param")\r\nelse\r\nretval = (void *)&(param->data[0]);\r\ntw_dev->posted_request_count--;\r\ntw_dev->state[request_id] = TW_S_INITIAL;\r\nreturn retval;\r\n}\r\nstatic int twl_initconnection(TW_Device_Extension *tw_dev, int message_credits,\r\nu32 set_features, unsigned short current_fw_srl,\r\nunsigned short current_fw_arch_id,\r\nunsigned short current_fw_branch,\r\nunsigned short current_fw_build,\r\nunsigned short *fw_on_ctlr_srl,\r\nunsigned short *fw_on_ctlr_arch_id,\r\nunsigned short *fw_on_ctlr_branch,\r\nunsigned short *fw_on_ctlr_build,\r\nu32 *init_connect_result)\r\n{\r\nTW_Command_Full *full_command_packet;\r\nTW_Initconnect *tw_initconnect;\r\nint request_id = 0, retval = 1;\r\nfull_command_packet = tw_dev->command_packet_virt[request_id];\r\nmemset(full_command_packet, 0, sizeof(TW_Command_Full));\r\nfull_command_packet->header.header_desc.size_header = 128;\r\ntw_initconnect = (TW_Initconnect *)&full_command_packet->command.oldcommand;\r\ntw_initconnect->opcode__reserved = TW_OPRES_IN(0, TW_OP_INIT_CONNECTION);\r\ntw_initconnect->request_id = request_id;\r\ntw_initconnect->message_credits = cpu_to_le16(message_credits);\r\ntw_initconnect->features = set_features;\r\ntw_initconnect->features |= sizeof(dma_addr_t) > 4 ? 1 : 0;\r\ntw_initconnect->features = cpu_to_le32(tw_initconnect->features);\r\nif (set_features & TW_EXTENDED_INIT_CONNECT) {\r\ntw_initconnect->size = TW_INIT_COMMAND_PACKET_SIZE_EXTENDED;\r\ntw_initconnect->fw_srl = cpu_to_le16(current_fw_srl);\r\ntw_initconnect->fw_arch_id = cpu_to_le16(current_fw_arch_id);\r\ntw_initconnect->fw_branch = cpu_to_le16(current_fw_branch);\r\ntw_initconnect->fw_build = cpu_to_le16(current_fw_build);\r\n} else\r\ntw_initconnect->size = TW_INIT_COMMAND_PACKET_SIZE;\r\ntwl_post_command_packet(tw_dev, request_id);\r\nif (twl_poll_response(tw_dev, request_id, 30)) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x8, "No valid response during init connection");\r\n} else {\r\nif (set_features & TW_EXTENDED_INIT_CONNECT) {\r\n*fw_on_ctlr_srl = le16_to_cpu(tw_initconnect->fw_srl);\r\n*fw_on_ctlr_arch_id = le16_to_cpu(tw_initconnect->fw_arch_id);\r\n*fw_on_ctlr_branch = le16_to_cpu(tw_initconnect->fw_branch);\r\n*fw_on_ctlr_build = le16_to_cpu(tw_initconnect->fw_build);\r\n*init_connect_result = le32_to_cpu(tw_initconnect->result);\r\n}\r\nretval = 0;\r\n}\r\ntw_dev->posted_request_count--;\r\ntw_dev->state[request_id] = TW_S_INITIAL;\r\nreturn retval;\r\n}\r\nstatic int twl_initialize_device_extension(TW_Device_Extension *tw_dev)\r\n{\r\nint i, retval = 1;\r\nif (twl_allocate_memory(tw_dev, sizeof(TW_Command_Full), 0)) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x9, "Command packet memory allocation failed");\r\ngoto out;\r\n}\r\nif (twl_allocate_memory(tw_dev, TW_SECTOR_SIZE, 1)) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0xa, "Generic memory allocation failed");\r\ngoto out;\r\n}\r\nif (twl_allocate_memory(tw_dev, sizeof(TW_Command_Apache_Header), 2)) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0xb, "Sense buffer allocation failed");\r\ngoto out;\r\n}\r\ntw_dev->event_queue[0] = kcalloc(TW_Q_LENGTH, sizeof(TW_Event), GFP_KERNEL);\r\nif (!tw_dev->event_queue[0]) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0xc, "Event info memory allocation failed");\r\ngoto out;\r\n}\r\nfor (i = 0; i < TW_Q_LENGTH; i++) {\r\ntw_dev->event_queue[i] = (TW_Event *)((unsigned char *)tw_dev->event_queue[0] + (i * sizeof(TW_Event)));\r\ntw_dev->free_queue[i] = i;\r\ntw_dev->state[i] = TW_S_INITIAL;\r\n}\r\ntw_dev->free_head = TW_Q_START;\r\ntw_dev->free_tail = TW_Q_START;\r\ntw_dev->error_sequence_id = 1;\r\ntw_dev->chrdev_request_id = TW_IOCTL_CHRDEV_FREE;\r\nmutex_init(&tw_dev->ioctl_lock);\r\ninit_waitqueue_head(&tw_dev->ioctl_wqueue);\r\nretval = 0;\r\nout:\r\nreturn retval;\r\n}\r\nstatic void twl_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id)\r\n{\r\nstruct scsi_cmnd *cmd = tw_dev->srb[request_id];\r\nif (cmd->SCp.phase == TW_PHASE_SGLIST)\r\nscsi_dma_unmap(cmd);\r\n}\r\nstatic int twl_handle_attention_interrupt(TW_Device_Extension *tw_dev)\r\n{\r\nint retval = 1;\r\nu32 request_id, doorbell;\r\ndoorbell = readl(TWL_HOBDB_REG_ADDR(tw_dev));\r\nif (doorbell & TWL_DOORBELL_CONTROLLER_ERROR) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0xd, "Microcontroller Error: clearing");\r\ngoto out;\r\n}\r\nif (doorbell & TWL_DOORBELL_ATTENTION_INTERRUPT) {\r\nif (!(test_and_set_bit(TW_IN_ATTENTION_LOOP, &tw_dev->flags))) {\r\ntwl_get_request_id(tw_dev, &request_id);\r\nif (twl_aen_read_queue(tw_dev, request_id)) {\r\ntw_dev->state[request_id] = TW_S_COMPLETED;\r\ntwl_free_request_id(tw_dev, request_id);\r\nclear_bit(TW_IN_ATTENTION_LOOP, &tw_dev->flags);\r\n}\r\n}\r\n}\r\nretval = 0;\r\nout:\r\nTWL_CLEAR_DB_INTERRUPT(tw_dev);\r\nreadl(TWL_HOBDBC_REG_ADDR(tw_dev));\r\nreturn retval;\r\n}\r\nstatic irqreturn_t twl_interrupt(int irq, void *dev_instance)\r\n{\r\nTW_Device_Extension *tw_dev = (TW_Device_Extension *)dev_instance;\r\nint i, handled = 0, error = 0;\r\ndma_addr_t mfa = 0;\r\nu32 reg, regl, regh, response, request_id = 0;\r\nstruct scsi_cmnd *cmd;\r\nTW_Command_Full *full_command_packet;\r\nspin_lock(tw_dev->host->host_lock);\r\nreg = readl(TWL_HISTAT_REG_ADDR(tw_dev));\r\nif (!(reg & TWL_HISTATUS_VALID_INTERRUPT))\r\ngoto twl_interrupt_bail;\r\nhandled = 1;\r\nif (test_bit(TW_IN_RESET, &tw_dev->flags))\r\ngoto twl_interrupt_bail;\r\nif (reg & TWL_HISTATUS_ATTENTION_INTERRUPT) {\r\nif (twl_handle_attention_interrupt(tw_dev)) {\r\nTWL_MASK_INTERRUPTS(tw_dev);\r\ngoto twl_interrupt_bail;\r\n}\r\n}\r\nwhile (reg & TWL_HISTATUS_RESPONSE_INTERRUPT) {\r\nif (sizeof(dma_addr_t) > 4) {\r\nregh = readl(TWL_HOBQPH_REG_ADDR(tw_dev));\r\nregl = readl(TWL_HOBQPL_REG_ADDR(tw_dev));\r\nmfa = ((u64)regh << 32) | regl;\r\n} else\r\nmfa = readl(TWL_HOBQPL_REG_ADDR(tw_dev));\r\nerror = 0;\r\nresponse = (u32)mfa;\r\nif (!TW_NOTMFA_OUT(response)) {\r\nfor (i=0;i<TW_Q_LENGTH;i++) {\r\nif (tw_dev->sense_buffer_phys[i] == mfa) {\r\nrequest_id = le16_to_cpu(tw_dev->sense_buffer_virt[i]->header_desc.request_id);\r\nif (tw_dev->srb[request_id] != NULL)\r\nerror = twl_fill_sense(tw_dev, i, request_id, 1, 1);\r\nelse {\r\nif (request_id != tw_dev->chrdev_request_id)\r\nerror = twl_fill_sense(tw_dev, i, request_id, 0, 1);\r\nelse\r\nmemcpy(tw_dev->command_packet_virt[request_id], tw_dev->sense_buffer_virt[i], sizeof(TW_Command_Apache_Header));\r\n}\r\nwritel((u32)((u64)tw_dev->sense_buffer_phys[i] >> 32), TWL_HOBQPH_REG_ADDR(tw_dev));\r\nwritel((u32)tw_dev->sense_buffer_phys[i], TWL_HOBQPL_REG_ADDR(tw_dev));\r\nbreak;\r\n}\r\n}\r\n} else\r\nrequest_id = TW_RESID_OUT(response);\r\nfull_command_packet = tw_dev->command_packet_virt[request_id];\r\nif (tw_dev->state[request_id] != TW_S_POSTED) {\r\nif (tw_dev->srb[request_id] != NULL) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0xe, "Received a request id that wasn't posted");\r\nTWL_MASK_INTERRUPTS(tw_dev);\r\ngoto twl_interrupt_bail;\r\n}\r\n}\r\nif (tw_dev->srb[request_id] == NULL) {\r\nif (request_id != tw_dev->chrdev_request_id) {\r\nif (twl_aen_complete(tw_dev, request_id))\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0xf, "Error completing AEN during attention interrupt");\r\n} else {\r\ntw_dev->chrdev_request_id = TW_IOCTL_CHRDEV_FREE;\r\nwake_up(&tw_dev->ioctl_wqueue);\r\n}\r\n} else {\r\ncmd = tw_dev->srb[request_id];\r\nif (!error)\r\ncmd->result = (DID_OK << 16);\r\nif ((scsi_sg_count(cmd) <= 1) && (full_command_packet->command.newcommand.status == 0)) {\r\nif (full_command_packet->command.newcommand.sg_list[0].length < scsi_bufflen(tw_dev->srb[request_id]))\r\nscsi_set_resid(cmd, scsi_bufflen(cmd) - full_command_packet->command.newcommand.sg_list[0].length);\r\n}\r\ntw_dev->state[request_id] = TW_S_COMPLETED;\r\ntwl_free_request_id(tw_dev, request_id);\r\ntw_dev->posted_request_count--;\r\ntw_dev->srb[request_id]->scsi_done(tw_dev->srb[request_id]);\r\ntwl_unmap_scsi_data(tw_dev, request_id);\r\n}\r\nreg = readl(TWL_HISTAT_REG_ADDR(tw_dev));\r\n}\r\ntwl_interrupt_bail:\r\nspin_unlock(tw_dev->host->host_lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int twl_poll_register(TW_Device_Extension *tw_dev, void *reg, u32 value, u32 result, int seconds)\r\n{\r\nunsigned long before;\r\nint retval = 1;\r\nu32 reg_value;\r\nreg_value = readl(reg);\r\nbefore = jiffies;\r\nwhile ((reg_value & value) != result) {\r\nreg_value = readl(reg);\r\nif (time_after(jiffies, before + HZ * seconds))\r\ngoto out;\r\nmsleep(50);\r\n}\r\nretval = 0;\r\nout:\r\nreturn retval;\r\n}\r\nstatic int twl_reset_sequence(TW_Device_Extension *tw_dev, int soft_reset)\r\n{\r\nint retval = 1;\r\nint i = 0;\r\nu32 status = 0;\r\nunsigned short fw_on_ctlr_srl = 0, fw_on_ctlr_arch_id = 0;\r\nunsigned short fw_on_ctlr_branch = 0, fw_on_ctlr_build = 0;\r\nu32 init_connect_result = 0;\r\nint tries = 0;\r\nint do_soft_reset = soft_reset;\r\nwhile (tries < TW_MAX_RESET_TRIES) {\r\nif (do_soft_reset) {\r\nTWL_SOFT_RESET(tw_dev);\r\nif (twl_poll_register(tw_dev, TWL_SCRPD3_REG_ADDR(tw_dev), TWL_CONTROLLER_READY, 0x0, 30)) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x10, "Controller never went non-ready during reset sequence");\r\ntries++;\r\ncontinue;\r\n}\r\nif (twl_poll_register(tw_dev, TWL_SCRPD3_REG_ADDR(tw_dev), TWL_CONTROLLER_READY, TWL_CONTROLLER_READY, 60)) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x11, "Controller not ready during reset sequence");\r\ntries++;\r\ncontinue;\r\n}\r\n}\r\nif (twl_initconnection(tw_dev, TW_INIT_MESSAGE_CREDITS,\r\nTW_EXTENDED_INIT_CONNECT, TW_CURRENT_DRIVER_SRL,\r\nTW_9750_ARCH_ID, TW_CURRENT_DRIVER_BRANCH,\r\nTW_CURRENT_DRIVER_BUILD, &fw_on_ctlr_srl,\r\n&fw_on_ctlr_arch_id, &fw_on_ctlr_branch,\r\n&fw_on_ctlr_build, &init_connect_result)) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x12, "Initconnection failed while checking SRL");\r\ndo_soft_reset = 1;\r\ntries++;\r\ncontinue;\r\n}\r\nwhile (i < TW_Q_LENGTH) {\r\nwritel((u32)((u64)tw_dev->sense_buffer_phys[i] >> 32), TWL_HOBQPH_REG_ADDR(tw_dev));\r\nwritel((u32)tw_dev->sense_buffer_phys[i], TWL_HOBQPL_REG_ADDR(tw_dev));\r\nstatus = readl(TWL_STATUS_REG_ADDR(tw_dev));\r\nif (!(status & TWL_STATUS_OVERRUN_SUBMIT))\r\ni++;\r\n}\r\nstatus = readl(TWL_STATUS_REG_ADDR(tw_dev));\r\nif (status) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x13, "Bad controller status after loading sense buffers");\r\ndo_soft_reset = 1;\r\ntries++;\r\ncontinue;\r\n}\r\nif (twl_aen_drain_queue(tw_dev, soft_reset)) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x14, "AEN drain failed during reset sequence");\r\ndo_soft_reset = 1;\r\ntries++;\r\ncontinue;\r\n}\r\nstrncpy(tw_dev->tw_compat_info.driver_version, TW_DRIVER_VERSION, strlen(TW_DRIVER_VERSION));\r\ntw_dev->tw_compat_info.driver_srl_high = TW_CURRENT_DRIVER_SRL;\r\ntw_dev->tw_compat_info.driver_branch_high = TW_CURRENT_DRIVER_BRANCH;\r\ntw_dev->tw_compat_info.driver_build_high = TW_CURRENT_DRIVER_BUILD;\r\ntw_dev->tw_compat_info.driver_srl_low = TW_BASE_FW_SRL;\r\ntw_dev->tw_compat_info.driver_branch_low = TW_BASE_FW_BRANCH;\r\ntw_dev->tw_compat_info.driver_build_low = TW_BASE_FW_BUILD;\r\ntw_dev->tw_compat_info.fw_on_ctlr_srl = fw_on_ctlr_srl;\r\ntw_dev->tw_compat_info.fw_on_ctlr_branch = fw_on_ctlr_branch;\r\ntw_dev->tw_compat_info.fw_on_ctlr_build = fw_on_ctlr_build;\r\nretval = 0;\r\ngoto out;\r\n}\r\nout:\r\nreturn retval;\r\n}\r\nstatic int twl_reset_device_extension(TW_Device_Extension *tw_dev, int ioctl_reset)\r\n{\r\nint i = 0, retval = 1;\r\nunsigned long flags = 0;\r\nif (ioctl_reset)\r\nscsi_block_requests(tw_dev->host);\r\nset_bit(TW_IN_RESET, &tw_dev->flags);\r\nTWL_MASK_INTERRUPTS(tw_dev);\r\nTWL_CLEAR_DB_INTERRUPT(tw_dev);\r\nspin_lock_irqsave(tw_dev->host->host_lock, flags);\r\nfor (i = 0; i < TW_Q_LENGTH; i++) {\r\nif ((tw_dev->state[i] != TW_S_FINISHED) &&\r\n(tw_dev->state[i] != TW_S_INITIAL) &&\r\n(tw_dev->state[i] != TW_S_COMPLETED)) {\r\nif (tw_dev->srb[i]) {\r\ntw_dev->srb[i]->result = (DID_RESET << 16);\r\ntw_dev->srb[i]->scsi_done(tw_dev->srb[i]);\r\ntwl_unmap_scsi_data(tw_dev, i);\r\n}\r\n}\r\n}\r\nfor (i = 0; i < TW_Q_LENGTH; i++) {\r\ntw_dev->free_queue[i] = i;\r\ntw_dev->state[i] = TW_S_INITIAL;\r\n}\r\ntw_dev->free_head = TW_Q_START;\r\ntw_dev->free_tail = TW_Q_START;\r\ntw_dev->posted_request_count = 0;\r\nspin_unlock_irqrestore(tw_dev->host->host_lock, flags);\r\nif (twl_reset_sequence(tw_dev, 1))\r\ngoto out;\r\nTWL_UNMASK_INTERRUPTS(tw_dev);\r\nclear_bit(TW_IN_RESET, &tw_dev->flags);\r\ntw_dev->chrdev_request_id = TW_IOCTL_CHRDEV_FREE;\r\nretval = 0;\r\nout:\r\nif (ioctl_reset)\r\nscsi_unblock_requests(tw_dev->host);\r\nreturn retval;\r\n}\r\nstatic int twl_scsi_biosparam(struct scsi_device *sdev, struct block_device *bdev, sector_t capacity, int geom[])\r\n{\r\nint heads, sectors;\r\nTW_Device_Extension *tw_dev;\r\ntw_dev = (TW_Device_Extension *)sdev->host->hostdata;\r\nif (capacity >= 0x200000) {\r\nheads = 255;\r\nsectors = 63;\r\n} else {\r\nheads = 64;\r\nsectors = 32;\r\n}\r\ngeom[0] = heads;\r\ngeom[1] = sectors;\r\ngeom[2] = sector_div(capacity, heads * sectors);\r\nreturn 0;\r\n}\r\nstatic int twl_scsi_eh_reset(struct scsi_cmnd *SCpnt)\r\n{\r\nTW_Device_Extension *tw_dev = NULL;\r\nint retval = FAILED;\r\ntw_dev = (TW_Device_Extension *)SCpnt->device->host->hostdata;\r\ntw_dev->num_resets++;\r\nsdev_printk(KERN_WARNING, SCpnt->device,\r\n"WARNING: (0x%02X:0x%04X): Command (0x%x) timed out, resetting card.\n",\r\nTW_DRIVER, 0x2c, SCpnt->cmnd[0]);\r\nmutex_lock(&tw_dev->ioctl_lock);\r\nif (twl_reset_device_extension(tw_dev, 0)) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x15, "Controller reset failed during scsi host reset");\r\ngoto out;\r\n}\r\nretval = SUCCESS;\r\nout:\r\nmutex_unlock(&tw_dev->ioctl_lock);\r\nreturn retval;\r\n}\r\nstatic int twl_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))\r\n{\r\nint request_id, retval;\r\nTW_Device_Extension *tw_dev = (TW_Device_Extension *)SCpnt->device->host->hostdata;\r\nif (test_bit(TW_IN_RESET, &tw_dev->flags)) {\r\nretval = SCSI_MLQUEUE_HOST_BUSY;\r\ngoto out;\r\n}\r\nSCpnt->scsi_done = done;\r\ntwl_get_request_id(tw_dev, &request_id);\r\ntw_dev->srb[request_id] = SCpnt;\r\nSCpnt->SCp.phase = TW_PHASE_INITIAL;\r\nretval = twl_scsiop_execute_scsi(tw_dev, request_id, NULL, 0, NULL);\r\nif (retval) {\r\ntw_dev->state[request_id] = TW_S_COMPLETED;\r\ntwl_free_request_id(tw_dev, request_id);\r\nSCpnt->result = (DID_ERROR << 16);\r\ndone(SCpnt);\r\nretval = 0;\r\n}\r\nout:\r\nreturn retval;\r\n}\r\nvoid twl_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nTW_Device_Extension *tw_dev;\r\nif (!host)\r\nreturn;\r\ntw_dev = (TW_Device_Extension *)host->hostdata;\r\nif (tw_dev->online)\r\n__twl_shutdown(tw_dev);\r\n}\r\nstatic int twl_slave_configure(struct scsi_device *sdev)\r\n{\r\nblk_queue_rq_timeout(sdev->request_queue, 60 * HZ);\r\nreturn 0;\r\n}\r\nstatic int twl_probe(struct pci_dev *pdev, const struct pci_device_id *dev_id)\r\n{\r\nstruct Scsi_Host *host = NULL;\r\nTW_Device_Extension *tw_dev;\r\nint retval = -ENODEV;\r\nint *ptr_phycount, phycount=0;\r\nretval = pci_enable_device(pdev);\r\nif (retval) {\r\nTW_PRINTK(host, TW_DRIVER, 0x17, "Failed to enable pci device");\r\ngoto out_disable_device;\r\n}\r\npci_set_master(pdev);\r\npci_try_set_mwi(pdev);\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(64))\r\n|| pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64)))\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))\r\n|| pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nTW_PRINTK(host, TW_DRIVER, 0x18, "Failed to set dma mask");\r\nretval = -ENODEV;\r\ngoto out_disable_device;\r\n}\r\nhost = scsi_host_alloc(&driver_template, sizeof(TW_Device_Extension));\r\nif (!host) {\r\nTW_PRINTK(host, TW_DRIVER, 0x19, "Failed to allocate memory for device extension");\r\nretval = -ENOMEM;\r\ngoto out_disable_device;\r\n}\r\ntw_dev = shost_priv(host);\r\ntw_dev->host = host;\r\ntw_dev->tw_pci_dev = pdev;\r\nif (twl_initialize_device_extension(tw_dev)) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x1a, "Failed to initialize device extension");\r\ngoto out_free_device_extension;\r\n}\r\nretval = pci_request_regions(pdev, "3w-sas");\r\nif (retval) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x1b, "Failed to get mem region");\r\ngoto out_free_device_extension;\r\n}\r\ntw_dev->base_addr = pci_iomap(pdev, 1, 0);\r\nif (!tw_dev->base_addr) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x1c, "Failed to ioremap");\r\ngoto out_release_mem_region;\r\n}\r\nTWL_MASK_INTERRUPTS(tw_dev);\r\nif (twl_reset_sequence(tw_dev, 0)) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x1d, "Controller reset failed during probe");\r\ngoto out_iounmap;\r\n}\r\nhost->max_id = TW_MAX_UNITS;\r\nhost->max_cmd_len = TW_MAX_CDB_LEN;\r\nhost->max_lun = TW_MAX_LUNS;\r\nhost->max_channel = 0;\r\nretval = scsi_add_host(host, &pdev->dev);\r\nif (retval) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x1e, "scsi add host failed");\r\ngoto out_iounmap;\r\n}\r\npci_set_drvdata(pdev, host);\r\nprintk(KERN_WARNING "3w-sas: scsi%d: Found an LSI 3ware %s Controller at 0x%llx, IRQ: %d.\n",\r\nhost->host_no,\r\n(char *)twl_get_param(tw_dev, 1, TW_VERSION_TABLE,\r\nTW_PARAM_MODEL, TW_PARAM_MODEL_LENGTH),\r\n(u64)pci_resource_start(pdev, 1), pdev->irq);\r\nptr_phycount = twl_get_param(tw_dev, 2, TW_PARAM_PHY_SUMMARY_TABLE,\r\nTW_PARAM_PHYCOUNT, TW_PARAM_PHYCOUNT_LENGTH);\r\nif (ptr_phycount)\r\nphycount = le32_to_cpu(*(int *)ptr_phycount);\r\nprintk(KERN_WARNING "3w-sas: scsi%d: Firmware %s, BIOS %s, Phys: %d.\n",\r\nhost->host_no,\r\n(char *)twl_get_param(tw_dev, 1, TW_VERSION_TABLE,\r\nTW_PARAM_FWVER, TW_PARAM_FWVER_LENGTH),\r\n(char *)twl_get_param(tw_dev, 2, TW_VERSION_TABLE,\r\nTW_PARAM_BIOSVER, TW_PARAM_BIOSVER_LENGTH),\r\nphycount);\r\nif (use_msi && !pci_enable_msi(pdev))\r\nset_bit(TW_USING_MSI, &tw_dev->flags);\r\nretval = request_irq(pdev->irq, twl_interrupt, IRQF_SHARED, "3w-sas", tw_dev);\r\nif (retval) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x1f, "Error requesting IRQ");\r\ngoto out_remove_host;\r\n}\r\ntwl_device_extension_list[twl_device_extension_count] = tw_dev;\r\ntwl_device_extension_count++;\r\nTWL_UNMASK_INTERRUPTS(tw_dev);\r\nscsi_scan_host(host);\r\nif (sysfs_create_bin_file(&host->shost_dev.kobj, &twl_sysfs_aen_read_attr))\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x20, "Failed to create sysfs binary file: 3ware_aen_read");\r\nif (sysfs_create_bin_file(&host->shost_dev.kobj, &twl_sysfs_compat_info_attr))\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x21, "Failed to create sysfs binary file: 3ware_compat_info");\r\nif (twl_major == -1) {\r\nif ((twl_major = register_chrdev (0, "twl", &twl_fops)) < 0)\r\nTW_PRINTK(host, TW_DRIVER, 0x22, "Failed to register character device");\r\n}\r\ntw_dev->online = 1;\r\nreturn 0;\r\nout_remove_host:\r\nif (test_bit(TW_USING_MSI, &tw_dev->flags))\r\npci_disable_msi(pdev);\r\nscsi_remove_host(host);\r\nout_iounmap:\r\niounmap(tw_dev->base_addr);\r\nout_release_mem_region:\r\npci_release_regions(pdev);\r\nout_free_device_extension:\r\ntwl_free_device_extension(tw_dev);\r\nscsi_host_put(host);\r\nout_disable_device:\r\npci_disable_device(pdev);\r\nreturn retval;\r\n}\r\nstatic void twl_remove(struct pci_dev *pdev)\r\n{\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nTW_Device_Extension *tw_dev;\r\nif (!host)\r\nreturn;\r\ntw_dev = (TW_Device_Extension *)host->hostdata;\r\nif (!tw_dev->online)\r\nreturn;\r\nsysfs_remove_bin_file(&host->shost_dev.kobj, &twl_sysfs_aen_read_attr);\r\nsysfs_remove_bin_file(&host->shost_dev.kobj, &twl_sysfs_compat_info_attr);\r\nscsi_remove_host(tw_dev->host);\r\nif (twl_major >= 0) {\r\nunregister_chrdev(twl_major, "twl");\r\ntwl_major = -1;\r\n}\r\n__twl_shutdown(tw_dev);\r\nif (test_bit(TW_USING_MSI, &tw_dev->flags))\r\npci_disable_msi(pdev);\r\niounmap(tw_dev->base_addr);\r\npci_release_regions(pdev);\r\ntwl_free_device_extension(tw_dev);\r\nscsi_host_put(tw_dev->host);\r\npci_disable_device(pdev);\r\ntwl_device_extension_count--;\r\n}\r\nstatic int twl_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nTW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;\r\nprintk(KERN_WARNING "3w-sas: Suspending host %d.\n", tw_dev->host->host_no);\r\nTWL_MASK_INTERRUPTS(tw_dev);\r\nfree_irq(tw_dev->tw_pci_dev->irq, tw_dev);\r\nif (twl_initconnection(tw_dev, 1, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, NULL)) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x23, "Connection shutdown failed during suspend");\r\n} else {\r\nprintk(KERN_WARNING "3w-sas: Suspend complete.\n");\r\n}\r\nTWL_CLEAR_DB_INTERRUPT(tw_dev);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int twl_resume(struct pci_dev *pdev)\r\n{\r\nint retval = 0;\r\nstruct Scsi_Host *host = pci_get_drvdata(pdev);\r\nTW_Device_Extension *tw_dev = (TW_Device_Extension *)host->hostdata;\r\nprintk(KERN_WARNING "3w-sas: Resuming host %d.\n", tw_dev->host->host_no);\r\npci_set_power_state(pdev, PCI_D0);\r\npci_enable_wake(pdev, PCI_D0, 0);\r\npci_restore_state(pdev);\r\nretval = pci_enable_device(pdev);\r\nif (retval) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x24, "Enable device failed during resume");\r\nreturn retval;\r\n}\r\npci_set_master(pdev);\r\npci_try_set_mwi(pdev);\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(64))\r\n|| pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64)))\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))\r\n|| pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nTW_PRINTK(host, TW_DRIVER, 0x25, "Failed to set dma mask during resume");\r\nretval = -ENODEV;\r\ngoto out_disable_device;\r\n}\r\nif (twl_reset_sequence(tw_dev, 0)) {\r\nretval = -ENODEV;\r\ngoto out_disable_device;\r\n}\r\nretval = request_irq(pdev->irq, twl_interrupt, IRQF_SHARED, "3w-sas", tw_dev);\r\nif (retval) {\r\nTW_PRINTK(tw_dev->host, TW_DRIVER, 0x26, "Error requesting IRQ during resume");\r\nretval = -ENODEV;\r\ngoto out_disable_device;\r\n}\r\nif (test_bit(TW_USING_MSI, &tw_dev->flags))\r\npci_enable_msi(pdev);\r\nTWL_UNMASK_INTERRUPTS(tw_dev);\r\nprintk(KERN_WARNING "3w-sas: Resume complete.\n");\r\nreturn 0;\r\nout_disable_device:\r\nscsi_remove_host(host);\r\npci_disable_device(pdev);\r\nreturn retval;\r\n}\r\nstatic int __init twl_init(void)\r\n{\r\nprintk(KERN_INFO "LSI 3ware SAS/SATA-RAID Controller device driver for Linux v%s.\n", TW_DRIVER_VERSION);\r\nreturn pci_register_driver(&twl_driver);\r\n}\r\nstatic void __exit twl_exit(void)\r\n{\r\npci_unregister_driver(&twl_driver);\r\n}
