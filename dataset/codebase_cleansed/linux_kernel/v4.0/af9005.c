static int af9005_generic_read_write(struct dvb_usb_device *d, u16 reg,\r\nint readwrite, int type, u8 * values, int len)\r\n{\r\nstruct af9005_device_state *st = d->priv;\r\nu8 obuf[16] = { 0 };\r\nu8 ibuf[17] = { 0 };\r\nu8 command;\r\nint i;\r\nint ret;\r\nif (len < 1) {\r\nerr("generic read/write, less than 1 byte. Makes no sense.");\r\nreturn -EINVAL;\r\n}\r\nif (len > 8) {\r\nerr("generic read/write, more than 8 bytes. Not supported.");\r\nreturn -EINVAL;\r\n}\r\nobuf[0] = 14;\r\nobuf[1] = 0;\r\nobuf[2] = AF9005_REGISTER_RW;\r\nobuf[3] = 12;\r\nobuf[4] = st->sequence++;\r\nobuf[5] = (u8) (reg >> 8);\r\nobuf[6] = (u8) (reg & 0xff);\r\nif (type == AF9005_OFDM_REG) {\r\ncommand = AF9005_CMD_OFDM_REG;\r\n} else {\r\ncommand = AF9005_CMD_TUNER;\r\n}\r\nif (len > 1)\r\ncommand |=\r\nAF9005_CMD_BURST | AF9005_CMD_AUTOINC | (len - 1) << 3;\r\ncommand |= readwrite;\r\nif (readwrite == AF9005_CMD_WRITE)\r\nfor (i = 0; i < len; i++)\r\nobuf[8 + i] = values[i];\r\nelse if (type == AF9005_TUNER_REG)\r\nobuf[8] = values[0];\r\nobuf[7] = command;\r\nret = dvb_usb_generic_rw(d, obuf, 16, ibuf, 17, 0);\r\nif (ret)\r\nreturn ret;\r\nif (ibuf[2] != AF9005_REGISTER_RW_ACK) {\r\nerr("generic read/write, wrong reply code.");\r\nreturn -EIO;\r\n}\r\nif (ibuf[3] != 0x0d) {\r\nerr("generic read/write, wrong length in reply.");\r\nreturn -EIO;\r\n}\r\nif (ibuf[4] != obuf[4]) {\r\nerr("generic read/write, wrong sequence in reply.");\r\nreturn -EIO;\r\n}\r\nif (ibuf[16] != 0x01) {\r\nerr("generic read/write wrong status code in reply.");\r\nreturn -EIO;\r\n}\r\nif (readwrite == AF9005_CMD_READ)\r\nfor (i = 0; i < len; i++)\r\nvalues[i] = ibuf[8 + i];\r\nreturn 0;\r\n}\r\nint af9005_read_ofdm_register(struct dvb_usb_device *d, u16 reg, u8 * value)\r\n{\r\nint ret;\r\ndeb_reg("read register %x ", reg);\r\nret = af9005_generic_read_write(d, reg,\r\nAF9005_CMD_READ, AF9005_OFDM_REG,\r\nvalue, 1);\r\nif (ret)\r\ndeb_reg("failed\n");\r\nelse\r\ndeb_reg("value %x\n", *value);\r\nreturn ret;\r\n}\r\nint af9005_read_ofdm_registers(struct dvb_usb_device *d, u16 reg,\r\nu8 * values, int len)\r\n{\r\nint ret;\r\ndeb_reg("read %d registers %x ", len, reg);\r\nret = af9005_generic_read_write(d, reg,\r\nAF9005_CMD_READ, AF9005_OFDM_REG,\r\nvalues, len);\r\nif (ret)\r\ndeb_reg("failed\n");\r\nelse\r\ndebug_dump(values, len, deb_reg);\r\nreturn ret;\r\n}\r\nint af9005_write_ofdm_register(struct dvb_usb_device *d, u16 reg, u8 value)\r\n{\r\nint ret;\r\nu8 temp = value;\r\ndeb_reg("write register %x value %x ", reg, value);\r\nret = af9005_generic_read_write(d, reg,\r\nAF9005_CMD_WRITE, AF9005_OFDM_REG,\r\n&temp, 1);\r\nif (ret)\r\ndeb_reg("failed\n");\r\nelse\r\ndeb_reg("ok\n");\r\nreturn ret;\r\n}\r\nint af9005_write_ofdm_registers(struct dvb_usb_device *d, u16 reg,\r\nu8 * values, int len)\r\n{\r\nint ret;\r\ndeb_reg("write %d registers %x values ", len, reg);\r\ndebug_dump(values, len, deb_reg);\r\nret = af9005_generic_read_write(d, reg,\r\nAF9005_CMD_WRITE, AF9005_OFDM_REG,\r\nvalues, len);\r\nif (ret)\r\ndeb_reg("failed\n");\r\nelse\r\ndeb_reg("ok\n");\r\nreturn ret;\r\n}\r\nint af9005_read_register_bits(struct dvb_usb_device *d, u16 reg, u8 pos,\r\nu8 len, u8 * value)\r\n{\r\nu8 temp;\r\nint ret;\r\ndeb_reg("read bits %x %x %x", reg, pos, len);\r\nret = af9005_read_ofdm_register(d, reg, &temp);\r\nif (ret) {\r\ndeb_reg(" failed\n");\r\nreturn ret;\r\n}\r\n*value = (temp >> pos) & regmask[len - 1];\r\ndeb_reg(" value %x\n", *value);\r\nreturn 0;\r\n}\r\nint af9005_write_register_bits(struct dvb_usb_device *d, u16 reg, u8 pos,\r\nu8 len, u8 value)\r\n{\r\nu8 temp, mask;\r\nint ret;\r\ndeb_reg("write bits %x %x %x value %x\n", reg, pos, len, value);\r\nif (pos == 0 && len == 8)\r\nreturn af9005_write_ofdm_register(d, reg, value);\r\nret = af9005_read_ofdm_register(d, reg, &temp);\r\nif (ret)\r\nreturn ret;\r\nmask = regmask[len - 1] << pos;\r\ntemp = (temp & ~mask) | ((value << pos) & mask);\r\nreturn af9005_write_ofdm_register(d, reg, temp);\r\n}\r\nstatic int af9005_usb_read_tuner_registers(struct dvb_usb_device *d,\r\nu16 reg, u8 * values, int len)\r\n{\r\nreturn af9005_generic_read_write(d, reg,\r\nAF9005_CMD_READ, AF9005_TUNER_REG,\r\nvalues, len);\r\n}\r\nstatic int af9005_usb_write_tuner_registers(struct dvb_usb_device *d,\r\nu16 reg, u8 * values, int len)\r\n{\r\nreturn af9005_generic_read_write(d, reg,\r\nAF9005_CMD_WRITE,\r\nAF9005_TUNER_REG, values, len);\r\n}\r\nint af9005_write_tuner_registers(struct dvb_usb_device *d, u16 reg,\r\nu8 * values, int len)\r\n{\r\nint ret, i, done = 0, fail = 0;\r\nu8 temp;\r\nret = af9005_usb_write_tuner_registers(d, reg, values, len);\r\nif (ret)\r\nreturn ret;\r\nif (reg != 0xffff) {\r\nfor (i = 0; i < 200; i++) {\r\nret =\r\naf9005_read_ofdm_register(d,\r\nxd_I2C_i2c_m_status_wdat_done,\r\n&temp);\r\nif (ret)\r\nreturn ret;\r\ndone = temp & (regmask[i2c_m_status_wdat_done_len - 1]\r\n<< i2c_m_status_wdat_done_pos);\r\nif (done)\r\nbreak;\r\nfail = temp & (regmask[i2c_m_status_wdat_fail_len - 1]\r\n<< i2c_m_status_wdat_fail_pos);\r\nif (fail)\r\nbreak;\r\nmsleep(50);\r\n}\r\nif (i == 200)\r\nreturn -ETIMEDOUT;\r\nif (fail) {\r\naf9005_write_register_bits(d,\r\nxd_I2C_i2c_m_status_wdat_fail,\r\ni2c_m_status_wdat_fail_pos,\r\ni2c_m_status_wdat_fail_len,\r\n1);\r\nreturn -EIO;\r\n}\r\nret =\r\naf9005_write_register_bits(d,\r\nxd_I2C_i2c_m_status_wdat_fail,\r\ni2c_m_status_wdat_done_pos,\r\ni2c_m_status_wdat_done_len, 1);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint af9005_read_tuner_registers(struct dvb_usb_device *d, u16 reg, u8 addr,\r\nu8 * values, int len)\r\n{\r\nint ret, i;\r\nu8 temp, buf[2];\r\nbuf[0] = addr;\r\nbuf[1] = values[0];\r\nvalues[0] = addr + 0x01;\r\nif (reg == APO_REG_I2C_RW_SILICON_TUNER) {\r\nret = af9005_write_tuner_registers(d, 0x00c0, buf, 2);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = af9005_usb_read_tuner_registers(d, reg, values, 1);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < 200; i++) {\r\nret = af9005_read_ofdm_register(d, 0xa408, &temp);\r\nif (ret)\r\nreturn ret;\r\nif (temp & 0x01)\r\nbreak;\r\nmsleep(50);\r\n}\r\nif (i == 200)\r\nreturn -ETIMEDOUT;\r\nret = af9005_write_ofdm_register(d, xd_I2C_i2c_m_data8, 1);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < len; i++) {\r\nret = af9005_read_ofdm_register(d, 0xa400 + i, &temp);\r\nif (ret)\r\nreturn ret;\r\nvalues[i] = temp;\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9005_i2c_write(struct dvb_usb_device *d, u8 i2caddr, u8 reg,\r\nu8 * data, int len)\r\n{\r\nint ret, i;\r\nu8 buf[3];\r\ndeb_i2c("i2c_write i2caddr %x, reg %x, len %d data ", i2caddr,\r\nreg, len);\r\ndebug_dump(data, len, deb_i2c);\r\nfor (i = 0; i < len; i++) {\r\nbuf[0] = i2caddr;\r\nbuf[1] = reg + (u8) i;\r\nbuf[2] = data[i];\r\nret =\r\naf9005_write_tuner_registers(d,\r\nAPO_REG_I2C_RW_SILICON_TUNER,\r\nbuf, 3);\r\nif (ret) {\r\ndeb_i2c("i2c_write failed\n");\r\nreturn ret;\r\n}\r\n}\r\ndeb_i2c("i2c_write ok\n");\r\nreturn 0;\r\n}\r\nstatic int af9005_i2c_read(struct dvb_usb_device *d, u8 i2caddr, u8 reg,\r\nu8 * data, int len)\r\n{\r\nint ret, i;\r\nu8 temp;\r\ndeb_i2c("i2c_read i2caddr %x, reg %x, len %d\n ", i2caddr, reg, len);\r\nfor (i = 0; i < len; i++) {\r\ntemp = reg + i;\r\nret =\r\naf9005_read_tuner_registers(d,\r\nAPO_REG_I2C_RW_SILICON_TUNER,\r\ni2caddr, &temp, 1);\r\nif (ret) {\r\ndeb_i2c("i2c_read failed\n");\r\nreturn ret;\r\n}\r\ndata[i] = temp;\r\n}\r\ndeb_i2c("i2c data read: ");\r\ndebug_dump(data, len, deb_i2c);\r\nreturn 0;\r\n}\r\nstatic int af9005_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint ret;\r\nu8 reg, addr;\r\nu8 *value;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nif (num > 2)\r\nwarn("more than 2 i2c messages at a time is not handled yet. TODO.");\r\nif (num == 2) {\r\nreg = *msg[0].buf;\r\naddr = msg[0].addr;\r\nvalue = msg[1].buf;\r\nret = af9005_i2c_read(d, addr, reg, value, 1);\r\nif (ret == 0)\r\nret = 2;\r\n} else {\r\nreg = msg[0].buf[0];\r\naddr = msg[0].addr;\r\nvalue = &msg[0].buf[1];\r\nret = af9005_i2c_write(d, addr, reg, value, msg[0].len - 1);\r\nif (ret == 0)\r\nret = 1;\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic u32 af9005_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nint af9005_send_command(struct dvb_usb_device *d, u8 command, u8 * wbuf,\r\nint wlen, u8 * rbuf, int rlen)\r\n{\r\nstruct af9005_device_state *st = d->priv;\r\nint ret, i, packet_len;\r\nu8 buf[64];\r\nu8 ibuf[64];\r\nif (wlen < 0) {\r\nerr("send command, wlen less than 0 bytes. Makes no sense.");\r\nreturn -EINVAL;\r\n}\r\nif (wlen > 54) {\r\nerr("send command, wlen more than 54 bytes. Not supported.");\r\nreturn -EINVAL;\r\n}\r\nif (rlen > 54) {\r\nerr("send command, rlen more than 54 bytes. Not supported.");\r\nreturn -EINVAL;\r\n}\r\npacket_len = wlen + 5;\r\nbuf[0] = (u8) (packet_len & 0xff);\r\nbuf[1] = (u8) ((packet_len & 0xff00) >> 8);\r\nbuf[2] = 0x26;\r\nbuf[3] = wlen + 3;\r\nbuf[4] = st->sequence++;\r\nbuf[5] = command;\r\nbuf[6] = wlen;\r\nfor (i = 0; i < wlen; i++)\r\nbuf[7 + i] = wbuf[i];\r\nret = dvb_usb_generic_rw(d, buf, wlen + 7, ibuf, rlen + 7, 0);\r\nif (ret)\r\nreturn ret;\r\nif (ibuf[2] != 0x27) {\r\nerr("send command, wrong reply code.");\r\nreturn -EIO;\r\n}\r\nif (ibuf[4] != buf[4]) {\r\nerr("send command, wrong sequence in reply.");\r\nreturn -EIO;\r\n}\r\nif (ibuf[5] != 0x01) {\r\nerr("send command, wrong status code in reply.");\r\nreturn -EIO;\r\n}\r\nif (ibuf[6] != rlen) {\r\nerr("send command, invalid data length in reply.");\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < rlen; i++)\r\nrbuf[i] = ibuf[i + 7];\r\nreturn 0;\r\n}\r\nint af9005_read_eeprom(struct dvb_usb_device *d, u8 address, u8 * values,\r\nint len)\r\n{\r\nstruct af9005_device_state *st = d->priv;\r\nu8 obuf[16], ibuf[14];\r\nint ret, i;\r\nmemset(obuf, 0, sizeof(obuf));\r\nmemset(ibuf, 0, sizeof(ibuf));\r\nobuf[0] = 14;\r\nobuf[1] = 0;\r\nobuf[2] = 0x2a;\r\nobuf[3] = 12;\r\nobuf[4] = st->sequence++;\r\nobuf[5] = 0;\r\nobuf[6] = len;\r\nobuf[7] = address;\r\nret = dvb_usb_generic_rw(d, obuf, 16, ibuf, 14, 0);\r\nif (ret)\r\nreturn ret;\r\nif (ibuf[2] != 0x2b) {\r\nerr("Read eeprom, invalid reply code");\r\nreturn -EIO;\r\n}\r\nif (ibuf[3] != 10) {\r\nerr("Read eeprom, invalid reply length");\r\nreturn -EIO;\r\n}\r\nif (ibuf[4] != obuf[4]) {\r\nerr("Read eeprom, wrong sequence in reply ");\r\nreturn -EIO;\r\n}\r\nif (ibuf[5] != 1) {\r\nerr("Read eeprom, wrong status in reply ");\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nvalues[i] = ibuf[6 + i];\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9005_boot_packet(struct usb_device *udev, int type, u8 * reply)\r\n{\r\nu8 buf[FW_BULKOUT_SIZE + 2];\r\nu16 checksum;\r\nint act_len, i, ret;\r\nmemset(buf, 0, sizeof(buf));\r\nbuf[0] = (u8) (FW_BULKOUT_SIZE & 0xff);\r\nbuf[1] = (u8) ((FW_BULKOUT_SIZE >> 8) & 0xff);\r\nswitch (type) {\r\ncase FW_CONFIG:\r\nbuf[2] = 0x11;\r\nbuf[3] = 0x04;\r\nbuf[4] = 0x00;\r\nbuf[5] = 0x03;\r\nchecksum = buf[4] + buf[5];\r\nbuf[6] = (u8) ((checksum >> 8) & 0xff);\r\nbuf[7] = (u8) (checksum & 0xff);\r\nbreak;\r\ncase FW_CONFIRM:\r\nbuf[2] = 0x11;\r\nbuf[3] = 0x04;\r\nbuf[4] = 0x00;\r\nbuf[5] = 0x01;\r\nchecksum = buf[4] + buf[5];\r\nbuf[6] = (u8) ((checksum >> 8) & 0xff);\r\nbuf[7] = (u8) (checksum & 0xff);\r\nbreak;\r\ncase FW_BOOT:\r\nbuf[2] = 0x10;\r\nbuf[3] = 0x08;\r\nbuf[4] = 0x00;\r\nbuf[5] = 0x97;\r\nbuf[6] = 0xaa;\r\nbuf[7] = 0x55;\r\nbuf[8] = 0xa5;\r\nbuf[9] = 0x5a;\r\nchecksum = 0;\r\nfor (i = 4; i <= 9; i++)\r\nchecksum += buf[i];\r\nbuf[10] = (u8) ((checksum >> 8) & 0xff);\r\nbuf[11] = (u8) (checksum & 0xff);\r\nbreak;\r\ndefault:\r\nerr("boot packet invalid boot packet type");\r\nreturn -EINVAL;\r\n}\r\ndeb_fw(">>> ");\r\ndebug_dump(buf, FW_BULKOUT_SIZE + 2, deb_fw);\r\nret = usb_bulk_msg(udev,\r\nusb_sndbulkpipe(udev, 0x02),\r\nbuf, FW_BULKOUT_SIZE + 2, &act_len, 2000);\r\nif (ret)\r\nerr("boot packet bulk message failed: %d (%d/%d)", ret,\r\nFW_BULKOUT_SIZE + 2, act_len);\r\nelse\r\nret = act_len != FW_BULKOUT_SIZE + 2 ? -1 : 0;\r\nif (ret)\r\nreturn ret;\r\nmemset(buf, 0, 9);\r\nret = usb_bulk_msg(udev,\r\nusb_rcvbulkpipe(udev, 0x01), buf, 9, &act_len, 2000);\r\nif (ret) {\r\nerr("boot packet recv bulk message failed: %d", ret);\r\nreturn ret;\r\n}\r\ndeb_fw("<<< ");\r\ndebug_dump(buf, act_len, deb_fw);\r\nchecksum = 0;\r\nswitch (type) {\r\ncase FW_CONFIG:\r\nif (buf[2] != 0x11) {\r\nerr("boot bad config header.");\r\nreturn -EIO;\r\n}\r\nif (buf[3] != 0x05) {\r\nerr("boot bad config size.");\r\nreturn -EIO;\r\n}\r\nif (buf[4] != 0x00) {\r\nerr("boot bad config sequence.");\r\nreturn -EIO;\r\n}\r\nif (buf[5] != 0x04) {\r\nerr("boot bad config subtype.");\r\nreturn -EIO;\r\n}\r\nfor (i = 4; i <= 6; i++)\r\nchecksum += buf[i];\r\nif (buf[7] * 256 + buf[8] != checksum) {\r\nerr("boot bad config checksum.");\r\nreturn -EIO;\r\n}\r\n*reply = buf[6];\r\nbreak;\r\ncase FW_CONFIRM:\r\nif (buf[2] != 0x11) {\r\nerr("boot bad confirm header.");\r\nreturn -EIO;\r\n}\r\nif (buf[3] != 0x05) {\r\nerr("boot bad confirm size.");\r\nreturn -EIO;\r\n}\r\nif (buf[4] != 0x00) {\r\nerr("boot bad confirm sequence.");\r\nreturn -EIO;\r\n}\r\nif (buf[5] != 0x02) {\r\nerr("boot bad confirm subtype.");\r\nreturn -EIO;\r\n}\r\nfor (i = 4; i <= 6; i++)\r\nchecksum += buf[i];\r\nif (buf[7] * 256 + buf[8] != checksum) {\r\nerr("boot bad confirm checksum.");\r\nreturn -EIO;\r\n}\r\n*reply = buf[6];\r\nbreak;\r\ncase FW_BOOT:\r\nif (buf[2] != 0x10) {\r\nerr("boot bad boot header.");\r\nreturn -EIO;\r\n}\r\nif (buf[3] != 0x05) {\r\nerr("boot bad boot size.");\r\nreturn -EIO;\r\n}\r\nif (buf[4] != 0x00) {\r\nerr("boot bad boot sequence.");\r\nreturn -EIO;\r\n}\r\nif (buf[5] != 0x01) {\r\nerr("boot bad boot pattern 01.");\r\nreturn -EIO;\r\n}\r\nif (buf[6] != 0x10) {\r\nerr("boot bad boot pattern 10.");\r\nreturn -EIO;\r\n}\r\nfor (i = 4; i <= 6; i++)\r\nchecksum += buf[i];\r\nif (buf[7] * 256 + buf[8] != checksum) {\r\nerr("boot bad boot checksum.");\r\nreturn -EIO;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9005_download_firmware(struct usb_device *udev, const struct firmware *fw)\r\n{\r\nint i, packets, ret, act_len;\r\nu8 buf[FW_BULKOUT_SIZE + 2];\r\nu8 reply;\r\nret = af9005_boot_packet(udev, FW_CONFIG, &reply);\r\nif (ret)\r\nreturn ret;\r\nif (reply != 0x01) {\r\nerr("before downloading firmware, FW_CONFIG expected 0x01, received 0x%x", reply);\r\nreturn -EIO;\r\n}\r\npackets = fw->size / FW_BULKOUT_SIZE;\r\nbuf[0] = (u8) (FW_BULKOUT_SIZE & 0xff);\r\nbuf[1] = (u8) ((FW_BULKOUT_SIZE >> 8) & 0xff);\r\nfor (i = 0; i < packets; i++) {\r\nmemcpy(&buf[2], fw->data + i * FW_BULKOUT_SIZE,\r\nFW_BULKOUT_SIZE);\r\ndeb_fw(">>> ");\r\ndebug_dump(buf, FW_BULKOUT_SIZE + 2, deb_fw);\r\nret = usb_bulk_msg(udev,\r\nusb_sndbulkpipe(udev, 0x02),\r\nbuf, FW_BULKOUT_SIZE + 2, &act_len, 1000);\r\nif (ret) {\r\nerr("firmware download failed at packet %d with code %d", i, ret);\r\nreturn ret;\r\n}\r\n}\r\nret = af9005_boot_packet(udev, FW_CONFIRM, &reply);\r\nif (ret)\r\nreturn ret;\r\nif (reply != (u8) (packets & 0xff)) {\r\nerr("after downloading firmware, FW_CONFIRM expected 0x%x, received 0x%x", packets & 0xff, reply);\r\nreturn -EIO;\r\n}\r\nret = af9005_boot_packet(udev, FW_BOOT, &reply);\r\nif (ret)\r\nreturn ret;\r\nret = af9005_boot_packet(udev, FW_CONFIG, &reply);\r\nif (ret)\r\nreturn ret;\r\nif (reply != 0x02) {\r\nerr("after downloading firmware, FW_CONFIG expected 0x02, received 0x%x", reply);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint af9005_led_control(struct dvb_usb_device *d, int onoff)\r\n{\r\nstruct af9005_device_state *st = d->priv;\r\nint temp, ret;\r\nif (onoff && dvb_usb_af9005_led)\r\ntemp = 1;\r\nelse\r\ntemp = 0;\r\nif (st->led_state != temp) {\r\nret =\r\naf9005_write_register_bits(d, xd_p_reg_top_locken1,\r\nreg_top_locken1_pos,\r\nreg_top_locken1_len, temp);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_write_register_bits(d, xd_p_reg_top_lock1,\r\nreg_top_lock1_pos,\r\nreg_top_lock1_len, temp);\r\nif (ret)\r\nreturn ret;\r\nst->led_state = temp;\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9005_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nu8 buf[8];\r\nint i;\r\nstruct usb_device *udev = adap->dev->udev;\r\nusb_clear_halt(udev, usb_sndbulkpipe(udev, 2));\r\nusb_clear_halt(udev, usb_rcvbulkpipe(udev, 1));\r\nif (dvb_usb_af9005_dump_eeprom) {\r\nprintk("EEPROM DUMP\n");\r\nfor (i = 0; i < 255; i += 8) {\r\naf9005_read_eeprom(adap->dev, i, buf, 8);\r\nprintk("ADDR %x ", i);\r\ndebug_dump(buf, 8, printk);\r\n}\r\n}\r\nadap->fe_adap[0].fe = af9005_fe_attach(adap->dev);\r\nreturn 0;\r\n}\r\nstatic int af9005_rc_query(struct dvb_usb_device *d, u32 * event, int *state)\r\n{\r\nstruct af9005_device_state *st = d->priv;\r\nint ret, len;\r\nu8 obuf[5];\r\nu8 ibuf[256];\r\n*state = REMOTE_NO_KEY_PRESSED;\r\nif (rc_decode == NULL) {\r\nreturn 0;\r\n}\r\nobuf[0] = 3;\r\nobuf[1] = 0;\r\nobuf[2] = 0x40;\r\nobuf[3] = 1;\r\nobuf[4] = st->sequence++;\r\nret = dvb_usb_generic_rw(d, obuf, 5, ibuf, 256, 0);\r\nif (ret) {\r\nerr("rc query failed");\r\nreturn ret;\r\n}\r\nif (ibuf[2] != 0x41) {\r\nerr("rc query bad header.");\r\nreturn -EIO;\r\n}\r\nif (ibuf[4] != obuf[4]) {\r\nerr("rc query bad sequence.");\r\nreturn -EIO;\r\n}\r\nlen = ibuf[5];\r\nif (len > 246) {\r\nerr("rc query invalid length");\r\nreturn -EIO;\r\n}\r\nif (len > 0) {\r\ndeb_rc("rc data (%d) ", len);\r\ndebug_dump((ibuf + 6), len, deb_rc);\r\nret = rc_decode(d, &ibuf[6], len, event, state);\r\nif (ret) {\r\nerr("rc_decode failed");\r\nreturn ret;\r\n} else {\r\ndeb_rc("rc_decode state %x event %x\n", *state, *event);\r\nif (*state == REMOTE_KEY_REPEAT)\r\n*event = d->last_event;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9005_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nreturn 0;\r\n}\r\nstatic int af9005_pid_filter_control(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nint ret;\r\ndeb_info("pid filter control onoff %d\n", onoff);\r\nif (onoff) {\r\nret =\r\naf9005_write_ofdm_register(adap->dev, XD_MP2IF_DMX_CTRL, 1);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_write_register_bits(adap->dev,\r\nXD_MP2IF_DMX_CTRL, 1, 1, 1);\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_write_ofdm_register(adap->dev, XD_MP2IF_DMX_CTRL, 1);\r\n} else\r\nret =\r\naf9005_write_ofdm_register(adap->dev, XD_MP2IF_DMX_CTRL, 0);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("pid filter control ok\n");\r\nreturn 0;\r\n}\r\nstatic int af9005_pid_filter(struct dvb_usb_adapter *adap, int index,\r\nu16 pid, int onoff)\r\n{\r\nu8 cmd = index & 0x1f;\r\nint ret;\r\ndeb_info("set pid filter, index %d, pid %x, onoff %d\n", index,\r\npid, onoff);\r\nif (onoff) {\r\nif (adap->feedcount == 1) {\r\ndeb_info("first pid set, enable pid table\n");\r\nret = af9005_pid_filter_control(adap, onoff);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret =\r\naf9005_write_ofdm_register(adap->dev,\r\nXD_MP2IF_PID_DATA_L,\r\n(u8) (pid & 0xff));\r\nif (ret)\r\nreturn ret;\r\nret =\r\naf9005_write_ofdm_register(adap->dev,\r\nXD_MP2IF_PID_DATA_H,\r\n(u8) (pid >> 8));\r\nif (ret)\r\nreturn ret;\r\ncmd |= 0x20 | 0x40;\r\n} else {\r\nif (adap->feedcount == 0) {\r\ndeb_info("last pid unset, disable pid table\n");\r\nret = af9005_pid_filter_control(adap, onoff);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nret = af9005_write_ofdm_register(adap->dev, XD_MP2IF_PID_IDX, cmd);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("set pid ok\n");\r\nreturn 0;\r\n}\r\nstatic int af9005_identify_state(struct usb_device *udev,\r\nstruct dvb_usb_device_properties *props,\r\nstruct dvb_usb_device_description **desc,\r\nint *cold)\r\n{\r\nint ret;\r\nu8 reply;\r\nret = af9005_boot_packet(udev, FW_CONFIG, &reply);\r\nif (ret)\r\nreturn ret;\r\ndeb_info("result of FW_CONFIG in identify state %d\n", reply);\r\nif (reply == 0x01)\r\n*cold = 1;\r\nelse if (reply == 0x02)\r\n*cold = 0;\r\nelse\r\nreturn -EIO;\r\ndeb_info("Identify state cold = %d\n", *cold);\r\nreturn 0;\r\n}\r\nstatic int af9005_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn dvb_usb_device_init(intf, &af9005_properties,\r\nTHIS_MODULE, NULL, adapter_nr);\r\n}\r\nstatic int __init af9005_usb_module_init(void)\r\n{\r\nint result;\r\nif ((result = usb_register(&af9005_usb_driver))) {\r\nerr("usb_register failed. (%d)", result);\r\nreturn result;\r\n}\r\n#if IS_MODULE(CONFIG_DVB_USB_AF9005) || defined(CONFIG_DVB_USB_AF9005_REMOTE)\r\nrc_decode = symbol_request(af9005_rc_decode);\r\nrc_keys = symbol_request(rc_map_af9005_table);\r\nrc_keys_size = symbol_request(rc_map_af9005_table_size);\r\n#endif\r\nif (rc_decode == NULL || rc_keys == NULL || rc_keys_size == NULL) {\r\nerr("af9005_rc_decode function not found, disabling remote");\r\naf9005_properties.rc.legacy.rc_query = NULL;\r\n} else {\r\naf9005_properties.rc.legacy.rc_map_table = rc_keys;\r\naf9005_properties.rc.legacy.rc_map_size = *rc_keys_size;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit af9005_usb_module_exit(void)\r\n{\r\nif (rc_decode != NULL)\r\nsymbol_put(af9005_rc_decode);\r\nif (rc_keys != NULL)\r\nsymbol_put(rc_map_af9005_table);\r\nif (rc_keys_size != NULL)\r\nsymbol_put(rc_map_af9005_table_size);\r\nusb_deregister(&af9005_usb_driver);\r\n}
