static int debuginfo__init_offline_dwarf(struct debuginfo *dbg,\r\nconst char *path)\r\n{\r\nint fd;\r\nfd = open(path, O_RDONLY);\r\nif (fd < 0)\r\nreturn fd;\r\ndbg->dwfl = dwfl_begin(&offline_callbacks);\r\nif (!dbg->dwfl)\r\ngoto error;\r\ndbg->mod = dwfl_report_offline(dbg->dwfl, "", "", fd);\r\nif (!dbg->mod)\r\ngoto error;\r\ndbg->dbg = dwfl_module_getdwarf(dbg->mod, &dbg->bias);\r\nif (!dbg->dbg)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nif (dbg->dwfl)\r\ndwfl_end(dbg->dwfl);\r\nelse\r\nclose(fd);\r\nmemset(dbg, 0, sizeof(*dbg));\r\nreturn -ENOENT;\r\n}\r\nstatic struct debuginfo *__debuginfo__new(const char *path)\r\n{\r\nstruct debuginfo *dbg = zalloc(sizeof(*dbg));\r\nif (!dbg)\r\nreturn NULL;\r\nif (debuginfo__init_offline_dwarf(dbg, path) < 0)\r\nzfree(&dbg);\r\nif (dbg)\r\npr_debug("Open Debuginfo file: %s\n", path);\r\nreturn dbg;\r\n}\r\nstruct debuginfo *debuginfo__new(const char *path)\r\n{\r\nenum dso_binary_type *type;\r\nchar buf[PATH_MAX], nil = '\0';\r\nstruct dso *dso;\r\nstruct debuginfo *dinfo = NULL;\r\ndso = dso__new(path);\r\nif (!dso)\r\ngoto out;\r\nfor (type = distro_dwarf_types;\r\n!dinfo && *type != DSO_BINARY_TYPE__NOT_FOUND;\r\ntype++) {\r\nif (dso__read_binary_type_filename(dso, *type, &nil,\r\nbuf, PATH_MAX) < 0)\r\ncontinue;\r\ndinfo = __debuginfo__new(buf);\r\n}\r\ndso__delete(dso);\r\nout:\r\nreturn dinfo ? : __debuginfo__new(path);\r\n}\r\nvoid debuginfo__delete(struct debuginfo *dbg)\r\n{\r\nif (dbg) {\r\nif (dbg->dwfl)\r\ndwfl_end(dbg->dwfl);\r\nfree(dbg);\r\n}\r\n}\r\nstatic struct probe_trace_arg_ref *alloc_trace_arg_ref(long offs)\r\n{\r\nstruct probe_trace_arg_ref *ref;\r\nref = zalloc(sizeof(struct probe_trace_arg_ref));\r\nif (ref != NULL)\r\nref->offset = offs;\r\nreturn ref;\r\n}\r\nstatic int convert_variable_location(Dwarf_Die *vr_die, Dwarf_Addr addr,\r\nDwarf_Op *fb_ops, Dwarf_Die *sp_die,\r\nstruct probe_trace_arg *tvar)\r\n{\r\nDwarf_Attribute attr;\r\nDwarf_Addr tmp = 0;\r\nDwarf_Op *op;\r\nsize_t nops;\r\nunsigned int regn;\r\nDwarf_Word offs = 0;\r\nbool ref = false;\r\nconst char *regs;\r\nint ret;\r\nif (dwarf_attr(vr_die, DW_AT_external, &attr) != NULL)\r\ngoto static_var;\r\nif (dwarf_attr(vr_die, DW_AT_location, &attr) == NULL)\r\nreturn -EINVAL;\r\nif (dwarf_getlocation_addr(&attr, addr, &op, &nops, 1) <= 0) {\r\nret = dwarf_entrypc(sp_die, &tmp);\r\nif (ret || addr != tmp ||\r\ndwarf_tag(vr_die) != DW_TAG_formal_parameter ||\r\ndwarf_highpc(sp_die, &tmp))\r\nreturn -ENOENT;\r\nfor (addr += 1; addr <= tmp; addr++) {\r\nif (dwarf_getlocation_addr(&attr, addr, &op,\r\n&nops, 1) > 0)\r\ngoto found;\r\n}\r\nreturn -ENOENT;\r\n}\r\nfound:\r\nif (nops == 0)\r\nreturn -ENOENT;\r\nif (op->atom == DW_OP_addr) {\r\nstatic_var:\r\nif (!tvar)\r\nreturn 0;\r\nret = strlen(dwarf_diename(vr_die));\r\ntvar->value = zalloc(ret + 2);\r\nif (tvar->value == NULL)\r\nreturn -ENOMEM;\r\nsnprintf(tvar->value, ret + 2, "@%s", dwarf_diename(vr_die));\r\ntvar->ref = alloc_trace_arg_ref((long)offs);\r\nif (tvar->ref == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nif (op->atom == DW_OP_fbreg) {\r\nif (fb_ops == NULL)\r\nreturn -ENOTSUP;\r\nref = true;\r\noffs = op->number;\r\nop = &fb_ops[0];\r\n}\r\nif (op->atom >= DW_OP_breg0 && op->atom <= DW_OP_breg31) {\r\nregn = op->atom - DW_OP_breg0;\r\noffs += op->number;\r\nref = true;\r\n} else if (op->atom >= DW_OP_reg0 && op->atom <= DW_OP_reg31) {\r\nregn = op->atom - DW_OP_reg0;\r\n} else if (op->atom == DW_OP_bregx) {\r\nregn = op->number;\r\noffs += op->number2;\r\nref = true;\r\n} else if (op->atom == DW_OP_regx) {\r\nregn = op->number;\r\n} else {\r\npr_debug("DW_OP %x is not supported.\n", op->atom);\r\nreturn -ENOTSUP;\r\n}\r\nif (!tvar)\r\nreturn 0;\r\nregs = get_arch_regstr(regn);\r\nif (!regs) {\r\npr_warning("Mapping for the register number %u "\r\n"missing on this architecture.\n", regn);\r\nreturn -ERANGE;\r\n}\r\ntvar->value = strdup(regs);\r\nif (tvar->value == NULL)\r\nreturn -ENOMEM;\r\nif (ref) {\r\ntvar->ref = alloc_trace_arg_ref((long)offs);\r\nif (tvar->ref == NULL)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int convert_variable_type(Dwarf_Die *vr_die,\r\nstruct probe_trace_arg *tvar,\r\nconst char *cast)\r\n{\r\nstruct probe_trace_arg_ref **ref_ptr = &tvar->ref;\r\nDwarf_Die type;\r\nchar buf[16];\r\nchar sbuf[STRERR_BUFSIZE];\r\nint bsize, boffs, total;\r\nint ret;\r\nif (cast && strcmp(cast, "string") != 0) {\r\ntvar->type = strdup(cast);\r\nreturn (tvar->type == NULL) ? -ENOMEM : 0;\r\n}\r\nbsize = dwarf_bitsize(vr_die);\r\nif (bsize > 0) {\r\nboffs = dwarf_bitoffset(vr_die);\r\ntotal = dwarf_bytesize(vr_die);\r\nif (boffs < 0 || total < 0)\r\nreturn -ENOENT;\r\nret = snprintf(buf, 16, "b%d@%d/%zd", bsize, boffs,\r\nBYTES_TO_BITS(total));\r\ngoto formatted;\r\n}\r\nif (die_get_real_type(vr_die, &type) == NULL) {\r\npr_warning("Failed to get a type information of %s.\n",\r\ndwarf_diename(vr_die));\r\nreturn -ENOENT;\r\n}\r\npr_debug("%s type is %s.\n",\r\ndwarf_diename(vr_die), dwarf_diename(&type));\r\nif (cast && strcmp(cast, "string") == 0) {\r\nret = dwarf_tag(&type);\r\nif (ret != DW_TAG_pointer_type &&\r\nret != DW_TAG_array_type) {\r\npr_warning("Failed to cast into string: "\r\n"%s(%s) is not a pointer nor array.\n",\r\ndwarf_diename(vr_die), dwarf_diename(&type));\r\nreturn -EINVAL;\r\n}\r\nif (die_get_real_type(&type, &type) == NULL) {\r\npr_warning("Failed to get a type"\r\n" information.\n");\r\nreturn -ENOENT;\r\n}\r\nif (ret == DW_TAG_pointer_type) {\r\nwhile (*ref_ptr)\r\nref_ptr = &(*ref_ptr)->next;\r\n*ref_ptr = zalloc(sizeof(struct probe_trace_arg_ref));\r\nif (*ref_ptr == NULL) {\r\npr_warning("Out of memory error\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (!die_compare_name(&type, "char") &&\r\n!die_compare_name(&type, "unsigned char")) {\r\npr_warning("Failed to cast into string: "\r\n"%s is not (unsigned) char *.\n",\r\ndwarf_diename(vr_die));\r\nreturn -EINVAL;\r\n}\r\ntvar->type = strdup(cast);\r\nreturn (tvar->type == NULL) ? -ENOMEM : 0;\r\n}\r\nret = dwarf_bytesize(&type);\r\nif (ret <= 0)\r\nreturn 0;\r\nret = BYTES_TO_BITS(ret);\r\nif (ret > MAX_BASIC_TYPE_BITS) {\r\npr_info("%s exceeds max-bitwidth. Cut down to %d bits.\n",\r\ndwarf_diename(&type), MAX_BASIC_TYPE_BITS);\r\nret = MAX_BASIC_TYPE_BITS;\r\n}\r\nret = snprintf(buf, 16, "%c%d",\r\ndie_is_signed_type(&type) ? 's' : 'u', ret);\r\nformatted:\r\nif (ret < 0 || ret >= 16) {\r\nif (ret >= 16)\r\nret = -E2BIG;\r\npr_warning("Failed to convert variable type: %s\n",\r\nstrerror_r(-ret, sbuf, sizeof(sbuf)));\r\nreturn ret;\r\n}\r\ntvar->type = strdup(buf);\r\nif (tvar->type == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int convert_variable_fields(Dwarf_Die *vr_die, const char *varname,\r\nstruct perf_probe_arg_field *field,\r\nstruct probe_trace_arg_ref **ref_ptr,\r\nDwarf_Die *die_mem)\r\n{\r\nstruct probe_trace_arg_ref *ref = *ref_ptr;\r\nDwarf_Die type;\r\nDwarf_Word offs;\r\nint ret, tag;\r\npr_debug("converting %s in %s\n", field->name, varname);\r\nif (die_get_real_type(vr_die, &type) == NULL) {\r\npr_warning("Failed to get the type of %s.\n", varname);\r\nreturn -ENOENT;\r\n}\r\npr_debug2("Var real type: (%x)\n", (unsigned)dwarf_dieoffset(&type));\r\ntag = dwarf_tag(&type);\r\nif (field->name[0] == '[' &&\r\n(tag == DW_TAG_array_type || tag == DW_TAG_pointer_type)) {\r\nif (field->next)\r\nmemcpy(die_mem, &type, sizeof(*die_mem));\r\nif (die_get_real_type(&type, &type) == NULL) {\r\npr_warning("Failed to get the type of %s.\n", varname);\r\nreturn -ENOENT;\r\n}\r\npr_debug2("Array real type: (%x)\n",\r\n(unsigned)dwarf_dieoffset(&type));\r\nif (tag == DW_TAG_pointer_type) {\r\nref = zalloc(sizeof(struct probe_trace_arg_ref));\r\nif (ref == NULL)\r\nreturn -ENOMEM;\r\nif (*ref_ptr)\r\n(*ref_ptr)->next = ref;\r\nelse\r\n*ref_ptr = ref;\r\n}\r\nref->offset += dwarf_bytesize(&type) * field->index;\r\nif (!field->next)\r\nmemcpy(die_mem, vr_die, sizeof(*die_mem));\r\ngoto next;\r\n} else if (tag == DW_TAG_pointer_type) {\r\nif (!field->ref) {\r\npr_err("Semantic error: %s must be referred by '->'\n",\r\nfield->name);\r\nreturn -EINVAL;\r\n}\r\nif (die_get_real_type(&type, &type) == NULL) {\r\npr_warning("Failed to get the type of %s.\n", varname);\r\nreturn -ENOENT;\r\n}\r\ntag = dwarf_tag(&type);\r\nif (tag != DW_TAG_structure_type && tag != DW_TAG_union_type) {\r\npr_warning("%s is not a data structure nor an union.\n",\r\nvarname);\r\nreturn -EINVAL;\r\n}\r\nref = zalloc(sizeof(struct probe_trace_arg_ref));\r\nif (ref == NULL)\r\nreturn -ENOMEM;\r\nif (*ref_ptr)\r\n(*ref_ptr)->next = ref;\r\nelse\r\n*ref_ptr = ref;\r\n} else {\r\nif (tag != DW_TAG_structure_type && tag != DW_TAG_union_type) {\r\npr_warning("%s is not a data structure nor an union.\n",\r\nvarname);\r\nreturn -EINVAL;\r\n}\r\nif (field->name[0] == '[') {\r\npr_err("Semantic error: %s is not a pointor"\r\n" nor array.\n", varname);\r\nreturn -EINVAL;\r\n}\r\nif (field->ref) {\r\npr_err("Semantic error: %s must be referred by '.'\n",\r\nfield->name);\r\nreturn -EINVAL;\r\n}\r\nif (!ref) {\r\npr_warning("Structure on a register is not "\r\n"supported yet.\n");\r\nreturn -ENOTSUP;\r\n}\r\n}\r\nif (die_find_member(&type, field->name, die_mem) == NULL) {\r\npr_warning("%s(type:%s) has no member %s.\n", varname,\r\ndwarf_diename(&type), field->name);\r\nreturn -EINVAL;\r\n}\r\nif (tag == DW_TAG_union_type) {\r\noffs = 0;\r\n} else {\r\nret = die_get_data_member_location(die_mem, &offs);\r\nif (ret < 0) {\r\npr_warning("Failed to get the offset of %s.\n",\r\nfield->name);\r\nreturn ret;\r\n}\r\n}\r\nref->offset += (long)offs;\r\nnext:\r\nif (field->next)\r\nreturn convert_variable_fields(die_mem, field->name,\r\nfield->next, &ref, die_mem);\r\nelse\r\nreturn 0;\r\n}\r\nstatic int convert_variable(Dwarf_Die *vr_die, struct probe_finder *pf)\r\n{\r\nDwarf_Die die_mem;\r\nint ret;\r\npr_debug("Converting variable %s into trace event.\n",\r\ndwarf_diename(vr_die));\r\nret = convert_variable_location(vr_die, pf->addr, pf->fb_ops,\r\n&pf->sp_die, pf->tvar);\r\nif (ret == -ENOENT || ret == -EINVAL)\r\npr_err("Failed to find the location of %s at this address.\n"\r\n" Perhaps, it has been optimized out.\n", pf->pvar->var);\r\nelse if (ret == -ENOTSUP)\r\npr_err("Sorry, we don't support this variable location yet.\n");\r\nelse if (ret == 0 && pf->pvar->field) {\r\nret = convert_variable_fields(vr_die, pf->pvar->var,\r\npf->pvar->field, &pf->tvar->ref,\r\n&die_mem);\r\nvr_die = &die_mem;\r\n}\r\nif (ret == 0)\r\nret = convert_variable_type(vr_die, pf->tvar, pf->pvar->type);\r\nreturn ret;\r\n}\r\nstatic int find_variable(Dwarf_Die *sc_die, struct probe_finder *pf)\r\n{\r\nDwarf_Die vr_die;\r\nchar buf[32], *ptr;\r\nint ret = 0;\r\nif (!is_c_varname(pf->pvar->var)) {\r\npf->tvar->value = strdup(pf->pvar->var);\r\nif (pf->tvar->value == NULL)\r\nreturn -ENOMEM;\r\nif (pf->pvar->type) {\r\npf->tvar->type = strdup(pf->pvar->type);\r\nif (pf->tvar->type == NULL)\r\nreturn -ENOMEM;\r\n}\r\nif (pf->pvar->name) {\r\npf->tvar->name = strdup(pf->pvar->name);\r\nif (pf->tvar->name == NULL)\r\nreturn -ENOMEM;\r\n} else\r\npf->tvar->name = NULL;\r\nreturn 0;\r\n}\r\nif (pf->pvar->name)\r\npf->tvar->name = strdup(pf->pvar->name);\r\nelse {\r\nret = synthesize_perf_probe_arg(pf->pvar, buf, 32);\r\nif (ret < 0)\r\nreturn ret;\r\nptr = strchr(buf, ':');\r\nif (ptr)\r\n*ptr = '_';\r\npf->tvar->name = strdup(buf);\r\n}\r\nif (pf->tvar->name == NULL)\r\nreturn -ENOMEM;\r\npr_debug("Searching '%s' variable in context.\n", pf->pvar->var);\r\nif (!die_find_variable_at(sc_die, pf->pvar->var, pf->addr, &vr_die)) {\r\nif (!die_find_variable_at(&pf->cu_die, pf->pvar->var, 0, &vr_die))\r\npr_warning("Failed to find '%s' in this function.\n",\r\npf->pvar->var);\r\nret = -ENOENT;\r\n}\r\nif (ret >= 0)\r\nret = convert_variable(&vr_die, pf);\r\nreturn ret;\r\n}\r\nstatic int convert_to_trace_point(Dwarf_Die *sp_die, Dwfl_Module *mod,\r\nDwarf_Addr paddr, bool retprobe,\r\nstruct probe_trace_point *tp)\r\n{\r\nDwarf_Addr eaddr, highaddr;\r\nGElf_Sym sym;\r\nconst char *symbol;\r\nif (dwarf_entrypc(sp_die, &eaddr) != 0) {\r\npr_warning("Failed to get entry address of %s\n",\r\ndwarf_diename(sp_die));\r\nreturn -ENOENT;\r\n}\r\nif (dwarf_highpc(sp_die, &highaddr) != 0) {\r\npr_warning("Failed to get end address of %s\n",\r\ndwarf_diename(sp_die));\r\nreturn -ENOENT;\r\n}\r\nif (paddr > highaddr) {\r\npr_warning("Offset specified is greater than size of %s\n",\r\ndwarf_diename(sp_die));\r\nreturn -EINVAL;\r\n}\r\nsymbol = dwarf_diename(sp_die);\r\nif (!symbol) {\r\nsymbol = dwfl_module_addrsym(mod, paddr, &sym, NULL);\r\nif (!symbol) {\r\npr_warning("Failed to find symbol at 0x%lx\n",\r\n(unsigned long)paddr);\r\nreturn -ENOENT;\r\n}\r\neaddr = sym.st_value;\r\n}\r\ntp->offset = (unsigned long)(paddr - eaddr);\r\ntp->address = (unsigned long)paddr;\r\ntp->symbol = strdup(symbol);\r\nif (!tp->symbol)\r\nreturn -ENOMEM;\r\nif (retprobe) {\r\nif (eaddr != paddr) {\r\npr_warning("Return probe must be on the head of"\r\n" a real function.\n");\r\nreturn -EINVAL;\r\n}\r\ntp->retprobe = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int call_probe_finder(Dwarf_Die *sc_die, struct probe_finder *pf)\r\n{\r\nDwarf_Attribute fb_attr;\r\nsize_t nops;\r\nint ret;\r\nif (!sc_die) {\r\npr_err("Caller must pass a scope DIE. Program error.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!die_is_func_def(sc_die)) {\r\nif (!die_find_realfunc(&pf->cu_die, pf->addr, &pf->sp_die)) {\r\npr_warning("Failed to find probe point in any "\r\n"functions.\n");\r\nreturn -ENOENT;\r\n}\r\n} else\r\nmemcpy(&pf->sp_die, sc_die, sizeof(Dwarf_Die));\r\ndwarf_attr(&pf->sp_die, DW_AT_frame_base, &fb_attr);\r\nret = dwarf_getlocation_addr(&fb_attr, pf->addr, &pf->fb_ops, &nops, 1);\r\nif (ret <= 0 || nops == 0) {\r\npf->fb_ops = NULL;\r\n#if _ELFUTILS_PREREQ(0, 142)\r\n} else if (nops == 1 && pf->fb_ops[0].atom == DW_OP_call_frame_cfa &&\r\npf->cfi != NULL) {\r\nDwarf_Frame *frame;\r\nif (dwarf_cfi_addrframe(pf->cfi, pf->addr, &frame) != 0 ||\r\ndwarf_frame_cfa(frame, &pf->fb_ops, &nops) != 0) {\r\npr_warning("Failed to get call frame on 0x%jx\n",\r\n(uintmax_t)pf->addr);\r\nreturn -ENOENT;\r\n}\r\n#endif\r\n}\r\nret = pf->callback(sc_die, pf);\r\npf->fb_ops = NULL;\r\nreturn ret;\r\n}\r\nstatic int find_best_scope_cb(Dwarf_Die *fn_die, void *data)\r\n{\r\nstruct find_scope_param *fsp = data;\r\nconst char *file;\r\nint lno;\r\nif (fsp->file) {\r\nfile = dwarf_decl_file(fn_die);\r\nif (!file || strcmp(fsp->file, file) != 0)\r\nreturn 0;\r\n}\r\nif (fsp->function) {\r\nif (die_compare_name(fn_die, fsp->function)) {\r\nmemcpy(fsp->die_mem, fn_die, sizeof(Dwarf_Die));\r\nfsp->found = true;\r\nreturn 1;\r\n}\r\n} else {\r\ndwarf_decl_line(fn_die, &lno);\r\nif (lno < fsp->line && fsp->diff > fsp->line - lno) {\r\nfsp->diff = fsp->line - lno;\r\nmemcpy(fsp->die_mem, fn_die, sizeof(Dwarf_Die));\r\nfsp->found = true;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic Dwarf_Die *find_best_scope(struct probe_finder *pf, Dwarf_Die *die_mem)\r\n{\r\nstruct find_scope_param fsp = {\r\n.function = pf->pev->point.function,\r\n.file = pf->fname,\r\n.line = pf->lno,\r\n.diff = INT_MAX,\r\n.die_mem = die_mem,\r\n.found = false,\r\n};\r\ncu_walk_functions_at(&pf->cu_die, pf->addr, find_best_scope_cb, &fsp);\r\nreturn fsp.found ? die_mem : NULL;\r\n}\r\nstatic int probe_point_line_walker(const char *fname, int lineno,\r\nDwarf_Addr addr, void *data)\r\n{\r\nstruct probe_finder *pf = data;\r\nDwarf_Die *sc_die, die_mem;\r\nint ret;\r\nif (lineno != pf->lno || strtailcmp(fname, pf->fname) != 0)\r\nreturn 0;\r\npf->addr = addr;\r\nsc_die = find_best_scope(pf, &die_mem);\r\nif (!sc_die) {\r\npr_warning("Failed to find scope of probe point.\n");\r\nreturn -ENOENT;\r\n}\r\nret = call_probe_finder(sc_die, pf);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic int find_probe_point_by_line(struct probe_finder *pf)\r\n{\r\nreturn die_walk_lines(&pf->cu_die, probe_point_line_walker, pf);\r\n}\r\nstatic int find_lazy_match_lines(struct intlist *list,\r\nconst char *fname, const char *pat)\r\n{\r\nFILE *fp;\r\nchar *line = NULL;\r\nsize_t line_len;\r\nssize_t len;\r\nint count = 0, linenum = 1;\r\nchar sbuf[STRERR_BUFSIZE];\r\nfp = fopen(fname, "r");\r\nif (!fp) {\r\npr_warning("Failed to open %s: %s\n", fname,\r\nstrerror_r(errno, sbuf, sizeof(sbuf)));\r\nreturn -errno;\r\n}\r\nwhile ((len = getline(&line, &line_len, fp)) > 0) {\r\nif (line[len - 1] == '\n')\r\nline[len - 1] = '\0';\r\nif (strlazymatch(line, pat)) {\r\nintlist__add(list, linenum);\r\ncount++;\r\n}\r\nlinenum++;\r\n}\r\nif (ferror(fp))\r\ncount = -errno;\r\nfree(line);\r\nfclose(fp);\r\nif (count == 0)\r\npr_debug("No matched lines found in %s.\n", fname);\r\nreturn count;\r\n}\r\nstatic int probe_point_lazy_walker(const char *fname, int lineno,\r\nDwarf_Addr addr, void *data)\r\n{\r\nstruct probe_finder *pf = data;\r\nDwarf_Die *sc_die, die_mem;\r\nint ret;\r\nif (!intlist__has_entry(pf->lcache, lineno) ||\r\nstrtailcmp(fname, pf->fname) != 0)\r\nreturn 0;\r\npr_debug("Probe line found: line:%d addr:0x%llx\n",\r\nlineno, (unsigned long long)addr);\r\npf->addr = addr;\r\npf->lno = lineno;\r\nsc_die = find_best_scope(pf, &die_mem);\r\nif (!sc_die) {\r\npr_warning("Failed to find scope of probe point.\n");\r\nreturn -ENOENT;\r\n}\r\nret = call_probe_finder(sc_die, pf);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic int find_probe_point_lazy(Dwarf_Die *sp_die, struct probe_finder *pf)\r\n{\r\nint ret = 0;\r\nif (intlist__empty(pf->lcache)) {\r\nret = find_lazy_match_lines(pf->lcache, pf->fname,\r\npf->pev->point.lazy_line);\r\nif (ret <= 0)\r\nreturn ret;\r\n}\r\nreturn die_walk_lines(sp_die, probe_point_lazy_walker, pf);\r\n}\r\nstatic int probe_point_inline_cb(Dwarf_Die *in_die, void *data)\r\n{\r\nstruct probe_finder *pf = data;\r\nstruct perf_probe_point *pp = &pf->pev->point;\r\nDwarf_Addr addr;\r\nint ret;\r\nif (pp->lazy_line)\r\nret = find_probe_point_lazy(in_die, pf);\r\nelse {\r\nif (dwarf_entrypc(in_die, &addr) != 0) {\r\npr_warning("Failed to get entry address of %s.\n",\r\ndwarf_diename(in_die));\r\nreturn -ENOENT;\r\n}\r\npf->addr = addr;\r\npf->addr += pp->offset;\r\npr_debug("found inline addr: 0x%jx\n",\r\n(uintmax_t)pf->addr);\r\nret = call_probe_finder(in_die, pf);\r\n}\r\nreturn ret;\r\n}\r\nstatic int probe_point_search_cb(Dwarf_Die *sp_die, void *data)\r\n{\r\nstruct dwarf_callback_param *param = data;\r\nstruct probe_finder *pf = param->data;\r\nstruct perf_probe_point *pp = &pf->pev->point;\r\nif (!die_is_func_def(sp_die) ||\r\n!die_compare_name(sp_die, pp->function))\r\nreturn DWARF_CB_OK;\r\nif (pp->file && strtailcmp(pp->file, dwarf_decl_file(sp_die)))\r\nreturn DWARF_CB_OK;\r\npf->fname = dwarf_decl_file(sp_die);\r\nif (pp->line) {\r\ndwarf_decl_line(sp_die, &pf->lno);\r\npf->lno += pp->line;\r\nparam->retval = find_probe_point_by_line(pf);\r\n} else if (!dwarf_func_inline(sp_die)) {\r\nif (pp->lazy_line)\r\nparam->retval = find_probe_point_lazy(sp_die, pf);\r\nelse {\r\nif (dwarf_entrypc(sp_die, &pf->addr) != 0) {\r\npr_warning("Failed to get entry address of "\r\n"%s.\n", dwarf_diename(sp_die));\r\nparam->retval = -ENOENT;\r\nreturn DWARF_CB_ABORT;\r\n}\r\npf->addr += pp->offset;\r\nparam->retval = call_probe_finder(sp_die, pf);\r\n}\r\n} else\r\nparam->retval = die_walk_instances(sp_die,\r\nprobe_point_inline_cb, (void *)pf);\r\nreturn DWARF_CB_ABORT;\r\n}\r\nstatic int find_probe_point_by_func(struct probe_finder *pf)\r\n{\r\nstruct dwarf_callback_param _param = {.data = (void *)pf,\r\n.retval = 0};\r\ndwarf_getfuncs(&pf->cu_die, probe_point_search_cb, &_param, 0);\r\nreturn _param.retval;\r\n}\r\nstatic int pubname_search_cb(Dwarf *dbg, Dwarf_Global *gl, void *data)\r\n{\r\nstruct pubname_callback_param *param = data;\r\nif (dwarf_offdie(dbg, gl->die_offset, param->sp_die)) {\r\nif (dwarf_tag(param->sp_die) != DW_TAG_subprogram)\r\nreturn DWARF_CB_OK;\r\nif (die_compare_name(param->sp_die, param->function)) {\r\nif (!dwarf_offdie(dbg, gl->cu_offset, param->cu_die))\r\nreturn DWARF_CB_OK;\r\nif (param->file &&\r\nstrtailcmp(param->file, dwarf_decl_file(param->sp_die)))\r\nreturn DWARF_CB_OK;\r\nparam->found = 1;\r\nreturn DWARF_CB_ABORT;\r\n}\r\n}\r\nreturn DWARF_CB_OK;\r\n}\r\nstatic int debuginfo__find_probes(struct debuginfo *dbg,\r\nstruct probe_finder *pf)\r\n{\r\nstruct perf_probe_point *pp = &pf->pev->point;\r\nDwarf_Off off, noff;\r\nsize_t cuhl;\r\nDwarf_Die *diep;\r\nint ret = 0;\r\n#if _ELFUTILS_PREREQ(0, 142)\r\nElf *elf;\r\nGElf_Ehdr ehdr;\r\nGElf_Shdr shdr;\r\nelf = dwarf_getelf(dbg->dbg);\r\nif (elf == NULL)\r\nreturn -EINVAL;\r\nif (gelf_getehdr(elf, &ehdr) == NULL)\r\nreturn -EINVAL;\r\nif (elf_section_by_name(elf, &ehdr, &shdr, ".eh_frame", NULL) &&\r\nshdr.sh_type == SHT_PROGBITS) {\r\npf->cfi = dwarf_getcfi_elf(elf);\r\n} else {\r\npf->cfi = dwarf_getcfi(dbg->dbg);\r\n}\r\n#endif\r\noff = 0;\r\npf->lcache = intlist__new(NULL);\r\nif (!pf->lcache)\r\nreturn -ENOMEM;\r\nif (pp->function) {\r\nstruct pubname_callback_param pubname_param = {\r\n.function = pp->function,\r\n.file = pp->file,\r\n.cu_die = &pf->cu_die,\r\n.sp_die = &pf->sp_die,\r\n.found = 0,\r\n};\r\nstruct dwarf_callback_param probe_param = {\r\n.data = pf,\r\n};\r\ndwarf_getpubnames(dbg->dbg, pubname_search_cb,\r\n&pubname_param, 0);\r\nif (pubname_param.found) {\r\nret = probe_point_search_cb(&pf->sp_die, &probe_param);\r\nif (ret)\r\ngoto found;\r\n}\r\n}\r\nwhile (!dwarf_nextcu(dbg->dbg, off, &noff, &cuhl, NULL, NULL, NULL)) {\r\ndiep = dwarf_offdie(dbg->dbg, off + cuhl, &pf->cu_die);\r\nif (!diep)\r\ncontinue;\r\nif (pp->file)\r\npf->fname = cu_find_realpath(&pf->cu_die, pp->file);\r\nelse\r\npf->fname = NULL;\r\nif (!pp->file || pf->fname) {\r\nif (pp->function)\r\nret = find_probe_point_by_func(pf);\r\nelse if (pp->lazy_line)\r\nret = find_probe_point_lazy(NULL, pf);\r\nelse {\r\npf->lno = pp->line;\r\nret = find_probe_point_by_line(pf);\r\n}\r\nif (ret < 0)\r\nbreak;\r\n}\r\noff = noff;\r\n}\r\nfound:\r\nintlist__delete(pf->lcache);\r\npf->lcache = NULL;\r\nreturn ret;\r\n}\r\nstatic int copy_variables_cb(Dwarf_Die *die_mem, void *data)\r\n{\r\nstruct local_vars_finder *vf = data;\r\nstruct probe_finder *pf = vf->pf;\r\nint tag;\r\ntag = dwarf_tag(die_mem);\r\nif (tag == DW_TAG_formal_parameter ||\r\ntag == DW_TAG_variable) {\r\nif (convert_variable_location(die_mem, vf->pf->addr,\r\nvf->pf->fb_ops, &pf->sp_die,\r\nNULL) == 0) {\r\nvf->args[vf->nargs].var = (char *)dwarf_diename(die_mem);\r\nif (vf->args[vf->nargs].var == NULL) {\r\nvf->ret = -ENOMEM;\r\nreturn DIE_FIND_CB_END;\r\n}\r\npr_debug(" %s", vf->args[vf->nargs].var);\r\nvf->nargs++;\r\n}\r\n}\r\nif (dwarf_haspc(die_mem, vf->pf->addr))\r\nreturn DIE_FIND_CB_CONTINUE;\r\nelse\r\nreturn DIE_FIND_CB_SIBLING;\r\n}\r\nstatic int expand_probe_args(Dwarf_Die *sc_die, struct probe_finder *pf,\r\nstruct perf_probe_arg *args)\r\n{\r\nDwarf_Die die_mem;\r\nint i;\r\nint n = 0;\r\nstruct local_vars_finder vf = {.pf = pf, .args = args,\r\n.max_args = MAX_PROBE_ARGS, .ret = 0};\r\nfor (i = 0; i < pf->pev->nargs; i++) {\r\nif (strcmp(pf->pev->args[i].var, "$vars") == 0) {\r\npr_debug("Expanding $vars into:");\r\nvf.nargs = n;\r\ndie_find_child(sc_die, copy_variables_cb, (void *)&vf,\r\n&die_mem);\r\npr_debug(" (%d)\n", vf.nargs - n);\r\nif (vf.ret < 0)\r\nreturn vf.ret;\r\nn = vf.nargs;\r\n} else {\r\nargs[n] = pf->pev->args[i];\r\nn++;\r\n}\r\n}\r\nreturn n;\r\n}\r\nstatic int add_probe_trace_event(Dwarf_Die *sc_die, struct probe_finder *pf)\r\n{\r\nstruct trace_event_finder *tf =\r\ncontainer_of(pf, struct trace_event_finder, pf);\r\nstruct probe_trace_event *tev;\r\nstruct perf_probe_arg *args;\r\nint ret, i;\r\nif (tf->ntevs == tf->max_tevs) {\r\npr_warning("Too many( > %d) probe point found.\n",\r\ntf->max_tevs);\r\nreturn -ERANGE;\r\n}\r\ntev = &tf->tevs[tf->ntevs++];\r\nret = convert_to_trace_point(&pf->sp_die, tf->mod, pf->addr,\r\npf->pev->point.retprobe, &tev->point);\r\nif (ret < 0)\r\nreturn ret;\r\npr_debug("Probe point found: %s+%lu\n", tev->point.symbol,\r\ntev->point.offset);\r\nargs = zalloc(sizeof(struct perf_probe_arg) * MAX_PROBE_ARGS);\r\nif (args == NULL)\r\nreturn -ENOMEM;\r\nret = expand_probe_args(sc_die, pf, args);\r\nif (ret < 0)\r\ngoto end;\r\ntev->nargs = ret;\r\ntev->args = zalloc(sizeof(struct probe_trace_arg) * tev->nargs);\r\nif (tev->args == NULL) {\r\nret = -ENOMEM;\r\ngoto end;\r\n}\r\nfor (i = 0; i < tev->nargs; i++) {\r\npf->pvar = &args[i];\r\npf->tvar = &tev->args[i];\r\nret = find_variable(sc_die, pf);\r\nif (ret != 0)\r\nbreak;\r\n}\r\nend:\r\nfree(args);\r\nreturn ret;\r\n}\r\nint debuginfo__find_trace_events(struct debuginfo *dbg,\r\nstruct perf_probe_event *pev,\r\nstruct probe_trace_event **tevs, int max_tevs)\r\n{\r\nstruct trace_event_finder tf = {\r\n.pf = {.pev = pev, .callback = add_probe_trace_event},\r\n.mod = dbg->mod, .max_tevs = max_tevs};\r\nint ret;\r\n*tevs = zalloc(sizeof(struct probe_trace_event) * max_tevs);\r\nif (*tevs == NULL)\r\nreturn -ENOMEM;\r\ntf.tevs = *tevs;\r\ntf.ntevs = 0;\r\nret = debuginfo__find_probes(dbg, &tf.pf);\r\nif (ret < 0) {\r\nzfree(tevs);\r\nreturn ret;\r\n}\r\nreturn (ret < 0) ? ret : tf.ntevs;\r\n}\r\nstatic int collect_variables_cb(Dwarf_Die *die_mem, void *data)\r\n{\r\nstruct available_var_finder *af = data;\r\nstruct variable_list *vl;\r\nchar buf[MAX_VAR_LEN];\r\nint tag, ret;\r\nvl = &af->vls[af->nvls - 1];\r\ntag = dwarf_tag(die_mem);\r\nif (tag == DW_TAG_formal_parameter ||\r\ntag == DW_TAG_variable) {\r\nret = convert_variable_location(die_mem, af->pf.addr,\r\naf->pf.fb_ops, &af->pf.sp_die,\r\nNULL);\r\nif (ret == 0) {\r\nret = die_get_varname(die_mem, buf, MAX_VAR_LEN);\r\npr_debug2("Add new var: %s\n", buf);\r\nif (ret > 0)\r\nstrlist__add(vl->vars, buf);\r\n}\r\n}\r\nif (af->child && dwarf_haspc(die_mem, af->pf.addr))\r\nreturn DIE_FIND_CB_CONTINUE;\r\nelse\r\nreturn DIE_FIND_CB_SIBLING;\r\n}\r\nstatic int add_available_vars(Dwarf_Die *sc_die, struct probe_finder *pf)\r\n{\r\nstruct available_var_finder *af =\r\ncontainer_of(pf, struct available_var_finder, pf);\r\nstruct variable_list *vl;\r\nDwarf_Die die_mem;\r\nint ret;\r\nif (af->nvls == af->max_vls) {\r\npr_warning("Too many( > %d) probe point found.\n", af->max_vls);\r\nreturn -ERANGE;\r\n}\r\nvl = &af->vls[af->nvls++];\r\nret = convert_to_trace_point(&pf->sp_die, af->mod, pf->addr,\r\npf->pev->point.retprobe, &vl->point);\r\nif (ret < 0)\r\nreturn ret;\r\npr_debug("Probe point found: %s+%lu\n", vl->point.symbol,\r\nvl->point.offset);\r\nvl->vars = strlist__new(true, NULL);\r\nif (vl->vars == NULL)\r\nreturn -ENOMEM;\r\naf->child = true;\r\ndie_find_child(sc_die, collect_variables_cb, (void *)af, &die_mem);\r\nif (!af->externs)\r\ngoto out;\r\naf->child = false;\r\ndie_find_child(&pf->cu_die, collect_variables_cb, (void *)af, &die_mem);\r\nout:\r\nif (strlist__empty(vl->vars)) {\r\nstrlist__delete(vl->vars);\r\nvl->vars = NULL;\r\n}\r\nreturn ret;\r\n}\r\nint debuginfo__find_available_vars_at(struct debuginfo *dbg,\r\nstruct perf_probe_event *pev,\r\nstruct variable_list **vls,\r\nint max_vls, bool externs)\r\n{\r\nstruct available_var_finder af = {\r\n.pf = {.pev = pev, .callback = add_available_vars},\r\n.mod = dbg->mod,\r\n.max_vls = max_vls, .externs = externs};\r\nint ret;\r\n*vls = zalloc(sizeof(struct variable_list) * max_vls);\r\nif (*vls == NULL)\r\nreturn -ENOMEM;\r\naf.vls = *vls;\r\naf.nvls = 0;\r\nret = debuginfo__find_probes(dbg, &af.pf);\r\nif (ret < 0) {\r\nwhile (af.nvls--) {\r\nzfree(&af.vls[af.nvls].point.symbol);\r\nstrlist__delete(af.vls[af.nvls].vars);\r\n}\r\nzfree(vls);\r\nreturn ret;\r\n}\r\nreturn (ret < 0) ? ret : af.nvls;\r\n}\r\nint debuginfo__find_probe_point(struct debuginfo *dbg, unsigned long addr,\r\nstruct perf_probe_point *ppt)\r\n{\r\nDwarf_Die cudie, spdie, indie;\r\nDwarf_Addr _addr = 0, baseaddr = 0;\r\nconst char *fname = NULL, *func = NULL, *basefunc = NULL, *tmp;\r\nint baseline = 0, lineno = 0, ret = 0;\r\naddr += dbg->bias;\r\nif (!dwarf_addrdie(dbg->dbg, (Dwarf_Addr)addr - dbg->bias, &cudie)) {\r\npr_warning("Failed to find debug information for address %lx\n",\r\naddr);\r\nret = -EINVAL;\r\ngoto end;\r\n}\r\ncu_find_lineinfo(&cudie, addr, &fname, &lineno);\r\nif (die_find_realfunc(&cudie, (Dwarf_Addr)addr, &spdie)) {\r\nfunc = basefunc = dwarf_diename(&spdie);\r\nif (!func ||\r\ndwarf_entrypc(&spdie, &baseaddr) != 0 ||\r\ndwarf_decl_line(&spdie, &baseline) != 0) {\r\nlineno = 0;\r\ngoto post;\r\n}\r\nfname = dwarf_decl_file(&spdie);\r\nif (addr == (unsigned long)baseaddr) {\r\nlineno = baseline;\r\ngoto post;\r\n}\r\nwhile (die_find_top_inlinefunc(&spdie, (Dwarf_Addr)addr,\r\n&indie)) {\r\nif (dwarf_entrypc(&indie, &_addr) == 0 &&\r\n_addr == addr) {\r\nlineno = die_get_call_lineno(&indie);\r\nfname = die_get_call_file(&indie);\r\nbreak;\r\n} else {\r\ntmp = dwarf_diename(&indie);\r\nif (!tmp ||\r\ndwarf_decl_line(&indie, &baseline) != 0)\r\nbreak;\r\nfunc = tmp;\r\nspdie = indie;\r\n}\r\n}\r\ntmp = dwarf_decl_file(&spdie);\r\nif (!tmp || strcmp(tmp, fname) != 0)\r\nlineno = 0;\r\n}\r\npost:\r\nif (lineno)\r\nppt->line = lineno - baseline;\r\nelse if (basefunc) {\r\nppt->offset = addr - (unsigned long)baseaddr;\r\nfunc = basefunc;\r\n}\r\nif (func) {\r\nppt->function = strdup(func);\r\nif (ppt->function == NULL) {\r\nret = -ENOMEM;\r\ngoto end;\r\n}\r\n}\r\nif (fname) {\r\nppt->file = strdup(fname);\r\nif (ppt->file == NULL) {\r\nzfree(&ppt->function);\r\nret = -ENOMEM;\r\ngoto end;\r\n}\r\n}\r\nend:\r\nif (ret == 0 && (fname || func))\r\nret = 1;\r\nreturn ret;\r\n}\r\nstatic int line_range_add_line(const char *src, unsigned int lineno,\r\nstruct line_range *lr)\r\n{\r\nif (!lr->path) {\r\nlr->path = strdup(src);\r\nif (lr->path == NULL)\r\nreturn -ENOMEM;\r\n}\r\nreturn intlist__add(lr->line_list, lineno);\r\n}\r\nstatic int line_range_walk_cb(const char *fname, int lineno,\r\nDwarf_Addr addr __maybe_unused,\r\nvoid *data)\r\n{\r\nstruct line_finder *lf = data;\r\nint err;\r\nif ((strtailcmp(fname, lf->fname) != 0) ||\r\n(lf->lno_s > lineno || lf->lno_e < lineno))\r\nreturn 0;\r\nerr = line_range_add_line(fname, lineno, lf->lr);\r\nif (err < 0 && err != -EEXIST)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int find_line_range_by_line(Dwarf_Die *sp_die, struct line_finder *lf)\r\n{\r\nint ret;\r\nret = die_walk_lines(sp_die ?: &lf->cu_die, line_range_walk_cb, lf);\r\nif (ret >= 0)\r\nif (!intlist__empty(lf->lr->line_list))\r\nret = lf->found = 1;\r\nelse\r\nret = 0;\r\nelse {\r\nzfree(&lf->lr->path);\r\n}\r\nreturn ret;\r\n}\r\nstatic int line_range_inline_cb(Dwarf_Die *in_die, void *data)\r\n{\r\nint ret = find_line_range_by_line(in_die, data);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic int line_range_search_cb(Dwarf_Die *sp_die, void *data)\r\n{\r\nstruct dwarf_callback_param *param = data;\r\nstruct line_finder *lf = param->data;\r\nstruct line_range *lr = lf->lr;\r\nif (lr->file && strtailcmp(lr->file, dwarf_decl_file(sp_die)))\r\nreturn DWARF_CB_OK;\r\nif (die_is_func_def(sp_die) &&\r\ndie_compare_name(sp_die, lr->function)) {\r\nlf->fname = dwarf_decl_file(sp_die);\r\ndwarf_decl_line(sp_die, &lr->offset);\r\npr_debug("fname: %s, lineno:%d\n", lf->fname, lr->offset);\r\nlf->lno_s = lr->offset + lr->start;\r\nif (lf->lno_s < 0)\r\nlf->lno_s = INT_MAX;\r\nlf->lno_e = lr->offset + lr->end;\r\nif (lf->lno_e < 0)\r\nlf->lno_e = INT_MAX;\r\npr_debug("New line range: %d to %d\n", lf->lno_s, lf->lno_e);\r\nlr->start = lf->lno_s;\r\nlr->end = lf->lno_e;\r\nif (dwarf_func_inline(sp_die))\r\nparam->retval = die_walk_instances(sp_die,\r\nline_range_inline_cb, lf);\r\nelse\r\nparam->retval = find_line_range_by_line(sp_die, lf);\r\nreturn DWARF_CB_ABORT;\r\n}\r\nreturn DWARF_CB_OK;\r\n}\r\nstatic int find_line_range_by_func(struct line_finder *lf)\r\n{\r\nstruct dwarf_callback_param param = {.data = (void *)lf, .retval = 0};\r\ndwarf_getfuncs(&lf->cu_die, line_range_search_cb, &param, 0);\r\nreturn param.retval;\r\n}\r\nint debuginfo__find_line_range(struct debuginfo *dbg, struct line_range *lr)\r\n{\r\nstruct line_finder lf = {.lr = lr, .found = 0};\r\nint ret = 0;\r\nDwarf_Off off = 0, noff;\r\nsize_t cuhl;\r\nDwarf_Die *diep;\r\nconst char *comp_dir;\r\nif (lr->function) {\r\nstruct pubname_callback_param pubname_param = {\r\n.function = lr->function, .file = lr->file,\r\n.cu_die = &lf.cu_die, .sp_die = &lf.sp_die, .found = 0};\r\nstruct dwarf_callback_param line_range_param = {\r\n.data = (void *)&lf, .retval = 0};\r\ndwarf_getpubnames(dbg->dbg, pubname_search_cb,\r\n&pubname_param, 0);\r\nif (pubname_param.found) {\r\nline_range_search_cb(&lf.sp_die, &line_range_param);\r\nif (lf.found)\r\ngoto found;\r\n}\r\n}\r\nwhile (!lf.found && ret >= 0) {\r\nif (dwarf_nextcu(dbg->dbg, off, &noff, &cuhl,\r\nNULL, NULL, NULL) != 0)\r\nbreak;\r\ndiep = dwarf_offdie(dbg->dbg, off + cuhl, &lf.cu_die);\r\nif (!diep)\r\ncontinue;\r\nif (lr->file)\r\nlf.fname = cu_find_realpath(&lf.cu_die, lr->file);\r\nelse\r\nlf.fname = 0;\r\nif (!lr->file || lf.fname) {\r\nif (lr->function)\r\nret = find_line_range_by_func(&lf);\r\nelse {\r\nlf.lno_s = lr->start;\r\nlf.lno_e = lr->end;\r\nret = find_line_range_by_line(NULL, &lf);\r\n}\r\n}\r\noff = noff;\r\n}\r\nfound:\r\nif (lf.found) {\r\ncomp_dir = cu_get_comp_dir(&lf.cu_die);\r\nif (comp_dir) {\r\nlr->comp_dir = strdup(comp_dir);\r\nif (!lr->comp_dir)\r\nret = -ENOMEM;\r\n}\r\n}\r\npr_debug("path: %s\n", lr->path);\r\nreturn (ret < 0) ? ret : lf.found;\r\n}
