bool vmw_fifo_have_3d(struct vmw_private *dev_priv)\r\n{\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nuint32_t fifo_min, hwversion;\r\nconst struct vmw_fifo_state *fifo = &dev_priv->fifo;\r\nif (!(dev_priv->capabilities & SVGA_CAP_3D))\r\nreturn false;\r\nif (dev_priv->capabilities & SVGA_CAP_GBOBJECTS) {\r\nuint32_t result;\r\nif (!dev_priv->has_mob)\r\nreturn false;\r\nspin_lock(&dev_priv->cap_lock);\r\nvmw_write(dev_priv, SVGA_REG_DEV_CAP, SVGA3D_DEVCAP_3D);\r\nresult = vmw_read(dev_priv, SVGA_REG_DEV_CAP);\r\nspin_unlock(&dev_priv->cap_lock);\r\nreturn (result != 0);\r\n}\r\nif (!(dev_priv->capabilities & SVGA_CAP_EXTENDED_FIFO))\r\nreturn false;\r\nfifo_min = ioread32(fifo_mem + SVGA_FIFO_MIN);\r\nif (fifo_min <= SVGA_FIFO_3D_HWVERSION * sizeof(unsigned int))\r\nreturn false;\r\nhwversion = ioread32(fifo_mem +\r\n((fifo->capabilities &\r\nSVGA_FIFO_CAP_3D_HWVERSION_REVISED) ?\r\nSVGA_FIFO_3D_HWVERSION_REVISED :\r\nSVGA_FIFO_3D_HWVERSION));\r\nif (hwversion == 0)\r\nreturn false;\r\nif (hwversion < SVGA3D_HWVERSION_WS8_B1)\r\nreturn false;\r\nif (!dev_priv->sou_priv)\r\nreturn false;\r\nreturn true;\r\n}\r\nbool vmw_fifo_have_pitchlock(struct vmw_private *dev_priv)\r\n{\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nuint32_t caps;\r\nif (!(dev_priv->capabilities & SVGA_CAP_EXTENDED_FIFO))\r\nreturn false;\r\ncaps = ioread32(fifo_mem + SVGA_FIFO_CAPABILITIES);\r\nif (caps & SVGA_FIFO_CAP_PITCHLOCK)\r\nreturn true;\r\nreturn false;\r\n}\r\nint vmw_fifo_init(struct vmw_private *dev_priv, struct vmw_fifo_state *fifo)\r\n{\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nuint32_t max;\r\nuint32_t min;\r\nuint32_t dummy;\r\nfifo->static_buffer_size = VMWGFX_FIFO_STATIC_SIZE;\r\nfifo->static_buffer = vmalloc(fifo->static_buffer_size);\r\nif (unlikely(fifo->static_buffer == NULL))\r\nreturn -ENOMEM;\r\nfifo->dynamic_buffer = NULL;\r\nfifo->reserved_size = 0;\r\nfifo->using_bounce_buffer = false;\r\nmutex_init(&fifo->fifo_mutex);\r\ninit_rwsem(&fifo->rwsem);\r\nDRM_INFO("width %d\n", vmw_read(dev_priv, SVGA_REG_WIDTH));\r\nDRM_INFO("height %d\n", vmw_read(dev_priv, SVGA_REG_HEIGHT));\r\nDRM_INFO("bpp %d\n", vmw_read(dev_priv, SVGA_REG_BITS_PER_PIXEL));\r\ndev_priv->enable_state = vmw_read(dev_priv, SVGA_REG_ENABLE);\r\ndev_priv->config_done_state = vmw_read(dev_priv, SVGA_REG_CONFIG_DONE);\r\ndev_priv->traces_state = vmw_read(dev_priv, SVGA_REG_TRACES);\r\nvmw_write(dev_priv, SVGA_REG_ENABLE, 1);\r\nmin = 4;\r\nif (dev_priv->capabilities & SVGA_CAP_EXTENDED_FIFO)\r\nmin = vmw_read(dev_priv, SVGA_REG_MEM_REGS);\r\nmin <<= 2;\r\nif (min < PAGE_SIZE)\r\nmin = PAGE_SIZE;\r\niowrite32(min, fifo_mem + SVGA_FIFO_MIN);\r\niowrite32(dev_priv->mmio_size, fifo_mem + SVGA_FIFO_MAX);\r\nwmb();\r\niowrite32(min, fifo_mem + SVGA_FIFO_NEXT_CMD);\r\niowrite32(min, fifo_mem + SVGA_FIFO_STOP);\r\niowrite32(0, fifo_mem + SVGA_FIFO_BUSY);\r\nmb();\r\nvmw_write(dev_priv, SVGA_REG_CONFIG_DONE, 1);\r\nmax = ioread32(fifo_mem + SVGA_FIFO_MAX);\r\nmin = ioread32(fifo_mem + SVGA_FIFO_MIN);\r\nfifo->capabilities = ioread32(fifo_mem + SVGA_FIFO_CAPABILITIES);\r\nDRM_INFO("Fifo max 0x%08x min 0x%08x cap 0x%08x\n",\r\n(unsigned int) max,\r\n(unsigned int) min,\r\n(unsigned int) fifo->capabilities);\r\natomic_set(&dev_priv->marker_seq, dev_priv->last_read_seqno);\r\niowrite32(dev_priv->last_read_seqno, fifo_mem + SVGA_FIFO_FENCE);\r\nvmw_marker_queue_init(&fifo->marker_queue);\r\nreturn vmw_fifo_send_fence(dev_priv, &dummy);\r\n}\r\nvoid vmw_fifo_ping_host(struct vmw_private *dev_priv, uint32_t reason)\r\n{\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nstatic DEFINE_SPINLOCK(ping_lock);\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&ping_lock, irq_flags);\r\nif (unlikely(ioread32(fifo_mem + SVGA_FIFO_BUSY) == 0)) {\r\niowrite32(1, fifo_mem + SVGA_FIFO_BUSY);\r\nvmw_write(dev_priv, SVGA_REG_SYNC, reason);\r\n}\r\nspin_unlock_irqrestore(&ping_lock, irq_flags);\r\n}\r\nvoid vmw_fifo_release(struct vmw_private *dev_priv, struct vmw_fifo_state *fifo)\r\n{\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nvmw_write(dev_priv, SVGA_REG_SYNC, SVGA_SYNC_GENERIC);\r\nwhile (vmw_read(dev_priv, SVGA_REG_BUSY) != 0)\r\n;\r\ndev_priv->last_read_seqno = ioread32(fifo_mem + SVGA_FIFO_FENCE);\r\nvmw_write(dev_priv, SVGA_REG_CONFIG_DONE,\r\ndev_priv->config_done_state);\r\nvmw_write(dev_priv, SVGA_REG_ENABLE,\r\ndev_priv->enable_state);\r\nvmw_write(dev_priv, SVGA_REG_TRACES,\r\ndev_priv->traces_state);\r\nvmw_marker_queue_takedown(&fifo->marker_queue);\r\nif (likely(fifo->static_buffer != NULL)) {\r\nvfree(fifo->static_buffer);\r\nfifo->static_buffer = NULL;\r\n}\r\nif (likely(fifo->dynamic_buffer != NULL)) {\r\nvfree(fifo->dynamic_buffer);\r\nfifo->dynamic_buffer = NULL;\r\n}\r\n}\r\nstatic bool vmw_fifo_is_full(struct vmw_private *dev_priv, uint32_t bytes)\r\n{\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nuint32_t max = ioread32(fifo_mem + SVGA_FIFO_MAX);\r\nuint32_t next_cmd = ioread32(fifo_mem + SVGA_FIFO_NEXT_CMD);\r\nuint32_t min = ioread32(fifo_mem + SVGA_FIFO_MIN);\r\nuint32_t stop = ioread32(fifo_mem + SVGA_FIFO_STOP);\r\nreturn ((max - next_cmd) + (stop - min) <= bytes);\r\n}\r\nstatic int vmw_fifo_wait_noirq(struct vmw_private *dev_priv,\r\nuint32_t bytes, bool interruptible,\r\nunsigned long timeout)\r\n{\r\nint ret = 0;\r\nunsigned long end_jiffies = jiffies + timeout;\r\nDEFINE_WAIT(__wait);\r\nDRM_INFO("Fifo wait noirq.\n");\r\nfor (;;) {\r\nprepare_to_wait(&dev_priv->fifo_queue, &__wait,\r\n(interruptible) ?\r\nTASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\r\nif (!vmw_fifo_is_full(dev_priv, bytes))\r\nbreak;\r\nif (time_after_eq(jiffies, end_jiffies)) {\r\nret = -EBUSY;\r\nDRM_ERROR("SVGA device lockup.\n");\r\nbreak;\r\n}\r\nschedule_timeout(1);\r\nif (interruptible && signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\n}\r\nfinish_wait(&dev_priv->fifo_queue, &__wait);\r\nwake_up_all(&dev_priv->fifo_queue);\r\nDRM_INFO("Fifo noirq exit.\n");\r\nreturn ret;\r\n}\r\nstatic int vmw_fifo_wait(struct vmw_private *dev_priv,\r\nuint32_t bytes, bool interruptible,\r\nunsigned long timeout)\r\n{\r\nlong ret = 1L;\r\nunsigned long irq_flags;\r\nif (likely(!vmw_fifo_is_full(dev_priv, bytes)))\r\nreturn 0;\r\nvmw_fifo_ping_host(dev_priv, SVGA_SYNC_FIFOFULL);\r\nif (!(dev_priv->capabilities & SVGA_CAP_IRQMASK))\r\nreturn vmw_fifo_wait_noirq(dev_priv, bytes,\r\ninterruptible, timeout);\r\nspin_lock(&dev_priv->waiter_lock);\r\nif (atomic_add_return(1, &dev_priv->fifo_queue_waiters) > 0) {\r\nspin_lock_irqsave(&dev_priv->irq_lock, irq_flags);\r\noutl(SVGA_IRQFLAG_FIFO_PROGRESS,\r\ndev_priv->io_start + VMWGFX_IRQSTATUS_PORT);\r\ndev_priv->irq_mask |= SVGA_IRQFLAG_FIFO_PROGRESS;\r\nvmw_write(dev_priv, SVGA_REG_IRQMASK, dev_priv->irq_mask);\r\nspin_unlock_irqrestore(&dev_priv->irq_lock, irq_flags);\r\n}\r\nspin_unlock(&dev_priv->waiter_lock);\r\nif (interruptible)\r\nret = wait_event_interruptible_timeout\r\n(dev_priv->fifo_queue,\r\n!vmw_fifo_is_full(dev_priv, bytes), timeout);\r\nelse\r\nret = wait_event_timeout\r\n(dev_priv->fifo_queue,\r\n!vmw_fifo_is_full(dev_priv, bytes), timeout);\r\nif (unlikely(ret == 0))\r\nret = -EBUSY;\r\nelse if (likely(ret > 0))\r\nret = 0;\r\nspin_lock(&dev_priv->waiter_lock);\r\nif (atomic_dec_and_test(&dev_priv->fifo_queue_waiters)) {\r\nspin_lock_irqsave(&dev_priv->irq_lock, irq_flags);\r\ndev_priv->irq_mask &= ~SVGA_IRQFLAG_FIFO_PROGRESS;\r\nvmw_write(dev_priv, SVGA_REG_IRQMASK, dev_priv->irq_mask);\r\nspin_unlock_irqrestore(&dev_priv->irq_lock, irq_flags);\r\n}\r\nspin_unlock(&dev_priv->waiter_lock);\r\nreturn ret;\r\n}\r\nvoid *vmw_fifo_reserve(struct vmw_private *dev_priv, uint32_t bytes)\r\n{\r\nstruct vmw_fifo_state *fifo_state = &dev_priv->fifo;\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nuint32_t max;\r\nuint32_t min;\r\nuint32_t next_cmd;\r\nuint32_t reserveable = fifo_state->capabilities & SVGA_FIFO_CAP_RESERVE;\r\nint ret;\r\nmutex_lock(&fifo_state->fifo_mutex);\r\nmax = ioread32(fifo_mem + SVGA_FIFO_MAX);\r\nmin = ioread32(fifo_mem + SVGA_FIFO_MIN);\r\nnext_cmd = ioread32(fifo_mem + SVGA_FIFO_NEXT_CMD);\r\nif (unlikely(bytes >= (max - min)))\r\ngoto out_err;\r\nBUG_ON(fifo_state->reserved_size != 0);\r\nBUG_ON(fifo_state->dynamic_buffer != NULL);\r\nfifo_state->reserved_size = bytes;\r\nwhile (1) {\r\nuint32_t stop = ioread32(fifo_mem + SVGA_FIFO_STOP);\r\nbool need_bounce = false;\r\nbool reserve_in_place = false;\r\nif (next_cmd >= stop) {\r\nif (likely((next_cmd + bytes < max ||\r\n(next_cmd + bytes == max && stop > min))))\r\nreserve_in_place = true;\r\nelse if (vmw_fifo_is_full(dev_priv, bytes)) {\r\nret = vmw_fifo_wait(dev_priv, bytes,\r\nfalse, 3 * HZ);\r\nif (unlikely(ret != 0))\r\ngoto out_err;\r\n} else\r\nneed_bounce = true;\r\n} else {\r\nif (likely((next_cmd + bytes < stop)))\r\nreserve_in_place = true;\r\nelse {\r\nret = vmw_fifo_wait(dev_priv, bytes,\r\nfalse, 3 * HZ);\r\nif (unlikely(ret != 0))\r\ngoto out_err;\r\n}\r\n}\r\nif (reserve_in_place) {\r\nif (reserveable || bytes <= sizeof(uint32_t)) {\r\nfifo_state->using_bounce_buffer = false;\r\nif (reserveable)\r\niowrite32(bytes, fifo_mem +\r\nSVGA_FIFO_RESERVED);\r\nreturn fifo_mem + (next_cmd >> 2);\r\n} else {\r\nneed_bounce = true;\r\n}\r\n}\r\nif (need_bounce) {\r\nfifo_state->using_bounce_buffer = true;\r\nif (bytes < fifo_state->static_buffer_size)\r\nreturn fifo_state->static_buffer;\r\nelse {\r\nfifo_state->dynamic_buffer = vmalloc(bytes);\r\nreturn fifo_state->dynamic_buffer;\r\n}\r\n}\r\n}\r\nout_err:\r\nfifo_state->reserved_size = 0;\r\nmutex_unlock(&fifo_state->fifo_mutex);\r\nreturn NULL;\r\n}\r\nstatic void vmw_fifo_res_copy(struct vmw_fifo_state *fifo_state,\r\n__le32 __iomem *fifo_mem,\r\nuint32_t next_cmd,\r\nuint32_t max, uint32_t min, uint32_t bytes)\r\n{\r\nuint32_t chunk_size = max - next_cmd;\r\nuint32_t rest;\r\nuint32_t *buffer = (fifo_state->dynamic_buffer != NULL) ?\r\nfifo_state->dynamic_buffer : fifo_state->static_buffer;\r\nif (bytes < chunk_size)\r\nchunk_size = bytes;\r\niowrite32(bytes, fifo_mem + SVGA_FIFO_RESERVED);\r\nmb();\r\nmemcpy_toio(fifo_mem + (next_cmd >> 2), buffer, chunk_size);\r\nrest = bytes - chunk_size;\r\nif (rest)\r\nmemcpy_toio(fifo_mem + (min >> 2), buffer + (chunk_size >> 2),\r\nrest);\r\n}\r\nstatic void vmw_fifo_slow_copy(struct vmw_fifo_state *fifo_state,\r\n__le32 __iomem *fifo_mem,\r\nuint32_t next_cmd,\r\nuint32_t max, uint32_t min, uint32_t bytes)\r\n{\r\nuint32_t *buffer = (fifo_state->dynamic_buffer != NULL) ?\r\nfifo_state->dynamic_buffer : fifo_state->static_buffer;\r\nwhile (bytes > 0) {\r\niowrite32(*buffer++, fifo_mem + (next_cmd >> 2));\r\nnext_cmd += sizeof(uint32_t);\r\nif (unlikely(next_cmd == max))\r\nnext_cmd = min;\r\nmb();\r\niowrite32(next_cmd, fifo_mem + SVGA_FIFO_NEXT_CMD);\r\nmb();\r\nbytes -= sizeof(uint32_t);\r\n}\r\n}\r\nvoid vmw_fifo_commit(struct vmw_private *dev_priv, uint32_t bytes)\r\n{\r\nstruct vmw_fifo_state *fifo_state = &dev_priv->fifo;\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nuint32_t next_cmd = ioread32(fifo_mem + SVGA_FIFO_NEXT_CMD);\r\nuint32_t max = ioread32(fifo_mem + SVGA_FIFO_MAX);\r\nuint32_t min = ioread32(fifo_mem + SVGA_FIFO_MIN);\r\nbool reserveable = fifo_state->capabilities & SVGA_FIFO_CAP_RESERVE;\r\nBUG_ON((bytes & 3) != 0);\r\nBUG_ON(bytes > fifo_state->reserved_size);\r\nfifo_state->reserved_size = 0;\r\nif (fifo_state->using_bounce_buffer) {\r\nif (reserveable)\r\nvmw_fifo_res_copy(fifo_state, fifo_mem,\r\nnext_cmd, max, min, bytes);\r\nelse\r\nvmw_fifo_slow_copy(fifo_state, fifo_mem,\r\nnext_cmd, max, min, bytes);\r\nif (fifo_state->dynamic_buffer) {\r\nvfree(fifo_state->dynamic_buffer);\r\nfifo_state->dynamic_buffer = NULL;\r\n}\r\n}\r\ndown_write(&fifo_state->rwsem);\r\nif (fifo_state->using_bounce_buffer || reserveable) {\r\nnext_cmd += bytes;\r\nif (next_cmd >= max)\r\nnext_cmd -= max - min;\r\nmb();\r\niowrite32(next_cmd, fifo_mem + SVGA_FIFO_NEXT_CMD);\r\n}\r\nif (reserveable)\r\niowrite32(0, fifo_mem + SVGA_FIFO_RESERVED);\r\nmb();\r\nup_write(&fifo_state->rwsem);\r\nvmw_fifo_ping_host(dev_priv, SVGA_SYNC_GENERIC);\r\nmutex_unlock(&fifo_state->fifo_mutex);\r\n}\r\nint vmw_fifo_send_fence(struct vmw_private *dev_priv, uint32_t *seqno)\r\n{\r\nstruct vmw_fifo_state *fifo_state = &dev_priv->fifo;\r\nstruct svga_fifo_cmd_fence *cmd_fence;\r\nvoid *fm;\r\nint ret = 0;\r\nuint32_t bytes = sizeof(__le32) + sizeof(*cmd_fence);\r\nfm = vmw_fifo_reserve(dev_priv, bytes);\r\nif (unlikely(fm == NULL)) {\r\n*seqno = atomic_read(&dev_priv->marker_seq);\r\nret = -ENOMEM;\r\n(void)vmw_fallback_wait(dev_priv, false, true, *seqno,\r\nfalse, 3*HZ);\r\ngoto out_err;\r\n}\r\ndo {\r\n*seqno = atomic_add_return(1, &dev_priv->marker_seq);\r\n} while (*seqno == 0);\r\nif (!(fifo_state->capabilities & SVGA_FIFO_CAP_FENCE)) {\r\nvmw_fifo_commit(dev_priv, 0);\r\nreturn 0;\r\n}\r\n*(__le32 *) fm = cpu_to_le32(SVGA_CMD_FENCE);\r\ncmd_fence = (struct svga_fifo_cmd_fence *)\r\n((unsigned long)fm + sizeof(__le32));\r\niowrite32(*seqno, &cmd_fence->fence);\r\nvmw_fifo_commit(dev_priv, bytes);\r\n(void) vmw_marker_push(&fifo_state->marker_queue, *seqno);\r\nvmw_update_seqno(dev_priv, fifo_state);\r\nout_err:\r\nreturn ret;\r\n}\r\nstatic int vmw_fifo_emit_dummy_legacy_query(struct vmw_private *dev_priv,\r\nuint32_t cid)\r\n{\r\nstruct ttm_buffer_object *bo = dev_priv->dummy_query_bo;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdWaitForQuery body;\r\n} *cmd;\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Out of fifo space for dummy query.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_WAIT_FOR_QUERY;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = cid;\r\ncmd->body.type = SVGA3D_QUERYTYPE_OCCLUSION;\r\nif (bo->mem.mem_type == TTM_PL_VRAM) {\r\ncmd->body.guestResult.gmrId = SVGA_GMR_FRAMEBUFFER;\r\ncmd->body.guestResult.offset = bo->offset;\r\n} else {\r\ncmd->body.guestResult.gmrId = bo->mem.start;\r\ncmd->body.guestResult.offset = 0;\r\n}\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nstatic int vmw_fifo_emit_dummy_gb_query(struct vmw_private *dev_priv,\r\nuint32_t cid)\r\n{\r\nstruct ttm_buffer_object *bo = dev_priv->dummy_query_bo;\r\nstruct {\r\nSVGA3dCmdHeader header;\r\nSVGA3dCmdWaitForGBQuery body;\r\n} *cmd;\r\ncmd = vmw_fifo_reserve(dev_priv, sizeof(*cmd));\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Out of fifo space for dummy query.\n");\r\nreturn -ENOMEM;\r\n}\r\ncmd->header.id = SVGA_3D_CMD_WAIT_FOR_GB_QUERY;\r\ncmd->header.size = sizeof(cmd->body);\r\ncmd->body.cid = cid;\r\ncmd->body.type = SVGA3D_QUERYTYPE_OCCLUSION;\r\nBUG_ON(bo->mem.mem_type != VMW_PL_MOB);\r\ncmd->body.mobid = bo->mem.start;\r\ncmd->body.offset = 0;\r\nvmw_fifo_commit(dev_priv, sizeof(*cmd));\r\nreturn 0;\r\n}\r\nint vmw_fifo_emit_dummy_query(struct vmw_private *dev_priv,\r\nuint32_t cid)\r\n{\r\nif (dev_priv->has_mob)\r\nreturn vmw_fifo_emit_dummy_gb_query(dev_priv, cid);\r\nreturn vmw_fifo_emit_dummy_legacy_query(dev_priv, cid);\r\n}
