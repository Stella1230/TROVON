static inline u8 virtfn_bus(struct pci_dev *dev, int id)\r\n{\r\nreturn dev->bus->number + ((dev->devfn + dev->sriov->offset +\r\ndev->sriov->stride * id) >> 8);\r\n}\r\nstatic inline u8 virtfn_devfn(struct pci_dev *dev, int id)\r\n{\r\nreturn (dev->devfn + dev->sriov->offset +\r\ndev->sriov->stride * id) & 0xff;\r\n}\r\nstatic struct pci_bus *virtfn_add_bus(struct pci_bus *bus, int busnr)\r\n{\r\nstruct pci_bus *child;\r\nif (bus->number == busnr)\r\nreturn bus;\r\nchild = pci_find_bus(pci_domain_nr(bus), busnr);\r\nif (child)\r\nreturn child;\r\nchild = pci_add_new_bus(bus, NULL, busnr);\r\nif (!child)\r\nreturn NULL;\r\npci_bus_insert_busn_res(child, busnr, busnr);\r\nreturn child;\r\n}\r\nstatic void virtfn_remove_bus(struct pci_bus *physbus, struct pci_bus *virtbus)\r\n{\r\nif (physbus != virtbus && list_empty(&virtbus->devices))\r\npci_remove_bus(virtbus);\r\n}\r\nstatic int virtfn_add(struct pci_dev *dev, int id, int reset)\r\n{\r\nint i;\r\nint rc = -ENOMEM;\r\nu64 size;\r\nchar buf[VIRTFN_ID_LEN];\r\nstruct pci_dev *virtfn;\r\nstruct resource *res;\r\nstruct pci_sriov *iov = dev->sriov;\r\nstruct pci_bus *bus;\r\nmutex_lock(&iov->dev->sriov->lock);\r\nbus = virtfn_add_bus(dev->bus, virtfn_bus(dev, id));\r\nif (!bus)\r\ngoto failed;\r\nvirtfn = pci_alloc_dev(bus);\r\nif (!virtfn)\r\ngoto failed0;\r\nvirtfn->devfn = virtfn_devfn(dev, id);\r\nvirtfn->vendor = dev->vendor;\r\npci_read_config_word(dev, iov->pos + PCI_SRIOV_VF_DID, &virtfn->device);\r\npci_setup_device(virtfn);\r\nvirtfn->dev.parent = dev->dev.parent;\r\nvirtfn->physfn = pci_dev_get(dev);\r\nvirtfn->is_virtfn = 1;\r\nvirtfn->multifunction = 0;\r\nfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {\r\nres = dev->resource + PCI_IOV_RESOURCES + i;\r\nif (!res->parent)\r\ncontinue;\r\nvirtfn->resource[i].name = pci_name(virtfn);\r\nvirtfn->resource[i].flags = res->flags;\r\nsize = resource_size(res);\r\ndo_div(size, iov->total_VFs);\r\nvirtfn->resource[i].start = res->start + size * id;\r\nvirtfn->resource[i].end = virtfn->resource[i].start + size - 1;\r\nrc = request_resource(res, &virtfn->resource[i]);\r\nBUG_ON(rc);\r\n}\r\nif (reset)\r\n__pci_reset_function(virtfn);\r\npci_device_add(virtfn, virtfn->bus);\r\nmutex_unlock(&iov->dev->sriov->lock);\r\npci_bus_add_device(virtfn);\r\nsprintf(buf, "virtfn%u", id);\r\nrc = sysfs_create_link(&dev->dev.kobj, &virtfn->dev.kobj, buf);\r\nif (rc)\r\ngoto failed1;\r\nrc = sysfs_create_link(&virtfn->dev.kobj, &dev->dev.kobj, "physfn");\r\nif (rc)\r\ngoto failed2;\r\nkobject_uevent(&virtfn->dev.kobj, KOBJ_CHANGE);\r\nreturn 0;\r\nfailed2:\r\nsysfs_remove_link(&dev->dev.kobj, buf);\r\nfailed1:\r\npci_dev_put(dev);\r\nmutex_lock(&iov->dev->sriov->lock);\r\npci_stop_and_remove_bus_device(virtfn);\r\nfailed0:\r\nvirtfn_remove_bus(dev->bus, bus);\r\nfailed:\r\nmutex_unlock(&iov->dev->sriov->lock);\r\nreturn rc;\r\n}\r\nstatic void virtfn_remove(struct pci_dev *dev, int id, int reset)\r\n{\r\nchar buf[VIRTFN_ID_LEN];\r\nstruct pci_dev *virtfn;\r\nstruct pci_sriov *iov = dev->sriov;\r\nvirtfn = pci_get_domain_bus_and_slot(pci_domain_nr(dev->bus),\r\nvirtfn_bus(dev, id),\r\nvirtfn_devfn(dev, id));\r\nif (!virtfn)\r\nreturn;\r\nif (reset) {\r\ndevice_release_driver(&virtfn->dev);\r\n__pci_reset_function(virtfn);\r\n}\r\nsprintf(buf, "virtfn%u", id);\r\nsysfs_remove_link(&dev->dev.kobj, buf);\r\nif (virtfn->dev.kobj.sd)\r\nsysfs_remove_link(&virtfn->dev.kobj, "physfn");\r\nmutex_lock(&iov->dev->sriov->lock);\r\npci_stop_and_remove_bus_device(virtfn);\r\nvirtfn_remove_bus(dev->bus, virtfn->bus);\r\nmutex_unlock(&iov->dev->sriov->lock);\r\npci_dev_put(virtfn);\r\npci_dev_put(dev);\r\n}\r\nstatic int sriov_enable(struct pci_dev *dev, int nr_virtfn)\r\n{\r\nint rc;\r\nint i, j;\r\nint nres;\r\nu16 offset, stride, initial;\r\nstruct resource *res;\r\nstruct pci_dev *pdev;\r\nstruct pci_sriov *iov = dev->sriov;\r\nint bars = 0;\r\nif (!nr_virtfn)\r\nreturn 0;\r\nif (iov->num_VFs)\r\nreturn -EINVAL;\r\npci_read_config_word(dev, iov->pos + PCI_SRIOV_INITIAL_VF, &initial);\r\nif (initial > iov->total_VFs ||\r\n(!(iov->cap & PCI_SRIOV_CAP_VFM) && (initial != iov->total_VFs)))\r\nreturn -EIO;\r\nif (nr_virtfn < 0 || nr_virtfn > iov->total_VFs ||\r\n(!(iov->cap & PCI_SRIOV_CAP_VFM) && (nr_virtfn > initial)))\r\nreturn -EINVAL;\r\npci_read_config_word(dev, iov->pos + PCI_SRIOV_VF_OFFSET, &offset);\r\npci_read_config_word(dev, iov->pos + PCI_SRIOV_VF_STRIDE, &stride);\r\nif (!offset || (nr_virtfn > 1 && !stride))\r\nreturn -EIO;\r\nnres = 0;\r\nfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {\r\nbars |= (1 << (i + PCI_IOV_RESOURCES));\r\nres = dev->resource + PCI_IOV_RESOURCES + i;\r\nif (res->parent)\r\nnres++;\r\n}\r\nif (nres != iov->nres) {\r\ndev_err(&dev->dev, "not enough MMIO resources for SR-IOV\n");\r\nreturn -ENOMEM;\r\n}\r\niov->offset = offset;\r\niov->stride = stride;\r\nif (virtfn_bus(dev, nr_virtfn - 1) > dev->bus->busn_res.end) {\r\ndev_err(&dev->dev, "SR-IOV: bus number out of range\n");\r\nreturn -ENOMEM;\r\n}\r\nif (pci_enable_resources(dev, bars)) {\r\ndev_err(&dev->dev, "SR-IOV: IOV BARS not allocated\n");\r\nreturn -ENOMEM;\r\n}\r\nif (iov->link != dev->devfn) {\r\npdev = pci_get_slot(dev->bus, iov->link);\r\nif (!pdev)\r\nreturn -ENODEV;\r\nif (!pdev->is_physfn) {\r\npci_dev_put(pdev);\r\nreturn -ENOSYS;\r\n}\r\nrc = sysfs_create_link(&dev->dev.kobj,\r\n&pdev->dev.kobj, "dep_link");\r\npci_dev_put(pdev);\r\nif (rc)\r\nreturn rc;\r\n}\r\npci_write_config_word(dev, iov->pos + PCI_SRIOV_NUM_VF, nr_virtfn);\r\niov->ctrl |= PCI_SRIOV_CTRL_VFE | PCI_SRIOV_CTRL_MSE;\r\npci_cfg_access_lock(dev);\r\npci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, iov->ctrl);\r\nmsleep(100);\r\npci_cfg_access_unlock(dev);\r\niov->initial_VFs = initial;\r\nif (nr_virtfn < initial)\r\ninitial = nr_virtfn;\r\nfor (i = 0; i < initial; i++) {\r\nrc = virtfn_add(dev, i, 0);\r\nif (rc)\r\ngoto failed;\r\n}\r\nkobject_uevent(&dev->dev.kobj, KOBJ_CHANGE);\r\niov->num_VFs = nr_virtfn;\r\nreturn 0;\r\nfailed:\r\nfor (j = 0; j < i; j++)\r\nvirtfn_remove(dev, j, 0);\r\niov->ctrl &= ~(PCI_SRIOV_CTRL_VFE | PCI_SRIOV_CTRL_MSE);\r\npci_cfg_access_lock(dev);\r\npci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, iov->ctrl);\r\npci_write_config_word(dev, iov->pos + PCI_SRIOV_NUM_VF, 0);\r\nssleep(1);\r\npci_cfg_access_unlock(dev);\r\nif (iov->link != dev->devfn)\r\nsysfs_remove_link(&dev->dev.kobj, "dep_link");\r\nreturn rc;\r\n}\r\nstatic void sriov_disable(struct pci_dev *dev)\r\n{\r\nint i;\r\nstruct pci_sriov *iov = dev->sriov;\r\nif (!iov->num_VFs)\r\nreturn;\r\nfor (i = 0; i < iov->num_VFs; i++)\r\nvirtfn_remove(dev, i, 0);\r\niov->ctrl &= ~(PCI_SRIOV_CTRL_VFE | PCI_SRIOV_CTRL_MSE);\r\npci_cfg_access_lock(dev);\r\npci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, iov->ctrl);\r\nssleep(1);\r\npci_cfg_access_unlock(dev);\r\nif (iov->link != dev->devfn)\r\nsysfs_remove_link(&dev->dev.kobj, "dep_link");\r\niov->num_VFs = 0;\r\npci_write_config_word(dev, iov->pos + PCI_SRIOV_NUM_VF, 0);\r\n}\r\nstatic int sriov_init(struct pci_dev *dev, int pos)\r\n{\r\nint i;\r\nint rc;\r\nint nres;\r\nu32 pgsz;\r\nu16 ctrl, total, offset, stride;\r\nstruct pci_sriov *iov;\r\nstruct resource *res;\r\nstruct pci_dev *pdev;\r\nif (pci_pcie_type(dev) != PCI_EXP_TYPE_RC_END &&\r\npci_pcie_type(dev) != PCI_EXP_TYPE_ENDPOINT)\r\nreturn -ENODEV;\r\npci_read_config_word(dev, pos + PCI_SRIOV_CTRL, &ctrl);\r\nif (ctrl & PCI_SRIOV_CTRL_VFE) {\r\npci_write_config_word(dev, pos + PCI_SRIOV_CTRL, 0);\r\nssleep(1);\r\n}\r\npci_read_config_word(dev, pos + PCI_SRIOV_TOTAL_VF, &total);\r\nif (!total)\r\nreturn 0;\r\nctrl = 0;\r\nlist_for_each_entry(pdev, &dev->bus->devices, bus_list)\r\nif (pdev->is_physfn)\r\ngoto found;\r\npdev = NULL;\r\nif (pci_ari_enabled(dev->bus))\r\nctrl |= PCI_SRIOV_CTRL_ARI;\r\nfound:\r\npci_write_config_word(dev, pos + PCI_SRIOV_CTRL, ctrl);\r\npci_write_config_word(dev, pos + PCI_SRIOV_NUM_VF, 0);\r\npci_read_config_word(dev, pos + PCI_SRIOV_VF_OFFSET, &offset);\r\npci_read_config_word(dev, pos + PCI_SRIOV_VF_STRIDE, &stride);\r\nif (!offset || (total > 1 && !stride))\r\nreturn -EIO;\r\npci_read_config_dword(dev, pos + PCI_SRIOV_SUP_PGSIZE, &pgsz);\r\ni = PAGE_SHIFT > 12 ? PAGE_SHIFT - 12 : 0;\r\npgsz &= ~((1 << i) - 1);\r\nif (!pgsz)\r\nreturn -EIO;\r\npgsz &= ~(pgsz - 1);\r\npci_write_config_dword(dev, pos + PCI_SRIOV_SYS_PGSIZE, pgsz);\r\nnres = 0;\r\nfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {\r\nres = dev->resource + PCI_IOV_RESOURCES + i;\r\ni += __pci_read_base(dev, pci_bar_unknown, res,\r\npos + PCI_SRIOV_BAR + i * 4);\r\nif (!res->flags)\r\ncontinue;\r\nif (resource_size(res) & (PAGE_SIZE - 1)) {\r\nrc = -EIO;\r\ngoto failed;\r\n}\r\nres->end = res->start + resource_size(res) * total - 1;\r\nnres++;\r\n}\r\niov = kzalloc(sizeof(*iov), GFP_KERNEL);\r\nif (!iov) {\r\nrc = -ENOMEM;\r\ngoto failed;\r\n}\r\niov->pos = pos;\r\niov->nres = nres;\r\niov->ctrl = ctrl;\r\niov->total_VFs = total;\r\niov->offset = offset;\r\niov->stride = stride;\r\niov->pgsz = pgsz;\r\niov->self = dev;\r\npci_read_config_dword(dev, pos + PCI_SRIOV_CAP, &iov->cap);\r\npci_read_config_byte(dev, pos + PCI_SRIOV_FUNC_LINK, &iov->link);\r\nif (pci_pcie_type(dev) == PCI_EXP_TYPE_RC_END)\r\niov->link = PCI_DEVFN(PCI_SLOT(dev->devfn), iov->link);\r\nif (pdev)\r\niov->dev = pci_dev_get(pdev);\r\nelse\r\niov->dev = dev;\r\nmutex_init(&iov->lock);\r\ndev->sriov = iov;\r\ndev->is_physfn = 1;\r\nreturn 0;\r\nfailed:\r\nfor (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {\r\nres = dev->resource + PCI_IOV_RESOURCES + i;\r\nres->flags = 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic void sriov_release(struct pci_dev *dev)\r\n{\r\nBUG_ON(dev->sriov->num_VFs);\r\nif (dev != dev->sriov->dev)\r\npci_dev_put(dev->sriov->dev);\r\nmutex_destroy(&dev->sriov->lock);\r\nkfree(dev->sriov);\r\ndev->sriov = NULL;\r\n}\r\nstatic void sriov_restore_state(struct pci_dev *dev)\r\n{\r\nint i;\r\nu16 ctrl;\r\nstruct pci_sriov *iov = dev->sriov;\r\npci_read_config_word(dev, iov->pos + PCI_SRIOV_CTRL, &ctrl);\r\nif (ctrl & PCI_SRIOV_CTRL_VFE)\r\nreturn;\r\nfor (i = PCI_IOV_RESOURCES; i <= PCI_IOV_RESOURCE_END; i++)\r\npci_update_resource(dev, i);\r\npci_write_config_dword(dev, iov->pos + PCI_SRIOV_SYS_PGSIZE, iov->pgsz);\r\npci_write_config_word(dev, iov->pos + PCI_SRIOV_NUM_VF, iov->num_VFs);\r\npci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, iov->ctrl);\r\nif (iov->ctrl & PCI_SRIOV_CTRL_VFE)\r\nmsleep(100);\r\n}\r\nint pci_iov_init(struct pci_dev *dev)\r\n{\r\nint pos;\r\nif (!pci_is_pcie(dev))\r\nreturn -ENODEV;\r\npos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_SRIOV);\r\nif (pos)\r\nreturn sriov_init(dev, pos);\r\nreturn -ENODEV;\r\n}\r\nvoid pci_iov_release(struct pci_dev *dev)\r\n{\r\nif (dev->is_physfn)\r\nsriov_release(dev);\r\n}\r\nint pci_iov_resource_bar(struct pci_dev *dev, int resno)\r\n{\r\nif (resno < PCI_IOV_RESOURCES || resno > PCI_IOV_RESOURCE_END)\r\nreturn 0;\r\nBUG_ON(!dev->is_physfn);\r\nreturn dev->sriov->pos + PCI_SRIOV_BAR +\r\n4 * (resno - PCI_IOV_RESOURCES);\r\n}\r\nresource_size_t pci_sriov_resource_alignment(struct pci_dev *dev, int resno)\r\n{\r\nstruct resource tmp;\r\nint reg = pci_iov_resource_bar(dev, resno);\r\nif (!reg)\r\nreturn 0;\r\n__pci_read_base(dev, pci_bar_unknown, &tmp, reg);\r\nreturn resource_alignment(&tmp);\r\n}\r\nvoid pci_restore_iov_state(struct pci_dev *dev)\r\n{\r\nif (dev->is_physfn)\r\nsriov_restore_state(dev);\r\n}\r\nint pci_iov_bus_range(struct pci_bus *bus)\r\n{\r\nint max = 0;\r\nu8 busnr;\r\nstruct pci_dev *dev;\r\nlist_for_each_entry(dev, &bus->devices, bus_list) {\r\nif (!dev->is_physfn)\r\ncontinue;\r\nbusnr = virtfn_bus(dev, dev->sriov->total_VFs - 1);\r\nif (busnr > max)\r\nmax = busnr;\r\n}\r\nreturn max ? max - bus->number : 0;\r\n}\r\nint pci_enable_sriov(struct pci_dev *dev, int nr_virtfn)\r\n{\r\nmight_sleep();\r\nif (!dev->is_physfn)\r\nreturn -ENOSYS;\r\nreturn sriov_enable(dev, nr_virtfn);\r\n}\r\nvoid pci_disable_sriov(struct pci_dev *dev)\r\n{\r\nmight_sleep();\r\nif (!dev->is_physfn)\r\nreturn;\r\nsriov_disable(dev);\r\n}\r\nint pci_num_vf(struct pci_dev *dev)\r\n{\r\nif (!dev->is_physfn)\r\nreturn 0;\r\nreturn dev->sriov->num_VFs;\r\n}\r\nint pci_vfs_assigned(struct pci_dev *dev)\r\n{\r\nstruct pci_dev *vfdev;\r\nunsigned int vfs_assigned = 0;\r\nunsigned short dev_id;\r\nif (!dev->is_physfn)\r\nreturn 0;\r\npci_read_config_word(dev, dev->sriov->pos + PCI_SRIOV_VF_DID, &dev_id);\r\nvfdev = pci_get_device(dev->vendor, dev_id, NULL);\r\nwhile (vfdev) {\r\nif (vfdev->is_virtfn && (vfdev->physfn == dev) &&\r\npci_is_dev_assigned(vfdev))\r\nvfs_assigned++;\r\nvfdev = pci_get_device(dev->vendor, dev_id, vfdev);\r\n}\r\nreturn vfs_assigned;\r\n}\r\nint pci_sriov_set_totalvfs(struct pci_dev *dev, u16 numvfs)\r\n{\r\nif (!dev->is_physfn)\r\nreturn -ENOSYS;\r\nif (numvfs > dev->sriov->total_VFs)\r\nreturn -EINVAL;\r\nif (dev->sriov->ctrl & PCI_SRIOV_CTRL_VFE)\r\nreturn -EBUSY;\r\nelse\r\ndev->sriov->driver_max_VFs = numvfs;\r\nreturn 0;\r\n}\r\nint pci_sriov_get_totalvfs(struct pci_dev *dev)\r\n{\r\nif (!dev->is_physfn)\r\nreturn 0;\r\nif (dev->sriov->driver_max_VFs)\r\nreturn dev->sriov->driver_max_VFs;\r\nreturn dev->sriov->total_VFs;\r\n}
