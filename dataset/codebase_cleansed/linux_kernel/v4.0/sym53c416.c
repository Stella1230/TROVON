static void sym53c416_set_transfer_counter(int base, unsigned int len)\r\n{\r\noutb(len & 0x0000FF, base + TC_LOW);\r\noutb((len & 0x00FF00) >> 8, base + TC_MID);\r\noutb((len & 0xFF0000) >> 16, base + TC_HIGH);\r\n}\r\nstatic __inline__ unsigned int sym53c416_read(int base, unsigned char *buffer, unsigned int len)\r\n{\r\nunsigned int orig_len = len;\r\nunsigned long flags = 0;\r\nunsigned int bytes_left;\r\nunsigned long i;\r\nint timeout = READ_TIMEOUT;\r\nspin_lock_irqsave(&sym53c416_lock, flags);\r\nwhile(len && timeout)\r\n{\r\nbytes_left = inb(base + PIO_FIFO_CNT);\r\nif(fastpio && bytes_left > 3)\r\n{\r\ninsl(base + PIO_FIFO_1, buffer, bytes_left >> 2);\r\nbuffer += bytes_left & 0xFC;\r\nlen -= bytes_left & 0xFC;\r\n}\r\nelse if(bytes_left > 0)\r\n{\r\nlen -= bytes_left;\r\nfor(; bytes_left > 0; bytes_left--)\r\n*(buffer++) = inb(base + PIO_FIFO_1);\r\n}\r\nelse\r\n{\r\ni = jiffies + timeout;\r\nspin_unlock_irqrestore(&sym53c416_lock, flags);\r\nwhile(time_before(jiffies, i) && (inb(base + PIO_INT_REG) & EMPTY) && timeout)\r\nif(inb(base + PIO_INT_REG) & SCI)\r\ntimeout = 0;\r\nspin_lock_irqsave(&sym53c416_lock, flags);\r\nif(inb(base + PIO_INT_REG) & EMPTY)\r\ntimeout = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&sym53c416_lock, flags);\r\nreturn orig_len - len;\r\n}\r\nstatic __inline__ unsigned int sym53c416_write(int base, unsigned char *buffer, unsigned int len)\r\n{\r\nunsigned int orig_len = len;\r\nunsigned long flags = 0;\r\nunsigned int bufferfree;\r\nunsigned long i;\r\nunsigned int timeout = WRITE_TIMEOUT;\r\nspin_lock_irqsave(&sym53c416_lock, flags);\r\nwhile(len && timeout)\r\n{\r\nbufferfree = PIO_SIZE - inb(base + PIO_FIFO_CNT);\r\nif(bufferfree > len)\r\nbufferfree = len;\r\nif(fastpio && bufferfree > 3)\r\n{\r\noutsl(base + PIO_FIFO_1, buffer, bufferfree >> 2);\r\nbuffer += bufferfree & 0xFC;\r\nlen -= bufferfree & 0xFC;\r\n}\r\nelse if(bufferfree > 0)\r\n{\r\nlen -= bufferfree;\r\nfor(; bufferfree > 0; bufferfree--)\r\noutb(*(buffer++), base + PIO_FIFO_1);\r\n}\r\nelse\r\n{\r\ni = jiffies + timeout;\r\nspin_unlock_irqrestore(&sym53c416_lock, flags);\r\nwhile(time_before(jiffies, i) && (inb(base + PIO_INT_REG) & FULL) && timeout)\r\n;\r\nspin_lock_irqsave(&sym53c416_lock, flags);\r\nif(inb(base + PIO_INT_REG) & FULL)\r\ntimeout = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&sym53c416_lock, flags);\r\nreturn orig_len - len;\r\n}\r\nstatic irqreturn_t sym53c416_intr_handle(int irq, void *dev_id)\r\n{\r\nstruct Scsi_Host *dev = dev_id;\r\nint base = dev->io_port;\r\nint i;\r\nunsigned long flags = 0;\r\nunsigned char status_reg, pio_int_reg, int_reg;\r\nstruct scatterlist *sg;\r\nunsigned int tot_trans = 0;\r\nspin_lock_irqsave(dev->host_lock,flags);\r\nstatus_reg = inb(base + STATUS_REG);\r\npio_int_reg = inb(base + PIO_INT_REG);\r\nint_reg = inb(base + INT_REG);\r\nspin_unlock_irqrestore(dev->host_lock, flags);\r\nif(int_reg & SCI)\r\n{\r\nprintk(KERN_DEBUG "sym53c416: Reset received\n");\r\ncurrent_command->SCp.phase = idle;\r\ncurrent_command->result = DID_RESET << 16;\r\nspin_lock_irqsave(dev->host_lock, flags);\r\ncurrent_command->scsi_done(current_command);\r\nspin_unlock_irqrestore(dev->host_lock, flags);\r\ngoto out;\r\n}\r\nif(int_reg & ILCMD)\r\n{\r\nprintk(KERN_WARNING "sym53c416: Illegal Command: 0x%02x.\n", inb(base + COMMAND_REG));\r\ncurrent_command->SCp.phase = idle;\r\ncurrent_command->result = DID_ERROR << 16;\r\nspin_lock_irqsave(dev->host_lock, flags);\r\ncurrent_command->scsi_done(current_command);\r\nspin_unlock_irqrestore(dev->host_lock, flags);\r\ngoto out;\r\n}\r\nif(status_reg & GE)\r\n{\r\nprintk(KERN_WARNING "sym53c416: Controller reports gross error.\n");\r\ncurrent_command->SCp.phase = idle;\r\ncurrent_command->result = DID_ERROR << 16;\r\nspin_lock_irqsave(dev->host_lock, flags);\r\ncurrent_command->scsi_done(current_command);\r\nspin_unlock_irqrestore(dev->host_lock, flags);\r\ngoto out;\r\n}\r\nif(status_reg & PE)\r\n{\r\nprintk(KERN_WARNING "sym53c416:SCSI parity error.\n");\r\ncurrent_command->SCp.phase = idle;\r\ncurrent_command->result = DID_PARITY << 16;\r\nspin_lock_irqsave(dev->host_lock, flags);\r\ncurrent_command->scsi_done(current_command);\r\nspin_unlock_irqrestore(dev->host_lock, flags);\r\ngoto out;\r\n}\r\nif(pio_int_reg & (CE | OUE))\r\n{\r\nprintk(KERN_WARNING "sym53c416: PIO interrupt error.\n");\r\ncurrent_command->SCp.phase = idle;\r\ncurrent_command->result = DID_ERROR << 16;\r\nspin_lock_irqsave(dev->host_lock, flags);\r\ncurrent_command->scsi_done(current_command);\r\nspin_unlock_irqrestore(dev->host_lock, flags);\r\ngoto out;\r\n}\r\nif(int_reg & DIS)\r\n{\r\nif(current_command->SCp.phase != message_in)\r\ncurrent_command->result = DID_NO_CONNECT << 16;\r\nelse\r\ncurrent_command->result = (current_command->SCp.Status & 0xFF) | ((current_command->SCp.Message & 0xFF) << 8) | (DID_OK << 16);\r\ncurrent_command->SCp.phase = idle;\r\nspin_lock_irqsave(dev->host_lock, flags);\r\ncurrent_command->scsi_done(current_command);\r\nspin_unlock_irqrestore(dev->host_lock, flags);\r\ngoto out;\r\n}\r\nswitch(status_reg & PHBITS)\r\n{\r\ncase PHASE_DATA_OUT:\r\n{\r\nif(int_reg & BS)\r\n{\r\ncurrent_command->SCp.phase = data_out;\r\noutb(FLUSH_FIFO, base + COMMAND_REG);\r\nsym53c416_set_transfer_counter(base,\r\nscsi_bufflen(current_command));\r\noutb(TRANSFER_INFORMATION | PIO_MODE, base + COMMAND_REG);\r\nscsi_for_each_sg(current_command,\r\nsg, scsi_sg_count(current_command), i) {\r\ntot_trans += sym53c416_write(base,\r\nSG_ADDRESS(sg),\r\nsg->length);\r\n}\r\nif(tot_trans < current_command->underflow)\r\nprintk(KERN_WARNING "sym53c416: Underflow, wrote %d bytes, request for %d bytes.\n", tot_trans, current_command->underflow);\r\n}\r\nbreak;\r\n}\r\ncase PHASE_DATA_IN:\r\n{\r\nif(int_reg & BS)\r\n{\r\ncurrent_command->SCp.phase = data_in;\r\noutb(FLUSH_FIFO, base + COMMAND_REG);\r\nsym53c416_set_transfer_counter(base,\r\nscsi_bufflen(current_command));\r\noutb(TRANSFER_INFORMATION | PIO_MODE, base + COMMAND_REG);\r\nscsi_for_each_sg(current_command,\r\nsg, scsi_sg_count(current_command), i) {\r\ntot_trans += sym53c416_read(base,\r\nSG_ADDRESS(sg),\r\nsg->length);\r\n}\r\nif(tot_trans < current_command->underflow)\r\nprintk(KERN_WARNING "sym53c416: Underflow, read %d bytes, request for %d bytes.\n", tot_trans, current_command->underflow);\r\n}\r\nbreak;\r\n}\r\ncase PHASE_COMMAND:\r\n{\r\ncurrent_command->SCp.phase = command_ph;\r\nprintk(KERN_ERR "sym53c416: Unknown interrupt in command phase.\n");\r\nbreak;\r\n}\r\ncase PHASE_STATUS:\r\n{\r\ncurrent_command->SCp.phase = status_ph;\r\noutb(FLUSH_FIFO, base + COMMAND_REG);\r\noutb(INIT_COMM_COMPLETE_SEQ, base + COMMAND_REG);\r\nbreak;\r\n}\r\ncase PHASE_RESERVED_1:\r\ncase PHASE_RESERVED_2:\r\n{\r\nprintk(KERN_ERR "sym53c416: Reserved phase occurred.\n");\r\nbreak;\r\n}\r\ncase PHASE_MESSAGE_OUT:\r\n{\r\ncurrent_command->SCp.phase = message_out;\r\noutb(SET_ATN, base + COMMAND_REG);\r\noutb(MSG_ACCEPTED, base + COMMAND_REG);\r\nbreak;\r\n}\r\ncase PHASE_MESSAGE_IN:\r\n{\r\ncurrent_command->SCp.phase = message_in;\r\ncurrent_command->SCp.Status = inb(base + SCSI_FIFO);\r\ncurrent_command->SCp.Message = inb(base + SCSI_FIFO);\r\nif(current_command->SCp.Message == SAVE_POINTERS || current_command->SCp.Message == DISCONNECT)\r\noutb(SET_ATN, base + COMMAND_REG);\r\noutb(MSG_ACCEPTED, base + COMMAND_REG);\r\nbreak;\r\n}\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sym53c416_init(int base, int scsi_id)\r\n{\r\noutb(RESET_CHIP, base + COMMAND_REG);\r\noutb(NOOP, base + COMMAND_REG);\r\noutb(0x99, base + TOM);\r\noutb(0x05, base + STP);\r\noutb(0x00, base + SYNC_OFFSET);\r\noutb(EPC | scsi_id, base + CONF_REG_1);\r\noutb(FE | SCSI2 | TBPA, base + CONF_REG_2);\r\noutb(IDMRC | QTE | CDB10 | FSCSI | FCLK, base + CONF_REG_3);\r\noutb(0x83 | EAN, base + CONF_REG_4);\r\noutb(IE | WSE0, base + CONF_REG_5);\r\noutb(0, base + FEATURE_EN);\r\n}\r\nstatic int sym53c416_probeirq(int base, int scsi_id)\r\n{\r\nint irq, irqs;\r\nunsigned long i;\r\ninb(base + INT_REG);\r\nirqs = probe_irq_on();\r\nsym53c416_init(base, scsi_id);\r\noutb(NOOP, base + COMMAND_REG);\r\noutb(ILLEGAL, base + COMMAND_REG);\r\noutb(0x07, base + DEST_BUS_ID);\r\noutb(0x00, base + DEST_BUS_ID);\r\ni = jiffies + 20;\r\nwhile(time_before(jiffies, i) && !(inb(base + STATUS_REG) & SCI))\r\nbarrier();\r\nif(time_before_eq(i, jiffies))\r\nreturn 0;\r\nirq = probe_irq_off(irqs);\r\nsym53c416_init(base, scsi_id);\r\nreturn irq;\r\n}\r\nvoid sym53c416_setup(char *str, int *ints)\r\n{\r\nint i;\r\nif(host_index >= MAXHOSTS)\r\n{\r\nprintk(KERN_WARNING "sym53c416: Too many hosts defined\n");\r\nreturn;\r\n}\r\nif(ints[0] < 1 || ints[0] > 2)\r\n{\r\nprintk(KERN_ERR "sym53c416: Wrong number of parameters:\n");\r\nprintk(KERN_ERR "sym53c416: usage: sym53c416=<base>[,<irq>]\n");\r\nreturn;\r\n}\r\nfor(i = 0; i < host_index && i >= 0; i++)\r\nif(hosts[i].base == ints[1])\r\ni = -2;\r\nif(i >= 0)\r\n{\r\nhosts[host_index].base = ints[1];\r\nhosts[host_index].irq = (ints[0] == 2)? ints[2] : 0;\r\nhost_index++;\r\n}\r\n}\r\nstatic int sym53c416_test(int base)\r\n{\r\noutb(RESET_CHIP, base + COMMAND_REG);\r\noutb(NOOP, base + COMMAND_REG);\r\nif(inb(base + COMMAND_REG) != NOOP)\r\nreturn 0;\r\nif(!inb(base + TC_HIGH) || inb(base + TC_HIGH) == 0xFF)\r\nreturn 0;\r\nif((inb(base + PIO_INT_REG) & (FULL | EMPTY | CE | OUE | FIE | EIE)) != EMPTY)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void sym53c416_probe(void)\r\n{\r\nint *base = probeaddrs;\r\nint ints[2];\r\nints[0] = 1;\r\nfor(; *base; base++) {\r\nif (request_region(*base, IO_RANGE, ID)) {\r\nif (sym53c416_test(*base)) {\r\nints[1] = *base;\r\nsym53c416_setup(NULL, ints);\r\n}\r\nrelease_region(*base, IO_RANGE);\r\n}\r\n}\r\n}\r\nint __init sym53c416_detect(struct scsi_host_template *tpnt)\r\n{\r\nunsigned long flags;\r\nstruct Scsi_Host * shpnt = NULL;\r\nint i;\r\nint count;\r\nstruct pnp_dev *idev = NULL;\r\n#ifdef MODULE\r\nint ints[3];\r\nints[0] = 2;\r\nif(sym53c416_base[0])\r\n{\r\nints[1] = sym53c416_base[0];\r\nints[2] = sym53c416_base[1];\r\nsym53c416_setup(NULL, ints);\r\n}\r\nif(sym53c416_base_1[0])\r\n{\r\nints[1] = sym53c416_base_1[0];\r\nints[2] = sym53c416_base_1[1];\r\nsym53c416_setup(NULL, ints);\r\n}\r\nif(sym53c416_base_2[0])\r\n{\r\nints[1] = sym53c416_base_2[0];\r\nints[2] = sym53c416_base_2[1];\r\nsym53c416_setup(NULL, ints);\r\n}\r\nif(sym53c416_base_3[0])\r\n{\r\nints[1] = sym53c416_base_3[0];\r\nints[2] = sym53c416_base_3[1];\r\nsym53c416_setup(NULL, ints);\r\n}\r\n#endif\r\nprintk(KERN_INFO "sym53c416.c: %s\n", VERSION_STRING);\r\nfor (i=0; id_table[i].vendor != 0; i++) {\r\nwhile((idev=pnp_find_dev(NULL, id_table[i].vendor,\r\nid_table[i].function, idev))!=NULL)\r\n{\r\nint i[3];\r\nif(pnp_device_attach(idev)<0)\r\n{\r\nprintk(KERN_WARNING "sym53c416: unable to attach PnP device.\n");\r\ncontinue;\r\n}\r\nif(pnp_activate_dev(idev) < 0)\r\n{\r\nprintk(KERN_WARNING "sym53c416: unable to activate PnP device.\n");\r\npnp_device_detach(idev);\r\ncontinue;\r\n}\r\ni[0] = 2;\r\ni[1] = pnp_port_start(idev, 0);\r\ni[2] = pnp_irq(idev, 0);\r\nprintk(KERN_INFO "sym53c416: ISAPnP card found and configured at 0x%X, IRQ %d.\n",\r\ni[1], i[2]);\r\nsym53c416_setup(NULL, i);\r\n}\r\n}\r\nsym53c416_probe();\r\nfor(count = 0, i = 0; i < host_index; i++) {\r\nif (!request_region(hosts[i].base, IO_RANGE, ID))\r\ncontinue;\r\nif (!sym53c416_test(hosts[i].base)) {\r\nprintk(KERN_WARNING "No sym53c416 found at address 0x%03x\n", hosts[i].base);\r\ngoto fail_release_region;\r\n}\r\nif (!hosts[i].irq)\r\nhosts[i].irq = sym53c416_probeirq(hosts[i].base, hosts[i].scsi_id);\r\nif (!hosts[i].irq)\r\ngoto fail_release_region;\r\nshpnt = scsi_register(tpnt, 0);\r\nif (!shpnt)\r\ngoto fail_release_region;\r\nif (request_irq(hosts[i].irq, sym53c416_intr_handle, 0, ID, shpnt))\r\ngoto fail_free_host;\r\nspin_lock_irqsave(&sym53c416_lock, flags);\r\nshpnt->unique_id = hosts[i].base;\r\nshpnt->io_port = hosts[i].base;\r\nshpnt->n_io_port = IO_RANGE;\r\nshpnt->irq = hosts[i].irq;\r\nshpnt->this_id = hosts[i].scsi_id;\r\nsym53c416_init(hosts[i].base, hosts[i].scsi_id);\r\ncount++;\r\nspin_unlock_irqrestore(&sym53c416_lock, flags);\r\ncontinue;\r\nfail_free_host:\r\nscsi_unregister(shpnt);\r\nfail_release_region:\r\nrelease_region(hosts[i].base, IO_RANGE);\r\n}\r\nreturn count;\r\n}\r\nconst char *sym53c416_info(struct Scsi_Host *SChost)\r\n{\r\nint i;\r\nint base = SChost->io_port;\r\nint irq = SChost->irq;\r\nint scsi_id = 0;\r\nint rev = inb(base + TC_HIGH);\r\nfor(i = 0; i < host_index; i++)\r\nif(hosts[i].base == base)\r\nscsi_id = hosts[i].scsi_id;\r\nsprintf(info, "Symbios Logic 53c416 (rev. %d) at 0x%03x, irq %d, SCSI-ID %d, %s pio", rev, base, irq, scsi_id, (fastpio)? "fast" : "slow");\r\nreturn info;\r\n}\r\nstatic int sym53c416_queuecommand_lck(Scsi_Cmnd *SCpnt, void (*done)(Scsi_Cmnd *))\r\n{\r\nint base;\r\nunsigned long flags = 0;\r\nint i;\r\nbase = SCpnt->device->host->io_port;\r\ncurrent_command = SCpnt;\r\ncurrent_command->scsi_done = done;\r\ncurrent_command->SCp.phase = command_ph;\r\ncurrent_command->SCp.Status = 0;\r\ncurrent_command->SCp.Message = 0;\r\nspin_lock_irqsave(&sym53c416_lock, flags);\r\noutb(scmd_id(SCpnt), base + DEST_BUS_ID);\r\noutb(FLUSH_FIFO, base + COMMAND_REG);\r\nfor(i = 0; i < SCpnt->cmd_len; i++)\r\noutb(SCpnt->cmnd[i], base + SCSI_FIFO);\r\noutb(SEL_WITHOUT_ATN_SEQ, base + COMMAND_REG);\r\nspin_unlock_irqrestore(&sym53c416_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sym53c416_host_reset(Scsi_Cmnd *SCpnt)\r\n{\r\nint base;\r\nint scsi_id = -1;\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sym53c416_lock, flags);\r\nbase = SCpnt->device->host->io_port;\r\nfor(i = 0; i < host_index && scsi_id == -1; i++)\r\nif(hosts[i].base == base)\r\nscsi_id = hosts[i].scsi_id;\r\noutb(RESET_CHIP, base + COMMAND_REG);\r\noutb(NOOP | PIO_MODE, base + COMMAND_REG);\r\noutb(RESET_SCSI_BUS, base + COMMAND_REG);\r\nsym53c416_init(base, scsi_id);\r\nspin_unlock_irqrestore(&sym53c416_lock, flags);\r\nreturn SUCCESS;\r\n}\r\nstatic int sym53c416_release(struct Scsi_Host *shost)\r\n{\r\nif (shost->irq)\r\nfree_irq(shost->irq, shost);\r\nif (shost->io_port && shost->n_io_port)\r\nrelease_region(shost->io_port, shost->n_io_port);\r\nreturn 0;\r\n}\r\nstatic int sym53c416_bios_param(struct scsi_device *sdev,\r\nstruct block_device *dev,\r\nsector_t capacity, int *ip)\r\n{\r\nint size;\r\nsize = capacity;\r\nip[0] = 64;\r\nip[1] = 32;\r\nif((ip[2] = size >> 11) > 1024)\r\n{\r\nip[0] = 255;\r\nip[1] = 63;\r\nip[2] = size / (255 * 63);\r\n}\r\nreturn 0;\r\n}
