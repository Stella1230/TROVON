int\r\naic7770_map_registers(struct ahc_softc *ahc, u_int port)\r\n{\r\nif (!request_region(port, AHC_EISA_IOSIZE, "aic7xxx"))\r\nreturn (ENOMEM);\r\nahc->tag = BUS_SPACE_PIO;\r\nahc->bsh.ioport = port;\r\nreturn (0);\r\n}\r\nint\r\naic7770_map_int(struct ahc_softc *ahc, u_int irq)\r\n{\r\nint error;\r\nint shared;\r\nshared = 0;\r\nif ((ahc->flags & AHC_EDGE_INTERRUPT) == 0)\r\nshared = IRQF_SHARED;\r\nerror = request_irq(irq, ahc_linux_isr, shared, "aic7xxx", ahc);\r\nif (error == 0)\r\nahc->platform_data->irq = irq;\r\nreturn (-error);\r\n}\r\nstatic int\r\naic7770_probe(struct device *dev)\r\n{\r\nstruct eisa_device *edev = to_eisa_device(dev);\r\nu_int eisaBase = edev->base_addr+AHC_EISA_SLOT_OFFSET;\r\nstruct ahc_softc *ahc;\r\nchar buf[80];\r\nchar *name;\r\nint error;\r\nsprintf(buf, "ahc_eisa:%d", eisaBase >> 12);\r\nname = kstrdup(buf, GFP_ATOMIC);\r\nif (name == NULL)\r\nreturn (ENOMEM);\r\nahc = ahc_alloc(&aic7xxx_driver_template, name);\r\nif (ahc == NULL)\r\nreturn (ENOMEM);\r\nerror = aic7770_config(ahc, aic7770_ident_table + edev->id.driver_data,\r\neisaBase);\r\nif (error != 0) {\r\nahc->bsh.ioport = 0;\r\nahc_free(ahc);\r\nreturn (error);\r\n}\r\ndev_set_drvdata(dev, ahc);\r\nerror = ahc_linux_register_host(ahc, &aic7xxx_driver_template);\r\nreturn (error);\r\n}\r\nstatic int\r\naic7770_remove(struct device *dev)\r\n{\r\nstruct ahc_softc *ahc = dev_get_drvdata(dev);\r\nu_long s;\r\nif (ahc->platform_data && ahc->platform_data->host)\r\nscsi_remove_host(ahc->platform_data->host);\r\nahc_lock(ahc, &s);\r\nahc_intr_enable(ahc, FALSE);\r\nahc_unlock(ahc, &s);\r\nahc_free(ahc);\r\nreturn 0;\r\n}\r\nint\r\nahc_linux_eisa_init(void)\r\n{\r\nreturn eisa_driver_register(&aic7770_driver);\r\n}\r\nvoid\r\nahc_linux_eisa_exit(void)\r\n{\r\neisa_driver_unregister(&aic7770_driver);\r\n}
