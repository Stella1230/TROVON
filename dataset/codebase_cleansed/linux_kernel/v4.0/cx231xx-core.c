void cx231xx_remove_from_devlist(struct cx231xx *dev)\r\n{\r\nif (dev == NULL)\r\nreturn;\r\nif (dev->udev == NULL)\r\nreturn;\r\nif (atomic_read(&dev->devlist_count) > 0) {\r\nmutex_lock(&cx231xx_devlist_mutex);\r\nlist_del(&dev->devlist);\r\natomic_dec(&dev->devlist_count);\r\nmutex_unlock(&cx231xx_devlist_mutex);\r\n}\r\n}\r\nvoid cx231xx_add_into_devlist(struct cx231xx *dev)\r\n{\r\nmutex_lock(&cx231xx_devlist_mutex);\r\nlist_add_tail(&dev->devlist, &cx231xx_devlist);\r\natomic_inc(&dev->devlist_count);\r\nmutex_unlock(&cx231xx_devlist_mutex);\r\n}\r\nint cx231xx_register_extension(struct cx231xx_ops *ops)\r\n{\r\nstruct cx231xx *dev = NULL;\r\nmutex_lock(&cx231xx_devlist_mutex);\r\nlist_add_tail(&ops->next, &cx231xx_extension_devlist);\r\nlist_for_each_entry(dev, &cx231xx_devlist, devlist) {\r\nops->init(dev);\r\ndev_info(dev->dev, "%s initialized\n", ops->name);\r\n}\r\nmutex_unlock(&cx231xx_devlist_mutex);\r\nreturn 0;\r\n}\r\nvoid cx231xx_unregister_extension(struct cx231xx_ops *ops)\r\n{\r\nstruct cx231xx *dev = NULL;\r\nmutex_lock(&cx231xx_devlist_mutex);\r\nlist_for_each_entry(dev, &cx231xx_devlist, devlist) {\r\nops->fini(dev);\r\ndev_info(dev->dev, "%s removed\n", ops->name);\r\n}\r\nlist_del(&ops->next);\r\nmutex_unlock(&cx231xx_devlist_mutex);\r\n}\r\nvoid cx231xx_init_extension(struct cx231xx *dev)\r\n{\r\nstruct cx231xx_ops *ops = NULL;\r\nmutex_lock(&cx231xx_devlist_mutex);\r\nif (!list_empty(&cx231xx_extension_devlist)) {\r\nlist_for_each_entry(ops, &cx231xx_extension_devlist, next) {\r\nif (ops->init)\r\nops->init(dev);\r\n}\r\n}\r\nmutex_unlock(&cx231xx_devlist_mutex);\r\n}\r\nvoid cx231xx_close_extension(struct cx231xx *dev)\r\n{\r\nstruct cx231xx_ops *ops = NULL;\r\nmutex_lock(&cx231xx_devlist_mutex);\r\nif (!list_empty(&cx231xx_extension_devlist)) {\r\nlist_for_each_entry(ops, &cx231xx_extension_devlist, next) {\r\nif (ops->fini)\r\nops->fini(dev);\r\n}\r\n}\r\nmutex_unlock(&cx231xx_devlist_mutex);\r\n}\r\nint cx231xx_send_usb_command(struct cx231xx_i2c *i2c_bus,\r\nstruct cx231xx_i2c_xfer_data *req_data)\r\n{\r\nint status = 0;\r\nstruct cx231xx *dev = i2c_bus->dev;\r\nstruct VENDOR_REQUEST_IN ven_req;\r\nu8 saddr_len = 0;\r\nu8 _i2c_period = 0;\r\nu8 _i2c_nostop = 0;\r\nu8 _i2c_reserve = 0;\r\nif (dev->state & DEV_DISCONNECTED)\r\nreturn -ENODEV;\r\n_i2c_period = i2c_bus->i2c_period;\r\n_i2c_nostop = i2c_bus->i2c_nostop;\r\n_i2c_reserve = i2c_bus->i2c_reserve;\r\nsaddr_len = req_data->saddr_len;\r\nif (saddr_len == 1)\r\nven_req.wValue =\r\nreq_data->\r\ndev_addr << 9 | _i2c_period << 4 | saddr_len << 2 |\r\n_i2c_nostop << 1 | I2C_SYNC | _i2c_reserve << 6;\r\nelse\r\nven_req.wValue =\r\nreq_data->\r\ndev_addr << 9 | _i2c_period << 4 | saddr_len << 2 |\r\n_i2c_nostop << 1 | I2C_SYNC | _i2c_reserve << 6;\r\nif (req_data->direction & I2C_M_RD) {\r\nven_req.bRequest = i2c_bus->nr + 4;\r\n} else\r\nven_req.bRequest = i2c_bus->nr;\r\nswitch (saddr_len) {\r\ncase 0:\r\nven_req.wIndex = 0;\r\nbreak;\r\ncase 1:\r\nven_req.wIndex = (req_data->saddr_dat & 0xff);\r\nbreak;\r\ncase 2:\r\nven_req.wIndex = req_data->saddr_dat;\r\nbreak;\r\n}\r\nven_req.wLength = req_data->buf_size;\r\nven_req.bData = 0;\r\nif (req_data->direction) {\r\nven_req.direction = USB_DIR_IN;\r\nmemset(req_data->p_buffer, 0x00, ven_req.wLength);\r\n} else\r\nven_req.direction = USB_DIR_OUT;\r\nven_req.pBuff = req_data->p_buffer;\r\nstatus = cx231xx_send_vendor_cmd(dev, &ven_req);\r\nif (status < 0 && !dev->i2c_scan_running) {\r\ndev_err(dev->dev, "%s: failed with status -%d\n",\r\n__func__, status);\r\n}\r\nreturn status;\r\n}\r\nstatic int __usb_control_msg(struct cx231xx *dev, unsigned int pipe,\r\n__u8 request, __u8 requesttype, __u16 value, __u16 index,\r\nvoid *data, __u16 size, int timeout)\r\n{\r\nint rc, i;\r\nif (reg_debug) {\r\nprintk(KERN_DEBUG "%s: (pipe 0x%08x): "\r\n"%s: %02x %02x %02x %02x %02x %02x %02x %02x ",\r\ndev->name,\r\npipe,\r\n(requesttype & USB_DIR_IN) ? "IN" : "OUT",\r\nrequesttype,\r\nrequest,\r\nvalue & 0xff, value >> 8,\r\nindex & 0xff, index >> 8,\r\nsize & 0xff, size >> 8);\r\nif (!(requesttype & USB_DIR_IN)) {\r\nprintk(KERN_CONT ">>>");\r\nfor (i = 0; i < size; i++)\r\nprintk(KERN_CONT " %02x",\r\n((unsigned char *)data)[i]);\r\n}\r\n}\r\nmutex_lock(&dev->ctrl_urb_lock);\r\nif (!(requesttype & USB_DIR_IN) && size)\r\nmemcpy(dev->urb_buf, data, size);\r\nrc = usb_control_msg(dev->udev, pipe, request, requesttype, value,\r\nindex, dev->urb_buf, size, timeout);\r\nif ((requesttype & USB_DIR_IN) && size)\r\nmemcpy(data, dev->urb_buf, size);\r\nmutex_unlock(&dev->ctrl_urb_lock);\r\nif (reg_debug) {\r\nif (unlikely(rc < 0)) {\r\nprintk(KERN_CONT "FAILED!\n");\r\nreturn rc;\r\n}\r\nif ((requesttype & USB_DIR_IN)) {\r\nprintk(KERN_CONT "<<<");\r\nfor (i = 0; i < size; i++)\r\nprintk(KERN_CONT " %02x",\r\n((unsigned char *)data)[i]);\r\n}\r\nprintk(KERN_CONT "\n");\r\n}\r\nreturn rc;\r\n}\r\nint cx231xx_read_ctrl_reg(struct cx231xx *dev, u8 req, u16 reg,\r\nchar *buf, int len)\r\n{\r\nu8 val = 0;\r\nint ret;\r\nint pipe = usb_rcvctrlpipe(dev->udev, 0);\r\nif (dev->state & DEV_DISCONNECTED)\r\nreturn -ENODEV;\r\nif (len > URB_MAX_CTRL_SIZE)\r\nreturn -EINVAL;\r\nswitch (len) {\r\ncase 1:\r\nval = ENABLE_ONE_BYTE;\r\nbreak;\r\ncase 2:\r\nval = ENABLE_TWE_BYTE;\r\nbreak;\r\ncase 3:\r\nval = ENABLE_THREE_BYTE;\r\nbreak;\r\ncase 4:\r\nval = ENABLE_FOUR_BYTE;\r\nbreak;\r\ndefault:\r\nval = 0xFF;\r\n}\r\nif (val == 0xFF)\r\nreturn -EINVAL;\r\nret = __usb_control_msg(dev, pipe, req,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nval, reg, buf, len, HZ);\r\nreturn ret;\r\n}\r\nint cx231xx_send_vendor_cmd(struct cx231xx *dev,\r\nstruct VENDOR_REQUEST_IN *ven_req)\r\n{\r\nint ret;\r\nint pipe = 0;\r\nint unsend_size = 0;\r\nu8 *pdata;\r\nif (dev->state & DEV_DISCONNECTED)\r\nreturn -ENODEV;\r\nif ((ven_req->wLength > URB_MAX_CTRL_SIZE))\r\nreturn -EINVAL;\r\nif (ven_req->direction)\r\npipe = usb_rcvctrlpipe(dev->udev, 0);\r\nelse\r\npipe = usb_sndctrlpipe(dev->udev, 0);\r\nif ((ven_req->wLength > 4) && ((ven_req->bRequest == 0x4) ||\r\n(ven_req->bRequest == 0x5) ||\r\n(ven_req->bRequest == 0x6))) {\r\nunsend_size = 0;\r\npdata = ven_req->pBuff;\r\nunsend_size = ven_req->wLength;\r\nven_req->wValue = ven_req->wValue & 0xFFFB;\r\nven_req->wValue = (ven_req->wValue & 0xFFBD) | 0x2;\r\nret = __usb_control_msg(dev, pipe, ven_req->bRequest,\r\nven_req->direction | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nven_req->wValue, ven_req->wIndex, pdata,\r\n0x0004, HZ);\r\nunsend_size = unsend_size - 4;\r\nven_req->wValue = (ven_req->wValue & 0xFFBD) | 0x42;\r\nwhile (unsend_size - 4 > 0) {\r\npdata = pdata + 4;\r\nret = __usb_control_msg(dev, pipe,\r\nven_req->bRequest,\r\nven_req->direction | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nven_req->wValue, ven_req->wIndex, pdata,\r\n0x0004, HZ);\r\nunsend_size = unsend_size - 4;\r\n}\r\nven_req->wValue = (ven_req->wValue & 0xFFBD) | 0x40;\r\npdata = pdata + 4;\r\nret = __usb_control_msg(dev, pipe, ven_req->bRequest,\r\nven_req->direction | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nven_req->wValue, ven_req->wIndex, pdata,\r\nunsend_size, HZ);\r\n} else {\r\nret = __usb_control_msg(dev, pipe, ven_req->bRequest,\r\nven_req->direction | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nven_req->wValue, ven_req->wIndex,\r\nven_req->pBuff, ven_req->wLength, HZ);\r\n}\r\nreturn ret;\r\n}\r\nint cx231xx_write_ctrl_reg(struct cx231xx *dev, u8 req, u16 reg, char *buf,\r\nint len)\r\n{\r\nu8 val = 0;\r\nint ret;\r\nint pipe = usb_sndctrlpipe(dev->udev, 0);\r\nif (dev->state & DEV_DISCONNECTED)\r\nreturn -ENODEV;\r\nif ((len < 1) || (len > URB_MAX_CTRL_SIZE))\r\nreturn -EINVAL;\r\nswitch (len) {\r\ncase 1:\r\nval = ENABLE_ONE_BYTE;\r\nbreak;\r\ncase 2:\r\nval = ENABLE_TWE_BYTE;\r\nbreak;\r\ncase 3:\r\nval = ENABLE_THREE_BYTE;\r\nbreak;\r\ncase 4:\r\nval = ENABLE_FOUR_BYTE;\r\nbreak;\r\ndefault:\r\nval = 0xFF;\r\n}\r\nif (val == 0xFF)\r\nreturn -EINVAL;\r\nif (reg_debug) {\r\nint byte;\r\ncx231xx_isocdbg("(pipe 0x%08x): "\r\n"OUT: %02x %02x %02x %02x %02x %02x %02x %02x >>>",\r\npipe,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nreq, 0, val, reg & 0xff,\r\nreg >> 8, len & 0xff, len >> 8);\r\nfor (byte = 0; byte < len; byte++)\r\ncx231xx_isocdbg(" %02x", (unsigned char)buf[byte]);\r\ncx231xx_isocdbg("\n");\r\n}\r\nret = __usb_control_msg(dev, pipe, req,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nval, reg, buf, len, HZ);\r\nreturn ret;\r\n}\r\nint cx231xx_set_video_alternate(struct cx231xx *dev)\r\n{\r\nint errCode, prev_alt = dev->video_mode.alt;\r\nunsigned int min_pkt_size = dev->width * 2 + 4;\r\nu32 usb_interface_index = 0;\r\nif (dev->width * 2 * dev->height > 720 * 240 * 2)\r\nmin_pkt_size *= 2;\r\nif (dev->width > 360) {\r\ndev->video_mode.alt = 3;\r\n} else if (dev->width > 180) {\r\ndev->video_mode.alt = 2;\r\n} else if (dev->width > 0) {\r\ndev->video_mode.alt = 1;\r\n} else {\r\ndev->video_mode.alt = 0;\r\n}\r\nif (dev->USE_ISO == 0)\r\ndev->video_mode.alt = 0;\r\ncx231xx_coredbg("dev->video_mode.alt= %d\n", dev->video_mode.alt);\r\nusb_interface_index =\r\ndev->current_pcb_config.hs_config_info[0].interface_info.\r\nvideo_index + 1;\r\nif (dev->video_mode.alt != prev_alt) {\r\ncx231xx_coredbg("minimum isoc packet size: %u (alt=%d)\n",\r\nmin_pkt_size, dev->video_mode.alt);\r\nif (dev->video_mode.alt_max_pkt_size != NULL)\r\ndev->video_mode.max_pkt_size =\r\ndev->video_mode.alt_max_pkt_size[dev->video_mode.alt];\r\ncx231xx_coredbg("setting alternate %d with wMaxPacketSize=%u\n",\r\ndev->video_mode.alt,\r\ndev->video_mode.max_pkt_size);\r\nerrCode =\r\nusb_set_interface(dev->udev, usb_interface_index,\r\ndev->video_mode.alt);\r\nif (errCode < 0) {\r\ndev_err(dev->dev,\r\n"cannot change alt number to %d (error=%i)\n",\r\ndev->video_mode.alt, errCode);\r\nreturn errCode;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint cx231xx_set_alt_setting(struct cx231xx *dev, u8 index, u8 alt)\r\n{\r\nint status = 0;\r\nu32 usb_interface_index = 0;\r\nu32 max_pkt_size = 0;\r\nswitch (index) {\r\ncase INDEX_TS1:\r\nusb_interface_index =\r\ndev->current_pcb_config.hs_config_info[0].interface_info.\r\nts1_index + 1;\r\ndev->ts1_mode.alt = alt;\r\nif (dev->ts1_mode.alt_max_pkt_size != NULL)\r\nmax_pkt_size = dev->ts1_mode.max_pkt_size =\r\ndev->ts1_mode.alt_max_pkt_size[dev->ts1_mode.alt];\r\nbreak;\r\ncase INDEX_TS2:\r\nusb_interface_index =\r\ndev->current_pcb_config.hs_config_info[0].interface_info.\r\nts2_index + 1;\r\nbreak;\r\ncase INDEX_AUDIO:\r\nusb_interface_index =\r\ndev->current_pcb_config.hs_config_info[0].interface_info.\r\naudio_index + 1;\r\ndev->adev.alt = alt;\r\nif (dev->adev.alt_max_pkt_size != NULL)\r\nmax_pkt_size = dev->adev.max_pkt_size =\r\ndev->adev.alt_max_pkt_size[dev->adev.alt];\r\nbreak;\r\ncase INDEX_VIDEO:\r\nusb_interface_index =\r\ndev->current_pcb_config.hs_config_info[0].interface_info.\r\nvideo_index + 1;\r\ndev->video_mode.alt = alt;\r\nif (dev->video_mode.alt_max_pkt_size != NULL)\r\nmax_pkt_size = dev->video_mode.max_pkt_size =\r\ndev->video_mode.alt_max_pkt_size[dev->video_mode.\r\nalt];\r\nbreak;\r\ncase INDEX_VANC:\r\nif (dev->board.no_alt_vanc)\r\nreturn 0;\r\nusb_interface_index =\r\ndev->current_pcb_config.hs_config_info[0].interface_info.\r\nvanc_index + 1;\r\ndev->vbi_mode.alt = alt;\r\nif (dev->vbi_mode.alt_max_pkt_size != NULL)\r\nmax_pkt_size = dev->vbi_mode.max_pkt_size =\r\ndev->vbi_mode.alt_max_pkt_size[dev->vbi_mode.alt];\r\nbreak;\r\ncase INDEX_HANC:\r\nusb_interface_index =\r\ndev->current_pcb_config.hs_config_info[0].interface_info.\r\nhanc_index + 1;\r\ndev->sliced_cc_mode.alt = alt;\r\nif (dev->sliced_cc_mode.alt_max_pkt_size != NULL)\r\nmax_pkt_size = dev->sliced_cc_mode.max_pkt_size =\r\ndev->sliced_cc_mode.alt_max_pkt_size[dev->\r\nsliced_cc_mode.\r\nalt];\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (alt > 0 && max_pkt_size == 0) {\r\ndev_err(dev->dev,\r\n"can't change interface %d alt no. to %d: Max. Pkt size = 0\n",\r\nusb_interface_index, alt);\r\nif (dev->board.no_alt_vanc)\r\nreturn -1;\r\n}\r\ncx231xx_coredbg("setting alternate %d with wMaxPacketSize=%u,"\r\n"Interface = %d\n", alt, max_pkt_size,\r\nusb_interface_index);\r\nif (usb_interface_index > 0) {\r\nstatus = usb_set_interface(dev->udev, usb_interface_index, alt);\r\nif (status < 0) {\r\ndev_err(dev->dev,\r\n"can't change interface %d alt no. to %d (err=%i)\n",\r\nusb_interface_index, alt, status);\r\nreturn status;\r\n}\r\n}\r\nreturn status;\r\n}\r\nint cx231xx_gpio_set(struct cx231xx *dev, struct cx231xx_reg_seq *gpio)\r\n{\r\nint rc = 0;\r\nif (!gpio)\r\nreturn rc;\r\nwhile (gpio->sleep >= 0) {\r\nrc = cx231xx_set_gpio_value(dev, gpio->bit, gpio->val);\r\nif (rc < 0)\r\nreturn rc;\r\nif (gpio->sleep > 0)\r\nmsleep(gpio->sleep);\r\ngpio++;\r\n}\r\nreturn rc;\r\n}\r\nint cx231xx_demod_reset(struct cx231xx *dev)\r\n{\r\nu8 status = 0;\r\nu8 value[4] = { 0, 0, 0, 0 };\r\nstatus = cx231xx_read_ctrl_reg(dev, VRT_GET_REGISTER, PWR_CTL_EN,\r\nvalue, 4);\r\ncx231xx_coredbg("reg0x%x=0x%x 0x%x 0x%x 0x%x\n", PWR_CTL_EN,\r\nvalue[0], value[1], value[2], value[3]);\r\ncx231xx_coredbg("Enter cx231xx_demod_reset()\n");\r\nvalue[1] = (u8) 0x3;\r\nstatus = cx231xx_write_ctrl_reg(dev, VRT_SET_REGISTER,\r\nPWR_CTL_EN, value, 4);\r\nmsleep(10);\r\nvalue[1] = (u8) 0x0;\r\nstatus = cx231xx_write_ctrl_reg(dev, VRT_SET_REGISTER,\r\nPWR_CTL_EN, value, 4);\r\nmsleep(10);\r\nvalue[1] = (u8) 0x3;\r\nstatus = cx231xx_write_ctrl_reg(dev, VRT_SET_REGISTER,\r\nPWR_CTL_EN, value, 4);\r\nmsleep(10);\r\nstatus = cx231xx_read_ctrl_reg(dev, VRT_GET_REGISTER, PWR_CTL_EN,\r\nvalue, 4);\r\ncx231xx_coredbg("reg0x%x=0x%x 0x%x 0x%x 0x%x\n", PWR_CTL_EN,\r\nvalue[0], value[1], value[2], value[3]);\r\nreturn status;\r\n}\r\nint is_fw_load(struct cx231xx *dev)\r\n{\r\nreturn cx231xx_check_fw(dev);\r\n}\r\nint cx231xx_set_mode(struct cx231xx *dev, enum cx231xx_mode set_mode)\r\n{\r\nint errCode = 0;\r\nif (dev->mode == set_mode)\r\nreturn 0;\r\nif (set_mode == CX231XX_SUSPEND) {\r\ndev->mode = set_mode;\r\n}\r\nif (dev->mode != CX231XX_SUSPEND)\r\nreturn -EINVAL;\r\ndev->mode = set_mode;\r\nif (dev->mode == CX231XX_DIGITAL_MODE) {\r\nswitch (dev->model) {\r\ncase CX231XX_BOARD_CNXT_CARRAERA:\r\ncase CX231XX_BOARD_CNXT_RDE_250:\r\ncase CX231XX_BOARD_CNXT_SHELBY:\r\ncase CX231XX_BOARD_CNXT_RDU_250:\r\nerrCode = cx231xx_set_agc_analog_digital_mux_select(dev, 0);\r\nbreak;\r\ncase CX231XX_BOARD_CNXT_RDE_253S:\r\ncase CX231XX_BOARD_CNXT_RDU_253S:\r\nerrCode = cx231xx_set_agc_analog_digital_mux_select(dev, 1);\r\nbreak;\r\ncase CX231XX_BOARD_HAUPPAUGE_EXETER:\r\ncase CX231XX_BOARD_HAUPPAUGE_930C_HD_1113xx:\r\nerrCode = cx231xx_set_power_mode(dev,\r\nPOLARIS_AVMODE_DIGITAL);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nswitch (dev->model) {\r\ncase CX231XX_BOARD_CNXT_CARRAERA:\r\ncase CX231XX_BOARD_CNXT_RDE_250:\r\ncase CX231XX_BOARD_CNXT_SHELBY:\r\ncase CX231XX_BOARD_CNXT_RDU_250:\r\nerrCode = cx231xx_set_agc_analog_digital_mux_select(dev, 1);\r\nbreak;\r\ncase CX231XX_BOARD_CNXT_RDE_253S:\r\ncase CX231XX_BOARD_CNXT_RDU_253S:\r\ncase CX231XX_BOARD_HAUPPAUGE_EXETER:\r\ncase CX231XX_BOARD_HAUPPAUGE_930C_HD_1113xx:\r\ncase CX231XX_BOARD_PV_PLAYTV_USB_HYBRID:\r\ncase CX231XX_BOARD_HAUPPAUGE_USB2_FM_PAL:\r\ncase CX231XX_BOARD_HAUPPAUGE_USB2_FM_NTSC:\r\nerrCode = cx231xx_set_agc_analog_digital_mux_select(dev, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn errCode ? -EINVAL : 0;\r\n}\r\nint cx231xx_ep5_bulkout(struct cx231xx *dev, u8 *firmware, u16 size)\r\n{\r\nint errCode = 0;\r\nint actlen, ret = -ENOMEM;\r\nu32 *buffer;\r\nbuffer = kzalloc(4096, GFP_KERNEL);\r\nif (buffer == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(&buffer[0], firmware, 4096);\r\nret = usb_bulk_msg(dev->udev, usb_sndbulkpipe(dev->udev, 5),\r\nbuffer, 4096, &actlen, 2000);\r\nif (ret)\r\ndev_err(dev->dev,\r\n"bulk message failed: %d (%d/%d)", ret,\r\nsize, actlen);\r\nelse {\r\nerrCode = actlen != size ? -1 : 0;\r\n}\r\nkfree(buffer);\r\nreturn errCode;\r\n}\r\nstatic void cx231xx_isoc_irq_callback(struct urb *urb)\r\n{\r\nstruct cx231xx_dmaqueue *dma_q = urb->context;\r\nstruct cx231xx_video_mode *vmode =\r\ncontainer_of(dma_q, struct cx231xx_video_mode, vidq);\r\nstruct cx231xx *dev = container_of(vmode, struct cx231xx, video_mode);\r\nint i;\r\nswitch (urb->status) {\r\ncase 0:\r\ncase -ETIMEDOUT:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ncx231xx_isocdbg("urb completition error %d.\n", urb->status);\r\nbreak;\r\n}\r\nspin_lock(&dev->video_mode.slock);\r\ndev->video_mode.isoc_ctl.isoc_copy(dev, urb);\r\nspin_unlock(&dev->video_mode.slock);\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nurb->iso_frame_desc[i].status = 0;\r\nurb->iso_frame_desc[i].actual_length = 0;\r\n}\r\nurb->status = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (urb->status) {\r\ncx231xx_isocdbg("urb resubmit failed (error=%i)\n",\r\nurb->status);\r\n}\r\n}\r\nstatic void cx231xx_bulk_irq_callback(struct urb *urb)\r\n{\r\nstruct cx231xx_dmaqueue *dma_q = urb->context;\r\nstruct cx231xx_video_mode *vmode =\r\ncontainer_of(dma_q, struct cx231xx_video_mode, vidq);\r\nstruct cx231xx *dev = container_of(vmode, struct cx231xx, video_mode);\r\nswitch (urb->status) {\r\ncase 0:\r\ncase -ETIMEDOUT:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ncx231xx_isocdbg("urb completition error %d.\n", urb->status);\r\nbreak;\r\n}\r\nspin_lock(&dev->video_mode.slock);\r\ndev->video_mode.bulk_ctl.bulk_copy(dev, urb);\r\nspin_unlock(&dev->video_mode.slock);\r\nurb->status = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (urb->status) {\r\ncx231xx_isocdbg("urb resubmit failed (error=%i)\n",\r\nurb->status);\r\n}\r\n}\r\nvoid cx231xx_uninit_isoc(struct cx231xx *dev)\r\n{\r\nstruct cx231xx_dmaqueue *dma_q = &dev->video_mode.vidq;\r\nstruct urb *urb;\r\nint i;\r\ncx231xx_isocdbg("cx231xx: called cx231xx_uninit_isoc\n");\r\ndev->video_mode.isoc_ctl.nfields = -1;\r\nfor (i = 0; i < dev->video_mode.isoc_ctl.num_bufs; i++) {\r\nurb = dev->video_mode.isoc_ctl.urb[i];\r\nif (urb) {\r\nif (!irqs_disabled())\r\nusb_kill_urb(urb);\r\nelse\r\nusb_unlink_urb(urb);\r\nif (dev->video_mode.isoc_ctl.transfer_buffer[i]) {\r\nusb_free_coherent(dev->udev,\r\nurb->transfer_buffer_length,\r\ndev->video_mode.isoc_ctl.\r\ntransfer_buffer[i],\r\nurb->transfer_dma);\r\n}\r\nusb_free_urb(urb);\r\ndev->video_mode.isoc_ctl.urb[i] = NULL;\r\n}\r\ndev->video_mode.isoc_ctl.transfer_buffer[i] = NULL;\r\n}\r\nkfree(dev->video_mode.isoc_ctl.urb);\r\nkfree(dev->video_mode.isoc_ctl.transfer_buffer);\r\nkfree(dma_q->p_left_data);\r\ndev->video_mode.isoc_ctl.urb = NULL;\r\ndev->video_mode.isoc_ctl.transfer_buffer = NULL;\r\ndev->video_mode.isoc_ctl.num_bufs = 0;\r\ndma_q->p_left_data = NULL;\r\nif (dev->mode_tv == 0)\r\ncx231xx_capture_start(dev, 0, Raw_Video);\r\nelse\r\ncx231xx_capture_start(dev, 0, TS1_serial_mode);\r\n}\r\nvoid cx231xx_uninit_bulk(struct cx231xx *dev)\r\n{\r\nstruct urb *urb;\r\nint i;\r\ncx231xx_isocdbg("cx231xx: called cx231xx_uninit_bulk\n");\r\ndev->video_mode.bulk_ctl.nfields = -1;\r\nfor (i = 0; i < dev->video_mode.bulk_ctl.num_bufs; i++) {\r\nurb = dev->video_mode.bulk_ctl.urb[i];\r\nif (urb) {\r\nif (!irqs_disabled())\r\nusb_kill_urb(urb);\r\nelse\r\nusb_unlink_urb(urb);\r\nif (dev->video_mode.bulk_ctl.transfer_buffer[i]) {\r\nusb_free_coherent(dev->udev,\r\nurb->transfer_buffer_length,\r\ndev->video_mode.isoc_ctl.\r\ntransfer_buffer[i],\r\nurb->transfer_dma);\r\n}\r\nusb_free_urb(urb);\r\ndev->video_mode.bulk_ctl.urb[i] = NULL;\r\n}\r\ndev->video_mode.bulk_ctl.transfer_buffer[i] = NULL;\r\n}\r\nkfree(dev->video_mode.bulk_ctl.urb);\r\nkfree(dev->video_mode.bulk_ctl.transfer_buffer);\r\ndev->video_mode.bulk_ctl.urb = NULL;\r\ndev->video_mode.bulk_ctl.transfer_buffer = NULL;\r\ndev->video_mode.bulk_ctl.num_bufs = 0;\r\nif (dev->mode_tv == 0)\r\ncx231xx_capture_start(dev, 0, Raw_Video);\r\nelse\r\ncx231xx_capture_start(dev, 0, TS1_serial_mode);\r\n}\r\nint cx231xx_init_isoc(struct cx231xx *dev, int max_packets,\r\nint num_bufs, int max_pkt_size,\r\nint (*isoc_copy) (struct cx231xx *dev, struct urb *urb))\r\n{\r\nstruct cx231xx_dmaqueue *dma_q = &dev->video_mode.vidq;\r\nint i;\r\nint sb_size, pipe;\r\nstruct urb *urb;\r\nint j, k;\r\nint rc;\r\ncx231xx_uninit_isoc(dev);\r\ndma_q->p_left_data = kzalloc(4096, GFP_KERNEL);\r\nif (dma_q->p_left_data == NULL)\r\nreturn -ENOMEM;\r\ndev->video_mode.isoc_ctl.isoc_copy = isoc_copy;\r\ndev->video_mode.isoc_ctl.num_bufs = num_bufs;\r\ndma_q->pos = 0;\r\ndma_q->is_partial_line = 0;\r\ndma_q->last_sav = 0;\r\ndma_q->current_field = -1;\r\ndma_q->field1_done = 0;\r\ndma_q->lines_per_field = dev->height / 2;\r\ndma_q->bytes_left_in_line = dev->width << 1;\r\ndma_q->lines_completed = 0;\r\ndma_q->mpeg_buffer_done = 0;\r\ndma_q->left_data_count = 0;\r\ndma_q->mpeg_buffer_completed = 0;\r\ndma_q->add_ps_package_head = CX231XX_NEED_ADD_PS_PACKAGE_HEAD;\r\ndma_q->ps_head[0] = 0x00;\r\ndma_q->ps_head[1] = 0x00;\r\ndma_q->ps_head[2] = 0x01;\r\ndma_q->ps_head[3] = 0xBA;\r\nfor (i = 0; i < 8; i++)\r\ndma_q->partial_buf[i] = 0;\r\ndev->video_mode.isoc_ctl.urb =\r\nkzalloc(sizeof(void *) * num_bufs, GFP_KERNEL);\r\nif (!dev->video_mode.isoc_ctl.urb) {\r\ndev_err(dev->dev,\r\n"cannot alloc memory for usb buffers\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->video_mode.isoc_ctl.transfer_buffer =\r\nkzalloc(sizeof(void *) * num_bufs, GFP_KERNEL);\r\nif (!dev->video_mode.isoc_ctl.transfer_buffer) {\r\ndev_err(dev->dev,\r\n"cannot allocate memory for usbtransfer\n");\r\nkfree(dev->video_mode.isoc_ctl.urb);\r\nreturn -ENOMEM;\r\n}\r\ndev->video_mode.isoc_ctl.max_pkt_size = max_pkt_size;\r\ndev->video_mode.isoc_ctl.buf = NULL;\r\nsb_size = max_packets * dev->video_mode.isoc_ctl.max_pkt_size;\r\nif (dev->mode_tv == 1)\r\ndev->video_mode.end_point_addr = 0x81;\r\nelse\r\ndev->video_mode.end_point_addr = 0x84;\r\nfor (i = 0; i < dev->video_mode.isoc_ctl.num_bufs; i++) {\r\nurb = usb_alloc_urb(max_packets, GFP_KERNEL);\r\nif (!urb) {\r\ndev_err(dev->dev,\r\n"cannot alloc isoc_ctl.urb %i\n", i);\r\ncx231xx_uninit_isoc(dev);\r\nreturn -ENOMEM;\r\n}\r\ndev->video_mode.isoc_ctl.urb[i] = urb;\r\ndev->video_mode.isoc_ctl.transfer_buffer[i] =\r\nusb_alloc_coherent(dev->udev, sb_size, GFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (!dev->video_mode.isoc_ctl.transfer_buffer[i]) {\r\ndev_err(dev->dev,\r\n"unable to allocate %i bytes for transfer buffer %i%s\n",\r\nsb_size, i,\r\nin_interrupt() ? " while in int" : "");\r\ncx231xx_uninit_isoc(dev);\r\nreturn -ENOMEM;\r\n}\r\nmemset(dev->video_mode.isoc_ctl.transfer_buffer[i], 0, sb_size);\r\npipe =\r\nusb_rcvisocpipe(dev->udev, dev->video_mode.end_point_addr);\r\nusb_fill_int_urb(urb, dev->udev, pipe,\r\ndev->video_mode.isoc_ctl.transfer_buffer[i],\r\nsb_size, cx231xx_isoc_irq_callback, dma_q, 1);\r\nurb->number_of_packets = max_packets;\r\nurb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\r\nk = 0;\r\nfor (j = 0; j < max_packets; j++) {\r\nurb->iso_frame_desc[j].offset = k;\r\nurb->iso_frame_desc[j].length =\r\ndev->video_mode.isoc_ctl.max_pkt_size;\r\nk += dev->video_mode.isoc_ctl.max_pkt_size;\r\n}\r\n}\r\ninit_waitqueue_head(&dma_q->wq);\r\nfor (i = 0; i < dev->video_mode.isoc_ctl.num_bufs; i++) {\r\nrc = usb_submit_urb(dev->video_mode.isoc_ctl.urb[i],\r\nGFP_ATOMIC);\r\nif (rc) {\r\ndev_err(dev->dev,\r\n"submit of urb %i failed (error=%i)\n", i,\r\nrc);\r\ncx231xx_uninit_isoc(dev);\r\nreturn rc;\r\n}\r\n}\r\nif (dev->mode_tv == 0)\r\ncx231xx_capture_start(dev, 1, Raw_Video);\r\nelse\r\ncx231xx_capture_start(dev, 1, TS1_serial_mode);\r\nreturn 0;\r\n}\r\nint cx231xx_init_bulk(struct cx231xx *dev, int max_packets,\r\nint num_bufs, int max_pkt_size,\r\nint (*bulk_copy) (struct cx231xx *dev, struct urb *urb))\r\n{\r\nstruct cx231xx_dmaqueue *dma_q = &dev->video_mode.vidq;\r\nint i;\r\nint sb_size, pipe;\r\nstruct urb *urb;\r\nint rc;\r\ndev->video_input = dev->video_input > 2 ? 2 : dev->video_input;\r\ncx231xx_coredbg("Setting Video mux to %d\n", dev->video_input);\r\nvideo_mux(dev, dev->video_input);\r\ncx231xx_uninit_bulk(dev);\r\ndev->video_mode.bulk_ctl.bulk_copy = bulk_copy;\r\ndev->video_mode.bulk_ctl.num_bufs = num_bufs;\r\ndma_q->pos = 0;\r\ndma_q->is_partial_line = 0;\r\ndma_q->last_sav = 0;\r\ndma_q->current_field = -1;\r\ndma_q->field1_done = 0;\r\ndma_q->lines_per_field = dev->height / 2;\r\ndma_q->bytes_left_in_line = dev->width << 1;\r\ndma_q->lines_completed = 0;\r\ndma_q->mpeg_buffer_done = 0;\r\ndma_q->left_data_count = 0;\r\ndma_q->mpeg_buffer_completed = 0;\r\ndma_q->ps_head[0] = 0x00;\r\ndma_q->ps_head[1] = 0x00;\r\ndma_q->ps_head[2] = 0x01;\r\ndma_q->ps_head[3] = 0xBA;\r\nfor (i = 0; i < 8; i++)\r\ndma_q->partial_buf[i] = 0;\r\ndev->video_mode.bulk_ctl.urb =\r\nkzalloc(sizeof(void *) * num_bufs, GFP_KERNEL);\r\nif (!dev->video_mode.bulk_ctl.urb) {\r\ndev_err(dev->dev,\r\n"cannot alloc memory for usb buffers\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->video_mode.bulk_ctl.transfer_buffer =\r\nkzalloc(sizeof(void *) * num_bufs, GFP_KERNEL);\r\nif (!dev->video_mode.bulk_ctl.transfer_buffer) {\r\ndev_err(dev->dev,\r\n"cannot allocate memory for usbtransfer\n");\r\nkfree(dev->video_mode.bulk_ctl.urb);\r\nreturn -ENOMEM;\r\n}\r\ndev->video_mode.bulk_ctl.max_pkt_size = max_pkt_size;\r\ndev->video_mode.bulk_ctl.buf = NULL;\r\nsb_size = max_packets * dev->video_mode.bulk_ctl.max_pkt_size;\r\nif (dev->mode_tv == 1)\r\ndev->video_mode.end_point_addr = 0x81;\r\nelse\r\ndev->video_mode.end_point_addr = 0x84;\r\nfor (i = 0; i < dev->video_mode.bulk_ctl.num_bufs; i++) {\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\ndev_err(dev->dev,\r\n"cannot alloc bulk_ctl.urb %i\n", i);\r\ncx231xx_uninit_bulk(dev);\r\nreturn -ENOMEM;\r\n}\r\ndev->video_mode.bulk_ctl.urb[i] = urb;\r\nurb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\r\ndev->video_mode.bulk_ctl.transfer_buffer[i] =\r\nusb_alloc_coherent(dev->udev, sb_size, GFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (!dev->video_mode.bulk_ctl.transfer_buffer[i]) {\r\ndev_err(dev->dev,\r\n"unable to allocate %i bytes for transfer buffer %i%s\n",\r\nsb_size, i,\r\nin_interrupt() ? " while in int" : "");\r\ncx231xx_uninit_bulk(dev);\r\nreturn -ENOMEM;\r\n}\r\nmemset(dev->video_mode.bulk_ctl.transfer_buffer[i], 0, sb_size);\r\npipe = usb_rcvbulkpipe(dev->udev,\r\ndev->video_mode.end_point_addr);\r\nusb_fill_bulk_urb(urb, dev->udev, pipe,\r\ndev->video_mode.bulk_ctl.transfer_buffer[i],\r\nsb_size, cx231xx_bulk_irq_callback, dma_q);\r\n}\r\ninit_waitqueue_head(&dma_q->wq);\r\nfor (i = 0; i < dev->video_mode.bulk_ctl.num_bufs; i++) {\r\nrc = usb_submit_urb(dev->video_mode.bulk_ctl.urb[i],\r\nGFP_ATOMIC);\r\nif (rc) {\r\ndev_err(dev->dev,\r\n"submit of urb %i failed (error=%i)\n", i, rc);\r\ncx231xx_uninit_bulk(dev);\r\nreturn rc;\r\n}\r\n}\r\nif (dev->mode_tv == 0)\r\ncx231xx_capture_start(dev, 1, Raw_Video);\r\nelse\r\ncx231xx_capture_start(dev, 1, TS1_serial_mode);\r\nreturn 0;\r\n}\r\nvoid cx231xx_stop_TS1(struct cx231xx *dev)\r\n{\r\nu8 val[4] = { 0, 0, 0, 0 };\r\nval[0] = 0x00;\r\nval[1] = 0x03;\r\nval[2] = 0x00;\r\nval[3] = 0x00;\r\ncx231xx_write_ctrl_reg(dev, VRT_SET_REGISTER,\r\nTS_MODE_REG, val, 4);\r\nval[0] = 0x00;\r\nval[1] = 0x70;\r\nval[2] = 0x04;\r\nval[3] = 0x00;\r\ncx231xx_write_ctrl_reg(dev, VRT_SET_REGISTER,\r\nTS1_CFG_REG, val, 4);\r\n}\r\nvoid cx231xx_start_TS1(struct cx231xx *dev)\r\n{\r\nu8 val[4] = { 0, 0, 0, 0 };\r\nval[0] = 0x03;\r\nval[1] = 0x03;\r\nval[2] = 0x00;\r\nval[3] = 0x00;\r\ncx231xx_write_ctrl_reg(dev, VRT_SET_REGISTER,\r\nTS_MODE_REG, val, 4);\r\nval[0] = 0x04;\r\nval[1] = 0xA3;\r\nval[2] = 0x3B;\r\nval[3] = 0x00;\r\ncx231xx_write_ctrl_reg(dev, VRT_SET_REGISTER,\r\nTS1_CFG_REG, val, 4);\r\n}\r\nint cx231xx_dev_init(struct cx231xx *dev)\r\n{\r\nint errCode = 0;\r\ndev->i2c_bus[0].nr = 0;\r\ndev->i2c_bus[0].dev = dev;\r\ndev->i2c_bus[0].i2c_period = I2C_SPEED_100K;\r\ndev->i2c_bus[0].i2c_nostop = 0;\r\ndev->i2c_bus[0].i2c_reserve = 0;\r\ndev->i2c_bus[1].nr = 1;\r\ndev->i2c_bus[1].dev = dev;\r\ndev->i2c_bus[1].i2c_period = I2C_SPEED_100K;\r\ndev->i2c_bus[1].i2c_nostop = 0;\r\ndev->i2c_bus[1].i2c_reserve = 0;\r\ndev->i2c_bus[2].nr = 2;\r\ndev->i2c_bus[2].dev = dev;\r\ndev->i2c_bus[2].i2c_period = I2C_SPEED_100K;\r\ndev->i2c_bus[2].i2c_nostop = 0;\r\ndev->i2c_bus[2].i2c_reserve = 0;\r\ncx231xx_i2c_register(&dev->i2c_bus[0]);\r\ncx231xx_i2c_register(&dev->i2c_bus[1]);\r\ncx231xx_i2c_register(&dev->i2c_bus[2]);\r\ncx231xx_i2c_mux_register(dev, 0);\r\ncx231xx_i2c_mux_register(dev, 1);\r\ncx231xx_do_i2c_scan(dev, I2C_0);\r\ncx231xx_do_i2c_scan(dev, I2C_1_MUX_1);\r\ncx231xx_do_i2c_scan(dev, I2C_2);\r\ncx231xx_do_i2c_scan(dev, I2C_1_MUX_3);\r\nif (dev->board.external_av) {\r\nerrCode = cx231xx_set_power_mode(dev,\r\nPOLARIS_AVMODE_ENXTERNAL_AV);\r\nif (errCode < 0) {\r\ndev_err(dev->dev,\r\n"%s: Failed to set Power - errCode [%d]!\n",\r\n__func__, errCode);\r\nreturn errCode;\r\n}\r\n} else {\r\nerrCode = cx231xx_set_power_mode(dev,\r\nPOLARIS_AVMODE_ANALOGT_TV);\r\nif (errCode < 0) {\r\ndev_err(dev->dev,\r\n"%s: Failed to set Power - errCode [%d]!\n",\r\n__func__, errCode);\r\nreturn errCode;\r\n}\r\n}\r\nif ((dev->board.tuner_type == TUNER_XC5000) ||\r\n(dev->board.tuner_type == TUNER_XC2028))\r\ncx231xx_gpio_set(dev, dev->board.tuner_gpio);\r\nerrCode = cx231xx_afe_init_super_block(dev, 0x23c);\r\nif (errCode < 0) {\r\ndev_err(dev->dev,\r\n"%s: cx231xx_afe init super block - errCode [%d]!\n",\r\n__func__, errCode);\r\nreturn errCode;\r\n}\r\nerrCode = cx231xx_afe_init_channels(dev);\r\nif (errCode < 0) {\r\ndev_err(dev->dev,\r\n"%s: cx231xx_afe init channels - errCode [%d]!\n",\r\n__func__, errCode);\r\nreturn errCode;\r\n}\r\nerrCode = cx231xx_dif_set_standard(dev, DIF_USE_BASEBAND);\r\nif (errCode < 0) {\r\ndev_err(dev->dev,\r\n"%s: cx231xx_dif set to By pass mode - errCode [%d]!\n",\r\n__func__, errCode);\r\nreturn errCode;\r\n}\r\nerrCode = cx231xx_i2s_blk_initialize(dev);\r\nif (errCode < 0) {\r\ndev_err(dev->dev,\r\n"%s: cx231xx_i2s block initialize - errCode [%d]!\n",\r\n__func__, errCode);\r\nreturn errCode;\r\n}\r\nerrCode = cx231xx_init_ctrl_pin_status(dev);\r\nif (errCode < 0) {\r\ndev_err(dev->dev,\r\n"%s: cx231xx_init ctrl pins - errCode [%d]!\n",\r\n__func__, errCode);\r\nreturn errCode;\r\n}\r\nswitch (dev->model) {\r\ncase CX231XX_BOARD_CNXT_CARRAERA:\r\ncase CX231XX_BOARD_CNXT_RDE_250:\r\ncase CX231XX_BOARD_CNXT_SHELBY:\r\ncase CX231XX_BOARD_CNXT_RDU_250:\r\nerrCode = cx231xx_set_agc_analog_digital_mux_select(dev, 1);\r\nbreak;\r\ncase CX231XX_BOARD_CNXT_RDE_253S:\r\ncase CX231XX_BOARD_CNXT_RDU_253S:\r\ncase CX231XX_BOARD_HAUPPAUGE_EXETER:\r\ncase CX231XX_BOARD_HAUPPAUGE_930C_HD_1113xx:\r\ncase CX231XX_BOARD_PV_PLAYTV_USB_HYBRID:\r\ncase CX231XX_BOARD_HAUPPAUGE_USB2_FM_PAL:\r\ncase CX231XX_BOARD_HAUPPAUGE_USB2_FM_NTSC:\r\nerrCode = cx231xx_set_agc_analog_digital_mux_select(dev, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (errCode < 0) {\r\ndev_err(dev->dev,\r\n"%s: cx231xx_AGC mode to Analog - errCode [%d]!\n",\r\n__func__, errCode);\r\nreturn errCode;\r\n}\r\ncx231xx_set_alt_setting(dev, INDEX_VIDEO, 0);\r\ncx231xx_set_alt_setting(dev, INDEX_VANC, 0);\r\ncx231xx_set_alt_setting(dev, INDEX_HANC, 0);\r\nif (dev->board.has_dvb)\r\ncx231xx_set_alt_setting(dev, INDEX_TS1, 0);\r\nerrCode = 0;\r\nreturn errCode;\r\n}\r\nvoid cx231xx_dev_uninit(struct cx231xx *dev)\r\n{\r\ncx231xx_i2c_mux_unregister(dev, 1);\r\ncx231xx_i2c_mux_unregister(dev, 0);\r\ncx231xx_i2c_unregister(&dev->i2c_bus[2]);\r\ncx231xx_i2c_unregister(&dev->i2c_bus[1]);\r\ncx231xx_i2c_unregister(&dev->i2c_bus[0]);\r\n}\r\nint cx231xx_send_gpio_cmd(struct cx231xx *dev, u32 gpio_bit, u8 *gpio_val,\r\nu8 len, u8 request, u8 direction)\r\n{\r\nint status = 0;\r\nstruct VENDOR_REQUEST_IN ven_req;\r\nven_req.wValue = (u16) (gpio_bit >> 16 & 0xffff);\r\nif (!request) {\r\nif (direction)\r\nven_req.bRequest = VRT_GET_GPIO;\r\nelse\r\nven_req.bRequest = VRT_SET_GPIO;\r\n} else {\r\nif (direction)\r\nven_req.bRequest = VRT_GET_GPIE;\r\nelse\r\nven_req.bRequest = VRT_SET_GPIE;\r\n}\r\nven_req.wIndex = (u16) (gpio_bit & 0xffff);\r\nven_req.wLength = len;\r\nven_req.bData = 0;\r\nven_req.pBuff = gpio_val;\r\nif (direction) {\r\nven_req.direction = USB_DIR_IN;\r\nmemset(ven_req.pBuff, 0x00, ven_req.wLength);\r\n} else\r\nven_req.direction = USB_DIR_OUT;\r\nstatus = cx231xx_send_vendor_cmd(dev, &ven_req);\r\nif (status < 0) {\r\ndev_err(dev->dev, "%s: failed with status -%d\n",\r\n__func__, status);\r\n}\r\nreturn status;\r\n}\r\nint cx231xx_mode_register(struct cx231xx *dev, u16 address, u32 mode)\r\n{\r\nu8 value[4] = { 0x0, 0x0, 0x0, 0x0 };\r\nu32 tmp = 0;\r\nint status = 0;\r\nstatus =\r\ncx231xx_read_ctrl_reg(dev, VRT_GET_REGISTER, address, value, 4);\r\nif (status < 0)\r\nreturn status;\r\ntmp = le32_to_cpu(*((__le32 *) value));\r\ntmp |= mode;\r\nvalue[0] = (u8) tmp;\r\nvalue[1] = (u8) (tmp >> 8);\r\nvalue[2] = (u8) (tmp >> 16);\r\nvalue[3] = (u8) (tmp >> 24);\r\nstatus =\r\ncx231xx_write_ctrl_reg(dev, VRT_SET_REGISTER, address, value, 4);\r\nreturn status;\r\n}\r\nint cx231xx_read_i2c_master(struct cx231xx *dev, u8 dev_addr, u16 saddr,\r\nu8 saddr_len, u32 *data, u8 data_len, int master)\r\n{\r\nint status = 0;\r\nstruct cx231xx_i2c_xfer_data req_data;\r\nu8 value[64] = "0";\r\nif (saddr_len == 0)\r\nsaddr = 0;\r\nelse if (saddr_len == 1)\r\nsaddr &= 0xff;\r\nreq_data.dev_addr = dev_addr >> 1;\r\nreq_data.direction = I2C_M_RD;\r\nreq_data.saddr_len = saddr_len;\r\nreq_data.saddr_dat = saddr;\r\nreq_data.buf_size = data_len;\r\nreq_data.p_buffer = (u8 *) value;\r\nif (master == 0)\r\nstatus = dev->cx231xx_send_usb_command(&dev->i2c_bus[0],\r\n&req_data);\r\nelse if (master == 1)\r\nstatus = dev->cx231xx_send_usb_command(&dev->i2c_bus[1],\r\n&req_data);\r\nelse if (master == 2)\r\nstatus = dev->cx231xx_send_usb_command(&dev->i2c_bus[2],\r\n&req_data);\r\nif (status >= 0) {\r\nif (data_len == 1)\r\n*data = value[0];\r\nelse if (data_len == 4)\r\n*data =\r\nvalue[0] | value[1] << 8 | value[2] << 16 | value[3]\r\n<< 24;\r\nelse if (data_len > 4)\r\n*data = value[saddr];\r\n}\r\nreturn status;\r\n}\r\nint cx231xx_write_i2c_master(struct cx231xx *dev, u8 dev_addr, u16 saddr,\r\nu8 saddr_len, u32 data, u8 data_len, int master)\r\n{\r\nint status = 0;\r\nu8 value[4] = { 0, 0, 0, 0 };\r\nstruct cx231xx_i2c_xfer_data req_data;\r\nvalue[0] = (u8) data;\r\nvalue[1] = (u8) (data >> 8);\r\nvalue[2] = (u8) (data >> 16);\r\nvalue[3] = (u8) (data >> 24);\r\nif (saddr_len == 0)\r\nsaddr = 0;\r\nelse if (saddr_len == 1)\r\nsaddr &= 0xff;\r\nreq_data.dev_addr = dev_addr >> 1;\r\nreq_data.direction = 0;\r\nreq_data.saddr_len = saddr_len;\r\nreq_data.saddr_dat = saddr;\r\nreq_data.buf_size = data_len;\r\nreq_data.p_buffer = value;\r\nif (master == 0)\r\nstatus = dev->cx231xx_send_usb_command(&dev->i2c_bus[0],\r\n&req_data);\r\nelse if (master == 1)\r\nstatus = dev->cx231xx_send_usb_command(&dev->i2c_bus[1],\r\n&req_data);\r\nelse if (master == 2)\r\nstatus = dev->cx231xx_send_usb_command(&dev->i2c_bus[2],\r\n&req_data);\r\nreturn status;\r\n}\r\nint cx231xx_read_i2c_data(struct cx231xx *dev, u8 dev_addr, u16 saddr,\r\nu8 saddr_len, u32 *data, u8 data_len)\r\n{\r\nint status = 0;\r\nstruct cx231xx_i2c_xfer_data req_data;\r\nu8 value[4] = { 0, 0, 0, 0 };\r\nif (saddr_len == 0)\r\nsaddr = 0;\r\nelse if (saddr_len == 1)\r\nsaddr &= 0xff;\r\nreq_data.dev_addr = dev_addr >> 1;\r\nreq_data.direction = I2C_M_RD;\r\nreq_data.saddr_len = saddr_len;\r\nreq_data.saddr_dat = saddr;\r\nreq_data.buf_size = data_len;\r\nreq_data.p_buffer = (u8 *) value;\r\nstatus = dev->cx231xx_send_usb_command(&dev->i2c_bus[0], &req_data);\r\nif (status >= 0) {\r\nif (data_len == 1)\r\n*data = value[0];\r\nelse\r\n*data =\r\nvalue[0] | value[1] << 8 | value[2] << 16 | value[3]\r\n<< 24;\r\n}\r\nreturn status;\r\n}\r\nint cx231xx_write_i2c_data(struct cx231xx *dev, u8 dev_addr, u16 saddr,\r\nu8 saddr_len, u32 data, u8 data_len)\r\n{\r\nint status = 0;\r\nu8 value[4] = { 0, 0, 0, 0 };\r\nstruct cx231xx_i2c_xfer_data req_data;\r\nvalue[0] = (u8) data;\r\nvalue[1] = (u8) (data >> 8);\r\nvalue[2] = (u8) (data >> 16);\r\nvalue[3] = (u8) (data >> 24);\r\nif (saddr_len == 0)\r\nsaddr = 0;\r\nelse if (saddr_len == 1)\r\nsaddr &= 0xff;\r\nreq_data.dev_addr = dev_addr >> 1;\r\nreq_data.direction = 0;\r\nreq_data.saddr_len = saddr_len;\r\nreq_data.saddr_dat = saddr;\r\nreq_data.buf_size = data_len;\r\nreq_data.p_buffer = value;\r\nstatus = dev->cx231xx_send_usb_command(&dev->i2c_bus[0], &req_data);\r\nreturn status;\r\n}\r\nint cx231xx_reg_mask_write(struct cx231xx *dev, u8 dev_addr, u8 size,\r\nu16 register_address, u8 bit_start, u8 bit_end,\r\nu32 value)\r\n{\r\nint status = 0;\r\nu32 tmp;\r\nu32 mask = 0;\r\nint i;\r\nif (bit_start > (size - 1) || bit_end > (size - 1))\r\nreturn -1;\r\nif (size == 8) {\r\nstatus =\r\ncx231xx_read_i2c_data(dev, dev_addr, register_address, 2,\r\n&tmp, 1);\r\n} else {\r\nstatus =\r\ncx231xx_read_i2c_data(dev, dev_addr, register_address, 2,\r\n&tmp, 4);\r\n}\r\nif (status < 0)\r\nreturn status;\r\nmask = 1 << bit_end;\r\nfor (i = bit_end; i > bit_start && i > 0; i--)\r\nmask = mask + (1 << (i - 1));\r\nvalue <<= bit_start;\r\nif (size == 8) {\r\ntmp &= ~mask;\r\ntmp |= value;\r\ntmp &= 0xff;\r\nstatus =\r\ncx231xx_write_i2c_data(dev, dev_addr, register_address, 2,\r\ntmp, 1);\r\n} else {\r\ntmp &= ~mask;\r\ntmp |= value;\r\nstatus =\r\ncx231xx_write_i2c_data(dev, dev_addr, register_address, 2,\r\ntmp, 4);\r\n}\r\nreturn status;\r\n}\r\nint cx231xx_read_modify_write_i2c_dword(struct cx231xx *dev, u8 dev_addr,\r\nu16 saddr, u32 mask, u32 value)\r\n{\r\nu32 temp;\r\nint status = 0;\r\nstatus = cx231xx_read_i2c_data(dev, dev_addr, saddr, 2, &temp, 4);\r\nif (status < 0)\r\nreturn status;\r\ntemp &= ~mask;\r\ntemp |= value;\r\nstatus = cx231xx_write_i2c_data(dev, dev_addr, saddr, 2, temp, 4);\r\nreturn status;\r\n}\r\nu32 cx231xx_set_field(u32 field_mask, u32 data)\r\n{\r\nu32 temp;\r\nfor (temp = field_mask; (temp & 1) == 0; temp >>= 1)\r\ndata <<= 1;\r\nreturn data;\r\n}
