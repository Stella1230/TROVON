static void __init mvebu_scu_enable(void)\r\n{\r\nstruct device_node *np =\r\nof_find_compatible_node(NULL, NULL, "arm,cortex-a9-scu");\r\nif (np) {\r\nscu_base = of_iomap(np, 0);\r\nscu_enable(scu_base);\r\nof_node_put(np);\r\n}\r\n}\r\nvoid __iomem *mvebu_get_scu_base(void)\r\n{\r\nreturn scu_base;\r\n}\r\nstatic int __init mvebu_scan_mem(unsigned long node, const char *uname,\r\nint depth, void *data)\r\n{\r\nconst char *type = of_get_flat_dt_prop(node, "device_type", NULL);\r\nconst __be32 *reg, *endp;\r\nint l;\r\nif (type == NULL || strcmp(type, "memory"))\r\nreturn 0;\r\nreg = of_get_flat_dt_prop(node, "linux,usable-memory", &l);\r\nif (reg == NULL)\r\nreg = of_get_flat_dt_prop(node, "reg", &l);\r\nif (reg == NULL)\r\nreturn 0;\r\nendp = reg + (l / sizeof(__be32));\r\nwhile ((endp - reg) >= (dt_root_addr_cells + dt_root_size_cells)) {\r\nu64 base, size;\r\nbase = dt_mem_next_cell(dt_root_addr_cells, &reg);\r\nsize = dt_mem_next_cell(dt_root_size_cells, &reg);\r\nmemblock_reserve(base, MVEBU_DDR_TRAINING_AREA_SZ);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init mvebu_memblock_reserve(void)\r\n{\r\nof_scan_flat_dt(mvebu_scan_mem, NULL);\r\n}\r\nstatic void __init mvebu_memblock_reserve(void) {}\r\nstatic int armada_375_external_abort_wa(unsigned long addr, unsigned int fsr,\r\nstruct pt_regs *regs)\r\n{\r\nstatic int ignore_first;\r\nif (!ignore_first && fsr == 0x1406) {\r\nignore_first = 1;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void __init mvebu_init_irq(void)\r\n{\r\nirqchip_init();\r\nmvebu_scu_enable();\r\ncoherency_init();\r\nBUG_ON(mvebu_mbus_dt_init(coherency_available()));\r\n}\r\nstatic void __init external_abort_quirk(void)\r\n{\r\nu32 dev, rev;\r\nif (mvebu_get_soc_id(&dev, &rev) == 0 && rev > ARMADA_375_Z1_REV)\r\nreturn;\r\nhook_fault_code(16 + 6, armada_375_external_abort_wa, SIGBUS, 0,\r\n"imprecise external abort");\r\n}\r\nstatic void __init i2c_quirk(void)\r\n{\r\nstruct device_node *np;\r\nu32 dev, rev;\r\nif (mvebu_get_soc_id(&dev, &rev) == 0 && rev > MV78XX0_A0_REV)\r\nreturn;\r\nfor_each_compatible_node(np, NULL, "marvell,mv78230-i2c") {\r\nstruct property *new_compat;\r\nnew_compat = kzalloc(sizeof(*new_compat), GFP_KERNEL);\r\nnew_compat->name = kstrdup("compatible", GFP_KERNEL);\r\nnew_compat->length = sizeof("marvell,mv78230-a0-i2c");\r\nnew_compat->value = kstrdup("marvell,mv78230-a0-i2c",\r\nGFP_KERNEL);\r\nof_update_property(np, new_compat);\r\n}\r\nreturn;\r\n}\r\nstatic void __init mvebu_dt_init(void)\r\n{\r\nif (of_machine_is_compatible("marvell,armadaxp"))\r\ni2c_quirk();\r\nif (of_machine_is_compatible("marvell,a375-db"))\r\nexternal_abort_quirk();\r\nof_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);\r\n}
