static void lov_init_set(struct lov_request_set *set)\r\n{\r\nset->set_count = 0;\r\natomic_set(&set->set_completes, 0);\r\natomic_set(&set->set_success, 0);\r\natomic_set(&set->set_finish_checked, 0);\r\nset->set_cookies = NULL;\r\nINIT_LIST_HEAD(&set->set_list);\r\natomic_set(&set->set_refcount, 1);\r\ninit_waitqueue_head(&set->set_waitq);\r\nspin_lock_init(&set->set_lock);\r\n}\r\nvoid lov_finish_set(struct lov_request_set *set)\r\n{\r\nstruct list_head *pos, *n;\r\nLASSERT(set);\r\nlist_for_each_safe(pos, n, &set->set_list) {\r\nstruct lov_request *req = list_entry(pos,\r\nstruct lov_request,\r\nrq_link);\r\nlist_del_init(&req->rq_link);\r\nif (req->rq_oi.oi_oa)\r\nOBDO_FREE(req->rq_oi.oi_oa);\r\nif (req->rq_oi.oi_md)\r\nOBD_FREE_LARGE(req->rq_oi.oi_md, req->rq_buflen);\r\nif (req->rq_oi.oi_osfs)\r\nOBD_FREE(req->rq_oi.oi_osfs,\r\nsizeof(*req->rq_oi.oi_osfs));\r\nOBD_FREE(req, sizeof(*req));\r\n}\r\nif (set->set_pga) {\r\nint len = set->set_oabufs * sizeof(*set->set_pga);\r\nOBD_FREE_LARGE(set->set_pga, len);\r\n}\r\nif (set->set_lockh)\r\nlov_llh_put(set->set_lockh);\r\nOBD_FREE(set, sizeof(*set));\r\n}\r\nint lov_set_finished(struct lov_request_set *set, int idempotent)\r\n{\r\nint completes = atomic_read(&set->set_completes);\r\nCDEBUG(D_INFO, "check set %d/%d\n", completes, set->set_count);\r\nif (completes == set->set_count) {\r\nif (idempotent)\r\nreturn 1;\r\nif (atomic_inc_return(&set->set_finish_checked) == 1)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid lov_update_set(struct lov_request_set *set,\r\nstruct lov_request *req, int rc)\r\n{\r\nreq->rq_complete = 1;\r\nreq->rq_rc = rc;\r\natomic_inc(&set->set_completes);\r\nif (rc == 0)\r\natomic_inc(&set->set_success);\r\nwake_up(&set->set_waitq);\r\n}\r\nint lov_update_common_set(struct lov_request_set *set,\r\nstruct lov_request *req, int rc)\r\n{\r\nstruct lov_obd *lov = &set->set_exp->exp_obd->u.lov;\r\nlov_update_set(set, req, rc);\r\nif (rc && !(lov->lov_tgts[req->rq_idx] &&\r\nlov->lov_tgts[req->rq_idx]->ltd_active))\r\nrc = 0;\r\nreturn rc;\r\n}\r\nvoid lov_set_add_req(struct lov_request *req, struct lov_request_set *set)\r\n{\r\nlist_add_tail(&req->rq_link, &set->set_list);\r\nset->set_count++;\r\nreq->rq_rqset = set;\r\n}\r\nstatic int lov_check_set(struct lov_obd *lov, int idx)\r\n{\r\nint rc;\r\nstruct lov_tgt_desc *tgt;\r\nmutex_lock(&lov->lov_lock);\r\ntgt = lov->lov_tgts[idx];\r\nrc = !tgt || tgt->ltd_active ||\r\n(tgt->ltd_exp &&\r\nclass_exp2cliimp(tgt->ltd_exp)->imp_connect_tried);\r\nmutex_unlock(&lov->lov_lock);\r\nreturn rc;\r\n}\r\nint lov_check_and_wait_active(struct lov_obd *lov, int ost_idx)\r\n{\r\nwait_queue_head_t waitq;\r\nstruct l_wait_info lwi;\r\nstruct lov_tgt_desc *tgt;\r\nint rc = 0;\r\nmutex_lock(&lov->lov_lock);\r\ntgt = lov->lov_tgts[ost_idx];\r\nif (unlikely(tgt == NULL)) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nif (likely(tgt->ltd_active)) {\r\nrc = 1;\r\ngoto out;\r\n}\r\nif (tgt->ltd_exp && class_exp2cliimp(tgt->ltd_exp)->imp_connect_tried) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nmutex_unlock(&lov->lov_lock);\r\ninit_waitqueue_head(&waitq);\r\nlwi = LWI_TIMEOUT_INTERVAL(cfs_time_seconds(obd_timeout),\r\ncfs_time_seconds(1), NULL, NULL);\r\nrc = l_wait_event(waitq, lov_check_set(lov, ost_idx), &lwi);\r\nif (tgt != NULL && tgt->ltd_active)\r\nreturn 1;\r\nreturn 0;\r\nout:\r\nmutex_unlock(&lov->lov_lock);\r\nreturn rc;\r\n}\r\nstatic int common_attr_done(struct lov_request_set *set)\r\n{\r\nstruct list_head *pos;\r\nstruct lov_request *req;\r\nstruct obdo *tmp_oa;\r\nint rc = 0, attrset = 0;\r\nLASSERT(set->set_oi != NULL);\r\nif (set->set_oi->oi_oa == NULL)\r\nreturn 0;\r\nif (!atomic_read(&set->set_success))\r\nreturn -EIO;\r\nOBDO_ALLOC(tmp_oa);\r\nif (tmp_oa == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nlist_for_each(pos, &set->set_list) {\r\nreq = list_entry(pos, struct lov_request, rq_link);\r\nif (!req->rq_complete || req->rq_rc)\r\ncontinue;\r\nif (req->rq_oi.oi_oa->o_valid == 0)\r\ncontinue;\r\nlov_merge_attrs(tmp_oa, req->rq_oi.oi_oa,\r\nreq->rq_oi.oi_oa->o_valid,\r\nset->set_oi->oi_md, req->rq_stripe, &attrset);\r\n}\r\nif (!attrset) {\r\nCERROR("No stripes had valid attrs\n");\r\nrc = -EIO;\r\n}\r\nif ((set->set_oi->oi_oa->o_valid & OBD_MD_FLEPOCH) &&\r\n(set->set_oi->oi_md->lsm_stripe_count != attrset)) {\r\nCERROR("Not all the stripes had valid attrs\n");\r\nrc = -EIO;\r\ngoto out;\r\n}\r\ntmp_oa->o_oi = set->set_oi->oi_oa->o_oi;\r\nmemcpy(set->set_oi->oi_oa, tmp_oa, sizeof(*set->set_oi->oi_oa));\r\nout:\r\nif (tmp_oa)\r\nOBDO_FREE(tmp_oa);\r\nreturn rc;\r\n}\r\nint lov_fini_getattr_set(struct lov_request_set *set)\r\n{\r\nint rc = 0;\r\nif (set == NULL)\r\nreturn 0;\r\nLASSERT(set->set_exp);\r\nif (atomic_read(&set->set_completes))\r\nrc = common_attr_done(set);\r\nlov_put_reqset(set);\r\nreturn rc;\r\n}\r\nstatic int cb_getattr_update(void *cookie, int rc)\r\n{\r\nstruct obd_info *oinfo = cookie;\r\nstruct lov_request *lovreq;\r\nlovreq = container_of(oinfo, struct lov_request, rq_oi);\r\nreturn lov_update_common_set(lovreq->rq_rqset, lovreq, rc);\r\n}\r\nint lov_prep_getattr_set(struct obd_export *exp, struct obd_info *oinfo,\r\nstruct lov_request_set **reqset)\r\n{\r\nstruct lov_request_set *set;\r\nstruct lov_obd *lov = &exp->exp_obd->u.lov;\r\nint rc = 0, i;\r\nOBD_ALLOC(set, sizeof(*set));\r\nif (set == NULL)\r\nreturn -ENOMEM;\r\nlov_init_set(set);\r\nset->set_exp = exp;\r\nset->set_oi = oinfo;\r\nfor (i = 0; i < oinfo->oi_md->lsm_stripe_count; i++) {\r\nstruct lov_oinfo *loi;\r\nstruct lov_request *req;\r\nloi = oinfo->oi_md->lsm_oinfo[i];\r\nif (!lov_check_and_wait_active(lov, loi->loi_ost_idx)) {\r\nCDEBUG(D_HA, "lov idx %d inactive\n", loi->loi_ost_idx);\r\nif (oinfo->oi_oa->o_valid & OBD_MD_FLEPOCH) {\r\nrc = -EIO;\r\ngoto out_set;\r\n}\r\ncontinue;\r\n}\r\nOBD_ALLOC(req, sizeof(*req));\r\nif (req == NULL) {\r\nrc = -ENOMEM;\r\ngoto out_set;\r\n}\r\nreq->rq_stripe = i;\r\nreq->rq_idx = loi->loi_ost_idx;\r\nOBDO_ALLOC(req->rq_oi.oi_oa);\r\nif (req->rq_oi.oi_oa == NULL) {\r\nOBD_FREE(req, sizeof(*req));\r\nrc = -ENOMEM;\r\ngoto out_set;\r\n}\r\nmemcpy(req->rq_oi.oi_oa, oinfo->oi_oa,\r\nsizeof(*req->rq_oi.oi_oa));\r\nreq->rq_oi.oi_oa->o_oi = loi->loi_oi;\r\nreq->rq_oi.oi_cb_up = cb_getattr_update;\r\nreq->rq_oi.oi_capa = oinfo->oi_capa;\r\nlov_set_add_req(req, set);\r\n}\r\nif (!set->set_count) {\r\nrc = -EIO;\r\ngoto out_set;\r\n}\r\n*reqset = set;\r\nreturn rc;\r\nout_set:\r\nlov_fini_getattr_set(set);\r\nreturn rc;\r\n}\r\nint lov_fini_destroy_set(struct lov_request_set *set)\r\n{\r\nif (set == NULL)\r\nreturn 0;\r\nLASSERT(set->set_exp);\r\nif (atomic_read(&set->set_completes)) {\r\n}\r\nlov_put_reqset(set);\r\nreturn 0;\r\n}\r\nint lov_prep_destroy_set(struct obd_export *exp, struct obd_info *oinfo,\r\nstruct obdo *src_oa, struct lov_stripe_md *lsm,\r\nstruct obd_trans_info *oti,\r\nstruct lov_request_set **reqset)\r\n{\r\nstruct lov_request_set *set;\r\nstruct lov_obd *lov = &exp->exp_obd->u.lov;\r\nint rc = 0, i;\r\nOBD_ALLOC(set, sizeof(*set));\r\nif (set == NULL)\r\nreturn -ENOMEM;\r\nlov_init_set(set);\r\nset->set_exp = exp;\r\nset->set_oi = oinfo;\r\nset->set_oi->oi_md = lsm;\r\nset->set_oi->oi_oa = src_oa;\r\nset->set_oti = oti;\r\nif (oti != NULL && src_oa->o_valid & OBD_MD_FLCOOKIE)\r\nset->set_cookies = oti->oti_logcookies;\r\nfor (i = 0; i < lsm->lsm_stripe_count; i++) {\r\nstruct lov_oinfo *loi;\r\nstruct lov_request *req;\r\nloi = lsm->lsm_oinfo[i];\r\nif (!lov_check_and_wait_active(lov, loi->loi_ost_idx)) {\r\nCDEBUG(D_HA, "lov idx %d inactive\n", loi->loi_ost_idx);\r\ncontinue;\r\n}\r\nOBD_ALLOC(req, sizeof(*req));\r\nif (req == NULL) {\r\nrc = -ENOMEM;\r\ngoto out_set;\r\n}\r\nreq->rq_stripe = i;\r\nreq->rq_idx = loi->loi_ost_idx;\r\nOBDO_ALLOC(req->rq_oi.oi_oa);\r\nif (req->rq_oi.oi_oa == NULL) {\r\nOBD_FREE(req, sizeof(*req));\r\nrc = -ENOMEM;\r\ngoto out_set;\r\n}\r\nmemcpy(req->rq_oi.oi_oa, src_oa, sizeof(*req->rq_oi.oi_oa));\r\nreq->rq_oi.oi_oa->o_oi = loi->loi_oi;\r\nlov_set_add_req(req, set);\r\n}\r\nif (!set->set_count) {\r\nrc = -EIO;\r\ngoto out_set;\r\n}\r\n*reqset = set;\r\nreturn rc;\r\nout_set:\r\nlov_fini_destroy_set(set);\r\nreturn rc;\r\n}\r\nint lov_fini_setattr_set(struct lov_request_set *set)\r\n{\r\nint rc = 0;\r\nif (set == NULL)\r\nreturn 0;\r\nLASSERT(set->set_exp);\r\nif (atomic_read(&set->set_completes)) {\r\nrc = common_attr_done(set);\r\n}\r\nlov_put_reqset(set);\r\nreturn rc;\r\n}\r\nint lov_update_setattr_set(struct lov_request_set *set,\r\nstruct lov_request *req, int rc)\r\n{\r\nstruct lov_obd *lov = &req->rq_rqset->set_exp->exp_obd->u.lov;\r\nstruct lov_stripe_md *lsm = req->rq_rqset->set_oi->oi_md;\r\nlov_update_set(set, req, rc);\r\nif (rc && !(lov->lov_tgts[req->rq_idx] &&\r\nlov->lov_tgts[req->rq_idx]->ltd_active))\r\nrc = 0;\r\nif (rc == 0) {\r\nif (req->rq_oi.oi_oa->o_valid & OBD_MD_FLCTIME)\r\nlsm->lsm_oinfo[req->rq_stripe]->loi_lvb.lvb_ctime =\r\nreq->rq_oi.oi_oa->o_ctime;\r\nif (req->rq_oi.oi_oa->o_valid & OBD_MD_FLMTIME)\r\nlsm->lsm_oinfo[req->rq_stripe]->loi_lvb.lvb_mtime =\r\nreq->rq_oi.oi_oa->o_mtime;\r\nif (req->rq_oi.oi_oa->o_valid & OBD_MD_FLATIME)\r\nlsm->lsm_oinfo[req->rq_stripe]->loi_lvb.lvb_atime =\r\nreq->rq_oi.oi_oa->o_atime;\r\n}\r\nreturn rc;\r\n}\r\nstatic int cb_setattr_update(void *cookie, int rc)\r\n{\r\nstruct obd_info *oinfo = cookie;\r\nstruct lov_request *lovreq;\r\nlovreq = container_of(oinfo, struct lov_request, rq_oi);\r\nreturn lov_update_setattr_set(lovreq->rq_rqset, lovreq, rc);\r\n}\r\nint lov_prep_setattr_set(struct obd_export *exp, struct obd_info *oinfo,\r\nstruct obd_trans_info *oti,\r\nstruct lov_request_set **reqset)\r\n{\r\nstruct lov_request_set *set;\r\nstruct lov_obd *lov = &exp->exp_obd->u.lov;\r\nint rc = 0, i;\r\nOBD_ALLOC(set, sizeof(*set));\r\nif (set == NULL)\r\nreturn -ENOMEM;\r\nlov_init_set(set);\r\nset->set_exp = exp;\r\nset->set_oti = oti;\r\nset->set_oi = oinfo;\r\nif (oti != NULL && oinfo->oi_oa->o_valid & OBD_MD_FLCOOKIE)\r\nset->set_cookies = oti->oti_logcookies;\r\nfor (i = 0; i < oinfo->oi_md->lsm_stripe_count; i++) {\r\nstruct lov_oinfo *loi = oinfo->oi_md->lsm_oinfo[i];\r\nstruct lov_request *req;\r\nif (!lov_check_and_wait_active(lov, loi->loi_ost_idx)) {\r\nCDEBUG(D_HA, "lov idx %d inactive\n", loi->loi_ost_idx);\r\ncontinue;\r\n}\r\nOBD_ALLOC(req, sizeof(*req));\r\nif (req == NULL) {\r\nrc = -ENOMEM;\r\ngoto out_set;\r\n}\r\nreq->rq_stripe = i;\r\nreq->rq_idx = loi->loi_ost_idx;\r\nOBDO_ALLOC(req->rq_oi.oi_oa);\r\nif (req->rq_oi.oi_oa == NULL) {\r\nOBD_FREE(req, sizeof(*req));\r\nrc = -ENOMEM;\r\ngoto out_set;\r\n}\r\nmemcpy(req->rq_oi.oi_oa, oinfo->oi_oa,\r\nsizeof(*req->rq_oi.oi_oa));\r\nreq->rq_oi.oi_oa->o_oi = loi->loi_oi;\r\nreq->rq_oi.oi_oa->o_stripe_idx = i;\r\nreq->rq_oi.oi_cb_up = cb_setattr_update;\r\nreq->rq_oi.oi_capa = oinfo->oi_capa;\r\nif (oinfo->oi_oa->o_valid & OBD_MD_FLSIZE) {\r\nint off = lov_stripe_offset(oinfo->oi_md,\r\noinfo->oi_oa->o_size, i,\r\n&req->rq_oi.oi_oa->o_size);\r\nif (off < 0 && req->rq_oi.oi_oa->o_size)\r\nreq->rq_oi.oi_oa->o_size--;\r\nCDEBUG(D_INODE, "stripe %d has size %llu/%llu\n",\r\ni, req->rq_oi.oi_oa->o_size,\r\noinfo->oi_oa->o_size);\r\n}\r\nlov_set_add_req(req, set);\r\n}\r\nif (!set->set_count) {\r\nrc = -EIO;\r\ngoto out_set;\r\n}\r\n*reqset = set;\r\nreturn rc;\r\nout_set:\r\nlov_fini_setattr_set(set);\r\nreturn rc;\r\n}\r\nint lov_fini_statfs(struct obd_device *obd, struct obd_statfs *osfs,\r\nint success)\r\n{\r\nif (success) {\r\n__u32 expected_stripes = lov_get_stripecnt(&obd->u.lov,\r\nLOV_MAGIC, 0);\r\nif (osfs->os_files != LOV_U64_MAX)\r\nlov_do_div64(osfs->os_files, expected_stripes);\r\nif (osfs->os_ffree != LOV_U64_MAX)\r\nlov_do_div64(osfs->os_ffree, expected_stripes);\r\nspin_lock(&obd->obd_osfs_lock);\r\nmemcpy(&obd->obd_osfs, osfs, sizeof(*osfs));\r\nobd->obd_osfs_age = cfs_time_current_64();\r\nspin_unlock(&obd->obd_osfs_lock);\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nint lov_fini_statfs_set(struct lov_request_set *set)\r\n{\r\nint rc = 0;\r\nif (set == NULL)\r\nreturn 0;\r\nif (atomic_read(&set->set_completes)) {\r\nrc = lov_fini_statfs(set->set_obd, set->set_oi->oi_osfs,\r\natomic_read(&set->set_success));\r\n}\r\nlov_put_reqset(set);\r\nreturn rc;\r\n}\r\nvoid lov_update_statfs(struct obd_statfs *osfs, struct obd_statfs *lov_sfs,\r\nint success)\r\n{\r\nint shift = 0, quit = 0;\r\n__u64 tmp;\r\nif (success == 0) {\r\nmemcpy(osfs, lov_sfs, sizeof(*lov_sfs));\r\n} else {\r\nif (osfs->os_bsize != lov_sfs->os_bsize) {\r\ntmp = osfs->os_bsize | lov_sfs->os_bsize;\r\nfor (shift = 0; shift <= 64; ++shift) {\r\nif (tmp & 1) {\r\nif (quit)\r\nbreak;\r\nelse\r\nquit = 1;\r\nshift = 0;\r\n}\r\ntmp >>= 1;\r\n}\r\n}\r\nif (osfs->os_bsize < lov_sfs->os_bsize) {\r\nosfs->os_bsize = lov_sfs->os_bsize;\r\nosfs->os_bfree >>= shift;\r\nosfs->os_bavail >>= shift;\r\nosfs->os_blocks >>= shift;\r\n} else if (shift != 0) {\r\nlov_sfs->os_bfree >>= shift;\r\nlov_sfs->os_bavail >>= shift;\r\nlov_sfs->os_blocks >>= shift;\r\n}\r\nosfs->os_bfree += lov_sfs->os_bfree;\r\nosfs->os_bavail += lov_sfs->os_bavail;\r\nosfs->os_blocks += lov_sfs->os_blocks;\r\nLOV_SUM_MAX(osfs->os_files, lov_sfs->os_files);\r\nLOV_SUM_MAX(osfs->os_ffree, lov_sfs->os_ffree);\r\n}\r\n}\r\nstatic int cb_statfs_update(void *cookie, int rc)\r\n{\r\nstruct obd_info *oinfo = cookie;\r\nstruct lov_request *lovreq;\r\nstruct lov_request_set *set;\r\nstruct obd_statfs *osfs, *lov_sfs;\r\nstruct lov_obd *lov;\r\nstruct lov_tgt_desc *tgt;\r\nstruct obd_device *lovobd, *tgtobd;\r\nint success;\r\nlovreq = container_of(oinfo, struct lov_request, rq_oi);\r\nset = lovreq->rq_rqset;\r\nlovobd = set->set_obd;\r\nlov = &lovobd->u.lov;\r\nosfs = set->set_oi->oi_osfs;\r\nlov_sfs = oinfo->oi_osfs;\r\nsuccess = atomic_read(&set->set_success);\r\nlov_update_set(set, lovreq, rc);\r\nif (rc)\r\ngoto out;\r\nobd_getref(lovobd);\r\ntgt = lov->lov_tgts[lovreq->rq_idx];\r\nif (!tgt || !tgt->ltd_active)\r\ngoto out_update;\r\ntgtobd = class_exp2obd(tgt->ltd_exp);\r\nspin_lock(&tgtobd->obd_osfs_lock);\r\nmemcpy(&tgtobd->obd_osfs, lov_sfs, sizeof(*lov_sfs));\r\nif ((oinfo->oi_flags & OBD_STATFS_FROM_CACHE) == 0)\r\ntgtobd->obd_osfs_age = cfs_time_current_64();\r\nspin_unlock(&tgtobd->obd_osfs_lock);\r\nout_update:\r\nlov_update_statfs(osfs, lov_sfs, success);\r\nobd_putref(lovobd);\r\nout:\r\nif (set->set_oi->oi_flags & OBD_STATFS_PTLRPCD &&\r\nlov_set_finished(set, 0)) {\r\nlov_statfs_interpret(NULL, set, set->set_count !=\r\natomic_read(&set->set_success));\r\n}\r\nreturn 0;\r\n}\r\nint lov_prep_statfs_set(struct obd_device *obd, struct obd_info *oinfo,\r\nstruct lov_request_set **reqset)\r\n{\r\nstruct lov_request_set *set;\r\nstruct lov_obd *lov = &obd->u.lov;\r\nint rc = 0, i;\r\nOBD_ALLOC(set, sizeof(*set));\r\nif (set == NULL)\r\nreturn -ENOMEM;\r\nlov_init_set(set);\r\nset->set_obd = obd;\r\nset->set_oi = oinfo;\r\nfor (i = 0; i < lov->desc.ld_tgt_count; i++) {\r\nstruct lov_request *req;\r\nif (lov->lov_tgts[i] == NULL ||\r\n(!lov_check_and_wait_active(lov, i) &&\r\n(oinfo->oi_flags & OBD_STATFS_NODELAY))) {\r\nCDEBUG(D_HA, "lov idx %d inactive\n", i);\r\ncontinue;\r\n}\r\nif (!lov->lov_tgts[i]->ltd_exp) {\r\nCDEBUG(D_HA, "lov idx %d administratively disabled\n", i);\r\ncontinue;\r\n}\r\nOBD_ALLOC(req, sizeof(*req));\r\nif (req == NULL) {\r\nrc = -ENOMEM;\r\ngoto out_set;\r\n}\r\nOBD_ALLOC(req->rq_oi.oi_osfs, sizeof(*req->rq_oi.oi_osfs));\r\nif (req->rq_oi.oi_osfs == NULL) {\r\nOBD_FREE(req, sizeof(*req));\r\nrc = -ENOMEM;\r\ngoto out_set;\r\n}\r\nreq->rq_idx = i;\r\nreq->rq_oi.oi_cb_up = cb_statfs_update;\r\nreq->rq_oi.oi_flags = oinfo->oi_flags;\r\nlov_set_add_req(req, set);\r\n}\r\nif (!set->set_count) {\r\nrc = -EIO;\r\ngoto out_set;\r\n}\r\n*reqset = set;\r\nreturn rc;\r\nout_set:\r\nlov_fini_statfs_set(set);\r\nreturn rc;\r\n}
