static int start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct saa7134_dmaqueue *dmaq = vq->drv_priv;\r\nstruct saa7134_dev *dev = dmaq->dev;\r\nu32 leading_null_bytes = 0;\r\nint err;\r\nerr = saa7134_ts_start_streaming(vq, count);\r\nif (err)\r\nreturn err;\r\nswitch (dev->board) {\r\ncase SAA7134_BOARD_BEHOLD_M6:\r\ncase SAA7134_BOARD_BEHOLD_M63:\r\ncase SAA7134_BOARD_BEHOLD_M6_EXTRA:\r\nleading_null_bytes = 1;\r\nbreak;\r\n}\r\nsaa_call_all(dev, core, init, leading_null_bytes);\r\nsaa_writeb(SAA7134_AUDIO_MUTE_CTRL,\r\nsaa_readb(SAA7134_AUDIO_MUTE_CTRL) & ~(1 << 6));\r\ndev->empress_started = 1;\r\nreturn 0;\r\n}\r\nstatic void stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct saa7134_dmaqueue *dmaq = vq->drv_priv;\r\nstruct saa7134_dev *dev = dmaq->dev;\r\nsaa7134_ts_stop_streaming(vq);\r\nsaa_writeb(SAA7134_SPECIAL_MODE, 0x00);\r\nmsleep(20);\r\nsaa_writeb(SAA7134_SPECIAL_MODE, 0x01);\r\nmsleep(100);\r\nsaa_writeb(SAA7134_AUDIO_MUTE_CTRL,\r\nsaa_readb(SAA7134_AUDIO_MUTE_CTRL) | (1 << 6));\r\ndev->empress_started = 0;\r\n}\r\nstatic int empress_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index != 0)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, "MPEG TS", sizeof(f->description));\r\nf->pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->flags = V4L2_FMT_FLAG_COMPRESSED;\r\nreturn 0;\r\n}\r\nstatic int empress_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nsaa_call_all(dev, video, g_mbus_fmt, &mbus_fmt);\r\nv4l2_fill_pix_format(&f->fmt.pix, &mbus_fmt);\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.sizeimage = TS_PACKET_SIZE * dev->ts.nr_packets;\r\nf->fmt.pix.bytesperline = 0;\r\nreturn 0;\r\n}\r\nstatic int empress_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nv4l2_fill_mbus_format(&mbus_fmt, &f->fmt.pix, MEDIA_BUS_FMT_FIXED);\r\nsaa_call_all(dev, video, s_mbus_fmt, &mbus_fmt);\r\nv4l2_fill_pix_format(&f->fmt.pix, &mbus_fmt);\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.sizeimage = TS_PACKET_SIZE * dev->ts.nr_packets;\r\nf->fmt.pix.bytesperline = 0;\r\nreturn 0;\r\n}\r\nstatic int empress_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nv4l2_fill_mbus_format(&mbus_fmt, &f->fmt.pix, MEDIA_BUS_FMT_FIXED);\r\nsaa_call_all(dev, video, try_mbus_fmt, &mbus_fmt);\r\nv4l2_fill_pix_format(&f->fmt.pix, &mbus_fmt);\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.sizeimage = TS_PACKET_SIZE * dev->ts.nr_packets;\r\nf->fmt.pix.bytesperline = 0;\r\nreturn 0;\r\n}\r\nstatic void empress_signal_update(struct work_struct *work)\r\n{\r\nstruct saa7134_dev* dev =\r\ncontainer_of(work, struct saa7134_dev, empress_workqueue);\r\nif (dev->nosignal) {\r\ndprintk("no video signal\n");\r\n} else {\r\ndprintk("video signal acquired\n");\r\n}\r\n}\r\nstatic void empress_signal_change(struct saa7134_dev *dev)\r\n{\r\nschedule_work(&dev->empress_workqueue);\r\n}\r\nstatic bool empress_ctrl_filter(const struct v4l2_ctrl *ctrl)\r\n{\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ncase V4L2_CID_HUE:\r\ncase V4L2_CID_CONTRAST:\r\ncase V4L2_CID_SATURATION:\r\ncase V4L2_CID_AUDIO_MUTE:\r\ncase V4L2_CID_AUDIO_VOLUME:\r\ncase V4L2_CID_PRIVATE_INVERT:\r\ncase V4L2_CID_PRIVATE_AUTOMUTE:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int empress_init(struct saa7134_dev *dev)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &dev->empress_ctrl_handler;\r\nstruct vb2_queue *q;\r\nint err;\r\ndprintk("%s: %s\n",dev->name,__func__);\r\ndev->empress_dev = video_device_alloc();\r\nif (NULL == dev->empress_dev)\r\nreturn -ENOMEM;\r\n*(dev->empress_dev) = saa7134_empress_template;\r\ndev->empress_dev->v4l2_dev = &dev->v4l2_dev;\r\ndev->empress_dev->release = video_device_release;\r\ndev->empress_dev->lock = &dev->lock;\r\nsnprintf(dev->empress_dev->name, sizeof(dev->empress_dev->name),\r\n"%s empress (%s)", dev->name,\r\nsaa7134_boards[dev->board].name);\r\nv4l2_ctrl_handler_init(hdl, 21);\r\nv4l2_ctrl_add_handler(hdl, &dev->ctrl_handler, empress_ctrl_filter);\r\nif (dev->empress_sd)\r\nv4l2_ctrl_add_handler(hdl, dev->empress_sd->ctrl_handler, NULL);\r\nif (hdl->error) {\r\nvideo_device_release(dev->empress_dev);\r\nreturn hdl->error;\r\n}\r\ndev->empress_dev->ctrl_handler = hdl;\r\nINIT_WORK(&dev->empress_workqueue, empress_signal_update);\r\nq = &dev->empress_vbq;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_READ;\r\nq->drv_priv = &dev->ts_q;\r\nq->ops = &saa7134_empress_qops;\r\nq->gfp_flags = GFP_DMA32;\r\nq->mem_ops = &vb2_dma_sg_memops;\r\nq->buf_struct_size = sizeof(struct saa7134_buf);\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &dev->lock;\r\nerr = vb2_queue_init(q);\r\nif (err)\r\nreturn err;\r\ndev->empress_dev->queue = q;\r\nvideo_set_drvdata(dev->empress_dev, dev);\r\nerr = video_register_device(dev->empress_dev,VFL_TYPE_GRABBER,\r\nempress_nr[dev->nr]);\r\nif (err < 0) {\r\nprintk(KERN_INFO "%s: can't register video device\n",\r\ndev->name);\r\nvideo_device_release(dev->empress_dev);\r\ndev->empress_dev = NULL;\r\nreturn err;\r\n}\r\nprintk(KERN_INFO "%s: registered device %s [mpeg]\n",\r\ndev->name, video_device_node_name(dev->empress_dev));\r\nempress_signal_update(&dev->empress_workqueue);\r\nreturn 0;\r\n}\r\nstatic int empress_fini(struct saa7134_dev *dev)\r\n{\r\ndprintk("%s: %s\n",dev->name,__func__);\r\nif (NULL == dev->empress_dev)\r\nreturn 0;\r\nflush_work(&dev->empress_workqueue);\r\nvideo_unregister_device(dev->empress_dev);\r\nvb2_queue_release(&dev->empress_vbq);\r\nv4l2_ctrl_handler_free(&dev->empress_ctrl_handler);\r\ndev->empress_dev = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init empress_register(void)\r\n{\r\nreturn saa7134_ts_register(&empress_ops);\r\n}\r\nstatic void __exit empress_unregister(void)\r\n{\r\nsaa7134_ts_unregister(&empress_ops);\r\n}
