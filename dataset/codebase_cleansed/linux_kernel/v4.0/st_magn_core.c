static int st_magn_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *ch, int *val,\r\nint *val2, long mask)\r\n{\r\nint err;\r\nstruct st_sensor_data *mdata = iio_priv(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nerr = st_sensors_read_info_raw(indio_dev, ch, val);\r\nif (err < 0)\r\ngoto read_error;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = 0;\r\nif ((ch->scan_index == ST_SENSORS_SCAN_Z) &&\r\n(mdata->current_fullscale->gain2 != 0))\r\n*val2 = mdata->current_fullscale->gain2;\r\nelse\r\n*val2 = mdata->current_fullscale->gain;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\n*val = mdata->odr;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nread_error:\r\nreturn err;\r\n}\r\nstatic int st_magn_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int val, int val2, long mask)\r\n{\r\nint err;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nerr = st_sensors_set_fullscale_by_gain(indio_dev, val2);\r\nbreak;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nif (val2)\r\nreturn -EINVAL;\r\nmutex_lock(&indio_dev->mlock);\r\nerr = st_sensors_set_odr(indio_dev, val);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn err;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nint st_magn_common_probe(struct iio_dev *indio_dev)\r\n{\r\nstruct st_sensor_data *mdata = iio_priv(indio_dev);\r\nint irq = mdata->get_irq_data_ready(indio_dev);\r\nint err;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &magn_info;\r\nst_sensors_power_enable(indio_dev);\r\nerr = st_sensors_check_device_support(indio_dev,\r\nARRAY_SIZE(st_magn_sensors_settings),\r\nst_magn_sensors_settings);\r\nif (err < 0)\r\nreturn err;\r\nmdata->num_data_channels = ST_MAGN_NUMBER_DATA_CHANNELS;\r\nmdata->multiread_bit = mdata->sensor_settings->multi_read_bit;\r\nindio_dev->channels = mdata->sensor_settings->ch;\r\nindio_dev->num_channels = ST_SENSORS_NUMBER_ALL_CHANNELS;\r\nmdata->current_fullscale = (struct st_sensor_fullscale_avl *)\r\n&mdata->sensor_settings->fs.fs_avl[0];\r\nmdata->odr = mdata->sensor_settings->odr.odr_avl[0].hz;\r\nerr = st_sensors_init_sensor(indio_dev, NULL);\r\nif (err < 0)\r\nreturn err;\r\nerr = st_magn_allocate_ring(indio_dev);\r\nif (err < 0)\r\nreturn err;\r\nif (irq > 0) {\r\nerr = st_sensors_allocate_trigger(indio_dev, NULL);\r\nif (err < 0)\r\ngoto st_magn_probe_trigger_error;\r\n}\r\nerr = iio_device_register(indio_dev);\r\nif (err)\r\ngoto st_magn_device_register_error;\r\ndev_info(&indio_dev->dev, "registered magnetometer %s\n",\r\nindio_dev->name);\r\nreturn 0;\r\nst_magn_device_register_error:\r\nif (irq > 0)\r\nst_sensors_deallocate_trigger(indio_dev);\r\nst_magn_probe_trigger_error:\r\nst_magn_deallocate_ring(indio_dev);\r\nreturn err;\r\n}\r\nvoid st_magn_common_remove(struct iio_dev *indio_dev)\r\n{\r\nstruct st_sensor_data *mdata = iio_priv(indio_dev);\r\nst_sensors_power_disable(indio_dev);\r\niio_device_unregister(indio_dev);\r\nif (mdata->get_irq_data_ready(indio_dev) > 0)\r\nst_sensors_deallocate_trigger(indio_dev);\r\nst_magn_deallocate_ring(indio_dev);\r\n}
