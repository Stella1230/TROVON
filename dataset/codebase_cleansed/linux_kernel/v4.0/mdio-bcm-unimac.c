static inline void unimac_mdio_start(struct unimac_mdio_priv *priv)\r\n{\r\nu32 reg;\r\nreg = __raw_readl(priv->base + MDIO_CMD);\r\nreg |= MDIO_START_BUSY;\r\n__raw_writel(reg, priv->base + MDIO_CMD);\r\n}\r\nstatic inline unsigned int unimac_mdio_busy(struct unimac_mdio_priv *priv)\r\n{\r\nreturn __raw_readl(priv->base + MDIO_CMD) & MDIO_START_BUSY;\r\n}\r\nstatic int unimac_mdio_read(struct mii_bus *bus, int phy_id, int reg)\r\n{\r\nstruct unimac_mdio_priv *priv = bus->priv;\r\nunsigned int timeout = 1000;\r\nu32 cmd;\r\ncmd = MDIO_RD | (phy_id << MDIO_PMD_SHIFT) | (reg << MDIO_REG_SHIFT);\r\n__raw_writel(cmd, priv->base + MDIO_CMD);\r\nunimac_mdio_start(priv);\r\ndo {\r\nif (!unimac_mdio_busy(priv))\r\nbreak;\r\nusleep_range(1000, 2000);\r\n} while (timeout--);\r\nif (!timeout)\r\nreturn -ETIMEDOUT;\r\ncmd = __raw_readl(priv->base + MDIO_CMD);\r\nif (cmd & MDIO_READ_FAIL)\r\nreturn -EIO;\r\nreturn cmd & 0xffff;\r\n}\r\nstatic int unimac_mdio_write(struct mii_bus *bus, int phy_id,\r\nint reg, u16 val)\r\n{\r\nstruct unimac_mdio_priv *priv = bus->priv;\r\nunsigned int timeout = 1000;\r\nu32 cmd;\r\ncmd = MDIO_WR | (phy_id << MDIO_PMD_SHIFT) |\r\n(reg << MDIO_REG_SHIFT) | (0xffff & val);\r\n__raw_writel(cmd, priv->base + MDIO_CMD);\r\nunimac_mdio_start(priv);\r\ndo {\r\nif (!unimac_mdio_busy(priv))\r\nbreak;\r\nusleep_range(1000, 2000);\r\n} while (timeout--);\r\nif (!timeout)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int unimac_mdio_probe(struct platform_device *pdev)\r\n{\r\nstruct unimac_mdio_priv *priv;\r\nstruct device_node *np;\r\nstruct mii_bus *bus;\r\nstruct resource *r;\r\nint ret;\r\nnp = pdev->dev.of_node;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\r\nif (!priv->base) {\r\ndev_err(&pdev->dev, "failed to remap register\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->mii_bus = mdiobus_alloc();\r\nif (!priv->mii_bus)\r\nreturn -ENOMEM;\r\nbus = priv->mii_bus;\r\nbus->priv = priv;\r\nbus->name = "unimac MII bus";\r\nbus->parent = &pdev->dev;\r\nbus->read = unimac_mdio_read;\r\nbus->write = unimac_mdio_write;\r\nsnprintf(bus->id, MII_BUS_ID_SIZE, "%s", pdev->name);\r\nbus->irq = kcalloc(PHY_MAX_ADDR, sizeof(int), GFP_KERNEL);\r\nif (!bus->irq) {\r\nret = -ENOMEM;\r\ngoto out_mdio_free;\r\n}\r\nret = of_mdiobus_register(bus, np);\r\nif (ret) {\r\ndev_err(&pdev->dev, "MDIO bus registration failed\n");\r\ngoto out_mdio_irq;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\ndev_info(&pdev->dev, "Broadcom UniMAC MDIO bus at 0x%p\n", priv->base);\r\nreturn 0;\r\nout_mdio_irq:\r\nkfree(bus->irq);\r\nout_mdio_free:\r\nmdiobus_free(bus);\r\nreturn ret;\r\n}\r\nstatic int unimac_mdio_remove(struct platform_device *pdev)\r\n{\r\nstruct unimac_mdio_priv *priv = platform_get_drvdata(pdev);\r\nmdiobus_unregister(priv->mii_bus);\r\nkfree(priv->mii_bus->irq);\r\nmdiobus_free(priv->mii_bus);\r\nreturn 0;\r\n}
