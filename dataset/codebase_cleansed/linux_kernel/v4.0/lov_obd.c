static void lov_getref(struct obd_device *obd)\r\n{\r\nstruct lov_obd *lov = &obd->u.lov;\r\nmutex_lock(&lov->lov_lock);\r\natomic_inc(&lov->lov_refcount);\r\nmutex_unlock(&lov->lov_lock);\r\nreturn;\r\n}\r\nstatic void lov_putref(struct obd_device *obd)\r\n{\r\nstruct lov_obd *lov = &obd->u.lov;\r\nmutex_lock(&lov->lov_lock);\r\nif (atomic_dec_and_test(&lov->lov_refcount) && lov->lov_death_row) {\r\nLIST_HEAD(kill);\r\nint i;\r\nstruct lov_tgt_desc *tgt, *n;\r\nCDEBUG(D_CONFIG, "destroying %d lov targets\n",\r\nlov->lov_death_row);\r\nfor (i = 0; i < lov->desc.ld_tgt_count; i++) {\r\ntgt = lov->lov_tgts[i];\r\nif (!tgt || !tgt->ltd_reap)\r\ncontinue;\r\nlist_add(&tgt->ltd_kill, &kill);\r\nlov_ost_pool_remove(&lov->lov_packed, i);\r\nlov->lov_tgts[i] = NULL;\r\nlov->lov_death_row--;\r\n}\r\nmutex_unlock(&lov->lov_lock);\r\nlist_for_each_entry_safe(tgt, n, &kill, ltd_kill) {\r\nlist_del(&tgt->ltd_kill);\r\n__lov_del_obd(obd, tgt);\r\n}\r\n} else {\r\nmutex_unlock(&lov->lov_lock);\r\n}\r\n}\r\nint lov_connect_obd(struct obd_device *obd, __u32 index, int activate,\r\nstruct obd_connect_data *data)\r\n{\r\nstruct lov_obd *lov = &obd->u.lov;\r\nstruct obd_uuid *tgt_uuid;\r\nstruct obd_device *tgt_obd;\r\nstatic struct obd_uuid lov_osc_uuid = { "LOV_OSC_UUID" };\r\nstruct obd_import *imp;\r\nstruct proc_dir_entry *lov_proc_dir;\r\nint rc;\r\nif (!lov->lov_tgts[index])\r\nreturn -EINVAL;\r\ntgt_uuid = &lov->lov_tgts[index]->ltd_uuid;\r\ntgt_obd = lov->lov_tgts[index]->ltd_obd;\r\nif (!tgt_obd->obd_set_up) {\r\nCERROR("Target %s not set up\n", obd_uuid2str(tgt_uuid));\r\nreturn -EINVAL;\r\n}\r\ntgt_obd->u.cli.cl_sp_me = lov->lov_sp_me;\r\nif (data && (data->ocd_connect_flags & OBD_CONNECT_INDEX))\r\ndata->ocd_index = index;\r\nimp = tgt_obd->u.cli.cl_import;\r\nif (activate) {\r\ntgt_obd->obd_no_recov = 0;\r\nptlrpc_activate_import(imp);\r\n}\r\nrc = obd_register_observer(tgt_obd, obd);\r\nif (rc) {\r\nCERROR("Target %s register_observer error %d\n",\r\nobd_uuid2str(tgt_uuid), rc);\r\nreturn rc;\r\n}\r\nif (imp->imp_invalid) {\r\nCDEBUG(D_CONFIG, "not connecting OSC %s; administratively disabled\n",\r\nobd_uuid2str(tgt_uuid));\r\nreturn 0;\r\n}\r\nrc = obd_connect(NULL, &lov->lov_tgts[index]->ltd_exp, tgt_obd,\r\n&lov_osc_uuid, data, NULL);\r\nif (rc || !lov->lov_tgts[index]->ltd_exp) {\r\nCERROR("Target %s connect error %d\n",\r\nobd_uuid2str(tgt_uuid), rc);\r\nreturn -ENODEV;\r\n}\r\nlov->lov_tgts[index]->ltd_reap = 0;\r\nCDEBUG(D_CONFIG, "Connected tgt idx %d %s (%s) %sactive\n", index,\r\nobd_uuid2str(tgt_uuid), tgt_obd->obd_name, activate ? "":"in");\r\nlov_proc_dir = obd->obd_proc_private;\r\nif (lov_proc_dir) {\r\nstruct obd_device *osc_obd = lov->lov_tgts[index]->ltd_exp->exp_obd;\r\nstruct proc_dir_entry *osc_symlink;\r\nLASSERT(osc_obd != NULL);\r\nLASSERT(osc_obd->obd_magic == OBD_DEVICE_MAGIC);\r\nLASSERT(osc_obd->obd_type->typ_name != NULL);\r\nosc_symlink = lprocfs_add_symlink(osc_obd->obd_name,\r\nlov_proc_dir,\r\n"../../../%s/%s",\r\nosc_obd->obd_type->typ_name,\r\nosc_obd->obd_name);\r\nif (osc_symlink == NULL) {\r\nCERROR("could not register LOV target /proc/fs/lustre/%s/%s/target_obds/%s.",\r\nobd->obd_type->typ_name, obd->obd_name,\r\nosc_obd->obd_name);\r\nlprocfs_remove(&lov_proc_dir);\r\nobd->obd_proc_private = NULL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int lov_connect(const struct lu_env *env,\r\nstruct obd_export **exp, struct obd_device *obd,\r\nstruct obd_uuid *cluuid, struct obd_connect_data *data,\r\nvoid *localdata)\r\n{\r\nstruct lov_obd *lov = &obd->u.lov;\r\nstruct lov_tgt_desc *tgt;\r\nstruct lustre_handle conn;\r\nint i, rc;\r\nCDEBUG(D_CONFIG, "connect #%d\n", lov->lov_connects);\r\nrc = class_connect(&conn, obd, cluuid);\r\nif (rc)\r\nreturn rc;\r\n*exp = class_conn2export(&conn);\r\nlov->lov_connects++;\r\nLASSERT(lov->lov_connects == 1);\r\nmemset(&lov->lov_ocd, 0, sizeof(lov->lov_ocd));\r\nif (data)\r\nlov->lov_ocd = *data;\r\nobd_getref(obd);\r\nfor (i = 0; i < lov->desc.ld_tgt_count; i++) {\r\ntgt = lov->lov_tgts[i];\r\nif (!tgt || obd_uuid_empty(&tgt->ltd_uuid))\r\ncontinue;\r\nrc = lov_connect_obd(obd, i, tgt->ltd_activate, &lov->lov_ocd);\r\nif (rc) {\r\nCERROR("%s: lov connect tgt %d failed: %d\n",\r\nobd->obd_name, i, rc);\r\ncontinue;\r\n}\r\nif (!lov->lov_tgts[i]->ltd_exp)\r\ncontinue;\r\nrc = lov_notify(obd, lov->lov_tgts[i]->ltd_exp->exp_obd,\r\nOBD_NOTIFY_CONNECT, (void *)&i);\r\nif (rc) {\r\nCERROR("%s error sending notify %d\n",\r\nobd->obd_name, rc);\r\n}\r\n}\r\nobd_putref(obd);\r\nreturn 0;\r\n}\r\nstatic int lov_disconnect_obd(struct obd_device *obd, struct lov_tgt_desc *tgt)\r\n{\r\nstruct proc_dir_entry *lov_proc_dir;\r\nstruct lov_obd *lov = &obd->u.lov;\r\nstruct obd_device *osc_obd;\r\nint rc;\r\nosc_obd = class_exp2obd(tgt->ltd_exp);\r\nCDEBUG(D_CONFIG, "%s: disconnecting target %s\n",\r\nobd->obd_name, osc_obd ? osc_obd->obd_name : "NULL");\r\nif (tgt->ltd_active) {\r\ntgt->ltd_active = 0;\r\nlov->desc.ld_active_tgt_count--;\r\ntgt->ltd_exp->exp_obd->obd_inactive = 1;\r\n}\r\nif (osc_obd) {\r\nlov_proc_dir = obd->obd_proc_private;\r\nif (lov_proc_dir) {\r\nlprocfs_remove_proc_entry(osc_obd->obd_name, lov_proc_dir);\r\n}\r\nosc_obd->obd_force = obd->obd_force;\r\nosc_obd->obd_fail = obd->obd_fail;\r\nosc_obd->obd_no_recov = obd->obd_no_recov;\r\n}\r\nobd_register_observer(osc_obd, NULL);\r\nrc = obd_disconnect(tgt->ltd_exp);\r\nif (rc) {\r\nCERROR("Target %s disconnect error %d\n",\r\ntgt->ltd_uuid.uuid, rc);\r\nrc = 0;\r\n}\r\ntgt->ltd_exp = NULL;\r\nreturn 0;\r\n}\r\nstatic int lov_disconnect(struct obd_export *exp)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct lov_obd *lov = &obd->u.lov;\r\nint i, rc;\r\nif (!lov->lov_tgts)\r\ngoto out;\r\nlov->lov_connects--;\r\nif (lov->lov_connects != 0) {\r\nCERROR("disconnect #%d\n", lov->lov_connects);\r\ngoto out;\r\n}\r\nobd_getref(obd);\r\nfor (i = 0; i < lov->desc.ld_tgt_count; i++) {\r\nif (lov->lov_tgts[i] && lov->lov_tgts[i]->ltd_exp) {\r\nlov_del_target(obd, i, NULL, lov->lov_tgts[i]->ltd_gen);\r\n}\r\n}\r\nobd_putref(obd);\r\nout:\r\nrc = class_disconnect(exp);\r\nreturn rc;\r\n}\r\nstatic int lov_set_osc_active(struct obd_device *obd, struct obd_uuid *uuid,\r\nenum obd_notify_event ev)\r\n{\r\nstruct lov_obd *lov = &obd->u.lov;\r\nstruct lov_tgt_desc *tgt;\r\nint index, activate, active;\r\nCDEBUG(D_INFO, "Searching in lov %p for uuid %s event(%d)\n",\r\nlov, uuid->uuid, ev);\r\nobd_getref(obd);\r\nfor (index = 0; index < lov->desc.ld_tgt_count; index++) {\r\ntgt = lov->lov_tgts[index];\r\nif (!tgt)\r\ncontinue;\r\nif (ev == OBD_NOTIFY_ACTIVATE && tgt->ltd_exp == NULL &&\r\nobd_uuid_equals(uuid, &tgt->ltd_uuid)) {\r\nstruct obd_uuid lov_osc_uuid = {"LOV_OSC_UUID"};\r\nobd_connect(NULL, &tgt->ltd_exp, tgt->ltd_obd,\r\n&lov_osc_uuid, &lov->lov_ocd, NULL);\r\n}\r\nif (!tgt->ltd_exp)\r\ncontinue;\r\nCDEBUG(D_INFO, "lov idx %d is %s conn %#llx\n",\r\nindex, obd_uuid2str(&tgt->ltd_uuid),\r\ntgt->ltd_exp->exp_handle.h_cookie);\r\nif (obd_uuid_equals(uuid, &tgt->ltd_uuid))\r\nbreak;\r\n}\r\nif (index == lov->desc.ld_tgt_count) {\r\nindex = -EINVAL;\r\ngoto out;\r\n}\r\nif (ev == OBD_NOTIFY_DEACTIVATE || ev == OBD_NOTIFY_ACTIVATE) {\r\nactivate = (ev == OBD_NOTIFY_ACTIVATE) ? 1 : 0;\r\nif (lov->lov_tgts[index]->ltd_activate == activate) {\r\nCDEBUG(D_INFO, "OSC %s already %sactivate!\n",\r\nuuid->uuid, activate ? "" : "de");\r\n} else {\r\nlov->lov_tgts[index]->ltd_activate = activate;\r\nCDEBUG(D_CONFIG, "%sactivate OSC %s\n",\r\nactivate ? "" : "de", obd_uuid2str(uuid));\r\n}\r\n} else if (ev == OBD_NOTIFY_INACTIVE || ev == OBD_NOTIFY_ACTIVE) {\r\nactive = (ev == OBD_NOTIFY_ACTIVE) ? 1 : 0;\r\nif (lov->lov_tgts[index]->ltd_active == active) {\r\nCDEBUG(D_INFO, "OSC %s already %sactive!\n",\r\nuuid->uuid, active ? "" : "in");\r\ngoto out;\r\n} else {\r\nCDEBUG(D_CONFIG, "Marking OSC %s %sactive\n",\r\nobd_uuid2str(uuid), active ? "" : "in");\r\n}\r\nlov->lov_tgts[index]->ltd_active = active;\r\nif (active) {\r\nlov->desc.ld_active_tgt_count++;\r\nlov->lov_tgts[index]->ltd_exp->exp_obd->obd_inactive = 0;\r\n} else {\r\nlov->desc.ld_active_tgt_count--;\r\nlov->lov_tgts[index]->ltd_exp->exp_obd->obd_inactive = 1;\r\n}\r\n} else {\r\nCERROR("Unknown event(%d) for uuid %s", ev, uuid->uuid);\r\n}\r\nout:\r\nobd_putref(obd);\r\nreturn index;\r\n}\r\nstatic int lov_notify(struct obd_device *obd, struct obd_device *watched,\r\nenum obd_notify_event ev, void *data)\r\n{\r\nint rc = 0;\r\nstruct lov_obd *lov = &obd->u.lov;\r\ndown_read(&lov->lov_notify_lock);\r\nif (!lov->lov_connects) {\r\nup_read(&lov->lov_notify_lock);\r\nreturn rc;\r\n}\r\nif (ev == OBD_NOTIFY_ACTIVE || ev == OBD_NOTIFY_INACTIVE ||\r\nev == OBD_NOTIFY_ACTIVATE || ev == OBD_NOTIFY_DEACTIVATE) {\r\nstruct obd_uuid *uuid;\r\nLASSERT(watched);\r\nif (strcmp(watched->obd_type->typ_name, LUSTRE_OSC_NAME)) {\r\nup_read(&lov->lov_notify_lock);\r\nCERROR("unexpected notification of %s %s!\n",\r\nwatched->obd_type->typ_name,\r\nwatched->obd_name);\r\nreturn -EINVAL;\r\n}\r\nuuid = &watched->u.cli.cl_target_uuid;\r\nrc = lov_set_osc_active(obd, uuid, ev);\r\nif (rc < 0) {\r\nup_read(&lov->lov_notify_lock);\r\nCERROR("event(%d) of %s failed: %d\n", ev,\r\nobd_uuid2str(uuid), rc);\r\nreturn rc;\r\n}\r\ndata = &rc;\r\n}\r\nif (watched) {\r\nrc = obd_notify_observer(obd, watched, ev, data);\r\n} else {\r\nstruct lov_obd *lov = &obd->u.lov;\r\nint i, is_sync;\r\ndata = &i;\r\nis_sync = (ev == OBD_NOTIFY_SYNC) ||\r\n(ev == OBD_NOTIFY_SYNC_NONBLOCK);\r\nobd_getref(obd);\r\nfor (i = 0; i < lov->desc.ld_tgt_count; i++) {\r\nif (!lov->lov_tgts[i])\r\ncontinue;\r\nif (is_sync && !lov->lov_tgts[i]->ltd_active)\r\ncontinue;\r\nrc = obd_notify_observer(obd, lov->lov_tgts[i]->ltd_obd,\r\nev, data);\r\nif (rc) {\r\nCERROR("%s: notify %s of %s failed %d\n",\r\nobd->obd_name,\r\nobd->obd_observer->obd_name,\r\nlov->lov_tgts[i]->ltd_obd->obd_name,\r\nrc);\r\n}\r\n}\r\nobd_putref(obd);\r\n}\r\nup_read(&lov->lov_notify_lock);\r\nreturn rc;\r\n}\r\nstatic int lov_add_target(struct obd_device *obd, struct obd_uuid *uuidp,\r\n__u32 index, int gen, int active)\r\n{\r\nstruct lov_obd *lov = &obd->u.lov;\r\nstruct lov_tgt_desc *tgt;\r\nstruct obd_device *tgt_obd;\r\nint rc;\r\nCDEBUG(D_CONFIG, "uuid:%s idx:%d gen:%d active:%d\n",\r\nuuidp->uuid, index, gen, active);\r\nif (gen <= 0) {\r\nCERROR("request to add OBD %s with invalid generation: %d\n",\r\nuuidp->uuid, gen);\r\nreturn -EINVAL;\r\n}\r\ntgt_obd = class_find_client_obd(uuidp, LUSTRE_OSC_NAME,\r\n&obd->obd_uuid);\r\nif (tgt_obd == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(&lov->lov_lock);\r\nif ((index < lov->lov_tgt_size) && (lov->lov_tgts[index] != NULL)) {\r\ntgt = lov->lov_tgts[index];\r\nCERROR("UUID %s already assigned at LOV target index %d\n",\r\nobd_uuid2str(&tgt->ltd_uuid), index);\r\nmutex_unlock(&lov->lov_lock);\r\nreturn -EEXIST;\r\n}\r\nif (index >= lov->lov_tgt_size) {\r\nstruct lov_tgt_desc **newtgts, **old = NULL;\r\n__u32 newsize, oldsize = 0;\r\nnewsize = max_t(__u32, lov->lov_tgt_size, 2);\r\nwhile (newsize < index + 1)\r\nnewsize = newsize << 1;\r\nOBD_ALLOC(newtgts, sizeof(*newtgts) * newsize);\r\nif (newtgts == NULL) {\r\nmutex_unlock(&lov->lov_lock);\r\nreturn -ENOMEM;\r\n}\r\nif (lov->lov_tgt_size) {\r\nmemcpy(newtgts, lov->lov_tgts, sizeof(*newtgts) *\r\nlov->lov_tgt_size);\r\nold = lov->lov_tgts;\r\noldsize = lov->lov_tgt_size;\r\n}\r\nlov->lov_tgts = newtgts;\r\nlov->lov_tgt_size = newsize;\r\nsmp_rmb();\r\nif (old)\r\nOBD_FREE(old, sizeof(*old) * oldsize);\r\nCDEBUG(D_CONFIG, "tgts: %p size: %d\n",\r\nlov->lov_tgts, lov->lov_tgt_size);\r\n}\r\nOBD_ALLOC_PTR(tgt);\r\nif (!tgt) {\r\nmutex_unlock(&lov->lov_lock);\r\nreturn -ENOMEM;\r\n}\r\nrc = lov_ost_pool_add(&lov->lov_packed, index, lov->lov_tgt_size);\r\nif (rc) {\r\nmutex_unlock(&lov->lov_lock);\r\nOBD_FREE_PTR(tgt);\r\nreturn rc;\r\n}\r\ntgt->ltd_uuid = *uuidp;\r\ntgt->ltd_obd = tgt_obd;\r\ntgt->ltd_gen = gen;\r\ntgt->ltd_index = index;\r\ntgt->ltd_activate = active;\r\nlov->lov_tgts[index] = tgt;\r\nif (index >= lov->desc.ld_tgt_count)\r\nlov->desc.ld_tgt_count = index + 1;\r\nmutex_unlock(&lov->lov_lock);\r\nCDEBUG(D_CONFIG, "idx=%d ltd_gen=%d ld_tgt_count=%d\n",\r\nindex, tgt->ltd_gen, lov->desc.ld_tgt_count);\r\nrc = obd_notify(obd, tgt_obd, OBD_NOTIFY_CREATE, &index);\r\nif (lov->lov_connects == 0) {\r\nreturn 0;\r\n}\r\nobd_getref(obd);\r\nrc = lov_connect_obd(obd, index, active, &lov->lov_ocd);\r\nif (rc)\r\ngoto out;\r\nif (!tgt->ltd_exp) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nif (lov->lov_cache != NULL) {\r\nrc = obd_set_info_async(NULL, tgt->ltd_exp,\r\nsizeof(KEY_CACHE_SET), KEY_CACHE_SET,\r\nsizeof(struct cl_client_cache), lov->lov_cache,\r\nNULL);\r\nif (rc < 0)\r\ngoto out;\r\n}\r\nrc = lov_notify(obd, tgt->ltd_exp->exp_obd,\r\nactive ? OBD_NOTIFY_CONNECT : OBD_NOTIFY_INACTIVE,\r\n(void *)&index);\r\nout:\r\nif (rc) {\r\nCERROR("add failed (%d), deleting %s\n", rc,\r\nobd_uuid2str(&tgt->ltd_uuid));\r\nlov_del_target(obd, index, NULL, 0);\r\n}\r\nobd_putref(obd);\r\nreturn rc;\r\n}\r\nint lov_del_target(struct obd_device *obd, __u32 index,\r\nstruct obd_uuid *uuidp, int gen)\r\n{\r\nstruct lov_obd *lov = &obd->u.lov;\r\nint count = lov->desc.ld_tgt_count;\r\nint rc = 0;\r\nif (index >= count) {\r\nCERROR("LOV target index %d >= number of LOV OBDs %d.\n",\r\nindex, count);\r\nreturn -EINVAL;\r\n}\r\ndown_write(&lov->lov_notify_lock);\r\nobd_getref(obd);\r\nif (!lov->lov_tgts[index]) {\r\nCERROR("LOV target at index %d is not setup.\n", index);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (uuidp && !obd_uuid_equals(uuidp, &lov->lov_tgts[index]->ltd_uuid)) {\r\nCERROR("LOV target UUID %s at index %d doesn't match %s.\n",\r\nlov_uuid2str(lov, index), index,\r\nobd_uuid2str(uuidp));\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nCDEBUG(D_CONFIG, "uuid: %s idx: %d gen: %d exp: %p active: %d\n",\r\nlov_uuid2str(lov, index), index,\r\nlov->lov_tgts[index]->ltd_gen, lov->lov_tgts[index]->ltd_exp,\r\nlov->lov_tgts[index]->ltd_active);\r\nlov->lov_tgts[index]->ltd_reap = 1;\r\nlov->lov_death_row++;\r\nout:\r\nobd_putref(obd);\r\nup_write(&lov->lov_notify_lock);\r\nreturn rc;\r\n}\r\nstatic void __lov_del_obd(struct obd_device *obd, struct lov_tgt_desc *tgt)\r\n{\r\nstruct obd_device *osc_obd;\r\nLASSERT(tgt);\r\nLASSERT(tgt->ltd_reap);\r\nosc_obd = class_exp2obd(tgt->ltd_exp);\r\nCDEBUG(D_CONFIG, "Removing tgt %s : %s\n",\r\ntgt->ltd_uuid.uuid,\r\nosc_obd ? osc_obd->obd_name : "<no obd>");\r\nif (tgt->ltd_exp)\r\nlov_disconnect_obd(obd, tgt);\r\nOBD_FREE_PTR(tgt);\r\nif (osc_obd)\r\nclass_manual_cleanup(osc_obd);\r\n}\r\nvoid lov_fix_desc_stripe_size(__u64 *val)\r\n{\r\nif (*val < LOV_MIN_STRIPE_SIZE) {\r\nif (*val != 0)\r\nLCONSOLE_INFO("Increasing default stripe size to minimum %u\n",\r\nLOV_DESC_STRIPE_SIZE_DEFAULT);\r\n*val = LOV_DESC_STRIPE_SIZE_DEFAULT;\r\n} else if (*val & (LOV_MIN_STRIPE_SIZE - 1)) {\r\n*val &= ~(LOV_MIN_STRIPE_SIZE - 1);\r\nLCONSOLE_WARN("Changing default stripe size to %llu (a multiple of %u)\n",\r\n*val, LOV_MIN_STRIPE_SIZE);\r\n}\r\n}\r\nvoid lov_fix_desc_stripe_count(__u32 *val)\r\n{\r\nif (*val == 0)\r\n*val = 1;\r\n}\r\nvoid lov_fix_desc_pattern(__u32 *val)\r\n{\r\nif ((*val != 0) && (*val != LOV_PATTERN_RAID0)) {\r\nLCONSOLE_WARN("Unknown stripe pattern: %#x\n", *val);\r\n*val = 0;\r\n}\r\n}\r\nvoid lov_fix_desc_qos_maxage(__u32 *val)\r\n{\r\nif (*val == 0)\r\n*val = LOV_DESC_QOS_MAXAGE_DEFAULT;\r\n}\r\nvoid lov_fix_desc(struct lov_desc *desc)\r\n{\r\nlov_fix_desc_stripe_size(&desc->ld_default_stripe_size);\r\nlov_fix_desc_stripe_count(&desc->ld_default_stripe_count);\r\nlov_fix_desc_pattern(&desc->ld_pattern);\r\nlov_fix_desc_qos_maxage(&desc->ld_qos_maxage);\r\n}\r\nint lov_setup(struct obd_device *obd, struct lustre_cfg *lcfg)\r\n{\r\nstruct lprocfs_static_vars lvars = { NULL };\r\nstruct lov_desc *desc;\r\nstruct lov_obd *lov = &obd->u.lov;\r\nint rc;\r\nif (LUSTRE_CFG_BUFLEN(lcfg, 1) < 1) {\r\nCERROR("LOV setup requires a descriptor\n");\r\nreturn -EINVAL;\r\n}\r\ndesc = (struct lov_desc *)lustre_cfg_buf(lcfg, 1);\r\nif (sizeof(*desc) > LUSTRE_CFG_BUFLEN(lcfg, 1)) {\r\nCERROR("descriptor size wrong: %d > %d\n",\r\n(int)sizeof(*desc), LUSTRE_CFG_BUFLEN(lcfg, 1));\r\nreturn -EINVAL;\r\n}\r\nif (desc->ld_magic != LOV_DESC_MAGIC) {\r\nif (desc->ld_magic == __swab32(LOV_DESC_MAGIC)) {\r\nCDEBUG(D_OTHER, "%s: Swabbing lov desc %p\n",\r\nobd->obd_name, desc);\r\nlustre_swab_lov_desc(desc);\r\n} else {\r\nCERROR("%s: Bad lov desc magic: %#x\n",\r\nobd->obd_name, desc->ld_magic);\r\nreturn -EINVAL;\r\n}\r\n}\r\nlov_fix_desc(desc);\r\ndesc->ld_active_tgt_count = 0;\r\nlov->desc = *desc;\r\nlov->lov_tgt_size = 0;\r\nmutex_init(&lov->lov_lock);\r\natomic_set(&lov->lov_refcount, 0);\r\nlov->lov_sp_me = LUSTRE_SP_CLI;\r\ninit_rwsem(&lov->lov_notify_lock);\r\nlov->lov_pools_hash_body = cfs_hash_create("POOLS", HASH_POOLS_CUR_BITS,\r\nHASH_POOLS_MAX_BITS,\r\nHASH_POOLS_BKT_BITS, 0,\r\nCFS_HASH_MIN_THETA,\r\nCFS_HASH_MAX_THETA,\r\n&pool_hash_operations,\r\nCFS_HASH_DEFAULT);\r\nINIT_LIST_HEAD(&lov->lov_pool_list);\r\nlov->lov_pool_count = 0;\r\nrc = lov_ost_pool_init(&lov->lov_packed, 0);\r\nif (rc)\r\ngoto out;\r\nlprocfs_lov_init_vars(&lvars);\r\nlprocfs_obd_setup(obd, lvars.obd_vars);\r\n#if defined (CONFIG_PROC_FS)\r\n{\r\nint rc1;\r\nrc1 = lprocfs_seq_create(obd->obd_proc_entry, "target_obd",\r\n0444, &lov_proc_target_fops, obd);\r\nif (rc1)\r\nCWARN("Error adding the target_obd file\n");\r\n}\r\n#endif\r\nlov->lov_pool_proc_entry = lprocfs_register("pools",\r\nobd->obd_proc_entry,\r\nNULL, NULL);\r\nreturn 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int lov_precleanup(struct obd_device *obd, enum obd_cleanup_stage stage)\r\n{\r\nstruct lov_obd *lov = &obd->u.lov;\r\nswitch (stage) {\r\ncase OBD_CLEANUP_EARLY: {\r\nint i;\r\nfor (i = 0; i < lov->desc.ld_tgt_count; i++) {\r\nif (!lov->lov_tgts[i] || !lov->lov_tgts[i]->ltd_active)\r\ncontinue;\r\nobd_precleanup(class_exp2obd(lov->lov_tgts[i]->ltd_exp),\r\nOBD_CLEANUP_EARLY);\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lov_cleanup(struct obd_device *obd)\r\n{\r\nstruct lov_obd *lov = &obd->u.lov;\r\nstruct list_head *pos, *tmp;\r\nstruct pool_desc *pool;\r\nlist_for_each_safe(pos, tmp, &lov->lov_pool_list) {\r\npool = list_entry(pos, struct pool_desc, pool_list);\r\nCDEBUG(D_INFO, "delete pool %p\n", pool);\r\nlov_pool_del(obd, pool->pool_name);\r\n}\r\ncfs_hash_putref(lov->lov_pools_hash_body);\r\nlov_ost_pool_free(&lov->lov_packed);\r\nlprocfs_obd_cleanup(obd);\r\nif (lov->lov_tgts) {\r\nint i;\r\nobd_getref(obd);\r\nfor (i = 0; i < lov->desc.ld_tgt_count; i++) {\r\nif (!lov->lov_tgts[i])\r\ncontinue;\r\nif (lov->lov_tgts[i]->ltd_active ||\r\natomic_read(&lov->lov_refcount))\r\nCERROR("lov tgt %d not cleaned! deathrow=%d, lovrc=%d\n",\r\ni, lov->lov_death_row,\r\natomic_read(&lov->lov_refcount));\r\nlov_del_target(obd, i, NULL, 0);\r\n}\r\nobd_putref(obd);\r\nOBD_FREE(lov->lov_tgts, sizeof(*lov->lov_tgts) *\r\nlov->lov_tgt_size);\r\nlov->lov_tgt_size = 0;\r\n}\r\nreturn 0;\r\n}\r\nint lov_process_config_base(struct obd_device *obd, struct lustre_cfg *lcfg,\r\n__u32 *indexp, int *genp)\r\n{\r\nstruct obd_uuid obd_uuid;\r\nint cmd;\r\nint rc = 0;\r\nswitch (cmd = lcfg->lcfg_command) {\r\ncase LCFG_LOV_ADD_OBD:\r\ncase LCFG_LOV_ADD_INA:\r\ncase LCFG_LOV_DEL_OBD: {\r\n__u32 index;\r\nint gen;\r\nif (LUSTRE_CFG_BUFLEN(lcfg, 1) > sizeof(obd_uuid.uuid)) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nobd_str2uuid(&obd_uuid, lustre_cfg_buf(lcfg, 1));\r\nif (sscanf(lustre_cfg_buf(lcfg, 2), "%d", indexp) != 1) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (sscanf(lustre_cfg_buf(lcfg, 3), "%d", genp) != 1) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nindex = *indexp;\r\ngen = *genp;\r\nif (cmd == LCFG_LOV_ADD_OBD)\r\nrc = lov_add_target(obd, &obd_uuid, index, gen, 1);\r\nelse if (cmd == LCFG_LOV_ADD_INA)\r\nrc = lov_add_target(obd, &obd_uuid, index, gen, 0);\r\nelse\r\nrc = lov_del_target(obd, index, &obd_uuid, gen);\r\ngoto out;\r\n}\r\ncase LCFG_PARAM: {\r\nstruct lprocfs_static_vars lvars = { NULL };\r\nstruct lov_desc *desc = &(obd->u.lov.desc);\r\nif (!desc) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nlprocfs_lov_init_vars(&lvars);\r\nrc = class_process_proc_param(PARAM_LOV, lvars.obd_vars,\r\nlcfg, obd);\r\nif (rc > 0)\r\nrc = 0;\r\ngoto out;\r\n}\r\ncase LCFG_POOL_NEW:\r\ncase LCFG_POOL_ADD:\r\ncase LCFG_POOL_DEL:\r\ncase LCFG_POOL_REM:\r\ngoto out;\r\ndefault: {\r\nCERROR("Unknown command: %d\n", lcfg->lcfg_command);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int lov_recreate(struct obd_export *exp, struct obdo *src_oa,\r\nstruct lov_stripe_md **ea, struct obd_trans_info *oti)\r\n{\r\nstruct lov_stripe_md *obj_mdp, *lsm;\r\nstruct lov_obd *lov = &exp->exp_obd->u.lov;\r\nunsigned ost_idx;\r\nint rc, i;\r\nLASSERT(src_oa->o_valid & OBD_MD_FLFLAGS &&\r\nsrc_oa->o_flags & OBD_FL_RECREATE_OBJS);\r\nOBD_ALLOC(obj_mdp, sizeof(*obj_mdp));\r\nif (obj_mdp == NULL)\r\nreturn -ENOMEM;\r\nost_idx = src_oa->o_nlink;\r\nlsm = *ea;\r\nif (lsm == NULL) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (ost_idx >= lov->desc.ld_tgt_count ||\r\n!lov->lov_tgts[ost_idx]) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nfor (i = 0; i < lsm->lsm_stripe_count; i++) {\r\nif (lsm->lsm_oinfo[i]->loi_ost_idx == ost_idx) {\r\nif (ostid_id(&lsm->lsm_oinfo[i]->loi_oi) !=\r\nostid_id(&src_oa->o_oi)) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (i == lsm->lsm_stripe_count) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = obd_create(NULL, lov->lov_tgts[ost_idx]->ltd_exp,\r\nsrc_oa, &obj_mdp, oti);\r\nout:\r\nOBD_FREE(obj_mdp, sizeof(*obj_mdp));\r\nreturn rc;\r\n}\r\nstatic int lov_create(const struct lu_env *env, struct obd_export *exp,\r\nstruct obdo *src_oa, struct lov_stripe_md **ea,\r\nstruct obd_trans_info *oti)\r\n{\r\nstruct lov_obd *lov;\r\nint rc = 0;\r\nLASSERT(ea != NULL);\r\nif (exp == NULL)\r\nreturn -EINVAL;\r\nif ((src_oa->o_valid & OBD_MD_FLFLAGS) &&\r\nsrc_oa->o_flags == OBD_FL_DELORPHAN) {\r\nLBUG();\r\n}\r\nlov = &exp->exp_obd->u.lov;\r\nif (!lov->desc.ld_active_tgt_count)\r\nreturn -EIO;\r\nobd_getref(exp->exp_obd);\r\nif ((src_oa->o_valid & OBD_MD_FLFLAGS) &&\r\n(src_oa->o_flags & OBD_FL_RECREATE_OBJS)) {\r\nrc = lov_recreate(exp, src_oa, ea, oti);\r\n}\r\nobd_putref(exp->exp_obd);\r\nreturn rc;\r\n}\r\nstatic int lov_destroy(const struct lu_env *env, struct obd_export *exp,\r\nstruct obdo *oa, struct lov_stripe_md *lsm,\r\nstruct obd_trans_info *oti, struct obd_export *md_exp,\r\nvoid *capa)\r\n{\r\nstruct lov_request_set *set;\r\nstruct obd_info oinfo;\r\nstruct lov_request *req;\r\nstruct list_head *pos;\r\nstruct lov_obd *lov;\r\nint rc = 0, err = 0;\r\nASSERT_LSM_MAGIC(lsm);\r\nif (!exp || !exp->exp_obd)\r\nreturn -ENODEV;\r\nif (oa->o_valid & OBD_MD_FLCOOKIE) {\r\nLASSERT(oti);\r\nLASSERT(oti->oti_logcookies);\r\n}\r\nlov = &exp->exp_obd->u.lov;\r\nobd_getref(exp->exp_obd);\r\nrc = lov_prep_destroy_set(exp, &oinfo, oa, lsm, oti, &set);\r\nif (rc)\r\ngoto out;\r\nlist_for_each(pos, &set->set_list) {\r\nreq = list_entry(pos, struct lov_request, rq_link);\r\nif (oa->o_valid & OBD_MD_FLCOOKIE)\r\noti->oti_logcookies = set->set_cookies + req->rq_stripe;\r\nerr = obd_destroy(env, lov->lov_tgts[req->rq_idx]->ltd_exp,\r\nreq->rq_oi.oi_oa, NULL, oti, NULL, capa);\r\nerr = lov_update_common_set(set, req, err);\r\nif (err) {\r\nCERROR("%s: destroying objid "DOSTID" subobj "\r\nDOSTID" on OST idx %d: rc = %d\n",\r\nexp->exp_obd->obd_name, POSTID(&oa->o_oi),\r\nPOSTID(&req->rq_oi.oi_oa->o_oi),\r\nreq->rq_idx, err);\r\nif (!rc)\r\nrc = err;\r\n}\r\n}\r\nif (rc == 0) {\r\nLASSERT(lsm_op_find(lsm->lsm_magic) != NULL);\r\nrc = lsm_op_find(lsm->lsm_magic)->lsm_destroy(lsm, oa, md_exp);\r\n}\r\nerr = lov_fini_destroy_set(set);\r\nout:\r\nobd_putref(exp->exp_obd);\r\nreturn rc ? rc : err;\r\n}\r\nstatic int lov_getattr_interpret(struct ptlrpc_request_set *rqset,\r\nvoid *data, int rc)\r\n{\r\nstruct lov_request_set *lovset = (struct lov_request_set *)data;\r\nint err;\r\nif (rc)\r\natomic_set(&lovset->set_completes, 0);\r\nerr = lov_fini_getattr_set(lovset);\r\nreturn rc ? rc : err;\r\n}\r\nstatic int lov_getattr_async(struct obd_export *exp, struct obd_info *oinfo,\r\nstruct ptlrpc_request_set *rqset)\r\n{\r\nstruct lov_request_set *lovset;\r\nstruct lov_obd *lov;\r\nstruct list_head *pos;\r\nstruct lov_request *req;\r\nint rc = 0, err;\r\nLASSERT(oinfo);\r\nASSERT_LSM_MAGIC(oinfo->oi_md);\r\nif (!exp || !exp->exp_obd)\r\nreturn -ENODEV;\r\nlov = &exp->exp_obd->u.lov;\r\nrc = lov_prep_getattr_set(exp, oinfo, &lovset);\r\nif (rc)\r\nreturn rc;\r\nCDEBUG(D_INFO, "objid "DOSTID": %ux%u byte stripes\n",\r\nPOSTID(&oinfo->oi_md->lsm_oi), oinfo->oi_md->lsm_stripe_count,\r\noinfo->oi_md->lsm_stripe_size);\r\nlist_for_each(pos, &lovset->set_list) {\r\nreq = list_entry(pos, struct lov_request, rq_link);\r\nCDEBUG(D_INFO, "objid " DOSTID "[%d] has subobj " DOSTID " at idx%u\n",\r\nPOSTID(&oinfo->oi_oa->o_oi), req->rq_stripe,\r\nPOSTID(&req->rq_oi.oi_oa->o_oi), req->rq_idx);\r\nrc = obd_getattr_async(lov->lov_tgts[req->rq_idx]->ltd_exp,\r\n&req->rq_oi, rqset);\r\nif (rc) {\r\nCERROR("%s: getattr objid "DOSTID" subobj"\r\nDOSTID" on OST idx %d: rc = %d\n",\r\nexp->exp_obd->obd_name,\r\nPOSTID(&oinfo->oi_oa->o_oi),\r\nPOSTID(&req->rq_oi.oi_oa->o_oi),\r\nreq->rq_idx, rc);\r\ngoto out;\r\n}\r\n}\r\nif (!list_empty(&rqset->set_requests)) {\r\nLASSERT(rc == 0);\r\nLASSERT(rqset->set_interpret == NULL);\r\nrqset->set_interpret = lov_getattr_interpret;\r\nrqset->set_arg = (void *)lovset;\r\nreturn rc;\r\n}\r\nout:\r\nif (rc)\r\natomic_set(&lovset->set_completes, 0);\r\nerr = lov_fini_getattr_set(lovset);\r\nreturn rc ? rc : err;\r\n}\r\nstatic int lov_setattr_interpret(struct ptlrpc_request_set *rqset,\r\nvoid *data, int rc)\r\n{\r\nstruct lov_request_set *lovset = (struct lov_request_set *)data;\r\nint err;\r\nif (rc)\r\natomic_set(&lovset->set_completes, 0);\r\nerr = lov_fini_setattr_set(lovset);\r\nreturn rc ? rc : err;\r\n}\r\nstatic int lov_setattr_async(struct obd_export *exp, struct obd_info *oinfo,\r\nstruct obd_trans_info *oti,\r\nstruct ptlrpc_request_set *rqset)\r\n{\r\nstruct lov_request_set *set;\r\nstruct lov_request *req;\r\nstruct list_head *pos;\r\nstruct lov_obd *lov;\r\nint rc = 0;\r\nLASSERT(oinfo);\r\nASSERT_LSM_MAGIC(oinfo->oi_md);\r\nif (oinfo->oi_oa->o_valid & OBD_MD_FLCOOKIE) {\r\nLASSERT(oti);\r\nLASSERT(oti->oti_logcookies);\r\n}\r\nif (!exp || !exp->exp_obd)\r\nreturn -ENODEV;\r\nlov = &exp->exp_obd->u.lov;\r\nrc = lov_prep_setattr_set(exp, oinfo, oti, &set);\r\nif (rc)\r\nreturn rc;\r\nCDEBUG(D_INFO, "objid "DOSTID": %ux%u byte stripes\n",\r\nPOSTID(&oinfo->oi_md->lsm_oi),\r\noinfo->oi_md->lsm_stripe_count,\r\noinfo->oi_md->lsm_stripe_size);\r\nlist_for_each(pos, &set->set_list) {\r\nreq = list_entry(pos, struct lov_request, rq_link);\r\nif (oinfo->oi_oa->o_valid & OBD_MD_FLCOOKIE)\r\noti->oti_logcookies = set->set_cookies + req->rq_stripe;\r\nCDEBUG(D_INFO, "objid " DOSTID "[%d] has subobj " DOSTID " at idx%u\n",\r\nPOSTID(&oinfo->oi_oa->o_oi), req->rq_stripe,\r\nPOSTID(&req->rq_oi.oi_oa->o_oi), req->rq_idx);\r\nrc = obd_setattr_async(lov->lov_tgts[req->rq_idx]->ltd_exp,\r\n&req->rq_oi, oti, rqset);\r\nif (rc) {\r\nCERROR("error: setattr objid "DOSTID" subobj"\r\nDOSTID" on OST idx %d: rc = %d\n",\r\nPOSTID(&set->set_oi->oi_oa->o_oi),\r\nPOSTID(&req->rq_oi.oi_oa->o_oi),\r\nreq->rq_idx, rc);\r\nbreak;\r\n}\r\n}\r\nif (rc || !rqset || list_empty(&rqset->set_requests)) {\r\nint err;\r\nif (rc)\r\natomic_set(&set->set_completes, 0);\r\nerr = lov_fini_setattr_set(set);\r\nreturn rc ? rc : err;\r\n}\r\nLASSERT(rqset->set_interpret == NULL);\r\nrqset->set_interpret = lov_setattr_interpret;\r\nrqset->set_arg = (void *)set;\r\nreturn 0;\r\n}\r\nstatic int lov_find_cbdata(struct obd_export *exp,\r\nstruct lov_stripe_md *lsm, ldlm_iterator_t it,\r\nvoid *data)\r\n{\r\nstruct lov_obd *lov;\r\nint rc = 0, i;\r\nASSERT_LSM_MAGIC(lsm);\r\nif (!exp || !exp->exp_obd)\r\nreturn -ENODEV;\r\nlov = &exp->exp_obd->u.lov;\r\nfor (i = 0; i < lsm->lsm_stripe_count; i++) {\r\nstruct lov_stripe_md submd;\r\nstruct lov_oinfo *loi = lsm->lsm_oinfo[i];\r\nif (!lov->lov_tgts[loi->loi_ost_idx]) {\r\nCDEBUG(D_HA, "lov idx %d NULL \n", loi->loi_ost_idx);\r\ncontinue;\r\n}\r\nsubmd.lsm_oi = loi->loi_oi;\r\nsubmd.lsm_stripe_count = 0;\r\nrc = obd_find_cbdata(lov->lov_tgts[loi->loi_ost_idx]->ltd_exp,\r\n&submd, it, data);\r\nif (rc != 0)\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}\r\nint lov_statfs_interpret(struct ptlrpc_request_set *rqset, void *data, int rc)\r\n{\r\nstruct lov_request_set *lovset = (struct lov_request_set *)data;\r\nint err;\r\nif (rc)\r\natomic_set(&lovset->set_completes, 0);\r\nerr = lov_fini_statfs_set(lovset);\r\nreturn rc ? rc : err;\r\n}\r\nstatic int lov_statfs_async(struct obd_export *exp, struct obd_info *oinfo,\r\n__u64 max_age, struct ptlrpc_request_set *rqset)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct lov_request_set *set;\r\nstruct lov_request *req;\r\nstruct list_head *pos;\r\nstruct lov_obd *lov;\r\nint rc = 0;\r\nLASSERT(oinfo != NULL);\r\nLASSERT(oinfo->oi_osfs != NULL);\r\nlov = &obd->u.lov;\r\nrc = lov_prep_statfs_set(obd, oinfo, &set);\r\nif (rc)\r\nreturn rc;\r\nlist_for_each(pos, &set->set_list) {\r\nreq = list_entry(pos, struct lov_request, rq_link);\r\nrc = obd_statfs_async(lov->lov_tgts[req->rq_idx]->ltd_exp,\r\n&req->rq_oi, max_age, rqset);\r\nif (rc)\r\nbreak;\r\n}\r\nif (rc || list_empty(&rqset->set_requests)) {\r\nint err;\r\nif (rc)\r\natomic_set(&set->set_completes, 0);\r\nerr = lov_fini_statfs_set(set);\r\nreturn rc ? rc : err;\r\n}\r\nLASSERT(rqset->set_interpret == NULL);\r\nrqset->set_interpret = lov_statfs_interpret;\r\nrqset->set_arg = (void *)set;\r\nreturn 0;\r\n}\r\nstatic int lov_statfs(const struct lu_env *env, struct obd_export *exp,\r\nstruct obd_statfs *osfs, __u64 max_age, __u32 flags)\r\n{\r\nstruct ptlrpc_request_set *set = NULL;\r\nstruct obd_info oinfo = { { { 0 } } };\r\nint rc = 0;\r\nset = ptlrpc_prep_set();\r\nif (set == NULL)\r\nreturn -ENOMEM;\r\noinfo.oi_osfs = osfs;\r\noinfo.oi_flags = flags;\r\nrc = lov_statfs_async(exp, &oinfo, max_age, set);\r\nif (rc == 0)\r\nrc = ptlrpc_set_wait(set);\r\nptlrpc_set_destroy(set);\r\nreturn rc;\r\n}\r\nstatic int lov_iocontrol(unsigned int cmd, struct obd_export *exp, int len,\r\nvoid *karg, void *uarg)\r\n{\r\nstruct obd_device *obddev = class_exp2obd(exp);\r\nstruct lov_obd *lov = &obddev->u.lov;\r\nint i = 0, rc = 0, count = lov->desc.ld_tgt_count;\r\nstruct obd_uuid *uuidp;\r\nswitch (cmd) {\r\ncase IOC_OBD_STATFS: {\r\nstruct obd_ioctl_data *data = karg;\r\nstruct obd_device *osc_obd;\r\nstruct obd_statfs stat_buf = {0};\r\n__u32 index;\r\n__u32 flags;\r\nmemcpy(&index, data->ioc_inlbuf2, sizeof(__u32));\r\nif ((index >= count))\r\nreturn -ENODEV;\r\nif (!lov->lov_tgts[index])\r\nreturn -EAGAIN;\r\nif (!lov->lov_tgts[index]->ltd_active)\r\nreturn -ENODATA;\r\nosc_obd = class_exp2obd(lov->lov_tgts[index]->ltd_exp);\r\nif (!osc_obd)\r\nreturn -EINVAL;\r\nif (copy_to_user(data->ioc_pbuf2, obd2cli_tgt(osc_obd),\r\nmin((int) data->ioc_plen2,\r\n(int) sizeof(struct obd_uuid))))\r\nreturn -EFAULT;\r\nflags = uarg ? *(__u32 *)uarg : 0;\r\nrc = obd_statfs(NULL, lov->lov_tgts[index]->ltd_exp, &stat_buf,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\nflags);\r\nif (rc)\r\nreturn rc;\r\nif (copy_to_user(data->ioc_pbuf1, &stat_buf,\r\nmin((int) data->ioc_plen1,\r\n(int) sizeof(stat_buf))))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase OBD_IOC_LOV_GET_CONFIG: {\r\nstruct obd_ioctl_data *data;\r\nstruct lov_desc *desc;\r\nchar *buf = NULL;\r\n__u32 *genp;\r\nlen = 0;\r\nif (obd_ioctl_getdata(&buf, &len, (void *)uarg))\r\nreturn -EINVAL;\r\ndata = (struct obd_ioctl_data *)buf;\r\nif (sizeof(*desc) > data->ioc_inllen1) {\r\nobd_ioctl_freedata(buf, len);\r\nreturn -EINVAL;\r\n}\r\nif (sizeof(uuidp->uuid) * count > data->ioc_inllen2) {\r\nobd_ioctl_freedata(buf, len);\r\nreturn -EINVAL;\r\n}\r\nif (sizeof(__u32) * count > data->ioc_inllen3) {\r\nobd_ioctl_freedata(buf, len);\r\nreturn -EINVAL;\r\n}\r\ndesc = (struct lov_desc *)data->ioc_inlbuf1;\r\nmemcpy(desc, &(lov->desc), sizeof(*desc));\r\nuuidp = (struct obd_uuid *)data->ioc_inlbuf2;\r\ngenp = (__u32 *)data->ioc_inlbuf3;\r\nfor (i = 0; i < count; i++, uuidp++, genp++) {\r\nif (!lov->lov_tgts[i])\r\ncontinue;\r\n*uuidp = lov->lov_tgts[i]->ltd_uuid;\r\n*genp = lov->lov_tgts[i]->ltd_gen;\r\n}\r\nif (copy_to_user((void *)uarg, buf, len))\r\nrc = -EFAULT;\r\nobd_ioctl_freedata(buf, len);\r\nbreak;\r\n}\r\ncase LL_IOC_LOV_GETSTRIPE:\r\nrc = lov_getstripe(exp, karg, uarg);\r\nbreak;\r\ncase OBD_IOC_QUOTACTL: {\r\nstruct if_quotactl *qctl = karg;\r\nstruct lov_tgt_desc *tgt = NULL;\r\nstruct obd_quotactl *oqctl;\r\nif (qctl->qc_valid == QC_OSTIDX) {\r\nif (qctl->qc_idx < 0 || count <= qctl->qc_idx)\r\nreturn -EINVAL;\r\ntgt = lov->lov_tgts[qctl->qc_idx];\r\nif (!tgt || !tgt->ltd_exp)\r\nreturn -EINVAL;\r\n} else if (qctl->qc_valid == QC_UUID) {\r\nfor (i = 0; i < count; i++) {\r\ntgt = lov->lov_tgts[i];\r\nif (!tgt ||\r\n!obd_uuid_equals(&tgt->ltd_uuid,\r\n&qctl->obd_uuid))\r\ncontinue;\r\nif (tgt->ltd_exp == NULL)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nif (i >= count)\r\nreturn -EAGAIN;\r\nLASSERT(tgt && tgt->ltd_exp);\r\nOBD_ALLOC_PTR(oqctl);\r\nif (!oqctl)\r\nreturn -ENOMEM;\r\nQCTL_COPY(oqctl, qctl);\r\nrc = obd_quotactl(tgt->ltd_exp, oqctl);\r\nif (rc == 0) {\r\nQCTL_COPY(qctl, oqctl);\r\nqctl->qc_valid = QC_OSTIDX;\r\nqctl->obd_uuid = tgt->ltd_uuid;\r\n}\r\nOBD_FREE_PTR(oqctl);\r\nbreak;\r\n}\r\ndefault: {\r\nint set = 0;\r\nif (count == 0)\r\nreturn -ENOTTY;\r\nfor (i = 0; i < count; i++) {\r\nint err;\r\nstruct obd_device *osc_obd;\r\nif (!lov->lov_tgts[i] || !lov->lov_tgts[i]->ltd_exp)\r\ncontinue;\r\nosc_obd = class_exp2obd(lov->lov_tgts[i]->ltd_exp);\r\nosc_obd->obd_force = obddev->obd_force;\r\nerr = obd_iocontrol(cmd, lov->lov_tgts[i]->ltd_exp,\r\nlen, karg, uarg);\r\nif (err == -ENODATA && cmd == OBD_IOC_POLL_QUOTACHECK) {\r\nreturn err;\r\n} else if (err) {\r\nif (lov->lov_tgts[i]->ltd_active) {\r\nCDEBUG(err == -ENOTTY ?\r\nD_IOCTL : D_WARNING,\r\n"iocontrol OSC %s on OST idx %d cmd %x: err = %d\n",\r\nlov_uuid2str(lov, i),\r\ni, cmd, err);\r\nif (!rc)\r\nrc = err;\r\n}\r\n} else {\r\nset = 1;\r\n}\r\n}\r\nif (!set && !rc)\r\nrc = -EIO;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nu64 fiemap_calc_fm_end_offset(struct ll_user_fiemap *fiemap,\r\nstruct lov_stripe_md *lsm, u64 fm_start,\r\nu64 fm_end, int *start_stripe)\r\n{\r\nu64 local_end = fiemap->fm_extents[0].fe_logical;\r\nu64 lun_start, lun_end;\r\nu64 fm_end_offset;\r\nint stripe_no = -1, i;\r\nif (fiemap->fm_extent_count == 0 ||\r\nfiemap->fm_extents[0].fe_logical == 0)\r\nreturn 0;\r\nfor (i = 0; i < lsm->lsm_stripe_count; i++) {\r\nif (lsm->lsm_oinfo[i]->loi_ost_idx ==\r\nfiemap->fm_extents[0].fe_device) {\r\nstripe_no = i;\r\nbreak;\r\n}\r\n}\r\nif (stripe_no == -1)\r\nreturn -EINVAL;\r\nif ((lov_stripe_intersects(lsm, stripe_no, fm_start, fm_end,\r\n&lun_start, &lun_end)) != 0 &&\r\nlocal_end < lun_end) {\r\nfm_end_offset = local_end;\r\n*start_stripe = stripe_no;\r\n} else {\r\nfm_end_offset = 0;\r\n*start_stripe = (stripe_no + 1) % lsm->lsm_stripe_count;\r\n}\r\nreturn fm_end_offset;\r\n}\r\nint fiemap_calc_last_stripe(struct lov_stripe_md *lsm, u64 fm_start,\r\nu64 fm_end, int start_stripe,\r\nint *stripe_count)\r\n{\r\nint last_stripe;\r\nu64 obd_start, obd_end;\r\nint i, j;\r\nif (fm_end - fm_start > lsm->lsm_stripe_size * lsm->lsm_stripe_count) {\r\nlast_stripe = (start_stripe < 1 ? lsm->lsm_stripe_count - 1 :\r\nstart_stripe - 1);\r\n*stripe_count = lsm->lsm_stripe_count;\r\n} else {\r\nfor (j = 0, i = start_stripe; j < lsm->lsm_stripe_count;\r\ni = (i + 1) % lsm->lsm_stripe_count, j++) {\r\nif ((lov_stripe_intersects(lsm, i, fm_start, fm_end,\r\n&obd_start, &obd_end)) == 0)\r\nbreak;\r\n}\r\n*stripe_count = j;\r\nlast_stripe = (start_stripe + j - 1) %lsm->lsm_stripe_count;\r\n}\r\nreturn last_stripe;\r\n}\r\nvoid fiemap_prepare_and_copy_exts(struct ll_user_fiemap *fiemap,\r\nstruct ll_fiemap_extent *lcl_fm_ext,\r\nint ost_index, unsigned int ext_count,\r\nint current_extent)\r\n{\r\nchar *to;\r\nint ext;\r\nfor (ext = 0; ext < ext_count; ext++) {\r\nlcl_fm_ext[ext].fe_device = ost_index;\r\nlcl_fm_ext[ext].fe_flags |= FIEMAP_EXTENT_NET;\r\n}\r\nto = (char *)fiemap + fiemap_count_to_size(current_extent);\r\nmemcpy(to, lcl_fm_ext, ext_count * sizeof(struct ll_fiemap_extent));\r\n}\r\nstatic int lov_fiemap(struct lov_obd *lov, __u32 keylen, void *key,\r\n__u32 *vallen, void *val, struct lov_stripe_md *lsm)\r\n{\r\nstruct ll_fiemap_info_key *fm_key = key;\r\nstruct ll_user_fiemap *fiemap = val;\r\nstruct ll_user_fiemap *fm_local = NULL;\r\nstruct ll_fiemap_extent *lcl_fm_ext;\r\nint count_local;\r\nunsigned int get_num_extents = 0;\r\nint ost_index = 0, actual_start_stripe, start_stripe;\r\nu64 fm_start, fm_end, fm_length, fm_end_offset;\r\nu64 curr_loc;\r\nint current_extent = 0, rc = 0, i;\r\nint ost_eof = 0;\r\nint ost_done = 0;\r\nint last_stripe;\r\nint cur_stripe = 0, cur_stripe_wrap = 0, stripe_count;\r\nunsigned int buffer_size = FIEMAP_BUFFER_SIZE;\r\nif (!lsm_has_objects(lsm)) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nif (fiemap_count_to_size(fm_key->fiemap.fm_extent_count) < buffer_size)\r\nbuffer_size = fiemap_count_to_size(fm_key->fiemap.fm_extent_count);\r\nOBD_ALLOC_LARGE(fm_local, buffer_size);\r\nif (fm_local == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nlcl_fm_ext = &fm_local->fm_extents[0];\r\ncount_local = fiemap_size_to_count(buffer_size);\r\nmemcpy(fiemap, &fm_key->fiemap, sizeof(*fiemap));\r\nfm_start = fiemap->fm_start;\r\nfm_length = fiemap->fm_length;\r\nactual_start_stripe = start_stripe = lov_stripe_number(lsm, fm_start);\r\nfm_end = (fm_length == ~0ULL ? fm_key->oa.o_size :\r\nfm_start + fm_length - 1);\r\nif (fm_end > fm_key->oa.o_size)\r\nfm_end = fm_key->oa.o_size;\r\nlast_stripe = fiemap_calc_last_stripe(lsm, fm_start, fm_end,\r\nactual_start_stripe, &stripe_count);\r\nfm_end_offset = fiemap_calc_fm_end_offset(fiemap, lsm, fm_start,\r\nfm_end, &start_stripe);\r\nif (fm_end_offset == -EINVAL) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (fiemap_count_to_size(fiemap->fm_extent_count) > *vallen)\r\nfiemap->fm_extent_count = fiemap_size_to_count(*vallen);\r\nif (fiemap->fm_extent_count == 0) {\r\nget_num_extents = 1;\r\ncount_local = 0;\r\n}\r\nfor (cur_stripe = start_stripe, i = 0; i < stripe_count;\r\ni++, cur_stripe = (cur_stripe + 1) % lsm->lsm_stripe_count) {\r\nu64 req_fm_len;\r\nu64 len_mapped_single_call;\r\nu64 lun_start, lun_end, obd_object_end;\r\nunsigned int ext_count;\r\ncur_stripe_wrap = cur_stripe;\r\nif ((lov_stripe_intersects(lsm, cur_stripe, fm_start, fm_end,\r\n&lun_start, &obd_object_end)) == 0)\r\ncontinue;\r\nif (fm_end_offset != 0 && cur_stripe == start_stripe)\r\nlun_start = fm_end_offset;\r\nif (fm_length != ~0ULL) {\r\nif (fm_start + fm_length < fm_start)\r\nfm_length = ~0ULL - fm_start;\r\nlun_end = lov_size_to_stripe(lsm, fm_start + fm_length,\r\ncur_stripe);\r\n} else {\r\nlun_end = ~0ULL;\r\n}\r\nif (lun_start == lun_end)\r\ncontinue;\r\nreq_fm_len = obd_object_end - lun_start;\r\nfm_local->fm_length = 0;\r\nlen_mapped_single_call = 0;\r\nost_eof = 0;\r\nost_done = 0;\r\ndo {\r\nif (get_num_extents == 0) {\r\nif (current_extent + count_local >\r\nfiemap->fm_extent_count)\r\ncount_local = fiemap->fm_extent_count -\r\ncurrent_extent;\r\n}\r\nlun_start += len_mapped_single_call;\r\nfm_local->fm_length = req_fm_len - len_mapped_single_call;\r\nreq_fm_len = fm_local->fm_length;\r\nfm_local->fm_extent_count = count_local;\r\nfm_local->fm_mapped_extents = 0;\r\nfm_local->fm_flags = fiemap->fm_flags;\r\nfm_key->oa.o_oi = lsm->lsm_oinfo[cur_stripe]->loi_oi;\r\nost_index = lsm->lsm_oinfo[cur_stripe]->loi_ost_idx;\r\nif (ost_index < 0 ||\r\nost_index >= lov->desc.ld_tgt_count) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (!lov->lov_tgts[ost_index]->ltd_active) {\r\nfm_local->fm_flags |= FIEMAP_EXTENT_LAST;\r\nfm_local->fm_mapped_extents = 1;\r\nlcl_fm_ext[0].fe_logical = lun_start;\r\nlcl_fm_ext[0].fe_length = obd_object_end -\r\nlun_start;\r\nlcl_fm_ext[0].fe_flags |= FIEMAP_EXTENT_UNKNOWN;\r\ngoto inactive_tgt;\r\n}\r\nfm_local->fm_start = lun_start;\r\nfm_local->fm_flags &= ~FIEMAP_FLAG_DEVICE_ORDER;\r\nmemcpy(&fm_key->fiemap, fm_local, sizeof(*fm_local));\r\n*vallen=fiemap_count_to_size(fm_local->fm_extent_count);\r\nrc = obd_get_info(NULL,\r\nlov->lov_tgts[ost_index]->ltd_exp,\r\nkeylen, key, vallen, fm_local, lsm);\r\nif (rc != 0)\r\ngoto out;\r\ninactive_tgt:\r\next_count = fm_local->fm_mapped_extents;\r\nif (ext_count == 0) {\r\nost_done = 1;\r\nif (cur_stripe_wrap == last_stripe) {\r\nfiemap->fm_mapped_extents = 0;\r\ngoto finish;\r\n}\r\nbreak;\r\n}\r\nif (get_num_extents) {\r\ncurrent_extent += ext_count;\r\nbreak;\r\n}\r\nlen_mapped_single_call = lcl_fm_ext[ext_count-1].fe_logical -\r\nlun_start + lcl_fm_ext[ext_count - 1].fe_length;\r\nif (req_fm_len <= len_mapped_single_call)\r\nost_done = 1;\r\nif (lcl_fm_ext[ext_count-1].fe_flags & FIEMAP_EXTENT_LAST)\r\nlcl_fm_ext[ext_count - 1].fe_flags &=\r\n~FIEMAP_EXTENT_LAST;\r\ncurr_loc = lov_stripe_size(lsm,\r\nlcl_fm_ext[ext_count - 1].fe_logical+\r\nlcl_fm_ext[ext_count - 1].fe_length,\r\ncur_stripe);\r\nif (curr_loc >= fm_key->oa.o_size)\r\nost_eof = 1;\r\nfiemap_prepare_and_copy_exts(fiemap, lcl_fm_ext,\r\nost_index, ext_count,\r\ncurrent_extent);\r\ncurrent_extent += ext_count;\r\nif (current_extent >= fiemap->fm_extent_count)\r\ngoto finish;\r\n} while (ost_done == 0 && ost_eof == 0);\r\nif (cur_stripe_wrap == last_stripe)\r\ngoto finish;\r\n}\r\nfinish:\r\nif (lsm->lsm_stripe_count > 1)\r\nfiemap->fm_flags |= FIEMAP_FLAG_DEVICE_ORDER;\r\nif (get_num_extents)\r\ngoto skip_last_device_calc;\r\nif (cur_stripe_wrap == last_stripe) {\r\nif (ost_done || ost_eof)\r\nfiemap->fm_extents[current_extent - 1].fe_flags |=\r\nFIEMAP_EXTENT_LAST;\r\n}\r\nskip_last_device_calc:\r\nfiemap->fm_mapped_extents = current_extent;\r\nout:\r\nOBD_FREE_LARGE(fm_local, buffer_size);\r\nreturn rc;\r\n}\r\nstatic int lov_get_info(const struct lu_env *env, struct obd_export *exp,\r\n__u32 keylen, void *key, __u32 *vallen, void *val,\r\nstruct lov_stripe_md *lsm)\r\n{\r\nstruct obd_device *obddev = class_exp2obd(exp);\r\nstruct lov_obd *lov = &obddev->u.lov;\r\nint i, rc;\r\nif (!vallen || !val)\r\nreturn -EFAULT;\r\nobd_getref(obddev);\r\nif (KEY_IS(KEY_LOCK_TO_STRIPE)) {\r\nstruct {\r\nchar name[16];\r\nstruct ldlm_lock *lock;\r\n} *data = key;\r\nstruct ldlm_res_id *res_id = &data->lock->l_resource->lr_name;\r\nstruct lov_oinfo *loi;\r\n__u32 *stripe = val;\r\nif (*vallen < sizeof(*stripe)) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\n*vallen = sizeof(*stripe);\r\nfor (i = 0; i < lsm->lsm_stripe_count; i++) {\r\nloi = lsm->lsm_oinfo[i];\r\nif (!lov->lov_tgts[loi->loi_ost_idx])\r\ncontinue;\r\nif (lov->lov_tgts[loi->loi_ost_idx]->ltd_exp ==\r\ndata->lock->l_conn_export &&\r\nostid_res_name_eq(&loi->loi_oi, res_id)) {\r\n*stripe = i;\r\nrc = 0;\r\ngoto out;\r\n}\r\n}\r\nLDLM_ERROR(data->lock, "lock on inode without such object");\r\ndump_lsm(D_ERROR, lsm);\r\nrc = -ENXIO;\r\ngoto out;\r\n} else if (KEY_IS(KEY_LAST_ID)) {\r\nstruct obd_id_info *info = val;\r\n__u32 size = sizeof(u64);\r\nstruct lov_tgt_desc *tgt;\r\nLASSERT(*vallen == sizeof(struct obd_id_info));\r\ntgt = lov->lov_tgts[info->idx];\r\nif (!tgt || !tgt->ltd_active) {\r\nrc = -ESRCH;\r\ngoto out;\r\n}\r\nrc = obd_get_info(env, tgt->ltd_exp, keylen, key,\r\n&size, info->data, NULL);\r\nrc = 0;\r\ngoto out;\r\n} else if (KEY_IS(KEY_LOVDESC)) {\r\nstruct lov_desc *desc_ret = val;\r\n*desc_ret = lov->desc;\r\nrc = 0;\r\ngoto out;\r\n} else if (KEY_IS(KEY_FIEMAP)) {\r\nrc = lov_fiemap(lov, keylen, key, vallen, val, lsm);\r\ngoto out;\r\n} else if (KEY_IS(KEY_CONNECT_FLAG)) {\r\nstruct lov_tgt_desc *tgt;\r\n__u64 ost_idx = *((__u64 *)val);\r\nLASSERT(*vallen == sizeof(__u64));\r\nLASSERT(ost_idx < lov->desc.ld_tgt_count);\r\ntgt = lov->lov_tgts[ost_idx];\r\nif (!tgt || !tgt->ltd_exp) {\r\nrc = -ESRCH;\r\ngoto out;\r\n}\r\n*((__u64 *)val) = exp_connect_flags(tgt->ltd_exp);\r\nrc = 0;\r\ngoto out;\r\n} else if (KEY_IS(KEY_TGT_COUNT)) {\r\n*((int *)val) = lov->desc.ld_tgt_count;\r\nrc = 0;\r\ngoto out;\r\n}\r\nrc = -EINVAL;\r\nout:\r\nobd_putref(obddev);\r\nreturn rc;\r\n}\r\nstatic int lov_set_info_async(const struct lu_env *env, struct obd_export *exp,\r\nu32 keylen, void *key, u32 vallen,\r\nvoid *val, struct ptlrpc_request_set *set)\r\n{\r\nstruct obd_device *obddev = class_exp2obd(exp);\r\nstruct lov_obd *lov = &obddev->u.lov;\r\nu32 count;\r\nint i, rc = 0, err;\r\nstruct lov_tgt_desc *tgt;\r\nunsigned incr, check_uuid,\r\ndo_inactive, no_set;\r\nunsigned next_id = 0, mds_con = 0, capa = 0;\r\nincr = check_uuid = do_inactive = no_set = 0;\r\nif (set == NULL) {\r\nno_set = 1;\r\nset = ptlrpc_prep_set();\r\nif (!set)\r\nreturn -ENOMEM;\r\n}\r\nobd_getref(obddev);\r\ncount = lov->desc.ld_tgt_count;\r\nif (KEY_IS(KEY_NEXT_ID)) {\r\ncount = vallen / sizeof(struct obd_id_info);\r\nvallen = sizeof(u64);\r\nincr = sizeof(struct obd_id_info);\r\ndo_inactive = 1;\r\nnext_id = 1;\r\n} else if (KEY_IS(KEY_CHECKSUM)) {\r\ndo_inactive = 1;\r\n} else if (KEY_IS(KEY_EVICT_BY_NID)) {\r\n} else if (KEY_IS(KEY_MDS_CONN)) {\r\nmds_con = 1;\r\n} else if (KEY_IS(KEY_CAPA_KEY)) {\r\ncapa = 1;\r\n} else if (KEY_IS(KEY_CACHE_SET)) {\r\nLASSERT(lov->lov_cache == NULL);\r\nlov->lov_cache = val;\r\ndo_inactive = 1;\r\n}\r\nfor (i = 0; i < count; i++, val = (char *)val + incr) {\r\nif (next_id) {\r\ntgt = lov->lov_tgts[((struct obd_id_info *)val)->idx];\r\n}\r\nvoid lov_stripe_unlock(struct lov_stripe_md *md)\r\n__releases(&md->lsm_lock\r\nstatic int lov_quotactl(struct obd_device *obd, struct obd_export *exp,\r\nstruct obd_quotactl *oqctl)\r\n{\r\nstruct lov_obd *lov = &obd->u.lov;\r\nstruct lov_tgt_desc *tgt;\r\n__u64 curspace = 0;\r\n__u64 bhardlimit = 0;\r\nint i, rc = 0;\r\nif (oqctl->qc_cmd != LUSTRE_Q_QUOTAON &&\r\noqctl->qc_cmd != LUSTRE_Q_QUOTAOFF &&\r\noqctl->qc_cmd != Q_GETOQUOTA &&\r\noqctl->qc_cmd != Q_INITQUOTA &&\r\noqctl->qc_cmd != LUSTRE_Q_SETQUOTA &&\r\noqctl->qc_cmd != Q_FINVALIDATE) {\r\nCERROR("bad quota opc %x for lov obd", oqctl->qc_cmd);\r\nreturn -EFAULT;\r\n}\r\nobd_getref(obd);\r\nfor (i = 0; i < lov->desc.ld_tgt_count; i++) {\r\nint err;\r\ntgt = lov->lov_tgts[i];\r\nif (!tgt)\r\ncontinue;\r\nif (!tgt->ltd_active || tgt->ltd_reap) {\r\nif (oqctl->qc_cmd == Q_GETOQUOTA &&\r\nlov->lov_tgts[i]->ltd_activate) {\r\nrc = -EREMOTEIO;\r\nCERROR("ost %d is inactive\n", i);\r\n} else {\r\nCDEBUG(D_HA, "ost %d is inactive\n", i);\r\n}\r\ncontinue;\r\n}\r\nerr = obd_quotactl(tgt->ltd_exp, oqctl);\r\nif (err) {\r\nif (tgt->ltd_active && !rc)\r\nrc = err;\r\ncontinue;\r\n}\r\nif (oqctl->qc_cmd == Q_GETOQUOTA) {\r\ncurspace += oqctl->qc_dqblk.dqb_curspace;\r\nbhardlimit += oqctl->qc_dqblk.dqb_bhardlimit;\r\n}\r\n}\r\nobd_putref(obd);\r\nif (oqctl->qc_cmd == Q_GETOQUOTA) {\r\noqctl->qc_dqblk.dqb_curspace = curspace;\r\noqctl->qc_dqblk.dqb_bhardlimit = bhardlimit;\r\n}\r\nreturn rc;\r\n}\r\nstatic int lov_quotacheck(struct obd_device *obd, struct obd_export *exp,\r\nstruct obd_quotactl *oqctl)\r\n{\r\nstruct lov_obd *lov = &obd->u.lov;\r\nint i, rc = 0;\r\nobd_getref(obd);\r\nfor (i = 0; i < lov->desc.ld_tgt_count; i++) {\r\nif (!lov->lov_tgts[i])\r\ncontinue;\r\nif (!lov->lov_tgts[i]->ltd_activate) {\r\nCWARN("lov idx %d was administratively disabled, skip quotacheck on it.\n",\r\ni);\r\ncontinue;\r\n}\r\nif (!lov->lov_tgts[i]->ltd_active) {\r\nCERROR("lov idx %d inactive\n", i);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\n}\r\nfor (i = 0; i < lov->desc.ld_tgt_count; i++) {\r\nint err;\r\nif (!lov->lov_tgts[i] || !lov->lov_tgts[i]->ltd_activate)\r\ncontinue;\r\nerr = obd_quotacheck(lov->lov_tgts[i]->ltd_exp, oqctl);\r\nif (err && !rc)\r\nrc = err;\r\n}\r\nout:\r\nobd_putref(obd);\r\nreturn rc;\r\n}\r\nint __init lov_init(void)\r\n{\r\nstruct lprocfs_static_vars lvars = { NULL };\r\nint rc;\r\nCDEBUG(D_INFO, "Lustre LOV module (%p).\n", &lov_caches);\r\nrc = lu_kmem_init(lov_caches);\r\nif (rc)\r\nreturn rc;\r\nlov_oinfo_slab = kmem_cache_create("lov_oinfo",\r\nsizeof(struct lov_oinfo),\r\n0, SLAB_HWCACHE_ALIGN, NULL);\r\nif (lov_oinfo_slab == NULL) {\r\nlu_kmem_fini(lov_caches);\r\nreturn -ENOMEM;\r\n}\r\nlprocfs_lov_init_vars(&lvars);\r\nrc = class_register_type(&lov_obd_ops, NULL, lvars.module_vars,\r\nLUSTRE_LOV_NAME, &lov_device_type);\r\nif (rc) {\r\nkmem_cache_destroy(lov_oinfo_slab);\r\nlu_kmem_fini(lov_caches);\r\n}\r\nreturn rc;\r\n}\r\nstatic void lov_exit(void)\r\n{\r\nclass_unregister_type(LUSTRE_LOV_NAME);\r\nkmem_cache_destroy(lov_oinfo_slab);\r\nlu_kmem_fini(lov_caches);\r\n}
