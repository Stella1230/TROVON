static int cypress_compute_slot(struct mt_device *td)\r\n{\r\nif (td->curdata.contactid != 0 || td->num_received == 0)\r\nreturn td->curdata.contactid;\r\nelse\r\nreturn -1;\r\n}\r\nstatic ssize_t mt_show_quirks(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct mt_device *td = hid_get_drvdata(hdev);\r\nreturn sprintf(buf, "%u\n", td->mtclass.quirks);\r\n}\r\nstatic ssize_t mt_set_quirks(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct mt_device *td = hid_get_drvdata(hdev);\r\nunsigned long val;\r\nif (kstrtoul(buf, 0, &val))\r\nreturn -EINVAL;\r\ntd->mtclass.quirks = val;\r\nif (td->cc_index < 0)\r\ntd->mtclass.quirks &= ~MT_QUIRK_CONTACT_CNT_ACCURATE;\r\nreturn count;\r\n}\r\nstatic void mt_feature_mapping(struct hid_device *hdev,\r\nstruct hid_field *field, struct hid_usage *usage)\r\n{\r\nstruct mt_device *td = hid_get_drvdata(hdev);\r\nswitch (usage->hid) {\r\ncase HID_DG_INPUTMODE:\r\nif (usage->usage_index >= field->report_count) {\r\ndev_err(&hdev->dev, "HID_DG_INPUTMODE out of range\n");\r\nbreak;\r\n}\r\ntd->inputmode = field->report->id;\r\ntd->inputmode_index = usage->usage_index;\r\nbreak;\r\ncase HID_DG_CONTACTMAX:\r\ntd->maxcontact_report_id = field->report->id;\r\ntd->maxcontacts = field->value[0];\r\nif (!td->maxcontacts &&\r\nfield->logical_maximum <= MT_MAX_MAXCONTACT)\r\ntd->maxcontacts = field->logical_maximum;\r\nif (td->mtclass.maxcontacts)\r\ntd->maxcontacts = td->mtclass.maxcontacts;\r\nbreak;\r\n}\r\n}\r\nstatic void set_abs(struct input_dev *input, unsigned int code,\r\nstruct hid_field *field, int snratio)\r\n{\r\nint fmin = field->logical_minimum;\r\nint fmax = field->logical_maximum;\r\nint fuzz = snratio ? (fmax - fmin) / snratio : 0;\r\ninput_set_abs_params(input, code, fmin, fmax, fuzz, 0);\r\ninput_abs_set_res(input, code, hidinput_calc_abs_res(field, code));\r\n}\r\nstatic void mt_store_field(struct hid_usage *usage, struct mt_device *td,\r\nstruct hid_input *hi)\r\n{\r\nstruct mt_fields *f = td->fields;\r\nif (f->length >= HID_MAX_FIELDS)\r\nreturn;\r\nf->usages[f->length++] = usage->hid;\r\n}\r\nstatic int mt_touch_input_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nstruct mt_device *td = hid_get_drvdata(hdev);\r\nstruct mt_class *cls = &td->mtclass;\r\nint code;\r\nstruct hid_usage *prev_usage = NULL;\r\nif (field->application == HID_DG_TOUCHSCREEN)\r\ntd->mt_flags |= INPUT_MT_DIRECT;\r\nif (field->application == HID_DG_TOUCHPAD ||\r\n(usage->hid & HID_USAGE_PAGE) == HID_UP_BUTTON) {\r\ntd->mt_flags |= INPUT_MT_POINTER;\r\ntd->inputmode_value = MT_INPUTMODE_TOUCHPAD;\r\n}\r\nif (usage->usage_index)\r\nprev_usage = &field->usage[usage->usage_index - 1];\r\nswitch (usage->hid & HID_USAGE_PAGE) {\r\ncase HID_UP_GENDESK:\r\nswitch (usage->hid) {\r\ncase HID_GD_X:\r\nif (prev_usage && (prev_usage->hid == usage->hid)) {\r\nhid_map_usage(hi, usage, bit, max,\r\nEV_ABS, ABS_MT_TOOL_X);\r\nset_abs(hi->input, ABS_MT_TOOL_X, field,\r\ncls->sn_move);\r\n} else {\r\nhid_map_usage(hi, usage, bit, max,\r\nEV_ABS, ABS_MT_POSITION_X);\r\nset_abs(hi->input, ABS_MT_POSITION_X, field,\r\ncls->sn_move);\r\n}\r\nmt_store_field(usage, td, hi);\r\nreturn 1;\r\ncase HID_GD_Y:\r\nif (prev_usage && (prev_usage->hid == usage->hid)) {\r\nhid_map_usage(hi, usage, bit, max,\r\nEV_ABS, ABS_MT_TOOL_Y);\r\nset_abs(hi->input, ABS_MT_TOOL_Y, field,\r\ncls->sn_move);\r\n} else {\r\nhid_map_usage(hi, usage, bit, max,\r\nEV_ABS, ABS_MT_POSITION_Y);\r\nset_abs(hi->input, ABS_MT_POSITION_Y, field,\r\ncls->sn_move);\r\n}\r\nmt_store_field(usage, td, hi);\r\nreturn 1;\r\n}\r\nreturn 0;\r\ncase HID_UP_DIGITIZER:\r\nswitch (usage->hid) {\r\ncase HID_DG_INRANGE:\r\nif (cls->quirks & MT_QUIRK_HOVERING) {\r\nhid_map_usage(hi, usage, bit, max,\r\nEV_ABS, ABS_MT_DISTANCE);\r\ninput_set_abs_params(hi->input,\r\nABS_MT_DISTANCE, 0, 1, 0, 0);\r\n}\r\nmt_store_field(usage, td, hi);\r\nreturn 1;\r\ncase HID_DG_CONFIDENCE:\r\nmt_store_field(usage, td, hi);\r\nreturn 1;\r\ncase HID_DG_TIPSWITCH:\r\nhid_map_usage(hi, usage, bit, max, EV_KEY, BTN_TOUCH);\r\ninput_set_capability(hi->input, EV_KEY, BTN_TOUCH);\r\nmt_store_field(usage, td, hi);\r\nreturn 1;\r\ncase HID_DG_CONTACTID:\r\nmt_store_field(usage, td, hi);\r\ntd->touches_by_report++;\r\ntd->mt_report_id = field->report->id;\r\nreturn 1;\r\ncase HID_DG_WIDTH:\r\nhid_map_usage(hi, usage, bit, max,\r\nEV_ABS, ABS_MT_TOUCH_MAJOR);\r\nif (!(cls->quirks & MT_QUIRK_NO_AREA))\r\nset_abs(hi->input, ABS_MT_TOUCH_MAJOR, field,\r\ncls->sn_width);\r\nmt_store_field(usage, td, hi);\r\nreturn 1;\r\ncase HID_DG_HEIGHT:\r\nhid_map_usage(hi, usage, bit, max,\r\nEV_ABS, ABS_MT_TOUCH_MINOR);\r\nif (!(cls->quirks & MT_QUIRK_NO_AREA)) {\r\nset_abs(hi->input, ABS_MT_TOUCH_MINOR, field,\r\ncls->sn_height);\r\ninput_set_abs_params(hi->input,\r\nABS_MT_ORIENTATION, 0, 1, 0, 0);\r\n}\r\nmt_store_field(usage, td, hi);\r\nreturn 1;\r\ncase HID_DG_TIPPRESSURE:\r\nhid_map_usage(hi, usage, bit, max,\r\nEV_ABS, ABS_MT_PRESSURE);\r\nset_abs(hi->input, ABS_MT_PRESSURE, field,\r\ncls->sn_pressure);\r\nmt_store_field(usage, td, hi);\r\nreturn 1;\r\ncase HID_DG_CONTACTCOUNT:\r\nif (field->index >= field->report->maxfield ||\r\nusage->usage_index >= field->report_count)\r\nreturn 1;\r\ntd->cc_index = field->index;\r\ntd->cc_value_index = usage->usage_index;\r\nreturn 1;\r\ncase HID_DG_CONTACTMAX:\r\nreturn -1;\r\ncase HID_DG_TOUCH:\r\nreturn -1;\r\n}\r\nreturn 0;\r\ncase HID_UP_BUTTON:\r\ncode = BTN_MOUSE + ((usage->hid - 1) & HID_USAGE);\r\nhid_map_usage(hi, usage, bit, max, EV_KEY, code);\r\ninput_set_capability(hi->input, EV_KEY, code);\r\nreturn 1;\r\ncase 0xff000000:\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt_touch_input_mapped(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nif (usage->type == EV_KEY || usage->type == EV_ABS)\r\nset_bit(usage->type, hi->input->evbit);\r\nreturn -1;\r\n}\r\nstatic int mt_compute_slot(struct mt_device *td, struct input_dev *input)\r\n{\r\n__s32 quirks = td->mtclass.quirks;\r\nif (quirks & MT_QUIRK_SLOT_IS_CONTACTID)\r\nreturn td->curdata.contactid;\r\nif (quirks & MT_QUIRK_CYPRESS)\r\nreturn cypress_compute_slot(td);\r\nif (quirks & MT_QUIRK_SLOT_IS_CONTACTNUMBER)\r\nreturn td->num_received;\r\nif (quirks & MT_QUIRK_SLOT_IS_CONTACTID_MINUS_ONE)\r\nreturn td->curdata.contactid - 1;\r\nreturn input_mt_get_slot_by_key(input, td->curdata.contactid);\r\n}\r\nstatic void mt_complete_slot(struct mt_device *td, struct input_dev *input)\r\n{\r\nif ((td->mtclass.quirks & MT_QUIRK_CONTACT_CNT_ACCURATE) &&\r\ntd->num_received >= td->num_expected)\r\nreturn;\r\nif (td->curvalid || (td->mtclass.quirks & MT_QUIRK_ALWAYS_VALID)) {\r\nint slotnum = mt_compute_slot(td, input);\r\nstruct mt_slot *s = &td->curdata;\r\nstruct input_mt *mt = input->mt;\r\nif (slotnum < 0 || slotnum >= td->maxcontacts)\r\nreturn;\r\nif ((td->mtclass.quirks & MT_QUIRK_IGNORE_DUPLICATES) && mt) {\r\nstruct input_mt_slot *slot = &mt->slots[slotnum];\r\nif (input_mt_is_active(slot) &&\r\ninput_mt_is_used(mt, slot))\r\nreturn;\r\n}\r\ninput_mt_slot(input, slotnum);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER,\r\ns->touch_state || s->inrange_state);\r\nif (s->touch_state || s->inrange_state) {\r\nint wide = (s->w > s->h);\r\nint major = max(s->w, s->h) >> 1;\r\nint minor = min(s->w, s->h) >> 1;\r\ninput_event(input, EV_ABS, ABS_MT_POSITION_X, s->x);\r\ninput_event(input, EV_ABS, ABS_MT_POSITION_Y, s->y);\r\ninput_event(input, EV_ABS, ABS_MT_TOOL_X, s->cx);\r\ninput_event(input, EV_ABS, ABS_MT_TOOL_Y, s->cy);\r\ninput_event(input, EV_ABS, ABS_MT_DISTANCE,\r\n!s->touch_state);\r\ninput_event(input, EV_ABS, ABS_MT_ORIENTATION, wide);\r\ninput_event(input, EV_ABS, ABS_MT_PRESSURE, s->p);\r\ninput_event(input, EV_ABS, ABS_MT_TOUCH_MAJOR, major);\r\ninput_event(input, EV_ABS, ABS_MT_TOUCH_MINOR, minor);\r\n}\r\n}\r\ntd->num_received++;\r\n}\r\nstatic void mt_sync_frame(struct mt_device *td, struct input_dev *input)\r\n{\r\ninput_mt_sync_frame(input);\r\ninput_sync(input);\r\ntd->num_received = 0;\r\n}\r\nstatic int mt_touch_event(struct hid_device *hid, struct hid_field *field,\r\nstruct hid_usage *usage, __s32 value)\r\n{\r\nif (hid->claimed & HID_CLAIMED_HIDDEV && hid->hiddev_hid_event)\r\nhid->hiddev_hid_event(hid, field, usage, value);\r\nreturn 1;\r\n}\r\nstatic void mt_process_mt_event(struct hid_device *hid, struct hid_field *field,\r\nstruct hid_usage *usage, __s32 value)\r\n{\r\nstruct mt_device *td = hid_get_drvdata(hid);\r\n__s32 quirks = td->mtclass.quirks;\r\nstruct input_dev *input = field->hidinput->input;\r\nif (hid->claimed & HID_CLAIMED_INPUT) {\r\nswitch (usage->hid) {\r\ncase HID_DG_INRANGE:\r\nif (quirks & MT_QUIRK_VALID_IS_INRANGE)\r\ntd->curvalid = value;\r\nif (quirks & MT_QUIRK_HOVERING)\r\ntd->curdata.inrange_state = value;\r\nbreak;\r\ncase HID_DG_TIPSWITCH:\r\nif (quirks & MT_QUIRK_NOT_SEEN_MEANS_UP)\r\ntd->curvalid = value;\r\ntd->curdata.touch_state = value;\r\nbreak;\r\ncase HID_DG_CONFIDENCE:\r\nif (quirks & MT_QUIRK_VALID_IS_CONFIDENCE)\r\ntd->curvalid = value;\r\nbreak;\r\ncase HID_DG_CONTACTID:\r\ntd->curdata.contactid = value;\r\nbreak;\r\ncase HID_DG_TIPPRESSURE:\r\ntd->curdata.p = value;\r\nbreak;\r\ncase HID_GD_X:\r\nif (usage->code == ABS_MT_TOOL_X)\r\ntd->curdata.cx = value;\r\nelse\r\ntd->curdata.x = value;\r\nbreak;\r\ncase HID_GD_Y:\r\nif (usage->code == ABS_MT_TOOL_Y)\r\ntd->curdata.cy = value;\r\nelse\r\ntd->curdata.y = value;\r\nbreak;\r\ncase HID_DG_WIDTH:\r\ntd->curdata.w = value;\r\nbreak;\r\ncase HID_DG_HEIGHT:\r\ntd->curdata.h = value;\r\nbreak;\r\ncase HID_DG_CONTACTCOUNT:\r\nbreak;\r\ncase HID_DG_TOUCH:\r\nbreak;\r\ndefault:\r\nif (usage->type)\r\ninput_event(input, usage->type, usage->code,\r\nvalue);\r\nreturn;\r\n}\r\nif (usage->usage_index + 1 == field->report_count) {\r\nif (usage->hid == td->last_slot_field)\r\nmt_complete_slot(td, field->hidinput->input);\r\n}\r\n}\r\n}\r\nstatic void mt_touch_report(struct hid_device *hid, struct hid_report *report)\r\n{\r\nstruct mt_device *td = hid_get_drvdata(hid);\r\nstruct hid_field *field;\r\nunsigned count;\r\nint r, n;\r\nif (td->cc_index >= 0) {\r\nstruct hid_field *field = report->field[td->cc_index];\r\nint value = field->value[td->cc_value_index];\r\nif (value)\r\ntd->num_expected = value;\r\n}\r\nfor (r = 0; r < report->maxfield; r++) {\r\nfield = report->field[r];\r\ncount = field->report_count;\r\nif (!(HID_MAIN_ITEM_VARIABLE & field->flags))\r\ncontinue;\r\nfor (n = 0; n < count; n++)\r\nmt_process_mt_event(hid, field, &field->usage[n],\r\nfield->value[n]);\r\n}\r\nif (td->num_received >= td->num_expected)\r\nmt_sync_frame(td, report->field[0]->hidinput->input);\r\n}\r\nstatic void mt_touch_input_configured(struct hid_device *hdev,\r\nstruct hid_input *hi)\r\n{\r\nstruct mt_device *td = hid_get_drvdata(hdev);\r\nstruct mt_class *cls = &td->mtclass;\r\nstruct input_dev *input = hi->input;\r\nif (!td->maxcontacts)\r\ntd->maxcontacts = MT_DEFAULT_MAXCONTACT;\r\nmt_post_parse(td);\r\nif (td->serial_maybe)\r\nmt_post_parse_default_settings(td);\r\nif (cls->is_indirect)\r\ntd->mt_flags |= INPUT_MT_POINTER;\r\nif (cls->quirks & MT_QUIRK_NOT_SEEN_MEANS_UP)\r\ntd->mt_flags |= INPUT_MT_DROP_UNUSED;\r\ninput_mt_init_slots(input, td->maxcontacts, td->mt_flags);\r\ntd->mt_flags = 0;\r\n}\r\nstatic int mt_input_mapping(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nstruct mt_device *td = hid_get_drvdata(hdev);\r\nif (!td->mtclass.export_all_inputs &&\r\nfield->application != HID_DG_TOUCHSCREEN &&\r\nfield->application != HID_DG_PEN &&\r\nfield->application != HID_DG_TOUCHPAD)\r\nreturn -1;\r\nif (field->physical == HID_DG_STYLUS)\r\nreturn 0;\r\nif (field->application == HID_DG_TOUCHSCREEN ||\r\nfield->application == HID_DG_TOUCHPAD)\r\nreturn mt_touch_input_mapping(hdev, hi, field, usage, bit, max);\r\nreturn 0;\r\n}\r\nstatic int mt_input_mapped(struct hid_device *hdev, struct hid_input *hi,\r\nstruct hid_field *field, struct hid_usage *usage,\r\nunsigned long **bit, int *max)\r\n{\r\nif (field->physical == HID_DG_STYLUS)\r\nreturn 0;\r\nif (field->application == HID_DG_TOUCHSCREEN ||\r\nfield->application == HID_DG_TOUCHPAD)\r\nreturn mt_touch_input_mapped(hdev, hi, field, usage, bit, max);\r\nreturn 0;\r\n}\r\nstatic int mt_event(struct hid_device *hid, struct hid_field *field,\r\nstruct hid_usage *usage, __s32 value)\r\n{\r\nstruct mt_device *td = hid_get_drvdata(hid);\r\nif (field->report->id == td->mt_report_id)\r\nreturn mt_touch_event(hid, field, usage, value);\r\nreturn 0;\r\n}\r\nstatic void mt_report(struct hid_device *hid, struct hid_report *report)\r\n{\r\nstruct mt_device *td = hid_get_drvdata(hid);\r\nstruct hid_field *field = report->field[0];\r\nif (!(hid->claimed & HID_CLAIMED_INPUT))\r\nreturn;\r\nif (report->id == td->mt_report_id)\r\nreturn mt_touch_report(hid, report);\r\nif (field && field->hidinput && field->hidinput->input)\r\ninput_sync(field->hidinput->input);\r\n}\r\nstatic void mt_set_input_mode(struct hid_device *hdev)\r\n{\r\nstruct mt_device *td = hid_get_drvdata(hdev);\r\nstruct hid_report *r;\r\nstruct hid_report_enum *re;\r\nstruct mt_class *cls = &td->mtclass;\r\nchar *buf;\r\nint report_len;\r\nif (td->inputmode < 0)\r\nreturn;\r\nre = &(hdev->report_enum[HID_FEATURE_REPORT]);\r\nr = re->report_id_hash[td->inputmode];\r\nif (r) {\r\nif (cls->quirks & MT_QUIRK_FORCE_GET_FEATURE) {\r\nreport_len = hid_report_len(r);\r\nbuf = hid_alloc_report_buf(r, GFP_KERNEL);\r\nif (!buf) {\r\nhid_err(hdev, "failed to allocate buffer for report\n");\r\nreturn;\r\n}\r\nhid_hw_raw_request(hdev, r->id, buf, report_len,\r\nHID_FEATURE_REPORT,\r\nHID_REQ_GET_REPORT);\r\nkfree(buf);\r\n}\r\nr->field[0]->value[td->inputmode_index] = td->inputmode_value;\r\nhid_hw_request(hdev, r, HID_REQ_SET_REPORT);\r\n}\r\n}\r\nstatic void mt_set_maxcontacts(struct hid_device *hdev)\r\n{\r\nstruct mt_device *td = hid_get_drvdata(hdev);\r\nstruct hid_report *r;\r\nstruct hid_report_enum *re;\r\nint fieldmax, max;\r\nif (td->maxcontact_report_id < 0)\r\nreturn;\r\nif (!td->mtclass.maxcontacts)\r\nreturn;\r\nre = &hdev->report_enum[HID_FEATURE_REPORT];\r\nr = re->report_id_hash[td->maxcontact_report_id];\r\nif (r) {\r\nmax = td->mtclass.maxcontacts;\r\nfieldmax = r->field[0]->logical_maximum;\r\nmax = min(fieldmax, max);\r\nif (r->field[0]->value[0] != max) {\r\nr->field[0]->value[0] = max;\r\nhid_hw_request(hdev, r, HID_REQ_SET_REPORT);\r\n}\r\n}\r\n}\r\nstatic void mt_post_parse_default_settings(struct mt_device *td)\r\n{\r\n__s32 quirks = td->mtclass.quirks;\r\nif (td->touches_by_report == 1) {\r\nquirks |= MT_QUIRK_ALWAYS_VALID;\r\nquirks &= ~MT_QUIRK_NOT_SEEN_MEANS_UP;\r\nquirks &= ~MT_QUIRK_VALID_IS_INRANGE;\r\nquirks &= ~MT_QUIRK_VALID_IS_CONFIDENCE;\r\nquirks &= ~MT_QUIRK_CONTACT_CNT_ACCURATE;\r\n}\r\ntd->mtclass.quirks = quirks;\r\n}\r\nstatic void mt_post_parse(struct mt_device *td)\r\n{\r\nstruct mt_fields *f = td->fields;\r\nstruct mt_class *cls = &td->mtclass;\r\nif (td->touches_by_report > 0) {\r\nint field_count_per_touch = f->length / td->touches_by_report;\r\ntd->last_slot_field = f->usages[field_count_per_touch - 1];\r\n}\r\nif (td->cc_index < 0)\r\ncls->quirks &= ~MT_QUIRK_CONTACT_CNT_ACCURATE;\r\n}\r\nstatic void mt_input_configured(struct hid_device *hdev, struct hid_input *hi)\r\n{\r\nstruct mt_device *td = hid_get_drvdata(hdev);\r\nchar *name;\r\nconst char *suffix = NULL;\r\nstruct hid_field *field = hi->report->field[0];\r\nif (hi->report->id == td->mt_report_id)\r\nmt_touch_input_configured(hdev, hi);\r\nif (hi->report->field[0]->physical == HID_DG_STYLUS) {\r\nsuffix = "Pen";\r\n__set_bit(BTN_STYLUS, hi->input->keybit);\r\n} else {\r\nswitch (field->application) {\r\ncase HID_GD_KEYBOARD:\r\nsuffix = "Keyboard";\r\nbreak;\r\ncase HID_GD_KEYPAD:\r\nsuffix = "Keypad";\r\nbreak;\r\ncase HID_GD_MOUSE:\r\nsuffix = "Mouse";\r\nbreak;\r\ncase HID_DG_STYLUS:\r\nsuffix = "Pen";\r\n__set_bit(BTN_STYLUS, hi->input->keybit);\r\nbreak;\r\ncase HID_DG_TOUCHSCREEN:\r\nbreak;\r\ncase HID_GD_SYSTEM_CONTROL:\r\nsuffix = "System Control";\r\nbreak;\r\ncase HID_CP_CONSUMER_CONTROL:\r\nsuffix = "Consumer Control";\r\nbreak;\r\ndefault:\r\nsuffix = "UNKNOWN";\r\nbreak;\r\n}\r\n}\r\nif (suffix) {\r\nname = devm_kzalloc(&hi->input->dev,\r\nstrlen(hdev->name) + strlen(suffix) + 2,\r\nGFP_KERNEL);\r\nif (name) {\r\nsprintf(name, "%s %s", hdev->name, suffix);\r\nhi->input->name = name;\r\n}\r\n}\r\n}\r\nstatic int mt_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nint ret, i;\r\nstruct mt_device *td;\r\nstruct mt_class *mtclass = mt_classes;\r\nfor (i = 0; mt_classes[i].name ; i++) {\r\nif (id->driver_data == mt_classes[i].name) {\r\nmtclass = &(mt_classes[i]);\r\nbreak;\r\n}\r\n}\r\nhdev->quirks |= HID_QUIRK_NO_INPUT_SYNC;\r\nhdev->quirks |= HID_QUIRK_MULTI_INPUT;\r\nhdev->quirks |= HID_QUIRK_NO_EMPTY_INPUT;\r\nif (id->group == HID_GROUP_MULTITOUCH_WIN_8)\r\nhdev->quirks |= HID_QUIRK_NO_INIT_INPUT_REPORTS;\r\ntd = devm_kzalloc(&hdev->dev, sizeof(struct mt_device), GFP_KERNEL);\r\nif (!td) {\r\ndev_err(&hdev->dev, "cannot allocate multitouch data\n");\r\nreturn -ENOMEM;\r\n}\r\ntd->mtclass = *mtclass;\r\ntd->inputmode = -1;\r\ntd->maxcontact_report_id = -1;\r\ntd->inputmode_value = MT_INPUTMODE_TOUCHSCREEN;\r\ntd->cc_index = -1;\r\ntd->mt_report_id = -1;\r\nhid_set_drvdata(hdev, td);\r\ntd->fields = devm_kzalloc(&hdev->dev, sizeof(struct mt_fields),\r\nGFP_KERNEL);\r\nif (!td->fields) {\r\ndev_err(&hdev->dev, "cannot allocate multitouch fields data\n");\r\nreturn -ENOMEM;\r\n}\r\nif (id->vendor == HID_ANY_ID && id->product == HID_ANY_ID)\r\ntd->serial_maybe = true;\r\nret = hid_parse(hdev);\r\nif (ret != 0)\r\nreturn ret;\r\nret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nif (ret)\r\nreturn ret;\r\nret = sysfs_create_group(&hdev->dev.kobj, &mt_attribute_group);\r\nmt_set_maxcontacts(hdev);\r\nmt_set_input_mode(hdev);\r\ndevm_kfree(&hdev->dev, td->fields);\r\ntd->fields = NULL;\r\nreturn 0;\r\n}\r\nstatic int mt_reset_resume(struct hid_device *hdev)\r\n{\r\nmt_set_maxcontacts(hdev);\r\nmt_set_input_mode(hdev);\r\nreturn 0;\r\n}\r\nstatic int mt_resume(struct hid_device *hdev)\r\n{\r\nhid_hw_idle(hdev, 0, 0, HID_REQ_SET_IDLE);\r\nreturn 0;\r\n}\r\nstatic void mt_remove(struct hid_device *hdev)\r\n{\r\nsysfs_remove_group(&hdev->dev.kobj, &mt_attribute_group);\r\nhid_hw_stop(hdev);\r\n}
