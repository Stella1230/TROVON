static struct cuse_conn *fc_to_cc(struct fuse_conn *fc)\r\n{\r\nreturn container_of(fc, struct cuse_conn, fc);\r\n}\r\nstatic struct list_head *cuse_conntbl_head(dev_t devt)\r\n{\r\nreturn &cuse_conntbl[(MAJOR(devt) + MINOR(devt)) % CUSE_CONNTBL_LEN];\r\n}\r\nstatic ssize_t cuse_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nloff_t pos = 0;\r\nstruct iovec iov = { .iov_base = buf, .iov_len = count };\r\nstruct fuse_io_priv io = { .async = 0, .file = file };\r\nstruct iov_iter ii;\r\niov_iter_init(&ii, READ, &iov, 1, count);\r\nreturn fuse_direct_io(&io, &ii, &pos, FUSE_DIO_CUSE);\r\n}\r\nstatic ssize_t cuse_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nloff_t pos = 0;\r\nstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = count };\r\nstruct fuse_io_priv io = { .async = 0, .file = file };\r\nstruct iov_iter ii;\r\niov_iter_init(&ii, WRITE, &iov, 1, count);\r\nreturn fuse_direct_io(&io, &ii, &pos,\r\nFUSE_DIO_WRITE | FUSE_DIO_CUSE);\r\n}\r\nstatic int cuse_open(struct inode *inode, struct file *file)\r\n{\r\ndev_t devt = inode->i_cdev->dev;\r\nstruct cuse_conn *cc = NULL, *pos;\r\nint rc;\r\nmutex_lock(&cuse_lock);\r\nlist_for_each_entry(pos, cuse_conntbl_head(devt), list)\r\nif (pos->dev->devt == devt) {\r\nfuse_conn_get(&pos->fc);\r\ncc = pos;\r\nbreak;\r\n}\r\nmutex_unlock(&cuse_lock);\r\nif (!cc)\r\nreturn -ENODEV;\r\nrc = fuse_do_open(&cc->fc, 0, file, 0);\r\nif (rc)\r\nfuse_conn_put(&cc->fc);\r\nreturn rc;\r\n}\r\nstatic int cuse_release(struct inode *inode, struct file *file)\r\n{\r\nstruct fuse_file *ff = file->private_data;\r\nstruct fuse_conn *fc = ff->fc;\r\nfuse_sync_release(ff, file->f_flags);\r\nfuse_conn_put(fc);\r\nreturn 0;\r\n}\r\nstatic long cuse_file_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct fuse_file *ff = file->private_data;\r\nstruct cuse_conn *cc = fc_to_cc(ff->fc);\r\nunsigned int flags = 0;\r\nif (cc->unrestricted_ioctl)\r\nflags |= FUSE_IOCTL_UNRESTRICTED;\r\nreturn fuse_do_ioctl(file, cmd, arg, flags);\r\n}\r\nstatic long cuse_file_compat_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct fuse_file *ff = file->private_data;\r\nstruct cuse_conn *cc = fc_to_cc(ff->fc);\r\nunsigned int flags = FUSE_IOCTL_COMPAT;\r\nif (cc->unrestricted_ioctl)\r\nflags |= FUSE_IOCTL_UNRESTRICTED;\r\nreturn fuse_do_ioctl(file, cmd, arg, flags);\r\n}\r\nstatic int cuse_parse_one(char **pp, char *end, char **keyp, char **valp)\r\n{\r\nchar *p = *pp;\r\nchar *key, *val;\r\nwhile (p < end && *p == '\0')\r\np++;\r\nif (p == end)\r\nreturn 0;\r\nif (end[-1] != '\0') {\r\nprintk(KERN_ERR "CUSE: info not properly terminated\n");\r\nreturn -EINVAL;\r\n}\r\nkey = val = p;\r\np += strlen(p);\r\nif (valp) {\r\nstrsep(&val, "=");\r\nif (!val)\r\nval = key + strlen(key);\r\nkey = strstrip(key);\r\nval = strstrip(val);\r\n} else\r\nkey = strstrip(key);\r\nif (!strlen(key)) {\r\nprintk(KERN_ERR "CUSE: zero length info key specified\n");\r\nreturn -EINVAL;\r\n}\r\n*pp = p;\r\n*keyp = key;\r\nif (valp)\r\n*valp = val;\r\nreturn 1;\r\n}\r\nstatic int cuse_parse_devinfo(char *p, size_t len, struct cuse_devinfo *devinfo)\r\n{\r\nchar *end = p + len;\r\nchar *uninitialized_var(key), *uninitialized_var(val);\r\nint rc;\r\nwhile (true) {\r\nrc = cuse_parse_one(&p, end, &key, &val);\r\nif (rc < 0)\r\nreturn rc;\r\nif (!rc)\r\nbreak;\r\nif (strcmp(key, "DEVNAME") == 0)\r\ndevinfo->name = val;\r\nelse\r\nprintk(KERN_WARNING "CUSE: unknown device info \"%s\"\n",\r\nkey);\r\n}\r\nif (!devinfo->name || !strlen(devinfo->name)) {\r\nprintk(KERN_ERR "CUSE: DEVNAME unspecified\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void cuse_gendev_release(struct device *dev)\r\n{\r\nkfree(dev);\r\n}\r\nstatic void cuse_process_init_reply(struct fuse_conn *fc, struct fuse_req *req)\r\n{\r\nstruct cuse_conn *cc = fc_to_cc(fc), *pos;\r\nstruct cuse_init_out *arg = req->out.args[0].value;\r\nstruct page *page = req->pages[0];\r\nstruct cuse_devinfo devinfo = { };\r\nstruct device *dev;\r\nstruct cdev *cdev;\r\ndev_t devt;\r\nint rc, i;\r\nif (req->out.h.error ||\r\narg->major != FUSE_KERNEL_VERSION || arg->minor < 11) {\r\ngoto err;\r\n}\r\nfc->minor = arg->minor;\r\nfc->max_read = max_t(unsigned, arg->max_read, 4096);\r\nfc->max_write = max_t(unsigned, arg->max_write, 4096);\r\ncc->unrestricted_ioctl = arg->flags & CUSE_UNRESTRICTED_IOCTL;\r\nrc = cuse_parse_devinfo(page_address(page), req->out.args[1].size,\r\n&devinfo);\r\nif (rc)\r\ngoto err;\r\ndevt = MKDEV(arg->dev_major, arg->dev_minor);\r\nif (!MAJOR(devt))\r\nrc = alloc_chrdev_region(&devt, MINOR(devt), 1, devinfo.name);\r\nelse\r\nrc = register_chrdev_region(devt, 1, devinfo.name);\r\nif (rc) {\r\nprintk(KERN_ERR "CUSE: failed to register chrdev region\n");\r\ngoto err;\r\n}\r\nrc = -ENOMEM;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\ngoto err_region;\r\ndevice_initialize(dev);\r\ndev_set_uevent_suppress(dev, 1);\r\ndev->class = cuse_class;\r\ndev->devt = devt;\r\ndev->release = cuse_gendev_release;\r\ndev_set_drvdata(dev, cc);\r\ndev_set_name(dev, "%s", devinfo.name);\r\nmutex_lock(&cuse_lock);\r\nfor (i = 0; i < CUSE_CONNTBL_LEN; ++i) {\r\nlist_for_each_entry(pos, &cuse_conntbl[i], list)\r\nif (!strcmp(dev_name(pos->dev), dev_name(dev)))\r\ngoto err_unlock;\r\n}\r\nrc = device_add(dev);\r\nif (rc)\r\ngoto err_unlock;\r\nrc = -ENOMEM;\r\ncdev = cdev_alloc();\r\nif (!cdev)\r\ngoto err_unlock;\r\ncdev->owner = THIS_MODULE;\r\ncdev->ops = &cuse_frontend_fops;\r\nrc = cdev_add(cdev, devt, 1);\r\nif (rc)\r\ngoto err_cdev;\r\ncc->dev = dev;\r\ncc->cdev = cdev;\r\nlist_add(&cc->list, cuse_conntbl_head(devt));\r\nmutex_unlock(&cuse_lock);\r\ndev_set_uevent_suppress(dev, 0);\r\nkobject_uevent(&dev->kobj, KOBJ_ADD);\r\nout:\r\nkfree(arg);\r\n__free_page(page);\r\nreturn;\r\nerr_cdev:\r\ncdev_del(cdev);\r\nerr_unlock:\r\nmutex_unlock(&cuse_lock);\r\nput_device(dev);\r\nerr_region:\r\nunregister_chrdev_region(devt, 1);\r\nerr:\r\nfuse_abort_conn(fc);\r\ngoto out;\r\n}\r\nstatic int cuse_send_init(struct cuse_conn *cc)\r\n{\r\nint rc;\r\nstruct fuse_req *req;\r\nstruct page *page;\r\nstruct fuse_conn *fc = &cc->fc;\r\nstruct cuse_init_in *arg;\r\nvoid *outarg;\r\nBUILD_BUG_ON(CUSE_INIT_INFO_MAX > PAGE_SIZE);\r\nreq = fuse_get_req_for_background(fc, 1);\r\nif (IS_ERR(req)) {\r\nrc = PTR_ERR(req);\r\ngoto err;\r\n}\r\nrc = -ENOMEM;\r\npage = alloc_page(GFP_KERNEL | __GFP_ZERO);\r\nif (!page)\r\ngoto err_put_req;\r\noutarg = kzalloc(sizeof(struct cuse_init_out), GFP_KERNEL);\r\nif (!outarg)\r\ngoto err_free_page;\r\narg = &req->misc.cuse_init_in;\r\narg->major = FUSE_KERNEL_VERSION;\r\narg->minor = FUSE_KERNEL_MINOR_VERSION;\r\narg->flags |= CUSE_UNRESTRICTED_IOCTL;\r\nreq->in.h.opcode = CUSE_INIT;\r\nreq->in.numargs = 1;\r\nreq->in.args[0].size = sizeof(struct cuse_init_in);\r\nreq->in.args[0].value = arg;\r\nreq->out.numargs = 2;\r\nreq->out.args[0].size = sizeof(struct cuse_init_out);\r\nreq->out.args[0].value = outarg;\r\nreq->out.args[1].size = CUSE_INIT_INFO_MAX;\r\nreq->out.argvar = 1;\r\nreq->out.argpages = 1;\r\nreq->pages[0] = page;\r\nreq->page_descs[0].length = req->out.args[1].size;\r\nreq->num_pages = 1;\r\nreq->end = cuse_process_init_reply;\r\nfuse_request_send_background(fc, req);\r\nreturn 0;\r\nerr_free_page:\r\n__free_page(page);\r\nerr_put_req:\r\nfuse_put_request(fc, req);\r\nerr:\r\nreturn rc;\r\n}\r\nstatic void cuse_fc_release(struct fuse_conn *fc)\r\n{\r\nstruct cuse_conn *cc = fc_to_cc(fc);\r\nkfree_rcu(cc, fc.rcu);\r\n}\r\nstatic int cuse_channel_open(struct inode *inode, struct file *file)\r\n{\r\nstruct cuse_conn *cc;\r\nint rc;\r\ncc = kzalloc(sizeof(*cc), GFP_KERNEL);\r\nif (!cc)\r\nreturn -ENOMEM;\r\nfuse_conn_init(&cc->fc);\r\nINIT_LIST_HEAD(&cc->list);\r\ncc->fc.release = cuse_fc_release;\r\ncc->fc.connected = 1;\r\ncc->fc.initialized = 1;\r\nrc = cuse_send_init(cc);\r\nif (rc) {\r\nfuse_conn_put(&cc->fc);\r\nreturn rc;\r\n}\r\nfile->private_data = &cc->fc;\r\nreturn 0;\r\n}\r\nstatic int cuse_channel_release(struct inode *inode, struct file *file)\r\n{\r\nstruct cuse_conn *cc = fc_to_cc(file->private_data);\r\nint rc;\r\nmutex_lock(&cuse_lock);\r\nlist_del_init(&cc->list);\r\nmutex_unlock(&cuse_lock);\r\nif (cc->dev)\r\ndevice_unregister(cc->dev);\r\nif (cc->cdev) {\r\nunregister_chrdev_region(cc->cdev->dev, 1);\r\ncdev_del(cc->cdev);\r\n}\r\nrc = fuse_dev_release(inode, file);\r\nreturn rc;\r\n}\r\nstatic ssize_t cuse_class_waiting_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct cuse_conn *cc = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", atomic_read(&cc->fc.num_waiting));\r\n}\r\nstatic ssize_t cuse_class_abort_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct cuse_conn *cc = dev_get_drvdata(dev);\r\nfuse_abort_conn(&cc->fc);\r\nreturn count;\r\n}\r\nstatic int __init cuse_init(void)\r\n{\r\nint i, rc;\r\nfor (i = 0; i < CUSE_CONNTBL_LEN; i++)\r\nINIT_LIST_HEAD(&cuse_conntbl[i]);\r\ncuse_channel_fops = fuse_dev_operations;\r\ncuse_channel_fops.owner = THIS_MODULE;\r\ncuse_channel_fops.open = cuse_channel_open;\r\ncuse_channel_fops.release = cuse_channel_release;\r\ncuse_class = class_create(THIS_MODULE, "cuse");\r\nif (IS_ERR(cuse_class))\r\nreturn PTR_ERR(cuse_class);\r\ncuse_class->dev_groups = cuse_class_dev_groups;\r\nrc = misc_register(&cuse_miscdev);\r\nif (rc) {\r\nclass_destroy(cuse_class);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit cuse_exit(void)\r\n{\r\nmisc_deregister(&cuse_miscdev);\r\nclass_destroy(cuse_class);\r\n}
