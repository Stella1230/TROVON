static bool is_componentized(struct device *dev)\r\n{\r\nreturn dev->of_node || dev->platform_data;\r\n}\r\nstatic void armada_drm_unref_work(struct work_struct *work)\r\n{\r\nstruct armada_private *priv =\r\ncontainer_of(work, struct armada_private, fb_unref_work);\r\nstruct drm_framebuffer *fb;\r\nwhile (kfifo_get(&priv->fb_unref, &fb))\r\ndrm_framebuffer_unreference(fb);\r\n}\r\nvoid __armada_drm_queue_unref_work(struct drm_device *dev,\r\nstruct drm_framebuffer *fb)\r\n{\r\nstruct armada_private *priv = dev->dev_private;\r\nWARN_ON(!kfifo_put(&priv->fb_unref, fb));\r\nschedule_work(&priv->fb_unref_work);\r\n}\r\nvoid armada_drm_queue_unref_work(struct drm_device *dev,\r\nstruct drm_framebuffer *fb)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\n__armada_drm_queue_unref_work(dev, fb);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nstatic int armada_drm_load(struct drm_device *dev, unsigned long flags)\r\n{\r\nconst struct platform_device_id *id;\r\nconst struct armada_variant *variant;\r\nstruct armada_private *priv;\r\nstruct resource *res[ARRAY_SIZE(priv->dcrtc)];\r\nstruct resource *mem = NULL;\r\nint ret, n, i;\r\nmemset(res, 0, sizeof(res));\r\nfor (n = i = 0; ; n++) {\r\nstruct resource *r = platform_get_resource(dev->platformdev,\r\nIORESOURCE_MEM, n);\r\nif (!r)\r\nbreak;\r\nif (resource_size(r) > SZ_64K)\r\nmem = r;\r\nelse if (i < ARRAY_SIZE(priv->dcrtc))\r\nres[i++] = r;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nif (!mem)\r\nreturn -ENXIO;\r\nif (!devm_request_mem_region(dev->dev, mem->start,\r\nresource_size(mem), "armada-drm"))\r\nreturn -EBUSY;\r\npriv = devm_kzalloc(dev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\nDRM_ERROR("failed to allocate private\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(dev->platformdev, dev);\r\ndev->dev_private = priv;\r\nid = platform_get_device_id(dev->platformdev);\r\nif (!id)\r\nreturn -ENXIO;\r\nvariant = (const struct armada_variant *)id->driver_data;\r\nINIT_WORK(&priv->fb_unref_work, armada_drm_unref_work);\r\nINIT_KFIFO(priv->fb_unref);\r\ndrm_mode_config_init(dev);\r\ndev->mode_config.min_width = 320;\r\ndev->mode_config.min_height = 200;\r\ndev->mode_config.max_width = 1920;\r\ndev->mode_config.max_height = 2048;\r\ndev->mode_config.preferred_depth = 24;\r\ndev->mode_config.funcs = &armada_drm_mode_config_funcs;\r\ndrm_mm_init(&priv->linear, mem->start, resource_size(mem));\r\nfor (n = 0; n < ARRAY_SIZE(priv->dcrtc); n++) {\r\nint irq;\r\nif (!res[n])\r\nbreak;\r\nirq = platform_get_irq(dev->platformdev, n);\r\nif (irq < 0)\r\ngoto err_kms;\r\nret = armada_drm_crtc_create(dev, dev->dev, res[n], irq,\r\nvariant, NULL);\r\nif (ret)\r\ngoto err_kms;\r\n}\r\nif (is_componentized(dev->dev)) {\r\nret = component_bind_all(dev->dev, dev);\r\nif (ret)\r\ngoto err_kms;\r\n} else {\r\n#ifdef CONFIG_DRM_ARMADA_TDA1998X\r\nret = armada_drm_connector_slave_create(dev, &tda19988_config);\r\nif (ret)\r\ngoto err_kms;\r\n#endif\r\n}\r\nret = drm_vblank_init(dev, dev->mode_config.num_crtc);\r\nif (ret)\r\ngoto err_comp;\r\ndev->irq_enabled = true;\r\ndev->vblank_disable_allowed = 1;\r\nret = armada_fbdev_init(dev);\r\nif (ret)\r\ngoto err_comp;\r\ndrm_kms_helper_poll_init(dev);\r\nreturn 0;\r\nerr_comp:\r\nif (is_componentized(dev->dev))\r\ncomponent_unbind_all(dev->dev, dev);\r\nerr_kms:\r\ndrm_mode_config_cleanup(dev);\r\ndrm_mm_takedown(&priv->linear);\r\nflush_work(&priv->fb_unref_work);\r\nreturn ret;\r\n}\r\nstatic int armada_drm_unload(struct drm_device *dev)\r\n{\r\nstruct armada_private *priv = dev->dev_private;\r\ndrm_kms_helper_poll_fini(dev);\r\narmada_fbdev_fini(dev);\r\nif (is_componentized(dev->dev))\r\ncomponent_unbind_all(dev->dev, dev);\r\ndrm_mode_config_cleanup(dev);\r\ndrm_mm_takedown(&priv->linear);\r\nflush_work(&priv->fb_unref_work);\r\ndev->dev_private = NULL;\r\nreturn 0;\r\n}\r\nvoid armada_drm_vbl_event_add(struct armada_crtc *dcrtc,\r\nstruct armada_vbl_event *evt)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dcrtc->irq_lock, flags);\r\nif (list_empty(&evt->node)) {\r\nlist_add_tail(&evt->node, &dcrtc->vbl_list);\r\ndrm_vblank_get(dcrtc->crtc.dev, dcrtc->num);\r\n}\r\nspin_unlock_irqrestore(&dcrtc->irq_lock, flags);\r\n}\r\nvoid armada_drm_vbl_event_remove(struct armada_crtc *dcrtc,\r\nstruct armada_vbl_event *evt)\r\n{\r\nif (!list_empty(&evt->node)) {\r\nlist_del_init(&evt->node);\r\ndrm_vblank_put(dcrtc->crtc.dev, dcrtc->num);\r\n}\r\n}\r\nvoid armada_drm_vbl_event_remove_unlocked(struct armada_crtc *dcrtc,\r\nstruct armada_vbl_event *evt)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dcrtc->irq_lock, flags);\r\narmada_drm_vbl_event_remove(dcrtc, evt);\r\nspin_unlock_irqrestore(&dcrtc->irq_lock, flags);\r\n}\r\nstatic int armada_drm_enable_vblank(struct drm_device *dev, int crtc)\r\n{\r\nstruct armada_private *priv = dev->dev_private;\r\narmada_drm_crtc_enable_irq(priv->dcrtc[crtc], VSYNC_IRQ_ENA);\r\nreturn 0;\r\n}\r\nstatic void armada_drm_disable_vblank(struct drm_device *dev, int crtc)\r\n{\r\nstruct armada_private *priv = dev->dev_private;\r\narmada_drm_crtc_disable_irq(priv->dcrtc[crtc], VSYNC_IRQ_ENA);\r\n}\r\nstatic void armada_drm_lastclose(struct drm_device *dev)\r\n{\r\narmada_fbdev_lastclose(dev);\r\n}\r\nstatic int armada_drm_bind(struct device *dev)\r\n{\r\nreturn drm_platform_init(&armada_drm_driver, to_platform_device(dev));\r\n}\r\nstatic void armada_drm_unbind(struct device *dev)\r\n{\r\ndrm_put_dev(dev_get_drvdata(dev));\r\n}\r\nstatic int compare_of(struct device *dev, void *data)\r\n{\r\nreturn dev->of_node == data;\r\n}\r\nstatic int compare_dev_name(struct device *dev, void *data)\r\n{\r\nconst char *name = data;\r\nreturn !strcmp(dev_name(dev), name);\r\n}\r\nstatic void armada_add_endpoints(struct device *dev,\r\nstruct component_match **match, struct device_node *port)\r\n{\r\nstruct device_node *ep, *remote;\r\nfor_each_child_of_node(port, ep) {\r\nremote = of_graph_get_remote_port_parent(ep);\r\nif (!remote || !of_device_is_available(remote)) {\r\nof_node_put(remote);\r\ncontinue;\r\n} else if (!of_device_is_available(remote->parent)) {\r\ndev_warn(dev, "parent device of %s is not available\n",\r\nremote->full_name);\r\nof_node_put(remote);\r\ncontinue;\r\n}\r\ncomponent_match_add(dev, match, compare_of, remote);\r\nof_node_put(remote);\r\n}\r\n}\r\nstatic int armada_drm_find_components(struct device *dev,\r\nstruct component_match **match)\r\n{\r\nstruct device_node *port;\r\nint i;\r\nif (dev->of_node) {\r\nstruct device_node *np = dev->of_node;\r\nfor (i = 0; ; i++) {\r\nport = of_parse_phandle(np, "ports", i);\r\nif (!port)\r\nbreak;\r\ncomponent_match_add(dev, match, compare_of, port);\r\nof_node_put(port);\r\n}\r\nif (i == 0) {\r\ndev_err(dev, "missing 'ports' property\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; ; i++) {\r\nport = of_parse_phandle(np, "ports", i);\r\nif (!port)\r\nbreak;\r\narmada_add_endpoints(dev, match, port);\r\nof_node_put(port);\r\n}\r\n} else if (dev->platform_data) {\r\nchar **devices = dev->platform_data;\r\nstruct device *d;\r\nfor (i = 0; devices[i]; i++)\r\ncomponent_match_add(dev, match, compare_dev_name,\r\ndevices[i]);\r\nif (i == 0) {\r\ndev_err(dev, "missing 'ports' property\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; devices[i]; i++) {\r\nd = bus_find_device_by_name(&platform_bus_type, NULL,\r\ndevices[i]);\r\nif (d && d->of_node) {\r\nfor_each_child_of_node(d->of_node, port)\r\narmada_add_endpoints(dev, match, port);\r\n}\r\nput_device(d);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int armada_drm_probe(struct platform_device *pdev)\r\n{\r\nif (is_componentized(&pdev->dev)) {\r\nstruct component_match *match = NULL;\r\nint ret;\r\nret = armada_drm_find_components(&pdev->dev, &match);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn component_master_add_with_match(&pdev->dev,\r\n&armada_master_ops, match);\r\n} else {\r\nreturn drm_platform_init(&armada_drm_driver, pdev);\r\n}\r\n}\r\nstatic int armada_drm_remove(struct platform_device *pdev)\r\n{\r\nif (is_componentized(&pdev->dev))\r\ncomponent_master_del(&pdev->dev, &armada_master_ops);\r\nelse\r\ndrm_put_dev(platform_get_drvdata(pdev));\r\nreturn 0;\r\n}\r\nstatic int __init armada_drm_init(void)\r\n{\r\nint ret;\r\narmada_drm_driver.num_ioctls = ARRAY_SIZE(armada_ioctls);\r\nret = platform_driver_register(&armada_lcd_platform_driver);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&armada_drm_platform_driver);\r\nif (ret)\r\nplatform_driver_unregister(&armada_lcd_platform_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit armada_drm_exit(void)\r\n{\r\nplatform_driver_unregister(&armada_drm_platform_driver);\r\nplatform_driver_unregister(&armada_lcd_platform_driver);\r\n}
