static int nf_ct_frag6_sysctl_register(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\nstruct ctl_table_header *hdr;\r\ntable = nf_ct_frag6_sysctl_table;\r\nif (!net_eq(net, &init_net)) {\r\ntable = kmemdup(table, sizeof(nf_ct_frag6_sysctl_table),\r\nGFP_KERNEL);\r\nif (table == NULL)\r\ngoto err_alloc;\r\ntable[0].data = &net->nf_frag.frags.timeout;\r\ntable[1].data = &net->nf_frag.frags.low_thresh;\r\ntable[1].extra2 = &net->nf_frag.frags.high_thresh;\r\ntable[2].data = &net->nf_frag.frags.high_thresh;\r\ntable[2].extra1 = &net->nf_frag.frags.low_thresh;\r\ntable[2].extra2 = &init_net.nf_frag.frags.high_thresh;\r\n}\r\nhdr = register_net_sysctl(net, "net/netfilter", table);\r\nif (hdr == NULL)\r\ngoto err_reg;\r\nnet->nf_frag.sysctl.frags_hdr = hdr;\r\nreturn 0;\r\nerr_reg:\r\nif (!net_eq(net, &init_net))\r\nkfree(table);\r\nerr_alloc:\r\nreturn -ENOMEM;\r\n}\r\nstatic void __net_exit nf_ct_frags6_sysctl_unregister(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\ntable = net->nf_frag.sysctl.frags_hdr->ctl_table_arg;\r\nunregister_net_sysctl_table(net->nf_frag.sysctl.frags_hdr);\r\nif (!net_eq(net, &init_net))\r\nkfree(table);\r\n}\r\nstatic int nf_ct_frag6_sysctl_register(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __net_exit nf_ct_frags6_sysctl_unregister(struct net *net)\r\n{\r\n}\r\nstatic inline u8 ip6_frag_ecn(const struct ipv6hdr *ipv6h)\r\n{\r\nreturn 1 << (ipv6_get_dsfield(ipv6h) & INET_ECN_MASK);\r\n}\r\nstatic unsigned int nf_hash_frag(__be32 id, const struct in6_addr *saddr,\r\nconst struct in6_addr *daddr)\r\n{\r\nnet_get_random_once(&nf_frags.rnd, sizeof(nf_frags.rnd));\r\nreturn jhash_3words(ipv6_addr_hash(saddr), ipv6_addr_hash(daddr),\r\n(__force u32)id, nf_frags.rnd);\r\n}\r\nstatic unsigned int nf_hashfn(const struct inet_frag_queue *q)\r\n{\r\nconst struct frag_queue *nq;\r\nnq = container_of(q, struct frag_queue, q);\r\nreturn nf_hash_frag(nq->id, &nq->saddr, &nq->daddr);\r\n}\r\nstatic void nf_skb_free(struct sk_buff *skb)\r\n{\r\nif (NFCT_FRAG6_CB(skb)->orig)\r\nkfree_skb(NFCT_FRAG6_CB(skb)->orig);\r\n}\r\nstatic void nf_ct_frag6_expire(unsigned long data)\r\n{\r\nstruct frag_queue *fq;\r\nstruct net *net;\r\nfq = container_of((struct inet_frag_queue *)data, struct frag_queue, q);\r\nnet = container_of(fq->q.net, struct net, nf_frag.frags);\r\nip6_expire_frag_queue(net, fq, &nf_frags);\r\n}\r\nstatic inline struct frag_queue *fq_find(struct net *net, __be32 id,\r\nu32 user, struct in6_addr *src,\r\nstruct in6_addr *dst, u8 ecn)\r\n{\r\nstruct inet_frag_queue *q;\r\nstruct ip6_create_arg arg;\r\nunsigned int hash;\r\narg.id = id;\r\narg.user = user;\r\narg.src = src;\r\narg.dst = dst;\r\narg.ecn = ecn;\r\nlocal_bh_disable();\r\nhash = nf_hash_frag(id, src, dst);\r\nq = inet_frag_find(&net->nf_frag.frags, &nf_frags, &arg, hash);\r\nlocal_bh_enable();\r\nif (IS_ERR_OR_NULL(q)) {\r\ninet_frag_maybe_warn_overflow(q, pr_fmt());\r\nreturn NULL;\r\n}\r\nreturn container_of(q, struct frag_queue, q);\r\n}\r\nstatic int nf_ct_frag6_queue(struct frag_queue *fq, struct sk_buff *skb,\r\nconst struct frag_hdr *fhdr, int nhoff)\r\n{\r\nstruct sk_buff *prev, *next;\r\nunsigned int payload_len;\r\nint offset, end;\r\nu8 ecn;\r\nif (fq->q.flags & INET_FRAG_COMPLETE) {\r\npr_debug("Already completed\n");\r\ngoto err;\r\n}\r\npayload_len = ntohs(ipv6_hdr(skb)->payload_len);\r\noffset = ntohs(fhdr->frag_off) & ~0x7;\r\nend = offset + (payload_len -\r\n((u8 *)(fhdr + 1) - (u8 *)(ipv6_hdr(skb) + 1)));\r\nif ((unsigned int)end > IPV6_MAXPLEN) {\r\npr_debug("offset is too large.\n");\r\nreturn -1;\r\n}\r\necn = ip6_frag_ecn(ipv6_hdr(skb));\r\nif (skb->ip_summed == CHECKSUM_COMPLETE) {\r\nconst unsigned char *nh = skb_network_header(skb);\r\nskb->csum = csum_sub(skb->csum,\r\ncsum_partial(nh, (u8 *)(fhdr + 1) - nh,\r\n0));\r\n}\r\nif (!(fhdr->frag_off & htons(IP6_MF))) {\r\nif (end < fq->q.len ||\r\n((fq->q.flags & INET_FRAG_LAST_IN) && end != fq->q.len)) {\r\npr_debug("already received last fragment\n");\r\ngoto err;\r\n}\r\nfq->q.flags |= INET_FRAG_LAST_IN;\r\nfq->q.len = end;\r\n} else {\r\nif (end & 0x7) {\r\npr_debug("end of fragment not rounded to 8 bytes.\n");\r\nreturn -1;\r\n}\r\nif (end > fq->q.len) {\r\nif (fq->q.flags & INET_FRAG_LAST_IN) {\r\npr_debug("last packet already reached.\n");\r\ngoto err;\r\n}\r\nfq->q.len = end;\r\n}\r\n}\r\nif (end == offset)\r\ngoto err;\r\nif (!pskb_pull(skb, (u8 *) (fhdr + 1) - skb->data)) {\r\npr_debug("queue: message is too short.\n");\r\ngoto err;\r\n}\r\nif (pskb_trim_rcsum(skb, end - offset)) {\r\npr_debug("Can't trim\n");\r\ngoto err;\r\n}\r\nprev = fq->q.fragments_tail;\r\nif (!prev || NFCT_FRAG6_CB(prev)->offset < offset) {\r\nnext = NULL;\r\ngoto found;\r\n}\r\nprev = NULL;\r\nfor (next = fq->q.fragments; next != NULL; next = next->next) {\r\nif (NFCT_FRAG6_CB(next)->offset >= offset)\r\nbreak;\r\nprev = next;\r\n}\r\nfound:\r\nif (prev &&\r\n(NFCT_FRAG6_CB(prev)->offset + prev->len) > offset)\r\ngoto discard_fq;\r\nif (next && NFCT_FRAG6_CB(next)->offset < end)\r\ngoto discard_fq;\r\nNFCT_FRAG6_CB(skb)->offset = offset;\r\nskb->next = next;\r\nif (!next)\r\nfq->q.fragments_tail = skb;\r\nif (prev)\r\nprev->next = skb;\r\nelse\r\nfq->q.fragments = skb;\r\nif (skb->dev) {\r\nfq->iif = skb->dev->ifindex;\r\nskb->dev = NULL;\r\n}\r\nfq->q.stamp = skb->tstamp;\r\nfq->q.meat += skb->len;\r\nfq->ecn |= ecn;\r\nif (payload_len > fq->q.max_size)\r\nfq->q.max_size = payload_len;\r\nadd_frag_mem_limit(&fq->q, skb->truesize);\r\nif (offset == 0) {\r\nfq->nhoffset = nhoff;\r\nfq->q.flags |= INET_FRAG_FIRST_IN;\r\n}\r\nreturn 0;\r\ndiscard_fq:\r\ninet_frag_kill(&fq->q, &nf_frags);\r\nerr:\r\nreturn -1;\r\n}\r\nstatic struct sk_buff *\r\nnf_ct_frag6_reasm(struct frag_queue *fq, struct net_device *dev)\r\n{\r\nstruct sk_buff *fp, *op, *head = fq->q.fragments;\r\nint payload_len;\r\nu8 ecn;\r\ninet_frag_kill(&fq->q, &nf_frags);\r\nWARN_ON(head == NULL);\r\nWARN_ON(NFCT_FRAG6_CB(head)->offset != 0);\r\necn = ip_frag_ecn_table[fq->ecn];\r\nif (unlikely(ecn == 0xff))\r\ngoto out_fail;\r\npayload_len = ((head->data - skb_network_header(head)) -\r\nsizeof(struct ipv6hdr) + fq->q.len -\r\nsizeof(struct frag_hdr));\r\nif (payload_len > IPV6_MAXPLEN) {\r\npr_debug("payload len is too large.\n");\r\ngoto out_oversize;\r\n}\r\nif (skb_unclone(head, GFP_ATOMIC)) {\r\npr_debug("skb is cloned but can't expand head");\r\ngoto out_oom;\r\n}\r\nif (skb_has_frag_list(head)) {\r\nstruct sk_buff *clone;\r\nint i, plen = 0;\r\nclone = alloc_skb(0, GFP_ATOMIC);\r\nif (clone == NULL)\r\ngoto out_oom;\r\nclone->next = head->next;\r\nhead->next = clone;\r\nskb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;\r\nskb_frag_list_init(head);\r\nfor (i = 0; i < skb_shinfo(head)->nr_frags; i++)\r\nplen += skb_frag_size(&skb_shinfo(head)->frags[i]);\r\nclone->len = clone->data_len = head->data_len - plen;\r\nhead->data_len -= clone->len;\r\nhead->len -= clone->len;\r\nclone->csum = 0;\r\nclone->ip_summed = head->ip_summed;\r\nNFCT_FRAG6_CB(clone)->orig = NULL;\r\nadd_frag_mem_limit(&fq->q, clone->truesize);\r\n}\r\nskb_network_header(head)[fq->nhoffset] = skb_transport_header(head)[0];\r\nmemmove(head->head + sizeof(struct frag_hdr), head->head,\r\n(head->data - head->head) - sizeof(struct frag_hdr));\r\nhead->mac_header += sizeof(struct frag_hdr);\r\nhead->network_header += sizeof(struct frag_hdr);\r\nskb_shinfo(head)->frag_list = head->next;\r\nskb_reset_transport_header(head);\r\nskb_push(head, head->data - skb_network_header(head));\r\nfor (fp=head->next; fp; fp = fp->next) {\r\nhead->data_len += fp->len;\r\nhead->len += fp->len;\r\nif (head->ip_summed != fp->ip_summed)\r\nhead->ip_summed = CHECKSUM_NONE;\r\nelse if (head->ip_summed == CHECKSUM_COMPLETE)\r\nhead->csum = csum_add(head->csum, fp->csum);\r\nhead->truesize += fp->truesize;\r\n}\r\nsub_frag_mem_limit(&fq->q, head->truesize);\r\nhead->ignore_df = 1;\r\nhead->next = NULL;\r\nhead->dev = dev;\r\nhead->tstamp = fq->q.stamp;\r\nipv6_hdr(head)->payload_len = htons(payload_len);\r\nipv6_change_dsfield(ipv6_hdr(head), 0xff, ecn);\r\nIP6CB(head)->frag_max_size = sizeof(struct ipv6hdr) + fq->q.max_size;\r\nif (head->ip_summed == CHECKSUM_COMPLETE)\r\nhead->csum = csum_partial(skb_network_header(head),\r\nskb_network_header_len(head),\r\nhead->csum);\r\nfq->q.fragments = NULL;\r\nfq->q.fragments_tail = NULL;\r\nfp = skb_shinfo(head)->frag_list;\r\nif (fp && NFCT_FRAG6_CB(fp)->orig == NULL)\r\nfp = fp->next;\r\nop = NFCT_FRAG6_CB(head)->orig;\r\nfor (; fp; fp = fp->next) {\r\nstruct sk_buff *orig = NFCT_FRAG6_CB(fp)->orig;\r\nop->next = orig;\r\nop = orig;\r\nNFCT_FRAG6_CB(fp)->orig = NULL;\r\n}\r\nreturn head;\r\nout_oversize:\r\nnet_dbg_ratelimited("nf_ct_frag6_reasm: payload len = %d\n",\r\npayload_len);\r\ngoto out_fail;\r\nout_oom:\r\nnet_dbg_ratelimited("nf_ct_frag6_reasm: no memory for reassembly\n");\r\nout_fail:\r\nreturn NULL;\r\n}\r\nstatic int\r\nfind_prev_fhdr(struct sk_buff *skb, u8 *prevhdrp, int *prevhoff, int *fhoff)\r\n{\r\nu8 nexthdr = ipv6_hdr(skb)->nexthdr;\r\nconst int netoff = skb_network_offset(skb);\r\nu8 prev_nhoff = netoff + offsetof(struct ipv6hdr, nexthdr);\r\nint start = netoff + sizeof(struct ipv6hdr);\r\nint len = skb->len - start;\r\nu8 prevhdr = NEXTHDR_IPV6;\r\nwhile (nexthdr != NEXTHDR_FRAGMENT) {\r\nstruct ipv6_opt_hdr hdr;\r\nint hdrlen;\r\nif (!ipv6_ext_hdr(nexthdr)) {\r\nreturn -1;\r\n}\r\nif (nexthdr == NEXTHDR_NONE) {\r\npr_debug("next header is none\n");\r\nreturn -1;\r\n}\r\nif (len < (int)sizeof(struct ipv6_opt_hdr)) {\r\npr_debug("too short\n");\r\nreturn -1;\r\n}\r\nif (skb_copy_bits(skb, start, &hdr, sizeof(hdr)))\r\nBUG();\r\nif (nexthdr == NEXTHDR_AUTH)\r\nhdrlen = (hdr.hdrlen+2)<<2;\r\nelse\r\nhdrlen = ipv6_optlen(&hdr);\r\nprevhdr = nexthdr;\r\nprev_nhoff = start;\r\nnexthdr = hdr.nexthdr;\r\nlen -= hdrlen;\r\nstart += hdrlen;\r\n}\r\nif (len < 0)\r\nreturn -1;\r\n*prevhdrp = prevhdr;\r\n*prevhoff = prev_nhoff;\r\n*fhoff = start;\r\nreturn 0;\r\n}\r\nstruct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user)\r\n{\r\nstruct sk_buff *clone;\r\nstruct net_device *dev = skb->dev;\r\nstruct net *net = skb_dst(skb) ? dev_net(skb_dst(skb)->dev)\r\n: dev_net(skb->dev);\r\nstruct frag_hdr *fhdr;\r\nstruct frag_queue *fq;\r\nstruct ipv6hdr *hdr;\r\nint fhoff, nhoff;\r\nu8 prevhdr;\r\nstruct sk_buff *ret_skb = NULL;\r\nif (ipv6_hdr(skb)->payload_len == 0) {\r\npr_debug("payload len = 0\n");\r\nreturn skb;\r\n}\r\nif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\r\nreturn skb;\r\nclone = skb_clone(skb, GFP_ATOMIC);\r\nif (clone == NULL) {\r\npr_debug("Can't clone skb\n");\r\nreturn skb;\r\n}\r\nNFCT_FRAG6_CB(clone)->orig = skb;\r\nif (!pskb_may_pull(clone, fhoff + sizeof(*fhdr))) {\r\npr_debug("message is too short.\n");\r\ngoto ret_orig;\r\n}\r\nskb_set_transport_header(clone, fhoff);\r\nhdr = ipv6_hdr(clone);\r\nfhdr = (struct frag_hdr *)skb_transport_header(clone);\r\nfq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,\r\nip6_frag_ecn(hdr));\r\nif (fq == NULL) {\r\npr_debug("Can't find and can't create new queue\n");\r\ngoto ret_orig;\r\n}\r\nspin_lock_bh(&fq->q.lock);\r\nif (nf_ct_frag6_queue(fq, clone, fhdr, nhoff) < 0) {\r\nspin_unlock_bh(&fq->q.lock);\r\npr_debug("Can't insert skb to queue\n");\r\ninet_frag_put(&fq->q, &nf_frags);\r\ngoto ret_orig;\r\n}\r\nif (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\r\nfq->q.meat == fq->q.len) {\r\nret_skb = nf_ct_frag6_reasm(fq, dev);\r\nif (ret_skb == NULL)\r\npr_debug("Can't reassemble fragmented packets\n");\r\n}\r\nspin_unlock_bh(&fq->q.lock);\r\ninet_frag_put(&fq->q, &nf_frags);\r\nreturn ret_skb;\r\nret_orig:\r\nkfree_skb(clone);\r\nreturn skb;\r\n}\r\nvoid nf_ct_frag6_consume_orig(struct sk_buff *skb)\r\n{\r\nstruct sk_buff *s, *s2;\r\nfor (s = NFCT_FRAG6_CB(skb)->orig; s;) {\r\ns2 = s->next;\r\ns->next = NULL;\r\nconsume_skb(s);\r\ns = s2;\r\n}\r\n}\r\nstatic int nf_ct_net_init(struct net *net)\r\n{\r\nnet->nf_frag.frags.high_thresh = IPV6_FRAG_HIGH_THRESH;\r\nnet->nf_frag.frags.low_thresh = IPV6_FRAG_LOW_THRESH;\r\nnet->nf_frag.frags.timeout = IPV6_FRAG_TIMEOUT;\r\ninet_frags_init_net(&net->nf_frag.frags);\r\nreturn nf_ct_frag6_sysctl_register(net);\r\n}\r\nstatic void nf_ct_net_exit(struct net *net)\r\n{\r\nnf_ct_frags6_sysctl_unregister(net);\r\ninet_frags_exit_net(&net->nf_frag.frags, &nf_frags);\r\n}\r\nint nf_ct_frag6_init(void)\r\n{\r\nint ret = 0;\r\nnf_frags.hashfn = nf_hashfn;\r\nnf_frags.constructor = ip6_frag_init;\r\nnf_frags.destructor = NULL;\r\nnf_frags.skb_free = nf_skb_free;\r\nnf_frags.qsize = sizeof(struct frag_queue);\r\nnf_frags.match = ip6_frag_match;\r\nnf_frags.frag_expire = nf_ct_frag6_expire;\r\nnf_frags.frags_cache_name = nf_frags_cache_name;\r\nret = inet_frags_init(&nf_frags);\r\nif (ret)\r\ngoto out;\r\nret = register_pernet_subsys(&nf_ct_net_ops);\r\nif (ret)\r\ninet_frags_fini(&nf_frags);\r\nout:\r\nreturn ret;\r\n}\r\nvoid nf_ct_frag6_cleanup(void)\r\n{\r\nunregister_pernet_subsys(&nf_ct_net_ops);\r\ninet_frags_fini(&nf_frags);\r\n}
