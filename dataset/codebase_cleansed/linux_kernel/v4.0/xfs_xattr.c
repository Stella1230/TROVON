static int\r\nxfs_xattr_get(struct dentry *dentry, const char *name,\r\nvoid *value, size_t size, int xflags)\r\n{\r\nstruct xfs_inode *ip = XFS_I(dentry->d_inode);\r\nint error, asize = size;\r\nif (strcmp(name, "") == 0)\r\nreturn -EINVAL;\r\nif (!size) {\r\nxflags |= ATTR_KERNOVAL;\r\nvalue = NULL;\r\n}\r\nerror = xfs_attr_get(ip, (unsigned char *)name, value, &asize, xflags);\r\nif (error)\r\nreturn error;\r\nreturn asize;\r\n}\r\nstatic int\r\nxfs_xattr_set(struct dentry *dentry, const char *name, const void *value,\r\nsize_t size, int flags, int xflags)\r\n{\r\nstruct xfs_inode *ip = XFS_I(dentry->d_inode);\r\nif (strcmp(name, "") == 0)\r\nreturn -EINVAL;\r\nif (flags & XATTR_CREATE)\r\nxflags |= ATTR_CREATE;\r\nif (flags & XATTR_REPLACE)\r\nxflags |= ATTR_REPLACE;\r\nif (!value)\r\nreturn xfs_attr_remove(ip, (unsigned char *)name, xflags);\r\nreturn xfs_attr_set(ip, (unsigned char *)name,\r\n(void *)value, size, xflags);\r\n}\r\nstatic unsigned int xfs_xattr_prefix_len(int flags)\r\n{\r\nif (flags & XFS_ATTR_SECURE)\r\nreturn sizeof("security");\r\nelse if (flags & XFS_ATTR_ROOT)\r\nreturn sizeof("trusted");\r\nelse\r\nreturn sizeof("user");\r\n}\r\nstatic const char *xfs_xattr_prefix(int flags)\r\n{\r\nif (flags & XFS_ATTR_SECURE)\r\nreturn xfs_xattr_security_handler.prefix;\r\nelse if (flags & XFS_ATTR_ROOT)\r\nreturn xfs_xattr_trusted_handler.prefix;\r\nelse\r\nreturn xfs_xattr_user_handler.prefix;\r\n}\r\nstatic int\r\nxfs_xattr_put_listent(\r\nstruct xfs_attr_list_context *context,\r\nint flags,\r\nunsigned char *name,\r\nint namelen,\r\nint valuelen,\r\nunsigned char *value)\r\n{\r\nunsigned int prefix_len = xfs_xattr_prefix_len(flags);\r\nchar *offset;\r\nint arraytop;\r\nASSERT(context->count >= 0);\r\nif ((flags & XFS_ATTR_ROOT) && !capable(CAP_SYS_ADMIN))\r\nreturn 0;\r\narraytop = context->count + prefix_len + namelen + 1;\r\nif (arraytop > context->firstu) {\r\ncontext->count = -1;\r\nreturn 1;\r\n}\r\noffset = (char *)context->alist + context->count;\r\nstrncpy(offset, xfs_xattr_prefix(flags), prefix_len);\r\noffset += prefix_len;\r\nstrncpy(offset, (char *)name, namelen);\r\noffset += namelen;\r\n*offset = '\0';\r\ncontext->count += prefix_len + namelen + 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nxfs_xattr_put_listent_sizes(\r\nstruct xfs_attr_list_context *context,\r\nint flags,\r\nunsigned char *name,\r\nint namelen,\r\nint valuelen,\r\nunsigned char *value)\r\n{\r\ncontext->count += xfs_xattr_prefix_len(flags) + namelen + 1;\r\nreturn 0;\r\n}\r\nstatic int\r\nlist_one_attr(const char *name, const size_t len, void *data,\r\nsize_t size, ssize_t *result)\r\n{\r\nchar *p = data + *result;\r\n*result += len;\r\nif (!size)\r\nreturn 0;\r\nif (*result > size)\r\nreturn -ERANGE;\r\nstrcpy(p, name);\r\nreturn 0;\r\n}\r\nssize_t\r\nxfs_vn_listxattr(struct dentry *dentry, char *data, size_t size)\r\n{\r\nstruct xfs_attr_list_context context;\r\nstruct attrlist_cursor_kern cursor = { 0 };\r\nstruct inode *inode = dentry->d_inode;\r\nint error;\r\nmemset(&context, 0, sizeof(context));\r\ncontext.dp = XFS_I(inode);\r\ncontext.cursor = &cursor;\r\ncontext.resynch = 1;\r\ncontext.alist = data;\r\ncontext.bufsize = size;\r\ncontext.firstu = context.bufsize;\r\nif (size)\r\ncontext.put_listent = xfs_xattr_put_listent;\r\nelse\r\ncontext.put_listent = xfs_xattr_put_listent_sizes;\r\nxfs_attr_list_int(&context);\r\nif (context.count < 0)\r\nreturn -ERANGE;\r\nif (posix_acl_access_exists(inode)) {\r\nerror = list_one_attr(POSIX_ACL_XATTR_ACCESS,\r\nstrlen(POSIX_ACL_XATTR_ACCESS) + 1,\r\ndata, size, &context.count);\r\nif (error)\r\nreturn error;\r\n}\r\nif (posix_acl_default_exists(inode)) {\r\nerror = list_one_attr(POSIX_ACL_XATTR_DEFAULT,\r\nstrlen(POSIX_ACL_XATTR_DEFAULT) + 1,\r\ndata, size, &context.count);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn context.count;\r\n}
