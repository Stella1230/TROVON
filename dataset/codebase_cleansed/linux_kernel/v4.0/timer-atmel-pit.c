static inline struct pit_data *clksrc_to_pit_data(struct clocksource *clksrc)\r\n{\r\nreturn container_of(clksrc, struct pit_data, clksrc);\r\n}\r\nstatic inline struct pit_data *clkevt_to_pit_data(struct clock_event_device *clkevt)\r\n{\r\nreturn container_of(clkevt, struct pit_data, clkevt);\r\n}\r\nstatic inline unsigned int pit_read(void __iomem *base, unsigned int reg_offset)\r\n{\r\nreturn __raw_readl(base + reg_offset);\r\n}\r\nstatic inline void pit_write(void __iomem *base, unsigned int reg_offset, unsigned long value)\r\n{\r\n__raw_writel(value, base + reg_offset);\r\n}\r\nstatic cycle_t read_pit_clk(struct clocksource *cs)\r\n{\r\nstruct pit_data *data = clksrc_to_pit_data(cs);\r\nunsigned long flags;\r\nu32 elapsed;\r\nu32 t;\r\nraw_local_irq_save(flags);\r\nelapsed = data->cnt;\r\nt = pit_read(data->base, AT91_PIT_PIIR);\r\nraw_local_irq_restore(flags);\r\nelapsed += PIT_PICNT(t) * data->cycle;\r\nelapsed += PIT_CPIV(t);\r\nreturn elapsed;\r\n}\r\nstatic void\r\npit_clkevt_mode(enum clock_event_mode mode, struct clock_event_device *dev)\r\n{\r\nstruct pit_data *data = clkevt_to_pit_data(dev);\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\ndata->cnt += data->cycle * PIT_PICNT(pit_read(data->base, AT91_PIT_PIVR));\r\npit_write(data->base, AT91_PIT_MR,\r\n(data->cycle - 1) | AT91_PIT_PITEN | AT91_PIT_PITIEN);\r\nbreak;\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\nBUG();\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\ncase CLOCK_EVT_MODE_UNUSED:\r\npit_write(data->base, AT91_PIT_MR,\r\n(data->cycle - 1) | AT91_PIT_PITEN);\r\nbreak;\r\ncase CLOCK_EVT_MODE_RESUME:\r\nbreak;\r\n}\r\n}\r\nstatic void at91sam926x_pit_suspend(struct clock_event_device *cedev)\r\n{\r\nstruct pit_data *data = clkevt_to_pit_data(cedev);\r\npit_write(data->base, AT91_PIT_MR, 0);\r\n}\r\nstatic void at91sam926x_pit_reset(struct pit_data *data)\r\n{\r\npit_write(data->base, AT91_PIT_MR, 0);\r\nwhile (PIT_CPIV(pit_read(data->base, AT91_PIT_PIVR)) != 0)\r\ncpu_relax();\r\npit_write(data->base, AT91_PIT_MR,\r\n(data->cycle - 1) | AT91_PIT_PITEN);\r\n}\r\nstatic void at91sam926x_pit_resume(struct clock_event_device *cedev)\r\n{\r\nstruct pit_data *data = clkevt_to_pit_data(cedev);\r\nat91sam926x_pit_reset(data);\r\n}\r\nstatic irqreturn_t at91sam926x_pit_interrupt(int irq, void *dev_id)\r\n{\r\nstruct pit_data *data = dev_id;\r\nWARN_ON_ONCE(!irqs_disabled());\r\nif ((data->clkevt.mode == CLOCK_EVT_MODE_PERIODIC) &&\r\n(pit_read(data->base, AT91_PIT_SR) & AT91_PIT_PITS)) {\r\nunsigned nr_ticks;\r\nnr_ticks = PIT_PICNT(pit_read(data->base, AT91_PIT_PIVR));\r\ndo {\r\ndata->cnt += data->cycle;\r\ndata->clkevt.event_handler(&data->clkevt);\r\nnr_ticks--;\r\n} while (nr_ticks);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic void __init at91sam926x_pit_common_init(struct pit_data *data)\r\n{\r\nunsigned long pit_rate;\r\nunsigned bits;\r\nint ret;\r\npit_rate = clk_get_rate(data->mck) / 16;\r\ndata->cycle = DIV_ROUND_CLOSEST(pit_rate, HZ);\r\nWARN_ON(((data->cycle - 1) & ~AT91_PIT_PIV) != 0);\r\nat91sam926x_pit_reset(data);\r\nbits = 12 + ilog2(data->cycle) ;\r\ndata->clksrc.mask = CLOCKSOURCE_MASK(bits);\r\ndata->clksrc.name = "pit";\r\ndata->clksrc.rating = 175;\r\ndata->clksrc.read = read_pit_clk,\r\ndata->clksrc.flags = CLOCK_SOURCE_IS_CONTINUOUS,\r\nclocksource_register_hz(&data->clksrc, pit_rate);\r\nret = request_irq(data->irq, at91sam926x_pit_interrupt,\r\nIRQF_SHARED | IRQF_TIMER | IRQF_IRQPOLL,\r\n"at91_tick", data);\r\nif (ret)\r\npanic(pr_fmt("Unable to setup IRQ\n"));\r\ndata->clkevt.name = "pit";\r\ndata->clkevt.features = CLOCK_EVT_FEAT_PERIODIC;\r\ndata->clkevt.shift = 32;\r\ndata->clkevt.mult = div_sc(pit_rate, NSEC_PER_SEC, data->clkevt.shift);\r\ndata->clkevt.rating = 100;\r\ndata->clkevt.cpumask = cpumask_of(0);\r\ndata->clkevt.set_mode = pit_clkevt_mode;\r\ndata->clkevt.resume = at91sam926x_pit_resume;\r\ndata->clkevt.suspend = at91sam926x_pit_suspend;\r\nclockevents_register_device(&data->clkevt);\r\n}\r\nstatic void __init at91sam926x_pit_dt_init(struct device_node *node)\r\n{\r\nstruct pit_data *data;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\npanic(pr_fmt("Unable to allocate memory\n"));\r\ndata->base = of_iomap(node, 0);\r\nif (!data->base)\r\npanic(pr_fmt("Could not map PIT address\n"));\r\ndata->mck = of_clk_get(node, 0);\r\nif (IS_ERR(data->mck))\r\ndata->mck = clk_get(NULL, "mck");\r\nif (IS_ERR(data->mck))\r\npanic(pr_fmt("Unable to get mck clk\n"));\r\ndata->irq = irq_of_parse_and_map(node, 0);\r\nif (!data->irq)\r\npanic(pr_fmt("Unable to get IRQ from DT\n"));\r\nat91sam926x_pit_common_init(data);\r\n}
