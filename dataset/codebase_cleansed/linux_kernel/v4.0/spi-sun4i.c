static inline u32 sun4i_spi_read(struct sun4i_spi *sspi, u32 reg)\r\n{\r\nreturn readl(sspi->base_addr + reg);\r\n}\r\nstatic inline void sun4i_spi_write(struct sun4i_spi *sspi, u32 reg, u32 value)\r\n{\r\nwritel(value, sspi->base_addr + reg);\r\n}\r\nstatic inline void sun4i_spi_drain_fifo(struct sun4i_spi *sspi, int len)\r\n{\r\nu32 reg, cnt;\r\nu8 byte;\r\nreg = sun4i_spi_read(sspi, SUN4I_FIFO_STA_REG);\r\nreg &= SUN4I_FIFO_STA_RF_CNT_MASK;\r\ncnt = reg >> SUN4I_FIFO_STA_RF_CNT_BITS;\r\nif (len > cnt)\r\nlen = cnt;\r\nwhile (len--) {\r\nbyte = readb(sspi->base_addr + SUN4I_RXDATA_REG);\r\nif (sspi->rx_buf)\r\n*sspi->rx_buf++ = byte;\r\n}\r\n}\r\nstatic inline void sun4i_spi_fill_fifo(struct sun4i_spi *sspi, int len)\r\n{\r\nu8 byte;\r\nif (len > sspi->len)\r\nlen = sspi->len;\r\nwhile (len--) {\r\nbyte = sspi->tx_buf ? *sspi->tx_buf++ : 0;\r\nwriteb(byte, sspi->base_addr + SUN4I_TXDATA_REG);\r\nsspi->len--;\r\n}\r\n}\r\nstatic void sun4i_spi_set_cs(struct spi_device *spi, bool enable)\r\n{\r\nstruct sun4i_spi *sspi = spi_master_get_devdata(spi->master);\r\nu32 reg;\r\nreg = sun4i_spi_read(sspi, SUN4I_CTL_REG);\r\nreg &= ~SUN4I_CTL_CS_MASK;\r\nreg |= SUN4I_CTL_CS(spi->chip_select);\r\nif (enable)\r\nreg |= SUN4I_CTL_CS_LEVEL;\r\nelse\r\nreg &= ~SUN4I_CTL_CS_LEVEL;\r\nif (spi->mode & SPI_CS_HIGH)\r\nreg &= ~SUN4I_CTL_CS_ACTIVE_LOW;\r\nelse\r\nreg |= SUN4I_CTL_CS_ACTIVE_LOW;\r\nsun4i_spi_write(sspi, SUN4I_CTL_REG, reg);\r\n}\r\nstatic int sun4i_spi_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *tfr)\r\n{\r\nstruct sun4i_spi *sspi = spi_master_get_devdata(master);\r\nunsigned int mclk_rate, div, timeout;\r\nunsigned int tx_len = 0;\r\nint ret = 0;\r\nu32 reg;\r\nif (tfr->len > SUN4I_FIFO_DEPTH)\r\nreturn -EINVAL;\r\nreinit_completion(&sspi->done);\r\nsspi->tx_buf = tfr->tx_buf;\r\nsspi->rx_buf = tfr->rx_buf;\r\nsspi->len = tfr->len;\r\nsun4i_spi_write(sspi, SUN4I_INT_STA_REG, ~0);\r\nreg = sun4i_spi_read(sspi, SUN4I_CTL_REG);\r\nsun4i_spi_write(sspi, SUN4I_CTL_REG,\r\nreg | SUN4I_CTL_RF_RST | SUN4I_CTL_TF_RST);\r\nif (spi->mode & SPI_CPOL)\r\nreg |= SUN4I_CTL_CPOL;\r\nelse\r\nreg &= ~SUN4I_CTL_CPOL;\r\nif (spi->mode & SPI_CPHA)\r\nreg |= SUN4I_CTL_CPHA;\r\nelse\r\nreg &= ~SUN4I_CTL_CPHA;\r\nif (spi->mode & SPI_LSB_FIRST)\r\nreg |= SUN4I_CTL_LMTF;\r\nelse\r\nreg &= ~SUN4I_CTL_LMTF;\r\nif (sspi->rx_buf)\r\nreg &= ~SUN4I_CTL_DHB;\r\nelse\r\nreg |= SUN4I_CTL_DHB;\r\nreg |= SUN4I_CTL_CS_MANUAL;\r\nsun4i_spi_write(sspi, SUN4I_CTL_REG, reg);\r\nmclk_rate = clk_get_rate(sspi->mclk);\r\nif (mclk_rate < (2 * spi->max_speed_hz)) {\r\nclk_set_rate(sspi->mclk, 2 * spi->max_speed_hz);\r\nmclk_rate = clk_get_rate(sspi->mclk);\r\n}\r\ndiv = mclk_rate / (2 * spi->max_speed_hz);\r\nif (div <= (SUN4I_CLK_CTL_CDR2_MASK + 1)) {\r\nif (div > 0)\r\ndiv--;\r\nreg = SUN4I_CLK_CTL_CDR2(div) | SUN4I_CLK_CTL_DRS;\r\n} else {\r\ndiv = ilog2(mclk_rate) - ilog2(spi->max_speed_hz);\r\nreg = SUN4I_CLK_CTL_CDR1(div);\r\n}\r\nsun4i_spi_write(sspi, SUN4I_CLK_CTL_REG, reg);\r\nif (sspi->tx_buf)\r\ntx_len = tfr->len;\r\nsun4i_spi_write(sspi, SUN4I_BURST_CNT_REG, SUN4I_BURST_CNT(tfr->len));\r\nsun4i_spi_write(sspi, SUN4I_XMIT_CNT_REG, SUN4I_XMIT_CNT(tx_len));\r\nsun4i_spi_fill_fifo(sspi, SUN4I_FIFO_DEPTH);\r\nsun4i_spi_write(sspi, SUN4I_INT_CTL_REG, SUN4I_INT_CTL_TC);\r\nreg = sun4i_spi_read(sspi, SUN4I_CTL_REG);\r\nsun4i_spi_write(sspi, SUN4I_CTL_REG, reg | SUN4I_CTL_XCH);\r\ntimeout = wait_for_completion_timeout(&sspi->done,\r\nmsecs_to_jiffies(1000));\r\nif (!timeout) {\r\nret = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nsun4i_spi_drain_fifo(sspi, SUN4I_FIFO_DEPTH);\r\nout:\r\nsun4i_spi_write(sspi, SUN4I_INT_CTL_REG, 0);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t sun4i_spi_handler(int irq, void *dev_id)\r\n{\r\nstruct sun4i_spi *sspi = dev_id;\r\nu32 status = sun4i_spi_read(sspi, SUN4I_INT_STA_REG);\r\nif (status & SUN4I_INT_CTL_TC) {\r\nsun4i_spi_write(sspi, SUN4I_INT_STA_REG, SUN4I_INT_CTL_TC);\r\ncomplete(&sspi->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int sun4i_spi_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct sun4i_spi *sspi = spi_master_get_devdata(master);\r\nint ret;\r\nret = clk_prepare_enable(sspi->hclk);\r\nif (ret) {\r\ndev_err(dev, "Couldn't enable AHB clock\n");\r\ngoto out;\r\n}\r\nret = clk_prepare_enable(sspi->mclk);\r\nif (ret) {\r\ndev_err(dev, "Couldn't enable module clock\n");\r\ngoto err;\r\n}\r\nsun4i_spi_write(sspi, SUN4I_CTL_REG,\r\nSUN4I_CTL_ENABLE | SUN4I_CTL_MASTER | SUN4I_CTL_TP);\r\nreturn 0;\r\nerr:\r\nclk_disable_unprepare(sspi->hclk);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int sun4i_spi_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct sun4i_spi *sspi = spi_master_get_devdata(master);\r\nclk_disable_unprepare(sspi->mclk);\r\nclk_disable_unprepare(sspi->hclk);\r\nreturn 0;\r\n}\r\nstatic int sun4i_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct sun4i_spi *sspi;\r\nstruct resource *res;\r\nint ret = 0, irq;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct sun4i_spi));\r\nif (!master) {\r\ndev_err(&pdev->dev, "Unable to allocate SPI Master\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, master);\r\nsspi = spi_master_get_devdata(master);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nsspi->base_addr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(sspi->base_addr)) {\r\nret = PTR_ERR(sspi->base_addr);\r\ngoto err_free_master;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "No spi IRQ specified\n");\r\nret = -ENXIO;\r\ngoto err_free_master;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, sun4i_spi_handler,\r\n0, "sun4i-spi", sspi);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Cannot request IRQ\n");\r\ngoto err_free_master;\r\n}\r\nsspi->master = master;\r\nmaster->set_cs = sun4i_spi_set_cs;\r\nmaster->transfer_one = sun4i_spi_transfer_one;\r\nmaster->num_chipselect = 4;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8);\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->auto_runtime_pm = true;\r\nsspi->hclk = devm_clk_get(&pdev->dev, "ahb");\r\nif (IS_ERR(sspi->hclk)) {\r\ndev_err(&pdev->dev, "Unable to acquire AHB clock\n");\r\nret = PTR_ERR(sspi->hclk);\r\ngoto err_free_master;\r\n}\r\nsspi->mclk = devm_clk_get(&pdev->dev, "mod");\r\nif (IS_ERR(sspi->mclk)) {\r\ndev_err(&pdev->dev, "Unable to acquire module clock\n");\r\nret = PTR_ERR(sspi->mclk);\r\ngoto err_free_master;\r\n}\r\ninit_completion(&sspi->done);\r\nret = sun4i_spi_runtime_resume(&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Couldn't resume the device\n");\r\ngoto err_free_master;\r\n}\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_idle(&pdev->dev);\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot register SPI master\n");\r\ngoto err_pm_disable;\r\n}\r\nreturn 0;\r\nerr_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nsun4i_spi_runtime_suspend(&pdev->dev);\r\nerr_free_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int sun4i_spi_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
