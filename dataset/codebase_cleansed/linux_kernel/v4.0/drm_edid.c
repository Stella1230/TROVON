int drm_edid_header_is_valid(const u8 *raw_edid)\r\n{\r\nint i, score = 0;\r\nfor (i = 0; i < sizeof(edid_header); i++)\r\nif (raw_edid[i] == edid_header[i])\r\nscore++;\r\nreturn score;\r\n}\r\nstatic int drm_edid_block_checksum(const u8 *raw_edid)\r\n{\r\nint i;\r\nu8 csum = 0;\r\nfor (i = 0; i < EDID_LENGTH; i++)\r\ncsum += raw_edid[i];\r\nreturn csum;\r\n}\r\nstatic bool drm_edid_is_zero(const u8 *in_edid, int length)\r\n{\r\nif (memchr_inv(in_edid, 0, length))\r\nreturn false;\r\nreturn true;\r\n}\r\nbool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid)\r\n{\r\nu8 csum;\r\nstruct edid *edid = (struct edid *)raw_edid;\r\nif (WARN_ON(!raw_edid))\r\nreturn false;\r\nif (edid_fixup > 8 || edid_fixup < 0)\r\nedid_fixup = 6;\r\nif (block == 0) {\r\nint score = drm_edid_header_is_valid(raw_edid);\r\nif (score == 8) ;\r\nelse if (score >= edid_fixup) {\r\nDRM_DEBUG("Fixing EDID header, your hardware may be failing\n");\r\nmemcpy(raw_edid, edid_header, sizeof(edid_header));\r\n} else {\r\ngoto bad;\r\n}\r\n}\r\ncsum = drm_edid_block_checksum(raw_edid);\r\nif (csum) {\r\nif (print_bad_edid) {\r\nDRM_ERROR("EDID checksum is invalid, remainder is %d\n", csum);\r\n}\r\nif (raw_edid[0] != 0x02)\r\ngoto bad;\r\n}\r\nswitch (raw_edid[0]) {\r\ncase 0:\r\nif (edid->version != 1) {\r\nDRM_ERROR("EDID has major version %d, instead of 1\n", edid->version);\r\ngoto bad;\r\n}\r\nif (edid->revision > 4)\r\nDRM_DEBUG("EDID minor > 4, assuming backward compatibility\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn true;\r\nbad:\r\nif (print_bad_edid) {\r\nif (drm_edid_is_zero(raw_edid, EDID_LENGTH)) {\r\nprintk(KERN_ERR "EDID block is all zeroes\n");\r\n} else {\r\nprintk(KERN_ERR "Raw EDID:\n");\r\nprint_hex_dump(KERN_ERR, " \t", DUMP_PREFIX_NONE, 16, 1,\r\nraw_edid, EDID_LENGTH, false);\r\n}\r\n}\r\nreturn false;\r\n}\r\nbool drm_edid_is_valid(struct edid *edid)\r\n{\r\nint i;\r\nu8 *raw = (u8 *)edid;\r\nif (!edid)\r\nreturn false;\r\nfor (i = 0; i <= edid->extensions; i++)\r\nif (!drm_edid_block_valid(raw + i * EDID_LENGTH, i, true))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int\r\ndrm_do_probe_ddc_edid(void *data, u8 *buf, unsigned int block, size_t len)\r\n{\r\nstruct i2c_adapter *adapter = data;\r\nunsigned char start = block * EDID_LENGTH;\r\nunsigned char segment = block >> 1;\r\nunsigned char xfers = segment ? 3 : 2;\r\nint ret, retries = 5;\r\ndo {\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = DDC_SEGMENT_ADDR,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &segment,\r\n}, {\r\n.addr = DDC_ADDR,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &start,\r\n}, {\r\n.addr = DDC_ADDR,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = buf,\r\n}\r\n};\r\nret = i2c_transfer(adapter, &msgs[3 - xfers], xfers);\r\nif (ret == -ENXIO) {\r\nDRM_DEBUG_KMS("drm: skipping non-existent adapter %s\n",\r\nadapter->name);\r\nbreak;\r\n}\r\n} while (ret != xfers && --retries);\r\nreturn ret == xfers ? 0 : -1;\r\n}\r\nstruct edid *drm_do_get_edid(struct drm_connector *connector,\r\nint (*get_edid_block)(void *data, u8 *buf, unsigned int block,\r\nsize_t len),\r\nvoid *data)\r\n{\r\nint i, j = 0, valid_extensions = 0;\r\nu8 *block, *new;\r\nbool print_bad_edid = !connector->bad_edid_counter || (drm_debug & DRM_UT_KMS);\r\nif ((block = kmalloc(EDID_LENGTH, GFP_KERNEL)) == NULL)\r\nreturn NULL;\r\nfor (i = 0; i < 4; i++) {\r\nif (get_edid_block(data, block, 0, EDID_LENGTH))\r\ngoto out;\r\nif (drm_edid_block_valid(block, 0, print_bad_edid))\r\nbreak;\r\nif (i == 0 && drm_edid_is_zero(block, EDID_LENGTH)) {\r\nconnector->null_edid_counter++;\r\ngoto carp;\r\n}\r\n}\r\nif (i == 4)\r\ngoto carp;\r\nif (block[0x7e] == 0)\r\nreturn (struct edid *)block;\r\nnew = krealloc(block, (block[0x7e] + 1) * EDID_LENGTH, GFP_KERNEL);\r\nif (!new)\r\ngoto out;\r\nblock = new;\r\nfor (j = 1; j <= block[0x7e]; j++) {\r\nfor (i = 0; i < 4; i++) {\r\nif (get_edid_block(data,\r\nblock + (valid_extensions + 1) * EDID_LENGTH,\r\nj, EDID_LENGTH))\r\ngoto out;\r\nif (drm_edid_block_valid(block + (valid_extensions + 1) * EDID_LENGTH, j, print_bad_edid)) {\r\nvalid_extensions++;\r\nbreak;\r\n}\r\n}\r\nif (i == 4 && print_bad_edid) {\r\ndev_warn(connector->dev->dev,\r\n"%s: Ignoring invalid EDID block %d.\n",\r\nconnector->name, j);\r\nconnector->bad_edid_counter++;\r\n}\r\n}\r\nif (valid_extensions != block[0x7e]) {\r\nblock[EDID_LENGTH-1] += block[0x7e] - valid_extensions;\r\nblock[0x7e] = valid_extensions;\r\nnew = krealloc(block, (valid_extensions + 1) * EDID_LENGTH, GFP_KERNEL);\r\nif (!new)\r\ngoto out;\r\nblock = new;\r\n}\r\nreturn (struct edid *)block;\r\ncarp:\r\nif (print_bad_edid) {\r\ndev_warn(connector->dev->dev, "%s: EDID block %d invalid.\n",\r\nconnector->name, j);\r\n}\r\nconnector->bad_edid_counter++;\r\nout:\r\nkfree(block);\r\nreturn NULL;\r\n}\r\nbool\r\ndrm_probe_ddc(struct i2c_adapter *adapter)\r\n{\r\nunsigned char out;\r\nreturn (drm_do_probe_ddc_edid(adapter, &out, 0, 1) == 0);\r\n}\r\nstruct edid *drm_get_edid(struct drm_connector *connector,\r\nstruct i2c_adapter *adapter)\r\n{\r\nstruct edid *edid;\r\nif (!drm_probe_ddc(adapter))\r\nreturn NULL;\r\nedid = drm_do_get_edid(connector, drm_do_probe_ddc_edid, adapter);\r\nif (edid)\r\ndrm_get_displayid(connector, edid);\r\nreturn edid;\r\n}\r\nstruct edid *drm_edid_duplicate(const struct edid *edid)\r\n{\r\nreturn kmemdup(edid, (edid->extensions + 1) * EDID_LENGTH, GFP_KERNEL);\r\n}\r\nstatic bool edid_vendor(struct edid *edid, char *vendor)\r\n{\r\nchar edid_vendor[3];\r\nedid_vendor[0] = ((edid->mfg_id[0] & 0x7c) >> 2) + '@';\r\nedid_vendor[1] = (((edid->mfg_id[0] & 0x3) << 3) |\r\n((edid->mfg_id[1] & 0xe0) >> 5)) + '@';\r\nedid_vendor[2] = (edid->mfg_id[1] & 0x1f) + '@';\r\nreturn !strncmp(edid_vendor, vendor, 3);\r\n}\r\nstatic u32 edid_get_quirks(struct edid *edid)\r\n{\r\nstruct edid_quirk *quirk;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(edid_quirk_list); i++) {\r\nquirk = &edid_quirk_list[i];\r\nif (edid_vendor(edid, quirk->vendor) &&\r\n(EDID_PRODUCT_ID(edid) == quirk->product_id))\r\nreturn quirk->quirks;\r\n}\r\nreturn 0;\r\n}\r\nstatic void edid_fixup_preferred(struct drm_connector *connector,\r\nu32 quirks)\r\n{\r\nstruct drm_display_mode *t, *cur_mode, *preferred_mode;\r\nint target_refresh = 0;\r\nint cur_vrefresh, preferred_vrefresh;\r\nif (list_empty(&connector->probed_modes))\r\nreturn;\r\nif (quirks & EDID_QUIRK_PREFER_LARGE_60)\r\ntarget_refresh = 60;\r\nif (quirks & EDID_QUIRK_PREFER_LARGE_75)\r\ntarget_refresh = 75;\r\npreferred_mode = list_first_entry(&connector->probed_modes,\r\nstruct drm_display_mode, head);\r\nlist_for_each_entry_safe(cur_mode, t, &connector->probed_modes, head) {\r\ncur_mode->type &= ~DRM_MODE_TYPE_PREFERRED;\r\nif (cur_mode == preferred_mode)\r\ncontinue;\r\nif (MODE_SIZE(cur_mode) > MODE_SIZE(preferred_mode))\r\npreferred_mode = cur_mode;\r\ncur_vrefresh = cur_mode->vrefresh ?\r\ncur_mode->vrefresh : drm_mode_vrefresh(cur_mode);\r\npreferred_vrefresh = preferred_mode->vrefresh ?\r\npreferred_mode->vrefresh : drm_mode_vrefresh(preferred_mode);\r\nif ((MODE_SIZE(cur_mode) == MODE_SIZE(preferred_mode)) &&\r\nMODE_REFRESH_DIFF(cur_vrefresh, target_refresh) <\r\nMODE_REFRESH_DIFF(preferred_vrefresh, target_refresh)) {\r\npreferred_mode = cur_mode;\r\n}\r\n}\r\npreferred_mode->type |= DRM_MODE_TYPE_PREFERRED;\r\n}\r\nstatic bool\r\nmode_is_rb(const struct drm_display_mode *mode)\r\n{\r\nreturn (mode->htotal - mode->hdisplay == 160) &&\r\n(mode->hsync_end - mode->hdisplay == 80) &&\r\n(mode->hsync_end - mode->hsync_start == 32) &&\r\n(mode->vsync_start - mode->vdisplay == 3);\r\n}\r\nstruct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,\r\nint hsize, int vsize, int fresh,\r\nbool rb)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(drm_dmt_modes); i++) {\r\nconst struct drm_display_mode *ptr = &drm_dmt_modes[i];\r\nif (hsize != ptr->hdisplay)\r\ncontinue;\r\nif (vsize != ptr->vdisplay)\r\ncontinue;\r\nif (fresh != drm_mode_vrefresh(ptr))\r\ncontinue;\r\nif (rb != mode_is_rb(ptr))\r\ncontinue;\r\nreturn drm_mode_duplicate(dev, ptr);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\ncea_for_each_detailed_block(u8 *ext, detailed_cb *cb, void *closure)\r\n{\r\nint i, n = 0;\r\nu8 d = ext[0x02];\r\nu8 *det_base = ext + d;\r\nn = (127 - d) / 18;\r\nfor (i = 0; i < n; i++)\r\ncb((struct detailed_timing *)(det_base + 18 * i), closure);\r\n}\r\nstatic void\r\nvtb_for_each_detailed_block(u8 *ext, detailed_cb *cb, void *closure)\r\n{\r\nunsigned int i, n = min((int)ext[0x02], 6);\r\nu8 *det_base = ext + 5;\r\nif (ext[0x01] != 1)\r\nreturn;\r\nfor (i = 0; i < n; i++)\r\ncb((struct detailed_timing *)(det_base + 18 * i), closure);\r\n}\r\nstatic void\r\ndrm_for_each_detailed_block(u8 *raw_edid, detailed_cb *cb, void *closure)\r\n{\r\nint i;\r\nstruct edid *edid = (struct edid *)raw_edid;\r\nif (edid == NULL)\r\nreturn;\r\nfor (i = 0; i < EDID_DETAILED_TIMINGS; i++)\r\ncb(&(edid->detailed_timings[i]), closure);\r\nfor (i = 1; i <= raw_edid[0x7e]; i++) {\r\nu8 *ext = raw_edid + (i * EDID_LENGTH);\r\nswitch (*ext) {\r\ncase CEA_EXT:\r\ncea_for_each_detailed_block(ext, cb, closure);\r\nbreak;\r\ncase VTB_EXT:\r\nvtb_for_each_detailed_block(ext, cb, closure);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\nis_rb(struct detailed_timing *t, void *data)\r\n{\r\nu8 *r = (u8 *)t;\r\nif (r[3] == EDID_DETAIL_MONITOR_RANGE)\r\nif (r[15] & 0x10)\r\n*(bool *)data = true;\r\n}\r\nstatic bool\r\ndrm_monitor_supports_rb(struct edid *edid)\r\n{\r\nif (edid->revision >= 4) {\r\nbool ret = false;\r\ndrm_for_each_detailed_block((u8 *)edid, is_rb, &ret);\r\nreturn ret;\r\n}\r\nreturn ((edid->input & DRM_EDID_INPUT_DIGITAL) != 0);\r\n}\r\nstatic void\r\nfind_gtf2(struct detailed_timing *t, void *data)\r\n{\r\nu8 *r = (u8 *)t;\r\nif (r[3] == EDID_DETAIL_MONITOR_RANGE && r[10] == 0x02)\r\n*(u8 **)data = r;\r\n}\r\nstatic int\r\ndrm_gtf2_hbreak(struct edid *edid)\r\n{\r\nu8 *r = NULL;\r\ndrm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);\r\nreturn r ? (r[12] * 2) : 0;\r\n}\r\nstatic int\r\ndrm_gtf2_2c(struct edid *edid)\r\n{\r\nu8 *r = NULL;\r\ndrm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);\r\nreturn r ? r[13] : 0;\r\n}\r\nstatic int\r\ndrm_gtf2_m(struct edid *edid)\r\n{\r\nu8 *r = NULL;\r\ndrm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);\r\nreturn r ? (r[15] << 8) + r[14] : 0;\r\n}\r\nstatic int\r\ndrm_gtf2_k(struct edid *edid)\r\n{\r\nu8 *r = NULL;\r\ndrm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);\r\nreturn r ? r[16] : 0;\r\n}\r\nstatic int\r\ndrm_gtf2_2j(struct edid *edid)\r\n{\r\nu8 *r = NULL;\r\ndrm_for_each_detailed_block((u8 *)edid, find_gtf2, &r);\r\nreturn r ? r[17] : 0;\r\n}\r\nstatic int standard_timing_level(struct edid *edid)\r\n{\r\nif (edid->revision >= 2) {\r\nif (edid->revision >= 4 && (edid->features & DRM_EDID_FEATURE_DEFAULT_GTF))\r\nreturn LEVEL_CVT;\r\nif (drm_gtf2_hbreak(edid))\r\nreturn LEVEL_GTF2;\r\nreturn LEVEL_GTF;\r\n}\r\nreturn LEVEL_DMT;\r\n}\r\nstatic int\r\nbad_std_timing(u8 a, u8 b)\r\n{\r\nreturn (a == 0x00 && b == 0x00) ||\r\n(a == 0x01 && b == 0x01) ||\r\n(a == 0x20 && b == 0x20);\r\n}\r\nstatic struct drm_display_mode *\r\ndrm_mode_std(struct drm_connector *connector, struct edid *edid,\r\nstruct std_timing *t)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_display_mode *m, *mode = NULL;\r\nint hsize, vsize;\r\nint vrefresh_rate;\r\nunsigned aspect_ratio = (t->vfreq_aspect & EDID_TIMING_ASPECT_MASK)\r\n>> EDID_TIMING_ASPECT_SHIFT;\r\nunsigned vfreq = (t->vfreq_aspect & EDID_TIMING_VFREQ_MASK)\r\n>> EDID_TIMING_VFREQ_SHIFT;\r\nint timing_level = standard_timing_level(edid);\r\nif (bad_std_timing(t->hsize, t->vfreq_aspect))\r\nreturn NULL;\r\nhsize = t->hsize * 8 + 248;\r\nvrefresh_rate = vfreq + 60;\r\nif (aspect_ratio == 0) {\r\nif (edid->revision < 3)\r\nvsize = hsize;\r\nelse\r\nvsize = (hsize * 10) / 16;\r\n} else if (aspect_ratio == 1)\r\nvsize = (hsize * 3) / 4;\r\nelse if (aspect_ratio == 2)\r\nvsize = (hsize * 4) / 5;\r\nelse\r\nvsize = (hsize * 9) / 16;\r\nif (vrefresh_rate == 60 &&\r\n((hsize == 1360 && vsize == 765) ||\r\n(hsize == 1368 && vsize == 769))) {\r\nhsize = 1366;\r\nvsize = 768;\r\n}\r\nlist_for_each_entry(m, &connector->probed_modes, head)\r\nif (m->hdisplay == hsize && m->vdisplay == vsize &&\r\ndrm_mode_vrefresh(m) == vrefresh_rate)\r\nreturn NULL;\r\nif (hsize == 1366 && vsize == 768 && vrefresh_rate == 60) {\r\nmode = drm_cvt_mode(dev, 1366, 768, vrefresh_rate, 0, 0,\r\nfalse);\r\nmode->hdisplay = 1366;\r\nmode->hsync_start = mode->hsync_start - 1;\r\nmode->hsync_end = mode->hsync_end - 1;\r\nreturn mode;\r\n}\r\nif (drm_monitor_supports_rb(edid)) {\r\nmode = drm_mode_find_dmt(dev, hsize, vsize, vrefresh_rate,\r\ntrue);\r\nif (mode)\r\nreturn mode;\r\n}\r\nmode = drm_mode_find_dmt(dev, hsize, vsize, vrefresh_rate, false);\r\nif (mode)\r\nreturn mode;\r\nswitch (timing_level) {\r\ncase LEVEL_DMT:\r\nbreak;\r\ncase LEVEL_GTF:\r\nmode = drm_gtf_mode(dev, hsize, vsize, vrefresh_rate, 0, 0);\r\nbreak;\r\ncase LEVEL_GTF2:\r\nmode = drm_gtf_mode(dev, hsize, vsize, vrefresh_rate, 0, 0);\r\nif (!mode)\r\nreturn NULL;\r\nif (drm_mode_hsync(mode) > drm_gtf2_hbreak(edid)) {\r\ndrm_mode_destroy(dev, mode);\r\nmode = drm_gtf_mode_complex(dev, hsize, vsize,\r\nvrefresh_rate, 0, 0,\r\ndrm_gtf2_m(edid),\r\ndrm_gtf2_2c(edid),\r\ndrm_gtf2_k(edid),\r\ndrm_gtf2_2j(edid));\r\n}\r\nbreak;\r\ncase LEVEL_CVT:\r\nmode = drm_cvt_mode(dev, hsize, vsize, vrefresh_rate, 0, 0,\r\nfalse);\r\nbreak;\r\n}\r\nreturn mode;\r\n}\r\nstatic void\r\ndrm_mode_do_interlace_quirk(struct drm_display_mode *mode,\r\nstruct detailed_pixel_timing *pt)\r\n{\r\nint i;\r\nstatic const struct {\r\nint w, h;\r\n} cea_interlaced[] = {\r\n{ 1920, 1080 },\r\n{ 720, 480 },\r\n{ 1440, 480 },\r\n{ 2880, 480 },\r\n{ 720, 576 },\r\n{ 1440, 576 },\r\n{ 2880, 576 },\r\n};\r\nif (!(pt->misc & DRM_EDID_PT_INTERLACED))\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(cea_interlaced); i++) {\r\nif ((mode->hdisplay == cea_interlaced[i].w) &&\r\n(mode->vdisplay == cea_interlaced[i].h / 2)) {\r\nmode->vdisplay *= 2;\r\nmode->vsync_start *= 2;\r\nmode->vsync_end *= 2;\r\nmode->vtotal *= 2;\r\nmode->vtotal |= 1;\r\n}\r\n}\r\nmode->flags |= DRM_MODE_FLAG_INTERLACE;\r\n}\r\nstatic struct drm_display_mode *drm_mode_detailed(struct drm_device *dev,\r\nstruct edid *edid,\r\nstruct detailed_timing *timing,\r\nu32 quirks)\r\n{\r\nstruct drm_display_mode *mode;\r\nstruct detailed_pixel_timing *pt = &timing->data.pixel_data;\r\nunsigned hactive = (pt->hactive_hblank_hi & 0xf0) << 4 | pt->hactive_lo;\r\nunsigned vactive = (pt->vactive_vblank_hi & 0xf0) << 4 | pt->vactive_lo;\r\nunsigned hblank = (pt->hactive_hblank_hi & 0xf) << 8 | pt->hblank_lo;\r\nunsigned vblank = (pt->vactive_vblank_hi & 0xf) << 8 | pt->vblank_lo;\r\nunsigned hsync_offset = (pt->hsync_vsync_offset_pulse_width_hi & 0xc0) << 2 | pt->hsync_offset_lo;\r\nunsigned hsync_pulse_width = (pt->hsync_vsync_offset_pulse_width_hi & 0x30) << 4 | pt->hsync_pulse_width_lo;\r\nunsigned vsync_offset = (pt->hsync_vsync_offset_pulse_width_hi & 0xc) << 2 | pt->vsync_offset_pulse_width_lo >> 4;\r\nunsigned vsync_pulse_width = (pt->hsync_vsync_offset_pulse_width_hi & 0x3) << 4 | (pt->vsync_offset_pulse_width_lo & 0xf);\r\nif (hactive < 64 || vactive < 64)\r\nreturn NULL;\r\nif (pt->misc & DRM_EDID_PT_STEREO) {\r\nDRM_DEBUG_KMS("stereo mode not supported\n");\r\nreturn NULL;\r\n}\r\nif (!(pt->misc & DRM_EDID_PT_SEPARATE_SYNC)) {\r\nDRM_DEBUG_KMS("composite sync not supported\n");\r\n}\r\nif (!hsync_pulse_width || !vsync_pulse_width) {\r\nDRM_DEBUG_KMS("Incorrect Detailed timing. "\r\n"Wrong Hsync/Vsync pulse width\n");\r\nreturn NULL;\r\n}\r\nif (quirks & EDID_QUIRK_FORCE_REDUCED_BLANKING) {\r\nmode = drm_cvt_mode(dev, hactive, vactive, 60, true, false, false);\r\nif (!mode)\r\nreturn NULL;\r\ngoto set_size;\r\n}\r\nmode = drm_mode_create(dev);\r\nif (!mode)\r\nreturn NULL;\r\nif (quirks & EDID_QUIRK_135_CLOCK_TOO_HIGH)\r\ntiming->pixel_clock = cpu_to_le16(1088);\r\nmode->clock = le16_to_cpu(timing->pixel_clock) * 10;\r\nmode->hdisplay = hactive;\r\nmode->hsync_start = mode->hdisplay + hsync_offset;\r\nmode->hsync_end = mode->hsync_start + hsync_pulse_width;\r\nmode->htotal = mode->hdisplay + hblank;\r\nmode->vdisplay = vactive;\r\nmode->vsync_start = mode->vdisplay + vsync_offset;\r\nmode->vsync_end = mode->vsync_start + vsync_pulse_width;\r\nmode->vtotal = mode->vdisplay + vblank;\r\nif (mode->hsync_end > mode->htotal)\r\nmode->htotal = mode->hsync_end + 1;\r\nif (mode->vsync_end > mode->vtotal)\r\nmode->vtotal = mode->vsync_end + 1;\r\ndrm_mode_do_interlace_quirk(mode, pt);\r\nif (quirks & EDID_QUIRK_DETAILED_SYNC_PP) {\r\npt->misc |= DRM_EDID_PT_HSYNC_POSITIVE | DRM_EDID_PT_VSYNC_POSITIVE;\r\n}\r\nmode->flags |= (pt->misc & DRM_EDID_PT_HSYNC_POSITIVE) ?\r\nDRM_MODE_FLAG_PHSYNC : DRM_MODE_FLAG_NHSYNC;\r\nmode->flags |= (pt->misc & DRM_EDID_PT_VSYNC_POSITIVE) ?\r\nDRM_MODE_FLAG_PVSYNC : DRM_MODE_FLAG_NVSYNC;\r\nset_size:\r\nmode->width_mm = pt->width_mm_lo | (pt->width_height_mm_hi & 0xf0) << 4;\r\nmode->height_mm = pt->height_mm_lo | (pt->width_height_mm_hi & 0xf) << 8;\r\nif (quirks & EDID_QUIRK_DETAILED_IN_CM) {\r\nmode->width_mm *= 10;\r\nmode->height_mm *= 10;\r\n}\r\nif (quirks & EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE) {\r\nmode->width_mm = edid->width_cm * 10;\r\nmode->height_mm = edid->height_cm * 10;\r\n}\r\nmode->type = DRM_MODE_TYPE_DRIVER;\r\nmode->vrefresh = drm_mode_vrefresh(mode);\r\ndrm_mode_set_name(mode);\r\nreturn mode;\r\n}\r\nstatic bool\r\nmode_in_hsync_range(const struct drm_display_mode *mode,\r\nstruct edid *edid, u8 *t)\r\n{\r\nint hsync, hmin, hmax;\r\nhmin = t[7];\r\nif (edid->revision >= 4)\r\nhmin += ((t[4] & 0x04) ? 255 : 0);\r\nhmax = t[8];\r\nif (edid->revision >= 4)\r\nhmax += ((t[4] & 0x08) ? 255 : 0);\r\nhsync = drm_mode_hsync(mode);\r\nreturn (hsync <= hmax && hsync >= hmin);\r\n}\r\nstatic bool\r\nmode_in_vsync_range(const struct drm_display_mode *mode,\r\nstruct edid *edid, u8 *t)\r\n{\r\nint vsync, vmin, vmax;\r\nvmin = t[5];\r\nif (edid->revision >= 4)\r\nvmin += ((t[4] & 0x01) ? 255 : 0);\r\nvmax = t[6];\r\nif (edid->revision >= 4)\r\nvmax += ((t[4] & 0x02) ? 255 : 0);\r\nvsync = drm_mode_vrefresh(mode);\r\nreturn (vsync <= vmax && vsync >= vmin);\r\n}\r\nstatic u32\r\nrange_pixel_clock(struct edid *edid, u8 *t)\r\n{\r\nif (t[9] == 0 || t[9] == 255)\r\nreturn 0;\r\nif (edid->revision >= 4 && t[10] == 0x04)\r\nreturn (t[9] * 10000) - ((t[12] >> 2) * 250);\r\nreturn t[9] * 10000 + 5001;\r\n}\r\nstatic bool\r\nmode_in_range(const struct drm_display_mode *mode, struct edid *edid,\r\nstruct detailed_timing *timing)\r\n{\r\nu32 max_clock;\r\nu8 *t = (u8 *)timing;\r\nif (!mode_in_hsync_range(mode, edid, t))\r\nreturn false;\r\nif (!mode_in_vsync_range(mode, edid, t))\r\nreturn false;\r\nif ((max_clock = range_pixel_clock(edid, t)))\r\nif (mode->clock > max_clock)\r\nreturn false;\r\nif (edid->revision >= 4 && t[10] == 0x04)\r\nif (t[13] && mode->hdisplay > 8 * (t[13] + (256 * (t[12]&0x3))))\r\nreturn false;\r\nif (mode_is_rb(mode) && !drm_monitor_supports_rb(edid))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool valid_inferred_mode(const struct drm_connector *connector,\r\nconst struct drm_display_mode *mode)\r\n{\r\nstruct drm_display_mode *m;\r\nbool ok = false;\r\nlist_for_each_entry(m, &connector->probed_modes, head) {\r\nif (mode->hdisplay == m->hdisplay &&\r\nmode->vdisplay == m->vdisplay &&\r\ndrm_mode_vrefresh(mode) == drm_mode_vrefresh(m))\r\nreturn false;\r\nif (mode->hdisplay <= m->hdisplay &&\r\nmode->vdisplay <= m->vdisplay)\r\nok = true;\r\n}\r\nreturn ok;\r\n}\r\nstatic int\r\ndrm_dmt_modes_for_range(struct drm_connector *connector, struct edid *edid,\r\nstruct detailed_timing *timing)\r\n{\r\nint i, modes = 0;\r\nstruct drm_display_mode *newmode;\r\nstruct drm_device *dev = connector->dev;\r\nfor (i = 0; i < ARRAY_SIZE(drm_dmt_modes); i++) {\r\nif (mode_in_range(drm_dmt_modes + i, edid, timing) &&\r\nvalid_inferred_mode(connector, drm_dmt_modes + i)) {\r\nnewmode = drm_mode_duplicate(dev, &drm_dmt_modes[i]);\r\nif (newmode) {\r\ndrm_mode_probed_add(connector, newmode);\r\nmodes++;\r\n}\r\n}\r\n}\r\nreturn modes;\r\n}\r\nstatic void fixup_mode_1366x768(struct drm_display_mode *mode)\r\n{\r\nif (mode->hdisplay == 1368 && mode->vdisplay == 768) {\r\nmode->hdisplay = 1366;\r\nmode->hsync_start--;\r\nmode->hsync_end--;\r\ndrm_mode_set_name(mode);\r\n}\r\n}\r\nstatic int\r\ndrm_gtf_modes_for_range(struct drm_connector *connector, struct edid *edid,\r\nstruct detailed_timing *timing)\r\n{\r\nint i, modes = 0;\r\nstruct drm_display_mode *newmode;\r\nstruct drm_device *dev = connector->dev;\r\nfor (i = 0; i < ARRAY_SIZE(extra_modes); i++) {\r\nconst struct minimode *m = &extra_modes[i];\r\nnewmode = drm_gtf_mode(dev, m->w, m->h, m->r, 0, 0);\r\nif (!newmode)\r\nreturn modes;\r\nfixup_mode_1366x768(newmode);\r\nif (!mode_in_range(newmode, edid, timing) ||\r\n!valid_inferred_mode(connector, newmode)) {\r\ndrm_mode_destroy(dev, newmode);\r\ncontinue;\r\n}\r\ndrm_mode_probed_add(connector, newmode);\r\nmodes++;\r\n}\r\nreturn modes;\r\n}\r\nstatic int\r\ndrm_cvt_modes_for_range(struct drm_connector *connector, struct edid *edid,\r\nstruct detailed_timing *timing)\r\n{\r\nint i, modes = 0;\r\nstruct drm_display_mode *newmode;\r\nstruct drm_device *dev = connector->dev;\r\nbool rb = drm_monitor_supports_rb(edid);\r\nfor (i = 0; i < ARRAY_SIZE(extra_modes); i++) {\r\nconst struct minimode *m = &extra_modes[i];\r\nnewmode = drm_cvt_mode(dev, m->w, m->h, m->r, rb, 0, 0);\r\nif (!newmode)\r\nreturn modes;\r\nfixup_mode_1366x768(newmode);\r\nif (!mode_in_range(newmode, edid, timing) ||\r\n!valid_inferred_mode(connector, newmode)) {\r\ndrm_mode_destroy(dev, newmode);\r\ncontinue;\r\n}\r\ndrm_mode_probed_add(connector, newmode);\r\nmodes++;\r\n}\r\nreturn modes;\r\n}\r\nstatic void\r\ndo_inferred_modes(struct detailed_timing *timing, void *c)\r\n{\r\nstruct detailed_mode_closure *closure = c;\r\nstruct detailed_non_pixel *data = &timing->data.other_data;\r\nstruct detailed_data_monitor_range *range = &data->data.range;\r\nif (data->type != EDID_DETAIL_MONITOR_RANGE)\r\nreturn;\r\nclosure->modes += drm_dmt_modes_for_range(closure->connector,\r\nclosure->edid,\r\ntiming);\r\nif (!version_greater(closure->edid, 1, 1))\r\nreturn;\r\nswitch (range->flags) {\r\ncase 0x02:\r\ncase 0x00:\r\nclosure->modes += drm_gtf_modes_for_range(closure->connector,\r\nclosure->edid,\r\ntiming);\r\nbreak;\r\ncase 0x04:\r\nif (!version_greater(closure->edid, 1, 3))\r\nbreak;\r\nclosure->modes += drm_cvt_modes_for_range(closure->connector,\r\nclosure->edid,\r\ntiming);\r\nbreak;\r\ncase 0x01:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nadd_inferred_modes(struct drm_connector *connector, struct edid *edid)\r\n{\r\nstruct detailed_mode_closure closure = {\r\n.connector = connector,\r\n.edid = edid,\r\n};\r\nif (version_greater(edid, 1, 0))\r\ndrm_for_each_detailed_block((u8 *)edid, do_inferred_modes,\r\n&closure);\r\nreturn closure.modes;\r\n}\r\nstatic int\r\ndrm_est3_modes(struct drm_connector *connector, struct detailed_timing *timing)\r\n{\r\nint i, j, m, modes = 0;\r\nstruct drm_display_mode *mode;\r\nu8 *est = ((u8 *)timing) + 5;\r\nfor (i = 0; i < 6; i++) {\r\nfor (j = 7; j >= 0; j--) {\r\nm = (i * 8) + (7 - j);\r\nif (m >= ARRAY_SIZE(est3_modes))\r\nbreak;\r\nif (est[i] & (1 << j)) {\r\nmode = drm_mode_find_dmt(connector->dev,\r\nest3_modes[m].w,\r\nest3_modes[m].h,\r\nest3_modes[m].r,\r\nest3_modes[m].rb);\r\nif (mode) {\r\ndrm_mode_probed_add(connector, mode);\r\nmodes++;\r\n}\r\n}\r\n}\r\n}\r\nreturn modes;\r\n}\r\nstatic void\r\ndo_established_modes(struct detailed_timing *timing, void *c)\r\n{\r\nstruct detailed_mode_closure *closure = c;\r\nstruct detailed_non_pixel *data = &timing->data.other_data;\r\nif (data->type == EDID_DETAIL_EST_TIMINGS)\r\nclosure->modes += drm_est3_modes(closure->connector, timing);\r\n}\r\nstatic int\r\nadd_established_modes(struct drm_connector *connector, struct edid *edid)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nunsigned long est_bits = edid->established_timings.t1 |\r\n(edid->established_timings.t2 << 8) |\r\n((edid->established_timings.mfg_rsvd & 0x80) << 9);\r\nint i, modes = 0;\r\nstruct detailed_mode_closure closure = {\r\n.connector = connector,\r\n.edid = edid,\r\n};\r\nfor (i = 0; i <= EDID_EST_TIMINGS; i++) {\r\nif (est_bits & (1<<i)) {\r\nstruct drm_display_mode *newmode;\r\nnewmode = drm_mode_duplicate(dev, &edid_est_modes[i]);\r\nif (newmode) {\r\ndrm_mode_probed_add(connector, newmode);\r\nmodes++;\r\n}\r\n}\r\n}\r\nif (version_greater(edid, 1, 0))\r\ndrm_for_each_detailed_block((u8 *)edid,\r\ndo_established_modes, &closure);\r\nreturn modes + closure.modes;\r\n}\r\nstatic void\r\ndo_standard_modes(struct detailed_timing *timing, void *c)\r\n{\r\nstruct detailed_mode_closure *closure = c;\r\nstruct detailed_non_pixel *data = &timing->data.other_data;\r\nstruct drm_connector *connector = closure->connector;\r\nstruct edid *edid = closure->edid;\r\nif (data->type == EDID_DETAIL_STD_MODES) {\r\nint i;\r\nfor (i = 0; i < 6; i++) {\r\nstruct std_timing *std;\r\nstruct drm_display_mode *newmode;\r\nstd = &data->data.timings[i];\r\nnewmode = drm_mode_std(connector, edid, std);\r\nif (newmode) {\r\ndrm_mode_probed_add(connector, newmode);\r\nclosure->modes++;\r\n}\r\n}\r\n}\r\n}\r\nstatic int\r\nadd_standard_modes(struct drm_connector *connector, struct edid *edid)\r\n{\r\nint i, modes = 0;\r\nstruct detailed_mode_closure closure = {\r\n.connector = connector,\r\n.edid = edid,\r\n};\r\nfor (i = 0; i < EDID_STD_TIMINGS; i++) {\r\nstruct drm_display_mode *newmode;\r\nnewmode = drm_mode_std(connector, edid,\r\n&edid->standard_timings[i]);\r\nif (newmode) {\r\ndrm_mode_probed_add(connector, newmode);\r\nmodes++;\r\n}\r\n}\r\nif (version_greater(edid, 1, 0))\r\ndrm_for_each_detailed_block((u8 *)edid, do_standard_modes,\r\n&closure);\r\nreturn modes + closure.modes;\r\n}\r\nstatic int drm_cvt_modes(struct drm_connector *connector,\r\nstruct detailed_timing *timing)\r\n{\r\nint i, j, modes = 0;\r\nstruct drm_display_mode *newmode;\r\nstruct drm_device *dev = connector->dev;\r\nstruct cvt_timing *cvt;\r\nconst int rates[] = { 60, 85, 75, 60, 50 };\r\nconst u8 empty[3] = { 0, 0, 0 };\r\nfor (i = 0; i < 4; i++) {\r\nint uninitialized_var(width), height;\r\ncvt = &(timing->data.other_data.data.cvt[i]);\r\nif (!memcmp(cvt->code, empty, 3))\r\ncontinue;\r\nheight = (cvt->code[0] + ((cvt->code[1] & 0xf0) << 4) + 1) * 2;\r\nswitch (cvt->code[1] & 0x0c) {\r\ncase 0x00:\r\nwidth = height * 4 / 3;\r\nbreak;\r\ncase 0x04:\r\nwidth = height * 16 / 9;\r\nbreak;\r\ncase 0x08:\r\nwidth = height * 16 / 10;\r\nbreak;\r\ncase 0x0c:\r\nwidth = height * 15 / 9;\r\nbreak;\r\n}\r\nfor (j = 1; j < 5; j++) {\r\nif (cvt->code[2] & (1 << j)) {\r\nnewmode = drm_cvt_mode(dev, width, height,\r\nrates[j], j == 0,\r\nfalse, false);\r\nif (newmode) {\r\ndrm_mode_probed_add(connector, newmode);\r\nmodes++;\r\n}\r\n}\r\n}\r\n}\r\nreturn modes;\r\n}\r\nstatic void\r\ndo_cvt_mode(struct detailed_timing *timing, void *c)\r\n{\r\nstruct detailed_mode_closure *closure = c;\r\nstruct detailed_non_pixel *data = &timing->data.other_data;\r\nif (data->type == EDID_DETAIL_CVT_3BYTE)\r\nclosure->modes += drm_cvt_modes(closure->connector, timing);\r\n}\r\nstatic int\r\nadd_cvt_modes(struct drm_connector *connector, struct edid *edid)\r\n{\r\nstruct detailed_mode_closure closure = {\r\n.connector = connector,\r\n.edid = edid,\r\n};\r\nif (version_greater(edid, 1, 2))\r\ndrm_for_each_detailed_block((u8 *)edid, do_cvt_mode, &closure);\r\nreturn closure.modes;\r\n}\r\nstatic void\r\ndo_detailed_mode(struct detailed_timing *timing, void *c)\r\n{\r\nstruct detailed_mode_closure *closure = c;\r\nstruct drm_display_mode *newmode;\r\nif (timing->pixel_clock) {\r\nnewmode = drm_mode_detailed(closure->connector->dev,\r\nclosure->edid, timing,\r\nclosure->quirks);\r\nif (!newmode)\r\nreturn;\r\nif (closure->preferred)\r\nnewmode->type |= DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_probed_add(closure->connector, newmode);\r\nclosure->modes++;\r\nclosure->preferred = 0;\r\n}\r\n}\r\nstatic int\r\nadd_detailed_modes(struct drm_connector *connector, struct edid *edid,\r\nu32 quirks)\r\n{\r\nstruct detailed_mode_closure closure = {\r\n.connector = connector,\r\n.edid = edid,\r\n.preferred = 1,\r\n.quirks = quirks,\r\n};\r\nif (closure.preferred && !version_greater(edid, 1, 3))\r\nclosure.preferred =\r\n(edid->features & DRM_EDID_FEATURE_PREFERRED_TIMING);\r\ndrm_for_each_detailed_block((u8 *)edid, do_detailed_mode, &closure);\r\nreturn closure.modes;\r\n}\r\nstatic u8 *drm_find_edid_extension(struct edid *edid, int ext_id)\r\n{\r\nu8 *edid_ext = NULL;\r\nint i;\r\nif (edid == NULL || edid->extensions == 0)\r\nreturn NULL;\r\nfor (i = 0; i < edid->extensions; i++) {\r\nedid_ext = (u8 *)edid + EDID_LENGTH * (i + 1);\r\nif (edid_ext[0] == ext_id)\r\nbreak;\r\n}\r\nif (i == edid->extensions)\r\nreturn NULL;\r\nreturn edid_ext;\r\n}\r\nstatic u8 *drm_find_cea_extension(struct edid *edid)\r\n{\r\nreturn drm_find_edid_extension(edid, CEA_EXT);\r\n}\r\nstatic u8 *drm_find_displayid_extension(struct edid *edid)\r\n{\r\nreturn drm_find_edid_extension(edid, DISPLAYID_EXT);\r\n}\r\nstatic unsigned int\r\ncea_mode_alternate_clock(const struct drm_display_mode *cea_mode)\r\n{\r\nunsigned int clock = cea_mode->clock;\r\nif (cea_mode->vrefresh % 6 != 0)\r\nreturn clock;\r\nif (cea_mode->vdisplay == 240 || cea_mode->vdisplay == 480)\r\nclock = clock * 1001 / 1000;\r\nelse\r\nclock = DIV_ROUND_UP(clock * 1000, 1001);\r\nreturn clock;\r\n}\r\nu8 drm_match_cea_mode(const struct drm_display_mode *to_match)\r\n{\r\nu8 mode;\r\nif (!to_match->clock)\r\nreturn 0;\r\nfor (mode = 0; mode < ARRAY_SIZE(edid_cea_modes); mode++) {\r\nconst struct drm_display_mode *cea_mode = &edid_cea_modes[mode];\r\nunsigned int clock1, clock2;\r\nclock1 = cea_mode->clock;\r\nclock2 = cea_mode_alternate_clock(cea_mode);\r\nif ((KHZ2PICOS(to_match->clock) == KHZ2PICOS(clock1) ||\r\nKHZ2PICOS(to_match->clock) == KHZ2PICOS(clock2)) &&\r\ndrm_mode_equal_no_clocks_no_stereo(to_match, cea_mode))\r\nreturn mode + 1;\r\n}\r\nreturn 0;\r\n}\r\nenum hdmi_picture_aspect drm_get_cea_aspect_ratio(const u8 video_code)\r\n{\r\nreturn edid_cea_modes[video_code-1].picture_aspect_ratio;\r\n}\r\nstatic unsigned int\r\nhdmi_mode_alternate_clock(const struct drm_display_mode *hdmi_mode)\r\n{\r\nif (hdmi_mode->vdisplay == 4096 && hdmi_mode->hdisplay == 2160)\r\nreturn hdmi_mode->clock;\r\nreturn cea_mode_alternate_clock(hdmi_mode);\r\n}\r\nstatic u8 drm_match_hdmi_mode(const struct drm_display_mode *to_match)\r\n{\r\nu8 mode;\r\nif (!to_match->clock)\r\nreturn 0;\r\nfor (mode = 0; mode < ARRAY_SIZE(edid_4k_modes); mode++) {\r\nconst struct drm_display_mode *hdmi_mode = &edid_4k_modes[mode];\r\nunsigned int clock1, clock2;\r\nclock1 = hdmi_mode->clock;\r\nclock2 = hdmi_mode_alternate_clock(hdmi_mode);\r\nif ((KHZ2PICOS(to_match->clock) == KHZ2PICOS(clock1) ||\r\nKHZ2PICOS(to_match->clock) == KHZ2PICOS(clock2)) &&\r\ndrm_mode_equal_no_clocks_no_stereo(to_match, hdmi_mode))\r\nreturn mode + 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nadd_alternate_cea_modes(struct drm_connector *connector, struct edid *edid)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_display_mode *mode, *tmp;\r\nLIST_HEAD(list);\r\nint modes = 0;\r\nif (!drm_find_cea_extension(edid))\r\nreturn 0;\r\nlist_for_each_entry(mode, &connector->probed_modes, head) {\r\nconst struct drm_display_mode *cea_mode = NULL;\r\nstruct drm_display_mode *newmode;\r\nu8 mode_idx = drm_match_cea_mode(mode) - 1;\r\nunsigned int clock1, clock2;\r\nif (mode_idx < ARRAY_SIZE(edid_cea_modes)) {\r\ncea_mode = &edid_cea_modes[mode_idx];\r\nclock2 = cea_mode_alternate_clock(cea_mode);\r\n} else {\r\nmode_idx = drm_match_hdmi_mode(mode) - 1;\r\nif (mode_idx < ARRAY_SIZE(edid_4k_modes)) {\r\ncea_mode = &edid_4k_modes[mode_idx];\r\nclock2 = hdmi_mode_alternate_clock(cea_mode);\r\n}\r\n}\r\nif (!cea_mode)\r\ncontinue;\r\nclock1 = cea_mode->clock;\r\nif (clock1 == clock2)\r\ncontinue;\r\nif (mode->clock != clock1 && mode->clock != clock2)\r\ncontinue;\r\nnewmode = drm_mode_duplicate(dev, cea_mode);\r\nif (!newmode)\r\ncontinue;\r\nnewmode->flags |= mode->flags & DRM_MODE_FLAG_3D_MASK;\r\nif (mode->clock != clock1)\r\nnewmode->clock = clock1;\r\nelse\r\nnewmode->clock = clock2;\r\nlist_add_tail(&newmode->head, &list);\r\n}\r\nlist_for_each_entry_safe(mode, tmp, &list, head) {\r\nlist_del(&mode->head);\r\ndrm_mode_probed_add(connector, mode);\r\nmodes++;\r\n}\r\nreturn modes;\r\n}\r\nstatic struct drm_display_mode *\r\ndrm_display_mode_from_vic_index(struct drm_connector *connector,\r\nconst u8 *video_db, u8 video_len,\r\nu8 video_index)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_display_mode *newmode;\r\nu8 cea_mode;\r\nif (video_db == NULL || video_index >= video_len)\r\nreturn NULL;\r\ncea_mode = (video_db[video_index] & 127) - 1;\r\nif (cea_mode >= ARRAY_SIZE(edid_cea_modes))\r\nreturn NULL;\r\nnewmode = drm_mode_duplicate(dev, &edid_cea_modes[cea_mode]);\r\nif (!newmode)\r\nreturn NULL;\r\nnewmode->vrefresh = 0;\r\nreturn newmode;\r\n}\r\nstatic int\r\ndo_cea_modes(struct drm_connector *connector, const u8 *db, u8 len)\r\n{\r\nint i, modes = 0;\r\nfor (i = 0; i < len; i++) {\r\nstruct drm_display_mode *mode;\r\nmode = drm_display_mode_from_vic_index(connector, db, len, i);\r\nif (mode) {\r\ndrm_mode_probed_add(connector, mode);\r\nmodes++;\r\n}\r\n}\r\nreturn modes;\r\n}\r\nstatic bool\r\nstereo_match_mandatory(const struct drm_display_mode *mode,\r\nconst struct stereo_mandatory_mode *stereo_mode)\r\n{\r\nunsigned int interlaced = mode->flags & DRM_MODE_FLAG_INTERLACE;\r\nreturn mode->hdisplay == stereo_mode->width &&\r\nmode->vdisplay == stereo_mode->height &&\r\ninterlaced == (stereo_mode->flags & DRM_MODE_FLAG_INTERLACE) &&\r\ndrm_mode_vrefresh(mode) == stereo_mode->vrefresh;\r\n}\r\nstatic int add_hdmi_mandatory_stereo_modes(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nconst struct drm_display_mode *mode;\r\nstruct list_head stereo_modes;\r\nint modes = 0, i;\r\nINIT_LIST_HEAD(&stereo_modes);\r\nlist_for_each_entry(mode, &connector->probed_modes, head) {\r\nfor (i = 0; i < ARRAY_SIZE(stereo_mandatory_modes); i++) {\r\nconst struct stereo_mandatory_mode *mandatory;\r\nstruct drm_display_mode *new_mode;\r\nif (!stereo_match_mandatory(mode,\r\n&stereo_mandatory_modes[i]))\r\ncontinue;\r\nmandatory = &stereo_mandatory_modes[i];\r\nnew_mode = drm_mode_duplicate(dev, mode);\r\nif (!new_mode)\r\ncontinue;\r\nnew_mode->flags |= mandatory->flags;\r\nlist_add_tail(&new_mode->head, &stereo_modes);\r\nmodes++;\r\n}\r\n}\r\nlist_splice_tail(&stereo_modes, &connector->probed_modes);\r\nreturn modes;\r\n}\r\nstatic int add_hdmi_mode(struct drm_connector *connector, u8 vic)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_display_mode *newmode;\r\nvic--;\r\nif (vic >= ARRAY_SIZE(edid_4k_modes)) {\r\nDRM_ERROR("Unknown HDMI VIC: %d\n", vic);\r\nreturn 0;\r\n}\r\nnewmode = drm_mode_duplicate(dev, &edid_4k_modes[vic]);\r\nif (!newmode)\r\nreturn 0;\r\ndrm_mode_probed_add(connector, newmode);\r\nreturn 1;\r\n}\r\nstatic int add_3d_struct_modes(struct drm_connector *connector, u16 structure,\r\nconst u8 *video_db, u8 video_len, u8 video_index)\r\n{\r\nstruct drm_display_mode *newmode;\r\nint modes = 0;\r\nif (structure & (1 << 0)) {\r\nnewmode = drm_display_mode_from_vic_index(connector, video_db,\r\nvideo_len,\r\nvideo_index);\r\nif (newmode) {\r\nnewmode->flags |= DRM_MODE_FLAG_3D_FRAME_PACKING;\r\ndrm_mode_probed_add(connector, newmode);\r\nmodes++;\r\n}\r\n}\r\nif (structure & (1 << 6)) {\r\nnewmode = drm_display_mode_from_vic_index(connector, video_db,\r\nvideo_len,\r\nvideo_index);\r\nif (newmode) {\r\nnewmode->flags |= DRM_MODE_FLAG_3D_TOP_AND_BOTTOM;\r\ndrm_mode_probed_add(connector, newmode);\r\nmodes++;\r\n}\r\n}\r\nif (structure & (1 << 8)) {\r\nnewmode = drm_display_mode_from_vic_index(connector, video_db,\r\nvideo_len,\r\nvideo_index);\r\nif (newmode) {\r\nnewmode->flags |= DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF;\r\ndrm_mode_probed_add(connector, newmode);\r\nmodes++;\r\n}\r\n}\r\nreturn modes;\r\n}\r\nstatic int\r\ndo_hdmi_vsdb_modes(struct drm_connector *connector, const u8 *db, u8 len,\r\nconst u8 *video_db, u8 video_len)\r\n{\r\nint modes = 0, offset = 0, i, multi_present = 0, multi_len;\r\nu8 vic_len, hdmi_3d_len = 0;\r\nu16 mask;\r\nu16 structure_all;\r\nif (len < 8)\r\ngoto out;\r\nif (!(db[8] & (1 << 5)))\r\ngoto out;\r\nif (db[8] & (1 << 7))\r\noffset += 2;\r\nif (db[8] & (1 << 6))\r\noffset += 2;\r\nif (len < (8 + offset + 2))\r\ngoto out;\r\noffset++;\r\nif (db[8 + offset] & (1 << 7)) {\r\nmodes += add_hdmi_mandatory_stereo_modes(connector);\r\nmulti_present = (db[8 + offset] & 0x60) >> 5;\r\n}\r\noffset++;\r\nvic_len = db[8 + offset] >> 5;\r\nhdmi_3d_len = db[8 + offset] & 0x1f;\r\nfor (i = 0; i < vic_len && len >= (9 + offset + i); i++) {\r\nu8 vic;\r\nvic = db[9 + offset + i];\r\nmodes += add_hdmi_mode(connector, vic);\r\n}\r\noffset += 1 + vic_len;\r\nif (multi_present == 1)\r\nmulti_len = 2;\r\nelse if (multi_present == 2)\r\nmulti_len = 4;\r\nelse\r\nmulti_len = 0;\r\nif (len < (8 + offset + hdmi_3d_len - 1))\r\ngoto out;\r\nif (hdmi_3d_len < multi_len)\r\ngoto out;\r\nif (multi_present == 1 || multi_present == 2) {\r\nstructure_all = (db[8 + offset] << 8) | db[9 + offset];\r\nif (multi_present == 2)\r\nmask = (db[10 + offset] << 8) | db[11 + offset];\r\nelse\r\nmask = 0xffff;\r\nfor (i = 0; i < 16; i++) {\r\nif (mask & (1 << i))\r\nmodes += add_3d_struct_modes(connector,\r\nstructure_all,\r\nvideo_db,\r\nvideo_len, i);\r\n}\r\n}\r\noffset += multi_len;\r\nfor (i = 0; i < (hdmi_3d_len - multi_len); i++) {\r\nint vic_index;\r\nstruct drm_display_mode *newmode = NULL;\r\nunsigned int newflag = 0;\r\nbool detail_present;\r\ndetail_present = ((db[8 + offset + i] & 0x0f) > 7);\r\nif (detail_present && (i + 1 == hdmi_3d_len - multi_len))\r\nbreak;\r\nvic_index = db[8 + offset + i] >> 4;\r\nswitch (db[8 + offset + i] & 0x0f) {\r\ncase 0:\r\nnewflag = DRM_MODE_FLAG_3D_FRAME_PACKING;\r\nbreak;\r\ncase 6:\r\nnewflag = DRM_MODE_FLAG_3D_TOP_AND_BOTTOM;\r\nbreak;\r\ncase 8:\r\nif ((db[9 + offset + i] >> 4) == 1)\r\nnewflag = DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF;\r\nbreak;\r\n}\r\nif (newflag != 0) {\r\nnewmode = drm_display_mode_from_vic_index(connector,\r\nvideo_db,\r\nvideo_len,\r\nvic_index);\r\nif (newmode) {\r\nnewmode->flags |= newflag;\r\ndrm_mode_probed_add(connector, newmode);\r\nmodes++;\r\n}\r\n}\r\nif (detail_present)\r\ni++;\r\n}\r\nout:\r\nreturn modes;\r\n}\r\nstatic int\r\ncea_db_payload_len(const u8 *db)\r\n{\r\nreturn db[0] & 0x1f;\r\n}\r\nstatic int\r\ncea_db_tag(const u8 *db)\r\n{\r\nreturn db[0] >> 5;\r\n}\r\nstatic int\r\ncea_revision(const u8 *cea)\r\n{\r\nreturn cea[1];\r\n}\r\nstatic int\r\ncea_db_offsets(const u8 *cea, int *start, int *end)\r\n{\r\n*start = 4;\r\n*end = cea[2];\r\nif (*end == 0)\r\n*end = 127;\r\nif (*end < 4 || *end > 127)\r\nreturn -ERANGE;\r\nreturn 0;\r\n}\r\nstatic bool cea_db_is_hdmi_vsdb(const u8 *db)\r\n{\r\nint hdmi_id;\r\nif (cea_db_tag(db) != VENDOR_BLOCK)\r\nreturn false;\r\nif (cea_db_payload_len(db) < 5)\r\nreturn false;\r\nhdmi_id = db[1] | (db[2] << 8) | (db[3] << 16);\r\nreturn hdmi_id == HDMI_IEEE_OUI;\r\n}\r\nstatic int\r\nadd_cea_modes(struct drm_connector *connector, struct edid *edid)\r\n{\r\nconst u8 *cea = drm_find_cea_extension(edid);\r\nconst u8 *db, *hdmi = NULL, *video = NULL;\r\nu8 dbl, hdmi_len, video_len = 0;\r\nint modes = 0;\r\nif (cea && cea_revision(cea) >= 3) {\r\nint i, start, end;\r\nif (cea_db_offsets(cea, &start, &end))\r\nreturn 0;\r\nfor_each_cea_db(cea, i, start, end) {\r\ndb = &cea[i];\r\ndbl = cea_db_payload_len(db);\r\nif (cea_db_tag(db) == VIDEO_BLOCK) {\r\nvideo = db + 1;\r\nvideo_len = dbl;\r\nmodes += do_cea_modes(connector, video, dbl);\r\n}\r\nelse if (cea_db_is_hdmi_vsdb(db)) {\r\nhdmi = db;\r\nhdmi_len = dbl;\r\n}\r\n}\r\n}\r\nif (hdmi)\r\nmodes += do_hdmi_vsdb_modes(connector, hdmi, hdmi_len, video,\r\nvideo_len);\r\nreturn modes;\r\n}\r\nstatic void\r\nparse_hdmi_vsdb(struct drm_connector *connector, const u8 *db)\r\n{\r\nu8 len = cea_db_payload_len(db);\r\nif (len >= 6) {\r\nconnector->eld[5] |= (db[6] >> 7) << 1;\r\nconnector->dvi_dual = db[6] & 1;\r\n}\r\nif (len >= 7)\r\nconnector->max_tmds_clock = db[7] * 5;\r\nif (len >= 8) {\r\nconnector->latency_present[0] = db[8] >> 7;\r\nconnector->latency_present[1] = (db[8] >> 6) & 1;\r\n}\r\nif (len >= 9)\r\nconnector->video_latency[0] = db[9];\r\nif (len >= 10)\r\nconnector->audio_latency[0] = db[10];\r\nif (len >= 11)\r\nconnector->video_latency[1] = db[11];\r\nif (len >= 12)\r\nconnector->audio_latency[1] = db[12];\r\nDRM_DEBUG_KMS("HDMI: DVI dual %d, "\r\n"max TMDS clock %d, "\r\n"latency present %d %d, "\r\n"video latency %d %d, "\r\n"audio latency %d %d\n",\r\nconnector->dvi_dual,\r\nconnector->max_tmds_clock,\r\n(int) connector->latency_present[0],\r\n(int) connector->latency_present[1],\r\nconnector->video_latency[0],\r\nconnector->video_latency[1],\r\nconnector->audio_latency[0],\r\nconnector->audio_latency[1]);\r\n}\r\nstatic void\r\nmonitor_name(struct detailed_timing *t, void *data)\r\n{\r\nif (t->data.other_data.type == EDID_DETAIL_MONITOR_NAME)\r\n*(u8 **)data = t->data.other_data.data.str.str;\r\n}\r\nvoid drm_edid_to_eld(struct drm_connector *connector, struct edid *edid)\r\n{\r\nuint8_t *eld = connector->eld;\r\nu8 *cea;\r\nu8 *name;\r\nu8 *db;\r\nint sad_count = 0;\r\nint mnl;\r\nint dbl;\r\nmemset(eld, 0, sizeof(connector->eld));\r\ncea = drm_find_cea_extension(edid);\r\nif (!cea) {\r\nDRM_DEBUG_KMS("ELD: no CEA Extension found\n");\r\nreturn;\r\n}\r\nname = NULL;\r\ndrm_for_each_detailed_block((u8 *)edid, monitor_name, &name);\r\nfor (mnl = 0; name && mnl < 13; mnl++) {\r\nif (name[mnl] == 0x0a)\r\nbreak;\r\neld[20 + mnl] = name[mnl];\r\n}\r\neld[4] = (cea[1] << 5) | mnl;\r\nDRM_DEBUG_KMS("ELD monitor %s\n", eld + 20);\r\neld[0] = 2 << 3;\r\neld[16] = edid->mfg_id[0];\r\neld[17] = edid->mfg_id[1];\r\neld[18] = edid->prod_code[0];\r\neld[19] = edid->prod_code[1];\r\nif (cea_revision(cea) >= 3) {\r\nint i, start, end;\r\nif (cea_db_offsets(cea, &start, &end)) {\r\nstart = 0;\r\nend = 0;\r\n}\r\nfor_each_cea_db(cea, i, start, end) {\r\ndb = &cea[i];\r\ndbl = cea_db_payload_len(db);\r\nswitch (cea_db_tag(db)) {\r\ncase AUDIO_BLOCK:\r\nsad_count = dbl / 3;\r\nif (dbl >= 1)\r\nmemcpy(eld + 20 + mnl, &db[1], dbl);\r\nbreak;\r\ncase SPEAKER_BLOCK:\r\nif (dbl >= 1)\r\neld[7] = db[1];\r\nbreak;\r\ncase VENDOR_BLOCK:\r\nif (cea_db_is_hdmi_vsdb(db))\r\nparse_hdmi_vsdb(connector, db);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\neld[5] |= sad_count << 4;\r\neld[DRM_ELD_BASELINE_ELD_LEN] =\r\nDIV_ROUND_UP(drm_eld_calc_baseline_block_size(eld), 4);\r\nDRM_DEBUG_KMS("ELD size %d, SAD count %d\n",\r\ndrm_eld_size(eld), sad_count);\r\n}\r\nint drm_edid_to_sad(struct edid *edid, struct cea_sad **sads)\r\n{\r\nint count = 0;\r\nint i, start, end, dbl;\r\nu8 *cea;\r\ncea = drm_find_cea_extension(edid);\r\nif (!cea) {\r\nDRM_DEBUG_KMS("SAD: no CEA Extension found\n");\r\nreturn -ENOENT;\r\n}\r\nif (cea_revision(cea) < 3) {\r\nDRM_DEBUG_KMS("SAD: wrong CEA revision\n");\r\nreturn -ENOTSUPP;\r\n}\r\nif (cea_db_offsets(cea, &start, &end)) {\r\nDRM_DEBUG_KMS("SAD: invalid data block offsets\n");\r\nreturn -EPROTO;\r\n}\r\nfor_each_cea_db(cea, i, start, end) {\r\nu8 *db = &cea[i];\r\nif (cea_db_tag(db) == AUDIO_BLOCK) {\r\nint j;\r\ndbl = cea_db_payload_len(db);\r\ncount = dbl / 3;\r\n*sads = kcalloc(count, sizeof(**sads), GFP_KERNEL);\r\nif (!*sads)\r\nreturn -ENOMEM;\r\nfor (j = 0; j < count; j++) {\r\nu8 *sad = &db[1 + j * 3];\r\n(*sads)[j].format = (sad[0] & 0x78) >> 3;\r\n(*sads)[j].channels = sad[0] & 0x7;\r\n(*sads)[j].freq = sad[1] & 0x7F;\r\n(*sads)[j].byte2 = sad[2];\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn count;\r\n}\r\nint drm_edid_to_speaker_allocation(struct edid *edid, u8 **sadb)\r\n{\r\nint count = 0;\r\nint i, start, end, dbl;\r\nconst u8 *cea;\r\ncea = drm_find_cea_extension(edid);\r\nif (!cea) {\r\nDRM_DEBUG_KMS("SAD: no CEA Extension found\n");\r\nreturn -ENOENT;\r\n}\r\nif (cea_revision(cea) < 3) {\r\nDRM_DEBUG_KMS("SAD: wrong CEA revision\n");\r\nreturn -ENOTSUPP;\r\n}\r\nif (cea_db_offsets(cea, &start, &end)) {\r\nDRM_DEBUG_KMS("SAD: invalid data block offsets\n");\r\nreturn -EPROTO;\r\n}\r\nfor_each_cea_db(cea, i, start, end) {\r\nconst u8 *db = &cea[i];\r\nif (cea_db_tag(db) == SPEAKER_BLOCK) {\r\ndbl = cea_db_payload_len(db);\r\nif (dbl == 3) {\r\n*sadb = kmemdup(&db[1], dbl, GFP_KERNEL);\r\nif (!*sadb)\r\nreturn -ENOMEM;\r\ncount = dbl;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn count;\r\n}\r\nint drm_av_sync_delay(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nint i = !!(mode->flags & DRM_MODE_FLAG_INTERLACE);\r\nint a, v;\r\nif (!connector->latency_present[0])\r\nreturn 0;\r\nif (!connector->latency_present[1])\r\ni = 0;\r\na = connector->audio_latency[i];\r\nv = connector->video_latency[i];\r\nif (a == 255 || v == 255)\r\nreturn 0;\r\nif (a)\r\na = min(2 * (a - 1), 500);\r\nif (v)\r\nv = min(2 * (v - 1), 500);\r\nreturn max(v - a, 0);\r\n}\r\nstruct drm_connector *drm_select_eld(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct drm_connector *connector;\r\nstruct drm_device *dev = encoder->dev;\r\nWARN_ON(!mutex_is_locked(&dev->mode_config.mutex));\r\nWARN_ON(!drm_modeset_is_locked(&dev->mode_config.connection_mutex));\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head)\r\nif (connector->encoder == encoder && connector->eld[0])\r\nreturn connector;\r\nreturn NULL;\r\n}\r\nbool drm_detect_hdmi_monitor(struct edid *edid)\r\n{\r\nu8 *edid_ext;\r\nint i;\r\nint start_offset, end_offset;\r\nedid_ext = drm_find_cea_extension(edid);\r\nif (!edid_ext)\r\nreturn false;\r\nif (cea_db_offsets(edid_ext, &start_offset, &end_offset))\r\nreturn false;\r\nfor_each_cea_db(edid_ext, i, start_offset, end_offset) {\r\nif (cea_db_is_hdmi_vsdb(&edid_ext[i]))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nbool drm_detect_monitor_audio(struct edid *edid)\r\n{\r\nu8 *edid_ext;\r\nint i, j;\r\nbool has_audio = false;\r\nint start_offset, end_offset;\r\nedid_ext = drm_find_cea_extension(edid);\r\nif (!edid_ext)\r\ngoto end;\r\nhas_audio = ((edid_ext[3] & EDID_BASIC_AUDIO) != 0);\r\nif (has_audio) {\r\nDRM_DEBUG_KMS("Monitor has basic audio support\n");\r\ngoto end;\r\n}\r\nif (cea_db_offsets(edid_ext, &start_offset, &end_offset))\r\ngoto end;\r\nfor_each_cea_db(edid_ext, i, start_offset, end_offset) {\r\nif (cea_db_tag(&edid_ext[i]) == AUDIO_BLOCK) {\r\nhas_audio = true;\r\nfor (j = 1; j < cea_db_payload_len(&edid_ext[i]) + 1; j += 3)\r\nDRM_DEBUG_KMS("CEA audio format %d\n",\r\n(edid_ext[i + j] >> 3) & 0xf);\r\ngoto end;\r\n}\r\n}\r\nend:\r\nreturn has_audio;\r\n}\r\nbool drm_rgb_quant_range_selectable(struct edid *edid)\r\n{\r\nu8 *edid_ext;\r\nint i, start, end;\r\nedid_ext = drm_find_cea_extension(edid);\r\nif (!edid_ext)\r\nreturn false;\r\nif (cea_db_offsets(edid_ext, &start, &end))\r\nreturn false;\r\nfor_each_cea_db(edid_ext, i, start, end) {\r\nif (cea_db_tag(&edid_ext[i]) == VIDEO_CAPABILITY_BLOCK &&\r\ncea_db_payload_len(&edid_ext[i]) == 2) {\r\nDRM_DEBUG_KMS("CEA VCDB 0x%02x\n", edid_ext[i + 2]);\r\nreturn edid_ext[i + 2] & EDID_CEA_VCDB_QS;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic bool drm_assign_hdmi_deep_color_info(struct edid *edid,\r\nstruct drm_display_info *info,\r\nstruct drm_connector *connector)\r\n{\r\nu8 *edid_ext, *hdmi;\r\nint i;\r\nint start_offset, end_offset;\r\nunsigned int dc_bpc = 0;\r\nedid_ext = drm_find_cea_extension(edid);\r\nif (!edid_ext)\r\nreturn false;\r\nif (cea_db_offsets(edid_ext, &start_offset, &end_offset))\r\nreturn false;\r\nfor_each_cea_db(edid_ext, i, start_offset, end_offset) {\r\nif (cea_db_is_hdmi_vsdb(&edid_ext[i])) {\r\ninfo->bpc = 8;\r\nhdmi = &edid_ext[i];\r\nif (cea_db_payload_len(hdmi) < 6)\r\nreturn false;\r\nif (hdmi[6] & DRM_EDID_HDMI_DC_30) {\r\ndc_bpc = 10;\r\ninfo->edid_hdmi_dc_modes |= DRM_EDID_HDMI_DC_30;\r\nDRM_DEBUG("%s: HDMI sink does deep color 30.\n",\r\nconnector->name);\r\n}\r\nif (hdmi[6] & DRM_EDID_HDMI_DC_36) {\r\ndc_bpc = 12;\r\ninfo->edid_hdmi_dc_modes |= DRM_EDID_HDMI_DC_36;\r\nDRM_DEBUG("%s: HDMI sink does deep color 36.\n",\r\nconnector->name);\r\n}\r\nif (hdmi[6] & DRM_EDID_HDMI_DC_48) {\r\ndc_bpc = 16;\r\ninfo->edid_hdmi_dc_modes |= DRM_EDID_HDMI_DC_48;\r\nDRM_DEBUG("%s: HDMI sink does deep color 48.\n",\r\nconnector->name);\r\n}\r\nif (dc_bpc > 0) {\r\nDRM_DEBUG("%s: Assigning HDMI sink color depth as %d bpc.\n",\r\nconnector->name, dc_bpc);\r\ninfo->bpc = dc_bpc;\r\ninfo->color_formats = DRM_COLOR_FORMAT_RGB444;\r\nif (hdmi[6] & DRM_EDID_HDMI_DC_Y444) {\r\ninfo->color_formats |= DRM_COLOR_FORMAT_YCRCB444;\r\nDRM_DEBUG("%s: HDMI sink does YCRCB444 in deep color.\n",\r\nconnector->name);\r\n}\r\nif (!(hdmi[6] & DRM_EDID_HDMI_DC_36)) {\r\nDRM_DEBUG("%s: HDMI sink should do DC_36, but does not!\n",\r\nconnector->name);\r\n}\r\nreturn true;\r\n}\r\nelse {\r\nDRM_DEBUG("%s: No deep color support on this HDMI sink.\n",\r\nconnector->name);\r\n}\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic void drm_add_display_info(struct edid *edid,\r\nstruct drm_display_info *info,\r\nstruct drm_connector *connector)\r\n{\r\nu8 *edid_ext;\r\ninfo->width_mm = edid->width_cm * 10;\r\ninfo->height_mm = edid->height_cm * 10;\r\ninfo->bpc = 0;\r\ninfo->color_formats = 0;\r\nif (edid->revision < 3)\r\nreturn;\r\nif (!(edid->input & DRM_EDID_INPUT_DIGITAL))\r\nreturn;\r\nedid_ext = drm_find_cea_extension(edid);\r\nif (edid_ext) {\r\ninfo->cea_rev = edid_ext[1];\r\ninfo->color_formats = DRM_COLOR_FORMAT_RGB444;\r\nif (edid_ext[3] & EDID_CEA_YCRCB444)\r\ninfo->color_formats |= DRM_COLOR_FORMAT_YCRCB444;\r\nif (edid_ext[3] & EDID_CEA_YCRCB422)\r\ninfo->color_formats |= DRM_COLOR_FORMAT_YCRCB422;\r\n}\r\ndrm_assign_hdmi_deep_color_info(edid, info, connector);\r\nif (edid->revision < 4)\r\nreturn;\r\nswitch (edid->input & DRM_EDID_DIGITAL_DEPTH_MASK) {\r\ncase DRM_EDID_DIGITAL_DEPTH_6:\r\ninfo->bpc = 6;\r\nbreak;\r\ncase DRM_EDID_DIGITAL_DEPTH_8:\r\ninfo->bpc = 8;\r\nbreak;\r\ncase DRM_EDID_DIGITAL_DEPTH_10:\r\ninfo->bpc = 10;\r\nbreak;\r\ncase DRM_EDID_DIGITAL_DEPTH_12:\r\ninfo->bpc = 12;\r\nbreak;\r\ncase DRM_EDID_DIGITAL_DEPTH_14:\r\ninfo->bpc = 14;\r\nbreak;\r\ncase DRM_EDID_DIGITAL_DEPTH_16:\r\ninfo->bpc = 16;\r\nbreak;\r\ncase DRM_EDID_DIGITAL_DEPTH_UNDEF:\r\ndefault:\r\ninfo->bpc = 0;\r\nbreak;\r\n}\r\nDRM_DEBUG("%s: Assigning EDID-1.4 digital sink color depth as %d bpc.\n",\r\nconnector->name, info->bpc);\r\ninfo->color_formats |= DRM_COLOR_FORMAT_RGB444;\r\nif (edid->features & DRM_EDID_FEATURE_RGB_YCRCB444)\r\ninfo->color_formats |= DRM_COLOR_FORMAT_YCRCB444;\r\nif (edid->features & DRM_EDID_FEATURE_RGB_YCRCB422)\r\ninfo->color_formats |= DRM_COLOR_FORMAT_YCRCB422;\r\n}\r\nint drm_add_edid_modes(struct drm_connector *connector, struct edid *edid)\r\n{\r\nint num_modes = 0;\r\nu32 quirks;\r\nif (edid == NULL) {\r\nreturn 0;\r\n}\r\nif (!drm_edid_is_valid(edid)) {\r\ndev_warn(connector->dev->dev, "%s: EDID invalid.\n",\r\nconnector->name);\r\nreturn 0;\r\n}\r\nquirks = edid_get_quirks(edid);\r\nnum_modes += add_detailed_modes(connector, edid, quirks);\r\nnum_modes += add_cvt_modes(connector, edid);\r\nnum_modes += add_standard_modes(connector, edid);\r\nnum_modes += add_established_modes(connector, edid);\r\nif (edid->features & DRM_EDID_FEATURE_DEFAULT_GTF)\r\nnum_modes += add_inferred_modes(connector, edid);\r\nnum_modes += add_cea_modes(connector, edid);\r\nnum_modes += add_alternate_cea_modes(connector, edid);\r\nif (quirks & (EDID_QUIRK_PREFER_LARGE_60 | EDID_QUIRK_PREFER_LARGE_75))\r\nedid_fixup_preferred(connector, quirks);\r\ndrm_add_display_info(edid, &connector->display_info, connector);\r\nif (quirks & EDID_QUIRK_FORCE_8BPC)\r\nconnector->display_info.bpc = 8;\r\nif (quirks & EDID_QUIRK_FORCE_12BPC)\r\nconnector->display_info.bpc = 12;\r\nreturn num_modes;\r\n}\r\nint drm_add_modes_noedid(struct drm_connector *connector,\r\nint hdisplay, int vdisplay)\r\n{\r\nint i, count, num_modes = 0;\r\nstruct drm_display_mode *mode;\r\nstruct drm_device *dev = connector->dev;\r\ncount = sizeof(drm_dmt_modes) / sizeof(struct drm_display_mode);\r\nif (hdisplay < 0)\r\nhdisplay = 0;\r\nif (vdisplay < 0)\r\nvdisplay = 0;\r\nfor (i = 0; i < count; i++) {\r\nconst struct drm_display_mode *ptr = &drm_dmt_modes[i];\r\nif (hdisplay && vdisplay) {\r\nif (ptr->hdisplay > hdisplay ||\r\nptr->vdisplay > vdisplay)\r\ncontinue;\r\n}\r\nif (drm_mode_vrefresh(ptr) > 61)\r\ncontinue;\r\nmode = drm_mode_duplicate(dev, ptr);\r\nif (mode) {\r\ndrm_mode_probed_add(connector, mode);\r\nnum_modes++;\r\n}\r\n}\r\nreturn num_modes;\r\n}\r\nvoid drm_set_preferred_mode(struct drm_connector *connector,\r\nint hpref, int vpref)\r\n{\r\nstruct drm_display_mode *mode;\r\nlist_for_each_entry(mode, &connector->probed_modes, head) {\r\nif (mode->hdisplay == hpref &&\r\nmode->vdisplay == vpref)\r\nmode->type |= DRM_MODE_TYPE_PREFERRED;\r\n}\r\n}\r\nint\r\ndrm_hdmi_avi_infoframe_from_display_mode(struct hdmi_avi_infoframe *frame,\r\nconst struct drm_display_mode *mode)\r\n{\r\nint err;\r\nif (!frame || !mode)\r\nreturn -EINVAL;\r\nerr = hdmi_avi_infoframe_init(frame);\r\nif (err < 0)\r\nreturn err;\r\nif (mode->flags & DRM_MODE_FLAG_DBLCLK)\r\nframe->pixel_repeat = 1;\r\nframe->video_code = drm_match_cea_mode(mode);\r\nframe->picture_aspect = HDMI_PICTURE_ASPECT_NONE;\r\nif (mode->picture_aspect_ratio == HDMI_PICTURE_ASPECT_4_3 ||\r\nmode->picture_aspect_ratio == HDMI_PICTURE_ASPECT_16_9)\r\nframe->picture_aspect = mode->picture_aspect_ratio;\r\nelse if (frame->video_code > 0)\r\nframe->picture_aspect = drm_get_cea_aspect_ratio(\r\nframe->video_code);\r\nframe->active_aspect = HDMI_ACTIVE_ASPECT_PICTURE;\r\nframe->scan_mode = HDMI_SCAN_MODE_UNDERSCAN;\r\nreturn 0;\r\n}\r\nstatic enum hdmi_3d_structure\r\ns3d_structure_from_display_mode(const struct drm_display_mode *mode)\r\n{\r\nu32 layout = mode->flags & DRM_MODE_FLAG_3D_MASK;\r\nswitch (layout) {\r\ncase DRM_MODE_FLAG_3D_FRAME_PACKING:\r\nreturn HDMI_3D_STRUCTURE_FRAME_PACKING;\r\ncase DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE:\r\nreturn HDMI_3D_STRUCTURE_FIELD_ALTERNATIVE;\r\ncase DRM_MODE_FLAG_3D_LINE_ALTERNATIVE:\r\nreturn HDMI_3D_STRUCTURE_LINE_ALTERNATIVE;\r\ncase DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL:\r\nreturn HDMI_3D_STRUCTURE_SIDE_BY_SIDE_FULL;\r\ncase DRM_MODE_FLAG_3D_L_DEPTH:\r\nreturn HDMI_3D_STRUCTURE_L_DEPTH;\r\ncase DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH:\r\nreturn HDMI_3D_STRUCTURE_L_DEPTH_GFX_GFX_DEPTH;\r\ncase DRM_MODE_FLAG_3D_TOP_AND_BOTTOM:\r\nreturn HDMI_3D_STRUCTURE_TOP_AND_BOTTOM;\r\ncase DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF:\r\nreturn HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF;\r\ndefault:\r\nreturn HDMI_3D_STRUCTURE_INVALID;\r\n}\r\n}\r\nint\r\ndrm_hdmi_vendor_infoframe_from_display_mode(struct hdmi_vendor_infoframe *frame,\r\nconst struct drm_display_mode *mode)\r\n{\r\nint err;\r\nu32 s3d_flags;\r\nu8 vic;\r\nif (!frame || !mode)\r\nreturn -EINVAL;\r\nvic = drm_match_hdmi_mode(mode);\r\ns3d_flags = mode->flags & DRM_MODE_FLAG_3D_MASK;\r\nif (!vic && !s3d_flags)\r\nreturn -EINVAL;\r\nif (vic && s3d_flags)\r\nreturn -EINVAL;\r\nerr = hdmi_vendor_infoframe_init(frame);\r\nif (err < 0)\r\nreturn err;\r\nif (vic)\r\nframe->vic = vic;\r\nelse\r\nframe->s3d_struct = s3d_structure_from_display_mode(mode);\r\nreturn 0;\r\n}\r\nstatic int drm_parse_display_id(struct drm_connector *connector,\r\nu8 *displayid, int length,\r\nbool is_edid_extension)\r\n{\r\nint idx = 0;\r\nstruct displayid_hdr *base;\r\nstruct displayid_block *block;\r\nu8 csum = 0;\r\nint i;\r\nif (is_edid_extension)\r\nidx = 1;\r\nbase = (struct displayid_hdr *)&displayid[idx];\r\nDRM_DEBUG_KMS("base revision 0x%x, length %d, %d %d\n",\r\nbase->rev, base->bytes, base->prod_id, base->ext_count);\r\nif (base->bytes + 5 > length - idx)\r\nreturn -EINVAL;\r\nfor (i = idx; i <= base->bytes + 5; i++) {\r\ncsum += displayid[i];\r\n}\r\nif (csum) {\r\nDRM_ERROR("DisplayID checksum invalid, remainder is %d\n", csum);\r\nreturn -EINVAL;\r\n}\r\nblock = (struct displayid_block *)&displayid[idx + 4];\r\nDRM_DEBUG_KMS("block id %d, rev %d, len %d\n",\r\nblock->tag, block->rev, block->num_bytes);\r\nswitch (block->tag) {\r\ncase DATA_BLOCK_TILED_DISPLAY: {\r\nstruct displayid_tiled_block *tile = (struct displayid_tiled_block *)block;\r\nu16 w, h;\r\nu8 tile_v_loc, tile_h_loc;\r\nu8 num_v_tile, num_h_tile;\r\nstruct drm_tile_group *tg;\r\nw = tile->tile_size[0] | tile->tile_size[1] << 8;\r\nh = tile->tile_size[2] | tile->tile_size[3] << 8;\r\nnum_v_tile = (tile->topo[0] & 0xf) | (tile->topo[2] & 0x30);\r\nnum_h_tile = (tile->topo[0] >> 4) | ((tile->topo[2] >> 2) & 0x30);\r\ntile_v_loc = (tile->topo[1] & 0xf) | ((tile->topo[2] & 0x3) << 4);\r\ntile_h_loc = (tile->topo[1] >> 4) | (((tile->topo[2] >> 2) & 0x3) << 4);\r\nconnector->has_tile = true;\r\nif (tile->tile_cap & 0x80)\r\nconnector->tile_is_single_monitor = true;\r\nconnector->num_h_tile = num_h_tile + 1;\r\nconnector->num_v_tile = num_v_tile + 1;\r\nconnector->tile_h_loc = tile_h_loc;\r\nconnector->tile_v_loc = tile_v_loc;\r\nconnector->tile_h_size = w + 1;\r\nconnector->tile_v_size = h + 1;\r\nDRM_DEBUG_KMS("tile cap 0x%x\n", tile->tile_cap);\r\nDRM_DEBUG_KMS("tile_size %d x %d\n", w + 1, h + 1);\r\nDRM_DEBUG_KMS("topo num tiles %dx%d, location %dx%d\n",\r\nnum_h_tile + 1, num_v_tile + 1, tile_h_loc, tile_v_loc);\r\nDRM_DEBUG_KMS("vend %c%c%c\n", tile->topology_id[0], tile->topology_id[1], tile->topology_id[2]);\r\ntg = drm_mode_get_tile_group(connector->dev, tile->topology_id);\r\nif (!tg) {\r\ntg = drm_mode_create_tile_group(connector->dev, tile->topology_id);\r\n}\r\nif (!tg)\r\nreturn -ENOMEM;\r\nif (connector->tile_group != tg) {\r\nif (connector->tile_group) {\r\ndrm_mode_put_tile_group(connector->dev, connector->tile_group);\r\n}\r\nconnector->tile_group = tg;\r\n} else\r\ndrm_mode_put_tile_group(connector->dev, tg);\r\n}\r\nbreak;\r\ndefault:\r\nprintk("unknown displayid tag %d\n", block->tag);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void drm_get_displayid(struct drm_connector *connector,\r\nstruct edid *edid)\r\n{\r\nvoid *displayid = NULL;\r\nint ret;\r\nconnector->has_tile = false;\r\ndisplayid = drm_find_displayid_extension(edid);\r\nif (!displayid) {\r\ngoto out_drop_ref;\r\n}\r\nret = drm_parse_display_id(connector, displayid, EDID_LENGTH, true);\r\nif (ret < 0)\r\ngoto out_drop_ref;\r\nif (!connector->has_tile)\r\ngoto out_drop_ref;\r\nreturn;\r\nout_drop_ref:\r\nif (connector->tile_group) {\r\ndrm_mode_put_tile_group(connector->dev, connector->tile_group);\r\nconnector->tile_group = NULL;\r\n}\r\nreturn;\r\n}
