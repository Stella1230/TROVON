static u8 sc16is7xx_port_read(struct uart_port *port, u8 reg)\r\n{\r\nstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\r\nunsigned int val = 0;\r\nregmap_read(s->regmap,\r\n(reg << SC16IS7XX_REG_SHIFT) | port->line, &val);\r\nreturn val;\r\n}\r\nstatic void sc16is7xx_port_write(struct uart_port *port, u8 reg, u8 val)\r\n{\r\nstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\r\nregmap_write(s->regmap,\r\n(reg << SC16IS7XX_REG_SHIFT) | port->line, val);\r\n}\r\nstatic void sc16is7xx_port_update(struct uart_port *port, u8 reg,\r\nu8 mask, u8 val)\r\n{\r\nstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\r\nregmap_update_bits(s->regmap,\r\n(reg << SC16IS7XX_REG_SHIFT) | port->line,\r\nmask, val);\r\n}\r\nstatic void sc16is7xx_power(struct uart_port *port, int on)\r\n{\r\nsc16is7xx_port_update(port, SC16IS7XX_IER_REG,\r\nSC16IS7XX_IER_SLEEP_BIT,\r\non ? 0 : SC16IS7XX_IER_SLEEP_BIT);\r\n}\r\nstatic bool sc16is7xx_regmap_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg >> SC16IS7XX_REG_SHIFT) {\r\ncase SC16IS7XX_RHR_REG:\r\ncase SC16IS7XX_IIR_REG:\r\ncase SC16IS7XX_LSR_REG:\r\ncase SC16IS7XX_MSR_REG:\r\ncase SC16IS7XX_TXLVL_REG:\r\ncase SC16IS7XX_RXLVL_REG:\r\ncase SC16IS7XX_IOSTATE_REG:\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nstatic bool sc16is7xx_regmap_precious(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg >> SC16IS7XX_REG_SHIFT) {\r\ncase SC16IS7XX_RHR_REG:\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nstatic int sc16is7xx_set_baud(struct uart_port *port, int baud)\r\n{\r\nstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\r\nu8 lcr;\r\nu8 prescaler = 0;\r\nunsigned long clk = port->uartclk, div = clk / 16 / baud;\r\nif (div > 0xffff) {\r\nprescaler = SC16IS7XX_MCR_CLKSEL_BIT;\r\ndiv /= 4;\r\n}\r\nlcr = sc16is7xx_port_read(port, SC16IS7XX_LCR_REG);\r\nsc16is7xx_port_write(port, SC16IS7XX_LCR_REG,\r\nSC16IS7XX_LCR_CONF_MODE_B);\r\nregcache_cache_bypass(s->regmap, true);\r\nsc16is7xx_port_write(port, SC16IS7XX_EFR_REG,\r\nSC16IS7XX_EFR_ENABLE_BIT);\r\nregcache_cache_bypass(s->regmap, false);\r\nsc16is7xx_port_write(port, SC16IS7XX_LCR_REG, lcr);\r\nsc16is7xx_port_update(port, SC16IS7XX_MCR_REG,\r\nSC16IS7XX_MCR_CLKSEL_BIT,\r\nprescaler);\r\nsc16is7xx_port_write(port, SC16IS7XX_LCR_REG,\r\nSC16IS7XX_LCR_CONF_MODE_A);\r\nregcache_cache_bypass(s->regmap, true);\r\nsc16is7xx_port_write(port, SC16IS7XX_DLH_REG, div / 256);\r\nsc16is7xx_port_write(port, SC16IS7XX_DLL_REG, div % 256);\r\nregcache_cache_bypass(s->regmap, false);\r\nsc16is7xx_port_write(port, SC16IS7XX_LCR_REG, lcr);\r\nreturn DIV_ROUND_CLOSEST(clk / 16, div);\r\n}\r\nstatic void sc16is7xx_handle_rx(struct uart_port *port, unsigned int rxlen,\r\nunsigned int iir)\r\n{\r\nstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\r\nunsigned int lsr = 0, ch, flag, bytes_read, i;\r\nbool read_lsr = (iir == SC16IS7XX_IIR_RLSE_SRC) ? true : false;\r\nif (unlikely(rxlen >= sizeof(s->buf))) {\r\ndev_warn_ratelimited(port->dev,\r\n"Port %i: Possible RX FIFO overrun: %d\n",\r\nport->line, rxlen);\r\nport->icount.buf_overrun++;\r\nrxlen = sizeof(s->buf);\r\n}\r\nwhile (rxlen) {\r\nif (read_lsr) {\r\nlsr = sc16is7xx_port_read(port, SC16IS7XX_LSR_REG);\r\nif (!(lsr & SC16IS7XX_LSR_FIFOE_BIT))\r\nread_lsr = false;\r\n} else\r\nlsr = 0;\r\nif (read_lsr) {\r\ns->buf[0] = sc16is7xx_port_read(port, SC16IS7XX_RHR_REG);\r\nbytes_read = 1;\r\n} else {\r\nregcache_cache_bypass(s->regmap, true);\r\nregmap_raw_read(s->regmap, SC16IS7XX_RHR_REG,\r\ns->buf, rxlen);\r\nregcache_cache_bypass(s->regmap, false);\r\nbytes_read = rxlen;\r\n}\r\nlsr &= SC16IS7XX_LSR_BRK_ERROR_MASK;\r\nport->icount.rx++;\r\nflag = TTY_NORMAL;\r\nif (unlikely(lsr)) {\r\nif (lsr & SC16IS7XX_LSR_BI_BIT) {\r\nport->icount.brk++;\r\nif (uart_handle_break(port))\r\ncontinue;\r\n} else if (lsr & SC16IS7XX_LSR_PE_BIT)\r\nport->icount.parity++;\r\nelse if (lsr & SC16IS7XX_LSR_FE_BIT)\r\nport->icount.frame++;\r\nelse if (lsr & SC16IS7XX_LSR_OE_BIT)\r\nport->icount.overrun++;\r\nlsr &= port->read_status_mask;\r\nif (lsr & SC16IS7XX_LSR_BI_BIT)\r\nflag = TTY_BREAK;\r\nelse if (lsr & SC16IS7XX_LSR_PE_BIT)\r\nflag = TTY_PARITY;\r\nelse if (lsr & SC16IS7XX_LSR_FE_BIT)\r\nflag = TTY_FRAME;\r\nelse if (lsr & SC16IS7XX_LSR_OE_BIT)\r\nflag = TTY_OVERRUN;\r\n}\r\nfor (i = 0; i < bytes_read; ++i) {\r\nch = s->buf[i];\r\nif (uart_handle_sysrq_char(port, ch))\r\ncontinue;\r\nif (lsr & port->ignore_status_mask)\r\ncontinue;\r\nuart_insert_char(port, lsr, SC16IS7XX_LSR_OE_BIT, ch,\r\nflag);\r\n}\r\nrxlen -= bytes_read;\r\n}\r\ntty_flip_buffer_push(&port->state->port);\r\n}\r\nstatic void sc16is7xx_handle_tx(struct uart_port *port)\r\n{\r\nstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\r\nstruct circ_buf *xmit = &port->state->xmit;\r\nunsigned int txlen, to_send, i;\r\nif (unlikely(port->x_char)) {\r\nsc16is7xx_port_write(port, SC16IS7XX_THR_REG, port->x_char);\r\nport->icount.tx++;\r\nport->x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port))\r\nreturn;\r\nto_send = uart_circ_chars_pending(xmit);\r\nif (likely(to_send)) {\r\ntxlen = sc16is7xx_port_read(port, SC16IS7XX_TXLVL_REG);\r\nto_send = (to_send > txlen) ? txlen : to_send;\r\nport->icount.tx += to_send;\r\nfor (i = 0; i < to_send; ++i) {\r\ns->buf[i] = xmit->buf[xmit->tail];\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\n}\r\nregcache_cache_bypass(s->regmap, true);\r\nregmap_raw_write(s->regmap, SC16IS7XX_THR_REG, s->buf, to_send);\r\nregcache_cache_bypass(s->regmap, false);\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\nstatic void sc16is7xx_port_irq(struct sc16is7xx_port *s, int portno)\r\n{\r\nstruct uart_port *port = &s->p[portno].port;\r\ndo {\r\nunsigned int iir, msr, rxlen;\r\niir = sc16is7xx_port_read(port, SC16IS7XX_IIR_REG);\r\nif (iir & SC16IS7XX_IIR_NO_INT_BIT)\r\nbreak;\r\niir &= SC16IS7XX_IIR_ID_MASK;\r\nswitch (iir) {\r\ncase SC16IS7XX_IIR_RDI_SRC:\r\ncase SC16IS7XX_IIR_RLSE_SRC:\r\ncase SC16IS7XX_IIR_RTOI_SRC:\r\ncase SC16IS7XX_IIR_XOFFI_SRC:\r\nrxlen = sc16is7xx_port_read(port, SC16IS7XX_RXLVL_REG);\r\nif (rxlen)\r\nsc16is7xx_handle_rx(port, rxlen, iir);\r\nbreak;\r\ncase SC16IS7XX_IIR_CTSRTS_SRC:\r\nmsr = sc16is7xx_port_read(port, SC16IS7XX_MSR_REG);\r\nuart_handle_cts_change(port,\r\n!!(msr & SC16IS7XX_MSR_CTS_BIT));\r\nbreak;\r\ncase SC16IS7XX_IIR_THRI_SRC:\r\nmutex_lock(&s->mutex);\r\nsc16is7xx_handle_tx(port);\r\nmutex_unlock(&s->mutex);\r\nbreak;\r\ndefault:\r\ndev_err_ratelimited(port->dev,\r\n"Port %i: Unexpected interrupt: %x",\r\nport->line, iir);\r\nbreak;\r\n}\r\n} while (1);\r\n}\r\nstatic irqreturn_t sc16is7xx_ist(int irq, void *dev_id)\r\n{\r\nstruct sc16is7xx_port *s = (struct sc16is7xx_port *)dev_id;\r\nint i;\r\nfor (i = 0; i < s->uart.nr; ++i)\r\nsc16is7xx_port_irq(s, i);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sc16is7xx_wq_proc(struct work_struct *ws)\r\n{\r\nstruct sc16is7xx_one *one = to_sc16is7xx_one(ws, tx_work);\r\nstruct sc16is7xx_port *s = dev_get_drvdata(one->port.dev);\r\nmutex_lock(&s->mutex);\r\nsc16is7xx_handle_tx(&one->port);\r\nmutex_unlock(&s->mutex);\r\n}\r\nstatic void sc16is7xx_stop_tx(struct uart_port* port)\r\n{\r\nstruct sc16is7xx_one *one = to_sc16is7xx_one(port, port);\r\nstruct circ_buf *xmit = &one->port.state->xmit;\r\nif (port->rs485.flags & SER_RS485_ENABLED) {\r\nint lsr = sc16is7xx_port_read(port, SC16IS7XX_LSR_REG);\r\nif (!(lsr & SC16IS7XX_LSR_TEMT_BIT))\r\nreturn;\r\nif (uart_circ_empty(xmit) &&\r\n(port->rs485.delay_rts_after_send > 0))\r\nmdelay(port->rs485.delay_rts_after_send);\r\n}\r\nsc16is7xx_port_update(port, SC16IS7XX_IER_REG,\r\nSC16IS7XX_IER_THRI_BIT,\r\n0);\r\n}\r\nstatic void sc16is7xx_stop_rx(struct uart_port* port)\r\n{\r\nstruct sc16is7xx_one *one = to_sc16is7xx_one(port, port);\r\none->port.read_status_mask &= ~SC16IS7XX_LSR_DR_BIT;\r\nsc16is7xx_port_update(port, SC16IS7XX_IER_REG,\r\nSC16IS7XX_LSR_DR_BIT,\r\n0);\r\n}\r\nstatic void sc16is7xx_start_tx(struct uart_port *port)\r\n{\r\nstruct sc16is7xx_one *one = to_sc16is7xx_one(port, port);\r\nif ((port->rs485.flags & SER_RS485_ENABLED) &&\r\n(port->rs485.delay_rts_before_send > 0)) {\r\nmdelay(port->rs485.delay_rts_before_send);\r\n}\r\nif (!work_pending(&one->tx_work))\r\nschedule_work(&one->tx_work);\r\n}\r\nstatic unsigned int sc16is7xx_tx_empty(struct uart_port *port)\r\n{\r\nunsigned int lvl, lsr;\r\nlvl = sc16is7xx_port_read(port, SC16IS7XX_TXLVL_REG);\r\nlsr = sc16is7xx_port_read(port, SC16IS7XX_LSR_REG);\r\nreturn ((lsr & SC16IS7XX_LSR_THRE_BIT) && !lvl) ? TIOCSER_TEMT : 0;\r\n}\r\nstatic unsigned int sc16is7xx_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_DSR | TIOCM_CAR;\r\n}\r\nstatic void sc16is7xx_md_proc(struct work_struct *ws)\r\n{\r\nstruct sc16is7xx_one *one = to_sc16is7xx_one(ws, md_work);\r\nsc16is7xx_port_update(&one->port, SC16IS7XX_MCR_REG,\r\nSC16IS7XX_MCR_LOOP_BIT,\r\n(one->port.mctrl & TIOCM_LOOP) ?\r\nSC16IS7XX_MCR_LOOP_BIT : 0);\r\n}\r\nstatic void sc16is7xx_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct sc16is7xx_one *one = to_sc16is7xx_one(port, port);\r\nschedule_work(&one->md_work);\r\n}\r\nstatic void sc16is7xx_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nsc16is7xx_port_update(port, SC16IS7XX_LCR_REG,\r\nSC16IS7XX_LCR_TXBREAK_BIT,\r\nbreak_state ? SC16IS7XX_LCR_TXBREAK_BIT : 0);\r\n}\r\nstatic void sc16is7xx_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\r\nunsigned int lcr, flow = 0;\r\nint baud;\r\ntermios->c_cflag &= ~CMSPAR;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nlcr = SC16IS7XX_LCR_WORD_LEN_5;\r\nbreak;\r\ncase CS6:\r\nlcr = SC16IS7XX_LCR_WORD_LEN_6;\r\nbreak;\r\ncase CS7:\r\nlcr = SC16IS7XX_LCR_WORD_LEN_7;\r\nbreak;\r\ncase CS8:\r\nlcr = SC16IS7XX_LCR_WORD_LEN_8;\r\nbreak;\r\ndefault:\r\nlcr = SC16IS7XX_LCR_WORD_LEN_8;\r\ntermios->c_cflag &= ~CSIZE;\r\ntermios->c_cflag |= CS8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & PARENB) {\r\nlcr |= SC16IS7XX_LCR_PARITY_BIT;\r\nif (!(termios->c_cflag & PARODD))\r\nlcr |= SC16IS7XX_LCR_EVENPARITY_BIT;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\nlcr |= SC16IS7XX_LCR_STOPLEN_BIT;\r\nport->read_status_mask = SC16IS7XX_LSR_OE_BIT;\r\nif (termios->c_iflag & INPCK)\r\nport->read_status_mask |= SC16IS7XX_LSR_PE_BIT |\r\nSC16IS7XX_LSR_FE_BIT;\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\nport->read_status_mask |= SC16IS7XX_LSR_BI_BIT;\r\nport->ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNBRK)\r\nport->ignore_status_mask |= SC16IS7XX_LSR_BI_BIT;\r\nif (!(termios->c_cflag & CREAD))\r\nport->ignore_status_mask |= SC16IS7XX_LSR_BRK_ERROR_MASK;\r\nsc16is7xx_port_write(port, SC16IS7XX_LCR_REG,\r\nSC16IS7XX_LCR_CONF_MODE_B);\r\nregcache_cache_bypass(s->regmap, true);\r\nsc16is7xx_port_write(port, SC16IS7XX_XON1_REG, termios->c_cc[VSTART]);\r\nsc16is7xx_port_write(port, SC16IS7XX_XOFF1_REG, termios->c_cc[VSTOP]);\r\nif (termios->c_cflag & CRTSCTS)\r\nflow |= SC16IS7XX_EFR_AUTOCTS_BIT |\r\nSC16IS7XX_EFR_AUTORTS_BIT;\r\nif (termios->c_iflag & IXON)\r\nflow |= SC16IS7XX_EFR_SWFLOW3_BIT;\r\nif (termios->c_iflag & IXOFF)\r\nflow |= SC16IS7XX_EFR_SWFLOW1_BIT;\r\nsc16is7xx_port_write(port, SC16IS7XX_EFR_REG, flow);\r\nregcache_cache_bypass(s->regmap, false);\r\nsc16is7xx_port_write(port, SC16IS7XX_LCR_REG, lcr);\r\nbaud = uart_get_baud_rate(port, termios, old,\r\nport->uartclk / 16 / 4 / 0xffff,\r\nport->uartclk / 16);\r\nbaud = sc16is7xx_set_baud(port, baud);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\n}\r\nstatic int sc16is7xx_config_rs485(struct uart_port *port,\r\nstruct serial_rs485 *rs485)\r\n{\r\nif (port->rs485.flags & SER_RS485_ENABLED)\r\nsc16is7xx_port_update(port, SC16IS7XX_EFCR_REG,\r\nSC16IS7XX_EFCR_AUTO_RS485_BIT,\r\nSC16IS7XX_EFCR_AUTO_RS485_BIT);\r\nelse\r\nsc16is7xx_port_update(port, SC16IS7XX_EFCR_REG,\r\nSC16IS7XX_EFCR_AUTO_RS485_BIT,\r\n0);\r\nport->rs485 = *rs485;\r\nreturn 0;\r\n}\r\nstatic int sc16is7xx_startup(struct uart_port *port)\r\n{\r\nstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\r\nunsigned int val;\r\nsc16is7xx_power(port, 1);\r\nval = SC16IS7XX_FCR_RXRESET_BIT | SC16IS7XX_FCR_TXRESET_BIT;\r\nsc16is7xx_port_write(port, SC16IS7XX_FCR_REG, val);\r\nudelay(5);\r\nsc16is7xx_port_write(port, SC16IS7XX_FCR_REG,\r\nSC16IS7XX_FCR_FIFO_BIT);\r\nsc16is7xx_port_write(port, SC16IS7XX_LCR_REG,\r\nSC16IS7XX_LCR_CONF_MODE_B);\r\nregcache_cache_bypass(s->regmap, true);\r\nsc16is7xx_port_write(port, SC16IS7XX_EFR_REG,\r\nSC16IS7XX_EFR_ENABLE_BIT);\r\nsc16is7xx_port_update(port, SC16IS7XX_MCR_REG,\r\nSC16IS7XX_MCR_TCRTLR_BIT,\r\nSC16IS7XX_MCR_TCRTLR_BIT);\r\nsc16is7xx_port_write(port, SC16IS7XX_TCR_REG,\r\nSC16IS7XX_TCR_RX_RESUME(24) |\r\nSC16IS7XX_TCR_RX_HALT(48));\r\nregcache_cache_bypass(s->regmap, false);\r\nsc16is7xx_port_write(port, SC16IS7XX_LCR_REG, SC16IS7XX_LCR_WORD_LEN_8);\r\nsc16is7xx_port_update(port, SC16IS7XX_EFCR_REG,\r\nSC16IS7XX_EFCR_RXDISABLE_BIT |\r\nSC16IS7XX_EFCR_TXDISABLE_BIT,\r\n0);\r\nval = SC16IS7XX_IER_RDI_BIT | SC16IS7XX_IER_THRI_BIT |\r\nSC16IS7XX_IER_CTSI_BIT;\r\nsc16is7xx_port_write(port, SC16IS7XX_IER_REG, val);\r\nreturn 0;\r\n}\r\nstatic void sc16is7xx_shutdown(struct uart_port *port)\r\n{\r\nsc16is7xx_port_write(port, SC16IS7XX_IER_REG, 0);\r\nsc16is7xx_port_write(port, SC16IS7XX_EFCR_REG,\r\nSC16IS7XX_EFCR_RXDISABLE_BIT |\r\nSC16IS7XX_EFCR_TXDISABLE_BIT);\r\nsc16is7xx_power(port, 0);\r\n}\r\nstatic const char *sc16is7xx_type(struct uart_port *port)\r\n{\r\nstruct sc16is7xx_port *s = dev_get_drvdata(port->dev);\r\nreturn (port->type == PORT_SC16IS7XX) ? s->devtype->name : NULL;\r\n}\r\nstatic int sc16is7xx_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void sc16is7xx_config_port(struct uart_port *port, int flags)\r\n{\r\nif (flags & UART_CONFIG_TYPE)\r\nport->type = PORT_SC16IS7XX;\r\n}\r\nstatic int sc16is7xx_verify_port(struct uart_port *port,\r\nstruct serial_struct *s)\r\n{\r\nif ((s->type != PORT_UNKNOWN) && (s->type != PORT_SC16IS7XX))\r\nreturn -EINVAL;\r\nif (s->irq != port->irq)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void sc16is7xx_pm(struct uart_port *port, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nsc16is7xx_power(port, (state == UART_PM_STATE_ON) ? 1 : 0);\r\n}\r\nstatic void sc16is7xx_null_void(struct uart_port *port)\r\n{\r\n}\r\nstatic int sc16is7xx_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nunsigned int val;\r\nstruct sc16is7xx_port *s = container_of(chip, struct sc16is7xx_port,\r\ngpio);\r\nstruct uart_port *port = &s->p[0].port;\r\nval = sc16is7xx_port_read(port, SC16IS7XX_IOSTATE_REG);\r\nreturn !!(val & BIT(offset));\r\n}\r\nstatic void sc16is7xx_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\r\n{\r\nstruct sc16is7xx_port *s = container_of(chip, struct sc16is7xx_port,\r\ngpio);\r\nstruct uart_port *port = &s->p[0].port;\r\nsc16is7xx_port_update(port, SC16IS7XX_IOSTATE_REG, BIT(offset),\r\nval ? BIT(offset) : 0);\r\n}\r\nstatic int sc16is7xx_gpio_direction_input(struct gpio_chip *chip,\r\nunsigned offset)\r\n{\r\nstruct sc16is7xx_port *s = container_of(chip, struct sc16is7xx_port,\r\ngpio);\r\nstruct uart_port *port = &s->p[0].port;\r\nsc16is7xx_port_update(port, SC16IS7XX_IODIR_REG, BIT(offset), 0);\r\nreturn 0;\r\n}\r\nstatic int sc16is7xx_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int val)\r\n{\r\nstruct sc16is7xx_port *s = container_of(chip, struct sc16is7xx_port,\r\ngpio);\r\nstruct uart_port *port = &s->p[0].port;\r\nsc16is7xx_port_update(port, SC16IS7XX_IOSTATE_REG, BIT(offset),\r\nval ? BIT(offset) : 0);\r\nsc16is7xx_port_update(port, SC16IS7XX_IODIR_REG, BIT(offset),\r\nBIT(offset));\r\nreturn 0;\r\n}\r\nstatic int sc16is7xx_probe(struct device *dev,\r\nstruct sc16is7xx_devtype *devtype,\r\nstruct regmap *regmap, int irq, unsigned long flags)\r\n{\r\nunsigned long freq, *pfreq = dev_get_platdata(dev);\r\nint i, ret;\r\nstruct sc16is7xx_port *s;\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\ns = devm_kzalloc(dev, sizeof(*s) +\r\nsizeof(struct sc16is7xx_one) * devtype->nr_uart,\r\nGFP_KERNEL);\r\nif (!s) {\r\ndev_err(dev, "Error allocating port structure\n");\r\nreturn -ENOMEM;\r\n}\r\ns->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(s->clk)) {\r\nif (pfreq)\r\nfreq = *pfreq;\r\nelse\r\nreturn PTR_ERR(s->clk);\r\n} else {\r\nfreq = clk_get_rate(s->clk);\r\n}\r\ns->regmap = regmap;\r\ns->devtype = devtype;\r\ndev_set_drvdata(dev, s);\r\ns->uart.owner = THIS_MODULE;\r\ns->uart.dev_name = "ttySC";\r\ns->uart.nr = devtype->nr_uart;\r\nret = uart_register_driver(&s->uart);\r\nif (ret) {\r\ndev_err(dev, "Registering UART driver failed\n");\r\ngoto out_clk;\r\n}\r\n#ifdef CONFIG_GPIOLIB\r\nif (devtype->nr_gpio) {\r\ns->gpio.owner = THIS_MODULE;\r\ns->gpio.dev = dev;\r\ns->gpio.label = dev_name(dev);\r\ns->gpio.direction_input = sc16is7xx_gpio_direction_input;\r\ns->gpio.get = sc16is7xx_gpio_get;\r\ns->gpio.direction_output = sc16is7xx_gpio_direction_output;\r\ns->gpio.set = sc16is7xx_gpio_set;\r\ns->gpio.base = -1;\r\ns->gpio.ngpio = devtype->nr_gpio;\r\ns->gpio.can_sleep = 1;\r\nret = gpiochip_add(&s->gpio);\r\nif (ret)\r\ngoto out_uart;\r\n}\r\n#endif\r\nmutex_init(&s->mutex);\r\nfor (i = 0; i < devtype->nr_uart; ++i) {\r\ns->p[i].port.line = i;\r\ns->p[i].port.dev = dev;\r\ns->p[i].port.irq = irq;\r\ns->p[i].port.type = PORT_SC16IS7XX;\r\ns->p[i].port.fifosize = SC16IS7XX_FIFO_SIZE;\r\ns->p[i].port.flags = UPF_FIXED_TYPE | UPF_LOW_LATENCY;\r\ns->p[i].port.iotype = UPIO_PORT;\r\ns->p[i].port.uartclk = freq;\r\ns->p[i].port.rs485_config = sc16is7xx_config_rs485;\r\ns->p[i].port.ops = &sc16is7xx_ops;\r\nsc16is7xx_port_write(&s->p[i].port, SC16IS7XX_IER_REG, 0);\r\nsc16is7xx_port_write(&s->p[i].port, SC16IS7XX_EFCR_REG,\r\nSC16IS7XX_EFCR_RXDISABLE_BIT |\r\nSC16IS7XX_EFCR_TXDISABLE_BIT);\r\nINIT_WORK(&s->p[i].tx_work, sc16is7xx_wq_proc);\r\nINIT_WORK(&s->p[i].md_work, sc16is7xx_md_proc);\r\nuart_add_one_port(&s->uart, &s->p[i].port);\r\nsc16is7xx_power(&s->p[i].port, 0);\r\n}\r\nret = devm_request_threaded_irq(dev, irq, NULL, sc16is7xx_ist,\r\nIRQF_ONESHOT | flags, dev_name(dev), s);\r\nif (!ret)\r\nreturn 0;\r\nmutex_destroy(&s->mutex);\r\n#ifdef CONFIG_GPIOLIB\r\nif (devtype->nr_gpio)\r\ngpiochip_remove(&s->gpio);\r\nout_uart:\r\n#endif\r\nuart_unregister_driver(&s->uart);\r\nout_clk:\r\nif (!IS_ERR(s->clk))\r\nclk_disable_unprepare(s->clk);\r\nreturn ret;\r\n}\r\nstatic int sc16is7xx_remove(struct device *dev)\r\n{\r\nstruct sc16is7xx_port *s = dev_get_drvdata(dev);\r\nint i;\r\n#ifdef CONFIG_GPIOLIB\r\nif (s->devtype->nr_gpio)\r\ngpiochip_remove(&s->gpio);\r\n#endif\r\nfor (i = 0; i < s->uart.nr; i++) {\r\ncancel_work_sync(&s->p[i].tx_work);\r\ncancel_work_sync(&s->p[i].md_work);\r\nuart_remove_one_port(&s->uart, &s->p[i].port);\r\nsc16is7xx_power(&s->p[i].port, 0);\r\n}\r\nmutex_destroy(&s->mutex);\r\nuart_unregister_driver(&s->uart);\r\nif (!IS_ERR(s->clk))\r\nclk_disable_unprepare(s->clk);\r\nreturn 0;\r\n}\r\nstatic int sc16is7xx_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct sc16is7xx_devtype *devtype;\r\nunsigned long flags = 0;\r\nstruct regmap *regmap;\r\nif (i2c->dev.of_node) {\r\nconst struct of_device_id *of_id =\r\nof_match_device(sc16is7xx_dt_ids, &i2c->dev);\r\ndevtype = (struct sc16is7xx_devtype *)of_id->data;\r\n} else {\r\ndevtype = (struct sc16is7xx_devtype *)id->driver_data;\r\nflags = IRQF_TRIGGER_FALLING;\r\n}\r\nregcfg.max_register = (0xf << SC16IS7XX_REG_SHIFT) |\r\n(devtype->nr_uart - 1);\r\nregmap = devm_regmap_init_i2c(i2c, &regcfg);\r\nreturn sc16is7xx_probe(&i2c->dev, devtype, regmap, i2c->irq, flags);\r\n}\r\nstatic int sc16is7xx_i2c_remove(struct i2c_client *client)\r\n{\r\nreturn sc16is7xx_remove(&client->dev);\r\n}
