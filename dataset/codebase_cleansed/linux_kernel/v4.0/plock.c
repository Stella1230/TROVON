static inline void set_version(struct dlm_plock_info *info)\r\n{\r\ninfo->version[0] = DLM_PLOCK_VERSION_MAJOR;\r\ninfo->version[1] = DLM_PLOCK_VERSION_MINOR;\r\ninfo->version[2] = DLM_PLOCK_VERSION_PATCH;\r\n}\r\nstatic int check_version(struct dlm_plock_info *info)\r\n{\r\nif ((DLM_PLOCK_VERSION_MAJOR != info->version[0]) ||\r\n(DLM_PLOCK_VERSION_MINOR < info->version[1])) {\r\nlog_print("plock device version mismatch: "\r\n"kernel (%u.%u.%u), user (%u.%u.%u)",\r\nDLM_PLOCK_VERSION_MAJOR,\r\nDLM_PLOCK_VERSION_MINOR,\r\nDLM_PLOCK_VERSION_PATCH,\r\ninfo->version[0],\r\ninfo->version[1],\r\ninfo->version[2]);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void send_op(struct plock_op *op)\r\n{\r\nset_version(&op->info);\r\nINIT_LIST_HEAD(&op->list);\r\nspin_lock(&ops_lock);\r\nlist_add_tail(&op->list, &send_list);\r\nspin_unlock(&ops_lock);\r\nwake_up(&send_wq);\r\n}\r\nstatic void do_unlock_close(struct dlm_ls *ls, u64 number,\r\nstruct file *file, struct file_lock *fl)\r\n{\r\nstruct plock_op *op;\r\nop = kzalloc(sizeof(*op), GFP_NOFS);\r\nif (!op)\r\nreturn;\r\nop->info.optype = DLM_PLOCK_OP_UNLOCK;\r\nop->info.pid = fl->fl_pid;\r\nop->info.fsid = ls->ls_global_id;\r\nop->info.number = number;\r\nop->info.start = 0;\r\nop->info.end = OFFSET_MAX;\r\nif (fl->fl_lmops && fl->fl_lmops->lm_grant)\r\nop->info.owner = (__u64) fl->fl_pid;\r\nelse\r\nop->info.owner = (__u64)(long) fl->fl_owner;\r\nop->info.flags |= DLM_PLOCK_FL_CLOSE;\r\nsend_op(op);\r\n}\r\nint dlm_posix_lock(dlm_lockspace_t *lockspace, u64 number, struct file *file,\r\nint cmd, struct file_lock *fl)\r\n{\r\nstruct dlm_ls *ls;\r\nstruct plock_op *op;\r\nstruct plock_xop *xop;\r\nint rv;\r\nls = dlm_find_lockspace_local(lockspace);\r\nif (!ls)\r\nreturn -EINVAL;\r\nxop = kzalloc(sizeof(*xop), GFP_NOFS);\r\nif (!xop) {\r\nrv = -ENOMEM;\r\ngoto out;\r\n}\r\nop = &xop->xop;\r\nop->info.optype = DLM_PLOCK_OP_LOCK;\r\nop->info.pid = fl->fl_pid;\r\nop->info.ex = (fl->fl_type == F_WRLCK);\r\nop->info.wait = IS_SETLKW(cmd);\r\nop->info.fsid = ls->ls_global_id;\r\nop->info.number = number;\r\nop->info.start = fl->fl_start;\r\nop->info.end = fl->fl_end;\r\nif (fl->fl_lmops && fl->fl_lmops->lm_grant) {\r\nop->info.owner = (__u64) fl->fl_pid;\r\nxop->callback = fl->fl_lmops->lm_grant;\r\nlocks_init_lock(&xop->flc);\r\nlocks_copy_lock(&xop->flc, fl);\r\nxop->fl = fl;\r\nxop->file = file;\r\n} else {\r\nop->info.owner = (__u64)(long) fl->fl_owner;\r\nxop->callback = NULL;\r\n}\r\nsend_op(op);\r\nif (xop->callback == NULL) {\r\nrv = wait_event_killable(recv_wq, (op->done != 0));\r\nif (rv == -ERESTARTSYS) {\r\nlog_debug(ls, "dlm_posix_lock: wait killed %llx",\r\n(unsigned long long)number);\r\nspin_lock(&ops_lock);\r\nlist_del(&op->list);\r\nspin_unlock(&ops_lock);\r\nkfree(xop);\r\ndo_unlock_close(ls, number, file, fl);\r\ngoto out;\r\n}\r\n} else {\r\nrv = FILE_LOCK_DEFERRED;\r\ngoto out;\r\n}\r\nspin_lock(&ops_lock);\r\nif (!list_empty(&op->list)) {\r\nlog_error(ls, "dlm_posix_lock: op on list %llx",\r\n(unsigned long long)number);\r\nlist_del(&op->list);\r\n}\r\nspin_unlock(&ops_lock);\r\nrv = op->info.rv;\r\nif (!rv) {\r\nif (posix_lock_file_wait(file, fl) < 0)\r\nlog_error(ls, "dlm_posix_lock: vfs lock error %llx",\r\n(unsigned long long)number);\r\n}\r\nkfree(xop);\r\nout:\r\ndlm_put_lockspace(ls);\r\nreturn rv;\r\n}\r\nstatic int dlm_plock_callback(struct plock_op *op)\r\n{\r\nstruct file *file;\r\nstruct file_lock *fl;\r\nstruct file_lock *flc;\r\nint (*notify)(struct file_lock *fl, int result) = NULL;\r\nstruct plock_xop *xop = (struct plock_xop *)op;\r\nint rv = 0;\r\nspin_lock(&ops_lock);\r\nif (!list_empty(&op->list)) {\r\nlog_print("dlm_plock_callback: op on list %llx",\r\n(unsigned long long)op->info.number);\r\nlist_del(&op->list);\r\n}\r\nspin_unlock(&ops_lock);\r\nfile = xop->file;\r\nflc = &xop->flc;\r\nfl = xop->fl;\r\nnotify = xop->callback;\r\nif (op->info.rv) {\r\nnotify(fl, op->info.rv);\r\ngoto out;\r\n}\r\nflc->fl_flags &= ~FL_SLEEP;\r\nif (posix_lock_file(file, flc, NULL)) {\r\nlog_print("dlm_plock_callback: vfs lock error %llx file %p fl %p",\r\n(unsigned long long)op->info.number, file, fl);\r\n}\r\nrv = notify(fl, 0);\r\nif (rv) {\r\nlog_print("dlm_plock_callback: lock granted after lock request "\r\n"failed; dangling lock!\n");\r\ngoto out;\r\n}\r\nout:\r\nkfree(xop);\r\nreturn rv;\r\n}\r\nint dlm_posix_unlock(dlm_lockspace_t *lockspace, u64 number, struct file *file,\r\nstruct file_lock *fl)\r\n{\r\nstruct dlm_ls *ls;\r\nstruct plock_op *op;\r\nint rv;\r\nunsigned char fl_flags = fl->fl_flags;\r\nls = dlm_find_lockspace_local(lockspace);\r\nif (!ls)\r\nreturn -EINVAL;\r\nop = kzalloc(sizeof(*op), GFP_NOFS);\r\nif (!op) {\r\nrv = -ENOMEM;\r\ngoto out;\r\n}\r\nfl->fl_flags |= FL_EXISTS;\r\nrv = posix_lock_file_wait(file, fl);\r\nif (rv == -ENOENT) {\r\nrv = 0;\r\ngoto out_free;\r\n}\r\nif (rv < 0) {\r\nlog_error(ls, "dlm_posix_unlock: vfs unlock error %d %llx",\r\nrv, (unsigned long long)number);\r\n}\r\nop->info.optype = DLM_PLOCK_OP_UNLOCK;\r\nop->info.pid = fl->fl_pid;\r\nop->info.fsid = ls->ls_global_id;\r\nop->info.number = number;\r\nop->info.start = fl->fl_start;\r\nop->info.end = fl->fl_end;\r\nif (fl->fl_lmops && fl->fl_lmops->lm_grant)\r\nop->info.owner = (__u64) fl->fl_pid;\r\nelse\r\nop->info.owner = (__u64)(long) fl->fl_owner;\r\nif (fl->fl_flags & FL_CLOSE) {\r\nop->info.flags |= DLM_PLOCK_FL_CLOSE;\r\nsend_op(op);\r\nrv = 0;\r\ngoto out;\r\n}\r\nsend_op(op);\r\nwait_event(recv_wq, (op->done != 0));\r\nspin_lock(&ops_lock);\r\nif (!list_empty(&op->list)) {\r\nlog_error(ls, "dlm_posix_unlock: op on list %llx",\r\n(unsigned long long)number);\r\nlist_del(&op->list);\r\n}\r\nspin_unlock(&ops_lock);\r\nrv = op->info.rv;\r\nif (rv == -ENOENT)\r\nrv = 0;\r\nout_free:\r\nkfree(op);\r\nout:\r\ndlm_put_lockspace(ls);\r\nfl->fl_flags = fl_flags;\r\nreturn rv;\r\n}\r\nint dlm_posix_get(dlm_lockspace_t *lockspace, u64 number, struct file *file,\r\nstruct file_lock *fl)\r\n{\r\nstruct dlm_ls *ls;\r\nstruct plock_op *op;\r\nint rv;\r\nls = dlm_find_lockspace_local(lockspace);\r\nif (!ls)\r\nreturn -EINVAL;\r\nop = kzalloc(sizeof(*op), GFP_NOFS);\r\nif (!op) {\r\nrv = -ENOMEM;\r\ngoto out;\r\n}\r\nop->info.optype = DLM_PLOCK_OP_GET;\r\nop->info.pid = fl->fl_pid;\r\nop->info.ex = (fl->fl_type == F_WRLCK);\r\nop->info.fsid = ls->ls_global_id;\r\nop->info.number = number;\r\nop->info.start = fl->fl_start;\r\nop->info.end = fl->fl_end;\r\nif (fl->fl_lmops && fl->fl_lmops->lm_grant)\r\nop->info.owner = (__u64) fl->fl_pid;\r\nelse\r\nop->info.owner = (__u64)(long) fl->fl_owner;\r\nsend_op(op);\r\nwait_event(recv_wq, (op->done != 0));\r\nspin_lock(&ops_lock);\r\nif (!list_empty(&op->list)) {\r\nlog_error(ls, "dlm_posix_get: op on list %llx",\r\n(unsigned long long)number);\r\nlist_del(&op->list);\r\n}\r\nspin_unlock(&ops_lock);\r\nrv = op->info.rv;\r\nfl->fl_type = F_UNLCK;\r\nif (rv == -ENOENT)\r\nrv = 0;\r\nelse if (rv > 0) {\r\nlocks_init_lock(fl);\r\nfl->fl_type = (op->info.ex) ? F_WRLCK : F_RDLCK;\r\nfl->fl_flags = FL_POSIX;\r\nfl->fl_pid = op->info.pid;\r\nfl->fl_start = op->info.start;\r\nfl->fl_end = op->info.end;\r\nrv = 0;\r\n}\r\nkfree(op);\r\nout:\r\ndlm_put_lockspace(ls);\r\nreturn rv;\r\n}\r\nstatic ssize_t dev_read(struct file *file, char __user *u, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct dlm_plock_info info;\r\nstruct plock_op *op = NULL;\r\nif (count < sizeof(info))\r\nreturn -EINVAL;\r\nspin_lock(&ops_lock);\r\nif (!list_empty(&send_list)) {\r\nop = list_entry(send_list.next, struct plock_op, list);\r\nif (op->info.flags & DLM_PLOCK_FL_CLOSE)\r\nlist_del(&op->list);\r\nelse\r\nlist_move(&op->list, &recv_list);\r\nmemcpy(&info, &op->info, sizeof(info));\r\n}\r\nspin_unlock(&ops_lock);\r\nif (!op)\r\nreturn -EAGAIN;\r\nif (op->info.flags & DLM_PLOCK_FL_CLOSE)\r\nkfree(op);\r\nif (copy_to_user(u, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nreturn sizeof(info);\r\n}\r\nstatic ssize_t dev_write(struct file *file, const char __user *u, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct dlm_plock_info info;\r\nstruct plock_op *op;\r\nint found = 0, do_callback = 0;\r\nif (count != sizeof(info))\r\nreturn -EINVAL;\r\nif (copy_from_user(&info, u, sizeof(info)))\r\nreturn -EFAULT;\r\nif (check_version(&info))\r\nreturn -EINVAL;\r\nspin_lock(&ops_lock);\r\nlist_for_each_entry(op, &recv_list, list) {\r\nif (op->info.fsid == info.fsid &&\r\nop->info.number == info.number &&\r\nop->info.owner == info.owner) {\r\nstruct plock_xop *xop = (struct plock_xop *)op;\r\nlist_del_init(&op->list);\r\nmemcpy(&op->info, &info, sizeof(info));\r\nif (xop->callback)\r\ndo_callback = 1;\r\nelse\r\nop->done = 1;\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&ops_lock);\r\nif (found) {\r\nif (do_callback)\r\ndlm_plock_callback(op);\r\nelse\r\nwake_up(&recv_wq);\r\n} else\r\nlog_print("dev_write no op %x %llx", info.fsid,\r\n(unsigned long long)info.number);\r\nreturn count;\r\n}\r\nstatic unsigned int dev_poll(struct file *file, poll_table *wait)\r\n{\r\nunsigned int mask = 0;\r\npoll_wait(file, &send_wq, wait);\r\nspin_lock(&ops_lock);\r\nif (!list_empty(&send_list))\r\nmask = POLLIN | POLLRDNORM;\r\nspin_unlock(&ops_lock);\r\nreturn mask;\r\n}\r\nint dlm_plock_init(void)\r\n{\r\nint rv;\r\nspin_lock_init(&ops_lock);\r\nINIT_LIST_HEAD(&send_list);\r\nINIT_LIST_HEAD(&recv_list);\r\ninit_waitqueue_head(&send_wq);\r\ninit_waitqueue_head(&recv_wq);\r\nrv = misc_register(&plock_dev_misc);\r\nif (rv)\r\nlog_print("dlm_plock_init: misc_register failed %d", rv);\r\nreturn rv;\r\n}\r\nvoid dlm_plock_exit(void)\r\n{\r\nif (misc_deregister(&plock_dev_misc) < 0)\r\nlog_print("dlm_plock_exit: misc_deregister failed");\r\n}
