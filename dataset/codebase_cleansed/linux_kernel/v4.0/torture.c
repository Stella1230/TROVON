static int\r\ntorture_onoff(void *arg)\r\n{\r\nint cpu;\r\nunsigned long delta;\r\nint maxcpu = -1;\r\nDEFINE_TORTURE_RANDOM(rand);\r\nint ret;\r\nunsigned long starttime;\r\nVERBOSE_TOROUT_STRING("torture_onoff task started");\r\nfor_each_online_cpu(cpu)\r\nmaxcpu = cpu;\r\nWARN_ON(maxcpu < 0);\r\nif (onoff_holdoff > 0) {\r\nVERBOSE_TOROUT_STRING("torture_onoff begin holdoff");\r\nschedule_timeout_interruptible(onoff_holdoff);\r\nVERBOSE_TOROUT_STRING("torture_onoff end holdoff");\r\n}\r\nwhile (!torture_must_stop()) {\r\ncpu = (torture_random(&rand) >> 4) % (maxcpu + 1);\r\nif (cpu_online(cpu) && cpu_is_hotpluggable(cpu)) {\r\nif (verbose)\r\npr_alert("%s" TORTURE_FLAG\r\n"torture_onoff task: offlining %d\n",\r\ntorture_type, cpu);\r\nstarttime = jiffies;\r\nn_offline_attempts++;\r\nret = cpu_down(cpu);\r\nif (ret) {\r\nif (verbose)\r\npr_alert("%s" TORTURE_FLAG\r\n"torture_onoff task: offline %d failed: errno %d\n",\r\ntorture_type, cpu, ret);\r\n} else {\r\nif (verbose)\r\npr_alert("%s" TORTURE_FLAG\r\n"torture_onoff task: offlined %d\n",\r\ntorture_type, cpu);\r\nn_offline_successes++;\r\ndelta = jiffies - starttime;\r\nsum_offline += delta;\r\nif (min_offline < 0) {\r\nmin_offline = delta;\r\nmax_offline = delta;\r\n}\r\nif (min_offline > delta)\r\nmin_offline = delta;\r\nif (max_offline < delta)\r\nmax_offline = delta;\r\n}\r\n} else if (cpu_is_hotpluggable(cpu)) {\r\nif (verbose)\r\npr_alert("%s" TORTURE_FLAG\r\n"torture_onoff task: onlining %d\n",\r\ntorture_type, cpu);\r\nstarttime = jiffies;\r\nn_online_attempts++;\r\nret = cpu_up(cpu);\r\nif (ret) {\r\nif (verbose)\r\npr_alert("%s" TORTURE_FLAG\r\n"torture_onoff task: online %d failed: errno %d\n",\r\ntorture_type, cpu, ret);\r\n} else {\r\nif (verbose)\r\npr_alert("%s" TORTURE_FLAG\r\n"torture_onoff task: onlined %d\n",\r\ntorture_type, cpu);\r\nn_online_successes++;\r\ndelta = jiffies - starttime;\r\nsum_online += delta;\r\nif (min_online < 0) {\r\nmin_online = delta;\r\nmax_online = delta;\r\n}\r\nif (min_online > delta)\r\nmin_online = delta;\r\nif (max_online < delta)\r\nmax_online = delta;\r\n}\r\n}\r\nschedule_timeout_interruptible(onoff_interval);\r\n}\r\ntorture_kthread_stopping("torture_onoff");\r\nreturn 0;\r\n}\r\nint torture_onoff_init(long ooholdoff, long oointerval)\r\n{\r\nint ret = 0;\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nonoff_holdoff = ooholdoff;\r\nonoff_interval = oointerval;\r\nif (onoff_interval <= 0)\r\nreturn 0;\r\nret = torture_create_kthread(torture_onoff, NULL, onoff_task);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void torture_onoff_cleanup(void)\r\n{\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nif (onoff_task == NULL)\r\nreturn;\r\nVERBOSE_TOROUT_STRING("Stopping torture_onoff task");\r\nkthread_stop(onoff_task);\r\nonoff_task = NULL;\r\n#endif\r\n}\r\nvoid torture_onoff_stats(void)\r\n{\r\n#ifdef CONFIG_HOTPLUG_CPU\r\npr_cont("onoff: %ld/%ld:%ld/%ld %d,%d:%d,%d %lu:%lu (HZ=%d) ",\r\nn_online_successes, n_online_attempts,\r\nn_offline_successes, n_offline_attempts,\r\nmin_online, max_online,\r\nmin_offline, max_offline,\r\nsum_online, sum_offline, HZ);\r\n#endif\r\n}\r\nbool torture_onoff_failures(void)\r\n{\r\n#ifdef CONFIG_HOTPLUG_CPU\r\nreturn n_online_successes != n_online_attempts ||\r\nn_offline_successes != n_offline_attempts;\r\n#else\r\nreturn false;\r\n#endif\r\n}\r\nunsigned long\r\ntorture_random(struct torture_random_state *trsp)\r\n{\r\nif (--trsp->trs_count < 0) {\r\ntrsp->trs_state += (unsigned long)local_clock();\r\ntrsp->trs_count = TORTURE_RANDOM_REFRESH;\r\n}\r\ntrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\r\nTORTURE_RANDOM_ADD;\r\nreturn swahw32(trsp->trs_state);\r\n}\r\nvoid torture_shuffle_task_register(struct task_struct *tp)\r\n{\r\nstruct shuffle_task *stp;\r\nif (WARN_ON_ONCE(tp == NULL))\r\nreturn;\r\nstp = kmalloc(sizeof(*stp), GFP_KERNEL);\r\nif (WARN_ON_ONCE(stp == NULL))\r\nreturn;\r\nstp->st_t = tp;\r\nmutex_lock(&shuffle_task_mutex);\r\nlist_add(&stp->st_l, &shuffle_task_list);\r\nmutex_unlock(&shuffle_task_mutex);\r\n}\r\nstatic void torture_shuffle_task_unregister_all(void)\r\n{\r\nstruct shuffle_task *stp;\r\nstruct shuffle_task *p;\r\nmutex_lock(&shuffle_task_mutex);\r\nlist_for_each_entry_safe(stp, p, &shuffle_task_list, st_l) {\r\nlist_del(&stp->st_l);\r\nkfree(stp);\r\n}\r\nmutex_unlock(&shuffle_task_mutex);\r\n}\r\nstatic void torture_shuffle_tasks(void)\r\n{\r\nstruct shuffle_task *stp;\r\ncpumask_setall(shuffle_tmp_mask);\r\nget_online_cpus();\r\nif (num_online_cpus() == 1) {\r\nput_online_cpus();\r\nreturn;\r\n}\r\nshuffle_idle_cpu = cpumask_next(shuffle_idle_cpu, shuffle_tmp_mask);\r\nif (shuffle_idle_cpu >= nr_cpu_ids)\r\nshuffle_idle_cpu = -1;\r\nelse\r\ncpumask_clear_cpu(shuffle_idle_cpu, shuffle_tmp_mask);\r\nmutex_lock(&shuffle_task_mutex);\r\nlist_for_each_entry(stp, &shuffle_task_list, st_l)\r\nset_cpus_allowed_ptr(stp->st_t, shuffle_tmp_mask);\r\nmutex_unlock(&shuffle_task_mutex);\r\nput_online_cpus();\r\n}\r\nstatic int torture_shuffle(void *arg)\r\n{\r\nVERBOSE_TOROUT_STRING("torture_shuffle task started");\r\ndo {\r\nschedule_timeout_interruptible(shuffle_interval);\r\ntorture_shuffle_tasks();\r\ntorture_shutdown_absorb("torture_shuffle");\r\n} while (!torture_must_stop());\r\ntorture_kthread_stopping("torture_shuffle");\r\nreturn 0;\r\n}\r\nint torture_shuffle_init(long shuffint)\r\n{\r\nshuffle_interval = shuffint;\r\nshuffle_idle_cpu = -1;\r\nif (!alloc_cpumask_var(&shuffle_tmp_mask, GFP_KERNEL)) {\r\nVERBOSE_TOROUT_ERRSTRING("Failed to alloc mask");\r\nreturn -ENOMEM;\r\n}\r\nreturn torture_create_kthread(torture_shuffle, NULL, shuffler_task);\r\n}\r\nstatic void torture_shuffle_cleanup(void)\r\n{\r\ntorture_shuffle_task_unregister_all();\r\nif (shuffler_task) {\r\nVERBOSE_TOROUT_STRING("Stopping torture_shuffle task");\r\nkthread_stop(shuffler_task);\r\nfree_cpumask_var(shuffle_tmp_mask);\r\n}\r\nshuffler_task = NULL;\r\n}\r\nvoid torture_shutdown_absorb(const char *title)\r\n{\r\nwhile (ACCESS_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\r\npr_notice("torture thread %s parking due to system shutdown\n",\r\ntitle);\r\nschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\r\n}\r\n}\r\nstatic int torture_shutdown(void *arg)\r\n{\r\nlong delta;\r\nunsigned long jiffies_snap;\r\nVERBOSE_TOROUT_STRING("torture_shutdown task started");\r\njiffies_snap = jiffies;\r\nwhile (ULONG_CMP_LT(jiffies_snap, shutdown_time) &&\r\n!torture_must_stop()) {\r\ndelta = shutdown_time - jiffies_snap;\r\nif (verbose)\r\npr_alert("%s" TORTURE_FLAG\r\n"torture_shutdown task: %lu jiffies remaining\n",\r\ntorture_type, delta);\r\nschedule_timeout_interruptible(delta);\r\njiffies_snap = jiffies;\r\n}\r\nif (torture_must_stop()) {\r\ntorture_kthread_stopping("torture_shutdown");\r\nreturn 0;\r\n}\r\nVERBOSE_TOROUT_STRING("torture_shutdown task shutting down system");\r\nshutdown_task = NULL;\r\nif (torture_shutdown_hook)\r\ntorture_shutdown_hook();\r\nelse\r\nVERBOSE_TOROUT_STRING("No torture_shutdown_hook(), skipping.");\r\nkernel_power_off();\r\nreturn 0;\r\n}\r\nint torture_shutdown_init(int ssecs, void (*cleanup)(void))\r\n{\r\nint ret = 0;\r\nshutdown_secs = ssecs;\r\ntorture_shutdown_hook = cleanup;\r\nif (shutdown_secs > 0) {\r\nshutdown_time = jiffies + shutdown_secs * HZ;\r\nret = torture_create_kthread(torture_shutdown, NULL,\r\nshutdown_task);\r\n}\r\nreturn ret;\r\n}\r\nstatic int torture_shutdown_notify(struct notifier_block *unused1,\r\nunsigned long unused2, void *unused3)\r\n{\r\nmutex_lock(&fullstop_mutex);\r\nif (ACCESS_ONCE(fullstop) == FULLSTOP_DONTSTOP) {\r\nVERBOSE_TOROUT_STRING("Unscheduled system shutdown detected");\r\nACCESS_ONCE(fullstop) = FULLSTOP_SHUTDOWN;\r\n} else {\r\npr_warn("Concurrent rmmod and shutdown illegal!\n");\r\n}\r\nmutex_unlock(&fullstop_mutex);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void torture_shutdown_cleanup(void)\r\n{\r\nunregister_reboot_notifier(&torture_shutdown_nb);\r\nif (shutdown_task != NULL) {\r\nVERBOSE_TOROUT_STRING("Stopping torture_shutdown task");\r\nkthread_stop(shutdown_task);\r\n}\r\nshutdown_task = NULL;\r\n}\r\nvoid stutter_wait(const char *title)\r\n{\r\nwhile (ACCESS_ONCE(stutter_pause_test) ||\r\n(torture_runnable && !ACCESS_ONCE(*torture_runnable))) {\r\nif (stutter_pause_test)\r\nif (ACCESS_ONCE(stutter_pause_test) == 1)\r\nschedule_timeout_interruptible(1);\r\nelse\r\nwhile (ACCESS_ONCE(stutter_pause_test))\r\ncond_resched();\r\nelse\r\nschedule_timeout_interruptible(round_jiffies_relative(HZ));\r\ntorture_shutdown_absorb(title);\r\n}\r\n}\r\nstatic int torture_stutter(void *arg)\r\n{\r\nVERBOSE_TOROUT_STRING("torture_stutter task started");\r\ndo {\r\nif (!torture_must_stop()) {\r\nif (stutter > 1) {\r\nschedule_timeout_interruptible(stutter - 1);\r\nACCESS_ONCE(stutter_pause_test) = 2;\r\n}\r\nschedule_timeout_interruptible(1);\r\nACCESS_ONCE(stutter_pause_test) = 1;\r\n}\r\nif (!torture_must_stop())\r\nschedule_timeout_interruptible(stutter);\r\nACCESS_ONCE(stutter_pause_test) = 0;\r\ntorture_shutdown_absorb("torture_stutter");\r\n} while (!torture_must_stop());\r\ntorture_kthread_stopping("torture_stutter");\r\nreturn 0;\r\n}\r\nint torture_stutter_init(int s)\r\n{\r\nint ret;\r\nstutter = s;\r\nret = torture_create_kthread(torture_stutter, NULL, stutter_task);\r\nreturn ret;\r\n}\r\nstatic void torture_stutter_cleanup(void)\r\n{\r\nif (!stutter_task)\r\nreturn;\r\nVERBOSE_TOROUT_STRING("Stopping torture_stutter task");\r\nkthread_stop(stutter_task);\r\nstutter_task = NULL;\r\n}\r\nbool torture_init_begin(char *ttype, bool v, int *runnable)\r\n{\r\nmutex_lock(&fullstop_mutex);\r\nif (torture_type != NULL) {\r\npr_alert("torture_init_begin: refusing %s init: %s running",\r\nttype, torture_type);\r\nmutex_unlock(&fullstop_mutex);\r\nreturn false;\r\n}\r\ntorture_type = ttype;\r\nverbose = v;\r\ntorture_runnable = runnable;\r\nfullstop = FULLSTOP_DONTSTOP;\r\nreturn true;\r\n}\r\nvoid torture_init_end(void)\r\n{\r\nmutex_unlock(&fullstop_mutex);\r\nregister_reboot_notifier(&torture_shutdown_nb);\r\n}\r\nbool torture_cleanup_begin(void)\r\n{\r\nmutex_lock(&fullstop_mutex);\r\nif (ACCESS_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\r\npr_warn("Concurrent rmmod and shutdown illegal!\n");\r\nmutex_unlock(&fullstop_mutex);\r\nschedule_timeout_uninterruptible(10);\r\nreturn true;\r\n}\r\nACCESS_ONCE(fullstop) = FULLSTOP_RMMOD;\r\nmutex_unlock(&fullstop_mutex);\r\ntorture_shutdown_cleanup();\r\ntorture_shuffle_cleanup();\r\ntorture_stutter_cleanup();\r\ntorture_onoff_cleanup();\r\nreturn false;\r\n}\r\nvoid torture_cleanup_end(void)\r\n{\r\nmutex_lock(&fullstop_mutex);\r\ntorture_type = NULL;\r\nmutex_unlock(&fullstop_mutex);\r\n}\r\nbool torture_must_stop(void)\r\n{\r\nreturn torture_must_stop_irq() || kthread_should_stop();\r\n}\r\nbool torture_must_stop_irq(void)\r\n{\r\nreturn ACCESS_ONCE(fullstop) != FULLSTOP_DONTSTOP;\r\n}\r\nvoid torture_kthread_stopping(char *title)\r\n{\r\nchar buf[128];\r\nsnprintf(buf, sizeof(buf), "Stopping %s", title);\r\nVERBOSE_TOROUT_STRING(buf);\r\nwhile (!kthread_should_stop()) {\r\ntorture_shutdown_absorb(title);\r\nschedule_timeout_uninterruptible(1);\r\n}\r\n}\r\nint _torture_create_kthread(int (*fn)(void *arg), void *arg, char *s, char *m,\r\nchar *f, struct task_struct **tp)\r\n{\r\nint ret = 0;\r\nVERBOSE_TOROUT_STRING(m);\r\n*tp = kthread_run(fn, arg, "%s", s);\r\nif (IS_ERR(*tp)) {\r\nret = PTR_ERR(*tp);\r\nVERBOSE_TOROUT_ERRSTRING(f);\r\n*tp = NULL;\r\n}\r\ntorture_shuffle_task_register(*tp);\r\nreturn ret;\r\n}\r\nvoid _torture_stop_kthread(char *m, struct task_struct **tp)\r\n{\r\nif (*tp == NULL)\r\nreturn;\r\nVERBOSE_TOROUT_STRING(m);\r\nkthread_stop(*tp);\r\n*tp = NULL;\r\n}
