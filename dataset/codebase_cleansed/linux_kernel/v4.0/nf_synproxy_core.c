bool\r\nsynproxy_parse_options(const struct sk_buff *skb, unsigned int doff,\r\nconst struct tcphdr *th, struct synproxy_options *opts)\r\n{\r\nint length = (th->doff * 4) - sizeof(*th);\r\nu8 buf[40], *ptr;\r\nptr = skb_header_pointer(skb, doff + sizeof(*th), length, buf);\r\nif (ptr == NULL)\r\nreturn false;\r\nopts->options = 0;\r\nwhile (length > 0) {\r\nint opcode = *ptr++;\r\nint opsize;\r\nswitch (opcode) {\r\ncase TCPOPT_EOL:\r\nreturn true;\r\ncase TCPOPT_NOP:\r\nlength--;\r\ncontinue;\r\ndefault:\r\nopsize = *ptr++;\r\nif (opsize < 2)\r\nreturn true;\r\nif (opsize > length)\r\nreturn true;\r\nswitch (opcode) {\r\ncase TCPOPT_MSS:\r\nif (opsize == TCPOLEN_MSS) {\r\nopts->mss = get_unaligned_be16(ptr);\r\nopts->options |= XT_SYNPROXY_OPT_MSS;\r\n}\r\nbreak;\r\ncase TCPOPT_WINDOW:\r\nif (opsize == TCPOLEN_WINDOW) {\r\nopts->wscale = *ptr;\r\nif (opts->wscale > 14)\r\nopts->wscale = 14;\r\nopts->options |= XT_SYNPROXY_OPT_WSCALE;\r\n}\r\nbreak;\r\ncase TCPOPT_TIMESTAMP:\r\nif (opsize == TCPOLEN_TIMESTAMP) {\r\nopts->tsval = get_unaligned_be32(ptr);\r\nopts->tsecr = get_unaligned_be32(ptr + 4);\r\nopts->options |= XT_SYNPROXY_OPT_TIMESTAMP;\r\n}\r\nbreak;\r\ncase TCPOPT_SACK_PERM:\r\nif (opsize == TCPOLEN_SACK_PERM)\r\nopts->options |= XT_SYNPROXY_OPT_SACK_PERM;\r\nbreak;\r\n}\r\nptr += opsize - 2;\r\nlength -= opsize;\r\n}\r\n}\r\nreturn true;\r\n}\r\nunsigned int synproxy_options_size(const struct synproxy_options *opts)\r\n{\r\nunsigned int size = 0;\r\nif (opts->options & XT_SYNPROXY_OPT_MSS)\r\nsize += TCPOLEN_MSS_ALIGNED;\r\nif (opts->options & XT_SYNPROXY_OPT_TIMESTAMP)\r\nsize += TCPOLEN_TSTAMP_ALIGNED;\r\nelse if (opts->options & XT_SYNPROXY_OPT_SACK_PERM)\r\nsize += TCPOLEN_SACKPERM_ALIGNED;\r\nif (opts->options & XT_SYNPROXY_OPT_WSCALE)\r\nsize += TCPOLEN_WSCALE_ALIGNED;\r\nreturn size;\r\n}\r\nvoid\r\nsynproxy_build_options(struct tcphdr *th, const struct synproxy_options *opts)\r\n{\r\n__be32 *ptr = (__be32 *)(th + 1);\r\nu8 options = opts->options;\r\nif (options & XT_SYNPROXY_OPT_MSS)\r\n*ptr++ = htonl((TCPOPT_MSS << 24) |\r\n(TCPOLEN_MSS << 16) |\r\nopts->mss);\r\nif (options & XT_SYNPROXY_OPT_TIMESTAMP) {\r\nif (options & XT_SYNPROXY_OPT_SACK_PERM)\r\n*ptr++ = htonl((TCPOPT_SACK_PERM << 24) |\r\n(TCPOLEN_SACK_PERM << 16) |\r\n(TCPOPT_TIMESTAMP << 8) |\r\nTCPOLEN_TIMESTAMP);\r\nelse\r\n*ptr++ = htonl((TCPOPT_NOP << 24) |\r\n(TCPOPT_NOP << 16) |\r\n(TCPOPT_TIMESTAMP << 8) |\r\nTCPOLEN_TIMESTAMP);\r\n*ptr++ = htonl(opts->tsval);\r\n*ptr++ = htonl(opts->tsecr);\r\n} else if (options & XT_SYNPROXY_OPT_SACK_PERM)\r\n*ptr++ = htonl((TCPOPT_NOP << 24) |\r\n(TCPOPT_NOP << 16) |\r\n(TCPOPT_SACK_PERM << 8) |\r\nTCPOLEN_SACK_PERM);\r\nif (options & XT_SYNPROXY_OPT_WSCALE)\r\n*ptr++ = htonl((TCPOPT_NOP << 24) |\r\n(TCPOPT_WINDOW << 16) |\r\n(TCPOLEN_WINDOW << 8) |\r\nopts->wscale);\r\n}\r\nvoid synproxy_init_timestamp_cookie(const struct xt_synproxy_info *info,\r\nstruct synproxy_options *opts)\r\n{\r\nopts->tsecr = opts->tsval;\r\nopts->tsval = tcp_time_stamp & ~0x3f;\r\nif (opts->options & XT_SYNPROXY_OPT_WSCALE) {\r\nopts->tsval |= opts->wscale;\r\nopts->wscale = info->wscale;\r\n} else\r\nopts->tsval |= 0xf;\r\nif (opts->options & XT_SYNPROXY_OPT_SACK_PERM)\r\nopts->tsval |= 1 << 4;\r\nif (opts->options & XT_SYNPROXY_OPT_ECN)\r\nopts->tsval |= 1 << 5;\r\n}\r\nvoid synproxy_check_timestamp_cookie(struct synproxy_options *opts)\r\n{\r\nopts->wscale = opts->tsecr & 0xf;\r\nif (opts->wscale != 0xf)\r\nopts->options |= XT_SYNPROXY_OPT_WSCALE;\r\nopts->options |= opts->tsecr & (1 << 4) ? XT_SYNPROXY_OPT_SACK_PERM : 0;\r\nopts->options |= opts->tsecr & (1 << 5) ? XT_SYNPROXY_OPT_ECN : 0;\r\n}\r\nunsigned int synproxy_tstamp_adjust(struct sk_buff *skb,\r\nunsigned int protoff,\r\nstruct tcphdr *th,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nconst struct nf_conn_synproxy *synproxy)\r\n{\r\nunsigned int optoff, optend;\r\nu32 *ptr, old;\r\nif (synproxy->tsoff == 0)\r\nreturn 1;\r\noptoff = protoff + sizeof(struct tcphdr);\r\noptend = protoff + th->doff * 4;\r\nif (!skb_make_writable(skb, optend))\r\nreturn 0;\r\nwhile (optoff < optend) {\r\nunsigned char *op = skb->data + optoff;\r\nswitch (op[0]) {\r\ncase TCPOPT_EOL:\r\nreturn 1;\r\ncase TCPOPT_NOP:\r\noptoff++;\r\ncontinue;\r\ndefault:\r\nif (optoff + 1 == optend ||\r\noptoff + op[1] > optend ||\r\nop[1] < 2)\r\nreturn 0;\r\nif (op[0] == TCPOPT_TIMESTAMP &&\r\nop[1] == TCPOLEN_TIMESTAMP) {\r\nif (CTINFO2DIR(ctinfo) == IP_CT_DIR_REPLY) {\r\nptr = (u32 *)&op[2];\r\nold = *ptr;\r\n*ptr = htonl(ntohl(*ptr) -\r\nsynproxy->tsoff);\r\n} else {\r\nptr = (u32 *)&op[6];\r\nold = *ptr;\r\n*ptr = htonl(ntohl(*ptr) +\r\nsynproxy->tsoff);\r\n}\r\ninet_proto_csum_replace4(&th->check, skb,\r\nold, *ptr, 0);\r\nreturn 1;\r\n}\r\noptoff += op[1];\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void *synproxy_cpu_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct synproxy_net *snet = synproxy_pernet(seq_file_net(seq));\r\nint cpu;\r\nif (*pos == 0)\r\nreturn SEQ_START_TOKEN;\r\nfor (cpu = *pos - 1; cpu < nr_cpu_ids; cpu++) {\r\nif (!cpu_possible(cpu))\r\ncontinue;\r\n*pos = cpu + 1;\r\nreturn per_cpu_ptr(snet->stats, cpu);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *synproxy_cpu_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct synproxy_net *snet = synproxy_pernet(seq_file_net(seq));\r\nint cpu;\r\nfor (cpu = *pos; cpu < nr_cpu_ids; cpu++) {\r\nif (!cpu_possible(cpu))\r\ncontinue;\r\n*pos = cpu + 1;\r\nreturn per_cpu_ptr(snet->stats, cpu);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void synproxy_cpu_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nreturn;\r\n}\r\nstatic int synproxy_cpu_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct synproxy_stats *stats = v;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_printf(seq, "entries\t\tsyn_received\t"\r\n"cookie_invalid\tcookie_valid\t"\r\n"cookie_retrans\tconn_reopened\n");\r\nreturn 0;\r\n}\r\nseq_printf(seq, "%08x\t%08x\t%08x\t%08x\t%08x\t%08x\n", 0,\r\nstats->syn_received,\r\nstats->cookie_invalid,\r\nstats->cookie_valid,\r\nstats->cookie_retrans,\r\nstats->conn_reopened);\r\nreturn 0;\r\n}\r\nstatic int synproxy_cpu_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &synproxy_cpu_seq_ops,\r\nsizeof(struct seq_net_private));\r\n}\r\nstatic int __net_init synproxy_proc_init(struct net *net)\r\n{\r\nif (!proc_create("synproxy", S_IRUGO, net->proc_net_stat,\r\n&synproxy_cpu_seq_fops))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void __net_exit synproxy_proc_exit(struct net *net)\r\n{\r\nremove_proc_entry("synproxy", net->proc_net_stat);\r\n}\r\nstatic int __net_init synproxy_proc_init(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __net_exit synproxy_proc_exit(struct net *net)\r\n{\r\nreturn;\r\n}\r\nstatic int __net_init synproxy_net_init(struct net *net)\r\n{\r\nstruct synproxy_net *snet = synproxy_pernet(net);\r\nstruct nf_conntrack_tuple t;\r\nstruct nf_conn *ct;\r\nint err = -ENOMEM;\r\nmemset(&t, 0, sizeof(t));\r\nct = nf_conntrack_alloc(net, 0, &t, &t, GFP_KERNEL);\r\nif (IS_ERR(ct)) {\r\nerr = PTR_ERR(ct);\r\ngoto err1;\r\n}\r\nif (!nfct_seqadj_ext_add(ct))\r\ngoto err2;\r\nif (!nfct_synproxy_ext_add(ct))\r\ngoto err2;\r\nnf_conntrack_tmpl_insert(net, ct);\r\nsnet->tmpl = ct;\r\nsnet->stats = alloc_percpu(struct synproxy_stats);\r\nif (snet->stats == NULL)\r\ngoto err2;\r\nerr = synproxy_proc_init(net);\r\nif (err < 0)\r\ngoto err3;\r\nreturn 0;\r\nerr3:\r\nfree_percpu(snet->stats);\r\nerr2:\r\nnf_conntrack_free(ct);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic void __net_exit synproxy_net_exit(struct net *net)\r\n{\r\nstruct synproxy_net *snet = synproxy_pernet(net);\r\nnf_ct_put(snet->tmpl);\r\nsynproxy_proc_exit(net);\r\nfree_percpu(snet->stats);\r\n}\r\nstatic int __init synproxy_core_init(void)\r\n{\r\nint err;\r\nerr = nf_ct_extend_register(&nf_ct_synproxy_extend);\r\nif (err < 0)\r\ngoto err1;\r\nerr = register_pernet_subsys(&synproxy_net_ops);\r\nif (err < 0)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\nnf_ct_extend_unregister(&nf_ct_synproxy_extend);\r\nerr1:\r\nreturn err;\r\n}\r\nstatic void __exit synproxy_core_exit(void)\r\n{\r\nunregister_pernet_subsys(&synproxy_net_ops);\r\nnf_ct_extend_unregister(&nf_ct_synproxy_extend);\r\n}
