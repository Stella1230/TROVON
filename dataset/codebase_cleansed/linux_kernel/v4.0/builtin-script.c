static bool output_set_by_user(void)\r\n{\r\nint j;\r\nfor (j = 0; j < PERF_TYPE_MAX; ++j) {\r\nif (output[j].user_set)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic const char *output_field2str(enum perf_output_field field)\r\n{\r\nint i, imax = ARRAY_SIZE(all_output_options);\r\nconst char *str = "";\r\nfor (i = 0; i < imax; ++i) {\r\nif (all_output_options[i].field == field) {\r\nstr = all_output_options[i].str;\r\nbreak;\r\n}\r\n}\r\nreturn str;\r\n}\r\nstatic int perf_evsel__check_stype(struct perf_evsel *evsel,\r\nu64 sample_type, const char *sample_msg,\r\nenum perf_output_field field)\r\n{\r\nstruct perf_event_attr *attr = &evsel->attr;\r\nint type = attr->type;\r\nconst char *evname;\r\nif (attr->sample_type & sample_type)\r\nreturn 0;\r\nif (output[type].user_set) {\r\nevname = perf_evsel__name(evsel);\r\npr_err("Samples for '%s' event do not have %s attribute set. "\r\n"Cannot print '%s' field.\n",\r\nevname, sample_msg, output_field2str(field));\r\nreturn -1;\r\n}\r\noutput[type].fields &= ~field;\r\nevname = perf_evsel__name(evsel);\r\npr_debug("Samples for '%s' event do not have %s attribute set. "\r\n"Skipping '%s' field.\n",\r\nevname, sample_msg, output_field2str(field));\r\nreturn 0;\r\n}\r\nstatic int perf_evsel__check_attr(struct perf_evsel *evsel,\r\nstruct perf_session *session)\r\n{\r\nstruct perf_event_attr *attr = &evsel->attr;\r\nif (PRINT_FIELD(TRACE) &&\r\n!perf_session__has_traces(session, "record -R"))\r\nreturn -EINVAL;\r\nif (PRINT_FIELD(IP)) {\r\nif (perf_evsel__check_stype(evsel, PERF_SAMPLE_IP, "IP",\r\nPERF_OUTPUT_IP))\r\nreturn -EINVAL;\r\n}\r\nif (PRINT_FIELD(ADDR) &&\r\nperf_evsel__check_stype(evsel, PERF_SAMPLE_ADDR, "ADDR",\r\nPERF_OUTPUT_ADDR))\r\nreturn -EINVAL;\r\nif (PRINT_FIELD(SYM) && !PRINT_FIELD(IP) && !PRINT_FIELD(ADDR)) {\r\npr_err("Display of symbols requested but neither sample IP nor "\r\n"sample address\nis selected. Hence, no addresses to convert "\r\n"to symbols.\n");\r\nreturn -EINVAL;\r\n}\r\nif (PRINT_FIELD(SYMOFFSET) && !PRINT_FIELD(SYM)) {\r\npr_err("Display of offsets requested but symbol is not"\r\n"selected.\n");\r\nreturn -EINVAL;\r\n}\r\nif (PRINT_FIELD(DSO) && !PRINT_FIELD(IP) && !PRINT_FIELD(ADDR)) {\r\npr_err("Display of DSO requested but neither sample IP nor "\r\n"sample address\nis selected. Hence, no addresses to convert "\r\n"to DSO.\n");\r\nreturn -EINVAL;\r\n}\r\nif (PRINT_FIELD(SRCLINE) && !PRINT_FIELD(IP)) {\r\npr_err("Display of source line number requested but sample IP is not\n"\r\n"selected. Hence, no address to lookup the source line number.\n");\r\nreturn -EINVAL;\r\n}\r\nif ((PRINT_FIELD(PID) || PRINT_FIELD(TID)) &&\r\nperf_evsel__check_stype(evsel, PERF_SAMPLE_TID, "TID",\r\nPERF_OUTPUT_TID|PERF_OUTPUT_PID))\r\nreturn -EINVAL;\r\nif (PRINT_FIELD(TIME) &&\r\nperf_evsel__check_stype(evsel, PERF_SAMPLE_TIME, "TIME",\r\nPERF_OUTPUT_TIME))\r\nreturn -EINVAL;\r\nif (PRINT_FIELD(CPU) &&\r\nperf_evsel__check_stype(evsel, PERF_SAMPLE_CPU, "CPU",\r\nPERF_OUTPUT_CPU))\r\nreturn -EINVAL;\r\nif (PRINT_FIELD(PERIOD) &&\r\nperf_evsel__check_stype(evsel, PERF_SAMPLE_PERIOD, "PERIOD",\r\nPERF_OUTPUT_PERIOD))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void set_print_ip_opts(struct perf_event_attr *attr)\r\n{\r\nunsigned int type = attr->type;\r\noutput[type].print_ip_opts = 0;\r\nif (PRINT_FIELD(IP))\r\noutput[type].print_ip_opts |= PRINT_IP_OPT_IP;\r\nif (PRINT_FIELD(SYM))\r\noutput[type].print_ip_opts |= PRINT_IP_OPT_SYM;\r\nif (PRINT_FIELD(DSO))\r\noutput[type].print_ip_opts |= PRINT_IP_OPT_DSO;\r\nif (PRINT_FIELD(SYMOFFSET))\r\noutput[type].print_ip_opts |= PRINT_IP_OPT_SYMOFFSET;\r\nif (PRINT_FIELD(SRCLINE))\r\noutput[type].print_ip_opts |= PRINT_IP_OPT_SRCLINE;\r\n}\r\nstatic int perf_session__check_output_opt(struct perf_session *session)\r\n{\r\nint j;\r\nstruct perf_evsel *evsel;\r\nfor (j = 0; j < PERF_TYPE_MAX; ++j) {\r\nevsel = perf_session__find_first_evtype(session, j);\r\nif (!evsel && output[j].user_set && !output[j].wildcard_set) {\r\npr_err("%s events do not exist. "\r\n"Remove corresponding -f option to proceed.\n",\r\nevent_type(j));\r\nreturn -1;\r\n}\r\nif (evsel && output[j].fields &&\r\nperf_evsel__check_attr(evsel, session))\r\nreturn -1;\r\nif (evsel == NULL)\r\ncontinue;\r\nset_print_ip_opts(&evsel->attr);\r\n}\r\nif (!no_callchain) {\r\nbool use_callchain = false;\r\nevlist__for_each(session->evlist, evsel) {\r\nif (evsel->attr.sample_type & PERF_SAMPLE_CALLCHAIN) {\r\nuse_callchain = true;\r\nbreak;\r\n}\r\n}\r\nif (!use_callchain)\r\nsymbol_conf.use_callchain = false;\r\n}\r\nif (symbol_conf.use_callchain &&\r\n!output[PERF_TYPE_TRACEPOINT].user_set) {\r\nstruct perf_event_attr *attr;\r\nj = PERF_TYPE_TRACEPOINT;\r\nevsel = perf_session__find_first_evtype(session, j);\r\nif (evsel == NULL)\r\ngoto out;\r\nattr = &evsel->attr;\r\nif (attr->sample_type & PERF_SAMPLE_CALLCHAIN) {\r\noutput[j].fields |= PERF_OUTPUT_IP;\r\noutput[j].fields |= PERF_OUTPUT_SYM;\r\noutput[j].fields |= PERF_OUTPUT_DSO;\r\nset_print_ip_opts(attr);\r\n}\r\n}\r\nout:\r\nreturn 0;\r\n}\r\nstatic void print_sample_start(struct perf_sample *sample,\r\nstruct thread *thread,\r\nstruct perf_evsel *evsel)\r\n{\r\nstruct perf_event_attr *attr = &evsel->attr;\r\nunsigned long secs;\r\nunsigned long usecs;\r\nunsigned long long nsecs;\r\nif (PRINT_FIELD(COMM)) {\r\nif (latency_format)\r\nprintf("%8.8s ", thread__comm_str(thread));\r\nelse if (PRINT_FIELD(IP) && symbol_conf.use_callchain)\r\nprintf("%s ", thread__comm_str(thread));\r\nelse\r\nprintf("%16s ", thread__comm_str(thread));\r\n}\r\nif (PRINT_FIELD(PID) && PRINT_FIELD(TID))\r\nprintf("%5d/%-5d ", sample->pid, sample->tid);\r\nelse if (PRINT_FIELD(PID))\r\nprintf("%5d ", sample->pid);\r\nelse if (PRINT_FIELD(TID))\r\nprintf("%5d ", sample->tid);\r\nif (PRINT_FIELD(CPU)) {\r\nif (latency_format)\r\nprintf("%3d ", sample->cpu);\r\nelse\r\nprintf("[%03d] ", sample->cpu);\r\n}\r\nif (PRINT_FIELD(TIME)) {\r\nnsecs = sample->time;\r\nsecs = nsecs / NSECS_PER_SEC;\r\nnsecs -= secs * NSECS_PER_SEC;\r\nusecs = nsecs / NSECS_PER_USEC;\r\nprintf("%5lu.%06lu: ", secs, usecs);\r\n}\r\n}\r\nstatic void print_sample_addr(union perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct thread *thread,\r\nstruct perf_event_attr *attr)\r\n{\r\nstruct addr_location al;\r\nprintf("%16" PRIx64, sample->addr);\r\nif (!sample_addr_correlates_sym(attr))\r\nreturn;\r\nperf_event__preprocess_sample_addr(event, sample, thread, &al);\r\nif (PRINT_FIELD(SYM)) {\r\nprintf(" ");\r\nif (PRINT_FIELD(SYMOFFSET))\r\nsymbol__fprintf_symname_offs(al.sym, &al, stdout);\r\nelse\r\nsymbol__fprintf_symname(al.sym, stdout);\r\n}\r\nif (PRINT_FIELD(DSO)) {\r\nprintf(" (");\r\nmap__fprintf_dsoname(al.map, stdout);\r\nprintf(")");\r\n}\r\n}\r\nstatic void print_sample_bts(union perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct thread *thread,\r\nstruct addr_location *al)\r\n{\r\nstruct perf_event_attr *attr = &evsel->attr;\r\nbool print_srcline_last = false;\r\nif (PRINT_FIELD(IP)) {\r\nunsigned int print_opts = output[attr->type].print_ip_opts;\r\nif (symbol_conf.use_callchain && sample->callchain) {\r\nprintf("\n");\r\n} else {\r\nprintf(" ");\r\nif (print_opts & PRINT_IP_OPT_SRCLINE) {\r\nprint_srcline_last = true;\r\nprint_opts &= ~PRINT_IP_OPT_SRCLINE;\r\n}\r\n}\r\nperf_evsel__print_ip(evsel, sample, al, print_opts,\r\nPERF_MAX_STACK_DEPTH);\r\n}\r\nif (PRINT_FIELD(ADDR) ||\r\n((evsel->attr.sample_type & PERF_SAMPLE_ADDR) &&\r\n!output[attr->type].user_set)) {\r\nprintf(" => ");\r\nprint_sample_addr(event, sample, thread, attr);\r\n}\r\nif (print_srcline_last)\r\nmap__fprintf_srcline(al->map, al->addr, "\n ", stdout);\r\nprintf("\n");\r\n}\r\nstatic void process_event(union perf_event *event, struct perf_sample *sample,\r\nstruct perf_evsel *evsel, struct thread *thread,\r\nstruct addr_location *al)\r\n{\r\nstruct perf_event_attr *attr = &evsel->attr;\r\nif (output[attr->type].fields == 0)\r\nreturn;\r\nprint_sample_start(sample, thread, evsel);\r\nif (PRINT_FIELD(PERIOD))\r\nprintf("%10" PRIu64 " ", sample->period);\r\nif (PRINT_FIELD(EVNAME)) {\r\nconst char *evname = perf_evsel__name(evsel);\r\nprintf("%s: ", evname ? evname : "[unknown]");\r\n}\r\nif (is_bts_event(attr)) {\r\nprint_sample_bts(event, sample, evsel, thread, al);\r\nreturn;\r\n}\r\nif (PRINT_FIELD(TRACE))\r\nevent_format__print(evsel->tp_format, sample->cpu,\r\nsample->raw_data, sample->raw_size);\r\nif (PRINT_FIELD(ADDR))\r\nprint_sample_addr(event, sample, thread, attr);\r\nif (PRINT_FIELD(IP)) {\r\nif (!symbol_conf.use_callchain)\r\nprintf(" ");\r\nelse\r\nprintf("\n");\r\nperf_evsel__print_ip(evsel, sample, al,\r\noutput[attr->type].print_ip_opts,\r\nPERF_MAX_STACK_DEPTH);\r\n}\r\nprintf("\n");\r\n}\r\nstatic int default_start_script(const char *script __maybe_unused,\r\nint argc __maybe_unused,\r\nconst char **argv __maybe_unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic int default_flush_script(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic int default_stop_script(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic int default_generate_script(struct pevent *pevent __maybe_unused,\r\nconst char *outfile __maybe_unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic void setup_scripting(void)\r\n{\r\nsetup_perl_scripting();\r\nsetup_python_scripting();\r\nscripting_ops = &default_scripting_ops;\r\n}\r\nstatic int flush_scripting(void)\r\n{\r\nreturn scripting_ops->flush_script();\r\n}\r\nstatic int cleanup_scripting(void)\r\n{\r\npr_debug("\nperf script stopped\n");\r\nreturn scripting_ops->stop_script();\r\n}\r\nstatic int process_sample_event(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine)\r\n{\r\nstruct addr_location al;\r\nstruct thread *thread = machine__findnew_thread(machine, sample->pid,\r\nsample->tid);\r\nif (thread == NULL) {\r\npr_debug("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\nreturn -1;\r\n}\r\nif (debug_mode) {\r\nif (sample->time < last_timestamp) {\r\npr_err("Samples misordered, previous: %" PRIu64\r\n" this: %" PRIu64 "\n", last_timestamp,\r\nsample->time);\r\nnr_unordered++;\r\n}\r\nlast_timestamp = sample->time;\r\nreturn 0;\r\n}\r\nif (perf_event__preprocess_sample(event, machine, &al, sample) < 0) {\r\npr_err("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\nreturn -1;\r\n}\r\nif (al.filtered)\r\nreturn 0;\r\nif (cpu_list && !test_bit(sample->cpu, cpu_bitmap))\r\nreturn 0;\r\nscripting_ops->process_event(event, sample, evsel, thread, &al);\r\nreturn 0;\r\n}\r\nstatic int process_attr(struct perf_tool *tool, union perf_event *event,\r\nstruct perf_evlist **pevlist)\r\n{\r\nstruct perf_script *scr = container_of(tool, struct perf_script, tool);\r\nstruct perf_evlist *evlist;\r\nstruct perf_evsel *evsel, *pos;\r\nint err;\r\nerr = perf_event__process_attr(tool, event, pevlist);\r\nif (err)\r\nreturn err;\r\nevlist = *pevlist;\r\nevsel = perf_evlist__last(*pevlist);\r\nif (evsel->attr.type >= PERF_TYPE_MAX)\r\nreturn 0;\r\nevlist__for_each(evlist, pos) {\r\nif (pos->attr.type == evsel->attr.type && pos != evsel)\r\nreturn 0;\r\n}\r\nset_print_ip_opts(&evsel->attr);\r\nreturn perf_evsel__check_attr(evsel, scr->session);\r\n}\r\nstatic int process_comm_event(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nstruct thread *thread;\r\nstruct perf_script *script = container_of(tool, struct perf_script, tool);\r\nstruct perf_session *session = script->session;\r\nstruct perf_evsel *evsel = perf_evlist__first(session->evlist);\r\nint ret = -1;\r\nthread = machine__findnew_thread(machine, event->comm.pid, event->comm.tid);\r\nif (thread == NULL) {\r\npr_debug("problem processing COMM event, skipping it.\n");\r\nreturn -1;\r\n}\r\nif (perf_event__process_comm(tool, event, sample, machine) < 0)\r\ngoto out;\r\nif (!evsel->attr.sample_id_all) {\r\nsample->cpu = 0;\r\nsample->time = 0;\r\nsample->tid = event->comm.tid;\r\nsample->pid = event->comm.pid;\r\n}\r\nprint_sample_start(sample, thread, evsel);\r\nperf_event__fprintf(event, stdout);\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int process_fork_event(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nstruct thread *thread;\r\nstruct perf_script *script = container_of(tool, struct perf_script, tool);\r\nstruct perf_session *session = script->session;\r\nstruct perf_evsel *evsel = perf_evlist__first(session->evlist);\r\nif (perf_event__process_fork(tool, event, sample, machine) < 0)\r\nreturn -1;\r\nthread = machine__findnew_thread(machine, event->fork.pid, event->fork.tid);\r\nif (thread == NULL) {\r\npr_debug("problem processing FORK event, skipping it.\n");\r\nreturn -1;\r\n}\r\nif (!evsel->attr.sample_id_all) {\r\nsample->cpu = 0;\r\nsample->time = event->fork.time;\r\nsample->tid = event->fork.tid;\r\nsample->pid = event->fork.pid;\r\n}\r\nprint_sample_start(sample, thread, evsel);\r\nperf_event__fprintf(event, stdout);\r\nreturn 0;\r\n}\r\nstatic int process_exit_event(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nstruct thread *thread;\r\nstruct perf_script *script = container_of(tool, struct perf_script, tool);\r\nstruct perf_session *session = script->session;\r\nstruct perf_evsel *evsel = perf_evlist__first(session->evlist);\r\nthread = machine__findnew_thread(machine, event->fork.pid, event->fork.tid);\r\nif (thread == NULL) {\r\npr_debug("problem processing EXIT event, skipping it.\n");\r\nreturn -1;\r\n}\r\nif (!evsel->attr.sample_id_all) {\r\nsample->cpu = 0;\r\nsample->time = 0;\r\nsample->tid = event->comm.tid;\r\nsample->pid = event->comm.pid;\r\n}\r\nprint_sample_start(sample, thread, evsel);\r\nperf_event__fprintf(event, stdout);\r\nif (perf_event__process_exit(tool, event, sample, machine) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int process_mmap_event(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nstruct thread *thread;\r\nstruct perf_script *script = container_of(tool, struct perf_script, tool);\r\nstruct perf_session *session = script->session;\r\nstruct perf_evsel *evsel = perf_evlist__first(session->evlist);\r\nif (perf_event__process_mmap(tool, event, sample, machine) < 0)\r\nreturn -1;\r\nthread = machine__findnew_thread(machine, event->mmap.pid, event->mmap.tid);\r\nif (thread == NULL) {\r\npr_debug("problem processing MMAP event, skipping it.\n");\r\nreturn -1;\r\n}\r\nif (!evsel->attr.sample_id_all) {\r\nsample->cpu = 0;\r\nsample->time = 0;\r\nsample->tid = event->mmap.tid;\r\nsample->pid = event->mmap.pid;\r\n}\r\nprint_sample_start(sample, thread, evsel);\r\nperf_event__fprintf(event, stdout);\r\nreturn 0;\r\n}\r\nstatic int process_mmap2_event(struct perf_tool *tool,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct machine *machine)\r\n{\r\nstruct thread *thread;\r\nstruct perf_script *script = container_of(tool, struct perf_script, tool);\r\nstruct perf_session *session = script->session;\r\nstruct perf_evsel *evsel = perf_evlist__first(session->evlist);\r\nif (perf_event__process_mmap2(tool, event, sample, machine) < 0)\r\nreturn -1;\r\nthread = machine__findnew_thread(machine, event->mmap2.pid, event->mmap2.tid);\r\nif (thread == NULL) {\r\npr_debug("problem processing MMAP2 event, skipping it.\n");\r\nreturn -1;\r\n}\r\nif (!evsel->attr.sample_id_all) {\r\nsample->cpu = 0;\r\nsample->time = 0;\r\nsample->tid = event->mmap2.tid;\r\nsample->pid = event->mmap2.pid;\r\n}\r\nprint_sample_start(sample, thread, evsel);\r\nperf_event__fprintf(event, stdout);\r\nreturn 0;\r\n}\r\nstatic void sig_handler(int sig __maybe_unused)\r\n{\r\nsession_done = 1;\r\n}\r\nstatic int __cmd_script(struct perf_script *script)\r\n{\r\nint ret;\r\nsignal(SIGINT, sig_handler);\r\nif (script->show_task_events) {\r\nscript->tool.comm = process_comm_event;\r\nscript->tool.fork = process_fork_event;\r\nscript->tool.exit = process_exit_event;\r\n}\r\nif (script->show_mmap_events) {\r\nscript->tool.mmap = process_mmap_event;\r\nscript->tool.mmap2 = process_mmap2_event;\r\n}\r\nret = perf_session__process_events(script->session, &script->tool);\r\nif (debug_mode)\r\npr_err("Misordered timestamps: %" PRIu64 "\n", nr_unordered);\r\nreturn ret;\r\n}\r\nstatic struct script_spec *script_spec__new(const char *spec,\r\nstruct scripting_ops *ops)\r\n{\r\nstruct script_spec *s = malloc(sizeof(*s) + strlen(spec) + 1);\r\nif (s != NULL) {\r\nstrcpy(s->spec, spec);\r\ns->ops = ops;\r\n}\r\nreturn s;\r\n}\r\nstatic void script_spec__add(struct script_spec *s)\r\n{\r\nlist_add_tail(&s->node, &script_specs);\r\n}\r\nstatic struct script_spec *script_spec__find(const char *spec)\r\n{\r\nstruct script_spec *s;\r\nlist_for_each_entry(s, &script_specs, node)\r\nif (strcasecmp(s->spec, spec) == 0)\r\nreturn s;\r\nreturn NULL;\r\n}\r\nstatic struct script_spec *script_spec__findnew(const char *spec,\r\nstruct scripting_ops *ops)\r\n{\r\nstruct script_spec *s = script_spec__find(spec);\r\nif (s)\r\nreturn s;\r\ns = script_spec__new(spec, ops);\r\nif (!s)\r\nreturn NULL;\r\nscript_spec__add(s);\r\nreturn s;\r\n}\r\nint script_spec_register(const char *spec, struct scripting_ops *ops)\r\n{\r\nstruct script_spec *s;\r\ns = script_spec__find(spec);\r\nif (s)\r\nreturn -1;\r\ns = script_spec__findnew(spec, ops);\r\nif (!s)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic struct scripting_ops *script_spec__lookup(const char *spec)\r\n{\r\nstruct script_spec *s = script_spec__find(spec);\r\nif (!s)\r\nreturn NULL;\r\nreturn s->ops;\r\n}\r\nstatic void list_available_languages(void)\r\n{\r\nstruct script_spec *s;\r\nfprintf(stderr, "\n");\r\nfprintf(stderr, "Scripting language extensions (used in "\r\n"perf script -s [spec:]script.[spec]):\n\n");\r\nlist_for_each_entry(s, &script_specs, node)\r\nfprintf(stderr, " %-42s [%s]\n", s->spec, s->ops->name);\r\nfprintf(stderr, "\n");\r\n}\r\nstatic int parse_scriptname(const struct option *opt __maybe_unused,\r\nconst char *str, int unset __maybe_unused)\r\n{\r\nchar spec[PATH_MAX];\r\nconst char *script, *ext;\r\nint len;\r\nif (strcmp(str, "lang") == 0) {\r\nlist_available_languages();\r\nexit(0);\r\n}\r\nscript = strchr(str, ':');\r\nif (script) {\r\nlen = script - str;\r\nif (len >= PATH_MAX) {\r\nfprintf(stderr, "invalid language specifier");\r\nreturn -1;\r\n}\r\nstrncpy(spec, str, len);\r\nspec[len] = '\0';\r\nscripting_ops = script_spec__lookup(spec);\r\nif (!scripting_ops) {\r\nfprintf(stderr, "invalid language specifier");\r\nreturn -1;\r\n}\r\nscript++;\r\n} else {\r\nscript = str;\r\next = strrchr(script, '.');\r\nif (!ext) {\r\nfprintf(stderr, "invalid script extension");\r\nreturn -1;\r\n}\r\nscripting_ops = script_spec__lookup(++ext);\r\nif (!scripting_ops) {\r\nfprintf(stderr, "invalid script extension");\r\nreturn -1;\r\n}\r\n}\r\nscript_name = strdup(script);\r\nreturn 0;\r\n}\r\nstatic int parse_output_fields(const struct option *opt __maybe_unused,\r\nconst char *arg, int unset __maybe_unused)\r\n{\r\nchar *tok;\r\nint i, imax = ARRAY_SIZE(all_output_options);\r\nint j;\r\nint rc = 0;\r\nchar *str = strdup(arg);\r\nint type = -1;\r\nif (!str)\r\nreturn -ENOMEM;\r\ntok = strchr(str, ':');\r\nif (tok) {\r\n*tok = '\0';\r\ntok++;\r\nif (!strcmp(str, "hw"))\r\ntype = PERF_TYPE_HARDWARE;\r\nelse if (!strcmp(str, "sw"))\r\ntype = PERF_TYPE_SOFTWARE;\r\nelse if (!strcmp(str, "trace"))\r\ntype = PERF_TYPE_TRACEPOINT;\r\nelse if (!strcmp(str, "raw"))\r\ntype = PERF_TYPE_RAW;\r\nelse {\r\nfprintf(stderr, "Invalid event type in field string.\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (output[type].user_set)\r\npr_warning("Overriding previous field request for %s events.\n",\r\nevent_type(type));\r\noutput[type].fields = 0;\r\noutput[type].user_set = true;\r\noutput[type].wildcard_set = false;\r\n} else {\r\ntok = str;\r\nif (strlen(str) == 0) {\r\nfprintf(stderr,\r\n"Cannot set fields to 'none' for all event types.\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (output_set_by_user())\r\npr_warning("Overriding previous field request for all events.\n");\r\nfor (j = 0; j < PERF_TYPE_MAX; ++j) {\r\noutput[j].fields = 0;\r\noutput[j].user_set = true;\r\noutput[j].wildcard_set = true;\r\n}\r\n}\r\ntok = strtok(tok, ",");\r\nwhile (tok) {\r\nfor (i = 0; i < imax; ++i) {\r\nif (strcmp(tok, all_output_options[i].str) == 0)\r\nbreak;\r\n}\r\nif (i == imax) {\r\nfprintf(stderr, "Invalid field requested.\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (type == -1) {\r\nfor (j = 0; j < PERF_TYPE_MAX; ++j) {\r\nif (output[j].invalid_fields & all_output_options[i].field) {\r\npr_warning("\'%s\' not valid for %s events. Ignoring.\n",\r\nall_output_options[i].str, event_type(j));\r\n} else\r\noutput[j].fields |= all_output_options[i].field;\r\n}\r\n} else {\r\nif (output[type].invalid_fields & all_output_options[i].field) {\r\nfprintf(stderr, "\'%s\' not valid for %s events.\n",\r\nall_output_options[i].str, event_type(type));\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\noutput[type].fields |= all_output_options[i].field;\r\n}\r\ntok = strtok(NULL, ",");\r\n}\r\nif (type >= 0) {\r\nif (output[type].fields == 0) {\r\npr_debug("No fields requested for %s type. "\r\n"Events will not be displayed.\n", event_type(type));\r\n}\r\n}\r\nout:\r\nfree(str);\r\nreturn rc;\r\n}\r\nstatic int is_directory(const char *base_path, const struct dirent *dent)\r\n{\r\nchar path[PATH_MAX];\r\nstruct stat st;\r\nsprintf(path, "%s/%s", base_path, dent->d_name);\r\nif (stat(path, &st))\r\nreturn 0;\r\nreturn S_ISDIR(st.st_mode);\r\n}\r\nstatic struct script_desc *script_desc__new(const char *name)\r\n{\r\nstruct script_desc *s = zalloc(sizeof(*s));\r\nif (s != NULL && name)\r\ns->name = strdup(name);\r\nreturn s;\r\n}\r\nstatic void script_desc__delete(struct script_desc *s)\r\n{\r\nzfree(&s->name);\r\nzfree(&s->half_liner);\r\nzfree(&s->args);\r\nfree(s);\r\n}\r\nstatic void script_desc__add(struct script_desc *s)\r\n{\r\nlist_add_tail(&s->node, &script_descs);\r\n}\r\nstatic struct script_desc *script_desc__find(const char *name)\r\n{\r\nstruct script_desc *s;\r\nlist_for_each_entry(s, &script_descs, node)\r\nif (strcasecmp(s->name, name) == 0)\r\nreturn s;\r\nreturn NULL;\r\n}\r\nstatic struct script_desc *script_desc__findnew(const char *name)\r\n{\r\nstruct script_desc *s = script_desc__find(name);\r\nif (s)\r\nreturn s;\r\ns = script_desc__new(name);\r\nif (!s)\r\ngoto out_delete_desc;\r\nscript_desc__add(s);\r\nreturn s;\r\nout_delete_desc:\r\nscript_desc__delete(s);\r\nreturn NULL;\r\n}\r\nstatic const char *ends_with(const char *str, const char *suffix)\r\n{\r\nsize_t suffix_len = strlen(suffix);\r\nconst char *p = str;\r\nif (strlen(str) > suffix_len) {\r\np = str + strlen(str) - suffix_len;\r\nif (!strncmp(p, suffix, suffix_len))\r\nreturn p;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int read_script_info(struct script_desc *desc, const char *filename)\r\n{\r\nchar line[BUFSIZ], *p;\r\nFILE *fp;\r\nfp = fopen(filename, "r");\r\nif (!fp)\r\nreturn -1;\r\nwhile (fgets(line, sizeof(line), fp)) {\r\np = ltrim(line);\r\nif (strlen(p) == 0)\r\ncontinue;\r\nif (*p != '#')\r\ncontinue;\r\np++;\r\nif (strlen(p) && *p == '!')\r\ncontinue;\r\np = ltrim(p);\r\nif (strlen(p) && p[strlen(p) - 1] == '\n')\r\np[strlen(p) - 1] = '\0';\r\nif (!strncmp(p, "description:", strlen("description:"))) {\r\np += strlen("description:");\r\ndesc->half_liner = strdup(ltrim(p));\r\ncontinue;\r\n}\r\nif (!strncmp(p, "args:", strlen("args:"))) {\r\np += strlen("args:");\r\ndesc->args = strdup(ltrim(p));\r\ncontinue;\r\n}\r\n}\r\nfclose(fp);\r\nreturn 0;\r\n}\r\nstatic char *get_script_root(struct dirent *script_dirent, const char *suffix)\r\n{\r\nchar *script_root, *str;\r\nscript_root = strdup(script_dirent->d_name);\r\nif (!script_root)\r\nreturn NULL;\r\nstr = (char *)ends_with(script_root, suffix);\r\nif (!str) {\r\nfree(script_root);\r\nreturn NULL;\r\n}\r\n*str = '\0';\r\nreturn script_root;\r\n}\r\nstatic int list_available_scripts(const struct option *opt __maybe_unused,\r\nconst char *s __maybe_unused,\r\nint unset __maybe_unused)\r\n{\r\nstruct dirent *script_next, *lang_next, script_dirent, lang_dirent;\r\nchar scripts_path[MAXPATHLEN];\r\nDIR *scripts_dir, *lang_dir;\r\nchar script_path[MAXPATHLEN];\r\nchar lang_path[MAXPATHLEN];\r\nstruct script_desc *desc;\r\nchar first_half[BUFSIZ];\r\nchar *script_root;\r\nsnprintf(scripts_path, MAXPATHLEN, "%s/scripts", perf_exec_path());\r\nscripts_dir = opendir(scripts_path);\r\nif (!scripts_dir)\r\nreturn -1;\r\nfor_each_lang(scripts_path, scripts_dir, lang_dirent, lang_next) {\r\nsnprintf(lang_path, MAXPATHLEN, "%s/%s/bin", scripts_path,\r\nlang_dirent.d_name);\r\nlang_dir = opendir(lang_path);\r\nif (!lang_dir)\r\ncontinue;\r\nfor_each_script(lang_path, lang_dir, script_dirent, script_next) {\r\nscript_root = get_script_root(&script_dirent, REPORT_SUFFIX);\r\nif (script_root) {\r\ndesc = script_desc__findnew(script_root);\r\nsnprintf(script_path, MAXPATHLEN, "%s/%s",\r\nlang_path, script_dirent.d_name);\r\nread_script_info(desc, script_path);\r\nfree(script_root);\r\n}\r\n}\r\n}\r\nfprintf(stdout, "List of available trace scripts:\n");\r\nlist_for_each_entry(desc, &script_descs, node) {\r\nsprintf(first_half, "%s %s", desc->name,\r\ndesc->args ? desc->args : "");\r\nfprintf(stdout, " %-36s %s\n", first_half,\r\ndesc->half_liner ? desc->half_liner : "");\r\n}\r\nexit(0);\r\n}\r\nstatic int check_ev_match(char *dir_name, char *scriptname,\r\nstruct perf_session *session)\r\n{\r\nchar filename[MAXPATHLEN], evname[128];\r\nchar line[BUFSIZ], *p;\r\nstruct perf_evsel *pos;\r\nint match, len;\r\nFILE *fp;\r\nsprintf(filename, "%s/bin/%s-record", dir_name, scriptname);\r\nfp = fopen(filename, "r");\r\nif (!fp)\r\nreturn -1;\r\nwhile (fgets(line, sizeof(line), fp)) {\r\np = ltrim(line);\r\nif (*p == '#')\r\ncontinue;\r\nwhile (strlen(p)) {\r\np = strstr(p, "-e");\r\nif (!p)\r\nbreak;\r\np += 2;\r\np = ltrim(p);\r\nlen = strcspn(p, " \t");\r\nif (!len)\r\nbreak;\r\nsnprintf(evname, len + 1, "%s", p);\r\nmatch = 0;\r\nevlist__for_each(session->evlist, pos) {\r\nif (!strcmp(perf_evsel__name(pos), evname)) {\r\nmatch = 1;\r\nbreak;\r\n}\r\n}\r\nif (!match) {\r\nfclose(fp);\r\nreturn -1;\r\n}\r\n}\r\n}\r\nfclose(fp);\r\nreturn 0;\r\n}\r\nint find_scripts(char **scripts_array, char **scripts_path_array)\r\n{\r\nstruct dirent *script_next, *lang_next, script_dirent, lang_dirent;\r\nchar scripts_path[MAXPATHLEN], lang_path[MAXPATHLEN];\r\nDIR *scripts_dir, *lang_dir;\r\nstruct perf_session *session;\r\nstruct perf_data_file file = {\r\n.path = input_name,\r\n.mode = PERF_DATA_MODE_READ,\r\n};\r\nchar *temp;\r\nint i = 0;\r\nsession = perf_session__new(&file, false, NULL);\r\nif (!session)\r\nreturn -1;\r\nsnprintf(scripts_path, MAXPATHLEN, "%s/scripts", perf_exec_path());\r\nscripts_dir = opendir(scripts_path);\r\nif (!scripts_dir) {\r\nperf_session__delete(session);\r\nreturn -1;\r\n}\r\nfor_each_lang(scripts_path, scripts_dir, lang_dirent, lang_next) {\r\nsnprintf(lang_path, MAXPATHLEN, "%s/%s", scripts_path,\r\nlang_dirent.d_name);\r\n#ifdef NO_LIBPERL\r\nif (strstr(lang_path, "perl"))\r\ncontinue;\r\n#endif\r\n#ifdef NO_LIBPYTHON\r\nif (strstr(lang_path, "python"))\r\ncontinue;\r\n#endif\r\nlang_dir = opendir(lang_path);\r\nif (!lang_dir)\r\ncontinue;\r\nfor_each_script(lang_path, lang_dir, script_dirent, script_next) {\r\nif (strstr(script_dirent.d_name, "top."))\r\ncontinue;\r\nsprintf(scripts_path_array[i], "%s/%s", lang_path,\r\nscript_dirent.d_name);\r\ntemp = strchr(script_dirent.d_name, '.');\r\nsnprintf(scripts_array[i],\r\n(temp - script_dirent.d_name) + 1,\r\n"%s", script_dirent.d_name);\r\nif (check_ev_match(lang_path,\r\nscripts_array[i], session))\r\ncontinue;\r\ni++;\r\n}\r\nclosedir(lang_dir);\r\n}\r\nclosedir(scripts_dir);\r\nperf_session__delete(session);\r\nreturn i;\r\n}\r\nstatic char *get_script_path(const char *script_root, const char *suffix)\r\n{\r\nstruct dirent *script_next, *lang_next, script_dirent, lang_dirent;\r\nchar scripts_path[MAXPATHLEN];\r\nchar script_path[MAXPATHLEN];\r\nDIR *scripts_dir, *lang_dir;\r\nchar lang_path[MAXPATHLEN];\r\nchar *__script_root;\r\nsnprintf(scripts_path, MAXPATHLEN, "%s/scripts", perf_exec_path());\r\nscripts_dir = opendir(scripts_path);\r\nif (!scripts_dir)\r\nreturn NULL;\r\nfor_each_lang(scripts_path, scripts_dir, lang_dirent, lang_next) {\r\nsnprintf(lang_path, MAXPATHLEN, "%s/%s/bin", scripts_path,\r\nlang_dirent.d_name);\r\nlang_dir = opendir(lang_path);\r\nif (!lang_dir)\r\ncontinue;\r\nfor_each_script(lang_path, lang_dir, script_dirent, script_next) {\r\n__script_root = get_script_root(&script_dirent, suffix);\r\nif (__script_root && !strcmp(script_root, __script_root)) {\r\nfree(__script_root);\r\nclosedir(lang_dir);\r\nclosedir(scripts_dir);\r\nsnprintf(script_path, MAXPATHLEN, "%s/%s",\r\nlang_path, script_dirent.d_name);\r\nreturn strdup(script_path);\r\n}\r\nfree(__script_root);\r\n}\r\nclosedir(lang_dir);\r\n}\r\nclosedir(scripts_dir);\r\nreturn NULL;\r\n}\r\nstatic bool is_top_script(const char *script_path)\r\n{\r\nreturn ends_with(script_path, "top") == NULL ? false : true;\r\n}\r\nstatic int has_required_arg(char *script_path)\r\n{\r\nstruct script_desc *desc;\r\nint n_args = 0;\r\nchar *p;\r\ndesc = script_desc__new(NULL);\r\nif (read_script_info(desc, script_path))\r\ngoto out;\r\nif (!desc->args)\r\ngoto out;\r\nfor (p = desc->args; *p; p++)\r\nif (*p == '<')\r\nn_args++;\r\nout:\r\nscript_desc__delete(desc);\r\nreturn n_args;\r\n}\r\nstatic int have_cmd(int argc, const char **argv)\r\n{\r\nchar **__argv = malloc(sizeof(const char *) * argc);\r\nif (!__argv) {\r\npr_err("malloc failed\n");\r\nreturn -1;\r\n}\r\nmemcpy(__argv, argv, sizeof(const char *) * argc);\r\nargc = parse_options(argc, (const char **)__argv, record_options,\r\nNULL, PARSE_OPT_STOP_AT_NON_OPTION);\r\nfree(__argv);\r\nsystem_wide = (argc == 0);\r\nreturn 0;\r\n}\r\nint cmd_script(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nbool show_full_info = false;\r\nbool header = false;\r\nbool header_only = false;\r\nbool script_started = false;\r\nchar *rec_script_path = NULL;\r\nchar *rep_script_path = NULL;\r\nstruct perf_session *session;\r\nchar *script_path = NULL;\r\nconst char **__argv;\r\nint i, j, err = 0;\r\nstruct perf_script script = {\r\n.tool = {\r\n.sample = process_sample_event,\r\n.mmap = perf_event__process_mmap,\r\n.mmap2 = perf_event__process_mmap2,\r\n.comm = perf_event__process_comm,\r\n.exit = perf_event__process_exit,\r\n.fork = perf_event__process_fork,\r\n.attr = process_attr,\r\n.tracing_data = perf_event__process_tracing_data,\r\n.build_id = perf_event__process_build_id,\r\n.ordered_events = true,\r\n.ordering_requires_timestamps = true,\r\n},\r\n};\r\nconst struct option options[] = {\r\nOPT_BOOLEAN('D', "dump-raw-trace", &dump_trace,\r\n"dump raw trace in ASCII"),\r\nOPT_INCR('v', "verbose", &verbose,\r\n"be more verbose (show symbol address, etc)"),\r\nOPT_BOOLEAN('L', "Latency", &latency_format,\r\n"show latency attributes (irqs/preemption disabled, etc)"),\r\nOPT_CALLBACK_NOOPT('l', "list", NULL, NULL, "list available scripts",\r\nlist_available_scripts),\r\nOPT_CALLBACK('s', "script", NULL, "name",\r\n"script file name (lang:script name, script name, or *)",\r\nparse_scriptname),\r\nOPT_STRING('g', "gen-script", &generate_script_lang, "lang",\r\n"generate perf-script.xx script in specified language"),\r\nOPT_STRING('i', "input", &input_name, "file", "input file name"),\r\nOPT_BOOLEAN('d', "debug-mode", &debug_mode,\r\n"do various checks like samples ordering and lost events"),\r\nOPT_BOOLEAN(0, "header", &header, "Show data header."),\r\nOPT_BOOLEAN(0, "header-only", &header_only, "Show only data header."),\r\nOPT_STRING('k', "vmlinux", &symbol_conf.vmlinux_name,\r\n"file", "vmlinux pathname"),\r\nOPT_STRING(0, "kallsyms", &symbol_conf.kallsyms_name,\r\n"file", "kallsyms pathname"),\r\nOPT_BOOLEAN('G', "hide-call-graph", &no_callchain,\r\n"When printing symbols do not display call chain"),\r\nOPT_STRING(0, "symfs", &symbol_conf.symfs, "directory",\r\n"Look for files with symbols relative to this directory"),\r\nOPT_CALLBACK('f', "fields", NULL, "str",\r\n"comma separated output fields prepend with 'type:'. "\r\n"Valid types: hw,sw,trace,raw. "\r\n"Fields: comm,tid,pid,time,cpu,event,trace,ip,sym,dso,"\r\n"addr,symoff,period", parse_output_fields),\r\nOPT_BOOLEAN('a', "all-cpus", &system_wide,\r\n"system-wide collection from all CPUs"),\r\nOPT_STRING('S', "symbols", &symbol_conf.sym_list_str, "symbol[,symbol...]",\r\n"only consider these symbols"),\r\nOPT_STRING('C', "cpu", &cpu_list, "cpu", "list of cpus to profile"),\r\nOPT_STRING('c', "comms", &symbol_conf.comm_list_str, "comm[,comm...]",\r\n"only display events for these comms"),\r\nOPT_BOOLEAN('I', "show-info", &show_full_info,\r\n"display extended information from perf.data file"),\r\nOPT_BOOLEAN('\0', "show-kernel-path", &symbol_conf.show_kernel_path,\r\n"Show the path of [kernel.kallsyms]"),\r\nOPT_BOOLEAN('\0', "show-task-events", &script.show_task_events,\r\n"Show the fork/comm/exit events"),\r\nOPT_BOOLEAN('\0', "show-mmap-events", &script.show_mmap_events,\r\n"Show the mmap events"),\r\nOPT_END()\r\n};\r\nconst char * const script_usage[] = {\r\n"perf script [<options>]",\r\n"perf script [<options>] record <script> [<record-options>] <command>",\r\n"perf script [<options>] report <script> [script-args]",\r\n"perf script [<options>] <script> [<record-options>] <command>",\r\n"perf script [<options>] <top-script> [script-args]",\r\nNULL\r\n};\r\nstruct perf_data_file file = {\r\n.mode = PERF_DATA_MODE_READ,\r\n};\r\nsetup_scripting();\r\nargc = parse_options(argc, argv, options, script_usage,\r\nPARSE_OPT_STOP_AT_NON_OPTION);\r\nfile.path = input_name;\r\nif (argc > 1 && !strncmp(argv[0], "rec", strlen("rec"))) {\r\nrec_script_path = get_script_path(argv[1], RECORD_SUFFIX);\r\nif (!rec_script_path)\r\nreturn cmd_record(argc, argv, NULL);\r\n}\r\nif (argc > 1 && !strncmp(argv[0], "rep", strlen("rep"))) {\r\nrep_script_path = get_script_path(argv[1], REPORT_SUFFIX);\r\nif (!rep_script_path) {\r\nfprintf(stderr,\r\n"Please specify a valid report script"\r\n"(see 'perf script -l' for listing)\n");\r\nreturn -1;\r\n}\r\n}\r\nperf_set_argv_exec_path(perf_exec_path());\r\nif (argc && !script_name && !rec_script_path && !rep_script_path) {\r\nint live_pipe[2];\r\nint rep_args;\r\npid_t pid;\r\nrec_script_path = get_script_path(argv[0], RECORD_SUFFIX);\r\nrep_script_path = get_script_path(argv[0], REPORT_SUFFIX);\r\nif (!rec_script_path && !rep_script_path) {\r\nfprintf(stderr, " Couldn't find script %s\n\n See perf"\r\n" script -l for available scripts.\n", argv[0]);\r\nusage_with_options(script_usage, options);\r\n}\r\nif (is_top_script(argv[0])) {\r\nrep_args = argc - 1;\r\n} else {\r\nint rec_args;\r\nrep_args = has_required_arg(rep_script_path);\r\nrec_args = (argc - 1) - rep_args;\r\nif (rec_args < 0) {\r\nfprintf(stderr, " %s script requires options."\r\n"\n\n See perf script -l for available "\r\n"scripts and options.\n", argv[0]);\r\nusage_with_options(script_usage, options);\r\n}\r\n}\r\nif (pipe(live_pipe) < 0) {\r\nperror("failed to create pipe");\r\nreturn -1;\r\n}\r\npid = fork();\r\nif (pid < 0) {\r\nperror("failed to fork");\r\nreturn -1;\r\n}\r\nif (!pid) {\r\nj = 0;\r\ndup2(live_pipe[1], 1);\r\nclose(live_pipe[0]);\r\nif (is_top_script(argv[0])) {\r\nsystem_wide = true;\r\n} else if (!system_wide) {\r\nif (have_cmd(argc - rep_args, &argv[rep_args]) != 0) {\r\nerr = -1;\r\ngoto out;\r\n}\r\n}\r\n__argv = malloc((argc + 6) * sizeof(const char *));\r\nif (!__argv) {\r\npr_err("malloc failed\n");\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\n__argv[j++] = "/bin/sh";\r\n__argv[j++] = rec_script_path;\r\nif (system_wide)\r\n__argv[j++] = "-a";\r\n__argv[j++] = "-q";\r\n__argv[j++] = "-o";\r\n__argv[j++] = "-";\r\nfor (i = rep_args + 1; i < argc; i++)\r\n__argv[j++] = argv[i];\r\n__argv[j++] = NULL;\r\nexecvp("/bin/sh", (char **)__argv);\r\nfree(__argv);\r\nexit(-1);\r\n}\r\ndup2(live_pipe[0], 0);\r\nclose(live_pipe[1]);\r\n__argv = malloc((argc + 4) * sizeof(const char *));\r\nif (!__argv) {\r\npr_err("malloc failed\n");\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nj = 0;\r\n__argv[j++] = "/bin/sh";\r\n__argv[j++] = rep_script_path;\r\nfor (i = 1; i < rep_args + 1; i++)\r\n__argv[j++] = argv[i];\r\n__argv[j++] = "-i";\r\n__argv[j++] = "-";\r\n__argv[j++] = NULL;\r\nexecvp("/bin/sh", (char **)__argv);\r\nfree(__argv);\r\nexit(-1);\r\n}\r\nif (rec_script_path)\r\nscript_path = rec_script_path;\r\nif (rep_script_path)\r\nscript_path = rep_script_path;\r\nif (script_path) {\r\nj = 0;\r\nif (!rec_script_path)\r\nsystem_wide = false;\r\nelse if (!system_wide) {\r\nif (have_cmd(argc - 1, &argv[1]) != 0) {\r\nerr = -1;\r\ngoto out;\r\n}\r\n}\r\n__argv = malloc((argc + 2) * sizeof(const char *));\r\nif (!__argv) {\r\npr_err("malloc failed\n");\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\n__argv[j++] = "/bin/sh";\r\n__argv[j++] = script_path;\r\nif (system_wide)\r\n__argv[j++] = "-a";\r\nfor (i = 2; i < argc; i++)\r\n__argv[j++] = argv[i];\r\n__argv[j++] = NULL;\r\nexecvp("/bin/sh", (char **)__argv);\r\nfree(__argv);\r\nexit(-1);\r\n}\r\nif (!script_name)\r\nsetup_pager();\r\nsession = perf_session__new(&file, false, &script.tool);\r\nif (session == NULL)\r\nreturn -1;\r\nif (header || header_only) {\r\nperf_session__fprintf_info(session, stdout, show_full_info);\r\nif (header_only)\r\ngoto out_delete;\r\n}\r\nif (symbol__init(&session->header.env) < 0)\r\ngoto out_delete;\r\nscript.session = session;\r\nif (cpu_list) {\r\nerr = perf_session__cpu_bitmap(session, cpu_list, cpu_bitmap);\r\nif (err < 0)\r\ngoto out_delete;\r\n}\r\nif (!no_callchain)\r\nsymbol_conf.use_callchain = true;\r\nelse\r\nsymbol_conf.use_callchain = false;\r\nif (generate_script_lang) {\r\nstruct stat perf_stat;\r\nint input;\r\nif (output_set_by_user()) {\r\nfprintf(stderr,\r\n"custom fields not supported for generated scripts");\r\nerr = -EINVAL;\r\ngoto out_delete;\r\n}\r\ninput = open(file.path, O_RDONLY);\r\nif (input < 0) {\r\nerr = -errno;\r\nperror("failed to open file");\r\ngoto out_delete;\r\n}\r\nerr = fstat(input, &perf_stat);\r\nif (err < 0) {\r\nperror("failed to stat file");\r\ngoto out_delete;\r\n}\r\nif (!perf_stat.st_size) {\r\nfprintf(stderr, "zero-sized file, nothing to do!\n");\r\ngoto out_delete;\r\n}\r\nscripting_ops = script_spec__lookup(generate_script_lang);\r\nif (!scripting_ops) {\r\nfprintf(stderr, "invalid language specifier");\r\nerr = -ENOENT;\r\ngoto out_delete;\r\n}\r\nerr = scripting_ops->generate_script(session->tevent.pevent,\r\n"perf-script");\r\ngoto out_delete;\r\n}\r\nif (script_name) {\r\nerr = scripting_ops->start_script(script_name, argc, argv);\r\nif (err)\r\ngoto out_delete;\r\npr_debug("perf script started with script %s\n\n", script_name);\r\nscript_started = true;\r\n}\r\nerr = perf_session__check_output_opt(session);\r\nif (err < 0)\r\ngoto out_delete;\r\nerr = __cmd_script(&script);\r\nflush_scripting();\r\nout_delete:\r\nperf_session__delete(session);\r\nif (script_started)\r\ncleanup_scripting();\r\nout:\r\nreturn err;\r\n}
