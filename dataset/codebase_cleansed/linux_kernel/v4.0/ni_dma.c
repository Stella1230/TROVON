uint32_t cayman_dma_get_rptr(struct radeon_device *rdev,\r\nstruct radeon_ring *ring)\r\n{\r\nu32 rptr, reg;\r\nif (rdev->wb.enabled) {\r\nrptr = rdev->wb.wb[ring->rptr_offs/4];\r\n} else {\r\nif (ring->idx == R600_RING_TYPE_DMA_INDEX)\r\nreg = DMA_RB_RPTR + DMA0_REGISTER_OFFSET;\r\nelse\r\nreg = DMA_RB_RPTR + DMA1_REGISTER_OFFSET;\r\nrptr = RREG32(reg);\r\n}\r\nreturn (rptr & 0x3fffc) >> 2;\r\n}\r\nuint32_t cayman_dma_get_wptr(struct radeon_device *rdev,\r\nstruct radeon_ring *ring)\r\n{\r\nu32 reg;\r\nif (ring->idx == R600_RING_TYPE_DMA_INDEX)\r\nreg = DMA_RB_WPTR + DMA0_REGISTER_OFFSET;\r\nelse\r\nreg = DMA_RB_WPTR + DMA1_REGISTER_OFFSET;\r\nreturn (RREG32(reg) & 0x3fffc) >> 2;\r\n}\r\nvoid cayman_dma_set_wptr(struct radeon_device *rdev,\r\nstruct radeon_ring *ring)\r\n{\r\nu32 reg;\r\nif (ring->idx == R600_RING_TYPE_DMA_INDEX)\r\nreg = DMA_RB_WPTR + DMA0_REGISTER_OFFSET;\r\nelse\r\nreg = DMA_RB_WPTR + DMA1_REGISTER_OFFSET;\r\nWREG32(reg, (ring->wptr << 2) & 0x3fffc);\r\n}\r\nvoid cayman_dma_ring_ib_execute(struct radeon_device *rdev,\r\nstruct radeon_ib *ib)\r\n{\r\nstruct radeon_ring *ring = &rdev->ring[ib->ring];\r\nunsigned vm_id = ib->vm ? ib->vm->ids[ib->ring].id : 0;\r\nif (rdev->wb.enabled) {\r\nu32 next_rptr = ring->wptr + 4;\r\nwhile ((next_rptr & 7) != 5)\r\nnext_rptr++;\r\nnext_rptr += 3;\r\nradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_WRITE, 0, 0, 1));\r\nradeon_ring_write(ring, ring->next_rptr_gpu_addr & 0xfffffffc);\r\nradeon_ring_write(ring, upper_32_bits(ring->next_rptr_gpu_addr) & 0xff);\r\nradeon_ring_write(ring, next_rptr);\r\n}\r\nwhile ((ring->wptr & 7) != 5)\r\nradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0));\r\nradeon_ring_write(ring, DMA_IB_PACKET(DMA_PACKET_INDIRECT_BUFFER, vm_id, 0));\r\nradeon_ring_write(ring, (ib->gpu_addr & 0xFFFFFFE0));\r\nradeon_ring_write(ring, (ib->length_dw << 12) | (upper_32_bits(ib->gpu_addr) & 0xFF));\r\n}\r\nvoid cayman_dma_stop(struct radeon_device *rdev)\r\n{\r\nu32 rb_cntl;\r\nif ((rdev->asic->copy.copy_ring_index == R600_RING_TYPE_DMA_INDEX) ||\r\n(rdev->asic->copy.copy_ring_index == CAYMAN_RING_TYPE_DMA1_INDEX))\r\nradeon_ttm_set_active_vram_size(rdev, rdev->mc.visible_vram_size);\r\nrb_cntl = RREG32(DMA_RB_CNTL + DMA0_REGISTER_OFFSET);\r\nrb_cntl &= ~DMA_RB_ENABLE;\r\nWREG32(DMA_RB_CNTL + DMA0_REGISTER_OFFSET, rb_cntl);\r\nrb_cntl = RREG32(DMA_RB_CNTL + DMA1_REGISTER_OFFSET);\r\nrb_cntl &= ~DMA_RB_ENABLE;\r\nWREG32(DMA_RB_CNTL + DMA1_REGISTER_OFFSET, rb_cntl);\r\nrdev->ring[R600_RING_TYPE_DMA_INDEX].ready = false;\r\nrdev->ring[CAYMAN_RING_TYPE_DMA1_INDEX].ready = false;\r\n}\r\nint cayman_dma_resume(struct radeon_device *rdev)\r\n{\r\nstruct radeon_ring *ring;\r\nu32 rb_cntl, dma_cntl, ib_cntl;\r\nu32 rb_bufsz;\r\nu32 reg_offset, wb_offset;\r\nint i, r;\r\nfor (i = 0; i < 2; i++) {\r\nif (i == 0) {\r\nring = &rdev->ring[R600_RING_TYPE_DMA_INDEX];\r\nreg_offset = DMA0_REGISTER_OFFSET;\r\nwb_offset = R600_WB_DMA_RPTR_OFFSET;\r\n} else {\r\nring = &rdev->ring[CAYMAN_RING_TYPE_DMA1_INDEX];\r\nreg_offset = DMA1_REGISTER_OFFSET;\r\nwb_offset = CAYMAN_WB_DMA1_RPTR_OFFSET;\r\n}\r\nWREG32(DMA_SEM_INCOMPLETE_TIMER_CNTL + reg_offset, 0);\r\nWREG32(DMA_SEM_WAIT_FAIL_TIMER_CNTL + reg_offset, 0);\r\nrb_bufsz = order_base_2(ring->ring_size / 4);\r\nrb_cntl = rb_bufsz << 1;\r\n#ifdef __BIG_ENDIAN\r\nrb_cntl |= DMA_RB_SWAP_ENABLE | DMA_RPTR_WRITEBACK_SWAP_ENABLE;\r\n#endif\r\nWREG32(DMA_RB_CNTL + reg_offset, rb_cntl);\r\nWREG32(DMA_RB_RPTR + reg_offset, 0);\r\nWREG32(DMA_RB_WPTR + reg_offset, 0);\r\nWREG32(DMA_RB_RPTR_ADDR_HI + reg_offset,\r\nupper_32_bits(rdev->wb.gpu_addr + wb_offset) & 0xFF);\r\nWREG32(DMA_RB_RPTR_ADDR_LO + reg_offset,\r\n((rdev->wb.gpu_addr + wb_offset) & 0xFFFFFFFC));\r\nif (rdev->wb.enabled)\r\nrb_cntl |= DMA_RPTR_WRITEBACK_ENABLE;\r\nWREG32(DMA_RB_BASE + reg_offset, ring->gpu_addr >> 8);\r\nib_cntl = DMA_IB_ENABLE | CMD_VMID_FORCE;\r\n#ifdef __BIG_ENDIAN\r\nib_cntl |= DMA_IB_SWAP_ENABLE;\r\n#endif\r\nWREG32(DMA_IB_CNTL + reg_offset, ib_cntl);\r\ndma_cntl = RREG32(DMA_CNTL + reg_offset);\r\ndma_cntl &= ~CTXEMPTY_INT_ENABLE;\r\nWREG32(DMA_CNTL + reg_offset, dma_cntl);\r\nring->wptr = 0;\r\nWREG32(DMA_RB_WPTR + reg_offset, ring->wptr << 2);\r\nWREG32(DMA_RB_CNTL + reg_offset, rb_cntl | DMA_RB_ENABLE);\r\nring->ready = true;\r\nr = radeon_ring_test(rdev, ring->idx, ring);\r\nif (r) {\r\nring->ready = false;\r\nreturn r;\r\n}\r\n}\r\nif ((rdev->asic->copy.copy_ring_index == R600_RING_TYPE_DMA_INDEX) ||\r\n(rdev->asic->copy.copy_ring_index == CAYMAN_RING_TYPE_DMA1_INDEX))\r\nradeon_ttm_set_active_vram_size(rdev, rdev->mc.real_vram_size);\r\nreturn 0;\r\n}\r\nvoid cayman_dma_fini(struct radeon_device *rdev)\r\n{\r\ncayman_dma_stop(rdev);\r\nradeon_ring_fini(rdev, &rdev->ring[R600_RING_TYPE_DMA_INDEX]);\r\nradeon_ring_fini(rdev, &rdev->ring[CAYMAN_RING_TYPE_DMA1_INDEX]);\r\n}\r\nbool cayman_dma_is_lockup(struct radeon_device *rdev, struct radeon_ring *ring)\r\n{\r\nu32 reset_mask = cayman_gpu_check_soft_reset(rdev);\r\nu32 mask;\r\nif (ring->idx == R600_RING_TYPE_DMA_INDEX)\r\nmask = RADEON_RESET_DMA;\r\nelse\r\nmask = RADEON_RESET_DMA1;\r\nif (!(reset_mask & mask)) {\r\nradeon_ring_lockup_update(rdev, ring);\r\nreturn false;\r\n}\r\nreturn radeon_ring_test_lockup(rdev, ring);\r\n}\r\nvoid cayman_dma_vm_copy_pages(struct radeon_device *rdev,\r\nstruct radeon_ib *ib,\r\nuint64_t pe, uint64_t src,\r\nunsigned count)\r\n{\r\nunsigned ndw;\r\nwhile (count) {\r\nndw = count * 2;\r\nif (ndw > 0xFFFFE)\r\nndw = 0xFFFFE;\r\nib->ptr[ib->length_dw++] = DMA_PACKET(DMA_PACKET_COPY,\r\n0, 0, ndw);\r\nib->ptr[ib->length_dw++] = lower_32_bits(pe);\r\nib->ptr[ib->length_dw++] = lower_32_bits(src);\r\nib->ptr[ib->length_dw++] = upper_32_bits(pe) & 0xff;\r\nib->ptr[ib->length_dw++] = upper_32_bits(src) & 0xff;\r\npe += ndw * 4;\r\nsrc += ndw * 4;\r\ncount -= ndw / 2;\r\n}\r\n}\r\nvoid cayman_dma_vm_write_pages(struct radeon_device *rdev,\r\nstruct radeon_ib *ib,\r\nuint64_t pe,\r\nuint64_t addr, unsigned count,\r\nuint32_t incr, uint32_t flags)\r\n{\r\nuint64_t value;\r\nunsigned ndw;\r\nwhile (count) {\r\nndw = count * 2;\r\nif (ndw > 0xFFFFE)\r\nndw = 0xFFFFE;\r\nib->ptr[ib->length_dw++] = DMA_PACKET(DMA_PACKET_WRITE,\r\n0, 0, ndw);\r\nib->ptr[ib->length_dw++] = pe;\r\nib->ptr[ib->length_dw++] = upper_32_bits(pe) & 0xff;\r\nfor (; ndw > 0; ndw -= 2, --count, pe += 8) {\r\nif (flags & R600_PTE_SYSTEM) {\r\nvalue = radeon_vm_map_gart(rdev, addr);\r\n} else if (flags & R600_PTE_VALID) {\r\nvalue = addr;\r\n} else {\r\nvalue = 0;\r\n}\r\naddr += incr;\r\nvalue |= flags;\r\nib->ptr[ib->length_dw++] = value;\r\nib->ptr[ib->length_dw++] = upper_32_bits(value);\r\n}\r\n}\r\n}\r\nvoid cayman_dma_vm_set_pages(struct radeon_device *rdev,\r\nstruct radeon_ib *ib,\r\nuint64_t pe,\r\nuint64_t addr, unsigned count,\r\nuint32_t incr, uint32_t flags)\r\n{\r\nuint64_t value;\r\nunsigned ndw;\r\nwhile (count) {\r\nndw = count * 2;\r\nif (ndw > 0xFFFFE)\r\nndw = 0xFFFFE;\r\nif (flags & R600_PTE_VALID)\r\nvalue = addr;\r\nelse\r\nvalue = 0;\r\nib->ptr[ib->length_dw++] = DMA_PTE_PDE_PACKET(ndw);\r\nib->ptr[ib->length_dw++] = pe;\r\nib->ptr[ib->length_dw++] = upper_32_bits(pe) & 0xff;\r\nib->ptr[ib->length_dw++] = flags;\r\nib->ptr[ib->length_dw++] = 0;\r\nib->ptr[ib->length_dw++] = value;\r\nib->ptr[ib->length_dw++] = upper_32_bits(value);\r\nib->ptr[ib->length_dw++] = incr;\r\nib->ptr[ib->length_dw++] = 0;\r\npe += ndw * 4;\r\naddr += (ndw / 2) * incr;\r\ncount -= ndw / 2;\r\n}\r\n}\r\nvoid cayman_dma_vm_pad_ib(struct radeon_ib *ib)\r\n{\r\nwhile (ib->length_dw & 0x7)\r\nib->ptr[ib->length_dw++] = DMA_PACKET(DMA_PACKET_NOP, 0, 0, 0);\r\n}\r\nvoid cayman_dma_vm_flush(struct radeon_device *rdev, struct radeon_ring *ring,\r\nunsigned vm_id, uint64_t pd_addr)\r\n{\r\nradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_SRBM_WRITE, 0, 0, 0));\r\nradeon_ring_write(ring, (0xf << 16) | ((VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (vm_id << 2)) >> 2));\r\nradeon_ring_write(ring, pd_addr >> 12);\r\nradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_SRBM_WRITE, 0, 0, 0));\r\nradeon_ring_write(ring, (0xf << 16) | (HDP_MEM_COHERENCY_FLUSH_CNTL >> 2));\r\nradeon_ring_write(ring, 1);\r\nradeon_ring_write(ring, DMA_PACKET(DMA_PACKET_SRBM_WRITE, 0, 0, 0));\r\nradeon_ring_write(ring, (0xf << 16) | (VM_INVALIDATE_REQUEST >> 2));\r\nradeon_ring_write(ring, 1 << vm_id);\r\nradeon_ring_write(ring, DMA_SRBM_READ_PACKET);\r\nradeon_ring_write(ring, (0xff << 20) | (VM_INVALIDATE_REQUEST >> 2));\r\nradeon_ring_write(ring, 0);\r\nradeon_ring_write(ring, 0);\r\n}
