static int nfs42_set_rw_stateid(nfs4_stateid *dst, struct file *file,\r\nfmode_t fmode)\r\n{\r\nstruct nfs_open_context *open;\r\nstruct nfs_lock_context *lock;\r\nint ret;\r\nopen = get_nfs_open_context(nfs_file_open_context(file));\r\nlock = nfs_get_lock_context(open);\r\nif (IS_ERR(lock)) {\r\nput_nfs_open_context(open);\r\nreturn PTR_ERR(lock);\r\n}\r\nret = nfs4_set_rw_stateid(dst, open, lock, fmode);\r\nnfs_put_lock_context(lock);\r\nput_nfs_open_context(open);\r\nreturn ret;\r\n}\r\nstatic int _nfs42_proc_fallocate(struct rpc_message *msg, struct file *filep,\r\nloff_t offset, loff_t len)\r\n{\r\nstruct inode *inode = file_inode(filep);\r\nstruct nfs42_falloc_args args = {\r\n.falloc_fh = NFS_FH(inode),\r\n.falloc_offset = offset,\r\n.falloc_length = len,\r\n};\r\nstruct nfs42_falloc_res res;\r\nstruct nfs_server *server = NFS_SERVER(inode);\r\nint status;\r\nmsg->rpc_argp = &args;\r\nmsg->rpc_resp = &res;\r\nstatus = nfs42_set_rw_stateid(&args.falloc_stateid, filep, FMODE_WRITE);\r\nif (status)\r\nreturn status;\r\nreturn nfs4_call_sync(server->client, server, msg,\r\n&args.seq_args, &res.seq_res, 0);\r\n}\r\nstatic int nfs42_proc_fallocate(struct rpc_message *msg, struct file *filep,\r\nloff_t offset, loff_t len)\r\n{\r\nstruct nfs_server *server = NFS_SERVER(file_inode(filep));\r\nstruct nfs4_exception exception = { };\r\nint err;\r\ndo {\r\nerr = _nfs42_proc_fallocate(msg, filep, offset, len);\r\nif (err == -ENOTSUPP)\r\nreturn -EOPNOTSUPP;\r\nerr = nfs4_handle_exception(server, err, &exception);\r\n} while (exception.retry);\r\nreturn err;\r\n}\r\nint nfs42_proc_allocate(struct file *filep, loff_t offset, loff_t len)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_ALLOCATE],\r\n};\r\nstruct inode *inode = file_inode(filep);\r\nint err;\r\nif (!nfs_server_capable(inode, NFS_CAP_ALLOCATE))\r\nreturn -EOPNOTSUPP;\r\nerr = nfs42_proc_fallocate(&msg, filep, offset, len);\r\nif (err == -EOPNOTSUPP)\r\nNFS_SERVER(inode)->caps &= ~NFS_CAP_ALLOCATE;\r\nreturn err;\r\n}\r\nint nfs42_proc_deallocate(struct file *filep, loff_t offset, loff_t len)\r\n{\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_DEALLOCATE],\r\n};\r\nstruct inode *inode = file_inode(filep);\r\nint err;\r\nif (!nfs_server_capable(inode, NFS_CAP_DEALLOCATE))\r\nreturn -EOPNOTSUPP;\r\nerr = nfs42_proc_fallocate(&msg, filep, offset, len);\r\nif (err == -EOPNOTSUPP)\r\nNFS_SERVER(inode)->caps &= ~NFS_CAP_DEALLOCATE;\r\nreturn err;\r\n}\r\nloff_t nfs42_proc_llseek(struct file *filep, loff_t offset, int whence)\r\n{\r\nstruct inode *inode = file_inode(filep);\r\nstruct nfs42_seek_args args = {\r\n.sa_fh = NFS_FH(inode),\r\n.sa_offset = offset,\r\n.sa_what = (whence == SEEK_HOLE) ?\r\nNFS4_CONTENT_HOLE : NFS4_CONTENT_DATA,\r\n};\r\nstruct nfs42_seek_res res;\r\nstruct rpc_message msg = {\r\n.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_SEEK],\r\n.rpc_argp = &args,\r\n.rpc_resp = &res,\r\n};\r\nstruct nfs_server *server = NFS_SERVER(inode);\r\nint status;\r\nif (!nfs_server_capable(inode, NFS_CAP_SEEK))\r\nreturn -ENOTSUPP;\r\nstatus = nfs42_set_rw_stateid(&args.sa_stateid, filep, FMODE_READ);\r\nif (status)\r\nreturn status;\r\nnfs_wb_all(inode);\r\nstatus = nfs4_call_sync(server->client, server, &msg,\r\n&args.seq_args, &res.seq_res, 0);\r\nif (status == -ENOTSUPP)\r\nserver->caps &= ~NFS_CAP_SEEK;\r\nif (status)\r\nreturn status;\r\nreturn vfs_setpos(filep, res.sr_offset, inode->i_sb->s_maxbytes);\r\n}
