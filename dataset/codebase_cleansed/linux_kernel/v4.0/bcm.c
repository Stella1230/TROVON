static inline u64 GET_U64(const struct can_frame *cp)\r\n{\r\nreturn *(u64 *)cp->data;\r\n}\r\nstatic inline struct bcm_sock *bcm_sk(const struct sock *sk)\r\n{\r\nreturn (struct bcm_sock *)sk;\r\n}\r\nstatic char *bcm_proc_getifname(char *result, int ifindex)\r\n{\r\nstruct net_device *dev;\r\nif (!ifindex)\r\nreturn "any";\r\nrcu_read_lock();\r\ndev = dev_get_by_index_rcu(&init_net, ifindex);\r\nif (dev)\r\nstrcpy(result, dev->name);\r\nelse\r\nstrcpy(result, "???");\r\nrcu_read_unlock();\r\nreturn result;\r\n}\r\nstatic int bcm_proc_show(struct seq_file *m, void *v)\r\n{\r\nchar ifname[IFNAMSIZ];\r\nstruct sock *sk = (struct sock *)m->private;\r\nstruct bcm_sock *bo = bcm_sk(sk);\r\nstruct bcm_op *op;\r\nseq_printf(m, ">>> socket %pK", sk->sk_socket);\r\nseq_printf(m, " / sk %pK", sk);\r\nseq_printf(m, " / bo %pK", bo);\r\nseq_printf(m, " / dropped %lu", bo->dropped_usr_msgs);\r\nseq_printf(m, " / bound %s", bcm_proc_getifname(ifname, bo->ifindex));\r\nseq_printf(m, " <<<\n");\r\nlist_for_each_entry(op, &bo->rx_ops, list) {\r\nunsigned long reduction;\r\nif (!op->frames_abs)\r\ncontinue;\r\nseq_printf(m, "rx_op: %03X %-5s ",\r\nop->can_id, bcm_proc_getifname(ifname, op->ifindex));\r\nseq_printf(m, "[%u]%c ", op->nframes,\r\n(op->flags & RX_CHECK_DLC)?'d':' ');\r\nif (op->kt_ival1.tv64)\r\nseq_printf(m, "timeo=%lld ",\r\n(long long)\r\nktime_to_us(op->kt_ival1));\r\nif (op->kt_ival2.tv64)\r\nseq_printf(m, "thr=%lld ",\r\n(long long)\r\nktime_to_us(op->kt_ival2));\r\nseq_printf(m, "# recv %ld (%ld) => reduction: ",\r\nop->frames_filtered, op->frames_abs);\r\nreduction = 100 - (op->frames_filtered * 100) / op->frames_abs;\r\nseq_printf(m, "%s%ld%%\n",\r\n(reduction == 100)?"near ":"", reduction);\r\n}\r\nlist_for_each_entry(op, &bo->tx_ops, list) {\r\nseq_printf(m, "tx_op: %03X %s [%u] ",\r\nop->can_id,\r\nbcm_proc_getifname(ifname, op->ifindex),\r\nop->nframes);\r\nif (op->kt_ival1.tv64)\r\nseq_printf(m, "t1=%lld ",\r\n(long long) ktime_to_us(op->kt_ival1));\r\nif (op->kt_ival2.tv64)\r\nseq_printf(m, "t2=%lld ",\r\n(long long) ktime_to_us(op->kt_ival2));\r\nseq_printf(m, "# sent %ld\n", op->frames_abs);\r\n}\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic int bcm_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, bcm_proc_show, PDE_DATA(inode));\r\n}\r\nstatic void bcm_can_tx(struct bcm_op *op)\r\n{\r\nstruct sk_buff *skb;\r\nstruct net_device *dev;\r\nstruct can_frame *cf = &op->frames[op->currframe];\r\nif (!op->ifindex)\r\nreturn;\r\ndev = dev_get_by_index(&init_net, op->ifindex);\r\nif (!dev) {\r\nreturn;\r\n}\r\nskb = alloc_skb(CFSIZ + sizeof(struct can_skb_priv), gfp_any());\r\nif (!skb)\r\ngoto out;\r\ncan_skb_reserve(skb);\r\ncan_skb_prv(skb)->ifindex = dev->ifindex;\r\nmemcpy(skb_put(skb, CFSIZ), cf, CFSIZ);\r\nskb->dev = dev;\r\ncan_skb_set_owner(skb, op->sk);\r\ncan_send(skb, 1);\r\nop->currframe++;\r\nop->frames_abs++;\r\nif (op->currframe >= op->nframes)\r\nop->currframe = 0;\r\nout:\r\ndev_put(dev);\r\n}\r\nstatic void bcm_send_to_user(struct bcm_op *op, struct bcm_msg_head *head,\r\nstruct can_frame *frames, int has_timestamp)\r\n{\r\nstruct sk_buff *skb;\r\nstruct can_frame *firstframe;\r\nstruct sockaddr_can *addr;\r\nstruct sock *sk = op->sk;\r\nunsigned int datalen = head->nframes * CFSIZ;\r\nint err;\r\nskb = alloc_skb(sizeof(*head) + datalen, gfp_any());\r\nif (!skb)\r\nreturn;\r\nmemcpy(skb_put(skb, sizeof(*head)), head, sizeof(*head));\r\nif (head->nframes) {\r\nfirstframe = (struct can_frame *)skb_tail_pointer(skb);\r\nmemcpy(skb_put(skb, datalen), frames, datalen);\r\nif (head->nframes == 1)\r\nfirstframe->can_dlc &= BCM_CAN_DLC_MASK;\r\n}\r\nif (has_timestamp) {\r\nskb->tstamp = op->rx_stamp;\r\n}\r\nBUILD_BUG_ON(sizeof(skb->cb) < sizeof(struct sockaddr_can));\r\naddr = (struct sockaddr_can *)skb->cb;\r\nmemset(addr, 0, sizeof(*addr));\r\naddr->can_family = AF_CAN;\r\naddr->can_ifindex = op->rx_ifindex;\r\nerr = sock_queue_rcv_skb(sk, skb);\r\nif (err < 0) {\r\nstruct bcm_sock *bo = bcm_sk(sk);\r\nkfree_skb(skb);\r\nbo->dropped_usr_msgs++;\r\n}\r\n}\r\nstatic void bcm_tx_start_timer(struct bcm_op *op)\r\n{\r\nif (op->kt_ival1.tv64 && op->count)\r\nhrtimer_start(&op->timer,\r\nktime_add(ktime_get(), op->kt_ival1),\r\nHRTIMER_MODE_ABS);\r\nelse if (op->kt_ival2.tv64)\r\nhrtimer_start(&op->timer,\r\nktime_add(ktime_get(), op->kt_ival2),\r\nHRTIMER_MODE_ABS);\r\n}\r\nstatic void bcm_tx_timeout_tsklet(unsigned long data)\r\n{\r\nstruct bcm_op *op = (struct bcm_op *)data;\r\nstruct bcm_msg_head msg_head;\r\nif (op->kt_ival1.tv64 && (op->count > 0)) {\r\nop->count--;\r\nif (!op->count && (op->flags & TX_COUNTEVT)) {\r\nmsg_head.opcode = TX_EXPIRED;\r\nmsg_head.flags = op->flags;\r\nmsg_head.count = op->count;\r\nmsg_head.ival1 = op->ival1;\r\nmsg_head.ival2 = op->ival2;\r\nmsg_head.can_id = op->can_id;\r\nmsg_head.nframes = 0;\r\nbcm_send_to_user(op, &msg_head, NULL, 0);\r\n}\r\nbcm_can_tx(op);\r\n} else if (op->kt_ival2.tv64)\r\nbcm_can_tx(op);\r\nbcm_tx_start_timer(op);\r\n}\r\nstatic enum hrtimer_restart bcm_tx_timeout_handler(struct hrtimer *hrtimer)\r\n{\r\nstruct bcm_op *op = container_of(hrtimer, struct bcm_op, timer);\r\ntasklet_schedule(&op->tsklet);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic void bcm_rx_changed(struct bcm_op *op, struct can_frame *data)\r\n{\r\nstruct bcm_msg_head head;\r\nop->frames_filtered++;\r\nif (op->frames_filtered > ULONG_MAX/100)\r\nop->frames_filtered = op->frames_abs = 0;\r\ndata->can_dlc &= (BCM_CAN_DLC_MASK|RX_RECV);\r\nhead.opcode = RX_CHANGED;\r\nhead.flags = op->flags;\r\nhead.count = op->count;\r\nhead.ival1 = op->ival1;\r\nhead.ival2 = op->ival2;\r\nhead.can_id = op->can_id;\r\nhead.nframes = 1;\r\nbcm_send_to_user(op, &head, data, 1);\r\n}\r\nstatic void bcm_rx_update_and_send(struct bcm_op *op,\r\nstruct can_frame *lastdata,\r\nconst struct can_frame *rxdata)\r\n{\r\nmemcpy(lastdata, rxdata, CFSIZ);\r\nlastdata->can_dlc |= (RX_RECV|RX_THR);\r\nif (!op->kt_ival2.tv64) {\r\nbcm_rx_changed(op, lastdata);\r\nreturn;\r\n}\r\nif (hrtimer_active(&op->thrtimer))\r\nreturn;\r\nif (!op->kt_lastmsg.tv64)\r\ngoto rx_changed_settime;\r\nif (ktime_us_delta(ktime_get(), op->kt_lastmsg) <\r\nktime_to_us(op->kt_ival2)) {\r\nhrtimer_start(&op->thrtimer,\r\nktime_add(op->kt_lastmsg, op->kt_ival2),\r\nHRTIMER_MODE_ABS);\r\nreturn;\r\n}\r\nrx_changed_settime:\r\nbcm_rx_changed(op, lastdata);\r\nop->kt_lastmsg = ktime_get();\r\n}\r\nstatic void bcm_rx_cmp_to_index(struct bcm_op *op, unsigned int index,\r\nconst struct can_frame *rxdata)\r\n{\r\nif (!(op->last_frames[index].can_dlc & RX_RECV)) {\r\nbcm_rx_update_and_send(op, &op->last_frames[index], rxdata);\r\nreturn;\r\n}\r\nif ((GET_U64(&op->frames[index]) & GET_U64(rxdata)) !=\r\n(GET_U64(&op->frames[index]) & GET_U64(&op->last_frames[index]))) {\r\nbcm_rx_update_and_send(op, &op->last_frames[index], rxdata);\r\nreturn;\r\n}\r\nif (op->flags & RX_CHECK_DLC) {\r\nif (rxdata->can_dlc != (op->last_frames[index].can_dlc &\r\nBCM_CAN_DLC_MASK)) {\r\nbcm_rx_update_and_send(op, &op->last_frames[index],\r\nrxdata);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void bcm_rx_starttimer(struct bcm_op *op)\r\n{\r\nif (op->flags & RX_NO_AUTOTIMER)\r\nreturn;\r\nif (op->kt_ival1.tv64)\r\nhrtimer_start(&op->timer, op->kt_ival1, HRTIMER_MODE_REL);\r\n}\r\nstatic void bcm_rx_timeout_tsklet(unsigned long data)\r\n{\r\nstruct bcm_op *op = (struct bcm_op *)data;\r\nstruct bcm_msg_head msg_head;\r\nmsg_head.opcode = RX_TIMEOUT;\r\nmsg_head.flags = op->flags;\r\nmsg_head.count = op->count;\r\nmsg_head.ival1 = op->ival1;\r\nmsg_head.ival2 = op->ival2;\r\nmsg_head.can_id = op->can_id;\r\nmsg_head.nframes = 0;\r\nbcm_send_to_user(op, &msg_head, NULL, 0);\r\n}\r\nstatic enum hrtimer_restart bcm_rx_timeout_handler(struct hrtimer *hrtimer)\r\n{\r\nstruct bcm_op *op = container_of(hrtimer, struct bcm_op, timer);\r\ntasklet_hi_schedule(&op->tsklet);\r\nif ((op->flags & RX_ANNOUNCE_RESUME) && op->last_frames) {\r\nmemset(op->last_frames, 0, op->nframes * CFSIZ);\r\n}\r\nreturn HRTIMER_NORESTART;\r\n}\r\nstatic inline int bcm_rx_do_flush(struct bcm_op *op, int update,\r\nunsigned int index)\r\n{\r\nif ((op->last_frames) && (op->last_frames[index].can_dlc & RX_THR)) {\r\nif (update)\r\nbcm_rx_changed(op, &op->last_frames[index]);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_rx_thr_flush(struct bcm_op *op, int update)\r\n{\r\nint updated = 0;\r\nif (op->nframes > 1) {\r\nunsigned int i;\r\nfor (i = 1; i < op->nframes; i++)\r\nupdated += bcm_rx_do_flush(op, update, i);\r\n} else {\r\nupdated += bcm_rx_do_flush(op, update, 0);\r\n}\r\nreturn updated;\r\n}\r\nstatic void bcm_rx_thr_tsklet(unsigned long data)\r\n{\r\nstruct bcm_op *op = (struct bcm_op *)data;\r\nbcm_rx_thr_flush(op, 1);\r\n}\r\nstatic enum hrtimer_restart bcm_rx_thr_handler(struct hrtimer *hrtimer)\r\n{\r\nstruct bcm_op *op = container_of(hrtimer, struct bcm_op, thrtimer);\r\ntasklet_schedule(&op->thrtsklet);\r\nif (bcm_rx_thr_flush(op, 0)) {\r\nhrtimer_forward(hrtimer, ktime_get(), op->kt_ival2);\r\nreturn HRTIMER_RESTART;\r\n} else {\r\nop->kt_lastmsg = ktime_set(0, 0);\r\nreturn HRTIMER_NORESTART;\r\n}\r\n}\r\nstatic void bcm_rx_handler(struct sk_buff *skb, void *data)\r\n{\r\nstruct bcm_op *op = (struct bcm_op *)data;\r\nconst struct can_frame *rxframe = (struct can_frame *)skb->data;\r\nunsigned int i;\r\nhrtimer_cancel(&op->timer);\r\nif (op->can_id != rxframe->can_id)\r\nreturn;\r\nop->rx_stamp = skb->tstamp;\r\nop->rx_ifindex = skb->dev->ifindex;\r\nop->frames_abs++;\r\nif (op->flags & RX_RTR_FRAME) {\r\nbcm_can_tx(op);\r\nreturn;\r\n}\r\nif (op->flags & RX_FILTER_ID) {\r\nbcm_rx_update_and_send(op, &op->last_frames[0], rxframe);\r\ngoto rx_starttimer;\r\n}\r\nif (op->nframes == 1) {\r\nbcm_rx_cmp_to_index(op, 0, rxframe);\r\ngoto rx_starttimer;\r\n}\r\nif (op->nframes > 1) {\r\nfor (i = 1; i < op->nframes; i++) {\r\nif ((GET_U64(&op->frames[0]) & GET_U64(rxframe)) ==\r\n(GET_U64(&op->frames[0]) &\r\nGET_U64(&op->frames[i]))) {\r\nbcm_rx_cmp_to_index(op, i, rxframe);\r\nbreak;\r\n}\r\n}\r\n}\r\nrx_starttimer:\r\nbcm_rx_starttimer(op);\r\n}\r\nstatic struct bcm_op *bcm_find_op(struct list_head *ops, canid_t can_id,\r\nint ifindex)\r\n{\r\nstruct bcm_op *op;\r\nlist_for_each_entry(op, ops, list) {\r\nif ((op->can_id == can_id) && (op->ifindex == ifindex))\r\nreturn op;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void bcm_remove_op(struct bcm_op *op)\r\n{\r\nhrtimer_cancel(&op->timer);\r\nhrtimer_cancel(&op->thrtimer);\r\nif (op->tsklet.func)\r\ntasklet_kill(&op->tsklet);\r\nif (op->thrtsklet.func)\r\ntasklet_kill(&op->thrtsklet);\r\nif ((op->frames) && (op->frames != &op->sframe))\r\nkfree(op->frames);\r\nif ((op->last_frames) && (op->last_frames != &op->last_sframe))\r\nkfree(op->last_frames);\r\nkfree(op);\r\n}\r\nstatic void bcm_rx_unreg(struct net_device *dev, struct bcm_op *op)\r\n{\r\nif (op->rx_reg_dev == dev) {\r\ncan_rx_unregister(dev, op->can_id, REGMASK(op->can_id),\r\nbcm_rx_handler, op);\r\nop->rx_reg_dev = NULL;\r\n} else\r\nprintk(KERN_ERR "can-bcm: bcm_rx_unreg: registered device "\r\n"mismatch %p %p\n", op->rx_reg_dev, dev);\r\n}\r\nstatic int bcm_delete_rx_op(struct list_head *ops, canid_t can_id, int ifindex)\r\n{\r\nstruct bcm_op *op, *n;\r\nlist_for_each_entry_safe(op, n, ops, list) {\r\nif ((op->can_id == can_id) && (op->ifindex == ifindex)) {\r\nif (op->ifindex) {\r\nif (op->rx_reg_dev) {\r\nstruct net_device *dev;\r\ndev = dev_get_by_index(&init_net,\r\nop->ifindex);\r\nif (dev) {\r\nbcm_rx_unreg(dev, op);\r\ndev_put(dev);\r\n}\r\n}\r\n} else\r\ncan_rx_unregister(NULL, op->can_id,\r\nREGMASK(op->can_id),\r\nbcm_rx_handler, op);\r\nlist_del(&op->list);\r\nbcm_remove_op(op);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_delete_tx_op(struct list_head *ops, canid_t can_id, int ifindex)\r\n{\r\nstruct bcm_op *op, *n;\r\nlist_for_each_entry_safe(op, n, ops, list) {\r\nif ((op->can_id == can_id) && (op->ifindex == ifindex)) {\r\nlist_del(&op->list);\r\nbcm_remove_op(op);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_read_op(struct list_head *ops, struct bcm_msg_head *msg_head,\r\nint ifindex)\r\n{\r\nstruct bcm_op *op = bcm_find_op(ops, msg_head->can_id, ifindex);\r\nif (!op)\r\nreturn -EINVAL;\r\nmsg_head->flags = op->flags;\r\nmsg_head->count = op->count;\r\nmsg_head->ival1 = op->ival1;\r\nmsg_head->ival2 = op->ival2;\r\nmsg_head->nframes = op->nframes;\r\nbcm_send_to_user(op, msg_head, op->frames, 0);\r\nreturn MHSIZ;\r\n}\r\nstatic int bcm_tx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,\r\nint ifindex, struct sock *sk)\r\n{\r\nstruct bcm_sock *bo = bcm_sk(sk);\r\nstruct bcm_op *op;\r\nunsigned int i;\r\nint err;\r\nif (!ifindex)\r\nreturn -ENODEV;\r\nif (msg_head->nframes < 1 || msg_head->nframes > MAX_NFRAMES)\r\nreturn -EINVAL;\r\nop = bcm_find_op(&bo->tx_ops, msg_head->can_id, ifindex);\r\nif (op) {\r\nif (msg_head->nframes > op->nframes)\r\nreturn -E2BIG;\r\nfor (i = 0; i < msg_head->nframes; i++) {\r\nerr = memcpy_from_msg((u8 *)&op->frames[i], msg, CFSIZ);\r\nif (op->frames[i].can_dlc > 8)\r\nerr = -EINVAL;\r\nif (err < 0)\r\nreturn err;\r\nif (msg_head->flags & TX_CP_CAN_ID) {\r\nop->frames[i].can_id = msg_head->can_id;\r\n}\r\n}\r\n} else {\r\nop = kzalloc(OPSIZ, GFP_KERNEL);\r\nif (!op)\r\nreturn -ENOMEM;\r\nop->can_id = msg_head->can_id;\r\nif (msg_head->nframes > 1) {\r\nop->frames = kmalloc(msg_head->nframes * CFSIZ,\r\nGFP_KERNEL);\r\nif (!op->frames) {\r\nkfree(op);\r\nreturn -ENOMEM;\r\n}\r\n} else\r\nop->frames = &op->sframe;\r\nfor (i = 0; i < msg_head->nframes; i++) {\r\nerr = memcpy_from_msg((u8 *)&op->frames[i], msg, CFSIZ);\r\nif (op->frames[i].can_dlc > 8)\r\nerr = -EINVAL;\r\nif (err < 0) {\r\nif (op->frames != &op->sframe)\r\nkfree(op->frames);\r\nkfree(op);\r\nreturn err;\r\n}\r\nif (msg_head->flags & TX_CP_CAN_ID) {\r\nop->frames[i].can_id = msg_head->can_id;\r\n}\r\n}\r\nop->last_frames = NULL;\r\nop->sk = sk;\r\nop->ifindex = ifindex;\r\nhrtimer_init(&op->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\r\nop->timer.function = bcm_tx_timeout_handler;\r\ntasklet_init(&op->tsklet, bcm_tx_timeout_tsklet,\r\n(unsigned long) op);\r\nhrtimer_init(&op->thrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\r\nlist_add(&op->list, &bo->tx_ops);\r\n}\r\nif (op->nframes != msg_head->nframes) {\r\nop->nframes = msg_head->nframes;\r\nop->currframe = 0;\r\n}\r\nop->flags = msg_head->flags;\r\nif (op->flags & TX_RESET_MULTI_IDX) {\r\nop->currframe = 0;\r\n}\r\nif (op->flags & SETTIMER) {\r\nop->count = msg_head->count;\r\nop->ival1 = msg_head->ival1;\r\nop->ival2 = msg_head->ival2;\r\nop->kt_ival1 = timeval_to_ktime(msg_head->ival1);\r\nop->kt_ival2 = timeval_to_ktime(msg_head->ival2);\r\nif (!op->kt_ival1.tv64 && !op->kt_ival2.tv64)\r\nhrtimer_cancel(&op->timer);\r\n}\r\nif (op->flags & STARTTIMER) {\r\nhrtimer_cancel(&op->timer);\r\nop->flags |= TX_ANNOUNCE;\r\n}\r\nif (op->flags & TX_ANNOUNCE) {\r\nbcm_can_tx(op);\r\nif (op->count)\r\nop->count--;\r\n}\r\nif (op->flags & STARTTIMER)\r\nbcm_tx_start_timer(op);\r\nreturn msg_head->nframes * CFSIZ + MHSIZ;\r\n}\r\nstatic int bcm_rx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,\r\nint ifindex, struct sock *sk)\r\n{\r\nstruct bcm_sock *bo = bcm_sk(sk);\r\nstruct bcm_op *op;\r\nint do_rx_register;\r\nint err = 0;\r\nif ((msg_head->flags & RX_FILTER_ID) || (!(msg_head->nframes))) {\r\nmsg_head->flags |= RX_FILTER_ID;\r\nmsg_head->nframes = 0;\r\n}\r\nif (msg_head->nframes > MAX_NFRAMES + 1)\r\nreturn -EINVAL;\r\nif ((msg_head->flags & RX_RTR_FRAME) &&\r\n((msg_head->nframes != 1) ||\r\n(!(msg_head->can_id & CAN_RTR_FLAG))))\r\nreturn -EINVAL;\r\nop = bcm_find_op(&bo->rx_ops, msg_head->can_id, ifindex);\r\nif (op) {\r\nif (msg_head->nframes > op->nframes)\r\nreturn -E2BIG;\r\nif (msg_head->nframes) {\r\nerr = memcpy_from_msg((u8 *)op->frames, msg,\r\nmsg_head->nframes * CFSIZ);\r\nif (err < 0)\r\nreturn err;\r\nmemset(op->last_frames, 0, msg_head->nframes * CFSIZ);\r\n}\r\nop->nframes = msg_head->nframes;\r\ndo_rx_register = 0;\r\n} else {\r\nop = kzalloc(OPSIZ, GFP_KERNEL);\r\nif (!op)\r\nreturn -ENOMEM;\r\nop->can_id = msg_head->can_id;\r\nop->nframes = msg_head->nframes;\r\nif (msg_head->nframes > 1) {\r\nop->frames = kmalloc(msg_head->nframes * CFSIZ,\r\nGFP_KERNEL);\r\nif (!op->frames) {\r\nkfree(op);\r\nreturn -ENOMEM;\r\n}\r\nop->last_frames = kzalloc(msg_head->nframes * CFSIZ,\r\nGFP_KERNEL);\r\nif (!op->last_frames) {\r\nkfree(op->frames);\r\nkfree(op);\r\nreturn -ENOMEM;\r\n}\r\n} else {\r\nop->frames = &op->sframe;\r\nop->last_frames = &op->last_sframe;\r\n}\r\nif (msg_head->nframes) {\r\nerr = memcpy_from_msg((u8 *)op->frames, msg,\r\nmsg_head->nframes * CFSIZ);\r\nif (err < 0) {\r\nif (op->frames != &op->sframe)\r\nkfree(op->frames);\r\nif (op->last_frames != &op->last_sframe)\r\nkfree(op->last_frames);\r\nkfree(op);\r\nreturn err;\r\n}\r\n}\r\nop->sk = sk;\r\nop->ifindex = ifindex;\r\nop->rx_ifindex = ifindex;\r\nhrtimer_init(&op->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\r\nop->timer.function = bcm_rx_timeout_handler;\r\ntasklet_init(&op->tsklet, bcm_rx_timeout_tsklet,\r\n(unsigned long) op);\r\nhrtimer_init(&op->thrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\r\nop->thrtimer.function = bcm_rx_thr_handler;\r\ntasklet_init(&op->thrtsklet, bcm_rx_thr_tsklet,\r\n(unsigned long) op);\r\nlist_add(&op->list, &bo->rx_ops);\r\ndo_rx_register = 1;\r\n}\r\nop->flags = msg_head->flags;\r\nif (op->flags & RX_RTR_FRAME) {\r\nhrtimer_cancel(&op->thrtimer);\r\nhrtimer_cancel(&op->timer);\r\nif ((op->flags & TX_CP_CAN_ID) ||\r\n(op->frames[0].can_id == op->can_id))\r\nop->frames[0].can_id = op->can_id & ~CAN_RTR_FLAG;\r\n} else {\r\nif (op->flags & SETTIMER) {\r\nop->ival1 = msg_head->ival1;\r\nop->ival2 = msg_head->ival2;\r\nop->kt_ival1 = timeval_to_ktime(msg_head->ival1);\r\nop->kt_ival2 = timeval_to_ktime(msg_head->ival2);\r\nif (!op->kt_ival1.tv64)\r\nhrtimer_cancel(&op->timer);\r\nop->kt_lastmsg = ktime_set(0, 0);\r\nhrtimer_cancel(&op->thrtimer);\r\nbcm_rx_thr_flush(op, 1);\r\n}\r\nif ((op->flags & STARTTIMER) && op->kt_ival1.tv64)\r\nhrtimer_start(&op->timer, op->kt_ival1,\r\nHRTIMER_MODE_REL);\r\n}\r\nif (do_rx_register) {\r\nif (ifindex) {\r\nstruct net_device *dev;\r\ndev = dev_get_by_index(&init_net, ifindex);\r\nif (dev) {\r\nerr = can_rx_register(dev, op->can_id,\r\nREGMASK(op->can_id),\r\nbcm_rx_handler, op,\r\n"bcm");\r\nop->rx_reg_dev = dev;\r\ndev_put(dev);\r\n}\r\n} else\r\nerr = can_rx_register(NULL, op->can_id,\r\nREGMASK(op->can_id),\r\nbcm_rx_handler, op, "bcm");\r\nif (err) {\r\nlist_del(&op->list);\r\nbcm_remove_op(op);\r\nreturn err;\r\n}\r\n}\r\nreturn msg_head->nframes * CFSIZ + MHSIZ;\r\n}\r\nstatic int bcm_tx_send(struct msghdr *msg, int ifindex, struct sock *sk)\r\n{\r\nstruct sk_buff *skb;\r\nstruct net_device *dev;\r\nint err;\r\nif (!ifindex)\r\nreturn -ENODEV;\r\nskb = alloc_skb(CFSIZ + sizeof(struct can_skb_priv), GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\ncan_skb_reserve(skb);\r\nerr = memcpy_from_msg(skb_put(skb, CFSIZ), msg, CFSIZ);\r\nif (err < 0) {\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\ndev = dev_get_by_index(&init_net, ifindex);\r\nif (!dev) {\r\nkfree_skb(skb);\r\nreturn -ENODEV;\r\n}\r\ncan_skb_prv(skb)->ifindex = dev->ifindex;\r\nskb->dev = dev;\r\ncan_skb_set_owner(skb, sk);\r\nerr = can_send(skb, 1);\r\ndev_put(dev);\r\nif (err)\r\nreturn err;\r\nreturn CFSIZ + MHSIZ;\r\n}\r\nstatic int bcm_sendmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t size)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct bcm_sock *bo = bcm_sk(sk);\r\nint ifindex = bo->ifindex;\r\nstruct bcm_msg_head msg_head;\r\nint ret;\r\nif (!bo->bound)\r\nreturn -ENOTCONN;\r\nif (size < MHSIZ || (size - MHSIZ) % CFSIZ)\r\nreturn -EINVAL;\r\nif (!ifindex && msg->msg_name) {\r\nDECLARE_SOCKADDR(struct sockaddr_can *, addr, msg->msg_name);\r\nif (msg->msg_namelen < sizeof(*addr))\r\nreturn -EINVAL;\r\nif (addr->can_family != AF_CAN)\r\nreturn -EINVAL;\r\nifindex = addr->can_ifindex;\r\nif (ifindex) {\r\nstruct net_device *dev;\r\ndev = dev_get_by_index(&init_net, ifindex);\r\nif (!dev)\r\nreturn -ENODEV;\r\nif (dev->type != ARPHRD_CAN) {\r\ndev_put(dev);\r\nreturn -ENODEV;\r\n}\r\ndev_put(dev);\r\n}\r\n}\r\nret = memcpy_from_msg((u8 *)&msg_head, msg, MHSIZ);\r\nif (ret < 0)\r\nreturn ret;\r\nlock_sock(sk);\r\nswitch (msg_head.opcode) {\r\ncase TX_SETUP:\r\nret = bcm_tx_setup(&msg_head, msg, ifindex, sk);\r\nbreak;\r\ncase RX_SETUP:\r\nret = bcm_rx_setup(&msg_head, msg, ifindex, sk);\r\nbreak;\r\ncase TX_DELETE:\r\nif (bcm_delete_tx_op(&bo->tx_ops, msg_head.can_id, ifindex))\r\nret = MHSIZ;\r\nelse\r\nret = -EINVAL;\r\nbreak;\r\ncase RX_DELETE:\r\nif (bcm_delete_rx_op(&bo->rx_ops, msg_head.can_id, ifindex))\r\nret = MHSIZ;\r\nelse\r\nret = -EINVAL;\r\nbreak;\r\ncase TX_READ:\r\nmsg_head.opcode = TX_STATUS;\r\nret = bcm_read_op(&bo->tx_ops, &msg_head, ifindex);\r\nbreak;\r\ncase RX_READ:\r\nmsg_head.opcode = RX_STATUS;\r\nret = bcm_read_op(&bo->rx_ops, &msg_head, ifindex);\r\nbreak;\r\ncase TX_SEND:\r\nif ((msg_head.nframes != 1) || (size != CFSIZ + MHSIZ))\r\nret = -EINVAL;\r\nelse\r\nret = bcm_tx_send(msg, ifindex, sk);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nrelease_sock(sk);\r\nreturn ret;\r\n}\r\nstatic int bcm_notifier(struct notifier_block *nb, unsigned long msg,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct bcm_sock *bo = container_of(nb, struct bcm_sock, notifier);\r\nstruct sock *sk = &bo->sk;\r\nstruct bcm_op *op;\r\nint notify_enodev = 0;\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nif (dev->type != ARPHRD_CAN)\r\nreturn NOTIFY_DONE;\r\nswitch (msg) {\r\ncase NETDEV_UNREGISTER:\r\nlock_sock(sk);\r\nlist_for_each_entry(op, &bo->rx_ops, list)\r\nif (op->rx_reg_dev == dev)\r\nbcm_rx_unreg(dev, op);\r\nif (bo->bound && bo->ifindex == dev->ifindex) {\r\nbo->bound = 0;\r\nbo->ifindex = 0;\r\nnotify_enodev = 1;\r\n}\r\nrelease_sock(sk);\r\nif (notify_enodev) {\r\nsk->sk_err = ENODEV;\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_error_report(sk);\r\n}\r\nbreak;\r\ncase NETDEV_DOWN:\r\nif (bo->bound && bo->ifindex == dev->ifindex) {\r\nsk->sk_err = ENETDOWN;\r\nif (!sock_flag(sk, SOCK_DEAD))\r\nsk->sk_error_report(sk);\r\n}\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int bcm_init(struct sock *sk)\r\n{\r\nstruct bcm_sock *bo = bcm_sk(sk);\r\nbo->bound = 0;\r\nbo->ifindex = 0;\r\nbo->dropped_usr_msgs = 0;\r\nbo->bcm_proc_read = NULL;\r\nINIT_LIST_HEAD(&bo->tx_ops);\r\nINIT_LIST_HEAD(&bo->rx_ops);\r\nbo->notifier.notifier_call = bcm_notifier;\r\nregister_netdevice_notifier(&bo->notifier);\r\nreturn 0;\r\n}\r\nstatic int bcm_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct bcm_sock *bo;\r\nstruct bcm_op *op, *next;\r\nif (sk == NULL)\r\nreturn 0;\r\nbo = bcm_sk(sk);\r\nunregister_netdevice_notifier(&bo->notifier);\r\nlock_sock(sk);\r\nlist_for_each_entry_safe(op, next, &bo->tx_ops, list)\r\nbcm_remove_op(op);\r\nlist_for_each_entry_safe(op, next, &bo->rx_ops, list) {\r\nif (op->ifindex) {\r\nif (op->rx_reg_dev) {\r\nstruct net_device *dev;\r\ndev = dev_get_by_index(&init_net, op->ifindex);\r\nif (dev) {\r\nbcm_rx_unreg(dev, op);\r\ndev_put(dev);\r\n}\r\n}\r\n} else\r\ncan_rx_unregister(NULL, op->can_id,\r\nREGMASK(op->can_id),\r\nbcm_rx_handler, op);\r\nbcm_remove_op(op);\r\n}\r\nif (proc_dir && bo->bcm_proc_read)\r\nremove_proc_entry(bo->procname, proc_dir);\r\nif (bo->bound) {\r\nbo->bound = 0;\r\nbo->ifindex = 0;\r\n}\r\nsock_orphan(sk);\r\nsock->sk = NULL;\r\nrelease_sock(sk);\r\nsock_put(sk);\r\nreturn 0;\r\n}\r\nstatic int bcm_connect(struct socket *sock, struct sockaddr *uaddr, int len,\r\nint flags)\r\n{\r\nstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\r\nstruct sock *sk = sock->sk;\r\nstruct bcm_sock *bo = bcm_sk(sk);\r\nif (len < sizeof(*addr))\r\nreturn -EINVAL;\r\nif (bo->bound)\r\nreturn -EISCONN;\r\nif (addr->can_ifindex) {\r\nstruct net_device *dev;\r\ndev = dev_get_by_index(&init_net, addr->can_ifindex);\r\nif (!dev)\r\nreturn -ENODEV;\r\nif (dev->type != ARPHRD_CAN) {\r\ndev_put(dev);\r\nreturn -ENODEV;\r\n}\r\nbo->ifindex = dev->ifindex;\r\ndev_put(dev);\r\n} else {\r\nbo->ifindex = 0;\r\n}\r\nbo->bound = 1;\r\nif (proc_dir) {\r\nsprintf(bo->procname, "%lu", sock_i_ino(sk));\r\nbo->bcm_proc_read = proc_create_data(bo->procname, 0644,\r\nproc_dir,\r\n&bcm_proc_fops, sk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_recvmsg(struct kiocb *iocb, struct socket *sock,\r\nstruct msghdr *msg, size_t size, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sk_buff *skb;\r\nint error = 0;\r\nint noblock;\r\nint err;\r\nnoblock = flags & MSG_DONTWAIT;\r\nflags &= ~MSG_DONTWAIT;\r\nskb = skb_recv_datagram(sk, flags, noblock, &error);\r\nif (!skb)\r\nreturn error;\r\nif (skb->len < size)\r\nsize = skb->len;\r\nerr = memcpy_to_msg(msg, skb->data, size);\r\nif (err < 0) {\r\nskb_free_datagram(sk, skb);\r\nreturn err;\r\n}\r\nsock_recv_ts_and_drops(msg, sk, skb);\r\nif (msg->msg_name) {\r\n__sockaddr_check_size(sizeof(struct sockaddr_can));\r\nmsg->msg_namelen = sizeof(struct sockaddr_can);\r\nmemcpy(msg->msg_name, skb->cb, msg->msg_namelen);\r\n}\r\nskb_free_datagram(sk, skb);\r\nreturn size;\r\n}\r\nstatic int __init bcm_module_init(void)\r\n{\r\nint err;\r\npr_info("can: broadcast manager protocol (rev " CAN_BCM_VERSION " t)\n");\r\nerr = can_proto_register(&bcm_can_proto);\r\nif (err < 0) {\r\nprintk(KERN_ERR "can: registration of bcm protocol failed\n");\r\nreturn err;\r\n}\r\nproc_dir = proc_mkdir("can-bcm", init_net.proc_net);\r\nreturn 0;\r\n}\r\nstatic void __exit bcm_module_exit(void)\r\n{\r\ncan_proto_unregister(&bcm_can_proto);\r\nif (proc_dir)\r\nremove_proc_entry("can-bcm", init_net.proc_net);\r\n}
