static int au8522_mse2snr_lookup(struct mse2snr_tab *tab, int sz, int mse,\r\nu16 *snr)\r\n{\r\nint i, ret = -EINVAL;\r\ndprintk("%s()\n", __func__);\r\nfor (i = 0; i < sz; i++) {\r\nif (mse < tab[i].val) {\r\n*snr = tab[i].data;\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\ndprintk("%s() snr=%d\n", __func__, *snr);\r\nreturn ret;\r\n}\r\nstatic int au8522_set_if(struct dvb_frontend *fe, enum au8522_if_freq if_freq)\r\n{\r\nstruct au8522_state *state = fe->demodulator_priv;\r\nu8 r0b5, r0b6, r0b7;\r\nchar *ifmhz;\r\nswitch (if_freq) {\r\ncase AU8522_IF_3_25MHZ:\r\nifmhz = "3.25";\r\nr0b5 = 0x00;\r\nr0b6 = 0x3d;\r\nr0b7 = 0xa0;\r\nbreak;\r\ncase AU8522_IF_4MHZ:\r\nifmhz = "4.00";\r\nr0b5 = 0x00;\r\nr0b6 = 0x4b;\r\nr0b7 = 0xd9;\r\nbreak;\r\ncase AU8522_IF_6MHZ:\r\nifmhz = "6.00";\r\nr0b5 = 0xfb;\r\nr0b6 = 0x8e;\r\nr0b7 = 0x39;\r\nbreak;\r\ndefault:\r\ndprintk("%s() IF Frequency not supported\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ndprintk("%s() %s MHz\n", __func__, ifmhz);\r\nau8522_writereg(state, 0x80b5, r0b5);\r\nau8522_writereg(state, 0x80b6, r0b6);\r\nau8522_writereg(state, 0x80b7, r0b7);\r\nreturn 0;\r\n}\r\nstatic int au8522_enable_modulation(struct dvb_frontend *fe,\r\nfe_modulation_t m)\r\n{\r\nstruct au8522_state *state = fe->demodulator_priv;\r\nint i;\r\ndprintk("%s(0x%08x)\n", __func__, m);\r\nswitch (m) {\r\ncase VSB_8:\r\ndprintk("%s() VSB_8\n", __func__);\r\nfor (i = 0; i < ARRAY_SIZE(VSB_mod_tab); i++)\r\nau8522_writereg(state,\r\nVSB_mod_tab[i].reg,\r\nVSB_mod_tab[i].data);\r\nau8522_set_if(fe, state->config->vsb_if);\r\nbreak;\r\ncase QAM_64:\r\ndprintk("%s() QAM 64\n", __func__);\r\nfor (i = 0; i < ARRAY_SIZE(QAM64_mod_tab); i++)\r\nau8522_writereg(state,\r\nQAM64_mod_tab[i].reg,\r\nQAM64_mod_tab[i].data);\r\nau8522_set_if(fe, state->config->qam_if);\r\nbreak;\r\ncase QAM_256:\r\nif (zv_mode) {\r\ndprintk("%s() QAM 256 (zv_mode)\n", __func__);\r\nfor (i = 0; i < ARRAY_SIZE(QAM256_mod_tab_zv_mode); i++)\r\nau8522_writereg(state,\r\nQAM256_mod_tab_zv_mode[i].reg,\r\nQAM256_mod_tab_zv_mode[i].data);\r\nau8522_set_if(fe, state->config->qam_if);\r\nmsleep(100);\r\nau8522_writereg(state, 0x821a, 0x00);\r\n} else {\r\ndprintk("%s() QAM 256\n", __func__);\r\nfor (i = 0; i < ARRAY_SIZE(QAM256_mod_tab); i++)\r\nau8522_writereg(state,\r\nQAM256_mod_tab[i].reg,\r\nQAM256_mod_tab[i].data);\r\nau8522_set_if(fe, state->config->qam_if);\r\n}\r\nbreak;\r\ndefault:\r\ndprintk("%s() Invalid modulation\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nstate->current_modulation = m;\r\nreturn 0;\r\n}\r\nstatic int au8522_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct au8522_state *state = fe->demodulator_priv;\r\nint ret = -EINVAL;\r\ndprintk("%s(frequency=%d)\n", __func__, c->frequency);\r\nif ((state->current_frequency == c->frequency) &&\r\n(state->current_modulation == c->modulation))\r\nreturn 0;\r\nif (fe->ops.tuner_ops.set_params) {\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = fe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nif (zv_mode) {\r\ndprintk("%s() increase tuner settling time for zv_mode\n",\r\n__func__);\r\nmsleep(250);\r\n} else\r\nmsleep(100);\r\nau8522_enable_modulation(fe, c->modulation);\r\nstate->current_frequency = c->frequency;\r\nreturn 0;\r\n}\r\nstatic int au8522_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct au8522_state *state = fe->demodulator_priv;\r\nu8 reg;\r\nu32 tuner_status = 0;\r\n*status = 0;\r\nif (state->current_modulation == VSB_8) {\r\ndprintk("%s() Checking VSB_8\n", __func__);\r\nreg = au8522_readreg(state, 0x4088);\r\nif ((reg & 0x03) == 0x03)\r\n*status |= FE_HAS_LOCK | FE_HAS_SYNC | FE_HAS_VITERBI;\r\n} else {\r\ndprintk("%s() Checking QAM\n", __func__);\r\nreg = au8522_readreg(state, 0x4541);\r\nif (reg & 0x80)\r\n*status |= FE_HAS_VITERBI;\r\nif (reg & 0x20)\r\n*status |= FE_HAS_LOCK | FE_HAS_SYNC;\r\n}\r\nswitch (state->config->status_mode) {\r\ncase AU8522_DEMODLOCKING:\r\ndprintk("%s() DEMODLOCKING\n", __func__);\r\nif (*status & FE_HAS_VITERBI)\r\n*status |= FE_HAS_CARRIER | FE_HAS_SIGNAL;\r\nbreak;\r\ncase AU8522_TUNERLOCKING:\r\ndprintk("%s() TUNERLOCKING\n", __func__);\r\nif (fe->ops.tuner_ops.get_status) {\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nfe->ops.tuner_ops.get_status(fe, &tuner_status);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nif (tuner_status)\r\n*status |= FE_HAS_CARRIER | FE_HAS_SIGNAL;\r\nbreak;\r\n}\r\nstate->fe_status = *status;\r\nif (*status & FE_HAS_LOCK)\r\nau8522_led_ctrl(state, -1);\r\nelse\r\nau8522_led_ctrl(state, 0);\r\ndprintk("%s() status 0x%08x\n", __func__, *status);\r\nreturn 0;\r\n}\r\nstatic int au8522_led_status(struct au8522_state *state, const u16 *snr)\r\n{\r\nstruct au8522_led_config *led_config = state->config->led_cfg;\r\nint led;\r\nu16 strong;\r\nif (!led_config)\r\nreturn 0;\r\nif (0 == (state->fe_status & FE_HAS_LOCK))\r\nreturn au8522_led_ctrl(state, 0);\r\nelse if (state->current_modulation == QAM_256)\r\nstrong = led_config->qam256_strong;\r\nelse if (state->current_modulation == QAM_64)\r\nstrong = led_config->qam64_strong;\r\nelse\r\nstrong = led_config->vsb8_strong;\r\nif (*snr >= strong)\r\nled = 2;\r\nelse\r\nled = 1;\r\nif ((state->led_state) &&\r\n(((strong < *snr) ? (*snr - strong) : (strong - *snr)) <= 10))\r\nreturn 0;\r\nreturn au8522_led_ctrl(state, led);\r\n}\r\nstatic int au8522_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct au8522_state *state = fe->demodulator_priv;\r\nint ret = -EINVAL;\r\ndprintk("%s()\n", __func__);\r\nif (state->current_modulation == QAM_256)\r\nret = au8522_mse2snr_lookup(qam256_mse2snr_tab,\r\nARRAY_SIZE(qam256_mse2snr_tab),\r\nau8522_readreg(state, 0x4522),\r\nsnr);\r\nelse if (state->current_modulation == QAM_64)\r\nret = au8522_mse2snr_lookup(qam64_mse2snr_tab,\r\nARRAY_SIZE(qam64_mse2snr_tab),\r\nau8522_readreg(state, 0x4522),\r\nsnr);\r\nelse\r\nret = au8522_mse2snr_lookup(vsb_mse2snr_tab,\r\nARRAY_SIZE(vsb_mse2snr_tab),\r\nau8522_readreg(state, 0x4311),\r\nsnr);\r\nif (state->config->led_cfg)\r\nau8522_led_status(state, snr);\r\nreturn ret;\r\n}\r\nstatic int au8522_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *signal_strength)\r\n{\r\nu16 snr;\r\nu32 tmp;\r\nint ret = au8522_read_snr(fe, &snr);\r\n*signal_strength = 0;\r\nif (0 == ret) {\r\ntmp = (snr * ((1 << 24) / 10));\r\nif (tmp >= 8960 * 0x10000)\r\n*signal_strength = 0xffff;\r\nelse\r\n*signal_strength = tmp / 8960;\r\n}\r\nreturn ret;\r\n}\r\nstatic int au8522_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct au8522_state *state = fe->demodulator_priv;\r\nif (state->current_modulation == VSB_8)\r\n*ucblocks = au8522_readreg(state, 0x4087);\r\nelse\r\n*ucblocks = au8522_readreg(state, 0x4543);\r\nreturn 0;\r\n}\r\nstatic int au8522_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nreturn au8522_read_ucblocks(fe, ber);\r\n}\r\nstatic int au8522_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct au8522_state *state = fe->demodulator_priv;\r\nc->frequency = state->current_frequency;\r\nc->modulation = state->current_modulation;\r\nreturn 0;\r\n}\r\nstatic int au8522_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 1000;\r\nreturn 0;\r\n}\r\nstatic void au8522_release(struct dvb_frontend *fe)\r\n{\r\nstruct au8522_state *state = fe->demodulator_priv;\r\nau8522_release_state(state);\r\n}\r\nstruct dvb_frontend *au8522_attach(const struct au8522_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct au8522_state *state = NULL;\r\nint instance;\r\ninstance = au8522_get_state(&state, i2c, config->demod_address);\r\nswitch (instance) {\r\ncase 0:\r\ndprintk("%s state allocation failed\n", __func__);\r\nbreak;\r\ncase 1:\r\ndprintk("%s using new instance\n", __func__);\r\nbreak;\r\ndefault:\r\ndprintk("%s using existing instance\n", __func__);\r\nbreak;\r\n}\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->operational_mode = AU8522_DIGITAL_MODE;\r\nmemcpy(&state->frontend.ops, &au8522_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nstate->frontend.ops.analog_ops.i2c_gate_ctrl = au8522_analog_i2c_gate_ctrl;\r\nif (au8522_init(&state->frontend) != 0) {\r\nprintk(KERN_ERR "%s: Failed to initialize correctly\n",\r\n__func__);\r\ngoto error;\r\n}\r\nau8522_i2c_gate_ctrl(&state->frontend, 1);\r\nreturn &state->frontend;\r\nerror:\r\nau8522_release_state(state);\r\nreturn NULL;\r\n}
