static void unpin_worker(struct drm_flip_work *work, void *val)\r\n{\r\nstruct omap_plane *omap_plane =\r\ncontainer_of(work, struct omap_plane, unpin_work);\r\nstruct drm_device *dev = omap_plane->base.dev;\r\nomap_framebuffer_unpin(val);\r\nmutex_lock(&dev->mode_config.mutex);\r\ndrm_framebuffer_unreference(val);\r\nmutex_unlock(&dev->mode_config.mutex);\r\n}\r\nstatic int update_pin(struct drm_plane *plane, struct drm_framebuffer *fb)\r\n{\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nstruct drm_framebuffer *pinned_fb = omap_plane->pinned_fb;\r\nif (pinned_fb != fb) {\r\nint ret = 0;\r\nDBG("%p -> %p", pinned_fb, fb);\r\nif (fb) {\r\ndrm_framebuffer_reference(fb);\r\nret = omap_framebuffer_pin(fb);\r\n}\r\nif (pinned_fb)\r\ndrm_flip_work_queue(&omap_plane->unpin_work, pinned_fb);\r\nif (ret) {\r\ndev_err(plane->dev->dev, "could not swap %p -> %p\n",\r\nomap_plane->pinned_fb, fb);\r\ndrm_framebuffer_unreference(fb);\r\nomap_plane->pinned_fb = NULL;\r\nreturn ret;\r\n}\r\nomap_plane->pinned_fb = fb;\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_plane_pre_apply(struct omap_drm_apply *apply)\r\n{\r\nstruct omap_plane *omap_plane =\r\ncontainer_of(apply, struct omap_plane, apply);\r\nstruct omap_drm_window *win = &omap_plane->win;\r\nstruct drm_plane *plane = &omap_plane->base;\r\nstruct drm_device *dev = plane->dev;\r\nstruct omap_overlay_info *info = &omap_plane->info;\r\nstruct drm_crtc *crtc = plane->crtc;\r\nenum omap_channel channel;\r\nbool enabled = omap_plane->enabled && crtc;\r\nbool ilace, replication;\r\nint ret;\r\nDBG("%s, enabled=%d", omap_plane->name, enabled);\r\nupdate_pin(plane, enabled ? plane->fb : NULL);\r\nif (!enabled) {\r\ndispc_ovl_enable(omap_plane->id, false);\r\nreturn;\r\n}\r\nchannel = omap_crtc_channel(crtc);\r\nomap_framebuffer_update_scanout(plane->fb, win, info);\r\nDBG("%dx%d -> %dx%d (%d)", info->width, info->height,\r\ninfo->out_width, info->out_height,\r\ninfo->screen_width);\r\nDBG("%d,%d %pad %pad", info->pos_x, info->pos_y,\r\n&info->paddr, &info->p_uv_addr);\r\nilace = false;\r\nreplication = false;\r\nret = dispc_ovl_setup(omap_plane->id, info,\r\nreplication, omap_crtc_timings(crtc), false);\r\nif (ret) {\r\ndev_err(dev->dev, "dispc_ovl_setup failed: %d\n", ret);\r\nreturn;\r\n}\r\ndispc_ovl_enable(omap_plane->id, true);\r\ndispc_ovl_set_channel_out(omap_plane->id, channel);\r\n}\r\nstatic void omap_plane_post_apply(struct omap_drm_apply *apply)\r\n{\r\nstruct omap_plane *omap_plane =\r\ncontainer_of(apply, struct omap_plane, apply);\r\nstruct drm_plane *plane = &omap_plane->base;\r\nstruct omap_drm_private *priv = plane->dev->dev_private;\r\nstruct omap_overlay_info *info = &omap_plane->info;\r\nstruct callback cb;\r\ncb = omap_plane->apply_done_cb;\r\nomap_plane->apply_done_cb.fxn = NULL;\r\ndrm_flip_work_commit(&omap_plane->unpin_work, priv->wq);\r\nif (cb.fxn)\r\ncb.fxn(cb.arg);\r\nif (omap_plane->enabled) {\r\nomap_framebuffer_flush(plane->fb, info->pos_x, info->pos_y,\r\ninfo->out_width, info->out_height);\r\n}\r\n}\r\nstatic int apply(struct drm_plane *plane)\r\n{\r\nif (plane->crtc) {\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nreturn omap_crtc_apply(plane->crtc, &omap_plane->apply);\r\n}\r\nreturn 0;\r\n}\r\nint omap_plane_mode_set(struct drm_plane *plane,\r\nstruct drm_crtc *crtc, struct drm_framebuffer *fb,\r\nint crtc_x, int crtc_y,\r\nunsigned int crtc_w, unsigned int crtc_h,\r\nuint32_t src_x, uint32_t src_y,\r\nuint32_t src_w, uint32_t src_h,\r\nvoid (*fxn)(void *), void *arg)\r\n{\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nstruct omap_drm_window *win = &omap_plane->win;\r\nwin->crtc_x = crtc_x;\r\nwin->crtc_y = crtc_y;\r\nwin->crtc_w = crtc_w;\r\nwin->crtc_h = crtc_h;\r\nwin->src_x = src_x >> 16;\r\nwin->src_y = src_y >> 16;\r\nwin->src_w = src_w >> 16;\r\nwin->src_h = src_h >> 16;\r\nif (fxn) {\r\nBUG_ON(omap_plane->apply_done_cb.fxn);\r\nomap_plane->apply_done_cb.fxn = fxn;\r\nomap_plane->apply_done_cb.arg = arg;\r\n}\r\nif (plane->fb)\r\ndrm_framebuffer_unreference(plane->fb);\r\ndrm_framebuffer_reference(fb);\r\nplane->fb = fb;\r\nplane->crtc = crtc;\r\nreturn apply(plane);\r\n}\r\nstatic int omap_plane_update(struct drm_plane *plane,\r\nstruct drm_crtc *crtc, struct drm_framebuffer *fb,\r\nint crtc_x, int crtc_y,\r\nunsigned int crtc_w, unsigned int crtc_h,\r\nuint32_t src_x, uint32_t src_y,\r\nuint32_t src_w, uint32_t src_h)\r\n{\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nomap_plane->enabled = true;\r\nswitch (omap_plane->win.rotation & 0xf) {\r\ncase BIT(DRM_ROTATE_90):\r\ncase BIT(DRM_ROTATE_270):\r\nswap(src_w, src_h);\r\nbreak;\r\n}\r\nreturn omap_plane_mode_set(plane, crtc, fb,\r\ncrtc_x, crtc_y, crtc_w, crtc_h,\r\nsrc_x, src_y, src_w, src_h,\r\nNULL, NULL);\r\n}\r\nstatic int omap_plane_disable(struct drm_plane *plane)\r\n{\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nomap_plane->win.rotation = BIT(DRM_ROTATE_0);\r\nreturn omap_plane_dpms(plane, DRM_MODE_DPMS_OFF);\r\n}\r\nstatic void omap_plane_destroy(struct drm_plane *plane)\r\n{\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nDBG("%s", omap_plane->name);\r\nomap_irq_unregister(plane->dev, &omap_plane->error_irq);\r\nomap_plane_disable(plane);\r\ndrm_plane_cleanup(plane);\r\ndrm_flip_work_cleanup(&omap_plane->unpin_work);\r\nkfree(omap_plane);\r\n}\r\nint omap_plane_dpms(struct drm_plane *plane, int mode)\r\n{\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nbool enabled = (mode == DRM_MODE_DPMS_ON);\r\nint ret = 0;\r\nif (enabled != omap_plane->enabled) {\r\nomap_plane->enabled = enabled;\r\nret = apply(plane);\r\n}\r\nreturn ret;\r\n}\r\nvoid omap_plane_install_properties(struct drm_plane *plane,\r\nstruct drm_mode_object *obj)\r\n{\r\nstruct drm_device *dev = plane->dev;\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct drm_property *prop;\r\nif (priv->has_dmm) {\r\nprop = priv->rotation_prop;\r\nif (!prop) {\r\nprop = drm_mode_create_rotation_property(dev,\r\nBIT(DRM_ROTATE_0) |\r\nBIT(DRM_ROTATE_90) |\r\nBIT(DRM_ROTATE_180) |\r\nBIT(DRM_ROTATE_270) |\r\nBIT(DRM_REFLECT_X) |\r\nBIT(DRM_REFLECT_Y));\r\nif (prop == NULL)\r\nreturn;\r\npriv->rotation_prop = prop;\r\n}\r\ndrm_object_attach_property(obj, prop, 0);\r\n}\r\nprop = priv->zorder_prop;\r\nif (!prop) {\r\nprop = drm_property_create_range(dev, 0, "zorder", 0, 3);\r\nif (prop == NULL)\r\nreturn;\r\npriv->zorder_prop = prop;\r\n}\r\ndrm_object_attach_property(obj, prop, 0);\r\n}\r\nint omap_plane_set_property(struct drm_plane *plane,\r\nstruct drm_property *property, uint64_t val)\r\n{\r\nstruct omap_plane *omap_plane = to_omap_plane(plane);\r\nstruct omap_drm_private *priv = plane->dev->dev_private;\r\nint ret = -EINVAL;\r\nif (property == priv->rotation_prop) {\r\nDBG("%s: rotation: %02x", omap_plane->name, (uint32_t)val);\r\nomap_plane->win.rotation = val;\r\nret = apply(plane);\r\n} else if (property == priv->zorder_prop) {\r\nDBG("%s: zorder: %02x", omap_plane->name, (uint32_t)val);\r\nomap_plane->info.zorder = val;\r\nret = apply(plane);\r\n}\r\nreturn ret;\r\n}\r\nstatic void omap_plane_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)\r\n{\r\nstruct omap_plane *omap_plane =\r\ncontainer_of(irq, struct omap_plane, error_irq);\r\nDRM_ERROR("%s: errors: %08x\n", omap_plane->name, irqstatus);\r\n}\r\nstruct drm_plane *omap_plane_init(struct drm_device *dev,\r\nint id, bool private_plane)\r\n{\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nstruct drm_plane *plane = NULL;\r\nstruct omap_plane *omap_plane;\r\nstruct omap_overlay_info *info;\r\nDBG("%s: priv=%d", plane_names[id], private_plane);\r\nomap_plane = kzalloc(sizeof(*omap_plane), GFP_KERNEL);\r\nif (!omap_plane)\r\nreturn NULL;\r\ndrm_flip_work_init(&omap_plane->unpin_work,\r\n"unpin", unpin_worker);\r\nomap_plane->nformats = omap_framebuffer_get_formats(\r\nomap_plane->formats, ARRAY_SIZE(omap_plane->formats),\r\ndss_feat_get_supported_color_modes(id));\r\nomap_plane->id = id;\r\nomap_plane->name = plane_names[id];\r\nplane = &omap_plane->base;\r\nomap_plane->apply.pre_apply = omap_plane_pre_apply;\r\nomap_plane->apply.post_apply = omap_plane_post_apply;\r\nomap_plane->error_irq.irqmask = error_irqs[id];\r\nomap_plane->error_irq.irq = omap_plane_error_irq;\r\nomap_irq_register(dev, &omap_plane->error_irq);\r\ndrm_plane_init(dev, plane, (1 << priv->num_crtcs) - 1, &omap_plane_funcs,\r\nomap_plane->formats, omap_plane->nformats, private_plane);\r\nomap_plane_install_properties(plane, &plane->base);\r\ninfo = &omap_plane->info;\r\ninfo->rotation_type = OMAP_DSS_ROT_DMA;\r\ninfo->rotation = OMAP_DSS_ROT_0;\r\ninfo->global_alpha = 0xff;\r\ninfo->mirror = 0;\r\nif (private_plane)\r\nomap_plane->info.zorder = 0;\r\nelse\r\nomap_plane->info.zorder = id;\r\nreturn plane;\r\n}
