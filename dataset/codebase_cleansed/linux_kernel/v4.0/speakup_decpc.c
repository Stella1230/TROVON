static int dt_getstatus(void)\r\n{\r\ndt_stat = inb_p(speakup_info.port_tts) |\r\n(inb_p(speakup_info.port_tts + 1) << 8);\r\nreturn dt_stat;\r\n}\r\nstatic void dt_sendcmd(u_int cmd)\r\n{\r\noutb_p(cmd & 0xFF, speakup_info.port_tts);\r\noutb_p((cmd >> 8) & 0xFF, speakup_info.port_tts+1);\r\n}\r\nstatic int dt_waitbit(int bit)\r\n{\r\nint timeout = 100;\r\nwhile (--timeout > 0) {\r\nif ((dt_getstatus() & bit) == bit)\r\nreturn 1;\r\nudelay(50);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dt_wait_dma(void)\r\n{\r\nint timeout = 100, state = dma_state;\r\nif (!dt_waitbit(STAT_dma_ready))\r\nreturn 0;\r\nwhile (--timeout > 0) {\r\nif ((dt_getstatus()&STAT_dma_state) == state)\r\nreturn 1;\r\nudelay(50);\r\n}\r\ndma_state = dt_getstatus() & STAT_dma_state;\r\nreturn 1;\r\n}\r\nstatic int dt_ctrl(u_int cmd)\r\n{\r\nint timeout = 10;\r\nif (!dt_waitbit(STAT_cmd_ready))\r\nreturn -1;\r\noutb_p(0, speakup_info.port_tts+2);\r\noutb_p(0, speakup_info.port_tts+3);\r\ndt_getstatus();\r\ndt_sendcmd(CMD_control|cmd);\r\noutb_p(0, speakup_info.port_tts+6);\r\nwhile (dt_getstatus() & STAT_cmd_ready) {\r\nudelay(20);\r\nif (--timeout == 0)\r\nbreak;\r\n}\r\ndt_sendcmd(CMD_null);\r\nreturn 0;\r\n}\r\nstatic void synth_flush(struct spk_synth *synth)\r\n{\r\nint timeout = 10;\r\nif (is_flushing)\r\nreturn;\r\nis_flushing = 4;\r\nin_escape = 0;\r\nwhile (dt_ctrl(CTRL_flush)) {\r\nif (--timeout == 0)\r\nbreak;\r\nudelay(50);\r\n}\r\nfor (timeout = 0; timeout < 10; timeout++) {\r\nif (dt_waitbit(STAT_dma_ready))\r\nbreak;\r\nudelay(50);\r\n}\r\noutb_p(DMA_sync, speakup_info.port_tts+4);\r\noutb_p(0, speakup_info.port_tts+4);\r\nudelay(100);\r\nfor (timeout = 0; timeout < 10; timeout++) {\r\nif (!(dt_getstatus() & STAT_flushing))\r\nbreak;\r\nudelay(50);\r\n}\r\ndma_state = dt_getstatus() & STAT_dma_state;\r\ndma_state ^= STAT_dma_state;\r\nis_flushing = 0;\r\n}\r\nstatic int dt_sendchar(char ch)\r\n{\r\nif (!dt_wait_dma())\r\nreturn -1;\r\nif (!(dt_stat & STAT_rr_char))\r\nreturn -2;\r\noutb_p(DMA_single_in, speakup_info.port_tts+4);\r\noutb_p(ch, speakup_info.port_tts+4);\r\ndma_state ^= STAT_dma_state;\r\nreturn 0;\r\n}\r\nstatic int testkernel(void)\r\n{\r\nint status = 0;\r\nif (dt_getstatus() == 0xffff) {\r\nstatus = -1;\r\ngoto oops;\r\n}\r\ndt_sendcmd(CMD_sync);\r\nif (!dt_waitbit(STAT_cmd_ready))\r\nstatus = -2;\r\nelse if (dt_stat&0x8000)\r\nreturn 0;\r\nelse if (dt_stat == 0x0dec)\r\npr_warn("dec_pc at 0x%x, software not loaded\n",\r\nspeakup_info.port_tts);\r\nstatus = -3;\r\noops: synth_release_region(speakup_info.port_tts, SYNTH_IO_EXTENT);\r\nspeakup_info.port_tts = 0;\r\nreturn status;\r\n}\r\nstatic void do_catch_up(struct spk_synth *synth)\r\n{\r\nu_char ch;\r\nstatic u_char last;\r\nunsigned long flags;\r\nunsigned long jiff_max;\r\nstruct var_t *jiffy_delta;\r\nstruct var_t *delay_time;\r\nint jiffy_delta_val;\r\nint delay_time_val;\r\njiffy_delta = spk_get_var(JIFFY);\r\ndelay_time = spk_get_var(DELAY);\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\njiffy_delta_val = jiffy_delta->u.n.value;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\njiff_max = jiffies + jiffy_delta_val;\r\nwhile (!kthread_should_stop()) {\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nif (speakup_info.flushing) {\r\nspeakup_info.flushing = 0;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nsynth->flush(synth);\r\ncontinue;\r\n}\r\nif (synth_buffer_empty()) {\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nbreak;\r\n}\r\nch = synth_buffer_peek();\r\nset_current_state(TASK_INTERRUPTIBLE);\r\ndelay_time_val = delay_time->u.n.value;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nif (ch == '\n')\r\nch = 0x0D;\r\nif (dt_sendchar(ch)) {\r\nschedule_timeout(msecs_to_jiffies(delay_time_val));\r\ncontinue;\r\n}\r\nset_current_state(TASK_RUNNING);\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\nsynth_buffer_getc();\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nif (ch == '[')\r\nin_escape = 1;\r\nelse if (ch == ']')\r\nin_escape = 0;\r\nelse if (ch <= SPACE) {\r\nif (!in_escape && strchr(",.!?;:", last))\r\ndt_sendchar(PROCSPEECH);\r\nif (time_after_eq(jiffies, jiff_max)) {\r\nif (!in_escape)\r\ndt_sendchar(PROCSPEECH);\r\nspin_lock_irqsave(&speakup_info.spinlock, flags);\r\njiffy_delta_val = jiffy_delta->u.n.value;\r\ndelay_time_val = delay_time->u.n.value;\r\nspin_unlock_irqrestore(&speakup_info.spinlock, flags);\r\nschedule_timeout(msecs_to_jiffies\r\n(delay_time_val));\r\njiff_max = jiffies + jiffy_delta_val;\r\n}\r\n}\r\nlast = ch;\r\nch = 0;\r\n}\r\nif (!in_escape)\r\ndt_sendchar(PROCSPEECH);\r\n}\r\nstatic const char *synth_immediate(struct spk_synth *synth, const char *buf)\r\n{\r\nu_char ch;\r\nwhile ((ch = *buf)) {\r\nif (ch == '\n')\r\nch = PROCSPEECH;\r\nif (dt_sendchar(ch))\r\nreturn buf;\r\nbuf++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int synth_probe(struct spk_synth *synth)\r\n{\r\nint i = 0, failed = 0;\r\npr_info("Probing for %s.\n", synth->long_name);\r\nfor (i = 0; synth_portlist[i]; i++) {\r\nif (synth_request_region(synth_portlist[i], SYNTH_IO_EXTENT)) {\r\npr_warn("request_region: failed with 0x%x, %d\n",\r\nsynth_portlist[i], SYNTH_IO_EXTENT);\r\ncontinue;\r\n}\r\nspeakup_info.port_tts = synth_portlist[i];\r\nfailed = testkernel();\r\nif (failed == 0)\r\nbreak;\r\n}\r\nif (failed) {\r\npr_info("%s: not found\n", synth->long_name);\r\nreturn -ENODEV;\r\n}\r\npr_info("%s: %03x-%03x, Driver Version %s,\n", synth->long_name,\r\nspeakup_info.port_tts, speakup_info.port_tts + 7,\r\nsynth->version);\r\nsynth->alive = 1;\r\nreturn 0;\r\n}\r\nstatic void dtpc_release(void)\r\n{\r\nif (speakup_info.port_tts)\r\nsynth_release_region(speakup_info.port_tts, SYNTH_IO_EXTENT);\r\nspeakup_info.port_tts = 0;\r\n}\r\nstatic int __init decpc_init(void)\r\n{\r\nreturn synth_add(&synth_dec_pc);\r\n}\r\nstatic void __exit decpc_exit(void)\r\n{\r\nsynth_remove(&synth_dec_pc);\r\n}
