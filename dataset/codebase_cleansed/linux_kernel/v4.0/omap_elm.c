static void elm_write_reg(struct elm_info *info, int offset, u32 val)\r\n{\r\nwritel(val, info->elm_base + offset);\r\n}\r\nstatic u32 elm_read_reg(struct elm_info *info, int offset)\r\n{\r\nreturn readl(info->elm_base + offset);\r\n}\r\nint elm_config(struct device *dev, enum bch_ecc bch_type,\r\nint ecc_steps, int ecc_step_size, int ecc_syndrome_size)\r\n{\r\nu32 reg_val;\r\nstruct elm_info *info = dev_get_drvdata(dev);\r\nif (!info) {\r\ndev_err(dev, "Unable to configure elm - device not probed?\n");\r\nreturn -EPROBE_DEFER;\r\n}\r\nif (ecc_step_size > ((ELM_ECC_SIZE + 1) / 2)) {\r\ndev_err(dev, "unsupported config ecc-size=%d\n", ecc_step_size);\r\nreturn -EINVAL;\r\n}\r\nif (ecc_steps > ERROR_VECTOR_MAX) {\r\ndev_err(dev, "unsupported config ecc-step=%d\n", ecc_steps);\r\nreturn -EINVAL;\r\n}\r\nreg_val = (bch_type & ECC_BCH_LEVEL_MASK) | (ELM_ECC_SIZE << 16);\r\nelm_write_reg(info, ELM_LOCATION_CONFIG, reg_val);\r\ninfo->bch_type = bch_type;\r\ninfo->ecc_steps = ecc_steps;\r\ninfo->ecc_syndrome_size = ecc_syndrome_size;\r\nreturn 0;\r\n}\r\nstatic void elm_configure_page_mode(struct elm_info *info, int index,\r\nbool enable)\r\n{\r\nu32 reg_val;\r\nreg_val = elm_read_reg(info, ELM_PAGE_CTRL);\r\nif (enable)\r\nreg_val |= BIT(index);\r\nelse\r\nreg_val &= ~BIT(index);\r\nelm_write_reg(info, ELM_PAGE_CTRL, reg_val);\r\n}\r\nstatic void elm_load_syndrome(struct elm_info *info,\r\nstruct elm_errorvec *err_vec, u8 *ecc)\r\n{\r\nint i, offset;\r\nu32 val;\r\nfor (i = 0; i < info->ecc_steps; i++) {\r\nif (err_vec[i].error_reported) {\r\nelm_configure_page_mode(info, i, true);\r\noffset = ELM_SYNDROME_FRAGMENT_0 +\r\nSYNDROME_FRAGMENT_REG_SIZE * i;\r\nswitch (info->bch_type) {\r\ncase BCH8_ECC:\r\nval = cpu_to_be32(*(u32 *) &ecc[9]);\r\nelm_write_reg(info, offset, val);\r\noffset += 4;\r\nval = cpu_to_be32(*(u32 *) &ecc[5]);\r\nelm_write_reg(info, offset, val);\r\noffset += 4;\r\nval = cpu_to_be32(*(u32 *) &ecc[1]);\r\nelm_write_reg(info, offset, val);\r\noffset += 4;\r\nval = ecc[0];\r\nelm_write_reg(info, offset, val);\r\nbreak;\r\ncase BCH4_ECC:\r\nval = (cpu_to_be32(*(u32 *) &ecc[3]) >> 4) |\r\n((ecc[2] & 0xf) << 28);\r\nelm_write_reg(info, offset, val);\r\noffset += 4;\r\nval = cpu_to_be32(*(u32 *) &ecc[0]) >> 12;\r\nelm_write_reg(info, offset, val);\r\nbreak;\r\ncase BCH16_ECC:\r\nval = cpu_to_be32(*(u32 *) &ecc[22]);\r\nelm_write_reg(info, offset, val);\r\noffset += 4;\r\nval = cpu_to_be32(*(u32 *) &ecc[18]);\r\nelm_write_reg(info, offset, val);\r\noffset += 4;\r\nval = cpu_to_be32(*(u32 *) &ecc[14]);\r\nelm_write_reg(info, offset, val);\r\noffset += 4;\r\nval = cpu_to_be32(*(u32 *) &ecc[10]);\r\nelm_write_reg(info, offset, val);\r\noffset += 4;\r\nval = cpu_to_be32(*(u32 *) &ecc[6]);\r\nelm_write_reg(info, offset, val);\r\noffset += 4;\r\nval = cpu_to_be32(*(u32 *) &ecc[2]);\r\nelm_write_reg(info, offset, val);\r\noffset += 4;\r\nval = cpu_to_be32(*(u32 *) &ecc[0]) >> 16;\r\nelm_write_reg(info, offset, val);\r\nbreak;\r\ndefault:\r\npr_err("invalid config bch_type\n");\r\n}\r\n}\r\necc += info->ecc_syndrome_size;\r\n}\r\n}\r\nstatic void elm_start_processing(struct elm_info *info,\r\nstruct elm_errorvec *err_vec)\r\n{\r\nint i, offset;\r\nu32 reg_val;\r\nfor (i = 0; i < info->ecc_steps; i++) {\r\nif (err_vec[i].error_reported) {\r\noffset = ELM_SYNDROME_FRAGMENT_6 +\r\nSYNDROME_FRAGMENT_REG_SIZE * i;\r\nreg_val = elm_read_reg(info, offset);\r\nreg_val |= ELM_SYNDROME_VALID;\r\nelm_write_reg(info, offset, reg_val);\r\n}\r\n}\r\n}\r\nstatic void elm_error_correction(struct elm_info *info,\r\nstruct elm_errorvec *err_vec)\r\n{\r\nint i, j, errors = 0;\r\nint offset;\r\nu32 reg_val;\r\nfor (i = 0; i < info->ecc_steps; i++) {\r\nif (err_vec[i].error_reported) {\r\noffset = ELM_LOCATION_STATUS + ERROR_LOCATION_SIZE * i;\r\nreg_val = elm_read_reg(info, offset);\r\nif (reg_val & ECC_CORRECTABLE_MASK) {\r\noffset = ELM_ERROR_LOCATION_0 +\r\nERROR_LOCATION_SIZE * i;\r\nerr_vec[i].error_count = reg_val &\r\nECC_NB_ERRORS_MASK;\r\nfor (j = 0; j < err_vec[i].error_count; j++) {\r\nreg_val = elm_read_reg(info, offset);\r\nerr_vec[i].error_loc[j] = reg_val &\r\nECC_ERROR_LOCATION_MASK;\r\noffset += 4;\r\n}\r\nerrors += err_vec[i].error_count;\r\n} else {\r\nerr_vec[i].error_uncorrectable = true;\r\n}\r\nelm_write_reg(info, ELM_IRQSTATUS, BIT(i));\r\nelm_configure_page_mode(info, i, false);\r\n}\r\n}\r\n}\r\nvoid elm_decode_bch_error_page(struct device *dev, u8 *ecc_calc,\r\nstruct elm_errorvec *err_vec)\r\n{\r\nstruct elm_info *info = dev_get_drvdata(dev);\r\nu32 reg_val;\r\nreg_val = elm_read_reg(info, ELM_IRQSTATUS);\r\nelm_write_reg(info, ELM_IRQSTATUS, reg_val & INTR_STATUS_PAGE_VALID);\r\nelm_write_reg(info, ELM_IRQENABLE, INTR_EN_PAGE_MASK);\r\nelm_load_syndrome(info, err_vec, ecc_calc);\r\nelm_start_processing(info, err_vec);\r\nwait_for_completion(&info->elm_completion);\r\nreg_val = elm_read_reg(info, ELM_IRQENABLE);\r\nelm_write_reg(info, ELM_IRQENABLE, reg_val & ~INTR_EN_PAGE_MASK);\r\nelm_error_correction(info, err_vec);\r\n}\r\nstatic irqreturn_t elm_isr(int this_irq, void *dev_id)\r\n{\r\nu32 reg_val;\r\nstruct elm_info *info = dev_id;\r\nreg_val = elm_read_reg(info, ELM_IRQSTATUS);\r\nif (reg_val & INTR_STATUS_PAGE_VALID) {\r\nelm_write_reg(info, ELM_IRQSTATUS,\r\nreg_val & INTR_STATUS_PAGE_VALID);\r\ncomplete(&info->elm_completion);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic int elm_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\nstruct resource *res, *irq;\r\nstruct elm_info *info;\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->dev = &pdev->dev;\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "no irq resource defined\n");\r\nreturn -ENODEV;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ninfo->elm_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(info->elm_base))\r\nreturn PTR_ERR(info->elm_base);\r\nret = devm_request_irq(&pdev->dev, irq->start, elm_isr, 0,\r\npdev->name, info);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failure requesting irq %i\n", irq->start);\r\nreturn ret;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\nif (pm_runtime_get_sync(&pdev->dev) < 0) {\r\nret = -EINVAL;\r\npm_runtime_disable(&pdev->dev);\r\ndev_err(&pdev->dev, "can't enable clock\n");\r\nreturn ret;\r\n}\r\ninit_completion(&info->elm_completion);\r\nINIT_LIST_HEAD(&info->list);\r\nlist_add(&info->list, &elm_devices);\r\nplatform_set_drvdata(pdev, info);\r\nreturn ret;\r\n}\r\nstatic int elm_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int elm_context_save(struct elm_info *info)\r\n{\r\nstruct elm_registers *regs = &info->elm_regs;\r\nenum bch_ecc bch_type = info->bch_type;\r\nu32 offset = 0, i;\r\nregs->elm_irqenable = elm_read_reg(info, ELM_IRQENABLE);\r\nregs->elm_sysconfig = elm_read_reg(info, ELM_SYSCONFIG);\r\nregs->elm_location_config = elm_read_reg(info, ELM_LOCATION_CONFIG);\r\nregs->elm_page_ctrl = elm_read_reg(info, ELM_PAGE_CTRL);\r\nfor (i = 0; i < ERROR_VECTOR_MAX; i++) {\r\noffset = i * SYNDROME_FRAGMENT_REG_SIZE;\r\nswitch (bch_type) {\r\ncase BCH16_ECC:\r\nregs->elm_syndrome_fragment_6[i] = elm_read_reg(info,\r\nELM_SYNDROME_FRAGMENT_6 + offset);\r\nregs->elm_syndrome_fragment_5[i] = elm_read_reg(info,\r\nELM_SYNDROME_FRAGMENT_5 + offset);\r\nregs->elm_syndrome_fragment_4[i] = elm_read_reg(info,\r\nELM_SYNDROME_FRAGMENT_4 + offset);\r\ncase BCH8_ECC:\r\nregs->elm_syndrome_fragment_3[i] = elm_read_reg(info,\r\nELM_SYNDROME_FRAGMENT_3 + offset);\r\nregs->elm_syndrome_fragment_2[i] = elm_read_reg(info,\r\nELM_SYNDROME_FRAGMENT_2 + offset);\r\ncase BCH4_ECC:\r\nregs->elm_syndrome_fragment_1[i] = elm_read_reg(info,\r\nELM_SYNDROME_FRAGMENT_1 + offset);\r\nregs->elm_syndrome_fragment_0[i] = elm_read_reg(info,\r\nELM_SYNDROME_FRAGMENT_0 + offset);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregs->elm_syndrome_fragment_6[i] = elm_read_reg(info,\r\nELM_SYNDROME_FRAGMENT_6 + offset);\r\n}\r\nreturn 0;\r\n}\r\nstatic int elm_context_restore(struct elm_info *info)\r\n{\r\nstruct elm_registers *regs = &info->elm_regs;\r\nenum bch_ecc bch_type = info->bch_type;\r\nu32 offset = 0, i;\r\nelm_write_reg(info, ELM_IRQENABLE, regs->elm_irqenable);\r\nelm_write_reg(info, ELM_SYSCONFIG, regs->elm_sysconfig);\r\nelm_write_reg(info, ELM_LOCATION_CONFIG, regs->elm_location_config);\r\nelm_write_reg(info, ELM_PAGE_CTRL, regs->elm_page_ctrl);\r\nfor (i = 0; i < ERROR_VECTOR_MAX; i++) {\r\noffset = i * SYNDROME_FRAGMENT_REG_SIZE;\r\nswitch (bch_type) {\r\ncase BCH16_ECC:\r\nelm_write_reg(info, ELM_SYNDROME_FRAGMENT_6 + offset,\r\nregs->elm_syndrome_fragment_6[i]);\r\nelm_write_reg(info, ELM_SYNDROME_FRAGMENT_5 + offset,\r\nregs->elm_syndrome_fragment_5[i]);\r\nelm_write_reg(info, ELM_SYNDROME_FRAGMENT_4 + offset,\r\nregs->elm_syndrome_fragment_4[i]);\r\ncase BCH8_ECC:\r\nelm_write_reg(info, ELM_SYNDROME_FRAGMENT_3 + offset,\r\nregs->elm_syndrome_fragment_3[i]);\r\nelm_write_reg(info, ELM_SYNDROME_FRAGMENT_2 + offset,\r\nregs->elm_syndrome_fragment_2[i]);\r\ncase BCH4_ECC:\r\nelm_write_reg(info, ELM_SYNDROME_FRAGMENT_1 + offset,\r\nregs->elm_syndrome_fragment_1[i]);\r\nelm_write_reg(info, ELM_SYNDROME_FRAGMENT_0 + offset,\r\nregs->elm_syndrome_fragment_0[i]);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nelm_write_reg(info, ELM_SYNDROME_FRAGMENT_6 + offset,\r\nregs->elm_syndrome_fragment_6[i] &\r\nELM_SYNDROME_VALID);\r\n}\r\nreturn 0;\r\n}\r\nstatic int elm_suspend(struct device *dev)\r\n{\r\nstruct elm_info *info = dev_get_drvdata(dev);\r\nelm_context_save(info);\r\npm_runtime_put_sync(dev);\r\nreturn 0;\r\n}\r\nstatic int elm_resume(struct device *dev)\r\n{\r\nstruct elm_info *info = dev_get_drvdata(dev);\r\npm_runtime_get_sync(dev);\r\nelm_context_restore(info);\r\nreturn 0;\r\n}
