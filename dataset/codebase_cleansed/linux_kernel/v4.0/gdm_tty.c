static void gdm_port_destruct(struct tty_port *port)\r\n{\r\nstruct gdm *gdm = container_of(port, struct gdm, port);\r\nmutex_lock(&gdm_table_lock);\r\ngdm_table[gdm->index][gdm->minor] = NULL;\r\nmutex_unlock(&gdm_table_lock);\r\nkfree(gdm);\r\n}\r\nstatic int gdm_tty_install(struct tty_driver *driver, struct tty_struct *tty)\r\n{\r\nstruct gdm *gdm = NULL;\r\nint ret;\r\nint i;\r\nint j;\r\nj = GDM_TTY_MINOR;\r\nfor (i = 0; i < TTY_MAX_COUNT; i++) {\r\nif (!strcmp(tty->driver->driver_name, DRIVER_STRING[i])) {\r\nj = tty->index;\r\nbreak;\r\n}\r\n}\r\nif (j == GDM_TTY_MINOR)\r\nreturn -ENODEV;\r\nmutex_lock(&gdm_table_lock);\r\ngdm = gdm_table[i][j];\r\nif (gdm == NULL) {\r\nmutex_unlock(&gdm_table_lock);\r\nreturn -ENODEV;\r\n}\r\ntty_port_get(&gdm->port);\r\nret = tty_standard_install(driver, tty);\r\nif (ret) {\r\ntty_port_put(&gdm->port);\r\nmutex_unlock(&gdm_table_lock);\r\nreturn ret;\r\n}\r\ntty->driver_data = gdm;\r\nmutex_unlock(&gdm_table_lock);\r\nreturn 0;\r\n}\r\nstatic int gdm_tty_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct gdm *gdm = tty->driver_data;\r\nreturn tty_port_open(&gdm->port, tty, filp);\r\n}\r\nstatic void gdm_tty_cleanup(struct tty_struct *tty)\r\n{\r\nstruct gdm *gdm = tty->driver_data;\r\ntty_port_put(&gdm->port);\r\n}\r\nstatic void gdm_tty_hangup(struct tty_struct *tty)\r\n{\r\nstruct gdm *gdm = tty->driver_data;\r\ntty_port_hangup(&gdm->port);\r\n}\r\nstatic void gdm_tty_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct gdm *gdm = tty->driver_data;\r\ntty_port_close(&gdm->port, tty, filp);\r\n}\r\nstatic int gdm_tty_recv_complete(void *data,\r\nint len,\r\nint index,\r\nstruct tty_dev *tty_dev,\r\nint complete)\r\n{\r\nstruct gdm *gdm = tty_dev->gdm[index];\r\nif (!GDM_TTY_READY(gdm)) {\r\nif (complete == RECV_PACKET_PROCESS_COMPLETE)\r\ngdm_tty_recv(gdm, gdm_tty_recv_complete);\r\nreturn TO_HOST_PORT_CLOSE;\r\n}\r\nif (data && len) {\r\nif (tty_buffer_request_room(&gdm->port, len) == len) {\r\ntty_insert_flip_string(&gdm->port, data, len);\r\ntty_flip_buffer_push(&gdm->port);\r\n} else {\r\nreturn TO_HOST_BUFFER_REQUEST_FAIL;\r\n}\r\n}\r\nif (complete == RECV_PACKET_PROCESS_COMPLETE)\r\ngdm_tty_recv(gdm, gdm_tty_recv_complete);\r\nreturn 0;\r\n}\r\nstatic void gdm_tty_send_complete(void *arg)\r\n{\r\nstruct gdm *gdm = (struct gdm *)arg;\r\nif (!GDM_TTY_READY(gdm))\r\nreturn;\r\ntty_port_tty_wakeup(&gdm->port);\r\n}\r\nstatic int gdm_tty_write(struct tty_struct *tty, const unsigned char *buf,\r\nint len)\r\n{\r\nstruct gdm *gdm = tty->driver_data;\r\nint remain = len;\r\nint sent_len = 0;\r\nint sending_len = 0;\r\nif (!GDM_TTY_READY(gdm))\r\nreturn -ENODEV;\r\nif (!len)\r\nreturn 0;\r\nwhile (1) {\r\nsending_len = remain > MUX_TX_MAX_SIZE ? MUX_TX_MAX_SIZE :\r\nremain;\r\ngdm_tty_send(gdm,\r\n(void *)(buf+sent_len),\r\nsending_len,\r\ngdm->index,\r\ngdm_tty_send_complete,\r\ngdm\r\n);\r\nsent_len += sending_len;\r\nremain -= sending_len;\r\nif (remain <= 0)\r\nbreak;\r\n}\r\nreturn len;\r\n}\r\nstatic int gdm_tty_write_room(struct tty_struct *tty)\r\n{\r\nstruct gdm *gdm = tty->driver_data;\r\nif (!GDM_TTY_READY(gdm))\r\nreturn -ENODEV;\r\nreturn WRITE_SIZE;\r\n}\r\nint register_lte_tty_device(struct tty_dev *tty_dev, struct device *device)\r\n{\r\nstruct gdm *gdm;\r\nint i;\r\nint j;\r\nfor (i = 0; i < TTY_MAX_COUNT; i++) {\r\ngdm = kmalloc(sizeof(struct gdm), GFP_KERNEL);\r\nif (!gdm)\r\nreturn -ENOMEM;\r\nmutex_lock(&gdm_table_lock);\r\nfor (j = 0; j < GDM_TTY_MINOR; j++) {\r\nif (!gdm_table[i][j])\r\nbreak;\r\n}\r\nif (j == GDM_TTY_MINOR) {\r\nkfree(gdm);\r\nmutex_unlock(&gdm_table_lock);\r\nreturn -EINVAL;\r\n}\r\ngdm_table[i][j] = gdm;\r\nmutex_unlock(&gdm_table_lock);\r\ntty_dev->gdm[i] = gdm;\r\ntty_port_init(&gdm->port);\r\ngdm->port.ops = &gdm_port_ops;\r\ngdm->index = i;\r\ngdm->minor = j;\r\ngdm->tty_dev = tty_dev;\r\ntty_port_register_device(&gdm->port, gdm_driver[i],\r\ngdm->minor, device);\r\n}\r\nfor (i = 0; i < MAX_ISSUE_NUM; i++)\r\ngdm_tty_recv(gdm, gdm_tty_recv_complete);\r\nreturn 0;\r\n}\r\nvoid unregister_lte_tty_device(struct tty_dev *tty_dev)\r\n{\r\nstruct gdm *gdm;\r\nstruct tty_struct *tty;\r\nint i;\r\nfor (i = 0; i < TTY_MAX_COUNT; i++) {\r\ngdm = tty_dev->gdm[i];\r\nif (!gdm)\r\ncontinue;\r\nmutex_lock(&gdm_table_lock);\r\ngdm_table[gdm->index][gdm->minor] = NULL;\r\nmutex_unlock(&gdm_table_lock);\r\ntty = tty_port_tty_get(&gdm->port);\r\nif (tty) {\r\ntty_vhangup(tty);\r\ntty_kref_put(tty);\r\n}\r\ntty_unregister_device(gdm_driver[i], gdm->minor);\r\ntty_port_put(&gdm->port);\r\n}\r\n}\r\nint register_lte_tty_driver(void)\r\n{\r\nstruct tty_driver *tty_driver;\r\nint i;\r\nint ret;\r\nfor (i = 0; i < TTY_MAX_COUNT; i++) {\r\ntty_driver = alloc_tty_driver(GDM_TTY_MINOR);\r\nif (!tty_driver)\r\nreturn -ENOMEM;\r\ntty_driver->owner = THIS_MODULE;\r\ntty_driver->driver_name = DRIVER_STRING[i];\r\ntty_driver->name = DEVICE_STRING[i];\r\ntty_driver->major = GDM_TTY_MAJOR;\r\ntty_driver->type = TTY_DRIVER_TYPE_SERIAL;\r\ntty_driver->subtype = SERIAL_TYPE_NORMAL;\r\ntty_driver->flags = TTY_DRIVER_REAL_RAW |\r\nTTY_DRIVER_DYNAMIC_DEV;\r\ntty_driver->init_termios = tty_std_termios;\r\ntty_driver->init_termios.c_cflag = B9600 | CS8 | HUPCL | CLOCAL;\r\ntty_driver->init_termios.c_lflag = ISIG | ICANON | IEXTEN;\r\ntty_set_operations(tty_driver, &gdm_tty_ops);\r\nret = tty_register_driver(tty_driver);\r\nif (ret) {\r\nput_tty_driver(tty_driver);\r\nreturn ret;\r\n}\r\ngdm_driver[i] = tty_driver;\r\n}\r\nreturn ret;\r\n}\r\nvoid unregister_lte_tty_driver(void)\r\n{\r\nstruct tty_driver *tty_driver;\r\nint i;\r\nfor (i = 0; i < TTY_MAX_COUNT; i++) {\r\ntty_driver = gdm_driver[i];\r\nif (tty_driver) {\r\ntty_unregister_driver(tty_driver);\r\nput_tty_driver(tty_driver);\r\n}\r\n}\r\n}
