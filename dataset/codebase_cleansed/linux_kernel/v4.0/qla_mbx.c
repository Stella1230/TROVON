static int\r\nqla2x00_mailbox_command(scsi_qla_host_t *vha, mbx_cmd_t *mcp)\r\n{\r\nint rval;\r\nunsigned long flags = 0;\r\ndevice_reg_t *reg;\r\nuint8_t abort_active;\r\nuint8_t io_lock_on;\r\nuint16_t command = 0;\r\nuint16_t *iptr;\r\nuint16_t __iomem *optr;\r\nuint32_t cnt;\r\nuint32_t mboxes;\r\nunsigned long wait_time;\r\nstruct qla_hw_data *ha = vha->hw;\r\nscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\r\nql_dbg(ql_dbg_mbx, vha, 0x1000, "Entered %s.\n", __func__);\r\nif (ha->pdev->error_state > pci_channel_io_frozen) {\r\nql_log(ql_log_warn, vha, 0x1001,\r\n"error_state is greater than pci_channel_io_frozen, "\r\n"exiting.\n");\r\nreturn QLA_FUNCTION_TIMEOUT;\r\n}\r\nif (vha->device_flags & DFLG_DEV_FAILED) {\r\nql_log(ql_log_warn, vha, 0x1002,\r\n"Device in failed state, exiting.\n");\r\nreturn QLA_FUNCTION_TIMEOUT;\r\n}\r\nreg = ha->iobase;\r\nio_lock_on = base_vha->flags.init_done;\r\nrval = QLA_SUCCESS;\r\nabort_active = test_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags);\r\nif (ha->flags.pci_channel_io_perm_failure) {\r\nql_log(ql_log_warn, vha, 0x1003,\r\n"Perm failure on EEH timeout MBX, exiting.\n");\r\nreturn QLA_FUNCTION_TIMEOUT;\r\n}\r\nif (IS_P3P_TYPE(ha) && ha->flags.isp82xx_fw_hung) {\r\nmcp->mb[0] = MBS_LINK_DOWN_ERROR;\r\nql_log(ql_log_warn, vha, 0x1004,\r\n"FW hung = %d.\n", ha->flags.isp82xx_fw_hung);\r\nreturn QLA_FUNCTION_TIMEOUT;\r\n}\r\nif (!wait_for_completion_timeout(&ha->mbx_cmd_comp, mcp->tov * HZ)) {\r\nql_log(ql_log_warn, vha, 0x1005,\r\n"Cmd access timeout, cmd=0x%x, Exiting.\n",\r\nmcp->mb[0]);\r\nreturn QLA_FUNCTION_TIMEOUT;\r\n}\r\nha->flags.mbox_busy = 1;\r\nha->mcp = mcp;\r\nql_dbg(ql_dbg_mbx, vha, 0x1006,\r\n"Prepare to issue mbox cmd=0x%x.\n", mcp->mb[0]);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nif (IS_P3P_TYPE(ha))\r\noptr = (uint16_t __iomem *)&reg->isp82.mailbox_in[0];\r\nelse if (IS_FWI2_CAPABLE(ha) && !(IS_P3P_TYPE(ha)))\r\noptr = (uint16_t __iomem *)&reg->isp24.mailbox0;\r\nelse\r\noptr = (uint16_t __iomem *)MAILBOX_REG(ha, &reg->isp, 0);\r\niptr = mcp->mb;\r\ncommand = mcp->mb[0];\r\nmboxes = mcp->out_mb;\r\nql_dbg(ql_dbg_mbx, vha, 0x1111,\r\n"Mailbox registers (OUT):\n");\r\nfor (cnt = 0; cnt < ha->mbx_count; cnt++) {\r\nif (IS_QLA2200(ha) && cnt == 8)\r\noptr =\r\n(uint16_t __iomem *)MAILBOX_REG(ha, &reg->isp, 8);\r\nif (mboxes & BIT_0) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1112,\r\n"mbox[%d]<-0x%04x\n", cnt, *iptr);\r\nWRT_REG_WORD(optr, *iptr);\r\n}\r\nmboxes >>= 1;\r\noptr++;\r\niptr++;\r\n}\r\nql_dbg(ql_dbg_mbx + ql_dbg_buffer, vha, 0x1117,\r\n"I/O Address = %p.\n", optr);\r\nha->flags.mbox_int = 0;\r\nclear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);\r\nql_dbg(ql_dbg_mbx, vha, 0x100f,\r\n"Going to unlock irq & waiting for interrupts. "\r\n"jiffies=%lx.\n", jiffies);\r\nif ((!abort_active && io_lock_on) || IS_NOPOLLING_TYPE(ha)) {\r\nset_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags);\r\nif (IS_P3P_TYPE(ha)) {\r\nif (RD_REG_DWORD(&reg->isp82.hint) &\r\nHINT_MBX_INT_PENDING) {\r\nspin_unlock_irqrestore(&ha->hardware_lock,\r\nflags);\r\nha->flags.mbox_busy = 0;\r\nql_dbg(ql_dbg_mbx, vha, 0x1010,\r\n"Pending mailbox timeout, exiting.\n");\r\nrval = QLA_FUNCTION_TIMEOUT;\r\ngoto premature_exit;\r\n}\r\nWRT_REG_DWORD(&reg->isp82.hint, HINT_MBX_INT_PENDING);\r\n} else if (IS_FWI2_CAPABLE(ha))\r\nWRT_REG_DWORD(&reg->isp24.hccr, HCCRX_SET_HOST_INT);\r\nelse\r\nWRT_REG_WORD(&reg->isp.hccr, HCCR_SET_HOST_INT);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (!wait_for_completion_timeout(&ha->mbx_intr_comp,\r\nmcp->tov * HZ)) {\r\nql_dbg(ql_dbg_mbx, vha, 0x117a,\r\n"cmd=%x Timeout.\n", command);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nclear_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\n} else {\r\nql_dbg(ql_dbg_mbx, vha, 0x1011,\r\n"Cmd=%x Polling Mode.\n", command);\r\nif (IS_P3P_TYPE(ha)) {\r\nif (RD_REG_DWORD(&reg->isp82.hint) &\r\nHINT_MBX_INT_PENDING) {\r\nspin_unlock_irqrestore(&ha->hardware_lock,\r\nflags);\r\nha->flags.mbox_busy = 0;\r\nql_dbg(ql_dbg_mbx, vha, 0x1012,\r\n"Pending mailbox timeout, exiting.\n");\r\nrval = QLA_FUNCTION_TIMEOUT;\r\ngoto premature_exit;\r\n}\r\nWRT_REG_DWORD(&reg->isp82.hint, HINT_MBX_INT_PENDING);\r\n} else if (IS_FWI2_CAPABLE(ha))\r\nWRT_REG_DWORD(&reg->isp24.hccr, HCCRX_SET_HOST_INT);\r\nelse\r\nWRT_REG_WORD(&reg->isp.hccr, HCCR_SET_HOST_INT);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nwait_time = jiffies + mcp->tov * HZ;\r\nwhile (!ha->flags.mbox_int) {\r\nif (time_after(jiffies, wait_time))\r\nbreak;\r\nqla2x00_poll(ha->rsp_q_map[0]);\r\nif (!ha->flags.mbox_int &&\r\n!(IS_QLA2200(ha) &&\r\ncommand == MBC_LOAD_RISC_RAM_EXTENDED))\r\nmsleep(10);\r\n}\r\nql_dbg(ql_dbg_mbx, vha, 0x1013,\r\n"Waited %d sec.\n",\r\n(uint)((jiffies - (wait_time - (mcp->tov * HZ)))/HZ));\r\n}\r\nif (ha->flags.mbox_int) {\r\nuint16_t *iptr2;\r\nql_dbg(ql_dbg_mbx, vha, 0x1014,\r\n"Cmd=%x completed.\n", command);\r\nha->flags.mbox_int = 0;\r\nclear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);\r\nif (IS_P3P_TYPE(ha) && ha->flags.isp82xx_fw_hung) {\r\nha->flags.mbox_busy = 0;\r\nmcp->mb[0] = MBS_LINK_DOWN_ERROR;\r\nha->mcp = NULL;\r\nrval = QLA_FUNCTION_FAILED;\r\nql_log(ql_log_warn, vha, 0x1015,\r\n"FW hung = %d.\n", ha->flags.isp82xx_fw_hung);\r\ngoto premature_exit;\r\n}\r\nif (ha->mailbox_out[0] != MBS_COMMAND_COMPLETE)\r\nrval = QLA_FUNCTION_FAILED;\r\niptr2 = mcp->mb;\r\niptr = (uint16_t *)&ha->mailbox_out[0];\r\nmboxes = mcp->in_mb;\r\nql_dbg(ql_dbg_mbx, vha, 0x1113,\r\n"Mailbox registers (IN):\n");\r\nfor (cnt = 0; cnt < ha->mbx_count; cnt++) {\r\nif (mboxes & BIT_0) {\r\n*iptr2 = *iptr;\r\nql_dbg(ql_dbg_mbx, vha, 0x1114,\r\n"mbox[%d]->0x%04x\n", cnt, *iptr2);\r\n}\r\nmboxes >>= 1;\r\niptr2++;\r\niptr++;\r\n}\r\n} else {\r\nuint16_t mb0;\r\nuint32_t ictrl;\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nmb0 = RD_REG_WORD(&reg->isp24.mailbox0);\r\nictrl = RD_REG_DWORD(&reg->isp24.ictrl);\r\n} else {\r\nmb0 = RD_MAILBOX_REG(ha, &reg->isp, 0);\r\nictrl = RD_REG_WORD(&reg->isp.ictrl);\r\n}\r\nql_dbg(ql_dbg_mbx + ql_dbg_buffer, vha, 0x1119,\r\n"MBX Command timeout for cmd %x, iocontrol=%x jiffies=%lx "\r\n"mb[0]=0x%x\n", command, ictrl, jiffies, mb0);\r\nql_dump_regs(ql_dbg_mbx + ql_dbg_buffer, vha, 0x1019);\r\nif (mcp->mb[0] != MBC_GEN_SYSTEM_ERROR)\r\nha->isp_ops->fw_dump(vha, 0);\r\nrval = QLA_FUNCTION_TIMEOUT;\r\n}\r\nha->flags.mbox_busy = 0;\r\nha->mcp = NULL;\r\nif ((abort_active || !io_lock_on) && !IS_NOPOLLING_TYPE(ha)) {\r\nql_dbg(ql_dbg_mbx, vha, 0x101a,\r\n"Checking for additional resp interrupt.\n");\r\nqla2x00_poll(ha->rsp_q_map[0]);\r\n}\r\nif (rval == QLA_FUNCTION_TIMEOUT &&\r\nmcp->mb[0] != MBC_GEN_SYSTEM_ERROR) {\r\nif (!io_lock_on || (mcp->flags & IOCTL_CMD) ||\r\nha->flags.eeh_busy) {\r\nql_dbg(ql_dbg_mbx, vha, 0x101b,\r\n"Timeout, schedule isp_abort_needed.\n");\r\nif (!test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags) &&\r\n!test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags) &&\r\n!test_bit(ISP_ABORT_RETRY, &vha->dpc_flags)) {\r\nif (IS_QLA82XX(ha)) {\r\nql_dbg(ql_dbg_mbx, vha, 0x112a,\r\n"disabling pause transmit on port "\r\n"0 & 1.\n");\r\nqla82xx_wr_32(ha,\r\nQLA82XX_CRB_NIU + 0x98,\r\nCRB_NIU_XG_PAUSE_CTL_P0|\r\nCRB_NIU_XG_PAUSE_CTL_P1);\r\n}\r\nql_log(ql_log_info, base_vha, 0x101c,\r\n"Mailbox cmd timeout occurred, cmd=0x%x, "\r\n"mb[0]=0x%x, eeh_busy=0x%x. Scheduling ISP "\r\n"abort.\n", command, mcp->mb[0],\r\nha->flags.eeh_busy);\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\n}\r\n} else if (!abort_active) {\r\nql_dbg(ql_dbg_mbx, vha, 0x101d,\r\n"Timeout, calling abort_isp.\n");\r\nif (!test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags) &&\r\n!test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags) &&\r\n!test_bit(ISP_ABORT_RETRY, &vha->dpc_flags)) {\r\nif (IS_QLA82XX(ha)) {\r\nql_dbg(ql_dbg_mbx, vha, 0x112b,\r\n"disabling pause transmit on port "\r\n"0 & 1.\n");\r\nqla82xx_wr_32(ha,\r\nQLA82XX_CRB_NIU + 0x98,\r\nCRB_NIU_XG_PAUSE_CTL_P0|\r\nCRB_NIU_XG_PAUSE_CTL_P1);\r\n}\r\nql_log(ql_log_info, base_vha, 0x101e,\r\n"Mailbox cmd timeout occurred, cmd=0x%x, "\r\n"mb[0]=0x%x. Scheduling ISP abort ",\r\ncommand, mcp->mb[0]);\r\nset_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags);\r\nclear_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\ncomplete(&ha->mbx_cmd_comp);\r\nif (ha->isp_ops->abort_isp(vha)) {\r\nset_bit(ISP_ABORT_NEEDED,\r\n&vha->dpc_flags);\r\n}\r\nclear_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags);\r\nql_dbg(ql_dbg_mbx, vha, 0x101f,\r\n"Finished abort_isp.\n");\r\ngoto mbx_done;\r\n}\r\n}\r\n}\r\npremature_exit:\r\ncomplete(&ha->mbx_cmd_comp);\r\nmbx_done:\r\nif (rval) {\r\nql_dbg(ql_dbg_disc, base_vha, 0x1020,\r\n"**** Failed mbx[0]=%x, mb[1]=%x, mb[2]=%x, mb[3]=%x, cmd=%x ****.\n",\r\nmcp->mb[0], mcp->mb[1], mcp->mb[2], mcp->mb[3], command);\r\n} else {\r\nql_dbg(ql_dbg_mbx, base_vha, 0x1021, "Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_load_ram(scsi_qla_host_t *vha, dma_addr_t req_dma, uint32_t risc_addr,\r\nuint32_t risc_code_size)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1022,\r\n"Entered %s.\n", __func__);\r\nif (MSW(risc_addr) || IS_FWI2_CAPABLE(ha)) {\r\nmcp->mb[0] = MBC_LOAD_RISC_RAM_EXTENDED;\r\nmcp->mb[8] = MSW(risc_addr);\r\nmcp->out_mb = MBX_8|MBX_0;\r\n} else {\r\nmcp->mb[0] = MBC_LOAD_RISC_RAM;\r\nmcp->out_mb = MBX_0;\r\n}\r\nmcp->mb[1] = LSW(risc_addr);\r\nmcp->mb[2] = MSW(req_dma);\r\nmcp->mb[3] = LSW(req_dma);\r\nmcp->mb[6] = MSW(MSD(req_dma));\r\nmcp->mb[7] = LSW(MSD(req_dma));\r\nmcp->out_mb |= MBX_7|MBX_6|MBX_3|MBX_2|MBX_1;\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nmcp->mb[4] = MSW(risc_code_size);\r\nmcp->mb[5] = LSW(risc_code_size);\r\nmcp->out_mb |= MBX_5|MBX_4;\r\n} else {\r\nmcp->mb[4] = LSW(risc_code_size);\r\nmcp->out_mb |= MBX_4;\r\n}\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1023,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1024,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_execute_fw(scsi_qla_host_t *vha, uint32_t risc_addr)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1025,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_EXECUTE_FIRMWARE;\r\nmcp->out_mb = MBX_0;\r\nmcp->in_mb = MBX_0;\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nmcp->mb[1] = MSW(risc_addr);\r\nmcp->mb[2] = LSW(risc_addr);\r\nmcp->mb[3] = 0;\r\nif (IS_QLA25XX(ha) || IS_QLA81XX(ha) || IS_QLA83XX(ha) ||\r\nIS_QLA27XX(ha)) {\r\nstruct nvram_81xx *nv = ha->nvram;\r\nmcp->mb[4] = (nv->enhanced_features &\r\nEXTENDED_BB_CREDITS);\r\n} else\r\nmcp->mb[4] = 0;\r\nmcp->out_mb |= MBX_4|MBX_3|MBX_2|MBX_1;\r\nmcp->in_mb |= MBX_1;\r\n} else {\r\nmcp->mb[1] = LSW(risc_addr);\r\nmcp->out_mb |= MBX_1;\r\nif (IS_QLA2322(ha) || IS_QLA6322(ha)) {\r\nmcp->mb[2] = 0;\r\nmcp->out_mb |= MBX_2;\r\n}\r\n}\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1026,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1027,\r\n"Done exchanges=%x.\n", mcp->mb[1]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1028,\r\n"Done %s.\n", __func__);\r\n}\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_get_fw_version(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1029,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_GET_FIRMWARE_VERSION;\r\nmcp->out_mb = MBX_0;\r\nmcp->in_mb = MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nif (IS_QLA81XX(vha->hw) || IS_QLA8031(ha) || IS_QLA8044(ha))\r\nmcp->in_mb |= MBX_13|MBX_12|MBX_11|MBX_10|MBX_9|MBX_8;\r\nif (IS_FWI2_CAPABLE(ha))\r\nmcp->in_mb |= MBX_17|MBX_16|MBX_15;\r\nif (IS_QLA27XX(ha))\r\nmcp->in_mb |= MBX_21|MBX_20|MBX_19|MBX_18;\r\nmcp->flags = 0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS)\r\ngoto failed;\r\nha->fw_major_version = mcp->mb[1];\r\nha->fw_minor_version = mcp->mb[2];\r\nha->fw_subminor_version = mcp->mb[3];\r\nha->fw_attributes = mcp->mb[6];\r\nif (IS_QLA2100(vha->hw) || IS_QLA2200(vha->hw))\r\nha->fw_memory_size = 0x1FFFF;\r\nelse\r\nha->fw_memory_size = (mcp->mb[5] << 16) | mcp->mb[4];\r\nif (IS_QLA81XX(vha->hw) || IS_QLA8031(vha->hw) || IS_QLA8044(ha)) {\r\nha->mpi_version[0] = mcp->mb[10] & 0xff;\r\nha->mpi_version[1] = mcp->mb[11] >> 8;\r\nha->mpi_version[2] = mcp->mb[11] & 0xff;\r\nha->mpi_capabilities = (mcp->mb[12] << 16) | mcp->mb[13];\r\nha->phy_version[0] = mcp->mb[8] & 0xff;\r\nha->phy_version[1] = mcp->mb[9] >> 8;\r\nha->phy_version[2] = mcp->mb[9] & 0xff;\r\n}\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nha->fw_attributes_h = mcp->mb[15];\r\nha->fw_attributes_ext[0] = mcp->mb[16];\r\nha->fw_attributes_ext[1] = mcp->mb[17];\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1139,\r\n"%s: FW_attributes Upper: 0x%x, Lower: 0x%x.\n",\r\n__func__, mcp->mb[15], mcp->mb[6]);\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x112f,\r\n"%s: Ext_FwAttributes Upper: 0x%x, Lower: 0x%x.\n",\r\n__func__, mcp->mb[17], mcp->mb[16]);\r\n}\r\nif (IS_QLA27XX(ha)) {\r\nha->fw_shared_ram_start = (mcp->mb[19] << 16) | mcp->mb[18];\r\nha->fw_shared_ram_end = (mcp->mb[21] << 16) | mcp->mb[20];\r\n}\r\nfailed:\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x102a, "Failed=%x.\n", rval);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x102b,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_get_fw_options(scsi_qla_host_t *vha, uint16_t *fwopts)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x102c,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_GET_FIRMWARE_OPTION;\r\nmcp->out_mb = MBX_0;\r\nmcp->in_mb = MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x102d, "Failed=%x.\n", rval);\r\n} else {\r\nfwopts[0] = mcp->mb[0];\r\nfwopts[1] = mcp->mb[1];\r\nfwopts[2] = mcp->mb[2];\r\nfwopts[3] = mcp->mb[3];\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x102e,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_set_fw_options(scsi_qla_host_t *vha, uint16_t *fwopts)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x102f,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_SET_FIRMWARE_OPTION;\r\nmcp->mb[1] = fwopts[1];\r\nmcp->mb[2] = fwopts[2];\r\nmcp->mb[3] = fwopts[3];\r\nmcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nif (IS_FWI2_CAPABLE(vha->hw)) {\r\nmcp->in_mb |= MBX_1;\r\n} else {\r\nmcp->mb[10] = fwopts[10];\r\nmcp->mb[11] = fwopts[11];\r\nmcp->mb[12] = 0;\r\nmcp->out_mb |= MBX_12|MBX_11|MBX_10;\r\n}\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nfwopts[0] = mcp->mb[0];\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1030,\r\n"Failed=%x (%x/%x).\n", rval, mcp->mb[0], mcp->mb[1]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1031,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_mbx_reg_test(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1032,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_MAILBOX_REGISTER_TEST;\r\nmcp->mb[1] = 0xAAAA;\r\nmcp->mb[2] = 0x5555;\r\nmcp->mb[3] = 0xAA55;\r\nmcp->mb[4] = 0x55AA;\r\nmcp->mb[5] = 0xA5A5;\r\nmcp->mb[6] = 0x5A5A;\r\nmcp->mb[7] = 0x2525;\r\nmcp->out_mb = MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval == QLA_SUCCESS) {\r\nif (mcp->mb[1] != 0xAAAA || mcp->mb[2] != 0x5555 ||\r\nmcp->mb[3] != 0xAA55 || mcp->mb[4] != 0x55AA)\r\nrval = QLA_FUNCTION_FAILED;\r\nif (mcp->mb[5] != 0xA5A5 || mcp->mb[6] != 0x5A5A ||\r\nmcp->mb[7] != 0x2525)\r\nrval = QLA_FUNCTION_FAILED;\r\n}\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1033, "Failed=%x.\n", rval);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1034,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_verify_checksum(scsi_qla_host_t *vha, uint32_t risc_addr)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1035,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_VERIFY_CHECKSUM;\r\nmcp->out_mb = MBX_0;\r\nmcp->in_mb = MBX_0;\r\nif (IS_FWI2_CAPABLE(vha->hw)) {\r\nmcp->mb[1] = MSW(risc_addr);\r\nmcp->mb[2] = LSW(risc_addr);\r\nmcp->out_mb |= MBX_2|MBX_1;\r\nmcp->in_mb |= MBX_2|MBX_1;\r\n} else {\r\nmcp->mb[1] = LSW(risc_addr);\r\nmcp->out_mb |= MBX_1;\r\nmcp->in_mb |= MBX_1;\r\n}\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1036,\r\n"Failed=%x chm sum=%x.\n", rval, IS_FWI2_CAPABLE(vha->hw) ?\r\n(mcp->mb[2] << 16) | mcp->mb[1] : mcp->mb[1]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1037,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_issue_iocb_timeout(scsi_qla_host_t *vha, void *buffer,\r\ndma_addr_t phys_addr, size_t size, uint32_t tov)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1038,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_IOCB_COMMAND_A64;\r\nmcp->mb[1] = 0;\r\nmcp->mb[2] = MSW(phys_addr);\r\nmcp->mb[3] = LSW(phys_addr);\r\nmcp->mb[6] = MSW(MSD(phys_addr));\r\nmcp->mb[7] = LSW(MSD(phys_addr));\r\nmcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_2|MBX_0;\r\nmcp->tov = tov;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1039, "Failed=%x.\n", rval);\r\n} else {\r\nsts_entry_t *sts_entry = (sts_entry_t *) buffer;\r\nsts_entry->entry_status &=\r\nIS_FWI2_CAPABLE(vha->hw) ? RF_MASK_24XX : RF_MASK;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x103a,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_issue_iocb(scsi_qla_host_t *vha, void *buffer, dma_addr_t phys_addr,\r\nsize_t size)\r\n{\r\nreturn qla2x00_issue_iocb_timeout(vha, buffer, phys_addr, size,\r\nMBX_TOV_SECONDS);\r\n}\r\nint\r\nqla2x00_abort_command(srb_t *sp)\r\n{\r\nunsigned long flags = 0;\r\nint rval;\r\nuint32_t handle = 0;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nfc_port_t *fcport = sp->fcport;\r\nscsi_qla_host_t *vha = fcport->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = vha->req;\r\nstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x103b,\r\n"Entered %s.\n", __func__);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nfor (handle = 1; handle < req->num_outstanding_cmds; handle++) {\r\nif (req->outstanding_cmds[handle] == sp)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (handle == req->num_outstanding_cmds) {\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nmcp->mb[0] = MBC_ABORT_COMMAND;\r\nif (HAS_EXTENDED_IDS(ha))\r\nmcp->mb[1] = fcport->loop_id;\r\nelse\r\nmcp->mb[1] = fcport->loop_id << 8;\r\nmcp->mb[2] = (uint16_t)handle;\r\nmcp->mb[3] = (uint16_t)(handle >> 16);\r\nmcp->mb[6] = (uint16_t)cmd->device->lun;\r\nmcp->out_mb = MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x103c, "Failed=%x.\n", rval);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x103d,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_abort_target(struct fc_port *fcport, uint64_t l, int tag)\r\n{\r\nint rval, rval2;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nscsi_qla_host_t *vha;\r\nstruct req_que *req;\r\nstruct rsp_que *rsp;\r\nl = l;\r\nvha = fcport->vha;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x103e,\r\n"Entered %s.\n", __func__);\r\nreq = vha->hw->req_q_map[0];\r\nrsp = req->rsp;\r\nmcp->mb[0] = MBC_ABORT_TARGET;\r\nmcp->out_mb = MBX_9|MBX_2|MBX_1|MBX_0;\r\nif (HAS_EXTENDED_IDS(vha->hw)) {\r\nmcp->mb[1] = fcport->loop_id;\r\nmcp->mb[10] = 0;\r\nmcp->out_mb |= MBX_10;\r\n} else {\r\nmcp->mb[1] = fcport->loop_id << 8;\r\n}\r\nmcp->mb[2] = vha->hw->loop_reset_delay;\r\nmcp->mb[9] = vha->vp_idx;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x103f,\r\n"Failed=%x.\n", rval);\r\n}\r\nrval2 = qla2x00_marker(vha, req, rsp, fcport->loop_id, 0,\r\nMK_SYNC_ID);\r\nif (rval2 != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1040,\r\n"Failed to issue marker IOCB (%x).\n", rval2);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1041,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_lun_reset(struct fc_port *fcport, uint64_t l, int tag)\r\n{\r\nint rval, rval2;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nscsi_qla_host_t *vha;\r\nstruct req_que *req;\r\nstruct rsp_que *rsp;\r\nvha = fcport->vha;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1042,\r\n"Entered %s.\n", __func__);\r\nreq = vha->hw->req_q_map[0];\r\nrsp = req->rsp;\r\nmcp->mb[0] = MBC_LUN_RESET;\r\nmcp->out_mb = MBX_9|MBX_3|MBX_2|MBX_1|MBX_0;\r\nif (HAS_EXTENDED_IDS(vha->hw))\r\nmcp->mb[1] = fcport->loop_id;\r\nelse\r\nmcp->mb[1] = fcport->loop_id << 8;\r\nmcp->mb[2] = (u32)l;\r\nmcp->mb[3] = 0;\r\nmcp->mb[9] = vha->vp_idx;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1043, "Failed=%x.\n", rval);\r\n}\r\nrval2 = qla2x00_marker(vha, req, rsp, fcport->loop_id, l,\r\nMK_SYNC_ID_LUN);\r\nif (rval2 != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1044,\r\n"Failed to issue marker IOCB (%x).\n", rval2);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1045,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_get_adapter_id(scsi_qla_host_t *vha, uint16_t *id, uint8_t *al_pa,\r\nuint8_t *area, uint8_t *domain, uint16_t *top, uint16_t *sw_cap)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1046,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_GET_ADAPTER_LOOP_ID;\r\nmcp->mb[9] = vha->vp_idx;\r\nmcp->out_mb = MBX_9|MBX_0;\r\nmcp->in_mb = MBX_9|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\r\nif (IS_CNA_CAPABLE(vha->hw))\r\nmcp->in_mb |= MBX_13|MBX_12|MBX_11|MBX_10;\r\nif (IS_FWI2_CAPABLE(vha->hw))\r\nmcp->in_mb |= MBX_19|MBX_18|MBX_17|MBX_16;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (mcp->mb[0] == MBS_COMMAND_ERROR)\r\nrval = QLA_COMMAND_ERROR;\r\nelse if (mcp->mb[0] == MBS_INVALID_COMMAND)\r\nrval = QLA_INVALID_COMMAND;\r\n*id = mcp->mb[1];\r\n*al_pa = LSB(mcp->mb[2]);\r\n*area = MSB(mcp->mb[2]);\r\n*domain = LSB(mcp->mb[3]);\r\n*top = mcp->mb[6];\r\n*sw_cap = mcp->mb[7];\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1047, "Failed=%x.\n", rval);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1048,\r\n"Done %s.\n", __func__);\r\nif (IS_CNA_CAPABLE(vha->hw)) {\r\nvha->fcoe_vlan_id = mcp->mb[9] & 0xfff;\r\nvha->fcoe_fcf_idx = mcp->mb[10];\r\nvha->fcoe_vn_port_mac[5] = mcp->mb[11] >> 8;\r\nvha->fcoe_vn_port_mac[4] = mcp->mb[11] & 0xff;\r\nvha->fcoe_vn_port_mac[3] = mcp->mb[12] >> 8;\r\nvha->fcoe_vn_port_mac[2] = mcp->mb[12] & 0xff;\r\nvha->fcoe_vn_port_mac[1] = mcp->mb[13] >> 8;\r\nvha->fcoe_vn_port_mac[0] = mcp->mb[13] & 0xff;\r\n}\r\nif (mcp->mb[7] & BIT_14) {\r\nvha->port_name[0] = MSB(mcp->mb[16]);\r\nvha->port_name[1] = LSB(mcp->mb[16]);\r\nvha->port_name[2] = MSB(mcp->mb[17]);\r\nvha->port_name[3] = LSB(mcp->mb[17]);\r\nvha->port_name[4] = MSB(mcp->mb[18]);\r\nvha->port_name[5] = LSB(mcp->mb[18]);\r\nvha->port_name[6] = MSB(mcp->mb[19]);\r\nvha->port_name[7] = LSB(mcp->mb[19]);\r\nfc_host_port_name(vha->host) =\r\nwwn_to_u64(vha->port_name);\r\nql_dbg(ql_dbg_mbx, vha, 0x10ca,\r\n"FA-WWN acquired %016llx\n",\r\nwwn_to_u64(vha->port_name));\r\n}\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_get_retry_cnt(scsi_qla_host_t *vha, uint8_t *retry_cnt, uint8_t *tov,\r\nuint16_t *r_a_tov)\r\n{\r\nint rval;\r\nuint16_t ratov;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1049,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_GET_RETRY_COUNT;\r\nmcp->out_mb = MBX_0;\r\nmcp->in_mb = MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x104a,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\n*r_a_tov = mcp->mb[3] / 2;\r\nratov = (mcp->mb[3]/2) / 10;\r\nif (mcp->mb[1] * ratov > (*retry_cnt) * (*tov)) {\r\n*retry_cnt = (uint8_t)mcp->mb[1];\r\n*tov = ratov;\r\n}\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x104b,\r\n"Done %s mb3=%d ratov=%d.\n", __func__, mcp->mb[3], ratov);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_init_firmware(scsi_qla_host_t *vha, uint16_t size)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x104c,\r\n"Entered %s.\n", __func__);\r\nif (IS_P3P_TYPE(ha) && ql2xdbwr)\r\nqla82xx_wr_32(ha, ha->nxdb_wr_ptr,\r\n(0x04 | (ha->portnum << 5) | (0 << 8) | (0 << 16)));\r\nif (ha->flags.npiv_supported)\r\nmcp->mb[0] = MBC_MID_INITIALIZE_FIRMWARE;\r\nelse\r\nmcp->mb[0] = MBC_INITIALIZE_FIRMWARE;\r\nmcp->mb[1] = 0;\r\nmcp->mb[2] = MSW(ha->init_cb_dma);\r\nmcp->mb[3] = LSW(ha->init_cb_dma);\r\nmcp->mb[6] = MSW(MSD(ha->init_cb_dma));\r\nmcp->mb[7] = LSW(MSD(ha->init_cb_dma));\r\nmcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\r\nif (ha->ex_init_cb && ha->ex_init_cb->ex_version) {\r\nmcp->mb[1] = BIT_0;\r\nmcp->mb[10] = MSW(ha->ex_init_cb_dma);\r\nmcp->mb[11] = LSW(ha->ex_init_cb_dma);\r\nmcp->mb[12] = MSW(MSD(ha->ex_init_cb_dma));\r\nmcp->mb[13] = LSW(MSD(ha->ex_init_cb_dma));\r\nmcp->mb[14] = sizeof(*ha->ex_init_cb);\r\nmcp->out_mb |= MBX_14|MBX_13|MBX_12|MBX_11|MBX_10;\r\n}\r\nmcp->in_mb = MBX_2|MBX_1|MBX_0;\r\nif (IS_QLA83XX(ha) || IS_QLA27XX(ha))\r\nmcp->in_mb |= MBX_3;\r\nmcp->buf_size = size;\r\nmcp->flags = MBX_DMA_OUT;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x104d,\r\n"Failed=%x mb[0]=%x, mb[1]=%x, mb[2]=%x, mb[3]=%x,.\n",\r\nrval, mcp->mb[0], mcp->mb[1], mcp->mb[2], mcp->mb[3]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x104e,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_get_node_name_list(scsi_qla_host_t *vha, void **out_data, int *out_len)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_port_24xx_data *list = NULL;\r\nvoid *pmap;\r\nmbx_cmd_t mc;\r\ndma_addr_t pmap_dma;\r\nulong dma_size;\r\nint rval, left;\r\nleft = 1;\r\nwhile (left > 0) {\r\ndma_size = left * sizeof(*list);\r\npmap = dma_alloc_coherent(&ha->pdev->dev, dma_size,\r\n&pmap_dma, GFP_KERNEL);\r\nif (!pmap) {\r\nql_log(ql_log_warn, vha, 0x113f,\r\n"%s(%ld): DMA Alloc failed of %ld\n",\r\n__func__, vha->host_no, dma_size);\r\nrval = QLA_MEMORY_ALLOC_FAILED;\r\ngoto out;\r\n}\r\nmc.mb[0] = MBC_PORT_NODE_NAME_LIST;\r\nmc.mb[1] = BIT_1 | BIT_3;\r\nmc.mb[2] = MSW(pmap_dma);\r\nmc.mb[3] = LSW(pmap_dma);\r\nmc.mb[6] = MSW(MSD(pmap_dma));\r\nmc.mb[7] = LSW(MSD(pmap_dma));\r\nmc.mb[8] = dma_size;\r\nmc.out_mb = MBX_0|MBX_1|MBX_2|MBX_3|MBX_6|MBX_7|MBX_8;\r\nmc.in_mb = MBX_0|MBX_1;\r\nmc.tov = 30;\r\nmc.flags = MBX_DMA_IN;\r\nrval = qla2x00_mailbox_command(vha, &mc);\r\nif (rval != QLA_SUCCESS) {\r\nif ((mc.mb[0] == MBS_COMMAND_ERROR) &&\r\n(mc.mb[1] == 0xA)) {\r\nleft += le16_to_cpu(mc.mb[2]) /\r\nsizeof(struct qla_port_24xx_data);\r\ngoto restart;\r\n}\r\ngoto out_free;\r\n}\r\nleft = 0;\r\nlist = kmemdup(pmap, dma_size, GFP_KERNEL);\r\nif (!list) {\r\nql_log(ql_log_warn, vha, 0x1140,\r\n"%s(%ld): failed to allocate node names list "\r\n"structure.\n", __func__, vha->host_no);\r\nrval = QLA_MEMORY_ALLOC_FAILED;\r\ngoto out_free;\r\n}\r\nrestart:\r\ndma_free_coherent(&ha->pdev->dev, dma_size, pmap, pmap_dma);\r\n}\r\n*out_data = list;\r\n*out_len = dma_size;\r\nout:\r\nreturn rval;\r\nout_free:\r\ndma_free_coherent(&ha->pdev->dev, dma_size, pmap, pmap_dma);\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_get_port_database(scsi_qla_host_t *vha, fc_port_t *fcport, uint8_t opt)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nport_database_t *pd;\r\nstruct port_database_24xx *pd24;\r\ndma_addr_t pd_dma;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x104f,\r\n"Entered %s.\n", __func__);\r\npd24 = NULL;\r\npd = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &pd_dma);\r\nif (pd == NULL) {\r\nql_log(ql_log_warn, vha, 0x1050,\r\n"Failed to allocate port database structure.\n");\r\nreturn QLA_MEMORY_ALLOC_FAILED;\r\n}\r\nmemset(pd, 0, max(PORT_DATABASE_SIZE, PORT_DATABASE_24XX_SIZE));\r\nmcp->mb[0] = MBC_GET_PORT_DATABASE;\r\nif (opt != 0 && !IS_FWI2_CAPABLE(ha))\r\nmcp->mb[0] = MBC_ENHANCED_GET_PORT_DATABASE;\r\nmcp->mb[2] = MSW(pd_dma);\r\nmcp->mb[3] = LSW(pd_dma);\r\nmcp->mb[6] = MSW(MSD(pd_dma));\r\nmcp->mb[7] = LSW(MSD(pd_dma));\r\nmcp->mb[9] = vha->vp_idx;\r\nmcp->out_mb = MBX_9|MBX_7|MBX_6|MBX_3|MBX_2|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nmcp->mb[1] = fcport->loop_id;\r\nmcp->mb[10] = opt;\r\nmcp->out_mb |= MBX_10|MBX_1;\r\nmcp->in_mb |= MBX_1;\r\n} else if (HAS_EXTENDED_IDS(ha)) {\r\nmcp->mb[1] = fcport->loop_id;\r\nmcp->mb[10] = opt;\r\nmcp->out_mb |= MBX_10|MBX_1;\r\n} else {\r\nmcp->mb[1] = fcport->loop_id << 8 | opt;\r\nmcp->out_mb |= MBX_1;\r\n}\r\nmcp->buf_size = IS_FWI2_CAPABLE(ha) ?\r\nPORT_DATABASE_24XX_SIZE : PORT_DATABASE_SIZE;\r\nmcp->flags = MBX_DMA_IN;\r\nmcp->tov = (ha->login_timeout * 2) + (ha->login_timeout / 2);\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS)\r\ngoto gpd_error_out;\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nuint64_t zero = 0;\r\npd24 = (struct port_database_24xx *) pd;\r\nif (pd24->current_login_state != PDS_PRLI_COMPLETE &&\r\npd24->last_login_state != PDS_PRLI_COMPLETE) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1051,\r\n"Unable to verify login-state (%x/%x) for "\r\n"loop_id %x.\n", pd24->current_login_state,\r\npd24->last_login_state, fcport->loop_id);\r\nrval = QLA_FUNCTION_FAILED;\r\ngoto gpd_error_out;\r\n}\r\nif (fcport->loop_id == FC_NO_LOOP_ID ||\r\n(memcmp(fcport->port_name, (uint8_t *)&zero, 8) &&\r\nmemcmp(fcport->port_name, pd24->port_name, 8))) {\r\nrval = QLA_NOT_LOGGED_IN;\r\ngoto gpd_error_out;\r\n}\r\nmemcpy(fcport->node_name, pd24->node_name, WWN_SIZE);\r\nmemcpy(fcport->port_name, pd24->port_name, WWN_SIZE);\r\nfcport->d_id.b.domain = pd24->port_id[0];\r\nfcport->d_id.b.area = pd24->port_id[1];\r\nfcport->d_id.b.al_pa = pd24->port_id[2];\r\nfcport->d_id.b.rsvd_1 = 0;\r\nif ((pd24->prli_svc_param_word_3[0] & BIT_4) == 0)\r\nfcport->port_type = FCT_INITIATOR;\r\nelse\r\nfcport->port_type = FCT_TARGET;\r\nfcport->supported_classes = (pd24->flags & PDF_CLASS_2) ?\r\nFC_COS_CLASS2 : FC_COS_CLASS3;\r\nif (pd24->prli_svc_param_word_3[0] & BIT_7)\r\nfcport->flags |= FCF_CONF_COMP_SUPPORTED;\r\n} else {\r\nuint64_t zero = 0;\r\nif (pd->master_state != PD_STATE_PORT_LOGGED_IN &&\r\npd->slave_state != PD_STATE_PORT_LOGGED_IN) {\r\nql_dbg(ql_dbg_mbx, vha, 0x100a,\r\n"Unable to verify login-state (%x/%x) - "\r\n"portid=%02x%02x%02x.\n", pd->master_state,\r\npd->slave_state, fcport->d_id.b.domain,\r\nfcport->d_id.b.area, fcport->d_id.b.al_pa);\r\nrval = QLA_FUNCTION_FAILED;\r\ngoto gpd_error_out;\r\n}\r\nif (fcport->loop_id == FC_NO_LOOP_ID ||\r\n(memcmp(fcport->port_name, (uint8_t *)&zero, 8) &&\r\nmemcmp(fcport->port_name, pd->port_name, 8))) {\r\nrval = QLA_NOT_LOGGED_IN;\r\ngoto gpd_error_out;\r\n}\r\nmemcpy(fcport->node_name, pd->node_name, WWN_SIZE);\r\nmemcpy(fcport->port_name, pd->port_name, WWN_SIZE);\r\nfcport->d_id.b.domain = pd->port_id[0];\r\nfcport->d_id.b.area = pd->port_id[3];\r\nfcport->d_id.b.al_pa = pd->port_id[2];\r\nfcport->d_id.b.rsvd_1 = 0;\r\nif ((pd->prli_svc_param_word_3[0] & BIT_4) == 0)\r\nfcport->port_type = FCT_INITIATOR;\r\nelse\r\nfcport->port_type = FCT_TARGET;\r\nfcport->supported_classes = (pd->options & BIT_4) ?\r\nFC_COS_CLASS2: FC_COS_CLASS3;\r\n}\r\ngpd_error_out:\r\ndma_pool_free(ha->s_dma_pool, pd, pd_dma);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1052,\r\n"Failed=%x mb[0]=%x mb[1]=%x.\n", rval,\r\nmcp->mb[0], mcp->mb[1]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1053,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_get_firmware_state(scsi_qla_host_t *vha, uint16_t *states)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1054,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_GET_FIRMWARE_STATE;\r\nmcp->out_mb = MBX_0;\r\nif (IS_FWI2_CAPABLE(vha->hw))\r\nmcp->in_mb = MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nelse\r\nmcp->in_mb = MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nstates[0] = mcp->mb[1];\r\nif (IS_FWI2_CAPABLE(vha->hw)) {\r\nstates[1] = mcp->mb[2];\r\nstates[2] = mcp->mb[3];\r\nstates[3] = mcp->mb[4];\r\nstates[4] = mcp->mb[5];\r\nstates[5] = mcp->mb[6];\r\n}\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1055, "Failed=%x.\n", rval);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1056,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_get_port_name(scsi_qla_host_t *vha, uint16_t loop_id, uint8_t *name,\r\nuint8_t opt)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1057,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_GET_PORT_NAME;\r\nmcp->mb[9] = vha->vp_idx;\r\nmcp->out_mb = MBX_9|MBX_1|MBX_0;\r\nif (HAS_EXTENDED_IDS(vha->hw)) {\r\nmcp->mb[1] = loop_id;\r\nmcp->mb[10] = opt;\r\nmcp->out_mb |= MBX_10;\r\n} else {\r\nmcp->mb[1] = loop_id << 8 | opt;\r\n}\r\nmcp->in_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1058, "Failed=%x.\n", rval);\r\n} else {\r\nif (name != NULL) {\r\nname[0] = MSB(mcp->mb[2]);\r\nname[1] = LSB(mcp->mb[2]);\r\nname[2] = MSB(mcp->mb[3]);\r\nname[3] = LSB(mcp->mb[3]);\r\nname[4] = MSB(mcp->mb[6]);\r\nname[5] = LSB(mcp->mb[6]);\r\nname[6] = MSB(mcp->mb[7]);\r\nname[7] = LSB(mcp->mb[7]);\r\n}\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1059,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla24xx_link_initialize(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1152,\r\n"Entered %s.\n", __func__);\r\nif (!IS_FWI2_CAPABLE(vha->hw) || IS_CNA_CAPABLE(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nmcp->mb[0] = MBC_LINK_INITIALIZATION;\r\nmcp->mb[1] = BIT_4;\r\nif (vha->hw->operating_mode == LOOP)\r\nmcp->mb[1] |= BIT_6;\r\nelse\r\nmcp->mb[1] |= BIT_5;\r\nmcp->mb[2] = 0;\r\nmcp->mb[3] = 0;\r\nmcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1153, "Failed=%x.\n", rval);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1154,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_lip_reset(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x105a,\r\n"Entered %s.\n", __func__);\r\nif (IS_CNA_CAPABLE(vha->hw)) {\r\nmcp->mb[0] = MBC_LIP_FULL_LOGIN;\r\nmcp->mb[1] = BIT_1;\r\nmcp->mb[2] = 0;\r\nmcp->out_mb = MBX_2|MBX_1|MBX_0;\r\n} else if (IS_FWI2_CAPABLE(vha->hw)) {\r\nmcp->mb[0] = MBC_LIP_FULL_LOGIN;\r\nmcp->mb[1] = BIT_6;\r\nmcp->mb[2] = 0;\r\nmcp->mb[3] = vha->hw->loop_reset_delay;\r\nmcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;\r\n} else {\r\nmcp->mb[0] = MBC_LIP_RESET;\r\nmcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;\r\nif (HAS_EXTENDED_IDS(vha->hw)) {\r\nmcp->mb[1] = 0x00ff;\r\nmcp->mb[10] = 0;\r\nmcp->out_mb |= MBX_10;\r\n} else {\r\nmcp->mb[1] = 0xff00;\r\n}\r\nmcp->mb[2] = vha->hw->loop_reset_delay;\r\nmcp->mb[3] = 0;\r\n}\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x105b, "Failed=%x.\n", rval);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x105c,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_send_sns(scsi_qla_host_t *vha, dma_addr_t sns_phys_address,\r\nuint16_t cmd_size, size_t buf_size)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x105d,\r\n"Entered %s.\n", __func__);\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x105e,\r\n"Retry cnt=%d ratov=%d total tov=%d.\n",\r\nvha->hw->retry_count, vha->hw->login_timeout, mcp->tov);\r\nmcp->mb[0] = MBC_SEND_SNS_COMMAND;\r\nmcp->mb[1] = cmd_size;\r\nmcp->mb[2] = MSW(sns_phys_address);\r\nmcp->mb[3] = LSW(sns_phys_address);\r\nmcp->mb[6] = MSW(MSD(sns_phys_address));\r\nmcp->mb[7] = LSW(MSD(sns_phys_address));\r\nmcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0|MBX_1;\r\nmcp->buf_size = buf_size;\r\nmcp->flags = MBX_DMA_OUT|MBX_DMA_IN;\r\nmcp->tov = (vha->hw->login_timeout * 2) + (vha->hw->login_timeout / 2);\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x105f,\r\n"Failed=%x mb[0]=%x mb[1]=%x.\n",\r\nrval, mcp->mb[0], mcp->mb[1]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1060,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla24xx_login_fabric(scsi_qla_host_t *vha, uint16_t loop_id, uint8_t domain,\r\nuint8_t area, uint8_t al_pa, uint16_t *mb, uint8_t opt)\r\n{\r\nint rval;\r\nstruct logio_entry_24xx *lg;\r\ndma_addr_t lg_dma;\r\nuint32_t iop[2];\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req;\r\nstruct rsp_que *rsp;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1061,\r\n"Entered %s.\n", __func__);\r\nif (ha->flags.cpu_affinity_enabled)\r\nreq = ha->req_q_map[0];\r\nelse\r\nreq = vha->req;\r\nrsp = req->rsp;\r\nlg = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &lg_dma);\r\nif (lg == NULL) {\r\nql_log(ql_log_warn, vha, 0x1062,\r\n"Failed to allocate login IOCB.\n");\r\nreturn QLA_MEMORY_ALLOC_FAILED;\r\n}\r\nmemset(lg, 0, sizeof(struct logio_entry_24xx));\r\nlg->entry_type = LOGINOUT_PORT_IOCB_TYPE;\r\nlg->entry_count = 1;\r\nlg->handle = MAKE_HANDLE(req->id, lg->handle);\r\nlg->nport_handle = cpu_to_le16(loop_id);\r\nlg->control_flags = __constant_cpu_to_le16(LCF_COMMAND_PLOGI);\r\nif (opt & BIT_0)\r\nlg->control_flags |= __constant_cpu_to_le16(LCF_COND_PLOGI);\r\nif (opt & BIT_1)\r\nlg->control_flags |= __constant_cpu_to_le16(LCF_SKIP_PRLI);\r\nlg->port_id[0] = al_pa;\r\nlg->port_id[1] = area;\r\nlg->port_id[2] = domain;\r\nlg->vp_index = vha->vp_idx;\r\nrval = qla2x00_issue_iocb_timeout(vha, lg, lg_dma, 0,\r\n(ha->r_a_tov / 10 * 2) + 2);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1063,\r\n"Failed to issue login IOCB (%x).\n", rval);\r\n} else if (lg->entry_status != 0) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1064,\r\n"Failed to complete IOCB -- error status (%x).\n",\r\nlg->entry_status);\r\nrval = QLA_FUNCTION_FAILED;\r\n} else if (lg->comp_status != __constant_cpu_to_le16(CS_COMPLETE)) {\r\niop[0] = le32_to_cpu(lg->io_parameter[0]);\r\niop[1] = le32_to_cpu(lg->io_parameter[1]);\r\nql_dbg(ql_dbg_mbx, vha, 0x1065,\r\n"Failed to complete IOCB -- completion status (%x) "\r\n"ioparam=%x/%x.\n", le16_to_cpu(lg->comp_status),\r\niop[0], iop[1]);\r\nswitch (iop[0]) {\r\ncase LSC_SCODE_PORTID_USED:\r\nmb[0] = MBS_PORT_ID_USED;\r\nmb[1] = LSW(iop[1]);\r\nbreak;\r\ncase LSC_SCODE_NPORT_USED:\r\nmb[0] = MBS_LOOP_ID_USED;\r\nbreak;\r\ncase LSC_SCODE_NOLINK:\r\ncase LSC_SCODE_NOIOCB:\r\ncase LSC_SCODE_NOXCB:\r\ncase LSC_SCODE_CMD_FAILED:\r\ncase LSC_SCODE_NOFABRIC:\r\ncase LSC_SCODE_FW_NOT_READY:\r\ncase LSC_SCODE_NOT_LOGGED_IN:\r\ncase LSC_SCODE_NOPCB:\r\ncase LSC_SCODE_ELS_REJECT:\r\ncase LSC_SCODE_CMD_PARAM_ERR:\r\ncase LSC_SCODE_NONPORT:\r\ncase LSC_SCODE_LOGGED_IN:\r\ncase LSC_SCODE_NOFLOGI_ACC:\r\ndefault:\r\nmb[0] = MBS_COMMAND_ERROR;\r\nbreak;\r\n}\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1066,\r\n"Done %s.\n", __func__);\r\niop[0] = le32_to_cpu(lg->io_parameter[0]);\r\nmb[0] = MBS_COMMAND_COMPLETE;\r\nmb[1] = 0;\r\nif (iop[0] & BIT_4) {\r\nif (iop[0] & BIT_8)\r\nmb[1] |= BIT_1;\r\n} else\r\nmb[1] = BIT_0;\r\nmb[10] = 0;\r\nif (lg->io_parameter[7] || lg->io_parameter[8])\r\nmb[10] |= BIT_0;\r\nif (lg->io_parameter[9] || lg->io_parameter[10])\r\nmb[10] |= BIT_1;\r\nif (lg->io_parameter[0] & __constant_cpu_to_le32(BIT_7))\r\nmb[10] |= BIT_7;\r\n}\r\ndma_pool_free(ha->s_dma_pool, lg, lg_dma);\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_login_fabric(scsi_qla_host_t *vha, uint16_t loop_id, uint8_t domain,\r\nuint8_t area, uint8_t al_pa, uint16_t *mb, uint8_t opt)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1067,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_LOGIN_FABRIC_PORT;\r\nmcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;\r\nif (HAS_EXTENDED_IDS(ha)) {\r\nmcp->mb[1] = loop_id;\r\nmcp->mb[10] = opt;\r\nmcp->out_mb |= MBX_10;\r\n} else {\r\nmcp->mb[1] = (loop_id << 8) | opt;\r\n}\r\nmcp->mb[2] = domain;\r\nmcp->mb[3] = area << 8 | al_pa;\r\nmcp->in_mb = MBX_7|MBX_6|MBX_2|MBX_1|MBX_0;\r\nmcp->tov = (ha->login_timeout * 2) + (ha->login_timeout / 2);\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (mb != NULL) {\r\nmb[0] = mcp->mb[0];\r\nmb[1] = mcp->mb[1];\r\nmb[2] = mcp->mb[2];\r\nmb[6] = mcp->mb[6];\r\nmb[7] = mcp->mb[7];\r\nmb[10] = 0;\r\n}\r\nif (rval != QLA_SUCCESS) {\r\nif (mcp->mb[0] == 0x4001 || mcp->mb[0] == 0x4002 ||\r\nmcp->mb[0] == 0x4003 || mcp->mb[0] == 0x4005 ||\r\nmcp->mb[0] == 0x4006)\r\nrval = QLA_SUCCESS;\r\nql_dbg(ql_dbg_mbx, vha, 0x1068,\r\n"Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x.\n",\r\nrval, mcp->mb[0], mcp->mb[1], mcp->mb[2]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1069,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_login_local_device(scsi_qla_host_t *vha, fc_port_t *fcport,\r\nuint16_t *mb_ret, uint8_t opt)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x106a,\r\n"Entered %s.\n", __func__);\r\nif (IS_FWI2_CAPABLE(ha))\r\nreturn qla24xx_login_fabric(vha, fcport->loop_id,\r\nfcport->d_id.b.domain, fcport->d_id.b.area,\r\nfcport->d_id.b.al_pa, mb_ret, opt);\r\nmcp->mb[0] = MBC_LOGIN_LOOP_PORT;\r\nif (HAS_EXTENDED_IDS(ha))\r\nmcp->mb[1] = fcport->loop_id;\r\nelse\r\nmcp->mb[1] = fcport->loop_id << 8;\r\nmcp->mb[2] = opt;\r\nmcp->out_mb = MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_7|MBX_6|MBX_1|MBX_0;\r\nmcp->tov = (ha->login_timeout * 2) + (ha->login_timeout / 2);\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (mb_ret != NULL) {\r\nmb_ret[0] = mcp->mb[0];\r\nmb_ret[1] = mcp->mb[1];\r\nmb_ret[6] = mcp->mb[6];\r\nmb_ret[7] = mcp->mb[7];\r\n}\r\nif (rval != QLA_SUCCESS) {\r\nif (mcp->mb[0] == 0x4005 || mcp->mb[0] == 0x4006)\r\nrval = QLA_SUCCESS;\r\nql_dbg(ql_dbg_mbx, vha, 0x106b,\r\n"Failed=%x mb[0]=%x mb[1]=%x mb[6]=%x mb[7]=%x.\n",\r\nrval, mcp->mb[0], mcp->mb[1], mcp->mb[6], mcp->mb[7]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x106c,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn (rval);\r\n}\r\nint\r\nqla24xx_fabric_logout(scsi_qla_host_t *vha, uint16_t loop_id, uint8_t domain,\r\nuint8_t area, uint8_t al_pa)\r\n{\r\nint rval;\r\nstruct logio_entry_24xx *lg;\r\ndma_addr_t lg_dma;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req;\r\nstruct rsp_que *rsp;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x106d,\r\n"Entered %s.\n", __func__);\r\nlg = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &lg_dma);\r\nif (lg == NULL) {\r\nql_log(ql_log_warn, vha, 0x106e,\r\n"Failed to allocate logout IOCB.\n");\r\nreturn QLA_MEMORY_ALLOC_FAILED;\r\n}\r\nmemset(lg, 0, sizeof(struct logio_entry_24xx));\r\nif (ql2xmaxqueues > 1)\r\nreq = ha->req_q_map[0];\r\nelse\r\nreq = vha->req;\r\nrsp = req->rsp;\r\nlg->entry_type = LOGINOUT_PORT_IOCB_TYPE;\r\nlg->entry_count = 1;\r\nlg->handle = MAKE_HANDLE(req->id, lg->handle);\r\nlg->nport_handle = cpu_to_le16(loop_id);\r\nlg->control_flags =\r\n__constant_cpu_to_le16(LCF_COMMAND_LOGO|LCF_IMPL_LOGO|\r\nLCF_FREE_NPORT);\r\nlg->port_id[0] = al_pa;\r\nlg->port_id[1] = area;\r\nlg->port_id[2] = domain;\r\nlg->vp_index = vha->vp_idx;\r\nrval = qla2x00_issue_iocb_timeout(vha, lg, lg_dma, 0,\r\n(ha->r_a_tov / 10 * 2) + 2);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x106f,\r\n"Failed to issue logout IOCB (%x).\n", rval);\r\n} else if (lg->entry_status != 0) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1070,\r\n"Failed to complete IOCB -- error status (%x).\n",\r\nlg->entry_status);\r\nrval = QLA_FUNCTION_FAILED;\r\n} else if (lg->comp_status != __constant_cpu_to_le16(CS_COMPLETE)) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1071,\r\n"Failed to complete IOCB -- completion status (%x) "\r\n"ioparam=%x/%x.\n", le16_to_cpu(lg->comp_status),\r\nle32_to_cpu(lg->io_parameter[0]),\r\nle32_to_cpu(lg->io_parameter[1]));\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1072,\r\n"Done %s.\n", __func__);\r\n}\r\ndma_pool_free(ha->s_dma_pool, lg, lg_dma);\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_fabric_logout(scsi_qla_host_t *vha, uint16_t loop_id, uint8_t domain,\r\nuint8_t area, uint8_t al_pa)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1073,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_LOGOUT_FABRIC_PORT;\r\nmcp->out_mb = MBX_1|MBX_0;\r\nif (HAS_EXTENDED_IDS(vha->hw)) {\r\nmcp->mb[1] = loop_id;\r\nmcp->mb[10] = 0;\r\nmcp->out_mb |= MBX_10;\r\n} else {\r\nmcp->mb[1] = loop_id << 8;\r\n}\r\nmcp->in_mb = MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1074,\r\n"Failed=%x mb[1]=%x.\n", rval, mcp->mb[1]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1075,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_full_login_lip(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1076,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_LIP_FULL_LOGIN;\r\nmcp->mb[1] = IS_FWI2_CAPABLE(vha->hw) ? BIT_3 : 0;\r\nmcp->mb[2] = 0;\r\nmcp->mb[3] = 0;\r\nmcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1077, "Failed=%x.\n", rval);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1078,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_get_id_list(scsi_qla_host_t *vha, void *id_list, dma_addr_t id_list_dma,\r\nuint16_t *entries)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1079,\r\n"Entered %s.\n", __func__);\r\nif (id_list == NULL)\r\nreturn QLA_FUNCTION_FAILED;\r\nmcp->mb[0] = MBC_GET_ID_LIST;\r\nmcp->out_mb = MBX_0;\r\nif (IS_FWI2_CAPABLE(vha->hw)) {\r\nmcp->mb[2] = MSW(id_list_dma);\r\nmcp->mb[3] = LSW(id_list_dma);\r\nmcp->mb[6] = MSW(MSD(id_list_dma));\r\nmcp->mb[7] = LSW(MSD(id_list_dma));\r\nmcp->mb[8] = 0;\r\nmcp->mb[9] = vha->vp_idx;\r\nmcp->out_mb |= MBX_9|MBX_8|MBX_7|MBX_6|MBX_3|MBX_2;\r\n} else {\r\nmcp->mb[1] = MSW(id_list_dma);\r\nmcp->mb[2] = LSW(id_list_dma);\r\nmcp->mb[3] = MSW(MSD(id_list_dma));\r\nmcp->mb[6] = LSW(MSD(id_list_dma));\r\nmcp->out_mb |= MBX_6|MBX_3|MBX_2|MBX_1;\r\n}\r\nmcp->in_mb = MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x107a, "Failed=%x.\n", rval);\r\n} else {\r\n*entries = mcp->mb[1];\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x107b,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_get_resource_cnts(scsi_qla_host_t *vha, uint16_t *cur_xchg_cnt,\r\nuint16_t *orig_xchg_cnt, uint16_t *cur_iocb_cnt,\r\nuint16_t *orig_iocb_cnt, uint16_t *max_npiv_vports, uint16_t *max_fcfs)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x107c,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_GET_RESOURCE_COUNTS;\r\nmcp->out_mb = MBX_0;\r\nmcp->in_mb = MBX_11|MBX_10|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\r\nif (IS_QLA81XX(vha->hw) || IS_QLA83XX(vha->hw) || IS_QLA27XX(vha->hw))\r\nmcp->in_mb |= MBX_12;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x107d,\r\n"Failed mb[0]=%x.\n", mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x107e,\r\n"Done %s mb1=%x mb2=%x mb3=%x mb6=%x mb7=%x mb10=%x "\r\n"mb11=%x mb12=%x.\n", __func__, mcp->mb[1], mcp->mb[2],\r\nmcp->mb[3], mcp->mb[6], mcp->mb[7], mcp->mb[10],\r\nmcp->mb[11], mcp->mb[12]);\r\nif (cur_xchg_cnt)\r\n*cur_xchg_cnt = mcp->mb[3];\r\nif (orig_xchg_cnt)\r\n*orig_xchg_cnt = mcp->mb[6];\r\nif (cur_iocb_cnt)\r\n*cur_iocb_cnt = mcp->mb[7];\r\nif (orig_iocb_cnt)\r\n*orig_iocb_cnt = mcp->mb[10];\r\nif (vha->hw->flags.npiv_supported && max_npiv_vports)\r\n*max_npiv_vports = mcp->mb[11];\r\nif ((IS_QLA81XX(vha->hw) || IS_QLA83XX(vha->hw)) && max_fcfs)\r\n*max_fcfs = mcp->mb[12];\r\n}\r\nreturn (rval);\r\n}\r\nint\r\nqla2x00_get_fcal_position_map(scsi_qla_host_t *vha, char *pos_map)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nchar *pmap;\r\ndma_addr_t pmap_dma;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x107f,\r\n"Entered %s.\n", __func__);\r\npmap = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &pmap_dma);\r\nif (pmap == NULL) {\r\nql_log(ql_log_warn, vha, 0x1080,\r\n"Memory alloc failed.\n");\r\nreturn QLA_MEMORY_ALLOC_FAILED;\r\n}\r\nmemset(pmap, 0, FCAL_MAP_SIZE);\r\nmcp->mb[0] = MBC_GET_FC_AL_POSITION_MAP;\r\nmcp->mb[2] = MSW(pmap_dma);\r\nmcp->mb[3] = LSW(pmap_dma);\r\nmcp->mb[6] = MSW(MSD(pmap_dma));\r\nmcp->mb[7] = LSW(MSD(pmap_dma));\r\nmcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_0;\r\nmcp->in_mb = MBX_1|MBX_0;\r\nmcp->buf_size = FCAL_MAP_SIZE;\r\nmcp->flags = MBX_DMA_IN;\r\nmcp->tov = (ha->login_timeout * 2) + (ha->login_timeout / 2);\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval == QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx + ql_dbg_buffer, vha, 0x1081,\r\n"mb0/mb1=%x/%X FC/AL position map size (%x).\n",\r\nmcp->mb[0], mcp->mb[1], (unsigned)pmap[0]);\r\nql_dump_buffer(ql_dbg_mbx + ql_dbg_buffer, vha, 0x111d,\r\npmap, pmap[0] + 1);\r\nif (pos_map)\r\nmemcpy(pos_map, pmap, FCAL_MAP_SIZE);\r\n}\r\ndma_pool_free(ha->s_dma_pool, pmap, pmap_dma);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1082, "Failed=%x.\n", rval);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1083,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_get_link_status(scsi_qla_host_t *vha, uint16_t loop_id,\r\nstruct link_statistics *stats, dma_addr_t stats_dma)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nuint32_t *siter, *diter, dwords;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1084,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_GET_LINK_STATUS;\r\nmcp->mb[2] = MSW(stats_dma);\r\nmcp->mb[3] = LSW(stats_dma);\r\nmcp->mb[6] = MSW(MSD(stats_dma));\r\nmcp->mb[7] = LSW(MSD(stats_dma));\r\nmcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nif (IS_FWI2_CAPABLE(ha)) {\r\nmcp->mb[1] = loop_id;\r\nmcp->mb[4] = 0;\r\nmcp->mb[10] = 0;\r\nmcp->out_mb |= MBX_10|MBX_4|MBX_1;\r\nmcp->in_mb |= MBX_1;\r\n} else if (HAS_EXTENDED_IDS(ha)) {\r\nmcp->mb[1] = loop_id;\r\nmcp->mb[10] = 0;\r\nmcp->out_mb |= MBX_10|MBX_1;\r\n} else {\r\nmcp->mb[1] = loop_id << 8;\r\nmcp->out_mb |= MBX_1;\r\n}\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = IOCTL_CMD;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval == QLA_SUCCESS) {\r\nif (mcp->mb[0] != MBS_COMMAND_COMPLETE) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1085,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1086,\r\n"Done %s.\n", __func__);\r\ndwords = offsetof(struct link_statistics, unused1) / 4;\r\nsiter = diter = &stats->link_fail_cnt;\r\nwhile (dwords--)\r\n*diter++ = le32_to_cpu(*siter++);\r\n}\r\n} else {\r\nql_dbg(ql_dbg_mbx, vha, 0x1087, "Failed=%x.\n", rval);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla24xx_get_isp_stats(scsi_qla_host_t *vha, struct link_statistics *stats,\r\ndma_addr_t stats_dma)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nuint32_t *siter, *diter, dwords;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1088,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_GET_LINK_PRIV_STATS;\r\nmcp->mb[2] = MSW(stats_dma);\r\nmcp->mb[3] = LSW(stats_dma);\r\nmcp->mb[6] = MSW(MSD(stats_dma));\r\nmcp->mb[7] = LSW(MSD(stats_dma));\r\nmcp->mb[8] = sizeof(struct link_statistics) / 4;\r\nmcp->mb[9] = vha->vp_idx;\r\nmcp->mb[10] = 0;\r\nmcp->out_mb = MBX_10|MBX_9|MBX_8|MBX_7|MBX_6|MBX_3|MBX_2|MBX_0;\r\nmcp->in_mb = MBX_2|MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = IOCTL_CMD;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval == QLA_SUCCESS) {\r\nif (mcp->mb[0] != MBS_COMMAND_COMPLETE) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1089,\r\n"Failed mb[0]=%x.\n", mcp->mb[0]);\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x108a,\r\n"Done %s.\n", __func__);\r\ndwords = sizeof(struct link_statistics) / 4;\r\nsiter = diter = &stats->link_fail_cnt;\r\nwhile (dwords--)\r\n*diter++ = le32_to_cpu(*siter++);\r\n}\r\n} else {\r\nql_dbg(ql_dbg_mbx, vha, 0x108b, "Failed=%x.\n", rval);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla24xx_abort_command(srb_t *sp)\r\n{\r\nint rval;\r\nunsigned long flags = 0;\r\nstruct abort_entry_24xx *abt;\r\ndma_addr_t abt_dma;\r\nuint32_t handle;\r\nfc_port_t *fcport = sp->fcport;\r\nstruct scsi_qla_host *vha = fcport->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = vha->req;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x108c,\r\n"Entered %s.\n", __func__);\r\nif (ql2xasynctmfenable)\r\nreturn qla24xx_async_abort_command(sp);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nfor (handle = 1; handle < req->num_outstanding_cmds; handle++) {\r\nif (req->outstanding_cmds[handle] == sp)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (handle == req->num_outstanding_cmds) {\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nabt = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &abt_dma);\r\nif (abt == NULL) {\r\nql_log(ql_log_warn, vha, 0x108d,\r\n"Failed to allocate abort IOCB.\n");\r\nreturn QLA_MEMORY_ALLOC_FAILED;\r\n}\r\nmemset(abt, 0, sizeof(struct abort_entry_24xx));\r\nabt->entry_type = ABORT_IOCB_TYPE;\r\nabt->entry_count = 1;\r\nabt->handle = MAKE_HANDLE(req->id, abt->handle);\r\nabt->nport_handle = cpu_to_le16(fcport->loop_id);\r\nabt->handle_to_abort = MAKE_HANDLE(req->id, handle);\r\nabt->port_id[0] = fcport->d_id.b.al_pa;\r\nabt->port_id[1] = fcport->d_id.b.area;\r\nabt->port_id[2] = fcport->d_id.b.domain;\r\nabt->vp_index = fcport->vha->vp_idx;\r\nabt->req_que_no = cpu_to_le16(req->id);\r\nrval = qla2x00_issue_iocb(vha, abt, abt_dma, 0);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x108e,\r\n"Failed to issue IOCB (%x).\n", rval);\r\n} else if (abt->entry_status != 0) {\r\nql_dbg(ql_dbg_mbx, vha, 0x108f,\r\n"Failed to complete IOCB -- error status (%x).\n",\r\nabt->entry_status);\r\nrval = QLA_FUNCTION_FAILED;\r\n} else if (abt->nport_handle != __constant_cpu_to_le16(0)) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1090,\r\n"Failed to complete IOCB -- completion status (%x).\n",\r\nle16_to_cpu(abt->nport_handle));\r\nif (abt->nport_handle == CS_IOCB_ERROR)\r\nrval = QLA_FUNCTION_PARAMETER_ERROR;\r\nelse\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1091,\r\n"Done %s.\n", __func__);\r\n}\r\ndma_pool_free(ha->s_dma_pool, abt, abt_dma);\r\nreturn rval;\r\n}\r\nstatic int\r\n__qla24xx_issue_tmf(char *name, uint32_t type, struct fc_port *fcport,\r\nuint64_t l, int tag)\r\n{\r\nint rval, rval2;\r\nstruct tsk_mgmt_cmd *tsk;\r\nstruct sts_entry_24xx *sts;\r\ndma_addr_t tsk_dma;\r\nscsi_qla_host_t *vha;\r\nstruct qla_hw_data *ha;\r\nstruct req_que *req;\r\nstruct rsp_que *rsp;\r\nvha = fcport->vha;\r\nha = vha->hw;\r\nreq = vha->req;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1092,\r\n"Entered %s.\n", __func__);\r\nif (ha->flags.cpu_affinity_enabled)\r\nrsp = ha->rsp_q_map[tag + 1];\r\nelse\r\nrsp = req->rsp;\r\ntsk = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &tsk_dma);\r\nif (tsk == NULL) {\r\nql_log(ql_log_warn, vha, 0x1093,\r\n"Failed to allocate task management IOCB.\n");\r\nreturn QLA_MEMORY_ALLOC_FAILED;\r\n}\r\nmemset(tsk, 0, sizeof(struct tsk_mgmt_cmd));\r\ntsk->p.tsk.entry_type = TSK_MGMT_IOCB_TYPE;\r\ntsk->p.tsk.entry_count = 1;\r\ntsk->p.tsk.handle = MAKE_HANDLE(req->id, tsk->p.tsk.handle);\r\ntsk->p.tsk.nport_handle = cpu_to_le16(fcport->loop_id);\r\ntsk->p.tsk.timeout = cpu_to_le16(ha->r_a_tov / 10 * 2);\r\ntsk->p.tsk.control_flags = cpu_to_le32(type);\r\ntsk->p.tsk.port_id[0] = fcport->d_id.b.al_pa;\r\ntsk->p.tsk.port_id[1] = fcport->d_id.b.area;\r\ntsk->p.tsk.port_id[2] = fcport->d_id.b.domain;\r\ntsk->p.tsk.vp_index = fcport->vha->vp_idx;\r\nif (type == TCF_LUN_RESET) {\r\nint_to_scsilun(l, &tsk->p.tsk.lun);\r\nhost_to_fcp_swap((uint8_t *)&tsk->p.tsk.lun,\r\nsizeof(tsk->p.tsk.lun));\r\n}\r\nsts = &tsk->p.sts;\r\nrval = qla2x00_issue_iocb(vha, tsk, tsk_dma, 0);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1094,\r\n"Failed to issue %s reset IOCB (%x).\n", name, rval);\r\n} else if (sts->entry_status != 0) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1095,\r\n"Failed to complete IOCB -- error status (%x).\n",\r\nsts->entry_status);\r\nrval = QLA_FUNCTION_FAILED;\r\n} else if (sts->comp_status !=\r\n__constant_cpu_to_le16(CS_COMPLETE)) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1096,\r\n"Failed to complete IOCB -- completion status (%x).\n",\r\nle16_to_cpu(sts->comp_status));\r\nrval = QLA_FUNCTION_FAILED;\r\n} else if (le16_to_cpu(sts->scsi_status) &\r\nSS_RESPONSE_INFO_LEN_VALID) {\r\nif (le32_to_cpu(sts->rsp_data_len) < 4) {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1097,\r\n"Ignoring inconsistent data length -- not enough "\r\n"response info (%d).\n",\r\nle32_to_cpu(sts->rsp_data_len));\r\n} else if (sts->data[3]) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1098,\r\n"Failed to complete IOCB -- response (%x).\n",\r\nsts->data[3]);\r\nrval = QLA_FUNCTION_FAILED;\r\n}\r\n}\r\nrval2 = qla2x00_marker(vha, req, rsp, fcport->loop_id, l,\r\ntype == TCF_LUN_RESET ? MK_SYNC_ID_LUN: MK_SYNC_ID);\r\nif (rval2 != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1099,\r\n"Failed to issue marker IOCB (%x).\n", rval2);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x109a,\r\n"Done %s.\n", __func__);\r\n}\r\ndma_pool_free(ha->s_dma_pool, tsk, tsk_dma);\r\nreturn rval;\r\n}\r\nint\r\nqla24xx_abort_target(struct fc_port *fcport, uint64_t l, int tag)\r\n{\r\nstruct qla_hw_data *ha = fcport->vha->hw;\r\nif ((ql2xasynctmfenable) && IS_FWI2_CAPABLE(ha))\r\nreturn qla2x00_async_tm_cmd(fcport, TCF_TARGET_RESET, l, tag);\r\nreturn __qla24xx_issue_tmf("Target", TCF_TARGET_RESET, fcport, l, tag);\r\n}\r\nint\r\nqla24xx_lun_reset(struct fc_port *fcport, uint64_t l, int tag)\r\n{\r\nstruct qla_hw_data *ha = fcport->vha->hw;\r\nif ((ql2xasynctmfenable) && IS_FWI2_CAPABLE(ha))\r\nreturn qla2x00_async_tm_cmd(fcport, TCF_LUN_RESET, l, tag);\r\nreturn __qla24xx_issue_tmf("Lun", TCF_LUN_RESET, fcport, l, tag);\r\n}\r\nint\r\nqla2x00_system_error(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!IS_QLA23XX(ha) && !IS_FWI2_CAPABLE(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x109b,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_GEN_SYSTEM_ERROR;\r\nmcp->out_mb = MBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = 5;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x109c, "Failed=%x.\n", rval);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x109d,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_write_serdes_word(scsi_qla_host_t *vha, uint16_t addr, uint16_t data)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nif (!IS_QLA2031(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1182,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_WRITE_SERDES;\r\nmcp->mb[1] = addr;\r\nmcp->mb[2] = data & 0xff;\r\nmcp->mb[3] = 0;\r\nmcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1183,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1184,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_read_serdes_word(scsi_qla_host_t *vha, uint16_t addr, uint16_t *data)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nif (!IS_QLA2031(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1185,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_READ_SERDES;\r\nmcp->mb[1] = addr;\r\nmcp->mb[3] = 0;\r\nmcp->out_mb = MBX_3|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\n*data = mcp->mb[1] & 0xff;\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1186,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1187,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla8044_write_serdes_word(scsi_qla_host_t *vha, uint32_t addr, uint32_t data)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nif (!IS_QLA8044(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1186,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_SET_GET_ETH_SERDES_REG;\r\nmcp->mb[1] = HCS_WRITE_SERDES;\r\nmcp->mb[3] = LSW(addr);\r\nmcp->mb[4] = MSW(addr);\r\nmcp->mb[5] = LSW(data);\r\nmcp->mb[6] = MSW(data);\r\nmcp->out_mb = MBX_6|MBX_5|MBX_4|MBX_3|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1187,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1188,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla8044_read_serdes_word(scsi_qla_host_t *vha, uint32_t addr, uint32_t *data)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nif (!IS_QLA8044(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1189,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_SET_GET_ETH_SERDES_REG;\r\nmcp->mb[1] = HCS_READ_SERDES;\r\nmcp->mb[3] = LSW(addr);\r\nmcp->mb[4] = MSW(addr);\r\nmcp->out_mb = MBX_4|MBX_3|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_2|MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\n*data = mcp->mb[2] << 16 | mcp->mb[1];\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x118a,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x118b,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_set_serdes_params(scsi_qla_host_t *vha, uint16_t sw_em_1g,\r\nuint16_t sw_em_2g, uint16_t sw_em_4g)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x109e,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_SERDES_PARAMS;\r\nmcp->mb[1] = BIT_0;\r\nmcp->mb[2] = sw_em_1g | BIT_15;\r\nmcp->mb[3] = sw_em_2g | BIT_15;\r\nmcp->mb[4] = sw_em_4g | BIT_15;\r\nmcp->out_mb = MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x109f,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10a0,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_stop_firmware(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nif (!IS_FWI2_CAPABLE(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10a1,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_STOP_FIRMWARE;\r\nmcp->mb[1] = 0;\r\nmcp->out_mb = MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = 5;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10a2, "Failed=%x.\n", rval);\r\nif (mcp->mb[0] == MBS_INVALID_COMMAND)\r\nrval = QLA_INVALID_COMMAND;\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10a3,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_enable_eft_trace(scsi_qla_host_t *vha, dma_addr_t eft_dma,\r\nuint16_t buffers)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10a4,\r\n"Entered %s.\n", __func__);\r\nif (!IS_FWI2_CAPABLE(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nif (unlikely(pci_channel_offline(vha->hw->pdev)))\r\nreturn QLA_FUNCTION_FAILED;\r\nmcp->mb[0] = MBC_TRACE_CONTROL;\r\nmcp->mb[1] = TC_EFT_ENABLE;\r\nmcp->mb[2] = LSW(eft_dma);\r\nmcp->mb[3] = MSW(eft_dma);\r\nmcp->mb[4] = LSW(MSD(eft_dma));\r\nmcp->mb[5] = MSW(MSD(eft_dma));\r\nmcp->mb[6] = buffers;\r\nmcp->mb[7] = TC_AEN_DISABLE;\r\nmcp->out_mb = MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10a5,\r\n"Failed=%x mb[0]=%x mb[1]=%x.\n",\r\nrval, mcp->mb[0], mcp->mb[1]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10a6,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_disable_eft_trace(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10a7,\r\n"Entered %s.\n", __func__);\r\nif (!IS_FWI2_CAPABLE(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nif (unlikely(pci_channel_offline(vha->hw->pdev)))\r\nreturn QLA_FUNCTION_FAILED;\r\nmcp->mb[0] = MBC_TRACE_CONTROL;\r\nmcp->mb[1] = TC_EFT_DISABLE;\r\nmcp->out_mb = MBX_1|MBX_0;\r\nmcp->in_mb = MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10a8,\r\n"Failed=%x mb[0]=%x mb[1]=%x.\n",\r\nrval, mcp->mb[0], mcp->mb[1]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10a9,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_enable_fce_trace(scsi_qla_host_t *vha, dma_addr_t fce_dma,\r\nuint16_t buffers, uint16_t *mb, uint32_t *dwords)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10aa,\r\n"Entered %s.\n", __func__);\r\nif (!IS_QLA25XX(vha->hw) && !IS_QLA81XX(vha->hw) &&\r\n!IS_QLA83XX(vha->hw) && !IS_QLA27XX(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nif (unlikely(pci_channel_offline(vha->hw->pdev)))\r\nreturn QLA_FUNCTION_FAILED;\r\nmcp->mb[0] = MBC_TRACE_CONTROL;\r\nmcp->mb[1] = TC_FCE_ENABLE;\r\nmcp->mb[2] = LSW(fce_dma);\r\nmcp->mb[3] = MSW(fce_dma);\r\nmcp->mb[4] = LSW(MSD(fce_dma));\r\nmcp->mb[5] = MSW(MSD(fce_dma));\r\nmcp->mb[6] = buffers;\r\nmcp->mb[7] = TC_AEN_DISABLE;\r\nmcp->mb[8] = 0;\r\nmcp->mb[9] = TC_FCE_DEFAULT_RX_SIZE;\r\nmcp->mb[10] = TC_FCE_DEFAULT_TX_SIZE;\r\nmcp->out_mb = MBX_10|MBX_9|MBX_8|MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|\r\nMBX_1|MBX_0;\r\nmcp->in_mb = MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10ab,\r\n"Failed=%x mb[0]=%x mb[1]=%x.\n",\r\nrval, mcp->mb[0], mcp->mb[1]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10ac,\r\n"Done %s.\n", __func__);\r\nif (mb)\r\nmemcpy(mb, mcp->mb, 8 * sizeof(*mb));\r\nif (dwords)\r\n*dwords = buffers;\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_disable_fce_trace(scsi_qla_host_t *vha, uint64_t *wr, uint64_t *rd)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10ad,\r\n"Entered %s.\n", __func__);\r\nif (!IS_FWI2_CAPABLE(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nif (unlikely(pci_channel_offline(vha->hw->pdev)))\r\nreturn QLA_FUNCTION_FAILED;\r\nmcp->mb[0] = MBC_TRACE_CONTROL;\r\nmcp->mb[1] = TC_FCE_DISABLE;\r\nmcp->mb[2] = TC_FCE_DISABLE_TRACE;\r\nmcp->out_mb = MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_9|MBX_8|MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|\r\nMBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10ae,\r\n"Failed=%x mb[0]=%x mb[1]=%x.\n",\r\nrval, mcp->mb[0], mcp->mb[1]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10af,\r\n"Done %s.\n", __func__);\r\nif (wr)\r\n*wr = (uint64_t) mcp->mb[5] << 48 |\r\n(uint64_t) mcp->mb[4] << 32 |\r\n(uint64_t) mcp->mb[3] << 16 |\r\n(uint64_t) mcp->mb[2];\r\nif (rd)\r\n*rd = (uint64_t) mcp->mb[9] << 48 |\r\n(uint64_t) mcp->mb[8] << 32 |\r\n(uint64_t) mcp->mb[7] << 16 |\r\n(uint64_t) mcp->mb[6];\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_get_idma_speed(scsi_qla_host_t *vha, uint16_t loop_id,\r\nuint16_t *port_speed, uint16_t *mb)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b0,\r\n"Entered %s.\n", __func__);\r\nif (!IS_IIDMA_CAPABLE(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nmcp->mb[0] = MBC_PORT_PARAMS;\r\nmcp->mb[1] = loop_id;\r\nmcp->mb[2] = mcp->mb[3] = 0;\r\nmcp->mb[9] = vha->vp_idx;\r\nmcp->out_mb = MBX_9|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_3|MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (mb != NULL) {\r\nmb[0] = mcp->mb[0];\r\nmb[1] = mcp->mb[1];\r\nmb[3] = mcp->mb[3];\r\n}\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10b1, "Failed=%x.\n", rval);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b2,\r\n"Done %s.\n", __func__);\r\nif (port_speed)\r\n*port_speed = mcp->mb[3];\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_set_idma_speed(scsi_qla_host_t *vha, uint16_t loop_id,\r\nuint16_t port_speed, uint16_t *mb)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b3,\r\n"Entered %s.\n", __func__);\r\nif (!IS_IIDMA_CAPABLE(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nmcp->mb[0] = MBC_PORT_PARAMS;\r\nmcp->mb[1] = loop_id;\r\nmcp->mb[2] = BIT_0;\r\nif (IS_CNA_CAPABLE(vha->hw))\r\nmcp->mb[3] = port_speed & (BIT_5|BIT_4|BIT_3|BIT_2|BIT_1|BIT_0);\r\nelse\r\nmcp->mb[3] = port_speed & (BIT_2|BIT_1|BIT_0);\r\nmcp->mb[9] = vha->vp_idx;\r\nmcp->out_mb = MBX_9|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_3|MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (mb != NULL) {\r\nmb[0] = mcp->mb[0];\r\nmb[1] = mcp->mb[1];\r\nmb[3] = mcp->mb[3];\r\n}\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10b4,\r\n"Failed=%x.\n", rval);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b5,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nvoid\r\nqla24xx_report_id_acquisition(scsi_qla_host_t *vha,\r\nstruct vp_rpt_id_entry_24xx *rptid_entry)\r\n{\r\nuint8_t vp_idx;\r\nuint16_t stat = le16_to_cpu(rptid_entry->vp_idx);\r\nstruct qla_hw_data *ha = vha->hw;\r\nscsi_qla_host_t *vp;\r\nunsigned long flags;\r\nint found;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b6,\r\n"Entered %s.\n", __func__);\r\nif (rptid_entry->entry_status != 0)\r\nreturn;\r\nif (rptid_entry->format == 0) {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b7,\r\n"Format 0 : Number of VPs setup %d, number of "\r\n"VPs acquired %d.\n",\r\nMSB(le16_to_cpu(rptid_entry->vp_count)),\r\nLSB(le16_to_cpu(rptid_entry->vp_count)));\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b8,\r\n"Primary port id %02x%02x%02x.\n",\r\nrptid_entry->port_id[2], rptid_entry->port_id[1],\r\nrptid_entry->port_id[0]);\r\n} else if (rptid_entry->format == 1) {\r\nvp_idx = LSB(stat);\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10b9,\r\n"Format 1: VP[%d] enabled - status %d - with "\r\n"port id %02x%02x%02x.\n", vp_idx, MSB(stat),\r\nrptid_entry->port_id[2], rptid_entry->port_id[1],\r\nrptid_entry->port_id[0]);\r\nif (!vp_idx) {\r\nvoid *wwpn = ha->init_cb->port_name;\r\nif (!MSB(stat)) {\r\nif (rptid_entry->vp_idx_map[1] & BIT_6)\r\nwwpn = rptid_entry->reserved_4 + 8;\r\n}\r\nmemcpy(vha->port_name, wwpn, WWN_SIZE);\r\nfc_host_port_name(vha->host) =\r\nwwn_to_u64(vha->port_name);\r\nql_dbg(ql_dbg_mbx, vha, 0x1018,\r\n"FA-WWN portname %016llx (%x)\n",\r\nfc_host_port_name(vha->host), MSB(stat));\r\n}\r\nvp = vha;\r\nif (vp_idx == 0)\r\ngoto reg_needed;\r\nif (MSB(stat) != 0 && MSB(stat) != 2) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10ba,\r\n"Could not acquire ID for VP[%d].\n", vp_idx);\r\nreturn;\r\n}\r\nfound = 0;\r\nspin_lock_irqsave(&ha->vport_slock, flags);\r\nlist_for_each_entry(vp, &ha->vp_list, list) {\r\nif (vp_idx == vp->vp_idx) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ha->vport_slock, flags);\r\nif (!found)\r\nreturn;\r\nvp->d_id.b.domain = rptid_entry->port_id[2];\r\nvp->d_id.b.area = rptid_entry->port_id[1];\r\nvp->d_id.b.al_pa = rptid_entry->port_id[0];\r\nset_bit(VP_IDX_ACQUIRED, &vp->vp_flags);\r\nreg_needed:\r\nset_bit(REGISTER_FC4_NEEDED, &vp->dpc_flags);\r\nset_bit(REGISTER_FDMI_NEEDED, &vp->dpc_flags);\r\nset_bit(VP_DPC_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\n}\r\n}\r\nint\r\nqla24xx_modify_vp_config(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nstruct vp_config_entry_24xx *vpmod;\r\ndma_addr_t vpmod_dma;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10bb,\r\n"Entered %s.\n", __func__);\r\nvpmod = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &vpmod_dma);\r\nif (!vpmod) {\r\nql_log(ql_log_warn, vha, 0x10bc,\r\n"Failed to allocate modify VP IOCB.\n");\r\nreturn QLA_MEMORY_ALLOC_FAILED;\r\n}\r\nmemset(vpmod, 0, sizeof(struct vp_config_entry_24xx));\r\nvpmod->entry_type = VP_CONFIG_IOCB_TYPE;\r\nvpmod->entry_count = 1;\r\nvpmod->command = VCT_COMMAND_MOD_ENABLE_VPS;\r\nvpmod->vp_count = 1;\r\nvpmod->vp_index1 = vha->vp_idx;\r\nvpmod->options_idx1 = BIT_3|BIT_4|BIT_5;\r\nqlt_modify_vp_config(vha, vpmod);\r\nmemcpy(vpmod->node_name_idx1, vha->node_name, WWN_SIZE);\r\nmemcpy(vpmod->port_name_idx1, vha->port_name, WWN_SIZE);\r\nvpmod->entry_count = 1;\r\nrval = qla2x00_issue_iocb(base_vha, vpmod, vpmod_dma, 0);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10bd,\r\n"Failed to issue VP config IOCB (%x).\n", rval);\r\n} else if (vpmod->comp_status != 0) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10be,\r\n"Failed to complete IOCB -- error status (%x).\n",\r\nvpmod->comp_status);\r\nrval = QLA_FUNCTION_FAILED;\r\n} else if (vpmod->comp_status != __constant_cpu_to_le16(CS_COMPLETE)) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10bf,\r\n"Failed to complete IOCB -- completion status (%x).\n",\r\nle16_to_cpu(vpmod->comp_status));\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10c0,\r\n"Done %s.\n", __func__);\r\nfc_vport_set_state(vha->fc_vport, FC_VPORT_INITIALIZING);\r\n}\r\ndma_pool_free(ha->s_dma_pool, vpmod, vpmod_dma);\r\nreturn rval;\r\n}\r\nint\r\nqla24xx_control_vp(scsi_qla_host_t *vha, int cmd)\r\n{\r\nint rval;\r\nint map, pos;\r\nstruct vp_ctrl_entry_24xx *vce;\r\ndma_addr_t vce_dma;\r\nstruct qla_hw_data *ha = vha->hw;\r\nint vp_index = vha->vp_idx;\r\nstruct scsi_qla_host *base_vha = pci_get_drvdata(ha->pdev);\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10c1,\r\n"Entered %s enabling index %d.\n", __func__, vp_index);\r\nif (vp_index == 0 || vp_index >= ha->max_npiv_vports)\r\nreturn QLA_PARAMETER_ERROR;\r\nvce = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &vce_dma);\r\nif (!vce) {\r\nql_log(ql_log_warn, vha, 0x10c2,\r\n"Failed to allocate VP control IOCB.\n");\r\nreturn QLA_MEMORY_ALLOC_FAILED;\r\n}\r\nmemset(vce, 0, sizeof(struct vp_ctrl_entry_24xx));\r\nvce->entry_type = VP_CTRL_IOCB_TYPE;\r\nvce->entry_count = 1;\r\nvce->command = cpu_to_le16(cmd);\r\nvce->vp_count = __constant_cpu_to_le16(1);\r\nmap = (vp_index - 1) / 8;\r\npos = (vp_index - 1) & 7;\r\nmutex_lock(&ha->vport_lock);\r\nvce->vp_idx_map[map] |= 1 << pos;\r\nmutex_unlock(&ha->vport_lock);\r\nrval = qla2x00_issue_iocb(base_vha, vce, vce_dma, 0);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10c3,\r\n"Failed to issue VP control IOCB (%x).\n", rval);\r\n} else if (vce->entry_status != 0) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10c4,\r\n"Failed to complete IOCB -- error status (%x).\n",\r\nvce->entry_status);\r\nrval = QLA_FUNCTION_FAILED;\r\n} else if (vce->comp_status != __constant_cpu_to_le16(CS_COMPLETE)) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10c5,\r\n"Failed to complet IOCB -- completion status (%x).\n",\r\nle16_to_cpu(vce->comp_status));\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10c6,\r\n"Done %s.\n", __func__);\r\n}\r\ndma_pool_free(ha->s_dma_pool, vce, vce_dma);\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_send_change_request(scsi_qla_host_t *vha, uint16_t format,\r\nuint16_t vp_idx)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10c7,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_SEND_CHANGE_REQUEST;\r\nmcp->mb[1] = format;\r\nmcp->mb[9] = vp_idx;\r\nmcp->out_mb = MBX_9|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0|MBX_1;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval == QLA_SUCCESS) {\r\nif (mcp->mb[0] != MBS_COMMAND_COMPLETE) {\r\nrval = BIT_1;\r\n}\r\n} else\r\nrval = BIT_1;\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_dump_ram(scsi_qla_host_t *vha, dma_addr_t req_dma, uint32_t addr,\r\nuint32_t size)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1009,\r\n"Entered %s.\n", __func__);\r\nif (MSW(addr) || IS_FWI2_CAPABLE(vha->hw)) {\r\nmcp->mb[0] = MBC_DUMP_RISC_RAM_EXTENDED;\r\nmcp->mb[8] = MSW(addr);\r\nmcp->out_mb = MBX_8|MBX_0;\r\n} else {\r\nmcp->mb[0] = MBC_DUMP_RISC_RAM;\r\nmcp->out_mb = MBX_0;\r\n}\r\nmcp->mb[1] = LSW(addr);\r\nmcp->mb[2] = MSW(req_dma);\r\nmcp->mb[3] = LSW(req_dma);\r\nmcp->mb[6] = MSW(MSD(req_dma));\r\nmcp->mb[7] = LSW(MSD(req_dma));\r\nmcp->out_mb |= MBX_7|MBX_6|MBX_3|MBX_2|MBX_1;\r\nif (IS_FWI2_CAPABLE(vha->hw)) {\r\nmcp->mb[4] = MSW(size);\r\nmcp->mb[5] = LSW(size);\r\nmcp->out_mb |= MBX_5|MBX_4;\r\n} else {\r\nmcp->mb[4] = LSW(size);\r\nmcp->out_mb |= MBX_4;\r\n}\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1008,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1007,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla84xx_verify_chip(struct scsi_qla_host *vha, uint16_t *status)\r\n{\r\nint rval, retry;\r\nstruct cs84xx_mgmt_cmd *mn;\r\ndma_addr_t mn_dma;\r\nuint16_t options;\r\nunsigned long flags;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10c8,\r\n"Entered %s.\n", __func__);\r\nmn = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &mn_dma);\r\nif (mn == NULL) {\r\nreturn QLA_MEMORY_ALLOC_FAILED;\r\n}\r\noptions = ha->cs84xx->fw_update ? VCO_FORCE_UPDATE : 0;\r\noptions |= VCO_END_OF_DATA;\r\ndo {\r\nretry = 0;\r\nmemset(mn, 0, sizeof(*mn));\r\nmn->p.req.entry_type = VERIFY_CHIP_IOCB_TYPE;\r\nmn->p.req.entry_count = 1;\r\nmn->p.req.options = cpu_to_le16(options);\r\nql_dbg(ql_dbg_mbx + ql_dbg_buffer, vha, 0x111c,\r\n"Dump of Verify Request.\n");\r\nql_dump_buffer(ql_dbg_mbx + ql_dbg_buffer, vha, 0x111e,\r\n(uint8_t *)mn, sizeof(*mn));\r\nrval = qla2x00_issue_iocb_timeout(vha, mn, mn_dma, 0, 120);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10cb,\r\n"Failed to issue verify IOCB (%x).\n", rval);\r\ngoto verify_done;\r\n}\r\nql_dbg(ql_dbg_mbx + ql_dbg_buffer, vha, 0x1110,\r\n"Dump of Verify Response.\n");\r\nql_dump_buffer(ql_dbg_mbx + ql_dbg_buffer, vha, 0x1118,\r\n(uint8_t *)mn, sizeof(*mn));\r\nstatus[0] = le16_to_cpu(mn->p.rsp.comp_status);\r\nstatus[1] = status[0] == CS_VCS_CHIP_FAILURE ?\r\nle16_to_cpu(mn->p.rsp.failure_code) : 0;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10ce,\r\n"cs=%x fc=%x.\n", status[0], status[1]);\r\nif (status[0] != CS_COMPLETE) {\r\nrval = QLA_FUNCTION_FAILED;\r\nif (!(options & VCO_DONT_UPDATE_FW)) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10cf,\r\n"Firmware update failed. Retrying "\r\n"without update firmware.\n");\r\noptions |= VCO_DONT_UPDATE_FW;\r\noptions &= ~VCO_FORCE_UPDATE;\r\nretry = 1;\r\n}\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10d0,\r\n"Firmware updated to %x.\n",\r\nle32_to_cpu(mn->p.rsp.fw_ver));\r\nspin_lock_irqsave(&ha->cs84xx->access_lock, flags);\r\nha->cs84xx->op_fw_version =\r\nle32_to_cpu(mn->p.rsp.fw_ver);\r\nspin_unlock_irqrestore(&ha->cs84xx->access_lock,\r\nflags);\r\n}\r\n} while (retry);\r\nverify_done:\r\ndma_pool_free(ha->s_dma_pool, mn, mn_dma);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10d1,\r\n"Failed=%x.\n", rval);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10d2,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla25xx_init_req_que(struct scsi_qla_host *vha, struct req_que *req)\r\n{\r\nint rval;\r\nunsigned long flags;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10d3,\r\n"Entered %s.\n", __func__);\r\nif (IS_SHADOW_REG_CAPABLE(ha))\r\nreq->options |= BIT_13;\r\nmcp->mb[0] = MBC_INITIALIZE_MULTIQ;\r\nmcp->mb[1] = req->options;\r\nmcp->mb[2] = MSW(LSD(req->dma));\r\nmcp->mb[3] = LSW(LSD(req->dma));\r\nmcp->mb[6] = MSW(MSD(req->dma));\r\nmcp->mb[7] = LSW(MSD(req->dma));\r\nmcp->mb[5] = req->length;\r\nif (req->rsp)\r\nmcp->mb[10] = req->rsp->id;\r\nmcp->mb[12] = req->qos;\r\nmcp->mb[11] = req->vp_idx;\r\nmcp->mb[13] = req->rid;\r\nif (IS_QLA83XX(ha) || IS_QLA27XX(ha))\r\nmcp->mb[15] = 0;\r\nmcp->mb[4] = req->id;\r\nmcp->mb[8] = 0;\r\nmcp->mb[9] = *req->out_ptr = 0;\r\nmcp->out_mb = MBX_14|MBX_13|MBX_12|MBX_11|MBX_10|MBX_9|MBX_8|MBX_7|\r\nMBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->flags = MBX_DMA_OUT;\r\nmcp->tov = MBX_TOV_SECONDS * 2;\r\nif (IS_QLA81XX(ha) || IS_QLA83XX(ha) || IS_QLA27XX(ha))\r\nmcp->in_mb |= MBX_1;\r\nif (IS_QLA83XX(ha) || IS_QLA27XX(ha)) {\r\nmcp->out_mb |= MBX_15;\r\nmcp->in_mb |= MBX_9 | MBX_8 | MBX_7;\r\n}\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nif (!(req->options & BIT_0)) {\r\nWRT_REG_DWORD(req->req_q_in, 0);\r\nif (!IS_QLA83XX(ha) && !IS_QLA27XX(ha))\r\nWRT_REG_DWORD(req->req_q_out, 0);\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10d4,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10d5,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla25xx_init_rsp_que(struct scsi_qla_host *vha, struct rsp_que *rsp)\r\n{\r\nint rval;\r\nunsigned long flags;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10d6,\r\n"Entered %s.\n", __func__);\r\nif (IS_SHADOW_REG_CAPABLE(ha))\r\nrsp->options |= BIT_13;\r\nmcp->mb[0] = MBC_INITIALIZE_MULTIQ;\r\nmcp->mb[1] = rsp->options;\r\nmcp->mb[2] = MSW(LSD(rsp->dma));\r\nmcp->mb[3] = LSW(LSD(rsp->dma));\r\nmcp->mb[6] = MSW(MSD(rsp->dma));\r\nmcp->mb[7] = LSW(MSD(rsp->dma));\r\nmcp->mb[5] = rsp->length;\r\nmcp->mb[14] = rsp->msix->entry;\r\nmcp->mb[13] = rsp->rid;\r\nif (IS_QLA83XX(ha) || IS_QLA27XX(ha))\r\nmcp->mb[15] = 0;\r\nmcp->mb[4] = rsp->id;\r\nmcp->mb[8] = *rsp->in_ptr = 0;\r\nmcp->mb[9] = 0;\r\nmcp->out_mb = MBX_14|MBX_13|MBX_9|MBX_8|MBX_7\r\n|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->flags = MBX_DMA_OUT;\r\nmcp->tov = MBX_TOV_SECONDS * 2;\r\nif (IS_QLA81XX(ha)) {\r\nmcp->out_mb |= MBX_12|MBX_11|MBX_10;\r\nmcp->in_mb |= MBX_1;\r\n} else if (IS_QLA83XX(ha) || IS_QLA27XX(ha)) {\r\nmcp->out_mb |= MBX_15|MBX_12|MBX_11|MBX_10;\r\nmcp->in_mb |= MBX_1;\r\nmcp->in_mb |= MBX_9 | MBX_8 | MBX_7;\r\n}\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nif (!(rsp->options & BIT_0)) {\r\nWRT_REG_DWORD(rsp->rsp_q_out, 0);\r\nif (!IS_QLA83XX(ha))\r\nWRT_REG_DWORD(rsp->rsp_q_in, 0);\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10d7,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10d8,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla81xx_idc_ack(scsi_qla_host_t *vha, uint16_t *mb)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10d9,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_IDC_ACK;\r\nmemcpy(&mcp->mb[1], mb, QLA_IDC_ACK_REGS * sizeof(uint16_t));\r\nmcp->out_mb = MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10da,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10db,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla81xx_fac_get_sector_size(scsi_qla_host_t *vha, uint32_t *sector_size)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10dc,\r\n"Entered %s.\n", __func__);\r\nif (!IS_QLA81XX(vha->hw) && !IS_QLA83XX(vha->hw) &&\r\n!IS_QLA27XX(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nmcp->mb[0] = MBC_FLASH_ACCESS_CTRL;\r\nmcp->mb[1] = FAC_OPT_CMD_GET_SECTOR_SIZE;\r\nmcp->out_mb = MBX_1|MBX_0;\r\nmcp->in_mb = MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10dd,\r\n"Failed=%x mb[0]=%x mb[1]=%x.\n",\r\nrval, mcp->mb[0], mcp->mb[1]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10de,\r\n"Done %s.\n", __func__);\r\n*sector_size = mcp->mb[1];\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla81xx_fac_do_write_enable(scsi_qla_host_t *vha, int enable)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nif (!IS_QLA81XX(vha->hw) && !IS_QLA83XX(vha->hw) &&\r\n!IS_QLA27XX(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10df,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_FLASH_ACCESS_CTRL;\r\nmcp->mb[1] = enable ? FAC_OPT_CMD_WRITE_ENABLE :\r\nFAC_OPT_CMD_WRITE_PROTECT;\r\nmcp->out_mb = MBX_1|MBX_0;\r\nmcp->in_mb = MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10e0,\r\n"Failed=%x mb[0]=%x mb[1]=%x.\n",\r\nrval, mcp->mb[0], mcp->mb[1]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e1,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla81xx_fac_erase_sector(scsi_qla_host_t *vha, uint32_t start, uint32_t finish)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nif (!IS_QLA81XX(vha->hw) && !IS_QLA83XX(vha->hw) &&\r\n!IS_QLA27XX(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e2,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_FLASH_ACCESS_CTRL;\r\nmcp->mb[1] = FAC_OPT_CMD_ERASE_SECTOR;\r\nmcp->mb[2] = LSW(start);\r\nmcp->mb[3] = MSW(start);\r\nmcp->mb[4] = LSW(finish);\r\nmcp->mb[5] = MSW(finish);\r\nmcp->out_mb = MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_2|MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10e3,\r\n"Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x.\n",\r\nrval, mcp->mb[0], mcp->mb[1], mcp->mb[2]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e4,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla81xx_restart_mpi_firmware(scsi_qla_host_t *vha)\r\n{\r\nint rval = 0;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e5,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_RESTART_MPI_FW;\r\nmcp->out_mb = MBX_0;\r\nmcp->in_mb = MBX_0|MBX_1;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10e6,\r\n"Failed=%x mb[0]=%x mb[1]=%x.\n",\r\nrval, mcp->mb[0], mcp->mb[1]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e7,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla82xx_set_driver_version(scsi_qla_host_t *vha, char *version)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nint i;\r\nint len;\r\nuint16_t *str;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!IS_P3P_TYPE(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x117b,\r\n"Entered %s.\n", __func__);\r\nstr = (void *)version;\r\nlen = strlen(version);\r\nmcp->mb[0] = MBC_SET_RNID_PARAMS;\r\nmcp->mb[1] = RNID_TYPE_SET_VERSION << 8;\r\nmcp->out_mb = MBX_1|MBX_0;\r\nfor (i = 4; i < 16 && len; i++, str++, len -= 2) {\r\nmcp->mb[i] = cpu_to_le16p(str);\r\nmcp->out_mb |= 1<<i;\r\n}\r\nfor (; i < 16; i++) {\r\nmcp->mb[i] = 0;\r\nmcp->out_mb |= 1<<i;\r\n}\r\nmcp->in_mb = MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x117c,\r\n"Failed=%x mb[0]=%x,%x.\n", rval, mcp->mb[0], mcp->mb[1]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x117d,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla25xx_set_driver_version(scsi_qla_host_t *vha, char *version)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nint len;\r\nuint16_t dwlen;\r\nuint8_t *str;\r\ndma_addr_t str_dma;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!IS_FWI2_CAPABLE(ha) || IS_QLA24XX_TYPE(ha) || IS_QLA81XX(ha) ||\r\nIS_P3P_TYPE(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x117e,\r\n"Entered %s.\n", __func__);\r\nstr = dma_pool_alloc(ha->s_dma_pool, GFP_KERNEL, &str_dma);\r\nif (!str) {\r\nql_log(ql_log_warn, vha, 0x117f,\r\n"Failed to allocate driver version param.\n");\r\nreturn QLA_MEMORY_ALLOC_FAILED;\r\n}\r\nmemcpy(str, "\x7\x3\x11\x0", 4);\r\ndwlen = str[0];\r\nlen = dwlen * 4 - 4;\r\nmemset(str + 4, 0, len);\r\nif (len > strlen(version))\r\nlen = strlen(version);\r\nmemcpy(str + 4, version, len);\r\nmcp->mb[0] = MBC_SET_RNID_PARAMS;\r\nmcp->mb[1] = RNID_TYPE_SET_VERSION << 8 | dwlen;\r\nmcp->mb[2] = MSW(LSD(str_dma));\r\nmcp->mb[3] = LSW(LSD(str_dma));\r\nmcp->mb[6] = MSW(MSD(str_dma));\r\nmcp->mb[7] = LSW(MSD(str_dma));\r\nmcp->out_mb = MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1180,\r\n"Failed=%x mb[0]=%x,%x.\n", rval, mcp->mb[0], mcp->mb[1]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1181,\r\n"Done %s.\n", __func__);\r\n}\r\ndma_pool_free(ha->s_dma_pool, str, str_dma);\r\nreturn rval;\r\n}\r\nstatic int\r\nqla2x00_read_asic_temperature(scsi_qla_host_t *vha, uint16_t *temp)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nif (!IS_FWI2_CAPABLE(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1159,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_GET_RNID_PARAMS;\r\nmcp->mb[1] = RNID_TYPE_ASIC_TEMP << 8;\r\nmcp->out_mb = MBX_1|MBX_0;\r\nmcp->in_mb = MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\n*temp = mcp->mb[1];\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x115a,\r\n"Failed=%x mb[0]=%x,%x.\n", rval, mcp->mb[0], mcp->mb[1]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x115b,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_read_sfp(scsi_qla_host_t *vha, dma_addr_t sfp_dma, uint8_t *sfp,\r\nuint16_t dev, uint16_t off, uint16_t len, uint16_t opt)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10e8,\r\n"Entered %s.\n", __func__);\r\nif (!IS_FWI2_CAPABLE(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nif (len == 1)\r\nopt |= BIT_0;\r\nmcp->mb[0] = MBC_READ_SFP;\r\nmcp->mb[1] = dev;\r\nmcp->mb[2] = MSW(sfp_dma);\r\nmcp->mb[3] = LSW(sfp_dma);\r\nmcp->mb[6] = MSW(MSD(sfp_dma));\r\nmcp->mb[7] = LSW(MSD(sfp_dma));\r\nmcp->mb[8] = len;\r\nmcp->mb[9] = off;\r\nmcp->mb[10] = opt;\r\nmcp->out_mb = MBX_10|MBX_9|MBX_8|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (opt & BIT_0)\r\n*sfp = mcp->mb[1];\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10e9,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10ea,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_write_sfp(scsi_qla_host_t *vha, dma_addr_t sfp_dma, uint8_t *sfp,\r\nuint16_t dev, uint16_t off, uint16_t len, uint16_t opt)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10eb,\r\n"Entered %s.\n", __func__);\r\nif (!IS_FWI2_CAPABLE(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nif (len == 1)\r\nopt |= BIT_0;\r\nif (opt & BIT_0)\r\nlen = *sfp;\r\nmcp->mb[0] = MBC_WRITE_SFP;\r\nmcp->mb[1] = dev;\r\nmcp->mb[2] = MSW(sfp_dma);\r\nmcp->mb[3] = LSW(sfp_dma);\r\nmcp->mb[6] = MSW(MSD(sfp_dma));\r\nmcp->mb[7] = LSW(MSD(sfp_dma));\r\nmcp->mb[8] = len;\r\nmcp->mb[9] = off;\r\nmcp->mb[10] = opt;\r\nmcp->out_mb = MBX_10|MBX_9|MBX_8|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10ec,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10ed,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_get_xgmac_stats(scsi_qla_host_t *vha, dma_addr_t stats_dma,\r\nuint16_t size_in_bytes, uint16_t *actual_size)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10ee,\r\n"Entered %s.\n", __func__);\r\nif (!IS_CNA_CAPABLE(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nmcp->mb[0] = MBC_GET_XGMAC_STATS;\r\nmcp->mb[2] = MSW(stats_dma);\r\nmcp->mb[3] = LSW(stats_dma);\r\nmcp->mb[6] = MSW(MSD(stats_dma));\r\nmcp->mb[7] = LSW(MSD(stats_dma));\r\nmcp->mb[8] = size_in_bytes >> 2;\r\nmcp->out_mb = MBX_8|MBX_7|MBX_6|MBX_3|MBX_2|MBX_0;\r\nmcp->in_mb = MBX_2|MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10ef,\r\n"Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x.\n",\r\nrval, mcp->mb[0], mcp->mb[1], mcp->mb[2]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10f0,\r\n"Done %s.\n", __func__);\r\n*actual_size = mcp->mb[2] << 2;\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_get_dcbx_params(scsi_qla_host_t *vha, dma_addr_t tlv_dma,\r\nuint16_t size)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10f1,\r\n"Entered %s.\n", __func__);\r\nif (!IS_CNA_CAPABLE(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nmcp->mb[0] = MBC_GET_DCBX_PARAMS;\r\nmcp->mb[1] = 0;\r\nmcp->mb[2] = MSW(tlv_dma);\r\nmcp->mb[3] = LSW(tlv_dma);\r\nmcp->mb[6] = MSW(MSD(tlv_dma));\r\nmcp->mb[7] = LSW(MSD(tlv_dma));\r\nmcp->mb[8] = size;\r\nmcp->out_mb = MBX_8|MBX_7|MBX_6|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_2|MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10f2,\r\n"Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x.\n",\r\nrval, mcp->mb[0], mcp->mb[1], mcp->mb[2]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10f3,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_read_ram_word(scsi_qla_host_t *vha, uint32_t risc_addr, uint32_t *data)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10f4,\r\n"Entered %s.\n", __func__);\r\nif (!IS_FWI2_CAPABLE(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nmcp->mb[0] = MBC_READ_RAM_EXTENDED;\r\nmcp->mb[1] = LSW(risc_addr);\r\nmcp->mb[8] = MSW(risc_addr);\r\nmcp->out_mb = MBX_8|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_3|MBX_2|MBX_0;\r\nmcp->tov = 30;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10f5,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10f6,\r\n"Done %s.\n", __func__);\r\n*data = mcp->mb[3] << 16 | mcp->mb[2];\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_loopback_test(scsi_qla_host_t *vha, struct msg_echo_lb *mreq,\r\nuint16_t *mresp)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10f7,\r\n"Entered %s.\n", __func__);\r\nmemset(mcp->mb, 0 , sizeof(mcp->mb));\r\nmcp->mb[0] = MBC_DIAGNOSTIC_LOOP_BACK;\r\nmcp->mb[1] = mreq->options | BIT_6;\r\nmcp->mb[10] = LSW(mreq->transfer_size);\r\nmcp->mb[11] = MSW(mreq->transfer_size);\r\nmcp->mb[14] = LSW(mreq->send_dma);\r\nmcp->mb[15] = MSW(mreq->send_dma);\r\nmcp->mb[20] = LSW(MSD(mreq->send_dma));\r\nmcp->mb[21] = MSW(MSD(mreq->send_dma));\r\nmcp->mb[16] = LSW(mreq->rcv_dma);\r\nmcp->mb[17] = MSW(mreq->rcv_dma);\r\nmcp->mb[6] = LSW(MSD(mreq->rcv_dma));\r\nmcp->mb[7] = MSW(MSD(mreq->rcv_dma));\r\nmcp->mb[18] = LSW(mreq->iteration_count);\r\nmcp->mb[19] = MSW(mreq->iteration_count);\r\nmcp->out_mb = MBX_21|MBX_20|MBX_19|MBX_18|MBX_17|MBX_16|MBX_15|\r\nMBX_14|MBX_13|MBX_12|MBX_11|MBX_10|MBX_7|MBX_6|MBX_1|MBX_0;\r\nif (IS_CNA_CAPABLE(vha->hw))\r\nmcp->out_mb |= MBX_2;\r\nmcp->in_mb = MBX_19|MBX_18|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->buf_size = mreq->transfer_size;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = MBX_DMA_OUT|MBX_DMA_IN|IOCTL_CMD;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10f8,\r\n"Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x mb[3]=%x mb[18]=%x "\r\n"mb[19]=%x.\n", rval, mcp->mb[0], mcp->mb[1], mcp->mb[2],\r\nmcp->mb[3], mcp->mb[18], mcp->mb[19]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10f9,\r\n"Done %s.\n", __func__);\r\n}\r\nmemcpy( mresp, mcp->mb, 64);\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_echo_test(scsi_qla_host_t *vha, struct msg_echo_lb *mreq,\r\nuint16_t *mresp)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10fa,\r\n"Entered %s.\n", __func__);\r\nmemset(mcp->mb, 0 , sizeof(mcp->mb));\r\nmcp->mb[0] = MBC_DIAGNOSTIC_ECHO;\r\nmcp->mb[1] = mreq->options | BIT_6;\r\nif (IS_CNA_CAPABLE(ha)) {\r\nmcp->mb[1] |= BIT_15;\r\nmcp->mb[2] = vha->fcoe_fcf_idx;\r\n}\r\nmcp->mb[16] = LSW(mreq->rcv_dma);\r\nmcp->mb[17] = MSW(mreq->rcv_dma);\r\nmcp->mb[6] = LSW(MSD(mreq->rcv_dma));\r\nmcp->mb[7] = MSW(MSD(mreq->rcv_dma));\r\nmcp->mb[10] = LSW(mreq->transfer_size);\r\nmcp->mb[14] = LSW(mreq->send_dma);\r\nmcp->mb[15] = MSW(mreq->send_dma);\r\nmcp->mb[20] = LSW(MSD(mreq->send_dma));\r\nmcp->mb[21] = MSW(MSD(mreq->send_dma));\r\nmcp->out_mb = MBX_21|MBX_20|MBX_17|MBX_16|MBX_15|\r\nMBX_14|MBX_10|MBX_7|MBX_6|MBX_1|MBX_0;\r\nif (IS_CNA_CAPABLE(ha))\r\nmcp->out_mb |= MBX_2;\r\nmcp->in_mb = MBX_0;\r\nif (IS_QLA24XX_TYPE(ha) || IS_QLA25XX(ha) ||\r\nIS_CNA_CAPABLE(ha) || IS_QLA2031(ha))\r\nmcp->in_mb |= MBX_1;\r\nif (IS_CNA_CAPABLE(ha) || IS_QLA2031(ha))\r\nmcp->in_mb |= MBX_3;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = MBX_DMA_OUT|MBX_DMA_IN|IOCTL_CMD;\r\nmcp->buf_size = mreq->transfer_size;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10fb,\r\n"Failed=%x mb[0]=%x mb[1]=%x.\n",\r\nrval, mcp->mb[0], mcp->mb[1]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10fc,\r\n"Done %s.\n", __func__);\r\n}\r\nmemcpy(mresp, mcp->mb, 64);\r\nreturn rval;\r\n}\r\nint\r\nqla84xx_reset_chip(scsi_qla_host_t *vha, uint16_t enable_diagnostic)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10fd,\r\n"Entered %s enable_diag=%d.\n", __func__, enable_diagnostic);\r\nmcp->mb[0] = MBC_ISP84XX_RESET;\r\nmcp->mb[1] = enable_diagnostic;\r\nmcp->out_mb = MBX_1|MBX_0;\r\nmcp->in_mb = MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = MBX_DMA_OUT|MBX_DMA_IN|IOCTL_CMD;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS)\r\nql_dbg(ql_dbg_mbx, vha, 0x10fe, "Failed=%x.\n", rval);\r\nelse\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10ff,\r\n"Done %s.\n", __func__);\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_write_ram_word(scsi_qla_host_t *vha, uint32_t risc_addr, uint32_t data)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1100,\r\n"Entered %s.\n", __func__);\r\nif (!IS_FWI2_CAPABLE(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nmcp->mb[0] = MBC_WRITE_RAM_WORD_EXTENDED;\r\nmcp->mb[1] = LSW(risc_addr);\r\nmcp->mb[2] = LSW(data);\r\nmcp->mb[3] = MSW(data);\r\nmcp->mb[8] = MSW(risc_addr);\r\nmcp->out_mb = MBX_8|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = 30;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1101,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1102,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla81xx_write_mpi_register(scsi_qla_host_t *vha, uint16_t *mb)\r\n{\r\nint rval;\r\nuint32_t stat, timer;\r\nuint16_t mb0 = 0;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_24xx __iomem *reg = &ha->iobase->isp24;\r\nrval = QLA_SUCCESS;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1103,\r\n"Entered %s.\n", __func__);\r\nclear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);\r\nWRT_REG_WORD(&reg->mailbox0, MBC_WRITE_MPI_REGISTER);\r\nWRT_REG_WORD(&reg->mailbox1, mb[0]);\r\nWRT_REG_WORD(&reg->mailbox2, mb[1]);\r\nWRT_REG_WORD(&reg->mailbox3, mb[2]);\r\nWRT_REG_WORD(&reg->mailbox4, mb[3]);\r\nWRT_REG_DWORD(&reg->hccr, HCCRX_SET_HOST_INT);\r\nfor (timer = 6000000; timer; timer--) {\r\nstat = RD_REG_DWORD(&reg->host_status);\r\nif (stat & HSRX_RISC_INT) {\r\nstat &= 0xff;\r\nif (stat == 0x1 || stat == 0x2 ||\r\nstat == 0x10 || stat == 0x11) {\r\nset_bit(MBX_INTERRUPT,\r\n&ha->mbx_cmd_flags);\r\nmb0 = RD_REG_WORD(&reg->mailbox0);\r\nWRT_REG_DWORD(&reg->hccr,\r\nHCCRX_CLR_RISC_INT);\r\nRD_REG_DWORD(&reg->hccr);\r\nbreak;\r\n}\r\n}\r\nudelay(5);\r\n}\r\nif (test_and_clear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags))\r\nrval = mb0 & MBS_MASK;\r\nelse\r\nrval = QLA_FUNCTION_FAILED;\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1104,\r\n"Failed=%x mb[0]=%x.\n", rval, mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1105,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_get_data_rate(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1106,\r\n"Entered %s.\n", __func__);\r\nif (!IS_FWI2_CAPABLE(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nmcp->mb[0] = MBC_DATA_RATE;\r\nmcp->mb[1] = 0;\r\nmcp->out_mb = MBX_1|MBX_0;\r\nmcp->in_mb = MBX_2|MBX_1|MBX_0;\r\nif (IS_QLA83XX(ha) || IS_QLA27XX(ha))\r\nmcp->in_mb |= MBX_3;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1107,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1108,\r\n"Done %s.\n", __func__);\r\nif (mcp->mb[1] != 0x7)\r\nha->link_data_rate = mcp->mb[1];\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla81xx_get_port_config(scsi_qla_host_t *vha, uint16_t *mb)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1109,\r\n"Entered %s.\n", __func__);\r\nif (!IS_QLA81XX(ha) && !IS_QLA83XX(ha) && !IS_QLA8044(ha) &&\r\n!IS_QLA27XX(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nmcp->mb[0] = MBC_GET_PORT_CONFIG;\r\nmcp->out_mb = MBX_0;\r\nmcp->in_mb = MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x110a,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nmemcpy(mb, &mcp->mb[1], sizeof(uint16_t) * 4);\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x110b,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla81xx_set_port_config(scsi_qla_host_t *vha, uint16_t *mb)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x110c,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_SET_PORT_CONFIG;\r\nmemcpy(&mcp->mb[1], mb, sizeof(uint16_t) * 4);\r\nmcp->out_mb = MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x110d,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x110e,\r\n"Done %s.\n", __func__);\r\nreturn rval;\r\n}\r\nint\r\nqla24xx_set_fcp_prio(scsi_qla_host_t *vha, uint16_t loop_id, uint16_t priority,\r\nuint16_t *mb)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x110f,\r\n"Entered %s.\n", __func__);\r\nif (!IS_QLA24XX_TYPE(ha) && !IS_QLA25XX(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nmcp->mb[0] = MBC_PORT_PARAMS;\r\nmcp->mb[1] = loop_id;\r\nif (ha->flags.fcp_prio_enabled)\r\nmcp->mb[2] = BIT_1;\r\nelse\r\nmcp->mb[2] = BIT_2;\r\nmcp->mb[4] = priority & 0xf;\r\nmcp->mb[9] = vha->vp_idx;\r\nmcp->out_mb = MBX_9|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_4|MBX_3|MBX_1|MBX_0;\r\nmcp->tov = 30;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (mb != NULL) {\r\nmb[0] = mcp->mb[0];\r\nmb[1] = mcp->mb[1];\r\nmb[3] = mcp->mb[3];\r\nmb[4] = mcp->mb[4];\r\n}\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x10cd, "Failed=%x.\n", rval);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x10cc,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_get_thermal_temp(scsi_qla_host_t *vha, uint16_t *temp)\r\n{\r\nint rval = QLA_FUNCTION_FAILED;\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint8_t byte;\r\nif (!IS_FWI2_CAPABLE(ha) || IS_QLA24XX_TYPE(ha) || IS_QLA81XX(ha)) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1150,\r\n"Thermal not supported by this card.\n");\r\nreturn rval;\r\n}\r\nif (IS_QLA25XX(ha)) {\r\nif (ha->pdev->subsystem_vendor == PCI_VENDOR_ID_QLOGIC &&\r\nha->pdev->subsystem_device == 0x0175) {\r\nrval = qla2x00_read_sfp(vha, 0, &byte,\r\n0x98, 0x1, 1, BIT_13|BIT_0);\r\n*temp = byte;\r\nreturn rval;\r\n}\r\nif (ha->pdev->subsystem_vendor == PCI_VENDOR_ID_HP &&\r\nha->pdev->subsystem_device == 0x338e) {\r\nrval = qla2x00_read_sfp(vha, 0, &byte,\r\n0x98, 0x1, 1, BIT_15|BIT_14|BIT_0);\r\n*temp = byte;\r\nreturn rval;\r\n}\r\nql_dbg(ql_dbg_mbx, vha, 0x10c9,\r\n"Thermal not supported by this card.\n");\r\nreturn rval;\r\n}\r\nif (IS_QLA82XX(ha)) {\r\n*temp = qla82xx_read_temperature(vha);\r\nrval = QLA_SUCCESS;\r\nreturn rval;\r\n} else if (IS_QLA8044(ha)) {\r\n*temp = qla8044_read_temperature(vha);\r\nrval = QLA_SUCCESS;\r\nreturn rval;\r\n}\r\nrval = qla2x00_read_asic_temperature(vha, temp);\r\nreturn rval;\r\n}\r\nint\r\nqla82xx_mbx_intr_enable(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1017,\r\n"Entered %s.\n", __func__);\r\nif (!IS_FWI2_CAPABLE(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nmemset(mcp, 0, sizeof(mbx_cmd_t));\r\nmcp->mb[0] = MBC_TOGGLE_INTERRUPT;\r\nmcp->mb[1] = 1;\r\nmcp->out_mb = MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = 30;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1016,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x100e,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla82xx_mbx_intr_disable(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x100d,\r\n"Entered %s.\n", __func__);\r\nif (!IS_P3P_TYPE(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nmemset(mcp, 0, sizeof(mbx_cmd_t));\r\nmcp->mb[0] = MBC_TOGGLE_INTERRUPT;\r\nmcp->mb[1] = 0;\r\nmcp->out_mb = MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = 30;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x100c,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x100b,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla82xx_md_get_template_size(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nint rval = QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x111f,\r\n"Entered %s.\n", __func__);\r\nmemset(mcp->mb, 0 , sizeof(mcp->mb));\r\nmcp->mb[0] = LSW(MBC_DIAGNOSTIC_MINIDUMP_TEMPLATE);\r\nmcp->mb[1] = MSW(MBC_DIAGNOSTIC_MINIDUMP_TEMPLATE);\r\nmcp->mb[2] = LSW(RQST_TMPLT_SIZE);\r\nmcp->mb[3] = MSW(RQST_TMPLT_SIZE);\r\nmcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_14|MBX_13|MBX_12|MBX_11|MBX_10|MBX_9|MBX_8|\r\nMBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->flags = MBX_DMA_OUT|MBX_DMA_IN|IOCTL_CMD;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1120,\r\n"mailbox command FAILED=0x%x, subcode=%x.\n",\r\n(mcp->mb[1] << 16) | mcp->mb[0],\r\n(mcp->mb[3] << 16) | mcp->mb[2]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1121,\r\n"Done %s.\n", __func__);\r\nha->md_template_size = ((mcp->mb[3] << 16) | mcp->mb[2]);\r\nif (!ha->md_template_size) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1122,\r\n"Null template size obtained.\n");\r\nrval = QLA_FUNCTION_FAILED;\r\n}\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla82xx_md_get_template(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nint rval = QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1123,\r\n"Entered %s.\n", __func__);\r\nha->md_tmplt_hdr = dma_alloc_coherent(&ha->pdev->dev,\r\nha->md_template_size, &ha->md_tmplt_hdr_dma, GFP_KERNEL);\r\nif (!ha->md_tmplt_hdr) {\r\nql_log(ql_log_warn, vha, 0x1124,\r\n"Unable to allocate memory for Minidump template.\n");\r\nreturn rval;\r\n}\r\nmemset(mcp->mb, 0 , sizeof(mcp->mb));\r\nmcp->mb[0] = LSW(MBC_DIAGNOSTIC_MINIDUMP_TEMPLATE);\r\nmcp->mb[1] = MSW(MBC_DIAGNOSTIC_MINIDUMP_TEMPLATE);\r\nmcp->mb[2] = LSW(RQST_TMPLT);\r\nmcp->mb[3] = MSW(RQST_TMPLT);\r\nmcp->mb[4] = LSW(LSD(ha->md_tmplt_hdr_dma));\r\nmcp->mb[5] = MSW(LSD(ha->md_tmplt_hdr_dma));\r\nmcp->mb[6] = LSW(MSD(ha->md_tmplt_hdr_dma));\r\nmcp->mb[7] = MSW(MSD(ha->md_tmplt_hdr_dma));\r\nmcp->mb[8] = LSW(ha->md_template_size);\r\nmcp->mb[9] = MSW(ha->md_template_size);\r\nmcp->flags = MBX_DMA_OUT|MBX_DMA_IN|IOCTL_CMD;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->out_mb = MBX_11|MBX_10|MBX_9|MBX_8|\r\nMBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_3|MBX_2|MBX_1|MBX_0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1125,\r\n"mailbox command FAILED=0x%x, subcode=%x.\n",\r\n((mcp->mb[1] << 16) | mcp->mb[0]),\r\n((mcp->mb[3] << 16) | mcp->mb[2]));\r\n} else\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1126,\r\n"Done %s.\n", __func__);\r\nreturn rval;\r\n}\r\nint\r\nqla8044_md_get_template(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nint rval = QLA_FUNCTION_FAILED;\r\nint offset = 0, size = MINIDUMP_SIZE_36K;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0xb11f,\r\n"Entered %s.\n", __func__);\r\nha->md_tmplt_hdr = dma_alloc_coherent(&ha->pdev->dev,\r\nha->md_template_size, &ha->md_tmplt_hdr_dma, GFP_KERNEL);\r\nif (!ha->md_tmplt_hdr) {\r\nql_log(ql_log_warn, vha, 0xb11b,\r\n"Unable to allocate memory for Minidump template.\n");\r\nreturn rval;\r\n}\r\nmemset(mcp->mb, 0 , sizeof(mcp->mb));\r\nwhile (offset < ha->md_template_size) {\r\nmcp->mb[0] = LSW(MBC_DIAGNOSTIC_MINIDUMP_TEMPLATE);\r\nmcp->mb[1] = MSW(MBC_DIAGNOSTIC_MINIDUMP_TEMPLATE);\r\nmcp->mb[2] = LSW(RQST_TMPLT);\r\nmcp->mb[3] = MSW(RQST_TMPLT);\r\nmcp->mb[4] = LSW(LSD(ha->md_tmplt_hdr_dma + offset));\r\nmcp->mb[5] = MSW(LSD(ha->md_tmplt_hdr_dma + offset));\r\nmcp->mb[6] = LSW(MSD(ha->md_tmplt_hdr_dma + offset));\r\nmcp->mb[7] = MSW(MSD(ha->md_tmplt_hdr_dma + offset));\r\nmcp->mb[8] = LSW(size);\r\nmcp->mb[9] = MSW(size);\r\nmcp->mb[10] = offset & 0x0000FFFF;\r\nmcp->mb[11] = offset & 0xFFFF0000;\r\nmcp->flags = MBX_DMA_OUT|MBX_DMA_IN|IOCTL_CMD;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->out_mb = MBX_11|MBX_10|MBX_9|MBX_8|\r\nMBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_3|MBX_2|MBX_1|MBX_0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0xb11c,\r\n"mailbox command FAILED=0x%x, subcode=%x.\n",\r\n((mcp->mb[1] << 16) | mcp->mb[0]),\r\n((mcp->mb[3] << 16) | mcp->mb[2]));\r\nreturn rval;\r\n} else\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0xb11d,\r\n"Done %s.\n", __func__);\r\noffset = offset + size;\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla81xx_set_led_config(scsi_qla_host_t *vha, uint16_t *led_cfg)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nif (!IS_QLA81XX(ha) && !IS_QLA8031(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1133,\r\n"Entered %s.\n", __func__);\r\nmemset(mcp, 0, sizeof(mbx_cmd_t));\r\nmcp->mb[0] = MBC_SET_LED_CONFIG;\r\nmcp->mb[1] = led_cfg[0];\r\nmcp->mb[2] = led_cfg[1];\r\nif (IS_QLA8031(ha)) {\r\nmcp->mb[3] = led_cfg[2];\r\nmcp->mb[4] = led_cfg[3];\r\nmcp->mb[5] = led_cfg[4];\r\nmcp->mb[6] = led_cfg[5];\r\n}\r\nmcp->out_mb = MBX_2|MBX_1|MBX_0;\r\nif (IS_QLA8031(ha))\r\nmcp->out_mb |= MBX_6|MBX_5|MBX_4|MBX_3;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = 30;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1134,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1135,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla81xx_get_led_config(scsi_qla_host_t *vha, uint16_t *led_cfg)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nif (!IS_QLA81XX(ha) && !IS_QLA8031(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1136,\r\n"Entered %s.\n", __func__);\r\nmemset(mcp, 0, sizeof(mbx_cmd_t));\r\nmcp->mb[0] = MBC_GET_LED_CONFIG;\r\nmcp->out_mb = MBX_0;\r\nmcp->in_mb = MBX_2|MBX_1|MBX_0;\r\nif (IS_QLA8031(ha))\r\nmcp->in_mb |= MBX_6|MBX_5|MBX_4|MBX_3;\r\nmcp->tov = 30;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1137,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nled_cfg[0] = mcp->mb[1];\r\nled_cfg[1] = mcp->mb[2];\r\nif (IS_QLA8031(ha)) {\r\nled_cfg[2] = mcp->mb[3];\r\nled_cfg[3] = mcp->mb[4];\r\nled_cfg[4] = mcp->mb[5];\r\nled_cfg[5] = mcp->mb[6];\r\n}\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1138,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla82xx_mbx_beacon_ctl(scsi_qla_host_t *vha, int enable)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nif (!IS_P3P_TYPE(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1127,\r\n"Entered %s.\n", __func__);\r\nmemset(mcp, 0, sizeof(mbx_cmd_t));\r\nmcp->mb[0] = MBC_SET_LED_CONFIG;\r\nif (enable)\r\nmcp->mb[7] = 0xE;\r\nelse\r\nmcp->mb[7] = 0xD;\r\nmcp->out_mb = MBX_7|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1128,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1129,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla83xx_wr_reg(scsi_qla_host_t *vha, uint32_t reg, uint32_t data)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nif (!IS_QLA83XX(ha) && !IS_QLA27XX(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1130,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_WRITE_REMOTE_REG;\r\nmcp->mb[1] = LSW(reg);\r\nmcp->mb[2] = MSW(reg);\r\nmcp->mb[3] = LSW(data);\r\nmcp->mb[4] = MSW(data);\r\nmcp->out_mb = MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1131,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1132,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_port_logout(scsi_qla_host_t *vha, struct fc_port *fcport)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nif (IS_QLA2100(ha) || IS_QLA2200(ha)) {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x113b,\r\n"Implicit LOGO Unsupported.\n");\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x113c,\r\n"Entering %s.\n", __func__);\r\nmcp->mb[0] = MBC_PORT_LOGOUT;\r\nmcp->mb[1] = fcport->loop_id;\r\nmcp->mb[10] = BIT_15;\r\nmcp->out_mb = MBX_10|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS)\r\nql_dbg(ql_dbg_mbx, vha, 0x113d,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\nelse\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x113e,\r\n"Done %s.\n", __func__);\r\nreturn rval;\r\n}\r\nint\r\nqla83xx_rd_reg(scsi_qla_host_t *vha, uint32_t reg, uint32_t *data)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nstruct qla_hw_data *ha = vha->hw;\r\nunsigned long retry_max_time = jiffies + (2 * HZ);\r\nif (!IS_QLA83XX(ha) && !IS_QLA27XX(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx, vha, 0x114b, "Entered %s.\n", __func__);\r\nretry_rd_reg:\r\nmcp->mb[0] = MBC_READ_REMOTE_REG;\r\nmcp->mb[1] = LSW(reg);\r\nmcp->mb[2] = MSW(reg);\r\nmcp->out_mb = MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_4|MBX_3|MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x114c,\r\n"Failed=%x mb[0]=%x mb[1]=%x.\n",\r\nrval, mcp->mb[0], mcp->mb[1]);\r\n} else {\r\n*data = (mcp->mb[3] | (mcp->mb[4] << 16));\r\nif (*data == QLA8XXX_BAD_VALUE) {\r\nif (time_after(jiffies, retry_max_time)) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1141,\r\n"Failure to read CAMRAM register. "\r\n"data=0x%x.\n", *data);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nmsleep(100);\r\ngoto retry_rd_reg;\r\n}\r\nql_dbg(ql_dbg_mbx, vha, 0x1142, "Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla83xx_restart_nic_firmware(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!IS_QLA83XX(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx, vha, 0x1143, "Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_RESTART_NIC_FIRMWARE;\r\nmcp->out_mb = MBX_0;\r\nmcp->in_mb = MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1144,\r\n"Failed=%x mb[0]=%x mb[1]=%x.\n",\r\nrval, mcp->mb[0], mcp->mb[1]);\r\nha->isp_ops->fw_dump(vha, 0);\r\n} else {\r\nql_dbg(ql_dbg_mbx, vha, 0x1145, "Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla83xx_access_control(scsi_qla_host_t *vha, uint16_t options,\r\nuint32_t start_addr, uint32_t end_addr, uint16_t *sector_size)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nuint8_t subcode = (uint8_t)options;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!IS_QLA8031(ha))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx, vha, 0x1146, "Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_SET_ACCESS_CONTROL;\r\nmcp->mb[1] = options;\r\nmcp->out_mb = MBX_1|MBX_0;\r\nif (subcode & BIT_2) {\r\nmcp->mb[2] = LSW(start_addr);\r\nmcp->mb[3] = MSW(start_addr);\r\nmcp->mb[4] = LSW(end_addr);\r\nmcp->mb[5] = MSW(end_addr);\r\nmcp->out_mb |= MBX_5|MBX_4|MBX_3|MBX_2;\r\n}\r\nmcp->in_mb = MBX_2|MBX_1|MBX_0;\r\nif (!(subcode & (BIT_2 | BIT_5)))\r\nmcp->in_mb |= MBX_4|MBX_3;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1147,\r\n"Failed=%x mb[0]=%x mb[1]=%x mb[2]=%x mb[3]=%x mb[4]=%x.\n",\r\nrval, mcp->mb[0], mcp->mb[1], mcp->mb[2], mcp->mb[3],\r\nmcp->mb[4]);\r\nha->isp_ops->fw_dump(vha, 0);\r\n} else {\r\nif (subcode & BIT_5)\r\n*sector_size = mcp->mb[1];\r\nelse if (subcode & (BIT_6 | BIT_7)) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1148,\r\n"Driver-lock id=%x%x", mcp->mb[4], mcp->mb[3]);\r\n} else if (subcode & (BIT_3 | BIT_4)) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1149,\r\n"Flash-lock id=%x%x", mcp->mb[4], mcp->mb[3]);\r\n}\r\nql_dbg(ql_dbg_mbx, vha, 0x114a, "Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqla2x00_dump_mctp_data(scsi_qla_host_t *vha, dma_addr_t req_dma, uint32_t addr,\r\nuint32_t size)\r\n{\r\nint rval;\r\nmbx_cmd_t mc;\r\nmbx_cmd_t *mcp = &mc;\r\nif (!IS_MCTP_CAPABLE(vha->hw))\r\nreturn QLA_FUNCTION_FAILED;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x114f,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_DUMP_RISC_RAM_EXTENDED;\r\nmcp->mb[1] = LSW(addr);\r\nmcp->mb[2] = MSW(req_dma);\r\nmcp->mb[3] = LSW(req_dma);\r\nmcp->mb[4] = MSW(size);\r\nmcp->mb[5] = LSW(size);\r\nmcp->mb[6] = MSW(MSD(req_dma));\r\nmcp->mb[7] = LSW(MSD(req_dma));\r\nmcp->mb[8] = MSW(addr);\r\nmcp->mb[10] |= BIT_7;\r\nmcp->mb[10] |= 0x40;\r\nmcp->out_mb |= MBX_10|MBX_8|MBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|\r\nMBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qla2x00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x114e,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x114d,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}
