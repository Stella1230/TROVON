static struct qla_tgt_sess *qlt_find_sess_by_port_name(\r\nstruct qla_tgt *tgt,\r\nconst uint8_t *port_name)\r\n{\r\nstruct qla_tgt_sess *sess;\r\nlist_for_each_entry(sess, &tgt->sess_list, sess_list_entry) {\r\nif (!memcmp(sess->port_name, port_name, WWN_SIZE))\r\nreturn sess;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline int qlt_issue_marker(struct scsi_qla_host *vha, int vha_locked)\r\n{\r\nif (unlikely(vha->marker_needed != 0)) {\r\nint rc = qla2x00_issue_marker(vha, vha_locked);\r\nif (rc != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe03d,\r\n"qla_target(%d): issue_marker() failed\n",\r\nvha->vp_idx);\r\n}\r\nreturn rc;\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic inline\r\nstruct scsi_qla_host *qlt_find_host_by_d_id(struct scsi_qla_host *vha,\r\nuint8_t *d_id)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint8_t vp_idx;\r\nif ((vha->d_id.b.area != d_id[1]) || (vha->d_id.b.domain != d_id[0]))\r\nreturn NULL;\r\nif (vha->d_id.b.al_pa == d_id[2])\r\nreturn vha;\r\nBUG_ON(ha->tgt.tgt_vp_map == NULL);\r\nvp_idx = ha->tgt.tgt_vp_map[d_id[2]].idx;\r\nif (likely(test_bit(vp_idx, ha->vp_idx_map)))\r\nreturn ha->tgt.tgt_vp_map[vp_idx].vha;\r\nreturn NULL;\r\n}\r\nstatic inline\r\nstruct scsi_qla_host *qlt_find_host_by_vp_idx(struct scsi_qla_host *vha,\r\nuint16_t vp_idx)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (vha->vp_idx == vp_idx)\r\nreturn vha;\r\nBUG_ON(ha->tgt.tgt_vp_map == NULL);\r\nif (likely(test_bit(vp_idx, ha->vp_idx_map)))\r\nreturn ha->tgt.tgt_vp_map[vp_idx].vha;\r\nreturn NULL;\r\n}\r\nstatic inline void qlt_incr_num_pend_cmds(struct scsi_qla_host *vha)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&vha->hw->tgt.q_full_lock, flags);\r\nvha->hw->tgt.num_pend_cmds++;\r\nif (vha->hw->tgt.num_pend_cmds > vha->hw->qla_stats.stat_max_pend_cmds)\r\nvha->hw->qla_stats.stat_max_pend_cmds =\r\nvha->hw->tgt.num_pend_cmds;\r\nspin_unlock_irqrestore(&vha->hw->tgt.q_full_lock, flags);\r\n}\r\nstatic inline void qlt_decr_num_pend_cmds(struct scsi_qla_host *vha)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&vha->hw->tgt.q_full_lock, flags);\r\nvha->hw->tgt.num_pend_cmds--;\r\nspin_unlock_irqrestore(&vha->hw->tgt.q_full_lock, flags);\r\n}\r\nstatic void qlt_24xx_atio_pkt_all_vps(struct scsi_qla_host *vha,\r\nstruct atio_from_isp *atio)\r\n{\r\nql_dbg(ql_dbg_tgt, vha, 0xe072,\r\n"%s: qla_target(%d): type %x ox_id %04x\n",\r\n__func__, vha->vp_idx, atio->u.raw.entry_type,\r\nbe16_to_cpu(atio->u.isp24.fcp_hdr.ox_id));\r\nswitch (atio->u.raw.entry_type) {\r\ncase ATIO_TYPE7:\r\n{\r\nstruct scsi_qla_host *host = qlt_find_host_by_d_id(vha,\r\natio->u.isp24.fcp_hdr.d_id);\r\nif (unlikely(NULL == host)) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe03e,\r\n"qla_target(%d): Received ATIO_TYPE7 "\r\n"with unknown d_id %x:%x:%x\n", vha->vp_idx,\r\natio->u.isp24.fcp_hdr.d_id[0],\r\natio->u.isp24.fcp_hdr.d_id[1],\r\natio->u.isp24.fcp_hdr.d_id[2]);\r\nbreak;\r\n}\r\nqlt_24xx_atio_pkt(host, atio);\r\nbreak;\r\n}\r\ncase IMMED_NOTIFY_TYPE:\r\n{\r\nstruct scsi_qla_host *host = vha;\r\nstruct imm_ntfy_from_isp *entry =\r\n(struct imm_ntfy_from_isp *)atio;\r\nif ((entry->u.isp24.vp_index != 0xFF) &&\r\n(entry->u.isp24.nport_handle != 0xFFFF)) {\r\nhost = qlt_find_host_by_vp_idx(vha,\r\nentry->u.isp24.vp_index);\r\nif (unlikely(!host)) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe03f,\r\n"qla_target(%d): Received "\r\n"ATIO (IMMED_NOTIFY_TYPE) "\r\n"with unknown vp_index %d\n",\r\nvha->vp_idx, entry->u.isp24.vp_index);\r\nbreak;\r\n}\r\n}\r\nqlt_24xx_atio_pkt(host, atio);\r\nbreak;\r\n}\r\ndefault:\r\nql_dbg(ql_dbg_tgt, vha, 0xe040,\r\n"qla_target(%d): Received unknown ATIO atio "\r\n"type %x\n", vha->vp_idx, atio->u.raw.entry_type);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nvoid qlt_response_pkt_all_vps(struct scsi_qla_host *vha, response_t *pkt)\r\n{\r\nswitch (pkt->entry_type) {\r\ncase CTIO_CRC2:\r\nql_dbg(ql_dbg_tgt, vha, 0xe073,\r\n"qla_target(%d):%s: CRC2 Response pkt\n",\r\nvha->vp_idx, __func__);\r\ncase CTIO_TYPE7:\r\n{\r\nstruct ctio7_from_24xx *entry = (struct ctio7_from_24xx *)pkt;\r\nstruct scsi_qla_host *host = qlt_find_host_by_vp_idx(vha,\r\nentry->vp_index);\r\nif (unlikely(!host)) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe041,\r\n"qla_target(%d): Response pkt (CTIO_TYPE7) "\r\n"received, with unknown vp_index %d\n",\r\nvha->vp_idx, entry->vp_index);\r\nbreak;\r\n}\r\nqlt_response_pkt(host, pkt);\r\nbreak;\r\n}\r\ncase IMMED_NOTIFY_TYPE:\r\n{\r\nstruct scsi_qla_host *host = vha;\r\nstruct imm_ntfy_from_isp *entry =\r\n(struct imm_ntfy_from_isp *)pkt;\r\nhost = qlt_find_host_by_vp_idx(vha, entry->u.isp24.vp_index);\r\nif (unlikely(!host)) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe042,\r\n"qla_target(%d): Response pkt (IMMED_NOTIFY_TYPE) "\r\n"received, with unknown vp_index %d\n",\r\nvha->vp_idx, entry->u.isp24.vp_index);\r\nbreak;\r\n}\r\nqlt_response_pkt(host, pkt);\r\nbreak;\r\n}\r\ncase NOTIFY_ACK_TYPE:\r\n{\r\nstruct scsi_qla_host *host = vha;\r\nstruct nack_to_isp *entry = (struct nack_to_isp *)pkt;\r\nif (0xFF != entry->u.isp24.vp_index) {\r\nhost = qlt_find_host_by_vp_idx(vha,\r\nentry->u.isp24.vp_index);\r\nif (unlikely(!host)) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe043,\r\n"qla_target(%d): Response "\r\n"pkt (NOTIFY_ACK_TYPE) "\r\n"received, with unknown "\r\n"vp_index %d\n", vha->vp_idx,\r\nentry->u.isp24.vp_index);\r\nbreak;\r\n}\r\n}\r\nqlt_response_pkt(host, pkt);\r\nbreak;\r\n}\r\ncase ABTS_RECV_24XX:\r\n{\r\nstruct abts_recv_from_24xx *entry =\r\n(struct abts_recv_from_24xx *)pkt;\r\nstruct scsi_qla_host *host = qlt_find_host_by_vp_idx(vha,\r\nentry->vp_index);\r\nif (unlikely(!host)) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe044,\r\n"qla_target(%d): Response pkt "\r\n"(ABTS_RECV_24XX) received, with unknown "\r\n"vp_index %d\n", vha->vp_idx, entry->vp_index);\r\nbreak;\r\n}\r\nqlt_response_pkt(host, pkt);\r\nbreak;\r\n}\r\ncase ABTS_RESP_24XX:\r\n{\r\nstruct abts_resp_to_24xx *entry =\r\n(struct abts_resp_to_24xx *)pkt;\r\nstruct scsi_qla_host *host = qlt_find_host_by_vp_idx(vha,\r\nentry->vp_index);\r\nif (unlikely(!host)) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe045,\r\n"qla_target(%d): Response pkt "\r\n"(ABTS_RECV_24XX) received, with unknown "\r\n"vp_index %d\n", vha->vp_idx, entry->vp_index);\r\nbreak;\r\n}\r\nqlt_response_pkt(host, pkt);\r\nbreak;\r\n}\r\ndefault:\r\nqlt_response_pkt(vha, pkt);\r\nbreak;\r\n}\r\n}\r\nstatic void qlt_free_session_done(struct work_struct *work)\r\n{\r\nstruct qla_tgt_sess *sess = container_of(work, struct qla_tgt_sess,\r\nfree_work);\r\nstruct qla_tgt *tgt = sess->tgt;\r\nstruct scsi_qla_host *vha = sess->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nBUG_ON(!tgt);\r\nif (sess->se_sess != NULL)\r\nha->tgt.tgt_ops->free_session(sess);\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf001,\r\n"Unregistration of sess %p finished\n", sess);\r\nkfree(sess);\r\ntgt->sess_count--;\r\nif (tgt->sess_count == 0)\r\nwake_up_all(&tgt->waitQ);\r\n}\r\nvoid qlt_unreg_sess(struct qla_tgt_sess *sess)\r\n{\r\nstruct scsi_qla_host *vha = sess->vha;\r\nvha->hw->tgt.tgt_ops->clear_nacl_from_fcport_map(sess);\r\nlist_del(&sess->sess_list_entry);\r\nif (sess->deleted)\r\nlist_del(&sess->del_list_entry);\r\nINIT_WORK(&sess->free_work, qlt_free_session_done);\r\nschedule_work(&sess->free_work);\r\n}\r\nstatic int qlt_reset(struct scsi_qla_host *vha, void *iocb, int mcmd)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt_sess *sess = NULL;\r\nuint32_t unpacked_lun, lun = 0;\r\nuint16_t loop_id;\r\nint res = 0;\r\nstruct imm_ntfy_from_isp *n = (struct imm_ntfy_from_isp *)iocb;\r\nstruct atio_from_isp *a = (struct atio_from_isp *)iocb;\r\nloop_id = le16_to_cpu(n->u.isp24.nport_handle);\r\nif (loop_id == 0xFFFF) {\r\n#if 0\r\natomic_inc(&ha->tgt.qla_tgt->tgt_global_resets_count);\r\nqlt_clear_tgt_db(ha->tgt.qla_tgt);\r\nif (!list_empty(&ha->tgt.qla_tgt->sess_list)) {\r\nsess = list_entry(ha->tgt.qla_tgt->sess_list.next,\r\ntypeof(*sess), sess_list_entry);\r\nswitch (mcmd) {\r\ncase QLA_TGT_NEXUS_LOSS_SESS:\r\nmcmd = QLA_TGT_NEXUS_LOSS;\r\nbreak;\r\ncase QLA_TGT_ABORT_ALL_SESS:\r\nmcmd = QLA_TGT_ABORT_ALL;\r\nbreak;\r\ncase QLA_TGT_NEXUS_LOSS:\r\ncase QLA_TGT_ABORT_ALL:\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_tgt, vha, 0xe046,\r\n"qla_target(%d): Not allowed "\r\n"command %x in %s", vha->vp_idx,\r\nmcmd, __func__);\r\nsess = NULL;\r\nbreak;\r\n}\r\n} else\r\nsess = NULL;\r\n#endif\r\n} else {\r\nsess = ha->tgt.tgt_ops->find_sess_by_loop_id(vha, loop_id);\r\n}\r\nql_dbg(ql_dbg_tgt, vha, 0xe000,\r\n"Using sess for qla_tgt_reset: %p\n", sess);\r\nif (!sess) {\r\nres = -ESRCH;\r\nreturn res;\r\n}\r\nql_dbg(ql_dbg_tgt, vha, 0xe047,\r\n"scsi(%ld): resetting (session %p from port %8phC mcmd %x, "\r\n"loop_id %d)\n", vha->host_no, sess, sess->port_name,\r\nmcmd, loop_id);\r\nlun = a->u.isp24.fcp_cmnd.lun;\r\nunpacked_lun = scsilun_to_int((struct scsi_lun *)&lun);\r\nreturn qlt_issue_task_mgmt(sess, unpacked_lun, mcmd,\r\niocb, QLA24XX_MGMT_SEND_NACK);\r\n}\r\nstatic void qlt_schedule_sess_for_deletion(struct qla_tgt_sess *sess,\r\nbool immediate)\r\n{\r\nstruct qla_tgt *tgt = sess->tgt;\r\nuint32_t dev_loss_tmo = tgt->ha->port_down_retry_count + 5;\r\nif (sess->deleted)\r\nreturn;\r\nql_dbg(ql_dbg_tgt, sess->vha, 0xe001,\r\n"Scheduling sess %p for deletion\n", sess);\r\nlist_add_tail(&sess->del_list_entry, &tgt->del_sess_list);\r\nsess->deleted = 1;\r\nif (immediate)\r\ndev_loss_tmo = 0;\r\nsess->expires = jiffies + dev_loss_tmo * HZ;\r\nql_dbg(ql_dbg_tgt, sess->vha, 0xe048,\r\n"qla_target(%d): session for port %8phC (loop ID %d) scheduled for "\r\n"deletion in %u secs (expires: %lu) immed: %d\n",\r\nsess->vha->vp_idx, sess->port_name, sess->loop_id, dev_loss_tmo,\r\nsess->expires, immediate);\r\nif (immediate)\r\nschedule_delayed_work(&tgt->sess_del_work, 0);\r\nelse\r\nschedule_delayed_work(&tgt->sess_del_work,\r\nsess->expires - jiffies);\r\n}\r\nstatic void qlt_clear_tgt_db(struct qla_tgt *tgt)\r\n{\r\nstruct qla_tgt_sess *sess;\r\nlist_for_each_entry(sess, &tgt->sess_list, sess_list_entry)\r\nqlt_schedule_sess_for_deletion(sess, true);\r\n}\r\nstatic int qla24xx_get_loop_id(struct scsi_qla_host *vha, const uint8_t *s_id,\r\nuint16_t *loop_id)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\ndma_addr_t gid_list_dma;\r\nstruct gid_list_info *gid_list;\r\nchar *id_iter;\r\nint res, rc, i;\r\nuint16_t entries;\r\ngid_list = dma_alloc_coherent(&ha->pdev->dev, qla2x00_gid_list_size(ha),\r\n&gid_list_dma, GFP_KERNEL);\r\nif (!gid_list) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf044,\r\n"qla_target(%d): DMA Alloc failed of %u\n",\r\nvha->vp_idx, qla2x00_gid_list_size(ha));\r\nreturn -ENOMEM;\r\n}\r\nrc = qla2x00_get_id_list(vha, gid_list, gid_list_dma, &entries);\r\nif (rc != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf045,\r\n"qla_target(%d): get_id_list() failed: %x\n",\r\nvha->vp_idx, rc);\r\nres = -1;\r\ngoto out_free_id_list;\r\n}\r\nid_iter = (char *)gid_list;\r\nres = -1;\r\nfor (i = 0; i < entries; i++) {\r\nstruct gid_list_info *gid = (struct gid_list_info *)id_iter;\r\nif ((gid->al_pa == s_id[2]) &&\r\n(gid->area == s_id[1]) &&\r\n(gid->domain == s_id[0])) {\r\n*loop_id = le16_to_cpu(gid->loop_id);\r\nres = 0;\r\nbreak;\r\n}\r\nid_iter += ha->gid_list_info_size;\r\n}\r\nout_free_id_list:\r\ndma_free_coherent(&ha->pdev->dev, qla2x00_gid_list_size(ha),\r\ngid_list, gid_list_dma);\r\nreturn res;\r\n}\r\nstatic void qlt_undelete_sess(struct qla_tgt_sess *sess)\r\n{\r\nBUG_ON(!sess->deleted);\r\nlist_del(&sess->del_list_entry);\r\nsess->deleted = 0;\r\n}\r\nstatic void qlt_del_sess_work_fn(struct delayed_work *work)\r\n{\r\nstruct qla_tgt *tgt = container_of(work, struct qla_tgt,\r\nsess_del_work);\r\nstruct scsi_qla_host *vha = tgt->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt_sess *sess;\r\nunsigned long flags, elapsed;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nwhile (!list_empty(&tgt->del_sess_list)) {\r\nsess = list_entry(tgt->del_sess_list.next, typeof(*sess),\r\ndel_list_entry);\r\nelapsed = jiffies;\r\nif (time_after_eq(elapsed, sess->expires)) {\r\nqlt_undelete_sess(sess);\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf004,\r\n"Timeout: sess %p about to be deleted\n",\r\nsess);\r\nha->tgt.tgt_ops->shutdown_sess(sess);\r\nha->tgt.tgt_ops->put_sess(sess);\r\n} else {\r\nschedule_delayed_work(&tgt->sess_del_work,\r\nsess->expires - elapsed);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nstatic struct qla_tgt_sess *qlt_create_sess(\r\nstruct scsi_qla_host *vha,\r\nfc_port_t *fcport,\r\nbool local)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt_sess *sess;\r\nunsigned long flags;\r\nunsigned char be_sid[3];\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nlist_for_each_entry(sess, &vha->vha_tgt.qla_tgt->sess_list,\r\nsess_list_entry) {\r\nif (!memcmp(sess->port_name, fcport->port_name, WWN_SIZE)) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf005,\r\n"Double sess %p found (s_id %x:%x:%x, "\r\n"loop_id %d), updating to d_id %x:%x:%x, "\r\n"loop_id %d", sess, sess->s_id.b.domain,\r\nsess->s_id.b.al_pa, sess->s_id.b.area,\r\nsess->loop_id, fcport->d_id.b.domain,\r\nfcport->d_id.b.al_pa, fcport->d_id.b.area,\r\nfcport->loop_id);\r\nif (sess->deleted)\r\nqlt_undelete_sess(sess);\r\nkref_get(&sess->se_sess->sess_kref);\r\nha->tgt.tgt_ops->update_sess(sess, fcport->d_id, fcport->loop_id,\r\n(fcport->flags & FCF_CONF_COMP_SUPPORTED));\r\nif (sess->local && !local)\r\nsess->local = 0;\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn sess;\r\n}\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nsess = kzalloc(sizeof(*sess), GFP_KERNEL);\r\nif (!sess) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf04a,\r\n"qla_target(%u): session allocation failed, all commands "\r\n"from port %8phC will be refused", vha->vp_idx,\r\nfcport->port_name);\r\nreturn NULL;\r\n}\r\nsess->tgt = vha->vha_tgt.qla_tgt;\r\nsess->vha = vha;\r\nsess->s_id = fcport->d_id;\r\nsess->loop_id = fcport->loop_id;\r\nsess->local = local;\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf006,\r\n"Adding sess %p to tgt %p via ->check_initiator_node_acl()\n",\r\nsess, vha->vha_tgt.qla_tgt);\r\nbe_sid[0] = sess->s_id.b.domain;\r\nbe_sid[1] = sess->s_id.b.area;\r\nbe_sid[2] = sess->s_id.b.al_pa;\r\nif (ha->tgt.tgt_ops->check_initiator_node_acl(vha,\r\n&fcport->port_name[0], sess, &be_sid[0], fcport->loop_id) < 0) {\r\nkfree(sess);\r\nreturn NULL;\r\n}\r\nkref_get(&sess->se_sess->sess_kref);\r\nsess->conf_compl_supported = (fcport->flags & FCF_CONF_COMP_SUPPORTED);\r\nBUILD_BUG_ON(sizeof(sess->port_name) != sizeof(fcport->port_name));\r\nmemcpy(sess->port_name, fcport->port_name, sizeof(sess->port_name));\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nlist_add_tail(&sess->sess_list_entry, &vha->vha_tgt.qla_tgt->sess_list);\r\nvha->vha_tgt.qla_tgt->sess_count++;\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf04b,\r\n"qla_target(%d): %ssession for wwn %8phC (loop_id %d, "\r\n"s_id %x:%x:%x, confirmed completion %ssupported) added\n",\r\nvha->vp_idx, local ? "local " : "", fcport->port_name,\r\nfcport->loop_id, sess->s_id.b.domain, sess->s_id.b.area,\r\nsess->s_id.b.al_pa, sess->conf_compl_supported ? "" : "not ");\r\nreturn sess;\r\n}\r\nvoid qlt_fc_port_added(struct scsi_qla_host *vha, fc_port_t *fcport)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\r\nstruct qla_tgt_sess *sess;\r\nunsigned long flags;\r\nif (!vha->hw->tgt.tgt_ops)\r\nreturn;\r\nif (!tgt || (fcport->port_type != FCT_INITIATOR))\r\nreturn;\r\nif (qla_ini_mode_enabled(vha))\r\nreturn;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nif (tgt->tgt_stop) {\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn;\r\n}\r\nsess = qlt_find_sess_by_port_name(tgt, fcport->port_name);\r\nif (!sess) {\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nmutex_lock(&vha->vha_tgt.tgt_mutex);\r\nsess = qlt_create_sess(vha, fcport, false);\r\nmutex_unlock(&vha->vha_tgt.tgt_mutex);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\n} else {\r\nkref_get(&sess->se_sess->sess_kref);\r\nif (sess->deleted) {\r\nqlt_undelete_sess(sess);\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf04c,\r\n"qla_target(%u): %ssession for port %8phC "\r\n"(loop ID %d) reappeared\n", vha->vp_idx,\r\nsess->local ? "local " : "", sess->port_name,\r\nsess->loop_id);\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf007,\r\n"Reappeared sess %p\n", sess);\r\n}\r\nha->tgt.tgt_ops->update_sess(sess, fcport->d_id, fcport->loop_id,\r\n(fcport->flags & FCF_CONF_COMP_SUPPORTED));\r\n}\r\nif (sess && sess->local) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf04d,\r\n"qla_target(%u): local session for "\r\n"port %8phC (loop ID %d) became global\n", vha->vp_idx,\r\nfcport->port_name, sess->loop_id);\r\nsess->local = 0;\r\n}\r\nha->tgt.tgt_ops->put_sess(sess);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nvoid qlt_fc_port_deleted(struct scsi_qla_host *vha, fc_port_t *fcport)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\r\nstruct qla_tgt_sess *sess;\r\nunsigned long flags;\r\nif (!vha->hw->tgt.tgt_ops)\r\nreturn;\r\nif (!tgt || (fcport->port_type != FCT_INITIATOR))\r\nreturn;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nif (tgt->tgt_stop) {\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn;\r\n}\r\nsess = qlt_find_sess_by_port_name(tgt, fcport->port_name);\r\nif (!sess) {\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn;\r\n}\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf008, "qla_tgt_fc_port_deleted %p", sess);\r\nsess->local = 1;\r\nqlt_schedule_sess_for_deletion(sess, false);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nstatic inline int test_tgt_sess_count(struct qla_tgt *tgt)\r\n{\r\nstruct qla_hw_data *ha = tgt->ha;\r\nunsigned long flags;\r\nint res;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nql_dbg(ql_dbg_tgt, tgt->vha, 0xe002,\r\n"tgt %p, empty(sess_list)=%d sess_count=%d\n",\r\ntgt, list_empty(&tgt->sess_list), tgt->sess_count);\r\nres = (tgt->sess_count == 0);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn res;\r\n}\r\nint qlt_stop_phase1(struct qla_tgt *tgt)\r\n{\r\nstruct scsi_qla_host *vha = tgt->vha;\r\nstruct qla_hw_data *ha = tgt->ha;\r\nunsigned long flags;\r\nmutex_lock(&qla_tgt_mutex);\r\nif (!vha->fc_vport) {\r\nstruct Scsi_Host *sh = vha->host;\r\nstruct fc_host_attrs *fc_host = shost_to_fc_host(sh);\r\nbool npiv_vports;\r\nspin_lock_irqsave(sh->host_lock, flags);\r\nnpiv_vports = (fc_host->npiv_vports_inuse);\r\nspin_unlock_irqrestore(sh->host_lock, flags);\r\nif (npiv_vports) {\r\nmutex_unlock(&qla_tgt_mutex);\r\nreturn -EPERM;\r\n}\r\n}\r\nif (tgt->tgt_stop || tgt->tgt_stopped) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf04e,\r\n"Already in tgt->tgt_stop or tgt_stopped state\n");\r\nmutex_unlock(&qla_tgt_mutex);\r\nreturn -EPERM;\r\n}\r\nql_dbg(ql_dbg_tgt, vha, 0xe003, "Stopping target for host %ld(%p)\n",\r\nvha->host_no, vha);\r\nmutex_lock(&vha->vha_tgt.tgt_mutex);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\ntgt->tgt_stop = 1;\r\nqlt_clear_tgt_db(tgt);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nmutex_unlock(&vha->vha_tgt.tgt_mutex);\r\nmutex_unlock(&qla_tgt_mutex);\r\nflush_delayed_work(&tgt->sess_del_work);\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf009,\r\n"Waiting for sess works (tgt %p)", tgt);\r\nspin_lock_irqsave(&tgt->sess_work_lock, flags);\r\nwhile (!list_empty(&tgt->sess_works_list)) {\r\nspin_unlock_irqrestore(&tgt->sess_work_lock, flags);\r\nflush_scheduled_work();\r\nspin_lock_irqsave(&tgt->sess_work_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&tgt->sess_work_lock, flags);\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf00a,\r\n"Waiting for tgt %p: list_empty(sess_list)=%d "\r\n"sess_count=%d\n", tgt, list_empty(&tgt->sess_list),\r\ntgt->sess_count);\r\nwait_event(tgt->waitQ, test_tgt_sess_count(tgt));\r\nif (!ha->flags.host_shutting_down && qla_tgt_mode_enabled(vha))\r\nqlt_disable_vha(vha);\r\nwait_event(tgt->waitQ, test_tgt_sess_count(tgt));\r\nreturn 0;\r\n}\r\nvoid qlt_stop_phase2(struct qla_tgt *tgt)\r\n{\r\nstruct qla_hw_data *ha = tgt->ha;\r\nscsi_qla_host_t *vha = pci_get_drvdata(ha->pdev);\r\nunsigned long flags;\r\nif (tgt->tgt_stopped) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf04f,\r\n"Already in tgt->tgt_stopped state\n");\r\ndump_stack();\r\nreturn;\r\n}\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf00b,\r\n"Waiting for %d IRQ commands to complete (tgt %p)",\r\ntgt->irq_cmd_count, tgt);\r\nmutex_lock(&vha->vha_tgt.tgt_mutex);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nwhile (tgt->irq_cmd_count != 0) {\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nudelay(2);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\n}\r\ntgt->tgt_stop = 0;\r\ntgt->tgt_stopped = 1;\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nmutex_unlock(&vha->vha_tgt.tgt_mutex);\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf00c, "Stop of tgt %p finished",\r\ntgt);\r\n}\r\nstatic void qlt_release(struct qla_tgt *tgt)\r\n{\r\nscsi_qla_host_t *vha = tgt->vha;\r\nif ((vha->vha_tgt.qla_tgt != NULL) && !tgt->tgt_stopped)\r\nqlt_stop_phase2(tgt);\r\nvha->vha_tgt.qla_tgt = NULL;\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf00d,\r\n"Release of tgt %p finished\n", tgt);\r\nkfree(tgt);\r\n}\r\nstatic int qlt_sched_sess_work(struct qla_tgt *tgt, int type,\r\nconst void *param, unsigned int param_size)\r\n{\r\nstruct qla_tgt_sess_work_param *prm;\r\nunsigned long flags;\r\nprm = kzalloc(sizeof(*prm), GFP_ATOMIC);\r\nif (!prm) {\r\nql_dbg(ql_dbg_tgt_mgt, tgt->vha, 0xf050,\r\n"qla_target(%d): Unable to create session "\r\n"work, command will be refused", 0);\r\nreturn -ENOMEM;\r\n}\r\nql_dbg(ql_dbg_tgt_mgt, tgt->vha, 0xf00e,\r\n"Scheduling work (type %d, prm %p)"\r\n" to find session for param %p (size %d, tgt %p)\n",\r\ntype, prm, param, param_size, tgt);\r\nprm->type = type;\r\nmemcpy(&prm->tm_iocb, param, param_size);\r\nspin_lock_irqsave(&tgt->sess_work_lock, flags);\r\nlist_add_tail(&prm->sess_works_list_entry, &tgt->sess_works_list);\r\nspin_unlock_irqrestore(&tgt->sess_work_lock, flags);\r\nschedule_work(&tgt->sess_work);\r\nreturn 0;\r\n}\r\nstatic void qlt_send_notify_ack(struct scsi_qla_host *vha,\r\nstruct imm_ntfy_from_isp *ntfy,\r\nuint32_t add_flags, uint16_t resp_code, int resp_code_valid,\r\nuint16_t srr_flags, uint16_t srr_reject_code, uint8_t srr_explan)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nrequest_t *pkt;\r\nstruct nack_to_isp *nack;\r\nql_dbg(ql_dbg_tgt, vha, 0xe004, "Sending NOTIFY_ACK (ha=%p)\n", ha);\r\nif (qlt_issue_marker(vha, 1) != QLA_SUCCESS)\r\nreturn;\r\npkt = (request_t *)qla2x00_alloc_iocbs(vha, NULL);\r\nif (!pkt) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe049,\r\n"qla_target(%d): %s failed: unable to allocate "\r\n"request packet\n", vha->vp_idx, __func__);\r\nreturn;\r\n}\r\nif (vha->vha_tgt.qla_tgt != NULL)\r\nvha->vha_tgt.qla_tgt->notify_ack_expected++;\r\npkt->entry_type = NOTIFY_ACK_TYPE;\r\npkt->entry_count = 1;\r\nnack = (struct nack_to_isp *)pkt;\r\nnack->ox_id = ntfy->ox_id;\r\nnack->u.isp24.nport_handle = ntfy->u.isp24.nport_handle;\r\nif (le16_to_cpu(ntfy->u.isp24.status) == IMM_NTFY_ELS) {\r\nnack->u.isp24.flags = ntfy->u.isp24.flags &\r\n__constant_cpu_to_le32(NOTIFY24XX_FLAGS_PUREX_IOCB);\r\n}\r\nnack->u.isp24.srr_rx_id = ntfy->u.isp24.srr_rx_id;\r\nnack->u.isp24.status = ntfy->u.isp24.status;\r\nnack->u.isp24.status_subcode = ntfy->u.isp24.status_subcode;\r\nnack->u.isp24.fw_handle = ntfy->u.isp24.fw_handle;\r\nnack->u.isp24.exchange_address = ntfy->u.isp24.exchange_address;\r\nnack->u.isp24.srr_rel_offs = ntfy->u.isp24.srr_rel_offs;\r\nnack->u.isp24.srr_ui = ntfy->u.isp24.srr_ui;\r\nnack->u.isp24.srr_flags = cpu_to_le16(srr_flags);\r\nnack->u.isp24.srr_reject_code = srr_reject_code;\r\nnack->u.isp24.srr_reject_code_expl = srr_explan;\r\nnack->u.isp24.vp_index = ntfy->u.isp24.vp_index;\r\nql_dbg(ql_dbg_tgt, vha, 0xe005,\r\n"qla_target(%d): Sending 24xx Notify Ack %d\n",\r\nvha->vp_idx, nack->u.isp24.status);\r\nwmb();\r\nqla2x00_start_iocbs(vha, vha->req);\r\n}\r\nstatic void qlt_24xx_send_abts_resp(struct scsi_qla_host *vha,\r\nstruct abts_recv_from_24xx *abts, uint32_t status,\r\nbool ids_reversed)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct abts_resp_to_24xx *resp;\r\nuint32_t f_ctl;\r\nuint8_t *p;\r\nql_dbg(ql_dbg_tgt, vha, 0xe006,\r\n"Sending task mgmt ABTS response (ha=%p, atio=%p, status=%x\n",\r\nha, abts, status);\r\nif (qlt_issue_marker(vha, 1) != QLA_SUCCESS)\r\nreturn;\r\nresp = (struct abts_resp_to_24xx *)qla2x00_alloc_iocbs_ready(vha, NULL);\r\nif (!resp) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe04a,\r\n"qla_target(%d): %s failed: unable to allocate "\r\n"request packet", vha->vp_idx, __func__);\r\nreturn;\r\n}\r\nresp->entry_type = ABTS_RESP_24XX;\r\nresp->entry_count = 1;\r\nresp->nport_handle = abts->nport_handle;\r\nresp->vp_index = vha->vp_idx;\r\nresp->sof_type = abts->sof_type;\r\nresp->exchange_address = abts->exchange_address;\r\nresp->fcp_hdr_le = abts->fcp_hdr_le;\r\nf_ctl = __constant_cpu_to_le32(F_CTL_EXCH_CONTEXT_RESP |\r\nF_CTL_LAST_SEQ | F_CTL_END_SEQ |\r\nF_CTL_SEQ_INITIATIVE);\r\np = (uint8_t *)&f_ctl;\r\nresp->fcp_hdr_le.f_ctl[0] = *p++;\r\nresp->fcp_hdr_le.f_ctl[1] = *p++;\r\nresp->fcp_hdr_le.f_ctl[2] = *p;\r\nif (ids_reversed) {\r\nresp->fcp_hdr_le.d_id[0] = abts->fcp_hdr_le.d_id[0];\r\nresp->fcp_hdr_le.d_id[1] = abts->fcp_hdr_le.d_id[1];\r\nresp->fcp_hdr_le.d_id[2] = abts->fcp_hdr_le.d_id[2];\r\nresp->fcp_hdr_le.s_id[0] = abts->fcp_hdr_le.s_id[0];\r\nresp->fcp_hdr_le.s_id[1] = abts->fcp_hdr_le.s_id[1];\r\nresp->fcp_hdr_le.s_id[2] = abts->fcp_hdr_le.s_id[2];\r\n} else {\r\nresp->fcp_hdr_le.d_id[0] = abts->fcp_hdr_le.s_id[0];\r\nresp->fcp_hdr_le.d_id[1] = abts->fcp_hdr_le.s_id[1];\r\nresp->fcp_hdr_le.d_id[2] = abts->fcp_hdr_le.s_id[2];\r\nresp->fcp_hdr_le.s_id[0] = abts->fcp_hdr_le.d_id[0];\r\nresp->fcp_hdr_le.s_id[1] = abts->fcp_hdr_le.d_id[1];\r\nresp->fcp_hdr_le.s_id[2] = abts->fcp_hdr_le.d_id[2];\r\n}\r\nresp->exchange_addr_to_abort = abts->exchange_addr_to_abort;\r\nif (status == FCP_TMF_CMPL) {\r\nresp->fcp_hdr_le.r_ctl = R_CTL_BASIC_LINK_SERV | R_CTL_B_ACC;\r\nresp->payload.ba_acct.seq_id_valid = SEQ_ID_INVALID;\r\nresp->payload.ba_acct.low_seq_cnt = 0x0000;\r\nresp->payload.ba_acct.high_seq_cnt = 0xFFFF;\r\nresp->payload.ba_acct.ox_id = abts->fcp_hdr_le.ox_id;\r\nresp->payload.ba_acct.rx_id = abts->fcp_hdr_le.rx_id;\r\n} else {\r\nresp->fcp_hdr_le.r_ctl = R_CTL_BASIC_LINK_SERV | R_CTL_B_RJT;\r\nresp->payload.ba_rjt.reason_code =\r\nBA_RJT_REASON_CODE_UNABLE_TO_PERFORM;\r\n}\r\nvha->vha_tgt.qla_tgt->abts_resp_expected++;\r\nwmb();\r\nqla2x00_start_iocbs(vha, vha->req);\r\n}\r\nstatic void qlt_24xx_retry_term_exchange(struct scsi_qla_host *vha,\r\nstruct abts_resp_from_24xx_fw *entry)\r\n{\r\nstruct ctio7_to_24xx *ctio;\r\nql_dbg(ql_dbg_tgt, vha, 0xe007,\r\n"Sending retry TERM EXCH CTIO7 (ha=%p)\n", vha->hw);\r\nif (qlt_issue_marker(vha, 1) != QLA_SUCCESS)\r\nreturn;\r\nctio = (struct ctio7_to_24xx *)qla2x00_alloc_iocbs_ready(vha, NULL);\r\nif (ctio == NULL) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe04b,\r\n"qla_target(%d): %s failed: unable to allocate "\r\n"request packet\n", vha->vp_idx, __func__);\r\nreturn;\r\n}\r\nctio->entry_type = CTIO_TYPE7;\r\nctio->entry_count = 1;\r\nctio->nport_handle = entry->nport_handle;\r\nctio->handle = QLA_TGT_SKIP_HANDLE | CTIO_COMPLETION_HANDLE_MARK;\r\nctio->timeout = __constant_cpu_to_le16(QLA_TGT_TIMEOUT);\r\nctio->vp_index = vha->vp_idx;\r\nctio->initiator_id[0] = entry->fcp_hdr_le.d_id[0];\r\nctio->initiator_id[1] = entry->fcp_hdr_le.d_id[1];\r\nctio->initiator_id[2] = entry->fcp_hdr_le.d_id[2];\r\nctio->exchange_addr = entry->exchange_addr_to_abort;\r\nctio->u.status1.flags =\r\n__constant_cpu_to_le16(CTIO7_FLAGS_STATUS_MODE_1 |\r\nCTIO7_FLAGS_TERMINATE);\r\nctio->u.status1.ox_id = cpu_to_le16(entry->fcp_hdr_le.ox_id);\r\nwmb();\r\nqla2x00_start_iocbs(vha, vha->req);\r\nqlt_24xx_send_abts_resp(vha, (struct abts_recv_from_24xx *)entry,\r\nFCP_TMF_CMPL, true);\r\n}\r\nstatic int __qlt_24xx_handle_abts(struct scsi_qla_host *vha,\r\nstruct abts_recv_from_24xx *abts, struct qla_tgt_sess *sess)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct se_session *se_sess = sess->se_sess;\r\nstruct qla_tgt_mgmt_cmd *mcmd;\r\nstruct se_cmd *se_cmd;\r\nu32 lun = 0;\r\nint rc;\r\nbool found_lun = false;\r\nspin_lock(&se_sess->sess_cmd_lock);\r\nlist_for_each_entry(se_cmd, &se_sess->sess_cmd_list, se_cmd_list) {\r\nstruct qla_tgt_cmd *cmd =\r\ncontainer_of(se_cmd, struct qla_tgt_cmd, se_cmd);\r\nif (cmd->tag == abts->exchange_addr_to_abort) {\r\nlun = cmd->unpacked_lun;\r\nfound_lun = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&se_sess->sess_cmd_lock);\r\nif (!found_lun)\r\nreturn -ENOENT;\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf00f,\r\n"qla_target(%d): task abort (tag=%d)\n",\r\nvha->vp_idx, abts->exchange_addr_to_abort);\r\nmcmd = mempool_alloc(qla_tgt_mgmt_cmd_mempool, GFP_ATOMIC);\r\nif (mcmd == NULL) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf051,\r\n"qla_target(%d): %s: Allocation of ABORT cmd failed",\r\nvha->vp_idx, __func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset(mcmd, 0, sizeof(*mcmd));\r\nmcmd->sess = sess;\r\nmemcpy(&mcmd->orig_iocb.abts, abts, sizeof(mcmd->orig_iocb.abts));\r\nmcmd->reset_count = vha->hw->chip_reset;\r\nrc = ha->tgt.tgt_ops->handle_tmr(mcmd, lun, TMR_ABORT_TASK,\r\nabts->exchange_addr_to_abort);\r\nif (rc != 0) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf052,\r\n"qla_target(%d): tgt_ops->handle_tmr()"\r\n" failed: %d", vha->vp_idx, rc);\r\nmempool_free(mcmd, qla_tgt_mgmt_cmd_mempool);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void qlt_24xx_handle_abts(struct scsi_qla_host *vha,\r\nstruct abts_recv_from_24xx *abts)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt_sess *sess;\r\nuint32_t tag = abts->exchange_addr_to_abort;\r\nuint8_t s_id[3];\r\nint rc;\r\nif (le32_to_cpu(abts->fcp_hdr_le.parameter) & ABTS_PARAM_ABORT_SEQ) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf053,\r\n"qla_target(%d): ABTS: Abort Sequence not "\r\n"supported\n", vha->vp_idx);\r\nqlt_24xx_send_abts_resp(vha, abts, FCP_TMF_REJECTED, false);\r\nreturn;\r\n}\r\nif (tag == ATIO_EXCHANGE_ADDRESS_UNKNOWN) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf010,\r\n"qla_target(%d): ABTS: Unknown Exchange "\r\n"Address received\n", vha->vp_idx);\r\nqlt_24xx_send_abts_resp(vha, abts, FCP_TMF_REJECTED, false);\r\nreturn;\r\n}\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf011,\r\n"qla_target(%d): task abort (s_id=%x:%x:%x, "\r\n"tag=%d, param=%x)\n", vha->vp_idx, abts->fcp_hdr_le.s_id[2],\r\nabts->fcp_hdr_le.s_id[1], abts->fcp_hdr_le.s_id[0], tag,\r\nle32_to_cpu(abts->fcp_hdr_le.parameter));\r\ns_id[0] = abts->fcp_hdr_le.s_id[2];\r\ns_id[1] = abts->fcp_hdr_le.s_id[1];\r\ns_id[2] = abts->fcp_hdr_le.s_id[0];\r\nsess = ha->tgt.tgt_ops->find_sess_by_s_id(vha, s_id);\r\nif (!sess) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf012,\r\n"qla_target(%d): task abort for non-existant session\n",\r\nvha->vp_idx);\r\nrc = qlt_sched_sess_work(vha->vha_tgt.qla_tgt,\r\nQLA_TGT_SESS_WORK_ABORT, abts, sizeof(*abts));\r\nif (rc != 0) {\r\nqlt_24xx_send_abts_resp(vha, abts, FCP_TMF_REJECTED,\r\nfalse);\r\n}\r\nreturn;\r\n}\r\nrc = __qlt_24xx_handle_abts(vha, abts, sess);\r\nif (rc != 0) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf054,\r\n"qla_target(%d): __qlt_24xx_handle_abts() failed: %d\n",\r\nvha->vp_idx, rc);\r\nqlt_24xx_send_abts_resp(vha, abts, FCP_TMF_REJECTED, false);\r\nreturn;\r\n}\r\n}\r\nstatic void qlt_24xx_send_task_mgmt_ctio(struct scsi_qla_host *ha,\r\nstruct qla_tgt_mgmt_cmd *mcmd, uint32_t resp_code)\r\n{\r\nstruct atio_from_isp *atio = &mcmd->orig_iocb.atio;\r\nstruct ctio7_to_24xx *ctio;\r\nuint16_t temp;\r\nql_dbg(ql_dbg_tgt, ha, 0xe008,\r\n"Sending task mgmt CTIO7 (ha=%p, atio=%p, resp_code=%x\n",\r\nha, atio, resp_code);\r\nif (qlt_issue_marker(ha, 1) != QLA_SUCCESS)\r\nreturn;\r\nctio = (struct ctio7_to_24xx *)qla2x00_alloc_iocbs(ha, NULL);\r\nif (ctio == NULL) {\r\nql_dbg(ql_dbg_tgt, ha, 0xe04c,\r\n"qla_target(%d): %s failed: unable to allocate "\r\n"request packet\n", ha->vp_idx, __func__);\r\nreturn;\r\n}\r\nctio->entry_type = CTIO_TYPE7;\r\nctio->entry_count = 1;\r\nctio->handle = QLA_TGT_SKIP_HANDLE | CTIO_COMPLETION_HANDLE_MARK;\r\nctio->nport_handle = mcmd->sess->loop_id;\r\nctio->timeout = __constant_cpu_to_le16(QLA_TGT_TIMEOUT);\r\nctio->vp_index = ha->vp_idx;\r\nctio->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];\r\nctio->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];\r\nctio->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];\r\nctio->exchange_addr = atio->u.isp24.exchange_addr;\r\nctio->u.status1.flags = (atio->u.isp24.attr << 9) |\r\n__constant_cpu_to_le16(CTIO7_FLAGS_STATUS_MODE_1 |\r\nCTIO7_FLAGS_SEND_STATUS);\r\ntemp = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);\r\nctio->u.status1.ox_id = cpu_to_le16(temp);\r\nctio->u.status1.scsi_status =\r\n__constant_cpu_to_le16(SS_RESPONSE_INFO_LEN_VALID);\r\nctio->u.status1.response_len = __constant_cpu_to_le16(8);\r\nctio->u.status1.sense_data[0] = resp_code;\r\nwmb();\r\nqla2x00_start_iocbs(ha, ha->req);\r\n}\r\nvoid qlt_free_mcmd(struct qla_tgt_mgmt_cmd *mcmd)\r\n{\r\nmempool_free(mcmd, qla_tgt_mgmt_cmd_mempool);\r\n}\r\nvoid qlt_xmit_tm_rsp(struct qla_tgt_mgmt_cmd *mcmd)\r\n{\r\nstruct scsi_qla_host *vha = mcmd->sess->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nunsigned long flags;\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf013,\r\n"TM response mcmd (%p) status %#x state %#x",\r\nmcmd, mcmd->fc_tm_rsp, mcmd->flags);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nif (qla2x00_reset_active(vha) || mcmd->reset_count != ha->chip_reset) {\r\nql_dbg(ql_dbg_async, vha, 0xe100,\r\n"RESET-TMR active/old-count/new-count = %d/%d/%d.\n",\r\nqla2x00_reset_active(vha), mcmd->reset_count,\r\nha->chip_reset);\r\nha->tgt.tgt_ops->free_mcmd(mcmd);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn;\r\n}\r\nif (mcmd->flags == QLA24XX_MGMT_SEND_NACK)\r\nqlt_send_notify_ack(vha, &mcmd->orig_iocb.imm_ntfy,\r\n0, 0, 0, 0, 0, 0);\r\nelse {\r\nif (mcmd->se_cmd.se_tmr_req->function == TMR_ABORT_TASK)\r\nqlt_24xx_send_abts_resp(vha, &mcmd->orig_iocb.abts,\r\nmcmd->fc_tm_rsp, false);\r\nelse\r\nqlt_24xx_send_task_mgmt_ctio(vha, mcmd,\r\nmcmd->fc_tm_rsp);\r\n}\r\nha->tgt.tgt_ops->free_mcmd(mcmd);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nstatic int qlt_pci_map_calc_cnt(struct qla_tgt_prm *prm)\r\n{\r\nstruct qla_tgt_cmd *cmd = prm->cmd;\r\nBUG_ON(cmd->sg_cnt == 0);\r\nprm->sg = (struct scatterlist *)cmd->sg;\r\nprm->seg_cnt = pci_map_sg(prm->tgt->ha->pdev, cmd->sg,\r\ncmd->sg_cnt, cmd->dma_data_direction);\r\nif (unlikely(prm->seg_cnt == 0))\r\ngoto out_err;\r\nprm->cmd->sg_mapped = 1;\r\nif (cmd->se_cmd.prot_op == TARGET_PROT_NORMAL) {\r\nif (prm->seg_cnt > prm->tgt->datasegs_per_cmd)\r\nprm->req_cnt += DIV_ROUND_UP(prm->seg_cnt -\r\nprm->tgt->datasegs_per_cmd,\r\nprm->tgt->datasegs_per_cont);\r\n} else {\r\nif ((cmd->se_cmd.prot_op == TARGET_PROT_DIN_INSERT) ||\r\n(cmd->se_cmd.prot_op == TARGET_PROT_DOUT_STRIP)) {\r\nprm->seg_cnt = DIV_ROUND_UP(cmd->bufflen, cmd->blk_sz);\r\nprm->tot_dsds = prm->seg_cnt;\r\n} else\r\nprm->tot_dsds = prm->seg_cnt;\r\nif (cmd->prot_sg_cnt) {\r\nprm->prot_sg = cmd->prot_sg;\r\nprm->prot_seg_cnt = pci_map_sg(prm->tgt->ha->pdev,\r\ncmd->prot_sg, cmd->prot_sg_cnt,\r\ncmd->dma_data_direction);\r\nif (unlikely(prm->prot_seg_cnt == 0))\r\ngoto out_err;\r\nif ((cmd->se_cmd.prot_op == TARGET_PROT_DIN_INSERT) ||\r\n(cmd->se_cmd.prot_op == TARGET_PROT_DOUT_STRIP)) {\r\nprm->prot_seg_cnt = DIV_ROUND_UP(cmd->bufflen,\r\ncmd->blk_sz);\r\nprm->tot_dsds += prm->prot_seg_cnt;\r\n} else\r\nprm->tot_dsds += prm->prot_seg_cnt;\r\n}\r\n}\r\nreturn 0;\r\nout_err:\r\nql_dbg(ql_dbg_tgt, prm->cmd->vha, 0xe04d,\r\n"qla_target(%d): PCI mapping failed: sg_cnt=%d",\r\n0, prm->cmd->sg_cnt);\r\nreturn -1;\r\n}\r\nstatic void qlt_unmap_sg(struct scsi_qla_host *vha, struct qla_tgt_cmd *cmd)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!cmd->sg_mapped)\r\nreturn;\r\npci_unmap_sg(ha->pdev, cmd->sg, cmd->sg_cnt, cmd->dma_data_direction);\r\ncmd->sg_mapped = 0;\r\nif (cmd->prot_sg_cnt)\r\npci_unmap_sg(ha->pdev, cmd->prot_sg, cmd->prot_sg_cnt,\r\ncmd->dma_data_direction);\r\nif (cmd->ctx_dsd_alloced)\r\nqla2x00_clean_dsd_pool(ha, NULL, cmd);\r\nif (cmd->ctx)\r\ndma_pool_free(ha->dl_dma_pool, cmd->ctx, cmd->ctx->crc_ctx_dma);\r\n}\r\nstatic int qlt_check_reserve_free_req(struct scsi_qla_host *vha,\r\nuint32_t req_cnt)\r\n{\r\nuint32_t cnt, cnt_in;\r\nif (vha->req->cnt < (req_cnt + 2)) {\r\ncnt = (uint16_t)RD_REG_DWORD(vha->req->req_q_out);\r\ncnt_in = (uint16_t)RD_REG_DWORD(vha->req->req_q_in);\r\nif (vha->req->ring_index < cnt)\r\nvha->req->cnt = cnt - vha->req->ring_index;\r\nelse\r\nvha->req->cnt = vha->req->length -\r\n(vha->req->ring_index - cnt);\r\n}\r\nif (unlikely(vha->req->cnt < (req_cnt + 2))) {\r\nql_dbg(ql_dbg_io, vha, 0x305a,\r\n"qla_target(%d): There is no room in the request ring: vha->req->ring_index=%d, vha->req->cnt=%d, req_cnt=%d Req-out=%d Req-in=%d Req-Length=%d\n",\r\nvha->vp_idx, vha->req->ring_index,\r\nvha->req->cnt, req_cnt, cnt, cnt_in, vha->req->length);\r\nreturn -EAGAIN;\r\n}\r\nvha->req->cnt -= req_cnt;\r\nreturn 0;\r\n}\r\nstatic inline void *qlt_get_req_pkt(struct scsi_qla_host *vha)\r\n{\r\nvha->req->ring_index++;\r\nif (vha->req->ring_index == vha->req->length) {\r\nvha->req->ring_index = 0;\r\nvha->req->ring_ptr = vha->req->ring;\r\n} else {\r\nvha->req->ring_ptr++;\r\n}\r\nreturn (cont_entry_t *)vha->req->ring_ptr;\r\n}\r\nstatic inline uint32_t qlt_make_handle(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t h;\r\nh = ha->tgt.current_handle;\r\ndo {\r\n++h;\r\nif (h > DEFAULT_OUTSTANDING_COMMANDS)\r\nh = 1;\r\nif (h == ha->tgt.current_handle) {\r\nql_dbg(ql_dbg_io, vha, 0x305b,\r\n"qla_target(%d): Ran out of "\r\n"empty cmd slots in ha %p\n", vha->vp_idx, ha);\r\nh = QLA_TGT_NULL_HANDLE;\r\nbreak;\r\n}\r\n} while ((h == QLA_TGT_NULL_HANDLE) ||\r\n(h == QLA_TGT_SKIP_HANDLE) ||\r\n(ha->tgt.cmds[h-1] != NULL));\r\nif (h != QLA_TGT_NULL_HANDLE)\r\nha->tgt.current_handle = h;\r\nreturn h;\r\n}\r\nstatic int qlt_24xx_build_ctio_pkt(struct qla_tgt_prm *prm,\r\nstruct scsi_qla_host *vha)\r\n{\r\nuint32_t h;\r\nstruct ctio7_to_24xx *pkt;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct atio_from_isp *atio = &prm->cmd->atio;\r\nuint16_t temp;\r\npkt = (struct ctio7_to_24xx *)vha->req->ring_ptr;\r\nprm->pkt = pkt;\r\nmemset(pkt, 0, sizeof(*pkt));\r\npkt->entry_type = CTIO_TYPE7;\r\npkt->entry_count = (uint8_t)prm->req_cnt;\r\npkt->vp_index = vha->vp_idx;\r\nh = qlt_make_handle(vha);\r\nif (unlikely(h == QLA_TGT_NULL_HANDLE)) {\r\nreturn -EAGAIN;\r\n} else\r\nha->tgt.cmds[h-1] = prm->cmd;\r\npkt->handle = h | CTIO_COMPLETION_HANDLE_MARK;\r\npkt->nport_handle = prm->cmd->loop_id;\r\npkt->timeout = __constant_cpu_to_le16(QLA_TGT_TIMEOUT);\r\npkt->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];\r\npkt->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];\r\npkt->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];\r\npkt->exchange_addr = atio->u.isp24.exchange_addr;\r\npkt->u.status0.flags |= (atio->u.isp24.attr << 9);\r\ntemp = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);\r\npkt->u.status0.ox_id = cpu_to_le16(temp);\r\npkt->u.status0.relative_offset = cpu_to_le32(prm->cmd->offset);\r\nreturn 0;\r\n}\r\nstatic void qlt_load_cont_data_segments(struct qla_tgt_prm *prm,\r\nstruct scsi_qla_host *vha)\r\n{\r\nint cnt;\r\nuint32_t *dword_ptr;\r\nint enable_64bit_addressing = prm->tgt->tgt_enable_64bit_addr;\r\nwhile (prm->seg_cnt > 0) {\r\ncont_a64_entry_t *cont_pkt64 =\r\n(cont_a64_entry_t *)qlt_get_req_pkt(vha);\r\nmemset(cont_pkt64, 0, sizeof(*cont_pkt64));\r\ncont_pkt64->entry_count = 1;\r\ncont_pkt64->sys_define = 0;\r\nif (enable_64bit_addressing) {\r\ncont_pkt64->entry_type = CONTINUE_A64_TYPE;\r\ndword_ptr =\r\n(uint32_t *)&cont_pkt64->dseg_0_address;\r\n} else {\r\ncont_pkt64->entry_type = CONTINUE_TYPE;\r\ndword_ptr =\r\n(uint32_t *)&((cont_entry_t *)\r\ncont_pkt64)->dseg_0_address;\r\n}\r\nfor (cnt = 0;\r\ncnt < prm->tgt->datasegs_per_cont && prm->seg_cnt;\r\ncnt++, prm->seg_cnt--) {\r\n*dword_ptr++ =\r\ncpu_to_le32(pci_dma_lo32\r\n(sg_dma_address(prm->sg)));\r\nif (enable_64bit_addressing) {\r\n*dword_ptr++ =\r\ncpu_to_le32(pci_dma_hi32\r\n(sg_dma_address\r\n(prm->sg)));\r\n}\r\n*dword_ptr++ = cpu_to_le32(sg_dma_len(prm->sg));\r\nprm->sg = sg_next(prm->sg);\r\n}\r\n}\r\n}\r\nstatic void qlt_load_data_segments(struct qla_tgt_prm *prm,\r\nstruct scsi_qla_host *vha)\r\n{\r\nint cnt;\r\nuint32_t *dword_ptr;\r\nint enable_64bit_addressing = prm->tgt->tgt_enable_64bit_addr;\r\nstruct ctio7_to_24xx *pkt24 = (struct ctio7_to_24xx *)prm->pkt;\r\npkt24->u.status0.transfer_length = cpu_to_le32(prm->cmd->bufflen);\r\ndword_ptr = pkt24->u.status0.dseg_0_address;\r\nif (prm->seg_cnt)\r\npkt24->dseg_count = cpu_to_le16(prm->seg_cnt);\r\nif (prm->seg_cnt == 0) {\r\n*dword_ptr++ = 0;\r\n*dword_ptr = 0;\r\nreturn;\r\n}\r\nfor (cnt = 0;\r\n(cnt < prm->tgt->datasegs_per_cmd) && prm->seg_cnt;\r\ncnt++, prm->seg_cnt--) {\r\n*dword_ptr++ =\r\ncpu_to_le32(pci_dma_lo32(sg_dma_address(prm->sg)));\r\nif (enable_64bit_addressing) {\r\n*dword_ptr++ =\r\ncpu_to_le32(pci_dma_hi32(\r\nsg_dma_address(prm->sg)));\r\n}\r\n*dword_ptr++ = cpu_to_le32(sg_dma_len(prm->sg));\r\nprm->sg = sg_next(prm->sg);\r\n}\r\nqlt_load_cont_data_segments(prm, vha);\r\n}\r\nstatic inline int qlt_has_data(struct qla_tgt_cmd *cmd)\r\n{\r\nreturn cmd->bufflen > 0;\r\n}\r\nstatic int qlt_pre_xmit_response(struct qla_tgt_cmd *cmd,\r\nstruct qla_tgt_prm *prm, int xmit_type, uint8_t scsi_status,\r\nuint32_t *full_req_cnt)\r\n{\r\nstruct qla_tgt *tgt = cmd->tgt;\r\nstruct scsi_qla_host *vha = tgt->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nif (unlikely(cmd->aborted)) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf014,\r\n"qla_target(%d): terminating exchange "\r\n"for aborted cmd=%p (se_cmd=%p, tag=%d)", vha->vp_idx, cmd,\r\nse_cmd, cmd->tag);\r\ncmd->state = QLA_TGT_STATE_ABORTED;\r\ncmd->cmd_flags |= BIT_6;\r\nqlt_send_term_exchange(vha, cmd, &cmd->atio, 0);\r\nreturn QLA_TGT_PRE_XMIT_RESP_CMD_ABORTED;\r\n}\r\nprm->cmd = cmd;\r\nprm->tgt = tgt;\r\nprm->rq_result = scsi_status;\r\nprm->sense_buffer = &cmd->sense_buffer[0];\r\nprm->sense_buffer_len = TRANSPORT_SENSE_BUFFER;\r\nprm->sg = NULL;\r\nprm->seg_cnt = -1;\r\nprm->req_cnt = 1;\r\nprm->add_status_pkt = 0;\r\nif (qlt_issue_marker(vha, 0) != QLA_SUCCESS)\r\nreturn -EFAULT;\r\nif ((xmit_type & QLA_TGT_XMIT_DATA) && qlt_has_data(cmd)) {\r\nif (qlt_pci_map_calc_cnt(prm) != 0)\r\nreturn -EAGAIN;\r\n}\r\n*full_req_cnt = prm->req_cnt;\r\nif (se_cmd->se_cmd_flags & SCF_UNDERFLOW_BIT) {\r\nprm->residual = se_cmd->residual_count;\r\nql_dbg(ql_dbg_io + ql_dbg_verbose, vha, 0x305c,\r\n"Residual underflow: %d (tag %d, "\r\n"op %x, bufflen %d, rq_result %x)\n", prm->residual,\r\ncmd->tag, se_cmd->t_task_cdb ? se_cmd->t_task_cdb[0] : 0,\r\ncmd->bufflen, prm->rq_result);\r\nprm->rq_result |= SS_RESIDUAL_UNDER;\r\n} else if (se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {\r\nprm->residual = se_cmd->residual_count;\r\nql_dbg(ql_dbg_io, vha, 0x305d,\r\n"Residual overflow: %d (tag %d, "\r\n"op %x, bufflen %d, rq_result %x)\n", prm->residual,\r\ncmd->tag, se_cmd->t_task_cdb ? se_cmd->t_task_cdb[0] : 0,\r\ncmd->bufflen, prm->rq_result);\r\nprm->rq_result |= SS_RESIDUAL_OVER;\r\n}\r\nif (xmit_type & QLA_TGT_XMIT_STATUS) {\r\nif (qlt_has_data(cmd)) {\r\nif (QLA_TGT_SENSE_VALID(prm->sense_buffer) ||\r\n(IS_FWI2_CAPABLE(ha) &&\r\n(prm->rq_result != 0))) {\r\nprm->add_status_pkt = 1;\r\n(*full_req_cnt)++;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int qlt_need_explicit_conf(struct qla_hw_data *ha,\r\nstruct qla_tgt_cmd *cmd, int sending_sense)\r\n{\r\nif (ha->tgt.enable_class_2)\r\nreturn 0;\r\nif (sending_sense)\r\nreturn cmd->conf_compl_supported;\r\nelse\r\nreturn ha->tgt.enable_explicit_conf &&\r\ncmd->conf_compl_supported;\r\n}\r\nstatic unsigned long qlt_srr_random(void)\r\n{\r\nstatic int Inited;\r\nstatic unsigned long RandomValue;\r\nstatic DEFINE_SPINLOCK(lock);\r\nregister long rv;\r\nregister long lo;\r\nregister long hi;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lock, flags);\r\nif (!Inited) {\r\nRandomValue = jiffies;\r\nInited = 1;\r\n}\r\nrv = RandomValue;\r\nhi = rv / 127773;\r\nlo = rv % 127773;\r\nrv = 16807 * lo - 2836 * hi;\r\nif (rv <= 0)\r\nrv += 2147483647;\r\nRandomValue = rv;\r\nspin_unlock_irqrestore(&lock, flags);\r\nreturn rv;\r\n}\r\nstatic void qlt_check_srr_debug(struct qla_tgt_cmd *cmd, int *xmit_type)\r\n{\r\n#if 0\r\nif ((*xmit_type & QLA_TGT_XMIT_STATUS) && (qlt_srr_random() % 200)\r\n== 50) {\r\n*xmit_type &= ~QLA_TGT_XMIT_STATUS;\r\nql_dbg(ql_dbg_tgt_mgt, cmd->vha, 0xf015,\r\n"Dropping cmd %p (tag %d) status", cmd, cmd->tag);\r\n}\r\n#endif\r\nif (cmd->dma_data_direction != DMA_FROM_DEVICE)\r\nreturn;\r\nif (qlt_has_data(cmd) && (cmd->sg_cnt > 1) &&\r\n((qlt_srr_random() % 100) == 20)) {\r\nint i, leave = 0;\r\nunsigned int tot_len = 0;\r\nwhile (leave == 0)\r\nleave = qlt_srr_random() % cmd->sg_cnt;\r\nfor (i = 0; i < leave; i++)\r\ntot_len += cmd->sg[i].length;\r\nql_dbg(ql_dbg_tgt_mgt, cmd->vha, 0xf016,\r\n"Cutting cmd %p (tag %d) buffer"\r\n" tail to len %d, sg_cnt %d (cmd->bufflen %d,"\r\n" cmd->sg_cnt %d)", cmd, cmd->tag, tot_len, leave,\r\ncmd->bufflen, cmd->sg_cnt);\r\ncmd->bufflen = tot_len;\r\ncmd->sg_cnt = leave;\r\n}\r\nif (qlt_has_data(cmd) && ((qlt_srr_random() % 100) == 70)) {\r\nunsigned int offset = qlt_srr_random() % cmd->bufflen;\r\nql_dbg(ql_dbg_tgt_mgt, cmd->vha, 0xf017,\r\n"Cutting cmd %p (tag %d) buffer head "\r\n"to offset %d (cmd->bufflen %d)", cmd, cmd->tag, offset,\r\ncmd->bufflen);\r\nif (offset == 0)\r\n*xmit_type &= ~QLA_TGT_XMIT_DATA;\r\nelse if (qlt_set_data_offset(cmd, offset)) {\r\nql_dbg(ql_dbg_tgt_mgt, cmd->vha, 0xf018,\r\n"qlt_set_data_offset() failed (tag %d)", cmd->tag);\r\n}\r\n}\r\n}\r\nstatic inline void qlt_check_srr_debug(struct qla_tgt_cmd *cmd, int *xmit_type)\r\n{}\r\nstatic void qlt_24xx_init_ctio_to_isp(struct ctio7_to_24xx *ctio,\r\nstruct qla_tgt_prm *prm)\r\n{\r\nprm->sense_buffer_len = min_t(uint32_t, prm->sense_buffer_len,\r\n(uint32_t)sizeof(ctio->u.status1.sense_data));\r\nctio->u.status0.flags |=\r\n__constant_cpu_to_le16(CTIO7_FLAGS_SEND_STATUS);\r\nif (qlt_need_explicit_conf(prm->tgt->ha, prm->cmd, 0)) {\r\nctio->u.status0.flags |= __constant_cpu_to_le16(\r\nCTIO7_FLAGS_EXPLICIT_CONFORM |\r\nCTIO7_FLAGS_CONFORM_REQ);\r\n}\r\nctio->u.status0.residual = cpu_to_le32(prm->residual);\r\nctio->u.status0.scsi_status = cpu_to_le16(prm->rq_result);\r\nif (QLA_TGT_SENSE_VALID(prm->sense_buffer)) {\r\nint i;\r\nif (qlt_need_explicit_conf(prm->tgt->ha, prm->cmd, 1)) {\r\nif (prm->cmd->se_cmd.scsi_status != 0) {\r\nql_dbg(ql_dbg_tgt, prm->cmd->vha, 0xe017,\r\n"Skipping EXPLICIT_CONFORM and "\r\n"CTIO7_FLAGS_CONFORM_REQ for FCP READ w/ "\r\n"non GOOD status\n");\r\ngoto skip_explict_conf;\r\n}\r\nctio->u.status1.flags |= __constant_cpu_to_le16(\r\nCTIO7_FLAGS_EXPLICIT_CONFORM |\r\nCTIO7_FLAGS_CONFORM_REQ);\r\n}\r\nskip_explict_conf:\r\nctio->u.status1.flags &=\r\n~__constant_cpu_to_le16(CTIO7_FLAGS_STATUS_MODE_0);\r\nctio->u.status1.flags |=\r\n__constant_cpu_to_le16(CTIO7_FLAGS_STATUS_MODE_1);\r\nctio->u.status1.scsi_status |=\r\n__constant_cpu_to_le16(SS_SENSE_LEN_VALID);\r\nctio->u.status1.sense_length =\r\ncpu_to_le16(prm->sense_buffer_len);\r\nfor (i = 0; i < prm->sense_buffer_len/4; i++)\r\n((uint32_t *)ctio->u.status1.sense_data)[i] =\r\ncpu_to_be32(((uint32_t *)prm->sense_buffer)[i]);\r\n#if 0\r\nif (unlikely((prm->sense_buffer_len % 4) != 0)) {\r\nstatic int q;\r\nif (q < 10) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe04f,\r\n"qla_target(%d): %d bytes of sense "\r\n"lost", prm->tgt->ha->vp_idx,\r\nprm->sense_buffer_len % 4);\r\nq++;\r\n}\r\n}\r\n#endif\r\n} else {\r\nctio->u.status1.flags &=\r\n~__constant_cpu_to_le16(CTIO7_FLAGS_STATUS_MODE_0);\r\nctio->u.status1.flags |=\r\n__constant_cpu_to_le16(CTIO7_FLAGS_STATUS_MODE_1);\r\nctio->u.status1.sense_length = 0;\r\nmemset(ctio->u.status1.sense_data, 0,\r\nsizeof(ctio->u.status1.sense_data));\r\n}\r\n}\r\nstatic inline int\r\nqlt_hba_err_chk_enabled(struct se_cmd *se_cmd)\r\n{\r\nswitch (se_cmd->prot_op) {\r\ncase TARGET_PROT_DOUT_INSERT:\r\ncase TARGET_PROT_DIN_STRIP:\r\nif (ql2xenablehba_err_chk >= 1)\r\nreturn 1;\r\nbreak;\r\ncase TARGET_PROT_DOUT_PASS:\r\ncase TARGET_PROT_DIN_PASS:\r\nif (ql2xenablehba_err_chk >= 2)\r\nreturn 1;\r\nbreak;\r\ncase TARGET_PROT_DIN_INSERT:\r\ncase TARGET_PROT_DOUT_STRIP:\r\nreturn 1;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void\r\nqlt_set_t10dif_tags(struct se_cmd *se_cmd, struct crc_context *ctx)\r\n{\r\nuint32_t lba = 0xffffffff & se_cmd->t_task_lba;\r\nctx->app_tag = 0;\r\nctx->app_tag_mask[0] = 0x0;\r\nctx->app_tag_mask[1] = 0x0;\r\nswitch (se_cmd->prot_type) {\r\ncase TARGET_DIF_TYPE0_PROT:\r\nctx->ref_tag = cpu_to_le32(lba);\r\nif (!qlt_hba_err_chk_enabled(se_cmd))\r\nbreak;\r\nctx->ref_tag_mask[0] = 0xff;\r\nctx->ref_tag_mask[1] = 0xff;\r\nctx->ref_tag_mask[2] = 0xff;\r\nctx->ref_tag_mask[3] = 0xff;\r\nbreak;\r\ncase TARGET_DIF_TYPE1_PROT:\r\nctx->ref_tag = cpu_to_le32(lba);\r\nif (!qlt_hba_err_chk_enabled(se_cmd))\r\nbreak;\r\nctx->ref_tag_mask[0] = 0xff;\r\nctx->ref_tag_mask[1] = 0xff;\r\nctx->ref_tag_mask[2] = 0xff;\r\nctx->ref_tag_mask[3] = 0xff;\r\nbreak;\r\ncase TARGET_DIF_TYPE2_PROT:\r\nctx->ref_tag = cpu_to_le32(lba);\r\nif (!qlt_hba_err_chk_enabled(se_cmd))\r\nbreak;\r\nctx->ref_tag_mask[0] = 0xff;\r\nctx->ref_tag_mask[1] = 0xff;\r\nctx->ref_tag_mask[2] = 0xff;\r\nctx->ref_tag_mask[3] = 0xff;\r\nbreak;\r\ncase TARGET_DIF_TYPE3_PROT:\r\nctx->ref_tag_mask[0] = ctx->ref_tag_mask[1] =\r\nctx->ref_tag_mask[2] = ctx->ref_tag_mask[3] = 0x00;\r\nbreak;\r\n}\r\n}\r\nstatic inline int\r\nqlt_build_ctio_crc2_pkt(struct qla_tgt_prm *prm, scsi_qla_host_t *vha)\r\n{\r\nuint32_t *cur_dsd;\r\nint sgc;\r\nuint32_t transfer_length = 0;\r\nuint32_t data_bytes;\r\nuint32_t dif_bytes;\r\nuint8_t bundling = 1;\r\nuint8_t *clr_ptr;\r\nstruct crc_context *crc_ctx_pkt = NULL;\r\nstruct qla_hw_data *ha;\r\nstruct ctio_crc2_to_fw *pkt;\r\ndma_addr_t crc_ctx_dma;\r\nuint16_t fw_prot_opts = 0;\r\nstruct qla_tgt_cmd *cmd = prm->cmd;\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nuint32_t h;\r\nstruct atio_from_isp *atio = &prm->cmd->atio;\r\nuint16_t t16;\r\nsgc = 0;\r\nha = vha->hw;\r\npkt = (struct ctio_crc2_to_fw *)vha->req->ring_ptr;\r\nprm->pkt = pkt;\r\nmemset(pkt, 0, sizeof(*pkt));\r\nql_dbg(ql_dbg_tgt, vha, 0xe071,\r\n"qla_target(%d):%s: se_cmd[%p] CRC2 prot_op[0x%x] cmd prot sg:cnt[%p:%x] lba[%llu]\n",\r\nvha->vp_idx, __func__, se_cmd, se_cmd->prot_op,\r\nprm->prot_sg, prm->prot_seg_cnt, se_cmd->t_task_lba);\r\nif ((se_cmd->prot_op == TARGET_PROT_DIN_INSERT) ||\r\n(se_cmd->prot_op == TARGET_PROT_DOUT_STRIP))\r\nbundling = 0;\r\ndata_bytes = cmd->bufflen;\r\ndif_bytes = (data_bytes / cmd->blk_sz) * 8;\r\nswitch (se_cmd->prot_op) {\r\ncase TARGET_PROT_DIN_INSERT:\r\ncase TARGET_PROT_DOUT_STRIP:\r\ntransfer_length = data_bytes;\r\ndata_bytes += dif_bytes;\r\nbreak;\r\ncase TARGET_PROT_DIN_STRIP:\r\ncase TARGET_PROT_DOUT_INSERT:\r\ncase TARGET_PROT_DIN_PASS:\r\ncase TARGET_PROT_DOUT_PASS:\r\ntransfer_length = data_bytes + dif_bytes;\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nif (!qlt_hba_err_chk_enabled(se_cmd))\r\nfw_prot_opts |= 0x10;\r\nelse if (IS_PI_UNINIT_CAPABLE(ha)) {\r\nif ((se_cmd->prot_type == TARGET_DIF_TYPE1_PROT) ||\r\n(se_cmd->prot_type == TARGET_DIF_TYPE2_PROT))\r\nfw_prot_opts |= PO_DIS_VALD_APP_ESC;\r\nelse if (se_cmd->prot_type == TARGET_DIF_TYPE3_PROT)\r\nfw_prot_opts |= PO_DIS_VALD_APP_REF_ESC;\r\n}\r\nswitch (se_cmd->prot_op) {\r\ncase TARGET_PROT_DIN_INSERT:\r\ncase TARGET_PROT_DOUT_INSERT:\r\nfw_prot_opts |= PO_MODE_DIF_INSERT;\r\nbreak;\r\ncase TARGET_PROT_DIN_STRIP:\r\ncase TARGET_PROT_DOUT_STRIP:\r\nfw_prot_opts |= PO_MODE_DIF_REMOVE;\r\nbreak;\r\ncase TARGET_PROT_DIN_PASS:\r\ncase TARGET_PROT_DOUT_PASS:\r\nfw_prot_opts |= PO_MODE_DIF_PASS;\r\nbreak;\r\ndefault:\r\nfw_prot_opts |= PO_MODE_DIF_PASS;\r\nbreak;\r\n}\r\npkt->entry_type = CTIO_CRC2;\r\npkt->entry_count = 1;\r\npkt->vp_index = vha->vp_idx;\r\nh = qlt_make_handle(vha);\r\nif (unlikely(h == QLA_TGT_NULL_HANDLE)) {\r\nreturn -EAGAIN;\r\n} else\r\nha->tgt.cmds[h-1] = prm->cmd;\r\npkt->handle = h | CTIO_COMPLETION_HANDLE_MARK;\r\npkt->nport_handle = prm->cmd->loop_id;\r\npkt->timeout = __constant_cpu_to_le16(QLA_TGT_TIMEOUT);\r\npkt->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];\r\npkt->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];\r\npkt->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];\r\npkt->exchange_addr = atio->u.isp24.exchange_addr;\r\nt16 = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);\r\npkt->ox_id = cpu_to_le16(t16);\r\nt16 = (atio->u.isp24.attr << 9);\r\npkt->flags |= cpu_to_le16(t16);\r\npkt->relative_offset = cpu_to_le32(prm->cmd->offset);\r\nif (cmd->dma_data_direction == DMA_TO_DEVICE)\r\npkt->flags = __constant_cpu_to_le16(CTIO7_FLAGS_DATA_IN);\r\nelse if (cmd->dma_data_direction == DMA_FROM_DEVICE)\r\npkt->flags = __constant_cpu_to_le16(CTIO7_FLAGS_DATA_OUT);\r\npkt->dseg_count = prm->tot_dsds;\r\npkt->transfer_length = cpu_to_le32(transfer_length);\r\ncrc_ctx_pkt = cmd->ctx =\r\ndma_pool_alloc(ha->dl_dma_pool, GFP_ATOMIC, &crc_ctx_dma);\r\nif (!crc_ctx_pkt)\r\ngoto crc_queuing_error;\r\nclr_ptr = (uint8_t *)crc_ctx_pkt;\r\nmemset(clr_ptr, 0, sizeof(*crc_ctx_pkt));\r\ncrc_ctx_pkt->crc_ctx_dma = crc_ctx_dma;\r\nINIT_LIST_HEAD(&crc_ctx_pkt->dsd_list);\r\ncrc_ctx_pkt->handle = pkt->handle;\r\nqlt_set_t10dif_tags(se_cmd, crc_ctx_pkt);\r\npkt->crc_context_address[0] = cpu_to_le32(LSD(crc_ctx_dma));\r\npkt->crc_context_address[1] = cpu_to_le32(MSD(crc_ctx_dma));\r\npkt->crc_context_len = CRC_CONTEXT_LEN_FW;\r\nif (!bundling) {\r\ncur_dsd = (uint32_t *) &crc_ctx_pkt->u.nobundling.data_address;\r\n} else {\r\nfw_prot_opts |= PO_ENABLE_DIF_BUNDLING;\r\ncrc_ctx_pkt->u.bundling.dif_byte_count = cpu_to_le32(dif_bytes);\r\ncrc_ctx_pkt->u.bundling.dseg_count =\r\ncpu_to_le16(prm->tot_dsds - prm->prot_seg_cnt);\r\ncur_dsd = (uint32_t *) &crc_ctx_pkt->u.bundling.data_address;\r\n}\r\ncrc_ctx_pkt->blk_size = cpu_to_le16(cmd->blk_sz);\r\ncrc_ctx_pkt->prot_opts = cpu_to_le16(fw_prot_opts);\r\ncrc_ctx_pkt->byte_count = cpu_to_le32(data_bytes);\r\ncrc_ctx_pkt->guard_seed = __constant_cpu_to_le16(0);\r\npkt->flags |= __constant_cpu_to_le16(CTIO7_FLAGS_DSD_PTR);\r\nif (!bundling && prm->prot_seg_cnt) {\r\nif (qla24xx_walk_and_build_sglist_no_difb(ha, NULL, cur_dsd,\r\nprm->tot_dsds, cmd))\r\ngoto crc_queuing_error;\r\n} else if (qla24xx_walk_and_build_sglist(ha, NULL, cur_dsd,\r\n(prm->tot_dsds - prm->prot_seg_cnt), cmd))\r\ngoto crc_queuing_error;\r\nif (bundling && prm->prot_seg_cnt) {\r\npkt->add_flags |= CTIO_CRC2_AF_DIF_DSD_ENA;\r\ncur_dsd = (uint32_t *) &crc_ctx_pkt->u.bundling.dif_address;\r\nif (qla24xx_walk_and_build_prot_sglist(ha, NULL, cur_dsd,\r\nprm->prot_seg_cnt, cmd))\r\ngoto crc_queuing_error;\r\n}\r\nreturn QLA_SUCCESS;\r\ncrc_queuing_error:\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nint qlt_xmit_response(struct qla_tgt_cmd *cmd, int xmit_type,\r\nuint8_t scsi_status)\r\n{\r\nstruct scsi_qla_host *vha = cmd->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct ctio7_to_24xx *pkt;\r\nstruct qla_tgt_prm prm;\r\nuint32_t full_req_cnt = 0;\r\nunsigned long flags = 0;\r\nint res;\r\nmemset(&prm, 0, sizeof(prm));\r\nqlt_check_srr_debug(cmd, &xmit_type);\r\nql_dbg(ql_dbg_tgt, cmd->vha, 0xe018,\r\n"is_send_status=%d, cmd->bufflen=%d, cmd->sg_cnt=%d, cmd->dma_data_direction=%d se_cmd[%p]\n",\r\n(xmit_type & QLA_TGT_XMIT_STATUS) ?\r\n1 : 0, cmd->bufflen, cmd->sg_cnt, cmd->dma_data_direction,\r\n&cmd->se_cmd);\r\nres = qlt_pre_xmit_response(cmd, &prm, xmit_type, scsi_status,\r\n&full_req_cnt);\r\nif (unlikely(res != 0)) {\r\nif (res == QLA_TGT_PRE_XMIT_RESP_CMD_ABORTED)\r\nreturn 0;\r\nreturn res;\r\n}\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nif (qla2x00_reset_active(vha) || cmd->reset_count != ha->chip_reset) {\r\ncmd->state = QLA_TGT_STATE_PROCESSED;\r\nqlt_abort_cmd_on_host_reset(cmd->vha, cmd);\r\nql_dbg(ql_dbg_async, vha, 0xe101,\r\n"RESET-RSP active/old-count/new-count = %d/%d/%d.\n",\r\nqla2x00_reset_active(vha), cmd->reset_count,\r\nha->chip_reset);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn 0;\r\n}\r\nres = qlt_check_reserve_free_req(vha, full_req_cnt);\r\nif (unlikely(res))\r\ngoto out_unmap_unlock;\r\nif (cmd->se_cmd.prot_op && (xmit_type & QLA_TGT_XMIT_DATA))\r\nres = qlt_build_ctio_crc2_pkt(&prm, vha);\r\nelse\r\nres = qlt_24xx_build_ctio_pkt(&prm, vha);\r\nif (unlikely(res != 0))\r\ngoto out_unmap_unlock;\r\npkt = (struct ctio7_to_24xx *)prm.pkt;\r\nif (qlt_has_data(cmd) && (xmit_type & QLA_TGT_XMIT_DATA)) {\r\npkt->u.status0.flags |=\r\n__constant_cpu_to_le16(CTIO7_FLAGS_DATA_IN |\r\nCTIO7_FLAGS_STATUS_MODE_0);\r\nif (cmd->se_cmd.prot_op == TARGET_PROT_NORMAL)\r\nqlt_load_data_segments(&prm, vha);\r\nif (prm.add_status_pkt == 0) {\r\nif (xmit_type & QLA_TGT_XMIT_STATUS) {\r\npkt->u.status0.scsi_status =\r\ncpu_to_le16(prm.rq_result);\r\npkt->u.status0.residual =\r\ncpu_to_le32(prm.residual);\r\npkt->u.status0.flags |= __constant_cpu_to_le16(\r\nCTIO7_FLAGS_SEND_STATUS);\r\nif (qlt_need_explicit_conf(ha, cmd, 0)) {\r\npkt->u.status0.flags |=\r\n__constant_cpu_to_le16(\r\nCTIO7_FLAGS_EXPLICIT_CONFORM |\r\nCTIO7_FLAGS_CONFORM_REQ);\r\n}\r\n}\r\n} else {\r\nstruct ctio7_to_24xx *ctio =\r\n(struct ctio7_to_24xx *)qlt_get_req_pkt(vha);\r\nql_dbg(ql_dbg_io, vha, 0x305e,\r\n"Building additional status packet 0x%p.\n",\r\nctio);\r\nmemcpy(ctio, pkt, sizeof(*ctio));\r\nctio->entry_count = 1;\r\nctio->entry_type = CTIO_TYPE7;\r\nctio->dseg_count = 0;\r\nctio->u.status1.flags &= ~__constant_cpu_to_le16(\r\nCTIO7_FLAGS_DATA_IN);\r\npkt->handle |= CTIO_INTERMEDIATE_HANDLE_MARK;\r\npkt->u.status0.flags |= __constant_cpu_to_le16(\r\nCTIO7_FLAGS_DONT_RET_CTIO);\r\nqlt_24xx_init_ctio_to_isp((struct ctio7_to_24xx *)ctio,\r\n&prm);\r\npr_debug("Status CTIO7: %p\n", ctio);\r\n}\r\n} else\r\nqlt_24xx_init_ctio_to_isp(pkt, &prm);\r\ncmd->state = QLA_TGT_STATE_PROCESSED;\r\ncmd->cmd_sent_to_fw = 1;\r\nwmb();\r\nqla2x00_start_iocbs(vha, vha->req);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn 0;\r\nout_unmap_unlock:\r\nqlt_unmap_sg(vha, cmd);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn res;\r\n}\r\nint qlt_rdy_to_xfer(struct qla_tgt_cmd *cmd)\r\n{\r\nstruct ctio7_to_24xx *pkt;\r\nstruct scsi_qla_host *vha = cmd->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt *tgt = cmd->tgt;\r\nstruct qla_tgt_prm prm;\r\nunsigned long flags;\r\nint res = 0;\r\nmemset(&prm, 0, sizeof(prm));\r\nprm.cmd = cmd;\r\nprm.tgt = tgt;\r\nprm.sg = NULL;\r\nprm.req_cnt = 1;\r\nif (qlt_issue_marker(vha, 0) != QLA_SUCCESS)\r\nreturn -EIO;\r\nif (qlt_pci_map_calc_cnt(&prm) != 0)\r\nreturn -EAGAIN;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nif (qla2x00_reset_active(vha) || cmd->reset_count != ha->chip_reset) {\r\ncmd->state = QLA_TGT_STATE_NEED_DATA;\r\nqlt_abort_cmd_on_host_reset(cmd->vha, cmd);\r\nql_dbg(ql_dbg_async, vha, 0xe102,\r\n"RESET-XFR active/old-count/new-count = %d/%d/%d.\n",\r\nqla2x00_reset_active(vha), cmd->reset_count,\r\nha->chip_reset);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn 0;\r\n}\r\nres = qlt_check_reserve_free_req(vha, prm.req_cnt);\r\nif (res != 0)\r\ngoto out_unlock_free_unmap;\r\nif (cmd->se_cmd.prot_op)\r\nres = qlt_build_ctio_crc2_pkt(&prm, vha);\r\nelse\r\nres = qlt_24xx_build_ctio_pkt(&prm, vha);\r\nif (unlikely(res != 0))\r\ngoto out_unlock_free_unmap;\r\npkt = (struct ctio7_to_24xx *)prm.pkt;\r\npkt->u.status0.flags |= __constant_cpu_to_le16(CTIO7_FLAGS_DATA_OUT |\r\nCTIO7_FLAGS_STATUS_MODE_0);\r\nif (cmd->se_cmd.prot_op == TARGET_PROT_NORMAL)\r\nqlt_load_data_segments(&prm, vha);\r\ncmd->state = QLA_TGT_STATE_NEED_DATA;\r\ncmd->cmd_sent_to_fw = 1;\r\nwmb();\r\nqla2x00_start_iocbs(vha, vha->req);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn res;\r\nout_unlock_free_unmap:\r\nqlt_unmap_sg(vha, cmd);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn res;\r\n}\r\nstatic inline int\r\nqlt_handle_dif_error(struct scsi_qla_host *vha, struct qla_tgt_cmd *cmd,\r\nstruct ctio_crc_from_fw *sts)\r\n{\r\nuint8_t *ap = &sts->actual_dif[0];\r\nuint8_t *ep = &sts->expected_dif[0];\r\nuint32_t e_ref_tag, a_ref_tag;\r\nuint16_t e_app_tag, a_app_tag;\r\nuint16_t e_guard, a_guard;\r\nuint64_t lba = cmd->se_cmd.t_task_lba;\r\na_guard = be16_to_cpu(*(uint16_t *)(ap + 0));\r\na_app_tag = be16_to_cpu(*(uint16_t *)(ap + 2));\r\na_ref_tag = be32_to_cpu(*(uint32_t *)(ap + 4));\r\ne_guard = be16_to_cpu(*(uint16_t *)(ep + 0));\r\ne_app_tag = be16_to_cpu(*(uint16_t *)(ep + 2));\r\ne_ref_tag = be32_to_cpu(*(uint32_t *)(ep + 4));\r\nql_dbg(ql_dbg_tgt, vha, 0xe075,\r\n"iocb(s) %p Returned STATUS.\n", sts);\r\nql_dbg(ql_dbg_tgt, vha, 0xf075,\r\n"dif check TGT cdb 0x%x lba 0x%llx: [Actual|Expected] Ref Tag[0x%x|0x%x], App Tag [0x%x|0x%x], Guard [0x%x|0x%x]\n",\r\ncmd->atio.u.isp24.fcp_cmnd.cdb[0], lba,\r\na_ref_tag, e_ref_tag, a_app_tag, e_app_tag, a_guard, e_guard);\r\nif ((a_app_tag == 0xffff) &&\r\n((cmd->se_cmd.prot_type != TARGET_DIF_TYPE3_PROT) ||\r\n(a_ref_tag == 0xffffffff))) {\r\nuint32_t blocks_done;\r\nblocks_done = e_ref_tag - (uint32_t)lba + 1;\r\ncmd->se_cmd.bad_sector = e_ref_tag;\r\ncmd->se_cmd.pi_err = 0;\r\nql_dbg(ql_dbg_tgt, vha, 0xf074,\r\n"need to return scsi good\n");\r\nif (cmd->prot_sg_cnt) {\r\nuint32_t i, j = 0, k = 0, num_ent;\r\nstruct scatterlist *sg, *sgl;\r\nsgl = cmd->prot_sg;\r\nfor_each_sg(sgl, sg, cmd->prot_sg_cnt, i) {\r\nnum_ent = sg_dma_len(sg) / 8;\r\nif (k + num_ent < blocks_done) {\r\nk += num_ent;\r\ncontinue;\r\n}\r\nj = blocks_done - k - 1;\r\nk = blocks_done;\r\nbreak;\r\n}\r\nif (k != blocks_done) {\r\nql_log(ql_log_warn, vha, 0xf076,\r\n"unexpected tag values tag:lba=%u:%llu)\n",\r\ne_ref_tag, (unsigned long long)lba);\r\ngoto out;\r\n}\r\n#if 0\r\nstruct sd_dif_tuple *spt;\r\nspt = page_address(sg_page(sg)) + sg->offset;\r\nspt += j;\r\nspt->app_tag = 0xffff;\r\nif (cmd->se_cmd.prot_type == SCSI_PROT_DIF_TYPE3)\r\nspt->ref_tag = 0xffffffff;\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nif (e_guard != a_guard) {\r\ncmd->se_cmd.pi_err = TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED;\r\ncmd->se_cmd.bad_sector = cmd->se_cmd.t_task_lba;\r\nql_log(ql_log_warn, vha, 0xe076,\r\n"Guard ERR: cdb 0x%x lba 0x%llx: [Actual|Expected] Ref Tag[0x%x|0x%x], App Tag [0x%x|0x%x], Guard [0x%x|0x%x] cmd=%p\n",\r\ncmd->atio.u.isp24.fcp_cmnd.cdb[0], lba,\r\na_ref_tag, e_ref_tag, a_app_tag, e_app_tag,\r\na_guard, e_guard, cmd);\r\ngoto out;\r\n}\r\nif (e_ref_tag != a_ref_tag) {\r\ncmd->se_cmd.pi_err = TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED;\r\ncmd->se_cmd.bad_sector = e_ref_tag;\r\nql_log(ql_log_warn, vha, 0xe077,\r\n"Ref Tag ERR: cdb 0x%x lba 0x%llx: [Actual|Expected] Ref Tag[0x%x|0x%x], App Tag [0x%x|0x%x], Guard [0x%x|0x%x] cmd=%p\n",\r\ncmd->atio.u.isp24.fcp_cmnd.cdb[0], lba,\r\na_ref_tag, e_ref_tag, a_app_tag, e_app_tag,\r\na_guard, e_guard, cmd);\r\ngoto out;\r\n}\r\nif (e_app_tag != a_app_tag) {\r\ncmd->se_cmd.pi_err = TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED;\r\ncmd->se_cmd.bad_sector = cmd->se_cmd.t_task_lba;\r\nql_log(ql_log_warn, vha, 0xe078,\r\n"App Tag ERR: cdb 0x%x lba 0x%llx: [Actual|Expected] Ref Tag[0x%x|0x%x], App Tag [0x%x|0x%x], Guard [0x%x|0x%x] cmd=%p\n",\r\ncmd->atio.u.isp24.fcp_cmnd.cdb[0], lba,\r\na_ref_tag, e_ref_tag, a_app_tag, e_app_tag,\r\na_guard, e_guard, cmd);\r\ngoto out;\r\n}\r\nout:\r\nreturn 1;\r\n}\r\nstatic int __qlt_send_term_exchange(struct scsi_qla_host *vha,\r\nstruct qla_tgt_cmd *cmd,\r\nstruct atio_from_isp *atio)\r\n{\r\nstruct ctio7_to_24xx *ctio24;\r\nstruct qla_hw_data *ha = vha->hw;\r\nrequest_t *pkt;\r\nint ret = 0;\r\nuint16_t temp;\r\nql_dbg(ql_dbg_tgt, vha, 0xe01c, "Sending TERM EXCH CTIO (ha=%p)\n", ha);\r\npkt = (request_t *)qla2x00_alloc_iocbs_ready(vha, NULL);\r\nif (pkt == NULL) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe050,\r\n"qla_target(%d): %s failed: unable to allocate "\r\n"request packet\n", vha->vp_idx, __func__);\r\nreturn -ENOMEM;\r\n}\r\nif (cmd != NULL) {\r\nif (cmd->state < QLA_TGT_STATE_PROCESSED) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe051,\r\n"qla_target(%d): Terminating cmd %p with "\r\n"incorrect state %d\n", vha->vp_idx, cmd,\r\ncmd->state);\r\n} else\r\nret = 1;\r\n}\r\npkt->entry_count = 1;\r\npkt->handle = QLA_TGT_SKIP_HANDLE | CTIO_COMPLETION_HANDLE_MARK;\r\nctio24 = (struct ctio7_to_24xx *)pkt;\r\nctio24->entry_type = CTIO_TYPE7;\r\nctio24->nport_handle = cmd ? cmd->loop_id : CTIO7_NHANDLE_UNRECOGNIZED;\r\nctio24->timeout = __constant_cpu_to_le16(QLA_TGT_TIMEOUT);\r\nctio24->vp_index = vha->vp_idx;\r\nctio24->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];\r\nctio24->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];\r\nctio24->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];\r\nctio24->exchange_addr = atio->u.isp24.exchange_addr;\r\nctio24->u.status1.flags = (atio->u.isp24.attr << 9) |\r\n__constant_cpu_to_le16(CTIO7_FLAGS_STATUS_MODE_1 |\r\nCTIO7_FLAGS_TERMINATE);\r\ntemp = be16_to_cpu(atio->u.isp24.fcp_hdr.ox_id);\r\nctio24->u.status1.ox_id = cpu_to_le16(temp);\r\nctio24->u.status1.residual = get_unaligned((uint32_t *)\r\n&atio->u.isp24.fcp_cmnd.add_cdb[\r\natio->u.isp24.fcp_cmnd.add_cdb_len]);\r\nif (ctio24->u.status1.residual != 0)\r\nctio24->u.status1.scsi_status |= SS_RESIDUAL_UNDER;\r\nwmb();\r\nqla2x00_start_iocbs(vha, vha->req);\r\nreturn ret;\r\n}\r\nstatic void qlt_send_term_exchange(struct scsi_qla_host *vha,\r\nstruct qla_tgt_cmd *cmd, struct atio_from_isp *atio, int ha_locked)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nif (qlt_issue_marker(vha, ha_locked) < 0)\r\nreturn;\r\nif (ha_locked) {\r\nrc = __qlt_send_term_exchange(vha, cmd, atio);\r\nif (rc == -ENOMEM)\r\nqlt_alloc_qfull_cmd(vha, atio, 0, 0);\r\ngoto done;\r\n}\r\nspin_lock_irqsave(&vha->hw->hardware_lock, flags);\r\nrc = __qlt_send_term_exchange(vha, cmd, atio);\r\nif (rc == -ENOMEM)\r\nqlt_alloc_qfull_cmd(vha, atio, 0, 0);\r\nspin_unlock_irqrestore(&vha->hw->hardware_lock, flags);\r\ndone:\r\nif (cmd && ((cmd->state != QLA_TGT_STATE_ABORTED) ||\r\n!cmd->cmd_sent_to_fw)) {\r\nif (!ha_locked && !in_interrupt())\r\nmsleep(250);\r\nqlt_unmap_sg(vha, cmd);\r\nvha->hw->tgt.tgt_ops->free_cmd(cmd);\r\n}\r\nreturn;\r\n}\r\nstatic void qlt_init_term_exchange(struct scsi_qla_host *vha)\r\n{\r\nstruct list_head free_list;\r\nstruct qla_tgt_cmd *cmd, *tcmd;\r\nvha->hw->tgt.leak_exchg_thresh_hold =\r\n(vha->hw->fw_xcb_count/100) * LEAK_EXCHG_THRESH_HOLD_PERCENT;\r\ncmd = tcmd = NULL;\r\nif (!list_empty(&vha->hw->tgt.q_full_list)) {\r\nINIT_LIST_HEAD(&free_list);\r\nlist_splice_init(&vha->hw->tgt.q_full_list, &free_list);\r\nlist_for_each_entry_safe(cmd, tcmd, &free_list, cmd_list) {\r\nlist_del(&cmd->cmd_list);\r\nqlt_free_cmd(cmd);\r\nvha->hw->tgt.num_qfull_cmds_alloc--;\r\n}\r\n}\r\nvha->hw->tgt.num_qfull_cmds_dropped = 0;\r\n}\r\nstatic void qlt_chk_exch_leak_thresh_hold(struct scsi_qla_host *vha)\r\n{\r\nuint32_t total_leaked;\r\ntotal_leaked = vha->hw->tgt.num_qfull_cmds_dropped;\r\nif (vha->hw->tgt.leak_exchg_thresh_hold &&\r\n(total_leaked > vha->hw->tgt.leak_exchg_thresh_hold)) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe079,\r\n"Chip reset due to exchange starvation: %d/%d.\n",\r\ntotal_leaked, vha->hw->fw_xcb_count);\r\nif (IS_P3P_TYPE(vha->hw))\r\nset_bit(FCOE_CTX_RESET_NEEDED, &vha->dpc_flags);\r\nelse\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\n}\r\n}\r\nvoid qlt_free_cmd(struct qla_tgt_cmd *cmd)\r\n{\r\nstruct qla_tgt_sess *sess = cmd->sess;\r\nql_dbg(ql_dbg_tgt, cmd->vha, 0xe074,\r\n"%s: se_cmd[%p] ox_id %04x\n",\r\n__func__, &cmd->se_cmd,\r\nbe16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));\r\nBUG_ON(cmd->cmd_in_wq);\r\nif (!cmd->q_full)\r\nqlt_decr_num_pend_cmds(cmd->vha);\r\nBUG_ON(cmd->sg_mapped);\r\ncmd->jiffies_at_free = get_jiffies_64();\r\nif (unlikely(cmd->free_sg))\r\nkfree(cmd->sg);\r\nif (!sess || !sess->se_sess) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\ncmd->jiffies_at_free = get_jiffies_64();\r\npercpu_ida_free(&sess->se_sess->sess_tag_pool, cmd->se_cmd.map_tag);\r\n}\r\nstatic int qlt_prepare_srr_ctio(struct scsi_qla_host *vha,\r\nstruct qla_tgt_cmd *cmd, void *ctio)\r\n{\r\nstruct qla_tgt_srr_ctio *sc;\r\nstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\r\nstruct qla_tgt_srr_imm *imm;\r\ntgt->ctio_srr_id++;\r\ncmd->cmd_flags |= BIT_15;\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf019,\r\n"qla_target(%d): CTIO with SRR status received\n", vha->vp_idx);\r\nif (!ctio) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf055,\r\n"qla_target(%d): SRR CTIO, but ctio is NULL\n",\r\nvha->vp_idx);\r\nreturn -EINVAL;\r\n}\r\nsc = kzalloc(sizeof(*sc), GFP_ATOMIC);\r\nif (sc != NULL) {\r\nsc->cmd = cmd;\r\nspin_lock(&tgt->srr_lock);\r\nsc->srr_id = tgt->ctio_srr_id;\r\nlist_add_tail(&sc->srr_list_entry,\r\n&tgt->srr_ctio_list);\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf01a,\r\n"CTIO SRR %p added (id %d)\n", sc, sc->srr_id);\r\nif (tgt->imm_srr_id == tgt->ctio_srr_id) {\r\nint found = 0;\r\nlist_for_each_entry(imm, &tgt->srr_imm_list,\r\nsrr_list_entry) {\r\nif (imm->srr_id == sc->srr_id) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf01b,\r\n"Scheduling srr work\n");\r\nschedule_work(&tgt->srr_work);\r\n} else {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf056,\r\n"qla_target(%d): imm_srr_id "\r\n"== ctio_srr_id (%d), but there is no "\r\n"corresponding SRR IMM, deleting CTIO "\r\n"SRR %p\n", vha->vp_idx,\r\ntgt->ctio_srr_id, sc);\r\nlist_del(&sc->srr_list_entry);\r\nspin_unlock(&tgt->srr_lock);\r\nkfree(sc);\r\nreturn -EINVAL;\r\n}\r\n}\r\nspin_unlock(&tgt->srr_lock);\r\n} else {\r\nstruct qla_tgt_srr_imm *ti;\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf057,\r\n"qla_target(%d): Unable to allocate SRR CTIO entry\n",\r\nvha->vp_idx);\r\nspin_lock(&tgt->srr_lock);\r\nlist_for_each_entry_safe(imm, ti, &tgt->srr_imm_list,\r\nsrr_list_entry) {\r\nif (imm->srr_id == tgt->ctio_srr_id) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf01c,\r\n"IMM SRR %p deleted (id %d)\n",\r\nimm, imm->srr_id);\r\nlist_del(&imm->srr_list_entry);\r\nqlt_reject_free_srr_imm(vha, imm, 1);\r\n}\r\n}\r\nspin_unlock(&tgt->srr_lock);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlt_term_ctio_exchange(struct scsi_qla_host *vha, void *ctio,\r\nstruct qla_tgt_cmd *cmd, uint32_t status)\r\n{\r\nint term = 0;\r\nif (ctio != NULL) {\r\nstruct ctio7_from_24xx *c = (struct ctio7_from_24xx *)ctio;\r\nterm = !(c->flags &\r\n__constant_cpu_to_le16(OF_TERM_EXCH));\r\n} else\r\nterm = 1;\r\nif (term)\r\nqlt_send_term_exchange(vha, cmd, &cmd->atio, 1);\r\nreturn term;\r\n}\r\nstatic inline struct qla_tgt_cmd *qlt_get_cmd(struct scsi_qla_host *vha,\r\nuint32_t handle)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nhandle--;\r\nif (ha->tgt.cmds[handle] != NULL) {\r\nstruct qla_tgt_cmd *cmd = ha->tgt.cmds[handle];\r\nha->tgt.cmds[handle] = NULL;\r\nreturn cmd;\r\n} else\r\nreturn NULL;\r\n}\r\nstatic struct qla_tgt_cmd *qlt_ctio_to_cmd(struct scsi_qla_host *vha,\r\nuint32_t handle, void *ctio)\r\n{\r\nstruct qla_tgt_cmd *cmd = NULL;\r\nhandle &= ~(CTIO_COMPLETION_HANDLE_MARK |\r\nCTIO_INTERMEDIATE_HANDLE_MARK);\r\nif (handle != QLA_TGT_NULL_HANDLE) {\r\nif (unlikely(handle == QLA_TGT_SKIP_HANDLE))\r\nreturn NULL;\r\nif (unlikely(handle > DEFAULT_OUTSTANDING_COMMANDS)) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe052,\r\n"qla_target(%d): Wrong handle %x received\n",\r\nvha->vp_idx, handle);\r\nreturn NULL;\r\n}\r\ncmd = qlt_get_cmd(vha, handle);\r\nif (unlikely(cmd == NULL)) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe053,\r\n"qla_target(%d): Suspicious: unable to "\r\n"find the command with handle %x\n", vha->vp_idx,\r\nhandle);\r\nreturn NULL;\r\n}\r\n} else if (ctio != NULL) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe054,\r\n"qla_target(%d): Wrong CTIO received: QLA24xx doesn't "\r\n"support NULL handles\n", vha->vp_idx);\r\nreturn NULL;\r\n}\r\nreturn cmd;\r\n}\r\nstatic void\r\nqlt_abort_cmd_on_host_reset(struct scsi_qla_host *vha, struct qla_tgt_cmd *cmd)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t handle;\r\nif (cmd->sg_mapped)\r\nqlt_unmap_sg(vha, cmd);\r\nhandle = qlt_make_handle(vha);\r\nif (cmd->state == QLA_TGT_STATE_PROCESSED) {\r\nql_dbg(ql_dbg_io, vha, 0xff00,\r\n"HOST-ABORT: handle=%d, state=PROCESSED.\n", handle);\r\n} else if (cmd->state == QLA_TGT_STATE_NEED_DATA) {\r\ncmd->write_data_transferred = 0;\r\ncmd->state = QLA_TGT_STATE_DATA_IN;\r\nql_dbg(ql_dbg_io, vha, 0xff01,\r\n"HOST-ABORT: handle=%d, state=DATA_IN.\n", handle);\r\nha->tgt.tgt_ops->handle_data(cmd);\r\nreturn;\r\n} else if (cmd->state == QLA_TGT_STATE_ABORTED) {\r\nql_dbg(ql_dbg_io, vha, 0xff02,\r\n"HOST-ABORT: handle=%d, state=ABORTED.\n", handle);\r\n} else {\r\nql_dbg(ql_dbg_io, vha, 0xff03,\r\n"HOST-ABORT: handle=%d, state=BAD(%d).\n", handle,\r\ncmd->state);\r\ndump_stack();\r\n}\r\ncmd->cmd_flags |= BIT_12;\r\nha->tgt.tgt_ops->free_cmd(cmd);\r\n}\r\nvoid\r\nqlt_host_reset_handler(struct qla_hw_data *ha)\r\n{\r\nstruct qla_tgt_cmd *cmd;\r\nunsigned long flags;\r\nscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\r\nscsi_qla_host_t *vha = NULL;\r\nstruct qla_tgt *tgt = base_vha->vha_tgt.qla_tgt;\r\nuint32_t i;\r\nif (!base_vha->hw->tgt.tgt_ops)\r\nreturn;\r\nif (!tgt || qla_ini_mode_enabled(base_vha)) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf003,\r\n"Target mode disabled\n");\r\nreturn;\r\n}\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xff10,\r\n"HOST-ABORT-HNDLR: base_vha->dpc_flags=%lx.\n",\r\nbase_vha->dpc_flags);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nfor (i = 1; i < DEFAULT_OUTSTANDING_COMMANDS + 1; i++) {\r\ncmd = qlt_get_cmd(base_vha, i);\r\nif (!cmd)\r\ncontinue;\r\nvha = cmd->vha;\r\nqlt_abort_cmd_on_host_reset(vha, cmd);\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nstatic void qlt_do_ctio_completion(struct scsi_qla_host *vha, uint32_t handle,\r\nuint32_t status, void *ctio)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct se_cmd *se_cmd;\r\nstruct target_core_fabric_ops *tfo;\r\nstruct qla_tgt_cmd *cmd;\r\nif (handle & CTIO_INTERMEDIATE_HANDLE_MARK) {\r\nif (status != CTIO_SUCCESS) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf01d,\r\n"Intermediate CTIO received"\r\n" (status %x)\n", status);\r\n}\r\nreturn;\r\n}\r\ncmd = qlt_ctio_to_cmd(vha, handle, ctio);\r\nif (cmd == NULL)\r\nreturn;\r\nse_cmd = &cmd->se_cmd;\r\ntfo = se_cmd->se_tfo;\r\ncmd->cmd_sent_to_fw = 0;\r\nqlt_unmap_sg(vha, cmd);\r\nif (unlikely(status != CTIO_SUCCESS)) {\r\nswitch (status & 0xFFFF) {\r\ncase CTIO_LIP_RESET:\r\ncase CTIO_TARGET_RESET:\r\ncase CTIO_ABORTED:\r\ncase CTIO_TIMEOUT:\r\ncase CTIO_INVALID_RX_ID:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf058,\r\n"qla_target(%d): CTIO with "\r\n"status %#x received, state %x, se_cmd %p, "\r\n"(LIP_RESET=e, ABORTED=2, TARGET_RESET=17, "\r\n"TIMEOUT=b, INVALID_RX_ID=8)\n", vha->vp_idx,\r\nstatus, cmd->state, se_cmd);\r\nbreak;\r\ncase CTIO_PORT_LOGGED_OUT:\r\ncase CTIO_PORT_UNAVAILABLE:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf059,\r\n"qla_target(%d): CTIO with PORT LOGGED "\r\n"OUT (29) or PORT UNAVAILABLE (28) status %x "\r\n"received (state %x, se_cmd %p)\n", vha->vp_idx,\r\nstatus, cmd->state, se_cmd);\r\nbreak;\r\ncase CTIO_SRR_RECEIVED:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf05a,\r\n"qla_target(%d): CTIO with SRR_RECEIVED"\r\n" status %x received (state %x, se_cmd %p)\n",\r\nvha->vp_idx, status, cmd->state, se_cmd);\r\nif (qlt_prepare_srr_ctio(vha, cmd, ctio) != 0)\r\nbreak;\r\nelse\r\nreturn;\r\ncase CTIO_DIF_ERROR: {\r\nstruct ctio_crc_from_fw *crc =\r\n(struct ctio_crc_from_fw *)ctio;\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf073,\r\n"qla_target(%d): CTIO with DIF_ERROR status %x received (state %x, se_cmd %p) actual_dif[0x%llx] expect_dif[0x%llx]\n",\r\nvha->vp_idx, status, cmd->state, se_cmd,\r\n*((u64 *)&crc->actual_dif[0]),\r\n*((u64 *)&crc->expected_dif[0]));\r\nif (qlt_handle_dif_error(vha, cmd, ctio)) {\r\nif (cmd->state == QLA_TGT_STATE_NEED_DATA) {\r\ngoto skip_term;\r\n} else {\r\ncmd->state = QLA_TGT_STATE_PROCESSED;\r\nha->tgt.tgt_ops->handle_dif_err(cmd);\r\nreturn;\r\n}\r\n} else {\r\nstatus = 0;\r\ngoto skip_term;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf05b,\r\n"qla_target(%d): CTIO with error status 0x%x received (state %x, se_cmd %p\n",\r\nvha->vp_idx, status, cmd->state, se_cmd);\r\nbreak;\r\n}\r\nif ((cmd->state != QLA_TGT_STATE_NEED_DATA) &&\r\n(cmd->state != QLA_TGT_STATE_ABORTED)) {\r\ncmd->cmd_flags |= BIT_13;\r\nif (qlt_term_ctio_exchange(vha, ctio, cmd, status))\r\nreturn;\r\n}\r\n}\r\nskip_term:\r\nif (cmd->state == QLA_TGT_STATE_PROCESSED) {\r\n;\r\n} else if (cmd->state == QLA_TGT_STATE_NEED_DATA) {\r\nint rx_status = 0;\r\ncmd->state = QLA_TGT_STATE_DATA_IN;\r\nif (unlikely(status != CTIO_SUCCESS))\r\nrx_status = -EIO;\r\nelse\r\ncmd->write_data_transferred = 1;\r\nha->tgt.tgt_ops->handle_data(cmd);\r\nreturn;\r\n} else if (cmd->state == QLA_TGT_STATE_ABORTED) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf01e,\r\n"Aborted command %p (tag %d) finished\n", cmd, cmd->tag);\r\n} else {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf05c,\r\n"qla_target(%d): A command in state (%d) should "\r\n"not return a CTIO complete\n", vha->vp_idx, cmd->state);\r\n}\r\nif (unlikely(status != CTIO_SUCCESS) &&\r\n(cmd->state != QLA_TGT_STATE_ABORTED)) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf01f, "Finishing failed CTIO\n");\r\ndump_stack();\r\n}\r\nha->tgt.tgt_ops->free_cmd(cmd);\r\n}\r\nstatic inline int qlt_get_fcp_task_attr(struct scsi_qla_host *vha,\r\nuint8_t task_codes)\r\n{\r\nint fcp_task_attr;\r\nswitch (task_codes) {\r\ncase ATIO_SIMPLE_QUEUE:\r\nfcp_task_attr = TCM_SIMPLE_TAG;\r\nbreak;\r\ncase ATIO_HEAD_OF_QUEUE:\r\nfcp_task_attr = TCM_HEAD_TAG;\r\nbreak;\r\ncase ATIO_ORDERED_QUEUE:\r\nfcp_task_attr = TCM_ORDERED_TAG;\r\nbreak;\r\ncase ATIO_ACA_QUEUE:\r\nfcp_task_attr = TCM_ACA_TAG;\r\nbreak;\r\ncase ATIO_UNTAGGED:\r\nfcp_task_attr = TCM_SIMPLE_TAG;\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf05d,\r\n"qla_target: unknown task code %x, use ORDERED instead\n",\r\ntask_codes);\r\nfcp_task_attr = TCM_ORDERED_TAG;\r\nbreak;\r\n}\r\nreturn fcp_task_attr;\r\n}\r\nstatic void __qlt_do_work(struct qla_tgt_cmd *cmd)\r\n{\r\nscsi_qla_host_t *vha = cmd->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\r\nstruct qla_tgt_sess *sess = cmd->sess;\r\nstruct atio_from_isp *atio = &cmd->atio;\r\nunsigned char *cdb;\r\nunsigned long flags;\r\nuint32_t data_length;\r\nint ret, fcp_task_attr, data_dir, bidi = 0;\r\ncmd->cmd_in_wq = 0;\r\ncmd->cmd_flags |= BIT_1;\r\nif (tgt->tgt_stop)\r\ngoto out_term;\r\ncdb = &atio->u.isp24.fcp_cmnd.cdb[0];\r\ncmd->tag = atio->u.isp24.exchange_addr;\r\ncmd->unpacked_lun = scsilun_to_int(\r\n(struct scsi_lun *)&atio->u.isp24.fcp_cmnd.lun);\r\nif (atio->u.isp24.fcp_cmnd.rddata &&\r\natio->u.isp24.fcp_cmnd.wrdata) {\r\nbidi = 1;\r\ndata_dir = DMA_TO_DEVICE;\r\n} else if (atio->u.isp24.fcp_cmnd.rddata)\r\ndata_dir = DMA_FROM_DEVICE;\r\nelse if (atio->u.isp24.fcp_cmnd.wrdata)\r\ndata_dir = DMA_TO_DEVICE;\r\nelse\r\ndata_dir = DMA_NONE;\r\nfcp_task_attr = qlt_get_fcp_task_attr(vha,\r\natio->u.isp24.fcp_cmnd.task_attr);\r\ndata_length = be32_to_cpu(get_unaligned((uint32_t *)\r\n&atio->u.isp24.fcp_cmnd.add_cdb[\r\natio->u.isp24.fcp_cmnd.add_cdb_len]));\r\nret = ha->tgt.tgt_ops->handle_cmd(vha, cmd, cdb, data_length,\r\nfcp_task_attr, data_dir, bidi);\r\nif (ret != 0)\r\ngoto out_term;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nha->tgt.tgt_ops->put_sess(sess);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn;\r\nout_term:\r\nql_dbg(ql_dbg_io, vha, 0x3060, "Terminating work cmd %p", cmd);\r\ncmd->cmd_flags |= BIT_2;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nqlt_send_term_exchange(vha, NULL, &cmd->atio, 1);\r\nqlt_decr_num_pend_cmds(vha);\r\npercpu_ida_free(&sess->se_sess->sess_tag_pool, cmd->se_cmd.map_tag);\r\nha->tgt.tgt_ops->put_sess(sess);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nstatic void qlt_do_work(struct work_struct *work)\r\n{\r\nstruct qla_tgt_cmd *cmd = container_of(work, struct qla_tgt_cmd, work);\r\n__qlt_do_work(cmd);\r\n}\r\nstatic struct qla_tgt_cmd *qlt_get_tag(scsi_qla_host_t *vha,\r\nstruct qla_tgt_sess *sess,\r\nstruct atio_from_isp *atio)\r\n{\r\nstruct se_session *se_sess = sess->se_sess;\r\nstruct qla_tgt_cmd *cmd;\r\nint tag;\r\ntag = percpu_ida_alloc(&se_sess->sess_tag_pool, TASK_RUNNING);\r\nif (tag < 0)\r\nreturn NULL;\r\ncmd = &((struct qla_tgt_cmd *)se_sess->sess_cmd_map)[tag];\r\nmemset(cmd, 0, sizeof(struct qla_tgt_cmd));\r\nmemcpy(&cmd->atio, atio, sizeof(*atio));\r\ncmd->state = QLA_TGT_STATE_NEW;\r\ncmd->tgt = vha->vha_tgt.qla_tgt;\r\nqlt_incr_num_pend_cmds(vha);\r\ncmd->vha = vha;\r\ncmd->se_cmd.map_tag = tag;\r\ncmd->sess = sess;\r\ncmd->loop_id = sess->loop_id;\r\ncmd->conf_compl_supported = sess->conf_compl_supported;\r\nreturn cmd;\r\n}\r\nstatic void qlt_create_sess_from_atio(struct work_struct *work)\r\n{\r\nstruct qla_tgt_sess_op *op = container_of(work,\r\nstruct qla_tgt_sess_op, work);\r\nscsi_qla_host_t *vha = op->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt_sess *sess;\r\nstruct qla_tgt_cmd *cmd;\r\nunsigned long flags;\r\nuint8_t *s_id = op->atio.u.isp24.fcp_hdr.s_id;\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf022,\r\n"qla_target(%d): Unable to find wwn login"\r\n" (s_id %x:%x:%x), trying to create it manually\n",\r\nvha->vp_idx, s_id[0], s_id[1], s_id[2]);\r\nif (op->atio.u.raw.entry_count > 1) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf023,\r\n"Dropping multy entry atio %p\n", &op->atio);\r\ngoto out_term;\r\n}\r\nmutex_lock(&vha->vha_tgt.tgt_mutex);\r\nsess = qlt_make_local_sess(vha, s_id);\r\nmutex_unlock(&vha->vha_tgt.tgt_mutex);\r\nif (!sess)\r\ngoto out_term;\r\ncmd = qlt_get_tag(vha, sess, &op->atio);\r\nif (!cmd) {\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nqlt_send_busy(vha, &op->atio, SAM_STAT_BUSY);\r\nha->tgt.tgt_ops->put_sess(sess);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nkfree(op);\r\nreturn;\r\n}\r\n__qlt_do_work(cmd);\r\nkfree(op);\r\nreturn;\r\nout_term:\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nqlt_send_term_exchange(vha, NULL, &op->atio, 1);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nkfree(op);\r\n}\r\nstatic int qlt_handle_cmd_for_atio(struct scsi_qla_host *vha,\r\nstruct atio_from_isp *atio)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\r\nstruct qla_tgt_sess *sess;\r\nstruct qla_tgt_cmd *cmd;\r\nif (unlikely(tgt->tgt_stop)) {\r\nql_dbg(ql_dbg_io, vha, 0x3061,\r\n"New command while device %p is shutting down\n", tgt);\r\nreturn -EFAULT;\r\n}\r\nsess = ha->tgt.tgt_ops->find_sess_by_s_id(vha, atio->u.isp24.fcp_hdr.s_id);\r\nif (unlikely(!sess)) {\r\nstruct qla_tgt_sess_op *op = kzalloc(sizeof(struct qla_tgt_sess_op),\r\nGFP_ATOMIC);\r\nif (!op)\r\nreturn -ENOMEM;\r\nmemcpy(&op->atio, atio, sizeof(*atio));\r\nop->vha = vha;\r\nINIT_WORK(&op->work, qlt_create_sess_from_atio);\r\nqueue_work(qla_tgt_wq, &op->work);\r\nreturn 0;\r\n}\r\nkref_get(&sess->se_sess->sess_kref);\r\ncmd = qlt_get_tag(vha, sess, atio);\r\nif (!cmd) {\r\nql_dbg(ql_dbg_io, vha, 0x3062,\r\n"qla_target(%d): Allocation of cmd failed\n", vha->vp_idx);\r\nha->tgt.tgt_ops->put_sess(sess);\r\nreturn -ENOMEM;\r\n}\r\ncmd->cmd_flags = 0;\r\ncmd->jiffies_at_alloc = get_jiffies_64();\r\ncmd->reset_count = vha->hw->chip_reset;\r\ncmd->cmd_in_wq = 1;\r\ncmd->cmd_flags |= BIT_0;\r\nINIT_WORK(&cmd->work, qlt_do_work);\r\nqueue_work(qla_tgt_wq, &cmd->work);\r\nreturn 0;\r\n}\r\nstatic int qlt_issue_task_mgmt(struct qla_tgt_sess *sess, uint32_t lun,\r\nint fn, void *iocb, int flags)\r\n{\r\nstruct scsi_qla_host *vha = sess->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt_mgmt_cmd *mcmd;\r\nint res;\r\nuint8_t tmr_func;\r\nmcmd = mempool_alloc(qla_tgt_mgmt_cmd_mempool, GFP_ATOMIC);\r\nif (!mcmd) {\r\nql_dbg(ql_dbg_tgt_tmr, vha, 0x10009,\r\n"qla_target(%d): Allocation of management "\r\n"command failed, some commands and their data could "\r\n"leak\n", vha->vp_idx);\r\nreturn -ENOMEM;\r\n}\r\nmemset(mcmd, 0, sizeof(*mcmd));\r\nmcmd->sess = sess;\r\nif (iocb) {\r\nmemcpy(&mcmd->orig_iocb.imm_ntfy, iocb,\r\nsizeof(mcmd->orig_iocb.imm_ntfy));\r\n}\r\nmcmd->tmr_func = fn;\r\nmcmd->flags = flags;\r\nmcmd->reset_count = vha->hw->chip_reset;\r\nswitch (fn) {\r\ncase QLA_TGT_CLEAR_ACA:\r\nql_dbg(ql_dbg_tgt_tmr, vha, 0x10000,\r\n"qla_target(%d): CLEAR_ACA received\n", sess->vha->vp_idx);\r\ntmr_func = TMR_CLEAR_ACA;\r\nbreak;\r\ncase QLA_TGT_TARGET_RESET:\r\nql_dbg(ql_dbg_tgt_tmr, vha, 0x10001,\r\n"qla_target(%d): TARGET_RESET received\n",\r\nsess->vha->vp_idx);\r\ntmr_func = TMR_TARGET_WARM_RESET;\r\nbreak;\r\ncase QLA_TGT_LUN_RESET:\r\nql_dbg(ql_dbg_tgt_tmr, vha, 0x10002,\r\n"qla_target(%d): LUN_RESET received\n", sess->vha->vp_idx);\r\ntmr_func = TMR_LUN_RESET;\r\nbreak;\r\ncase QLA_TGT_CLEAR_TS:\r\nql_dbg(ql_dbg_tgt_tmr, vha, 0x10003,\r\n"qla_target(%d): CLEAR_TS received\n", sess->vha->vp_idx);\r\ntmr_func = TMR_CLEAR_TASK_SET;\r\nbreak;\r\ncase QLA_TGT_ABORT_TS:\r\nql_dbg(ql_dbg_tgt_tmr, vha, 0x10004,\r\n"qla_target(%d): ABORT_TS received\n", sess->vha->vp_idx);\r\ntmr_func = TMR_ABORT_TASK_SET;\r\nbreak;\r\n#if 0\r\ncase QLA_TGT_ABORT_ALL:\r\nql_dbg(ql_dbg_tgt_tmr, vha, 0x10005,\r\n"qla_target(%d): Doing ABORT_ALL_TASKS\n",\r\nsess->vha->vp_idx);\r\ntmr_func = 0;\r\nbreak;\r\ncase QLA_TGT_ABORT_ALL_SESS:\r\nql_dbg(ql_dbg_tgt_tmr, vha, 0x10006,\r\n"qla_target(%d): Doing ABORT_ALL_TASKS_SESS\n",\r\nsess->vha->vp_idx);\r\ntmr_func = 0;\r\nbreak;\r\ncase QLA_TGT_NEXUS_LOSS_SESS:\r\nql_dbg(ql_dbg_tgt_tmr, vha, 0x10007,\r\n"qla_target(%d): Doing NEXUS_LOSS_SESS\n",\r\nsess->vha->vp_idx);\r\ntmr_func = 0;\r\nbreak;\r\ncase QLA_TGT_NEXUS_LOSS:\r\nql_dbg(ql_dbg_tgt_tmr, vha, 0x10008,\r\n"qla_target(%d): Doing NEXUS_LOSS\n", sess->vha->vp_idx);\r\ntmr_func = 0;\r\nbreak;\r\n#endif\r\ndefault:\r\nql_dbg(ql_dbg_tgt_tmr, vha, 0x1000a,\r\n"qla_target(%d): Unknown task mgmt fn 0x%x\n",\r\nsess->vha->vp_idx, fn);\r\nmempool_free(mcmd, qla_tgt_mgmt_cmd_mempool);\r\nreturn -ENOSYS;\r\n}\r\nres = ha->tgt.tgt_ops->handle_tmr(mcmd, lun, tmr_func, 0);\r\nif (res != 0) {\r\nql_dbg(ql_dbg_tgt_tmr, vha, 0x1000b,\r\n"qla_target(%d): tgt.tgt_ops->handle_tmr() failed: %d\n",\r\nsess->vha->vp_idx, res);\r\nmempool_free(mcmd, qla_tgt_mgmt_cmd_mempool);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlt_handle_task_mgmt(struct scsi_qla_host *vha, void *iocb)\r\n{\r\nstruct atio_from_isp *a = (struct atio_from_isp *)iocb;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt *tgt;\r\nstruct qla_tgt_sess *sess;\r\nuint32_t lun, unpacked_lun;\r\nint lun_size, fn;\r\ntgt = vha->vha_tgt.qla_tgt;\r\nlun = a->u.isp24.fcp_cmnd.lun;\r\nlun_size = sizeof(a->u.isp24.fcp_cmnd.lun);\r\nfn = a->u.isp24.fcp_cmnd.task_mgmt_flags;\r\nsess = ha->tgt.tgt_ops->find_sess_by_s_id(vha,\r\na->u.isp24.fcp_hdr.s_id);\r\nunpacked_lun = scsilun_to_int((struct scsi_lun *)&lun);\r\nif (!sess) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf024,\r\n"qla_target(%d): task mgmt fn 0x%x for "\r\n"non-existant session\n", vha->vp_idx, fn);\r\nreturn qlt_sched_sess_work(tgt, QLA_TGT_SESS_WORK_TM, iocb,\r\nsizeof(struct atio_from_isp));\r\n}\r\nreturn qlt_issue_task_mgmt(sess, unpacked_lun, fn, iocb, 0);\r\n}\r\nstatic int __qlt_abort_task(struct scsi_qla_host *vha,\r\nstruct imm_ntfy_from_isp *iocb, struct qla_tgt_sess *sess)\r\n{\r\nstruct atio_from_isp *a = (struct atio_from_isp *)iocb;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt_mgmt_cmd *mcmd;\r\nuint32_t lun, unpacked_lun;\r\nint rc;\r\nmcmd = mempool_alloc(qla_tgt_mgmt_cmd_mempool, GFP_ATOMIC);\r\nif (mcmd == NULL) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf05f,\r\n"qla_target(%d): %s: Allocation of ABORT cmd failed\n",\r\nvha->vp_idx, __func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset(mcmd, 0, sizeof(*mcmd));\r\nmcmd->sess = sess;\r\nmemcpy(&mcmd->orig_iocb.imm_ntfy, iocb,\r\nsizeof(mcmd->orig_iocb.imm_ntfy));\r\nlun = a->u.isp24.fcp_cmnd.lun;\r\nunpacked_lun = scsilun_to_int((struct scsi_lun *)&lun);\r\nmcmd->reset_count = vha->hw->chip_reset;\r\nrc = ha->tgt.tgt_ops->handle_tmr(mcmd, unpacked_lun, TMR_ABORT_TASK,\r\nle16_to_cpu(iocb->u.isp2x.seq_id));\r\nif (rc != 0) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf060,\r\n"qla_target(%d): tgt_ops->handle_tmr() failed: %d\n",\r\nvha->vp_idx, rc);\r\nmempool_free(mcmd, qla_tgt_mgmt_cmd_mempool);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlt_abort_task(struct scsi_qla_host *vha,\r\nstruct imm_ntfy_from_isp *iocb)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt_sess *sess;\r\nint loop_id;\r\nloop_id = GET_TARGET_ID(ha, (struct atio_from_isp *)iocb);\r\nsess = ha->tgt.tgt_ops->find_sess_by_loop_id(vha, loop_id);\r\nif (sess == NULL) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf025,\r\n"qla_target(%d): task abort for unexisting "\r\n"session\n", vha->vp_idx);\r\nreturn qlt_sched_sess_work(vha->vha_tgt.qla_tgt,\r\nQLA_TGT_SESS_WORK_ABORT, iocb, sizeof(*iocb));\r\n}\r\nreturn __qlt_abort_task(vha, iocb, sess);\r\n}\r\nstatic int qlt_24xx_handle_els(struct scsi_qla_host *vha,\r\nstruct imm_ntfy_from_isp *iocb)\r\n{\r\nint res = 0;\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf026,\r\n"qla_target(%d): Port ID: 0x%3phC ELS opcode: 0x%02x\n",\r\nvha->vp_idx, iocb->u.isp24.port_id, iocb->u.isp24.status_subcode);\r\nswitch (iocb->u.isp24.status_subcode) {\r\ncase ELS_PLOGI:\r\ncase ELS_FLOGI:\r\ncase ELS_PRLI:\r\ncase ELS_LOGO:\r\ncase ELS_PRLO:\r\nres = qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS);\r\nbreak;\r\ncase ELS_PDISC:\r\ncase ELS_ADISC:\r\n{\r\nstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\r\nif (tgt->link_reinit_iocb_pending) {\r\nqlt_send_notify_ack(vha, &tgt->link_reinit_iocb,\r\n0, 0, 0, 0, 0, 0);\r\ntgt->link_reinit_iocb_pending = 0;\r\n}\r\nres = 1;\r\nbreak;\r\n}\r\ndefault:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf061,\r\n"qla_target(%d): Unsupported ELS command %x "\r\n"received\n", vha->vp_idx, iocb->u.isp24.status_subcode);\r\nres = qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS);\r\nbreak;\r\n}\r\nreturn res;\r\n}\r\nstatic int qlt_set_data_offset(struct qla_tgt_cmd *cmd, uint32_t offset)\r\n{\r\nstruct scatterlist *sg, *sgp, *sg_srr, *sg_srr_start = NULL;\r\nsize_t first_offset = 0, rem_offset = offset, tmp = 0;\r\nint i, sg_srr_cnt, bufflen = 0;\r\nql_dbg(ql_dbg_tgt, cmd->vha, 0xe023,\r\n"Entering qla_tgt_set_data_offset: cmd: %p, cmd->sg: %p, "\r\n"cmd->sg_cnt: %u, direction: %d\n",\r\ncmd, cmd->sg, cmd->sg_cnt, cmd->dma_data_direction);\r\npr_debug("Rejecting non zero SRR rel_offs: %u\n", offset);\r\nreturn -1;\r\nif (!cmd->sg || !cmd->sg_cnt) {\r\nql_dbg(ql_dbg_tgt, cmd->vha, 0xe055,\r\n"Missing cmd->sg or zero cmd->sg_cnt in"\r\n" qla_tgt_set_data_offset\n");\r\nreturn -EINVAL;\r\n}\r\nfor_each_sg(cmd->sg, sg, cmd->sg_cnt, i) {\r\nql_dbg(ql_dbg_tgt, cmd->vha, 0xe024,\r\n"sg[%d]: %p page: %p, length: %d, offset: %d\n",\r\ni, sg, sg_page(sg), sg->length, sg->offset);\r\nif ((sg->length + tmp) > offset) {\r\nfirst_offset = rem_offset;\r\nsg_srr_start = sg;\r\nql_dbg(ql_dbg_tgt, cmd->vha, 0xe025,\r\n"Found matching sg[%d], using %p as sg_srr_start, "\r\n"and using first_offset: %zu\n", i, sg,\r\nfirst_offset);\r\nbreak;\r\n}\r\ntmp += sg->length;\r\nrem_offset -= sg->length;\r\n}\r\nif (!sg_srr_start) {\r\nql_dbg(ql_dbg_tgt, cmd->vha, 0xe056,\r\n"Unable to locate sg_srr_start for offset: %u\n", offset);\r\nreturn -EINVAL;\r\n}\r\nsg_srr_cnt = (cmd->sg_cnt - i);\r\nsg_srr = kzalloc(sizeof(struct scatterlist) * sg_srr_cnt, GFP_KERNEL);\r\nif (!sg_srr) {\r\nql_dbg(ql_dbg_tgt, cmd->vha, 0xe057,\r\n"Unable to allocate sgp\n");\r\nreturn -ENOMEM;\r\n}\r\nsg_init_table(sg_srr, sg_srr_cnt);\r\nsgp = &sg_srr[0];\r\nfor_each_sg(sg_srr_start, sg, sg_srr_cnt, i) {\r\nif (first_offset) {\r\nsg_set_page(sgp, sg_page(sg),\r\n(sg->length - first_offset), first_offset);\r\nfirst_offset = 0;\r\n} else {\r\nsg_set_page(sgp, sg_page(sg), sg->length, 0);\r\n}\r\nbufflen += sgp->length;\r\nsgp = sg_next(sgp);\r\nif (!sgp)\r\nbreak;\r\n}\r\ncmd->sg = sg_srr;\r\ncmd->sg_cnt = sg_srr_cnt;\r\ncmd->bufflen = bufflen;\r\ncmd->offset += offset;\r\ncmd->free_sg = 1;\r\nql_dbg(ql_dbg_tgt, cmd->vha, 0xe026, "New cmd->sg: %p\n", cmd->sg);\r\nql_dbg(ql_dbg_tgt, cmd->vha, 0xe027, "New cmd->sg_cnt: %u\n",\r\ncmd->sg_cnt);\r\nql_dbg(ql_dbg_tgt, cmd->vha, 0xe028, "New cmd->bufflen: %u\n",\r\ncmd->bufflen);\r\nql_dbg(ql_dbg_tgt, cmd->vha, 0xe029, "New cmd->offset: %u\n",\r\ncmd->offset);\r\nif (cmd->sg_cnt < 0)\r\nBUG();\r\nif (cmd->bufflen < 0)\r\nBUG();\r\nreturn 0;\r\n}\r\nstatic inline int qlt_srr_adjust_data(struct qla_tgt_cmd *cmd,\r\nuint32_t srr_rel_offs, int *xmit_type)\r\n{\r\nint res = 0, rel_offs;\r\nrel_offs = srr_rel_offs - cmd->offset;\r\nql_dbg(ql_dbg_tgt_mgt, cmd->vha, 0xf027, "srr_rel_offs=%d, rel_offs=%d",\r\nsrr_rel_offs, rel_offs);\r\n*xmit_type = QLA_TGT_XMIT_ALL;\r\nif (rel_offs < 0) {\r\nql_dbg(ql_dbg_tgt_mgt, cmd->vha, 0xf062,\r\n"qla_target(%d): SRR rel_offs (%d) < 0",\r\ncmd->vha->vp_idx, rel_offs);\r\nres = -1;\r\n} else if (rel_offs == cmd->bufflen)\r\n*xmit_type = QLA_TGT_XMIT_STATUS;\r\nelse if (rel_offs > 0)\r\nres = qlt_set_data_offset(cmd, rel_offs);\r\nreturn res;\r\n}\r\nstatic void qlt_handle_srr(struct scsi_qla_host *vha,\r\nstruct qla_tgt_srr_ctio *sctio, struct qla_tgt_srr_imm *imm)\r\n{\r\nstruct imm_ntfy_from_isp *ntfy =\r\n(struct imm_ntfy_from_isp *)&imm->imm_ntfy;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt_cmd *cmd = sctio->cmd;\r\nstruct se_cmd *se_cmd = &cmd->se_cmd;\r\nunsigned long flags;\r\nint xmit_type = 0, resp = 0;\r\nuint32_t offset;\r\nuint16_t srr_ui;\r\noffset = le32_to_cpu(ntfy->u.isp24.srr_rel_offs);\r\nsrr_ui = ntfy->u.isp24.srr_ui;\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf028, "SRR cmd %p, srr_ui %x\n",\r\ncmd, srr_ui);\r\nswitch (srr_ui) {\r\ncase SRR_IU_STATUS:\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nqlt_send_notify_ack(vha, ntfy,\r\n0, 0, 0, NOTIFY_ACK_SRR_FLAGS_ACCEPT, 0, 0);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nxmit_type = QLA_TGT_XMIT_STATUS;\r\nresp = 1;\r\nbreak;\r\ncase SRR_IU_DATA_IN:\r\nif (!cmd->sg || !cmd->sg_cnt) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf063,\r\n"Unable to process SRR_IU_DATA_IN due to"\r\n" missing cmd->sg, state: %d\n", cmd->state);\r\ndump_stack();\r\ngoto out_reject;\r\n}\r\nif (se_cmd->scsi_status != 0) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe02a,\r\n"Rejecting SRR_IU_DATA_IN with non GOOD "\r\n"scsi_status\n");\r\ngoto out_reject;\r\n}\r\ncmd->bufflen = se_cmd->data_length;\r\nif (qlt_has_data(cmd)) {\r\nif (qlt_srr_adjust_data(cmd, offset, &xmit_type) != 0)\r\ngoto out_reject;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nqlt_send_notify_ack(vha, ntfy,\r\n0, 0, 0, NOTIFY_ACK_SRR_FLAGS_ACCEPT, 0, 0);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nresp = 1;\r\n} else {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf064,\r\n"qla_target(%d): SRR for in data for cmd "\r\n"without them (tag %d, SCSI status %d), "\r\n"reject", vha->vp_idx, cmd->tag,\r\ncmd->se_cmd.scsi_status);\r\ngoto out_reject;\r\n}\r\nbreak;\r\ncase SRR_IU_DATA_OUT:\r\nif (!cmd->sg || !cmd->sg_cnt) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf065,\r\n"Unable to process SRR_IU_DATA_OUT due to"\r\n" missing cmd->sg\n");\r\ndump_stack();\r\ngoto out_reject;\r\n}\r\nif (se_cmd->scsi_status != 0) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe02b,\r\n"Rejecting SRR_IU_DATA_OUT"\r\n" with non GOOD scsi_status\n");\r\ngoto out_reject;\r\n}\r\ncmd->bufflen = se_cmd->data_length;\r\nif (qlt_has_data(cmd)) {\r\nif (qlt_srr_adjust_data(cmd, offset, &xmit_type) != 0)\r\ngoto out_reject;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nqlt_send_notify_ack(vha, ntfy,\r\n0, 0, 0, NOTIFY_ACK_SRR_FLAGS_ACCEPT, 0, 0);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (xmit_type & QLA_TGT_XMIT_DATA) {\r\ncmd->cmd_flags |= BIT_8;\r\nqlt_rdy_to_xfer(cmd);\r\n}\r\n} else {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf066,\r\n"qla_target(%d): SRR for out data for cmd "\r\n"without them (tag %d, SCSI status %d), "\r\n"reject", vha->vp_idx, cmd->tag,\r\ncmd->se_cmd.scsi_status);\r\ngoto out_reject;\r\n}\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf067,\r\n"qla_target(%d): Unknown srr_ui value %x",\r\nvha->vp_idx, srr_ui);\r\ngoto out_reject;\r\n}\r\nif (resp) {\r\ncmd->cmd_flags |= BIT_7;\r\nqlt_xmit_response(cmd, xmit_type, se_cmd->scsi_status);\r\n}\r\nreturn;\r\nout_reject:\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nqlt_send_notify_ack(vha, ntfy, 0, 0, 0,\r\nNOTIFY_ACK_SRR_FLAGS_REJECT,\r\nNOTIFY_ACK_SRR_REJECT_REASON_UNABLE_TO_PERFORM,\r\nNOTIFY_ACK_SRR_FLAGS_REJECT_EXPL_NO_EXPL);\r\nif (cmd->state == QLA_TGT_STATE_NEED_DATA) {\r\ncmd->state = QLA_TGT_STATE_DATA_IN;\r\ndump_stack();\r\n} else {\r\ncmd->cmd_flags |= BIT_9;\r\nqlt_send_term_exchange(vha, cmd, &cmd->atio, 1);\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nstatic void qlt_reject_free_srr_imm(struct scsi_qla_host *vha,\r\nstruct qla_tgt_srr_imm *imm, int ha_locked)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nunsigned long flags = 0;\r\nif (!ha_locked)\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nqlt_send_notify_ack(vha, (void *)&imm->imm_ntfy, 0, 0, 0,\r\nNOTIFY_ACK_SRR_FLAGS_REJECT,\r\nNOTIFY_ACK_SRR_REJECT_REASON_UNABLE_TO_PERFORM,\r\nNOTIFY_ACK_SRR_FLAGS_REJECT_EXPL_NO_EXPL);\r\nif (!ha_locked)\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nkfree(imm);\r\n}\r\nstatic void qlt_handle_srr_work(struct work_struct *work)\r\n{\r\nstruct qla_tgt *tgt = container_of(work, struct qla_tgt, srr_work);\r\nstruct scsi_qla_host *vha = tgt->vha;\r\nstruct qla_tgt_srr_ctio *sctio;\r\nunsigned long flags;\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf029, "Entering SRR work (tgt %p)\n",\r\ntgt);\r\nrestart:\r\nspin_lock_irqsave(&tgt->srr_lock, flags);\r\nlist_for_each_entry(sctio, &tgt->srr_ctio_list, srr_list_entry) {\r\nstruct qla_tgt_srr_imm *imm, *i, *ti;\r\nstruct qla_tgt_cmd *cmd;\r\nstruct se_cmd *se_cmd;\r\nimm = NULL;\r\nlist_for_each_entry_safe(i, ti, &tgt->srr_imm_list,\r\nsrr_list_entry) {\r\nif (i->srr_id == sctio->srr_id) {\r\nlist_del(&i->srr_list_entry);\r\nif (imm) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf068,\r\n"qla_target(%d): There must be "\r\n"only one IMM SRR per CTIO SRR "\r\n"(IMM SRR %p, id %d, CTIO %p\n",\r\nvha->vp_idx, i, i->srr_id, sctio);\r\nqlt_reject_free_srr_imm(tgt->vha, i, 0);\r\n} else\r\nimm = i;\r\n}\r\n}\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf02a,\r\n"IMM SRR %p, CTIO SRR %p (id %d)\n", imm, sctio,\r\nsctio->srr_id);\r\nif (imm == NULL) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf02b,\r\n"Not found matching IMM for SRR CTIO (id %d)\n",\r\nsctio->srr_id);\r\ncontinue;\r\n} else\r\nlist_del(&sctio->srr_list_entry);\r\nspin_unlock_irqrestore(&tgt->srr_lock, flags);\r\ncmd = sctio->cmd;\r\ncmd->offset = 0;\r\nif (cmd->free_sg) {\r\nkfree(cmd->sg);\r\ncmd->sg = NULL;\r\ncmd->free_sg = 0;\r\n}\r\nse_cmd = &cmd->se_cmd;\r\ncmd->sg_cnt = se_cmd->t_data_nents;\r\ncmd->sg = se_cmd->t_data_sg;\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf02c,\r\n"SRR cmd %p (se_cmd %p, tag %d, op %x), "\r\n"sg_cnt=%d, offset=%d", cmd, &cmd->se_cmd, cmd->tag,\r\nse_cmd->t_task_cdb ? se_cmd->t_task_cdb[0] : 0,\r\ncmd->sg_cnt, cmd->offset);\r\nqlt_handle_srr(vha, sctio, imm);\r\nkfree(imm);\r\nkfree(sctio);\r\ngoto restart;\r\n}\r\nspin_unlock_irqrestore(&tgt->srr_lock, flags);\r\n}\r\nstatic void qlt_prepare_srr_imm(struct scsi_qla_host *vha,\r\nstruct imm_ntfy_from_isp *iocb)\r\n{\r\nstruct qla_tgt_srr_imm *imm;\r\nstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\r\nstruct qla_tgt_srr_ctio *sctio;\r\ntgt->imm_srr_id++;\r\nql_log(ql_log_warn, vha, 0xf02d, "qla_target(%d): SRR received\n",\r\nvha->vp_idx);\r\nimm = kzalloc(sizeof(*imm), GFP_ATOMIC);\r\nif (imm != NULL) {\r\nmemcpy(&imm->imm_ntfy, iocb, sizeof(imm->imm_ntfy));\r\nspin_lock(&tgt->srr_lock);\r\nimm->srr_id = tgt->imm_srr_id;\r\nlist_add_tail(&imm->srr_list_entry,\r\n&tgt->srr_imm_list);\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf02e,\r\n"IMM NTFY SRR %p added (id %d, ui %x)\n",\r\nimm, imm->srr_id, iocb->u.isp24.srr_ui);\r\nif (tgt->imm_srr_id == tgt->ctio_srr_id) {\r\nint found = 0;\r\nlist_for_each_entry(sctio, &tgt->srr_ctio_list,\r\nsrr_list_entry) {\r\nif (sctio->srr_id == imm->srr_id) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf02f, "%s",\r\n"Scheduling srr work\n");\r\nschedule_work(&tgt->srr_work);\r\n} else {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf030,\r\n"qla_target(%d): imm_srr_id "\r\n"== ctio_srr_id (%d), but there is no "\r\n"corresponding SRR CTIO, deleting IMM "\r\n"SRR %p\n", vha->vp_idx, tgt->ctio_srr_id,\r\nimm);\r\nlist_del(&imm->srr_list_entry);\r\nkfree(imm);\r\nspin_unlock(&tgt->srr_lock);\r\ngoto out_reject;\r\n}\r\n}\r\nspin_unlock(&tgt->srr_lock);\r\n} else {\r\nstruct qla_tgt_srr_ctio *ts;\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf069,\r\n"qla_target(%d): Unable to allocate SRR IMM "\r\n"entry, SRR request will be rejected\n", vha->vp_idx);\r\nspin_lock(&tgt->srr_lock);\r\nlist_for_each_entry_safe(sctio, ts, &tgt->srr_ctio_list,\r\nsrr_list_entry) {\r\nif (sctio->srr_id == tgt->imm_srr_id) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf031,\r\n"CTIO SRR %p deleted (id %d)\n",\r\nsctio, sctio->srr_id);\r\nlist_del(&sctio->srr_list_entry);\r\nqlt_send_term_exchange(vha, sctio->cmd,\r\n&sctio->cmd->atio, 1);\r\nkfree(sctio);\r\n}\r\n}\r\nspin_unlock(&tgt->srr_lock);\r\ngoto out_reject;\r\n}\r\nreturn;\r\nout_reject:\r\nqlt_send_notify_ack(vha, iocb, 0, 0, 0,\r\nNOTIFY_ACK_SRR_FLAGS_REJECT,\r\nNOTIFY_ACK_SRR_REJECT_REASON_UNABLE_TO_PERFORM,\r\nNOTIFY_ACK_SRR_FLAGS_REJECT_EXPL_NO_EXPL);\r\n}\r\nstatic void qlt_handle_imm_notify(struct scsi_qla_host *vha,\r\nstruct imm_ntfy_from_isp *iocb)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t add_flags = 0;\r\nint send_notify_ack = 1;\r\nuint16_t status;\r\nstatus = le16_to_cpu(iocb->u.isp2x.status);\r\nswitch (status) {\r\ncase IMM_NTFY_LIP_RESET:\r\n{\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf032,\r\n"qla_target(%d): LIP reset (loop %#x), subcode %x\n",\r\nvha->vp_idx, le16_to_cpu(iocb->u.isp24.nport_handle),\r\niocb->u.isp24.status_subcode);\r\nif (qlt_reset(vha, iocb, QLA_TGT_ABORT_ALL) == 0)\r\nsend_notify_ack = 0;\r\nbreak;\r\n}\r\ncase IMM_NTFY_LIP_LINK_REINIT:\r\n{\r\nstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf033,\r\n"qla_target(%d): LINK REINIT (loop %#x, "\r\n"subcode %x)\n", vha->vp_idx,\r\nle16_to_cpu(iocb->u.isp24.nport_handle),\r\niocb->u.isp24.status_subcode);\r\nif (tgt->link_reinit_iocb_pending) {\r\nqlt_send_notify_ack(vha, &tgt->link_reinit_iocb,\r\n0, 0, 0, 0, 0, 0);\r\n}\r\nmemcpy(&tgt->link_reinit_iocb, iocb, sizeof(*iocb));\r\ntgt->link_reinit_iocb_pending = 1;\r\nsend_notify_ack = 0;\r\nbreak;\r\n}\r\ncase IMM_NTFY_PORT_LOGOUT:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf034,\r\n"qla_target(%d): Port logout (loop "\r\n"%#x, subcode %x)\n", vha->vp_idx,\r\nle16_to_cpu(iocb->u.isp24.nport_handle),\r\niocb->u.isp24.status_subcode);\r\nif (qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS_SESS) == 0)\r\nsend_notify_ack = 0;\r\nbreak;\r\ncase IMM_NTFY_GLBL_TPRLO:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf035,\r\n"qla_target(%d): Global TPRLO (%x)\n", vha->vp_idx, status);\r\nif (qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS) == 0)\r\nsend_notify_ack = 0;\r\nbreak;\r\ncase IMM_NTFY_PORT_CONFIG:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf036,\r\n"qla_target(%d): Port config changed (%x)\n", vha->vp_idx,\r\nstatus);\r\nif (qlt_reset(vha, iocb, QLA_TGT_ABORT_ALL) == 0)\r\nsend_notify_ack = 0;\r\nbreak;\r\ncase IMM_NTFY_GLBL_LOGO:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf06a,\r\n"qla_target(%d): Link failure detected\n",\r\nvha->vp_idx);\r\nif (qlt_reset(vha, iocb, QLA_TGT_NEXUS_LOSS) == 0)\r\nsend_notify_ack = 0;\r\nbreak;\r\ncase IMM_NTFY_IOCB_OVERFLOW:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf06b,\r\n"qla_target(%d): Cannot provide requested "\r\n"capability (IOCB overflowed the immediate notify "\r\n"resource count)\n", vha->vp_idx);\r\nbreak;\r\ncase IMM_NTFY_ABORT_TASK:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf037,\r\n"qla_target(%d): Abort Task (S %08x I %#x -> "\r\n"L %#x)\n", vha->vp_idx,\r\nle16_to_cpu(iocb->u.isp2x.seq_id),\r\nGET_TARGET_ID(ha, (struct atio_from_isp *)iocb),\r\nle16_to_cpu(iocb->u.isp2x.lun));\r\nif (qlt_abort_task(vha, iocb) == 0)\r\nsend_notify_ack = 0;\r\nbreak;\r\ncase IMM_NTFY_RESOURCE:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf06c,\r\n"qla_target(%d): Out of resources, host %ld\n",\r\nvha->vp_idx, vha->host_no);\r\nbreak;\r\ncase IMM_NTFY_MSG_RX:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf038,\r\n"qla_target(%d): Immediate notify task %x\n",\r\nvha->vp_idx, iocb->u.isp2x.task_flags);\r\nif (qlt_handle_task_mgmt(vha, iocb) == 0)\r\nsend_notify_ack = 0;\r\nbreak;\r\ncase IMM_NTFY_ELS:\r\nif (qlt_24xx_handle_els(vha, iocb) == 0)\r\nsend_notify_ack = 0;\r\nbreak;\r\ncase IMM_NTFY_SRR:\r\nqlt_prepare_srr_imm(vha, iocb);\r\nsend_notify_ack = 0;\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf06d,\r\n"qla_target(%d): Received unknown immediate "\r\n"notify status %x\n", vha->vp_idx, status);\r\nbreak;\r\n}\r\nif (send_notify_ack)\r\nqlt_send_notify_ack(vha, iocb, add_flags, 0, 0, 0, 0, 0);\r\n}\r\nstatic int __qlt_send_busy(struct scsi_qla_host *vha,\r\nstruct atio_from_isp *atio, uint16_t status)\r\n{\r\nstruct ctio7_to_24xx *ctio24;\r\nstruct qla_hw_data *ha = vha->hw;\r\nrequest_t *pkt;\r\nstruct qla_tgt_sess *sess = NULL;\r\nsess = ha->tgt.tgt_ops->find_sess_by_s_id(vha,\r\natio->u.isp24.fcp_hdr.s_id);\r\nif (!sess) {\r\nqlt_send_term_exchange(vha, NULL, atio, 1);\r\nreturn 0;\r\n}\r\npkt = (request_t *)qla2x00_alloc_iocbs(vha, NULL);\r\nif (!pkt) {\r\nql_dbg(ql_dbg_io, vha, 0x3063,\r\n"qla_target(%d): %s failed: unable to allocate "\r\n"request packet", vha->vp_idx, __func__);\r\nreturn -ENOMEM;\r\n}\r\npkt->entry_count = 1;\r\npkt->handle = QLA_TGT_SKIP_HANDLE | CTIO_COMPLETION_HANDLE_MARK;\r\nctio24 = (struct ctio7_to_24xx *)pkt;\r\nctio24->entry_type = CTIO_TYPE7;\r\nctio24->nport_handle = sess->loop_id;\r\nctio24->timeout = __constant_cpu_to_le16(QLA_TGT_TIMEOUT);\r\nctio24->vp_index = vha->vp_idx;\r\nctio24->initiator_id[0] = atio->u.isp24.fcp_hdr.s_id[2];\r\nctio24->initiator_id[1] = atio->u.isp24.fcp_hdr.s_id[1];\r\nctio24->initiator_id[2] = atio->u.isp24.fcp_hdr.s_id[0];\r\nctio24->exchange_addr = atio->u.isp24.exchange_addr;\r\nctio24->u.status1.flags = (atio->u.isp24.attr << 9) |\r\n__constant_cpu_to_le16(\r\nCTIO7_FLAGS_STATUS_MODE_1 | CTIO7_FLAGS_SEND_STATUS |\r\nCTIO7_FLAGS_DONT_RET_CTIO);\r\nctio24->u.status1.ox_id = swab16(atio->u.isp24.fcp_hdr.ox_id);\r\nctio24->u.status1.scsi_status = cpu_to_le16(status);\r\nwmb();\r\nqla2x00_start_iocbs(vha, vha->req);\r\nreturn 0;\r\n}\r\nstatic void\r\nqlt_alloc_qfull_cmd(struct scsi_qla_host *vha,\r\nstruct atio_from_isp *atio, uint16_t status, int qfull)\r\n{\r\nstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt_sess *sess;\r\nstruct se_session *se_sess;\r\nstruct qla_tgt_cmd *cmd;\r\nint tag;\r\nif (unlikely(tgt->tgt_stop)) {\r\nql_dbg(ql_dbg_io, vha, 0x300a,\r\n"New command while device %p is shutting down\n", tgt);\r\nreturn;\r\n}\r\nif ((vha->hw->tgt.num_qfull_cmds_alloc + 1) > MAX_QFULL_CMDS_ALLOC) {\r\nvha->hw->tgt.num_qfull_cmds_dropped++;\r\nif (vha->hw->tgt.num_qfull_cmds_dropped >\r\nvha->hw->qla_stats.stat_max_qfull_cmds_dropped)\r\nvha->hw->qla_stats.stat_max_qfull_cmds_dropped =\r\nvha->hw->tgt.num_qfull_cmds_dropped;\r\nql_dbg(ql_dbg_io, vha, 0x3068,\r\n"qla_target(%d): %s: QFull CMD dropped[%d]\n",\r\nvha->vp_idx, __func__,\r\nvha->hw->tgt.num_qfull_cmds_dropped);\r\nqlt_chk_exch_leak_thresh_hold(vha);\r\nreturn;\r\n}\r\nsess = ha->tgt.tgt_ops->find_sess_by_s_id\r\n(vha, atio->u.isp24.fcp_hdr.s_id);\r\nif (!sess)\r\nreturn;\r\nse_sess = sess->se_sess;\r\ntag = percpu_ida_alloc(&se_sess->sess_tag_pool, TASK_RUNNING);\r\nif (tag < 0)\r\nreturn;\r\ncmd = &((struct qla_tgt_cmd *)se_sess->sess_cmd_map)[tag];\r\nif (!cmd) {\r\nql_dbg(ql_dbg_io, vha, 0x3009,\r\n"qla_target(%d): %s: Allocation of cmd failed\n",\r\nvha->vp_idx, __func__);\r\nvha->hw->tgt.num_qfull_cmds_dropped++;\r\nif (vha->hw->tgt.num_qfull_cmds_dropped >\r\nvha->hw->qla_stats.stat_max_qfull_cmds_dropped)\r\nvha->hw->qla_stats.stat_max_qfull_cmds_dropped =\r\nvha->hw->tgt.num_qfull_cmds_dropped;\r\nqlt_chk_exch_leak_thresh_hold(vha);\r\nreturn;\r\n}\r\nmemset(cmd, 0, sizeof(struct qla_tgt_cmd));\r\nqlt_incr_num_pend_cmds(vha);\r\nINIT_LIST_HEAD(&cmd->cmd_list);\r\nmemcpy(&cmd->atio, atio, sizeof(*atio));\r\ncmd->tgt = vha->vha_tgt.qla_tgt;\r\ncmd->vha = vha;\r\ncmd->reset_count = vha->hw->chip_reset;\r\ncmd->q_full = 1;\r\nif (qfull) {\r\ncmd->q_full = 1;\r\ncmd->state = status;\r\n} else\r\ncmd->term_exchg = 1;\r\nlist_add_tail(&cmd->cmd_list, &vha->hw->tgt.q_full_list);\r\nvha->hw->tgt.num_qfull_cmds_alloc++;\r\nif (vha->hw->tgt.num_qfull_cmds_alloc >\r\nvha->hw->qla_stats.stat_max_qfull_cmds_alloc)\r\nvha->hw->qla_stats.stat_max_qfull_cmds_alloc =\r\nvha->hw->tgt.num_qfull_cmds_alloc;\r\n}\r\nint\r\nqlt_free_qfull_cmds(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nunsigned long flags;\r\nstruct qla_tgt_cmd *cmd, *tcmd;\r\nstruct list_head free_list;\r\nint rc = 0;\r\nif (list_empty(&ha->tgt.q_full_list))\r\nreturn 0;\r\nINIT_LIST_HEAD(&free_list);\r\nspin_lock_irqsave(&vha->hw->hardware_lock, flags);\r\nif (list_empty(&ha->tgt.q_full_list)) {\r\nspin_unlock_irqrestore(&vha->hw->hardware_lock, flags);\r\nreturn 0;\r\n}\r\nlist_for_each_entry_safe(cmd, tcmd, &ha->tgt.q_full_list, cmd_list) {\r\nif (cmd->q_full)\r\nrc = __qlt_send_busy(vha, &cmd->atio, cmd->state);\r\nelse if (cmd->term_exchg)\r\nrc = __qlt_send_term_exchange(vha, NULL, &cmd->atio);\r\nif (rc == -ENOMEM)\r\nbreak;\r\nif (cmd->q_full)\r\nql_dbg(ql_dbg_io, vha, 0x3006,\r\n"%s: busy sent for ox_id[%04x]\n", __func__,\r\nbe16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));\r\nelse if (cmd->term_exchg)\r\nql_dbg(ql_dbg_io, vha, 0x3007,\r\n"%s: Term exchg sent for ox_id[%04x]\n", __func__,\r\nbe16_to_cpu(cmd->atio.u.isp24.fcp_hdr.ox_id));\r\nelse\r\nql_dbg(ql_dbg_io, vha, 0x3008,\r\n"%s: Unexpected cmd in QFull list %p\n", __func__,\r\ncmd);\r\nlist_del(&cmd->cmd_list);\r\nlist_add_tail(&cmd->cmd_list, &free_list);\r\nvha->hw->tgt.num_qfull_cmds_alloc--;\r\n}\r\nspin_unlock_irqrestore(&vha->hw->hardware_lock, flags);\r\ncmd = NULL;\r\nlist_for_each_entry_safe(cmd, tcmd, &free_list, cmd_list) {\r\nlist_del(&cmd->cmd_list);\r\nqlt_free_cmd(cmd);\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\nqlt_send_busy(struct scsi_qla_host *vha,\r\nstruct atio_from_isp *atio, uint16_t status)\r\n{\r\nint rc = 0;\r\nrc = __qlt_send_busy(vha, atio, status);\r\nif (rc == -ENOMEM)\r\nqlt_alloc_qfull_cmd(vha, atio, status, 1);\r\n}\r\nstatic int\r\nqlt_chk_qfull_thresh_hold(struct scsi_qla_host *vha,\r\nstruct atio_from_isp *atio)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint16_t status;\r\nif (ha->tgt.num_pend_cmds < Q_FULL_THRESH_HOLD(ha))\r\nreturn 0;\r\nstatus = temp_sam_status;\r\nqlt_send_busy(vha, atio, status);\r\nreturn 1;\r\n}\r\nstatic void qlt_24xx_atio_pkt(struct scsi_qla_host *vha,\r\nstruct atio_from_isp *atio)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\r\nint rc;\r\nif (unlikely(tgt == NULL)) {\r\nql_dbg(ql_dbg_io, vha, 0x3064,\r\n"ATIO pkt, but no tgt (ha %p)", ha);\r\nreturn;\r\n}\r\ntgt->irq_cmd_count++;\r\nswitch (atio->u.raw.entry_type) {\r\ncase ATIO_TYPE7:\r\nif (unlikely(atio->u.isp24.exchange_addr ==\r\nATIO_EXCHANGE_ADDRESS_UNKNOWN)) {\r\nql_dbg(ql_dbg_io, vha, 0x3065,\r\n"qla_target(%d): ATIO_TYPE7 "\r\n"received with UNKNOWN exchange address, "\r\n"sending QUEUE_FULL\n", vha->vp_idx);\r\nqlt_send_busy(vha, atio, SAM_STAT_TASK_SET_FULL);\r\nbreak;\r\n}\r\nif (likely(atio->u.isp24.fcp_cmnd.task_mgmt_flags == 0)) {\r\nrc = qlt_chk_qfull_thresh_hold(vha, atio);\r\nif (rc != 0) {\r\ntgt->irq_cmd_count--;\r\nreturn;\r\n}\r\nrc = qlt_handle_cmd_for_atio(vha, atio);\r\n} else {\r\nrc = qlt_handle_task_mgmt(vha, atio);\r\n}\r\nif (unlikely(rc != 0)) {\r\nif (rc == -ESRCH) {\r\n#if 1\r\nqlt_send_busy(vha, atio, SAM_STAT_BUSY);\r\n#else\r\nqlt_send_term_exchange(vha, NULL, atio, 1);\r\n#endif\r\n} else {\r\nif (tgt->tgt_stop) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe059,\r\n"qla_target: Unable to send "\r\n"command to target for req, "\r\n"ignoring.\n");\r\n} else {\r\nql_dbg(ql_dbg_tgt, vha, 0xe05a,\r\n"qla_target(%d): Unable to send "\r\n"command to target, sending BUSY "\r\n"status.\n", vha->vp_idx);\r\nqlt_send_busy(vha, atio, SAM_STAT_BUSY);\r\n}\r\n}\r\n}\r\nbreak;\r\ncase IMMED_NOTIFY_TYPE:\r\n{\r\nif (unlikely(atio->u.isp2x.entry_status != 0)) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe05b,\r\n"qla_target(%d): Received ATIO packet %x "\r\n"with error status %x\n", vha->vp_idx,\r\natio->u.raw.entry_type,\r\natio->u.isp2x.entry_status);\r\nbreak;\r\n}\r\nql_dbg(ql_dbg_tgt, vha, 0xe02e, "%s", "IMMED_NOTIFY ATIO");\r\nqlt_handle_imm_notify(vha, (struct imm_ntfy_from_isp *)atio);\r\nbreak;\r\n}\r\ndefault:\r\nql_dbg(ql_dbg_tgt, vha, 0xe05c,\r\n"qla_target(%d): Received unknown ATIO atio "\r\n"type %x\n", vha->vp_idx, atio->u.raw.entry_type);\r\nbreak;\r\n}\r\ntgt->irq_cmd_count--;\r\n}\r\nstatic void qlt_response_pkt(struct scsi_qla_host *vha, response_t *pkt)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\r\nif (unlikely(tgt == NULL)) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe05d,\r\n"qla_target(%d): Response pkt %x received, but no "\r\n"tgt (ha %p)\n", vha->vp_idx, pkt->entry_type, ha);\r\nreturn;\r\n}\r\ntgt->irq_cmd_count++;\r\nswitch (pkt->entry_type) {\r\ncase CTIO_CRC2:\r\ncase CTIO_TYPE7:\r\n{\r\nstruct ctio7_from_24xx *entry = (struct ctio7_from_24xx *)pkt;\r\nqlt_do_ctio_completion(vha, entry->handle,\r\nle16_to_cpu(entry->status)|(pkt->entry_status << 16),\r\nentry);\r\nbreak;\r\n}\r\ncase ACCEPT_TGT_IO_TYPE:\r\n{\r\nstruct atio_from_isp *atio = (struct atio_from_isp *)pkt;\r\nint rc;\r\nif (atio->u.isp2x.status !=\r\n__constant_cpu_to_le16(ATIO_CDB_VALID)) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe05e,\r\n"qla_target(%d): ATIO with error "\r\n"status %x received\n", vha->vp_idx,\r\nle16_to_cpu(atio->u.isp2x.status));\r\nbreak;\r\n}\r\nrc = qlt_chk_qfull_thresh_hold(vha, atio);\r\nif (rc != 0) {\r\ntgt->irq_cmd_count--;\r\nreturn;\r\n}\r\nrc = qlt_handle_cmd_for_atio(vha, atio);\r\nif (unlikely(rc != 0)) {\r\nif (rc == -ESRCH) {\r\n#if 1\r\nqlt_send_busy(vha, atio, 0);\r\n#else\r\nqlt_send_term_exchange(vha, NULL, atio, 1);\r\n#endif\r\n} else {\r\nif (tgt->tgt_stop) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe05f,\r\n"qla_target: Unable to send "\r\n"command to target, sending TERM "\r\n"EXCHANGE for rsp\n");\r\nqlt_send_term_exchange(vha, NULL,\r\natio, 1);\r\n} else {\r\nql_dbg(ql_dbg_tgt, vha, 0xe060,\r\n"qla_target(%d): Unable to send "\r\n"command to target, sending BUSY "\r\n"status\n", vha->vp_idx);\r\nqlt_send_busy(vha, atio, 0);\r\n}\r\n}\r\n}\r\n}\r\nbreak;\r\ncase CONTINUE_TGT_IO_TYPE:\r\n{\r\nstruct ctio_to_2xxx *entry = (struct ctio_to_2xxx *)pkt;\r\nqlt_do_ctio_completion(vha, entry->handle,\r\nle16_to_cpu(entry->status)|(pkt->entry_status << 16),\r\nentry);\r\nbreak;\r\n}\r\ncase CTIO_A64_TYPE:\r\n{\r\nstruct ctio_to_2xxx *entry = (struct ctio_to_2xxx *)pkt;\r\nqlt_do_ctio_completion(vha, entry->handle,\r\nle16_to_cpu(entry->status)|(pkt->entry_status << 16),\r\nentry);\r\nbreak;\r\n}\r\ncase IMMED_NOTIFY_TYPE:\r\nql_dbg(ql_dbg_tgt, vha, 0xe035, "%s", "IMMED_NOTIFY\n");\r\nqlt_handle_imm_notify(vha, (struct imm_ntfy_from_isp *)pkt);\r\nbreak;\r\ncase NOTIFY_ACK_TYPE:\r\nif (tgt->notify_ack_expected > 0) {\r\nstruct nack_to_isp *entry = (struct nack_to_isp *)pkt;\r\nql_dbg(ql_dbg_tgt, vha, 0xe036,\r\n"NOTIFY_ACK seq %08x status %x\n",\r\nle16_to_cpu(entry->u.isp2x.seq_id),\r\nle16_to_cpu(entry->u.isp2x.status));\r\ntgt->notify_ack_expected--;\r\nif (entry->u.isp2x.status !=\r\n__constant_cpu_to_le16(NOTIFY_ACK_SUCCESS)) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe061,\r\n"qla_target(%d): NOTIFY_ACK "\r\n"failed %x\n", vha->vp_idx,\r\nle16_to_cpu(entry->u.isp2x.status));\r\n}\r\n} else {\r\nql_dbg(ql_dbg_tgt, vha, 0xe062,\r\n"qla_target(%d): Unexpected NOTIFY_ACK received\n",\r\nvha->vp_idx);\r\n}\r\nbreak;\r\ncase ABTS_RECV_24XX:\r\nql_dbg(ql_dbg_tgt, vha, 0xe037,\r\n"ABTS_RECV_24XX: instance %d\n", vha->vp_idx);\r\nqlt_24xx_handle_abts(vha, (struct abts_recv_from_24xx *)pkt);\r\nbreak;\r\ncase ABTS_RESP_24XX:\r\nif (tgt->abts_resp_expected > 0) {\r\nstruct abts_resp_from_24xx_fw *entry =\r\n(struct abts_resp_from_24xx_fw *)pkt;\r\nql_dbg(ql_dbg_tgt, vha, 0xe038,\r\n"ABTS_RESP_24XX: compl_status %x\n",\r\nentry->compl_status);\r\ntgt->abts_resp_expected--;\r\nif (le16_to_cpu(entry->compl_status) !=\r\nABTS_RESP_COMPL_SUCCESS) {\r\nif ((entry->error_subcode1 == 0x1E) &&\r\n(entry->error_subcode2 == 0)) {\r\nqlt_24xx_retry_term_exchange(vha,\r\nentry);\r\n} else\r\nql_dbg(ql_dbg_tgt, vha, 0xe063,\r\n"qla_target(%d): ABTS_RESP_24XX "\r\n"failed %x (subcode %x:%x)",\r\nvha->vp_idx, entry->compl_status,\r\nentry->error_subcode1,\r\nentry->error_subcode2);\r\n}\r\n} else {\r\nql_dbg(ql_dbg_tgt, vha, 0xe064,\r\n"qla_target(%d): Unexpected ABTS_RESP_24XX "\r\n"received\n", vha->vp_idx);\r\n}\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_tgt, vha, 0xe065,\r\n"qla_target(%d): Received unknown response pkt "\r\n"type %x\n", vha->vp_idx, pkt->entry_type);\r\nbreak;\r\n}\r\ntgt->irq_cmd_count--;\r\n}\r\nvoid qlt_async_event(uint16_t code, struct scsi_qla_host *vha,\r\nuint16_t *mailbox)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\r\nint login_code;\r\nif (!ha->tgt.tgt_ops)\r\nreturn;\r\nif (unlikely(tgt == NULL)) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe03a,\r\n"ASYNC EVENT %#x, but no tgt (ha %p)\n", code, ha);\r\nreturn;\r\n}\r\nif (((code == MBA_POINT_TO_POINT) || (code == MBA_CHG_IN_CONNECTION)) &&\r\nIS_QLA2100(ha))\r\nreturn;\r\ntgt->irq_cmd_count++;\r\nswitch (code) {\r\ncase MBA_RESET:\r\ncase MBA_SYSTEM_ERR:\r\ncase MBA_REQ_TRANSFER_ERR:\r\ncase MBA_RSP_TRANSFER_ERR:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf03a,\r\n"qla_target(%d): System error async event %#x "\r\n"occurred", vha->vp_idx, code);\r\nbreak;\r\ncase MBA_WAKEUP_THRES:\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nbreak;\r\ncase MBA_LOOP_UP:\r\n{\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf03b,\r\n"qla_target(%d): Async LOOP_UP occurred "\r\n"(m[0]=%x, m[1]=%x, m[2]=%x, m[3]=%x)", vha->vp_idx,\r\nle16_to_cpu(mailbox[0]), le16_to_cpu(mailbox[1]),\r\nle16_to_cpu(mailbox[2]), le16_to_cpu(mailbox[3]));\r\nif (tgt->link_reinit_iocb_pending) {\r\nqlt_send_notify_ack(vha, (void *)&tgt->link_reinit_iocb,\r\n0, 0, 0, 0, 0, 0);\r\ntgt->link_reinit_iocb_pending = 0;\r\n}\r\nbreak;\r\n}\r\ncase MBA_LIP_OCCURRED:\r\ncase MBA_LOOP_DOWN:\r\ncase MBA_LIP_RESET:\r\ncase MBA_RSCN_UPDATE:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf03c,\r\n"qla_target(%d): Async event %#x occurred "\r\n"(m[0]=%x, m[1]=%x, m[2]=%x, m[3]=%x)", vha->vp_idx, code,\r\nle16_to_cpu(mailbox[0]), le16_to_cpu(mailbox[1]),\r\nle16_to_cpu(mailbox[2]), le16_to_cpu(mailbox[3]));\r\nbreak;\r\ncase MBA_PORT_UPDATE:\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf03d,\r\n"qla_target(%d): Port update async event %#x "\r\n"occurred: updating the ports database (m[0]=%x, m[1]=%x, "\r\n"m[2]=%x, m[3]=%x)", vha->vp_idx, code,\r\nle16_to_cpu(mailbox[0]), le16_to_cpu(mailbox[1]),\r\nle16_to_cpu(mailbox[2]), le16_to_cpu(mailbox[3]));\r\nlogin_code = le16_to_cpu(mailbox[2]);\r\nif (login_code == 0x4)\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf03e,\r\n"Async MB 2: Got PLOGI Complete\n");\r\nelse if (login_code == 0x7)\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf03f,\r\n"Async MB 2: Port Logged Out\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ntgt->irq_cmd_count--;\r\n}\r\nstatic fc_port_t *qlt_get_port_database(struct scsi_qla_host *vha,\r\nuint16_t loop_id)\r\n{\r\nfc_port_t *fcport;\r\nint rc;\r\nfcport = kzalloc(sizeof(*fcport), GFP_KERNEL);\r\nif (!fcport) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf06f,\r\n"qla_target(%d): Allocation of tmp FC port failed",\r\nvha->vp_idx);\r\nreturn NULL;\r\n}\r\nfcport->loop_id = loop_id;\r\nrc = qla2x00_get_port_database(vha, fcport, 0);\r\nif (rc != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf070,\r\n"qla_target(%d): Failed to retrieve fcport "\r\n"information -- get_port_database() returned %x "\r\n"(loop_id=0x%04x)", vha->vp_idx, rc, loop_id);\r\nkfree(fcport);\r\nreturn NULL;\r\n}\r\nreturn fcport;\r\n}\r\nstatic struct qla_tgt_sess *qlt_make_local_sess(struct scsi_qla_host *vha,\r\nuint8_t *s_id)\r\n{\r\nstruct qla_tgt_sess *sess = NULL;\r\nfc_port_t *fcport = NULL;\r\nint rc, global_resets;\r\nuint16_t loop_id = 0;\r\nretry:\r\nglobal_resets =\r\natomic_read(&vha->vha_tgt.qla_tgt->tgt_global_resets_count);\r\nrc = qla24xx_get_loop_id(vha, s_id, &loop_id);\r\nif (rc != 0) {\r\nif ((s_id[0] == 0xFF) &&\r\n(s_id[1] == 0xFC)) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf042,\r\n"Unable to find initiator with S_ID %x:%x:%x",\r\ns_id[0], s_id[1], s_id[2]);\r\n} else\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf071,\r\n"qla_target(%d): Unable to find "\r\n"initiator with S_ID %x:%x:%x",\r\nvha->vp_idx, s_id[0], s_id[1],\r\ns_id[2]);\r\nreturn NULL;\r\n}\r\nfcport = qlt_get_port_database(vha, loop_id);\r\nif (!fcport)\r\nreturn NULL;\r\nif (global_resets !=\r\natomic_read(&vha->vha_tgt.qla_tgt->tgt_global_resets_count)) {\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf043,\r\n"qla_target(%d): global reset during session discovery "\r\n"(counter was %d, new %d), retrying", vha->vp_idx,\r\nglobal_resets,\r\natomic_read(&vha->vha_tgt.\r\nqla_tgt->tgt_global_resets_count));\r\ngoto retry;\r\n}\r\nsess = qlt_create_sess(vha, fcport, true);\r\nkfree(fcport);\r\nreturn sess;\r\n}\r\nstatic void qlt_abort_work(struct qla_tgt *tgt,\r\nstruct qla_tgt_sess_work_param *prm)\r\n{\r\nstruct scsi_qla_host *vha = tgt->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt_sess *sess = NULL;\r\nunsigned long flags;\r\nuint32_t be_s_id;\r\nuint8_t s_id[3];\r\nint rc;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nif (tgt->tgt_stop)\r\ngoto out_term;\r\ns_id[0] = prm->abts.fcp_hdr_le.s_id[2];\r\ns_id[1] = prm->abts.fcp_hdr_le.s_id[1];\r\ns_id[2] = prm->abts.fcp_hdr_le.s_id[0];\r\nsess = ha->tgt.tgt_ops->find_sess_by_s_id(vha,\r\n(unsigned char *)&be_s_id);\r\nif (!sess) {\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nmutex_lock(&vha->vha_tgt.tgt_mutex);\r\nsess = qlt_make_local_sess(vha, s_id);\r\nmutex_unlock(&vha->vha_tgt.tgt_mutex);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nif (!sess)\r\ngoto out_term;\r\n} else {\r\nkref_get(&sess->se_sess->sess_kref);\r\n}\r\nif (tgt->tgt_stop)\r\ngoto out_term;\r\nrc = __qlt_24xx_handle_abts(vha, &prm->abts, sess);\r\nif (rc != 0)\r\ngoto out_term;\r\nha->tgt.tgt_ops->put_sess(sess);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn;\r\nout_term:\r\nqlt_24xx_send_abts_resp(vha, &prm->abts, FCP_TMF_REJECTED, false);\r\nif (sess)\r\nha->tgt.tgt_ops->put_sess(sess);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nstatic void qlt_tmr_work(struct qla_tgt *tgt,\r\nstruct qla_tgt_sess_work_param *prm)\r\n{\r\nstruct atio_from_isp *a = &prm->tm_iocb2;\r\nstruct scsi_qla_host *vha = tgt->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt_sess *sess = NULL;\r\nunsigned long flags;\r\nuint8_t *s_id = NULL;\r\nint rc;\r\nuint32_t lun, unpacked_lun;\r\nint lun_size, fn;\r\nvoid *iocb;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nif (tgt->tgt_stop)\r\ngoto out_term;\r\ns_id = prm->tm_iocb2.u.isp24.fcp_hdr.s_id;\r\nsess = ha->tgt.tgt_ops->find_sess_by_s_id(vha, s_id);\r\nif (!sess) {\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nmutex_lock(&vha->vha_tgt.tgt_mutex);\r\nsess = qlt_make_local_sess(vha, s_id);\r\nmutex_unlock(&vha->vha_tgt.tgt_mutex);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nif (!sess)\r\ngoto out_term;\r\n} else {\r\nkref_get(&sess->se_sess->sess_kref);\r\n}\r\niocb = a;\r\nlun = a->u.isp24.fcp_cmnd.lun;\r\nlun_size = sizeof(lun);\r\nfn = a->u.isp24.fcp_cmnd.task_mgmt_flags;\r\nunpacked_lun = scsilun_to_int((struct scsi_lun *)&lun);\r\nrc = qlt_issue_task_mgmt(sess, unpacked_lun, fn, iocb, 0);\r\nif (rc != 0)\r\ngoto out_term;\r\nha->tgt.tgt_ops->put_sess(sess);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn;\r\nout_term:\r\nqlt_send_term_exchange(vha, NULL, &prm->tm_iocb2, 1);\r\nif (sess)\r\nha->tgt.tgt_ops->put_sess(sess);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nstatic void qlt_sess_work_fn(struct work_struct *work)\r\n{\r\nstruct qla_tgt *tgt = container_of(work, struct qla_tgt, sess_work);\r\nstruct scsi_qla_host *vha = tgt->vha;\r\nunsigned long flags;\r\nql_dbg(ql_dbg_tgt_mgt, vha, 0xf000, "Sess work (tgt %p)", tgt);\r\nspin_lock_irqsave(&tgt->sess_work_lock, flags);\r\nwhile (!list_empty(&tgt->sess_works_list)) {\r\nstruct qla_tgt_sess_work_param *prm = list_entry(\r\ntgt->sess_works_list.next, typeof(*prm),\r\nsess_works_list_entry);\r\nlist_del(&prm->sess_works_list_entry);\r\nspin_unlock_irqrestore(&tgt->sess_work_lock, flags);\r\nswitch (prm->type) {\r\ncase QLA_TGT_SESS_WORK_ABORT:\r\nqlt_abort_work(tgt, prm);\r\nbreak;\r\ncase QLA_TGT_SESS_WORK_TM:\r\nqlt_tmr_work(tgt, prm);\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\nbreak;\r\n}\r\nspin_lock_irqsave(&tgt->sess_work_lock, flags);\r\nkfree(prm);\r\n}\r\nspin_unlock_irqrestore(&tgt->sess_work_lock, flags);\r\n}\r\nint qlt_add_target(struct qla_hw_data *ha, struct scsi_qla_host *base_vha)\r\n{\r\nstruct qla_tgt *tgt;\r\nif (!QLA_TGT_MODE_ENABLED())\r\nreturn 0;\r\nif (!IS_TGT_MODE_CAPABLE(ha)) {\r\nql_log(ql_log_warn, base_vha, 0xe070,\r\n"This adapter does not support target mode.\n");\r\nreturn 0;\r\n}\r\nql_dbg(ql_dbg_tgt, base_vha, 0xe03b,\r\n"Registering target for host %ld(%p).\n", base_vha->host_no, ha);\r\nBUG_ON(base_vha->vha_tgt.qla_tgt != NULL);\r\ntgt = kzalloc(sizeof(struct qla_tgt), GFP_KERNEL);\r\nif (!tgt) {\r\nql_dbg(ql_dbg_tgt, base_vha, 0xe066,\r\n"Unable to allocate struct qla_tgt\n");\r\nreturn -ENOMEM;\r\n}\r\nif (!(base_vha->host->hostt->supported_mode & MODE_TARGET))\r\nbase_vha->host->hostt->supported_mode |= MODE_TARGET;\r\ntgt->ha = ha;\r\ntgt->vha = base_vha;\r\ninit_waitqueue_head(&tgt->waitQ);\r\nINIT_LIST_HEAD(&tgt->sess_list);\r\nINIT_LIST_HEAD(&tgt->del_sess_list);\r\nINIT_DELAYED_WORK(&tgt->sess_del_work,\r\n(void (*)(struct work_struct *))qlt_del_sess_work_fn);\r\nspin_lock_init(&tgt->sess_work_lock);\r\nINIT_WORK(&tgt->sess_work, qlt_sess_work_fn);\r\nINIT_LIST_HEAD(&tgt->sess_works_list);\r\nspin_lock_init(&tgt->srr_lock);\r\nINIT_LIST_HEAD(&tgt->srr_ctio_list);\r\nINIT_LIST_HEAD(&tgt->srr_imm_list);\r\nINIT_WORK(&tgt->srr_work, qlt_handle_srr_work);\r\natomic_set(&tgt->tgt_global_resets_count, 0);\r\nbase_vha->vha_tgt.qla_tgt = tgt;\r\nql_dbg(ql_dbg_tgt, base_vha, 0xe067,\r\n"qla_target(%d): using 64 Bit PCI addressing",\r\nbase_vha->vp_idx);\r\ntgt->tgt_enable_64bit_addr = 1;\r\ntgt->sg_tablesize = QLA_TGT_MAX_SG_24XX(base_vha->req->length - 3);\r\ntgt->datasegs_per_cmd = QLA_TGT_DATASEGS_PER_CMD_24XX;\r\ntgt->datasegs_per_cont = QLA_TGT_DATASEGS_PER_CONT_24XX;\r\nif (base_vha->fc_vport)\r\nreturn 0;\r\nmutex_lock(&qla_tgt_mutex);\r\nlist_add_tail(&tgt->tgt_list_entry, &qla_tgt_glist);\r\nmutex_unlock(&qla_tgt_mutex);\r\nreturn 0;\r\n}\r\nint qlt_remove_target(struct qla_hw_data *ha, struct scsi_qla_host *vha)\r\n{\r\nif (!vha->vha_tgt.qla_tgt)\r\nreturn 0;\r\nif (vha->fc_vport) {\r\nqlt_release(vha->vha_tgt.qla_tgt);\r\nreturn 0;\r\n}\r\nqlt_init_term_exchange(vha);\r\nmutex_lock(&qla_tgt_mutex);\r\nlist_del(&vha->vha_tgt.qla_tgt->tgt_list_entry);\r\nmutex_unlock(&qla_tgt_mutex);\r\nql_dbg(ql_dbg_tgt, vha, 0xe03c, "Unregistering target for host %ld(%p)",\r\nvha->host_no, ha);\r\nqlt_release(vha->vha_tgt.qla_tgt);\r\nreturn 0;\r\n}\r\nstatic void qlt_lport_dump(struct scsi_qla_host *vha, u64 wwpn,\r\nunsigned char *b)\r\n{\r\nint i;\r\npr_debug("qla2xxx HW vha->node_name: ");\r\nfor (i = 0; i < WWN_SIZE; i++)\r\npr_debug("%02x ", vha->node_name[i]);\r\npr_debug("\n");\r\npr_debug("qla2xxx HW vha->port_name: ");\r\nfor (i = 0; i < WWN_SIZE; i++)\r\npr_debug("%02x ", vha->port_name[i]);\r\npr_debug("\n");\r\npr_debug("qla2xxx passed configfs WWPN: ");\r\nput_unaligned_be64(wwpn, b);\r\nfor (i = 0; i < WWN_SIZE; i++)\r\npr_debug("%02x ", b[i]);\r\npr_debug("\n");\r\n}\r\nint qlt_lport_register(void *target_lport_ptr, u64 phys_wwpn,\r\nu64 npiv_wwpn, u64 npiv_wwnn,\r\nint (*callback)(struct scsi_qla_host *, void *, u64, u64))\r\n{\r\nstruct qla_tgt *tgt;\r\nstruct scsi_qla_host *vha;\r\nstruct qla_hw_data *ha;\r\nstruct Scsi_Host *host;\r\nunsigned long flags;\r\nint rc;\r\nu8 b[WWN_SIZE];\r\nmutex_lock(&qla_tgt_mutex);\r\nlist_for_each_entry(tgt, &qla_tgt_glist, tgt_list_entry) {\r\nvha = tgt->vha;\r\nha = vha->hw;\r\nhost = vha->host;\r\nif (!host)\r\ncontinue;\r\nif (!(host->hostt->supported_mode & MODE_TARGET))\r\ncontinue;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nif ((!npiv_wwpn || !npiv_wwnn) && host->active_mode & MODE_TARGET) {\r\npr_debug("MODE_TARGET already active on qla2xxx(%d)\n",\r\nhost->host_no);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\ncontinue;\r\n}\r\nif (tgt->tgt_stop) {\r\npr_debug("MODE_TARGET in shutdown on qla2xxx(%d)\n",\r\nhost->host_no);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\ncontinue;\r\n}\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (!scsi_host_get(host)) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe068,\r\n"Unable to scsi_host_get() for"\r\n" qla2xxx scsi_host\n");\r\ncontinue;\r\n}\r\nqlt_lport_dump(vha, phys_wwpn, b);\r\nif (memcmp(vha->port_name, b, WWN_SIZE)) {\r\nscsi_host_put(host);\r\ncontinue;\r\n}\r\nrc = (*callback)(vha, target_lport_ptr, npiv_wwpn, npiv_wwnn);\r\nif (rc != 0)\r\nscsi_host_put(host);\r\nmutex_unlock(&qla_tgt_mutex);\r\nreturn rc;\r\n}\r\nmutex_unlock(&qla_tgt_mutex);\r\nreturn -ENODEV;\r\n}\r\nvoid qlt_lport_deregister(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct Scsi_Host *sh = vha->host;\r\nvha->vha_tgt.target_lport_ptr = NULL;\r\nha->tgt.tgt_ops = NULL;\r\nscsi_host_put(sh);\r\n}\r\nstatic void qlt_set_mode(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nswitch (ql2x_ini_mode) {\r\ncase QLA2XXX_INI_MODE_DISABLED:\r\ncase QLA2XXX_INI_MODE_EXCLUSIVE:\r\nvha->host->active_mode = MODE_TARGET;\r\nbreak;\r\ncase QLA2XXX_INI_MODE_ENABLED:\r\nvha->host->active_mode |= MODE_TARGET;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ha->tgt.ini_mode_force_reverse)\r\nqla_reverse_ini_mode(vha);\r\n}\r\nstatic void qlt_clear_mode(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nswitch (ql2x_ini_mode) {\r\ncase QLA2XXX_INI_MODE_DISABLED:\r\nvha->host->active_mode = MODE_UNKNOWN;\r\nbreak;\r\ncase QLA2XXX_INI_MODE_EXCLUSIVE:\r\nvha->host->active_mode = MODE_INITIATOR;\r\nbreak;\r\ncase QLA2XXX_INI_MODE_ENABLED:\r\nvha->host->active_mode &= ~MODE_TARGET;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ha->tgt.ini_mode_force_reverse)\r\nqla_reverse_ini_mode(vha);\r\n}\r\nvoid\r\nqlt_enable_vha(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\r\nunsigned long flags;\r\nscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\r\nif (!tgt) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe069,\r\n"Unable to locate qla_tgt pointer from"\r\n" struct qla_hw_data\n");\r\ndump_stack();\r\nreturn;\r\n}\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\ntgt->tgt_stopped = 0;\r\nqlt_set_mode(vha);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nif (vha->vp_idx) {\r\nqla24xx_disable_vp(vha);\r\nqla24xx_enable_vp(vha);\r\n} else {\r\nset_bit(ISP_ABORT_NEEDED, &base_vha->dpc_flags);\r\nqla2xxx_wake_dpc(base_vha);\r\nqla2x00_wait_for_hba_online(base_vha);\r\n}\r\n}\r\nstatic void qlt_disable_vha(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct qla_tgt *tgt = vha->vha_tgt.qla_tgt;\r\nunsigned long flags;\r\nif (!tgt) {\r\nql_dbg(ql_dbg_tgt, vha, 0xe06a,\r\n"Unable to locate qla_tgt pointer from"\r\n" struct qla_hw_data\n");\r\ndump_stack();\r\nreturn;\r\n}\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nqlt_clear_mode(vha);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\nqla2x00_wait_for_hba_online(vha);\r\n}\r\nvoid\r\nqlt_vport_create(struct scsi_qla_host *vha, struct qla_hw_data *ha)\r\n{\r\nif (!qla_tgt_mode_enabled(vha))\r\nreturn;\r\nvha->vha_tgt.qla_tgt = NULL;\r\nmutex_init(&vha->vha_tgt.tgt_mutex);\r\nmutex_init(&vha->vha_tgt.tgt_host_action_mutex);\r\nqlt_clear_mode(vha);\r\nha->tgt.atio_q_length = ATIO_ENTRY_CNT_24XX;\r\nqlt_add_target(ha, vha);\r\n}\r\nvoid\r\nqlt_rff_id(struct scsi_qla_host *vha, struct ct_sns_req *ct_req)\r\n{\r\nif (qla_tgt_mode_enabled(vha)) {\r\nif (qla_ini_mode_enabled(vha))\r\nct_req->req.rff_id.fc4_feature = BIT_0 | BIT_1;\r\nelse\r\nct_req->req.rff_id.fc4_feature = BIT_0;\r\n} else if (qla_ini_mode_enabled(vha)) {\r\nct_req->req.rff_id.fc4_feature = BIT_1;\r\n}\r\n}\r\nvoid\r\nqlt_init_atio_q_entries(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint16_t cnt;\r\nstruct atio_from_isp *pkt = (struct atio_from_isp *)ha->tgt.atio_ring;\r\nif (!qla_tgt_mode_enabled(vha))\r\nreturn;\r\nfor (cnt = 0; cnt < ha->tgt.atio_q_length; cnt++) {\r\npkt->u.raw.signature = ATIO_PROCESSED;\r\npkt++;\r\n}\r\n}\r\nvoid\r\nqlt_24xx_process_atio_queue(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct atio_from_isp *pkt;\r\nint cnt, i;\r\nif (!vha->flags.online)\r\nreturn;\r\nwhile (ha->tgt.atio_ring_ptr->signature != ATIO_PROCESSED) {\r\npkt = (struct atio_from_isp *)ha->tgt.atio_ring_ptr;\r\ncnt = pkt->u.raw.entry_count;\r\nqlt_24xx_atio_pkt_all_vps(vha, (struct atio_from_isp *)pkt);\r\nfor (i = 0; i < cnt; i++) {\r\nha->tgt.atio_ring_index++;\r\nif (ha->tgt.atio_ring_index == ha->tgt.atio_q_length) {\r\nha->tgt.atio_ring_index = 0;\r\nha->tgt.atio_ring_ptr = ha->tgt.atio_ring;\r\n} else\r\nha->tgt.atio_ring_ptr++;\r\npkt->u.raw.signature = ATIO_PROCESSED;\r\npkt = (struct atio_from_isp *)ha->tgt.atio_ring_ptr;\r\n}\r\nwmb();\r\n}\r\nWRT_REG_DWORD(ISP_ATIO_Q_OUT(vha), ha->tgt.atio_ring_index);\r\n}\r\nvoid\r\nqlt_24xx_config_rings(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!QLA_TGT_MODE_ENABLED())\r\nreturn;\r\nWRT_REG_DWORD(ISP_ATIO_Q_IN(vha), 0);\r\nWRT_REG_DWORD(ISP_ATIO_Q_OUT(vha), 0);\r\nRD_REG_DWORD(ISP_ATIO_Q_OUT(vha));\r\nif (IS_ATIO_MSIX_CAPABLE(ha)) {\r\nstruct qla_msix_entry *msix = &ha->msix_entries[2];\r\nstruct init_cb_24xx *icb = (struct init_cb_24xx *)ha->init_cb;\r\nicb->msix_atio = cpu_to_le16(msix->entry);\r\nql_dbg(ql_dbg_init, vha, 0xf072,\r\n"Registering ICB vector 0x%x for atio que.\n",\r\nmsix->entry);\r\n}\r\n}\r\nvoid\r\nqlt_24xx_config_nvram_stage1(struct scsi_qla_host *vha, struct nvram_24xx *nv)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (qla_tgt_mode_enabled(vha)) {\r\nif (!ha->tgt.saved_set) {\r\nha->tgt.saved_exchange_count = nv->exchange_count;\r\nha->tgt.saved_firmware_options_1 =\r\nnv->firmware_options_1;\r\nha->tgt.saved_firmware_options_2 =\r\nnv->firmware_options_2;\r\nha->tgt.saved_firmware_options_3 =\r\nnv->firmware_options_3;\r\nha->tgt.saved_set = 1;\r\n}\r\nnv->exchange_count = __constant_cpu_to_le16(0xFFFF);\r\nnv->firmware_options_1 |= __constant_cpu_to_le32(BIT_4);\r\nif (!qla_ini_mode_enabled(vha))\r\nnv->firmware_options_1 |= __constant_cpu_to_le32(BIT_5);\r\nnv->firmware_options_1 &= __constant_cpu_to_le32(~BIT_13);\r\nnv->firmware_options_1 &= __constant_cpu_to_le32(~BIT_9);\r\nif (ql2xtgt_tape_enable)\r\nnv->firmware_options_2 |= cpu_to_le32(BIT_12);\r\nelse\r\nnv->firmware_options_2 &= cpu_to_le32(~BIT_12);\r\nnv->host_p &= __constant_cpu_to_le32(~BIT_10);\r\nnv->firmware_options_2 |= __constant_cpu_to_le32(BIT_14);\r\n} else {\r\nif (ha->tgt.saved_set) {\r\nnv->exchange_count = ha->tgt.saved_exchange_count;\r\nnv->firmware_options_1 =\r\nha->tgt.saved_firmware_options_1;\r\nnv->firmware_options_2 =\r\nha->tgt.saved_firmware_options_2;\r\nnv->firmware_options_3 =\r\nha->tgt.saved_firmware_options_3;\r\n}\r\nreturn;\r\n}\r\nnv->firmware_options_3 |= BIT_6|BIT_9;\r\nif (ha->tgt.enable_class_2) {\r\nif (vha->flags.init_done)\r\nfc_host_supported_classes(vha->host) =\r\nFC_COS_CLASS2 | FC_COS_CLASS3;\r\nnv->firmware_options_2 |= __constant_cpu_to_le32(BIT_8);\r\n} else {\r\nif (vha->flags.init_done)\r\nfc_host_supported_classes(vha->host) = FC_COS_CLASS3;\r\nnv->firmware_options_2 &= ~__constant_cpu_to_le32(BIT_8);\r\n}\r\n}\r\nvoid\r\nqlt_24xx_config_nvram_stage2(struct scsi_qla_host *vha,\r\nstruct init_cb_24xx *icb)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (ha->tgt.node_name_set) {\r\nmemcpy(icb->node_name, ha->tgt.tgt_node_name, WWN_SIZE);\r\nicb->firmware_options_1 |= __constant_cpu_to_le32(BIT_14);\r\n}\r\n}\r\nvoid\r\nqlt_81xx_config_nvram_stage1(struct scsi_qla_host *vha, struct nvram_81xx *nv)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!QLA_TGT_MODE_ENABLED())\r\nreturn;\r\nif (qla_tgt_mode_enabled(vha)) {\r\nif (!ha->tgt.saved_set) {\r\nha->tgt.saved_exchange_count = nv->exchange_count;\r\nha->tgt.saved_firmware_options_1 =\r\nnv->firmware_options_1;\r\nha->tgt.saved_firmware_options_2 =\r\nnv->firmware_options_2;\r\nha->tgt.saved_firmware_options_3 =\r\nnv->firmware_options_3;\r\nha->tgt.saved_set = 1;\r\n}\r\nnv->exchange_count = __constant_cpu_to_le16(0xFFFF);\r\nnv->firmware_options_1 |= __constant_cpu_to_le32(BIT_4);\r\nif (!qla_ini_mode_enabled(vha))\r\nnv->firmware_options_1 |=\r\n__constant_cpu_to_le32(BIT_5);\r\nnv->firmware_options_1 &= __constant_cpu_to_le32(~BIT_13);\r\nnv->firmware_options_1 &= __constant_cpu_to_le32(~BIT_9);\r\nif (ql2xtgt_tape_enable)\r\nnv->firmware_options_2 |= cpu_to_le32(BIT_12);\r\nelse\r\nnv->firmware_options_2 &= cpu_to_le32(~BIT_12);\r\nnv->host_p &= __constant_cpu_to_le32(~BIT_10);\r\nnv->firmware_options_2 |= __constant_cpu_to_le32(BIT_14);\r\n} else {\r\nif (ha->tgt.saved_set) {\r\nnv->exchange_count = ha->tgt.saved_exchange_count;\r\nnv->firmware_options_1 =\r\nha->tgt.saved_firmware_options_1;\r\nnv->firmware_options_2 =\r\nha->tgt.saved_firmware_options_2;\r\nnv->firmware_options_3 =\r\nha->tgt.saved_firmware_options_3;\r\n}\r\nreturn;\r\n}\r\nnv->firmware_options_3 |= BIT_6|BIT_9;\r\nif (ha->tgt.enable_class_2) {\r\nif (vha->flags.init_done)\r\nfc_host_supported_classes(vha->host) =\r\nFC_COS_CLASS2 | FC_COS_CLASS3;\r\nnv->firmware_options_2 |= __constant_cpu_to_le32(BIT_8);\r\n} else {\r\nif (vha->flags.init_done)\r\nfc_host_supported_classes(vha->host) = FC_COS_CLASS3;\r\nnv->firmware_options_2 &= ~__constant_cpu_to_le32(BIT_8);\r\n}\r\n}\r\nvoid\r\nqlt_81xx_config_nvram_stage2(struct scsi_qla_host *vha,\r\nstruct init_cb_81xx *icb)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (!QLA_TGT_MODE_ENABLED())\r\nreturn;\r\nif (ha->tgt.node_name_set) {\r\nmemcpy(icb->node_name, ha->tgt.tgt_node_name, WWN_SIZE);\r\nicb->firmware_options_1 |= __constant_cpu_to_le32(BIT_14);\r\n}\r\n}\r\nvoid\r\nqlt_83xx_iospace_config(struct qla_hw_data *ha)\r\n{\r\nif (!QLA_TGT_MODE_ENABLED())\r\nreturn;\r\nha->msix_count += 1;\r\n}\r\nint\r\nqlt_24xx_process_response_error(struct scsi_qla_host *vha,\r\nstruct sts_entry_24xx *pkt)\r\n{\r\nswitch (pkt->entry_type) {\r\ncase ABTS_RECV_24XX:\r\ncase ABTS_RESP_24XX:\r\ncase CTIO_TYPE7:\r\ncase NOTIFY_ACK_TYPE:\r\ncase CTIO_CRC2:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nvoid\r\nqlt_modify_vp_config(struct scsi_qla_host *vha,\r\nstruct vp_config_entry_24xx *vpmod)\r\n{\r\nif (qla_tgt_mode_enabled(vha))\r\nvpmod->options_idx1 &= ~BIT_5;\r\nif (!qla_ini_mode_enabled(vha))\r\nvpmod->options_idx1 &= ~BIT_4;\r\n}\r\nvoid\r\nqlt_probe_one_stage1(struct scsi_qla_host *base_vha, struct qla_hw_data *ha)\r\n{\r\nif (!QLA_TGT_MODE_ENABLED())\r\nreturn;\r\nif (ha->mqenable || IS_QLA83XX(ha)) {\r\nISP_ATIO_Q_IN(base_vha) = &ha->mqiobase->isp25mq.atio_q_in;\r\nISP_ATIO_Q_OUT(base_vha) = &ha->mqiobase->isp25mq.atio_q_out;\r\n} else {\r\nISP_ATIO_Q_IN(base_vha) = &ha->iobase->isp24.atio_q_in;\r\nISP_ATIO_Q_OUT(base_vha) = &ha->iobase->isp24.atio_q_out;\r\n}\r\nmutex_init(&base_vha->vha_tgt.tgt_mutex);\r\nmutex_init(&base_vha->vha_tgt.tgt_host_action_mutex);\r\nqlt_clear_mode(base_vha);\r\n}\r\nirqreturn_t\r\nqla83xx_msix_atio_q(int irq, void *dev_id)\r\n{\r\nstruct rsp_que *rsp;\r\nscsi_qla_host_t *vha;\r\nstruct qla_hw_data *ha;\r\nunsigned long flags;\r\nrsp = (struct rsp_que *) dev_id;\r\nha = rsp->hw;\r\nvha = pci_get_drvdata(ha->pdev);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nqlt_24xx_process_atio_queue(vha);\r\nqla24xx_process_response_queue(vha, rsp);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nint\r\nqlt_mem_alloc(struct qla_hw_data *ha)\r\n{\r\nif (!QLA_TGT_MODE_ENABLED())\r\nreturn 0;\r\nha->tgt.tgt_vp_map = kzalloc(sizeof(struct qla_tgt_vp_map) *\r\nMAX_MULTI_ID_FABRIC, GFP_KERNEL);\r\nif (!ha->tgt.tgt_vp_map)\r\nreturn -ENOMEM;\r\nha->tgt.atio_ring = dma_alloc_coherent(&ha->pdev->dev,\r\n(ha->tgt.atio_q_length + 1) * sizeof(struct atio_from_isp),\r\n&ha->tgt.atio_dma, GFP_KERNEL);\r\nif (!ha->tgt.atio_ring) {\r\nkfree(ha->tgt.tgt_vp_map);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nqlt_mem_free(struct qla_hw_data *ha)\r\n{\r\nif (!QLA_TGT_MODE_ENABLED())\r\nreturn;\r\nif (ha->tgt.atio_ring) {\r\ndma_free_coherent(&ha->pdev->dev, (ha->tgt.atio_q_length + 1) *\r\nsizeof(struct atio_from_isp), ha->tgt.atio_ring,\r\nha->tgt.atio_dma);\r\n}\r\nkfree(ha->tgt.tgt_vp_map);\r\n}\r\nvoid\r\nqlt_update_vp_map(struct scsi_qla_host *vha, int cmd)\r\n{\r\nif (!QLA_TGT_MODE_ENABLED())\r\nreturn;\r\nswitch (cmd) {\r\ncase SET_VP_IDX:\r\nvha->hw->tgt.tgt_vp_map[vha->vp_idx].vha = vha;\r\nbreak;\r\ncase SET_AL_PA:\r\nvha->hw->tgt.tgt_vp_map[vha->d_id.b.al_pa].idx = vha->vp_idx;\r\nbreak;\r\ncase RESET_VP_IDX:\r\nvha->hw->tgt.tgt_vp_map[vha->vp_idx].vha = NULL;\r\nbreak;\r\ncase RESET_AL_PA:\r\nvha->hw->tgt.tgt_vp_map[vha->d_id.b.al_pa].idx = 0;\r\nbreak;\r\n}\r\n}\r\nstatic int __init qlt_parse_ini_mode(void)\r\n{\r\nif (strcasecmp(qlini_mode, QLA2XXX_INI_MODE_STR_EXCLUSIVE) == 0)\r\nql2x_ini_mode = QLA2XXX_INI_MODE_EXCLUSIVE;\r\nelse if (strcasecmp(qlini_mode, QLA2XXX_INI_MODE_STR_DISABLED) == 0)\r\nql2x_ini_mode = QLA2XXX_INI_MODE_DISABLED;\r\nelse if (strcasecmp(qlini_mode, QLA2XXX_INI_MODE_STR_ENABLED) == 0)\r\nql2x_ini_mode = QLA2XXX_INI_MODE_ENABLED;\r\nelse\r\nreturn false;\r\nreturn true;\r\n}\r\nint __init qlt_init(void)\r\n{\r\nint ret;\r\nif (!qlt_parse_ini_mode()) {\r\nql_log(ql_log_fatal, NULL, 0xe06b,\r\n"qlt_parse_ini_mode() failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (!QLA_TGT_MODE_ENABLED())\r\nreturn 0;\r\nqla_tgt_mgmt_cmd_cachep = kmem_cache_create("qla_tgt_mgmt_cmd_cachep",\r\nsizeof(struct qla_tgt_mgmt_cmd), __alignof__(struct\r\nqla_tgt_mgmt_cmd), 0, NULL);\r\nif (!qla_tgt_mgmt_cmd_cachep) {\r\nql_log(ql_log_fatal, NULL, 0xe06d,\r\n"kmem_cache_create for qla_tgt_mgmt_cmd_cachep failed\n");\r\nreturn -ENOMEM;\r\n}\r\nqla_tgt_mgmt_cmd_mempool = mempool_create(25, mempool_alloc_slab,\r\nmempool_free_slab, qla_tgt_mgmt_cmd_cachep);\r\nif (!qla_tgt_mgmt_cmd_mempool) {\r\nql_log(ql_log_fatal, NULL, 0xe06e,\r\n"mempool_create for qla_tgt_mgmt_cmd_mempool failed\n");\r\nret = -ENOMEM;\r\ngoto out_mgmt_cmd_cachep;\r\n}\r\nqla_tgt_wq = alloc_workqueue("qla_tgt_wq", 0, 0);\r\nif (!qla_tgt_wq) {\r\nql_log(ql_log_fatal, NULL, 0xe06f,\r\n"alloc_workqueue for qla_tgt_wq failed\n");\r\nret = -ENOMEM;\r\ngoto out_cmd_mempool;\r\n}\r\nreturn (ql2x_ini_mode == QLA2XXX_INI_MODE_DISABLED) ? 1 : 0;\r\nout_cmd_mempool:\r\nmempool_destroy(qla_tgt_mgmt_cmd_mempool);\r\nout_mgmt_cmd_cachep:\r\nkmem_cache_destroy(qla_tgt_mgmt_cmd_cachep);\r\nreturn ret;\r\n}\r\nvoid qlt_exit(void)\r\n{\r\nif (!QLA_TGT_MODE_ENABLED())\r\nreturn;\r\ndestroy_workqueue(qla_tgt_wq);\r\nmempool_destroy(qla_tgt_mgmt_cmd_mempool);\r\nkmem_cache_destroy(qla_tgt_mgmt_cmd_cachep);\r\n}
