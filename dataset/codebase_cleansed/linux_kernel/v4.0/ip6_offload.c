static int ipv6_gso_pull_exthdrs(struct sk_buff *skb, int proto)\r\n{\r\nconst struct net_offload *ops = NULL;\r\nfor (;;) {\r\nstruct ipv6_opt_hdr *opth;\r\nint len;\r\nif (proto != NEXTHDR_HOP) {\r\nops = rcu_dereference(inet6_offloads[proto]);\r\nif (unlikely(!ops))\r\nbreak;\r\nif (!(ops->flags & INET6_PROTO_GSO_EXTHDR))\r\nbreak;\r\n}\r\nif (unlikely(!pskb_may_pull(skb, 8)))\r\nbreak;\r\nopth = (void *)skb->data;\r\nlen = ipv6_optlen(opth);\r\nif (unlikely(!pskb_may_pull(skb, len)))\r\nbreak;\r\nopth = (void *)skb->data;\r\nproto = opth->nexthdr;\r\n__skb_pull(skb, len);\r\n}\r\nreturn proto;\r\n}\r\nstatic struct sk_buff *ipv6_gso_segment(struct sk_buff *skb,\r\nnetdev_features_t features)\r\n{\r\nstruct sk_buff *segs = ERR_PTR(-EINVAL);\r\nstruct ipv6hdr *ipv6h;\r\nconst struct net_offload *ops;\r\nint proto;\r\nstruct frag_hdr *fptr;\r\nunsigned int unfrag_ip6hlen;\r\nu8 *prevhdr;\r\nint offset = 0;\r\nbool encap, udpfrag;\r\nint nhoff;\r\nif (unlikely(skb_shinfo(skb)->gso_type &\r\n~(SKB_GSO_TCPV4 |\r\nSKB_GSO_UDP |\r\nSKB_GSO_DODGY |\r\nSKB_GSO_TCP_ECN |\r\nSKB_GSO_GRE |\r\nSKB_GSO_GRE_CSUM |\r\nSKB_GSO_IPIP |\r\nSKB_GSO_SIT |\r\nSKB_GSO_UDP_TUNNEL |\r\nSKB_GSO_UDP_TUNNEL_CSUM |\r\nSKB_GSO_TUNNEL_REMCSUM |\r\nSKB_GSO_TCPV6 |\r\n0)))\r\ngoto out;\r\nskb_reset_network_header(skb);\r\nnhoff = skb_network_header(skb) - skb_mac_header(skb);\r\nif (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))\r\ngoto out;\r\nencap = SKB_GSO_CB(skb)->encap_level > 0;\r\nif (encap)\r\nfeatures &= skb->dev->hw_enc_features;\r\nSKB_GSO_CB(skb)->encap_level += sizeof(*ipv6h);\r\nipv6h = ipv6_hdr(skb);\r\n__skb_pull(skb, sizeof(*ipv6h));\r\nsegs = ERR_PTR(-EPROTONOSUPPORT);\r\nproto = ipv6_gso_pull_exthdrs(skb, ipv6h->nexthdr);\r\nif (skb->encapsulation &&\r\nskb_shinfo(skb)->gso_type & (SKB_GSO_SIT|SKB_GSO_IPIP))\r\nudpfrag = proto == IPPROTO_UDP && encap;\r\nelse\r\nudpfrag = proto == IPPROTO_UDP && !skb->encapsulation;\r\nops = rcu_dereference(inet6_offloads[proto]);\r\nif (likely(ops && ops->callbacks.gso_segment)) {\r\nskb_reset_transport_header(skb);\r\nsegs = ops->callbacks.gso_segment(skb, features);\r\n}\r\nif (IS_ERR(segs))\r\ngoto out;\r\nfor (skb = segs; skb; skb = skb->next) {\r\nipv6h = (struct ipv6hdr *)(skb_mac_header(skb) + nhoff);\r\nipv6h->payload_len = htons(skb->len - nhoff - sizeof(*ipv6h));\r\nskb->network_header = (u8 *)ipv6h - skb->head;\r\nif (udpfrag) {\r\nunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\r\nfptr = (struct frag_hdr *)((u8 *)ipv6h + unfrag_ip6hlen);\r\nfptr->frag_off = htons(offset);\r\nif (skb->next != NULL)\r\nfptr->frag_off |= htons(IP6_MF);\r\noffset += (ntohs(ipv6h->payload_len) -\r\nsizeof(struct frag_hdr));\r\n}\r\nif (encap)\r\nskb_reset_inner_headers(skb);\r\n}\r\nout:\r\nreturn segs;\r\n}\r\nstatic int ipv6_exthdrs_len(struct ipv6hdr *iph,\r\nconst struct net_offload **opps)\r\n{\r\nstruct ipv6_opt_hdr *opth = (void *)iph;\r\nint len = 0, proto, optlen = sizeof(*iph);\r\nproto = iph->nexthdr;\r\nfor (;;) {\r\nif (proto != NEXTHDR_HOP) {\r\n*opps = rcu_dereference(inet6_offloads[proto]);\r\nif (unlikely(!(*opps)))\r\nbreak;\r\nif (!((*opps)->flags & INET6_PROTO_GSO_EXTHDR))\r\nbreak;\r\n}\r\nopth = (void *)opth + optlen;\r\noptlen = ipv6_optlen(opth);\r\nlen += optlen;\r\nproto = opth->nexthdr;\r\n}\r\nreturn len;\r\n}\r\nstatic struct sk_buff **ipv6_gro_receive(struct sk_buff **head,\r\nstruct sk_buff *skb)\r\n{\r\nconst struct net_offload *ops;\r\nstruct sk_buff **pp = NULL;\r\nstruct sk_buff *p;\r\nstruct ipv6hdr *iph;\r\nunsigned int nlen;\r\nunsigned int hlen;\r\nunsigned int off;\r\nu16 flush = 1;\r\nint proto;\r\noff = skb_gro_offset(skb);\r\nhlen = off + sizeof(*iph);\r\niph = skb_gro_header_fast(skb, off);\r\nif (skb_gro_header_hard(skb, hlen)) {\r\niph = skb_gro_header_slow(skb, hlen, off);\r\nif (unlikely(!iph))\r\ngoto out;\r\n}\r\nskb_set_network_header(skb, off);\r\nskb_gro_pull(skb, sizeof(*iph));\r\nskb_set_transport_header(skb, skb_gro_offset(skb));\r\nflush += ntohs(iph->payload_len) != skb_gro_len(skb);\r\nrcu_read_lock();\r\nproto = iph->nexthdr;\r\nops = rcu_dereference(inet6_offloads[proto]);\r\nif (!ops || !ops->callbacks.gro_receive) {\r\n__pskb_pull(skb, skb_gro_offset(skb));\r\nproto = ipv6_gso_pull_exthdrs(skb, proto);\r\nskb_gro_pull(skb, -skb_transport_offset(skb));\r\nskb_reset_transport_header(skb);\r\n__skb_push(skb, skb_gro_offset(skb));\r\nops = rcu_dereference(inet6_offloads[proto]);\r\nif (!ops || !ops->callbacks.gro_receive)\r\ngoto out_unlock;\r\niph = ipv6_hdr(skb);\r\n}\r\nNAPI_GRO_CB(skb)->proto = proto;\r\nflush--;\r\nnlen = skb_network_header_len(skb);\r\nfor (p = *head; p; p = p->next) {\r\nconst struct ipv6hdr *iph2;\r\n__be32 first_word;\r\nif (!NAPI_GRO_CB(p)->same_flow)\r\ncontinue;\r\niph2 = (struct ipv6hdr *)(p->data + off);\r\nfirst_word = *(__be32 *)iph ^ *(__be32 *)iph2;\r\nif ((first_word & htonl(0xF00FFFFF)) ||\r\nmemcmp(&iph->nexthdr, &iph2->nexthdr,\r\nnlen - offsetof(struct ipv6hdr, nexthdr))) {\r\nNAPI_GRO_CB(p)->same_flow = 0;\r\ncontinue;\r\n}\r\nNAPI_GRO_CB(p)->flush |= !!(first_word & htonl(0x0FF00000));\r\nNAPI_GRO_CB(p)->flush |= flush;\r\nNAPI_GRO_CB(p)->flush_id = 0;\r\n}\r\nNAPI_GRO_CB(skb)->flush |= flush;\r\nskb_gro_postpull_rcsum(skb, iph, nlen);\r\npp = ops->callbacks.gro_receive(head, skb);\r\nout_unlock:\r\nrcu_read_unlock();\r\nout:\r\nNAPI_GRO_CB(skb)->flush |= flush;\r\nreturn pp;\r\n}\r\nstatic int ipv6_gro_complete(struct sk_buff *skb, int nhoff)\r\n{\r\nconst struct net_offload *ops;\r\nstruct ipv6hdr *iph = (struct ipv6hdr *)(skb->data + nhoff);\r\nint err = -ENOSYS;\r\niph->payload_len = htons(skb->len - nhoff - sizeof(*iph));\r\nrcu_read_lock();\r\nnhoff += sizeof(*iph) + ipv6_exthdrs_len(iph, &ops);\r\nif (WARN_ON(!ops || !ops->callbacks.gro_complete))\r\ngoto out_unlock;\r\nerr = ops->callbacks.gro_complete(skb, nhoff);\r\nout_unlock:\r\nrcu_read_unlock();\r\nreturn err;\r\n}\r\nstatic int __init ipv6_offload_init(void)\r\n{\r\nif (tcpv6_offload_init() < 0)\r\npr_crit("%s: Cannot add TCP protocol offload\n", __func__);\r\nif (udp_offload_init() < 0)\r\npr_crit("%s: Cannot add UDP protocol offload\n", __func__);\r\nif (ipv6_exthdrs_offload_init() < 0)\r\npr_crit("%s: Cannot add EXTHDRS protocol offload\n", __func__);\r\ndev_add_offload(&ipv6_packet_offload);\r\ninet_add_offload(&sit_offload, IPPROTO_IPV6);\r\nreturn 0;\r\n}
