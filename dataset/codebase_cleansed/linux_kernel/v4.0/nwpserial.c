static void wait_for_bits(struct nwpserial_port *up, int bits)\r\n{\r\nunsigned int status, tmout = 10000;\r\ndo {\r\nstatus = dcr_read(up->dcr_host, UART_LSR);\r\nif (--tmout == 0)\r\nbreak;\r\nudelay(1);\r\n} while ((status & bits) != bits);\r\n}\r\nstatic void nwpserial_console_putchar(struct uart_port *port, int c)\r\n{\r\nstruct nwpserial_port *up;\r\nup = container_of(port, struct nwpserial_port, port);\r\nwait_for_bits(up, UART_LSR_THRE);\r\ndcr_write(up->dcr_host, UART_TX, c);\r\nup->port.icount.tx++;\r\n}\r\nstatic void\r\nnwpserial_console_write(struct console *co, const char *s, unsigned int count)\r\n{\r\nstruct nwpserial_port *up = &nwpserial_ports[co->index];\r\nunsigned long flags;\r\nint locked = 1;\r\nif (oops_in_progress)\r\nlocked = spin_trylock_irqsave(&up->port.lock, flags);\r\nelse\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nup->ier = dcr_read(up->dcr_host, UART_IER);\r\ndcr_write(up->dcr_host, UART_IER, up->ier & ~UART_IER_RDI);\r\nuart_console_write(&up->port, s, count, nwpserial_console_putchar);\r\nwhile ((dcr_read(up->dcr_host, UART_LSR) & UART_LSR_THRE) == 0)\r\ncpu_relax();\r\ndcr_write(up->dcr_host, UART_IER, up->ier);\r\nif (locked)\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\n}\r\nstatic int nwpserial_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void nwpserial_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic void nwpserial_config_port(struct uart_port *port, int flags)\r\n{\r\nport->type = PORT_NWPSERIAL;\r\n}\r\nstatic irqreturn_t nwpserial_interrupt(int irq, void *dev_id)\r\n{\r\nstruct nwpserial_port *up = dev_id;\r\nstruct tty_port *port = &up->port.state->port;\r\nirqreturn_t ret;\r\nunsigned int iir;\r\nunsigned char ch;\r\nspin_lock(&up->port.lock);\r\niir = dcr_read(up->dcr_host, UART_IIR);\r\nif (!iir) {\r\nret = IRQ_NONE;\r\ngoto out;\r\n}\r\ndo {\r\nup->port.icount.rx++;\r\nch = dcr_read(up->dcr_host, UART_RX);\r\nif (up->port.ignore_status_mask != NWPSERIAL_STATUS_RXVALID)\r\ntty_insert_flip_char(port, ch, TTY_NORMAL);\r\n} while (dcr_read(up->dcr_host, UART_LSR) & UART_LSR_DR);\r\nspin_unlock(&up->port.lock);\r\ntty_flip_buffer_push(port);\r\nspin_lock(&up->port.lock);\r\nret = IRQ_HANDLED;\r\ndcr_write(up->dcr_host, UART_IIR, 1);\r\nout:\r\nspin_unlock(&up->port.lock);\r\nreturn ret;\r\n}\r\nstatic int nwpserial_startup(struct uart_port *port)\r\n{\r\nstruct nwpserial_port *up;\r\nint err;\r\nup = container_of(port, struct nwpserial_port, port);\r\nup->mcr = dcr_read(up->dcr_host, UART_MCR) & ~UART_MCR_AFE;\r\ndcr_write(up->dcr_host, UART_MCR, up->mcr);\r\nerr = request_irq(up->port.irq, nwpserial_interrupt,\r\nIRQF_SHARED, "nwpserial", up);\r\nif (err)\r\nreturn err;\r\nup->ier = UART_IER_RDI;\r\ndcr_write(up->dcr_host, UART_IER, up->ier);\r\nup->port.ignore_status_mask &= ~NWPSERIAL_STATUS_RXVALID;\r\nreturn 0;\r\n}\r\nstatic void nwpserial_shutdown(struct uart_port *port)\r\n{\r\nstruct nwpserial_port *up;\r\nup = container_of(port, struct nwpserial_port, port);\r\nup->port.ignore_status_mask |= NWPSERIAL_STATUS_RXVALID;\r\nup->ier = 0;\r\ndcr_write(up->dcr_host, UART_IER, up->ier);\r\nfree_irq(up->port.irq, up);\r\n}\r\nstatic int nwpserial_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic const char *nwpserial_type(struct uart_port *port)\r\n{\r\nreturn port->type == PORT_NWPSERIAL ? "nwpserial" : NULL;\r\n}\r\nstatic void nwpserial_set_termios(struct uart_port *port,\r\nstruct ktermios *termios, struct ktermios *old)\r\n{\r\nstruct nwpserial_port *up;\r\nup = container_of(port, struct nwpserial_port, port);\r\nup->port.read_status_mask = NWPSERIAL_STATUS_RXVALID\r\n| NWPSERIAL_STATUS_TXFULL;\r\nup->port.ignore_status_mask = 0;\r\nif ((termios->c_cflag & CREAD) == 0)\r\nup->port.ignore_status_mask |= NWPSERIAL_STATUS_RXVALID;\r\nif (old)\r\ntty_termios_copy_hw(termios, old);\r\n}\r\nstatic void nwpserial_break_ctl(struct uart_port *port, int ctl)\r\n{\r\n}\r\nstatic void nwpserial_stop_rx(struct uart_port *port)\r\n{\r\nstruct nwpserial_port *up;\r\nup = container_of(port, struct nwpserial_port, port);\r\nup->port.ignore_status_mask = NWPSERIAL_STATUS_RXVALID;\r\n}\r\nstatic void nwpserial_putchar(struct nwpserial_port *up, unsigned char c)\r\n{\r\nwait_for_bits(up, UART_LSR_THRE);\r\ndcr_write(up->dcr_host, UART_TX, c);\r\nup->port.icount.tx++;\r\n}\r\nstatic void nwpserial_start_tx(struct uart_port *port)\r\n{\r\nstruct nwpserial_port *up;\r\nstruct circ_buf *xmit;\r\nup = container_of(port, struct nwpserial_port, port);\r\nxmit = &up->port.state->xmit;\r\nif (port->x_char) {\r\nnwpserial_putchar(up, up->port.x_char);\r\nport->x_char = 0;\r\n}\r\nwhile (!(uart_circ_empty(xmit) || uart_tx_stopped(&up->port))) {\r\nnwpserial_putchar(up, xmit->buf[xmit->tail]);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE-1);\r\n}\r\n}\r\nstatic unsigned int nwpserial_get_mctrl(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void nwpserial_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\n}\r\nstatic void nwpserial_stop_tx(struct uart_port *port)\r\n{\r\n}\r\nstatic unsigned int nwpserial_tx_empty(struct uart_port *port)\r\n{\r\nstruct nwpserial_port *up;\r\nunsigned long flags;\r\nint ret;\r\nup = container_of(port, struct nwpserial_port, port);\r\nspin_lock_irqsave(&up->port.lock, flags);\r\nret = dcr_read(up->dcr_host, UART_LSR);\r\nspin_unlock_irqrestore(&up->port.lock, flags);\r\nreturn ret & UART_LSR_TEMT ? TIOCSER_TEMT : 0;\r\n}\r\nint nwpserial_register_port(struct uart_port *port)\r\n{\r\nstruct nwpserial_port *up = NULL;\r\nint ret = -1;\r\nint i;\r\nstatic int first = 1;\r\nint dcr_len;\r\nint dcr_base;\r\nstruct device_node *dn;\r\nmutex_lock(&nwpserial_mutex);\r\ndn = port->dev->of_node;\r\nif (dn == NULL)\r\ngoto out;\r\ndcr_base = dcr_resource_start(dn, 0);\r\nfor (i = 0; i < NWPSERIAL_NR; i++)\r\nif (nwpserial_ports[i].port.iobase == dcr_base) {\r\nup = &nwpserial_ports[i];\r\nbreak;\r\n}\r\nif (up == NULL)\r\nfor (i = 0; i < NWPSERIAL_NR; i++)\r\nif (nwpserial_ports[i].port.type == PORT_UNKNOWN &&\r\nnwpserial_ports[i].port.iobase == 0) {\r\nup = &nwpserial_ports[i];\r\nbreak;\r\n}\r\nif (up == NULL) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (first)\r\nuart_register_driver(&nwpserial_reg);\r\nfirst = 0;\r\nup->port.membase = port->membase;\r\nup->port.irq = port->irq;\r\nup->port.uartclk = port->uartclk;\r\nup->port.fifosize = port->fifosize;\r\nup->port.regshift = port->regshift;\r\nup->port.iotype = port->iotype;\r\nup->port.flags = port->flags;\r\nup->port.mapbase = port->mapbase;\r\nup->port.private_data = port->private_data;\r\nif (port->dev)\r\nup->port.dev = port->dev;\r\nif (up->port.iobase != dcr_base) {\r\nup->port.ops = &nwpserial_pops;\r\nup->port.fifosize = 16;\r\nspin_lock_init(&up->port.lock);\r\nup->port.iobase = dcr_base;\r\ndcr_len = dcr_resource_len(dn, 0);\r\nup->dcr_host = dcr_map(dn, dcr_base, dcr_len);\r\nif (!DCR_MAP_OK(up->dcr_host)) {\r\nprintk(KERN_ERR "Cannot map DCR resources for NWPSERIAL");\r\ngoto out;\r\n}\r\n}\r\nret = uart_add_one_port(&nwpserial_reg, &up->port);\r\nif (ret == 0)\r\nret = up->port.line;\r\nout:\r\nmutex_unlock(&nwpserial_mutex);\r\nreturn ret;\r\n}\r\nvoid nwpserial_unregister_port(int line)\r\n{\r\nstruct nwpserial_port *up = &nwpserial_ports[line];\r\nmutex_lock(&nwpserial_mutex);\r\nuart_remove_one_port(&nwpserial_reg, &up->port);\r\nup->port.type = PORT_UNKNOWN;\r\nmutex_unlock(&nwpserial_mutex);\r\n}\r\nstatic int __init nwpserial_console_init(void)\r\n{\r\nstruct nwpserial_port *up = NULL;\r\nstruct device_node *dn;\r\nconst char *name;\r\nint dcr_base;\r\nint dcr_len;\r\nint i;\r\nfor (i = 0; i < NWPSERIAL_NR; i++)\r\nif (nwpserial_ports[i].port.type == PORT_UNKNOWN) {\r\nup = &nwpserial_ports[i];\r\nbreak;\r\n}\r\nif (up == NULL)\r\nreturn -1;\r\nname = of_get_property(of_chosen, "linux,stdout-path", NULL);\r\nif (name == NULL)\r\nreturn -1;\r\ndn = of_find_node_by_path(name);\r\nif (!dn)\r\nreturn -1;\r\nspin_lock_init(&up->port.lock);\r\nup->port.ops = &nwpserial_pops;\r\nup->port.type = PORT_NWPSERIAL;\r\nup->port.fifosize = 16;\r\ndcr_base = dcr_resource_start(dn, 0);\r\ndcr_len = dcr_resource_len(dn, 0);\r\nup->port.iobase = dcr_base;\r\nup->dcr_host = dcr_map(dn, dcr_base, dcr_len);\r\nif (!DCR_MAP_OK(up->dcr_host)) {\r\nprintk("Cannot map DCR resources for SERIAL");\r\nreturn -1;\r\n}\r\nregister_console(&nwpserial_console);\r\nreturn 0;\r\n}
