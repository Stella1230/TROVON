static void iwl_mvm_bound_iface_iterator(void *_data, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct iwl_mvm_active_iface_iterator_data *data = _data;\r\nstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\r\nif (vif == data->ignore_vif || !mvmvif->phy_ctxt ||\r\nvif->type == NL80211_IFTYPE_P2P_DEVICE)\r\nreturn;\r\ndata->num_active_macs++;\r\nif (vif->type == NL80211_IFTYPE_STATION) {\r\ndata->sta_vif_ap_sta_id = mvmvif->ap_sta_id;\r\nif (vif->bss_conf.assoc)\r\ndata->sta_vif_state = SF_FULL_ON;\r\nelse\r\ndata->sta_vif_state = SF_INIT_OFF;\r\n}\r\n}\r\nstatic void iwl_mvm_fill_sf_command(struct iwl_sf_cfg_cmd *sf_cmd,\r\nstruct ieee80211_sta *sta)\r\n{\r\nint i, j, watermark;\r\nsf_cmd->watermark[SF_LONG_DELAY_ON] = cpu_to_le32(SF_W_MARK_SCAN);\r\nif (sta) {\r\nif (sta->ht_cap.ht_supported || sta->vht_cap.vht_supported) {\r\nswitch (sta->rx_nss) {\r\ncase 1:\r\nwatermark = SF_W_MARK_SISO;\r\nbreak;\r\ncase 2:\r\nwatermark = SF_W_MARK_MIMO2;\r\nbreak;\r\ndefault:\r\nwatermark = SF_W_MARK_MIMO3;\r\nbreak;\r\n}\r\n} else {\r\nwatermark = SF_W_MARK_LEGACY;\r\n}\r\n} else {\r\nwatermark = SF_W_MARK_MIMO2;\r\n}\r\nsf_cmd->watermark[SF_FULL_ON] = cpu_to_le32(watermark);\r\nfor (i = 0; i < SF_NUM_SCENARIO; i++) {\r\nfor (j = 0; j < SF_NUM_TIMEOUT_TYPES; j++) {\r\nsf_cmd->long_delay_timeouts[i][j] =\r\ncpu_to_le32(SF_LONG_DELAY_AGING_TIMER);\r\n}\r\n}\r\nBUILD_BUG_ON(sizeof(sf_full_timeout) !=\r\nsizeof(__le32) * SF_NUM_SCENARIO * SF_NUM_TIMEOUT_TYPES);\r\nmemcpy(sf_cmd->full_on_timeouts, sf_full_timeout,\r\nsizeof(sf_full_timeout));\r\n}\r\nstatic int iwl_mvm_sf_config(struct iwl_mvm *mvm, u8 sta_id,\r\nenum iwl_sf_state new_state)\r\n{\r\nstruct iwl_sf_cfg_cmd sf_cmd = {\r\n.state = cpu_to_le32(new_state),\r\n};\r\nstruct ieee80211_sta *sta;\r\nint ret = 0;\r\nif (mvm->fw->ucode_capa.api[0] & IWL_UCODE_TLV_API_SF_NO_DUMMY_NOTIF &&\r\nmvm->cfg->disable_dummy_notification)\r\nsf_cmd.state |= cpu_to_le32(SF_CFG_DUMMY_NOTIF_OFF);\r\nif (new_state != SF_FULL_ON && mvm->sf_state == new_state)\r\nreturn 0;\r\nswitch (new_state) {\r\ncase SF_UNINIT:\r\nbreak;\r\ncase SF_FULL_ON:\r\nif (sta_id == IWL_MVM_STATION_COUNT) {\r\nIWL_ERR(mvm,\r\n"No station: Cannot switch SF to FULL_ON\n");\r\nreturn -EINVAL;\r\n}\r\nrcu_read_lock();\r\nsta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);\r\nif (IS_ERR_OR_NULL(sta)) {\r\nIWL_ERR(mvm, "Invalid station id\n");\r\nrcu_read_unlock();\r\nreturn -EINVAL;\r\n}\r\niwl_mvm_fill_sf_command(&sf_cmd, sta);\r\nrcu_read_unlock();\r\nbreak;\r\ncase SF_INIT_OFF:\r\niwl_mvm_fill_sf_command(&sf_cmd, NULL);\r\nbreak;\r\ndefault:\r\nWARN_ONCE(1, "Invalid state: %d. not sending Smart Fifo cmd\n",\r\nnew_state);\r\nreturn -EINVAL;\r\n}\r\nret = iwl_mvm_send_cmd_pdu(mvm, REPLY_SF_CFG_CMD, CMD_ASYNC,\r\nsizeof(sf_cmd), &sf_cmd);\r\nif (!ret)\r\nmvm->sf_state = new_state;\r\nreturn ret;\r\n}\r\nint iwl_mvm_sf_update(struct iwl_mvm *mvm, struct ieee80211_vif *changed_vif,\r\nbool remove_vif)\r\n{\r\nenum iwl_sf_state new_state;\r\nu8 sta_id = IWL_MVM_STATION_COUNT;\r\nstruct iwl_mvm_vif *mvmvif = NULL;\r\nstruct iwl_mvm_active_iface_iterator_data data = {\r\n.ignore_vif = changed_vif,\r\n.sta_vif_state = SF_UNINIT,\r\n.sta_vif_ap_sta_id = IWL_MVM_STATION_COUNT,\r\n};\r\nif (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status) ||\r\n(changed_vif && changed_vif->type == NL80211_IFTYPE_P2P_DEVICE))\r\nreturn 0;\r\nieee80211_iterate_active_interfaces_atomic(mvm->hw,\r\nIEEE80211_IFACE_ITER_NORMAL,\r\niwl_mvm_bound_iface_iterator,\r\n&data);\r\nif (changed_vif && !remove_vif)\r\ndata.num_active_macs++;\r\nswitch (data.num_active_macs) {\r\ncase 0:\r\nnew_state = SF_INIT_OFF;\r\nbreak;\r\ncase 1:\r\nif (remove_vif) {\r\nnew_state = data.sta_vif_state;\r\nsta_id = data.sta_vif_ap_sta_id;\r\n} else {\r\nif (WARN_ON(!changed_vif))\r\nreturn -EINVAL;\r\nif (changed_vif->type != NL80211_IFTYPE_STATION) {\r\nnew_state = SF_UNINIT;\r\n} else if (changed_vif->bss_conf.assoc &&\r\nchanged_vif->bss_conf.dtim_period) {\r\nmvmvif = iwl_mvm_vif_from_mac80211(changed_vif);\r\nsta_id = mvmvif->ap_sta_id;\r\nnew_state = SF_FULL_ON;\r\n} else {\r\nnew_state = SF_INIT_OFF;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nnew_state = SF_UNINIT;\r\n}\r\nreturn iwl_mvm_sf_config(mvm, sta_id, new_state);\r\n}
