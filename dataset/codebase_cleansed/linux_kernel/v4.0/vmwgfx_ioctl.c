int vmw_getparam_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct drm_vmw_getparam_arg *param =\r\n(struct drm_vmw_getparam_arg *)data;\r\nstruct vmw_fpriv *vmw_fp = vmw_fpriv(file_priv);\r\nswitch (param->param) {\r\ncase DRM_VMW_PARAM_NUM_STREAMS:\r\nparam->value = vmw_overlay_num_overlays(dev_priv);\r\nbreak;\r\ncase DRM_VMW_PARAM_NUM_FREE_STREAMS:\r\nparam->value = vmw_overlay_num_free_overlays(dev_priv);\r\nbreak;\r\ncase DRM_VMW_PARAM_3D:\r\nparam->value = vmw_fifo_have_3d(dev_priv) ? 1 : 0;\r\nbreak;\r\ncase DRM_VMW_PARAM_HW_CAPS:\r\nparam->value = dev_priv->capabilities;\r\nbreak;\r\ncase DRM_VMW_PARAM_FIFO_CAPS:\r\nparam->value = dev_priv->fifo.capabilities;\r\nbreak;\r\ncase DRM_VMW_PARAM_MAX_FB_SIZE:\r\nparam->value = dev_priv->prim_bb_mem;\r\nbreak;\r\ncase DRM_VMW_PARAM_FIFO_HW_VERSION:\r\n{\r\n__le32 __iomem *fifo_mem = dev_priv->mmio_virt;\r\nconst struct vmw_fifo_state *fifo = &dev_priv->fifo;\r\nif ((dev_priv->capabilities & SVGA_CAP_GBOBJECTS)) {\r\nparam->value = SVGA3D_HWVERSION_WS8_B1;\r\nbreak;\r\n}\r\nparam->value =\r\nioread32(fifo_mem +\r\n((fifo->capabilities &\r\nSVGA_FIFO_CAP_3D_HWVERSION_REVISED) ?\r\nSVGA_FIFO_3D_HWVERSION_REVISED :\r\nSVGA_FIFO_3D_HWVERSION));\r\nbreak;\r\n}\r\ncase DRM_VMW_PARAM_MAX_SURF_MEMORY:\r\nif ((dev_priv->capabilities & SVGA_CAP_GBOBJECTS) &&\r\n!vmw_fp->gb_aware)\r\nparam->value = dev_priv->max_mob_pages * PAGE_SIZE / 2;\r\nelse\r\nparam->value = dev_priv->memory_size;\r\nbreak;\r\ncase DRM_VMW_PARAM_3D_CAPS_SIZE:\r\nif ((dev_priv->capabilities & SVGA_CAP_GBOBJECTS) &&\r\nvmw_fp->gb_aware)\r\nparam->value = SVGA3D_DEVCAP_MAX * sizeof(uint32_t);\r\nelse if (dev_priv->capabilities & SVGA_CAP_GBOBJECTS)\r\nparam->value = sizeof(struct svga_3d_compat_cap) +\r\nsizeof(uint32_t);\r\nelse\r\nparam->value = (SVGA_FIFO_3D_CAPS_LAST -\r\nSVGA_FIFO_3D_CAPS + 1) *\r\nsizeof(uint32_t);\r\nbreak;\r\ncase DRM_VMW_PARAM_MAX_MOB_MEMORY:\r\nvmw_fp->gb_aware = true;\r\nparam->value = dev_priv->max_mob_pages * PAGE_SIZE;\r\nbreak;\r\ncase DRM_VMW_PARAM_MAX_MOB_SIZE:\r\nparam->value = dev_priv->max_mob_size;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Illegal vmwgfx get param request: %d\n",\r\nparam->param);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vmw_fill_compat_cap(struct vmw_private *dev_priv, void *bounce,\r\nsize_t size)\r\n{\r\nstruct svga_3d_compat_cap *compat_cap =\r\n(struct svga_3d_compat_cap *) bounce;\r\nunsigned int i;\r\nsize_t pair_offset = offsetof(struct svga_3d_compat_cap, pairs);\r\nunsigned int max_size;\r\nif (size < pair_offset)\r\nreturn -EINVAL;\r\nmax_size = (size - pair_offset) / sizeof(SVGA3dCapPair);\r\nif (max_size > SVGA3D_DEVCAP_MAX)\r\nmax_size = SVGA3D_DEVCAP_MAX;\r\ncompat_cap->header.length =\r\n(pair_offset + max_size * sizeof(SVGA3dCapPair)) / sizeof(u32);\r\ncompat_cap->header.type = SVGA3DCAPS_RECORD_DEVCAPS;\r\nspin_lock(&dev_priv->cap_lock);\r\nfor (i = 0; i < max_size; ++i) {\r\nvmw_write(dev_priv, SVGA_REG_DEV_CAP, i);\r\ncompat_cap->pairs[i][0] = i;\r\ncompat_cap->pairs[i][1] = vmw_read(dev_priv, SVGA_REG_DEV_CAP);\r\n}\r\nspin_unlock(&dev_priv->cap_lock);\r\nreturn 0;\r\n}\r\nint vmw_get_cap_3d_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct drm_vmw_get_3d_cap_arg *arg =\r\n(struct drm_vmw_get_3d_cap_arg *) data;\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nuint32_t size;\r\n__le32 __iomem *fifo_mem;\r\nvoid __user *buffer = (void __user *)((unsigned long)(arg->buffer));\r\nvoid *bounce;\r\nint ret;\r\nbool gb_objects = !!(dev_priv->capabilities & SVGA_CAP_GBOBJECTS);\r\nstruct vmw_fpriv *vmw_fp = vmw_fpriv(file_priv);\r\nif (unlikely(arg->pad64 != 0)) {\r\nDRM_ERROR("Illegal GET_3D_CAP argument.\n");\r\nreturn -EINVAL;\r\n}\r\nif (gb_objects && vmw_fp->gb_aware)\r\nsize = SVGA3D_DEVCAP_MAX * sizeof(uint32_t);\r\nelse if (gb_objects)\r\nsize = sizeof(struct svga_3d_compat_cap) + sizeof(uint32_t);\r\nelse\r\nsize = (SVGA_FIFO_3D_CAPS_LAST - SVGA_FIFO_3D_CAPS + 1) *\r\nsizeof(uint32_t);\r\nif (arg->max_size < size)\r\nsize = arg->max_size;\r\nbounce = vzalloc(size);\r\nif (unlikely(bounce == NULL)) {\r\nDRM_ERROR("Failed to allocate bounce buffer for 3D caps.\n");\r\nreturn -ENOMEM;\r\n}\r\nif (gb_objects && vmw_fp->gb_aware) {\r\nint i, num;\r\nuint32_t *bounce32 = (uint32_t *) bounce;\r\nnum = size / sizeof(uint32_t);\r\nif (num > SVGA3D_DEVCAP_MAX)\r\nnum = SVGA3D_DEVCAP_MAX;\r\nspin_lock(&dev_priv->cap_lock);\r\nfor (i = 0; i < num; ++i) {\r\nvmw_write(dev_priv, SVGA_REG_DEV_CAP, i);\r\n*bounce32++ = vmw_read(dev_priv, SVGA_REG_DEV_CAP);\r\n}\r\nspin_unlock(&dev_priv->cap_lock);\r\n} else if (gb_objects) {\r\nret = vmw_fill_compat_cap(dev_priv, bounce, size);\r\nif (unlikely(ret != 0))\r\ngoto out_err;\r\n} else {\r\nfifo_mem = dev_priv->mmio_virt;\r\nmemcpy_fromio(bounce, &fifo_mem[SVGA_FIFO_3D_CAPS], size);\r\n}\r\nret = copy_to_user(buffer, bounce, size);\r\nif (ret)\r\nret = -EFAULT;\r\nout_err:\r\nvfree(bounce);\r\nif (unlikely(ret != 0))\r\nDRM_ERROR("Failed to report 3D caps info.\n");\r\nreturn ret;\r\n}\r\nint vmw_present_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct drm_vmw_present_arg *arg =\r\n(struct drm_vmw_present_arg *)data;\r\nstruct vmw_surface *surface;\r\nstruct drm_vmw_rect __user *clips_ptr;\r\nstruct drm_vmw_rect *clips = NULL;\r\nstruct drm_framebuffer *fb;\r\nstruct vmw_framebuffer *vfb;\r\nstruct vmw_resource *res;\r\nuint32_t num_clips;\r\nint ret;\r\nnum_clips = arg->num_clips;\r\nclips_ptr = (struct drm_vmw_rect *)(unsigned long)arg->clips_ptr;\r\nif (unlikely(num_clips == 0))\r\nreturn 0;\r\nif (clips_ptr == NULL) {\r\nDRM_ERROR("Variable clips_ptr must be specified.\n");\r\nret = -EINVAL;\r\ngoto out_clips;\r\n}\r\nclips = kcalloc(num_clips, sizeof(*clips), GFP_KERNEL);\r\nif (clips == NULL) {\r\nDRM_ERROR("Failed to allocate clip rect list.\n");\r\nret = -ENOMEM;\r\ngoto out_clips;\r\n}\r\nret = copy_from_user(clips, clips_ptr, num_clips * sizeof(*clips));\r\nif (ret) {\r\nDRM_ERROR("Failed to copy clip rects from userspace.\n");\r\nret = -EFAULT;\r\ngoto out_no_copy;\r\n}\r\ndrm_modeset_lock_all(dev);\r\nfb = drm_framebuffer_lookup(dev, arg->fb_id);\r\nif (!fb) {\r\nDRM_ERROR("Invalid framebuffer id.\n");\r\nret = -ENOENT;\r\ngoto out_no_fb;\r\n}\r\nvfb = vmw_framebuffer_to_vfb(fb);\r\nret = ttm_read_lock(&dev_priv->reservation_sem, true);\r\nif (unlikely(ret != 0))\r\ngoto out_no_ttm_lock;\r\nret = vmw_user_resource_lookup_handle(dev_priv, tfile, arg->sid,\r\nuser_surface_converter,\r\n&res);\r\nif (ret)\r\ngoto out_no_surface;\r\nsurface = vmw_res_to_srf(res);\r\nret = vmw_kms_present(dev_priv, file_priv,\r\nvfb, surface, arg->sid,\r\narg->dest_x, arg->dest_y,\r\nclips, num_clips);\r\nvmw_surface_unreference(&surface);\r\nout_no_surface:\r\nttm_read_unlock(&dev_priv->reservation_sem);\r\nout_no_ttm_lock:\r\ndrm_framebuffer_unreference(fb);\r\nout_no_fb:\r\ndrm_modeset_unlock_all(dev);\r\nout_no_copy:\r\nkfree(clips);\r\nout_clips:\r\nreturn ret;\r\n}\r\nint vmw_present_readback_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct vmw_private *dev_priv = vmw_priv(dev);\r\nstruct drm_vmw_present_readback_arg *arg =\r\n(struct drm_vmw_present_readback_arg *)data;\r\nstruct drm_vmw_fence_rep __user *user_fence_rep =\r\n(struct drm_vmw_fence_rep __user *)\r\n(unsigned long)arg->fence_rep;\r\nstruct drm_vmw_rect __user *clips_ptr;\r\nstruct drm_vmw_rect *clips = NULL;\r\nstruct drm_framebuffer *fb;\r\nstruct vmw_framebuffer *vfb;\r\nuint32_t num_clips;\r\nint ret;\r\nnum_clips = arg->num_clips;\r\nclips_ptr = (struct drm_vmw_rect *)(unsigned long)arg->clips_ptr;\r\nif (unlikely(num_clips == 0))\r\nreturn 0;\r\nif (clips_ptr == NULL) {\r\nDRM_ERROR("Argument clips_ptr must be specified.\n");\r\nret = -EINVAL;\r\ngoto out_clips;\r\n}\r\nclips = kcalloc(num_clips, sizeof(*clips), GFP_KERNEL);\r\nif (clips == NULL) {\r\nDRM_ERROR("Failed to allocate clip rect list.\n");\r\nret = -ENOMEM;\r\ngoto out_clips;\r\n}\r\nret = copy_from_user(clips, clips_ptr, num_clips * sizeof(*clips));\r\nif (ret) {\r\nDRM_ERROR("Failed to copy clip rects from userspace.\n");\r\nret = -EFAULT;\r\ngoto out_no_copy;\r\n}\r\ndrm_modeset_lock_all(dev);\r\nfb = drm_framebuffer_lookup(dev, arg->fb_id);\r\nif (!fb) {\r\nDRM_ERROR("Invalid framebuffer id.\n");\r\nret = -ENOENT;\r\ngoto out_no_fb;\r\n}\r\nvfb = vmw_framebuffer_to_vfb(fb);\r\nif (!vfb->dmabuf) {\r\nDRM_ERROR("Framebuffer not dmabuf backed.\n");\r\nret = -EINVAL;\r\ngoto out_no_ttm_lock;\r\n}\r\nret = ttm_read_lock(&dev_priv->reservation_sem, true);\r\nif (unlikely(ret != 0))\r\ngoto out_no_ttm_lock;\r\nret = vmw_kms_readback(dev_priv, file_priv,\r\nvfb, user_fence_rep,\r\nclips, num_clips);\r\nttm_read_unlock(&dev_priv->reservation_sem);\r\nout_no_ttm_lock:\r\ndrm_framebuffer_unreference(fb);\r\nout_no_fb:\r\ndrm_modeset_unlock_all(dev);\r\nout_no_copy:\r\nkfree(clips);\r\nout_clips:\r\nreturn ret;\r\n}\r\nunsigned int vmw_fops_poll(struct file *filp, struct poll_table_struct *wait)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nstruct vmw_private *dev_priv =\r\nvmw_priv(file_priv->minor->dev);\r\nvmw_fifo_ping_host(dev_priv, SVGA_SYNC_GENERIC);\r\nreturn drm_poll(filp, wait);\r\n}\r\nssize_t vmw_fops_read(struct file *filp, char __user *buffer,\r\nsize_t count, loff_t *offset)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nstruct vmw_private *dev_priv =\r\nvmw_priv(file_priv->minor->dev);\r\nvmw_fifo_ping_host(dev_priv, SVGA_SYNC_GENERIC);\r\nreturn drm_read(filp, buffer, count, offset);\r\n}
