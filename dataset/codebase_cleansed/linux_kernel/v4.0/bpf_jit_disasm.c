static void get_exec_path(char *tpath, size_t size)\r\n{\r\nchar *path;\r\nssize_t len;\r\nsnprintf(tpath, size, "/proc/%d/exe", (int) getpid());\r\ntpath[size - 1] = 0;\r\npath = strdup(tpath);\r\nassert(path);\r\nlen = readlink(path, tpath, size);\r\ntpath[len] = 0;\r\nfree(path);\r\n}\r\nstatic void get_asm_insns(uint8_t *image, size_t len, int opcodes)\r\n{\r\nint count, i, pc = 0;\r\nchar tpath[256];\r\nstruct disassemble_info info;\r\ndisassembler_ftype disassemble;\r\nbfd *bfdf;\r\nmemset(tpath, 0, sizeof(tpath));\r\nget_exec_path(tpath, sizeof(tpath));\r\nbfdf = bfd_openr(tpath, NULL);\r\nassert(bfdf);\r\nassert(bfd_check_format(bfdf, bfd_object));\r\ninit_disassemble_info(&info, stdout, (fprintf_ftype) fprintf);\r\ninfo.arch = bfd_get_arch(bfdf);\r\ninfo.mach = bfd_get_mach(bfdf);\r\ninfo.buffer = image;\r\ninfo.buffer_length = len;\r\ndisassemble_init_for_target(&info);\r\ndisassemble = disassembler(bfdf);\r\nassert(disassemble);\r\ndo {\r\nprintf("%4x:\t", pc);\r\ncount = disassemble(pc, &info);\r\nif (opcodes) {\r\nprintf("\n\t");\r\nfor (i = 0; i < count; ++i)\r\nprintf("%02x ", (uint8_t) image[pc + i]);\r\n}\r\nprintf("\n");\r\npc += count;\r\n} while(count > 0 && pc < len);\r\nbfd_close(bfdf);\r\n}\r\nstatic char *get_klog_buff(int *klen)\r\n{\r\nint ret, len = klogctl(10, NULL, 0);\r\nchar *buff = malloc(len);\r\nassert(buff && klen);\r\nret = klogctl(3, buff, len);\r\nassert(ret >= 0);\r\n*klen = ret;\r\nreturn buff;\r\n}\r\nstatic void put_klog_buff(char *buff)\r\n{\r\nfree(buff);\r\n}\r\nstatic int get_last_jit_image(char *haystack, size_t hlen,\r\nuint8_t *image, size_t ilen)\r\n{\r\nchar *ptr, *pptr, *tmp;\r\noff_t off = 0;\r\nint ret, flen, proglen, pass, ulen = 0;\r\nregmatch_t pmatch[1];\r\nunsigned long base;\r\nregex_t regex;\r\nif (hlen == 0)\r\nreturn 0;\r\nret = regcomp(&regex, "flen=[[:alnum:]]+ proglen=[[:digit:]]+ "\r\n"pass=[[:digit:]]+ image=[[:xdigit:]]+", REG_EXTENDED);\r\nassert(ret == 0);\r\nptr = haystack;\r\nwhile (1) {\r\nret = regexec(&regex, ptr, 1, pmatch, 0);\r\nif (ret == 0) {\r\nptr += pmatch[0].rm_eo;\r\noff += pmatch[0].rm_eo;\r\nassert(off < hlen);\r\n} else\r\nbreak;\r\n}\r\nptr = haystack + off - (pmatch[0].rm_eo - pmatch[0].rm_so);\r\nret = sscanf(ptr, "flen=%d proglen=%d pass=%d image=%lx",\r\n&flen, &proglen, &pass, &base);\r\nif (ret != 4)\r\nreturn 0;\r\ntmp = ptr = haystack + off;\r\nwhile ((ptr = strtok(tmp, "\n")) != NULL && ulen < ilen) {\r\ntmp = NULL;\r\nif (!strstr(ptr, "JIT code"))\r\ncontinue;\r\npptr = ptr;\r\nwhile ((ptr = strstr(pptr, ":")))\r\npptr = ptr + 1;\r\nptr = pptr;\r\ndo {\r\nimage[ulen++] = (uint8_t) strtoul(pptr, &pptr, 16);\r\nif (ptr == pptr || ulen >= ilen) {\r\nulen--;\r\nbreak;\r\n}\r\nptr = pptr;\r\n} while (1);\r\n}\r\nassert(ulen == proglen);\r\nprintf("%d bytes emitted from JIT compiler (pass:%d, flen:%d)\n",\r\nproglen, pass, flen);\r\nprintf("%lx + <x>:\n", base);\r\nregfree(&regex);\r\nreturn ulen;\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nint len, klen, opcodes = 0;\r\nchar *kbuff;\r\nstatic uint8_t image[32768];\r\nif (argc > 1) {\r\nif (!strncmp("-o", argv[argc - 1], 2)) {\r\nopcodes = 1;\r\n} else {\r\nprintf("usage: bpf_jit_disasm [-o: show opcodes]\n");\r\nexit(0);\r\n}\r\n}\r\nbfd_init();\r\nmemset(image, 0, sizeof(image));\r\nkbuff = get_klog_buff(&klen);\r\nlen = get_last_jit_image(kbuff, klen, image, sizeof(image));\r\nif (len > 0)\r\nget_asm_insns(image, len, opcodes);\r\nput_klog_buff(kbuff);\r\nreturn 0;\r\n}
