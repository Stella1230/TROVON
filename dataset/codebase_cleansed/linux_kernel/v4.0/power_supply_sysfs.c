static ssize_t power_supply_show_property(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf) {\r\nstatic char *type_text[] = {\r\n"Unknown", "Battery", "UPS", "Mains", "USB",\r\n"USB_DCP", "USB_CDP", "USB_ACA"\r\n};\r\nstatic char *status_text[] = {\r\n"Unknown", "Charging", "Discharging", "Not charging", "Full"\r\n};\r\nstatic char *charge_type[] = {\r\n"Unknown", "N/A", "Trickle", "Fast"\r\n};\r\nstatic char *health_text[] = {\r\n"Unknown", "Good", "Overheat", "Dead", "Over voltage",\r\n"Unspecified failure", "Cold", "Watchdog timer expire",\r\n"Safety timer expire"\r\n};\r\nstatic char *technology_text[] = {\r\n"Unknown", "NiMH", "Li-ion", "Li-poly", "LiFe", "NiCd",\r\n"LiMn"\r\n};\r\nstatic char *capacity_level_text[] = {\r\n"Unknown", "Critical", "Low", "Normal", "High", "Full"\r\n};\r\nstatic char *scope_text[] = {\r\n"Unknown", "System", "Device"\r\n};\r\nssize_t ret = 0;\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nconst ptrdiff_t off = attr - power_supply_attrs;\r\nunion power_supply_propval value;\r\nif (off == POWER_SUPPLY_PROP_TYPE) {\r\nvalue.intval = psy->type;\r\n} else {\r\nret = psy->get_property(psy, off, &value);\r\nif (ret < 0) {\r\nif (ret == -ENODATA)\r\ndev_dbg(dev, "driver has no data for `%s' property\n",\r\nattr->attr.name);\r\nelse if (ret != -ENODEV)\r\ndev_err(dev, "driver failed to report `%s' property: %zd\n",\r\nattr->attr.name, ret);\r\nreturn ret;\r\n}\r\n}\r\nif (off == POWER_SUPPLY_PROP_STATUS)\r\nreturn sprintf(buf, "%s\n", status_text[value.intval]);\r\nelse if (off == POWER_SUPPLY_PROP_CHARGE_TYPE)\r\nreturn sprintf(buf, "%s\n", charge_type[value.intval]);\r\nelse if (off == POWER_SUPPLY_PROP_HEALTH)\r\nreturn sprintf(buf, "%s\n", health_text[value.intval]);\r\nelse if (off == POWER_SUPPLY_PROP_TECHNOLOGY)\r\nreturn sprintf(buf, "%s\n", technology_text[value.intval]);\r\nelse if (off == POWER_SUPPLY_PROP_CAPACITY_LEVEL)\r\nreturn sprintf(buf, "%s\n", capacity_level_text[value.intval]);\r\nelse if (off == POWER_SUPPLY_PROP_TYPE)\r\nreturn sprintf(buf, "%s\n", type_text[value.intval]);\r\nelse if (off == POWER_SUPPLY_PROP_SCOPE)\r\nreturn sprintf(buf, "%s\n", scope_text[value.intval]);\r\nelse if (off >= POWER_SUPPLY_PROP_MODEL_NAME)\r\nreturn sprintf(buf, "%s\n", value.strval);\r\nreturn sprintf(buf, "%d\n", value.intval);\r\n}\r\nstatic ssize_t power_supply_store_property(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count) {\r\nssize_t ret;\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nconst ptrdiff_t off = attr - power_supply_attrs;\r\nunion power_supply_propval value;\r\nlong long_val;\r\nret = kstrtol(buf, 10, &long_val);\r\nif (ret < 0)\r\nreturn ret;\r\nvalue.intval = long_val;\r\nret = psy->set_property(psy, off, &value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic umode_t power_supply_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr,\r\nint attrno)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\numode_t mode = S_IRUSR | S_IRGRP | S_IROTH;\r\nint i;\r\nif (attrno == POWER_SUPPLY_PROP_TYPE)\r\nreturn mode;\r\nfor (i = 0; i < psy->num_properties; i++) {\r\nint property = psy->properties[i];\r\nif (property == attrno) {\r\nif (psy->property_is_writeable &&\r\npsy->property_is_writeable(psy, property) > 0)\r\nmode |= S_IWUSR;\r\nreturn mode;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid power_supply_init_attrs(struct device_type *dev_type)\r\n{\r\nint i;\r\ndev_type->groups = power_supply_attr_groups;\r\nfor (i = 0; i < ARRAY_SIZE(power_supply_attrs); i++)\r\n__power_supply_attrs[i] = &power_supply_attrs[i].attr;\r\n}\r\nstatic char *kstruprdup(const char *str, gfp_t gfp)\r\n{\r\nchar *ret, *ustr;\r\nustr = ret = kmalloc(strlen(str) + 1, gfp);\r\nif (!ret)\r\nreturn NULL;\r\nwhile (*str)\r\n*ustr++ = toupper(*str++);\r\n*ustr = 0;\r\nreturn ret;\r\n}\r\nint power_supply_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nint ret = 0, j;\r\nchar *prop_buf;\r\nchar *attrname;\r\ndev_dbg(dev, "uevent\n");\r\nif (!psy || !psy->dev) {\r\ndev_dbg(dev, "No power supply yet\n");\r\nreturn ret;\r\n}\r\ndev_dbg(dev, "POWER_SUPPLY_NAME=%s\n", psy->name);\r\nret = add_uevent_var(env, "POWER_SUPPLY_NAME=%s", psy->name);\r\nif (ret)\r\nreturn ret;\r\nprop_buf = (char *)get_zeroed_page(GFP_KERNEL);\r\nif (!prop_buf)\r\nreturn -ENOMEM;\r\nfor (j = 0; j < psy->num_properties; j++) {\r\nstruct device_attribute *attr;\r\nchar *line;\r\nattr = &power_supply_attrs[psy->properties[j]];\r\nret = power_supply_show_property(dev, attr, prop_buf);\r\nif (ret == -ENODEV || ret == -ENODATA) {\r\nret = 0;\r\ncontinue;\r\n}\r\nif (ret < 0)\r\ngoto out;\r\nline = strchr(prop_buf, '\n');\r\nif (line)\r\n*line = 0;\r\nattrname = kstruprdup(attr->attr.name, GFP_KERNEL);\r\nif (!attrname) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ndev_dbg(dev, "prop %s=%s\n", attrname, prop_buf);\r\nret = add_uevent_var(env, "POWER_SUPPLY_%s=%s", attrname, prop_buf);\r\nkfree(attrname);\r\nif (ret)\r\ngoto out;\r\n}\r\nout:\r\nfree_page((unsigned long)prop_buf);\r\nreturn ret;\r\n}
