void set_thresholds(unsigned long cpu)\r\n{\r\n#ifdef CONFIG_TAU_INT\r\nmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TIE | THRM1_TID);\r\nmtspr (SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V | THRM1_TIE);\r\n#else\r\nmtspr(SPRN_THRM1, THRM1_THRES(tau[cpu].low) | THRM1_V | THRM1_TID);\r\nmtspr(SPRN_THRM2, THRM1_THRES(tau[cpu].high) | THRM1_V);\r\n#endif\r\n}\r\nvoid TAUupdate(int cpu)\r\n{\r\nunsigned thrm;\r\n#ifdef DEBUG\r\nprintk("TAUupdate ");\r\n#endif\r\nif((thrm = mfspr(SPRN_THRM1)) & THRM1_TIV){\r\nif(thrm & THRM1_TIN){\r\nif (tau[cpu].low >= step_size){\r\ntau[cpu].low -= step_size;\r\ntau[cpu].high -= (step_size - window_expand);\r\n}\r\ntau[cpu].grew = 1;\r\n#ifdef DEBUG\r\nprintk("low threshold crossed ");\r\n#endif\r\n}\r\n}\r\nif((thrm = mfspr(SPRN_THRM2)) & THRM1_TIV){\r\nif(thrm & THRM1_TIN){\r\nif (tau[cpu].high <= 127-step_size){\r\ntau[cpu].low += (step_size - window_expand);\r\ntau[cpu].high += step_size;\r\n}\r\ntau[cpu].grew = 1;\r\n#ifdef DEBUG\r\nprintk("high threshold crossed ");\r\n#endif\r\n}\r\n}\r\n#ifdef DEBUG\r\nprintk("grew = %d\n", tau[cpu].grew);\r\n#endif\r\n#ifndef CONFIG_TAU_INT\r\nset_thresholds(cpu);\r\n#endif\r\n}\r\nvoid TAUException(struct pt_regs * regs)\r\n{\r\nint cpu = smp_processor_id();\r\nirq_enter();\r\ntau[cpu].interrupts++;\r\nTAUupdate(cpu);\r\nirq_exit();\r\n}\r\nstatic void tau_timeout(void * info)\r\n{\r\nint cpu;\r\nunsigned long flags;\r\nint size;\r\nint shrink;\r\nlocal_irq_save(flags);\r\ncpu = smp_processor_id();\r\n#ifndef CONFIG_TAU_INT\r\nTAUupdate(cpu);\r\n#endif\r\nsize = tau[cpu].high - tau[cpu].low;\r\nif (size > min_window && ! tau[cpu].grew) {\r\nshrink = (2 + size - min_window) / 4;\r\nif (shrink) {\r\ntau[cpu].low += shrink;\r\ntau[cpu].high -= shrink;\r\n} else {\r\ntau[cpu].low += 1;\r\n#if 1\r\nif ((tau[cpu].high - tau[cpu].low) != min_window){\r\nprintk(KERN_ERR "temp.c: line %d, logic error\n", __LINE__);\r\n}\r\n#endif\r\n}\r\n}\r\ntau[cpu].grew = 0;\r\nset_thresholds(cpu);\r\nmtspr(SPRN_THRM3, THRM3_SITV(500*60) | THRM3_E);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void tau_timeout_smp(unsigned long unused)\r\n{\r\nmod_timer(&tau_timer, jiffies + shrink_timer) ;\r\non_each_cpu(tau_timeout, NULL, 0);\r\n}\r\nvoid __init TAU_init_smp(void * info)\r\n{\r\nunsigned long cpu = smp_processor_id();\r\ntau[cpu].low = 5;\r\ntau[cpu].high = 120;\r\nset_thresholds(cpu);\r\n}\r\nint __init TAU_init(void)\r\n{\r\nif (!cpu_has_feature(CPU_FTR_TAU)) {\r\nprintk("Thermal assist unit not available\n");\r\ntau_initialized = 0;\r\nreturn 1;\r\n}\r\ninit_timer(&tau_timer);\r\ntau_timer.function = tau_timeout_smp;\r\ntau_timer.expires = jiffies + shrink_timer;\r\nadd_timer(&tau_timer);\r\non_each_cpu(TAU_init_smp, NULL, 0);\r\nprintk("Thermal assist unit ");\r\n#ifdef CONFIG_TAU_INT\r\nprintk("using interrupts, ");\r\n#else\r\nprintk("using timers, ");\r\n#endif\r\nprintk("shrink_timer: %d jiffies\n", shrink_timer);\r\ntau_initialized = 1;\r\nreturn 0;\r\n}\r\nu32 cpu_temp_both(unsigned long cpu)\r\n{\r\nreturn ((tau[cpu].high << 16) | tau[cpu].low);\r\n}\r\nint cpu_temp(unsigned long cpu)\r\n{\r\nreturn ((tau[cpu].high + tau[cpu].low) / 2);\r\n}\r\nint tau_interrupts(unsigned long cpu)\r\n{\r\nreturn (tau[cpu].interrupts);\r\n}
