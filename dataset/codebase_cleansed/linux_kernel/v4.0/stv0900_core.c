static struct stv0900_inode *find_inode(struct i2c_adapter *i2c_adap,\r\nu8 i2c_addr)\r\n{\r\nstruct stv0900_inode *temp_chip = stv0900_first_inode;\r\nif (temp_chip != NULL) {\r\nwhile ((temp_chip != NULL) &&\r\n((temp_chip->internal->i2c_adap != i2c_adap) ||\r\n(temp_chip->internal->i2c_addr != i2c_addr)))\r\ntemp_chip = temp_chip->next_inode;\r\n}\r\nreturn temp_chip;\r\n}\r\nstatic void remove_inode(struct stv0900_internal *internal)\r\n{\r\nstruct stv0900_inode *prev_node = stv0900_first_inode;\r\nstruct stv0900_inode *del_node = find_inode(internal->i2c_adap,\r\ninternal->i2c_addr);\r\nif (del_node != NULL) {\r\nif (del_node == stv0900_first_inode) {\r\nstv0900_first_inode = del_node->next_inode;\r\n} else {\r\nwhile (prev_node->next_inode != del_node)\r\nprev_node = prev_node->next_inode;\r\nif (del_node->next_inode == NULL)\r\nprev_node->next_inode = NULL;\r\nelse\r\nprev_node->next_inode =\r\nprev_node->next_inode->next_inode;\r\n}\r\nkfree(del_node);\r\n}\r\n}\r\nstatic struct stv0900_inode *append_internal(struct stv0900_internal *internal)\r\n{\r\nstruct stv0900_inode *new_node = stv0900_first_inode;\r\nif (new_node == NULL) {\r\nnew_node = kmalloc(sizeof(struct stv0900_inode), GFP_KERNEL);\r\nstv0900_first_inode = new_node;\r\n} else {\r\nwhile (new_node->next_inode != NULL)\r\nnew_node = new_node->next_inode;\r\nnew_node->next_inode = kmalloc(sizeof(struct stv0900_inode),\r\nGFP_KERNEL);\r\nif (new_node->next_inode != NULL)\r\nnew_node = new_node->next_inode;\r\nelse\r\nnew_node = NULL;\r\n}\r\nif (new_node != NULL) {\r\nnew_node->internal = internal;\r\nnew_node->next_inode = NULL;\r\n}\r\nreturn new_node;\r\n}\r\ns32 ge2comp(s32 a, s32 width)\r\n{\r\nif (width == 32)\r\nreturn a;\r\nelse\r\nreturn (a >= (1 << (width - 1))) ? (a - (1 << width)) : a;\r\n}\r\nvoid stv0900_write_reg(struct stv0900_internal *intp, u16 reg_addr,\r\nu8 reg_data)\r\n{\r\nu8 data[3];\r\nint ret;\r\nstruct i2c_msg i2cmsg = {\r\n.addr = intp->i2c_addr,\r\n.flags = 0,\r\n.len = 3,\r\n.buf = data,\r\n};\r\ndata[0] = MSB(reg_addr);\r\ndata[1] = LSB(reg_addr);\r\ndata[2] = reg_data;\r\nret = i2c_transfer(intp->i2c_adap, &i2cmsg, 1);\r\nif (ret != 1)\r\ndprintk("%s: i2c error %d\n", __func__, ret);\r\n}\r\nu8 stv0900_read_reg(struct stv0900_internal *intp, u16 reg)\r\n{\r\nint ret;\r\nu8 b0[] = { MSB(reg), LSB(reg) };\r\nu8 buf = 0;\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = intp->i2c_addr,\r\n.flags = 0,\r\n.buf = b0,\r\n.len = 2,\r\n}, {\r\n.addr = intp->i2c_addr,\r\n.flags = I2C_M_RD,\r\n.buf = &buf,\r\n.len = 1,\r\n},\r\n};\r\nret = i2c_transfer(intp->i2c_adap, msg, 2);\r\nif (ret != 2)\r\ndprintk("%s: i2c error %d, reg[0x%02x]\n",\r\n__func__, ret, reg);\r\nreturn buf;\r\n}\r\nstatic void extract_mask_pos(u32 label, u8 *mask, u8 *pos)\r\n{\r\nu8 position = 0, i = 0;\r\n(*mask) = label & 0xff;\r\nwhile ((position == 0) && (i < 8)) {\r\nposition = ((*mask) >> i) & 0x01;\r\ni++;\r\n}\r\n(*pos) = (i - 1);\r\n}\r\nvoid stv0900_write_bits(struct stv0900_internal *intp, u32 label, u8 val)\r\n{\r\nu8 reg, mask, pos;\r\nreg = stv0900_read_reg(intp, (label >> 16) & 0xffff);\r\nextract_mask_pos(label, &mask, &pos);\r\nval = mask & (val << pos);\r\nreg = (reg & (~mask)) | val;\r\nstv0900_write_reg(intp, (label >> 16) & 0xffff, reg);\r\n}\r\nu8 stv0900_get_bits(struct stv0900_internal *intp, u32 label)\r\n{\r\nu8 val = 0xff;\r\nu8 mask, pos;\r\nextract_mask_pos(label, &mask, &pos);\r\nval = stv0900_read_reg(intp, label >> 16);\r\nval = (val & mask) >> pos;\r\nreturn val;\r\n}\r\nstatic enum fe_stv0900_error stv0900_initialize(struct stv0900_internal *intp)\r\n{\r\ns32 i;\r\nif (intp == NULL)\r\nreturn STV0900_INVALID_HANDLE;\r\nintp->chip_id = stv0900_read_reg(intp, R0900_MID);\r\nif (intp->errs != STV0900_NO_ERROR)\r\nreturn intp->errs;\r\nstv0900_write_reg(intp, R0900_P1_DMDISTATE, 0x5c);\r\nstv0900_write_reg(intp, R0900_P2_DMDISTATE, 0x5c);\r\nmsleep(3);\r\nstv0900_write_reg(intp, R0900_P1_TNRCFG, 0x6c);\r\nstv0900_write_reg(intp, R0900_P2_TNRCFG, 0x6f);\r\nstv0900_write_reg(intp, R0900_P1_I2CRPT, 0x20);\r\nstv0900_write_reg(intp, R0900_P2_I2CRPT, 0x20);\r\nstv0900_write_reg(intp, R0900_NCOARSE, 0x13);\r\nmsleep(3);\r\nstv0900_write_reg(intp, R0900_I2CCFG, 0x08);\r\nswitch (intp->clkmode) {\r\ncase 0:\r\ncase 2:\r\nstv0900_write_reg(intp, R0900_SYNTCTRL, 0x20\r\n| intp->clkmode);\r\nbreak;\r\ndefault:\r\ni = 0x02 & stv0900_read_reg(intp, R0900_SYNTCTRL);\r\nstv0900_write_reg(intp, R0900_SYNTCTRL, 0x20 | i);\r\nbreak;\r\n}\r\nmsleep(3);\r\nfor (i = 0; i < 181; i++)\r\nstv0900_write_reg(intp, STV0900_InitVal[i][0],\r\nSTV0900_InitVal[i][1]);\r\nif (stv0900_read_reg(intp, R0900_MID) >= 0x20) {\r\nstv0900_write_reg(intp, R0900_TSGENERAL, 0x0c);\r\nfor (i = 0; i < 32; i++)\r\nstv0900_write_reg(intp, STV0900_Cut20_AddOnVal[i][0],\r\nSTV0900_Cut20_AddOnVal[i][1]);\r\n}\r\nstv0900_write_reg(intp, R0900_P1_FSPYCFG, 0x6c);\r\nstv0900_write_reg(intp, R0900_P2_FSPYCFG, 0x6c);\r\nstv0900_write_reg(intp, R0900_P1_PDELCTRL2, 0x01);\r\nstv0900_write_reg(intp, R0900_P2_PDELCTRL2, 0x21);\r\nstv0900_write_reg(intp, R0900_P1_PDELCTRL3, 0x20);\r\nstv0900_write_reg(intp, R0900_P2_PDELCTRL3, 0x20);\r\nstv0900_write_reg(intp, R0900_TSTRES0, 0x80);\r\nstv0900_write_reg(intp, R0900_TSTRES0, 0x00);\r\nreturn STV0900_NO_ERROR;\r\n}\r\nstatic u32 stv0900_get_mclk_freq(struct stv0900_internal *intp, u32 ext_clk)\r\n{\r\nu32 mclk = 90000000, div = 0, ad_div = 0;\r\ndiv = stv0900_get_bits(intp, F0900_M_DIV);\r\nad_div = ((stv0900_get_bits(intp, F0900_SELX1RATIO) == 1) ? 4 : 6);\r\nmclk = (div + 1) * ext_clk / ad_div;\r\ndprintk("%s: Calculated Mclk = %d\n", __func__, mclk);\r\nreturn mclk;\r\n}\r\nstatic enum fe_stv0900_error stv0900_set_mclk(struct stv0900_internal *intp, u32 mclk)\r\n{\r\nu32 m_div, clk_sel;\r\nif (intp == NULL)\r\nreturn STV0900_INVALID_HANDLE;\r\nif (intp->errs)\r\nreturn STV0900_I2C_ERROR;\r\ndprintk("%s: Mclk set to %d, Quartz = %d\n", __func__, mclk,\r\nintp->quartz);\r\nclk_sel = ((stv0900_get_bits(intp, F0900_SELX1RATIO) == 1) ? 4 : 6);\r\nm_div = ((clk_sel * mclk) / intp->quartz) - 1;\r\nstv0900_write_bits(intp, F0900_M_DIV, m_div);\r\nintp->mclk = stv0900_get_mclk_freq(intp,\r\nintp->quartz);\r\nm_div = intp->mclk / 704000;\r\nstv0900_write_reg(intp, R0900_P1_F22TX, m_div);\r\nstv0900_write_reg(intp, R0900_P1_F22RX, m_div);\r\nstv0900_write_reg(intp, R0900_P2_F22TX, m_div);\r\nstv0900_write_reg(intp, R0900_P2_F22RX, m_div);\r\nif ((intp->errs))\r\nreturn STV0900_I2C_ERROR;\r\nreturn STV0900_NO_ERROR;\r\n}\r\nstatic u32 stv0900_get_err_count(struct stv0900_internal *intp, int cntr,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\nu32 lsb, msb, hsb, err_val;\r\nswitch (cntr) {\r\ncase 0:\r\ndefault:\r\nhsb = stv0900_get_bits(intp, ERR_CNT12);\r\nmsb = stv0900_get_bits(intp, ERR_CNT11);\r\nlsb = stv0900_get_bits(intp, ERR_CNT10);\r\nbreak;\r\ncase 1:\r\nhsb = stv0900_get_bits(intp, ERR_CNT22);\r\nmsb = stv0900_get_bits(intp, ERR_CNT21);\r\nlsb = stv0900_get_bits(intp, ERR_CNT20);\r\nbreak;\r\n}\r\nerr_val = (hsb << 16) + (msb << 8) + (lsb);\r\nreturn err_val;\r\n}\r\nstatic int stv0900_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_demod_num demod = state->demod;\r\nstv0900_write_bits(intp, I2CT_ON, enable);\r\nreturn 0;\r\n}\r\nstatic void stv0900_set_ts_parallel_serial(struct stv0900_internal *intp,\r\nenum fe_stv0900_clock_type path1_ts,\r\nenum fe_stv0900_clock_type path2_ts)\r\n{\r\ndprintk("%s\n", __func__);\r\nif (intp->chip_id >= 0x20) {\r\nswitch (path1_ts) {\r\ncase STV0900_PARALLEL_PUNCT_CLOCK:\r\ncase STV0900_DVBCI_CLOCK:\r\nswitch (path2_ts) {\r\ncase STV0900_SERIAL_PUNCT_CLOCK:\r\ncase STV0900_SERIAL_CONT_CLOCK:\r\ndefault:\r\nstv0900_write_reg(intp, R0900_TSGENERAL,\r\n0x00);\r\nbreak;\r\ncase STV0900_PARALLEL_PUNCT_CLOCK:\r\ncase STV0900_DVBCI_CLOCK:\r\nstv0900_write_reg(intp, R0900_TSGENERAL,\r\n0x06);\r\nstv0900_write_bits(intp,\r\nF0900_P1_TSFIFO_MANSPEED, 3);\r\nstv0900_write_bits(intp,\r\nF0900_P2_TSFIFO_MANSPEED, 0);\r\nstv0900_write_reg(intp,\r\nR0900_P1_TSSPEED, 0x14);\r\nstv0900_write_reg(intp,\r\nR0900_P2_TSSPEED, 0x28);\r\nbreak;\r\n}\r\nbreak;\r\ncase STV0900_SERIAL_PUNCT_CLOCK:\r\ncase STV0900_SERIAL_CONT_CLOCK:\r\ndefault:\r\nswitch (path2_ts) {\r\ncase STV0900_SERIAL_PUNCT_CLOCK:\r\ncase STV0900_SERIAL_CONT_CLOCK:\r\ndefault:\r\nstv0900_write_reg(intp,\r\nR0900_TSGENERAL, 0x0C);\r\nbreak;\r\ncase STV0900_PARALLEL_PUNCT_CLOCK:\r\ncase STV0900_DVBCI_CLOCK:\r\nstv0900_write_reg(intp,\r\nR0900_TSGENERAL, 0x0A);\r\ndprintk("%s: 0x0a\n", __func__);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n} else {\r\nswitch (path1_ts) {\r\ncase STV0900_PARALLEL_PUNCT_CLOCK:\r\ncase STV0900_DVBCI_CLOCK:\r\nswitch (path2_ts) {\r\ncase STV0900_SERIAL_PUNCT_CLOCK:\r\ncase STV0900_SERIAL_CONT_CLOCK:\r\ndefault:\r\nstv0900_write_reg(intp, R0900_TSGENERAL1X,\r\n0x10);\r\nbreak;\r\ncase STV0900_PARALLEL_PUNCT_CLOCK:\r\ncase STV0900_DVBCI_CLOCK:\r\nstv0900_write_reg(intp, R0900_TSGENERAL1X,\r\n0x16);\r\nstv0900_write_bits(intp,\r\nF0900_P1_TSFIFO_MANSPEED, 3);\r\nstv0900_write_bits(intp,\r\nF0900_P2_TSFIFO_MANSPEED, 0);\r\nstv0900_write_reg(intp, R0900_P1_TSSPEED,\r\n0x14);\r\nstv0900_write_reg(intp, R0900_P2_TSSPEED,\r\n0x28);\r\nbreak;\r\n}\r\nbreak;\r\ncase STV0900_SERIAL_PUNCT_CLOCK:\r\ncase STV0900_SERIAL_CONT_CLOCK:\r\ndefault:\r\nswitch (path2_ts) {\r\ncase STV0900_SERIAL_PUNCT_CLOCK:\r\ncase STV0900_SERIAL_CONT_CLOCK:\r\ndefault:\r\nstv0900_write_reg(intp, R0900_TSGENERAL1X,\r\n0x14);\r\nbreak;\r\ncase STV0900_PARALLEL_PUNCT_CLOCK:\r\ncase STV0900_DVBCI_CLOCK:\r\nstv0900_write_reg(intp, R0900_TSGENERAL1X,\r\n0x12);\r\ndprintk("%s: 0x12\n", __func__);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\nswitch (path1_ts) {\r\ncase STV0900_PARALLEL_PUNCT_CLOCK:\r\nstv0900_write_bits(intp, F0900_P1_TSFIFO_SERIAL, 0x00);\r\nstv0900_write_bits(intp, F0900_P1_TSFIFO_DVBCI, 0x00);\r\nbreak;\r\ncase STV0900_DVBCI_CLOCK:\r\nstv0900_write_bits(intp, F0900_P1_TSFIFO_SERIAL, 0x00);\r\nstv0900_write_bits(intp, F0900_P1_TSFIFO_DVBCI, 0x01);\r\nbreak;\r\ncase STV0900_SERIAL_PUNCT_CLOCK:\r\nstv0900_write_bits(intp, F0900_P1_TSFIFO_SERIAL, 0x01);\r\nstv0900_write_bits(intp, F0900_P1_TSFIFO_DVBCI, 0x00);\r\nbreak;\r\ncase STV0900_SERIAL_CONT_CLOCK:\r\nstv0900_write_bits(intp, F0900_P1_TSFIFO_SERIAL, 0x01);\r\nstv0900_write_bits(intp, F0900_P1_TSFIFO_DVBCI, 0x01);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (path2_ts) {\r\ncase STV0900_PARALLEL_PUNCT_CLOCK:\r\nstv0900_write_bits(intp, F0900_P2_TSFIFO_SERIAL, 0x00);\r\nstv0900_write_bits(intp, F0900_P2_TSFIFO_DVBCI, 0x00);\r\nbreak;\r\ncase STV0900_DVBCI_CLOCK:\r\nstv0900_write_bits(intp, F0900_P2_TSFIFO_SERIAL, 0x00);\r\nstv0900_write_bits(intp, F0900_P2_TSFIFO_DVBCI, 0x01);\r\nbreak;\r\ncase STV0900_SERIAL_PUNCT_CLOCK:\r\nstv0900_write_bits(intp, F0900_P2_TSFIFO_SERIAL, 0x01);\r\nstv0900_write_bits(intp, F0900_P2_TSFIFO_DVBCI, 0x00);\r\nbreak;\r\ncase STV0900_SERIAL_CONT_CLOCK:\r\nstv0900_write_bits(intp, F0900_P2_TSFIFO_SERIAL, 0x01);\r\nstv0900_write_bits(intp, F0900_P2_TSFIFO_DVBCI, 0x01);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nstv0900_write_bits(intp, F0900_P2_RST_HWARE, 1);\r\nstv0900_write_bits(intp, F0900_P2_RST_HWARE, 0);\r\nstv0900_write_bits(intp, F0900_P1_RST_HWARE, 1);\r\nstv0900_write_bits(intp, F0900_P1_RST_HWARE, 0);\r\n}\r\nvoid stv0900_set_tuner(struct dvb_frontend *fe, u32 frequency,\r\nu32 bandwidth)\r\n{\r\nstruct dvb_frontend_ops *frontend_ops = NULL;\r\nstruct dvb_tuner_ops *tuner_ops = NULL;\r\nfrontend_ops = &fe->ops;\r\ntuner_ops = &frontend_ops->tuner_ops;\r\nif (tuner_ops->set_frequency) {\r\nif ((tuner_ops->set_frequency(fe, frequency)) < 0)\r\ndprintk("%s: Invalid parameter\n", __func__);\r\nelse\r\ndprintk("%s: Frequency=%d\n", __func__, frequency);\r\n}\r\nif (tuner_ops->set_bandwidth) {\r\nif ((tuner_ops->set_bandwidth(fe, bandwidth)) < 0)\r\ndprintk("%s: Invalid parameter\n", __func__);\r\nelse\r\ndprintk("%s: Bandwidth=%d\n", __func__, bandwidth);\r\n}\r\n}\r\nvoid stv0900_set_bandwidth(struct dvb_frontend *fe, u32 bandwidth)\r\n{\r\nstruct dvb_frontend_ops *frontend_ops = NULL;\r\nstruct dvb_tuner_ops *tuner_ops = NULL;\r\nfrontend_ops = &fe->ops;\r\ntuner_ops = &frontend_ops->tuner_ops;\r\nif (tuner_ops->set_bandwidth) {\r\nif ((tuner_ops->set_bandwidth(fe, bandwidth)) < 0)\r\ndprintk("%s: Invalid parameter\n", __func__);\r\nelse\r\ndprintk("%s: Bandwidth=%d\n", __func__, bandwidth);\r\n}\r\n}\r\nu32 stv0900_get_freq_auto(struct stv0900_internal *intp, int demod)\r\n{\r\nu32 freq, round;\r\nfreq = (stv0900_get_bits(intp, TUN_RFFREQ2) << 10) +\r\n(stv0900_get_bits(intp, TUN_RFFREQ1) << 2) +\r\nstv0900_get_bits(intp, TUN_RFFREQ0);\r\nfreq = (freq * 1000) / 64;\r\nround = (stv0900_get_bits(intp, TUN_RFRESTE1) >> 2) +\r\nstv0900_get_bits(intp, TUN_RFRESTE0);\r\nround = (round * 1000) / 2048;\r\nreturn freq + round;\r\n}\r\nvoid stv0900_set_tuner_auto(struct stv0900_internal *intp, u32 Frequency,\r\nu32 Bandwidth, int demod)\r\n{\r\nu32 tunerFrequency;\r\ntunerFrequency = (Frequency * 64) / 1000;\r\nstv0900_write_bits(intp, TUN_RFFREQ2, (tunerFrequency >> 10));\r\nstv0900_write_bits(intp, TUN_RFFREQ1, (tunerFrequency >> 2) & 0xff);\r\nstv0900_write_bits(intp, TUN_RFFREQ0, (tunerFrequency & 0x03));\r\nstv0900_write_bits(intp, TUN_BW, Bandwidth / 2000000);\r\nstv0900_write_reg(intp, TNRLD, 1);\r\n}\r\nstatic s32 stv0900_get_rf_level(struct stv0900_internal *intp,\r\nconst struct stv0900_table *lookup,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\ns32 agc_gain = 0,\r\nimin,\r\nimax,\r\ni,\r\nrf_lvl = 0;\r\ndprintk("%s\n", __func__);\r\nif ((lookup == NULL) || (lookup->size <= 0))\r\nreturn 0;\r\nagc_gain = MAKEWORD(stv0900_get_bits(intp, AGCIQ_VALUE1),\r\nstv0900_get_bits(intp, AGCIQ_VALUE0));\r\nimin = 0;\r\nimax = lookup->size - 1;\r\nif (INRANGE(lookup->table[imin].regval, agc_gain,\r\nlookup->table[imax].regval)) {\r\nwhile ((imax - imin) > 1) {\r\ni = (imax + imin) >> 1;\r\nif (INRANGE(lookup->table[imin].regval,\r\nagc_gain,\r\nlookup->table[i].regval))\r\nimax = i;\r\nelse\r\nimin = i;\r\n}\r\nrf_lvl = (s32)agc_gain - lookup->table[imin].regval;\r\nrf_lvl *= (lookup->table[imax].realval -\r\nlookup->table[imin].realval);\r\nrf_lvl /= (lookup->table[imax].regval -\r\nlookup->table[imin].regval);\r\nrf_lvl += lookup->table[imin].realval;\r\n} else if (agc_gain > lookup->table[0].regval)\r\nrf_lvl = 5;\r\nelse if (agc_gain < lookup->table[lookup->size-1].regval)\r\nrf_lvl = -100;\r\ndprintk("%s: RFLevel = %d\n", __func__, rf_lvl);\r\nreturn rf_lvl;\r\n}\r\nstatic int stv0900_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *internal = state->internal;\r\ns32 rflevel = stv0900_get_rf_level(internal, &stv0900_rf,\r\nstate->demod);\r\nrflevel = (rflevel + 100) * (65535 / 70);\r\nif (rflevel < 0)\r\nrflevel = 0;\r\nif (rflevel > 65535)\r\nrflevel = 65535;\r\n*strength = rflevel;\r\nreturn 0;\r\n}\r\nstatic s32 stv0900_carr_get_quality(struct dvb_frontend *fe,\r\nconst struct stv0900_table *lookup)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_demod_num demod = state->demod;\r\ns32 c_n = -100,\r\nregval,\r\nimin,\r\nimax,\r\ni,\r\nnoise_field1,\r\nnoise_field0;\r\ndprintk("%s\n", __func__);\r\nif (stv0900_get_standard(fe, demod) == STV0900_DVBS2_STANDARD) {\r\nnoise_field1 = NOSPLHT_NORMED1;\r\nnoise_field0 = NOSPLHT_NORMED0;\r\n} else {\r\nnoise_field1 = NOSDATAT_NORMED1;\r\nnoise_field0 = NOSDATAT_NORMED0;\r\n}\r\nif (stv0900_get_bits(intp, LOCK_DEFINITIF)) {\r\nif ((lookup != NULL) && lookup->size) {\r\nregval = 0;\r\nmsleep(5);\r\nfor (i = 0; i < 16; i++) {\r\nregval += MAKEWORD(stv0900_get_bits(intp,\r\nnoise_field1),\r\nstv0900_get_bits(intp,\r\nnoise_field0));\r\nmsleep(1);\r\n}\r\nregval /= 16;\r\nimin = 0;\r\nimax = lookup->size - 1;\r\nif (INRANGE(lookup->table[imin].regval,\r\nregval,\r\nlookup->table[imax].regval)) {\r\nwhile ((imax - imin) > 1) {\r\ni = (imax + imin) >> 1;\r\nif (INRANGE(lookup->table[imin].regval,\r\nregval,\r\nlookup->table[i].regval))\r\nimax = i;\r\nelse\r\nimin = i;\r\n}\r\nc_n = ((regval - lookup->table[imin].regval)\r\n* (lookup->table[imax].realval\r\n- lookup->table[imin].realval)\r\n/ (lookup->table[imax].regval\r\n- lookup->table[imin].regval))\r\n+ lookup->table[imin].realval;\r\n} else if (regval < lookup->table[imin].regval)\r\nc_n = 1000;\r\n}\r\n}\r\nreturn c_n;\r\n}\r\nstatic int stv0900_read_ucblocks(struct dvb_frontend *fe, u32 * ucblocks)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_demod_num demod = state->demod;\r\nu8 err_val1, err_val0;\r\nu32 header_err_val = 0;\r\n*ucblocks = 0x0;\r\nif (stv0900_get_standard(fe, demod) == STV0900_DVBS2_STANDARD) {\r\nerr_val1 = stv0900_read_reg(intp, BBFCRCKO1);\r\nerr_val0 = stv0900_read_reg(intp, BBFCRCKO0);\r\nheader_err_val = (err_val1 << 8) | err_val0;\r\nerr_val1 = stv0900_read_reg(intp, UPCRCKO1);\r\nerr_val0 = stv0900_read_reg(intp, UPCRCKO0);\r\n*ucblocks = (err_val1 << 8) | err_val0;\r\n*ucblocks += header_err_val;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stv0900_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\ns32 snrlcl = stv0900_carr_get_quality(fe,\r\n(const struct stv0900_table *)&stv0900_s2_cn);\r\nsnrlcl = (snrlcl + 30) * 384;\r\nif (snrlcl < 0)\r\nsnrlcl = 0;\r\nif (snrlcl > 65535)\r\nsnrlcl = 65535;\r\n*snr = snrlcl;\r\nreturn 0;\r\n}\r\nstatic u32 stv0900_get_ber(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\nu32 ber = 10000000, i;\r\ns32 demod_state;\r\ndemod_state = stv0900_get_bits(intp, HEADER_MODE);\r\nswitch (demod_state) {\r\ncase STV0900_SEARCH:\r\ncase STV0900_PLH_DETECTED:\r\ndefault:\r\nber = 10000000;\r\nbreak;\r\ncase STV0900_DVBS_FOUND:\r\nber = 0;\r\nfor (i = 0; i < 5; i++) {\r\nmsleep(5);\r\nber += stv0900_get_err_count(intp, 0, demod);\r\n}\r\nber /= 5;\r\nif (stv0900_get_bits(intp, PRFVIT)) {\r\nber *= 9766;\r\nber = ber >> 13;\r\n}\r\nbreak;\r\ncase STV0900_DVBS2_FOUND:\r\nber = 0;\r\nfor (i = 0; i < 5; i++) {\r\nmsleep(5);\r\nber += stv0900_get_err_count(intp, 0, demod);\r\n}\r\nber /= 5;\r\nif (stv0900_get_bits(intp, PKTDELIN_LOCK)) {\r\nber *= 9766;\r\nber = ber >> 13;\r\n}\r\nbreak;\r\n}\r\nreturn ber;\r\n}\r\nstatic int stv0900_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *internal = state->internal;\r\n*ber = stv0900_get_ber(internal, state->demod);\r\nreturn 0;\r\n}\r\nint stv0900_get_demod_lock(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod, s32 time_out)\r\n{\r\ns32 timer = 0,\r\nlock = 0;\r\nenum fe_stv0900_search_state dmd_state;\r\nwhile ((timer < time_out) && (lock == 0)) {\r\ndmd_state = stv0900_get_bits(intp, HEADER_MODE);\r\ndprintk("Demod State = %d\n", dmd_state);\r\nswitch (dmd_state) {\r\ncase STV0900_SEARCH:\r\ncase STV0900_PLH_DETECTED:\r\ndefault:\r\nlock = 0;\r\nbreak;\r\ncase STV0900_DVBS2_FOUND:\r\ncase STV0900_DVBS_FOUND:\r\nlock = stv0900_get_bits(intp, LOCK_DEFINITIF);\r\nbreak;\r\n}\r\nif (lock == 0)\r\nmsleep(10);\r\ntimer += 10;\r\n}\r\nif (lock)\r\ndprintk("DEMOD LOCK OK\n");\r\nelse\r\ndprintk("DEMOD LOCK FAIL\n");\r\nreturn lock;\r\n}\r\nvoid stv0900_stop_all_s2_modcod(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\ns32 regflist,\r\ni;\r\ndprintk("%s\n", __func__);\r\nregflist = MODCODLST0;\r\nfor (i = 0; i < 16; i++)\r\nstv0900_write_reg(intp, regflist + i, 0xff);\r\n}\r\nvoid stv0900_activate_s2_modcod(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\nu32 matype,\r\nmod_code,\r\nfmod,\r\nreg_index,\r\nfield_index;\r\ndprintk("%s\n", __func__);\r\nif (intp->chip_id <= 0x11) {\r\nmsleep(5);\r\nmod_code = stv0900_read_reg(intp, PLHMODCOD);\r\nmatype = mod_code & 0x3;\r\nmod_code = (mod_code & 0x7f) >> 2;\r\nreg_index = MODCODLSTF - mod_code / 2;\r\nfield_index = mod_code % 2;\r\nswitch (matype) {\r\ncase 0:\r\ndefault:\r\nfmod = 14;\r\nbreak;\r\ncase 1:\r\nfmod = 13;\r\nbreak;\r\ncase 2:\r\nfmod = 11;\r\nbreak;\r\ncase 3:\r\nfmod = 7;\r\nbreak;\r\n}\r\nif ((INRANGE(STV0900_QPSK_12, mod_code, STV0900_8PSK_910))\r\n&& (matype <= 1)) {\r\nif (field_index == 0)\r\nstv0900_write_reg(intp, reg_index,\r\n0xf0 | fmod);\r\nelse\r\nstv0900_write_reg(intp, reg_index,\r\n(fmod << 4) | 0xf);\r\n}\r\n} else if (intp->chip_id >= 0x12) {\r\nfor (reg_index = 0; reg_index < 7; reg_index++)\r\nstv0900_write_reg(intp, MODCODLST0 + reg_index, 0xff);\r\nstv0900_write_reg(intp, MODCODLSTE, 0xff);\r\nstv0900_write_reg(intp, MODCODLSTF, 0xcf);\r\nfor (reg_index = 0; reg_index < 8; reg_index++)\r\nstv0900_write_reg(intp, MODCODLST7 + reg_index, 0xcc);\r\n}\r\n}\r\nvoid stv0900_activate_s2_modcod_single(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\nu32 reg_index;\r\ndprintk("%s\n", __func__);\r\nstv0900_write_reg(intp, MODCODLST0, 0xff);\r\nstv0900_write_reg(intp, MODCODLST1, 0xf0);\r\nstv0900_write_reg(intp, MODCODLSTF, 0x0f);\r\nfor (reg_index = 0; reg_index < 13; reg_index++)\r\nstv0900_write_reg(intp, MODCODLST2 + reg_index, 0);\r\n}\r\nstatic enum dvbfe_algo stv0900_frontend_algo(struct dvb_frontend *fe)\r\n{\r\nreturn DVBFE_ALGO_CUSTOM;\r\n}\r\nvoid stv0900_start_search(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\nu32 freq;\r\ns16 freq_s16 ;\r\nstv0900_write_bits(intp, DEMOD_MODE, 0x1f);\r\nif (intp->chip_id == 0x10)\r\nstv0900_write_reg(intp, CORRELEXP, 0xaa);\r\nif (intp->chip_id < 0x20)\r\nstv0900_write_reg(intp, CARHDR, 0x55);\r\nif (intp->chip_id <= 0x20) {\r\nif (intp->symbol_rate[0] <= 5000000) {\r\nstv0900_write_reg(intp, CARCFG, 0x44);\r\nstv0900_write_reg(intp, CFRUP1, 0x0f);\r\nstv0900_write_reg(intp, CFRUP0, 0xff);\r\nstv0900_write_reg(intp, CFRLOW1, 0xf0);\r\nstv0900_write_reg(intp, CFRLOW0, 0x00);\r\nstv0900_write_reg(intp, RTCS2, 0x68);\r\n} else {\r\nstv0900_write_reg(intp, CARCFG, 0xc4);\r\nstv0900_write_reg(intp, RTCS2, 0x44);\r\n}\r\n} else {\r\nif (intp->symbol_rate[demod] <= 5000000)\r\nstv0900_write_reg(intp, RTCS2, 0x68);\r\nelse\r\nstv0900_write_reg(intp, RTCS2, 0x44);\r\nstv0900_write_reg(intp, CARCFG, 0x46);\r\nif (intp->srch_algo[demod] == STV0900_WARM_START) {\r\nfreq = 1000 << 16;\r\nfreq /= (intp->mclk / 1000);\r\nfreq_s16 = (s16)freq;\r\n} else {\r\nfreq = (intp->srch_range[demod] / 2000);\r\nif (intp->symbol_rate[demod] <= 5000000)\r\nfreq += 80;\r\nelse\r\nfreq += 600;\r\nfreq = freq << 16;\r\nfreq /= (intp->mclk / 1000);\r\nfreq_s16 = (s16)freq;\r\n}\r\nstv0900_write_bits(intp, CFR_UP1, MSB(freq_s16));\r\nstv0900_write_bits(intp, CFR_UP0, LSB(freq_s16));\r\nfreq_s16 *= (-1);\r\nstv0900_write_bits(intp, CFR_LOW1, MSB(freq_s16));\r\nstv0900_write_bits(intp, CFR_LOW0, LSB(freq_s16));\r\n}\r\nstv0900_write_reg(intp, CFRINIT1, 0);\r\nstv0900_write_reg(intp, CFRINIT0, 0);\r\nif (intp->chip_id >= 0x20) {\r\nstv0900_write_reg(intp, EQUALCFG, 0x41);\r\nstv0900_write_reg(intp, FFECFG, 0x41);\r\nif ((intp->srch_standard[demod] == STV0900_SEARCH_DVBS1) ||\r\n(intp->srch_standard[demod] == STV0900_SEARCH_DSS) ||\r\n(intp->srch_standard[demod] == STV0900_AUTO_SEARCH)) {\r\nstv0900_write_reg(intp, VITSCALE,\r\n0x82);\r\nstv0900_write_reg(intp, VAVSRVIT, 0x0);\r\n}\r\n}\r\nstv0900_write_reg(intp, SFRSTEP, 0x00);\r\nstv0900_write_reg(intp, TMGTHRISE, 0xe0);\r\nstv0900_write_reg(intp, TMGTHFALL, 0xc0);\r\nstv0900_write_bits(intp, SCAN_ENABLE, 0);\r\nstv0900_write_bits(intp, CFR_AUTOSCAN, 0);\r\nstv0900_write_bits(intp, S1S2_SEQUENTIAL, 0);\r\nstv0900_write_reg(intp, RTC, 0x88);\r\nif (intp->chip_id >= 0x20) {\r\nif (intp->symbol_rate[demod] < 2000000) {\r\nif (intp->chip_id <= 0x20)\r\nstv0900_write_reg(intp, CARFREQ, 0x39);\r\nelse\r\nstv0900_write_reg(intp, CARFREQ, 0x89);\r\nstv0900_write_reg(intp, CARHDR, 0x40);\r\n} else if (intp->symbol_rate[demod] < 10000000) {\r\nstv0900_write_reg(intp, CARFREQ, 0x4c);\r\nstv0900_write_reg(intp, CARHDR, 0x20);\r\n} else {\r\nstv0900_write_reg(intp, CARFREQ, 0x4b);\r\nstv0900_write_reg(intp, CARHDR, 0x20);\r\n}\r\n} else {\r\nif (intp->symbol_rate[demod] < 10000000)\r\nstv0900_write_reg(intp, CARFREQ, 0xef);\r\nelse\r\nstv0900_write_reg(intp, CARFREQ, 0xed);\r\n}\r\nswitch (intp->srch_algo[demod]) {\r\ncase STV0900_WARM_START:\r\nstv0900_write_reg(intp, DMDISTATE, 0x1f);\r\nstv0900_write_reg(intp, DMDISTATE, 0x18);\r\nbreak;\r\ncase STV0900_COLD_START:\r\nstv0900_write_reg(intp, DMDISTATE, 0x1f);\r\nstv0900_write_reg(intp, DMDISTATE, 0x15);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nu8 stv0900_get_optim_carr_loop(s32 srate, enum fe_stv0900_modcode modcode,\r\ns32 pilot, u8 chip_id)\r\n{\r\nu8 aclc_value = 0x29;\r\ns32 i;\r\nconst struct stv0900_car_loop_optim *cls2, *cllqs2, *cllas2;\r\ndprintk("%s\n", __func__);\r\nif (chip_id <= 0x12) {\r\ncls2 = FE_STV0900_S2CarLoop;\r\ncllqs2 = FE_STV0900_S2LowQPCarLoopCut30;\r\ncllas2 = FE_STV0900_S2APSKCarLoopCut30;\r\n} else if (chip_id == 0x20) {\r\ncls2 = FE_STV0900_S2CarLoopCut20;\r\ncllqs2 = FE_STV0900_S2LowQPCarLoopCut20;\r\ncllas2 = FE_STV0900_S2APSKCarLoopCut20;\r\n} else {\r\ncls2 = FE_STV0900_S2CarLoopCut30;\r\ncllqs2 = FE_STV0900_S2LowQPCarLoopCut30;\r\ncllas2 = FE_STV0900_S2APSKCarLoopCut30;\r\n}\r\nif (modcode < STV0900_QPSK_12) {\r\ni = 0;\r\nwhile ((i < 3) && (modcode != cllqs2[i].modcode))\r\ni++;\r\nif (i >= 3)\r\ni = 2;\r\n} else {\r\ni = 0;\r\nwhile ((i < 14) && (modcode != cls2[i].modcode))\r\ni++;\r\nif (i >= 14) {\r\ni = 0;\r\nwhile ((i < 11) && (modcode != cllas2[i].modcode))\r\ni++;\r\nif (i >= 11)\r\ni = 10;\r\n}\r\n}\r\nif (modcode <= STV0900_QPSK_25) {\r\nif (pilot) {\r\nif (srate <= 3000000)\r\naclc_value = cllqs2[i].car_loop_pilots_on_2;\r\nelse if (srate <= 7000000)\r\naclc_value = cllqs2[i].car_loop_pilots_on_5;\r\nelse if (srate <= 15000000)\r\naclc_value = cllqs2[i].car_loop_pilots_on_10;\r\nelse if (srate <= 25000000)\r\naclc_value = cllqs2[i].car_loop_pilots_on_20;\r\nelse\r\naclc_value = cllqs2[i].car_loop_pilots_on_30;\r\n} else {\r\nif (srate <= 3000000)\r\naclc_value = cllqs2[i].car_loop_pilots_off_2;\r\nelse if (srate <= 7000000)\r\naclc_value = cllqs2[i].car_loop_pilots_off_5;\r\nelse if (srate <= 15000000)\r\naclc_value = cllqs2[i].car_loop_pilots_off_10;\r\nelse if (srate <= 25000000)\r\naclc_value = cllqs2[i].car_loop_pilots_off_20;\r\nelse\r\naclc_value = cllqs2[i].car_loop_pilots_off_30;\r\n}\r\n} else if (modcode <= STV0900_8PSK_910) {\r\nif (pilot) {\r\nif (srate <= 3000000)\r\naclc_value = cls2[i].car_loop_pilots_on_2;\r\nelse if (srate <= 7000000)\r\naclc_value = cls2[i].car_loop_pilots_on_5;\r\nelse if (srate <= 15000000)\r\naclc_value = cls2[i].car_loop_pilots_on_10;\r\nelse if (srate <= 25000000)\r\naclc_value = cls2[i].car_loop_pilots_on_20;\r\nelse\r\naclc_value = cls2[i].car_loop_pilots_on_30;\r\n} else {\r\nif (srate <= 3000000)\r\naclc_value = cls2[i].car_loop_pilots_off_2;\r\nelse if (srate <= 7000000)\r\naclc_value = cls2[i].car_loop_pilots_off_5;\r\nelse if (srate <= 15000000)\r\naclc_value = cls2[i].car_loop_pilots_off_10;\r\nelse if (srate <= 25000000)\r\naclc_value = cls2[i].car_loop_pilots_off_20;\r\nelse\r\naclc_value = cls2[i].car_loop_pilots_off_30;\r\n}\r\n} else {\r\nif (srate <= 3000000)\r\naclc_value = cllas2[i].car_loop_pilots_on_2;\r\nelse if (srate <= 7000000)\r\naclc_value = cllas2[i].car_loop_pilots_on_5;\r\nelse if (srate <= 15000000)\r\naclc_value = cllas2[i].car_loop_pilots_on_10;\r\nelse if (srate <= 25000000)\r\naclc_value = cllas2[i].car_loop_pilots_on_20;\r\nelse\r\naclc_value = cllas2[i].car_loop_pilots_on_30;\r\n}\r\nreturn aclc_value;\r\n}\r\nu8 stv0900_get_optim_short_carr_loop(s32 srate,\r\nenum fe_stv0900_modulation modulation,\r\nu8 chip_id)\r\n{\r\nconst struct stv0900_short_frames_car_loop_optim *s2scl;\r\nconst struct stv0900_short_frames_car_loop_optim_vs_mod *s2sclc30;\r\ns32 mod_index = 0;\r\nu8 aclc_value = 0x0b;\r\ndprintk("%s\n", __func__);\r\ns2scl = FE_STV0900_S2ShortCarLoop;\r\ns2sclc30 = FE_STV0900_S2ShortCarLoopCut30;\r\nswitch (modulation) {\r\ncase STV0900_QPSK:\r\ndefault:\r\nmod_index = 0;\r\nbreak;\r\ncase STV0900_8PSK:\r\nmod_index = 1;\r\nbreak;\r\ncase STV0900_16APSK:\r\nmod_index = 2;\r\nbreak;\r\ncase STV0900_32APSK:\r\nmod_index = 3;\r\nbreak;\r\n}\r\nif (chip_id >= 0x30) {\r\nif (srate <= 3000000)\r\naclc_value = s2sclc30[mod_index].car_loop_2;\r\nelse if (srate <= 7000000)\r\naclc_value = s2sclc30[mod_index].car_loop_5;\r\nelse if (srate <= 15000000)\r\naclc_value = s2sclc30[mod_index].car_loop_10;\r\nelse if (srate <= 25000000)\r\naclc_value = s2sclc30[mod_index].car_loop_20;\r\nelse\r\naclc_value = s2sclc30[mod_index].car_loop_30;\r\n} else if (chip_id >= 0x20) {\r\nif (srate <= 3000000)\r\naclc_value = s2scl[mod_index].car_loop_cut20_2;\r\nelse if (srate <= 7000000)\r\naclc_value = s2scl[mod_index].car_loop_cut20_5;\r\nelse if (srate <= 15000000)\r\naclc_value = s2scl[mod_index].car_loop_cut20_10;\r\nelse if (srate <= 25000000)\r\naclc_value = s2scl[mod_index].car_loop_cut20_20;\r\nelse\r\naclc_value = s2scl[mod_index].car_loop_cut20_30;\r\n} else {\r\nif (srate <= 3000000)\r\naclc_value = s2scl[mod_index].car_loop_cut12_2;\r\nelse if (srate <= 7000000)\r\naclc_value = s2scl[mod_index].car_loop_cut12_5;\r\nelse if (srate <= 15000000)\r\naclc_value = s2scl[mod_index].car_loop_cut12_10;\r\nelse if (srate <= 25000000)\r\naclc_value = s2scl[mod_index].car_loop_cut12_20;\r\nelse\r\naclc_value = s2scl[mod_index].car_loop_cut12_30;\r\n}\r\nreturn aclc_value;\r\n}\r\nstatic\r\nenum fe_stv0900_error stv0900_st_dvbs2_single(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_mode LDPC_Mode,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\ns32 reg_ind;\r\ndprintk("%s\n", __func__);\r\nswitch (LDPC_Mode) {\r\ncase STV0900_DUAL:\r\ndefault:\r\nif ((intp->demod_mode != STV0900_DUAL)\r\n|| (stv0900_get_bits(intp, F0900_DDEMOD) != 1)) {\r\nstv0900_write_reg(intp, R0900_GENCFG, 0x1d);\r\nintp->demod_mode = STV0900_DUAL;\r\nstv0900_write_bits(intp, F0900_FRESFEC, 1);\r\nstv0900_write_bits(intp, F0900_FRESFEC, 0);\r\nfor (reg_ind = 0; reg_ind < 7; reg_ind++)\r\nstv0900_write_reg(intp,\r\nR0900_P1_MODCODLST0 + reg_ind,\r\n0xff);\r\nfor (reg_ind = 0; reg_ind < 8; reg_ind++)\r\nstv0900_write_reg(intp,\r\nR0900_P1_MODCODLST7 + reg_ind,\r\n0xcc);\r\nstv0900_write_reg(intp, R0900_P1_MODCODLSTE, 0xff);\r\nstv0900_write_reg(intp, R0900_P1_MODCODLSTF, 0xcf);\r\nfor (reg_ind = 0; reg_ind < 7; reg_ind++)\r\nstv0900_write_reg(intp,\r\nR0900_P2_MODCODLST0 + reg_ind,\r\n0xff);\r\nfor (reg_ind = 0; reg_ind < 8; reg_ind++)\r\nstv0900_write_reg(intp,\r\nR0900_P2_MODCODLST7 + reg_ind,\r\n0xcc);\r\nstv0900_write_reg(intp, R0900_P2_MODCODLSTE, 0xff);\r\nstv0900_write_reg(intp, R0900_P2_MODCODLSTF, 0xcf);\r\n}\r\nbreak;\r\ncase STV0900_SINGLE:\r\nif (demod == STV0900_DEMOD_2) {\r\nstv0900_stop_all_s2_modcod(intp, STV0900_DEMOD_1);\r\nstv0900_activate_s2_modcod_single(intp,\r\nSTV0900_DEMOD_2);\r\nstv0900_write_reg(intp, R0900_GENCFG, 0x06);\r\n} else {\r\nstv0900_stop_all_s2_modcod(intp, STV0900_DEMOD_2);\r\nstv0900_activate_s2_modcod_single(intp,\r\nSTV0900_DEMOD_1);\r\nstv0900_write_reg(intp, R0900_GENCFG, 0x04);\r\n}\r\nintp->demod_mode = STV0900_SINGLE;\r\nstv0900_write_bits(intp, F0900_FRESFEC, 1);\r\nstv0900_write_bits(intp, F0900_FRESFEC, 0);\r\nstv0900_write_bits(intp, F0900_P1_ALGOSWRST, 1);\r\nstv0900_write_bits(intp, F0900_P1_ALGOSWRST, 0);\r\nstv0900_write_bits(intp, F0900_P2_ALGOSWRST, 1);\r\nstv0900_write_bits(intp, F0900_P2_ALGOSWRST, 0);\r\nbreak;\r\n}\r\nreturn STV0900_NO_ERROR;\r\n}\r\nstatic enum fe_stv0900_error stv0900_init_internal(struct dvb_frontend *fe,\r\nstruct stv0900_init_params *p_init)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nenum fe_stv0900_error error = STV0900_NO_ERROR;\r\nenum fe_stv0900_error demodError = STV0900_NO_ERROR;\r\nstruct stv0900_internal *intp = NULL;\r\nint selosci, i;\r\nstruct stv0900_inode *temp_int = find_inode(state->i2c_adap,\r\nstate->config->demod_address);\r\ndprintk("%s\n", __func__);\r\nif ((temp_int != NULL) && (p_init->demod_mode == STV0900_DUAL)) {\r\nstate->internal = temp_int->internal;\r\n(state->internal->dmds_used)++;\r\ndprintk("%s: Find Internal Structure!\n", __func__);\r\nreturn STV0900_NO_ERROR;\r\n} else {\r\nstate->internal = kmalloc(sizeof(struct stv0900_internal),\r\nGFP_KERNEL);\r\nif (state->internal == NULL)\r\nreturn STV0900_INVALID_HANDLE;\r\ntemp_int = append_internal(state->internal);\r\nif (temp_int == NULL) {\r\nkfree(state->internal);\r\nstate->internal = NULL;\r\nreturn STV0900_INVALID_HANDLE;\r\n}\r\nstate->internal->dmds_used = 1;\r\nstate->internal->i2c_adap = state->i2c_adap;\r\nstate->internal->i2c_addr = state->config->demod_address;\r\nstate->internal->clkmode = state->config->clkmode;\r\nstate->internal->errs = STV0900_NO_ERROR;\r\ndprintk("%s: Create New Internal Structure!\n", __func__);\r\n}\r\nif (state->internal == NULL) {\r\nerror = STV0900_INVALID_HANDLE;\r\nreturn error;\r\n}\r\ndemodError = stv0900_initialize(state->internal);\r\nif (demodError == STV0900_NO_ERROR) {\r\nerror = STV0900_NO_ERROR;\r\n} else {\r\nif (demodError == STV0900_INVALID_HANDLE)\r\nerror = STV0900_INVALID_HANDLE;\r\nelse\r\nerror = STV0900_I2C_ERROR;\r\nreturn error;\r\n}\r\nintp = state->internal;\r\nintp->demod_mode = p_init->demod_mode;\r\nstv0900_st_dvbs2_single(intp, intp->demod_mode, STV0900_DEMOD_1);\r\nintp->chip_id = stv0900_read_reg(intp, R0900_MID);\r\nintp->rolloff = p_init->rolloff;\r\nintp->quartz = p_init->dmd_ref_clk;\r\nstv0900_write_bits(intp, F0900_P1_ROLLOFF_CONTROL, p_init->rolloff);\r\nstv0900_write_bits(intp, F0900_P2_ROLLOFF_CONTROL, p_init->rolloff);\r\nintp->ts_config = p_init->ts_config;\r\nif (intp->ts_config == NULL)\r\nstv0900_set_ts_parallel_serial(intp,\r\np_init->path1_ts_clock,\r\np_init->path2_ts_clock);\r\nelse {\r\nfor (i = 0; intp->ts_config[i].addr != 0xffff; i++)\r\nstv0900_write_reg(intp,\r\nintp->ts_config[i].addr,\r\nintp->ts_config[i].val);\r\nstv0900_write_bits(intp, F0900_P2_RST_HWARE, 1);\r\nstv0900_write_bits(intp, F0900_P2_RST_HWARE, 0);\r\nstv0900_write_bits(intp, F0900_P1_RST_HWARE, 1);\r\nstv0900_write_bits(intp, F0900_P1_RST_HWARE, 0);\r\n}\r\nintp->tuner_type[0] = p_init->tuner1_type;\r\nintp->tuner_type[1] = p_init->tuner2_type;\r\nswitch (p_init->tuner1_type) {\r\ncase 3:\r\nstv0900_write_reg(intp, R0900_P1_TNRCFG, 0x3c);\r\nstv0900_write_reg(intp, R0900_P1_TNRCFG2, 0x86);\r\nstv0900_write_reg(intp, R0900_P1_TNRCFG3, 0x18);\r\nstv0900_write_reg(intp, R0900_P1_TNRXTAL, 27);\r\nstv0900_write_reg(intp, R0900_P1_TNRSTEPS, 0x05);\r\nstv0900_write_reg(intp, R0900_P1_TNRGAIN, 0x17);\r\nstv0900_write_reg(intp, R0900_P1_TNRADJ, 0x1f);\r\nstv0900_write_reg(intp, R0900_P1_TNRCTL2, 0x0);\r\nstv0900_write_bits(intp, F0900_P1_TUN_TYPE, 3);\r\nbreak;\r\ndefault:\r\nstv0900_write_bits(intp, F0900_P1_TUN_TYPE, 6);\r\nbreak;\r\n}\r\nstv0900_write_bits(intp, F0900_P1_TUN_MADDRESS, p_init->tun1_maddress);\r\nswitch (p_init->tuner1_adc) {\r\ncase 1:\r\nstv0900_write_reg(intp, R0900_TSTTNR1, 0x26);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nstv0900_write_reg(intp, R0900_P1_TNRLD, 1);\r\nswitch (p_init->tuner2_type) {\r\ncase 3:\r\nstv0900_write_reg(intp, R0900_P2_TNRCFG, 0x3c);\r\nstv0900_write_reg(intp, R0900_P2_TNRCFG2, 0x86);\r\nstv0900_write_reg(intp, R0900_P2_TNRCFG3, 0x18);\r\nstv0900_write_reg(intp, R0900_P2_TNRXTAL, 27);\r\nstv0900_write_reg(intp, R0900_P2_TNRSTEPS, 0x05);\r\nstv0900_write_reg(intp, R0900_P2_TNRGAIN, 0x17);\r\nstv0900_write_reg(intp, R0900_P2_TNRADJ, 0x1f);\r\nstv0900_write_reg(intp, R0900_P2_TNRCTL2, 0x0);\r\nstv0900_write_bits(intp, F0900_P2_TUN_TYPE, 3);\r\nbreak;\r\ndefault:\r\nstv0900_write_bits(intp, F0900_P2_TUN_TYPE, 6);\r\nbreak;\r\n}\r\nstv0900_write_bits(intp, F0900_P2_TUN_MADDRESS, p_init->tun2_maddress);\r\nswitch (p_init->tuner2_adc) {\r\ncase 1:\r\nstv0900_write_reg(intp, R0900_TSTTNR3, 0x26);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nstv0900_write_reg(intp, R0900_P2_TNRLD, 1);\r\nstv0900_write_bits(intp, F0900_P1_TUN_IQSWAP, p_init->tun1_iq_inv);\r\nstv0900_write_bits(intp, F0900_P2_TUN_IQSWAP, p_init->tun2_iq_inv);\r\nstv0900_set_mclk(intp, 135000000);\r\nmsleep(3);\r\nswitch (intp->clkmode) {\r\ncase 0:\r\ncase 2:\r\nstv0900_write_reg(intp, R0900_SYNTCTRL, 0x20 | intp->clkmode);\r\nbreak;\r\ndefault:\r\nselosci = 0x02 & stv0900_read_reg(intp, R0900_SYNTCTRL);\r\nstv0900_write_reg(intp, R0900_SYNTCTRL, 0x20 | selosci);\r\nbreak;\r\n}\r\nmsleep(3);\r\nintp->mclk = stv0900_get_mclk_freq(intp, intp->quartz);\r\nif (intp->errs)\r\nerror = STV0900_I2C_ERROR;\r\nreturn error;\r\n}\r\nstatic int stv0900_status(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod)\r\n{\r\nenum fe_stv0900_search_state demod_state;\r\nint locked = FALSE;\r\nu8 tsbitrate0_val, tsbitrate1_val;\r\ns32 bitrate;\r\ndemod_state = stv0900_get_bits(intp, HEADER_MODE);\r\nswitch (demod_state) {\r\ncase STV0900_SEARCH:\r\ncase STV0900_PLH_DETECTED:\r\ndefault:\r\nlocked = FALSE;\r\nbreak;\r\ncase STV0900_DVBS2_FOUND:\r\nlocked = stv0900_get_bits(intp, LOCK_DEFINITIF) &&\r\nstv0900_get_bits(intp, PKTDELIN_LOCK) &&\r\nstv0900_get_bits(intp, TSFIFO_LINEOK);\r\nbreak;\r\ncase STV0900_DVBS_FOUND:\r\nlocked = stv0900_get_bits(intp, LOCK_DEFINITIF) &&\r\nstv0900_get_bits(intp, LOCKEDVIT) &&\r\nstv0900_get_bits(intp, TSFIFO_LINEOK);\r\nbreak;\r\n}\r\ndprintk("%s: locked = %d\n", __func__, locked);\r\nif (stvdebug) {\r\ntsbitrate0_val = stv0900_read_reg(intp, TSBITRATE0);\r\ntsbitrate1_val = stv0900_read_reg(intp, TSBITRATE1);\r\nbitrate = (stv0900_get_mclk_freq(intp, intp->quartz)/1000000)\r\n* (tsbitrate1_val << 8 | tsbitrate0_val);\r\nbitrate /= 16384;\r\ndprintk("TS bitrate = %d Mbit/sec\n", bitrate);\r\n}\r\nreturn locked;\r\n}\r\nstatic int stv0900_set_mis(struct stv0900_internal *intp,\r\nenum fe_stv0900_demod_num demod, int mis)\r\n{\r\ndprintk("%s\n", __func__);\r\nif (mis < 0 || mis > 255) {\r\ndprintk("Disable MIS filtering\n");\r\nstv0900_write_bits(intp, FILTER_EN, 0);\r\n} else {\r\ndprintk("Enable MIS filtering - %d\n", mis);\r\nstv0900_write_bits(intp, FILTER_EN, 1);\r\nstv0900_write_reg(intp, ISIENTRY, mis);\r\nstv0900_write_reg(intp, ISIBITENA, 0xff);\r\n}\r\nreturn STV0900_NO_ERROR;\r\n}\r\nstatic enum dvbfe_search stv0900_search(struct dvb_frontend *fe)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_demod_num demod = state->demod;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct stv0900_search_params p_search;\r\nstruct stv0900_signal_info p_result = intp->result[demod];\r\nenum fe_stv0900_error error = STV0900_NO_ERROR;\r\ndprintk("%s: ", __func__);\r\nif (!(INRANGE(100000, c->symbol_rate, 70000000)))\r\nreturn DVBFE_ALGO_SEARCH_FAILED;\r\nif (state->config->set_ts_params)\r\nstate->config->set_ts_params(fe, 0);\r\nstv0900_set_mis(intp, demod, c->stream_id);\r\np_result.locked = FALSE;\r\np_search.path = demod;\r\np_search.frequency = c->frequency;\r\np_search.symbol_rate = c->symbol_rate;\r\np_search.search_range = 10000000;\r\np_search.fec = STV0900_FEC_UNKNOWN;\r\np_search.standard = STV0900_AUTO_SEARCH;\r\np_search.iq_inversion = STV0900_IQ_AUTO;\r\np_search.search_algo = STV0900_BLIND_SEARCH;\r\nif (c->delivery_system == SYS_DVBS)\r\np_search.standard = STV0900_SEARCH_DVBS1;\r\nintp->srch_standard[demod] = p_search.standard;\r\nintp->symbol_rate[demod] = p_search.symbol_rate;\r\nintp->srch_range[demod] = p_search.search_range;\r\nintp->freq[demod] = p_search.frequency;\r\nintp->srch_algo[demod] = p_search.search_algo;\r\nintp->srch_iq_inv[demod] = p_search.iq_inversion;\r\nintp->fec[demod] = p_search.fec;\r\nif ((stv0900_algo(fe) == STV0900_RANGEOK) &&\r\n(intp->errs == STV0900_NO_ERROR)) {\r\np_result.locked = intp->result[demod].locked;\r\np_result.standard = intp->result[demod].standard;\r\np_result.frequency = intp->result[demod].frequency;\r\np_result.symbol_rate = intp->result[demod].symbol_rate;\r\np_result.fec = intp->result[demod].fec;\r\np_result.modcode = intp->result[demod].modcode;\r\np_result.pilot = intp->result[demod].pilot;\r\np_result.frame_len = intp->result[demod].frame_len;\r\np_result.spectrum = intp->result[demod].spectrum;\r\np_result.rolloff = intp->result[demod].rolloff;\r\np_result.modulation = intp->result[demod].modulation;\r\n} else {\r\np_result.locked = FALSE;\r\nswitch (intp->err[demod]) {\r\ncase STV0900_I2C_ERROR:\r\nerror = STV0900_I2C_ERROR;\r\nbreak;\r\ncase STV0900_NO_ERROR:\r\ndefault:\r\nerror = STV0900_SEARCH_FAILED;\r\nbreak;\r\n}\r\n}\r\nif ((p_result.locked == TRUE) && (error == STV0900_NO_ERROR)) {\r\ndprintk("Search Success\n");\r\nreturn DVBFE_ALGO_SEARCH_SUCCESS;\r\n} else {\r\ndprintk("Search Fail\n");\r\nreturn DVBFE_ALGO_SEARCH_FAILED;\r\n}\r\n}\r\nstatic int stv0900_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\ndprintk("%s: ", __func__);\r\nif ((stv0900_status(state->internal, state->demod)) == TRUE) {\r\ndprintk("DEMOD LOCK OK\n");\r\n*status = FE_HAS_CARRIER\r\n| FE_HAS_VITERBI\r\n| FE_HAS_SYNC\r\n| FE_HAS_LOCK;\r\nif (state->config->set_lock_led)\r\nstate->config->set_lock_led(fe, 1);\r\n} else {\r\n*status = 0;\r\nif (state->config->set_lock_led)\r\nstate->config->set_lock_led(fe, 0);\r\ndprintk("DEMOD LOCK FAIL\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int stv0900_stop_ts(struct dvb_frontend *fe, int stop_ts)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_demod_num demod = state->demod;\r\nif (stop_ts == TRUE)\r\nstv0900_write_bits(intp, RST_HWARE, 1);\r\nelse\r\nstv0900_write_bits(intp, RST_HWARE, 0);\r\nreturn 0;\r\n}\r\nstatic int stv0900_diseqc_init(struct dvb_frontend *fe)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_demod_num demod = state->demod;\r\nstv0900_write_bits(intp, DISTX_MODE, state->config->diseqc_mode);\r\nstv0900_write_bits(intp, DISEQC_RESET, 1);\r\nstv0900_write_bits(intp, DISEQC_RESET, 0);\r\nreturn 0;\r\n}\r\nstatic int stv0900_init(struct dvb_frontend *fe)\r\n{\r\ndprintk("%s\n", __func__);\r\nstv0900_stop_ts(fe, 1);\r\nstv0900_diseqc_init(fe);\r\nreturn 0;\r\n}\r\nstatic int stv0900_diseqc_send(struct stv0900_internal *intp , u8 *data,\r\nu32 NbData, enum fe_stv0900_demod_num demod)\r\n{\r\ns32 i = 0;\r\nstv0900_write_bits(intp, DIS_PRECHARGE, 1);\r\nwhile (i < NbData) {\r\nwhile (stv0900_get_bits(intp, FIFO_FULL))\r\n;\r\nstv0900_write_reg(intp, DISTXDATA, data[i]);\r\ni++;\r\n}\r\nstv0900_write_bits(intp, DIS_PRECHARGE, 0);\r\ni = 0;\r\nwhile ((stv0900_get_bits(intp, TX_IDLE) != 1) && (i < 10)) {\r\nmsleep(10);\r\ni++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stv0900_send_master_cmd(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_master_cmd *cmd)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nreturn stv0900_diseqc_send(state->internal,\r\ncmd->msg,\r\ncmd->msg_len,\r\nstate->demod);\r\n}\r\nstatic int stv0900_send_burst(struct dvb_frontend *fe, fe_sec_mini_cmd_t burst)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_demod_num demod = state->demod;\r\nu8 data;\r\nswitch (burst) {\r\ncase SEC_MINI_A:\r\nstv0900_write_bits(intp, DISTX_MODE, 3);\r\ndata = 0x00;\r\nstv0900_diseqc_send(intp, &data, 1, state->demod);\r\nbreak;\r\ncase SEC_MINI_B:\r\nstv0900_write_bits(intp, DISTX_MODE, 2);\r\ndata = 0xff;\r\nstv0900_diseqc_send(intp, &data, 1, state->demod);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stv0900_recv_slave_reply(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_slave_reply *reply)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_demod_num demod = state->demod;\r\ns32 i = 0;\r\nreply->msg_len = 0;\r\nwhile ((stv0900_get_bits(intp, RX_END) != 1) && (i < 10)) {\r\nmsleep(10);\r\ni++;\r\n}\r\nif (stv0900_get_bits(intp, RX_END)) {\r\nreply->msg_len = stv0900_get_bits(intp, FIFO_BYTENBR);\r\nfor (i = 0; i < reply->msg_len; i++)\r\nreply->msg[i] = stv0900_read_reg(intp, DISRXDATA);\r\n}\r\nreturn 0;\r\n}\r\nstatic int stv0900_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t toneoff)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_demod_num demod = state->demod;\r\ndprintk("%s: %s\n", __func__, ((toneoff == 0) ? "On" : "Off"));\r\nswitch (toneoff) {\r\ncase SEC_TONE_ON:\r\nstv0900_write_bits(intp, DISTX_MODE, 0);\r\nstv0900_write_bits(intp, DISEQC_RESET, 1);\r\nstv0900_write_bits(intp, DISEQC_RESET, 0);\r\nbreak;\r\ncase SEC_TONE_OFF:\r\nstv0900_write_bits(intp, DISTX_MODE,\r\nstate->config->diseqc_mode);\r\nstv0900_write_bits(intp, DISEQC_RESET, 1);\r\nstv0900_write_bits(intp, DISEQC_RESET, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void stv0900_release(struct dvb_frontend *fe)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\ndprintk("%s\n", __func__);\r\nif (state->config->set_lock_led)\r\nstate->config->set_lock_led(fe, 0);\r\nif ((--(state->internal->dmds_used)) <= 0) {\r\ndprintk("%s: Actually removing\n", __func__);\r\nremove_inode(state->internal);\r\nkfree(state->internal);\r\n}\r\nkfree(state);\r\n}\r\nstatic int stv0900_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\ndprintk("%s\n", __func__);\r\nif (state->config->set_lock_led)\r\nstate->config->set_lock_led(fe, 0);\r\nreturn 0;\r\n}\r\nstatic int stv0900_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct stv0900_state *state = fe->demodulator_priv;\r\nstruct stv0900_internal *intp = state->internal;\r\nenum fe_stv0900_demod_num demod = state->demod;\r\nstruct stv0900_signal_info p_result = intp->result[demod];\r\np->frequency = p_result.locked ? p_result.frequency : 0;\r\np->symbol_rate = p_result.locked ? p_result.symbol_rate : 0;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *stv0900_attach(const struct stv0900_config *config,\r\nstruct i2c_adapter *i2c,\r\nint demod)\r\n{\r\nstruct stv0900_state *state = NULL;\r\nstruct stv0900_init_params init_params;\r\nenum fe_stv0900_error err_stv0900;\r\nstate = kzalloc(sizeof(struct stv0900_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->demod = demod;\r\nstate->config = config;\r\nstate->i2c_adap = i2c;\r\nmemcpy(&state->frontend.ops, &stv0900_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nswitch (demod) {\r\ncase 0:\r\ncase 1:\r\ninit_params.dmd_ref_clk = config->xtal;\r\ninit_params.demod_mode = config->demod_mode;\r\ninit_params.rolloff = STV0900_35;\r\ninit_params.path1_ts_clock = config->path1_mode;\r\ninit_params.tun1_maddress = config->tun1_maddress;\r\ninit_params.tun1_iq_inv = STV0900_IQ_NORMAL;\r\ninit_params.tuner1_adc = config->tun1_adc;\r\ninit_params.tuner1_type = config->tun1_type;\r\ninit_params.path2_ts_clock = config->path2_mode;\r\ninit_params.ts_config = config->ts_config_regs;\r\ninit_params.tun2_maddress = config->tun2_maddress;\r\ninit_params.tuner2_adc = config->tun2_adc;\r\ninit_params.tuner2_type = config->tun2_type;\r\ninit_params.tun2_iq_inv = STV0900_IQ_SWAPPED;\r\nerr_stv0900 = stv0900_init_internal(&state->frontend,\r\n&init_params);\r\nif (err_stv0900)\r\ngoto error;\r\nif (state->internal->chip_id >= 0x30)\r\nstate->frontend.ops.info.caps |= FE_CAN_MULTISTREAM;\r\nbreak;\r\ndefault:\r\ngoto error;\r\nbreak;\r\n}\r\ndprintk("%s: Attaching STV0900 demodulator(%d) \n", __func__, demod);\r\nreturn &state->frontend;\r\nerror:\r\ndprintk("%s: Failed to attach STV0900 demodulator(%d) \n",\r\n__func__, demod);\r\nkfree(state);\r\nreturn NULL;\r\n}
