static inline struct sony_btf_mpx *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct sony_btf_mpx, sd);\r\n}\r\nstatic int mpx_write(struct i2c_client *client, int dev, int addr, int val)\r\n{\r\nu8 buffer[5];\r\nstruct i2c_msg msg;\r\nbuffer[0] = dev;\r\nbuffer[1] = addr >> 8;\r\nbuffer[2] = addr & 0xff;\r\nbuffer[3] = val >> 8;\r\nbuffer[4] = val & 0xff;\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.len = 5;\r\nmsg.buf = buffer;\r\ni2c_transfer(client->adapter, &msg, 1);\r\nreturn 0;\r\n}\r\nstatic int mpx_setup(struct sony_btf_mpx *t)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&t->sd);\r\nu16 source = 0;\r\nu8 buffer[3];\r\nstruct i2c_msg msg;\r\nint mode = t->mpxmode;\r\nbuffer[0] = 0x00;\r\nbuffer[1] = 0x80;\r\nbuffer[2] = 0x00;\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.len = 3;\r\nmsg.buf = buffer;\r\ni2c_transfer(client->adapter, &msg, 1);\r\nbuffer[1] = 0x00;\r\ni2c_transfer(client->adapter, &msg, 1);\r\nif (t->audmode != V4L2_TUNER_MODE_MONO)\r\nmode++;\r\nif (mpx_audio_modes[mode].audio_mode != AUD_MONO) {\r\nswitch (t->audmode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\nswitch (mpx_audio_modes[mode].audio_mode) {\r\ncase AUD_A2:\r\nsource = mpx_audio_modes[mode].source;\r\nbreak;\r\ncase AUD_NICAM:\r\nsource = 0x0000;\r\nbreak;\r\ncase AUD_NICAM_L:\r\nsource = 0x0200;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase V4L2_TUNER_MODE_STEREO:\r\nsource = mpx_audio_modes[mode].source;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1:\r\nsource = 0x0300;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG2:\r\nsource = 0x0400;\r\nbreak;\r\n}\r\nsource |= mpx_audio_modes[mode].source & 0x00ff;\r\n} else\r\nsource = mpx_audio_modes[mode].source;\r\nmpx_write(client, 0x10, 0x0030, mpx_audio_modes[mode].modus);\r\nmpx_write(client, 0x12, 0x0008, source);\r\nmpx_write(client, 0x12, 0x0013, mpx_audio_modes[mode].acb);\r\nmpx_write(client, 0x12, 0x000e,\r\nmpx_audio_modes[mode].fm_prescale);\r\nmpx_write(client, 0x12, 0x0010,\r\nmpx_audio_modes[mode].nicam_prescale);\r\nmpx_write(client, 0x12, 0x000d,\r\nmpx_audio_modes[mode].scart_prescale);\r\nmpx_write(client, 0x10, 0x0020, mpx_audio_modes[mode].system);\r\nmpx_write(client, 0x12, 0x0000, mpx_audio_modes[mode].volume);\r\nif (mpx_audio_modes[mode].audio_mode == AUD_A2)\r\nmpx_write(client, 0x10, 0x0022,\r\nt->audmode == V4L2_TUNER_MODE_MONO ? 0x07f0 : 0x0190);\r\n#ifdef MPX_DEBUG\r\n{\r\nu8 buf1[3], buf2[2];\r\nstruct i2c_msg msgs[2];\r\nv4l2_info(client,\r\n"MPX registers: %04x %04x %04x %04x %04x %04x %04x %04x\n",\r\nmpx_audio_modes[mode].modus,\r\nsource,\r\nmpx_audio_modes[mode].acb,\r\nmpx_audio_modes[mode].fm_prescale,\r\nmpx_audio_modes[mode].nicam_prescale,\r\nmpx_audio_modes[mode].scart_prescale,\r\nmpx_audio_modes[mode].system,\r\nmpx_audio_modes[mode].volume);\r\nbuf1[0] = 0x11;\r\nbuf1[1] = 0x00;\r\nbuf1[2] = 0x7e;\r\nmsgs[0].addr = client->addr;\r\nmsgs[0].flags = 0;\r\nmsgs[0].len = 3;\r\nmsgs[0].buf = buf1;\r\nmsgs[1].addr = client->addr;\r\nmsgs[1].flags = I2C_M_RD;\r\nmsgs[1].len = 2;\r\nmsgs[1].buf = buf2;\r\ni2c_transfer(client->adapter, msgs, 2);\r\nv4l2_info(client, "MPX system: %02x%02x\n",\r\nbuf2[0], buf2[1]);\r\nbuf1[0] = 0x11;\r\nbuf1[1] = 0x02;\r\nbuf1[2] = 0x00;\r\ni2c_transfer(client->adapter, msgs, 2);\r\nv4l2_info(client, "MPX status: %02x%02x\n",\r\nbuf2[0], buf2[1]);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int sony_btf_mpx_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct sony_btf_mpx *t = to_state(sd);\r\nint default_mpx_mode = 0;\r\nif (std & V4L2_STD_PAL_BG)\r\ndefault_mpx_mode = 1;\r\nelse if (std & V4L2_STD_PAL_I)\r\ndefault_mpx_mode = 4;\r\nelse if (std & V4L2_STD_PAL_DK)\r\ndefault_mpx_mode = 6;\r\nelse if (std & V4L2_STD_SECAM_L)\r\ndefault_mpx_mode = 11;\r\nif (default_mpx_mode != t->mpxmode) {\r\nt->mpxmode = default_mpx_mode;\r\nmpx_setup(t);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sony_btf_mpx_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *vt)\r\n{\r\nstruct sony_btf_mpx *t = to_state(sd);\r\nvt->capability = V4L2_TUNER_CAP_NORM |\r\nV4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LANG1 |\r\nV4L2_TUNER_CAP_LANG2;\r\nvt->rxsubchans = V4L2_TUNER_SUB_MONO |\r\nV4L2_TUNER_SUB_STEREO | V4L2_TUNER_SUB_LANG1 |\r\nV4L2_TUNER_SUB_LANG2;\r\nvt->audmode = t->audmode;\r\nreturn 0;\r\n}\r\nstatic int sony_btf_mpx_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *vt)\r\n{\r\nstruct sony_btf_mpx *t = to_state(sd);\r\nif (vt->type != V4L2_TUNER_ANALOG_TV)\r\nreturn -EINVAL;\r\nif (vt->audmode != t->audmode) {\r\nt->audmode = vt->audmode;\r\nmpx_setup(t);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sony_btf_mpx_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct sony_btf_mpx *t;\r\nstruct v4l2_subdev *sd;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_I2C_BLOCK))\r\nreturn -ENODEV;\r\nv4l_info(client, "chip found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nt = devm_kzalloc(&client->dev, sizeof(*t), GFP_KERNEL);\r\nif (t == NULL)\r\nreturn -ENOMEM;\r\nsd = &t->sd;\r\nv4l2_i2c_subdev_init(sd, client, &sony_btf_mpx_ops);\r\nt->mpxmode = 0;\r\nt->audmode = V4L2_TUNER_MODE_STEREO;\r\nreturn 0;\r\n}\r\nstatic int sony_btf_mpx_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nreturn 0;\r\n}
