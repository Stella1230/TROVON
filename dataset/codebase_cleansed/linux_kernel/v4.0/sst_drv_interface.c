int free_stream_context(struct intel_sst_drv *ctx, unsigned int str_id)\r\n{\r\nstruct stream_info *stream;\r\nint ret = 0;\r\nstream = get_stream_info(ctx, str_id);\r\nif (stream) {\r\nret = sst_free_stream(ctx, str_id);\r\nif (ret)\r\nsst_clean_stream(&ctx->streams[str_id]);\r\nreturn ret;\r\n} else {\r\ndev_err(ctx->dev, "we tried to free stream context %d which was freed!!!\n", str_id);\r\n}\r\nreturn ret;\r\n}\r\nint sst_get_stream_allocated(struct intel_sst_drv *ctx,\r\nstruct snd_sst_params *str_param,\r\nstruct snd_sst_lib_download **lib_dnld)\r\n{\r\nint retval;\r\nretval = ctx->ops->alloc_stream(ctx, str_param);\r\nif (retval > 0)\r\ndev_dbg(ctx->dev, "Stream allocated %d\n", retval);\r\nreturn retval;\r\n}\r\nint sst_get_sfreq(struct snd_sst_params *str_param)\r\n{\r\nswitch (str_param->codec) {\r\ncase SST_CODEC_TYPE_PCM:\r\nreturn str_param->sparams.uc.pcm_params.sfreq;\r\ncase SST_CODEC_TYPE_AAC:\r\nreturn str_param->sparams.uc.aac_params.externalsr;\r\ncase SST_CODEC_TYPE_MP3:\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint sst_get_num_channel(struct snd_sst_params *str_param)\r\n{\r\nswitch (str_param->codec) {\r\ncase SST_CODEC_TYPE_PCM:\r\nreturn str_param->sparams.uc.pcm_params.num_chan;\r\ncase SST_CODEC_TYPE_MP3:\r\nreturn str_param->sparams.uc.mp3_params.num_chan;\r\ncase SST_CODEC_TYPE_AAC:\r\nreturn str_param->sparams.uc.aac_params.num_chan;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint sst_get_stream(struct intel_sst_drv *ctx,\r\nstruct snd_sst_params *str_param)\r\n{\r\nint retval;\r\nstruct stream_info *str_info;\r\nretval = ctx->ops->alloc_stream(ctx, str_param);\r\nif (retval <= 0) {\r\nreturn -EIO;\r\n}\r\nstr_info = &ctx->streams[retval];\r\nstr_info->sfreq = sst_get_sfreq(str_param);\r\nreturn retval;\r\n}\r\nstatic int sst_power_control(struct device *dev, bool state)\r\n{\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\ndev_dbg(ctx->dev, "state:%d", state);\r\nif (state == true)\r\nreturn pm_runtime_get_sync(dev);\r\nelse\r\nreturn sst_pm_runtime_put(ctx);\r\n}\r\nstatic int sst_open_pcm_stream(struct device *dev,\r\nstruct snd_sst_params *str_param)\r\n{\r\nint retval;\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nif (!str_param)\r\nreturn -EINVAL;\r\nretval = sst_get_stream(ctx, str_param);\r\nif (retval > 0)\r\nctx->stream_cnt++;\r\nelse\r\ndev_err(ctx->dev, "sst_get_stream returned err %d\n", retval);\r\nreturn retval;\r\n}\r\nstatic int sst_cdev_open(struct device *dev,\r\nstruct snd_sst_params *str_params, struct sst_compress_cb *cb)\r\n{\r\nint str_id, retval;\r\nstruct stream_info *stream;\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nretval = pm_runtime_get_sync(ctx->dev);\r\nif (retval < 0)\r\nreturn retval;\r\nstr_id = sst_get_stream(ctx, str_params);\r\nif (str_id > 0) {\r\ndev_dbg(dev, "stream allocated in sst_cdev_open %d\n", str_id);\r\nstream = &ctx->streams[str_id];\r\nstream->compr_cb = cb->compr_cb;\r\nstream->compr_cb_param = cb->param;\r\nstream->drain_notify = cb->drain_notify;\r\nstream->drain_cb_param = cb->drain_cb_param;\r\n} else {\r\ndev_err(dev, "stream encountered error during alloc %d\n", str_id);\r\nstr_id = -EINVAL;\r\nsst_pm_runtime_put(ctx);\r\n}\r\nreturn str_id;\r\n}\r\nstatic int sst_cdev_close(struct device *dev, unsigned int str_id)\r\n{\r\nint retval;\r\nstruct stream_info *stream;\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nstream = get_stream_info(ctx, str_id);\r\nif (!stream) {\r\ndev_err(dev, "stream info is NULL for str %d!!!\n", str_id);\r\nreturn -EINVAL;\r\n}\r\nif (stream->status == STREAM_RESET) {\r\ndev_dbg(dev, "stream in reset state...\n");\r\nstream->status = STREAM_UN_INIT;\r\nretval = 0;\r\ngoto put;\r\n}\r\nretval = sst_free_stream(ctx, str_id);\r\nput:\r\nstream->compr_cb_param = NULL;\r\nstream->compr_cb = NULL;\r\nif (retval)\r\ndev_err(dev, "free stream returned err %d\n", retval);\r\ndev_dbg(dev, "End\n");\r\nreturn retval;\r\n}\r\nstatic int sst_cdev_ack(struct device *dev, unsigned int str_id,\r\nunsigned long bytes)\r\n{\r\nstruct stream_info *stream;\r\nstruct snd_sst_tstamp fw_tstamp = {0,};\r\nint offset;\r\nvoid __iomem *addr;\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nstream = get_stream_info(ctx, str_id);\r\nif (!stream)\r\nreturn -EINVAL;\r\nstream->cumm_bytes += bytes;\r\ndev_dbg(dev, "bytes copied %d inc by %ld\n", stream->cumm_bytes, bytes);\r\nmemcpy_fromio(&fw_tstamp,\r\n((void *)(ctx->mailbox + ctx->tstamp)\r\n+(str_id * sizeof(fw_tstamp))),\r\nsizeof(fw_tstamp));\r\nfw_tstamp.bytes_copied = stream->cumm_bytes;\r\ndev_dbg(dev, "bytes sent to fw %llu inc by %ld\n",\r\nfw_tstamp.bytes_copied, bytes);\r\naddr = ((void *)(ctx->mailbox + ctx->tstamp)) +\r\n(str_id * sizeof(fw_tstamp));\r\noffset = offsetof(struct snd_sst_tstamp, bytes_copied);\r\nsst_shim_write(addr, offset, fw_tstamp.bytes_copied);\r\nreturn 0;\r\n}\r\nstatic int sst_cdev_set_metadata(struct device *dev,\r\nunsigned int str_id, struct snd_compr_metadata *metadata)\r\n{\r\nint retval = 0;\r\nstruct stream_info *str_info;\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\ndev_dbg(dev, "set metadata for stream %d\n", str_id);\r\nstr_info = get_stream_info(ctx, str_id);\r\nif (!str_info)\r\nreturn -EINVAL;\r\ndev_dbg(dev, "pipe id = %d\n", str_info->pipe_id);\r\nretval = sst_prepare_and_post_msg(ctx, str_info->task_id, IPC_CMD,\r\nIPC_IA_SET_STREAM_PARAMS_MRFLD, str_info->pipe_id,\r\nsizeof(*metadata), metadata, NULL,\r\ntrue, true, true, false);\r\nreturn retval;\r\n}\r\nstatic int sst_cdev_stream_pause(struct device *dev, unsigned int str_id)\r\n{\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nreturn sst_pause_stream(ctx, str_id);\r\n}\r\nstatic int sst_cdev_stream_pause_release(struct device *dev,\r\nunsigned int str_id)\r\n{\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nreturn sst_resume_stream(ctx, str_id);\r\n}\r\nstatic int sst_cdev_stream_start(struct device *dev, unsigned int str_id)\r\n{\r\nstruct stream_info *str_info;\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nstr_info = get_stream_info(ctx, str_id);\r\nif (!str_info)\r\nreturn -EINVAL;\r\nstr_info->prev = str_info->status;\r\nstr_info->status = STREAM_RUNNING;\r\nreturn sst_start_stream(ctx, str_id);\r\n}\r\nstatic int sst_cdev_stream_drop(struct device *dev, unsigned int str_id)\r\n{\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nreturn sst_drop_stream(ctx, str_id);\r\n}\r\nstatic int sst_cdev_stream_drain(struct device *dev, unsigned int str_id)\r\n{\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nreturn sst_drain_stream(ctx, str_id, false);\r\n}\r\nstatic int sst_cdev_stream_partial_drain(struct device *dev,\r\nunsigned int str_id)\r\n{\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nreturn sst_drain_stream(ctx, str_id, true);\r\n}\r\nstatic int sst_cdev_tstamp(struct device *dev, unsigned int str_id,\r\nstruct snd_compr_tstamp *tstamp)\r\n{\r\nstruct snd_sst_tstamp fw_tstamp = {0,};\r\nstruct stream_info *stream;\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nmemcpy_fromio(&fw_tstamp,\r\n((void *)(ctx->mailbox + ctx->tstamp)\r\n+(str_id * sizeof(fw_tstamp))),\r\nsizeof(fw_tstamp));\r\nstream = get_stream_info(ctx, str_id);\r\nif (!stream)\r\nreturn -EINVAL;\r\ndev_dbg(dev, "rb_counter %llu in bytes\n", fw_tstamp.ring_buffer_counter);\r\ntstamp->copied_total = fw_tstamp.ring_buffer_counter;\r\ntstamp->pcm_frames = fw_tstamp.frames_decoded;\r\ntstamp->pcm_io_frames = div_u64(fw_tstamp.hardware_counter,\r\n(u64)((stream->num_ch) * SST_GET_BYTES_PER_SAMPLE(24)));\r\ntstamp->sampling_rate = fw_tstamp.sampling_frequency;\r\ndev_dbg(dev, "PCM = %u\n", tstamp->pcm_io_frames);\r\ndev_dbg(dev, "Ptr Query on strid = %d copied_total %d, decodec %d\n",\r\nstr_id, tstamp->copied_total, tstamp->pcm_frames);\r\ndev_dbg(dev, "rendered %d\n", tstamp->pcm_io_frames);\r\nreturn 0;\r\n}\r\nstatic int sst_cdev_caps(struct snd_compr_caps *caps)\r\n{\r\ncaps->num_codecs = NUM_CODEC;\r\ncaps->min_fragment_size = MIN_FRAGMENT_SIZE;\r\ncaps->max_fragment_size = MAX_FRAGMENT_SIZE;\r\ncaps->min_fragments = MIN_FRAGMENT;\r\ncaps->max_fragments = MAX_FRAGMENT;\r\ncaps->codecs[0] = SND_AUDIOCODEC_MP3;\r\ncaps->codecs[1] = SND_AUDIOCODEC_AAC;\r\nreturn 0;\r\n}\r\nstatic int sst_cdev_codec_caps(struct snd_compr_codec_caps *codec)\r\n{\r\nif (codec->codec == SND_AUDIOCODEC_MP3)\r\n*codec = caps_mp3;\r\nelse if (codec->codec == SND_AUDIOCODEC_AAC)\r\n*codec = caps_aac;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nvoid sst_cdev_fragment_elapsed(struct intel_sst_drv *ctx, int str_id)\r\n{\r\nstruct stream_info *stream;\r\ndev_dbg(ctx->dev, "fragment elapsed from firmware for str_id %d\n",\r\nstr_id);\r\nstream = &ctx->streams[str_id];\r\nif (stream->compr_cb)\r\nstream->compr_cb(stream->compr_cb_param);\r\n}\r\nstatic int sst_close_pcm_stream(struct device *dev, unsigned int str_id)\r\n{\r\nstruct stream_info *stream;\r\nint retval = 0;\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nstream = get_stream_info(ctx, str_id);\r\nif (!stream) {\r\ndev_err(ctx->dev, "stream info is NULL for str %d!!!\n", str_id);\r\nreturn -EINVAL;\r\n}\r\nif (stream->status == STREAM_RESET) {\r\ndev_dbg(ctx->dev, "stream in reset state...\n");\r\nretval = 0;\r\ngoto put;\r\n}\r\nretval = free_stream_context(ctx, str_id);\r\nput:\r\nstream->pcm_substream = NULL;\r\nstream->status = STREAM_UN_INIT;\r\nstream->period_elapsed = NULL;\r\nctx->stream_cnt--;\r\nif (retval)\r\ndev_err(ctx->dev, "free stream returned err %d\n", retval);\r\ndev_dbg(ctx->dev, "Exit\n");\r\nreturn 0;\r\n}\r\nstatic inline int sst_calc_tstamp(struct intel_sst_drv *ctx,\r\nstruct pcm_stream_info *info,\r\nstruct snd_pcm_substream *substream,\r\nstruct snd_sst_tstamp *fw_tstamp)\r\n{\r\nsize_t delay_bytes, delay_frames;\r\nsize_t buffer_sz;\r\nu32 pointer_bytes, pointer_samples;\r\ndev_dbg(ctx->dev, "mrfld ring_buffer_counter %llu in bytes\n",\r\nfw_tstamp->ring_buffer_counter);\r\ndev_dbg(ctx->dev, "mrfld hardware_counter %llu in bytes\n",\r\nfw_tstamp->hardware_counter);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndelay_bytes = (size_t) (fw_tstamp->ring_buffer_counter -\r\nfw_tstamp->hardware_counter);\r\nelse\r\ndelay_bytes = (size_t) (fw_tstamp->hardware_counter -\r\nfw_tstamp->ring_buffer_counter);\r\ndelay_frames = bytes_to_frames(substream->runtime, delay_bytes);\r\nbuffer_sz = snd_pcm_lib_buffer_bytes(substream);\r\ndiv_u64_rem(fw_tstamp->ring_buffer_counter, buffer_sz, &pointer_bytes);\r\npointer_samples = bytes_to_samples(substream->runtime, pointer_bytes);\r\ndev_dbg(ctx->dev, "pcm delay %zu in bytes\n", delay_bytes);\r\ninfo->buffer_ptr = pointer_samples / substream->runtime->channels;\r\ninfo->pcm_delay = delay_frames / substream->runtime->channels;\r\ndev_dbg(ctx->dev, "buffer ptr %llu pcm_delay rep: %llu\n",\r\ninfo->buffer_ptr, info->pcm_delay);\r\nreturn 0;\r\n}\r\nstatic int sst_read_timestamp(struct device *dev, struct pcm_stream_info *info)\r\n{\r\nstruct stream_info *stream;\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_sst_tstamp fw_tstamp;\r\nunsigned int str_id;\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nstr_id = info->str_id;\r\nstream = get_stream_info(ctx, str_id);\r\nif (!stream)\r\nreturn -EINVAL;\r\nif (!stream->pcm_substream)\r\nreturn -EINVAL;\r\nsubstream = stream->pcm_substream;\r\nmemcpy_fromio(&fw_tstamp,\r\n((void *)(ctx->mailbox + ctx->tstamp)\r\n+ (str_id * sizeof(fw_tstamp))),\r\nsizeof(fw_tstamp));\r\nreturn sst_calc_tstamp(ctx, info, substream, &fw_tstamp);\r\n}\r\nstatic int sst_stream_start(struct device *dev, int str_id)\r\n{\r\nstruct stream_info *str_info;\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nif (ctx->sst_state != SST_FW_RUNNING)\r\nreturn 0;\r\nstr_info = get_stream_info(ctx, str_id);\r\nif (!str_info)\r\nreturn -EINVAL;\r\nstr_info->prev = str_info->status;\r\nstr_info->status = STREAM_RUNNING;\r\nsst_start_stream(ctx, str_id);\r\nreturn 0;\r\n}\r\nstatic int sst_stream_drop(struct device *dev, int str_id)\r\n{\r\nstruct stream_info *str_info;\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nif (ctx->sst_state != SST_FW_RUNNING)\r\nreturn 0;\r\nstr_info = get_stream_info(ctx, str_id);\r\nif (!str_info)\r\nreturn -EINVAL;\r\nstr_info->prev = STREAM_UN_INIT;\r\nstr_info->status = STREAM_INIT;\r\nreturn sst_drop_stream(ctx, str_id);\r\n}\r\nstatic int sst_stream_init(struct device *dev, struct pcm_stream_info *str_info)\r\n{\r\nint str_id = 0;\r\nstruct stream_info *stream;\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nstr_id = str_info->str_id;\r\nif (ctx->sst_state != SST_FW_RUNNING)\r\nreturn 0;\r\nstream = get_stream_info(ctx, str_id);\r\nif (!stream)\r\nreturn -EINVAL;\r\ndev_dbg(ctx->dev, "setting the period ptrs\n");\r\nstream->pcm_substream = str_info->arg;\r\nstream->period_elapsed = str_info->period_elapsed;\r\nstream->sfreq = str_info->sfreq;\r\nstream->prev = stream->status;\r\nstream->status = STREAM_INIT;\r\ndev_dbg(ctx->dev,\r\n"pcm_substream %p, period_elapsed %p, sfreq %d, status %d\n",\r\nstream->pcm_substream, stream->period_elapsed,\r\nstream->sfreq, stream->status);\r\nreturn 0;\r\n}\r\nstatic int sst_send_byte_stream(struct device *dev,\r\nstruct snd_sst_bytes_v2 *bytes)\r\n{\r\nint ret_val = 0;\r\nstruct intel_sst_drv *ctx = dev_get_drvdata(dev);\r\nif (NULL == bytes)\r\nreturn -EINVAL;\r\nret_val = pm_runtime_get_sync(ctx->dev);\r\nif (ret_val < 0)\r\nreturn ret_val;\r\nret_val = sst_send_byte_stream_mrfld(ctx, bytes);\r\nsst_pm_runtime_put(ctx);\r\nreturn ret_val;\r\n}\r\nint sst_register(struct device *dev)\r\n{\r\nint ret_val;\r\nsst_dsp_device.dev = dev;\r\nret_val = sst_register_dsp(&sst_dsp_device);\r\nif (ret_val)\r\ndev_err(dev, "Unable to register DSP with platform driver\n");\r\nreturn ret_val;\r\n}\r\nint sst_unregister(struct device *dev)\r\n{\r\nreturn sst_unregister_dsp(&sst_dsp_device);\r\n}
