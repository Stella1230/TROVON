static void\r\nprom_console_write(struct console *con, const char *s, unsigned n)\r\n{\r\nprom_write(s, n);\r\n}\r\nstatic void __init process_switch(char c)\r\n{\r\nswitch (c) {\r\ncase 'd':\r\ncase 's':\r\nbreak;\r\ncase 'h':\r\nprom_printf("boot_flags_init: Halt!\n");\r\nprom_halt();\r\nbreak;\r\ncase 'p':\r\nprom_early_console.flags &= ~CON_BOOT;\r\nbreak;\r\ncase 'P':\r\nif (tlb_type != cheetah) {\r\nprintk("BOOT: Ignoring P-Cache force option.\n");\r\nbreak;\r\n}\r\ncheetah_pcache_forced_on = 1;\r\nadd_taint(TAINT_MACHINE_CHECK, LOCKDEP_NOW_UNRELIABLE);\r\ncheetah_enable_pcache();\r\nbreak;\r\ndefault:\r\nprintk("Unknown boot switch (-%c)\n", c);\r\nbreak;\r\n}\r\n}\r\nstatic void __init boot_flags_init(char *commands)\r\n{\r\nwhile (*commands) {\r\nwhile (*commands && *commands == ' ')\r\ncommands++;\r\nif (*commands == '\0')\r\nbreak;\r\nif (*commands == '-') {\r\ncommands++;\r\nwhile (*commands && *commands != ' ')\r\nprocess_switch(*commands++);\r\ncontinue;\r\n}\r\nif (!strncmp(commands, "mem=", 4))\r\ncmdline_memory_size = memparse(commands + 4, &commands);\r\nwhile (*commands && *commands != ' ')\r\ncommands++;\r\n}\r\n}\r\nstatic void __init per_cpu_patch(void)\r\n{\r\nstruct cpuid_patch_entry *p;\r\nunsigned long ver;\r\nint is_jbus;\r\nif (tlb_type == spitfire && !this_is_starfire)\r\nreturn;\r\nis_jbus = 0;\r\nif (tlb_type != hypervisor) {\r\n__asm__ ("rdpr %%ver, %0" : "=r" (ver));\r\nis_jbus = ((ver >> 32UL) == __JALAPENO_ID ||\r\n(ver >> 32UL) == __SERRANO_ID);\r\n}\r\np = &__cpuid_patch;\r\nwhile (p < &__cpuid_patch_end) {\r\nunsigned long addr = p->addr;\r\nunsigned int *insns;\r\nswitch (tlb_type) {\r\ncase spitfire:\r\ninsns = &p->starfire[0];\r\nbreak;\r\ncase cheetah:\r\ncase cheetah_plus:\r\nif (is_jbus)\r\ninsns = &p->cheetah_jbus[0];\r\nelse\r\ninsns = &p->cheetah_safari[0];\r\nbreak;\r\ncase hypervisor:\r\ninsns = &p->sun4v[0];\r\nbreak;\r\ndefault:\r\nprom_printf("Unknown cpu type, halting.\n");\r\nprom_halt();\r\n}\r\n*(unsigned int *) (addr + 0) = insns[0];\r\nwmb();\r\n__asm__ __volatile__("flush %0" : : "r" (addr + 0));\r\n*(unsigned int *) (addr + 4) = insns[1];\r\nwmb();\r\n__asm__ __volatile__("flush %0" : : "r" (addr + 4));\r\n*(unsigned int *) (addr + 8) = insns[2];\r\nwmb();\r\n__asm__ __volatile__("flush %0" : : "r" (addr + 8));\r\n*(unsigned int *) (addr + 12) = insns[3];\r\nwmb();\r\n__asm__ __volatile__("flush %0" : : "r" (addr + 12));\r\np++;\r\n}\r\n}\r\nvoid sun4v_patch_1insn_range(struct sun4v_1insn_patch_entry *start,\r\nstruct sun4v_1insn_patch_entry *end)\r\n{\r\nwhile (start < end) {\r\nunsigned long addr = start->addr;\r\n*(unsigned int *) (addr + 0) = start->insn;\r\nwmb();\r\n__asm__ __volatile__("flush %0" : : "r" (addr + 0));\r\nstart++;\r\n}\r\n}\r\nvoid sun4v_patch_2insn_range(struct sun4v_2insn_patch_entry *start,\r\nstruct sun4v_2insn_patch_entry *end)\r\n{\r\nwhile (start < end) {\r\nunsigned long addr = start->addr;\r\n*(unsigned int *) (addr + 0) = start->insns[0];\r\nwmb();\r\n__asm__ __volatile__("flush %0" : : "r" (addr + 0));\r\n*(unsigned int *) (addr + 4) = start->insns[1];\r\nwmb();\r\n__asm__ __volatile__("flush %0" : : "r" (addr + 4));\r\nstart++;\r\n}\r\n}\r\nstatic void __init sun4v_patch(void)\r\n{\r\nextern void sun4v_hvapi_init(void);\r\nif (tlb_type != hypervisor)\r\nreturn;\r\nsun4v_patch_1insn_range(&__sun4v_1insn_patch,\r\n&__sun4v_1insn_patch_end);\r\nsun4v_patch_2insn_range(&__sun4v_2insn_patch,\r\n&__sun4v_2insn_patch_end);\r\nsun4v_hvapi_init();\r\n}\r\nstatic void __init popc_patch(void)\r\n{\r\nstruct popc_3insn_patch_entry *p3;\r\nstruct popc_6insn_patch_entry *p6;\r\np3 = &__popc_3insn_patch;\r\nwhile (p3 < &__popc_3insn_patch_end) {\r\nunsigned long i, addr = p3->addr;\r\nfor (i = 0; i < 3; i++) {\r\n*(unsigned int *) (addr + (i * 4)) = p3->insns[i];\r\nwmb();\r\n__asm__ __volatile__("flush %0"\r\n: : "r" (addr + (i * 4)));\r\n}\r\np3++;\r\n}\r\np6 = &__popc_6insn_patch;\r\nwhile (p6 < &__popc_6insn_patch_end) {\r\nunsigned long i, addr = p6->addr;\r\nfor (i = 0; i < 6; i++) {\r\n*(unsigned int *) (addr + (i * 4)) = p6->insns[i];\r\nwmb();\r\n__asm__ __volatile__("flush %0"\r\n: : "r" (addr + (i * 4)));\r\n}\r\np6++;\r\n}\r\n}\r\nstatic void __init pause_patch(void)\r\n{\r\nstruct pause_patch_entry *p;\r\np = &__pause_3insn_patch;\r\nwhile (p < &__pause_3insn_patch_end) {\r\nunsigned long i, addr = p->addr;\r\nfor (i = 0; i < 3; i++) {\r\n*(unsigned int *) (addr + (i * 4)) = p->insns[i];\r\nwmb();\r\n__asm__ __volatile__("flush %0"\r\n: : "r" (addr + (i * 4)));\r\n}\r\np++;\r\n}\r\n}\r\nvoid __init start_early_boot(void)\r\n{\r\nint cpu;\r\ncheck_if_starfire();\r\nper_cpu_patch();\r\nsun4v_patch();\r\ncpu = hard_smp_processor_id();\r\nif (cpu >= NR_CPUS) {\r\nprom_printf("Serious problem, boot cpu id (%d) >= NR_CPUS (%d)\n",\r\ncpu, NR_CPUS);\r\nprom_halt();\r\n}\r\ncurrent_thread_info()->cpu = cpu;\r\nprom_init_report();\r\nstart_kernel();\r\n}\r\nvoid cpucap_info(struct seq_file *m)\r\n{\r\nunsigned long caps = sparc64_elf_hwcap;\r\nint i, printed = 0;\r\nseq_puts(m, "cpucaps\t\t: ");\r\nfor (i = 0; i < ARRAY_SIZE(hwcaps); i++) {\r\nunsigned long bit = 1UL << i;\r\nif (caps & bit) {\r\nseq_printf(m, "%s%s",\r\nprinted ? "," : "", hwcaps[i]);\r\nprinted++;\r\n}\r\n}\r\nif (caps & HWCAP_SPARC_CRYPTO) {\r\nunsigned long cfr;\r\n__asm__ __volatile__("rd %%asr26, %0" : "=r" (cfr));\r\nfor (i = 0; i < ARRAY_SIZE(crypto_hwcaps); i++) {\r\nunsigned long bit = 1UL << i;\r\nif (cfr & bit) {\r\nseq_printf(m, "%s%s",\r\nprinted ? "," : "", crypto_hwcaps[i]);\r\nprinted++;\r\n}\r\n}\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nstatic void __init report_one_hwcap(int *printed, const char *name)\r\n{\r\nif ((*printed) == 0)\r\nprintk(KERN_INFO "CPU CAPS: [");\r\nprintk(KERN_CONT "%s%s",\r\n(*printed) ? "," : "", name);\r\nif (++(*printed) == 8) {\r\nprintk(KERN_CONT "]\n");\r\n*printed = 0;\r\n}\r\n}\r\nstatic void __init report_crypto_hwcaps(int *printed)\r\n{\r\nunsigned long cfr;\r\nint i;\r\n__asm__ __volatile__("rd %%asr26, %0" : "=r" (cfr));\r\nfor (i = 0; i < ARRAY_SIZE(crypto_hwcaps); i++) {\r\nunsigned long bit = 1UL << i;\r\nif (cfr & bit)\r\nreport_one_hwcap(printed, crypto_hwcaps[i]);\r\n}\r\n}\r\nstatic void __init report_hwcaps(unsigned long caps)\r\n{\r\nint i, printed = 0;\r\nfor (i = 0; i < ARRAY_SIZE(hwcaps); i++) {\r\nunsigned long bit = 1UL << i;\r\nif (caps & bit)\r\nreport_one_hwcap(&printed, hwcaps[i]);\r\n}\r\nif (caps & HWCAP_SPARC_CRYPTO)\r\nreport_crypto_hwcaps(&printed);\r\nif (printed != 0)\r\nprintk(KERN_CONT "]\n");\r\n}\r\nstatic unsigned long __init mdesc_cpu_hwcap_list(void)\r\n{\r\nstruct mdesc_handle *hp;\r\nunsigned long caps = 0;\r\nconst char *prop;\r\nint len;\r\nu64 pn;\r\nhp = mdesc_grab();\r\nif (!hp)\r\nreturn 0;\r\npn = mdesc_node_by_name(hp, MDESC_NODE_NULL, "cpu");\r\nif (pn == MDESC_NODE_NULL)\r\ngoto out;\r\nprop = mdesc_get_property(hp, pn, "hwcap-list", &len);\r\nif (!prop)\r\ngoto out;\r\nwhile (len) {\r\nint i, plen;\r\nfor (i = 0; i < ARRAY_SIZE(hwcaps); i++) {\r\nunsigned long bit = 1UL << i;\r\nif (!strcmp(prop, hwcaps[i])) {\r\ncaps |= bit;\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(crypto_hwcaps); i++) {\r\nif (!strcmp(prop, crypto_hwcaps[i]))\r\ncaps |= HWCAP_SPARC_CRYPTO;\r\n}\r\nplen = strlen(prop) + 1;\r\nprop += plen;\r\nlen -= plen;\r\n}\r\nout:\r\nmdesc_release(hp);\r\nreturn caps;\r\n}\r\nstatic void __init init_sparc64_elf_hwcap(void)\r\n{\r\nunsigned long cap = sparc64_elf_hwcap;\r\nunsigned long mdesc_caps;\r\nif (tlb_type == cheetah || tlb_type == cheetah_plus)\r\ncap |= HWCAP_SPARC_ULTRA3;\r\nelse if (tlb_type == hypervisor) {\r\nif (sun4v_chip_type == SUN4V_CHIP_NIAGARA1 ||\r\nsun4v_chip_type == SUN4V_CHIP_NIAGARA2 ||\r\nsun4v_chip_type == SUN4V_CHIP_NIAGARA3 ||\r\nsun4v_chip_type == SUN4V_CHIP_NIAGARA4 ||\r\nsun4v_chip_type == SUN4V_CHIP_NIAGARA5 ||\r\nsun4v_chip_type == SUN4V_CHIP_SPARC_M6 ||\r\nsun4v_chip_type == SUN4V_CHIP_SPARC_M7 ||\r\nsun4v_chip_type == SUN4V_CHIP_SPARC64X)\r\ncap |= HWCAP_SPARC_BLKINIT;\r\nif (sun4v_chip_type == SUN4V_CHIP_NIAGARA2 ||\r\nsun4v_chip_type == SUN4V_CHIP_NIAGARA3 ||\r\nsun4v_chip_type == SUN4V_CHIP_NIAGARA4 ||\r\nsun4v_chip_type == SUN4V_CHIP_NIAGARA5 ||\r\nsun4v_chip_type == SUN4V_CHIP_SPARC_M6 ||\r\nsun4v_chip_type == SUN4V_CHIP_SPARC_M7 ||\r\nsun4v_chip_type == SUN4V_CHIP_SPARC64X)\r\ncap |= HWCAP_SPARC_N2;\r\n}\r\ncap |= (AV_SPARC_MUL32 | AV_SPARC_DIV32 | AV_SPARC_V8PLUS);\r\nmdesc_caps = mdesc_cpu_hwcap_list();\r\nif (!mdesc_caps) {\r\nif (tlb_type == spitfire)\r\ncap |= AV_SPARC_VIS;\r\nif (tlb_type == cheetah || tlb_type == cheetah_plus)\r\ncap |= AV_SPARC_VIS | AV_SPARC_VIS2;\r\nif (tlb_type == cheetah_plus) {\r\nunsigned long impl, ver;\r\n__asm__ __volatile__("rdpr %%ver, %0" : "=r" (ver));\r\nimpl = ((ver >> 32) & 0xffff);\r\nif (impl == PANTHER_IMPL)\r\ncap |= AV_SPARC_POPC;\r\n}\r\nif (tlb_type == hypervisor) {\r\nif (sun4v_chip_type == SUN4V_CHIP_NIAGARA1)\r\ncap |= AV_SPARC_ASI_BLK_INIT;\r\nif (sun4v_chip_type == SUN4V_CHIP_NIAGARA2 ||\r\nsun4v_chip_type == SUN4V_CHIP_NIAGARA3 ||\r\nsun4v_chip_type == SUN4V_CHIP_NIAGARA4 ||\r\nsun4v_chip_type == SUN4V_CHIP_NIAGARA5 ||\r\nsun4v_chip_type == SUN4V_CHIP_SPARC_M6 ||\r\nsun4v_chip_type == SUN4V_CHIP_SPARC_M7 ||\r\nsun4v_chip_type == SUN4V_CHIP_SPARC64X)\r\ncap |= (AV_SPARC_VIS | AV_SPARC_VIS2 |\r\nAV_SPARC_ASI_BLK_INIT |\r\nAV_SPARC_POPC);\r\nif (sun4v_chip_type == SUN4V_CHIP_NIAGARA3 ||\r\nsun4v_chip_type == SUN4V_CHIP_NIAGARA4 ||\r\nsun4v_chip_type == SUN4V_CHIP_NIAGARA5 ||\r\nsun4v_chip_type == SUN4V_CHIP_SPARC_M6 ||\r\nsun4v_chip_type == SUN4V_CHIP_SPARC_M7 ||\r\nsun4v_chip_type == SUN4V_CHIP_SPARC64X)\r\ncap |= (AV_SPARC_VIS3 | AV_SPARC_HPC |\r\nAV_SPARC_FMAF);\r\n}\r\n}\r\nsparc64_elf_hwcap = cap | mdesc_caps;\r\nreport_hwcaps(sparc64_elf_hwcap);\r\nif (sparc64_elf_hwcap & AV_SPARC_POPC)\r\npopc_patch();\r\nif (sparc64_elf_hwcap & AV_SPARC_PAUSE)\r\npause_patch();\r\n}\r\nvoid __init setup_arch(char **cmdline_p)\r\n{\r\n*cmdline_p = prom_getbootargs();\r\nstrlcpy(boot_command_line, *cmdline_p, COMMAND_LINE_SIZE);\r\nparse_early_param();\r\nboot_flags_init(*cmdline_p);\r\n#ifdef CONFIG_EARLYFB\r\nif (btext_find_display())\r\n#endif\r\nregister_console(&prom_early_console);\r\nif (tlb_type == hypervisor)\r\nprintk("ARCH: SUN4V\n");\r\nelse\r\nprintk("ARCH: SUN4U\n");\r\n#ifdef CONFIG_DUMMY_CONSOLE\r\nconswitchp = &dummy_con;\r\n#endif\r\nidprom_init();\r\nif (!root_flags)\r\nroot_mountflags &= ~MS_RDONLY;\r\nROOT_DEV = old_decode_dev(root_dev);\r\n#ifdef CONFIG_BLK_DEV_RAM\r\nrd_image_start = ram_flags & RAMDISK_IMAGE_START_MASK;\r\nrd_prompt = ((ram_flags & RAMDISK_PROMPT_FLAG) != 0);\r\nrd_doload = ((ram_flags & RAMDISK_LOAD_FLAG) != 0);\r\n#endif\r\ntask_thread_info(&init_task)->kregs = &fake_swapper_regs;\r\n#ifdef CONFIG_IP_PNP\r\nif (!ic_set_manually) {\r\nphandle chosen = prom_finddevice("/chosen");\r\nu32 cl, sv, gw;\r\ncl = prom_getintdefault (chosen, "client-ip", 0);\r\nsv = prom_getintdefault (chosen, "server-ip", 0);\r\ngw = prom_getintdefault (chosen, "gateway-ip", 0);\r\nif (cl && sv) {\r\nic_myaddr = cl;\r\nic_servaddr = sv;\r\nif (gw)\r\nic_gateway = gw;\r\n#if defined(CONFIG_IP_PNP_BOOTP) || defined(CONFIG_IP_PNP_RARP)\r\nic_proto_enabled = 0;\r\n#endif\r\n}\r\n}\r\n#endif\r\ninit_cur_cpu_trap(current_thread_info());\r\npaging_init();\r\ninit_sparc64_elf_hwcap();\r\n}\r\nvoid sun_do_break(void)\r\n{\r\nif (!stop_a_enabled)\r\nreturn;\r\nprom_printf("\n");\r\nflush_user_windows();\r\nprom_cmdline();\r\n}
