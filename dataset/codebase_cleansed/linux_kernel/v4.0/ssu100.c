static inline int ssu100_control_msg(struct usb_device *dev,\r\nu8 request, u16 data, u16 index)\r\n{\r\nreturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nrequest, 0x40, data, index,\r\nNULL, 0, 300);\r\n}\r\nstatic inline int ssu100_setdevice(struct usb_device *dev, u8 *data)\r\n{\r\nu16 x = ((u16)(data[1] << 8) | (u16)(data[0]));\r\nreturn ssu100_control_msg(dev, QT_SET_GET_DEVICE, x, 0);\r\n}\r\nstatic inline int ssu100_getdevice(struct usb_device *dev, u8 *data)\r\n{\r\nreturn usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nQT_SET_GET_DEVICE, 0xc0, 0, 0,\r\ndata, 3, 300);\r\n}\r\nstatic inline int ssu100_getregister(struct usb_device *dev,\r\nunsigned short uart,\r\nunsigned short reg,\r\nu8 *data)\r\n{\r\nreturn usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nQT_SET_GET_REGISTER, 0xc0, reg,\r\nuart, data, sizeof(*data), 300);\r\n}\r\nstatic inline int ssu100_setregister(struct usb_device *dev,\r\nunsigned short uart,\r\nunsigned short reg,\r\nu16 data)\r\n{\r\nu16 value = (data << 8) | reg;\r\nreturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\nQT_SET_GET_REGISTER, 0x40, value, uart,\r\nNULL, 0, 300);\r\n}\r\nstatic inline int update_mctrl(struct usb_device *dev, unsigned int set,\r\nunsigned int clear)\r\n{\r\nunsigned urb_value;\r\nint result;\r\nif (((set | clear) & (TIOCM_DTR | TIOCM_RTS)) == 0) {\r\ndev_dbg(&dev->dev, "%s - DTR|RTS not being set|cleared\n", __func__);\r\nreturn 0;\r\n}\r\nclear &= ~set;\r\nurb_value = 0;\r\nif (set & TIOCM_DTR)\r\nurb_value |= UART_MCR_DTR;\r\nif (set & TIOCM_RTS)\r\nurb_value |= UART_MCR_RTS;\r\nresult = ssu100_setregister(dev, 0, UART_MCR, urb_value);\r\nif (result < 0)\r\ndev_dbg(&dev->dev, "%s Error from MODEM_CTRL urb\n", __func__);\r\nreturn result;\r\n}\r\nstatic int ssu100_initdevice(struct usb_device *dev)\r\n{\r\nu8 *data;\r\nint result = 0;\r\ndata = kzalloc(3, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nresult = ssu100_getdevice(dev, data);\r\nif (result < 0) {\r\ndev_dbg(&dev->dev, "%s - get_device failed %i\n", __func__, result);\r\ngoto out;\r\n}\r\ndata[1] &= ~FULLPWRBIT;\r\nresult = ssu100_setdevice(dev, data);\r\nif (result < 0) {\r\ndev_dbg(&dev->dev, "%s - setdevice failed %i\n", __func__, result);\r\ngoto out;\r\n}\r\nresult = ssu100_control_msg(dev, QT_GET_SET_PREBUF_TRIG_LVL, 128, 0);\r\nif (result < 0) {\r\ndev_dbg(&dev->dev, "%s - set prebuffer level failed %i\n", __func__, result);\r\ngoto out;\r\n}\r\nresult = ssu100_control_msg(dev, QT_SET_ATF, ATC_DISABLED, 0);\r\nif (result < 0) {\r\ndev_dbg(&dev->dev, "%s - set ATFprebuffer level failed %i\n", __func__, result);\r\ngoto out;\r\n}\r\nresult = ssu100_getdevice(dev, data);\r\nif (result < 0) {\r\ndev_dbg(&dev->dev, "%s - get_device failed %i\n", __func__, result);\r\ngoto out;\r\n}\r\ndata[0] &= ~(RR_BITS | DUPMODE_BITS);\r\ndata[0] |= CLKS_X4;\r\ndata[1] &= ~(LOOPMODE_BITS);\r\ndata[1] |= RS232_MODE;\r\nresult = ssu100_setdevice(dev, data);\r\nif (result < 0) {\r\ndev_dbg(&dev->dev, "%s - setdevice failed %i\n", __func__, result);\r\ngoto out;\r\n}\r\nout: kfree(data);\r\nreturn result;\r\n}\r\nstatic void ssu100_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nstruct ktermios *termios = &tty->termios;\r\nu16 baud, divisor, remainder;\r\nunsigned int cflag = termios->c_cflag;\r\nu16 urb_value = 0;\r\nint result;\r\nif (cflag & PARENB) {\r\nif (cflag & PARODD)\r\nurb_value |= UART_LCR_PARITY;\r\nelse\r\nurb_value |= SERIAL_EVEN_PARITY;\r\n}\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nurb_value |= UART_LCR_WLEN5;\r\nbreak;\r\ncase CS6:\r\nurb_value |= UART_LCR_WLEN6;\r\nbreak;\r\ncase CS7:\r\nurb_value |= UART_LCR_WLEN7;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nurb_value |= UART_LCR_WLEN8;\r\nbreak;\r\n}\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud)\r\nbaud = 9600;\r\ndev_dbg(&port->dev, "%s - got baud = %d\n", __func__, baud);\r\ndivisor = MAX_BAUD_RATE / baud;\r\nremainder = MAX_BAUD_RATE % baud;\r\nif (((remainder * 2) >= baud) && (baud != 110))\r\ndivisor++;\r\nurb_value = urb_value << 8;\r\nresult = ssu100_control_msg(dev, QT_GET_SET_UART, divisor, urb_value);\r\nif (result < 0)\r\ndev_dbg(&port->dev, "%s - set uart failed\n", __func__);\r\nif (cflag & CRTSCTS)\r\nresult = ssu100_control_msg(dev, QT_HW_FLOW_CONTROL_MASK,\r\nSERIAL_CRTSCTS, 0);\r\nelse\r\nresult = ssu100_control_msg(dev, QT_HW_FLOW_CONTROL_MASK,\r\n0, 0);\r\nif (result < 0)\r\ndev_dbg(&port->dev, "%s - set HW flow control failed\n", __func__);\r\nif (I_IXOFF(tty) || I_IXON(tty)) {\r\nu16 x = ((u16)(START_CHAR(tty) << 8) | (u16)(STOP_CHAR(tty)));\r\nresult = ssu100_control_msg(dev, QT_SW_FLOW_CONTROL_MASK,\r\nx, 0);\r\n} else\r\nresult = ssu100_control_msg(dev, QT_SW_FLOW_CONTROL_MASK,\r\n0, 0);\r\nif (result < 0)\r\ndev_dbg(&port->dev, "%s - set SW flow control failed\n", __func__);\r\n}\r\nstatic int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nstruct ssu100_port_private *priv = usb_get_serial_port_data(port);\r\nu8 *data;\r\nint result;\r\nunsigned long flags;\r\ndata = kzalloc(2, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\nQT_OPEN_CLOSE_CHANNEL,\r\nQT_TRANSFER_IN, 0x01,\r\n0, data, 2, 300);\r\nif (result < 0) {\r\ndev_dbg(&port->dev, "%s - open failed %i\n", __func__, result);\r\nkfree(data);\r\nreturn result;\r\n}\r\nspin_lock_irqsave(&priv->status_lock, flags);\r\npriv->shadowLSR = data[0];\r\npriv->shadowMSR = data[1];\r\nspin_unlock_irqrestore(&priv->status_lock, flags);\r\nkfree(data);\r\nresult = ssu100_control_msg(dev, QT_GET_SET_UART, 0x30, 0x0300);\r\nif (result < 0)\r\ndev_dbg(&port->dev, "%s - set uart failed\n", __func__);\r\nif (tty)\r\nssu100_set_termios(tty, port, &tty->termios);\r\nreturn usb_serial_generic_open(tty, port);\r\n}\r\nstatic int get_serial_info(struct usb_serial_port *port,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct serial_struct tmp;\r\nif (!retinfo)\r\nreturn -EFAULT;\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.line = port->minor;\r\ntmp.port = 0;\r\ntmp.irq = 0;\r\ntmp.flags = ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;\r\ntmp.xmit_fifo_size = port->bulk_out_size;\r\ntmp.baud_base = 9600;\r\ntmp.close_delay = 5*HZ;\r\ntmp.closing_wait = 30*HZ;\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ssu100_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nreturn get_serial_info(port,\r\n(struct serial_struct __user *) arg);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int ssu100_attach(struct usb_serial *serial)\r\n{\r\nreturn ssu100_initdevice(serial->dev);\r\n}\r\nstatic int ssu100_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct ssu100_port_private *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nspin_lock_init(&priv->status_lock);\r\nusb_set_serial_port_data(port, priv);\r\nreturn 0;\r\n}\r\nstatic int ssu100_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct ssu100_port_private *priv;\r\npriv = usb_get_serial_port_data(port);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int ssu100_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_device *dev = port->serial->dev;\r\nu8 *d;\r\nint r;\r\nd = kzalloc(2, GFP_KERNEL);\r\nif (!d)\r\nreturn -ENOMEM;\r\nr = ssu100_getregister(dev, 0, UART_MCR, d);\r\nif (r < 0)\r\ngoto mget_out;\r\nr = ssu100_getregister(dev, 0, UART_MSR, d+1);\r\nif (r < 0)\r\ngoto mget_out;\r\nr = (d[0] & UART_MCR_DTR ? TIOCM_DTR : 0) |\r\n(d[0] & UART_MCR_RTS ? TIOCM_RTS : 0) |\r\n(d[1] & UART_MSR_CTS ? TIOCM_CTS : 0) |\r\n(d[1] & UART_MSR_DCD ? TIOCM_CAR : 0) |\r\n(d[1] & UART_MSR_RI ? TIOCM_RI : 0) |\r\n(d[1] & UART_MSR_DSR ? TIOCM_DSR : 0);\r\nmget_out:\r\nkfree(d);\r\nreturn r;\r\n}\r\nstatic int ssu100_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct usb_device *dev = port->serial->dev;\r\nreturn update_mctrl(dev, set, clear);\r\n}\r\nstatic void ssu100_dtr_rts(struct usb_serial_port *port, int on)\r\n{\r\nstruct usb_device *dev = port->serial->dev;\r\nif (!on) {\r\nif (ssu100_setregister(dev, 0, UART_MCR, 0) < 0)\r\ndev_err(&port->dev, "error from flowcontrol urb\n");\r\n}\r\nif (on)\r\nset_mctrl(dev, TIOCM_DTR | TIOCM_RTS);\r\nelse\r\nclear_mctrl(dev, TIOCM_DTR | TIOCM_RTS);\r\n}\r\nstatic void ssu100_update_msr(struct usb_serial_port *port, u8 msr)\r\n{\r\nstruct ssu100_port_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->status_lock, flags);\r\npriv->shadowMSR = msr;\r\nspin_unlock_irqrestore(&priv->status_lock, flags);\r\nif (msr & UART_MSR_ANY_DELTA) {\r\nif (msr & UART_MSR_DCTS)\r\nport->icount.cts++;\r\nif (msr & UART_MSR_DDSR)\r\nport->icount.dsr++;\r\nif (msr & UART_MSR_DDCD)\r\nport->icount.dcd++;\r\nif (msr & UART_MSR_TERI)\r\nport->icount.rng++;\r\nwake_up_interruptible(&port->port.delta_msr_wait);\r\n}\r\n}\r\nstatic void ssu100_update_lsr(struct usb_serial_port *port, u8 lsr,\r\nchar *tty_flag)\r\n{\r\nstruct ssu100_port_private *priv = usb_get_serial_port_data(port);\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->status_lock, flags);\r\npriv->shadowLSR = lsr;\r\nspin_unlock_irqrestore(&priv->status_lock, flags);\r\n*tty_flag = TTY_NORMAL;\r\nif (lsr & UART_LSR_BRK_ERROR_BITS) {\r\nif (lsr & UART_LSR_BI) {\r\nport->icount.brk++;\r\n*tty_flag = TTY_BREAK;\r\nusb_serial_handle_break(port);\r\n}\r\nif (lsr & UART_LSR_PE) {\r\nport->icount.parity++;\r\nif (*tty_flag == TTY_NORMAL)\r\n*tty_flag = TTY_PARITY;\r\n}\r\nif (lsr & UART_LSR_FE) {\r\nport->icount.frame++;\r\nif (*tty_flag == TTY_NORMAL)\r\n*tty_flag = TTY_FRAME;\r\n}\r\nif (lsr & UART_LSR_OE) {\r\nport->icount.overrun++;\r\ntty_insert_flip_char(&port->port, 0, TTY_OVERRUN);\r\n}\r\n}\r\n}\r\nstatic void ssu100_process_read_urb(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nchar *packet = (char *)urb->transfer_buffer;\r\nchar flag = TTY_NORMAL;\r\nu32 len = urb->actual_length;\r\nint i;\r\nchar *ch;\r\nif ((len >= 4) &&\r\n(packet[0] == 0x1b) && (packet[1] == 0x1b) &&\r\n((packet[2] == 0x00) || (packet[2] == 0x01))) {\r\nif (packet[2] == 0x00)\r\nssu100_update_lsr(port, packet[3], &flag);\r\nif (packet[2] == 0x01)\r\nssu100_update_msr(port, packet[3]);\r\nlen -= 4;\r\nch = packet + 4;\r\n} else\r\nch = packet;\r\nif (!len)\r\nreturn;\r\nif (port->port.console && port->sysrq) {\r\nfor (i = 0; i < len; i++, ch++) {\r\nif (!usb_serial_handle_sysrq_char(port, *ch))\r\ntty_insert_flip_char(&port->port, *ch, flag);\r\n}\r\n} else\r\ntty_insert_flip_string_fixed_flag(&port->port, ch, flag, len);\r\ntty_flip_buffer_push(&port->port);\r\n}
