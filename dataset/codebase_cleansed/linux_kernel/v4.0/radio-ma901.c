static inline struct ma901radio_device *to_ma901radio_dev(struct v4l2_device *v4l2_dev)\r\n{\r\nreturn container_of(v4l2_dev, struct ma901radio_device, v4l2_dev);\r\n}\r\nstatic int ma901radio_set_freq(struct ma901radio_device *radio, int freq)\r\n{\r\nunsigned int freq_send = 0x300 + (freq >> 5) / 25;\r\nint retval;\r\nradio->buffer[0] = 0x0a;\r\nradio->buffer[1] = MA901_RADIO_SET_FREQ;\r\nradio->buffer[2] = ((freq_send >> 8) & 0xff) + 0x80;\r\nradio->buffer[3] = freq_send & 0xff;\r\nradio->buffer[4] = 0x00;\r\nradio->buffer[5] = 0x00;\r\nradio->buffer[6] = 0x00;\r\nradio->buffer[7] = 0x00;\r\nretval = usb_control_msg(radio->usbdev, usb_sndctrlpipe(radio->usbdev, 0),\r\n9, 0x21, 0x0300, 0,\r\nradio->buffer, BUFFER_LENGTH, USB_TIMEOUT);\r\nif (retval < 0)\r\nreturn retval;\r\nradio->curfreq = freq;\r\nreturn 0;\r\n}\r\nstatic int ma901radio_set_volume(struct ma901radio_device *radio, u16 vol_to_set)\r\n{\r\nint retval;\r\nradio->buffer[0] = 0x0a;\r\nradio->buffer[1] = MA901_RADIO_SET_VOLUME;\r\nradio->buffer[2] = 0xc2;\r\nradio->buffer[3] = vol_to_set + 0x20;\r\nradio->buffer[4] = 0x00;\r\nradio->buffer[5] = 0x00;\r\nradio->buffer[6] = 0x00;\r\nradio->buffer[7] = 0x00;\r\nretval = usb_control_msg(radio->usbdev, usb_sndctrlpipe(radio->usbdev, 0),\r\n9, 0x21, 0x0300, 0,\r\nradio->buffer, BUFFER_LENGTH, USB_TIMEOUT);\r\nif (retval < 0)\r\nreturn retval;\r\nradio->volume = vol_to_set;\r\nreturn retval;\r\n}\r\nstatic int ma901_set_stereo(struct ma901radio_device *radio, u8 stereo)\r\n{\r\nint retval;\r\nradio->buffer[0] = 0x0a;\r\nradio->buffer[1] = MA901_RADIO_SET_MONO_STEREO;\r\nradio->buffer[2] = stereo;\r\nradio->buffer[3] = 0x00;\r\nradio->buffer[4] = 0x00;\r\nradio->buffer[5] = 0x00;\r\nradio->buffer[6] = 0x00;\r\nradio->buffer[7] = 0x00;\r\nretval = usb_control_msg(radio->usbdev, usb_sndctrlpipe(radio->usbdev, 0),\r\n9, 0x21, 0x0300, 0,\r\nradio->buffer, BUFFER_LENGTH, USB_TIMEOUT);\r\nif (retval < 0)\r\nreturn retval;\r\nif (stereo == MA901_WANT_STEREO)\r\nradio->stereo = V4L2_TUNER_MODE_STEREO;\r\nelse\r\nradio->stereo = V4L2_TUNER_MODE_MONO;\r\nreturn retval;\r\n}\r\nstatic void usb_ma901radio_disconnect(struct usb_interface *intf)\r\n{\r\nstruct ma901radio_device *radio = to_ma901radio_dev(usb_get_intfdata(intf));\r\nmutex_lock(&radio->lock);\r\nvideo_unregister_device(&radio->vdev);\r\nusb_set_intfdata(intf, NULL);\r\nv4l2_device_disconnect(&radio->v4l2_dev);\r\nmutex_unlock(&radio->lock);\r\nv4l2_device_put(&radio->v4l2_dev);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstruct ma901radio_device *radio = video_drvdata(file);\r\nstrlcpy(v->driver, "radio-ma901", sizeof(v->driver));\r\nstrlcpy(v->card, "Masterkit MA901 USB FM Radio", sizeof(v->card));\r\nusb_make_path(radio->usbdev, v->bus_info, sizeof(v->bus_info));\r\nv->device_caps = V4L2_CAP_RADIO | V4L2_CAP_TUNER;\r\nv->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct ma901radio_device *radio = video_drvdata(file);\r\nif (v->index > 0)\r\nreturn -EINVAL;\r\nv->signal = 0;\r\nstrcpy(v->name, "FM");\r\nv->type = V4L2_TUNER_RADIO;\r\nv->rangelow = FREQ_MIN * FREQ_MUL;\r\nv->rangehigh = FREQ_MAX * FREQ_MUL;\r\nv->capability = V4L2_TUNER_CAP_LOW | V4L2_TUNER_CAP_STEREO;\r\nv->audmode = radio->stereo ?\r\nV4L2_TUNER_MODE_STEREO : V4L2_TUNER_MODE_MONO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *v)\r\n{\r\nstruct ma901radio_device *radio = video_drvdata(file);\r\nif (v->index > 0)\r\nreturn -EINVAL;\r\nswitch (v->audmode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\nreturn ma901_set_stereo(radio, MA901_WANT_MONO);\r\ndefault:\r\nreturn ma901_set_stereo(radio, MA901_WANT_STEREO);\r\n}\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct ma901radio_device *radio = video_drvdata(file);\r\nif (f->tuner != 0)\r\nreturn -EINVAL;\r\nreturn ma901radio_set_freq(radio, clamp_t(unsigned, f->frequency,\r\nFREQ_MIN * FREQ_MUL, FREQ_MAX * FREQ_MUL));\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct ma901radio_device *radio = video_drvdata(file);\r\nif (f->tuner != 0)\r\nreturn -EINVAL;\r\nf->frequency = radio->curfreq;\r\nreturn 0;\r\n}\r\nstatic int usb_ma901radio_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct ma901radio_device *radio =\r\ncontainer_of(ctrl->handler, struct ma901radio_device, hdl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nreturn ma901radio_set_volume(radio, (u16)ctrl->val);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int usb_ma901radio_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nreturn 0;\r\n}\r\nstatic int usb_ma901radio_resume(struct usb_interface *intf)\r\n{\r\nreturn 0;\r\n}\r\nstatic void usb_ma901radio_release(struct v4l2_device *v4l2_dev)\r\n{\r\nstruct ma901radio_device *radio = to_ma901radio_dev(v4l2_dev);\r\nv4l2_ctrl_handler_free(&radio->hdl);\r\nv4l2_device_unregister(&radio->v4l2_dev);\r\nkfree(radio->buffer);\r\nkfree(radio);\r\n}\r\nstatic int usb_ma901radio_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct ma901radio_device *radio;\r\nint retval = 0;\r\nif (dev->product && dev->manufacturer &&\r\n(strncmp(dev->product, "MA901", 5) != 0\r\n|| strncmp(dev->manufacturer, "www.masterkit.ru", 16) != 0))\r\nreturn -ENODEV;\r\nradio = kzalloc(sizeof(struct ma901radio_device), GFP_KERNEL);\r\nif (!radio) {\r\ndev_err(&intf->dev, "kzalloc for ma901radio_device failed\n");\r\nretval = -ENOMEM;\r\ngoto err;\r\n}\r\nradio->buffer = kmalloc(BUFFER_LENGTH, GFP_KERNEL);\r\nif (!radio->buffer) {\r\ndev_err(&intf->dev, "kmalloc for radio->buffer failed\n");\r\nretval = -ENOMEM;\r\ngoto err_nobuf;\r\n}\r\nretval = v4l2_device_register(&intf->dev, &radio->v4l2_dev);\r\nif (retval < 0) {\r\ndev_err(&intf->dev, "couldn't register v4l2_device\n");\r\ngoto err_v4l2;\r\n}\r\nv4l2_ctrl_handler_init(&radio->hdl, 1);\r\nv4l2_ctrl_new_std(&radio->hdl, &usb_ma901radio_ctrl_ops,\r\nV4L2_CID_AUDIO_VOLUME, MA901_VOLUME_MIN,\r\nMA901_VOLUME_MAX, 1, MA901_VOLUME_MAX);\r\nif (radio->hdl.error) {\r\nretval = radio->hdl.error;\r\ndev_err(&intf->dev, "couldn't register control\n");\r\ngoto err_ctrl;\r\n}\r\nmutex_init(&radio->lock);\r\nradio->v4l2_dev.ctrl_handler = &radio->hdl;\r\nradio->v4l2_dev.release = usb_ma901radio_release;\r\nstrlcpy(radio->vdev.name, radio->v4l2_dev.name,\r\nsizeof(radio->vdev.name));\r\nradio->vdev.v4l2_dev = &radio->v4l2_dev;\r\nradio->vdev.fops = &usb_ma901radio_fops;\r\nradio->vdev.ioctl_ops = &usb_ma901radio_ioctl_ops;\r\nradio->vdev.release = video_device_release_empty;\r\nradio->vdev.lock = &radio->lock;\r\nradio->usbdev = interface_to_usbdev(intf);\r\nradio->intf = intf;\r\nusb_set_intfdata(intf, &radio->v4l2_dev);\r\nradio->curfreq = 95.21 * FREQ_MUL;\r\nvideo_set_drvdata(&radio->vdev, radio);\r\nretval = video_register_device(&radio->vdev, VFL_TYPE_RADIO,\r\nradio_nr);\r\nif (retval < 0) {\r\ndev_err(&intf->dev, "could not register video device\n");\r\ngoto err_vdev;\r\n}\r\nreturn 0;\r\nerr_vdev:\r\nv4l2_ctrl_handler_free(&radio->hdl);\r\nerr_ctrl:\r\nv4l2_device_unregister(&radio->v4l2_dev);\r\nerr_v4l2:\r\nkfree(radio->buffer);\r\nerr_nobuf:\r\nkfree(radio);\r\nerr:\r\nreturn retval;\r\n}
