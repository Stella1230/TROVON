bool rsi_is_cipher_wep(struct rsi_common *common)\r\n{\r\nif (((common->secinfo.gtk_cipher == WLAN_CIPHER_SUITE_WEP104) ||\r\n(common->secinfo.gtk_cipher == WLAN_CIPHER_SUITE_WEP40)) &&\r\n(!common->secinfo.ptk_cipher))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void rsi_register_rates_channels(struct rsi_hw *adapter, int band)\r\n{\r\nstruct ieee80211_supported_band *sbands = &adapter->sbands[band];\r\nvoid *channels = NULL;\r\nif (band == IEEE80211_BAND_2GHZ) {\r\nchannels = kmalloc(sizeof(rsi_2ghz_channels), GFP_KERNEL);\r\nmemcpy(channels,\r\nrsi_2ghz_channels,\r\nsizeof(rsi_2ghz_channels));\r\nsbands->band = IEEE80211_BAND_2GHZ;\r\nsbands->n_channels = ARRAY_SIZE(rsi_2ghz_channels);\r\nsbands->bitrates = rsi_rates;\r\nsbands->n_bitrates = ARRAY_SIZE(rsi_rates);\r\n} else {\r\nchannels = kmalloc(sizeof(rsi_5ghz_channels), GFP_KERNEL);\r\nmemcpy(channels,\r\nrsi_5ghz_channels,\r\nsizeof(rsi_5ghz_channels));\r\nsbands->band = IEEE80211_BAND_5GHZ;\r\nsbands->n_channels = ARRAY_SIZE(rsi_5ghz_channels);\r\nsbands->bitrates = &rsi_rates[4];\r\nsbands->n_bitrates = ARRAY_SIZE(rsi_rates) - 4;\r\n}\r\nsbands->channels = channels;\r\nmemset(&sbands->ht_cap, 0, sizeof(struct ieee80211_sta_ht_cap));\r\nsbands->ht_cap.ht_supported = true;\r\nsbands->ht_cap.cap = (IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\r\nIEEE80211_HT_CAP_SGI_20 |\r\nIEEE80211_HT_CAP_SGI_40);\r\nsbands->ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_16K;\r\nsbands->ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE;\r\nsbands->ht_cap.mcs.rx_mask[0] = 0xff;\r\nsbands->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\r\n}\r\nvoid rsi_mac80211_detach(struct rsi_hw *adapter)\r\n{\r\nstruct ieee80211_hw *hw = adapter->hw;\r\nif (hw) {\r\nieee80211_stop_queues(hw);\r\nieee80211_unregister_hw(hw);\r\nieee80211_free_hw(hw);\r\n}\r\nrsi_remove_dbgfs(adapter);\r\n}\r\nvoid rsi_indicate_tx_status(struct rsi_hw *adapter,\r\nstruct sk_buff *skb,\r\nint status)\r\n{\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nmemset(info->driver_data, 0, IEEE80211_TX_INFO_DRIVER_DATA_SIZE);\r\nif (!status)\r\ninfo->flags |= IEEE80211_TX_STAT_ACK;\r\nieee80211_tx_status_irqsafe(adapter->hw, skb);\r\n}\r\nstatic void rsi_mac80211_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_tx_control *control,\r\nstruct sk_buff *skb)\r\n{\r\nstruct rsi_hw *adapter = hw->priv;\r\nstruct rsi_common *common = adapter->priv;\r\nrsi_core_xmit(common, skb);\r\n}\r\nstatic int rsi_mac80211_start(struct ieee80211_hw *hw)\r\n{\r\nstruct rsi_hw *adapter = hw->priv;\r\nstruct rsi_common *common = adapter->priv;\r\nmutex_lock(&common->mutex);\r\ncommon->iface_down = false;\r\nmutex_unlock(&common->mutex);\r\nreturn 0;\r\n}\r\nstatic void rsi_mac80211_stop(struct ieee80211_hw *hw)\r\n{\r\nstruct rsi_hw *adapter = hw->priv;\r\nstruct rsi_common *common = adapter->priv;\r\nmutex_lock(&common->mutex);\r\ncommon->iface_down = true;\r\nmutex_unlock(&common->mutex);\r\n}\r\nstatic int rsi_mac80211_add_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct rsi_hw *adapter = hw->priv;\r\nstruct rsi_common *common = adapter->priv;\r\nint ret = -EOPNOTSUPP;\r\nmutex_lock(&common->mutex);\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\nif (!adapter->sc_nvifs) {\r\n++adapter->sc_nvifs;\r\nadapter->vifs[0] = vif;\r\nret = rsi_set_vap_capabilities(common, STA_OPMODE);\r\n}\r\nbreak;\r\ndefault:\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Interface type %d not supported\n", __func__,\r\nvif->type);\r\n}\r\nmutex_unlock(&common->mutex);\r\nreturn ret;\r\n}\r\nstatic void rsi_mac80211_remove_interface(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct rsi_hw *adapter = hw->priv;\r\nstruct rsi_common *common = adapter->priv;\r\nmutex_lock(&common->mutex);\r\nif (vif->type == NL80211_IFTYPE_STATION)\r\nadapter->sc_nvifs--;\r\nif (!memcmp(adapter->vifs[0], vif, sizeof(struct ieee80211_vif)))\r\nadapter->vifs[0] = NULL;\r\nmutex_unlock(&common->mutex);\r\n}\r\nstatic int rsi_channel_change(struct ieee80211_hw *hw)\r\n{\r\nstruct rsi_hw *adapter = hw->priv;\r\nstruct rsi_common *common = adapter->priv;\r\nint status = -EOPNOTSUPP;\r\nstruct ieee80211_channel *curchan = hw->conf.chandef.chan;\r\nu16 channel = curchan->hw_value;\r\nstruct ieee80211_bss_conf *bss = &adapter->vifs[0]->bss_conf;\r\nrsi_dbg(INFO_ZONE,\r\n"%s: Set channel: %d MHz type: %d channel_no %d\n",\r\n__func__, curchan->center_freq,\r\ncurchan->flags, channel);\r\nif (bss->assoc) {\r\nif (!common->hw_data_qs_blocked &&\r\n(rsi_get_connected_channel(adapter) != channel)) {\r\nrsi_dbg(INFO_ZONE, "blk data q %d\n", channel);\r\nif (!rsi_send_block_unblock_frame(common, true))\r\ncommon->hw_data_qs_blocked = true;\r\n}\r\n}\r\nstatus = rsi_band_check(common);\r\nif (!status)\r\nstatus = rsi_set_channel(adapter->priv, channel);\r\nif (bss->assoc) {\r\nif (common->hw_data_qs_blocked &&\r\n(rsi_get_connected_channel(adapter) == channel)) {\r\nrsi_dbg(INFO_ZONE, "unblk data q %d\n", channel);\r\nif (!rsi_send_block_unblock_frame(common, false))\r\ncommon->hw_data_qs_blocked = false;\r\n}\r\n} else {\r\nif (common->hw_data_qs_blocked) {\r\nrsi_dbg(INFO_ZONE, "unblk data q %d\n", channel);\r\nif (!rsi_send_block_unblock_frame(common, false))\r\ncommon->hw_data_qs_blocked = false;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int rsi_mac80211_config(struct ieee80211_hw *hw,\r\nu32 changed)\r\n{\r\nstruct rsi_hw *adapter = hw->priv;\r\nstruct rsi_common *common = adapter->priv;\r\nint status = -EOPNOTSUPP;\r\nmutex_lock(&common->mutex);\r\nif (changed & IEEE80211_CONF_CHANGE_CHANNEL)\r\nstatus = rsi_channel_change(hw);\r\nmutex_unlock(&common->mutex);\r\nreturn status;\r\n}\r\nu16 rsi_get_connected_channel(struct rsi_hw *adapter)\r\n{\r\nstruct ieee80211_vif *vif = adapter->vifs[0];\r\nif (vif) {\r\nstruct ieee80211_bss_conf *bss = &vif->bss_conf;\r\nstruct ieee80211_channel *channel = bss->chandef.chan;\r\nreturn channel->hw_value;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rsi_mac80211_bss_info_changed(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *bss_conf,\r\nu32 changed)\r\n{\r\nstruct rsi_hw *adapter = hw->priv;\r\nstruct rsi_common *common = adapter->priv;\r\nmutex_lock(&common->mutex);\r\nif (changed & BSS_CHANGED_ASSOC) {\r\nrsi_dbg(INFO_ZONE, "%s: Changed Association status: %d\n",\r\n__func__, bss_conf->assoc);\r\nrsi_inform_bss_status(common,\r\nbss_conf->assoc,\r\nbss_conf->bssid,\r\nbss_conf->qos,\r\nbss_conf->aid);\r\n}\r\nif (changed & BSS_CHANGED_CQM) {\r\ncommon->cqm_info.last_cqm_event_rssi = 0;\r\ncommon->cqm_info.rssi_thold = bss_conf->cqm_rssi_thold;\r\ncommon->cqm_info.rssi_hyst = bss_conf->cqm_rssi_hyst;\r\nrsi_dbg(INFO_ZONE, "RSSI throld & hysteresis are: %d %d\n",\r\ncommon->cqm_info.rssi_thold,\r\ncommon->cqm_info.rssi_hyst);\r\n}\r\nmutex_unlock(&common->mutex);\r\n}\r\nstatic void rsi_mac80211_conf_filter(struct ieee80211_hw *hw,\r\nu32 changed_flags,\r\nu32 *total_flags,\r\nu64 multicast)\r\n{\r\n*total_flags &= RSI_SUPP_FILTERS;\r\n}\r\nstatic int rsi_mac80211_conf_tx(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif, u16 queue,\r\nconst struct ieee80211_tx_queue_params *params)\r\n{\r\nstruct rsi_hw *adapter = hw->priv;\r\nstruct rsi_common *common = adapter->priv;\r\nu8 idx = 0;\r\nif (queue >= IEEE80211_NUM_ACS)\r\nreturn 0;\r\nrsi_dbg(INFO_ZONE,\r\n"%s: Conf queue %d, aifs: %d, cwmin: %d cwmax: %d, txop: %d\n",\r\n__func__, queue, params->aifs,\r\nparams->cw_min, params->cw_max, params->txop);\r\nmutex_lock(&common->mutex);\r\nswitch (queue) {\r\ncase IEEE80211_AC_VO:\r\nidx = VO_Q;\r\nbreak;\r\ncase IEEE80211_AC_VI:\r\nidx = VI_Q;\r\nbreak;\r\ncase IEEE80211_AC_BE:\r\nidx = BE_Q;\r\nbreak;\r\ncase IEEE80211_AC_BK:\r\nidx = BK_Q;\r\nbreak;\r\ndefault:\r\nidx = BE_Q;\r\nbreak;\r\n}\r\nmemcpy(&common->edca_params[idx],\r\nparams,\r\nsizeof(struct ieee80211_tx_queue_params));\r\nmutex_unlock(&common->mutex);\r\nreturn 0;\r\n}\r\nstatic int rsi_hal_key_config(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nstruct rsi_hw *adapter = hw->priv;\r\nint status;\r\nu8 key_type;\r\nif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\r\nkey_type = RSI_PAIRWISE_KEY;\r\nelse\r\nkey_type = RSI_GROUP_KEY;\r\nrsi_dbg(ERR_ZONE, "%s: Cipher 0x%x key_type: %d key_len: %d\n",\r\n__func__, key->cipher, key_type, key->keylen);\r\nif ((key->cipher == WLAN_CIPHER_SUITE_WEP104) ||\r\n(key->cipher == WLAN_CIPHER_SUITE_WEP40)) {\r\nstatus = rsi_hal_load_key(adapter->priv,\r\nkey->key,\r\nkey->keylen,\r\nRSI_PAIRWISE_KEY,\r\nkey->keyidx,\r\nkey->cipher);\r\nif (status)\r\nreturn status;\r\n}\r\nreturn rsi_hal_load_key(adapter->priv,\r\nkey->key,\r\nkey->keylen,\r\nkey_type,\r\nkey->keyidx,\r\nkey->cipher);\r\n}\r\nstatic int rsi_mac80211_set_key(struct ieee80211_hw *hw,\r\nenum set_key_cmd cmd,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta,\r\nstruct ieee80211_key_conf *key)\r\n{\r\nstruct rsi_hw *adapter = hw->priv;\r\nstruct rsi_common *common = adapter->priv;\r\nstruct security_info *secinfo = &common->secinfo;\r\nint status;\r\nmutex_lock(&common->mutex);\r\nswitch (cmd) {\r\ncase SET_KEY:\r\nsecinfo->security_enable = true;\r\nstatus = rsi_hal_key_config(hw, vif, key);\r\nif (status) {\r\nmutex_unlock(&common->mutex);\r\nreturn status;\r\n}\r\nif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\r\nsecinfo->ptk_cipher = key->cipher;\r\nelse\r\nsecinfo->gtk_cipher = key->cipher;\r\nkey->hw_key_idx = key->keyidx;\r\nkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\r\nrsi_dbg(ERR_ZONE, "%s: RSI set_key\n", __func__);\r\nbreak;\r\ncase DISABLE_KEY:\r\nsecinfo->security_enable = false;\r\nrsi_dbg(ERR_ZONE, "%s: RSI del key\n", __func__);\r\nmemset(key, 0, sizeof(struct ieee80211_key_conf));\r\nstatus = rsi_hal_key_config(hw, vif, key);\r\nbreak;\r\ndefault:\r\nstatus = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nmutex_unlock(&common->mutex);\r\nreturn status;\r\n}\r\nstatic int rsi_mac80211_ampdu_action(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nenum ieee80211_ampdu_mlme_action action,\r\nstruct ieee80211_sta *sta,\r\nunsigned short tid,\r\nunsigned short *ssn,\r\nunsigned char buf_size)\r\n{\r\nint status = -EOPNOTSUPP;\r\nstruct rsi_hw *adapter = hw->priv;\r\nstruct rsi_common *common = adapter->priv;\r\nu16 seq_no = 0;\r\nu8 ii = 0;\r\nfor (ii = 0; ii < RSI_MAX_VIFS; ii++) {\r\nif (vif == adapter->vifs[ii])\r\nbreak;\r\n}\r\nmutex_lock(&common->mutex);\r\nrsi_dbg(INFO_ZONE, "%s: AMPDU action %d called\n", __func__, action);\r\nif (ssn != NULL)\r\nseq_no = *ssn;\r\nswitch (action) {\r\ncase IEEE80211_AMPDU_RX_START:\r\nstatus = rsi_send_aggregation_params_frame(common,\r\ntid,\r\nseq_no,\r\nbuf_size,\r\nSTA_RX_ADDBA_DONE);\r\nbreak;\r\ncase IEEE80211_AMPDU_RX_STOP:\r\nstatus = rsi_send_aggregation_params_frame(common,\r\ntid,\r\n0,\r\nbuf_size,\r\nSTA_RX_DELBA);\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_START:\r\ncommon->vif_info[ii].seq_start = seq_no;\r\nieee80211_start_tx_ba_cb_irqsafe(vif, sta->addr, tid);\r\nstatus = 0;\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_STOP_CONT:\r\ncase IEEE80211_AMPDU_TX_STOP_FLUSH:\r\ncase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\r\nstatus = rsi_send_aggregation_params_frame(common,\r\ntid,\r\nseq_no,\r\nbuf_size,\r\nSTA_TX_DELBA);\r\nif (!status)\r\nieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\r\nbreak;\r\ncase IEEE80211_AMPDU_TX_OPERATIONAL:\r\nstatus = rsi_send_aggregation_params_frame(common,\r\ntid,\r\ncommon->vif_info[ii]\r\n.seq_start,\r\nbuf_size,\r\nSTA_TX_ADDBA_DONE);\r\nbreak;\r\ndefault:\r\nrsi_dbg(ERR_ZONE, "%s: Uknown AMPDU action\n", __func__);\r\nbreak;\r\n}\r\nmutex_unlock(&common->mutex);\r\nreturn status;\r\n}\r\nstatic int rsi_mac80211_set_rts_threshold(struct ieee80211_hw *hw,\r\nu32 value)\r\n{\r\nstruct rsi_hw *adapter = hw->priv;\r\nstruct rsi_common *common = adapter->priv;\r\nmutex_lock(&common->mutex);\r\ncommon->rts_threshold = value;\r\nmutex_unlock(&common->mutex);\r\nreturn 0;\r\n}\r\nstatic int rsi_mac80211_set_rate_mask(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nconst struct cfg80211_bitrate_mask *mask)\r\n{\r\nstruct rsi_hw *adapter = hw->priv;\r\nstruct rsi_common *common = adapter->priv;\r\nenum ieee80211_band band = hw->conf.chandef.chan->band;\r\nmutex_lock(&common->mutex);\r\ncommon->fixedrate_mask[band] = 0;\r\nif (mask->control[band].legacy == 0xfff) {\r\ncommon->fixedrate_mask[band] =\r\n(mask->control[band].ht_mcs[0] << 12);\r\n} else {\r\ncommon->fixedrate_mask[band] =\r\nmask->control[band].legacy;\r\n}\r\nmutex_unlock(&common->mutex);\r\nreturn 0;\r\n}\r\nstatic void rsi_perform_cqm(struct rsi_common *common,\r\nu8 *bssid,\r\ns8 rssi)\r\n{\r\nstruct rsi_hw *adapter = common->priv;\r\ns8 last_event = common->cqm_info.last_cqm_event_rssi;\r\nint thold = common->cqm_info.rssi_thold;\r\nu32 hyst = common->cqm_info.rssi_hyst;\r\nenum nl80211_cqm_rssi_threshold_event event;\r\nif (rssi < thold && (last_event == 0 || rssi < (last_event - hyst)))\r\nevent = NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW;\r\nelse if (rssi > thold &&\r\n(last_event == 0 || rssi > (last_event + hyst)))\r\nevent = NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH;\r\nelse\r\nreturn;\r\ncommon->cqm_info.last_cqm_event_rssi = rssi;\r\nrsi_dbg(INFO_ZONE, "CQM: Notifying event: %d\n", event);\r\nieee80211_cqm_rssi_notify(adapter->vifs[0], event, GFP_KERNEL);\r\nreturn;\r\n}\r\nstatic void rsi_fill_rx_status(struct ieee80211_hw *hw,\r\nstruct sk_buff *skb,\r\nstruct rsi_common *common,\r\nstruct ieee80211_rx_status *rxs)\r\n{\r\nstruct ieee80211_bss_conf *bss = &common->priv->vifs[0]->bss_conf;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct skb_info *rx_params = (struct skb_info *)info->driver_data;\r\nstruct ieee80211_hdr *hdr;\r\nchar rssi = rx_params->rssi;\r\nu8 hdrlen = 0;\r\nu8 channel = rx_params->channel;\r\ns32 freq;\r\nhdr = ((struct ieee80211_hdr *)(skb->data));\r\nhdrlen = ieee80211_hdrlen(hdr->frame_control);\r\nmemset(info, 0, sizeof(struct ieee80211_tx_info));\r\nrxs->signal = -(rssi);\r\nrxs->band = common->band;\r\nfreq = ieee80211_channel_to_frequency(channel, rxs->band);\r\nif (freq)\r\nrxs->freq = freq;\r\nif (ieee80211_has_protected(hdr->frame_control)) {\r\nif (rsi_is_cipher_wep(common)) {\r\nmemmove(skb->data + 4, skb->data, hdrlen);\r\nskb_pull(skb, 4);\r\n} else {\r\nmemmove(skb->data + 8, skb->data, hdrlen);\r\nskb_pull(skb, 8);\r\nrxs->flag |= RX_FLAG_MMIC_STRIPPED;\r\n}\r\nrxs->flag |= RX_FLAG_DECRYPTED;\r\nrxs->flag |= RX_FLAG_IV_STRIPPED;\r\n}\r\nif (bss->assoc && !(memcmp(bss->bssid, hdr->addr2, ETH_ALEN))) {\r\nif (ieee80211_is_beacon(hdr->frame_control))\r\nrsi_perform_cqm(common, hdr->addr2, rxs->signal);\r\n}\r\nreturn;\r\n}\r\nvoid rsi_indicate_pkt_to_os(struct rsi_common *common,\r\nstruct sk_buff *skb)\r\n{\r\nstruct rsi_hw *adapter = common->priv;\r\nstruct ieee80211_hw *hw = adapter->hw;\r\nstruct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);\r\nif ((common->iface_down) || (!adapter->sc_nvifs)) {\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nrsi_fill_rx_status(hw, skb, common, rx_status);\r\nieee80211_rx_irqsafe(hw, skb);\r\n}\r\nstatic void rsi_set_min_rate(struct ieee80211_hw *hw,\r\nstruct ieee80211_sta *sta,\r\nstruct rsi_common *common)\r\n{\r\nu8 band = hw->conf.chandef.chan->band;\r\nu8 ii;\r\nu32 rate_bitmap;\r\nbool matched = false;\r\ncommon->bitrate_mask[band] = sta->supp_rates[band];\r\nrate_bitmap = (common->fixedrate_mask[band] & sta->supp_rates[band]);\r\nif (rate_bitmap & 0xfff) {\r\nfor (ii = 0; ii < ARRAY_SIZE(rsi_rates); ii++) {\r\nif (rate_bitmap & BIT(ii)) {\r\ncommon->min_rate = rsi_rates[ii].hw_value;\r\nmatched = true;\r\nbreak;\r\n}\r\n}\r\n}\r\ncommon->vif_info[0].is_ht = sta->ht_cap.ht_supported;\r\nif ((common->vif_info[0].is_ht) && (rate_bitmap >> 12)) {\r\nfor (ii = 0; ii < ARRAY_SIZE(rsi_mcsrates); ii++) {\r\nif ((rate_bitmap >> 12) & BIT(ii)) {\r\ncommon->min_rate = rsi_mcsrates[ii];\r\nmatched = true;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!matched)\r\ncommon->min_rate = 0xffff;\r\n}\r\nstatic int rsi_mac80211_sta_add(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct rsi_hw *adapter = hw->priv;\r\nstruct rsi_common *common = adapter->priv;\r\nmutex_lock(&common->mutex);\r\nrsi_set_min_rate(hw, sta, common);\r\nif ((sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ||\r\n(sta->ht_cap.cap & IEEE80211_HT_CAP_SGI_40)) {\r\ncommon->vif_info[0].sgi = true;\r\n}\r\nif (sta->ht_cap.ht_supported)\r\nieee80211_start_tx_ba_session(sta, 0, 0);\r\nmutex_unlock(&common->mutex);\r\nreturn 0;\r\n}\r\nstatic int rsi_mac80211_sta_remove(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_sta *sta)\r\n{\r\nstruct rsi_hw *adapter = hw->priv;\r\nstruct rsi_common *common = adapter->priv;\r\nmutex_lock(&common->mutex);\r\ncommon->bitrate_mask[IEEE80211_BAND_2GHZ] = 0;\r\ncommon->bitrate_mask[IEEE80211_BAND_5GHZ] = 0;\r\ncommon->min_rate = 0xffff;\r\ncommon->vif_info[0].is_ht = false;\r\ncommon->vif_info[0].sgi = false;\r\ncommon->vif_info[0].seq_start = 0;\r\ncommon->secinfo.ptk_cipher = 0;\r\ncommon->secinfo.gtk_cipher = 0;\r\nmutex_unlock(&common->mutex);\r\nreturn 0;\r\n}\r\nint rsi_mac80211_attach(struct rsi_common *common)\r\n{\r\nint status = 0;\r\nstruct ieee80211_hw *hw = NULL;\r\nstruct wiphy *wiphy = NULL;\r\nstruct rsi_hw *adapter = common->priv;\r\nu8 addr_mask[ETH_ALEN] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x3};\r\nrsi_dbg(INIT_ZONE, "%s: Performing mac80211 attach\n", __func__);\r\nhw = ieee80211_alloc_hw(sizeof(struct rsi_hw), &mac80211_ops);\r\nif (!hw) {\r\nrsi_dbg(ERR_ZONE, "%s: ieee80211 hw alloc failed\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nwiphy = hw->wiphy;\r\nSET_IEEE80211_DEV(hw, adapter->device);\r\nhw->priv = adapter;\r\nadapter->hw = hw;\r\nhw->flags = IEEE80211_HW_SIGNAL_DBM |\r\nIEEE80211_HW_HAS_RATE_CONTROL |\r\nIEEE80211_HW_AMPDU_AGGREGATION |\r\n0;\r\nhw->queues = MAX_HW_QUEUES;\r\nhw->extra_tx_headroom = RSI_NEEDED_HEADROOM;\r\nhw->max_rates = 1;\r\nhw->max_rate_tries = MAX_RETRIES;\r\nhw->max_tx_aggregation_subframes = 6;\r\nrsi_register_rates_channels(adapter, IEEE80211_BAND_2GHZ);\r\nrsi_register_rates_channels(adapter, IEEE80211_BAND_5GHZ);\r\nhw->rate_control_algorithm = "AARF";\r\nSET_IEEE80211_PERM_ADDR(hw, common->mac_addr);\r\nether_addr_copy(hw->wiphy->addr_mask, addr_mask);\r\nwiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);\r\nwiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\r\nwiphy->retry_short = RETRY_SHORT;\r\nwiphy->retry_long = RETRY_LONG;\r\nwiphy->frag_threshold = IEEE80211_MAX_FRAG_THRESHOLD;\r\nwiphy->rts_threshold = IEEE80211_MAX_RTS_THRESHOLD;\r\nwiphy->flags = 0;\r\nwiphy->available_antennas_rx = 1;\r\nwiphy->available_antennas_tx = 1;\r\nwiphy->bands[IEEE80211_BAND_2GHZ] =\r\n&adapter->sbands[IEEE80211_BAND_2GHZ];\r\nwiphy->bands[IEEE80211_BAND_5GHZ] =\r\n&adapter->sbands[IEEE80211_BAND_5GHZ];\r\nstatus = ieee80211_register_hw(hw);\r\nif (status)\r\nreturn status;\r\nreturn rsi_init_dbgfs(adapter);\r\n}
