static void svc_reclassify_socket(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nWARN_ON_ONCE(sock_owned_by_user(sk));\r\nif (sock_owned_by_user(sk))\r\nreturn;\r\nswitch (sk->sk_family) {\r\ncase AF_INET:\r\nsock_lock_init_class_and_name(sk, "slock-AF_INET-NFSD",\r\n&svc_slock_key[0],\r\n"sk_xprt.xpt_lock-AF_INET-NFSD",\r\n&svc_key[0]);\r\nbreak;\r\ncase AF_INET6:\r\nsock_lock_init_class_and_name(sk, "slock-AF_INET6-NFSD",\r\n&svc_slock_key[1],\r\n"sk_xprt.xpt_lock-AF_INET6-NFSD",\r\n&svc_key[1]);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void svc_reclassify_socket(struct socket *sock)\r\n{\r\n}\r\nstatic void svc_release_skb(struct svc_rqst *rqstp)\r\n{\r\nstruct sk_buff *skb = rqstp->rq_xprt_ctxt;\r\nif (skb) {\r\nstruct svc_sock *svsk =\r\ncontainer_of(rqstp->rq_xprt, struct svc_sock, sk_xprt);\r\nrqstp->rq_xprt_ctxt = NULL;\r\ndprintk("svc: service %p, releasing skb %p\n", rqstp, skb);\r\nskb_free_datagram_locked(svsk->sk_sk, skb);\r\n}\r\n}\r\nstatic void svc_set_cmsg_data(struct svc_rqst *rqstp, struct cmsghdr *cmh)\r\n{\r\nstruct svc_sock *svsk =\r\ncontainer_of(rqstp->rq_xprt, struct svc_sock, sk_xprt);\r\nswitch (svsk->sk_sk->sk_family) {\r\ncase AF_INET: {\r\nstruct in_pktinfo *pki = CMSG_DATA(cmh);\r\ncmh->cmsg_level = SOL_IP;\r\ncmh->cmsg_type = IP_PKTINFO;\r\npki->ipi_ifindex = 0;\r\npki->ipi_spec_dst.s_addr =\r\nsvc_daddr_in(rqstp)->sin_addr.s_addr;\r\ncmh->cmsg_len = CMSG_LEN(sizeof(*pki));\r\n}\r\nbreak;\r\ncase AF_INET6: {\r\nstruct in6_pktinfo *pki = CMSG_DATA(cmh);\r\nstruct sockaddr_in6 *daddr = svc_daddr_in6(rqstp);\r\ncmh->cmsg_level = SOL_IPV6;\r\ncmh->cmsg_type = IPV6_PKTINFO;\r\npki->ipi6_ifindex = daddr->sin6_scope_id;\r\npki->ipi6_addr = daddr->sin6_addr;\r\ncmh->cmsg_len = CMSG_LEN(sizeof(*pki));\r\n}\r\nbreak;\r\n}\r\n}\r\nint svc_send_common(struct socket *sock, struct xdr_buf *xdr,\r\nstruct page *headpage, unsigned long headoffset,\r\nstruct page *tailpage, unsigned long tailoffset)\r\n{\r\nint result;\r\nint size;\r\nstruct page **ppage = xdr->pages;\r\nsize_t base = xdr->page_base;\r\nunsigned int pglen = xdr->page_len;\r\nunsigned int flags = MSG_MORE;\r\nint slen;\r\nint len = 0;\r\nslen = xdr->len;\r\nif (slen == xdr->head[0].iov_len)\r\nflags = 0;\r\nlen = kernel_sendpage(sock, headpage, headoffset,\r\nxdr->head[0].iov_len, flags);\r\nif (len != xdr->head[0].iov_len)\r\ngoto out;\r\nslen -= xdr->head[0].iov_len;\r\nif (slen == 0)\r\ngoto out;\r\nsize = PAGE_SIZE - base < pglen ? PAGE_SIZE - base : pglen;\r\nwhile (pglen > 0) {\r\nif (slen == size)\r\nflags = 0;\r\nresult = kernel_sendpage(sock, *ppage, base, size, flags);\r\nif (result > 0)\r\nlen += result;\r\nif (result != size)\r\ngoto out;\r\nslen -= size;\r\npglen -= size;\r\nsize = PAGE_SIZE < pglen ? PAGE_SIZE : pglen;\r\nbase = 0;\r\nppage++;\r\n}\r\nif (xdr->tail[0].iov_len) {\r\nresult = kernel_sendpage(sock, tailpage, tailoffset,\r\nxdr->tail[0].iov_len, 0);\r\nif (result > 0)\r\nlen += result;\r\n}\r\nout:\r\nreturn len;\r\n}\r\nstatic int svc_sendto(struct svc_rqst *rqstp, struct xdr_buf *xdr)\r\n{\r\nstruct svc_sock *svsk =\r\ncontainer_of(rqstp->rq_xprt, struct svc_sock, sk_xprt);\r\nstruct socket *sock = svsk->sk_sock;\r\nunion {\r\nstruct cmsghdr hdr;\r\nlong all[SVC_PKTINFO_SPACE / sizeof(long)];\r\n} buffer;\r\nstruct cmsghdr *cmh = &buffer.hdr;\r\nint len = 0;\r\nunsigned long tailoff;\r\nunsigned long headoff;\r\nRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\r\nif (rqstp->rq_prot == IPPROTO_UDP) {\r\nstruct msghdr msg = {\r\n.msg_name = &rqstp->rq_addr,\r\n.msg_namelen = rqstp->rq_addrlen,\r\n.msg_control = cmh,\r\n.msg_controllen = sizeof(buffer),\r\n.msg_flags = MSG_MORE,\r\n};\r\nsvc_set_cmsg_data(rqstp, cmh);\r\nif (sock_sendmsg(sock, &msg, 0) < 0)\r\ngoto out;\r\n}\r\ntailoff = ((unsigned long)xdr->tail[0].iov_base) & (PAGE_SIZE-1);\r\nheadoff = 0;\r\nlen = svc_send_common(sock, xdr, rqstp->rq_respages[0], headoff,\r\nrqstp->rq_respages[0], tailoff);\r\nout:\r\ndprintk("svc: socket %p sendto([%p %Zu... ], %d) = %d (addr %s)\n",\r\nsvsk, xdr->head[0].iov_base, xdr->head[0].iov_len,\r\nxdr->len, len, svc_print_addr(rqstp, buf, sizeof(buf)));\r\nreturn len;\r\n}\r\nstatic int svc_one_sock_name(struct svc_sock *svsk, char *buf, int remaining)\r\n{\r\nconst struct sock *sk = svsk->sk_sk;\r\nconst char *proto_name = sk->sk_protocol == IPPROTO_UDP ?\r\n"udp" : "tcp";\r\nint len;\r\nswitch (sk->sk_family) {\r\ncase PF_INET:\r\nlen = snprintf(buf, remaining, "ipv4 %s %pI4 %d\n",\r\nproto_name,\r\n&inet_sk(sk)->inet_rcv_saddr,\r\ninet_sk(sk)->inet_num);\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase PF_INET6:\r\nlen = snprintf(buf, remaining, "ipv6 %s %pI6 %d\n",\r\nproto_name,\r\n&sk->sk_v6_rcv_saddr,\r\ninet_sk(sk)->inet_num);\r\nbreak;\r\n#endif\r\ndefault:\r\nlen = snprintf(buf, remaining, "*unknown-%d*\n",\r\nsk->sk_family);\r\n}\r\nif (len >= remaining) {\r\n*buf = '\0';\r\nreturn -ENAMETOOLONG;\r\n}\r\nreturn len;\r\n}\r\nstatic int svc_recvfrom(struct svc_rqst *rqstp, struct kvec *iov, int nr,\r\nint buflen)\r\n{\r\nstruct svc_sock *svsk =\r\ncontainer_of(rqstp->rq_xprt, struct svc_sock, sk_xprt);\r\nstruct msghdr msg = {\r\n.msg_flags = MSG_DONTWAIT,\r\n};\r\nint len;\r\nrqstp->rq_xprt_hlen = 0;\r\nclear_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);\r\nlen = kernel_recvmsg(svsk->sk_sock, &msg, iov, nr, buflen,\r\nmsg.msg_flags);\r\nif (len == buflen)\r\nset_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);\r\ndprintk("svc: socket %p recvfrom(%p, %Zu) = %d\n",\r\nsvsk, iov[0].iov_base, iov[0].iov_len, len);\r\nreturn len;\r\n}\r\nstatic int svc_partial_recvfrom(struct svc_rqst *rqstp,\r\nstruct kvec *iov, int nr,\r\nint buflen, unsigned int base)\r\n{\r\nsize_t save_iovlen;\r\nvoid *save_iovbase;\r\nunsigned int i;\r\nint ret;\r\nif (base == 0)\r\nreturn svc_recvfrom(rqstp, iov, nr, buflen);\r\nfor (i = 0; i < nr; i++) {\r\nif (iov[i].iov_len > base)\r\nbreak;\r\nbase -= iov[i].iov_len;\r\n}\r\nsave_iovlen = iov[i].iov_len;\r\nsave_iovbase = iov[i].iov_base;\r\niov[i].iov_len -= base;\r\niov[i].iov_base += base;\r\nret = svc_recvfrom(rqstp, &iov[i], nr - i, buflen);\r\niov[i].iov_len = save_iovlen;\r\niov[i].iov_base = save_iovbase;\r\nreturn ret;\r\n}\r\nstatic void svc_sock_setbufsize(struct socket *sock, unsigned int snd,\r\nunsigned int rcv)\r\n{\r\n#if 0\r\nmm_segment_t oldfs;\r\noldfs = get_fs(); set_fs(KERNEL_DS);\r\nsock_setsockopt(sock, SOL_SOCKET, SO_SNDBUF,\r\n(char*)&snd, sizeof(snd));\r\nsock_setsockopt(sock, SOL_SOCKET, SO_RCVBUF,\r\n(char*)&rcv, sizeof(rcv));\r\n#else\r\nlock_sock(sock->sk);\r\nsock->sk->sk_sndbuf = snd * 2;\r\nsock->sk->sk_rcvbuf = rcv * 2;\r\nsock->sk->sk_write_space(sock->sk);\r\nrelease_sock(sock->sk);\r\n#endif\r\n}\r\nstatic int svc_sock_secure_port(struct svc_rqst *rqstp)\r\n{\r\nreturn svc_port_is_privileged(svc_addr(rqstp));\r\n}\r\nstatic void svc_udp_data_ready(struct sock *sk)\r\n{\r\nstruct svc_sock *svsk = (struct svc_sock *)sk->sk_user_data;\r\nwait_queue_head_t *wq = sk_sleep(sk);\r\nif (svsk) {\r\ndprintk("svc: socket %p(inet %p), busy=%d\n",\r\nsvsk, sk,\r\ntest_bit(XPT_BUSY, &svsk->sk_xprt.xpt_flags));\r\nset_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);\r\nsvc_xprt_enqueue(&svsk->sk_xprt);\r\n}\r\nif (wq && waitqueue_active(wq))\r\nwake_up_interruptible(wq);\r\n}\r\nstatic void svc_write_space(struct sock *sk)\r\n{\r\nstruct svc_sock *svsk = (struct svc_sock *)(sk->sk_user_data);\r\nwait_queue_head_t *wq = sk_sleep(sk);\r\nif (svsk) {\r\ndprintk("svc: socket %p(inet %p), write_space busy=%d\n",\r\nsvsk, sk, test_bit(XPT_BUSY, &svsk->sk_xprt.xpt_flags));\r\nsvc_xprt_enqueue(&svsk->sk_xprt);\r\n}\r\nif (wq && waitqueue_active(wq)) {\r\ndprintk("RPC svc_write_space: someone sleeping on %p\n",\r\nsvsk);\r\nwake_up_interruptible(wq);\r\n}\r\n}\r\nstatic int svc_tcp_has_wspace(struct svc_xprt *xprt)\r\n{\r\nstruct svc_sock *svsk = container_of(xprt, struct svc_sock, sk_xprt);\r\nstruct svc_serv *serv = svsk->sk_xprt.xpt_server;\r\nint required;\r\nif (test_bit(XPT_LISTENER, &xprt->xpt_flags))\r\nreturn 1;\r\nrequired = atomic_read(&xprt->xpt_reserved) + serv->sv_max_mesg;\r\nif (sk_stream_wspace(svsk->sk_sk) >= required ||\r\n(sk_stream_min_wspace(svsk->sk_sk) == 0 &&\r\natomic_read(&xprt->xpt_reserved) == 0))\r\nreturn 1;\r\nset_bit(SOCK_NOSPACE, &svsk->sk_sock->flags);\r\nreturn 0;\r\n}\r\nstatic void svc_tcp_write_space(struct sock *sk)\r\n{\r\nstruct svc_sock *svsk = (struct svc_sock *)(sk->sk_user_data);\r\nstruct socket *sock = sk->sk_socket;\r\nif (!sk_stream_is_writeable(sk) || !sock)\r\nreturn;\r\nif (!svsk || svc_tcp_has_wspace(&svsk->sk_xprt))\r\nclear_bit(SOCK_NOSPACE, &sock->flags);\r\nsvc_write_space(sk);\r\n}\r\nstatic void svc_tcp_adjust_wspace(struct svc_xprt *xprt)\r\n{\r\nstruct svc_sock *svsk = container_of(xprt, struct svc_sock, sk_xprt);\r\nif (svc_tcp_has_wspace(xprt))\r\nclear_bit(SOCK_NOSPACE, &svsk->sk_sock->flags);\r\n}\r\nstatic int svc_udp_get_dest_address4(struct svc_rqst *rqstp,\r\nstruct cmsghdr *cmh)\r\n{\r\nstruct in_pktinfo *pki = CMSG_DATA(cmh);\r\nstruct sockaddr_in *daddr = svc_daddr_in(rqstp);\r\nif (cmh->cmsg_type != IP_PKTINFO)\r\nreturn 0;\r\ndaddr->sin_family = AF_INET;\r\ndaddr->sin_addr.s_addr = pki->ipi_spec_dst.s_addr;\r\nreturn 1;\r\n}\r\nstatic int svc_udp_get_dest_address6(struct svc_rqst *rqstp,\r\nstruct cmsghdr *cmh)\r\n{\r\nstruct in6_pktinfo *pki = CMSG_DATA(cmh);\r\nstruct sockaddr_in6 *daddr = svc_daddr_in6(rqstp);\r\nif (cmh->cmsg_type != IPV6_PKTINFO)\r\nreturn 0;\r\ndaddr->sin6_family = AF_INET6;\r\ndaddr->sin6_addr = pki->ipi6_addr;\r\ndaddr->sin6_scope_id = pki->ipi6_ifindex;\r\nreturn 1;\r\n}\r\nstatic int svc_udp_get_dest_address(struct svc_rqst *rqstp,\r\nstruct cmsghdr *cmh)\r\n{\r\nswitch (cmh->cmsg_level) {\r\ncase SOL_IP:\r\nreturn svc_udp_get_dest_address4(rqstp, cmh);\r\ncase SOL_IPV6:\r\nreturn svc_udp_get_dest_address6(rqstp, cmh);\r\n}\r\nreturn 0;\r\n}\r\nstatic int svc_udp_recvfrom(struct svc_rqst *rqstp)\r\n{\r\nstruct svc_sock *svsk =\r\ncontainer_of(rqstp->rq_xprt, struct svc_sock, sk_xprt);\r\nstruct svc_serv *serv = svsk->sk_xprt.xpt_server;\r\nstruct sk_buff *skb;\r\nunion {\r\nstruct cmsghdr hdr;\r\nlong all[SVC_PKTINFO_SPACE / sizeof(long)];\r\n} buffer;\r\nstruct cmsghdr *cmh = &buffer.hdr;\r\nstruct msghdr msg = {\r\n.msg_name = svc_addr(rqstp),\r\n.msg_control = cmh,\r\n.msg_controllen = sizeof(buffer),\r\n.msg_flags = MSG_DONTWAIT,\r\n};\r\nsize_t len;\r\nint err;\r\nif (test_and_clear_bit(XPT_CHNGBUF, &svsk->sk_xprt.xpt_flags))\r\nsvc_sock_setbufsize(svsk->sk_sock,\r\n(serv->sv_nrthreads+3) * serv->sv_max_mesg,\r\n(serv->sv_nrthreads+3) * serv->sv_max_mesg);\r\nclear_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);\r\nskb = NULL;\r\nerr = kernel_recvmsg(svsk->sk_sock, &msg, NULL,\r\n0, 0, MSG_PEEK | MSG_DONTWAIT);\r\nif (err >= 0)\r\nskb = skb_recv_datagram(svsk->sk_sk, 0, 1, &err);\r\nif (skb == NULL) {\r\nif (err != -EAGAIN) {\r\ndprintk("svc: recvfrom returned error %d\n", -err);\r\nset_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);\r\n}\r\nreturn 0;\r\n}\r\nlen = svc_addr_len(svc_addr(rqstp));\r\nrqstp->rq_addrlen = len;\r\nif (skb->tstamp.tv64 == 0) {\r\nskb->tstamp = ktime_get_real();\r\n}\r\nsvsk->sk_sk->sk_stamp = skb->tstamp;\r\nset_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);\r\nlen = skb->len - sizeof(struct udphdr);\r\nrqstp->rq_arg.len = len;\r\nrqstp->rq_prot = IPPROTO_UDP;\r\nif (!svc_udp_get_dest_address(rqstp, cmh)) {\r\nnet_warn_ratelimited("svc: received unknown control message %d/%d; dropping RPC reply datagram\n",\r\ncmh->cmsg_level, cmh->cmsg_type);\r\ngoto out_free;\r\n}\r\nrqstp->rq_daddrlen = svc_addr_len(svc_daddr(rqstp));\r\nif (skb_is_nonlinear(skb)) {\r\nlocal_bh_disable();\r\nif (csum_partial_copy_to_xdr(&rqstp->rq_arg, skb)) {\r\nlocal_bh_enable();\r\ngoto out_free;\r\n}\r\nlocal_bh_enable();\r\nskb_free_datagram_locked(svsk->sk_sk, skb);\r\n} else {\r\nrqstp->rq_arg.head[0].iov_base = skb->data +\r\nsizeof(struct udphdr);\r\nrqstp->rq_arg.head[0].iov_len = len;\r\nif (skb_checksum_complete(skb))\r\ngoto out_free;\r\nrqstp->rq_xprt_ctxt = skb;\r\n}\r\nrqstp->rq_arg.page_base = 0;\r\nif (len <= rqstp->rq_arg.head[0].iov_len) {\r\nrqstp->rq_arg.head[0].iov_len = len;\r\nrqstp->rq_arg.page_len = 0;\r\nrqstp->rq_respages = rqstp->rq_pages+1;\r\n} else {\r\nrqstp->rq_arg.page_len = len - rqstp->rq_arg.head[0].iov_len;\r\nrqstp->rq_respages = rqstp->rq_pages + 1 +\r\nDIV_ROUND_UP(rqstp->rq_arg.page_len, PAGE_SIZE);\r\n}\r\nrqstp->rq_next_page = rqstp->rq_respages+1;\r\nif (serv->sv_stats)\r\nserv->sv_stats->netudpcnt++;\r\nreturn len;\r\nout_free:\r\ntrace_kfree_skb(skb, svc_udp_recvfrom);\r\nskb_free_datagram_locked(svsk->sk_sk, skb);\r\nreturn 0;\r\n}\r\nstatic int\r\nsvc_udp_sendto(struct svc_rqst *rqstp)\r\n{\r\nint error;\r\nerror = svc_sendto(rqstp, &rqstp->rq_res);\r\nif (error == -ECONNREFUSED)\r\nerror = svc_sendto(rqstp, &rqstp->rq_res);\r\nreturn error;\r\n}\r\nstatic void svc_udp_prep_reply_hdr(struct svc_rqst *rqstp)\r\n{\r\n}\r\nstatic int svc_udp_has_wspace(struct svc_xprt *xprt)\r\n{\r\nstruct svc_sock *svsk = container_of(xprt, struct svc_sock, sk_xprt);\r\nstruct svc_serv *serv = xprt->xpt_server;\r\nunsigned long required;\r\nset_bit(SOCK_NOSPACE, &svsk->sk_sock->flags);\r\nrequired = atomic_read(&svsk->sk_xprt.xpt_reserved) + serv->sv_max_mesg;\r\nif (required*2 > sock_wspace(svsk->sk_sk))\r\nreturn 0;\r\nclear_bit(SOCK_NOSPACE, &svsk->sk_sock->flags);\r\nreturn 1;\r\n}\r\nstatic struct svc_xprt *svc_udp_accept(struct svc_xprt *xprt)\r\n{\r\nBUG();\r\nreturn NULL;\r\n}\r\nstatic struct svc_xprt *svc_udp_create(struct svc_serv *serv,\r\nstruct net *net,\r\nstruct sockaddr *sa, int salen,\r\nint flags)\r\n{\r\nreturn svc_create_socket(serv, IPPROTO_UDP, net, sa, salen, flags);\r\n}\r\nstatic void svc_udp_init(struct svc_sock *svsk, struct svc_serv *serv)\r\n{\r\nint err, level, optname, one = 1;\r\nsvc_xprt_init(sock_net(svsk->sk_sock->sk), &svc_udp_class,\r\n&svsk->sk_xprt, serv);\r\nclear_bit(XPT_CACHE_AUTH, &svsk->sk_xprt.xpt_flags);\r\nsvsk->sk_sk->sk_data_ready = svc_udp_data_ready;\r\nsvsk->sk_sk->sk_write_space = svc_write_space;\r\nsvc_sock_setbufsize(svsk->sk_sock,\r\n3 * svsk->sk_xprt.xpt_server->sv_max_mesg,\r\n3 * svsk->sk_xprt.xpt_server->sv_max_mesg);\r\nset_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);\r\nset_bit(XPT_CHNGBUF, &svsk->sk_xprt.xpt_flags);\r\nswitch (svsk->sk_sk->sk_family) {\r\ncase AF_INET:\r\nlevel = SOL_IP;\r\noptname = IP_PKTINFO;\r\nbreak;\r\ncase AF_INET6:\r\nlevel = SOL_IPV6;\r\noptname = IPV6_RECVPKTINFO;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nerr = kernel_setsockopt(svsk->sk_sock, level, optname,\r\n(char *)&one, sizeof(one));\r\ndprintk("svc: kernel_setsockopt returned %d\n", err);\r\n}\r\nstatic void svc_tcp_listen_data_ready(struct sock *sk)\r\n{\r\nstruct svc_sock *svsk = (struct svc_sock *)sk->sk_user_data;\r\nwait_queue_head_t *wq;\r\ndprintk("svc: socket %p TCP (listen) state change %d\n",\r\nsk, sk->sk_state);\r\nif (sk->sk_state == TCP_LISTEN) {\r\nif (svsk) {\r\nset_bit(XPT_CONN, &svsk->sk_xprt.xpt_flags);\r\nsvc_xprt_enqueue(&svsk->sk_xprt);\r\n} else\r\nprintk("svc: socket %p: no user data\n", sk);\r\n}\r\nwq = sk_sleep(sk);\r\nif (wq && waitqueue_active(wq))\r\nwake_up_interruptible_all(wq);\r\n}\r\nstatic void svc_tcp_state_change(struct sock *sk)\r\n{\r\nstruct svc_sock *svsk = (struct svc_sock *)sk->sk_user_data;\r\nwait_queue_head_t *wq = sk_sleep(sk);\r\ndprintk("svc: socket %p TCP (connected) state change %d (svsk %p)\n",\r\nsk, sk->sk_state, sk->sk_user_data);\r\nif (!svsk)\r\nprintk("svc: socket %p: no user data\n", sk);\r\nelse {\r\nset_bit(XPT_CLOSE, &svsk->sk_xprt.xpt_flags);\r\nsvc_xprt_enqueue(&svsk->sk_xprt);\r\n}\r\nif (wq && waitqueue_active(wq))\r\nwake_up_interruptible_all(wq);\r\n}\r\nstatic void svc_tcp_data_ready(struct sock *sk)\r\n{\r\nstruct svc_sock *svsk = (struct svc_sock *)sk->sk_user_data;\r\nwait_queue_head_t *wq = sk_sleep(sk);\r\ndprintk("svc: socket %p TCP data ready (svsk %p)\n",\r\nsk, sk->sk_user_data);\r\nif (svsk) {\r\nset_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);\r\nsvc_xprt_enqueue(&svsk->sk_xprt);\r\n}\r\nif (wq && waitqueue_active(wq))\r\nwake_up_interruptible(wq);\r\n}\r\nstatic struct svc_xprt *svc_tcp_accept(struct svc_xprt *xprt)\r\n{\r\nstruct svc_sock *svsk = container_of(xprt, struct svc_sock, sk_xprt);\r\nstruct sockaddr_storage addr;\r\nstruct sockaddr *sin = (struct sockaddr *) &addr;\r\nstruct svc_serv *serv = svsk->sk_xprt.xpt_server;\r\nstruct socket *sock = svsk->sk_sock;\r\nstruct socket *newsock;\r\nstruct svc_sock *newsvsk;\r\nint err, slen;\r\nRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\r\ndprintk("svc: tcp_accept %p sock %p\n", svsk, sock);\r\nif (!sock)\r\nreturn NULL;\r\nclear_bit(XPT_CONN, &svsk->sk_xprt.xpt_flags);\r\nerr = kernel_accept(sock, &newsock, O_NONBLOCK);\r\nif (err < 0) {\r\nif (err == -ENOMEM)\r\nprintk(KERN_WARNING "%s: no more sockets!\n",\r\nserv->sv_name);\r\nelse if (err != -EAGAIN)\r\nnet_warn_ratelimited("%s: accept failed (err %d)!\n",\r\nserv->sv_name, -err);\r\nreturn NULL;\r\n}\r\nset_bit(XPT_CONN, &svsk->sk_xprt.xpt_flags);\r\nerr = kernel_getpeername(newsock, sin, &slen);\r\nif (err < 0) {\r\nnet_warn_ratelimited("%s: peername failed (err %d)!\n",\r\nserv->sv_name, -err);\r\ngoto failed;\r\n}\r\nif (!svc_port_is_privileged(sin)) {\r\ndprintk("%s: connect from unprivileged port: %s\n",\r\nserv->sv_name,\r\n__svc_print_addr(sin, buf, sizeof(buf)));\r\n}\r\ndprintk("%s: connect from %s\n", serv->sv_name,\r\n__svc_print_addr(sin, buf, sizeof(buf)));\r\nnewsock->sk->sk_sndtimeo = HZ*30;\r\nnewsvsk = svc_setup_socket(serv, newsock,\r\n(SVC_SOCK_ANONYMOUS | SVC_SOCK_TEMPORARY));\r\nif (IS_ERR(newsvsk))\r\ngoto failed;\r\nsvc_xprt_set_remote(&newsvsk->sk_xprt, sin, slen);\r\nerr = kernel_getsockname(newsock, sin, &slen);\r\nif (unlikely(err < 0)) {\r\ndprintk("svc_tcp_accept: kernel_getsockname error %d\n", -err);\r\nslen = offsetof(struct sockaddr, sa_data);\r\n}\r\nsvc_xprt_set_local(&newsvsk->sk_xprt, sin, slen);\r\nif (sock_is_loopback(newsock->sk))\r\nset_bit(XPT_LOCAL, &newsvsk->sk_xprt.xpt_flags);\r\nelse\r\nclear_bit(XPT_LOCAL, &newsvsk->sk_xprt.xpt_flags);\r\nif (serv->sv_stats)\r\nserv->sv_stats->nettcpconn++;\r\nreturn &newsvsk->sk_xprt;\r\nfailed:\r\nsock_release(newsock);\r\nreturn NULL;\r\n}\r\nstatic unsigned int svc_tcp_restore_pages(struct svc_sock *svsk, struct svc_rqst *rqstp)\r\n{\r\nunsigned int i, len, npages;\r\nif (svsk->sk_datalen == 0)\r\nreturn 0;\r\nlen = svsk->sk_datalen;\r\nnpages = (len + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nfor (i = 0; i < npages; i++) {\r\nif (rqstp->rq_pages[i] != NULL)\r\nput_page(rqstp->rq_pages[i]);\r\nBUG_ON(svsk->sk_pages[i] == NULL);\r\nrqstp->rq_pages[i] = svsk->sk_pages[i];\r\nsvsk->sk_pages[i] = NULL;\r\n}\r\nrqstp->rq_arg.head[0].iov_base = page_address(rqstp->rq_pages[0]);\r\nreturn len;\r\n}\r\nstatic void svc_tcp_save_pages(struct svc_sock *svsk, struct svc_rqst *rqstp)\r\n{\r\nunsigned int i, len, npages;\r\nif (svsk->sk_datalen == 0)\r\nreturn;\r\nlen = svsk->sk_datalen;\r\nnpages = (len + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nfor (i = 0; i < npages; i++) {\r\nsvsk->sk_pages[i] = rqstp->rq_pages[i];\r\nrqstp->rq_pages[i] = NULL;\r\n}\r\n}\r\nstatic void svc_tcp_clear_pages(struct svc_sock *svsk)\r\n{\r\nunsigned int i, len, npages;\r\nif (svsk->sk_datalen == 0)\r\ngoto out;\r\nlen = svsk->sk_datalen;\r\nnpages = (len + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nfor (i = 0; i < npages; i++) {\r\nif (svsk->sk_pages[i] == NULL) {\r\nWARN_ON_ONCE(1);\r\ncontinue;\r\n}\r\nput_page(svsk->sk_pages[i]);\r\nsvsk->sk_pages[i] = NULL;\r\n}\r\nout:\r\nsvsk->sk_tcplen = 0;\r\nsvsk->sk_datalen = 0;\r\n}\r\nstatic int svc_tcp_recv_record(struct svc_sock *svsk, struct svc_rqst *rqstp)\r\n{\r\nstruct svc_serv *serv = svsk->sk_xprt.xpt_server;\r\nunsigned int want;\r\nint len;\r\nif (svsk->sk_tcplen < sizeof(rpc_fraghdr)) {\r\nstruct kvec iov;\r\nwant = sizeof(rpc_fraghdr) - svsk->sk_tcplen;\r\niov.iov_base = ((char *) &svsk->sk_reclen) + svsk->sk_tcplen;\r\niov.iov_len = want;\r\nif ((len = svc_recvfrom(rqstp, &iov, 1, want)) < 0)\r\ngoto error;\r\nsvsk->sk_tcplen += len;\r\nif (len < want) {\r\ndprintk("svc: short recvfrom while reading record "\r\n"length (%d of %d)\n", len, want);\r\nreturn -EAGAIN;\r\n}\r\ndprintk("svc: TCP record, %d bytes\n", svc_sock_reclen(svsk));\r\nif (svc_sock_reclen(svsk) + svsk->sk_datalen >\r\nserv->sv_max_mesg) {\r\nnet_notice_ratelimited("RPC: fragment too large: %d\n",\r\nsvc_sock_reclen(svsk));\r\ngoto err_delete;\r\n}\r\n}\r\nreturn svc_sock_reclen(svsk);\r\nerror:\r\ndprintk("RPC: TCP recv_record got %d\n", len);\r\nreturn len;\r\nerr_delete:\r\nset_bit(XPT_CLOSE, &svsk->sk_xprt.xpt_flags);\r\nreturn -EAGAIN;\r\n}\r\nstatic int receive_cb_reply(struct svc_sock *svsk, struct svc_rqst *rqstp)\r\n{\r\nstruct rpc_xprt *bc_xprt = svsk->sk_xprt.xpt_bc_xprt;\r\nstruct rpc_rqst *req = NULL;\r\nstruct kvec *src, *dst;\r\n__be32 *p = (__be32 *)rqstp->rq_arg.head[0].iov_base;\r\n__be32 xid;\r\n__be32 calldir;\r\nxid = *p++;\r\ncalldir = *p;\r\nif (!bc_xprt)\r\nreturn -EAGAIN;\r\nspin_lock_bh(&bc_xprt->transport_lock);\r\nreq = xprt_lookup_rqst(bc_xprt, xid);\r\nif (!req)\r\ngoto unlock_notfound;\r\nmemcpy(&req->rq_private_buf, &req->rq_rcv_buf, sizeof(struct xdr_buf));\r\ndst = &req->rq_private_buf.head[0];\r\nsrc = &rqstp->rq_arg.head[0];\r\nif (dst->iov_len < src->iov_len)\r\ngoto unlock_eagain;\r\nmemcpy(dst->iov_base, src->iov_base, src->iov_len);\r\nxprt_complete_rqst(req->rq_task, rqstp->rq_arg.len);\r\nrqstp->rq_arg.len = 0;\r\nspin_unlock_bh(&bc_xprt->transport_lock);\r\nreturn 0;\r\nunlock_notfound:\r\nprintk(KERN_NOTICE\r\n"%s: Got unrecognized reply: "\r\n"calldir 0x%x xpt_bc_xprt %p xid %08x\n",\r\n__func__, ntohl(calldir),\r\nbc_xprt, ntohl(xid));\r\nunlock_eagain:\r\nspin_unlock_bh(&bc_xprt->transport_lock);\r\nreturn -EAGAIN;\r\n}\r\nstatic int copy_pages_to_kvecs(struct kvec *vec, struct page **pages, int len)\r\n{\r\nint i = 0;\r\nint t = 0;\r\nwhile (t < len) {\r\nvec[i].iov_base = page_address(pages[i]);\r\nvec[i].iov_len = PAGE_SIZE;\r\ni++;\r\nt += PAGE_SIZE;\r\n}\r\nreturn i;\r\n}\r\nstatic void svc_tcp_fragment_received(struct svc_sock *svsk)\r\n{\r\ndprintk("svc: TCP %s record (%d bytes)\n",\r\nsvc_sock_final_rec(svsk) ? "final" : "nonfinal",\r\nsvc_sock_reclen(svsk));\r\nsvsk->sk_tcplen = 0;\r\nsvsk->sk_reclen = 0;\r\n}\r\nstatic int svc_tcp_recvfrom(struct svc_rqst *rqstp)\r\n{\r\nstruct svc_sock *svsk =\r\ncontainer_of(rqstp->rq_xprt, struct svc_sock, sk_xprt);\r\nstruct svc_serv *serv = svsk->sk_xprt.xpt_server;\r\nint len;\r\nstruct kvec *vec;\r\nunsigned int want, base;\r\n__be32 *p;\r\n__be32 calldir;\r\nint pnum;\r\ndprintk("svc: tcp_recv %p data %d conn %d close %d\n",\r\nsvsk, test_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags),\r\ntest_bit(XPT_CONN, &svsk->sk_xprt.xpt_flags),\r\ntest_bit(XPT_CLOSE, &svsk->sk_xprt.xpt_flags));\r\nlen = svc_tcp_recv_record(svsk, rqstp);\r\nif (len < 0)\r\ngoto error;\r\nbase = svc_tcp_restore_pages(svsk, rqstp);\r\nwant = svc_sock_reclen(svsk) - (svsk->sk_tcplen - sizeof(rpc_fraghdr));\r\nvec = rqstp->rq_vec;\r\npnum = copy_pages_to_kvecs(&vec[0], &rqstp->rq_pages[0],\r\nsvsk->sk_datalen + want);\r\nrqstp->rq_respages = &rqstp->rq_pages[pnum];\r\nrqstp->rq_next_page = rqstp->rq_respages + 1;\r\nlen = svc_partial_recvfrom(rqstp, vec, pnum, want, base);\r\nif (len >= 0) {\r\nsvsk->sk_tcplen += len;\r\nsvsk->sk_datalen += len;\r\n}\r\nif (len != want || !svc_sock_final_rec(svsk)) {\r\nsvc_tcp_save_pages(svsk, rqstp);\r\nif (len < 0 && len != -EAGAIN)\r\ngoto err_delete;\r\nif (len == want)\r\nsvc_tcp_fragment_received(svsk);\r\nelse\r\ndprintk("svc: incomplete TCP record (%d of %d)\n",\r\n(int)(svsk->sk_tcplen - sizeof(rpc_fraghdr)),\r\nsvc_sock_reclen(svsk));\r\ngoto err_noclose;\r\n}\r\nif (svsk->sk_datalen < 8) {\r\nsvsk->sk_datalen = 0;\r\ngoto err_delete;\r\n}\r\nrqstp->rq_arg.len = svsk->sk_datalen;\r\nrqstp->rq_arg.page_base = 0;\r\nif (rqstp->rq_arg.len <= rqstp->rq_arg.head[0].iov_len) {\r\nrqstp->rq_arg.head[0].iov_len = rqstp->rq_arg.len;\r\nrqstp->rq_arg.page_len = 0;\r\n} else\r\nrqstp->rq_arg.page_len = rqstp->rq_arg.len - rqstp->rq_arg.head[0].iov_len;\r\nrqstp->rq_xprt_ctxt = NULL;\r\nrqstp->rq_prot = IPPROTO_TCP;\r\nif (test_bit(XPT_LOCAL, &svsk->sk_xprt.xpt_flags))\r\nset_bit(RQ_LOCAL, &rqstp->rq_flags);\r\nelse\r\nclear_bit(RQ_LOCAL, &rqstp->rq_flags);\r\np = (__be32 *)rqstp->rq_arg.head[0].iov_base;\r\ncalldir = p[1];\r\nif (calldir)\r\nlen = receive_cb_reply(svsk, rqstp);\r\nsvsk->sk_datalen = 0;\r\nsvc_tcp_fragment_received(svsk);\r\nif (len < 0)\r\ngoto error;\r\nsvc_xprt_copy_addrs(rqstp, &svsk->sk_xprt);\r\nif (serv->sv_stats)\r\nserv->sv_stats->nettcpcnt++;\r\nreturn rqstp->rq_arg.len;\r\nerror:\r\nif (len != -EAGAIN)\r\ngoto err_delete;\r\ndprintk("RPC: TCP recvfrom got EAGAIN\n");\r\nreturn 0;\r\nerr_delete:\r\nprintk(KERN_NOTICE "%s: recvfrom returned errno %d\n",\r\nsvsk->sk_xprt.xpt_server->sv_name, -len);\r\nset_bit(XPT_CLOSE, &svsk->sk_xprt.xpt_flags);\r\nerr_noclose:\r\nreturn 0;\r\n}\r\nstatic int svc_tcp_sendto(struct svc_rqst *rqstp)\r\n{\r\nstruct xdr_buf *xbufp = &rqstp->rq_res;\r\nint sent;\r\n__be32 reclen;\r\nreclen = htonl(0x80000000|((xbufp->len ) - 4));\r\nmemcpy(xbufp->head[0].iov_base, &reclen, 4);\r\nsent = svc_sendto(rqstp, &rqstp->rq_res);\r\nif (sent != xbufp->len) {\r\nprintk(KERN_NOTICE\r\n"rpc-srv/tcp: %s: %s %d when sending %d bytes "\r\n"- shutting down socket\n",\r\nrqstp->rq_xprt->xpt_server->sv_name,\r\n(sent<0)?"got error":"sent only",\r\nsent, xbufp->len);\r\nset_bit(XPT_CLOSE, &rqstp->rq_xprt->xpt_flags);\r\nsvc_xprt_enqueue(rqstp->rq_xprt);\r\nsent = -EAGAIN;\r\n}\r\nreturn sent;\r\n}\r\nstatic void svc_tcp_prep_reply_hdr(struct svc_rqst *rqstp)\r\n{\r\nstruct kvec *resv = &rqstp->rq_res.head[0];\r\nsvc_putnl(resv, 0);\r\n}\r\nstatic struct svc_xprt *svc_tcp_create(struct svc_serv *serv,\r\nstruct net *net,\r\nstruct sockaddr *sa, int salen,\r\nint flags)\r\n{\r\nreturn svc_create_socket(serv, IPPROTO_TCP, net, sa, salen, flags);\r\n}\r\nstatic struct svc_xprt *svc_bc_tcp_create(struct svc_serv *serv,\r\nstruct net *net,\r\nstruct sockaddr *sa, int salen,\r\nint flags)\r\n{\r\nreturn svc_bc_create_socket(serv, IPPROTO_TCP, net, sa, salen, flags);\r\n}\r\nstatic void svc_bc_tcp_sock_detach(struct svc_xprt *xprt)\r\n{\r\n}\r\nstatic void svc_init_bc_xprt_sock(void)\r\n{\r\nsvc_reg_xprt_class(&svc_tcp_bc_class);\r\n}\r\nstatic void svc_cleanup_bc_xprt_sock(void)\r\n{\r\nsvc_unreg_xprt_class(&svc_tcp_bc_class);\r\n}\r\nstatic void svc_init_bc_xprt_sock(void)\r\n{\r\n}\r\nstatic void svc_cleanup_bc_xprt_sock(void)\r\n{\r\n}\r\nvoid svc_init_xprt_sock(void)\r\n{\r\nsvc_reg_xprt_class(&svc_tcp_class);\r\nsvc_reg_xprt_class(&svc_udp_class);\r\nsvc_init_bc_xprt_sock();\r\n}\r\nvoid svc_cleanup_xprt_sock(void)\r\n{\r\nsvc_unreg_xprt_class(&svc_tcp_class);\r\nsvc_unreg_xprt_class(&svc_udp_class);\r\nsvc_cleanup_bc_xprt_sock();\r\n}\r\nstatic void svc_tcp_init(struct svc_sock *svsk, struct svc_serv *serv)\r\n{\r\nstruct sock *sk = svsk->sk_sk;\r\nsvc_xprt_init(sock_net(svsk->sk_sock->sk), &svc_tcp_class,\r\n&svsk->sk_xprt, serv);\r\nset_bit(XPT_CACHE_AUTH, &svsk->sk_xprt.xpt_flags);\r\nif (sk->sk_state == TCP_LISTEN) {\r\ndprintk("setting up TCP socket for listening\n");\r\nset_bit(XPT_LISTENER, &svsk->sk_xprt.xpt_flags);\r\nsk->sk_data_ready = svc_tcp_listen_data_ready;\r\nset_bit(XPT_CONN, &svsk->sk_xprt.xpt_flags);\r\n} else {\r\ndprintk("setting up TCP socket for reading\n");\r\nsk->sk_state_change = svc_tcp_state_change;\r\nsk->sk_data_ready = svc_tcp_data_ready;\r\nsk->sk_write_space = svc_tcp_write_space;\r\nsvsk->sk_reclen = 0;\r\nsvsk->sk_tcplen = 0;\r\nsvsk->sk_datalen = 0;\r\nmemset(&svsk->sk_pages[0], 0, sizeof(svsk->sk_pages));\r\ntcp_sk(sk)->nonagle |= TCP_NAGLE_OFF;\r\nset_bit(XPT_DATA, &svsk->sk_xprt.xpt_flags);\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\nset_bit(XPT_CLOSE, &svsk->sk_xprt.xpt_flags);\r\n}\r\n}\r\nvoid svc_sock_update_bufs(struct svc_serv *serv)\r\n{\r\nstruct svc_sock *svsk;\r\nspin_lock_bh(&serv->sv_lock);\r\nlist_for_each_entry(svsk, &serv->sv_permsocks, sk_xprt.xpt_list)\r\nset_bit(XPT_CHNGBUF, &svsk->sk_xprt.xpt_flags);\r\nspin_unlock_bh(&serv->sv_lock);\r\n}\r\nstatic struct svc_sock *svc_setup_socket(struct svc_serv *serv,\r\nstruct socket *sock,\r\nint flags)\r\n{\r\nstruct svc_sock *svsk;\r\nstruct sock *inet;\r\nint pmap_register = !(flags & SVC_SOCK_ANONYMOUS);\r\nint err = 0;\r\ndprintk("svc: svc_setup_socket %p\n", sock);\r\nsvsk = kzalloc(sizeof(*svsk), GFP_KERNEL);\r\nif (!svsk)\r\nreturn ERR_PTR(-ENOMEM);\r\ninet = sock->sk;\r\nif (pmap_register)\r\nerr = svc_register(serv, sock_net(sock->sk), inet->sk_family,\r\ninet->sk_protocol,\r\nntohs(inet_sk(inet)->inet_sport));\r\nif (err < 0) {\r\nkfree(svsk);\r\nreturn ERR_PTR(err);\r\n}\r\ninet->sk_user_data = svsk;\r\nsvsk->sk_sock = sock;\r\nsvsk->sk_sk = inet;\r\nsvsk->sk_ostate = inet->sk_state_change;\r\nsvsk->sk_odata = inet->sk_data_ready;\r\nsvsk->sk_owspace = inet->sk_write_space;\r\nif (sock->type == SOCK_DGRAM)\r\nsvc_udp_init(svsk, serv);\r\nelse {\r\nsvc_sock_setbufsize(svsk->sk_sock, 4 * serv->sv_max_mesg,\r\n4 * serv->sv_max_mesg);\r\nsvc_tcp_init(svsk, serv);\r\n}\r\ndprintk("svc: svc_setup_socket created %p (inet %p)\n",\r\nsvsk, svsk->sk_sk);\r\nreturn svsk;\r\n}\r\nbool svc_alien_sock(struct net *net, int fd)\r\n{\r\nint err;\r\nstruct socket *sock = sockfd_lookup(fd, &err);\r\nbool ret = false;\r\nif (!sock)\r\ngoto out;\r\nif (sock_net(sock->sk) != net)\r\nret = true;\r\nsockfd_put(sock);\r\nout:\r\nreturn ret;\r\n}\r\nint svc_addsock(struct svc_serv *serv, const int fd, char *name_return,\r\nconst size_t len)\r\n{\r\nint err = 0;\r\nstruct socket *so = sockfd_lookup(fd, &err);\r\nstruct svc_sock *svsk = NULL;\r\nstruct sockaddr_storage addr;\r\nstruct sockaddr *sin = (struct sockaddr *)&addr;\r\nint salen;\r\nif (!so)\r\nreturn err;\r\nerr = -EAFNOSUPPORT;\r\nif ((so->sk->sk_family != PF_INET) && (so->sk->sk_family != PF_INET6))\r\ngoto out;\r\nerr = -EPROTONOSUPPORT;\r\nif (so->sk->sk_protocol != IPPROTO_TCP &&\r\nso->sk->sk_protocol != IPPROTO_UDP)\r\ngoto out;\r\nerr = -EISCONN;\r\nif (so->state > SS_UNCONNECTED)\r\ngoto out;\r\nerr = -ENOENT;\r\nif (!try_module_get(THIS_MODULE))\r\ngoto out;\r\nsvsk = svc_setup_socket(serv, so, SVC_SOCK_DEFAULTS);\r\nif (IS_ERR(svsk)) {\r\nmodule_put(THIS_MODULE);\r\nerr = PTR_ERR(svsk);\r\ngoto out;\r\n}\r\nif (kernel_getsockname(svsk->sk_sock, sin, &salen) == 0)\r\nsvc_xprt_set_local(&svsk->sk_xprt, sin, salen);\r\nsvc_add_new_perm_xprt(serv, &svsk->sk_xprt);\r\nreturn svc_one_sock_name(svsk, name_return, len);\r\nout:\r\nsockfd_put(so);\r\nreturn err;\r\n}\r\nstatic struct svc_xprt *svc_create_socket(struct svc_serv *serv,\r\nint protocol,\r\nstruct net *net,\r\nstruct sockaddr *sin, int len,\r\nint flags)\r\n{\r\nstruct svc_sock *svsk;\r\nstruct socket *sock;\r\nint error;\r\nint type;\r\nstruct sockaddr_storage addr;\r\nstruct sockaddr *newsin = (struct sockaddr *)&addr;\r\nint newlen;\r\nint family;\r\nint val;\r\nRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\r\ndprintk("svc: svc_create_socket(%s, %d, %s)\n",\r\nserv->sv_program->pg_name, protocol,\r\n__svc_print_addr(sin, buf, sizeof(buf)));\r\nif (protocol != IPPROTO_UDP && protocol != IPPROTO_TCP) {\r\nprintk(KERN_WARNING "svc: only UDP and TCP "\r\n"sockets supported\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ntype = (protocol == IPPROTO_UDP)? SOCK_DGRAM : SOCK_STREAM;\r\nswitch (sin->sa_family) {\r\ncase AF_INET6:\r\nfamily = PF_INET6;\r\nbreak;\r\ncase AF_INET:\r\nfamily = PF_INET;\r\nbreak;\r\ndefault:\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nerror = __sock_create(net, family, type, protocol, &sock, 1);\r\nif (error < 0)\r\nreturn ERR_PTR(error);\r\nsvc_reclassify_socket(sock);\r\nval = 1;\r\nif (family == PF_INET6)\r\nkernel_setsockopt(sock, SOL_IPV6, IPV6_V6ONLY,\r\n(char *)&val, sizeof(val));\r\nif (type == SOCK_STREAM)\r\nsock->sk->sk_reuse = SK_CAN_REUSE;\r\nerror = kernel_bind(sock, sin, len);\r\nif (error < 0)\r\ngoto bummer;\r\nnewlen = len;\r\nerror = kernel_getsockname(sock, newsin, &newlen);\r\nif (error < 0)\r\ngoto bummer;\r\nif (protocol == IPPROTO_TCP) {\r\nif ((error = kernel_listen(sock, 64)) < 0)\r\ngoto bummer;\r\n}\r\nsvsk = svc_setup_socket(serv, sock, flags);\r\nif (IS_ERR(svsk)) {\r\nerror = PTR_ERR(svsk);\r\ngoto bummer;\r\n}\r\nsvc_xprt_set_local(&svsk->sk_xprt, newsin, newlen);\r\nreturn (struct svc_xprt *)svsk;\r\nbummer:\r\ndprintk("svc: svc_create_socket error = %d\n", -error);\r\nsock_release(sock);\r\nreturn ERR_PTR(error);\r\n}\r\nstatic void svc_sock_detach(struct svc_xprt *xprt)\r\n{\r\nstruct svc_sock *svsk = container_of(xprt, struct svc_sock, sk_xprt);\r\nstruct sock *sk = svsk->sk_sk;\r\nwait_queue_head_t *wq;\r\ndprintk("svc: svc_sock_detach(%p)\n", svsk);\r\nsk->sk_state_change = svsk->sk_ostate;\r\nsk->sk_data_ready = svsk->sk_odata;\r\nsk->sk_write_space = svsk->sk_owspace;\r\nwq = sk_sleep(sk);\r\nif (wq && waitqueue_active(wq))\r\nwake_up_interruptible(wq);\r\n}\r\nstatic void svc_tcp_sock_detach(struct svc_xprt *xprt)\r\n{\r\nstruct svc_sock *svsk = container_of(xprt, struct svc_sock, sk_xprt);\r\ndprintk("svc: svc_tcp_sock_detach(%p)\n", svsk);\r\nsvc_sock_detach(xprt);\r\nif (!test_bit(XPT_LISTENER, &xprt->xpt_flags)) {\r\nsvc_tcp_clear_pages(svsk);\r\nkernel_sock_shutdown(svsk->sk_sock, SHUT_RDWR);\r\n}\r\n}\r\nstatic void svc_sock_free(struct svc_xprt *xprt)\r\n{\r\nstruct svc_sock *svsk = container_of(xprt, struct svc_sock, sk_xprt);\r\ndprintk("svc: svc_sock_free(%p)\n", svsk);\r\nif (svsk->sk_sock->file)\r\nsockfd_put(svsk->sk_sock);\r\nelse\r\nsock_release(svsk->sk_sock);\r\nkfree(svsk);\r\n}\r\nstatic struct svc_xprt *svc_bc_create_socket(struct svc_serv *serv,\r\nint protocol,\r\nstruct net *net,\r\nstruct sockaddr *sin, int len,\r\nint flags)\r\n{\r\nstruct svc_sock *svsk;\r\nstruct svc_xprt *xprt;\r\nif (protocol != IPPROTO_TCP) {\r\nprintk(KERN_WARNING "svc: only TCP sockets"\r\n" supported on shared back channel\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nsvsk = kzalloc(sizeof(*svsk), GFP_KERNEL);\r\nif (!svsk)\r\nreturn ERR_PTR(-ENOMEM);\r\nxprt = &svsk->sk_xprt;\r\nsvc_xprt_init(net, &svc_tcp_bc_class, xprt, serv);\r\nserv->sv_bc_xprt = xprt;\r\nreturn xprt;\r\n}\r\nstatic void svc_bc_sock_free(struct svc_xprt *xprt)\r\n{\r\nif (xprt)\r\nkfree(container_of(xprt, struct svc_sock, sk_xprt));\r\n}
