int pcmcia_validate_mem(struct pcmcia_socket *s)\r\n{\r\nif (s->resource_ops->validate_mem)\r\nreturn s->resource_ops->validate_mem(s);\r\nreturn 0;\r\n}\r\nstruct resource *pcmcia_find_mem_region(u_long base, u_long num, u_long align,\r\nint low, struct pcmcia_socket *s)\r\n{\r\nif (s->resource_ops->find_mem)\r\nreturn s->resource_ops->find_mem(base, num, align, low, s);\r\nreturn NULL;\r\n}\r\nstatic void release_io_space(struct pcmcia_socket *s, struct resource *res)\r\n{\r\nresource_size_t num = resource_size(res);\r\nint i;\r\ndev_dbg(&s->dev, "release_io_space for %pR\n", res);\r\nfor (i = 0; i < MAX_IO_WIN; i++) {\r\nif (!s->io[i].res)\r\ncontinue;\r\nif ((s->io[i].res->start <= res->start) &&\r\n(s->io[i].res->end >= res->end)) {\r\ns->io[i].InUse -= num;\r\nif (res->parent)\r\nrelease_resource(res);\r\nres->start = res->end = 0;\r\nres->flags = IORESOURCE_IO;\r\nif (s->io[i].InUse == 0) {\r\nrelease_resource(s->io[i].res);\r\nkfree(s->io[i].res);\r\ns->io[i].res = NULL;\r\n}\r\n}\r\n}\r\n}\r\nstatic int alloc_io_space(struct pcmcia_socket *s, struct resource *res,\r\nunsigned int lines)\r\n{\r\nunsigned int align;\r\nunsigned int base = res->start;\r\nunsigned int num = res->end;\r\nint ret;\r\nres->flags |= IORESOURCE_IO;\r\ndev_dbg(&s->dev, "alloc_io_space request for %pR, %d lines\n",\r\nres, lines);\r\nalign = base ? (lines ? 1<<lines : 0) : 1;\r\nif (align && (align < num)) {\r\nif (base) {\r\ndev_dbg(&s->dev, "odd IO request\n");\r\nalign = 0;\r\n} else\r\nwhile (align && (align < num))\r\nalign <<= 1;\r\n}\r\nif (base & ~(align-1)) {\r\ndev_dbg(&s->dev, "odd IO request\n");\r\nalign = 0;\r\n}\r\nret = s->resource_ops->find_io(s, res->flags, &base, num, align,\r\n&res->parent);\r\nif (ret) {\r\ndev_dbg(&s->dev, "alloc_io_space request failed (%d)\n", ret);\r\nreturn -EINVAL;\r\n}\r\nres->start = base;\r\nres->end = res->start + num - 1;\r\nif (res->parent) {\r\nret = request_resource(res->parent, res);\r\nif (ret) {\r\ndev_warn(&s->dev,\r\n"request_resource %pR failed: %d\n", res, ret);\r\nres->parent = NULL;\r\nrelease_io_space(s, res);\r\n}\r\n}\r\ndev_dbg(&s->dev, "alloc_io_space request result %d: %pR\n", ret, res);\r\nreturn ret;\r\n}\r\nstatic int pcmcia_access_config(struct pcmcia_device *p_dev,\r\noff_t where, u8 *val,\r\nint (*accessf) (struct pcmcia_socket *s,\r\nint attr, unsigned int addr,\r\nunsigned int len, void *ptr))\r\n{\r\nstruct pcmcia_socket *s;\r\nconfig_t *c;\r\nint addr;\r\nint ret = 0;\r\ns = p_dev->socket;\r\nmutex_lock(&s->ops_mutex);\r\nc = p_dev->function_config;\r\nif (!(c->state & CONFIG_LOCKED)) {\r\ndev_dbg(&p_dev->dev, "Configuration isn't locked\n");\r\nmutex_unlock(&s->ops_mutex);\r\nreturn -EACCES;\r\n}\r\naddr = (p_dev->config_base + where) >> 1;\r\nret = accessf(s, 1, addr, 1, val);\r\nmutex_unlock(&s->ops_mutex);\r\nreturn ret;\r\n}\r\nint pcmcia_read_config_byte(struct pcmcia_device *p_dev, off_t where, u8 *val)\r\n{\r\nreturn pcmcia_access_config(p_dev, where, val, pcmcia_read_cis_mem);\r\n}\r\nint pcmcia_write_config_byte(struct pcmcia_device *p_dev, off_t where, u8 val)\r\n{\r\nreturn pcmcia_access_config(p_dev, where, &val, pcmcia_write_cis_mem);\r\n}\r\nint pcmcia_map_mem_page(struct pcmcia_device *p_dev, struct resource *res,\r\nunsigned int offset)\r\n{\r\nstruct pcmcia_socket *s = p_dev->socket;\r\nunsigned int w;\r\nint ret;\r\nw = ((res->flags & IORESOURCE_BITS & WIN_FLAGS_REQ) >> 2) - 1;\r\nif (w >= MAX_WIN)\r\nreturn -EINVAL;\r\nmutex_lock(&s->ops_mutex);\r\ns->win[w].card_start = offset;\r\nret = s->ops->set_mem_map(s, &s->win[w]);\r\nif (ret)\r\ndev_warn(&p_dev->dev, "failed to set_mem_map\n");\r\nmutex_unlock(&s->ops_mutex);\r\nreturn ret;\r\n}\r\nint pcmcia_fixup_iowidth(struct pcmcia_device *p_dev)\r\n{\r\nstruct pcmcia_socket *s = p_dev->socket;\r\npccard_io_map io_off = { 0, 0, 0, 0, 1 };\r\npccard_io_map io_on;\r\nint i, ret = 0;\r\nmutex_lock(&s->ops_mutex);\r\ndev_dbg(&p_dev->dev, "fixup iowidth to 8bit\n");\r\nif (!(s->state & SOCKET_PRESENT) ||\r\n!(p_dev->function_config->state & CONFIG_LOCKED)) {\r\ndev_dbg(&p_dev->dev, "No card? Config not locked?\n");\r\nret = -EACCES;\r\ngoto unlock;\r\n}\r\nio_on.speed = io_speed;\r\nfor (i = 0; i < MAX_IO_WIN; i++) {\r\nif (!s->io[i].res)\r\ncontinue;\r\nio_off.map = i;\r\nio_on.map = i;\r\nio_on.flags = MAP_ACTIVE | IO_DATA_PATH_WIDTH_8;\r\nio_on.start = s->io[i].res->start;\r\nio_on.stop = s->io[i].res->end;\r\ns->ops->set_io_map(s, &io_off);\r\nmdelay(40);\r\ns->ops->set_io_map(s, &io_on);\r\n}\r\nunlock:\r\nmutex_unlock(&s->ops_mutex);\r\nreturn ret;\r\n}\r\nint pcmcia_fixup_vpp(struct pcmcia_device *p_dev, unsigned char new_vpp)\r\n{\r\nstruct pcmcia_socket *s = p_dev->socket;\r\nint ret = 0;\r\nmutex_lock(&s->ops_mutex);\r\ndev_dbg(&p_dev->dev, "fixup Vpp to %d\n", new_vpp);\r\nif (!(s->state & SOCKET_PRESENT) ||\r\n!(p_dev->function_config->state & CONFIG_LOCKED)) {\r\ndev_dbg(&p_dev->dev, "No card? Config not locked?\n");\r\nret = -EACCES;\r\ngoto unlock;\r\n}\r\ns->socket.Vpp = new_vpp;\r\nif (s->ops->set_socket(s, &s->socket)) {\r\ndev_warn(&p_dev->dev, "Unable to set VPP\n");\r\nret = -EIO;\r\ngoto unlock;\r\n}\r\np_dev->vpp = new_vpp;\r\nunlock:\r\nmutex_unlock(&s->ops_mutex);\r\nreturn ret;\r\n}\r\nint pcmcia_release_configuration(struct pcmcia_device *p_dev)\r\n{\r\npccard_io_map io = { 0, 0, 0, 0, 1 };\r\nstruct pcmcia_socket *s = p_dev->socket;\r\nconfig_t *c;\r\nint i;\r\nmutex_lock(&s->ops_mutex);\r\nc = p_dev->function_config;\r\nif (p_dev->_locked) {\r\np_dev->_locked = 0;\r\nif (--(s->lock_count) == 0) {\r\ns->socket.flags = SS_OUTPUT_ENA;\r\ns->socket.Vpp = 0;\r\ns->socket.io_irq = 0;\r\ns->ops->set_socket(s, &s->socket);\r\n}\r\n}\r\nif (c->state & CONFIG_LOCKED) {\r\nc->state &= ~CONFIG_LOCKED;\r\nif (c->state & CONFIG_IO_REQ)\r\nfor (i = 0; i < MAX_IO_WIN; i++) {\r\nif (!s->io[i].res)\r\ncontinue;\r\ns->io[i].Config--;\r\nif (s->io[i].Config != 0)\r\ncontinue;\r\nio.map = i;\r\ns->ops->set_io_map(s, &io);\r\n}\r\n}\r\nmutex_unlock(&s->ops_mutex);\r\nreturn 0;\r\n}\r\nstatic int pcmcia_release_io(struct pcmcia_device *p_dev)\r\n{\r\nstruct pcmcia_socket *s = p_dev->socket;\r\nint ret = -EINVAL;\r\nconfig_t *c;\r\nmutex_lock(&s->ops_mutex);\r\nif (!p_dev->_io)\r\ngoto out;\r\nc = p_dev->function_config;\r\nrelease_io_space(s, &c->io[0]);\r\nif (c->io[1].end)\r\nrelease_io_space(s, &c->io[1]);\r\np_dev->_io = 0;\r\nc->state &= ~CONFIG_IO_REQ;\r\nout:\r\nmutex_unlock(&s->ops_mutex);\r\nreturn ret;\r\n}\r\nint pcmcia_release_window(struct pcmcia_device *p_dev, struct resource *res)\r\n{\r\nstruct pcmcia_socket *s = p_dev->socket;\r\npccard_mem_map *win;\r\nunsigned int w;\r\ndev_dbg(&p_dev->dev, "releasing window %pR\n", res);\r\nw = ((res->flags & IORESOURCE_BITS & WIN_FLAGS_REQ) >> 2) - 1;\r\nif (w >= MAX_WIN)\r\nreturn -EINVAL;\r\nmutex_lock(&s->ops_mutex);\r\nwin = &s->win[w];\r\nif (!(p_dev->_win & CLIENT_WIN_REQ(w))) {\r\ndev_dbg(&p_dev->dev, "not releasing unknown window\n");\r\nmutex_unlock(&s->ops_mutex);\r\nreturn -EINVAL;\r\n}\r\nwin->flags &= ~MAP_ACTIVE;\r\ns->ops->set_mem_map(s, win);\r\ns->state &= ~SOCKET_WIN_REQ(w);\r\nif (win->res) {\r\nrelease_resource(res);\r\nrelease_resource(win->res);\r\nkfree(win->res);\r\nwin->res = NULL;\r\n}\r\nres->start = res->end = 0;\r\nres->flags = IORESOURCE_MEM;\r\np_dev->_win &= ~CLIENT_WIN_REQ(w);\r\nmutex_unlock(&s->ops_mutex);\r\nreturn 0;\r\n}\r\nint pcmcia_enable_device(struct pcmcia_device *p_dev)\r\n{\r\nint i;\r\nunsigned int base;\r\nstruct pcmcia_socket *s = p_dev->socket;\r\nconfig_t *c;\r\npccard_io_map iomap;\r\nunsigned char status = 0;\r\nunsigned char ext_status = 0;\r\nunsigned char option = 0;\r\nunsigned int flags = p_dev->config_flags;\r\nif (!(s->state & SOCKET_PRESENT))\r\nreturn -ENODEV;\r\nmutex_lock(&s->ops_mutex);\r\nc = p_dev->function_config;\r\nif (c->state & CONFIG_LOCKED) {\r\nmutex_unlock(&s->ops_mutex);\r\ndev_dbg(&p_dev->dev, "Configuration is locked\n");\r\nreturn -EACCES;\r\n}\r\ns->socket.Vpp = p_dev->vpp;\r\nif (s->ops->set_socket(s, &s->socket)) {\r\nmutex_unlock(&s->ops_mutex);\r\ndev_printk(KERN_WARNING, &p_dev->dev,\r\n"Unable to set socket state\n");\r\nreturn -EINVAL;\r\n}\r\nif (p_dev->_io || flags & CONF_ENABLE_IRQ)\r\nflags |= CONF_ENABLE_IOCARD;\r\nif (flags & CONF_ENABLE_IOCARD)\r\ns->socket.flags |= SS_IOCARD;\r\nif (flags & CONF_ENABLE_ZVCARD)\r\ns->socket.flags |= SS_ZVCARD | SS_IOCARD;\r\nif (flags & CONF_ENABLE_SPKR) {\r\ns->socket.flags |= SS_SPKR_ENA;\r\nstatus = CCSR_AUDIO_ENA;\r\nif (!(p_dev->config_regs & PRESENT_STATUS))\r\ndev_warn(&p_dev->dev, "speaker requested, but "\r\n"PRESENT_STATUS not set!\n");\r\n}\r\nif (flags & CONF_ENABLE_IRQ)\r\ns->socket.io_irq = s->pcmcia_irq;\r\nelse\r\ns->socket.io_irq = 0;\r\nif (flags & CONF_ENABLE_ESR) {\r\np_dev->config_regs |= PRESENT_EXT_STATUS;\r\next_status = ESR_REQ_ATTN_ENA;\r\n}\r\ns->ops->set_socket(s, &s->socket);\r\ns->lock_count++;\r\ndev_dbg(&p_dev->dev,\r\n"enable_device: V %d, flags %x, base %x, regs %x, idx %x\n",\r\np_dev->vpp, flags, p_dev->config_base, p_dev->config_regs,\r\np_dev->config_index);\r\nbase = p_dev->config_base;\r\nif (p_dev->config_regs & PRESENT_COPY) {\r\nu16 tmp = 0;\r\ndev_dbg(&p_dev->dev, "clearing CISREG_SCR\n");\r\npcmcia_write_cis_mem(s, 1, (base + CISREG_SCR)>>1, 1, &tmp);\r\n}\r\nif (p_dev->config_regs & PRESENT_PIN_REPLACE) {\r\nu16 tmp = 0;\r\ndev_dbg(&p_dev->dev, "clearing CISREG_PRR\n");\r\npcmcia_write_cis_mem(s, 1, (base + CISREG_PRR)>>1, 1, &tmp);\r\n}\r\nif (p_dev->config_regs & PRESENT_OPTION) {\r\nif (s->functions == 1) {\r\noption = p_dev->config_index & COR_CONFIG_MASK;\r\n} else {\r\noption = p_dev->config_index & COR_MFC_CONFIG_MASK;\r\noption |= COR_FUNC_ENA|COR_IREQ_ENA;\r\nif (p_dev->config_regs & PRESENT_IOBASE_0)\r\noption |= COR_ADDR_DECODE;\r\n}\r\nif ((flags & CONF_ENABLE_IRQ) &&\r\n!(flags & CONF_ENABLE_PULSE_IRQ))\r\noption |= COR_LEVEL_REQ;\r\npcmcia_write_cis_mem(s, 1, (base + CISREG_COR)>>1, 1, &option);\r\nmdelay(40);\r\n}\r\nif (p_dev->config_regs & PRESENT_STATUS)\r\npcmcia_write_cis_mem(s, 1, (base + CISREG_CCSR)>>1, 1, &status);\r\nif (p_dev->config_regs & PRESENT_EXT_STATUS)\r\npcmcia_write_cis_mem(s, 1, (base + CISREG_ESR)>>1, 1,\r\n&ext_status);\r\nif (p_dev->config_regs & PRESENT_IOBASE_0) {\r\nu8 b = c->io[0].start & 0xff;\r\npcmcia_write_cis_mem(s, 1, (base + CISREG_IOBASE_0)>>1, 1, &b);\r\nb = (c->io[0].start >> 8) & 0xff;\r\npcmcia_write_cis_mem(s, 1, (base + CISREG_IOBASE_1)>>1, 1, &b);\r\n}\r\nif (p_dev->config_regs & PRESENT_IOSIZE) {\r\nu8 b = resource_size(&c->io[0]) + resource_size(&c->io[1]) - 1;\r\npcmcia_write_cis_mem(s, 1, (base + CISREG_IOSIZE)>>1, 1, &b);\r\n}\r\nif (c->state & CONFIG_IO_REQ) {\r\niomap.speed = io_speed;\r\nfor (i = 0; i < MAX_IO_WIN; i++)\r\nif (s->io[i].res) {\r\niomap.map = i;\r\niomap.flags = MAP_ACTIVE;\r\nswitch (s->io[i].res->flags & IO_DATA_PATH_WIDTH) {\r\ncase IO_DATA_PATH_WIDTH_16:\r\niomap.flags |= MAP_16BIT; break;\r\ncase IO_DATA_PATH_WIDTH_AUTO:\r\niomap.flags |= MAP_AUTOSZ; break;\r\ndefault:\r\nbreak;\r\n}\r\niomap.start = s->io[i].res->start;\r\niomap.stop = s->io[i].res->end;\r\ns->ops->set_io_map(s, &iomap);\r\ns->io[i].Config++;\r\n}\r\n}\r\nc->state |= CONFIG_LOCKED;\r\np_dev->_locked = 1;\r\nmutex_unlock(&s->ops_mutex);\r\nreturn 0;\r\n}\r\nint pcmcia_request_io(struct pcmcia_device *p_dev)\r\n{\r\nstruct pcmcia_socket *s = p_dev->socket;\r\nconfig_t *c = p_dev->function_config;\r\nint ret = -EINVAL;\r\nmutex_lock(&s->ops_mutex);\r\ndev_dbg(&p_dev->dev, "pcmcia_request_io: %pR , %pR",\r\n&c->io[0], &c->io[1]);\r\nif (!(s->state & SOCKET_PRESENT)) {\r\ndev_dbg(&p_dev->dev, "pcmcia_request_io: No card present\n");\r\ngoto out;\r\n}\r\nif (c->state & CONFIG_LOCKED) {\r\ndev_dbg(&p_dev->dev, "Configuration is locked\n");\r\ngoto out;\r\n}\r\nif (c->state & CONFIG_IO_REQ) {\r\ndev_dbg(&p_dev->dev, "IO already configured\n");\r\ngoto out;\r\n}\r\nret = alloc_io_space(s, &c->io[0], p_dev->io_lines);\r\nif (ret)\r\ngoto out;\r\nif (c->io[1].end) {\r\nret = alloc_io_space(s, &c->io[1], p_dev->io_lines);\r\nif (ret) {\r\nstruct resource tmp = c->io[0];\r\nrelease_io_space(s, &c->io[0]);\r\nc->io[0].end = resource_size(&tmp);\r\nc->io[0].start = tmp.start;\r\nc->io[0].flags = tmp.flags;\r\ngoto out;\r\n}\r\n} else\r\nc->io[1].start = 0;\r\nc->state |= CONFIG_IO_REQ;\r\np_dev->_io = 1;\r\ndev_dbg(&p_dev->dev, "pcmcia_request_io succeeded: %pR , %pR",\r\n&c->io[0], &c->io[1]);\r\nout:\r\nmutex_unlock(&s->ops_mutex);\r\nreturn ret;\r\n}\r\nint __must_check pcmcia_request_irq(struct pcmcia_device *p_dev,\r\nirq_handler_t handler)\r\n{\r\nint ret;\r\nif (!p_dev->irq)\r\nreturn -EINVAL;\r\nret = request_irq(p_dev->irq, handler, IRQF_SHARED,\r\np_dev->devname, p_dev->priv);\r\nif (!ret)\r\np_dev->_irq = 1;\r\nreturn ret;\r\n}\r\nint __must_check\r\n__pcmcia_request_exclusive_irq(struct pcmcia_device *p_dev,\r\nirq_handler_t handler)\r\n{\r\nint ret;\r\nif (!p_dev->irq)\r\nreturn -EINVAL;\r\nret = request_irq(p_dev->irq, handler, 0, p_dev->devname, p_dev->priv);\r\nif (ret) {\r\nret = pcmcia_request_irq(p_dev, handler);\r\ndev_printk(KERN_WARNING, &p_dev->dev, "pcmcia: "\r\n"request for exclusive IRQ could not be fulfilled.\n");\r\ndev_printk(KERN_WARNING, &p_dev->dev, "pcmcia: the driver "\r\n"needs updating to supported shared IRQ lines.\n");\r\n}\r\nif (ret)\r\ndev_printk(KERN_INFO, &p_dev->dev, "request_irq() failed\n");\r\nelse\r\np_dev->_irq = 1;\r\nreturn ret;\r\n}\r\nstatic irqreturn_t test_action(int cpl, void *dev_id)\r\n{\r\nreturn IRQ_NONE;\r\n}\r\nstatic int pcmcia_setup_isa_irq(struct pcmcia_device *p_dev, int type)\r\n{\r\nstruct pcmcia_socket *s = p_dev->socket;\r\nunsigned int try, irq;\r\nu32 mask = s->irq_mask;\r\nint ret = -ENODEV;\r\nfor (try = 0; try < 64; try++) {\r\nirq = try % 32;\r\nif (irq > NR_IRQS)\r\ncontinue;\r\nif (!((mask >> irq) & 1))\r\ncontinue;\r\nif ((try < 32) && pcmcia_used_irq[irq])\r\ncontinue;\r\nret = request_irq(irq, test_action, type, p_dev->devname,\r\np_dev);\r\nif (!ret) {\r\nfree_irq(irq, p_dev);\r\np_dev->irq = s->pcmcia_irq = irq;\r\npcmcia_used_irq[irq]++;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid pcmcia_cleanup_irq(struct pcmcia_socket *s)\r\n{\r\npcmcia_used_irq[s->pcmcia_irq]--;\r\ns->pcmcia_irq = 0;\r\n}\r\nstatic int pcmcia_setup_isa_irq(struct pcmcia_device *p_dev, int type)\r\n{\r\nreturn -EINVAL;\r\n}\r\nvoid pcmcia_cleanup_irq(struct pcmcia_socket *s)\r\n{\r\ns->pcmcia_irq = 0;\r\nreturn;\r\n}\r\nint pcmcia_setup_irq(struct pcmcia_device *p_dev)\r\n{\r\nstruct pcmcia_socket *s = p_dev->socket;\r\nif (p_dev->irq)\r\nreturn 0;\r\nif (s->pcmcia_irq) {\r\np_dev->irq = s->pcmcia_irq;\r\nreturn 0;\r\n}\r\nif (!pcmcia_setup_isa_irq(p_dev, 0))\r\nreturn 0;\r\nif (!pcmcia_setup_isa_irq(p_dev, IRQF_SHARED))\r\nreturn 0;\r\nif (s->pci_irq) {\r\np_dev->irq = s->pcmcia_irq = s->pci_irq;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint pcmcia_request_window(struct pcmcia_device *p_dev, struct resource *res,\r\nunsigned int speed)\r\n{\r\nstruct pcmcia_socket *s = p_dev->socket;\r\npccard_mem_map *win;\r\nu_long align;\r\nint w;\r\ndev_dbg(&p_dev->dev, "request_window %pR %d\n", res, speed);\r\nif (!(s->state & SOCKET_PRESENT)) {\r\ndev_dbg(&p_dev->dev, "No card present\n");\r\nreturn -ENODEV;\r\n}\r\nif (res->end == 0)\r\nres->end = s->map_size;\r\nalign = (s->features & SS_CAP_MEM_ALIGN) ? res->end : s->map_size;\r\nif (res->end & (s->map_size-1)) {\r\ndev_dbg(&p_dev->dev, "invalid map size\n");\r\nreturn -EINVAL;\r\n}\r\nif ((res->start && (s->features & SS_CAP_STATIC_MAP)) ||\r\n(res->start & (align-1))) {\r\ndev_dbg(&p_dev->dev, "invalid base address\n");\r\nreturn -EINVAL;\r\n}\r\nif (res->start)\r\nalign = 0;\r\nmutex_lock(&s->ops_mutex);\r\nfor (w = 0; w < MAX_WIN; w++)\r\nif (!(s->state & SOCKET_WIN_REQ(w)))\r\nbreak;\r\nif (w == MAX_WIN) {\r\ndev_dbg(&p_dev->dev, "all windows are used already\n");\r\nmutex_unlock(&s->ops_mutex);\r\nreturn -EINVAL;\r\n}\r\nwin = &s->win[w];\r\nif (!(s->features & SS_CAP_STATIC_MAP)) {\r\nwin->res = pcmcia_find_mem_region(res->start, res->end, align,\r\n0, s);\r\nif (!win->res) {\r\ndev_dbg(&p_dev->dev, "allocating mem region failed\n");\r\nmutex_unlock(&s->ops_mutex);\r\nreturn -EINVAL;\r\n}\r\n}\r\np_dev->_win |= CLIENT_WIN_REQ(w);\r\nwin->map = w+1;\r\nwin->flags = res->flags & WIN_FLAGS_MAP;\r\nwin->speed = speed;\r\nwin->card_start = 0;\r\nif (s->ops->set_mem_map(s, win) != 0) {\r\ndev_dbg(&p_dev->dev, "failed to set memory mapping\n");\r\nmutex_unlock(&s->ops_mutex);\r\nreturn -EIO;\r\n}\r\ns->state |= SOCKET_WIN_REQ(w);\r\nif (s->features & SS_CAP_STATIC_MAP)\r\nres->start = win->static_start;\r\nelse\r\nres->start = win->res->start;\r\nres->end += res->start - 1;\r\nres->flags &= ~WIN_FLAGS_REQ;\r\nres->flags |= (win->map << 2) | IORESOURCE_MEM;\r\nres->parent = win->res;\r\nif (win->res)\r\nrequest_resource(&iomem_resource, res);\r\ndev_dbg(&p_dev->dev, "request_window results in %pR\n", res);\r\nmutex_unlock(&s->ops_mutex);\r\nreturn 0;\r\n}\r\nvoid pcmcia_disable_device(struct pcmcia_device *p_dev)\r\n{\r\nint i;\r\ndev_dbg(&p_dev->dev, "disabling device\n");\r\nfor (i = 0; i < MAX_WIN; i++) {\r\nstruct resource *res = p_dev->resource[MAX_IO_WIN + i];\r\nif (res->flags & WIN_FLAGS_REQ)\r\npcmcia_release_window(p_dev, res);\r\n}\r\npcmcia_release_configuration(p_dev);\r\npcmcia_release_io(p_dev);\r\nif (p_dev->_irq) {\r\nfree_irq(p_dev->irq, p_dev->priv);\r\np_dev->_irq = 0;\r\n}\r\n}
