static inline int\r\ngoldfish_mmc_cover_is_open(struct goldfish_mmc_host *host)\r\n{\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\ngoldfish_mmc_show_cover_switch(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct goldfish_mmc_host *host = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", goldfish_mmc_cover_is_open(host) ? "open" :\r\n"closed");\r\n}\r\nstatic void\r\ngoldfish_mmc_start_command(struct goldfish_mmc_host *host, struct mmc_command *cmd)\r\n{\r\nu32 cmdreg;\r\nu32 resptype;\r\nu32 cmdtype;\r\nhost->cmd = cmd;\r\nresptype = 0;\r\ncmdtype = 0;\r\nswitch (mmc_resp_type(cmd)) {\r\ncase MMC_RSP_NONE:\r\nbreak;\r\ncase MMC_RSP_R1:\r\ncase MMC_RSP_R1B:\r\nresptype = 1;\r\nbreak;\r\ncase MMC_RSP_R2:\r\nresptype = 2;\r\nbreak;\r\ncase MMC_RSP_R3:\r\nresptype = 3;\r\nbreak;\r\ndefault:\r\ndev_err(mmc_dev(host->mmc),\r\n"Invalid response type: %04x\n", mmc_resp_type(cmd));\r\nbreak;\r\n}\r\nif (mmc_cmd_type(cmd) == MMC_CMD_ADTC)\r\ncmdtype = OMAP_MMC_CMDTYPE_ADTC;\r\nelse if (mmc_cmd_type(cmd) == MMC_CMD_BC)\r\ncmdtype = OMAP_MMC_CMDTYPE_BC;\r\nelse if (mmc_cmd_type(cmd) == MMC_CMD_BCR)\r\ncmdtype = OMAP_MMC_CMDTYPE_BCR;\r\nelse\r\ncmdtype = OMAP_MMC_CMDTYPE_AC;\r\ncmdreg = cmd->opcode | (resptype << 8) | (cmdtype << 12);\r\nif (host->bus_mode == MMC_BUSMODE_OPENDRAIN)\r\ncmdreg |= 1 << 6;\r\nif (cmd->flags & MMC_RSP_BUSY)\r\ncmdreg |= 1 << 11;\r\nif (host->data && !(host->data->flags & MMC_DATA_WRITE))\r\ncmdreg |= 1 << 15;\r\nGOLDFISH_MMC_WRITE(host, MMC_ARG, cmd->arg);\r\nGOLDFISH_MMC_WRITE(host, MMC_CMD, cmdreg);\r\n}\r\nstatic void goldfish_mmc_xfer_done(struct goldfish_mmc_host *host,\r\nstruct mmc_data *data)\r\n{\r\nif (host->dma_in_use) {\r\nenum dma_data_direction dma_data_dir;\r\nif (data->flags & MMC_DATA_WRITE)\r\ndma_data_dir = DMA_TO_DEVICE;\r\nelse\r\ndma_data_dir = DMA_FROM_DEVICE;\r\nif (dma_data_dir == DMA_FROM_DEVICE) {\r\nuint8_t *dest = (uint8_t *)sg_virt(data->sg);\r\nmemcpy(dest, host->virt_base, data->sg->length);\r\n}\r\nhost->data->bytes_xfered += data->sg->length;\r\ndma_unmap_sg(mmc_dev(host->mmc), data->sg, host->sg_len,\r\ndma_data_dir);\r\n}\r\nhost->data = NULL;\r\nhost->sg_len = 0;\r\nif (!data->stop) {\r\nhost->mrq = NULL;\r\nmmc_request_done(host->mmc, data->mrq);\r\nreturn;\r\n}\r\ngoldfish_mmc_start_command(host, data->stop);\r\n}\r\nstatic void goldfish_mmc_end_of_data(struct goldfish_mmc_host *host,\r\nstruct mmc_data *data)\r\n{\r\nif (!host->dma_in_use) {\r\ngoldfish_mmc_xfer_done(host, data);\r\nreturn;\r\n}\r\nif (host->dma_done)\r\ngoldfish_mmc_xfer_done(host, data);\r\n}\r\nstatic void goldfish_mmc_cmd_done(struct goldfish_mmc_host *host,\r\nstruct mmc_command *cmd)\r\n{\r\nhost->cmd = NULL;\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\nif (cmd->flags & MMC_RSP_136) {\r\ncmd->resp[3] =\r\nGOLDFISH_MMC_READ(host, MMC_RESP_0);\r\ncmd->resp[2] =\r\nGOLDFISH_MMC_READ(host, MMC_RESP_1);\r\ncmd->resp[1] =\r\nGOLDFISH_MMC_READ(host, MMC_RESP_2);\r\ncmd->resp[0] =\r\nGOLDFISH_MMC_READ(host, MMC_RESP_3);\r\n} else {\r\ncmd->resp[0] =\r\nGOLDFISH_MMC_READ(host, MMC_RESP_0);\r\n}\r\n}\r\nif (host->data == NULL || cmd->error) {\r\nhost->mrq = NULL;\r\nmmc_request_done(host->mmc, cmd->mrq);\r\n}\r\n}\r\nstatic irqreturn_t goldfish_mmc_irq(int irq, void *dev_id)\r\n{\r\nstruct goldfish_mmc_host *host = (struct goldfish_mmc_host *)dev_id;\r\nu16 status;\r\nint end_command = 0;\r\nint end_transfer = 0;\r\nint transfer_error = 0;\r\nint state_changed = 0;\r\nint cmd_timeout = 0;\r\nwhile ((status = GOLDFISH_MMC_READ(host, MMC_INT_STATUS)) != 0) {\r\nGOLDFISH_MMC_WRITE(host, MMC_INT_STATUS, status);\r\nif (status & MMC_STAT_END_OF_CMD)\r\nend_command = 1;\r\nif (status & MMC_STAT_END_OF_DATA)\r\nend_transfer = 1;\r\nif (status & MMC_STAT_STATE_CHANGE)\r\nstate_changed = 1;\r\nif (status & MMC_STAT_CMD_TIMEOUT) {\r\nend_command = 0;\r\ncmd_timeout = 1;\r\n}\r\n}\r\nif (cmd_timeout) {\r\nstruct mmc_request *mrq = host->mrq;\r\nmrq->cmd->error = -ETIMEDOUT;\r\nhost->mrq = NULL;\r\nmmc_request_done(host->mmc, mrq);\r\n}\r\nif (end_command)\r\ngoldfish_mmc_cmd_done(host, host->cmd);\r\nif (transfer_error)\r\ngoldfish_mmc_xfer_done(host, host->data);\r\nelse if (end_transfer) {\r\nhost->dma_done = 1;\r\ngoldfish_mmc_end_of_data(host, host->data);\r\n} else if (host->data != NULL) {\r\nhost->dma_done = 1;\r\ngoldfish_mmc_end_of_data(host, host->data);\r\n}\r\nif (state_changed) {\r\nu32 state = GOLDFISH_MMC_READ(host, MMC_STATE);\r\npr_info("%s: Card detect now %d\n", __func__,\r\n(state & MMC_STATE_INSERTED));\r\nmmc_detect_change(host->mmc, 0);\r\n}\r\nif (!end_command && !end_transfer &&\r\n!transfer_error && !state_changed && !cmd_timeout) {\r\nstatus = GOLDFISH_MMC_READ(host, MMC_INT_STATUS);\r\ndev_info(mmc_dev(host->mmc),"spurious irq 0x%04x\n", status);\r\nif (status != 0) {\r\nGOLDFISH_MMC_WRITE(host, MMC_INT_STATUS, status);\r\nGOLDFISH_MMC_WRITE(host, MMC_INT_ENABLE, 0);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void goldfish_mmc_prepare_data(struct goldfish_mmc_host *host,\r\nstruct mmc_request *req)\r\n{\r\nstruct mmc_data *data = req->data;\r\nint block_size;\r\nunsigned sg_len;\r\nenum dma_data_direction dma_data_dir;\r\nhost->data = data;\r\nif (data == NULL) {\r\nGOLDFISH_MMC_WRITE(host, MMC_BLOCK_LENGTH, 0);\r\nGOLDFISH_MMC_WRITE(host, MMC_BLOCK_COUNT, 0);\r\nhost->dma_in_use = 0;\r\nreturn;\r\n}\r\nblock_size = data->blksz;\r\nGOLDFISH_MMC_WRITE(host, MMC_BLOCK_COUNT, data->blocks - 1);\r\nGOLDFISH_MMC_WRITE(host, MMC_BLOCK_LENGTH, block_size - 1);\r\nsg_len = (data->blocks == 1) ? 1 : data->sg_len;\r\nif (data->flags & MMC_DATA_WRITE)\r\ndma_data_dir = DMA_TO_DEVICE;\r\nelse\r\ndma_data_dir = DMA_FROM_DEVICE;\r\nhost->sg_len = dma_map_sg(mmc_dev(host->mmc), data->sg,\r\nsg_len, dma_data_dir);\r\nhost->dma_done = 0;\r\nhost->dma_in_use = 1;\r\nif (dma_data_dir == DMA_TO_DEVICE) {\r\nconst uint8_t *src = (uint8_t *)sg_virt(data->sg);\r\nmemcpy(host->virt_base, src, data->sg->length);\r\n}\r\n}\r\nstatic void goldfish_mmc_request(struct mmc_host *mmc, struct mmc_request *req)\r\n{\r\nstruct goldfish_mmc_host *host = mmc_priv(mmc);\r\nWARN_ON(host->mrq != NULL);\r\nhost->mrq = req;\r\ngoldfish_mmc_prepare_data(host, req);\r\ngoldfish_mmc_start_command(host, req->cmd);\r\nif (req->cmd->opcode == SD_IO_SEND_OP_COND &&\r\nreq->cmd->flags == (MMC_RSP_SPI_R4 | MMC_RSP_R4 | MMC_CMD_BCR))\r\nreq->cmd->error = -EINVAL;\r\n}\r\nstatic void goldfish_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct goldfish_mmc_host *host = mmc_priv(mmc);\r\nhost->bus_mode = ios->bus_mode;\r\nhost->hw_bus_mode = host->bus_mode;\r\n}\r\nstatic int goldfish_mmc_get_ro(struct mmc_host *mmc)\r\n{\r\nuint32_t state;\r\nstruct goldfish_mmc_host *host = mmc_priv(mmc);\r\nstate = GOLDFISH_MMC_READ(host, MMC_STATE);\r\nreturn ((state & MMC_STATE_READ_ONLY) != 0);\r\n}\r\nstatic int goldfish_mmc_probe(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct goldfish_mmc_host *host = NULL;\r\nstruct resource *res;\r\nint ret = 0;\r\nint irq;\r\ndma_addr_t buf_addr;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (res == NULL || irq < 0)\r\nreturn -ENXIO;\r\nmmc = mmc_alloc_host(sizeof(struct goldfish_mmc_host), &pdev->dev);\r\nif (mmc == NULL) {\r\nret = -ENOMEM;\r\ngoto err_alloc_host_failed;\r\n}\r\nhost = mmc_priv(mmc);\r\nhost->mmc = mmc;\r\npr_err("mmc: Mapping %lX to %lX\n", (long)res->start, (long)res->end);\r\nhost->reg_base = ioremap(res->start, resource_size(res));\r\nif (host->reg_base == NULL) {\r\nret = -ENOMEM;\r\ngoto ioremap_failed;\r\n}\r\nhost->virt_base = dma_alloc_coherent(&pdev->dev, BUFFER_SIZE,\r\n&buf_addr, GFP_KERNEL);\r\nif (host->virt_base == 0) {\r\nret = -ENOMEM;\r\ngoto dma_alloc_failed;\r\n}\r\nhost->phys_base = buf_addr;\r\nhost->id = pdev->id;\r\nhost->irq = irq;\r\nmmc->ops = &goldfish_mmc_ops;\r\nmmc->f_min = 400000;\r\nmmc->f_max = 24000000;\r\nmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\r\nmmc->caps = MMC_CAP_4_BIT_DATA;\r\nmmc->max_segs = 32;\r\nmmc->max_blk_size = 2048;\r\nmmc->max_blk_count = 2048;\r\nmmc->max_req_size = BUFFER_SIZE;\r\nmmc->max_seg_size = mmc->max_req_size;\r\nret = request_irq(host->irq, goldfish_mmc_irq, 0, DRIVER_NAME, host);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed IRQ Adding goldfish MMC\n");\r\ngoto err_request_irq_failed;\r\n}\r\nhost->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, host);\r\nret = device_create_file(&pdev->dev, &dev_attr_cover_switch);\r\nif (ret)\r\ndev_warn(mmc_dev(host->mmc),\r\n"Unable to create sysfs attributes\n");\r\nGOLDFISH_MMC_WRITE(host, MMC_SET_BUFFER, host->phys_base);\r\nGOLDFISH_MMC_WRITE(host, MMC_INT_ENABLE,\r\nMMC_STAT_END_OF_CMD | MMC_STAT_END_OF_DATA |\r\nMMC_STAT_STATE_CHANGE | MMC_STAT_CMD_TIMEOUT);\r\nmmc_add_host(mmc);\r\nreturn 0;\r\nerr_request_irq_failed:\r\ndma_free_coherent(&pdev->dev, BUFFER_SIZE, host->virt_base,\r\nhost->phys_base);\r\ndma_alloc_failed:\r\niounmap(host->reg_base);\r\nioremap_failed:\r\nmmc_free_host(host->mmc);\r\nerr_alloc_host_failed:\r\nreturn ret;\r\n}\r\nstatic int goldfish_mmc_remove(struct platform_device *pdev)\r\n{\r\nstruct goldfish_mmc_host *host = platform_get_drvdata(pdev);\r\nBUG_ON(host == NULL);\r\nmmc_remove_host(host->mmc);\r\nfree_irq(host->irq, host);\r\ndma_free_coherent(&pdev->dev, BUFFER_SIZE, host->virt_base, host->phys_base);\r\niounmap(host->reg_base);\r\nmmc_free_host(host->mmc);\r\nreturn 0;\r\n}
