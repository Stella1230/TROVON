static inline int dataflash_status(struct spi_device *spi)\r\n{\r\nreturn spi_w8r8(spi, OP_READ_STATUS);\r\n}\r\nstatic int dataflash_waitready(struct spi_device *spi)\r\n{\r\nint status;\r\nfor (;;) {\r\nstatus = dataflash_status(spi);\r\nif (status < 0) {\r\npr_debug("%s: status %d?\n",\r\ndev_name(&spi->dev), status);\r\nstatus = 0;\r\n}\r\nif (status & (1 << 7))\r\nreturn status;\r\nmsleep(3);\r\n}\r\n}\r\nstatic int dataflash_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nstruct dataflash *priv = mtd->priv;\r\nstruct spi_device *spi = priv->spi;\r\nstruct spi_transfer x = { };\r\nstruct spi_message msg;\r\nunsigned blocksize = priv->page_size << 3;\r\nuint8_t *command;\r\nuint32_t rem;\r\npr_debug("%s: erase addr=0x%llx len 0x%llx\n",\r\ndev_name(&spi->dev), (long long)instr->addr,\r\n(long long)instr->len);\r\ndiv_u64_rem(instr->len, priv->page_size, &rem);\r\nif (rem)\r\nreturn -EINVAL;\r\ndiv_u64_rem(instr->addr, priv->page_size, &rem);\r\nif (rem)\r\nreturn -EINVAL;\r\nspi_message_init(&msg);\r\nx.tx_buf = command = priv->command;\r\nx.len = 4;\r\nspi_message_add_tail(&x, &msg);\r\nmutex_lock(&priv->lock);\r\nwhile (instr->len > 0) {\r\nunsigned int pageaddr;\r\nint status;\r\nint do_block;\r\npageaddr = div_u64(instr->addr, priv->page_size);\r\ndo_block = (pageaddr & 0x7) == 0 && instr->len >= blocksize;\r\npageaddr = pageaddr << priv->page_offset;\r\ncommand[0] = do_block ? OP_ERASE_BLOCK : OP_ERASE_PAGE;\r\ncommand[1] = (uint8_t)(pageaddr >> 16);\r\ncommand[2] = (uint8_t)(pageaddr >> 8);\r\ncommand[3] = 0;\r\npr_debug("ERASE %s: (%x) %x %x %x [%i]\n",\r\ndo_block ? "block" : "page",\r\ncommand[0], command[1], command[2], command[3],\r\npageaddr);\r\nstatus = spi_sync(spi, &msg);\r\n(void) dataflash_waitready(spi);\r\nif (status < 0) {\r\nprintk(KERN_ERR "%s: erase %x, err %d\n",\r\ndev_name(&spi->dev), pageaddr, status);\r\ncontinue;\r\n}\r\nif (do_block) {\r\ninstr->addr += blocksize;\r\ninstr->len -= blocksize;\r\n} else {\r\ninstr->addr += priv->page_size;\r\ninstr->len -= priv->page_size;\r\n}\r\n}\r\nmutex_unlock(&priv->lock);\r\ninstr->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(instr);\r\nreturn 0;\r\n}\r\nstatic int dataflash_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nstruct dataflash *priv = mtd->priv;\r\nstruct spi_transfer x[2] = { };\r\nstruct spi_message msg;\r\nunsigned int addr;\r\nuint8_t *command;\r\nint status;\r\npr_debug("%s: read 0x%x..0x%x\n", dev_name(&priv->spi->dev),\r\n(unsigned)from, (unsigned)(from + len));\r\naddr = (((unsigned)from / priv->page_size) << priv->page_offset)\r\n+ ((unsigned)from % priv->page_size);\r\ncommand = priv->command;\r\npr_debug("READ: (%x) %x %x %x\n",\r\ncommand[0], command[1], command[2], command[3]);\r\nspi_message_init(&msg);\r\nx[0].tx_buf = command;\r\nx[0].len = 8;\r\nspi_message_add_tail(&x[0], &msg);\r\nx[1].rx_buf = buf;\r\nx[1].len = len;\r\nspi_message_add_tail(&x[1], &msg);\r\nmutex_lock(&priv->lock);\r\ncommand[0] = OP_READ_CONTINUOUS;\r\ncommand[1] = (uint8_t)(addr >> 16);\r\ncommand[2] = (uint8_t)(addr >> 8);\r\ncommand[3] = (uint8_t)(addr >> 0);\r\nstatus = spi_sync(priv->spi, &msg);\r\nmutex_unlock(&priv->lock);\r\nif (status >= 0) {\r\n*retlen = msg.actual_length - 8;\r\nstatus = 0;\r\n} else\r\npr_debug("%s: read %x..%x --> %d\n",\r\ndev_name(&priv->spi->dev),\r\n(unsigned)from, (unsigned)(from + len),\r\nstatus);\r\nreturn status;\r\n}\r\nstatic int dataflash_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t * retlen, const u_char * buf)\r\n{\r\nstruct dataflash *priv = mtd->priv;\r\nstruct spi_device *spi = priv->spi;\r\nstruct spi_transfer x[2] = { };\r\nstruct spi_message msg;\r\nunsigned int pageaddr, addr, offset, writelen;\r\nsize_t remaining = len;\r\nu_char *writebuf = (u_char *) buf;\r\nint status = -EINVAL;\r\nuint8_t *command;\r\npr_debug("%s: write 0x%x..0x%x\n",\r\ndev_name(&spi->dev), (unsigned)to, (unsigned)(to + len));\r\nspi_message_init(&msg);\r\nx[0].tx_buf = command = priv->command;\r\nx[0].len = 4;\r\nspi_message_add_tail(&x[0], &msg);\r\npageaddr = ((unsigned)to / priv->page_size);\r\noffset = ((unsigned)to % priv->page_size);\r\nif (offset + len > priv->page_size)\r\nwritelen = priv->page_size - offset;\r\nelse\r\nwritelen = len;\r\nmutex_lock(&priv->lock);\r\nwhile (remaining > 0) {\r\npr_debug("write @ %i:%i len=%i\n",\r\npageaddr, offset, writelen);\r\naddr = pageaddr << priv->page_offset;\r\nif (writelen != priv->page_size) {\r\ncommand[0] = OP_TRANSFER_BUF1;\r\ncommand[1] = (addr & 0x00FF0000) >> 16;\r\ncommand[2] = (addr & 0x0000FF00) >> 8;\r\ncommand[3] = 0;\r\npr_debug("TRANSFER: (%x) %x %x %x\n",\r\ncommand[0], command[1], command[2], command[3]);\r\nstatus = spi_sync(spi, &msg);\r\nif (status < 0)\r\npr_debug("%s: xfer %u -> %d\n",\r\ndev_name(&spi->dev), addr, status);\r\n(void) dataflash_waitready(priv->spi);\r\n}\r\naddr += offset;\r\ncommand[0] = OP_PROGRAM_VIA_BUF1;\r\ncommand[1] = (addr & 0x00FF0000) >> 16;\r\ncommand[2] = (addr & 0x0000FF00) >> 8;\r\ncommand[3] = (addr & 0x000000FF);\r\npr_debug("PROGRAM: (%x) %x %x %x\n",\r\ncommand[0], command[1], command[2], command[3]);\r\nx[1].tx_buf = writebuf;\r\nx[1].len = writelen;\r\nspi_message_add_tail(x + 1, &msg);\r\nstatus = spi_sync(spi, &msg);\r\nspi_transfer_del(x + 1);\r\nif (status < 0)\r\npr_debug("%s: pgm %u/%u -> %d\n",\r\ndev_name(&spi->dev), addr, writelen, status);\r\n(void) dataflash_waitready(priv->spi);\r\n#ifdef CONFIG_MTD_DATAFLASH_WRITE_VERIFY\r\naddr = pageaddr << priv->page_offset;\r\ncommand[0] = OP_COMPARE_BUF1;\r\ncommand[1] = (addr & 0x00FF0000) >> 16;\r\ncommand[2] = (addr & 0x0000FF00) >> 8;\r\ncommand[3] = 0;\r\npr_debug("COMPARE: (%x) %x %x %x\n",\r\ncommand[0], command[1], command[2], command[3]);\r\nstatus = spi_sync(spi, &msg);\r\nif (status < 0)\r\npr_debug("%s: compare %u -> %d\n",\r\ndev_name(&spi->dev), addr, status);\r\nstatus = dataflash_waitready(priv->spi);\r\nif (status & (1 << 6)) {\r\nprintk(KERN_ERR "%s: compare page %u, err %d\n",\r\ndev_name(&spi->dev), pageaddr, status);\r\nremaining = 0;\r\nstatus = -EIO;\r\nbreak;\r\n} else\r\nstatus = 0;\r\n#endif\r\nremaining = remaining - writelen;\r\npageaddr++;\r\noffset = 0;\r\nwritebuf += writelen;\r\n*retlen += writelen;\r\nif (remaining > priv->page_size)\r\nwritelen = priv->page_size;\r\nelse\r\nwritelen = remaining;\r\n}\r\nmutex_unlock(&priv->lock);\r\nreturn status;\r\n}\r\nstatic int dataflash_get_otp_info(struct mtd_info *mtd, size_t len,\r\nsize_t *retlen, struct otp_info *info)\r\n{\r\ninfo->start = 0;\r\ninfo->length = 64;\r\ninfo->locked = 1;\r\n*retlen = sizeof(*info);\r\nreturn 0;\r\n}\r\nstatic ssize_t otp_read(struct spi_device *spi, unsigned base,\r\nuint8_t *buf, loff_t off, size_t len)\r\n{\r\nstruct spi_message m;\r\nsize_t l;\r\nuint8_t *scratch;\r\nstruct spi_transfer t;\r\nint status;\r\nif (off > 64)\r\nreturn -EINVAL;\r\nif ((off + len) > 64)\r\nlen = 64 - off;\r\nspi_message_init(&m);\r\nl = 4 + base + off + len;\r\nscratch = kzalloc(l, GFP_KERNEL);\r\nif (!scratch)\r\nreturn -ENOMEM;\r\nscratch[0] = OP_READ_SECURITY;\r\nmemset(&t, 0, sizeof t);\r\nt.tx_buf = scratch;\r\nt.rx_buf = scratch;\r\nt.len = l;\r\nspi_message_add_tail(&t, &m);\r\ndataflash_waitready(spi);\r\nstatus = spi_sync(spi, &m);\r\nif (status >= 0) {\r\nmemcpy(buf, scratch + 4 + base + off, len);\r\nstatus = len;\r\n}\r\nkfree(scratch);\r\nreturn status;\r\n}\r\nstatic int dataflash_read_fact_otp(struct mtd_info *mtd,\r\nloff_t from, size_t len, size_t *retlen, u_char *buf)\r\n{\r\nstruct dataflash *priv = mtd->priv;\r\nint status;\r\nmutex_lock(&priv->lock);\r\nstatus = otp_read(priv->spi, 64, buf, from, len);\r\nmutex_unlock(&priv->lock);\r\nif (status < 0)\r\nreturn status;\r\n*retlen = status;\r\nreturn 0;\r\n}\r\nstatic int dataflash_read_user_otp(struct mtd_info *mtd,\r\nloff_t from, size_t len, size_t *retlen, u_char *buf)\r\n{\r\nstruct dataflash *priv = mtd->priv;\r\nint status;\r\nmutex_lock(&priv->lock);\r\nstatus = otp_read(priv->spi, 0, buf, from, len);\r\nmutex_unlock(&priv->lock);\r\nif (status < 0)\r\nreturn status;\r\n*retlen = status;\r\nreturn 0;\r\n}\r\nstatic int dataflash_write_user_otp(struct mtd_info *mtd,\r\nloff_t from, size_t len, size_t *retlen, u_char *buf)\r\n{\r\nstruct spi_message m;\r\nconst size_t l = 4 + 64;\r\nuint8_t *scratch;\r\nstruct spi_transfer t;\r\nstruct dataflash *priv = mtd->priv;\r\nint status;\r\nif (from >= 64) {\r\n*retlen = 0;\r\nreturn 0;\r\n}\r\nif ((from + len) > 64)\r\nlen = 64 - from;\r\nscratch = kzalloc(l, GFP_KERNEL);\r\nif (!scratch)\r\nreturn -ENOMEM;\r\nscratch[0] = OP_WRITE_SECURITY;\r\nmemcpy(scratch + 4 + from, buf, len);\r\nspi_message_init(&m);\r\nmemset(&t, 0, sizeof t);\r\nt.tx_buf = scratch;\r\nt.len = l;\r\nspi_message_add_tail(&t, &m);\r\nmutex_lock(&priv->lock);\r\ndataflash_waitready(priv->spi);\r\nstatus = spi_sync(priv->spi, &m);\r\nmutex_unlock(&priv->lock);\r\nkfree(scratch);\r\nif (status >= 0) {\r\nstatus = 0;\r\n*retlen = len;\r\n}\r\nreturn status;\r\n}\r\nstatic char *otp_setup(struct mtd_info *device, char revision)\r\n{\r\ndevice->_get_fact_prot_info = dataflash_get_otp_info;\r\ndevice->_read_fact_prot_reg = dataflash_read_fact_otp;\r\ndevice->_get_user_prot_info = dataflash_get_otp_info;\r\ndevice->_read_user_prot_reg = dataflash_read_user_otp;\r\nif (revision > 'c')\r\ndevice->_write_user_prot_reg = dataflash_write_user_otp;\r\nreturn ", OTP";\r\n}\r\nstatic char *otp_setup(struct mtd_info *device, char revision)\r\n{\r\nreturn " (OTP)";\r\n}\r\nstatic int add_dataflash_otp(struct spi_device *spi, char *name, int nr_pages,\r\nint pagesize, int pageoffset, char revision)\r\n{\r\nstruct dataflash *priv;\r\nstruct mtd_info *device;\r\nstruct mtd_part_parser_data ppdata;\r\nstruct flash_platform_data *pdata = dev_get_platdata(&spi->dev);\r\nchar *otp_tag = "";\r\nint err = 0;\r\npriv = kzalloc(sizeof *priv, GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nmutex_init(&priv->lock);\r\npriv->spi = spi;\r\npriv->page_size = pagesize;\r\npriv->page_offset = pageoffset;\r\nsprintf(priv->name, "spi%d.%d-%s",\r\nspi->master->bus_num, spi->chip_select,\r\nname);\r\ndevice = &priv->mtd;\r\ndevice->name = (pdata && pdata->name) ? pdata->name : priv->name;\r\ndevice->size = nr_pages * pagesize;\r\ndevice->erasesize = pagesize;\r\ndevice->writesize = pagesize;\r\ndevice->owner = THIS_MODULE;\r\ndevice->type = MTD_DATAFLASH;\r\ndevice->flags = MTD_WRITEABLE;\r\ndevice->_erase = dataflash_erase;\r\ndevice->_read = dataflash_read;\r\ndevice->_write = dataflash_write;\r\ndevice->priv = priv;\r\ndevice->dev.parent = &spi->dev;\r\nif (revision >= 'c')\r\notp_tag = otp_setup(device, revision);\r\ndev_info(&spi->dev, "%s (%lld KBytes) pagesize %d bytes%s\n",\r\nname, (long long)((device->size + 1023) >> 10),\r\npagesize, otp_tag);\r\nspi_set_drvdata(spi, priv);\r\nppdata.of_node = spi->dev.of_node;\r\nerr = mtd_device_parse_register(device, NULL, &ppdata,\r\npdata ? pdata->parts : NULL,\r\npdata ? pdata->nr_parts : 0);\r\nif (!err)\r\nreturn 0;\r\nkfree(priv);\r\nreturn err;\r\n}\r\nstatic inline int add_dataflash(struct spi_device *spi, char *name,\r\nint nr_pages, int pagesize, int pageoffset)\r\n{\r\nreturn add_dataflash_otp(spi, name, nr_pages, pagesize,\r\npageoffset, 0);\r\n}\r\nstatic struct flash_info *jedec_probe(struct spi_device *spi)\r\n{\r\nint tmp;\r\nuint8_t code = OP_READ_ID;\r\nuint8_t id[3];\r\nuint32_t jedec;\r\nstruct flash_info *info;\r\nint status;\r\ntmp = spi_write_then_read(spi, &code, 1, id, 3);\r\nif (tmp < 0) {\r\npr_debug("%s: error %d reading JEDEC ID\n",\r\ndev_name(&spi->dev), tmp);\r\nreturn ERR_PTR(tmp);\r\n}\r\nif (id[0] != 0x1f)\r\nreturn NULL;\r\njedec = id[0];\r\njedec = jedec << 8;\r\njedec |= id[1];\r\njedec = jedec << 8;\r\njedec |= id[2];\r\nfor (tmp = 0, info = dataflash_data;\r\ntmp < ARRAY_SIZE(dataflash_data);\r\ntmp++, info++) {\r\nif (info->jedec_id == jedec) {\r\npr_debug("%s: OTP, sector protect%s\n",\r\ndev_name(&spi->dev),\r\n(info->flags & SUP_POW2PS)\r\n? ", binary pagesize" : ""\r\n);\r\nif (info->flags & SUP_POW2PS) {\r\nstatus = dataflash_status(spi);\r\nif (status < 0) {\r\npr_debug("%s: status error %d\n",\r\ndev_name(&spi->dev), status);\r\nreturn ERR_PTR(status);\r\n}\r\nif (status & 0x1) {\r\nif (info->flags & IS_POW2PS)\r\nreturn info;\r\n} else {\r\nif (!(info->flags & IS_POW2PS))\r\nreturn info;\r\n}\r\n} else\r\nreturn info;\r\n}\r\n}\r\ndev_warn(&spi->dev, "JEDEC id %06x not handled\n", jedec);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic int dataflash_probe(struct spi_device *spi)\r\n{\r\nint status;\r\nstruct flash_info *info;\r\ninfo = jedec_probe(spi);\r\nif (IS_ERR(info))\r\nreturn PTR_ERR(info);\r\nif (info != NULL)\r\nreturn add_dataflash_otp(spi, info->name, info->nr_pages,\r\ninfo->pagesize, info->pageoffset,\r\n(info->flags & SUP_POW2PS) ? 'd' : 'c');\r\nstatus = dataflash_status(spi);\r\nif (status <= 0 || status == 0xff) {\r\npr_debug("%s: status error %d\n",\r\ndev_name(&spi->dev), status);\r\nif (status == 0 || status == 0xff)\r\nstatus = -ENODEV;\r\nreturn status;\r\n}\r\nswitch (status & 0x3c) {\r\ncase 0x0c:\r\nstatus = add_dataflash(spi, "AT45DB011B", 512, 264, 9);\r\nbreak;\r\ncase 0x14:\r\nstatus = add_dataflash(spi, "AT45DB021B", 1024, 264, 9);\r\nbreak;\r\ncase 0x1c:\r\nstatus = add_dataflash(spi, "AT45DB041x", 2048, 264, 9);\r\nbreak;\r\ncase 0x24:\r\nstatus = add_dataflash(spi, "AT45DB081B", 4096, 264, 9);\r\nbreak;\r\ncase 0x2c:\r\nstatus = add_dataflash(spi, "AT45DB161x", 4096, 528, 10);\r\nbreak;\r\ncase 0x34:\r\nstatus = add_dataflash(spi, "AT45DB321x", 8192, 528, 10);\r\nbreak;\r\ncase 0x38:\r\ncase 0x3c:\r\nstatus = add_dataflash(spi, "AT45DB642x", 8192, 1056, 11);\r\nbreak;\r\ndefault:\r\ndev_info(&spi->dev, "unsupported device (%x)\n",\r\nstatus & 0x3c);\r\nstatus = -ENODEV;\r\n}\r\nif (status < 0)\r\npr_debug("%s: add_dataflash --> %d\n", dev_name(&spi->dev),\r\nstatus);\r\nreturn status;\r\n}\r\nstatic int dataflash_remove(struct spi_device *spi)\r\n{\r\nstruct dataflash *flash = spi_get_drvdata(spi);\r\nint status;\r\npr_debug("%s: remove\n", dev_name(&spi->dev));\r\nstatus = mtd_device_unregister(&flash->mtd);\r\nif (status == 0)\r\nkfree(flash);\r\nreturn status;\r\n}
