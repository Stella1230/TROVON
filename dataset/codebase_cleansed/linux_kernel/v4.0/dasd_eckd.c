static int\r\ndasd_eckd_probe (struct ccw_device *cdev)\r\n{\r\nint ret;\r\nret = ccw_device_set_options(cdev, CCWDEV_ALLOW_FORCE |\r\nCCWDEV_DO_PATHGROUP | CCWDEV_DO_MULTIPATH);\r\nif (ret) {\r\nDBF_EVENT_DEVID(DBF_WARNING, cdev, "%s",\r\n"dasd_eckd_probe: could not set "\r\n"ccw-device options");\r\nreturn ret;\r\n}\r\nret = dasd_generic_probe(cdev, &dasd_eckd_discipline);\r\nreturn ret;\r\n}\r\nstatic int\r\ndasd_eckd_set_online(struct ccw_device *cdev)\r\n{\r\nreturn dasd_generic_set_online(cdev, &dasd_eckd_discipline);\r\n}\r\nstatic inline unsigned int\r\nround_up_multiple(unsigned int no, unsigned int mult)\r\n{\r\nint rem = no % mult;\r\nreturn (rem ? no - rem + mult : no);\r\n}\r\nstatic inline unsigned int\r\nceil_quot(unsigned int d1, unsigned int d2)\r\n{\r\nreturn (d1 + (d2 - 1)) / d2;\r\n}\r\nstatic unsigned int\r\nrecs_per_track(struct dasd_eckd_characteristics * rdc,\r\nunsigned int kl, unsigned int dl)\r\n{\r\nint dn, kn;\r\nswitch (rdc->dev_type) {\r\ncase 0x3380:\r\nif (kl)\r\nreturn 1499 / (15 + 7 + ceil_quot(kl + 12, 32) +\r\nceil_quot(dl + 12, 32));\r\nelse\r\nreturn 1499 / (15 + ceil_quot(dl + 12, 32));\r\ncase 0x3390:\r\ndn = ceil_quot(dl + 6, 232) + 1;\r\nif (kl) {\r\nkn = ceil_quot(kl + 6, 232) + 1;\r\nreturn 1729 / (10 + 9 + ceil_quot(kl + 6 * kn, 34) +\r\n9 + ceil_quot(dl + 6 * dn, 34));\r\n} else\r\nreturn 1729 / (10 + 9 + ceil_quot(dl + 6 * dn, 34));\r\ncase 0x9345:\r\ndn = ceil_quot(dl + 6, 232) + 1;\r\nif (kl) {\r\nkn = ceil_quot(kl + 6, 232) + 1;\r\nreturn 1420 / (18 + 7 + ceil_quot(kl + 6 * kn, 34) +\r\nceil_quot(dl + 6 * dn, 34));\r\n} else\r\nreturn 1420 / (18 + 7 + ceil_quot(dl + 6 * dn, 34));\r\n}\r\nreturn 0;\r\n}\r\nstatic void set_ch_t(struct ch_t *geo, __u32 cyl, __u8 head)\r\n{\r\ngeo->cyl = (__u16) cyl;\r\ngeo->head = cyl >> 16;\r\ngeo->head <<= 4;\r\ngeo->head |= head;\r\n}\r\nstatic int\r\ncheck_XRC (struct ccw1 *de_ccw,\r\nstruct DE_eckd_data *data,\r\nstruct dasd_device *device)\r\n{\r\nstruct dasd_eckd_private *private;\r\nint rc;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\nif (!private->rdc_data.facilities.XRC_supported)\r\nreturn 0;\r\ndata->ga_extended |= 0x08;\r\ndata->ga_extended |= 0x02;\r\nrc = get_sync_clock(&data->ep_sys_time);\r\nif (rc == -EOPNOTSUPP || rc == -EACCES)\r\nrc = 0;\r\nde_ccw->count = sizeof(struct DE_eckd_data);\r\nde_ccw->flags |= CCW_FLAG_SLI;\r\nreturn rc;\r\n}\r\nstatic int\r\ndefine_extent(struct ccw1 *ccw, struct DE_eckd_data *data, unsigned int trk,\r\nunsigned int totrk, int cmd, struct dasd_device *device)\r\n{\r\nstruct dasd_eckd_private *private;\r\nu32 begcyl, endcyl;\r\nu16 heads, beghead, endhead;\r\nint rc = 0;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\nccw->cmd_code = DASD_ECKD_CCW_DEFINE_EXTENT;\r\nccw->flags = 0;\r\nccw->count = 16;\r\nccw->cda = (__u32) __pa(data);\r\nmemset(data, 0, sizeof(struct DE_eckd_data));\r\nswitch (cmd) {\r\ncase DASD_ECKD_CCW_READ_HOME_ADDRESS:\r\ncase DASD_ECKD_CCW_READ_RECORD_ZERO:\r\ncase DASD_ECKD_CCW_READ:\r\ncase DASD_ECKD_CCW_READ_MT:\r\ncase DASD_ECKD_CCW_READ_CKD:\r\ncase DASD_ECKD_CCW_READ_CKD_MT:\r\ncase DASD_ECKD_CCW_READ_KD:\r\ncase DASD_ECKD_CCW_READ_KD_MT:\r\ncase DASD_ECKD_CCW_READ_COUNT:\r\ndata->mask.perm = 0x1;\r\ndata->attributes.operation = private->attrib.operation;\r\nbreak;\r\ncase DASD_ECKD_CCW_WRITE:\r\ncase DASD_ECKD_CCW_WRITE_MT:\r\ncase DASD_ECKD_CCW_WRITE_KD:\r\ncase DASD_ECKD_CCW_WRITE_KD_MT:\r\ndata->mask.perm = 0x02;\r\ndata->attributes.operation = private->attrib.operation;\r\nrc = check_XRC (ccw, data, device);\r\nbreak;\r\ncase DASD_ECKD_CCW_WRITE_CKD:\r\ncase DASD_ECKD_CCW_WRITE_CKD_MT:\r\ndata->attributes.operation = DASD_BYPASS_CACHE;\r\nrc = check_XRC (ccw, data, device);\r\nbreak;\r\ncase DASD_ECKD_CCW_ERASE:\r\ncase DASD_ECKD_CCW_WRITE_HOME_ADDRESS:\r\ncase DASD_ECKD_CCW_WRITE_RECORD_ZERO:\r\ndata->mask.perm = 0x3;\r\ndata->mask.auth = 0x1;\r\ndata->attributes.operation = DASD_BYPASS_CACHE;\r\nrc = check_XRC (ccw, data, device);\r\nbreak;\r\ndefault:\r\ndev_err(&device->cdev->dev,\r\n"0x%x is not a known command\n", cmd);\r\nbreak;\r\n}\r\ndata->attributes.mode = 0x3;\r\nif ((private->rdc_data.cu_type == 0x2105 ||\r\nprivate->rdc_data.cu_type == 0x2107 ||\r\nprivate->rdc_data.cu_type == 0x1750)\r\n&& !(private->uses_cdl && trk < 2))\r\ndata->ga_extended |= 0x40;\r\nheads = private->rdc_data.trk_per_cyl;\r\nbegcyl = trk / heads;\r\nbeghead = trk % heads;\r\nendcyl = totrk / heads;\r\nendhead = totrk % heads;\r\nif (data->attributes.operation == DASD_SEQ_PRESTAGE ||\r\ndata->attributes.operation == DASD_SEQ_ACCESS) {\r\nif (endcyl + private->attrib.nr_cyl < private->real_cyl)\r\nendcyl += private->attrib.nr_cyl;\r\nelse\r\nendcyl = (private->real_cyl - 1);\r\n}\r\nset_ch_t(&data->beg_ext, begcyl, beghead);\r\nset_ch_t(&data->end_ext, endcyl, endhead);\r\nreturn rc;\r\n}\r\nstatic int check_XRC_on_prefix(struct PFX_eckd_data *pfxdata,\r\nstruct dasd_device *device)\r\n{\r\nstruct dasd_eckd_private *private;\r\nint rc;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\nif (!private->rdc_data.facilities.XRC_supported)\r\nreturn 0;\r\npfxdata->define_extent.ga_extended |= 0x08;\r\npfxdata->define_extent.ga_extended |= 0x02;\r\npfxdata->validity.time_stamp = 1;\r\nrc = get_sync_clock(&pfxdata->define_extent.ep_sys_time);\r\nif (rc == -EOPNOTSUPP || rc == -EACCES)\r\nrc = 0;\r\nreturn rc;\r\n}\r\nstatic void fill_LRE_data(struct LRE_eckd_data *data, unsigned int trk,\r\nunsigned int rec_on_trk, int count, int cmd,\r\nstruct dasd_device *device, unsigned int reclen,\r\nunsigned int tlf)\r\n{\r\nstruct dasd_eckd_private *private;\r\nint sector;\r\nint dn, d;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\nmemset(data, 0, sizeof(*data));\r\nsector = 0;\r\nif (rec_on_trk) {\r\nswitch (private->rdc_data.dev_type) {\r\ncase 0x3390:\r\ndn = ceil_quot(reclen + 6, 232);\r\nd = 9 + ceil_quot(reclen + 6 * (dn + 1), 34);\r\nsector = (49 + (rec_on_trk - 1) * (10 + d)) / 8;\r\nbreak;\r\ncase 0x3380:\r\nd = 7 + ceil_quot(reclen + 12, 32);\r\nsector = (39 + (rec_on_trk - 1) * (8 + d)) / 7;\r\nbreak;\r\n}\r\n}\r\ndata->sector = sector;\r\ndata->count = count;\r\nswitch (cmd) {\r\ncase DASD_ECKD_CCW_WRITE_HOME_ADDRESS:\r\ndata->operation.orientation = 0x3;\r\ndata->operation.operation = 0x03;\r\nbreak;\r\ncase DASD_ECKD_CCW_READ_HOME_ADDRESS:\r\ndata->operation.orientation = 0x3;\r\ndata->operation.operation = 0x16;\r\nbreak;\r\ncase DASD_ECKD_CCW_WRITE_RECORD_ZERO:\r\ndata->operation.orientation = 0x1;\r\ndata->operation.operation = 0x03;\r\ndata->count++;\r\nbreak;\r\ncase DASD_ECKD_CCW_READ_RECORD_ZERO:\r\ndata->operation.orientation = 0x3;\r\ndata->operation.operation = 0x16;\r\ndata->count++;\r\nbreak;\r\ncase DASD_ECKD_CCW_WRITE:\r\ncase DASD_ECKD_CCW_WRITE_MT:\r\ncase DASD_ECKD_CCW_WRITE_KD:\r\ncase DASD_ECKD_CCW_WRITE_KD_MT:\r\ndata->auxiliary.length_valid = 0x1;\r\ndata->length = reclen;\r\ndata->operation.operation = 0x01;\r\nbreak;\r\ncase DASD_ECKD_CCW_WRITE_CKD:\r\ncase DASD_ECKD_CCW_WRITE_CKD_MT:\r\ndata->auxiliary.length_valid = 0x1;\r\ndata->length = reclen;\r\ndata->operation.operation = 0x03;\r\nbreak;\r\ncase DASD_ECKD_CCW_WRITE_FULL_TRACK:\r\ndata->operation.orientation = 0x0;\r\ndata->operation.operation = 0x3F;\r\ndata->extended_operation = 0x11;\r\ndata->length = 0;\r\ndata->extended_parameter_length = 0x02;\r\nif (data->count > 8) {\r\ndata->extended_parameter[0] = 0xFF;\r\ndata->extended_parameter[1] = 0xFF;\r\ndata->extended_parameter[1] <<= (16 - count);\r\n} else {\r\ndata->extended_parameter[0] = 0xFF;\r\ndata->extended_parameter[0] <<= (8 - count);\r\ndata->extended_parameter[1] = 0x00;\r\n}\r\ndata->sector = 0xFF;\r\nbreak;\r\ncase DASD_ECKD_CCW_WRITE_TRACK_DATA:\r\ndata->auxiliary.length_valid = 0x1;\r\ndata->length = reclen;\r\ndata->operation.operation = 0x3F;\r\ndata->extended_operation = 0x23;\r\nbreak;\r\ncase DASD_ECKD_CCW_READ:\r\ncase DASD_ECKD_CCW_READ_MT:\r\ncase DASD_ECKD_CCW_READ_KD:\r\ncase DASD_ECKD_CCW_READ_KD_MT:\r\ndata->auxiliary.length_valid = 0x1;\r\ndata->length = reclen;\r\ndata->operation.operation = 0x06;\r\nbreak;\r\ncase DASD_ECKD_CCW_READ_CKD:\r\ncase DASD_ECKD_CCW_READ_CKD_MT:\r\ndata->auxiliary.length_valid = 0x1;\r\ndata->length = reclen;\r\ndata->operation.operation = 0x16;\r\nbreak;\r\ncase DASD_ECKD_CCW_READ_COUNT:\r\ndata->operation.operation = 0x06;\r\nbreak;\r\ncase DASD_ECKD_CCW_READ_TRACK:\r\ndata->operation.orientation = 0x1;\r\ndata->operation.operation = 0x0C;\r\ndata->extended_parameter_length = 0;\r\ndata->sector = 0xFF;\r\nbreak;\r\ncase DASD_ECKD_CCW_READ_TRACK_DATA:\r\ndata->auxiliary.length_valid = 0x1;\r\ndata->length = tlf;\r\ndata->operation.operation = 0x0C;\r\nbreak;\r\ncase DASD_ECKD_CCW_ERASE:\r\ndata->length = reclen;\r\ndata->auxiliary.length_valid = 0x1;\r\ndata->operation.operation = 0x0b;\r\nbreak;\r\ndefault:\r\nDBF_DEV_EVENT(DBF_ERR, device,\r\n"fill LRE unknown opcode 0x%x", cmd);\r\nBUG();\r\n}\r\nset_ch_t(&data->seek_addr,\r\ntrk / private->rdc_data.trk_per_cyl,\r\ntrk % private->rdc_data.trk_per_cyl);\r\ndata->search_arg.cyl = data->seek_addr.cyl;\r\ndata->search_arg.head = data->seek_addr.head;\r\ndata->search_arg.record = rec_on_trk;\r\n}\r\nstatic int prefix_LRE(struct ccw1 *ccw, struct PFX_eckd_data *pfxdata,\r\nunsigned int trk, unsigned int totrk, int cmd,\r\nstruct dasd_device *basedev, struct dasd_device *startdev,\r\nunsigned char format, unsigned int rec_on_trk, int count,\r\nunsigned int blksize, unsigned int tlf)\r\n{\r\nstruct dasd_eckd_private *basepriv, *startpriv;\r\nstruct DE_eckd_data *dedata;\r\nstruct LRE_eckd_data *lredata;\r\nu32 begcyl, endcyl;\r\nu16 heads, beghead, endhead;\r\nint rc = 0;\r\nbasepriv = (struct dasd_eckd_private *) basedev->private;\r\nstartpriv = (struct dasd_eckd_private *) startdev->private;\r\ndedata = &pfxdata->define_extent;\r\nlredata = &pfxdata->locate_record;\r\nccw->cmd_code = DASD_ECKD_CCW_PFX;\r\nccw->flags = 0;\r\nif (cmd == DASD_ECKD_CCW_WRITE_FULL_TRACK) {\r\nccw->count = sizeof(*pfxdata) + 2;\r\nccw->cda = (__u32) __pa(pfxdata);\r\nmemset(pfxdata, 0, sizeof(*pfxdata) + 2);\r\n} else {\r\nccw->count = sizeof(*pfxdata);\r\nccw->cda = (__u32) __pa(pfxdata);\r\nmemset(pfxdata, 0, sizeof(*pfxdata));\r\n}\r\nif (format > 1) {\r\nDBF_DEV_EVENT(DBF_ERR, basedev,\r\n"PFX LRE unknown format 0x%x", format);\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\npfxdata->format = format;\r\npfxdata->base_address = basepriv->ned->unit_addr;\r\npfxdata->base_lss = basepriv->ned->ID;\r\npfxdata->validity.define_extent = 1;\r\nif (startpriv->uid.type != UA_BASE_DEVICE) {\r\npfxdata->validity.verify_base = 1;\r\nif (startpriv->uid.type == UA_HYPER_PAV_ALIAS)\r\npfxdata->validity.hyper_pav = 1;\r\n}\r\nswitch (cmd) {\r\ncase DASD_ECKD_CCW_READ_HOME_ADDRESS:\r\ncase DASD_ECKD_CCW_READ_RECORD_ZERO:\r\ncase DASD_ECKD_CCW_READ:\r\ncase DASD_ECKD_CCW_READ_MT:\r\ncase DASD_ECKD_CCW_READ_CKD:\r\ncase DASD_ECKD_CCW_READ_CKD_MT:\r\ncase DASD_ECKD_CCW_READ_KD:\r\ncase DASD_ECKD_CCW_READ_KD_MT:\r\ncase DASD_ECKD_CCW_READ_COUNT:\r\ndedata->mask.perm = 0x1;\r\ndedata->attributes.operation = basepriv->attrib.operation;\r\nbreak;\r\ncase DASD_ECKD_CCW_READ_TRACK:\r\ncase DASD_ECKD_CCW_READ_TRACK_DATA:\r\ndedata->mask.perm = 0x1;\r\ndedata->attributes.operation = basepriv->attrib.operation;\r\ndedata->blk_size = 0;\r\nbreak;\r\ncase DASD_ECKD_CCW_WRITE:\r\ncase DASD_ECKD_CCW_WRITE_MT:\r\ncase DASD_ECKD_CCW_WRITE_KD:\r\ncase DASD_ECKD_CCW_WRITE_KD_MT:\r\ndedata->mask.perm = 0x02;\r\ndedata->attributes.operation = basepriv->attrib.operation;\r\nrc = check_XRC_on_prefix(pfxdata, basedev);\r\nbreak;\r\ncase DASD_ECKD_CCW_WRITE_CKD:\r\ncase DASD_ECKD_CCW_WRITE_CKD_MT:\r\ndedata->attributes.operation = DASD_BYPASS_CACHE;\r\nrc = check_XRC_on_prefix(pfxdata, basedev);\r\nbreak;\r\ncase DASD_ECKD_CCW_ERASE:\r\ncase DASD_ECKD_CCW_WRITE_HOME_ADDRESS:\r\ncase DASD_ECKD_CCW_WRITE_RECORD_ZERO:\r\ndedata->mask.perm = 0x3;\r\ndedata->mask.auth = 0x1;\r\ndedata->attributes.operation = DASD_BYPASS_CACHE;\r\nrc = check_XRC_on_prefix(pfxdata, basedev);\r\nbreak;\r\ncase DASD_ECKD_CCW_WRITE_FULL_TRACK:\r\ndedata->mask.perm = 0x03;\r\ndedata->attributes.operation = basepriv->attrib.operation;\r\ndedata->blk_size = 0;\r\nbreak;\r\ncase DASD_ECKD_CCW_WRITE_TRACK_DATA:\r\ndedata->mask.perm = 0x02;\r\ndedata->attributes.operation = basepriv->attrib.operation;\r\ndedata->blk_size = blksize;\r\nrc = check_XRC_on_prefix(pfxdata, basedev);\r\nbreak;\r\ndefault:\r\nDBF_DEV_EVENT(DBF_ERR, basedev,\r\n"PFX LRE unknown opcode 0x%x", cmd);\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\ndedata->attributes.mode = 0x3;\r\nif ((basepriv->rdc_data.cu_type == 0x2105 ||\r\nbasepriv->rdc_data.cu_type == 0x2107 ||\r\nbasepriv->rdc_data.cu_type == 0x1750)\r\n&& !(basepriv->uses_cdl && trk < 2))\r\ndedata->ga_extended |= 0x40;\r\nheads = basepriv->rdc_data.trk_per_cyl;\r\nbegcyl = trk / heads;\r\nbeghead = trk % heads;\r\nendcyl = totrk / heads;\r\nendhead = totrk % heads;\r\nif (dedata->attributes.operation == DASD_SEQ_PRESTAGE ||\r\ndedata->attributes.operation == DASD_SEQ_ACCESS) {\r\nif (endcyl + basepriv->attrib.nr_cyl < basepriv->real_cyl)\r\nendcyl += basepriv->attrib.nr_cyl;\r\nelse\r\nendcyl = (basepriv->real_cyl - 1);\r\n}\r\nset_ch_t(&dedata->beg_ext, begcyl, beghead);\r\nset_ch_t(&dedata->end_ext, endcyl, endhead);\r\nif (format == 1) {\r\nfill_LRE_data(lredata, trk, rec_on_trk, count, cmd,\r\nbasedev, blksize, tlf);\r\n}\r\nreturn rc;\r\n}\r\nstatic int prefix(struct ccw1 *ccw, struct PFX_eckd_data *pfxdata,\r\nunsigned int trk, unsigned int totrk, int cmd,\r\nstruct dasd_device *basedev, struct dasd_device *startdev)\r\n{\r\nreturn prefix_LRE(ccw, pfxdata, trk, totrk, cmd, basedev, startdev,\r\n0, 0, 0, 0, 0);\r\n}\r\nstatic void\r\nlocate_record(struct ccw1 *ccw, struct LO_eckd_data *data, unsigned int trk,\r\nunsigned int rec_on_trk, int no_rec, int cmd,\r\nstruct dasd_device * device, int reclen)\r\n{\r\nstruct dasd_eckd_private *private;\r\nint sector;\r\nint dn, d;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\nDBF_DEV_EVENT(DBF_INFO, device,\r\n"Locate: trk %d, rec %d, no_rec %d, cmd %d, reclen %d",\r\ntrk, rec_on_trk, no_rec, cmd, reclen);\r\nccw->cmd_code = DASD_ECKD_CCW_LOCATE_RECORD;\r\nccw->flags = 0;\r\nccw->count = 16;\r\nccw->cda = (__u32) __pa(data);\r\nmemset(data, 0, sizeof(struct LO_eckd_data));\r\nsector = 0;\r\nif (rec_on_trk) {\r\nswitch (private->rdc_data.dev_type) {\r\ncase 0x3390:\r\ndn = ceil_quot(reclen + 6, 232);\r\nd = 9 + ceil_quot(reclen + 6 * (dn + 1), 34);\r\nsector = (49 + (rec_on_trk - 1) * (10 + d)) / 8;\r\nbreak;\r\ncase 0x3380:\r\nd = 7 + ceil_quot(reclen + 12, 32);\r\nsector = (39 + (rec_on_trk - 1) * (8 + d)) / 7;\r\nbreak;\r\n}\r\n}\r\ndata->sector = sector;\r\ndata->count = no_rec;\r\nswitch (cmd) {\r\ncase DASD_ECKD_CCW_WRITE_HOME_ADDRESS:\r\ndata->operation.orientation = 0x3;\r\ndata->operation.operation = 0x03;\r\nbreak;\r\ncase DASD_ECKD_CCW_READ_HOME_ADDRESS:\r\ndata->operation.orientation = 0x3;\r\ndata->operation.operation = 0x16;\r\nbreak;\r\ncase DASD_ECKD_CCW_WRITE_RECORD_ZERO:\r\ndata->operation.orientation = 0x1;\r\ndata->operation.operation = 0x03;\r\ndata->count++;\r\nbreak;\r\ncase DASD_ECKD_CCW_READ_RECORD_ZERO:\r\ndata->operation.orientation = 0x3;\r\ndata->operation.operation = 0x16;\r\ndata->count++;\r\nbreak;\r\ncase DASD_ECKD_CCW_WRITE:\r\ncase DASD_ECKD_CCW_WRITE_MT:\r\ncase DASD_ECKD_CCW_WRITE_KD:\r\ncase DASD_ECKD_CCW_WRITE_KD_MT:\r\ndata->auxiliary.last_bytes_used = 0x1;\r\ndata->length = reclen;\r\ndata->operation.operation = 0x01;\r\nbreak;\r\ncase DASD_ECKD_CCW_WRITE_CKD:\r\ncase DASD_ECKD_CCW_WRITE_CKD_MT:\r\ndata->auxiliary.last_bytes_used = 0x1;\r\ndata->length = reclen;\r\ndata->operation.operation = 0x03;\r\nbreak;\r\ncase DASD_ECKD_CCW_READ:\r\ncase DASD_ECKD_CCW_READ_MT:\r\ncase DASD_ECKD_CCW_READ_KD:\r\ncase DASD_ECKD_CCW_READ_KD_MT:\r\ndata->auxiliary.last_bytes_used = 0x1;\r\ndata->length = reclen;\r\ndata->operation.operation = 0x06;\r\nbreak;\r\ncase DASD_ECKD_CCW_READ_CKD:\r\ncase DASD_ECKD_CCW_READ_CKD_MT:\r\ndata->auxiliary.last_bytes_used = 0x1;\r\ndata->length = reclen;\r\ndata->operation.operation = 0x16;\r\nbreak;\r\ncase DASD_ECKD_CCW_READ_COUNT:\r\ndata->operation.operation = 0x06;\r\nbreak;\r\ncase DASD_ECKD_CCW_ERASE:\r\ndata->length = reclen;\r\ndata->auxiliary.last_bytes_used = 0x1;\r\ndata->operation.operation = 0x0b;\r\nbreak;\r\ndefault:\r\nDBF_DEV_EVENT(DBF_ERR, device, "unknown locate record "\r\n"opcode 0x%x", cmd);\r\n}\r\nset_ch_t(&data->seek_addr,\r\ntrk / private->rdc_data.trk_per_cyl,\r\ntrk % private->rdc_data.trk_per_cyl);\r\ndata->search_arg.cyl = data->seek_addr.cyl;\r\ndata->search_arg.head = data->seek_addr.head;\r\ndata->search_arg.record = rec_on_trk;\r\n}\r\nstatic inline int\r\ndasd_eckd_cdl_special(int blk_per_trk, int recid)\r\n{\r\nif (recid < 3)\r\nreturn 1;\r\nif (recid < blk_per_trk)\r\nreturn 0;\r\nif (recid < 2 * blk_per_trk)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline int\r\ndasd_eckd_cdl_reclen(int recid)\r\n{\r\nif (recid < 3)\r\nreturn sizes_trk0[recid];\r\nreturn LABEL_SIZE;\r\n}\r\nstatic void create_uid(struct dasd_eckd_private *private)\r\n{\r\nint count;\r\nstruct dasd_uid *uid;\r\nuid = &private->uid;\r\nmemset(uid, 0, sizeof(struct dasd_uid));\r\nmemcpy(uid->vendor, private->ned->HDA_manufacturer,\r\nsizeof(uid->vendor) - 1);\r\nEBCASC(uid->vendor, sizeof(uid->vendor) - 1);\r\nmemcpy(uid->serial, private->ned->HDA_location,\r\nsizeof(uid->serial) - 1);\r\nEBCASC(uid->serial, sizeof(uid->serial) - 1);\r\nuid->ssid = private->gneq->subsystemID;\r\nuid->real_unit_addr = private->ned->unit_addr;\r\nif (private->sneq) {\r\nuid->type = private->sneq->sua_flags;\r\nif (uid->type == UA_BASE_PAV_ALIAS)\r\nuid->base_unit_addr = private->sneq->base_unit_addr;\r\n} else {\r\nuid->type = UA_BASE_DEVICE;\r\n}\r\nif (private->vdsneq) {\r\nfor (count = 0; count < 16; count++) {\r\nsprintf(uid->vduit+2*count, "%02x",\r\nprivate->vdsneq->uit[count]);\r\n}\r\n}\r\n}\r\nstatic int dasd_eckd_generate_uid(struct dasd_device *device)\r\n{\r\nstruct dasd_eckd_private *private;\r\nunsigned long flags;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\nif (!private)\r\nreturn -ENODEV;\r\nif (!private->ned || !private->gneq)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\ncreate_uid(private);\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\nreturn 0;\r\n}\r\nstatic int dasd_eckd_get_uid(struct dasd_device *device, struct dasd_uid *uid)\r\n{\r\nstruct dasd_eckd_private *private;\r\nunsigned long flags;\r\nif (device->private) {\r\nprivate = (struct dasd_eckd_private *)device->private;\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\n*uid = private->uid;\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int dasd_eckd_compare_path_uid(struct dasd_device *device,\r\nstruct dasd_eckd_private *private)\r\n{\r\nstruct dasd_uid device_uid;\r\ncreate_uid(private);\r\ndasd_eckd_get_uid(device, &device_uid);\r\nreturn memcmp(&device_uid, &private->uid, sizeof(struct dasd_uid));\r\n}\r\nstatic void dasd_eckd_fill_rcd_cqr(struct dasd_device *device,\r\nstruct dasd_ccw_req *cqr,\r\n__u8 *rcd_buffer,\r\n__u8 lpm)\r\n{\r\nstruct ccw1 *ccw;\r\nrcd_buffer[0] = 0xE5;\r\nrcd_buffer[1] = 0xF1;\r\nrcd_buffer[2] = 0x4B;\r\nrcd_buffer[3] = 0xF0;\r\nccw = cqr->cpaddr;\r\nccw->cmd_code = DASD_ECKD_CCW_RCD;\r\nccw->flags = 0;\r\nccw->cda = (__u32)(addr_t)rcd_buffer;\r\nccw->count = DASD_ECKD_RCD_DATA_SIZE;\r\ncqr->magic = DASD_ECKD_MAGIC;\r\ncqr->startdev = device;\r\ncqr->memdev = device;\r\ncqr->block = NULL;\r\ncqr->expires = 10*HZ;\r\ncqr->lpm = lpm;\r\ncqr->retries = 256;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nset_bit(DASD_CQR_VERIFY_PATH, &cqr->flags);\r\n}\r\nstatic void read_conf_cb(struct dasd_ccw_req *cqr, void *data)\r\n{\r\nstruct ccw1 *ccw;\r\n__u8 *rcd_buffer;\r\nif (cqr->status != DASD_CQR_DONE) {\r\nccw = cqr->cpaddr;\r\nrcd_buffer = (__u8 *)((addr_t) ccw->cda);\r\nmemset(rcd_buffer, 0, sizeof(*rcd_buffer));\r\nrcd_buffer[0] = 0xE5;\r\nrcd_buffer[1] = 0xF1;\r\nrcd_buffer[2] = 0x4B;\r\nrcd_buffer[3] = 0xF0;\r\n}\r\ndasd_wakeup_cb(cqr, data);\r\n}\r\nstatic int dasd_eckd_read_conf_immediately(struct dasd_device *device,\r\nstruct dasd_ccw_req *cqr,\r\n__u8 *rcd_buffer,\r\n__u8 lpm)\r\n{\r\nstruct ciw *ciw;\r\nint rc;\r\nciw = ccw_device_get_ciw(device->cdev, CIW_TYPE_RCD);\r\nif (!ciw || ciw->cmd != DASD_ECKD_CCW_RCD)\r\nreturn -EOPNOTSUPP;\r\ndasd_eckd_fill_rcd_cqr(device, cqr, rcd_buffer, lpm);\r\nclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\r\nset_bit(DASD_CQR_ALLOW_SLOCK, &cqr->flags);\r\ncqr->retries = 5;\r\ncqr->callback = read_conf_cb;\r\nrc = dasd_sleep_on_immediatly(cqr);\r\nreturn rc;\r\n}\r\nstatic int dasd_eckd_read_conf_lpm(struct dasd_device *device,\r\nvoid **rcd_buffer,\r\nint *rcd_buffer_size, __u8 lpm)\r\n{\r\nstruct ciw *ciw;\r\nchar *rcd_buf = NULL;\r\nint ret;\r\nstruct dasd_ccw_req *cqr;\r\nciw = ccw_device_get_ciw(device->cdev, CIW_TYPE_RCD);\r\nif (!ciw || ciw->cmd != DASD_ECKD_CCW_RCD) {\r\nret = -EOPNOTSUPP;\r\ngoto out_error;\r\n}\r\nrcd_buf = kzalloc(DASD_ECKD_RCD_DATA_SIZE, GFP_KERNEL | GFP_DMA);\r\nif (!rcd_buf) {\r\nret = -ENOMEM;\r\ngoto out_error;\r\n}\r\ncqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1 ,\r\n0,\r\ndevice);\r\nif (IS_ERR(cqr)) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Could not allocate RCD request");\r\nret = -ENOMEM;\r\ngoto out_error;\r\n}\r\ndasd_eckd_fill_rcd_cqr(device, cqr, rcd_buf, lpm);\r\ncqr->callback = read_conf_cb;\r\nret = dasd_sleep_on(cqr);\r\ndasd_sfree_request(cqr, cqr->memdev);\r\nif (ret)\r\ngoto out_error;\r\n*rcd_buffer_size = DASD_ECKD_RCD_DATA_SIZE;\r\n*rcd_buffer = rcd_buf;\r\nreturn 0;\r\nout_error:\r\nkfree(rcd_buf);\r\n*rcd_buffer = NULL;\r\n*rcd_buffer_size = 0;\r\nreturn ret;\r\n}\r\nstatic int dasd_eckd_identify_conf_parts(struct dasd_eckd_private *private)\r\n{\r\nstruct dasd_sneq *sneq;\r\nint i, count;\r\nprivate->ned = NULL;\r\nprivate->sneq = NULL;\r\nprivate->vdsneq = NULL;\r\nprivate->gneq = NULL;\r\ncount = private->conf_len / sizeof(struct dasd_sneq);\r\nsneq = (struct dasd_sneq *)private->conf_data;\r\nfor (i = 0; i < count; ++i) {\r\nif (sneq->flags.identifier == 1 && sneq->format == 1)\r\nprivate->sneq = sneq;\r\nelse if (sneq->flags.identifier == 1 && sneq->format == 4)\r\nprivate->vdsneq = (struct vd_sneq *)sneq;\r\nelse if (sneq->flags.identifier == 2)\r\nprivate->gneq = (struct dasd_gneq *)sneq;\r\nelse if (sneq->flags.identifier == 3 && sneq->res1 == 1)\r\nprivate->ned = (struct dasd_ned *)sneq;\r\nsneq++;\r\n}\r\nif (!private->ned || !private->gneq) {\r\nprivate->ned = NULL;\r\nprivate->sneq = NULL;\r\nprivate->vdsneq = NULL;\r\nprivate->gneq = NULL;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned char dasd_eckd_path_access(void *conf_data, int conf_len)\r\n{\r\nstruct dasd_gneq *gneq;\r\nint i, count, found;\r\ncount = conf_len / sizeof(*gneq);\r\ngneq = (struct dasd_gneq *)conf_data;\r\nfound = 0;\r\nfor (i = 0; i < count; ++i) {\r\nif (gneq->flags.identifier == 2) {\r\nfound = 1;\r\nbreak;\r\n}\r\ngneq++;\r\n}\r\nif (found)\r\nreturn ((char *)gneq)[18] & 0x07;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int dasd_eckd_read_conf(struct dasd_device *device)\r\n{\r\nvoid *conf_data;\r\nint conf_len, conf_data_saved;\r\nint rc, path_err;\r\n__u8 lpm, opm;\r\nstruct dasd_eckd_private *private, path_private;\r\nstruct dasd_path *path_data;\r\nstruct dasd_uid *uid;\r\nchar print_path_uid[60], print_device_uid[60];\r\nprivate = (struct dasd_eckd_private *) device->private;\r\npath_data = &device->path_data;\r\nopm = ccw_device_get_path_mask(device->cdev);\r\nconf_data_saved = 0;\r\npath_err = 0;\r\nfor (lpm = 0x80; lpm; lpm>>= 1) {\r\nif (!(lpm & opm))\r\ncontinue;\r\nrc = dasd_eckd_read_conf_lpm(device, &conf_data,\r\n&conf_len, lpm);\r\nif (rc && rc != -EOPNOTSUPP) {\r\nDBF_EVENT_DEVID(DBF_WARNING, device->cdev,\r\n"Read configuration data returned "\r\n"error %d", rc);\r\nreturn rc;\r\n}\r\nif (conf_data == NULL) {\r\nDBF_EVENT_DEVID(DBF_WARNING, device->cdev, "%s",\r\n"No configuration data "\r\n"retrieved");\r\npath_data->opm |= lpm;\r\ncontinue;\r\n}\r\nif (!conf_data_saved) {\r\nkfree(private->conf_data);\r\nprivate->conf_data = conf_data;\r\nprivate->conf_len = conf_len;\r\nif (dasd_eckd_identify_conf_parts(private)) {\r\nprivate->conf_data = NULL;\r\nprivate->conf_len = 0;\r\nkfree(conf_data);\r\ncontinue;\r\n}\r\ndasd_eckd_generate_uid(device);\r\nconf_data_saved++;\r\n} else {\r\npath_private.conf_data = conf_data;\r\npath_private.conf_len = DASD_ECKD_RCD_DATA_SIZE;\r\nif (dasd_eckd_identify_conf_parts(\r\n&path_private)) {\r\npath_private.conf_data = NULL;\r\npath_private.conf_len = 0;\r\nkfree(conf_data);\r\ncontinue;\r\n}\r\nif (dasd_eckd_compare_path_uid(\r\ndevice, &path_private)) {\r\nuid = &path_private.uid;\r\nif (strlen(uid->vduit) > 0)\r\nsnprintf(print_path_uid,\r\nsizeof(print_path_uid),\r\n"%s.%s.%04x.%02x.%s",\r\nuid->vendor, uid->serial,\r\nuid->ssid, uid->real_unit_addr,\r\nuid->vduit);\r\nelse\r\nsnprintf(print_path_uid,\r\nsizeof(print_path_uid),\r\n"%s.%s.%04x.%02x",\r\nuid->vendor, uid->serial,\r\nuid->ssid,\r\nuid->real_unit_addr);\r\nuid = &private->uid;\r\nif (strlen(uid->vduit) > 0)\r\nsnprintf(print_device_uid,\r\nsizeof(print_device_uid),\r\n"%s.%s.%04x.%02x.%s",\r\nuid->vendor, uid->serial,\r\nuid->ssid, uid->real_unit_addr,\r\nuid->vduit);\r\nelse\r\nsnprintf(print_device_uid,\r\nsizeof(print_device_uid),\r\n"%s.%s.%04x.%02x",\r\nuid->vendor, uid->serial,\r\nuid->ssid,\r\nuid->real_unit_addr);\r\ndev_err(&device->cdev->dev,\r\n"Not all channel paths lead to "\r\n"the same device, path %02X leads to "\r\n"device %s instead of %s\n", lpm,\r\nprint_path_uid, print_device_uid);\r\npath_err = -EINVAL;\r\npath_data->cablepm |= lpm;\r\ncontinue;\r\n}\r\npath_private.conf_data = NULL;\r\npath_private.conf_len = 0;\r\n}\r\nswitch (dasd_eckd_path_access(conf_data, conf_len)) {\r\ncase 0x02:\r\npath_data->npm |= lpm;\r\nbreak;\r\ncase 0x03:\r\npath_data->ppm |= lpm;\r\nbreak;\r\n}\r\npath_data->opm |= lpm;\r\npath_data->cablepm &= ~lpm;\r\npath_data->hpfpm &= ~lpm;\r\npath_data->cuirpm &= ~lpm;\r\nif (conf_data != private->conf_data)\r\nkfree(conf_data);\r\n}\r\nreturn path_err;\r\n}\r\nstatic int verify_fcx_max_data(struct dasd_device *device, __u8 lpm)\r\n{\r\nstruct dasd_eckd_private *private;\r\nint mdc;\r\nu32 fcx_max_data;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\nif (private->fcx_max_data) {\r\nmdc = ccw_device_get_mdc(device->cdev, lpm);\r\nif ((mdc < 0)) {\r\ndev_warn(&device->cdev->dev,\r\n"Detecting the maximum data size for zHPF "\r\n"requests failed (rc=%d) for a new path %x\n",\r\nmdc, lpm);\r\nreturn mdc;\r\n}\r\nfcx_max_data = mdc * FCX_MAX_DATA_FACTOR;\r\nif (fcx_max_data < private->fcx_max_data) {\r\ndev_warn(&device->cdev->dev,\r\n"The maximum data size for zHPF requests %u "\r\n"on a new path %x is below the active maximum "\r\n"%u\n", fcx_max_data, lpm,\r\nprivate->fcx_max_data);\r\nreturn -EACCES;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rebuild_device_uid(struct dasd_device *device,\r\nstruct path_verification_work_data *data)\r\n{\r\nstruct dasd_eckd_private *private;\r\nstruct dasd_path *path_data;\r\n__u8 lpm, opm;\r\nint rc;\r\nrc = -ENODEV;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\npath_data = &device->path_data;\r\nopm = device->path_data.opm;\r\nfor (lpm = 0x80; lpm; lpm >>= 1) {\r\nif (!(lpm & opm))\r\ncontinue;\r\nmemset(&data->rcd_buffer, 0, sizeof(data->rcd_buffer));\r\nmemset(&data->cqr, 0, sizeof(data->cqr));\r\ndata->cqr.cpaddr = &data->ccw;\r\nrc = dasd_eckd_read_conf_immediately(device, &data->cqr,\r\ndata->rcd_buffer,\r\nlpm);\r\nif (rc) {\r\nif (rc == -EOPNOTSUPP)\r\ncontinue;\r\nDBF_EVENT_DEVID(DBF_WARNING, device->cdev,\r\n"Read configuration data "\r\n"returned error %d", rc);\r\nbreak;\r\n}\r\nmemcpy(private->conf_data, data->rcd_buffer,\r\nDASD_ECKD_RCD_DATA_SIZE);\r\nif (dasd_eckd_identify_conf_parts(private)) {\r\nrc = -ENODEV;\r\n} else\r\nbreak;\r\n}\r\nif (!rc)\r\nrc = dasd_eckd_generate_uid(device);\r\nreturn rc;\r\n}\r\nstatic void do_path_verification_work(struct work_struct *work)\r\n{\r\nstruct path_verification_work_data *data;\r\nstruct dasd_device *device;\r\nstruct dasd_eckd_private path_private;\r\nstruct dasd_uid *uid;\r\n__u8 path_rcd_buf[DASD_ECKD_RCD_DATA_SIZE];\r\n__u8 lpm, opm, npm, ppm, epm, hpfpm, cablepm;\r\nunsigned long flags;\r\nchar print_uid[60];\r\nint rc;\r\ndata = container_of(work, struct path_verification_work_data, worker);\r\ndevice = data->device;\r\nif (test_bit(DASD_FLAG_SUSPENDED, &device->flags)) {\r\nschedule_work(work);\r\nreturn;\r\n}\r\nopm = 0;\r\nnpm = 0;\r\nppm = 0;\r\nepm = 0;\r\nhpfpm = 0;\r\ncablepm = 0;\r\nfor (lpm = 0x80; lpm; lpm >>= 1) {\r\nif (!(lpm & data->tbvpm))\r\ncontinue;\r\nmemset(&data->rcd_buffer, 0, sizeof(data->rcd_buffer));\r\nmemset(&data->cqr, 0, sizeof(data->cqr));\r\ndata->cqr.cpaddr = &data->ccw;\r\nrc = dasd_eckd_read_conf_immediately(device, &data->cqr,\r\ndata->rcd_buffer,\r\nlpm);\r\nif (!rc) {\r\nswitch (dasd_eckd_path_access(data->rcd_buffer,\r\nDASD_ECKD_RCD_DATA_SIZE)\r\n) {\r\ncase 0x02:\r\nnpm |= lpm;\r\nbreak;\r\ncase 0x03:\r\nppm |= lpm;\r\nbreak;\r\n}\r\nopm |= lpm;\r\n} else if (rc == -EOPNOTSUPP) {\r\nDBF_EVENT_DEVID(DBF_WARNING, device->cdev, "%s",\r\n"path verification: No configuration "\r\n"data retrieved");\r\nopm |= lpm;\r\n} else if (rc == -EAGAIN) {\r\nDBF_EVENT_DEVID(DBF_WARNING, device->cdev, "%s",\r\n"path verification: device is stopped,"\r\n" try again later");\r\nepm |= lpm;\r\n} else {\r\ndev_warn(&device->cdev->dev,\r\n"Reading device feature codes failed "\r\n"(rc=%d) for new path %x\n", rc, lpm);\r\ncontinue;\r\n}\r\nif (verify_fcx_max_data(device, lpm)) {\r\nopm &= ~lpm;\r\nnpm &= ~lpm;\r\nppm &= ~lpm;\r\nhpfpm |= lpm;\r\ncontinue;\r\n}\r\nmemcpy(&path_rcd_buf, data->rcd_buffer,\r\nDASD_ECKD_RCD_DATA_SIZE);\r\npath_private.conf_data = (void *) &path_rcd_buf;\r\npath_private.conf_len = DASD_ECKD_RCD_DATA_SIZE;\r\nif (dasd_eckd_identify_conf_parts(&path_private)) {\r\npath_private.conf_data = NULL;\r\npath_private.conf_len = 0;\r\ncontinue;\r\n}\r\nif (device->path_data.opm &&\r\ndasd_eckd_compare_path_uid(device, &path_private)) {\r\nif (rebuild_device_uid(device, data) ||\r\ndasd_eckd_compare_path_uid(\r\ndevice, &path_private)) {\r\nuid = &path_private.uid;\r\nif (strlen(uid->vduit) > 0)\r\nsnprintf(print_uid, sizeof(print_uid),\r\n"%s.%s.%04x.%02x.%s",\r\nuid->vendor, uid->serial,\r\nuid->ssid, uid->real_unit_addr,\r\nuid->vduit);\r\nelse\r\nsnprintf(print_uid, sizeof(print_uid),\r\n"%s.%s.%04x.%02x",\r\nuid->vendor, uid->serial,\r\nuid->ssid,\r\nuid->real_unit_addr);\r\ndev_err(&device->cdev->dev,\r\n"The newly added channel path %02X "\r\n"will not be used because it leads "\r\n"to a different device %s\n",\r\nlpm, print_uid);\r\nopm &= ~lpm;\r\nnpm &= ~lpm;\r\nppm &= ~lpm;\r\ncablepm |= lpm;\r\ncontinue;\r\n}\r\n}\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\nif (!device->path_data.opm && opm) {\r\ndevice->path_data.opm = opm;\r\ndevice->path_data.cablepm &= ~opm;\r\ndevice->path_data.cuirpm &= ~opm;\r\ndevice->path_data.hpfpm &= ~opm;\r\ndasd_generic_path_operational(device);\r\n} else {\r\ndevice->path_data.opm |= opm;\r\ndevice->path_data.cablepm &= ~opm;\r\ndevice->path_data.cuirpm &= ~opm;\r\ndevice->path_data.hpfpm &= ~opm;\r\n}\r\ndevice->path_data.npm |= npm;\r\ndevice->path_data.ppm |= ppm;\r\ndevice->path_data.tbvpm |= epm;\r\ndevice->path_data.cablepm |= cablepm;\r\ndevice->path_data.hpfpm |= hpfpm;\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\n}\r\ndasd_put_device(device);\r\nif (data->isglobal)\r\nmutex_unlock(&dasd_path_verification_mutex);\r\nelse\r\nkfree(data);\r\n}\r\nstatic int dasd_eckd_verify_path(struct dasd_device *device, __u8 lpm)\r\n{\r\nstruct path_verification_work_data *data;\r\ndata = kmalloc(sizeof(*data), GFP_ATOMIC | GFP_DMA);\r\nif (!data) {\r\nif (mutex_trylock(&dasd_path_verification_mutex)) {\r\ndata = path_verification_worker;\r\ndata->isglobal = 1;\r\n} else\r\nreturn -ENOMEM;\r\n} else {\r\nmemset(data, 0, sizeof(*data));\r\ndata->isglobal = 0;\r\n}\r\nINIT_WORK(&data->worker, do_path_verification_work);\r\ndasd_get_device(device);\r\ndata->device = device;\r\ndata->tbvpm = lpm;\r\nschedule_work(&data->worker);\r\nreturn 0;\r\n}\r\nstatic int dasd_eckd_read_features(struct dasd_device *device)\r\n{\r\nstruct dasd_psf_prssd_data *prssdp;\r\nstruct dasd_rssd_features *features;\r\nstruct dasd_ccw_req *cqr;\r\nstruct ccw1 *ccw;\r\nint rc;\r\nstruct dasd_eckd_private *private;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\nmemset(&private->features, 0, sizeof(struct dasd_rssd_features));\r\ncqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1 + 1 ,\r\n(sizeof(struct dasd_psf_prssd_data) +\r\nsizeof(struct dasd_rssd_features)),\r\ndevice);\r\nif (IS_ERR(cqr)) {\r\nDBF_EVENT_DEVID(DBF_WARNING, device->cdev, "%s", "Could not "\r\n"allocate initialization request");\r\nreturn PTR_ERR(cqr);\r\n}\r\ncqr->startdev = device;\r\ncqr->memdev = device;\r\ncqr->block = NULL;\r\ncqr->retries = 256;\r\ncqr->expires = 10 * HZ;\r\nprssdp = (struct dasd_psf_prssd_data *) cqr->data;\r\nmemset(prssdp, 0, sizeof(struct dasd_psf_prssd_data));\r\nprssdp->order = PSF_ORDER_PRSSD;\r\nprssdp->suborder = 0x41;\r\nccw = cqr->cpaddr;\r\nccw->cmd_code = DASD_ECKD_CCW_PSF;\r\nccw->count = sizeof(struct dasd_psf_prssd_data);\r\nccw->flags |= CCW_FLAG_CC;\r\nccw->cda = (__u32)(addr_t) prssdp;\r\nfeatures = (struct dasd_rssd_features *) (prssdp + 1);\r\nmemset(features, 0, sizeof(struct dasd_rssd_features));\r\nccw++;\r\nccw->cmd_code = DASD_ECKD_CCW_RSSD;\r\nccw->count = sizeof(struct dasd_rssd_features);\r\nccw->cda = (__u32)(addr_t) features;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nrc = dasd_sleep_on(cqr);\r\nif (rc == 0) {\r\nprssdp = (struct dasd_psf_prssd_data *) cqr->data;\r\nfeatures = (struct dasd_rssd_features *) (prssdp + 1);\r\nmemcpy(&private->features, features,\r\nsizeof(struct dasd_rssd_features));\r\n} else\r\ndev_warn(&device->cdev->dev, "Reading device feature codes"\r\n" failed with rc=%d\n", rc);\r\ndasd_sfree_request(cqr, cqr->memdev);\r\nreturn rc;\r\n}\r\nstatic struct dasd_ccw_req *dasd_eckd_build_psf_ssc(struct dasd_device *device,\r\nint enable_pav)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nstruct dasd_psf_ssc_data *psf_ssc_data;\r\nstruct ccw1 *ccw;\r\ncqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1 ,\r\nsizeof(struct dasd_psf_ssc_data),\r\ndevice);\r\nif (IS_ERR(cqr)) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Could not allocate PSF-SSC request");\r\nreturn cqr;\r\n}\r\npsf_ssc_data = (struct dasd_psf_ssc_data *)cqr->data;\r\npsf_ssc_data->order = PSF_ORDER_SSC;\r\npsf_ssc_data->suborder = 0xc0;\r\nif (enable_pav) {\r\npsf_ssc_data->suborder |= 0x08;\r\npsf_ssc_data->reserved[0] = 0x88;\r\n}\r\nccw = cqr->cpaddr;\r\nccw->cmd_code = DASD_ECKD_CCW_PSF;\r\nccw->cda = (__u32)(addr_t)psf_ssc_data;\r\nccw->count = 66;\r\ncqr->startdev = device;\r\ncqr->memdev = device;\r\ncqr->block = NULL;\r\ncqr->retries = 256;\r\ncqr->expires = 10*HZ;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nreturn cqr;\r\n}\r\nstatic int\r\ndasd_eckd_psf_ssc(struct dasd_device *device, int enable_pav,\r\nunsigned long flags)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nint rc;\r\ncqr = dasd_eckd_build_psf_ssc(device, enable_pav);\r\nif (IS_ERR(cqr))\r\nreturn PTR_ERR(cqr);\r\ncqr->flags |= flags;\r\nrc = dasd_sleep_on(cqr);\r\nif (!rc)\r\ncss_schedule_reprobe();\r\nelse if (cqr->intrc == -EAGAIN)\r\nrc = -EAGAIN;\r\ndasd_sfree_request(cqr, cqr->memdev);\r\nreturn rc;\r\n}\r\nstatic int dasd_eckd_validate_server(struct dasd_device *device,\r\nunsigned long flags)\r\n{\r\nint rc;\r\nstruct dasd_eckd_private *private;\r\nint enable_pav;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\nif (private->uid.type == UA_BASE_PAV_ALIAS ||\r\nprivate->uid.type == UA_HYPER_PAV_ALIAS)\r\nreturn 0;\r\nif (dasd_nopav || MACHINE_IS_VM)\r\nenable_pav = 0;\r\nelse\r\nenable_pav = 1;\r\nrc = dasd_eckd_psf_ssc(device, enable_pav, flags);\r\nDBF_EVENT_DEVID(DBF_WARNING, device->cdev, "PSF-SSC for SSID %04x "\r\n"returned rc=%d", private->uid.ssid, rc);\r\nreturn rc;\r\n}\r\nstatic void dasd_eckd_do_validate_server(struct work_struct *work)\r\n{\r\nstruct dasd_device *device = container_of(work, struct dasd_device,\r\nkick_validate);\r\nunsigned long flags = 0;\r\nset_bit(DASD_CQR_FLAGS_FAILFAST, &flags);\r\nif (dasd_eckd_validate_server(device, flags)\r\n== -EAGAIN) {\r\nschedule_work(&device->kick_validate);\r\nreturn;\r\n}\r\ndasd_put_device(device);\r\n}\r\nstatic void dasd_eckd_kick_validate_server(struct dasd_device *device)\r\n{\r\ndasd_get_device(device);\r\nif (test_bit(DASD_FLAG_OFFLINE, &device->flags) ||\r\ndevice->state < DASD_STATE_ONLINE) {\r\ndasd_put_device(device);\r\nreturn;\r\n}\r\nschedule_work(&device->kick_validate);\r\n}\r\nstatic u32 get_fcx_max_data(struct dasd_device *device)\r\n{\r\n#if defined(CONFIG_64BIT)\r\nint tpm, mdc;\r\nint fcx_in_css, fcx_in_gneq, fcx_in_features;\r\nstruct dasd_eckd_private *private;\r\nif (dasd_nofcx)\r\nreturn 0;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\nfcx_in_css = css_general_characteristics.fcx;\r\nfcx_in_gneq = private->gneq->reserved2[7] & 0x04;\r\nfcx_in_features = private->features.feature[40] & 0x80;\r\ntpm = fcx_in_css && fcx_in_gneq && fcx_in_features;\r\nif (!tpm)\r\nreturn 0;\r\nmdc = ccw_device_get_mdc(device->cdev, 0);\r\nif (mdc < 0) {\r\ndev_warn(&device->cdev->dev, "Detecting the maximum supported"\r\n" data size for zHPF requests failed\n");\r\nreturn 0;\r\n} else\r\nreturn mdc * FCX_MAX_DATA_FACTOR;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int\r\ndasd_eckd_check_characteristics(struct dasd_device *device)\r\n{\r\nstruct dasd_eckd_private *private;\r\nstruct dasd_block *block;\r\nstruct dasd_uid temp_uid;\r\nint rc, i;\r\nint readonly;\r\nunsigned long value;\r\nINIT_WORK(&device->kick_validate, dasd_eckd_do_validate_server);\r\nif (!ccw_device_is_pathgroup(device->cdev)) {\r\ndev_warn(&device->cdev->dev,\r\n"A channel path group could not be established\n");\r\nreturn -EIO;\r\n}\r\nif (!ccw_device_is_multipath(device->cdev)) {\r\ndev_info(&device->cdev->dev,\r\n"The DASD is not operating in multipath mode\n");\r\n}\r\nprivate = (struct dasd_eckd_private *) device->private;\r\nif (!private) {\r\nprivate = kzalloc(sizeof(*private), GFP_KERNEL | GFP_DMA);\r\nif (!private) {\r\ndev_warn(&device->cdev->dev,\r\n"Allocating memory for private DASD data "\r\n"failed\n");\r\nreturn -ENOMEM;\r\n}\r\ndevice->private = (void *) private;\r\n} else {\r\nmemset(private, 0, sizeof(*private));\r\n}\r\nprivate->init_cqr_status = -1;\r\nprivate->attrib.operation = DASD_NORMAL_CACHE;\r\nprivate->attrib.nr_cyl = 0;\r\nrc = dasd_eckd_read_conf(device);\r\nif (rc)\r\ngoto out_err1;\r\ndevice->default_expires = DASD_EXPIRES;\r\ndevice->default_retries = DASD_RETRIES;\r\nif (private->gneq) {\r\nvalue = 1;\r\nfor (i = 0; i < private->gneq->timeout.value; i++)\r\nvalue = 10 * value;\r\nvalue = value * private->gneq->timeout.number;\r\nif (value != 0 && value <= DASD_EXPIRES_MAX)\r\ndevice->default_expires = value;\r\n}\r\ndasd_eckd_get_uid(device, &temp_uid);\r\nif (temp_uid.type == UA_BASE_DEVICE) {\r\nblock = dasd_alloc_block();\r\nif (IS_ERR(block)) {\r\nDBF_EVENT_DEVID(DBF_WARNING, device->cdev, "%s",\r\n"could not allocate dasd "\r\n"block structure");\r\nrc = PTR_ERR(block);\r\ngoto out_err1;\r\n}\r\ndevice->block = block;\r\nblock->base = device;\r\n}\r\nrc = dasd_alias_make_device_known_to_lcu(device);\r\nif (rc)\r\ngoto out_err2;\r\ndasd_eckd_validate_server(device, 0);\r\nrc = dasd_eckd_read_conf(device);\r\nif (rc)\r\ngoto out_err3;\r\ndasd_eckd_read_features(device);\r\nrc = dasd_generic_read_dev_chars(device, DASD_ECKD_MAGIC,\r\n&private->rdc_data, 64);\r\nif (rc) {\r\nDBF_EVENT_DEVID(DBF_WARNING, device->cdev,\r\n"Read device characteristic failed, rc=%d", rc);\r\ngoto out_err3;\r\n}\r\nif ((device->features & DASD_FEATURE_USERAW) &&\r\n!(private->rdc_data.facilities.RT_in_LR)) {\r\ndev_err(&device->cdev->dev, "The storage server does not "\r\n"support raw-track access\n");\r\nrc = -EINVAL;\r\ngoto out_err3;\r\n}\r\nif (private->rdc_data.no_cyl == LV_COMPAT_CYL &&\r\nprivate->rdc_data.long_no_cyl)\r\nprivate->real_cyl = private->rdc_data.long_no_cyl;\r\nelse\r\nprivate->real_cyl = private->rdc_data.no_cyl;\r\nprivate->fcx_max_data = get_fcx_max_data(device);\r\nreadonly = dasd_device_is_ro(device);\r\nif (readonly)\r\nset_bit(DASD_FLAG_DEVICE_RO, &device->flags);\r\ndev_info(&device->cdev->dev, "New DASD %04X/%02X (CU %04X/%02X) "\r\n"with %d cylinders, %d heads, %d sectors%s\n",\r\nprivate->rdc_data.dev_type,\r\nprivate->rdc_data.dev_model,\r\nprivate->rdc_data.cu_type,\r\nprivate->rdc_data.cu_model.model,\r\nprivate->real_cyl,\r\nprivate->rdc_data.trk_per_cyl,\r\nprivate->rdc_data.sec_per_trk,\r\nreadonly ? ", read-only device" : "");\r\nreturn 0;\r\nout_err3:\r\ndasd_alias_disconnect_device_from_lcu(device);\r\nout_err2:\r\ndasd_free_block(device->block);\r\ndevice->block = NULL;\r\nout_err1:\r\nkfree(private->conf_data);\r\nkfree(device->private);\r\ndevice->private = NULL;\r\nreturn rc;\r\n}\r\nstatic void dasd_eckd_uncheck_device(struct dasd_device *device)\r\n{\r\nstruct dasd_eckd_private *private;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\ndasd_alias_disconnect_device_from_lcu(device);\r\nprivate->ned = NULL;\r\nprivate->sneq = NULL;\r\nprivate->vdsneq = NULL;\r\nprivate->gneq = NULL;\r\nprivate->conf_len = 0;\r\nkfree(private->conf_data);\r\nprivate->conf_data = NULL;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_eckd_analysis_ccw(struct dasd_device *device)\r\n{\r\nstruct dasd_eckd_private *private;\r\nstruct eckd_count *count_data;\r\nstruct LO_eckd_data *LO_data;\r\nstruct dasd_ccw_req *cqr;\r\nstruct ccw1 *ccw;\r\nint cplength, datasize;\r\nint i;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\ncplength = 8;\r\ndatasize = sizeof(struct DE_eckd_data) + 2*sizeof(struct LO_eckd_data);\r\ncqr = dasd_smalloc_request(DASD_ECKD_MAGIC, cplength, datasize, device);\r\nif (IS_ERR(cqr))\r\nreturn cqr;\r\nccw = cqr->cpaddr;\r\ndefine_extent(ccw++, cqr->data, 0, 2,\r\nDASD_ECKD_CCW_READ_COUNT, device);\r\nLO_data = cqr->data + sizeof(struct DE_eckd_data);\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nlocate_record(ccw++, LO_data++, 0, 0, 4,\r\nDASD_ECKD_CCW_READ_COUNT, device, 0);\r\ncount_data = private->count_area;\r\nfor (i = 0; i < 4; i++) {\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nccw->cmd_code = DASD_ECKD_CCW_READ_COUNT;\r\nccw->flags = 0;\r\nccw->count = 8;\r\nccw->cda = (__u32)(addr_t) count_data;\r\nccw++;\r\ncount_data++;\r\n}\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nlocate_record(ccw++, LO_data++, 2, 0, 1,\r\nDASD_ECKD_CCW_READ_COUNT, device, 0);\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nccw->cmd_code = DASD_ECKD_CCW_READ_COUNT;\r\nccw->flags = 0;\r\nccw->count = 8;\r\nccw->cda = (__u32)(addr_t) count_data;\r\ncqr->block = NULL;\r\ncqr->startdev = device;\r\ncqr->memdev = device;\r\ncqr->retries = 255;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nreturn cqr;\r\n}\r\nstatic int dasd_eckd_analysis_evaluation(struct dasd_ccw_req *init_cqr)\r\n{\r\nchar *sense;\r\nif (init_cqr->status == DASD_CQR_DONE)\r\nreturn INIT_CQR_OK;\r\nelse if (init_cqr->status == DASD_CQR_NEED_ERP ||\r\ninit_cqr->status == DASD_CQR_FAILED) {\r\nsense = dasd_get_sense(&init_cqr->irb);\r\nif (sense && (sense[1] & SNS1_NO_REC_FOUND))\r\nreturn INIT_CQR_UNFORMATTED;\r\nelse\r\nreturn INIT_CQR_ERROR;\r\n} else\r\nreturn INIT_CQR_ERROR;\r\n}\r\nstatic void dasd_eckd_analysis_callback(struct dasd_ccw_req *init_cqr,\r\nvoid *data)\r\n{\r\nstruct dasd_eckd_private *private;\r\nstruct dasd_device *device;\r\ndevice = init_cqr->startdev;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\nprivate->init_cqr_status = dasd_eckd_analysis_evaluation(init_cqr);\r\ndasd_sfree_request(init_cqr, device);\r\ndasd_kick_device(device);\r\n}\r\nstatic int dasd_eckd_start_analysis(struct dasd_block *block)\r\n{\r\nstruct dasd_ccw_req *init_cqr;\r\ninit_cqr = dasd_eckd_analysis_ccw(block->base);\r\nif (IS_ERR(init_cqr))\r\nreturn PTR_ERR(init_cqr);\r\ninit_cqr->callback = dasd_eckd_analysis_callback;\r\ninit_cqr->callback_data = NULL;\r\ninit_cqr->expires = 5*HZ;\r\nclear_bit(DASD_CQR_FLAGS_USE_ERP, &init_cqr->flags);\r\ninit_cqr->retries = 0;\r\ndasd_add_request_head(init_cqr);\r\nreturn -EAGAIN;\r\n}\r\nstatic int dasd_eckd_end_analysis(struct dasd_block *block)\r\n{\r\nstruct dasd_device *device;\r\nstruct dasd_eckd_private *private;\r\nstruct eckd_count *count_area;\r\nunsigned int sb, blk_per_trk;\r\nint status, i;\r\nstruct dasd_ccw_req *init_cqr;\r\ndevice = block->base;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\nstatus = private->init_cqr_status;\r\nprivate->init_cqr_status = -1;\r\nif (status == INIT_CQR_ERROR) {\r\ninit_cqr = dasd_eckd_analysis_ccw(device);\r\ndasd_sleep_on(init_cqr);\r\nstatus = dasd_eckd_analysis_evaluation(init_cqr);\r\ndasd_sfree_request(init_cqr, device);\r\n}\r\nif (device->features & DASD_FEATURE_USERAW) {\r\nblock->bp_block = DASD_RAW_BLOCKSIZE;\r\nblk_per_trk = DASD_RAW_BLOCK_PER_TRACK;\r\nblock->s2b_shift = 3;\r\ngoto raw;\r\n}\r\nif (status == INIT_CQR_UNFORMATTED) {\r\ndev_warn(&device->cdev->dev, "The DASD is not formatted\n");\r\nreturn -EMEDIUMTYPE;\r\n} else if (status == INIT_CQR_ERROR) {\r\ndev_err(&device->cdev->dev,\r\n"Detecting the DASD disk layout failed because "\r\n"of an I/O error\n");\r\nreturn -EIO;\r\n}\r\nprivate->uses_cdl = 1;\r\ncount_area = NULL;\r\nfor (i = 0; i < 3; i++) {\r\nif (private->count_area[i].kl != 4 ||\r\nprivate->count_area[i].dl != dasd_eckd_cdl_reclen(i) - 4 ||\r\nprivate->count_area[i].cyl != 0 ||\r\nprivate->count_area[i].head != count_area_head[i] ||\r\nprivate->count_area[i].record != count_area_rec[i]) {\r\nprivate->uses_cdl = 0;\r\nbreak;\r\n}\r\n}\r\nif (i == 3)\r\ncount_area = &private->count_area[4];\r\nif (private->uses_cdl == 0) {\r\nfor (i = 0; i < 5; i++) {\r\nif ((private->count_area[i].kl != 0) ||\r\n(private->count_area[i].dl !=\r\nprivate->count_area[0].dl) ||\r\nprivate->count_area[i].cyl != 0 ||\r\nprivate->count_area[i].head != count_area_head[i] ||\r\nprivate->count_area[i].record != count_area_rec[i])\r\nbreak;\r\n}\r\nif (i == 5)\r\ncount_area = &private->count_area[0];\r\n} else {\r\nif (private->count_area[3].record == 1)\r\ndev_warn(&device->cdev->dev,\r\n"Track 0 has no records following the VTOC\n");\r\n}\r\nif (count_area != NULL && count_area->kl == 0) {\r\nif (dasd_check_blocksize(count_area->dl) == 0)\r\nblock->bp_block = count_area->dl;\r\n}\r\nif (block->bp_block == 0) {\r\ndev_warn(&device->cdev->dev,\r\n"The disk layout of the DASD is not supported\n");\r\nreturn -EMEDIUMTYPE;\r\n}\r\nblock->s2b_shift = 0;\r\nfor (sb = 512; sb < block->bp_block; sb = sb << 1)\r\nblock->s2b_shift++;\r\nblk_per_trk = recs_per_track(&private->rdc_data, 0, block->bp_block);\r\nraw:\r\nblock->blocks = (private->real_cyl *\r\nprivate->rdc_data.trk_per_cyl *\r\nblk_per_trk);\r\ndev_info(&device->cdev->dev,\r\n"DASD with %d KB/block, %d KB total size, %d KB/track, "\r\n"%s\n", (block->bp_block >> 10),\r\n((private->real_cyl *\r\nprivate->rdc_data.trk_per_cyl *\r\nblk_per_trk * (block->bp_block >> 9)) >> 1),\r\n((blk_per_trk * block->bp_block) >> 10),\r\nprivate->uses_cdl ?\r\n"compatible disk layout" : "linux disk layout");\r\nreturn 0;\r\n}\r\nstatic int dasd_eckd_do_analysis(struct dasd_block *block)\r\n{\r\nstruct dasd_eckd_private *private;\r\nprivate = (struct dasd_eckd_private *) block->base->private;\r\nif (private->init_cqr_status < 0)\r\nreturn dasd_eckd_start_analysis(block);\r\nelse\r\nreturn dasd_eckd_end_analysis(block);\r\n}\r\nstatic int dasd_eckd_basic_to_ready(struct dasd_device *device)\r\n{\r\nreturn dasd_alias_add_device(device);\r\n}\r\nstatic int dasd_eckd_online_to_ready(struct dasd_device *device)\r\n{\r\ncancel_work_sync(&device->reload_device);\r\ncancel_work_sync(&device->kick_validate);\r\nreturn 0;\r\n}\r\nstatic int dasd_eckd_basic_to_known(struct dasd_device *device)\r\n{\r\nreturn dasd_alias_remove_device(device);\r\n}\r\nstatic int\r\ndasd_eckd_fill_geometry(struct dasd_block *block, struct hd_geometry *geo)\r\n{\r\nstruct dasd_eckd_private *private;\r\nprivate = (struct dasd_eckd_private *) block->base->private;\r\nif (dasd_check_blocksize(block->bp_block) == 0) {\r\ngeo->sectors = recs_per_track(&private->rdc_data,\r\n0, block->bp_block);\r\n}\r\ngeo->cylinders = private->rdc_data.no_cyl;\r\ngeo->heads = private->rdc_data.trk_per_cyl;\r\nreturn 0;\r\n}\r\nstatic struct dasd_ccw_req *\r\ndasd_eckd_build_format(struct dasd_device *base,\r\nstruct format_data_t *fdata,\r\nint enable_pav)\r\n{\r\nstruct dasd_eckd_private *base_priv;\r\nstruct dasd_eckd_private *start_priv;\r\nstruct dasd_device *startdev = NULL;\r\nstruct dasd_ccw_req *fcp;\r\nstruct eckd_count *ect;\r\nstruct ch_t address;\r\nstruct ccw1 *ccw;\r\nvoid *data;\r\nint rpt;\r\nint cplength, datasize;\r\nint i, j;\r\nint intensity = 0;\r\nint r0_perm;\r\nint nr_tracks;\r\nint use_prefix;\r\nif (enable_pav)\r\nstartdev = dasd_alias_get_start_dev(base);\r\nif (!startdev)\r\nstartdev = base;\r\nstart_priv = (struct dasd_eckd_private *) startdev->private;\r\nbase_priv = (struct dasd_eckd_private *) base->private;\r\nrpt = recs_per_track(&base_priv->rdc_data, 0, fdata->blksize);\r\nnr_tracks = fdata->stop_unit - fdata->start_unit + 1;\r\nif (fdata->intensity & 0x10) {\r\nr0_perm = 0;\r\nintensity = fdata->intensity & ~0x10;\r\n} else {\r\nr0_perm = 1;\r\nintensity = fdata->intensity;\r\n}\r\nuse_prefix = base_priv->features.feature[8] & 0x01;\r\nswitch (intensity) {\r\ncase 0x00:\r\ncase 0x08:\r\ncplength = 2 + (rpt*nr_tracks);\r\nif (use_prefix)\r\ndatasize = sizeof(struct PFX_eckd_data) +\r\nsizeof(struct LO_eckd_data) +\r\nrpt * nr_tracks * sizeof(struct eckd_count);\r\nelse\r\ndatasize = sizeof(struct DE_eckd_data) +\r\nsizeof(struct LO_eckd_data) +\r\nrpt * nr_tracks * sizeof(struct eckd_count);\r\nbreak;\r\ncase 0x01:\r\ncase 0x09:\r\ncplength = 2 + rpt * nr_tracks;\r\nif (use_prefix)\r\ndatasize = sizeof(struct PFX_eckd_data) +\r\nsizeof(struct LO_eckd_data) +\r\nsizeof(struct eckd_count) +\r\nrpt * nr_tracks * sizeof(struct eckd_count);\r\nelse\r\ndatasize = sizeof(struct DE_eckd_data) +\r\nsizeof(struct LO_eckd_data) +\r\nsizeof(struct eckd_count) +\r\nrpt * nr_tracks * sizeof(struct eckd_count);\r\nbreak;\r\ncase 0x04:\r\ncase 0x0c:\r\ncplength = 3;\r\nif (use_prefix)\r\ndatasize = sizeof(struct PFX_eckd_data) +\r\nsizeof(struct LO_eckd_data) +\r\nsizeof(struct eckd_count);\r\nelse\r\ndatasize = sizeof(struct DE_eckd_data) +\r\nsizeof(struct LO_eckd_data) +\r\nsizeof(struct eckd_count);\r\nbreak;\r\ndefault:\r\ndev_warn(&startdev->cdev->dev,\r\n"An I/O control call used incorrect flags 0x%x\n",\r\nfdata->intensity);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nfcp = dasd_smalloc_request(DASD_ECKD_MAGIC, cplength,\r\ndatasize, startdev);\r\nif (IS_ERR(fcp))\r\nreturn fcp;\r\nstart_priv->count++;\r\ndata = fcp->data;\r\nccw = fcp->cpaddr;\r\nswitch (intensity & ~0x08) {\r\ncase 0x00:\r\nif (use_prefix) {\r\nprefix(ccw++, (struct PFX_eckd_data *) data,\r\nfdata->start_unit, fdata->stop_unit,\r\nDASD_ECKD_CCW_WRITE_CKD, base, startdev);\r\nif (r0_perm)\r\n((struct PFX_eckd_data *)data)\r\n->define_extent.ga_extended |= 0x04;\r\ndata += sizeof(struct PFX_eckd_data);\r\n} else {\r\ndefine_extent(ccw++, (struct DE_eckd_data *) data,\r\nfdata->start_unit, fdata->stop_unit,\r\nDASD_ECKD_CCW_WRITE_CKD, startdev);\r\nif (r0_perm)\r\n((struct DE_eckd_data *) data)\r\n->ga_extended |= 0x04;\r\ndata += sizeof(struct DE_eckd_data);\r\n}\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nlocate_record(ccw++, (struct LO_eckd_data *) data,\r\nfdata->start_unit, 0, rpt*nr_tracks,\r\nDASD_ECKD_CCW_WRITE_CKD, base,\r\nfdata->blksize);\r\ndata += sizeof(struct LO_eckd_data);\r\nbreak;\r\ncase 0x01:\r\nif (use_prefix) {\r\nprefix(ccw++, (struct PFX_eckd_data *) data,\r\nfdata->start_unit, fdata->stop_unit,\r\nDASD_ECKD_CCW_WRITE_RECORD_ZERO,\r\nbase, startdev);\r\ndata += sizeof(struct PFX_eckd_data);\r\n} else {\r\ndefine_extent(ccw++, (struct DE_eckd_data *) data,\r\nfdata->start_unit, fdata->stop_unit,\r\nDASD_ECKD_CCW_WRITE_RECORD_ZERO, startdev);\r\ndata += sizeof(struct DE_eckd_data);\r\n}\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nlocate_record(ccw++, (struct LO_eckd_data *) data,\r\nfdata->start_unit, 0, rpt * nr_tracks + 1,\r\nDASD_ECKD_CCW_WRITE_RECORD_ZERO, base,\r\nbase->block->bp_block);\r\ndata += sizeof(struct LO_eckd_data);\r\nbreak;\r\ncase 0x04:\r\nif (use_prefix) {\r\nprefix(ccw++, (struct PFX_eckd_data *) data,\r\nfdata->start_unit, fdata->stop_unit,\r\nDASD_ECKD_CCW_WRITE_CKD, base, startdev);\r\ndata += sizeof(struct PFX_eckd_data);\r\n} else {\r\ndefine_extent(ccw++, (struct DE_eckd_data *) data,\r\nfdata->start_unit, fdata->stop_unit,\r\nDASD_ECKD_CCW_WRITE_CKD, startdev);\r\ndata += sizeof(struct DE_eckd_data);\r\n}\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nlocate_record(ccw++, (struct LO_eckd_data *) data,\r\nfdata->start_unit, 0, 1,\r\nDASD_ECKD_CCW_WRITE_CKD, base, 8);\r\ndata += sizeof(struct LO_eckd_data);\r\nbreak;\r\n}\r\nfor (j = 0; j < nr_tracks; j++) {\r\nset_ch_t(&address,\r\n(fdata->start_unit + j) /\r\nbase_priv->rdc_data.trk_per_cyl,\r\n(fdata->start_unit + j) %\r\nbase_priv->rdc_data.trk_per_cyl);\r\nif (intensity & 0x01) {\r\nect = (struct eckd_count *) data;\r\ndata += sizeof(struct eckd_count);\r\nect->cyl = address.cyl;\r\nect->head = address.head;\r\nect->record = 0;\r\nect->kl = 0;\r\nect->dl = 8;\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nccw->cmd_code = DASD_ECKD_CCW_WRITE_RECORD_ZERO;\r\nccw->flags = CCW_FLAG_SLI;\r\nccw->count = 8;\r\nccw->cda = (__u32)(addr_t) ect;\r\nccw++;\r\n}\r\nif ((intensity & ~0x08) & 0x04) {\r\nect = (struct eckd_count *) data;\r\ndata += sizeof(struct eckd_count);\r\nect->cyl = address.cyl;\r\nect->head = address.head;\r\nect->record = 1;\r\nect->kl = 0;\r\nect->dl = 0;\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nccw->cmd_code = DASD_ECKD_CCW_WRITE_CKD;\r\nccw->flags = CCW_FLAG_SLI;\r\nccw->count = 8;\r\nccw->cda = (__u32)(addr_t) ect;\r\n} else {\r\nfor (i = 0; i < rpt; i++) {\r\nect = (struct eckd_count *) data;\r\ndata += sizeof(struct eckd_count);\r\nect->cyl = address.cyl;\r\nect->head = address.head;\r\nect->record = i + 1;\r\nect->kl = 0;\r\nect->dl = fdata->blksize;\r\nif ((intensity & 0x08) &&\r\nfdata->start_unit == 0) {\r\nif (i < 3) {\r\nect->kl = 4;\r\nect->dl = sizes_trk0[i] - 4;\r\n}\r\n}\r\nif ((intensity & 0x08) &&\r\nfdata->start_unit == 1) {\r\nect->kl = 44;\r\nect->dl = LABEL_SIZE - 44;\r\n}\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nif (i != 0 || j == 0)\r\nccw->cmd_code =\r\nDASD_ECKD_CCW_WRITE_CKD;\r\nelse\r\nccw->cmd_code =\r\nDASD_ECKD_CCW_WRITE_CKD_MT;\r\nccw->flags = CCW_FLAG_SLI;\r\nccw->count = 8;\r\nccw->cda = (__u32)(addr_t) ect;\r\nccw++;\r\n}\r\n}\r\n}\r\nfcp->startdev = startdev;\r\nfcp->memdev = startdev;\r\nfcp->basedev = base;\r\nfcp->retries = 256;\r\nfcp->expires = startdev->default_expires * HZ;\r\nfcp->buildclk = get_tod_clock();\r\nfcp->status = DASD_CQR_FILLED;\r\nreturn fcp;\r\n}\r\nstatic int\r\ndasd_eckd_format_device(struct dasd_device *base,\r\nstruct format_data_t *fdata,\r\nint enable_pav)\r\n{\r\nstruct dasd_ccw_req *cqr, *n;\r\nstruct dasd_block *block;\r\nstruct dasd_eckd_private *private;\r\nstruct list_head format_queue;\r\nstruct dasd_device *device;\r\nint old_stop, format_step;\r\nint step, rc = 0, sleep_rc;\r\nblock = base->block;\r\nprivate = (struct dasd_eckd_private *) base->private;\r\nif (fdata->start_unit >=\r\n(private->real_cyl * private->rdc_data.trk_per_cyl)) {\r\ndev_warn(&base->cdev->dev,\r\n"Start track number %u used in formatting is too big\n",\r\nfdata->start_unit);\r\nreturn -EINVAL;\r\n}\r\nif (fdata->stop_unit >=\r\n(private->real_cyl * private->rdc_data.trk_per_cyl)) {\r\ndev_warn(&base->cdev->dev,\r\n"Stop track number %u used in formatting is too big\n",\r\nfdata->stop_unit);\r\nreturn -EINVAL;\r\n}\r\nif (fdata->start_unit > fdata->stop_unit) {\r\ndev_warn(&base->cdev->dev,\r\n"Start track %u used in formatting exceeds end track\n",\r\nfdata->start_unit);\r\nreturn -EINVAL;\r\n}\r\nif (dasd_check_blocksize(fdata->blksize) != 0) {\r\ndev_warn(&base->cdev->dev,\r\n"The DASD cannot be formatted with block size %u\n",\r\nfdata->blksize);\r\nreturn -EINVAL;\r\n}\r\nINIT_LIST_HEAD(&format_queue);\r\nold_stop = fdata->stop_unit;\r\nwhile (fdata->start_unit <= 1) {\r\nfdata->stop_unit = fdata->start_unit;\r\ncqr = dasd_eckd_build_format(base, fdata, enable_pav);\r\nlist_add(&cqr->blocklist, &format_queue);\r\nfdata->stop_unit = old_stop;\r\nfdata->start_unit++;\r\nif (fdata->start_unit > fdata->stop_unit)\r\ngoto sleep;\r\n}\r\nretry:\r\nformat_step = 255 / recs_per_track(&private->rdc_data, 0,\r\nfdata->blksize);\r\nwhile (fdata->start_unit <= old_stop) {\r\nstep = fdata->stop_unit - fdata->start_unit + 1;\r\nif (step > format_step)\r\nfdata->stop_unit = fdata->start_unit + format_step - 1;\r\ncqr = dasd_eckd_build_format(base, fdata, enable_pav);\r\nif (IS_ERR(cqr)) {\r\nif (PTR_ERR(cqr) == -ENOMEM) {\r\nfdata->stop_unit = old_stop;\r\ngoto sleep;\r\n} else\r\nreturn PTR_ERR(cqr);\r\n}\r\nlist_add(&cqr->blocklist, &format_queue);\r\nfdata->start_unit = fdata->stop_unit + 1;\r\nfdata->stop_unit = old_stop;\r\n}\r\nsleep:\r\nsleep_rc = dasd_sleep_on_queue(&format_queue);\r\nlist_for_each_entry_safe(cqr, n, &format_queue, blocklist) {\r\ndevice = cqr->startdev;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\nif (cqr->status == DASD_CQR_FAILED)\r\nrc = -EIO;\r\nlist_del_init(&cqr->blocklist);\r\ndasd_sfree_request(cqr, device);\r\nprivate->count--;\r\n}\r\nif (sleep_rc)\r\nreturn sleep_rc;\r\nif (fdata->start_unit <= fdata->stop_unit)\r\ngoto retry;\r\nreturn rc;\r\n}\r\nstatic void dasd_eckd_handle_terminated_request(struct dasd_ccw_req *cqr)\r\n{\r\nif (cqr->retries < 0) {\r\ncqr->status = DASD_CQR_FAILED;\r\nreturn;\r\n}\r\ncqr->status = DASD_CQR_FILLED;\r\nif (cqr->block && (cqr->startdev != cqr->block->base)) {\r\ndasd_eckd_reset_ccw_to_base_io(cqr);\r\ncqr->startdev = cqr->block->base;\r\ncqr->lpm = cqr->block->base->path_data.opm;\r\n}\r\n}\r\nstatic dasd_erp_fn_t\r\ndasd_eckd_erp_action(struct dasd_ccw_req * cqr)\r\n{\r\nstruct dasd_device *device = (struct dasd_device *) cqr->startdev;\r\nstruct ccw_device *cdev = device->cdev;\r\nswitch (cdev->id.cu_type) {\r\ncase 0x3990:\r\ncase 0x2105:\r\ncase 0x2107:\r\ncase 0x1750:\r\nreturn dasd_3990_erp_action;\r\ncase 0x9343:\r\ncase 0x3880:\r\ndefault:\r\nreturn dasd_default_erp_action;\r\n}\r\n}\r\nstatic dasd_erp_fn_t\r\ndasd_eckd_erp_postaction(struct dasd_ccw_req * cqr)\r\n{\r\nreturn dasd_default_erp_postaction;\r\n}\r\nstatic void dasd_eckd_check_for_device_change(struct dasd_device *device,\r\nstruct dasd_ccw_req *cqr,\r\nstruct irb *irb)\r\n{\r\nchar mask;\r\nchar *sense = NULL;\r\nstruct dasd_eckd_private *private;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\nmask = DEV_STAT_ATTENTION | DEV_STAT_DEV_END | DEV_STAT_UNIT_EXCEP;\r\nif ((scsw_dstat(&irb->scsw) & mask) == mask) {\r\nif (!device->block && private->lcu &&\r\ndevice->state == DASD_STATE_ONLINE &&\r\n!test_bit(DASD_FLAG_OFFLINE, &device->flags) &&\r\n!test_bit(DASD_FLAG_SUSPENDED, &device->flags)) {\r\ndasd_alias_remove_device(device);\r\ndasd_reload_device(device);\r\n}\r\ndasd_generic_handle_state_change(device);\r\nreturn;\r\n}\r\nsense = dasd_get_sense(irb);\r\nif (!sense)\r\nreturn;\r\nif ((sense[27] & DASD_SENSE_BIT_0) && (sense[7] == 0x0D) &&\r\n(scsw_dstat(&irb->scsw) & DEV_STAT_UNIT_CHECK)) {\r\ndasd_alias_handle_summary_unit_check(device, irb);\r\nreturn;\r\n}\r\nif (!cqr && !(sense[27] & DASD_SENSE_BIT_0) &&\r\n((sense[6] & DASD_SIM_SENSE) == DASD_SIM_SENSE)) {\r\ndasd_3990_erp_handle_sim(device, sense);\r\nreturn;\r\n}\r\nif (device->block && (sense[27] & DASD_SENSE_BIT_0) &&\r\n(sense[7] == 0x3F) &&\r\n(scsw_dstat(&irb->scsw) & DEV_STAT_UNIT_CHECK) &&\r\ntest_bit(DASD_FLAG_IS_RESERVED, &device->flags)) {\r\nif (device->features & DASD_FEATURE_FAILONSLCK)\r\nset_bit(DASD_FLAG_LOCK_STOLEN, &device->flags);\r\nclear_bit(DASD_FLAG_IS_RESERVED, &device->flags);\r\ndev_err(&device->cdev->dev,\r\n"The device reservation was lost\n");\r\n}\r\n}\r\nstatic struct dasd_ccw_req *dasd_eckd_build_cp_cmd_single(\r\nstruct dasd_device *startdev,\r\nstruct dasd_block *block,\r\nstruct request *req,\r\nsector_t first_rec,\r\nsector_t last_rec,\r\nsector_t first_trk,\r\nsector_t last_trk,\r\nunsigned int first_offs,\r\nunsigned int last_offs,\r\nunsigned int blk_per_trk,\r\nunsigned int blksize)\r\n{\r\nstruct dasd_eckd_private *private;\r\nunsigned long *idaws;\r\nstruct LO_eckd_data *LO_data;\r\nstruct dasd_ccw_req *cqr;\r\nstruct ccw1 *ccw;\r\nstruct req_iterator iter;\r\nstruct bio_vec bv;\r\nchar *dst;\r\nunsigned int off;\r\nint count, cidaw, cplength, datasize;\r\nsector_t recid;\r\nunsigned char cmd, rcmd;\r\nint use_prefix;\r\nstruct dasd_device *basedev;\r\nbasedev = block->base;\r\nprivate = (struct dasd_eckd_private *) basedev->private;\r\nif (rq_data_dir(req) == READ)\r\ncmd = DASD_ECKD_CCW_READ_MT;\r\nelse if (rq_data_dir(req) == WRITE)\r\ncmd = DASD_ECKD_CCW_WRITE_MT;\r\nelse\r\nreturn ERR_PTR(-EINVAL);\r\ncount = 0;\r\ncidaw = 0;\r\nrq_for_each_segment(bv, req, iter) {\r\nif (bv.bv_len & (blksize - 1))\r\nreturn ERR_PTR(-EINVAL);\r\ncount += bv.bv_len >> (block->s2b_shift + 9);\r\n#if defined(CONFIG_64BIT)\r\nif (idal_is_needed (page_address(bv.bv_page), bv.bv_len))\r\ncidaw += bv.bv_len >> (block->s2b_shift + 9);\r\n#endif\r\n}\r\nif (count != last_rec - first_rec + 1)\r\nreturn ERR_PTR(-EINVAL);\r\nuse_prefix = private->features.feature[8] & 0x01;\r\nif (use_prefix) {\r\ncplength = 2 + count;\r\ndatasize = sizeof(struct PFX_eckd_data) +\r\nsizeof(struct LO_eckd_data) +\r\ncidaw * sizeof(unsigned long);\r\n} else {\r\ncplength = 2 + count;\r\ndatasize = sizeof(struct DE_eckd_data) +\r\nsizeof(struct LO_eckd_data) +\r\ncidaw * sizeof(unsigned long);\r\n}\r\nif (private->uses_cdl && first_rec < 2*blk_per_trk) {\r\nif (last_rec >= 2*blk_per_trk)\r\ncount = 2*blk_per_trk - first_rec;\r\ncplength += count;\r\ndatasize += count*sizeof(struct LO_eckd_data);\r\n}\r\ncqr = dasd_smalloc_request(DASD_ECKD_MAGIC, cplength, datasize,\r\nstartdev);\r\nif (IS_ERR(cqr))\r\nreturn cqr;\r\nccw = cqr->cpaddr;\r\nif (use_prefix) {\r\nif (prefix(ccw++, cqr->data, first_trk,\r\nlast_trk, cmd, basedev, startdev) == -EAGAIN) {\r\ndasd_sfree_request(cqr, startdev);\r\nreturn ERR_PTR(-EAGAIN);\r\n}\r\nidaws = (unsigned long *) (cqr->data +\r\nsizeof(struct PFX_eckd_data));\r\n} else {\r\nif (define_extent(ccw++, cqr->data, first_trk,\r\nlast_trk, cmd, basedev) == -EAGAIN) {\r\ndasd_sfree_request(cqr, startdev);\r\nreturn ERR_PTR(-EAGAIN);\r\n}\r\nidaws = (unsigned long *) (cqr->data +\r\nsizeof(struct DE_eckd_data));\r\n}\r\nLO_data = (struct LO_eckd_data *) (idaws + cidaw);\r\nrecid = first_rec;\r\nif (private->uses_cdl == 0 || recid > 2*blk_per_trk) {\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nlocate_record(ccw++, LO_data++, first_trk, first_offs + 1,\r\nlast_rec - recid + 1, cmd, basedev, blksize);\r\n}\r\nrq_for_each_segment(bv, req, iter) {\r\ndst = page_address(bv.bv_page) + bv.bv_offset;\r\nif (dasd_page_cache) {\r\nchar *copy = kmem_cache_alloc(dasd_page_cache,\r\nGFP_DMA | __GFP_NOWARN);\r\nif (copy && rq_data_dir(req) == WRITE)\r\nmemcpy(copy + bv.bv_offset, dst, bv.bv_len);\r\nif (copy)\r\ndst = copy + bv.bv_offset;\r\n}\r\nfor (off = 0; off < bv.bv_len; off += blksize) {\r\nsector_t trkid = recid;\r\nunsigned int recoffs = sector_div(trkid, blk_per_trk);\r\nrcmd = cmd;\r\ncount = blksize;\r\nif (private->uses_cdl && recid < 2*blk_per_trk) {\r\nif (dasd_eckd_cdl_special(blk_per_trk, recid)){\r\nrcmd |= 0x8;\r\ncount = dasd_eckd_cdl_reclen(recid);\r\nif (count < blksize &&\r\nrq_data_dir(req) == READ)\r\nmemset(dst + count, 0xe5,\r\nblksize - count);\r\n}\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nlocate_record(ccw++, LO_data++,\r\ntrkid, recoffs + 1,\r\n1, rcmd, basedev, count);\r\n}\r\nif (private->uses_cdl && recid == 2*blk_per_trk) {\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nlocate_record(ccw++, LO_data++,\r\ntrkid, recoffs + 1,\r\nlast_rec - recid + 1,\r\ncmd, basedev, count);\r\n}\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nccw->cmd_code = rcmd;\r\nccw->count = count;\r\nif (idal_is_needed(dst, blksize)) {\r\nccw->cda = (__u32)(addr_t) idaws;\r\nccw->flags = CCW_FLAG_IDA;\r\nidaws = idal_create_words(idaws, dst, blksize);\r\n} else {\r\nccw->cda = (__u32)(addr_t) dst;\r\nccw->flags = 0;\r\n}\r\nccw++;\r\ndst += blksize;\r\nrecid++;\r\n}\r\n}\r\nif (blk_noretry_request(req) ||\r\nblock->base->features & DASD_FEATURE_FAILFAST)\r\nset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\r\ncqr->startdev = startdev;\r\ncqr->memdev = startdev;\r\ncqr->block = block;\r\ncqr->expires = startdev->default_expires * HZ;\r\ncqr->lpm = startdev->path_data.ppm;\r\ncqr->retries = startdev->default_retries;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nreturn cqr;\r\n}\r\nstatic struct dasd_ccw_req *dasd_eckd_build_cp_cmd_track(\r\nstruct dasd_device *startdev,\r\nstruct dasd_block *block,\r\nstruct request *req,\r\nsector_t first_rec,\r\nsector_t last_rec,\r\nsector_t first_trk,\r\nsector_t last_trk,\r\nunsigned int first_offs,\r\nunsigned int last_offs,\r\nunsigned int blk_per_trk,\r\nunsigned int blksize)\r\n{\r\nunsigned long *idaws;\r\nstruct dasd_ccw_req *cqr;\r\nstruct ccw1 *ccw;\r\nstruct req_iterator iter;\r\nstruct bio_vec bv;\r\nchar *dst, *idaw_dst;\r\nunsigned int cidaw, cplength, datasize;\r\nunsigned int tlf;\r\nsector_t recid;\r\nunsigned char cmd;\r\nstruct dasd_device *basedev;\r\nunsigned int trkcount, count, count_to_trk_end;\r\nunsigned int idaw_len, seg_len, part_len, len_to_track_end;\r\nunsigned char new_track, end_idaw;\r\nsector_t trkid;\r\nunsigned int recoffs;\r\nbasedev = block->base;\r\nif (rq_data_dir(req) == READ)\r\ncmd = DASD_ECKD_CCW_READ_TRACK_DATA;\r\nelse if (rq_data_dir(req) == WRITE)\r\ncmd = DASD_ECKD_CCW_WRITE_TRACK_DATA;\r\nelse\r\nreturn ERR_PTR(-EINVAL);\r\ncidaw = last_rec - first_rec + 1;\r\ntrkcount = last_trk - first_trk + 1;\r\ncplength = 1 + trkcount;\r\ndatasize = sizeof(struct PFX_eckd_data) +\r\ncidaw * sizeof(unsigned long long);\r\ncqr = dasd_smalloc_request(DASD_ECKD_MAGIC, cplength, datasize,\r\nstartdev);\r\nif (IS_ERR(cqr))\r\nreturn cqr;\r\nccw = cqr->cpaddr;\r\nif (first_trk == last_trk)\r\ntlf = last_offs - first_offs + 1;\r\nelse\r\ntlf = last_offs + 1;\r\ntlf *= blksize;\r\nif (prefix_LRE(ccw++, cqr->data, first_trk,\r\nlast_trk, cmd, basedev, startdev,\r\n1 , first_offs + 1,\r\ntrkcount, blksize,\r\ntlf) == -EAGAIN) {\r\ndasd_sfree_request(cqr, startdev);\r\nreturn ERR_PTR(-EAGAIN);\r\n}\r\nidaws = (unsigned long *) (cqr->data + sizeof(struct PFX_eckd_data));\r\nrecid = first_rec;\r\nnew_track = 1;\r\nend_idaw = 0;\r\nlen_to_track_end = 0;\r\nidaw_dst = NULL;\r\nidaw_len = 0;\r\nrq_for_each_segment(bv, req, iter) {\r\ndst = page_address(bv.bv_page) + bv.bv_offset;\r\nseg_len = bv.bv_len;\r\nwhile (seg_len) {\r\nif (new_track) {\r\ntrkid = recid;\r\nrecoffs = sector_div(trkid, blk_per_trk);\r\ncount_to_trk_end = blk_per_trk - recoffs;\r\ncount = min((last_rec - recid + 1),\r\n(sector_t)count_to_trk_end);\r\nlen_to_track_end = count * blksize;\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nccw->cmd_code = cmd;\r\nccw->count = len_to_track_end;\r\nccw->cda = (__u32)(addr_t)idaws;\r\nccw->flags = CCW_FLAG_IDA;\r\nccw++;\r\nrecid += count;\r\nnew_track = 0;\r\nif (!idaw_dst)\r\nidaw_dst = dst;\r\n}\r\nif (!idaw_dst) {\r\nif (__pa(dst) & (IDA_BLOCK_SIZE-1)) {\r\ndasd_sfree_request(cqr, startdev);\r\nreturn ERR_PTR(-ERANGE);\r\n} else\r\nidaw_dst = dst;\r\n}\r\nif ((idaw_dst + idaw_len) != dst) {\r\ndasd_sfree_request(cqr, startdev);\r\nreturn ERR_PTR(-ERANGE);\r\n}\r\npart_len = min(seg_len, len_to_track_end);\r\nseg_len -= part_len;\r\ndst += part_len;\r\nidaw_len += part_len;\r\nlen_to_track_end -= part_len;\r\nif (!(__pa(idaw_dst + idaw_len) & (IDA_BLOCK_SIZE-1)))\r\nend_idaw = 1;\r\nif (!len_to_track_end) {\r\nnew_track = 1;\r\nend_idaw = 1;\r\n}\r\nif (end_idaw) {\r\nidaws = idal_create_words(idaws, idaw_dst,\r\nidaw_len);\r\nidaw_dst = NULL;\r\nidaw_len = 0;\r\nend_idaw = 0;\r\n}\r\n}\r\n}\r\nif (blk_noretry_request(req) ||\r\nblock->base->features & DASD_FEATURE_FAILFAST)\r\nset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\r\ncqr->startdev = startdev;\r\ncqr->memdev = startdev;\r\ncqr->block = block;\r\ncqr->expires = startdev->default_expires * HZ;\r\ncqr->lpm = startdev->path_data.ppm;\r\ncqr->retries = startdev->default_retries;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nreturn cqr;\r\n}\r\nstatic int prepare_itcw(struct itcw *itcw,\r\nunsigned int trk, unsigned int totrk, int cmd,\r\nstruct dasd_device *basedev,\r\nstruct dasd_device *startdev,\r\nunsigned int rec_on_trk, int count,\r\nunsigned int blksize,\r\nunsigned int total_data_size,\r\nunsigned int tlf,\r\nunsigned int blk_per_trk)\r\n{\r\nstruct PFX_eckd_data pfxdata;\r\nstruct dasd_eckd_private *basepriv, *startpriv;\r\nstruct DE_eckd_data *dedata;\r\nstruct LRE_eckd_data *lredata;\r\nstruct dcw *dcw;\r\nu32 begcyl, endcyl;\r\nu16 heads, beghead, endhead;\r\nu8 pfx_cmd;\r\nint rc = 0;\r\nint sector = 0;\r\nint dn, d;\r\nbasepriv = (struct dasd_eckd_private *) basedev->private;\r\nstartpriv = (struct dasd_eckd_private *) startdev->private;\r\ndedata = &pfxdata.define_extent;\r\nlredata = &pfxdata.locate_record;\r\nmemset(&pfxdata, 0, sizeof(pfxdata));\r\npfxdata.format = 1;\r\npfxdata.base_address = basepriv->ned->unit_addr;\r\npfxdata.base_lss = basepriv->ned->ID;\r\npfxdata.validity.define_extent = 1;\r\nif (startpriv->uid.type != UA_BASE_DEVICE) {\r\npfxdata.validity.verify_base = 1;\r\nif (startpriv->uid.type == UA_HYPER_PAV_ALIAS)\r\npfxdata.validity.hyper_pav = 1;\r\n}\r\nswitch (cmd) {\r\ncase DASD_ECKD_CCW_READ_TRACK_DATA:\r\ndedata->mask.perm = 0x1;\r\ndedata->attributes.operation = basepriv->attrib.operation;\r\ndedata->blk_size = blksize;\r\ndedata->ga_extended |= 0x42;\r\nlredata->operation.orientation = 0x0;\r\nlredata->operation.operation = 0x0C;\r\nlredata->auxiliary.check_bytes = 0x01;\r\npfx_cmd = DASD_ECKD_CCW_PFX_READ;\r\nbreak;\r\ncase DASD_ECKD_CCW_WRITE_TRACK_DATA:\r\ndedata->mask.perm = 0x02;\r\ndedata->attributes.operation = basepriv->attrib.operation;\r\ndedata->blk_size = blksize;\r\nrc = check_XRC_on_prefix(&pfxdata, basedev);\r\ndedata->ga_extended |= 0x42;\r\nlredata->operation.orientation = 0x0;\r\nlredata->operation.operation = 0x3F;\r\nlredata->extended_operation = 0x23;\r\nlredata->auxiliary.check_bytes = 0x2;\r\npfx_cmd = DASD_ECKD_CCW_PFX;\r\nbreak;\r\ndefault:\r\nDBF_DEV_EVENT(DBF_ERR, basedev,\r\n"prepare itcw, unknown opcode 0x%x", cmd);\r\nBUG();\r\nbreak;\r\n}\r\nif (rc)\r\nreturn rc;\r\ndedata->attributes.mode = 0x3;\r\nheads = basepriv->rdc_data.trk_per_cyl;\r\nbegcyl = trk / heads;\r\nbeghead = trk % heads;\r\nendcyl = totrk / heads;\r\nendhead = totrk % heads;\r\nif (dedata->attributes.operation == DASD_SEQ_PRESTAGE ||\r\ndedata->attributes.operation == DASD_SEQ_ACCESS) {\r\nif (endcyl + basepriv->attrib.nr_cyl < basepriv->real_cyl)\r\nendcyl += basepriv->attrib.nr_cyl;\r\nelse\r\nendcyl = (basepriv->real_cyl - 1);\r\n}\r\nset_ch_t(&dedata->beg_ext, begcyl, beghead);\r\nset_ch_t(&dedata->end_ext, endcyl, endhead);\r\ndedata->ep_format = 0x20;\r\ndedata->ep_rec_per_track = blk_per_trk;\r\nif (rec_on_trk) {\r\nswitch (basepriv->rdc_data.dev_type) {\r\ncase 0x3390:\r\ndn = ceil_quot(blksize + 6, 232);\r\nd = 9 + ceil_quot(blksize + 6 * (dn + 1), 34);\r\nsector = (49 + (rec_on_trk - 1) * (10 + d)) / 8;\r\nbreak;\r\ncase 0x3380:\r\nd = 7 + ceil_quot(blksize + 12, 32);\r\nsector = (39 + (rec_on_trk - 1) * (8 + d)) / 7;\r\nbreak;\r\n}\r\n}\r\nlredata->auxiliary.length_valid = 1;\r\nlredata->auxiliary.length_scope = 1;\r\nlredata->auxiliary.imbedded_ccw_valid = 1;\r\nlredata->length = tlf;\r\nlredata->imbedded_ccw = cmd;\r\nlredata->count = count;\r\nlredata->sector = sector;\r\nset_ch_t(&lredata->seek_addr, begcyl, beghead);\r\nlredata->search_arg.cyl = lredata->seek_addr.cyl;\r\nlredata->search_arg.head = lredata->seek_addr.head;\r\nlredata->search_arg.record = rec_on_trk;\r\ndcw = itcw_add_dcw(itcw, pfx_cmd, 0,\r\n&pfxdata, sizeof(pfxdata), total_data_size);\r\nreturn PTR_RET(dcw);\r\n}\r\nstatic struct dasd_ccw_req *dasd_eckd_build_cp_tpm_track(\r\nstruct dasd_device *startdev,\r\nstruct dasd_block *block,\r\nstruct request *req,\r\nsector_t first_rec,\r\nsector_t last_rec,\r\nsector_t first_trk,\r\nsector_t last_trk,\r\nunsigned int first_offs,\r\nunsigned int last_offs,\r\nunsigned int blk_per_trk,\r\nunsigned int blksize)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nstruct req_iterator iter;\r\nstruct bio_vec bv;\r\nchar *dst;\r\nunsigned int trkcount, ctidaw;\r\nunsigned char cmd;\r\nstruct dasd_device *basedev;\r\nunsigned int tlf;\r\nstruct itcw *itcw;\r\nstruct tidaw *last_tidaw = NULL;\r\nint itcw_op;\r\nsize_t itcw_size;\r\nu8 tidaw_flags;\r\nunsigned int seg_len, part_len, len_to_track_end;\r\nunsigned char new_track;\r\nsector_t recid, trkid;\r\nunsigned int offs;\r\nunsigned int count, count_to_trk_end;\r\nint ret;\r\nbasedev = block->base;\r\nif (rq_data_dir(req) == READ) {\r\ncmd = DASD_ECKD_CCW_READ_TRACK_DATA;\r\nitcw_op = ITCW_OP_READ;\r\n} else if (rq_data_dir(req) == WRITE) {\r\ncmd = DASD_ECKD_CCW_WRITE_TRACK_DATA;\r\nitcw_op = ITCW_OP_WRITE;\r\n} else\r\nreturn ERR_PTR(-EINVAL);\r\ntrkcount = last_trk - first_trk + 1;\r\nctidaw = 0;\r\nrq_for_each_segment(bv, req, iter) {\r\n++ctidaw;\r\n}\r\nif (rq_data_dir(req) == WRITE)\r\nctidaw += (last_trk - first_trk);\r\nitcw_size = itcw_calc_size(0, ctidaw, 0);\r\ncqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 0, itcw_size, startdev);\r\nif (IS_ERR(cqr))\r\nreturn cqr;\r\nif (first_trk == last_trk)\r\ntlf = last_offs - first_offs + 1;\r\nelse\r\ntlf = last_offs + 1;\r\ntlf *= blksize;\r\nitcw = itcw_init(cqr->data, itcw_size, itcw_op, 0, ctidaw, 0);\r\nif (IS_ERR(itcw)) {\r\nret = -EINVAL;\r\ngoto out_error;\r\n}\r\ncqr->cpaddr = itcw_get_tcw(itcw);\r\nif (prepare_itcw(itcw, first_trk, last_trk,\r\ncmd, basedev, startdev,\r\nfirst_offs + 1,\r\ntrkcount, blksize,\r\n(last_rec - first_rec + 1) * blksize,\r\ntlf, blk_per_trk) == -EAGAIN) {\r\nret = -EAGAIN;\r\ngoto out_error;\r\n}\r\nlen_to_track_end = 0;\r\nif (rq_data_dir(req) == WRITE) {\r\nnew_track = 1;\r\nrecid = first_rec;\r\nrq_for_each_segment(bv, req, iter) {\r\ndst = page_address(bv.bv_page) + bv.bv_offset;\r\nseg_len = bv.bv_len;\r\nwhile (seg_len) {\r\nif (new_track) {\r\ntrkid = recid;\r\noffs = sector_div(trkid, blk_per_trk);\r\ncount_to_trk_end = blk_per_trk - offs;\r\ncount = min((last_rec - recid + 1),\r\n(sector_t)count_to_trk_end);\r\nlen_to_track_end = count * blksize;\r\nrecid += count;\r\nnew_track = 0;\r\n}\r\npart_len = min(seg_len, len_to_track_end);\r\nseg_len -= part_len;\r\nlen_to_track_end -= part_len;\r\nif (!len_to_track_end) {\r\nnew_track = 1;\r\ntidaw_flags = TIDAW_FLAGS_INSERT_CBC;\r\n} else\r\ntidaw_flags = 0;\r\nlast_tidaw = itcw_add_tidaw(itcw, tidaw_flags,\r\ndst, part_len);\r\nif (IS_ERR(last_tidaw)) {\r\nret = -EINVAL;\r\ngoto out_error;\r\n}\r\ndst += part_len;\r\n}\r\n}\r\n} else {\r\nrq_for_each_segment(bv, req, iter) {\r\ndst = page_address(bv.bv_page) + bv.bv_offset;\r\nlast_tidaw = itcw_add_tidaw(itcw, 0x00,\r\ndst, bv.bv_len);\r\nif (IS_ERR(last_tidaw)) {\r\nret = -EINVAL;\r\ngoto out_error;\r\n}\r\n}\r\n}\r\nlast_tidaw->flags |= TIDAW_FLAGS_LAST;\r\nlast_tidaw->flags &= ~TIDAW_FLAGS_INSERT_CBC;\r\nitcw_finalize(itcw);\r\nif (blk_noretry_request(req) ||\r\nblock->base->features & DASD_FEATURE_FAILFAST)\r\nset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\r\ncqr->cpmode = 1;\r\ncqr->startdev = startdev;\r\ncqr->memdev = startdev;\r\ncqr->block = block;\r\ncqr->expires = startdev->default_expires * HZ;\r\ncqr->lpm = startdev->path_data.ppm;\r\ncqr->retries = startdev->default_retries;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nreturn cqr;\r\nout_error:\r\ndasd_sfree_request(cqr, startdev);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic struct dasd_ccw_req *dasd_eckd_build_cp(struct dasd_device *startdev,\r\nstruct dasd_block *block,\r\nstruct request *req)\r\n{\r\nint cmdrtd, cmdwtd;\r\nint use_prefix;\r\nint fcx_multitrack;\r\nstruct dasd_eckd_private *private;\r\nstruct dasd_device *basedev;\r\nsector_t first_rec, last_rec;\r\nsector_t first_trk, last_trk;\r\nunsigned int first_offs, last_offs;\r\nunsigned int blk_per_trk, blksize;\r\nint cdlspecial;\r\nunsigned int data_size;\r\nstruct dasd_ccw_req *cqr;\r\nbasedev = block->base;\r\nprivate = (struct dasd_eckd_private *) basedev->private;\r\nblksize = block->bp_block;\r\nblk_per_trk = recs_per_track(&private->rdc_data, 0, blksize);\r\nif (blk_per_trk == 0)\r\nreturn ERR_PTR(-EINVAL);\r\nfirst_rec = first_trk = blk_rq_pos(req) >> block->s2b_shift;\r\nfirst_offs = sector_div(first_trk, blk_per_trk);\r\nlast_rec = last_trk =\r\n(blk_rq_pos(req) + blk_rq_sectors(req) - 1) >> block->s2b_shift;\r\nlast_offs = sector_div(last_trk, blk_per_trk);\r\ncdlspecial = (private->uses_cdl && first_rec < 2*blk_per_trk);\r\nfcx_multitrack = private->features.feature[40] & 0x20;\r\ndata_size = blk_rq_bytes(req);\r\nif (data_size % blksize)\r\nreturn ERR_PTR(-EINVAL);\r\nif (rq_data_dir(req) == WRITE)\r\ndata_size += (last_trk - first_trk) * 4;\r\ncmdrtd = private->features.feature[9] & 0x20;\r\ncmdwtd = private->features.feature[12] & 0x40;\r\nuse_prefix = private->features.feature[8] & 0x01;\r\ncqr = NULL;\r\nif (cdlspecial || dasd_page_cache) {\r\n} else if ((data_size <= private->fcx_max_data)\r\n&& (fcx_multitrack || (first_trk == last_trk))) {\r\ncqr = dasd_eckd_build_cp_tpm_track(startdev, block, req,\r\nfirst_rec, last_rec,\r\nfirst_trk, last_trk,\r\nfirst_offs, last_offs,\r\nblk_per_trk, blksize);\r\nif (IS_ERR(cqr) && (PTR_ERR(cqr) != -EAGAIN) &&\r\n(PTR_ERR(cqr) != -ENOMEM))\r\ncqr = NULL;\r\n} else if (use_prefix &&\r\n(((rq_data_dir(req) == READ) && cmdrtd) ||\r\n((rq_data_dir(req) == WRITE) && cmdwtd))) {\r\ncqr = dasd_eckd_build_cp_cmd_track(startdev, block, req,\r\nfirst_rec, last_rec,\r\nfirst_trk, last_trk,\r\nfirst_offs, last_offs,\r\nblk_per_trk, blksize);\r\nif (IS_ERR(cqr) && (PTR_ERR(cqr) != -EAGAIN) &&\r\n(PTR_ERR(cqr) != -ENOMEM))\r\ncqr = NULL;\r\n}\r\nif (!cqr)\r\ncqr = dasd_eckd_build_cp_cmd_single(startdev, block, req,\r\nfirst_rec, last_rec,\r\nfirst_trk, last_trk,\r\nfirst_offs, last_offs,\r\nblk_per_trk, blksize);\r\nreturn cqr;\r\n}\r\nstatic struct dasd_ccw_req *dasd_raw_build_cp(struct dasd_device *startdev,\r\nstruct dasd_block *block,\r\nstruct request *req)\r\n{\r\nunsigned long *idaws;\r\nstruct dasd_device *basedev;\r\nstruct dasd_ccw_req *cqr;\r\nstruct ccw1 *ccw;\r\nstruct req_iterator iter;\r\nstruct bio_vec bv;\r\nchar *dst;\r\nunsigned char cmd;\r\nunsigned int trkcount;\r\nunsigned int seg_len, len_to_track_end;\r\nunsigned int first_offs;\r\nunsigned int cidaw, cplength, datasize;\r\nsector_t first_trk, last_trk, sectors;\r\nsector_t start_padding_sectors, end_sector_offset, end_padding_sectors;\r\nunsigned int pfx_datasize;\r\nstart_padding_sectors = blk_rq_pos(req) % DASD_RAW_SECTORS_PER_TRACK;\r\nend_sector_offset = (blk_rq_pos(req) + blk_rq_sectors(req)) %\r\nDASD_RAW_SECTORS_PER_TRACK;\r\nend_padding_sectors = (DASD_RAW_SECTORS_PER_TRACK - end_sector_offset) %\r\nDASD_RAW_SECTORS_PER_TRACK;\r\nbasedev = block->base;\r\nif ((start_padding_sectors || end_padding_sectors) &&\r\n(rq_data_dir(req) == WRITE)) {\r\nDBF_DEV_EVENT(DBF_ERR, basedev,\r\n"raw write not track aligned (%lu,%lu) req %p",\r\nstart_padding_sectors, end_padding_sectors, req);\r\ncqr = ERR_PTR(-EINVAL);\r\ngoto out;\r\n}\r\nfirst_trk = blk_rq_pos(req) / DASD_RAW_SECTORS_PER_TRACK;\r\nlast_trk = (blk_rq_pos(req) + blk_rq_sectors(req) - 1) /\r\nDASD_RAW_SECTORS_PER_TRACK;\r\ntrkcount = last_trk - first_trk + 1;\r\nfirst_offs = 0;\r\nif (rq_data_dir(req) == READ)\r\ncmd = DASD_ECKD_CCW_READ_TRACK;\r\nelse if (rq_data_dir(req) == WRITE)\r\ncmd = DASD_ECKD_CCW_WRITE_FULL_TRACK;\r\nelse {\r\ncqr = ERR_PTR(-EINVAL);\r\ngoto out;\r\n}\r\ncidaw = trkcount * DASD_RAW_BLOCK_PER_TRACK;\r\ncplength = 1 + trkcount;\r\npfx_datasize = sizeof(struct PFX_eckd_data) + 8;\r\ndatasize = pfx_datasize + cidaw * sizeof(unsigned long long);\r\ncqr = dasd_smalloc_request(DASD_ECKD_MAGIC, cplength,\r\ndatasize, startdev);\r\nif (IS_ERR(cqr))\r\ngoto out;\r\nccw = cqr->cpaddr;\r\nif (prefix_LRE(ccw++, cqr->data, first_trk, last_trk, cmd,\r\nbasedev, startdev, 1 , first_offs + 1,\r\ntrkcount, 0, 0) == -EAGAIN) {\r\ndasd_sfree_request(cqr, startdev);\r\ncqr = ERR_PTR(-EAGAIN);\r\ngoto out;\r\n}\r\nidaws = (unsigned long *)(cqr->data + pfx_datasize);\r\nlen_to_track_end = 0;\r\nif (start_padding_sectors) {\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nccw->cmd_code = cmd;\r\nccw->count = 57326;\r\nlen_to_track_end = 65536 - start_padding_sectors * 512;\r\nccw->cda = (__u32)(addr_t)idaws;\r\nccw->flags |= CCW_FLAG_IDA;\r\nccw->flags |= CCW_FLAG_SLI;\r\nccw++;\r\nfor (sectors = 0; sectors < start_padding_sectors; sectors += 8)\r\nidaws = idal_create_words(idaws, rawpadpage, PAGE_SIZE);\r\n}\r\nrq_for_each_segment(bv, req, iter) {\r\ndst = page_address(bv.bv_page) + bv.bv_offset;\r\nseg_len = bv.bv_len;\r\nif (cmd == DASD_ECKD_CCW_READ_TRACK)\r\nmemset(dst, 0, seg_len);\r\nif (!len_to_track_end) {\r\nccw[-1].flags |= CCW_FLAG_CC;\r\nccw->cmd_code = cmd;\r\nccw->count = 57326;\r\nlen_to_track_end = 65536;\r\nccw->cda = (__u32)(addr_t)idaws;\r\nccw->flags |= CCW_FLAG_IDA;\r\nccw->flags |= CCW_FLAG_SLI;\r\nccw++;\r\n}\r\nlen_to_track_end -= seg_len;\r\nidaws = idal_create_words(idaws, dst, seg_len);\r\n}\r\nfor (sectors = 0; sectors < end_padding_sectors; sectors += 8)\r\nidaws = idal_create_words(idaws, rawpadpage, PAGE_SIZE);\r\nif (blk_noretry_request(req) ||\r\nblock->base->features & DASD_FEATURE_FAILFAST)\r\nset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\r\ncqr->startdev = startdev;\r\ncqr->memdev = startdev;\r\ncqr->block = block;\r\ncqr->expires = startdev->default_expires * HZ;\r\ncqr->lpm = startdev->path_data.ppm;\r\ncqr->retries = startdev->default_retries;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nif (IS_ERR(cqr) && PTR_ERR(cqr) != -EAGAIN)\r\ncqr = NULL;\r\nout:\r\nreturn cqr;\r\n}\r\nstatic int\r\ndasd_eckd_free_cp(struct dasd_ccw_req *cqr, struct request *req)\r\n{\r\nstruct dasd_eckd_private *private;\r\nstruct ccw1 *ccw;\r\nstruct req_iterator iter;\r\nstruct bio_vec bv;\r\nchar *dst, *cda;\r\nunsigned int blksize, blk_per_trk, off;\r\nsector_t recid;\r\nint status;\r\nif (!dasd_page_cache)\r\ngoto out;\r\nprivate = (struct dasd_eckd_private *) cqr->block->base->private;\r\nblksize = cqr->block->bp_block;\r\nblk_per_trk = recs_per_track(&private->rdc_data, 0, blksize);\r\nrecid = blk_rq_pos(req) >> cqr->block->s2b_shift;\r\nccw = cqr->cpaddr;\r\nccw++;\r\nif (private->uses_cdl == 0 || recid > 2*blk_per_trk)\r\nccw++;\r\nrq_for_each_segment(bv, req, iter) {\r\ndst = page_address(bv.bv_page) + bv.bv_offset;\r\nfor (off = 0; off < bv.bv_len; off += blksize) {\r\nif (private->uses_cdl && recid <= 2*blk_per_trk)\r\nccw++;\r\nif (dst) {\r\nif (ccw->flags & CCW_FLAG_IDA)\r\ncda = *((char **)((addr_t) ccw->cda));\r\nelse\r\ncda = (char *)((addr_t) ccw->cda);\r\nif (dst != cda) {\r\nif (rq_data_dir(req) == READ)\r\nmemcpy(dst, cda, bv.bv_len);\r\nkmem_cache_free(dasd_page_cache,\r\n(void *)((addr_t)cda & PAGE_MASK));\r\n}\r\ndst = NULL;\r\n}\r\nccw++;\r\nrecid++;\r\n}\r\n}\r\nout:\r\nstatus = cqr->status == DASD_CQR_DONE;\r\ndasd_sfree_request(cqr, cqr->memdev);\r\nreturn status;\r\n}\r\nvoid dasd_eckd_reset_ccw_to_base_io(struct dasd_ccw_req *cqr)\r\n{\r\nstruct ccw1 *ccw;\r\nstruct PFX_eckd_data *pfxdata;\r\nstruct tcw *tcw;\r\nstruct tccb *tccb;\r\nstruct dcw *dcw;\r\nif (cqr->cpmode == 1) {\r\ntcw = cqr->cpaddr;\r\ntccb = tcw_get_tccb(tcw);\r\ndcw = (struct dcw *)&tccb->tca[0];\r\npfxdata = (struct PFX_eckd_data *)&dcw->cd[0];\r\npfxdata->validity.verify_base = 0;\r\npfxdata->validity.hyper_pav = 0;\r\n} else {\r\nccw = cqr->cpaddr;\r\npfxdata = cqr->data;\r\nif (ccw->cmd_code == DASD_ECKD_CCW_PFX) {\r\npfxdata->validity.verify_base = 0;\r\npfxdata->validity.hyper_pav = 0;\r\n}\r\n}\r\n}\r\nstatic struct dasd_ccw_req *dasd_eckd_build_alias_cp(struct dasd_device *base,\r\nstruct dasd_block *block,\r\nstruct request *req)\r\n{\r\nstruct dasd_eckd_private *private;\r\nstruct dasd_device *startdev;\r\nunsigned long flags;\r\nstruct dasd_ccw_req *cqr;\r\nstartdev = dasd_alias_get_start_dev(base);\r\nif (!startdev)\r\nstartdev = base;\r\nprivate = (struct dasd_eckd_private *) startdev->private;\r\nif (private->count >= DASD_ECKD_CHANQ_MAX_SIZE)\r\nreturn ERR_PTR(-EBUSY);\r\nspin_lock_irqsave(get_ccwdev_lock(startdev->cdev), flags);\r\nprivate->count++;\r\nif ((base->features & DASD_FEATURE_USERAW))\r\ncqr = dasd_raw_build_cp(startdev, block, req);\r\nelse\r\ncqr = dasd_eckd_build_cp(startdev, block, req);\r\nif (IS_ERR(cqr))\r\nprivate->count--;\r\nspin_unlock_irqrestore(get_ccwdev_lock(startdev->cdev), flags);\r\nreturn cqr;\r\n}\r\nstatic int dasd_eckd_free_alias_cp(struct dasd_ccw_req *cqr,\r\nstruct request *req)\r\n{\r\nstruct dasd_eckd_private *private;\r\nunsigned long flags;\r\nspin_lock_irqsave(get_ccwdev_lock(cqr->memdev->cdev), flags);\r\nprivate = (struct dasd_eckd_private *) cqr->memdev->private;\r\nprivate->count--;\r\nspin_unlock_irqrestore(get_ccwdev_lock(cqr->memdev->cdev), flags);\r\nreturn dasd_eckd_free_cp(cqr, req);\r\n}\r\nstatic int\r\ndasd_eckd_fill_info(struct dasd_device * device,\r\nstruct dasd_information2_t * info)\r\n{\r\nstruct dasd_eckd_private *private;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\ninfo->label_block = 2;\r\ninfo->FBA_layout = private->uses_cdl ? 0 : 1;\r\ninfo->format = private->uses_cdl ? DASD_FORMAT_CDL : DASD_FORMAT_LDL;\r\ninfo->characteristics_size = sizeof(struct dasd_eckd_characteristics);\r\nmemcpy(info->characteristics, &private->rdc_data,\r\nsizeof(struct dasd_eckd_characteristics));\r\ninfo->confdata_size = min((unsigned long)private->conf_len,\r\nsizeof(info->configuration_data));\r\nmemcpy(info->configuration_data, private->conf_data,\r\ninfo->confdata_size);\r\nreturn 0;\r\n}\r\nstatic int\r\ndasd_eckd_release(struct dasd_device *device)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nint rc;\r\nstruct ccw1 *ccw;\r\nint useglobal;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nuseglobal = 0;\r\ncqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1, 32, device);\r\nif (IS_ERR(cqr)) {\r\nmutex_lock(&dasd_reserve_mutex);\r\nuseglobal = 1;\r\ncqr = &dasd_reserve_req->cqr;\r\nmemset(cqr, 0, sizeof(*cqr));\r\nmemset(&dasd_reserve_req->ccw, 0,\r\nsizeof(dasd_reserve_req->ccw));\r\ncqr->cpaddr = &dasd_reserve_req->ccw;\r\ncqr->data = &dasd_reserve_req->data;\r\ncqr->magic = DASD_ECKD_MAGIC;\r\n}\r\nccw = cqr->cpaddr;\r\nccw->cmd_code = DASD_ECKD_CCW_RELEASE;\r\nccw->flags |= CCW_FLAG_SLI;\r\nccw->count = 32;\r\nccw->cda = (__u32)(addr_t) cqr->data;\r\ncqr->startdev = device;\r\ncqr->memdev = device;\r\nclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\r\nset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\r\ncqr->retries = 2;\r\ncqr->expires = 2 * HZ;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nrc = dasd_sleep_on_immediatly(cqr);\r\nif (!rc)\r\nclear_bit(DASD_FLAG_IS_RESERVED, &device->flags);\r\nif (useglobal)\r\nmutex_unlock(&dasd_reserve_mutex);\r\nelse\r\ndasd_sfree_request(cqr, cqr->memdev);\r\nreturn rc;\r\n}\r\nstatic int\r\ndasd_eckd_reserve(struct dasd_device *device)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nint rc;\r\nstruct ccw1 *ccw;\r\nint useglobal;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nuseglobal = 0;\r\ncqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1, 32, device);\r\nif (IS_ERR(cqr)) {\r\nmutex_lock(&dasd_reserve_mutex);\r\nuseglobal = 1;\r\ncqr = &dasd_reserve_req->cqr;\r\nmemset(cqr, 0, sizeof(*cqr));\r\nmemset(&dasd_reserve_req->ccw, 0,\r\nsizeof(dasd_reserve_req->ccw));\r\ncqr->cpaddr = &dasd_reserve_req->ccw;\r\ncqr->data = &dasd_reserve_req->data;\r\ncqr->magic = DASD_ECKD_MAGIC;\r\n}\r\nccw = cqr->cpaddr;\r\nccw->cmd_code = DASD_ECKD_CCW_RESERVE;\r\nccw->flags |= CCW_FLAG_SLI;\r\nccw->count = 32;\r\nccw->cda = (__u32)(addr_t) cqr->data;\r\ncqr->startdev = device;\r\ncqr->memdev = device;\r\nclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\r\nset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\r\ncqr->retries = 2;\r\ncqr->expires = 2 * HZ;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nrc = dasd_sleep_on_immediatly(cqr);\r\nif (!rc)\r\nset_bit(DASD_FLAG_IS_RESERVED, &device->flags);\r\nif (useglobal)\r\nmutex_unlock(&dasd_reserve_mutex);\r\nelse\r\ndasd_sfree_request(cqr, cqr->memdev);\r\nreturn rc;\r\n}\r\nstatic int\r\ndasd_eckd_steal_lock(struct dasd_device *device)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nint rc;\r\nstruct ccw1 *ccw;\r\nint useglobal;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nuseglobal = 0;\r\ncqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1, 32, device);\r\nif (IS_ERR(cqr)) {\r\nmutex_lock(&dasd_reserve_mutex);\r\nuseglobal = 1;\r\ncqr = &dasd_reserve_req->cqr;\r\nmemset(cqr, 0, sizeof(*cqr));\r\nmemset(&dasd_reserve_req->ccw, 0,\r\nsizeof(dasd_reserve_req->ccw));\r\ncqr->cpaddr = &dasd_reserve_req->ccw;\r\ncqr->data = &dasd_reserve_req->data;\r\ncqr->magic = DASD_ECKD_MAGIC;\r\n}\r\nccw = cqr->cpaddr;\r\nccw->cmd_code = DASD_ECKD_CCW_SLCK;\r\nccw->flags |= CCW_FLAG_SLI;\r\nccw->count = 32;\r\nccw->cda = (__u32)(addr_t) cqr->data;\r\ncqr->startdev = device;\r\ncqr->memdev = device;\r\nclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\r\nset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\r\ncqr->retries = 2;\r\ncqr->expires = 2 * HZ;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nrc = dasd_sleep_on_immediatly(cqr);\r\nif (!rc)\r\nset_bit(DASD_FLAG_IS_RESERVED, &device->flags);\r\nif (useglobal)\r\nmutex_unlock(&dasd_reserve_mutex);\r\nelse\r\ndasd_sfree_request(cqr, cqr->memdev);\r\nreturn rc;\r\n}\r\nstatic int dasd_eckd_snid(struct dasd_device *device,\r\nvoid __user *argp)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nint rc;\r\nstruct ccw1 *ccw;\r\nint useglobal;\r\nstruct dasd_snid_ioctl_data usrparm;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (copy_from_user(&usrparm, argp, sizeof(usrparm)))\r\nreturn -EFAULT;\r\nuseglobal = 0;\r\ncqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1,\r\nsizeof(struct dasd_snid_data), device);\r\nif (IS_ERR(cqr)) {\r\nmutex_lock(&dasd_reserve_mutex);\r\nuseglobal = 1;\r\ncqr = &dasd_reserve_req->cqr;\r\nmemset(cqr, 0, sizeof(*cqr));\r\nmemset(&dasd_reserve_req->ccw, 0,\r\nsizeof(dasd_reserve_req->ccw));\r\ncqr->cpaddr = &dasd_reserve_req->ccw;\r\ncqr->data = &dasd_reserve_req->data;\r\ncqr->magic = DASD_ECKD_MAGIC;\r\n}\r\nccw = cqr->cpaddr;\r\nccw->cmd_code = DASD_ECKD_CCW_SNID;\r\nccw->flags |= CCW_FLAG_SLI;\r\nccw->count = 12;\r\nccw->cda = (__u32)(addr_t) cqr->data;\r\ncqr->startdev = device;\r\ncqr->memdev = device;\r\nclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\r\nset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\r\nset_bit(DASD_CQR_ALLOW_SLOCK, &cqr->flags);\r\ncqr->retries = 5;\r\ncqr->expires = 10 * HZ;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\ncqr->lpm = usrparm.path_mask;\r\nrc = dasd_sleep_on_immediatly(cqr);\r\nif (!rc && usrparm.path_mask && (cqr->lpm != usrparm.path_mask))\r\nrc = -EIO;\r\nif (!rc) {\r\nusrparm.data = *((struct dasd_snid_data *)cqr->data);\r\nif (copy_to_user(argp, &usrparm, sizeof(usrparm)))\r\nrc = -EFAULT;\r\n}\r\nif (useglobal)\r\nmutex_unlock(&dasd_reserve_mutex);\r\nelse\r\ndasd_sfree_request(cqr, cqr->memdev);\r\nreturn rc;\r\n}\r\nstatic int\r\ndasd_eckd_performance(struct dasd_device *device, void __user *argp)\r\n{\r\nstruct dasd_psf_prssd_data *prssdp;\r\nstruct dasd_rssd_perf_stats_t *stats;\r\nstruct dasd_ccw_req *cqr;\r\nstruct ccw1 *ccw;\r\nint rc;\r\ncqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1 + 1 ,\r\n(sizeof(struct dasd_psf_prssd_data) +\r\nsizeof(struct dasd_rssd_perf_stats_t)),\r\ndevice);\r\nif (IS_ERR(cqr)) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Could not allocate initialization request");\r\nreturn PTR_ERR(cqr);\r\n}\r\ncqr->startdev = device;\r\ncqr->memdev = device;\r\ncqr->retries = 0;\r\nclear_bit(DASD_CQR_FLAGS_USE_ERP, &cqr->flags);\r\ncqr->expires = 10 * HZ;\r\nprssdp = (struct dasd_psf_prssd_data *) cqr->data;\r\nmemset(prssdp, 0, sizeof(struct dasd_psf_prssd_data));\r\nprssdp->order = PSF_ORDER_PRSSD;\r\nprssdp->suborder = 0x01;\r\nprssdp->varies[1] = 0x01;\r\nccw = cqr->cpaddr;\r\nccw->cmd_code = DASD_ECKD_CCW_PSF;\r\nccw->count = sizeof(struct dasd_psf_prssd_data);\r\nccw->flags |= CCW_FLAG_CC;\r\nccw->cda = (__u32)(addr_t) prssdp;\r\nstats = (struct dasd_rssd_perf_stats_t *) (prssdp + 1);\r\nmemset(stats, 0, sizeof(struct dasd_rssd_perf_stats_t));\r\nccw++;\r\nccw->cmd_code = DASD_ECKD_CCW_RSSD;\r\nccw->count = sizeof(struct dasd_rssd_perf_stats_t);\r\nccw->cda = (__u32)(addr_t) stats;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nrc = dasd_sleep_on(cqr);\r\nif (rc == 0) {\r\nprssdp = (struct dasd_psf_prssd_data *) cqr->data;\r\nstats = (struct dasd_rssd_perf_stats_t *) (prssdp + 1);\r\nif (copy_to_user(argp, stats,\r\nsizeof(struct dasd_rssd_perf_stats_t)))\r\nrc = -EFAULT;\r\n}\r\ndasd_sfree_request(cqr, cqr->memdev);\r\nreturn rc;\r\n}\r\nstatic int\r\ndasd_eckd_get_attrib(struct dasd_device *device, void __user *argp)\r\n{\r\nstruct dasd_eckd_private *private =\r\n(struct dasd_eckd_private *)device->private;\r\nstruct attrib_data_t attrib = private->attrib;\r\nint rc;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (!argp)\r\nreturn -EINVAL;\r\nrc = 0;\r\nif (copy_to_user(argp, (long *) &attrib,\r\nsizeof(struct attrib_data_t)))\r\nrc = -EFAULT;\r\nreturn rc;\r\n}\r\nstatic int\r\ndasd_eckd_set_attrib(struct dasd_device *device, void __user *argp)\r\n{\r\nstruct dasd_eckd_private *private =\r\n(struct dasd_eckd_private *)device->private;\r\nstruct attrib_data_t attrib;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nif (!argp)\r\nreturn -EINVAL;\r\nif (copy_from_user(&attrib, argp, sizeof(struct attrib_data_t)))\r\nreturn -EFAULT;\r\nprivate->attrib = attrib;\r\ndev_info(&device->cdev->dev,\r\n"The DASD cache mode was set to %x (%i cylinder prestage)\n",\r\nprivate->attrib.operation, private->attrib.nr_cyl);\r\nreturn 0;\r\n}\r\nstatic int dasd_symm_io(struct dasd_device *device, void __user *argp)\r\n{\r\nstruct dasd_symmio_parms usrparm;\r\nchar *psf_data, *rssd_result;\r\nstruct dasd_ccw_req *cqr;\r\nstruct ccw1 *ccw;\r\nchar psf0, psf1;\r\nint rc;\r\nif (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\npsf0 = psf1 = 0;\r\nrc = -EFAULT;\r\nif (copy_from_user(&usrparm, argp, sizeof(usrparm)))\r\ngoto out;\r\nif (is_compat_task() || sizeof(long) == 4) {\r\nrc = -EINVAL;\r\nif ((usrparm.psf_data >> 32) != 0)\r\ngoto out;\r\nif ((usrparm.rssd_result >> 32) != 0)\r\ngoto out;\r\nusrparm.psf_data &= 0x7fffffffULL;\r\nusrparm.rssd_result &= 0x7fffffffULL;\r\n}\r\npsf_data = kzalloc(usrparm.psf_data_len, GFP_KERNEL | GFP_DMA);\r\nrssd_result = kzalloc(usrparm.rssd_result_len, GFP_KERNEL | GFP_DMA);\r\nif (!psf_data || !rssd_result) {\r\nrc = -ENOMEM;\r\ngoto out_free;\r\n}\r\nrc = -EFAULT;\r\nif (copy_from_user(psf_data,\r\n(void __user *)(unsigned long) usrparm.psf_data,\r\nusrparm.psf_data_len))\r\ngoto out_free;\r\npsf0 = psf_data[0];\r\npsf1 = psf_data[1];\r\ncqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 2 , 0, device);\r\nif (IS_ERR(cqr)) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Could not allocate initialization request");\r\nrc = PTR_ERR(cqr);\r\ngoto out_free;\r\n}\r\ncqr->startdev = device;\r\ncqr->memdev = device;\r\ncqr->retries = 3;\r\ncqr->expires = 10 * HZ;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nccw = cqr->cpaddr;\r\nccw->cmd_code = DASD_ECKD_CCW_PSF;\r\nccw->count = usrparm.psf_data_len;\r\nccw->flags |= CCW_FLAG_CC;\r\nccw->cda = (__u32)(addr_t) psf_data;\r\nccw++;\r\nccw->cmd_code = DASD_ECKD_CCW_RSSD;\r\nccw->count = usrparm.rssd_result_len;\r\nccw->flags = CCW_FLAG_SLI ;\r\nccw->cda = (__u32)(addr_t) rssd_result;\r\nrc = dasd_sleep_on(cqr);\r\nif (rc)\r\ngoto out_sfree;\r\nrc = -EFAULT;\r\nif (copy_to_user((void __user *)(unsigned long) usrparm.rssd_result,\r\nrssd_result, usrparm.rssd_result_len))\r\ngoto out_sfree;\r\nrc = 0;\r\nout_sfree:\r\ndasd_sfree_request(cqr, cqr->memdev);\r\nout_free:\r\nkfree(rssd_result);\r\nkfree(psf_data);\r\nout:\r\nDBF_DEV_EVENT(DBF_WARNING, device,\r\n"Symmetrix ioctl (0x%02x 0x%02x): rc=%d",\r\n(int) psf0, (int) psf1, rc);\r\nreturn rc;\r\n}\r\nstatic int\r\ndasd_eckd_ioctl(struct dasd_block *block, unsigned int cmd, void __user *argp)\r\n{\r\nstruct dasd_device *device = block->base;\r\nswitch (cmd) {\r\ncase BIODASDGATTR:\r\nreturn dasd_eckd_get_attrib(device, argp);\r\ncase BIODASDSATTR:\r\nreturn dasd_eckd_set_attrib(device, argp);\r\ncase BIODASDPSRD:\r\nreturn dasd_eckd_performance(device, argp);\r\ncase BIODASDRLSE:\r\nreturn dasd_eckd_release(device);\r\ncase BIODASDRSRV:\r\nreturn dasd_eckd_reserve(device);\r\ncase BIODASDSLCK:\r\nreturn dasd_eckd_steal_lock(device);\r\ncase BIODASDSNID:\r\nreturn dasd_eckd_snid(device, argp);\r\ncase BIODASDSYMMIO:\r\nreturn dasd_symm_io(device, argp);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int\r\ndasd_eckd_dump_ccw_range(struct ccw1 *from, struct ccw1 *to, char *page)\r\n{\r\nint len, count;\r\nchar *datap;\r\nlen = 0;\r\nwhile (from <= to) {\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" CCW %p: %08X %08X DAT:",\r\nfrom, ((int *) from)[0], ((int *) from)[1]);\r\nif (from->flags & CCW_FLAG_IDA)\r\ndatap = (char *) *((addr_t *) (addr_t) from->cda);\r\nelse\r\ndatap = (char *) ((addr_t) from->cda);\r\nfor (count = 0; count < from->count && count < 32; count++) {\r\nif (count % 8 == 0) len += sprintf(page + len, " ");\r\nif (count % 4 == 0) len += sprintf(page + len, " ");\r\nlen += sprintf(page + len, "%02x", datap[count]);\r\n}\r\nlen += sprintf(page + len, "\n");\r\nfrom++;\r\n}\r\nreturn len;\r\n}\r\nstatic void\r\ndasd_eckd_dump_sense_dbf(struct dasd_device *device, struct irb *irb,\r\nchar *reason)\r\n{\r\nu64 *sense;\r\nu64 *stat;\r\nsense = (u64 *) dasd_get_sense(irb);\r\nstat = (u64 *) &irb->scsw;\r\nif (sense) {\r\nDBF_DEV_EVENT(DBF_EMERG, device, "%s: %016llx %08x : "\r\n"%016llx %016llx %016llx %016llx",\r\nreason, *stat, *((u32 *) (stat + 1)),\r\nsense[0], sense[1], sense[2], sense[3]);\r\n} else {\r\nDBF_DEV_EVENT(DBF_EMERG, device, "%s: %016llx %08x : %s",\r\nreason, *stat, *((u32 *) (stat + 1)),\r\n"NO VALID SENSE");\r\n}\r\n}\r\nstatic void dasd_eckd_dump_sense_ccw(struct dasd_device *device,\r\nstruct dasd_ccw_req *req, struct irb *irb)\r\n{\r\nchar *page;\r\nstruct ccw1 *first, *last, *fail, *from, *to;\r\nint len, sl, sct;\r\npage = (char *) get_zeroed_page(GFP_ATOMIC);\r\nif (page == NULL) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"No memory to dump sense data\n");\r\nreturn;\r\n}\r\nlen = sprintf(page, PRINTK_HEADER\r\n" I/O status report for device %s:\n",\r\ndev_name(&device->cdev->dev));\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" in req: %p CC:%02X FC:%02X AC:%02X SC:%02X DS:%02X "\r\n"CS:%02X RC:%d\n",\r\nreq, scsw_cc(&irb->scsw), scsw_fctl(&irb->scsw),\r\nscsw_actl(&irb->scsw), scsw_stctl(&irb->scsw),\r\nscsw_dstat(&irb->scsw), scsw_cstat(&irb->scsw),\r\nreq ? req->intrc : 0);\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" device %s: Failing CCW: %p\n",\r\ndev_name(&device->cdev->dev),\r\n(void *) (addr_t) irb->scsw.cmd.cpa);\r\nif (irb->esw.esw0.erw.cons) {\r\nfor (sl = 0; sl < 4; sl++) {\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" Sense(hex) %2d-%2d:",\r\n(8 * sl), ((8 * sl) + 7));\r\nfor (sct = 0; sct < 8; sct++) {\r\nlen += sprintf(page + len, " %02x",\r\nirb->ecw[8 * sl + sct]);\r\n}\r\nlen += sprintf(page + len, "\n");\r\n}\r\nif (irb->ecw[27] & DASD_SENSE_BIT_0) {\r\nsprintf(page + len, PRINTK_HEADER\r\n" 24 Byte: %x MSG %x, "\r\n"%s MSGb to SYSOP\n",\r\nirb->ecw[7] >> 4, irb->ecw[7] & 0x0f,\r\nirb->ecw[1] & 0x10 ? "" : "no");\r\n} else {\r\nsprintf(page + len, PRINTK_HEADER\r\n" 32 Byte: Format: %x "\r\n"Exception class %x\n",\r\nirb->ecw[6] & 0x0f, irb->ecw[22] >> 4);\r\n}\r\n} else {\r\nsprintf(page + len, PRINTK_HEADER\r\n" SORRY - NO VALID SENSE AVAILABLE\n");\r\n}\r\nprintk(KERN_ERR "%s", page);\r\nif (req) {\r\nfirst = req->cpaddr;\r\nfor (last = first; last->flags & (CCW_FLAG_CC | CCW_FLAG_DC); last++);\r\nto = min(first + 6, last);\r\nlen = sprintf(page, PRINTK_HEADER\r\n" Related CP in req: %p\n", req);\r\ndasd_eckd_dump_ccw_range(first, to, page + len);\r\nprintk(KERN_ERR "%s", page);\r\nlen = 0;\r\nfrom = ++to;\r\nfail = (struct ccw1 *)(addr_t)\r\nirb->scsw.cmd.cpa;\r\nif (from < fail - 2) {\r\nfrom = fail - 2;\r\nlen += sprintf(page, PRINTK_HEADER "......\n");\r\n}\r\nto = min(fail + 1, last);\r\nlen += dasd_eckd_dump_ccw_range(from, to, page + len);\r\nfrom = max(from, ++to);\r\nif (from < last - 1) {\r\nfrom = last - 1;\r\nlen += sprintf(page + len, PRINTK_HEADER "......\n");\r\n}\r\nlen += dasd_eckd_dump_ccw_range(from, last, page + len);\r\nif (len > 0)\r\nprintk(KERN_ERR "%s", page);\r\n}\r\nfree_page((unsigned long) page);\r\n}\r\nstatic void dasd_eckd_dump_sense_tcw(struct dasd_device *device,\r\nstruct dasd_ccw_req *req, struct irb *irb)\r\n{\r\nchar *page;\r\nint len, sl, sct, residual;\r\nstruct tsb *tsb;\r\nu8 *sense, *rcq;\r\npage = (char *) get_zeroed_page(GFP_ATOMIC);\r\nif (page == NULL) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, " %s",\r\n"No memory to dump sense data");\r\nreturn;\r\n}\r\nlen = sprintf(page, PRINTK_HEADER\r\n" I/O status report for device %s:\n",\r\ndev_name(&device->cdev->dev));\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" in req: %p CC:%02X FC:%02X AC:%02X SC:%02X DS:%02X "\r\n"CS:%02X fcxs:%02X schxs:%02X RC:%d\n",\r\nreq, scsw_cc(&irb->scsw), scsw_fctl(&irb->scsw),\r\nscsw_actl(&irb->scsw), scsw_stctl(&irb->scsw),\r\nscsw_dstat(&irb->scsw), scsw_cstat(&irb->scsw),\r\nirb->scsw.tm.fcxs, irb->scsw.tm.schxs,\r\nreq ? req->intrc : 0);\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" device %s: Failing TCW: %p\n",\r\ndev_name(&device->cdev->dev),\r\n(void *) (addr_t) irb->scsw.tm.tcw);\r\ntsb = NULL;\r\nsense = NULL;\r\nif (irb->scsw.tm.tcw && (irb->scsw.tm.fcxs & 0x01))\r\ntsb = tcw_get_tsb(\r\n(struct tcw *)(unsigned long)irb->scsw.tm.tcw);\r\nif (tsb) {\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" tsb->length %d\n", tsb->length);\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" tsb->flags %x\n", tsb->flags);\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" tsb->dcw_offset %d\n", tsb->dcw_offset);\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" tsb->count %d\n", tsb->count);\r\nresidual = tsb->count - 28;\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" residual %d\n", residual);\r\nswitch (tsb->flags & 0x07) {\r\ncase 1:\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" tsb->tsa.iostat.dev_time %d\n",\r\ntsb->tsa.iostat.dev_time);\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" tsb->tsa.iostat.def_time %d\n",\r\ntsb->tsa.iostat.def_time);\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" tsb->tsa.iostat.queue_time %d\n",\r\ntsb->tsa.iostat.queue_time);\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" tsb->tsa.iostat.dev_busy_time %d\n",\r\ntsb->tsa.iostat.dev_busy_time);\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" tsb->tsa.iostat.dev_act_time %d\n",\r\ntsb->tsa.iostat.dev_act_time);\r\nsense = tsb->tsa.iostat.sense;\r\nbreak;\r\ncase 2:\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" tsb->tsa.ddpc.rc %d\n", tsb->tsa.ddpc.rc);\r\nfor (sl = 0; sl < 2; sl++) {\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" tsb->tsa.ddpc.rcq %2d-%2d: ",\r\n(8 * sl), ((8 * sl) + 7));\r\nrcq = tsb->tsa.ddpc.rcq;\r\nfor (sct = 0; sct < 8; sct++) {\r\nlen += sprintf(page + len, " %02x",\r\nrcq[8 * sl + sct]);\r\n}\r\nlen += sprintf(page + len, "\n");\r\n}\r\nsense = tsb->tsa.ddpc.sense;\r\nbreak;\r\ncase 3:\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" tsb->tsa.intrg.: not supportet yet\n");\r\nbreak;\r\n}\r\nif (sense) {\r\nfor (sl = 0; sl < 4; sl++) {\r\nlen += sprintf(page + len, PRINTK_HEADER\r\n" Sense(hex) %2d-%2d:",\r\n(8 * sl), ((8 * sl) + 7));\r\nfor (sct = 0; sct < 8; sct++) {\r\nlen += sprintf(page + len, " %02x",\r\nsense[8 * sl + sct]);\r\n}\r\nlen += sprintf(page + len, "\n");\r\n}\r\nif (sense[27] & DASD_SENSE_BIT_0) {\r\nsprintf(page + len, PRINTK_HEADER\r\n" 24 Byte: %x MSG %x, "\r\n"%s MSGb to SYSOP\n",\r\nsense[7] >> 4, sense[7] & 0x0f,\r\nsense[1] & 0x10 ? "" : "no");\r\n} else {\r\nsprintf(page + len, PRINTK_HEADER\r\n" 32 Byte: Format: %x "\r\n"Exception class %x\n",\r\nsense[6] & 0x0f, sense[22] >> 4);\r\n}\r\n} else {\r\nsprintf(page + len, PRINTK_HEADER\r\n" SORRY - NO VALID SENSE AVAILABLE\n");\r\n}\r\n} else {\r\nsprintf(page + len, PRINTK_HEADER\r\n" SORRY - NO TSB DATA AVAILABLE\n");\r\n}\r\nprintk(KERN_ERR "%s", page);\r\nfree_page((unsigned long) page);\r\n}\r\nstatic void dasd_eckd_dump_sense(struct dasd_device *device,\r\nstruct dasd_ccw_req *req, struct irb *irb)\r\n{\r\nif (scsw_is_tm(&irb->scsw))\r\ndasd_eckd_dump_sense_tcw(device, req, irb);\r\nelse\r\ndasd_eckd_dump_sense_ccw(device, req, irb);\r\n}\r\nstatic int dasd_eckd_pm_freeze(struct dasd_device *device)\r\n{\r\ndasd_alias_remove_device(device);\r\ndasd_alias_disconnect_device_from_lcu(device);\r\nreturn 0;\r\n}\r\nstatic int dasd_eckd_restore_device(struct dasd_device *device)\r\n{\r\nstruct dasd_eckd_private *private;\r\nstruct dasd_eckd_characteristics temp_rdc_data;\r\nint rc;\r\nstruct dasd_uid temp_uid;\r\nunsigned long flags;\r\nunsigned long cqr_flags = 0;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\ndasd_eckd_read_conf(device);\r\ndasd_eckd_get_uid(device, &temp_uid);\r\nrc = dasd_eckd_generate_uid(device);\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\nif (memcmp(&private->uid, &temp_uid, sizeof(struct dasd_uid)) != 0)\r\ndev_err(&device->cdev->dev, "The UID of the DASD has "\r\n"changed\n");\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\nif (rc)\r\ngoto out_err;\r\nrc = dasd_alias_make_device_known_to_lcu(device);\r\nif (rc)\r\nreturn rc;\r\nset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr_flags);\r\ndasd_eckd_validate_server(device, cqr_flags);\r\ndasd_eckd_read_conf(device);\r\ndasd_eckd_read_features(device);\r\nrc = dasd_generic_read_dev_chars(device, DASD_ECKD_MAGIC,\r\n&temp_rdc_data, 64);\r\nif (rc) {\r\nDBF_EVENT_DEVID(DBF_WARNING, device->cdev,\r\n"Read device characteristic failed, rc=%d", rc);\r\ngoto out_err;\r\n}\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\nmemcpy(&private->rdc_data, &temp_rdc_data, sizeof(temp_rdc_data));\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\ndasd_alias_add_device(device);\r\nreturn 0;\r\nout_err:\r\nreturn -1;\r\n}\r\nstatic int dasd_eckd_reload_device(struct dasd_device *device)\r\n{\r\nstruct dasd_eckd_private *private;\r\nint rc, old_base;\r\nchar print_uid[60];\r\nstruct dasd_uid uid;\r\nunsigned long flags;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\nold_base = private->uid.base_unit_addr;\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\nrc = dasd_eckd_read_conf(device);\r\nif (rc)\r\ngoto out_err;\r\nrc = dasd_eckd_generate_uid(device);\r\nif (rc)\r\ngoto out_err;\r\ndasd_alias_update_add_device(device);\r\ndasd_eckd_get_uid(device, &uid);\r\nif (old_base != uid.base_unit_addr) {\r\nif (strlen(uid.vduit) > 0)\r\nsnprintf(print_uid, sizeof(print_uid),\r\n"%s.%s.%04x.%02x.%s", uid.vendor, uid.serial,\r\nuid.ssid, uid.base_unit_addr, uid.vduit);\r\nelse\r\nsnprintf(print_uid, sizeof(print_uid),\r\n"%s.%s.%04x.%02x", uid.vendor, uid.serial,\r\nuid.ssid, uid.base_unit_addr);\r\ndev_info(&device->cdev->dev,\r\n"An Alias device was reassigned to a new base device "\r\n"with UID: %s\n", print_uid);\r\n}\r\nreturn 0;\r\nout_err:\r\nreturn -1;\r\n}\r\nstatic int dasd_eckd_read_message_buffer(struct dasd_device *device,\r\nstruct dasd_rssd_messages *messages,\r\n__u8 lpum)\r\n{\r\nstruct dasd_rssd_messages *message_buf;\r\nstruct dasd_psf_prssd_data *prssdp;\r\nstruct dasd_eckd_private *private;\r\nstruct dasd_ccw_req *cqr;\r\nstruct ccw1 *ccw;\r\nint rc;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\ncqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1 + 1 ,\r\n(sizeof(struct dasd_psf_prssd_data) +\r\nsizeof(struct dasd_rssd_messages)),\r\ndevice);\r\nif (IS_ERR(cqr)) {\r\nDBF_EVENT_DEVID(DBF_WARNING, device->cdev, "%s",\r\n"Could not allocate read message buffer request");\r\nreturn PTR_ERR(cqr);\r\n}\r\ncqr->startdev = device;\r\ncqr->memdev = device;\r\ncqr->block = NULL;\r\ncqr->retries = 256;\r\ncqr->expires = 10 * HZ;\r\nset_bit(DASD_CQR_VERIFY_PATH, &cqr->flags);\r\ncqr->lpm = lpum;\r\nprssdp = (struct dasd_psf_prssd_data *) cqr->data;\r\nmemset(prssdp, 0, sizeof(struct dasd_psf_prssd_data));\r\nprssdp->order = PSF_ORDER_PRSSD;\r\nprssdp->suborder = 0x03;\r\nccw = cqr->cpaddr;\r\nccw->cmd_code = DASD_ECKD_CCW_PSF;\r\nccw->count = sizeof(struct dasd_psf_prssd_data);\r\nccw->flags |= CCW_FLAG_CC;\r\nccw->flags |= CCW_FLAG_SLI;\r\nccw->cda = (__u32)(addr_t) prssdp;\r\nmessage_buf = (struct dasd_rssd_messages *) (prssdp + 1);\r\nmemset(message_buf, 0, sizeof(struct dasd_rssd_messages));\r\nccw++;\r\nccw->cmd_code = DASD_ECKD_CCW_RSSD;\r\nccw->count = sizeof(struct dasd_rssd_messages);\r\nccw->flags |= CCW_FLAG_SLI;\r\nccw->cda = (__u32)(addr_t) message_buf;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nrc = dasd_sleep_on_immediatly(cqr);\r\nif (rc == 0) {\r\nprssdp = (struct dasd_psf_prssd_data *) cqr->data;\r\nmessage_buf = (struct dasd_rssd_messages *)\r\n(prssdp + 1);\r\nmemcpy(messages, message_buf,\r\nsizeof(struct dasd_rssd_messages));\r\n} else\r\nDBF_EVENT_DEVID(DBF_WARNING, device->cdev,\r\n"Reading messages failed with rc=%d\n"\r\n, rc);\r\ndasd_sfree_request(cqr, cqr->memdev);\r\nreturn rc;\r\n}\r\nstatic int\r\ndasd_eckd_psf_cuir_response(struct dasd_device *device, int response,\r\n__u32 message_id,\r\nstruct channel_path_desc *desc,\r\nstruct subchannel_id sch_id)\r\n{\r\nstruct dasd_psf_cuir_response *psf_cuir;\r\nstruct dasd_ccw_req *cqr;\r\nstruct ccw1 *ccw;\r\nint rc;\r\ncqr = dasd_smalloc_request(DASD_ECKD_MAGIC, 1 ,\r\nsizeof(struct dasd_psf_cuir_response),\r\ndevice);\r\nif (IS_ERR(cqr)) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Could not allocate PSF-CUIR request");\r\nreturn PTR_ERR(cqr);\r\n}\r\npsf_cuir = (struct dasd_psf_cuir_response *)cqr->data;\r\npsf_cuir->order = PSF_ORDER_CUIR_RESPONSE;\r\npsf_cuir->cc = response;\r\nif (desc)\r\npsf_cuir->chpid = desc->chpid;\r\npsf_cuir->message_id = message_id;\r\npsf_cuir->cssid = sch_id.cssid;\r\npsf_cuir->ssid = sch_id.ssid;\r\nccw = cqr->cpaddr;\r\nccw->cmd_code = DASD_ECKD_CCW_PSF;\r\nccw->cda = (__u32)(addr_t)psf_cuir;\r\nccw->count = sizeof(struct dasd_psf_cuir_response);\r\ncqr->startdev = device;\r\ncqr->memdev = device;\r\ncqr->block = NULL;\r\ncqr->retries = 256;\r\ncqr->expires = 10*HZ;\r\ncqr->buildclk = get_tod_clock();\r\ncqr->status = DASD_CQR_FILLED;\r\nrc = dasd_sleep_on(cqr);\r\ndasd_sfree_request(cqr, cqr->memdev);\r\nreturn rc;\r\n}\r\nstatic int dasd_eckd_cuir_change_state(struct dasd_device *device, __u8 lpum)\r\n{\r\nunsigned long flags;\r\n__u8 tbcpm;\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\ntbcpm = device->path_data.opm & ~lpum;\r\nif (tbcpm) {\r\ndevice->path_data.opm = tbcpm;\r\ndevice->path_data.cuirpm |= lpum;\r\n}\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\nreturn tbcpm ? 0 : PSF_CUIR_LAST_PATH;\r\n}\r\nstatic int dasd_eckd_cuir_quiesce(struct dasd_device *device, __u8 lpum,\r\nstruct channel_path_desc *desc,\r\nstruct subchannel_id sch_id)\r\n{\r\nstruct alias_pav_group *pavgroup, *tempgroup;\r\nstruct dasd_eckd_private *private;\r\nstruct dasd_device *dev, *n;\r\nint rc;\r\nprivate = (struct dasd_eckd_private *) device->private;\r\nrc = 0;\r\nlist_for_each_entry_safe(dev, n,\r\n&private->lcu->active_devices,\r\nalias_list) {\r\nrc = dasd_eckd_cuir_change_state(dev, lpum);\r\nif (rc)\r\ngoto out;\r\n}\r\nlist_for_each_entry_safe(dev, n,\r\n&private->lcu->inactive_devices,\r\nalias_list) {\r\nrc = dasd_eckd_cuir_change_state(dev, lpum);\r\nif (rc)\r\ngoto out;\r\n}\r\nlist_for_each_entry_safe(pavgroup, tempgroup,\r\n&private->lcu->grouplist, group) {\r\nlist_for_each_entry_safe(dev, n, &pavgroup->baselist,\r\nalias_list) {\r\nrc = dasd_eckd_cuir_change_state(dev, lpum);\r\nif (rc)\r\ngoto out;\r\n}\r\nlist_for_each_entry_safe(dev, n, &pavgroup->aliaslist,\r\nalias_list) {\r\nrc = dasd_eckd_cuir_change_state(dev, lpum);\r\nif (rc)\r\ngoto out;\r\n}\r\n}\r\npr_warn("Service on the storage server caused path %x.%02x to go offline",\r\nsch_id.cssid, desc ? desc->chpid : 0);\r\nrc = PSF_CUIR_COMPLETED;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int dasd_eckd_cuir_resume(struct dasd_device *device, __u8 lpum,\r\nstruct channel_path_desc *desc,\r\nstruct subchannel_id sch_id)\r\n{\r\nstruct alias_pav_group *pavgroup, *tempgroup;\r\nstruct dasd_eckd_private *private;\r\nstruct dasd_device *dev, *n;\r\npr_info("Path %x.%02x is back online after service on the storage server",\r\nsch_id.cssid, desc ? desc->chpid : 0);\r\nprivate = (struct dasd_eckd_private *) device->private;\r\nlist_for_each_entry_safe(dev, n,\r\n&private->lcu->active_devices,\r\nalias_list) {\r\nif (!(dev->path_data.opm & lpum)) {\r\ndev->path_data.tbvpm |= lpum;\r\ndasd_schedule_device_bh(dev);\r\n}\r\n}\r\nlist_for_each_entry_safe(dev, n,\r\n&private->lcu->inactive_devices,\r\nalias_list) {\r\nif (!(dev->path_data.opm & lpum)) {\r\ndev->path_data.tbvpm |= lpum;\r\ndasd_schedule_device_bh(dev);\r\n}\r\n}\r\nlist_for_each_entry_safe(pavgroup, tempgroup,\r\n&private->lcu->grouplist,\r\ngroup) {\r\nlist_for_each_entry_safe(dev, n,\r\n&pavgroup->baselist,\r\nalias_list) {\r\nif (!(dev->path_data.opm & lpum)) {\r\ndev->path_data.tbvpm |= lpum;\r\ndasd_schedule_device_bh(dev);\r\n}\r\n}\r\nlist_for_each_entry_safe(dev, n,\r\n&pavgroup->aliaslist,\r\nalias_list) {\r\nif (!(dev->path_data.opm & lpum)) {\r\ndev->path_data.tbvpm |= lpum;\r\ndasd_schedule_device_bh(dev);\r\n}\r\n}\r\n}\r\nreturn PSF_CUIR_COMPLETED;\r\n}\r\nstatic void dasd_eckd_handle_cuir(struct dasd_device *device, void *messages,\r\n__u8 lpum)\r\n{\r\nstruct dasd_cuir_message *cuir = messages;\r\nstruct channel_path_desc *desc;\r\nstruct subchannel_id sch_id;\r\nint pos, response;\r\nccw_device_get_schid(device->cdev, &sch_id);\r\npos = 8 - ffs(lpum);\r\ndesc = ccw_device_get_chp_desc(device->cdev, pos);\r\nif (cuir->code == CUIR_QUIESCE) {\r\nresponse = dasd_eckd_cuir_quiesce(device, lpum, desc, sch_id);\r\n} else if (cuir->code == CUIR_RESUME) {\r\nresponse = dasd_eckd_cuir_resume(device, lpum, desc, sch_id);\r\n} else\r\nresponse = PSF_CUIR_NOT_SUPPORTED;\r\ndasd_eckd_psf_cuir_response(device, response, cuir->message_id,\r\ndesc, sch_id);\r\nkfree(desc);\r\n}\r\nstatic void dasd_eckd_check_attention_work(struct work_struct *work)\r\n{\r\nstruct check_attention_work_data *data;\r\nstruct dasd_rssd_messages *messages;\r\nstruct dasd_device *device;\r\nint rc;\r\ndata = container_of(work, struct check_attention_work_data, worker);\r\ndevice = data->device;\r\nmessages = kzalloc(sizeof(*messages), GFP_KERNEL);\r\nif (!messages) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Could not allocate attention message buffer");\r\ngoto out;\r\n}\r\nrc = dasd_eckd_read_message_buffer(device, messages, data->lpum);\r\nif (rc)\r\ngoto out;\r\nif (messages->length == ATTENTION_LENGTH_CUIR &&\r\nmessages->format == ATTENTION_FORMAT_CUIR)\r\ndasd_eckd_handle_cuir(device, messages, data->lpum);\r\nout:\r\ndasd_put_device(device);\r\nkfree(messages);\r\nkfree(data);\r\n}\r\nstatic int dasd_eckd_check_attention(struct dasd_device *device, __u8 lpum)\r\n{\r\nstruct check_attention_work_data *data;\r\ndata = kzalloc(sizeof(*data), GFP_ATOMIC);\r\nif (!data)\r\nreturn -ENOMEM;\r\nINIT_WORK(&data->worker, dasd_eckd_check_attention_work);\r\ndasd_get_device(device);\r\ndata->device = device;\r\ndata->lpum = lpum;\r\nschedule_work(&data->worker);\r\nreturn 0;\r\n}\r\nstatic int __init\r\ndasd_eckd_init(void)\r\n{\r\nint ret;\r\nASCEBC(dasd_eckd_discipline.ebcname, 4);\r\ndasd_reserve_req = kmalloc(sizeof(*dasd_reserve_req),\r\nGFP_KERNEL | GFP_DMA);\r\nif (!dasd_reserve_req)\r\nreturn -ENOMEM;\r\npath_verification_worker = kmalloc(sizeof(*path_verification_worker),\r\nGFP_KERNEL | GFP_DMA);\r\nif (!path_verification_worker) {\r\nkfree(dasd_reserve_req);\r\nreturn -ENOMEM;\r\n}\r\nrawpadpage = (void *)__get_free_page(GFP_KERNEL);\r\nif (!rawpadpage) {\r\nkfree(path_verification_worker);\r\nkfree(dasd_reserve_req);\r\nreturn -ENOMEM;\r\n}\r\nret = ccw_driver_register(&dasd_eckd_driver);\r\nif (!ret)\r\nwait_for_device_probe();\r\nelse {\r\nkfree(path_verification_worker);\r\nkfree(dasd_reserve_req);\r\nfree_page((unsigned long)rawpadpage);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit\r\ndasd_eckd_cleanup(void)\r\n{\r\nccw_driver_unregister(&dasd_eckd_driver);\r\nkfree(path_verification_worker);\r\nkfree(dasd_reserve_req);\r\nfree_page((unsigned long)rawpadpage);\r\n}
