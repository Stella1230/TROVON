static size_t bond_get_slave_size(const struct net_device *bond_dev,\r\nconst struct net_device *slave_dev)\r\n{\r\nreturn nla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(MAX_ADDR_LEN) +\r\nnla_total_size(sizeof(u16)) +\r\nnla_total_size(sizeof(u16)) +\r\n0;\r\n}\r\nstatic int bond_fill_slave_info(struct sk_buff *skb,\r\nconst struct net_device *bond_dev,\r\nconst struct net_device *slave_dev)\r\n{\r\nstruct slave *slave = bond_slave_get_rtnl(slave_dev);\r\nif (nla_put_u8(skb, IFLA_BOND_SLAVE_STATE, bond_slave_state(slave)))\r\ngoto nla_put_failure;\r\nif (nla_put_u8(skb, IFLA_BOND_SLAVE_MII_STATUS, slave->link))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, IFLA_BOND_SLAVE_LINK_FAILURE_COUNT,\r\nslave->link_failure_count))\r\ngoto nla_put_failure;\r\nif (nla_put(skb, IFLA_BOND_SLAVE_PERM_HWADDR,\r\nslave_dev->addr_len, slave->perm_hwaddr))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(skb, IFLA_BOND_SLAVE_QUEUE_ID, slave->queue_id))\r\ngoto nla_put_failure;\r\nif (BOND_MODE(slave->bond) == BOND_MODE_8023AD) {\r\nconst struct aggregator *agg;\r\nagg = SLAVE_AD_INFO(slave)->port.aggregator;\r\nif (agg)\r\nif (nla_put_u16(skb, IFLA_BOND_SLAVE_AD_AGGREGATOR_ID,\r\nagg->aggregator_identifier))\r\ngoto nla_put_failure;\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int bond_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\nif (tb[IFLA_ADDRESS]) {\r\nif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\r\nreturn -EINVAL;\r\nif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bond_slave_changelink(struct net_device *bond_dev,\r\nstruct net_device *slave_dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nstruct bonding *bond = netdev_priv(bond_dev);\r\nstruct bond_opt_value newval;\r\nint err;\r\nif (!data)\r\nreturn 0;\r\nif (data[IFLA_BOND_SLAVE_QUEUE_ID]) {\r\nu16 queue_id = nla_get_u16(data[IFLA_BOND_SLAVE_QUEUE_ID]);\r\nchar queue_id_str[IFNAMSIZ + 7];\r\nsnprintf(queue_id_str, sizeof(queue_id_str), "%s:%u\n",\r\nslave_dev->name, queue_id);\r\nbond_opt_initstr(&newval, queue_id_str);\r\nerr = __bond_opt_set(bond, BOND_OPT_QUEUE_ID, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bond_changelink(struct net_device *bond_dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nstruct bonding *bond = netdev_priv(bond_dev);\r\nstruct bond_opt_value newval;\r\nint miimon = 0;\r\nint err;\r\nif (!data)\r\nreturn 0;\r\nif (data[IFLA_BOND_MODE]) {\r\nint mode = nla_get_u8(data[IFLA_BOND_MODE]);\r\nbond_opt_initval(&newval, mode);\r\nerr = __bond_opt_set(bond, BOND_OPT_MODE, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_ACTIVE_SLAVE]) {\r\nint ifindex = nla_get_u32(data[IFLA_BOND_ACTIVE_SLAVE]);\r\nstruct net_device *slave_dev;\r\nchar *active_slave = "";\r\nif (ifindex != 0) {\r\nslave_dev = __dev_get_by_index(dev_net(bond_dev),\r\nifindex);\r\nif (!slave_dev)\r\nreturn -ENODEV;\r\nactive_slave = slave_dev->name;\r\n}\r\nbond_opt_initstr(&newval, active_slave);\r\nerr = __bond_opt_set(bond, BOND_OPT_ACTIVE_SLAVE, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_MIIMON]) {\r\nmiimon = nla_get_u32(data[IFLA_BOND_MIIMON]);\r\nbond_opt_initval(&newval, miimon);\r\nerr = __bond_opt_set(bond, BOND_OPT_MIIMON, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_UPDELAY]) {\r\nint updelay = nla_get_u32(data[IFLA_BOND_UPDELAY]);\r\nbond_opt_initval(&newval, updelay);\r\nerr = __bond_opt_set(bond, BOND_OPT_UPDELAY, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_DOWNDELAY]) {\r\nint downdelay = nla_get_u32(data[IFLA_BOND_DOWNDELAY]);\r\nbond_opt_initval(&newval, downdelay);\r\nerr = __bond_opt_set(bond, BOND_OPT_DOWNDELAY, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_USE_CARRIER]) {\r\nint use_carrier = nla_get_u8(data[IFLA_BOND_USE_CARRIER]);\r\nbond_opt_initval(&newval, use_carrier);\r\nerr = __bond_opt_set(bond, BOND_OPT_USE_CARRIER, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_ARP_INTERVAL]) {\r\nint arp_interval = nla_get_u32(data[IFLA_BOND_ARP_INTERVAL]);\r\nif (arp_interval && miimon) {\r\nnetdev_err(bond->dev, "ARP monitoring cannot be used with MII monitoring\n");\r\nreturn -EINVAL;\r\n}\r\nbond_opt_initval(&newval, arp_interval);\r\nerr = __bond_opt_set(bond, BOND_OPT_ARP_INTERVAL, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_ARP_IP_TARGET]) {\r\nstruct nlattr *attr;\r\nint i = 0, rem;\r\nbond_option_arp_ip_targets_clear(bond);\r\nnla_for_each_nested(attr, data[IFLA_BOND_ARP_IP_TARGET], rem) {\r\n__be32 target;\r\nif (nla_len(attr) < sizeof(target))\r\nreturn -EINVAL;\r\ntarget = nla_get_be32(attr);\r\nbond_opt_initval(&newval, (__force u64)target);\r\nerr = __bond_opt_set(bond, BOND_OPT_ARP_TARGETS,\r\n&newval);\r\nif (err)\r\nbreak;\r\ni++;\r\n}\r\nif (i == 0 && bond->params.arp_interval)\r\nnetdev_warn(bond->dev, "Removing last arp target with arp_interval on\n");\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_ARP_VALIDATE]) {\r\nint arp_validate = nla_get_u32(data[IFLA_BOND_ARP_VALIDATE]);\r\nif (arp_validate && miimon) {\r\nnetdev_err(bond->dev, "ARP validating cannot be used with MII monitoring\n");\r\nreturn -EINVAL;\r\n}\r\nbond_opt_initval(&newval, arp_validate);\r\nerr = __bond_opt_set(bond, BOND_OPT_ARP_VALIDATE, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_ARP_ALL_TARGETS]) {\r\nint arp_all_targets =\r\nnla_get_u32(data[IFLA_BOND_ARP_ALL_TARGETS]);\r\nbond_opt_initval(&newval, arp_all_targets);\r\nerr = __bond_opt_set(bond, BOND_OPT_ARP_ALL_TARGETS, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_PRIMARY]) {\r\nint ifindex = nla_get_u32(data[IFLA_BOND_PRIMARY]);\r\nstruct net_device *dev;\r\nchar *primary = "";\r\ndev = __dev_get_by_index(dev_net(bond_dev), ifindex);\r\nif (dev)\r\nprimary = dev->name;\r\nbond_opt_initstr(&newval, primary);\r\nerr = __bond_opt_set(bond, BOND_OPT_PRIMARY, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_PRIMARY_RESELECT]) {\r\nint primary_reselect =\r\nnla_get_u8(data[IFLA_BOND_PRIMARY_RESELECT]);\r\nbond_opt_initval(&newval, primary_reselect);\r\nerr = __bond_opt_set(bond, BOND_OPT_PRIMARY_RESELECT, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_FAIL_OVER_MAC]) {\r\nint fail_over_mac =\r\nnla_get_u8(data[IFLA_BOND_FAIL_OVER_MAC]);\r\nbond_opt_initval(&newval, fail_over_mac);\r\nerr = __bond_opt_set(bond, BOND_OPT_FAIL_OVER_MAC, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_XMIT_HASH_POLICY]) {\r\nint xmit_hash_policy =\r\nnla_get_u8(data[IFLA_BOND_XMIT_HASH_POLICY]);\r\nbond_opt_initval(&newval, xmit_hash_policy);\r\nerr = __bond_opt_set(bond, BOND_OPT_XMIT_HASH, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_RESEND_IGMP]) {\r\nint resend_igmp =\r\nnla_get_u32(data[IFLA_BOND_RESEND_IGMP]);\r\nbond_opt_initval(&newval, resend_igmp);\r\nerr = __bond_opt_set(bond, BOND_OPT_RESEND_IGMP, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_NUM_PEER_NOTIF]) {\r\nint num_peer_notif =\r\nnla_get_u8(data[IFLA_BOND_NUM_PEER_NOTIF]);\r\nbond_opt_initval(&newval, num_peer_notif);\r\nerr = __bond_opt_set(bond, BOND_OPT_NUM_PEER_NOTIF, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_ALL_SLAVES_ACTIVE]) {\r\nint all_slaves_active =\r\nnla_get_u8(data[IFLA_BOND_ALL_SLAVES_ACTIVE]);\r\nbond_opt_initval(&newval, all_slaves_active);\r\nerr = __bond_opt_set(bond, BOND_OPT_ALL_SLAVES_ACTIVE, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_MIN_LINKS]) {\r\nint min_links =\r\nnla_get_u32(data[IFLA_BOND_MIN_LINKS]);\r\nbond_opt_initval(&newval, min_links);\r\nerr = __bond_opt_set(bond, BOND_OPT_MINLINKS, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_LP_INTERVAL]) {\r\nint lp_interval =\r\nnla_get_u32(data[IFLA_BOND_LP_INTERVAL]);\r\nbond_opt_initval(&newval, lp_interval);\r\nerr = __bond_opt_set(bond, BOND_OPT_LP_INTERVAL, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_PACKETS_PER_SLAVE]) {\r\nint packets_per_slave =\r\nnla_get_u32(data[IFLA_BOND_PACKETS_PER_SLAVE]);\r\nbond_opt_initval(&newval, packets_per_slave);\r\nerr = __bond_opt_set(bond, BOND_OPT_PACKETS_PER_SLAVE, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_AD_LACP_RATE]) {\r\nint lacp_rate =\r\nnla_get_u8(data[IFLA_BOND_AD_LACP_RATE]);\r\nbond_opt_initval(&newval, lacp_rate);\r\nerr = __bond_opt_set(bond, BOND_OPT_LACP_RATE, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nif (data[IFLA_BOND_AD_SELECT]) {\r\nint ad_select =\r\nnla_get_u8(data[IFLA_BOND_AD_SELECT]);\r\nbond_opt_initval(&newval, ad_select);\r\nerr = __bond_opt_set(bond, BOND_OPT_AD_SELECT, &newval);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bond_newlink(struct net *src_net, struct net_device *bond_dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nint err;\r\nerr = bond_changelink(bond_dev, tb, data);\r\nif (err < 0)\r\nreturn err;\r\nreturn register_netdevice(bond_dev);\r\n}\r\nstatic size_t bond_get_size(const struct net_device *bond_dev)\r\n{\r\nreturn nla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(struct nlattr)) +\r\nnla_total_size(sizeof(u32)) * BOND_MAX_ARP_TARGETS +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(u8)) +\r\nnla_total_size(sizeof(struct nlattr)) +\r\nnla_total_size(sizeof(u16)) +\r\nnla_total_size(sizeof(u16)) +\r\nnla_total_size(sizeof(u16)) +\r\nnla_total_size(sizeof(u16)) +\r\nnla_total_size(ETH_ALEN) +\r\n0;\r\n}\r\nstatic int bond_option_active_slave_get_ifindex(struct bonding *bond)\r\n{\r\nconst struct net_device *slave;\r\nint ifindex;\r\nrcu_read_lock();\r\nslave = bond_option_active_slave_get_rcu(bond);\r\nifindex = slave ? slave->ifindex : 0;\r\nrcu_read_unlock();\r\nreturn ifindex;\r\n}\r\nstatic int bond_fill_info(struct sk_buff *skb,\r\nconst struct net_device *bond_dev)\r\n{\r\nstruct bonding *bond = netdev_priv(bond_dev);\r\nunsigned int packets_per_slave;\r\nint ifindex, i, targets_added;\r\nstruct nlattr *targets;\r\nstruct slave *primary;\r\nif (nla_put_u8(skb, IFLA_BOND_MODE, BOND_MODE(bond)))\r\ngoto nla_put_failure;\r\nifindex = bond_option_active_slave_get_ifindex(bond);\r\nif (ifindex && nla_put_u32(skb, IFLA_BOND_ACTIVE_SLAVE, ifindex))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, IFLA_BOND_MIIMON, bond->params.miimon))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, IFLA_BOND_UPDELAY,\r\nbond->params.updelay * bond->params.miimon))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, IFLA_BOND_DOWNDELAY,\r\nbond->params.downdelay * bond->params.miimon))\r\ngoto nla_put_failure;\r\nif (nla_put_u8(skb, IFLA_BOND_USE_CARRIER, bond->params.use_carrier))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, IFLA_BOND_ARP_INTERVAL, bond->params.arp_interval))\r\ngoto nla_put_failure;\r\ntargets = nla_nest_start(skb, IFLA_BOND_ARP_IP_TARGET);\r\nif (!targets)\r\ngoto nla_put_failure;\r\ntargets_added = 0;\r\nfor (i = 0; i < BOND_MAX_ARP_TARGETS; i++) {\r\nif (bond->params.arp_targets[i]) {\r\nnla_put_be32(skb, i, bond->params.arp_targets[i]);\r\ntargets_added = 1;\r\n}\r\n}\r\nif (targets_added)\r\nnla_nest_end(skb, targets);\r\nelse\r\nnla_nest_cancel(skb, targets);\r\nif (nla_put_u32(skb, IFLA_BOND_ARP_VALIDATE, bond->params.arp_validate))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, IFLA_BOND_ARP_ALL_TARGETS,\r\nbond->params.arp_all_targets))\r\ngoto nla_put_failure;\r\nprimary = rtnl_dereference(bond->primary_slave);\r\nif (primary &&\r\nnla_put_u32(skb, IFLA_BOND_PRIMARY, primary->dev->ifindex))\r\ngoto nla_put_failure;\r\nif (nla_put_u8(skb, IFLA_BOND_PRIMARY_RESELECT,\r\nbond->params.primary_reselect))\r\ngoto nla_put_failure;\r\nif (nla_put_u8(skb, IFLA_BOND_FAIL_OVER_MAC,\r\nbond->params.fail_over_mac))\r\ngoto nla_put_failure;\r\nif (nla_put_u8(skb, IFLA_BOND_XMIT_HASH_POLICY,\r\nbond->params.xmit_policy))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, IFLA_BOND_RESEND_IGMP,\r\nbond->params.resend_igmp))\r\ngoto nla_put_failure;\r\nif (nla_put_u8(skb, IFLA_BOND_NUM_PEER_NOTIF,\r\nbond->params.num_peer_notif))\r\ngoto nla_put_failure;\r\nif (nla_put_u8(skb, IFLA_BOND_ALL_SLAVES_ACTIVE,\r\nbond->params.all_slaves_active))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, IFLA_BOND_MIN_LINKS,\r\nbond->params.min_links))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, IFLA_BOND_LP_INTERVAL,\r\nbond->params.lp_interval))\r\ngoto nla_put_failure;\r\npackets_per_slave = bond->params.packets_per_slave;\r\nif (nla_put_u32(skb, IFLA_BOND_PACKETS_PER_SLAVE,\r\npackets_per_slave))\r\ngoto nla_put_failure;\r\nif (nla_put_u8(skb, IFLA_BOND_AD_LACP_RATE,\r\nbond->params.lacp_fast))\r\ngoto nla_put_failure;\r\nif (nla_put_u8(skb, IFLA_BOND_AD_SELECT,\r\nbond->params.ad_select))\r\ngoto nla_put_failure;\r\nif (BOND_MODE(bond) == BOND_MODE_8023AD) {\r\nstruct ad_info info;\r\nif (!bond_3ad_get_active_agg_info(bond, &info)) {\r\nstruct nlattr *nest;\r\nnest = nla_nest_start(skb, IFLA_BOND_AD_INFO);\r\nif (!nest)\r\ngoto nla_put_failure;\r\nif (nla_put_u16(skb, IFLA_BOND_AD_INFO_AGGREGATOR,\r\ninfo.aggregator_id))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(skb, IFLA_BOND_AD_INFO_NUM_PORTS,\r\ninfo.ports))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(skb, IFLA_BOND_AD_INFO_ACTOR_KEY,\r\ninfo.actor_key))\r\ngoto nla_put_failure;\r\nif (nla_put_u16(skb, IFLA_BOND_AD_INFO_PARTNER_KEY,\r\ninfo.partner_key))\r\ngoto nla_put_failure;\r\nif (nla_put(skb, IFLA_BOND_AD_INFO_PARTNER_MAC,\r\nsizeof(info.partner_system),\r\n&info.partner_system))\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\n}\r\n}\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nint __init bond_netlink_init(void)\r\n{\r\nreturn rtnl_link_register(&bond_link_ops);\r\n}\r\nvoid bond_netlink_fini(void)\r\n{\r\nrtnl_link_unregister(&bond_link_ops);\r\n}
