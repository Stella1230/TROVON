static loff_t msr_seek(struct file *file, loff_t offset, int orig)\r\n{\r\nloff_t ret;\r\nstruct inode *inode = file_inode(file);\r\nmutex_lock(&inode->i_mutex);\r\nswitch (orig) {\r\ncase SEEK_SET:\r\nfile->f_pos = offset;\r\nret = file->f_pos;\r\nbreak;\r\ncase SEEK_CUR:\r\nfile->f_pos += offset;\r\nret = file->f_pos;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&inode->i_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t msr_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nu32 __user *tmp = (u32 __user *) buf;\r\nu32 data[2];\r\nu32 reg = *ppos;\r\nint cpu = iminor(file_inode(file));\r\nint err = 0;\r\nssize_t bytes = 0;\r\nif (count % 8)\r\nreturn -EINVAL;\r\nfor (; count; count -= 8) {\r\nerr = rdmsr_safe_on_cpu(cpu, reg, &data[0], &data[1]);\r\nif (err)\r\nbreak;\r\nif (copy_to_user(tmp, &data, 8)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\ntmp += 2;\r\nbytes += 8;\r\n}\r\nreturn bytes ? bytes : err;\r\n}\r\nstatic ssize_t msr_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nconst u32 __user *tmp = (const u32 __user *)buf;\r\nu32 data[2];\r\nu32 reg = *ppos;\r\nint cpu = iminor(file_inode(file));\r\nint err = 0;\r\nssize_t bytes = 0;\r\nif (count % 8)\r\nreturn -EINVAL;\r\nfor (; count; count -= 8) {\r\nif (copy_from_user(&data, tmp, 8)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = wrmsr_safe_on_cpu(cpu, reg, data[0], data[1]);\r\nif (err)\r\nbreak;\r\ntmp += 2;\r\nbytes += 8;\r\n}\r\nreturn bytes ? bytes : err;\r\n}\r\nstatic long msr_ioctl(struct file *file, unsigned int ioc, unsigned long arg)\r\n{\r\nu32 __user *uregs = (u32 __user *)arg;\r\nu32 regs[8];\r\nint cpu = iminor(file_inode(file));\r\nint err;\r\nswitch (ioc) {\r\ncase X86_IOC_RDMSR_REGS:\r\nif (!(file->f_mode & FMODE_READ)) {\r\nerr = -EBADF;\r\nbreak;\r\n}\r\nif (copy_from_user(&regs, uregs, sizeof regs)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = rdmsr_safe_regs_on_cpu(cpu, regs);\r\nif (err)\r\nbreak;\r\nif (copy_to_user(uregs, &regs, sizeof regs))\r\nerr = -EFAULT;\r\nbreak;\r\ncase X86_IOC_WRMSR_REGS:\r\nif (!(file->f_mode & FMODE_WRITE)) {\r\nerr = -EBADF;\r\nbreak;\r\n}\r\nif (copy_from_user(&regs, uregs, sizeof regs)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = wrmsr_safe_regs_on_cpu(cpu, regs);\r\nif (err)\r\nbreak;\r\nif (copy_to_user(uregs, &regs, sizeof regs))\r\nerr = -EFAULT;\r\nbreak;\r\ndefault:\r\nerr = -ENOTTY;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int msr_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned int cpu = iminor(file_inode(file));\r\nstruct cpuinfo_x86 *c;\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nif (cpu >= nr_cpu_ids || !cpu_online(cpu))\r\nreturn -ENXIO;\r\nc = &cpu_data(cpu);\r\nif (!cpu_has(c, X86_FEATURE_MSR))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int msr_device_create(int cpu)\r\n{\r\nstruct device *dev;\r\ndev = device_create(msr_class, NULL, MKDEV(MSR_MAJOR, cpu), NULL,\r\n"msr%d", cpu);\r\nreturn PTR_ERR_OR_ZERO(dev);\r\n}\r\nstatic void msr_device_destroy(int cpu)\r\n{\r\ndevice_destroy(msr_class, MKDEV(MSR_MAJOR, cpu));\r\n}\r\nstatic int msr_class_cpu_callback(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nunsigned int cpu = (unsigned long)hcpu;\r\nint err = 0;\r\nswitch (action) {\r\ncase CPU_UP_PREPARE:\r\nerr = msr_device_create(cpu);\r\nbreak;\r\ncase CPU_UP_CANCELED:\r\ncase CPU_UP_CANCELED_FROZEN:\r\ncase CPU_DEAD:\r\nmsr_device_destroy(cpu);\r\nbreak;\r\n}\r\nreturn notifier_from_errno(err);\r\n}\r\nstatic char *msr_devnode(struct device *dev, umode_t *mode)\r\n{\r\nreturn kasprintf(GFP_KERNEL, "cpu/%u/msr", MINOR(dev->devt));\r\n}\r\nstatic int __init msr_init(void)\r\n{\r\nint i, err = 0;\r\ni = 0;\r\nif (__register_chrdev(MSR_MAJOR, 0, NR_CPUS, "cpu/msr", &msr_fops)) {\r\npr_err("unable to get major %d for msr\n", MSR_MAJOR);\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nmsr_class = class_create(THIS_MODULE, "msr");\r\nif (IS_ERR(msr_class)) {\r\nerr = PTR_ERR(msr_class);\r\ngoto out_chrdev;\r\n}\r\nmsr_class->devnode = msr_devnode;\r\ncpu_notifier_register_begin();\r\nfor_each_online_cpu(i) {\r\nerr = msr_device_create(i);\r\nif (err != 0)\r\ngoto out_class;\r\n}\r\n__register_hotcpu_notifier(&msr_class_cpu_notifier);\r\ncpu_notifier_register_done();\r\nerr = 0;\r\ngoto out;\r\nout_class:\r\ni = 0;\r\nfor_each_online_cpu(i)\r\nmsr_device_destroy(i);\r\ncpu_notifier_register_done();\r\nclass_destroy(msr_class);\r\nout_chrdev:\r\n__unregister_chrdev(MSR_MAJOR, 0, NR_CPUS, "cpu/msr");\r\nout:\r\nreturn err;\r\n}\r\nstatic void __exit msr_exit(void)\r\n{\r\nint cpu = 0;\r\ncpu_notifier_register_begin();\r\nfor_each_online_cpu(cpu)\r\nmsr_device_destroy(cpu);\r\nclass_destroy(msr_class);\r\n__unregister_chrdev(MSR_MAJOR, 0, NR_CPUS, "cpu/msr");\r\n__unregister_hotcpu_notifier(&msr_class_cpu_notifier);\r\ncpu_notifier_register_done();\r\n}
