static void\r\nah_esp_conn_fill_param_proto(struct net *net, int af,\r\nconst struct ip_vs_iphdr *iph, int inverse,\r\nstruct ip_vs_conn_param *p)\r\n{\r\nif (likely(!inverse))\r\nip_vs_conn_fill_param(net, af, IPPROTO_UDP,\r\n&iph->saddr, htons(PORT_ISAKMP),\r\n&iph->daddr, htons(PORT_ISAKMP), p);\r\nelse\r\nip_vs_conn_fill_param(net, af, IPPROTO_UDP,\r\n&iph->daddr, htons(PORT_ISAKMP),\r\n&iph->saddr, htons(PORT_ISAKMP), p);\r\n}\r\nstatic struct ip_vs_conn *\r\nah_esp_conn_in_get(int af, const struct sk_buff *skb,\r\nconst struct ip_vs_iphdr *iph,\r\nint inverse)\r\n{\r\nstruct ip_vs_conn *cp;\r\nstruct ip_vs_conn_param p;\r\nstruct net *net = skb_net(skb);\r\nah_esp_conn_fill_param_proto(net, af, iph, inverse, &p);\r\ncp = ip_vs_conn_in_get(&p);\r\nif (!cp) {\r\nIP_VS_DBG_BUF(12, "Unknown ISAKMP entry for outin packet "\r\n"%s%s %s->%s\n",\r\ninverse ? "ICMP+" : "",\r\nip_vs_proto_get(iph->protocol)->name,\r\nIP_VS_DBG_ADDR(af, &iph->saddr),\r\nIP_VS_DBG_ADDR(af, &iph->daddr));\r\n}\r\nreturn cp;\r\n}\r\nstatic struct ip_vs_conn *\r\nah_esp_conn_out_get(int af, const struct sk_buff *skb,\r\nconst struct ip_vs_iphdr *iph, int inverse)\r\n{\r\nstruct ip_vs_conn *cp;\r\nstruct ip_vs_conn_param p;\r\nstruct net *net = skb_net(skb);\r\nah_esp_conn_fill_param_proto(net, af, iph, inverse, &p);\r\ncp = ip_vs_conn_out_get(&p);\r\nif (!cp) {\r\nIP_VS_DBG_BUF(12, "Unknown ISAKMP entry for inout packet "\r\n"%s%s %s->%s\n",\r\ninverse ? "ICMP+" : "",\r\nip_vs_proto_get(iph->protocol)->name,\r\nIP_VS_DBG_ADDR(af, &iph->saddr),\r\nIP_VS_DBG_ADDR(af, &iph->daddr));\r\n}\r\nreturn cp;\r\n}\r\nstatic int\r\nah_esp_conn_schedule(int af, struct sk_buff *skb, struct ip_vs_proto_data *pd,\r\nint *verdict, struct ip_vs_conn **cpp,\r\nstruct ip_vs_iphdr *iph)\r\n{\r\n*verdict = NF_ACCEPT;\r\nreturn 0;\r\n}
