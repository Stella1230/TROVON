int rl6231_calc_dmic_clk(int rate)\r\n{\r\nint div[] = {2, 3, 4, 6, 8, 12}, idx = -EINVAL;\r\nint i, red, bound, temp;\r\nred = 3000000 * 12;\r\nfor (i = 0; i < ARRAY_SIZE(div); i++) {\r\nbound = div[i] * 3000000;\r\nif (rate > bound)\r\ncontinue;\r\ntemp = bound - rate;\r\nif (temp < red) {\r\nred = temp;\r\nidx = i;\r\n}\r\n}\r\nreturn idx;\r\n}\r\nint rl6231_pll_calc(const unsigned int freq_in,\r\nconst unsigned int freq_out, struct rl6231_pll_code *pll_code)\r\n{\r\nint max_n = RL6231_PLL_N_MAX, max_m = RL6231_PLL_M_MAX;\r\nint k, red, n_t, pll_out, in_t, out_t;\r\nint n = 0, m = 0, m_t = 0;\r\nint red_t = abs(freq_out - freq_in);\r\nbool bypass = false;\r\nif (RL6231_PLL_INP_MAX < freq_in || RL6231_PLL_INP_MIN > freq_in)\r\nreturn -EINVAL;\r\nk = 100000000 / freq_out - 2;\r\nif (k > RL6231_PLL_K_MAX)\r\nk = RL6231_PLL_K_MAX;\r\nfor (n_t = 0; n_t <= max_n; n_t++) {\r\nin_t = freq_in / (k + 2);\r\npll_out = freq_out / (n_t + 2);\r\nif (in_t < 0)\r\ncontinue;\r\nif (in_t == pll_out) {\r\nbypass = true;\r\nn = n_t;\r\ngoto code_find;\r\n}\r\nred = abs(in_t - pll_out);\r\nif (red < red_t) {\r\nbypass = true;\r\nn = n_t;\r\nm = m_t;\r\nif (red == 0)\r\ngoto code_find;\r\nred_t = red;\r\n}\r\nfor (m_t = 0; m_t <= max_m; m_t++) {\r\nout_t = in_t / (m_t + 2);\r\nred = abs(out_t - pll_out);\r\nif (red < red_t) {\r\nbypass = false;\r\nn = n_t;\r\nm = m_t;\r\nif (red == 0)\r\ngoto code_find;\r\nred_t = red;\r\n}\r\n}\r\n}\r\npr_debug("Only get approximation about PLL\n");\r\ncode_find:\r\npll_code->m_bp = bypass;\r\npll_code->m_code = m;\r\npll_code->n_code = n;\r\npll_code->k_code = k;\r\nreturn 0;\r\n}\r\nint rl6231_get_clk_info(int sclk, int rate)\r\n{\r\nint i, pd[] = {1, 2, 3, 4, 6, 8, 12, 16};\r\nif (sclk <= 0 || rate <= 0)\r\nreturn -EINVAL;\r\nrate = rate << 8;\r\nfor (i = 0; i < ARRAY_SIZE(pd); i++)\r\nif (sclk == rate * pd[i])\r\nreturn i;\r\nreturn -EINVAL;\r\n}
