static void __tcx_set_control_plane(struct fb_info *info)\r\n{\r\nstruct tcx_par *par = info->par;\r\nu32 __iomem *p, *pend;\r\nif (par->lowdepth)\r\nreturn;\r\np = par->cplane;\r\nif (p == NULL)\r\nreturn;\r\nfor (pend = p + info->fix.smem_len; p < pend; p++) {\r\nu32 tmp = sbus_readl(p);\r\ntmp &= 0xffffff;\r\nsbus_writel(tmp, p);\r\n}\r\n}\r\nstatic void tcx_reset(struct fb_info *info)\r\n{\r\nstruct tcx_par *par = (struct tcx_par *) info->par;\r\nunsigned long flags;\r\nspin_lock_irqsave(&par->lock, flags);\r\n__tcx_set_control_plane(info);\r\nspin_unlock_irqrestore(&par->lock, flags);\r\n}\r\nstatic int tcx_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\ntcx_reset(info);\r\nreturn 0;\r\n}\r\nstatic int tcx_setcolreg(unsigned regno,\r\nunsigned red, unsigned green, unsigned blue,\r\nunsigned transp, struct fb_info *info)\r\n{\r\nstruct tcx_par *par = (struct tcx_par *) info->par;\r\nstruct bt_regs __iomem *bt = par->bt;\r\nunsigned long flags;\r\nif (regno >= 256)\r\nreturn 1;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nspin_lock_irqsave(&par->lock, flags);\r\nsbus_writel(regno << 24, &bt->addr);\r\nsbus_writel(red << 24, &bt->color_map);\r\nsbus_writel(green << 24, &bt->color_map);\r\nsbus_writel(blue << 24, &bt->color_map);\r\nspin_unlock_irqrestore(&par->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\ntcx_blank(int blank, struct fb_info *info)\r\n{\r\nstruct tcx_par *par = (struct tcx_par *) info->par;\r\nstruct tcx_thc __iomem *thc = par->thc;\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&par->lock, flags);\r\nval = sbus_readl(&thc->thc_misc);\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\nval &= ~(TCX_THC_MISC_VSYNC_DIS |\r\nTCX_THC_MISC_HSYNC_DIS);\r\nval |= TCX_THC_MISC_VIDEO;\r\npar->flags &= ~TCX_FLAG_BLANKED;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\nval &= ~TCX_THC_MISC_VIDEO;\r\npar->flags |= TCX_FLAG_BLANKED;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nval |= TCX_THC_MISC_VSYNC_DIS;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nval |= TCX_THC_MISC_HSYNC_DIS;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nbreak;\r\n}\r\nsbus_writel(val, &thc->thc_misc);\r\nspin_unlock_irqrestore(&par->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int tcx_mmap(struct fb_info *info, struct vm_area_struct *vma)\r\n{\r\nstruct tcx_par *par = (struct tcx_par *)info->par;\r\nreturn sbusfb_mmap_helper(par->mmap_map,\r\ninfo->fix.smem_start, info->fix.smem_len,\r\npar->which_io, vma);\r\n}\r\nstatic int tcx_ioctl(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct tcx_par *par = (struct tcx_par *) info->par;\r\nreturn sbusfb_ioctl_helper(cmd, arg, info,\r\nFBTYPE_TCXCOLOR,\r\n(par->lowdepth ? 8 : 24),\r\ninfo->fix.smem_len);\r\n}\r\nstatic void\r\ntcx_init_fix(struct fb_info *info, int linebytes)\r\n{\r\nstruct tcx_par *par = (struct tcx_par *)info->par;\r\nconst char *tcx_name;\r\nif (par->lowdepth)\r\ntcx_name = "TCX8";\r\nelse\r\ntcx_name = "TCX24";\r\nstrlcpy(info->fix.id, tcx_name, sizeof(info->fix.id));\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\ninfo->fix.line_length = linebytes;\r\ninfo->fix.accel = FB_ACCEL_SUN_TCX;\r\n}\r\nstatic void tcx_unmap_regs(struct platform_device *op, struct fb_info *info,\r\nstruct tcx_par *par)\r\n{\r\nif (par->tec)\r\nof_iounmap(&op->resource[7],\r\npar->tec, sizeof(struct tcx_tec));\r\nif (par->thc)\r\nof_iounmap(&op->resource[9],\r\npar->thc, sizeof(struct tcx_thc));\r\nif (par->bt)\r\nof_iounmap(&op->resource[8],\r\npar->bt, sizeof(struct bt_regs));\r\nif (par->cplane)\r\nof_iounmap(&op->resource[4],\r\npar->cplane, info->fix.smem_len * sizeof(u32));\r\nif (info->screen_base)\r\nof_iounmap(&op->resource[0],\r\ninfo->screen_base, info->fix.smem_len);\r\n}\r\nstatic int tcx_probe(struct platform_device *op)\r\n{\r\nstruct device_node *dp = op->dev.of_node;\r\nstruct fb_info *info;\r\nstruct tcx_par *par;\r\nint linebytes, i, err;\r\ninfo = framebuffer_alloc(sizeof(struct tcx_par), &op->dev);\r\nerr = -ENOMEM;\r\nif (!info)\r\ngoto out_err;\r\npar = info->par;\r\nspin_lock_init(&par->lock);\r\npar->lowdepth =\r\n(of_find_property(dp, "tcx-8-bit", NULL) != NULL);\r\nsbusfb_fill_var(&info->var, dp, 8);\r\ninfo->var.red.length = 8;\r\ninfo->var.green.length = 8;\r\ninfo->var.blue.length = 8;\r\nlinebytes = of_getintprop_default(dp, "linebytes",\r\ninfo->var.xres);\r\ninfo->fix.smem_len = PAGE_ALIGN(linebytes * info->var.yres);\r\npar->tec = of_ioremap(&op->resource[7], 0,\r\nsizeof(struct tcx_tec), "tcx tec");\r\npar->thc = of_ioremap(&op->resource[9], 0,\r\nsizeof(struct tcx_thc), "tcx thc");\r\npar->bt = of_ioremap(&op->resource[8], 0,\r\nsizeof(struct bt_regs), "tcx dac");\r\ninfo->screen_base = of_ioremap(&op->resource[0], 0,\r\ninfo->fix.smem_len, "tcx ram");\r\nif (!par->tec || !par->thc ||\r\n!par->bt || !info->screen_base)\r\ngoto out_unmap_regs;\r\nmemcpy(&par->mmap_map, &__tcx_mmap_map, sizeof(par->mmap_map));\r\nif (!par->lowdepth) {\r\npar->cplane = of_ioremap(&op->resource[4], 0,\r\ninfo->fix.smem_len * sizeof(u32),\r\n"tcx cplane");\r\nif (!par->cplane)\r\ngoto out_unmap_regs;\r\n} else {\r\npar->mmap_map[1].size = SBUS_MMAP_EMPTY;\r\npar->mmap_map[4].size = SBUS_MMAP_EMPTY;\r\npar->mmap_map[5].size = SBUS_MMAP_EMPTY;\r\npar->mmap_map[6].size = SBUS_MMAP_EMPTY;\r\n}\r\ninfo->fix.smem_start = op->resource[0].start;\r\npar->which_io = op->resource[0].flags & IORESOURCE_BITS;\r\nfor (i = 0; i < TCX_MMAP_ENTRIES; i++) {\r\nint j;\r\nswitch (i) {\r\ncase 10:\r\nj = 12;\r\nbreak;\r\ncase 11: case 12:\r\nj = i - 1;\r\nbreak;\r\ndefault:\r\nj = i;\r\nbreak;\r\n}\r\npar->mmap_map[i].poff = op->resource[j].start;\r\n}\r\ninfo->flags = FBINFO_DEFAULT;\r\ninfo->fbops = &tcx_ops;\r\nsbus_writel(0x04 << 24, &par->bt->addr);\r\nsbus_writel(0xff << 24, &par->bt->control);\r\nsbus_writel(0x05 << 24, &par->bt->addr);\r\nsbus_writel(0x00 << 24, &par->bt->control);\r\nsbus_writel(0x06 << 24, &par->bt->addr);\r\nsbus_writel(0x73 << 24, &par->bt->control);\r\nsbus_writel(0x07 << 24, &par->bt->addr);\r\nsbus_writel(0x00 << 24, &par->bt->control);\r\ntcx_reset(info);\r\ntcx_blank(FB_BLANK_UNBLANK, info);\r\nif (fb_alloc_cmap(&info->cmap, 256, 0))\r\ngoto out_unmap_regs;\r\nfb_set_cmap(&info->cmap, info);\r\ntcx_init_fix(info, linebytes);\r\nerr = register_framebuffer(info);\r\nif (err < 0)\r\ngoto out_dealloc_cmap;\r\ndev_set_drvdata(&op->dev, info);\r\nprintk(KERN_INFO "%s: TCX at %lx:%lx, %s\n",\r\ndp->full_name,\r\npar->which_io,\r\ninfo->fix.smem_start,\r\npar->lowdepth ? "8-bit only" : "24-bit depth");\r\nreturn 0;\r\nout_dealloc_cmap:\r\nfb_dealloc_cmap(&info->cmap);\r\nout_unmap_regs:\r\ntcx_unmap_regs(op, info, par);\r\nframebuffer_release(info);\r\nout_err:\r\nreturn err;\r\n}\r\nstatic int tcx_remove(struct platform_device *op)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(&op->dev);\r\nstruct tcx_par *par = info->par;\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\ntcx_unmap_regs(op, info, par);\r\nframebuffer_release(info);\r\nreturn 0;\r\n}\r\nstatic int __init tcx_init(void)\r\n{\r\nif (fb_get_options("tcxfb", NULL))\r\nreturn -ENODEV;\r\nreturn platform_driver_register(&tcx_driver);\r\n}\r\nstatic void __exit tcx_exit(void)\r\n{\r\nplatform_driver_unregister(&tcx_driver);\r\n}
