asmlinkage void __exception_irq_entry\r\nnvic_handle_irq(irq_hw_number_t hwirq, struct pt_regs *regs)\r\n{\r\nunsigned int irq = irq_linear_revmap(nvic_irq_domain, hwirq);\r\nhandle_IRQ(irq, regs);\r\n}\r\nstatic int __init nvic_of_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nunsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;\r\nunsigned int irqs, i, ret, numbanks;\r\nvoid __iomem *nvic_base;\r\nnumbanks = (readl_relaxed(V7M_SCS_ICTR) &\r\nV7M_SCS_ICTR_INTLINESNUM_MASK) + 1;\r\nnvic_base = of_iomap(node, 0);\r\nif (!nvic_base) {\r\npr_warn("unable to map nvic registers\n");\r\nreturn -ENOMEM;\r\n}\r\nirqs = numbanks * 32;\r\nif (irqs > NVIC_MAX_IRQ)\r\nirqs = NVIC_MAX_IRQ;\r\nnvic_irq_domain =\r\nirq_domain_add_linear(node, irqs, &irq_generic_chip_ops, NULL);\r\nif (!nvic_irq_domain) {\r\npr_warn("Failed to allocate irq domain\n");\r\nreturn -ENOMEM;\r\n}\r\nret = irq_alloc_domain_generic_chips(nvic_irq_domain, 32, 1,\r\n"nvic_irq", handle_fasteoi_irq,\r\nclr, 0, IRQ_GC_INIT_MASK_CACHE);\r\nif (ret) {\r\npr_warn("Failed to allocate irq chips\n");\r\nirq_domain_remove(nvic_irq_domain);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < numbanks; ++i) {\r\nstruct irq_chip_generic *gc;\r\ngc = irq_get_domain_generic_chip(nvic_irq_domain, 32 * i);\r\ngc->reg_base = nvic_base + 4 * i;\r\ngc->chip_types[0].regs.enable = NVIC_ISER;\r\ngc->chip_types[0].regs.disable = NVIC_ICER;\r\ngc->chip_types[0].chip.irq_mask = irq_gc_mask_disable_reg;\r\ngc->chip_types[0].chip.irq_unmask = irq_gc_unmask_enable_reg;\r\ngc->chip_types[0].chip.irq_eoi = irq_gc_noop;\r\nwritel_relaxed(~0, gc->reg_base + NVIC_ICER);\r\n}\r\nfor (i = 0; i < irqs; i += 4)\r\nwritel_relaxed(0, nvic_base + NVIC_IPR + i);\r\nreturn 0;\r\n}
