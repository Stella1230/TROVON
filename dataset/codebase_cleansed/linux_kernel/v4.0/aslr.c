static inline u16 i8254(void)\r\n{\r\nu16 status, timer;\r\ndo {\r\noutb(I8254_PORT_CONTROL,\r\nI8254_CMD_READBACK | I8254_SELECT_COUNTER0);\r\nstatus = inb(I8254_PORT_COUNTER0);\r\ntimer = inb(I8254_PORT_COUNTER0);\r\ntimer |= inb(I8254_PORT_COUNTER0) << 8;\r\n} while (status & I8254_STATUS_NOTREADY);\r\nreturn timer;\r\n}\r\nstatic unsigned long rotate_xor(unsigned long hash, const void *area,\r\nsize_t size)\r\n{\r\nsize_t i;\r\nunsigned long *ptr = (unsigned long *)area;\r\nfor (i = 0; i < size / sizeof(hash); i++) {\r\nhash = (hash << ((sizeof(hash) * 8) - 7)) | (hash >> 7);\r\nhash ^= ptr[i];\r\n}\r\nreturn hash;\r\n}\r\nstatic unsigned long get_random_boot(void)\r\n{\r\nunsigned long hash = 0;\r\nhash = rotate_xor(hash, build_str, sizeof(build_str));\r\nhash = rotate_xor(hash, real_mode, sizeof(*real_mode));\r\nreturn hash;\r\n}\r\nstatic unsigned long get_random_long(void)\r\n{\r\n#ifdef CONFIG_X86_64\r\nconst unsigned long mix_const = 0x5d6008cbf3848dd3UL;\r\n#else\r\nconst unsigned long mix_const = 0x3f39e593UL;\r\n#endif\r\nunsigned long raw, random = get_random_boot();\r\nbool use_i8254 = true;\r\ndebug_putstr("KASLR using");\r\nif (has_cpuflag(X86_FEATURE_RDRAND)) {\r\ndebug_putstr(" RDRAND");\r\nif (rdrand_long(&raw)) {\r\nrandom ^= raw;\r\nuse_i8254 = false;\r\n}\r\n}\r\nif (has_cpuflag(X86_FEATURE_TSC)) {\r\ndebug_putstr(" RDTSC");\r\nrdtscll(raw);\r\nrandom ^= raw;\r\nuse_i8254 = false;\r\n}\r\nif (use_i8254) {\r\ndebug_putstr(" i8254");\r\nrandom ^= i8254();\r\n}\r\nasm("mul %3"\r\n: "=a" (random), "=d" (raw)\r\n: "a" (random), "rm" (mix_const));\r\nrandom += raw;\r\ndebug_putstr("...\n");\r\nreturn random;\r\n}\r\nstatic bool mem_contains(struct mem_vector *region, struct mem_vector *item)\r\n{\r\nif (item->start < region->start)\r\nreturn false;\r\nif (item->start + item->size > region->start + region->size)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool mem_overlaps(struct mem_vector *one, struct mem_vector *two)\r\n{\r\nif (one->start + one->size <= two->start)\r\nreturn false;\r\nif (one->start >= two->start + two->size)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void mem_avoid_init(unsigned long input, unsigned long input_size,\r\nunsigned long output, unsigned long output_size)\r\n{\r\nu64 initrd_start, initrd_size;\r\nu64 cmd_line, cmd_line_size;\r\nunsigned long unsafe, unsafe_len;\r\nchar *ptr;\r\nunsafe_len = (output_size >> 12) + 32768 + 18;\r\nunsafe = (unsigned long)input + input_size - unsafe_len;\r\nmem_avoid[0].start = unsafe;\r\nmem_avoid[0].size = unsafe_len;\r\ninitrd_start = (u64)real_mode->ext_ramdisk_image << 32;\r\ninitrd_start |= real_mode->hdr.ramdisk_image;\r\ninitrd_size = (u64)real_mode->ext_ramdisk_size << 32;\r\ninitrd_size |= real_mode->hdr.ramdisk_size;\r\nmem_avoid[1].start = initrd_start;\r\nmem_avoid[1].size = initrd_size;\r\ncmd_line = (u64)real_mode->ext_cmd_line_ptr << 32;\r\ncmd_line |= real_mode->hdr.cmd_line_ptr;\r\nptr = (char *)(unsigned long)cmd_line;\r\nfor (cmd_line_size = 0; ptr[cmd_line_size++]; )\r\n;\r\nmem_avoid[2].start = cmd_line;\r\nmem_avoid[2].size = cmd_line_size;\r\nmem_avoid[3].start = (unsigned long)free_mem_ptr;\r\nmem_avoid[3].size = BOOT_HEAP_SIZE;\r\nmem_avoid[4].start = (unsigned long)free_mem_end_ptr;\r\nmem_avoid[4].size = BOOT_STACK_SIZE;\r\n}\r\nstatic bool mem_avoid_overlap(struct mem_vector *img)\r\n{\r\nint i;\r\nstruct setup_data *ptr;\r\nfor (i = 0; i < MEM_AVOID_MAX; i++) {\r\nif (mem_overlaps(img, &mem_avoid[i]))\r\nreturn true;\r\n}\r\nptr = (struct setup_data *)(unsigned long)real_mode->hdr.setup_data;\r\nwhile (ptr) {\r\nstruct mem_vector avoid;\r\navoid.start = (unsigned long)ptr;\r\navoid.size = sizeof(*ptr) + ptr->len;\r\nif (mem_overlaps(img, &avoid))\r\nreturn true;\r\nptr = (struct setup_data *)(unsigned long)ptr->next;\r\n}\r\nreturn false;\r\n}\r\nstatic void slots_append(unsigned long addr)\r\n{\r\nif (slot_max >= CONFIG_RANDOMIZE_BASE_MAX_OFFSET /\r\nCONFIG_PHYSICAL_ALIGN)\r\nreturn;\r\nslots[slot_max++] = addr;\r\n}\r\nstatic unsigned long slots_fetch_random(void)\r\n{\r\nif (slot_max == 0)\r\nreturn 0;\r\nreturn slots[get_random_long() % slot_max];\r\n}\r\nstatic void process_e820_entry(struct e820entry *entry,\r\nunsigned long minimum,\r\nunsigned long image_size)\r\n{\r\nstruct mem_vector region, img;\r\nif (entry->type != E820_RAM)\r\nreturn;\r\nif (entry->addr >= CONFIG_RANDOMIZE_BASE_MAX_OFFSET)\r\nreturn;\r\nif (entry->addr + entry->size < minimum)\r\nreturn;\r\nregion.start = entry->addr;\r\nregion.size = entry->size;\r\nif (region.start < minimum)\r\nregion.start = minimum;\r\nregion.start = ALIGN(region.start, CONFIG_PHYSICAL_ALIGN);\r\nif (region.start > entry->addr + entry->size)\r\nreturn;\r\nregion.size -= region.start - entry->addr;\r\nif (region.start + region.size > CONFIG_RANDOMIZE_BASE_MAX_OFFSET)\r\nregion.size = CONFIG_RANDOMIZE_BASE_MAX_OFFSET - region.start;\r\nfor (img.start = region.start, img.size = image_size ;\r\nmem_contains(&region, &img) ;\r\nimg.start += CONFIG_PHYSICAL_ALIGN) {\r\nif (mem_avoid_overlap(&img))\r\ncontinue;\r\nslots_append(img.start);\r\n}\r\n}\r\nstatic unsigned long find_random_addr(unsigned long minimum,\r\nunsigned long size)\r\n{\r\nint i;\r\nunsigned long addr;\r\nminimum = ALIGN(minimum, CONFIG_PHYSICAL_ALIGN);\r\nfor (i = 0; i < real_mode->e820_entries; i++) {\r\nprocess_e820_entry(&real_mode->e820_map[i], minimum, size);\r\n}\r\nreturn slots_fetch_random();\r\n}\r\nunsigned char *choose_kernel_location(unsigned char *input,\r\nunsigned long input_size,\r\nunsigned char *output,\r\nunsigned long output_size)\r\n{\r\nunsigned long choice = (unsigned long)output;\r\nunsigned long random;\r\n#ifdef CONFIG_HIBERNATION\r\nif (!cmdline_find_option_bool("kaslr")) {\r\ndebug_putstr("KASLR disabled by default...\n");\r\ngoto out;\r\n}\r\n#else\r\nif (cmdline_find_option_bool("nokaslr")) {\r\ndebug_putstr("KASLR disabled by cmdline...\n");\r\ngoto out;\r\n}\r\n#endif\r\nmem_avoid_init((unsigned long)input, input_size,\r\n(unsigned long)output, output_size);\r\nrandom = find_random_addr(choice, output_size);\r\nif (!random) {\r\ndebug_putstr("KASLR could not find suitable E820 region...\n");\r\ngoto out;\r\n}\r\nif (random < choice)\r\ngoto out;\r\nchoice = random;\r\nout:\r\nreturn (unsigned char *)choice;\r\n}
