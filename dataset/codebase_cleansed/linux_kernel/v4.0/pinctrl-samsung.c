static inline struct samsung_pin_bank *gc_to_pin_bank(struct gpio_chip *gc)\r\n{\r\nreturn container_of(gc, struct samsung_pin_bank, gpio_chip);\r\n}\r\nstatic int samsung_get_group_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct samsung_pinctrl_drv_data *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->nr_groups;\r\n}\r\nstatic const char *samsung_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nstruct samsung_pinctrl_drv_data *pmx = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmx->pin_groups[group].name;\r\n}\r\nstatic int samsung_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct samsung_pinctrl_drv_data *pmx = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = pmx->pin_groups[group].pins;\r\n*num_pins = pmx->pin_groups[group].num_pins;\r\nreturn 0;\r\n}\r\nstatic int reserve_map(struct device *dev, struct pinctrl_map **map,\r\nunsigned *reserved_maps, unsigned *num_maps,\r\nunsigned reserve)\r\n{\r\nunsigned old_num = *reserved_maps;\r\nunsigned new_num = *num_maps + reserve;\r\nstruct pinctrl_map *new_map;\r\nif (old_num >= new_num)\r\nreturn 0;\r\nnew_map = krealloc(*map, sizeof(*new_map) * new_num, GFP_KERNEL);\r\nif (!new_map) {\r\ndev_err(dev, "krealloc(map) failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(new_map + old_num, 0, (new_num - old_num) * sizeof(*new_map));\r\n*map = new_map;\r\n*reserved_maps = new_num;\r\nreturn 0;\r\n}\r\nstatic int add_map_mux(struct pinctrl_map **map, unsigned *reserved_maps,\r\nunsigned *num_maps, const char *group,\r\nconst char *function)\r\n{\r\nif (WARN_ON(*num_maps == *reserved_maps))\r\nreturn -ENOSPC;\r\n(*map)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;\r\n(*map)[*num_maps].data.mux.group = group;\r\n(*map)[*num_maps].data.mux.function = function;\r\n(*num_maps)++;\r\nreturn 0;\r\n}\r\nstatic int add_map_configs(struct device *dev, struct pinctrl_map **map,\r\nunsigned *reserved_maps, unsigned *num_maps,\r\nconst char *group, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nunsigned long *dup_configs;\r\nif (WARN_ON(*num_maps == *reserved_maps))\r\nreturn -ENOSPC;\r\ndup_configs = kmemdup(configs, num_configs * sizeof(*dup_configs),\r\nGFP_KERNEL);\r\nif (!dup_configs) {\r\ndev_err(dev, "kmemdup(configs) failed\n");\r\nreturn -ENOMEM;\r\n}\r\n(*map)[*num_maps].type = PIN_MAP_TYPE_CONFIGS_GROUP;\r\n(*map)[*num_maps].data.configs.group_or_pin = group;\r\n(*map)[*num_maps].data.configs.configs = dup_configs;\r\n(*map)[*num_maps].data.configs.num_configs = num_configs;\r\n(*num_maps)++;\r\nreturn 0;\r\n}\r\nstatic int add_config(struct device *dev, unsigned long **configs,\r\nunsigned *num_configs, unsigned long config)\r\n{\r\nunsigned old_num = *num_configs;\r\nunsigned new_num = old_num + 1;\r\nunsigned long *new_configs;\r\nnew_configs = krealloc(*configs, sizeof(*new_configs) * new_num,\r\nGFP_KERNEL);\r\nif (!new_configs) {\r\ndev_err(dev, "krealloc(configs) failed\n");\r\nreturn -ENOMEM;\r\n}\r\nnew_configs[old_num] = config;\r\n*configs = new_configs;\r\n*num_configs = new_num;\r\nreturn 0;\r\n}\r\nstatic void samsung_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map,\r\nunsigned num_maps)\r\n{\r\nint i;\r\nfor (i = 0; i < num_maps; i++)\r\nif (map[i].type == PIN_MAP_TYPE_CONFIGS_GROUP)\r\nkfree(map[i].data.configs.configs);\r\nkfree(map);\r\n}\r\nstatic int samsung_dt_subnode_to_map(struct samsung_pinctrl_drv_data *drvdata,\r\nstruct device *dev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map,\r\nunsigned *reserved_maps,\r\nunsigned *num_maps)\r\n{\r\nint ret, i;\r\nu32 val;\r\nunsigned long config;\r\nunsigned long *configs = NULL;\r\nunsigned num_configs = 0;\r\nunsigned reserve;\r\nstruct property *prop;\r\nconst char *group;\r\nbool has_func = false;\r\nret = of_property_read_u32(np, "samsung,pin-function", &val);\r\nif (!ret)\r\nhas_func = true;\r\nfor (i = 0; i < ARRAY_SIZE(cfg_params); i++) {\r\nret = of_property_read_u32(np, cfg_params[i].property, &val);\r\nif (!ret) {\r\nconfig = PINCFG_PACK(cfg_params[i].param, val);\r\nret = add_config(dev, &configs, &num_configs, config);\r\nif (ret < 0)\r\ngoto exit;\r\n} else if (ret != -EINVAL) {\r\ndev_err(dev, "could not parse property %s\n",\r\ncfg_params[i].property);\r\n}\r\n}\r\nreserve = 0;\r\nif (has_func)\r\nreserve++;\r\nif (num_configs)\r\nreserve++;\r\nret = of_property_count_strings(np, "samsung,pins");\r\nif (ret < 0) {\r\ndev_err(dev, "could not parse property samsung,pins\n");\r\ngoto exit;\r\n}\r\nreserve *= ret;\r\nret = reserve_map(dev, map, reserved_maps, num_maps, reserve);\r\nif (ret < 0)\r\ngoto exit;\r\nof_property_for_each_string(np, "samsung,pins", prop, group) {\r\nif (has_func) {\r\nret = add_map_mux(map, reserved_maps,\r\nnum_maps, group, np->full_name);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\nif (num_configs) {\r\nret = add_map_configs(dev, map, reserved_maps,\r\nnum_maps, group, configs,\r\nnum_configs);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\n}\r\nret = 0;\r\nexit:\r\nkfree(configs);\r\nreturn ret;\r\n}\r\nstatic int samsung_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np_config,\r\nstruct pinctrl_map **map,\r\nunsigned *num_maps)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\nunsigned reserved_maps;\r\nstruct device_node *np;\r\nint ret;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\nreserved_maps = 0;\r\n*map = NULL;\r\n*num_maps = 0;\r\nif (!of_get_child_count(np_config))\r\nreturn samsung_dt_subnode_to_map(drvdata, pctldev->dev,\r\nnp_config, map,\r\n&reserved_maps,\r\nnum_maps);\r\nfor_each_child_of_node(np_config, np) {\r\nret = samsung_dt_subnode_to_map(drvdata, pctldev->dev, np, map,\r\n&reserved_maps, num_maps);\r\nif (ret < 0) {\r\nsamsung_dt_free_map(pctldev, *map, *num_maps);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int samsung_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\nreturn drvdata->nr_functions;\r\n}\r\nstatic const char *samsung_pinmux_get_fname(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\nreturn drvdata->pmx_functions[selector].name;\r\n}\r\nstatic int samsung_pinmux_get_groups(struct pinctrl_dev *pctldev,\r\nunsigned selector, const char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = drvdata->pmx_functions[selector].groups;\r\n*num_groups = drvdata->pmx_functions[selector].num_groups;\r\nreturn 0;\r\n}\r\nstatic void pin_to_reg_bank(struct samsung_pinctrl_drv_data *drvdata,\r\nunsigned pin, void __iomem **reg, u32 *offset,\r\nstruct samsung_pin_bank **bank)\r\n{\r\nstruct samsung_pin_bank *b;\r\nb = drvdata->pin_banks;\r\nwhile ((pin >= b->pin_base) &&\r\n((b->pin_base + b->nr_pins - 1) < pin))\r\nb++;\r\n*reg = drvdata->virt_base + b->pctl_offset;\r\n*offset = pin - b->pin_base;\r\nif (bank)\r\n*bank = b;\r\n}\r\nstatic void samsung_pinmux_setup(struct pinctrl_dev *pctldev, unsigned selector,\r\nunsigned group, bool enable)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\nconst struct samsung_pin_bank_type *type;\r\nstruct samsung_pin_bank *bank;\r\nvoid __iomem *reg;\r\nu32 mask, shift, data, pin_offset;\r\nunsigned long flags;\r\nconst struct samsung_pmx_func *func;\r\nconst struct samsung_pin_group *grp;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\nfunc = &drvdata->pmx_functions[selector];\r\ngrp = &drvdata->pin_groups[group];\r\npin_to_reg_bank(drvdata, grp->pins[0] - drvdata->pin_base,\r\n&reg, &pin_offset, &bank);\r\ntype = bank->type;\r\nmask = (1 << type->fld_width[PINCFG_TYPE_FUNC]) - 1;\r\nshift = pin_offset * type->fld_width[PINCFG_TYPE_FUNC];\r\nif (shift >= 32) {\r\nshift -= 32;\r\nreg += 4;\r\n}\r\nspin_lock_irqsave(&bank->slock, flags);\r\ndata = readl(reg + type->reg_offset[PINCFG_TYPE_FUNC]);\r\ndata &= ~(mask << shift);\r\nif (enable)\r\ndata |= func->val << shift;\r\nwritel(data, reg + type->reg_offset[PINCFG_TYPE_FUNC]);\r\nspin_unlock_irqrestore(&bank->slock, flags);\r\n}\r\nstatic int samsung_pinmux_set_mux(struct pinctrl_dev *pctldev,\r\nunsigned selector,\r\nunsigned group)\r\n{\r\nsamsung_pinmux_setup(pctldev, selector, group, true);\r\nreturn 0;\r\n}\r\nstatic int samsung_pinconf_rw(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *config, bool set)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\nconst struct samsung_pin_bank_type *type;\r\nstruct samsung_pin_bank *bank;\r\nvoid __iomem *reg_base;\r\nenum pincfg_type cfg_type = PINCFG_UNPACK_TYPE(*config);\r\nu32 data, width, pin_offset, mask, shift;\r\nu32 cfg_value, cfg_reg;\r\nunsigned long flags;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\npin_to_reg_bank(drvdata, pin - drvdata->pin_base, &reg_base,\r\n&pin_offset, &bank);\r\ntype = bank->type;\r\nif (cfg_type >= PINCFG_TYPE_NUM || !type->fld_width[cfg_type])\r\nreturn -EINVAL;\r\nwidth = type->fld_width[cfg_type];\r\ncfg_reg = type->reg_offset[cfg_type];\r\nspin_lock_irqsave(&bank->slock, flags);\r\nmask = (1 << width) - 1;\r\nshift = pin_offset * width;\r\ndata = readl(reg_base + cfg_reg);\r\nif (set) {\r\ncfg_value = PINCFG_UNPACK_VALUE(*config);\r\ndata &= ~(mask << shift);\r\ndata |= (cfg_value << shift);\r\nwritel(data, reg_base + cfg_reg);\r\n} else {\r\ndata >>= shift;\r\ndata &= mask;\r\n*config = PINCFG_PACK(cfg_type, data);\r\n}\r\nspin_unlock_irqrestore(&bank->slock, flags);\r\nreturn 0;\r\n}\r\nstatic int samsung_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < num_configs; i++) {\r\nret = samsung_pinconf_rw(pctldev, pin, &configs[i], true);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int samsung_pinconf_get(struct pinctrl_dev *pctldev, unsigned int pin,\r\nunsigned long *config)\r\n{\r\nreturn samsung_pinconf_rw(pctldev, pin, config, false);\r\n}\r\nstatic int samsung_pinconf_group_set(struct pinctrl_dev *pctldev,\r\nunsigned group, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\nconst unsigned int *pins;\r\nunsigned int cnt;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\npins = drvdata->pin_groups[group].pins;\r\nfor (cnt = 0; cnt < drvdata->pin_groups[group].num_pins; cnt++)\r\nsamsung_pinconf_set(pctldev, pins[cnt], configs, num_configs);\r\nreturn 0;\r\n}\r\nstatic int samsung_pinconf_group_get(struct pinctrl_dev *pctldev,\r\nunsigned int group, unsigned long *config)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\nconst unsigned int *pins;\r\ndrvdata = pinctrl_dev_get_drvdata(pctldev);\r\npins = drvdata->pin_groups[group].pins;\r\nsamsung_pinconf_get(pctldev, pins[0], config);\r\nreturn 0;\r\n}\r\nstatic void samsung_gpio_set(struct gpio_chip *gc, unsigned offset, int value)\r\n{\r\nstruct samsung_pin_bank *bank = gc_to_pin_bank(gc);\r\nconst struct samsung_pin_bank_type *type = bank->type;\r\nunsigned long flags;\r\nvoid __iomem *reg;\r\nu32 data;\r\nreg = bank->drvdata->virt_base + bank->pctl_offset;\r\nspin_lock_irqsave(&bank->slock, flags);\r\ndata = readl(reg + type->reg_offset[PINCFG_TYPE_DAT]);\r\ndata &= ~(1 << offset);\r\nif (value)\r\ndata |= 1 << offset;\r\nwritel(data, reg + type->reg_offset[PINCFG_TYPE_DAT]);\r\nspin_unlock_irqrestore(&bank->slock, flags);\r\n}\r\nstatic int samsung_gpio_get(struct gpio_chip *gc, unsigned offset)\r\n{\r\nvoid __iomem *reg;\r\nu32 data;\r\nstruct samsung_pin_bank *bank = gc_to_pin_bank(gc);\r\nconst struct samsung_pin_bank_type *type = bank->type;\r\nreg = bank->drvdata->virt_base + bank->pctl_offset;\r\ndata = readl(reg + type->reg_offset[PINCFG_TYPE_DAT]);\r\ndata >>= offset;\r\ndata &= 1;\r\nreturn data;\r\n}\r\nstatic int samsung_gpio_set_direction(struct gpio_chip *gc,\r\nunsigned offset, bool input)\r\n{\r\nconst struct samsung_pin_bank_type *type;\r\nstruct samsung_pin_bank *bank;\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\nvoid __iomem *reg;\r\nu32 data, mask, shift;\r\nunsigned long flags;\r\nbank = gc_to_pin_bank(gc);\r\ntype = bank->type;\r\ndrvdata = bank->drvdata;\r\nreg = drvdata->virt_base + bank->pctl_offset +\r\ntype->reg_offset[PINCFG_TYPE_FUNC];\r\nmask = (1 << type->fld_width[PINCFG_TYPE_FUNC]) - 1;\r\nshift = offset * type->fld_width[PINCFG_TYPE_FUNC];\r\nif (shift >= 32) {\r\nshift -= 32;\r\nreg += 4;\r\n}\r\nspin_lock_irqsave(&bank->slock, flags);\r\ndata = readl(reg);\r\ndata &= ~(mask << shift);\r\nif (!input)\r\ndata |= FUNC_OUTPUT << shift;\r\nwritel(data, reg);\r\nspin_unlock_irqrestore(&bank->slock, flags);\r\nreturn 0;\r\n}\r\nstatic int samsung_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\nreturn samsung_gpio_set_direction(gc, offset, true);\r\n}\r\nstatic int samsung_gpio_direction_output(struct gpio_chip *gc, unsigned offset,\r\nint value)\r\n{\r\nsamsung_gpio_set(gc, offset, value);\r\nreturn samsung_gpio_set_direction(gc, offset, false);\r\n}\r\nstatic int samsung_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct samsung_pin_bank *bank = gc_to_pin_bank(gc);\r\nunsigned int virq;\r\nif (!bank->irq_domain)\r\nreturn -ENXIO;\r\nvirq = irq_create_mapping(bank->irq_domain, offset);\r\nreturn (virq) ? : -ENXIO;\r\n}\r\nstatic struct samsung_pin_group *samsung_pinctrl_create_groups(\r\nstruct device *dev,\r\nstruct samsung_pinctrl_drv_data *drvdata,\r\nunsigned int *cnt)\r\n{\r\nstruct pinctrl_desc *ctrldesc = &drvdata->pctl;\r\nstruct samsung_pin_group *groups, *grp;\r\nconst struct pinctrl_pin_desc *pdesc;\r\nint i;\r\ngroups = devm_kzalloc(dev, ctrldesc->npins * sizeof(*groups),\r\nGFP_KERNEL);\r\nif (!groups)\r\nreturn ERR_PTR(-EINVAL);\r\ngrp = groups;\r\npdesc = ctrldesc->pins;\r\nfor (i = 0; i < ctrldesc->npins; ++i, ++pdesc, ++grp) {\r\ngrp->name = pdesc->name;\r\ngrp->pins = &pdesc->number;\r\ngrp->num_pins = 1;\r\n}\r\n*cnt = ctrldesc->npins;\r\nreturn groups;\r\n}\r\nstatic int samsung_pinctrl_create_function(struct device *dev,\r\nstruct samsung_pinctrl_drv_data *drvdata,\r\nstruct device_node *func_np,\r\nstruct samsung_pmx_func *func)\r\n{\r\nint npins;\r\nint ret;\r\nint i;\r\nif (of_property_read_u32(func_np, "samsung,pin-function", &func->val))\r\nreturn 0;\r\nnpins = of_property_count_strings(func_np, "samsung,pins");\r\nif (npins < 1) {\r\ndev_err(dev, "invalid pin list in %s node", func_np->name);\r\nreturn -EINVAL;\r\n}\r\nfunc->name = func_np->full_name;\r\nfunc->groups = devm_kzalloc(dev, npins * sizeof(char *), GFP_KERNEL);\r\nif (!func->groups)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < npins; ++i) {\r\nconst char *gname;\r\nret = of_property_read_string_index(func_np, "samsung,pins",\r\ni, &gname);\r\nif (ret) {\r\ndev_err(dev,\r\n"failed to read pin name %d from %s node\n",\r\ni, func_np->name);\r\nreturn ret;\r\n}\r\nfunc->groups[i] = gname;\r\n}\r\nfunc->num_groups = npins;\r\nreturn 1;\r\n}\r\nstatic struct samsung_pmx_func *samsung_pinctrl_create_functions(\r\nstruct device *dev,\r\nstruct samsung_pinctrl_drv_data *drvdata,\r\nunsigned int *cnt)\r\n{\r\nstruct samsung_pmx_func *functions, *func;\r\nstruct device_node *dev_np = dev->of_node;\r\nstruct device_node *cfg_np;\r\nunsigned int func_cnt = 0;\r\nint ret;\r\nfor_each_child_of_node(dev_np, cfg_np) {\r\nstruct device_node *func_np;\r\nif (!of_get_child_count(cfg_np)) {\r\nif (!of_find_property(cfg_np,\r\n"samsung,pin-function", NULL))\r\ncontinue;\r\n++func_cnt;\r\ncontinue;\r\n}\r\nfor_each_child_of_node(cfg_np, func_np) {\r\nif (!of_find_property(func_np,\r\n"samsung,pin-function", NULL))\r\ncontinue;\r\n++func_cnt;\r\n}\r\n}\r\nfunctions = devm_kzalloc(dev, func_cnt * sizeof(*functions),\r\nGFP_KERNEL);\r\nif (!functions) {\r\ndev_err(dev, "failed to allocate memory for function list\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nfunc = functions;\r\nfunc_cnt = 0;\r\nfor_each_child_of_node(dev_np, cfg_np) {\r\nstruct device_node *func_np;\r\nif (!of_get_child_count(cfg_np)) {\r\nret = samsung_pinctrl_create_function(dev, drvdata,\r\ncfg_np, func);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nif (ret > 0) {\r\n++func;\r\n++func_cnt;\r\n}\r\ncontinue;\r\n}\r\nfor_each_child_of_node(cfg_np, func_np) {\r\nret = samsung_pinctrl_create_function(dev, drvdata,\r\nfunc_np, func);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nif (ret > 0) {\r\n++func;\r\n++func_cnt;\r\n}\r\n}\r\n}\r\n*cnt = func_cnt;\r\nreturn functions;\r\n}\r\nstatic int samsung_pinctrl_parse_dt(struct platform_device *pdev,\r\nstruct samsung_pinctrl_drv_data *drvdata)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct samsung_pin_group *groups;\r\nstruct samsung_pmx_func *functions;\r\nunsigned int grp_cnt = 0, func_cnt = 0;\r\ngroups = samsung_pinctrl_create_groups(dev, drvdata, &grp_cnt);\r\nif (IS_ERR(groups)) {\r\ndev_err(dev, "failed to parse pin groups\n");\r\nreturn PTR_ERR(groups);\r\n}\r\nfunctions = samsung_pinctrl_create_functions(dev, drvdata, &func_cnt);\r\nif (IS_ERR(functions)) {\r\ndev_err(dev, "failed to parse pin functions\n");\r\nreturn PTR_ERR(groups);\r\n}\r\ndrvdata->pin_groups = groups;\r\ndrvdata->nr_groups = grp_cnt;\r\ndrvdata->pmx_functions = functions;\r\ndrvdata->nr_functions = func_cnt;\r\nreturn 0;\r\n}\r\nstatic int samsung_pinctrl_register(struct platform_device *pdev,\r\nstruct samsung_pinctrl_drv_data *drvdata)\r\n{\r\nstruct pinctrl_desc *ctrldesc = &drvdata->pctl;\r\nstruct pinctrl_pin_desc *pindesc, *pdesc;\r\nstruct samsung_pin_bank *pin_bank;\r\nchar *pin_names;\r\nint pin, bank, ret;\r\nctrldesc->name = "samsung-pinctrl";\r\nctrldesc->owner = THIS_MODULE;\r\nctrldesc->pctlops = &samsung_pctrl_ops;\r\nctrldesc->pmxops = &samsung_pinmux_ops;\r\nctrldesc->confops = &samsung_pinconf_ops;\r\npindesc = devm_kzalloc(&pdev->dev, sizeof(*pindesc) *\r\ndrvdata->nr_pins, GFP_KERNEL);\r\nif (!pindesc) {\r\ndev_err(&pdev->dev, "mem alloc for pin descriptors failed\n");\r\nreturn -ENOMEM;\r\n}\r\nctrldesc->pins = pindesc;\r\nctrldesc->npins = drvdata->nr_pins;\r\nfor (pin = 0, pdesc = pindesc; pin < ctrldesc->npins; pin++, pdesc++)\r\npdesc->number = pin + drvdata->pin_base;\r\npin_names = devm_kzalloc(&pdev->dev, sizeof(char) * PIN_NAME_LENGTH *\r\ndrvdata->nr_pins, GFP_KERNEL);\r\nif (!pin_names) {\r\ndev_err(&pdev->dev, "mem alloc for pin names failed\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (bank = 0; bank < drvdata->nr_banks; bank++) {\r\npin_bank = &drvdata->pin_banks[bank];\r\nfor (pin = 0; pin < pin_bank->nr_pins; pin++) {\r\nsprintf(pin_names, "%s-%d", pin_bank->name, pin);\r\npdesc = pindesc + pin_bank->pin_base + pin;\r\npdesc->name = pin_names;\r\npin_names += PIN_NAME_LENGTH;\r\n}\r\n}\r\nret = samsung_pinctrl_parse_dt(pdev, drvdata);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->pctl_dev = pinctrl_register(ctrldesc, &pdev->dev, drvdata);\r\nif (!drvdata->pctl_dev) {\r\ndev_err(&pdev->dev, "could not register pinctrl driver\n");\r\nreturn -EINVAL;\r\n}\r\nfor (bank = 0; bank < drvdata->nr_banks; ++bank) {\r\npin_bank = &drvdata->pin_banks[bank];\r\npin_bank->grange.name = pin_bank->name;\r\npin_bank->grange.id = bank;\r\npin_bank->grange.pin_base = drvdata->pin_base\r\n+ pin_bank->pin_base;\r\npin_bank->grange.base = pin_bank->gpio_chip.base;\r\npin_bank->grange.npins = pin_bank->gpio_chip.ngpio;\r\npin_bank->grange.gc = &pin_bank->gpio_chip;\r\npinctrl_add_gpio_range(drvdata->pctl_dev, &pin_bank->grange);\r\n}\r\nreturn 0;\r\n}\r\nstatic int samsung_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn pinctrl_request_gpio(chip->base + offset);\r\n}\r\nstatic void samsung_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\npinctrl_free_gpio(chip->base + offset);\r\n}\r\nstatic int samsung_gpiolib_register(struct platform_device *pdev,\r\nstruct samsung_pinctrl_drv_data *drvdata)\r\n{\r\nstruct samsung_pin_bank *bank = drvdata->pin_banks;\r\nstruct gpio_chip *gc;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < drvdata->nr_banks; ++i, ++bank) {\r\nbank->gpio_chip = samsung_gpiolib_chip;\r\ngc = &bank->gpio_chip;\r\ngc->base = drvdata->pin_base + bank->pin_base;\r\ngc->ngpio = bank->nr_pins;\r\ngc->dev = &pdev->dev;\r\ngc->of_node = bank->of_node;\r\ngc->label = bank->name;\r\nret = gpiochip_add(gc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register gpio_chip %s, error code: %d\n",\r\ngc->label, ret);\r\ngoto fail;\r\n}\r\n}\r\nreturn 0;\r\nfail:\r\nfor (--i, --bank; i >= 0; --i, --bank)\r\ngpiochip_remove(&bank->gpio_chip);\r\nreturn ret;\r\n}\r\nstatic int samsung_gpiolib_unregister(struct platform_device *pdev,\r\nstruct samsung_pinctrl_drv_data *drvdata)\r\n{\r\nstruct samsung_pin_bank *bank = drvdata->pin_banks;\r\nint i;\r\nfor (i = 0; i < drvdata->nr_banks; ++i, ++bank)\r\ngpiochip_remove(&bank->gpio_chip);\r\nreturn 0;\r\n}\r\nstatic const struct samsung_pin_ctrl *\r\nsamsung_pinctrl_get_soc_data(struct samsung_pinctrl_drv_data *d,\r\nstruct platform_device *pdev)\r\n{\r\nint id;\r\nconst struct of_device_id *match;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device_node *np;\r\nconst struct samsung_pin_bank_data *bdata;\r\nconst struct samsung_pin_ctrl *ctrl;\r\nstruct samsung_pin_bank *bank;\r\nint i;\r\nid = of_alias_get_id(node, "pinctrl");\r\nif (id < 0) {\r\ndev_err(&pdev->dev, "failed to get alias id\n");\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\nmatch = of_match_node(samsung_pinctrl_dt_match, node);\r\nctrl = (struct samsung_pin_ctrl *)match->data + id;\r\nd->suspend = ctrl->suspend;\r\nd->resume = ctrl->resume;\r\nd->nr_banks = ctrl->nr_banks;\r\nd->pin_banks = devm_kcalloc(&pdev->dev, d->nr_banks,\r\nsizeof(*d->pin_banks), GFP_KERNEL);\r\nif (!d->pin_banks)\r\nreturn ERR_PTR(-ENOMEM);\r\nbank = d->pin_banks;\r\nbdata = ctrl->pin_banks;\r\nfor (i = 0; i < ctrl->nr_banks; ++i, ++bdata, ++bank) {\r\nbank->type = bdata->type;\r\nbank->pctl_offset = bdata->pctl_offset;\r\nbank->nr_pins = bdata->nr_pins;\r\nbank->eint_func = bdata->eint_func;\r\nbank->eint_type = bdata->eint_type;\r\nbank->eint_mask = bdata->eint_mask;\r\nbank->eint_offset = bdata->eint_offset;\r\nbank->name = bdata->name;\r\nspin_lock_init(&bank->slock);\r\nbank->drvdata = d;\r\nbank->pin_base = d->nr_pins;\r\nd->nr_pins += bank->nr_pins;\r\n}\r\nfor_each_child_of_node(node, np) {\r\nif (!of_find_property(np, "gpio-controller", NULL))\r\ncontinue;\r\nbank = d->pin_banks;\r\nfor (i = 0; i < d->nr_banks; ++i, ++bank) {\r\nif (!strcmp(bank->name, np->name)) {\r\nbank->of_node = np;\r\nbreak;\r\n}\r\n}\r\n}\r\nd->pin_base = pin_base;\r\npin_base += d->nr_pins;\r\nreturn ctrl;\r\n}\r\nstatic int samsung_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\nconst struct samsung_pin_ctrl *ctrl;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nint ret;\r\nif (!dev->of_node) {\r\ndev_err(dev, "device tree node not found\n");\r\nreturn -ENODEV;\r\n}\r\ndrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\r\nif (!drvdata) {\r\ndev_err(dev, "failed to allocate memory for driver's "\r\n"private data\n");\r\nreturn -ENOMEM;\r\n}\r\nctrl = samsung_pinctrl_get_soc_data(drvdata, pdev);\r\nif (IS_ERR(ctrl)) {\r\ndev_err(&pdev->dev, "driver data not available\n");\r\nreturn PTR_ERR(ctrl);\r\n}\r\ndrvdata->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndrvdata->virt_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(drvdata->virt_base))\r\nreturn PTR_ERR(drvdata->virt_base);\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res)\r\ndrvdata->irq = res->start;\r\nret = samsung_gpiolib_register(pdev, drvdata);\r\nif (ret)\r\nreturn ret;\r\nret = samsung_pinctrl_register(pdev, drvdata);\r\nif (ret) {\r\nsamsung_gpiolib_unregister(pdev, drvdata);\r\nreturn ret;\r\n}\r\nif (ctrl->eint_gpio_init)\r\nctrl->eint_gpio_init(drvdata);\r\nif (ctrl->eint_wkup_init)\r\nctrl->eint_wkup_init(drvdata);\r\nplatform_set_drvdata(pdev, drvdata);\r\nlist_add_tail(&drvdata->node, &drvdata_list);\r\nreturn 0;\r\n}\r\nstatic void samsung_pinctrl_suspend_dev(\r\nstruct samsung_pinctrl_drv_data *drvdata)\r\n{\r\nvoid __iomem *virt_base = drvdata->virt_base;\r\nint i;\r\nfor (i = 0; i < drvdata->nr_banks; i++) {\r\nstruct samsung_pin_bank *bank = &drvdata->pin_banks[i];\r\nvoid __iomem *reg = virt_base + bank->pctl_offset;\r\nconst u8 *offs = bank->type->reg_offset;\r\nconst u8 *widths = bank->type->fld_width;\r\nenum pincfg_type type;\r\nif (!widths[PINCFG_TYPE_CON_PDN])\r\ncontinue;\r\nfor (type = 0; type < PINCFG_TYPE_NUM; type++)\r\nif (widths[type])\r\nbank->pm_save[type] = readl(reg + offs[type]);\r\nif (widths[PINCFG_TYPE_FUNC] * bank->nr_pins > 32) {\r\nbank->pm_save[PINCFG_TYPE_NUM] =\r\nreadl(reg + offs[PINCFG_TYPE_FUNC] + 4);\r\npr_debug("Save %s @ %p (con %#010x %08x)\n",\r\nbank->name, reg,\r\nbank->pm_save[PINCFG_TYPE_FUNC],\r\nbank->pm_save[PINCFG_TYPE_NUM]);\r\n} else {\r\npr_debug("Save %s @ %p (con %#010x)\n", bank->name,\r\nreg, bank->pm_save[PINCFG_TYPE_FUNC]);\r\n}\r\n}\r\nif (drvdata->suspend)\r\ndrvdata->suspend(drvdata);\r\n}\r\nstatic void samsung_pinctrl_resume_dev(struct samsung_pinctrl_drv_data *drvdata)\r\n{\r\nvoid __iomem *virt_base = drvdata->virt_base;\r\nint i;\r\nif (drvdata->resume)\r\ndrvdata->resume(drvdata);\r\nfor (i = 0; i < drvdata->nr_banks; i++) {\r\nstruct samsung_pin_bank *bank = &drvdata->pin_banks[i];\r\nvoid __iomem *reg = virt_base + bank->pctl_offset;\r\nconst u8 *offs = bank->type->reg_offset;\r\nconst u8 *widths = bank->type->fld_width;\r\nenum pincfg_type type;\r\nif (!widths[PINCFG_TYPE_CON_PDN])\r\ncontinue;\r\nif (widths[PINCFG_TYPE_FUNC] * bank->nr_pins > 32) {\r\npr_debug("%s @ %p (con %#010x %08x => %#010x %08x)\n",\r\nbank->name, reg,\r\nreadl(reg + offs[PINCFG_TYPE_FUNC]),\r\nreadl(reg + offs[PINCFG_TYPE_FUNC] + 4),\r\nbank->pm_save[PINCFG_TYPE_FUNC],\r\nbank->pm_save[PINCFG_TYPE_NUM]);\r\nwritel(bank->pm_save[PINCFG_TYPE_NUM],\r\nreg + offs[PINCFG_TYPE_FUNC] + 4);\r\n} else {\r\npr_debug("%s @ %p (con %#010x => %#010x)\n", bank->name,\r\nreg, readl(reg + offs[PINCFG_TYPE_FUNC]),\r\nbank->pm_save[PINCFG_TYPE_FUNC]);\r\n}\r\nfor (type = 0; type < PINCFG_TYPE_NUM; type++)\r\nif (widths[type])\r\nwritel(bank->pm_save[type], reg + offs[type]);\r\n}\r\n}\r\nstatic int samsung_pinctrl_suspend(void)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\nlist_for_each_entry(drvdata, &drvdata_list, node) {\r\nsamsung_pinctrl_suspend_dev(drvdata);\r\n}\r\nreturn 0;\r\n}\r\nstatic void samsung_pinctrl_resume(void)\r\n{\r\nstruct samsung_pinctrl_drv_data *drvdata;\r\nlist_for_each_entry_reverse(drvdata, &drvdata_list, node) {\r\nsamsung_pinctrl_resume_dev(drvdata);\r\n}\r\n}\r\nstatic int __init samsung_pinctrl_drv_register(void)\r\n{\r\nregister_syscore_ops(&samsung_pinctrl_syscore_ops);\r\nreturn platform_driver_register(&samsung_pinctrl_driver);\r\n}\r\nstatic void __exit samsung_pinctrl_drv_unregister(void)\r\n{\r\nplatform_driver_unregister(&samsung_pinctrl_driver);\r\n}
