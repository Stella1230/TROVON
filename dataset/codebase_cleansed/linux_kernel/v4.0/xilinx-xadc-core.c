static void xadc_write_reg(struct xadc *xadc, unsigned int reg,\r\nuint32_t val)\r\n{\r\nwritel(val, xadc->base + reg);\r\n}\r\nstatic void xadc_read_reg(struct xadc *xadc, unsigned int reg,\r\nuint32_t *val)\r\n{\r\n*val = readl(xadc->base + reg);\r\n}\r\nstatic void xadc_zynq_write_fifo(struct xadc *xadc, uint32_t *cmd,\r\nunsigned int n)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < n; i++)\r\nxadc_write_reg(xadc, XADC_ZYNQ_REG_CFIFO, cmd[i]);\r\n}\r\nstatic void xadc_zynq_drain_fifo(struct xadc *xadc)\r\n{\r\nuint32_t status, tmp;\r\nxadc_read_reg(xadc, XADC_ZYNQ_REG_STATUS, &status);\r\nwhile (!(status & XADC_ZYNQ_STATUS_DFIFOE)) {\r\nxadc_read_reg(xadc, XADC_ZYNQ_REG_DFIFO, &tmp);\r\nxadc_read_reg(xadc, XADC_ZYNQ_REG_STATUS, &status);\r\n}\r\n}\r\nstatic void xadc_zynq_update_intmsk(struct xadc *xadc, unsigned int mask,\r\nunsigned int val)\r\n{\r\nxadc->zynq_intmask &= ~mask;\r\nxadc->zynq_intmask |= val;\r\nxadc_write_reg(xadc, XADC_ZYNQ_REG_INTMSK,\r\nxadc->zynq_intmask | xadc->zynq_masked_alarm);\r\n}\r\nstatic int xadc_zynq_write_adc_reg(struct xadc *xadc, unsigned int reg,\r\nuint16_t val)\r\n{\r\nuint32_t cmd[1];\r\nuint32_t tmp;\r\nint ret;\r\nspin_lock_irq(&xadc->lock);\r\nxadc_zynq_update_intmsk(xadc, XADC_ZYNQ_INT_DFIFO_GTH,\r\nXADC_ZYNQ_INT_DFIFO_GTH);\r\nreinit_completion(&xadc->completion);\r\ncmd[0] = XADC_ZYNQ_CMD(XADC_ZYNQ_CMD_WRITE, reg, val);\r\nxadc_zynq_write_fifo(xadc, cmd, ARRAY_SIZE(cmd));\r\nxadc_read_reg(xadc, XADC_ZYNQ_REG_CFG, &tmp);\r\ntmp &= ~XADC_ZYNQ_CFG_DFIFOTH_MASK;\r\ntmp |= 0 << XADC_ZYNQ_CFG_DFIFOTH_OFFSET;\r\nxadc_write_reg(xadc, XADC_ZYNQ_REG_CFG, tmp);\r\nxadc_zynq_update_intmsk(xadc, XADC_ZYNQ_INT_DFIFO_GTH, 0);\r\nspin_unlock_irq(&xadc->lock);\r\nret = wait_for_completion_interruptible_timeout(&xadc->completion, HZ);\r\nif (ret == 0)\r\nret = -EIO;\r\nelse\r\nret = 0;\r\nxadc_read_reg(xadc, XADC_ZYNQ_REG_DFIFO, &tmp);\r\nreturn ret;\r\n}\r\nstatic int xadc_zynq_read_adc_reg(struct xadc *xadc, unsigned int reg,\r\nuint16_t *val)\r\n{\r\nuint32_t cmd[2];\r\nuint32_t resp, tmp;\r\nint ret;\r\ncmd[0] = XADC_ZYNQ_CMD(XADC_ZYNQ_CMD_READ, reg, 0);\r\ncmd[1] = XADC_ZYNQ_CMD(XADC_ZYNQ_CMD_NOP, 0, 0);\r\nspin_lock_irq(&xadc->lock);\r\nxadc_zynq_update_intmsk(xadc, XADC_ZYNQ_INT_DFIFO_GTH,\r\nXADC_ZYNQ_INT_DFIFO_GTH);\r\nxadc_zynq_drain_fifo(xadc);\r\nreinit_completion(&xadc->completion);\r\nxadc_zynq_write_fifo(xadc, cmd, ARRAY_SIZE(cmd));\r\nxadc_read_reg(xadc, XADC_ZYNQ_REG_CFG, &tmp);\r\ntmp &= ~XADC_ZYNQ_CFG_DFIFOTH_MASK;\r\ntmp |= 1 << XADC_ZYNQ_CFG_DFIFOTH_OFFSET;\r\nxadc_write_reg(xadc, XADC_ZYNQ_REG_CFG, tmp);\r\nxadc_zynq_update_intmsk(xadc, XADC_ZYNQ_INT_DFIFO_GTH, 0);\r\nspin_unlock_irq(&xadc->lock);\r\nret = wait_for_completion_interruptible_timeout(&xadc->completion, HZ);\r\nif (ret == 0)\r\nret = -EIO;\r\nif (ret < 0)\r\nreturn ret;\r\nxadc_read_reg(xadc, XADC_ZYNQ_REG_DFIFO, &resp);\r\nxadc_read_reg(xadc, XADC_ZYNQ_REG_DFIFO, &resp);\r\n*val = resp & 0xffff;\r\nreturn 0;\r\n}\r\nstatic unsigned int xadc_zynq_transform_alarm(unsigned int alarm)\r\n{\r\nreturn ((alarm & 0x80) >> 4) |\r\n((alarm & 0x78) << 1) |\r\n(alarm & 0x07);\r\n}\r\nstatic void xadc_zynq_unmask_worker(struct work_struct *work)\r\n{\r\nstruct xadc *xadc = container_of(work, struct xadc, zynq_unmask_work.work);\r\nunsigned int misc_sts, unmask;\r\nxadc_read_reg(xadc, XADC_ZYNQ_REG_STATUS, &misc_sts);\r\nmisc_sts &= XADC_ZYNQ_INT_ALARM_MASK;\r\nspin_lock_irq(&xadc->lock);\r\nunmask = (xadc->zynq_masked_alarm ^ misc_sts) & xadc->zynq_masked_alarm;\r\nxadc->zynq_masked_alarm &= misc_sts;\r\nxadc->zynq_masked_alarm &= ~xadc->zynq_intmask;\r\nxadc_write_reg(xadc, XADC_ZYNQ_REG_INTSTS, unmask);\r\nxadc_zynq_update_intmsk(xadc, 0, 0);\r\nspin_unlock_irq(&xadc->lock);\r\nif (xadc->zynq_masked_alarm) {\r\nschedule_delayed_work(&xadc->zynq_unmask_work,\r\nmsecs_to_jiffies(XADC_ZYNQ_UNMASK_TIMEOUT));\r\n}\r\n}\r\nstatic irqreturn_t xadc_zynq_threaded_interrupt_handler(int irq, void *devid)\r\n{\r\nstruct iio_dev *indio_dev = devid;\r\nstruct xadc *xadc = iio_priv(indio_dev);\r\nunsigned int alarm;\r\nspin_lock_irq(&xadc->lock);\r\nalarm = xadc->zynq_alarm;\r\nxadc->zynq_alarm = 0;\r\nspin_unlock_irq(&xadc->lock);\r\nxadc_handle_events(indio_dev, xadc_zynq_transform_alarm(alarm));\r\nschedule_delayed_work(&xadc->zynq_unmask_work,\r\nmsecs_to_jiffies(XADC_ZYNQ_UNMASK_TIMEOUT));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t xadc_zynq_interrupt_handler(int irq, void *devid)\r\n{\r\nstruct iio_dev *indio_dev = devid;\r\nstruct xadc *xadc = iio_priv(indio_dev);\r\nirqreturn_t ret = IRQ_HANDLED;\r\nuint32_t status;\r\nxadc_read_reg(xadc, XADC_ZYNQ_REG_INTSTS, &status);\r\nstatus &= ~(xadc->zynq_intmask | xadc->zynq_masked_alarm);\r\nif (!status)\r\nreturn IRQ_NONE;\r\nspin_lock(&xadc->lock);\r\nxadc_write_reg(xadc, XADC_ZYNQ_REG_INTSTS, status);\r\nif (status & XADC_ZYNQ_INT_DFIFO_GTH) {\r\nxadc_zynq_update_intmsk(xadc, XADC_ZYNQ_INT_DFIFO_GTH,\r\nXADC_ZYNQ_INT_DFIFO_GTH);\r\ncomplete(&xadc->completion);\r\n}\r\nstatus &= XADC_ZYNQ_INT_ALARM_MASK;\r\nif (status) {\r\nxadc->zynq_alarm |= status;\r\nxadc->zynq_masked_alarm |= status;\r\nxadc_zynq_update_intmsk(xadc, 0, 0);\r\nret = IRQ_WAKE_THREAD;\r\n}\r\nspin_unlock(&xadc->lock);\r\nreturn ret;\r\n}\r\nstatic int xadc_zynq_setup(struct platform_device *pdev,\r\nstruct iio_dev *indio_dev, int irq)\r\n{\r\nstruct xadc *xadc = iio_priv(indio_dev);\r\nunsigned long pcap_rate;\r\nunsigned int tck_div;\r\nunsigned int div;\r\nunsigned int igap;\r\nunsigned int tck_rate;\r\nigap = XADC_ZYNQ_IGAP_DEFAULT;\r\ntck_rate = XADC_ZYNQ_TCK_RATE_MAX;\r\nxadc->zynq_intmask = ~0;\r\npcap_rate = clk_get_rate(xadc->clk);\r\nif (tck_rate > XADC_ZYNQ_TCK_RATE_MAX)\r\ntck_rate = XADC_ZYNQ_TCK_RATE_MAX;\r\nif (tck_rate > pcap_rate / 2) {\r\ndiv = 2;\r\n} else {\r\ndiv = pcap_rate / tck_rate;\r\nif (pcap_rate / div > XADC_ZYNQ_TCK_RATE_MAX)\r\ndiv++;\r\n}\r\nif (div <= 3)\r\ntck_div = XADC_ZYNQ_CFG_TCKRATE_DIV2;\r\nelse if (div <= 7)\r\ntck_div = XADC_ZYNQ_CFG_TCKRATE_DIV4;\r\nelse if (div <= 15)\r\ntck_div = XADC_ZYNQ_CFG_TCKRATE_DIV8;\r\nelse\r\ntck_div = XADC_ZYNQ_CFG_TCKRATE_DIV16;\r\nxadc_write_reg(xadc, XADC_ZYNQ_REG_CTL, XADC_ZYNQ_CTL_RESET);\r\nxadc_write_reg(xadc, XADC_ZYNQ_REG_CTL, 0);\r\nxadc_write_reg(xadc, XADC_ZYNQ_REG_INTSTS, ~0);\r\nxadc_write_reg(xadc, XADC_ZYNQ_REG_INTMSK, xadc->zynq_intmask);\r\nxadc_write_reg(xadc, XADC_ZYNQ_REG_CFG, XADC_ZYNQ_CFG_ENABLE |\r\nXADC_ZYNQ_CFG_REDGE | XADC_ZYNQ_CFG_WEDGE |\r\ntck_div | XADC_ZYNQ_CFG_IGAP(igap));\r\nreturn 0;\r\n}\r\nstatic unsigned long xadc_zynq_get_dclk_rate(struct xadc *xadc)\r\n{\r\nunsigned int div;\r\nuint32_t val;\r\nxadc_read_reg(xadc, XADC_ZYNQ_REG_CFG, &val);\r\nswitch (val & XADC_ZYNQ_CFG_TCKRATE_MASK) {\r\ncase XADC_ZYNQ_CFG_TCKRATE_DIV4:\r\ndiv = 4;\r\nbreak;\r\ncase XADC_ZYNQ_CFG_TCKRATE_DIV8:\r\ndiv = 8;\r\nbreak;\r\ncase XADC_ZYNQ_CFG_TCKRATE_DIV16:\r\ndiv = 16;\r\nbreak;\r\ndefault:\r\ndiv = 2;\r\nbreak;\r\n}\r\nreturn clk_get_rate(xadc->clk) / div;\r\n}\r\nstatic void xadc_zynq_update_alarm(struct xadc *xadc, unsigned int alarm)\r\n{\r\nunsigned long flags;\r\nuint32_t status;\r\nalarm = ((alarm & 0x08) << 4) | ((alarm & 0xf0) >> 1) | (alarm & 0x07);\r\nspin_lock_irqsave(&xadc->lock, flags);\r\nxadc_read_reg(xadc, XADC_ZYNQ_REG_INTSTS, &status);\r\nxadc_write_reg(xadc, XADC_ZYNQ_REG_INTSTS, status & alarm);\r\nxadc_zynq_update_intmsk(xadc, XADC_ZYNQ_INT_ALARM_MASK,\r\n~alarm & XADC_ZYNQ_INT_ALARM_MASK);\r\nspin_unlock_irqrestore(&xadc->lock, flags);\r\n}\r\nstatic int xadc_axi_read_adc_reg(struct xadc *xadc, unsigned int reg,\r\nuint16_t *val)\r\n{\r\nuint32_t val32;\r\nxadc_read_reg(xadc, XADC_AXI_ADC_REG_OFFSET + reg * 4, &val32);\r\n*val = val32 & 0xffff;\r\nreturn 0;\r\n}\r\nstatic int xadc_axi_write_adc_reg(struct xadc *xadc, unsigned int reg,\r\nuint16_t val)\r\n{\r\nxadc_write_reg(xadc, XADC_AXI_ADC_REG_OFFSET + reg * 4, val);\r\nreturn 0;\r\n}\r\nstatic int xadc_axi_setup(struct platform_device *pdev,\r\nstruct iio_dev *indio_dev, int irq)\r\n{\r\nstruct xadc *xadc = iio_priv(indio_dev);\r\nxadc_write_reg(xadc, XADC_AXI_REG_RESET, XADC_AXI_RESET_MAGIC);\r\nxadc_write_reg(xadc, XADC_AXI_REG_GIER, XADC_AXI_GIER_ENABLE);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t xadc_axi_interrupt_handler(int irq, void *devid)\r\n{\r\nstruct iio_dev *indio_dev = devid;\r\nstruct xadc *xadc = iio_priv(indio_dev);\r\nuint32_t status, mask;\r\nunsigned int events;\r\nxadc_read_reg(xadc, XADC_AXI_REG_IPISR, &status);\r\nxadc_read_reg(xadc, XADC_AXI_REG_IPIER, &mask);\r\nstatus &= mask;\r\nif (!status)\r\nreturn IRQ_NONE;\r\nif ((status & XADC_AXI_INT_EOS) && xadc->trigger)\r\niio_trigger_poll(xadc->trigger);\r\nif (status & XADC_AXI_INT_ALARM_MASK) {\r\nevents = (status & 0x000e) >> 1;\r\nevents |= (status & 0x0001) << 3;\r\nevents |= (status & 0x3c00) >> 6;\r\nxadc_handle_events(indio_dev, events);\r\n}\r\nxadc_write_reg(xadc, XADC_AXI_REG_IPISR, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void xadc_axi_update_alarm(struct xadc *xadc, unsigned int alarm)\r\n{\r\nuint32_t val;\r\nunsigned long flags;\r\nalarm = ((alarm & 0x07) << 1) | ((alarm & 0x08) >> 3) |\r\n((alarm & 0xf0) << 6);\r\nspin_lock_irqsave(&xadc->lock, flags);\r\nxadc_read_reg(xadc, XADC_AXI_REG_IPIER, &val);\r\nval &= ~XADC_AXI_INT_ALARM_MASK;\r\nval |= alarm;\r\nxadc_write_reg(xadc, XADC_AXI_REG_IPIER, val);\r\nspin_unlock_irqrestore(&xadc->lock, flags);\r\n}\r\nstatic unsigned long xadc_axi_get_dclk(struct xadc *xadc)\r\n{\r\nreturn clk_get_rate(xadc->clk);\r\n}\r\nstatic int _xadc_update_adc_reg(struct xadc *xadc, unsigned int reg,\r\nuint16_t mask, uint16_t val)\r\n{\r\nuint16_t tmp;\r\nint ret;\r\nret = _xadc_read_adc_reg(xadc, reg, &tmp);\r\nif (ret)\r\nreturn ret;\r\nreturn _xadc_write_adc_reg(xadc, reg, (tmp & ~mask) | val);\r\n}\r\nstatic int xadc_update_adc_reg(struct xadc *xadc, unsigned int reg,\r\nuint16_t mask, uint16_t val)\r\n{\r\nint ret;\r\nmutex_lock(&xadc->mutex);\r\nret = _xadc_update_adc_reg(xadc, reg, mask, val);\r\nmutex_unlock(&xadc->mutex);\r\nreturn ret;\r\n}\r\nstatic unsigned long xadc_get_dclk_rate(struct xadc *xadc)\r\n{\r\nreturn xadc->ops->get_dclk_rate(xadc);\r\n}\r\nstatic int xadc_update_scan_mode(struct iio_dev *indio_dev,\r\nconst unsigned long *mask)\r\n{\r\nstruct xadc *xadc = iio_priv(indio_dev);\r\nunsigned int n;\r\nn = bitmap_weight(mask, indio_dev->masklength);\r\nkfree(xadc->data);\r\nxadc->data = kcalloc(n, sizeof(*xadc->data), GFP_KERNEL);\r\nif (!xadc->data)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic unsigned int xadc_scan_index_to_channel(unsigned int scan_index)\r\n{\r\nswitch (scan_index) {\r\ncase 5:\r\nreturn XADC_REG_VCCPINT;\r\ncase 6:\r\nreturn XADC_REG_VCCPAUX;\r\ncase 7:\r\nreturn XADC_REG_VCCO_DDR;\r\ncase 8:\r\nreturn XADC_REG_TEMP;\r\ncase 9:\r\nreturn XADC_REG_VCCINT;\r\ncase 10:\r\nreturn XADC_REG_VCCAUX;\r\ncase 11:\r\nreturn XADC_REG_VPVN;\r\ncase 12:\r\nreturn XADC_REG_VREFP;\r\ncase 13:\r\nreturn XADC_REG_VREFN;\r\ncase 14:\r\nreturn XADC_REG_VCCBRAM;\r\ndefault:\r\nreturn XADC_REG_VAUX(scan_index - 16);\r\n}\r\n}\r\nstatic irqreturn_t xadc_trigger_handler(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct xadc *xadc = iio_priv(indio_dev);\r\nunsigned int chan;\r\nint i, j;\r\nif (!xadc->data)\r\ngoto out;\r\nj = 0;\r\nfor_each_set_bit(i, indio_dev->active_scan_mask,\r\nindio_dev->masklength) {\r\nchan = xadc_scan_index_to_channel(i);\r\nxadc_read_adc_reg(xadc, chan, &xadc->data[j]);\r\nj++;\r\n}\r\niio_push_to_buffers(indio_dev, xadc->data);\r\nout:\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int xadc_trigger_set_state(struct iio_trigger *trigger, bool state)\r\n{\r\nstruct xadc *xadc = iio_trigger_get_drvdata(trigger);\r\nunsigned long flags;\r\nunsigned int convst;\r\nunsigned int val;\r\nint ret = 0;\r\nmutex_lock(&xadc->mutex);\r\nif (state) {\r\nif (xadc->trigger != NULL) {\r\nret = -EBUSY;\r\ngoto err_out;\r\n} else {\r\nxadc->trigger = trigger;\r\nif (trigger == xadc->convst_trigger)\r\nconvst = XADC_CONF0_EC;\r\nelse\r\nconvst = 0;\r\n}\r\nret = _xadc_update_adc_reg(xadc, XADC_REG_CONF1, XADC_CONF0_EC,\r\nconvst);\r\nif (ret)\r\ngoto err_out;\r\n} else {\r\nxadc->trigger = NULL;\r\n}\r\nspin_lock_irqsave(&xadc->lock, flags);\r\nxadc_read_reg(xadc, XADC_AXI_REG_IPIER, &val);\r\nxadc_write_reg(xadc, XADC_AXI_REG_IPISR, val & XADC_AXI_INT_EOS);\r\nif (state)\r\nval |= XADC_AXI_INT_EOS;\r\nelse\r\nval &= ~XADC_AXI_INT_EOS;\r\nxadc_write_reg(xadc, XADC_AXI_REG_IPIER, val);\r\nspin_unlock_irqrestore(&xadc->lock, flags);\r\nerr_out:\r\nmutex_unlock(&xadc->mutex);\r\nreturn ret;\r\n}\r\nstatic struct iio_trigger *xadc_alloc_trigger(struct iio_dev *indio_dev,\r\nconst char *name)\r\n{\r\nstruct iio_trigger *trig;\r\nint ret;\r\ntrig = iio_trigger_alloc("%s%d-%s", indio_dev->name,\r\nindio_dev->id, name);\r\nif (trig == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\ntrig->dev.parent = indio_dev->dev.parent;\r\ntrig->ops = &xadc_trigger_ops;\r\niio_trigger_set_drvdata(trig, iio_priv(indio_dev));\r\nret = iio_trigger_register(trig);\r\nif (ret)\r\ngoto error_free_trig;\r\nreturn trig;\r\nerror_free_trig:\r\niio_trigger_free(trig);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int xadc_power_adc_b(struct xadc *xadc, unsigned int seq_mode)\r\n{\r\nuint16_t val;\r\nswitch (seq_mode) {\r\ncase XADC_CONF1_SEQ_SIMULTANEOUS:\r\ncase XADC_CONF1_SEQ_INDEPENDENT:\r\nval = XADC_CONF2_PD_ADC_B;\r\nbreak;\r\ndefault:\r\nval = 0;\r\nbreak;\r\n}\r\nreturn xadc_update_adc_reg(xadc, XADC_REG_CONF2, XADC_CONF2_PD_MASK,\r\nval);\r\n}\r\nstatic int xadc_get_seq_mode(struct xadc *xadc, unsigned long scan_mode)\r\n{\r\nunsigned int aux_scan_mode = scan_mode >> 16;\r\nif (xadc->external_mux_mode == XADC_EXTERNAL_MUX_DUAL)\r\nreturn XADC_CONF1_SEQ_SIMULTANEOUS;\r\nif ((aux_scan_mode & 0xff00) == 0 ||\r\n(aux_scan_mode & 0x00ff) == 0)\r\nreturn XADC_CONF1_SEQ_CONTINUOUS;\r\nreturn XADC_CONF1_SEQ_SIMULTANEOUS;\r\n}\r\nstatic int xadc_postdisable(struct iio_dev *indio_dev)\r\n{\r\nstruct xadc *xadc = iio_priv(indio_dev);\r\nunsigned long scan_mask;\r\nint ret;\r\nint i;\r\nscan_mask = 1;\r\nfor (i = 0; i < indio_dev->num_channels; i++)\r\nscan_mask |= BIT(indio_dev->channels[i].scan_index);\r\nret = xadc_write_adc_reg(xadc, XADC_REG_SEQ(0), scan_mask & 0xffff);\r\nif (ret)\r\nreturn ret;\r\nret = xadc_write_adc_reg(xadc, XADC_REG_SEQ(1), scan_mask >> 16);\r\nif (ret)\r\nreturn ret;\r\nret = xadc_update_adc_reg(xadc, XADC_REG_CONF1, XADC_CONF1_SEQ_MASK,\r\nXADC_CONF1_SEQ_CONTINUOUS);\r\nif (ret)\r\nreturn ret;\r\nreturn xadc_power_adc_b(xadc, XADC_CONF1_SEQ_CONTINUOUS);\r\n}\r\nstatic int xadc_preenable(struct iio_dev *indio_dev)\r\n{\r\nstruct xadc *xadc = iio_priv(indio_dev);\r\nunsigned long scan_mask;\r\nint seq_mode;\r\nint ret;\r\nret = xadc_update_adc_reg(xadc, XADC_REG_CONF1, XADC_CONF1_SEQ_MASK,\r\nXADC_CONF1_SEQ_DEFAULT);\r\nif (ret)\r\ngoto err;\r\nscan_mask = *indio_dev->active_scan_mask;\r\nseq_mode = xadc_get_seq_mode(xadc, scan_mask);\r\nret = xadc_write_adc_reg(xadc, XADC_REG_SEQ(0), scan_mask & 0xffff);\r\nif (ret)\r\ngoto err;\r\nret = xadc_write_adc_reg(xadc, XADC_REG_SEQ(1), scan_mask >> 16);\r\nif (ret)\r\ngoto err;\r\nret = xadc_power_adc_b(xadc, seq_mode);\r\nif (ret)\r\ngoto err;\r\nret = xadc_update_adc_reg(xadc, XADC_REG_CONF1, XADC_CONF1_SEQ_MASK,\r\nseq_mode);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nxadc_postdisable(indio_dev);\r\nreturn ret;\r\n}\r\nstatic int xadc_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val, int *val2, long info)\r\n{\r\nstruct xadc *xadc = iio_priv(indio_dev);\r\nunsigned int div;\r\nuint16_t val16;\r\nint ret;\r\nswitch (info) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (iio_buffer_enabled(indio_dev))\r\nreturn -EBUSY;\r\nret = xadc_read_adc_reg(xadc, chan->address, &val16);\r\nif (ret < 0)\r\nreturn ret;\r\nval16 >>= 4;\r\nif (chan->scan_type.sign == 'u')\r\n*val = val16;\r\nelse\r\n*val = sign_extend32(val16, 11);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_VOLTAGE:\r\nswitch (chan->address) {\r\ncase XADC_REG_VCCINT:\r\ncase XADC_REG_VCCAUX:\r\ncase XADC_REG_VCCBRAM:\r\ncase XADC_REG_VCCPINT:\r\ncase XADC_REG_VCCPAUX:\r\ncase XADC_REG_VCCO_DDR:\r\n*val = 3000;\r\nbreak;\r\ndefault:\r\n*val = 1000;\r\nbreak;\r\n}\r\n*val2 = 12;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ncase IIO_TEMP:\r\n*val = 503975;\r\n*val2 = 12;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_OFFSET:\r\n*val = -((273150 << 12) / 503975);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nret = xadc_read_adc_reg(xadc, XADC_REG_CONF2, &val16);\r\nif (ret)\r\nreturn ret;\r\ndiv = (val16 & XADC_CONF2_DIV_MASK) >> XADC_CONF2_DIV_OFFSET;\r\nif (div < 2)\r\ndiv = 2;\r\n*val = xadc_get_dclk_rate(xadc) / div / 26;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int xadc_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int val, int val2, long info)\r\n{\r\nstruct xadc *xadc = iio_priv(indio_dev);\r\nunsigned long clk_rate = xadc_get_dclk_rate(xadc);\r\nunsigned int div;\r\nif (info != IIO_CHAN_INFO_SAMP_FREQ)\r\nreturn -EINVAL;\r\nif (val <= 0)\r\nreturn -EINVAL;\r\nif (val > 150000)\r\nval = 150000;\r\nval *= 26;\r\nif (val < 1000000)\r\nval = 1000000;\r\ndiv = clk_rate / val;\r\nif (clk_rate / div / 26 > 150000)\r\ndiv++;\r\nif (div < 2)\r\ndiv = 2;\r\nelse if (div > 0xff)\r\ndiv = 0xff;\r\nreturn xadc_update_adc_reg(xadc, XADC_REG_CONF2, XADC_CONF2_DIV_MASK,\r\ndiv << XADC_CONF2_DIV_OFFSET);\r\n}\r\nstatic int xadc_parse_dt(struct iio_dev *indio_dev, struct device_node *np,\r\nunsigned int *conf)\r\n{\r\nstruct xadc *xadc = iio_priv(indio_dev);\r\nstruct iio_chan_spec *channels, *chan;\r\nstruct device_node *chan_node, *child;\r\nunsigned int num_channels;\r\nconst char *external_mux;\r\nu32 ext_mux_chan;\r\nint reg;\r\nint ret;\r\n*conf = 0;\r\nret = of_property_read_string(np, "xlnx,external-mux", &external_mux);\r\nif (ret < 0 || strcasecmp(external_mux, "none") == 0)\r\nxadc->external_mux_mode = XADC_EXTERNAL_MUX_NONE;\r\nelse if (strcasecmp(external_mux, "single") == 0)\r\nxadc->external_mux_mode = XADC_EXTERNAL_MUX_SINGLE;\r\nelse if (strcasecmp(external_mux, "dual") == 0)\r\nxadc->external_mux_mode = XADC_EXTERNAL_MUX_DUAL;\r\nelse\r\nreturn -EINVAL;\r\nif (xadc->external_mux_mode != XADC_EXTERNAL_MUX_NONE) {\r\nret = of_property_read_u32(np, "xlnx,external-mux-channel",\r\n&ext_mux_chan);\r\nif (ret < 0)\r\nreturn ret;\r\nif (xadc->external_mux_mode == XADC_EXTERNAL_MUX_SINGLE) {\r\nif (ext_mux_chan == 0)\r\next_mux_chan = XADC_REG_VPVN;\r\nelse if (ext_mux_chan <= 16)\r\next_mux_chan = XADC_REG_VAUX(ext_mux_chan - 1);\r\nelse\r\nreturn -EINVAL;\r\n} else {\r\nif (ext_mux_chan > 0 && ext_mux_chan <= 8)\r\next_mux_chan = XADC_REG_VAUX(ext_mux_chan - 1);\r\nelse\r\nreturn -EINVAL;\r\n}\r\n*conf |= XADC_CONF0_MUX | XADC_CONF0_CHAN(ext_mux_chan);\r\n}\r\nchannels = kmemdup(xadc_channels, sizeof(xadc_channels), GFP_KERNEL);\r\nif (!channels)\r\nreturn -ENOMEM;\r\nnum_channels = 9;\r\nchan = &channels[9];\r\nchan_node = of_get_child_by_name(np, "xlnx,channels");\r\nif (chan_node) {\r\nfor_each_child_of_node(chan_node, child) {\r\nif (num_channels >= ARRAY_SIZE(xadc_channels)) {\r\nof_node_put(child);\r\nbreak;\r\n}\r\nret = of_property_read_u32(child, "reg", &reg);\r\nif (ret || reg > 16)\r\ncontinue;\r\nif (of_property_read_bool(child, "xlnx,bipolar"))\r\nchan->scan_type.sign = 's';\r\nif (reg == 0) {\r\nchan->scan_index = 11;\r\nchan->address = XADC_REG_VPVN;\r\n} else {\r\nchan->scan_index = 15 + reg;\r\nchan->address = XADC_REG_VAUX(reg - 1);\r\n}\r\nnum_channels++;\r\nchan++;\r\n}\r\n}\r\nof_node_put(chan_node);\r\nindio_dev->num_channels = num_channels;\r\nindio_dev->channels = krealloc(channels, sizeof(*channels) *\r\nnum_channels, GFP_KERNEL);\r\nif (!indio_dev->channels)\r\nindio_dev->channels = channels;\r\nreturn 0;\r\n}\r\nstatic int xadc_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *id;\r\nstruct iio_dev *indio_dev;\r\nunsigned int bipolar_mask;\r\nstruct resource *mem;\r\nunsigned int conf0;\r\nstruct xadc *xadc;\r\nint ret;\r\nint irq;\r\nint i;\r\nif (!pdev->dev.of_node)\r\nreturn -ENODEV;\r\nid = of_match_node(xadc_of_match_table, pdev->dev.of_node);\r\nif (!id)\r\nreturn -EINVAL;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0)\r\nreturn -ENXIO;\r\nindio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*xadc));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nxadc = iio_priv(indio_dev);\r\nxadc->ops = id->data;\r\ninit_completion(&xadc->completion);\r\nmutex_init(&xadc->mutex);\r\nspin_lock_init(&xadc->lock);\r\nINIT_DELAYED_WORK(&xadc->zynq_unmask_work, xadc_zynq_unmask_worker);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nxadc->base = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(xadc->base))\r\nreturn PTR_ERR(xadc->base);\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->dev.of_node = pdev->dev.of_node;\r\nindio_dev->name = "xadc";\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &xadc_info;\r\nret = xadc_parse_dt(indio_dev, pdev->dev.of_node, &conf0);\r\nif (ret)\r\ngoto err_device_free;\r\nif (xadc->ops->flags & XADC_FLAGS_BUFFERED) {\r\nret = iio_triggered_buffer_setup(indio_dev,\r\n&iio_pollfunc_store_time, &xadc_trigger_handler,\r\n&xadc_buffer_ops);\r\nif (ret)\r\ngoto err_device_free;\r\nxadc->convst_trigger = xadc_alloc_trigger(indio_dev, "convst");\r\nif (IS_ERR(xadc->convst_trigger)) {\r\nret = PTR_ERR(xadc->convst_trigger);\r\ngoto err_triggered_buffer_cleanup;\r\n}\r\nxadc->samplerate_trigger = xadc_alloc_trigger(indio_dev,\r\n"samplerate");\r\nif (IS_ERR(xadc->samplerate_trigger)) {\r\nret = PTR_ERR(xadc->samplerate_trigger);\r\ngoto err_free_convst_trigger;\r\n}\r\n}\r\nxadc->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(xadc->clk)) {\r\nret = PTR_ERR(xadc->clk);\r\ngoto err_free_samplerate_trigger;\r\n}\r\nclk_prepare_enable(xadc->clk);\r\nret = xadc->ops->setup(pdev, indio_dev, irq);\r\nif (ret)\r\ngoto err_free_samplerate_trigger;\r\nret = request_threaded_irq(irq, xadc->ops->interrupt_handler,\r\nxadc->ops->threaded_interrupt_handler,\r\n0, dev_name(&pdev->dev), indio_dev);\r\nif (ret)\r\ngoto err_clk_disable_unprepare;\r\nfor (i = 0; i < 16; i++)\r\nxadc_read_adc_reg(xadc, XADC_REG_THRESHOLD(i),\r\n&xadc->threshold[i]);\r\nret = xadc_write_adc_reg(xadc, XADC_REG_CONF0, conf0);\r\nif (ret)\r\ngoto err_free_irq;\r\nbipolar_mask = 0;\r\nfor (i = 0; i < indio_dev->num_channels; i++) {\r\nif (indio_dev->channels[i].scan_type.sign == 's')\r\nbipolar_mask |= BIT(indio_dev->channels[i].scan_index);\r\n}\r\nret = xadc_write_adc_reg(xadc, XADC_REG_INPUT_MODE(0), bipolar_mask);\r\nif (ret)\r\ngoto err_free_irq;\r\nret = xadc_write_adc_reg(xadc, XADC_REG_INPUT_MODE(1),\r\nbipolar_mask >> 16);\r\nif (ret)\r\ngoto err_free_irq;\r\nxadc_update_adc_reg(xadc, XADC_REG_CONF1, XADC_CONF1_ALARM_MASK,\r\nXADC_CONF1_ALARM_MASK);\r\nfor (i = 0; i < 16; i++) {\r\nif (i % 8 < 4 || i == 7)\r\nxadc->threshold[i] = 0xffff;\r\nelse\r\nxadc->threshold[i] = 0;\r\nxadc_write_adc_reg(xadc, XADC_REG_THRESHOLD(i),\r\nxadc->threshold[i]);\r\n}\r\nxadc_postdisable(indio_dev);\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto err_free_irq;\r\nplatform_set_drvdata(pdev, indio_dev);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(irq, indio_dev);\r\nerr_free_samplerate_trigger:\r\nif (xadc->ops->flags & XADC_FLAGS_BUFFERED)\r\niio_trigger_free(xadc->samplerate_trigger);\r\nerr_free_convst_trigger:\r\nif (xadc->ops->flags & XADC_FLAGS_BUFFERED)\r\niio_trigger_free(xadc->convst_trigger);\r\nerr_triggered_buffer_cleanup:\r\nif (xadc->ops->flags & XADC_FLAGS_BUFFERED)\r\niio_triggered_buffer_cleanup(indio_dev);\r\nerr_clk_disable_unprepare:\r\nclk_disable_unprepare(xadc->clk);\r\nerr_device_free:\r\nkfree(indio_dev->channels);\r\nreturn ret;\r\n}\r\nstatic int xadc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *indio_dev = platform_get_drvdata(pdev);\r\nstruct xadc *xadc = iio_priv(indio_dev);\r\nint irq = platform_get_irq(pdev, 0);\r\niio_device_unregister(indio_dev);\r\nif (xadc->ops->flags & XADC_FLAGS_BUFFERED) {\r\niio_trigger_free(xadc->samplerate_trigger);\r\niio_trigger_free(xadc->convst_trigger);\r\niio_triggered_buffer_cleanup(indio_dev);\r\n}\r\nfree_irq(irq, indio_dev);\r\nclk_disable_unprepare(xadc->clk);\r\ncancel_delayed_work(&xadc->zynq_unmask_work);\r\nkfree(xadc->data);\r\nkfree(indio_dev->channels);\r\nreturn 0;\r\n}
