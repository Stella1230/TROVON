static int interact_read_packet(struct gameport *gameport, int length, u32 *data)\r\n{\r\nunsigned long flags;\r\nunsigned char u, v;\r\nunsigned int t, s;\r\nint i;\r\ni = 0;\r\ndata[0] = data[1] = data[2] = 0;\r\nt = gameport_time(gameport, INTERACT_MAX_START);\r\ns = gameport_time(gameport, INTERACT_MAX_STROBE);\r\nlocal_irq_save(flags);\r\ngameport_trigger(gameport);\r\nv = gameport_read(gameport);\r\nwhile (t > 0 && i < length) {\r\nt--;\r\nu = v; v = gameport_read(gameport);\r\nif (v & ~u & 0x40) {\r\ndata[0] = (data[0] << 1) | ((v >> 4) & 1);\r\ndata[1] = (data[1] << 1) | ((v >> 5) & 1);\r\ndata[2] = (data[2] << 1) | ((v >> 7) & 1);\r\ni++;\r\nt = s;\r\n}\r\n}\r\nlocal_irq_restore(flags);\r\nreturn i;\r\n}\r\nstatic void interact_poll(struct gameport *gameport)\r\n{\r\nstruct interact *interact = gameport_get_drvdata(gameport);\r\nstruct input_dev *dev = interact->dev;\r\nu32 data[3];\r\nint i;\r\ninteract->reads++;\r\nif (interact_read_packet(interact->gameport, interact->length, data) < interact->length) {\r\ninteract->bads++;\r\n} else {\r\nfor (i = 0; i < 3; i++)\r\ndata[i] <<= INTERACT_MAX_LENGTH - interact->length;\r\nswitch (interact->type) {\r\ncase INTERACT_TYPE_HHFX:\r\nfor (i = 0; i < 4; i++)\r\ninput_report_abs(dev, interact_abs_hhfx[i], (data[i & 1] >> ((i >> 1) << 3)) & 0xff);\r\nfor (i = 0; i < 2; i++)\r\ninput_report_abs(dev, ABS_HAT0Y - i,\r\n((data[1] >> ((i << 1) + 17)) & 1) - ((data[1] >> ((i << 1) + 16)) & 1));\r\nfor (i = 0; i < 8; i++)\r\ninput_report_key(dev, interact_btn_hhfx[i], (data[0] >> (i + 16)) & 1);\r\nfor (i = 0; i < 4; i++)\r\ninput_report_key(dev, interact_btn_hhfx[i + 8], (data[1] >> (i + 20)) & 1);\r\nbreak;\r\ncase INTERACT_TYPE_PP8D:\r\nfor (i = 0; i < 2; i++)\r\ninput_report_abs(dev, interact_abs_pp8d[i],\r\n((data[0] >> ((i << 1) + 20)) & 1) - ((data[0] >> ((i << 1) + 21)) & 1));\r\nfor (i = 0; i < 8; i++)\r\ninput_report_key(dev, interact_btn_pp8d[i], (data[1] >> (i + 16)) & 1);\r\nbreak;\r\n}\r\n}\r\ninput_sync(dev);\r\n}\r\nstatic int interact_open(struct input_dev *dev)\r\n{\r\nstruct interact *interact = input_get_drvdata(dev);\r\ngameport_start_polling(interact->gameport);\r\nreturn 0;\r\n}\r\nstatic void interact_close(struct input_dev *dev)\r\n{\r\nstruct interact *interact = input_get_drvdata(dev);\r\ngameport_stop_polling(interact->gameport);\r\n}\r\nstatic int interact_connect(struct gameport *gameport, struct gameport_driver *drv)\r\n{\r\nstruct interact *interact;\r\nstruct input_dev *input_dev;\r\n__u32 data[3];\r\nint i, t;\r\nint err;\r\ninteract = kzalloc(sizeof(struct interact), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!interact || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto fail1;\r\n}\r\ninteract->gameport = gameport;\r\ninteract->dev = input_dev;\r\ngameport_set_drvdata(gameport, interact);\r\nerr = gameport_open(gameport, drv, GAMEPORT_MODE_RAW);\r\nif (err)\r\ngoto fail1;\r\ni = interact_read_packet(gameport, INTERACT_MAX_LENGTH * 2, data);\r\nif (i != 32 || (data[0] >> 24) != 0x0c || (data[1] >> 24) != 0x02) {\r\nerr = -ENODEV;\r\ngoto fail2;\r\n}\r\nfor (i = 0; interact_type[i].length; i++)\r\nif (interact_type[i].id == (data[2] >> 16))\r\nbreak;\r\nif (!interact_type[i].length) {\r\nprintk(KERN_WARNING "interact.c: Unknown joystick on %s. [len %d d0 %08x d1 %08x i2 %08x]\n",\r\ngameport->phys, i, data[0], data[1], data[2]);\r\nerr = -ENODEV;\r\ngoto fail2;\r\n}\r\ngameport_set_poll_handler(gameport, interact_poll);\r\ngameport_set_poll_interval(gameport, 20);\r\nsnprintf(interact->phys, sizeof(interact->phys), "%s/input0", gameport->phys);\r\ninteract->type = i;\r\ninteract->length = interact_type[i].length;\r\ninput_dev->name = interact_type[i].name;\r\ninput_dev->phys = interact->phys;\r\ninput_dev->id.bustype = BUS_GAMEPORT;\r\ninput_dev->id.vendor = GAMEPORT_ID_VENDOR_INTERACT;\r\ninput_dev->id.product = interact_type[i].id;\r\ninput_dev->id.version = 0x0100;\r\ninput_dev->dev.parent = &gameport->dev;\r\ninput_set_drvdata(input_dev, interact);\r\ninput_dev->open = interact_open;\r\ninput_dev->close = interact_close;\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);\r\nfor (i = 0; (t = interact_type[interact->type].abs[i]) >= 0; i++) {\r\nif (i < interact_type[interact->type].b8)\r\ninput_set_abs_params(input_dev, t, 0, 255, 0, 0);\r\nelse\r\ninput_set_abs_params(input_dev, t, -1, 1, 0, 0);\r\n}\r\nfor (i = 0; (t = interact_type[interact->type].btn[i]) >= 0; i++)\r\n__set_bit(t, input_dev->keybit);\r\nerr = input_register_device(interact->dev);\r\nif (err)\r\ngoto fail2;\r\nreturn 0;\r\nfail2: gameport_close(gameport);\r\nfail1: gameport_set_drvdata(gameport, NULL);\r\ninput_free_device(input_dev);\r\nkfree(interact);\r\nreturn err;\r\n}\r\nstatic void interact_disconnect(struct gameport *gameport)\r\n{\r\nstruct interact *interact = gameport_get_drvdata(gameport);\r\ninput_unregister_device(interact->dev);\r\ngameport_close(gameport);\r\ngameport_set_drvdata(gameport, NULL);\r\nkfree(interact);\r\n}
