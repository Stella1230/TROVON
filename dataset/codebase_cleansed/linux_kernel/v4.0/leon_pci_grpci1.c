static int grpci1_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nstruct grpci1_priv *priv = dev->bus->sysdata;\r\nint irq_group;\r\nirq_group = slot & 0x3;\r\npin = ((pin - 1) + irq_group) & 0x3;\r\nreturn priv->irq_map[pin];\r\n}\r\nstatic int grpci1_cfg_r32(struct grpci1_priv *priv, unsigned int bus,\r\nunsigned int devfn, int where, u32 *val)\r\n{\r\nu32 *pci_conf, tmp, cfg;\r\nif (where & 0x3)\r\nreturn -EINVAL;\r\nif (bus == 0) {\r\ndevfn += (0x8 * 6);\r\n} else if (bus == TGT) {\r\nbus = 0;\r\ndevfn = 0;\r\n}\r\ncfg = REGLOAD(priv->regs->cfg_stat);\r\nREGSTORE(priv->regs->cfg_stat, (cfg & ~(0xf << 23)) | (bus << 23));\r\npci_conf = (u32 *) (priv->pci_conf | (devfn << 8) | (where & 0xfc));\r\ntmp = LEON3_BYPASS_LOAD_PA(pci_conf);\r\nif (REGLOAD(priv->regs->cfg_stat) & CFGSTAT_CTO) {\r\n*val = 0xffffffff;\r\ntmp = REGLOAD(priv->regs->stat_cmd);\r\ngrpci1_cfg_w32(priv, TGT, 0, PCI_COMMAND, tmp);\r\n} else {\r\n*val = swab32(tmp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int grpci1_cfg_r16(struct grpci1_priv *priv, unsigned int bus,\r\nunsigned int devfn, int where, u32 *val)\r\n{\r\nu32 v;\r\nint ret;\r\nif (where & 0x1)\r\nreturn -EINVAL;\r\nret = grpci1_cfg_r32(priv, bus, devfn, where & ~0x3, &v);\r\n*val = 0xffff & (v >> (8 * (where & 0x3)));\r\nreturn ret;\r\n}\r\nstatic int grpci1_cfg_r8(struct grpci1_priv *priv, unsigned int bus,\r\nunsigned int devfn, int where, u32 *val)\r\n{\r\nu32 v;\r\nint ret;\r\nret = grpci1_cfg_r32(priv, bus, devfn, where & ~0x3, &v);\r\n*val = 0xff & (v >> (8 * (where & 3)));\r\nreturn ret;\r\n}\r\nstatic int grpci1_cfg_w32(struct grpci1_priv *priv, unsigned int bus,\r\nunsigned int devfn, int where, u32 val)\r\n{\r\nunsigned int *pci_conf;\r\nu32 cfg;\r\nif (where & 0x3)\r\nreturn -EINVAL;\r\nif (bus == 0) {\r\ndevfn += (0x8 * 6);\r\n} else if (bus == TGT) {\r\nbus = 0;\r\ndevfn = 0;\r\n}\r\ncfg = REGLOAD(priv->regs->cfg_stat);\r\nREGSTORE(priv->regs->cfg_stat, (cfg & ~(0xf << 23)) | (bus << 23));\r\npci_conf = (unsigned int *) (priv->pci_conf |\r\n(devfn << 8) | (where & 0xfc));\r\nLEON3_BYPASS_STORE_PA(pci_conf, swab32(val));\r\nreturn 0;\r\n}\r\nstatic int grpci1_cfg_w16(struct grpci1_priv *priv, unsigned int bus,\r\nunsigned int devfn, int where, u32 val)\r\n{\r\nint ret;\r\nu32 v;\r\nif (where & 0x1)\r\nreturn -EINVAL;\r\nret = grpci1_cfg_r32(priv, bus, devfn, where&~3, &v);\r\nif (ret)\r\nreturn ret;\r\nv = (v & ~(0xffff << (8 * (where & 0x3)))) |\r\n((0xffff & val) << (8 * (where & 0x3)));\r\nreturn grpci1_cfg_w32(priv, bus, devfn, where & ~0x3, v);\r\n}\r\nstatic int grpci1_cfg_w8(struct grpci1_priv *priv, unsigned int bus,\r\nunsigned int devfn, int where, u32 val)\r\n{\r\nint ret;\r\nu32 v;\r\nret = grpci1_cfg_r32(priv, bus, devfn, where & ~0x3, &v);\r\nif (ret != 0)\r\nreturn ret;\r\nv = (v & ~(0xff << (8 * (where & 0x3)))) |\r\n((0xff & val) << (8 * (where & 0x3)));\r\nreturn grpci1_cfg_w32(priv, bus, devfn, where & ~0x3, v);\r\n}\r\nstatic int grpci1_read_config(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nstruct grpci1_priv *priv = grpci1priv;\r\nunsigned int busno = bus->number;\r\nint ret;\r\nif (PCI_SLOT(devfn) > 15 || busno > 15) {\r\n*val = ~0;\r\nreturn 0;\r\n}\r\nswitch (size) {\r\ncase 1:\r\nret = grpci1_cfg_r8(priv, busno, devfn, where, val);\r\nbreak;\r\ncase 2:\r\nret = grpci1_cfg_r16(priv, busno, devfn, where, val);\r\nbreak;\r\ncase 4:\r\nret = grpci1_cfg_r32(priv, busno, devfn, where, val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n#ifdef GRPCI1_DEBUG_CFGACCESS\r\nprintk(KERN_INFO\r\n"grpci1_read_config: [%02x:%02x:%x] ofs=%d val=%x size=%d\n",\r\nbusno, PCI_SLOT(devfn), PCI_FUNC(devfn), where, *val, size);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int grpci1_write_config(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nstruct grpci1_priv *priv = grpci1priv;\r\nunsigned int busno = bus->number;\r\nif (PCI_SLOT(devfn) > 15 || busno > 15)\r\nreturn 0;\r\n#ifdef GRPCI1_DEBUG_CFGACCESS\r\nprintk(KERN_INFO\r\n"grpci1_write_config: [%02x:%02x:%x] ofs=%d size=%d val=%x\n",\r\nbusno, PCI_SLOT(devfn), PCI_FUNC(devfn), where, size, val);\r\n#endif\r\nswitch (size) {\r\ndefault:\r\nreturn -EINVAL;\r\ncase 1:\r\nreturn grpci1_cfg_w8(priv, busno, devfn, where, val);\r\ncase 2:\r\nreturn grpci1_cfg_w16(priv, busno, devfn, where, val);\r\ncase 4:\r\nreturn grpci1_cfg_w32(priv, busno, devfn, where, val);\r\n}\r\n}\r\nstatic void grpci1_mask_irq(struct irq_data *data)\r\n{\r\nu32 irqidx;\r\nstruct grpci1_priv *priv = grpci1priv;\r\nirqidx = (u32)data->chip_data - 1;\r\nif (irqidx > 3)\r\nreturn;\r\nirqidx += IRQ_MASK_BIT;\r\nREGSTORE(priv->regs->irq, REGLOAD(priv->regs->irq) & ~(1 << irqidx));\r\n}\r\nstatic void grpci1_unmask_irq(struct irq_data *data)\r\n{\r\nu32 irqidx;\r\nstruct grpci1_priv *priv = grpci1priv;\r\nirqidx = (u32)data->chip_data - 1;\r\nif (irqidx > 3)\r\nreturn;\r\nirqidx += IRQ_MASK_BIT;\r\nREGSTORE(priv->regs->irq, REGLOAD(priv->regs->irq) | (1 << irqidx));\r\n}\r\nstatic unsigned int grpci1_startup_irq(struct irq_data *data)\r\n{\r\ngrpci1_unmask_irq(data);\r\nreturn 0;\r\n}\r\nstatic void grpci1_shutdown_irq(struct irq_data *data)\r\n{\r\ngrpci1_mask_irq(data);\r\n}\r\nstatic void grpci1_pci_flow_irq(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct grpci1_priv *priv = grpci1priv;\r\nint i, ack = 0;\r\nunsigned int irqreg;\r\nirqreg = REGLOAD(priv->regs->irq);\r\nirqreg = (irqreg >> IRQ_MASK_BIT) & irqreg;\r\nif (irqreg & IRQ_ALL_ERRORS) {\r\ngeneric_handle_irq(priv->irq_err);\r\nack = 1;\r\n}\r\nif (irqreg & IRQ_INTX) {\r\nfor (i = 0; i < 4; i++) {\r\nif (irqreg & (1 << i))\r\ngeneric_handle_irq(priv->irq_map[i]);\r\n}\r\nack = 1;\r\n}\r\nif (ack)\r\ndesc->irq_data.chip->irq_eoi(&desc->irq_data);\r\n}\r\nstatic unsigned int grpci1_build_device_irq(unsigned int irq)\r\n{\r\nunsigned int virq = 0, pil;\r\npil = 1 << 8;\r\nvirq = irq_alloc(irq, pil);\r\nif (virq == 0)\r\ngoto out;\r\nirq_set_chip_and_handler_name(virq, &grpci1_irq, handle_simple_irq,\r\n"pcilvl");\r\nirq_set_chip_data(virq, (void *)irq);\r\nout:\r\nreturn virq;\r\n}\r\nstatic void grpci1_hw_init(struct grpci1_priv *priv)\r\n{\r\nu32 ahbadr, bar_sz, data, pciadr;\r\nstruct grpci1_regs __iomem *regs = priv->regs;\r\nREGSTORE(regs->cfg_stat, priv->pci_area & 0xf0000000);\r\nahbadr = 0xf0000000 & (u32)__pa(PAGE_ALIGN((unsigned long) &_end));\r\nREGSTORE(regs->page1, ahbadr);\r\nREGSTORE(regs->iomap, REGLOAD(regs->iomap) & 0x0000ffff);\r\nREGSTORE(regs->irq, 0);\r\ngrpci1_cfg_w32(priv, TGT, 0, PCI_BASE_ADDRESS_0, 0xffffffff);\r\ngrpci1_cfg_r32(priv, TGT, 0, PCI_BASE_ADDRESS_0, &bar_sz);\r\nbar_sz = ~bar_sz + 1;\r\npciadr = priv->pci_area - bar_sz;\r\ngrpci1_cfg_w32(priv, TGT, 0, PCI_BASE_ADDRESS_0, pciadr);\r\ngrpci1_cfg_w32(priv, TGT, 0, PCI_BASE_ADDRESS_1, ahbadr);\r\ngrpci1_cfg_w8(priv, TGT, 0, PCI_CACHE_LINE_SIZE, 0xff);\r\ngrpci1_cfg_w8(priv, TGT, 0, PCI_LATENCY_TIMER, 0x40);\r\ngrpci1_cfg_r32(priv, TGT, 0, PCI_COMMAND, &data);\r\ndata |= (PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\r\ngrpci1_cfg_w32(priv, TGT, 0, PCI_COMMAND, data);\r\n}\r\nstatic irqreturn_t grpci1_jump_interrupt(int irq, void *arg)\r\n{\r\nstruct grpci1_priv *priv = arg;\r\ndev_err(priv->dev, "Jump IRQ happened\n");\r\nreturn IRQ_NONE;\r\n}\r\nstatic irqreturn_t grpci1_err_interrupt(int irq, void *arg)\r\n{\r\nstruct grpci1_priv *priv = arg;\r\nu32 status;\r\ngrpci1_cfg_r16(priv, TGT, 0, PCI_STATUS, &status);\r\nstatus &= priv->pci_err_mask;\r\nif (status == 0)\r\nreturn IRQ_NONE;\r\nif (status & PCI_STATUS_PARITY)\r\ndev_err(priv->dev, "Data Parity Error\n");\r\nif (status & PCI_STATUS_SIG_TARGET_ABORT)\r\ndev_err(priv->dev, "Signalled Target Abort\n");\r\nif (status & PCI_STATUS_REC_TARGET_ABORT)\r\ndev_err(priv->dev, "Received Target Abort\n");\r\nif (status & PCI_STATUS_REC_MASTER_ABORT)\r\ndev_err(priv->dev, "Received Master Abort\n");\r\nif (status & PCI_STATUS_SIG_SYSTEM_ERROR)\r\ndev_err(priv->dev, "Signalled System Error\n");\r\nif (status & PCI_STATUS_DETECTED_PARITY)\r\ndev_err(priv->dev, "Parity Error\n");\r\ngrpci1_cfg_w16(priv, TGT, 0, PCI_STATUS, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int grpci1_of_probe(struct platform_device *ofdev)\r\n{\r\nstruct grpci1_regs __iomem *regs;\r\nstruct grpci1_priv *priv;\r\nint err, len;\r\nconst int *tmp;\r\nu32 cfg, size, err_mask;\r\nstruct resource *res;\r\nif (grpci1priv) {\r\ndev_err(&ofdev->dev, "only one GRPCI1 supported\n");\r\nreturn -ENODEV;\r\n}\r\nif (ofdev->num_resources < 3) {\r\ndev_err(&ofdev->dev, "not enough APB/AHB resources\n");\r\nreturn -EIO;\r\n}\r\npriv = devm_kzalloc(&ofdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&ofdev->dev, "memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(ofdev, priv);\r\npriv->dev = &ofdev->dev;\r\nres = platform_get_resource(ofdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(&ofdev->dev, res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\ncfg = REGLOAD(regs->cfg_stat);\r\nif ((cfg & CFGSTAT_HOST) == 0) {\r\ndev_err(&ofdev->dev, "not in host system slot\n");\r\nreturn -EIO;\r\n}\r\nREGSTORE(regs->page1, 0xffffffff);\r\nsize = ~REGLOAD(regs->page1) + 1;\r\nif (size < 0x10000000) {\r\ndev_err(&ofdev->dev, "BAR1 must be at least 256MByte\n");\r\nreturn -EIO;\r\n}\r\nif ((REGLOAD(regs->page0) & PAGE0_BTEN) == 0) {\r\ndev_err(&ofdev->dev, "byte-twisting is required\n");\r\nreturn -EIO;\r\n}\r\npriv->regs = regs;\r\npriv->irq = irq_of_parse_and_map(ofdev->dev.of_node, 0);\r\ndev_info(&ofdev->dev, "host found at 0x%p, irq%d\n", regs, priv->irq);\r\npriv->pci_area = ofdev->resource[1].start;\r\npriv->pci_area_end = ofdev->resource[1].end+1;\r\npriv->pci_io = ofdev->resource[2].start;\r\npriv->pci_conf = ofdev->resource[2].start + 0x10000;\r\npriv->pci_conf_end = priv->pci_conf + 0x10000;\r\npriv->pci_io_va = (unsigned long)ioremap(priv->pci_io, 0x10000);\r\nif (!priv->pci_io_va) {\r\ndev_err(&ofdev->dev, "unable to map PCI I/O area\n");\r\nreturn -EIO;\r\n}\r\nprintk(KERN_INFO\r\n"GRPCI1: MEMORY SPACE [0x%08lx - 0x%08lx]\n"\r\n" I/O SPACE [0x%08lx - 0x%08lx]\n"\r\n" CONFIG SPACE [0x%08lx - 0x%08lx]\n",\r\npriv->pci_area, priv->pci_area_end-1,\r\npriv->pci_io, priv->pci_conf-1,\r\npriv->pci_conf, priv->pci_conf_end-1);\r\npriv->info.io_space.name = "GRPCI1 PCI I/O Space";\r\npriv->info.io_space.start = priv->pci_io_va + 0x1000;\r\npriv->info.io_space.end = priv->pci_io_va + 0x10000 - 1;\r\npriv->info.io_space.flags = IORESOURCE_IO;\r\npriv->info.mem_space.name = "GRPCI1 PCI MEM Space";\r\npriv->info.mem_space.start = priv->pci_area;\r\npriv->info.mem_space.end = priv->pci_area_end - 1;\r\npriv->info.mem_space.flags = IORESOURCE_MEM;\r\nif (request_resource(&iomem_resource, &priv->info.mem_space) < 0) {\r\ndev_err(&ofdev->dev, "unable to request PCI memory area\n");\r\nerr = -ENOMEM;\r\ngoto err1;\r\n}\r\nif (request_resource(&ioport_resource, &priv->info.io_space) < 0) {\r\ndev_err(&ofdev->dev, "unable to request PCI I/O area\n");\r\nerr = -ENOMEM;\r\ngoto err2;\r\n}\r\npriv->info.busn.name = "GRPCI1 busn";\r\npriv->info.busn.start = 0;\r\npriv->info.busn.end = 15;\r\ngrpci1priv = priv;\r\ngrpci1_hw_init(priv);\r\nleon_update_virq_handling(priv->irq, grpci1_pci_flow_irq, "pcilvl", 0);\r\npriv->irq_map[0] = grpci1_build_device_irq(1);\r\npriv->irq_map[1] = grpci1_build_device_irq(2);\r\npriv->irq_map[2] = grpci1_build_device_irq(3);\r\npriv->irq_map[3] = grpci1_build_device_irq(4);\r\npriv->irq_err = grpci1_build_device_irq(5);\r\nprintk(KERN_INFO " PCI INTA..D#: IRQ%d, IRQ%d, IRQ%d, IRQ%d\n",\r\npriv->irq_map[0], priv->irq_map[1], priv->irq_map[2],\r\npriv->irq_map[3]);\r\nerr = devm_request_irq(&ofdev->dev, priv->irq, grpci1_jump_interrupt, 0,\r\n"GRPCI1_JUMP", priv);\r\nif (err) {\r\ndev_err(&ofdev->dev, "ERR IRQ request failed: %d\n", err);\r\ngoto err3;\r\n}\r\nerr = devm_request_irq(&ofdev->dev, priv->irq_err,\r\ngrpci1_err_interrupt, IRQF_SHARED, "GRPCI1_ERR",\r\npriv);\r\nif (err) {\r\ndev_err(&ofdev->dev, "ERR VIRQ request failed: %d\n", err);\r\ngoto err3;\r\n}\r\ntmp = of_get_property(ofdev->dev.of_node, "all_pci_errors", &len);\r\nif (tmp && (len == 4)) {\r\npriv->pci_err_mask = ALL_PCI_ERRORS;\r\nerr_mask = IRQ_ALL_ERRORS << IRQ_MASK_BIT;\r\n} else {\r\npriv->pci_err_mask = DEF_PCI_ERRORS;\r\nerr_mask = IRQ_DEF_ERRORS << IRQ_MASK_BIT;\r\n}\r\nREGSTORE(regs->irq, err_mask);\r\npriv->info.ops = &grpci1_ops;\r\npriv->info.map_irq = grpci1_map_irq;\r\nleon_pci_init(ofdev, &priv->info);\r\nreturn 0;\r\nerr3:\r\nrelease_resource(&priv->info.io_space);\r\nerr2:\r\nrelease_resource(&priv->info.mem_space);\r\nerr1:\r\niounmap((void __iomem *)priv->pci_io_va);\r\ngrpci1priv = NULL;\r\nreturn err;\r\n}\r\nstatic int __init grpci1_init(void)\r\n{\r\nreturn platform_driver_register(&grpci1_of_driver);\r\n}
