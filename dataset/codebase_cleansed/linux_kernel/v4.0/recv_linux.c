void rtw_handle_tkip_mic_err23a(struct rtw_adapter *padapter, u8 bgroup)\r\n{\r\nenum nl80211_key_type key_type = 0;\r\nunion iwreq_data wrqu;\r\nstruct iw_michaelmicfailure ev;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nunsigned long cur_time;\r\nif (psecuritypriv->last_mic_err_time == 0) {\r\npsecuritypriv->last_mic_err_time = jiffies;\r\n} else {\r\ncur_time = jiffies;\r\nif (cur_time - psecuritypriv->last_mic_err_time < 60*HZ) {\r\npsecuritypriv->btkip_countermeasure = true;\r\npsecuritypriv->last_mic_err_time = 0;\r\npsecuritypriv->btkip_countermeasure_time = cur_time;\r\n} else {\r\npsecuritypriv->last_mic_err_time = jiffies;\r\n}\r\n}\r\nif (bgroup)\r\nkey_type |= NL80211_KEYTYPE_GROUP;\r\nelse\r\nkey_type |= NL80211_KEYTYPE_PAIRWISE;\r\ncfg80211_michael_mic_failure(padapter->pnetdev,\r\n(u8 *)&pmlmepriv->assoc_bssid[0],\r\nkey_type, -1, NULL, GFP_ATOMIC);\r\nmemset(&ev, 0x00, sizeof(ev));\r\nif (bgroup)\r\nev.flags |= IW_MICFAILURE_GROUP;\r\nelse\r\nev.flags |= IW_MICFAILURE_PAIRWISE;\r\nev.src_addr.sa_family = ARPHRD_ETHER;\r\nether_addr_copy(ev.src_addr.sa_data, &pmlmepriv->assoc_bssid[0]);\r\nmemset(&wrqu, 0x00, sizeof(wrqu));\r\nwrqu.data.length = sizeof(ev);\r\n}\r\nint rtw_recv_indicatepkt23a(struct rtw_adapter *padapter,\r\nstruct recv_frame *precv_frame)\r\n{\r\nstruct recv_priv *precvpriv;\r\nstruct sk_buff *skb;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nprecvpriv = &padapter->recvpriv;\r\nskb = precv_frame->pkt;\r\nif (!skb) {\r\nRT_TRACE(_module_recv_osdep_c_, _drv_err_,\r\n("rtw_recv_indicatepkt23a():skb == NULL!!!!\n"));\r\ngoto _recv_indicatepkt_drop;\r\n}\r\nRT_TRACE(_module_recv_osdep_c_, _drv_info_,\r\n("rtw_recv_indicatepkt23a():skb != NULL !!!\n"));\r\nRT_TRACE(_module_recv_osdep_c_, _drv_info_,\r\n("rtw_recv_indicatepkt23a():precv_frame->hdr.rx_data =%p\n",\r\nprecv_frame->pkt->data));\r\nRT_TRACE(_module_recv_osdep_c_, _drv_info_,\r\n("\n skb->head =%p skb->data =%p skb->tail =%p skb->end =%p skb->len =%d\n",\r\nskb->head, skb->data,\r\nskb_tail_pointer(skb), skb_end_pointer(skb), skb->len));\r\nif (check_fwstate(pmlmepriv, WIFI_AP_STATE) == true) {\r\nstruct sk_buff *pskb2 = NULL;\r\nstruct sta_info *psta = NULL;\r\nstruct sta_priv *pstapriv = &padapter->stapriv;\r\nstruct rx_pkt_attrib *pattrib = &precv_frame->attrib;\r\nint bmcast = is_multicast_ether_addr(pattrib->dst);\r\nif (!ether_addr_equal(pattrib->dst,\r\nmyid(&padapter->eeprompriv))) {\r\nif (bmcast) {\r\npsta = rtw_get_bcmc_stainfo23a(padapter);\r\npskb2 = skb_clone(skb, GFP_ATOMIC);\r\n} else {\r\npsta = rtw_get_stainfo23a(pstapriv, pattrib->dst);\r\n}\r\nif (psta) {\r\nstruct net_device *pnetdev = padapter->pnetdev;\r\nskb->dev = pnetdev;\r\nskb_set_queue_mapping(skb, rtw_recv_select_queue23a(skb));\r\nrtw_xmit23a_entry23a(skb, pnetdev);\r\nif (bmcast)\r\nskb = pskb2;\r\nelse\r\ngoto _recv_indicatepkt_end;\r\n}\r\n} else {\r\n}\r\n}\r\nskb->ip_summed = CHECKSUM_NONE;\r\nskb->dev = padapter->pnetdev;\r\nskb->protocol = eth_type_trans(skb, padapter->pnetdev);\r\nnetif_rx(skb);\r\n_recv_indicatepkt_end:\r\nprecv_frame->pkt = NULL;\r\nrtw_free_recvframe23a(precv_frame);\r\nRT_TRACE(_module_recv_osdep_c_, _drv_info_,\r\n("\n rtw_recv_indicatepkt23a :after netif_rx!!!!\n"));\r\nreturn _SUCCESS;\r\n_recv_indicatepkt_drop:\r\nrtw_free_recvframe23a(precv_frame);\r\nreturn _FAIL;\r\n}\r\nvoid rtw_init_recv_timer23a(struct recv_reorder_ctrl *preorder_ctrl)\r\n{\r\nsetup_timer(&preorder_ctrl->reordering_ctrl_timer,\r\nrtw_reordering_ctrl_timeout_handler23a,\r\n(unsigned long)preorder_ctrl);\r\n}
