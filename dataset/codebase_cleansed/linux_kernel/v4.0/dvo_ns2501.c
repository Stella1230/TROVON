static bool ns2501_readb(struct intel_dvo_device *dvo, int addr, uint8_t * ch)\r\n{\r\nstruct ns2501_priv *ns = dvo->dev_priv;\r\nstruct i2c_adapter *adapter = dvo->i2c_bus;\r\nu8 out_buf[2];\r\nu8 in_buf[2];\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = dvo->slave_addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = out_buf,\r\n},\r\n{\r\n.addr = dvo->slave_addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = in_buf,\r\n}\r\n};\r\nout_buf[0] = addr;\r\nout_buf[1] = 0;\r\nif (i2c_transfer(adapter, msgs, 2) == 2) {\r\n*ch = in_buf[0];\r\nreturn true;\r\n}\r\nif (!ns->quiet) {\r\nDRM_DEBUG_KMS\r\n("Unable to read register 0x%02x from %s:0x%02x.\n", addr,\r\nadapter->name, dvo->slave_addr);\r\n}\r\nreturn false;\r\n}\r\nstatic bool ns2501_writeb(struct intel_dvo_device *dvo, int addr, uint8_t ch)\r\n{\r\nstruct ns2501_priv *ns = dvo->dev_priv;\r\nstruct i2c_adapter *adapter = dvo->i2c_bus;\r\nuint8_t out_buf[2];\r\nstruct i2c_msg msg = {\r\n.addr = dvo->slave_addr,\r\n.flags = 0,\r\n.len = 2,\r\n.buf = out_buf,\r\n};\r\nout_buf[0] = addr;\r\nout_buf[1] = ch;\r\nif (i2c_transfer(adapter, &msg, 1) == 1) {\r\nreturn true;\r\n}\r\nif (!ns->quiet) {\r\nDRM_DEBUG_KMS("Unable to write register 0x%02x to %s:%d\n",\r\naddr, adapter->name, dvo->slave_addr);\r\n}\r\nreturn false;\r\n}\r\nstatic bool ns2501_init(struct intel_dvo_device *dvo,\r\nstruct i2c_adapter *adapter)\r\n{\r\nstruct ns2501_priv *ns;\r\nunsigned char ch;\r\nns = kzalloc(sizeof(struct ns2501_priv), GFP_KERNEL);\r\nif (ns == NULL)\r\nreturn false;\r\ndvo->i2c_bus = adapter;\r\ndvo->dev_priv = ns;\r\nns->quiet = true;\r\nif (!ns2501_readb(dvo, NS2501_VID_LO, &ch))\r\ngoto out;\r\nif (ch != (NS2501_VID & 0xff)) {\r\nDRM_DEBUG_KMS("ns2501 not detected got %d: from %s Slave %d.\n",\r\nch, adapter->name, dvo->slave_addr);\r\ngoto out;\r\n}\r\nif (!ns2501_readb(dvo, NS2501_DID_LO, &ch))\r\ngoto out;\r\nif (ch != (NS2501_DID & 0xff)) {\r\nDRM_DEBUG_KMS("ns2501 not detected got %d: from %s Slave %d.\n",\r\nch, adapter->name, dvo->slave_addr);\r\ngoto out;\r\n}\r\nns->quiet = false;\r\nDRM_DEBUG_KMS("init ns2501 dvo controller successfully!\n");\r\nreturn true;\r\nout:\r\nkfree(ns);\r\nreturn false;\r\n}\r\nstatic enum drm_connector_status ns2501_detect(struct intel_dvo_device *dvo)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nstatic enum drm_mode_status ns2501_mode_valid(struct intel_dvo_device *dvo,\r\nstruct drm_display_mode *mode)\r\n{\r\nDRM_DEBUG_KMS\r\n("is mode valid (hdisplay=%d,htotal=%d,vdisplay=%d,vtotal=%d)\n",\r\nmode->hdisplay, mode->htotal, mode->vdisplay, mode->vtotal);\r\nif ((mode->hdisplay == 640 && mode->vdisplay == 480 && mode->clock == 25175) ||\r\n(mode->hdisplay == 800 && mode->vdisplay == 600 && mode->clock == 40000) ||\r\n(mode->hdisplay == 1024 && mode->vdisplay == 768 && mode->clock == 65000)) {\r\nreturn MODE_OK;\r\n} else {\r\nreturn MODE_ONE_SIZE;\r\n}\r\n}\r\nstatic void ns2501_mode_set(struct intel_dvo_device *dvo,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct ns2501_priv *ns = (struct ns2501_priv *)(dvo->dev_priv);\r\nint mode_idx, i;\r\nDRM_DEBUG_KMS\r\n("set mode (hdisplay=%d,htotal=%d,vdisplay=%d,vtotal=%d).\n",\r\nmode->hdisplay, mode->htotal, mode->vdisplay, mode->vtotal);\r\nif (mode->hdisplay == 640 && mode->vdisplay == 480)\r\nmode_idx = MODE_640x480;\r\nelse if (mode->hdisplay == 800 && mode->vdisplay == 600)\r\nmode_idx = MODE_800x600;\r\nelse if (mode->hdisplay == 1024 && mode->vdisplay == 768)\r\nmode_idx = MODE_1024x768;\r\nelse\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(regs_init); i++)\r\nns2501_writeb(dvo, regs_init[i].offset, regs_init[i].value);\r\nns->regs = regs_1024x768[mode_idx];\r\nfor (i = 0; i < 84; i++)\r\nns2501_writeb(dvo, ns->regs[i].offset, ns->regs[i].value);\r\n}\r\nstatic bool ns2501_get_hw_state(struct intel_dvo_device *dvo)\r\n{\r\nunsigned char ch;\r\nif (!ns2501_readb(dvo, NS2501_REG8, &ch))\r\nreturn false;\r\nreturn ch & NS2501_8_PD;\r\n}\r\nstatic void ns2501_dpms(struct intel_dvo_device *dvo, bool enable)\r\n{\r\nstruct ns2501_priv *ns = (struct ns2501_priv *)(dvo->dev_priv);\r\nDRM_DEBUG_KMS("Trying set the dpms of the DVO to %i\n", enable);\r\nif (enable) {\r\nif (WARN_ON(ns->regs[83].offset != 0x08 ||\r\nns->regs[84].offset != 0x41 ||\r\nns->regs[85].offset != 0xc0))\r\nreturn;\r\nns2501_writeb(dvo, 0xc0, ns->regs[85].value | 0x08);\r\nns2501_writeb(dvo, 0x41, ns->regs[84].value);\r\nns2501_writeb(dvo, 0x34, 0x01);\r\nmsleep(15);\r\nns2501_writeb(dvo, 0x08, 0x35);\r\nif (!(ns->regs[83].value & NS2501_8_BPAS))\r\nns2501_writeb(dvo, 0x08, 0x31);\r\nmsleep(200);\r\nns2501_writeb(dvo, 0x34, 0x03);\r\nns2501_writeb(dvo, 0xc0, ns->regs[85].value);\r\n} else {\r\nns2501_writeb(dvo, 0x34, 0x01);\r\nmsleep(200);\r\nns2501_writeb(dvo, 0x08, 0x34);\r\nmsleep(15);\r\nns2501_writeb(dvo, 0x34, 0x00);\r\n}\r\n}\r\nstatic void ns2501_destroy(struct intel_dvo_device *dvo)\r\n{\r\nstruct ns2501_priv *ns = dvo->dev_priv;\r\nif (ns) {\r\nkfree(ns);\r\ndvo->dev_priv = NULL;\r\n}\r\n}
