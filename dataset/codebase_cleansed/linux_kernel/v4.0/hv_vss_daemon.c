static int vss_do_freeze(char *dir, unsigned int cmd)\r\n{\r\nint ret, fd = open(dir, O_RDONLY);\r\nif (fd < 0)\r\nreturn 1;\r\nret = ioctl(fd, cmd, 0);\r\nif (ret) {\r\nif ((cmd == FIFREEZE && errno == EBUSY) ||\r\n(cmd == FITHAW && errno == EINVAL)) {\r\nclose(fd);\r\nreturn 0;\r\n}\r\n}\r\nclose(fd);\r\nreturn !!ret;\r\n}\r\nstatic int vss_operate(int operation)\r\n{\r\nchar match[] = "/dev/";\r\nFILE *mounts;\r\nstruct mntent *ent;\r\nunsigned int cmd;\r\nint error = 0, root_seen = 0, save_errno = 0;\r\nswitch (operation) {\r\ncase VSS_OP_FREEZE:\r\ncmd = FIFREEZE;\r\nbreak;\r\ncase VSS_OP_THAW:\r\ncmd = FITHAW;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nmounts = setmntent("/proc/mounts", "r");\r\nif (mounts == NULL)\r\nreturn -1;\r\nwhile ((ent = getmntent(mounts))) {\r\nif (strncmp(ent->mnt_fsname, match, strlen(match)))\r\ncontinue;\r\nif (hasmntopt(ent, MNTOPT_RO) != NULL)\r\ncontinue;\r\nif (strcmp(ent->mnt_type, "vfat") == 0)\r\ncontinue;\r\nif (strcmp(ent->mnt_dir, "/") == 0) {\r\nroot_seen = 1;\r\ncontinue;\r\n}\r\nerror |= vss_do_freeze(ent->mnt_dir, cmd);\r\nif (error && operation == VSS_OP_FREEZE)\r\ngoto err;\r\n}\r\nif (root_seen) {\r\nerror |= vss_do_freeze("/", cmd);\r\nif (error && operation == VSS_OP_FREEZE)\r\ngoto err;\r\n}\r\ngoto out;\r\nerr:\r\nsave_errno = errno;\r\nvss_operate(VSS_OP_THAW);\r\nif (ent)\r\nsyslog(LOG_ERR, "FREEZE of %s failed; error:%d %s",\r\nent->mnt_dir, save_errno, strerror(save_errno));\r\nelse\r\nsyslog(LOG_ERR, "FREEZE of / failed; error:%d %s", save_errno,\r\nstrerror(save_errno));\r\nout:\r\nendmntent(mounts);\r\nreturn error;\r\n}\r\nstatic int netlink_send(int fd, struct cn_msg *msg)\r\n{\r\nstruct nlmsghdr nlh = { .nlmsg_type = NLMSG_DONE };\r\nunsigned int size;\r\nstruct msghdr message;\r\nstruct iovec iov[2];\r\nsize = sizeof(struct cn_msg) + msg->len;\r\nnlh.nlmsg_pid = getpid();\r\nnlh.nlmsg_len = NLMSG_LENGTH(size);\r\niov[0].iov_base = &nlh;\r\niov[0].iov_len = sizeof(nlh);\r\niov[1].iov_base = msg;\r\niov[1].iov_len = size;\r\nmemset(&message, 0, sizeof(message));\r\nmessage.msg_name = &addr;\r\nmessage.msg_namelen = sizeof(addr);\r\nmessage.msg_iov = iov;\r\nmessage.msg_iovlen = 2;\r\nreturn sendmsg(fd, &message, 0);\r\n}\r\nvoid print_usage(char *argv[])\r\n{\r\nfprintf(stderr, "Usage: %s [options]\n"\r\n"Options are:\n"\r\n" -n, --no-daemon stay in foreground, don't daemonize\n"\r\n" -h, --help print this help\n", argv[0]);\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nint fd, len, nl_group;\r\nint error;\r\nstruct cn_msg *message;\r\nstruct pollfd pfd;\r\nstruct nlmsghdr *incoming_msg;\r\nstruct cn_msg *incoming_cn_msg;\r\nint op;\r\nstruct hv_vss_msg *vss_msg;\r\nchar *vss_recv_buffer;\r\nsize_t vss_recv_buffer_len;\r\nint daemonize = 1, long_index = 0, opt;\r\nstatic struct option long_options[] = {\r\n{"help", no_argument, 0, 'h' },\r\n{"no-daemon", no_argument, 0, 'n' },\r\n{0, 0, 0, 0 }\r\n};\r\nwhile ((opt = getopt_long(argc, argv, "hn", long_options,\r\n&long_index)) != -1) {\r\nswitch (opt) {\r\ncase 'n':\r\ndaemonize = 0;\r\nbreak;\r\ncase 'h':\r\ndefault:\r\nprint_usage(argv);\r\nexit(EXIT_FAILURE);\r\n}\r\n}\r\nif (daemonize && daemon(1, 0))\r\nreturn 1;\r\nopenlog("Hyper-V VSS", 0, LOG_USER);\r\nsyslog(LOG_INFO, "VSS starting; pid is:%d", getpid());\r\nvss_recv_buffer_len = NLMSG_LENGTH(0) + sizeof(struct cn_msg) + sizeof(struct hv_vss_msg);\r\nvss_recv_buffer = calloc(1, vss_recv_buffer_len);\r\nif (!vss_recv_buffer) {\r\nsyslog(LOG_ERR, "Failed to allocate netlink buffers");\r\nexit(EXIT_FAILURE);\r\n}\r\nfd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_CONNECTOR);\r\nif (fd < 0) {\r\nsyslog(LOG_ERR, "netlink socket creation failed; error:%d %s",\r\nerrno, strerror(errno));\r\nexit(EXIT_FAILURE);\r\n}\r\naddr.nl_family = AF_NETLINK;\r\naddr.nl_pad = 0;\r\naddr.nl_pid = 0;\r\naddr.nl_groups = 0;\r\nerror = bind(fd, (struct sockaddr *)&addr, sizeof(addr));\r\nif (error < 0) {\r\nsyslog(LOG_ERR, "bind failed; error:%d %s", errno, strerror(errno));\r\nclose(fd);\r\nexit(EXIT_FAILURE);\r\n}\r\nnl_group = CN_VSS_IDX;\r\nif (setsockopt(fd, SOL_NETLINK, NETLINK_ADD_MEMBERSHIP, &nl_group, sizeof(nl_group)) < 0) {\r\nsyslog(LOG_ERR, "setsockopt failed; error:%d %s", errno, strerror(errno));\r\nclose(fd);\r\nexit(EXIT_FAILURE);\r\n}\r\nmessage = (struct cn_msg *)vss_recv_buffer;\r\nmessage->id.idx = CN_VSS_IDX;\r\nmessage->id.val = CN_VSS_VAL;\r\nmessage->ack = 0;\r\nvss_msg = (struct hv_vss_msg *)message->data;\r\nvss_msg->vss_hdr.operation = VSS_OP_REGISTER;\r\nmessage->len = sizeof(struct hv_vss_msg);\r\nlen = netlink_send(fd, message);\r\nif (len < 0) {\r\nsyslog(LOG_ERR, "netlink_send failed; error:%d %s", errno, strerror(errno));\r\nclose(fd);\r\nexit(EXIT_FAILURE);\r\n}\r\npfd.fd = fd;\r\nwhile (1) {\r\nstruct sockaddr *addr_p = (struct sockaddr *) &addr;\r\nsocklen_t addr_l = sizeof(addr);\r\npfd.events = POLLIN;\r\npfd.revents = 0;\r\nif (poll(&pfd, 1, -1) < 0) {\r\nsyslog(LOG_ERR, "poll failed; error:%d %s", errno, strerror(errno));\r\nif (errno == EINVAL) {\r\nclose(fd);\r\nexit(EXIT_FAILURE);\r\n}\r\nelse\r\ncontinue;\r\n}\r\nlen = recvfrom(fd, vss_recv_buffer, vss_recv_buffer_len, 0,\r\naddr_p, &addr_l);\r\nif (len < 0) {\r\nsyslog(LOG_ERR, "recvfrom failed; pid:%u error:%d %s",\r\naddr.nl_pid, errno, strerror(errno));\r\nclose(fd);\r\nreturn -1;\r\n}\r\nif (addr.nl_pid) {\r\nsyslog(LOG_WARNING,\r\n"Received packet from untrusted pid:%u",\r\naddr.nl_pid);\r\ncontinue;\r\n}\r\nincoming_msg = (struct nlmsghdr *)vss_recv_buffer;\r\nif (incoming_msg->nlmsg_type != NLMSG_DONE)\r\ncontinue;\r\nincoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg);\r\nvss_msg = (struct hv_vss_msg *)incoming_cn_msg->data;\r\nop = vss_msg->vss_hdr.operation;\r\nerror = HV_S_OK;\r\nswitch (op) {\r\ncase VSS_OP_FREEZE:\r\ncase VSS_OP_THAW:\r\nerror = vss_operate(op);\r\nsyslog(LOG_INFO, "VSS: op=%s: %s\n",\r\nop == VSS_OP_FREEZE ? "FREEZE" : "THAW",\r\nerror ? "failed" : "succeeded");\r\nif (error) {\r\nerror = HV_E_FAIL;\r\nsyslog(LOG_ERR, "op=%d failed!", op);\r\nsyslog(LOG_ERR, "report it with these files:");\r\nsyslog(LOG_ERR, "/etc/fstab and /proc/mounts");\r\n}\r\nbreak;\r\ndefault:\r\nsyslog(LOG_ERR, "Illegal op:%d\n", op);\r\n}\r\nvss_msg->error = error;\r\nlen = netlink_send(fd, incoming_cn_msg);\r\nif (len < 0) {\r\nsyslog(LOG_ERR, "net_link send failed; error:%d %s",\r\nerrno, strerror(errno));\r\nexit(EXIT_FAILURE);\r\n}\r\n}\r\n}
