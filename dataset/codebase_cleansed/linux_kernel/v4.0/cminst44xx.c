void omap_cm_base_init(void)\r\n{\r\n_cm_bases[OMAP4430_PRM_PARTITION] = prm_base;\r\n_cm_bases[OMAP4430_CM1_PARTITION] = cm_base;\r\n_cm_bases[OMAP4430_CM2_PARTITION] = cm2_base;\r\n_cm_bases[OMAP4430_PRCM_MPU_PARTITION] = prcm_mpu_base;\r\n}\r\nstatic u32 _clkctrl_idlest(u8 part, u16 inst, u16 clkctrl_offs)\r\n{\r\nu32 v = omap4_cminst_read_inst_reg(part, inst, clkctrl_offs);\r\nv &= OMAP4430_IDLEST_MASK;\r\nv >>= OMAP4430_IDLEST_SHIFT;\r\nreturn v;\r\n}\r\nstatic bool _is_module_ready(u8 part, u16 inst, u16 clkctrl_offs)\r\n{\r\nu32 v;\r\nv = _clkctrl_idlest(part, inst, clkctrl_offs);\r\nreturn (v == CLKCTRL_IDLEST_FUNCTIONAL ||\r\nv == CLKCTRL_IDLEST_INTERFACE_IDLE) ? true : false;\r\n}\r\nstatic u32 omap4_cminst_read_inst_reg(u8 part, u16 inst, u16 idx)\r\n{\r\nBUG_ON(part >= OMAP4_MAX_PRCM_PARTITIONS ||\r\npart == OMAP4430_INVALID_PRCM_PARTITION ||\r\n!_cm_bases[part]);\r\nreturn readl_relaxed(_cm_bases[part] + inst + idx);\r\n}\r\nstatic void omap4_cminst_write_inst_reg(u32 val, u8 part, u16 inst, u16 idx)\r\n{\r\nBUG_ON(part >= OMAP4_MAX_PRCM_PARTITIONS ||\r\npart == OMAP4430_INVALID_PRCM_PARTITION ||\r\n!_cm_bases[part]);\r\nwritel_relaxed(val, _cm_bases[part] + inst + idx);\r\n}\r\nstatic u32 omap4_cminst_rmw_inst_reg_bits(u32 mask, u32 bits, u8 part, u16 inst,\r\ns16 idx)\r\n{\r\nu32 v;\r\nv = omap4_cminst_read_inst_reg(part, inst, idx);\r\nv &= ~mask;\r\nv |= bits;\r\nomap4_cminst_write_inst_reg(v, part, inst, idx);\r\nreturn v;\r\n}\r\nstatic u32 omap4_cminst_set_inst_reg_bits(u32 bits, u8 part, u16 inst, s16 idx)\r\n{\r\nreturn omap4_cminst_rmw_inst_reg_bits(bits, bits, part, inst, idx);\r\n}\r\nstatic u32 omap4_cminst_clear_inst_reg_bits(u32 bits, u8 part, u16 inst,\r\ns16 idx)\r\n{\r\nreturn omap4_cminst_rmw_inst_reg_bits(bits, 0x0, part, inst, idx);\r\n}\r\nstatic u32 omap4_cminst_read_inst_reg_bits(u8 part, u16 inst, s16 idx, u32 mask)\r\n{\r\nu32 v;\r\nv = omap4_cminst_read_inst_reg(part, inst, idx);\r\nv &= mask;\r\nv >>= __ffs(mask);\r\nreturn v;\r\n}\r\nstatic void _clktrctrl_write(u8 c, u8 part, u16 inst, u16 cdoffs)\r\n{\r\nu32 v;\r\nv = omap4_cminst_read_inst_reg(part, inst, cdoffs + OMAP4_CM_CLKSTCTRL);\r\nv &= ~OMAP4430_CLKTRCTRL_MASK;\r\nv |= c << OMAP4430_CLKTRCTRL_SHIFT;\r\nomap4_cminst_write_inst_reg(v, part, inst, cdoffs + OMAP4_CM_CLKSTCTRL);\r\n}\r\nstatic bool omap4_cminst_is_clkdm_in_hwsup(u8 part, u16 inst, u16 cdoffs)\r\n{\r\nu32 v;\r\nv = omap4_cminst_read_inst_reg(part, inst, cdoffs + OMAP4_CM_CLKSTCTRL);\r\nv &= OMAP4430_CLKTRCTRL_MASK;\r\nv >>= OMAP4430_CLKTRCTRL_SHIFT;\r\nreturn (v == OMAP34XX_CLKSTCTRL_ENABLE_AUTO) ? true : false;\r\n}\r\nstatic void omap4_cminst_clkdm_enable_hwsup(u8 part, u16 inst, u16 cdoffs)\r\n{\r\n_clktrctrl_write(OMAP34XX_CLKSTCTRL_ENABLE_AUTO, part, inst, cdoffs);\r\n}\r\nstatic void omap4_cminst_clkdm_disable_hwsup(u8 part, u16 inst, u16 cdoffs)\r\n{\r\n_clktrctrl_write(OMAP34XX_CLKSTCTRL_DISABLE_AUTO, part, inst, cdoffs);\r\n}\r\nstatic void omap4_cminst_clkdm_force_wakeup(u8 part, u16 inst, u16 cdoffs)\r\n{\r\n_clktrctrl_write(OMAP34XX_CLKSTCTRL_FORCE_WAKEUP, part, inst, cdoffs);\r\n}\r\nstatic void omap4_cminst_clkdm_force_sleep(u8 part, u16 inst, u16 cdoffs)\r\n{\r\n_clktrctrl_write(OMAP34XX_CLKSTCTRL_FORCE_SLEEP, part, inst, cdoffs);\r\n}\r\nstatic int omap4_cminst_wait_module_ready(u8 part, s16 inst, u16 clkctrl_offs,\r\nu8 bit_shift)\r\n{\r\nint i = 0;\r\nif (!clkctrl_offs)\r\nreturn 0;\r\nomap_test_timeout(_is_module_ready(part, inst, clkctrl_offs),\r\nMAX_MODULE_READY_TIME, i);\r\nreturn (i < MAX_MODULE_READY_TIME) ? 0 : -EBUSY;\r\n}\r\nstatic int omap4_cminst_wait_module_idle(u8 part, s16 inst, u16 clkctrl_offs,\r\nu8 bit_shift)\r\n{\r\nint i = 0;\r\nif (!clkctrl_offs)\r\nreturn 0;\r\nomap_test_timeout((_clkctrl_idlest(part, inst, clkctrl_offs) ==\r\nCLKCTRL_IDLEST_DISABLED),\r\nMAX_MODULE_DISABLE_TIME, i);\r\nreturn (i < MAX_MODULE_DISABLE_TIME) ? 0 : -EBUSY;\r\n}\r\nstatic void omap4_cminst_module_enable(u8 mode, u8 part, u16 inst,\r\nu16 clkctrl_offs)\r\n{\r\nu32 v;\r\nv = omap4_cminst_read_inst_reg(part, inst, clkctrl_offs);\r\nv &= ~OMAP4430_MODULEMODE_MASK;\r\nv |= mode << OMAP4430_MODULEMODE_SHIFT;\r\nomap4_cminst_write_inst_reg(v, part, inst, clkctrl_offs);\r\n}\r\nstatic void omap4_cminst_module_disable(u8 part, u16 inst, u16 clkctrl_offs)\r\n{\r\nu32 v;\r\nv = omap4_cminst_read_inst_reg(part, inst, clkctrl_offs);\r\nv &= ~OMAP4430_MODULEMODE_MASK;\r\nomap4_cminst_write_inst_reg(v, part, inst, clkctrl_offs);\r\n}\r\nstatic int omap4_clkdm_add_wkup_sleep_dep(struct clockdomain *clkdm1,\r\nstruct clockdomain *clkdm2)\r\n{\r\nomap4_cminst_set_inst_reg_bits((1 << clkdm2->dep_bit),\r\nclkdm1->prcm_partition,\r\nclkdm1->cm_inst, clkdm1->clkdm_offs +\r\nOMAP4_CM_STATICDEP);\r\nreturn 0;\r\n}\r\nstatic int omap4_clkdm_del_wkup_sleep_dep(struct clockdomain *clkdm1,\r\nstruct clockdomain *clkdm2)\r\n{\r\nomap4_cminst_clear_inst_reg_bits((1 << clkdm2->dep_bit),\r\nclkdm1->prcm_partition,\r\nclkdm1->cm_inst, clkdm1->clkdm_offs +\r\nOMAP4_CM_STATICDEP);\r\nreturn 0;\r\n}\r\nstatic int omap4_clkdm_read_wkup_sleep_dep(struct clockdomain *clkdm1,\r\nstruct clockdomain *clkdm2)\r\n{\r\nreturn omap4_cminst_read_inst_reg_bits(clkdm1->prcm_partition,\r\nclkdm1->cm_inst,\r\nclkdm1->clkdm_offs +\r\nOMAP4_CM_STATICDEP,\r\n(1 << clkdm2->dep_bit));\r\n}\r\nstatic int omap4_clkdm_clear_all_wkup_sleep_deps(struct clockdomain *clkdm)\r\n{\r\nstruct clkdm_dep *cd;\r\nu32 mask = 0;\r\nif (!clkdm->prcm_partition)\r\nreturn 0;\r\nfor (cd = clkdm->wkdep_srcs; cd && cd->clkdm_name; cd++) {\r\nif (!cd->clkdm)\r\ncontinue;\r\nmask |= 1 << cd->clkdm->dep_bit;\r\ncd->wkdep_usecount = 0;\r\n}\r\nomap4_cminst_clear_inst_reg_bits(mask, clkdm->prcm_partition,\r\nclkdm->cm_inst, clkdm->clkdm_offs +\r\nOMAP4_CM_STATICDEP);\r\nreturn 0;\r\n}\r\nstatic int omap4_clkdm_sleep(struct clockdomain *clkdm)\r\n{\r\nif (clkdm->flags & CLKDM_CAN_HWSUP)\r\nomap4_cminst_clkdm_enable_hwsup(clkdm->prcm_partition,\r\nclkdm->cm_inst,\r\nclkdm->clkdm_offs);\r\nelse if (clkdm->flags & CLKDM_CAN_FORCE_SLEEP)\r\nomap4_cminst_clkdm_force_sleep(clkdm->prcm_partition,\r\nclkdm->cm_inst,\r\nclkdm->clkdm_offs);\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int omap4_clkdm_wakeup(struct clockdomain *clkdm)\r\n{\r\nomap4_cminst_clkdm_force_wakeup(clkdm->prcm_partition,\r\nclkdm->cm_inst, clkdm->clkdm_offs);\r\nreturn 0;\r\n}\r\nstatic void omap4_clkdm_allow_idle(struct clockdomain *clkdm)\r\n{\r\nomap4_cminst_clkdm_enable_hwsup(clkdm->prcm_partition,\r\nclkdm->cm_inst, clkdm->clkdm_offs);\r\n}\r\nstatic void omap4_clkdm_deny_idle(struct clockdomain *clkdm)\r\n{\r\nif (clkdm->flags & CLKDM_CAN_FORCE_WAKEUP)\r\nomap4_clkdm_wakeup(clkdm);\r\nelse\r\nomap4_cminst_clkdm_disable_hwsup(clkdm->prcm_partition,\r\nclkdm->cm_inst,\r\nclkdm->clkdm_offs);\r\n}\r\nstatic int omap4_clkdm_clk_enable(struct clockdomain *clkdm)\r\n{\r\nif (clkdm->flags & CLKDM_CAN_FORCE_WAKEUP)\r\nreturn omap4_clkdm_wakeup(clkdm);\r\nreturn 0;\r\n}\r\nstatic int omap4_clkdm_clk_disable(struct clockdomain *clkdm)\r\n{\r\nbool hwsup = false;\r\nif (!clkdm->prcm_partition)\r\nreturn 0;\r\nif (clkdm->flags & CLKDM_MISSING_IDLE_REPORTING &&\r\n!(clkdm->flags & CLKDM_CAN_FORCE_SLEEP)) {\r\nomap4_clkdm_allow_idle(clkdm);\r\nreturn 0;\r\n}\r\nhwsup = omap4_cminst_is_clkdm_in_hwsup(clkdm->prcm_partition,\r\nclkdm->cm_inst, clkdm->clkdm_offs);\r\nif (!hwsup && (clkdm->flags & CLKDM_CAN_FORCE_SLEEP))\r\nomap4_clkdm_sleep(clkdm);\r\nreturn 0;\r\n}\r\nint __init omap4_cm_init(void)\r\n{\r\nreturn cm_register(&omap4xxx_cm_ll_data);\r\n}\r\nstatic void __exit omap4_cm_exit(void)\r\n{\r\ncm_unregister(&omap4xxx_cm_ll_data);\r\n}
