static inline struct exynos_dsi *display_to_dsi(struct exynos_drm_display *d)\r\n{\r\nreturn container_of(d, struct exynos_dsi, display);\r\n}\r\nstatic inline struct exynos_dsi_driver_data *exynos_dsi_get_driver_data(\r\nstruct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(exynos_dsi_of_match, &pdev->dev);\r\nreturn (struct exynos_dsi_driver_data *)of_id->data;\r\n}\r\nstatic void exynos_dsi_wait_for_reset(struct exynos_dsi *dsi)\r\n{\r\nif (wait_for_completion_timeout(&dsi->completed, msecs_to_jiffies(300)))\r\nreturn;\r\ndev_err(dsi->dev, "timeout waiting for reset\n");\r\n}\r\nstatic void exynos_dsi_reset(struct exynos_dsi *dsi)\r\n{\r\nreinit_completion(&dsi->completed);\r\nwritel(DSIM_SWRST, dsi->reg_base + DSIM_SWRST_REG);\r\n}\r\nstatic unsigned long exynos_dsi_pll_find_pms(struct exynos_dsi *dsi,\r\nunsigned long fin, unsigned long fout, u8 *p, u16 *m, u8 *s)\r\n{\r\nunsigned long best_freq = 0;\r\nu32 min_delta = 0xffffffff;\r\nu8 p_min, p_max;\r\nu8 _p, uninitialized_var(best_p);\r\nu16 _m, uninitialized_var(best_m);\r\nu8 _s, uninitialized_var(best_s);\r\np_min = DIV_ROUND_UP(fin, (12 * MHZ));\r\np_max = fin / (6 * MHZ);\r\nfor (_p = p_min; _p <= p_max; ++_p) {\r\nfor (_s = 0; _s <= 5; ++_s) {\r\nu64 tmp;\r\nu32 delta;\r\ntmp = (u64)fout * (_p << _s);\r\ndo_div(tmp, fin);\r\n_m = tmp;\r\nif (_m < 41 || _m > 125)\r\ncontinue;\r\ntmp = (u64)_m * fin;\r\ndo_div(tmp, _p);\r\nif (tmp < 500 * MHZ || tmp > 1000 * MHZ)\r\ncontinue;\r\ntmp = (u64)_m * fin;\r\ndo_div(tmp, _p << _s);\r\ndelta = abs(fout - tmp);\r\nif (delta < min_delta) {\r\nbest_p = _p;\r\nbest_m = _m;\r\nbest_s = _s;\r\nmin_delta = delta;\r\nbest_freq = tmp;\r\n}\r\n}\r\n}\r\nif (best_freq) {\r\n*p = best_p;\r\n*m = best_m;\r\n*s = best_s;\r\n}\r\nreturn best_freq;\r\n}\r\nstatic unsigned long exynos_dsi_set_pll(struct exynos_dsi *dsi,\r\nunsigned long freq)\r\n{\r\nstruct exynos_dsi_driver_data *driver_data = dsi->driver_data;\r\nunsigned long fin, fout;\r\nint timeout;\r\nu8 p, s;\r\nu16 m;\r\nu32 reg;\r\nclk_set_rate(dsi->pll_clk, dsi->pll_clk_rate);\r\nfin = clk_get_rate(dsi->pll_clk);\r\nif (!fin) {\r\ndev_err(dsi->dev, "failed to get PLL clock frequency\n");\r\nreturn 0;\r\n}\r\ndev_dbg(dsi->dev, "PLL input frequency: %lu\n", fin);\r\nfout = exynos_dsi_pll_find_pms(dsi, fin, freq, &p, &m, &s);\r\nif (!fout) {\r\ndev_err(dsi->dev,\r\n"failed to find PLL PMS for requested frequency\n");\r\nreturn 0;\r\n}\r\ndev_dbg(dsi->dev, "PLL freq %lu, (p %d, m %d, s %d)\n", fout, p, m, s);\r\nwritel(500, dsi->reg_base + driver_data->plltmr_reg);\r\nreg = DSIM_PLL_EN | DSIM_PLL_P(p) | DSIM_PLL_M(m) | DSIM_PLL_S(s);\r\nif (driver_data->has_freqband) {\r\nstatic const unsigned long freq_bands[] = {\r\n100 * MHZ, 120 * MHZ, 160 * MHZ, 200 * MHZ,\r\n270 * MHZ, 320 * MHZ, 390 * MHZ, 450 * MHZ,\r\n510 * MHZ, 560 * MHZ, 640 * MHZ, 690 * MHZ,\r\n770 * MHZ, 870 * MHZ, 950 * MHZ,\r\n};\r\nint band;\r\nfor (band = 0; band < ARRAY_SIZE(freq_bands); ++band)\r\nif (fout < freq_bands[band])\r\nbreak;\r\ndev_dbg(dsi->dev, "band %d\n", band);\r\nreg |= DSIM_FREQ_BAND(band);\r\n}\r\nwritel(reg, dsi->reg_base + DSIM_PLLCTRL_REG);\r\ntimeout = 1000;\r\ndo {\r\nif (timeout-- == 0) {\r\ndev_err(dsi->dev, "PLL failed to stabilize\n");\r\nreturn 0;\r\n}\r\nreg = readl(dsi->reg_base + DSIM_STATUS_REG);\r\n} while ((reg & DSIM_PLL_STABLE) == 0);\r\nreturn fout;\r\n}\r\nstatic int exynos_dsi_enable_clock(struct exynos_dsi *dsi)\r\n{\r\nunsigned long hs_clk, byte_clk, esc_clk;\r\nunsigned long esc_div;\r\nu32 reg;\r\nhs_clk = exynos_dsi_set_pll(dsi, dsi->burst_clk_rate);\r\nif (!hs_clk) {\r\ndev_err(dsi->dev, "failed to configure DSI PLL\n");\r\nreturn -EFAULT;\r\n}\r\nbyte_clk = hs_clk / 8;\r\nesc_div = DIV_ROUND_UP(byte_clk, dsi->esc_clk_rate);\r\nesc_clk = byte_clk / esc_div;\r\nif (esc_clk > 20 * MHZ) {\r\n++esc_div;\r\nesc_clk = byte_clk / esc_div;\r\n}\r\ndev_dbg(dsi->dev, "hs_clk = %lu, byte_clk = %lu, esc_clk = %lu\n",\r\nhs_clk, byte_clk, esc_clk);\r\nreg = readl(dsi->reg_base + DSIM_CLKCTRL_REG);\r\nreg &= ~(DSIM_ESC_PRESCALER_MASK | DSIM_LANE_ESC_CLK_EN_CLK\r\n| DSIM_LANE_ESC_CLK_EN_DATA_MASK | DSIM_PLL_BYPASS\r\n| DSIM_BYTE_CLK_SRC_MASK);\r\nreg |= DSIM_ESC_CLKEN | DSIM_BYTE_CLKEN\r\n| DSIM_ESC_PRESCALER(esc_div)\r\n| DSIM_LANE_ESC_CLK_EN_CLK\r\n| DSIM_LANE_ESC_CLK_EN_DATA(BIT(dsi->lanes) - 1)\r\n| DSIM_BYTE_CLK_SRC(0)\r\n| DSIM_TX_REQUEST_HSCLK;\r\nwritel(reg, dsi->reg_base + DSIM_CLKCTRL_REG);\r\nreturn 0;\r\n}\r\nstatic void exynos_dsi_set_phy_ctrl(struct exynos_dsi *dsi)\r\n{\r\nstruct exynos_dsi_driver_data *driver_data = dsi->driver_data;\r\nu32 reg;\r\nif (driver_data->has_freqband)\r\nreturn;\r\nreg = DSIM_PHYCTRL_ULPS_EXIT(0x0af);\r\nwritel(reg, dsi->reg_base + DSIM_PHYCTRL_REG);\r\nreg = DSIM_PHYTIMING_LPX(0x06) | DSIM_PHYTIMING_HS_EXIT(0x0b);\r\nwritel(reg, dsi->reg_base + DSIM_PHYTIMING_REG);\r\nreg = DSIM_PHYTIMING1_CLK_PREPARE(0x07) |\r\nDSIM_PHYTIMING1_CLK_ZERO(0x27) |\r\nDSIM_PHYTIMING1_CLK_POST(0x0d) |\r\nDSIM_PHYTIMING1_CLK_TRAIL(0x08);\r\nwritel(reg, dsi->reg_base + DSIM_PHYTIMING1_REG);\r\nreg = DSIM_PHYTIMING2_HS_PREPARE(0x09) | DSIM_PHYTIMING2_HS_ZERO(0x0d) |\r\nDSIM_PHYTIMING2_HS_TRAIL(0x0b);\r\nwritel(reg, dsi->reg_base + DSIM_PHYTIMING2_REG);\r\n}\r\nstatic void exynos_dsi_disable_clock(struct exynos_dsi *dsi)\r\n{\r\nu32 reg;\r\nreg = readl(dsi->reg_base + DSIM_CLKCTRL_REG);\r\nreg &= ~(DSIM_LANE_ESC_CLK_EN_CLK | DSIM_LANE_ESC_CLK_EN_DATA_MASK\r\n| DSIM_ESC_CLKEN | DSIM_BYTE_CLKEN);\r\nwritel(reg, dsi->reg_base + DSIM_CLKCTRL_REG);\r\nreg = readl(dsi->reg_base + DSIM_PLLCTRL_REG);\r\nreg &= ~DSIM_PLL_EN;\r\nwritel(reg, dsi->reg_base + DSIM_PLLCTRL_REG);\r\n}\r\nstatic int exynos_dsi_init_link(struct exynos_dsi *dsi)\r\n{\r\nstruct exynos_dsi_driver_data *driver_data = dsi->driver_data;\r\nint timeout;\r\nu32 reg;\r\nu32 lanes_mask;\r\nreg = readl(dsi->reg_base + DSIM_FIFOCTRL_REG);\r\nreg &= ~0x1f;\r\nwritel(reg, dsi->reg_base + DSIM_FIFOCTRL_REG);\r\nusleep_range(9000, 11000);\r\nreg |= 0x1f;\r\nwritel(reg, dsi->reg_base + DSIM_FIFOCTRL_REG);\r\nusleep_range(9000, 11000);\r\nreg = 0;\r\nif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO) {\r\nreg |= DSIM_VIDEO_MODE;\r\nif (!(dsi->mode_flags & MIPI_DSI_MODE_VSYNC_FLUSH))\r\nreg |= DSIM_MFLUSH_VS;\r\nif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)\r\nreg |= DSIM_SYNC_INFORM;\r\nif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_BURST)\r\nreg |= DSIM_BURST_MODE;\r\nif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_AUTO_VERT)\r\nreg |= DSIM_AUTO_MODE;\r\nif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_HSE)\r\nreg |= DSIM_HSE_MODE;\r\nif (!(dsi->mode_flags & MIPI_DSI_MODE_VIDEO_HFP))\r\nreg |= DSIM_HFP_MODE;\r\nif (!(dsi->mode_flags & MIPI_DSI_MODE_VIDEO_HBP))\r\nreg |= DSIM_HBP_MODE;\r\nif (!(dsi->mode_flags & MIPI_DSI_MODE_VIDEO_HSA))\r\nreg |= DSIM_HSA_MODE;\r\n}\r\nif (!(dsi->mode_flags & MIPI_DSI_MODE_EOT_PACKET))\r\nreg |= DSIM_EOT_DISABLE;\r\nswitch (dsi->format) {\r\ncase MIPI_DSI_FMT_RGB888:\r\nreg |= DSIM_MAIN_PIX_FORMAT_RGB888;\r\nbreak;\r\ncase MIPI_DSI_FMT_RGB666:\r\nreg |= DSIM_MAIN_PIX_FORMAT_RGB666;\r\nbreak;\r\ncase MIPI_DSI_FMT_RGB666_PACKED:\r\nreg |= DSIM_MAIN_PIX_FORMAT_RGB666_P;\r\nbreak;\r\ncase MIPI_DSI_FMT_RGB565:\r\nreg |= DSIM_MAIN_PIX_FORMAT_RGB565;\r\nbreak;\r\ndefault:\r\ndev_err(dsi->dev, "invalid pixel format\n");\r\nreturn -EINVAL;\r\n}\r\nreg |= DSIM_NUM_OF_DATA_LANE(dsi->lanes - 1);\r\nwritel(reg, dsi->reg_base + DSIM_CONFIG_REG);\r\nreg |= DSIM_LANE_EN_CLK;\r\nwritel(reg, dsi->reg_base + DSIM_CONFIG_REG);\r\nlanes_mask = BIT(dsi->lanes) - 1;\r\nreg |= DSIM_LANE_EN(lanes_mask);\r\nwritel(reg, dsi->reg_base + DSIM_CONFIG_REG);\r\nif (driver_data->has_clklane_stop &&\r\ndsi->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS) {\r\nreg |= DSIM_CLKLANE_STOP;\r\nwritel(reg, dsi->reg_base + DSIM_CONFIG_REG);\r\n}\r\ntimeout = 100;\r\ndo {\r\nif (timeout-- == 0) {\r\ndev_err(dsi->dev, "waiting for bus lanes timed out\n");\r\nreturn -EFAULT;\r\n}\r\nreg = readl(dsi->reg_base + DSIM_STATUS_REG);\r\nif ((reg & DSIM_STOP_STATE_DAT(lanes_mask))\r\n!= DSIM_STOP_STATE_DAT(lanes_mask))\r\ncontinue;\r\n} while (!(reg & (DSIM_STOP_STATE_CLK | DSIM_TX_READY_HS_CLK)));\r\nreg = readl(dsi->reg_base + DSIM_ESCMODE_REG);\r\nreg &= ~DSIM_STOP_STATE_CNT_MASK;\r\nreg |= DSIM_STOP_STATE_CNT(0xf);\r\nwritel(reg, dsi->reg_base + DSIM_ESCMODE_REG);\r\nreg = DSIM_BTA_TIMEOUT(0xff) | DSIM_LPDR_TIMEOUT(0xffff);\r\nwritel(reg, dsi->reg_base + DSIM_TIMEOUT_REG);\r\nreturn 0;\r\n}\r\nstatic void exynos_dsi_set_display_mode(struct exynos_dsi *dsi)\r\n{\r\nstruct videomode *vm = &dsi->vm;\r\nu32 reg;\r\nif (dsi->mode_flags & MIPI_DSI_MODE_VIDEO) {\r\nreg = DSIM_CMD_ALLOW(0xf)\r\n| DSIM_STABLE_VFP(vm->vfront_porch)\r\n| DSIM_MAIN_VBP(vm->vback_porch);\r\nwritel(reg, dsi->reg_base + DSIM_MVPORCH_REG);\r\nreg = DSIM_MAIN_HFP(vm->hfront_porch)\r\n| DSIM_MAIN_HBP(vm->hback_porch);\r\nwritel(reg, dsi->reg_base + DSIM_MHPORCH_REG);\r\nreg = DSIM_MAIN_VSA(vm->vsync_len)\r\n| DSIM_MAIN_HSA(vm->hsync_len);\r\nwritel(reg, dsi->reg_base + DSIM_MSYNC_REG);\r\n}\r\nreg = DSIM_MAIN_HRESOL(vm->hactive) | DSIM_MAIN_VRESOL(vm->vactive);\r\nwritel(reg, dsi->reg_base + DSIM_MDRESOL_REG);\r\ndev_dbg(dsi->dev, "LCD size = %dx%d\n", vm->hactive, vm->vactive);\r\n}\r\nstatic void exynos_dsi_set_display_enable(struct exynos_dsi *dsi, bool enable)\r\n{\r\nu32 reg;\r\nreg = readl(dsi->reg_base + DSIM_MDRESOL_REG);\r\nif (enable)\r\nreg |= DSIM_MAIN_STAND_BY;\r\nelse\r\nreg &= ~DSIM_MAIN_STAND_BY;\r\nwritel(reg, dsi->reg_base + DSIM_MDRESOL_REG);\r\n}\r\nstatic int exynos_dsi_wait_for_hdr_fifo(struct exynos_dsi *dsi)\r\n{\r\nint timeout = 2000;\r\ndo {\r\nu32 reg = readl(dsi->reg_base + DSIM_FIFOCTRL_REG);\r\nif (!(reg & DSIM_SFR_HEADER_FULL))\r\nreturn 0;\r\nif (!cond_resched())\r\nusleep_range(950, 1050);\r\n} while (--timeout);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void exynos_dsi_set_cmd_lpm(struct exynos_dsi *dsi, bool lpm)\r\n{\r\nu32 v = readl(dsi->reg_base + DSIM_ESCMODE_REG);\r\nif (lpm)\r\nv |= DSIM_CMD_LPDT_LP;\r\nelse\r\nv &= ~DSIM_CMD_LPDT_LP;\r\nwritel(v, dsi->reg_base + DSIM_ESCMODE_REG);\r\n}\r\nstatic void exynos_dsi_force_bta(struct exynos_dsi *dsi)\r\n{\r\nu32 v = readl(dsi->reg_base + DSIM_ESCMODE_REG);\r\nv |= DSIM_FORCE_BTA;\r\nwritel(v, dsi->reg_base + DSIM_ESCMODE_REG);\r\n}\r\nstatic void exynos_dsi_send_to_fifo(struct exynos_dsi *dsi,\r\nstruct exynos_dsi_transfer *xfer)\r\n{\r\nstruct device *dev = dsi->dev;\r\nconst u8 *payload = xfer->tx_payload + xfer->tx_done;\r\nu16 length = xfer->tx_len - xfer->tx_done;\r\nbool first = !xfer->tx_done;\r\nu32 reg;\r\ndev_dbg(dev, "< xfer %p: tx len %u, done %u, rx len %u, done %u\n",\r\nxfer, xfer->tx_len, xfer->tx_done, xfer->rx_len, xfer->rx_done);\r\nif (length > DSI_TX_FIFO_SIZE)\r\nlength = DSI_TX_FIFO_SIZE;\r\nxfer->tx_done += length;\r\nwhile (length >= 4) {\r\nreg = (payload[3] << 24) | (payload[2] << 16)\r\n| (payload[1] << 8) | payload[0];\r\nwritel(reg, dsi->reg_base + DSIM_PAYLOAD_REG);\r\npayload += 4;\r\nlength -= 4;\r\n}\r\nreg = 0;\r\nswitch (length) {\r\ncase 3:\r\nreg |= payload[2] << 16;\r\ncase 2:\r\nreg |= payload[1] << 8;\r\ncase 1:\r\nreg |= payload[0];\r\nwritel(reg, dsi->reg_base + DSIM_PAYLOAD_REG);\r\nbreak;\r\ncase 0:\r\nbreak;\r\n}\r\nif (!first)\r\nreturn;\r\nreg = (xfer->data[1] << 16) | (xfer->data[0] << 8) | xfer->data_id;\r\nif (exynos_dsi_wait_for_hdr_fifo(dsi)) {\r\ndev_err(dev, "waiting for header FIFO timed out\n");\r\nreturn;\r\n}\r\nif (NEQV(xfer->flags & MIPI_DSI_MSG_USE_LPM,\r\ndsi->state & DSIM_STATE_CMD_LPM)) {\r\nexynos_dsi_set_cmd_lpm(dsi, xfer->flags & MIPI_DSI_MSG_USE_LPM);\r\ndsi->state ^= DSIM_STATE_CMD_LPM;\r\n}\r\nwritel(reg, dsi->reg_base + DSIM_PKTHDR_REG);\r\nif (xfer->flags & MIPI_DSI_MSG_REQ_ACK)\r\nexynos_dsi_force_bta(dsi);\r\n}\r\nstatic void exynos_dsi_read_from_fifo(struct exynos_dsi *dsi,\r\nstruct exynos_dsi_transfer *xfer)\r\n{\r\nu8 *payload = xfer->rx_payload + xfer->rx_done;\r\nbool first = !xfer->rx_done;\r\nstruct device *dev = dsi->dev;\r\nu16 length;\r\nu32 reg;\r\nif (first) {\r\nreg = readl(dsi->reg_base + DSIM_RXFIFO_REG);\r\nswitch (reg & 0x3f) {\r\ncase MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_2BYTE:\r\ncase MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE:\r\nif (xfer->rx_len >= 2) {\r\npayload[1] = reg >> 16;\r\n++xfer->rx_done;\r\n}\r\ncase MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_1BYTE:\r\ncase MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE:\r\npayload[0] = reg >> 8;\r\n++xfer->rx_done;\r\nxfer->rx_len = xfer->rx_done;\r\nxfer->result = 0;\r\ngoto clear_fifo;\r\ncase MIPI_DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT:\r\ndev_err(dev, "DSI Error Report: 0x%04x\n",\r\n(reg >> 8) & 0xffff);\r\nxfer->result = 0;\r\ngoto clear_fifo;\r\n}\r\nlength = (reg >> 8) & 0xffff;\r\nif (length > xfer->rx_len) {\r\ndev_err(dev,\r\n"response too long (%u > %u bytes), stripping\n",\r\nxfer->rx_len, length);\r\nlength = xfer->rx_len;\r\n} else if (length < xfer->rx_len)\r\nxfer->rx_len = length;\r\n}\r\nlength = xfer->rx_len - xfer->rx_done;\r\nxfer->rx_done += length;\r\nwhile (length >= 4) {\r\nreg = readl(dsi->reg_base + DSIM_RXFIFO_REG);\r\npayload[0] = (reg >> 0) & 0xff;\r\npayload[1] = (reg >> 8) & 0xff;\r\npayload[2] = (reg >> 16) & 0xff;\r\npayload[3] = (reg >> 24) & 0xff;\r\npayload += 4;\r\nlength -= 4;\r\n}\r\nif (length) {\r\nreg = readl(dsi->reg_base + DSIM_RXFIFO_REG);\r\nswitch (length) {\r\ncase 3:\r\npayload[2] = (reg >> 16) & 0xff;\r\ncase 2:\r\npayload[1] = (reg >> 8) & 0xff;\r\ncase 1:\r\npayload[0] = reg & 0xff;\r\n}\r\n}\r\nif (xfer->rx_done == xfer->rx_len)\r\nxfer->result = 0;\r\nclear_fifo:\r\nlength = DSI_RX_FIFO_SIZE / 4;\r\ndo {\r\nreg = readl(dsi->reg_base + DSIM_RXFIFO_REG);\r\nif (reg == DSI_RX_FIFO_EMPTY)\r\nbreak;\r\n} while (--length);\r\n}\r\nstatic void exynos_dsi_transfer_start(struct exynos_dsi *dsi)\r\n{\r\nunsigned long flags;\r\nstruct exynos_dsi_transfer *xfer;\r\nbool start = false;\r\nagain:\r\nspin_lock_irqsave(&dsi->transfer_lock, flags);\r\nif (list_empty(&dsi->transfer_list)) {\r\nspin_unlock_irqrestore(&dsi->transfer_lock, flags);\r\nreturn;\r\n}\r\nxfer = list_first_entry(&dsi->transfer_list,\r\nstruct exynos_dsi_transfer, list);\r\nspin_unlock_irqrestore(&dsi->transfer_lock, flags);\r\nif (xfer->tx_len && xfer->tx_done == xfer->tx_len)\r\nreturn;\r\nexynos_dsi_send_to_fifo(dsi, xfer);\r\nif (xfer->tx_len || xfer->rx_len)\r\nreturn;\r\nxfer->result = 0;\r\ncomplete(&xfer->completed);\r\nspin_lock_irqsave(&dsi->transfer_lock, flags);\r\nlist_del_init(&xfer->list);\r\nstart = !list_empty(&dsi->transfer_list);\r\nspin_unlock_irqrestore(&dsi->transfer_lock, flags);\r\nif (start)\r\ngoto again;\r\n}\r\nstatic bool exynos_dsi_transfer_finish(struct exynos_dsi *dsi)\r\n{\r\nstruct exynos_dsi_transfer *xfer;\r\nunsigned long flags;\r\nbool start = true;\r\nspin_lock_irqsave(&dsi->transfer_lock, flags);\r\nif (list_empty(&dsi->transfer_list)) {\r\nspin_unlock_irqrestore(&dsi->transfer_lock, flags);\r\nreturn false;\r\n}\r\nxfer = list_first_entry(&dsi->transfer_list,\r\nstruct exynos_dsi_transfer, list);\r\nspin_unlock_irqrestore(&dsi->transfer_lock, flags);\r\ndev_dbg(dsi->dev,\r\n"> xfer %p, tx_len %u, tx_done %u, rx_len %u, rx_done %u\n",\r\nxfer, xfer->tx_len, xfer->tx_done, xfer->rx_len, xfer->rx_done);\r\nif (xfer->tx_done != xfer->tx_len)\r\nreturn true;\r\nif (xfer->rx_done != xfer->rx_len)\r\nexynos_dsi_read_from_fifo(dsi, xfer);\r\nif (xfer->rx_done != xfer->rx_len)\r\nreturn true;\r\nspin_lock_irqsave(&dsi->transfer_lock, flags);\r\nlist_del_init(&xfer->list);\r\nstart = !list_empty(&dsi->transfer_list);\r\nspin_unlock_irqrestore(&dsi->transfer_lock, flags);\r\nif (!xfer->rx_len)\r\nxfer->result = 0;\r\ncomplete(&xfer->completed);\r\nreturn start;\r\n}\r\nstatic void exynos_dsi_remove_transfer(struct exynos_dsi *dsi,\r\nstruct exynos_dsi_transfer *xfer)\r\n{\r\nunsigned long flags;\r\nbool start;\r\nspin_lock_irqsave(&dsi->transfer_lock, flags);\r\nif (!list_empty(&dsi->transfer_list) &&\r\nxfer == list_first_entry(&dsi->transfer_list,\r\nstruct exynos_dsi_transfer, list)) {\r\nlist_del_init(&xfer->list);\r\nstart = !list_empty(&dsi->transfer_list);\r\nspin_unlock_irqrestore(&dsi->transfer_lock, flags);\r\nif (start)\r\nexynos_dsi_transfer_start(dsi);\r\nreturn;\r\n}\r\nlist_del_init(&xfer->list);\r\nspin_unlock_irqrestore(&dsi->transfer_lock, flags);\r\n}\r\nstatic int exynos_dsi_transfer(struct exynos_dsi *dsi,\r\nstruct exynos_dsi_transfer *xfer)\r\n{\r\nunsigned long flags;\r\nbool stopped;\r\nxfer->tx_done = 0;\r\nxfer->rx_done = 0;\r\nxfer->result = -ETIMEDOUT;\r\ninit_completion(&xfer->completed);\r\nspin_lock_irqsave(&dsi->transfer_lock, flags);\r\nstopped = list_empty(&dsi->transfer_list);\r\nlist_add_tail(&xfer->list, &dsi->transfer_list);\r\nspin_unlock_irqrestore(&dsi->transfer_lock, flags);\r\nif (stopped)\r\nexynos_dsi_transfer_start(dsi);\r\nwait_for_completion_timeout(&xfer->completed,\r\nmsecs_to_jiffies(DSI_XFER_TIMEOUT_MS));\r\nif (xfer->result == -ETIMEDOUT) {\r\nexynos_dsi_remove_transfer(dsi, xfer);\r\ndev_err(dsi->dev, "xfer timed out: %*ph %*ph\n", 2, xfer->data,\r\nxfer->tx_len, xfer->tx_payload);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn xfer->result;\r\n}\r\nstatic irqreturn_t exynos_dsi_irq(int irq, void *dev_id)\r\n{\r\nstruct exynos_dsi *dsi = dev_id;\r\nu32 status;\r\nstatus = readl(dsi->reg_base + DSIM_INTSRC_REG);\r\nif (!status) {\r\nstatic unsigned long int j;\r\nif (printk_timed_ratelimit(&j, 500))\r\ndev_warn(dsi->dev, "spurious interrupt\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nwritel(status, dsi->reg_base + DSIM_INTSRC_REG);\r\nif (status & DSIM_INT_SW_RST_RELEASE) {\r\nu32 mask = ~(DSIM_INT_RX_DONE | DSIM_INT_SFR_FIFO_EMPTY);\r\nwritel(mask, dsi->reg_base + DSIM_INTMSK_REG);\r\ncomplete(&dsi->completed);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (!(status & (DSIM_INT_RX_DONE | DSIM_INT_SFR_FIFO_EMPTY)))\r\nreturn IRQ_HANDLED;\r\nif (exynos_dsi_transfer_finish(dsi))\r\nexynos_dsi_transfer_start(dsi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t exynos_dsi_te_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct exynos_dsi *dsi = (struct exynos_dsi *)dev_id;\r\nstruct drm_encoder *encoder = dsi->display.encoder;\r\nif (dsi->state & DSIM_STATE_ENABLED)\r\nexynos_drm_crtc_te_handler(encoder->crtc);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void exynos_dsi_enable_irq(struct exynos_dsi *dsi)\r\n{\r\nenable_irq(dsi->irq);\r\nif (gpio_is_valid(dsi->te_gpio))\r\nenable_irq(gpio_to_irq(dsi->te_gpio));\r\n}\r\nstatic void exynos_dsi_disable_irq(struct exynos_dsi *dsi)\r\n{\r\nif (gpio_is_valid(dsi->te_gpio))\r\ndisable_irq(gpio_to_irq(dsi->te_gpio));\r\ndisable_irq(dsi->irq);\r\n}\r\nstatic int exynos_dsi_init(struct exynos_dsi *dsi)\r\n{\r\nexynos_dsi_reset(dsi);\r\nexynos_dsi_enable_irq(dsi);\r\nexynos_dsi_enable_clock(dsi);\r\nexynos_dsi_wait_for_reset(dsi);\r\nexynos_dsi_set_phy_ctrl(dsi);\r\nexynos_dsi_init_link(dsi);\r\nreturn 0;\r\n}\r\nstatic int exynos_dsi_register_te_irq(struct exynos_dsi *dsi)\r\n{\r\nint ret;\r\nint te_gpio_irq;\r\ndsi->te_gpio = of_get_named_gpio(dsi->panel_node, "te-gpios", 0);\r\nif (!gpio_is_valid(dsi->te_gpio)) {\r\ndev_err(dsi->dev, "no te-gpios specified\n");\r\nret = dsi->te_gpio;\r\ngoto out;\r\n}\r\nret = gpio_request_one(dsi->te_gpio, GPIOF_IN, "te_gpio");\r\nif (ret) {\r\ndev_err(dsi->dev, "gpio request failed with %d\n", ret);\r\ngoto out;\r\n}\r\nte_gpio_irq = gpio_to_irq(dsi->te_gpio);\r\nirq_set_status_flags(te_gpio_irq, IRQ_NOAUTOEN);\r\nret = request_threaded_irq(te_gpio_irq, exynos_dsi_te_irq_handler, NULL,\r\nIRQF_TRIGGER_RISING, "TE", dsi);\r\nif (ret) {\r\ndev_err(dsi->dev, "request interrupt failed with %d\n", ret);\r\ngpio_free(dsi->te_gpio);\r\ngoto out;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void exynos_dsi_unregister_te_irq(struct exynos_dsi *dsi)\r\n{\r\nif (gpio_is_valid(dsi->te_gpio)) {\r\nfree_irq(gpio_to_irq(dsi->te_gpio), dsi);\r\ngpio_free(dsi->te_gpio);\r\ndsi->te_gpio = -ENOENT;\r\n}\r\n}\r\nstatic int exynos_dsi_host_attach(struct mipi_dsi_host *host,\r\nstruct mipi_dsi_device *device)\r\n{\r\nstruct exynos_dsi *dsi = host_to_dsi(host);\r\ndsi->lanes = device->lanes;\r\ndsi->format = device->format;\r\ndsi->mode_flags = device->mode_flags;\r\ndsi->panel_node = device->dev.of_node;\r\nif (!(dsi->mode_flags & MIPI_DSI_MODE_VIDEO)) {\r\nint ret = exynos_dsi_register_te_irq(dsi);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (dsi->connector.dev)\r\ndrm_helper_hpd_irq_event(dsi->connector.dev);\r\nreturn 0;\r\n}\r\nstatic int exynos_dsi_host_detach(struct mipi_dsi_host *host,\r\nstruct mipi_dsi_device *device)\r\n{\r\nstruct exynos_dsi *dsi = host_to_dsi(host);\r\nexynos_dsi_unregister_te_irq(dsi);\r\ndsi->panel_node = NULL;\r\nif (dsi->connector.dev)\r\ndrm_helper_hpd_irq_event(dsi->connector.dev);\r\nreturn 0;\r\n}\r\nstatic bool exynos_dsi_is_short_dsi_type(u8 type)\r\n{\r\nreturn (type & 0x0f) <= 8;\r\n}\r\nstatic ssize_t exynos_dsi_host_transfer(struct mipi_dsi_host *host,\r\nconst struct mipi_dsi_msg *msg)\r\n{\r\nstruct exynos_dsi *dsi = host_to_dsi(host);\r\nstruct exynos_dsi_transfer xfer;\r\nint ret;\r\nif (!(dsi->state & DSIM_STATE_INITIALIZED)) {\r\nret = exynos_dsi_init(dsi);\r\nif (ret)\r\nreturn ret;\r\ndsi->state |= DSIM_STATE_INITIALIZED;\r\n}\r\nif (msg->tx_len == 0)\r\nreturn -EINVAL;\r\nxfer.data_id = msg->type | (msg->channel << 6);\r\nif (exynos_dsi_is_short_dsi_type(msg->type)) {\r\nconst char *tx_buf = msg->tx_buf;\r\nif (msg->tx_len > 2)\r\nreturn -EINVAL;\r\nxfer.tx_len = 0;\r\nxfer.data[0] = tx_buf[0];\r\nxfer.data[1] = (msg->tx_len == 2) ? tx_buf[1] : 0;\r\n} else {\r\nxfer.tx_len = msg->tx_len;\r\nxfer.data[0] = msg->tx_len & 0xff;\r\nxfer.data[1] = msg->tx_len >> 8;\r\nxfer.tx_payload = msg->tx_buf;\r\n}\r\nxfer.rx_len = msg->rx_len;\r\nxfer.rx_payload = msg->rx_buf;\r\nxfer.flags = msg->flags;\r\nret = exynos_dsi_transfer(dsi, &xfer);\r\nreturn (ret < 0) ? ret : xfer.rx_done;\r\n}\r\nstatic int exynos_dsi_poweron(struct exynos_dsi *dsi)\r\n{\r\nint ret;\r\nret = regulator_bulk_enable(ARRAY_SIZE(dsi->supplies), dsi->supplies);\r\nif (ret < 0) {\r\ndev_err(dsi->dev, "cannot enable regulators %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(dsi->bus_clk);\r\nif (ret < 0) {\r\ndev_err(dsi->dev, "cannot enable bus clock %d\n", ret);\r\ngoto err_bus_clk;\r\n}\r\nret = clk_prepare_enable(dsi->pll_clk);\r\nif (ret < 0) {\r\ndev_err(dsi->dev, "cannot enable pll clock %d\n", ret);\r\ngoto err_pll_clk;\r\n}\r\nret = phy_power_on(dsi->phy);\r\nif (ret < 0) {\r\ndev_err(dsi->dev, "cannot enable phy %d\n", ret);\r\ngoto err_phy;\r\n}\r\nreturn 0;\r\nerr_phy:\r\nclk_disable_unprepare(dsi->pll_clk);\r\nerr_pll_clk:\r\nclk_disable_unprepare(dsi->bus_clk);\r\nerr_bus_clk:\r\nregulator_bulk_disable(ARRAY_SIZE(dsi->supplies), dsi->supplies);\r\nreturn ret;\r\n}\r\nstatic void exynos_dsi_poweroff(struct exynos_dsi *dsi)\r\n{\r\nint ret;\r\nusleep_range(10000, 20000);\r\nif (dsi->state & DSIM_STATE_INITIALIZED) {\r\ndsi->state &= ~DSIM_STATE_INITIALIZED;\r\nexynos_dsi_disable_clock(dsi);\r\nexynos_dsi_disable_irq(dsi);\r\n}\r\ndsi->state &= ~DSIM_STATE_CMD_LPM;\r\nphy_power_off(dsi->phy);\r\nclk_disable_unprepare(dsi->pll_clk);\r\nclk_disable_unprepare(dsi->bus_clk);\r\nret = regulator_bulk_disable(ARRAY_SIZE(dsi->supplies), dsi->supplies);\r\nif (ret < 0)\r\ndev_err(dsi->dev, "cannot disable regulators %d\n", ret);\r\n}\r\nstatic int exynos_dsi_enable(struct exynos_dsi *dsi)\r\n{\r\nint ret;\r\nif (dsi->state & DSIM_STATE_ENABLED)\r\nreturn 0;\r\nret = exynos_dsi_poweron(dsi);\r\nif (ret < 0)\r\nreturn ret;\r\nret = drm_panel_prepare(dsi->panel);\r\nif (ret < 0) {\r\nexynos_dsi_poweroff(dsi);\r\nreturn ret;\r\n}\r\nexynos_dsi_set_display_mode(dsi);\r\nexynos_dsi_set_display_enable(dsi, true);\r\ndsi->state |= DSIM_STATE_ENABLED;\r\nret = drm_panel_enable(dsi->panel);\r\nif (ret < 0) {\r\ndsi->state &= ~DSIM_STATE_ENABLED;\r\nexynos_dsi_set_display_enable(dsi, false);\r\ndrm_panel_unprepare(dsi->panel);\r\nexynos_dsi_poweroff(dsi);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void exynos_dsi_disable(struct exynos_dsi *dsi)\r\n{\r\nif (!(dsi->state & DSIM_STATE_ENABLED))\r\nreturn;\r\ndrm_panel_disable(dsi->panel);\r\nexynos_dsi_set_display_enable(dsi, false);\r\ndrm_panel_unprepare(dsi->panel);\r\nexynos_dsi_poweroff(dsi);\r\ndsi->state &= ~DSIM_STATE_ENABLED;\r\n}\r\nstatic void exynos_dsi_dpms(struct exynos_drm_display *display, int mode)\r\n{\r\nstruct exynos_dsi *dsi = display_to_dsi(display);\r\nif (dsi->panel) {\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nexynos_dsi_enable(dsi);\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ncase DRM_MODE_DPMS_OFF:\r\nexynos_dsi_disable(dsi);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic enum drm_connector_status\r\nexynos_dsi_detect(struct drm_connector *connector, bool force)\r\n{\r\nstruct exynos_dsi *dsi = connector_to_dsi(connector);\r\nif (!dsi->panel) {\r\ndsi->panel = of_drm_find_panel(dsi->panel_node);\r\nif (dsi->panel)\r\ndrm_panel_attach(dsi->panel, &dsi->connector);\r\n} else if (!dsi->panel_node) {\r\nstruct exynos_drm_display *display;\r\ndisplay = platform_get_drvdata(to_platform_device(dsi->dev));\r\nexynos_dsi_dpms(display, DRM_MODE_DPMS_OFF);\r\ndrm_panel_detach(dsi->panel);\r\ndsi->panel = NULL;\r\n}\r\nif (dsi->panel)\r\nreturn connector_status_connected;\r\nreturn connector_status_disconnected;\r\n}\r\nstatic void exynos_dsi_connector_destroy(struct drm_connector *connector)\r\n{\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\nconnector->dev = NULL;\r\n}\r\nstatic int exynos_dsi_get_modes(struct drm_connector *connector)\r\n{\r\nstruct exynos_dsi *dsi = connector_to_dsi(connector);\r\nif (dsi->panel)\r\nreturn dsi->panel->funcs->get_modes(dsi->panel);\r\nreturn 0;\r\n}\r\nstatic int exynos_dsi_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nreturn MODE_OK;\r\n}\r\nstatic struct drm_encoder *\r\nexynos_dsi_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct exynos_dsi *dsi = connector_to_dsi(connector);\r\nreturn dsi->display.encoder;\r\n}\r\nstatic int exynos_dsi_create_connector(struct exynos_drm_display *display,\r\nstruct drm_encoder *encoder)\r\n{\r\nstruct exynos_dsi *dsi = display_to_dsi(display);\r\nstruct drm_connector *connector = &dsi->connector;\r\nint ret;\r\nconnector->polled = DRM_CONNECTOR_POLL_HPD;\r\nret = drm_connector_init(encoder->dev, connector,\r\n&exynos_dsi_connector_funcs,\r\nDRM_MODE_CONNECTOR_DSI);\r\nif (ret) {\r\nDRM_ERROR("Failed to initialize connector with drm\n");\r\nreturn ret;\r\n}\r\ndrm_connector_helper_add(connector, &exynos_dsi_connector_helper_funcs);\r\ndrm_connector_register(connector);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nreturn 0;\r\n}\r\nstatic void exynos_dsi_mode_set(struct exynos_drm_display *display,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct exynos_dsi *dsi = display_to_dsi(display);\r\nstruct videomode *vm = &dsi->vm;\r\nvm->hactive = mode->hdisplay;\r\nvm->vactive = mode->vdisplay;\r\nvm->vfront_porch = mode->vsync_start - mode->vdisplay;\r\nvm->vback_porch = mode->vtotal - mode->vsync_end;\r\nvm->vsync_len = mode->vsync_end - mode->vsync_start;\r\nvm->hfront_porch = mode->hsync_start - mode->hdisplay;\r\nvm->hback_porch = mode->htotal - mode->hsync_end;\r\nvm->hsync_len = mode->hsync_end - mode->hsync_start;\r\n}\r\nstatic struct device_node *\r\nof_get_child_by_name_reg(struct device_node *parent, const char *name, u32 reg)\r\n{\r\nstruct device_node *np;\r\nfor_each_child_of_node(parent, np) {\r\nu32 r;\r\nif (!np->name || of_node_cmp(np->name, name))\r\ncontinue;\r\nif (of_property_read_u32(np, "reg", &r) < 0)\r\nr = 0;\r\nif (reg == r)\r\nbreak;\r\n}\r\nreturn np;\r\n}\r\nstatic struct device_node *of_graph_get_port_by_reg(struct device_node *parent,\r\nu32 reg)\r\n{\r\nstruct device_node *ports, *port;\r\nports = of_get_child_by_name(parent, "ports");\r\nif (ports)\r\nparent = ports;\r\nport = of_get_child_by_name_reg(parent, "port", reg);\r\nof_node_put(ports);\r\nreturn port;\r\n}\r\nstatic struct device_node *\r\nof_graph_get_endpoint_by_reg(struct device_node *port, u32 reg)\r\n{\r\nreturn of_get_child_by_name_reg(port, "endpoint", reg);\r\n}\r\nstatic int exynos_dsi_of_read_u32(const struct device_node *np,\r\nconst char *propname, u32 *out_value)\r\n{\r\nint ret = of_property_read_u32(np, propname, out_value);\r\nif (ret < 0)\r\npr_err("%s: failed to get '%s' property\n", np->full_name,\r\npropname);\r\nreturn ret;\r\n}\r\nstatic int exynos_dsi_parse_dt(struct exynos_dsi *dsi)\r\n{\r\nstruct device *dev = dsi->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct device_node *port, *ep;\r\nint ret;\r\nret = exynos_dsi_of_read_u32(node, "samsung,pll-clock-frequency",\r\n&dsi->pll_clk_rate);\r\nif (ret < 0)\r\nreturn ret;\r\nport = of_graph_get_port_by_reg(node, DSI_PORT_OUT);\r\nif (!port) {\r\ndev_err(dev, "no output port specified\n");\r\nreturn -EINVAL;\r\n}\r\nep = of_graph_get_endpoint_by_reg(port, 0);\r\nof_node_put(port);\r\nif (!ep) {\r\ndev_err(dev, "no endpoint specified in output port\n");\r\nreturn -EINVAL;\r\n}\r\nret = exynos_dsi_of_read_u32(ep, "samsung,burst-clock-frequency",\r\n&dsi->burst_clk_rate);\r\nif (ret < 0)\r\ngoto end;\r\nret = exynos_dsi_of_read_u32(ep, "samsung,esc-clock-frequency",\r\n&dsi->esc_clk_rate);\r\nend:\r\nof_node_put(ep);\r\nreturn ret;\r\n}\r\nstatic int exynos_dsi_bind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct exynos_drm_display *display = dev_get_drvdata(dev);\r\nstruct exynos_dsi *dsi = display_to_dsi(display);\r\nstruct drm_device *drm_dev = data;\r\nint ret;\r\nret = exynos_drm_create_enc_conn(drm_dev, display);\r\nif (ret) {\r\nDRM_ERROR("Encoder create [%d] failed with %d\n",\r\ndisplay->type, ret);\r\nreturn ret;\r\n}\r\nreturn mipi_dsi_host_register(&dsi->dsi_host);\r\n}\r\nstatic void exynos_dsi_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct exynos_drm_display *display = dev_get_drvdata(dev);\r\nstruct exynos_dsi *dsi = display_to_dsi(display);\r\nexynos_dsi_dpms(display, DRM_MODE_DPMS_OFF);\r\nmipi_dsi_host_unregister(&dsi->dsi_host);\r\n}\r\nstatic int exynos_dsi_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct exynos_dsi *dsi;\r\nint ret;\r\ndsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);\r\nif (!dsi)\r\nreturn -ENOMEM;\r\ndsi->display.type = EXYNOS_DISPLAY_TYPE_LCD;\r\ndsi->display.ops = &exynos_dsi_display_ops;\r\nret = exynos_drm_component_add(dev, EXYNOS_DEVICE_TYPE_CONNECTOR,\r\ndsi->display.type);\r\nif (ret)\r\nreturn ret;\r\ndsi->te_gpio = -ENOENT;\r\ninit_completion(&dsi->completed);\r\nspin_lock_init(&dsi->transfer_lock);\r\nINIT_LIST_HEAD(&dsi->transfer_list);\r\ndsi->dsi_host.ops = &exynos_dsi_ops;\r\ndsi->dsi_host.dev = dev;\r\ndsi->dev = dev;\r\ndsi->driver_data = exynos_dsi_get_driver_data(pdev);\r\nret = exynos_dsi_parse_dt(dsi);\r\nif (ret)\r\ngoto err_del_component;\r\ndsi->supplies[0].supply = "vddcore";\r\ndsi->supplies[1].supply = "vddio";\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(dsi->supplies),\r\ndsi->supplies);\r\nif (ret) {\r\ndev_info(dev, "failed to get regulators: %d\n", ret);\r\nreturn -EPROBE_DEFER;\r\n}\r\ndsi->pll_clk = devm_clk_get(dev, "pll_clk");\r\nif (IS_ERR(dsi->pll_clk)) {\r\ndev_info(dev, "failed to get dsi pll input clock\n");\r\nret = PTR_ERR(dsi->pll_clk);\r\ngoto err_del_component;\r\n}\r\ndsi->bus_clk = devm_clk_get(dev, "bus_clk");\r\nif (IS_ERR(dsi->bus_clk)) {\r\ndev_info(dev, "failed to get dsi bus clock\n");\r\nret = PTR_ERR(dsi->bus_clk);\r\ngoto err_del_component;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndsi->reg_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(dsi->reg_base)) {\r\ndev_err(dev, "failed to remap io region\n");\r\nret = PTR_ERR(dsi->reg_base);\r\ngoto err_del_component;\r\n}\r\ndsi->phy = devm_phy_get(dev, "dsim");\r\nif (IS_ERR(dsi->phy)) {\r\ndev_info(dev, "failed to get dsim phy\n");\r\nret = PTR_ERR(dsi->phy);\r\ngoto err_del_component;\r\n}\r\ndsi->irq = platform_get_irq(pdev, 0);\r\nif (dsi->irq < 0) {\r\ndev_err(dev, "failed to request dsi irq resource\n");\r\nret = dsi->irq;\r\ngoto err_del_component;\r\n}\r\nirq_set_status_flags(dsi->irq, IRQ_NOAUTOEN);\r\nret = devm_request_threaded_irq(dev, dsi->irq, NULL,\r\nexynos_dsi_irq, IRQF_ONESHOT,\r\ndev_name(dev), dsi);\r\nif (ret) {\r\ndev_err(dev, "failed to request dsi irq\n");\r\ngoto err_del_component;\r\n}\r\nplatform_set_drvdata(pdev, &dsi->display);\r\nret = component_add(dev, &exynos_dsi_component_ops);\r\nif (ret)\r\ngoto err_del_component;\r\nreturn ret;\r\nerr_del_component:\r\nexynos_drm_component_del(dev, EXYNOS_DEVICE_TYPE_CONNECTOR);\r\nreturn ret;\r\n}\r\nstatic int exynos_dsi_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &exynos_dsi_component_ops);\r\nexynos_drm_component_del(&pdev->dev, EXYNOS_DEVICE_TYPE_CONNECTOR);\r\nreturn 0;\r\n}
