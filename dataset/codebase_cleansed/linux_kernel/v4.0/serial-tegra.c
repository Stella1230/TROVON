static inline unsigned long tegra_uart_read(struct tegra_uart_port *tup,\r\nunsigned long reg)\r\n{\r\nreturn readl(tup->uport.membase + (reg << tup->uport.regshift));\r\n}\r\nstatic inline void tegra_uart_write(struct tegra_uart_port *tup, unsigned val,\r\nunsigned long reg)\r\n{\r\nwritel(val, tup->uport.membase + (reg << tup->uport.regshift));\r\n}\r\nstatic inline struct tegra_uart_port *to_tegra_uport(struct uart_port *u)\r\n{\r\nreturn container_of(u, struct tegra_uart_port, uport);\r\n}\r\nstatic unsigned int tegra_uart_get_mctrl(struct uart_port *u)\r\n{\r\nstruct tegra_uart_port *tup = to_tegra_uport(u);\r\nif (tup->enable_modem_interrupt)\r\nreturn TIOCM_RI | TIOCM_CD | TIOCM_DSR | TIOCM_CTS;\r\nreturn TIOCM_CTS;\r\n}\r\nstatic void set_rts(struct tegra_uart_port *tup, bool active)\r\n{\r\nunsigned long mcr;\r\nmcr = tup->mcr_shadow;\r\nif (active)\r\nmcr |= TEGRA_UART_MCR_RTS_EN;\r\nelse\r\nmcr &= ~TEGRA_UART_MCR_RTS_EN;\r\nif (mcr != tup->mcr_shadow) {\r\ntegra_uart_write(tup, mcr, UART_MCR);\r\ntup->mcr_shadow = mcr;\r\n}\r\nreturn;\r\n}\r\nstatic void set_dtr(struct tegra_uart_port *tup, bool active)\r\n{\r\nunsigned long mcr;\r\nmcr = tup->mcr_shadow;\r\nif (active)\r\nmcr |= UART_MCR_DTR;\r\nelse\r\nmcr &= ~UART_MCR_DTR;\r\nif (mcr != tup->mcr_shadow) {\r\ntegra_uart_write(tup, mcr, UART_MCR);\r\ntup->mcr_shadow = mcr;\r\n}\r\nreturn;\r\n}\r\nstatic void tegra_uart_set_mctrl(struct uart_port *u, unsigned int mctrl)\r\n{\r\nstruct tegra_uart_port *tup = to_tegra_uport(u);\r\nunsigned long mcr;\r\nint dtr_enable;\r\nmcr = tup->mcr_shadow;\r\ntup->rts_active = !!(mctrl & TIOCM_RTS);\r\nset_rts(tup, tup->rts_active);\r\ndtr_enable = !!(mctrl & TIOCM_DTR);\r\nset_dtr(tup, dtr_enable);\r\nreturn;\r\n}\r\nstatic void tegra_uart_break_ctl(struct uart_port *u, int break_ctl)\r\n{\r\nstruct tegra_uart_port *tup = to_tegra_uport(u);\r\nunsigned long lcr;\r\nlcr = tup->lcr_shadow;\r\nif (break_ctl)\r\nlcr |= UART_LCR_SBC;\r\nelse\r\nlcr &= ~UART_LCR_SBC;\r\ntegra_uart_write(tup, lcr, UART_LCR);\r\ntup->lcr_shadow = lcr;\r\n}\r\nstatic void tegra_uart_wait_sym_time(struct tegra_uart_port *tup,\r\nunsigned int syms)\r\n{\r\nif (tup->current_baud)\r\nudelay(DIV_ROUND_UP(syms * tup->symb_bit * 1000000,\r\ntup->current_baud));\r\n}\r\nstatic void tegra_uart_fifo_reset(struct tegra_uart_port *tup, u8 fcr_bits)\r\n{\r\nunsigned long fcr = tup->fcr_shadow;\r\nif (tup->cdata->allow_txfifo_reset_fifo_mode) {\r\nfcr |= fcr_bits & (UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\r\ntegra_uart_write(tup, fcr, UART_FCR);\r\n} else {\r\nfcr &= ~UART_FCR_ENABLE_FIFO;\r\ntegra_uart_write(tup, fcr, UART_FCR);\r\nudelay(60);\r\nfcr |= fcr_bits & (UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\r\ntegra_uart_write(tup, fcr, UART_FCR);\r\nfcr |= UART_FCR_ENABLE_FIFO;\r\ntegra_uart_write(tup, fcr, UART_FCR);\r\n}\r\ntegra_uart_read(tup, UART_SCR);\r\ntegra_uart_wait_sym_time(tup, 1);\r\n}\r\nstatic int tegra_set_baudrate(struct tegra_uart_port *tup, unsigned int baud)\r\n{\r\nunsigned long rate;\r\nunsigned int divisor;\r\nunsigned long lcr;\r\nint ret;\r\nif (tup->current_baud == baud)\r\nreturn 0;\r\nif (tup->cdata->support_clk_src_div) {\r\nrate = baud * 16;\r\nret = clk_set_rate(tup->uart_clk, rate);\r\nif (ret < 0) {\r\ndev_err(tup->uport.dev,\r\n"clk_set_rate() failed for rate %lu\n", rate);\r\nreturn ret;\r\n}\r\ndivisor = 1;\r\n} else {\r\nrate = clk_get_rate(tup->uart_clk);\r\ndivisor = DIV_ROUND_CLOSEST(rate, baud * 16);\r\n}\r\nlcr = tup->lcr_shadow;\r\nlcr |= UART_LCR_DLAB;\r\ntegra_uart_write(tup, lcr, UART_LCR);\r\ntegra_uart_write(tup, divisor & 0xFF, UART_TX);\r\ntegra_uart_write(tup, ((divisor >> 8) & 0xFF), UART_IER);\r\nlcr &= ~UART_LCR_DLAB;\r\ntegra_uart_write(tup, lcr, UART_LCR);\r\ntegra_uart_read(tup, UART_SCR);\r\ntup->current_baud = baud;\r\ntegra_uart_wait_sym_time(tup, 2);\r\nreturn 0;\r\n}\r\nstatic char tegra_uart_decode_rx_error(struct tegra_uart_port *tup,\r\nunsigned long lsr)\r\n{\r\nchar flag = TTY_NORMAL;\r\nif (unlikely(lsr & TEGRA_UART_LSR_ANY)) {\r\nif (lsr & UART_LSR_OE) {\r\nflag = TTY_OVERRUN;\r\ntup->uport.icount.overrun++;\r\ndev_err(tup->uport.dev, "Got overrun errors\n");\r\n} else if (lsr & UART_LSR_PE) {\r\nflag = TTY_PARITY;\r\ntup->uport.icount.parity++;\r\ndev_err(tup->uport.dev, "Got Parity errors\n");\r\n} else if (lsr & UART_LSR_FE) {\r\nflag = TTY_FRAME;\r\ntup->uport.icount.frame++;\r\ndev_err(tup->uport.dev, "Got frame errors\n");\r\n} else if (lsr & UART_LSR_BI) {\r\ndev_err(tup->uport.dev, "Got Break\n");\r\ntup->uport.icount.brk++;\r\nif (!(lsr & UART_LSR_DR) && (lsr & UART_LSR_FIFOE))\r\ntegra_uart_fifo_reset(tup, UART_FCR_CLEAR_RCVR);\r\n}\r\n}\r\nreturn flag;\r\n}\r\nstatic int tegra_uart_request_port(struct uart_port *u)\r\n{\r\nreturn 0;\r\n}\r\nstatic void tegra_uart_release_port(struct uart_port *u)\r\n{\r\n}\r\nstatic void tegra_uart_fill_tx_fifo(struct tegra_uart_port *tup, int max_bytes)\r\n{\r\nstruct circ_buf *xmit = &tup->uport.state->xmit;\r\nint i;\r\nfor (i = 0; i < max_bytes; i++) {\r\nBUG_ON(uart_circ_empty(xmit));\r\nif (tup->cdata->tx_fifo_full_status) {\r\nunsigned long lsr = tegra_uart_read(tup, UART_LSR);\r\nif ((lsr & TEGRA_UART_LSR_TXFIFO_FULL))\r\nbreak;\r\n}\r\ntegra_uart_write(tup, xmit->buf[xmit->tail], UART_TX);\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\ntup->uport.icount.tx++;\r\n}\r\n}\r\nstatic void tegra_uart_start_pio_tx(struct tegra_uart_port *tup,\r\nunsigned int bytes)\r\n{\r\nif (bytes > TEGRA_UART_MIN_DMA)\r\nbytes = TEGRA_UART_MIN_DMA;\r\ntup->tx_in_progress = TEGRA_UART_TX_PIO;\r\ntup->tx_bytes = bytes;\r\ntup->ier_shadow |= UART_IER_THRI;\r\ntegra_uart_write(tup, tup->ier_shadow, UART_IER);\r\n}\r\nstatic void tegra_uart_tx_dma_complete(void *args)\r\n{\r\nstruct tegra_uart_port *tup = args;\r\nstruct circ_buf *xmit = &tup->uport.state->xmit;\r\nstruct dma_tx_state state;\r\nunsigned long flags;\r\nint count;\r\ndmaengine_tx_status(tup->tx_dma_chan, tup->rx_cookie, &state);\r\ncount = tup->tx_bytes_requested - state.residue;\r\nasync_tx_ack(tup->tx_dma_desc);\r\nspin_lock_irqsave(&tup->uport.lock, flags);\r\nxmit->tail = (xmit->tail + count) & (UART_XMIT_SIZE - 1);\r\ntup->tx_in_progress = 0;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&tup->uport);\r\ntegra_uart_start_next_tx(tup);\r\nspin_unlock_irqrestore(&tup->uport.lock, flags);\r\n}\r\nstatic int tegra_uart_start_tx_dma(struct tegra_uart_port *tup,\r\nunsigned long count)\r\n{\r\nstruct circ_buf *xmit = &tup->uport.state->xmit;\r\ndma_addr_t tx_phys_addr;\r\ndma_sync_single_for_device(tup->uport.dev, tup->tx_dma_buf_phys,\r\nUART_XMIT_SIZE, DMA_TO_DEVICE);\r\ntup->tx_bytes = count & ~(0xF);\r\ntx_phys_addr = tup->tx_dma_buf_phys + xmit->tail;\r\ntup->tx_dma_desc = dmaengine_prep_slave_single(tup->tx_dma_chan,\r\ntx_phys_addr, tup->tx_bytes, DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT);\r\nif (!tup->tx_dma_desc) {\r\ndev_err(tup->uport.dev, "Not able to get desc for Tx\n");\r\nreturn -EIO;\r\n}\r\ntup->tx_dma_desc->callback = tegra_uart_tx_dma_complete;\r\ntup->tx_dma_desc->callback_param = tup;\r\ntup->tx_in_progress = TEGRA_UART_TX_DMA;\r\ntup->tx_bytes_requested = tup->tx_bytes;\r\ntup->tx_cookie = dmaengine_submit(tup->tx_dma_desc);\r\ndma_async_issue_pending(tup->tx_dma_chan);\r\nreturn 0;\r\n}\r\nstatic void tegra_uart_start_next_tx(struct tegra_uart_port *tup)\r\n{\r\nunsigned long tail;\r\nunsigned long count;\r\nstruct circ_buf *xmit = &tup->uport.state->xmit;\r\ntail = (unsigned long)&xmit->buf[xmit->tail];\r\ncount = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);\r\nif (!count)\r\nreturn;\r\nif (count < TEGRA_UART_MIN_DMA)\r\ntegra_uart_start_pio_tx(tup, count);\r\nelse if (BYTES_TO_ALIGN(tail) > 0)\r\ntegra_uart_start_pio_tx(tup, BYTES_TO_ALIGN(tail));\r\nelse\r\ntegra_uart_start_tx_dma(tup, count);\r\n}\r\nstatic void tegra_uart_start_tx(struct uart_port *u)\r\n{\r\nstruct tegra_uart_port *tup = to_tegra_uport(u);\r\nstruct circ_buf *xmit = &u->state->xmit;\r\nif (!uart_circ_empty(xmit) && !tup->tx_in_progress)\r\ntegra_uart_start_next_tx(tup);\r\n}\r\nstatic unsigned int tegra_uart_tx_empty(struct uart_port *u)\r\n{\r\nstruct tegra_uart_port *tup = to_tegra_uport(u);\r\nunsigned int ret = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&u->lock, flags);\r\nif (!tup->tx_in_progress) {\r\nunsigned long lsr = tegra_uart_read(tup, UART_LSR);\r\nif ((lsr & TX_EMPTY_STATUS) == TX_EMPTY_STATUS)\r\nret = TIOCSER_TEMT;\r\n}\r\nspin_unlock_irqrestore(&u->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void tegra_uart_stop_tx(struct uart_port *u)\r\n{\r\nstruct tegra_uart_port *tup = to_tegra_uport(u);\r\nstruct circ_buf *xmit = &tup->uport.state->xmit;\r\nstruct dma_tx_state state;\r\nint count;\r\nif (tup->tx_in_progress != TEGRA_UART_TX_DMA)\r\nreturn;\r\ndmaengine_terminate_all(tup->tx_dma_chan);\r\ndmaengine_tx_status(tup->tx_dma_chan, tup->tx_cookie, &state);\r\ncount = tup->tx_bytes_requested - state.residue;\r\nasync_tx_ack(tup->tx_dma_desc);\r\nxmit->tail = (xmit->tail + count) & (UART_XMIT_SIZE - 1);\r\ntup->tx_in_progress = 0;\r\nreturn;\r\n}\r\nstatic void tegra_uart_handle_tx_pio(struct tegra_uart_port *tup)\r\n{\r\nstruct circ_buf *xmit = &tup->uport.state->xmit;\r\ntegra_uart_fill_tx_fifo(tup, tup->tx_bytes);\r\ntup->tx_in_progress = 0;\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&tup->uport);\r\ntegra_uart_start_next_tx(tup);\r\nreturn;\r\n}\r\nstatic void tegra_uart_handle_rx_pio(struct tegra_uart_port *tup,\r\nstruct tty_port *tty)\r\n{\r\ndo {\r\nchar flag = TTY_NORMAL;\r\nunsigned long lsr = 0;\r\nunsigned char ch;\r\nlsr = tegra_uart_read(tup, UART_LSR);\r\nif (!(lsr & UART_LSR_DR))\r\nbreak;\r\nflag = tegra_uart_decode_rx_error(tup, lsr);\r\nch = (unsigned char) tegra_uart_read(tup, UART_RX);\r\ntup->uport.icount.rx++;\r\nif (!uart_handle_sysrq_char(&tup->uport, ch) && tty)\r\ntty_insert_flip_char(tty, ch, flag);\r\n} while (1);\r\nreturn;\r\n}\r\nstatic void tegra_uart_copy_rx_to_tty(struct tegra_uart_port *tup,\r\nstruct tty_port *tty, int count)\r\n{\r\nint copied;\r\ntup->uport.icount.rx += count;\r\nif (!tty) {\r\ndev_err(tup->uport.dev, "No tty port\n");\r\nreturn;\r\n}\r\ndma_sync_single_for_cpu(tup->uport.dev, tup->rx_dma_buf_phys,\r\nTEGRA_UART_RX_DMA_BUFFER_SIZE, DMA_FROM_DEVICE);\r\ncopied = tty_insert_flip_string(tty,\r\n((unsigned char *)(tup->rx_dma_buf_virt)), count);\r\nif (copied != count) {\r\nWARN_ON(1);\r\ndev_err(tup->uport.dev, "RxData copy to tty layer failed\n");\r\n}\r\ndma_sync_single_for_device(tup->uport.dev, tup->rx_dma_buf_phys,\r\nTEGRA_UART_RX_DMA_BUFFER_SIZE, DMA_TO_DEVICE);\r\n}\r\nstatic void tegra_uart_rx_dma_complete(void *args)\r\n{\r\nstruct tegra_uart_port *tup = args;\r\nstruct uart_port *u = &tup->uport;\r\nint count = tup->rx_bytes_requested;\r\nstruct tty_struct *tty = tty_port_tty_get(&tup->uport.state->port);\r\nstruct tty_port *port = &u->state->port;\r\nunsigned long flags;\r\nasync_tx_ack(tup->rx_dma_desc);\r\nspin_lock_irqsave(&u->lock, flags);\r\nif (tup->rts_active)\r\nset_rts(tup, false);\r\nif (count)\r\ntegra_uart_copy_rx_to_tty(tup, port, count);\r\ntegra_uart_handle_rx_pio(tup, port);\r\nif (tty) {\r\nspin_unlock_irqrestore(&u->lock, flags);\r\ntty_flip_buffer_push(port);\r\nspin_lock_irqsave(&u->lock, flags);\r\ntty_kref_put(tty);\r\n}\r\ntegra_uart_start_rx_dma(tup);\r\nif (tup->rts_active)\r\nset_rts(tup, true);\r\nspin_unlock_irqrestore(&u->lock, flags);\r\n}\r\nstatic void tegra_uart_handle_rx_dma(struct tegra_uart_port *tup,\r\nunsigned long *flags)\r\n{\r\nstruct dma_tx_state state;\r\nstruct tty_struct *tty = tty_port_tty_get(&tup->uport.state->port);\r\nstruct tty_port *port = &tup->uport.state->port;\r\nstruct uart_port *u = &tup->uport;\r\nint count;\r\nif (tup->rts_active)\r\nset_rts(tup, false);\r\ndmaengine_terminate_all(tup->rx_dma_chan);\r\ndmaengine_tx_status(tup->rx_dma_chan, tup->rx_cookie, &state);\r\nasync_tx_ack(tup->rx_dma_desc);\r\ncount = tup->rx_bytes_requested - state.residue;\r\nif (count)\r\ntegra_uart_copy_rx_to_tty(tup, port, count);\r\ntegra_uart_handle_rx_pio(tup, port);\r\nif (tty) {\r\nspin_unlock_irqrestore(&u->lock, *flags);\r\ntty_flip_buffer_push(port);\r\nspin_lock_irqsave(&u->lock, *flags);\r\ntty_kref_put(tty);\r\n}\r\ntegra_uart_start_rx_dma(tup);\r\nif (tup->rts_active)\r\nset_rts(tup, true);\r\n}\r\nstatic int tegra_uart_start_rx_dma(struct tegra_uart_port *tup)\r\n{\r\nunsigned int count = TEGRA_UART_RX_DMA_BUFFER_SIZE;\r\ntup->rx_dma_desc = dmaengine_prep_slave_single(tup->rx_dma_chan,\r\ntup->rx_dma_buf_phys, count, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT);\r\nif (!tup->rx_dma_desc) {\r\ndev_err(tup->uport.dev, "Not able to get desc for Rx\n");\r\nreturn -EIO;\r\n}\r\ntup->rx_dma_desc->callback = tegra_uart_rx_dma_complete;\r\ntup->rx_dma_desc->callback_param = tup;\r\ndma_sync_single_for_device(tup->uport.dev, tup->rx_dma_buf_phys,\r\ncount, DMA_TO_DEVICE);\r\ntup->rx_bytes_requested = count;\r\ntup->rx_cookie = dmaengine_submit(tup->rx_dma_desc);\r\ndma_async_issue_pending(tup->rx_dma_chan);\r\nreturn 0;\r\n}\r\nstatic void tegra_uart_handle_modem_signal_change(struct uart_port *u)\r\n{\r\nstruct tegra_uart_port *tup = to_tegra_uport(u);\r\nunsigned long msr;\r\nmsr = tegra_uart_read(tup, UART_MSR);\r\nif (!(msr & UART_MSR_ANY_DELTA))\r\nreturn;\r\nif (msr & UART_MSR_TERI)\r\ntup->uport.icount.rng++;\r\nif (msr & UART_MSR_DDSR)\r\ntup->uport.icount.dsr++;\r\nif (msr & UART_MSR_DDCD)\r\nuart_handle_dcd_change(&tup->uport, msr & UART_MSR_DCD);\r\nif (msr & UART_MSR_DCTS)\r\nuart_handle_cts_change(&tup->uport, msr & UART_MSR_CTS);\r\nreturn;\r\n}\r\nstatic irqreturn_t tegra_uart_isr(int irq, void *data)\r\n{\r\nstruct tegra_uart_port *tup = data;\r\nstruct uart_port *u = &tup->uport;\r\nunsigned long iir;\r\nunsigned long ier;\r\nbool is_rx_int = false;\r\nunsigned long flags;\r\nspin_lock_irqsave(&u->lock, flags);\r\nwhile (1) {\r\niir = tegra_uart_read(tup, UART_IIR);\r\nif (iir & UART_IIR_NO_INT) {\r\nif (is_rx_int) {\r\ntegra_uart_handle_rx_dma(tup, &flags);\r\nif (tup->rx_in_progress) {\r\nier = tup->ier_shadow;\r\nier |= (UART_IER_RLSI | UART_IER_RTOIE |\r\nTEGRA_UART_IER_EORD);\r\ntup->ier_shadow = ier;\r\ntegra_uart_write(tup, ier, UART_IER);\r\n}\r\n}\r\nspin_unlock_irqrestore(&u->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nswitch ((iir >> 1) & 0x7) {\r\ncase 0:\r\ntegra_uart_handle_modem_signal_change(u);\r\nbreak;\r\ncase 1:\r\ntup->ier_shadow &= ~UART_IER_THRI;\r\ntegra_uart_write(tup, tup->ier_shadow, UART_IER);\r\ntegra_uart_handle_tx_pio(tup);\r\nbreak;\r\ncase 4:\r\ncase 6:\r\ncase 2:\r\nif (!is_rx_int) {\r\nis_rx_int = true;\r\nier = tup->ier_shadow;\r\nier |= UART_IER_RDI;\r\ntegra_uart_write(tup, ier, UART_IER);\r\nier &= ~(UART_IER_RDI | UART_IER_RLSI |\r\nUART_IER_RTOIE | TEGRA_UART_IER_EORD);\r\ntup->ier_shadow = ier;\r\ntegra_uart_write(tup, ier, UART_IER);\r\n}\r\nbreak;\r\ncase 3:\r\ntegra_uart_decode_rx_error(tup,\r\ntegra_uart_read(tup, UART_LSR));\r\nbreak;\r\ncase 5:\r\ncase 7:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void tegra_uart_stop_rx(struct uart_port *u)\r\n{\r\nstruct tegra_uart_port *tup = to_tegra_uport(u);\r\nstruct tty_struct *tty;\r\nstruct tty_port *port = &u->state->port;\r\nstruct dma_tx_state state;\r\nunsigned long ier;\r\nint count;\r\nif (tup->rts_active)\r\nset_rts(tup, false);\r\nif (!tup->rx_in_progress)\r\nreturn;\r\ntty = tty_port_tty_get(&tup->uport.state->port);\r\ntegra_uart_wait_sym_time(tup, 1);\r\nier = tup->ier_shadow;\r\nier &= ~(UART_IER_RDI | UART_IER_RLSI | UART_IER_RTOIE |\r\nTEGRA_UART_IER_EORD);\r\ntup->ier_shadow = ier;\r\ntegra_uart_write(tup, ier, UART_IER);\r\ntup->rx_in_progress = 0;\r\nif (tup->rx_dma_chan) {\r\ndmaengine_terminate_all(tup->rx_dma_chan);\r\ndmaengine_tx_status(tup->rx_dma_chan, tup->rx_cookie, &state);\r\nasync_tx_ack(tup->rx_dma_desc);\r\ncount = tup->rx_bytes_requested - state.residue;\r\ntegra_uart_copy_rx_to_tty(tup, port, count);\r\ntegra_uart_handle_rx_pio(tup, port);\r\n} else {\r\ntegra_uart_handle_rx_pio(tup, port);\r\n}\r\nif (tty) {\r\ntty_flip_buffer_push(port);\r\ntty_kref_put(tty);\r\n}\r\nreturn;\r\n}\r\nstatic void tegra_uart_hw_deinit(struct tegra_uart_port *tup)\r\n{\r\nunsigned long flags;\r\nunsigned long char_time = DIV_ROUND_UP(10000000, tup->current_baud);\r\nunsigned long fifo_empty_time = tup->uport.fifosize * char_time;\r\nunsigned long wait_time;\r\nunsigned long lsr;\r\nunsigned long msr;\r\nunsigned long mcr;\r\ntegra_uart_write(tup, 0, UART_IER);\r\nlsr = tegra_uart_read(tup, UART_LSR);\r\nif ((lsr & UART_LSR_TEMT) != UART_LSR_TEMT) {\r\nmsr = tegra_uart_read(tup, UART_MSR);\r\nmcr = tegra_uart_read(tup, UART_MCR);\r\nif ((mcr & TEGRA_UART_MCR_CTS_EN) && (msr & UART_MSR_CTS))\r\ndev_err(tup->uport.dev,\r\n"Tx Fifo not empty, CTS disabled, waiting\n");\r\nwhile ((lsr & UART_LSR_TEMT) != UART_LSR_TEMT) {\r\nwait_time = min(fifo_empty_time, 100lu);\r\nudelay(wait_time);\r\nfifo_empty_time -= wait_time;\r\nif (!fifo_empty_time) {\r\nmsr = tegra_uart_read(tup, UART_MSR);\r\nmcr = tegra_uart_read(tup, UART_MCR);\r\nif ((mcr & TEGRA_UART_MCR_CTS_EN) &&\r\n(msr & UART_MSR_CTS))\r\ndev_err(tup->uport.dev,\r\n"Slave not ready\n");\r\nbreak;\r\n}\r\nlsr = tegra_uart_read(tup, UART_LSR);\r\n}\r\n}\r\nspin_lock_irqsave(&tup->uport.lock, flags);\r\ntegra_uart_fifo_reset(tup, UART_FCR_CLEAR_XMIT | UART_FCR_CLEAR_RCVR);\r\ntup->current_baud = 0;\r\nspin_unlock_irqrestore(&tup->uport.lock, flags);\r\nclk_disable_unprepare(tup->uart_clk);\r\n}\r\nstatic int tegra_uart_hw_init(struct tegra_uart_port *tup)\r\n{\r\nint ret;\r\ntup->fcr_shadow = 0;\r\ntup->mcr_shadow = 0;\r\ntup->lcr_shadow = 0;\r\ntup->ier_shadow = 0;\r\ntup->current_baud = 0;\r\nclk_prepare_enable(tup->uart_clk);\r\nreset_control_assert(tup->rst);\r\nudelay(10);\r\nreset_control_deassert(tup->rst);\r\ntup->rx_in_progress = 0;\r\ntup->tx_in_progress = 0;\r\ntup->fcr_shadow = UART_FCR_ENABLE_FIFO;\r\ntup->fcr_shadow |= UART_FCR_R_TRIG_01;\r\ntup->fcr_shadow |= TEGRA_UART_TX_TRIG_16B;\r\ntegra_uart_write(tup, tup->fcr_shadow, UART_FCR);\r\ntup->lcr_shadow = TEGRA_UART_DEFAULT_LSR;\r\ntegra_set_baudrate(tup, TEGRA_UART_DEFAULT_BAUD);\r\ntup->fcr_shadow |= UART_FCR_DMA_SELECT;\r\ntegra_uart_write(tup, tup->fcr_shadow, UART_FCR);\r\nret = tegra_uart_start_rx_dma(tup);\r\nif (ret < 0) {\r\ndev_err(tup->uport.dev, "Not able to start Rx DMA\n");\r\nreturn ret;\r\n}\r\ntup->rx_in_progress = 1;\r\ntup->ier_shadow = UART_IER_RLSI | UART_IER_RTOIE | TEGRA_UART_IER_EORD;\r\ntegra_uart_write(tup, tup->ier_shadow, UART_IER);\r\nreturn 0;\r\n}\r\nstatic int tegra_uart_dma_channel_allocate(struct tegra_uart_port *tup,\r\nbool dma_to_memory)\r\n{\r\nstruct dma_chan *dma_chan;\r\nunsigned char *dma_buf;\r\ndma_addr_t dma_phys;\r\nint ret;\r\nstruct dma_slave_config dma_sconfig;\r\ndma_chan = dma_request_slave_channel_reason(tup->uport.dev,\r\ndma_to_memory ? "rx" : "tx");\r\nif (IS_ERR(dma_chan)) {\r\nret = PTR_ERR(dma_chan);\r\ndev_err(tup->uport.dev,\r\n"DMA channel alloc failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (dma_to_memory) {\r\ndma_buf = dma_alloc_coherent(tup->uport.dev,\r\nTEGRA_UART_RX_DMA_BUFFER_SIZE,\r\n&dma_phys, GFP_KERNEL);\r\nif (!dma_buf) {\r\ndev_err(tup->uport.dev,\r\n"Not able to allocate the dma buffer\n");\r\ndma_release_channel(dma_chan);\r\nreturn -ENOMEM;\r\n}\r\n} else {\r\ndma_phys = dma_map_single(tup->uport.dev,\r\ntup->uport.state->xmit.buf, UART_XMIT_SIZE,\r\nDMA_TO_DEVICE);\r\ndma_buf = tup->uport.state->xmit.buf;\r\n}\r\nif (dma_to_memory) {\r\ndma_sconfig.src_addr = tup->uport.mapbase;\r\ndma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\ndma_sconfig.src_maxburst = 4;\r\n} else {\r\ndma_sconfig.dst_addr = tup->uport.mapbase;\r\ndma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\ndma_sconfig.dst_maxburst = 16;\r\n}\r\nret = dmaengine_slave_config(dma_chan, &dma_sconfig);\r\nif (ret < 0) {\r\ndev_err(tup->uport.dev,\r\n"Dma slave config failed, err = %d\n", ret);\r\ngoto scrub;\r\n}\r\nif (dma_to_memory) {\r\ntup->rx_dma_chan = dma_chan;\r\ntup->rx_dma_buf_virt = dma_buf;\r\ntup->rx_dma_buf_phys = dma_phys;\r\n} else {\r\ntup->tx_dma_chan = dma_chan;\r\ntup->tx_dma_buf_virt = dma_buf;\r\ntup->tx_dma_buf_phys = dma_phys;\r\n}\r\nreturn 0;\r\nscrub:\r\ndma_release_channel(dma_chan);\r\nreturn ret;\r\n}\r\nstatic void tegra_uart_dma_channel_free(struct tegra_uart_port *tup,\r\nbool dma_to_memory)\r\n{\r\nstruct dma_chan *dma_chan;\r\nif (dma_to_memory) {\r\ndma_free_coherent(tup->uport.dev, TEGRA_UART_RX_DMA_BUFFER_SIZE,\r\ntup->rx_dma_buf_virt, tup->rx_dma_buf_phys);\r\ndma_chan = tup->rx_dma_chan;\r\ntup->rx_dma_chan = NULL;\r\ntup->rx_dma_buf_phys = 0;\r\ntup->rx_dma_buf_virt = NULL;\r\n} else {\r\ndma_unmap_single(tup->uport.dev, tup->tx_dma_buf_phys,\r\nUART_XMIT_SIZE, DMA_TO_DEVICE);\r\ndma_chan = tup->tx_dma_chan;\r\ntup->tx_dma_chan = NULL;\r\ntup->tx_dma_buf_phys = 0;\r\ntup->tx_dma_buf_virt = NULL;\r\n}\r\ndma_release_channel(dma_chan);\r\n}\r\nstatic int tegra_uart_startup(struct uart_port *u)\r\n{\r\nstruct tegra_uart_port *tup = to_tegra_uport(u);\r\nint ret;\r\nret = tegra_uart_dma_channel_allocate(tup, false);\r\nif (ret < 0) {\r\ndev_err(u->dev, "Tx Dma allocation failed, err = %d\n", ret);\r\nreturn ret;\r\n}\r\nret = tegra_uart_dma_channel_allocate(tup, true);\r\nif (ret < 0) {\r\ndev_err(u->dev, "Rx Dma allocation failed, err = %d\n", ret);\r\ngoto fail_rx_dma;\r\n}\r\nret = tegra_uart_hw_init(tup);\r\nif (ret < 0) {\r\ndev_err(u->dev, "Uart HW init failed, err = %d\n", ret);\r\ngoto fail_hw_init;\r\n}\r\nret = request_irq(u->irq, tegra_uart_isr, 0,\r\ndev_name(u->dev), tup);\r\nif (ret < 0) {\r\ndev_err(u->dev, "Failed to register ISR for IRQ %d\n", u->irq);\r\ngoto fail_hw_init;\r\n}\r\nreturn 0;\r\nfail_hw_init:\r\ntegra_uart_dma_channel_free(tup, true);\r\nfail_rx_dma:\r\ntegra_uart_dma_channel_free(tup, false);\r\nreturn ret;\r\n}\r\nstatic void tegra_uart_flush_buffer(struct uart_port *u)\r\n{\r\nstruct tegra_uart_port *tup = to_tegra_uport(u);\r\ntup->tx_bytes = 0;\r\nif (tup->tx_dma_chan)\r\ndmaengine_terminate_all(tup->tx_dma_chan);\r\nreturn;\r\n}\r\nstatic void tegra_uart_shutdown(struct uart_port *u)\r\n{\r\nstruct tegra_uart_port *tup = to_tegra_uport(u);\r\ntegra_uart_hw_deinit(tup);\r\ntup->rx_in_progress = 0;\r\ntup->tx_in_progress = 0;\r\ntegra_uart_dma_channel_free(tup, true);\r\ntegra_uart_dma_channel_free(tup, false);\r\nfree_irq(u->irq, tup);\r\ntegra_uart_flush_buffer(u);\r\n}\r\nstatic void tegra_uart_enable_ms(struct uart_port *u)\r\n{\r\nstruct tegra_uart_port *tup = to_tegra_uport(u);\r\nif (tup->enable_modem_interrupt) {\r\ntup->ier_shadow |= UART_IER_MSI;\r\ntegra_uart_write(tup, tup->ier_shadow, UART_IER);\r\n}\r\n}\r\nstatic void tegra_uart_set_termios(struct uart_port *u,\r\nstruct ktermios *termios, struct ktermios *oldtermios)\r\n{\r\nstruct tegra_uart_port *tup = to_tegra_uport(u);\r\nunsigned int baud;\r\nunsigned long flags;\r\nunsigned int lcr;\r\nint symb_bit = 1;\r\nstruct clk *parent_clk = clk_get_parent(tup->uart_clk);\r\nunsigned long parent_clk_rate = clk_get_rate(parent_clk);\r\nint max_divider = (tup->cdata->support_clk_src_div) ? 0x7FFF : 0xFFFF;\r\nmax_divider *= 16;\r\nspin_lock_irqsave(&u->lock, flags);\r\nif (tup->rts_active)\r\nset_rts(tup, false);\r\ntegra_uart_write(tup, tup->ier_shadow | UART_IER_RDI, UART_IER);\r\ntegra_uart_read(tup, UART_IER);\r\ntegra_uart_write(tup, 0, UART_IER);\r\ntegra_uart_read(tup, UART_IER);\r\nlcr = tup->lcr_shadow;\r\nlcr &= ~UART_LCR_PARITY;\r\ntermios->c_cflag &= ~CMSPAR;\r\nif ((termios->c_cflag & PARENB) == PARENB) {\r\nsymb_bit++;\r\nif (termios->c_cflag & PARODD) {\r\nlcr |= UART_LCR_PARITY;\r\nlcr &= ~UART_LCR_EPAR;\r\nlcr &= ~UART_LCR_SPAR;\r\n} else {\r\nlcr |= UART_LCR_PARITY;\r\nlcr |= UART_LCR_EPAR;\r\nlcr &= ~UART_LCR_SPAR;\r\n}\r\n}\r\nlcr &= ~UART_LCR_WLEN8;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\nlcr |= UART_LCR_WLEN5;\r\nsymb_bit += 5;\r\nbreak;\r\ncase CS6:\r\nlcr |= UART_LCR_WLEN6;\r\nsymb_bit += 6;\r\nbreak;\r\ncase CS7:\r\nlcr |= UART_LCR_WLEN7;\r\nsymb_bit += 7;\r\nbreak;\r\ndefault:\r\nlcr |= UART_LCR_WLEN8;\r\nsymb_bit += 8;\r\nbreak;\r\n}\r\nif (termios->c_cflag & CSTOPB) {\r\nlcr |= UART_LCR_STOP;\r\nsymb_bit += 2;\r\n} else {\r\nlcr &= ~UART_LCR_STOP;\r\nsymb_bit++;\r\n}\r\ntegra_uart_write(tup, lcr, UART_LCR);\r\ntup->lcr_shadow = lcr;\r\ntup->symb_bit = symb_bit;\r\nbaud = uart_get_baud_rate(u, termios, oldtermios,\r\nparent_clk_rate/max_divider,\r\nparent_clk_rate/16);\r\nspin_unlock_irqrestore(&u->lock, flags);\r\ntegra_set_baudrate(tup, baud);\r\nif (tty_termios_baud_rate(termios))\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\nspin_lock_irqsave(&u->lock, flags);\r\nif (termios->c_cflag & CRTSCTS) {\r\ntup->mcr_shadow |= TEGRA_UART_MCR_CTS_EN;\r\ntup->mcr_shadow &= ~TEGRA_UART_MCR_RTS_EN;\r\ntegra_uart_write(tup, tup->mcr_shadow, UART_MCR);\r\nif (tup->rts_active)\r\nset_rts(tup, true);\r\n} else {\r\ntup->mcr_shadow &= ~TEGRA_UART_MCR_CTS_EN;\r\ntup->mcr_shadow &= ~TEGRA_UART_MCR_RTS_EN;\r\ntegra_uart_write(tup, tup->mcr_shadow, UART_MCR);\r\n}\r\nuart_update_timeout(u, termios->c_cflag, baud);\r\ntegra_uart_read(tup, UART_IER);\r\ntegra_uart_write(tup, tup->ier_shadow, UART_IER);\r\ntegra_uart_read(tup, UART_IER);\r\nspin_unlock_irqrestore(&u->lock, flags);\r\nreturn;\r\n}\r\nstatic const char *tegra_uart_type(struct uart_port *u)\r\n{\r\nreturn TEGRA_UART_TYPE;\r\n}\r\nstatic int tegra_uart_parse_dt(struct platform_device *pdev,\r\nstruct tegra_uart_port *tup)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nint port;\r\nport = of_alias_get_id(np, "serial");\r\nif (port < 0) {\r\ndev_err(&pdev->dev, "failed to get alias id, errno %d\n", port);\r\nreturn port;\r\n}\r\ntup->uport.line = port;\r\ntup->enable_modem_interrupt = of_property_read_bool(np,\r\n"nvidia,enable-modem-interrupt");\r\nreturn 0;\r\n}\r\nstatic int tegra_uart_probe(struct platform_device *pdev)\r\n{\r\nstruct tegra_uart_port *tup;\r\nstruct uart_port *u;\r\nstruct resource *resource;\r\nint ret;\r\nconst struct tegra_uart_chip_data *cdata;\r\nconst struct of_device_id *match;\r\nmatch = of_match_device(tegra_uart_of_match, &pdev->dev);\r\nif (!match) {\r\ndev_err(&pdev->dev, "Error: No device match found\n");\r\nreturn -ENODEV;\r\n}\r\ncdata = match->data;\r\ntup = devm_kzalloc(&pdev->dev, sizeof(*tup), GFP_KERNEL);\r\nif (!tup) {\r\ndev_err(&pdev->dev, "Failed to allocate memory for tup\n");\r\nreturn -ENOMEM;\r\n}\r\nret = tegra_uart_parse_dt(pdev, tup);\r\nif (ret < 0)\r\nreturn ret;\r\nu = &tup->uport;\r\nu->dev = &pdev->dev;\r\nu->ops = &tegra_uart_ops;\r\nu->type = PORT_TEGRA;\r\nu->fifosize = 32;\r\ntup->cdata = cdata;\r\nplatform_set_drvdata(pdev, tup);\r\nresource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!resource) {\r\ndev_err(&pdev->dev, "No IO memory resource\n");\r\nreturn -ENODEV;\r\n}\r\nu->mapbase = resource->start;\r\nu->membase = devm_ioremap_resource(&pdev->dev, resource);\r\nif (IS_ERR(u->membase))\r\nreturn PTR_ERR(u->membase);\r\ntup->uart_clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(tup->uart_clk)) {\r\ndev_err(&pdev->dev, "Couldn't get the clock\n");\r\nreturn PTR_ERR(tup->uart_clk);\r\n}\r\ntup->rst = devm_reset_control_get(&pdev->dev, "serial");\r\nif (IS_ERR(tup->rst)) {\r\ndev_err(&pdev->dev, "Couldn't get the reset\n");\r\nreturn PTR_ERR(tup->rst);\r\n}\r\nu->iotype = UPIO_MEM32;\r\nu->irq = platform_get_irq(pdev, 0);\r\nu->regshift = 2;\r\nret = uart_add_one_port(&tegra_uart_driver, u);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to add uart port, err %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tegra_uart_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_uart_port *tup = platform_get_drvdata(pdev);\r\nstruct uart_port *u = &tup->uport;\r\nuart_remove_one_port(&tegra_uart_driver, u);\r\nreturn 0;\r\n}\r\nstatic int tegra_uart_suspend(struct device *dev)\r\n{\r\nstruct tegra_uart_port *tup = dev_get_drvdata(dev);\r\nstruct uart_port *u = &tup->uport;\r\nreturn uart_suspend_port(&tegra_uart_driver, u);\r\n}\r\nstatic int tegra_uart_resume(struct device *dev)\r\n{\r\nstruct tegra_uart_port *tup = dev_get_drvdata(dev);\r\nstruct uart_port *u = &tup->uport;\r\nreturn uart_resume_port(&tegra_uart_driver, u);\r\n}\r\nstatic int __init tegra_uart_init(void)\r\n{\r\nint ret;\r\nret = uart_register_driver(&tegra_uart_driver);\r\nif (ret < 0) {\r\npr_err("Could not register %s driver\n",\r\ntegra_uart_driver.driver_name);\r\nreturn ret;\r\n}\r\nret = platform_driver_register(&tegra_uart_platform_driver);\r\nif (ret < 0) {\r\npr_err("Uart platform driver register failed, e = %d\n", ret);\r\nuart_unregister_driver(&tegra_uart_driver);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit tegra_uart_exit(void)\r\n{\r\npr_info("Unloading tegra uart driver\n");\r\nplatform_driver_unregister(&tegra_uart_platform_driver);\r\nuart_unregister_driver(&tegra_uart_driver);\r\n}
