static void saa7164_vbi_configure(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\ndprintk(DBGLVL_VBI, "%s()\n", __func__);\r\nport->vbi_params.width = port->width;\r\nport->vbi_params.height = port->height;\r\nport->vbi_params.is_50hz =\r\n(port->encodernorm.id & V4L2_STD_625_50) != 0;\r\nsaa7164_api_initialize_dif(port);\r\n#if 0\r\nsaa7164_api_configure_dif(port, port->encodernorm.id);\r\n#endif\r\n#if 0\r\nsaa7164_api_set_audio_std(port);\r\n#endif\r\ndprintk(DBGLVL_VBI, "%s() ends\n", __func__);\r\n}\r\nstatic int saa7164_vbi_buffers_dealloc(struct saa7164_port *port)\r\n{\r\nstruct list_head *c, *n, *p, *q, *l, *v;\r\nstruct saa7164_dev *dev = port->dev;\r\nstruct saa7164_buffer *buf;\r\nstruct saa7164_user_buffer *ubuf;\r\nmutex_lock(&port->dmaqueue_lock);\r\ndprintk(DBGLVL_VBI, "%s(port=%d) dmaqueue\n", __func__, port->nr);\r\nlist_for_each_safe(c, n, &port->dmaqueue.list) {\r\nbuf = list_entry(c, struct saa7164_buffer, list);\r\nlist_del(c);\r\nsaa7164_buffer_dealloc(buf);\r\n}\r\ndprintk(DBGLVL_VBI, "%s(port=%d) used\n", __func__, port->nr);\r\nlist_for_each_safe(p, q, &port->list_buf_used.list) {\r\nubuf = list_entry(p, struct saa7164_user_buffer, list);\r\nlist_del(p);\r\nsaa7164_buffer_dealloc_user(ubuf);\r\n}\r\ndprintk(DBGLVL_VBI, "%s(port=%d) free\n", __func__, port->nr);\r\nlist_for_each_safe(l, v, &port->list_buf_free.list) {\r\nubuf = list_entry(l, struct saa7164_user_buffer, list);\r\nlist_del(l);\r\nsaa7164_buffer_dealloc_user(ubuf);\r\n}\r\nmutex_unlock(&port->dmaqueue_lock);\r\ndprintk(DBGLVL_VBI, "%s(port=%d) done\n", __func__, port->nr);\r\nreturn 0;\r\n}\r\nstatic int saa7164_vbi_buffers_alloc(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nstruct saa7164_buffer *buf;\r\nstruct saa7164_user_buffer *ubuf;\r\nstruct tmHWStreamParameters *params = &port->hw_streamingparams;\r\nint result = -ENODEV, i;\r\nint len = 0;\r\ndprintk(DBGLVL_VBI, "%s()\n", __func__);\r\nparams->samplesperline = 1440;\r\nparams->numberoflines = 12;\r\nparams->numberoflines = 18;\r\nparams->pitch = 1600;\r\nparams->pitch = 1440;\r\nparams->numpagetables = 2 +\r\n((params->numberoflines * params->pitch) / PAGE_SIZE);\r\nparams->bitspersample = 8;\r\nparams->linethreshold = 0;\r\nparams->pagetablelistvirt = NULL;\r\nparams->pagetablelistphys = NULL;\r\nparams->numpagetableentries = port->hwcfg.buffercount;\r\nfor (i = 0; i < port->hwcfg.buffercount; i++) {\r\nbuf = saa7164_buffer_alloc(port,\r\nparams->numberoflines *\r\nparams->pitch);\r\nif (!buf) {\r\nprintk(KERN_ERR "%s() failed "\r\n"(errno = %d), unable to allocate buffer\n",\r\n__func__, result);\r\nresult = -ENOMEM;\r\ngoto failed;\r\n} else {\r\nmutex_lock(&port->dmaqueue_lock);\r\nlist_add_tail(&buf->list, &port->dmaqueue.list);\r\nmutex_unlock(&port->dmaqueue_lock);\r\n}\r\n}\r\nlen = params->numberoflines * params->pitch;\r\nif (vbi_buffers < 16)\r\nvbi_buffers = 16;\r\nif (vbi_buffers > 512)\r\nvbi_buffers = 512;\r\nfor (i = 0; i < vbi_buffers; i++) {\r\nubuf = saa7164_buffer_alloc_user(dev, len);\r\nif (ubuf) {\r\nmutex_lock(&port->dmaqueue_lock);\r\nlist_add_tail(&ubuf->list, &port->list_buf_free.list);\r\nmutex_unlock(&port->dmaqueue_lock);\r\n}\r\n}\r\nresult = 0;\r\nfailed:\r\nreturn result;\r\n}\r\nstatic int saa7164_vbi_initialize(struct saa7164_port *port)\r\n{\r\nsaa7164_vbi_configure(port);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id id)\r\n{\r\nstruct saa7164_vbi_fh *fh = file->private_data;\r\nstruct saa7164_port *port = fh->port;\r\nstruct saa7164_dev *dev = port->dev;\r\nunsigned int i;\r\ndprintk(DBGLVL_VBI, "%s(id=0x%x)\n", __func__, (u32)id);\r\nfor (i = 0; i < ARRAY_SIZE(saa7164_tvnorms); i++) {\r\nif (id & saa7164_tvnorms[i].id)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(saa7164_tvnorms))\r\nreturn -EINVAL;\r\nport->encodernorm = saa7164_tvnorms[i];\r\nport->std = id;\r\nsaa7164_api_set_audio_std(port);\r\ndprintk(DBGLVL_VBI, "%s(id=0x%x) OK\n", __func__, (u32)id);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *id)\r\n{\r\nstruct saa7164_encoder_fh *fh = file->private_data;\r\nstruct saa7164_port *port = fh->port;\r\n*id = port->std;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nint n;\r\nchar *inputs[] = { "tuner", "composite", "svideo", "aux",\r\n"composite 2", "svideo 2", "aux 2" };\r\nif (i->index >= 7)\r\nreturn -EINVAL;\r\nstrcpy(i->name, inputs[i->index]);\r\nif (i->index == 0)\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\nelse\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nfor (n = 0; n < ARRAY_SIZE(saa7164_tvnorms); n++)\r\ni->std |= saa7164_tvnorms[n].id;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct saa7164_vbi_fh *fh = file->private_data;\r\nstruct saa7164_port *port = fh->port;\r\nstruct saa7164_dev *dev = port->dev;\r\nif (saa7164_api_get_videomux(port) != SAA_OK)\r\nreturn -EIO;\r\n*i = (port->mux_input - 1);\r\ndprintk(DBGLVL_VBI, "%s() input=%d\n", __func__, *i);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct saa7164_vbi_fh *fh = file->private_data;\r\nstruct saa7164_port *port = fh->port;\r\nstruct saa7164_dev *dev = port->dev;\r\ndprintk(DBGLVL_VBI, "%s() input=%d\n", __func__, i);\r\nif (i >= 7)\r\nreturn -EINVAL;\r\nport->mux_input = i + 1;\r\nif (saa7164_api_set_videomux(port) != SAA_OK)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct saa7164_vbi_fh *fh = file->private_data;\r\nstruct saa7164_port *port = fh->port;\r\nstruct saa7164_dev *dev = port->dev;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "tuner");\r\nt->type = V4L2_TUNER_ANALOG_TV;\r\nt->capability = V4L2_TUNER_CAP_NORM | V4L2_TUNER_CAP_STEREO;\r\ndprintk(DBGLVL_VBI, "VIDIOC_G_TUNER: tuner type %d\n", t->type);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *t)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct saa7164_vbi_fh *fh = file->private_data;\r\nstruct saa7164_port *port = fh->port;\r\nf->type = V4L2_TUNER_ANALOG_TV;\r\nf->frequency = port->freq;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct saa7164_vbi_fh *fh = file->private_data;\r\nstruct saa7164_port *port = fh->port;\r\nstruct saa7164_dev *dev = port->dev;\r\nstruct saa7164_port *tsport;\r\nstruct dvb_frontend *fe;\r\nstruct analog_parameters params = {\r\n.mode = V4L2_TUNER_ANALOG_TV,\r\n.audmode = V4L2_TUNER_MODE_STEREO,\r\n.std = port->encodernorm.id,\r\n.frequency = f->frequency\r\n};\r\ndprintk(DBGLVL_VBI, "%s() frequency=%d tuner=%d\n", __func__,\r\nf->frequency, f->tuner);\r\nif (f->tuner != 0)\r\nreturn -EINVAL;\r\nif (f->type != V4L2_TUNER_ANALOG_TV)\r\nreturn -EINVAL;\r\nport->freq = f->frequency;\r\nif (port->nr == SAA7164_PORT_VBI1)\r\ntsport = &dev->ports[SAA7164_PORT_TS1];\r\nelse\r\nif (port->nr == SAA7164_PORT_VBI2)\r\ntsport = &dev->ports[SAA7164_PORT_TS2];\r\nelse\r\nBUG();\r\nfe = tsport->dvb.frontend;\r\nif (fe && fe->ops.tuner_ops.set_analog_params)\r\nfe->ops.tuner_ops.set_analog_params(fe, &params);\r\nelse\r\nprintk(KERN_ERR "%s() No analog tuner, aborting\n", __func__);\r\nsaa7164_vbi_initialize(port);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctl)\r\n{\r\nstruct saa7164_vbi_fh *fh = file->private_data;\r\nstruct saa7164_port *port = fh->port;\r\nstruct saa7164_dev *dev = port->dev;\r\ndprintk(DBGLVL_VBI, "%s(id=%d, value=%d)\n", __func__,\r\nctl->id, ctl->value);\r\nswitch (ctl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nctl->value = port->ctl_brightness;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nctl->value = port->ctl_contrast;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nctl->value = port->ctl_saturation;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nctl->value = port->ctl_hue;\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nctl->value = port->ctl_sharpness;\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nctl->value = port->ctl_volume;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctl)\r\n{\r\nstruct saa7164_vbi_fh *fh = file->private_data;\r\nstruct saa7164_port *port = fh->port;\r\nstruct saa7164_dev *dev = port->dev;\r\nint ret = 0;\r\ndprintk(DBGLVL_VBI, "%s(id=%d, value=%d)\n", __func__,\r\nctl->id, ctl->value);\r\nswitch (ctl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nif ((ctl->value >= 0) && (ctl->value <= 255)) {\r\nport->ctl_brightness = ctl->value;\r\nsaa7164_api_set_usercontrol(port,\r\nPU_BRIGHTNESS_CONTROL);\r\n} else\r\nret = -EINVAL;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nif ((ctl->value >= 0) && (ctl->value <= 255)) {\r\nport->ctl_contrast = ctl->value;\r\nsaa7164_api_set_usercontrol(port, PU_CONTRAST_CONTROL);\r\n} else\r\nret = -EINVAL;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nif ((ctl->value >= 0) && (ctl->value <= 255)) {\r\nport->ctl_saturation = ctl->value;\r\nsaa7164_api_set_usercontrol(port,\r\nPU_SATURATION_CONTROL);\r\n} else\r\nret = -EINVAL;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nif ((ctl->value >= 0) && (ctl->value <= 255)) {\r\nport->ctl_hue = ctl->value;\r\nsaa7164_api_set_usercontrol(port, PU_HUE_CONTROL);\r\n} else\r\nret = -EINVAL;\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nif ((ctl->value >= 0) && (ctl->value <= 255)) {\r\nport->ctl_sharpness = ctl->value;\r\nsaa7164_api_set_usercontrol(port, PU_SHARPNESS_CONTROL);\r\n} else\r\nret = -EINVAL;\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nif ((ctl->value >= -83) && (ctl->value <= 24)) {\r\nport->ctl_volume = ctl->value;\r\nsaa7164_api_set_audio_volume(port, port->ctl_volume);\r\n} else\r\nret = -EINVAL;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int saa7164_get_ctrl(struct saa7164_port *port,\r\nstruct v4l2_ext_control *ctrl)\r\n{\r\nstruct saa7164_vbi_params *params = &port->vbi_params;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\nctrl->value = params->stream_type;\r\nbreak;\r\ncase V4L2_CID_MPEG_AUDIO_MUTE:\r\nctrl->value = params->ctl_mute;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_ASPECT:\r\nctrl->value = params->ctl_aspect;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_B_FRAMES:\r\nctrl->value = params->refdist;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\r\nctrl->value = params->gop_size;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_ext_ctrls(struct file *file, void *priv,\r\nstruct v4l2_ext_controls *ctrls)\r\n{\r\nstruct saa7164_vbi_fh *fh = file->private_data;\r\nstruct saa7164_port *port = fh->port;\r\nint i, err = 0;\r\nif (ctrls->ctrl_class == V4L2_CTRL_CLASS_MPEG) {\r\nfor (i = 0; i < ctrls->count; i++) {\r\nstruct v4l2_ext_control *ctrl = ctrls->controls + i;\r\nerr = saa7164_get_ctrl(port, ctrl);\r\nif (err) {\r\nctrls->error_idx = i;\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int saa7164_try_ctrl(struct v4l2_ext_control *ctrl, int ac3)\r\n{\r\nint ret = -EINVAL;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\nif ((ctrl->value == V4L2_MPEG_STREAM_TYPE_MPEG2_PS) ||\r\n(ctrl->value == V4L2_MPEG_STREAM_TYPE_MPEG2_TS))\r\nret = 0;\r\nbreak;\r\ncase V4L2_CID_MPEG_AUDIO_MUTE:\r\nif ((ctrl->value >= 0) &&\r\n(ctrl->value <= 1))\r\nret = 0;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_ASPECT:\r\nif ((ctrl->value >= V4L2_MPEG_VIDEO_ASPECT_1x1) &&\r\n(ctrl->value <= V4L2_MPEG_VIDEO_ASPECT_221x100))\r\nret = 0;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\r\nif ((ctrl->value >= 0) &&\r\n(ctrl->value <= 255))\r\nret = 0;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_B_FRAMES:\r\nif ((ctrl->value >= 1) &&\r\n(ctrl->value <= 3))\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vidioc_try_ext_ctrls(struct file *file, void *priv,\r\nstruct v4l2_ext_controls *ctrls)\r\n{\r\nint i, err = 0;\r\nif (ctrls->ctrl_class == V4L2_CTRL_CLASS_MPEG) {\r\nfor (i = 0; i < ctrls->count; i++) {\r\nstruct v4l2_ext_control *ctrl = ctrls->controls + i;\r\nerr = saa7164_try_ctrl(ctrl, 0);\r\nif (err) {\r\nctrls->error_idx = i;\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int saa7164_set_ctrl(struct saa7164_port *port,\r\nstruct v4l2_ext_control *ctrl)\r\n{\r\nstruct saa7164_vbi_params *params = &port->vbi_params;\r\nint ret = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\nparams->stream_type = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_MPEG_AUDIO_MUTE:\r\nparams->ctl_mute = ctrl->value;\r\nret = saa7164_api_audio_mute(port, params->ctl_mute);\r\nif (ret != SAA_OK) {\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__,\r\nret);\r\nret = -EIO;\r\n}\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_ASPECT:\r\nparams->ctl_aspect = ctrl->value;\r\nret = saa7164_api_set_aspect_ratio(port);\r\nif (ret != SAA_OK) {\r\nprintk(KERN_ERR "%s() error, ret = 0x%x\n", __func__,\r\nret);\r\nret = -EIO;\r\n}\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_B_FRAMES:\r\nparams->refdist = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\r\nparams->gop_size = ctrl->value;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vidioc_s_ext_ctrls(struct file *file, void *priv,\r\nstruct v4l2_ext_controls *ctrls)\r\n{\r\nstruct saa7164_vbi_fh *fh = file->private_data;\r\nstruct saa7164_port *port = fh->port;\r\nint i, err = 0;\r\nif (ctrls->ctrl_class == V4L2_CTRL_CLASS_MPEG) {\r\nfor (i = 0; i < ctrls->count; i++) {\r\nstruct v4l2_ext_control *ctrl = ctrls->controls + i;\r\nerr = saa7164_try_ctrl(ctrl, 0);\r\nif (err) {\r\nctrls->error_idx = i;\r\nbreak;\r\n}\r\nerr = saa7164_set_ctrl(port, ctrl);\r\nif (err) {\r\nctrls->error_idx = i;\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct saa7164_vbi_fh *fh = file->private_data;\r\nstruct saa7164_port *port = fh->port;\r\nstruct saa7164_dev *dev = port->dev;\r\nstrcpy(cap->driver, dev->name);\r\nstrlcpy(cap->card, saa7164_boards[dev->board].name,\r\nsizeof(cap->card));\r\nsprintf(cap->bus_info, "PCI:%s", pci_name(dev->pci));\r\ncap->capabilities =\r\nV4L2_CAP_VBI_CAPTURE |\r\nV4L2_CAP_READWRITE |\r\n0;\r\ncap->capabilities |= V4L2_CAP_TUNER;\r\ncap->version = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index != 0)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, "VBI", sizeof(f->description));\r\nf->pixelformat = V4L2_PIX_FMT_MPEG;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7164_vbi_fh *fh = file->private_data;\r\nstruct saa7164_port *port = fh->port;\r\nstruct saa7164_dev *dev = port->dev;\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage =\r\nport->ts_packet_size * port->ts_packet_count;\r\nf->fmt.pix.colorspace = 0;\r\nf->fmt.pix.width = port->width;\r\nf->fmt.pix.height = port->height;\r\ndprintk(DBGLVL_VBI, "VIDIOC_G_FMT: w: %d, h: %d\n",\r\nport->width, port->height);\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7164_vbi_fh *fh = file->private_data;\r\nstruct saa7164_port *port = fh->port;\r\nstruct saa7164_dev *dev = port->dev;\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage =\r\nport->ts_packet_size * port->ts_packet_count;\r\nf->fmt.pix.colorspace = 0;\r\ndprintk(DBGLVL_VBI, "VIDIOC_TRY_FMT: w: %d, h: %d\n",\r\nport->width, port->height);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7164_vbi_fh *fh = file->private_data;\r\nstruct saa7164_port *port = fh->port;\r\nstruct saa7164_dev *dev = port->dev;\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.sizeimage =\r\nport->ts_packet_size * port->ts_packet_count;\r\nf->fmt.pix.colorspace = 0;\r\ndprintk(DBGLVL_VBI, "VIDIOC_S_FMT: w: %d, h: %d, f: %d\n",\r\nf->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.field);\r\nreturn 0;\r\n}\r\nstatic int fill_queryctrl(struct saa7164_vbi_params *params,\r\nstruct v4l2_queryctrl *c)\r\n{\r\nswitch (c->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nreturn v4l2_ctrl_query_fill(c, 0x0, 0xff, 1, 127);\r\ncase V4L2_CID_CONTRAST:\r\nreturn v4l2_ctrl_query_fill(c, 0x0, 0xff, 1, 66);\r\ncase V4L2_CID_SATURATION:\r\nreturn v4l2_ctrl_query_fill(c, 0x0, 0xff, 1, 62);\r\ncase V4L2_CID_HUE:\r\nreturn v4l2_ctrl_query_fill(c, 0x0, 0xff, 1, 128);\r\ncase V4L2_CID_SHARPNESS:\r\nreturn v4l2_ctrl_query_fill(c, 0x0, 0x0f, 1, 8);\r\ncase V4L2_CID_MPEG_AUDIO_MUTE:\r\nreturn v4l2_ctrl_query_fill(c, 0x0, 0x01, 1, 0);\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nreturn v4l2_ctrl_query_fill(c, -83, 24, 1, 20);\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\nreturn v4l2_ctrl_query_fill(c,\r\nV4L2_MPEG_STREAM_TYPE_MPEG2_PS,\r\nV4L2_MPEG_STREAM_TYPE_MPEG2_TS,\r\n1, V4L2_MPEG_STREAM_TYPE_MPEG2_PS);\r\ncase V4L2_CID_MPEG_VIDEO_ASPECT:\r\nreturn v4l2_ctrl_query_fill(c,\r\nV4L2_MPEG_VIDEO_ASPECT_1x1,\r\nV4L2_MPEG_VIDEO_ASPECT_221x100,\r\n1, V4L2_MPEG_VIDEO_ASPECT_4x3);\r\ncase V4L2_CID_MPEG_VIDEO_GOP_SIZE:\r\nreturn v4l2_ctrl_query_fill(c, 1, 255, 1, 15);\r\ncase V4L2_CID_MPEG_VIDEO_B_FRAMES:\r\nreturn v4l2_ctrl_query_fill(c,\r\n1, 3, 1, 1);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *c)\r\n{\r\nstruct saa7164_vbi_fh *fh = priv;\r\nstruct saa7164_port *port = fh->port;\r\nint i, next;\r\nu32 id = c->id;\r\nmemset(c, 0, sizeof(*c));\r\nnext = !!(id & V4L2_CTRL_FLAG_NEXT_CTRL);\r\nc->id = id & ~V4L2_CTRL_FLAG_NEXT_CTRL;\r\nfor (i = 0; i < ARRAY_SIZE(saa7164_v4l2_ctrls); i++) {\r\nif (next) {\r\nif (c->id < saa7164_v4l2_ctrls[i])\r\nc->id = saa7164_v4l2_ctrls[i];\r\nelse\r\ncontinue;\r\n}\r\nif (c->id == saa7164_v4l2_ctrls[i])\r\nreturn fill_queryctrl(&port->vbi_params, c);\r\nif (c->id < saa7164_v4l2_ctrls[i])\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int saa7164_vbi_stop_port(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nint ret;\r\nret = saa7164_api_transition_port(port, SAA_DMASTATE_STOP);\r\nif ((ret != SAA_OK) && (ret != SAA_ERR_ALREADY_STOPPED)) {\r\nprintk(KERN_ERR "%s() stop transition failed, ret = 0x%x\n",\r\n__func__, ret);\r\nret = -EIO;\r\n} else {\r\ndprintk(DBGLVL_VBI, "%s() Stopped\n", __func__);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int saa7164_vbi_acquire_port(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nint ret;\r\nret = saa7164_api_transition_port(port, SAA_DMASTATE_ACQUIRE);\r\nif ((ret != SAA_OK) && (ret != SAA_ERR_ALREADY_STOPPED)) {\r\nprintk(KERN_ERR "%s() acquire transition failed, ret = 0x%x\n",\r\n__func__, ret);\r\nret = -EIO;\r\n} else {\r\ndprintk(DBGLVL_VBI, "%s() Acquired\n", __func__);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int saa7164_vbi_pause_port(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nint ret;\r\nret = saa7164_api_transition_port(port, SAA_DMASTATE_PAUSE);\r\nif ((ret != SAA_OK) && (ret != SAA_ERR_ALREADY_STOPPED)) {\r\nprintk(KERN_ERR "%s() pause transition failed, ret = 0x%x\n",\r\n__func__, ret);\r\nret = -EIO;\r\n} else {\r\ndprintk(DBGLVL_VBI, "%s() Paused\n", __func__);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int saa7164_vbi_stop_streaming(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nstruct saa7164_buffer *buf;\r\nstruct saa7164_user_buffer *ubuf;\r\nstruct list_head *c, *n;\r\nint ret;\r\ndprintk(DBGLVL_VBI, "%s(port=%d)\n", __func__, port->nr);\r\nret = saa7164_vbi_pause_port(port);\r\nret = saa7164_vbi_acquire_port(port);\r\nret = saa7164_vbi_stop_port(port);\r\ndprintk(DBGLVL_VBI, "%s(port=%d) Hardware stopped\n", __func__,\r\nport->nr);\r\nmutex_lock(&port->dmaqueue_lock);\r\nlist_for_each_safe(c, n, &port->dmaqueue.list) {\r\nbuf = list_entry(c, struct saa7164_buffer, list);\r\nbuf->flags = SAA7164_BUFFER_FREE;\r\nbuf->pos = 0;\r\n}\r\nlist_for_each_safe(c, n, &port->list_buf_used.list) {\r\nubuf = list_entry(c, struct saa7164_user_buffer, list);\r\nubuf->pos = 0;\r\nlist_move_tail(&ubuf->list, &port->list_buf_free.list);\r\n}\r\nmutex_unlock(&port->dmaqueue_lock);\r\nsaa7164_vbi_buffers_dealloc(port);\r\ndprintk(DBGLVL_VBI, "%s(port=%d) Released\n", __func__, port->nr);\r\nreturn ret;\r\n}\r\nstatic int saa7164_vbi_start_streaming(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nint result, ret = 0;\r\ndprintk(DBGLVL_VBI, "%s(port=%d)\n", __func__, port->nr);\r\nport->done_first_interrupt = 0;\r\nsaa7164_vbi_buffers_alloc(port);\r\n#if 0\r\nsaa7164_api_set_encoder(port);\r\nsaa7164_api_get_encoder(port);\r\n#endif\r\nsaa7164_buffer_cfg_port(port);\r\nif (saa7164_api_set_vbi_format(port) != SAA_OK) {\r\nprintk(KERN_ERR "%s() No supported VBI format\n", __func__);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nresult = saa7164_api_transition_port(port, SAA_DMASTATE_ACQUIRE);\r\nif ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {\r\nprintk(KERN_ERR "%s() acquire transition failed, res = 0x%x\n",\r\n__func__, result);\r\nret = -EIO;\r\ngoto out;\r\n} else\r\ndprintk(DBGLVL_VBI, "%s() Acquired\n", __func__);\r\nresult = saa7164_api_transition_port(port, SAA_DMASTATE_PAUSE);\r\nif ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {\r\nprintk(KERN_ERR "%s() pause transition failed, res = 0x%x\n",\r\n__func__, result);\r\nresult = saa7164_vbi_stop_port(port);\r\nif (result != SAA_OK) {\r\nprintk(KERN_ERR "%s() pause/forced stop transition "\r\n"failed, res = 0x%x\n", __func__, result);\r\n}\r\nret = -EIO;\r\ngoto out;\r\n} else\r\ndprintk(DBGLVL_VBI, "%s() Paused\n", __func__);\r\nresult = saa7164_api_transition_port(port, SAA_DMASTATE_RUN);\r\nif ((result != SAA_OK) && (result != SAA_ERR_ALREADY_STOPPED)) {\r\nprintk(KERN_ERR "%s() run transition failed, result = 0x%x\n",\r\n__func__, result);\r\nresult = saa7164_vbi_acquire_port(port);\r\nresult = saa7164_vbi_stop_port(port);\r\nif (result != SAA_OK) {\r\nprintk(KERN_ERR "%s() run/forced stop transition "\r\n"failed, res = 0x%x\n", __func__, result);\r\n}\r\nret = -EIO;\r\n} else\r\ndprintk(DBGLVL_VBI, "%s() Running\n", __func__);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int saa7164_vbi_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nf->fmt.vbi.samples_per_line = 1600;\r\nf->fmt.vbi.samples_per_line = 1440;\r\nf->fmt.vbi.sampling_rate = 27000000;\r\nf->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;\r\nf->fmt.vbi.offset = 0;\r\nf->fmt.vbi.flags = 0;\r\nf->fmt.vbi.start[0] = 10;\r\nf->fmt.vbi.count[0] = 18;\r\nf->fmt.vbi.start[1] = 263 + 10 + 1;\r\nf->fmt.vbi.count[1] = 18;\r\nreturn 0;\r\n}\r\nstatic int fops_open(struct file *file)\r\n{\r\nstruct saa7164_dev *dev;\r\nstruct saa7164_port *port;\r\nstruct saa7164_vbi_fh *fh;\r\nport = (struct saa7164_port *)video_get_drvdata(video_devdata(file));\r\nif (!port)\r\nreturn -ENODEV;\r\ndev = port->dev;\r\ndprintk(DBGLVL_VBI, "%s()\n", __func__);\r\nfh = kzalloc(sizeof(*fh), GFP_KERNEL);\r\nif (NULL == fh)\r\nreturn -ENOMEM;\r\nfile->private_data = fh;\r\nfh->port = port;\r\nreturn 0;\r\n}\r\nstatic int fops_release(struct file *file)\r\n{\r\nstruct saa7164_vbi_fh *fh = file->private_data;\r\nstruct saa7164_port *port = fh->port;\r\nstruct saa7164_dev *dev = port->dev;\r\ndprintk(DBGLVL_VBI, "%s()\n", __func__);\r\nif (atomic_cmpxchg(&fh->v4l_reading, 1, 0) == 1) {\r\nif (atomic_dec_return(&port->v4l_reader_count) == 0) {\r\nsaa7164_vbi_stop_streaming(port);\r\n}\r\n}\r\nfile->private_data = NULL;\r\nkfree(fh);\r\nreturn 0;\r\n}\r\nstatic struct\r\nsaa7164_user_buffer *saa7164_vbi_next_buf(struct saa7164_port *port)\r\n{\r\nstruct saa7164_user_buffer *ubuf = NULL;\r\nstruct saa7164_dev *dev = port->dev;\r\nu32 crc;\r\nmutex_lock(&port->dmaqueue_lock);\r\nif (!list_empty(&port->list_buf_used.list)) {\r\nubuf = list_first_entry(&port->list_buf_used.list,\r\nstruct saa7164_user_buffer, list);\r\nif (crc_checking) {\r\ncrc = crc32(0, ubuf->data, ubuf->actual_size);\r\nif (crc != ubuf->crc) {\r\nprintk(KERN_ERR "%s() ubuf %p crc became invalid, was 0x%x became 0x%x\n",\r\n__func__,\r\nubuf, ubuf->crc, crc);\r\n}\r\n}\r\n}\r\nmutex_unlock(&port->dmaqueue_lock);\r\ndprintk(DBGLVL_VBI, "%s() returns %p\n", __func__, ubuf);\r\nreturn ubuf;\r\n}\r\nstatic ssize_t fops_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct saa7164_vbi_fh *fh = file->private_data;\r\nstruct saa7164_port *port = fh->port;\r\nstruct saa7164_user_buffer *ubuf = NULL;\r\nstruct saa7164_dev *dev = port->dev;\r\nint ret = 0;\r\nint rem, cnt;\r\nu8 *p;\r\nport->last_read_msecs_diff = port->last_read_msecs;\r\nport->last_read_msecs = jiffies_to_msecs(jiffies);\r\nport->last_read_msecs_diff = port->last_read_msecs -\r\nport->last_read_msecs_diff;\r\nsaa7164_histogram_update(&port->read_interval,\r\nport->last_read_msecs_diff);\r\nif (*pos) {\r\nprintk(KERN_ERR "%s() ESPIPE\n", __func__);\r\nreturn -ESPIPE;\r\n}\r\nif (atomic_cmpxchg(&fh->v4l_reading, 0, 1) == 0) {\r\nif (atomic_inc_return(&port->v4l_reader_count) == 1) {\r\nif (saa7164_vbi_initialize(port) < 0) {\r\nprintk(KERN_ERR "%s() EINVAL\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nsaa7164_vbi_start_streaming(port);\r\nmsleep(200);\r\n}\r\n}\r\nif ((file->f_flags & O_NONBLOCK) == 0) {\r\nif (wait_event_interruptible(port->wait_read,\r\nsaa7164_vbi_next_buf(port))) {\r\nprintk(KERN_ERR "%s() ERESTARTSYS\n", __func__);\r\nreturn -ERESTARTSYS;\r\n}\r\n}\r\nubuf = saa7164_vbi_next_buf(port);\r\nwhile ((count > 0) && ubuf) {\r\nrem = ubuf->actual_size - ubuf->pos;\r\ncnt = rem > count ? count : rem;\r\np = ubuf->data + ubuf->pos;\r\ndprintk(DBGLVL_VBI,\r\n"%s() count=%d cnt=%d rem=%d buf=%p buf->pos=%d\n",\r\n__func__, (int)count, cnt, rem, ubuf, ubuf->pos);\r\nif (copy_to_user(buffer, p, cnt)) {\r\nprintk(KERN_ERR "%s() copy_to_user failed\n", __func__);\r\nif (!ret) {\r\nprintk(KERN_ERR "%s() EFAULT\n", __func__);\r\nret = -EFAULT;\r\n}\r\ngoto err;\r\n}\r\nubuf->pos += cnt;\r\ncount -= cnt;\r\nbuffer += cnt;\r\nret += cnt;\r\nif (ubuf->pos > ubuf->actual_size)\r\nprintk(KERN_ERR "read() pos > actual, huh?\n");\r\nif (ubuf->pos == ubuf->actual_size) {\r\nubuf->pos = 0;\r\nmutex_lock(&port->dmaqueue_lock);\r\nlist_move_tail(&ubuf->list, &port->list_buf_free.list);\r\nmutex_unlock(&port->dmaqueue_lock);\r\nif ((file->f_flags & O_NONBLOCK) == 0) {\r\nif (wait_event_interruptible(port->wait_read,\r\nsaa7164_vbi_next_buf(port))) {\r\nbreak;\r\n}\r\n}\r\nubuf = saa7164_vbi_next_buf(port);\r\n}\r\n}\r\nerr:\r\nif (!ret && !ubuf) {\r\nprintk(KERN_ERR "%s() EAGAIN\n", __func__);\r\nret = -EAGAIN;\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int fops_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct saa7164_vbi_fh *fh = (struct saa7164_vbi_fh *)file->private_data;\r\nstruct saa7164_port *port = fh->port;\r\nunsigned int mask = 0;\r\nport->last_poll_msecs_diff = port->last_poll_msecs;\r\nport->last_poll_msecs = jiffies_to_msecs(jiffies);\r\nport->last_poll_msecs_diff = port->last_poll_msecs -\r\nport->last_poll_msecs_diff;\r\nsaa7164_histogram_update(&port->poll_interval,\r\nport->last_poll_msecs_diff);\r\nif (!video_is_registered(port->v4l_device))\r\nreturn -EIO;\r\nif (atomic_cmpxchg(&fh->v4l_reading, 0, 1) == 0) {\r\nif (atomic_inc_return(&port->v4l_reader_count) == 1) {\r\nif (saa7164_vbi_initialize(port) < 0)\r\nreturn -EINVAL;\r\nsaa7164_vbi_start_streaming(port);\r\nmsleep(200);\r\n}\r\n}\r\nif ((file->f_flags & O_NONBLOCK) == 0) {\r\nif (wait_event_interruptible(port->wait_read,\r\nsaa7164_vbi_next_buf(port))) {\r\nreturn -ERESTARTSYS;\r\n}\r\n}\r\nif (!list_empty(&port->list_buf_used.list))\r\nmask |= POLLIN | POLLRDNORM;\r\nreturn mask;\r\n}\r\nstatic struct video_device *saa7164_vbi_alloc(\r\nstruct saa7164_port *port,\r\nstruct pci_dev *pci,\r\nstruct video_device *template,\r\nchar *type)\r\n{\r\nstruct video_device *vfd;\r\nstruct saa7164_dev *dev = port->dev;\r\ndprintk(DBGLVL_VBI, "%s()\n", __func__);\r\nvfd = video_device_alloc();\r\nif (NULL == vfd)\r\nreturn NULL;\r\n*vfd = *template;\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s %s (%s)", dev->name,\r\ntype, saa7164_boards[dev->board].name);\r\nvfd->v4l2_dev = &dev->v4l2_dev;\r\nvfd->release = video_device_release;\r\nreturn vfd;\r\n}\r\nint saa7164_vbi_register(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\nint result = -ENODEV;\r\ndprintk(DBGLVL_VBI, "%s()\n", __func__);\r\nif (port->type != SAA7164_MPEG_VBI)\r\nBUG();\r\nif (port->hwcfg.BARLocation == 0) {\r\nprintk(KERN_ERR "%s() failed "\r\n"(errno = %d), NO PCI configuration\n",\r\n__func__, result);\r\nresult = -ENOMEM;\r\ngoto failed;\r\n}\r\nport->v4l_device = saa7164_vbi_alloc(port,\r\ndev->pci, &saa7164_vbi_template, "vbi");\r\nif (!port->v4l_device) {\r\nprintk(KERN_INFO "%s: can't allocate vbi device\n",\r\ndev->name);\r\nresult = -ENOMEM;\r\ngoto failed;\r\n}\r\nport->std = V4L2_STD_NTSC_M;\r\nvideo_set_drvdata(port->v4l_device, port);\r\nresult = video_register_device(port->v4l_device,\r\nVFL_TYPE_VBI, -1);\r\nif (result < 0) {\r\nprintk(KERN_INFO "%s: can't register vbi device\n",\r\ndev->name);\r\ngoto failed;\r\n}\r\nprintk(KERN_INFO "%s: registered device vbi%d [vbi]\n",\r\ndev->name, port->v4l_device->num);\r\nresult = 0;\r\nfailed:\r\nreturn result;\r\n}\r\nvoid saa7164_vbi_unregister(struct saa7164_port *port)\r\n{\r\nstruct saa7164_dev *dev = port->dev;\r\ndprintk(DBGLVL_VBI, "%s(port=%d)\n", __func__, port->nr);\r\nif (port->type != SAA7164_MPEG_VBI)\r\nBUG();\r\nif (port->v4l_device) {\r\nif (port->v4l_device->minor != -1)\r\nvideo_unregister_device(port->v4l_device);\r\nelse\r\nvideo_device_release(port->v4l_device);\r\nport->v4l_device = NULL;\r\n}\r\n}
