static unsigned int adau1701_register_size(struct device *dev,\r\nunsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase ADAU1701_PINCONF_0:\r\ncase ADAU1701_PINCONF_1:\r\nreturn 3;\r\ncase ADAU1701_DSPCTRL:\r\ncase ADAU1701_SEROCTL:\r\ncase ADAU1701_AUXNPOW:\r\ncase ADAU1701_OSCIPOW:\r\ncase ADAU1701_DACSET:\r\nreturn 2;\r\ncase ADAU1701_SERICTL:\r\nreturn 1;\r\n}\r\ndev_err(dev, "Unsupported register address: %d\n", reg);\r\nreturn 0;\r\n}\r\nstatic bool adau1701_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase ADAU1701_DACSET:\r\ncase ADAU1701_DSPCTRL:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int adau1701_reg_write(void *context, unsigned int reg,\r\nunsigned int value)\r\n{\r\nstruct i2c_client *client = context;\r\nunsigned int i;\r\nunsigned int size;\r\nuint8_t buf[5];\r\nint ret;\r\nsize = adau1701_register_size(&client->dev, reg);\r\nif (size == 0)\r\nreturn -EINVAL;\r\nbuf[0] = reg >> 8;\r\nbuf[1] = reg & 0xff;\r\nfor (i = size + 1; i >= 2; --i) {\r\nbuf[i] = value;\r\nvalue >>= 8;\r\n}\r\nret = i2c_master_send(client, buf, size + 2);\r\nif (ret == size + 2)\r\nreturn 0;\r\nelse if (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic int adau1701_reg_read(void *context, unsigned int reg,\r\nunsigned int *value)\r\n{\r\nint ret;\r\nunsigned int i;\r\nunsigned int size;\r\nuint8_t send_buf[2], recv_buf[3];\r\nstruct i2c_client *client = context;\r\nstruct i2c_msg msgs[2];\r\nsize = adau1701_register_size(&client->dev, reg);\r\nif (size == 0)\r\nreturn -EINVAL;\r\nsend_buf[0] = reg >> 8;\r\nsend_buf[1] = reg & 0xff;\r\nmsgs[0].addr = client->addr;\r\nmsgs[0].len = sizeof(send_buf);\r\nmsgs[0].buf = send_buf;\r\nmsgs[0].flags = 0;\r\nmsgs[1].addr = client->addr;\r\nmsgs[1].len = size;\r\nmsgs[1].buf = recv_buf;\r\nmsgs[1].flags = I2C_M_RD;\r\nret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret != ARRAY_SIZE(msgs))\r\nreturn -EIO;\r\n*value = 0;\r\nfor (i = 0; i < size; i++) {\r\n*value <<= 8;\r\n*value |= recv_buf[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic int adau1701_safeload(struct sigmadsp *sigmadsp, unsigned int addr,\r\nconst uint8_t bytes[], size_t len)\r\n{\r\nstruct i2c_client *client = to_i2c_client(sigmadsp->dev);\r\nstruct adau1701 *adau1701 = i2c_get_clientdata(client);\r\nunsigned int val;\r\nunsigned int i;\r\nuint8_t buf[10];\r\nint ret;\r\nret = regmap_read(adau1701->regmap, ADAU1701_DSPCTRL, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val & ADAU1701_DSPCTRL_IST)\r\nmsleep(50);\r\nfor (i = 0; i < len / 4; i++) {\r\nput_unaligned_le16(ADAU1701_SAFELOAD_DATA(i), buf);\r\nbuf[2] = 0x00;\r\nmemcpy(buf + 3, bytes + i * 4, 4);\r\nret = i2c_master_send(client, buf, 7);\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret != 7)\r\nreturn -EIO;\r\nput_unaligned_le16(ADAU1701_SAFELOAD_ADDR(i), buf);\r\nput_unaligned_le16(addr + i, buf + 2);\r\nret = i2c_master_send(client, buf, 4);\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret != 4)\r\nreturn -EIO;\r\n}\r\nreturn regmap_update_bits(adau1701->regmap, ADAU1701_DSPCTRL,\r\nADAU1701_DSPCTRL_IST, ADAU1701_DSPCTRL_IST);\r\n}\r\nstatic int adau1701_reset(struct snd_soc_codec *codec, unsigned int clkdiv,\r\nunsigned int rate)\r\n{\r\nstruct adau1701 *adau1701 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nsigmadsp_reset(adau1701->sigmadsp);\r\nif (clkdiv != ADAU1707_CLKDIV_UNSET &&\r\ngpio_is_valid(adau1701->gpio_pll_mode[0]) &&\r\ngpio_is_valid(adau1701->gpio_pll_mode[1])) {\r\nswitch (clkdiv) {\r\ncase 64:\r\ngpio_set_value_cansleep(adau1701->gpio_pll_mode[0], 0);\r\ngpio_set_value_cansleep(adau1701->gpio_pll_mode[1], 0);\r\nbreak;\r\ncase 256:\r\ngpio_set_value_cansleep(adau1701->gpio_pll_mode[0], 0);\r\ngpio_set_value_cansleep(adau1701->gpio_pll_mode[1], 1);\r\nbreak;\r\ncase 384:\r\ngpio_set_value_cansleep(adau1701->gpio_pll_mode[0], 1);\r\ngpio_set_value_cansleep(adau1701->gpio_pll_mode[1], 0);\r\nbreak;\r\ncase 0:\r\ncase 512:\r\ngpio_set_value_cansleep(adau1701->gpio_pll_mode[0], 1);\r\ngpio_set_value_cansleep(adau1701->gpio_pll_mode[1], 1);\r\nbreak;\r\n}\r\n}\r\nadau1701->pll_clkdiv = clkdiv;\r\nif (gpio_is_valid(adau1701->gpio_nreset)) {\r\ngpio_set_value_cansleep(adau1701->gpio_nreset, 0);\r\nudelay(1);\r\ngpio_set_value_cansleep(adau1701->gpio_nreset, 1);\r\nmdelay(85);\r\n}\r\nif (clkdiv != ADAU1707_CLKDIV_UNSET) {\r\nret = sigmadsp_setup(adau1701->sigmadsp, rate);\r\nif (ret) {\r\ndev_warn(codec->dev, "Failed to load firmware\n");\r\nreturn ret;\r\n}\r\n}\r\nregmap_write(adau1701->regmap, ADAU1701_DACSET, ADAU1701_DACSET_DACINIT);\r\nregmap_write(adau1701->regmap, ADAU1701_DSPCTRL, ADAU1701_DSPCTRL_CR);\r\nregcache_mark_dirty(adau1701->regmap);\r\nregcache_sync(adau1701->regmap);\r\nreturn 0;\r\n}\r\nstatic int adau1701_set_capture_pcm_format(struct snd_soc_codec *codec,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct adau1701 *adau1701 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int mask = ADAU1701_SEROCTL_WORD_LEN_MASK;\r\nunsigned int val;\r\nswitch (params_width(params)) {\r\ncase 16:\r\nval = ADAU1701_SEROCTL_WORD_LEN_16;\r\nbreak;\r\ncase 20:\r\nval = ADAU1701_SEROCTL_WORD_LEN_20;\r\nbreak;\r\ncase 24:\r\nval = ADAU1701_SEROCTL_WORD_LEN_24;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (adau1701->dai_fmt == SND_SOC_DAIFMT_RIGHT_J) {\r\nswitch (params_width(params)) {\r\ncase 16:\r\nval |= ADAU1701_SEROCTL_MSB_DEALY16;\r\nbreak;\r\ncase 20:\r\nval |= ADAU1701_SEROCTL_MSB_DEALY12;\r\nbreak;\r\ncase 24:\r\nval |= ADAU1701_SEROCTL_MSB_DEALY8;\r\nbreak;\r\n}\r\nmask |= ADAU1701_SEROCTL_MSB_DEALY_MASK;\r\n}\r\nregmap_update_bits(adau1701->regmap, ADAU1701_SEROCTL, mask, val);\r\nreturn 0;\r\n}\r\nstatic int adau1701_set_playback_pcm_format(struct snd_soc_codec *codec,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct adau1701 *adau1701 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val;\r\nif (adau1701->dai_fmt != SND_SOC_DAIFMT_RIGHT_J)\r\nreturn 0;\r\nswitch (params_width(params)) {\r\ncase 16:\r\nval = ADAU1701_SERICTL_RIGHTJ_16;\r\nbreak;\r\ncase 20:\r\nval = ADAU1701_SERICTL_RIGHTJ_20;\r\nbreak;\r\ncase 24:\r\nval = ADAU1701_SERICTL_RIGHTJ_24;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(adau1701->regmap, ADAU1701_SERICTL,\r\nADAU1701_SERICTL_MODE_MASK, val);\r\nreturn 0;\r\n}\r\nstatic int adau1701_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct adau1701 *adau1701 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int clkdiv = adau1701->sysclk / params_rate(params);\r\nunsigned int val;\r\nint ret;\r\nif (clkdiv != adau1701->pll_clkdiv) {\r\nret = adau1701_reset(codec, clkdiv, params_rate(params));\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nswitch (params_rate(params)) {\r\ncase 192000:\r\nval = ADAU1701_DSPCTRL_SR_192;\r\nbreak;\r\ncase 96000:\r\nval = ADAU1701_DSPCTRL_SR_96;\r\nbreak;\r\ncase 48000:\r\nval = ADAU1701_DSPCTRL_SR_48;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(adau1701->regmap, ADAU1701_DSPCTRL,\r\nADAU1701_DSPCTRL_SR_MASK, val);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nreturn adau1701_set_playback_pcm_format(codec, params);\r\nelse\r\nreturn adau1701_set_capture_pcm_format(codec, params);\r\n}\r\nstatic int adau1701_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct adau1701 *adau1701 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int serictl = 0x00, seroctl = 0x00;\r\nbool invert_lrclk;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nseroctl |= ADAU1701_SEROCTL_MASTER | ADAU1701_SEROCTL_OBF16\r\n| ADAU1701_SEROCTL_OLF1024;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\ninvert_lrclk = false;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\ninvert_lrclk = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\ninvert_lrclk = false;\r\nserictl |= ADAU1701_SERICTL_INV_BCLK;\r\nseroctl |= ADAU1701_SEROCTL_INV_BCLK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\ninvert_lrclk = true;\r\nserictl |= ADAU1701_SERICTL_INV_BCLK;\r\nseroctl |= ADAU1701_SEROCTL_INV_BCLK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nserictl |= ADAU1701_SERICTL_LEFTJ;\r\nseroctl |= ADAU1701_SEROCTL_MSB_DEALY0;\r\ninvert_lrclk = !invert_lrclk;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nserictl |= ADAU1701_SERICTL_RIGHTJ_24;\r\nseroctl |= ADAU1701_SEROCTL_MSB_DEALY8;\r\ninvert_lrclk = !invert_lrclk;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (invert_lrclk) {\r\nseroctl |= ADAU1701_SEROCTL_INV_LRCLK;\r\nserictl |= ADAU1701_SERICTL_INV_LRCLK;\r\n}\r\nadau1701->dai_fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\r\nregmap_write(adau1701->regmap, ADAU1701_SERICTL, serictl);\r\nregmap_update_bits(adau1701->regmap, ADAU1701_SEROCTL,\r\n~ADAU1701_SEROCTL_WORD_LEN_MASK, seroctl);\r\nreturn 0;\r\n}\r\nstatic int adau1701_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nunsigned int mask = ADAU1701_AUXNPOW_VBPD | ADAU1701_AUXNPOW_VRPD;\r\nstruct adau1701 *adau1701 = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nregmap_update_bits(adau1701->regmap,\r\nADAU1701_AUXNPOW, mask, 0x00);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nregmap_update_bits(adau1701->regmap,\r\nADAU1701_AUXNPOW, mask, mask);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int adau1701_digital_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nunsigned int mask = ADAU1701_DSPCTRL_DAM;\r\nstruct adau1701 *adau1701 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val;\r\nif (mute)\r\nval = 0;\r\nelse\r\nval = mask;\r\nregmap_update_bits(adau1701->regmap, ADAU1701_DSPCTRL, mask, val);\r\nreturn 0;\r\n}\r\nstatic int adau1701_set_sysclk(struct snd_soc_codec *codec, int clk_id,\r\nint source, unsigned int freq, int dir)\r\n{\r\nunsigned int val;\r\nstruct adau1701 *adau1701 = snd_soc_codec_get_drvdata(codec);\r\nswitch (clk_id) {\r\ncase ADAU1701_CLK_SRC_OSC:\r\nval = 0x0;\r\nbreak;\r\ncase ADAU1701_CLK_SRC_MCLK:\r\nval = ADAU1701_OSCIPOW_OPD;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(adau1701->regmap, ADAU1701_OSCIPOW,\r\nADAU1701_OSCIPOW_OPD, val);\r\nadau1701->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int adau1701_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct adau1701 *adau1701 = snd_soc_codec_get_drvdata(dai->codec);\r\nreturn sigmadsp_restrict_params(adau1701->sigmadsp, substream);\r\n}\r\nstatic int adau1701_probe(struct snd_soc_codec *codec)\r\n{\r\nint i, ret;\r\nunsigned int val;\r\nstruct adau1701 *adau1701 = snd_soc_codec_get_drvdata(codec);\r\nret = sigmadsp_attach(adau1701->sigmadsp, &codec->component);\r\nif (ret)\r\nreturn ret;\r\nadau1701->pll_clkdiv = ADAU1707_CLKDIV_UNSET;\r\nret = adau1701_reset(codec, adau1701->pll_clkdiv, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nval = 0;\r\nfor (i = 0; i < 6; i++)\r\nval |= adau1701->pin_config[i] << (i * 4);\r\nregmap_write(adau1701->regmap, ADAU1701_PINCONF_0, val);\r\nval = 0;\r\nfor (i = 0; i < 6; i++)\r\nval |= adau1701->pin_config[i + 6] << (i * 4);\r\nregmap_write(adau1701->regmap, ADAU1701_PINCONF_1, val);\r\nreturn 0;\r\n}\r\nstatic int adau1701_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct adau1701 *adau1701;\r\nstruct device *dev = &client->dev;\r\nint gpio_nreset = -EINVAL;\r\nint gpio_pll_mode[2] = { -EINVAL, -EINVAL };\r\nint ret;\r\nadau1701 = devm_kzalloc(dev, sizeof(*adau1701), GFP_KERNEL);\r\nif (!adau1701)\r\nreturn -ENOMEM;\r\nadau1701->client = client;\r\nadau1701->regmap = devm_regmap_init(dev, NULL, client,\r\n&adau1701_regmap);\r\nif (IS_ERR(adau1701->regmap))\r\nreturn PTR_ERR(adau1701->regmap);\r\nif (dev->of_node) {\r\ngpio_nreset = of_get_named_gpio(dev->of_node, "reset-gpio", 0);\r\nif (gpio_nreset < 0 && gpio_nreset != -ENOENT)\r\nreturn gpio_nreset;\r\ngpio_pll_mode[0] = of_get_named_gpio(dev->of_node,\r\n"adi,pll-mode-gpios", 0);\r\nif (gpio_pll_mode[0] < 0 && gpio_pll_mode[0] != -ENOENT)\r\nreturn gpio_pll_mode[0];\r\ngpio_pll_mode[1] = of_get_named_gpio(dev->of_node,\r\n"adi,pll-mode-gpios", 1);\r\nif (gpio_pll_mode[1] < 0 && gpio_pll_mode[1] != -ENOENT)\r\nreturn gpio_pll_mode[1];\r\nof_property_read_u32(dev->of_node, "adi,pll-clkdiv",\r\n&adau1701->pll_clkdiv);\r\nof_property_read_u8_array(dev->of_node, "adi,pin-config",\r\nadau1701->pin_config,\r\nARRAY_SIZE(adau1701->pin_config));\r\n}\r\nif (gpio_is_valid(gpio_nreset)) {\r\nret = devm_gpio_request_one(dev, gpio_nreset, GPIOF_OUT_INIT_LOW,\r\n"ADAU1701 Reset");\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (gpio_is_valid(gpio_pll_mode[0]) &&\r\ngpio_is_valid(gpio_pll_mode[1])) {\r\nret = devm_gpio_request_one(dev, gpio_pll_mode[0],\r\nGPIOF_OUT_INIT_LOW,\r\n"ADAU1701 PLL mode 0");\r\nif (ret < 0)\r\nreturn ret;\r\nret = devm_gpio_request_one(dev, gpio_pll_mode[1],\r\nGPIOF_OUT_INIT_LOW,\r\n"ADAU1701 PLL mode 1");\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nadau1701->gpio_nreset = gpio_nreset;\r\nadau1701->gpio_pll_mode[0] = gpio_pll_mode[0];\r\nadau1701->gpio_pll_mode[1] = gpio_pll_mode[1];\r\ni2c_set_clientdata(client, adau1701);\r\nadau1701->sigmadsp = devm_sigmadsp_init_i2c(client,\r\n&adau1701_sigmadsp_ops, ADAU1701_FIRMWARE);\r\nif (IS_ERR(adau1701->sigmadsp))\r\nreturn PTR_ERR(adau1701->sigmadsp);\r\nret = snd_soc_register_codec(&client->dev, &adau1701_codec_drv,\r\n&adau1701_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int adau1701_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
