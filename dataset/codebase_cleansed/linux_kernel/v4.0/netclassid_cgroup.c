static inline struct cgroup_cls_state *css_cls_state(struct cgroup_subsys_state *css)\r\n{\r\nreturn css ? container_of(css, struct cgroup_cls_state, css) : NULL;\r\n}\r\nstruct cgroup_cls_state *task_cls_state(struct task_struct *p)\r\n{\r\nreturn css_cls_state(task_css(p, net_cls_cgrp_id));\r\n}\r\nstatic struct cgroup_subsys_state *\r\ncgrp_css_alloc(struct cgroup_subsys_state *parent_css)\r\n{\r\nstruct cgroup_cls_state *cs;\r\ncs = kzalloc(sizeof(*cs), GFP_KERNEL);\r\nif (!cs)\r\nreturn ERR_PTR(-ENOMEM);\r\nreturn &cs->css;\r\n}\r\nstatic int cgrp_css_online(struct cgroup_subsys_state *css)\r\n{\r\nstruct cgroup_cls_state *cs = css_cls_state(css);\r\nstruct cgroup_cls_state *parent = css_cls_state(css->parent);\r\nif (parent)\r\ncs->classid = parent->classid;\r\nreturn 0;\r\n}\r\nstatic void cgrp_css_free(struct cgroup_subsys_state *css)\r\n{\r\nkfree(css_cls_state(css));\r\n}\r\nstatic int update_classid(const void *v, struct file *file, unsigned n)\r\n{\r\nint err;\r\nstruct socket *sock = sock_from_file(file, &err);\r\nif (sock)\r\nsock->sk->sk_classid = (u32)(unsigned long)v;\r\nreturn 0;\r\n}\r\nstatic void cgrp_attach(struct cgroup_subsys_state *css,\r\nstruct cgroup_taskset *tset)\r\n{\r\nstruct cgroup_cls_state *cs = css_cls_state(css);\r\nvoid *v = (void *)(unsigned long)cs->classid;\r\nstruct task_struct *p;\r\ncgroup_taskset_for_each(p, tset) {\r\ntask_lock(p);\r\niterate_fd(p->files, 0, update_classid, v);\r\ntask_unlock(p);\r\n}\r\n}\r\nstatic u64 read_classid(struct cgroup_subsys_state *css, struct cftype *cft)\r\n{\r\nreturn css_cls_state(css)->classid;\r\n}\r\nstatic int write_classid(struct cgroup_subsys_state *css, struct cftype *cft,\r\nu64 value)\r\n{\r\ncss_cls_state(css)->classid = (u32) value;\r\nreturn 0;\r\n}
