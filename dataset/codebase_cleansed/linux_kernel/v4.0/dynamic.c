struct device_node *of_node_get(struct device_node *node)\r\n{\r\nif (node)\r\nkobject_get(&node->kobj);\r\nreturn node;\r\n}\r\nvoid of_node_put(struct device_node *node)\r\n{\r\nif (node)\r\nkobject_put(&node->kobj);\r\n}\r\nvoid __of_detach_node_sysfs(struct device_node *np)\r\n{\r\nstruct property *pp;\r\nif (!IS_ENABLED(CONFIG_SYSFS))\r\nreturn;\r\nBUG_ON(!of_node_is_initialized(np));\r\nif (!of_kset)\r\nreturn;\r\nif (of_node_is_attached(np)) {\r\nfor_each_property_of_node(np, pp)\r\nsysfs_remove_bin_file(&np->kobj, &pp->attr);\r\nkobject_del(&np->kobj);\r\n}\r\nof_node_put(np);\r\n}\r\nint of_reconfig_notifier_register(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_register(&of_reconfig_chain, nb);\r\n}\r\nint of_reconfig_notifier_unregister(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_unregister(&of_reconfig_chain, nb);\r\n}\r\nint of_reconfig_notify(unsigned long action, struct of_reconfig_data *p)\r\n{\r\nint rc;\r\n#ifdef DEBUG\r\nstruct of_reconfig_data *pr = p;\r\nswitch (action) {\r\ncase OF_RECONFIG_ATTACH_NODE:\r\ncase OF_RECONFIG_DETACH_NODE:\r\npr_debug("of/notify %-15s %s\n", action_names[action],\r\npr->dn->full_name);\r\nbreak;\r\ncase OF_RECONFIG_ADD_PROPERTY:\r\ncase OF_RECONFIG_REMOVE_PROPERTY:\r\ncase OF_RECONFIG_UPDATE_PROPERTY:\r\npr_debug("of/notify %-15s %s:%s\n", action_names[action],\r\npr->dn->full_name, pr->prop->name);\r\nbreak;\r\n}\r\n#endif\r\nrc = blocking_notifier_call_chain(&of_reconfig_chain, action, p);\r\nreturn notifier_to_errno(rc);\r\n}\r\nint of_reconfig_get_state_change(unsigned long action, struct of_reconfig_data *pr)\r\n{\r\nstruct property *prop, *old_prop = NULL;\r\nint is_status, status_state, old_status_state, prev_state, new_state;\r\nswitch (action) {\r\ncase OF_RECONFIG_ATTACH_NODE:\r\ncase OF_RECONFIG_DETACH_NODE:\r\nprop = of_find_property(pr->dn, "status", NULL);\r\nbreak;\r\ncase OF_RECONFIG_ADD_PROPERTY:\r\ncase OF_RECONFIG_REMOVE_PROPERTY:\r\nprop = pr->prop;\r\nbreak;\r\ncase OF_RECONFIG_UPDATE_PROPERTY:\r\nprop = pr->prop;\r\nold_prop = pr->old_prop;\r\nbreak;\r\ndefault:\r\nreturn OF_RECONFIG_NO_CHANGE;\r\n}\r\nis_status = 0;\r\nstatus_state = -1;\r\nold_status_state = -1;\r\nprev_state = -1;\r\nnew_state = -1;\r\nif (prop && !strcmp(prop->name, "status")) {\r\nis_status = 1;\r\nstatus_state = !strcmp(prop->value, "okay") ||\r\n!strcmp(prop->value, "ok");\r\nif (old_prop)\r\nold_status_state = !strcmp(old_prop->value, "okay") ||\r\n!strcmp(old_prop->value, "ok");\r\n}\r\nswitch (action) {\r\ncase OF_RECONFIG_ATTACH_NODE:\r\nprev_state = 0;\r\nnew_state = status_state != 0;\r\nbreak;\r\ncase OF_RECONFIG_DETACH_NODE:\r\nprev_state = status_state != 0;\r\nnew_state = 0;\r\nbreak;\r\ncase OF_RECONFIG_ADD_PROPERTY:\r\nif (is_status) {\r\nprev_state = 1;\r\nnew_state = status_state;\r\n}\r\nbreak;\r\ncase OF_RECONFIG_REMOVE_PROPERTY:\r\nif (is_status) {\r\nprev_state = status_state;\r\nnew_state = 1;\r\n}\r\nbreak;\r\ncase OF_RECONFIG_UPDATE_PROPERTY:\r\nif (is_status) {\r\nprev_state = old_status_state != 0;\r\nnew_state = status_state != 0;\r\n}\r\nbreak;\r\n}\r\nif (prev_state == new_state)\r\nreturn OF_RECONFIG_NO_CHANGE;\r\nreturn new_state ? OF_RECONFIG_CHANGE_ADD : OF_RECONFIG_CHANGE_REMOVE;\r\n}\r\nint of_property_notify(int action, struct device_node *np,\r\nstruct property *prop, struct property *oldprop)\r\n{\r\nstruct of_reconfig_data pr;\r\nif (!of_node_is_attached(np))\r\nreturn 0;\r\npr.dn = np;\r\npr.prop = prop;\r\npr.old_prop = oldprop;\r\nreturn of_reconfig_notify(action, &pr);\r\n}\r\nvoid __of_attach_node(struct device_node *np)\r\n{\r\nconst __be32 *phandle;\r\nint sz;\r\nnp->name = __of_get_property(np, "name", NULL) ? : "<NULL>";\r\nnp->type = __of_get_property(np, "device_type", NULL) ? : "<NULL>";\r\nphandle = __of_get_property(np, "phandle", &sz);\r\nif (!phandle)\r\nphandle = __of_get_property(np, "linux,phandle", &sz);\r\nif (IS_ENABLED(PPC_PSERIES) && !phandle)\r\nphandle = __of_get_property(np, "ibm,phandle", &sz);\r\nnp->phandle = (phandle && (sz >= 4)) ? be32_to_cpup(phandle) : 0;\r\nnp->child = NULL;\r\nnp->sibling = np->parent->child;\r\nnp->parent->child = np;\r\nof_node_clear_flag(np, OF_DETACHED);\r\n}\r\nint of_attach_node(struct device_node *np)\r\n{\r\nstruct of_reconfig_data rd;\r\nunsigned long flags;\r\nmemset(&rd, 0, sizeof(rd));\r\nrd.dn = np;\r\nmutex_lock(&of_mutex);\r\nraw_spin_lock_irqsave(&devtree_lock, flags);\r\n__of_attach_node(np);\r\nraw_spin_unlock_irqrestore(&devtree_lock, flags);\r\n__of_attach_node_sysfs(np);\r\nmutex_unlock(&of_mutex);\r\nof_reconfig_notify(OF_RECONFIG_ATTACH_NODE, &rd);\r\nreturn 0;\r\n}\r\nvoid __of_detach_node(struct device_node *np)\r\n{\r\nstruct device_node *parent;\r\nif (WARN_ON(of_node_check_flag(np, OF_DETACHED)))\r\nreturn;\r\nparent = np->parent;\r\nif (WARN_ON(!parent))\r\nreturn;\r\nif (parent->child == np)\r\nparent->child = np->sibling;\r\nelse {\r\nstruct device_node *prevsib;\r\nfor (prevsib = np->parent->child;\r\nprevsib->sibling != np;\r\nprevsib = prevsib->sibling)\r\n;\r\nprevsib->sibling = np->sibling;\r\n}\r\nof_node_set_flag(np, OF_DETACHED);\r\n}\r\nint of_detach_node(struct device_node *np)\r\n{\r\nstruct of_reconfig_data rd;\r\nunsigned long flags;\r\nint rc = 0;\r\nmemset(&rd, 0, sizeof(rd));\r\nrd.dn = np;\r\nmutex_lock(&of_mutex);\r\nraw_spin_lock_irqsave(&devtree_lock, flags);\r\n__of_detach_node(np);\r\nraw_spin_unlock_irqrestore(&devtree_lock, flags);\r\n__of_detach_node_sysfs(np);\r\nmutex_unlock(&of_mutex);\r\nof_reconfig_notify(OF_RECONFIG_DETACH_NODE, &rd);\r\nreturn rc;\r\n}\r\nvoid of_node_release(struct kobject *kobj)\r\n{\r\nstruct device_node *node = kobj_to_device_node(kobj);\r\nstruct property *prop = node->properties;\r\nif (!of_node_check_flag(node, OF_DETACHED)) {\r\npr_err("ERROR: Bad of_node_put() on %s\n", node->full_name);\r\ndump_stack();\r\nreturn;\r\n}\r\nif (!of_node_check_flag(node, OF_DYNAMIC))\r\nreturn;\r\nwhile (prop) {\r\nstruct property *next = prop->next;\r\nkfree(prop->name);\r\nkfree(prop->value);\r\nkfree(prop);\r\nprop = next;\r\nif (!prop) {\r\nprop = node->deadprops;\r\nnode->deadprops = NULL;\r\n}\r\n}\r\nkfree(node->full_name);\r\nkfree(node->data);\r\nkfree(node);\r\n}\r\nstruct property *__of_prop_dup(const struct property *prop, gfp_t allocflags)\r\n{\r\nstruct property *new;\r\nnew = kzalloc(sizeof(*new), allocflags);\r\nif (!new)\r\nreturn NULL;\r\nnew->name = kstrdup(prop->name, allocflags);\r\nnew->value = kmemdup(prop->value, prop->length, allocflags);\r\nnew->length = prop->length;\r\nif (!new->name || !new->value)\r\ngoto err_free;\r\nof_property_set_flag(new, OF_DYNAMIC);\r\nreturn new;\r\nerr_free:\r\nkfree(new->name);\r\nkfree(new->value);\r\nkfree(new);\r\nreturn NULL;\r\n}\r\nstruct device_node *__of_node_dup(const struct device_node *np, const char *fmt, ...)\r\n{\r\nva_list vargs;\r\nstruct device_node *node;\r\nnode = kzalloc(sizeof(*node), GFP_KERNEL);\r\nif (!node)\r\nreturn NULL;\r\nva_start(vargs, fmt);\r\nnode->full_name = kvasprintf(GFP_KERNEL, fmt, vargs);\r\nva_end(vargs);\r\nif (!node->full_name) {\r\nkfree(node);\r\nreturn NULL;\r\n}\r\nof_node_set_flag(node, OF_DYNAMIC);\r\nof_node_set_flag(node, OF_DETACHED);\r\nof_node_init(node);\r\nif (np) {\r\nstruct property *pp, *new_pp;\r\nfor_each_property_of_node(np, pp) {\r\nnew_pp = __of_prop_dup(pp, GFP_KERNEL);\r\nif (!new_pp)\r\ngoto err_prop;\r\nif (__of_add_property(node, new_pp)) {\r\nkfree(new_pp->name);\r\nkfree(new_pp->value);\r\nkfree(new_pp);\r\ngoto err_prop;\r\n}\r\n}\r\n}\r\nreturn node;\r\nerr_prop:\r\nof_node_put(node);\r\nreturn NULL;\r\n}\r\nstatic void __of_changeset_entry_destroy(struct of_changeset_entry *ce)\r\n{\r\nof_node_put(ce->np);\r\nlist_del(&ce->node);\r\nkfree(ce);\r\n}\r\nstatic void __of_changeset_entry_dump(struct of_changeset_entry *ce)\r\n{\r\nswitch (ce->action) {\r\ncase OF_RECONFIG_ADD_PROPERTY:\r\ncase OF_RECONFIG_REMOVE_PROPERTY:\r\ncase OF_RECONFIG_UPDATE_PROPERTY:\r\npr_debug("of/cset<%p> %-15s %s/%s\n", ce, action_names[ce->action],\r\nce->np->full_name, ce->prop->name);\r\nbreak;\r\ncase OF_RECONFIG_ATTACH_NODE:\r\ncase OF_RECONFIG_DETACH_NODE:\r\npr_debug("of/cset<%p> %-15s %s\n", ce, action_names[ce->action],\r\nce->np->full_name);\r\nbreak;\r\n}\r\n}\r\nstatic inline void __of_changeset_entry_dump(struct of_changeset_entry *ce)\r\n{\r\n}\r\nstatic void __of_changeset_entry_invert(struct of_changeset_entry *ce,\r\nstruct of_changeset_entry *rce)\r\n{\r\nmemcpy(rce, ce, sizeof(*rce));\r\nswitch (ce->action) {\r\ncase OF_RECONFIG_ATTACH_NODE:\r\nrce->action = OF_RECONFIG_DETACH_NODE;\r\nbreak;\r\ncase OF_RECONFIG_DETACH_NODE:\r\nrce->action = OF_RECONFIG_ATTACH_NODE;\r\nbreak;\r\ncase OF_RECONFIG_ADD_PROPERTY:\r\nrce->action = OF_RECONFIG_REMOVE_PROPERTY;\r\nbreak;\r\ncase OF_RECONFIG_REMOVE_PROPERTY:\r\nrce->action = OF_RECONFIG_ADD_PROPERTY;\r\nbreak;\r\ncase OF_RECONFIG_UPDATE_PROPERTY:\r\nrce->old_prop = ce->prop;\r\nrce->prop = ce->old_prop;\r\nbreak;\r\n}\r\n}\r\nstatic void __of_changeset_entry_notify(struct of_changeset_entry *ce, bool revert)\r\n{\r\nstruct of_reconfig_data rd;\r\nstruct of_changeset_entry ce_inverted;\r\nint ret;\r\nif (revert) {\r\n__of_changeset_entry_invert(ce, &ce_inverted);\r\nce = &ce_inverted;\r\n}\r\nswitch (ce->action) {\r\ncase OF_RECONFIG_ATTACH_NODE:\r\ncase OF_RECONFIG_DETACH_NODE:\r\nmemset(&rd, 0, sizeof(rd));\r\nrd.dn = ce->np;\r\nret = of_reconfig_notify(ce->action, &rd);\r\nbreak;\r\ncase OF_RECONFIG_ADD_PROPERTY:\r\ncase OF_RECONFIG_REMOVE_PROPERTY:\r\ncase OF_RECONFIG_UPDATE_PROPERTY:\r\nret = of_property_notify(ce->action, ce->np, ce->prop, ce->old_prop);\r\nbreak;\r\ndefault:\r\npr_err("%s: invalid devicetree changeset action: %i\n", __func__,\r\n(int)ce->action);\r\nreturn;\r\n}\r\nif (ret)\r\npr_err("%s: notifier error @%s\n", __func__, ce->np->full_name);\r\n}\r\nstatic int __of_changeset_entry_apply(struct of_changeset_entry *ce)\r\n{\r\nstruct property *old_prop, **propp;\r\nunsigned long flags;\r\nint ret = 0;\r\n__of_changeset_entry_dump(ce);\r\nraw_spin_lock_irqsave(&devtree_lock, flags);\r\nswitch (ce->action) {\r\ncase OF_RECONFIG_ATTACH_NODE:\r\n__of_attach_node(ce->np);\r\nbreak;\r\ncase OF_RECONFIG_DETACH_NODE:\r\n__of_detach_node(ce->np);\r\nbreak;\r\ncase OF_RECONFIG_ADD_PROPERTY:\r\nfor (propp = &ce->np->deadprops; *propp; propp = &(*propp)->next) {\r\nif (*propp == ce->prop) {\r\n*propp = ce->prop->next;\r\nce->prop->next = NULL;\r\nbreak;\r\n}\r\n}\r\nret = __of_add_property(ce->np, ce->prop);\r\nif (ret) {\r\npr_err("%s: add_property failed @%s/%s\n",\r\n__func__, ce->np->full_name,\r\nce->prop->name);\r\nbreak;\r\n}\r\nbreak;\r\ncase OF_RECONFIG_REMOVE_PROPERTY:\r\nret = __of_remove_property(ce->np, ce->prop);\r\nif (ret) {\r\npr_err("%s: remove_property failed @%s/%s\n",\r\n__func__, ce->np->full_name,\r\nce->prop->name);\r\nbreak;\r\n}\r\nbreak;\r\ncase OF_RECONFIG_UPDATE_PROPERTY:\r\nfor (propp = &ce->np->deadprops; *propp; propp = &(*propp)->next) {\r\nif (*propp == ce->prop) {\r\n*propp = ce->prop->next;\r\nce->prop->next = NULL;\r\nbreak;\r\n}\r\n}\r\nret = __of_update_property(ce->np, ce->prop, &old_prop);\r\nif (ret) {\r\npr_err("%s: update_property failed @%s/%s\n",\r\n__func__, ce->np->full_name,\r\nce->prop->name);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nraw_spin_unlock_irqrestore(&devtree_lock, flags);\r\nif (ret)\r\nreturn ret;\r\nswitch (ce->action) {\r\ncase OF_RECONFIG_ATTACH_NODE:\r\n__of_attach_node_sysfs(ce->np);\r\nbreak;\r\ncase OF_RECONFIG_DETACH_NODE:\r\n__of_detach_node_sysfs(ce->np);\r\nbreak;\r\ncase OF_RECONFIG_ADD_PROPERTY:\r\n__of_add_property_sysfs(ce->np, ce->prop);\r\nbreak;\r\ncase OF_RECONFIG_REMOVE_PROPERTY:\r\n__of_remove_property_sysfs(ce->np, ce->prop);\r\nbreak;\r\ncase OF_RECONFIG_UPDATE_PROPERTY:\r\n__of_update_property_sysfs(ce->np, ce->prop, ce->old_prop);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int __of_changeset_entry_revert(struct of_changeset_entry *ce)\r\n{\r\nstruct of_changeset_entry ce_inverted;\r\n__of_changeset_entry_invert(ce, &ce_inverted);\r\nreturn __of_changeset_entry_apply(&ce_inverted);\r\n}\r\nvoid of_changeset_init(struct of_changeset *ocs)\r\n{\r\nmemset(ocs, 0, sizeof(*ocs));\r\nINIT_LIST_HEAD(&ocs->entries);\r\n}\r\nvoid of_changeset_destroy(struct of_changeset *ocs)\r\n{\r\nstruct of_changeset_entry *ce, *cen;\r\nlist_for_each_entry_safe_reverse(ce, cen, &ocs->entries, node)\r\n__of_changeset_entry_destroy(ce);\r\n}\r\nint of_changeset_apply(struct of_changeset *ocs)\r\n{\r\nstruct of_changeset_entry *ce;\r\nint ret;\r\npr_debug("of_changeset: applying...\n");\r\nlist_for_each_entry(ce, &ocs->entries, node) {\r\nret = __of_changeset_entry_apply(ce);\r\nif (ret) {\r\npr_err("%s: Error applying changeset (%d)\n", __func__, ret);\r\nlist_for_each_entry_continue_reverse(ce, &ocs->entries, node)\r\n__of_changeset_entry_revert(ce);\r\nreturn ret;\r\n}\r\n}\r\npr_debug("of_changeset: applied, emitting notifiers.\n");\r\nmutex_unlock(&of_mutex);\r\nlist_for_each_entry(ce, &ocs->entries, node)\r\n__of_changeset_entry_notify(ce, 0);\r\nmutex_lock(&of_mutex);\r\npr_debug("of_changeset: notifiers sent.\n");\r\nreturn 0;\r\n}\r\nint of_changeset_revert(struct of_changeset *ocs)\r\n{\r\nstruct of_changeset_entry *ce;\r\nint ret;\r\npr_debug("of_changeset: reverting...\n");\r\nlist_for_each_entry_reverse(ce, &ocs->entries, node) {\r\nret = __of_changeset_entry_revert(ce);\r\nif (ret) {\r\npr_err("%s: Error reverting changeset (%d)\n", __func__, ret);\r\nlist_for_each_entry_continue(ce, &ocs->entries, node)\r\n__of_changeset_entry_apply(ce);\r\nreturn ret;\r\n}\r\n}\r\npr_debug("of_changeset: reverted, emitting notifiers.\n");\r\nmutex_unlock(&of_mutex);\r\nlist_for_each_entry_reverse(ce, &ocs->entries, node)\r\n__of_changeset_entry_notify(ce, 1);\r\nmutex_lock(&of_mutex);\r\npr_debug("of_changeset: notifiers sent.\n");\r\nreturn 0;\r\n}\r\nint of_changeset_action(struct of_changeset *ocs, unsigned long action,\r\nstruct device_node *np, struct property *prop)\r\n{\r\nstruct of_changeset_entry *ce;\r\nce = kzalloc(sizeof(*ce), GFP_KERNEL);\r\nif (!ce) {\r\npr_err("%s: Failed to allocate\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nce->action = action;\r\nce->np = of_node_get(np);\r\nce->prop = prop;\r\nif (action == OF_RECONFIG_UPDATE_PROPERTY && prop)\r\nce->old_prop = of_find_property(np, prop->name, NULL);\r\nlist_add_tail(&ce->node, &ocs->entries);\r\nreturn 0;\r\n}
