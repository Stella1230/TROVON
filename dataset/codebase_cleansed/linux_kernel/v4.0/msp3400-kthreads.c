const char *msp_standard_std_name(int std)\r\n{\r\nint i;\r\nfor (i = 0; msp_stdlist[i].name != NULL; i++)\r\nif (msp_stdlist[i].retval == std)\r\nreturn msp_stdlist[i].name;\r\nreturn "unknown";\r\n}\r\nstatic v4l2_std_id msp_standard_std(int std)\r\n{\r\nint i;\r\nfor (i = 0; msp_stdlist[i].name != NULL; i++)\r\nif (msp_stdlist[i].retval == std)\r\nreturn msp_stdlist[i].std;\r\nreturn V4L2_STD_ALL;\r\n}\r\nstatic void msp_set_source(struct i2c_client *client, u16 src)\r\n{\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nif (msp_dolby) {\r\nmsp_write_dsp(client, 0x0008, 0x0520);\r\nmsp_write_dsp(client, 0x0009, 0x0620);\r\n} else {\r\nmsp_write_dsp(client, 0x0008, src);\r\nmsp_write_dsp(client, 0x0009, src);\r\n}\r\nmsp_write_dsp(client, 0x000a, src);\r\nmsp_write_dsp(client, 0x000b, src);\r\nmsp_write_dsp(client, 0x000c, src);\r\nif (state->has_scart2_out)\r\nmsp_write_dsp(client, 0x0041, src);\r\n}\r\nvoid msp3400c_set_carrier(struct i2c_client *client, int cdo1, int cdo2)\r\n{\r\nmsp_write_dem(client, 0x0093, cdo1 & 0xfff);\r\nmsp_write_dem(client, 0x009b, cdo1 >> 12);\r\nmsp_write_dem(client, 0x00a3, cdo2 & 0xfff);\r\nmsp_write_dem(client, 0x00ab, cdo2 >> 12);\r\nmsp_write_dem(client, 0x0056, 0);\r\n}\r\nvoid msp3400c_set_mode(struct i2c_client *client, int mode)\r\n{\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nstruct msp3400c_init_data_dem *data = &msp3400c_init_data[mode];\r\nint tuner = (state->route_in >> 3) & 1;\r\nint i;\r\nv4l_dbg(1, msp_debug, client, "set_mode: %d\n", mode);\r\nstate->mode = mode;\r\nstate->rxsubchans = V4L2_TUNER_SUB_MONO;\r\nmsp_write_dem(client, 0x00bb, data->ad_cv | (tuner ? 0x100 : 0));\r\nfor (i = 5; i >= 0; i--)\r\nmsp_write_dem(client, 0x0001, data->fir1[i]);\r\nmsp_write_dem(client, 0x0005, 0x0004);\r\nmsp_write_dem(client, 0x0005, 0x0040);\r\nmsp_write_dem(client, 0x0005, 0x0000);\r\nfor (i = 5; i >= 0; i--)\r\nmsp_write_dem(client, 0x0005, data->fir2[i]);\r\nmsp_write_dem(client, 0x0083, data->mode_reg);\r\nmsp3400c_set_carrier(client, data->cdo1, data->cdo2);\r\nmsp_set_source(client, data->dsp_src);\r\nmsp_write_dsp(client, 0x000d, 0x1900);\r\nmsp_write_dsp(client, 0x000e, data->dsp_matrix);\r\nif (state->has_nicam)\r\nmsp_write_dsp(client, 0x0010, 0x5a00);\r\n}\r\nstatic void msp3400c_set_audmode(struct i2c_client *client)\r\n{\r\nstatic char *strmode[] = {\r\n"mono", "stereo", "lang2", "lang1", "lang1+lang2"\r\n};\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nchar *modestr = (state->audmode >= 0 && state->audmode < 5) ?\r\nstrmode[state->audmode] : "unknown";\r\nint src = 0;\r\nint audmode = state->audmode;\r\nif (state->opmode == OPMODE_AUTOSELECT) {\r\nv4l_dbg(1, msp_debug, client,\r\n"set_audmode called with mode=%d instead of set_source (ignored)\n",\r\nstate->audmode);\r\nreturn;\r\n}\r\nif (state->mode != MSP_MODE_EXTERN) {\r\nif (state->rxsubchans == V4L2_TUNER_SUB_MONO)\r\naudmode = V4L2_TUNER_MODE_MONO;\r\nelse if (state->rxsubchans & V4L2_TUNER_SUB_LANG2) {\r\nif (audmode == V4L2_TUNER_MODE_MONO ||\r\naudmode == V4L2_TUNER_MODE_STEREO)\r\naudmode = V4L2_TUNER_MODE_LANG1;\r\n}\r\nelse if (audmode != V4L2_TUNER_MODE_MONO)\r\naudmode = V4L2_TUNER_MODE_STEREO;\r\n}\r\nswitch (state->mode) {\r\ncase MSP_MODE_FM_TERRA:\r\nv4l_dbg(1, msp_debug, client, "FM set_audmode: %s\n", modestr);\r\nswitch (audmode) {\r\ncase V4L2_TUNER_MODE_STEREO:\r\nmsp_write_dsp(client, 0x000e, 0x3001);\r\nbreak;\r\ncase V4L2_TUNER_MODE_MONO:\r\ncase V4L2_TUNER_MODE_LANG1:\r\ncase V4L2_TUNER_MODE_LANG2:\r\ncase V4L2_TUNER_MODE_LANG1_LANG2:\r\nmsp_write_dsp(client, 0x000e, 0x3000);\r\nbreak;\r\n}\r\nbreak;\r\ncase MSP_MODE_FM_SAT:\r\nv4l_dbg(1, msp_debug, client, "SAT set_audmode: %s\n", modestr);\r\nswitch (audmode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\nmsp3400c_set_carrier(client, MSP_CARRIER(6.5), MSP_CARRIER(6.5));\r\nbreak;\r\ncase V4L2_TUNER_MODE_STEREO:\r\ncase V4L2_TUNER_MODE_LANG1_LANG2:\r\nmsp3400c_set_carrier(client, MSP_CARRIER(7.2), MSP_CARRIER(7.02));\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1:\r\nmsp3400c_set_carrier(client, MSP_CARRIER(7.38), MSP_CARRIER(7.02));\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG2:\r\nmsp3400c_set_carrier(client, MSP_CARRIER(7.38), MSP_CARRIER(7.02));\r\nbreak;\r\n}\r\nbreak;\r\ncase MSP_MODE_FM_NICAM1:\r\ncase MSP_MODE_FM_NICAM2:\r\ncase MSP_MODE_AM_NICAM:\r\nv4l_dbg(1, msp_debug, client,\r\n"NICAM set_audmode: %s\n", modestr);\r\nif (state->nicam_on)\r\nsrc = 0x0100;\r\nbreak;\r\ncase MSP_MODE_BTSC:\r\nv4l_dbg(1, msp_debug, client,\r\n"BTSC set_audmode: %s\n", modestr);\r\nbreak;\r\ncase MSP_MODE_EXTERN:\r\nv4l_dbg(1, msp_debug, client,\r\n"extern set_audmode: %s\n", modestr);\r\nsrc = 0x0200;\r\nbreak;\r\ncase MSP_MODE_FM_RADIO:\r\nv4l_dbg(1, msp_debug, client,\r\n"FM-Radio set_audmode: %s\n", modestr);\r\nbreak;\r\ndefault:\r\nv4l_dbg(1, msp_debug, client, "mono set_audmode\n");\r\nreturn;\r\n}\r\nv4l_dbg(1, msp_debug, client, "set audmode %d\n", audmode);\r\nswitch (audmode) {\r\ncase V4L2_TUNER_MODE_STEREO:\r\ncase V4L2_TUNER_MODE_LANG1_LANG2:\r\nsrc |= 0x0020;\r\nbreak;\r\ncase V4L2_TUNER_MODE_MONO:\r\nif (state->mode == MSP_MODE_AM_NICAM) {\r\nv4l_dbg(1, msp_debug, client, "switching to AM mono\n");\r\nmsp_set_scart(client, SCART_MONO, 0);\r\nsrc = 0x0200;\r\nbreak;\r\n}\r\nif (state->rxsubchans & V4L2_TUNER_SUB_STEREO)\r\nsrc = 0x0030;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1:\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG2:\r\nsrc |= 0x0010;\r\nbreak;\r\n}\r\nv4l_dbg(1, msp_debug, client,\r\n"set_audmode final source/matrix = 0x%x\n", src);\r\nmsp_set_source(client, src);\r\n}\r\nstatic void msp3400c_print_mode(struct i2c_client *client)\r\n{\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nif (state->main == state->second)\r\nv4l_dbg(1, msp_debug, client,\r\n"mono sound carrier: %d.%03d MHz\n",\r\nstate->main / 910000, (state->main / 910) % 1000);\r\nelse\r\nv4l_dbg(1, msp_debug, client,\r\n"main sound carrier: %d.%03d MHz\n",\r\nstate->main / 910000, (state->main / 910) % 1000);\r\nif (state->mode == MSP_MODE_FM_NICAM1 || state->mode == MSP_MODE_FM_NICAM2)\r\nv4l_dbg(1, msp_debug, client,\r\n"NICAM/FM carrier : %d.%03d MHz\n",\r\nstate->second / 910000, (state->second/910) % 1000);\r\nif (state->mode == MSP_MODE_AM_NICAM)\r\nv4l_dbg(1, msp_debug, client,\r\n"NICAM/AM carrier : %d.%03d MHz\n",\r\nstate->second / 910000, (state->second / 910) % 1000);\r\nif (state->mode == MSP_MODE_FM_TERRA && state->main != state->second) {\r\nv4l_dbg(1, msp_debug, client,\r\n"FM-stereo carrier : %d.%03d MHz\n",\r\nstate->second / 910000, (state->second / 910) % 1000);\r\n}\r\n}\r\nstatic int msp3400c_detect_stereo(struct i2c_client *client)\r\n{\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nint val;\r\nint rxsubchans = state->rxsubchans;\r\nint newnicam = state->nicam_on;\r\nint update = 0;\r\nswitch (state->mode) {\r\ncase MSP_MODE_FM_TERRA:\r\nval = msp_read_dsp(client, 0x18);\r\nif (val > 32767)\r\nval -= 65536;\r\nv4l_dbg(2, msp_debug, client,\r\n"stereo detect register: %d\n", val);\r\nif (val > 8192) {\r\nrxsubchans = V4L2_TUNER_SUB_STEREO;\r\n} else if (val < -4096) {\r\nrxsubchans = V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;\r\n} else {\r\nrxsubchans = V4L2_TUNER_SUB_MONO;\r\n}\r\nnewnicam = 0;\r\nbreak;\r\ncase MSP_MODE_FM_NICAM1:\r\ncase MSP_MODE_FM_NICAM2:\r\ncase MSP_MODE_AM_NICAM:\r\nval = msp_read_dem(client, 0x23);\r\nv4l_dbg(2, msp_debug, client, "nicam sync=%d, mode=%d\n",\r\nval & 1, (val & 0x1e) >> 1);\r\nif (val & 1) {\r\nswitch ((val & 0x1e) >> 1) {\r\ncase 0:\r\ncase 8:\r\nrxsubchans = V4L2_TUNER_SUB_STEREO;\r\nbreak;\r\ncase 1:\r\ncase 9:\r\nrxsubchans = V4L2_TUNER_SUB_MONO;\r\nbreak;\r\ncase 2:\r\ncase 10:\r\nrxsubchans = V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;\r\nbreak;\r\ndefault:\r\nrxsubchans = V4L2_TUNER_SUB_MONO;\r\nbreak;\r\n}\r\nnewnicam = 1;\r\n} else {\r\nnewnicam = 0;\r\nrxsubchans = V4L2_TUNER_SUB_MONO;\r\n}\r\nbreak;\r\n}\r\nif (rxsubchans != state->rxsubchans) {\r\nupdate = 1;\r\nv4l_dbg(1, msp_debug, client,\r\n"watch: rxsubchans %02x => %02x\n",\r\nstate->rxsubchans, rxsubchans);\r\nstate->rxsubchans = rxsubchans;\r\n}\r\nif (newnicam != state->nicam_on) {\r\nupdate = 1;\r\nv4l_dbg(1, msp_debug, client, "watch: nicam %d => %d\n",\r\nstate->nicam_on, newnicam);\r\nstate->nicam_on = newnicam;\r\n}\r\nreturn update;\r\n}\r\nstatic void watch_stereo(struct i2c_client *client)\r\n{\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nif (msp_detect_stereo(client))\r\nmsp_set_audmode(client);\r\nif (msp_once)\r\nstate->watch_stereo = 0;\r\n}\r\nint msp3400c_thread(void *data)\r\n{\r\nstruct i2c_client *client = data;\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nstruct msp3400c_carrier_detect *cd;\r\nint count, max1, max2, val1, val2, val, i;\r\nv4l_dbg(1, msp_debug, client, "msp3400 daemon started\n");\r\nstate->detected_std = V4L2_STD_ALL;\r\nset_freezable();\r\nfor (;;) {\r\nv4l_dbg(2, msp_debug, client, "msp3400 thread: sleep\n");\r\nmsp_sleep(state, -1);\r\nv4l_dbg(2, msp_debug, client, "msp3400 thread: wakeup\n");\r\nrestart:\r\nv4l_dbg(2, msp_debug, client, "thread: restart scan\n");\r\nstate->restart = 0;\r\nif (kthread_should_stop())\r\nbreak;\r\nif (state->radio || MSP_MODE_EXTERN == state->mode) {\r\nv4l_dbg(1, msp_debug, client,\r\n"thread: no carrier scan\n");\r\nstate->scan_in_progress = 0;\r\nmsp_update_volume(state);\r\ncontinue;\r\n}\r\nstate->scan_in_progress = 1;\r\nmsp_update_volume(state);\r\nmsp3400c_set_mode(client, MSP_MODE_AM_DETECT);\r\nval1 = val2 = 0;\r\nmax1 = max2 = -1;\r\nstate->watch_stereo = 0;\r\nstate->nicam_on = 0;\r\nif (msp_sleep(state, 200))\r\ngoto restart;\r\ncd = msp3400c_carrier_detect_main;\r\ncount = ARRAY_SIZE(msp3400c_carrier_detect_main);\r\nif (msp_amsound && (state->v4l2_std & V4L2_STD_SECAM)) {\r\nmax1 = 3;\r\ncount = 0;\r\nv4l_dbg(1, msp_debug, client, "AM sound override\n");\r\n}\r\nfor (i = 0; i < count; i++) {\r\nmsp3400c_set_carrier(client, cd[i].cdo, cd[i].cdo);\r\nif (msp_sleep(state, 100))\r\ngoto restart;\r\nval = msp_read_dsp(client, 0x1b);\r\nif (val > 32767)\r\nval -= 65536;\r\nif (val1 < val)\r\nval1 = val, max1 = i;\r\nv4l_dbg(1, msp_debug, client,\r\n"carrier1 val: %5d / %s\n", val, cd[i].name);\r\n}\r\nswitch (max1) {\r\ncase 1:\r\ncd = msp3400c_carrier_detect_55;\r\ncount = ARRAY_SIZE(msp3400c_carrier_detect_55);\r\nbreak;\r\ncase 3:\r\ncd = msp3400c_carrier_detect_65;\r\ncount = ARRAY_SIZE(msp3400c_carrier_detect_65);\r\nbreak;\r\ncase 0:\r\ncase 2:\r\ndefault:\r\ncd = NULL;\r\ncount = 0;\r\nbreak;\r\n}\r\nif (msp_amsound && (state->v4l2_std & V4L2_STD_SECAM)) {\r\ncd = NULL;\r\ncount = 0;\r\nmax2 = 0;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nmsp3400c_set_carrier(client, cd[i].cdo, cd[i].cdo);\r\nif (msp_sleep(state, 100))\r\ngoto restart;\r\nval = msp_read_dsp(client, 0x1b);\r\nif (val > 32767)\r\nval -= 65536;\r\nif (val2 < val)\r\nval2 = val, max2 = i;\r\nv4l_dbg(1, msp_debug, client,\r\n"carrier2 val: %5d / %s\n", val, cd[i].name);\r\n}\r\nstate->main = msp3400c_carrier_detect_main[max1].cdo;\r\nswitch (max1) {\r\ncase 1:\r\nstate->detected_std = V4L2_STD_BG | V4L2_STD_PAL_H;\r\nif (max2 == 0) {\r\nstate->second = msp3400c_carrier_detect_55[max2].cdo;\r\nmsp3400c_set_mode(client, MSP_MODE_FM_TERRA);\r\nstate->watch_stereo = 1;\r\n} else if (max2 == 1 && state->has_nicam) {\r\nstate->second = msp3400c_carrier_detect_55[max2].cdo;\r\nmsp3400c_set_mode(client, MSP_MODE_FM_NICAM1);\r\nstate->nicam_on = 1;\r\nstate->watch_stereo = 1;\r\n} else {\r\ngoto no_second;\r\n}\r\nbreak;\r\ncase 2:\r\nstate->detected_std = V4L2_STD_PAL_I;\r\nstate->second = MSP_CARRIER(6.552);\r\nmsp3400c_set_mode(client, MSP_MODE_FM_NICAM2);\r\nstate->nicam_on = 1;\r\nstate->watch_stereo = 1;\r\nbreak;\r\ncase 3:\r\nif (max2 == 1 || max2 == 2) {\r\nstate->second = msp3400c_carrier_detect_65[max2].cdo;\r\nmsp3400c_set_mode(client, MSP_MODE_FM_TERRA);\r\nstate->watch_stereo = 1;\r\nstate->detected_std = V4L2_STD_DK;\r\n} else if (max2 == 0 && (state->v4l2_std & V4L2_STD_SECAM)) {\r\nstate->second = msp3400c_carrier_detect_65[max2].cdo;\r\nmsp3400c_set_mode(client, MSP_MODE_AM_NICAM);\r\nstate->watch_stereo = 1;\r\nstate->detected_std = V4L2_STD_L;\r\n} else if (max2 == 0 && state->has_nicam) {\r\nstate->second = msp3400c_carrier_detect_65[max2].cdo;\r\nmsp3400c_set_mode(client, MSP_MODE_FM_NICAM1);\r\nstate->nicam_on = 1;\r\nstate->watch_stereo = 1;\r\nstate->detected_std = V4L2_STD_DK;\r\n} else {\r\ngoto no_second;\r\n}\r\nbreak;\r\ncase 0:\r\nstate->detected_std = V4L2_STD_MN;\r\ndefault:\r\nno_second:\r\nstate->second = msp3400c_carrier_detect_main[max1].cdo;\r\nmsp3400c_set_mode(client, MSP_MODE_FM_TERRA);\r\nbreak;\r\n}\r\nmsp3400c_set_carrier(client, state->second, state->main);\r\nstate->scan_in_progress = 0;\r\nmsp3400c_set_audmode(client);\r\nmsp_update_volume(state);\r\nif (msp_debug)\r\nmsp3400c_print_mode(client);\r\ncount = 3;\r\nwhile (state->watch_stereo) {\r\nif (msp_sleep(state, count ? 1000 : 5000))\r\ngoto restart;\r\nif (count)\r\ncount--;\r\nwatch_stereo(client);\r\n}\r\n}\r\nv4l_dbg(1, msp_debug, client, "thread: exit\n");\r\nreturn 0;\r\n}\r\nint msp3410d_thread(void *data)\r\n{\r\nstruct i2c_client *client = data;\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nint val, i, std, count;\r\nv4l_dbg(1, msp_debug, client, "msp3410 daemon started\n");\r\nstate->detected_std = V4L2_STD_ALL;\r\nset_freezable();\r\nfor (;;) {\r\nv4l_dbg(2, msp_debug, client, "msp3410 thread: sleep\n");\r\nmsp_sleep(state, -1);\r\nv4l_dbg(2, msp_debug, client, "msp3410 thread: wakeup\n");\r\nrestart:\r\nv4l_dbg(2, msp_debug, client, "thread: restart scan\n");\r\nstate->restart = 0;\r\nif (kthread_should_stop())\r\nbreak;\r\nif (state->mode == MSP_MODE_EXTERN) {\r\nv4l_dbg(1, msp_debug, client,\r\n"thread: no carrier scan\n");\r\nstate->scan_in_progress = 0;\r\nmsp_update_volume(state);\r\ncontinue;\r\n}\r\nstate->scan_in_progress = 1;\r\nmsp_update_volume(state);\r\nif (state->radio)\r\nstd = 0x40;\r\nelse\r\nstd = (state->v4l2_std & V4L2_STD_NTSC) ? 0x20 : 1;\r\nstate->watch_stereo = 0;\r\nstate->nicam_on = 0;\r\nif (msp_sleep(state, 200))\r\ngoto restart;\r\nif (msp_debug)\r\nv4l_dbg(2, msp_debug, client,\r\n"setting standard: %s (0x%04x)\n",\r\nmsp_standard_std_name(std), std);\r\nif (std != 1) {\r\nval = std;\r\n} else {\r\nmsp_write_dem(client, 0x20, std);\r\nfor (;;) {\r\nif (msp_sleep(state, 100))\r\ngoto restart;\r\nval = msp_read_dem(client, 0x7e);\r\nif (val < 0x07ff)\r\nbreak;\r\nv4l_dbg(2, msp_debug, client,\r\n"detection still in progress\n");\r\n}\r\n}\r\nfor (i = 0; msp_stdlist[i].name != NULL; i++)\r\nif (msp_stdlist[i].retval == val)\r\nbreak;\r\nv4l_dbg(1, msp_debug, client, "current standard: %s (0x%04x)\n",\r\nmsp_standard_std_name(val), val);\r\nstate->main = msp_stdlist[i].main;\r\nstate->second = msp_stdlist[i].second;\r\nstate->std = val;\r\nstate->rxsubchans = V4L2_TUNER_SUB_MONO;\r\nif (msp_amsound && !state->radio &&\r\n(state->v4l2_std & V4L2_STD_SECAM) && (val != 0x0009)) {\r\nv4l_dbg(1, msp_debug, client, "autodetection failed,"\r\n" switching to backup standard: %s (0x%04x)\n",\r\nmsp_stdlist[8].name ?\r\nmsp_stdlist[8].name : "unknown", val);\r\nstate->std = val = 0x0009;\r\nmsp_write_dem(client, 0x20, val);\r\n} else {\r\nstate->detected_std = msp_standard_std(state->std);\r\n}\r\nswitch (val) {\r\ncase 0x0008:\r\ncase 0x000a:\r\ncase 0x000b:\r\nif (val == 0x000a)\r\nstate->mode = MSP_MODE_FM_NICAM2;\r\nelse\r\nstate->mode = MSP_MODE_FM_NICAM1;\r\nstate->nicam_on = 1;\r\nstate->watch_stereo = 1;\r\nbreak;\r\ncase 0x0009:\r\nstate->mode = MSP_MODE_AM_NICAM;\r\nstate->nicam_on = 1;\r\nstate->watch_stereo = 1;\r\nbreak;\r\ncase 0x0020:\r\nstate->mode = MSP_MODE_BTSC;\r\nbreak;\r\ncase 0x0040:\r\nstate->mode = MSP_MODE_FM_RADIO;\r\nstate->rxsubchans = V4L2_TUNER_SUB_STEREO;\r\nmsp3400c_set_mode(client, MSP_MODE_FM_RADIO);\r\nmsp3400c_set_carrier(client, MSP_CARRIER(10.7),\r\nMSP_CARRIER(10.7));\r\nbreak;\r\ncase 0x0002:\r\ncase 0x0003:\r\ncase 0x0004:\r\ncase 0x0005:\r\nstate->mode = MSP_MODE_FM_TERRA;\r\nstate->watch_stereo = 1;\r\nbreak;\r\n}\r\nmsp_write_dsp(client, 0x0d, 0x1900);\r\nmsp_write_dsp(client, 0x0e, 0x3000);\r\nif (state->has_nicam)\r\nmsp_write_dsp(client, 0x10, 0x5a00);\r\nif (state->has_i2s_conf)\r\nmsp_write_dem(client, 0x40, state->i2s_mode);\r\nmsp3400c_set_audmode(client);\r\nstate->scan_in_progress = 0;\r\nmsp_update_volume(state);\r\ncount = 3;\r\nwhile (state->watch_stereo) {\r\nif (msp_sleep(state, count ? 1000 : 5000))\r\ngoto restart;\r\nif (count)\r\ncount--;\r\nwatch_stereo(client);\r\n}\r\n}\r\nv4l_dbg(1, msp_debug, client, "thread: exit\n");\r\nreturn 0;\r\n}\r\nstatic int msp34xxg_modus(struct i2c_client *client)\r\n{\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nif (state->radio) {\r\nv4l_dbg(1, msp_debug, client, "selected radio modus\n");\r\nreturn 0x0001;\r\n}\r\nif (state->v4l2_std == V4L2_STD_NTSC_M_JP) {\r\nv4l_dbg(1, msp_debug, client, "selected M (EIA-J) modus\n");\r\nreturn 0x4001;\r\n}\r\nif (state->v4l2_std == V4L2_STD_NTSC_M_KR) {\r\nv4l_dbg(1, msp_debug, client, "selected M (A2) modus\n");\r\nreturn 0x0001;\r\n}\r\nif (state->v4l2_std == V4L2_STD_SECAM_L) {\r\nv4l_dbg(1, msp_debug, client, "selected SECAM-L modus\n");\r\nreturn 0x6001;\r\n}\r\nif (state->v4l2_std & V4L2_STD_MN) {\r\nv4l_dbg(1, msp_debug, client, "selected M (BTSC) modus\n");\r\nreturn 0x2001;\r\n}\r\nreturn 0x7001;\r\n}\r\nstatic void msp34xxg_set_source(struct i2c_client *client, u16 reg, int in)\r\n{\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nint source, matrix;\r\nswitch (state->audmode) {\r\ncase V4L2_TUNER_MODE_MONO:\r\nsource = 0;\r\nmatrix = 0x30;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG2:\r\nsource = 4;\r\nmatrix = 0x10;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1_LANG2:\r\nsource = 1;\r\nmatrix = 0x20;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG1:\r\nsource = 3;\r\nmatrix = 0x00;\r\nbreak;\r\ncase V4L2_TUNER_MODE_STEREO:\r\ndefault:\r\nsource = 3;\r\nmatrix = 0x20;\r\nbreak;\r\n}\r\nif (in == MSP_DSP_IN_TUNER)\r\nsource = (source << 8) | 0x20;\r\nelse if (in >= MSP_DSP_IN_MAIN_AVC && state->has_dolby_pro_logic)\r\nsource = ((in + 1) << 8) | matrix;\r\nelse\r\nsource = (in << 8) | matrix;\r\nv4l_dbg(1, msp_debug, client,\r\n"set source to %d (0x%x) for output %02x\n", in, source, reg);\r\nmsp_write_dsp(client, reg, source);\r\n}\r\nstatic void msp34xxg_set_sources(struct i2c_client *client)\r\n{\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nu32 in = state->route_in;\r\nmsp34xxg_set_source(client, 0x0008, (in >> 4) & 0xf);\r\nmsp34xxg_set_source(client, 0x000c, (in >> 4) & 0xf);\r\nmsp34xxg_set_source(client, 0x0009, (in >> 8) & 0xf);\r\nmsp34xxg_set_source(client, 0x000a, (in >> 12) & 0xf);\r\nif (state->has_scart2_out)\r\nmsp34xxg_set_source(client, 0x0041, (in >> 16) & 0xf);\r\nmsp34xxg_set_source(client, 0x000b, (in >> 20) & 0xf);\r\n}\r\nstatic void msp34xxg_reset(struct i2c_client *client)\r\n{\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nint tuner = (state->route_in >> 3) & 1;\r\nint modus;\r\nstate->std = 1;\r\nmsp_reset(client);\r\nif (state->has_i2s_conf)\r\nmsp_write_dem(client, 0x40, state->i2s_mode);\r\nmodus = msp34xxg_modus(client);\r\nmodus |= tuner ? 0x100 : 0;\r\nmsp_write_dem(client, 0x30, modus);\r\nmsp34xxg_set_sources(client);\r\nmsp_write_dsp(client, 0x0d, 0x1900);\r\nmsp_write_dsp(client, 0x0e, 0x3000);\r\nif (state->has_nicam)\r\nmsp_write_dsp(client, 0x10, 0x5a00);\r\nmsp_write_dem(client, 0x22, msp_stereo_thresh);\r\n}\r\nint msp34xxg_thread(void *data)\r\n{\r\nstruct i2c_client *client = data;\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nint val, i;\r\nv4l_dbg(1, msp_debug, client, "msp34xxg daemon started\n");\r\nstate->detected_std = V4L2_STD_ALL;\r\nset_freezable();\r\nfor (;;) {\r\nv4l_dbg(2, msp_debug, client, "msp34xxg thread: sleep\n");\r\nmsp_sleep(state, -1);\r\nv4l_dbg(2, msp_debug, client, "msp34xxg thread: wakeup\n");\r\nrestart:\r\nv4l_dbg(1, msp_debug, client, "thread: restart scan\n");\r\nstate->restart = 0;\r\nif (kthread_should_stop())\r\nbreak;\r\nif (state->mode == MSP_MODE_EXTERN) {\r\nv4l_dbg(1, msp_debug, client,\r\n"thread: no carrier scan\n");\r\nstate->scan_in_progress = 0;\r\nmsp_update_volume(state);\r\ncontinue;\r\n}\r\nmsp34xxg_reset(client);\r\nstate->std = state->radio ? 0x40 :\r\n(state->force_btsc && msp_standard == 1) ? 32 : msp_standard;\r\nmsp_write_dem(client, 0x20, state->std);\r\nif (state->std != 1)\r\ngoto unmute;\r\nv4l_dbg(1, msp_debug, client,\r\n"started autodetect, waiting for result\n");\r\nfor (i = 0; i < 10; i++) {\r\nif (msp_sleep(state, 100))\r\ngoto restart;\r\nval = msp_read_dem(client, 0x7e);\r\nif (val < 0x07ff) {\r\nstate->std = val;\r\nbreak;\r\n}\r\nv4l_dbg(2, msp_debug, client,\r\n"detection still in progress\n");\r\n}\r\nif (state->std == 1) {\r\nv4l_dbg(1, msp_debug, client,\r\n"detection still in progress after 10 tries. giving up.\n");\r\ncontinue;\r\n}\r\nunmute:\r\nv4l_dbg(1, msp_debug, client,\r\n"detected standard: %s (0x%04x)\n",\r\nmsp_standard_std_name(state->std), state->std);\r\nstate->detected_std = msp_standard_std(state->std);\r\nif (state->std == 9) {\r\nmsp_write_dsp(client, 0x0e, 0x7c00);\r\n}\r\nmsp_update_volume(state);\r\nif (msp_write_dsp(client, 0x13, state->acb))\r\nreturn -1;\r\nif (state->std != 0x20)\r\ncontinue;\r\nstate->watch_stereo = 1;\r\nwatch_stereo(client);\r\nwhile (state->watch_stereo) {\r\nwatch_stereo(client);\r\nif (msp_sleep(state, 5000))\r\ngoto restart;\r\n}\r\n}\r\nv4l_dbg(1, msp_debug, client, "thread: exit\n");\r\nreturn 0;\r\n}\r\nstatic int msp34xxg_detect_stereo(struct i2c_client *client)\r\n{\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nint status = msp_read_dem(client, 0x0200);\r\nint is_bilingual = status & 0x100;\r\nint is_stereo = status & 0x40;\r\nint oldrx = state->rxsubchans;\r\nif (state->mode == MSP_MODE_EXTERN)\r\nreturn 0;\r\nstate->rxsubchans = 0;\r\nif (is_stereo)\r\nstate->rxsubchans = V4L2_TUNER_SUB_STEREO;\r\nelse\r\nstate->rxsubchans = V4L2_TUNER_SUB_MONO;\r\nif (is_bilingual) {\r\nif (state->std == 0x20)\r\nstate->rxsubchans |= V4L2_TUNER_SUB_SAP;\r\nelse\r\nstate->rxsubchans =\r\nV4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;\r\n}\r\nv4l_dbg(1, msp_debug, client,\r\n"status=0x%x, stereo=%d, bilingual=%d -> rxsubchans=%d\n",\r\nstatus, is_stereo, is_bilingual, state->rxsubchans);\r\nreturn (oldrx != state->rxsubchans);\r\n}\r\nstatic void msp34xxg_set_audmode(struct i2c_client *client)\r\n{\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nif (state->std == 0x20) {\r\nif ((state->rxsubchans & V4L2_TUNER_SUB_SAP) &&\r\n(state->audmode == V4L2_TUNER_MODE_LANG1_LANG2 ||\r\nstate->audmode == V4L2_TUNER_MODE_LANG2)) {\r\nmsp_write_dem(client, 0x20, 0x21);\r\n} else {\r\nmsp_write_dem(client, 0x20, 0x20);\r\n}\r\n}\r\nmsp34xxg_set_sources(client);\r\n}\r\nvoid msp_set_audmode(struct i2c_client *client)\r\n{\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nswitch (state->opmode) {\r\ncase OPMODE_MANUAL:\r\ncase OPMODE_AUTODETECT:\r\nmsp3400c_set_audmode(client);\r\nbreak;\r\ncase OPMODE_AUTOSELECT:\r\nmsp34xxg_set_audmode(client);\r\nbreak;\r\n}\r\n}\r\nint msp_detect_stereo(struct i2c_client *client)\r\n{\r\nstruct msp_state *state = to_state(i2c_get_clientdata(client));\r\nswitch (state->opmode) {\r\ncase OPMODE_MANUAL:\r\ncase OPMODE_AUTODETECT:\r\nreturn msp3400c_detect_stereo(client);\r\ncase OPMODE_AUTOSELECT:\r\nreturn msp34xxg_detect_stereo(client);\r\n}\r\nreturn 0;\r\n}
