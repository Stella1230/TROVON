void nfc_llcp_sock_link(struct llcp_sock_list *l, struct sock *sk)\r\n{\r\nwrite_lock(&l->lock);\r\nsk_add_node(sk, &l->head);\r\nwrite_unlock(&l->lock);\r\n}\r\nvoid nfc_llcp_sock_unlink(struct llcp_sock_list *l, struct sock *sk)\r\n{\r\nwrite_lock(&l->lock);\r\nsk_del_node_init(sk);\r\nwrite_unlock(&l->lock);\r\n}\r\nvoid nfc_llcp_socket_remote_param_init(struct nfc_llcp_sock *sock)\r\n{\r\nsock->remote_rw = LLCP_DEFAULT_RW;\r\nsock->remote_miu = LLCP_MAX_MIU + 1;\r\n}\r\nstatic void nfc_llcp_socket_purge(struct nfc_llcp_sock *sock)\r\n{\r\nstruct nfc_llcp_local *local = sock->local;\r\nstruct sk_buff *s, *tmp;\r\npr_debug("%p\n", &sock->sk);\r\nskb_queue_purge(&sock->tx_queue);\r\nskb_queue_purge(&sock->tx_pending_queue);\r\nif (local == NULL)\r\nreturn;\r\nskb_queue_walk_safe(&local->tx_queue, s, tmp) {\r\nif (s->sk != &sock->sk)\r\ncontinue;\r\nskb_unlink(s, &local->tx_queue);\r\nkfree_skb(s);\r\n}\r\n}\r\nstatic void nfc_llcp_socket_release(struct nfc_llcp_local *local, bool device,\r\nint err)\r\n{\r\nstruct sock *sk;\r\nstruct hlist_node *tmp;\r\nstruct nfc_llcp_sock *llcp_sock;\r\nskb_queue_purge(&local->tx_queue);\r\nwrite_lock(&local->sockets.lock);\r\nsk_for_each_safe(sk, tmp, &local->sockets.head) {\r\nllcp_sock = nfc_llcp_sock(sk);\r\nbh_lock_sock(sk);\r\nnfc_llcp_socket_purge(llcp_sock);\r\nif (sk->sk_state == LLCP_CONNECTED)\r\nnfc_put_device(llcp_sock->dev);\r\nif (sk->sk_state == LLCP_LISTEN) {\r\nstruct nfc_llcp_sock *lsk, *n;\r\nstruct sock *accept_sk;\r\nlist_for_each_entry_safe(lsk, n,\r\n&llcp_sock->accept_queue,\r\naccept_queue) {\r\naccept_sk = &lsk->sk;\r\nbh_lock_sock(accept_sk);\r\nnfc_llcp_accept_unlink(accept_sk);\r\nif (err)\r\naccept_sk->sk_err = err;\r\naccept_sk->sk_state = LLCP_CLOSED;\r\naccept_sk->sk_state_change(sk);\r\nbh_unlock_sock(accept_sk);\r\n}\r\n}\r\nif (err)\r\nsk->sk_err = err;\r\nsk->sk_state = LLCP_CLOSED;\r\nsk->sk_state_change(sk);\r\nbh_unlock_sock(sk);\r\nsk_del_node_init(sk);\r\n}\r\nwrite_unlock(&local->sockets.lock);\r\nif (device == true)\r\nreturn;\r\nwrite_lock(&local->raw_sockets.lock);\r\nsk_for_each_safe(sk, tmp, &local->raw_sockets.head) {\r\nllcp_sock = nfc_llcp_sock(sk);\r\nbh_lock_sock(sk);\r\nnfc_llcp_socket_purge(llcp_sock);\r\nif (err)\r\nsk->sk_err = err;\r\nsk->sk_state = LLCP_CLOSED;\r\nsk->sk_state_change(sk);\r\nbh_unlock_sock(sk);\r\nsk_del_node_init(sk);\r\n}\r\nwrite_unlock(&local->raw_sockets.lock);\r\n}\r\nstruct nfc_llcp_local *nfc_llcp_local_get(struct nfc_llcp_local *local)\r\n{\r\nkref_get(&local->ref);\r\nreturn local;\r\n}\r\nstatic void local_cleanup(struct nfc_llcp_local *local)\r\n{\r\nnfc_llcp_socket_release(local, false, ENXIO);\r\ndel_timer_sync(&local->link_timer);\r\nskb_queue_purge(&local->tx_queue);\r\ncancel_work_sync(&local->tx_work);\r\ncancel_work_sync(&local->rx_work);\r\ncancel_work_sync(&local->timeout_work);\r\nkfree_skb(local->rx_pending);\r\ndel_timer_sync(&local->sdreq_timer);\r\ncancel_work_sync(&local->sdreq_timeout_work);\r\nnfc_llcp_free_sdp_tlv_list(&local->pending_sdreqs);\r\n}\r\nstatic void local_release(struct kref *ref)\r\n{\r\nstruct nfc_llcp_local *local;\r\nlocal = container_of(ref, struct nfc_llcp_local, ref);\r\nlist_del(&local->list);\r\nlocal_cleanup(local);\r\nkfree(local);\r\n}\r\nint nfc_llcp_local_put(struct nfc_llcp_local *local)\r\n{\r\nif (local == NULL)\r\nreturn 0;\r\nreturn kref_put(&local->ref, local_release);\r\n}\r\nstatic struct nfc_llcp_sock *nfc_llcp_sock_get(struct nfc_llcp_local *local,\r\nu8 ssap, u8 dsap)\r\n{\r\nstruct sock *sk;\r\nstruct nfc_llcp_sock *llcp_sock, *tmp_sock;\r\npr_debug("ssap dsap %d %d\n", ssap, dsap);\r\nif (ssap == 0 && dsap == 0)\r\nreturn NULL;\r\nread_lock(&local->sockets.lock);\r\nllcp_sock = NULL;\r\nsk_for_each(sk, &local->sockets.head) {\r\ntmp_sock = nfc_llcp_sock(sk);\r\nif (tmp_sock->ssap == ssap && tmp_sock->dsap == dsap) {\r\nllcp_sock = tmp_sock;\r\nbreak;\r\n}\r\n}\r\nread_unlock(&local->sockets.lock);\r\nif (llcp_sock == NULL)\r\nreturn NULL;\r\nsock_hold(&llcp_sock->sk);\r\nreturn llcp_sock;\r\n}\r\nstatic void nfc_llcp_sock_put(struct nfc_llcp_sock *sock)\r\n{\r\nsock_put(&sock->sk);\r\n}\r\nstatic void nfc_llcp_timeout_work(struct work_struct *work)\r\n{\r\nstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\r\ntimeout_work);\r\nnfc_dep_link_down(local->dev);\r\n}\r\nstatic void nfc_llcp_symm_timer(unsigned long data)\r\n{\r\nstruct nfc_llcp_local *local = (struct nfc_llcp_local *) data;\r\npr_err("SYMM timeout\n");\r\nschedule_work(&local->timeout_work);\r\n}\r\nstatic void nfc_llcp_sdreq_timeout_work(struct work_struct *work)\r\n{\r\nunsigned long time;\r\nHLIST_HEAD(nl_sdres_list);\r\nstruct hlist_node *n;\r\nstruct nfc_llcp_sdp_tlv *sdp;\r\nstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\r\nsdreq_timeout_work);\r\nmutex_lock(&local->sdreq_lock);\r\ntime = jiffies - msecs_to_jiffies(3 * local->remote_lto);\r\nhlist_for_each_entry_safe(sdp, n, &local->pending_sdreqs, node) {\r\nif (time_after(sdp->time, time))\r\ncontinue;\r\nsdp->sap = LLCP_SDP_UNBOUND;\r\nhlist_del(&sdp->node);\r\nhlist_add_head(&sdp->node, &nl_sdres_list);\r\n}\r\nif (!hlist_empty(&local->pending_sdreqs))\r\nmod_timer(&local->sdreq_timer,\r\njiffies + msecs_to_jiffies(3 * local->remote_lto));\r\nmutex_unlock(&local->sdreq_lock);\r\nif (!hlist_empty(&nl_sdres_list))\r\nnfc_genl_llc_send_sdres(local->dev, &nl_sdres_list);\r\n}\r\nstatic void nfc_llcp_sdreq_timer(unsigned long data)\r\n{\r\nstruct nfc_llcp_local *local = (struct nfc_llcp_local *) data;\r\nschedule_work(&local->sdreq_timeout_work);\r\n}\r\nstruct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev)\r\n{\r\nstruct nfc_llcp_local *local;\r\nlist_for_each_entry(local, &llcp_devices, list)\r\nif (local->dev == dev)\r\nreturn local;\r\npr_debug("No device found\n");\r\nreturn NULL;\r\n}\r\nstatic int nfc_llcp_wks_sap(char *service_name, size_t service_name_len)\r\n{\r\nint sap, num_wks;\r\npr_debug("%s\n", service_name);\r\nif (service_name == NULL)\r\nreturn -EINVAL;\r\nnum_wks = ARRAY_SIZE(wks);\r\nfor (sap = 0; sap < num_wks; sap++) {\r\nif (wks[sap] == NULL)\r\ncontinue;\r\nif (strncmp(wks[sap], service_name, service_name_len) == 0)\r\nreturn sap;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic\r\nstruct nfc_llcp_sock *nfc_llcp_sock_from_sn(struct nfc_llcp_local *local,\r\nu8 *sn, size_t sn_len)\r\n{\r\nstruct sock *sk;\r\nstruct nfc_llcp_sock *llcp_sock, *tmp_sock;\r\npr_debug("sn %zd %p\n", sn_len, sn);\r\nif (sn == NULL || sn_len == 0)\r\nreturn NULL;\r\nread_lock(&local->sockets.lock);\r\nllcp_sock = NULL;\r\nsk_for_each(sk, &local->sockets.head) {\r\ntmp_sock = nfc_llcp_sock(sk);\r\npr_debug("llcp sock %p\n", tmp_sock);\r\nif (tmp_sock->sk.sk_type == SOCK_STREAM &&\r\ntmp_sock->sk.sk_state != LLCP_LISTEN)\r\ncontinue;\r\nif (tmp_sock->sk.sk_type == SOCK_DGRAM &&\r\ntmp_sock->sk.sk_state != LLCP_BOUND)\r\ncontinue;\r\nif (tmp_sock->service_name == NULL ||\r\ntmp_sock->service_name_len == 0)\r\ncontinue;\r\nif (tmp_sock->service_name_len != sn_len)\r\ncontinue;\r\nif (memcmp(sn, tmp_sock->service_name, sn_len) == 0) {\r\nllcp_sock = tmp_sock;\r\nbreak;\r\n}\r\n}\r\nread_unlock(&local->sockets.lock);\r\npr_debug("Found llcp sock %p\n", llcp_sock);\r\nreturn llcp_sock;\r\n}\r\nu8 nfc_llcp_get_sdp_ssap(struct nfc_llcp_local *local,\r\nstruct nfc_llcp_sock *sock)\r\n{\r\nmutex_lock(&local->sdp_lock);\r\nif (sock->service_name != NULL && sock->service_name_len > 0) {\r\nint ssap = nfc_llcp_wks_sap(sock->service_name,\r\nsock->service_name_len);\r\nif (ssap > 0) {\r\npr_debug("WKS %d\n", ssap);\r\nif (local->local_wks & BIT(ssap)) {\r\nmutex_unlock(&local->sdp_lock);\r\nreturn LLCP_SAP_MAX;\r\n}\r\nset_bit(ssap, &local->local_wks);\r\nmutex_unlock(&local->sdp_lock);\r\nreturn ssap;\r\n}\r\nif (nfc_llcp_sock_from_sn(local, sock->service_name,\r\nsock->service_name_len) != NULL) {\r\nmutex_unlock(&local->sdp_lock);\r\nreturn LLCP_SAP_MAX;\r\n}\r\nmutex_unlock(&local->sdp_lock);\r\nreturn LLCP_SDP_UNBOUND;\r\n} else if (sock->ssap != 0 && sock->ssap < LLCP_WKS_NUM_SAP) {\r\nif (!test_bit(sock->ssap, &local->local_wks)) {\r\nset_bit(sock->ssap, &local->local_wks);\r\nmutex_unlock(&local->sdp_lock);\r\nreturn sock->ssap;\r\n}\r\n}\r\nmutex_unlock(&local->sdp_lock);\r\nreturn LLCP_SAP_MAX;\r\n}\r\nu8 nfc_llcp_get_local_ssap(struct nfc_llcp_local *local)\r\n{\r\nu8 local_ssap;\r\nmutex_lock(&local->sdp_lock);\r\nlocal_ssap = find_first_zero_bit(&local->local_sap, LLCP_LOCAL_NUM_SAP);\r\nif (local_ssap == LLCP_LOCAL_NUM_SAP) {\r\nmutex_unlock(&local->sdp_lock);\r\nreturn LLCP_SAP_MAX;\r\n}\r\nset_bit(local_ssap, &local->local_sap);\r\nmutex_unlock(&local->sdp_lock);\r\nreturn local_ssap + LLCP_LOCAL_SAP_OFFSET;\r\n}\r\nvoid nfc_llcp_put_ssap(struct nfc_llcp_local *local, u8 ssap)\r\n{\r\nu8 local_ssap;\r\nunsigned long *sdp;\r\nif (ssap < LLCP_WKS_NUM_SAP) {\r\nlocal_ssap = ssap;\r\nsdp = &local->local_wks;\r\n} else if (ssap < LLCP_LOCAL_NUM_SAP) {\r\natomic_t *client_cnt;\r\nlocal_ssap = ssap - LLCP_WKS_NUM_SAP;\r\nsdp = &local->local_sdp;\r\nclient_cnt = &local->local_sdp_cnt[local_ssap];\r\npr_debug("%d clients\n", atomic_read(client_cnt));\r\nmutex_lock(&local->sdp_lock);\r\nif (atomic_dec_and_test(client_cnt)) {\r\nstruct nfc_llcp_sock *l_sock;\r\npr_debug("No more clients for SAP %d\n", ssap);\r\nclear_bit(local_ssap, sdp);\r\nl_sock = nfc_llcp_sock_get(local, ssap, LLCP_SAP_SDP);\r\nif (l_sock) {\r\nl_sock->ssap = LLCP_SDP_UNBOUND;\r\nnfc_llcp_sock_put(l_sock);\r\n}\r\n}\r\nmutex_unlock(&local->sdp_lock);\r\nreturn;\r\n} else if (ssap < LLCP_MAX_SAP) {\r\nlocal_ssap = ssap - LLCP_LOCAL_NUM_SAP;\r\nsdp = &local->local_sap;\r\n} else {\r\nreturn;\r\n}\r\nmutex_lock(&local->sdp_lock);\r\nclear_bit(local_ssap, sdp);\r\nmutex_unlock(&local->sdp_lock);\r\n}\r\nstatic u8 nfc_llcp_reserve_sdp_ssap(struct nfc_llcp_local *local)\r\n{\r\nu8 ssap;\r\nmutex_lock(&local->sdp_lock);\r\nssap = find_first_zero_bit(&local->local_sdp, LLCP_SDP_NUM_SAP);\r\nif (ssap == LLCP_SDP_NUM_SAP) {\r\nmutex_unlock(&local->sdp_lock);\r\nreturn LLCP_SAP_MAX;\r\n}\r\npr_debug("SDP ssap %d\n", LLCP_WKS_NUM_SAP + ssap);\r\nset_bit(ssap, &local->local_sdp);\r\nmutex_unlock(&local->sdp_lock);\r\nreturn LLCP_WKS_NUM_SAP + ssap;\r\n}\r\nstatic int nfc_llcp_build_gb(struct nfc_llcp_local *local)\r\n{\r\nu8 *gb_cur, *version_tlv, version, version_length;\r\nu8 *lto_tlv, lto_length;\r\nu8 *wks_tlv, wks_length;\r\nu8 *miux_tlv, miux_length;\r\n__be16 wks = cpu_to_be16(local->local_wks);\r\nu8 gb_len = 0;\r\nint ret = 0;\r\nversion = LLCP_VERSION_11;\r\nversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\r\n1, &version_length);\r\ngb_len += version_length;\r\nlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\r\ngb_len += lto_length;\r\npr_debug("Local wks 0x%lx\n", local->local_wks);\r\nwks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\r\ngb_len += wks_length;\r\nmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\r\n&miux_length);\r\ngb_len += miux_length;\r\ngb_len += ARRAY_SIZE(llcp_magic);\r\nif (gb_len > NFC_MAX_GT_LEN) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ngb_cur = local->gb;\r\nmemcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));\r\ngb_cur += ARRAY_SIZE(llcp_magic);\r\nmemcpy(gb_cur, version_tlv, version_length);\r\ngb_cur += version_length;\r\nmemcpy(gb_cur, lto_tlv, lto_length);\r\ngb_cur += lto_length;\r\nmemcpy(gb_cur, wks_tlv, wks_length);\r\ngb_cur += wks_length;\r\nmemcpy(gb_cur, miux_tlv, miux_length);\r\ngb_cur += miux_length;\r\nlocal->gb_len = gb_len;\r\nout:\r\nkfree(version_tlv);\r\nkfree(lto_tlv);\r\nkfree(wks_tlv);\r\nkfree(miux_tlv);\r\nreturn ret;\r\n}\r\nu8 *nfc_llcp_general_bytes(struct nfc_dev *dev, size_t *general_bytes_len)\r\n{\r\nstruct nfc_llcp_local *local;\r\nlocal = nfc_llcp_find_local(dev);\r\nif (local == NULL) {\r\n*general_bytes_len = 0;\r\nreturn NULL;\r\n}\r\nnfc_llcp_build_gb(local);\r\n*general_bytes_len = local->gb_len;\r\nreturn local->gb;\r\n}\r\nint nfc_llcp_set_remote_gb(struct nfc_dev *dev, u8 *gb, u8 gb_len)\r\n{\r\nstruct nfc_llcp_local *local;\r\nif (gb_len < 3 || gb_len > NFC_MAX_GT_LEN)\r\nreturn -EINVAL;\r\nlocal = nfc_llcp_find_local(dev);\r\nif (local == NULL) {\r\npr_err("No LLCP device\n");\r\nreturn -ENODEV;\r\n}\r\nmemset(local->remote_gb, 0, NFC_MAX_GT_LEN);\r\nmemcpy(local->remote_gb, gb, gb_len);\r\nlocal->remote_gb_len = gb_len;\r\nif (memcmp(local->remote_gb, llcp_magic, 3)) {\r\npr_err("MAC does not support LLCP\n");\r\nreturn -EINVAL;\r\n}\r\nreturn nfc_llcp_parse_gb_tlv(local,\r\n&local->remote_gb[3],\r\nlocal->remote_gb_len - 3);\r\n}\r\nstatic u8 nfc_llcp_dsap(struct sk_buff *pdu)\r\n{\r\nreturn (pdu->data[0] & 0xfc) >> 2;\r\n}\r\nstatic u8 nfc_llcp_ptype(struct sk_buff *pdu)\r\n{\r\nreturn ((pdu->data[0] & 0x03) << 2) | ((pdu->data[1] & 0xc0) >> 6);\r\n}\r\nstatic u8 nfc_llcp_ssap(struct sk_buff *pdu)\r\n{\r\nreturn pdu->data[1] & 0x3f;\r\n}\r\nstatic u8 nfc_llcp_ns(struct sk_buff *pdu)\r\n{\r\nreturn pdu->data[2] >> 4;\r\n}\r\nstatic u8 nfc_llcp_nr(struct sk_buff *pdu)\r\n{\r\nreturn pdu->data[2] & 0xf;\r\n}\r\nstatic void nfc_llcp_set_nrns(struct nfc_llcp_sock *sock, struct sk_buff *pdu)\r\n{\r\npdu->data[2] = (sock->send_n << 4) | (sock->recv_n);\r\nsock->send_n = (sock->send_n + 1) % 16;\r\nsock->recv_ack_n = (sock->recv_n - 1) % 16;\r\n}\r\nvoid nfc_llcp_send_to_raw_sock(struct nfc_llcp_local *local,\r\nstruct sk_buff *skb, u8 direction)\r\n{\r\nstruct sk_buff *skb_copy = NULL, *nskb;\r\nstruct sock *sk;\r\nu8 *data;\r\nread_lock(&local->raw_sockets.lock);\r\nsk_for_each(sk, &local->raw_sockets.head) {\r\nif (sk->sk_state != LLCP_BOUND)\r\ncontinue;\r\nif (skb_copy == NULL) {\r\nskb_copy = __pskb_copy_fclone(skb, NFC_RAW_HEADER_SIZE,\r\nGFP_ATOMIC, true);\r\nif (skb_copy == NULL)\r\ncontinue;\r\ndata = skb_push(skb_copy, NFC_RAW_HEADER_SIZE);\r\ndata[0] = local->dev ? local->dev->idx : 0xFF;\r\ndata[1] = direction & 0x01;\r\ndata[1] |= (RAW_PAYLOAD_LLCP << 1);\r\n}\r\nnskb = skb_clone(skb_copy, GFP_ATOMIC);\r\nif (!nskb)\r\ncontinue;\r\nif (sock_queue_rcv_skb(sk, nskb))\r\nkfree_skb(nskb);\r\n}\r\nread_unlock(&local->raw_sockets.lock);\r\nkfree_skb(skb_copy);\r\n}\r\nstatic void nfc_llcp_tx_work(struct work_struct *work)\r\n{\r\nstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\r\ntx_work);\r\nstruct sk_buff *skb;\r\nstruct sock *sk;\r\nstruct nfc_llcp_sock *llcp_sock;\r\nskb = skb_dequeue(&local->tx_queue);\r\nif (skb != NULL) {\r\nsk = skb->sk;\r\nllcp_sock = nfc_llcp_sock(sk);\r\nif (llcp_sock == NULL && nfc_llcp_ptype(skb) == LLCP_PDU_I) {\r\nkfree_skb(skb);\r\nnfc_llcp_send_symm(local->dev);\r\n} else if (llcp_sock && !llcp_sock->remote_ready) {\r\nskb_queue_head(&local->tx_queue, skb);\r\nnfc_llcp_send_symm(local->dev);\r\n} else {\r\nstruct sk_buff *copy_skb = NULL;\r\nu8 ptype = nfc_llcp_ptype(skb);\r\nint ret;\r\npr_debug("Sending pending skb\n");\r\nprint_hex_dump(KERN_DEBUG, "LLCP Tx: ",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\nskb->data, skb->len, true);\r\nif (ptype == LLCP_PDU_DISC && sk != NULL &&\r\nsk->sk_state == LLCP_DISCONNECTING) {\r\nnfc_llcp_sock_unlink(&local->sockets, sk);\r\nsock_orphan(sk);\r\nsock_put(sk);\r\n}\r\nif (ptype == LLCP_PDU_I)\r\ncopy_skb = skb_copy(skb, GFP_ATOMIC);\r\n__net_timestamp(skb);\r\nnfc_llcp_send_to_raw_sock(local, skb,\r\nNFC_DIRECTION_TX);\r\nret = nfc_data_exchange(local->dev, local->target_idx,\r\nskb, nfc_llcp_recv, local);\r\nif (ret) {\r\nkfree_skb(copy_skb);\r\ngoto out;\r\n}\r\nif (ptype == LLCP_PDU_I && copy_skb)\r\nskb_queue_tail(&llcp_sock->tx_pending_queue,\r\ncopy_skb);\r\n}\r\n} else {\r\nnfc_llcp_send_symm(local->dev);\r\n}\r\nout:\r\nmod_timer(&local->link_timer,\r\njiffies + msecs_to_jiffies(2 * local->remote_lto));\r\n}\r\nstatic struct nfc_llcp_sock *nfc_llcp_connecting_sock_get(struct nfc_llcp_local *local,\r\nu8 ssap)\r\n{\r\nstruct sock *sk;\r\nstruct nfc_llcp_sock *llcp_sock;\r\nread_lock(&local->connecting_sockets.lock);\r\nsk_for_each(sk, &local->connecting_sockets.head) {\r\nllcp_sock = nfc_llcp_sock(sk);\r\nif (llcp_sock->ssap == ssap) {\r\nsock_hold(&llcp_sock->sk);\r\ngoto out;\r\n}\r\n}\r\nllcp_sock = NULL;\r\nout:\r\nread_unlock(&local->connecting_sockets.lock);\r\nreturn llcp_sock;\r\n}\r\nstatic struct nfc_llcp_sock *nfc_llcp_sock_get_sn(struct nfc_llcp_local *local,\r\nu8 *sn, size_t sn_len)\r\n{\r\nstruct nfc_llcp_sock *llcp_sock;\r\nllcp_sock = nfc_llcp_sock_from_sn(local, sn, sn_len);\r\nif (llcp_sock == NULL)\r\nreturn NULL;\r\nsock_hold(&llcp_sock->sk);\r\nreturn llcp_sock;\r\n}\r\nstatic u8 *nfc_llcp_connect_sn(struct sk_buff *skb, size_t *sn_len)\r\n{\r\nu8 *tlv = &skb->data[2], type, length;\r\nsize_t tlv_array_len = skb->len - LLCP_HEADER_SIZE, offset = 0;\r\nwhile (offset < tlv_array_len) {\r\ntype = tlv[0];\r\nlength = tlv[1];\r\npr_debug("type 0x%x length %d\n", type, length);\r\nif (type == LLCP_TLV_SN) {\r\n*sn_len = length;\r\nreturn &tlv[2];\r\n}\r\noffset += length + 2;\r\ntlv += length + 2;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void nfc_llcp_recv_ui(struct nfc_llcp_local *local,\r\nstruct sk_buff *skb)\r\n{\r\nstruct nfc_llcp_sock *llcp_sock;\r\nstruct nfc_llcp_ui_cb *ui_cb;\r\nu8 dsap, ssap;\r\ndsap = nfc_llcp_dsap(skb);\r\nssap = nfc_llcp_ssap(skb);\r\nui_cb = nfc_llcp_ui_skb_cb(skb);\r\nui_cb->dsap = dsap;\r\nui_cb->ssap = ssap;\r\npr_debug("%d %d\n", dsap, ssap);\r\nllcp_sock = nfc_llcp_sock_get(local, dsap, LLCP_SAP_SDP);\r\nif (llcp_sock == NULL || llcp_sock->sk.sk_type != SOCK_DGRAM)\r\nreturn;\r\nskb_pull(skb, LLCP_HEADER_SIZE);\r\nif (!sock_queue_rcv_skb(&llcp_sock->sk, skb)) {\r\nskb_get(skb);\r\n} else {\r\npr_err("Receive queue is full\n");\r\n}\r\nnfc_llcp_sock_put(llcp_sock);\r\n}\r\nstatic void nfc_llcp_recv_connect(struct nfc_llcp_local *local,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sock *new_sk, *parent;\r\nstruct nfc_llcp_sock *sock, *new_sock;\r\nu8 dsap, ssap, reason;\r\ndsap = nfc_llcp_dsap(skb);\r\nssap = nfc_llcp_ssap(skb);\r\npr_debug("%d %d\n", dsap, ssap);\r\nif (dsap != LLCP_SAP_SDP) {\r\nsock = nfc_llcp_sock_get(local, dsap, LLCP_SAP_SDP);\r\nif (sock == NULL || sock->sk.sk_state != LLCP_LISTEN) {\r\nreason = LLCP_DM_NOBOUND;\r\ngoto fail;\r\n}\r\n} else {\r\nu8 *sn;\r\nsize_t sn_len;\r\nsn = nfc_llcp_connect_sn(skb, &sn_len);\r\nif (sn == NULL) {\r\nreason = LLCP_DM_NOBOUND;\r\ngoto fail;\r\n}\r\npr_debug("Service name length %zu\n", sn_len);\r\nsock = nfc_llcp_sock_get_sn(local, sn, sn_len);\r\nif (sock == NULL) {\r\nreason = LLCP_DM_NOBOUND;\r\ngoto fail;\r\n}\r\n}\r\nlock_sock(&sock->sk);\r\nparent = &sock->sk;\r\nif (sk_acceptq_is_full(parent)) {\r\nreason = LLCP_DM_REJ;\r\nrelease_sock(&sock->sk);\r\nsock_put(&sock->sk);\r\ngoto fail;\r\n}\r\nif (sock->ssap == LLCP_SDP_UNBOUND) {\r\nu8 ssap = nfc_llcp_reserve_sdp_ssap(local);\r\npr_debug("First client, reserving %d\n", ssap);\r\nif (ssap == LLCP_SAP_MAX) {\r\nreason = LLCP_DM_REJ;\r\nrelease_sock(&sock->sk);\r\nsock_put(&sock->sk);\r\ngoto fail;\r\n}\r\nsock->ssap = ssap;\r\n}\r\nnew_sk = nfc_llcp_sock_alloc(NULL, parent->sk_type, GFP_ATOMIC);\r\nif (new_sk == NULL) {\r\nreason = LLCP_DM_REJ;\r\nrelease_sock(&sock->sk);\r\nsock_put(&sock->sk);\r\ngoto fail;\r\n}\r\nnew_sock = nfc_llcp_sock(new_sk);\r\nnew_sock->dev = local->dev;\r\nnew_sock->local = nfc_llcp_local_get(local);\r\nnew_sock->rw = sock->rw;\r\nnew_sock->miux = sock->miux;\r\nnew_sock->nfc_protocol = sock->nfc_protocol;\r\nnew_sock->dsap = ssap;\r\nnew_sock->target_idx = local->target_idx;\r\nnew_sock->parent = parent;\r\nnew_sock->ssap = sock->ssap;\r\nif (sock->ssap < LLCP_LOCAL_NUM_SAP && sock->ssap >= LLCP_WKS_NUM_SAP) {\r\natomic_t *client_count;\r\npr_debug("reserved_ssap %d for %p\n", sock->ssap, new_sock);\r\nclient_count =\r\n&local->local_sdp_cnt[sock->ssap - LLCP_WKS_NUM_SAP];\r\natomic_inc(client_count);\r\nnew_sock->reserved_ssap = sock->ssap;\r\n}\r\nnfc_llcp_parse_connection_tlv(new_sock, &skb->data[LLCP_HEADER_SIZE],\r\nskb->len - LLCP_HEADER_SIZE);\r\npr_debug("new sock %p sk %p\n", new_sock, &new_sock->sk);\r\nnfc_llcp_sock_link(&local->sockets, new_sk);\r\nnfc_llcp_accept_enqueue(&sock->sk, new_sk);\r\nnfc_get_device(local->dev->idx);\r\nnew_sk->sk_state = LLCP_CONNECTED;\r\nparent->sk_data_ready(parent);\r\nnfc_llcp_send_cc(new_sock);\r\nrelease_sock(&sock->sk);\r\nsock_put(&sock->sk);\r\nreturn;\r\nfail:\r\nnfc_llcp_send_dm(local, dsap, ssap, reason);\r\n}\r\nint nfc_llcp_queue_i_frames(struct nfc_llcp_sock *sock)\r\n{\r\nint nr_frames = 0;\r\nstruct nfc_llcp_local *local = sock->local;\r\npr_debug("Remote ready %d tx queue len %d remote rw %d",\r\nsock->remote_ready, skb_queue_len(&sock->tx_pending_queue),\r\nsock->remote_rw);\r\nwhile (sock->remote_ready &&\r\nskb_queue_len(&sock->tx_pending_queue) < sock->remote_rw) {\r\nstruct sk_buff *pdu;\r\npdu = skb_dequeue(&sock->tx_queue);\r\nif (pdu == NULL)\r\nbreak;\r\nnfc_llcp_set_nrns(sock, pdu);\r\nskb_queue_tail(&local->tx_queue, pdu);\r\nnr_frames++;\r\n}\r\nreturn nr_frames;\r\n}\r\nstatic void nfc_llcp_recv_hdlc(struct nfc_llcp_local *local,\r\nstruct sk_buff *skb)\r\n{\r\nstruct nfc_llcp_sock *llcp_sock;\r\nstruct sock *sk;\r\nu8 dsap, ssap, ptype, ns, nr;\r\nptype = nfc_llcp_ptype(skb);\r\ndsap = nfc_llcp_dsap(skb);\r\nssap = nfc_llcp_ssap(skb);\r\nns = nfc_llcp_ns(skb);\r\nnr = nfc_llcp_nr(skb);\r\npr_debug("%d %d R %d S %d\n", dsap, ssap, nr, ns);\r\nllcp_sock = nfc_llcp_sock_get(local, dsap, ssap);\r\nif (llcp_sock == NULL) {\r\nnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\r\nreturn;\r\n}\r\nsk = &llcp_sock->sk;\r\nlock_sock(sk);\r\nif (sk->sk_state == LLCP_CLOSED) {\r\nrelease_sock(sk);\r\nnfc_llcp_sock_put(llcp_sock);\r\n}\r\nif (ptype == LLCP_PDU_I) {\r\npr_debug("I frame, queueing on %p\n", &llcp_sock->sk);\r\nif (ns == llcp_sock->recv_n)\r\nllcp_sock->recv_n = (llcp_sock->recv_n + 1) % 16;\r\nelse\r\npr_err("Received out of sequence I PDU\n");\r\nskb_pull(skb, LLCP_HEADER_SIZE + LLCP_SEQUENCE_SIZE);\r\nif (!sock_queue_rcv_skb(&llcp_sock->sk, skb)) {\r\nskb_get(skb);\r\n} else {\r\npr_err("Receive queue is full\n");\r\n}\r\n}\r\nif (llcp_sock->send_ack_n != nr) {\r\nstruct sk_buff *s, *tmp;\r\nu8 n;\r\nllcp_sock->send_ack_n = nr;\r\nskb_queue_walk_safe(&llcp_sock->tx_pending_queue, s, tmp) {\r\nn = nfc_llcp_ns(s);\r\nskb_unlink(s, &llcp_sock->tx_pending_queue);\r\nkfree_skb(s);\r\nif (n == nr)\r\nbreak;\r\n}\r\nskb_queue_reverse_walk_safe(&llcp_sock->tx_pending_queue,\r\ns, tmp) {\r\nskb_unlink(s, &llcp_sock->tx_pending_queue);\r\nskb_queue_head(&local->tx_queue, s);\r\n}\r\n}\r\nif (ptype == LLCP_PDU_RR)\r\nllcp_sock->remote_ready = true;\r\nelse if (ptype == LLCP_PDU_RNR)\r\nllcp_sock->remote_ready = false;\r\nif (nfc_llcp_queue_i_frames(llcp_sock) == 0 && ptype == LLCP_PDU_I)\r\nnfc_llcp_send_rr(llcp_sock);\r\nrelease_sock(sk);\r\nnfc_llcp_sock_put(llcp_sock);\r\n}\r\nstatic void nfc_llcp_recv_disc(struct nfc_llcp_local *local,\r\nstruct sk_buff *skb)\r\n{\r\nstruct nfc_llcp_sock *llcp_sock;\r\nstruct sock *sk;\r\nu8 dsap, ssap;\r\ndsap = nfc_llcp_dsap(skb);\r\nssap = nfc_llcp_ssap(skb);\r\nif ((dsap == 0) && (ssap == 0)) {\r\npr_debug("Connection termination");\r\nnfc_dep_link_down(local->dev);\r\nreturn;\r\n}\r\nllcp_sock = nfc_llcp_sock_get(local, dsap, ssap);\r\nif (llcp_sock == NULL) {\r\nnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\r\nreturn;\r\n}\r\nsk = &llcp_sock->sk;\r\nlock_sock(sk);\r\nnfc_llcp_socket_purge(llcp_sock);\r\nif (sk->sk_state == LLCP_CLOSED) {\r\nrelease_sock(sk);\r\nnfc_llcp_sock_put(llcp_sock);\r\n}\r\nif (sk->sk_state == LLCP_CONNECTED) {\r\nnfc_put_device(local->dev);\r\nsk->sk_state = LLCP_CLOSED;\r\nsk->sk_state_change(sk);\r\n}\r\nnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_DISC);\r\nrelease_sock(sk);\r\nnfc_llcp_sock_put(llcp_sock);\r\n}\r\nstatic void nfc_llcp_recv_cc(struct nfc_llcp_local *local, struct sk_buff *skb)\r\n{\r\nstruct nfc_llcp_sock *llcp_sock;\r\nstruct sock *sk;\r\nu8 dsap, ssap;\r\ndsap = nfc_llcp_dsap(skb);\r\nssap = nfc_llcp_ssap(skb);\r\nllcp_sock = nfc_llcp_connecting_sock_get(local, dsap);\r\nif (llcp_sock == NULL) {\r\npr_err("Invalid CC\n");\r\nnfc_llcp_send_dm(local, dsap, ssap, LLCP_DM_NOCONN);\r\nreturn;\r\n}\r\nsk = &llcp_sock->sk;\r\nnfc_llcp_sock_unlink(&local->connecting_sockets, sk);\r\nnfc_llcp_sock_link(&local->sockets, sk);\r\nllcp_sock->dsap = ssap;\r\nnfc_llcp_parse_connection_tlv(llcp_sock, &skb->data[LLCP_HEADER_SIZE],\r\nskb->len - LLCP_HEADER_SIZE);\r\nsk->sk_state = LLCP_CONNECTED;\r\nsk->sk_state_change(sk);\r\nnfc_llcp_sock_put(llcp_sock);\r\n}\r\nstatic void nfc_llcp_recv_dm(struct nfc_llcp_local *local, struct sk_buff *skb)\r\n{\r\nstruct nfc_llcp_sock *llcp_sock;\r\nstruct sock *sk;\r\nu8 dsap, ssap, reason;\r\ndsap = nfc_llcp_dsap(skb);\r\nssap = nfc_llcp_ssap(skb);\r\nreason = skb->data[2];\r\npr_debug("%d %d reason %d\n", ssap, dsap, reason);\r\nswitch (reason) {\r\ncase LLCP_DM_NOBOUND:\r\ncase LLCP_DM_REJ:\r\nllcp_sock = nfc_llcp_connecting_sock_get(local, dsap);\r\nbreak;\r\ndefault:\r\nllcp_sock = nfc_llcp_sock_get(local, dsap, ssap);\r\nbreak;\r\n}\r\nif (llcp_sock == NULL) {\r\npr_debug("Already closed\n");\r\nreturn;\r\n}\r\nsk = &llcp_sock->sk;\r\nsk->sk_err = ENXIO;\r\nsk->sk_state = LLCP_CLOSED;\r\nsk->sk_state_change(sk);\r\nnfc_llcp_sock_put(llcp_sock);\r\n}\r\nstatic void nfc_llcp_recv_snl(struct nfc_llcp_local *local,\r\nstruct sk_buff *skb)\r\n{\r\nstruct nfc_llcp_sock *llcp_sock;\r\nu8 dsap, ssap, *tlv, type, length, tid, sap;\r\nu16 tlv_len, offset;\r\nchar *service_name;\r\nsize_t service_name_len;\r\nstruct nfc_llcp_sdp_tlv *sdp;\r\nHLIST_HEAD(llc_sdres_list);\r\nsize_t sdres_tlvs_len;\r\nHLIST_HEAD(nl_sdres_list);\r\ndsap = nfc_llcp_dsap(skb);\r\nssap = nfc_llcp_ssap(skb);\r\npr_debug("%d %d\n", dsap, ssap);\r\nif (dsap != LLCP_SAP_SDP || ssap != LLCP_SAP_SDP) {\r\npr_err("Wrong SNL SAP\n");\r\nreturn;\r\n}\r\ntlv = &skb->data[LLCP_HEADER_SIZE];\r\ntlv_len = skb->len - LLCP_HEADER_SIZE;\r\noffset = 0;\r\nsdres_tlvs_len = 0;\r\nwhile (offset < tlv_len) {\r\ntype = tlv[0];\r\nlength = tlv[1];\r\nswitch (type) {\r\ncase LLCP_TLV_SDREQ:\r\ntid = tlv[2];\r\nservice_name = (char *) &tlv[3];\r\nservice_name_len = length - 1;\r\npr_debug("Looking for %.16s\n", service_name);\r\nif (service_name_len == strlen("urn:nfc:sn:sdp") &&\r\n!strncmp(service_name, "urn:nfc:sn:sdp",\r\nservice_name_len)) {\r\nsap = 1;\r\ngoto add_snl;\r\n}\r\nllcp_sock = nfc_llcp_sock_from_sn(local, service_name,\r\nservice_name_len);\r\nif (!llcp_sock) {\r\nsap = 0;\r\ngoto add_snl;\r\n}\r\nif (llcp_sock->ssap == LLCP_SDP_UNBOUND) {\r\natomic_t *client_count;\r\nsap = nfc_llcp_reserve_sdp_ssap(local);\r\npr_debug("Reserving %d\n", sap);\r\nif (sap == LLCP_SAP_MAX) {\r\nsap = 0;\r\ngoto add_snl;\r\n}\r\nclient_count =\r\n&local->local_sdp_cnt[sap -\r\nLLCP_WKS_NUM_SAP];\r\natomic_inc(client_count);\r\nllcp_sock->ssap = sap;\r\nllcp_sock->reserved_ssap = sap;\r\n} else {\r\nsap = llcp_sock->ssap;\r\n}\r\npr_debug("%p %d\n", llcp_sock, sap);\r\nadd_snl:\r\nsdp = nfc_llcp_build_sdres_tlv(tid, sap);\r\nif (sdp == NULL)\r\ngoto exit;\r\nsdres_tlvs_len += sdp->tlv_len;\r\nhlist_add_head(&sdp->node, &llc_sdres_list);\r\nbreak;\r\ncase LLCP_TLV_SDRES:\r\nmutex_lock(&local->sdreq_lock);\r\npr_debug("LLCP_TLV_SDRES: searching tid %d\n", tlv[2]);\r\nhlist_for_each_entry(sdp, &local->pending_sdreqs, node) {\r\nif (sdp->tid != tlv[2])\r\ncontinue;\r\nsdp->sap = tlv[3];\r\npr_debug("Found: uri=%s, sap=%d\n",\r\nsdp->uri, sdp->sap);\r\nhlist_del(&sdp->node);\r\nhlist_add_head(&sdp->node, &nl_sdres_list);\r\nbreak;\r\n}\r\nmutex_unlock(&local->sdreq_lock);\r\nbreak;\r\ndefault:\r\npr_err("Invalid SNL tlv value 0x%x\n", type);\r\nbreak;\r\n}\r\noffset += length + 2;\r\ntlv += length + 2;\r\n}\r\nexit:\r\nif (!hlist_empty(&nl_sdres_list))\r\nnfc_genl_llc_send_sdres(local->dev, &nl_sdres_list);\r\nif (!hlist_empty(&llc_sdres_list))\r\nnfc_llcp_send_snl_sdres(local, &llc_sdres_list, sdres_tlvs_len);\r\n}\r\nstatic void nfc_llcp_recv_agf(struct nfc_llcp_local *local, struct sk_buff *skb)\r\n{\r\nu8 ptype;\r\nu16 pdu_len;\r\nstruct sk_buff *new_skb;\r\nif (skb->len <= LLCP_HEADER_SIZE) {\r\npr_err("Malformed AGF PDU\n");\r\nreturn;\r\n}\r\nskb_pull(skb, LLCP_HEADER_SIZE);\r\nwhile (skb->len > LLCP_AGF_PDU_HEADER_SIZE) {\r\npdu_len = skb->data[0] << 8 | skb->data[1];\r\nskb_pull(skb, LLCP_AGF_PDU_HEADER_SIZE);\r\nif (pdu_len < LLCP_HEADER_SIZE || pdu_len > skb->len) {\r\npr_err("Malformed AGF PDU\n");\r\nreturn;\r\n}\r\nptype = nfc_llcp_ptype(skb);\r\nif (ptype == LLCP_PDU_SYMM || ptype == LLCP_PDU_AGF)\r\ngoto next;\r\nnew_skb = nfc_alloc_recv_skb(pdu_len, GFP_KERNEL);\r\nif (new_skb == NULL) {\r\npr_err("Could not allocate PDU\n");\r\nreturn;\r\n}\r\nmemcpy(skb_put(new_skb, pdu_len), skb->data, pdu_len);\r\nnfc_llcp_rx_skb(local, new_skb);\r\nkfree_skb(new_skb);\r\nnext:\r\nskb_pull(skb, pdu_len);\r\n}\r\n}\r\nstatic void nfc_llcp_rx_skb(struct nfc_llcp_local *local, struct sk_buff *skb)\r\n{\r\nu8 dsap, ssap, ptype;\r\nptype = nfc_llcp_ptype(skb);\r\ndsap = nfc_llcp_dsap(skb);\r\nssap = nfc_llcp_ssap(skb);\r\npr_debug("ptype 0x%x dsap 0x%x ssap 0x%x\n", ptype, dsap, ssap);\r\nif (ptype != LLCP_PDU_SYMM)\r\nprint_hex_dump(KERN_DEBUG, "LLCP Rx: ", DUMP_PREFIX_OFFSET,\r\n16, 1, skb->data, skb->len, true);\r\nswitch (ptype) {\r\ncase LLCP_PDU_SYMM:\r\npr_debug("SYMM\n");\r\nbreak;\r\ncase LLCP_PDU_UI:\r\npr_debug("UI\n");\r\nnfc_llcp_recv_ui(local, skb);\r\nbreak;\r\ncase LLCP_PDU_CONNECT:\r\npr_debug("CONNECT\n");\r\nnfc_llcp_recv_connect(local, skb);\r\nbreak;\r\ncase LLCP_PDU_DISC:\r\npr_debug("DISC\n");\r\nnfc_llcp_recv_disc(local, skb);\r\nbreak;\r\ncase LLCP_PDU_CC:\r\npr_debug("CC\n");\r\nnfc_llcp_recv_cc(local, skb);\r\nbreak;\r\ncase LLCP_PDU_DM:\r\npr_debug("DM\n");\r\nnfc_llcp_recv_dm(local, skb);\r\nbreak;\r\ncase LLCP_PDU_SNL:\r\npr_debug("SNL\n");\r\nnfc_llcp_recv_snl(local, skb);\r\nbreak;\r\ncase LLCP_PDU_I:\r\ncase LLCP_PDU_RR:\r\ncase LLCP_PDU_RNR:\r\npr_debug("I frame\n");\r\nnfc_llcp_recv_hdlc(local, skb);\r\nbreak;\r\ncase LLCP_PDU_AGF:\r\npr_debug("AGF frame\n");\r\nnfc_llcp_recv_agf(local, skb);\r\nbreak;\r\n}\r\n}\r\nstatic void nfc_llcp_rx_work(struct work_struct *work)\r\n{\r\nstruct nfc_llcp_local *local = container_of(work, struct nfc_llcp_local,\r\nrx_work);\r\nstruct sk_buff *skb;\r\nskb = local->rx_pending;\r\nif (skb == NULL) {\r\npr_debug("No pending SKB\n");\r\nreturn;\r\n}\r\n__net_timestamp(skb);\r\nnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_RX);\r\nnfc_llcp_rx_skb(local, skb);\r\nschedule_work(&local->tx_work);\r\nkfree_skb(local->rx_pending);\r\nlocal->rx_pending = NULL;\r\n}\r\nstatic void __nfc_llcp_recv(struct nfc_llcp_local *local, struct sk_buff *skb)\r\n{\r\nlocal->rx_pending = skb;\r\ndel_timer(&local->link_timer);\r\nschedule_work(&local->rx_work);\r\n}\r\nvoid nfc_llcp_recv(void *data, struct sk_buff *skb, int err)\r\n{\r\nstruct nfc_llcp_local *local = (struct nfc_llcp_local *) data;\r\npr_debug("Received an LLCP PDU\n");\r\nif (err < 0) {\r\npr_err("err %d\n", err);\r\nreturn;\r\n}\r\n__nfc_llcp_recv(local, skb);\r\n}\r\nint nfc_llcp_data_received(struct nfc_dev *dev, struct sk_buff *skb)\r\n{\r\nstruct nfc_llcp_local *local;\r\nlocal = nfc_llcp_find_local(dev);\r\nif (local == NULL) {\r\nkfree_skb(skb);\r\nreturn -ENODEV;\r\n}\r\n__nfc_llcp_recv(local, skb);\r\nreturn 0;\r\n}\r\nvoid nfc_llcp_mac_is_down(struct nfc_dev *dev)\r\n{\r\nstruct nfc_llcp_local *local;\r\nlocal = nfc_llcp_find_local(dev);\r\nif (local == NULL)\r\nreturn;\r\nlocal->remote_miu = LLCP_DEFAULT_MIU;\r\nlocal->remote_lto = LLCP_DEFAULT_LTO;\r\nnfc_llcp_socket_release(local, true, 0);\r\n}\r\nvoid nfc_llcp_mac_is_up(struct nfc_dev *dev, u32 target_idx,\r\nu8 comm_mode, u8 rf_mode)\r\n{\r\nstruct nfc_llcp_local *local;\r\npr_debug("rf mode %d\n", rf_mode);\r\nlocal = nfc_llcp_find_local(dev);\r\nif (local == NULL)\r\nreturn;\r\nlocal->target_idx = target_idx;\r\nlocal->comm_mode = comm_mode;\r\nlocal->rf_mode = rf_mode;\r\nif (rf_mode == NFC_RF_INITIATOR) {\r\npr_debug("Queueing Tx work\n");\r\nschedule_work(&local->tx_work);\r\n} else {\r\nmod_timer(&local->link_timer,\r\njiffies + msecs_to_jiffies(local->remote_lto));\r\n}\r\n}\r\nint nfc_llcp_register_device(struct nfc_dev *ndev)\r\n{\r\nstruct nfc_llcp_local *local;\r\nlocal = kzalloc(sizeof(struct nfc_llcp_local), GFP_KERNEL);\r\nif (local == NULL)\r\nreturn -ENOMEM;\r\nlocal->dev = ndev;\r\nINIT_LIST_HEAD(&local->list);\r\nkref_init(&local->ref);\r\nmutex_init(&local->sdp_lock);\r\ninit_timer(&local->link_timer);\r\nlocal->link_timer.data = (unsigned long) local;\r\nlocal->link_timer.function = nfc_llcp_symm_timer;\r\nskb_queue_head_init(&local->tx_queue);\r\nINIT_WORK(&local->tx_work, nfc_llcp_tx_work);\r\nlocal->rx_pending = NULL;\r\nINIT_WORK(&local->rx_work, nfc_llcp_rx_work);\r\nINIT_WORK(&local->timeout_work, nfc_llcp_timeout_work);\r\nrwlock_init(&local->sockets.lock);\r\nrwlock_init(&local->connecting_sockets.lock);\r\nrwlock_init(&local->raw_sockets.lock);\r\nlocal->lto = 150;\r\nlocal->rw = LLCP_MAX_RW;\r\nlocal->miux = cpu_to_be16(LLCP_MAX_MIUX);\r\nlocal->local_wks = 0x1;\r\nnfc_llcp_build_gb(local);\r\nlocal->remote_miu = LLCP_DEFAULT_MIU;\r\nlocal->remote_lto = LLCP_DEFAULT_LTO;\r\nmutex_init(&local->sdreq_lock);\r\nINIT_HLIST_HEAD(&local->pending_sdreqs);\r\ninit_timer(&local->sdreq_timer);\r\nlocal->sdreq_timer.data = (unsigned long) local;\r\nlocal->sdreq_timer.function = nfc_llcp_sdreq_timer;\r\nINIT_WORK(&local->sdreq_timeout_work, nfc_llcp_sdreq_timeout_work);\r\nlist_add(&local->list, &llcp_devices);\r\nreturn 0;\r\n}\r\nvoid nfc_llcp_unregister_device(struct nfc_dev *dev)\r\n{\r\nstruct nfc_llcp_local *local = nfc_llcp_find_local(dev);\r\nif (local == NULL) {\r\npr_debug("No such device\n");\r\nreturn;\r\n}\r\nlocal_cleanup(local);\r\nnfc_llcp_local_put(local);\r\n}\r\nint __init nfc_llcp_init(void)\r\n{\r\nreturn nfc_llcp_sock_init();\r\n}\r\nvoid nfc_llcp_exit(void)\r\n{\r\nnfc_llcp_sock_exit();\r\n}
