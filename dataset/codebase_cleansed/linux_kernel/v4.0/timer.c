static inline unsigned int tbase_get_deferrable(struct tvec_base *base)\r\n{\r\nreturn ((unsigned int)(unsigned long)base & TIMER_DEFERRABLE);\r\n}\r\nstatic inline unsigned int tbase_get_irqsafe(struct tvec_base *base)\r\n{\r\nreturn ((unsigned int)(unsigned long)base & TIMER_IRQSAFE);\r\n}\r\nstatic inline struct tvec_base *tbase_get_base(struct tvec_base *base)\r\n{\r\nreturn ((struct tvec_base *)((unsigned long)base & ~TIMER_FLAG_MASK));\r\n}\r\nstatic inline void\r\ntimer_set_base(struct timer_list *timer, struct tvec_base *new_base)\r\n{\r\nunsigned long flags = (unsigned long)timer->base & TIMER_FLAG_MASK;\r\ntimer->base = (struct tvec_base *)((unsigned long)(new_base) | flags);\r\n}\r\nstatic unsigned long round_jiffies_common(unsigned long j, int cpu,\r\nbool force_up)\r\n{\r\nint rem;\r\nunsigned long original = j;\r\nj += cpu * 3;\r\nrem = j % HZ;\r\nif (rem < HZ/4 && !force_up)\r\nj = j - rem;\r\nelse\r\nj = j - rem + HZ;\r\nj -= cpu * 3;\r\nreturn time_is_after_jiffies(j) ? j : original;\r\n}\r\nunsigned long __round_jiffies(unsigned long j, int cpu)\r\n{\r\nreturn round_jiffies_common(j, cpu, false);\r\n}\r\nunsigned long __round_jiffies_relative(unsigned long j, int cpu)\r\n{\r\nunsigned long j0 = jiffies;\r\nreturn round_jiffies_common(j + j0, cpu, false) - j0;\r\n}\r\nunsigned long round_jiffies(unsigned long j)\r\n{\r\nreturn round_jiffies_common(j, raw_smp_processor_id(), false);\r\n}\r\nunsigned long round_jiffies_relative(unsigned long j)\r\n{\r\nreturn __round_jiffies_relative(j, raw_smp_processor_id());\r\n}\r\nunsigned long __round_jiffies_up(unsigned long j, int cpu)\r\n{\r\nreturn round_jiffies_common(j, cpu, true);\r\n}\r\nunsigned long __round_jiffies_up_relative(unsigned long j, int cpu)\r\n{\r\nunsigned long j0 = jiffies;\r\nreturn round_jiffies_common(j + j0, cpu, true) - j0;\r\n}\r\nunsigned long round_jiffies_up(unsigned long j)\r\n{\r\nreturn round_jiffies_common(j, raw_smp_processor_id(), true);\r\n}\r\nunsigned long round_jiffies_up_relative(unsigned long j)\r\n{\r\nreturn __round_jiffies_up_relative(j, raw_smp_processor_id());\r\n}\r\nvoid set_timer_slack(struct timer_list *timer, int slack_hz)\r\n{\r\ntimer->slack = slack_hz;\r\n}\r\nstatic bool catchup_timer_jiffies(struct tvec_base *base)\r\n{\r\nif (!base->all_timers) {\r\nbase->timer_jiffies = jiffies;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void\r\n__internal_add_timer(struct tvec_base *base, struct timer_list *timer)\r\n{\r\nunsigned long expires = timer->expires;\r\nunsigned long idx = expires - base->timer_jiffies;\r\nstruct list_head *vec;\r\nif (idx < TVR_SIZE) {\r\nint i = expires & TVR_MASK;\r\nvec = base->tv1.vec + i;\r\n} else if (idx < 1 << (TVR_BITS + TVN_BITS)) {\r\nint i = (expires >> TVR_BITS) & TVN_MASK;\r\nvec = base->tv2.vec + i;\r\n} else if (idx < 1 << (TVR_BITS + 2 * TVN_BITS)) {\r\nint i = (expires >> (TVR_BITS + TVN_BITS)) & TVN_MASK;\r\nvec = base->tv3.vec + i;\r\n} else if (idx < 1 << (TVR_BITS + 3 * TVN_BITS)) {\r\nint i = (expires >> (TVR_BITS + 2 * TVN_BITS)) & TVN_MASK;\r\nvec = base->tv4.vec + i;\r\n} else if ((signed long) idx < 0) {\r\nvec = base->tv1.vec + (base->timer_jiffies & TVR_MASK);\r\n} else {\r\nint i;\r\nif (idx > MAX_TVAL) {\r\nidx = MAX_TVAL;\r\nexpires = idx + base->timer_jiffies;\r\n}\r\ni = (expires >> (TVR_BITS + 3 * TVN_BITS)) & TVN_MASK;\r\nvec = base->tv5.vec + i;\r\n}\r\nlist_add_tail(&timer->entry, vec);\r\n}\r\nstatic void internal_add_timer(struct tvec_base *base, struct timer_list *timer)\r\n{\r\n(void)catchup_timer_jiffies(base);\r\n__internal_add_timer(base, timer);\r\nif (!tbase_get_deferrable(timer->base)) {\r\nif (!base->active_timers++ ||\r\ntime_before(timer->expires, base->next_timer))\r\nbase->next_timer = timer->expires;\r\n}\r\nbase->all_timers++;\r\nif (!tbase_get_deferrable(base) || tick_nohz_full_cpu(base->cpu))\r\nwake_up_nohz_cpu(base->cpu);\r\n}\r\nvoid __timer_stats_timer_set_start_info(struct timer_list *timer, void *addr)\r\n{\r\nif (timer->start_site)\r\nreturn;\r\ntimer->start_site = addr;\r\nmemcpy(timer->start_comm, current->comm, TASK_COMM_LEN);\r\ntimer->start_pid = current->pid;\r\n}\r\nstatic void timer_stats_account_timer(struct timer_list *timer)\r\n{\r\nunsigned int flag = 0;\r\nif (likely(!timer->start_site))\r\nreturn;\r\nif (unlikely(tbase_get_deferrable(timer->base)))\r\nflag |= TIMER_STATS_FLAG_DEFERRABLE;\r\ntimer_stats_update_stats(timer, timer->start_pid, timer->start_site,\r\ntimer->function, timer->start_comm, flag);\r\n}\r\nstatic void timer_stats_account_timer(struct timer_list *timer) {}\r\nstatic void *timer_debug_hint(void *addr)\r\n{\r\nreturn ((struct timer_list *) addr)->function;\r\n}\r\nstatic int timer_fixup_init(void *addr, enum debug_obj_state state)\r\n{\r\nstruct timer_list *timer = addr;\r\nswitch (state) {\r\ncase ODEBUG_STATE_ACTIVE:\r\ndel_timer_sync(timer);\r\ndebug_object_init(timer, &timer_debug_descr);\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void stub_timer(unsigned long data)\r\n{\r\nWARN_ON(1);\r\n}\r\nstatic int timer_fixup_activate(void *addr, enum debug_obj_state state)\r\n{\r\nstruct timer_list *timer = addr;\r\nswitch (state) {\r\ncase ODEBUG_STATE_NOTAVAILABLE:\r\nif (timer->entry.next == NULL &&\r\ntimer->entry.prev == TIMER_ENTRY_STATIC) {\r\ndebug_object_init(timer, &timer_debug_descr);\r\ndebug_object_activate(timer, &timer_debug_descr);\r\nreturn 0;\r\n} else {\r\nsetup_timer(timer, stub_timer, 0);\r\nreturn 1;\r\n}\r\nreturn 0;\r\ncase ODEBUG_STATE_ACTIVE:\r\nWARN_ON(1);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int timer_fixup_free(void *addr, enum debug_obj_state state)\r\n{\r\nstruct timer_list *timer = addr;\r\nswitch (state) {\r\ncase ODEBUG_STATE_ACTIVE:\r\ndel_timer_sync(timer);\r\ndebug_object_free(timer, &timer_debug_descr);\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int timer_fixup_assert_init(void *addr, enum debug_obj_state state)\r\n{\r\nstruct timer_list *timer = addr;\r\nswitch (state) {\r\ncase ODEBUG_STATE_NOTAVAILABLE:\r\nif (timer->entry.prev == TIMER_ENTRY_STATIC) {\r\ndebug_object_init(timer, &timer_debug_descr);\r\nreturn 0;\r\n} else {\r\nsetup_timer(timer, stub_timer, 0);\r\nreturn 1;\r\n}\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic inline void debug_timer_init(struct timer_list *timer)\r\n{\r\ndebug_object_init(timer, &timer_debug_descr);\r\n}\r\nstatic inline void debug_timer_activate(struct timer_list *timer)\r\n{\r\ndebug_object_activate(timer, &timer_debug_descr);\r\n}\r\nstatic inline void debug_timer_deactivate(struct timer_list *timer)\r\n{\r\ndebug_object_deactivate(timer, &timer_debug_descr);\r\n}\r\nstatic inline void debug_timer_free(struct timer_list *timer)\r\n{\r\ndebug_object_free(timer, &timer_debug_descr);\r\n}\r\nstatic inline void debug_timer_assert_init(struct timer_list *timer)\r\n{\r\ndebug_object_assert_init(timer, &timer_debug_descr);\r\n}\r\nvoid init_timer_on_stack_key(struct timer_list *timer, unsigned int flags,\r\nconst char *name, struct lock_class_key *key)\r\n{\r\ndebug_object_init_on_stack(timer, &timer_debug_descr);\r\ndo_init_timer(timer, flags, name, key);\r\n}\r\nvoid destroy_timer_on_stack(struct timer_list *timer)\r\n{\r\ndebug_object_free(timer, &timer_debug_descr);\r\n}\r\nstatic inline void debug_timer_init(struct timer_list *timer) { }\r\nstatic inline void debug_timer_activate(struct timer_list *timer) { }\r\nstatic inline void debug_timer_deactivate(struct timer_list *timer) { }\r\nstatic inline void debug_timer_assert_init(struct timer_list *timer) { }\r\nstatic inline void debug_init(struct timer_list *timer)\r\n{\r\ndebug_timer_init(timer);\r\ntrace_timer_init(timer);\r\n}\r\nstatic inline void\r\ndebug_activate(struct timer_list *timer, unsigned long expires)\r\n{\r\ndebug_timer_activate(timer);\r\ntrace_timer_start(timer, expires);\r\n}\r\nstatic inline void debug_deactivate(struct timer_list *timer)\r\n{\r\ndebug_timer_deactivate(timer);\r\ntrace_timer_cancel(timer);\r\n}\r\nstatic inline void debug_assert_init(struct timer_list *timer)\r\n{\r\ndebug_timer_assert_init(timer);\r\n}\r\nstatic void do_init_timer(struct timer_list *timer, unsigned int flags,\r\nconst char *name, struct lock_class_key *key)\r\n{\r\nstruct tvec_base *base = raw_cpu_read(tvec_bases);\r\ntimer->entry.next = NULL;\r\ntimer->base = (void *)((unsigned long)base | flags);\r\ntimer->slack = -1;\r\n#ifdef CONFIG_TIMER_STATS\r\ntimer->start_site = NULL;\r\ntimer->start_pid = -1;\r\nmemset(timer->start_comm, 0, TASK_COMM_LEN);\r\n#endif\r\nlockdep_init_map(&timer->lockdep_map, name, key, 0);\r\n}\r\nvoid init_timer_key(struct timer_list *timer, unsigned int flags,\r\nconst char *name, struct lock_class_key *key)\r\n{\r\ndebug_init(timer);\r\ndo_init_timer(timer, flags, name, key);\r\n}\r\nstatic inline void detach_timer(struct timer_list *timer, bool clear_pending)\r\n{\r\nstruct list_head *entry = &timer->entry;\r\ndebug_deactivate(timer);\r\n__list_del(entry->prev, entry->next);\r\nif (clear_pending)\r\nentry->next = NULL;\r\nentry->prev = LIST_POISON2;\r\n}\r\nstatic inline void\r\ndetach_expired_timer(struct timer_list *timer, struct tvec_base *base)\r\n{\r\ndetach_timer(timer, true);\r\nif (!tbase_get_deferrable(timer->base))\r\nbase->active_timers--;\r\nbase->all_timers--;\r\n(void)catchup_timer_jiffies(base);\r\n}\r\nstatic int detach_if_pending(struct timer_list *timer, struct tvec_base *base,\r\nbool clear_pending)\r\n{\r\nif (!timer_pending(timer))\r\nreturn 0;\r\ndetach_timer(timer, clear_pending);\r\nif (!tbase_get_deferrable(timer->base)) {\r\nbase->active_timers--;\r\nif (timer->expires == base->next_timer)\r\nbase->next_timer = base->timer_jiffies;\r\n}\r\nbase->all_timers--;\r\n(void)catchup_timer_jiffies(base);\r\nreturn 1;\r\n}\r\nstatic struct tvec_base *lock_timer_base(struct timer_list *timer,\r\nunsigned long *flags)\r\n__acquires(timer->base->lock)\r\n{\r\nstruct tvec_base *base;\r\nfor (;;) {\r\nstruct tvec_base *prelock_base = timer->base;\r\nbase = tbase_get_base(prelock_base);\r\nif (likely(base != NULL)) {\r\nspin_lock_irqsave(&base->lock, *flags);\r\nif (likely(prelock_base == timer->base))\r\nreturn base;\r\nspin_unlock_irqrestore(&base->lock, *flags);\r\n}\r\ncpu_relax();\r\n}\r\n}\r\nstatic inline int\r\n__mod_timer(struct timer_list *timer, unsigned long expires,\r\nbool pending_only, int pinned)\r\n{\r\nstruct tvec_base *base, *new_base;\r\nunsigned long flags;\r\nint ret = 0 , cpu;\r\ntimer_stats_timer_set_start_info(timer);\r\nBUG_ON(!timer->function);\r\nbase = lock_timer_base(timer, &flags);\r\nret = detach_if_pending(timer, base, false);\r\nif (!ret && pending_only)\r\ngoto out_unlock;\r\ndebug_activate(timer, expires);\r\ncpu = get_nohz_timer_target(pinned);\r\nnew_base = per_cpu(tvec_bases, cpu);\r\nif (base != new_base) {\r\nif (likely(base->running_timer != timer)) {\r\ntimer_set_base(timer, NULL);\r\nspin_unlock(&base->lock);\r\nbase = new_base;\r\nspin_lock(&base->lock);\r\ntimer_set_base(timer, base);\r\n}\r\n}\r\ntimer->expires = expires;\r\ninternal_add_timer(base, timer);\r\nout_unlock:\r\nspin_unlock_irqrestore(&base->lock, flags);\r\nreturn ret;\r\n}\r\nint mod_timer_pending(struct timer_list *timer, unsigned long expires)\r\n{\r\nreturn __mod_timer(timer, expires, true, TIMER_NOT_PINNED);\r\n}\r\nstatic inline\r\nunsigned long apply_slack(struct timer_list *timer, unsigned long expires)\r\n{\r\nunsigned long expires_limit, mask;\r\nint bit;\r\nif (timer->slack >= 0) {\r\nexpires_limit = expires + timer->slack;\r\n} else {\r\nlong delta = expires - jiffies;\r\nif (delta < 256)\r\nreturn expires;\r\nexpires_limit = expires + delta / 256;\r\n}\r\nmask = expires ^ expires_limit;\r\nif (mask == 0)\r\nreturn expires;\r\nbit = find_last_bit(&mask, BITS_PER_LONG);\r\nmask = (1UL << bit) - 1;\r\nexpires_limit = expires_limit & ~(mask);\r\nreturn expires_limit;\r\n}\r\nint mod_timer(struct timer_list *timer, unsigned long expires)\r\n{\r\nexpires = apply_slack(timer, expires);\r\nif (timer_pending(timer) && timer->expires == expires)\r\nreturn 1;\r\nreturn __mod_timer(timer, expires, false, TIMER_NOT_PINNED);\r\n}\r\nint mod_timer_pinned(struct timer_list *timer, unsigned long expires)\r\n{\r\nif (timer->expires == expires && timer_pending(timer))\r\nreturn 1;\r\nreturn __mod_timer(timer, expires, false, TIMER_PINNED);\r\n}\r\nvoid add_timer(struct timer_list *timer)\r\n{\r\nBUG_ON(timer_pending(timer));\r\nmod_timer(timer, timer->expires);\r\n}\r\nvoid add_timer_on(struct timer_list *timer, int cpu)\r\n{\r\nstruct tvec_base *base = per_cpu(tvec_bases, cpu);\r\nunsigned long flags;\r\ntimer_stats_timer_set_start_info(timer);\r\nBUG_ON(timer_pending(timer) || !timer->function);\r\nspin_lock_irqsave(&base->lock, flags);\r\ntimer_set_base(timer, base);\r\ndebug_activate(timer, timer->expires);\r\ninternal_add_timer(base, timer);\r\nspin_unlock_irqrestore(&base->lock, flags);\r\n}\r\nint del_timer(struct timer_list *timer)\r\n{\r\nstruct tvec_base *base;\r\nunsigned long flags;\r\nint ret = 0;\r\ndebug_assert_init(timer);\r\ntimer_stats_timer_clear_start_info(timer);\r\nif (timer_pending(timer)) {\r\nbase = lock_timer_base(timer, &flags);\r\nret = detach_if_pending(timer, base, true);\r\nspin_unlock_irqrestore(&base->lock, flags);\r\n}\r\nreturn ret;\r\n}\r\nint try_to_del_timer_sync(struct timer_list *timer)\r\n{\r\nstruct tvec_base *base;\r\nunsigned long flags;\r\nint ret = -1;\r\ndebug_assert_init(timer);\r\nbase = lock_timer_base(timer, &flags);\r\nif (base->running_timer != timer) {\r\ntimer_stats_timer_clear_start_info(timer);\r\nret = detach_if_pending(timer, base, true);\r\n}\r\nspin_unlock_irqrestore(&base->lock, flags);\r\nreturn ret;\r\n}\r\nint del_timer_sync(struct timer_list *timer)\r\n{\r\n#ifdef CONFIG_LOCKDEP\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nlock_map_acquire(&timer->lockdep_map);\r\nlock_map_release(&timer->lockdep_map);\r\nlocal_irq_restore(flags);\r\n#endif\r\nWARN_ON(in_irq() && !tbase_get_irqsafe(timer->base));\r\nfor (;;) {\r\nint ret = try_to_del_timer_sync(timer);\r\nif (ret >= 0)\r\nreturn ret;\r\ncpu_relax();\r\n}\r\n}\r\nstatic int cascade(struct tvec_base *base, struct tvec *tv, int index)\r\n{\r\nstruct timer_list *timer, *tmp;\r\nstruct list_head tv_list;\r\nlist_replace_init(tv->vec + index, &tv_list);\r\nlist_for_each_entry_safe(timer, tmp, &tv_list, entry) {\r\nBUG_ON(tbase_get_base(timer->base) != base);\r\n__internal_add_timer(base, timer);\r\n}\r\nreturn index;\r\n}\r\nstatic void call_timer_fn(struct timer_list *timer, void (*fn)(unsigned long),\r\nunsigned long data)\r\n{\r\nint count = preempt_count();\r\n#ifdef CONFIG_LOCKDEP\r\nstruct lockdep_map lockdep_map;\r\nlockdep_copy_map(&lockdep_map, &timer->lockdep_map);\r\n#endif\r\nlock_map_acquire(&lockdep_map);\r\ntrace_timer_expire_entry(timer);\r\nfn(data);\r\ntrace_timer_expire_exit(timer);\r\nlock_map_release(&lockdep_map);\r\nif (count != preempt_count()) {\r\nWARN_ONCE(1, "timer: %pF preempt leak: %08x -> %08x\n",\r\nfn, count, preempt_count());\r\npreempt_count_set(count);\r\n}\r\n}\r\nstatic inline void __run_timers(struct tvec_base *base)\r\n{\r\nstruct timer_list *timer;\r\nspin_lock_irq(&base->lock);\r\nif (catchup_timer_jiffies(base)) {\r\nspin_unlock_irq(&base->lock);\r\nreturn;\r\n}\r\nwhile (time_after_eq(jiffies, base->timer_jiffies)) {\r\nstruct list_head work_list;\r\nstruct list_head *head = &work_list;\r\nint index = base->timer_jiffies & TVR_MASK;\r\nif (!index &&\r\n(!cascade(base, &base->tv2, INDEX(0))) &&\r\n(!cascade(base, &base->tv3, INDEX(1))) &&\r\n!cascade(base, &base->tv4, INDEX(2)))\r\ncascade(base, &base->tv5, INDEX(3));\r\n++base->timer_jiffies;\r\nlist_replace_init(base->tv1.vec + index, head);\r\nwhile (!list_empty(head)) {\r\nvoid (*fn)(unsigned long);\r\nunsigned long data;\r\nbool irqsafe;\r\ntimer = list_first_entry(head, struct timer_list,entry);\r\nfn = timer->function;\r\ndata = timer->data;\r\nirqsafe = tbase_get_irqsafe(timer->base);\r\ntimer_stats_account_timer(timer);\r\nbase->running_timer = timer;\r\ndetach_expired_timer(timer, base);\r\nif (irqsafe) {\r\nspin_unlock(&base->lock);\r\ncall_timer_fn(timer, fn, data);\r\nspin_lock(&base->lock);\r\n} else {\r\nspin_unlock_irq(&base->lock);\r\ncall_timer_fn(timer, fn, data);\r\nspin_lock_irq(&base->lock);\r\n}\r\n}\r\n}\r\nbase->running_timer = NULL;\r\nspin_unlock_irq(&base->lock);\r\n}\r\nstatic unsigned long __next_timer_interrupt(struct tvec_base *base)\r\n{\r\nunsigned long timer_jiffies = base->timer_jiffies;\r\nunsigned long expires = timer_jiffies + NEXT_TIMER_MAX_DELTA;\r\nint index, slot, array, found = 0;\r\nstruct timer_list *nte;\r\nstruct tvec *varray[4];\r\nindex = slot = timer_jiffies & TVR_MASK;\r\ndo {\r\nlist_for_each_entry(nte, base->tv1.vec + slot, entry) {\r\nif (tbase_get_deferrable(nte->base))\r\ncontinue;\r\nfound = 1;\r\nexpires = nte->expires;\r\nif (!index || slot < index)\r\ngoto cascade;\r\nreturn expires;\r\n}\r\nslot = (slot + 1) & TVR_MASK;\r\n} while (slot != index);\r\ncascade:\r\nif (index)\r\ntimer_jiffies += TVR_SIZE - index;\r\ntimer_jiffies >>= TVR_BITS;\r\nvarray[0] = &base->tv2;\r\nvarray[1] = &base->tv3;\r\nvarray[2] = &base->tv4;\r\nvarray[3] = &base->tv5;\r\nfor (array = 0; array < 4; array++) {\r\nstruct tvec *varp = varray[array];\r\nindex = slot = timer_jiffies & TVN_MASK;\r\ndo {\r\nlist_for_each_entry(nte, varp->vec + slot, entry) {\r\nif (tbase_get_deferrable(nte->base))\r\ncontinue;\r\nfound = 1;\r\nif (time_before(nte->expires, expires))\r\nexpires = nte->expires;\r\n}\r\nif (found) {\r\nif (!index || slot < index)\r\nbreak;\r\nreturn expires;\r\n}\r\nslot = (slot + 1) & TVN_MASK;\r\n} while (slot != index);\r\nif (index)\r\ntimer_jiffies += TVN_SIZE - index;\r\ntimer_jiffies >>= TVN_BITS;\r\n}\r\nreturn expires;\r\n}\r\nstatic unsigned long cmp_next_hrtimer_event(unsigned long now,\r\nunsigned long expires)\r\n{\r\nktime_t hr_delta = hrtimer_get_next_event();\r\nstruct timespec tsdelta;\r\nunsigned long delta;\r\nif (hr_delta.tv64 == KTIME_MAX)\r\nreturn expires;\r\nif (hr_delta.tv64 <= 0)\r\nreturn now + 1;\r\ntsdelta = ktime_to_timespec(hr_delta);\r\ndelta = timespec_to_jiffies(&tsdelta);\r\nif (delta > NEXT_TIMER_MAX_DELTA)\r\ndelta = NEXT_TIMER_MAX_DELTA;\r\nif (delta < 1)\r\ndelta = 1;\r\nnow += delta;\r\nif (time_before(now, expires))\r\nreturn now;\r\nreturn expires;\r\n}\r\nunsigned long get_next_timer_interrupt(unsigned long now)\r\n{\r\nstruct tvec_base *base = __this_cpu_read(tvec_bases);\r\nunsigned long expires = now + NEXT_TIMER_MAX_DELTA;\r\nif (cpu_is_offline(smp_processor_id()))\r\nreturn expires;\r\nspin_lock(&base->lock);\r\nif (base->active_timers) {\r\nif (time_before_eq(base->next_timer, base->timer_jiffies))\r\nbase->next_timer = __next_timer_interrupt(base);\r\nexpires = base->next_timer;\r\n}\r\nspin_unlock(&base->lock);\r\nif (time_before_eq(expires, now))\r\nreturn now;\r\nreturn cmp_next_hrtimer_event(now, expires);\r\n}\r\nvoid update_process_times(int user_tick)\r\n{\r\nstruct task_struct *p = current;\r\naccount_process_tick(p, user_tick);\r\nrun_local_timers();\r\nrcu_check_callbacks(user_tick);\r\n#ifdef CONFIG_IRQ_WORK\r\nif (in_irq())\r\nirq_work_tick();\r\n#endif\r\nscheduler_tick();\r\nrun_posix_cpu_timers(p);\r\n}\r\nstatic void run_timer_softirq(struct softirq_action *h)\r\n{\r\nstruct tvec_base *base = __this_cpu_read(tvec_bases);\r\nhrtimer_run_pending();\r\nif (time_after_eq(jiffies, base->timer_jiffies))\r\n__run_timers(base);\r\n}\r\nvoid run_local_timers(void)\r\n{\r\nhrtimer_run_queues();\r\nraise_softirq(TIMER_SOFTIRQ);\r\n}\r\nstatic void process_timeout(unsigned long __data)\r\n{\r\nwake_up_process((struct task_struct *)__data);\r\n}\r\nsigned long __sched schedule_timeout(signed long timeout)\r\n{\r\nstruct timer_list timer;\r\nunsigned long expire;\r\nswitch (timeout)\r\n{\r\ncase MAX_SCHEDULE_TIMEOUT:\r\nschedule();\r\ngoto out;\r\ndefault:\r\nif (timeout < 0) {\r\nprintk(KERN_ERR "schedule_timeout: wrong timeout "\r\n"value %lx\n", timeout);\r\ndump_stack();\r\ncurrent->state = TASK_RUNNING;\r\ngoto out;\r\n}\r\n}\r\nexpire = timeout + jiffies;\r\nsetup_timer_on_stack(&timer, process_timeout, (unsigned long)current);\r\n__mod_timer(&timer, expire, false, TIMER_NOT_PINNED);\r\nschedule();\r\ndel_singleshot_timer_sync(&timer);\r\ndestroy_timer_on_stack(&timer);\r\ntimeout = expire - jiffies;\r\nout:\r\nreturn timeout < 0 ? 0 : timeout;\r\n}\r\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\r\n{\r\n__set_current_state(TASK_INTERRUPTIBLE);\r\nreturn schedule_timeout(timeout);\r\n}\r\nsigned long __sched schedule_timeout_killable(signed long timeout)\r\n{\r\n__set_current_state(TASK_KILLABLE);\r\nreturn schedule_timeout(timeout);\r\n}\r\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\r\n{\r\n__set_current_state(TASK_UNINTERRUPTIBLE);\r\nreturn schedule_timeout(timeout);\r\n}\r\nstatic int init_timers_cpu(int cpu)\r\n{\r\nint j;\r\nstruct tvec_base *base;\r\nstatic char tvec_base_done[NR_CPUS];\r\nif (!tvec_base_done[cpu]) {\r\nstatic char boot_done;\r\nif (boot_done) {\r\nbase = kzalloc_node(sizeof(*base), GFP_KERNEL,\r\ncpu_to_node(cpu));\r\nif (!base)\r\nreturn -ENOMEM;\r\nif (WARN_ON(base != tbase_get_base(base))) {\r\nkfree(base);\r\nreturn -ENOMEM;\r\n}\r\nper_cpu(tvec_bases, cpu) = base;\r\n} else {\r\nboot_done = 1;\r\nbase = &boot_tvec_bases;\r\n}\r\nspin_lock_init(&base->lock);\r\ntvec_base_done[cpu] = 1;\r\nbase->cpu = cpu;\r\n} else {\r\nbase = per_cpu(tvec_bases, cpu);\r\n}\r\nfor (j = 0; j < TVN_SIZE; j++) {\r\nINIT_LIST_HEAD(base->tv5.vec + j);\r\nINIT_LIST_HEAD(base->tv4.vec + j);\r\nINIT_LIST_HEAD(base->tv3.vec + j);\r\nINIT_LIST_HEAD(base->tv2.vec + j);\r\n}\r\nfor (j = 0; j < TVR_SIZE; j++)\r\nINIT_LIST_HEAD(base->tv1.vec + j);\r\nbase->timer_jiffies = jiffies;\r\nbase->next_timer = base->timer_jiffies;\r\nbase->active_timers = 0;\r\nbase->all_timers = 0;\r\nreturn 0;\r\n}\r\nstatic void migrate_timer_list(struct tvec_base *new_base, struct list_head *head)\r\n{\r\nstruct timer_list *timer;\r\nwhile (!list_empty(head)) {\r\ntimer = list_first_entry(head, struct timer_list, entry);\r\ndetach_timer(timer, false);\r\ntimer_set_base(timer, new_base);\r\ninternal_add_timer(new_base, timer);\r\n}\r\n}\r\nstatic void migrate_timers(int cpu)\r\n{\r\nstruct tvec_base *old_base;\r\nstruct tvec_base *new_base;\r\nint i;\r\nBUG_ON(cpu_online(cpu));\r\nold_base = per_cpu(tvec_bases, cpu);\r\nnew_base = get_cpu_var(tvec_bases);\r\nspin_lock_irq(&new_base->lock);\r\nspin_lock_nested(&old_base->lock, SINGLE_DEPTH_NESTING);\r\nBUG_ON(old_base->running_timer);\r\nfor (i = 0; i < TVR_SIZE; i++)\r\nmigrate_timer_list(new_base, old_base->tv1.vec + i);\r\nfor (i = 0; i < TVN_SIZE; i++) {\r\nmigrate_timer_list(new_base, old_base->tv2.vec + i);\r\nmigrate_timer_list(new_base, old_base->tv3.vec + i);\r\nmigrate_timer_list(new_base, old_base->tv4.vec + i);\r\nmigrate_timer_list(new_base, old_base->tv5.vec + i);\r\n}\r\nspin_unlock(&old_base->lock);\r\nspin_unlock_irq(&new_base->lock);\r\nput_cpu_var(tvec_bases);\r\n}\r\nstatic int timer_cpu_notify(struct notifier_block *self,\r\nunsigned long action, void *hcpu)\r\n{\r\nlong cpu = (long)hcpu;\r\nint err;\r\nswitch(action) {\r\ncase CPU_UP_PREPARE:\r\ncase CPU_UP_PREPARE_FROZEN:\r\nerr = init_timers_cpu(cpu);\r\nif (err < 0)\r\nreturn notifier_from_errno(err);\r\nbreak;\r\n#ifdef CONFIG_HOTPLUG_CPU\r\ncase CPU_DEAD:\r\ncase CPU_DEAD_FROZEN:\r\nmigrate_timers(cpu);\r\nbreak;\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nvoid __init init_timers(void)\r\n{\r\nint err;\r\nBUILD_BUG_ON(__alignof__(struct tvec_base) & TIMER_FLAG_MASK);\r\nerr = timer_cpu_notify(&timers_nb, (unsigned long)CPU_UP_PREPARE,\r\n(void *)(long)smp_processor_id());\r\nBUG_ON(err != NOTIFY_OK);\r\ninit_timer_stats();\r\nregister_cpu_notifier(&timers_nb);\r\nopen_softirq(TIMER_SOFTIRQ, run_timer_softirq);\r\n}\r\nvoid msleep(unsigned int msecs)\r\n{\r\nunsigned long timeout = msecs_to_jiffies(msecs) + 1;\r\nwhile (timeout)\r\ntimeout = schedule_timeout_uninterruptible(timeout);\r\n}\r\nunsigned long msleep_interruptible(unsigned int msecs)\r\n{\r\nunsigned long timeout = msecs_to_jiffies(msecs) + 1;\r\nwhile (timeout && !signal_pending(current))\r\ntimeout = schedule_timeout_interruptible(timeout);\r\nreturn jiffies_to_msecs(timeout);\r\n}\r\nstatic int __sched do_usleep_range(unsigned long min, unsigned long max)\r\n{\r\nktime_t kmin;\r\nunsigned long delta;\r\nkmin = ktime_set(0, min * NSEC_PER_USEC);\r\ndelta = (max - min) * NSEC_PER_USEC;\r\nreturn schedule_hrtimeout_range(&kmin, delta, HRTIMER_MODE_REL);\r\n}\r\nvoid usleep_range(unsigned long min, unsigned long max)\r\n{\r\n__set_current_state(TASK_UNINTERRUPTIBLE);\r\ndo_usleep_range(min, max);\r\n}
