bool radeon_is_px(struct drm_device *dev)\r\n{\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (rdev->flags & RADEON_IS_PX)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void radeon_device_handle_px_quirks(struct radeon_device *rdev)\r\n{\r\nstruct radeon_px_quirk *p = radeon_px_quirk_list;\r\nwhile (p && p->chip_device != 0) {\r\nif (rdev->pdev->vendor == p->chip_vendor &&\r\nrdev->pdev->device == p->chip_device &&\r\nrdev->pdev->subsystem_vendor == p->subsys_vendor &&\r\nrdev->pdev->subsystem_device == p->subsys_device) {\r\nrdev->px_quirk_flags = p->px_quirk_flags;\r\nbreak;\r\n}\r\n++p;\r\n}\r\nif (rdev->px_quirk_flags & RADEON_PX_QUIRK_DISABLE_PX)\r\nrdev->flags &= ~RADEON_IS_PX;\r\n}\r\nvoid radeon_program_register_sequence(struct radeon_device *rdev,\r\nconst u32 *registers,\r\nconst u32 array_size)\r\n{\r\nu32 tmp, reg, and_mask, or_mask;\r\nint i;\r\nif (array_size % 3)\r\nreturn;\r\nfor (i = 0; i < array_size; i +=3) {\r\nreg = registers[i + 0];\r\nand_mask = registers[i + 1];\r\nor_mask = registers[i + 2];\r\nif (and_mask == 0xffffffff) {\r\ntmp = or_mask;\r\n} else {\r\ntmp = RREG32(reg);\r\ntmp &= ~and_mask;\r\ntmp |= or_mask;\r\n}\r\nWREG32(reg, tmp);\r\n}\r\n}\r\nvoid radeon_pci_config_reset(struct radeon_device *rdev)\r\n{\r\npci_write_config_dword(rdev->pdev, 0x7c, RADEON_ASIC_RESET_DATA);\r\n}\r\nvoid radeon_surface_init(struct radeon_device *rdev)\r\n{\r\nif (rdev->family < CHIP_R600) {\r\nint i;\r\nfor (i = 0; i < RADEON_GEM_MAX_SURFACES; i++) {\r\nif (rdev->surface_regs[i].bo)\r\nradeon_bo_get_surface_reg(rdev->surface_regs[i].bo);\r\nelse\r\nradeon_clear_surface_reg(rdev, i);\r\n}\r\nWREG32(RADEON_SURFACE_CNTL, 0);\r\n}\r\n}\r\nvoid radeon_scratch_init(struct radeon_device *rdev)\r\n{\r\nint i;\r\nif (rdev->family < CHIP_R300) {\r\nrdev->scratch.num_reg = 5;\r\n} else {\r\nrdev->scratch.num_reg = 7;\r\n}\r\nrdev->scratch.reg_base = RADEON_SCRATCH_REG0;\r\nfor (i = 0; i < rdev->scratch.num_reg; i++) {\r\nrdev->scratch.free[i] = true;\r\nrdev->scratch.reg[i] = rdev->scratch.reg_base + (i * 4);\r\n}\r\n}\r\nint radeon_scratch_get(struct radeon_device *rdev, uint32_t *reg)\r\n{\r\nint i;\r\nfor (i = 0; i < rdev->scratch.num_reg; i++) {\r\nif (rdev->scratch.free[i]) {\r\nrdev->scratch.free[i] = false;\r\n*reg = rdev->scratch.reg[i];\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid radeon_scratch_free(struct radeon_device *rdev, uint32_t reg)\r\n{\r\nint i;\r\nfor (i = 0; i < rdev->scratch.num_reg; i++) {\r\nif (rdev->scratch.reg[i] == reg) {\r\nrdev->scratch.free[i] = true;\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic int radeon_doorbell_init(struct radeon_device *rdev)\r\n{\r\nrdev->doorbell.base = pci_resource_start(rdev->pdev, 2);\r\nrdev->doorbell.size = pci_resource_len(rdev->pdev, 2);\r\nrdev->doorbell.num_doorbells = min_t(u32, rdev->doorbell.size / sizeof(u32), RADEON_MAX_DOORBELLS);\r\nif (rdev->doorbell.num_doorbells == 0)\r\nreturn -EINVAL;\r\nrdev->doorbell.ptr = ioremap(rdev->doorbell.base, rdev->doorbell.num_doorbells * sizeof(u32));\r\nif (rdev->doorbell.ptr == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nDRM_INFO("doorbell mmio base: 0x%08X\n", (uint32_t)rdev->doorbell.base);\r\nDRM_INFO("doorbell mmio size: %u\n", (unsigned)rdev->doorbell.size);\r\nmemset(&rdev->doorbell.used, 0, sizeof(rdev->doorbell.used));\r\nreturn 0;\r\n}\r\nstatic void radeon_doorbell_fini(struct radeon_device *rdev)\r\n{\r\niounmap(rdev->doorbell.ptr);\r\nrdev->doorbell.ptr = NULL;\r\n}\r\nint radeon_doorbell_get(struct radeon_device *rdev, u32 *doorbell)\r\n{\r\nunsigned long offset = find_first_zero_bit(rdev->doorbell.used, rdev->doorbell.num_doorbells);\r\nif (offset < rdev->doorbell.num_doorbells) {\r\n__set_bit(offset, rdev->doorbell.used);\r\n*doorbell = offset;\r\nreturn 0;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\nvoid radeon_doorbell_free(struct radeon_device *rdev, u32 doorbell)\r\n{\r\nif (doorbell < rdev->doorbell.num_doorbells)\r\n__clear_bit(doorbell, rdev->doorbell.used);\r\n}\r\nvoid radeon_doorbell_get_kfd_info(struct radeon_device *rdev,\r\nphys_addr_t *aperture_base,\r\nsize_t *aperture_size,\r\nsize_t *start_offset)\r\n{\r\nif (rdev->doorbell.size > rdev->doorbell.num_doorbells * sizeof(u32)) {\r\n*aperture_base = rdev->doorbell.base;\r\n*aperture_size = rdev->doorbell.size;\r\n*start_offset = rdev->doorbell.num_doorbells * sizeof(u32);\r\n} else {\r\n*aperture_base = 0;\r\n*aperture_size = 0;\r\n*start_offset = 0;\r\n}\r\n}\r\nvoid radeon_wb_disable(struct radeon_device *rdev)\r\n{\r\nrdev->wb.enabled = false;\r\n}\r\nvoid radeon_wb_fini(struct radeon_device *rdev)\r\n{\r\nradeon_wb_disable(rdev);\r\nif (rdev->wb.wb_obj) {\r\nif (!radeon_bo_reserve(rdev->wb.wb_obj, false)) {\r\nradeon_bo_kunmap(rdev->wb.wb_obj);\r\nradeon_bo_unpin(rdev->wb.wb_obj);\r\nradeon_bo_unreserve(rdev->wb.wb_obj);\r\n}\r\nradeon_bo_unref(&rdev->wb.wb_obj);\r\nrdev->wb.wb = NULL;\r\nrdev->wb.wb_obj = NULL;\r\n}\r\n}\r\nint radeon_wb_init(struct radeon_device *rdev)\r\n{\r\nint r;\r\nif (rdev->wb.wb_obj == NULL) {\r\nr = radeon_bo_create(rdev, RADEON_GPU_PAGE_SIZE, PAGE_SIZE, true,\r\nRADEON_GEM_DOMAIN_GTT, 0, NULL, NULL,\r\n&rdev->wb.wb_obj);\r\nif (r) {\r\ndev_warn(rdev->dev, "(%d) create WB bo failed\n", r);\r\nreturn r;\r\n}\r\nr = radeon_bo_reserve(rdev->wb.wb_obj, false);\r\nif (unlikely(r != 0)) {\r\nradeon_wb_fini(rdev);\r\nreturn r;\r\n}\r\nr = radeon_bo_pin(rdev->wb.wb_obj, RADEON_GEM_DOMAIN_GTT,\r\n&rdev->wb.gpu_addr);\r\nif (r) {\r\nradeon_bo_unreserve(rdev->wb.wb_obj);\r\ndev_warn(rdev->dev, "(%d) pin WB bo failed\n", r);\r\nradeon_wb_fini(rdev);\r\nreturn r;\r\n}\r\nr = radeon_bo_kmap(rdev->wb.wb_obj, (void **)&rdev->wb.wb);\r\nradeon_bo_unreserve(rdev->wb.wb_obj);\r\nif (r) {\r\ndev_warn(rdev->dev, "(%d) map WB bo failed\n", r);\r\nradeon_wb_fini(rdev);\r\nreturn r;\r\n}\r\n}\r\nmemset((char *)rdev->wb.wb, 0, RADEON_GPU_PAGE_SIZE);\r\nrdev->wb.use_event = false;\r\nif (radeon_no_wb == 1) {\r\nrdev->wb.enabled = false;\r\n} else {\r\nif (rdev->flags & RADEON_IS_AGP) {\r\nrdev->wb.enabled = false;\r\n} else if (rdev->family < CHIP_R300) {\r\nrdev->wb.enabled = false;\r\n} else {\r\nrdev->wb.enabled = true;\r\nif (rdev->family >= CHIP_R600) {\r\nrdev->wb.use_event = true;\r\n}\r\n}\r\n}\r\nif (rdev->family >= CHIP_PALM) {\r\nrdev->wb.enabled = true;\r\nrdev->wb.use_event = true;\r\n}\r\ndev_info(rdev->dev, "WB %sabled\n", rdev->wb.enabled ? "en" : "dis");\r\nreturn 0;\r\n}\r\nvoid radeon_vram_location(struct radeon_device *rdev, struct radeon_mc *mc, u64 base)\r\n{\r\nuint64_t limit = (uint64_t)radeon_vram_limit << 20;\r\nmc->vram_start = base;\r\nif (mc->mc_vram_size > (rdev->mc.mc_mask - base + 1)) {\r\ndev_warn(rdev->dev, "limiting VRAM to PCI aperture size\n");\r\nmc->real_vram_size = mc->aper_size;\r\nmc->mc_vram_size = mc->aper_size;\r\n}\r\nmc->vram_end = mc->vram_start + mc->mc_vram_size - 1;\r\nif (rdev->flags & RADEON_IS_AGP && mc->vram_end > mc->gtt_start && mc->vram_start <= mc->gtt_end) {\r\ndev_warn(rdev->dev, "limiting VRAM to PCI aperture size\n");\r\nmc->real_vram_size = mc->aper_size;\r\nmc->mc_vram_size = mc->aper_size;\r\n}\r\nmc->vram_end = mc->vram_start + mc->mc_vram_size - 1;\r\nif (limit && limit < mc->real_vram_size)\r\nmc->real_vram_size = limit;\r\ndev_info(rdev->dev, "VRAM: %lluM 0x%016llX - 0x%016llX (%lluM used)\n",\r\nmc->mc_vram_size >> 20, mc->vram_start,\r\nmc->vram_end, mc->real_vram_size >> 20);\r\n}\r\nvoid radeon_gtt_location(struct radeon_device *rdev, struct radeon_mc *mc)\r\n{\r\nu64 size_af, size_bf;\r\nsize_af = ((rdev->mc.mc_mask - mc->vram_end) + mc->gtt_base_align) & ~mc->gtt_base_align;\r\nsize_bf = mc->vram_start & ~mc->gtt_base_align;\r\nif (size_bf > size_af) {\r\nif (mc->gtt_size > size_bf) {\r\ndev_warn(rdev->dev, "limiting GTT\n");\r\nmc->gtt_size = size_bf;\r\n}\r\nmc->gtt_start = (mc->vram_start & ~mc->gtt_base_align) - mc->gtt_size;\r\n} else {\r\nif (mc->gtt_size > size_af) {\r\ndev_warn(rdev->dev, "limiting GTT\n");\r\nmc->gtt_size = size_af;\r\n}\r\nmc->gtt_start = (mc->vram_end + 1 + mc->gtt_base_align) & ~mc->gtt_base_align;\r\n}\r\nmc->gtt_end = mc->gtt_start + mc->gtt_size - 1;\r\ndev_info(rdev->dev, "GTT: %lluM 0x%016llX - 0x%016llX\n",\r\nmc->gtt_size >> 20, mc->gtt_start, mc->gtt_end);\r\n}\r\nbool radeon_card_posted(struct radeon_device *rdev)\r\n{\r\nuint32_t reg;\r\nif (efi_enabled(EFI_BOOT) &&\r\n(rdev->pdev->subsystem_vendor == PCI_VENDOR_ID_APPLE) &&\r\n(rdev->family < CHIP_R600))\r\nreturn false;\r\nif (ASIC_IS_NODCE(rdev))\r\ngoto check_memsize;\r\nif (ASIC_IS_DCE4(rdev)) {\r\nreg = RREG32(EVERGREEN_CRTC_CONTROL + EVERGREEN_CRTC0_REGISTER_OFFSET) |\r\nRREG32(EVERGREEN_CRTC_CONTROL + EVERGREEN_CRTC1_REGISTER_OFFSET);\r\nif (rdev->num_crtc >= 4) {\r\nreg |= RREG32(EVERGREEN_CRTC_CONTROL + EVERGREEN_CRTC2_REGISTER_OFFSET) |\r\nRREG32(EVERGREEN_CRTC_CONTROL + EVERGREEN_CRTC3_REGISTER_OFFSET);\r\n}\r\nif (rdev->num_crtc >= 6) {\r\nreg |= RREG32(EVERGREEN_CRTC_CONTROL + EVERGREEN_CRTC4_REGISTER_OFFSET) |\r\nRREG32(EVERGREEN_CRTC_CONTROL + EVERGREEN_CRTC5_REGISTER_OFFSET);\r\n}\r\nif (reg & EVERGREEN_CRTC_MASTER_EN)\r\nreturn true;\r\n} else if (ASIC_IS_AVIVO(rdev)) {\r\nreg = RREG32(AVIVO_D1CRTC_CONTROL) |\r\nRREG32(AVIVO_D2CRTC_CONTROL);\r\nif (reg & AVIVO_CRTC_EN) {\r\nreturn true;\r\n}\r\n} else {\r\nreg = RREG32(RADEON_CRTC_GEN_CNTL) |\r\nRREG32(RADEON_CRTC2_GEN_CNTL);\r\nif (reg & RADEON_CRTC_EN) {\r\nreturn true;\r\n}\r\n}\r\ncheck_memsize:\r\nif (rdev->family >= CHIP_R600)\r\nreg = RREG32(R600_CONFIG_MEMSIZE);\r\nelse\r\nreg = RREG32(RADEON_CONFIG_MEMSIZE);\r\nif (reg)\r\nreturn true;\r\nreturn false;\r\n}\r\nvoid radeon_update_bandwidth_info(struct radeon_device *rdev)\r\n{\r\nfixed20_12 a;\r\nu32 sclk = rdev->pm.current_sclk;\r\nu32 mclk = rdev->pm.current_mclk;\r\na.full = dfixed_const(100);\r\nrdev->pm.sclk.full = dfixed_const(sclk);\r\nrdev->pm.sclk.full = dfixed_div(rdev->pm.sclk, a);\r\nrdev->pm.mclk.full = dfixed_const(mclk);\r\nrdev->pm.mclk.full = dfixed_div(rdev->pm.mclk, a);\r\nif (rdev->flags & RADEON_IS_IGP) {\r\na.full = dfixed_const(16);\r\nrdev->pm.core_bandwidth.full = dfixed_div(rdev->pm.sclk, a);\r\n}\r\n}\r\nbool radeon_boot_test_post_card(struct radeon_device *rdev)\r\n{\r\nif (radeon_card_posted(rdev))\r\nreturn true;\r\nif (rdev->bios) {\r\nDRM_INFO("GPU not posted. posting now...\n");\r\nif (rdev->is_atom_bios)\r\natom_asic_init(rdev->mode_info.atom_context);\r\nelse\r\nradeon_combios_asic_init(rdev->ddev);\r\nreturn true;\r\n} else {\r\ndev_err(rdev->dev, "Card not posted and no BIOS - ignoring\n");\r\nreturn false;\r\n}\r\n}\r\nint radeon_dummy_page_init(struct radeon_device *rdev)\r\n{\r\nif (rdev->dummy_page.page)\r\nreturn 0;\r\nrdev->dummy_page.page = alloc_page(GFP_DMA32 | GFP_KERNEL | __GFP_ZERO);\r\nif (rdev->dummy_page.page == NULL)\r\nreturn -ENOMEM;\r\nrdev->dummy_page.addr = pci_map_page(rdev->pdev, rdev->dummy_page.page,\r\n0, PAGE_SIZE, PCI_DMA_BIDIRECTIONAL);\r\nif (pci_dma_mapping_error(rdev->pdev, rdev->dummy_page.addr)) {\r\ndev_err(&rdev->pdev->dev, "Failed to DMA MAP the dummy page\n");\r\n__free_page(rdev->dummy_page.page);\r\nrdev->dummy_page.page = NULL;\r\nreturn -ENOMEM;\r\n}\r\nrdev->dummy_page.entry = radeon_gart_get_page_entry(rdev->dummy_page.addr,\r\nRADEON_GART_PAGE_DUMMY);\r\nreturn 0;\r\n}\r\nvoid radeon_dummy_page_fini(struct radeon_device *rdev)\r\n{\r\nif (rdev->dummy_page.page == NULL)\r\nreturn;\r\npci_unmap_page(rdev->pdev, rdev->dummy_page.addr,\r\nPAGE_SIZE, PCI_DMA_BIDIRECTIONAL);\r\n__free_page(rdev->dummy_page.page);\r\nrdev->dummy_page.page = NULL;\r\n}\r\nstatic uint32_t cail_pll_read(struct card_info *info, uint32_t reg)\r\n{\r\nstruct radeon_device *rdev = info->dev->dev_private;\r\nuint32_t r;\r\nr = rdev->pll_rreg(rdev, reg);\r\nreturn r;\r\n}\r\nstatic void cail_pll_write(struct card_info *info, uint32_t reg, uint32_t val)\r\n{\r\nstruct radeon_device *rdev = info->dev->dev_private;\r\nrdev->pll_wreg(rdev, reg, val);\r\n}\r\nstatic uint32_t cail_mc_read(struct card_info *info, uint32_t reg)\r\n{\r\nstruct radeon_device *rdev = info->dev->dev_private;\r\nuint32_t r;\r\nr = rdev->mc_rreg(rdev, reg);\r\nreturn r;\r\n}\r\nstatic void cail_mc_write(struct card_info *info, uint32_t reg, uint32_t val)\r\n{\r\nstruct radeon_device *rdev = info->dev->dev_private;\r\nrdev->mc_wreg(rdev, reg, val);\r\n}\r\nstatic void cail_reg_write(struct card_info *info, uint32_t reg, uint32_t val)\r\n{\r\nstruct radeon_device *rdev = info->dev->dev_private;\r\nWREG32(reg*4, val);\r\n}\r\nstatic uint32_t cail_reg_read(struct card_info *info, uint32_t reg)\r\n{\r\nstruct radeon_device *rdev = info->dev->dev_private;\r\nuint32_t r;\r\nr = RREG32(reg*4);\r\nreturn r;\r\n}\r\nstatic void cail_ioreg_write(struct card_info *info, uint32_t reg, uint32_t val)\r\n{\r\nstruct radeon_device *rdev = info->dev->dev_private;\r\nWREG32_IO(reg*4, val);\r\n}\r\nstatic uint32_t cail_ioreg_read(struct card_info *info, uint32_t reg)\r\n{\r\nstruct radeon_device *rdev = info->dev->dev_private;\r\nuint32_t r;\r\nr = RREG32_IO(reg*4);\r\nreturn r;\r\n}\r\nint radeon_atombios_init(struct radeon_device *rdev)\r\n{\r\nstruct card_info *atom_card_info =\r\nkzalloc(sizeof(struct card_info), GFP_KERNEL);\r\nif (!atom_card_info)\r\nreturn -ENOMEM;\r\nrdev->mode_info.atom_card_info = atom_card_info;\r\natom_card_info->dev = rdev->ddev;\r\natom_card_info->reg_read = cail_reg_read;\r\natom_card_info->reg_write = cail_reg_write;\r\nif (rdev->rio_mem) {\r\natom_card_info->ioreg_read = cail_ioreg_read;\r\natom_card_info->ioreg_write = cail_ioreg_write;\r\n} else {\r\nDRM_ERROR("Unable to find PCI I/O BAR; using MMIO for ATOM IIO\n");\r\natom_card_info->ioreg_read = cail_reg_read;\r\natom_card_info->ioreg_write = cail_reg_write;\r\n}\r\natom_card_info->mc_read = cail_mc_read;\r\natom_card_info->mc_write = cail_mc_write;\r\natom_card_info->pll_read = cail_pll_read;\r\natom_card_info->pll_write = cail_pll_write;\r\nrdev->mode_info.atom_context = atom_parse(atom_card_info, rdev->bios);\r\nif (!rdev->mode_info.atom_context) {\r\nradeon_atombios_fini(rdev);\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&rdev->mode_info.atom_context->mutex);\r\nmutex_init(&rdev->mode_info.atom_context->scratch_mutex);\r\nradeon_atom_initialize_bios_scratch_regs(rdev->ddev);\r\natom_allocate_fb_scratch(rdev->mode_info.atom_context);\r\nreturn 0;\r\n}\r\nvoid radeon_atombios_fini(struct radeon_device *rdev)\r\n{\r\nif (rdev->mode_info.atom_context) {\r\nkfree(rdev->mode_info.atom_context->scratch);\r\n}\r\nkfree(rdev->mode_info.atom_context);\r\nrdev->mode_info.atom_context = NULL;\r\nkfree(rdev->mode_info.atom_card_info);\r\nrdev->mode_info.atom_card_info = NULL;\r\n}\r\nint radeon_combios_init(struct radeon_device *rdev)\r\n{\r\nradeon_combios_initialize_bios_scratch_regs(rdev->ddev);\r\nreturn 0;\r\n}\r\nvoid radeon_combios_fini(struct radeon_device *rdev)\r\n{\r\n}\r\nstatic unsigned int radeon_vga_set_decode(void *cookie, bool state)\r\n{\r\nstruct radeon_device *rdev = cookie;\r\nradeon_vga_set_state(rdev, state);\r\nif (state)\r\nreturn VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM |\r\nVGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;\r\nelse\r\nreturn VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;\r\n}\r\nstatic bool radeon_check_pot_argument(int arg)\r\n{\r\nreturn (arg & (arg - 1)) == 0;\r\n}\r\nstatic void radeon_check_arguments(struct radeon_device *rdev)\r\n{\r\nif (!radeon_check_pot_argument(radeon_vram_limit)) {\r\ndev_warn(rdev->dev, "vram limit (%d) must be a power of 2\n",\r\nradeon_vram_limit);\r\nradeon_vram_limit = 0;\r\n}\r\nif (radeon_gart_size == -1) {\r\nif (rdev->family >= CHIP_RV770)\r\nradeon_gart_size = 1024;\r\nelse\r\nradeon_gart_size = 512;\r\n}\r\nif (radeon_gart_size < 32) {\r\ndev_warn(rdev->dev, "gart size (%d) too small\n",\r\nradeon_gart_size);\r\nif (rdev->family >= CHIP_RV770)\r\nradeon_gart_size = 1024;\r\nelse\r\nradeon_gart_size = 512;\r\n} else if (!radeon_check_pot_argument(radeon_gart_size)) {\r\ndev_warn(rdev->dev, "gart size (%d) must be a power of 2\n",\r\nradeon_gart_size);\r\nif (rdev->family >= CHIP_RV770)\r\nradeon_gart_size = 1024;\r\nelse\r\nradeon_gart_size = 512;\r\n}\r\nrdev->mc.gtt_size = (uint64_t)radeon_gart_size << 20;\r\nswitch (radeon_agpmode) {\r\ncase -1:\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\ncase 8:\r\nbreak;\r\ndefault:\r\ndev_warn(rdev->dev, "invalid AGP mode %d (valid mode: "\r\n"-1, 0, 1, 2, 4, 8)\n", radeon_agpmode);\r\nradeon_agpmode = 0;\r\nbreak;\r\n}\r\nif (!radeon_check_pot_argument(radeon_vm_size)) {\r\ndev_warn(rdev->dev, "VM size (%d) must be a power of 2\n",\r\nradeon_vm_size);\r\nradeon_vm_size = 4;\r\n}\r\nif (radeon_vm_size < 1) {\r\ndev_warn(rdev->dev, "VM size (%d) to small, min is 1GB\n",\r\nradeon_vm_size);\r\nradeon_vm_size = 4;\r\n}\r\nif (radeon_vm_size > 1024) {\r\ndev_warn(rdev->dev, "VM size (%d) too large, max is 1TB\n",\r\nradeon_vm_size);\r\nradeon_vm_size = 4;\r\n}\r\nif (radeon_vm_block_size == -1) {\r\nunsigned bits = ilog2(radeon_vm_size) + 18;\r\nif (radeon_vm_size <= 8)\r\nradeon_vm_block_size = bits - 9;\r\nelse\r\nradeon_vm_block_size = (bits + 3) / 2;\r\n} else if (radeon_vm_block_size < 9) {\r\ndev_warn(rdev->dev, "VM page table size (%d) too small\n",\r\nradeon_vm_block_size);\r\nradeon_vm_block_size = 9;\r\n}\r\nif (radeon_vm_block_size > 24 ||\r\n(radeon_vm_size * 1024) < (1ull << radeon_vm_block_size)) {\r\ndev_warn(rdev->dev, "VM page table size (%d) too large\n",\r\nradeon_vm_block_size);\r\nradeon_vm_block_size = 9;\r\n}\r\n}\r\nstatic void radeon_switcheroo_set_state(struct pci_dev *pdev, enum vga_switcheroo_state state)\r\n{\r\nstruct drm_device *dev = pci_get_drvdata(pdev);\r\nstruct radeon_device *rdev = dev->dev_private;\r\nif (radeon_is_px(dev) && state == VGA_SWITCHEROO_OFF)\r\nreturn;\r\nif (state == VGA_SWITCHEROO_ON) {\r\nunsigned d3_delay = dev->pdev->d3_delay;\r\nprintk(KERN_INFO "radeon: switched on\n");\r\ndev->switch_power_state = DRM_SWITCH_POWER_CHANGING;\r\nif (d3_delay < 20 && (rdev->px_quirk_flags & RADEON_PX_QUIRK_LONG_WAKEUP))\r\ndev->pdev->d3_delay = 20;\r\nradeon_resume_kms(dev, true, true);\r\ndev->pdev->d3_delay = d3_delay;\r\ndev->switch_power_state = DRM_SWITCH_POWER_ON;\r\ndrm_kms_helper_poll_enable(dev);\r\n} else {\r\nprintk(KERN_INFO "radeon: switched off\n");\r\ndrm_kms_helper_poll_disable(dev);\r\ndev->switch_power_state = DRM_SWITCH_POWER_CHANGING;\r\nradeon_suspend_kms(dev, true, true);\r\ndev->switch_power_state = DRM_SWITCH_POWER_OFF;\r\n}\r\n}\r\nstatic bool radeon_switcheroo_can_switch(struct pci_dev *pdev)\r\n{\r\nstruct drm_device *dev = pci_get_drvdata(pdev);\r\nreturn dev->open_count == 0;\r\n}\r\nint radeon_device_init(struct radeon_device *rdev,\r\nstruct drm_device *ddev,\r\nstruct pci_dev *pdev,\r\nuint32_t flags)\r\n{\r\nint r, i;\r\nint dma_bits;\r\nbool runtime = false;\r\nrdev->shutdown = false;\r\nrdev->dev = &pdev->dev;\r\nrdev->ddev = ddev;\r\nrdev->pdev = pdev;\r\nrdev->flags = flags;\r\nrdev->family = flags & RADEON_FAMILY_MASK;\r\nrdev->is_atom_bios = false;\r\nrdev->usec_timeout = RADEON_MAX_USEC_TIMEOUT;\r\nrdev->mc.gtt_size = 512 * 1024 * 1024;\r\nrdev->accel_working = false;\r\nfor (i = 0; i < RADEON_NUM_RINGS; i++) {\r\nrdev->ring[i].idx = i;\r\n}\r\nrdev->fence_context = fence_context_alloc(RADEON_NUM_RINGS);\r\nDRM_INFO("initializing kernel modesetting (%s 0x%04X:0x%04X 0x%04X:0x%04X).\n",\r\nradeon_family_name[rdev->family], pdev->vendor, pdev->device,\r\npdev->subsystem_vendor, pdev->subsystem_device);\r\nmutex_init(&rdev->ring_lock);\r\nmutex_init(&rdev->dc_hw_i2c_mutex);\r\natomic_set(&rdev->ih.lock, 0);\r\nmutex_init(&rdev->gem.mutex);\r\nmutex_init(&rdev->pm.mutex);\r\nmutex_init(&rdev->gpu_clock_mutex);\r\nmutex_init(&rdev->srbm_mutex);\r\nmutex_init(&rdev->grbm_idx_mutex);\r\ninit_rwsem(&rdev->pm.mclk_lock);\r\ninit_rwsem(&rdev->exclusive_lock);\r\ninit_waitqueue_head(&rdev->irq.vblank_queue);\r\nmutex_init(&rdev->mn_lock);\r\nhash_init(rdev->mn_hash);\r\nr = radeon_gem_init(rdev);\r\nif (r)\r\nreturn r;\r\nradeon_check_arguments(rdev);\r\nrdev->vm_manager.max_pfn = radeon_vm_size << 18;\r\nr = radeon_asic_init(rdev);\r\nif (r)\r\nreturn r;\r\nif ((rdev->family >= CHIP_RS400) &&\r\n(rdev->flags & RADEON_IS_IGP)) {\r\nrdev->flags &= ~RADEON_IS_AGP;\r\n}\r\nif (rdev->flags & RADEON_IS_AGP && radeon_agpmode == -1) {\r\nradeon_agp_disable(rdev);\r\n}\r\nif (rdev->family >= CHIP_CAYMAN)\r\nrdev->mc.mc_mask = 0xffffffffffULL;\r\nelse if (rdev->family >= CHIP_CEDAR)\r\nrdev->mc.mc_mask = 0xfffffffffULL;\r\nelse\r\nrdev->mc.mc_mask = 0xffffffffULL;\r\nrdev->need_dma32 = false;\r\nif (rdev->flags & RADEON_IS_AGP)\r\nrdev->need_dma32 = true;\r\nif ((rdev->flags & RADEON_IS_PCI) &&\r\n(rdev->family <= CHIP_RS740))\r\nrdev->need_dma32 = true;\r\ndma_bits = rdev->need_dma32 ? 32 : 40;\r\nr = pci_set_dma_mask(rdev->pdev, DMA_BIT_MASK(dma_bits));\r\nif (r) {\r\nrdev->need_dma32 = true;\r\ndma_bits = 32;\r\nprintk(KERN_WARNING "radeon: No suitable DMA available.\n");\r\n}\r\nr = pci_set_consistent_dma_mask(rdev->pdev, DMA_BIT_MASK(dma_bits));\r\nif (r) {\r\npci_set_consistent_dma_mask(rdev->pdev, DMA_BIT_MASK(32));\r\nprintk(KERN_WARNING "radeon: No coherent DMA available.\n");\r\n}\r\nspin_lock_init(&rdev->mmio_idx_lock);\r\nspin_lock_init(&rdev->smc_idx_lock);\r\nspin_lock_init(&rdev->pll_idx_lock);\r\nspin_lock_init(&rdev->mc_idx_lock);\r\nspin_lock_init(&rdev->pcie_idx_lock);\r\nspin_lock_init(&rdev->pciep_idx_lock);\r\nspin_lock_init(&rdev->pif_idx_lock);\r\nspin_lock_init(&rdev->cg_idx_lock);\r\nspin_lock_init(&rdev->uvd_idx_lock);\r\nspin_lock_init(&rdev->rcu_idx_lock);\r\nspin_lock_init(&rdev->didt_idx_lock);\r\nspin_lock_init(&rdev->end_idx_lock);\r\nif (rdev->family >= CHIP_BONAIRE) {\r\nrdev->rmmio_base = pci_resource_start(rdev->pdev, 5);\r\nrdev->rmmio_size = pci_resource_len(rdev->pdev, 5);\r\n} else {\r\nrdev->rmmio_base = pci_resource_start(rdev->pdev, 2);\r\nrdev->rmmio_size = pci_resource_len(rdev->pdev, 2);\r\n}\r\nrdev->rmmio = ioremap(rdev->rmmio_base, rdev->rmmio_size);\r\nif (rdev->rmmio == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nDRM_INFO("register mmio base: 0x%08X\n", (uint32_t)rdev->rmmio_base);\r\nDRM_INFO("register mmio size: %u\n", (unsigned)rdev->rmmio_size);\r\nif (rdev->family >= CHIP_BONAIRE)\r\nradeon_doorbell_init(rdev);\r\nfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\r\nif (pci_resource_flags(rdev->pdev, i) & IORESOURCE_IO) {\r\nrdev->rio_mem_size = pci_resource_len(rdev->pdev, i);\r\nrdev->rio_mem = pci_iomap(rdev->pdev, i, rdev->rio_mem_size);\r\nbreak;\r\n}\r\n}\r\nif (rdev->rio_mem == NULL)\r\nDRM_ERROR("Unable to find PCI I/O BAR\n");\r\nif (rdev->flags & RADEON_IS_PX)\r\nradeon_device_handle_px_quirks(rdev);\r\nvga_client_register(rdev->pdev, rdev, NULL, radeon_vga_set_decode);\r\nif (rdev->flags & RADEON_IS_PX)\r\nruntime = true;\r\nvga_switcheroo_register_client(rdev->pdev, &radeon_switcheroo_ops, runtime);\r\nif (runtime)\r\nvga_switcheroo_init_domain_pm_ops(rdev->dev, &rdev->vga_pm_domain);\r\nr = radeon_init(rdev);\r\nif (r)\r\ngoto failed;\r\nr = radeon_gem_debugfs_init(rdev);\r\nif (r) {\r\nDRM_ERROR("registering gem debugfs failed (%d).\n", r);\r\n}\r\nif (rdev->flags & RADEON_IS_AGP && !rdev->accel_working) {\r\nradeon_asic_reset(rdev);\r\nradeon_fini(rdev);\r\nradeon_agp_disable(rdev);\r\nr = radeon_init(rdev);\r\nif (r)\r\ngoto failed;\r\n}\r\nr = radeon_ib_ring_tests(rdev);\r\nif (r)\r\nDRM_ERROR("ib ring test failed (%d).\n", r);\r\nif ((radeon_testing & 1)) {\r\nif (rdev->accel_working)\r\nradeon_test_moves(rdev);\r\nelse\r\nDRM_INFO("radeon: acceleration disabled, skipping move tests\n");\r\n}\r\nif ((radeon_testing & 2)) {\r\nif (rdev->accel_working)\r\nradeon_test_syncing(rdev);\r\nelse\r\nDRM_INFO("radeon: acceleration disabled, skipping sync tests\n");\r\n}\r\nif (radeon_benchmarking) {\r\nif (rdev->accel_working)\r\nradeon_benchmark(rdev, radeon_benchmarking);\r\nelse\r\nDRM_INFO("radeon: acceleration disabled, skipping benchmarks\n");\r\n}\r\nreturn 0;\r\nfailed:\r\nif (runtime)\r\nvga_switcheroo_fini_domain_pm_ops(rdev->dev);\r\nreturn r;\r\n}\r\nvoid radeon_device_fini(struct radeon_device *rdev)\r\n{\r\nDRM_INFO("radeon: finishing device.\n");\r\nrdev->shutdown = true;\r\nradeon_bo_evict_vram(rdev);\r\nradeon_fini(rdev);\r\nvga_switcheroo_unregister_client(rdev->pdev);\r\nif (rdev->flags & RADEON_IS_PX)\r\nvga_switcheroo_fini_domain_pm_ops(rdev->dev);\r\nvga_client_register(rdev->pdev, NULL, NULL, NULL);\r\nif (rdev->rio_mem)\r\npci_iounmap(rdev->pdev, rdev->rio_mem);\r\nrdev->rio_mem = NULL;\r\niounmap(rdev->rmmio);\r\nrdev->rmmio = NULL;\r\nif (rdev->family >= CHIP_BONAIRE)\r\nradeon_doorbell_fini(rdev);\r\nradeon_debugfs_remove_files(rdev);\r\n}\r\nint radeon_suspend_kms(struct drm_device *dev, bool suspend, bool fbcon)\r\n{\r\nstruct radeon_device *rdev;\r\nstruct drm_crtc *crtc;\r\nstruct drm_connector *connector;\r\nint i, r;\r\nif (dev == NULL || dev->dev_private == NULL) {\r\nreturn -ENODEV;\r\n}\r\nrdev = dev->dev_private;\r\nif (dev->switch_power_state == DRM_SWITCH_POWER_OFF)\r\nreturn 0;\r\ndrm_kms_helper_poll_disable(dev);\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\ndrm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);\r\n}\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct radeon_framebuffer *rfb = to_radeon_framebuffer(crtc->primary->fb);\r\nstruct radeon_bo *robj;\r\nif (rfb == NULL || rfb->obj == NULL) {\r\ncontinue;\r\n}\r\nrobj = gem_to_radeon_bo(rfb->obj);\r\nif (!radeon_fbdev_robj_is_fb(rdev, robj)) {\r\nr = radeon_bo_reserve(robj, false);\r\nif (r == 0) {\r\nradeon_bo_unpin(robj);\r\nradeon_bo_unreserve(robj);\r\n}\r\n}\r\n}\r\nradeon_bo_evict_vram(rdev);\r\nfor (i = 0; i < RADEON_NUM_RINGS; i++) {\r\nr = radeon_fence_wait_empty(rdev, i);\r\nif (r) {\r\nradeon_fence_driver_force_completion(rdev, i);\r\n}\r\n}\r\nradeon_save_bios_scratch_regs(rdev);\r\nradeon_suspend(rdev);\r\nradeon_hpd_fini(rdev);\r\nradeon_bo_evict_vram(rdev);\r\nradeon_agp_suspend(rdev);\r\npci_save_state(dev->pdev);\r\nif (suspend) {\r\npci_disable_device(dev->pdev);\r\npci_set_power_state(dev->pdev, PCI_D3hot);\r\n}\r\nif (fbcon) {\r\nconsole_lock();\r\nradeon_fbdev_set_suspend(rdev, 1);\r\nconsole_unlock();\r\n}\r\nreturn 0;\r\n}\r\nint radeon_resume_kms(struct drm_device *dev, bool resume, bool fbcon)\r\n{\r\nstruct drm_connector *connector;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nint r;\r\nif (dev->switch_power_state == DRM_SWITCH_POWER_OFF)\r\nreturn 0;\r\nif (fbcon) {\r\nconsole_lock();\r\n}\r\nif (resume) {\r\npci_set_power_state(dev->pdev, PCI_D0);\r\npci_restore_state(dev->pdev);\r\nif (pci_enable_device(dev->pdev)) {\r\nif (fbcon)\r\nconsole_unlock();\r\nreturn -1;\r\n}\r\n}\r\nradeon_agp_resume(rdev);\r\nradeon_resume(rdev);\r\nr = radeon_ib_ring_tests(rdev);\r\nif (r)\r\nDRM_ERROR("ib ring test failed (%d).\n", r);\r\nif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled) {\r\nr = radeon_pm_late_init(rdev);\r\nif (r) {\r\nrdev->pm.dpm_enabled = false;\r\nDRM_ERROR("radeon_pm_late_init failed, disabling dpm\n");\r\n}\r\n} else {\r\nradeon_pm_resume(rdev);\r\n}\r\nradeon_restore_bios_scratch_regs(rdev);\r\nif (rdev->is_atom_bios) {\r\nradeon_atom_encoder_init(rdev);\r\nradeon_atom_disp_eng_pll_init(rdev);\r\nif (rdev->mode_info.bl_encoder) {\r\nu8 bl_level = radeon_get_backlight_level(rdev,\r\nrdev->mode_info.bl_encoder);\r\nradeon_set_backlight_level(rdev, rdev->mode_info.bl_encoder,\r\nbl_level);\r\n}\r\n}\r\nradeon_hpd_init(rdev);\r\nif (fbcon) {\r\ndrm_helper_resume_force_mode(dev);\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\ndrm_helper_connector_dpms(connector, DRM_MODE_DPMS_ON);\r\n}\r\n}\r\ndrm_kms_helper_poll_enable(dev);\r\nif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled)\r\nradeon_pm_compute_clocks(rdev);\r\nif (fbcon) {\r\nradeon_fbdev_set_suspend(rdev, 0);\r\nconsole_unlock();\r\n}\r\nreturn 0;\r\n}\r\nint radeon_gpu_reset(struct radeon_device *rdev)\r\n{\r\nunsigned ring_sizes[RADEON_NUM_RINGS];\r\nuint32_t *ring_data[RADEON_NUM_RINGS];\r\nbool saved = false;\r\nint i, r;\r\nint resched;\r\ndown_write(&rdev->exclusive_lock);\r\nif (!rdev->needs_reset) {\r\nup_write(&rdev->exclusive_lock);\r\nreturn 0;\r\n}\r\nradeon_save_bios_scratch_regs(rdev);\r\nresched = ttm_bo_lock_delayed_workqueue(&rdev->mman.bdev);\r\nradeon_suspend(rdev);\r\nradeon_hpd_fini(rdev);\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nring_sizes[i] = radeon_ring_backup(rdev, &rdev->ring[i],\r\n&ring_data[i]);\r\nif (ring_sizes[i]) {\r\nsaved = true;\r\ndev_info(rdev->dev, "Saved %d dwords of commands "\r\n"on ring %d.\n", ring_sizes[i], i);\r\n}\r\n}\r\nr = radeon_asic_reset(rdev);\r\nif (!r) {\r\ndev_info(rdev->dev, "GPU reset succeeded, trying to resume\n");\r\nradeon_resume(rdev);\r\n}\r\nradeon_restore_bios_scratch_regs(rdev);\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nif (!r && ring_data[i]) {\r\nradeon_ring_restore(rdev, &rdev->ring[i],\r\nring_sizes[i], ring_data[i]);\r\n} else {\r\nradeon_fence_driver_force_completion(rdev, i);\r\nkfree(ring_data[i]);\r\n}\r\n}\r\nif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled) {\r\nr = radeon_pm_late_init(rdev);\r\nif (r) {\r\nrdev->pm.dpm_enabled = false;\r\nDRM_ERROR("radeon_pm_late_init failed, disabling dpm\n");\r\n}\r\n} else {\r\nradeon_pm_resume(rdev);\r\n}\r\nif (rdev->is_atom_bios) {\r\nradeon_atom_encoder_init(rdev);\r\nradeon_atom_disp_eng_pll_init(rdev);\r\nif (rdev->mode_info.bl_encoder) {\r\nu8 bl_level = radeon_get_backlight_level(rdev,\r\nrdev->mode_info.bl_encoder);\r\nradeon_set_backlight_level(rdev, rdev->mode_info.bl_encoder,\r\nbl_level);\r\n}\r\n}\r\nradeon_hpd_init(rdev);\r\nttm_bo_unlock_delayed_workqueue(&rdev->mman.bdev, resched);\r\nrdev->in_reset = true;\r\nrdev->needs_reset = false;\r\ndowngrade_write(&rdev->exclusive_lock);\r\ndrm_helper_resume_force_mode(rdev->ddev);\r\nif ((rdev->pm.pm_method == PM_METHOD_DPM) && rdev->pm.dpm_enabled)\r\nradeon_pm_compute_clocks(rdev);\r\nif (!r) {\r\nr = radeon_ib_ring_tests(rdev);\r\nif (r && saved)\r\nr = -EAGAIN;\r\n} else {\r\ndev_info(rdev->dev, "GPU reset failed\n");\r\n}\r\nrdev->needs_reset = r == -EAGAIN;\r\nrdev->in_reset = false;\r\nup_read(&rdev->exclusive_lock);\r\nreturn r;\r\n}\r\nint radeon_debugfs_add_files(struct radeon_device *rdev,\r\nstruct drm_info_list *files,\r\nunsigned nfiles)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < rdev->debugfs_count; i++) {\r\nif (rdev->debugfs[i].files == files) {\r\nreturn 0;\r\n}\r\n}\r\ni = rdev->debugfs_count + 1;\r\nif (i > RADEON_DEBUGFS_MAX_COMPONENTS) {\r\nDRM_ERROR("Reached maximum number of debugfs components.\n");\r\nDRM_ERROR("Report so we increase "\r\n"RADEON_DEBUGFS_MAX_COMPONENTS.\n");\r\nreturn -EINVAL;\r\n}\r\nrdev->debugfs[rdev->debugfs_count].files = files;\r\nrdev->debugfs[rdev->debugfs_count].num_files = nfiles;\r\nrdev->debugfs_count = i;\r\n#if defined(CONFIG_DEBUG_FS)\r\ndrm_debugfs_create_files(files, nfiles,\r\nrdev->ddev->control->debugfs_root,\r\nrdev->ddev->control);\r\ndrm_debugfs_create_files(files, nfiles,\r\nrdev->ddev->primary->debugfs_root,\r\nrdev->ddev->primary);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void radeon_debugfs_remove_files(struct radeon_device *rdev)\r\n{\r\n#if defined(CONFIG_DEBUG_FS)\r\nunsigned i;\r\nfor (i = 0; i < rdev->debugfs_count; i++) {\r\ndrm_debugfs_remove_files(rdev->debugfs[i].files,\r\nrdev->debugfs[i].num_files,\r\nrdev->ddev->control);\r\ndrm_debugfs_remove_files(rdev->debugfs[i].files,\r\nrdev->debugfs[i].num_files,\r\nrdev->ddev->primary);\r\n}\r\n#endif\r\n}\r\nint radeon_debugfs_init(struct drm_minor *minor)\r\n{\r\nreturn 0;\r\n}\r\nvoid radeon_debugfs_cleanup(struct drm_minor *minor)\r\n{\r\n}
