static int ehci_ci_portpower(struct usb_hcd *hcd, int portnum, bool enable)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct ehci_ci_priv *priv = (struct ehci_ci_priv *)ehci->priv;\r\nstruct device *dev = hcd->self.controller;\r\nstruct ci_hdrc *ci = dev_get_drvdata(dev);\r\nint ret = 0;\r\nint port = HCS_N_PORTS(ehci->hcs_params);\r\nif (priv->reg_vbus && !ci_otg_is_fsm_mode(ci)) {\r\nif (port > 1) {\r\ndev_warn(dev,\r\n"Not support multi-port regulator control\n");\r\nreturn 0;\r\n}\r\nif (enable)\r\nret = regulator_enable(priv->reg_vbus);\r\nelse\r\nret = regulator_disable(priv->reg_vbus);\r\nif (ret) {\r\ndev_err(dev,\r\n"Failed to %s vbus regulator, ret=%d\n",\r\nenable ? "enable" : "disable", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t host_irq(struct ci_hdrc *ci)\r\n{\r\nreturn usb_hcd_irq(ci->irq, ci->hcd);\r\n}\r\nstatic int host_start(struct ci_hdrc *ci)\r\n{\r\nstruct usb_hcd *hcd;\r\nstruct ehci_hcd *ehci;\r\nstruct ehci_ci_priv *priv;\r\nint ret;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nhcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\r\nif (!hcd)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(ci->dev, ci);\r\nhcd->rsrc_start = ci->hw_bank.phys;\r\nhcd->rsrc_len = ci->hw_bank.size;\r\nhcd->regs = ci->hw_bank.abs;\r\nhcd->has_tt = 1;\r\nhcd->power_budget = ci->platdata->power_budget;\r\nhcd->tpl_support = ci->platdata->tpl_support;\r\nif (ci->phy)\r\nhcd->phy = ci->phy;\r\nelse\r\nhcd->usb_phy = ci->usb_phy;\r\nehci = hcd_to_ehci(hcd);\r\nehci->caps = ci->hw_bank.cap;\r\nehci->has_hostpc = ci->hw_bank.lpm;\r\nehci->has_tdi_phy_lpm = ci->hw_bank.lpm;\r\nehci->imx28_write_fix = ci->imx28_write_fix;\r\npriv = (struct ehci_ci_priv *)ehci->priv;\r\npriv->reg_vbus = NULL;\r\nif (ci->platdata->reg_vbus)\r\npriv->reg_vbus = ci->platdata->reg_vbus;\r\nret = usb_add_hcd(hcd, 0, 0);\r\nif (ret) {\r\ngoto put_hcd;\r\n} else {\r\nstruct usb_otg *otg = &ci->otg;\r\nci->hcd = hcd;\r\nif (ci_otg_is_fsm_mode(ci)) {\r\notg->host = &hcd->self;\r\nhcd->self.otg_port = 1;\r\n}\r\n}\r\nif (ci->platdata->flags & CI_HDRC_DISABLE_STREAMING)\r\nhw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);\r\nreturn ret;\r\nput_hcd:\r\nusb_put_hcd(hcd);\r\nreturn ret;\r\n}\r\nstatic void host_stop(struct ci_hdrc *ci)\r\n{\r\nstruct usb_hcd *hcd = ci->hcd;\r\nif (hcd) {\r\nusb_remove_hcd(hcd);\r\nusb_put_hcd(hcd);\r\n}\r\n}\r\nvoid ci_hdrc_host_destroy(struct ci_hdrc *ci)\r\n{\r\nif (ci->role == CI_ROLE_HOST && ci->hcd)\r\nhost_stop(ci);\r\n}\r\nint ci_hdrc_host_init(struct ci_hdrc *ci)\r\n{\r\nstruct ci_role_driver *rdrv;\r\nif (!hw_read(ci, CAP_DCCPARAMS, DCCPARAMS_HC))\r\nreturn -ENXIO;\r\nrdrv = devm_kzalloc(ci->dev, sizeof(struct ci_role_driver), GFP_KERNEL);\r\nif (!rdrv)\r\nreturn -ENOMEM;\r\nrdrv->start = host_start;\r\nrdrv->stop = host_stop;\r\nrdrv->irq = host_irq;\r\nrdrv->name = "host";\r\nci->roles[CI_ROLE_HOST] = rdrv;\r\nehci_init_driver(&ci_ehci_hc_driver, &ehci_ci_overrides);\r\nreturn 0;\r\n}
