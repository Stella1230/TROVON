void ima_free_template_entry(struct ima_template_entry *entry)\r\n{\r\nint i;\r\nfor (i = 0; i < entry->template_desc->num_fields; i++)\r\nkfree(entry->template_data[i].data);\r\nkfree(entry);\r\n}\r\nint ima_alloc_init_template(struct integrity_iint_cache *iint,\r\nstruct file *file, const unsigned char *filename,\r\nstruct evm_ima_xattr_data *xattr_value,\r\nint xattr_len, struct ima_template_entry **entry)\r\n{\r\nstruct ima_template_desc *template_desc = ima_template_desc_current();\r\nint i, result = 0;\r\n*entry = kzalloc(sizeof(**entry) + template_desc->num_fields *\r\nsizeof(struct ima_field_data), GFP_NOFS);\r\nif (!*entry)\r\nreturn -ENOMEM;\r\n(*entry)->template_desc = template_desc;\r\nfor (i = 0; i < template_desc->num_fields; i++) {\r\nstruct ima_template_field *field = template_desc->fields[i];\r\nu32 len;\r\nresult = field->field_init(iint, file, filename,\r\nxattr_value, xattr_len,\r\n&((*entry)->template_data[i]));\r\nif (result != 0)\r\ngoto out;\r\nlen = (*entry)->template_data[i].len;\r\n(*entry)->template_data_len += sizeof(len);\r\n(*entry)->template_data_len += len;\r\n}\r\nreturn 0;\r\nout:\r\nima_free_template_entry(*entry);\r\n*entry = NULL;\r\nreturn result;\r\n}\r\nint ima_store_template(struct ima_template_entry *entry,\r\nint violation, struct inode *inode,\r\nconst unsigned char *filename)\r\n{\r\nstatic const char op[] = "add_template_measure";\r\nstatic const char audit_cause[] = "hashing_error";\r\nchar *template_name = entry->template_desc->name;\r\nint result;\r\nstruct {\r\nstruct ima_digest_data hdr;\r\nchar digest[TPM_DIGEST_SIZE];\r\n} hash;\r\nif (!violation) {\r\nint num_fields = entry->template_desc->num_fields;\r\nhash.hdr.algo = HASH_ALGO_SHA1;\r\nresult = ima_calc_field_array_hash(&entry->template_data[0],\r\nentry->template_desc,\r\nnum_fields, &hash.hdr);\r\nif (result < 0) {\r\nintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,\r\ntemplate_name, op,\r\naudit_cause, result, 0);\r\nreturn result;\r\n}\r\nmemcpy(entry->digest, hash.hdr.digest, hash.hdr.length);\r\n}\r\nresult = ima_add_template_entry(entry, violation, op, inode, filename);\r\nreturn result;\r\n}\r\nvoid ima_add_violation(struct file *file, const unsigned char *filename,\r\nconst char *op, const char *cause)\r\n{\r\nstruct ima_template_entry *entry;\r\nstruct inode *inode = file_inode(file);\r\nint violation = 1;\r\nint result;\r\natomic_long_inc(&ima_htable.violations);\r\nresult = ima_alloc_init_template(NULL, file, filename,\r\nNULL, 0, &entry);\r\nif (result < 0) {\r\nresult = -ENOMEM;\r\ngoto err_out;\r\n}\r\nresult = ima_store_template(entry, violation, inode, filename);\r\nif (result < 0)\r\nima_free_template_entry(entry);\r\nerr_out:\r\nintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\r\nop, cause, result, 0);\r\n}\r\nint ima_get_action(struct inode *inode, int mask, int function)\r\n{\r\nint flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE;\r\nflags &= ima_policy_flag;\r\nreturn ima_match_policy(inode, function, mask, flags);\r\n}\r\nint ima_collect_measurement(struct integrity_iint_cache *iint,\r\nstruct file *file,\r\nstruct evm_ima_xattr_data **xattr_value,\r\nint *xattr_len)\r\n{\r\nconst char *audit_cause = "failed";\r\nstruct inode *inode = file_inode(file);\r\nconst char *filename = file->f_path.dentry->d_name.name;\r\nint result = 0;\r\nstruct {\r\nstruct ima_digest_data hdr;\r\nchar digest[IMA_MAX_DIGEST_SIZE];\r\n} hash;\r\nif (xattr_value)\r\n*xattr_len = ima_read_xattr(file->f_path.dentry, xattr_value);\r\nif (!(iint->flags & IMA_COLLECTED)) {\r\nu64 i_version = file_inode(file)->i_version;\r\nif (file->f_flags & O_DIRECT) {\r\naudit_cause = "failed(directio)";\r\nresult = -EACCES;\r\ngoto out;\r\n}\r\nhash.hdr.algo = ima_hash_algo;\r\nif (xattr_value)\r\nima_get_hash_algo(*xattr_value, *xattr_len, &hash.hdr);\r\nresult = ima_calc_file_hash(file, &hash.hdr);\r\nif (!result) {\r\nint length = sizeof(hash.hdr) + hash.hdr.length;\r\nvoid *tmpbuf = krealloc(iint->ima_hash, length,\r\nGFP_NOFS);\r\nif (tmpbuf) {\r\niint->ima_hash = tmpbuf;\r\nmemcpy(iint->ima_hash, &hash, length);\r\niint->version = i_version;\r\niint->flags |= IMA_COLLECTED;\r\n} else\r\nresult = -ENOMEM;\r\n}\r\n}\r\nout:\r\nif (result)\r\nintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,\r\nfilename, "collect_data", audit_cause,\r\nresult, 0);\r\nreturn result;\r\n}\r\nvoid ima_store_measurement(struct integrity_iint_cache *iint,\r\nstruct file *file, const unsigned char *filename,\r\nstruct evm_ima_xattr_data *xattr_value,\r\nint xattr_len)\r\n{\r\nstatic const char op[] = "add_template_measure";\r\nstatic const char audit_cause[] = "ENOMEM";\r\nint result = -ENOMEM;\r\nstruct inode *inode = file_inode(file);\r\nstruct ima_template_entry *entry;\r\nint violation = 0;\r\nif (iint->flags & IMA_MEASURED)\r\nreturn;\r\nresult = ima_alloc_init_template(iint, file, filename,\r\nxattr_value, xattr_len, &entry);\r\nif (result < 0) {\r\nintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\r\nop, audit_cause, result, 0);\r\nreturn;\r\n}\r\nresult = ima_store_template(entry, violation, inode, filename);\r\nif (!result || result == -EEXIST)\r\niint->flags |= IMA_MEASURED;\r\nif (result < 0)\r\nima_free_template_entry(entry);\r\n}\r\nvoid ima_audit_measurement(struct integrity_iint_cache *iint,\r\nconst unsigned char *filename)\r\n{\r\nstruct audit_buffer *ab;\r\nchar hash[(iint->ima_hash->length * 2) + 1];\r\nconst char *algo_name = hash_algo_name[iint->ima_hash->algo];\r\nchar algo_hash[sizeof(hash) + strlen(algo_name) + 2];\r\nint i;\r\nif (iint->flags & IMA_AUDITED)\r\nreturn;\r\nfor (i = 0; i < iint->ima_hash->length; i++)\r\nhex_byte_pack(hash + (i * 2), iint->ima_hash->digest[i]);\r\nhash[i * 2] = '\0';\r\nab = audit_log_start(current->audit_context, GFP_KERNEL,\r\nAUDIT_INTEGRITY_RULE);\r\nif (!ab)\r\nreturn;\r\naudit_log_format(ab, "file=");\r\naudit_log_untrustedstring(ab, filename);\r\naudit_log_format(ab, " hash=");\r\nsnprintf(algo_hash, sizeof(algo_hash), "%s:%s", algo_name, hash);\r\naudit_log_untrustedstring(ab, algo_hash);\r\naudit_log_task_info(ab, current);\r\naudit_log_end(ab);\r\niint->flags |= IMA_AUDITED;\r\n}\r\nconst char *ima_d_path(struct path *path, char **pathbuf)\r\n{\r\nchar *pathname = NULL;\r\n*pathbuf = __getname();\r\nif (*pathbuf) {\r\npathname = d_absolute_path(path, *pathbuf, PATH_MAX);\r\nif (IS_ERR(pathname)) {\r\n__putname(*pathbuf);\r\n*pathbuf = NULL;\r\npathname = NULL;\r\n}\r\n}\r\nreturn pathname ?: (const char *)path->dentry->d_name.name;\r\n}
