int ll_xattr_init(void)\r\n{\r\nreturn lu_kmem_init(xattr_caches);\r\n}\r\nvoid ll_xattr_fini(void)\r\n{\r\nlu_kmem_fini(xattr_caches);\r\n}\r\nstatic void ll_xattr_cache_init(struct ll_inode_info *lli)\r\n{\r\nLASSERT(lli != NULL);\r\nINIT_LIST_HEAD(&lli->lli_xattrs);\r\nlli->lli_flags |= LLIF_XATTR_CACHE;\r\n}\r\nstatic int ll_xattr_cache_find(struct list_head *cache,\r\nconst char *xattr_name,\r\nstruct ll_xattr_entry **xattr)\r\n{\r\nstruct ll_xattr_entry *entry;\r\nlist_for_each_entry(entry, cache, xe_list) {\r\nif (xattr_name == NULL ||\r\nstrcmp(xattr_name, entry->xe_name) == 0) {\r\n*xattr = entry;\r\nCDEBUG(D_CACHE, "find: [%s]=%.*s\n",\r\nentry->xe_name, entry->xe_vallen,\r\nentry->xe_value);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENODATA;\r\n}\r\nstatic int ll_xattr_cache_add(struct list_head *cache,\r\nconst char *xattr_name,\r\nconst char *xattr_val,\r\nunsigned xattr_val_len)\r\n{\r\nstruct ll_xattr_entry *xattr;\r\nif (ll_xattr_cache_find(cache, xattr_name, &xattr) == 0) {\r\nCDEBUG(D_CACHE, "duplicate xattr: [%s]\n", xattr_name);\r\nreturn -EPROTO;\r\n}\r\nOBD_SLAB_ALLOC_PTR_GFP(xattr, xattr_kmem, GFP_NOFS);\r\nif (xattr == NULL) {\r\nCDEBUG(D_CACHE, "failed to allocate xattr\n");\r\nreturn -ENOMEM;\r\n}\r\nxattr->xe_name = kstrdup(xattr_name, GFP_NOFS);\r\nif (!xattr->xe_name) {\r\nCDEBUG(D_CACHE, "failed to alloc xattr name %u\n",\r\nxattr->xe_namelen);\r\ngoto err_name;\r\n}\r\nxattr->xe_value = kzalloc(xattr_val_len, GFP_NOFS);\r\nif (!xattr->xe_value) {\r\nCDEBUG(D_CACHE, "failed to alloc xattr value %d\n",\r\nxattr_val_len);\r\ngoto err_value;\r\n}\r\nmemcpy(xattr->xe_value, xattr_val, xattr_val_len);\r\nxattr->xe_vallen = xattr_val_len;\r\nlist_add(&xattr->xe_list, cache);\r\nCDEBUG(D_CACHE, "set: [%s]=%.*s\n", xattr_name,\r\nxattr_val_len, xattr_val);\r\nreturn 0;\r\nerr_value:\r\nOBD_FREE(xattr->xe_name, xattr->xe_namelen);\r\nerr_name:\r\nOBD_SLAB_FREE_PTR(xattr, xattr_kmem);\r\nreturn -ENOMEM;\r\n}\r\nstatic int ll_xattr_cache_del(struct list_head *cache,\r\nconst char *xattr_name)\r\n{\r\nstruct ll_xattr_entry *xattr;\r\nCDEBUG(D_CACHE, "del xattr: %s\n", xattr_name);\r\nif (ll_xattr_cache_find(cache, xattr_name, &xattr) == 0) {\r\nlist_del(&xattr->xe_list);\r\nOBD_FREE(xattr->xe_name, xattr->xe_namelen);\r\nOBD_FREE(xattr->xe_value, xattr->xe_vallen);\r\nOBD_SLAB_FREE_PTR(xattr, xattr_kmem);\r\nreturn 0;\r\n}\r\nreturn -ENODATA;\r\n}\r\nstatic int ll_xattr_cache_list(struct list_head *cache,\r\nchar *xld_buffer,\r\nint xld_size)\r\n{\r\nstruct ll_xattr_entry *xattr, *tmp;\r\nint xld_tail = 0;\r\nlist_for_each_entry_safe(xattr, tmp, cache, xe_list) {\r\nCDEBUG(D_CACHE, "list: buffer=%p[%d] name=%s\n",\r\nxld_buffer, xld_tail, xattr->xe_name);\r\nif (xld_buffer) {\r\nxld_size -= xattr->xe_namelen;\r\nif (xld_size < 0)\r\nbreak;\r\nmemcpy(&xld_buffer[xld_tail],\r\nxattr->xe_name, xattr->xe_namelen);\r\n}\r\nxld_tail += xattr->xe_namelen;\r\n}\r\nif (xld_size < 0)\r\nreturn -ERANGE;\r\nreturn xld_tail;\r\n}\r\nstatic int ll_xattr_cache_valid(struct ll_inode_info *lli)\r\n{\r\nreturn !!(lli->lli_flags & LLIF_XATTR_CACHE);\r\n}\r\nstatic int ll_xattr_cache_destroy_locked(struct ll_inode_info *lli)\r\n{\r\nif (!ll_xattr_cache_valid(lli))\r\nreturn 0;\r\nwhile (ll_xattr_cache_del(&lli->lli_xattrs, NULL) == 0)\r\n;\r\nlli->lli_flags &= ~LLIF_XATTR_CACHE;\r\nreturn 0;\r\n}\r\nint ll_xattr_cache_destroy(struct inode *inode)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nint rc;\r\ndown_write(&lli->lli_xattrs_list_rwsem);\r\nrc = ll_xattr_cache_destroy_locked(lli);\r\nup_write(&lli->lli_xattrs_list_rwsem);\r\nreturn rc;\r\n}\r\nstatic int ll_xattr_find_get_lock(struct inode *inode,\r\nstruct lookup_intent *oit,\r\nstruct ptlrpc_request **req)\r\n{\r\nldlm_mode_t mode;\r\nstruct lustre_handle lockh = { 0 };\r\nstruct md_op_data *op_data;\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct ldlm_enqueue_info einfo = { .ei_type = LDLM_IBITS,\r\n.ei_mode = it_to_lock_mode(oit),\r\n.ei_cb_bl = ll_md_blocking_ast,\r\n.ei_cb_cp = ldlm_completion_ast };\r\nstruct ll_sb_info *sbi = ll_i2sbi(inode);\r\nstruct obd_export *exp = sbi->ll_md_exp;\r\nint rc;\r\nmutex_lock(&lli->lli_xattrs_enq_lock);\r\nmode = ll_take_md_lock(inode, MDS_INODELOCK_XATTR, &lockh, 0, LCK_PR);\r\nif (mode != 0) {\r\noit->d.lustre.it_lock_handle = lockh.cookie;\r\noit->d.lustre.it_lock_mode = mode;\r\ngoto out;\r\n}\r\nop_data = ll_prep_md_op_data(NULL, inode, NULL, NULL, 0, 0,\r\nLUSTRE_OPC_ANY, NULL);\r\nif (IS_ERR(op_data)) {\r\nmutex_unlock(&lli->lli_xattrs_enq_lock);\r\nreturn PTR_ERR(op_data);\r\n}\r\nop_data->op_valid = OBD_MD_FLXATTR | OBD_MD_FLXATTRLS;\r\nrc = md_enqueue(exp, &einfo, oit, op_data, &lockh, NULL, 0, NULL, 0);\r\nll_finish_md_op_data(op_data);\r\nif (rc < 0) {\r\nCDEBUG(D_CACHE,\r\n"md_intent_lock failed with %d for fid "DFID"\n",\r\nrc, PFID(ll_inode2fid(inode)));\r\nmutex_unlock(&lli->lli_xattrs_enq_lock);\r\nreturn rc;\r\n}\r\n*req = (struct ptlrpc_request *)oit->d.lustre.it_data;\r\nout:\r\ndown_write(&lli->lli_xattrs_list_rwsem);\r\nmutex_unlock(&lli->lli_xattrs_enq_lock);\r\nreturn 0;\r\n}\r\nstatic int ll_xattr_cache_refill(struct inode *inode, struct lookup_intent *oit)\r\n{\r\nstruct ll_sb_info *sbi = ll_i2sbi(inode);\r\nstruct ptlrpc_request *req = NULL;\r\nconst char *xdata, *xval, *xtail, *xvtail;\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct mdt_body *body;\r\n__u32 *xsizes;\r\nint rc = 0, i;\r\nrc = ll_xattr_find_get_lock(inode, oit, &req);\r\nif (rc)\r\ngoto out_no_unlock;\r\nif (ll_xattr_cache_valid(lli)) {\r\nll_stats_ops_tally(sbi, LPROC_LL_GETXATTR_HITS, 1);\r\nrc = 0;\r\ngoto out_maybe_drop;\r\n}\r\nif (unlikely(req == NULL)) {\r\nCDEBUG(D_CACHE, "cancelled by a parallel getxattr\n");\r\nrc = -EIO;\r\ngoto out_maybe_drop;\r\n}\r\nif (oit->d.lustre.it_status < 0) {\r\nCDEBUG(D_CACHE, "getxattr intent returned %d for fid "DFID"\n",\r\noit->d.lustre.it_status, PFID(ll_inode2fid(inode)));\r\nrc = oit->d.lustre.it_status;\r\nif (rc == -ERANGE)\r\nrc = -EAGAIN;\r\ngoto out_destroy;\r\n}\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_MDT_BODY);\r\nif (body == NULL) {\r\nCERROR("no MDT BODY in the refill xattr reply\n");\r\nrc = -EPROTO;\r\ngoto out_destroy;\r\n}\r\nxdata = req_capsule_server_sized_get(&req->rq_pill, &RMF_EADATA,\r\nbody->eadatasize);\r\nxval = req_capsule_server_sized_get(&req->rq_pill, &RMF_EAVALS,\r\nbody->aclsize);\r\nxsizes = req_capsule_server_sized_get(&req->rq_pill, &RMF_EAVALS_LENS,\r\nbody->max_mdsize * sizeof(__u32));\r\nif (xdata == NULL || xval == NULL || xsizes == NULL) {\r\nCERROR("wrong setxattr reply\n");\r\nrc = -EPROTO;\r\ngoto out_destroy;\r\n}\r\nxtail = xdata + body->eadatasize;\r\nxvtail = xval + body->aclsize;\r\nCDEBUG(D_CACHE, "caching: xdata=%p xtail=%p\n", xdata, xtail);\r\nll_xattr_cache_init(lli);\r\nfor (i = 0; i < body->max_mdsize; i++) {\r\nCDEBUG(D_CACHE, "caching [%s]=%.*s\n", xdata, *xsizes, xval);\r\nif (memchr(xdata, 0, xtail - xdata) == NULL) {\r\nCERROR("xattr protocol violation (names are broken)\n");\r\nrc = -EPROTO;\r\n} else if (xval + *xsizes > xvtail) {\r\nCERROR("xattr protocol violation (vals are broken)\n");\r\nrc = -EPROTO;\r\n} else if (OBD_FAIL_CHECK(OBD_FAIL_LLITE_XATTR_ENOMEM)) {\r\nrc = -ENOMEM;\r\n} else if (!strcmp(xdata, XATTR_NAME_ACL_ACCESS)) {\r\nCDEBUG(D_CACHE, "not caching %s\n",\r\nXATTR_NAME_ACL_ACCESS);\r\nrc = 0;\r\n} else {\r\nrc = ll_xattr_cache_add(&lli->lli_xattrs, xdata, xval,\r\n*xsizes);\r\n}\r\nif (rc < 0) {\r\nll_xattr_cache_destroy_locked(lli);\r\ngoto out_destroy;\r\n}\r\nxdata += strlen(xdata) + 1;\r\nxval += *xsizes;\r\nxsizes++;\r\n}\r\nif (xdata != xtail || xval != xvtail)\r\nCERROR("a hole in xattr data\n");\r\nll_set_lock_data(sbi->ll_md_exp, inode, oit, NULL);\r\ngoto out_maybe_drop;\r\nout_maybe_drop:\r\nll_intent_drop_lock(oit);\r\nif (rc != 0)\r\nup_write(&lli->lli_xattrs_list_rwsem);\r\nout_no_unlock:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\nout_destroy:\r\nup_write(&lli->lli_xattrs_list_rwsem);\r\nldlm_lock_decref_and_cancel((struct lustre_handle *)\r\n&oit->d.lustre.it_lock_handle,\r\noit->d.lustre.it_lock_mode);\r\ngoto out_no_unlock;\r\n}\r\nint ll_xattr_cache_get(struct inode *inode,\r\nconst char *name,\r\nchar *buffer,\r\nsize_t size,\r\n__u64 valid)\r\n{\r\nstruct lookup_intent oit = { .it_op = IT_GETXATTR };\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nint rc = 0;\r\nLASSERT(!!(valid & OBD_MD_FLXATTR) ^ !!(valid & OBD_MD_FLXATTRLS));\r\ndown_read(&lli->lli_xattrs_list_rwsem);\r\nif (!ll_xattr_cache_valid(lli)) {\r\nup_read(&lli->lli_xattrs_list_rwsem);\r\nrc = ll_xattr_cache_refill(inode, &oit);\r\nif (rc)\r\nreturn rc;\r\ndowngrade_write(&lli->lli_xattrs_list_rwsem);\r\n} else {\r\nll_stats_ops_tally(ll_i2sbi(inode), LPROC_LL_GETXATTR_HITS, 1);\r\n}\r\nif (valid & OBD_MD_FLXATTR) {\r\nstruct ll_xattr_entry *xattr;\r\nrc = ll_xattr_cache_find(&lli->lli_xattrs, name, &xattr);\r\nif (rc == 0) {\r\nrc = xattr->xe_vallen;\r\nif (size != 0) {\r\nif (size >= xattr->xe_vallen)\r\nmemcpy(buffer, xattr->xe_value,\r\nxattr->xe_vallen);\r\nelse\r\nrc = -ERANGE;\r\n}\r\n}\r\n} else if (valid & OBD_MD_FLXATTRLS) {\r\nrc = ll_xattr_cache_list(&lli->lli_xattrs,\r\nsize ? buffer : NULL, size);\r\n}\r\ngoto out;\r\nout:\r\nup_read(&lli->lli_xattrs_list_rwsem);\r\nreturn rc;\r\n}
