static inline struct vip_buffer *to_vip_buffer(struct vb2_buffer *vb2)\r\n{\r\nreturn container_of(vb2, struct vip_buffer, vb);\r\n}\r\nstatic inline void reg_write(struct sta2x11_vip *vip, unsigned int reg, u32 val)\r\n{\r\niowrite32((val), (vip->iomem)+(reg));\r\n}\r\nstatic inline u32 reg_read(struct sta2x11_vip *vip, unsigned int reg)\r\n{\r\nreturn ioread32((vip->iomem)+(reg));\r\n}\r\nstatic void start_dma(struct sta2x11_vip *vip, struct vip_buffer *vip_buf)\r\n{\r\nunsigned long offset = 0;\r\nif (vip->format.field == V4L2_FIELD_INTERLACED)\r\noffset = vip->format.width * 2;\r\nspin_lock_irq(&vip->slock);\r\nreg_write(vip, DVP_CTL, reg_read(vip, DVP_CTL) | DVP_CTL_ENA);\r\nreg_write(vip, DVP_VTP, (u32)vip_buf->dma);\r\nreg_write(vip, DVP_VBP, (u32)vip_buf->dma + offset);\r\nspin_unlock_irq(&vip->slock);\r\n}\r\nstatic void vip_active_buf_next(struct sta2x11_vip *vip)\r\n{\r\nspin_lock(&vip->lock);\r\nif (list_empty(&vip->buffer_list)) {\r\nspin_unlock(&vip->lock);\r\nreturn;\r\n}\r\nvip->active = list_first_entry(&vip->buffer_list,\r\nstruct vip_buffer,\r\nlist);\r\nvip->tcount = 0;\r\nvip->bcount = 0;\r\nspin_unlock(&vip->lock);\r\nif (vb2_is_streaming(&vip->vb_vidq)) {\r\nstart_dma(vip, vip->active);\r\n}\r\n}\r\nstatic int queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct sta2x11_vip *vip = vb2_get_drv_priv(vq);\r\nif (!(*nbuffers) || *nbuffers < MAX_FRAMES)\r\n*nbuffers = MAX_FRAMES;\r\n*nplanes = 1;\r\nsizes[0] = vip->format.sizeimage;\r\nalloc_ctxs[0] = vip->alloc_ctx;\r\nvip->sequence = 0;\r\nvip->active = NULL;\r\nvip->tcount = 0;\r\nvip->bcount = 0;\r\nreturn 0;\r\n}\r\nstatic int buffer_init(struct vb2_buffer *vb)\r\n{\r\nstruct vip_buffer *vip_buf = to_vip_buffer(vb);\r\nvip_buf->dma = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nINIT_LIST_HEAD(&vip_buf->list);\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct sta2x11_vip *vip = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vip_buffer *vip_buf = to_vip_buffer(vb);\r\nunsigned long size;\r\nsize = vip->format.sizeimage;\r\nif (vb2_plane_size(vb, 0) < size) {\r\nv4l2_err(&vip->v4l2_dev, "buffer too small (%lu < %lu)\n",\r\nvb2_plane_size(vb, 0), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(&vip_buf->vb, 0, size);\r\nreturn 0;\r\n}\r\nstatic void buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct sta2x11_vip *vip = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vip_buffer *vip_buf = to_vip_buffer(vb);\r\nspin_lock(&vip->lock);\r\nlist_add_tail(&vip_buf->list, &vip->buffer_list);\r\nif (!vip->active) {\r\nvip->active = list_first_entry(&vip->buffer_list,\r\nstruct vip_buffer,\r\nlist);\r\nif (vb2_is_streaming(&vip->vb_vidq))\r\nstart_dma(vip, vip_buf);\r\n}\r\nspin_unlock(&vip->lock);\r\n}\r\nstatic void buffer_finish(struct vb2_buffer *vb)\r\n{\r\nstruct sta2x11_vip *vip = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vip_buffer *vip_buf = to_vip_buffer(vb);\r\nspin_lock(&vip->lock);\r\nlist_del_init(&vip_buf->list);\r\nspin_unlock(&vip->lock);\r\nif (vb2_is_streaming(vb->vb2_queue))\r\nvip_active_buf_next(vip);\r\n}\r\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct sta2x11_vip *vip = vb2_get_drv_priv(vq);\r\nspin_lock_irq(&vip->slock);\r\nreg_write(vip, DVP_ITM, DVP_IT_VSB | DVP_IT_VST);\r\nspin_unlock_irq(&vip->slock);\r\nif (count)\r\nstart_dma(vip, vip->active);\r\nreturn 0;\r\n}\r\nstatic void stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct sta2x11_vip *vip = vb2_get_drv_priv(vq);\r\nstruct vip_buffer *vip_buf, *node;\r\nreg_write(vip, DVP_CTL, reg_read(vip, DVP_CTL) & ~DVP_CTL_ENA);\r\nreg_write(vip, DVP_ITM, 0);\r\nspin_lock(&vip->lock);\r\nlist_for_each_entry_safe(vip_buf, node, &vip->buffer_list, list) {\r\nvb2_buffer_done(&vip_buf->vb, VB2_BUF_STATE_ERROR);\r\nlist_del(&vip_buf->list);\r\n}\r\nspin_unlock(&vip->lock);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct sta2x11_vip *vip = video_drvdata(file);\r\nstrcpy(cap->driver, KBUILD_MODNAME);\r\nstrcpy(cap->card, KBUILD_MODNAME);\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "PCI:%s",\r\npci_name(vip->pdev));\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *priv, v4l2_std_id std)\r\n{\r\nstruct sta2x11_vip *vip = video_drvdata(file);\r\nv4l2_std_id oldstd = vip->std, newstd;\r\nint status;\r\nif (V4L2_STD_ALL == std) {\r\nv4l2_subdev_call(vip->decoder, video, s_std, std);\r\nssleep(2);\r\nv4l2_subdev_call(vip->decoder, video, querystd, &newstd);\r\nv4l2_subdev_call(vip->decoder, video, g_input_status, &status);\r\nif (status & V4L2_IN_ST_NO_SIGNAL)\r\nreturn -EIO;\r\nstd = vip->std = newstd;\r\nif (oldstd != std) {\r\nif (V4L2_STD_525_60 & std)\r\nvip->format = formats_60[0];\r\nelse\r\nvip->format = formats_50[0];\r\n}\r\nreturn 0;\r\n}\r\nif (oldstd != std) {\r\nif (V4L2_STD_525_60 & std)\r\nvip->format = formats_60[0];\r\nelse\r\nvip->format = formats_50[0];\r\n}\r\nreturn v4l2_subdev_call(vip->decoder, video, s_std, std);\r\n}\r\nstatic int vidioc_g_std(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct sta2x11_vip *vip = video_drvdata(file);\r\n*std = vip->std;\r\nreturn 0;\r\n}\r\nstatic int vidioc_querystd(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct sta2x11_vip *vip = video_drvdata(file);\r\nreturn v4l2_subdev_call(vip->decoder, video, querystd, std);\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *inp)\r\n{\r\nif (inp->index > 1)\r\nreturn -EINVAL;\r\ninp->type = V4L2_INPUT_TYPE_CAMERA;\r\ninp->std = V4L2_STD_ALL;\r\nsprintf(inp->name, "Camera %u", inp->index);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct sta2x11_vip *vip = video_drvdata(file);\r\nint ret;\r\nif (i > 1)\r\nreturn -EINVAL;\r\nret = v4l2_subdev_call(vip->decoder, video, s_routing, i, 0, 0);\r\nif (!ret)\r\nvip->input = i;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct sta2x11_vip *vip = video_drvdata(file);\r\n*i = vip->input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index != 0)\r\nreturn -EINVAL;\r\nstrcpy(f->description, "4:2:2, packed, UYVY");\r\nf->pixelformat = V4L2_PIX_FMT_UYVY;\r\nf->flags = 0;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct sta2x11_vip *vip = video_drvdata(file);\r\nint interlace_lim;\r\nif (V4L2_PIX_FMT_UYVY != f->fmt.pix.pixelformat) {\r\nv4l2_warn(&vip->v4l2_dev, "Invalid format, only UYVY supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (V4L2_STD_525_60 & vip->std)\r\ninterlace_lim = 240;\r\nelse\r\ninterlace_lim = 288;\r\nswitch (f->fmt.pix.field) {\r\ndefault:\r\ncase V4L2_FIELD_ANY:\r\nif (interlace_lim < f->fmt.pix.height)\r\nf->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nelse\r\nf->fmt.pix.field = V4L2_FIELD_BOTTOM;\r\nbreak;\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\nif (interlace_lim < f->fmt.pix.height)\r\nf->fmt.pix.height = interlace_lim;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\nbreak;\r\n}\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;\r\nf->fmt.pix.height &= ~1;\r\nif (2 * interlace_lim < f->fmt.pix.height)\r\nf->fmt.pix.height = 2 * interlace_lim;\r\nif (200 > f->fmt.pix.height)\r\nf->fmt.pix.height = 200;\r\nf->fmt.pix.width = 720;\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\r\nf->fmt.pix.sizeimage = f->fmt.pix.width * 2 * f->fmt.pix.height;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct sta2x11_vip *vip = video_drvdata(file);\r\nunsigned int t_stop, b_stop, pitch;\r\nint ret;\r\nret = vidioc_try_fmt_vid_cap(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nif (vb2_is_busy(&vip->vb_vidq)) {\r\nv4l2_err(&vip->v4l2_dev, "device busy\n");\r\nreturn -EBUSY;\r\n}\r\nvip->format = f->fmt.pix;\r\nswitch (vip->format.field) {\r\ncase V4L2_FIELD_INTERLACED:\r\nt_stop = ((vip->format.height / 2 - 1) << 16) |\r\n(2 * vip->format.width - 1);\r\nb_stop = t_stop;\r\npitch = 4 * vip->format.width;\r\nbreak;\r\ncase V4L2_FIELD_TOP:\r\nt_stop = ((vip->format.height - 1) << 16) |\r\n(2 * vip->format.width - 1);\r\nb_stop = (0 << 16) | (2 * vip->format.width - 1);\r\npitch = 2 * vip->format.width;\r\nbreak;\r\ncase V4L2_FIELD_BOTTOM:\r\nt_stop = (0 << 16) | (2 * vip->format.width - 1);\r\nb_stop = (vip->format.height << 16) |\r\n(2 * vip->format.width - 1);\r\npitch = 2 * vip->format.width;\r\nbreak;\r\ndefault:\r\nv4l2_err(&vip->v4l2_dev, "unknown field format\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irq(&vip->slock);\r\nreg_write(vip, DVP_TFO, 0);\r\nreg_write(vip, DVP_BFO, 0);\r\nreg_write(vip, DVP_TFS, t_stop);\r\nreg_write(vip, DVP_BFS, b_stop);\r\nreg_write(vip, DVP_VMP, pitch);\r\nspin_unlock_irq(&vip->slock);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct sta2x11_vip *vip = video_drvdata(file);\r\nf->fmt.pix = vip->format;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t vip_irq(int irq, struct sta2x11_vip *vip)\r\n{\r\nunsigned int status;\r\nstatus = reg_read(vip, DVP_ITS);\r\nif (!status)\r\nreturn IRQ_NONE;\r\nif (status & DVP_IT_FIFO)\r\nif (vip->overflow++ > 5)\r\npr_info("VIP: fifo overflow\n");\r\nif ((status & DVP_IT_VST) && (status & DVP_IT_VSB)) {\r\nreturn IRQ_HANDLED;\r\n}\r\nif (status & DVP_IT_VST)\r\nif ((++vip->tcount) < 2)\r\nreturn IRQ_HANDLED;\r\nif (status & DVP_IT_VSB) {\r\nvip->bcount++;\r\nreturn IRQ_HANDLED;\r\n}\r\nif (vip->active) {\r\nreg_write(vip, DVP_CTL, reg_read(vip, DVP_CTL) & ~DVP_CTL_ENA);\r\ndo_gettimeofday(&vip->active->vb.v4l2_buf.timestamp);\r\nvip->active->vb.v4l2_buf.sequence = vip->sequence++;\r\nvb2_buffer_done(&vip->active->vb, VB2_BUF_STATE_DONE);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sta2x11_vip_init_register(struct sta2x11_vip *vip)\r\n{\r\nspin_lock_irq(&vip->slock);\r\nreg_read(vip, DVP_ITS);\r\nreg_write(vip, DVP_HLFLN, DVP_HLFLN_SD);\r\nreg_write(vip, DVP_CTL, DVP_CTL_RST);\r\nreg_write(vip, DVP_CTL, 0);\r\nspin_unlock_irq(&vip->slock);\r\n}\r\nstatic void sta2x11_vip_clear_register(struct sta2x11_vip *vip)\r\n{\r\nspin_lock_irq(&vip->slock);\r\nreg_write(vip, DVP_ITM, 0);\r\nreg_write(vip, DVP_CTL, DVP_CTL_RST);\r\nreg_write(vip, DVP_CTL, 0);\r\nreg_read(vip, DVP_ITS);\r\nspin_unlock_irq(&vip->slock);\r\n}\r\nstatic int sta2x11_vip_init_buffer(struct sta2x11_vip *vip)\r\n{\r\nint err;\r\nerr = dma_set_coherent_mask(&vip->pdev->dev, DMA_BIT_MASK(29));\r\nif (err) {\r\nv4l2_err(&vip->v4l2_dev, "Cannot configure coherent mask");\r\nreturn err;\r\n}\r\nmemset(&vip->vb_vidq, 0, sizeof(struct vb2_queue));\r\nvip->vb_vidq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nvip->vb_vidq.io_modes = VB2_MMAP | VB2_READ;\r\nvip->vb_vidq.drv_priv = vip;\r\nvip->vb_vidq.buf_struct_size = sizeof(struct vip_buffer);\r\nvip->vb_vidq.ops = &vip_video_qops;\r\nvip->vb_vidq.mem_ops = &vb2_dma_contig_memops;\r\nerr = vb2_queue_init(&vip->vb_vidq);\r\nif (err)\r\nreturn err;\r\nINIT_LIST_HEAD(&vip->buffer_list);\r\nspin_lock_init(&vip->lock);\r\nvip->alloc_ctx = vb2_dma_contig_init_ctx(&vip->pdev->dev);\r\nif (IS_ERR(vip->alloc_ctx)) {\r\nv4l2_err(&vip->v4l2_dev, "Can't allocate buffer context");\r\nreturn PTR_ERR(vip->alloc_ctx);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sta2x11_vip_release_buffer(struct sta2x11_vip *vip)\r\n{\r\nvb2_dma_contig_cleanup_ctx(vip->alloc_ctx);\r\n}\r\nstatic int sta2x11_vip_init_controls(struct sta2x11_vip *vip)\r\n{\r\nv4l2_ctrl_handler_init(&vip->ctrl_hdl, 0);\r\nvip->v4l2_dev.ctrl_handler = &vip->ctrl_hdl;\r\nif (vip->ctrl_hdl.error) {\r\nint err = vip->ctrl_hdl.error;\r\nv4l2_ctrl_handler_free(&vip->ctrl_hdl);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vip_gpio_reserve(struct device *dev, int pin, int dir,\r\nconst char *name)\r\n{\r\nint ret;\r\nif (pin == -1)\r\nreturn 0;\r\nret = gpio_request(pin, name);\r\nif (ret) {\r\ndev_err(dev, "Failed to allocate pin %d (%s)\n", pin, name);\r\nreturn ret;\r\n}\r\nret = gpio_direction_output(pin, dir);\r\nif (ret) {\r\ndev_err(dev, "Failed to set direction for pin %d (%s)\n",\r\npin, name);\r\ngpio_free(pin);\r\nreturn ret;\r\n}\r\nret = gpio_export(pin, false);\r\nif (ret) {\r\ndev_err(dev, "Failed to export pin %d (%s)\n", pin, name);\r\ngpio_free(pin);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vip_gpio_release(struct device *dev, int pin, const char *name)\r\n{\r\nif (pin != -1) {\r\ndev_dbg(dev, "releasing pin %d (%s)\n", pin, name);\r\ngpio_unexport(pin);\r\ngpio_free(pin);\r\n}\r\n}\r\nstatic int sta2x11_vip_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint ret;\r\nstruct sta2x11_vip *vip;\r\nstruct vip_config *config;\r\nif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(26))) {\r\ndev_err(&pdev->dev, "26-bit DMA addressing not available\n");\r\nreturn -EINVAL;\r\n}\r\nret = pci_enable_device(pdev);\r\nif (ret)\r\nreturn ret;\r\nconfig = dev_get_platdata(&pdev->dev);\r\nif (!config) {\r\ndev_info(&pdev->dev, "VIP slot disabled\n");\r\nret = -EINVAL;\r\ngoto disable;\r\n}\r\nret = vip_gpio_reserve(&pdev->dev, config->pwr_pin, 0,\r\nconfig->pwr_name);\r\nif (ret)\r\ngoto disable;\r\nif (config->reset_pin >= 0) {\r\nret = vip_gpio_reserve(&pdev->dev, config->reset_pin, 0,\r\nconfig->reset_name);\r\nif (ret) {\r\nvip_gpio_release(&pdev->dev, config->pwr_pin,\r\nconfig->pwr_name);\r\ngoto disable;\r\n}\r\n}\r\nif (config->pwr_pin != -1) {\r\nusleep_range(5000, 25000);\r\nret = gpio_direction_output(config->pwr_pin, 1);\r\n}\r\nif (config->reset_pin != -1) {\r\nusleep_range(5000, 25000);\r\nret = gpio_direction_output(config->reset_pin, 1);\r\n}\r\nusleep_range(5000, 25000);\r\nvip = kzalloc(sizeof(struct sta2x11_vip), GFP_KERNEL);\r\nif (!vip) {\r\nret = -ENOMEM;\r\ngoto release_gpios;\r\n}\r\nvip->pdev = pdev;\r\nvip->std = V4L2_STD_PAL;\r\nvip->format = formats_50[0];\r\nvip->config = config;\r\nret = sta2x11_vip_init_controls(vip);\r\nif (ret)\r\ngoto free_mem;\r\nret = v4l2_device_register(&pdev->dev, &vip->v4l2_dev);\r\nif (ret)\r\ngoto free_mem;\r\ndev_dbg(&pdev->dev, "BAR #0 at 0x%lx 0x%lx irq %d\n",\r\n(unsigned long)pci_resource_start(pdev, 0),\r\n(unsigned long)pci_resource_len(pdev, 0), pdev->irq);\r\npci_set_master(pdev);\r\nret = pci_request_regions(pdev, KBUILD_MODNAME);\r\nif (ret)\r\ngoto unreg;\r\nvip->iomem = pci_iomap(pdev, 0, 0x100);\r\nif (!vip->iomem) {\r\nret = -ENOMEM;\r\ngoto release;\r\n}\r\npci_enable_msi(pdev);\r\nret = sta2x11_vip_init_buffer(vip);\r\nif (ret)\r\ngoto unmap;\r\nspin_lock_init(&vip->slock);\r\nret = request_irq(pdev->irq,\r\n(irq_handler_t) vip_irq,\r\nIRQF_SHARED, KBUILD_MODNAME, vip);\r\nif (ret) {\r\ndev_err(&pdev->dev, "request_irq failed\n");\r\nret = -ENODEV;\r\ngoto release_buf;\r\n}\r\nvip->video_dev = video_device_alloc();\r\nif (!vip->video_dev) {\r\nret = -ENOMEM;\r\ngoto release_irq;\r\n}\r\nvip->video_dev = &video_dev_template;\r\nvip->video_dev->v4l2_dev = &vip->v4l2_dev;\r\nvip->video_dev->queue = &vip->vb_vidq;\r\nvideo_set_drvdata(vip->video_dev, vip);\r\nret = video_register_device(vip->video_dev, VFL_TYPE_GRABBER, -1);\r\nif (ret)\r\ngoto vrelease;\r\nvip->adapter = i2c_get_adapter(vip->config->i2c_id);\r\nif (!vip->adapter) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev, "no I2C adapter found\n");\r\ngoto vunreg;\r\n}\r\nvip->decoder = v4l2_i2c_new_subdev(&vip->v4l2_dev, vip->adapter,\r\n"adv7180", vip->config->i2c_addr,\r\nNULL);\r\nif (!vip->decoder) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev, "no decoder found\n");\r\ngoto vunreg;\r\n}\r\ni2c_put_adapter(vip->adapter);\r\nv4l2_subdev_call(vip->decoder, core, init, 0);\r\nsta2x11_vip_init_register(vip);\r\ndev_info(&pdev->dev, "STA2X11 Video Input Port (VIP) loaded\n");\r\nreturn 0;\r\nvunreg:\r\nvideo_set_drvdata(vip->video_dev, NULL);\r\nvrelease:\r\nif (video_is_registered(vip->video_dev))\r\nvideo_unregister_device(vip->video_dev);\r\nelse\r\nvideo_device_release(vip->video_dev);\r\nrelease_irq:\r\nfree_irq(pdev->irq, vip);\r\nrelease_buf:\r\nsta2x11_vip_release_buffer(vip);\r\npci_disable_msi(pdev);\r\nunmap:\r\nvb2_queue_release(&vip->vb_vidq);\r\npci_iounmap(pdev, vip->iomem);\r\nrelease:\r\npci_release_regions(pdev);\r\nunreg:\r\nv4l2_device_unregister(&vip->v4l2_dev);\r\nfree_mem:\r\nkfree(vip);\r\nrelease_gpios:\r\nvip_gpio_release(&pdev->dev, config->reset_pin, config->reset_name);\r\nvip_gpio_release(&pdev->dev, config->pwr_pin, config->pwr_name);\r\ndisable:\r\nreturn ret;\r\n}\r\nstatic void sta2x11_vip_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pdev);\r\nstruct sta2x11_vip *vip =\r\ncontainer_of(v4l2_dev, struct sta2x11_vip, v4l2_dev);\r\nsta2x11_vip_clear_register(vip);\r\nvideo_set_drvdata(vip->video_dev, NULL);\r\nvideo_unregister_device(vip->video_dev);\r\nfree_irq(pdev->irq, vip);\r\npci_disable_msi(pdev);\r\nvb2_queue_release(&vip->vb_vidq);\r\npci_iounmap(pdev, vip->iomem);\r\npci_release_regions(pdev);\r\nv4l2_device_unregister(&vip->v4l2_dev);\r\nvip_gpio_release(&pdev->dev, vip->config->pwr_pin,\r\nvip->config->pwr_name);\r\nvip_gpio_release(&pdev->dev, vip->config->reset_pin,\r\nvip->config->reset_name);\r\nkfree(vip);\r\n}\r\nstatic int sta2x11_vip_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pdev);\r\nstruct sta2x11_vip *vip =\r\ncontainer_of(v4l2_dev, struct sta2x11_vip, v4l2_dev);\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&vip->slock, flags);\r\nvip->register_save_area[0] = reg_read(vip, DVP_CTL);\r\nreg_write(vip, DVP_CTL, vip->register_save_area[0] & DVP_CTL_DIS);\r\nvip->register_save_area[SAVE_COUNT] = reg_read(vip, DVP_ITM);\r\nreg_write(vip, DVP_ITM, 0);\r\nfor (i = 1; i < SAVE_COUNT; i++)\r\nvip->register_save_area[i] = reg_read(vip, 4 * i);\r\nfor (i = 0; i < AUX_COUNT; i++)\r\nvip->register_save_area[SAVE_COUNT + IRQ_COUNT + i] =\r\nreg_read(vip, registers_to_save[i]);\r\nspin_unlock_irqrestore(&vip->slock, flags);\r\npci_save_state(pdev);\r\nif (pci_set_power_state(pdev, pci_choose_state(pdev, state))) {\r\nvip->disabled = 1;\r\n}\r\npr_info("VIP: suspend\n");\r\nreturn 0;\r\n}\r\nstatic int sta2x11_vip_resume(struct pci_dev *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pdev);\r\nstruct sta2x11_vip *vip =\r\ncontainer_of(v4l2_dev, struct sta2x11_vip, v4l2_dev);\r\nunsigned long flags;\r\nint ret, i;\r\npr_info("VIP: resume\n");\r\nif (vip->disabled) {\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\npr_warn("VIP: Can't enable device.\n");\r\nreturn ret;\r\n}\r\nvip->disabled = 0;\r\n}\r\nret = pci_set_power_state(pdev, PCI_D0);\r\nif (ret) {\r\npr_warn("VIP: Can't enable device.\n");\r\nvip->disabled = 1;\r\nreturn ret;\r\n}\r\npci_restore_state(pdev);\r\nspin_lock_irqsave(&vip->slock, flags);\r\nfor (i = 1; i < SAVE_COUNT; i++)\r\nreg_write(vip, 4 * i, vip->register_save_area[i]);\r\nfor (i = 0; i < AUX_COUNT; i++)\r\nreg_write(vip, registers_to_save[i],\r\nvip->register_save_area[SAVE_COUNT + IRQ_COUNT + i]);\r\nreg_write(vip, DVP_CTL, vip->register_save_area[0]);\r\nreg_write(vip, DVP_ITM, vip->register_save_area[SAVE_COUNT]);\r\nspin_unlock_irqrestore(&vip->slock, flags);\r\nreturn 0;\r\n}\r\nstatic int __init sta2x11_vip_init_module(void)\r\n{\r\nreturn pci_register_driver(&sta2x11_vip_driver);\r\n}\r\nstatic void __exit sta2x11_vip_exit_module(void)\r\n{\r\npci_unregister_driver(&sta2x11_vip_driver);\r\n}
