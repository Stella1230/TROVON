static inline struct oz_hcd *oz_hcd_private(struct usb_hcd *hcd)\r\n{\r\nreturn (struct oz_hcd *)hcd->hcd_priv;\r\n}\r\nstatic int oz_get_port_from_addr(struct oz_hcd *ozhcd, u8 bus_addr)\r\n{\r\nint i;\r\nfor (i = 0; i < OZ_NB_PORTS; i++) {\r\nif (ozhcd->ports[i].bus_addr == bus_addr)\r\nreturn i;\r\n}\r\nreturn ozhcd->conn_port;\r\n}\r\nstatic struct oz_urb_link *oz_alloc_urb_link(void)\r\n{\r\nstruct oz_urb_link *urbl = NULL;\r\nunsigned long irq_state;\r\nspin_lock_irqsave(&g_link_lock, irq_state);\r\nif (g_link_pool) {\r\nurbl = container_of(g_link_pool, struct oz_urb_link, link);\r\ng_link_pool = urbl->link.next;\r\n--g_link_pool_size;\r\n}\r\nspin_unlock_irqrestore(&g_link_lock, irq_state);\r\nif (urbl == NULL)\r\nurbl = kmalloc(sizeof(struct oz_urb_link), GFP_ATOMIC);\r\nreturn urbl;\r\n}\r\nstatic void oz_free_urb_link(struct oz_urb_link *urbl)\r\n{\r\nif (urbl) {\r\nunsigned long irq_state;\r\nspin_lock_irqsave(&g_link_lock, irq_state);\r\nif (g_link_pool_size < OZ_MAX_LINK_POOL_SIZE) {\r\nurbl->link.next = g_link_pool;\r\ng_link_pool = &urbl->link;\r\nurbl = NULL;\r\ng_link_pool_size++;\r\n}\r\nspin_unlock_irqrestore(&g_link_lock, irq_state);\r\nkfree(urbl);\r\n}\r\n}\r\nstatic void oz_empty_link_pool(void)\r\n{\r\nstruct list_head *e;\r\nunsigned long irq_state;\r\nspin_lock_irqsave(&g_link_lock, irq_state);\r\ne = g_link_pool;\r\ng_link_pool = NULL;\r\ng_link_pool_size = 0;\r\nspin_unlock_irqrestore(&g_link_lock, irq_state);\r\nwhile (e) {\r\nstruct oz_urb_link *urbl =\r\ncontainer_of(e, struct oz_urb_link, link);\r\ne = e->next;\r\nkfree(urbl);\r\n}\r\n}\r\nstatic struct oz_endpoint *oz_ep_alloc(int buffer_size, gfp_t mem_flags)\r\n{\r\nstruct oz_endpoint *ep =\r\nkzalloc(sizeof(struct oz_endpoint)+buffer_size, mem_flags);\r\nif (ep) {\r\nINIT_LIST_HEAD(&ep->urb_list);\r\nINIT_LIST_HEAD(&ep->link);\r\nep->credit = -1;\r\nif (buffer_size) {\r\nep->buffer_size = buffer_size;\r\nep->buffer = (u8 *)(ep+1);\r\n}\r\n}\r\nreturn ep;\r\n}\r\nstatic struct oz_urb_link *oz_uncancel_urb(struct oz_hcd *ozhcd, struct urb *urb)\r\n{\r\nstruct oz_urb_link *urbl;\r\nstruct list_head *e;\r\nlist_for_each(e, &ozhcd->urb_cancel_list) {\r\nurbl = container_of(e, struct oz_urb_link, link);\r\nif (urb == urbl->urb) {\r\nlist_del_init(e);\r\nreturn urbl;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void oz_complete_urb(struct usb_hcd *hcd, struct urb *urb,\r\nint status)\r\n{\r\nstruct oz_hcd *ozhcd = oz_hcd_private(hcd);\r\nunsigned long irq_state;\r\nstruct oz_urb_link *cancel_urbl;\r\nspin_lock_irqsave(&g_tasklet_lock, irq_state);\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nurb->hcpriv = NULL;\r\ncancel_urbl = oz_uncancel_urb(ozhcd, urb);\r\nspin_unlock(&g_tasklet_lock);\r\nif (oz_forget_urb(urb)) {\r\noz_dbg(ON, "ERROR Unknown URB %p\n", urb);\r\n} else {\r\natomic_dec(&g_pending_urbs);\r\nusb_hcd_giveback_urb(hcd, urb, status);\r\n}\r\nspin_lock(&g_tasklet_lock);\r\nspin_unlock_irqrestore(&g_tasklet_lock, irq_state);\r\nif (cancel_urbl)\r\noz_free_urb_link(cancel_urbl);\r\n}\r\nstatic void oz_ep_free(struct oz_port *port, struct oz_endpoint *ep)\r\n{\r\nif (port) {\r\nstruct list_head list;\r\nstruct oz_hcd *ozhcd = port->ozhcd;\r\nINIT_LIST_HEAD(&list);\r\nif (ep->flags & OZ_F_EP_HAVE_STREAM)\r\noz_usb_stream_delete(port->hpd, ep->ep_num);\r\nspin_lock_bh(&ozhcd->hcd_lock);\r\nlist_replace_init(&ep->urb_list, &list);\r\nlist_splice_tail(&list, &ozhcd->orphanage);\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\n}\r\noz_dbg(ON, "Freeing endpoint memory\n");\r\nkfree(ep);\r\n}\r\nstatic void oz_complete_buffered_urb(struct oz_port *port,\r\nstruct oz_endpoint *ep,\r\nstruct urb *urb)\r\n{\r\nint data_len, available_space, copy_len;\r\ndata_len = ep->buffer[ep->out_ix];\r\nif (data_len <= urb->transfer_buffer_length)\r\navailable_space = data_len;\r\nelse\r\navailable_space = urb->transfer_buffer_length;\r\nif (++ep->out_ix == ep->buffer_size)\r\nep->out_ix = 0;\r\ncopy_len = ep->buffer_size - ep->out_ix;\r\nif (copy_len >= available_space)\r\ncopy_len = available_space;\r\nmemcpy(urb->transfer_buffer, &ep->buffer[ep->out_ix], copy_len);\r\nif (copy_len < available_space) {\r\nmemcpy((urb->transfer_buffer + copy_len), ep->buffer,\r\n(available_space - copy_len));\r\nep->out_ix = available_space - copy_len;\r\n} else {\r\nep->out_ix += copy_len;\r\n}\r\nurb->actual_length = available_space;\r\nif (ep->out_ix == ep->buffer_size)\r\nep->out_ix = 0;\r\nep->buffered_units--;\r\noz_dbg(ON, "Trying to give back buffered frame of size=%d\n",\r\navailable_space);\r\noz_complete_urb(port->ozhcd->hcd, urb, 0);\r\n}\r\nstatic int oz_enqueue_ep_urb(struct oz_port *port, u8 ep_addr, int in_dir,\r\nstruct urb *urb, u8 req_id)\r\n{\r\nstruct oz_urb_link *urbl;\r\nstruct oz_endpoint *ep = NULL;\r\nint err = 0;\r\nif (ep_addr >= OZ_NB_ENDPOINTS) {\r\noz_dbg(ON, "%s: Invalid endpoint number\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nurbl = oz_alloc_urb_link();\r\nif (!urbl)\r\nreturn -ENOMEM;\r\nurbl->submit_counter = 0;\r\nurbl->urb = urb;\r\nurbl->req_id = req_id;\r\nurbl->ep_num = ep_addr;\r\nspin_lock_bh(&port->ozhcd->hcd_lock);\r\nif (urb->unlinked) {\r\nspin_unlock_bh(&port->ozhcd->hcd_lock);\r\noz_dbg(ON, "urb %p unlinked so complete immediately\n", urb);\r\noz_complete_urb(port->ozhcd->hcd, urb, 0);\r\noz_free_urb_link(urbl);\r\nreturn 0;\r\n}\r\nif (in_dir)\r\nep = port->in_ep[ep_addr];\r\nelse\r\nep = port->out_ep[ep_addr];\r\nif (!ep) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nif (((ep->attrib & USB_ENDPOINT_XFERTYPE_MASK) == USB_ENDPOINT_XFER_INT)\r\n&& ep->buffered_units > 0) {\r\noz_free_urb_link(urbl);\r\nspin_unlock_bh(&port->ozhcd->hcd_lock);\r\noz_complete_buffered_urb(port, ep, urb);\r\nreturn 0;\r\n}\r\nif (port->hpd) {\r\nlist_add_tail(&urbl->link, &ep->urb_list);\r\nif (!in_dir && ep_addr && (ep->credit < 0)) {\r\ngetrawmonotonic(&ep->timestamp);\r\nep->credit = 0;\r\n}\r\n} else {\r\nerr = -EPIPE;\r\n}\r\nout:\r\nspin_unlock_bh(&port->ozhcd->hcd_lock);\r\nif (err)\r\noz_free_urb_link(urbl);\r\nreturn err;\r\n}\r\nstatic int oz_dequeue_ep_urb(struct oz_port *port, u8 ep_addr, int in_dir,\r\nstruct urb *urb)\r\n{\r\nstruct oz_urb_link *urbl = NULL;\r\nstruct oz_endpoint *ep;\r\nspin_lock_bh(&port->ozhcd->hcd_lock);\r\nif (in_dir)\r\nep = port->in_ep[ep_addr];\r\nelse\r\nep = port->out_ep[ep_addr];\r\nif (ep) {\r\nstruct list_head *e;\r\nlist_for_each(e, &ep->urb_list) {\r\nurbl = container_of(e, struct oz_urb_link, link);\r\nif (urbl->urb == urb) {\r\nlist_del_init(e);\r\nbreak;\r\n}\r\nurbl = NULL;\r\n}\r\n}\r\nspin_unlock_bh(&port->ozhcd->hcd_lock);\r\nif (urbl)\r\noz_free_urb_link(urbl);\r\nreturn urbl ? 0 : -EIDRM;\r\n}\r\nstatic struct urb *oz_find_urb_by_id(struct oz_port *port, int ep_ix,\r\nu8 req_id)\r\n{\r\nstruct oz_hcd *ozhcd = port->ozhcd;\r\nstruct urb *urb = NULL;\r\nstruct oz_urb_link *urbl;\r\nstruct oz_endpoint *ep;\r\nspin_lock_bh(&ozhcd->hcd_lock);\r\nep = port->out_ep[ep_ix];\r\nif (ep) {\r\nstruct list_head *e;\r\nlist_for_each(e, &ep->urb_list) {\r\nurbl = container_of(e, struct oz_urb_link, link);\r\nif (urbl->req_id == req_id) {\r\nurb = urbl->urb;\r\nlist_del_init(e);\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\nif (urb)\r\noz_free_urb_link(urbl);\r\nreturn urb;\r\n}\r\nstatic void oz_acquire_port(struct oz_port *port, void *hpd)\r\n{\r\nINIT_LIST_HEAD(&port->isoc_out_ep);\r\nINIT_LIST_HEAD(&port->isoc_in_ep);\r\nport->flags |= OZ_PORT_F_PRESENT | OZ_PORT_F_CHANGED;\r\nport->status |= USB_PORT_STAT_CONNECTION |\r\n(USB_PORT_STAT_C_CONNECTION << 16);\r\noz_usb_get(hpd);\r\nport->hpd = hpd;\r\n}\r\nstatic struct oz_hcd *oz_hcd_claim(void)\r\n{\r\nstruct oz_hcd *ozhcd;\r\nspin_lock_bh(&g_hcdlock);\r\nozhcd = g_ozhcd;\r\nif (ozhcd)\r\nusb_get_hcd(ozhcd->hcd);\r\nspin_unlock_bh(&g_hcdlock);\r\nreturn ozhcd;\r\n}\r\nstatic inline void oz_hcd_put(struct oz_hcd *ozhcd)\r\n{\r\nif (ozhcd)\r\nusb_put_hcd(ozhcd->hcd);\r\n}\r\nstruct oz_port *oz_hcd_pd_arrived(void *hpd)\r\n{\r\nint i;\r\nstruct oz_port *hport;\r\nstruct oz_hcd *ozhcd;\r\nstruct oz_endpoint *ep;\r\nozhcd = oz_hcd_claim();\r\nif (!ozhcd)\r\nreturn NULL;\r\nep = oz_ep_alloc(0, GFP_ATOMIC);\r\nif (!ep)\r\ngoto err_put;\r\nspin_lock_bh(&ozhcd->hcd_lock);\r\nif (ozhcd->conn_port >= 0)\r\ngoto err_unlock;\r\nfor (i = 0; i < OZ_NB_PORTS; i++) {\r\nstruct oz_port *port = &ozhcd->ports[i];\r\nspin_lock(&port->port_lock);\r\nif (!(port->flags & (OZ_PORT_F_PRESENT | OZ_PORT_F_CHANGED))) {\r\noz_acquire_port(port, hpd);\r\nspin_unlock(&port->port_lock);\r\nbreak;\r\n}\r\nspin_unlock(&port->port_lock);\r\n}\r\nif (i == OZ_NB_PORTS)\r\ngoto err_unlock;\r\nozhcd->conn_port = i;\r\nhport = &ozhcd->ports[i];\r\nhport->out_ep[0] = ep;\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\nif (ozhcd->flags & OZ_HDC_F_SUSPENDED)\r\nusb_hcd_resume_root_hub(ozhcd->hcd);\r\nusb_hcd_poll_rh_status(ozhcd->hcd);\r\noz_hcd_put(ozhcd);\r\nreturn hport;\r\nerr_unlock:\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\noz_ep_free(NULL, ep);\r\nerr_put:\r\noz_hcd_put(ozhcd);\r\nreturn NULL;\r\n}\r\nvoid oz_hcd_pd_departed(struct oz_port *port)\r\n{\r\nstruct oz_hcd *ozhcd;\r\nvoid *hpd;\r\nstruct oz_endpoint *ep = NULL;\r\nif (port == NULL) {\r\noz_dbg(ON, "%s: port = 0\n", __func__);\r\nreturn;\r\n}\r\nozhcd = port->ozhcd;\r\nif (ozhcd == NULL)\r\nreturn;\r\nspin_lock_bh(&ozhcd->hcd_lock);\r\nif ((ozhcd->conn_port >= 0) &&\r\n(port == &ozhcd->ports[ozhcd->conn_port])) {\r\noz_dbg(ON, "Clearing conn_port\n");\r\nozhcd->conn_port = -1;\r\n}\r\nspin_lock(&port->port_lock);\r\nport->flags |= OZ_PORT_F_DYING;\r\nspin_unlock(&port->port_lock);\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\noz_clean_endpoints_for_config(ozhcd->hcd, port);\r\nspin_lock_bh(&port->port_lock);\r\nhpd = port->hpd;\r\nport->hpd = NULL;\r\nport->bus_addr = 0xff;\r\nport->config_num = 0;\r\nport->flags &= ~(OZ_PORT_F_PRESENT | OZ_PORT_F_DYING);\r\nport->flags |= OZ_PORT_F_CHANGED;\r\nport->status &= ~(USB_PORT_STAT_CONNECTION | USB_PORT_STAT_ENABLE);\r\nport->status |= (USB_PORT_STAT_C_CONNECTION << 16);\r\nif (port->out_ep[0]) {\r\nep = port->out_ep[0];\r\nport->out_ep[0] = NULL;\r\n}\r\nspin_unlock_bh(&port->port_lock);\r\nif (ep)\r\noz_ep_free(port, ep);\r\nusb_hcd_poll_rh_status(ozhcd->hcd);\r\noz_usb_put(hpd);\r\n}\r\nvoid oz_hcd_pd_reset(void *hpd, void *hport)\r\n{\r\nstruct oz_port *port = (struct oz_port *)hport;\r\nstruct oz_hcd *ozhcd = port->ozhcd;\r\noz_dbg(ON, "PD Reset\n");\r\nspin_lock_bh(&port->port_lock);\r\nport->flags |= OZ_PORT_F_CHANGED;\r\nport->status |= USB_PORT_STAT_RESET;\r\nport->status |= (USB_PORT_STAT_C_RESET << 16);\r\nspin_unlock_bh(&port->port_lock);\r\noz_clean_endpoints_for_config(ozhcd->hcd, port);\r\nusb_hcd_poll_rh_status(ozhcd->hcd);\r\n}\r\nvoid oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\r\nint length, int offset, int total_size)\r\n{\r\nstruct oz_port *port = (struct oz_port *)hport;\r\nstruct urb *urb;\r\nint err = 0;\r\noz_dbg(ON, "oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\n",\r\nlength, offset, total_size);\r\nurb = oz_find_urb_by_id(port, 0, req_id);\r\nif (!urb)\r\nreturn;\r\nif (status == 0) {\r\nint copy_len;\r\nint required_size = urb->transfer_buffer_length;\r\nif (required_size > total_size)\r\nrequired_size = total_size;\r\ncopy_len = required_size-offset;\r\nif (length <= copy_len)\r\ncopy_len = length;\r\nmemcpy(urb->transfer_buffer+offset, desc, copy_len);\r\noffset += copy_len;\r\nif (offset < required_size) {\r\nstruct usb_ctrlrequest *setup =\r\n(struct usb_ctrlrequest *)urb->setup_packet;\r\nunsigned wvalue = le16_to_cpu(setup->wValue);\r\nif (oz_enqueue_ep_urb(port, 0, 0, urb, req_id))\r\nerr = -ENOMEM;\r\nelse if (oz_usb_get_desc_req(port->hpd, req_id,\r\nsetup->bRequestType, (u8)(wvalue>>8),\r\n(u8)wvalue, setup->wIndex, offset,\r\nrequired_size-offset)) {\r\noz_dequeue_ep_urb(port, 0, 0, urb);\r\nerr = -ENOMEM;\r\n}\r\nif (err == 0)\r\nreturn;\r\n}\r\n}\r\nurb->actual_length = total_size;\r\noz_complete_urb(port->ozhcd->hcd, urb, 0);\r\n}\r\nstatic void oz_display_conf_type(u8 t)\r\n{\r\nswitch (t) {\r\ncase USB_REQ_GET_STATUS:\r\noz_dbg(ON, "USB_REQ_GET_STATUS - cnf\n");\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\noz_dbg(ON, "USB_REQ_CLEAR_FEATURE - cnf\n");\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\noz_dbg(ON, "USB_REQ_SET_FEATURE - cnf\n");\r\nbreak;\r\ncase USB_REQ_SET_ADDRESS:\r\noz_dbg(ON, "USB_REQ_SET_ADDRESS - cnf\n");\r\nbreak;\r\ncase USB_REQ_GET_DESCRIPTOR:\r\noz_dbg(ON, "USB_REQ_GET_DESCRIPTOR - cnf\n");\r\nbreak;\r\ncase USB_REQ_SET_DESCRIPTOR:\r\noz_dbg(ON, "USB_REQ_SET_DESCRIPTOR - cnf\n");\r\nbreak;\r\ncase USB_REQ_GET_CONFIGURATION:\r\noz_dbg(ON, "USB_REQ_GET_CONFIGURATION - cnf\n");\r\nbreak;\r\ncase USB_REQ_SET_CONFIGURATION:\r\noz_dbg(ON, "USB_REQ_SET_CONFIGURATION - cnf\n");\r\nbreak;\r\ncase USB_REQ_GET_INTERFACE:\r\noz_dbg(ON, "USB_REQ_GET_INTERFACE - cnf\n");\r\nbreak;\r\ncase USB_REQ_SET_INTERFACE:\r\noz_dbg(ON, "USB_REQ_SET_INTERFACE - cnf\n");\r\nbreak;\r\ncase USB_REQ_SYNCH_FRAME:\r\noz_dbg(ON, "USB_REQ_SYNCH_FRAME - cnf\n");\r\nbreak;\r\n}\r\n}\r\nstatic void oz_hcd_complete_set_config(struct oz_port *port, struct urb *urb,\r\nu8 rcode, u8 config_num)\r\n{\r\nint rc = 0;\r\nstruct usb_hcd *hcd = port->ozhcd->hcd;\r\nif (rcode == 0) {\r\nport->config_num = config_num;\r\noz_clean_endpoints_for_config(hcd, port);\r\nif (oz_build_endpoints_for_config(hcd, port,\r\n&urb->dev->config[port->config_num-1], GFP_ATOMIC)) {\r\nrc = -ENOMEM;\r\n}\r\n} else {\r\nrc = -ENOMEM;\r\n}\r\noz_complete_urb(hcd, urb, rc);\r\n}\r\nstatic void oz_hcd_complete_set_interface(struct oz_port *port, struct urb *urb,\r\nu8 rcode, u8 if_num, u8 alt)\r\n{\r\nstruct usb_hcd *hcd = port->ozhcd->hcd;\r\nint rc = 0;\r\nif ((rcode == 0) && (port->config_num > 0)) {\r\nstruct usb_host_config *config;\r\nstruct usb_host_interface *intf;\r\noz_dbg(ON, "Set interface %d alt %d\n", if_num, alt);\r\noz_clean_endpoints_for_interface(hcd, port, if_num);\r\nconfig = &urb->dev->config[port->config_num-1];\r\nintf = &config->intf_cache[if_num]->altsetting[alt];\r\nif (oz_build_endpoints_for_interface(hcd, port, intf,\r\nGFP_ATOMIC))\r\nrc = -ENOMEM;\r\nelse\r\nport->iface[if_num].alt = alt;\r\n} else {\r\nrc = -ENOMEM;\r\n}\r\noz_complete_urb(hcd, urb, rc);\r\n}\r\nvoid oz_hcd_control_cnf(void *hport, u8 req_id, u8 rcode, const u8 *data,\r\nint data_len)\r\n{\r\nstruct oz_port *port = (struct oz_port *)hport;\r\nstruct urb *urb;\r\nstruct usb_ctrlrequest *setup;\r\nstruct usb_hcd *hcd = port->ozhcd->hcd;\r\nunsigned windex;\r\nunsigned wvalue;\r\noz_dbg(ON, "oz_hcd_control_cnf rcode=%u len=%d\n", rcode, data_len);\r\nurb = oz_find_urb_by_id(port, 0, req_id);\r\nif (!urb) {\r\noz_dbg(ON, "URB not found\n");\r\nreturn;\r\n}\r\nsetup = (struct usb_ctrlrequest *)urb->setup_packet;\r\nwindex = le16_to_cpu(setup->wIndex);\r\nwvalue = le16_to_cpu(setup->wValue);\r\nif ((setup->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\r\noz_display_conf_type(setup->bRequest);\r\nswitch (setup->bRequest) {\r\ncase USB_REQ_SET_CONFIGURATION:\r\noz_hcd_complete_set_config(port, urb, rcode,\r\n(u8)wvalue);\r\nbreak;\r\ncase USB_REQ_SET_INTERFACE:\r\noz_hcd_complete_set_interface(port, urb, rcode,\r\n(u8)windex, (u8)wvalue);\r\nbreak;\r\ndefault:\r\noz_complete_urb(hcd, urb, 0);\r\n}\r\n} else {\r\nint copy_len;\r\noz_dbg(ON, "VENDOR-CLASS - cnf\n");\r\nif (data_len) {\r\nif (data_len <= urb->transfer_buffer_length)\r\ncopy_len = data_len;\r\nelse\r\ncopy_len = urb->transfer_buffer_length;\r\nmemcpy(urb->transfer_buffer, data, copy_len);\r\nurb->actual_length = copy_len;\r\n}\r\noz_complete_urb(hcd, urb, 0);\r\n}\r\n}\r\nstatic int oz_hcd_buffer_data(struct oz_endpoint *ep, const u8 *data,\r\nint data_len)\r\n{\r\nint space;\r\nint copy_len;\r\nif (!ep->buffer)\r\nreturn -1;\r\nspace = ep->out_ix-ep->in_ix-1;\r\nif (space < 0)\r\nspace += ep->buffer_size;\r\nif (space < (data_len+1)) {\r\noz_dbg(ON, "Buffer full\n");\r\nreturn -1;\r\n}\r\nep->buffer[ep->in_ix] = (u8)data_len;\r\nif (++ep->in_ix == ep->buffer_size)\r\nep->in_ix = 0;\r\ncopy_len = ep->buffer_size - ep->in_ix;\r\nif (copy_len > data_len)\r\ncopy_len = data_len;\r\nmemcpy(&ep->buffer[ep->in_ix], data, copy_len);\r\nif (copy_len < data_len) {\r\nmemcpy(ep->buffer, data+copy_len, data_len-copy_len);\r\nep->in_ix = data_len-copy_len;\r\n} else {\r\nep->in_ix += copy_len;\r\n}\r\nif (ep->in_ix == ep->buffer_size)\r\nep->in_ix = 0;\r\nep->buffered_units++;\r\nreturn 0;\r\n}\r\nvoid oz_hcd_data_ind(void *hport, u8 endpoint, const u8 *data, int data_len)\r\n{\r\nstruct oz_port *port = (struct oz_port *)hport;\r\nstruct oz_endpoint *ep;\r\nstruct oz_hcd *ozhcd = port->ozhcd;\r\nspin_lock_bh(&ozhcd->hcd_lock);\r\nep = port->in_ep[endpoint & USB_ENDPOINT_NUMBER_MASK];\r\nif (ep == NULL)\r\ngoto done;\r\nswitch (ep->attrib & USB_ENDPOINT_XFERTYPE_MASK) {\r\ncase USB_ENDPOINT_XFER_INT:\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (!list_empty(&ep->urb_list)) {\r\nstruct oz_urb_link *urbl =\r\nlist_first_entry(&ep->urb_list,\r\nstruct oz_urb_link, link);\r\nstruct urb *urb;\r\nint copy_len;\r\nlist_del_init(&urbl->link);\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\nurb = urbl->urb;\r\noz_free_urb_link(urbl);\r\nif (data_len <= urb->transfer_buffer_length)\r\ncopy_len = data_len;\r\nelse\r\ncopy_len = urb->transfer_buffer_length;\r\nmemcpy(urb->transfer_buffer, data, copy_len);\r\nurb->actual_length = copy_len;\r\noz_complete_urb(port->ozhcd->hcd, urb, 0);\r\nreturn;\r\n} else {\r\noz_dbg(ON, "buffering frame as URB is not available\n");\r\noz_hcd_buffer_data(ep, data, data_len);\r\n}\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\noz_hcd_buffer_data(ep, data, data_len);\r\nbreak;\r\n}\r\ndone:\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\n}\r\nstatic inline int oz_usb_get_frame_number(void)\r\n{\r\nreturn atomic_inc_return(&g_usb_frame_number);\r\n}\r\nint oz_hcd_heartbeat(void *hport)\r\n{\r\nint rc = 0;\r\nstruct oz_port *port = (struct oz_port *)hport;\r\nstruct oz_hcd *ozhcd = port->ozhcd;\r\nstruct oz_urb_link *urbl;\r\nstruct list_head xfr_list;\r\nstruct list_head *e;\r\nstruct list_head *n;\r\nstruct urb *urb;\r\nstruct oz_endpoint *ep;\r\nstruct timespec ts, delta;\r\ngetrawmonotonic(&ts);\r\nINIT_LIST_HEAD(&xfr_list);\r\nspin_lock_bh(&ozhcd->hcd_lock);\r\nlist_for_each(e, &port->isoc_out_ep) {\r\nep = ep_from_link(e);\r\nif (ep->credit < 0)\r\ncontinue;\r\ndelta = timespec_sub(ts, ep->timestamp);\r\nep->credit += div_u64(timespec_to_ns(&delta), NSEC_PER_MSEC);\r\nif (ep->credit > ep->credit_ceiling)\r\nep->credit = ep->credit_ceiling;\r\nep->timestamp = ts;\r\nwhile (ep->credit && !list_empty(&ep->urb_list)) {\r\nurbl = list_first_entry(&ep->urb_list,\r\nstruct oz_urb_link, link);\r\nurb = urbl->urb;\r\nif ((ep->credit + 1) < urb->number_of_packets)\r\nbreak;\r\nep->credit -= urb->number_of_packets;\r\nif (ep->credit < 0)\r\nep->credit = 0;\r\nlist_move_tail(&urbl->link, &xfr_list);\r\n}\r\n}\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\nlist_for_each_safe(e, n, &xfr_list) {\r\nurbl = container_of(e, struct oz_urb_link, link);\r\nurb = urbl->urb;\r\nlist_del_init(e);\r\nurb->error_count = 0;\r\nurb->start_frame = oz_usb_get_frame_number();\r\noz_usb_send_isoc(port->hpd, urbl->ep_num, urb);\r\noz_free_urb_link(urbl);\r\noz_complete_urb(port->ozhcd->hcd, urb, 0);\r\n}\r\nspin_lock_bh(&ozhcd->hcd_lock);\r\nlist_for_each(e, &port->isoc_in_ep) {\r\nstruct oz_endpoint *ep = ep_from_link(e);\r\nif (ep->flags & OZ_F_EP_BUFFERING) {\r\nif (ep->buffered_units >= OZ_IN_BUFFERING_UNITS) {\r\nep->flags &= ~OZ_F_EP_BUFFERING;\r\nep->credit = 0;\r\nep->timestamp = ts;\r\nep->start_frame = 0;\r\n}\r\ncontinue;\r\n}\r\ndelta = timespec_sub(ts, ep->timestamp);\r\nep->credit += div_u64(timespec_to_ns(&delta), NSEC_PER_MSEC);\r\nep->timestamp = ts;\r\nwhile (!list_empty(&ep->urb_list)) {\r\nstruct oz_urb_link *urbl =\r\nlist_first_entry(&ep->urb_list,\r\nstruct oz_urb_link, link);\r\nstruct urb *urb = urbl->urb;\r\nint len = 0;\r\nint copy_len;\r\nint i;\r\nif (ep->credit < urb->number_of_packets)\r\nbreak;\r\nif (ep->buffered_units < urb->number_of_packets)\r\nbreak;\r\nurb->actual_length = 0;\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nlen = ep->buffer[ep->out_ix];\r\nif (++ep->out_ix == ep->buffer_size)\r\nep->out_ix = 0;\r\ncopy_len = ep->buffer_size - ep->out_ix;\r\nif (copy_len > len)\r\ncopy_len = len;\r\nmemcpy(urb->transfer_buffer,\r\n&ep->buffer[ep->out_ix], copy_len);\r\nif (copy_len < len) {\r\nmemcpy(urb->transfer_buffer+copy_len,\r\nep->buffer, len-copy_len);\r\nep->out_ix = len-copy_len;\r\n} else\r\nep->out_ix += copy_len;\r\nif (ep->out_ix == ep->buffer_size)\r\nep->out_ix = 0;\r\nurb->iso_frame_desc[i].offset =\r\nurb->actual_length;\r\nurb->actual_length += len;\r\nurb->iso_frame_desc[i].actual_length = len;\r\nurb->iso_frame_desc[i].status = 0;\r\n}\r\nep->buffered_units -= urb->number_of_packets;\r\nurb->error_count = 0;\r\nurb->start_frame = ep->start_frame;\r\nep->start_frame += urb->number_of_packets;\r\nlist_move_tail(&urbl->link, &xfr_list);\r\nep->credit -= urb->number_of_packets;\r\n}\r\n}\r\nif (!list_empty(&port->isoc_out_ep) || !list_empty(&port->isoc_in_ep))\r\nrc = 1;\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\nlist_for_each_safe(e, n, &xfr_list) {\r\nurbl = container_of(e, struct oz_urb_link, link);\r\nurb = urbl->urb;\r\nlist_del_init(e);\r\noz_free_urb_link(urbl);\r\noz_complete_urb(port->ozhcd->hcd, urb, 0);\r\n}\r\nep = port->out_ep[0];\r\nif (ep) {\r\nstruct list_head *e;\r\nstruct list_head *n;\r\nspin_lock_bh(&ozhcd->hcd_lock);\r\nlist_for_each_safe(e, n, &ep->urb_list) {\r\nurbl = container_of(e, struct oz_urb_link, link);\r\nif (urbl->submit_counter > EP0_TIMEOUT_COUNTER) {\r\noz_dbg(ON, "Request 0x%p timeout\n", urbl->urb);\r\nlist_move_tail(e, &xfr_list);\r\nurbl->submit_counter = 0;\r\n} else {\r\nurbl->submit_counter++;\r\n}\r\n}\r\nif (!list_empty(&ep->urb_list))\r\nrc = 1;\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\ne = xfr_list.next;\r\nwhile (e != &xfr_list) {\r\nurbl = container_of(e, struct oz_urb_link, link);\r\ne = e->next;\r\noz_dbg(ON, "Resending request to PD\n");\r\noz_process_ep0_urb(ozhcd, urbl->urb, GFP_ATOMIC);\r\noz_free_urb_link(urbl);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int oz_build_endpoints_for_interface(struct usb_hcd *hcd,\r\nstruct oz_port *port,\r\nstruct usb_host_interface *intf, gfp_t mem_flags)\r\n{\r\nstruct oz_hcd *ozhcd = port->ozhcd;\r\nint i;\r\nint if_ix = intf->desc.bInterfaceNumber;\r\nint request_heartbeat = 0;\r\noz_dbg(ON, "interface[%d] = %p\n", if_ix, intf);\r\nif (if_ix >= port->num_iface || port->iface == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < intf->desc.bNumEndpoints; i++) {\r\nstruct usb_host_endpoint *hep = &intf->endpoint[i];\r\nu8 ep_addr = hep->desc.bEndpointAddress;\r\nu8 ep_num = ep_addr & USB_ENDPOINT_NUMBER_MASK;\r\nstruct oz_endpoint *ep;\r\nint buffer_size = 0;\r\noz_dbg(ON, "%d bEndpointAddress = %x\n", i, ep_addr);\r\nif (ep_addr & USB_ENDPOINT_DIR_MASK) {\r\nswitch (hep->desc.bmAttributes &\r\nUSB_ENDPOINT_XFERTYPE_MASK) {\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nbuffer_size = OZ_EP_BUFFER_SIZE_ISOC;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nbuffer_size = OZ_EP_BUFFER_SIZE_INT;\r\nbreak;\r\n}\r\n}\r\nep = oz_ep_alloc(buffer_size, mem_flags);\r\nif (!ep) {\r\noz_clean_endpoints_for_interface(hcd, port, if_ix);\r\nreturn -ENOMEM;\r\n}\r\nep->attrib = hep->desc.bmAttributes;\r\nep->ep_num = ep_num;\r\nif ((ep->attrib & USB_ENDPOINT_XFERTYPE_MASK)\r\n== USB_ENDPOINT_XFER_ISOC) {\r\noz_dbg(ON, "wMaxPacketSize = %d\n",\r\nusb_endpoint_maxp(&hep->desc));\r\nep->credit_ceiling = 200;\r\nif (ep_addr & USB_ENDPOINT_DIR_MASK) {\r\nep->flags |= OZ_F_EP_BUFFERING;\r\n} else {\r\nep->flags |= OZ_F_EP_HAVE_STREAM;\r\nif (oz_usb_stream_create(port->hpd, ep_num))\r\nep->flags &= ~OZ_F_EP_HAVE_STREAM;\r\n}\r\n}\r\nspin_lock_bh(&ozhcd->hcd_lock);\r\nif (ep_addr & USB_ENDPOINT_DIR_MASK) {\r\nport->in_ep[ep_num] = ep;\r\nport->iface[if_ix].ep_mask |=\r\n(1<<(ep_num+OZ_NB_ENDPOINTS));\r\nif ((ep->attrib & USB_ENDPOINT_XFERTYPE_MASK)\r\n== USB_ENDPOINT_XFER_ISOC) {\r\nlist_add_tail(&ep->link, &port->isoc_in_ep);\r\nrequest_heartbeat = 1;\r\n}\r\n} else {\r\nport->out_ep[ep_num] = ep;\r\nport->iface[if_ix].ep_mask |= (1<<ep_num);\r\nif ((ep->attrib & USB_ENDPOINT_XFERTYPE_MASK)\r\n== USB_ENDPOINT_XFER_ISOC) {\r\nlist_add_tail(&ep->link, &port->isoc_out_ep);\r\nrequest_heartbeat = 1;\r\n}\r\n}\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\nif (request_heartbeat && port->hpd)\r\noz_usb_request_heartbeat(port->hpd);\r\n}\r\nreturn 0;\r\n}\r\nstatic void oz_clean_endpoints_for_interface(struct usb_hcd *hcd,\r\nstruct oz_port *port, int if_ix)\r\n{\r\nstruct oz_hcd *ozhcd = port->ozhcd;\r\nunsigned mask;\r\nint i;\r\nstruct list_head ep_list;\r\noz_dbg(ON, "Deleting endpoints for interface %d\n", if_ix);\r\nif (if_ix >= port->num_iface)\r\nreturn;\r\nINIT_LIST_HEAD(&ep_list);\r\nspin_lock_bh(&ozhcd->hcd_lock);\r\nmask = port->iface[if_ix].ep_mask;\r\nport->iface[if_ix].ep_mask = 0;\r\nfor (i = 0; i < OZ_NB_ENDPOINTS; i++) {\r\nstruct list_head *e;\r\nif ((mask & (1<<i)) && port->out_ep[i]) {\r\ne = &port->out_ep[i]->link;\r\nport->out_ep[i] = NULL;\r\nlist_move_tail(e, &ep_list);\r\n}\r\nif ((mask & (1<<(i+OZ_NB_ENDPOINTS))) && port->in_ep[i]) {\r\ne = &port->in_ep[i]->link;\r\nport->in_ep[i] = NULL;\r\nlist_move_tail(e, &ep_list);\r\n}\r\n}\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\nwhile (!list_empty(&ep_list)) {\r\nstruct oz_endpoint *ep =\r\nlist_first_entry(&ep_list, struct oz_endpoint, link);\r\nlist_del_init(&ep->link);\r\noz_ep_free(port, ep);\r\n}\r\n}\r\nstatic int oz_build_endpoints_for_config(struct usb_hcd *hcd,\r\nstruct oz_port *port, struct usb_host_config *config,\r\ngfp_t mem_flags)\r\n{\r\nstruct oz_hcd *ozhcd = port->ozhcd;\r\nint i;\r\nint num_iface = config->desc.bNumInterfaces;\r\nif (num_iface) {\r\nstruct oz_interface *iface;\r\niface = kmalloc(num_iface*sizeof(struct oz_interface),\r\nmem_flags | __GFP_ZERO);\r\nif (!iface)\r\nreturn -ENOMEM;\r\nspin_lock_bh(&ozhcd->hcd_lock);\r\nport->iface = iface;\r\nport->num_iface = num_iface;\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\n}\r\nfor (i = 0; i < num_iface; i++) {\r\nstruct usb_host_interface *intf =\r\n&config->intf_cache[i]->altsetting[0];\r\nif (oz_build_endpoints_for_interface(hcd, port, intf,\r\nmem_flags))\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\noz_clean_endpoints_for_config(hcd, port);\r\nreturn -1;\r\n}\r\nstatic void oz_clean_endpoints_for_config(struct usb_hcd *hcd,\r\nstruct oz_port *port)\r\n{\r\nstruct oz_hcd *ozhcd = port->ozhcd;\r\nint i;\r\noz_dbg(ON, "Deleting endpoints for configuration\n");\r\nfor (i = 0; i < port->num_iface; i++)\r\noz_clean_endpoints_for_interface(hcd, port, i);\r\nspin_lock_bh(&ozhcd->hcd_lock);\r\nif (port->iface) {\r\noz_dbg(ON, "Freeing interfaces object\n");\r\nkfree(port->iface);\r\nport->iface = NULL;\r\n}\r\nport->num_iface = 0;\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\n}\r\nstatic void *oz_claim_hpd(struct oz_port *port)\r\n{\r\nvoid *hpd;\r\nstruct oz_hcd *ozhcd = port->ozhcd;\r\nspin_lock_bh(&ozhcd->hcd_lock);\r\nhpd = port->hpd;\r\nif (hpd)\r\noz_usb_get(hpd);\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\nreturn hpd;\r\n}\r\nstatic void oz_process_ep0_urb(struct oz_hcd *ozhcd, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct usb_ctrlrequest *setup;\r\nunsigned windex;\r\nunsigned wvalue;\r\nunsigned wlength;\r\nvoid *hpd;\r\nu8 req_id;\r\nint rc = 0;\r\nunsigned complete = 0;\r\nint port_ix = -1;\r\nstruct oz_port *port = NULL;\r\noz_dbg(URB, "[%s]:(%p)\n", __func__, urb);\r\nport_ix = oz_get_port_from_addr(ozhcd, urb->dev->devnum);\r\nif (port_ix < 0) {\r\nrc = -EPIPE;\r\ngoto out;\r\n}\r\nport = &ozhcd->ports[port_ix];\r\nif (((port->flags & OZ_PORT_F_PRESENT) == 0)\r\n|| (port->flags & OZ_PORT_F_DYING)) {\r\noz_dbg(ON, "Refusing URB port_ix = %d devnum = %d\n",\r\nport_ix, urb->dev->devnum);\r\nrc = -EPIPE;\r\ngoto out;\r\n}\r\nurb->hcpriv = port;\r\nsetup = (struct usb_ctrlrequest *)urb->setup_packet;\r\nwindex = le16_to_cpu(setup->wIndex);\r\nwvalue = le16_to_cpu(setup->wValue);\r\nwlength = le16_to_cpu(setup->wLength);\r\noz_dbg(CTRL_DETAIL, "bRequestType = %x\n", setup->bRequestType);\r\noz_dbg(CTRL_DETAIL, "bRequest = %x\n", setup->bRequest);\r\noz_dbg(CTRL_DETAIL, "wValue = %x\n", wvalue);\r\noz_dbg(CTRL_DETAIL, "wIndex = %x\n", windex);\r\noz_dbg(CTRL_DETAIL, "wLength = %x\n", wlength);\r\nreq_id = port->next_req_id++;\r\nhpd = oz_claim_hpd(port);\r\nif (hpd == NULL) {\r\noz_dbg(ON, "Cannot claim port\n");\r\nrc = -EPIPE;\r\ngoto out;\r\n}\r\nif ((setup->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\r\nswitch (setup->bRequest) {\r\ncase USB_REQ_GET_DESCRIPTOR:\r\noz_dbg(ON, "USB_REQ_GET_DESCRIPTOR - req\n");\r\nbreak;\r\ncase USB_REQ_SET_ADDRESS:\r\noz_dbg(ON, "USB_REQ_SET_ADDRESS - req\n");\r\noz_dbg(ON, "Port %d address is 0x%x\n",\r\nozhcd->conn_port,\r\n(u8)le16_to_cpu(setup->wValue));\r\nspin_lock_bh(&ozhcd->hcd_lock);\r\nif (ozhcd->conn_port >= 0) {\r\nozhcd->ports[ozhcd->conn_port].bus_addr =\r\n(u8)le16_to_cpu(setup->wValue);\r\noz_dbg(ON, "Clearing conn_port\n");\r\nozhcd->conn_port = -1;\r\n}\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\ncomplete = 1;\r\nbreak;\r\ncase USB_REQ_SET_CONFIGURATION:\r\noz_dbg(ON, "USB_REQ_SET_CONFIGURATION - req\n");\r\nbreak;\r\ncase USB_REQ_GET_CONFIGURATION:\r\noz_dbg(ON, "USB_REQ_GET_CONFIGURATION - reply now\n");\r\nif (urb->transfer_buffer_length >= 1) {\r\nurb->actual_length = 1;\r\n*((u8 *)urb->transfer_buffer) =\r\nport->config_num;\r\ncomplete = 1;\r\n} else {\r\nrc = -EPIPE;\r\n}\r\nbreak;\r\ncase USB_REQ_GET_INTERFACE:\r\noz_dbg(ON, "USB_REQ_GET_INTERFACE - reply now\n");\r\nif (urb->transfer_buffer_length >= 1) {\r\nurb->actual_length = 1;\r\n*((u8 *)urb->transfer_buffer) =\r\nport->iface[(u8)windex].alt;\r\noz_dbg(ON, "interface = %d alt = %d\n",\r\nwindex, port->iface[(u8)windex].alt);\r\ncomplete = 1;\r\n} else {\r\nrc = -EPIPE;\r\n}\r\nbreak;\r\ncase USB_REQ_SET_INTERFACE:\r\noz_dbg(ON, "USB_REQ_SET_INTERFACE - req\n");\r\nbreak;\r\n}\r\n}\r\nif (!rc && !complete) {\r\nint data_len = 0;\r\nif ((setup->bRequestType & USB_DIR_IN) == 0)\r\ndata_len = wlength;\r\nurb->actual_length = data_len;\r\nif (oz_usb_control_req(port->hpd, req_id, setup,\r\nurb->transfer_buffer, data_len)) {\r\nrc = -ENOMEM;\r\n} else {\r\nif (oz_enqueue_ep_urb(port, 0, 0, urb, req_id))\r\nrc = -ENOMEM;\r\n}\r\n}\r\noz_usb_put(hpd);\r\nout:\r\nif (rc || complete) {\r\noz_dbg(ON, "Completing request locally\n");\r\noz_complete_urb(ozhcd->hcd, urb, rc);\r\n} else {\r\noz_usb_request_heartbeat(port->hpd);\r\n}\r\n}\r\nstatic int oz_urb_process(struct oz_hcd *ozhcd, struct urb *urb)\r\n{\r\nint rc = 0;\r\nstruct oz_port *port = urb->hcpriv;\r\nu8 ep_addr;\r\noz_remember_urb(urb);\r\nif (!urb->transfer_buffer && urb->transfer_buffer_length)\r\nreturn -EINVAL;\r\nif ((port->flags & OZ_PORT_F_PRESENT) == 0)\r\nreturn -EPIPE;\r\nep_addr = usb_pipeendpoint(urb->pipe);\r\nif (ep_addr) {\r\nif (oz_enqueue_ep_urb(port, ep_addr, usb_pipein(urb->pipe),\r\nurb, 0))\r\nrc = -EPIPE;\r\n} else {\r\noz_process_ep0_urb(ozhcd, urb, GFP_ATOMIC);\r\n}\r\nreturn rc;\r\n}\r\nstatic void oz_urb_process_tasklet(unsigned long unused)\r\n{\r\nunsigned long irq_state;\r\nstruct urb *urb;\r\nstruct oz_hcd *ozhcd = oz_hcd_claim();\r\nint rc = 0;\r\nif (ozhcd == NULL)\r\nreturn;\r\nspin_lock_irqsave(&g_tasklet_lock, irq_state);\r\nwhile (!list_empty(&ozhcd->urb_pending_list)) {\r\nstruct oz_urb_link *urbl =\r\nlist_first_entry(&ozhcd->urb_pending_list,\r\nstruct oz_urb_link, link);\r\nlist_del_init(&urbl->link);\r\nspin_unlock_irqrestore(&g_tasklet_lock, irq_state);\r\nurb = urbl->urb;\r\noz_free_urb_link(urbl);\r\nrc = oz_urb_process(ozhcd, urb);\r\nif (rc)\r\noz_complete_urb(ozhcd->hcd, urb, rc);\r\nspin_lock_irqsave(&g_tasklet_lock, irq_state);\r\n}\r\nspin_unlock_irqrestore(&g_tasklet_lock, irq_state);\r\noz_hcd_put(ozhcd);\r\n}\r\nstatic void oz_urb_cancel(struct oz_port *port, u8 ep_num, struct urb *urb)\r\n{\r\nstruct oz_urb_link *urbl = NULL;\r\nstruct list_head *e;\r\nstruct oz_hcd *ozhcd;\r\nunsigned long irq_state;\r\nu8 ix;\r\nif (port == NULL) {\r\noz_dbg(ON, "%s: ERROR: (%p) port is null\n", __func__, urb);\r\nreturn;\r\n}\r\nozhcd = port->ozhcd;\r\nif (ozhcd == NULL) {\r\noz_dbg(ON, "%s; ERROR: (%p) ozhcd is null\n", __func__, urb);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&g_tasklet_lock, irq_state);\r\nlist_for_each(e, &ozhcd->urb_cancel_list) {\r\nurbl = container_of(e, struct oz_urb_link, link);\r\nif (urb == urbl->urb) {\r\nlist_del_init(e);\r\nspin_unlock_irqrestore(&g_tasklet_lock, irq_state);\r\ngoto out2;\r\n}\r\n}\r\nspin_unlock_irqrestore(&g_tasklet_lock, irq_state);\r\nurbl = NULL;\r\nspin_lock_irqsave(&ozhcd->hcd_lock, irq_state);\r\nlist_for_each(e, &ozhcd->orphanage) {\r\nurbl = container_of(e, struct oz_urb_link, link);\r\nif (urbl->urb == urb) {\r\nlist_del(e);\r\noz_dbg(ON, "Found urb in orphanage\n");\r\ngoto out;\r\n}\r\n}\r\nix = (ep_num & 0xf);\r\nurbl = NULL;\r\nif ((ep_num & USB_DIR_IN) && ix)\r\nurbl = oz_remove_urb(port->in_ep[ix], urb);\r\nelse\r\nurbl = oz_remove_urb(port->out_ep[ix], urb);\r\nout:\r\nspin_unlock_irqrestore(&ozhcd->hcd_lock, irq_state);\r\nout2:\r\nif (urbl) {\r\nurb->actual_length = 0;\r\noz_free_urb_link(urbl);\r\noz_complete_urb(ozhcd->hcd, urb, -EPIPE);\r\n}\r\n}\r\nstatic void oz_urb_cancel_tasklet(unsigned long unused)\r\n{\r\nunsigned long irq_state;\r\nstruct urb *urb;\r\nstruct oz_hcd *ozhcd = oz_hcd_claim();\r\nif (ozhcd == NULL)\r\nreturn;\r\nspin_lock_irqsave(&g_tasklet_lock, irq_state);\r\nwhile (!list_empty(&ozhcd->urb_cancel_list)) {\r\nstruct oz_urb_link *urbl =\r\nlist_first_entry(&ozhcd->urb_cancel_list,\r\nstruct oz_urb_link, link);\r\nlist_del_init(&urbl->link);\r\nspin_unlock_irqrestore(&g_tasklet_lock, irq_state);\r\nurb = urbl->urb;\r\nif (urb->unlinked)\r\noz_urb_cancel(urbl->port, urbl->ep_num, urb);\r\noz_free_urb_link(urbl);\r\nspin_lock_irqsave(&g_tasklet_lock, irq_state);\r\n}\r\nspin_unlock_irqrestore(&g_tasklet_lock, irq_state);\r\noz_hcd_put(ozhcd);\r\n}\r\nstatic void oz_hcd_clear_orphanage(struct oz_hcd *ozhcd, int status)\r\n{\r\nif (ozhcd) {\r\nstruct oz_urb_link *urbl;\r\nwhile (!list_empty(&ozhcd->orphanage)) {\r\nurbl = list_first_entry(&ozhcd->orphanage,\r\nstruct oz_urb_link, link);\r\nlist_del(&urbl->link);\r\noz_complete_urb(ozhcd->hcd, urbl->urb, status);\r\noz_free_urb_link(urbl);\r\n}\r\n}\r\n}\r\nstatic int oz_hcd_start(struct usb_hcd *hcd)\r\n{\r\nhcd->power_budget = 200;\r\nhcd->state = HC_STATE_RUNNING;\r\nhcd->uses_new_polling = 1;\r\nreturn 0;\r\n}\r\nstatic void oz_hcd_stop(struct usb_hcd *hcd)\r\n{\r\n}\r\nstatic void oz_hcd_shutdown(struct usb_hcd *hcd)\r\n{\r\n}\r\nstatic int oz_hcd_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct oz_hcd *ozhcd = oz_hcd_private(hcd);\r\nint rc;\r\nint port_ix;\r\nstruct oz_port *port;\r\nunsigned long irq_state;\r\nstruct oz_urb_link *urbl;\r\noz_dbg(URB, "%s: (%p)\n", __func__, urb);\r\nif (unlikely(ozhcd == NULL)) {\r\noz_dbg(URB, "Refused urb(%p) not ozhcd\n", urb);\r\nreturn -EPIPE;\r\n}\r\nif (unlikely(hcd->state != HC_STATE_RUNNING)) {\r\noz_dbg(URB, "Refused urb(%p) not running\n", urb);\r\nreturn -EPIPE;\r\n}\r\nport_ix = oz_get_port_from_addr(ozhcd, urb->dev->devnum);\r\nif (port_ix < 0)\r\nreturn -EPIPE;\r\nport = &ozhcd->ports[port_ix];\r\nif (port == NULL)\r\nreturn -EPIPE;\r\nif (!(port->flags & OZ_PORT_F_PRESENT) ||\r\n(port->flags & OZ_PORT_F_CHANGED)) {\r\noz_dbg(ON, "Refusing URB port_ix = %d devnum = %d\n",\r\nport_ix, urb->dev->devnum);\r\nreturn -EPIPE;\r\n}\r\nurb->hcpriv = port;\r\nurbl = oz_alloc_urb_link();\r\nif (unlikely(urbl == NULL))\r\nreturn -ENOMEM;\r\nurbl->urb = urb;\r\nspin_lock_irqsave(&g_tasklet_lock, irq_state);\r\nrc = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (unlikely(rc)) {\r\nspin_unlock_irqrestore(&g_tasklet_lock, irq_state);\r\noz_free_urb_link(urbl);\r\nreturn rc;\r\n}\r\nlist_add_tail(&urbl->link, &ozhcd->urb_pending_list);\r\nspin_unlock_irqrestore(&g_tasklet_lock, irq_state);\r\ntasklet_schedule(&g_urb_process_tasklet);\r\natomic_inc(&g_pending_urbs);\r\nreturn 0;\r\n}\r\nstatic struct oz_urb_link *oz_remove_urb(struct oz_endpoint *ep,\r\nstruct urb *urb)\r\n{\r\nstruct oz_urb_link *urbl;\r\nstruct list_head *e;\r\nif (unlikely(ep == NULL))\r\nreturn NULL;\r\nlist_for_each(e, &ep->urb_list) {\r\nurbl = container_of(e, struct oz_urb_link, link);\r\nif (urbl->urb == urb) {\r\nlist_del_init(e);\r\nif (usb_pipeisoc(urb->pipe)) {\r\nep->credit -= urb->number_of_packets;\r\nif (ep->credit < 0)\r\nep->credit = 0;\r\n}\r\nreturn urbl;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int oz_hcd_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct oz_hcd *ozhcd = oz_hcd_private(hcd);\r\nstruct oz_urb_link *urbl;\r\nint rc;\r\nunsigned long irq_state;\r\noz_dbg(URB, "%s: (%p)\n", __func__, urb);\r\nurbl = oz_alloc_urb_link();\r\nif (unlikely(urbl == NULL))\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&g_tasklet_lock, irq_state);\r\nrc = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif ((rc == 0) && urb->hcpriv) {\r\nurbl->urb = urb;\r\nurbl->port = (struct oz_port *)urb->hcpriv;\r\nurbl->ep_num = usb_pipeendpoint(urb->pipe);\r\nif (usb_pipein(urb->pipe))\r\nurbl->ep_num |= USB_DIR_IN;\r\nlist_add_tail(&urbl->link, &ozhcd->urb_cancel_list);\r\nspin_unlock_irqrestore(&g_tasklet_lock, irq_state);\r\ntasklet_schedule(&g_urb_cancel_tasklet);\r\n} else {\r\nspin_unlock_irqrestore(&g_tasklet_lock, irq_state);\r\noz_free_urb_link(urbl);\r\n}\r\nreturn rc;\r\n}\r\nstatic void oz_hcd_endpoint_disable(struct usb_hcd *hcd,\r\nstruct usb_host_endpoint *ep)\r\n{\r\n}\r\nstatic void oz_hcd_endpoint_reset(struct usb_hcd *hcd,\r\nstruct usb_host_endpoint *ep)\r\n{\r\n}\r\nstatic int oz_hcd_get_frame_number(struct usb_hcd *hcd)\r\n{\r\noz_dbg(ON, "oz_hcd_get_frame_number\n");\r\nreturn oz_usb_get_frame_number();\r\n}\r\nstatic int oz_hcd_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct oz_hcd *ozhcd = oz_hcd_private(hcd);\r\nint i;\r\nbuf[0] = 0;\r\nbuf[1] = 0;\r\nspin_lock_bh(&ozhcd->hcd_lock);\r\nfor (i = 0; i < OZ_NB_PORTS; i++) {\r\nif (ozhcd->ports[i].flags & OZ_PORT_F_CHANGED) {\r\noz_dbg(HUB, "Port %d changed\n", i);\r\nozhcd->ports[i].flags &= ~OZ_PORT_F_CHANGED;\r\nif (i < 7)\r\nbuf[0] |= 1 << (i + 1);\r\nelse\r\nbuf[1] |= 1 << (i - 7);\r\n}\r\n}\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\nif (buf[0] != 0 || buf[1] != 0)\r\nreturn 2;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void oz_get_hub_descriptor(struct usb_hcd *hcd,\r\nstruct usb_hub_descriptor *desc)\r\n{\r\nmemset(desc, 0, sizeof(*desc));\r\ndesc->bDescriptorType = 0x29;\r\ndesc->bDescLength = 9;\r\ndesc->wHubCharacteristics = (__force __u16)\r\n__constant_cpu_to_le16(0x0001);\r\ndesc->bNbrPorts = OZ_NB_PORTS;\r\n}\r\nstatic int oz_set_port_feature(struct usb_hcd *hcd, u16 wvalue, u16 windex)\r\n{\r\nstruct oz_port *port;\r\nint err = 0;\r\nu8 port_id = (u8)windex;\r\nstruct oz_hcd *ozhcd = oz_hcd_private(hcd);\r\nunsigned set_bits = 0;\r\nunsigned clear_bits = 0;\r\nif ((port_id < 1) || (port_id > OZ_NB_PORTS))\r\nreturn -EPIPE;\r\nport = &ozhcd->ports[port_id-1];\r\nswitch (wvalue) {\r\ncase USB_PORT_FEAT_CONNECTION:\r\noz_dbg(HUB, "USB_PORT_FEAT_CONNECTION\n");\r\nbreak;\r\ncase USB_PORT_FEAT_ENABLE:\r\noz_dbg(HUB, "USB_PORT_FEAT_ENABLE\n");\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\noz_dbg(HUB, "USB_PORT_FEAT_SUSPEND\n");\r\nbreak;\r\ncase USB_PORT_FEAT_OVER_CURRENT:\r\noz_dbg(HUB, "USB_PORT_FEAT_OVER_CURRENT\n");\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\noz_dbg(HUB, "USB_PORT_FEAT_RESET\n");\r\nset_bits = USB_PORT_STAT_ENABLE | (USB_PORT_STAT_C_RESET<<16);\r\nclear_bits = USB_PORT_STAT_RESET;\r\nozhcd->ports[port_id-1].bus_addr = 0;\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\noz_dbg(HUB, "USB_PORT_FEAT_POWER\n");\r\nset_bits |= USB_PORT_STAT_POWER;\r\nbreak;\r\ncase USB_PORT_FEAT_LOWSPEED:\r\noz_dbg(HUB, "USB_PORT_FEAT_LOWSPEED\n");\r\nbreak;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\noz_dbg(HUB, "USB_PORT_FEAT_C_CONNECTION\n");\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\noz_dbg(HUB, "USB_PORT_FEAT_C_ENABLE\n");\r\nbreak;\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\noz_dbg(HUB, "USB_PORT_FEAT_C_SUSPEND\n");\r\nbreak;\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\noz_dbg(HUB, "USB_PORT_FEAT_C_OVER_CURRENT\n");\r\nbreak;\r\ncase USB_PORT_FEAT_C_RESET:\r\noz_dbg(HUB, "USB_PORT_FEAT_C_RESET\n");\r\nbreak;\r\ncase USB_PORT_FEAT_TEST:\r\noz_dbg(HUB, "USB_PORT_FEAT_TEST\n");\r\nbreak;\r\ncase USB_PORT_FEAT_INDICATOR:\r\noz_dbg(HUB, "USB_PORT_FEAT_INDICATOR\n");\r\nbreak;\r\ndefault:\r\noz_dbg(HUB, "Other %d\n", wvalue);\r\nbreak;\r\n}\r\nif (set_bits || clear_bits) {\r\nspin_lock_bh(&port->port_lock);\r\nport->status &= ~clear_bits;\r\nport->status |= set_bits;\r\nspin_unlock_bh(&port->port_lock);\r\n}\r\noz_dbg(HUB, "Port[%d] status = 0x%x\n", port_id, port->status);\r\nreturn err;\r\n}\r\nstatic int oz_clear_port_feature(struct usb_hcd *hcd, u16 wvalue, u16 windex)\r\n{\r\nstruct oz_port *port;\r\nint err = 0;\r\nu8 port_id = (u8)windex;\r\nstruct oz_hcd *ozhcd = oz_hcd_private(hcd);\r\nunsigned clear_bits = 0;\r\nif ((port_id < 1) || (port_id > OZ_NB_PORTS))\r\nreturn -EPIPE;\r\nport = &ozhcd->ports[port_id-1];\r\nswitch (wvalue) {\r\ncase USB_PORT_FEAT_CONNECTION:\r\noz_dbg(HUB, "USB_PORT_FEAT_CONNECTION\n");\r\nbreak;\r\ncase USB_PORT_FEAT_ENABLE:\r\noz_dbg(HUB, "USB_PORT_FEAT_ENABLE\n");\r\nclear_bits = USB_PORT_STAT_ENABLE;\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\noz_dbg(HUB, "USB_PORT_FEAT_SUSPEND\n");\r\nbreak;\r\ncase USB_PORT_FEAT_OVER_CURRENT:\r\noz_dbg(HUB, "USB_PORT_FEAT_OVER_CURRENT\n");\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\noz_dbg(HUB, "USB_PORT_FEAT_RESET\n");\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\noz_dbg(HUB, "USB_PORT_FEAT_POWER\n");\r\nclear_bits |= USB_PORT_STAT_POWER;\r\nbreak;\r\ncase USB_PORT_FEAT_LOWSPEED:\r\noz_dbg(HUB, "USB_PORT_FEAT_LOWSPEED\n");\r\nbreak;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\noz_dbg(HUB, "USB_PORT_FEAT_C_CONNECTION\n");\r\nclear_bits = (USB_PORT_STAT_C_CONNECTION << 16);\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\noz_dbg(HUB, "USB_PORT_FEAT_C_ENABLE\n");\r\nclear_bits = (USB_PORT_STAT_C_ENABLE << 16);\r\nbreak;\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\noz_dbg(HUB, "USB_PORT_FEAT_C_SUSPEND\n");\r\nbreak;\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\noz_dbg(HUB, "USB_PORT_FEAT_C_OVER_CURRENT\n");\r\nbreak;\r\ncase USB_PORT_FEAT_C_RESET:\r\noz_dbg(HUB, "USB_PORT_FEAT_C_RESET\n");\r\nclear_bits = (USB_PORT_FEAT_C_RESET << 16);\r\nbreak;\r\ncase USB_PORT_FEAT_TEST:\r\noz_dbg(HUB, "USB_PORT_FEAT_TEST\n");\r\nbreak;\r\ncase USB_PORT_FEAT_INDICATOR:\r\noz_dbg(HUB, "USB_PORT_FEAT_INDICATOR\n");\r\nbreak;\r\ndefault:\r\noz_dbg(HUB, "Other %d\n", wvalue);\r\nbreak;\r\n}\r\nif (clear_bits) {\r\nspin_lock_bh(&port->port_lock);\r\nport->status &= ~clear_bits;\r\nspin_unlock_bh(&port->port_lock);\r\n}\r\noz_dbg(HUB, "Port[%d] status = 0x%x\n",\r\nport_id, ozhcd->ports[port_id-1].status);\r\nreturn err;\r\n}\r\nstatic int oz_get_port_status(struct usb_hcd *hcd, u16 windex, char *buf)\r\n{\r\nstruct oz_hcd *ozhcd;\r\nu32 status;\r\nif ((windex < 1) || (windex > OZ_NB_PORTS))\r\nreturn -EPIPE;\r\nozhcd = oz_hcd_private(hcd);\r\noz_dbg(HUB, "GetPortStatus windex = %d\n", windex);\r\nstatus = ozhcd->ports[windex-1].status;\r\nput_unaligned(cpu_to_le32(status), (__le32 *)buf);\r\noz_dbg(HUB, "Port[%d] status = %x\n", windex, status);\r\nreturn 0;\r\n}\r\nstatic int oz_hcd_hub_control(struct usb_hcd *hcd, u16 req_type, u16 wvalue,\r\nu16 windex, char *buf, u16 wlength)\r\n{\r\nint err = 0;\r\nswitch (req_type) {\r\ncase ClearHubFeature:\r\noz_dbg(HUB, "ClearHubFeature: %d\n", req_type);\r\nbreak;\r\ncase ClearPortFeature:\r\nerr = oz_clear_port_feature(hcd, wvalue, windex);\r\nbreak;\r\ncase GetHubDescriptor:\r\noz_get_hub_descriptor(hcd, (struct usb_hub_descriptor *)buf);\r\nbreak;\r\ncase GetHubStatus:\r\noz_dbg(HUB, "GetHubStatus: req_type = 0x%x\n", req_type);\r\nput_unaligned(__constant_cpu_to_le32(0), (__le32 *)buf);\r\nbreak;\r\ncase GetPortStatus:\r\nerr = oz_get_port_status(hcd, windex, buf);\r\nbreak;\r\ncase SetHubFeature:\r\noz_dbg(HUB, "SetHubFeature: %d\n", req_type);\r\nbreak;\r\ncase SetPortFeature:\r\nerr = oz_set_port_feature(hcd, wvalue, windex);\r\nbreak;\r\ndefault:\r\noz_dbg(HUB, "Other: %d\n", req_type);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int oz_hcd_bus_suspend(struct usb_hcd *hcd)\r\n{\r\nstruct oz_hcd *ozhcd;\r\nozhcd = oz_hcd_private(hcd);\r\nspin_lock_bh(&ozhcd->hcd_lock);\r\nhcd->state = HC_STATE_SUSPENDED;\r\nozhcd->flags |= OZ_HDC_F_SUSPENDED;\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\nreturn 0;\r\n}\r\nstatic int oz_hcd_bus_resume(struct usb_hcd *hcd)\r\n{\r\nstruct oz_hcd *ozhcd;\r\nozhcd = oz_hcd_private(hcd);\r\nspin_lock_bh(&ozhcd->hcd_lock);\r\nozhcd->flags &= ~OZ_HDC_F_SUSPENDED;\r\nhcd->state = HC_STATE_RUNNING;\r\nspin_unlock_bh(&ozhcd->hcd_lock);\r\nreturn 0;\r\n}\r\nstatic void oz_plat_shutdown(struct platform_device *dev)\r\n{\r\n}\r\nstatic int oz_plat_probe(struct platform_device *dev)\r\n{\r\nint i;\r\nint err;\r\nstruct usb_hcd *hcd;\r\nstruct oz_hcd *ozhcd;\r\nhcd = usb_create_hcd(&g_oz_hc_drv, &dev->dev, dev_name(&dev->dev));\r\nif (hcd == NULL) {\r\noz_dbg(ON, "Failed to created hcd object OK\n");\r\nreturn -ENOMEM;\r\n}\r\nozhcd = oz_hcd_private(hcd);\r\nmemset(ozhcd, 0, sizeof(*ozhcd));\r\nINIT_LIST_HEAD(&ozhcd->urb_pending_list);\r\nINIT_LIST_HEAD(&ozhcd->urb_cancel_list);\r\nINIT_LIST_HEAD(&ozhcd->orphanage);\r\nozhcd->hcd = hcd;\r\nozhcd->conn_port = -1;\r\nspin_lock_init(&ozhcd->hcd_lock);\r\nfor (i = 0; i < OZ_NB_PORTS; i++) {\r\nstruct oz_port *port = &ozhcd->ports[i];\r\nport->ozhcd = ozhcd;\r\nport->flags = 0;\r\nport->status = 0;\r\nport->bus_addr = 0xff;\r\nspin_lock_init(&port->port_lock);\r\n}\r\nerr = usb_add_hcd(hcd, 0, 0);\r\nif (err) {\r\noz_dbg(ON, "Failed to add hcd object OK\n");\r\nusb_put_hcd(hcd);\r\nreturn -1;\r\n}\r\nspin_lock_bh(&g_hcdlock);\r\ng_ozhcd = ozhcd;\r\nspin_unlock_bh(&g_hcdlock);\r\nreturn 0;\r\n}\r\nstatic int oz_plat_remove(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct oz_hcd *ozhcd;\r\nif (hcd == NULL)\r\nreturn -1;\r\nozhcd = oz_hcd_private(hcd);\r\nspin_lock_bh(&g_hcdlock);\r\nif (ozhcd == g_ozhcd)\r\ng_ozhcd = NULL;\r\nspin_unlock_bh(&g_hcdlock);\r\noz_dbg(ON, "Clearing orphanage\n");\r\noz_hcd_clear_orphanage(ozhcd, -EPIPE);\r\noz_dbg(ON, "Removing hcd\n");\r\nusb_remove_hcd(hcd);\r\nusb_put_hcd(hcd);\r\noz_empty_link_pool();\r\nreturn 0;\r\n}\r\nstatic int oz_plat_suspend(struct platform_device *dev, pm_message_t msg)\r\n{\r\nreturn 0;\r\n}\r\nstatic int oz_plat_resume(struct platform_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nint oz_hcd_init(void)\r\n{\r\nint err;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\ntasklet_init(&g_urb_process_tasklet, oz_urb_process_tasklet, 0);\r\ntasklet_init(&g_urb_cancel_tasklet, oz_urb_cancel_tasklet, 0);\r\nerr = platform_driver_register(&g_oz_plat_drv);\r\noz_dbg(ON, "platform_driver_register() returned %d\n", err);\r\nif (err)\r\ngoto error;\r\ng_plat_dev = platform_device_alloc(OZ_PLAT_DEV_NAME, -1);\r\nif (g_plat_dev == NULL) {\r\nerr = -ENOMEM;\r\ngoto error1;\r\n}\r\noz_dbg(ON, "platform_device_alloc() succeeded\n");\r\nerr = platform_device_add(g_plat_dev);\r\nif (err)\r\ngoto error2;\r\noz_dbg(ON, "platform_device_add() succeeded\n");\r\nreturn 0;\r\nerror2:\r\nplatform_device_put(g_plat_dev);\r\nerror1:\r\nplatform_driver_unregister(&g_oz_plat_drv);\r\nerror:\r\ntasklet_disable(&g_urb_process_tasklet);\r\ntasklet_disable(&g_urb_cancel_tasklet);\r\noz_dbg(ON, "oz_hcd_init() failed %d\n", err);\r\nreturn err;\r\n}\r\nvoid oz_hcd_term(void)\r\n{\r\nmsleep(OZ_HUB_DEBOUNCE_TIMEOUT);\r\ntasklet_kill(&g_urb_process_tasklet);\r\ntasklet_kill(&g_urb_cancel_tasklet);\r\nplatform_device_unregister(g_plat_dev);\r\nplatform_driver_unregister(&g_oz_plat_drv);\r\noz_dbg(ON, "Pending urbs:%d\n", atomic_read(&g_pending_urbs));\r\n}
