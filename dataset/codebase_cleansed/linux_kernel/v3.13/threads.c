void rds_connect_complete(struct rds_connection *conn)\r\n{\r\nif (!rds_conn_transition(conn, RDS_CONN_CONNECTING, RDS_CONN_UP)) {\r\nprintk(KERN_WARNING "%s: Cannot transition to state UP, "\r\n"current state is %d\n",\r\n__func__,\r\natomic_read(&conn->c_state));\r\natomic_set(&conn->c_state, RDS_CONN_ERROR);\r\nqueue_work(rds_wq, &conn->c_down_w);\r\nreturn;\r\n}\r\nrdsdebug("conn %p for %pI4 to %pI4 complete\n",\r\nconn, &conn->c_laddr, &conn->c_faddr);\r\nconn->c_reconnect_jiffies = 0;\r\nset_bit(0, &conn->c_map_queued);\r\nqueue_delayed_work(rds_wq, &conn->c_send_w, 0);\r\nqueue_delayed_work(rds_wq, &conn->c_recv_w, 0);\r\n}\r\nvoid rds_queue_reconnect(struct rds_connection *conn)\r\n{\r\nunsigned long rand;\r\nrdsdebug("conn %p for %pI4 to %pI4 reconnect jiffies %lu\n",\r\nconn, &conn->c_laddr, &conn->c_faddr,\r\nconn->c_reconnect_jiffies);\r\nset_bit(RDS_RECONNECT_PENDING, &conn->c_flags);\r\nif (conn->c_reconnect_jiffies == 0) {\r\nconn->c_reconnect_jiffies = rds_sysctl_reconnect_min_jiffies;\r\nqueue_delayed_work(rds_wq, &conn->c_conn_w, 0);\r\nreturn;\r\n}\r\nget_random_bytes(&rand, sizeof(rand));\r\nrdsdebug("%lu delay %lu ceil conn %p for %pI4 -> %pI4\n",\r\nrand % conn->c_reconnect_jiffies, conn->c_reconnect_jiffies,\r\nconn, &conn->c_laddr, &conn->c_faddr);\r\nqueue_delayed_work(rds_wq, &conn->c_conn_w,\r\nrand % conn->c_reconnect_jiffies);\r\nconn->c_reconnect_jiffies = min(conn->c_reconnect_jiffies * 2,\r\nrds_sysctl_reconnect_max_jiffies);\r\n}\r\nvoid rds_connect_worker(struct work_struct *work)\r\n{\r\nstruct rds_connection *conn = container_of(work, struct rds_connection, c_conn_w.work);\r\nint ret;\r\nclear_bit(RDS_RECONNECT_PENDING, &conn->c_flags);\r\nif (rds_conn_transition(conn, RDS_CONN_DOWN, RDS_CONN_CONNECTING)) {\r\nret = conn->c_trans->conn_connect(conn);\r\nrdsdebug("conn %p for %pI4 to %pI4 dispatched, ret %d\n",\r\nconn, &conn->c_laddr, &conn->c_faddr, ret);\r\nif (ret) {\r\nif (rds_conn_transition(conn, RDS_CONN_CONNECTING, RDS_CONN_DOWN))\r\nrds_queue_reconnect(conn);\r\nelse\r\nrds_conn_error(conn, "RDS: connect failed\n");\r\n}\r\n}\r\n}\r\nvoid rds_send_worker(struct work_struct *work)\r\n{\r\nstruct rds_connection *conn = container_of(work, struct rds_connection, c_send_w.work);\r\nint ret;\r\nif (rds_conn_state(conn) == RDS_CONN_UP) {\r\nret = rds_send_xmit(conn);\r\nrdsdebug("conn %p ret %d\n", conn, ret);\r\nswitch (ret) {\r\ncase -EAGAIN:\r\nrds_stats_inc(s_send_immediate_retry);\r\nqueue_delayed_work(rds_wq, &conn->c_send_w, 0);\r\nbreak;\r\ncase -ENOMEM:\r\nrds_stats_inc(s_send_delayed_retry);\r\nqueue_delayed_work(rds_wq, &conn->c_send_w, 2);\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid rds_recv_worker(struct work_struct *work)\r\n{\r\nstruct rds_connection *conn = container_of(work, struct rds_connection, c_recv_w.work);\r\nint ret;\r\nif (rds_conn_state(conn) == RDS_CONN_UP) {\r\nret = conn->c_trans->recv(conn);\r\nrdsdebug("conn %p ret %d\n", conn, ret);\r\nswitch (ret) {\r\ncase -EAGAIN:\r\nrds_stats_inc(s_recv_immediate_retry);\r\nqueue_delayed_work(rds_wq, &conn->c_recv_w, 0);\r\nbreak;\r\ncase -ENOMEM:\r\nrds_stats_inc(s_recv_delayed_retry);\r\nqueue_delayed_work(rds_wq, &conn->c_recv_w, 2);\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid rds_shutdown_worker(struct work_struct *work)\r\n{\r\nstruct rds_connection *conn = container_of(work, struct rds_connection, c_down_w);\r\nrds_conn_shutdown(conn);\r\n}\r\nvoid rds_threads_exit(void)\r\n{\r\ndestroy_workqueue(rds_wq);\r\n}\r\nint rds_threads_init(void)\r\n{\r\nrds_wq = create_singlethread_workqueue("krdsd");\r\nif (!rds_wq)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}
