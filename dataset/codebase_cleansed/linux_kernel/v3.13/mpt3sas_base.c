static int\r\n_scsih_set_fwfault_debug(const char *val, struct kernel_param *kp)\r\n{\r\nint ret = param_set_int(val, kp);\r\nstruct MPT3SAS_ADAPTER *ioc;\r\nif (ret)\r\nreturn ret;\r\npr_info("setting fwfault_debug(%d)\n", mpt3sas_fwfault_debug);\r\nlist_for_each_entry(ioc, &mpt3sas_ioc_list, list)\r\nioc->fwfault_debug = mpt3sas_fwfault_debug;\r\nreturn 0;\r\n}\r\nstatic int mpt3sas_remove_dead_ioc_func(void *arg)\r\n{\r\nstruct MPT3SAS_ADAPTER *ioc = (struct MPT3SAS_ADAPTER *)arg;\r\nstruct pci_dev *pdev;\r\nif ((ioc == NULL))\r\nreturn -1;\r\npdev = ioc->pdev;\r\nif ((pdev == NULL))\r\nreturn -1;\r\npci_stop_and_remove_bus_device(pdev);\r\nreturn 0;\r\n}\r\nstatic void\r\n_base_fault_reset_work(struct work_struct *work)\r\n{\r\nstruct MPT3SAS_ADAPTER *ioc =\r\ncontainer_of(work, struct MPT3SAS_ADAPTER, fault_reset_work.work);\r\nunsigned long flags;\r\nu32 doorbell;\r\nint rc;\r\nstruct task_struct *p;\r\nspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\r\nif (ioc->shost_recovery)\r\ngoto rearm_timer;\r\nspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\r\ndoorbell = mpt3sas_base_get_iocstate(ioc, 0);\r\nif ((doorbell & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_MASK) {\r\npr_err(MPT3SAS_FMT "SAS host is non-operational !!!!\n",\r\nioc->name);\r\nioc->schedule_dead_ioc_flush_running_cmds(ioc);\r\nioc->remove_host = 1;\r\np = kthread_run(mpt3sas_remove_dead_ioc_func, ioc,\r\n"mpt3sas_dead_ioc_%d", ioc->id);\r\nif (IS_ERR(p))\r\npr_err(MPT3SAS_FMT\r\n"%s: Running mpt3sas_dead_ioc thread failed !!!!\n",\r\nioc->name, __func__);\r\nelse\r\npr_err(MPT3SAS_FMT\r\n"%s: Running mpt3sas_dead_ioc thread success !!!!\n",\r\nioc->name, __func__);\r\nreturn;\r\n}\r\nif ((doorbell & MPI2_IOC_STATE_MASK) != MPI2_IOC_STATE_OPERATIONAL) {\r\nrc = mpt3sas_base_hard_reset_handler(ioc, CAN_SLEEP,\r\nFORCE_BIG_HAMMER);\r\npr_warn(MPT3SAS_FMT "%s: hard reset: %s\n", ioc->name,\r\n__func__, (rc == 0) ? "success" : "failed");\r\ndoorbell = mpt3sas_base_get_iocstate(ioc, 0);\r\nif ((doorbell & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT)\r\nmpt3sas_base_fault_info(ioc, doorbell &\r\nMPI2_DOORBELL_DATA_MASK);\r\nif (rc && (doorbell & MPI2_IOC_STATE_MASK) !=\r\nMPI2_IOC_STATE_OPERATIONAL)\r\nreturn;\r\n}\r\nspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\r\nrearm_timer:\r\nif (ioc->fault_reset_work_q)\r\nqueue_delayed_work(ioc->fault_reset_work_q,\r\n&ioc->fault_reset_work,\r\nmsecs_to_jiffies(FAULT_POLLING_INTERVAL));\r\nspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\r\n}\r\nvoid\r\nmpt3sas_base_start_watchdog(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nunsigned long flags;\r\nif (ioc->fault_reset_work_q)\r\nreturn;\r\nINIT_DELAYED_WORK(&ioc->fault_reset_work, _base_fault_reset_work);\r\nsnprintf(ioc->fault_reset_work_q_name,\r\nsizeof(ioc->fault_reset_work_q_name), "poll_%d_status", ioc->id);\r\nioc->fault_reset_work_q =\r\ncreate_singlethread_workqueue(ioc->fault_reset_work_q_name);\r\nif (!ioc->fault_reset_work_q) {\r\npr_err(MPT3SAS_FMT "%s: failed (line=%d)\n",\r\nioc->name, __func__, __LINE__);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\r\nif (ioc->fault_reset_work_q)\r\nqueue_delayed_work(ioc->fault_reset_work_q,\r\n&ioc->fault_reset_work,\r\nmsecs_to_jiffies(FAULT_POLLING_INTERVAL));\r\nspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\r\n}\r\nvoid\r\nmpt3sas_base_stop_watchdog(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nunsigned long flags;\r\nstruct workqueue_struct *wq;\r\nspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\r\nwq = ioc->fault_reset_work_q;\r\nioc->fault_reset_work_q = NULL;\r\nspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\r\nif (wq) {\r\nif (!cancel_delayed_work(&ioc->fault_reset_work))\r\nflush_workqueue(wq);\r\ndestroy_workqueue(wq);\r\n}\r\n}\r\nvoid\r\nmpt3sas_base_fault_info(struct MPT3SAS_ADAPTER *ioc , u16 fault_code)\r\n{\r\npr_err(MPT3SAS_FMT "fault_state(0x%04x)!\n",\r\nioc->name, fault_code);\r\n}\r\nvoid\r\nmpt3sas_halt_firmware(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nu32 doorbell;\r\nif (!ioc->fwfault_debug)\r\nreturn;\r\ndump_stack();\r\ndoorbell = readl(&ioc->chip->Doorbell);\r\nif ((doorbell & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT)\r\nmpt3sas_base_fault_info(ioc , doorbell);\r\nelse {\r\nwritel(0xC0FFEE00, &ioc->chip->Doorbell);\r\npr_err(MPT3SAS_FMT "Firmware is halted due to command timeout\n",\r\nioc->name);\r\n}\r\nif (ioc->fwfault_debug == 2)\r\nfor (;;)\r\n;\r\nelse\r\npanic("panic in %s\n", __func__);\r\n}\r\nstatic void\r\n_base_sas_ioc_info(struct MPT3SAS_ADAPTER *ioc, MPI2DefaultReply_t *mpi_reply,\r\nMPI2RequestHeader_t *request_hdr)\r\n{\r\nu16 ioc_status = le16_to_cpu(mpi_reply->IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nchar *desc = NULL;\r\nu16 frame_sz;\r\nchar *func_str = NULL;\r\nif (request_hdr->Function == MPI2_FUNCTION_SCSI_IO_REQUEST ||\r\nrequest_hdr->Function == MPI2_FUNCTION_RAID_SCSI_IO_PASSTHROUGH ||\r\nrequest_hdr->Function == MPI2_FUNCTION_EVENT_NOTIFICATION)\r\nreturn;\r\nif (ioc_status == MPI2_IOCSTATUS_CONFIG_INVALID_PAGE)\r\nreturn;\r\nswitch (ioc_status) {\r\ncase MPI2_IOCSTATUS_INVALID_FUNCTION:\r\ndesc = "invalid function";\r\nbreak;\r\ncase MPI2_IOCSTATUS_BUSY:\r\ndesc = "busy";\r\nbreak;\r\ncase MPI2_IOCSTATUS_INVALID_SGL:\r\ndesc = "invalid sgl";\r\nbreak;\r\ncase MPI2_IOCSTATUS_INTERNAL_ERROR:\r\ndesc = "internal error";\r\nbreak;\r\ncase MPI2_IOCSTATUS_INVALID_VPID:\r\ndesc = "invalid vpid";\r\nbreak;\r\ncase MPI2_IOCSTATUS_INSUFFICIENT_RESOURCES:\r\ndesc = "insufficient resources";\r\nbreak;\r\ncase MPI2_IOCSTATUS_INVALID_FIELD:\r\ndesc = "invalid field";\r\nbreak;\r\ncase MPI2_IOCSTATUS_INVALID_STATE:\r\ndesc = "invalid state";\r\nbreak;\r\ncase MPI2_IOCSTATUS_OP_STATE_NOT_SUPPORTED:\r\ndesc = "op state not supported";\r\nbreak;\r\ncase MPI2_IOCSTATUS_CONFIG_INVALID_ACTION:\r\ndesc = "config invalid action";\r\nbreak;\r\ncase MPI2_IOCSTATUS_CONFIG_INVALID_TYPE:\r\ndesc = "config invalid type";\r\nbreak;\r\ncase MPI2_IOCSTATUS_CONFIG_INVALID_PAGE:\r\ndesc = "config invalid page";\r\nbreak;\r\ncase MPI2_IOCSTATUS_CONFIG_INVALID_DATA:\r\ndesc = "config invalid data";\r\nbreak;\r\ncase MPI2_IOCSTATUS_CONFIG_NO_DEFAULTS:\r\ndesc = "config no defaults";\r\nbreak;\r\ncase MPI2_IOCSTATUS_CONFIG_CANT_COMMIT:\r\ndesc = "config cant commit";\r\nbreak;\r\ncase MPI2_IOCSTATUS_SCSI_RECOVERED_ERROR:\r\ncase MPI2_IOCSTATUS_SCSI_INVALID_DEVHANDLE:\r\ncase MPI2_IOCSTATUS_SCSI_DEVICE_NOT_THERE:\r\ncase MPI2_IOCSTATUS_SCSI_DATA_OVERRUN:\r\ncase MPI2_IOCSTATUS_SCSI_DATA_UNDERRUN:\r\ncase MPI2_IOCSTATUS_SCSI_IO_DATA_ERROR:\r\ncase MPI2_IOCSTATUS_SCSI_PROTOCOL_ERROR:\r\ncase MPI2_IOCSTATUS_SCSI_TASK_TERMINATED:\r\ncase MPI2_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:\r\ncase MPI2_IOCSTATUS_SCSI_TASK_MGMT_FAILED:\r\ncase MPI2_IOCSTATUS_SCSI_IOC_TERMINATED:\r\ncase MPI2_IOCSTATUS_SCSI_EXT_TERMINATED:\r\nbreak;\r\ncase MPI2_IOCSTATUS_EEDP_GUARD_ERROR:\r\ndesc = "eedp guard error";\r\nbreak;\r\ncase MPI2_IOCSTATUS_EEDP_REF_TAG_ERROR:\r\ndesc = "eedp ref tag error";\r\nbreak;\r\ncase MPI2_IOCSTATUS_EEDP_APP_TAG_ERROR:\r\ndesc = "eedp app tag error";\r\nbreak;\r\ncase MPI2_IOCSTATUS_TARGET_INVALID_IO_INDEX:\r\ndesc = "target invalid io index";\r\nbreak;\r\ncase MPI2_IOCSTATUS_TARGET_ABORTED:\r\ndesc = "target aborted";\r\nbreak;\r\ncase MPI2_IOCSTATUS_TARGET_NO_CONN_RETRYABLE:\r\ndesc = "target no conn retryable";\r\nbreak;\r\ncase MPI2_IOCSTATUS_TARGET_NO_CONNECTION:\r\ndesc = "target no connection";\r\nbreak;\r\ncase MPI2_IOCSTATUS_TARGET_XFER_COUNT_MISMATCH:\r\ndesc = "target xfer count mismatch";\r\nbreak;\r\ncase MPI2_IOCSTATUS_TARGET_DATA_OFFSET_ERROR:\r\ndesc = "target data offset error";\r\nbreak;\r\ncase MPI2_IOCSTATUS_TARGET_TOO_MUCH_WRITE_DATA:\r\ndesc = "target too much write data";\r\nbreak;\r\ncase MPI2_IOCSTATUS_TARGET_IU_TOO_SHORT:\r\ndesc = "target iu too short";\r\nbreak;\r\ncase MPI2_IOCSTATUS_TARGET_ACK_NAK_TIMEOUT:\r\ndesc = "target ack nak timeout";\r\nbreak;\r\ncase MPI2_IOCSTATUS_TARGET_NAK_RECEIVED:\r\ndesc = "target nak received";\r\nbreak;\r\ncase MPI2_IOCSTATUS_SAS_SMP_REQUEST_FAILED:\r\ndesc = "smp request failed";\r\nbreak;\r\ncase MPI2_IOCSTATUS_SAS_SMP_DATA_OVERRUN:\r\ndesc = "smp data overrun";\r\nbreak;\r\ncase MPI2_IOCSTATUS_DIAGNOSTIC_RELEASED:\r\ndesc = "diagnostic released";\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!desc)\r\nreturn;\r\nswitch (request_hdr->Function) {\r\ncase MPI2_FUNCTION_CONFIG:\r\nframe_sz = sizeof(Mpi2ConfigRequest_t) + ioc->sge_size;\r\nfunc_str = "config_page";\r\nbreak;\r\ncase MPI2_FUNCTION_SCSI_TASK_MGMT:\r\nframe_sz = sizeof(Mpi2SCSITaskManagementRequest_t);\r\nfunc_str = "task_mgmt";\r\nbreak;\r\ncase MPI2_FUNCTION_SAS_IO_UNIT_CONTROL:\r\nframe_sz = sizeof(Mpi2SasIoUnitControlRequest_t);\r\nfunc_str = "sas_iounit_ctl";\r\nbreak;\r\ncase MPI2_FUNCTION_SCSI_ENCLOSURE_PROCESSOR:\r\nframe_sz = sizeof(Mpi2SepRequest_t);\r\nfunc_str = "enclosure";\r\nbreak;\r\ncase MPI2_FUNCTION_IOC_INIT:\r\nframe_sz = sizeof(Mpi2IOCInitRequest_t);\r\nfunc_str = "ioc_init";\r\nbreak;\r\ncase MPI2_FUNCTION_PORT_ENABLE:\r\nframe_sz = sizeof(Mpi2PortEnableRequest_t);\r\nfunc_str = "port_enable";\r\nbreak;\r\ncase MPI2_FUNCTION_SMP_PASSTHROUGH:\r\nframe_sz = sizeof(Mpi2SmpPassthroughRequest_t) + ioc->sge_size;\r\nfunc_str = "smp_passthru";\r\nbreak;\r\ndefault:\r\nframe_sz = 32;\r\nfunc_str = "unknown";\r\nbreak;\r\n}\r\npr_warn(MPT3SAS_FMT "ioc_status: %s(0x%04x), request(0x%p),(%s)\n",\r\nioc->name, desc, ioc_status, request_hdr, func_str);\r\n_debug_dump_mf(request_hdr, frame_sz/4);\r\n}\r\nstatic void\r\n_base_display_event_data(struct MPT3SAS_ADAPTER *ioc,\r\nMpi2EventNotificationReply_t *mpi_reply)\r\n{\r\nchar *desc = NULL;\r\nu16 event;\r\nif (!(ioc->logging_level & MPT_DEBUG_EVENTS))\r\nreturn;\r\nevent = le16_to_cpu(mpi_reply->Event);\r\nswitch (event) {\r\ncase MPI2_EVENT_LOG_DATA:\r\ndesc = "Log Data";\r\nbreak;\r\ncase MPI2_EVENT_STATE_CHANGE:\r\ndesc = "Status Change";\r\nbreak;\r\ncase MPI2_EVENT_HARD_RESET_RECEIVED:\r\ndesc = "Hard Reset Received";\r\nbreak;\r\ncase MPI2_EVENT_EVENT_CHANGE:\r\ndesc = "Event Change";\r\nbreak;\r\ncase MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE:\r\ndesc = "Device Status Change";\r\nbreak;\r\ncase MPI2_EVENT_IR_OPERATION_STATUS:\r\ndesc = "IR Operation Status";\r\nbreak;\r\ncase MPI2_EVENT_SAS_DISCOVERY:\r\n{\r\nMpi2EventDataSasDiscovery_t *event_data =\r\n(Mpi2EventDataSasDiscovery_t *)mpi_reply->EventData;\r\npr_info(MPT3SAS_FMT "Discovery: (%s)", ioc->name,\r\n(event_data->ReasonCode == MPI2_EVENT_SAS_DISC_RC_STARTED) ?\r\n"start" : "stop");\r\nif (event_data->DiscoveryStatus)\r\npr_info("discovery_status(0x%08x)",\r\nle32_to_cpu(event_data->DiscoveryStatus));\r\npr_info("\n");\r\nreturn;\r\n}\r\ncase MPI2_EVENT_SAS_BROADCAST_PRIMITIVE:\r\ndesc = "SAS Broadcast Primitive";\r\nbreak;\r\ncase MPI2_EVENT_SAS_INIT_DEVICE_STATUS_CHANGE:\r\ndesc = "SAS Init Device Status Change";\r\nbreak;\r\ncase MPI2_EVENT_SAS_INIT_TABLE_OVERFLOW:\r\ndesc = "SAS Init Table Overflow";\r\nbreak;\r\ncase MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST:\r\ndesc = "SAS Topology Change List";\r\nbreak;\r\ncase MPI2_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE:\r\ndesc = "SAS Enclosure Device Status Change";\r\nbreak;\r\ncase MPI2_EVENT_IR_VOLUME:\r\ndesc = "IR Volume";\r\nbreak;\r\ncase MPI2_EVENT_IR_PHYSICAL_DISK:\r\ndesc = "IR Physical Disk";\r\nbreak;\r\ncase MPI2_EVENT_IR_CONFIGURATION_CHANGE_LIST:\r\ndesc = "IR Configuration Change List";\r\nbreak;\r\ncase MPI2_EVENT_LOG_ENTRY_ADDED:\r\ndesc = "Log Entry Added";\r\nbreak;\r\n}\r\nif (!desc)\r\nreturn;\r\npr_info(MPT3SAS_FMT "%s\n", ioc->name, desc);\r\n}\r\nstatic void\r\n_base_sas_log_info(struct MPT3SAS_ADAPTER *ioc , u32 log_info)\r\n{\r\nunion loginfo_type {\r\nu32 loginfo;\r\nstruct {\r\nu32 subcode:16;\r\nu32 code:8;\r\nu32 originator:4;\r\nu32 bus_type:4;\r\n} dw;\r\n};\r\nunion loginfo_type sas_loginfo;\r\nchar *originator_str = NULL;\r\nsas_loginfo.loginfo = log_info;\r\nif (sas_loginfo.dw.bus_type != 3 )\r\nreturn;\r\nif (log_info == 0x31170000)\r\nreturn;\r\nif (ioc->ignore_loginfos && (log_info == 0x30050000 || log_info ==\r\n0x31140000 || log_info == 0x31130000))\r\nreturn;\r\nswitch (sas_loginfo.dw.originator) {\r\ncase 0:\r\noriginator_str = "IOP";\r\nbreak;\r\ncase 1:\r\noriginator_str = "PL";\r\nbreak;\r\ncase 2:\r\noriginator_str = "IR";\r\nbreak;\r\n}\r\npr_warn(MPT3SAS_FMT\r\n"log_info(0x%08x): originator(%s), code(0x%02x), sub_code(0x%04x)\n",\r\nioc->name, log_info,\r\noriginator_str, sas_loginfo.dw.code,\r\nsas_loginfo.dw.subcode);\r\n}\r\nstatic void\r\n_base_display_reply_info(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,\r\nu32 reply)\r\n{\r\nMPI2DefaultReply_t *mpi_reply;\r\nu16 ioc_status;\r\nu32 loginfo = 0;\r\nmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\r\nif (unlikely(!mpi_reply)) {\r\npr_err(MPT3SAS_FMT "mpi_reply not valid at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply->IOCStatus);\r\n#ifdef CONFIG_SCSI_MPT3SAS_LOGGING\r\nif ((ioc_status & MPI2_IOCSTATUS_MASK) &&\r\n(ioc->logging_level & MPT_DEBUG_REPLY)) {\r\n_base_sas_ioc_info(ioc , mpi_reply,\r\nmpt3sas_base_get_msg_frame(ioc, smid));\r\n}\r\n#endif\r\nif (ioc_status & MPI2_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE) {\r\nloginfo = le32_to_cpu(mpi_reply->IOCLogInfo);\r\n_base_sas_log_info(ioc, loginfo);\r\n}\r\nif (ioc_status || loginfo) {\r\nioc_status &= MPI2_IOCSTATUS_MASK;\r\nmpt3sas_trigger_mpi(ioc, ioc_status, loginfo);\r\n}\r\n}\r\nu8\r\nmpt3sas_base_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,\r\nu32 reply)\r\n{\r\nMPI2DefaultReply_t *mpi_reply;\r\nmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\r\nif (mpi_reply && mpi_reply->Function == MPI2_FUNCTION_EVENT_ACK)\r\nreturn 1;\r\nif (ioc->base_cmds.status == MPT3_CMD_NOT_USED)\r\nreturn 1;\r\nioc->base_cmds.status |= MPT3_CMD_COMPLETE;\r\nif (mpi_reply) {\r\nioc->base_cmds.status |= MPT3_CMD_REPLY_VALID;\r\nmemcpy(ioc->base_cmds.reply, mpi_reply, mpi_reply->MsgLength*4);\r\n}\r\nioc->base_cmds.status &= ~MPT3_CMD_PENDING;\r\ncomplete(&ioc->base_cmds.done);\r\nreturn 1;\r\n}\r\nstatic u8\r\n_base_async_event(struct MPT3SAS_ADAPTER *ioc, u8 msix_index, u32 reply)\r\n{\r\nMpi2EventNotificationReply_t *mpi_reply;\r\nMpi2EventAckRequest_t *ack_request;\r\nu16 smid;\r\nmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\r\nif (!mpi_reply)\r\nreturn 1;\r\nif (mpi_reply->Function != MPI2_FUNCTION_EVENT_NOTIFICATION)\r\nreturn 1;\r\n#ifdef CONFIG_SCSI_MPT3SAS_LOGGING\r\n_base_display_event_data(ioc, mpi_reply);\r\n#endif\r\nif (!(mpi_reply->AckRequired & MPI2_EVENT_NOTIFICATION_ACK_REQUIRED))\r\ngoto out;\r\nsmid = mpt3sas_base_get_smid(ioc, ioc->base_cb_idx);\r\nif (!smid) {\r\npr_err(MPT3SAS_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\ngoto out;\r\n}\r\nack_request = mpt3sas_base_get_msg_frame(ioc, smid);\r\nmemset(ack_request, 0, sizeof(Mpi2EventAckRequest_t));\r\nack_request->Function = MPI2_FUNCTION_EVENT_ACK;\r\nack_request->Event = mpi_reply->Event;\r\nack_request->EventContext = mpi_reply->EventContext;\r\nack_request->VF_ID = 0;\r\nack_request->VP_ID = 0;\r\nmpt3sas_base_put_smid_default(ioc, smid);\r\nout:\r\nmpt3sas_scsih_event_callback(ioc, msix_index, reply);\r\nmpt3sas_ctl_event_callback(ioc, msix_index, reply);\r\nreturn 1;\r\n}\r\nstatic u8\r\n_base_get_cb_idx(struct MPT3SAS_ADAPTER *ioc, u16 smid)\r\n{\r\nint i;\r\nu8 cb_idx;\r\nif (smid < ioc->hi_priority_smid) {\r\ni = smid - 1;\r\ncb_idx = ioc->scsi_lookup[i].cb_idx;\r\n} else if (smid < ioc->internal_smid) {\r\ni = smid - ioc->hi_priority_smid;\r\ncb_idx = ioc->hpr_lookup[i].cb_idx;\r\n} else if (smid <= ioc->hba_queue_depth) {\r\ni = smid - ioc->internal_smid;\r\ncb_idx = ioc->internal_lookup[i].cb_idx;\r\n} else\r\ncb_idx = 0xFF;\r\nreturn cb_idx;\r\n}\r\nstatic void\r\n_base_mask_interrupts(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nu32 him_register;\r\nioc->mask_interrupts = 1;\r\nhim_register = readl(&ioc->chip->HostInterruptMask);\r\nhim_register |= MPI2_HIM_DIM + MPI2_HIM_RIM + MPI2_HIM_RESET_IRQ_MASK;\r\nwritel(him_register, &ioc->chip->HostInterruptMask);\r\nreadl(&ioc->chip->HostInterruptMask);\r\n}\r\nstatic void\r\n_base_unmask_interrupts(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nu32 him_register;\r\nhim_register = readl(&ioc->chip->HostInterruptMask);\r\nhim_register &= ~MPI2_HIM_RIM;\r\nwritel(him_register, &ioc->chip->HostInterruptMask);\r\nioc->mask_interrupts = 0;\r\n}\r\nstatic irqreturn_t\r\n_base_interrupt(int irq, void *bus_id)\r\n{\r\nstruct adapter_reply_queue *reply_q = bus_id;\r\nunion reply_descriptor rd;\r\nu32 completed_cmds;\r\nu8 request_desript_type;\r\nu16 smid;\r\nu8 cb_idx;\r\nu32 reply;\r\nu8 msix_index = reply_q->msix_index;\r\nstruct MPT3SAS_ADAPTER *ioc = reply_q->ioc;\r\nMpi2ReplyDescriptorsUnion_t *rpf;\r\nu8 rc;\r\nif (ioc->mask_interrupts)\r\nreturn IRQ_NONE;\r\nif (!atomic_add_unless(&reply_q->busy, 1, 1))\r\nreturn IRQ_NONE;\r\nrpf = &reply_q->reply_post_free[reply_q->reply_post_host_index];\r\nrequest_desript_type = rpf->Default.ReplyFlags\r\n& MPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK;\r\nif (request_desript_type == MPI2_RPY_DESCRIPT_FLAGS_UNUSED) {\r\natomic_dec(&reply_q->busy);\r\nreturn IRQ_NONE;\r\n}\r\ncompleted_cmds = 0;\r\ncb_idx = 0xFF;\r\ndo {\r\nrd.word = le64_to_cpu(rpf->Words);\r\nif (rd.u.low == UINT_MAX || rd.u.high == UINT_MAX)\r\ngoto out;\r\nreply = 0;\r\nsmid = le16_to_cpu(rpf->Default.DescriptorTypeDependent1);\r\nif (request_desript_type ==\r\nMPI25_RPY_DESCRIPT_FLAGS_FAST_PATH_SCSI_IO_SUCCESS ||\r\nrequest_desript_type ==\r\nMPI2_RPY_DESCRIPT_FLAGS_SCSI_IO_SUCCESS) {\r\ncb_idx = _base_get_cb_idx(ioc, smid);\r\nif ((likely(cb_idx < MPT_MAX_CALLBACKS)) &&\r\n(likely(mpt_callbacks[cb_idx] != NULL))) {\r\nrc = mpt_callbacks[cb_idx](ioc, smid,\r\nmsix_index, 0);\r\nif (rc)\r\nmpt3sas_base_free_smid(ioc, smid);\r\n}\r\n} else if (request_desript_type ==\r\nMPI2_RPY_DESCRIPT_FLAGS_ADDRESS_REPLY) {\r\nreply = le32_to_cpu(\r\nrpf->AddressReply.ReplyFrameAddress);\r\nif (reply > ioc->reply_dma_max_address ||\r\nreply < ioc->reply_dma_min_address)\r\nreply = 0;\r\nif (smid) {\r\ncb_idx = _base_get_cb_idx(ioc, smid);\r\nif ((likely(cb_idx < MPT_MAX_CALLBACKS)) &&\r\n(likely(mpt_callbacks[cb_idx] != NULL))) {\r\nrc = mpt_callbacks[cb_idx](ioc, smid,\r\nmsix_index, reply);\r\nif (reply)\r\n_base_display_reply_info(ioc,\r\nsmid, msix_index, reply);\r\nif (rc)\r\nmpt3sas_base_free_smid(ioc,\r\nsmid);\r\n}\r\n} else {\r\n_base_async_event(ioc, msix_index, reply);\r\n}\r\nif (reply) {\r\nioc->reply_free_host_index =\r\n(ioc->reply_free_host_index ==\r\n(ioc->reply_free_queue_depth - 1)) ?\r\n0 : ioc->reply_free_host_index + 1;\r\nioc->reply_free[ioc->reply_free_host_index] =\r\ncpu_to_le32(reply);\r\nwmb();\r\nwritel(ioc->reply_free_host_index,\r\n&ioc->chip->ReplyFreeHostIndex);\r\n}\r\n}\r\nrpf->Words = cpu_to_le64(ULLONG_MAX);\r\nreply_q->reply_post_host_index =\r\n(reply_q->reply_post_host_index ==\r\n(ioc->reply_post_queue_depth - 1)) ? 0 :\r\nreply_q->reply_post_host_index + 1;\r\nrequest_desript_type =\r\nreply_q->reply_post_free[reply_q->reply_post_host_index].\r\nDefault.ReplyFlags & MPI2_RPY_DESCRIPT_FLAGS_TYPE_MASK;\r\ncompleted_cmds++;\r\nif (request_desript_type == MPI2_RPY_DESCRIPT_FLAGS_UNUSED)\r\ngoto out;\r\nif (!reply_q->reply_post_host_index)\r\nrpf = reply_q->reply_post_free;\r\nelse\r\nrpf++;\r\n} while (1);\r\nout:\r\nif (!completed_cmds) {\r\natomic_dec(&reply_q->busy);\r\nreturn IRQ_NONE;\r\n}\r\nwmb();\r\nwritel(reply_q->reply_post_host_index | (msix_index <<\r\nMPI2_RPHI_MSIX_INDEX_SHIFT), &ioc->chip->ReplyPostHostIndex);\r\natomic_dec(&reply_q->busy);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline int\r\n_base_is_controller_msix_enabled(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nreturn (ioc->facts.IOCCapabilities &\r\nMPI2_IOCFACTS_CAPABILITY_MSI_X_INDEX) && ioc->msix_enable;\r\n}\r\nvoid\r\nmpt3sas_base_flush_reply_queues(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nstruct adapter_reply_queue *reply_q;\r\nif (!_base_is_controller_msix_enabled(ioc))\r\nreturn;\r\nlist_for_each_entry(reply_q, &ioc->reply_queue_list, list) {\r\nif (ioc->shost_recovery)\r\nreturn;\r\nif (reply_q->msix_index == 0)\r\ncontinue;\r\n_base_interrupt(reply_q->vector, (void *)reply_q);\r\n}\r\n}\r\nvoid\r\nmpt3sas_base_release_callback_handler(u8 cb_idx)\r\n{\r\nmpt_callbacks[cb_idx] = NULL;\r\n}\r\nu8\r\nmpt3sas_base_register_callback_handler(MPT_CALLBACK cb_func)\r\n{\r\nu8 cb_idx;\r\nfor (cb_idx = MPT_MAX_CALLBACKS-1; cb_idx; cb_idx--)\r\nif (mpt_callbacks[cb_idx] == NULL)\r\nbreak;\r\nmpt_callbacks[cb_idx] = cb_func;\r\nreturn cb_idx;\r\n}\r\nvoid\r\nmpt3sas_base_initialize_callback_handler(void)\r\n{\r\nu8 cb_idx;\r\nfor (cb_idx = 0; cb_idx < MPT_MAX_CALLBACKS; cb_idx++)\r\nmpt3sas_base_release_callback_handler(cb_idx);\r\n}\r\nstatic void\r\n_base_build_zero_len_sge(struct MPT3SAS_ADAPTER *ioc, void *paddr)\r\n{\r\nu32 flags_length = (u32)((MPI2_SGE_FLAGS_LAST_ELEMENT |\r\nMPI2_SGE_FLAGS_END_OF_BUFFER | MPI2_SGE_FLAGS_END_OF_LIST |\r\nMPI2_SGE_FLAGS_SIMPLE_ELEMENT) <<\r\nMPI2_SGE_FLAGS_SHIFT);\r\nioc->base_add_sg_single(paddr, flags_length, -1);\r\n}\r\nstatic void\r\n_base_add_sg_single_32(void *paddr, u32 flags_length, dma_addr_t dma_addr)\r\n{\r\nMpi2SGESimple32_t *sgel = paddr;\r\nflags_length |= (MPI2_SGE_FLAGS_32_BIT_ADDRESSING |\r\nMPI2_SGE_FLAGS_SYSTEM_ADDRESS) << MPI2_SGE_FLAGS_SHIFT;\r\nsgel->FlagsLength = cpu_to_le32(flags_length);\r\nsgel->Address = cpu_to_le32(dma_addr);\r\n}\r\nstatic void\r\n_base_add_sg_single_64(void *paddr, u32 flags_length, dma_addr_t dma_addr)\r\n{\r\nMpi2SGESimple64_t *sgel = paddr;\r\nflags_length |= (MPI2_SGE_FLAGS_64_BIT_ADDRESSING |\r\nMPI2_SGE_FLAGS_SYSTEM_ADDRESS) << MPI2_SGE_FLAGS_SHIFT;\r\nsgel->FlagsLength = cpu_to_le32(flags_length);\r\nsgel->Address = cpu_to_le64(dma_addr);\r\n}\r\nstatic struct chain_tracker *\r\n_base_get_chain_buffer_tracker(struct MPT3SAS_ADAPTER *ioc, u16 smid)\r\n{\r\nstruct chain_tracker *chain_req;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nif (list_empty(&ioc->free_chain_list)) {\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\ndfailprintk(ioc, pr_warn(MPT3SAS_FMT\r\n"chain buffers not available\n", ioc->name));\r\nreturn NULL;\r\n}\r\nchain_req = list_entry(ioc->free_chain_list.next,\r\nstruct chain_tracker, tracker_list);\r\nlist_del_init(&chain_req->tracker_list);\r\nlist_add_tail(&chain_req->tracker_list,\r\n&ioc->scsi_lookup[smid - 1].chain_list);\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nreturn chain_req;\r\n}\r\nstatic void\r\n_base_build_sg(struct MPT3SAS_ADAPTER *ioc, void *psge,\r\ndma_addr_t data_out_dma, size_t data_out_sz, dma_addr_t data_in_dma,\r\nsize_t data_in_sz)\r\n{\r\nu32 sgl_flags;\r\nif (!data_out_sz && !data_in_sz) {\r\n_base_build_zero_len_sge(ioc, psge);\r\nreturn;\r\n}\r\nif (data_out_sz && data_in_sz) {\r\nsgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI2_SGE_FLAGS_END_OF_BUFFER | MPI2_SGE_FLAGS_HOST_TO_IOC);\r\nsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\r\nioc->base_add_sg_single(psge, sgl_flags |\r\ndata_out_sz, data_out_dma);\r\npsge += ioc->sge_size;\r\nsgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |\r\nMPI2_SGE_FLAGS_END_OF_LIST);\r\nsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\r\nioc->base_add_sg_single(psge, sgl_flags |\r\ndata_in_sz, data_in_dma);\r\n} else if (data_out_sz) {\r\nsgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |\r\nMPI2_SGE_FLAGS_END_OF_LIST | MPI2_SGE_FLAGS_HOST_TO_IOC);\r\nsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\r\nioc->base_add_sg_single(psge, sgl_flags |\r\ndata_out_sz, data_out_dma);\r\n} else if (data_in_sz) {\r\nsgl_flags = (MPI2_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI2_SGE_FLAGS_LAST_ELEMENT | MPI2_SGE_FLAGS_END_OF_BUFFER |\r\nMPI2_SGE_FLAGS_END_OF_LIST);\r\nsgl_flags = sgl_flags << MPI2_SGE_FLAGS_SHIFT;\r\nioc->base_add_sg_single(psge, sgl_flags |\r\ndata_in_sz, data_in_dma);\r\n}\r\n}\r\nstatic void\r\n_base_add_sg_single_ieee(void *paddr, u8 flags, u8 chain_offset, u32 length,\r\ndma_addr_t dma_addr)\r\n{\r\nMpi25IeeeSgeChain64_t *sgel = paddr;\r\nsgel->Flags = flags;\r\nsgel->NextChainOffset = chain_offset;\r\nsgel->Length = cpu_to_le32(length);\r\nsgel->Address = cpu_to_le64(dma_addr);\r\n}\r\nstatic void\r\n_base_build_zero_len_sge_ieee(struct MPT3SAS_ADAPTER *ioc, void *paddr)\r\n{\r\nu8 sgl_flags = (MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR |\r\nMPI25_IEEE_SGE_FLAGS_END_OF_LIST);\r\n_base_add_sg_single_ieee(paddr, sgl_flags, 0, 0, -1);\r\n}\r\nstatic int\r\n_base_build_sg_scmd_ieee(struct MPT3SAS_ADAPTER *ioc,\r\nstruct scsi_cmnd *scmd, u16 smid)\r\n{\r\nMpi2SCSIIORequest_t *mpi_request;\r\ndma_addr_t chain_dma;\r\nstruct scatterlist *sg_scmd;\r\nvoid *sg_local, *chain;\r\nu32 chain_offset;\r\nu32 chain_length;\r\nint sges_left;\r\nu32 sges_in_segment;\r\nu8 simple_sgl_flags;\r\nu8 simple_sgl_flags_last;\r\nu8 chain_sgl_flags;\r\nstruct chain_tracker *chain_req;\r\nmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\r\nsimple_sgl_flags = MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR;\r\nsimple_sgl_flags_last = simple_sgl_flags |\r\nMPI25_IEEE_SGE_FLAGS_END_OF_LIST;\r\nchain_sgl_flags = MPI2_IEEE_SGE_FLAGS_CHAIN_ELEMENT |\r\nMPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR;\r\nsg_scmd = scsi_sglist(scmd);\r\nsges_left = scsi_dma_map(scmd);\r\nif (!sges_left) {\r\nsdev_printk(KERN_ERR, scmd->device,\r\n"pci_map_sg failed: request for %d bytes!\n",\r\nscsi_bufflen(scmd));\r\nreturn -ENOMEM;\r\n}\r\nsg_local = &mpi_request->SGL;\r\nsges_in_segment = (ioc->request_sz -\r\noffsetof(Mpi2SCSIIORequest_t, SGL))/ioc->sge_size_ieee;\r\nif (sges_left <= sges_in_segment)\r\ngoto fill_in_last_segment;\r\nmpi_request->ChainOffset = (sges_in_segment - 1 ) +\r\n(offsetof(Mpi2SCSIIORequest_t, SGL)/ioc->sge_size_ieee);\r\nwhile (sges_in_segment > 1) {\r\n_base_add_sg_single_ieee(sg_local, simple_sgl_flags, 0,\r\nsg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\r\nsg_scmd = sg_next(sg_scmd);\r\nsg_local += ioc->sge_size_ieee;\r\nsges_left--;\r\nsges_in_segment--;\r\n}\r\nchain_req = _base_get_chain_buffer_tracker(ioc, smid);\r\nif (!chain_req)\r\nreturn -1;\r\nchain = chain_req->chain_buffer;\r\nchain_dma = chain_req->chain_buffer_dma;\r\ndo {\r\nsges_in_segment = (sges_left <=\r\nioc->max_sges_in_chain_message) ? sges_left :\r\nioc->max_sges_in_chain_message;\r\nchain_offset = (sges_left == sges_in_segment) ?\r\n0 : sges_in_segment;\r\nchain_length = sges_in_segment * ioc->sge_size_ieee;\r\nif (chain_offset)\r\nchain_length += ioc->sge_size_ieee;\r\n_base_add_sg_single_ieee(sg_local, chain_sgl_flags,\r\nchain_offset, chain_length, chain_dma);\r\nsg_local = chain;\r\nif (!chain_offset)\r\ngoto fill_in_last_segment;\r\nwhile (sges_in_segment) {\r\n_base_add_sg_single_ieee(sg_local, simple_sgl_flags, 0,\r\nsg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\r\nsg_scmd = sg_next(sg_scmd);\r\nsg_local += ioc->sge_size_ieee;\r\nsges_left--;\r\nsges_in_segment--;\r\n}\r\nchain_req = _base_get_chain_buffer_tracker(ioc, smid);\r\nif (!chain_req)\r\nreturn -1;\r\nchain = chain_req->chain_buffer;\r\nchain_dma = chain_req->chain_buffer_dma;\r\n} while (1);\r\nfill_in_last_segment:\r\nwhile (sges_left) {\r\nif (sges_left == 1)\r\n_base_add_sg_single_ieee(sg_local,\r\nsimple_sgl_flags_last, 0, sg_dma_len(sg_scmd),\r\nsg_dma_address(sg_scmd));\r\nelse\r\n_base_add_sg_single_ieee(sg_local, simple_sgl_flags, 0,\r\nsg_dma_len(sg_scmd), sg_dma_address(sg_scmd));\r\nsg_scmd = sg_next(sg_scmd);\r\nsg_local += ioc->sge_size_ieee;\r\nsges_left--;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\n_base_build_sg_ieee(struct MPT3SAS_ADAPTER *ioc, void *psge,\r\ndma_addr_t data_out_dma, size_t data_out_sz, dma_addr_t data_in_dma,\r\nsize_t data_in_sz)\r\n{\r\nu8 sgl_flags;\r\nif (!data_out_sz && !data_in_sz) {\r\n_base_build_zero_len_sge_ieee(ioc, psge);\r\nreturn;\r\n}\r\nif (data_out_sz && data_in_sz) {\r\nsgl_flags = MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR;\r\n_base_add_sg_single_ieee(psge, sgl_flags, 0, data_out_sz,\r\ndata_out_dma);\r\npsge += ioc->sge_size_ieee;\r\nsgl_flags |= MPI25_IEEE_SGE_FLAGS_END_OF_LIST;\r\n_base_add_sg_single_ieee(psge, sgl_flags, 0, data_in_sz,\r\ndata_in_dma);\r\n} else if (data_out_sz) {\r\nsgl_flags = MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI25_IEEE_SGE_FLAGS_END_OF_LIST |\r\nMPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR;\r\n_base_add_sg_single_ieee(psge, sgl_flags, 0, data_out_sz,\r\ndata_out_dma);\r\n} else if (data_in_sz) {\r\nsgl_flags = MPI2_IEEE_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI25_IEEE_SGE_FLAGS_END_OF_LIST |\r\nMPI2_IEEE_SGE_FLAGS_SYSTEM_ADDR;\r\n_base_add_sg_single_ieee(psge, sgl_flags, 0, data_in_sz,\r\ndata_in_dma);\r\n}\r\n}\r\nstatic int\r\n_base_config_dma_addressing(struct MPT3SAS_ADAPTER *ioc, struct pci_dev *pdev)\r\n{\r\nstruct sysinfo s;\r\nchar *desc = NULL;\r\nif (sizeof(dma_addr_t) > 4) {\r\nconst uint64_t required_mask =\r\ndma_get_required_mask(&pdev->dev);\r\nif ((required_mask > DMA_BIT_MASK(32)) &&\r\n!pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) &&\r\n!pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64))) {\r\nioc->base_add_sg_single = &_base_add_sg_single_64;\r\nioc->sge_size = sizeof(Mpi2SGESimple64_t);\r\ndesc = "64";\r\ngoto out;\r\n}\r\n}\r\nif (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32))\r\n&& !pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nioc->base_add_sg_single = &_base_add_sg_single_32;\r\nioc->sge_size = sizeof(Mpi2SGESimple32_t);\r\ndesc = "32";\r\n} else\r\nreturn -ENODEV;\r\nout:\r\nsi_meminfo(&s);\r\npr_info(MPT3SAS_FMT\r\n"%s BIT PCI BUS DMA ADDRESSING SUPPORTED, total mem (%ld kB)\n",\r\nioc->name, desc, convert_to_kb(s.totalram));\r\nreturn 0;\r\n}\r\nstatic int\r\n_base_check_enable_msix(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nint base;\r\nu16 message_control;\r\nbase = pci_find_capability(ioc->pdev, PCI_CAP_ID_MSIX);\r\nif (!base) {\r\ndfailprintk(ioc, pr_info(MPT3SAS_FMT "msix not supported\n",\r\nioc->name));\r\nreturn -EINVAL;\r\n}\r\npci_read_config_word(ioc->pdev, base + 2, &message_control);\r\nioc->msix_vector_count = (message_control & 0x3FF) + 1;\r\nif (ioc->msix_vector_count > 8)\r\nioc->msix_vector_count = 8;\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"msix is supported, vector_count(%d)\n",\r\nioc->name, ioc->msix_vector_count));\r\nreturn 0;\r\n}\r\nstatic void\r\n_base_free_irq(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nstruct adapter_reply_queue *reply_q, *next;\r\nif (list_empty(&ioc->reply_queue_list))\r\nreturn;\r\nlist_for_each_entry_safe(reply_q, next, &ioc->reply_queue_list, list) {\r\nlist_del(&reply_q->list);\r\nsynchronize_irq(reply_q->vector);\r\nfree_irq(reply_q->vector, reply_q);\r\nkfree(reply_q);\r\n}\r\n}\r\nstatic int\r\n_base_request_irq(struct MPT3SAS_ADAPTER *ioc, u8 index, u32 vector)\r\n{\r\nstruct adapter_reply_queue *reply_q;\r\nint r;\r\nreply_q = kzalloc(sizeof(struct adapter_reply_queue), GFP_KERNEL);\r\nif (!reply_q) {\r\npr_err(MPT3SAS_FMT "unable to allocate memory %d!\n",\r\nioc->name, (int)sizeof(struct adapter_reply_queue));\r\nreturn -ENOMEM;\r\n}\r\nreply_q->ioc = ioc;\r\nreply_q->msix_index = index;\r\nreply_q->vector = vector;\r\natomic_set(&reply_q->busy, 0);\r\nif (ioc->msix_enable)\r\nsnprintf(reply_q->name, MPT_NAME_LENGTH, "%s%d-msix%d",\r\nMPT3SAS_DRIVER_NAME, ioc->id, index);\r\nelse\r\nsnprintf(reply_q->name, MPT_NAME_LENGTH, "%s%d",\r\nMPT3SAS_DRIVER_NAME, ioc->id);\r\nr = request_irq(vector, _base_interrupt, IRQF_SHARED, reply_q->name,\r\nreply_q);\r\nif (r) {\r\npr_err(MPT3SAS_FMT "unable to allocate interrupt %d!\n",\r\nreply_q->name, vector);\r\nkfree(reply_q);\r\nreturn -EBUSY;\r\n}\r\nINIT_LIST_HEAD(&reply_q->list);\r\nlist_add_tail(&reply_q->list, &ioc->reply_queue_list);\r\nreturn 0;\r\n}\r\nstatic void\r\n_base_assign_reply_queues(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nstruct adapter_reply_queue *reply_q;\r\nint cpu_id;\r\nint cpu_grouping, loop, grouping, grouping_mod;\r\nint reply_queue;\r\nif (!_base_is_controller_msix_enabled(ioc))\r\nreturn;\r\nmemset(ioc->cpu_msix_table, 0, ioc->cpu_msix_table_sz);\r\nif (ioc->reply_queue_count > ioc->facts.MaxMSIxVectors) {\r\nioc->reply_queue_count = ioc->facts.MaxMSIxVectors;\r\nreply_queue = 0;\r\nlist_for_each_entry(reply_q, &ioc->reply_queue_list, list) {\r\nreply_q->msix_index = reply_queue;\r\nif (++reply_queue == ioc->reply_queue_count)\r\nreply_queue = 0;\r\n}\r\n}\r\nif (ioc->cpu_count > ioc->msix_vector_count) {\r\ngrouping = ioc->cpu_count / ioc->msix_vector_count;\r\ngrouping_mod = ioc->cpu_count % ioc->msix_vector_count;\r\nif (grouping < 2 || (grouping == 2 && !grouping_mod))\r\ncpu_grouping = 2;\r\nelse if (grouping < 4 || (grouping == 4 && !grouping_mod))\r\ncpu_grouping = 4;\r\nelse if (grouping < 8 || (grouping == 8 && !grouping_mod))\r\ncpu_grouping = 8;\r\nelse\r\ncpu_grouping = 16;\r\n} else\r\ncpu_grouping = 0;\r\nloop = 0;\r\nreply_q = list_entry(ioc->reply_queue_list.next,\r\nstruct adapter_reply_queue, list);\r\nfor_each_online_cpu(cpu_id) {\r\nif (!cpu_grouping) {\r\nioc->cpu_msix_table[cpu_id] = reply_q->msix_index;\r\nreply_q = list_entry(reply_q->list.next,\r\nstruct adapter_reply_queue, list);\r\n} else {\r\nif (loop < cpu_grouping) {\r\nioc->cpu_msix_table[cpu_id] =\r\nreply_q->msix_index;\r\nloop++;\r\n} else {\r\nreply_q = list_entry(reply_q->list.next,\r\nstruct adapter_reply_queue, list);\r\nioc->cpu_msix_table[cpu_id] =\r\nreply_q->msix_index;\r\nloop = 1;\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\n_base_disable_msix(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nif (!ioc->msix_enable)\r\nreturn;\r\npci_disable_msix(ioc->pdev);\r\nioc->msix_enable = 0;\r\n}\r\nstatic int\r\n_base_enable_msix(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nstruct msix_entry *entries, *a;\r\nint r;\r\nint i;\r\nu8 try_msix = 0;\r\nif (msix_disable == -1 || msix_disable == 0)\r\ntry_msix = 1;\r\nif (!try_msix)\r\ngoto try_ioapic;\r\nif (_base_check_enable_msix(ioc) != 0)\r\ngoto try_ioapic;\r\nioc->reply_queue_count = min_t(int, ioc->cpu_count,\r\nioc->msix_vector_count);\r\nprintk(MPT3SAS_FMT "MSI-X vectors supported: %d, no of cores"\r\n": %d, max_msix_vectors: %d\n", ioc->name, ioc->msix_vector_count,\r\nioc->cpu_count, max_msix_vectors);\r\nif (max_msix_vectors > 0) {\r\nioc->reply_queue_count = min_t(int, max_msix_vectors,\r\nioc->reply_queue_count);\r\nioc->msix_vector_count = ioc->reply_queue_count;\r\n}\r\nentries = kcalloc(ioc->reply_queue_count, sizeof(struct msix_entry),\r\nGFP_KERNEL);\r\nif (!entries) {\r\ndfailprintk(ioc, pr_info(MPT3SAS_FMT\r\n"kcalloc failed @ at %s:%d/%s() !!!\n",\r\nioc->name, __FILE__, __LINE__, __func__));\r\ngoto try_ioapic;\r\n}\r\nfor (i = 0, a = entries; i < ioc->reply_queue_count; i++, a++)\r\na->entry = i;\r\nr = pci_enable_msix(ioc->pdev, entries, ioc->reply_queue_count);\r\nif (r) {\r\ndfailprintk(ioc, pr_info(MPT3SAS_FMT\r\n"pci_enable_msix failed (r=%d) !!!\n",\r\nioc->name, r));\r\nkfree(entries);\r\ngoto try_ioapic;\r\n}\r\nioc->msix_enable = 1;\r\nfor (i = 0, a = entries; i < ioc->reply_queue_count; i++, a++) {\r\nr = _base_request_irq(ioc, i, a->vector);\r\nif (r) {\r\n_base_free_irq(ioc);\r\n_base_disable_msix(ioc);\r\nkfree(entries);\r\ngoto try_ioapic;\r\n}\r\n}\r\nkfree(entries);\r\nreturn 0;\r\ntry_ioapic:\r\nr = _base_request_irq(ioc, 0, ioc->pdev->irq);\r\nreturn r;\r\n}\r\nint\r\nmpt3sas_base_map_resources(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nstruct pci_dev *pdev = ioc->pdev;\r\nu32 memap_sz;\r\nu32 pio_sz;\r\nint i, r = 0;\r\nu64 pio_chip = 0;\r\nu64 chip_phys = 0;\r\nstruct adapter_reply_queue *reply_q;\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "%s\n",\r\nioc->name, __func__));\r\nioc->bars = pci_select_bars(pdev, IORESOURCE_MEM);\r\nif (pci_enable_device_mem(pdev)) {\r\npr_warn(MPT3SAS_FMT "pci_enable_device_mem: failed\n",\r\nioc->name);\r\nioc->bars = 0;\r\nreturn -ENODEV;\r\n}\r\nif (pci_request_selected_regions(pdev, ioc->bars,\r\nMPT3SAS_DRIVER_NAME)) {\r\npr_warn(MPT3SAS_FMT "pci_request_selected_regions: failed\n",\r\nioc->name);\r\nioc->bars = 0;\r\nr = -ENODEV;\r\ngoto out_fail;\r\n}\r\npci_enable_pcie_error_reporting(pdev);\r\npci_set_master(pdev);\r\nif (_base_config_dma_addressing(ioc, pdev) != 0) {\r\npr_warn(MPT3SAS_FMT "no suitable DMA mask for %s\n",\r\nioc->name, pci_name(pdev));\r\nr = -ENODEV;\r\ngoto out_fail;\r\n}\r\nfor (i = 0, memap_sz = 0, pio_sz = 0 ; i < DEVICE_COUNT_RESOURCE; i++) {\r\nif (pci_resource_flags(pdev, i) & IORESOURCE_IO) {\r\nif (pio_sz)\r\ncontinue;\r\npio_chip = (u64)pci_resource_start(pdev, i);\r\npio_sz = pci_resource_len(pdev, i);\r\n} else if (pci_resource_flags(pdev, i) & IORESOURCE_MEM) {\r\nif (memap_sz)\r\ncontinue;\r\nioc->chip_phys = pci_resource_start(pdev, i);\r\nchip_phys = (u64)ioc->chip_phys;\r\nmemap_sz = pci_resource_len(pdev, i);\r\nioc->chip = ioremap(ioc->chip_phys, memap_sz);\r\nif (ioc->chip == NULL) {\r\npr_err(MPT3SAS_FMT "unable to map adapter memory!\n",\r\nioc->name);\r\nr = -EINVAL;\r\ngoto out_fail;\r\n}\r\n}\r\n}\r\n_base_mask_interrupts(ioc);\r\nr = _base_enable_msix(ioc);\r\nif (r)\r\ngoto out_fail;\r\nlist_for_each_entry(reply_q, &ioc->reply_queue_list, list)\r\npr_info(MPT3SAS_FMT "%s: IRQ %d\n",\r\nreply_q->name, ((ioc->msix_enable) ? "PCI-MSI-X enabled" :\r\n"IO-APIC enabled"), reply_q->vector);\r\npr_info(MPT3SAS_FMT "iomem(0x%016llx), mapped(0x%p), size(%d)\n",\r\nioc->name, (unsigned long long)chip_phys, ioc->chip, memap_sz);\r\npr_info(MPT3SAS_FMT "ioport(0x%016llx), size(%d)\n",\r\nioc->name, (unsigned long long)pio_chip, pio_sz);\r\npci_save_state(pdev);\r\nreturn 0;\r\nout_fail:\r\nif (ioc->chip_phys)\r\niounmap(ioc->chip);\r\nioc->chip_phys = 0;\r\npci_release_selected_regions(ioc->pdev, ioc->bars);\r\npci_disable_pcie_error_reporting(pdev);\r\npci_disable_device(pdev);\r\nreturn r;\r\n}\r\nvoid *\r\nmpt3sas_base_get_msg_frame(struct MPT3SAS_ADAPTER *ioc, u16 smid)\r\n{\r\nreturn (void *)(ioc->request + (smid * ioc->request_sz));\r\n}\r\nvoid *\r\nmpt3sas_base_get_sense_buffer(struct MPT3SAS_ADAPTER *ioc, u16 smid)\r\n{\r\nreturn (void *)(ioc->sense + ((smid - 1) * SCSI_SENSE_BUFFERSIZE));\r\n}\r\n__le32\r\nmpt3sas_base_get_sense_buffer_dma(struct MPT3SAS_ADAPTER *ioc, u16 smid)\r\n{\r\nreturn cpu_to_le32(ioc->sense_dma + ((smid - 1) *\r\nSCSI_SENSE_BUFFERSIZE));\r\n}\r\nvoid *\r\nmpt3sas_base_get_reply_virt_addr(struct MPT3SAS_ADAPTER *ioc, u32 phys_addr)\r\n{\r\nif (!phys_addr)\r\nreturn NULL;\r\nreturn ioc->reply + (phys_addr - (u32)ioc->reply_dma);\r\n}\r\nu16\r\nmpt3sas_base_get_smid(struct MPT3SAS_ADAPTER *ioc, u8 cb_idx)\r\n{\r\nunsigned long flags;\r\nstruct request_tracker *request;\r\nu16 smid;\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nif (list_empty(&ioc->internal_free_list)) {\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\npr_err(MPT3SAS_FMT "%s: smid not available\n",\r\nioc->name, __func__);\r\nreturn 0;\r\n}\r\nrequest = list_entry(ioc->internal_free_list.next,\r\nstruct request_tracker, tracker_list);\r\nrequest->cb_idx = cb_idx;\r\nsmid = request->smid;\r\nlist_del(&request->tracker_list);\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nreturn smid;\r\n}\r\nu16\r\nmpt3sas_base_get_smid_scsiio(struct MPT3SAS_ADAPTER *ioc, u8 cb_idx,\r\nstruct scsi_cmnd *scmd)\r\n{\r\nunsigned long flags;\r\nstruct scsiio_tracker *request;\r\nu16 smid;\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nif (list_empty(&ioc->free_list)) {\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\npr_err(MPT3SAS_FMT "%s: smid not available\n",\r\nioc->name, __func__);\r\nreturn 0;\r\n}\r\nrequest = list_entry(ioc->free_list.next,\r\nstruct scsiio_tracker, tracker_list);\r\nrequest->scmd = scmd;\r\nrequest->cb_idx = cb_idx;\r\nsmid = request->smid;\r\nlist_del(&request->tracker_list);\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nreturn smid;\r\n}\r\nu16\r\nmpt3sas_base_get_smid_hpr(struct MPT3SAS_ADAPTER *ioc, u8 cb_idx)\r\n{\r\nunsigned long flags;\r\nstruct request_tracker *request;\r\nu16 smid;\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nif (list_empty(&ioc->hpr_free_list)) {\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nreturn 0;\r\n}\r\nrequest = list_entry(ioc->hpr_free_list.next,\r\nstruct request_tracker, tracker_list);\r\nrequest->cb_idx = cb_idx;\r\nsmid = request->smid;\r\nlist_del(&request->tracker_list);\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nreturn smid;\r\n}\r\nvoid\r\nmpt3sas_base_free_smid(struct MPT3SAS_ADAPTER *ioc, u16 smid)\r\n{\r\nunsigned long flags;\r\nint i;\r\nstruct chain_tracker *chain_req, *next;\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nif (smid < ioc->hi_priority_smid) {\r\ni = smid - 1;\r\nif (!list_empty(&ioc->scsi_lookup[i].chain_list)) {\r\nlist_for_each_entry_safe(chain_req, next,\r\n&ioc->scsi_lookup[i].chain_list, tracker_list) {\r\nlist_del_init(&chain_req->tracker_list);\r\nlist_add(&chain_req->tracker_list,\r\n&ioc->free_chain_list);\r\n}\r\n}\r\nioc->scsi_lookup[i].cb_idx = 0xFF;\r\nioc->scsi_lookup[i].scmd = NULL;\r\nlist_add(&ioc->scsi_lookup[i].tracker_list, &ioc->free_list);\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nif (ioc->shost_recovery && ioc->pending_io_count) {\r\nif (ioc->pending_io_count == 1)\r\nwake_up(&ioc->reset_wq);\r\nioc->pending_io_count--;\r\n}\r\nreturn;\r\n} else if (smid < ioc->internal_smid) {\r\ni = smid - ioc->hi_priority_smid;\r\nioc->hpr_lookup[i].cb_idx = 0xFF;\r\nlist_add(&ioc->hpr_lookup[i].tracker_list, &ioc->hpr_free_list);\r\n} else if (smid <= ioc->hba_queue_depth) {\r\ni = smid - ioc->internal_smid;\r\nioc->internal_lookup[i].cb_idx = 0xFF;\r\nlist_add(&ioc->internal_lookup[i].tracker_list,\r\n&ioc->internal_free_list);\r\n}\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\n}\r\nstatic inline void\r\n_base_writeq(__u64 b, volatile void __iomem *addr, spinlock_t *writeq_lock)\r\n{\r\nwriteq(cpu_to_le64(b), addr);\r\n}\r\nstatic inline void\r\n_base_writeq(__u64 b, volatile void __iomem *addr, spinlock_t *writeq_lock)\r\n{\r\nunsigned long flags;\r\n__u64 data_out = cpu_to_le64(b);\r\nspin_lock_irqsave(writeq_lock, flags);\r\nwritel((u32)(data_out), addr);\r\nwritel((u32)(data_out >> 32), (addr + 4));\r\nspin_unlock_irqrestore(writeq_lock, flags);\r\n}\r\nstatic inline u8\r\n_base_get_msix_index(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nreturn ioc->cpu_msix_table[raw_smp_processor_id()];\r\n}\r\nvoid\r\nmpt3sas_base_put_smid_scsi_io(struct MPT3SAS_ADAPTER *ioc, u16 smid, u16 handle)\r\n{\r\nMpi2RequestDescriptorUnion_t descriptor;\r\nu64 *request = (u64 *)&descriptor;\r\ndescriptor.SCSIIO.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_SCSI_IO;\r\ndescriptor.SCSIIO.MSIxIndex = _base_get_msix_index(ioc);\r\ndescriptor.SCSIIO.SMID = cpu_to_le16(smid);\r\ndescriptor.SCSIIO.DevHandle = cpu_to_le16(handle);\r\ndescriptor.SCSIIO.LMID = 0;\r\n_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,\r\n&ioc->scsi_lookup_lock);\r\n}\r\nvoid\r\nmpt3sas_base_put_smid_fast_path(struct MPT3SAS_ADAPTER *ioc, u16 smid,\r\nu16 handle)\r\n{\r\nMpi2RequestDescriptorUnion_t descriptor;\r\nu64 *request = (u64 *)&descriptor;\r\ndescriptor.SCSIIO.RequestFlags =\r\nMPI25_REQ_DESCRIPT_FLAGS_FAST_PATH_SCSI_IO;\r\ndescriptor.SCSIIO.MSIxIndex = _base_get_msix_index(ioc);\r\ndescriptor.SCSIIO.SMID = cpu_to_le16(smid);\r\ndescriptor.SCSIIO.DevHandle = cpu_to_le16(handle);\r\ndescriptor.SCSIIO.LMID = 0;\r\n_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,\r\n&ioc->scsi_lookup_lock);\r\n}\r\nvoid\r\nmpt3sas_base_put_smid_hi_priority(struct MPT3SAS_ADAPTER *ioc, u16 smid)\r\n{\r\nMpi2RequestDescriptorUnion_t descriptor;\r\nu64 *request = (u64 *)&descriptor;\r\ndescriptor.HighPriority.RequestFlags =\r\nMPI2_REQ_DESCRIPT_FLAGS_HIGH_PRIORITY;\r\ndescriptor.HighPriority.MSIxIndex = 0;\r\ndescriptor.HighPriority.SMID = cpu_to_le16(smid);\r\ndescriptor.HighPriority.LMID = 0;\r\ndescriptor.HighPriority.Reserved1 = 0;\r\n_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,\r\n&ioc->scsi_lookup_lock);\r\n}\r\nvoid\r\nmpt3sas_base_put_smid_default(struct MPT3SAS_ADAPTER *ioc, u16 smid)\r\n{\r\nMpi2RequestDescriptorUnion_t descriptor;\r\nu64 *request = (u64 *)&descriptor;\r\ndescriptor.Default.RequestFlags = MPI2_REQ_DESCRIPT_FLAGS_DEFAULT_TYPE;\r\ndescriptor.Default.MSIxIndex = _base_get_msix_index(ioc);\r\ndescriptor.Default.SMID = cpu_to_le16(smid);\r\ndescriptor.Default.LMID = 0;\r\ndescriptor.Default.DescriptorTypeDependent = 0;\r\n_base_writeq(*request, &ioc->chip->RequestDescriptorPostLow,\r\n&ioc->scsi_lookup_lock);\r\n}\r\nstatic void\r\n_base_display_ioc_capabilities(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nint i = 0;\r\nchar desc[16];\r\nu32 iounit_pg1_flags;\r\nu32 bios_version;\r\nbios_version = le32_to_cpu(ioc->bios_pg3.BiosVersion);\r\nstrncpy(desc, ioc->manu_pg0.ChipName, 16);\r\npr_info(MPT3SAS_FMT "%s: FWVersion(%02d.%02d.%02d.%02d), "\\r\n"ChipRevision(0x%02x), BiosVersion(%02d.%02d.%02d.%02d)\n",\r\nioc->name, desc,\r\n(ioc->facts.FWVersion.Word & 0xFF000000) >> 24,\r\n(ioc->facts.FWVersion.Word & 0x00FF0000) >> 16,\r\n(ioc->facts.FWVersion.Word & 0x0000FF00) >> 8,\r\nioc->facts.FWVersion.Word & 0x000000FF,\r\nioc->pdev->revision,\r\n(bios_version & 0xFF000000) >> 24,\r\n(bios_version & 0x00FF0000) >> 16,\r\n(bios_version & 0x0000FF00) >> 8,\r\nbios_version & 0x000000FF);\r\npr_info(MPT3SAS_FMT "Protocol=(", ioc->name);\r\nif (ioc->facts.ProtocolFlags & MPI2_IOCFACTS_PROTOCOL_SCSI_INITIATOR) {\r\npr_info("Initiator");\r\ni++;\r\n}\r\nif (ioc->facts.ProtocolFlags & MPI2_IOCFACTS_PROTOCOL_SCSI_TARGET) {\r\npr_info("%sTarget", i ? "," : "");\r\ni++;\r\n}\r\ni = 0;\r\npr_info("), ");\r\npr_info("Capabilities=(");\r\nif (ioc->facts.IOCCapabilities &\r\nMPI2_IOCFACTS_CAPABILITY_INTEGRATED_RAID) {\r\npr_info("Raid");\r\ni++;\r\n}\r\nif (ioc->facts.IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_TLR) {\r\npr_info("%sTLR", i ? "," : "");\r\ni++;\r\n}\r\nif (ioc->facts.IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_MULTICAST) {\r\npr_info("%sMulticast", i ? "," : "");\r\ni++;\r\n}\r\nif (ioc->facts.IOCCapabilities &\r\nMPI2_IOCFACTS_CAPABILITY_BIDIRECTIONAL_TARGET) {\r\npr_info("%sBIDI Target", i ? "," : "");\r\ni++;\r\n}\r\nif (ioc->facts.IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_EEDP) {\r\npr_info("%sEEDP", i ? "," : "");\r\ni++;\r\n}\r\nif (ioc->facts.IOCCapabilities &\r\nMPI2_IOCFACTS_CAPABILITY_SNAPSHOT_BUFFER) {\r\npr_info("%sSnapshot Buffer", i ? "," : "");\r\ni++;\r\n}\r\nif (ioc->facts.IOCCapabilities &\r\nMPI2_IOCFACTS_CAPABILITY_DIAG_TRACE_BUFFER) {\r\npr_info("%sDiag Trace Buffer", i ? "," : "");\r\ni++;\r\n}\r\nif (ioc->facts.IOCCapabilities &\r\nMPI2_IOCFACTS_CAPABILITY_EXTENDED_BUFFER) {\r\npr_info("%sDiag Extended Buffer", i ? "," : "");\r\ni++;\r\n}\r\nif (ioc->facts.IOCCapabilities &\r\nMPI2_IOCFACTS_CAPABILITY_TASK_SET_FULL_HANDLING) {\r\npr_info("%sTask Set Full", i ? "," : "");\r\ni++;\r\n}\r\niounit_pg1_flags = le32_to_cpu(ioc->iounit_pg1.Flags);\r\nif (!(iounit_pg1_flags & MPI2_IOUNITPAGE1_NATIVE_COMMAND_Q_DISABLE)) {\r\npr_info("%sNCQ", i ? "," : "");\r\ni++;\r\n}\r\npr_info(")\n");\r\n}\r\nvoid\r\nmpt3sas_base_update_missing_delay(struct MPT3SAS_ADAPTER *ioc,\r\nu16 device_missing_delay, u8 io_missing_delay)\r\n{\r\nu16 dmd, dmd_new, dmd_orignal;\r\nu8 io_missing_delay_original;\r\nu16 sz;\r\nMpi2SasIOUnitPage1_t *sas_iounit_pg1 = NULL;\r\nMpi2ConfigReply_t mpi_reply;\r\nu8 num_phys = 0;\r\nu16 ioc_status;\r\nmpt3sas_config_get_number_hba_phys(ioc, &num_phys);\r\nif (!num_phys)\r\nreturn;\r\nsz = offsetof(Mpi2SasIOUnitPage1_t, PhyData) + (num_phys *\r\nsizeof(Mpi2SasIOUnit1PhyData_t));\r\nsas_iounit_pg1 = kzalloc(sz, GFP_KERNEL);\r\nif (!sas_iounit_pg1) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out;\r\n}\r\nif ((mpt3sas_config_get_sas_iounit_pg1(ioc, &mpi_reply,\r\nsas_iounit_pg1, sz))) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out;\r\n}\r\ndmd = sas_iounit_pg1->ReportDeviceMissingDelay;\r\nif (dmd & MPI2_SASIOUNIT1_REPORT_MISSING_UNIT_16)\r\ndmd = (dmd & MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK) * 16;\r\nelse\r\ndmd = dmd & MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK;\r\ndmd_orignal = dmd;\r\nif (device_missing_delay > 0x7F) {\r\ndmd = (device_missing_delay > 0x7F0) ? 0x7F0 :\r\ndevice_missing_delay;\r\ndmd = dmd / 16;\r\ndmd |= MPI2_SASIOUNIT1_REPORT_MISSING_UNIT_16;\r\n} else\r\ndmd = device_missing_delay;\r\nsas_iounit_pg1->ReportDeviceMissingDelay = dmd;\r\nio_missing_delay_original = sas_iounit_pg1->IODeviceMissingDelay;\r\nsas_iounit_pg1->IODeviceMissingDelay = io_missing_delay;\r\nif (!mpt3sas_config_set_sas_iounit_pg1(ioc, &mpi_reply, sas_iounit_pg1,\r\nsz)) {\r\nif (dmd & MPI2_SASIOUNIT1_REPORT_MISSING_UNIT_16)\r\ndmd_new = (dmd &\r\nMPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK) * 16;\r\nelse\r\ndmd_new =\r\ndmd & MPI2_SASIOUNIT1_REPORT_MISSING_TIMEOUT_MASK;\r\npr_info(MPT3SAS_FMT "device_missing_delay: old(%d), new(%d)\n",\r\nioc->name, dmd_orignal, dmd_new);\r\npr_info(MPT3SAS_FMT "ioc_missing_delay: old(%d), new(%d)\n",\r\nioc->name, io_missing_delay_original,\r\nio_missing_delay);\r\nioc->device_missing_delay = dmd_new;\r\nioc->io_missing_delay = io_missing_delay;\r\n}\r\nout:\r\nkfree(sas_iounit_pg1);\r\n}\r\nstatic void\r\n_base_static_config_pages(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nMpi2ConfigReply_t mpi_reply;\r\nu32 iounit_pg1_flags;\r\nmpt3sas_config_get_manufacturing_pg0(ioc, &mpi_reply, &ioc->manu_pg0);\r\nif (ioc->ir_firmware)\r\nmpt3sas_config_get_manufacturing_pg10(ioc, &mpi_reply,\r\n&ioc->manu_pg10);\r\nmpt3sas_config_get_manufacturing_pg11(ioc, &mpi_reply, &ioc->manu_pg11);\r\nif (ioc->manu_pg11.EEDPTagMode == 0) {\r\npr_err("%s: overriding NVDATA EEDPTagMode setting\n",\r\nioc->name);\r\nioc->manu_pg11.EEDPTagMode &= ~0x3;\r\nioc->manu_pg11.EEDPTagMode |= 0x1;\r\nmpt3sas_config_set_manufacturing_pg11(ioc, &mpi_reply,\r\n&ioc->manu_pg11);\r\n}\r\nmpt3sas_config_get_bios_pg2(ioc, &mpi_reply, &ioc->bios_pg2);\r\nmpt3sas_config_get_bios_pg3(ioc, &mpi_reply, &ioc->bios_pg3);\r\nmpt3sas_config_get_ioc_pg8(ioc, &mpi_reply, &ioc->ioc_pg8);\r\nmpt3sas_config_get_iounit_pg0(ioc, &mpi_reply, &ioc->iounit_pg0);\r\nmpt3sas_config_get_iounit_pg1(ioc, &mpi_reply, &ioc->iounit_pg1);\r\n_base_display_ioc_capabilities(ioc);\r\niounit_pg1_flags = le32_to_cpu(ioc->iounit_pg1.Flags);\r\nif ((ioc->facts.IOCCapabilities &\r\nMPI2_IOCFACTS_CAPABILITY_TASK_SET_FULL_HANDLING))\r\niounit_pg1_flags &=\r\n~MPI2_IOUNITPAGE1_DISABLE_TASK_SET_FULL_HANDLING;\r\nelse\r\niounit_pg1_flags |=\r\nMPI2_IOUNITPAGE1_DISABLE_TASK_SET_FULL_HANDLING;\r\nioc->iounit_pg1.Flags = cpu_to_le32(iounit_pg1_flags);\r\nmpt3sas_config_set_iounit_pg1(ioc, &mpi_reply, &ioc->iounit_pg1);\r\n}\r\nstatic void\r\n_base_release_memory_pools(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nint i;\r\ndexitprintk(ioc, pr_info(MPT3SAS_FMT "%s\n", ioc->name,\r\n__func__));\r\nif (ioc->request) {\r\npci_free_consistent(ioc->pdev, ioc->request_dma_sz,\r\nioc->request, ioc->request_dma);\r\ndexitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"request_pool(0x%p): free\n",\r\nioc->name, ioc->request));\r\nioc->request = NULL;\r\n}\r\nif (ioc->sense) {\r\npci_pool_free(ioc->sense_dma_pool, ioc->sense, ioc->sense_dma);\r\nif (ioc->sense_dma_pool)\r\npci_pool_destroy(ioc->sense_dma_pool);\r\ndexitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"sense_pool(0x%p): free\n",\r\nioc->name, ioc->sense));\r\nioc->sense = NULL;\r\n}\r\nif (ioc->reply) {\r\npci_pool_free(ioc->reply_dma_pool, ioc->reply, ioc->reply_dma);\r\nif (ioc->reply_dma_pool)\r\npci_pool_destroy(ioc->reply_dma_pool);\r\ndexitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"reply_pool(0x%p): free\n",\r\nioc->name, ioc->reply));\r\nioc->reply = NULL;\r\n}\r\nif (ioc->reply_free) {\r\npci_pool_free(ioc->reply_free_dma_pool, ioc->reply_free,\r\nioc->reply_free_dma);\r\nif (ioc->reply_free_dma_pool)\r\npci_pool_destroy(ioc->reply_free_dma_pool);\r\ndexitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"reply_free_pool(0x%p): free\n",\r\nioc->name, ioc->reply_free));\r\nioc->reply_free = NULL;\r\n}\r\nif (ioc->reply_post_free) {\r\npci_pool_free(ioc->reply_post_free_dma_pool,\r\nioc->reply_post_free, ioc->reply_post_free_dma);\r\nif (ioc->reply_post_free_dma_pool)\r\npci_pool_destroy(ioc->reply_post_free_dma_pool);\r\ndexitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"reply_post_free_pool(0x%p): free\n", ioc->name,\r\nioc->reply_post_free));\r\nioc->reply_post_free = NULL;\r\n}\r\nif (ioc->config_page) {\r\ndexitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"config_page(0x%p): free\n", ioc->name,\r\nioc->config_page));\r\npci_free_consistent(ioc->pdev, ioc->config_page_sz,\r\nioc->config_page, ioc->config_page_dma);\r\n}\r\nif (ioc->scsi_lookup) {\r\nfree_pages((ulong)ioc->scsi_lookup, ioc->scsi_lookup_pages);\r\nioc->scsi_lookup = NULL;\r\n}\r\nkfree(ioc->hpr_lookup);\r\nkfree(ioc->internal_lookup);\r\nif (ioc->chain_lookup) {\r\nfor (i = 0; i < ioc->chain_depth; i++) {\r\nif (ioc->chain_lookup[i].chain_buffer)\r\npci_pool_free(ioc->chain_dma_pool,\r\nioc->chain_lookup[i].chain_buffer,\r\nioc->chain_lookup[i].chain_buffer_dma);\r\n}\r\nif (ioc->chain_dma_pool)\r\npci_pool_destroy(ioc->chain_dma_pool);\r\nfree_pages((ulong)ioc->chain_lookup, ioc->chain_pages);\r\nioc->chain_lookup = NULL;\r\n}\r\n}\r\nstatic int\r\n_base_allocate_memory_pools(struct MPT3SAS_ADAPTER *ioc, int sleep_flag)\r\n{\r\nstruct mpt3sas_facts *facts;\r\nu16 max_sge_elements;\r\nu16 chains_needed_per_io;\r\nu32 sz, total_sz, reply_post_free_sz;\r\nu32 retry_sz;\r\nu16 max_request_credit;\r\nunsigned short sg_tablesize;\r\nu16 sge_size;\r\nint i;\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "%s\n", ioc->name,\r\n__func__));\r\nretry_sz = 0;\r\nfacts = &ioc->facts;\r\nif (max_sgl_entries != -1)\r\nsg_tablesize = max_sgl_entries;\r\nelse\r\nsg_tablesize = MPT3SAS_SG_DEPTH;\r\nif (sg_tablesize < MPT3SAS_MIN_PHYS_SEGMENTS)\r\nsg_tablesize = MPT3SAS_MIN_PHYS_SEGMENTS;\r\nelse if (sg_tablesize > MPT3SAS_MAX_PHYS_SEGMENTS)\r\nsg_tablesize = MPT3SAS_MAX_PHYS_SEGMENTS;\r\nioc->shost->sg_tablesize = sg_tablesize;\r\nioc->hi_priority_depth = facts->HighPriorityCredit;\r\nioc->internal_depth = ioc->hi_priority_depth + (5);\r\nif (max_queue_depth != -1 && max_queue_depth != 0) {\r\nmax_request_credit = min_t(u16, max_queue_depth +\r\nioc->hi_priority_depth + ioc->internal_depth,\r\nfacts->RequestCredit);\r\nif (max_request_credit > MAX_HBA_QUEUE_DEPTH)\r\nmax_request_credit = MAX_HBA_QUEUE_DEPTH;\r\n} else\r\nmax_request_credit = min_t(u16, facts->RequestCredit,\r\nMAX_HBA_QUEUE_DEPTH);\r\nioc->hba_queue_depth = max_request_credit;\r\nioc->request_sz = facts->IOCRequestFrameSize * 4;\r\nioc->reply_sz = facts->ReplyFrameSize * 4;\r\nsge_size = max_t(u16, ioc->sge_size, ioc->sge_size_ieee);\r\nretry_allocation:\r\ntotal_sz = 0;\r\nmax_sge_elements = ioc->request_sz - ((sizeof(Mpi2SCSIIORequest_t) -\r\nsizeof(Mpi2SGEIOUnion_t)) + sge_size);\r\nioc->max_sges_in_main_message = max_sge_elements/sge_size;\r\nmax_sge_elements = ioc->request_sz - sge_size;\r\nioc->max_sges_in_chain_message = max_sge_elements/sge_size;\r\nchains_needed_per_io = ((ioc->shost->sg_tablesize -\r\nioc->max_sges_in_main_message)/ioc->max_sges_in_chain_message)\r\n+ 1;\r\nif (chains_needed_per_io > facts->MaxChainDepth) {\r\nchains_needed_per_io = facts->MaxChainDepth;\r\nioc->shost->sg_tablesize = min_t(u16,\r\nioc->max_sges_in_main_message + (ioc->max_sges_in_chain_message\r\n* chains_needed_per_io), ioc->shost->sg_tablesize);\r\n}\r\nioc->chains_needed_per_io = chains_needed_per_io;\r\nioc->reply_free_queue_depth = ioc->hba_queue_depth + 64;\r\nioc->reply_post_queue_depth = ioc->hba_queue_depth +\r\nioc->reply_free_queue_depth + 1 ;\r\nif (ioc->reply_post_queue_depth % 16)\r\nioc->reply_post_queue_depth += 16 -\r\n(ioc->reply_post_queue_depth % 16);\r\nif (ioc->reply_post_queue_depth >\r\nfacts->MaxReplyDescriptorPostQueueDepth) {\r\nioc->reply_post_queue_depth =\r\nfacts->MaxReplyDescriptorPostQueueDepth -\r\n(facts->MaxReplyDescriptorPostQueueDepth % 16);\r\nioc->hba_queue_depth =\r\n((ioc->reply_post_queue_depth - 64) / 2) - 1;\r\nioc->reply_free_queue_depth = ioc->hba_queue_depth + 64;\r\n}\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "scatter gather: " \\r\n"sge_in_main_msg(%d), sge_per_chain(%d), sge_per_io(%d), "\r\n"chains_per_io(%d)\n", ioc->name, ioc->max_sges_in_main_message,\r\nioc->max_sges_in_chain_message, ioc->shost->sg_tablesize,\r\nioc->chains_needed_per_io));\r\nioc->scsiio_depth = ioc->hba_queue_depth -\r\nioc->hi_priority_depth - ioc->internal_depth;\r\nioc->shost->can_queue = ioc->scsiio_depth;\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"scsi host: can_queue depth (%d)\n",\r\nioc->name, ioc->shost->can_queue));\r\nioc->chain_depth = ioc->chains_needed_per_io * ioc->scsiio_depth;\r\nsz = ((ioc->scsiio_depth + 1) * ioc->request_sz);\r\nsz += (ioc->hi_priority_depth * ioc->request_sz);\r\nsz += (ioc->internal_depth * ioc->request_sz);\r\nioc->request_dma_sz = sz;\r\nioc->request = pci_alloc_consistent(ioc->pdev, sz, &ioc->request_dma);\r\nif (!ioc->request) {\r\npr_err(MPT3SAS_FMT "request pool: pci_alloc_consistent " \\r\n"failed: hba_depth(%d), chains_per_io(%d), frame_sz(%d), "\r\n"total(%d kB)\n", ioc->name, ioc->hba_queue_depth,\r\nioc->chains_needed_per_io, ioc->request_sz, sz/1024);\r\nif (ioc->scsiio_depth < MPT3SAS_SAS_QUEUE_DEPTH)\r\ngoto out;\r\nretry_sz += 64;\r\nioc->hba_queue_depth = max_request_credit - retry_sz;\r\ngoto retry_allocation;\r\n}\r\nif (retry_sz)\r\npr_err(MPT3SAS_FMT "request pool: pci_alloc_consistent " \\r\n"succeed: hba_depth(%d), chains_per_io(%d), frame_sz(%d), "\r\n"total(%d kb)\n", ioc->name, ioc->hba_queue_depth,\r\nioc->chains_needed_per_io, ioc->request_sz, sz/1024);\r\nioc->hi_priority = ioc->request + ((ioc->scsiio_depth + 1) *\r\nioc->request_sz);\r\nioc->hi_priority_dma = ioc->request_dma + ((ioc->scsiio_depth + 1) *\r\nioc->request_sz);\r\nioc->internal = ioc->hi_priority + (ioc->hi_priority_depth *\r\nioc->request_sz);\r\nioc->internal_dma = ioc->hi_priority_dma + (ioc->hi_priority_depth *\r\nioc->request_sz);\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"request pool(0x%p): depth(%d), frame_size(%d), pool_size(%d kB)\n",\r\nioc->name, ioc->request, ioc->hba_queue_depth, ioc->request_sz,\r\n(ioc->hba_queue_depth * ioc->request_sz)/1024));\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "request pool: dma(0x%llx)\n",\r\nioc->name, (unsigned long long) ioc->request_dma));\r\ntotal_sz += sz;\r\nsz = ioc->scsiio_depth * sizeof(struct scsiio_tracker);\r\nioc->scsi_lookup_pages = get_order(sz);\r\nioc->scsi_lookup = (struct scsiio_tracker *)__get_free_pages(\r\nGFP_KERNEL, ioc->scsi_lookup_pages);\r\nif (!ioc->scsi_lookup) {\r\npr_err(MPT3SAS_FMT "scsi_lookup: get_free_pages failed, sz(%d)\n",\r\nioc->name, (int)sz);\r\ngoto out;\r\n}\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "scsiio(0x%p): depth(%d)\n",\r\nioc->name, ioc->request, ioc->scsiio_depth));\r\nioc->chain_depth = min_t(u32, ioc->chain_depth, MAX_CHAIN_DEPTH);\r\nsz = ioc->chain_depth * sizeof(struct chain_tracker);\r\nioc->chain_pages = get_order(sz);\r\nioc->chain_lookup = (struct chain_tracker *)__get_free_pages(\r\nGFP_KERNEL, ioc->chain_pages);\r\nif (!ioc->chain_lookup) {\r\npr_err(MPT3SAS_FMT "chain_lookup: __get_free_pages failed\n",\r\nioc->name);\r\ngoto out;\r\n}\r\nioc->chain_dma_pool = pci_pool_create("chain pool", ioc->pdev,\r\nioc->request_sz, 16, 0);\r\nif (!ioc->chain_dma_pool) {\r\npr_err(MPT3SAS_FMT "chain_dma_pool: pci_pool_create failed\n",\r\nioc->name);\r\ngoto out;\r\n}\r\nfor (i = 0; i < ioc->chain_depth; i++) {\r\nioc->chain_lookup[i].chain_buffer = pci_pool_alloc(\r\nioc->chain_dma_pool , GFP_KERNEL,\r\n&ioc->chain_lookup[i].chain_buffer_dma);\r\nif (!ioc->chain_lookup[i].chain_buffer) {\r\nioc->chain_depth = i;\r\ngoto chain_done;\r\n}\r\ntotal_sz += ioc->request_sz;\r\n}\r\nchain_done:\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"chain pool depth(%d), frame_size(%d), pool_size(%d kB)\n",\r\nioc->name, ioc->chain_depth, ioc->request_sz,\r\n((ioc->chain_depth * ioc->request_sz))/1024));\r\nioc->hpr_lookup = kcalloc(ioc->hi_priority_depth,\r\nsizeof(struct request_tracker), GFP_KERNEL);\r\nif (!ioc->hpr_lookup) {\r\npr_err(MPT3SAS_FMT "hpr_lookup: kcalloc failed\n",\r\nioc->name);\r\ngoto out;\r\n}\r\nioc->hi_priority_smid = ioc->scsiio_depth + 1;\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"hi_priority(0x%p): depth(%d), start smid(%d)\n",\r\nioc->name, ioc->hi_priority,\r\nioc->hi_priority_depth, ioc->hi_priority_smid));\r\nioc->internal_lookup = kcalloc(ioc->internal_depth,\r\nsizeof(struct request_tracker), GFP_KERNEL);\r\nif (!ioc->internal_lookup) {\r\npr_err(MPT3SAS_FMT "internal_lookup: kcalloc failed\n",\r\nioc->name);\r\ngoto out;\r\n}\r\nioc->internal_smid = ioc->hi_priority_smid + ioc->hi_priority_depth;\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"internal(0x%p): depth(%d), start smid(%d)\n",\r\nioc->name, ioc->internal,\r\nioc->internal_depth, ioc->internal_smid));\r\nsz = ioc->scsiio_depth * SCSI_SENSE_BUFFERSIZE;\r\nioc->sense_dma_pool = pci_pool_create("sense pool", ioc->pdev, sz, 4,\r\n0);\r\nif (!ioc->sense_dma_pool) {\r\npr_err(MPT3SAS_FMT "sense pool: pci_pool_create failed\n",\r\nioc->name);\r\ngoto out;\r\n}\r\nioc->sense = pci_pool_alloc(ioc->sense_dma_pool , GFP_KERNEL,\r\n&ioc->sense_dma);\r\nif (!ioc->sense) {\r\npr_err(MPT3SAS_FMT "sense pool: pci_pool_alloc failed\n",\r\nioc->name);\r\ngoto out;\r\n}\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"sense pool(0x%p): depth(%d), element_size(%d), pool_size"\r\n"(%d kB)\n", ioc->name, ioc->sense, ioc->scsiio_depth,\r\nSCSI_SENSE_BUFFERSIZE, sz/1024));\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "sense_dma(0x%llx)\n",\r\nioc->name, (unsigned long long)ioc->sense_dma));\r\ntotal_sz += sz;\r\nsz = ioc->reply_free_queue_depth * ioc->reply_sz;\r\nioc->reply_dma_pool = pci_pool_create("reply pool", ioc->pdev, sz, 4,\r\n0);\r\nif (!ioc->reply_dma_pool) {\r\npr_err(MPT3SAS_FMT "reply pool: pci_pool_create failed\n",\r\nioc->name);\r\ngoto out;\r\n}\r\nioc->reply = pci_pool_alloc(ioc->reply_dma_pool , GFP_KERNEL,\r\n&ioc->reply_dma);\r\nif (!ioc->reply) {\r\npr_err(MPT3SAS_FMT "reply pool: pci_pool_alloc failed\n",\r\nioc->name);\r\ngoto out;\r\n}\r\nioc->reply_dma_min_address = (u32)(ioc->reply_dma);\r\nioc->reply_dma_max_address = (u32)(ioc->reply_dma) + sz;\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"reply pool(0x%p): depth(%d), frame_size(%d), pool_size(%d kB)\n",\r\nioc->name, ioc->reply,\r\nioc->reply_free_queue_depth, ioc->reply_sz, sz/1024));\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "reply_dma(0x%llx)\n",\r\nioc->name, (unsigned long long)ioc->reply_dma));\r\ntotal_sz += sz;\r\nsz = ioc->reply_free_queue_depth * 4;\r\nioc->reply_free_dma_pool = pci_pool_create("reply_free pool",\r\nioc->pdev, sz, 16, 0);\r\nif (!ioc->reply_free_dma_pool) {\r\npr_err(MPT3SAS_FMT "reply_free pool: pci_pool_create failed\n",\r\nioc->name);\r\ngoto out;\r\n}\r\nioc->reply_free = pci_pool_alloc(ioc->reply_free_dma_pool , GFP_KERNEL,\r\n&ioc->reply_free_dma);\r\nif (!ioc->reply_free) {\r\npr_err(MPT3SAS_FMT "reply_free pool: pci_pool_alloc failed\n",\r\nioc->name);\r\ngoto out;\r\n}\r\nmemset(ioc->reply_free, 0, sz);\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "reply_free pool(0x%p): " \\r\n"depth(%d), element_size(%d), pool_size(%d kB)\n", ioc->name,\r\nioc->reply_free, ioc->reply_free_queue_depth, 4, sz/1024));\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"reply_free_dma (0x%llx)\n",\r\nioc->name, (unsigned long long)ioc->reply_free_dma));\r\ntotal_sz += sz;\r\nreply_post_free_sz = ioc->reply_post_queue_depth *\r\nsizeof(Mpi2DefaultReplyDescriptor_t);\r\nif (_base_is_controller_msix_enabled(ioc))\r\nsz = reply_post_free_sz * ioc->reply_queue_count;\r\nelse\r\nsz = reply_post_free_sz;\r\nioc->reply_post_free_dma_pool = pci_pool_create("reply_post_free pool",\r\nioc->pdev, sz, 16, 0);\r\nif (!ioc->reply_post_free_dma_pool) {\r\npr_err(MPT3SAS_FMT\r\n"reply_post_free pool: pci_pool_create failed\n",\r\nioc->name);\r\ngoto out;\r\n}\r\nioc->reply_post_free = pci_pool_alloc(ioc->reply_post_free_dma_pool ,\r\nGFP_KERNEL, &ioc->reply_post_free_dma);\r\nif (!ioc->reply_post_free) {\r\npr_err(MPT3SAS_FMT\r\n"reply_post_free pool: pci_pool_alloc failed\n",\r\nioc->name);\r\ngoto out;\r\n}\r\nmemset(ioc->reply_post_free, 0, sz);\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "reply post free pool" \\r\n"(0x%p): depth(%d), element_size(%d), pool_size(%d kB)\n",\r\nioc->name, ioc->reply_post_free, ioc->reply_post_queue_depth, 8,\r\nsz/1024));\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"reply_post_free_dma = (0x%llx)\n",\r\nioc->name, (unsigned long long)\r\nioc->reply_post_free_dma));\r\ntotal_sz += sz;\r\nioc->config_page_sz = 512;\r\nioc->config_page = pci_alloc_consistent(ioc->pdev,\r\nioc->config_page_sz, &ioc->config_page_dma);\r\nif (!ioc->config_page) {\r\npr_err(MPT3SAS_FMT\r\n"config page: pci_pool_alloc failed\n",\r\nioc->name);\r\ngoto out;\r\n}\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"config page(0x%p): size(%d)\n",\r\nioc->name, ioc->config_page, ioc->config_page_sz));\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "config_page_dma(0x%llx)\n",\r\nioc->name, (unsigned long long)ioc->config_page_dma));\r\ntotal_sz += ioc->config_page_sz;\r\npr_info(MPT3SAS_FMT "Allocated physical memory: size(%d kB)\n",\r\nioc->name, total_sz/1024);\r\npr_info(MPT3SAS_FMT\r\n"Current Controller Queue Depth(%d),Max Controller Queue Depth(%d)\n",\r\nioc->name, ioc->shost->can_queue, facts->RequestCredit);\r\npr_info(MPT3SAS_FMT "Scatter Gather Elements per IO(%d)\n",\r\nioc->name, ioc->shost->sg_tablesize);\r\nreturn 0;\r\nout:\r\nreturn -ENOMEM;\r\n}\r\nu32\r\nmpt3sas_base_get_iocstate(struct MPT3SAS_ADAPTER *ioc, int cooked)\r\n{\r\nu32 s, sc;\r\ns = readl(&ioc->chip->Doorbell);\r\nsc = s & MPI2_IOC_STATE_MASK;\r\nreturn cooked ? sc : s;\r\n}\r\nstatic int\r\n_base_wait_on_iocstate(struct MPT3SAS_ADAPTER *ioc, u32 ioc_state, int timeout,\r\nint sleep_flag)\r\n{\r\nu32 count, cntdn;\r\nu32 current_state;\r\ncount = 0;\r\ncntdn = (sleep_flag == CAN_SLEEP) ? 1000*timeout : 2000*timeout;\r\ndo {\r\ncurrent_state = mpt3sas_base_get_iocstate(ioc, 1);\r\nif (current_state == ioc_state)\r\nreturn 0;\r\nif (count && current_state == MPI2_IOC_STATE_FAULT)\r\nbreak;\r\nif (sleep_flag == CAN_SLEEP)\r\nusleep_range(1000, 1500);\r\nelse\r\nudelay(500);\r\ncount++;\r\n} while (--cntdn);\r\nreturn current_state;\r\n}\r\nstatic int\r\n_base_wait_for_doorbell_int(struct MPT3SAS_ADAPTER *ioc, int timeout,\r\nint sleep_flag)\r\n{\r\nu32 cntdn, count;\r\nu32 int_status;\r\ncount = 0;\r\ncntdn = (sleep_flag == CAN_SLEEP) ? 1000*timeout : 2000*timeout;\r\ndo {\r\nint_status = readl(&ioc->chip->HostInterruptStatus);\r\nif (int_status & MPI2_HIS_IOC2SYS_DB_STATUS) {\r\ndhsprintk(ioc, pr_info(MPT3SAS_FMT\r\n"%s: successful count(%d), timeout(%d)\n",\r\nioc->name, __func__, count, timeout));\r\nreturn 0;\r\n}\r\nif (sleep_flag == CAN_SLEEP)\r\nusleep_range(1000, 1500);\r\nelse\r\nudelay(500);\r\ncount++;\r\n} while (--cntdn);\r\npr_err(MPT3SAS_FMT\r\n"%s: failed due to timeout count(%d), int_status(%x)!\n",\r\nioc->name, __func__, count, int_status);\r\nreturn -EFAULT;\r\n}\r\nstatic int\r\n_base_wait_for_doorbell_ack(struct MPT3SAS_ADAPTER *ioc, int timeout,\r\nint sleep_flag)\r\n{\r\nu32 cntdn, count;\r\nu32 int_status;\r\nu32 doorbell;\r\ncount = 0;\r\ncntdn = (sleep_flag == CAN_SLEEP) ? 1000*timeout : 2000*timeout;\r\ndo {\r\nint_status = readl(&ioc->chip->HostInterruptStatus);\r\nif (!(int_status & MPI2_HIS_SYS2IOC_DB_STATUS)) {\r\ndhsprintk(ioc, pr_info(MPT3SAS_FMT\r\n"%s: successful count(%d), timeout(%d)\n",\r\nioc->name, __func__, count, timeout));\r\nreturn 0;\r\n} else if (int_status & MPI2_HIS_IOC2SYS_DB_STATUS) {\r\ndoorbell = readl(&ioc->chip->Doorbell);\r\nif ((doorbell & MPI2_IOC_STATE_MASK) ==\r\nMPI2_IOC_STATE_FAULT) {\r\nmpt3sas_base_fault_info(ioc , doorbell);\r\nreturn -EFAULT;\r\n}\r\n} else if (int_status == 0xFFFFFFFF)\r\ngoto out;\r\nif (sleep_flag == CAN_SLEEP)\r\nusleep_range(1000, 1500);\r\nelse\r\nudelay(500);\r\ncount++;\r\n} while (--cntdn);\r\nout:\r\npr_err(MPT3SAS_FMT\r\n"%s: failed due to timeout count(%d), int_status(%x)!\n",\r\nioc->name, __func__, count, int_status);\r\nreturn -EFAULT;\r\n}\r\nstatic int\r\n_base_wait_for_doorbell_not_used(struct MPT3SAS_ADAPTER *ioc, int timeout,\r\nint sleep_flag)\r\n{\r\nu32 cntdn, count;\r\nu32 doorbell_reg;\r\ncount = 0;\r\ncntdn = (sleep_flag == CAN_SLEEP) ? 1000*timeout : 2000*timeout;\r\ndo {\r\ndoorbell_reg = readl(&ioc->chip->Doorbell);\r\nif (!(doorbell_reg & MPI2_DOORBELL_USED)) {\r\ndhsprintk(ioc, pr_info(MPT3SAS_FMT\r\n"%s: successful count(%d), timeout(%d)\n",\r\nioc->name, __func__, count, timeout));\r\nreturn 0;\r\n}\r\nif (sleep_flag == CAN_SLEEP)\r\nusleep_range(1000, 1500);\r\nelse\r\nudelay(500);\r\ncount++;\r\n} while (--cntdn);\r\npr_err(MPT3SAS_FMT\r\n"%s: failed due to timeout count(%d), doorbell_reg(%x)!\n",\r\nioc->name, __func__, count, doorbell_reg);\r\nreturn -EFAULT;\r\n}\r\nstatic int\r\n_base_send_ioc_reset(struct MPT3SAS_ADAPTER *ioc, u8 reset_type, int timeout,\r\nint sleep_flag)\r\n{\r\nu32 ioc_state;\r\nint r = 0;\r\nif (reset_type != MPI2_FUNCTION_IOC_MESSAGE_UNIT_RESET) {\r\npr_err(MPT3SAS_FMT "%s: unknown reset_type\n",\r\nioc->name, __func__);\r\nreturn -EFAULT;\r\n}\r\nif (!(ioc->facts.IOCCapabilities &\r\nMPI2_IOCFACTS_CAPABILITY_EVENT_REPLAY))\r\nreturn -EFAULT;\r\npr_info(MPT3SAS_FMT "sending message unit reset !!\n", ioc->name);\r\nwritel(reset_type << MPI2_DOORBELL_FUNCTION_SHIFT,\r\n&ioc->chip->Doorbell);\r\nif ((_base_wait_for_doorbell_ack(ioc, 15, sleep_flag))) {\r\nr = -EFAULT;\r\ngoto out;\r\n}\r\nioc_state = _base_wait_on_iocstate(ioc, MPI2_IOC_STATE_READY,\r\ntimeout, sleep_flag);\r\nif (ioc_state) {\r\npr_err(MPT3SAS_FMT\r\n"%s: failed going to ready state (ioc_state=0x%x)\n",\r\nioc->name, __func__, ioc_state);\r\nr = -EFAULT;\r\ngoto out;\r\n}\r\nout:\r\npr_info(MPT3SAS_FMT "message unit reset: %s\n",\r\nioc->name, ((r == 0) ? "SUCCESS" : "FAILED"));\r\nreturn r;\r\n}\r\nstatic int\r\n_base_handshake_req_reply_wait(struct MPT3SAS_ADAPTER *ioc, int request_bytes,\r\nu32 *request, int reply_bytes, u16 *reply, int timeout, int sleep_flag)\r\n{\r\nMPI2DefaultReply_t *default_reply = (MPI2DefaultReply_t *)reply;\r\nint i;\r\nu8 failed;\r\nu16 dummy;\r\n__le32 *mfp;\r\nif ((readl(&ioc->chip->Doorbell) & MPI2_DOORBELL_USED)) {\r\npr_err(MPT3SAS_FMT\r\n"doorbell is in use (line=%d)\n",\r\nioc->name, __LINE__);\r\nreturn -EFAULT;\r\n}\r\nif (readl(&ioc->chip->HostInterruptStatus) &\r\nMPI2_HIS_IOC2SYS_DB_STATUS)\r\nwritel(0, &ioc->chip->HostInterruptStatus);\r\nwritel(((MPI2_FUNCTION_HANDSHAKE<<MPI2_DOORBELL_FUNCTION_SHIFT) |\r\n((request_bytes/4)<<MPI2_DOORBELL_ADD_DWORDS_SHIFT)),\r\n&ioc->chip->Doorbell);\r\nif ((_base_wait_for_doorbell_int(ioc, 5, NO_SLEEP))) {\r\npr_err(MPT3SAS_FMT\r\n"doorbell handshake int failed (line=%d)\n",\r\nioc->name, __LINE__);\r\nreturn -EFAULT;\r\n}\r\nwritel(0, &ioc->chip->HostInterruptStatus);\r\nif ((_base_wait_for_doorbell_ack(ioc, 5, sleep_flag))) {\r\npr_err(MPT3SAS_FMT\r\n"doorbell handshake ack failed (line=%d)\n",\r\nioc->name, __LINE__);\r\nreturn -EFAULT;\r\n}\r\nfor (i = 0, failed = 0; i < request_bytes/4 && !failed; i++) {\r\nwritel(cpu_to_le32(request[i]), &ioc->chip->Doorbell);\r\nif ((_base_wait_for_doorbell_ack(ioc, 5, sleep_flag)))\r\nfailed = 1;\r\n}\r\nif (failed) {\r\npr_err(MPT3SAS_FMT\r\n"doorbell handshake sending request failed (line=%d)\n",\r\nioc->name, __LINE__);\r\nreturn -EFAULT;\r\n}\r\nif ((_base_wait_for_doorbell_int(ioc, timeout, sleep_flag))) {\r\npr_err(MPT3SAS_FMT\r\n"doorbell handshake int failed (line=%d)\n",\r\nioc->name, __LINE__);\r\nreturn -EFAULT;\r\n}\r\nreply[0] = le16_to_cpu(readl(&ioc->chip->Doorbell)\r\n& MPI2_DOORBELL_DATA_MASK);\r\nwritel(0, &ioc->chip->HostInterruptStatus);\r\nif ((_base_wait_for_doorbell_int(ioc, 5, sleep_flag))) {\r\npr_err(MPT3SAS_FMT\r\n"doorbell handshake int failed (line=%d)\n",\r\nioc->name, __LINE__);\r\nreturn -EFAULT;\r\n}\r\nreply[1] = le16_to_cpu(readl(&ioc->chip->Doorbell)\r\n& MPI2_DOORBELL_DATA_MASK);\r\nwritel(0, &ioc->chip->HostInterruptStatus);\r\nfor (i = 2; i < default_reply->MsgLength * 2; i++) {\r\nif ((_base_wait_for_doorbell_int(ioc, 5, sleep_flag))) {\r\npr_err(MPT3SAS_FMT\r\n"doorbell handshake int failed (line=%d)\n",\r\nioc->name, __LINE__);\r\nreturn -EFAULT;\r\n}\r\nif (i >= reply_bytes/2)\r\ndummy = readl(&ioc->chip->Doorbell);\r\nelse\r\nreply[i] = le16_to_cpu(readl(&ioc->chip->Doorbell)\r\n& MPI2_DOORBELL_DATA_MASK);\r\nwritel(0, &ioc->chip->HostInterruptStatus);\r\n}\r\n_base_wait_for_doorbell_int(ioc, 5, sleep_flag);\r\nif (_base_wait_for_doorbell_not_used(ioc, 5, sleep_flag) != 0) {\r\ndhsprintk(ioc, pr_info(MPT3SAS_FMT\r\n"doorbell is in use (line=%d)\n", ioc->name, __LINE__));\r\n}\r\nwritel(0, &ioc->chip->HostInterruptStatus);\r\nif (ioc->logging_level & MPT_DEBUG_INIT) {\r\nmfp = (__le32 *)reply;\r\npr_info("\toffset:data\n");\r\nfor (i = 0; i < reply_bytes/4; i++)\r\npr_info("\t[0x%02x]:%08x\n", i*4,\r\nle32_to_cpu(mfp[i]));\r\n}\r\nreturn 0;\r\n}\r\nint\r\nmpt3sas_base_sas_iounit_control(struct MPT3SAS_ADAPTER *ioc,\r\nMpi2SasIoUnitControlReply_t *mpi_reply,\r\nMpi2SasIoUnitControlRequest_t *mpi_request)\r\n{\r\nu16 smid;\r\nu32 ioc_state;\r\nunsigned long timeleft;\r\nu8 issue_reset;\r\nint rc;\r\nvoid *request;\r\nu16 wait_state_count;\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "%s\n", ioc->name,\r\n__func__));\r\nmutex_lock(&ioc->base_cmds.mutex);\r\nif (ioc->base_cmds.status != MPT3_CMD_NOT_USED) {\r\npr_err(MPT3SAS_FMT "%s: base_cmd in use\n",\r\nioc->name, __func__);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nwait_state_count = 0;\r\nioc_state = mpt3sas_base_get_iocstate(ioc, 1);\r\nwhile (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {\r\nif (wait_state_count++ == 10) {\r\npr_err(MPT3SAS_FMT\r\n"%s: failed due to ioc not operational\n",\r\nioc->name, __func__);\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nssleep(1);\r\nioc_state = mpt3sas_base_get_iocstate(ioc, 1);\r\npr_info(MPT3SAS_FMT\r\n"%s: waiting for operational state(count=%d)\n",\r\nioc->name, __func__, wait_state_count);\r\n}\r\nsmid = mpt3sas_base_get_smid(ioc, ioc->base_cb_idx);\r\nif (!smid) {\r\npr_err(MPT3SAS_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nrc = 0;\r\nioc->base_cmds.status = MPT3_CMD_PENDING;\r\nrequest = mpt3sas_base_get_msg_frame(ioc, smid);\r\nioc->base_cmds.smid = smid;\r\nmemcpy(request, mpi_request, sizeof(Mpi2SasIoUnitControlRequest_t));\r\nif (mpi_request->Operation == MPI2_SAS_OP_PHY_HARD_RESET ||\r\nmpi_request->Operation == MPI2_SAS_OP_PHY_LINK_RESET)\r\nioc->ioc_link_reset_in_progress = 1;\r\ninit_completion(&ioc->base_cmds.done);\r\nmpt3sas_base_put_smid_default(ioc, smid);\r\ntimeleft = wait_for_completion_timeout(&ioc->base_cmds.done,\r\nmsecs_to_jiffies(10000));\r\nif ((mpi_request->Operation == MPI2_SAS_OP_PHY_HARD_RESET ||\r\nmpi_request->Operation == MPI2_SAS_OP_PHY_LINK_RESET) &&\r\nioc->ioc_link_reset_in_progress)\r\nioc->ioc_link_reset_in_progress = 0;\r\nif (!(ioc->base_cmds.status & MPT3_CMD_COMPLETE)) {\r\npr_err(MPT3SAS_FMT "%s: timeout\n",\r\nioc->name, __func__);\r\n_debug_dump_mf(mpi_request,\r\nsizeof(Mpi2SasIoUnitControlRequest_t)/4);\r\nif (!(ioc->base_cmds.status & MPT3_CMD_RESET))\r\nissue_reset = 1;\r\ngoto issue_host_reset;\r\n}\r\nif (ioc->base_cmds.status & MPT3_CMD_REPLY_VALID)\r\nmemcpy(mpi_reply, ioc->base_cmds.reply,\r\nsizeof(Mpi2SasIoUnitControlReply_t));\r\nelse\r\nmemset(mpi_reply, 0, sizeof(Mpi2SasIoUnitControlReply_t));\r\nioc->base_cmds.status = MPT3_CMD_NOT_USED;\r\ngoto out;\r\nissue_host_reset:\r\nif (issue_reset)\r\nmpt3sas_base_hard_reset_handler(ioc, CAN_SLEEP,\r\nFORCE_BIG_HAMMER);\r\nioc->base_cmds.status = MPT3_CMD_NOT_USED;\r\nrc = -EFAULT;\r\nout:\r\nmutex_unlock(&ioc->base_cmds.mutex);\r\nreturn rc;\r\n}\r\nint\r\nmpt3sas_base_scsi_enclosure_processor(struct MPT3SAS_ADAPTER *ioc,\r\nMpi2SepReply_t *mpi_reply, Mpi2SepRequest_t *mpi_request)\r\n{\r\nu16 smid;\r\nu32 ioc_state;\r\nunsigned long timeleft;\r\nu8 issue_reset;\r\nint rc;\r\nvoid *request;\r\nu16 wait_state_count;\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "%s\n", ioc->name,\r\n__func__));\r\nmutex_lock(&ioc->base_cmds.mutex);\r\nif (ioc->base_cmds.status != MPT3_CMD_NOT_USED) {\r\npr_err(MPT3SAS_FMT "%s: base_cmd in use\n",\r\nioc->name, __func__);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nwait_state_count = 0;\r\nioc_state = mpt3sas_base_get_iocstate(ioc, 1);\r\nwhile (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {\r\nif (wait_state_count++ == 10) {\r\npr_err(MPT3SAS_FMT\r\n"%s: failed due to ioc not operational\n",\r\nioc->name, __func__);\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nssleep(1);\r\nioc_state = mpt3sas_base_get_iocstate(ioc, 1);\r\npr_info(MPT3SAS_FMT\r\n"%s: waiting for operational state(count=%d)\n",\r\nioc->name,\r\n__func__, wait_state_count);\r\n}\r\nsmid = mpt3sas_base_get_smid(ioc, ioc->base_cb_idx);\r\nif (!smid) {\r\npr_err(MPT3SAS_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nrc = 0;\r\nioc->base_cmds.status = MPT3_CMD_PENDING;\r\nrequest = mpt3sas_base_get_msg_frame(ioc, smid);\r\nioc->base_cmds.smid = smid;\r\nmemcpy(request, mpi_request, sizeof(Mpi2SepReply_t));\r\ninit_completion(&ioc->base_cmds.done);\r\nmpt3sas_base_put_smid_default(ioc, smid);\r\ntimeleft = wait_for_completion_timeout(&ioc->base_cmds.done,\r\nmsecs_to_jiffies(10000));\r\nif (!(ioc->base_cmds.status & MPT3_CMD_COMPLETE)) {\r\npr_err(MPT3SAS_FMT "%s: timeout\n",\r\nioc->name, __func__);\r\n_debug_dump_mf(mpi_request,\r\nsizeof(Mpi2SepRequest_t)/4);\r\nif (!(ioc->base_cmds.status & MPT3_CMD_RESET))\r\nissue_reset = 1;\r\ngoto issue_host_reset;\r\n}\r\nif (ioc->base_cmds.status & MPT3_CMD_REPLY_VALID)\r\nmemcpy(mpi_reply, ioc->base_cmds.reply,\r\nsizeof(Mpi2SepReply_t));\r\nelse\r\nmemset(mpi_reply, 0, sizeof(Mpi2SepReply_t));\r\nioc->base_cmds.status = MPT3_CMD_NOT_USED;\r\ngoto out;\r\nissue_host_reset:\r\nif (issue_reset)\r\nmpt3sas_base_hard_reset_handler(ioc, CAN_SLEEP,\r\nFORCE_BIG_HAMMER);\r\nioc->base_cmds.status = MPT3_CMD_NOT_USED;\r\nrc = -EFAULT;\r\nout:\r\nmutex_unlock(&ioc->base_cmds.mutex);\r\nreturn rc;\r\n}\r\nstatic int\r\n_base_get_port_facts(struct MPT3SAS_ADAPTER *ioc, int port, int sleep_flag)\r\n{\r\nMpi2PortFactsRequest_t mpi_request;\r\nMpi2PortFactsReply_t mpi_reply;\r\nstruct mpt3sas_port_facts *pfacts;\r\nint mpi_reply_sz, mpi_request_sz, r;\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "%s\n", ioc->name,\r\n__func__));\r\nmpi_reply_sz = sizeof(Mpi2PortFactsReply_t);\r\nmpi_request_sz = sizeof(Mpi2PortFactsRequest_t);\r\nmemset(&mpi_request, 0, mpi_request_sz);\r\nmpi_request.Function = MPI2_FUNCTION_PORT_FACTS;\r\nmpi_request.PortNumber = port;\r\nr = _base_handshake_req_reply_wait(ioc, mpi_request_sz,\r\n(u32 *)&mpi_request, mpi_reply_sz, (u16 *)&mpi_reply, 5, CAN_SLEEP);\r\nif (r != 0) {\r\npr_err(MPT3SAS_FMT "%s: handshake failed (r=%d)\n",\r\nioc->name, __func__, r);\r\nreturn r;\r\n}\r\npfacts = &ioc->pfacts[port];\r\nmemset(pfacts, 0, sizeof(struct mpt3sas_port_facts));\r\npfacts->PortNumber = mpi_reply.PortNumber;\r\npfacts->VP_ID = mpi_reply.VP_ID;\r\npfacts->VF_ID = mpi_reply.VF_ID;\r\npfacts->MaxPostedCmdBuffers =\r\nle16_to_cpu(mpi_reply.MaxPostedCmdBuffers);\r\nreturn 0;\r\n}\r\nstatic int\r\n_base_get_ioc_facts(struct MPT3SAS_ADAPTER *ioc, int sleep_flag)\r\n{\r\nMpi2IOCFactsRequest_t mpi_request;\r\nMpi2IOCFactsReply_t mpi_reply;\r\nstruct mpt3sas_facts *facts;\r\nint mpi_reply_sz, mpi_request_sz, r;\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "%s\n", ioc->name,\r\n__func__));\r\nmpi_reply_sz = sizeof(Mpi2IOCFactsReply_t);\r\nmpi_request_sz = sizeof(Mpi2IOCFactsRequest_t);\r\nmemset(&mpi_request, 0, mpi_request_sz);\r\nmpi_request.Function = MPI2_FUNCTION_IOC_FACTS;\r\nr = _base_handshake_req_reply_wait(ioc, mpi_request_sz,\r\n(u32 *)&mpi_request, mpi_reply_sz, (u16 *)&mpi_reply, 5, CAN_SLEEP);\r\nif (r != 0) {\r\npr_err(MPT3SAS_FMT "%s: handshake failed (r=%d)\n",\r\nioc->name, __func__, r);\r\nreturn r;\r\n}\r\nfacts = &ioc->facts;\r\nmemset(facts, 0, sizeof(struct mpt3sas_facts));\r\nfacts->MsgVersion = le16_to_cpu(mpi_reply.MsgVersion);\r\nfacts->HeaderVersion = le16_to_cpu(mpi_reply.HeaderVersion);\r\nfacts->VP_ID = mpi_reply.VP_ID;\r\nfacts->VF_ID = mpi_reply.VF_ID;\r\nfacts->IOCExceptions = le16_to_cpu(mpi_reply.IOCExceptions);\r\nfacts->MaxChainDepth = mpi_reply.MaxChainDepth;\r\nfacts->WhoInit = mpi_reply.WhoInit;\r\nfacts->NumberOfPorts = mpi_reply.NumberOfPorts;\r\nfacts->MaxMSIxVectors = mpi_reply.MaxMSIxVectors;\r\nfacts->RequestCredit = le16_to_cpu(mpi_reply.RequestCredit);\r\nfacts->MaxReplyDescriptorPostQueueDepth =\r\nle16_to_cpu(mpi_reply.MaxReplyDescriptorPostQueueDepth);\r\nfacts->ProductID = le16_to_cpu(mpi_reply.ProductID);\r\nfacts->IOCCapabilities = le32_to_cpu(mpi_reply.IOCCapabilities);\r\nif ((facts->IOCCapabilities & MPI2_IOCFACTS_CAPABILITY_INTEGRATED_RAID))\r\nioc->ir_firmware = 1;\r\nfacts->FWVersion.Word = le32_to_cpu(mpi_reply.FWVersion.Word);\r\nfacts->IOCRequestFrameSize =\r\nle16_to_cpu(mpi_reply.IOCRequestFrameSize);\r\nfacts->MaxInitiators = le16_to_cpu(mpi_reply.MaxInitiators);\r\nfacts->MaxTargets = le16_to_cpu(mpi_reply.MaxTargets);\r\nioc->shost->max_id = -1;\r\nfacts->MaxSasExpanders = le16_to_cpu(mpi_reply.MaxSasExpanders);\r\nfacts->MaxEnclosures = le16_to_cpu(mpi_reply.MaxEnclosures);\r\nfacts->ProtocolFlags = le16_to_cpu(mpi_reply.ProtocolFlags);\r\nfacts->HighPriorityCredit =\r\nle16_to_cpu(mpi_reply.HighPriorityCredit);\r\nfacts->ReplyFrameSize = mpi_reply.ReplyFrameSize;\r\nfacts->MaxDevHandle = le16_to_cpu(mpi_reply.MaxDevHandle);\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"hba queue depth(%d), max chains per io(%d)\n",\r\nioc->name, facts->RequestCredit,\r\nfacts->MaxChainDepth));\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT\r\n"request frame size(%d), reply frame size(%d)\n", ioc->name,\r\nfacts->IOCRequestFrameSize * 4, facts->ReplyFrameSize * 4));\r\nreturn 0;\r\n}\r\nstatic int\r\n_base_send_ioc_init(struct MPT3SAS_ADAPTER *ioc, int sleep_flag)\r\n{\r\nMpi2IOCInitRequest_t mpi_request;\r\nMpi2IOCInitReply_t mpi_reply;\r\nint r;\r\nstruct timeval current_time;\r\nu16 ioc_status;\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "%s\n", ioc->name,\r\n__func__));\r\nmemset(&mpi_request, 0, sizeof(Mpi2IOCInitRequest_t));\r\nmpi_request.Function = MPI2_FUNCTION_IOC_INIT;\r\nmpi_request.WhoInit = MPI2_WHOINIT_HOST_DRIVER;\r\nmpi_request.VF_ID = 0;\r\nmpi_request.VP_ID = 0;\r\nmpi_request.MsgVersion = cpu_to_le16(MPI2_VERSION);\r\nmpi_request.HeaderVersion = cpu_to_le16(MPI2_HEADER_VERSION);\r\nif (_base_is_controller_msix_enabled(ioc))\r\nmpi_request.HostMSIxVectors = ioc->reply_queue_count;\r\nmpi_request.SystemRequestFrameSize = cpu_to_le16(ioc->request_sz/4);\r\nmpi_request.ReplyDescriptorPostQueueDepth =\r\ncpu_to_le16(ioc->reply_post_queue_depth);\r\nmpi_request.ReplyFreeQueueDepth =\r\ncpu_to_le16(ioc->reply_free_queue_depth);\r\nmpi_request.SenseBufferAddressHigh =\r\ncpu_to_le32((u64)ioc->sense_dma >> 32);\r\nmpi_request.SystemReplyAddressHigh =\r\ncpu_to_le32((u64)ioc->reply_dma >> 32);\r\nmpi_request.SystemRequestFrameBaseAddress =\r\ncpu_to_le64((u64)ioc->request_dma);\r\nmpi_request.ReplyFreeQueueAddress =\r\ncpu_to_le64((u64)ioc->reply_free_dma);\r\nmpi_request.ReplyDescriptorPostQueueAddress =\r\ncpu_to_le64((u64)ioc->reply_post_free_dma);\r\ndo_gettimeofday(&current_time);\r\nmpi_request.TimeStamp = cpu_to_le64((u64)current_time.tv_sec * 1000 +\r\n(current_time.tv_usec / 1000));\r\nif (ioc->logging_level & MPT_DEBUG_INIT) {\r\n__le32 *mfp;\r\nint i;\r\nmfp = (__le32 *)&mpi_request;\r\npr_info("\toffset:data\n");\r\nfor (i = 0; i < sizeof(Mpi2IOCInitRequest_t)/4; i++)\r\npr_info("\t[0x%02x]:%08x\n", i*4,\r\nle32_to_cpu(mfp[i]));\r\n}\r\nr = _base_handshake_req_reply_wait(ioc,\r\nsizeof(Mpi2IOCInitRequest_t), (u32 *)&mpi_request,\r\nsizeof(Mpi2IOCInitReply_t), (u16 *)&mpi_reply, 10,\r\nsleep_flag);\r\nif (r != 0) {\r\npr_err(MPT3SAS_FMT "%s: handshake failed (r=%d)\n",\r\nioc->name, __func__, r);\r\nreturn r;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) & MPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS ||\r\nmpi_reply.IOCLogInfo) {\r\npr_err(MPT3SAS_FMT "%s: failed\n", ioc->name, __func__);\r\nr = -EIO;\r\n}\r\nreturn 0;\r\n}\r\nu8\r\nmpt3sas_port_enable_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,\r\nu32 reply)\r\n{\r\nMPI2DefaultReply_t *mpi_reply;\r\nu16 ioc_status;\r\nif (ioc->port_enable_cmds.status == MPT3_CMD_NOT_USED)\r\nreturn 1;\r\nmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\r\nif (!mpi_reply)\r\nreturn 1;\r\nif (mpi_reply->Function != MPI2_FUNCTION_PORT_ENABLE)\r\nreturn 1;\r\nioc->port_enable_cmds.status &= ~MPT3_CMD_PENDING;\r\nioc->port_enable_cmds.status |= MPT3_CMD_COMPLETE;\r\nioc->port_enable_cmds.status |= MPT3_CMD_REPLY_VALID;\r\nmemcpy(ioc->port_enable_cmds.reply, mpi_reply, mpi_reply->MsgLength*4);\r\nioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS)\r\nioc->port_enable_failed = 1;\r\nif (ioc->is_driver_loading) {\r\nif (ioc_status == MPI2_IOCSTATUS_SUCCESS) {\r\nmpt3sas_port_enable_complete(ioc);\r\nreturn 1;\r\n} else {\r\nioc->start_scan_failed = ioc_status;\r\nioc->start_scan = 0;\r\nreturn 1;\r\n}\r\n}\r\ncomplete(&ioc->port_enable_cmds.done);\r\nreturn 1;\r\n}\r\nstatic int\r\n_base_send_port_enable(struct MPT3SAS_ADAPTER *ioc, int sleep_flag)\r\n{\r\nMpi2PortEnableRequest_t *mpi_request;\r\nMpi2PortEnableReply_t *mpi_reply;\r\nunsigned long timeleft;\r\nint r = 0;\r\nu16 smid;\r\nu16 ioc_status;\r\npr_info(MPT3SAS_FMT "sending port enable !!\n", ioc->name);\r\nif (ioc->port_enable_cmds.status & MPT3_CMD_PENDING) {\r\npr_err(MPT3SAS_FMT "%s: internal command already in use\n",\r\nioc->name, __func__);\r\nreturn -EAGAIN;\r\n}\r\nsmid = mpt3sas_base_get_smid(ioc, ioc->port_enable_cb_idx);\r\nif (!smid) {\r\npr_err(MPT3SAS_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\nreturn -EAGAIN;\r\n}\r\nioc->port_enable_cmds.status = MPT3_CMD_PENDING;\r\nmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\r\nioc->port_enable_cmds.smid = smid;\r\nmemset(mpi_request, 0, sizeof(Mpi2PortEnableRequest_t));\r\nmpi_request->Function = MPI2_FUNCTION_PORT_ENABLE;\r\ninit_completion(&ioc->port_enable_cmds.done);\r\nmpt3sas_base_put_smid_default(ioc, smid);\r\ntimeleft = wait_for_completion_timeout(&ioc->port_enable_cmds.done,\r\n300*HZ);\r\nif (!(ioc->port_enable_cmds.status & MPT3_CMD_COMPLETE)) {\r\npr_err(MPT3SAS_FMT "%s: timeout\n",\r\nioc->name, __func__);\r\n_debug_dump_mf(mpi_request,\r\nsizeof(Mpi2PortEnableRequest_t)/4);\r\nif (ioc->port_enable_cmds.status & MPT3_CMD_RESET)\r\nr = -EFAULT;\r\nelse\r\nr = -ETIME;\r\ngoto out;\r\n}\r\nmpi_reply = ioc->port_enable_cmds.reply;\r\nioc_status = le16_to_cpu(mpi_reply->IOCStatus) & MPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\npr_err(MPT3SAS_FMT "%s: failed with (ioc_status=0x%08x)\n",\r\nioc->name, __func__, ioc_status);\r\nr = -EFAULT;\r\ngoto out;\r\n}\r\nout:\r\nioc->port_enable_cmds.status = MPT3_CMD_NOT_USED;\r\npr_info(MPT3SAS_FMT "port enable: %s\n", ioc->name, ((r == 0) ?\r\n"SUCCESS" : "FAILED"));\r\nreturn r;\r\n}\r\nint\r\nmpt3sas_port_enable(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nMpi2PortEnableRequest_t *mpi_request;\r\nu16 smid;\r\npr_info(MPT3SAS_FMT "sending port enable !!\n", ioc->name);\r\nif (ioc->port_enable_cmds.status & MPT3_CMD_PENDING) {\r\npr_err(MPT3SAS_FMT "%s: internal command already in use\n",\r\nioc->name, __func__);\r\nreturn -EAGAIN;\r\n}\r\nsmid = mpt3sas_base_get_smid(ioc, ioc->port_enable_cb_idx);\r\nif (!smid) {\r\npr_err(MPT3SAS_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\nreturn -EAGAIN;\r\n}\r\nioc->port_enable_cmds.status = MPT3_CMD_PENDING;\r\nmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\r\nioc->port_enable_cmds.smid = smid;\r\nmemset(mpi_request, 0, sizeof(Mpi2PortEnableRequest_t));\r\nmpi_request->Function = MPI2_FUNCTION_PORT_ENABLE;\r\nmpt3sas_base_put_smid_default(ioc, smid);\r\nreturn 0;\r\n}\r\nstatic int\r\n_base_determine_wait_on_discovery(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nif (ioc->ir_firmware)\r\nreturn 1;\r\nif (!ioc->bios_pg3.BiosVersion)\r\nreturn 0;\r\nif ((ioc->bios_pg2.CurrentBootDeviceForm &\r\nMPI2_BIOSPAGE2_FORM_MASK) ==\r\nMPI2_BIOSPAGE2_FORM_NO_DEVICE_SPECIFIED &&\r\n(ioc->bios_pg2.ReqBootDeviceForm &\r\nMPI2_BIOSPAGE2_FORM_MASK) ==\r\nMPI2_BIOSPAGE2_FORM_NO_DEVICE_SPECIFIED &&\r\n(ioc->bios_pg2.ReqAltBootDeviceForm &\r\nMPI2_BIOSPAGE2_FORM_MASK) ==\r\nMPI2_BIOSPAGE2_FORM_NO_DEVICE_SPECIFIED)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void\r\n_base_unmask_events(struct MPT3SAS_ADAPTER *ioc, u16 event)\r\n{\r\nu32 desired_event;\r\nif (event >= 128)\r\nreturn;\r\ndesired_event = (1 << (event % 32));\r\nif (event < 32)\r\nioc->event_masks[0] &= ~desired_event;\r\nelse if (event < 64)\r\nioc->event_masks[1] &= ~desired_event;\r\nelse if (event < 96)\r\nioc->event_masks[2] &= ~desired_event;\r\nelse if (event < 128)\r\nioc->event_masks[3] &= ~desired_event;\r\n}\r\nstatic int\r\n_base_event_notification(struct MPT3SAS_ADAPTER *ioc, int sleep_flag)\r\n{\r\nMpi2EventNotificationRequest_t *mpi_request;\r\nunsigned long timeleft;\r\nu16 smid;\r\nint r = 0;\r\nint i;\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "%s\n", ioc->name,\r\n__func__));\r\nif (ioc->base_cmds.status & MPT3_CMD_PENDING) {\r\npr_err(MPT3SAS_FMT "%s: internal command already in use\n",\r\nioc->name, __func__);\r\nreturn -EAGAIN;\r\n}\r\nsmid = mpt3sas_base_get_smid(ioc, ioc->base_cb_idx);\r\nif (!smid) {\r\npr_err(MPT3SAS_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\nreturn -EAGAIN;\r\n}\r\nioc->base_cmds.status = MPT3_CMD_PENDING;\r\nmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\r\nioc->base_cmds.smid = smid;\r\nmemset(mpi_request, 0, sizeof(Mpi2EventNotificationRequest_t));\r\nmpi_request->Function = MPI2_FUNCTION_EVENT_NOTIFICATION;\r\nmpi_request->VF_ID = 0;\r\nmpi_request->VP_ID = 0;\r\nfor (i = 0; i < MPI2_EVENT_NOTIFY_EVENTMASK_WORDS; i++)\r\nmpi_request->EventMasks[i] =\r\ncpu_to_le32(ioc->event_masks[i]);\r\ninit_completion(&ioc->base_cmds.done);\r\nmpt3sas_base_put_smid_default(ioc, smid);\r\ntimeleft = wait_for_completion_timeout(&ioc->base_cmds.done, 30*HZ);\r\nif (!(ioc->base_cmds.status & MPT3_CMD_COMPLETE)) {\r\npr_err(MPT3SAS_FMT "%s: timeout\n",\r\nioc->name, __func__);\r\n_debug_dump_mf(mpi_request,\r\nsizeof(Mpi2EventNotificationRequest_t)/4);\r\nif (ioc->base_cmds.status & MPT3_CMD_RESET)\r\nr = -EFAULT;\r\nelse\r\nr = -ETIME;\r\n} else\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "%s: complete\n",\r\nioc->name, __func__));\r\nioc->base_cmds.status = MPT3_CMD_NOT_USED;\r\nreturn r;\r\n}\r\nvoid\r\nmpt3sas_base_validate_event_type(struct MPT3SAS_ADAPTER *ioc, u32 *event_type)\r\n{\r\nint i, j;\r\nu32 event_mask, desired_event;\r\nu8 send_update_to_fw;\r\nfor (i = 0, send_update_to_fw = 0; i <\r\nMPI2_EVENT_NOTIFY_EVENTMASK_WORDS; i++) {\r\nevent_mask = ~event_type[i];\r\ndesired_event = 1;\r\nfor (j = 0; j < 32; j++) {\r\nif (!(event_mask & desired_event) &&\r\n(ioc->event_masks[i] & desired_event)) {\r\nioc->event_masks[i] &= ~desired_event;\r\nsend_update_to_fw = 1;\r\n}\r\ndesired_event = (desired_event << 1);\r\n}\r\n}\r\nif (!send_update_to_fw)\r\nreturn;\r\nmutex_lock(&ioc->base_cmds.mutex);\r\n_base_event_notification(ioc, CAN_SLEEP);\r\nmutex_unlock(&ioc->base_cmds.mutex);\r\n}\r\nstatic int\r\n_base_diag_reset(struct MPT3SAS_ADAPTER *ioc, int sleep_flag)\r\n{\r\nu32 host_diagnostic;\r\nu32 ioc_state;\r\nu32 count;\r\nu32 hcb_size;\r\npr_info(MPT3SAS_FMT "sending diag reset !!\n", ioc->name);\r\ndrsprintk(ioc, pr_info(MPT3SAS_FMT "clear interrupts\n",\r\nioc->name));\r\ncount = 0;\r\ndo {\r\ndrsprintk(ioc, pr_info(MPT3SAS_FMT\r\n"write magic sequence\n", ioc->name));\r\nwritel(MPI2_WRSEQ_FLUSH_KEY_VALUE, &ioc->chip->WriteSequence);\r\nwritel(MPI2_WRSEQ_1ST_KEY_VALUE, &ioc->chip->WriteSequence);\r\nwritel(MPI2_WRSEQ_2ND_KEY_VALUE, &ioc->chip->WriteSequence);\r\nwritel(MPI2_WRSEQ_3RD_KEY_VALUE, &ioc->chip->WriteSequence);\r\nwritel(MPI2_WRSEQ_4TH_KEY_VALUE, &ioc->chip->WriteSequence);\r\nwritel(MPI2_WRSEQ_5TH_KEY_VALUE, &ioc->chip->WriteSequence);\r\nwritel(MPI2_WRSEQ_6TH_KEY_VALUE, &ioc->chip->WriteSequence);\r\nif (sleep_flag == CAN_SLEEP)\r\nmsleep(100);\r\nelse\r\nmdelay(100);\r\nif (count++ > 20)\r\ngoto out;\r\nhost_diagnostic = readl(&ioc->chip->HostDiagnostic);\r\ndrsprintk(ioc, pr_info(MPT3SAS_FMT\r\n"wrote magic sequence: count(%d), host_diagnostic(0x%08x)\n",\r\nioc->name, count, host_diagnostic));\r\n} while ((host_diagnostic & MPI2_DIAG_DIAG_WRITE_ENABLE) == 0);\r\nhcb_size = readl(&ioc->chip->HCBSize);\r\ndrsprintk(ioc, pr_info(MPT3SAS_FMT "diag reset: issued\n",\r\nioc->name));\r\nwritel(host_diagnostic | MPI2_DIAG_RESET_ADAPTER,\r\n&ioc->chip->HostDiagnostic);\r\nif (sleep_flag == CAN_SLEEP)\r\nmsleep(MPI2_HARD_RESET_PCIE_FIRST_READ_DELAY_MICRO_SEC/1000);\r\nelse\r\nmdelay(MPI2_HARD_RESET_PCIE_FIRST_READ_DELAY_MICRO_SEC/1000);\r\nfor (count = 0; count < (300000000 /\r\nMPI2_HARD_RESET_PCIE_SECOND_READ_DELAY_MICRO_SEC); count++) {\r\nhost_diagnostic = readl(&ioc->chip->HostDiagnostic);\r\nif (host_diagnostic == 0xFFFFFFFF)\r\ngoto out;\r\nif (!(host_diagnostic & MPI2_DIAG_RESET_ADAPTER))\r\nbreak;\r\nif (sleep_flag == CAN_SLEEP)\r\nmsleep(MPI2_HARD_RESET_PCIE_SECOND_READ_DELAY_MICRO_SEC\r\n/ 1000);\r\nelse\r\nmdelay(MPI2_HARD_RESET_PCIE_SECOND_READ_DELAY_MICRO_SEC\r\n/ 1000);\r\n}\r\nif (host_diagnostic & MPI2_DIAG_HCB_MODE) {\r\ndrsprintk(ioc, pr_info(MPT3SAS_FMT\r\n"restart the adapter assuming the HCB Address points to good F/W\n",\r\nioc->name));\r\nhost_diagnostic &= ~MPI2_DIAG_BOOT_DEVICE_SELECT_MASK;\r\nhost_diagnostic |= MPI2_DIAG_BOOT_DEVICE_SELECT_HCDW;\r\nwritel(host_diagnostic, &ioc->chip->HostDiagnostic);\r\ndrsprintk(ioc, pr_info(MPT3SAS_FMT\r\n"re-enable the HCDW\n", ioc->name));\r\nwritel(hcb_size | MPI2_HCB_SIZE_HCB_ENABLE,\r\n&ioc->chip->HCBSize);\r\n}\r\ndrsprintk(ioc, pr_info(MPT3SAS_FMT "restart the adapter\n",\r\nioc->name));\r\nwritel(host_diagnostic & ~MPI2_DIAG_HOLD_IOC_RESET,\r\n&ioc->chip->HostDiagnostic);\r\ndrsprintk(ioc, pr_info(MPT3SAS_FMT\r\n"disable writes to the diagnostic register\n", ioc->name));\r\nwritel(MPI2_WRSEQ_FLUSH_KEY_VALUE, &ioc->chip->WriteSequence);\r\ndrsprintk(ioc, pr_info(MPT3SAS_FMT\r\n"Wait for FW to go to the READY state\n", ioc->name));\r\nioc_state = _base_wait_on_iocstate(ioc, MPI2_IOC_STATE_READY, 20,\r\nsleep_flag);\r\nif (ioc_state) {\r\npr_err(MPT3SAS_FMT\r\n"%s: failed going to ready state (ioc_state=0x%x)\n",\r\nioc->name, __func__, ioc_state);\r\ngoto out;\r\n}\r\npr_info(MPT3SAS_FMT "diag reset: SUCCESS\n", ioc->name);\r\nreturn 0;\r\nout:\r\npr_err(MPT3SAS_FMT "diag reset: FAILED\n", ioc->name);\r\nreturn -EFAULT;\r\n}\r\nstatic int\r\n_base_make_ioc_ready(struct MPT3SAS_ADAPTER *ioc, int sleep_flag,\r\nenum reset_type type)\r\n{\r\nu32 ioc_state;\r\nint rc;\r\nint count;\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "%s\n", ioc->name,\r\n__func__));\r\nif (ioc->pci_error_recovery)\r\nreturn 0;\r\nioc_state = mpt3sas_base_get_iocstate(ioc, 0);\r\ndhsprintk(ioc, pr_info(MPT3SAS_FMT "%s: ioc_state(0x%08x)\n",\r\nioc->name, __func__, ioc_state));\r\ncount = 0;\r\nif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_RESET) {\r\nwhile ((ioc_state & MPI2_IOC_STATE_MASK) !=\r\nMPI2_IOC_STATE_READY) {\r\nif (count++ == 10) {\r\npr_err(MPT3SAS_FMT\r\n"%s: failed going to ready state (ioc_state=0x%x)\n",\r\nioc->name, __func__, ioc_state);\r\nreturn -EFAULT;\r\n}\r\nif (sleep_flag == CAN_SLEEP)\r\nssleep(1);\r\nelse\r\nmdelay(1000);\r\nioc_state = mpt3sas_base_get_iocstate(ioc, 0);\r\n}\r\n}\r\nif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_READY)\r\nreturn 0;\r\nif (ioc_state & MPI2_DOORBELL_USED) {\r\ndhsprintk(ioc, pr_info(MPT3SAS_FMT\r\n"unexpected doorbell active!\n",\r\nioc->name));\r\ngoto issue_diag_reset;\r\n}\r\nif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT) {\r\nmpt3sas_base_fault_info(ioc, ioc_state &\r\nMPI2_DOORBELL_DATA_MASK);\r\ngoto issue_diag_reset;\r\n}\r\nif (type == FORCE_BIG_HAMMER)\r\ngoto issue_diag_reset;\r\nif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_OPERATIONAL)\r\nif (!(_base_send_ioc_reset(ioc,\r\nMPI2_FUNCTION_IOC_MESSAGE_UNIT_RESET, 15, CAN_SLEEP))) {\r\nreturn 0;\r\n}\r\nissue_diag_reset:\r\nrc = _base_diag_reset(ioc, CAN_SLEEP);\r\nreturn rc;\r\n}\r\nstatic int\r\n_base_make_ioc_operational(struct MPT3SAS_ADAPTER *ioc, int sleep_flag)\r\n{\r\nint r, i;\r\nunsigned long flags;\r\nu32 reply_address;\r\nu16 smid;\r\nstruct _tr_list *delayed_tr, *delayed_tr_next;\r\nstruct adapter_reply_queue *reply_q;\r\nlong reply_post_free;\r\nu32 reply_post_free_sz;\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "%s\n", ioc->name,\r\n__func__));\r\nlist_for_each_entry_safe(delayed_tr, delayed_tr_next,\r\n&ioc->delayed_tr_list, list) {\r\nlist_del(&delayed_tr->list);\r\nkfree(delayed_tr);\r\n}\r\nlist_for_each_entry_safe(delayed_tr, delayed_tr_next,\r\n&ioc->delayed_tr_volume_list, list) {\r\nlist_del(&delayed_tr->list);\r\nkfree(delayed_tr);\r\n}\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nINIT_LIST_HEAD(&ioc->free_list);\r\nsmid = 1;\r\nfor (i = 0; i < ioc->scsiio_depth; i++, smid++) {\r\nINIT_LIST_HEAD(&ioc->scsi_lookup[i].chain_list);\r\nioc->scsi_lookup[i].cb_idx = 0xFF;\r\nioc->scsi_lookup[i].smid = smid;\r\nioc->scsi_lookup[i].scmd = NULL;\r\nlist_add_tail(&ioc->scsi_lookup[i].tracker_list,\r\n&ioc->free_list);\r\n}\r\nINIT_LIST_HEAD(&ioc->hpr_free_list);\r\nsmid = ioc->hi_priority_smid;\r\nfor (i = 0; i < ioc->hi_priority_depth; i++, smid++) {\r\nioc->hpr_lookup[i].cb_idx = 0xFF;\r\nioc->hpr_lookup[i].smid = smid;\r\nlist_add_tail(&ioc->hpr_lookup[i].tracker_list,\r\n&ioc->hpr_free_list);\r\n}\r\nINIT_LIST_HEAD(&ioc->internal_free_list);\r\nsmid = ioc->internal_smid;\r\nfor (i = 0; i < ioc->internal_depth; i++, smid++) {\r\nioc->internal_lookup[i].cb_idx = 0xFF;\r\nioc->internal_lookup[i].smid = smid;\r\nlist_add_tail(&ioc->internal_lookup[i].tracker_list,\r\n&ioc->internal_free_list);\r\n}\r\nINIT_LIST_HEAD(&ioc->free_chain_list);\r\nfor (i = 0; i < ioc->chain_depth; i++)\r\nlist_add_tail(&ioc->chain_lookup[i].tracker_list,\r\n&ioc->free_chain_list);\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nfor (i = 0, reply_address = (u32)ioc->reply_dma ;\r\ni < ioc->reply_free_queue_depth ; i++, reply_address +=\r\nioc->reply_sz)\r\nioc->reply_free[i] = cpu_to_le32(reply_address);\r\nif (ioc->is_driver_loading)\r\n_base_assign_reply_queues(ioc);\r\nreply_post_free = (long)ioc->reply_post_free;\r\nreply_post_free_sz = ioc->reply_post_queue_depth *\r\nsizeof(Mpi2DefaultReplyDescriptor_t);\r\nlist_for_each_entry(reply_q, &ioc->reply_queue_list, list) {\r\nreply_q->reply_post_host_index = 0;\r\nreply_q->reply_post_free = (Mpi2ReplyDescriptorsUnion_t *)\r\nreply_post_free;\r\nfor (i = 0; i < ioc->reply_post_queue_depth; i++)\r\nreply_q->reply_post_free[i].Words =\r\ncpu_to_le64(ULLONG_MAX);\r\nif (!_base_is_controller_msix_enabled(ioc))\r\ngoto skip_init_reply_post_free_queue;\r\nreply_post_free += reply_post_free_sz;\r\n}\r\nskip_init_reply_post_free_queue:\r\nr = _base_send_ioc_init(ioc, sleep_flag);\r\nif (r)\r\nreturn r;\r\nioc->reply_free_host_index = ioc->reply_free_queue_depth - 1;\r\nwritel(ioc->reply_free_host_index, &ioc->chip->ReplyFreeHostIndex);\r\nlist_for_each_entry(reply_q, &ioc->reply_queue_list, list) {\r\nwritel(reply_q->msix_index << MPI2_RPHI_MSIX_INDEX_SHIFT,\r\n&ioc->chip->ReplyPostHostIndex);\r\nif (!_base_is_controller_msix_enabled(ioc))\r\ngoto skip_init_reply_post_host_index;\r\n}\r\nskip_init_reply_post_host_index:\r\n_base_unmask_interrupts(ioc);\r\nr = _base_event_notification(ioc, sleep_flag);\r\nif (r)\r\nreturn r;\r\nif (sleep_flag == CAN_SLEEP)\r\n_base_static_config_pages(ioc);\r\nif (ioc->is_driver_loading) {\r\nioc->wait_for_discovery_to_complete =\r\n_base_determine_wait_on_discovery(ioc);\r\nreturn r;\r\n}\r\nr = _base_send_port_enable(ioc, sleep_flag);\r\nif (r)\r\nreturn r;\r\nreturn r;\r\n}\r\nvoid\r\nmpt3sas_base_free_resources(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nstruct pci_dev *pdev = ioc->pdev;\r\ndexitprintk(ioc, pr_info(MPT3SAS_FMT "%s\n", ioc->name,\r\n__func__));\r\nif (ioc->chip_phys && ioc->chip) {\r\n_base_mask_interrupts(ioc);\r\nioc->shost_recovery = 1;\r\n_base_make_ioc_ready(ioc, CAN_SLEEP, SOFT_RESET);\r\nioc->shost_recovery = 0;\r\n}\r\n_base_free_irq(ioc);\r\n_base_disable_msix(ioc);\r\nif (ioc->chip_phys && ioc->chip)\r\niounmap(ioc->chip);\r\nioc->chip_phys = 0;\r\nif (pci_is_enabled(pdev)) {\r\npci_release_selected_regions(ioc->pdev, ioc->bars);\r\npci_disable_pcie_error_reporting(pdev);\r\npci_disable_device(pdev);\r\n}\r\nreturn;\r\n}\r\nint\r\nmpt3sas_base_attach(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\nint r, i;\r\nint cpu_id, last_cpu_id = 0;\r\ndinitprintk(ioc, pr_info(MPT3SAS_FMT "%s\n", ioc->name,\r\n__func__));\r\nioc->cpu_count = num_online_cpus();\r\nfor_each_online_cpu(cpu_id)\r\nlast_cpu_id = cpu_id;\r\nioc->cpu_msix_table_sz = last_cpu_id + 1;\r\nioc->cpu_msix_table = kzalloc(ioc->cpu_msix_table_sz, GFP_KERNEL);\r\nioc->reply_queue_count = 1;\r\nif (!ioc->cpu_msix_table) {\r\ndfailprintk(ioc, pr_info(MPT3SAS_FMT\r\n"allocation for cpu_msix_table failed!!!\n",\r\nioc->name));\r\nr = -ENOMEM;\r\ngoto out_free_resources;\r\n}\r\nr = mpt3sas_base_map_resources(ioc);\r\nif (r)\r\ngoto out_free_resources;\r\npci_set_drvdata(ioc->pdev, ioc->shost);\r\nr = _base_get_ioc_facts(ioc, CAN_SLEEP);\r\nif (r)\r\ngoto out_free_resources;\r\nioc->build_sg_scmd = &_base_build_sg_scmd_ieee;\r\nioc->build_sg = &_base_build_sg_ieee;\r\nioc->build_zero_len_sge = &_base_build_zero_len_sge_ieee;\r\nioc->mpi25 = 1;\r\nioc->sge_size_ieee = sizeof(Mpi2IeeeSgeSimple64_t);\r\nioc->build_sg_mpi = &_base_build_sg;\r\nioc->build_zero_len_sge_mpi = &_base_build_zero_len_sge;\r\nr = _base_make_ioc_ready(ioc, CAN_SLEEP, SOFT_RESET);\r\nif (r)\r\ngoto out_free_resources;\r\nioc->pfacts = kcalloc(ioc->facts.NumberOfPorts,\r\nsizeof(struct mpt3sas_port_facts), GFP_KERNEL);\r\nif (!ioc->pfacts) {\r\nr = -ENOMEM;\r\ngoto out_free_resources;\r\n}\r\nfor (i = 0 ; i < ioc->facts.NumberOfPorts; i++) {\r\nr = _base_get_port_facts(ioc, i, CAN_SLEEP);\r\nif (r)\r\ngoto out_free_resources;\r\n}\r\nr = _base_allocate_memory_pools(ioc, CAN_SLEEP);\r\nif (r)\r\ngoto out_free_resources;\r\ninit_waitqueue_head(&ioc->reset_wq);\r\nioc->pd_handles_sz = (ioc->facts.MaxDevHandle / 8);\r\nif (ioc->facts.MaxDevHandle % 8)\r\nioc->pd_handles_sz++;\r\nioc->pd_handles = kzalloc(ioc->pd_handles_sz,\r\nGFP_KERNEL);\r\nif (!ioc->pd_handles) {\r\nr = -ENOMEM;\r\ngoto out_free_resources;\r\n}\r\nioc->blocking_handles = kzalloc(ioc->pd_handles_sz,\r\nGFP_KERNEL);\r\nif (!ioc->blocking_handles) {\r\nr = -ENOMEM;\r\ngoto out_free_resources;\r\n}\r\nioc->fwfault_debug = mpt3sas_fwfault_debug;\r\nmutex_init(&ioc->base_cmds.mutex);\r\nioc->base_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\r\nioc->base_cmds.status = MPT3_CMD_NOT_USED;\r\nioc->port_enable_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\r\nioc->port_enable_cmds.status = MPT3_CMD_NOT_USED;\r\nioc->transport_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\r\nioc->transport_cmds.status = MPT3_CMD_NOT_USED;\r\nmutex_init(&ioc->transport_cmds.mutex);\r\nioc->scsih_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\r\nioc->scsih_cmds.status = MPT3_CMD_NOT_USED;\r\nmutex_init(&ioc->scsih_cmds.mutex);\r\nioc->tm_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\r\nioc->tm_cmds.status = MPT3_CMD_NOT_USED;\r\nmutex_init(&ioc->tm_cmds.mutex);\r\nioc->config_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\r\nioc->config_cmds.status = MPT3_CMD_NOT_USED;\r\nmutex_init(&ioc->config_cmds.mutex);\r\nioc->ctl_cmds.reply = kzalloc(ioc->reply_sz, GFP_KERNEL);\r\nioc->ctl_cmds.sense = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_KERNEL);\r\nioc->ctl_cmds.status = MPT3_CMD_NOT_USED;\r\nmutex_init(&ioc->ctl_cmds.mutex);\r\nif (!ioc->base_cmds.reply || !ioc->transport_cmds.reply ||\r\n!ioc->scsih_cmds.reply || !ioc->tm_cmds.reply ||\r\n!ioc->config_cmds.reply || !ioc->ctl_cmds.reply ||\r\n!ioc->ctl_cmds.sense) {\r\nr = -ENOMEM;\r\ngoto out_free_resources;\r\n}\r\nfor (i = 0; i < MPI2_EVENT_NOTIFY_EVENTMASK_WORDS; i++)\r\nioc->event_masks[i] = -1;\r\n_base_unmask_events(ioc, MPI2_EVENT_SAS_DISCOVERY);\r\n_base_unmask_events(ioc, MPI2_EVENT_SAS_BROADCAST_PRIMITIVE);\r\n_base_unmask_events(ioc, MPI2_EVENT_SAS_TOPOLOGY_CHANGE_LIST);\r\n_base_unmask_events(ioc, MPI2_EVENT_SAS_DEVICE_STATUS_CHANGE);\r\n_base_unmask_events(ioc, MPI2_EVENT_SAS_ENCL_DEVICE_STATUS_CHANGE);\r\n_base_unmask_events(ioc, MPI2_EVENT_IR_CONFIGURATION_CHANGE_LIST);\r\n_base_unmask_events(ioc, MPI2_EVENT_IR_VOLUME);\r\n_base_unmask_events(ioc, MPI2_EVENT_IR_PHYSICAL_DISK);\r\n_base_unmask_events(ioc, MPI2_EVENT_IR_OPERATION_STATUS);\r\n_base_unmask_events(ioc, MPI2_EVENT_LOG_ENTRY_ADDED);\r\nr = _base_make_ioc_operational(ioc, CAN_SLEEP);\r\nif (r)\r\ngoto out_free_resources;\r\nreturn 0;\r\nout_free_resources:\r\nioc->remove_host = 1;\r\nmpt3sas_base_free_resources(ioc);\r\n_base_release_memory_pools(ioc);\r\npci_set_drvdata(ioc->pdev, NULL);\r\nkfree(ioc->cpu_msix_table);\r\nkfree(ioc->pd_handles);\r\nkfree(ioc->blocking_handles);\r\nkfree(ioc->tm_cmds.reply);\r\nkfree(ioc->transport_cmds.reply);\r\nkfree(ioc->scsih_cmds.reply);\r\nkfree(ioc->config_cmds.reply);\r\nkfree(ioc->base_cmds.reply);\r\nkfree(ioc->port_enable_cmds.reply);\r\nkfree(ioc->ctl_cmds.reply);\r\nkfree(ioc->ctl_cmds.sense);\r\nkfree(ioc->pfacts);\r\nioc->ctl_cmds.reply = NULL;\r\nioc->base_cmds.reply = NULL;\r\nioc->tm_cmds.reply = NULL;\r\nioc->scsih_cmds.reply = NULL;\r\nioc->transport_cmds.reply = NULL;\r\nioc->config_cmds.reply = NULL;\r\nioc->pfacts = NULL;\r\nreturn r;\r\n}\r\nvoid\r\nmpt3sas_base_detach(struct MPT3SAS_ADAPTER *ioc)\r\n{\r\ndexitprintk(ioc, pr_info(MPT3SAS_FMT "%s\n", ioc->name,\r\n__func__));\r\nmpt3sas_base_stop_watchdog(ioc);\r\nmpt3sas_base_free_resources(ioc);\r\n_base_release_memory_pools(ioc);\r\npci_set_drvdata(ioc->pdev, NULL);\r\nkfree(ioc->cpu_msix_table);\r\nkfree(ioc->pd_handles);\r\nkfree(ioc->blocking_handles);\r\nkfree(ioc->pfacts);\r\nkfree(ioc->ctl_cmds.reply);\r\nkfree(ioc->ctl_cmds.sense);\r\nkfree(ioc->base_cmds.reply);\r\nkfree(ioc->port_enable_cmds.reply);\r\nkfree(ioc->tm_cmds.reply);\r\nkfree(ioc->transport_cmds.reply);\r\nkfree(ioc->scsih_cmds.reply);\r\nkfree(ioc->config_cmds.reply);\r\n}\r\nstatic void\r\n_base_reset_handler(struct MPT3SAS_ADAPTER *ioc, int reset_phase)\r\n{\r\nmpt3sas_scsih_reset_handler(ioc, reset_phase);\r\nmpt3sas_ctl_reset_handler(ioc, reset_phase);\r\nswitch (reset_phase) {\r\ncase MPT3_IOC_PRE_RESET:\r\ndtmprintk(ioc, pr_info(MPT3SAS_FMT\r\n"%s: MPT3_IOC_PRE_RESET\n", ioc->name, __func__));\r\nbreak;\r\ncase MPT3_IOC_AFTER_RESET:\r\ndtmprintk(ioc, pr_info(MPT3SAS_FMT\r\n"%s: MPT3_IOC_AFTER_RESET\n", ioc->name, __func__));\r\nif (ioc->transport_cmds.status & MPT3_CMD_PENDING) {\r\nioc->transport_cmds.status |= MPT3_CMD_RESET;\r\nmpt3sas_base_free_smid(ioc, ioc->transport_cmds.smid);\r\ncomplete(&ioc->transport_cmds.done);\r\n}\r\nif (ioc->base_cmds.status & MPT3_CMD_PENDING) {\r\nioc->base_cmds.status |= MPT3_CMD_RESET;\r\nmpt3sas_base_free_smid(ioc, ioc->base_cmds.smid);\r\ncomplete(&ioc->base_cmds.done);\r\n}\r\nif (ioc->port_enable_cmds.status & MPT3_CMD_PENDING) {\r\nioc->port_enable_failed = 1;\r\nioc->port_enable_cmds.status |= MPT3_CMD_RESET;\r\nmpt3sas_base_free_smid(ioc, ioc->port_enable_cmds.smid);\r\nif (ioc->is_driver_loading) {\r\nioc->start_scan_failed =\r\nMPI2_IOCSTATUS_INTERNAL_ERROR;\r\nioc->start_scan = 0;\r\nioc->port_enable_cmds.status =\r\nMPT3_CMD_NOT_USED;\r\n} else\r\ncomplete(&ioc->port_enable_cmds.done);\r\n}\r\nif (ioc->config_cmds.status & MPT3_CMD_PENDING) {\r\nioc->config_cmds.status |= MPT3_CMD_RESET;\r\nmpt3sas_base_free_smid(ioc, ioc->config_cmds.smid);\r\nioc->config_cmds.smid = USHRT_MAX;\r\ncomplete(&ioc->config_cmds.done);\r\n}\r\nbreak;\r\ncase MPT3_IOC_DONE_RESET:\r\ndtmprintk(ioc, pr_info(MPT3SAS_FMT\r\n"%s: MPT3_IOC_DONE_RESET\n", ioc->name, __func__));\r\nbreak;\r\n}\r\n}\r\nstatic void\r\n_wait_for_commands_to_complete(struct MPT3SAS_ADAPTER *ioc, int sleep_flag)\r\n{\r\nu32 ioc_state;\r\nunsigned long flags;\r\nu16 i;\r\nioc->pending_io_count = 0;\r\nif (sleep_flag != CAN_SLEEP)\r\nreturn;\r\nioc_state = mpt3sas_base_get_iocstate(ioc, 0);\r\nif ((ioc_state & MPI2_IOC_STATE_MASK) != MPI2_IOC_STATE_OPERATIONAL)\r\nreturn;\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nfor (i = 0; i < ioc->scsiio_depth; i++)\r\nif (ioc->scsi_lookup[i].cb_idx != 0xFF)\r\nioc->pending_io_count++;\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nif (!ioc->pending_io_count)\r\nreturn;\r\nwait_event_timeout(ioc->reset_wq, ioc->pending_io_count == 0, 10 * HZ);\r\n}\r\nint\r\nmpt3sas_base_hard_reset_handler(struct MPT3SAS_ADAPTER *ioc, int sleep_flag,\r\nenum reset_type type)\r\n{\r\nint r;\r\nunsigned long flags;\r\nu32 ioc_state;\r\nu8 is_fault = 0, is_trigger = 0;\r\ndtmprintk(ioc, pr_info(MPT3SAS_FMT "%s: enter\n", ioc->name,\r\n__func__));\r\nif (ioc->pci_error_recovery) {\r\npr_err(MPT3SAS_FMT "%s: pci error recovery reset\n",\r\nioc->name, __func__);\r\nr = 0;\r\ngoto out_unlocked;\r\n}\r\nif (mpt3sas_fwfault_debug)\r\nmpt3sas_halt_firmware(ioc);\r\nBUG_ON(sleep_flag == NO_SLEEP);\r\nif (!mutex_trylock(&ioc->reset_in_progress_mutex)) {\r\ndo {\r\nssleep(1);\r\n} while (ioc->shost_recovery == 1);\r\ndtmprintk(ioc, pr_info(MPT3SAS_FMT "%s: exit\n", ioc->name,\r\n__func__));\r\nreturn ioc->ioc_reset_in_progress_status;\r\n}\r\nspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\r\nioc->shost_recovery = 1;\r\nspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\r\nif ((ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\r\nMPT3_DIAG_BUFFER_IS_REGISTERED) &&\r\n(!(ioc->diag_buffer_status[MPI2_DIAG_BUF_TYPE_TRACE] &\r\nMPT3_DIAG_BUFFER_IS_RELEASED))) {\r\nis_trigger = 1;\r\nioc_state = mpt3sas_base_get_iocstate(ioc, 0);\r\nif ((ioc_state & MPI2_IOC_STATE_MASK) == MPI2_IOC_STATE_FAULT)\r\nis_fault = 1;\r\n}\r\n_base_reset_handler(ioc, MPT3_IOC_PRE_RESET);\r\n_wait_for_commands_to_complete(ioc, sleep_flag);\r\n_base_mask_interrupts(ioc);\r\nr = _base_make_ioc_ready(ioc, sleep_flag, type);\r\nif (r)\r\ngoto out;\r\n_base_reset_handler(ioc, MPT3_IOC_AFTER_RESET);\r\nif (ioc->is_driver_loading && ioc->port_enable_failed) {\r\nioc->remove_host = 1;\r\nr = -EFAULT;\r\ngoto out;\r\n}\r\nr = _base_get_ioc_facts(ioc, CAN_SLEEP);\r\nif (r)\r\ngoto out;\r\nr = _base_make_ioc_operational(ioc, sleep_flag);\r\nif (!r)\r\n_base_reset_handler(ioc, MPT3_IOC_DONE_RESET);\r\nout:\r\ndtmprintk(ioc, pr_info(MPT3SAS_FMT "%s: %s\n",\r\nioc->name, __func__, ((r == 0) ? "SUCCESS" : "FAILED")));\r\nspin_lock_irqsave(&ioc->ioc_reset_in_progress_lock, flags);\r\nioc->ioc_reset_in_progress_status = r;\r\nioc->shost_recovery = 0;\r\nspin_unlock_irqrestore(&ioc->ioc_reset_in_progress_lock, flags);\r\nioc->ioc_reset_count++;\r\nmutex_unlock(&ioc->reset_in_progress_mutex);\r\nout_unlocked:\r\nif ((r == 0) && is_trigger) {\r\nif (is_fault)\r\nmpt3sas_trigger_master(ioc, MASTER_TRIGGER_FW_FAULT);\r\nelse\r\nmpt3sas_trigger_master(ioc,\r\nMASTER_TRIGGER_ADAPTER_RESET);\r\n}\r\ndtmprintk(ioc, pr_info(MPT3SAS_FMT "%s: exit\n", ioc->name,\r\n__func__));\r\nreturn r;\r\n}
