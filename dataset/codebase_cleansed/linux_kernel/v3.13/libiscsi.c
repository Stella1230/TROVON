inline void iscsi_conn_queue_work(struct iscsi_conn *conn)\r\n{\r\nstruct Scsi_Host *shost = conn->session->host;\r\nstruct iscsi_host *ihost = shost_priv(shost);\r\nif (ihost->workq)\r\nqueue_work(ihost->workq, &conn->xmitwork);\r\n}\r\nstatic void __iscsi_update_cmdsn(struct iscsi_session *session,\r\nuint32_t exp_cmdsn, uint32_t max_cmdsn)\r\n{\r\nif (iscsi_sna_lt(max_cmdsn, exp_cmdsn - 1))\r\nreturn;\r\nif (exp_cmdsn != session->exp_cmdsn &&\r\n!iscsi_sna_lt(exp_cmdsn, session->exp_cmdsn))\r\nsession->exp_cmdsn = exp_cmdsn;\r\nif (max_cmdsn != session->max_cmdsn &&\r\n!iscsi_sna_lt(max_cmdsn, session->max_cmdsn)) {\r\nsession->max_cmdsn = max_cmdsn;\r\nif (!list_empty(&session->leadconn->cmdqueue) ||\r\n!list_empty(&session->leadconn->mgmtqueue))\r\niscsi_conn_queue_work(session->leadconn);\r\n}\r\n}\r\nvoid iscsi_update_cmdsn(struct iscsi_session *session, struct iscsi_nopin *hdr)\r\n{\r\n__iscsi_update_cmdsn(session, be32_to_cpu(hdr->exp_cmdsn),\r\nbe32_to_cpu(hdr->max_cmdsn));\r\n}\r\nvoid iscsi_prep_data_out_pdu(struct iscsi_task *task, struct iscsi_r2t_info *r2t,\r\nstruct iscsi_data *hdr)\r\n{\r\nstruct iscsi_conn *conn = task->conn;\r\nunsigned int left = r2t->data_length - r2t->sent;\r\ntask->hdr_len = sizeof(struct iscsi_data);\r\nmemset(hdr, 0, sizeof(struct iscsi_data));\r\nhdr->ttt = r2t->ttt;\r\nhdr->datasn = cpu_to_be32(r2t->datasn);\r\nr2t->datasn++;\r\nhdr->opcode = ISCSI_OP_SCSI_DATA_OUT;\r\nhdr->lun = task->lun;\r\nhdr->itt = task->hdr_itt;\r\nhdr->exp_statsn = r2t->exp_statsn;\r\nhdr->offset = cpu_to_be32(r2t->data_offset + r2t->sent);\r\nif (left > conn->max_xmit_dlength) {\r\nhton24(hdr->dlength, conn->max_xmit_dlength);\r\nr2t->data_count = conn->max_xmit_dlength;\r\nhdr->flags = 0;\r\n} else {\r\nhton24(hdr->dlength, left);\r\nr2t->data_count = left;\r\nhdr->flags = ISCSI_FLAG_CMD_FINAL;\r\n}\r\nconn->dataout_pdus_cnt++;\r\n}\r\nstatic int iscsi_add_hdr(struct iscsi_task *task, unsigned len)\r\n{\r\nunsigned exp_len = task->hdr_len + len;\r\nif (exp_len > task->hdr_max) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nWARN_ON(len & (ISCSI_PAD_LEN - 1));\r\ntask->hdr_len = exp_len;\r\nreturn 0;\r\n}\r\nstatic int iscsi_prep_ecdb_ahs(struct iscsi_task *task)\r\n{\r\nstruct scsi_cmnd *cmd = task->sc;\r\nunsigned rlen, pad_len;\r\nunsigned short ahslength;\r\nstruct iscsi_ecdb_ahdr *ecdb_ahdr;\r\nint rc;\r\necdb_ahdr = iscsi_next_hdr(task);\r\nrlen = cmd->cmd_len - ISCSI_CDB_SIZE;\r\nBUG_ON(rlen > sizeof(ecdb_ahdr->ecdb));\r\nahslength = rlen + sizeof(ecdb_ahdr->reserved);\r\npad_len = iscsi_padding(rlen);\r\nrc = iscsi_add_hdr(task, sizeof(ecdb_ahdr->ahslength) +\r\nsizeof(ecdb_ahdr->ahstype) + ahslength + pad_len);\r\nif (rc)\r\nreturn rc;\r\nif (pad_len)\r\nmemset(&ecdb_ahdr->ecdb[rlen], 0, pad_len);\r\necdb_ahdr->ahslength = cpu_to_be16(ahslength);\r\necdb_ahdr->ahstype = ISCSI_AHSTYPE_CDB;\r\necdb_ahdr->reserved = 0;\r\nmemcpy(ecdb_ahdr->ecdb, cmd->cmnd + ISCSI_CDB_SIZE, rlen);\r\nISCSI_DBG_SESSION(task->conn->session,\r\n"iscsi_prep_ecdb_ahs: varlen_cdb_len %d "\r\n"rlen %d pad_len %d ahs_length %d iscsi_headers_size "\r\n"%u\n", cmd->cmd_len, rlen, pad_len, ahslength,\r\ntask->hdr_len);\r\nreturn 0;\r\n}\r\nstatic int iscsi_prep_bidi_ahs(struct iscsi_task *task)\r\n{\r\nstruct scsi_cmnd *sc = task->sc;\r\nstruct iscsi_rlength_ahdr *rlen_ahdr;\r\nint rc;\r\nrlen_ahdr = iscsi_next_hdr(task);\r\nrc = iscsi_add_hdr(task, sizeof(*rlen_ahdr));\r\nif (rc)\r\nreturn rc;\r\nrlen_ahdr->ahslength =\r\ncpu_to_be16(sizeof(rlen_ahdr->read_length) +\r\nsizeof(rlen_ahdr->reserved));\r\nrlen_ahdr->ahstype = ISCSI_AHSTYPE_RLENGTH;\r\nrlen_ahdr->reserved = 0;\r\nrlen_ahdr->read_length = cpu_to_be32(scsi_in(sc)->length);\r\nISCSI_DBG_SESSION(task->conn->session,\r\n"bidi-in rlen_ahdr->read_length(%d) "\r\n"rlen_ahdr->ahslength(%d)\n",\r\nbe32_to_cpu(rlen_ahdr->read_length),\r\nbe16_to_cpu(rlen_ahdr->ahslength));\r\nreturn 0;\r\n}\r\nstatic int iscsi_check_tmf_restrictions(struct iscsi_task *task, int opcode)\r\n{\r\nstruct iscsi_conn *conn = task->conn;\r\nstruct iscsi_tm *tmf = &conn->tmhdr;\r\nunsigned int hdr_lun;\r\nif (conn->tmf_state == TMF_INITIAL)\r\nreturn 0;\r\nif ((tmf->opcode & ISCSI_OPCODE_MASK) != ISCSI_OP_SCSI_TMFUNC)\r\nreturn 0;\r\nswitch (ISCSI_TM_FUNC_VALUE(tmf)) {\r\ncase ISCSI_TM_FUNC_LOGICAL_UNIT_RESET:\r\nhdr_lun = scsilun_to_int(&tmf->lun);\r\nif (hdr_lun != task->sc->device->lun)\r\nreturn 0;\r\ncase ISCSI_TM_FUNC_TARGET_WARM_RESET:\r\nif (opcode != ISCSI_OP_SCSI_DATA_OUT) {\r\niscsi_conn_printk(KERN_INFO, conn,\r\n"task [op %x/%x itt "\r\n"0x%x/0x%x] "\r\n"rejected.\n",\r\ntask->hdr->opcode, opcode,\r\ntask->itt, task->hdr_itt);\r\nreturn -EACCES;\r\n}\r\nif (conn->session->fast_abort) {\r\niscsi_conn_printk(KERN_INFO, conn,\r\n"task [op %x/%x itt "\r\n"0x%x/0x%x] fast abort.\n",\r\ntask->hdr->opcode, opcode,\r\ntask->itt, task->hdr_itt);\r\nreturn -EACCES;\r\n}\r\nbreak;\r\ncase ISCSI_TM_FUNC_ABORT_TASK:\r\nif (opcode == ISCSI_OP_SCSI_DATA_OUT &&\r\ntask->hdr_itt == tmf->rtt) {\r\nISCSI_DBG_SESSION(conn->session,\r\n"Preventing task %x/%x from sending "\r\n"data-out due to abort task in "\r\n"progress\n", task->itt,\r\ntask->hdr_itt);\r\nreturn -EACCES;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)\r\n{\r\nstruct iscsi_conn *conn = task->conn;\r\nstruct iscsi_session *session = conn->session;\r\nstruct scsi_cmnd *sc = task->sc;\r\nstruct iscsi_scsi_req *hdr;\r\nunsigned hdrlength, cmd_len;\r\nitt_t itt;\r\nint rc;\r\nrc = iscsi_check_tmf_restrictions(task, ISCSI_OP_SCSI_CMD);\r\nif (rc)\r\nreturn rc;\r\nif (conn->session->tt->alloc_pdu) {\r\nrc = conn->session->tt->alloc_pdu(task, ISCSI_OP_SCSI_CMD);\r\nif (rc)\r\nreturn rc;\r\n}\r\nhdr = (struct iscsi_scsi_req *)task->hdr;\r\nitt = hdr->itt;\r\nmemset(hdr, 0, sizeof(*hdr));\r\nif (session->tt->parse_pdu_itt)\r\nhdr->itt = task->hdr_itt = itt;\r\nelse\r\nhdr->itt = task->hdr_itt = build_itt(task->itt,\r\ntask->conn->session->age);\r\ntask->hdr_len = 0;\r\nrc = iscsi_add_hdr(task, sizeof(*hdr));\r\nif (rc)\r\nreturn rc;\r\nhdr->opcode = ISCSI_OP_SCSI_CMD;\r\nhdr->flags = ISCSI_ATTR_SIMPLE;\r\nint_to_scsilun(sc->device->lun, &hdr->lun);\r\ntask->lun = hdr->lun;\r\nhdr->exp_statsn = cpu_to_be32(conn->exp_statsn);\r\ncmd_len = sc->cmd_len;\r\nif (cmd_len < ISCSI_CDB_SIZE)\r\nmemset(&hdr->cdb[cmd_len], 0, ISCSI_CDB_SIZE - cmd_len);\r\nelse if (cmd_len > ISCSI_CDB_SIZE) {\r\nrc = iscsi_prep_ecdb_ahs(task);\r\nif (rc)\r\nreturn rc;\r\ncmd_len = ISCSI_CDB_SIZE;\r\n}\r\nmemcpy(hdr->cdb, sc->cmnd, cmd_len);\r\ntask->imm_count = 0;\r\nif (scsi_bidi_cmnd(sc)) {\r\nhdr->flags |= ISCSI_FLAG_CMD_READ;\r\nrc = iscsi_prep_bidi_ahs(task);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (sc->sc_data_direction == DMA_TO_DEVICE) {\r\nunsigned out_len = scsi_out(sc)->length;\r\nstruct iscsi_r2t_info *r2t = &task->unsol_r2t;\r\nhdr->data_length = cpu_to_be32(out_len);\r\nhdr->flags |= ISCSI_FLAG_CMD_WRITE;\r\nmemset(r2t, 0, sizeof(*r2t));\r\nif (session->imm_data_en) {\r\nif (out_len >= session->first_burst)\r\ntask->imm_count = min(session->first_burst,\r\nconn->max_xmit_dlength);\r\nelse\r\ntask->imm_count = min(out_len,\r\nconn->max_xmit_dlength);\r\nhton24(hdr->dlength, task->imm_count);\r\n} else\r\nzero_data(hdr->dlength);\r\nif (!session->initial_r2t_en) {\r\nr2t->data_length = min(session->first_burst, out_len) -\r\ntask->imm_count;\r\nr2t->data_offset = task->imm_count;\r\nr2t->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);\r\nr2t->exp_statsn = cpu_to_be32(conn->exp_statsn);\r\n}\r\nif (!task->unsol_r2t.data_length)\r\nhdr->flags |= ISCSI_FLAG_CMD_FINAL;\r\n} else {\r\nhdr->flags |= ISCSI_FLAG_CMD_FINAL;\r\nzero_data(hdr->dlength);\r\nhdr->data_length = cpu_to_be32(scsi_in(sc)->length);\r\nif (sc->sc_data_direction == DMA_FROM_DEVICE)\r\nhdr->flags |= ISCSI_FLAG_CMD_READ;\r\n}\r\nhdrlength = task->hdr_len - sizeof(*hdr);\r\nWARN_ON(hdrlength & (ISCSI_PAD_LEN-1));\r\nhdrlength /= ISCSI_PAD_LEN;\r\nWARN_ON(hdrlength >= 256);\r\nhdr->hlength = hdrlength & 0xFF;\r\nhdr->cmdsn = task->cmdsn = cpu_to_be32(session->cmdsn);\r\nif (session->tt->init_task && session->tt->init_task(task))\r\nreturn -EIO;\r\ntask->state = ISCSI_TASK_RUNNING;\r\nsession->cmdsn++;\r\nconn->scsicmd_pdus_cnt++;\r\nISCSI_DBG_SESSION(session, "iscsi prep [%s cid %d sc %p cdb 0x%x "\r\n"itt 0x%x len %d bidi_len %d cmdsn %d win %d]\n",\r\nscsi_bidi_cmnd(sc) ? "bidirectional" :\r\nsc->sc_data_direction == DMA_TO_DEVICE ?\r\n"write" : "read", conn->id, sc, sc->cmnd[0],\r\ntask->itt, scsi_bufflen(sc),\r\nscsi_bidi_cmnd(sc) ? scsi_in(sc)->length : 0,\r\nsession->cmdsn,\r\nsession->max_cmdsn - session->exp_cmdsn + 1);\r\nreturn 0;\r\n}\r\nstatic void iscsi_free_task(struct iscsi_task *task)\r\n{\r\nstruct iscsi_conn *conn = task->conn;\r\nstruct iscsi_session *session = conn->session;\r\nstruct scsi_cmnd *sc = task->sc;\r\nint oldstate = task->state;\r\nISCSI_DBG_SESSION(session, "freeing task itt 0x%x state %d sc %p\n",\r\ntask->itt, task->state, task->sc);\r\nsession->tt->cleanup_task(task);\r\ntask->state = ISCSI_TASK_FREE;\r\ntask->sc = NULL;\r\nif (conn->login_task == task)\r\nreturn;\r\nkfifo_in(&session->cmdpool.queue, (void*)&task, sizeof(void*));\r\nif (sc) {\r\nsc->SCp.ptr = NULL;\r\nif (oldstate != ISCSI_TASK_REQUEUE_SCSIQ)\r\nsc->scsi_done(sc);\r\n}\r\n}\r\nvoid __iscsi_get_task(struct iscsi_task *task)\r\n{\r\natomic_inc(&task->refcount);\r\n}\r\nvoid __iscsi_put_task(struct iscsi_task *task)\r\n{\r\nif (atomic_dec_and_test(&task->refcount))\r\niscsi_free_task(task);\r\n}\r\nvoid iscsi_put_task(struct iscsi_task *task)\r\n{\r\nstruct iscsi_session *session = task->conn->session;\r\nspin_lock_bh(&session->lock);\r\n__iscsi_put_task(task);\r\nspin_unlock_bh(&session->lock);\r\n}\r\nstatic void iscsi_complete_task(struct iscsi_task *task, int state)\r\n{\r\nstruct iscsi_conn *conn = task->conn;\r\nISCSI_DBG_SESSION(conn->session,\r\n"complete task itt 0x%x state %d sc %p\n",\r\ntask->itt, task->state, task->sc);\r\nif (task->state == ISCSI_TASK_COMPLETED ||\r\ntask->state == ISCSI_TASK_ABRT_TMF ||\r\ntask->state == ISCSI_TASK_ABRT_SESS_RECOV ||\r\ntask->state == ISCSI_TASK_REQUEUE_SCSIQ)\r\nreturn;\r\nWARN_ON_ONCE(task->state == ISCSI_TASK_FREE);\r\ntask->state = state;\r\nif (!list_empty(&task->running))\r\nlist_del_init(&task->running);\r\nif (conn->task == task)\r\nconn->task = NULL;\r\nif (conn->ping_task == task)\r\nconn->ping_task = NULL;\r\n__iscsi_put_task(task);\r\n}\r\nvoid iscsi_complete_scsi_task(struct iscsi_task *task,\r\nuint32_t exp_cmdsn, uint32_t max_cmdsn)\r\n{\r\nstruct iscsi_conn *conn = task->conn;\r\nISCSI_DBG_SESSION(conn->session, "[itt 0x%x]\n", task->itt);\r\nconn->last_recv = jiffies;\r\n__iscsi_update_cmdsn(conn->session, exp_cmdsn, max_cmdsn);\r\niscsi_complete_task(task, ISCSI_TASK_COMPLETED);\r\n}\r\nstatic void fail_scsi_task(struct iscsi_task *task, int err)\r\n{\r\nstruct iscsi_conn *conn = task->conn;\r\nstruct scsi_cmnd *sc;\r\nint state;\r\nsc = task->sc;\r\nif (!sc)\r\nreturn;\r\nif (task->state == ISCSI_TASK_PENDING) {\r\nconn->session->queued_cmdsn--;\r\nstate = ISCSI_TASK_COMPLETED;\r\n} else if (err == DID_TRANSPORT_DISRUPTED)\r\nstate = ISCSI_TASK_ABRT_SESS_RECOV;\r\nelse\r\nstate = ISCSI_TASK_ABRT_TMF;\r\nsc->result = err << 16;\r\nif (!scsi_bidi_cmnd(sc))\r\nscsi_set_resid(sc, scsi_bufflen(sc));\r\nelse {\r\nscsi_out(sc)->resid = scsi_out(sc)->length;\r\nscsi_in(sc)->resid = scsi_in(sc)->length;\r\n}\r\niscsi_complete_task(task, state);\r\n}\r\nstatic int iscsi_prep_mgmt_task(struct iscsi_conn *conn,\r\nstruct iscsi_task *task)\r\n{\r\nstruct iscsi_session *session = conn->session;\r\nstruct iscsi_hdr *hdr = task->hdr;\r\nstruct iscsi_nopout *nop = (struct iscsi_nopout *)hdr;\r\nuint8_t opcode = hdr->opcode & ISCSI_OPCODE_MASK;\r\nif (conn->session->state == ISCSI_STATE_LOGGING_OUT)\r\nreturn -ENOTCONN;\r\nif (opcode != ISCSI_OP_LOGIN && opcode != ISCSI_OP_TEXT)\r\nnop->exp_statsn = cpu_to_be32(conn->exp_statsn);\r\nnop->cmdsn = cpu_to_be32(session->cmdsn);\r\nif (hdr->itt != RESERVED_ITT) {\r\nif (conn->c_stage == ISCSI_CONN_STARTED &&\r\n!(hdr->opcode & ISCSI_OP_IMMEDIATE)) {\r\nsession->queued_cmdsn++;\r\nsession->cmdsn++;\r\n}\r\n}\r\nif (session->tt->init_task && session->tt->init_task(task))\r\nreturn -EIO;\r\nif ((hdr->opcode & ISCSI_OPCODE_MASK) == ISCSI_OP_LOGOUT)\r\nsession->state = ISCSI_STATE_LOGGING_OUT;\r\ntask->state = ISCSI_TASK_RUNNING;\r\nISCSI_DBG_SESSION(session, "mgmtpdu [op 0x%x hdr->itt 0x%x "\r\n"datalen %d]\n", hdr->opcode & ISCSI_OPCODE_MASK,\r\nhdr->itt, task->data_count);\r\nreturn 0;\r\n}\r\nstatic struct iscsi_task *\r\n__iscsi_conn_send_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,\r\nchar *data, uint32_t data_size)\r\n{\r\nstruct iscsi_session *session = conn->session;\r\nstruct iscsi_host *ihost = shost_priv(session->host);\r\nuint8_t opcode = hdr->opcode & ISCSI_OPCODE_MASK;\r\nstruct iscsi_task *task;\r\nitt_t itt;\r\nif (session->state == ISCSI_STATE_TERMINATE)\r\nreturn NULL;\r\nif (opcode == ISCSI_OP_LOGIN || opcode == ISCSI_OP_TEXT) {\r\nif (conn->login_task->state != ISCSI_TASK_FREE) {\r\niscsi_conn_printk(KERN_ERR, conn, "Login/Text in "\r\n"progress. Cannot start new task.\n");\r\nreturn NULL;\r\n}\r\ntask = conn->login_task;\r\n} else {\r\nif (session->state != ISCSI_STATE_LOGGED_IN)\r\nreturn NULL;\r\nBUG_ON(conn->c_stage == ISCSI_CONN_INITIAL_STAGE);\r\nBUG_ON(conn->c_stage == ISCSI_CONN_STOPPED);\r\nif (!kfifo_out(&session->cmdpool.queue,\r\n(void*)&task, sizeof(void*)))\r\nreturn NULL;\r\n}\r\natomic_set(&task->refcount, 1);\r\ntask->conn = conn;\r\ntask->sc = NULL;\r\nINIT_LIST_HEAD(&task->running);\r\ntask->state = ISCSI_TASK_PENDING;\r\nif (data_size) {\r\nmemcpy(task->data, data, data_size);\r\ntask->data_count = data_size;\r\n} else\r\ntask->data_count = 0;\r\nif (conn->session->tt->alloc_pdu) {\r\nif (conn->session->tt->alloc_pdu(task, hdr->opcode)) {\r\niscsi_conn_printk(KERN_ERR, conn, "Could not allocate "\r\n"pdu for mgmt task.\n");\r\ngoto free_task;\r\n}\r\n}\r\nitt = task->hdr->itt;\r\ntask->hdr_len = sizeof(struct iscsi_hdr);\r\nmemcpy(task->hdr, hdr, sizeof(struct iscsi_hdr));\r\nif (hdr->itt != RESERVED_ITT) {\r\nif (session->tt->parse_pdu_itt)\r\ntask->hdr->itt = itt;\r\nelse\r\ntask->hdr->itt = build_itt(task->itt,\r\ntask->conn->session->age);\r\n}\r\nif (!ihost->workq) {\r\nif (iscsi_prep_mgmt_task(conn, task))\r\ngoto free_task;\r\nif (session->tt->xmit_task(task))\r\ngoto free_task;\r\n} else {\r\nlist_add_tail(&task->running, &conn->mgmtqueue);\r\niscsi_conn_queue_work(conn);\r\n}\r\nreturn task;\r\nfree_task:\r\n__iscsi_put_task(task);\r\nreturn NULL;\r\n}\r\nint iscsi_conn_send_pdu(struct iscsi_cls_conn *cls_conn, struct iscsi_hdr *hdr,\r\nchar *data, uint32_t data_size)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct iscsi_session *session = conn->session;\r\nint err = 0;\r\nspin_lock_bh(&session->lock);\r\nif (!__iscsi_conn_send_pdu(conn, hdr, data, data_size))\r\nerr = -EPERM;\r\nspin_unlock_bh(&session->lock);\r\nreturn err;\r\n}\r\nstatic void iscsi_scsi_cmd_rsp(struct iscsi_conn *conn, struct iscsi_hdr *hdr,\r\nstruct iscsi_task *task, char *data,\r\nint datalen)\r\n{\r\nstruct iscsi_scsi_rsp *rhdr = (struct iscsi_scsi_rsp *)hdr;\r\nstruct iscsi_session *session = conn->session;\r\nstruct scsi_cmnd *sc = task->sc;\r\niscsi_update_cmdsn(session, (struct iscsi_nopin*)rhdr);\r\nconn->exp_statsn = be32_to_cpu(rhdr->statsn) + 1;\r\nsc->result = (DID_OK << 16) | rhdr->cmd_status;\r\nif (rhdr->response != ISCSI_STATUS_CMD_COMPLETED) {\r\nsc->result = DID_ERROR << 16;\r\ngoto out;\r\n}\r\nif (rhdr->cmd_status == SAM_STAT_CHECK_CONDITION) {\r\nuint16_t senselen;\r\nif (datalen < 2) {\r\ninvalid_datalen:\r\niscsi_conn_printk(KERN_ERR, conn,\r\n"Got CHECK_CONDITION but invalid data "\r\n"buffer size of %d\n", datalen);\r\nsc->result = DID_BAD_TARGET << 16;\r\ngoto out;\r\n}\r\nsenselen = get_unaligned_be16(data);\r\nif (datalen < senselen)\r\ngoto invalid_datalen;\r\nmemcpy(sc->sense_buffer, data + 2,\r\nmin_t(uint16_t, senselen, SCSI_SENSE_BUFFERSIZE));\r\nISCSI_DBG_SESSION(session, "copied %d bytes of sense\n",\r\nmin_t(uint16_t, senselen,\r\nSCSI_SENSE_BUFFERSIZE));\r\n}\r\nif (rhdr->flags & (ISCSI_FLAG_CMD_BIDI_UNDERFLOW |\r\nISCSI_FLAG_CMD_BIDI_OVERFLOW)) {\r\nint res_count = be32_to_cpu(rhdr->bi_residual_count);\r\nif (scsi_bidi_cmnd(sc) && res_count > 0 &&\r\n(rhdr->flags & ISCSI_FLAG_CMD_BIDI_OVERFLOW ||\r\nres_count <= scsi_in(sc)->length))\r\nscsi_in(sc)->resid = res_count;\r\nelse\r\nsc->result = (DID_BAD_TARGET << 16) | rhdr->cmd_status;\r\n}\r\nif (rhdr->flags & (ISCSI_FLAG_CMD_UNDERFLOW |\r\nISCSI_FLAG_CMD_OVERFLOW)) {\r\nint res_count = be32_to_cpu(rhdr->residual_count);\r\nif (res_count > 0 &&\r\n(rhdr->flags & ISCSI_FLAG_CMD_OVERFLOW ||\r\nres_count <= scsi_bufflen(sc)))\r\nscsi_set_resid(sc, res_count);\r\nelse\r\nsc->result = (DID_BAD_TARGET << 16) | rhdr->cmd_status;\r\n}\r\nout:\r\nISCSI_DBG_SESSION(session, "cmd rsp done [sc %p res %d itt 0x%x]\n",\r\nsc, sc->result, task->itt);\r\nconn->scsirsp_pdus_cnt++;\r\niscsi_complete_task(task, ISCSI_TASK_COMPLETED);\r\n}\r\nstatic void\r\niscsi_data_in_rsp(struct iscsi_conn *conn, struct iscsi_hdr *hdr,\r\nstruct iscsi_task *task)\r\n{\r\nstruct iscsi_data_rsp *rhdr = (struct iscsi_data_rsp *)hdr;\r\nstruct scsi_cmnd *sc = task->sc;\r\nif (!(rhdr->flags & ISCSI_FLAG_DATA_STATUS))\r\nreturn;\r\niscsi_update_cmdsn(conn->session, (struct iscsi_nopin *)hdr);\r\nsc->result = (DID_OK << 16) | rhdr->cmd_status;\r\nconn->exp_statsn = be32_to_cpu(rhdr->statsn) + 1;\r\nif (rhdr->flags & (ISCSI_FLAG_DATA_UNDERFLOW |\r\nISCSI_FLAG_DATA_OVERFLOW)) {\r\nint res_count = be32_to_cpu(rhdr->residual_count);\r\nif (res_count > 0 &&\r\n(rhdr->flags & ISCSI_FLAG_CMD_OVERFLOW ||\r\nres_count <= scsi_in(sc)->length))\r\nscsi_in(sc)->resid = res_count;\r\nelse\r\nsc->result = (DID_BAD_TARGET << 16) | rhdr->cmd_status;\r\n}\r\nISCSI_DBG_SESSION(conn->session, "data in with status done "\r\n"[sc %p res %d itt 0x%x]\n",\r\nsc, sc->result, task->itt);\r\nconn->scsirsp_pdus_cnt++;\r\niscsi_complete_task(task, ISCSI_TASK_COMPLETED);\r\n}\r\nstatic void iscsi_tmf_rsp(struct iscsi_conn *conn, struct iscsi_hdr *hdr)\r\n{\r\nstruct iscsi_tm_rsp *tmf = (struct iscsi_tm_rsp *)hdr;\r\nconn->exp_statsn = be32_to_cpu(hdr->statsn) + 1;\r\nconn->tmfrsp_pdus_cnt++;\r\nif (conn->tmf_state != TMF_QUEUED)\r\nreturn;\r\nif (tmf->response == ISCSI_TMF_RSP_COMPLETE)\r\nconn->tmf_state = TMF_SUCCESS;\r\nelse if (tmf->response == ISCSI_TMF_RSP_NO_TASK)\r\nconn->tmf_state = TMF_NOT_FOUND;\r\nelse\r\nconn->tmf_state = TMF_FAILED;\r\nwake_up(&conn->ehwait);\r\n}\r\nstatic void iscsi_send_nopout(struct iscsi_conn *conn, struct iscsi_nopin *rhdr)\r\n{\r\nstruct iscsi_nopout hdr;\r\nstruct iscsi_task *task;\r\nif (!rhdr && conn->ping_task)\r\nreturn;\r\nmemset(&hdr, 0, sizeof(struct iscsi_nopout));\r\nhdr.opcode = ISCSI_OP_NOOP_OUT | ISCSI_OP_IMMEDIATE;\r\nhdr.flags = ISCSI_FLAG_CMD_FINAL;\r\nif (rhdr) {\r\nhdr.lun = rhdr->lun;\r\nhdr.ttt = rhdr->ttt;\r\nhdr.itt = RESERVED_ITT;\r\n} else\r\nhdr.ttt = RESERVED_ITT;\r\ntask = __iscsi_conn_send_pdu(conn, (struct iscsi_hdr *)&hdr, NULL, 0);\r\nif (!task)\r\niscsi_conn_printk(KERN_ERR, conn, "Could not send nopout\n");\r\nelse if (!rhdr) {\r\nconn->ping_task = task;\r\nconn->last_ping = jiffies;\r\n}\r\n}\r\nstatic int iscsi_nop_out_rsp(struct iscsi_task *task,\r\nstruct iscsi_nopin *nop, char *data, int datalen)\r\n{\r\nstruct iscsi_conn *conn = task->conn;\r\nint rc = 0;\r\nif (conn->ping_task != task) {\r\nif (iscsi_recv_pdu(conn->cls_conn, (struct iscsi_hdr *)nop,\r\ndata, datalen))\r\nrc = ISCSI_ERR_CONN_FAILED;\r\n} else\r\nmod_timer(&conn->transport_timer, jiffies + conn->recv_timeout);\r\niscsi_complete_task(task, ISCSI_TASK_COMPLETED);\r\nreturn rc;\r\n}\r\nstatic int iscsi_handle_reject(struct iscsi_conn *conn, struct iscsi_hdr *hdr,\r\nchar *data, int datalen)\r\n{\r\nstruct iscsi_reject *reject = (struct iscsi_reject *)hdr;\r\nstruct iscsi_hdr rejected_pdu;\r\nint opcode, rc = 0;\r\nconn->exp_statsn = be32_to_cpu(reject->statsn) + 1;\r\nif (ntoh24(reject->dlength) > datalen ||\r\nntoh24(reject->dlength) < sizeof(struct iscsi_hdr)) {\r\niscsi_conn_printk(KERN_ERR, conn, "Cannot handle rejected "\r\n"pdu. Invalid data length (pdu dlength "\r\n"%u, datalen %d\n", ntoh24(reject->dlength),\r\ndatalen);\r\nreturn ISCSI_ERR_PROTO;\r\n}\r\nmemcpy(&rejected_pdu, data, sizeof(struct iscsi_hdr));\r\nopcode = rejected_pdu.opcode & ISCSI_OPCODE_MASK;\r\nswitch (reject->reason) {\r\ncase ISCSI_REASON_DATA_DIGEST_ERROR:\r\niscsi_conn_printk(KERN_ERR, conn,\r\n"pdu (op 0x%x itt 0x%x) rejected "\r\n"due to DataDigest error.\n",\r\nrejected_pdu.itt, opcode);\r\nbreak;\r\ncase ISCSI_REASON_IMM_CMD_REJECT:\r\niscsi_conn_printk(KERN_ERR, conn,\r\n"pdu (op 0x%x itt 0x%x) rejected. Too many "\r\n"immediate commands.\n",\r\nrejected_pdu.itt, opcode);\r\nif (opcode != ISCSI_OP_NOOP_OUT)\r\nreturn 0;\r\nif (rejected_pdu.itt == cpu_to_be32(ISCSI_RESERVED_TAG))\r\niscsi_send_nopout(conn,\r\n(struct iscsi_nopin*)&rejected_pdu);\r\nelse {\r\nstruct iscsi_task *task;\r\ntask = iscsi_itt_to_task(conn, rejected_pdu.itt);\r\nif (!task) {\r\niscsi_conn_printk(KERN_ERR, conn,\r\n"Invalid pdu reject. Could "\r\n"not lookup rejected task.\n");\r\nrc = ISCSI_ERR_BAD_ITT;\r\n} else\r\nrc = iscsi_nop_out_rsp(task,\r\n(struct iscsi_nopin*)&rejected_pdu,\r\nNULL, 0);\r\n}\r\nbreak;\r\ndefault:\r\niscsi_conn_printk(KERN_ERR, conn,\r\n"pdu (op 0x%x itt 0x%x) rejected. Reason "\r\n"code 0x%x\n", rejected_pdu.itt,\r\nrejected_pdu.opcode, reject->reason);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstruct iscsi_task *iscsi_itt_to_task(struct iscsi_conn *conn, itt_t itt)\r\n{\r\nstruct iscsi_session *session = conn->session;\r\nint i;\r\nif (itt == RESERVED_ITT)\r\nreturn NULL;\r\nif (session->tt->parse_pdu_itt)\r\nsession->tt->parse_pdu_itt(conn, itt, &i, NULL);\r\nelse\r\ni = get_itt(itt);\r\nif (i >= session->cmds_max)\r\nreturn NULL;\r\nreturn session->cmds[i];\r\n}\r\nint __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,\r\nchar *data, int datalen)\r\n{\r\nstruct iscsi_session *session = conn->session;\r\nint opcode = hdr->opcode & ISCSI_OPCODE_MASK, rc = 0;\r\nstruct iscsi_task *task;\r\nuint32_t itt;\r\nconn->last_recv = jiffies;\r\nrc = iscsi_verify_itt(conn, hdr->itt);\r\nif (rc)\r\nreturn rc;\r\nif (hdr->itt != RESERVED_ITT)\r\nitt = get_itt(hdr->itt);\r\nelse\r\nitt = ~0U;\r\nISCSI_DBG_SESSION(session, "[op 0x%x cid %d itt 0x%x len %d]\n",\r\nopcode, conn->id, itt, datalen);\r\nif (itt == ~0U) {\r\niscsi_update_cmdsn(session, (struct iscsi_nopin*)hdr);\r\nswitch(opcode) {\r\ncase ISCSI_OP_NOOP_IN:\r\nif (datalen) {\r\nrc = ISCSI_ERR_PROTO;\r\nbreak;\r\n}\r\nif (hdr->ttt == cpu_to_be32(ISCSI_RESERVED_TAG))\r\nbreak;\r\niscsi_send_nopout(conn, (struct iscsi_nopin*)hdr);\r\nbreak;\r\ncase ISCSI_OP_REJECT:\r\nrc = iscsi_handle_reject(conn, hdr, data, datalen);\r\nbreak;\r\ncase ISCSI_OP_ASYNC_EVENT:\r\nconn->exp_statsn = be32_to_cpu(hdr->statsn) + 1;\r\nif (iscsi_recv_pdu(conn->cls_conn, hdr, data, datalen))\r\nrc = ISCSI_ERR_CONN_FAILED;\r\nbreak;\r\ndefault:\r\nrc = ISCSI_ERR_BAD_OPCODE;\r\nbreak;\r\n}\r\ngoto out;\r\n}\r\nswitch(opcode) {\r\ncase ISCSI_OP_SCSI_CMD_RSP:\r\ncase ISCSI_OP_SCSI_DATA_IN:\r\ntask = iscsi_itt_to_ctask(conn, hdr->itt);\r\nif (!task)\r\nreturn ISCSI_ERR_BAD_ITT;\r\ntask->last_xfer = jiffies;\r\nbreak;\r\ncase ISCSI_OP_R2T:\r\nreturn 0;\r\ncase ISCSI_OP_LOGOUT_RSP:\r\ncase ISCSI_OP_LOGIN_RSP:\r\ncase ISCSI_OP_TEXT_RSP:\r\ncase ISCSI_OP_SCSI_TMFUNC_RSP:\r\ncase ISCSI_OP_NOOP_IN:\r\ntask = iscsi_itt_to_task(conn, hdr->itt);\r\nif (!task)\r\nreturn ISCSI_ERR_BAD_ITT;\r\nbreak;\r\ndefault:\r\nreturn ISCSI_ERR_BAD_OPCODE;\r\n}\r\nswitch(opcode) {\r\ncase ISCSI_OP_SCSI_CMD_RSP:\r\niscsi_scsi_cmd_rsp(conn, hdr, task, data, datalen);\r\nbreak;\r\ncase ISCSI_OP_SCSI_DATA_IN:\r\niscsi_data_in_rsp(conn, hdr, task);\r\nbreak;\r\ncase ISCSI_OP_LOGOUT_RSP:\r\niscsi_update_cmdsn(session, (struct iscsi_nopin*)hdr);\r\nif (datalen) {\r\nrc = ISCSI_ERR_PROTO;\r\nbreak;\r\n}\r\nconn->exp_statsn = be32_to_cpu(hdr->statsn) + 1;\r\ngoto recv_pdu;\r\ncase ISCSI_OP_LOGIN_RSP:\r\ncase ISCSI_OP_TEXT_RSP:\r\niscsi_update_cmdsn(session, (struct iscsi_nopin*)hdr);\r\ngoto recv_pdu;\r\ncase ISCSI_OP_SCSI_TMFUNC_RSP:\r\niscsi_update_cmdsn(session, (struct iscsi_nopin*)hdr);\r\nif (datalen) {\r\nrc = ISCSI_ERR_PROTO;\r\nbreak;\r\n}\r\niscsi_tmf_rsp(conn, hdr);\r\niscsi_complete_task(task, ISCSI_TASK_COMPLETED);\r\nbreak;\r\ncase ISCSI_OP_NOOP_IN:\r\niscsi_update_cmdsn(session, (struct iscsi_nopin*)hdr);\r\nif (hdr->ttt != cpu_to_be32(ISCSI_RESERVED_TAG) || datalen) {\r\nrc = ISCSI_ERR_PROTO;\r\nbreak;\r\n}\r\nconn->exp_statsn = be32_to_cpu(hdr->statsn) + 1;\r\nrc = iscsi_nop_out_rsp(task, (struct iscsi_nopin*)hdr,\r\ndata, datalen);\r\nbreak;\r\ndefault:\r\nrc = ISCSI_ERR_BAD_OPCODE;\r\nbreak;\r\n}\r\nout:\r\nreturn rc;\r\nrecv_pdu:\r\nif (iscsi_recv_pdu(conn->cls_conn, hdr, data, datalen))\r\nrc = ISCSI_ERR_CONN_FAILED;\r\niscsi_complete_task(task, ISCSI_TASK_COMPLETED);\r\nreturn rc;\r\n}\r\nint iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,\r\nchar *data, int datalen)\r\n{\r\nint rc;\r\nspin_lock(&conn->session->lock);\r\nrc = __iscsi_complete_pdu(conn, hdr, data, datalen);\r\nspin_unlock(&conn->session->lock);\r\nreturn rc;\r\n}\r\nint iscsi_verify_itt(struct iscsi_conn *conn, itt_t itt)\r\n{\r\nstruct iscsi_session *session = conn->session;\r\nint age = 0, i = 0;\r\nif (itt == RESERVED_ITT)\r\nreturn 0;\r\nif (session->tt->parse_pdu_itt)\r\nsession->tt->parse_pdu_itt(conn, itt, &i, &age);\r\nelse {\r\ni = get_itt(itt);\r\nage = ((__force u32)itt >> ISCSI_AGE_SHIFT) & ISCSI_AGE_MASK;\r\n}\r\nif (age != session->age) {\r\niscsi_conn_printk(KERN_ERR, conn,\r\n"received itt %x expected session age (%x)\n",\r\n(__force u32)itt, session->age);\r\nreturn ISCSI_ERR_BAD_ITT;\r\n}\r\nif (i >= session->cmds_max) {\r\niscsi_conn_printk(KERN_ERR, conn,\r\n"received invalid itt index %u (max cmds "\r\n"%u.\n", i, session->cmds_max);\r\nreturn ISCSI_ERR_BAD_ITT;\r\n}\r\nreturn 0;\r\n}\r\nstruct iscsi_task *iscsi_itt_to_ctask(struct iscsi_conn *conn, itt_t itt)\r\n{\r\nstruct iscsi_task *task;\r\nif (iscsi_verify_itt(conn, itt))\r\nreturn NULL;\r\ntask = iscsi_itt_to_task(conn, itt);\r\nif (!task || !task->sc)\r\nreturn NULL;\r\nif (task->sc->SCp.phase != conn->session->age) {\r\niscsi_session_printk(KERN_ERR, conn->session,\r\n"task's session age %d, expected %d\n",\r\ntask->sc->SCp.phase, conn->session->age);\r\nreturn NULL;\r\n}\r\nreturn task;\r\n}\r\nvoid iscsi_session_failure(struct iscsi_session *session,\r\nenum iscsi_err err)\r\n{\r\nstruct iscsi_conn *conn;\r\nstruct device *dev;\r\nspin_lock_bh(&session->lock);\r\nconn = session->leadconn;\r\nif (session->state == ISCSI_STATE_TERMINATE || !conn) {\r\nspin_unlock_bh(&session->lock);\r\nreturn;\r\n}\r\ndev = get_device(&conn->cls_conn->dev);\r\nspin_unlock_bh(&session->lock);\r\nif (!dev)\r\nreturn;\r\nif (err == ISCSI_ERR_INVALID_HOST)\r\niscsi_conn_error_event(conn->cls_conn, err);\r\nelse\r\niscsi_conn_failure(conn, err);\r\nput_device(dev);\r\n}\r\nvoid iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err)\r\n{\r\nstruct iscsi_session *session = conn->session;\r\nspin_lock_bh(&session->lock);\r\nif (session->state == ISCSI_STATE_FAILED) {\r\nspin_unlock_bh(&session->lock);\r\nreturn;\r\n}\r\nif (conn->stop_stage == 0)\r\nsession->state = ISCSI_STATE_FAILED;\r\nspin_unlock_bh(&session->lock);\r\nset_bit(ISCSI_SUSPEND_BIT, &conn->suspend_tx);\r\nset_bit(ISCSI_SUSPEND_BIT, &conn->suspend_rx);\r\niscsi_conn_error_event(conn->cls_conn, err);\r\n}\r\nstatic int iscsi_check_cmdsn_window_closed(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_session *session = conn->session;\r\nif (!iscsi_sna_lte(session->queued_cmdsn, session->max_cmdsn)) {\r\nISCSI_DBG_SESSION(session, "iSCSI CmdSN closed. ExpCmdSn "\r\n"%u MaxCmdSN %u CmdSN %u/%u\n",\r\nsession->exp_cmdsn, session->max_cmdsn,\r\nsession->cmdsn, session->queued_cmdsn);\r\nreturn -ENOSPC;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsi_xmit_task(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_task *task = conn->task;\r\nint rc;\r\nif (test_bit(ISCSI_SUSPEND_BIT, &conn->suspend_tx))\r\nreturn -ENODATA;\r\n__iscsi_get_task(task);\r\nspin_unlock_bh(&conn->session->lock);\r\nrc = conn->session->tt->xmit_task(task);\r\nspin_lock_bh(&conn->session->lock);\r\nif (!rc) {\r\ntask->last_xfer = jiffies;\r\nconn->task = NULL;\r\n}\r\n__iscsi_put_task(task);\r\nreturn rc;\r\n}\r\nvoid iscsi_requeue_task(struct iscsi_task *task)\r\n{\r\nstruct iscsi_conn *conn = task->conn;\r\nif (list_empty(&task->running))\r\nlist_add_tail(&task->running, &conn->requeue);\r\niscsi_conn_queue_work(conn);\r\n}\r\nstatic int iscsi_data_xmit(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_task *task;\r\nint rc = 0;\r\nspin_lock_bh(&conn->session->lock);\r\nif (test_bit(ISCSI_SUSPEND_BIT, &conn->suspend_tx)) {\r\nISCSI_DBG_SESSION(conn->session, "Tx suspended!\n");\r\nspin_unlock_bh(&conn->session->lock);\r\nreturn -ENODATA;\r\n}\r\nif (conn->task) {\r\nrc = iscsi_xmit_task(conn);\r\nif (rc)\r\ngoto done;\r\n}\r\ncheck_mgmt:\r\nwhile (!list_empty(&conn->mgmtqueue)) {\r\nconn->task = list_entry(conn->mgmtqueue.next,\r\nstruct iscsi_task, running);\r\nlist_del_init(&conn->task->running);\r\nif (iscsi_prep_mgmt_task(conn, conn->task)) {\r\n__iscsi_put_task(conn->task);\r\nconn->task = NULL;\r\ncontinue;\r\n}\r\nrc = iscsi_xmit_task(conn);\r\nif (rc)\r\ngoto done;\r\n}\r\nwhile (!list_empty(&conn->cmdqueue)) {\r\nconn->task = list_entry(conn->cmdqueue.next, struct iscsi_task,\r\nrunning);\r\nlist_del_init(&conn->task->running);\r\nif (conn->session->state == ISCSI_STATE_LOGGING_OUT) {\r\nfail_scsi_task(conn->task, DID_IMM_RETRY);\r\ncontinue;\r\n}\r\nrc = iscsi_prep_scsi_cmd_pdu(conn->task);\r\nif (rc) {\r\nif (rc == -ENOMEM || rc == -EACCES) {\r\nlist_add_tail(&conn->task->running,\r\n&conn->cmdqueue);\r\nconn->task = NULL;\r\ngoto done;\r\n} else\r\nfail_scsi_task(conn->task, DID_ABORT);\r\ncontinue;\r\n}\r\nrc = iscsi_xmit_task(conn);\r\nif (rc)\r\ngoto done;\r\nif (!list_empty(&conn->mgmtqueue))\r\ngoto check_mgmt;\r\n}\r\nwhile (!list_empty(&conn->requeue)) {\r\nif (conn->session->state == ISCSI_STATE_LOGGING_OUT)\r\nbreak;\r\ntask = list_entry(conn->requeue.next, struct iscsi_task,\r\nrunning);\r\nif (iscsi_check_tmf_restrictions(task, ISCSI_OP_SCSI_DATA_OUT))\r\nbreak;\r\nconn->task = task;\r\nlist_del_init(&conn->task->running);\r\nconn->task->state = ISCSI_TASK_RUNNING;\r\nrc = iscsi_xmit_task(conn);\r\nif (rc)\r\ngoto done;\r\nif (!list_empty(&conn->mgmtqueue))\r\ngoto check_mgmt;\r\n}\r\nspin_unlock_bh(&conn->session->lock);\r\nreturn -ENODATA;\r\ndone:\r\nspin_unlock_bh(&conn->session->lock);\r\nreturn rc;\r\n}\r\nstatic void iscsi_xmitworker(struct work_struct *work)\r\n{\r\nstruct iscsi_conn *conn =\r\ncontainer_of(work, struct iscsi_conn, xmitwork);\r\nint rc;\r\ndo {\r\nrc = iscsi_data_xmit(conn);\r\n} while (rc >= 0 || rc == -EAGAIN);\r\n}\r\nstatic inline struct iscsi_task *iscsi_alloc_task(struct iscsi_conn *conn,\r\nstruct scsi_cmnd *sc)\r\n{\r\nstruct iscsi_task *task;\r\nif (!kfifo_out(&conn->session->cmdpool.queue,\r\n(void *) &task, sizeof(void *)))\r\nreturn NULL;\r\nsc->SCp.phase = conn->session->age;\r\nsc->SCp.ptr = (char *) task;\r\natomic_set(&task->refcount, 1);\r\ntask->state = ISCSI_TASK_PENDING;\r\ntask->conn = conn;\r\ntask->sc = sc;\r\ntask->have_checked_conn = false;\r\ntask->last_timeout = jiffies;\r\ntask->last_xfer = jiffies;\r\nINIT_LIST_HEAD(&task->running);\r\nreturn task;\r\n}\r\nint iscsi_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *sc)\r\n{\r\nstruct iscsi_cls_session *cls_session;\r\nstruct iscsi_host *ihost;\r\nint reason = 0;\r\nstruct iscsi_session *session;\r\nstruct iscsi_conn *conn;\r\nstruct iscsi_task *task = NULL;\r\nsc->result = 0;\r\nsc->SCp.ptr = NULL;\r\nihost = shost_priv(host);\r\ncls_session = starget_to_session(scsi_target(sc->device));\r\nsession = cls_session->dd_data;\r\nspin_lock_bh(&session->lock);\r\nreason = iscsi_session_chkready(cls_session);\r\nif (reason) {\r\nsc->result = reason;\r\ngoto fault;\r\n}\r\nif (session->state != ISCSI_STATE_LOGGED_IN) {\r\nswitch (session->state) {\r\ncase ISCSI_STATE_FAILED:\r\ncase ISCSI_STATE_IN_RECOVERY:\r\nreason = FAILURE_SESSION_IN_RECOVERY;\r\nsc->result = DID_IMM_RETRY << 16;\r\nbreak;\r\ncase ISCSI_STATE_LOGGING_OUT:\r\nreason = FAILURE_SESSION_LOGGING_OUT;\r\nsc->result = DID_IMM_RETRY << 16;\r\nbreak;\r\ncase ISCSI_STATE_RECOVERY_FAILED:\r\nreason = FAILURE_SESSION_RECOVERY_TIMEOUT;\r\nsc->result = DID_TRANSPORT_FAILFAST << 16;\r\nbreak;\r\ncase ISCSI_STATE_TERMINATE:\r\nreason = FAILURE_SESSION_TERMINATE;\r\nsc->result = DID_NO_CONNECT << 16;\r\nbreak;\r\ndefault:\r\nreason = FAILURE_SESSION_FREED;\r\nsc->result = DID_NO_CONNECT << 16;\r\n}\r\ngoto fault;\r\n}\r\nconn = session->leadconn;\r\nif (!conn) {\r\nreason = FAILURE_SESSION_FREED;\r\nsc->result = DID_NO_CONNECT << 16;\r\ngoto fault;\r\n}\r\nif (test_bit(ISCSI_SUSPEND_BIT, &conn->suspend_tx)) {\r\nreason = FAILURE_SESSION_IN_RECOVERY;\r\nsc->result = DID_REQUEUE;\r\ngoto fault;\r\n}\r\nif (iscsi_check_cmdsn_window_closed(conn)) {\r\nreason = FAILURE_WINDOW_CLOSED;\r\ngoto reject;\r\n}\r\ntask = iscsi_alloc_task(conn, sc);\r\nif (!task) {\r\nreason = FAILURE_OOM;\r\ngoto reject;\r\n}\r\nif (!ihost->workq) {\r\nreason = iscsi_prep_scsi_cmd_pdu(task);\r\nif (reason) {\r\nif (reason == -ENOMEM || reason == -EACCES) {\r\nreason = FAILURE_OOM;\r\ngoto prepd_reject;\r\n} else {\r\nsc->result = DID_ABORT << 16;\r\ngoto prepd_fault;\r\n}\r\n}\r\nif (session->tt->xmit_task(task)) {\r\nsession->cmdsn--;\r\nreason = FAILURE_SESSION_NOT_READY;\r\ngoto prepd_reject;\r\n}\r\n} else {\r\nlist_add_tail(&task->running, &conn->cmdqueue);\r\niscsi_conn_queue_work(conn);\r\n}\r\nsession->queued_cmdsn++;\r\nspin_unlock_bh(&session->lock);\r\nreturn 0;\r\nprepd_reject:\r\niscsi_complete_task(task, ISCSI_TASK_REQUEUE_SCSIQ);\r\nreject:\r\nspin_unlock_bh(&session->lock);\r\nISCSI_DBG_SESSION(session, "cmd 0x%x rejected (%d)\n",\r\nsc->cmnd[0], reason);\r\nreturn SCSI_MLQUEUE_TARGET_BUSY;\r\nprepd_fault:\r\niscsi_complete_task(task, ISCSI_TASK_REQUEUE_SCSIQ);\r\nfault:\r\nspin_unlock_bh(&session->lock);\r\nISCSI_DBG_SESSION(session, "iscsi: cmd 0x%x is not queued (%d)\n",\r\nsc->cmnd[0], reason);\r\nif (!scsi_bidi_cmnd(sc))\r\nscsi_set_resid(sc, scsi_bufflen(sc));\r\nelse {\r\nscsi_out(sc)->resid = scsi_out(sc)->length;\r\nscsi_in(sc)->resid = scsi_in(sc)->length;\r\n}\r\nsc->scsi_done(sc);\r\nreturn 0;\r\n}\r\nint iscsi_change_queue_depth(struct scsi_device *sdev, int depth, int reason)\r\n{\r\nswitch (reason) {\r\ncase SCSI_QDEPTH_DEFAULT:\r\nscsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);\r\nbreak;\r\ncase SCSI_QDEPTH_QFULL:\r\nscsi_track_queue_full(sdev, depth);\r\nbreak;\r\ncase SCSI_QDEPTH_RAMP_UP:\r\nscsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn sdev->queue_depth;\r\n}\r\nint iscsi_target_alloc(struct scsi_target *starget)\r\n{\r\nstruct iscsi_cls_session *cls_session = starget_to_session(starget);\r\nstruct iscsi_session *session = cls_session->dd_data;\r\nstarget->can_queue = session->scsi_cmds_max;\r\nreturn 0;\r\n}\r\nstatic void iscsi_tmf_timedout(unsigned long data)\r\n{\r\nstruct iscsi_conn *conn = (struct iscsi_conn *)data;\r\nstruct iscsi_session *session = conn->session;\r\nspin_lock(&session->lock);\r\nif (conn->tmf_state == TMF_QUEUED) {\r\nconn->tmf_state = TMF_TIMEDOUT;\r\nISCSI_DBG_EH(session, "tmf timedout\n");\r\nwake_up(&conn->ehwait);\r\n}\r\nspin_unlock(&session->lock);\r\n}\r\nstatic int iscsi_exec_task_mgmt_fn(struct iscsi_conn *conn,\r\nstruct iscsi_tm *hdr, int age,\r\nint timeout)\r\n{\r\nstruct iscsi_session *session = conn->session;\r\nstruct iscsi_task *task;\r\ntask = __iscsi_conn_send_pdu(conn, (struct iscsi_hdr *)hdr,\r\nNULL, 0);\r\nif (!task) {\r\nspin_unlock_bh(&session->lock);\r\niscsi_conn_printk(KERN_ERR, conn, "Could not send TMF.\n");\r\niscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);\r\nspin_lock_bh(&session->lock);\r\nreturn -EPERM;\r\n}\r\nconn->tmfcmd_pdus_cnt++;\r\nconn->tmf_timer.expires = timeout * HZ + jiffies;\r\nconn->tmf_timer.function = iscsi_tmf_timedout;\r\nconn->tmf_timer.data = (unsigned long)conn;\r\nadd_timer(&conn->tmf_timer);\r\nISCSI_DBG_EH(session, "tmf set timeout\n");\r\nspin_unlock_bh(&session->lock);\r\nmutex_unlock(&session->eh_mutex);\r\nwait_event_interruptible(conn->ehwait, age != session->age ||\r\nsession->state != ISCSI_STATE_LOGGED_IN ||\r\nconn->tmf_state != TMF_QUEUED);\r\nif (signal_pending(current))\r\nflush_signals(current);\r\ndel_timer_sync(&conn->tmf_timer);\r\nmutex_lock(&session->eh_mutex);\r\nspin_lock_bh(&session->lock);\r\nif (age != session->age ||\r\nsession->state != ISCSI_STATE_LOGGED_IN)\r\nreturn -ENOTCONN;\r\nreturn 0;\r\n}\r\nstatic void fail_scsi_tasks(struct iscsi_conn *conn, unsigned lun,\r\nint error)\r\n{\r\nstruct iscsi_task *task;\r\nint i;\r\nfor (i = 0; i < conn->session->cmds_max; i++) {\r\ntask = conn->session->cmds[i];\r\nif (!task->sc || task->state == ISCSI_TASK_FREE)\r\ncontinue;\r\nif (lun != -1 && lun != task->sc->device->lun)\r\ncontinue;\r\nISCSI_DBG_SESSION(conn->session,\r\n"failing sc %p itt 0x%x state %d\n",\r\ntask->sc, task->itt, task->state);\r\nfail_scsi_task(task, error);\r\n}\r\n}\r\nvoid iscsi_suspend_queue(struct iscsi_conn *conn)\r\n{\r\nspin_lock_bh(&conn->session->lock);\r\nset_bit(ISCSI_SUSPEND_BIT, &conn->suspend_tx);\r\nspin_unlock_bh(&conn->session->lock);\r\n}\r\nvoid iscsi_suspend_tx(struct iscsi_conn *conn)\r\n{\r\nstruct Scsi_Host *shost = conn->session->host;\r\nstruct iscsi_host *ihost = shost_priv(shost);\r\nset_bit(ISCSI_SUSPEND_BIT, &conn->suspend_tx);\r\nif (ihost->workq)\r\nflush_workqueue(ihost->workq);\r\n}\r\nstatic void iscsi_start_tx(struct iscsi_conn *conn)\r\n{\r\nclear_bit(ISCSI_SUSPEND_BIT, &conn->suspend_tx);\r\niscsi_conn_queue_work(conn);\r\n}\r\nstatic int iscsi_has_ping_timed_out(struct iscsi_conn *conn)\r\n{\r\nif (conn->ping_task &&\r\ntime_before_eq(conn->last_recv + (conn->recv_timeout * HZ) +\r\n(conn->ping_timeout * HZ), jiffies))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic enum blk_eh_timer_return iscsi_eh_cmd_timed_out(struct scsi_cmnd *sc)\r\n{\r\nenum blk_eh_timer_return rc = BLK_EH_NOT_HANDLED;\r\nstruct iscsi_task *task = NULL, *running_task;\r\nstruct iscsi_cls_session *cls_session;\r\nstruct iscsi_session *session;\r\nstruct iscsi_conn *conn;\r\nint i;\r\ncls_session = starget_to_session(scsi_target(sc->device));\r\nsession = cls_session->dd_data;\r\nISCSI_DBG_EH(session, "scsi cmd %p timedout\n", sc);\r\nspin_lock(&session->lock);\r\ntask = (struct iscsi_task *)sc->SCp.ptr;\r\nif (!task) {\r\nrc = BLK_EH_HANDLED;\r\ngoto done;\r\n}\r\nif (session->state != ISCSI_STATE_LOGGED_IN) {\r\nrc = BLK_EH_RESET_TIMER;\r\ngoto done;\r\n}\r\nconn = session->leadconn;\r\nif (!conn) {\r\nrc = BLK_EH_RESET_TIMER;\r\ngoto done;\r\n}\r\nif (time_after(task->last_xfer, task->last_timeout)) {\r\nISCSI_DBG_EH(session, "Command making progress. Asking "\r\n"scsi-ml for more time to complete. "\r\n"Last data xfer at %lu. Last timeout was at "\r\n"%lu\n.", task->last_xfer, task->last_timeout);\r\ntask->have_checked_conn = false;\r\nrc = BLK_EH_RESET_TIMER;\r\ngoto done;\r\n}\r\nif (!conn->recv_timeout && !conn->ping_timeout)\r\ngoto done;\r\nif (iscsi_has_ping_timed_out(conn)) {\r\nrc = BLK_EH_RESET_TIMER;\r\ngoto done;\r\n}\r\nfor (i = 0; i < conn->session->cmds_max; i++) {\r\nrunning_task = conn->session->cmds[i];\r\nif (!running_task->sc || running_task == task ||\r\nrunning_task->state != ISCSI_TASK_RUNNING)\r\ncontinue;\r\nif (time_after(running_task->sc->jiffies_at_alloc,\r\ntask->sc->jiffies_at_alloc))\r\ncontinue;\r\nif (time_after(running_task->last_xfer, task->last_timeout)) {\r\nISCSI_DBG_EH(session, "Command has not made progress "\r\n"but commands ahead of it have. "\r\n"Asking scsi-ml for more time to "\r\n"complete. Our last xfer vs running task "\r\n"last xfer %lu/%lu. Last check %lu.\n",\r\ntask->last_xfer, running_task->last_xfer,\r\ntask->last_timeout);\r\nrc = BLK_EH_RESET_TIMER;\r\ngoto done;\r\n}\r\n}\r\nif (task->have_checked_conn)\r\ngoto done;\r\nif (conn->ping_task) {\r\ntask->have_checked_conn = true;\r\nrc = BLK_EH_RESET_TIMER;\r\ngoto done;\r\n}\r\niscsi_send_nopout(conn, NULL);\r\ntask->have_checked_conn = true;\r\nrc = BLK_EH_RESET_TIMER;\r\ndone:\r\nif (task)\r\ntask->last_timeout = jiffies;\r\nspin_unlock(&session->lock);\r\nISCSI_DBG_EH(session, "return %s\n", rc == BLK_EH_RESET_TIMER ?\r\n"timer reset" : "nh");\r\nreturn rc;\r\n}\r\nstatic void iscsi_check_transport_timeouts(unsigned long data)\r\n{\r\nstruct iscsi_conn *conn = (struct iscsi_conn *)data;\r\nstruct iscsi_session *session = conn->session;\r\nunsigned long recv_timeout, next_timeout = 0, last_recv;\r\nspin_lock(&session->lock);\r\nif (session->state != ISCSI_STATE_LOGGED_IN)\r\ngoto done;\r\nrecv_timeout = conn->recv_timeout;\r\nif (!recv_timeout)\r\ngoto done;\r\nrecv_timeout *= HZ;\r\nlast_recv = conn->last_recv;\r\nif (iscsi_has_ping_timed_out(conn)) {\r\niscsi_conn_printk(KERN_ERR, conn, "ping timeout of %d secs "\r\n"expired, recv timeout %d, last rx %lu, "\r\n"last ping %lu, now %lu\n",\r\nconn->ping_timeout, conn->recv_timeout,\r\nlast_recv, conn->last_ping, jiffies);\r\nspin_unlock(&session->lock);\r\niscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);\r\nreturn;\r\n}\r\nif (time_before_eq(last_recv + recv_timeout, jiffies)) {\r\nISCSI_DBG_CONN(conn, "Sending nopout as ping\n");\r\niscsi_send_nopout(conn, NULL);\r\nnext_timeout = conn->last_ping + (conn->ping_timeout * HZ);\r\n} else\r\nnext_timeout = last_recv + recv_timeout;\r\nISCSI_DBG_CONN(conn, "Setting next tmo %lu\n", next_timeout);\r\nmod_timer(&conn->transport_timer, next_timeout);\r\ndone:\r\nspin_unlock(&session->lock);\r\n}\r\nstatic void iscsi_prep_abort_task_pdu(struct iscsi_task *task,\r\nstruct iscsi_tm *hdr)\r\n{\r\nmemset(hdr, 0, sizeof(*hdr));\r\nhdr->opcode = ISCSI_OP_SCSI_TMFUNC | ISCSI_OP_IMMEDIATE;\r\nhdr->flags = ISCSI_TM_FUNC_ABORT_TASK & ISCSI_FLAG_TM_FUNC_MASK;\r\nhdr->flags |= ISCSI_FLAG_CMD_FINAL;\r\nhdr->lun = task->lun;\r\nhdr->rtt = task->hdr_itt;\r\nhdr->refcmdsn = task->cmdsn;\r\n}\r\nint iscsi_eh_abort(struct scsi_cmnd *sc)\r\n{\r\nstruct iscsi_cls_session *cls_session;\r\nstruct iscsi_session *session;\r\nstruct iscsi_conn *conn;\r\nstruct iscsi_task *task;\r\nstruct iscsi_tm *hdr;\r\nint rc, age;\r\ncls_session = starget_to_session(scsi_target(sc->device));\r\nsession = cls_session->dd_data;\r\nISCSI_DBG_EH(session, "aborting sc %p\n", sc);\r\nmutex_lock(&session->eh_mutex);\r\nspin_lock_bh(&session->lock);\r\nif (!sc->SCp.ptr) {\r\nISCSI_DBG_EH(session, "sc never reached iscsi layer or "\r\n"it completed.\n");\r\nspin_unlock_bh(&session->lock);\r\nmutex_unlock(&session->eh_mutex);\r\nreturn SUCCESS;\r\n}\r\nif (!session->leadconn || session->state != ISCSI_STATE_LOGGED_IN ||\r\nsc->SCp.phase != session->age) {\r\nspin_unlock_bh(&session->lock);\r\nmutex_unlock(&session->eh_mutex);\r\nISCSI_DBG_EH(session, "failing abort due to dropped "\r\n"session.\n");\r\nreturn FAILED;\r\n}\r\nconn = session->leadconn;\r\nconn->eh_abort_cnt++;\r\nage = session->age;\r\ntask = (struct iscsi_task *)sc->SCp.ptr;\r\nISCSI_DBG_EH(session, "aborting [sc %p itt 0x%x]\n",\r\nsc, task->itt);\r\nif (!task->sc) {\r\nISCSI_DBG_EH(session, "sc completed while abort in progress\n");\r\ngoto success;\r\n}\r\nif (task->state == ISCSI_TASK_PENDING) {\r\nfail_scsi_task(task, DID_ABORT);\r\ngoto success;\r\n}\r\nif (conn->tmf_state != TMF_INITIAL)\r\ngoto failed;\r\nconn->tmf_state = TMF_QUEUED;\r\nhdr = &conn->tmhdr;\r\niscsi_prep_abort_task_pdu(task, hdr);\r\nif (iscsi_exec_task_mgmt_fn(conn, hdr, age, session->abort_timeout)) {\r\nrc = FAILED;\r\ngoto failed;\r\n}\r\nswitch (conn->tmf_state) {\r\ncase TMF_SUCCESS:\r\nspin_unlock_bh(&session->lock);\r\niscsi_suspend_tx(conn);\r\nspin_lock_bh(&session->lock);\r\nfail_scsi_task(task, DID_ABORT);\r\nconn->tmf_state = TMF_INITIAL;\r\nmemset(hdr, 0, sizeof(*hdr));\r\nspin_unlock_bh(&session->lock);\r\niscsi_start_tx(conn);\r\ngoto success_unlocked;\r\ncase TMF_TIMEDOUT:\r\nspin_unlock_bh(&session->lock);\r\niscsi_conn_failure(conn, ISCSI_ERR_SCSI_EH_SESSION_RST);\r\ngoto failed_unlocked;\r\ncase TMF_NOT_FOUND:\r\nif (!sc->SCp.ptr) {\r\nconn->tmf_state = TMF_INITIAL;\r\nmemset(hdr, 0, sizeof(*hdr));\r\nISCSI_DBG_EH(session, "sc completed while abort in "\r\n"progress\n");\r\ngoto success;\r\n}\r\ndefault:\r\nconn->tmf_state = TMF_INITIAL;\r\ngoto failed;\r\n}\r\nsuccess:\r\nspin_unlock_bh(&session->lock);\r\nsuccess_unlocked:\r\nISCSI_DBG_EH(session, "abort success [sc %p itt 0x%x]\n",\r\nsc, task->itt);\r\nmutex_unlock(&session->eh_mutex);\r\nreturn SUCCESS;\r\nfailed:\r\nspin_unlock_bh(&session->lock);\r\nfailed_unlocked:\r\nISCSI_DBG_EH(session, "abort failed [sc %p itt 0x%x]\n", sc,\r\ntask ? task->itt : 0);\r\nmutex_unlock(&session->eh_mutex);\r\nreturn FAILED;\r\n}\r\nstatic void iscsi_prep_lun_reset_pdu(struct scsi_cmnd *sc, struct iscsi_tm *hdr)\r\n{\r\nmemset(hdr, 0, sizeof(*hdr));\r\nhdr->opcode = ISCSI_OP_SCSI_TMFUNC | ISCSI_OP_IMMEDIATE;\r\nhdr->flags = ISCSI_TM_FUNC_LOGICAL_UNIT_RESET & ISCSI_FLAG_TM_FUNC_MASK;\r\nhdr->flags |= ISCSI_FLAG_CMD_FINAL;\r\nint_to_scsilun(sc->device->lun, &hdr->lun);\r\nhdr->rtt = RESERVED_ITT;\r\n}\r\nint iscsi_eh_device_reset(struct scsi_cmnd *sc)\r\n{\r\nstruct iscsi_cls_session *cls_session;\r\nstruct iscsi_session *session;\r\nstruct iscsi_conn *conn;\r\nstruct iscsi_tm *hdr;\r\nint rc = FAILED;\r\ncls_session = starget_to_session(scsi_target(sc->device));\r\nsession = cls_session->dd_data;\r\nISCSI_DBG_EH(session, "LU Reset [sc %p lun %u]\n", sc, sc->device->lun);\r\nmutex_lock(&session->eh_mutex);\r\nspin_lock_bh(&session->lock);\r\nif (!session->leadconn || session->state != ISCSI_STATE_LOGGED_IN)\r\ngoto unlock;\r\nconn = session->leadconn;\r\nif (conn->tmf_state != TMF_INITIAL)\r\ngoto unlock;\r\nconn->tmf_state = TMF_QUEUED;\r\nhdr = &conn->tmhdr;\r\niscsi_prep_lun_reset_pdu(sc, hdr);\r\nif (iscsi_exec_task_mgmt_fn(conn, hdr, session->age,\r\nsession->lu_reset_timeout)) {\r\nrc = FAILED;\r\ngoto unlock;\r\n}\r\nswitch (conn->tmf_state) {\r\ncase TMF_SUCCESS:\r\nbreak;\r\ncase TMF_TIMEDOUT:\r\nspin_unlock_bh(&session->lock);\r\niscsi_conn_failure(conn, ISCSI_ERR_SCSI_EH_SESSION_RST);\r\ngoto done;\r\ndefault:\r\nconn->tmf_state = TMF_INITIAL;\r\ngoto unlock;\r\n}\r\nrc = SUCCESS;\r\nspin_unlock_bh(&session->lock);\r\niscsi_suspend_tx(conn);\r\nspin_lock_bh(&session->lock);\r\nmemset(hdr, 0, sizeof(*hdr));\r\nfail_scsi_tasks(conn, sc->device->lun, DID_ERROR);\r\nconn->tmf_state = TMF_INITIAL;\r\nspin_unlock_bh(&session->lock);\r\niscsi_start_tx(conn);\r\ngoto done;\r\nunlock:\r\nspin_unlock_bh(&session->lock);\r\ndone:\r\nISCSI_DBG_EH(session, "dev reset result = %s\n",\r\nrc == SUCCESS ? "SUCCESS" : "FAILED");\r\nmutex_unlock(&session->eh_mutex);\r\nreturn rc;\r\n}\r\nvoid iscsi_session_recovery_timedout(struct iscsi_cls_session *cls_session)\r\n{\r\nstruct iscsi_session *session = cls_session->dd_data;\r\nspin_lock_bh(&session->lock);\r\nif (session->state != ISCSI_STATE_LOGGED_IN) {\r\nsession->state = ISCSI_STATE_RECOVERY_FAILED;\r\nif (session->leadconn)\r\nwake_up(&session->leadconn->ehwait);\r\n}\r\nspin_unlock_bh(&session->lock);\r\n}\r\nint iscsi_eh_session_reset(struct scsi_cmnd *sc)\r\n{\r\nstruct iscsi_cls_session *cls_session;\r\nstruct iscsi_session *session;\r\nstruct iscsi_conn *conn;\r\ncls_session = starget_to_session(scsi_target(sc->device));\r\nsession = cls_session->dd_data;\r\nconn = session->leadconn;\r\nmutex_lock(&session->eh_mutex);\r\nspin_lock_bh(&session->lock);\r\nif (session->state == ISCSI_STATE_TERMINATE) {\r\nfailed:\r\nISCSI_DBG_EH(session,\r\n"failing session reset: Could not log back into "\r\n"%s, %s [age %d]\n", session->targetname,\r\nconn->persistent_address, session->age);\r\nspin_unlock_bh(&session->lock);\r\nmutex_unlock(&session->eh_mutex);\r\nreturn FAILED;\r\n}\r\nspin_unlock_bh(&session->lock);\r\nmutex_unlock(&session->eh_mutex);\r\niscsi_conn_failure(conn, ISCSI_ERR_SCSI_EH_SESSION_RST);\r\nISCSI_DBG_EH(session, "wait for relogin\n");\r\nwait_event_interruptible(conn->ehwait,\r\nsession->state == ISCSI_STATE_TERMINATE ||\r\nsession->state == ISCSI_STATE_LOGGED_IN ||\r\nsession->state == ISCSI_STATE_RECOVERY_FAILED);\r\nif (signal_pending(current))\r\nflush_signals(current);\r\nmutex_lock(&session->eh_mutex);\r\nspin_lock_bh(&session->lock);\r\nif (session->state == ISCSI_STATE_LOGGED_IN) {\r\nISCSI_DBG_EH(session,\r\n"session reset succeeded for %s,%s\n",\r\nsession->targetname, conn->persistent_address);\r\n} else\r\ngoto failed;\r\nspin_unlock_bh(&session->lock);\r\nmutex_unlock(&session->eh_mutex);\r\nreturn SUCCESS;\r\n}\r\nstatic void iscsi_prep_tgt_reset_pdu(struct scsi_cmnd *sc, struct iscsi_tm *hdr)\r\n{\r\nmemset(hdr, 0, sizeof(*hdr));\r\nhdr->opcode = ISCSI_OP_SCSI_TMFUNC | ISCSI_OP_IMMEDIATE;\r\nhdr->flags = ISCSI_TM_FUNC_TARGET_WARM_RESET & ISCSI_FLAG_TM_FUNC_MASK;\r\nhdr->flags |= ISCSI_FLAG_CMD_FINAL;\r\nhdr->rtt = RESERVED_ITT;\r\n}\r\nint iscsi_eh_target_reset(struct scsi_cmnd *sc)\r\n{\r\nstruct iscsi_cls_session *cls_session;\r\nstruct iscsi_session *session;\r\nstruct iscsi_conn *conn;\r\nstruct iscsi_tm *hdr;\r\nint rc = FAILED;\r\ncls_session = starget_to_session(scsi_target(sc->device));\r\nsession = cls_session->dd_data;\r\nISCSI_DBG_EH(session, "tgt Reset [sc %p tgt %s]\n", sc,\r\nsession->targetname);\r\nmutex_lock(&session->eh_mutex);\r\nspin_lock_bh(&session->lock);\r\nif (!session->leadconn || session->state != ISCSI_STATE_LOGGED_IN)\r\ngoto unlock;\r\nconn = session->leadconn;\r\nif (conn->tmf_state != TMF_INITIAL)\r\ngoto unlock;\r\nconn->tmf_state = TMF_QUEUED;\r\nhdr = &conn->tmhdr;\r\niscsi_prep_tgt_reset_pdu(sc, hdr);\r\nif (iscsi_exec_task_mgmt_fn(conn, hdr, session->age,\r\nsession->tgt_reset_timeout)) {\r\nrc = FAILED;\r\ngoto unlock;\r\n}\r\nswitch (conn->tmf_state) {\r\ncase TMF_SUCCESS:\r\nbreak;\r\ncase TMF_TIMEDOUT:\r\nspin_unlock_bh(&session->lock);\r\niscsi_conn_failure(conn, ISCSI_ERR_SCSI_EH_SESSION_RST);\r\ngoto done;\r\ndefault:\r\nconn->tmf_state = TMF_INITIAL;\r\ngoto unlock;\r\n}\r\nrc = SUCCESS;\r\nspin_unlock_bh(&session->lock);\r\niscsi_suspend_tx(conn);\r\nspin_lock_bh(&session->lock);\r\nmemset(hdr, 0, sizeof(*hdr));\r\nfail_scsi_tasks(conn, -1, DID_ERROR);\r\nconn->tmf_state = TMF_INITIAL;\r\nspin_unlock_bh(&session->lock);\r\niscsi_start_tx(conn);\r\ngoto done;\r\nunlock:\r\nspin_unlock_bh(&session->lock);\r\ndone:\r\nISCSI_DBG_EH(session, "tgt %s reset result = %s\n", session->targetname,\r\nrc == SUCCESS ? "SUCCESS" : "FAILED");\r\nmutex_unlock(&session->eh_mutex);\r\nreturn rc;\r\n}\r\nint iscsi_eh_recover_target(struct scsi_cmnd *sc)\r\n{\r\nint rc;\r\nrc = iscsi_eh_target_reset(sc);\r\nif (rc == FAILED)\r\nrc = iscsi_eh_session_reset(sc);\r\nreturn rc;\r\n}\r\nint\r\niscsi_pool_init(struct iscsi_pool *q, int max, void ***items, int item_size)\r\n{\r\nint i, num_arrays = 1;\r\nmemset(q, 0, sizeof(*q));\r\nq->max = max;\r\nif (items)\r\nnum_arrays++;\r\nq->pool = kzalloc(num_arrays * max * sizeof(void*), GFP_KERNEL);\r\nif (q->pool == NULL)\r\nreturn -ENOMEM;\r\nkfifo_init(&q->queue, (void*)q->pool, max * sizeof(void*));\r\nfor (i = 0; i < max; i++) {\r\nq->pool[i] = kzalloc(item_size, GFP_KERNEL);\r\nif (q->pool[i] == NULL) {\r\nq->max = i;\r\ngoto enomem;\r\n}\r\nkfifo_in(&q->queue, (void*)&q->pool[i], sizeof(void*));\r\n}\r\nif (items) {\r\n*items = q->pool + max;\r\nmemcpy(*items, q->pool, max * sizeof(void *));\r\n}\r\nreturn 0;\r\nenomem:\r\niscsi_pool_free(q);\r\nreturn -ENOMEM;\r\n}\r\nvoid iscsi_pool_free(struct iscsi_pool *q)\r\n{\r\nint i;\r\nfor (i = 0; i < q->max; i++)\r\nkfree(q->pool[i]);\r\nkfree(q->pool);\r\n}\r\nint iscsi_host_add(struct Scsi_Host *shost, struct device *pdev)\r\n{\r\nif (!shost->can_queue)\r\nshost->can_queue = ISCSI_DEF_XMIT_CMDS_MAX;\r\nif (!shost->cmd_per_lun)\r\nshost->cmd_per_lun = ISCSI_DEF_CMD_PER_LUN;\r\nif (!shost->transportt->eh_timed_out)\r\nshost->transportt->eh_timed_out = iscsi_eh_cmd_timed_out;\r\nreturn scsi_add_host(shost, pdev);\r\n}\r\nstruct Scsi_Host *iscsi_host_alloc(struct scsi_host_template *sht,\r\nint dd_data_size, bool xmit_can_sleep)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct iscsi_host *ihost;\r\nshost = scsi_host_alloc(sht, sizeof(struct iscsi_host) + dd_data_size);\r\nif (!shost)\r\nreturn NULL;\r\nihost = shost_priv(shost);\r\nif (xmit_can_sleep) {\r\nsnprintf(ihost->workq_name, sizeof(ihost->workq_name),\r\n"iscsi_q_%d", shost->host_no);\r\nihost->workq = create_singlethread_workqueue(ihost->workq_name);\r\nif (!ihost->workq)\r\ngoto free_host;\r\n}\r\nspin_lock_init(&ihost->lock);\r\nihost->state = ISCSI_HOST_SETUP;\r\nihost->num_sessions = 0;\r\ninit_waitqueue_head(&ihost->session_removal_wq);\r\nreturn shost;\r\nfree_host:\r\nscsi_host_put(shost);\r\nreturn NULL;\r\n}\r\nstatic void iscsi_notify_host_removed(struct iscsi_cls_session *cls_session)\r\n{\r\niscsi_session_failure(cls_session->dd_data, ISCSI_ERR_INVALID_HOST);\r\n}\r\nvoid iscsi_host_remove(struct Scsi_Host *shost)\r\n{\r\nstruct iscsi_host *ihost = shost_priv(shost);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ihost->lock, flags);\r\nihost->state = ISCSI_HOST_REMOVED;\r\nspin_unlock_irqrestore(&ihost->lock, flags);\r\niscsi_host_for_each_session(shost, iscsi_notify_host_removed);\r\nwait_event_interruptible(ihost->session_removal_wq,\r\nihost->num_sessions == 0);\r\nif (signal_pending(current))\r\nflush_signals(current);\r\nscsi_remove_host(shost);\r\nif (ihost->workq)\r\ndestroy_workqueue(ihost->workq);\r\n}\r\nvoid iscsi_host_free(struct Scsi_Host *shost)\r\n{\r\nstruct iscsi_host *ihost = shost_priv(shost);\r\nkfree(ihost->netdev);\r\nkfree(ihost->hwaddress);\r\nkfree(ihost->initiatorname);\r\nscsi_host_put(shost);\r\n}\r\nstatic void iscsi_host_dec_session_cnt(struct Scsi_Host *shost)\r\n{\r\nstruct iscsi_host *ihost = shost_priv(shost);\r\nunsigned long flags;\r\nshost = scsi_host_get(shost);\r\nif (!shost) {\r\nprintk(KERN_ERR "Invalid state. Cannot notify host removal "\r\n"of session teardown event because host already "\r\n"removed.\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&ihost->lock, flags);\r\nihost->num_sessions--;\r\nif (ihost->num_sessions == 0)\r\nwake_up(&ihost->session_removal_wq);\r\nspin_unlock_irqrestore(&ihost->lock, flags);\r\nscsi_host_put(shost);\r\n}\r\nstruct iscsi_cls_session *\r\niscsi_session_setup(struct iscsi_transport *iscsit, struct Scsi_Host *shost,\r\nuint16_t cmds_max, int dd_size, int cmd_task_size,\r\nuint32_t initial_cmdsn, unsigned int id)\r\n{\r\nstruct iscsi_host *ihost = shost_priv(shost);\r\nstruct iscsi_session *session;\r\nstruct iscsi_cls_session *cls_session;\r\nint cmd_i, scsi_cmds, total_cmds = cmds_max;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ihost->lock, flags);\r\nif (ihost->state == ISCSI_HOST_REMOVED) {\r\nspin_unlock_irqrestore(&ihost->lock, flags);\r\nreturn NULL;\r\n}\r\nihost->num_sessions++;\r\nspin_unlock_irqrestore(&ihost->lock, flags);\r\nif (!total_cmds)\r\ntotal_cmds = ISCSI_DEF_XMIT_CMDS_MAX;\r\nif (total_cmds < ISCSI_TOTAL_CMDS_MIN) {\r\nprintk(KERN_ERR "iscsi: invalid can_queue of %d. can_queue "\r\n"must be a power of two that is at least %d.\n",\r\ntotal_cmds, ISCSI_TOTAL_CMDS_MIN);\r\ngoto dec_session_count;\r\n}\r\nif (total_cmds > ISCSI_TOTAL_CMDS_MAX) {\r\nprintk(KERN_ERR "iscsi: invalid can_queue of %d. can_queue "\r\n"must be a power of 2 less than or equal to %d.\n",\r\ncmds_max, ISCSI_TOTAL_CMDS_MAX);\r\ntotal_cmds = ISCSI_TOTAL_CMDS_MAX;\r\n}\r\nif (!is_power_of_2(total_cmds)) {\r\nprintk(KERN_ERR "iscsi: invalid can_queue of %d. can_queue "\r\n"must be a power of 2.\n", total_cmds);\r\ntotal_cmds = rounddown_pow_of_two(total_cmds);\r\nif (total_cmds < ISCSI_TOTAL_CMDS_MIN)\r\nreturn NULL;\r\nprintk(KERN_INFO "iscsi: Rounding can_queue to %d.\n",\r\ntotal_cmds);\r\n}\r\nscsi_cmds = total_cmds - ISCSI_MGMT_CMDS_MAX;\r\ncls_session = iscsi_alloc_session(shost, iscsit,\r\nsizeof(struct iscsi_session) +\r\ndd_size);\r\nif (!cls_session)\r\ngoto dec_session_count;\r\nsession = cls_session->dd_data;\r\nsession->cls_session = cls_session;\r\nsession->host = shost;\r\nsession->state = ISCSI_STATE_FREE;\r\nsession->fast_abort = 1;\r\nsession->tgt_reset_timeout = 30;\r\nsession->lu_reset_timeout = 15;\r\nsession->abort_timeout = 10;\r\nsession->scsi_cmds_max = scsi_cmds;\r\nsession->cmds_max = total_cmds;\r\nsession->queued_cmdsn = session->cmdsn = initial_cmdsn;\r\nsession->exp_cmdsn = initial_cmdsn + 1;\r\nsession->max_cmdsn = initial_cmdsn + 1;\r\nsession->max_r2t = 1;\r\nsession->tt = iscsit;\r\nsession->dd_data = cls_session->dd_data + sizeof(*session);\r\nmutex_init(&session->eh_mutex);\r\nspin_lock_init(&session->lock);\r\nif (iscsi_pool_init(&session->cmdpool, session->cmds_max,\r\n(void***)&session->cmds,\r\ncmd_task_size + sizeof(struct iscsi_task)))\r\ngoto cmdpool_alloc_fail;\r\nfor (cmd_i = 0; cmd_i < session->cmds_max; cmd_i++) {\r\nstruct iscsi_task *task = session->cmds[cmd_i];\r\nif (cmd_task_size)\r\ntask->dd_data = &task[1];\r\ntask->itt = cmd_i;\r\ntask->state = ISCSI_TASK_FREE;\r\nINIT_LIST_HEAD(&task->running);\r\n}\r\nif (!try_module_get(iscsit->owner))\r\ngoto module_get_fail;\r\nif (iscsi_add_session(cls_session, id))\r\ngoto cls_session_fail;\r\nreturn cls_session;\r\ncls_session_fail:\r\nmodule_put(iscsit->owner);\r\nmodule_get_fail:\r\niscsi_pool_free(&session->cmdpool);\r\ncmdpool_alloc_fail:\r\niscsi_free_session(cls_session);\r\ndec_session_count:\r\niscsi_host_dec_session_cnt(shost);\r\nreturn NULL;\r\n}\r\nvoid iscsi_session_teardown(struct iscsi_cls_session *cls_session)\r\n{\r\nstruct iscsi_session *session = cls_session->dd_data;\r\nstruct module *owner = cls_session->transport->owner;\r\nstruct Scsi_Host *shost = session->host;\r\niscsi_pool_free(&session->cmdpool);\r\nkfree(session->password);\r\nkfree(session->password_in);\r\nkfree(session->username);\r\nkfree(session->username_in);\r\nkfree(session->targetname);\r\nkfree(session->targetalias);\r\nkfree(session->initiatorname);\r\nkfree(session->boot_root);\r\nkfree(session->boot_nic);\r\nkfree(session->boot_target);\r\nkfree(session->ifacename);\r\nkfree(session->portal_type);\r\nkfree(session->discovery_parent_type);\r\niscsi_destroy_session(cls_session);\r\niscsi_host_dec_session_cnt(shost);\r\nmodule_put(owner);\r\n}\r\nstruct iscsi_cls_conn *\r\niscsi_conn_setup(struct iscsi_cls_session *cls_session, int dd_size,\r\nuint32_t conn_idx)\r\n{\r\nstruct iscsi_session *session = cls_session->dd_data;\r\nstruct iscsi_conn *conn;\r\nstruct iscsi_cls_conn *cls_conn;\r\nchar *data;\r\ncls_conn = iscsi_create_conn(cls_session, sizeof(*conn) + dd_size,\r\nconn_idx);\r\nif (!cls_conn)\r\nreturn NULL;\r\nconn = cls_conn->dd_data;\r\nmemset(conn, 0, sizeof(*conn) + dd_size);\r\nconn->dd_data = cls_conn->dd_data + sizeof(*conn);\r\nconn->session = session;\r\nconn->cls_conn = cls_conn;\r\nconn->c_stage = ISCSI_CONN_INITIAL_STAGE;\r\nconn->id = conn_idx;\r\nconn->exp_statsn = 0;\r\nconn->tmf_state = TMF_INITIAL;\r\ninit_timer(&conn->transport_timer);\r\nconn->transport_timer.data = (unsigned long)conn;\r\nconn->transport_timer.function = iscsi_check_transport_timeouts;\r\nINIT_LIST_HEAD(&conn->mgmtqueue);\r\nINIT_LIST_HEAD(&conn->cmdqueue);\r\nINIT_LIST_HEAD(&conn->requeue);\r\nINIT_WORK(&conn->xmitwork, iscsi_xmitworker);\r\nspin_lock_bh(&session->lock);\r\nif (!kfifo_out(&session->cmdpool.queue,\r\n(void*)&conn->login_task,\r\nsizeof(void*))) {\r\nspin_unlock_bh(&session->lock);\r\ngoto login_task_alloc_fail;\r\n}\r\nspin_unlock_bh(&session->lock);\r\ndata = (char *) __get_free_pages(GFP_KERNEL,\r\nget_order(ISCSI_DEF_MAX_RECV_SEG_LEN));\r\nif (!data)\r\ngoto login_task_data_alloc_fail;\r\nconn->login_task->data = conn->data = data;\r\ninit_timer(&conn->tmf_timer);\r\ninit_waitqueue_head(&conn->ehwait);\r\nreturn cls_conn;\r\nlogin_task_data_alloc_fail:\r\nkfifo_in(&session->cmdpool.queue, (void*)&conn->login_task,\r\nsizeof(void*));\r\nlogin_task_alloc_fail:\r\niscsi_destroy_conn(cls_conn);\r\nreturn NULL;\r\n}\r\nvoid iscsi_conn_teardown(struct iscsi_cls_conn *cls_conn)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct iscsi_session *session = conn->session;\r\nunsigned long flags;\r\ndel_timer_sync(&conn->transport_timer);\r\nspin_lock_bh(&session->lock);\r\nconn->c_stage = ISCSI_CONN_CLEANUP_WAIT;\r\nif (session->leadconn == conn) {\r\nsession->state = ISCSI_STATE_TERMINATE;\r\nwake_up(&conn->ehwait);\r\n}\r\nspin_unlock_bh(&session->lock);\r\nfor (;;) {\r\nspin_lock_irqsave(session->host->host_lock, flags);\r\nif (!session->host->host_busy) {\r\nspin_unlock_irqrestore(session->host->host_lock, flags);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(session->host->host_lock, flags);\r\nmsleep_interruptible(500);\r\niscsi_conn_printk(KERN_INFO, conn, "iscsi conn_destroy(): "\r\n"host_busy %d host_failed %d\n",\r\nsession->host->host_busy,\r\nsession->host->host_failed);\r\nwake_up(&conn->ehwait);\r\n}\r\niscsi_suspend_tx(conn);\r\nspin_lock_bh(&session->lock);\r\nfree_pages((unsigned long) conn->data,\r\nget_order(ISCSI_DEF_MAX_RECV_SEG_LEN));\r\nkfree(conn->persistent_address);\r\nkfifo_in(&session->cmdpool.queue, (void*)&conn->login_task,\r\nsizeof(void*));\r\nif (session->leadconn == conn)\r\nsession->leadconn = NULL;\r\nspin_unlock_bh(&session->lock);\r\niscsi_destroy_conn(cls_conn);\r\n}\r\nint iscsi_conn_start(struct iscsi_cls_conn *cls_conn)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct iscsi_session *session = conn->session;\r\nif (!session) {\r\niscsi_conn_printk(KERN_ERR, conn,\r\n"can't start unbound connection\n");\r\nreturn -EPERM;\r\n}\r\nif ((session->imm_data_en || !session->initial_r2t_en) &&\r\nsession->first_burst > session->max_burst) {\r\niscsi_conn_printk(KERN_INFO, conn, "invalid burst lengths: "\r\n"first_burst %d max_burst %d\n",\r\nsession->first_burst, session->max_burst);\r\nreturn -EINVAL;\r\n}\r\nif (conn->ping_timeout && !conn->recv_timeout) {\r\niscsi_conn_printk(KERN_ERR, conn, "invalid recv timeout of "\r\n"zero. Using 5 seconds\n.");\r\nconn->recv_timeout = 5;\r\n}\r\nif (conn->recv_timeout && !conn->ping_timeout) {\r\niscsi_conn_printk(KERN_ERR, conn, "invalid ping timeout of "\r\n"zero. Using 5 seconds.\n");\r\nconn->ping_timeout = 5;\r\n}\r\nspin_lock_bh(&session->lock);\r\nconn->c_stage = ISCSI_CONN_STARTED;\r\nsession->state = ISCSI_STATE_LOGGED_IN;\r\nsession->queued_cmdsn = session->cmdsn;\r\nconn->last_recv = jiffies;\r\nconn->last_ping = jiffies;\r\nif (conn->recv_timeout && conn->ping_timeout)\r\nmod_timer(&conn->transport_timer,\r\njiffies + (conn->recv_timeout * HZ));\r\nswitch(conn->stop_stage) {\r\ncase STOP_CONN_RECOVER:\r\nconn->stop_stage = 0;\r\nconn->tmf_state = TMF_INITIAL;\r\nsession->age++;\r\nif (session->age == 16)\r\nsession->age = 0;\r\nbreak;\r\ncase STOP_CONN_TERM:\r\nconn->stop_stage = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock_bh(&session->lock);\r\niscsi_unblock_session(session->cls_session);\r\nwake_up(&conn->ehwait);\r\nreturn 0;\r\n}\r\nstatic void\r\nfail_mgmt_tasks(struct iscsi_session *session, struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_task *task;\r\nint i, state;\r\nfor (i = 0; i < conn->session->cmds_max; i++) {\r\ntask = conn->session->cmds[i];\r\nif (task->sc)\r\ncontinue;\r\nif (task->state == ISCSI_TASK_FREE)\r\ncontinue;\r\nISCSI_DBG_SESSION(conn->session,\r\n"failing mgmt itt 0x%x state %d\n",\r\ntask->itt, task->state);\r\nstate = ISCSI_TASK_ABRT_SESS_RECOV;\r\nif (task->state == ISCSI_TASK_PENDING)\r\nstate = ISCSI_TASK_COMPLETED;\r\niscsi_complete_task(task, state);\r\n}\r\n}\r\nstatic void iscsi_start_session_recovery(struct iscsi_session *session,\r\nstruct iscsi_conn *conn, int flag)\r\n{\r\nint old_stop_stage;\r\nmutex_lock(&session->eh_mutex);\r\nspin_lock_bh(&session->lock);\r\nif (conn->stop_stage == STOP_CONN_TERM) {\r\nspin_unlock_bh(&session->lock);\r\nmutex_unlock(&session->eh_mutex);\r\nreturn;\r\n}\r\nif (flag == STOP_CONN_TERM)\r\nsession->state = ISCSI_STATE_TERMINATE;\r\nelse if (conn->stop_stage != STOP_CONN_RECOVER)\r\nsession->state = ISCSI_STATE_IN_RECOVERY;\r\nold_stop_stage = conn->stop_stage;\r\nconn->stop_stage = flag;\r\nspin_unlock_bh(&session->lock);\r\ndel_timer_sync(&conn->transport_timer);\r\niscsi_suspend_tx(conn);\r\nspin_lock_bh(&session->lock);\r\nconn->c_stage = ISCSI_CONN_STOPPED;\r\nspin_unlock_bh(&session->lock);\r\nif (flag == STOP_CONN_RECOVER) {\r\nconn->hdrdgst_en = 0;\r\nconn->datadgst_en = 0;\r\nif (session->state == ISCSI_STATE_IN_RECOVERY &&\r\nold_stop_stage != STOP_CONN_RECOVER) {\r\nISCSI_DBG_SESSION(session, "blocking session\n");\r\niscsi_block_session(session->cls_session);\r\n}\r\n}\r\nspin_lock_bh(&session->lock);\r\nfail_scsi_tasks(conn, -1, DID_TRANSPORT_DISRUPTED);\r\nfail_mgmt_tasks(session, conn);\r\nmemset(&conn->tmhdr, 0, sizeof(conn->tmhdr));\r\nspin_unlock_bh(&session->lock);\r\nmutex_unlock(&session->eh_mutex);\r\n}\r\nvoid iscsi_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct iscsi_session *session = conn->session;\r\nswitch (flag) {\r\ncase STOP_CONN_RECOVER:\r\ncase STOP_CONN_TERM:\r\niscsi_start_session_recovery(session, conn, flag);\r\nbreak;\r\ndefault:\r\niscsi_conn_printk(KERN_ERR, conn,\r\n"invalid stop flag %d\n", flag);\r\n}\r\n}\r\nint iscsi_conn_bind(struct iscsi_cls_session *cls_session,\r\nstruct iscsi_cls_conn *cls_conn, int is_leading)\r\n{\r\nstruct iscsi_session *session = cls_session->dd_data;\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nspin_lock_bh(&session->lock);\r\nif (is_leading)\r\nsession->leadconn = conn;\r\nspin_unlock_bh(&session->lock);\r\nclear_bit(ISCSI_SUSPEND_BIT, &conn->suspend_rx);\r\nclear_bit(ISCSI_SUSPEND_BIT, &conn->suspend_tx);\r\nreturn 0;\r\n}\r\nint iscsi_switch_str_param(char **param, char *new_val_buf)\r\n{\r\nchar *new_val;\r\nif (*param) {\r\nif (!strcmp(*param, new_val_buf))\r\nreturn 0;\r\n}\r\nnew_val = kstrdup(new_val_buf, GFP_NOIO);\r\nif (!new_val)\r\nreturn -ENOMEM;\r\nkfree(*param);\r\n*param = new_val;\r\nreturn 0;\r\n}\r\nint iscsi_set_param(struct iscsi_cls_conn *cls_conn,\r\nenum iscsi_param param, char *buf, int buflen)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct iscsi_session *session = conn->session;\r\nint val;\r\nswitch(param) {\r\ncase ISCSI_PARAM_FAST_ABORT:\r\nsscanf(buf, "%d", &session->fast_abort);\r\nbreak;\r\ncase ISCSI_PARAM_ABORT_TMO:\r\nsscanf(buf, "%d", &session->abort_timeout);\r\nbreak;\r\ncase ISCSI_PARAM_LU_RESET_TMO:\r\nsscanf(buf, "%d", &session->lu_reset_timeout);\r\nbreak;\r\ncase ISCSI_PARAM_TGT_RESET_TMO:\r\nsscanf(buf, "%d", &session->tgt_reset_timeout);\r\nbreak;\r\ncase ISCSI_PARAM_PING_TMO:\r\nsscanf(buf, "%d", &conn->ping_timeout);\r\nbreak;\r\ncase ISCSI_PARAM_RECV_TMO:\r\nsscanf(buf, "%d", &conn->recv_timeout);\r\nbreak;\r\ncase ISCSI_PARAM_MAX_RECV_DLENGTH:\r\nsscanf(buf, "%d", &conn->max_recv_dlength);\r\nbreak;\r\ncase ISCSI_PARAM_MAX_XMIT_DLENGTH:\r\nsscanf(buf, "%d", &conn->max_xmit_dlength);\r\nbreak;\r\ncase ISCSI_PARAM_HDRDGST_EN:\r\nsscanf(buf, "%d", &conn->hdrdgst_en);\r\nbreak;\r\ncase ISCSI_PARAM_DATADGST_EN:\r\nsscanf(buf, "%d", &conn->datadgst_en);\r\nbreak;\r\ncase ISCSI_PARAM_INITIAL_R2T_EN:\r\nsscanf(buf, "%d", &session->initial_r2t_en);\r\nbreak;\r\ncase ISCSI_PARAM_MAX_R2T:\r\nsscanf(buf, "%hu", &session->max_r2t);\r\nbreak;\r\ncase ISCSI_PARAM_IMM_DATA_EN:\r\nsscanf(buf, "%d", &session->imm_data_en);\r\nbreak;\r\ncase ISCSI_PARAM_FIRST_BURST:\r\nsscanf(buf, "%d", &session->first_burst);\r\nbreak;\r\ncase ISCSI_PARAM_MAX_BURST:\r\nsscanf(buf, "%d", &session->max_burst);\r\nbreak;\r\ncase ISCSI_PARAM_PDU_INORDER_EN:\r\nsscanf(buf, "%d", &session->pdu_inorder_en);\r\nbreak;\r\ncase ISCSI_PARAM_DATASEQ_INORDER_EN:\r\nsscanf(buf, "%d", &session->dataseq_inorder_en);\r\nbreak;\r\ncase ISCSI_PARAM_ERL:\r\nsscanf(buf, "%d", &session->erl);\r\nbreak;\r\ncase ISCSI_PARAM_EXP_STATSN:\r\nsscanf(buf, "%u", &conn->exp_statsn);\r\nbreak;\r\ncase ISCSI_PARAM_USERNAME:\r\nreturn iscsi_switch_str_param(&session->username, buf);\r\ncase ISCSI_PARAM_USERNAME_IN:\r\nreturn iscsi_switch_str_param(&session->username_in, buf);\r\ncase ISCSI_PARAM_PASSWORD:\r\nreturn iscsi_switch_str_param(&session->password, buf);\r\ncase ISCSI_PARAM_PASSWORD_IN:\r\nreturn iscsi_switch_str_param(&session->password_in, buf);\r\ncase ISCSI_PARAM_TARGET_NAME:\r\nreturn iscsi_switch_str_param(&session->targetname, buf);\r\ncase ISCSI_PARAM_TARGET_ALIAS:\r\nreturn iscsi_switch_str_param(&session->targetalias, buf);\r\ncase ISCSI_PARAM_TPGT:\r\nsscanf(buf, "%d", &session->tpgt);\r\nbreak;\r\ncase ISCSI_PARAM_PERSISTENT_PORT:\r\nsscanf(buf, "%d", &conn->persistent_port);\r\nbreak;\r\ncase ISCSI_PARAM_PERSISTENT_ADDRESS:\r\nreturn iscsi_switch_str_param(&conn->persistent_address, buf);\r\ncase ISCSI_PARAM_IFACE_NAME:\r\nreturn iscsi_switch_str_param(&session->ifacename, buf);\r\ncase ISCSI_PARAM_INITIATOR_NAME:\r\nreturn iscsi_switch_str_param(&session->initiatorname, buf);\r\ncase ISCSI_PARAM_BOOT_ROOT:\r\nreturn iscsi_switch_str_param(&session->boot_root, buf);\r\ncase ISCSI_PARAM_BOOT_NIC:\r\nreturn iscsi_switch_str_param(&session->boot_nic, buf);\r\ncase ISCSI_PARAM_BOOT_TARGET:\r\nreturn iscsi_switch_str_param(&session->boot_target, buf);\r\ncase ISCSI_PARAM_PORTAL_TYPE:\r\nreturn iscsi_switch_str_param(&session->portal_type, buf);\r\ncase ISCSI_PARAM_DISCOVERY_PARENT_TYPE:\r\nreturn iscsi_switch_str_param(&session->discovery_parent_type,\r\nbuf);\r\ncase ISCSI_PARAM_DISCOVERY_SESS:\r\nsscanf(buf, "%d", &val);\r\nsession->discovery_sess = !!val;\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn 0;\r\n}\r\nint iscsi_session_get_param(struct iscsi_cls_session *cls_session,\r\nenum iscsi_param param, char *buf)\r\n{\r\nstruct iscsi_session *session = cls_session->dd_data;\r\nint len;\r\nswitch(param) {\r\ncase ISCSI_PARAM_FAST_ABORT:\r\nlen = sprintf(buf, "%d\n", session->fast_abort);\r\nbreak;\r\ncase ISCSI_PARAM_ABORT_TMO:\r\nlen = sprintf(buf, "%d\n", session->abort_timeout);\r\nbreak;\r\ncase ISCSI_PARAM_LU_RESET_TMO:\r\nlen = sprintf(buf, "%d\n", session->lu_reset_timeout);\r\nbreak;\r\ncase ISCSI_PARAM_TGT_RESET_TMO:\r\nlen = sprintf(buf, "%d\n", session->tgt_reset_timeout);\r\nbreak;\r\ncase ISCSI_PARAM_INITIAL_R2T_EN:\r\nlen = sprintf(buf, "%d\n", session->initial_r2t_en);\r\nbreak;\r\ncase ISCSI_PARAM_MAX_R2T:\r\nlen = sprintf(buf, "%hu\n", session->max_r2t);\r\nbreak;\r\ncase ISCSI_PARAM_IMM_DATA_EN:\r\nlen = sprintf(buf, "%d\n", session->imm_data_en);\r\nbreak;\r\ncase ISCSI_PARAM_FIRST_BURST:\r\nlen = sprintf(buf, "%u\n", session->first_burst);\r\nbreak;\r\ncase ISCSI_PARAM_MAX_BURST:\r\nlen = sprintf(buf, "%u\n", session->max_burst);\r\nbreak;\r\ncase ISCSI_PARAM_PDU_INORDER_EN:\r\nlen = sprintf(buf, "%d\n", session->pdu_inorder_en);\r\nbreak;\r\ncase ISCSI_PARAM_DATASEQ_INORDER_EN:\r\nlen = sprintf(buf, "%d\n", session->dataseq_inorder_en);\r\nbreak;\r\ncase ISCSI_PARAM_DEF_TASKMGMT_TMO:\r\nlen = sprintf(buf, "%d\n", session->def_taskmgmt_tmo);\r\nbreak;\r\ncase ISCSI_PARAM_ERL:\r\nlen = sprintf(buf, "%d\n", session->erl);\r\nbreak;\r\ncase ISCSI_PARAM_TARGET_NAME:\r\nlen = sprintf(buf, "%s\n", session->targetname);\r\nbreak;\r\ncase ISCSI_PARAM_TARGET_ALIAS:\r\nlen = sprintf(buf, "%s\n", session->targetalias);\r\nbreak;\r\ncase ISCSI_PARAM_TPGT:\r\nlen = sprintf(buf, "%d\n", session->tpgt);\r\nbreak;\r\ncase ISCSI_PARAM_USERNAME:\r\nlen = sprintf(buf, "%s\n", session->username);\r\nbreak;\r\ncase ISCSI_PARAM_USERNAME_IN:\r\nlen = sprintf(buf, "%s\n", session->username_in);\r\nbreak;\r\ncase ISCSI_PARAM_PASSWORD:\r\nlen = sprintf(buf, "%s\n", session->password);\r\nbreak;\r\ncase ISCSI_PARAM_PASSWORD_IN:\r\nlen = sprintf(buf, "%s\n", session->password_in);\r\nbreak;\r\ncase ISCSI_PARAM_IFACE_NAME:\r\nlen = sprintf(buf, "%s\n", session->ifacename);\r\nbreak;\r\ncase ISCSI_PARAM_INITIATOR_NAME:\r\nlen = sprintf(buf, "%s\n", session->initiatorname);\r\nbreak;\r\ncase ISCSI_PARAM_BOOT_ROOT:\r\nlen = sprintf(buf, "%s\n", session->boot_root);\r\nbreak;\r\ncase ISCSI_PARAM_BOOT_NIC:\r\nlen = sprintf(buf, "%s\n", session->boot_nic);\r\nbreak;\r\ncase ISCSI_PARAM_BOOT_TARGET:\r\nlen = sprintf(buf, "%s\n", session->boot_target);\r\nbreak;\r\ncase ISCSI_PARAM_AUTO_SND_TGT_DISABLE:\r\nlen = sprintf(buf, "%u\n", session->auto_snd_tgt_disable);\r\nbreak;\r\ncase ISCSI_PARAM_DISCOVERY_SESS:\r\nlen = sprintf(buf, "%u\n", session->discovery_sess);\r\nbreak;\r\ncase ISCSI_PARAM_PORTAL_TYPE:\r\nlen = sprintf(buf, "%s\n", session->portal_type);\r\nbreak;\r\ncase ISCSI_PARAM_CHAP_AUTH_EN:\r\nlen = sprintf(buf, "%u\n", session->chap_auth_en);\r\nbreak;\r\ncase ISCSI_PARAM_DISCOVERY_LOGOUT_EN:\r\nlen = sprintf(buf, "%u\n", session->discovery_logout_en);\r\nbreak;\r\ncase ISCSI_PARAM_BIDI_CHAP_EN:\r\nlen = sprintf(buf, "%u\n", session->bidi_chap_en);\r\nbreak;\r\ncase ISCSI_PARAM_DISCOVERY_AUTH_OPTIONAL:\r\nlen = sprintf(buf, "%u\n", session->discovery_auth_optional);\r\nbreak;\r\ncase ISCSI_PARAM_DEF_TIME2WAIT:\r\nlen = sprintf(buf, "%d\n", session->time2wait);\r\nbreak;\r\ncase ISCSI_PARAM_DEF_TIME2RETAIN:\r\nlen = sprintf(buf, "%d\n", session->time2retain);\r\nbreak;\r\ncase ISCSI_PARAM_TSID:\r\nlen = sprintf(buf, "%u\n", session->tsid);\r\nbreak;\r\ncase ISCSI_PARAM_ISID:\r\nlen = sprintf(buf, "%02x%02x%02x%02x%02x%02x\n",\r\nsession->isid[0], session->isid[1],\r\nsession->isid[2], session->isid[3],\r\nsession->isid[4], session->isid[5]);\r\nbreak;\r\ncase ISCSI_PARAM_DISCOVERY_PARENT_IDX:\r\nlen = sprintf(buf, "%u\n", session->discovery_parent_idx);\r\nbreak;\r\ncase ISCSI_PARAM_DISCOVERY_PARENT_TYPE:\r\nif (session->discovery_parent_type)\r\nlen = sprintf(buf, "%s\n",\r\nsession->discovery_parent_type);\r\nelse\r\nlen = sprintf(buf, "\n");\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn len;\r\n}\r\nint iscsi_conn_get_addr_param(struct sockaddr_storage *addr,\r\nenum iscsi_param param, char *buf)\r\n{\r\nstruct sockaddr_in6 *sin6 = NULL;\r\nstruct sockaddr_in *sin = NULL;\r\nint len;\r\nswitch (addr->ss_family) {\r\ncase AF_INET:\r\nsin = (struct sockaddr_in *)addr;\r\nbreak;\r\ncase AF_INET6:\r\nsin6 = (struct sockaddr_in6 *)addr;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (param) {\r\ncase ISCSI_PARAM_CONN_ADDRESS:\r\ncase ISCSI_HOST_PARAM_IPADDRESS:\r\nif (sin)\r\nlen = sprintf(buf, "%pI4\n", &sin->sin_addr.s_addr);\r\nelse\r\nlen = sprintf(buf, "%pI6\n", &sin6->sin6_addr);\r\nbreak;\r\ncase ISCSI_PARAM_CONN_PORT:\r\nif (sin)\r\nlen = sprintf(buf, "%hu\n", be16_to_cpu(sin->sin_port));\r\nelse\r\nlen = sprintf(buf, "%hu\n",\r\nbe16_to_cpu(sin6->sin6_port));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn len;\r\n}\r\nint iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,\r\nenum iscsi_param param, char *buf)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nint len;\r\nswitch(param) {\r\ncase ISCSI_PARAM_PING_TMO:\r\nlen = sprintf(buf, "%u\n", conn->ping_timeout);\r\nbreak;\r\ncase ISCSI_PARAM_RECV_TMO:\r\nlen = sprintf(buf, "%u\n", conn->recv_timeout);\r\nbreak;\r\ncase ISCSI_PARAM_MAX_RECV_DLENGTH:\r\nlen = sprintf(buf, "%u\n", conn->max_recv_dlength);\r\nbreak;\r\ncase ISCSI_PARAM_MAX_XMIT_DLENGTH:\r\nlen = sprintf(buf, "%u\n", conn->max_xmit_dlength);\r\nbreak;\r\ncase ISCSI_PARAM_HDRDGST_EN:\r\nlen = sprintf(buf, "%d\n", conn->hdrdgst_en);\r\nbreak;\r\ncase ISCSI_PARAM_DATADGST_EN:\r\nlen = sprintf(buf, "%d\n", conn->datadgst_en);\r\nbreak;\r\ncase ISCSI_PARAM_IFMARKER_EN:\r\nlen = sprintf(buf, "%d\n", conn->ifmarker_en);\r\nbreak;\r\ncase ISCSI_PARAM_OFMARKER_EN:\r\nlen = sprintf(buf, "%d\n", conn->ofmarker_en);\r\nbreak;\r\ncase ISCSI_PARAM_EXP_STATSN:\r\nlen = sprintf(buf, "%u\n", conn->exp_statsn);\r\nbreak;\r\ncase ISCSI_PARAM_PERSISTENT_PORT:\r\nlen = sprintf(buf, "%d\n", conn->persistent_port);\r\nbreak;\r\ncase ISCSI_PARAM_PERSISTENT_ADDRESS:\r\nlen = sprintf(buf, "%s\n", conn->persistent_address);\r\nbreak;\r\ncase ISCSI_PARAM_STATSN:\r\nlen = sprintf(buf, "%u\n", conn->statsn);\r\nbreak;\r\ncase ISCSI_PARAM_MAX_SEGMENT_SIZE:\r\nlen = sprintf(buf, "%u\n", conn->max_segment_size);\r\nbreak;\r\ncase ISCSI_PARAM_KEEPALIVE_TMO:\r\nlen = sprintf(buf, "%u\n", conn->keepalive_tmo);\r\nbreak;\r\ncase ISCSI_PARAM_LOCAL_PORT:\r\nlen = sprintf(buf, "%u\n", conn->local_port);\r\nbreak;\r\ncase ISCSI_PARAM_TCP_TIMESTAMP_STAT:\r\nlen = sprintf(buf, "%u\n", conn->tcp_timestamp_stat);\r\nbreak;\r\ncase ISCSI_PARAM_TCP_NAGLE_DISABLE:\r\nlen = sprintf(buf, "%u\n", conn->tcp_nagle_disable);\r\nbreak;\r\ncase ISCSI_PARAM_TCP_WSF_DISABLE:\r\nlen = sprintf(buf, "%u\n", conn->tcp_wsf_disable);\r\nbreak;\r\ncase ISCSI_PARAM_TCP_TIMER_SCALE:\r\nlen = sprintf(buf, "%u\n", conn->tcp_timer_scale);\r\nbreak;\r\ncase ISCSI_PARAM_TCP_TIMESTAMP_EN:\r\nlen = sprintf(buf, "%u\n", conn->tcp_timestamp_en);\r\nbreak;\r\ncase ISCSI_PARAM_IP_FRAGMENT_DISABLE:\r\nlen = sprintf(buf, "%u\n", conn->fragment_disable);\r\nbreak;\r\ncase ISCSI_PARAM_IPV4_TOS:\r\nlen = sprintf(buf, "%u\n", conn->ipv4_tos);\r\nbreak;\r\ncase ISCSI_PARAM_IPV6_TC:\r\nlen = sprintf(buf, "%u\n", conn->ipv6_traffic_class);\r\nbreak;\r\ncase ISCSI_PARAM_IPV6_FLOW_LABEL:\r\nlen = sprintf(buf, "%u\n", conn->ipv6_flow_label);\r\nbreak;\r\ncase ISCSI_PARAM_IS_FW_ASSIGNED_IPV6:\r\nlen = sprintf(buf, "%u\n", conn->is_fw_assigned_ipv6);\r\nbreak;\r\ncase ISCSI_PARAM_TCP_XMIT_WSF:\r\nlen = sprintf(buf, "%u\n", conn->tcp_xmit_wsf);\r\nbreak;\r\ncase ISCSI_PARAM_TCP_RECV_WSF:\r\nlen = sprintf(buf, "%u\n", conn->tcp_recv_wsf);\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn len;\r\n}\r\nint iscsi_host_get_param(struct Scsi_Host *shost, enum iscsi_host_param param,\r\nchar *buf)\r\n{\r\nstruct iscsi_host *ihost = shost_priv(shost);\r\nint len;\r\nswitch (param) {\r\ncase ISCSI_HOST_PARAM_NETDEV_NAME:\r\nlen = sprintf(buf, "%s\n", ihost->netdev);\r\nbreak;\r\ncase ISCSI_HOST_PARAM_HWADDRESS:\r\nlen = sprintf(buf, "%s\n", ihost->hwaddress);\r\nbreak;\r\ncase ISCSI_HOST_PARAM_INITIATOR_NAME:\r\nlen = sprintf(buf, "%s\n", ihost->initiatorname);\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn len;\r\n}\r\nint iscsi_host_set_param(struct Scsi_Host *shost, enum iscsi_host_param param,\r\nchar *buf, int buflen)\r\n{\r\nstruct iscsi_host *ihost = shost_priv(shost);\r\nswitch (param) {\r\ncase ISCSI_HOST_PARAM_NETDEV_NAME:\r\nreturn iscsi_switch_str_param(&ihost->netdev, buf);\r\ncase ISCSI_HOST_PARAM_HWADDRESS:\r\nreturn iscsi_switch_str_param(&ihost->hwaddress, buf);\r\ncase ISCSI_HOST_PARAM_INITIATOR_NAME:\r\nreturn iscsi_switch_str_param(&ihost->initiatorname, buf);\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn 0;\r\n}
