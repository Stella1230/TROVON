u8 rtw_validate_ssid(struct ndis_802_11_ssid *ssid)\r\n{\r\nu8 i;\r\nu8 ret = true;\r\n_func_enter_;\r\nif (ssid->SsidLength > 32) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("ssid length >32\n"));\r\nret = false;\r\ngoto exit;\r\n}\r\nfor (i = 0; i < ssid->SsidLength; i++) {\r\nif (!((ssid->Ssid[i] >= 0x20) && (ssid->Ssid[i] <= 0x7e))) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("ssid has nonprintabl ascii\n"));\r\nret = false;\r\nbreak;\r\n}\r\n}\r\nexit:\r\n_func_exit_;\r\nreturn ret;\r\n}\r\nu8 rtw_do_join(struct adapter *padapter)\r\n{\r\nunsigned long irqL;\r\nstruct list_head *plist, *phead;\r\nu8 *pibss = NULL;\r\nstruct mlme_priv *pmlmepriv = &(padapter->mlmepriv);\r\nstruct __queue *queue = &(pmlmepriv->scanned_queue);\r\nu8 ret = _SUCCESS;\r\n_func_enter_;\r\n_enter_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);\r\nphead = get_list_head(queue);\r\nplist = get_next(phead);\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("\n rtw_do_join: phead = %p; plist = %p\n\n\n", phead, plist));\r\npmlmepriv->cur_network.join_res = -2;\r\nset_fwstate(pmlmepriv, _FW_UNDER_LINKING);\r\npmlmepriv->pscanned = plist;\r\npmlmepriv->to_join = true;\r\nif (_rtw_queue_empty(queue)) {\r\n_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\r\nif (!pmlmepriv->LinkDetectInfo.bBusyTraffic ||\r\npmlmepriv->to_roaming > 0) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("rtw_do_join(): site survey if scanned_queue is empty\n."));\r\nret = rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0);\r\nif (_SUCCESS != ret) {\r\npmlmepriv->to_join = false;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("rtw_do_join(): site survey return error\n."));\r\n}\r\n} else {\r\npmlmepriv->to_join = false;\r\nret = _FAIL;\r\n}\r\ngoto exit;\r\n} else {\r\nint select_ret;\r\n_exit_critical_bh(&(pmlmepriv->scanned_queue.lock), &irqL);\r\nselect_ret = rtw_select_and_join_from_scanned_queue(pmlmepriv);\r\nif (select_ret == _SUCCESS) {\r\npmlmepriv->to_join = false;\r\n_set_timer(&pmlmepriv->assoc_timer, MAX_JOIN_TIMEOUT);\r\n} else {\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE) == true) {\r\nstruct wlan_bssid_ex *pdev_network = &(padapter->registrypriv.dev_network);\r\npmlmepriv->fw_state = WIFI_ADHOC_MASTER_STATE;\r\npibss = padapter->registrypriv.dev_network.MacAddress;\r\n_rtw_memset(&pdev_network->Ssid, 0, sizeof(struct ndis_802_11_ssid));\r\nmemcpy(&pdev_network->Ssid, &pmlmepriv->assoc_ssid, sizeof(struct ndis_802_11_ssid));\r\nrtw_update_registrypriv_dev_network(padapter);\r\nrtw_generate_random_ibss(pibss);\r\nif (rtw_createbss_cmd(padapter) != _SUCCESS) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("***Error =>do_goin: rtw_createbss_cmd status FAIL***\n "));\r\nret = false;\r\ngoto exit;\r\n}\r\npmlmepriv->to_join = false;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n("***Error => rtw_select_and_join_from_scanned_queue FAIL under STA_Mode***\n "));\r\n} else {\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\r\nif (!pmlmepriv->LinkDetectInfo.bBusyTraffic ||\r\npmlmepriv->to_roaming > 0) {\r\nret = rtw_sitesurvey_cmd(padapter, &pmlmepriv->assoc_ssid, 1, NULL, 0);\r\nif (_SUCCESS != ret) {\r\npmlmepriv->to_join = false;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("do_join(): site survey return error\n."));\r\n}\r\n} else {\r\nret = _FAIL;\r\npmlmepriv->to_join = false;\r\n}\r\n}\r\n}\r\n}\r\nexit:\r\n_func_exit_;\r\nreturn ret;\r\n}\r\nu8 rtw_set_802_11_bssid(struct adapter *padapter, u8 *bssid)\r\n{\r\nunsigned long irqL;\r\nu8 status = _SUCCESS;\r\nu32 cur_time = 0;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\n_func_enter_;\r\nDBG_88E_LEVEL(_drv_info_, "set bssid:%pM\n", bssid);\r\nif ((bssid[0] == 0x00 && bssid[1] == 0x00 && bssid[2] == 0x00 &&\r\nbssid[3] == 0x00 && bssid[4] == 0x00 && bssid[5] == 0x00) ||\r\n(bssid[0] == 0xFF && bssid[1] == 0xFF && bssid[2] == 0xFF &&\r\nbssid[3] == 0xFF && bssid[4] == 0xFF && bssid[5] == 0xFF)) {\r\nstatus = _FAIL;\r\ngoto exit;\r\n}\r\n_enter_critical_bh(&pmlmepriv->lock, &irqL);\r\nDBG_88E("Set BSSID under fw_state = 0x%08x\n", get_fwstate(pmlmepriv));\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true)\r\ngoto handle_tkip_countermeasure;\r\nelse if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING))\r\ngoto release_mlme_lock;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("set_bssid: _FW_LINKED||WIFI_ADHOC_MASTER_STATE\n"));\r\nif (_rtw_memcmp(&pmlmepriv->cur_network.network.MacAddress, bssid, ETH_ALEN)) {\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE) == false)\r\ngoto release_mlme_lock;\r\n} else {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("Set BSSID not the same bssid\n"));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("set_bssid =%pM\n", (bssid)));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("cur_bssid =%pM\n", (pmlmepriv->cur_network.network.MacAddress)));\r\nrtw_disassoc_cmd(padapter, 0, true);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == true)\r\nrtw_indicate_disconnect(padapter);\r\nrtw_free_assoc_resources(padapter, 1);\r\nif ((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true)) {\r\n_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);\r\nset_fwstate(pmlmepriv, WIFI_ADHOC_STATE);\r\n}\r\n}\r\n}\r\nhandle_tkip_countermeasure:\r\nif (padapter->securitypriv.btkip_countermeasure) {\r\ncur_time = rtw_get_current_time();\r\nif ((cur_time - padapter->securitypriv.btkip_countermeasure_time) > 60 * HZ) {\r\npadapter->securitypriv.btkip_countermeasure = false;\r\npadapter->securitypriv.btkip_countermeasure_time = 0;\r\n} else {\r\nstatus = _FAIL;\r\ngoto release_mlme_lock;\r\n}\r\n}\r\nmemcpy(&pmlmepriv->assoc_bssid, bssid, ETH_ALEN);\r\npmlmepriv->assoc_by_bssid = true;\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY))\r\npmlmepriv->to_join = true;\r\nelse\r\nstatus = rtw_do_join(padapter);\r\nrelease_mlme_lock:\r\n_exit_critical_bh(&pmlmepriv->lock, &irqL);\r\nexit:\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("rtw_set_802_11_bssid: status=%d\n", status));\r\n_func_exit_;\r\nreturn status;\r\n}\r\nu8 rtw_set_802_11_ssid(struct adapter *padapter, struct ndis_802_11_ssid *ssid)\r\n{\r\nunsigned long irqL;\r\nu8 status = _SUCCESS;\r\nu32 cur_time = 0;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_network *pnetwork = &pmlmepriv->cur_network;\r\n_func_enter_;\r\nDBG_88E_LEVEL(_drv_info_, "set ssid [%s] fw_state=0x%08x\n",\r\nssid->Ssid, get_fwstate(pmlmepriv));\r\nif (!padapter->hw_init_completed) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("set_ssid: hw_init_completed == false =>exit!!!\n"));\r\nstatus = _FAIL;\r\ngoto exit;\r\n}\r\n_enter_critical_bh(&pmlmepriv->lock, &irqL);\r\nDBG_88E("Set SSID under fw_state = 0x%08x\n", get_fwstate(pmlmepriv));\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {\r\ngoto handle_tkip_countermeasure;\r\n} else if (check_fwstate(pmlmepriv, _FW_UNDER_LINKING) == true) {\r\ngoto release_mlme_lock;\r\n}\r\nif (check_fwstate(pmlmepriv, _FW_LINKED|WIFI_ADHOC_MASTER_STATE)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n("set_ssid: _FW_LINKED||WIFI_ADHOC_MASTER_STATE\n"));\r\nif ((pmlmepriv->assoc_ssid.SsidLength == ssid->SsidLength) &&\r\n(_rtw_memcmp(&pmlmepriv->assoc_ssid.Ssid, ssid->Ssid, ssid->SsidLength))) {\r\nif ((check_fwstate(pmlmepriv, WIFI_STATION_STATE) == false)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("Set SSID is the same ssid, fw_state = 0x%08x\n",\r\nget_fwstate(pmlmepriv)));\r\nif (!rtw_is_same_ibss(padapter, pnetwork)) {\r\nrtw_disassoc_cmd(padapter, 0, true);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == true)\r\nrtw_indicate_disconnect(padapter);\r\nrtw_free_assoc_resources(padapter, 1);\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) {\r\n_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);\r\nset_fwstate(pmlmepriv, WIFI_ADHOC_STATE);\r\n}\r\n} else {\r\ngoto release_mlme_lock;\r\n}\r\n} else {\r\nrtw_lps_ctrl_wk_cmd(padapter, LPS_CTRL_JOINBSS, 1);\r\n}\r\n} else {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("Set SSID not the same ssid\n"));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("set_ssid =[%s] len = 0x%x\n", ssid->Ssid, (unsigned int)ssid->SsidLength));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("assoc_ssid =[%s] len = 0x%x\n", pmlmepriv->assoc_ssid.Ssid, (unsigned int)pmlmepriv->assoc_ssid.SsidLength));\r\nrtw_disassoc_cmd(padapter, 0, true);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == true)\r\nrtw_indicate_disconnect(padapter);\r\nrtw_free_assoc_resources(padapter, 1);\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) == true) {\r\n_clr_fwstate_(pmlmepriv, WIFI_ADHOC_MASTER_STATE);\r\nset_fwstate(pmlmepriv, WIFI_ADHOC_STATE);\r\n}\r\n}\r\n}\r\nhandle_tkip_countermeasure:\r\nif (padapter->securitypriv.btkip_countermeasure) {\r\ncur_time = rtw_get_current_time();\r\nif ((cur_time - padapter->securitypriv.btkip_countermeasure_time) > 60 * HZ) {\r\npadapter->securitypriv.btkip_countermeasure = false;\r\npadapter->securitypriv.btkip_countermeasure_time = 0;\r\n} else {\r\nstatus = _FAIL;\r\ngoto release_mlme_lock;\r\n}\r\n}\r\nmemcpy(&pmlmepriv->assoc_ssid, ssid, sizeof(struct ndis_802_11_ssid));\r\npmlmepriv->assoc_by_bssid = false;\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY) == true) {\r\npmlmepriv->to_join = true;\r\n} else {\r\nstatus = rtw_do_join(padapter);\r\n}\r\nrelease_mlme_lock:\r\n_exit_critical_bh(&pmlmepriv->lock, &irqL);\r\nexit:\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("-rtw_set_802_11_ssid: status =%d\n", status));\r\n_func_exit_;\r\nreturn status;\r\n}\r\nu8 rtw_set_802_11_infrastructure_mode(struct adapter *padapter,\r\nenum ndis_802_11_network_infra networktype)\r\n{\r\nunsigned long irqL;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_network *cur_network = &pmlmepriv->cur_network;\r\nenum ndis_802_11_network_infra *pold_state = &(cur_network->network.InfrastructureMode);\r\n_func_enter_;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_notice_,\r\n("+rtw_set_802_11_infrastructure_mode: old =%d new =%d fw_state = 0x%08x\n",\r\n*pold_state, networktype, get_fwstate(pmlmepriv)));\r\nif (*pold_state != networktype) {\r\n_enter_critical_bh(&pmlmepriv->lock, &irqL);\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, (" change mode!"));\r\nif (*pold_state == Ndis802_11APMode) {\r\ncur_network->join_res = -1;\r\n#ifdef CONFIG_88EU_AP_MODE\r\nstop_ap_mode(padapter);\r\n#endif\r\n}\r\nif ((check_fwstate(pmlmepriv, _FW_LINKED)) ||\r\n(*pold_state == Ndis802_11IBSS))\r\nrtw_disassoc_cmd(padapter, 0, true);\r\nif ((check_fwstate(pmlmepriv, _FW_LINKED)) ||\r\n(check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)))\r\nrtw_free_assoc_resources(padapter, 1);\r\nif ((*pold_state == Ndis802_11Infrastructure) || (*pold_state == Ndis802_11IBSS)) {\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == true)\r\nrtw_indicate_disconnect(padapter);\r\n}\r\n*pold_state = networktype;\r\n_clr_fwstate_(pmlmepriv, ~WIFI_NULL_STATE);\r\nswitch (networktype) {\r\ncase Ndis802_11IBSS:\r\nset_fwstate(pmlmepriv, WIFI_ADHOC_STATE);\r\nbreak;\r\ncase Ndis802_11Infrastructure:\r\nset_fwstate(pmlmepriv, WIFI_STATION_STATE);\r\nbreak;\r\ncase Ndis802_11APMode:\r\nset_fwstate(pmlmepriv, WIFI_AP_STATE);\r\n#ifdef CONFIG_88EU_AP_MODE\r\nstart_ap_mode(padapter);\r\n#endif\r\nbreak;\r\ncase Ndis802_11AutoUnknown:\r\ncase Ndis802_11InfrastructureMax:\r\nbreak;\r\n}\r\n_exit_critical_bh(&pmlmepriv->lock, &irqL);\r\n}\r\n_func_exit_;\r\nreturn true;\r\n}\r\nu8 rtw_set_802_11_disassociate(struct adapter *padapter)\r\n{\r\nunsigned long irqL;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\n_func_enter_;\r\n_enter_critical_bh(&pmlmepriv->lock, &irqL);\r\nif (check_fwstate(pmlmepriv, _FW_LINKED)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n("MgntActrtw_set_802_11_disassociate: rtw_indicate_disconnect\n"));\r\nrtw_disassoc_cmd(padapter, 0, true);\r\nrtw_indicate_disconnect(padapter);\r\nrtw_free_assoc_resources(padapter, 1);\r\nrtw_pwr_wakeup(padapter);\r\n}\r\n_exit_critical_bh(&pmlmepriv->lock, &irqL);\r\n_func_exit_;\r\nreturn true;\r\n}\r\nu8 rtw_set_802_11_bssid_list_scan(struct adapter *padapter, struct ndis_802_11_ssid *pssid, int ssid_max_num)\r\n{\r\nunsigned long irqL;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nu8 res = true;\r\n_func_enter_;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("+rtw_set_802_11_bssid_list_scan(), fw_state =%x\n", get_fwstate(pmlmepriv)));\r\nif (padapter == NULL) {\r\nres = false;\r\ngoto exit;\r\n}\r\nif (!padapter->hw_init_completed) {\r\nres = false;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("\n === rtw_set_802_11_bssid_list_scan:hw_init_completed == false ===\n"));\r\ngoto exit;\r\n}\r\nif ((check_fwstate(pmlmepriv, _FW_UNDER_SURVEY|_FW_UNDER_LINKING)) ||\r\n(pmlmepriv->LinkDetectInfo.bBusyTraffic)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("rtw_set_802_11_bssid_list_scan fail since fw_state = %x\n", get_fwstate(pmlmepriv)));\r\nres = true;\r\nif (check_fwstate(pmlmepriv, (_FW_UNDER_SURVEY|_FW_UNDER_LINKING)) == true) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("\n###_FW_UNDER_SURVEY|_FW_UNDER_LINKING\n\n"));\r\n} else {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("\n###pmlmepriv->sitesurveyctrl.traffic_busy == true\n\n"));\r\n}\r\n} else {\r\nif (rtw_is_scan_deny(padapter)) {\r\nDBG_88E(FUNC_ADPT_FMT": scan deny\n", FUNC_ADPT_ARG(padapter));\r\nindicate_wx_scan_complete_event(padapter);\r\nreturn _SUCCESS;\r\n}\r\n_enter_critical_bh(&pmlmepriv->lock, &irqL);\r\nres = rtw_sitesurvey_cmd(padapter, pssid, ssid_max_num, NULL, 0);\r\n_exit_critical_bh(&pmlmepriv->lock, &irqL);\r\n}\r\nexit:\r\n_func_exit_;\r\nreturn res;\r\n}\r\nu8 rtw_set_802_11_authentication_mode(struct adapter *padapter, enum ndis_802_11_auth_mode authmode)\r\n{\r\nstruct security_priv *psecuritypriv = &padapter->securitypriv;\r\nint res;\r\nu8 ret;\r\n_func_enter_;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("set_802_11_auth.mode(): mode =%x\n", authmode));\r\npsecuritypriv->ndisauthtype = authmode;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n("rtw_set_802_11_authentication_mode:psecuritypriv->ndisauthtype=%d",\r\npsecuritypriv->ndisauthtype));\r\nif (psecuritypriv->ndisauthtype > 3)\r\npsecuritypriv->dot11AuthAlgrthm = dot11AuthAlgrthm_8021X;\r\nres = rtw_set_auth(padapter, psecuritypriv);\r\nif (res == _SUCCESS)\r\nret = true;\r\nelse\r\nret = false;\r\n_func_exit_;\r\nreturn ret;\r\n}\r\nu8 rtw_set_802_11_add_wep(struct adapter *padapter, struct ndis_802_11_wep *wep)\r\n{\r\nint keyid, res;\r\nstruct security_priv *psecuritypriv = &(padapter->securitypriv);\r\nu8 ret = _SUCCESS;\r\n_func_enter_;\r\nkeyid = wep->KeyIndex & 0x3fffffff;\r\nif (keyid >= 4) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("MgntActrtw_set_802_11_add_wep:keyid>4 =>fail\n"));\r\nret = false;\r\ngoto exit;\r\n}\r\nswitch (wep->KeyLength) {\r\ncase 5:\r\npsecuritypriv->dot11PrivacyAlgrthm = _WEP40_;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("MgntActrtw_set_802_11_add_wep:wep->KeyLength = 5\n"));\r\nbreak;\r\ncase 13:\r\npsecuritypriv->dot11PrivacyAlgrthm = _WEP104_;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("MgntActrtw_set_802_11_add_wep:wep->KeyLength = 13\n"));\r\nbreak;\r\ndefault:\r\npsecuritypriv->dot11PrivacyAlgrthm = _NO_PRIVACY_;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_, ("MgntActrtw_set_802_11_add_wep:wep->KeyLength!= 5 or 13\n"));\r\nbreak;\r\n}\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n("rtw_set_802_11_add_wep:befor memcpy, wep->KeyLength = 0x%x wep->KeyIndex = 0x%x keyid =%x\n",\r\nwep->KeyLength, wep->KeyIndex, keyid));\r\nmemcpy(&(psecuritypriv->dot11DefKey[keyid].skey[0]), &(wep->KeyMaterial), wep->KeyLength);\r\npsecuritypriv->dot11DefKeylen[keyid] = wep->KeyLength;\r\npsecuritypriv->dot11PrivacyKeyIndex = keyid;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n("rtw_set_802_11_add_wep:security key material : %x %x %x %x %x %x %x %x %x %x %x %x %x\n",\r\npsecuritypriv->dot11DefKey[keyid].skey[0],\r\npsecuritypriv->dot11DefKey[keyid].skey[1],\r\npsecuritypriv->dot11DefKey[keyid].skey[2],\r\npsecuritypriv->dot11DefKey[keyid].skey[3],\r\npsecuritypriv->dot11DefKey[keyid].skey[4],\r\npsecuritypriv->dot11DefKey[keyid].skey[5],\r\npsecuritypriv->dot11DefKey[keyid].skey[6],\r\npsecuritypriv->dot11DefKey[keyid].skey[7],\r\npsecuritypriv->dot11DefKey[keyid].skey[8],\r\npsecuritypriv->dot11DefKey[keyid].skey[9],\r\npsecuritypriv->dot11DefKey[keyid].skey[10],\r\npsecuritypriv->dot11DefKey[keyid].skey[11],\r\npsecuritypriv->dot11DefKey[keyid].skey[12]));\r\nres = rtw_set_key(padapter, psecuritypriv, keyid, 1);\r\nif (res == _FAIL)\r\nret = false;\r\nexit:\r\n_func_exit_;\r\nreturn ret;\r\n}\r\nu8 rtw_set_802_11_remove_wep(struct adapter *padapter, u32 keyindex)\r\n{\r\nu8 ret = _SUCCESS;\r\n_func_enter_;\r\nif (keyindex >= 0x80000000 || padapter == NULL) {\r\nret = false;\r\ngoto exit;\r\n} else {\r\nint res;\r\nstruct security_priv *psecuritypriv = &(padapter->securitypriv);\r\nif (keyindex < 4) {\r\n_rtw_memset(&psecuritypriv->dot11DefKey[keyindex], 0, 16);\r\nres = rtw_set_key(padapter, psecuritypriv, keyindex, 0);\r\npsecuritypriv->dot11DefKeylen[keyindex] = 0;\r\nif (res == _FAIL)\r\nret = _FAIL;\r\n} else {\r\nret = _FAIL;\r\n}\r\n}\r\nexit:\r\n_func_exit_;\r\nreturn ret;\r\n}\r\nu8 rtw_set_802_11_add_key(struct adapter *padapter, struct ndis_802_11_key *key)\r\n{\r\nuint encryptionalgo;\r\nu8 *pbssid;\r\nstruct sta_info *stainfo;\r\nu8 bgroup = false;\r\nu8 bgrouptkey = false;\r\nu8 ret = _SUCCESS;\r\n_func_enter_;\r\nif (((key->KeyIndex & 0x80000000) == 0) && ((key->KeyIndex & 0x40000000) > 0)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n("rtw_set_802_11_add_key: ((key->KeyIndex & 0x80000000)==0)[=%d]",\r\n(int)(key->KeyIndex & 0x80000000) == 0));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n("rtw_set_802_11_add_key:((key->KeyIndex & 0x40000000)>0)[=%d]",\r\n(int)(key->KeyIndex & 0x40000000) > 0));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_info_,\r\n("rtw_set_802_11_add_key: key->KeyIndex=%d\n",\r\n(int)key->KeyIndex));\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nif (key->KeyIndex & 0x40000000) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("OID_802_11_ADD_KEY: +++++ Pairwise key +++++\n"));\r\npbssid = get_bssid(&padapter->mlmepriv);\r\nstainfo = rtw_get_stainfo(&padapter->stapriv, pbssid);\r\nif ((stainfo != NULL) && (padapter->securitypriv.dot11AuthAlgrthm == dot11AuthAlgrthm_8021X)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("OID_802_11_ADD_KEY:(stainfo!=NULL)&&(Adapter->securitypriv.dot11AuthAlgrthm==dot11AuthAlgrthm_8021X)\n"));\r\nencryptionalgo = stainfo->dot118021XPrivacy;\r\n} else {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("OID_802_11_ADD_KEY: stainfo == NULL)||(Adapter->securitypriv.dot11AuthAlgrthm!= dot11AuthAlgrthm_8021X)\n"));\r\nencryptionalgo = padapter->securitypriv.dot11PrivacyAlgrthm;\r\n}\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("rtw_set_802_11_add_key: (encryptionalgo==%d)!\n",\r\nencryptionalgo));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("rtw_set_802_11_add_key: (Adapter->securitypriv.dot11PrivacyAlgrthm==%d)!\n",\r\npadapter->securitypriv.dot11PrivacyAlgrthm));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("rtw_set_802_11_add_key: (Adapter->securitypriv.dot11AuthAlgrthm==%d)!\n",\r\npadapter->securitypriv.dot11AuthAlgrthm));\r\nif ((stainfo != NULL))\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("rtw_set_802_11_add_key: (stainfo->dot118021XPrivacy==%d)!\n",\r\nstainfo->dot118021XPrivacy));\r\nif (key->KeyIndex & 0x000000FF) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, (" key->KeyIndex & 0x000000FF.\n"));\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nif (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == true) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("MacAddr_isBcst(key->BSSID)\n"));\r\nret = false;\r\ngoto exit;\r\n}\r\nif ((encryptionalgo == _TKIP_) && (key->KeyLength != 32)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("TKIP KeyLength:0x%x != 32\n", key->KeyLength));\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nif ((encryptionalgo == _AES_) && (key->KeyLength != 16)) {\r\nif (key->KeyLength == 32) {\r\nkey->KeyLength = 16;\r\n} else {\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\n}\r\nif ((encryptionalgo == _WEP40_ || encryptionalgo == _WEP104_) &&\r\n(key->KeyLength != 5 && key->KeyLength != 13)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("WEP KeyLength:0x%x != 5 or 13\n", key->KeyLength));\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nbgroup = false;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("------------------------------------------\n"));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("[Pairwise Key set]\n"));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("------------------------------------------\n"));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("key index: 0x%8x(0x%8x)\n", key->KeyIndex, (key->KeyIndex&0x3)));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("key Length: %d\n", key->KeyLength));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("------------------------------------------\n"));\r\n} else {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("OID_802_11_ADD_KEY: +++++ Group key +++++\n"));\r\nif ((padapter->securitypriv.ndisauthtype <= 3) &&\r\n(padapter->securitypriv.dot118021XGrpPrivacy == 0)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("keylen =%d(Adapter->securitypriv.dot11PrivacyAlgrthm=%x )padapter->securitypriv.dot118021XGrpPrivacy(%x)\n",\r\nkey->KeyLength, padapter->securitypriv.dot11PrivacyAlgrthm,\r\npadapter->securitypriv.dot118021XGrpPrivacy));\r\nswitch (key->KeyLength) {\r\ncase 5:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _WEP40_;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("Adapter->securitypriv.dot11PrivacyAlgrthm=%x key->KeyLength=%u\n",\r\npadapter->securitypriv.dot11PrivacyAlgrthm, key->KeyLength));\r\nbreak;\r\ncase 13:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _WEP104_;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("Adapter->securitypriv.dot11PrivacyAlgrthm=%x key->KeyLength=%u\n",\r\npadapter->securitypriv.dot11PrivacyAlgrthm, key->KeyLength));\r\nbreak;\r\ndefault:\r\npadapter->securitypriv.dot11PrivacyAlgrthm = _NO_PRIVACY_;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("Adapter->securitypriv.dot11PrivacyAlgrthm=%x key->KeyLength=%u\n",\r\npadapter->securitypriv.dot11PrivacyAlgrthm, key->KeyLength));\r\nbreak;\r\n}\r\nencryptionalgo = padapter->securitypriv.dot11PrivacyAlgrthm;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n(" Adapter->securitypriv.dot11PrivacyAlgrthm=%x\n",\r\npadapter->securitypriv.dot11PrivacyAlgrthm));\r\n} else {\r\nencryptionalgo = padapter->securitypriv.dot118021XGrpPrivacy;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("(Adapter->securitypriv.dot11PrivacyAlgrthm=%x)encryptionalgo(%x)=padapter->securitypriv.dot118021XGrpPrivacy(%x)keylen=%d\n",\r\npadapter->securitypriv.dot11PrivacyAlgrthm, encryptionalgo,\r\npadapter->securitypriv.dot118021XGrpPrivacy, key->KeyLength));\r\n}\r\nif ((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE) == true) && (IS_MAC_ADDRESS_BROADCAST(key->BSSID) == false)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n(" IBSS but BSSID is not Broadcast Address.\n"));\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nif ((encryptionalgo == _TKIP_) && (key->KeyLength != 32)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n(" TKIP GTK KeyLength:%u != 32\n", key->KeyLength));\r\nret = _FAIL;\r\ngoto exit;\r\n} else if (encryptionalgo == _AES_ && (key->KeyLength != 16 && key->KeyLength != 32)) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("<=== SetInfo, OID_802_11_ADD_KEY: AES GTK KeyLength:%u != 16 or 32\n",\r\nkey->KeyLength));\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nif ((encryptionalgo == _AES_) && (key->KeyLength == 32)) {\r\nkey->KeyLength = 16;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("AES key length changed: %u\n", key->KeyLength));\r\n}\r\nif (key->KeyIndex & 0x8000000) {\r\nbgrouptkey = true;\r\n}\r\nif ((check_fwstate(&padapter->mlmepriv, WIFI_ADHOC_STATE)) &&\r\n(check_fwstate(&padapter->mlmepriv, _FW_LINKED)))\r\nbgrouptkey = true;\r\nbgroup = true;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("------------------------------------------\n"));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("[Group Key set]\n"));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("------------------------------------------\n")) ;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("key index: 0x%8x(0x%8x)\n", key->KeyIndex, (key->KeyIndex&0x3)));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("key Length: %d\n", key->KeyLength)) ;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("------------------------------------------\n"));\r\n}\r\nif ((padapter->securitypriv.dot11AuthAlgrthm != dot11AuthAlgrthm_8021X) &&\r\n(encryptionalgo == _WEP40_ || encryptionalgo == _WEP104_)) {\r\nu32 keyindex;\r\nu32 len = FIELD_OFFSET(struct ndis_802_11_key, KeyMaterial) + key->KeyLength;\r\nstruct ndis_802_11_wep *wep = &padapter->securitypriv.ndiswep;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("OID_802_11_ADD_KEY: +++++ WEP key +++++\n"));\r\nwep->Length = len;\r\nkeyindex = key->KeyIndex&0x7fffffff;\r\nwep->KeyIndex = keyindex ;\r\nwep->KeyLength = key->KeyLength;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("OID_802_11_ADD_KEY:Before memcpy\n"));\r\nmemcpy(wep->KeyMaterial, key->KeyMaterial, key->KeyLength);\r\nmemcpy(&(padapter->securitypriv.dot11DefKey[keyindex].skey[0]), key->KeyMaterial, key->KeyLength);\r\npadapter->securitypriv.dot11DefKeylen[keyindex] = key->KeyLength;\r\npadapter->securitypriv.dot11PrivacyKeyIndex = keyindex;\r\nret = rtw_set_802_11_add_wep(padapter, wep);\r\ngoto exit;\r\n}\r\nif (key->KeyIndex & 0x20000000) {\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("OID_802_11_ADD_KEY: +++++ SetRSC+++++\n"));\r\nif (bgroup) {\r\nunsigned long long keysrc = key->KeyRSC & 0x00FFFFFFFFFFFFULL;\r\nmemcpy(&padapter->securitypriv.dot11Grprxpn, &keysrc, 8);\r\n} else {\r\nunsigned long long keysrc = key->KeyRSC & 0x00FFFFFFFFFFFFULL;\r\nmemcpy(&padapter->securitypriv.dot11Grptxpn, &keysrc, 8);\r\n}\r\n}\r\nif (bgroup) {\r\nint res;\r\nif (bgrouptkey)\r\npadapter->securitypriv.dot118021XGrpKeyid = (u8)key->KeyIndex;\r\nif ((key->KeyIndex&0x3) == 0) {\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\n_rtw_memset(&padapter->securitypriv.dot118021XGrpKey[(u8)((key->KeyIndex) & 0x03)], 0, 16);\r\n_rtw_memset(&padapter->securitypriv.dot118021XGrptxmickey[(u8)((key->KeyIndex) & 0x03)], 0, 16);\r\n_rtw_memset(&padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)], 0, 16);\r\nif ((key->KeyIndex & 0x10000000)) {\r\nmemcpy(&padapter->securitypriv.dot118021XGrptxmickey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial + 16, 8);\r\nmemcpy(&padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial + 24, 8);\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("\n rtw_set_802_11_add_key:rx mic :0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",\r\npadapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[0],\r\npadapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[1],\r\npadapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[2],\r\npadapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[3],\r\npadapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[4],\r\npadapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[5],\r\npadapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[6],\r\npadapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[7]));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("\n rtw_set_802_11_add_key:set Group mic key!!!!!!!!\n"));\r\n} else {\r\nmemcpy(&padapter->securitypriv.dot118021XGrptxmickey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial + 24, 8);\r\nmemcpy(&padapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial + 16, 8);\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("\n rtw_set_802_11_add_key:rx mic :0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x:0x%02x\n",\r\npadapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[0],\r\npadapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[1],\r\npadapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[2],\r\npadapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[3],\r\npadapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[4],\r\npadapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[5],\r\npadapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex) & 0x03)].skey[6],\r\npadapter->securitypriv.dot118021XGrprxmickey[(u8)((key->KeyIndex-1) & 0x03)].skey[7]));\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_,\r\n("\n rtw_set_802_11_add_key:set Group mic key!!!!!!!!\n"));\r\n}\r\nmemcpy(&padapter->securitypriv.dot118021XGrpKey[(u8)((key->KeyIndex) & 0x03)], key->KeyMaterial, key->KeyLength);\r\nkey->KeyIndex = key->KeyIndex & 0x03;\r\npadapter->securitypriv.binstallGrpkey = true;\r\npadapter->securitypriv.bcheck_grpkey = false;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("reset group key"));\r\nres = rtw_set_key(padapter, &padapter->securitypriv, key->KeyIndex, 1);\r\nif (res == _FAIL)\r\nret = _FAIL;\r\ngoto exit;\r\n} else {\r\nu8 res;\r\npbssid = get_bssid(&padapter->mlmepriv);\r\nstainfo = rtw_get_stainfo(&padapter->stapriv, pbssid);\r\nif (stainfo != NULL) {\r\n_rtw_memset(&stainfo->dot118021x_UncstKey, 0, 16);\r\nmemcpy(&stainfo->dot118021x_UncstKey, key->KeyMaterial, 16);\r\nif (encryptionalgo == _TKIP_) {\r\npadapter->securitypriv.busetkipkey = false;\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("\n========== _set_timer\n"));\r\nif ((key->KeyIndex & 0x10000000)) {\r\nmemcpy(&stainfo->dot11tkiptxmickey, key->KeyMaterial + 16, 8);\r\nmemcpy(&stainfo->dot11tkiprxmickey, key->KeyMaterial + 24, 8);\r\n} else {\r\nmemcpy(&stainfo->dot11tkiptxmickey, key->KeyMaterial + 24, 8);\r\nmemcpy(&stainfo->dot11tkiprxmickey, key->KeyMaterial + 16, 8);\r\n}\r\n}\r\nif (bgrouptkey) {\r\nres = rtw_setstakey_cmd(padapter, (unsigned char *)stainfo, false);\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("\n rtw_set_802_11_add_key:rtw_setstakey_cmd(group)\n"));\r\n} else {\r\nres = rtw_setstakey_cmd(padapter, (unsigned char *)stainfo, true);\r\nRT_TRACE(_module_rtl871x_ioctl_set_c_, _drv_err_, ("\n rtw_set_802_11_add_key:rtw_setstakey_cmd(unicast)\n"));\r\n}\r\nif (!res)\r\nret = _FAIL;\r\n}\r\n}\r\nexit:\r\n_func_exit_;\r\nreturn ret;\r\n}\r\nu8 rtw_set_802_11_remove_key(struct adapter *padapter, struct ndis_802_11_remove_key *key)\r\n{\r\nu8 *pbssid;\r\nstruct sta_info *stainfo;\r\nu8 bgroup = (key->KeyIndex & 0x4000000) > 0 ? false : true;\r\nu8 keyIndex = (u8)key->KeyIndex & 0x03;\r\nu8 ret = _SUCCESS;\r\n_func_enter_;\r\nif ((key->KeyIndex & 0xbffffffc) > 0) {\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\nif (bgroup) {\r\n_rtw_memset(&padapter->securitypriv.dot118021XGrpKey[keyIndex], 0, 16);\r\n} else {\r\npbssid = get_bssid(&padapter->mlmepriv);\r\nstainfo = rtw_get_stainfo(&padapter->stapriv, pbssid);\r\nif (stainfo) {\r\n_rtw_memset(&stainfo->dot118021x_UncstKey, 0, 16);\r\n} else {\r\nret = _FAIL;\r\ngoto exit;\r\n}\r\n}\r\nexit:\r\n_func_exit_;\r\nreturn ret;\r\n}\r\nu16 rtw_get_cur_max_rate(struct adapter *adapter)\r\n{\r\nint i = 0;\r\nu8 *p;\r\nu16 rate = 0, max_rate = 0;\r\nstruct mlme_ext_priv *pmlmeext = &adapter->mlmeextpriv;\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nstruct registry_priv *pregistrypriv = &adapter->registrypriv;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nstruct wlan_bssid_ex *pcur_bss = &pmlmepriv->cur_network.network;\r\nstruct rtw_ieee80211_ht_cap *pht_capie;\r\nu8 rf_type = 0;\r\nu8 bw_40MHz = 0, short_GI_20 = 0, short_GI_40 = 0;\r\nu16 mcs_rate = 0;\r\nu32 ht_ielen = 0;\r\nif (adapter->registrypriv.mp_mode == 1) {\r\nif (check_fwstate(pmlmepriv, WIFI_MP_STATE))\r\nreturn 0;\r\n}\r\nif ((!check_fwstate(pmlmepriv, _FW_LINKED)) &&\r\n(!check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)))\r\nreturn 0;\r\nif (pmlmeext->cur_wireless_mode & (WIRELESS_11_24N|WIRELESS_11_5N)) {\r\np = rtw_get_ie(&pcur_bss->IEs[12], _HT_CAPABILITY_IE_, &ht_ielen, pcur_bss->IELength-12);\r\nif (p && ht_ielen > 0) {\r\npht_capie = (struct rtw_ieee80211_ht_cap *)(p+2);\r\nmemcpy(&mcs_rate, pht_capie->supp_mcs_set, 2);\r\nbw_40MHz = (pmlmeext->cur_bwmode && (HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH & pmlmeinfo->HT_info.infos[0])) ? 1 : 0;\r\nshort_GI_20 = (le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info) & IEEE80211_HT_CAP_SGI_20) ? 1 : 0;\r\nshort_GI_40 = (le16_to_cpu(pmlmeinfo->HT_caps.u.HT_cap_element.HT_caps_info) & IEEE80211_HT_CAP_SGI_40) ? 1 : 0;\r\nrtw_hal_get_hwreg(adapter, HW_VAR_RF_TYPE, (u8 *)(&rf_type));\r\nmax_rate = rtw_mcs_rate(\r\nrf_type,\r\nbw_40MHz & (pregistrypriv->cbw40_enable),\r\nshort_GI_20,\r\nshort_GI_40,\r\npmlmeinfo->HT_caps.u.HT_cap_element.MCS_rate\r\n);\r\n}\r\n} else {\r\nwhile ((pcur_bss->SupportedRates[i] != 0) && (pcur_bss->SupportedRates[i] != 0xFF)) {\r\nrate = pcur_bss->SupportedRates[i]&0x7F;\r\nif (rate > max_rate)\r\nmax_rate = rate;\r\ni++;\r\n}\r\nmax_rate = max_rate*10/2;\r\n}\r\nreturn max_rate;\r\n}\r\nint rtw_set_scan_mode(struct adapter *adapter, enum rt_scan_type scan_mode)\r\n{\r\nif (scan_mode != SCAN_ACTIVE && scan_mode != SCAN_PASSIVE)\r\nreturn _FAIL;\r\nadapter->mlmepriv.scan_mode = scan_mode;\r\nreturn _SUCCESS;\r\n}\r\nint rtw_set_channel_plan(struct adapter *adapter, u8 channel_plan)\r\n{\r\nreturn rtw_set_chplan_cmd(adapter, channel_plan, 1);\r\n}\r\nint rtw_set_country(struct adapter *adapter, const char *country_code)\r\n{\r\nint channel_plan = RT_CHANNEL_DOMAIN_WORLD_WIDE_5G;\r\nDBG_88E("%s country_code:%s\n", __func__, country_code);\r\nif (0 == strcmp(country_code, "US"))\r\nchannel_plan = RT_CHANNEL_DOMAIN_FCC;\r\nelse if (0 == strcmp(country_code, "EU"))\r\nchannel_plan = RT_CHANNEL_DOMAIN_ETSI;\r\nelse if (0 == strcmp(country_code, "JP"))\r\nchannel_plan = RT_CHANNEL_DOMAIN_MKK;\r\nelse if (0 == strcmp(country_code, "CN"))\r\nchannel_plan = RT_CHANNEL_DOMAIN_CHINA;\r\nelse\r\nDBG_88E("%s unknown country_code:%s\n", __func__, country_code);\r\nreturn rtw_set_channel_plan(adapter, channel_plan);\r\n}
