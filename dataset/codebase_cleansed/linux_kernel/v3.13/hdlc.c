int hdlc_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif ((new_mtu < 68) || (new_mtu > HDLC_MAX_MTU))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic int hdlc_rcv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *p, struct net_device *orig_dev)\r\n{\r\nstruct hdlc_device *hdlc = dev_to_hdlc(dev);\r\nif (!net_eq(dev_net(dev), &init_net)) {\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nBUG_ON(!hdlc->proto->netif_rx);\r\nreturn hdlc->proto->netif_rx(skb);\r\n}\r\nnetdev_tx_t hdlc_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nif (hdlc->proto->xmit)\r\nreturn hdlc->proto->xmit(skb, dev);\r\nreturn hdlc->xmit(skb, dev);\r\n}\r\nstatic inline void hdlc_proto_start(struct net_device *dev)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nif (hdlc->proto->start)\r\nhdlc->proto->start(dev);\r\n}\r\nstatic inline void hdlc_proto_stop(struct net_device *dev)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nif (hdlc->proto->stop)\r\nhdlc->proto->stop(dev);\r\n}\r\nstatic int hdlc_device_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nhdlc_device *hdlc;\r\nunsigned long flags;\r\nint on;\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nif (!(dev->priv_flags & IFF_WAN_HDLC))\r\nreturn NOTIFY_DONE;\r\nif (event != NETDEV_CHANGE)\r\nreturn NOTIFY_DONE;\r\non = netif_carrier_ok(dev);\r\n#ifdef DEBUG_LINK\r\nprintk(KERN_DEBUG "%s: hdlc_device_event NETDEV_CHANGE, carrier %i\n",\r\ndev->name, on);\r\n#endif\r\nhdlc = dev_to_hdlc(dev);\r\nspin_lock_irqsave(&hdlc->state_lock, flags);\r\nif (hdlc->carrier == on)\r\ngoto carrier_exit;\r\nhdlc->carrier = on;\r\nif (!hdlc->open)\r\ngoto carrier_exit;\r\nif (hdlc->carrier) {\r\nnetdev_info(dev, "Carrier detected\n");\r\nhdlc_proto_start(dev);\r\n} else {\r\nnetdev_info(dev, "Carrier lost\n");\r\nhdlc_proto_stop(dev);\r\n}\r\ncarrier_exit:\r\nspin_unlock_irqrestore(&hdlc->state_lock, flags);\r\nreturn NOTIFY_DONE;\r\n}\r\nint hdlc_open(struct net_device *dev)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\n#ifdef DEBUG_LINK\r\nprintk(KERN_DEBUG "%s: hdlc_open() carrier %i open %i\n", dev->name,\r\nhdlc->carrier, hdlc->open);\r\n#endif\r\nif (hdlc->proto == NULL)\r\nreturn -ENOSYS;\r\nif (hdlc->proto->open) {\r\nint result = hdlc->proto->open(dev);\r\nif (result)\r\nreturn result;\r\n}\r\nspin_lock_irq(&hdlc->state_lock);\r\nif (hdlc->carrier) {\r\nnetdev_info(dev, "Carrier detected\n");\r\nhdlc_proto_start(dev);\r\n} else\r\nnetdev_info(dev, "No carrier\n");\r\nhdlc->open = 1;\r\nspin_unlock_irq(&hdlc->state_lock);\r\nreturn 0;\r\n}\r\nvoid hdlc_close(struct net_device *dev)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\n#ifdef DEBUG_LINK\r\nprintk(KERN_DEBUG "%s: hdlc_close() carrier %i open %i\n", dev->name,\r\nhdlc->carrier, hdlc->open);\r\n#endif\r\nspin_lock_irq(&hdlc->state_lock);\r\nhdlc->open = 0;\r\nif (hdlc->carrier)\r\nhdlc_proto_stop(dev);\r\nspin_unlock_irq(&hdlc->state_lock);\r\nif (hdlc->proto->close)\r\nhdlc->proto->close(dev);\r\n}\r\nint hdlc_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct hdlc_proto *proto = first_proto;\r\nint result;\r\nif (cmd != SIOCWANDEV)\r\nreturn -EINVAL;\r\nif (dev_to_hdlc(dev)->proto) {\r\nresult = dev_to_hdlc(dev)->proto->ioctl(dev, ifr);\r\nif (result != -EINVAL)\r\nreturn result;\r\n}\r\nwhile (proto) {\r\nif ((result = proto->ioctl(dev, ifr)) != -EINVAL)\r\nreturn result;\r\nproto = proto->next;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void hdlc_setup_dev(struct net_device *dev)\r\n{\r\ndev->flags = IFF_POINTOPOINT | IFF_NOARP;\r\ndev->priv_flags = IFF_WAN_HDLC;\r\ndev->mtu = HDLC_MAX_MTU;\r\ndev->type = ARPHRD_RAWHDLC;\r\ndev->hard_header_len = 16;\r\ndev->addr_len = 0;\r\ndev->header_ops = &hdlc_null_ops;\r\n}\r\nstatic void hdlc_setup(struct net_device *dev)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nhdlc_setup_dev(dev);\r\nhdlc->carrier = 1;\r\nhdlc->open = 0;\r\nspin_lock_init(&hdlc->state_lock);\r\n}\r\nstruct net_device *alloc_hdlcdev(void *priv)\r\n{\r\nstruct net_device *dev;\r\ndev = alloc_netdev(sizeof(struct hdlc_device), "hdlc%d", hdlc_setup);\r\nif (dev)\r\ndev_to_hdlc(dev)->priv = priv;\r\nreturn dev;\r\n}\r\nvoid unregister_hdlc_device(struct net_device *dev)\r\n{\r\nrtnl_lock();\r\nunregister_netdevice(dev);\r\ndetach_hdlc_protocol(dev);\r\nrtnl_unlock();\r\n}\r\nint attach_hdlc_protocol(struct net_device *dev, struct hdlc_proto *proto,\r\nsize_t size)\r\n{\r\ndetach_hdlc_protocol(dev);\r\nif (!try_module_get(proto->module))\r\nreturn -ENOSYS;\r\nif (size) {\r\ndev_to_hdlc(dev)->state = kmalloc(size, GFP_KERNEL);\r\nif (dev_to_hdlc(dev)->state == NULL) {\r\nmodule_put(proto->module);\r\nreturn -ENOBUFS;\r\n}\r\n}\r\ndev_to_hdlc(dev)->proto = proto;\r\nreturn 0;\r\n}\r\nvoid detach_hdlc_protocol(struct net_device *dev)\r\n{\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nif (hdlc->proto) {\r\nif (hdlc->proto->detach)\r\nhdlc->proto->detach(dev);\r\nmodule_put(hdlc->proto->module);\r\nhdlc->proto = NULL;\r\n}\r\nkfree(hdlc->state);\r\nhdlc->state = NULL;\r\nhdlc_setup_dev(dev);\r\n}\r\nvoid register_hdlc_protocol(struct hdlc_proto *proto)\r\n{\r\nrtnl_lock();\r\nproto->next = first_proto;\r\nfirst_proto = proto;\r\nrtnl_unlock();\r\n}\r\nvoid unregister_hdlc_protocol(struct hdlc_proto *proto)\r\n{\r\nstruct hdlc_proto **p;\r\nrtnl_lock();\r\np = &first_proto;\r\nwhile (*p != proto) {\r\nBUG_ON(!*p);\r\np = &((*p)->next);\r\n}\r\n*p = proto->next;\r\nrtnl_unlock();\r\n}\r\nstatic int __init hdlc_module_init(void)\r\n{\r\nint result;\r\npr_info("%s\n", version);\r\nif ((result = register_netdevice_notifier(&hdlc_notifier)) != 0)\r\nreturn result;\r\ndev_add_pack(&hdlc_packet_type);\r\nreturn 0;\r\n}\r\nstatic void __exit hdlc_module_exit(void)\r\n{\r\ndev_remove_pack(&hdlc_packet_type);\r\nunregister_netdevice_notifier(&hdlc_notifier);\r\n}
