__u64 eventfd_signal(struct eventfd_ctx *ctx, __u64 n)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctx->wqh.lock, flags);\r\nif (ULLONG_MAX - ctx->count < n)\r\nn = ULLONG_MAX - ctx->count;\r\nctx->count += n;\r\nif (waitqueue_active(&ctx->wqh))\r\nwake_up_locked_poll(&ctx->wqh, POLLIN);\r\nspin_unlock_irqrestore(&ctx->wqh.lock, flags);\r\nreturn n;\r\n}\r\nstatic void eventfd_free_ctx(struct eventfd_ctx *ctx)\r\n{\r\nkfree(ctx);\r\n}\r\nstatic void eventfd_free(struct kref *kref)\r\n{\r\nstruct eventfd_ctx *ctx = container_of(kref, struct eventfd_ctx, kref);\r\neventfd_free_ctx(ctx);\r\n}\r\nstruct eventfd_ctx *eventfd_ctx_get(struct eventfd_ctx *ctx)\r\n{\r\nkref_get(&ctx->kref);\r\nreturn ctx;\r\n}\r\nvoid eventfd_ctx_put(struct eventfd_ctx *ctx)\r\n{\r\nkref_put(&ctx->kref, eventfd_free);\r\n}\r\nstatic int eventfd_release(struct inode *inode, struct file *file)\r\n{\r\nstruct eventfd_ctx *ctx = file->private_data;\r\nwake_up_poll(&ctx->wqh, POLLHUP);\r\neventfd_ctx_put(ctx);\r\nreturn 0;\r\n}\r\nstatic unsigned int eventfd_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct eventfd_ctx *ctx = file->private_data;\r\nunsigned int events = 0;\r\nunsigned long flags;\r\npoll_wait(file, &ctx->wqh, wait);\r\nspin_lock_irqsave(&ctx->wqh.lock, flags);\r\nif (ctx->count > 0)\r\nevents |= POLLIN;\r\nif (ctx->count == ULLONG_MAX)\r\nevents |= POLLERR;\r\nif (ULLONG_MAX - 1 > ctx->count)\r\nevents |= POLLOUT;\r\nspin_unlock_irqrestore(&ctx->wqh.lock, flags);\r\nreturn events;\r\n}\r\nstatic void eventfd_ctx_do_read(struct eventfd_ctx *ctx, __u64 *cnt)\r\n{\r\n*cnt = (ctx->flags & EFD_SEMAPHORE) ? 1 : ctx->count;\r\nctx->count -= *cnt;\r\n}\r\nint eventfd_ctx_remove_wait_queue(struct eventfd_ctx *ctx, wait_queue_t *wait,\r\n__u64 *cnt)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctx->wqh.lock, flags);\r\neventfd_ctx_do_read(ctx, cnt);\r\n__remove_wait_queue(&ctx->wqh, wait);\r\nif (*cnt != 0 && waitqueue_active(&ctx->wqh))\r\nwake_up_locked_poll(&ctx->wqh, POLLOUT);\r\nspin_unlock_irqrestore(&ctx->wqh.lock, flags);\r\nreturn *cnt != 0 ? 0 : -EAGAIN;\r\n}\r\nssize_t eventfd_ctx_read(struct eventfd_ctx *ctx, int no_wait, __u64 *cnt)\r\n{\r\nssize_t res;\r\nDECLARE_WAITQUEUE(wait, current);\r\nspin_lock_irq(&ctx->wqh.lock);\r\n*cnt = 0;\r\nres = -EAGAIN;\r\nif (ctx->count > 0)\r\nres = 0;\r\nelse if (!no_wait) {\r\n__add_wait_queue(&ctx->wqh, &wait);\r\nfor (;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (ctx->count > 0) {\r\nres = 0;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nres = -ERESTARTSYS;\r\nbreak;\r\n}\r\nspin_unlock_irq(&ctx->wqh.lock);\r\nschedule();\r\nspin_lock_irq(&ctx->wqh.lock);\r\n}\r\n__remove_wait_queue(&ctx->wqh, &wait);\r\n__set_current_state(TASK_RUNNING);\r\n}\r\nif (likely(res == 0)) {\r\neventfd_ctx_do_read(ctx, cnt);\r\nif (waitqueue_active(&ctx->wqh))\r\nwake_up_locked_poll(&ctx->wqh, POLLOUT);\r\n}\r\nspin_unlock_irq(&ctx->wqh.lock);\r\nreturn res;\r\n}\r\nstatic ssize_t eventfd_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct eventfd_ctx *ctx = file->private_data;\r\nssize_t res;\r\n__u64 cnt;\r\nif (count < sizeof(cnt))\r\nreturn -EINVAL;\r\nres = eventfd_ctx_read(ctx, file->f_flags & O_NONBLOCK, &cnt);\r\nif (res < 0)\r\nreturn res;\r\nreturn put_user(cnt, (__u64 __user *) buf) ? -EFAULT : sizeof(cnt);\r\n}\r\nstatic ssize_t eventfd_write(struct file *file, const char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct eventfd_ctx *ctx = file->private_data;\r\nssize_t res;\r\n__u64 ucnt;\r\nDECLARE_WAITQUEUE(wait, current);\r\nif (count < sizeof(ucnt))\r\nreturn -EINVAL;\r\nif (copy_from_user(&ucnt, buf, sizeof(ucnt)))\r\nreturn -EFAULT;\r\nif (ucnt == ULLONG_MAX)\r\nreturn -EINVAL;\r\nspin_lock_irq(&ctx->wqh.lock);\r\nres = -EAGAIN;\r\nif (ULLONG_MAX - ctx->count > ucnt)\r\nres = sizeof(ucnt);\r\nelse if (!(file->f_flags & O_NONBLOCK)) {\r\n__add_wait_queue(&ctx->wqh, &wait);\r\nfor (res = 0;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (ULLONG_MAX - ctx->count > ucnt) {\r\nres = sizeof(ucnt);\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nres = -ERESTARTSYS;\r\nbreak;\r\n}\r\nspin_unlock_irq(&ctx->wqh.lock);\r\nschedule();\r\nspin_lock_irq(&ctx->wqh.lock);\r\n}\r\n__remove_wait_queue(&ctx->wqh, &wait);\r\n__set_current_state(TASK_RUNNING);\r\n}\r\nif (likely(res > 0)) {\r\nctx->count += ucnt;\r\nif (waitqueue_active(&ctx->wqh))\r\nwake_up_locked_poll(&ctx->wqh, POLLIN);\r\n}\r\nspin_unlock_irq(&ctx->wqh.lock);\r\nreturn res;\r\n}\r\nstatic int eventfd_show_fdinfo(struct seq_file *m, struct file *f)\r\n{\r\nstruct eventfd_ctx *ctx = f->private_data;\r\nint ret;\r\nspin_lock_irq(&ctx->wqh.lock);\r\nret = seq_printf(m, "eventfd-count: %16llx\n",\r\n(unsigned long long)ctx->count);\r\nspin_unlock_irq(&ctx->wqh.lock);\r\nreturn ret;\r\n}\r\nstruct file *eventfd_fget(int fd)\r\n{\r\nstruct file *file;\r\nfile = fget(fd);\r\nif (!file)\r\nreturn ERR_PTR(-EBADF);\r\nif (file->f_op != &eventfd_fops) {\r\nfput(file);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn file;\r\n}\r\nstruct eventfd_ctx *eventfd_ctx_fdget(int fd)\r\n{\r\nstruct file *file;\r\nstruct eventfd_ctx *ctx;\r\nfile = eventfd_fget(fd);\r\nif (IS_ERR(file))\r\nreturn (struct eventfd_ctx *) file;\r\nctx = eventfd_ctx_get(file->private_data);\r\nfput(file);\r\nreturn ctx;\r\n}\r\nstruct eventfd_ctx *eventfd_ctx_fileget(struct file *file)\r\n{\r\nif (file->f_op != &eventfd_fops)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn eventfd_ctx_get(file->private_data);\r\n}\r\nstruct file *eventfd_file_create(unsigned int count, int flags)\r\n{\r\nstruct file *file;\r\nstruct eventfd_ctx *ctx;\r\nBUILD_BUG_ON(EFD_CLOEXEC != O_CLOEXEC);\r\nBUILD_BUG_ON(EFD_NONBLOCK != O_NONBLOCK);\r\nif (flags & ~EFD_FLAGS_SET)\r\nreturn ERR_PTR(-EINVAL);\r\nctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn ERR_PTR(-ENOMEM);\r\nkref_init(&ctx->kref);\r\ninit_waitqueue_head(&ctx->wqh);\r\nctx->count = count;\r\nctx->flags = flags;\r\nfile = anon_inode_getfile("[eventfd]", &eventfd_fops, ctx,\r\nO_RDWR | (flags & EFD_SHARED_FCNTL_FLAGS));\r\nif (IS_ERR(file))\r\neventfd_free_ctx(ctx);\r\nreturn file;\r\n}
