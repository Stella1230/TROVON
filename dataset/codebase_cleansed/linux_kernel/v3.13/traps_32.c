static void instruction_dump(unsigned long *pc)\r\n{\r\nint i;\r\nif((((unsigned long) pc) & 3))\r\nreturn;\r\nfor(i = -3; i < 6; i++)\r\nprintk("%c%08lx%c",i?' ':'<',pc[i],i?' ':'>');\r\nprintk("\n");\r\n}\r\nvoid die_if_kernel(char *str, struct pt_regs *regs)\r\n{\r\nstatic int die_counter;\r\nint count = 0;\r\nprintk(\r\n" \\|/ ____ \\|/\n"\r\n" \"@'/ ,. \\`@\"\n"\r\n" /_| \\__/ |_\\\n"\r\n" \\__U_/\n");\r\nprintk("%s(%d): %s [#%d]\n", current->comm, task_pid_nr(current), str, ++die_counter);\r\nshow_regs(regs);\r\nadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\r\n__SAVE; __SAVE; __SAVE; __SAVE;\r\n__SAVE; __SAVE; __SAVE; __SAVE;\r\n__RESTORE; __RESTORE; __RESTORE; __RESTORE;\r\n__RESTORE; __RESTORE; __RESTORE; __RESTORE;\r\n{\r\nstruct reg_window32 *rw = (struct reg_window32 *)regs->u_regs[UREG_FP];\r\nwhile(rw &&\r\ncount++ < 30 &&\r\n(((unsigned long) rw) >= PAGE_OFFSET) &&\r\n!(((unsigned long) rw) & 0x7)) {\r\nprintk("Caller[%08lx]: %pS\n", rw->ins[7],\r\n(void *) rw->ins[7]);\r\nrw = (struct reg_window32 *)rw->ins[6];\r\n}\r\n}\r\nprintk("Instruction DUMP:");\r\ninstruction_dump ((unsigned long *) regs->pc);\r\nif(regs->psr & PSR_PS)\r\ndo_exit(SIGKILL);\r\ndo_exit(SIGSEGV);\r\n}\r\nvoid do_hw_interrupt(struct pt_regs *regs, unsigned long type)\r\n{\r\nsiginfo_t info;\r\nif(type < 0x80) {\r\nprintk("Unimplemented Sparc TRAP, type = %02lx\n", type);\r\ndie_if_kernel("Whee... Hello Mr. Penguin", regs);\r\n}\r\nif(regs->psr & PSR_PS)\r\ndie_if_kernel("Kernel bad trap", regs);\r\ninfo.si_signo = SIGILL;\r\ninfo.si_errno = 0;\r\ninfo.si_code = ILL_ILLTRP;\r\ninfo.si_addr = (void __user *)regs->pc;\r\ninfo.si_trapno = type - 0x80;\r\nforce_sig_info(SIGILL, &info, current);\r\n}\r\nvoid do_illegal_instruction(struct pt_regs *regs, unsigned long pc, unsigned long npc,\r\nunsigned long psr)\r\n{\r\nsiginfo_t info;\r\nif(psr & PSR_PS)\r\ndie_if_kernel("Kernel illegal instruction", regs);\r\n#ifdef TRAP_DEBUG\r\nprintk("Ill instr. at pc=%08lx instruction is %08lx\n",\r\nregs->pc, *(unsigned long *)regs->pc);\r\n#endif\r\ninfo.si_signo = SIGILL;\r\ninfo.si_errno = 0;\r\ninfo.si_code = ILL_ILLOPC;\r\ninfo.si_addr = (void __user *)pc;\r\ninfo.si_trapno = 0;\r\nsend_sig_info(SIGILL, &info, current);\r\n}\r\nvoid do_priv_instruction(struct pt_regs *regs, unsigned long pc, unsigned long npc,\r\nunsigned long psr)\r\n{\r\nsiginfo_t info;\r\nif(psr & PSR_PS)\r\ndie_if_kernel("Penguin instruction from Penguin mode??!?!", regs);\r\ninfo.si_signo = SIGILL;\r\ninfo.si_errno = 0;\r\ninfo.si_code = ILL_PRVOPC;\r\ninfo.si_addr = (void __user *)pc;\r\ninfo.si_trapno = 0;\r\nsend_sig_info(SIGILL, &info, current);\r\n}\r\nvoid do_memaccess_unaligned(struct pt_regs *regs, unsigned long pc, unsigned long npc,\r\nunsigned long psr)\r\n{\r\nsiginfo_t info;\r\nif(regs->psr & PSR_PS) {\r\nprintk("KERNEL MNA at pc %08lx npc %08lx called by %08lx\n", pc, npc,\r\nregs->u_regs[UREG_RETPC]);\r\ndie_if_kernel("BOGUS", regs);\r\n}\r\n#if 0\r\nshow_regs (regs);\r\ninstruction_dump ((unsigned long *) regs->pc);\r\nprintk ("do_MNA!\n");\r\n#endif\r\ninfo.si_signo = SIGBUS;\r\ninfo.si_errno = 0;\r\ninfo.si_code = BUS_ADRALN;\r\ninfo.si_addr = (void *)0;\r\ninfo.si_trapno = 0;\r\nsend_sig_info(SIGBUS, &info, current);\r\n}\r\nvoid do_fpd_trap(struct pt_regs *regs, unsigned long pc, unsigned long npc,\r\nunsigned long psr)\r\n{\r\nif(psr & PSR_PS)\r\ndie_if_kernel("Kernel gets FloatingPenguinUnit disabled trap", regs);\r\nput_psr(get_psr() | PSR_EF);\r\nregs->psr |= PSR_EF;\r\n#ifndef CONFIG_SMP\r\nif(last_task_used_math == current)\r\nreturn;\r\nif(last_task_used_math) {\r\nstruct task_struct *fptask = last_task_used_math;\r\nfpsave(&fptask->thread.float_regs[0], &fptask->thread.fsr,\r\n&fptask->thread.fpqueue[0], &fptask->thread.fpqdepth);\r\n}\r\nlast_task_used_math = current;\r\nif(used_math()) {\r\nfpload(&current->thread.float_regs[0], &current->thread.fsr);\r\n} else {\r\nfpload(&init_fregs[0], &init_fsr);\r\nset_used_math();\r\n}\r\n#else\r\nif(!used_math()) {\r\nfpload(&init_fregs[0], &init_fsr);\r\nset_used_math();\r\n} else {\r\nfpload(&current->thread.float_regs[0], &current->thread.fsr);\r\n}\r\nset_thread_flag(TIF_USEDFPU);\r\n#endif\r\n}\r\nvoid handle_tag_overflow(struct pt_regs *regs, unsigned long pc, unsigned long npc,\r\nunsigned long psr)\r\n{\r\nsiginfo_t info;\r\nif(psr & PSR_PS)\r\ndie_if_kernel("Penguin overflow trap from kernel mode", regs);\r\ninfo.si_signo = SIGEMT;\r\ninfo.si_errno = 0;\r\ninfo.si_code = EMT_TAGOVF;\r\ninfo.si_addr = (void __user *)pc;\r\ninfo.si_trapno = 0;\r\nsend_sig_info(SIGEMT, &info, current);\r\n}\r\nvoid handle_watchpoint(struct pt_regs *regs, unsigned long pc, unsigned long npc,\r\nunsigned long psr)\r\n{\r\n#ifdef TRAP_DEBUG\r\nprintk("Watchpoint detected at PC %08lx NPC %08lx PSR %08lx\n",\r\npc, npc, psr);\r\n#endif\r\nif(psr & PSR_PS)\r\npanic("Tell me what a watchpoint trap is, and I'll then deal "\r\n"with such a beast...");\r\n}\r\nvoid handle_reg_access(struct pt_regs *regs, unsigned long pc, unsigned long npc,\r\nunsigned long psr)\r\n{\r\nsiginfo_t info;\r\n#ifdef TRAP_DEBUG\r\nprintk("Register Access Exception at PC %08lx NPC %08lx PSR %08lx\n",\r\npc, npc, psr);\r\n#endif\r\ninfo.si_signo = SIGBUS;\r\ninfo.si_errno = 0;\r\ninfo.si_code = BUS_OBJERR;\r\ninfo.si_addr = (void __user *)pc;\r\ninfo.si_trapno = 0;\r\nforce_sig_info(SIGBUS, &info, current);\r\n}\r\nvoid handle_cp_disabled(struct pt_regs *regs, unsigned long pc, unsigned long npc,\r\nunsigned long psr)\r\n{\r\nsiginfo_t info;\r\ninfo.si_signo = SIGILL;\r\ninfo.si_errno = 0;\r\ninfo.si_code = ILL_COPROC;\r\ninfo.si_addr = (void __user *)pc;\r\ninfo.si_trapno = 0;\r\nsend_sig_info(SIGILL, &info, current);\r\n}\r\nvoid handle_cp_exception(struct pt_regs *regs, unsigned long pc, unsigned long npc,\r\nunsigned long psr)\r\n{\r\nsiginfo_t info;\r\n#ifdef TRAP_DEBUG\r\nprintk("Co-Processor Exception at PC %08lx NPC %08lx PSR %08lx\n",\r\npc, npc, psr);\r\n#endif\r\ninfo.si_signo = SIGILL;\r\ninfo.si_errno = 0;\r\ninfo.si_code = ILL_COPROC;\r\ninfo.si_addr = (void __user *)pc;\r\ninfo.si_trapno = 0;\r\nsend_sig_info(SIGILL, &info, current);\r\n}\r\nvoid handle_hw_divzero(struct pt_regs *regs, unsigned long pc, unsigned long npc,\r\nunsigned long psr)\r\n{\r\nsiginfo_t info;\r\ninfo.si_signo = SIGFPE;\r\ninfo.si_errno = 0;\r\ninfo.si_code = FPE_INTDIV;\r\ninfo.si_addr = (void __user *)pc;\r\ninfo.si_trapno = 0;\r\nsend_sig_info(SIGFPE, &info, current);\r\n}\r\nvoid do_BUG(const char *file, int line)\r\n{\r\nprintk("kernel BUG at %s:%d!\n", file, line);\r\n}\r\nvoid trap_init(void)\r\n{\r\nextern void thread_info_offsets_are_bolixed_pete(void);\r\nif (TI_UWINMASK != offsetof(struct thread_info, uwinmask) ||\r\nTI_TASK != offsetof(struct thread_info, task) ||\r\nTI_EXECDOMAIN != offsetof(struct thread_info, exec_domain) ||\r\nTI_FLAGS != offsetof(struct thread_info, flags) ||\r\nTI_CPU != offsetof(struct thread_info, cpu) ||\r\nTI_PREEMPT != offsetof(struct thread_info, preempt_count) ||\r\nTI_SOFTIRQ != offsetof(struct thread_info, softirq_count) ||\r\nTI_HARDIRQ != offsetof(struct thread_info, hardirq_count) ||\r\nTI_KSP != offsetof(struct thread_info, ksp) ||\r\nTI_KPC != offsetof(struct thread_info, kpc) ||\r\nTI_KPSR != offsetof(struct thread_info, kpsr) ||\r\nTI_KWIM != offsetof(struct thread_info, kwim) ||\r\nTI_REG_WINDOW != offsetof(struct thread_info, reg_window) ||\r\nTI_RWIN_SPTRS != offsetof(struct thread_info, rwbuf_stkptrs) ||\r\nTI_W_SAVED != offsetof(struct thread_info, w_saved))\r\nthread_info_offsets_are_bolixed_pete();\r\natomic_inc(&init_mm.mm_count);\r\ncurrent->active_mm = &init_mm;\r\n}
