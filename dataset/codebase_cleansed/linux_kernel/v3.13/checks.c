static inline void check_msg(struct check *c, const char *fmt, ...)\r\n{\r\nva_list ap;\r\nva_start(ap, fmt);\r\nif ((c->warn && (quiet < 1))\r\n|| (c->error && (quiet < 2))) {\r\nfprintf(stderr, "%s (%s): ",\r\n(c->error) ? "ERROR" : "Warning", c->name);\r\nvfprintf(stderr, fmt, ap);\r\nfprintf(stderr, "\n");\r\n}\r\n}\r\nstatic void check_nodes_props(struct check *c, struct node *dt, struct node *node)\r\n{\r\nstruct node *child;\r\nstruct property *prop;\r\nTRACE(c, "%s", node->fullpath);\r\nif (c->node_fn)\r\nc->node_fn(c, dt, node);\r\nif (c->prop_fn)\r\nfor_each_property(node, prop) {\r\nTRACE(c, "%s\t'%s'", node->fullpath, prop->name);\r\nc->prop_fn(c, dt, node, prop);\r\n}\r\nfor_each_child(node, child)\r\ncheck_nodes_props(c, dt, child);\r\n}\r\nstatic int run_check(struct check *c, struct node *dt)\r\n{\r\nint error = 0;\r\nint i;\r\nassert(!c->inprogress);\r\nif (c->status != UNCHECKED)\r\ngoto out;\r\nc->inprogress = 1;\r\nfor (i = 0; i < c->num_prereqs; i++) {\r\nstruct check *prq = c->prereq[i];\r\nerror |= run_check(prq, dt);\r\nif (prq->status != PASSED) {\r\nc->status = PREREQ;\r\ncheck_msg(c, "Failed prerequisite '%s'",\r\nc->prereq[i]->name);\r\n}\r\n}\r\nif (c->status != UNCHECKED)\r\ngoto out;\r\nif (c->node_fn || c->prop_fn)\r\ncheck_nodes_props(c, dt, dt);\r\nif (c->tree_fn)\r\nc->tree_fn(c, dt);\r\nif (c->status == UNCHECKED)\r\nc->status = PASSED;\r\nTRACE(c, "\tCompleted, status %d", c->status);\r\nout:\r\nc->inprogress = 0;\r\nif ((c->status != PASSED) && (c->error))\r\nerror = 1;\r\nreturn error;\r\n}\r\nstatic inline void check_always_fail(struct check *c, struct node *dt)\r\n{\r\nFAIL(c, "always_fail check");\r\n}\r\nstatic void check_is_string(struct check *c, struct node *root,\r\nstruct node *node)\r\n{\r\nstruct property *prop;\r\nchar *propname = c->data;\r\nprop = get_property(node, propname);\r\nif (!prop)\r\nreturn;\r\nif (!data_is_one_string(prop->val))\r\nFAIL(c, "\"%s\" property in %s is not a string",\r\npropname, node->fullpath);\r\n}\r\nstatic void check_is_cell(struct check *c, struct node *root,\r\nstruct node *node)\r\n{\r\nstruct property *prop;\r\nchar *propname = c->data;\r\nprop = get_property(node, propname);\r\nif (!prop)\r\nreturn;\r\nif (prop->val.len != sizeof(cell_t))\r\nFAIL(c, "\"%s\" property in %s is not a single cell",\r\npropname, node->fullpath);\r\n}\r\nstatic void check_duplicate_node_names(struct check *c, struct node *dt,\r\nstruct node *node)\r\n{\r\nstruct node *child, *child2;\r\nfor_each_child(node, child)\r\nfor (child2 = child->next_sibling;\r\nchild2;\r\nchild2 = child2->next_sibling)\r\nif (streq(child->name, child2->name))\r\nFAIL(c, "Duplicate node name %s",\r\nchild->fullpath);\r\n}\r\nstatic void check_duplicate_property_names(struct check *c, struct node *dt,\r\nstruct node *node)\r\n{\r\nstruct property *prop, *prop2;\r\nfor_each_property(node, prop) {\r\nfor (prop2 = prop->next; prop2; prop2 = prop2->next) {\r\nif (prop2->deleted)\r\ncontinue;\r\nif (streq(prop->name, prop2->name))\r\nFAIL(c, "Duplicate property name %s in %s",\r\nprop->name, node->fullpath);\r\n}\r\n}\r\n}\r\nstatic void check_node_name_chars(struct check *c, struct node *dt,\r\nstruct node *node)\r\n{\r\nint n = strspn(node->name, c->data);\r\nif (n < strlen(node->name))\r\nFAIL(c, "Bad character '%c' in node %s",\r\nnode->name[n], node->fullpath);\r\n}\r\nstatic void check_node_name_format(struct check *c, struct node *dt,\r\nstruct node *node)\r\n{\r\nif (strchr(get_unitname(node), '@'))\r\nFAIL(c, "Node %s has multiple '@' characters in name",\r\nnode->fullpath);\r\n}\r\nstatic void check_property_name_chars(struct check *c, struct node *dt,\r\nstruct node *node, struct property *prop)\r\n{\r\nint n = strspn(prop->name, c->data);\r\nif (n < strlen(prop->name))\r\nFAIL(c, "Bad character '%c' in property name \"%s\", node %s",\r\nprop->name[n], prop->name, node->fullpath);\r\n}\r\nstatic void check_duplicate_label(struct check *c, struct node *dt,\r\nconst char *label, struct node *node,\r\nstruct property *prop, struct marker *mark)\r\n{\r\nstruct node *othernode = NULL;\r\nstruct property *otherprop = NULL;\r\nstruct marker *othermark = NULL;\r\nothernode = get_node_by_label(dt, label);\r\nif (!othernode)\r\notherprop = get_property_by_label(dt, label, &othernode);\r\nif (!othernode)\r\nothermark = get_marker_label(dt, label, &othernode,\r\n&otherprop);\r\nif (!othernode)\r\nreturn;\r\nif ((othernode != node) || (otherprop != prop) || (othermark != mark))\r\nFAIL(c, "Duplicate label '%s' on " DESCLABEL_FMT\r\n" and " DESCLABEL_FMT,\r\nlabel, DESCLABEL_ARGS(node, prop, mark),\r\nDESCLABEL_ARGS(othernode, otherprop, othermark));\r\n}\r\nstatic void check_duplicate_label_node(struct check *c, struct node *dt,\r\nstruct node *node)\r\n{\r\nstruct label *l;\r\nfor_each_label(node->labels, l)\r\ncheck_duplicate_label(c, dt, l->label, node, NULL, NULL);\r\n}\r\nstatic void check_duplicate_label_prop(struct check *c, struct node *dt,\r\nstruct node *node, struct property *prop)\r\n{\r\nstruct marker *m = prop->val.markers;\r\nstruct label *l;\r\nfor_each_label(prop->labels, l)\r\ncheck_duplicate_label(c, dt, l->label, node, prop, NULL);\r\nfor_each_marker_of_type(m, LABEL)\r\ncheck_duplicate_label(c, dt, m->ref, node, prop, m);\r\n}\r\nstatic void check_explicit_phandles(struct check *c, struct node *root,\r\nstruct node *node, struct property *prop)\r\n{\r\nstruct marker *m;\r\nstruct node *other;\r\ncell_t phandle;\r\nif (!streq(prop->name, "phandle")\r\n&& !streq(prop->name, "linux,phandle"))\r\nreturn;\r\nif (prop->val.len != sizeof(cell_t)) {\r\nFAIL(c, "%s has bad length (%d) %s property",\r\nnode->fullpath, prop->val.len, prop->name);\r\nreturn;\r\n}\r\nm = prop->val.markers;\r\nfor_each_marker_of_type(m, REF_PHANDLE) {\r\nassert(m->offset == 0);\r\nif (node != get_node_by_ref(root, m->ref))\r\n{\r\nFAIL(c, "%s in %s is a reference to another node",\r\nprop->name, node->fullpath);\r\nreturn;\r\n}\r\nreturn;\r\n}\r\nphandle = propval_cell(prop);\r\nif ((phandle == 0) || (phandle == -1)) {\r\nFAIL(c, "%s has bad value (0x%x) in %s property",\r\nnode->fullpath, phandle, prop->name);\r\nreturn;\r\n}\r\nif (node->phandle && (node->phandle != phandle))\r\nFAIL(c, "%s has %s property which replaces existing phandle information",\r\nnode->fullpath, prop->name);\r\nother = get_node_by_phandle(root, phandle);\r\nif (other && (other != node)) {\r\nFAIL(c, "%s has duplicated phandle 0x%x (seen before at %s)",\r\nnode->fullpath, phandle, other->fullpath);\r\nreturn;\r\n}\r\nnode->phandle = phandle;\r\n}\r\nstatic void check_name_properties(struct check *c, struct node *root,\r\nstruct node *node)\r\n{\r\nstruct property **pp, *prop = NULL;\r\nfor (pp = &node->proplist; *pp; pp = &((*pp)->next))\r\nif (streq((*pp)->name, "name")) {\r\nprop = *pp;\r\nbreak;\r\n}\r\nif (!prop)\r\nreturn;\r\nif ((prop->val.len != node->basenamelen+1)\r\n|| (memcmp(prop->val.val, node->name, node->basenamelen) != 0)) {\r\nFAIL(c, "\"name\" property in %s is incorrect (\"%s\" instead"\r\n" of base node name)", node->fullpath, prop->val.val);\r\n} else {\r\n*pp = prop->next;\r\nfree(prop->name);\r\ndata_free(prop->val);\r\nfree(prop);\r\n}\r\n}\r\nstatic void fixup_phandle_references(struct check *c, struct node *dt,\r\nstruct node *node, struct property *prop)\r\n{\r\nstruct marker *m = prop->val.markers;\r\nstruct node *refnode;\r\ncell_t phandle;\r\nfor_each_marker_of_type(m, REF_PHANDLE) {\r\nassert(m->offset + sizeof(cell_t) <= prop->val.len);\r\nrefnode = get_node_by_ref(dt, m->ref);\r\nif (! refnode) {\r\nFAIL(c, "Reference to non-existent node or label \"%s\"\n",\r\nm->ref);\r\ncontinue;\r\n}\r\nphandle = get_node_phandle(dt, refnode);\r\n*((cell_t *)(prop->val.val + m->offset)) = cpu_to_fdt32(phandle);\r\n}\r\n}\r\nstatic void fixup_path_references(struct check *c, struct node *dt,\r\nstruct node *node, struct property *prop)\r\n{\r\nstruct marker *m = prop->val.markers;\r\nstruct node *refnode;\r\nchar *path;\r\nfor_each_marker_of_type(m, REF_PATH) {\r\nassert(m->offset <= prop->val.len);\r\nrefnode = get_node_by_ref(dt, m->ref);\r\nif (!refnode) {\r\nFAIL(c, "Reference to non-existent node or label \"%s\"\n",\r\nm->ref);\r\ncontinue;\r\n}\r\npath = refnode->fullpath;\r\nprop->val = data_insert_at_marker(prop->val, m, path,\r\nstrlen(path) + 1);\r\n}\r\n}\r\nstatic void fixup_addr_size_cells(struct check *c, struct node *dt,\r\nstruct node *node)\r\n{\r\nstruct property *prop;\r\nnode->addr_cells = -1;\r\nnode->size_cells = -1;\r\nprop = get_property(node, "#address-cells");\r\nif (prop)\r\nnode->addr_cells = propval_cell(prop);\r\nprop = get_property(node, "#size-cells");\r\nif (prop)\r\nnode->size_cells = propval_cell(prop);\r\n}\r\nstatic void check_reg_format(struct check *c, struct node *dt,\r\nstruct node *node)\r\n{\r\nstruct property *prop;\r\nint addr_cells, size_cells, entrylen;\r\nprop = get_property(node, "reg");\r\nif (!prop)\r\nreturn;\r\nif (!node->parent) {\r\nFAIL(c, "Root node has a \"reg\" property");\r\nreturn;\r\n}\r\nif (prop->val.len == 0)\r\nFAIL(c, "\"reg\" property in %s is empty", node->fullpath);\r\naddr_cells = node_addr_cells(node->parent);\r\nsize_cells = node_size_cells(node->parent);\r\nentrylen = (addr_cells + size_cells) * sizeof(cell_t);\r\nif ((prop->val.len % entrylen) != 0)\r\nFAIL(c, "\"reg\" property in %s has invalid length (%d bytes) "\r\n"(#address-cells == %d, #size-cells == %d)",\r\nnode->fullpath, prop->val.len, addr_cells, size_cells);\r\n}\r\nstatic void check_ranges_format(struct check *c, struct node *dt,\r\nstruct node *node)\r\n{\r\nstruct property *prop;\r\nint c_addr_cells, p_addr_cells, c_size_cells, p_size_cells, entrylen;\r\nprop = get_property(node, "ranges");\r\nif (!prop)\r\nreturn;\r\nif (!node->parent) {\r\nFAIL(c, "Root node has a \"ranges\" property");\r\nreturn;\r\n}\r\np_addr_cells = node_addr_cells(node->parent);\r\np_size_cells = node_size_cells(node->parent);\r\nc_addr_cells = node_addr_cells(node);\r\nc_size_cells = node_size_cells(node);\r\nentrylen = (p_addr_cells + c_addr_cells + c_size_cells) * sizeof(cell_t);\r\nif (prop->val.len == 0) {\r\nif (p_addr_cells != c_addr_cells)\r\nFAIL(c, "%s has empty \"ranges\" property but its "\r\n"#address-cells (%d) differs from %s (%d)",\r\nnode->fullpath, c_addr_cells, node->parent->fullpath,\r\np_addr_cells);\r\nif (p_size_cells != c_size_cells)\r\nFAIL(c, "%s has empty \"ranges\" property but its "\r\n"#size-cells (%d) differs from %s (%d)",\r\nnode->fullpath, c_size_cells, node->parent->fullpath,\r\np_size_cells);\r\n} else if ((prop->val.len % entrylen) != 0) {\r\nFAIL(c, "\"ranges\" property in %s has invalid length (%d bytes) "\r\n"(parent #address-cells == %d, child #address-cells == %d, "\r\n"#size-cells == %d)", node->fullpath, prop->val.len,\r\np_addr_cells, c_addr_cells, c_size_cells);\r\n}\r\n}\r\nstatic void check_avoid_default_addr_size(struct check *c, struct node *dt,\r\nstruct node *node)\r\n{\r\nstruct property *reg, *ranges;\r\nif (!node->parent)\r\nreturn;\r\nreg = get_property(node, "reg");\r\nranges = get_property(node, "ranges");\r\nif (!reg && !ranges)\r\nreturn;\r\nif ((node->parent->addr_cells == -1))\r\nFAIL(c, "Relying on default #address-cells value for %s",\r\nnode->fullpath);\r\nif ((node->parent->size_cells == -1))\r\nFAIL(c, "Relying on default #size-cells value for %s",\r\nnode->fullpath);\r\n}\r\nstatic void check_obsolete_chosen_interrupt_controller(struct check *c,\r\nstruct node *dt)\r\n{\r\nstruct node *chosen;\r\nstruct property *prop;\r\nchosen = get_node_by_path(dt, "/chosen");\r\nif (!chosen)\r\nreturn;\r\nprop = get_property(chosen, "interrupt-controller");\r\nif (prop)\r\nFAIL(c, "/chosen has obsolete \"interrupt-controller\" "\r\n"property");\r\n}\r\nstatic void enable_warning_error(struct check *c, bool warn, bool error)\r\n{\r\nint i;\r\nif ((warn && !c->warn) || (error && !c->error))\r\nfor (i = 0; i < c->num_prereqs; i++)\r\nenable_warning_error(c->prereq[i], warn, error);\r\nc->warn = c->warn || warn;\r\nc->error = c->error || error;\r\n}\r\nstatic void disable_warning_error(struct check *c, bool warn, bool error)\r\n{\r\nint i;\r\nif ((warn && c->warn) || (error && c->error)) {\r\nfor (i = 0; i < ARRAY_SIZE(check_table); i++) {\r\nstruct check *cc = check_table[i];\r\nint j;\r\nfor (j = 0; j < cc->num_prereqs; j++)\r\nif (cc->prereq[j] == c)\r\ndisable_warning_error(cc, warn, error);\r\n}\r\n}\r\nc->warn = c->warn && !warn;\r\nc->error = c->error && !error;\r\n}\r\nvoid parse_checks_option(bool warn, bool error, const char *optarg)\r\n{\r\nint i;\r\nconst char *name = optarg;\r\nbool enable = true;\r\nif ((strncmp(optarg, "no-", 3) == 0)\r\n|| (strncmp(optarg, "no_", 3) == 0)) {\r\nname = optarg + 3;\r\nenable = false;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(check_table); i++) {\r\nstruct check *c = check_table[i];\r\nif (streq(c->name, name)) {\r\nif (enable)\r\nenable_warning_error(c, warn, error);\r\nelse\r\ndisable_warning_error(c, warn, error);\r\nreturn;\r\n}\r\n}\r\ndie("Unrecognized check name \"%s\"\n", name);\r\n}\r\nvoid process_checks(int force, struct boot_info *bi)\r\n{\r\nstruct node *dt = bi->dt;\r\nint i;\r\nint error = 0;\r\nfor (i = 0; i < ARRAY_SIZE(check_table); i++) {\r\nstruct check *c = check_table[i];\r\nif (c->warn || c->error)\r\nerror = error || run_check(c, dt);\r\n}\r\nif (error) {\r\nif (!force) {\r\nfprintf(stderr, "ERROR: Input tree has errors, aborting "\r\n"(use -f to force output)\n");\r\nexit(2);\r\n} else if (quiet < 3) {\r\nfprintf(stderr, "Warning: Input tree has errors, "\r\n"output forced\n");\r\n}\r\n}\r\n}
