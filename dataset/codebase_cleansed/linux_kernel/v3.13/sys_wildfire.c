static void\r\nwildfire_update_irq_hw(unsigned int irq)\r\n{\r\nint qbbno = (irq >> 8) & (WILDFIRE_MAX_QBB - 1);\r\nint pcano = (irq >> 6) & (WILDFIRE_PCA_PER_QBB - 1);\r\nwildfire_pca *pca;\r\nvolatile unsigned long * enable0;\r\nif (!WILDFIRE_PCA_EXISTS(qbbno, pcano)) {\r\nif (!doing_init_irq_hw) {\r\nprintk(KERN_ERR "wildfire_update_irq_hw:"\r\n" got irq %d for non-existent PCA %d"\r\n" on QBB %d.\n",\r\nirq, pcano, qbbno);\r\n}\r\nreturn;\r\n}\r\npca = WILDFIRE_pca(qbbno, pcano);\r\nenable0 = (unsigned long *) &pca->pca_int[0].enable;\r\n*enable0 = cached_irq_mask[qbbno * WILDFIRE_PCA_PER_QBB + pcano];\r\nmb();\r\n*enable0;\r\n}\r\nstatic void __init\r\nwildfire_init_irq_hw(void)\r\n{\r\n#if 0\r\nregister wildfire_pca * pca = WILDFIRE_pca(0, 0);\r\nvolatile unsigned long * enable0, * enable1, * enable2, *enable3;\r\nvolatile unsigned long * target0, * target1, * target2, *target3;\r\nenable0 = (unsigned long *) &pca->pca_int[0].enable;\r\nenable1 = (unsigned long *) &pca->pca_int[1].enable;\r\nenable2 = (unsigned long *) &pca->pca_int[2].enable;\r\nenable3 = (unsigned long *) &pca->pca_int[3].enable;\r\ntarget0 = (unsigned long *) &pca->pca_int[0].target;\r\ntarget1 = (unsigned long *) &pca->pca_int[1].target;\r\ntarget2 = (unsigned long *) &pca->pca_int[2].target;\r\ntarget3 = (unsigned long *) &pca->pca_int[3].target;\r\n*enable0 = *enable1 = *enable2 = *enable3 = 0;\r\n*target0 = (1UL<<8) | WILDFIRE_QBB(0);\r\n*target1 = *target2 = *target3 = 0;\r\nmb();\r\n*enable0; *enable1; *enable2; *enable3;\r\n*target0; *target1; *target2; *target3;\r\n#else\r\nint i;\r\ndoing_init_irq_hw = 1;\r\nfor (i = 0; i < WILDFIRE_NR_IRQS; i+=WILDFIRE_IRQ_PER_PCA)\r\nwildfire_update_irq_hw(i);\r\ndoing_init_irq_hw = 0;\r\n#endif\r\n}\r\nstatic void\r\nwildfire_enable_irq(struct irq_data *d)\r\n{\r\nunsigned int irq = d->irq;\r\nif (irq < 16)\r\ni8259a_enable_irq(d);\r\nspin_lock(&wildfire_irq_lock);\r\nset_bit(irq, &cached_irq_mask);\r\nwildfire_update_irq_hw(irq);\r\nspin_unlock(&wildfire_irq_lock);\r\n}\r\nstatic void\r\nwildfire_disable_irq(struct irq_data *d)\r\n{\r\nunsigned int irq = d->irq;\r\nif (irq < 16)\r\ni8259a_disable_irq(d);\r\nspin_lock(&wildfire_irq_lock);\r\nclear_bit(irq, &cached_irq_mask);\r\nwildfire_update_irq_hw(irq);\r\nspin_unlock(&wildfire_irq_lock);\r\n}\r\nstatic void\r\nwildfire_mask_and_ack_irq(struct irq_data *d)\r\n{\r\nunsigned int irq = d->irq;\r\nif (irq < 16)\r\ni8259a_mask_and_ack_irq(d);\r\nspin_lock(&wildfire_irq_lock);\r\nclear_bit(irq, &cached_irq_mask);\r\nwildfire_update_irq_hw(irq);\r\nspin_unlock(&wildfire_irq_lock);\r\n}\r\nstatic void __init\r\nwildfire_init_irq_per_pca(int qbbno, int pcano)\r\n{\r\nint i, irq_bias;\r\nstatic struct irqaction isa_enable = {\r\n.handler = no_action,\r\n.name = "isa_enable",\r\n};\r\nirq_bias = qbbno * (WILDFIRE_PCA_PER_QBB * WILDFIRE_IRQ_PER_PCA)\r\n+ pcano * WILDFIRE_IRQ_PER_PCA;\r\n#if 0\r\nunsigned long io_bias;\r\nio_bias = WILDFIRE_IO(qbbno, pcano<<1) - WILDFIRE_IO_BIAS;\r\noutb(0, DMA1_RESET_REG + io_bias);\r\noutb(0, DMA2_RESET_REG + io_bias);\r\noutb(DMA_MODE_CASCADE, DMA2_MODE_REG + io_bias);\r\noutb(0, DMA2_MASK_REG + io_bias);\r\n#endif\r\n#if 0\r\ninit_i8259a_irqs();\r\n#endif\r\nfor (i = 0; i < 16; ++i) {\r\nif (i == 2)\r\ncontinue;\r\nirq_set_chip_and_handler(i + irq_bias, &wildfire_irq_type,\r\nhandle_level_irq);\r\nirq_set_status_flags(i + irq_bias, IRQ_LEVEL);\r\n}\r\nirq_set_chip_and_handler(36 + irq_bias, &wildfire_irq_type,\r\nhandle_level_irq);\r\nirq_set_status_flags(36 + irq_bias, IRQ_LEVEL);\r\nfor (i = 40; i < 64; ++i) {\r\nirq_set_chip_and_handler(i + irq_bias, &wildfire_irq_type,\r\nhandle_level_irq);\r\nirq_set_status_flags(i + irq_bias, IRQ_LEVEL);\r\n}\r\nsetup_irq(32+irq_bias, &isa_enable);\r\n}\r\nstatic void __init\r\nwildfire_init_irq(void)\r\n{\r\nint qbbno, pcano;\r\n#if 1\r\nwildfire_init_irq_hw();\r\ninit_i8259a_irqs();\r\n#endif\r\nfor (qbbno = 0; qbbno < WILDFIRE_MAX_QBB; qbbno++) {\r\nif (WILDFIRE_QBB_EXISTS(qbbno)) {\r\nfor (pcano = 0; pcano < WILDFIRE_PCA_PER_QBB; pcano++) {\r\nif (WILDFIRE_PCA_EXISTS(qbbno, pcano)) {\r\nwildfire_init_irq_per_pca(qbbno, pcano);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void\r\nwildfire_device_interrupt(unsigned long vector)\r\n{\r\nint irq;\r\nirq = (vector - 0x800) >> 4;\r\nhandle_irq(irq);\r\nreturn;\r\n}\r\nstatic int __init\r\nwildfire_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nstatic char irq_tab[8][5] __initdata = {\r\n{ -1, -1, -1, -1, -1},\r\n{ 36, 36, 36+1, 36+2, 36+3},\r\n{ 40, 40, 40+1, 40+2, 40+3},\r\n{ 44, 44, 44+1, 44+2, 44+3},\r\n{ 48, 48, 48+1, 48+2, 48+3},\r\n{ 52, 52, 52+1, 52+2, 52+3},\r\n{ 56, 56, 56+1, 56+2, 56+3},\r\n{ 60, 60, 60+1, 60+2, 60+3},\r\n};\r\nlong min_idsel = 0, max_idsel = 7, irqs_per_slot = 5;\r\nstruct pci_controller *hose = dev->sysdata;\r\nint irq = COMMON_TABLE_LOOKUP;\r\nif (irq > 0) {\r\nint qbbno = hose->index >> 3;\r\nint pcano = (hose->index >> 1) & 3;\r\nirq += (qbbno << 8) + (pcano << 6);\r\n}\r\nreturn irq;\r\n}
