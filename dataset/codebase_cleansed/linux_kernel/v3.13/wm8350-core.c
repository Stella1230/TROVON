int wm8350_clear_bits(struct wm8350 *wm8350, u16 reg, u16 mask)\r\n{\r\nreturn regmap_update_bits(wm8350->regmap, reg, mask, 0);\r\n}\r\nint wm8350_set_bits(struct wm8350 *wm8350, u16 reg, u16 mask)\r\n{\r\nreturn regmap_update_bits(wm8350->regmap, reg, mask, mask);\r\n}\r\nu16 wm8350_reg_read(struct wm8350 *wm8350, int reg)\r\n{\r\nunsigned int data;\r\nint err;\r\nerr = regmap_read(wm8350->regmap, reg, &data);\r\nif (err)\r\ndev_err(wm8350->dev, "read from reg R%d failed\n", reg);\r\nreturn data;\r\n}\r\nint wm8350_reg_write(struct wm8350 *wm8350, int reg, u16 val)\r\n{\r\nint ret;\r\nret = regmap_write(wm8350->regmap, reg, val);\r\nif (ret)\r\ndev_err(wm8350->dev, "write to reg R%d failed\n", reg);\r\nreturn ret;\r\n}\r\nint wm8350_block_read(struct wm8350 *wm8350, int start_reg, int regs,\r\nu16 *dest)\r\n{\r\nint err = 0;\r\nerr = regmap_bulk_read(wm8350->regmap, start_reg, dest, regs);\r\nif (err)\r\ndev_err(wm8350->dev, "block read starting from R%d failed\n",\r\nstart_reg);\r\nreturn err;\r\n}\r\nint wm8350_block_write(struct wm8350 *wm8350, int start_reg, int regs,\r\nu16 *src)\r\n{\r\nint ret = 0;\r\nret = regmap_bulk_write(wm8350->regmap, start_reg, src, regs);\r\nif (ret)\r\ndev_err(wm8350->dev, "block write starting at R%d failed\n",\r\nstart_reg);\r\nreturn ret;\r\n}\r\nint wm8350_reg_lock(struct wm8350 *wm8350)\r\n{\r\nint ret;\r\nmutex_lock(&reg_lock_mutex);\r\nldbg(__func__);\r\nret = wm8350_reg_write(wm8350, WM8350_SECURITY, WM8350_LOCK_KEY);\r\nif (ret)\r\ndev_err(wm8350->dev, "lock failed\n");\r\nwm8350->unlocked = false;\r\nmutex_unlock(&reg_lock_mutex);\r\nreturn ret;\r\n}\r\nint wm8350_reg_unlock(struct wm8350 *wm8350)\r\n{\r\nint ret;\r\nmutex_lock(&reg_lock_mutex);\r\nldbg(__func__);\r\nret = wm8350_reg_write(wm8350, WM8350_SECURITY, WM8350_UNLOCK_KEY);\r\nif (ret)\r\ndev_err(wm8350->dev, "unlock failed\n");\r\nwm8350->unlocked = true;\r\nmutex_unlock(&reg_lock_mutex);\r\nreturn ret;\r\n}\r\nint wm8350_read_auxadc(struct wm8350 *wm8350, int channel, int scale, int vref)\r\n{\r\nu16 reg, result = 0;\r\nif (channel < WM8350_AUXADC_AUX1 || channel > WM8350_AUXADC_TEMP)\r\nreturn -EINVAL;\r\nif (channel >= WM8350_AUXADC_USB && channel <= WM8350_AUXADC_TEMP\r\n&& (scale != 0 || vref != 0))\r\nreturn -EINVAL;\r\nmutex_lock(&wm8350->auxadc_mutex);\r\nreg = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_5);\r\nwm8350_reg_write(wm8350, WM8350_POWER_MGMT_5, reg | WM8350_AUXADC_ENA);\r\nif (scale || vref) {\r\nreg = scale << 13;\r\nreg |= vref << 12;\r\nwm8350_reg_write(wm8350, WM8350_AUX1_READBACK + channel, reg);\r\n}\r\nreg = wm8350_reg_read(wm8350, WM8350_DIGITISER_CONTROL_1);\r\nreg |= 1 << channel | WM8350_AUXADC_POLL;\r\nwm8350_reg_write(wm8350, WM8350_DIGITISER_CONTROL_1, reg);\r\ntry_wait_for_completion(&wm8350->auxadc_done);\r\nwait_for_completion_timeout(&wm8350->auxadc_done, msecs_to_jiffies(5));\r\nreg = wm8350_reg_read(wm8350, WM8350_DIGITISER_CONTROL_1);\r\nif (reg & WM8350_AUXADC_POLL)\r\ndev_err(wm8350->dev, "adc chn %d read timeout\n", channel);\r\nelse\r\nresult = wm8350_reg_read(wm8350,\r\nWM8350_AUX1_READBACK + channel);\r\nreg = wm8350_reg_read(wm8350, WM8350_POWER_MGMT_5);\r\nwm8350_reg_write(wm8350, WM8350_POWER_MGMT_5,\r\nreg & ~WM8350_AUXADC_ENA);\r\nmutex_unlock(&wm8350->auxadc_mutex);\r\nreturn result & WM8350_AUXADC_DATA1_MASK;\r\n}\r\nstatic irqreturn_t wm8350_auxadc_irq(int irq, void *irq_data)\r\n{\r\nstruct wm8350 *wm8350 = irq_data;\r\ncomplete(&wm8350->auxadc_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void wm8350_client_dev_register(struct wm8350 *wm8350,\r\nconst char *name,\r\nstruct platform_device **pdev)\r\n{\r\nint ret;\r\n*pdev = platform_device_alloc(name, -1);\r\nif (*pdev == NULL) {\r\ndev_err(wm8350->dev, "Failed to allocate %s\n", name);\r\nreturn;\r\n}\r\n(*pdev)->dev.parent = wm8350->dev;\r\nplatform_set_drvdata(*pdev, wm8350);\r\nret = platform_device_add(*pdev);\r\nif (ret != 0) {\r\ndev_err(wm8350->dev, "Failed to register %s: %d\n", name, ret);\r\nplatform_device_put(*pdev);\r\n*pdev = NULL;\r\n}\r\n}\r\nint wm8350_device_init(struct wm8350 *wm8350, int irq,\r\nstruct wm8350_platform_data *pdata)\r\n{\r\nint ret;\r\nunsigned int id1, id2, mask_rev;\r\nunsigned int cust_id, mode, chip_rev;\r\ndev_set_drvdata(wm8350->dev, wm8350);\r\nret = regmap_read(wm8350->regmap, WM8350_RESET_ID, &id1);\r\nif (ret != 0) {\r\ndev_err(wm8350->dev, "Failed to read ID: %d\n", ret);\r\ngoto err;\r\n}\r\nret = regmap_read(wm8350->regmap, WM8350_ID, &id2);\r\nif (ret != 0) {\r\ndev_err(wm8350->dev, "Failed to read ID: %d\n", ret);\r\ngoto err;\r\n}\r\nret = regmap_read(wm8350->regmap, WM8350_REVISION, &mask_rev);\r\nif (ret != 0) {\r\ndev_err(wm8350->dev, "Failed to read revision: %d\n", ret);\r\ngoto err;\r\n}\r\nif (id1 != 0x6143) {\r\ndev_err(wm8350->dev,\r\n"Device with ID %x is not a WM8350\n", id1);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nmode = id2 & WM8350_CONF_STS_MASK >> 10;\r\ncust_id = id2 & WM8350_CUST_ID_MASK;\r\nchip_rev = (id2 & WM8350_CHIP_REV_MASK) >> 12;\r\ndev_info(wm8350->dev,\r\n"CONF_STS %d, CUST_ID %d, MASK_REV %d, CHIP_REV %d\n",\r\nmode, cust_id, mask_rev, chip_rev);\r\nif (cust_id != 0) {\r\ndev_err(wm8350->dev, "Unsupported CUST_ID\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nswitch (mask_rev) {\r\ncase 0:\r\nwm8350->pmic.max_dcdc = WM8350_DCDC_6;\r\nwm8350->pmic.max_isink = WM8350_ISINK_B;\r\nswitch (chip_rev) {\r\ncase WM8350_REV_E:\r\ndev_info(wm8350->dev, "WM8350 Rev E\n");\r\nbreak;\r\ncase WM8350_REV_F:\r\ndev_info(wm8350->dev, "WM8350 Rev F\n");\r\nbreak;\r\ncase WM8350_REV_G:\r\ndev_info(wm8350->dev, "WM8350 Rev G\n");\r\nwm8350->power.rev_g_coeff = 1;\r\nbreak;\r\ncase WM8350_REV_H:\r\ndev_info(wm8350->dev, "WM8350 Rev H\n");\r\nwm8350->power.rev_g_coeff = 1;\r\nbreak;\r\ndefault:\r\ndev_err(wm8350->dev, "Unknown WM8350 CHIP_REV\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nbreak;\r\ncase 1:\r\nwm8350->pmic.max_dcdc = WM8350_DCDC_4;\r\nwm8350->pmic.max_isink = WM8350_ISINK_A;\r\nswitch (chip_rev) {\r\ncase 0:\r\ndev_info(wm8350->dev, "WM8351 Rev A\n");\r\nwm8350->power.rev_g_coeff = 1;\r\nbreak;\r\ncase 1:\r\ndev_info(wm8350->dev, "WM8351 Rev B\n");\r\nwm8350->power.rev_g_coeff = 1;\r\nbreak;\r\ndefault:\r\ndev_err(wm8350->dev, "Unknown WM8351 CHIP_REV\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nbreak;\r\ncase 2:\r\nwm8350->pmic.max_dcdc = WM8350_DCDC_6;\r\nwm8350->pmic.max_isink = WM8350_ISINK_B;\r\nswitch (chip_rev) {\r\ncase 0:\r\ndev_info(wm8350->dev, "WM8352 Rev A\n");\r\nwm8350->power.rev_g_coeff = 1;\r\nbreak;\r\ndefault:\r\ndev_err(wm8350->dev, "Unknown WM8352 CHIP_REV\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(wm8350->dev, "Unknown MASK_REV\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nmutex_init(&wm8350->auxadc_mutex);\r\ninit_completion(&wm8350->auxadc_done);\r\nret = wm8350_irq_init(wm8350, irq, pdata);\r\nif (ret < 0)\r\ngoto err;\r\nif (wm8350->irq_base) {\r\nret = request_threaded_irq(wm8350->irq_base +\r\nWM8350_IRQ_AUXADC_DATARDY,\r\nNULL, wm8350_auxadc_irq, 0,\r\n"auxadc", wm8350);\r\nif (ret < 0)\r\ndev_warn(wm8350->dev,\r\n"Failed to request AUXADC IRQ: %d\n", ret);\r\n}\r\nif (pdata && pdata->init) {\r\nret = pdata->init(wm8350);\r\nif (ret != 0) {\r\ndev_err(wm8350->dev, "Platform init() failed: %d\n",\r\nret);\r\ngoto err_irq;\r\n}\r\n}\r\nwm8350_reg_write(wm8350, WM8350_SYSTEM_INTERRUPTS_MASK, 0x0);\r\nwm8350_client_dev_register(wm8350, "wm8350-codec",\r\n&(wm8350->codec.pdev));\r\nwm8350_client_dev_register(wm8350, "wm8350-gpio",\r\n&(wm8350->gpio.pdev));\r\nwm8350_client_dev_register(wm8350, "wm8350-hwmon",\r\n&(wm8350->hwmon.pdev));\r\nwm8350_client_dev_register(wm8350, "wm8350-power",\r\n&(wm8350->power.pdev));\r\nwm8350_client_dev_register(wm8350, "wm8350-rtc", &(wm8350->rtc.pdev));\r\nwm8350_client_dev_register(wm8350, "wm8350-wdt", &(wm8350->wdt.pdev));\r\nreturn 0;\r\nerr_irq:\r\nwm8350_irq_exit(wm8350);\r\nerr:\r\nreturn ret;\r\n}\r\nvoid wm8350_device_exit(struct wm8350 *wm8350)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(wm8350->pmic.led); i++)\r\nplatform_device_unregister(wm8350->pmic.led[i].pdev);\r\nfor (i = 0; i < ARRAY_SIZE(wm8350->pmic.pdev); i++)\r\nplatform_device_unregister(wm8350->pmic.pdev[i]);\r\nplatform_device_unregister(wm8350->wdt.pdev);\r\nplatform_device_unregister(wm8350->rtc.pdev);\r\nplatform_device_unregister(wm8350->power.pdev);\r\nplatform_device_unregister(wm8350->hwmon.pdev);\r\nplatform_device_unregister(wm8350->gpio.pdev);\r\nplatform_device_unregister(wm8350->codec.pdev);\r\nif (wm8350->irq_base)\r\nfree_irq(wm8350->irq_base + WM8350_IRQ_AUXADC_DATARDY, wm8350);\r\nwm8350_irq_exit(wm8350);\r\n}
