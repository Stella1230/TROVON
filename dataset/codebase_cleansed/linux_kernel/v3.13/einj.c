static void einj_exec_ctx_init(struct apei_exec_context *ctx)\r\n{\r\napei_exec_ctx_init(ctx, einj_ins_type, ARRAY_SIZE(einj_ins_type),\r\nEINJ_TAB_ENTRY(einj_tab), einj_tab->entries);\r\n}\r\nstatic int __einj_get_available_error_type(u32 *type)\r\n{\r\nstruct apei_exec_context ctx;\r\nint rc;\r\neinj_exec_ctx_init(&ctx);\r\nrc = apei_exec_run(&ctx, ACPI_EINJ_GET_ERROR_TYPE);\r\nif (rc)\r\nreturn rc;\r\n*type = apei_exec_ctx_get_output(&ctx);\r\nreturn 0;\r\n}\r\nstatic int einj_get_available_error_type(u32 *type)\r\n{\r\nint rc;\r\nmutex_lock(&einj_mutex);\r\nrc = __einj_get_available_error_type(type);\r\nmutex_unlock(&einj_mutex);\r\nreturn rc;\r\n}\r\nstatic int einj_timedout(u64 *t)\r\n{\r\nif ((s64)*t < SPIN_UNIT) {\r\npr_warning(FW_WARN EINJ_PFX\r\n"Firmware does not respond in time\n");\r\nreturn 1;\r\n}\r\n*t -= SPIN_UNIT;\r\nndelay(SPIN_UNIT);\r\ntouch_nmi_watchdog();\r\nreturn 0;\r\n}\r\nstatic void check_vendor_extension(u64 paddr,\r\nstruct set_error_type_with_address *v5param)\r\n{\r\nint offset = v5param->vendor_extension;\r\nstruct vendor_error_type_extension *v;\r\nu32 sbdf;\r\nif (!offset)\r\nreturn;\r\nv = acpi_os_map_memory(paddr + offset, sizeof(*v));\r\nif (!v)\r\nreturn;\r\nsbdf = v->pcie_sbdf;\r\nsprintf(vendor_dev, "%x:%x:%x.%x vendor_id=%x device_id=%x rev_id=%x\n",\r\nsbdf >> 24, (sbdf >> 16) & 0xff,\r\n(sbdf >> 11) & 0x1f, (sbdf >> 8) & 0x7,\r\nv->vendor_id, v->device_id, v->rev_id);\r\nacpi_os_unmap_memory(v, sizeof(*v));\r\n}\r\nstatic void *einj_get_parameter_address(void)\r\n{\r\nint i;\r\nu64 paddrv4 = 0, paddrv5 = 0;\r\nstruct acpi_whea_header *entry;\r\nentry = EINJ_TAB_ENTRY(einj_tab);\r\nfor (i = 0; i < einj_tab->entries; i++) {\r\nif (entry->action == ACPI_EINJ_SET_ERROR_TYPE &&\r\nentry->instruction == ACPI_EINJ_WRITE_REGISTER &&\r\nentry->register_region.space_id ==\r\nACPI_ADR_SPACE_SYSTEM_MEMORY)\r\nmemcpy(&paddrv4, &entry->register_region.address,\r\nsizeof(paddrv4));\r\nif (entry->action == ACPI_EINJ_SET_ERROR_TYPE_WITH_ADDRESS &&\r\nentry->instruction == ACPI_EINJ_WRITE_REGISTER &&\r\nentry->register_region.space_id ==\r\nACPI_ADR_SPACE_SYSTEM_MEMORY)\r\nmemcpy(&paddrv5, &entry->register_region.address,\r\nsizeof(paddrv5));\r\nentry++;\r\n}\r\nif (paddrv5) {\r\nstruct set_error_type_with_address *v5param;\r\nv5param = acpi_os_map_memory(paddrv5, sizeof(*v5param));\r\nif (v5param) {\r\nacpi5 = 1;\r\ncheck_vendor_extension(paddrv5, v5param);\r\nreturn v5param;\r\n}\r\n}\r\nif (param_extension && paddrv4) {\r\nstruct einj_parameter *v4param;\r\nv4param = acpi_os_map_memory(paddrv4, sizeof(*v4param));\r\nif (!v4param)\r\nreturn NULL;\r\nif (v4param->reserved1 || v4param->reserved2) {\r\nacpi_os_unmap_memory(v4param, sizeof(*v4param));\r\nreturn NULL;\r\n}\r\nreturn v4param;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int einj_check_trigger_header(struct acpi_einj_trigger *trigger_tab)\r\n{\r\nif (trigger_tab->header_size != sizeof(struct acpi_einj_trigger))\r\nreturn -EINVAL;\r\nif (trigger_tab->table_size > PAGE_SIZE ||\r\ntrigger_tab->table_size < trigger_tab->header_size)\r\nreturn -EINVAL;\r\nif (trigger_tab->entry_count !=\r\n(trigger_tab->table_size - trigger_tab->header_size) /\r\nsizeof(struct acpi_einj_entry))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic struct acpi_generic_address *einj_get_trigger_parameter_region(\r\nstruct acpi_einj_trigger *trigger_tab, u64 param1, u64 param2)\r\n{\r\nint i;\r\nstruct acpi_whea_header *entry;\r\nentry = (struct acpi_whea_header *)\r\n((char *)trigger_tab + sizeof(struct acpi_einj_trigger));\r\nfor (i = 0; i < trigger_tab->entry_count; i++) {\r\nif (entry->action == ACPI_EINJ_TRIGGER_ERROR &&\r\nentry->instruction == ACPI_EINJ_WRITE_REGISTER_VALUE &&\r\nentry->register_region.space_id ==\r\nACPI_ADR_SPACE_SYSTEM_MEMORY &&\r\n(entry->register_region.address & param2) == (param1 & param2))\r\nreturn &entry->register_region;\r\nentry++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int __einj_error_trigger(u64 trigger_paddr, u32 type,\r\nu64 param1, u64 param2)\r\n{\r\nstruct acpi_einj_trigger *trigger_tab = NULL;\r\nstruct apei_exec_context trigger_ctx;\r\nstruct apei_resources trigger_resources;\r\nstruct acpi_whea_header *trigger_entry;\r\nstruct resource *r;\r\nu32 table_size;\r\nint rc = -EIO;\r\nstruct acpi_generic_address *trigger_param_region = NULL;\r\nr = request_mem_region(trigger_paddr, sizeof(*trigger_tab),\r\n"APEI EINJ Trigger Table");\r\nif (!r) {\r\npr_err(EINJ_PFX\r\n"Can not request [mem %#010llx-%#010llx] for Trigger table\n",\r\n(unsigned long long)trigger_paddr,\r\n(unsigned long long)trigger_paddr +\r\nsizeof(*trigger_tab) - 1);\r\ngoto out;\r\n}\r\ntrigger_tab = ioremap_cache(trigger_paddr, sizeof(*trigger_tab));\r\nif (!trigger_tab) {\r\npr_err(EINJ_PFX "Failed to map trigger table!\n");\r\ngoto out_rel_header;\r\n}\r\nrc = einj_check_trigger_header(trigger_tab);\r\nif (rc) {\r\npr_warning(FW_BUG EINJ_PFX\r\n"The trigger error action table is invalid\n");\r\ngoto out_rel_header;\r\n}\r\nif (!trigger_tab->entry_count)\r\ngoto out_rel_header;\r\nrc = -EIO;\r\ntable_size = trigger_tab->table_size;\r\nr = request_mem_region(trigger_paddr + sizeof(*trigger_tab),\r\ntable_size - sizeof(*trigger_tab),\r\n"APEI EINJ Trigger Table");\r\nif (!r) {\r\npr_err(EINJ_PFX\r\n"Can not request [mem %#010llx-%#010llx] for Trigger Table Entry\n",\r\n(unsigned long long)trigger_paddr + sizeof(*trigger_tab),\r\n(unsigned long long)trigger_paddr + table_size - 1);\r\ngoto out_rel_header;\r\n}\r\niounmap(trigger_tab);\r\ntrigger_tab = ioremap_cache(trigger_paddr, table_size);\r\nif (!trigger_tab) {\r\npr_err(EINJ_PFX "Failed to map trigger table!\n");\r\ngoto out_rel_entry;\r\n}\r\ntrigger_entry = (struct acpi_whea_header *)\r\n((char *)trigger_tab + sizeof(struct acpi_einj_trigger));\r\napei_resources_init(&trigger_resources);\r\napei_exec_ctx_init(&trigger_ctx, einj_ins_type,\r\nARRAY_SIZE(einj_ins_type),\r\ntrigger_entry, trigger_tab->entry_count);\r\nrc = apei_exec_collect_resources(&trigger_ctx, &trigger_resources);\r\nif (rc)\r\ngoto out_fini;\r\nrc = apei_resources_sub(&trigger_resources, &einj_resources);\r\nif (rc)\r\ngoto out_fini;\r\nif ((param_extension || acpi5) && (type & MEM_ERROR_MASK) && param2) {\r\nstruct apei_resources addr_resources;\r\napei_resources_init(&addr_resources);\r\ntrigger_param_region = einj_get_trigger_parameter_region(\r\ntrigger_tab, param1, param2);\r\nif (trigger_param_region) {\r\nrc = apei_resources_add(&addr_resources,\r\ntrigger_param_region->address,\r\ntrigger_param_region->bit_width/8, true);\r\nif (rc)\r\ngoto out_fini;\r\nrc = apei_resources_sub(&trigger_resources,\r\n&addr_resources);\r\n}\r\napei_resources_fini(&addr_resources);\r\nif (rc)\r\ngoto out_fini;\r\n}\r\nrc = apei_resources_request(&trigger_resources, "APEI EINJ Trigger");\r\nif (rc)\r\ngoto out_fini;\r\nrc = apei_exec_pre_map_gars(&trigger_ctx);\r\nif (rc)\r\ngoto out_release;\r\nrc = apei_exec_run(&trigger_ctx, ACPI_EINJ_TRIGGER_ERROR);\r\napei_exec_post_unmap_gars(&trigger_ctx);\r\nout_release:\r\napei_resources_release(&trigger_resources);\r\nout_fini:\r\napei_resources_fini(&trigger_resources);\r\nout_rel_entry:\r\nrelease_mem_region(trigger_paddr + sizeof(*trigger_tab),\r\ntable_size - sizeof(*trigger_tab));\r\nout_rel_header:\r\nrelease_mem_region(trigger_paddr, sizeof(*trigger_tab));\r\nout:\r\nif (trigger_tab)\r\niounmap(trigger_tab);\r\nreturn rc;\r\n}\r\nstatic int __einj_error_inject(u32 type, u64 param1, u64 param2)\r\n{\r\nstruct apei_exec_context ctx;\r\nu64 val, trigger_paddr, timeout = FIRMWARE_TIMEOUT;\r\nint rc;\r\neinj_exec_ctx_init(&ctx);\r\nrc = apei_exec_run_optional(&ctx, ACPI_EINJ_BEGIN_OPERATION);\r\nif (rc)\r\nreturn rc;\r\napei_exec_ctx_set_input(&ctx, type);\r\nif (acpi5) {\r\nstruct set_error_type_with_address *v5param = einj_param;\r\nv5param->type = type;\r\nif (type & ACPI5_VENDOR_BIT) {\r\nswitch (vendor_flags) {\r\ncase SETWA_FLAGS_APICID:\r\nv5param->apicid = param1;\r\nbreak;\r\ncase SETWA_FLAGS_MEM:\r\nv5param->memory_address = param1;\r\nv5param->memory_address_range = param2;\r\nbreak;\r\ncase SETWA_FLAGS_PCIE_SBDF:\r\nv5param->pcie_sbdf = param1;\r\nbreak;\r\n}\r\nv5param->flags = vendor_flags;\r\n} else {\r\nswitch (type) {\r\ncase ACPI_EINJ_PROCESSOR_CORRECTABLE:\r\ncase ACPI_EINJ_PROCESSOR_UNCORRECTABLE:\r\ncase ACPI_EINJ_PROCESSOR_FATAL:\r\nv5param->apicid = param1;\r\nv5param->flags = SETWA_FLAGS_APICID;\r\nbreak;\r\ncase ACPI_EINJ_MEMORY_CORRECTABLE:\r\ncase ACPI_EINJ_MEMORY_UNCORRECTABLE:\r\ncase ACPI_EINJ_MEMORY_FATAL:\r\nv5param->memory_address = param1;\r\nv5param->memory_address_range = param2;\r\nv5param->flags = SETWA_FLAGS_MEM;\r\nbreak;\r\ncase ACPI_EINJ_PCIX_CORRECTABLE:\r\ncase ACPI_EINJ_PCIX_UNCORRECTABLE:\r\ncase ACPI_EINJ_PCIX_FATAL:\r\nv5param->pcie_sbdf = param1;\r\nv5param->flags = SETWA_FLAGS_PCIE_SBDF;\r\nbreak;\r\n}\r\n}\r\n} else {\r\nrc = apei_exec_run(&ctx, ACPI_EINJ_SET_ERROR_TYPE);\r\nif (rc)\r\nreturn rc;\r\nif (einj_param) {\r\nstruct einj_parameter *v4param = einj_param;\r\nv4param->param1 = param1;\r\nv4param->param2 = param2;\r\n}\r\n}\r\nrc = apei_exec_run(&ctx, ACPI_EINJ_EXECUTE_OPERATION);\r\nif (rc)\r\nreturn rc;\r\nfor (;;) {\r\nrc = apei_exec_run(&ctx, ACPI_EINJ_CHECK_BUSY_STATUS);\r\nif (rc)\r\nreturn rc;\r\nval = apei_exec_ctx_get_output(&ctx);\r\nif (!(val & EINJ_OP_BUSY))\r\nbreak;\r\nif (einj_timedout(&timeout))\r\nreturn -EIO;\r\n}\r\nrc = apei_exec_run(&ctx, ACPI_EINJ_GET_COMMAND_STATUS);\r\nif (rc)\r\nreturn rc;\r\nval = apei_exec_ctx_get_output(&ctx);\r\nif (val != EINJ_STATUS_SUCCESS)\r\nreturn -EBUSY;\r\nrc = apei_exec_run(&ctx, ACPI_EINJ_GET_TRIGGER_TABLE);\r\nif (rc)\r\nreturn rc;\r\ntrigger_paddr = apei_exec_ctx_get_output(&ctx);\r\nif (notrigger == 0) {\r\nrc = __einj_error_trigger(trigger_paddr, type, param1, param2);\r\nif (rc)\r\nreturn rc;\r\n}\r\nrc = apei_exec_run_optional(&ctx, ACPI_EINJ_END_OPERATION);\r\nreturn rc;\r\n}\r\nstatic int einj_error_inject(u32 type, u64 param1, u64 param2)\r\n{\r\nint rc;\r\nunsigned long pfn;\r\nif (!(param_extension || acpi5))\r\ngoto inject;\r\nif (type & ACPI5_VENDOR_BIT) {\r\nif (vendor_flags != SETWA_FLAGS_MEM)\r\ngoto inject;\r\n} else if (!(type & MEM_ERROR_MASK))\r\ngoto inject;\r\npfn = PFN_DOWN(param1 & param2);\r\nif (!page_is_ram(pfn) || ((param2 & PAGE_MASK) != PAGE_MASK))\r\nreturn -EINVAL;\r\ninject:\r\nmutex_lock(&einj_mutex);\r\nrc = __einj_error_inject(type, param1, param2);\r\nmutex_unlock(&einj_mutex);\r\nreturn rc;\r\n}\r\nstatic int available_error_type_show(struct seq_file *m, void *v)\r\n{\r\nint rc;\r\nu32 available_error_type = 0;\r\nrc = einj_get_available_error_type(&available_error_type);\r\nif (rc)\r\nreturn rc;\r\nif (available_error_type & 0x0001)\r\nseq_printf(m, "0x00000001\tProcessor Correctable\n");\r\nif (available_error_type & 0x0002)\r\nseq_printf(m, "0x00000002\tProcessor Uncorrectable non-fatal\n");\r\nif (available_error_type & 0x0004)\r\nseq_printf(m, "0x00000004\tProcessor Uncorrectable fatal\n");\r\nif (available_error_type & 0x0008)\r\nseq_printf(m, "0x00000008\tMemory Correctable\n");\r\nif (available_error_type & 0x0010)\r\nseq_printf(m, "0x00000010\tMemory Uncorrectable non-fatal\n");\r\nif (available_error_type & 0x0020)\r\nseq_printf(m, "0x00000020\tMemory Uncorrectable fatal\n");\r\nif (available_error_type & 0x0040)\r\nseq_printf(m, "0x00000040\tPCI Express Correctable\n");\r\nif (available_error_type & 0x0080)\r\nseq_printf(m, "0x00000080\tPCI Express Uncorrectable non-fatal\n");\r\nif (available_error_type & 0x0100)\r\nseq_printf(m, "0x00000100\tPCI Express Uncorrectable fatal\n");\r\nif (available_error_type & 0x0200)\r\nseq_printf(m, "0x00000200\tPlatform Correctable\n");\r\nif (available_error_type & 0x0400)\r\nseq_printf(m, "0x00000400\tPlatform Uncorrectable non-fatal\n");\r\nif (available_error_type & 0x0800)\r\nseq_printf(m, "0x00000800\tPlatform Uncorrectable fatal\n");\r\nreturn 0;\r\n}\r\nstatic int available_error_type_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, available_error_type_show, NULL);\r\n}\r\nstatic int error_type_get(void *data, u64 *val)\r\n{\r\n*val = error_type;\r\nreturn 0;\r\n}\r\nstatic int error_type_set(void *data, u64 val)\r\n{\r\nint rc;\r\nu32 available_error_type = 0;\r\nu32 tval, vendor;\r\nvendor = val & ACPI5_VENDOR_BIT;\r\ntval = val & 0x7fffffff;\r\nif (tval & (tval - 1))\r\nreturn -EINVAL;\r\nif (!vendor) {\r\nrc = einj_get_available_error_type(&available_error_type);\r\nif (rc)\r\nreturn rc;\r\nif (!(val & available_error_type))\r\nreturn -EINVAL;\r\n}\r\nerror_type = val;\r\nreturn 0;\r\n}\r\nstatic int error_inject_set(void *data, u64 val)\r\n{\r\nif (!error_type)\r\nreturn -EINVAL;\r\nreturn einj_error_inject(error_type, error_param1, error_param2);\r\n}\r\nstatic int einj_check_table(struct acpi_table_einj *einj_tab)\r\n{\r\nif ((einj_tab->header_length !=\r\n(sizeof(struct acpi_table_einj) - sizeof(einj_tab->header)))\r\n&& (einj_tab->header_length != sizeof(struct acpi_table_einj)))\r\nreturn -EINVAL;\r\nif (einj_tab->header.length < sizeof(struct acpi_table_einj))\r\nreturn -EINVAL;\r\nif (einj_tab->entries !=\r\n(einj_tab->header.length - sizeof(struct acpi_table_einj)) /\r\nsizeof(struct acpi_einj_entry))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int __init einj_init(void)\r\n{\r\nint rc;\r\nacpi_status status;\r\nstruct dentry *fentry;\r\nstruct apei_exec_context ctx;\r\nif (acpi_disabled)\r\nreturn -ENODEV;\r\nstatus = acpi_get_table(ACPI_SIG_EINJ, 0,\r\n(struct acpi_table_header **)&einj_tab);\r\nif (status == AE_NOT_FOUND)\r\nreturn -ENODEV;\r\nelse if (ACPI_FAILURE(status)) {\r\nconst char *msg = acpi_format_exception(status);\r\npr_err(EINJ_PFX "Failed to get table, %s\n", msg);\r\nreturn -EINVAL;\r\n}\r\nrc = einj_check_table(einj_tab);\r\nif (rc) {\r\npr_warning(FW_BUG EINJ_PFX "EINJ table is invalid\n");\r\nreturn -EINVAL;\r\n}\r\nrc = -ENOMEM;\r\neinj_debug_dir = debugfs_create_dir("einj", apei_get_debugfs_dir());\r\nif (!einj_debug_dir)\r\ngoto err_cleanup;\r\nfentry = debugfs_create_file("available_error_type", S_IRUSR,\r\neinj_debug_dir, NULL,\r\n&available_error_type_fops);\r\nif (!fentry)\r\ngoto err_cleanup;\r\nfentry = debugfs_create_file("error_type", S_IRUSR | S_IWUSR,\r\neinj_debug_dir, NULL, &error_type_fops);\r\nif (!fentry)\r\ngoto err_cleanup;\r\nfentry = debugfs_create_file("error_inject", S_IWUSR,\r\neinj_debug_dir, NULL, &error_inject_fops);\r\nif (!fentry)\r\ngoto err_cleanup;\r\napei_resources_init(&einj_resources);\r\neinj_exec_ctx_init(&ctx);\r\nrc = apei_exec_collect_resources(&ctx, &einj_resources);\r\nif (rc)\r\ngoto err_fini;\r\nrc = apei_resources_request(&einj_resources, "APEI EINJ");\r\nif (rc)\r\ngoto err_fini;\r\nrc = apei_exec_pre_map_gars(&ctx);\r\nif (rc)\r\ngoto err_release;\r\nrc = -ENOMEM;\r\neinj_param = einj_get_parameter_address();\r\nif ((param_extension || acpi5) && einj_param) {\r\nfentry = debugfs_create_x64("param1", S_IRUSR | S_IWUSR,\r\neinj_debug_dir, &error_param1);\r\nif (!fentry)\r\ngoto err_unmap;\r\nfentry = debugfs_create_x64("param2", S_IRUSR | S_IWUSR,\r\neinj_debug_dir, &error_param2);\r\nif (!fentry)\r\ngoto err_unmap;\r\nfentry = debugfs_create_x32("notrigger", S_IRUSR | S_IWUSR,\r\neinj_debug_dir, &notrigger);\r\nif (!fentry)\r\ngoto err_unmap;\r\n}\r\nif (vendor_dev[0]) {\r\nvendor_blob.data = vendor_dev;\r\nvendor_blob.size = strlen(vendor_dev);\r\nfentry = debugfs_create_blob("vendor", S_IRUSR,\r\neinj_debug_dir, &vendor_blob);\r\nif (!fentry)\r\ngoto err_unmap;\r\nfentry = debugfs_create_x32("vendor_flags", S_IRUSR | S_IWUSR,\r\neinj_debug_dir, &vendor_flags);\r\nif (!fentry)\r\ngoto err_unmap;\r\n}\r\npr_info(EINJ_PFX "Error INJection is initialized.\n");\r\nreturn 0;\r\nerr_unmap:\r\nif (einj_param) {\r\nacpi_size size = (acpi5) ?\r\nsizeof(struct set_error_type_with_address) :\r\nsizeof(struct einj_parameter);\r\nacpi_os_unmap_memory(einj_param, size);\r\n}\r\napei_exec_post_unmap_gars(&ctx);\r\nerr_release:\r\napei_resources_release(&einj_resources);\r\nerr_fini:\r\napei_resources_fini(&einj_resources);\r\nerr_cleanup:\r\ndebugfs_remove_recursive(einj_debug_dir);\r\nreturn rc;\r\n}\r\nstatic void __exit einj_exit(void)\r\n{\r\nstruct apei_exec_context ctx;\r\nif (einj_param) {\r\nacpi_size size = (acpi5) ?\r\nsizeof(struct set_error_type_with_address) :\r\nsizeof(struct einj_parameter);\r\nacpi_os_unmap_memory(einj_param, size);\r\n}\r\neinj_exec_ctx_init(&ctx);\r\napei_exec_post_unmap_gars(&ctx);\r\napei_resources_release(&einj_resources);\r\napei_resources_fini(&einj_resources);\r\ndebugfs_remove_recursive(einj_debug_dir);\r\n}
