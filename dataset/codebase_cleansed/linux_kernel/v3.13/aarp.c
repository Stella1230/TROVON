static void __aarp_expire(struct aarp_entry *a)\r\n{\r\nskb_queue_purge(&a->packet_queue);\r\nkfree(a);\r\n}\r\nstatic void __aarp_send_query(struct aarp_entry *a)\r\n{\r\nstatic unsigned char aarp_eth_multicast[ETH_ALEN] =\r\n{ 0x09, 0x00, 0x07, 0xFF, 0xFF, 0xFF };\r\nstruct net_device *dev = a->dev;\r\nstruct elapaarp *eah;\r\nint len = dev->hard_header_len + sizeof(*eah) + aarp_dl->header_length;\r\nstruct sk_buff *skb = alloc_skb(len, GFP_ATOMIC);\r\nstruct atalk_addr *sat = atalk_find_dev_addr(dev);\r\nif (!skb)\r\nreturn;\r\nif (!sat) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nskb_reserve(skb, dev->hard_header_len + aarp_dl->header_length);\r\nskb_reset_network_header(skb);\r\nskb_reset_transport_header(skb);\r\nskb_put(skb, sizeof(*eah));\r\nskb->protocol = htons(ETH_P_ATALK);\r\nskb->dev = dev;\r\neah = aarp_hdr(skb);\r\neah->hw_type = htons(AARP_HW_TYPE_ETHERNET);\r\neah->pa_type = htons(ETH_P_ATALK);\r\neah->hw_len = ETH_ALEN;\r\neah->pa_len = AARP_PA_ALEN;\r\neah->function = htons(AARP_REQUEST);\r\nmemcpy(eah->hw_src, dev->dev_addr, ETH_ALEN);\r\neah->pa_src_zero = 0;\r\neah->pa_src_net = sat->s_net;\r\neah->pa_src_node = sat->s_node;\r\nmemset(eah->hw_dst, '\0', ETH_ALEN);\r\neah->pa_dst_zero = 0;\r\neah->pa_dst_net = a->target_addr.s_net;\r\neah->pa_dst_node = a->target_addr.s_node;\r\naarp_dl->request(aarp_dl, skb, aarp_eth_multicast);\r\na->xmit_count++;\r\na->last_sent = jiffies;\r\n}\r\nstatic void aarp_send_reply(struct net_device *dev, struct atalk_addr *us,\r\nstruct atalk_addr *them, unsigned char *sha)\r\n{\r\nstruct elapaarp *eah;\r\nint len = dev->hard_header_len + sizeof(*eah) + aarp_dl->header_length;\r\nstruct sk_buff *skb = alloc_skb(len, GFP_ATOMIC);\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, dev->hard_header_len + aarp_dl->header_length);\r\nskb_reset_network_header(skb);\r\nskb_reset_transport_header(skb);\r\nskb_put(skb, sizeof(*eah));\r\nskb->protocol = htons(ETH_P_ATALK);\r\nskb->dev = dev;\r\neah = aarp_hdr(skb);\r\neah->hw_type = htons(AARP_HW_TYPE_ETHERNET);\r\neah->pa_type = htons(ETH_P_ATALK);\r\neah->hw_len = ETH_ALEN;\r\neah->pa_len = AARP_PA_ALEN;\r\neah->function = htons(AARP_REPLY);\r\nmemcpy(eah->hw_src, dev->dev_addr, ETH_ALEN);\r\neah->pa_src_zero = 0;\r\neah->pa_src_net = us->s_net;\r\neah->pa_src_node = us->s_node;\r\nif (!sha)\r\nmemset(eah->hw_dst, '\0', ETH_ALEN);\r\nelse\r\nmemcpy(eah->hw_dst, sha, ETH_ALEN);\r\neah->pa_dst_zero = 0;\r\neah->pa_dst_net = them->s_net;\r\neah->pa_dst_node = them->s_node;\r\naarp_dl->request(aarp_dl, skb, sha);\r\n}\r\nstatic void aarp_send_probe(struct net_device *dev, struct atalk_addr *us)\r\n{\r\nstruct elapaarp *eah;\r\nint len = dev->hard_header_len + sizeof(*eah) + aarp_dl->header_length;\r\nstruct sk_buff *skb = alloc_skb(len, GFP_ATOMIC);\r\nstatic unsigned char aarp_eth_multicast[ETH_ALEN] =\r\n{ 0x09, 0x00, 0x07, 0xFF, 0xFF, 0xFF };\r\nif (!skb)\r\nreturn;\r\nskb_reserve(skb, dev->hard_header_len + aarp_dl->header_length);\r\nskb_reset_network_header(skb);\r\nskb_reset_transport_header(skb);\r\nskb_put(skb, sizeof(*eah));\r\nskb->protocol = htons(ETH_P_ATALK);\r\nskb->dev = dev;\r\neah = aarp_hdr(skb);\r\neah->hw_type = htons(AARP_HW_TYPE_ETHERNET);\r\neah->pa_type = htons(ETH_P_ATALK);\r\neah->hw_len = ETH_ALEN;\r\neah->pa_len = AARP_PA_ALEN;\r\neah->function = htons(AARP_PROBE);\r\nmemcpy(eah->hw_src, dev->dev_addr, ETH_ALEN);\r\neah->pa_src_zero = 0;\r\neah->pa_src_net = us->s_net;\r\neah->pa_src_node = us->s_node;\r\nmemset(eah->hw_dst, '\0', ETH_ALEN);\r\neah->pa_dst_zero = 0;\r\neah->pa_dst_net = us->s_net;\r\neah->pa_dst_node = us->s_node;\r\naarp_dl->request(aarp_dl, skb, aarp_eth_multicast);\r\n}\r\nstatic void __aarp_expire_timer(struct aarp_entry **n)\r\n{\r\nstruct aarp_entry *t;\r\nwhile (*n)\r\nif (time_after(jiffies, (*n)->expires_at)) {\r\nt = *n;\r\n*n = (*n)->next;\r\n__aarp_expire(t);\r\n} else\r\nn = &((*n)->next);\r\n}\r\nstatic void __aarp_kick(struct aarp_entry **n)\r\n{\r\nstruct aarp_entry *t;\r\nwhile (*n)\r\nif ((*n)->xmit_count >= sysctl_aarp_retransmit_limit) {\r\nt = *n;\r\n*n = (*n)->next;\r\n__aarp_expire(t);\r\n} else {\r\n__aarp_send_query(*n);\r\nn = &((*n)->next);\r\n}\r\n}\r\nstatic void __aarp_expire_device(struct aarp_entry **n, struct net_device *dev)\r\n{\r\nstruct aarp_entry *t;\r\nwhile (*n)\r\nif ((*n)->dev == dev) {\r\nt = *n;\r\n*n = (*n)->next;\r\n__aarp_expire(t);\r\n} else\r\nn = &((*n)->next);\r\n}\r\nstatic void aarp_expire_timeout(unsigned long unused)\r\n{\r\nint ct;\r\nwrite_lock_bh(&aarp_lock);\r\nfor (ct = 0; ct < AARP_HASH_SIZE; ct++) {\r\n__aarp_expire_timer(&resolved[ct]);\r\n__aarp_kick(&unresolved[ct]);\r\n__aarp_expire_timer(&unresolved[ct]);\r\n__aarp_expire_timer(&proxies[ct]);\r\n}\r\nwrite_unlock_bh(&aarp_lock);\r\nmod_timer(&aarp_timer, jiffies +\r\n(unresolved_count ? sysctl_aarp_tick_time :\r\nsysctl_aarp_expiry_time));\r\n}\r\nstatic int aarp_device_event(struct notifier_block *this, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nint ct;\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nif (event == NETDEV_DOWN) {\r\nwrite_lock_bh(&aarp_lock);\r\nfor (ct = 0; ct < AARP_HASH_SIZE; ct++) {\r\n__aarp_expire_device(&resolved[ct], dev);\r\n__aarp_expire_device(&unresolved[ct], dev);\r\n__aarp_expire_device(&proxies[ct], dev);\r\n}\r\nwrite_unlock_bh(&aarp_lock);\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void __aarp_expire_all(struct aarp_entry **n)\r\n{\r\nstruct aarp_entry *t;\r\nwhile (*n) {\r\nt = *n;\r\n*n = (*n)->next;\r\n__aarp_expire(t);\r\n}\r\n}\r\nstatic void aarp_purge(void)\r\n{\r\nint ct;\r\nwrite_lock_bh(&aarp_lock);\r\nfor (ct = 0; ct < AARP_HASH_SIZE; ct++) {\r\n__aarp_expire_all(&resolved[ct]);\r\n__aarp_expire_all(&unresolved[ct]);\r\n__aarp_expire_all(&proxies[ct]);\r\n}\r\nwrite_unlock_bh(&aarp_lock);\r\n}\r\nstatic struct aarp_entry *aarp_alloc(void)\r\n{\r\nstruct aarp_entry *a = kmalloc(sizeof(*a), GFP_ATOMIC);\r\nif (a)\r\nskb_queue_head_init(&a->packet_queue);\r\nreturn a;\r\n}\r\nstatic struct aarp_entry *__aarp_find_entry(struct aarp_entry *list,\r\nstruct net_device *dev,\r\nstruct atalk_addr *sat)\r\n{\r\nwhile (list) {\r\nif (list->target_addr.s_net == sat->s_net &&\r\nlist->target_addr.s_node == sat->s_node &&\r\nlist->dev == dev)\r\nbreak;\r\nlist = list->next;\r\n}\r\nreturn list;\r\n}\r\nvoid aarp_proxy_remove(struct net_device *dev, struct atalk_addr *sa)\r\n{\r\nint hash = sa->s_node % (AARP_HASH_SIZE - 1);\r\nstruct aarp_entry *a;\r\nwrite_lock_bh(&aarp_lock);\r\na = __aarp_find_entry(proxies[hash], dev, sa);\r\nif (a)\r\na->expires_at = jiffies - 1;\r\nwrite_unlock_bh(&aarp_lock);\r\n}\r\nstatic struct atalk_addr *__aarp_proxy_find(struct net_device *dev,\r\nstruct atalk_addr *sa)\r\n{\r\nint hash = sa->s_node % (AARP_HASH_SIZE - 1);\r\nstruct aarp_entry *a = __aarp_find_entry(proxies[hash], dev, sa);\r\nreturn a ? sa : NULL;\r\n}\r\nstatic void aarp_send_probe_phase1(struct atalk_iface *iface)\r\n{\r\nstruct ifreq atreq;\r\nstruct sockaddr_at *sa = (struct sockaddr_at *)&atreq.ifr_addr;\r\nconst struct net_device_ops *ops = iface->dev->netdev_ops;\r\nsa->sat_addr.s_node = iface->address.s_node;\r\nsa->sat_addr.s_net = ntohs(iface->address.s_net);\r\nif (!(ops->ndo_do_ioctl(iface->dev, &atreq, SIOCSIFADDR))) {\r\nops->ndo_do_ioctl(iface->dev, &atreq, SIOCGIFADDR);\r\nif (iface->address.s_net != htons(sa->sat_addr.s_net) ||\r\niface->address.s_node != sa->sat_addr.s_node)\r\niface->status |= ATIF_PROBE_FAIL;\r\niface->address.s_net = htons(sa->sat_addr.s_net);\r\niface->address.s_node = sa->sat_addr.s_node;\r\n}\r\n}\r\nvoid aarp_probe_network(struct atalk_iface *atif)\r\n{\r\nif (atif->dev->type == ARPHRD_LOCALTLK ||\r\natif->dev->type == ARPHRD_PPP)\r\naarp_send_probe_phase1(atif);\r\nelse {\r\nunsigned int count;\r\nfor (count = 0; count < AARP_RETRANSMIT_LIMIT; count++) {\r\naarp_send_probe(atif->dev, &atif->address);\r\nmsleep(100);\r\nif (atif->status & ATIF_PROBE_FAIL)\r\nbreak;\r\n}\r\n}\r\n}\r\nint aarp_proxy_probe_network(struct atalk_iface *atif, struct atalk_addr *sa)\r\n{\r\nint hash, retval = -EPROTONOSUPPORT;\r\nstruct aarp_entry *entry;\r\nunsigned int count;\r\nif (atif->dev->type == ARPHRD_LOCALTLK ||\r\natif->dev->type == ARPHRD_PPP)\r\ngoto out;\r\nentry = aarp_alloc();\r\nretval = -ENOMEM;\r\nif (!entry)\r\ngoto out;\r\nentry->expires_at = -1;\r\nentry->status = ATIF_PROBE;\r\nentry->target_addr.s_node = sa->s_node;\r\nentry->target_addr.s_net = sa->s_net;\r\nentry->dev = atif->dev;\r\nwrite_lock_bh(&aarp_lock);\r\nhash = sa->s_node % (AARP_HASH_SIZE - 1);\r\nentry->next = proxies[hash];\r\nproxies[hash] = entry;\r\nfor (count = 0; count < AARP_RETRANSMIT_LIMIT; count++) {\r\naarp_send_probe(atif->dev, sa);\r\nwrite_unlock_bh(&aarp_lock);\r\nmsleep(100);\r\nwrite_lock_bh(&aarp_lock);\r\nif (entry->status & ATIF_PROBE_FAIL)\r\nbreak;\r\n}\r\nif (entry->status & ATIF_PROBE_FAIL) {\r\nentry->expires_at = jiffies - 1;\r\nretval = -EADDRINUSE;\r\n} else {\r\nentry->status &= ~ATIF_PROBE;\r\nretval = 1;\r\n}\r\nwrite_unlock_bh(&aarp_lock);\r\nout:\r\nreturn retval;\r\n}\r\nint aarp_send_ddp(struct net_device *dev, struct sk_buff *skb,\r\nstruct atalk_addr *sa, void *hwaddr)\r\n{\r\nstatic char ddp_eth_multicast[ETH_ALEN] =\r\n{ 0x09, 0x00, 0x07, 0xFF, 0xFF, 0xFF };\r\nint hash;\r\nstruct aarp_entry *a;\r\nskb_reset_network_header(skb);\r\nif (dev->type == ARPHRD_LOCALTLK) {\r\nstruct atalk_addr *at = atalk_find_dev_addr(dev);\r\nstruct ddpehdr *ddp = (struct ddpehdr *)skb->data;\r\nint ft = 2;\r\nif ((!ddp->deh_snet || at->s_net == ddp->deh_snet) &&\r\n(!ddp->deh_dnet || at->s_net == ddp->deh_dnet)) {\r\nskb_pull(skb, sizeof(*ddp) - 4);\r\n*((__be16 *)skb->data) = htons(skb->len);\r\nft = 1;\r\n}\r\nskb_push(skb, 3);\r\nskb->data[0] = sa->s_node;\r\nskb->data[1] = at->s_node;\r\nskb->data[2] = ft;\r\nskb->dev = dev;\r\ngoto sendit;\r\n}\r\nif (dev->type == ARPHRD_PPP) {\r\nskb->protocol = htons(ETH_P_PPPTALK);\r\nskb->dev = dev;\r\ngoto sendit;\r\n}\r\nif (dev->type != ARPHRD_ETHER)\r\ngoto free_it;\r\nskb->dev = dev;\r\nskb->protocol = htons(ETH_P_ATALK);\r\nhash = sa->s_node % (AARP_HASH_SIZE - 1);\r\nif (sa->s_node == ATADDR_BCAST) {\r\nddp_dl->request(ddp_dl, skb, ddp_eth_multicast);\r\ngoto sent;\r\n}\r\nwrite_lock_bh(&aarp_lock);\r\na = __aarp_find_entry(resolved[hash], dev, sa);\r\nif (a) {\r\na->expires_at = jiffies + (sysctl_aarp_expiry_time * 10);\r\nddp_dl->request(ddp_dl, skb, a->hwaddr);\r\nwrite_unlock_bh(&aarp_lock);\r\ngoto sent;\r\n}\r\na = __aarp_find_entry(unresolved[hash], dev, sa);\r\nif (a) {\r\nskb_queue_tail(&a->packet_queue, skb);\r\ngoto out_unlock;\r\n}\r\na = aarp_alloc();\r\nif (!a) {\r\nwrite_unlock_bh(&aarp_lock);\r\ngoto free_it;\r\n}\r\nskb_queue_tail(&a->packet_queue, skb);\r\na->expires_at = jiffies + sysctl_aarp_resolve_time;\r\na->dev = dev;\r\na->next = unresolved[hash];\r\na->target_addr = *sa;\r\na->xmit_count = 0;\r\nunresolved[hash] = a;\r\nunresolved_count++;\r\n__aarp_send_query(a);\r\nif (unresolved_count == 1)\r\nmod_timer(&aarp_timer, jiffies + sysctl_aarp_tick_time);\r\nout_unlock:\r\nwrite_unlock_bh(&aarp_lock);\r\ngoto sent;\r\nsendit:\r\nif (skb->sk)\r\nskb->priority = skb->sk->sk_priority;\r\nif (dev_queue_xmit(skb))\r\ngoto drop;\r\nsent:\r\nreturn NET_XMIT_SUCCESS;\r\nfree_it:\r\nkfree_skb(skb);\r\ndrop:\r\nreturn NET_XMIT_DROP;\r\n}\r\nstatic void __aarp_resolved(struct aarp_entry **list, struct aarp_entry *a,\r\nint hash)\r\n{\r\nstruct sk_buff *skb;\r\nwhile (*list)\r\nif (*list == a) {\r\nunresolved_count--;\r\n*list = a->next;\r\na->next = resolved[hash];\r\nresolved[hash] = a;\r\nwhile ((skb = skb_dequeue(&a->packet_queue)) != NULL) {\r\na->expires_at = jiffies +\r\nsysctl_aarp_expiry_time * 10;\r\nddp_dl->request(ddp_dl, skb, a->hwaddr);\r\n}\r\n} else\r\nlist = &((*list)->next);\r\n}\r\nstatic int aarp_rcv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nstruct elapaarp *ea = aarp_hdr(skb);\r\nint hash, ret = 0;\r\n__u16 function;\r\nstruct aarp_entry *a;\r\nstruct atalk_addr sa, *ma, da;\r\nstruct atalk_iface *ifa;\r\nif (!net_eq(dev_net(dev), &init_net))\r\ngoto out0;\r\nif (dev->type != ARPHRD_ETHER)\r\ngoto out0;\r\nif (!skb_pull(skb, sizeof(*ea)))\r\ngoto out0;\r\nfunction = ntohs(ea->function);\r\nif (function < AARP_REQUEST || function > AARP_PROBE ||\r\nea->hw_len != ETH_ALEN || ea->pa_len != AARP_PA_ALEN ||\r\nea->pa_src_zero || ea->pa_dst_zero)\r\ngoto out0;\r\nhash = ea->pa_src_node % (AARP_HASH_SIZE - 1);\r\nsa.s_node = ea->pa_src_node;\r\nsa.s_net = ea->pa_src_net;\r\nifa = atalk_find_dev(dev);\r\nif (!ifa)\r\ngoto out1;\r\nif (ifa->status & ATIF_PROBE &&\r\nifa->address.s_node == ea->pa_dst_node &&\r\nifa->address.s_net == ea->pa_dst_net) {\r\nifa->status |= ATIF_PROBE_FAIL;\r\ngoto out1;\r\n}\r\nda.s_node = ea->pa_dst_node;\r\nda.s_net = ea->pa_dst_net;\r\nwrite_lock_bh(&aarp_lock);\r\na = __aarp_find_entry(proxies[hash], dev, &da);\r\nif (a && a->status & ATIF_PROBE) {\r\na->status |= ATIF_PROBE_FAIL;\r\ngoto unlock;\r\n}\r\nswitch (function) {\r\ncase AARP_REPLY:\r\nif (!unresolved_count)\r\nbreak;\r\na = __aarp_find_entry(unresolved[hash], dev, &sa);\r\nif (!a || dev != a->dev)\r\nbreak;\r\nmemcpy(a->hwaddr, ea->hw_src, ETH_ALEN);\r\n__aarp_resolved(&unresolved[hash], a, hash);\r\nif (!unresolved_count)\r\nmod_timer(&aarp_timer,\r\njiffies + sysctl_aarp_expiry_time);\r\nbreak;\r\ncase AARP_REQUEST:\r\ncase AARP_PROBE:\r\nsa.s_node = ea->pa_dst_node;\r\nsa.s_net = ea->pa_dst_net;\r\nma = __aarp_proxy_find(dev, &sa);\r\nif (!ma)\r\nma = &ifa->address;\r\nelse {\r\nda.s_node = sa.s_node;\r\nda.s_net = sa.s_net;\r\nma = &da;\r\n}\r\nif (function == AARP_PROBE) {\r\na = __aarp_find_entry(resolved[sa.s_node %\r\n(AARP_HASH_SIZE - 1)],\r\nskb->dev, &sa);\r\nif (a) {\r\na->expires_at = jiffies - 1;\r\nmod_timer(&aarp_timer, jiffies +\r\nsysctl_aarp_tick_time);\r\n}\r\n}\r\nif (sa.s_node != ma->s_node)\r\nbreak;\r\nif (sa.s_net && ma->s_net && sa.s_net != ma->s_net)\r\nbreak;\r\nsa.s_node = ea->pa_src_node;\r\nsa.s_net = ea->pa_src_net;\r\naarp_send_reply(dev, ma, &sa, ea->hw_src);\r\nbreak;\r\n}\r\nunlock:\r\nwrite_unlock_bh(&aarp_lock);\r\nout1:\r\nret = 1;\r\nout0:\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nvoid __init aarp_proto_init(void)\r\n{\r\naarp_dl = register_snap_client(aarp_snap_id, aarp_rcv);\r\nif (!aarp_dl)\r\nprintk(KERN_CRIT "Unable to register AARP with SNAP.\n");\r\nsetup_timer(&aarp_timer, aarp_expire_timeout, 0);\r\naarp_timer.expires = jiffies + sysctl_aarp_expiry_time;\r\nadd_timer(&aarp_timer);\r\nregister_netdevice_notifier(&aarp_notifier);\r\n}\r\nvoid aarp_device_down(struct net_device *dev)\r\n{\r\nint ct;\r\nwrite_lock_bh(&aarp_lock);\r\nfor (ct = 0; ct < AARP_HASH_SIZE; ct++) {\r\n__aarp_expire_device(&resolved[ct], dev);\r\n__aarp_expire_device(&unresolved[ct], dev);\r\n__aarp_expire_device(&proxies[ct], dev);\r\n}\r\nwrite_unlock_bh(&aarp_lock);\r\n}\r\nstatic struct aarp_entry *iter_next(struct aarp_iter_state *iter, loff_t *pos)\r\n{\r\nint ct = iter->bucket;\r\nstruct aarp_entry **table = iter->table;\r\nloff_t off = 0;\r\nstruct aarp_entry *entry;\r\nrescan:\r\nwhile(ct < AARP_HASH_SIZE) {\r\nfor (entry = table[ct]; entry; entry = entry->next) {\r\nif (!pos || ++off == *pos) {\r\niter->table = table;\r\niter->bucket = ct;\r\nreturn entry;\r\n}\r\n}\r\n++ct;\r\n}\r\nif (table == resolved) {\r\nct = 0;\r\ntable = unresolved;\r\ngoto rescan;\r\n}\r\nif (table == unresolved) {\r\nct = 0;\r\ntable = proxies;\r\ngoto rescan;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *aarp_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(aarp_lock)\r\n{\r\nstruct aarp_iter_state *iter = seq->private;\r\nread_lock_bh(&aarp_lock);\r\niter->table = resolved;\r\niter->bucket = 0;\r\nreturn *pos ? iter_next(iter, pos) : SEQ_START_TOKEN;\r\n}\r\nstatic void *aarp_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct aarp_entry *entry = v;\r\nstruct aarp_iter_state *iter = seq->private;\r\n++*pos;\r\nif (v == SEQ_START_TOKEN)\r\nentry = iter_next(iter, NULL);\r\nelse if (entry->next)\r\nentry = entry->next;\r\nelse {\r\n++iter->bucket;\r\nentry = iter_next(iter, NULL);\r\n}\r\nreturn entry;\r\n}\r\nstatic void aarp_seq_stop(struct seq_file *seq, void *v)\r\n__releases(aarp_lock)\r\n{\r\nread_unlock_bh(&aarp_lock);\r\n}\r\nstatic const char *dt2str(unsigned long ticks)\r\n{\r\nstatic char buf[32];\r\nsprintf(buf, "%ld.%02ld", ticks / HZ, ((ticks % HZ) * 100 ) / HZ);\r\nreturn buf;\r\n}\r\nstatic int aarp_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct aarp_iter_state *iter = seq->private;\r\nstruct aarp_entry *entry = v;\r\nunsigned long now = jiffies;\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq,\r\n"Address Interface Hardware Address"\r\n" Expires LastSend Retry Status\n");\r\nelse {\r\nseq_printf(seq, "%04X:%02X %-12s",\r\nntohs(entry->target_addr.s_net),\r\n(unsigned int) entry->target_addr.s_node,\r\nentry->dev ? entry->dev->name : "????");\r\nseq_printf(seq, "%pM", entry->hwaddr);\r\nseq_printf(seq, " %8s",\r\ndt2str((long)entry->expires_at - (long)now));\r\nif (iter->table == unresolved)\r\nseq_printf(seq, " %8s %6hu",\r\ndt2str(now - entry->last_sent),\r\nentry->xmit_count);\r\nelse\r\nseq_puts(seq, " ");\r\nseq_printf(seq, " %s\n",\r\n(iter->table == resolved) ? "resolved"\r\n: (iter->table == unresolved) ? "unresolved"\r\n: (iter->table == proxies) ? "proxies"\r\n: "unknown");\r\n}\r\nreturn 0;\r\n}\r\nstatic int aarp_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_private(file, &aarp_seq_ops,\r\nsizeof(struct aarp_iter_state));\r\n}\r\nvoid aarp_cleanup_module(void)\r\n{\r\ndel_timer_sync(&aarp_timer);\r\nunregister_netdevice_notifier(&aarp_notifier);\r\nunregister_snap_client(aarp_dl);\r\naarp_purge();\r\n}
