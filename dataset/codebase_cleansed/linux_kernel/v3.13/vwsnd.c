static void dbgassert(const char *fcn, int line, const char *expr)\r\n{\r\nif (in_interrupt())\r\npanic("ASSERTION FAILED IN INTERRUPT, %s:%s:%d %s\n",\r\n__FILE__, fcn, line, expr);\r\nelse {\r\nint x;\r\nprintk(KERN_ERR "ASSERTION FAILED, %s:%s:%d %s\n",\r\n__FILE__, fcn, line, expr);\r\nx = * (volatile int *) 0;\r\n}\r\n}\r\nstatic void li_destroy(lithium_t *lith)\r\n{\r\nif (lith->page0) {\r\niounmap(lith->page0);\r\nlith->page0 = NULL;\r\n}\r\nif (lith->page1) {\r\niounmap(lith->page1);\r\nlith->page1 = NULL;\r\n}\r\nif (lith->page2) {\r\niounmap(lith->page2);\r\nlith->page2 = NULL;\r\n}\r\n}\r\nstatic int __init li_create(lithium_t *lith, unsigned long baseaddr)\r\n{\r\nspin_lock_init(&lith->lock);\r\nlith->page0 = ioremap_nocache(baseaddr + LI_PAGE0_OFFSET, PAGE_SIZE);\r\nlith->page1 = ioremap_nocache(baseaddr + LI_PAGE1_OFFSET, PAGE_SIZE);\r\nlith->page2 = ioremap_nocache(baseaddr + LI_PAGE2_OFFSET, PAGE_SIZE);\r\nif (!lith->page0 || !lith->page1 || !lith->page2) {\r\nli_destroy(lith);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic __inline__ unsigned long li_readl(lithium_t *lith, int off)\r\n{\r\nreturn * (volatile unsigned long *) (lith->page0 + off);\r\n}\r\nstatic __inline__ unsigned char li_readb(lithium_t *lith, int off)\r\n{\r\nreturn * (volatile unsigned char *) (lith->page0 + off);\r\n}\r\nstatic __inline__ void li_writel(lithium_t *lith, int off, unsigned long val)\r\n{\r\n* (volatile unsigned long *) (lith->page0 + off) = val;\r\n}\r\nstatic __inline__ void li_writeb(lithium_t *lith, int off, unsigned char val)\r\n{\r\n* (volatile unsigned char *) (lith->page0 + off) = val;\r\n}\r\nstatic int li_ad1843_wait(lithium_t *lith)\r\n{\r\nunsigned long later = jiffies + 2;\r\nwhile (li_readl(lith, LI_CODEC_COMMAND) & LI_CC_BUSY)\r\nif (time_after_eq(jiffies, later))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int li_read_ad1843_reg(lithium_t *lith, int reg)\r\n{\r\nint val;\r\nASSERT(!in_interrupt());\r\nspin_lock(&lith->lock);\r\n{\r\nval = li_ad1843_wait(lith);\r\nif (val == 0) {\r\nli_writel(lith, LI_CODEC_COMMAND, LI_CC_DIR_RD | reg);\r\nval = li_ad1843_wait(lith);\r\n}\r\nif (val == 0)\r\nval = li_readl(lith, LI_CODEC_DATA);\r\n}\r\nspin_unlock(&lith->lock);\r\nDBGXV("li_read_ad1843_reg(lith=0x%p, reg=%d) returns 0x%04x\n",\r\nlith, reg, val);\r\nreturn val;\r\n}\r\nstatic void li_write_ad1843_reg(lithium_t *lith, int reg, int newval)\r\n{\r\nspin_lock(&lith->lock);\r\n{\r\nif (li_ad1843_wait(lith) == 0) {\r\nli_writel(lith, LI_CODEC_DATA, newval);\r\nli_writel(lith, LI_CODEC_COMMAND, LI_CC_DIR_WR | reg);\r\n}\r\n}\r\nspin_unlock(&lith->lock);\r\n}\r\nstatic void li_setup_dma(dma_chan_t *chan,\r\nconst dma_chan_desc_t *desc,\r\nlithium_t *lith,\r\nunsigned long buffer_paddr,\r\nint bufshift,\r\nint fragshift,\r\nint channels,\r\nint sampsize)\r\n{\r\nunsigned long mode, format;\r\nunsigned long size, tmask;\r\nDBGEV("(chan=0x%p, desc=0x%p, lith=0x%p, buffer_paddr=0x%lx, "\r\n"bufshift=%d, fragshift=%d, channels=%d, sampsize=%d)\n",\r\nchan, desc, lith, buffer_paddr,\r\nbufshift, fragshift, channels, sampsize);\r\nli_writel(lith, desc->ctlreg, LI_CCTL_RESET);\r\nASSERT(channels == 1 || channels == 2);\r\nif (channels == 2)\r\nmode = LI_CCFG_MODE_STEREO;\r\nelse\r\nmode = LI_CCFG_MODE_MONO;\r\nASSERT(sampsize == 1 || sampsize == 2);\r\nif (sampsize == 2)\r\nformat = LI_CCFG_FMT_16BIT;\r\nelse\r\nformat = LI_CCFG_FMT_8BIT;\r\nchan->desc = desc;\r\nchan->lith = lith;\r\nASSERT(!(buffer_paddr & 0xFF));\r\nchan->baseval = (buffer_paddr >> 8) | 1 << (37 - 8);\r\nchan->cfgval = ((chan->cfgval & ~LI_CCFG_LOCK) |\r\nSHIFT_FIELD(desc->ad1843_slot, LI_CCFG_SLOT) |\r\ndesc->direction |\r\nmode |\r\nformat);\r\nsize = bufshift - 6;\r\ntmask = 13 - fragshift;\r\nASSERT(size >= 2 && size <= 7);\r\nASSERT(tmask >= 1 && tmask <= 7);\r\nchan->ctlval = ((chan->ctlval & ~LI_CCTL_RESET) |\r\nSHIFT_FIELD(size, LI_CCTL_SIZE) |\r\n(chan->ctlval & ~LI_CCTL_DMA_ENABLE) |\r\nSHIFT_FIELD(tmask, LI_CCTL_TMASK) |\r\nSHIFT_FIELD(0, LI_CCTL_TPTR));\r\nDBGPV("basereg 0x%x = 0x%lx\n", desc->basereg, chan->baseval);\r\nDBGPV("cfgreg 0x%x = 0x%lx\n", desc->cfgreg, chan->cfgval);\r\nDBGPV("ctlreg 0x%x = 0x%lx\n", desc->ctlreg, chan->ctlval);\r\nli_writel(lith, desc->basereg, chan->baseval);\r\nli_writel(lith, desc->cfgreg, chan->cfgval);\r\nli_writel(lith, desc->ctlreg, chan->ctlval);\r\nDBGRV();\r\n}\r\nstatic void li_shutdown_dma(dma_chan_t *chan)\r\n{\r\nlithium_t *lith = chan->lith;\r\nvoid * lith1 = lith->page1;\r\nDBGEV("(chan=0x%p)\n", chan);\r\nchan->ctlval &= ~LI_CCTL_DMA_ENABLE;\r\nDBGPV("ctlreg 0x%x = 0x%lx\n", chan->desc->ctlreg, chan->ctlval);\r\nli_writel(lith, chan->desc->ctlreg, chan->ctlval);\r\nif (lith1 && chan->desc->direction == LI_CCFG_DIR_OUT)\r\n* (volatile unsigned long *) (lith1 + 0x500) = 0;\r\n}\r\nstatic __inline__ void li_activate_dma(dma_chan_t *chan)\r\n{\r\nchan->ctlval |= LI_CCTL_DMA_ENABLE;\r\nDBGPV("ctlval = 0x%lx\n", chan->ctlval);\r\nli_writel(chan->lith, chan->desc->ctlreg, chan->ctlval);\r\n}\r\nstatic void li_deactivate_dma(dma_chan_t *chan)\r\n{\r\nlithium_t *lith = chan->lith;\r\nvoid * lith2 = lith->page2;\r\nchan->ctlval &= ~(LI_CCTL_DMA_ENABLE | LI_CCTL_RPTR | LI_CCTL_WPTR);\r\nDBGPV("ctlval = 0x%lx\n", chan->ctlval);\r\nDBGPV("ctlreg 0x%x = 0x%lx\n", chan->desc->ctlreg, chan->ctlval);\r\nli_writel(lith, chan->desc->ctlreg, chan->ctlval);\r\nif (lith2 && chan->desc->direction == LI_CCFG_DIR_OUT) {\r\n* (volatile unsigned long *) (lith2 + 0x98) = 0;\r\n* (volatile unsigned long *) (lith2 + 0x9C) = 0;\r\n}\r\n}\r\nstatic __inline__ int li_read_swptr(dma_chan_t *chan)\r\n{\r\nconst unsigned long mask = chan->desc->swptrmask;\r\nreturn CHUNKS_TO_BYTES(UNSHIFT_FIELD(chan->ctlval, mask));\r\n}\r\nstatic __inline__ int li_read_hwptr(dma_chan_t *chan)\r\n{\r\nreturn CHUNKS_TO_BYTES(li_readb(chan->lith, chan->desc->hwptrreg));\r\n}\r\nstatic __inline__ void li_write_swptr(dma_chan_t *chan, int val)\r\n{\r\nconst unsigned long mask = chan->desc->swptrmask;\r\nASSERT(!(val & ~CHUNKS_TO_BYTES(0xFF)));\r\nval = BYTES_TO_CHUNKS(val);\r\nchan->ctlval = (chan->ctlval & ~mask) | SHIFT_FIELD(val, mask);\r\nli_writeb(chan->lith, chan->desc->swptrreg, val);\r\n}\r\nstatic void li_read_USTMSC(dma_chan_t *chan, ustmsc_t *ustmsc)\r\n{\r\nlithium_t *lith = chan->lith;\r\nconst dma_chan_desc_t *desc = chan->desc;\r\nunsigned long now_low, now_high0, now_high1, chan_ust;\r\nspin_lock(&lith->lock);\r\n{\r\ndo {\r\nnow_high0 = li_readl(lith, LI_UST_HIGH);\r\nnow_low = li_readl(lith, LI_UST_LOW);\r\nustmsc->msc = li_readl(lith, desc->mscreg);\r\nchan_ust = li_readl(lith, desc->ustreg);\r\nnow_high1 = li_readl(lith, LI_UST_HIGH);\r\n} while (now_high0 != now_high1);\r\n}\r\nspin_unlock(&lith->lock);\r\nustmsc->ust = ((unsigned long long) now_high0 << 32 | chan_ust);\r\n}\r\nstatic void li_enable_interrupts(lithium_t *lith, unsigned int mask)\r\n{\r\nDBGEV("(lith=0x%p, mask=0x%x)\n", lith, mask);\r\nli_writel(lith, LI_INTR_STATUS, mask);\r\nmask |= li_readl(lith, LI_INTR_MASK);\r\nli_writel(lith, LI_INTR_MASK, mask);\r\n}\r\nstatic void li_disable_interrupts(lithium_t *lith, unsigned int mask)\r\n{\r\nunsigned int keepmask;\r\nDBGEV("(lith=0x%p, mask=0x%x)\n", lith, mask);\r\nkeepmask = li_readl(lith, LI_INTR_MASK) & ~mask;\r\nli_writel(lith, LI_INTR_MASK, keepmask);\r\nli_writel(lith, LI_INTR_STATUS, mask);\r\n}\r\nstatic unsigned int li_get_clear_intr_status(lithium_t *lith)\r\n{\r\nunsigned int status;\r\nstatus = li_readl(lith, LI_INTR_STATUS);\r\nli_writel(lith, LI_INTR_STATUS, ~0);\r\nreturn status & li_readl(lith, LI_INTR_MASK);\r\n}\r\nstatic int li_init(lithium_t *lith)\r\n{\r\nli_writel(lith, LI_HOST_CONTROLLER, LI_HC_RESET);\r\nudelay(1);\r\nli_writel(lith, LI_HOST_CONTROLLER, LI_HC_LINK_ENABLE);\r\nudelay(1);\r\nreturn 0;\r\n}\r\nstatic int ad1843_read_bits(lithium_t *lith, const ad1843_bitfield_t *field)\r\n{\r\nint w = li_read_ad1843_reg(lith, field->reg);\r\nint val = w >> field->lo_bit & ((1 << field->nbits) - 1);\r\nDBGXV("ad1843_read_bits(lith=0x%p, field->{%d %d %d}) returns 0x%x\n",\r\nlith, field->reg, field->lo_bit, field->nbits, val);\r\nreturn val;\r\n}\r\nstatic int ad1843_write_bits(lithium_t *lith,\r\nconst ad1843_bitfield_t *field,\r\nint newval)\r\n{\r\nint w = li_read_ad1843_reg(lith, field->reg);\r\nint mask = ((1 << field->nbits) - 1) << field->lo_bit;\r\nint oldval = (w & mask) >> field->lo_bit;\r\nint newbits = (newval << field->lo_bit) & mask;\r\nw = (w & ~mask) | newbits;\r\n(void) li_write_ad1843_reg(lith, field->reg, w);\r\nDBGXV("ad1843_write_bits(lith=0x%p, field->{%d %d %d}, val=0x%x) "\r\n"returns 0x%x\n",\r\nlith, field->reg, field->lo_bit, field->nbits, newval,\r\noldval);\r\nreturn oldval;\r\n}\r\nstatic void ad1843_read_multi(lithium_t *lith, int argcount, ...)\r\n{\r\nva_list ap;\r\nconst ad1843_bitfield_t *fp;\r\nint w = 0, mask, *value, reg = -1;\r\nva_start(ap, argcount);\r\nwhile (--argcount >= 0) {\r\nfp = va_arg(ap, const ad1843_bitfield_t *);\r\nvalue = va_arg(ap, int *);\r\nif (reg == -1) {\r\nreg = fp->reg;\r\nw = li_read_ad1843_reg(lith, reg);\r\n}\r\nASSERT(reg == fp->reg);\r\nmask = (1 << fp->nbits) - 1;\r\n*value = w >> fp->lo_bit & mask;\r\n}\r\nva_end(ap);\r\n}\r\nstatic void ad1843_write_multi(lithium_t *lith, int argcount, ...)\r\n{\r\nva_list ap;\r\nint reg;\r\nconst ad1843_bitfield_t *fp;\r\nint value;\r\nint w, m, mask, bits;\r\nmask = 0;\r\nbits = 0;\r\nreg = -1;\r\nva_start(ap, argcount);\r\nwhile (--argcount >= 0) {\r\nfp = va_arg(ap, const ad1843_bitfield_t *);\r\nvalue = va_arg(ap, int);\r\nif (reg == -1)\r\nreg = fp->reg;\r\nASSERT(fp->reg == reg);\r\nm = ((1 << fp->nbits) - 1) << fp->lo_bit;\r\nmask |= m;\r\nbits |= (value << fp->lo_bit) & m;\r\n}\r\nva_end(ap);\r\nASSERT(!(bits & ~mask));\r\nif (~mask & 0xFFFF)\r\nw = li_read_ad1843_reg(lith, reg);\r\nelse\r\nw = 0;\r\nw = (w & ~mask) | bits;\r\n(void) li_write_ad1843_reg(lith, reg, w);\r\n}\r\nstatic int ad1843_get_gain(lithium_t *lith, const ad1843_gain_t *gp)\r\n{\r\nint lg, rg;\r\nunsigned short mask = (1 << gp->lfield->nbits) - 1;\r\nad1843_read_multi(lith, 2, gp->lfield, &lg, gp->rfield, &rg);\r\nif (gp->negative) {\r\nlg = mask - lg;\r\nrg = mask - rg;\r\n}\r\nlg = (lg * 100 + (mask >> 1)) / mask;\r\nrg = (rg * 100 + (mask >> 1)) / mask;\r\nreturn lg << 0 | rg << 8;\r\n}\r\nstatic int ad1843_set_gain(lithium_t *lith,\r\nconst ad1843_gain_t *gp,\r\nint newval)\r\n{\r\nunsigned short mask = (1 << gp->lfield->nbits) - 1;\r\nint lg = newval >> 0 & 0xFF;\r\nint rg = newval >> 8;\r\nif (lg < 0 || lg > 100 || rg < 0 || rg > 100)\r\nreturn -EINVAL;\r\nlg = (lg * mask + (mask >> 1)) / 100;\r\nrg = (rg * mask + (mask >> 1)) / 100;\r\nif (gp->negative) {\r\nlg = mask - lg;\r\nrg = mask - rg;\r\n}\r\nad1843_write_multi(lith, 2, gp->lfield, lg, gp->rfield, rg);\r\nreturn ad1843_get_gain(lith, gp);\r\n}\r\nstatic int ad1843_get_recsrc(lithium_t *lith)\r\n{\r\nint ls = ad1843_read_bits(lith, &ad1843_LSS);\r\nswitch (ls) {\r\ncase 1:\r\nreturn SOUND_MASK_MIC;\r\ncase 2:\r\nreturn SOUND_MASK_LINE;\r\ncase 3:\r\nreturn SOUND_MASK_CD;\r\ncase 6:\r\nreturn SOUND_MASK_PCM;\r\ndefault:\r\nASSERT(0);\r\nreturn -1;\r\n}\r\n}\r\nstatic void ad1843_set_resample_mode(lithium_t *lith, int onoff)\r\n{\r\nint save_da1 = li_read_ad1843_reg(lith, 9);\r\nad1843_write_multi(lith, 4,\r\n&ad1843_DA1EN, 0,\r\n&ad1843_DA2EN, 0,\r\n&ad1843_ADLEN, 0,\r\n&ad1843_ADREN, 0);\r\nASSERT(onoff == 0 || onoff == 1);\r\nad1843_write_bits(lith, &ad1843_DRSFLT, onoff);\r\nad1843_write_multi(lith, 3,\r\n&ad1843_DA1EN, 1,\r\n&ad1843_ADLEN, 1,\r\n&ad1843_ADREN, 1);\r\nli_write_ad1843_reg(lith, 9, save_da1);\r\n}\r\nstatic int ad1843_set_recsrc(lithium_t *lith, int newsrc)\r\n{\r\nint bits;\r\nint oldbits;\r\nswitch (newsrc) {\r\ncase SOUND_MASK_PCM:\r\nbits = 6;\r\nbreak;\r\ncase SOUND_MASK_MIC:\r\nbits = 1;\r\nbreak;\r\ncase SOUND_MASK_LINE:\r\nbits = 2;\r\nbreak;\r\ncase SOUND_MASK_CD:\r\nbits = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\noldbits = ad1843_read_bits(lith, &ad1843_LSS);\r\nif (newsrc == SOUND_MASK_PCM && oldbits != 6) {\r\nDBGP("enabling digital resample mode\n");\r\nad1843_set_resample_mode(lith, 1);\r\nad1843_write_multi(lith, 2,\r\n&ad1843_DAADL, 2,\r\n&ad1843_DAADR, 2);\r\n} else if (newsrc != SOUND_MASK_PCM && oldbits == 6) {\r\nDBGP("disabling digital resample mode\n");\r\nad1843_set_resample_mode(lith, 0);\r\nad1843_write_multi(lith, 2,\r\n&ad1843_DAADL, 0,\r\n&ad1843_DAADR, 0);\r\n}\r\nad1843_write_multi(lith, 2, &ad1843_LSS, bits, &ad1843_RSS, bits);\r\nreturn newsrc;\r\n}\r\nstatic int ad1843_get_outsrc(lithium_t *lith)\r\n{\r\nint pcm, line, mic, cd;\r\npcm = ad1843_read_bits(lith, &ad1843_LDA1GM) ? 0 : SOUND_MASK_PCM;\r\nline = ad1843_read_bits(lith, &ad1843_LX1MM) ? 0 : SOUND_MASK_LINE;\r\ncd = ad1843_read_bits(lith, &ad1843_LX2MM) ? 0 : SOUND_MASK_CD;\r\nmic = ad1843_read_bits(lith, &ad1843_LMCMM) ? 0 : SOUND_MASK_MIC;\r\nreturn pcm | line | cd | mic;\r\n}\r\nstatic int ad1843_set_outsrc(lithium_t *lith, int mask)\r\n{\r\nint pcm, line, mic, cd;\r\nif (mask & ~(SOUND_MASK_PCM | SOUND_MASK_LINE |\r\nSOUND_MASK_CD | SOUND_MASK_MIC))\r\nreturn -EINVAL;\r\npcm = (mask & SOUND_MASK_PCM) ? 0 : 1;\r\nline = (mask & SOUND_MASK_LINE) ? 0 : 1;\r\nmic = (mask & SOUND_MASK_MIC) ? 0 : 1;\r\ncd = (mask & SOUND_MASK_CD) ? 0 : 1;\r\nad1843_write_multi(lith, 2, &ad1843_LDA1GM, pcm, &ad1843_RDA1GM, pcm);\r\nad1843_write_multi(lith, 2, &ad1843_LX1MM, line, &ad1843_RX1MM, line);\r\nad1843_write_multi(lith, 2, &ad1843_LX2MM, cd, &ad1843_RX2MM, cd);\r\nad1843_write_multi(lith, 2, &ad1843_LMCMM, mic, &ad1843_RMCMM, mic);\r\nreturn mask;\r\n}\r\nstatic void ad1843_setup_dac(lithium_t *lith,\r\nint framerate,\r\nint fmt,\r\nint channels)\r\n{\r\nint ad_fmt = 0, ad_mode = 0;\r\nDBGEV("(lith=0x%p, framerate=%d, fmt=%d, channels=%d)\n",\r\nlith, framerate, fmt, channels);\r\nswitch (fmt) {\r\ncase AFMT_S8: ad_fmt = 1; break;\r\ncase AFMT_U8: ad_fmt = 1; break;\r\ncase AFMT_S16_LE: ad_fmt = 1; break;\r\ncase AFMT_MU_LAW: ad_fmt = 2; break;\r\ncase AFMT_A_LAW: ad_fmt = 3; break;\r\ndefault: ASSERT(0);\r\n}\r\nswitch (channels) {\r\ncase 2: ad_mode = 0; break;\r\ncase 1: ad_mode = 1; break;\r\ndefault: ASSERT(0);\r\n}\r\nDBGPV("ad_mode = %d, ad_fmt = %d\n", ad_mode, ad_fmt);\r\nASSERT(framerate >= 4000 && framerate <= 49000);\r\nad1843_write_bits(lith, &ad1843_C1C, framerate);\r\nad1843_write_multi(lith, 2,\r\n&ad1843_DA1SM, ad_mode, &ad1843_DA1F, ad_fmt);\r\n}\r\nstatic void ad1843_shutdown_dac(lithium_t *lith)\r\n{\r\nad1843_write_bits(lith, &ad1843_DA1F, 1);\r\n}\r\nstatic void ad1843_setup_adc(lithium_t *lith, int framerate, int fmt, int channels)\r\n{\r\nint da_fmt = 0;\r\nDBGEV("(lith=0x%p, framerate=%d, fmt=%d, channels=%d)\n",\r\nlith, framerate, fmt, channels);\r\nswitch (fmt) {\r\ncase AFMT_S8: da_fmt = 1; break;\r\ncase AFMT_U8: da_fmt = 1; break;\r\ncase AFMT_S16_LE: da_fmt = 1; break;\r\ncase AFMT_MU_LAW: da_fmt = 2; break;\r\ncase AFMT_A_LAW: da_fmt = 3; break;\r\ndefault: ASSERT(0);\r\n}\r\nDBGPV("da_fmt = %d\n", da_fmt);\r\nASSERT(framerate >= 4000 && framerate <= 49000);\r\nad1843_write_bits(lith, &ad1843_C2C, framerate);\r\nad1843_write_multi(lith, 2,\r\n&ad1843_ADLF, da_fmt, &ad1843_ADRF, da_fmt);\r\n}\r\nstatic void ad1843_shutdown_adc(lithium_t *lith)\r\n{\r\n}\r\nstatic int __init ad1843_init(lithium_t *lith)\r\n{\r\nunsigned long later;\r\nint err;\r\nerr = li_init(lith);\r\nif (err)\r\nreturn err;\r\nif (ad1843_read_bits(lith, &ad1843_INIT) != 0) {\r\nprintk(KERN_ERR "vwsnd sound: AD1843 won't initialize\n");\r\nreturn -EIO;\r\n}\r\nad1843_write_bits(lith, &ad1843_SCF, 1);\r\nad1843_write_bits(lith, &ad1843_PDNI, 0);\r\nlater = jiffies + HZ / 2;\r\nDBGDO(shut_up++);\r\nwhile (ad1843_read_bits(lith, &ad1843_PDNO)) {\r\nif (time_after(jiffies, later)) {\r\nprintk(KERN_ERR\r\n"vwsnd audio: AD1843 won't power up\n");\r\nreturn -EIO;\r\n}\r\nschedule();\r\n}\r\nDBGDO(shut_up--);\r\nad1843_write_multi(lith, 2, &ad1843_C1EN, 1, &ad1843_C2EN, 1);\r\nad1843_write_multi(lith, 3,\r\n&ad1843_DA1C, 1,\r\n&ad1843_ADLC, 2,\r\n&ad1843_ADRC, 2);\r\nad1843_write_bits(lith, &ad1843_ADTLK, 1);\r\nad1843_write_multi(lith, 5,\r\n&ad1843_ANAEN, 1,\r\n&ad1843_AAMEN, 1,\r\n&ad1843_DA1EN, 1,\r\n&ad1843_ADLEN, 1,\r\n&ad1843_ADREN, 1);\r\nad1843_write_bits(lith, &ad1843_DA1C, 1);\r\nad1843_set_outsrc(lith,\r\n(SOUND_MASK_PCM | SOUND_MASK_LINE |\r\nSOUND_MASK_MIC | SOUND_MASK_CD));\r\nad1843_write_multi(lith, 2, &ad1843_LDA1AM, 0, &ad1843_RDA1AM, 0);\r\nad1843_set_recsrc(lith, SOUND_MASK_LINE);\r\nad1843_write_multi(lith, 2, &ad1843_LMGE, 1, &ad1843_RMGE, 1);\r\nad1843_write_multi(lith, 2, &ad1843_HPOS, 1, &ad1843_HPOM, 0);\r\nreturn 0;\r\n}\r\nstatic __inline__ unsigned int __swb_inc_u(vwsnd_port_t *port, int inc)\r\n{\r\nif (inc) {\r\nport->swb_u_idx += inc;\r\nport->swb_u_idx %= port->swbuf_size;\r\nport->swb_u_avail -= inc;\r\nport->swb_i_avail += inc;\r\n}\r\nreturn port->swb_u_avail;\r\n}\r\nstatic __inline__ unsigned int swb_inc_u(vwsnd_port_t *port, int inc)\r\n{\r\nunsigned long flags;\r\nunsigned int ret;\r\nspin_lock_irqsave(&port->lock, flags);\r\n{\r\nret = __swb_inc_u(port, inc);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn ret;\r\n}\r\nstatic __inline__ unsigned int __swb_inc_i(vwsnd_port_t *port, int inc)\r\n{\r\nif (inc) {\r\nport->swb_i_idx += inc;\r\nport->swb_i_idx %= port->swbuf_size;\r\nport->swb_i_avail -= inc;\r\nport->swb_u_avail += inc;\r\n}\r\nreturn port->swb_i_avail;\r\n}\r\nstatic __inline__ unsigned int swb_inc_i(vwsnd_port_t *port, int inc)\r\n{\r\nunsigned long flags;\r\nunsigned int ret;\r\nspin_lock_irqsave(&port->lock, flags);\r\n{\r\nret = __swb_inc_i(port, inc);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int pcm_setup(vwsnd_dev_t *devc,\r\nvwsnd_port_t *rport,\r\nvwsnd_port_t *wport)\r\n{\r\nvwsnd_port_t *aport = rport ? rport : wport;\r\nint sample_size;\r\nunsigned int zero_word;\r\nDBGEV("(devc=0x%p, rport=0x%p, wport=0x%p)\n", devc, rport, wport);\r\nASSERT(aport != NULL);\r\nif (aport->swbuf != NULL)\r\nreturn 0;\r\nswitch (aport->sw_samplefmt) {\r\ncase AFMT_MU_LAW:\r\nsample_size = 1;\r\nzero_word = 0xFFFFFFFF ^ 0x80808080;\r\nbreak;\r\ncase AFMT_A_LAW:\r\nsample_size = 1;\r\nzero_word = 0xD5D5D5D5 ^ 0x80808080;\r\nbreak;\r\ncase AFMT_U8:\r\nsample_size = 1;\r\nzero_word = 0x80808080;\r\nbreak;\r\ncase AFMT_S8:\r\nsample_size = 1;\r\nzero_word = 0x00000000;\r\nbreak;\r\ncase AFMT_S16_LE:\r\nsample_size = 2;\r\nzero_word = 0x00000000;\r\nbreak;\r\ndefault:\r\nsample_size = 0;\r\nzero_word = 0;\r\nASSERT(0);\r\n}\r\naport->sample_size = sample_size;\r\naport->zero_word = zero_word;\r\naport->frame_size = aport->sw_channels * aport->sample_size;\r\naport->hw_fragshift = aport->sw_fragshift - aport->sw_subdivshift;\r\naport->hw_fragsize = 1 << aport->hw_fragshift;\r\naport->hw_fragcount = aport->sw_fragcount << aport->sw_subdivshift;\r\nASSERT(aport->hw_fragsize >= MIN_FRAGSIZE);\r\nASSERT(aport->hw_fragsize <= MAX_FRAGSIZE);\r\nASSERT(aport->hw_fragcount >= MIN_FRAGCOUNT(aport->hw_fragsize));\r\nASSERT(aport->hw_fragcount <= MAX_FRAGCOUNT(aport->hw_fragsize));\r\nif (rport) {\r\nint hwfrags, swfrags;\r\nrport->hwbuf_max = aport->hwbuf_size - DMACHUNK_SIZE;\r\nhwfrags = rport->hwbuf_max >> aport->hw_fragshift;\r\nswfrags = aport->hw_fragcount - hwfrags;\r\nif (swfrags < 2)\r\nswfrags = 2;\r\nrport->swbuf_size = swfrags * aport->hw_fragsize;\r\nDBGPV("hwfrags = %d, swfrags = %d\n", hwfrags, swfrags);\r\nDBGPV("read hwbuf_max = %d, swbuf_size = %d\n",\r\nrport->hwbuf_max, rport->swbuf_size);\r\n}\r\nif (wport) {\r\nint hwfrags, swfrags;\r\nint total_bytes = aport->hw_fragcount * aport->hw_fragsize;\r\nwport->hwbuf_max = aport->hwbuf_size - DMACHUNK_SIZE;\r\nif (wport->hwbuf_max > total_bytes)\r\nwport->hwbuf_max = total_bytes;\r\nhwfrags = wport->hwbuf_max >> aport->hw_fragshift;\r\nDBGPV("hwfrags = %d\n", hwfrags);\r\nswfrags = aport->hw_fragcount - hwfrags;\r\nif (swfrags < 2)\r\nswfrags = 2;\r\nwport->swbuf_size = swfrags * aport->hw_fragsize;\r\nDBGPV("hwfrags = %d, swfrags = %d\n", hwfrags, swfrags);\r\nDBGPV("write hwbuf_max = %d, swbuf_size = %d\n",\r\nwport->hwbuf_max, wport->swbuf_size);\r\n}\r\naport->swb_u_idx = 0;\r\naport->swb_i_idx = 0;\r\naport->byte_count = 0;\r\naport->swbuf = vmalloc(aport->swbuf_size + PAGE_SIZE);\r\nif (!aport->swbuf)\r\nreturn -ENOMEM;\r\nif (rport && wport) {\r\nASSERT(aport == rport);\r\nASSERT(wport->swbuf == NULL);\r\nwport->swbuf = vmalloc(aport->swbuf_size + PAGE_SIZE);\r\nif (!wport->swbuf) {\r\nvfree(aport->swbuf);\r\naport->swbuf = NULL;\r\nreturn -ENOMEM;\r\n}\r\nwport->sample_size = rport->sample_size;\r\nwport->zero_word = rport->zero_word;\r\nwport->frame_size = rport->frame_size;\r\nwport->hw_fragshift = rport->hw_fragshift;\r\nwport->hw_fragsize = rport->hw_fragsize;\r\nwport->hw_fragcount = rport->hw_fragcount;\r\nwport->swbuf_size = rport->swbuf_size;\r\nwport->hwbuf_max = rport->hwbuf_max;\r\nwport->swb_u_idx = rport->swb_u_idx;\r\nwport->swb_i_idx = rport->swb_i_idx;\r\nwport->byte_count = rport->byte_count;\r\n}\r\nif (rport) {\r\nrport->swb_u_avail = 0;\r\nrport->swb_i_avail = rport->swbuf_size;\r\nrport->swstate = SW_RUN;\r\nli_setup_dma(&rport->chan,\r\n&li_comm1,\r\n&devc->lith,\r\nrport->hwbuf_paddr,\r\nHWBUF_SHIFT,\r\nrport->hw_fragshift,\r\nrport->sw_channels,\r\nrport->sample_size);\r\nad1843_setup_adc(&devc->lith,\r\nrport->sw_framerate,\r\nrport->sw_samplefmt,\r\nrport->sw_channels);\r\nli_enable_interrupts(&devc->lith, READ_INTR_MASK);\r\nif (!(rport->flags & DISABLED)) {\r\nustmsc_t ustmsc;\r\nrport->hwstate = HW_RUNNING;\r\nli_activate_dma(&rport->chan);\r\nli_read_USTMSC(&rport->chan, &ustmsc);\r\nrport->MSC_offset = ustmsc.msc;\r\n}\r\n}\r\nif (wport) {\r\nif (wport->hwbuf_max > wport->swbuf_size)\r\nwport->hwbuf_max = wport->swbuf_size;\r\nwport->flags &= ~ERFLOWN;\r\nwport->swb_u_avail = wport->swbuf_size;\r\nwport->swb_i_avail = 0;\r\nwport->swstate = SW_RUN;\r\nli_setup_dma(&wport->chan,\r\n&li_comm2,\r\n&devc->lith,\r\nwport->hwbuf_paddr,\r\nHWBUF_SHIFT,\r\nwport->hw_fragshift,\r\nwport->sw_channels,\r\nwport->sample_size);\r\nad1843_setup_dac(&devc->lith,\r\nwport->sw_framerate,\r\nwport->sw_samplefmt,\r\nwport->sw_channels);\r\nli_enable_interrupts(&devc->lith, WRITE_INTR_MASK);\r\n}\r\nDBGRV();\r\nreturn 0;\r\n}\r\nstatic void pcm_shutdown_port(vwsnd_dev_t *devc,\r\nvwsnd_port_t *aport,\r\nunsigned int mask)\r\n{\r\nunsigned long flags;\r\nvwsnd_port_hwstate_t hwstate;\r\nDECLARE_WAITQUEUE(wait, current);\r\naport->swstate = SW_INITIAL;\r\nadd_wait_queue(&aport->queue, &wait);\r\nwhile (1) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nspin_lock_irqsave(&aport->lock, flags);\r\n{\r\nhwstate = aport->hwstate;\r\n}\r\nspin_unlock_irqrestore(&aport->lock, flags);\r\nif (hwstate == HW_STOPPED)\r\nbreak;\r\nschedule();\r\n}\r\ncurrent->state = TASK_RUNNING;\r\nremove_wait_queue(&aport->queue, &wait);\r\nli_disable_interrupts(&devc->lith, mask);\r\nif (aport == &devc->rport)\r\nad1843_shutdown_adc(&devc->lith);\r\nelse\r\nad1843_shutdown_dac(&devc->lith);\r\nli_shutdown_dma(&aport->chan);\r\nvfree(aport->swbuf);\r\naport->swbuf = NULL;\r\naport->byte_count = 0;\r\n}\r\nstatic void pcm_shutdown(vwsnd_dev_t *devc,\r\nvwsnd_port_t *rport,\r\nvwsnd_port_t *wport)\r\n{\r\nDBGEV("(devc=0x%p, rport=0x%p, wport=0x%p)\n", devc, rport, wport);\r\nif (rport && rport->swbuf) {\r\nDBGPV("shutting down rport\n");\r\npcm_shutdown_port(devc, rport, READ_INTR_MASK);\r\n}\r\nif (wport && wport->swbuf) {\r\nDBGPV("shutting down wport\n");\r\npcm_shutdown_port(devc, wport, WRITE_INTR_MASK);\r\n}\r\nDBGRV();\r\n}\r\nstatic void pcm_copy_in(vwsnd_port_t *rport, int swidx, int hwidx, int nb)\r\n{\r\nchar *src = rport->hwbuf + hwidx;\r\nchar *dst = rport->swbuf + swidx;\r\nint fmt = rport->sw_samplefmt;\r\nDBGPV("swidx = %d, hwidx = %d\n", swidx, hwidx);\r\nASSERT(rport->hwbuf != NULL);\r\nASSERT(rport->swbuf != NULL);\r\nASSERT(nb > 0 && (nb % 32) == 0);\r\nASSERT(swidx % 32 == 0 && hwidx % 32 == 0);\r\nASSERT(swidx >= 0 && swidx + nb <= rport->swbuf_size);\r\nASSERT(hwidx >= 0 && hwidx + nb <= rport->hwbuf_size);\r\nif (fmt == AFMT_MU_LAW || fmt == AFMT_A_LAW || fmt == AFMT_S8) {\r\nchar *end = src + nb;\r\nwhile (src < end)\r\n*dst++ = *src++ ^ 0x80;\r\n} else\r\nmemcpy(dst, src, nb);\r\n}\r\nstatic void pcm_copy_out(vwsnd_port_t *wport, int swidx, int hwidx, int nb)\r\n{\r\nchar *src = wport->swbuf + swidx;\r\nchar *dst = wport->hwbuf + hwidx;\r\nint fmt = wport->sw_samplefmt;\r\nASSERT(nb > 0 && (nb % 32) == 0);\r\nASSERT(wport->hwbuf != NULL);\r\nASSERT(wport->swbuf != NULL);\r\nASSERT(swidx % 32 == 0 && hwidx % 32 == 0);\r\nASSERT(swidx >= 0 && swidx + nb <= wport->swbuf_size);\r\nASSERT(hwidx >= 0 && hwidx + nb <= wport->hwbuf_size);\r\nif (fmt == AFMT_MU_LAW || fmt == AFMT_A_LAW || fmt == AFMT_S8) {\r\nchar *end = src + nb;\r\nwhile (src < end)\r\n*dst++ = *src++ ^ 0x80;\r\n} else\r\nmemcpy(dst, src, nb);\r\n}\r\nstatic void pcm_output(vwsnd_dev_t *devc, int erflown, int nb)\r\n{\r\nvwsnd_port_t *wport = &devc->wport;\r\nconst int hwmax = wport->hwbuf_max;\r\nconst int hwsize = wport->hwbuf_size;\r\nconst int swsize = wport->swbuf_size;\r\nconst int fragsize = wport->hw_fragsize;\r\nunsigned long iflags;\r\nDBGEV("(devc=0x%p, erflown=%d, nb=%d)\n", devc, erflown, nb);\r\nspin_lock_irqsave(&wport->lock, iflags);\r\nif (erflown)\r\nwport->flags |= ERFLOWN;\r\n(void) __swb_inc_u(wport, nb);\r\nif (wport->flags & HW_BUSY) {\r\nspin_unlock_irqrestore(&wport->lock, iflags);\r\nDBGPV("returning: HW BUSY\n");\r\nreturn;\r\n}\r\nif (wport->flags & DISABLED) {\r\nspin_unlock_irqrestore(&wport->lock, iflags);\r\nDBGPV("returning: DISABLED\n");\r\nreturn;\r\n}\r\nwport->flags |= HW_BUSY;\r\nwhile (1) {\r\nint swptr, hwptr, hw_avail, sw_avail, swidx;\r\nvwsnd_port_hwstate_t hwstate = wport->hwstate;\r\nvwsnd_port_swstate_t swstate = wport->swstate;\r\nint hw_unavail;\r\nustmsc_t ustmsc;\r\nhwptr = li_read_hwptr(&wport->chan);\r\nswptr = li_read_swptr(&wport->chan);\r\nhw_unavail = (swptr - hwptr + hwsize) % hwsize;\r\nhw_avail = (hwmax - hw_unavail) & -fragsize;\r\nsw_avail = wport->swb_i_avail & -fragsize;\r\nif (sw_avail && swstate == SW_RUN) {\r\nif (wport->flags & ERFLOWN) {\r\nwport->flags &= ~ERFLOWN;\r\n}\r\n} else if (swstate == SW_INITIAL ||\r\nswstate == SW_OFF ||\r\n(swstate == SW_DRAIN &&\r\n!sw_avail &&\r\n(wport->flags & ERFLOWN))) {\r\nDBGP("stopping. hwstate = %d\n", hwstate);\r\nif (hwstate != HW_STOPPED) {\r\nli_deactivate_dma(&wport->chan);\r\nwport->hwstate = HW_STOPPED;\r\n}\r\nwake_up(&wport->queue);\r\nbreak;\r\n}\r\nif (!sw_avail || !hw_avail)\r\nbreak;\r\nspin_unlock_irqrestore(&wport->lock, iflags);\r\nswidx = wport->swb_i_idx;\r\nnb = hw_avail;\r\nif (nb > sw_avail)\r\nnb = sw_avail;\r\nif (nb > hwsize - swptr)\r\nnb = hwsize - swptr;\r\nif (nb > swsize - swidx)\r\nnb = swsize - swidx;\r\nASSERT(nb > 0);\r\nif (nb % fragsize) {\r\nDBGP("nb = %d, fragsize = %d\n", nb, fragsize);\r\nDBGP("hw_avail = %d\n", hw_avail);\r\nDBGP("sw_avail = %d\n", sw_avail);\r\nDBGP("hwsize = %d, swptr = %d\n", hwsize, swptr);\r\nDBGP("swsize = %d, swidx = %d\n", swsize, swidx);\r\n}\r\nASSERT(!(nb % fragsize));\r\nDBGPV("copying swb[%d..%d] to hwb[%d..%d]\n",\r\nswidx, swidx + nb, swptr, swptr + nb);\r\npcm_copy_out(wport, swidx, swptr, nb);\r\nli_write_swptr(&wport->chan, (swptr + nb) % hwsize);\r\nspin_lock_irqsave(&wport->lock, iflags);\r\nif (hwstate == HW_STOPPED) {\r\nDBGPV("starting\n");\r\nli_activate_dma(&wport->chan);\r\nwport->hwstate = HW_RUNNING;\r\nli_read_USTMSC(&wport->chan, &ustmsc);\r\nASSERT(wport->byte_count % wport->frame_size == 0);\r\nwport->MSC_offset = ustmsc.msc - wport->byte_count / wport->frame_size;\r\n}\r\n__swb_inc_i(wport, nb);\r\nwport->byte_count += nb;\r\nwport->frag_count += nb / fragsize;\r\nASSERT(nb % fragsize == 0);\r\nwake_up(&wport->queue);\r\n}\r\nwport->flags &= ~HW_BUSY;\r\nspin_unlock_irqrestore(&wport->lock, iflags);\r\nDBGRV();\r\n}\r\nstatic void pcm_input(vwsnd_dev_t *devc, int erflown, int nb)\r\n{\r\nvwsnd_port_t *rport = &devc->rport;\r\nconst int hwmax = rport->hwbuf_max;\r\nconst int hwsize = rport->hwbuf_size;\r\nconst int swsize = rport->swbuf_size;\r\nconst int fragsize = rport->hw_fragsize;\r\nunsigned long iflags;\r\nDBGEV("(devc=0x%p, erflown=%d, nb=%d)\n", devc, erflown, nb);\r\nspin_lock_irqsave(&rport->lock, iflags);\r\nif (erflown)\r\nrport->flags |= ERFLOWN;\r\n(void) __swb_inc_u(rport, nb);\r\nif (rport->flags & HW_BUSY || !rport->swbuf) {\r\nspin_unlock_irqrestore(&rport->lock, iflags);\r\nDBGPV("returning: HW BUSY or !swbuf\n");\r\nreturn;\r\n}\r\nif (rport->flags & DISABLED) {\r\nspin_unlock_irqrestore(&rport->lock, iflags);\r\nDBGPV("returning: DISABLED\n");\r\nreturn;\r\n}\r\nrport->flags |= HW_BUSY;\r\nwhile (1) {\r\nint swptr, hwptr, hw_avail, sw_avail, swidx;\r\nvwsnd_port_hwstate_t hwstate = rport->hwstate;\r\nvwsnd_port_swstate_t swstate = rport->swstate;\r\nhwptr = li_read_hwptr(&rport->chan);\r\nswptr = li_read_swptr(&rport->chan);\r\nhw_avail = (hwptr - swptr + hwsize) % hwsize & -fragsize;\r\nif (hw_avail > hwmax)\r\nhw_avail = hwmax;\r\nsw_avail = rport->swb_i_avail & -fragsize;\r\nif (swstate != SW_RUN) {\r\nDBGP("stopping. hwstate = %d\n", hwstate);\r\nif (hwstate != HW_STOPPED) {\r\nli_deactivate_dma(&rport->chan);\r\nrport->hwstate = HW_STOPPED;\r\n}\r\nwake_up(&rport->queue);\r\nbreak;\r\n}\r\nif (!sw_avail || !hw_avail)\r\nbreak;\r\nspin_unlock_irqrestore(&rport->lock, iflags);\r\nswidx = rport->swb_i_idx;\r\nnb = hw_avail;\r\nif (nb > sw_avail)\r\nnb = sw_avail;\r\nif (nb > hwsize - swptr)\r\nnb = hwsize - swptr;\r\nif (nb > swsize - swidx)\r\nnb = swsize - swidx;\r\nASSERT(nb > 0);\r\nif (nb % fragsize) {\r\nDBGP("nb = %d, fragsize = %d\n", nb, fragsize);\r\nDBGP("hw_avail = %d\n", hw_avail);\r\nDBGP("sw_avail = %d\n", sw_avail);\r\nDBGP("hwsize = %d, swptr = %d\n", hwsize, swptr);\r\nDBGP("swsize = %d, swidx = %d\n", swsize, swidx);\r\n}\r\nASSERT(!(nb % fragsize));\r\nDBGPV("copying hwb[%d..%d] to swb[%d..%d]\n",\r\nswptr, swptr + nb, swidx, swidx + nb);\r\npcm_copy_in(rport, swidx, swptr, nb);\r\nli_write_swptr(&rport->chan, (swptr + nb) % hwsize);\r\nspin_lock_irqsave(&rport->lock, iflags);\r\n__swb_inc_i(rport, nb);\r\nrport->byte_count += nb;\r\nrport->frag_count += nb / fragsize;\r\nASSERT(nb % fragsize == 0);\r\nwake_up(&rport->queue);\r\n}\r\nrport->flags &= ~HW_BUSY;\r\nspin_unlock_irqrestore(&rport->lock, iflags);\r\nDBGRV();\r\n}\r\nstatic void pcm_flush_frag(vwsnd_dev_t *devc)\r\n{\r\nvwsnd_port_t *wport = &devc->wport;\r\nDBGPV("swstate = %d\n", wport->swstate);\r\nif (wport->swstate == SW_RUN) {\r\nint idx = wport->swb_u_idx;\r\nint end = (idx + wport->hw_fragsize - 1)\r\n>> wport->hw_fragshift\r\n<< wport->hw_fragshift;\r\nint nb = end - idx;\r\nDBGPV("clearing %d bytes\n", nb);\r\nif (nb)\r\nmemset(wport->swbuf + idx,\r\n(char) wport->zero_word,\r\nnb);\r\nwport->swstate = SW_DRAIN;\r\npcm_output(devc, 0, nb);\r\n}\r\nDBGRV();\r\n}\r\nstatic void pcm_write_sync(vwsnd_dev_t *devc)\r\n{\r\nvwsnd_port_t *wport = &devc->wport;\r\nDECLARE_WAITQUEUE(wait, current);\r\nunsigned long flags;\r\nvwsnd_port_hwstate_t hwstate;\r\nDBGEV("(devc=0x%p)\n", devc);\r\nadd_wait_queue(&wport->queue, &wait);\r\nwhile (1) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nspin_lock_irqsave(&wport->lock, flags);\r\n{\r\nhwstate = wport->hwstate;\r\n}\r\nspin_unlock_irqrestore(&wport->lock, flags);\r\nif (hwstate == HW_STOPPED)\r\nbreak;\r\nschedule();\r\n}\r\ncurrent->state = TASK_RUNNING;\r\nremove_wait_queue(&wport->queue, &wait);\r\nDBGPV("swstate = %d, hwstate = %d\n", wport->swstate, wport->hwstate);\r\nDBGRV();\r\n}\r\nstatic void vwsnd_audio_read_intr(vwsnd_dev_t *devc, unsigned int status)\r\n{\r\nint overflown = status & LI_INTR_COMM1_OVERFLOW;\r\nif (status & READ_INTR_MASK)\r\npcm_input(devc, overflown, 0);\r\n}\r\nstatic void vwsnd_audio_write_intr(vwsnd_dev_t *devc, unsigned int status)\r\n{\r\nint underflown = status & LI_INTR_COMM2_UNDERFLOW;\r\nif (status & WRITE_INTR_MASK)\r\npcm_output(devc, underflown, 0);\r\n}\r\nstatic irqreturn_t vwsnd_audio_intr(int irq, void *dev_id)\r\n{\r\nvwsnd_dev_t *devc = dev_id;\r\nunsigned int status;\r\nDBGEV("(irq=%d, dev_id=0x%p)\n", irq, dev_id);\r\nstatus = li_get_clear_intr_status(&devc->lith);\r\nvwsnd_audio_read_intr(devc, status);\r\nvwsnd_audio_write_intr(devc, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic ssize_t vwsnd_audio_do_read(struct file *file,\r\nchar *buffer,\r\nsize_t count,\r\nloff_t *ppos)\r\n{\r\nvwsnd_dev_t *devc = file->private_data;\r\nvwsnd_port_t *rport = ((file->f_mode & FMODE_READ) ?\r\n&devc->rport : NULL);\r\nint ret, nb;\r\nDBGEV("(file=0x%p, buffer=0x%p, count=%d, ppos=0x%p)\n",\r\nfile, buffer, count, ppos);\r\nif (!rport)\r\nreturn -EINVAL;\r\nif (rport->swbuf == NULL) {\r\nvwsnd_port_t *wport = (file->f_mode & FMODE_WRITE) ?\r\n&devc->wport : NULL;\r\nret = pcm_setup(devc, rport, wport);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (!access_ok(VERIFY_READ, buffer, count))\r\nreturn -EFAULT;\r\nret = 0;\r\nwhile (count) {\r\nDECLARE_WAITQUEUE(wait, current);\r\nadd_wait_queue(&rport->queue, &wait);\r\nwhile ((nb = swb_inc_u(rport, 0)) == 0) {\r\nDBGPV("blocking\n");\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (rport->flags & DISABLED ||\r\nfile->f_flags & O_NONBLOCK) {\r\ncurrent->state = TASK_RUNNING;\r\nremove_wait_queue(&rport->queue, &wait);\r\nreturn ret ? ret : -EAGAIN;\r\n}\r\nschedule();\r\nif (signal_pending(current)) {\r\ncurrent->state = TASK_RUNNING;\r\nremove_wait_queue(&rport->queue, &wait);\r\nreturn ret ? ret : -ERESTARTSYS;\r\n}\r\n}\r\ncurrent->state = TASK_RUNNING;\r\nremove_wait_queue(&rport->queue, &wait);\r\npcm_input(devc, 0, 0);\r\nif (nb > count)\r\nnb = count;\r\nDBGPV("nb = %d\n", nb);\r\nif (copy_to_user(buffer, rport->swbuf + rport->swb_u_idx, nb))\r\nreturn -EFAULT;\r\n(void) swb_inc_u(rport, nb);\r\nbuffer += nb;\r\ncount -= nb;\r\nret += nb;\r\n}\r\nDBGPV("returning %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic ssize_t vwsnd_audio_read(struct file *file,\r\nchar *buffer,\r\nsize_t count,\r\nloff_t *ppos)\r\n{\r\nvwsnd_dev_t *devc = file->private_data;\r\nssize_t ret;\r\nmutex_lock(&devc->io_mutex);\r\nret = vwsnd_audio_do_read(file, buffer, count, ppos);\r\nmutex_unlock(&devc->io_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t vwsnd_audio_do_write(struct file *file,\r\nconst char *buffer,\r\nsize_t count,\r\nloff_t *ppos)\r\n{\r\nvwsnd_dev_t *devc = file->private_data;\r\nvwsnd_port_t *wport = ((file->f_mode & FMODE_WRITE) ?\r\n&devc->wport : NULL);\r\nint ret, nb;\r\nDBGEV("(file=0x%p, buffer=0x%p, count=%d, ppos=0x%p)\n",\r\nfile, buffer, count, ppos);\r\nif (!wport)\r\nreturn -EINVAL;\r\nif (wport->swbuf == NULL) {\r\nvwsnd_port_t *rport = (file->f_mode & FMODE_READ) ?\r\n&devc->rport : NULL;\r\nret = pcm_setup(devc, rport, wport);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (!access_ok(VERIFY_WRITE, buffer, count))\r\nreturn -EFAULT;\r\nret = 0;\r\nwhile (count) {\r\nDECLARE_WAITQUEUE(wait, current);\r\nadd_wait_queue(&wport->queue, &wait);\r\nwhile ((nb = swb_inc_u(wport, 0)) == 0) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (wport->flags & DISABLED ||\r\nfile->f_flags & O_NONBLOCK) {\r\ncurrent->state = TASK_RUNNING;\r\nremove_wait_queue(&wport->queue, &wait);\r\nreturn ret ? ret : -EAGAIN;\r\n}\r\nschedule();\r\nif (signal_pending(current)) {\r\ncurrent->state = TASK_RUNNING;\r\nremove_wait_queue(&wport->queue, &wait);\r\nreturn ret ? ret : -ERESTARTSYS;\r\n}\r\n}\r\ncurrent->state = TASK_RUNNING;\r\nremove_wait_queue(&wport->queue, &wait);\r\nif (nb > count)\r\nnb = count;\r\nDBGPV("nb = %d\n", nb);\r\nif (copy_from_user(wport->swbuf + wport->swb_u_idx, buffer, nb))\r\nreturn -EFAULT;\r\npcm_output(devc, 0, nb);\r\nbuffer += nb;\r\ncount -= nb;\r\nret += nb;\r\n}\r\nDBGPV("returning %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic ssize_t vwsnd_audio_write(struct file *file,\r\nconst char *buffer,\r\nsize_t count,\r\nloff_t *ppos)\r\n{\r\nvwsnd_dev_t *devc = file->private_data;\r\nssize_t ret;\r\nmutex_lock(&devc->io_mutex);\r\nret = vwsnd_audio_do_write(file, buffer, count, ppos);\r\nmutex_unlock(&devc->io_mutex);\r\nreturn ret;\r\n}\r\nstatic unsigned int vwsnd_audio_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nvwsnd_dev_t *devc = (vwsnd_dev_t *) file->private_data;\r\nvwsnd_port_t *rport = (file->f_mode & FMODE_READ) ?\r\n&devc->rport : NULL;\r\nvwsnd_port_t *wport = (file->f_mode & FMODE_WRITE) ?\r\n&devc->wport : NULL;\r\nunsigned int mask = 0;\r\nDBGEV("(file=0x%p, wait=0x%p)\n", file, wait);\r\nASSERT(rport || wport);\r\nif (rport) {\r\npoll_wait(file, &rport->queue, wait);\r\nif (swb_inc_u(rport, 0))\r\nmask |= (POLLIN | POLLRDNORM);\r\n}\r\nif (wport) {\r\npoll_wait(file, &wport->queue, wait);\r\nif (wport->swbuf == NULL || swb_inc_u(wport, 0))\r\nmask |= (POLLOUT | POLLWRNORM);\r\n}\r\nDBGPV("returning 0x%x\n", mask);\r\nreturn mask;\r\n}\r\nstatic int vwsnd_audio_do_ioctl(struct file *file,\r\nunsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvwsnd_dev_t *devc = (vwsnd_dev_t *) file->private_data;\r\nvwsnd_port_t *rport = (file->f_mode & FMODE_READ) ?\r\n&devc->rport : NULL;\r\nvwsnd_port_t *wport = (file->f_mode & FMODE_WRITE) ?\r\n&devc->wport : NULL;\r\nvwsnd_port_t *aport = rport ? rport : wport;\r\nstruct audio_buf_info buf_info;\r\nstruct count_info info;\r\nunsigned long flags;\r\nint ival;\r\nDBGEV("(file=0x%p, cmd=0x%x, arg=0x%lx)\n",\r\nfile, cmd, arg);\r\nswitch (cmd) {\r\ncase OSS_GETVERSION:\r\nDBGX("OSS_GETVERSION\n");\r\nival = SOUND_VERSION;\r\nreturn put_user(ival, (int *) arg);\r\ncase SNDCTL_DSP_GETCAPS:\r\nDBGX("SNDCTL_DSP_GETCAPS\n");\r\nival = DSP_CAP_DUPLEX | DSP_CAP_REALTIME | DSP_CAP_TRIGGER;\r\nreturn put_user(ival, (int *) arg);\r\ncase SNDCTL_DSP_GETFMTS:\r\nDBGX("SNDCTL_DSP_GETFMTS\n");\r\nival = (AFMT_S16_LE | AFMT_MU_LAW | AFMT_A_LAW |\r\nAFMT_U8 | AFMT_S8);\r\nreturn put_user(ival, (int *) arg);\r\nbreak;\r\ncase SOUND_PCM_READ_RATE:\r\nDBGX("SOUND_PCM_READ_RATE\n");\r\nival = aport->sw_framerate;\r\nreturn put_user(ival, (int *) arg);\r\ncase SOUND_PCM_READ_CHANNELS:\r\nDBGX("SOUND_PCM_READ_CHANNELS\n");\r\nival = aport->sw_channels;\r\nreturn put_user(ival, (int *) arg);\r\ncase SNDCTL_DSP_SPEED:\r\nif (get_user(ival, (int *) arg))\r\nreturn -EFAULT;\r\nDBGX("SNDCTL_DSP_SPEED %d\n", ival);\r\nif (ival) {\r\nif (aport->swstate != SW_INITIAL) {\r\nDBGX("SNDCTL_DSP_SPEED failed: swstate = %d\n",\r\naport->swstate);\r\nreturn -EINVAL;\r\n}\r\nif (ival < MIN_SPEED)\r\nival = MIN_SPEED;\r\nif (ival > MAX_SPEED)\r\nival = MAX_SPEED;\r\nif (rport)\r\nrport->sw_framerate = ival;\r\nif (wport)\r\nwport->sw_framerate = ival;\r\n} else\r\nival = aport->sw_framerate;\r\nreturn put_user(ival, (int *) arg);\r\ncase SNDCTL_DSP_STEREO:\r\nif (get_user(ival, (int *) arg))\r\nreturn -EFAULT;\r\nDBGX("SNDCTL_DSP_STEREO %d\n", ival);\r\nif (ival != 0 && ival != 1)\r\nreturn -EINVAL;\r\nif (aport->swstate != SW_INITIAL)\r\nreturn -EINVAL;\r\nif (rport)\r\nrport->sw_channels = ival + 1;\r\nif (wport)\r\nwport->sw_channels = ival + 1;\r\nreturn put_user(ival, (int *) arg);\r\ncase SNDCTL_DSP_CHANNELS:\r\nif (get_user(ival, (int *) arg))\r\nreturn -EFAULT;\r\nDBGX("SNDCTL_DSP_CHANNELS %d\n", ival);\r\nif (ival != 1 && ival != 2)\r\nreturn -EINVAL;\r\nif (aport->swstate != SW_INITIAL)\r\nreturn -EINVAL;\r\nif (rport)\r\nrport->sw_channels = ival;\r\nif (wport)\r\nwport->sw_channels = ival;\r\nreturn put_user(ival, (int *) arg);\r\ncase SNDCTL_DSP_GETBLKSIZE:\r\nival = pcm_setup(devc, rport, wport);\r\nif (ival < 0) {\r\nDBGX("SNDCTL_DSP_GETBLKSIZE failed, errno %d\n", ival);\r\nreturn ival;\r\n}\r\nival = 1 << aport->sw_fragshift;\r\nDBGX("SNDCTL_DSP_GETBLKSIZE returning %d\n", ival);\r\nreturn put_user(ival, (int *) arg);\r\ncase SNDCTL_DSP_SETFRAGMENT:\r\nif (get_user(ival, (int *) arg))\r\nreturn -EFAULT;\r\nDBGX("SNDCTL_DSP_SETFRAGMENT %d:%d\n",\r\nival >> 16, ival & 0xFFFF);\r\nif (aport->swstate != SW_INITIAL)\r\nreturn -EINVAL;\r\n{\r\nint sw_fragshift = ival & 0xFFFF;\r\nint sw_subdivshift = aport->sw_subdivshift;\r\nint hw_fragshift = sw_fragshift - sw_subdivshift;\r\nint sw_fragcount = (ival >> 16) & 0xFFFF;\r\nint hw_fragsize;\r\nif (hw_fragshift < MIN_FRAGSHIFT)\r\nhw_fragshift = MIN_FRAGSHIFT;\r\nif (hw_fragshift > MAX_FRAGSHIFT)\r\nhw_fragshift = MAX_FRAGSHIFT;\r\nsw_fragshift = hw_fragshift + aport->sw_subdivshift;\r\nhw_fragsize = 1 << hw_fragshift;\r\nif (sw_fragcount < MIN_FRAGCOUNT(hw_fragsize))\r\nsw_fragcount = MIN_FRAGCOUNT(hw_fragsize);\r\nif (sw_fragcount > MAX_FRAGCOUNT(hw_fragsize))\r\nsw_fragcount = MAX_FRAGCOUNT(hw_fragsize);\r\nDBGPV("sw_fragshift = %d\n", sw_fragshift);\r\nDBGPV("rport = 0x%p, wport = 0x%p\n", rport, wport);\r\nif (rport) {\r\nrport->sw_fragshift = sw_fragshift;\r\nrport->sw_fragcount = sw_fragcount;\r\n}\r\nif (wport) {\r\nwport->sw_fragshift = sw_fragshift;\r\nwport->sw_fragcount = sw_fragcount;\r\n}\r\nival = sw_fragcount << 16 | sw_fragshift;\r\n}\r\nDBGX("SNDCTL_DSP_SETFRAGMENT returns %d:%d\n",\r\nival >> 16, ival & 0xFFFF);\r\nreturn put_user(ival, (int *) arg);\r\ncase SNDCTL_DSP_SUBDIVIDE:\r\nif (get_user(ival, (int *) arg))\r\nreturn -EFAULT;\r\nDBGX("SNDCTL_DSP_SUBDIVIDE %d\n", ival);\r\nif (aport->swstate != SW_INITIAL)\r\nreturn -EINVAL;\r\n{\r\nint subdivshift;\r\nint hw_fragshift, hw_fragsize, hw_fragcount;\r\nswitch (ival) {\r\ncase 1: subdivshift = 0; break;\r\ncase 2: subdivshift = 1; break;\r\ncase 4: subdivshift = 2; break;\r\ndefault: return -EINVAL;\r\n}\r\nhw_fragshift = aport->sw_fragshift - subdivshift;\r\nif (hw_fragshift < MIN_FRAGSHIFT ||\r\nhw_fragshift > MAX_FRAGSHIFT)\r\nreturn -EINVAL;\r\nhw_fragsize = 1 << hw_fragshift;\r\nhw_fragcount = aport->sw_fragcount >> subdivshift;\r\nif (hw_fragcount < MIN_FRAGCOUNT(hw_fragsize) ||\r\nhw_fragcount > MAX_FRAGCOUNT(hw_fragsize))\r\nreturn -EINVAL;\r\nif (rport)\r\nrport->sw_subdivshift = subdivshift;\r\nif (wport)\r\nwport->sw_subdivshift = subdivshift;\r\n}\r\nreturn 0;\r\ncase SNDCTL_DSP_SETFMT:\r\nif (get_user(ival, (int *) arg))\r\nreturn -EFAULT;\r\nDBGX("SNDCTL_DSP_SETFMT %d\n", ival);\r\nif (ival != AFMT_QUERY) {\r\nif (aport->swstate != SW_INITIAL) {\r\nDBGP("SETFMT failed, swstate = %d\n",\r\naport->swstate);\r\nreturn -EINVAL;\r\n}\r\nswitch (ival) {\r\ncase AFMT_MU_LAW:\r\ncase AFMT_A_LAW:\r\ncase AFMT_U8:\r\ncase AFMT_S8:\r\ncase AFMT_S16_LE:\r\nif (rport)\r\nrport->sw_samplefmt = ival;\r\nif (wport)\r\nwport->sw_samplefmt = ival;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nival = aport->sw_samplefmt;\r\nreturn put_user(ival, (int *) arg);\r\ncase SNDCTL_DSP_GETOSPACE:\r\nDBGXV("SNDCTL_DSP_GETOSPACE\n");\r\nif (!wport)\r\nreturn -EINVAL;\r\nival = pcm_setup(devc, rport, wport);\r\nif (ival < 0)\r\nreturn ival;\r\nival = swb_inc_u(wport, 0);\r\nbuf_info.fragments = ival >> wport->sw_fragshift;\r\nbuf_info.fragstotal = wport->sw_fragcount;\r\nbuf_info.fragsize = 1 << wport->sw_fragshift;\r\nbuf_info.bytes = ival;\r\nDBGXV("SNDCTL_DSP_GETOSPACE returns { %d %d %d %d }\n",\r\nbuf_info.fragments, buf_info.fragstotal,\r\nbuf_info.fragsize, buf_info.bytes);\r\nif (copy_to_user((void *) arg, &buf_info, sizeof buf_info))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase SNDCTL_DSP_GETISPACE:\r\nDBGX("SNDCTL_DSP_GETISPACE\n");\r\nif (!rport)\r\nreturn -EINVAL;\r\nival = pcm_setup(devc, rport, wport);\r\nif (ival < 0)\r\nreturn ival;\r\nival = swb_inc_u(rport, 0);\r\nbuf_info.fragments = ival >> rport->sw_fragshift;\r\nbuf_info.fragstotal = rport->sw_fragcount;\r\nbuf_info.fragsize = 1 << rport->sw_fragshift;\r\nbuf_info.bytes = ival;\r\nDBGX("SNDCTL_DSP_GETISPACE returns { %d %d %d %d }\n",\r\nbuf_info.fragments, buf_info.fragstotal,\r\nbuf_info.fragsize, buf_info.bytes);\r\nif (copy_to_user((void *) arg, &buf_info, sizeof buf_info))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase SNDCTL_DSP_NONBLOCK:\r\nDBGX("SNDCTL_DSP_NONBLOCK\n");\r\nspin_lock(&file->f_lock);\r\nfile->f_flags |= O_NONBLOCK;\r\nspin_unlock(&file->f_lock);\r\nreturn 0;\r\ncase SNDCTL_DSP_RESET:\r\nDBGX("SNDCTL_DSP_RESET\n");\r\nif (wport && wport->swbuf) {\r\nwport->swstate = SW_INITIAL;\r\npcm_output(devc, 0, 0);\r\npcm_write_sync(devc);\r\n}\r\npcm_shutdown(devc, rport, wport);\r\nreturn 0;\r\ncase SNDCTL_DSP_SYNC:\r\nDBGX("SNDCTL_DSP_SYNC\n");\r\nif (wport) {\r\npcm_flush_frag(devc);\r\npcm_write_sync(devc);\r\n}\r\npcm_shutdown(devc, rport, wport);\r\nreturn 0;\r\ncase SNDCTL_DSP_POST:\r\nDBGX("SNDCTL_DSP_POST\n");\r\nif (!wport)\r\nreturn -EINVAL;\r\npcm_flush_frag(devc);\r\nreturn 0;\r\ncase SNDCTL_DSP_GETIPTR:\r\nDBGX("SNDCTL_DSP_GETIPTR\n");\r\nif (!rport)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&rport->lock, flags);\r\n{\r\nustmsc_t ustmsc;\r\nif (rport->hwstate == HW_RUNNING) {\r\nASSERT(rport->swstate == SW_RUN);\r\nli_read_USTMSC(&rport->chan, &ustmsc);\r\ninfo.bytes = ustmsc.msc - rport->MSC_offset;\r\ninfo.bytes *= rport->frame_size;\r\n} else {\r\ninfo.bytes = rport->byte_count;\r\n}\r\ninfo.blocks = rport->frag_count;\r\ninfo.ptr = 0;\r\nrport->frag_count = 0;\r\n}\r\nspin_unlock_irqrestore(&rport->lock, flags);\r\nif (copy_to_user((void *) arg, &info, sizeof info))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase SNDCTL_DSP_GETOPTR:\r\nDBGX("SNDCTL_DSP_GETOPTR\n");\r\nif (!wport)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&wport->lock, flags);\r\n{\r\nustmsc_t ustmsc;\r\nif (wport->hwstate == HW_RUNNING) {\r\nASSERT(wport->swstate == SW_RUN);\r\nli_read_USTMSC(&wport->chan, &ustmsc);\r\ninfo.bytes = ustmsc.msc - wport->MSC_offset;\r\ninfo.bytes *= wport->frame_size;\r\n} else {\r\ninfo.bytes = wport->byte_count;\r\n}\r\ninfo.blocks = wport->frag_count;\r\ninfo.ptr = 0;\r\nwport->frag_count = 0;\r\n}\r\nspin_unlock_irqrestore(&wport->lock, flags);\r\nif (copy_to_user((void *) arg, &info, sizeof info))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase SNDCTL_DSP_GETODELAY:\r\nDBGX("SNDCTL_DSP_GETODELAY\n");\r\nif (!wport)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&wport->lock, flags);\r\n{\r\nint fsize = wport->frame_size;\r\nival = wport->swb_i_avail / fsize;\r\nif (wport->hwstate == HW_RUNNING) {\r\nint swptr, hwptr, hwframes, hwbytes, hwsize;\r\nint totalhwbytes;\r\nustmsc_t ustmsc;\r\nhwsize = wport->hwbuf_size;\r\nswptr = li_read_swptr(&wport->chan);\r\nli_read_USTMSC(&wport->chan, &ustmsc);\r\nhwframes = ustmsc.msc - wport->MSC_offset;\r\ntotalhwbytes = hwframes * fsize;\r\nhwptr = totalhwbytes % hwsize;\r\nhwbytes = (swptr - hwptr + hwsize) % hwsize;\r\nival += hwbytes / fsize;\r\n}\r\n}\r\nspin_unlock_irqrestore(&wport->lock, flags);\r\nreturn put_user(ival, (int *) arg);\r\ncase SNDCTL_DSP_PROFILE:\r\nDBGX("SNDCTL_DSP_PROFILE\n");\r\nbreak;\r\ncase SNDCTL_DSP_GETTRIGGER:\r\nDBGX("SNDCTL_DSP_GETTRIGGER\n");\r\nival = 0;\r\nif (rport) {\r\nspin_lock_irqsave(&rport->lock, flags);\r\n{\r\nif (!(rport->flags & DISABLED))\r\nival |= PCM_ENABLE_INPUT;\r\n}\r\nspin_unlock_irqrestore(&rport->lock, flags);\r\n}\r\nif (wport) {\r\nspin_lock_irqsave(&wport->lock, flags);\r\n{\r\nif (!(wport->flags & DISABLED))\r\nival |= PCM_ENABLE_OUTPUT;\r\n}\r\nspin_unlock_irqrestore(&wport->lock, flags);\r\n}\r\nreturn put_user(ival, (int *) arg);\r\ncase SNDCTL_DSP_SETTRIGGER:\r\nif (get_user(ival, (int *) arg))\r\nreturn -EFAULT;\r\nDBGX("SNDCTL_DSP_SETTRIGGER %d\n", ival);\r\nif (((rport && !(ival & PCM_ENABLE_INPUT)) ||\r\n(wport && !(ival & PCM_ENABLE_OUTPUT))) &&\r\naport->swstate != SW_INITIAL)\r\nreturn -EINVAL;\r\nif (rport) {\r\nvwsnd_port_hwstate_t hwstate;\r\nspin_lock_irqsave(&rport->lock, flags);\r\n{\r\nhwstate = rport->hwstate;\r\nif (ival & PCM_ENABLE_INPUT)\r\nrport->flags &= ~DISABLED;\r\nelse\r\nrport->flags |= DISABLED;\r\n}\r\nspin_unlock_irqrestore(&rport->lock, flags);\r\nif (hwstate != HW_RUNNING && ival & PCM_ENABLE_INPUT) {\r\nif (rport->swstate == SW_INITIAL)\r\npcm_setup(devc, rport, wport);\r\nelse\r\nli_activate_dma(&rport->chan);\r\n}\r\n}\r\nif (wport) {\r\nvwsnd_port_flags_t pflags;\r\nspin_lock_irqsave(&wport->lock, flags);\r\n{\r\npflags = wport->flags;\r\nif (ival & PCM_ENABLE_OUTPUT)\r\nwport->flags &= ~DISABLED;\r\nelse\r\nwport->flags |= DISABLED;\r\n}\r\nspin_unlock_irqrestore(&wport->lock, flags);\r\nif (pflags & DISABLED && ival & PCM_ENABLE_OUTPUT) {\r\nif (wport->swstate == SW_RUN)\r\npcm_output(devc, 0, 0);\r\n}\r\n}\r\nreturn 0;\r\ndefault:\r\nDBGP("unknown ioctl 0x%x\n", cmd);\r\nreturn -EINVAL;\r\n}\r\nDBGP("unimplemented ioctl 0x%x\n", cmd);\r\nreturn -EINVAL;\r\n}\r\nstatic long vwsnd_audio_ioctl(struct file *file,\r\nunsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvwsnd_dev_t *devc = (vwsnd_dev_t *) file->private_data;\r\nint ret;\r\nmutex_lock(&vwsnd_mutex);\r\nmutex_lock(&devc->io_mutex);\r\nret = vwsnd_audio_do_ioctl(file, cmd, arg);\r\nmutex_unlock(&devc->io_mutex);\r\nmutex_unlock(&vwsnd_mutex);\r\nreturn ret;\r\n}\r\nstatic int vwsnd_audio_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nDBGE("(file=0x%p, vma=0x%p)\n", file, vma);\r\nreturn -ENODEV;\r\n}\r\nstatic int vwsnd_audio_open(struct inode *inode, struct file *file)\r\n{\r\nvwsnd_dev_t *devc;\r\nint minor = iminor(inode);\r\nint sw_samplefmt;\r\nDBGE("(inode=0x%p, file=0x%p)\n", inode, file);\r\nmutex_lock(&vwsnd_mutex);\r\nINC_USE_COUNT;\r\nfor (devc = vwsnd_dev_list; devc; devc = devc->next_dev)\r\nif ((devc->audio_minor & ~0x0F) == (minor & ~0x0F))\r\nbreak;\r\nif (devc == NULL) {\r\nDEC_USE_COUNT;\r\nmutex_unlock(&vwsnd_mutex);\r\nreturn -ENODEV;\r\n}\r\nmutex_lock(&devc->open_mutex);\r\nwhile (devc->open_mode & file->f_mode) {\r\nmutex_unlock(&devc->open_mutex);\r\nif (file->f_flags & O_NONBLOCK) {\r\nDEC_USE_COUNT;\r\nmutex_unlock(&vwsnd_mutex);\r\nreturn -EBUSY;\r\n}\r\ninterruptible_sleep_on(&devc->open_wait);\r\nif (signal_pending(current)) {\r\nDEC_USE_COUNT;\r\nmutex_unlock(&vwsnd_mutex);\r\nreturn -ERESTARTSYS;\r\n}\r\nmutex_lock(&devc->open_mutex);\r\n}\r\ndevc->open_mode |= file->f_mode & (FMODE_READ | FMODE_WRITE);\r\nmutex_unlock(&devc->open_mutex);\r\nsw_samplefmt = 0;\r\nif ((minor & 0xF) == SND_DEV_DSP)\r\nsw_samplefmt = AFMT_U8;\r\nelse if ((minor & 0xF) == SND_DEV_AUDIO)\r\nsw_samplefmt = AFMT_MU_LAW;\r\nelse if ((minor & 0xF) == SND_DEV_DSP16)\r\nsw_samplefmt = AFMT_S16_LE;\r\nelse\r\nASSERT(0);\r\nmutex_lock(&devc->io_mutex);\r\n{\r\nif (file->f_mode & FMODE_READ) {\r\ndevc->rport.swstate = SW_INITIAL;\r\ndevc->rport.flags = 0;\r\ndevc->rport.sw_channels = 1;\r\ndevc->rport.sw_samplefmt = sw_samplefmt;\r\ndevc->rport.sw_framerate = 8000;\r\ndevc->rport.sw_fragshift = DEFAULT_FRAGSHIFT;\r\ndevc->rport.sw_fragcount = DEFAULT_FRAGCOUNT;\r\ndevc->rport.sw_subdivshift = DEFAULT_SUBDIVSHIFT;\r\ndevc->rport.byte_count = 0;\r\ndevc->rport.frag_count = 0;\r\n}\r\nif (file->f_mode & FMODE_WRITE) {\r\ndevc->wport.swstate = SW_INITIAL;\r\ndevc->wport.flags = 0;\r\ndevc->wport.sw_channels = 1;\r\ndevc->wport.sw_samplefmt = sw_samplefmt;\r\ndevc->wport.sw_framerate = 8000;\r\ndevc->wport.sw_fragshift = DEFAULT_FRAGSHIFT;\r\ndevc->wport.sw_fragcount = DEFAULT_FRAGCOUNT;\r\ndevc->wport.sw_subdivshift = DEFAULT_SUBDIVSHIFT;\r\ndevc->wport.byte_count = 0;\r\ndevc->wport.frag_count = 0;\r\n}\r\n}\r\nmutex_unlock(&devc->io_mutex);\r\nfile->private_data = devc;\r\nDBGRV();\r\nmutex_unlock(&vwsnd_mutex);\r\nreturn 0;\r\n}\r\nstatic int vwsnd_audio_release(struct inode *inode, struct file *file)\r\n{\r\nvwsnd_dev_t *devc = (vwsnd_dev_t *) file->private_data;\r\nvwsnd_port_t *wport = NULL, *rport = NULL;\r\nint err = 0;\r\nmutex_lock(&vwsnd_mutex);\r\nmutex_lock(&devc->io_mutex);\r\n{\r\nDBGEV("(inode=0x%p, file=0x%p)\n", inode, file);\r\nif (file->f_mode & FMODE_READ)\r\nrport = &devc->rport;\r\nif (file->f_mode & FMODE_WRITE) {\r\nwport = &devc->wport;\r\npcm_flush_frag(devc);\r\npcm_write_sync(devc);\r\n}\r\npcm_shutdown(devc, rport, wport);\r\nif (rport)\r\nrport->swstate = SW_OFF;\r\nif (wport)\r\nwport->swstate = SW_OFF;\r\n}\r\nmutex_unlock(&devc->io_mutex);\r\nmutex_lock(&devc->open_mutex);\r\n{\r\ndevc->open_mode &= ~file->f_mode;\r\n}\r\nmutex_unlock(&devc->open_mutex);\r\nwake_up(&devc->open_wait);\r\nDEC_USE_COUNT;\r\nDBGR();\r\nmutex_unlock(&vwsnd_mutex);\r\nreturn err;\r\n}\r\nstatic int vwsnd_mixer_open(struct inode *inode, struct file *file)\r\n{\r\nvwsnd_dev_t *devc;\r\nDBGEV("(inode=0x%p, file=0x%p)\n", inode, file);\r\nINC_USE_COUNT;\r\nmutex_lock(&vwsnd_mutex);\r\nfor (devc = vwsnd_dev_list; devc; devc = devc->next_dev)\r\nif (devc->mixer_minor == iminor(inode))\r\nbreak;\r\nif (devc == NULL) {\r\nDEC_USE_COUNT;\r\nmutex_unlock(&vwsnd_mutex);\r\nreturn -ENODEV;\r\n}\r\nfile->private_data = devc;\r\nmutex_unlock(&vwsnd_mutex);\r\nreturn 0;\r\n}\r\nstatic int vwsnd_mixer_release(struct inode *inode, struct file *file)\r\n{\r\nDBGEV("(inode=0x%p, file=0x%p)\n", inode, file);\r\nDEC_USE_COUNT;\r\nreturn 0;\r\n}\r\nstatic int mixer_read_ioctl(vwsnd_dev_t *devc, unsigned int nr, void __user *arg)\r\n{\r\nint val = -1;\r\nDBGEV("(devc=0x%p, nr=0x%x, arg=0x%p)\n", devc, nr, arg);\r\nswitch (nr) {\r\ncase SOUND_MIXER_CAPS:\r\nval = SOUND_CAP_EXCL_INPUT;\r\nbreak;\r\ncase SOUND_MIXER_DEVMASK:\r\nval = (SOUND_MASK_PCM | SOUND_MASK_LINE |\r\nSOUND_MASK_MIC | SOUND_MASK_CD | SOUND_MASK_RECLEV);\r\nbreak;\r\ncase SOUND_MIXER_STEREODEVS:\r\nval = (SOUND_MASK_PCM | SOUND_MASK_LINE |\r\nSOUND_MASK_MIC | SOUND_MASK_CD | SOUND_MASK_RECLEV);\r\nbreak;\r\ncase SOUND_MIXER_OUTMASK:\r\nval = (SOUND_MASK_PCM | SOUND_MASK_LINE |\r\nSOUND_MASK_MIC | SOUND_MASK_CD);\r\nbreak;\r\ncase SOUND_MIXER_RECMASK:\r\nval = (SOUND_MASK_PCM | SOUND_MASK_LINE |\r\nSOUND_MASK_MIC | SOUND_MASK_CD);\r\nbreak;\r\ncase SOUND_MIXER_PCM:\r\nval = ad1843_get_gain(&devc->lith, &ad1843_gain_PCM);\r\nbreak;\r\ncase SOUND_MIXER_LINE:\r\nval = ad1843_get_gain(&devc->lith, &ad1843_gain_LINE);\r\nbreak;\r\ncase SOUND_MIXER_MIC:\r\nval = ad1843_get_gain(&devc->lith, &ad1843_gain_MIC);\r\nbreak;\r\ncase SOUND_MIXER_CD:\r\nval = ad1843_get_gain(&devc->lith, &ad1843_gain_CD);\r\nbreak;\r\ncase SOUND_MIXER_RECLEV:\r\nval = ad1843_get_gain(&devc->lith, &ad1843_gain_RECLEV);\r\nbreak;\r\ncase SOUND_MIXER_RECSRC:\r\nval = ad1843_get_recsrc(&devc->lith);\r\nbreak;\r\ncase SOUND_MIXER_OUTSRC:\r\nval = ad1843_get_outsrc(&devc->lith);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn put_user(val, (int __user *) arg);\r\n}\r\nstatic int mixer_write_ioctl(vwsnd_dev_t *devc, unsigned int nr, void __user *arg)\r\n{\r\nint val;\r\nint err;\r\nDBGEV("(devc=0x%p, nr=0x%x, arg=0x%p)\n", devc, nr, arg);\r\nerr = get_user(val, (int __user *) arg);\r\nif (err)\r\nreturn -EFAULT;\r\nswitch (nr) {\r\ncase SOUND_MIXER_PCM:\r\nval = ad1843_set_gain(&devc->lith, &ad1843_gain_PCM, val);\r\nbreak;\r\ncase SOUND_MIXER_LINE:\r\nval = ad1843_set_gain(&devc->lith, &ad1843_gain_LINE, val);\r\nbreak;\r\ncase SOUND_MIXER_MIC:\r\nval = ad1843_set_gain(&devc->lith, &ad1843_gain_MIC, val);\r\nbreak;\r\ncase SOUND_MIXER_CD:\r\nval = ad1843_set_gain(&devc->lith, &ad1843_gain_CD, val);\r\nbreak;\r\ncase SOUND_MIXER_RECLEV:\r\nval = ad1843_set_gain(&devc->lith, &ad1843_gain_RECLEV, val);\r\nbreak;\r\ncase SOUND_MIXER_RECSRC:\r\nif (devc->rport.swbuf || devc->wport.swbuf)\r\nreturn -EBUSY;\r\nval = ad1843_set_recsrc(&devc->lith, val);\r\nbreak;\r\ncase SOUND_MIXER_OUTSRC:\r\nval = ad1843_set_outsrc(&devc->lith, val);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (val < 0)\r\nreturn val;\r\nreturn put_user(val, (int __user *) arg);\r\n}\r\nstatic long vwsnd_mixer_ioctl(struct file *file,\r\nunsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvwsnd_dev_t *devc = (vwsnd_dev_t *) file->private_data;\r\nconst unsigned int nrmask = _IOC_NRMASK << _IOC_NRSHIFT;\r\nconst unsigned int nr = (cmd & nrmask) >> _IOC_NRSHIFT;\r\nint retval;\r\nDBGEV("(devc=0x%p, cmd=0x%x, arg=0x%lx)\n", devc, cmd, arg);\r\nmutex_lock(&vwsnd_mutex);\r\nmutex_lock(&devc->mix_mutex);\r\n{\r\nif ((cmd & ~nrmask) == MIXER_READ(0))\r\nretval = mixer_read_ioctl(devc, nr, (void __user *) arg);\r\nelse if ((cmd & ~nrmask) == MIXER_WRITE(0))\r\nretval = mixer_write_ioctl(devc, nr, (void __user *) arg);\r\nelse\r\nretval = -EINVAL;\r\n}\r\nmutex_unlock(&devc->mix_mutex);\r\nmutex_unlock(&vwsnd_mutex);\r\nreturn retval;\r\n}\r\nstatic int __init probe_vwsnd(struct address_info *hw_config)\r\n{\r\nlithium_t lith;\r\nint w;\r\nunsigned long later;\r\nDBGEV("(hw_config=0x%p)\n", hw_config);\r\nif (li_create(&lith, hw_config->io_base) != 0) {\r\nprintk(KERN_WARNING "probe_vwsnd: can't map lithium\n");\r\nreturn 0;\r\n}\r\nlater = jiffies + 2;\r\nli_writel(&lith, LI_HOST_CONTROLLER, LI_HC_LINK_ENABLE);\r\ndo {\r\nw = li_readl(&lith, LI_HOST_CONTROLLER);\r\n} while (w == LI_HC_LINK_ENABLE && time_before(jiffies, later));\r\nli_destroy(&lith);\r\nDBGPV("HC = 0x%04x\n", w);\r\nif ((w == LI_HC_LINK_ENABLE) || (w & LI_HC_LINK_CODEC)) {\r\nprintk(KERN_WARNING "probe_vwsnd: audio codec not found\n");\r\nreturn 0;\r\n}\r\nif (w & LI_HC_LINK_FAILURE) {\r\nprintk(KERN_WARNING "probe_vwsnd: can't init audio codec\n");\r\nreturn 0;\r\n}\r\nprintk(KERN_INFO "vwsnd: lithium audio at mmio %#x irq %d\n",\r\nhw_config->io_base, hw_config->irq);\r\nreturn 1;\r\n}\r\nstatic int __init attach_vwsnd(struct address_info *hw_config)\r\n{\r\nvwsnd_dev_t *devc = NULL;\r\nint err = -ENOMEM;\r\nDBGEV("(hw_config=0x%p)\n", hw_config);\r\ndevc = kmalloc(sizeof (vwsnd_dev_t), GFP_KERNEL);\r\nif (devc == NULL)\r\ngoto fail0;\r\nerr = li_create(&devc->lith, hw_config->io_base);\r\nif (err)\r\ngoto fail1;\r\ninit_waitqueue_head(&devc->open_wait);\r\ndevc->rport.hwbuf_size = HWBUF_SIZE;\r\ndevc->rport.hwbuf_vaddr = __get_free_pages(GFP_KERNEL, HWBUF_ORDER);\r\nif (!devc->rport.hwbuf_vaddr)\r\ngoto fail2;\r\ndevc->rport.hwbuf = (void *) devc->rport.hwbuf_vaddr;\r\ndevc->rport.hwbuf_paddr = virt_to_phys(devc->rport.hwbuf);\r\nli_writel(&devc->lith, LI_COMM1_BASE,\r\ndevc->rport.hwbuf_paddr >> 8 | 1 << (37 - 8));\r\ndevc->wport.hwbuf_size = HWBUF_SIZE;\r\ndevc->wport.hwbuf_vaddr = __get_free_pages(GFP_KERNEL, HWBUF_ORDER);\r\nif (!devc->wport.hwbuf_vaddr)\r\ngoto fail3;\r\ndevc->wport.hwbuf = (void *) devc->wport.hwbuf_vaddr;\r\ndevc->wport.hwbuf_paddr = virt_to_phys(devc->wport.hwbuf);\r\nDBGP("wport hwbuf = 0x%p\n", devc->wport.hwbuf);\r\nDBGDO(shut_up++);\r\nerr = ad1843_init(&devc->lith);\r\nDBGDO(shut_up--);\r\nif (err)\r\ngoto fail4;\r\nerr = request_irq(hw_config->irq, vwsnd_audio_intr, 0, "vwsnd", devc);\r\nif (err)\r\ngoto fail5;\r\ndevc->audio_minor = register_sound_dsp(&vwsnd_audio_fops, -1);\r\nif ((err = devc->audio_minor) < 0) {\r\nDBGDO(printk(KERN_WARNING\r\n"attach_vwsnd: register_sound_dsp error %d\n",\r\nerr));\r\ngoto fail6;\r\n}\r\ndevc->mixer_minor = register_sound_mixer(&vwsnd_mixer_fops,\r\ndevc->audio_minor >> 4);\r\nif ((err = devc->mixer_minor) < 0) {\r\nDBGDO(printk(KERN_WARNING\r\n"attach_vwsnd: register_sound_mixer error %d\n",\r\nerr));\r\ngoto fail7;\r\n}\r\nhw_config->slots[0] = devc->audio_minor;\r\nmutex_init(&devc->open_mutex);\r\nmutex_init(&devc->io_mutex);\r\nmutex_init(&devc->mix_mutex);\r\ndevc->open_mode = 0;\r\nspin_lock_init(&devc->rport.lock);\r\ninit_waitqueue_head(&devc->rport.queue);\r\ndevc->rport.swstate = SW_OFF;\r\ndevc->rport.hwstate = HW_STOPPED;\r\ndevc->rport.flags = 0;\r\ndevc->rport.swbuf = NULL;\r\nspin_lock_init(&devc->wport.lock);\r\ninit_waitqueue_head(&devc->wport.queue);\r\ndevc->wport.swstate = SW_OFF;\r\ndevc->wport.hwstate = HW_STOPPED;\r\ndevc->wport.flags = 0;\r\ndevc->wport.swbuf = NULL;\r\ndevc->next_dev = vwsnd_dev_list;\r\nvwsnd_dev_list = devc;\r\nreturn devc->audio_minor;\r\nfail7:\r\nunregister_sound_dsp(devc->audio_minor);\r\nfail6:\r\nfree_irq(hw_config->irq, devc);\r\nfail5:\r\nfail4:\r\nfree_pages(devc->wport.hwbuf_vaddr, HWBUF_ORDER);\r\nfail3:\r\nfree_pages(devc->rport.hwbuf_vaddr, HWBUF_ORDER);\r\nfail2:\r\nli_destroy(&devc->lith);\r\nfail1:\r\nkfree(devc);\r\nfail0:\r\nreturn err;\r\n}\r\nstatic int __exit unload_vwsnd(struct address_info *hw_config)\r\n{\r\nvwsnd_dev_t *devc, **devcp;\r\nDBGE("()\n");\r\ndevcp = &vwsnd_dev_list;\r\nwhile ((devc = *devcp)) {\r\nif (devc->audio_minor == hw_config->slots[0]) {\r\n*devcp = devc->next_dev;\r\nbreak;\r\n}\r\ndevcp = &devc->next_dev;\r\n}\r\nif (!devc)\r\nreturn -ENODEV;\r\nunregister_sound_mixer(devc->mixer_minor);\r\nunregister_sound_dsp(devc->audio_minor);\r\nfree_irq(hw_config->irq, devc);\r\nfree_pages(devc->wport.hwbuf_vaddr, HWBUF_ORDER);\r\nfree_pages(devc->rport.hwbuf_vaddr, HWBUF_ORDER);\r\nli_destroy(&devc->lith);\r\nkfree(devc);\r\nreturn 0;\r\n}\r\nstatic int __init init_vwsnd(void)\r\n{\r\nint err;\r\nDBGXV("\n");\r\nDBGXV("sound::vwsnd::init_module()\n");\r\nif (!probe_vwsnd(&the_hw_config))\r\nreturn -ENODEV;\r\nerr = attach_vwsnd(&the_hw_config);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_vwsnd(void)\r\n{\r\nDBGX("sound::vwsnd::cleanup_module()\n");\r\nunload_vwsnd(&the_hw_config);\r\n}
