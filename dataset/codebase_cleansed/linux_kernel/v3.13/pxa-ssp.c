static void dump_registers(struct ssp_device *ssp)\r\n{\r\ndev_dbg(&ssp->pdev->dev, "SSCR0 0x%08x SSCR1 0x%08x SSTO 0x%08x\n",\r\npxa_ssp_read_reg(ssp, SSCR0), pxa_ssp_read_reg(ssp, SSCR1),\r\npxa_ssp_read_reg(ssp, SSTO));\r\ndev_dbg(&ssp->pdev->dev, "SSPSP 0x%08x SSSR 0x%08x SSACD 0x%08x\n",\r\npxa_ssp_read_reg(ssp, SSPSP), pxa_ssp_read_reg(ssp, SSSR),\r\npxa_ssp_read_reg(ssp, SSACD));\r\n}\r\nstatic void pxa_ssp_enable(struct ssp_device *ssp)\r\n{\r\nuint32_t sscr0;\r\nsscr0 = __raw_readl(ssp->mmio_base + SSCR0) | SSCR0_SSE;\r\n__raw_writel(sscr0, ssp->mmio_base + SSCR0);\r\n}\r\nstatic void pxa_ssp_disable(struct ssp_device *ssp)\r\n{\r\nuint32_t sscr0;\r\nsscr0 = __raw_readl(ssp->mmio_base + SSCR0) & ~SSCR0_SSE;\r\n__raw_writel(sscr0, ssp->mmio_base + SSCR0);\r\n}\r\nstatic void pxa_ssp_set_dma_params(struct ssp_device *ssp, int width4,\r\nint out, struct snd_dmaengine_dai_dma_data *dma)\r\n{\r\ndma->addr_width = width4 ? DMA_SLAVE_BUSWIDTH_4_BYTES :\r\nDMA_SLAVE_BUSWIDTH_2_BYTES;\r\ndma->maxburst = 16;\r\ndma->addr = ssp->phys_base + SSDR;\r\n}\r\nstatic int pxa_ssp_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct ssp_device *ssp = priv->ssp;\r\nstruct snd_dmaengine_dai_dma_data *dma;\r\nint ret = 0;\r\nif (!cpu_dai->active) {\r\nclk_enable(ssp->clk);\r\npxa_ssp_disable(ssp);\r\n}\r\ndma = kzalloc(sizeof(struct snd_dmaengine_dai_dma_data), GFP_KERNEL);\r\nif (!dma)\r\nreturn -ENOMEM;\r\ndma->filter_data = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?\r\n&ssp->drcmr_tx : &ssp->drcmr_rx;\r\nsnd_soc_dai_set_dma_data(cpu_dai, substream, dma);\r\nreturn ret;\r\n}\r\nstatic void pxa_ssp_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct ssp_device *ssp = priv->ssp;\r\nif (!cpu_dai->active) {\r\npxa_ssp_disable(ssp);\r\nclk_disable(ssp->clk);\r\n}\r\nkfree(snd_soc_dai_get_dma_data(cpu_dai, substream));\r\nsnd_soc_dai_set_dma_data(cpu_dai, substream, NULL);\r\n}\r\nstatic int pxa_ssp_suspend(struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct ssp_device *ssp = priv->ssp;\r\nif (!cpu_dai->active)\r\nclk_enable(ssp->clk);\r\npriv->cr0 = __raw_readl(ssp->mmio_base + SSCR0);\r\npriv->cr1 = __raw_readl(ssp->mmio_base + SSCR1);\r\npriv->to = __raw_readl(ssp->mmio_base + SSTO);\r\npriv->psp = __raw_readl(ssp->mmio_base + SSPSP);\r\npxa_ssp_disable(ssp);\r\nclk_disable(ssp->clk);\r\nreturn 0;\r\n}\r\nstatic int pxa_ssp_resume(struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct ssp_device *ssp = priv->ssp;\r\nuint32_t sssr = SSSR_ROR | SSSR_TUR | SSSR_BCE;\r\nclk_enable(ssp->clk);\r\n__raw_writel(sssr, ssp->mmio_base + SSSR);\r\n__raw_writel(priv->cr0 & ~SSCR0_SSE, ssp->mmio_base + SSCR0);\r\n__raw_writel(priv->cr1, ssp->mmio_base + SSCR1);\r\n__raw_writel(priv->to, ssp->mmio_base + SSTO);\r\n__raw_writel(priv->psp, ssp->mmio_base + SSPSP);\r\nif (cpu_dai->active)\r\npxa_ssp_enable(ssp);\r\nelse\r\nclk_disable(ssp->clk);\r\nreturn 0;\r\n}\r\nstatic void pxa_ssp_set_scr(struct ssp_device *ssp, u32 div)\r\n{\r\nu32 sscr0 = pxa_ssp_read_reg(ssp, SSCR0);\r\nif (ssp->type == PXA25x_SSP) {\r\nsscr0 &= ~0x0000ff00;\r\nsscr0 |= ((div - 2)/2) << 8;\r\n} else {\r\nsscr0 &= ~0x000fff00;\r\nsscr0 |= (div - 1) << 8;\r\n}\r\npxa_ssp_write_reg(ssp, SSCR0, sscr0);\r\n}\r\nstatic u32 pxa_ssp_get_scr(struct ssp_device *ssp)\r\n{\r\nu32 sscr0 = pxa_ssp_read_reg(ssp, SSCR0);\r\nu32 div;\r\nif (ssp->type == PXA25x_SSP)\r\ndiv = ((sscr0 >> 8) & 0xff) * 2 + 2;\r\nelse\r\ndiv = ((sscr0 >> 8) & 0xfff) + 1;\r\nreturn div;\r\n}\r\nstatic int pxa_ssp_set_dai_sysclk(struct snd_soc_dai *cpu_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct ssp_device *ssp = priv->ssp;\r\nint val;\r\nu32 sscr0 = pxa_ssp_read_reg(ssp, SSCR0) &\r\n~(SSCR0_ECS | SSCR0_NCS | SSCR0_MOD | SSCR0_ACS);\r\ndev_dbg(&ssp->pdev->dev,\r\n"pxa_ssp_set_dai_sysclk id: %d, clk_id %d, freq %u\n",\r\ncpu_dai->id, clk_id, freq);\r\nswitch (clk_id) {\r\ncase PXA_SSP_CLK_NET_PLL:\r\nsscr0 |= SSCR0_MOD;\r\nbreak;\r\ncase PXA_SSP_CLK_PLL:\r\nif (ssp->type == PXA25x_SSP)\r\npriv->sysclk = 1843200;\r\nelse\r\npriv->sysclk = 13000000;\r\nbreak;\r\ncase PXA_SSP_CLK_EXT:\r\npriv->sysclk = freq;\r\nsscr0 |= SSCR0_ECS;\r\nbreak;\r\ncase PXA_SSP_CLK_NET:\r\npriv->sysclk = freq;\r\nsscr0 |= SSCR0_NCS | SSCR0_MOD;\r\nbreak;\r\ncase PXA_SSP_CLK_AUDIO:\r\npriv->sysclk = 0;\r\npxa_ssp_set_scr(ssp, 1);\r\nsscr0 |= SSCR0_ACS;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nif (ssp->type != PXA3xx_SSP)\r\nclk_disable(ssp->clk);\r\nval = pxa_ssp_read_reg(ssp, SSCR0) | sscr0;\r\npxa_ssp_write_reg(ssp, SSCR0, val);\r\nif (ssp->type != PXA3xx_SSP)\r\nclk_enable(ssp->clk);\r\nreturn 0;\r\n}\r\nstatic int pxa_ssp_set_dai_clkdiv(struct snd_soc_dai *cpu_dai,\r\nint div_id, int div)\r\n{\r\nstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct ssp_device *ssp = priv->ssp;\r\nint val;\r\nswitch (div_id) {\r\ncase PXA_SSP_AUDIO_DIV_ACDS:\r\nval = (pxa_ssp_read_reg(ssp, SSACD) & ~0x7) | SSACD_ACDS(div);\r\npxa_ssp_write_reg(ssp, SSACD, val);\r\nbreak;\r\ncase PXA_SSP_AUDIO_DIV_SCDB:\r\nval = pxa_ssp_read_reg(ssp, SSACD);\r\nval &= ~SSACD_SCDB;\r\nif (ssp->type == PXA3xx_SSP)\r\nval &= ~SSACD_SCDX8;\r\nswitch (div) {\r\ncase PXA_SSP_CLK_SCDB_1:\r\nval |= SSACD_SCDB;\r\nbreak;\r\ncase PXA_SSP_CLK_SCDB_4:\r\nbreak;\r\ncase PXA_SSP_CLK_SCDB_8:\r\nif (ssp->type == PXA3xx_SSP)\r\nval |= SSACD_SCDX8;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npxa_ssp_write_reg(ssp, SSACD, val);\r\nbreak;\r\ncase PXA_SSP_DIV_SCR:\r\npxa_ssp_set_scr(ssp, div);\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pxa_ssp_set_dai_pll(struct snd_soc_dai *cpu_dai, int pll_id,\r\nint source, unsigned int freq_in, unsigned int freq_out)\r\n{\r\nstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct ssp_device *ssp = priv->ssp;\r\nu32 ssacd = pxa_ssp_read_reg(ssp, SSACD) & ~0x70;\r\nif (ssp->type == PXA3xx_SSP)\r\npxa_ssp_write_reg(ssp, SSACDD, 0);\r\nswitch (freq_out) {\r\ncase 5622000:\r\nbreak;\r\ncase 11345000:\r\nssacd |= (0x1 << 4);\r\nbreak;\r\ncase 12235000:\r\nssacd |= (0x2 << 4);\r\nbreak;\r\ncase 14857000:\r\nssacd |= (0x3 << 4);\r\nbreak;\r\ncase 32842000:\r\nssacd |= (0x4 << 4);\r\nbreak;\r\ncase 48000000:\r\nssacd |= (0x5 << 4);\r\nbreak;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nif (ssp->type == PXA3xx_SSP) {\r\nu32 val;\r\nu64 tmp = 19968;\r\ntmp *= 1000000;\r\ndo_div(tmp, freq_out);\r\nval = tmp;\r\nval = (val << 16) | 64;\r\npxa_ssp_write_reg(ssp, SSACDD, val);\r\nssacd |= (0x6 << 4);\r\ndev_dbg(&ssp->pdev->dev,\r\n"Using SSACDD %x to supply %uHz\n",\r\nval, freq_out);\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\npxa_ssp_write_reg(ssp, SSACD, ssacd);\r\nreturn 0;\r\n}\r\nstatic int pxa_ssp_set_dai_tdm_slot(struct snd_soc_dai *cpu_dai,\r\nunsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)\r\n{\r\nstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct ssp_device *ssp = priv->ssp;\r\nu32 sscr0;\r\nsscr0 = pxa_ssp_read_reg(ssp, SSCR0);\r\nsscr0 &= ~(SSCR0_MOD | SSCR0_SlotsPerFrm(8) | SSCR0_EDSS | SSCR0_DSS);\r\nif (slot_width > 16)\r\nsscr0 |= SSCR0_EDSS | SSCR0_DataSize(slot_width - 16);\r\nelse\r\nsscr0 |= SSCR0_DataSize(slot_width);\r\nif (slots > 1) {\r\nsscr0 |= SSCR0_MOD;\r\nsscr0 |= SSCR0_SlotsPerFrm(slots);\r\npxa_ssp_write_reg(ssp, SSTSA, tx_mask);\r\npxa_ssp_write_reg(ssp, SSRSA, rx_mask);\r\n}\r\npxa_ssp_write_reg(ssp, SSCR0, sscr0);\r\nreturn 0;\r\n}\r\nstatic int pxa_ssp_set_dai_tristate(struct snd_soc_dai *cpu_dai,\r\nint tristate)\r\n{\r\nstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct ssp_device *ssp = priv->ssp;\r\nu32 sscr1;\r\nsscr1 = pxa_ssp_read_reg(ssp, SSCR1);\r\nif (tristate)\r\nsscr1 &= ~SSCR1_TTE;\r\nelse\r\nsscr1 |= SSCR1_TTE;\r\npxa_ssp_write_reg(ssp, SSCR1, sscr1);\r\nreturn 0;\r\n}\r\nstatic int pxa_ssp_set_dai_fmt(struct snd_soc_dai *cpu_dai,\r\nunsigned int fmt)\r\n{\r\nstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct ssp_device *ssp = priv->ssp;\r\nu32 sscr0, sscr1, sspsp, scfr;\r\nif (priv->dai_fmt == fmt)\r\nreturn 0;\r\nif (pxa_ssp_read_reg(ssp, SSCR0) & SSCR0_SSE) {\r\ndev_err(&ssp->pdev->dev,\r\n"can't change hardware dai format: stream is in use");\r\nreturn -EINVAL;\r\n}\r\nsscr0 = pxa_ssp_read_reg(ssp, SSCR0) &\r\n~(SSCR0_ECS | SSCR0_NCS | SSCR0_MOD | SSCR0_ACS);\r\nsscr1 = SSCR1_RxTresh(8) | SSCR1_TxTresh(7);\r\nsspsp = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nsscr1 |= SSCR1_SCLKDIR | SSCR1_SFRMDIR | SSCR1_SCFR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nsscr1 |= SSCR1_SCLKDIR | SSCR1_SCFR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nsspsp |= SSPSP_SFRMP;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nsspsp |= SSPSP_SCMODE(2);\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nsspsp |= SSPSP_SCMODE(2) | SSPSP_SFRMP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nsscr0 |= SSCR0_PSP;\r\nsscr1 |= SSCR1_RWOT | SSCR1_TRAIL;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nsspsp |= SSPSP_FSRT;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nsscr0 |= SSCR0_MOD | SSCR0_PSP;\r\nsscr1 |= SSCR1_TRAIL | SSCR1_RWOT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npxa_ssp_write_reg(ssp, SSCR0, sscr0);\r\npxa_ssp_write_reg(ssp, SSCR1, sscr1);\r\npxa_ssp_write_reg(ssp, SSPSP, sspsp);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nscfr = pxa_ssp_read_reg(ssp, SSCR1) | SSCR1_SCFR;\r\npxa_ssp_write_reg(ssp, SSCR1, scfr);\r\nwhile (pxa_ssp_read_reg(ssp, SSSR) & SSSR_BSY)\r\ncpu_relax();\r\nbreak;\r\n}\r\ndump_registers(ssp);\r\npriv->dai_fmt = fmt;\r\nreturn 0;\r\n}\r\nstatic int pxa_ssp_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct ssp_device *ssp = priv->ssp;\r\nint chn = params_channels(params);\r\nu32 sscr0;\r\nu32 sspsp;\r\nint width = snd_pcm_format_physical_width(params_format(params));\r\nint ttsa = pxa_ssp_read_reg(ssp, SSTSA) & 0xf;\r\nstruct snd_dmaengine_dai_dma_data *dma_data;\r\ndma_data = snd_soc_dai_get_dma_data(cpu_dai, substream);\r\npxa_ssp_set_dma_params(ssp,\r\n((chn == 2) && (ttsa != 1)) || (width == 32),\r\nsubstream->stream == SNDRV_PCM_STREAM_PLAYBACK, dma_data);\r\nif (pxa_ssp_read_reg(ssp, SSCR0) & SSCR0_SSE)\r\nreturn 0;\r\nsscr0 = pxa_ssp_read_reg(ssp, SSCR0) & ~(SSCR0_DSS | SSCR0_EDSS);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nif (ssp->type == PXA3xx_SSP)\r\nsscr0 |= SSCR0_FPCKE;\r\nsscr0 |= SSCR0_DataSize(16);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nsscr0 |= (SSCR0_EDSS | SSCR0_DataSize(8));\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nsscr0 |= (SSCR0_EDSS | SSCR0_DataSize(16));\r\nbreak;\r\n}\r\npxa_ssp_write_reg(ssp, SSCR0, sscr0);\r\nswitch (priv->dai_fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nsspsp = pxa_ssp_read_reg(ssp, SSPSP);\r\nif ((pxa_ssp_get_scr(ssp) == 4) && (width == 16)) {\r\nif (ssp->type != PXA3xx_SSP)\r\nreturn -EINVAL;\r\nsspsp |= SSPSP_SFRMWDTH(width * 2);\r\nsspsp |= SSPSP_SFRMDLY(width * 4);\r\nsspsp |= SSPSP_EDMYSTOP(3);\r\nsspsp |= SSPSP_DMYSTOP(3);\r\nsspsp |= SSPSP_DMYSTRT(1);\r\n} else {\r\nsspsp |= SSPSP_SFRMWDTH(width + 1);\r\nsspsp |= SSPSP_SFRMDLY((width + 1) * 2);\r\nsspsp |= SSPSP_DMYSTRT(1);\r\n}\r\npxa_ssp_write_reg(ssp, SSPSP, sspsp);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif ((sscr0 & SSCR0_MOD) && !ttsa) {\r\ndev_err(&ssp->pdev->dev, "No TDM timeslot configured\n");\r\nreturn -EINVAL;\r\n}\r\ndump_registers(ssp);\r\nreturn 0;\r\n}\r\nstatic void pxa_ssp_set_running_bit(struct snd_pcm_substream *substream,\r\nstruct ssp_device *ssp, int value)\r\n{\r\nuint32_t sscr0 = pxa_ssp_read_reg(ssp, SSCR0);\r\nuint32_t sscr1 = pxa_ssp_read_reg(ssp, SSCR1);\r\nuint32_t sspsp = pxa_ssp_read_reg(ssp, SSPSP);\r\nuint32_t sssr = pxa_ssp_read_reg(ssp, SSSR);\r\nif (value && (sscr0 & SSCR0_SSE))\r\npxa_ssp_write_reg(ssp, SSCR0, sscr0 & ~SSCR0_SSE);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (value)\r\nsscr1 |= SSCR1_TSRE;\r\nelse\r\nsscr1 &= ~SSCR1_TSRE;\r\n} else {\r\nif (value)\r\nsscr1 |= SSCR1_RSRE;\r\nelse\r\nsscr1 &= ~SSCR1_RSRE;\r\n}\r\npxa_ssp_write_reg(ssp, SSCR1, sscr1);\r\nif (value) {\r\npxa_ssp_write_reg(ssp, SSSR, sssr);\r\npxa_ssp_write_reg(ssp, SSPSP, sspsp);\r\npxa_ssp_write_reg(ssp, SSCR0, sscr0 | SSCR0_SSE);\r\n}\r\n}\r\nstatic int pxa_ssp_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nint ret = 0;\r\nstruct ssp_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct ssp_device *ssp = priv->ssp;\r\nint val;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\npxa_ssp_enable(ssp);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\npxa_ssp_set_running_bit(substream, ssp, 1);\r\nval = pxa_ssp_read_reg(ssp, SSSR);\r\npxa_ssp_write_reg(ssp, SSSR, val);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_START:\r\npxa_ssp_set_running_bit(substream, ssp, 1);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\npxa_ssp_set_running_bit(substream, ssp, 0);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\npxa_ssp_disable(ssp);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\npxa_ssp_set_running_bit(substream, ssp, 0);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\ndump_registers(ssp);\r\nreturn ret;\r\n}\r\nstatic int pxa_ssp_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct device *dev = dai->dev;\r\nstruct ssp_priv *priv;\r\nint ret;\r\npriv = kzalloc(sizeof(struct ssp_priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nif (dev->of_node) {\r\nstruct device_node *ssp_handle;\r\nssp_handle = of_parse_phandle(dev->of_node, "port", 0);\r\nif (!ssp_handle) {\r\ndev_err(dev, "unable to get 'port' phandle\n");\r\nreturn -ENODEV;\r\n}\r\npriv->ssp = pxa_ssp_request_of(ssp_handle, "SoC audio");\r\nif (priv->ssp == NULL) {\r\nret = -ENODEV;\r\ngoto err_priv;\r\n}\r\n} else {\r\npriv->ssp = pxa_ssp_request(dai->id + 1, "SoC audio");\r\nif (priv->ssp == NULL) {\r\nret = -ENODEV;\r\ngoto err_priv;\r\n}\r\n}\r\npriv->dai_fmt = (unsigned int) -1;\r\nsnd_soc_dai_set_drvdata(dai, priv);\r\nreturn 0;\r\nerr_priv:\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nstatic int pxa_ssp_remove(struct snd_soc_dai *dai)\r\n{\r\nstruct ssp_priv *priv = snd_soc_dai_get_drvdata(dai);\r\npxa_ssp_free(priv->ssp);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int asoc_ssp_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_component(&pdev->dev, &pxa_ssp_component,\r\n&pxa_ssp_dai, 1);\r\n}\r\nstatic int asoc_ssp_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_component(&pdev->dev);\r\nreturn 0;\r\n}
