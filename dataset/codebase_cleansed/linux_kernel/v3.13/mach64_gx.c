static void aty_dac_waste4(const struct atyfb_par *par)\r\n{\r\n(void) aty_ld_8(DAC_REGS, par);\r\n(void) aty_ld_8(DAC_REGS + 2, par);\r\n(void) aty_ld_8(DAC_REGS + 2, par);\r\n(void) aty_ld_8(DAC_REGS + 2, par);\r\n(void) aty_ld_8(DAC_REGS + 2, par);\r\n}\r\nstatic void aty_StrobeClock(const struct atyfb_par *par)\r\n{\r\nu8 tmp;\r\nudelay(26);\r\ntmp = aty_ld_8(CLOCK_CNTL, par);\r\naty_st_8(CLOCK_CNTL + par->clk_wr_offset, tmp | CLOCK_STROBE, par);\r\nreturn;\r\n}\r\nstatic void aty_st_514(int offset, u8 val, const struct atyfb_par *par)\r\n{\r\naty_st_8(DAC_CNTL, 1, par);\r\naty_st_8(DAC_W_INDEX, offset & 0xff, par);\r\naty_st_8(DAC_DATA, (offset >> 8) & 0xff, par);\r\naty_st_8(DAC_MASK, val, par);\r\naty_st_8(DAC_CNTL, 0, par);\r\n}\r\nstatic int aty_set_dac_514(const struct fb_info *info,\r\nconst union aty_pll *pll, u32 bpp, u32 accel)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nstatic struct {\r\nu8 pixel_dly;\r\nu8 misc2_cntl;\r\nu8 pixel_rep;\r\nu8 pixel_cntl_index;\r\nu8 pixel_cntl_v1;\r\n} tab[3] = {\r\n{\r\n0, 0x41, 0x03, 0x71, 0x45},\r\n{\r\n0, 0x45, 0x04, 0x0c, 0x01},\r\n{\r\n0, 0x45, 0x06, 0x0e, 0x00},\r\n};\r\nint i;\r\nswitch (bpp) {\r\ncase 8:\r\ndefault:\r\ni = 0;\r\nbreak;\r\ncase 16:\r\ni = 1;\r\nbreak;\r\ncase 32:\r\ni = 2;\r\nbreak;\r\n}\r\naty_st_514(0x90, 0x00, par);\r\naty_st_514(0x04, tab[i].pixel_dly, par);\r\naty_st_514(0x05, 0x00, par);\r\naty_st_514(0x02, 0x01, par);\r\naty_st_514(0x71, tab[i].misc2_cntl, par);\r\naty_st_514(0x0a, tab[i].pixel_rep, par);\r\naty_st_514(tab[i].pixel_cntl_index, tab[i].pixel_cntl_v1, par);\r\nreturn 0;\r\n}\r\nstatic int aty_var_to_pll_514(const struct fb_info *info, u32 vclk_per,\r\nu32 bpp, union aty_pll *pll)\r\n{\r\nstatic struct {\r\nu32 limit;\r\nu8 m;\r\nu8 n;\r\n} RGB514_clocks[7] = {\r\n{\r\n8000, (3 << 6) | 20, 9},\r\n{\r\n10000, (1 << 6) | 19, 3},\r\n{\r\n13000, (1 << 6) | 2, 3},\r\n{\r\n14000, (2 << 6) | 8, 7},\r\n{\r\n16000, (1 << 6) | 44, 6},\r\n{\r\n25000, (1 << 6) | 15, 5},\r\n{\r\n50000, (0 << 6) | 53, 7},\r\n};\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(RGB514_clocks); i++)\r\nif (vclk_per <= RGB514_clocks[i].limit) {\r\npll->ibm514.m = RGB514_clocks[i].m;\r\npll->ibm514.n = RGB514_clocks[i].n;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic u32 aty_pll_514_to_var(const struct fb_info *info,\r\nconst union aty_pll *pll)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nu8 df, vco_div_count, ref_div_count;\r\ndf = pll->ibm514.m >> 6;\r\nvco_div_count = pll->ibm514.m & 0x3f;\r\nref_div_count = pll->ibm514.n;\r\nreturn ((par->ref_clk_per * ref_div_count) << (3 - df))/\r\n(vco_div_count + 65);\r\n}\r\nstatic void aty_set_pll_514(const struct fb_info *info,\r\nconst union aty_pll *pll)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\naty_st_514(0x06, 0x02, par);\r\naty_st_514(0x10, 0x01, par);\r\naty_st_514(0x70, 0x01, par);\r\naty_st_514(0x8f, 0x1f, par);\r\naty_st_514(0x03, 0x00, par);\r\naty_st_514(0x05, 0x00, par);\r\naty_st_514(0x20, pll->ibm514.m, par);\r\naty_st_514(0x21, pll->ibm514.n, par);\r\n}\r\nstatic int aty_set_dac_ATI68860_B(const struct fb_info *info,\r\nconst union aty_pll *pll, u32 bpp,\r\nu32 accel)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nu32 gModeReg, devSetupRegA, temp, mask;\r\ngModeReg = 0;\r\ndevSetupRegA = 0;\r\nswitch (bpp) {\r\ncase 8:\r\ngModeReg = 0x83;\r\ndevSetupRegA =\r\n0x60 | 0x00 ;\r\nbreak;\r\ncase 15:\r\ngModeReg = 0xA0;\r\ndevSetupRegA = 0x60;\r\nbreak;\r\ncase 16:\r\ngModeReg = 0xA1;\r\ndevSetupRegA = 0x60;\r\nbreak;\r\ncase 24:\r\ngModeReg = 0xC0;\r\ndevSetupRegA = 0x60;\r\nbreak;\r\ncase 32:\r\ngModeReg = 0xE3;\r\ndevSetupRegA = 0x60;\r\nbreak;\r\n}\r\nif (!accel) {\r\ngModeReg = 0x80;\r\ndevSetupRegA = 0x61;\r\n}\r\ntemp = aty_ld_8(DAC_CNTL, par);\r\naty_st_8(DAC_CNTL, (temp & ~DAC_EXT_SEL_RS2) | DAC_EXT_SEL_RS3,\r\npar);\r\naty_st_8(DAC_REGS + 2, 0x1D, par);\r\naty_st_8(DAC_REGS + 3, gModeReg, par);\r\naty_st_8(DAC_REGS, 0x02, par);\r\ntemp = aty_ld_8(DAC_CNTL, par);\r\naty_st_8(DAC_CNTL, temp | DAC_EXT_SEL_RS2 | DAC_EXT_SEL_RS3, par);\r\nif (info->fix.smem_len < ONE_MB)\r\nmask = 0x04;\r\nelse if (info->fix.smem_len == ONE_MB)\r\nmask = 0x08;\r\nelse\r\nmask = 0x0C;\r\n#define A860_DELAY_L 0x80\r\ntemp = aty_ld_8(DAC_REGS, par);\r\naty_st_8(DAC_REGS, (devSetupRegA | mask) | (temp & A860_DELAY_L),\r\npar);\r\ntemp = aty_ld_8(DAC_CNTL, par);\r\naty_st_8(DAC_CNTL, (temp & ~(DAC_EXT_SEL_RS2 | DAC_EXT_SEL_RS3)),\r\npar);\r\naty_st_le32(BUS_CNTL, 0x890e20f1, par);\r\naty_st_le32(DAC_CNTL, 0x47052100, par);\r\nreturn 0;\r\n}\r\nstatic int aty_set_dac_ATT21C498(const struct fb_info *info,\r\nconst union aty_pll *pll, u32 bpp,\r\nu32 accel)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nu32 dotClock;\r\nint muxmode = 0;\r\nint DACMask = 0;\r\ndotClock = 100000000 / pll->ics2595.period_in_ps;\r\nswitch (bpp) {\r\ncase 8:\r\nif (dotClock > 8000) {\r\nDACMask = 0x24;\r\nmuxmode = 1;\r\n} else\r\nDACMask = 0x04;\r\nbreak;\r\ncase 15:\r\nDACMask = 0x16;\r\nbreak;\r\ncase 16:\r\nDACMask = 0x36;\r\nbreak;\r\ncase 24:\r\nDACMask = 0xE6;\r\nbreak;\r\ncase 32:\r\nDACMask = 0xE6;\r\nbreak;\r\n}\r\nif (1 )\r\nDACMask |= 0x02;\r\naty_dac_waste4(par);\r\naty_st_8(DAC_REGS + 2, DACMask, par);\r\naty_st_le32(BUS_CNTL, 0x890e20f1, par);\r\naty_st_le32(DAC_CNTL, 0x00072000, par);\r\nreturn muxmode;\r\n}\r\nstatic int aty_var_to_pll_18818(const struct fb_info *info, u32 vclk_per,\r\nu32 bpp, union aty_pll *pll)\r\n{\r\nu32 MHz100;\r\nu32 program_bits;\r\nu32 post_divider;\r\nMHz100 = 100000000 / vclk_per;\r\nprogram_bits = -1;\r\npost_divider = 1;\r\nif (MHz100 > MAX_FREQ_2595) {\r\nMHz100 = MAX_FREQ_2595;\r\nreturn -EINVAL;\r\n} else if (MHz100 < ABS_MIN_FREQ_2595) {\r\nprogram_bits = 0;\r\nreturn -EINVAL;\r\n} else {\r\nwhile (MHz100 < MIN_FREQ_2595) {\r\nMHz100 *= 2;\r\npost_divider *= 2;\r\n}\r\n}\r\nMHz100 *= 1000;\r\nMHz100 = (REF_DIV_2595 * MHz100) / REF_FREQ_2595;\r\nMHz100 += 500;\r\nMHz100 /= 1000;\r\nif (program_bits == -1) {\r\nprogram_bits = MHz100 - N_ADJ_2595;\r\nswitch (post_divider) {\r\ncase 1:\r\nprogram_bits |= 0x0600;\r\nbreak;\r\ncase 2:\r\nprogram_bits |= 0x0400;\r\nbreak;\r\ncase 4:\r\nprogram_bits |= 0x0200;\r\nbreak;\r\ncase 8:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nprogram_bits |= STOP_BITS_2595;\r\npll->ics2595.program_bits = program_bits;\r\npll->ics2595.locationAddr = 0;\r\npll->ics2595.post_divider = post_divider;\r\npll->ics2595.period_in_ps = vclk_per;\r\nreturn 0;\r\n}\r\nstatic u32 aty_pll_18818_to_var(const struct fb_info *info,\r\nconst union aty_pll *pll)\r\n{\r\nreturn (pll->ics2595.period_in_ps);\r\n}\r\nstatic void aty_ICS2595_put1bit(u8 data, const struct atyfb_par *par)\r\n{\r\nu8 tmp;\r\ndata &= 0x01;\r\ntmp = aty_ld_8(CLOCK_CNTL, par);\r\naty_st_8(CLOCK_CNTL + par->clk_wr_offset,\r\n(tmp & ~0x04) | (data << 2), par);\r\ntmp = aty_ld_8(CLOCK_CNTL, par);\r\naty_st_8(CLOCK_CNTL + par->clk_wr_offset, (tmp & ~0x08) | (0 << 3),\r\npar);\r\naty_StrobeClock(par);\r\ntmp = aty_ld_8(CLOCK_CNTL, par);\r\naty_st_8(CLOCK_CNTL + par->clk_wr_offset, (tmp & ~0x08) | (1 << 3),\r\npar);\r\naty_StrobeClock(par);\r\nreturn;\r\n}\r\nstatic void aty_set_pll18818(const struct fb_info *info,\r\nconst union aty_pll *pll)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nu32 program_bits;\r\nu32 locationAddr;\r\nu32 i;\r\nu8 old_clock_cntl;\r\nu8 old_crtc_ext_disp;\r\nold_clock_cntl = aty_ld_8(CLOCK_CNTL, par);\r\naty_st_8(CLOCK_CNTL + par->clk_wr_offset, 0, par);\r\nold_crtc_ext_disp = aty_ld_8(CRTC_GEN_CNTL + 3, par);\r\naty_st_8(CRTC_GEN_CNTL + 3,\r\nold_crtc_ext_disp | (CRTC_EXT_DISP_EN >> 24), par);\r\nmdelay(15);\r\nprogram_bits = pll->ics2595.program_bits;\r\nlocationAddr = pll->ics2595.locationAddr;\r\naty_st_8(CLOCK_CNTL + par->clk_wr_offset, 0, par);\r\naty_StrobeClock(par);\r\naty_st_8(CLOCK_CNTL + par->clk_wr_offset, 1, par);\r\naty_StrobeClock(par);\r\naty_ICS2595_put1bit(1, par);\r\naty_ICS2595_put1bit(0, par);\r\naty_ICS2595_put1bit(0, par);\r\nfor (i = 0; i < 5; i++) {\r\naty_ICS2595_put1bit(locationAddr & 1, par);\r\nlocationAddr >>= 1;\r\n}\r\nfor (i = 0; i < 8 + 1 + 2 + 2; i++) {\r\naty_ICS2595_put1bit(program_bits & 1, par);\r\nprogram_bits >>= 1;\r\n}\r\nmdelay(1);\r\n(void) aty_ld_8(DAC_REGS, par);\r\naty_st_8(CRTC_GEN_CNTL + 3, old_crtc_ext_disp, par);\r\naty_st_8(CLOCK_CNTL + par->clk_wr_offset,\r\nold_clock_cntl | CLOCK_STROBE, par);\r\nmdelay(50);\r\naty_st_8(CLOCK_CNTL + par->clk_wr_offset,\r\n((pll->ics2595.locationAddr & 0x0F) | CLOCK_STROBE), par);\r\nreturn;\r\n}\r\nstatic int aty_var_to_pll_1703(const struct fb_info *info, u32 vclk_per,\r\nu32 bpp, union aty_pll *pll)\r\n{\r\nu32 mhz100;\r\nu32 program_bits;\r\nu32 mach64MinFreq, mach64MaxFreq, mach64RefFreq;\r\nu32 temp, tempB;\r\nu16 remainder, preRemainder;\r\nshort divider = 0, tempA;\r\nmhz100 = 100000000 / vclk_per;\r\nmach64MinFreq = MIN_FREQ_2595;\r\nmach64MaxFreq = MAX_FREQ_2595;\r\nmach64RefFreq = REF_FREQ_2595;\r\nif (mhz100 == 0)\r\nprogram_bits = 0xE0;\r\nelse {\r\nif (mhz100 < mach64MinFreq)\r\nmhz100 = mach64MinFreq;\r\nif (mhz100 > mach64MaxFreq)\r\nmhz100 = mach64MaxFreq;\r\ndivider = 0;\r\nwhile (mhz100 < (mach64MinFreq << 3)) {\r\nmhz100 <<= 1;\r\ndivider += 0x20;\r\n}\r\ntemp = (unsigned int) (mhz100);\r\ntemp = (unsigned int) (temp * (MIN_N_1703 + 2));\r\ntemp -= (short) (mach64RefFreq << 1);\r\ntempA = MIN_N_1703;\r\npreRemainder = 0xffff;\r\ndo {\r\ntempB = temp;\r\nremainder = tempB % mach64RefFreq;\r\ntempB = tempB / mach64RefFreq;\r\nif ((tempB & 0xffff) <= 127\r\n&& (remainder <= preRemainder)) {\r\npreRemainder = remainder;\r\ndivider &= ~0x1f;\r\ndivider |= tempA;\r\ndivider =\r\n(divider & 0x00ff) +\r\n((tempB & 0xff) << 8);\r\n}\r\ntemp += mhz100;\r\ntempA++;\r\n} while (tempA <= (MIN_N_1703 << 1));\r\nprogram_bits = divider;\r\n}\r\npll->ics2595.program_bits = program_bits;\r\npll->ics2595.locationAddr = 0;\r\npll->ics2595.post_divider = divider;\r\npll->ics2595.period_in_ps = vclk_per;\r\nreturn 0;\r\n}\r\nstatic u32 aty_pll_1703_to_var(const struct fb_info *info,\r\nconst union aty_pll *pll)\r\n{\r\nreturn (pll->ics2595.period_in_ps);\r\n}\r\nstatic void aty_set_pll_1703(const struct fb_info *info,\r\nconst union aty_pll *pll)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nu32 program_bits;\r\nu32 locationAddr;\r\nchar old_crtc_ext_disp;\r\nold_crtc_ext_disp = aty_ld_8(CRTC_GEN_CNTL + 3, par);\r\naty_st_8(CRTC_GEN_CNTL + 3,\r\nold_crtc_ext_disp | (CRTC_EXT_DISP_EN >> 24), par);\r\nprogram_bits = pll->ics2595.program_bits;\r\nlocationAddr = pll->ics2595.locationAddr;\r\naty_dac_waste4(par);\r\n(void) aty_ld_8(DAC_REGS + 2, par);\r\naty_st_8(DAC_REGS + 2, (locationAddr << 1) + 0x20, par);\r\naty_st_8(DAC_REGS + 2, 0, par);\r\naty_st_8(DAC_REGS + 2, (program_bits & 0xFF00) >> 8, par);\r\naty_st_8(DAC_REGS + 2, (program_bits & 0xFF), par);\r\n(void) aty_ld_8(DAC_REGS, par);\r\naty_st_8(CRTC_GEN_CNTL + 3, old_crtc_ext_disp, par);\r\nreturn;\r\n}\r\nstatic int aty_var_to_pll_8398(const struct fb_info *info, u32 vclk_per,\r\nu32 bpp, union aty_pll *pll)\r\n{\r\nu32 tempA, tempB, fOut, longMHz100, diff, preDiff;\r\nu32 mhz100;\r\nu32 program_bits;\r\nu32 mach64MinFreq, mach64MaxFreq, mach64RefFreq;\r\nu16 m, n, k = 0, save_m, save_n, twoToKth;\r\nmhz100 = 100000000 / vclk_per;\r\nmach64MinFreq = MIN_FREQ_2595;\r\nmach64MaxFreq = MAX_FREQ_2595;\r\nmach64RefFreq = REF_FREQ_2595;\r\nsave_m = 0;\r\nsave_n = 0;\r\nif (mhz100 == 0)\r\nprogram_bits = 0xE0;\r\nelse {\r\nif (mhz100 < mach64MinFreq)\r\nmhz100 = mach64MinFreq;\r\nif (mhz100 > mach64MaxFreq)\r\nmhz100 = mach64MaxFreq;\r\nlongMHz100 = mhz100 * 256 / 100;\r\nwhile (mhz100 < (mach64MinFreq << 3)) {\r\nmhz100 <<= 1;\r\nk++;\r\n}\r\ntwoToKth = 1 << k;\r\ndiff = 0;\r\npreDiff = 0xFFFFFFFF;\r\nfor (m = MIN_M; m <= MAX_M; m++) {\r\nfor (n = MIN_N; n <= MAX_N; n++) {\r\ntempA = 938356;\r\ntempA *= (n + 8);\r\ntempB = twoToKth * 256;\r\ntempB *= (m + 2);\r\nfOut = tempA / tempB;\r\nif (longMHz100 > fOut)\r\ndiff = longMHz100 - fOut;\r\nelse\r\ndiff = fOut - longMHz100;\r\nif (diff < preDiff) {\r\nsave_m = m;\r\nsave_n = n;\r\npreDiff = diff;\r\n}\r\n}\r\n}\r\nprogram_bits = (k << 6) + (save_m) + (save_n << 8);\r\n}\r\npll->ics2595.program_bits = program_bits;\r\npll->ics2595.locationAddr = 0;\r\npll->ics2595.post_divider = 0;\r\npll->ics2595.period_in_ps = vclk_per;\r\nreturn 0;\r\n}\r\nstatic u32 aty_pll_8398_to_var(const struct fb_info *info,\r\nconst union aty_pll *pll)\r\n{\r\nreturn (pll->ics2595.period_in_ps);\r\n}\r\nstatic void aty_set_pll_8398(const struct fb_info *info,\r\nconst union aty_pll *pll)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nu32 program_bits;\r\nu32 locationAddr;\r\nchar old_crtc_ext_disp;\r\nchar tmp;\r\nold_crtc_ext_disp = aty_ld_8(CRTC_GEN_CNTL + 3, par);\r\naty_st_8(CRTC_GEN_CNTL + 3,\r\nold_crtc_ext_disp | (CRTC_EXT_DISP_EN >> 24), par);\r\nprogram_bits = pll->ics2595.program_bits;\r\nlocationAddr = pll->ics2595.locationAddr;\r\ntmp = aty_ld_8(DAC_CNTL, par);\r\naty_st_8(DAC_CNTL, tmp | DAC_EXT_SEL_RS2 | DAC_EXT_SEL_RS3, par);\r\naty_st_8(DAC_REGS, locationAddr, par);\r\naty_st_8(DAC_REGS + 1, (program_bits & 0xff00) >> 8, par);\r\naty_st_8(DAC_REGS + 1, (program_bits & 0xff), par);\r\ntmp = aty_ld_8(DAC_CNTL, par);\r\naty_st_8(DAC_CNTL, (tmp & ~DAC_EXT_SEL_RS2) | DAC_EXT_SEL_RS3,\r\npar);\r\n(void) aty_ld_8(DAC_REGS, par);\r\naty_st_8(CRTC_GEN_CNTL + 3, old_crtc_ext_disp, par);\r\nreturn;\r\n}\r\nstatic int aty_var_to_pll_408(const struct fb_info *info, u32 vclk_per,\r\nu32 bpp, union aty_pll *pll)\r\n{\r\nu32 mhz100;\r\nu32 program_bits;\r\nu32 mach64MinFreq, mach64MaxFreq, mach64RefFreq;\r\nu32 temp, tempB;\r\nu16 remainder, preRemainder;\r\nshort divider = 0, tempA;\r\nmhz100 = 100000000 / vclk_per;\r\nmach64MinFreq = MIN_FREQ_2595;\r\nmach64MaxFreq = MAX_FREQ_2595;\r\nmach64RefFreq = REF_FREQ_2595;\r\nif (mhz100 == 0)\r\nprogram_bits = 0xFF;\r\nelse {\r\nif (mhz100 < mach64MinFreq)\r\nmhz100 = mach64MinFreq;\r\nif (mhz100 > mach64MaxFreq)\r\nmhz100 = mach64MaxFreq;\r\nwhile (mhz100 < (mach64MinFreq << 3)) {\r\nmhz100 <<= 1;\r\ndivider += 0x40;\r\n}\r\ntemp = (unsigned int) mhz100;\r\ntemp = (unsigned int) (temp * (MIN_N_408 + 2));\r\ntemp -= ((short) (mach64RefFreq << 1));\r\ntempA = MIN_N_408;\r\npreRemainder = 0xFFFF;\r\ndo {\r\ntempB = temp;\r\nremainder = tempB % mach64RefFreq;\r\ntempB = tempB / mach64RefFreq;\r\nif (((tempB & 0xFFFF) <= 255)\r\n&& (remainder <= preRemainder)) {\r\npreRemainder = remainder;\r\ndivider &= ~0x3f;\r\ndivider |= tempA;\r\ndivider =\r\n(divider & 0x00FF) +\r\n((tempB & 0xFF) << 8);\r\n}\r\ntemp += mhz100;\r\ntempA++;\r\n} while (tempA <= 32);\r\nprogram_bits = divider;\r\n}\r\npll->ics2595.program_bits = program_bits;\r\npll->ics2595.locationAddr = 0;\r\npll->ics2595.post_divider = divider;\r\npll->ics2595.period_in_ps = vclk_per;\r\nreturn 0;\r\n}\r\nstatic u32 aty_pll_408_to_var(const struct fb_info *info,\r\nconst union aty_pll *pll)\r\n{\r\nreturn (pll->ics2595.period_in_ps);\r\n}\r\nstatic void aty_set_pll_408(const struct fb_info *info,\r\nconst union aty_pll *pll)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\nu32 program_bits;\r\nu32 locationAddr;\r\nu8 tmpA, tmpB, tmpC;\r\nchar old_crtc_ext_disp;\r\nold_crtc_ext_disp = aty_ld_8(CRTC_GEN_CNTL + 3, par);\r\naty_st_8(CRTC_GEN_CNTL + 3,\r\nold_crtc_ext_disp | (CRTC_EXT_DISP_EN >> 24), par);\r\nprogram_bits = pll->ics2595.program_bits;\r\nlocationAddr = pll->ics2595.locationAddr;\r\naty_dac_waste4(par);\r\ntmpB = aty_ld_8(DAC_REGS + 2, par) | 1;\r\naty_dac_waste4(par);\r\naty_st_8(DAC_REGS + 2, tmpB, par);\r\ntmpA = tmpB;\r\ntmpC = tmpA;\r\ntmpA |= 8;\r\ntmpB = 1;\r\naty_st_8(DAC_REGS, tmpB, par);\r\naty_st_8(DAC_REGS + 2, tmpA, par);\r\nudelay(400);\r\nlocationAddr = (locationAddr << 2) + 0x40;\r\ntmpB = locationAddr;\r\ntmpA = program_bits >> 8;\r\naty_st_8(DAC_REGS, tmpB, par);\r\naty_st_8(DAC_REGS + 2, tmpA, par);\r\ntmpB = locationAddr + 1;\r\ntmpA = (u8) program_bits;\r\naty_st_8(DAC_REGS, tmpB, par);\r\naty_st_8(DAC_REGS + 2, tmpA, par);\r\ntmpB = locationAddr + 2;\r\ntmpA = 0x77;\r\naty_st_8(DAC_REGS, tmpB, par);\r\naty_st_8(DAC_REGS + 2, tmpA, par);\r\nudelay(400);\r\ntmpA = tmpC & (~(1 | 8));\r\ntmpB = 1;\r\naty_st_8(DAC_REGS, tmpB, par);\r\naty_st_8(DAC_REGS + 2, tmpA, par);\r\n(void) aty_ld_8(DAC_REGS, par);\r\naty_st_8(CRTC_GEN_CNTL + 3, old_crtc_ext_disp, par);\r\nreturn;\r\n}\r\nstatic int aty_set_dac_unsupported(const struct fb_info *info,\r\nconst union aty_pll *pll, u32 bpp,\r\nu32 accel)\r\n{\r\nstruct atyfb_par *par = (struct atyfb_par *) info->par;\r\naty_st_le32(BUS_CNTL, 0x890e20f1, par);\r\naty_st_le32(DAC_CNTL, 0x47052100, par);\r\naty_st_le32(BUS_CNTL, 0x590e10ff, par);\r\naty_st_le32(DAC_CNTL, 0x47012100, par);\r\nreturn 0;\r\n}\r\nstatic int dummy(void)\r\n{\r\nreturn 0;\r\n}
