static int adp5588_gpio_read(struct i2c_client *client, u8 reg)\r\n{\r\nint ret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret < 0)\r\ndev_err(&client->dev, "Read Error\n");\r\nreturn ret;\r\n}\r\nstatic int adp5588_gpio_write(struct i2c_client *client, u8 reg, u8 val)\r\n{\r\nint ret = i2c_smbus_write_byte_data(client, reg, val);\r\nif (ret < 0)\r\ndev_err(&client->dev, "Write Error\n");\r\nreturn ret;\r\n}\r\nstatic int adp5588_gpio_get_value(struct gpio_chip *chip, unsigned off)\r\n{\r\nstruct adp5588_gpio *dev =\r\ncontainer_of(chip, struct adp5588_gpio, gpio_chip);\r\nreturn !!(adp5588_gpio_read(dev->client,\r\nGPIO_DAT_STAT1 + ADP5588_BANK(off)) & ADP5588_BIT(off));\r\n}\r\nstatic void adp5588_gpio_set_value(struct gpio_chip *chip,\r\nunsigned off, int val)\r\n{\r\nunsigned bank, bit;\r\nstruct adp5588_gpio *dev =\r\ncontainer_of(chip, struct adp5588_gpio, gpio_chip);\r\nbank = ADP5588_BANK(off);\r\nbit = ADP5588_BIT(off);\r\nmutex_lock(&dev->lock);\r\nif (val)\r\ndev->dat_out[bank] |= bit;\r\nelse\r\ndev->dat_out[bank] &= ~bit;\r\nadp5588_gpio_write(dev->client, GPIO_DAT_OUT1 + bank,\r\ndev->dat_out[bank]);\r\nmutex_unlock(&dev->lock);\r\n}\r\nstatic int adp5588_gpio_direction_input(struct gpio_chip *chip, unsigned off)\r\n{\r\nint ret;\r\nunsigned bank;\r\nstruct adp5588_gpio *dev =\r\ncontainer_of(chip, struct adp5588_gpio, gpio_chip);\r\nbank = ADP5588_BANK(off);\r\nmutex_lock(&dev->lock);\r\ndev->dir[bank] &= ~ADP5588_BIT(off);\r\nret = adp5588_gpio_write(dev->client, GPIO_DIR1 + bank, dev->dir[bank]);\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic int adp5588_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned off, int val)\r\n{\r\nint ret;\r\nunsigned bank, bit;\r\nstruct adp5588_gpio *dev =\r\ncontainer_of(chip, struct adp5588_gpio, gpio_chip);\r\nbank = ADP5588_BANK(off);\r\nbit = ADP5588_BIT(off);\r\nmutex_lock(&dev->lock);\r\ndev->dir[bank] |= bit;\r\nif (val)\r\ndev->dat_out[bank] |= bit;\r\nelse\r\ndev->dat_out[bank] &= ~bit;\r\nret = adp5588_gpio_write(dev->client, GPIO_DAT_OUT1 + bank,\r\ndev->dat_out[bank]);\r\nret |= adp5588_gpio_write(dev->client, GPIO_DIR1 + bank,\r\ndev->dir[bank]);\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic int adp5588_gpio_to_irq(struct gpio_chip *chip, unsigned off)\r\n{\r\nstruct adp5588_gpio *dev =\r\ncontainer_of(chip, struct adp5588_gpio, gpio_chip);\r\nreturn dev->irq_base + off;\r\n}\r\nstatic void adp5588_irq_bus_lock(struct irq_data *d)\r\n{\r\nstruct adp5588_gpio *dev = irq_data_get_irq_chip_data(d);\r\nmutex_lock(&dev->irq_lock);\r\n}\r\nstatic void adp5588_irq_bus_sync_unlock(struct irq_data *d)\r\n{\r\nstruct adp5588_gpio *dev = irq_data_get_irq_chip_data(d);\r\nint i;\r\nfor (i = 0; i <= ADP5588_BANK(ADP5588_MAXGPIO); i++)\r\nif (dev->int_en[i] ^ dev->irq_mask[i]) {\r\ndev->int_en[i] = dev->irq_mask[i];\r\nadp5588_gpio_write(dev->client, GPIO_INT_EN1 + i,\r\ndev->int_en[i]);\r\n}\r\nmutex_unlock(&dev->irq_lock);\r\n}\r\nstatic void adp5588_irq_mask(struct irq_data *d)\r\n{\r\nstruct adp5588_gpio *dev = irq_data_get_irq_chip_data(d);\r\nunsigned gpio = d->irq - dev->irq_base;\r\ndev->irq_mask[ADP5588_BANK(gpio)] &= ~ADP5588_BIT(gpio);\r\n}\r\nstatic void adp5588_irq_unmask(struct irq_data *d)\r\n{\r\nstruct adp5588_gpio *dev = irq_data_get_irq_chip_data(d);\r\nunsigned gpio = d->irq - dev->irq_base;\r\ndev->irq_mask[ADP5588_BANK(gpio)] |= ADP5588_BIT(gpio);\r\n}\r\nstatic int adp5588_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct adp5588_gpio *dev = irq_data_get_irq_chip_data(d);\r\nuint16_t gpio = d->irq - dev->irq_base;\r\nunsigned bank, bit;\r\nif ((type & IRQ_TYPE_EDGE_BOTH)) {\r\ndev_err(&dev->client->dev, "irq %d: unsupported type %d\n",\r\nd->irq, type);\r\nreturn -EINVAL;\r\n}\r\nbank = ADP5588_BANK(gpio);\r\nbit = ADP5588_BIT(gpio);\r\nif (type & IRQ_TYPE_LEVEL_HIGH)\r\ndev->int_lvl[bank] |= bit;\r\nelse if (type & IRQ_TYPE_LEVEL_LOW)\r\ndev->int_lvl[bank] &= ~bit;\r\nelse\r\nreturn -EINVAL;\r\nadp5588_gpio_direction_input(&dev->gpio_chip, gpio);\r\nadp5588_gpio_write(dev->client, GPIO_INT_LVL1 + bank,\r\ndev->int_lvl[bank]);\r\nreturn 0;\r\n}\r\nstatic int adp5588_gpio_read_intstat(struct i2c_client *client, u8 *buf)\r\n{\r\nint ret = i2c_smbus_read_i2c_block_data(client, GPIO_INT_STAT1, 3, buf);\r\nif (ret < 0)\r\ndev_err(&client->dev, "Read INT_STAT Error\n");\r\nreturn ret;\r\n}\r\nstatic irqreturn_t adp5588_irq_handler(int irq, void *devid)\r\n{\r\nstruct adp5588_gpio *dev = devid;\r\nunsigned status, bank, bit, pending;\r\nint ret;\r\nstatus = adp5588_gpio_read(dev->client, INT_STAT);\r\nif (status & ADP5588_GPI_INT) {\r\nret = adp5588_gpio_read_intstat(dev->client, dev->irq_stat);\r\nif (ret < 0)\r\nmemset(dev->irq_stat, 0, ARRAY_SIZE(dev->irq_stat));\r\nfor (bank = 0, bit = 0; bank <= ADP5588_BANK(ADP5588_MAXGPIO);\r\nbank++, bit = 0) {\r\npending = dev->irq_stat[bank] & dev->irq_mask[bank];\r\nwhile (pending) {\r\nif (pending & (1 << bit)) {\r\nhandle_nested_irq(dev->irq_base +\r\n(bank << 3) + bit);\r\npending &= ~(1 << bit);\r\n}\r\nbit++;\r\n}\r\n}\r\n}\r\nadp5588_gpio_write(dev->client, INT_STAT, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int adp5588_irq_setup(struct adp5588_gpio *dev)\r\n{\r\nstruct i2c_client *client = dev->client;\r\nstruct adp5588_gpio_platform_data *pdata =\r\ndev_get_platdata(&client->dev);\r\nunsigned gpio;\r\nint ret;\r\nadp5588_gpio_write(client, CFG, ADP5588_AUTO_INC);\r\nadp5588_gpio_write(client, INT_STAT, -1);\r\nadp5588_gpio_read_intstat(client, dev->irq_stat);\r\ndev->irq_base = pdata->irq_base;\r\nmutex_init(&dev->irq_lock);\r\nfor (gpio = 0; gpio < dev->gpio_chip.ngpio; gpio++) {\r\nint irq = gpio + dev->irq_base;\r\nirq_set_chip_data(irq, dev);\r\nirq_set_chip_and_handler(irq, &adp5588_irq_chip,\r\nhandle_level_irq);\r\nirq_set_nested_thread(irq, 1);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(irq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(irq);\r\n#endif\r\n}\r\nret = request_threaded_irq(client->irq,\r\nNULL,\r\nadp5588_irq_handler,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\ndev_name(&client->dev), dev);\r\nif (ret) {\r\ndev_err(&client->dev, "failed to request irq %d\n",\r\nclient->irq);\r\ngoto out;\r\n}\r\ndev->gpio_chip.to_irq = adp5588_gpio_to_irq;\r\nadp5588_gpio_write(client, CFG,\r\nADP5588_AUTO_INC | ADP5588_INT_CFG | ADP5588_GPI_INT);\r\nreturn 0;\r\nout:\r\ndev->irq_base = 0;\r\nreturn ret;\r\n}\r\nstatic void adp5588_irq_teardown(struct adp5588_gpio *dev)\r\n{\r\nif (dev->irq_base)\r\nfree_irq(dev->client->irq, dev);\r\n}\r\nstatic int adp5588_irq_setup(struct adp5588_gpio *dev)\r\n{\r\nstruct i2c_client *client = dev->client;\r\ndev_warn(&client->dev, "interrupt support not compiled in\n");\r\nreturn 0;\r\n}\r\nstatic void adp5588_irq_teardown(struct adp5588_gpio *dev)\r\n{\r\n}\r\nstatic int adp5588_gpio_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct adp5588_gpio_platform_data *pdata =\r\ndev_get_platdata(&client->dev);\r\nstruct adp5588_gpio *dev;\r\nstruct gpio_chip *gc;\r\nint ret, i, revid;\r\nif (pdata == NULL) {\r\ndev_err(&client->dev, "missing platform data\n");\r\nreturn -ENODEV;\r\n}\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(&client->dev, "SMBUS Byte Data not Supported\n");\r\nreturn -EIO;\r\n}\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\ndev_err(&client->dev, "failed to alloc memory\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->client = client;\r\ngc = &dev->gpio_chip;\r\ngc->direction_input = adp5588_gpio_direction_input;\r\ngc->direction_output = adp5588_gpio_direction_output;\r\ngc->get = adp5588_gpio_get_value;\r\ngc->set = adp5588_gpio_set_value;\r\ngc->can_sleep = 1;\r\ngc->base = pdata->gpio_start;\r\ngc->ngpio = ADP5588_MAXGPIO;\r\ngc->label = client->name;\r\ngc->owner = THIS_MODULE;\r\nmutex_init(&dev->lock);\r\nret = adp5588_gpio_read(dev->client, DEV_ID);\r\nif (ret < 0)\r\ngoto err;\r\nrevid = ret & ADP5588_DEVICE_ID_MASK;\r\nfor (i = 0, ret = 0; i <= ADP5588_BANK(ADP5588_MAXGPIO); i++) {\r\ndev->dat_out[i] = adp5588_gpio_read(client, GPIO_DAT_OUT1 + i);\r\ndev->dir[i] = adp5588_gpio_read(client, GPIO_DIR1 + i);\r\nret |= adp5588_gpio_write(client, KP_GPIO1 + i, 0);\r\nret |= adp5588_gpio_write(client, GPIO_PULL1 + i,\r\n(pdata->pullup_dis_mask >> (8 * i)) & 0xFF);\r\nret |= adp5588_gpio_write(client, GPIO_INT_EN1 + i, 0);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (pdata->irq_base) {\r\nif (WA_DELAYED_READOUT_REVID(revid)) {\r\ndev_warn(&client->dev, "GPIO int not supported\n");\r\n} else {\r\nret = adp5588_irq_setup(dev);\r\nif (ret)\r\ngoto err;\r\n}\r\n}\r\nret = gpiochip_add(&dev->gpio_chip);\r\nif (ret)\r\ngoto err_irq;\r\ndev_info(&client->dev, "IRQ Base: %d Rev.: %d\n",\r\npdata->irq_base, revid);\r\nif (pdata->setup) {\r\nret = pdata->setup(client, gc->base, gc->ngpio, pdata->context);\r\nif (ret < 0)\r\ndev_warn(&client->dev, "setup failed, %d\n", ret);\r\n}\r\ni2c_set_clientdata(client, dev);\r\nreturn 0;\r\nerr_irq:\r\nadp5588_irq_teardown(dev);\r\nerr:\r\nkfree(dev);\r\nreturn ret;\r\n}\r\nstatic int adp5588_gpio_remove(struct i2c_client *client)\r\n{\r\nstruct adp5588_gpio_platform_data *pdata =\r\ndev_get_platdata(&client->dev);\r\nstruct adp5588_gpio *dev = i2c_get_clientdata(client);\r\nint ret;\r\nif (pdata->teardown) {\r\nret = pdata->teardown(client,\r\ndev->gpio_chip.base, dev->gpio_chip.ngpio,\r\npdata->context);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "teardown failed %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nif (dev->irq_base)\r\nfree_irq(dev->client->irq, dev);\r\nret = gpiochip_remove(&dev->gpio_chip);\r\nif (ret) {\r\ndev_err(&client->dev, "gpiochip_remove failed %d\n", ret);\r\nreturn ret;\r\n}\r\nkfree(dev);\r\nreturn 0;\r\n}
