static inline void stu300_wr8(u32 value, void __iomem *address)\r\n{\r\nwritel((value << 16) | value, address);\r\n}\r\nstatic inline u32 stu300_r8(void __iomem *address)\r\n{\r\nreturn readl(address) & 0x000000FFU;\r\n}\r\nstatic void stu300_irq_enable(struct stu300_dev *dev)\r\n{\r\nu32 val;\r\nval = stu300_r8(dev->virtbase + I2C_CR);\r\nval |= I2C_CR_INTERRUPT_ENABLE;\r\nstu300_wr8(val, dev->virtbase + I2C_CR);\r\nstu300_wr8(val, dev->virtbase + I2C_CR);\r\n}\r\nstatic void stu300_irq_disable(struct stu300_dev *dev)\r\n{\r\nu32 val;\r\nval = stu300_r8(dev->virtbase + I2C_CR);\r\nval &= ~I2C_CR_INTERRUPT_ENABLE;\r\nstu300_wr8(val, dev->virtbase + I2C_CR);\r\nstu300_wr8(val, dev->virtbase + I2C_CR);\r\n}\r\nstatic int stu300_event_occurred(struct stu300_dev *dev,\r\nenum stu300_event mr_event) {\r\nu32 status1;\r\nu32 status2;\r\nstatus1 = stu300_r8(dev->virtbase + I2C_SR1);\r\nif (!(status1 & I2C_SR1_EVF_IND))\r\nreturn 0;\r\nstatus2 = stu300_r8(dev->virtbase + I2C_SR2);\r\nstu300_irq_disable(dev);\r\nif (status2 & I2C_SR2_AF_IND) {\r\ndev->cmd_err = STU300_ERROR_ACKNOWLEDGE_FAILURE;\r\nreturn 1;\r\n} else if (status2 & I2C_SR2_BERR_IND) {\r\ndev->cmd_err = STU300_ERROR_BUS_ERROR;\r\nreturn 1;\r\n} else if (status2 & I2C_SR2_ARLO_IND) {\r\ndev->cmd_err = STU300_ERROR_ARBITRATION_LOST;\r\nreturn 1;\r\n}\r\nswitch (mr_event) {\r\ncase STU300_EVENT_1:\r\nif (status1 & I2C_SR1_ADSL_IND)\r\nreturn 1;\r\nbreak;\r\ncase STU300_EVENT_2:\r\ncase STU300_EVENT_3:\r\ncase STU300_EVENT_7:\r\ncase STU300_EVENT_8:\r\nif (status1 & I2C_SR1_BTF_IND) {\r\nreturn 1;\r\n}\r\nbreak;\r\ncase STU300_EVENT_4:\r\nif (status2 & I2C_SR2_STOPF_IND)\r\nreturn 1;\r\nbreak;\r\ncase STU300_EVENT_5:\r\nif (status1 & I2C_SR1_SB_IND)\r\nreturn 1;\r\nbreak;\r\ncase STU300_EVENT_6:\r\nif (status2 & I2C_SR2_ENDAD_IND) {\r\nreturn 1;\r\n}\r\nbreak;\r\ncase STU300_EVENT_9:\r\nif (status1 & I2C_SR1_ADD10_IND)\r\nreturn 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndev->cmd_err = STU300_ERROR_UNKNOWN;\r\ndev_err(&dev->pdev->dev,\r\n"Unhandled interrupt! %d sr1: 0x%x sr2: 0x%x\n",\r\nmr_event, status1, status2);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t stu300_irh(int irq, void *data)\r\n{\r\nstruct stu300_dev *dev = data;\r\nint res;\r\nclk_enable(dev->clk);\r\nspin_lock(&dev->cmd_issue_lock);\r\nres = stu300_event_occurred(dev, dev->cmd_event);\r\nif (res || dev->cmd_err != STU300_ERROR_NONE)\r\ncomplete(&dev->cmd_complete);\r\nspin_unlock(&dev->cmd_issue_lock);\r\nclk_disable(dev->clk);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int stu300_start_and_await_event(struct stu300_dev *dev,\r\nu8 cr_value,\r\nenum stu300_event mr_event)\r\n{\r\nint ret;\r\nif (unlikely(irqs_disabled())) {\r\nWARN(1, "irqs are disabled, cannot poll for event\n");\r\nreturn -EIO;\r\n}\r\nspin_lock_irq(&dev->cmd_issue_lock);\r\ninit_completion(&dev->cmd_complete);\r\ndev->cmd_err = STU300_ERROR_NONE;\r\ndev->cmd_event = mr_event;\r\nspin_unlock_irq(&dev->cmd_issue_lock);\r\ncr_value |= I2C_CR_INTERRUPT_ENABLE;\r\nstu300_wr8(cr_value, dev->virtbase + I2C_CR);\r\nret = wait_for_completion_interruptible_timeout(&dev->cmd_complete,\r\nSTU300_TIMEOUT);\r\nif (ret < 0) {\r\ndev_err(&dev->pdev->dev,\r\n"wait_for_completion_interruptible_timeout() "\r\n"returned %d waiting for event %04x\n", ret, mr_event);\r\nreturn ret;\r\n}\r\nif (ret == 0) {\r\ndev_err(&dev->pdev->dev, "controller timed out "\r\n"waiting for event %d, reinit hardware\n", mr_event);\r\n(void) stu300_init_hw(dev);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (dev->cmd_err != STU300_ERROR_NONE) {\r\ndev_err(&dev->pdev->dev, "controller (start) "\r\n"error %d waiting for event %d, reinit hardware\n",\r\ndev->cmd_err, mr_event);\r\n(void) stu300_init_hw(dev);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stu300_await_event(struct stu300_dev *dev,\r\nenum stu300_event mr_event)\r\n{\r\nint ret;\r\nif (unlikely(irqs_disabled())) {\r\ndev_err(&dev->pdev->dev, "irqs are disabled on this "\r\n"system!\n");\r\nreturn -EIO;\r\n}\r\nspin_lock_irq(&dev->cmd_issue_lock);\r\ndev->cmd_err = STU300_ERROR_NONE;\r\ndev->cmd_event = mr_event;\r\ninit_completion(&dev->cmd_complete);\r\nstu300_irq_enable(dev);\r\nspin_unlock_irq(&dev->cmd_issue_lock);\r\nret = wait_for_completion_interruptible_timeout(&dev->cmd_complete,\r\nSTU300_TIMEOUT);\r\nif (ret < 0) {\r\ndev_err(&dev->pdev->dev,\r\n"wait_for_completion_interruptible_timeout()"\r\n"returned %d waiting for event %04x\n", ret, mr_event);\r\nreturn ret;\r\n}\r\nif (ret == 0) {\r\nif (mr_event != STU300_EVENT_6) {\r\ndev_err(&dev->pdev->dev, "controller "\r\n"timed out waiting for event %d, reinit "\r\n"hardware\n", mr_event);\r\n(void) stu300_init_hw(dev);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nif (dev->cmd_err != STU300_ERROR_NONE) {\r\nif (mr_event != STU300_EVENT_6) {\r\ndev_err(&dev->pdev->dev, "controller "\r\n"error (await_event) %d waiting for event %d, "\r\n"reinit hardware\n", dev->cmd_err, mr_event);\r\n(void) stu300_init_hw(dev);\r\n}\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stu300_wait_while_busy(struct stu300_dev *dev)\r\n{\r\nunsigned long timeout;\r\nint i;\r\nfor (i = 0; i < BUSY_RELEASE_ATTEMPTS; i++) {\r\ntimeout = jiffies + STU300_TIMEOUT;\r\nwhile (!time_after(jiffies, timeout)) {\r\nif ((stu300_r8(dev->virtbase + I2C_SR1) &\r\nI2C_SR1_BUSY_IND) == 0)\r\nreturn 0;\r\nmsleep(1);\r\n}\r\ndev_err(&dev->pdev->dev, "transaction timed out "\r\n"waiting for device to be free (not busy). "\r\n"Attempt: %d\n", i+1);\r\ndev_err(&dev->pdev->dev, "base address = "\r\n"0x%08x, reinit hardware\n", (u32) dev->virtbase);\r\n(void) stu300_init_hw(dev);\r\n}\r\ndev_err(&dev->pdev->dev, "giving up after %d attempts "\r\n"to reset the bus.\n", BUSY_RELEASE_ATTEMPTS);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int stu300_set_clk(struct stu300_dev *dev, unsigned long clkrate)\r\n{\r\nu32 val;\r\nint i = 0;\r\nwhile (i < ARRAY_SIZE(stu300_clktable) - 1 &&\r\nstu300_clktable[i].rate < clkrate)\r\ni++;\r\nif (stu300_clktable[i].setting == 0xFFU) {\r\ndev_err(&dev->pdev->dev, "too %s clock rate requested "\r\n"(%lu Hz).\n", i ? "high" : "low", clkrate);\r\nreturn -EINVAL;\r\n}\r\nstu300_wr8(stu300_clktable[i].setting,\r\ndev->virtbase + I2C_OAR2);\r\ndev_dbg(&dev->pdev->dev, "Clock rate %lu Hz, I2C bus speed %d Hz "\r\n"virtbase %p\n", clkrate, dev->speed, dev->virtbase);\r\nif (dev->speed > 100000)\r\nval = ((clkrate/dev->speed) - 9)/3 + 1;\r\nelse\r\nval = ((clkrate/dev->speed) - 7)/2 + 1;\r\nif (val < 0x002) {\r\ndev_err(&dev->pdev->dev, "too low clock rate (%lu Hz).\n",\r\nclkrate);\r\nreturn -EINVAL;\r\n}\r\nif (val & 0xFFFFF000U) {\r\ndev_err(&dev->pdev->dev, "too high clock rate (%lu Hz).\n",\r\nclkrate);\r\nreturn -EINVAL;\r\n}\r\nif (dev->speed > 100000) {\r\nstu300_wr8((val & I2C_CCR_CC_MASK) | I2C_CCR_FMSM,\r\ndev->virtbase + I2C_CCR);\r\ndev_dbg(&dev->pdev->dev, "set clock divider to 0x%08x, "\r\n"Fast Mode I2C\n", val);\r\n} else {\r\nstu300_wr8((val & I2C_CCR_CC_MASK),\r\ndev->virtbase + I2C_CCR);\r\ndev_dbg(&dev->pdev->dev, "set clock divider to "\r\n"0x%08x, Standard Mode I2C\n", val);\r\n}\r\nstu300_wr8(((val >> 7) & 0x1F),\r\ndev->virtbase + I2C_ECCR);\r\nreturn 0;\r\n}\r\nstatic int stu300_init_hw(struct stu300_dev *dev)\r\n{\r\nu32 dummy;\r\nunsigned long clkrate;\r\nint ret;\r\nstu300_wr8(0x00, dev->virtbase + I2C_CR);\r\nstu300_wr8(0x00, dev->virtbase + I2C_OAR1);\r\nclkrate = clk_get_rate(dev->clk);\r\nret = stu300_set_clk(dev, clkrate);\r\nif (ret)\r\nreturn ret;\r\nstu300_wr8(I2C_CR_PERIPHERAL_ENABLE,\r\ndev->virtbase + I2C_CR);\r\nstu300_wr8(I2C_CR_PERIPHERAL_ENABLE,\r\ndev->virtbase + I2C_CR);\r\ndummy = stu300_r8(dev->virtbase + I2C_SR2);\r\ndummy = stu300_r8(dev->virtbase + I2C_SR1);\r\nreturn 0;\r\n}\r\nstatic int stu300_send_address(struct stu300_dev *dev,\r\nstruct i2c_msg *msg, int resend)\r\n{\r\nu32 val;\r\nint ret;\r\nif (msg->flags & I2C_M_TEN)\r\nval = (0xf0 | (((u32) msg->addr & 0x300) >> 7)) &\r\nI2C_DR_D_MASK;\r\nelse\r\nval = ((msg->addr << 1) & I2C_DR_D_MASK);\r\nif (msg->flags & I2C_M_RD) {\r\nval |= 0x01;\r\nif (resend)\r\ndev_dbg(&dev->pdev->dev, "read resend\n");\r\n} else if (resend)\r\ndev_dbg(&dev->pdev->dev, "write resend\n");\r\nstu300_wr8(val, dev->virtbase + I2C_DR);\r\nif (msg->flags & I2C_M_TEN) {\r\nret = stu300_await_event(dev, STU300_EVENT_9);\r\nval = msg->addr & I2C_DR_D_MASK;\r\nstu300_wr8(val, dev->virtbase + I2C_DR);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nif (resend)\r\ndev_dbg(&dev->pdev->dev, "await event 6\n");\r\nret = stu300_await_event(dev, STU300_EVENT_6);\r\nval = stu300_r8(dev->virtbase + I2C_CR);\r\nval |= I2C_CR_PERIPHERAL_ENABLE;\r\nstu300_wr8(val, dev->virtbase + I2C_CR);\r\nreturn ret;\r\n}\r\nstatic int stu300_xfer_msg(struct i2c_adapter *adap,\r\nstruct i2c_msg *msg, int stop)\r\n{\r\nu32 cr;\r\nu32 val;\r\nu32 i;\r\nint ret;\r\nint attempts = 0;\r\nstruct stu300_dev *dev = i2c_get_adapdata(adap);\r\nclk_enable(dev->clk);\r\nif (0) {\r\ndev_dbg(&dev->pdev->dev, "I2C message to: 0x%04x, len: %d, "\r\n"flags: 0x%04x, stop: %d\n",\r\nmsg->addr, msg->len, msg->flags, stop);\r\n}\r\nif (msg->len == 0) {\r\nret = -EINVAL;\r\ngoto exit_disable;\r\n}\r\ndo {\r\nif (attempts)\r\ndev_dbg(&dev->pdev->dev, "wait while busy\n");\r\nret = stu300_wait_while_busy(dev);\r\nif (ret != 0)\r\ngoto exit_disable;\r\nif (attempts)\r\ndev_dbg(&dev->pdev->dev, "re-int hw\n");\r\nret = stu300_init_hw(dev);\r\nif (ret)\r\ngoto exit_disable;\r\ncr = I2C_CR_PERIPHERAL_ENABLE;\r\nif (!(msg->flags & I2C_M_NOSTART))\r\ncr |= I2C_CR_START_ENABLE;\r\nif ((msg->flags & I2C_M_RD) && (msg->len > 1))\r\ncr |= I2C_CR_ACK_ENABLE;\r\nif (!(msg->flags & I2C_M_NOSTART)) {\r\nif (attempts)\r\ndev_dbg(&dev->pdev->dev, "send start event\n");\r\nret = stu300_start_and_await_event(dev, cr,\r\nSTU300_EVENT_5);\r\n}\r\nif (attempts)\r\ndev_dbg(&dev->pdev->dev, "send address\n");\r\nif (ret == 0)\r\nret = stu300_send_address(dev, msg, attempts != 0);\r\nif (ret != 0) {\r\nattempts++;\r\ndev_dbg(&dev->pdev->dev, "failed sending address, "\r\n"retrying. Attempt: %d msg_index: %d/%d\n",\r\nattempts, dev->msg_index, dev->msg_len);\r\n}\r\n} while (ret != 0 && attempts < NUM_ADDR_RESEND_ATTEMPTS);\r\nif (attempts < NUM_ADDR_RESEND_ATTEMPTS && attempts > 0) {\r\ndev_dbg(&dev->pdev->dev, "managed to get address "\r\n"through after %d attempts\n", attempts);\r\n} else if (attempts == NUM_ADDR_RESEND_ATTEMPTS) {\r\ndev_dbg(&dev->pdev->dev, "I give up, tried %d times "\r\n"to resend address.\n",\r\nNUM_ADDR_RESEND_ATTEMPTS);\r\ngoto exit_disable;\r\n}\r\nif (msg->flags & I2C_M_RD) {\r\nfor (i = 0; i < msg->len; i++) {\r\nif (i == msg->len-1) {\r\nval = I2C_CR_PERIPHERAL_ENABLE;\r\nif (stop)\r\nval |= I2C_CR_STOP_ENABLE;\r\nstu300_wr8(val,\r\ndev->virtbase + I2C_CR);\r\n}\r\nret = stu300_await_event(dev, STU300_EVENT_7);\r\nif (ret != 0)\r\ngoto exit_disable;\r\nmsg->buf[i] = (u8) stu300_r8(dev->virtbase + I2C_DR);\r\n}\r\n} else {\r\nfor (i = 0; i < msg->len; i++) {\r\nstu300_wr8(msg->buf[i],\r\ndev->virtbase + I2C_DR);\r\nret = stu300_await_event(dev, STU300_EVENT_8);\r\nif (ret != 0) {\r\ndev_err(&dev->pdev->dev, "error awaiting "\r\n"event 8 (%d)\n", ret);\r\ngoto exit_disable;\r\n}\r\n}\r\nif (!(msg->flags & I2C_M_IGNORE_NAK)) {\r\nif (stu300_r8(dev->virtbase + I2C_SR2) &\r\nI2C_SR2_AF_IND) {\r\ndev_err(&dev->pdev->dev, "I2C payload "\r\n"send returned NAK!\n");\r\nret = -EIO;\r\ngoto exit_disable;\r\n}\r\n}\r\nif (stop) {\r\nval = I2C_CR_PERIPHERAL_ENABLE;\r\nval |= I2C_CR_STOP_ENABLE;\r\nstu300_wr8(val, dev->virtbase + I2C_CR);\r\n}\r\n}\r\nret = stu300_wait_while_busy(dev);\r\nif (ret != 0) {\r\ndev_err(&dev->pdev->dev, "timout waiting for transfer "\r\n"to commence.\n");\r\ngoto exit_disable;\r\n}\r\nval = stu300_r8(dev->virtbase + I2C_SR2);\r\nval = stu300_r8(dev->virtbase + I2C_SR1);\r\nret = 0;\r\nexit_disable:\r\nstu300_wr8(0x00, dev->virtbase + I2C_CR);\r\nclk_disable(dev->clk);\r\nreturn ret;\r\n}\r\nstatic int stu300_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\r\nint num)\r\n{\r\nint ret = -1;\r\nint i;\r\nstruct stu300_dev *dev = i2c_get_adapdata(adap);\r\ndev->msg_len = num;\r\nfor (i = 0; i < num; i++) {\r\ndev->msg_index = i;\r\nret = stu300_xfer_msg(adap, &msgs[i], (i == (num - 1)));\r\nif (ret != 0) {\r\nnum = ret;\r\nbreak;\r\n}\r\n}\r\nreturn num;\r\n}\r\nstatic u32 stu300_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR;\r\n}\r\nstatic int stu300_probe(struct platform_device *pdev)\r\n{\r\nstruct stu300_dev *dev;\r\nstruct i2c_adapter *adap;\r\nstruct resource *res;\r\nint bus_nr;\r\nint ret = 0;\r\ndev = devm_kzalloc(&pdev->dev, sizeof(struct stu300_dev), GFP_KERNEL);\r\nif (!dev) {\r\ndev_err(&pdev->dev, "could not allocate device struct\n");\r\nreturn -ENOMEM;\r\n}\r\nbus_nr = pdev->id;\r\ndev->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(dev->clk)) {\r\ndev_err(&pdev->dev, "could not retrieve i2c bus clock\n");\r\nreturn PTR_ERR(dev->clk);\r\n}\r\ndev->pdev = pdev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndev->virtbase = devm_ioremap_resource(&pdev->dev, res);\r\ndev_dbg(&pdev->dev, "initialize bus device I2C%d on virtual "\r\n"base %p\n", bus_nr, dev->virtbase);\r\nif (IS_ERR(dev->virtbase))\r\nreturn PTR_ERR(dev->virtbase);\r\ndev->irq = platform_get_irq(pdev, 0);\r\nret = devm_request_irq(&pdev->dev, dev->irq, stu300_irh, 0, NAME, dev);\r\nif (ret < 0)\r\nreturn ret;\r\ndev->speed = scl_frequency;\r\nclk_prepare_enable(dev->clk);\r\nret = stu300_init_hw(dev);\r\nclk_disable(dev->clk);\r\nif (ret != 0) {\r\ndev_err(&dev->pdev->dev, "error initializing hardware.\n");\r\nreturn -EIO;\r\n}\r\nspin_lock_init(&dev->cmd_issue_lock);\r\ndev->cmd_event = STU300_EVENT_NONE;\r\ndev->cmd_err = STU300_ERROR_NONE;\r\nadap = &dev->adapter;\r\nadap->owner = THIS_MODULE;\r\nadap->class = I2C_CLASS_DDC;\r\nstrlcpy(adap->name, "ST Microelectronics DDC I2C adapter",\r\nsizeof(adap->name));\r\nadap->nr = bus_nr;\r\nadap->algo = &stu300_algo;\r\nadap->dev.parent = &pdev->dev;\r\nadap->dev.of_node = pdev->dev.of_node;\r\ni2c_set_adapdata(adap, dev);\r\nret = i2c_add_numbered_adapter(adap);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failure adding ST Micro DDC "\r\n"I2C adapter\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, dev);\r\ndev_info(&pdev->dev, "ST DDC I2C @ %p, irq %d\n",\r\ndev->virtbase, dev->irq);\r\nreturn 0;\r\n}\r\nstatic int stu300_suspend(struct device *device)\r\n{\r\nstruct stu300_dev *dev = dev_get_drvdata(device);\r\nstu300_wr8(0x00, dev->virtbase + I2C_CR);\r\nreturn 0;\r\n}\r\nstatic int stu300_resume(struct device *device)\r\n{\r\nint ret = 0;\r\nstruct stu300_dev *dev = dev_get_drvdata(device);\r\nclk_enable(dev->clk);\r\nret = stu300_init_hw(dev);\r\nclk_disable(dev->clk);\r\nif (ret != 0)\r\ndev_err(device, "error re-initializing hardware.\n");\r\nreturn ret;\r\n}\r\nstatic int stu300_remove(struct platform_device *pdev)\r\n{\r\nstruct stu300_dev *dev = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&dev->adapter);\r\nstu300_wr8(0x00, dev->virtbase + I2C_CR);\r\nreturn 0;\r\n}\r\nstatic int __init stu300_init(void)\r\n{\r\nreturn platform_driver_register(&stu300_i2c_driver);\r\n}\r\nstatic void __exit stu300_exit(void)\r\n{\r\nplatform_driver_unregister(&stu300_i2c_driver);\r\n}
