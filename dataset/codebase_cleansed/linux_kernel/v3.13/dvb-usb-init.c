static int dvb_usb_adapter_init(struct dvb_usb_device *d, short *adapter_nrs)\r\n{\r\nstruct dvb_usb_adapter *adap;\r\nint ret, n, o;\r\nfor (n = 0; n < d->props.num_adapters; n++) {\r\nadap = &d->adapter[n];\r\nadap->dev = d;\r\nadap->id = n;\r\nmemcpy(&adap->props, &d->props.adapter[n], sizeof(struct dvb_usb_adapter_properties));\r\nfor (o = 0; o < adap->props.num_frontends; o++) {\r\nstruct dvb_usb_adapter_fe_properties *props = &adap->props.fe[o];\r\nif (d->udev->speed == USB_SPEED_FULL && !(props->caps & DVB_USB_ADAP_HAS_PID_FILTER)) {\r\nerr("This USB2.0 device cannot be run on a USB1.1 port. (it lacks a hardware PID filter)");\r\nreturn -ENODEV;\r\n}\r\nif ((d->udev->speed == USB_SPEED_FULL && props->caps & DVB_USB_ADAP_HAS_PID_FILTER) ||\r\n(props->caps & DVB_USB_ADAP_NEED_PID_FILTERING)) {\r\ninfo("will use the device's hardware PID filter (table count: %d).", props->pid_filter_count);\r\nadap->fe_adap[o].pid_filtering = 1;\r\nadap->fe_adap[o].max_feed_count = props->pid_filter_count;\r\n} else {\r\ninfo("will pass the complete MPEG2 transport stream to the software demuxer.");\r\nadap->fe_adap[o].pid_filtering = 0;\r\nadap->fe_adap[o].max_feed_count = 255;\r\n}\r\nif (!adap->fe_adap[o].pid_filtering &&\r\ndvb_usb_force_pid_filter_usage &&\r\nprops->caps & DVB_USB_ADAP_HAS_PID_FILTER) {\r\ninfo("pid filter enabled by module option.");\r\nadap->fe_adap[o].pid_filtering = 1;\r\nadap->fe_adap[o].max_feed_count = props->pid_filter_count;\r\n}\r\nif (props->size_of_priv > 0) {\r\nadap->fe_adap[o].priv = kzalloc(props->size_of_priv, GFP_KERNEL);\r\nif (adap->fe_adap[o].priv == NULL) {\r\nerr("no memory for priv for adapter %d fe %d.", n, o);\r\nreturn -ENOMEM;\r\n}\r\n}\r\n}\r\nif (adap->props.size_of_priv > 0) {\r\nadap->priv = kzalloc(adap->props.size_of_priv, GFP_KERNEL);\r\nif (adap->priv == NULL) {\r\nerr("no memory for priv for adapter %d.", n);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif ((ret = dvb_usb_adapter_stream_init(adap)) ||\r\n(ret = dvb_usb_adapter_dvb_init(adap, adapter_nrs)) ||\r\n(ret = dvb_usb_adapter_frontend_init(adap))) {\r\nreturn ret;\r\n}\r\nif (adap->fe_adap[1].fe)\r\nadap->dvb_adap.mfe_shared = 1;\r\nd->num_adapters_initialized++;\r\nd->state |= DVB_USB_STATE_DVB;\r\n}\r\nif (d->props.generic_bulk_ctrl_endpoint != 0) {\r\nusb_clear_halt(d->udev, usb_sndbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\r\nusb_clear_halt(d->udev, usb_rcvbulkpipe(d->udev, d->props.generic_bulk_ctrl_endpoint));\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_usb_adapter_exit(struct dvb_usb_device *d)\r\n{\r\nint n;\r\nfor (n = 0; n < d->num_adapters_initialized; n++) {\r\ndvb_usb_adapter_frontend_exit(&d->adapter[n]);\r\ndvb_usb_adapter_dvb_exit(&d->adapter[n]);\r\ndvb_usb_adapter_stream_exit(&d->adapter[n]);\r\nkfree(d->adapter[n].priv);\r\n}\r\nd->num_adapters_initialized = 0;\r\nd->state &= ~DVB_USB_STATE_DVB;\r\nreturn 0;\r\n}\r\nstatic int dvb_usb_exit(struct dvb_usb_device *d)\r\n{\r\ndeb_info("state before exiting everything: %x\n", d->state);\r\ndvb_usb_remote_exit(d);\r\ndvb_usb_adapter_exit(d);\r\ndvb_usb_i2c_exit(d);\r\ndeb_info("state should be zero now: %x\n", d->state);\r\nd->state = DVB_USB_STATE_INIT;\r\nkfree(d->priv);\r\nkfree(d);\r\nreturn 0;\r\n}\r\nstatic int dvb_usb_init(struct dvb_usb_device *d, short *adapter_nums)\r\n{\r\nint ret = 0;\r\nmutex_init(&d->usb_mutex);\r\nmutex_init(&d->i2c_mutex);\r\nd->state = DVB_USB_STATE_INIT;\r\nif (d->props.size_of_priv > 0) {\r\nd->priv = kzalloc(d->props.size_of_priv, GFP_KERNEL);\r\nif (d->priv == NULL) {\r\nerr("no memory for priv in 'struct dvb_usb_device'");\r\nreturn -ENOMEM;\r\n}\r\n}\r\ndvb_usb_device_power_ctrl(d, 1);\r\nif ((ret = dvb_usb_i2c_init(d)) ||\r\n(ret = dvb_usb_adapter_init(d, adapter_nums))) {\r\ndvb_usb_exit(d);\r\nreturn ret;\r\n}\r\nif ((ret = dvb_usb_remote_init(d)))\r\nerr("could not initialize remote control.");\r\ndvb_usb_device_power_ctrl(d, 0);\r\nreturn 0;\r\n}\r\nstatic struct dvb_usb_device_description *dvb_usb_find_device(struct usb_device *udev, struct dvb_usb_device_properties *props, int *cold)\r\n{\r\nint i, j;\r\nstruct dvb_usb_device_description *desc = NULL;\r\n*cold = -1;\r\nfor (i = 0; i < props->num_device_descs; i++) {\r\nfor (j = 0; j < DVB_USB_ID_MAX_NUM && props->devices[i].cold_ids[j] != NULL; j++) {\r\ndeb_info("check for cold %x %x\n", props->devices[i].cold_ids[j]->idVendor, props->devices[i].cold_ids[j]->idProduct);\r\nif (props->devices[i].cold_ids[j]->idVendor == le16_to_cpu(udev->descriptor.idVendor) &&\r\nprops->devices[i].cold_ids[j]->idProduct == le16_to_cpu(udev->descriptor.idProduct)) {\r\n*cold = 1;\r\ndesc = &props->devices[i];\r\nbreak;\r\n}\r\n}\r\nif (desc != NULL)\r\nbreak;\r\nfor (j = 0; j < DVB_USB_ID_MAX_NUM && props->devices[i].warm_ids[j] != NULL; j++) {\r\ndeb_info("check for warm %x %x\n", props->devices[i].warm_ids[j]->idVendor, props->devices[i].warm_ids[j]->idProduct);\r\nif (props->devices[i].warm_ids[j]->idVendor == le16_to_cpu(udev->descriptor.idVendor) &&\r\nprops->devices[i].warm_ids[j]->idProduct == le16_to_cpu(udev->descriptor.idProduct)) {\r\n*cold = 0;\r\ndesc = &props->devices[i];\r\nbreak;\r\n}\r\n}\r\n}\r\nif (desc != NULL && props->identify_state != NULL)\r\nprops->identify_state(udev, props, &desc, cold);\r\nreturn desc;\r\n}\r\nint dvb_usb_device_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nif (onoff)\r\nd->powered++;\r\nelse\r\nd->powered--;\r\nif (d->powered == 0 || (onoff && d->powered == 1)) {\r\ndeb_info("power control: %d\n", onoff);\r\nif (d->props.power_ctrl)\r\nreturn d->props.power_ctrl(d, onoff);\r\n}\r\nreturn 0;\r\n}\r\nint dvb_usb_device_init(struct usb_interface *intf,\r\nstruct dvb_usb_device_properties *props,\r\nstruct module *owner, struct dvb_usb_device **du,\r\nshort *adapter_nums)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct dvb_usb_device *d = NULL;\r\nstruct dvb_usb_device_description *desc = NULL;\r\nint ret = -ENOMEM, cold = 0;\r\nif (du != NULL)\r\n*du = NULL;\r\nif ((desc = dvb_usb_find_device(udev, props, &cold)) == NULL) {\r\ndeb_err("something went very wrong, device was not found in current device list - let's see what comes next.\n");\r\nreturn -ENODEV;\r\n}\r\nif (cold) {\r\ninfo("found a '%s' in cold state, will try to load a firmware", desc->name);\r\nret = dvb_usb_download_firmware(udev, props);\r\nif (!props->no_reconnect || ret != 0)\r\nreturn ret;\r\n}\r\ninfo("found a '%s' in warm state.", desc->name);\r\nd = kzalloc(sizeof(struct dvb_usb_device), GFP_KERNEL);\r\nif (d == NULL) {\r\nerr("no memory for 'struct dvb_usb_device'");\r\nreturn -ENOMEM;\r\n}\r\nd->udev = udev;\r\nmemcpy(&d->props, props, sizeof(struct dvb_usb_device_properties));\r\nd->desc = desc;\r\nd->owner = owner;\r\nusb_set_intfdata(intf, d);\r\nif (du != NULL)\r\n*du = d;\r\nret = dvb_usb_init(d, adapter_nums);\r\nif (ret == 0)\r\ninfo("%s successfully initialized and connected.", desc->name);\r\nelse\r\ninfo("%s error while loading driver (%d)", desc->name, ret);\r\nreturn ret;\r\n}\r\nvoid dvb_usb_device_exit(struct usb_interface *intf)\r\n{\r\nstruct dvb_usb_device *d = usb_get_intfdata(intf);\r\nconst char *name = "generic DVB-USB module";\r\nusb_set_intfdata(intf, NULL);\r\nif (d != NULL && d->desc != NULL) {\r\nname = d->desc->name;\r\ndvb_usb_exit(d);\r\n}\r\ninfo("%s successfully deinitialized and disconnected.", name);\r\n}
