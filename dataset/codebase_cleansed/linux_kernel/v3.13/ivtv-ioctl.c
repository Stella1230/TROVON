u16 ivtv_service2vbi(int type)\r\n{\r\nswitch (type) {\r\ncase V4L2_SLICED_TELETEXT_B:\r\nreturn IVTV_SLICED_TYPE_TELETEXT_B;\r\ncase V4L2_SLICED_CAPTION_525:\r\nreturn IVTV_SLICED_TYPE_CAPTION_525;\r\ncase V4L2_SLICED_WSS_625:\r\nreturn IVTV_SLICED_TYPE_WSS_625;\r\ncase V4L2_SLICED_VPS:\r\nreturn IVTV_SLICED_TYPE_VPS;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int valid_service_line(int field, int line, int is_pal)\r\n{\r\nreturn (is_pal && line >= 6 && (line != 23 || field == 0)) ||\r\n(!is_pal && line >= 10 && line < 22);\r\n}\r\nstatic u16 select_service_from_set(int field, int line, u16 set, int is_pal)\r\n{\r\nu16 valid_set = (is_pal ? V4L2_SLICED_VBI_625 : V4L2_SLICED_VBI_525);\r\nint i;\r\nset = set & valid_set;\r\nif (set == 0 || !valid_service_line(field, line, is_pal)) {\r\nreturn 0;\r\n}\r\nif (!is_pal) {\r\nif (line == 21 && (set & V4L2_SLICED_CAPTION_525))\r\nreturn V4L2_SLICED_CAPTION_525;\r\n}\r\nelse {\r\nif (line == 16 && field == 0 && (set & V4L2_SLICED_VPS))\r\nreturn V4L2_SLICED_VPS;\r\nif (line == 23 && field == 0 && (set & V4L2_SLICED_WSS_625))\r\nreturn V4L2_SLICED_WSS_625;\r\nif (line == 23)\r\nreturn 0;\r\n}\r\nfor (i = 0; i < 32; i++) {\r\nif ((1 << i) & set)\r\nreturn 1 << i;\r\n}\r\nreturn 0;\r\n}\r\nvoid ivtv_expand_service_set(struct v4l2_sliced_vbi_format *fmt, int is_pal)\r\n{\r\nu16 set = fmt->service_set;\r\nint f, l;\r\nfmt->service_set = 0;\r\nfor (f = 0; f < 2; f++) {\r\nfor (l = 0; l < 24; l++) {\r\nfmt->service_lines[f][l] = select_service_from_set(f, l, set, is_pal);\r\n}\r\n}\r\n}\r\nstatic void check_service_set(struct v4l2_sliced_vbi_format *fmt, int is_pal)\r\n{\r\nint f, l;\r\nfor (f = 0; f < 2; f++) {\r\nfor (l = 0; l < 24; l++) {\r\nfmt->service_lines[f][l] = select_service_from_set(f, l, fmt->service_lines[f][l], is_pal);\r\n}\r\n}\r\n}\r\nu16 ivtv_get_service_set(struct v4l2_sliced_vbi_format *fmt)\r\n{\r\nint f, l;\r\nu16 set = 0;\r\nfor (f = 0; f < 2; f++) {\r\nfor (l = 0; l < 24; l++) {\r\nset |= fmt->service_lines[f][l];\r\n}\r\n}\r\nreturn set;\r\n}\r\nvoid ivtv_set_osd_alpha(struct ivtv *itv)\r\n{\r\nivtv_vapi(itv, CX2341X_OSD_SET_GLOBAL_ALPHA, 3,\r\nitv->osd_global_alpha_state, itv->osd_global_alpha, !itv->osd_local_alpha_state);\r\nivtv_vapi(itv, CX2341X_OSD_SET_CHROMA_KEY, 2, itv->osd_chroma_key_state, itv->osd_chroma_key);\r\n}\r\nint ivtv_set_speed(struct ivtv *itv, int speed)\r\n{\r\nu32 data[CX2341X_MBOX_MAX_DATA];\r\nint single_step = (speed == 1 || speed == -1);\r\nDEFINE_WAIT(wait);\r\nif (speed == 0) speed = 1000;\r\nif (speed == itv->speed && !single_step)\r\nreturn 0;\r\nif (single_step && (speed < 0) == (itv->speed < 0)) {\r\nivtv_vapi(itv, CX2341X_DEC_STEP_VIDEO, 1, 0);\r\nitv->speed = speed;\r\nreturn 0;\r\n}\r\nif (single_step)\r\nspeed = speed < 0 ? -1000 : 1000;\r\ndata[0] = (speed > 1000 || speed < -1000) ? 0x80000000 : 0;\r\ndata[0] |= (speed > 1000 || speed < -1500) ? 0x40000000 : 0;\r\ndata[1] = (speed < 0);\r\ndata[2] = speed < 0 ? 3 : 7;\r\ndata[3] = v4l2_ctrl_g_ctrl(itv->cxhdl.video_b_frames);\r\ndata[4] = (speed == 1500 || speed == 500) ? itv->speed_mute_audio : 0;\r\ndata[5] = 0;\r\ndata[6] = 0;\r\nif (speed == 1500 || speed == -1500) data[0] |= 1;\r\nelse if (speed == 2000 || speed == -2000) data[0] |= 2;\r\nelse if (speed > -1000 && speed < 0) data[0] |= (-1000 / speed);\r\nelse if (speed < 1000 && speed > 0) data[0] |= (1000 / speed);\r\nif (atomic_read(&itv->decoding) > 0) {\r\nint got_sig = 0;\r\nivtv_vapi(itv, CX2341X_DEC_PAUSE_PLAYBACK, 1, 0);\r\nmutex_unlock(&itv->serialize_lock);\r\nprepare_to_wait(&itv->dma_waitq, &wait, TASK_INTERRUPTIBLE);\r\nwhile (test_bit(IVTV_F_I_DMA, &itv->i_flags)) {\r\ngot_sig = signal_pending(current);\r\nif (got_sig)\r\nbreak;\r\ngot_sig = 0;\r\nschedule();\r\n}\r\nfinish_wait(&itv->dma_waitq, &wait);\r\nmutex_lock(&itv->serialize_lock);\r\nif (got_sig)\r\nreturn -EINTR;\r\nivtv_api(itv, CX2341X_DEC_SET_PLAYBACK_SPEED, 7, data);\r\nIVTV_DEBUG_INFO("Setting Speed to 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n",\r\ndata[0], data[1], data[2], data[3], data[4], data[5], data[6]);\r\n}\r\nif (single_step) {\r\nspeed = (speed < 0) ? -1 : 1;\r\nivtv_vapi(itv, CX2341X_DEC_STEP_VIDEO, 1, 0);\r\n}\r\nitv->speed = speed;\r\nreturn 0;\r\n}\r\nstatic int ivtv_validate_speed(int cur_speed, int new_speed)\r\n{\r\nint fact = new_speed < 0 ? -1 : 1;\r\nint s;\r\nif (cur_speed == 0)\r\ncur_speed = 1000;\r\nif (new_speed < 0)\r\nnew_speed = -new_speed;\r\nif (cur_speed < 0)\r\ncur_speed = -cur_speed;\r\nif (cur_speed <= new_speed) {\r\nif (new_speed > 1500)\r\nreturn fact * 2000;\r\nif (new_speed > 1000)\r\nreturn fact * 1500;\r\n}\r\nelse {\r\nif (new_speed >= 2000)\r\nreturn fact * 2000;\r\nif (new_speed >= 1500)\r\nreturn fact * 1500;\r\nif (new_speed >= 1000)\r\nreturn fact * 1000;\r\n}\r\nif (new_speed == 0)\r\nreturn 1000;\r\nif (new_speed == 1 || new_speed == 1000)\r\nreturn fact * new_speed;\r\ns = new_speed;\r\nnew_speed = 1000 / new_speed;\r\nif (1000 / cur_speed == new_speed)\r\nnew_speed += (cur_speed < s) ? -1 : 1;\r\nif (new_speed > 60) return 1000 / (fact * 60);\r\nreturn 1000 / (fact * new_speed);\r\n}\r\nstatic int ivtv_video_command(struct ivtv *itv, struct ivtv_open_id *id,\r\nstruct v4l2_decoder_cmd *dc, int try)\r\n{\r\nstruct ivtv_stream *s = &itv->streams[IVTV_DEC_STREAM_TYPE_MPG];\r\nif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\r\nreturn -EINVAL;\r\nswitch (dc->cmd) {\r\ncase V4L2_DEC_CMD_START: {\r\ndc->flags &= V4L2_DEC_CMD_START_MUTE_AUDIO;\r\ndc->start.speed = ivtv_validate_speed(itv->speed, dc->start.speed);\r\nif (dc->start.speed < 0)\r\ndc->start.format = V4L2_DEC_START_FMT_GOP;\r\nelse\r\ndc->start.format = V4L2_DEC_START_FMT_NONE;\r\nif (dc->start.speed != 500 && dc->start.speed != 1500)\r\ndc->flags = dc->start.speed == 1000 ? 0 :\r\nV4L2_DEC_CMD_START_MUTE_AUDIO;\r\nif (try) break;\r\nitv->speed_mute_audio = dc->flags & V4L2_DEC_CMD_START_MUTE_AUDIO;\r\nif (ivtv_set_output_mode(itv, OUT_MPG) != OUT_MPG)\r\nreturn -EBUSY;\r\nif (test_and_clear_bit(IVTV_F_I_DEC_PAUSED, &itv->i_flags)) {\r\nitv->speed = 0;\r\n}\r\nreturn ivtv_start_decoding(id, dc->start.speed);\r\n}\r\ncase V4L2_DEC_CMD_STOP:\r\ndc->flags &= V4L2_DEC_CMD_STOP_IMMEDIATELY | V4L2_DEC_CMD_STOP_TO_BLACK;\r\nif (dc->flags & V4L2_DEC_CMD_STOP_IMMEDIATELY)\r\ndc->stop.pts = 0;\r\nif (try) break;\r\nif (atomic_read(&itv->decoding) == 0)\r\nreturn 0;\r\nif (itv->output_mode != OUT_MPG)\r\nreturn -EBUSY;\r\nitv->output_mode = OUT_NONE;\r\nreturn ivtv_stop_v4l2_decode_stream(s, dc->flags, dc->stop.pts);\r\ncase V4L2_DEC_CMD_PAUSE:\r\ndc->flags &= V4L2_DEC_CMD_PAUSE_TO_BLACK;\r\nif (try) break;\r\nif (!atomic_read(&itv->decoding))\r\nreturn -EPERM;\r\nif (itv->output_mode != OUT_MPG)\r\nreturn -EBUSY;\r\nif (atomic_read(&itv->decoding) > 0) {\r\nivtv_vapi(itv, CX2341X_DEC_PAUSE_PLAYBACK, 1,\r\n(dc->flags & V4L2_DEC_CMD_PAUSE_TO_BLACK) ? 1 : 0);\r\nset_bit(IVTV_F_I_DEC_PAUSED, &itv->i_flags);\r\n}\r\nbreak;\r\ncase V4L2_DEC_CMD_RESUME:\r\ndc->flags = 0;\r\nif (try) break;\r\nif (!atomic_read(&itv->decoding))\r\nreturn -EPERM;\r\nif (itv->output_mode != OUT_MPG)\r\nreturn -EBUSY;\r\nif (test_and_clear_bit(IVTV_F_I_DEC_PAUSED, &itv->i_flags)) {\r\nint speed = itv->speed;\r\nitv->speed = 0;\r\nreturn ivtv_start_decoding(id, speed);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ivtv_g_fmt_sliced_vbi_out(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nstruct v4l2_sliced_vbi_format *vbifmt = &fmt->fmt.sliced;\r\nvbifmt->reserved[0] = 0;\r\nvbifmt->reserved[1] = 0;\r\nif (!(itv->v4l2_cap & V4L2_CAP_SLICED_VBI_OUTPUT))\r\nreturn -EINVAL;\r\nvbifmt->io_size = sizeof(struct v4l2_sliced_vbi_data) * 36;\r\nmemset(vbifmt->service_lines, 0, sizeof(vbifmt->service_lines));\r\nif (itv->is_60hz) {\r\nvbifmt->service_lines[0][21] = V4L2_SLICED_CAPTION_525;\r\nvbifmt->service_lines[1][21] = V4L2_SLICED_CAPTION_525;\r\n} else {\r\nvbifmt->service_lines[0][23] = V4L2_SLICED_WSS_625;\r\nvbifmt->service_lines[0][16] = V4L2_SLICED_VPS;\r\n}\r\nvbifmt->service_set = ivtv_get_service_set(vbifmt);\r\nreturn 0;\r\n}\r\nstatic int ivtv_g_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct ivtv_open_id *id = fh2id(fh);\r\nstruct ivtv *itv = id->itv;\r\nstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\r\npixfmt->width = itv->cxhdl.width;\r\npixfmt->height = itv->cxhdl.height;\r\npixfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\npixfmt->field = V4L2_FIELD_INTERLACED;\r\npixfmt->priv = 0;\r\nif (id->type == IVTV_ENC_STREAM_TYPE_YUV) {\r\npixfmt->pixelformat = V4L2_PIX_FMT_HM12;\r\npixfmt->sizeimage = pixfmt->height * 720 * 3 / 2;\r\npixfmt->bytesperline = 720;\r\n} else {\r\npixfmt->pixelformat = V4L2_PIX_FMT_MPEG;\r\npixfmt->sizeimage = 128 * 1024;\r\npixfmt->bytesperline = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ivtv_g_fmt_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nstruct v4l2_vbi_format *vbifmt = &fmt->fmt.vbi;\r\nvbifmt->sampling_rate = 27000000;\r\nvbifmt->offset = 248;\r\nvbifmt->samples_per_line = itv->vbi.raw_decoder_line_size - 4;\r\nvbifmt->sample_format = V4L2_PIX_FMT_GREY;\r\nvbifmt->start[0] = itv->vbi.start[0];\r\nvbifmt->start[1] = itv->vbi.start[1];\r\nvbifmt->count[0] = vbifmt->count[1] = itv->vbi.count;\r\nvbifmt->flags = 0;\r\nvbifmt->reserved[0] = 0;\r\nvbifmt->reserved[1] = 0;\r\nreturn 0;\r\n}\r\nstatic int ivtv_g_fmt_sliced_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct v4l2_sliced_vbi_format *vbifmt = &fmt->fmt.sliced;\r\nstruct ivtv_open_id *id = fh2id(fh);\r\nstruct ivtv *itv = id->itv;\r\nvbifmt->reserved[0] = 0;\r\nvbifmt->reserved[1] = 0;\r\nvbifmt->io_size = sizeof(struct v4l2_sliced_vbi_data) * 36;\r\nif (id->type == IVTV_DEC_STREAM_TYPE_VBI) {\r\nvbifmt->service_set = itv->is_50hz ? V4L2_SLICED_VBI_625 :\r\nV4L2_SLICED_VBI_525;\r\nivtv_expand_service_set(vbifmt, itv->is_50hz);\r\nvbifmt->service_set = ivtv_get_service_set(vbifmt);\r\nreturn 0;\r\n}\r\nv4l2_subdev_call(itv->sd_video, vbi, g_sliced_fmt, vbifmt);\r\nvbifmt->service_set = ivtv_get_service_set(vbifmt);\r\nreturn 0;\r\n}\r\nstatic int ivtv_g_fmt_vid_out(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct ivtv_open_id *id = fh2id(fh);\r\nstruct ivtv *itv = id->itv;\r\nstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\r\nif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\r\nreturn -EINVAL;\r\npixfmt->width = itv->main_rect.width;\r\npixfmt->height = itv->main_rect.height;\r\npixfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\npixfmt->field = V4L2_FIELD_INTERLACED;\r\npixfmt->priv = 0;\r\nif (id->type == IVTV_DEC_STREAM_TYPE_YUV) {\r\nswitch (itv->yuv_info.lace_mode & IVTV_YUV_MODE_MASK) {\r\ncase IVTV_YUV_MODE_INTERLACED:\r\npixfmt->field = (itv->yuv_info.lace_mode & IVTV_YUV_SYNC_MASK) ?\r\nV4L2_FIELD_INTERLACED_BT : V4L2_FIELD_INTERLACED_TB;\r\nbreak;\r\ncase IVTV_YUV_MODE_PROGRESSIVE:\r\npixfmt->field = V4L2_FIELD_NONE;\r\nbreak;\r\ndefault:\r\npixfmt->field = V4L2_FIELD_ANY;\r\nbreak;\r\n}\r\npixfmt->pixelformat = V4L2_PIX_FMT_HM12;\r\npixfmt->bytesperline = 720;\r\npixfmt->width = itv->yuv_info.v4l2_src_w;\r\npixfmt->height = itv->yuv_info.v4l2_src_h;\r\npixfmt->sizeimage =\r\n1080 * ((pixfmt->height + 31) & ~31);\r\n} else {\r\npixfmt->pixelformat = V4L2_PIX_FMT_MPEG;\r\npixfmt->sizeimage = 128 * 1024;\r\npixfmt->bytesperline = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ivtv_g_fmt_vid_out_overlay(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nstruct v4l2_window *winfmt = &fmt->fmt.win;\r\nif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\r\nreturn -EINVAL;\r\nwinfmt->chromakey = itv->osd_chroma_key;\r\nwinfmt->global_alpha = itv->osd_global_alpha;\r\nwinfmt->field = V4L2_FIELD_INTERLACED;\r\nwinfmt->clips = NULL;\r\nwinfmt->clipcount = 0;\r\nwinfmt->bitmap = NULL;\r\nwinfmt->w.top = winfmt->w.left = 0;\r\nwinfmt->w.width = itv->osd_rect.width;\r\nwinfmt->w.height = itv->osd_rect.height;\r\nreturn 0;\r\n}\r\nstatic int ivtv_try_fmt_sliced_vbi_out(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nreturn ivtv_g_fmt_sliced_vbi_out(file, fh, fmt);\r\n}\r\nstatic int ivtv_try_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct ivtv_open_id *id = fh2id(fh);\r\nstruct ivtv *itv = id->itv;\r\nint w = fmt->fmt.pix.width;\r\nint h = fmt->fmt.pix.height;\r\nint min_h = 2;\r\nw = min(w, 720);\r\nw = max(w, 2);\r\nif (id->type == IVTV_ENC_STREAM_TYPE_YUV) {\r\nh &= ~0x1f;\r\nmin_h = 32;\r\n}\r\nh = min(h, itv->is_50hz ? 576 : 480);\r\nh = max(h, min_h);\r\nivtv_g_fmt_vid_cap(file, fh, fmt);\r\nfmt->fmt.pix.width = w;\r\nfmt->fmt.pix.height = h;\r\nreturn 0;\r\n}\r\nstatic int ivtv_try_fmt_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nreturn ivtv_g_fmt_vbi_cap(file, fh, fmt);\r\n}\r\nstatic int ivtv_try_fmt_sliced_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct v4l2_sliced_vbi_format *vbifmt = &fmt->fmt.sliced;\r\nstruct ivtv_open_id *id = fh2id(fh);\r\nstruct ivtv *itv = id->itv;\r\nif (id->type == IVTV_DEC_STREAM_TYPE_VBI)\r\nreturn ivtv_g_fmt_sliced_vbi_cap(file, fh, fmt);\r\nvbifmt->io_size = sizeof(struct v4l2_sliced_vbi_data) * 36;\r\nvbifmt->reserved[0] = 0;\r\nvbifmt->reserved[1] = 0;\r\nif (vbifmt->service_set)\r\nivtv_expand_service_set(vbifmt, itv->is_50hz);\r\ncheck_service_set(vbifmt, itv->is_50hz);\r\nvbifmt->service_set = ivtv_get_service_set(vbifmt);\r\nreturn 0;\r\n}\r\nstatic int ivtv_try_fmt_vid_out(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct ivtv_open_id *id = fh2id(fh);\r\ns32 w = fmt->fmt.pix.width;\r\ns32 h = fmt->fmt.pix.height;\r\nint field = fmt->fmt.pix.field;\r\nint ret = ivtv_g_fmt_vid_out(file, fh, fmt);\r\nw = min(w, 720);\r\nw = max(w, 2);\r\nh = min(h, 576);\r\nh = max(h, 2);\r\nif (id->type == IVTV_DEC_STREAM_TYPE_YUV)\r\nfmt->fmt.pix.field = field;\r\nfmt->fmt.pix.width = w;\r\nfmt->fmt.pix.height = h;\r\nreturn ret;\r\n}\r\nstatic int ivtv_try_fmt_vid_out_overlay(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nu32 chromakey = fmt->fmt.win.chromakey;\r\nu8 global_alpha = fmt->fmt.win.global_alpha;\r\nif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\r\nreturn -EINVAL;\r\nivtv_g_fmt_vid_out_overlay(file, fh, fmt);\r\nfmt->fmt.win.chromakey = chromakey;\r\nfmt->fmt.win.global_alpha = global_alpha;\r\nreturn 0;\r\n}\r\nstatic int ivtv_s_fmt_sliced_vbi_out(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nreturn ivtv_g_fmt_sliced_vbi_out(file, fh, fmt);\r\n}\r\nstatic int ivtv_s_fmt_vid_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct ivtv_open_id *id = fh2id(fh);\r\nstruct ivtv *itv = id->itv;\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nint ret = ivtv_try_fmt_vid_cap(file, fh, fmt);\r\nint w = fmt->fmt.pix.width;\r\nint h = fmt->fmt.pix.height;\r\nif (ret)\r\nreturn ret;\r\nif (itv->cxhdl.width == w && itv->cxhdl.height == h)\r\nreturn 0;\r\nif (atomic_read(&itv->capturing) > 0)\r\nreturn -EBUSY;\r\nitv->cxhdl.width = w;\r\nitv->cxhdl.height = h;\r\nif (v4l2_ctrl_g_ctrl(itv->cxhdl.video_encoding) == V4L2_MPEG_VIDEO_ENCODING_MPEG_1)\r\nfmt->fmt.pix.width /= 2;\r\nmbus_fmt.width = fmt->fmt.pix.width;\r\nmbus_fmt.height = h;\r\nmbus_fmt.code = V4L2_MBUS_FMT_FIXED;\r\nv4l2_subdev_call(itv->sd_video, video, s_mbus_fmt, &mbus_fmt);\r\nreturn ivtv_g_fmt_vid_cap(file, fh, fmt);\r\n}\r\nstatic int ivtv_s_fmt_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nif (!ivtv_raw_vbi(itv) && atomic_read(&itv->capturing) > 0)\r\nreturn -EBUSY;\r\nitv->vbi.sliced_in->service_set = 0;\r\nitv->vbi.in.type = V4L2_BUF_TYPE_VBI_CAPTURE;\r\nv4l2_subdev_call(itv->sd_video, vbi, s_raw_fmt, &fmt->fmt.vbi);\r\nreturn ivtv_g_fmt_vbi_cap(file, fh, fmt);\r\n}\r\nstatic int ivtv_s_fmt_sliced_vbi_cap(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct v4l2_sliced_vbi_format *vbifmt = &fmt->fmt.sliced;\r\nstruct ivtv_open_id *id = fh2id(fh);\r\nstruct ivtv *itv = id->itv;\r\nint ret = ivtv_try_fmt_sliced_vbi_cap(file, fh, fmt);\r\nif (ret || id->type == IVTV_DEC_STREAM_TYPE_VBI)\r\nreturn ret;\r\ncheck_service_set(vbifmt, itv->is_50hz);\r\nif (ivtv_raw_vbi(itv) && atomic_read(&itv->capturing) > 0)\r\nreturn -EBUSY;\r\nitv->vbi.in.type = V4L2_BUF_TYPE_SLICED_VBI_CAPTURE;\r\nv4l2_subdev_call(itv->sd_video, vbi, s_sliced_fmt, vbifmt);\r\nmemcpy(itv->vbi.sliced_in, vbifmt, sizeof(*itv->vbi.sliced_in));\r\nreturn 0;\r\n}\r\nstatic int ivtv_s_fmt_vid_out(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct ivtv_open_id *id = fh2id(fh);\r\nstruct ivtv *itv = id->itv;\r\nstruct yuv_playback_info *yi = &itv->yuv_info;\r\nint ret = ivtv_try_fmt_vid_out(file, fh, fmt);\r\nif (ret)\r\nreturn ret;\r\nif (id->type != IVTV_DEC_STREAM_TYPE_YUV)\r\nreturn 0;\r\nif (yi->stream_size)\r\nreturn -EBUSY;\r\nyi->v4l2_src_w = fmt->fmt.pix.width;\r\nyi->v4l2_src_h = fmt->fmt.pix.height;\r\nswitch (fmt->fmt.pix.field) {\r\ncase V4L2_FIELD_NONE:\r\nyi->lace_mode = IVTV_YUV_MODE_PROGRESSIVE;\r\nbreak;\r\ncase V4L2_FIELD_ANY:\r\nyi->lace_mode = IVTV_YUV_MODE_AUTO;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED_BT:\r\nyi->lace_mode =\r\nIVTV_YUV_MODE_INTERLACED|IVTV_YUV_SYNC_ODD;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED_TB:\r\ndefault:\r\nyi->lace_mode = IVTV_YUV_MODE_INTERLACED;\r\nbreak;\r\n}\r\nyi->lace_sync_field = (yi->lace_mode & IVTV_YUV_SYNC_MASK) == IVTV_YUV_SYNC_EVEN ? 0 : 1;\r\nif (test_bit(IVTV_F_I_DEC_YUV, &itv->i_flags))\r\nitv->dma_data_req_size =\r\n1080 * ((yi->v4l2_src_h + 31) & ~31);\r\nreturn 0;\r\n}\r\nstatic int ivtv_s_fmt_vid_out_overlay(struct file *file, void *fh, struct v4l2_format *fmt)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nint ret = ivtv_try_fmt_vid_out_overlay(file, fh, fmt);\r\nif (ret == 0) {\r\nitv->osd_chroma_key = fmt->fmt.win.chromakey;\r\nitv->osd_global_alpha = fmt->fmt.win.global_alpha;\r\nivtv_set_osd_alpha(itv);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ivtv_itvc(struct ivtv *itv, bool get, u64 reg, u64 *val)\r\n{\r\nvolatile u8 __iomem *reg_start;\r\nif (reg & 0x3)\r\nreturn -EINVAL;\r\nif (reg >= IVTV_REG_OFFSET && reg < IVTV_REG_OFFSET + IVTV_REG_SIZE)\r\nreg_start = itv->reg_mem - IVTV_REG_OFFSET;\r\nelse if (itv->has_cx23415 && reg >= IVTV_DECODER_OFFSET &&\r\nreg < IVTV_DECODER_OFFSET + IVTV_DECODER_SIZE)\r\nreg_start = itv->dec_mem - IVTV_DECODER_OFFSET;\r\nelse if (reg < IVTV_ENCODER_SIZE)\r\nreg_start = itv->enc_mem;\r\nelse\r\nreturn -EINVAL;\r\nif (get)\r\n*val = readl(reg + reg_start);\r\nelse\r\nwritel(*val, reg + reg_start);\r\nreturn 0;\r\n}\r\nstatic int ivtv_g_register(struct file *file, void *fh, struct v4l2_dbg_register *reg)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nreg->size = 4;\r\nreturn ivtv_itvc(itv, true, reg->reg, &reg->val);\r\n}\r\nstatic int ivtv_s_register(struct file *file, void *fh, const struct v4l2_dbg_register *reg)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nu64 val = reg->val;\r\nreturn ivtv_itvc(itv, false, reg->reg, &val);\r\n}\r\nstatic int ivtv_querycap(struct file *file, void *fh, struct v4l2_capability *vcap)\r\n{\r\nstruct ivtv_open_id *id = fh2id(file->private_data);\r\nstruct ivtv *itv = id->itv;\r\nstruct ivtv_stream *s = &itv->streams[id->type];\r\nstrlcpy(vcap->driver, IVTV_DRIVER_NAME, sizeof(vcap->driver));\r\nstrlcpy(vcap->card, itv->card_name, sizeof(vcap->card));\r\nsnprintf(vcap->bus_info, sizeof(vcap->bus_info), "PCI:%s", pci_name(itv->pdev));\r\nvcap->capabilities = itv->v4l2_cap | V4L2_CAP_DEVICE_CAPS;\r\nvcap->device_caps = s->caps;\r\nreturn 0;\r\n}\r\nstatic int ivtv_enumaudio(struct file *file, void *fh, struct v4l2_audio *vin)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nreturn ivtv_get_audio_input(itv, vin->index, vin);\r\n}\r\nstatic int ivtv_g_audio(struct file *file, void *fh, struct v4l2_audio *vin)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nvin->index = itv->audio_input;\r\nreturn ivtv_get_audio_input(itv, vin->index, vin);\r\n}\r\nstatic int ivtv_s_audio(struct file *file, void *fh, const struct v4l2_audio *vout)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nif (vout->index >= itv->nof_audio_inputs)\r\nreturn -EINVAL;\r\nitv->audio_input = vout->index;\r\nivtv_audio_set_io(itv);\r\nreturn 0;\r\n}\r\nstatic int ivtv_enumaudout(struct file *file, void *fh, struct v4l2_audioout *vin)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nreturn ivtv_get_audio_output(itv, vin->index, vin);\r\n}\r\nstatic int ivtv_g_audout(struct file *file, void *fh, struct v4l2_audioout *vin)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nvin->index = 0;\r\nreturn ivtv_get_audio_output(itv, vin->index, vin);\r\n}\r\nstatic int ivtv_s_audout(struct file *file, void *fh, const struct v4l2_audioout *vout)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nif (itv->card->video_outputs == NULL || vout->index != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ivtv_enum_input(struct file *file, void *fh, struct v4l2_input *vin)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nreturn ivtv_get_input(itv, vin->index, vin);\r\n}\r\nstatic int ivtv_enum_output(struct file *file, void *fh, struct v4l2_output *vout)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nreturn ivtv_get_output(itv, vout->index, vout);\r\n}\r\nstatic int ivtv_cropcap(struct file *file, void *fh, struct v4l2_cropcap *cropcap)\r\n{\r\nstruct ivtv_open_id *id = fh2id(fh);\r\nstruct ivtv *itv = id->itv;\r\nstruct yuv_playback_info *yi = &itv->yuv_info;\r\nint streamtype;\r\nstreamtype = id->type;\r\nif (cropcap->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\ncropcap->bounds.top = cropcap->bounds.left = 0;\r\ncropcap->bounds.width = 720;\r\nif (cropcap->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\ncropcap->bounds.height = itv->is_50hz ? 576 : 480;\r\ncropcap->pixelaspect.numerator = itv->is_50hz ? 59 : 10;\r\ncropcap->pixelaspect.denominator = itv->is_50hz ? 54 : 11;\r\n} else if (streamtype == IVTV_DEC_STREAM_TYPE_YUV) {\r\nif (yi->track_osd) {\r\ncropcap->bounds.width = yi->osd_full_w;\r\ncropcap->bounds.height = yi->osd_full_h;\r\n} else {\r\ncropcap->bounds.width = 720;\r\ncropcap->bounds.height =\r\nitv->is_out_50hz ? 576 : 480;\r\n}\r\ncropcap->pixelaspect.numerator = itv->is_out_50hz ? 59 : 10;\r\ncropcap->pixelaspect.denominator = itv->is_out_50hz ? 54 : 11;\r\n} else {\r\ncropcap->bounds.height = itv->is_out_50hz ? 576 : 480;\r\ncropcap->pixelaspect.numerator = itv->is_out_50hz ? 59 : 10;\r\ncropcap->pixelaspect.denominator = itv->is_out_50hz ? 54 : 11;\r\n}\r\ncropcap->defrect = cropcap->bounds;\r\nreturn 0;\r\n}\r\nstatic int ivtv_s_crop(struct file *file, void *fh, const struct v4l2_crop *crop)\r\n{\r\nstruct ivtv_open_id *id = fh2id(fh);\r\nstruct ivtv *itv = id->itv;\r\nstruct yuv_playback_info *yi = &itv->yuv_info;\r\nint streamtype;\r\nstreamtype = id->type;\r\nif (crop->type == V4L2_BUF_TYPE_VIDEO_OUTPUT &&\r\n(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT)) {\r\nif (streamtype == IVTV_DEC_STREAM_TYPE_YUV) {\r\nyi->main_rect = crop->c;\r\nreturn 0;\r\n} else {\r\nif (!ivtv_vapi(itv, CX2341X_OSD_SET_FRAMEBUFFER_WINDOW, 4,\r\ncrop->c.width, crop->c.height, crop->c.left, crop->c.top)) {\r\nitv->main_rect = crop->c;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ivtv_g_crop(struct file *file, void *fh, struct v4l2_crop *crop)\r\n{\r\nstruct ivtv_open_id *id = fh2id(fh);\r\nstruct ivtv *itv = id->itv;\r\nstruct yuv_playback_info *yi = &itv->yuv_info;\r\nint streamtype;\r\nstreamtype = id->type;\r\nif (crop->type == V4L2_BUF_TYPE_VIDEO_OUTPUT &&\r\n(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT)) {\r\nif (streamtype == IVTV_DEC_STREAM_TYPE_YUV)\r\ncrop->c = yi->main_rect;\r\nelse\r\ncrop->c = itv->main_rect;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ivtv_enum_fmt_vid_cap(struct file *file, void *fh, struct v4l2_fmtdesc *fmt)\r\n{\r\nstatic const struct v4l2_fmtdesc hm12 = {\r\n0, V4L2_BUF_TYPE_VIDEO_CAPTURE, 0,\r\n"HM12 (YUV 4:2:0)", V4L2_PIX_FMT_HM12,\r\n{ 0, 0, 0, 0 }\r\n};\r\nstatic const struct v4l2_fmtdesc mpeg = {\r\n0, V4L2_BUF_TYPE_VIDEO_CAPTURE, V4L2_FMT_FLAG_COMPRESSED,\r\n"MPEG", V4L2_PIX_FMT_MPEG,\r\n{ 0, 0, 0, 0 }\r\n};\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nstruct ivtv_stream *s = &itv->streams[fh2id(fh)->type];\r\nif (fmt->index)\r\nreturn -EINVAL;\r\nif (s->type == IVTV_ENC_STREAM_TYPE_MPG)\r\n*fmt = mpeg;\r\nelse if (s->type == IVTV_ENC_STREAM_TYPE_YUV)\r\n*fmt = hm12;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ivtv_enum_fmt_vid_out(struct file *file, void *fh, struct v4l2_fmtdesc *fmt)\r\n{\r\nstatic const struct v4l2_fmtdesc hm12 = {\r\n0, V4L2_BUF_TYPE_VIDEO_OUTPUT, 0,\r\n"HM12 (YUV 4:2:0)", V4L2_PIX_FMT_HM12,\r\n{ 0, 0, 0, 0 }\r\n};\r\nstatic const struct v4l2_fmtdesc mpeg = {\r\n0, V4L2_BUF_TYPE_VIDEO_OUTPUT, V4L2_FMT_FLAG_COMPRESSED,\r\n"MPEG", V4L2_PIX_FMT_MPEG,\r\n{ 0, 0, 0, 0 }\r\n};\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nstruct ivtv_stream *s = &itv->streams[fh2id(fh)->type];\r\nif (fmt->index)\r\nreturn -EINVAL;\r\nif (s->type == IVTV_DEC_STREAM_TYPE_MPG)\r\n*fmt = mpeg;\r\nelse if (s->type == IVTV_DEC_STREAM_TYPE_YUV)\r\n*fmt = hm12;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ivtv_g_input(struct file *file, void *fh, unsigned int *i)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\n*i = itv->active_input;\r\nreturn 0;\r\n}\r\nint ivtv_s_input(struct file *file, void *fh, unsigned int inp)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nv4l2_std_id std;\r\nint i;\r\nif (inp >= itv->nof_inputs)\r\nreturn -EINVAL;\r\nif (inp == itv->active_input) {\r\nIVTV_DEBUG_INFO("Input unchanged\n");\r\nreturn 0;\r\n}\r\nif (atomic_read(&itv->capturing) > 0) {\r\nreturn -EBUSY;\r\n}\r\nIVTV_DEBUG_INFO("Changing input from %d to %d\n",\r\nitv->active_input, inp);\r\nitv->active_input = inp;\r\nitv->audio_input = itv->card->video_inputs[inp].audio_index;\r\nif (itv->card->video_inputs[inp].video_type == IVTV_CARD_INPUT_VID_TUNER)\r\nstd = itv->tuner_std;\r\nelse\r\nstd = V4L2_STD_ALL;\r\nfor (i = 0; i <= IVTV_ENC_STREAM_TYPE_VBI; i++)\r\nitv->streams[i].vdev->tvnorms = std;\r\nivtv_mute(itv);\r\nivtv_video_set_io(itv);\r\nivtv_audio_set_io(itv);\r\nivtv_unmute(itv);\r\nreturn 0;\r\n}\r\nstatic int ivtv_g_output(struct file *file, void *fh, unsigned int *i)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\r\nreturn -EINVAL;\r\n*i = itv->active_output;\r\nreturn 0;\r\n}\r\nstatic int ivtv_s_output(struct file *file, void *fh, unsigned int outp)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nif (outp >= itv->card->nof_outputs)\r\nreturn -EINVAL;\r\nif (outp == itv->active_output) {\r\nIVTV_DEBUG_INFO("Output unchanged\n");\r\nreturn 0;\r\n}\r\nIVTV_DEBUG_INFO("Changing output from %d to %d\n",\r\nitv->active_output, outp);\r\nitv->active_output = outp;\r\nivtv_call_hw(itv, IVTV_HW_SAA7127, video, s_routing,\r\nSAA7127_INPUT_TYPE_NORMAL,\r\nitv->card->video_outputs[outp].video_output, 0);\r\nreturn 0;\r\n}\r\nstatic int ivtv_g_frequency(struct file *file, void *fh, struct v4l2_frequency *vf)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nstruct ivtv_stream *s = &itv->streams[fh2id(fh)->type];\r\nif (s->vdev->vfl_dir)\r\nreturn -ENOTTY;\r\nif (vf->tuner != 0)\r\nreturn -EINVAL;\r\nivtv_call_all(itv, tuner, g_frequency, vf);\r\nreturn 0;\r\n}\r\nint ivtv_s_frequency(struct file *file, void *fh, const struct v4l2_frequency *vf)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nstruct ivtv_stream *s = &itv->streams[fh2id(fh)->type];\r\nif (s->vdev->vfl_dir)\r\nreturn -ENOTTY;\r\nif (vf->tuner != 0)\r\nreturn -EINVAL;\r\nivtv_mute(itv);\r\nIVTV_DEBUG_INFO("v4l2 ioctl: set frequency %d\n", vf->frequency);\r\nivtv_call_all(itv, tuner, s_frequency, vf);\r\nivtv_unmute(itv);\r\nreturn 0;\r\n}\r\nstatic int ivtv_g_std(struct file *file, void *fh, v4l2_std_id *std)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\n*std = itv->std;\r\nreturn 0;\r\n}\r\nvoid ivtv_s_std_enc(struct ivtv *itv, v4l2_std_id std)\r\n{\r\nitv->std = std;\r\nitv->is_60hz = (std & V4L2_STD_525_60) ? 1 : 0;\r\nitv->is_50hz = !itv->is_60hz;\r\ncx2341x_handler_set_50hz(&itv->cxhdl, itv->is_50hz);\r\nitv->cxhdl.width = 720;\r\nitv->cxhdl.height = itv->is_50hz ? 576 : 480;\r\nitv->vbi.count = itv->is_50hz ? 18 : 12;\r\nitv->vbi.start[0] = itv->is_50hz ? 6 : 10;\r\nitv->vbi.start[1] = itv->is_50hz ? 318 : 273;\r\nif (itv->hw_flags & IVTV_HW_CX25840)\r\nitv->vbi.sliced_decoder_line_size = itv->is_60hz ? 272 : 284;\r\nivtv_call_all(itv, core, s_std, itv->std);\r\n}\r\nvoid ivtv_s_std_dec(struct ivtv *itv, v4l2_std_id std)\r\n{\r\nstruct yuv_playback_info *yi = &itv->yuv_info;\r\nDEFINE_WAIT(wait);\r\nint f;\r\nitv->std_out = std;\r\nitv->is_out_60hz = (std & V4L2_STD_525_60) ? 1 : 0;\r\nitv->is_out_50hz = !itv->is_out_60hz;\r\nivtv_call_all(itv, video, s_std_output, itv->std_out);\r\nmutex_unlock(&itv->serialize_lock);\r\nfor (f = 0; f < 4; f++) {\r\nprepare_to_wait(&itv->vsync_waitq, &wait,\r\nTASK_UNINTERRUPTIBLE);\r\nif ((read_reg(IVTV_REG_DEC_LINE_FIELD) >> 16) < 100)\r\nbreak;\r\nschedule_timeout(msecs_to_jiffies(25));\r\n}\r\nfinish_wait(&itv->vsync_waitq, &wait);\r\nmutex_lock(&itv->serialize_lock);\r\nif (f == 4)\r\nIVTV_WARN("Mode change failed to sync to decoder\n");\r\nivtv_vapi(itv, CX2341X_DEC_SET_STANDARD, 1, itv->is_out_50hz);\r\nitv->main_rect.left = 0;\r\nitv->main_rect.top = 0;\r\nitv->main_rect.width = 720;\r\nitv->main_rect.height = itv->is_out_50hz ? 576 : 480;\r\nivtv_vapi(itv, CX2341X_OSD_SET_FRAMEBUFFER_WINDOW, 4,\r\n720, itv->main_rect.height, 0, 0);\r\nyi->main_rect = itv->main_rect;\r\nif (!itv->osd_info) {\r\nyi->osd_full_w = 720;\r\nyi->osd_full_h = itv->is_out_50hz ? 576 : 480;\r\n}\r\n}\r\nstatic int ivtv_s_std(struct file *file, void *fh, v4l2_std_id std)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nif ((std & V4L2_STD_ALL) == 0)\r\nreturn -EINVAL;\r\nif (std == itv->std)\r\nreturn 0;\r\nif (test_bit(IVTV_F_I_RADIO_USER, &itv->i_flags) ||\r\natomic_read(&itv->capturing) > 0 ||\r\natomic_read(&itv->decoding) > 0) {\r\nreturn -EBUSY;\r\n}\r\nIVTV_DEBUG_INFO("Switching standard to %llx.\n",\r\n(unsigned long long)itv->std);\r\nivtv_s_std_enc(itv, std);\r\nif (itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT)\r\nivtv_s_std_dec(itv, std);\r\nreturn 0;\r\n}\r\nstatic int ivtv_s_tuner(struct file *file, void *fh, const struct v4l2_tuner *vt)\r\n{\r\nstruct ivtv_open_id *id = fh2id(fh);\r\nstruct ivtv *itv = id->itv;\r\nif (vt->index != 0)\r\nreturn -EINVAL;\r\nivtv_call_all(itv, tuner, s_tuner, vt);\r\nreturn 0;\r\n}\r\nstatic int ivtv_g_tuner(struct file *file, void *fh, struct v4l2_tuner *vt)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nif (vt->index != 0)\r\nreturn -EINVAL;\r\nivtv_call_all(itv, tuner, g_tuner, vt);\r\nif (vt->type == V4L2_TUNER_RADIO)\r\nstrlcpy(vt->name, "ivtv Radio Tuner", sizeof(vt->name));\r\nelse\r\nstrlcpy(vt->name, "ivtv TV Tuner", sizeof(vt->name));\r\nreturn 0;\r\n}\r\nstatic int ivtv_g_sliced_vbi_cap(struct file *file, void *fh, struct v4l2_sliced_vbi_cap *cap)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nint set = itv->is_50hz ? V4L2_SLICED_VBI_625 : V4L2_SLICED_VBI_525;\r\nint f, l;\r\nif (cap->type == V4L2_BUF_TYPE_SLICED_VBI_CAPTURE) {\r\nfor (f = 0; f < 2; f++) {\r\nfor (l = 0; l < 24; l++) {\r\nif (valid_service_line(f, l, itv->is_50hz))\r\ncap->service_lines[f][l] = set;\r\n}\r\n}\r\n} else if (cap->type == V4L2_BUF_TYPE_SLICED_VBI_OUTPUT) {\r\nif (!(itv->v4l2_cap & V4L2_CAP_SLICED_VBI_OUTPUT))\r\nreturn -EINVAL;\r\nif (itv->is_60hz) {\r\ncap->service_lines[0][21] = V4L2_SLICED_CAPTION_525;\r\ncap->service_lines[1][21] = V4L2_SLICED_CAPTION_525;\r\n} else {\r\ncap->service_lines[0][23] = V4L2_SLICED_WSS_625;\r\ncap->service_lines[0][16] = V4L2_SLICED_VPS;\r\n}\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nset = 0;\r\nfor (f = 0; f < 2; f++)\r\nfor (l = 0; l < 24; l++)\r\nset |= cap->service_lines[f][l];\r\ncap->service_set = set;\r\nreturn 0;\r\n}\r\nstatic int ivtv_g_enc_index(struct file *file, void *fh, struct v4l2_enc_idx *idx)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nstruct v4l2_enc_idx_entry *e = idx->entry;\r\nint entries;\r\nint i;\r\nentries = (itv->pgm_info_write_idx + IVTV_MAX_PGM_INDEX - itv->pgm_info_read_idx) %\r\nIVTV_MAX_PGM_INDEX;\r\nif (entries > V4L2_ENC_IDX_ENTRIES)\r\nentries = V4L2_ENC_IDX_ENTRIES;\r\nidx->entries = 0;\r\nidx->entries_cap = IVTV_MAX_PGM_INDEX;\r\nif (!atomic_read(&itv->capturing))\r\nreturn 0;\r\nfor (i = 0; i < entries; i++) {\r\n*e = itv->pgm_info[(itv->pgm_info_read_idx + i) % IVTV_MAX_PGM_INDEX];\r\nif ((e->flags & V4L2_ENC_IDX_FRAME_MASK) <= V4L2_ENC_IDX_FRAME_B) {\r\nidx->entries++;\r\ne++;\r\n}\r\n}\r\nitv->pgm_info_read_idx = (itv->pgm_info_read_idx + idx->entries) % IVTV_MAX_PGM_INDEX;\r\nreturn 0;\r\n}\r\nstatic int ivtv_encoder_cmd(struct file *file, void *fh, struct v4l2_encoder_cmd *enc)\r\n{\r\nstruct ivtv_open_id *id = fh2id(fh);\r\nstruct ivtv *itv = id->itv;\r\nswitch (enc->cmd) {\r\ncase V4L2_ENC_CMD_START:\r\nIVTV_DEBUG_IOCTL("V4L2_ENC_CMD_START\n");\r\nenc->flags = 0;\r\nreturn ivtv_start_capture(id);\r\ncase V4L2_ENC_CMD_STOP:\r\nIVTV_DEBUG_IOCTL("V4L2_ENC_CMD_STOP\n");\r\nenc->flags &= V4L2_ENC_CMD_STOP_AT_GOP_END;\r\nivtv_stop_capture(id, enc->flags & V4L2_ENC_CMD_STOP_AT_GOP_END);\r\nreturn 0;\r\ncase V4L2_ENC_CMD_PAUSE:\r\nIVTV_DEBUG_IOCTL("V4L2_ENC_CMD_PAUSE\n");\r\nenc->flags = 0;\r\nif (!atomic_read(&itv->capturing))\r\nreturn -EPERM;\r\nif (test_and_set_bit(IVTV_F_I_ENC_PAUSED, &itv->i_flags))\r\nreturn 0;\r\nivtv_mute(itv);\r\nivtv_vapi(itv, CX2341X_ENC_PAUSE_ENCODER, 1, 0);\r\nbreak;\r\ncase V4L2_ENC_CMD_RESUME:\r\nIVTV_DEBUG_IOCTL("V4L2_ENC_CMD_RESUME\n");\r\nenc->flags = 0;\r\nif (!atomic_read(&itv->capturing))\r\nreturn -EPERM;\r\nif (!test_and_clear_bit(IVTV_F_I_ENC_PAUSED, &itv->i_flags))\r\nreturn 0;\r\nivtv_vapi(itv, CX2341X_ENC_PAUSE_ENCODER, 1, 1);\r\nivtv_unmute(itv);\r\nbreak;\r\ndefault:\r\nIVTV_DEBUG_IOCTL("Unknown cmd %d\n", enc->cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ivtv_try_encoder_cmd(struct file *file, void *fh, struct v4l2_encoder_cmd *enc)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nswitch (enc->cmd) {\r\ncase V4L2_ENC_CMD_START:\r\nIVTV_DEBUG_IOCTL("V4L2_ENC_CMD_START\n");\r\nenc->flags = 0;\r\nreturn 0;\r\ncase V4L2_ENC_CMD_STOP:\r\nIVTV_DEBUG_IOCTL("V4L2_ENC_CMD_STOP\n");\r\nenc->flags &= V4L2_ENC_CMD_STOP_AT_GOP_END;\r\nreturn 0;\r\ncase V4L2_ENC_CMD_PAUSE:\r\nIVTV_DEBUG_IOCTL("V4L2_ENC_CMD_PAUSE\n");\r\nenc->flags = 0;\r\nreturn 0;\r\ncase V4L2_ENC_CMD_RESUME:\r\nIVTV_DEBUG_IOCTL("V4L2_ENC_CMD_RESUME\n");\r\nenc->flags = 0;\r\nreturn 0;\r\ndefault:\r\nIVTV_DEBUG_IOCTL("Unknown cmd %d\n", enc->cmd);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int ivtv_g_fbuf(struct file *file, void *fh, struct v4l2_framebuffer *fb)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nu32 data[CX2341X_MBOX_MAX_DATA];\r\nstruct yuv_playback_info *yi = &itv->yuv_info;\r\nint pixfmt;\r\nstatic u32 pixel_format[16] = {\r\nV4L2_PIX_FMT_PAL8,\r\nV4L2_PIX_FMT_RGB565,\r\nV4L2_PIX_FMT_RGB555,\r\nV4L2_PIX_FMT_RGB444,\r\nV4L2_PIX_FMT_RGB32,\r\n0,\r\n0,\r\n0,\r\nV4L2_PIX_FMT_PAL8,\r\nV4L2_PIX_FMT_YUV565,\r\nV4L2_PIX_FMT_YUV555,\r\nV4L2_PIX_FMT_YUV444,\r\nV4L2_PIX_FMT_YUV32,\r\n0,\r\n0,\r\n0,\r\n};\r\nif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT_OVERLAY))\r\nreturn -EINVAL;\r\nif (!itv->osd_video_pbase)\r\nreturn -EINVAL;\r\nfb->capability = V4L2_FBUF_CAP_EXTERNOVERLAY | V4L2_FBUF_CAP_CHROMAKEY |\r\nV4L2_FBUF_CAP_GLOBAL_ALPHA;\r\nivtv_vapi_result(itv, data, CX2341X_OSD_GET_STATE, 0);\r\ndata[0] |= (read_reg(0x2a00) >> 7) & 0x40;\r\npixfmt = (data[0] >> 3) & 0xf;\r\nfb->fmt.pixelformat = pixel_format[pixfmt];\r\nfb->fmt.width = itv->osd_rect.width;\r\nfb->fmt.height = itv->osd_rect.height;\r\nfb->fmt.field = V4L2_FIELD_INTERLACED;\r\nfb->fmt.bytesperline = fb->fmt.width;\r\nfb->fmt.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nfb->fmt.field = V4L2_FIELD_INTERLACED;\r\nfb->fmt.priv = 0;\r\nif (fb->fmt.pixelformat != V4L2_PIX_FMT_PAL8)\r\nfb->fmt.bytesperline *= 2;\r\nif (fb->fmt.pixelformat == V4L2_PIX_FMT_RGB32 ||\r\nfb->fmt.pixelformat == V4L2_PIX_FMT_YUV32)\r\nfb->fmt.bytesperline *= 2;\r\nfb->fmt.sizeimage = fb->fmt.bytesperline * fb->fmt.height;\r\nfb->base = (void *)itv->osd_video_pbase;\r\nfb->flags = 0;\r\nif (itv->osd_chroma_key_state)\r\nfb->flags |= V4L2_FBUF_FLAG_CHROMAKEY;\r\nif (itv->osd_global_alpha_state)\r\nfb->flags |= V4L2_FBUF_FLAG_GLOBAL_ALPHA;\r\nif (yi->track_osd)\r\nfb->flags |= V4L2_FBUF_FLAG_OVERLAY;\r\npixfmt &= 7;\r\nif (pixfmt == 1 || pixfmt > 4)\r\nreturn 0;\r\nif (pixfmt == 2 || pixfmt == 3)\r\nfb->capability |= V4L2_FBUF_CAP_LOCAL_INV_ALPHA;\r\nelse\r\nfb->capability |= V4L2_FBUF_CAP_LOCAL_ALPHA;\r\nif (itv->osd_local_alpha_state) {\r\nif (pixfmt == 2 || pixfmt == 3)\r\nfb->flags |= V4L2_FBUF_FLAG_LOCAL_INV_ALPHA;\r\nelse\r\nfb->flags |= V4L2_FBUF_FLAG_LOCAL_ALPHA;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ivtv_s_fbuf(struct file *file, void *fh, const struct v4l2_framebuffer *fb)\r\n{\r\nstruct ivtv_open_id *id = fh2id(fh);\r\nstruct ivtv *itv = id->itv;\r\nstruct yuv_playback_info *yi = &itv->yuv_info;\r\nif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT_OVERLAY))\r\nreturn -EINVAL;\r\nif (!itv->osd_video_pbase)\r\nreturn -EINVAL;\r\nitv->osd_global_alpha_state = (fb->flags & V4L2_FBUF_FLAG_GLOBAL_ALPHA) != 0;\r\nitv->osd_local_alpha_state =\r\n(fb->flags & (V4L2_FBUF_FLAG_LOCAL_ALPHA|V4L2_FBUF_FLAG_LOCAL_INV_ALPHA)) != 0;\r\nitv->osd_chroma_key_state = (fb->flags & V4L2_FBUF_FLAG_CHROMAKEY) != 0;\r\nivtv_set_osd_alpha(itv);\r\nyi->track_osd = (fb->flags & V4L2_FBUF_FLAG_OVERLAY) != 0;\r\nreturn 0;\r\n}\r\nstatic int ivtv_overlay(struct file *file, void *fh, unsigned int on)\r\n{\r\nstruct ivtv_open_id *id = fh2id(fh);\r\nstruct ivtv *itv = id->itv;\r\nif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT_OVERLAY))\r\nreturn -EINVAL;\r\nivtv_vapi(itv, CX2341X_OSD_SET_STATE, 1, on != 0);\r\nreturn 0;\r\n}\r\nstatic int ivtv_subscribe_event(struct v4l2_fh *fh, const struct v4l2_event_subscription *sub)\r\n{\r\nswitch (sub->type) {\r\ncase V4L2_EVENT_VSYNC:\r\ncase V4L2_EVENT_EOS:\r\nreturn v4l2_event_subscribe(fh, sub, 0, NULL);\r\ncase V4L2_EVENT_CTRL:\r\nreturn v4l2_event_subscribe(fh, sub, 0, &v4l2_ctrl_sub_ev_ops);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int ivtv_log_status(struct file *file, void *fh)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nu32 data[CX2341X_MBOX_MAX_DATA];\r\nint has_output = itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT;\r\nstruct v4l2_input vidin;\r\nstruct v4l2_audio audin;\r\nint i;\r\nIVTV_INFO("Version: %s Card: %s\n", IVTV_VERSION, itv->card_name);\r\nif (itv->hw_flags & IVTV_HW_TVEEPROM) {\r\nstruct tveeprom tv;\r\nivtv_read_eeprom(itv, &tv);\r\n}\r\nivtv_call_all(itv, core, log_status);\r\nivtv_get_input(itv, itv->active_input, &vidin);\r\nivtv_get_audio_input(itv, itv->audio_input, &audin);\r\nIVTV_INFO("Video Input: %s\n", vidin.name);\r\nIVTV_INFO("Audio Input: %s%s\n", audin.name,\r\n(itv->dualwatch_stereo_mode & ~0x300) == 0x200 ? " (Bilingual)" : "");\r\nif (has_output) {\r\nstruct v4l2_output vidout;\r\nstruct v4l2_audioout audout;\r\nint mode = itv->output_mode;\r\nstatic const char * const output_modes[5] = {\r\n"None",\r\n"MPEG Streaming",\r\n"YUV Streaming",\r\n"YUV Frames",\r\n"Passthrough",\r\n};\r\nstatic const char * const alpha_mode[4] = {\r\n"None",\r\n"Global",\r\n"Local",\r\n"Global and Local"\r\n};\r\nstatic const char * const pixel_format[16] = {\r\n"ARGB Indexed",\r\n"RGB 5:6:5",\r\n"ARGB 1:5:5:5",\r\n"ARGB 1:4:4:4",\r\n"ARGB 8:8:8:8",\r\n"5",\r\n"6",\r\n"7",\r\n"AYUV Indexed",\r\n"YUV 5:6:5",\r\n"AYUV 1:5:5:5",\r\n"AYUV 1:4:4:4",\r\n"AYUV 8:8:8:8",\r\n"13",\r\n"14",\r\n"15",\r\n};\r\nivtv_get_output(itv, itv->active_output, &vidout);\r\nivtv_get_audio_output(itv, 0, &audout);\r\nIVTV_INFO("Video Output: %s\n", vidout.name);\r\nif (mode < 0 || mode > OUT_PASSTHROUGH)\r\nmode = OUT_NONE;\r\nIVTV_INFO("Output Mode: %s\n", output_modes[mode]);\r\nivtv_vapi_result(itv, data, CX2341X_OSD_GET_STATE, 0);\r\ndata[0] |= (read_reg(0x2a00) >> 7) & 0x40;\r\nIVTV_INFO("Overlay: %s, Alpha: %s, Pixel Format: %s\n",\r\ndata[0] & 1 ? "On" : "Off",\r\nalpha_mode[(data[0] >> 1) & 0x3],\r\npixel_format[(data[0] >> 3) & 0xf]);\r\n}\r\nIVTV_INFO("Tuner: %s\n",\r\ntest_bit(IVTV_F_I_RADIO_USER, &itv->i_flags) ? "Radio" : "TV");\r\nv4l2_ctrl_handler_log_status(&itv->cxhdl.hdl, itv->v4l2_dev.name);\r\nIVTV_INFO("Status flags: 0x%08lx\n", itv->i_flags);\r\nfor (i = 0; i < IVTV_MAX_STREAMS; i++) {\r\nstruct ivtv_stream *s = &itv->streams[i];\r\nif (s->vdev == NULL || s->buffers == 0)\r\ncontinue;\r\nIVTV_INFO("Stream %s: status 0x%04lx, %d%% of %d KiB (%d buffers) in use\n", s->name, s->s_flags,\r\n(s->buffers - s->q_free.buffers) * 100 / s->buffers,\r\n(s->buffers * s->buf_size) / 1024, s->buffers);\r\n}\r\nIVTV_INFO("Read MPG/VBI: %lld/%lld bytes\n",\r\n(long long)itv->mpg_data_received,\r\n(long long)itv->vbi_data_inserted);\r\nreturn 0;\r\n}\r\nstatic int ivtv_decoder_cmd(struct file *file, void *fh, struct v4l2_decoder_cmd *dec)\r\n{\r\nstruct ivtv_open_id *id = fh2id(file->private_data);\r\nstruct ivtv *itv = id->itv;\r\nIVTV_DEBUG_IOCTL("VIDIOC_DECODER_CMD %d\n", dec->cmd);\r\nreturn ivtv_video_command(itv, id, dec, false);\r\n}\r\nstatic int ivtv_try_decoder_cmd(struct file *file, void *fh, struct v4l2_decoder_cmd *dec)\r\n{\r\nstruct ivtv_open_id *id = fh2id(file->private_data);\r\nstruct ivtv *itv = id->itv;\r\nIVTV_DEBUG_IOCTL("VIDIOC_TRY_DECODER_CMD %d\n", dec->cmd);\r\nreturn ivtv_video_command(itv, id, dec, true);\r\n}\r\nstatic int ivtv_decoder_ioctls(struct file *filp, unsigned int cmd, void *arg)\r\n{\r\nstruct ivtv_open_id *id = fh2id(filp->private_data);\r\nstruct ivtv *itv = id->itv;\r\nint nonblocking = filp->f_flags & O_NONBLOCK;\r\nstruct ivtv_stream *s = &itv->streams[id->type];\r\nunsigned long iarg = (unsigned long)arg;\r\nswitch (cmd) {\r\ncase IVTV_IOC_DMA_FRAME: {\r\nstruct ivtv_dma_frame *args = arg;\r\nIVTV_DEBUG_IOCTL("IVTV_IOC_DMA_FRAME\n");\r\nif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\r\nreturn -EINVAL;\r\nif (args->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn -EINVAL;\r\nif (itv->output_mode == OUT_UDMA_YUV && args->y_source == NULL)\r\nreturn 0;\r\nif (ivtv_start_decoding(id, id->type)) {\r\nreturn -EBUSY;\r\n}\r\nif (ivtv_set_output_mode(itv, OUT_UDMA_YUV) != OUT_UDMA_YUV) {\r\nivtv_release_stream(s);\r\nreturn -EBUSY;\r\n}\r\nid->yuv_frames = 1;\r\nif (args->y_source == NULL)\r\nreturn 0;\r\nreturn ivtv_yuv_prep_frame(itv, args);\r\n}\r\ncase IVTV_IOC_PASSTHROUGH_MODE:\r\nIVTV_DEBUG_IOCTL("IVTV_IOC_PASSTHROUGH_MODE\n");\r\nif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\r\nreturn -EINVAL;\r\nreturn ivtv_passthrough_mode(itv, *(int *)arg != 0);\r\ncase VIDEO_GET_PTS: {\r\ns64 *pts = arg;\r\ns64 frame;\r\nIVTV_DEBUG_IOCTL("VIDEO_GET_PTS\n");\r\nif (s->type < IVTV_DEC_STREAM_TYPE_MPG) {\r\n*pts = s->dma_pts;\r\nbreak;\r\n}\r\nif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\r\nreturn -EINVAL;\r\nreturn ivtv_g_pts_frame(itv, pts, &frame);\r\n}\r\ncase VIDEO_GET_FRAME_COUNT: {\r\ns64 *frame = arg;\r\ns64 pts;\r\nIVTV_DEBUG_IOCTL("VIDEO_GET_FRAME_COUNT\n");\r\nif (s->type < IVTV_DEC_STREAM_TYPE_MPG) {\r\n*frame = 0;\r\nbreak;\r\n}\r\nif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\r\nreturn -EINVAL;\r\nreturn ivtv_g_pts_frame(itv, &pts, frame);\r\n}\r\ncase VIDEO_PLAY: {\r\nstruct v4l2_decoder_cmd dc;\r\nIVTV_DEBUG_IOCTL("VIDEO_PLAY\n");\r\nmemset(&dc, 0, sizeof(dc));\r\ndc.cmd = V4L2_DEC_CMD_START;\r\nreturn ivtv_video_command(itv, id, &dc, 0);\r\n}\r\ncase VIDEO_STOP: {\r\nstruct v4l2_decoder_cmd dc;\r\nIVTV_DEBUG_IOCTL("VIDEO_STOP\n");\r\nmemset(&dc, 0, sizeof(dc));\r\ndc.cmd = V4L2_DEC_CMD_STOP;\r\ndc.flags = V4L2_DEC_CMD_STOP_TO_BLACK | V4L2_DEC_CMD_STOP_IMMEDIATELY;\r\nreturn ivtv_video_command(itv, id, &dc, 0);\r\n}\r\ncase VIDEO_FREEZE: {\r\nstruct v4l2_decoder_cmd dc;\r\nIVTV_DEBUG_IOCTL("VIDEO_FREEZE\n");\r\nmemset(&dc, 0, sizeof(dc));\r\ndc.cmd = V4L2_DEC_CMD_PAUSE;\r\nreturn ivtv_video_command(itv, id, &dc, 0);\r\n}\r\ncase VIDEO_CONTINUE: {\r\nstruct v4l2_decoder_cmd dc;\r\nIVTV_DEBUG_IOCTL("VIDEO_CONTINUE\n");\r\nmemset(&dc, 0, sizeof(dc));\r\ndc.cmd = V4L2_DEC_CMD_RESUME;\r\nreturn ivtv_video_command(itv, id, &dc, 0);\r\n}\r\ncase VIDEO_COMMAND:\r\ncase VIDEO_TRY_COMMAND: {\r\nstruct v4l2_decoder_cmd *dc = arg;\r\nint try = (cmd == VIDEO_TRY_COMMAND);\r\nif (try)\r\nIVTV_DEBUG_IOCTL("VIDEO_TRY_COMMAND %d\n", dc->cmd);\r\nelse\r\nIVTV_DEBUG_IOCTL("VIDEO_COMMAND %d\n", dc->cmd);\r\nreturn ivtv_video_command(itv, id, dc, try);\r\n}\r\ncase VIDEO_GET_EVENT: {\r\nstruct video_event *ev = arg;\r\nDEFINE_WAIT(wait);\r\nIVTV_DEBUG_IOCTL("VIDEO_GET_EVENT\n");\r\nif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\r\nreturn -EINVAL;\r\nmemset(ev, 0, sizeof(*ev));\r\nset_bit(IVTV_F_I_EV_VSYNC_ENABLED, &itv->i_flags);\r\nwhile (1) {\r\nif (test_and_clear_bit(IVTV_F_I_EV_DEC_STOPPED, &itv->i_flags))\r\nev->type = VIDEO_EVENT_DECODER_STOPPED;\r\nelse if (test_and_clear_bit(IVTV_F_I_EV_VSYNC, &itv->i_flags)) {\r\nev->type = VIDEO_EVENT_VSYNC;\r\nev->u.vsync_field = test_bit(IVTV_F_I_EV_VSYNC_FIELD, &itv->i_flags) ?\r\nVIDEO_VSYNC_FIELD_ODD : VIDEO_VSYNC_FIELD_EVEN;\r\nif (itv->output_mode == OUT_UDMA_YUV &&\r\n(itv->yuv_info.lace_mode & IVTV_YUV_MODE_MASK) ==\r\nIVTV_YUV_MODE_PROGRESSIVE) {\r\nev->u.vsync_field = VIDEO_VSYNC_FIELD_PROGRESSIVE;\r\n}\r\n}\r\nif (ev->type)\r\nreturn 0;\r\nif (nonblocking)\r\nreturn -EAGAIN;\r\nmutex_unlock(&itv->serialize_lock);\r\nprepare_to_wait(&itv->event_waitq, &wait, TASK_INTERRUPTIBLE);\r\nif (!test_bit(IVTV_F_I_EV_DEC_STOPPED, &itv->i_flags) &&\r\n!test_bit(IVTV_F_I_EV_VSYNC, &itv->i_flags))\r\nschedule();\r\nfinish_wait(&itv->event_waitq, &wait);\r\nmutex_lock(&itv->serialize_lock);\r\nif (signal_pending(current)) {\r\nIVTV_DEBUG_INFO("User stopped wait for event\n");\r\nreturn -EINTR;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase VIDEO_SELECT_SOURCE:\r\nIVTV_DEBUG_IOCTL("VIDEO_SELECT_SOURCE\n");\r\nif (!(itv->v4l2_cap & V4L2_CAP_VIDEO_OUTPUT))\r\nreturn -EINVAL;\r\nreturn ivtv_passthrough_mode(itv, iarg == VIDEO_SOURCE_DEMUX);\r\ncase AUDIO_SET_MUTE:\r\nIVTV_DEBUG_IOCTL("AUDIO_SET_MUTE\n");\r\nitv->speed_mute_audio = iarg;\r\nreturn 0;\r\ncase AUDIO_CHANNEL_SELECT:\r\nIVTV_DEBUG_IOCTL("AUDIO_CHANNEL_SELECT\n");\r\nif (iarg > AUDIO_STEREO_SWAPPED)\r\nreturn -EINVAL;\r\nreturn v4l2_ctrl_s_ctrl(itv->ctrl_audio_playback, iarg + 1);\r\ncase AUDIO_BILINGUAL_CHANNEL_SELECT:\r\nIVTV_DEBUG_IOCTL("AUDIO_BILINGUAL_CHANNEL_SELECT\n");\r\nif (iarg > AUDIO_STEREO_SWAPPED)\r\nreturn -EINVAL;\r\nreturn v4l2_ctrl_s_ctrl(itv->ctrl_audio_multilingual_playback, iarg + 1);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic long ivtv_default(struct file *file, void *fh, bool valid_prio,\r\nunsigned int cmd, void *arg)\r\n{\r\nstruct ivtv *itv = fh2id(fh)->itv;\r\nif (!valid_prio) {\r\nswitch (cmd) {\r\ncase IVTV_IOC_PASSTHROUGH_MODE:\r\ncase VIDEO_PLAY:\r\ncase VIDEO_STOP:\r\ncase VIDEO_FREEZE:\r\ncase VIDEO_CONTINUE:\r\ncase VIDEO_COMMAND:\r\ncase VIDEO_SELECT_SOURCE:\r\ncase AUDIO_SET_MUTE:\r\ncase AUDIO_CHANNEL_SELECT:\r\ncase AUDIO_BILINGUAL_CHANNEL_SELECT:\r\nreturn -EBUSY;\r\n}\r\n}\r\nswitch (cmd) {\r\ncase VIDIOC_INT_RESET: {\r\nu32 val = *(u32 *)arg;\r\nif ((val == 0 && itv->options.newi2c) || (val & 0x01))\r\nivtv_reset_ir_gpio(itv);\r\nif (val & 0x02)\r\nv4l2_subdev_call(itv->sd_video, core, reset, 0);\r\nbreak;\r\n}\r\ncase IVTV_IOC_DMA_FRAME:\r\ncase IVTV_IOC_PASSTHROUGH_MODE:\r\ncase VIDEO_GET_PTS:\r\ncase VIDEO_GET_FRAME_COUNT:\r\ncase VIDEO_GET_EVENT:\r\ncase VIDEO_PLAY:\r\ncase VIDEO_STOP:\r\ncase VIDEO_FREEZE:\r\ncase VIDEO_CONTINUE:\r\ncase VIDEO_COMMAND:\r\ncase VIDEO_TRY_COMMAND:\r\ncase VIDEO_SELECT_SOURCE:\r\ncase AUDIO_SET_MUTE:\r\ncase AUDIO_CHANNEL_SELECT:\r\ncase AUDIO_BILINGUAL_CHANNEL_SELECT:\r\nreturn ivtv_decoder_ioctls(file, cmd, (void *)arg);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nreturn 0;\r\n}\r\nvoid ivtv_set_funcs(struct video_device *vdev)\r\n{\r\nvdev->ioctl_ops = &ivtv_ioctl_ops;\r\n}
