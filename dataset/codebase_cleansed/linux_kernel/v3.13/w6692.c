static void\r\n_set_debug(struct w6692_hw *card)\r\n{\r\ncard->dch.debug = debug;\r\ncard->bc[0].bch.debug = debug;\r\ncard->bc[1].bch.debug = debug;\r\n}\r\nstatic int\r\nset_debug(const char *val, struct kernel_param *kp)\r\n{\r\nint ret;\r\nstruct w6692_hw *card;\r\nret = param_set_uint(val, kp);\r\nif (!ret) {\r\nread_lock(&card_lock);\r\nlist_for_each_entry(card, &Cards, list)\r\n_set_debug(card);\r\nread_unlock(&card_lock);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline u8\r\nReadW6692(struct w6692_hw *card, u8 offset)\r\n{\r\nreturn inb(card->addr + offset);\r\n}\r\nstatic inline void\r\nWriteW6692(struct w6692_hw *card, u8 offset, u8 value)\r\n{\r\noutb(value, card->addr + offset);\r\n}\r\nstatic inline u8\r\nReadW6692B(struct w6692_ch *bc, u8 offset)\r\n{\r\nreturn inb(bc->addr + offset);\r\n}\r\nstatic inline void\r\nWriteW6692B(struct w6692_ch *bc, u8 offset, u8 value)\r\n{\r\noutb(value, bc->addr + offset);\r\n}\r\nstatic void\r\nenable_hwirq(struct w6692_hw *card)\r\n{\r\nWriteW6692(card, W_IMASK, card->imask);\r\n}\r\nstatic void\r\ndisable_hwirq(struct w6692_hw *card)\r\n{\r\nWriteW6692(card, W_IMASK, 0xff);\r\n}\r\nstatic void\r\nW6692Version(struct w6692_hw *card)\r\n{\r\nint val;\r\nval = ReadW6692(card, W_D_RBCH);\r\npr_notice("%s: Winbond W6692 version: %s\n", card->name,\r\nW6692Ver[(val >> 6) & 3]);\r\n}\r\nstatic void\r\nw6692_led_handler(struct w6692_hw *card, int on)\r\n{\r\nif ((!(card->fmask & led)) || card->subtype == W6692_USR)\r\nreturn;\r\nif (on) {\r\ncard->xdata &= 0xfb;\r\nWriteW6692(card, W_XDATA, card->xdata);\r\n} else {\r\ncard->xdata |= 0x04;\r\nWriteW6692(card, W_XDATA, card->xdata);\r\n}\r\n}\r\nstatic void\r\nph_command(struct w6692_hw *card, u8 cmd)\r\n{\r\npr_debug("%s: ph_command %x\n", card->name, cmd);\r\nWriteW6692(card, W_CIX, cmd);\r\n}\r\nstatic void\r\nW6692_new_ph(struct w6692_hw *card)\r\n{\r\nif (card->state == W_L1CMD_RST)\r\nph_command(card, W_L1CMD_DRC);\r\nschedule_event(&card->dch, FLG_PHCHANGE);\r\n}\r\nstatic void\r\nW6692_ph_bh(struct dchannel *dch)\r\n{\r\nstruct w6692_hw *card = dch->hw;\r\nswitch (card->state) {\r\ncase W_L1CMD_RST:\r\ndch->state = 0;\r\nl1_event(dch->l1, HW_RESET_IND);\r\nbreak;\r\ncase W_L1IND_CD:\r\ndch->state = 3;\r\nl1_event(dch->l1, HW_DEACT_CNF);\r\nbreak;\r\ncase W_L1IND_DRD:\r\ndch->state = 3;\r\nl1_event(dch->l1, HW_DEACT_IND);\r\nbreak;\r\ncase W_L1IND_CE:\r\ndch->state = 4;\r\nl1_event(dch->l1, HW_POWERUP_IND);\r\nbreak;\r\ncase W_L1IND_LD:\r\nif (dch->state <= 5) {\r\ndch->state = 5;\r\nl1_event(dch->l1, ANYSIGNAL);\r\n} else {\r\ndch->state = 8;\r\nl1_event(dch->l1, LOSTFRAMING);\r\n}\r\nbreak;\r\ncase W_L1IND_ARD:\r\ndch->state = 6;\r\nl1_event(dch->l1, INFO2);\r\nbreak;\r\ncase W_L1IND_AI8:\r\ndch->state = 7;\r\nl1_event(dch->l1, INFO4_P8);\r\nbreak;\r\ncase W_L1IND_AI10:\r\ndch->state = 7;\r\nl1_event(dch->l1, INFO4_P10);\r\nbreak;\r\ndefault:\r\npr_debug("%s: TE unknown state %02x dch state %02x\n",\r\ncard->name, card->state, dch->state);\r\nbreak;\r\n}\r\npr_debug("%s: TE newstate %02x\n", card->name, dch->state);\r\n}\r\nstatic void\r\nW6692_empty_Dfifo(struct w6692_hw *card, int count)\r\n{\r\nstruct dchannel *dch = &card->dch;\r\nu8 *ptr;\r\npr_debug("%s: empty_Dfifo %d\n", card->name, count);\r\nif (!dch->rx_skb) {\r\ndch->rx_skb = mI_alloc_skb(card->dch.maxlen, GFP_ATOMIC);\r\nif (!dch->rx_skb) {\r\npr_info("%s: D receive out of memory\n", card->name);\r\nWriteW6692(card, W_D_CMDR, W_D_CMDR_RACK);\r\nreturn;\r\n}\r\n}\r\nif ((dch->rx_skb->len + count) >= dch->maxlen) {\r\npr_debug("%s: empty_Dfifo overrun %d\n", card->name,\r\ndch->rx_skb->len + count);\r\nWriteW6692(card, W_D_CMDR, W_D_CMDR_RACK);\r\nreturn;\r\n}\r\nptr = skb_put(dch->rx_skb, count);\r\ninsb(card->addr + W_D_RFIFO, ptr, count);\r\nWriteW6692(card, W_D_CMDR, W_D_CMDR_RACK);\r\nif (debug & DEBUG_HW_DFIFO) {\r\nsnprintf(card->log, 63, "D-recv %s %d ",\r\ncard->name, count);\r\nprint_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, ptr, count);\r\n}\r\n}\r\nstatic void\r\nW6692_fill_Dfifo(struct w6692_hw *card)\r\n{\r\nstruct dchannel *dch = &card->dch;\r\nint count;\r\nu8 *ptr;\r\nu8 cmd = W_D_CMDR_XMS;\r\npr_debug("%s: fill_Dfifo\n", card->name);\r\nif (!dch->tx_skb)\r\nreturn;\r\ncount = dch->tx_skb->len - dch->tx_idx;\r\nif (count <= 0)\r\nreturn;\r\nif (count > W_D_FIFO_THRESH)\r\ncount = W_D_FIFO_THRESH;\r\nelse\r\ncmd |= W_D_CMDR_XME;\r\nptr = dch->tx_skb->data + dch->tx_idx;\r\ndch->tx_idx += count;\r\noutsb(card->addr + W_D_XFIFO, ptr, count);\r\nWriteW6692(card, W_D_CMDR, cmd);\r\nif (test_and_set_bit(FLG_BUSY_TIMER, &dch->Flags)) {\r\npr_debug("%s: fill_Dfifo dbusytimer running\n", card->name);\r\ndel_timer(&dch->timer);\r\n}\r\ninit_timer(&dch->timer);\r\ndch->timer.expires = jiffies + ((DBUSY_TIMER_VALUE * HZ) / 1000);\r\nadd_timer(&dch->timer);\r\nif (debug & DEBUG_HW_DFIFO) {\r\nsnprintf(card->log, 63, "D-send %s %d ",\r\ncard->name, count);\r\nprint_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, ptr, count);\r\n}\r\n}\r\nstatic void\r\nd_retransmit(struct w6692_hw *card)\r\n{\r\nstruct dchannel *dch = &card->dch;\r\nif (test_and_clear_bit(FLG_BUSY_TIMER, &dch->Flags))\r\ndel_timer(&dch->timer);\r\n#ifdef FIXME\r\nif (test_and_clear_bit(FLG_L1_BUSY, &dch->Flags))\r\ndchannel_sched_event(dch, D_CLEARBUSY);\r\n#endif\r\nif (test_bit(FLG_TX_BUSY, &dch->Flags)) {\r\ndch->tx_idx = 0;\r\nW6692_fill_Dfifo(card);\r\n} else if (dch->tx_skb) {\r\npr_info("%s: %s without TX_BUSY\n", card->name, __func__);\r\ntest_and_set_bit(FLG_TX_BUSY, &dch->Flags);\r\ndch->tx_idx = 0;\r\nW6692_fill_Dfifo(card);\r\n} else {\r\npr_info("%s: XDU no TX_BUSY\n", card->name);\r\nif (get_next_dframe(dch))\r\nW6692_fill_Dfifo(card);\r\n}\r\n}\r\nstatic void\r\nhandle_rxD(struct w6692_hw *card) {\r\nu8 stat;\r\nint count;\r\nstat = ReadW6692(card, W_D_RSTA);\r\nif (stat & (W_D_RSTA_RDOV | W_D_RSTA_CRCE | W_D_RSTA_RMB)) {\r\nif (stat & W_D_RSTA_RDOV) {\r\npr_debug("%s: D-channel RDOV\n", card->name);\r\n#ifdef ERROR_STATISTIC\r\ncard->dch.err_rx++;\r\n#endif\r\n}\r\nif (stat & W_D_RSTA_CRCE) {\r\npr_debug("%s: D-channel CRC error\n", card->name);\r\n#ifdef ERROR_STATISTIC\r\ncard->dch.err_crc++;\r\n#endif\r\n}\r\nif (stat & W_D_RSTA_RMB) {\r\npr_debug("%s: D-channel ABORT\n", card->name);\r\n#ifdef ERROR_STATISTIC\r\ncard->dch.err_rx++;\r\n#endif\r\n}\r\nif (card->dch.rx_skb)\r\ndev_kfree_skb(card->dch.rx_skb);\r\ncard->dch.rx_skb = NULL;\r\nWriteW6692(card, W_D_CMDR, W_D_CMDR_RACK | W_D_CMDR_RRST);\r\n} else {\r\ncount = ReadW6692(card, W_D_RBCL) & (W_D_FIFO_THRESH - 1);\r\nif (count == 0)\r\ncount = W_D_FIFO_THRESH;\r\nW6692_empty_Dfifo(card, count);\r\nrecv_Dchannel(&card->dch);\r\n}\r\n}\r\nstatic void\r\nhandle_txD(struct w6692_hw *card) {\r\nif (test_and_clear_bit(FLG_BUSY_TIMER, &card->dch.Flags))\r\ndel_timer(&card->dch.timer);\r\nif (card->dch.tx_skb && card->dch.tx_idx < card->dch.tx_skb->len) {\r\nW6692_fill_Dfifo(card);\r\n} else {\r\nif (card->dch.tx_skb)\r\ndev_kfree_skb(card->dch.tx_skb);\r\nif (get_next_dframe(&card->dch))\r\nW6692_fill_Dfifo(card);\r\n}\r\n}\r\nstatic void\r\nhandle_statusD(struct w6692_hw *card)\r\n{\r\nstruct dchannel *dch = &card->dch;\r\nu8 exval, v1, cir;\r\nexval = ReadW6692(card, W_D_EXIR);\r\npr_debug("%s: D_EXIR %02x\n", card->name, exval);\r\nif (exval & (W_D_EXI_XDUN | W_D_EXI_XCOL)) {\r\npr_debug("%s: D-channel underrun/collision\n", card->name);\r\n#ifdef ERROR_STATISTIC\r\ndch->err_tx++;\r\n#endif\r\nd_retransmit(card);\r\n}\r\nif (exval & W_D_EXI_RDOV) {\r\npr_debug("%s: D-channel RDOV\n", card->name);\r\nWriteW6692(card, W_D_CMDR, W_D_CMDR_RRST);\r\n}\r\nif (exval & W_D_EXI_TIN2)\r\npr_debug("%s: spurious TIN2 interrupt\n", card->name);\r\nif (exval & W_D_EXI_MOC) {\r\nv1 = ReadW6692(card, W_MOSR);\r\npr_debug("%s: spurious MOC interrupt MOSR %02x\n",\r\ncard->name, v1);\r\n}\r\nif (exval & W_D_EXI_ISC) {\r\ncir = ReadW6692(card, W_CIR);\r\npr_debug("%s: ISC CIR %02X\n", card->name, cir);\r\nif (cir & W_CIR_ICC) {\r\nv1 = cir & W_CIR_COD_MASK;\r\npr_debug("%s: ph_state_change %x -> %x\n", card->name,\r\ndch->state, v1);\r\ncard->state = v1;\r\nif (card->fmask & led) {\r\nswitch (v1) {\r\ncase W_L1IND_AI8:\r\ncase W_L1IND_AI10:\r\nw6692_led_handler(card, 1);\r\nbreak;\r\ndefault:\r\nw6692_led_handler(card, 0);\r\nbreak;\r\n}\r\n}\r\nW6692_new_ph(card);\r\n}\r\nif (cir & W_CIR_SCC) {\r\nv1 = ReadW6692(card, W_SQR);\r\npr_debug("%s: SCC SQR %02X\n", card->name, v1);\r\n}\r\n}\r\nif (exval & W_D_EXI_WEXP)\r\npr_debug("%s: spurious WEXP interrupt!\n", card->name);\r\nif (exval & W_D_EXI_TEXP)\r\npr_debug("%s: spurious TEXP interrupt!\n", card->name);\r\n}\r\nstatic void\r\nW6692_empty_Bfifo(struct w6692_ch *wch, int count)\r\n{\r\nstruct w6692_hw *card = wch->bch.hw;\r\nu8 *ptr;\r\nint maxlen;\r\npr_debug("%s: empty_Bfifo %d\n", card->name, count);\r\nif (unlikely(wch->bch.state == ISDN_P_NONE)) {\r\npr_debug("%s: empty_Bfifo ISDN_P_NONE\n", card->name);\r\nWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RACK | W_B_CMDR_RACT);\r\nif (wch->bch.rx_skb)\r\nskb_trim(wch->bch.rx_skb, 0);\r\nreturn;\r\n}\r\nif (test_bit(FLG_RX_OFF, &wch->bch.Flags)) {\r\nwch->bch.dropcnt += count;\r\nWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RACK | W_B_CMDR_RACT);\r\nreturn;\r\n}\r\nmaxlen = bchannel_get_rxbuf(&wch->bch, count);\r\nif (maxlen < 0) {\r\nWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RACK | W_B_CMDR_RACT);\r\nif (wch->bch.rx_skb)\r\nskb_trim(wch->bch.rx_skb, 0);\r\npr_warning("%s.B%d: No bufferspace for %d bytes\n",\r\ncard->name, wch->bch.nr, count);\r\nreturn;\r\n}\r\nptr = skb_put(wch->bch.rx_skb, count);\r\ninsb(wch->addr + W_B_RFIFO, ptr, count);\r\nWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RACK | W_B_CMDR_RACT);\r\nif (debug & DEBUG_HW_DFIFO) {\r\nsnprintf(card->log, 63, "B%1d-recv %s %d ",\r\nwch->bch.nr, card->name, count);\r\nprint_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, ptr, count);\r\n}\r\n}\r\nstatic void\r\nW6692_fill_Bfifo(struct w6692_ch *wch)\r\n{\r\nstruct w6692_hw *card = wch->bch.hw;\r\nint count, fillempty = 0;\r\nu8 *ptr, cmd = W_B_CMDR_RACT | W_B_CMDR_XMS;\r\npr_debug("%s: fill Bfifo\n", card->name);\r\nif (!wch->bch.tx_skb) {\r\nif (!test_bit(FLG_TX_EMPTY, &wch->bch.Flags))\r\nreturn;\r\nptr = wch->bch.fill;\r\ncount = W_B_FIFO_THRESH;\r\nfillempty = 1;\r\n} else {\r\ncount = wch->bch.tx_skb->len - wch->bch.tx_idx;\r\nif (count <= 0)\r\nreturn;\r\nptr = wch->bch.tx_skb->data + wch->bch.tx_idx;\r\n}\r\nif (count > W_B_FIFO_THRESH)\r\ncount = W_B_FIFO_THRESH;\r\nelse if (test_bit(FLG_HDLC, &wch->bch.Flags))\r\ncmd |= W_B_CMDR_XME;\r\npr_debug("%s: fill Bfifo%d/%d\n", card->name,\r\ncount, wch->bch.tx_idx);\r\nwch->bch.tx_idx += count;\r\nif (fillempty) {\r\nwhile (count > 0) {\r\noutsb(wch->addr + W_B_XFIFO, ptr, MISDN_BCH_FILL_SIZE);\r\ncount -= MISDN_BCH_FILL_SIZE;\r\n}\r\n} else {\r\noutsb(wch->addr + W_B_XFIFO, ptr, count);\r\n}\r\nWriteW6692B(wch, W_B_CMDR, cmd);\r\nif ((debug & DEBUG_HW_BFIFO) && !fillempty) {\r\nsnprintf(card->log, 63, "B%1d-send %s %d ",\r\nwch->bch.nr, card->name, count);\r\nprint_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, ptr, count);\r\n}\r\n}\r\nstatic int\r\ndisable_pots(struct w6692_ch *wch)\r\n{\r\nstruct w6692_hw *card = wch->bch.hw;\r\nif (!(card->fmask & pots))\r\nreturn -ENODEV;\r\nwch->b_mode &= ~(W_B_MODE_EPCM | W_B_MODE_BSW0);\r\nWriteW6692B(wch, W_B_MODE, wch->b_mode);\r\nWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RRST | W_B_CMDR_RACT |\r\nW_B_CMDR_XRST);\r\nreturn 0;\r\n}\r\nstatic int\r\nw6692_mode(struct w6692_ch *wch, u32 pr)\r\n{\r\nstruct w6692_hw *card;\r\ncard = wch->bch.hw;\r\npr_debug("%s: B%d protocol %x-->%x\n", card->name,\r\nwch->bch.nr, wch->bch.state, pr);\r\nswitch (pr) {\r\ncase ISDN_P_NONE:\r\nif ((card->fmask & pots) && (wch->b_mode & W_B_MODE_EPCM))\r\ndisable_pots(wch);\r\nwch->b_mode = 0;\r\nmISDN_clear_bchannel(&wch->bch);\r\nWriteW6692B(wch, W_B_MODE, wch->b_mode);\r\nWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RRST | W_B_CMDR_XRST);\r\ntest_and_clear_bit(FLG_HDLC, &wch->bch.Flags);\r\ntest_and_clear_bit(FLG_TRANSPARENT, &wch->bch.Flags);\r\nbreak;\r\ncase ISDN_P_B_RAW:\r\nwch->b_mode = W_B_MODE_MMS;\r\nWriteW6692B(wch, W_B_MODE, wch->b_mode);\r\nWriteW6692B(wch, W_B_EXIM, 0);\r\nWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RRST | W_B_CMDR_RACT |\r\nW_B_CMDR_XRST);\r\ntest_and_set_bit(FLG_TRANSPARENT, &wch->bch.Flags);\r\nbreak;\r\ncase ISDN_P_B_HDLC:\r\nwch->b_mode = W_B_MODE_ITF;\r\nWriteW6692B(wch, W_B_MODE, wch->b_mode);\r\nWriteW6692B(wch, W_B_ADM1, 0xff);\r\nWriteW6692B(wch, W_B_ADM2, 0xff);\r\nWriteW6692B(wch, W_B_EXIM, 0);\r\nWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RRST | W_B_CMDR_RACT |\r\nW_B_CMDR_XRST);\r\ntest_and_set_bit(FLG_HDLC, &wch->bch.Flags);\r\nbreak;\r\ndefault:\r\npr_info("%s: protocol %x not known\n", card->name, pr);\r\nreturn -ENOPROTOOPT;\r\n}\r\nwch->bch.state = pr;\r\nreturn 0;\r\n}\r\nstatic void\r\nsend_next(struct w6692_ch *wch)\r\n{\r\nif (wch->bch.tx_skb && wch->bch.tx_idx < wch->bch.tx_skb->len) {\r\nW6692_fill_Bfifo(wch);\r\n} else {\r\nif (wch->bch.tx_skb)\r\ndev_kfree_skb(wch->bch.tx_skb);\r\nif (get_next_bframe(&wch->bch)) {\r\nW6692_fill_Bfifo(wch);\r\ntest_and_clear_bit(FLG_TX_EMPTY, &wch->bch.Flags);\r\n} else if (test_bit(FLG_TX_EMPTY, &wch->bch.Flags)) {\r\nW6692_fill_Bfifo(wch);\r\n}\r\n}\r\n}\r\nstatic void\r\nW6692B_interrupt(struct w6692_hw *card, int ch)\r\n{\r\nstruct w6692_ch *wch = &card->bc[ch];\r\nint count;\r\nu8 stat, star = 0;\r\nstat = ReadW6692B(wch, W_B_EXIR);\r\npr_debug("%s: B%d EXIR %02x\n", card->name, wch->bch.nr, stat);\r\nif (stat & W_B_EXI_RME) {\r\nstar = ReadW6692B(wch, W_B_STAR);\r\nif (star & (W_B_STAR_RDOV | W_B_STAR_CRCE | W_B_STAR_RMB)) {\r\nif ((star & W_B_STAR_RDOV) &&\r\ntest_bit(FLG_ACTIVE, &wch->bch.Flags)) {\r\npr_debug("%s: B%d RDOV proto=%x\n", card->name,\r\nwch->bch.nr, wch->bch.state);\r\n#ifdef ERROR_STATISTIC\r\nwch->bch.err_rdo++;\r\n#endif\r\n}\r\nif (test_bit(FLG_HDLC, &wch->bch.Flags)) {\r\nif (star & W_B_STAR_CRCE) {\r\npr_debug("%s: B%d CRC error\n",\r\ncard->name, wch->bch.nr);\r\n#ifdef ERROR_STATISTIC\r\nwch->bch.err_crc++;\r\n#endif\r\n}\r\nif (star & W_B_STAR_RMB) {\r\npr_debug("%s: B%d message abort\n",\r\ncard->name, wch->bch.nr);\r\n#ifdef ERROR_STATISTIC\r\nwch->bch.err_inv++;\r\n#endif\r\n}\r\n}\r\nWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RACK |\r\nW_B_CMDR_RRST | W_B_CMDR_RACT);\r\nif (wch->bch.rx_skb)\r\nskb_trim(wch->bch.rx_skb, 0);\r\n} else {\r\ncount = ReadW6692B(wch, W_B_RBCL) &\r\n(W_B_FIFO_THRESH - 1);\r\nif (count == 0)\r\ncount = W_B_FIFO_THRESH;\r\nW6692_empty_Bfifo(wch, count);\r\nrecv_Bchannel(&wch->bch, 0, false);\r\n}\r\n}\r\nif (stat & W_B_EXI_RMR) {\r\nif (!(stat & W_B_EXI_RME))\r\nstar = ReadW6692B(wch, W_B_STAR);\r\nif (star & W_B_STAR_RDOV) {\r\npr_debug("%s: B%d RDOV proto=%x\n", card->name,\r\nwch->bch.nr, wch->bch.state);\r\n#ifdef ERROR_STATISTIC\r\nwch->bch.err_rdo++;\r\n#endif\r\nWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RACK |\r\nW_B_CMDR_RRST | W_B_CMDR_RACT);\r\n} else {\r\nW6692_empty_Bfifo(wch, W_B_FIFO_THRESH);\r\nif (test_bit(FLG_TRANSPARENT, &wch->bch.Flags))\r\nrecv_Bchannel(&wch->bch, 0, false);\r\n}\r\n}\r\nif (stat & W_B_EXI_RDOV) {\r\nif (!(star & W_B_STAR_RDOV)) {\r\npr_debug("%s: B%d RDOV IRQ proto=%x\n", card->name,\r\nwch->bch.nr, wch->bch.state);\r\n#ifdef ERROR_STATISTIC\r\nwch->bch.err_rdo++;\r\n#endif\r\nWriteW6692B(wch, W_B_CMDR, W_B_CMDR_RACK |\r\nW_B_CMDR_RRST | W_B_CMDR_RACT);\r\n}\r\n}\r\nif (stat & W_B_EXI_XFR) {\r\nif (!(stat & (W_B_EXI_RME | W_B_EXI_RMR))) {\r\nstar = ReadW6692B(wch, W_B_STAR);\r\npr_debug("%s: B%d star %02x\n", card->name,\r\nwch->bch.nr, star);\r\n}\r\nif (star & W_B_STAR_XDOW) {\r\npr_warning("%s: B%d XDOW proto=%x\n", card->name,\r\nwch->bch.nr, wch->bch.state);\r\n#ifdef ERROR_STATISTIC\r\nwch->bch.err_xdu++;\r\n#endif\r\nWriteW6692B(wch, W_B_CMDR, W_B_CMDR_XRST |\r\nW_B_CMDR_RACT);\r\nif (wch->bch.tx_skb) {\r\nif (!test_bit(FLG_TRANSPARENT, &wch->bch.Flags))\r\nwch->bch.tx_idx = 0;\r\n}\r\n}\r\nsend_next(wch);\r\nif (star & W_B_STAR_XDOW)\r\nreturn;\r\n}\r\nif (stat & W_B_EXI_XDUN) {\r\npr_warning("%s: B%d XDUN proto=%x\n", card->name,\r\nwch->bch.nr, wch->bch.state);\r\n#ifdef ERROR_STATISTIC\r\nwch->bch.err_xdu++;\r\n#endif\r\nif (wch->bch.tx_skb) {\r\nif (!test_bit(FLG_TRANSPARENT, &wch->bch.Flags))\r\nwch->bch.tx_idx = 0;\r\n} else if (test_bit(FLG_FILLEMPTY, &wch->bch.Flags)) {\r\ntest_and_set_bit(FLG_TX_EMPTY, &wch->bch.Flags);\r\n}\r\nsend_next(wch);\r\n}\r\n}\r\nstatic irqreturn_t\r\nw6692_irq(int intno, void *dev_id)\r\n{\r\nstruct w6692_hw *card = dev_id;\r\nu8 ista;\r\nspin_lock(&card->lock);\r\nista = ReadW6692(card, W_ISTA);\r\nif ((ista | card->imask) == card->imask) {\r\nspin_unlock(&card->lock);\r\nreturn IRQ_NONE;\r\n}\r\ncard->irqcnt++;\r\npr_debug("%s: ista %02x\n", card->name, ista);\r\nista &= ~card->imask;\r\nif (ista & W_INT_B1_EXI)\r\nW6692B_interrupt(card, 0);\r\nif (ista & W_INT_B2_EXI)\r\nW6692B_interrupt(card, 1);\r\nif (ista & W_INT_D_RME)\r\nhandle_rxD(card);\r\nif (ista & W_INT_D_RMR)\r\nW6692_empty_Dfifo(card, W_D_FIFO_THRESH);\r\nif (ista & W_INT_D_XFR)\r\nhandle_txD(card);\r\nif (ista & W_INT_D_EXI)\r\nhandle_statusD(card);\r\nif (ista & (W_INT_XINT0 | W_INT_XINT1))\r\npr_debug("%s: W6692 spurious XINT!\n", card->name);\r\nspin_unlock(&card->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\ndbusy_timer_handler(struct dchannel *dch)\r\n{\r\nstruct w6692_hw *card = dch->hw;\r\nint rbch, star;\r\nu_long flags;\r\nif (test_bit(FLG_BUSY_TIMER, &dch->Flags)) {\r\nspin_lock_irqsave(&card->lock, flags);\r\nrbch = ReadW6692(card, W_D_RBCH);\r\nstar = ReadW6692(card, W_D_STAR);\r\npr_debug("%s: D-Channel Busy RBCH %02x STAR %02x\n",\r\ncard->name, rbch, star);\r\nif (star & W_D_STAR_XBZ)\r\ntest_and_set_bit(FLG_L1_BUSY, &dch->Flags);\r\nelse {\r\ntest_and_clear_bit(FLG_BUSY_TIMER, &dch->Flags);\r\nif (dch->tx_idx)\r\ndch->tx_idx = 0;\r\nelse\r\npr_info("%s: W6692 D-Channel Busy no tx_idx\n",\r\ncard->name);\r\nWriteW6692(card, W_D_CMDR, W_D_CMDR_XRST);\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\n}\r\nvoid initW6692(struct w6692_hw *card)\r\n{\r\nu8 val;\r\ncard->dch.timer.function = (void *)dbusy_timer_handler;\r\ncard->dch.timer.data = (u_long)&card->dch;\r\ninit_timer(&card->dch.timer);\r\nw6692_mode(&card->bc[0], ISDN_P_NONE);\r\nw6692_mode(&card->bc[1], ISDN_P_NONE);\r\nWriteW6692(card, W_D_CTL, 0x00);\r\ndisable_hwirq(card);\r\nWriteW6692(card, W_D_SAM, 0xff);\r\nWriteW6692(card, W_D_TAM, 0xff);\r\nWriteW6692(card, W_D_MODE, W_D_MODE_RACT);\r\ncard->state = W_L1CMD_RST;\r\nph_command(card, W_L1CMD_RST);\r\nph_command(card, W_L1CMD_ECK);\r\ncard->imask = 0x18;\r\nWriteW6692(card, W_D_EXIM, 0x00);\r\nWriteW6692B(&card->bc[0], W_B_EXIM, 0);\r\nWriteW6692B(&card->bc[1], W_B_EXIM, 0);\r\nWriteW6692(card, W_D_CMDR, W_D_CMDR_RRST | W_D_CMDR_XRST);\r\nWriteW6692B(&card->bc[0], W_B_CMDR, W_B_CMDR_RRST | W_B_CMDR_XRST);\r\nWriteW6692B(&card->bc[1], W_B_CMDR, W_B_CMDR_RRST | W_B_CMDR_XRST);\r\nif (card->subtype == W6692_USR) {\r\ncard->pctl = 0x80;\r\ncard->xdata = 0;\r\nWriteW6692(card, W_PCTL, card->pctl);\r\nWriteW6692(card, W_XDATA, card->xdata);\r\n} else {\r\ncard->pctl = W_PCTL_OE5 | W_PCTL_OE4 | W_PCTL_OE2 |\r\nW_PCTL_OE1 | W_PCTL_OE0;\r\ncard->xaddr = 0x00;\r\nif (card->fmask & pots)\r\ncard->xdata |= 0x06;\r\nif (card->fmask & led)\r\ncard->xdata |= 0x04;\r\nif ((card->fmask & pots) || (card->fmask & led)) {\r\nWriteW6692(card, W_PCTL, card->pctl);\r\nWriteW6692(card, W_XADDR, card->xaddr);\r\nWriteW6692(card, W_XDATA, card->xdata);\r\nval = ReadW6692(card, W_XADDR);\r\nif (debug & DEBUG_HW)\r\npr_notice("%s: W_XADDR=%02x\n",\r\ncard->name, val);\r\n}\r\n}\r\n}\r\nstatic void\r\nreset_w6692(struct w6692_hw *card)\r\n{\r\nWriteW6692(card, W_D_CTL, W_D_CTL_SRST);\r\nmdelay(10);\r\nWriteW6692(card, W_D_CTL, 0);\r\n}\r\nstatic int\r\ninit_card(struct w6692_hw *card)\r\n{\r\nint cnt = 3;\r\nu_long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\ndisable_hwirq(card);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nif (request_irq(card->irq, w6692_irq, IRQF_SHARED, card->name, card)) {\r\npr_info("%s: couldn't get interrupt %d\n", card->name,\r\ncard->irq);\r\nreturn -EIO;\r\n}\r\nwhile (cnt--) {\r\nspin_lock_irqsave(&card->lock, flags);\r\ninitW6692(card);\r\nenable_hwirq(card);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nmsleep_interruptible(10);\r\nif (debug & DEBUG_HW)\r\npr_notice("%s: IRQ %d count %d\n", card->name,\r\ncard->irq, card->irqcnt);\r\nif (!card->irqcnt) {\r\npr_info("%s: IRQ(%d) getting no IRQs during init %d\n",\r\ncard->name, card->irq, 3 - cnt);\r\nreset_w6692(card);\r\n} else\r\nreturn 0;\r\n}\r\nfree_irq(card->irq, card);\r\nreturn -EIO;\r\n}\r\nstatic int\r\nw6692_l2l1B(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nstruct bchannel *bch = container_of(ch, struct bchannel, ch);\r\nstruct w6692_ch *bc = container_of(bch, struct w6692_ch, bch);\r\nstruct w6692_hw *card = bch->hw;\r\nint ret = -EINVAL;\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nunsigned long flags;\r\nswitch (hh->prim) {\r\ncase PH_DATA_REQ:\r\nspin_lock_irqsave(&card->lock, flags);\r\nret = bchannel_senddata(bch, skb);\r\nif (ret > 0) {\r\nret = 0;\r\nW6692_fill_Bfifo(bc);\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nreturn ret;\r\ncase PH_ACTIVATE_REQ:\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (!test_and_set_bit(FLG_ACTIVE, &bch->Flags))\r\nret = w6692_mode(bc, ch->protocol);\r\nelse\r\nret = 0;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nif (!ret)\r\n_queue_data(ch, PH_ACTIVATE_IND, MISDN_ID_ANY, 0,\r\nNULL, GFP_KERNEL);\r\nbreak;\r\ncase PH_DEACTIVATE_REQ:\r\nspin_lock_irqsave(&card->lock, flags);\r\nmISDN_clear_bchannel(bch);\r\nw6692_mode(bc, ISDN_P_NONE);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n_queue_data(ch, PH_DEACTIVATE_IND, MISDN_ID_ANY, 0,\r\nNULL, GFP_KERNEL);\r\nret = 0;\r\nbreak;\r\ndefault:\r\npr_info("%s: %s unknown prim(%x,%x)\n",\r\ncard->name, __func__, hh->prim, hh->id);\r\nret = -EINVAL;\r\n}\r\nif (!ret)\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int\r\nchannel_bctrl(struct bchannel *bch, struct mISDN_ctrl_req *cq)\r\n{\r\nreturn mISDN_ctrl_bchannel(bch, cq);\r\n}\r\nstatic int\r\nopen_bchannel(struct w6692_hw *card, struct channel_req *rq)\r\n{\r\nstruct bchannel *bch;\r\nif (rq->adr.channel == 0 || rq->adr.channel > 2)\r\nreturn -EINVAL;\r\nif (rq->protocol == ISDN_P_NONE)\r\nreturn -EINVAL;\r\nbch = &card->bc[rq->adr.channel - 1].bch;\r\nif (test_and_set_bit(FLG_OPEN, &bch->Flags))\r\nreturn -EBUSY;\r\nbch->ch.protocol = rq->protocol;\r\nrq->ch = &bch->ch;\r\nreturn 0;\r\n}\r\nstatic int\r\nchannel_ctrl(struct w6692_hw *card, struct mISDN_ctrl_req *cq)\r\n{\r\nint ret = 0;\r\nswitch (cq->op) {\r\ncase MISDN_CTRL_GETOP:\r\ncq->op = MISDN_CTRL_L1_TIMER3;\r\nbreak;\r\ncase MISDN_CTRL_L1_TIMER3:\r\nret = l1_event(card->dch.l1, HW_TIMER3_VALUE | (cq->p1 & 0xff));\r\nbreak;\r\ndefault:\r\npr_info("%s: unknown CTRL OP %x\n", card->name, cq->op);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nw6692_bctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\r\n{\r\nstruct bchannel *bch = container_of(ch, struct bchannel, ch);\r\nstruct w6692_ch *bc = container_of(bch, struct w6692_ch, bch);\r\nstruct w6692_hw *card = bch->hw;\r\nint ret = -EINVAL;\r\nu_long flags;\r\npr_debug("%s: %s cmd:%x %p\n", card->name, __func__, cmd, arg);\r\nswitch (cmd) {\r\ncase CLOSE_CHANNEL:\r\ntest_and_clear_bit(FLG_OPEN, &bch->Flags);\r\ncancel_work_sync(&bch->workq);\r\nspin_lock_irqsave(&card->lock, flags);\r\nmISDN_clear_bchannel(bch);\r\nw6692_mode(bc, ISDN_P_NONE);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nch->protocol = ISDN_P_NONE;\r\nch->peer = NULL;\r\nmodule_put(THIS_MODULE);\r\nret = 0;\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nret = channel_bctrl(bch, arg);\r\nbreak;\r\ndefault:\r\npr_info("%s: %s unknown prim(%x)\n",\r\ncard->name, __func__, cmd);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nw6692_l2l1D(struct mISDNchannel *ch, struct sk_buff *skb)\r\n{\r\nstruct mISDNdevice *dev = container_of(ch, struct mISDNdevice, D);\r\nstruct dchannel *dch = container_of(dev, struct dchannel, dev);\r\nstruct w6692_hw *card = container_of(dch, struct w6692_hw, dch);\r\nint ret = -EINVAL;\r\nstruct mISDNhead *hh = mISDN_HEAD_P(skb);\r\nu32 id;\r\nu_long flags;\r\nswitch (hh->prim) {\r\ncase PH_DATA_REQ:\r\nspin_lock_irqsave(&card->lock, flags);\r\nret = dchannel_senddata(dch, skb);\r\nif (ret > 0) {\r\nid = hh->id;\r\nW6692_fill_Dfifo(card);\r\nret = 0;\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nqueue_ch_frame(ch, PH_DATA_CNF, id, NULL);\r\n} else\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nreturn ret;\r\ncase PH_ACTIVATE_REQ:\r\nret = l1_event(dch->l1, hh->prim);\r\nbreak;\r\ncase PH_DEACTIVATE_REQ:\r\ntest_and_clear_bit(FLG_L2_ACTIVATED, &dch->Flags);\r\nret = l1_event(dch->l1, hh->prim);\r\nbreak;\r\n}\r\nif (!ret)\r\ndev_kfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int\r\nw6692_l1callback(struct dchannel *dch, u32 cmd)\r\n{\r\nstruct w6692_hw *card = container_of(dch, struct w6692_hw, dch);\r\nu_long flags;\r\npr_debug("%s: cmd(%x) state(%02x)\n", card->name, cmd, card->state);\r\nswitch (cmd) {\r\ncase INFO3_P8:\r\nspin_lock_irqsave(&card->lock, flags);\r\nph_command(card, W_L1CMD_AR8);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nbreak;\r\ncase INFO3_P10:\r\nspin_lock_irqsave(&card->lock, flags);\r\nph_command(card, W_L1CMD_AR10);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nbreak;\r\ncase HW_RESET_REQ:\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (card->state != W_L1IND_DRD)\r\nph_command(card, W_L1CMD_RST);\r\nph_command(card, W_L1CMD_ECK);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nbreak;\r\ncase HW_DEACT_REQ:\r\nskb_queue_purge(&dch->squeue);\r\nif (dch->tx_skb) {\r\ndev_kfree_skb(dch->tx_skb);\r\ndch->tx_skb = NULL;\r\n}\r\ndch->tx_idx = 0;\r\nif (dch->rx_skb) {\r\ndev_kfree_skb(dch->rx_skb);\r\ndch->rx_skb = NULL;\r\n}\r\ntest_and_clear_bit(FLG_TX_BUSY, &dch->Flags);\r\nif (test_and_clear_bit(FLG_BUSY_TIMER, &dch->Flags))\r\ndel_timer(&dch->timer);\r\nbreak;\r\ncase HW_POWERUP_REQ:\r\nspin_lock_irqsave(&card->lock, flags);\r\nph_command(card, W_L1CMD_ECK);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nbreak;\r\ncase PH_ACTIVATE_IND:\r\ntest_and_set_bit(FLG_ACTIVE, &dch->Flags);\r\n_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\r\nGFP_ATOMIC);\r\nbreak;\r\ncase PH_DEACTIVATE_IND:\r\ntest_and_clear_bit(FLG_ACTIVE, &dch->Flags);\r\n_queue_data(&dch->dev.D, cmd, MISDN_ID_ANY, 0, NULL,\r\nGFP_ATOMIC);\r\nbreak;\r\ndefault:\r\npr_debug("%s: %s unknown command %x\n", card->name,\r\n__func__, cmd);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nopen_dchannel(struct w6692_hw *card, struct channel_req *rq)\r\n{\r\npr_debug("%s: %s dev(%d) open from %p\n", card->name, __func__,\r\ncard->dch.dev.id, __builtin_return_address(1));\r\nif (rq->protocol != ISDN_P_TE_S0)\r\nreturn -EINVAL;\r\nif (rq->adr.channel == 1)\r\nreturn -EINVAL;\r\nrq->ch = &card->dch.dev.D;\r\nrq->ch->protocol = rq->protocol;\r\nif (card->dch.state == 7)\r\n_queue_data(rq->ch, PH_ACTIVATE_IND, MISDN_ID_ANY,\r\n0, NULL, GFP_KERNEL);\r\nreturn 0;\r\n}\r\nstatic int\r\nw6692_dctrl(struct mISDNchannel *ch, u32 cmd, void *arg)\r\n{\r\nstruct mISDNdevice *dev = container_of(ch, struct mISDNdevice, D);\r\nstruct dchannel *dch = container_of(dev, struct dchannel, dev);\r\nstruct w6692_hw *card = container_of(dch, struct w6692_hw, dch);\r\nstruct channel_req *rq;\r\nint err = 0;\r\npr_debug("%s: DCTRL: %x %p\n", card->name, cmd, arg);\r\nswitch (cmd) {\r\ncase OPEN_CHANNEL:\r\nrq = arg;\r\nif (rq->protocol == ISDN_P_TE_S0)\r\nerr = open_dchannel(card, rq);\r\nelse\r\nerr = open_bchannel(card, rq);\r\nif (err)\r\nbreak;\r\nif (!try_module_get(THIS_MODULE))\r\npr_info("%s: cannot get module\n", card->name);\r\nbreak;\r\ncase CLOSE_CHANNEL:\r\npr_debug("%s: dev(%d) close from %p\n", card->name,\r\ndch->dev.id, __builtin_return_address(0));\r\nmodule_put(THIS_MODULE);\r\nbreak;\r\ncase CONTROL_CHANNEL:\r\nerr = channel_ctrl(card, arg);\r\nbreak;\r\ndefault:\r\npr_debug("%s: unknown DCTRL command %x\n", card->name, cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int\r\nsetup_w6692(struct w6692_hw *card)\r\n{\r\nu32 val;\r\nif (!request_region(card->addr, 256, card->name)) {\r\npr_info("%s: config port %x-%x already in use\n", card->name,\r\ncard->addr, card->addr + 255);\r\nreturn -EIO;\r\n}\r\nW6692Version(card);\r\ncard->bc[0].addr = card->addr;\r\ncard->bc[1].addr = card->addr + 0x40;\r\nval = ReadW6692(card, W_ISTA);\r\nif (debug & DEBUG_HW)\r\npr_notice("%s ISTA=%02x\n", card->name, val);\r\nval = ReadW6692(card, W_IMASK);\r\nif (debug & DEBUG_HW)\r\npr_notice("%s IMASK=%02x\n", card->name, val);\r\nval = ReadW6692(card, W_D_EXIR);\r\nif (debug & DEBUG_HW)\r\npr_notice("%s D_EXIR=%02x\n", card->name, val);\r\nval = ReadW6692(card, W_D_EXIM);\r\nif (debug & DEBUG_HW)\r\npr_notice("%s D_EXIM=%02x\n", card->name, val);\r\nval = ReadW6692(card, W_D_RSTA);\r\nif (debug & DEBUG_HW)\r\npr_notice("%s D_RSTA=%02x\n", card->name, val);\r\nreturn 0;\r\n}\r\nstatic void\r\nrelease_card(struct w6692_hw *card)\r\n{\r\nu_long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\ndisable_hwirq(card);\r\nw6692_mode(&card->bc[0], ISDN_P_NONE);\r\nw6692_mode(&card->bc[1], ISDN_P_NONE);\r\nif ((card->fmask & led) || card->subtype == W6692_USR) {\r\ncard->xdata |= 0x04;\r\nWriteW6692(card, W_XDATA, card->xdata);\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nfree_irq(card->irq, card);\r\nl1_event(card->dch.l1, CLOSE_CHANNEL);\r\nmISDN_unregister_device(&card->dch.dev);\r\nrelease_region(card->addr, 256);\r\nmISDN_freebchannel(&card->bc[1].bch);\r\nmISDN_freebchannel(&card->bc[0].bch);\r\nmISDN_freedchannel(&card->dch);\r\nwrite_lock_irqsave(&card_lock, flags);\r\nlist_del(&card->list);\r\nwrite_unlock_irqrestore(&card_lock, flags);\r\npci_disable_device(card->pdev);\r\npci_set_drvdata(card->pdev, NULL);\r\nkfree(card);\r\n}\r\nstatic int\r\nsetup_instance(struct w6692_hw *card)\r\n{\r\nint i, err;\r\nu_long flags;\r\nsnprintf(card->name, MISDN_MAX_IDLEN - 1, "w6692.%d", w6692_cnt + 1);\r\nwrite_lock_irqsave(&card_lock, flags);\r\nlist_add_tail(&card->list, &Cards);\r\nwrite_unlock_irqrestore(&card_lock, flags);\r\ncard->fmask = (1 << w6692_cnt);\r\n_set_debug(card);\r\nspin_lock_init(&card->lock);\r\nmISDN_initdchannel(&card->dch, MAX_DFRAME_LEN_L1, W6692_ph_bh);\r\ncard->dch.dev.Dprotocols = (1 << ISDN_P_TE_S0);\r\ncard->dch.dev.D.send = w6692_l2l1D;\r\ncard->dch.dev.D.ctrl = w6692_dctrl;\r\ncard->dch.dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |\r\n(1 << (ISDN_P_B_HDLC & ISDN_P_B_MASK));\r\ncard->dch.hw = card;\r\ncard->dch.dev.nrbchan = 2;\r\nfor (i = 0; i < 2; i++) {\r\nmISDN_initbchannel(&card->bc[i].bch, MAX_DATA_MEM,\r\nW_B_FIFO_THRESH);\r\ncard->bc[i].bch.hw = card;\r\ncard->bc[i].bch.nr = i + 1;\r\ncard->bc[i].bch.ch.nr = i + 1;\r\ncard->bc[i].bch.ch.send = w6692_l2l1B;\r\ncard->bc[i].bch.ch.ctrl = w6692_bctrl;\r\nset_channelmap(i + 1, card->dch.dev.channelmap);\r\nlist_add(&card->bc[i].bch.ch.list, &card->dch.dev.bchannels);\r\n}\r\nerr = setup_w6692(card);\r\nif (err)\r\ngoto error_setup;\r\nerr = mISDN_register_device(&card->dch.dev, &card->pdev->dev,\r\ncard->name);\r\nif (err)\r\ngoto error_reg;\r\nerr = init_card(card);\r\nif (err)\r\ngoto error_init;\r\nerr = create_l1(&card->dch, w6692_l1callback);\r\nif (!err) {\r\nw6692_cnt++;\r\npr_notice("W6692 %d cards installed\n", w6692_cnt);\r\nreturn 0;\r\n}\r\nfree_irq(card->irq, card);\r\nerror_init:\r\nmISDN_unregister_device(&card->dch.dev);\r\nerror_reg:\r\nrelease_region(card->addr, 256);\r\nerror_setup:\r\nmISDN_freebchannel(&card->bc[1].bch);\r\nmISDN_freebchannel(&card->bc[0].bch);\r\nmISDN_freedchannel(&card->dch);\r\nwrite_lock_irqsave(&card_lock, flags);\r\nlist_del(&card->list);\r\nwrite_unlock_irqrestore(&card_lock, flags);\r\nkfree(card);\r\nreturn err;\r\n}\r\nstatic int\r\nw6692_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint err = -ENOMEM;\r\nstruct w6692_hw *card;\r\nstruct w6692map *m = (struct w6692map *)ent->driver_data;\r\ncard = kzalloc(sizeof(struct w6692_hw), GFP_KERNEL);\r\nif (!card) {\r\npr_info("No kmem for w6692 card\n");\r\nreturn err;\r\n}\r\ncard->pdev = pdev;\r\ncard->subtype = m->subtype;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\nkfree(card);\r\nreturn err;\r\n}\r\nprintk(KERN_INFO "mISDN_w6692: found adapter %s at %s\n",\r\nm->name, pci_name(pdev));\r\ncard->addr = pci_resource_start(pdev, 1);\r\ncard->irq = pdev->irq;\r\npci_set_drvdata(pdev, card);\r\nerr = setup_instance(card);\r\nif (err)\r\npci_set_drvdata(pdev, NULL);\r\nreturn err;\r\n}\r\nstatic void\r\nw6692_remove_pci(struct pci_dev *pdev)\r\n{\r\nstruct w6692_hw *card = pci_get_drvdata(pdev);\r\nif (card)\r\nrelease_card(card);\r\nelse\r\nif (debug)\r\npr_notice("%s: drvdata already removed\n", __func__);\r\n}\r\nstatic int __init w6692_init(void)\r\n{\r\nint err;\r\npr_notice("Winbond W6692 PCI driver Rev. %s\n", W6692_REV);\r\nerr = pci_register_driver(&w6692_driver);\r\nreturn err;\r\n}\r\nstatic void __exit w6692_cleanup(void)\r\n{\r\npci_unregister_driver(&w6692_driver);\r\n}
