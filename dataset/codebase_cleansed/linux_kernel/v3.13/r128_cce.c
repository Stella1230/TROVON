static int R128_READ_PLL(struct drm_device *dev, int addr)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nR128_WRITE8(R128_CLOCK_CNTL_INDEX, addr & 0x1f);\r\nreturn R128_READ(R128_CLOCK_CNTL_DATA);\r\n}\r\nstatic void r128_status(drm_r128_private_t *dev_priv)\r\n{\r\nprintk("GUI_STAT = 0x%08x\n",\r\n(unsigned int)R128_READ(R128_GUI_STAT));\r\nprintk("PM4_STAT = 0x%08x\n",\r\n(unsigned int)R128_READ(R128_PM4_STAT));\r\nprintk("PM4_BUFFER_DL_WPTR = 0x%08x\n",\r\n(unsigned int)R128_READ(R128_PM4_BUFFER_DL_WPTR));\r\nprintk("PM4_BUFFER_DL_RPTR = 0x%08x\n",\r\n(unsigned int)R128_READ(R128_PM4_BUFFER_DL_RPTR));\r\nprintk("PM4_MICRO_CNTL = 0x%08x\n",\r\n(unsigned int)R128_READ(R128_PM4_MICRO_CNTL));\r\nprintk("PM4_BUFFER_CNTL = 0x%08x\n",\r\n(unsigned int)R128_READ(R128_PM4_BUFFER_CNTL));\r\n}\r\nstatic int r128_do_pixcache_flush(drm_r128_private_t *dev_priv)\r\n{\r\nu32 tmp;\r\nint i;\r\ntmp = R128_READ(R128_PC_NGUI_CTLSTAT) | R128_PC_FLUSH_ALL;\r\nR128_WRITE(R128_PC_NGUI_CTLSTAT, tmp);\r\nfor (i = 0; i < dev_priv->usec_timeout; i++) {\r\nif (!(R128_READ(R128_PC_NGUI_CTLSTAT) & R128_PC_BUSY))\r\nreturn 0;\r\nDRM_UDELAY(1);\r\n}\r\n#if R128_FIFO_DEBUG\r\nDRM_ERROR("failed!\n");\r\n#endif\r\nreturn -EBUSY;\r\n}\r\nstatic int r128_do_wait_for_fifo(drm_r128_private_t *dev_priv, int entries)\r\n{\r\nint i;\r\nfor (i = 0; i < dev_priv->usec_timeout; i++) {\r\nint slots = R128_READ(R128_GUI_STAT) & R128_GUI_FIFOCNT_MASK;\r\nif (slots >= entries)\r\nreturn 0;\r\nDRM_UDELAY(1);\r\n}\r\n#if R128_FIFO_DEBUG\r\nDRM_ERROR("failed!\n");\r\n#endif\r\nreturn -EBUSY;\r\n}\r\nstatic int r128_do_wait_for_idle(drm_r128_private_t *dev_priv)\r\n{\r\nint i, ret;\r\nret = r128_do_wait_for_fifo(dev_priv, 64);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < dev_priv->usec_timeout; i++) {\r\nif (!(R128_READ(R128_GUI_STAT) & R128_GUI_ACTIVE)) {\r\nr128_do_pixcache_flush(dev_priv);\r\nreturn 0;\r\n}\r\nDRM_UDELAY(1);\r\n}\r\n#if R128_FIFO_DEBUG\r\nDRM_ERROR("failed!\n");\r\n#endif\r\nreturn -EBUSY;\r\n}\r\nstatic int r128_cce_load_microcode(drm_r128_private_t *dev_priv)\r\n{\r\nstruct platform_device *pdev;\r\nconst struct firmware *fw;\r\nconst __be32 *fw_data;\r\nint rc, i;\r\nDRM_DEBUG("\n");\r\npdev = platform_device_register_simple("r128_cce", 0, NULL, 0);\r\nif (IS_ERR(pdev)) {\r\nprintk(KERN_ERR "r128_cce: Failed to register firmware\n");\r\nreturn PTR_ERR(pdev);\r\n}\r\nrc = request_firmware(&fw, FIRMWARE_NAME, &pdev->dev);\r\nplatform_device_unregister(pdev);\r\nif (rc) {\r\nprintk(KERN_ERR "r128_cce: Failed to load firmware \"%s\"\n",\r\nFIRMWARE_NAME);\r\nreturn rc;\r\n}\r\nif (fw->size != 256 * 8) {\r\nprintk(KERN_ERR\r\n"r128_cce: Bogus length %zu in firmware \"%s\"\n",\r\nfw->size, FIRMWARE_NAME);\r\nrc = -EINVAL;\r\ngoto out_release;\r\n}\r\nr128_do_wait_for_idle(dev_priv);\r\nfw_data = (const __be32 *)fw->data;\r\nR128_WRITE(R128_PM4_MICROCODE_ADDR, 0);\r\nfor (i = 0; i < 256; i++) {\r\nR128_WRITE(R128_PM4_MICROCODE_DATAH,\r\nbe32_to_cpup(&fw_data[i * 2]));\r\nR128_WRITE(R128_PM4_MICROCODE_DATAL,\r\nbe32_to_cpup(&fw_data[i * 2 + 1]));\r\n}\r\nout_release:\r\nrelease_firmware(fw);\r\nreturn rc;\r\n}\r\nstatic void r128_do_cce_flush(drm_r128_private_t *dev_priv)\r\n{\r\nu32 tmp;\r\ntmp = R128_READ(R128_PM4_BUFFER_DL_WPTR) | R128_PM4_BUFFER_DL_DONE;\r\nR128_WRITE(R128_PM4_BUFFER_DL_WPTR, tmp);\r\n}\r\nint r128_do_cce_idle(drm_r128_private_t *dev_priv)\r\n{\r\nint i;\r\nfor (i = 0; i < dev_priv->usec_timeout; i++) {\r\nif (GET_RING_HEAD(dev_priv) == dev_priv->ring.tail) {\r\nint pm4stat = R128_READ(R128_PM4_STAT);\r\nif (((pm4stat & R128_PM4_FIFOCNT_MASK) >=\r\ndev_priv->cce_fifo_size) &&\r\n!(pm4stat & (R128_PM4_BUSY |\r\nR128_PM4_GUI_ACTIVE))) {\r\nreturn r128_do_pixcache_flush(dev_priv);\r\n}\r\n}\r\nDRM_UDELAY(1);\r\n}\r\n#if R128_FIFO_DEBUG\r\nDRM_ERROR("failed!\n");\r\nr128_status(dev_priv);\r\n#endif\r\nreturn -EBUSY;\r\n}\r\nstatic void r128_do_cce_start(drm_r128_private_t *dev_priv)\r\n{\r\nr128_do_wait_for_idle(dev_priv);\r\nR128_WRITE(R128_PM4_BUFFER_CNTL,\r\ndev_priv->cce_mode | dev_priv->ring.size_l2qw\r\n| R128_PM4_BUFFER_CNTL_NOUPDATE);\r\nR128_READ(R128_PM4_BUFFER_ADDR);\r\nR128_WRITE(R128_PM4_MICRO_CNTL, R128_PM4_MICRO_FREERUN);\r\ndev_priv->cce_running = 1;\r\n}\r\nstatic void r128_do_cce_reset(drm_r128_private_t *dev_priv)\r\n{\r\nR128_WRITE(R128_PM4_BUFFER_DL_WPTR, 0);\r\nR128_WRITE(R128_PM4_BUFFER_DL_RPTR, 0);\r\ndev_priv->ring.tail = 0;\r\n}\r\nstatic void r128_do_cce_stop(drm_r128_private_t *dev_priv)\r\n{\r\nR128_WRITE(R128_PM4_MICRO_CNTL, 0);\r\nR128_WRITE(R128_PM4_BUFFER_CNTL,\r\nR128_PM4_NONPM4 | R128_PM4_BUFFER_CNTL_NOUPDATE);\r\ndev_priv->cce_running = 0;\r\n}\r\nstatic int r128_do_engine_reset(struct drm_device *dev)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nu32 clock_cntl_index, mclk_cntl, gen_reset_cntl;\r\nr128_do_pixcache_flush(dev_priv);\r\nclock_cntl_index = R128_READ(R128_CLOCK_CNTL_INDEX);\r\nmclk_cntl = R128_READ_PLL(dev, R128_MCLK_CNTL);\r\nR128_WRITE_PLL(R128_MCLK_CNTL,\r\nmclk_cntl | R128_FORCE_GCP | R128_FORCE_PIPE3D_CP);\r\ngen_reset_cntl = R128_READ(R128_GEN_RESET_CNTL);\r\nR128_WRITE(R128_GEN_RESET_CNTL, gen_reset_cntl | R128_SOFT_RESET_GUI);\r\nR128_READ(R128_GEN_RESET_CNTL);\r\nR128_WRITE(R128_GEN_RESET_CNTL, gen_reset_cntl & ~R128_SOFT_RESET_GUI);\r\nR128_READ(R128_GEN_RESET_CNTL);\r\nR128_WRITE_PLL(R128_MCLK_CNTL, mclk_cntl);\r\nR128_WRITE(R128_CLOCK_CNTL_INDEX, clock_cntl_index);\r\nR128_WRITE(R128_GEN_RESET_CNTL, gen_reset_cntl);\r\nr128_do_cce_reset(dev_priv);\r\ndev_priv->cce_running = 0;\r\nr128_freelist_reset(dev);\r\nreturn 0;\r\n}\r\nstatic void r128_cce_init_ring_buffer(struct drm_device *dev,\r\ndrm_r128_private_t *dev_priv)\r\n{\r\nu32 ring_start;\r\nu32 tmp;\r\nDRM_DEBUG("\n");\r\n#if __OS_HAS_AGP\r\nif (!dev_priv->is_pci)\r\nring_start = dev_priv->cce_ring->offset - dev->agp->base;\r\nelse\r\n#endif\r\nring_start = dev_priv->cce_ring->offset -\r\n(unsigned long)dev->sg->virtual;\r\nR128_WRITE(R128_PM4_BUFFER_OFFSET, ring_start | R128_AGP_OFFSET);\r\nR128_WRITE(R128_PM4_BUFFER_DL_WPTR, 0);\r\nR128_WRITE(R128_PM4_BUFFER_DL_RPTR, 0);\r\nR128_WRITE(R128_PM4_BUFFER_WM_CNTL,\r\n((R128_WATERMARK_L / 4) << R128_WMA_SHIFT)\r\n| ((R128_WATERMARK_M / 4) << R128_WMB_SHIFT)\r\n| ((R128_WATERMARK_N / 4) << R128_WMC_SHIFT)\r\n| ((R128_WATERMARK_K / 64) << R128_WB_WM_SHIFT));\r\nR128_READ(R128_PM4_BUFFER_ADDR);\r\ntmp = R128_READ(R128_BUS_CNTL) & ~R128_BUS_MASTER_DIS;\r\nR128_WRITE(R128_BUS_CNTL, tmp);\r\n}\r\nstatic int r128_do_init_cce(struct drm_device *dev, drm_r128_init_t *init)\r\n{\r\ndrm_r128_private_t *dev_priv;\r\nint rc;\r\nDRM_DEBUG("\n");\r\nif (dev->dev_private) {\r\nDRM_DEBUG("called when already initialized\n");\r\nreturn -EINVAL;\r\n}\r\ndev_priv = kzalloc(sizeof(drm_r128_private_t), GFP_KERNEL);\r\nif (dev_priv == NULL)\r\nreturn -ENOMEM;\r\ndev_priv->is_pci = init->is_pci;\r\nif (dev_priv->is_pci && !dev->sg) {\r\nDRM_ERROR("PCI GART memory not allocated!\n");\r\ndev->dev_private = (void *)dev_priv;\r\nr128_do_cleanup_cce(dev);\r\nreturn -EINVAL;\r\n}\r\ndev_priv->usec_timeout = init->usec_timeout;\r\nif (dev_priv->usec_timeout < 1 ||\r\ndev_priv->usec_timeout > R128_MAX_USEC_TIMEOUT) {\r\nDRM_DEBUG("TIMEOUT problem!\n");\r\ndev->dev_private = (void *)dev_priv;\r\nr128_do_cleanup_cce(dev);\r\nreturn -EINVAL;\r\n}\r\ndev_priv->cce_mode = init->cce_mode;\r\natomic_set(&dev_priv->idle_count, 0);\r\nif ((init->cce_mode != R128_PM4_192BM) &&\r\n(init->cce_mode != R128_PM4_128BM_64INDBM) &&\r\n(init->cce_mode != R128_PM4_64BM_128INDBM) &&\r\n(init->cce_mode != R128_PM4_64BM_64VCBM_64INDBM)) {\r\nDRM_DEBUG("Bad cce_mode!\n");\r\ndev->dev_private = (void *)dev_priv;\r\nr128_do_cleanup_cce(dev);\r\nreturn -EINVAL;\r\n}\r\nswitch (init->cce_mode) {\r\ncase R128_PM4_NONPM4:\r\ndev_priv->cce_fifo_size = 0;\r\nbreak;\r\ncase R128_PM4_192PIO:\r\ncase R128_PM4_192BM:\r\ndev_priv->cce_fifo_size = 192;\r\nbreak;\r\ncase R128_PM4_128PIO_64INDBM:\r\ncase R128_PM4_128BM_64INDBM:\r\ndev_priv->cce_fifo_size = 128;\r\nbreak;\r\ncase R128_PM4_64PIO_128INDBM:\r\ncase R128_PM4_64BM_128INDBM:\r\ncase R128_PM4_64PIO_64VCBM_64INDBM:\r\ncase R128_PM4_64BM_64VCBM_64INDBM:\r\ncase R128_PM4_64PIO_64VCPIO_64INDPIO:\r\ndev_priv->cce_fifo_size = 64;\r\nbreak;\r\n}\r\nswitch (init->fb_bpp) {\r\ncase 16:\r\ndev_priv->color_fmt = R128_DATATYPE_RGB565;\r\nbreak;\r\ncase 32:\r\ndefault:\r\ndev_priv->color_fmt = R128_DATATYPE_ARGB8888;\r\nbreak;\r\n}\r\ndev_priv->front_offset = init->front_offset;\r\ndev_priv->front_pitch = init->front_pitch;\r\ndev_priv->back_offset = init->back_offset;\r\ndev_priv->back_pitch = init->back_pitch;\r\nswitch (init->depth_bpp) {\r\ncase 16:\r\ndev_priv->depth_fmt = R128_DATATYPE_RGB565;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\ndefault:\r\ndev_priv->depth_fmt = R128_DATATYPE_ARGB8888;\r\nbreak;\r\n}\r\ndev_priv->depth_offset = init->depth_offset;\r\ndev_priv->depth_pitch = init->depth_pitch;\r\ndev_priv->span_offset = init->span_offset;\r\ndev_priv->front_pitch_offset_c = (((dev_priv->front_pitch / 8) << 21) |\r\n(dev_priv->front_offset >> 5));\r\ndev_priv->back_pitch_offset_c = (((dev_priv->back_pitch / 8) << 21) |\r\n(dev_priv->back_offset >> 5));\r\ndev_priv->depth_pitch_offset_c = (((dev_priv->depth_pitch / 8) << 21) |\r\n(dev_priv->depth_offset >> 5) |\r\nR128_DST_TILE);\r\ndev_priv->span_pitch_offset_c = (((dev_priv->depth_pitch / 8) << 21) |\r\n(dev_priv->span_offset >> 5));\r\ndev_priv->sarea = drm_getsarea(dev);\r\nif (!dev_priv->sarea) {\r\nDRM_ERROR("could not find sarea!\n");\r\ndev->dev_private = (void *)dev_priv;\r\nr128_do_cleanup_cce(dev);\r\nreturn -EINVAL;\r\n}\r\ndev_priv->mmio = drm_core_findmap(dev, init->mmio_offset);\r\nif (!dev_priv->mmio) {\r\nDRM_ERROR("could not find mmio region!\n");\r\ndev->dev_private = (void *)dev_priv;\r\nr128_do_cleanup_cce(dev);\r\nreturn -EINVAL;\r\n}\r\ndev_priv->cce_ring = drm_core_findmap(dev, init->ring_offset);\r\nif (!dev_priv->cce_ring) {\r\nDRM_ERROR("could not find cce ring region!\n");\r\ndev->dev_private = (void *)dev_priv;\r\nr128_do_cleanup_cce(dev);\r\nreturn -EINVAL;\r\n}\r\ndev_priv->ring_rptr = drm_core_findmap(dev, init->ring_rptr_offset);\r\nif (!dev_priv->ring_rptr) {\r\nDRM_ERROR("could not find ring read pointer!\n");\r\ndev->dev_private = (void *)dev_priv;\r\nr128_do_cleanup_cce(dev);\r\nreturn -EINVAL;\r\n}\r\ndev->agp_buffer_token = init->buffers_offset;\r\ndev->agp_buffer_map = drm_core_findmap(dev, init->buffers_offset);\r\nif (!dev->agp_buffer_map) {\r\nDRM_ERROR("could not find dma buffer region!\n");\r\ndev->dev_private = (void *)dev_priv;\r\nr128_do_cleanup_cce(dev);\r\nreturn -EINVAL;\r\n}\r\nif (!dev_priv->is_pci) {\r\ndev_priv->agp_textures =\r\ndrm_core_findmap(dev, init->agp_textures_offset);\r\nif (!dev_priv->agp_textures) {\r\nDRM_ERROR("could not find agp texture region!\n");\r\ndev->dev_private = (void *)dev_priv;\r\nr128_do_cleanup_cce(dev);\r\nreturn -EINVAL;\r\n}\r\n}\r\ndev_priv->sarea_priv =\r\n(drm_r128_sarea_t *) ((u8 *) dev_priv->sarea->handle +\r\ninit->sarea_priv_offset);\r\n#if __OS_HAS_AGP\r\nif (!dev_priv->is_pci) {\r\ndrm_core_ioremap_wc(dev_priv->cce_ring, dev);\r\ndrm_core_ioremap_wc(dev_priv->ring_rptr, dev);\r\ndrm_core_ioremap_wc(dev->agp_buffer_map, dev);\r\nif (!dev_priv->cce_ring->handle ||\r\n!dev_priv->ring_rptr->handle ||\r\n!dev->agp_buffer_map->handle) {\r\nDRM_ERROR("Could not ioremap agp regions!\n");\r\ndev->dev_private = (void *)dev_priv;\r\nr128_do_cleanup_cce(dev);\r\nreturn -ENOMEM;\r\n}\r\n} else\r\n#endif\r\n{\r\ndev_priv->cce_ring->handle =\r\n(void *)(unsigned long)dev_priv->cce_ring->offset;\r\ndev_priv->ring_rptr->handle =\r\n(void *)(unsigned long)dev_priv->ring_rptr->offset;\r\ndev->agp_buffer_map->handle =\r\n(void *)(unsigned long)dev->agp_buffer_map->offset;\r\n}\r\n#if __OS_HAS_AGP\r\nif (!dev_priv->is_pci)\r\ndev_priv->cce_buffers_offset = dev->agp->base;\r\nelse\r\n#endif\r\ndev_priv->cce_buffers_offset = (unsigned long)dev->sg->virtual;\r\ndev_priv->ring.start = (u32 *) dev_priv->cce_ring->handle;\r\ndev_priv->ring.end = ((u32 *) dev_priv->cce_ring->handle\r\n+ init->ring_size / sizeof(u32));\r\ndev_priv->ring.size = init->ring_size;\r\ndev_priv->ring.size_l2qw = order_base_2(init->ring_size / 8);\r\ndev_priv->ring.tail_mask = (dev_priv->ring.size / sizeof(u32)) - 1;\r\ndev_priv->ring.high_mark = 128;\r\ndev_priv->sarea_priv->last_frame = 0;\r\nR128_WRITE(R128_LAST_FRAME_REG, dev_priv->sarea_priv->last_frame);\r\ndev_priv->sarea_priv->last_dispatch = 0;\r\nR128_WRITE(R128_LAST_DISPATCH_REG, dev_priv->sarea_priv->last_dispatch);\r\n#if __OS_HAS_AGP\r\nif (dev_priv->is_pci) {\r\n#endif\r\ndev_priv->gart_info.table_mask = DMA_BIT_MASK(32);\r\ndev_priv->gart_info.gart_table_location = DRM_ATI_GART_MAIN;\r\ndev_priv->gart_info.table_size = R128_PCIGART_TABLE_SIZE;\r\ndev_priv->gart_info.addr = NULL;\r\ndev_priv->gart_info.bus_addr = 0;\r\ndev_priv->gart_info.gart_reg_if = DRM_ATI_GART_PCI;\r\nif (!drm_ati_pcigart_init(dev, &dev_priv->gart_info)) {\r\nDRM_ERROR("failed to init PCI GART!\n");\r\ndev->dev_private = (void *)dev_priv;\r\nr128_do_cleanup_cce(dev);\r\nreturn -ENOMEM;\r\n}\r\nR128_WRITE(R128_PCI_GART_PAGE, dev_priv->gart_info.bus_addr);\r\n#if __OS_HAS_AGP\r\n}\r\n#endif\r\nr128_cce_init_ring_buffer(dev, dev_priv);\r\nrc = r128_cce_load_microcode(dev_priv);\r\ndev->dev_private = (void *)dev_priv;\r\nr128_do_engine_reset(dev);\r\nif (rc) {\r\nDRM_ERROR("Failed to load firmware!\n");\r\nr128_do_cleanup_cce(dev);\r\n}\r\nreturn rc;\r\n}\r\nint r128_do_cleanup_cce(struct drm_device *dev)\r\n{\r\nif (dev->irq_enabled)\r\ndrm_irq_uninstall(dev);\r\nif (dev->dev_private) {\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\n#if __OS_HAS_AGP\r\nif (!dev_priv->is_pci) {\r\nif (dev_priv->cce_ring != NULL)\r\ndrm_core_ioremapfree(dev_priv->cce_ring, dev);\r\nif (dev_priv->ring_rptr != NULL)\r\ndrm_core_ioremapfree(dev_priv->ring_rptr, dev);\r\nif (dev->agp_buffer_map != NULL) {\r\ndrm_core_ioremapfree(dev->agp_buffer_map, dev);\r\ndev->agp_buffer_map = NULL;\r\n}\r\n} else\r\n#endif\r\n{\r\nif (dev_priv->gart_info.bus_addr)\r\nif (!drm_ati_pcigart_cleanup(dev,\r\n&dev_priv->gart_info))\r\nDRM_ERROR\r\n("failed to cleanup PCI GART!\n");\r\n}\r\nkfree(dev->dev_private);\r\ndev->dev_private = NULL;\r\n}\r\nreturn 0;\r\n}\r\nint r128_cce_init(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_r128_init_t *init = data;\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nswitch (init->func) {\r\ncase R128_INIT_CCE:\r\nreturn r128_do_init_cce(dev, init);\r\ncase R128_CLEANUP_CCE:\r\nreturn r128_do_cleanup_cce(dev);\r\n}\r\nreturn -EINVAL;\r\n}\r\nint r128_cce_start(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDEV_INIT_TEST_WITH_RETURN(dev_priv);\r\nif (dev_priv->cce_running || dev_priv->cce_mode == R128_PM4_NONPM4) {\r\nDRM_DEBUG("while CCE running\n");\r\nreturn 0;\r\n}\r\nr128_do_cce_start(dev_priv);\r\nreturn 0;\r\n}\r\nint r128_cce_stop(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\ndrm_r128_cce_stop_t *stop = data;\r\nint ret;\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDEV_INIT_TEST_WITH_RETURN(dev_priv);\r\nif (stop->flush)\r\nr128_do_cce_flush(dev_priv);\r\nif (stop->idle) {\r\nret = r128_do_cce_idle(dev_priv);\r\nif (ret)\r\nreturn ret;\r\n}\r\nr128_do_cce_stop(dev_priv);\r\nr128_do_engine_reset(dev);\r\nreturn 0;\r\n}\r\nint r128_cce_reset(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDEV_INIT_TEST_WITH_RETURN(dev_priv);\r\nr128_do_cce_reset(dev_priv);\r\ndev_priv->cce_running = 0;\r\nreturn 0;\r\n}\r\nint r128_cce_idle(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDEV_INIT_TEST_WITH_RETURN(dev_priv);\r\nif (dev_priv->cce_running)\r\nr128_do_cce_flush(dev_priv);\r\nreturn r128_do_cce_idle(dev_priv);\r\n}\r\nint r128_engine_reset(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\nDRM_DEBUG("\n");\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nDEV_INIT_TEST_WITH_RETURN(dev->dev_private);\r\nreturn r128_do_engine_reset(dev);\r\n}\r\nint r128_fullscreen(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic struct drm_buf *r128_freelist_get(struct drm_device * dev)\r\n{\r\nstruct drm_device_dma *dma = dev->dma;\r\ndrm_r128_private_t *dev_priv = dev->dev_private;\r\ndrm_r128_buf_priv_t *buf_priv;\r\nstruct drm_buf *buf;\r\nint i, t;\r\nfor (i = 0; i < dma->buf_count; i++) {\r\nbuf = dma->buflist[i];\r\nbuf_priv = buf->dev_private;\r\nif (!buf->file_priv)\r\nreturn buf;\r\n}\r\nfor (t = 0; t < dev_priv->usec_timeout; t++) {\r\nu32 done_age = R128_READ(R128_LAST_DISPATCH_REG);\r\nfor (i = 0; i < dma->buf_count; i++) {\r\nbuf = dma->buflist[i];\r\nbuf_priv = buf->dev_private;\r\nif (buf->pending && buf_priv->age <= done_age) {\r\nbuf->pending = 0;\r\nreturn buf;\r\n}\r\n}\r\nDRM_UDELAY(1);\r\n}\r\nDRM_DEBUG("returning NULL!\n");\r\nreturn NULL;\r\n}\r\nvoid r128_freelist_reset(struct drm_device *dev)\r\n{\r\nstruct drm_device_dma *dma = dev->dma;\r\nint i;\r\nfor (i = 0; i < dma->buf_count; i++) {\r\nstruct drm_buf *buf = dma->buflist[i];\r\ndrm_r128_buf_priv_t *buf_priv = buf->dev_private;\r\nbuf_priv->age = 0;\r\n}\r\n}\r\nint r128_wait_ring(drm_r128_private_t *dev_priv, int n)\r\n{\r\ndrm_r128_ring_buffer_t *ring = &dev_priv->ring;\r\nint i;\r\nfor (i = 0; i < dev_priv->usec_timeout; i++) {\r\nr128_update_ring_snapshot(dev_priv);\r\nif (ring->space >= n)\r\nreturn 0;\r\nDRM_UDELAY(1);\r\n}\r\nDRM_ERROR("failed!\n");\r\nreturn -EBUSY;\r\n}\r\nstatic int r128_cce_get_buffers(struct drm_device *dev,\r\nstruct drm_file *file_priv,\r\nstruct drm_dma *d)\r\n{\r\nint i;\r\nstruct drm_buf *buf;\r\nfor (i = d->granted_count; i < d->request_count; i++) {\r\nbuf = r128_freelist_get(dev);\r\nif (!buf)\r\nreturn -EAGAIN;\r\nbuf->file_priv = file_priv;\r\nif (DRM_COPY_TO_USER(&d->request_indices[i], &buf->idx,\r\nsizeof(buf->idx)))\r\nreturn -EFAULT;\r\nif (DRM_COPY_TO_USER(&d->request_sizes[i], &buf->total,\r\nsizeof(buf->total)))\r\nreturn -EFAULT;\r\nd->granted_count++;\r\n}\r\nreturn 0;\r\n}\r\nint r128_cce_buffers(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\nstruct drm_device_dma *dma = dev->dma;\r\nint ret = 0;\r\nstruct drm_dma *d = data;\r\nLOCK_TEST_WITH_RETURN(dev, file_priv);\r\nif (d->send_count != 0) {\r\nDRM_ERROR("Process %d trying to send %d buffers via drmDMA\n",\r\nDRM_CURRENTPID, d->send_count);\r\nreturn -EINVAL;\r\n}\r\nif (d->request_count < 0 || d->request_count > dma->buf_count) {\r\nDRM_ERROR("Process %d trying to get %d buffers (of %d max)\n",\r\nDRM_CURRENTPID, d->request_count, dma->buf_count);\r\nreturn -EINVAL;\r\n}\r\nd->granted_count = 0;\r\nif (d->request_count)\r\nret = r128_cce_get_buffers(dev, file_priv, d);\r\nreturn ret;\r\n}
