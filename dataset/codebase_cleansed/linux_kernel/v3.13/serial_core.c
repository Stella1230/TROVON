void uart_write_wakeup(struct uart_port *port)\r\n{\r\nstruct uart_state *state = port->state;\r\nBUG_ON(!state);\r\ntty_wakeup(state->port.tty);\r\n}\r\nstatic void uart_stop(struct tty_struct *tty)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nstruct uart_port *port = state->uart_port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nport->ops->stop_tx(port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void __uart_start(struct tty_struct *tty)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nstruct uart_port *port = state->uart_port;\r\nif (!uart_circ_empty(&state->xmit) && state->xmit.buf &&\r\n!tty->stopped && !tty->hw_stopped)\r\nport->ops->start_tx(port);\r\n}\r\nstatic void uart_start(struct tty_struct *tty)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nstruct uart_port *port = state->uart_port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\n__uart_start(tty);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic inline void\r\nuart_update_mctrl(struct uart_port *port, unsigned int set, unsigned int clear)\r\n{\r\nunsigned long flags;\r\nunsigned int old;\r\nspin_lock_irqsave(&port->lock, flags);\r\nold = port->mctrl;\r\nport->mctrl = (old & ~clear) | set;\r\nif (old != port->mctrl)\r\nport->ops->set_mctrl(port, port->mctrl);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int uart_port_startup(struct tty_struct *tty, struct uart_state *state,\r\nint init_hw)\r\n{\r\nstruct uart_port *uport = state->uart_port;\r\nstruct tty_port *port = &state->port;\r\nunsigned long page;\r\nint retval = 0;\r\nif (uport->type == PORT_UNKNOWN)\r\nreturn 1;\r\nif (!state->xmit.buf) {\r\npage = get_zeroed_page(GFP_KERNEL);\r\nif (!page)\r\nreturn -ENOMEM;\r\nstate->xmit.buf = (unsigned char *) page;\r\nuart_circ_clear(&state->xmit);\r\n}\r\nretval = uport->ops->startup(uport);\r\nif (retval == 0) {\r\nif (uart_console(uport) && uport->cons->cflag) {\r\ntty->termios.c_cflag = uport->cons->cflag;\r\nuport->cons->cflag = 0;\r\n}\r\nuart_change_speed(tty, state, NULL);\r\nif (init_hw) {\r\nif (tty->termios.c_cflag & CBAUD)\r\nuart_set_mctrl(uport, TIOCM_RTS | TIOCM_DTR);\r\n}\r\nif (tty_port_cts_enabled(port)) {\r\nspin_lock_irq(&uport->lock);\r\nif (!(uport->ops->get_mctrl(uport) & TIOCM_CTS))\r\ntty->hw_stopped = 1;\r\nspin_unlock_irq(&uport->lock);\r\n}\r\n}\r\nif (retval && capable(CAP_SYS_ADMIN))\r\nreturn 1;\r\nreturn retval;\r\n}\r\nstatic int uart_startup(struct tty_struct *tty, struct uart_state *state,\r\nint init_hw)\r\n{\r\nstruct tty_port *port = &state->port;\r\nint retval;\r\nif (port->flags & ASYNC_INITIALIZED)\r\nreturn 0;\r\nset_bit(TTY_IO_ERROR, &tty->flags);\r\nretval = uart_port_startup(tty, state, init_hw);\r\nif (!retval) {\r\nset_bit(ASYNCB_INITIALIZED, &port->flags);\r\nclear_bit(TTY_IO_ERROR, &tty->flags);\r\n} else if (retval > 0)\r\nretval = 0;\r\nreturn retval;\r\n}\r\nstatic void uart_shutdown(struct tty_struct *tty, struct uart_state *state)\r\n{\r\nstruct uart_port *uport = state->uart_port;\r\nstruct tty_port *port = &state->port;\r\nif (tty)\r\nset_bit(TTY_IO_ERROR, &tty->flags);\r\nif (test_and_clear_bit(ASYNCB_INITIALIZED, &port->flags)) {\r\nif (!tty || (tty->termios.c_cflag & HUPCL))\r\nuart_clear_mctrl(uport, TIOCM_DTR | TIOCM_RTS);\r\nuart_port_shutdown(port);\r\n}\r\nclear_bit(ASYNCB_SUSPENDED, &port->flags);\r\nif (state->xmit.buf) {\r\nfree_page((unsigned long)state->xmit.buf);\r\nstate->xmit.buf = NULL;\r\n}\r\n}\r\nvoid\r\nuart_update_timeout(struct uart_port *port, unsigned int cflag,\r\nunsigned int baud)\r\n{\r\nunsigned int bits;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nbits = 7;\r\nbreak;\r\ncase CS6:\r\nbits = 8;\r\nbreak;\r\ncase CS7:\r\nbits = 9;\r\nbreak;\r\ndefault:\r\nbits = 10;\r\nbreak;\r\n}\r\nif (cflag & CSTOPB)\r\nbits++;\r\nif (cflag & PARENB)\r\nbits++;\r\nbits = bits * port->fifosize;\r\nport->timeout = (HZ * bits) / baud + HZ/50;\r\n}\r\nunsigned int\r\nuart_get_baud_rate(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old, unsigned int min, unsigned int max)\r\n{\r\nunsigned int try, baud, altbaud = 38400;\r\nint hung_up = 0;\r\nupf_t flags = port->flags & UPF_SPD_MASK;\r\nif (flags == UPF_SPD_HI)\r\naltbaud = 57600;\r\nelse if (flags == UPF_SPD_VHI)\r\naltbaud = 115200;\r\nelse if (flags == UPF_SPD_SHI)\r\naltbaud = 230400;\r\nelse if (flags == UPF_SPD_WARP)\r\naltbaud = 460800;\r\nfor (try = 0; try < 2; try++) {\r\nbaud = tty_termios_baud_rate(termios);\r\nif (baud == 38400)\r\nbaud = altbaud;\r\nif (baud == 0) {\r\nhung_up = 1;\r\nbaud = 9600;\r\n}\r\nif (baud >= min && baud <= max)\r\nreturn baud;\r\ntermios->c_cflag &= ~CBAUD;\r\nif (old) {\r\nbaud = tty_termios_baud_rate(old);\r\nif (!hung_up)\r\ntty_termios_encode_baud_rate(termios,\r\nbaud, baud);\r\nold = NULL;\r\ncontinue;\r\n}\r\nif (!hung_up) {\r\nif (baud <= min)\r\ntty_termios_encode_baud_rate(termios,\r\nmin + 1, min + 1);\r\nelse\r\ntty_termios_encode_baud_rate(termios,\r\nmax - 1, max - 1);\r\n}\r\n}\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\nunsigned int\r\nuart_get_divisor(struct uart_port *port, unsigned int baud)\r\n{\r\nunsigned int quot;\r\nif (baud == 38400 && (port->flags & UPF_SPD_MASK) == UPF_SPD_CUST)\r\nquot = port->custom_divisor;\r\nelse\r\nquot = DIV_ROUND_CLOSEST(port->uartclk, 16 * baud);\r\nreturn quot;\r\n}\r\nstatic void uart_change_speed(struct tty_struct *tty, struct uart_state *state,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct tty_port *port = &state->port;\r\nstruct uart_port *uport = state->uart_port;\r\nstruct ktermios *termios;\r\nif (!tty || uport->type == PORT_UNKNOWN)\r\nreturn;\r\ntermios = &tty->termios;\r\nif (termios->c_cflag & CRTSCTS)\r\nset_bit(ASYNCB_CTS_FLOW, &port->flags);\r\nelse\r\nclear_bit(ASYNCB_CTS_FLOW, &port->flags);\r\nif (termios->c_cflag & CLOCAL)\r\nclear_bit(ASYNCB_CHECK_CD, &port->flags);\r\nelse\r\nset_bit(ASYNCB_CHECK_CD, &port->flags);\r\nuport->ops->set_termios(uport, termios, old_termios);\r\n}\r\nstatic inline int __uart_put_char(struct uart_port *port,\r\nstruct circ_buf *circ, unsigned char c)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nif (!circ->buf)\r\nreturn 0;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (uart_circ_chars_free(circ) != 0) {\r\ncirc->buf[circ->head] = c;\r\ncirc->head = (circ->head + 1) & (UART_XMIT_SIZE - 1);\r\nret = 1;\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int uart_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nreturn __uart_put_char(state->uart_port, &state->xmit, ch);\r\n}\r\nstatic void uart_flush_chars(struct tty_struct *tty)\r\n{\r\nuart_start(tty);\r\n}\r\nstatic int uart_write(struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nstruct uart_port *port;\r\nstruct circ_buf *circ;\r\nunsigned long flags;\r\nint c, ret = 0;\r\nif (!state) {\r\nWARN_ON(1);\r\nreturn -EL3HLT;\r\n}\r\nport = state->uart_port;\r\ncirc = &state->xmit;\r\nif (!circ->buf)\r\nreturn 0;\r\nspin_lock_irqsave(&port->lock, flags);\r\nwhile (1) {\r\nc = CIRC_SPACE_TO_END(circ->head, circ->tail, UART_XMIT_SIZE);\r\nif (count < c)\r\nc = count;\r\nif (c <= 0)\r\nbreak;\r\nmemcpy(circ->buf + circ->head, buf, c);\r\ncirc->head = (circ->head + c) & (UART_XMIT_SIZE - 1);\r\nbuf += c;\r\ncount -= c;\r\nret += c;\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nuart_start(tty);\r\nreturn ret;\r\n}\r\nstatic int uart_write_room(struct tty_struct *tty)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&state->uart_port->lock, flags);\r\nret = uart_circ_chars_free(&state->xmit);\r\nspin_unlock_irqrestore(&state->uart_port->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int uart_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&state->uart_port->lock, flags);\r\nret = uart_circ_chars_pending(&state->xmit);\r\nspin_unlock_irqrestore(&state->uart_port->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void uart_flush_buffer(struct tty_struct *tty)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nstruct uart_port *port;\r\nunsigned long flags;\r\nif (!state) {\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nport = state->uart_port;\r\npr_debug("uart_flush_buffer(%d) called\n", tty->index);\r\nspin_lock_irqsave(&port->lock, flags);\r\nuart_circ_clear(&state->xmit);\r\nif (port->ops->flush_buffer)\r\nport->ops->flush_buffer(port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\ntty_wakeup(tty);\r\n}\r\nstatic void uart_send_xchar(struct tty_struct *tty, char ch)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nstruct uart_port *port = state->uart_port;\r\nunsigned long flags;\r\nif (port->ops->send_xchar)\r\nport->ops->send_xchar(port, ch);\r\nelse {\r\nport->x_char = ch;\r\nif (ch) {\r\nspin_lock_irqsave(&port->lock, flags);\r\nport->ops->start_tx(port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\n}\r\n}\r\nstatic void uart_throttle(struct tty_struct *tty)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nstruct uart_port *port = state->uart_port;\r\nuint32_t mask = 0;\r\nif (I_IXOFF(tty))\r\nmask |= UPF_SOFT_FLOW;\r\nif (tty->termios.c_cflag & CRTSCTS)\r\nmask |= UPF_HARD_FLOW;\r\nif (port->flags & mask) {\r\nport->ops->throttle(port);\r\nmask &= ~port->flags;\r\n}\r\nif (mask & UPF_SOFT_FLOW)\r\nuart_send_xchar(tty, STOP_CHAR(tty));\r\nif (mask & UPF_HARD_FLOW)\r\nuart_clear_mctrl(port, TIOCM_RTS);\r\n}\r\nstatic void uart_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nstruct uart_port *port = state->uart_port;\r\nuint32_t mask = 0;\r\nif (I_IXOFF(tty))\r\nmask |= UPF_SOFT_FLOW;\r\nif (tty->termios.c_cflag & CRTSCTS)\r\nmask |= UPF_HARD_FLOW;\r\nif (port->flags & mask) {\r\nport->ops->unthrottle(port);\r\nmask &= ~port->flags;\r\n}\r\nif (mask & UPF_SOFT_FLOW) {\r\nif (port->x_char)\r\nport->x_char = 0;\r\nelse\r\nuart_send_xchar(tty, START_CHAR(tty));\r\n}\r\nif (mask & UPF_HARD_FLOW)\r\nuart_set_mctrl(port, TIOCM_RTS);\r\n}\r\nstatic void do_uart_get_info(struct tty_port *port,\r\nstruct serial_struct *retinfo)\r\n{\r\nstruct uart_state *state = container_of(port, struct uart_state, port);\r\nstruct uart_port *uport = state->uart_port;\r\nmemset(retinfo, 0, sizeof(*retinfo));\r\nretinfo->type = uport->type;\r\nretinfo->line = uport->line;\r\nretinfo->port = uport->iobase;\r\nif (HIGH_BITS_OFFSET)\r\nretinfo->port_high = (long) uport->iobase >> HIGH_BITS_OFFSET;\r\nretinfo->irq = uport->irq;\r\nretinfo->flags = uport->flags;\r\nretinfo->xmit_fifo_size = uport->fifosize;\r\nretinfo->baud_base = uport->uartclk / 16;\r\nretinfo->close_delay = jiffies_to_msecs(port->close_delay) / 10;\r\nretinfo->closing_wait = port->closing_wait == ASYNC_CLOSING_WAIT_NONE ?\r\nASYNC_CLOSING_WAIT_NONE :\r\njiffies_to_msecs(port->closing_wait) / 10;\r\nretinfo->custom_divisor = uport->custom_divisor;\r\nretinfo->hub6 = uport->hub6;\r\nretinfo->io_type = uport->iotype;\r\nretinfo->iomem_reg_shift = uport->regshift;\r\nretinfo->iomem_base = (void *)(unsigned long)uport->mapbase;\r\n}\r\nstatic void uart_get_info(struct tty_port *port,\r\nstruct serial_struct *retinfo)\r\n{\r\nmutex_lock(&port->mutex);\r\ndo_uart_get_info(port, retinfo);\r\nmutex_unlock(&port->mutex);\r\n}\r\nstatic int uart_get_info_user(struct tty_port *port,\r\nstruct serial_struct __user *retinfo)\r\n{\r\nstruct serial_struct tmp;\r\nuart_get_info(port, &tmp);\r\nif (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int uart_set_info(struct tty_struct *tty, struct tty_port *port,\r\nstruct uart_state *state,\r\nstruct serial_struct *new_info)\r\n{\r\nstruct uart_port *uport = state->uart_port;\r\nunsigned long new_port;\r\nunsigned int change_irq, change_port, closing_wait;\r\nunsigned int old_custom_divisor, close_delay;\r\nupf_t old_flags, new_flags;\r\nint retval = 0;\r\nnew_port = new_info->port;\r\nif (HIGH_BITS_OFFSET)\r\nnew_port += (unsigned long) new_info->port_high << HIGH_BITS_OFFSET;\r\nnew_info->irq = irq_canonicalize(new_info->irq);\r\nclose_delay = msecs_to_jiffies(new_info->close_delay * 10);\r\nclosing_wait = new_info->closing_wait == ASYNC_CLOSING_WAIT_NONE ?\r\nASYNC_CLOSING_WAIT_NONE :\r\nmsecs_to_jiffies(new_info->closing_wait * 10);\r\nchange_irq = !(uport->flags & UPF_FIXED_PORT)\r\n&& new_info->irq != uport->irq;\r\nchange_port = !(uport->flags & UPF_FIXED_PORT)\r\n&& (new_port != uport->iobase ||\r\n(unsigned long)new_info->iomem_base != uport->mapbase ||\r\nnew_info->hub6 != uport->hub6 ||\r\nnew_info->io_type != uport->iotype ||\r\nnew_info->iomem_reg_shift != uport->regshift ||\r\nnew_info->type != uport->type);\r\nold_flags = uport->flags;\r\nnew_flags = new_info->flags;\r\nold_custom_divisor = uport->custom_divisor;\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nretval = -EPERM;\r\nif (change_irq || change_port ||\r\n(new_info->baud_base != uport->uartclk / 16) ||\r\n(close_delay != port->close_delay) ||\r\n(closing_wait != port->closing_wait) ||\r\n(new_info->xmit_fifo_size &&\r\nnew_info->xmit_fifo_size != uport->fifosize) ||\r\n(((new_flags ^ old_flags) & ~UPF_USR_MASK) != 0))\r\ngoto exit;\r\nuport->flags = ((uport->flags & ~UPF_USR_MASK) |\r\n(new_flags & UPF_USR_MASK));\r\nuport->custom_divisor = new_info->custom_divisor;\r\ngoto check_and_exit;\r\n}\r\nif (uport->ops->verify_port)\r\nretval = uport->ops->verify_port(uport, new_info);\r\nif ((new_info->irq >= nr_irqs) || (new_info->irq < 0) ||\r\n(new_info->baud_base < 9600))\r\nretval = -EINVAL;\r\nif (retval)\r\ngoto exit;\r\nif (change_port || change_irq) {\r\nretval = -EBUSY;\r\nif (tty_port_users(port) > 1)\r\ngoto exit;\r\nuart_shutdown(tty, state);\r\n}\r\nif (change_port) {\r\nunsigned long old_iobase, old_mapbase;\r\nunsigned int old_type, old_iotype, old_hub6, old_shift;\r\nold_iobase = uport->iobase;\r\nold_mapbase = uport->mapbase;\r\nold_type = uport->type;\r\nold_hub6 = uport->hub6;\r\nold_iotype = uport->iotype;\r\nold_shift = uport->regshift;\r\nif (old_type != PORT_UNKNOWN)\r\nuport->ops->release_port(uport);\r\nuport->iobase = new_port;\r\nuport->type = new_info->type;\r\nuport->hub6 = new_info->hub6;\r\nuport->iotype = new_info->io_type;\r\nuport->regshift = new_info->iomem_reg_shift;\r\nuport->mapbase = (unsigned long)new_info->iomem_base;\r\nif (uport->type != PORT_UNKNOWN) {\r\nretval = uport->ops->request_port(uport);\r\n} else {\r\nretval = 0;\r\n}\r\nif (retval && old_type != PORT_UNKNOWN) {\r\nuport->iobase = old_iobase;\r\nuport->type = old_type;\r\nuport->hub6 = old_hub6;\r\nuport->iotype = old_iotype;\r\nuport->regshift = old_shift;\r\nuport->mapbase = old_mapbase;\r\nretval = uport->ops->request_port(uport);\r\nif (retval)\r\nuport->type = PORT_UNKNOWN;\r\nretval = -EBUSY;\r\ngoto exit;\r\n}\r\n}\r\nif (change_irq)\r\nuport->irq = new_info->irq;\r\nif (!(uport->flags & UPF_FIXED_PORT))\r\nuport->uartclk = new_info->baud_base * 16;\r\nuport->flags = (uport->flags & ~UPF_CHANGE_MASK) |\r\n(new_flags & UPF_CHANGE_MASK);\r\nuport->custom_divisor = new_info->custom_divisor;\r\nport->close_delay = close_delay;\r\nport->closing_wait = closing_wait;\r\nif (new_info->xmit_fifo_size)\r\nuport->fifosize = new_info->xmit_fifo_size;\r\nport->low_latency = (uport->flags & UPF_LOW_LATENCY) ? 1 : 0;\r\ncheck_and_exit:\r\nretval = 0;\r\nif (uport->type == PORT_UNKNOWN)\r\ngoto exit;\r\nif (port->flags & ASYNC_INITIALIZED) {\r\nif (((old_flags ^ uport->flags) & UPF_SPD_MASK) ||\r\nold_custom_divisor != uport->custom_divisor) {\r\nif (uport->flags & UPF_SPD_MASK) {\r\nchar buf[64];\r\nprintk(KERN_NOTICE\r\n"%s sets custom speed on %s. This "\r\n"is deprecated.\n", current->comm,\r\ntty_name(port->tty, buf));\r\n}\r\nuart_change_speed(tty, state, NULL);\r\n}\r\n} else\r\nretval = uart_startup(tty, state, 1);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic int uart_set_info_user(struct tty_struct *tty, struct uart_state *state,\r\nstruct serial_struct __user *newinfo)\r\n{\r\nstruct serial_struct new_serial;\r\nstruct tty_port *port = &state->port;\r\nint retval;\r\nif (copy_from_user(&new_serial, newinfo, sizeof(new_serial)))\r\nreturn -EFAULT;\r\nmutex_lock(&port->mutex);\r\nretval = uart_set_info(tty, port, state, &new_serial);\r\nmutex_unlock(&port->mutex);\r\nreturn retval;\r\n}\r\nstatic int uart_get_lsr_info(struct tty_struct *tty,\r\nstruct uart_state *state, unsigned int __user *value)\r\n{\r\nstruct uart_port *uport = state->uart_port;\r\nunsigned int result;\r\nresult = uport->ops->tx_empty(uport);\r\nif (uport->x_char ||\r\n((uart_circ_chars_pending(&state->xmit) > 0) &&\r\n!tty->stopped && !tty->hw_stopped))\r\nresult &= ~TIOCSER_TEMT;\r\nreturn put_user(result, value);\r\n}\r\nstatic int uart_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nstruct tty_port *port = &state->port;\r\nstruct uart_port *uport = state->uart_port;\r\nint result = -EIO;\r\nmutex_lock(&port->mutex);\r\nif (!(tty->flags & (1 << TTY_IO_ERROR))) {\r\nresult = uport->mctrl;\r\nspin_lock_irq(&uport->lock);\r\nresult |= uport->ops->get_mctrl(uport);\r\nspin_unlock_irq(&uport->lock);\r\n}\r\nmutex_unlock(&port->mutex);\r\nreturn result;\r\n}\r\nstatic int\r\nuart_tiocmset(struct tty_struct *tty, unsigned int set, unsigned int clear)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nstruct uart_port *uport = state->uart_port;\r\nstruct tty_port *port = &state->port;\r\nint ret = -EIO;\r\nmutex_lock(&port->mutex);\r\nif (!(tty->flags & (1 << TTY_IO_ERROR))) {\r\nuart_update_mctrl(uport, set, clear);\r\nret = 0;\r\n}\r\nmutex_unlock(&port->mutex);\r\nreturn ret;\r\n}\r\nstatic int uart_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nstruct tty_port *port = &state->port;\r\nstruct uart_port *uport = state->uart_port;\r\nmutex_lock(&port->mutex);\r\nif (uport->type != PORT_UNKNOWN)\r\nuport->ops->break_ctl(uport, break_state);\r\nmutex_unlock(&port->mutex);\r\nreturn 0;\r\n}\r\nstatic int uart_do_autoconfig(struct tty_struct *tty,struct uart_state *state)\r\n{\r\nstruct uart_port *uport = state->uart_port;\r\nstruct tty_port *port = &state->port;\r\nint flags, ret;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (mutex_lock_interruptible(&port->mutex))\r\nreturn -ERESTARTSYS;\r\nret = -EBUSY;\r\nif (tty_port_users(port) == 1) {\r\nuart_shutdown(tty, state);\r\nif (uport->type != PORT_UNKNOWN)\r\nuport->ops->release_port(uport);\r\nflags = UART_CONFIG_TYPE;\r\nif (uport->flags & UPF_AUTO_IRQ)\r\nflags |= UART_CONFIG_IRQ;\r\nuport->ops->config_port(uport, flags);\r\nret = uart_startup(tty, state, 1);\r\n}\r\nmutex_unlock(&port->mutex);\r\nreturn ret;\r\n}\r\nstatic int\r\nuart_wait_modem_status(struct uart_state *state, unsigned long arg)\r\n{\r\nstruct uart_port *uport = state->uart_port;\r\nstruct tty_port *port = &state->port;\r\nDECLARE_WAITQUEUE(wait, current);\r\nstruct uart_icount cprev, cnow;\r\nint ret;\r\nspin_lock_irq(&uport->lock);\r\nmemcpy(&cprev, &uport->icount, sizeof(struct uart_icount));\r\nuport->ops->enable_ms(uport);\r\nspin_unlock_irq(&uport->lock);\r\nadd_wait_queue(&port->delta_msr_wait, &wait);\r\nfor (;;) {\r\nspin_lock_irq(&uport->lock);\r\nmemcpy(&cnow, &uport->icount, sizeof(struct uart_icount));\r\nspin_unlock_irq(&uport->lock);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||\r\n((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||\r\n((arg & TIOCM_CD) && (cnow.dcd != cprev.dcd)) ||\r\n((arg & TIOCM_CTS) && (cnow.cts != cprev.cts))) {\r\nret = 0;\r\nbreak;\r\n}\r\nschedule();\r\nif (signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\ncprev = cnow;\r\n}\r\ncurrent->state = TASK_RUNNING;\r\nremove_wait_queue(&port->delta_msr_wait, &wait);\r\nreturn ret;\r\n}\r\nstatic int uart_get_icount(struct tty_struct *tty,\r\nstruct serial_icounter_struct *icount)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nstruct uart_icount cnow;\r\nstruct uart_port *uport = state->uart_port;\r\nspin_lock_irq(&uport->lock);\r\nmemcpy(&cnow, &uport->icount, sizeof(struct uart_icount));\r\nspin_unlock_irq(&uport->lock);\r\nicount->cts = cnow.cts;\r\nicount->dsr = cnow.dsr;\r\nicount->rng = cnow.rng;\r\nicount->dcd = cnow.dcd;\r\nicount->rx = cnow.rx;\r\nicount->tx = cnow.tx;\r\nicount->frame = cnow.frame;\r\nicount->overrun = cnow.overrun;\r\nicount->parity = cnow.parity;\r\nicount->brk = cnow.brk;\r\nicount->buf_overrun = cnow.buf_overrun;\r\nreturn 0;\r\n}\r\nstatic int\r\nuart_ioctl(struct tty_struct *tty, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nstruct tty_port *port = &state->port;\r\nvoid __user *uarg = (void __user *)arg;\r\nint ret = -ENOIOCTLCMD;\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\nret = uart_get_info_user(port, uarg);\r\nbreak;\r\ncase TIOCSSERIAL:\r\nret = uart_set_info_user(tty, state, uarg);\r\nbreak;\r\ncase TIOCSERCONFIG:\r\nret = uart_do_autoconfig(tty, state);\r\nbreak;\r\ncase TIOCSERGWILD:\r\ncase TIOCSERSWILD:\r\nret = 0;\r\nbreak;\r\n}\r\nif (ret != -ENOIOCTLCMD)\r\ngoto out;\r\nif (tty->flags & (1 << TTY_IO_ERROR)) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nswitch (cmd) {\r\ncase TIOCMIWAIT:\r\nret = uart_wait_modem_status(state, arg);\r\nbreak;\r\n}\r\nif (ret != -ENOIOCTLCMD)\r\ngoto out;\r\nmutex_lock(&port->mutex);\r\nif (tty->flags & (1 << TTY_IO_ERROR)) {\r\nret = -EIO;\r\ngoto out_up;\r\n}\r\nswitch (cmd) {\r\ncase TIOCSERGETLSR:\r\nret = uart_get_lsr_info(tty, state, uarg);\r\nbreak;\r\ndefault: {\r\nstruct uart_port *uport = state->uart_port;\r\nif (uport->ops->ioctl)\r\nret = uport->ops->ioctl(uport, cmd, arg);\r\nbreak;\r\n}\r\n}\r\nout_up:\r\nmutex_unlock(&port->mutex);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void uart_set_ldisc(struct tty_struct *tty)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nstruct uart_port *uport = state->uart_port;\r\nif (uport->ops->set_ldisc)\r\nuport->ops->set_ldisc(uport, tty->termios.c_line);\r\n}\r\nstatic void uart_set_termios(struct tty_struct *tty,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nstruct uart_port *uport = state->uart_port;\r\nunsigned long flags;\r\nunsigned int cflag = tty->termios.c_cflag;\r\nunsigned int iflag_mask = IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK;\r\nbool sw_changed = false;\r\nif (uport->flags & UPF_SOFT_FLOW) {\r\niflag_mask |= IXANY|IXON|IXOFF;\r\nsw_changed =\r\ntty->termios.c_cc[VSTART] != old_termios->c_cc[VSTART] ||\r\ntty->termios.c_cc[VSTOP] != old_termios->c_cc[VSTOP];\r\n}\r\nif ((cflag ^ old_termios->c_cflag) == 0 &&\r\ntty->termios.c_ospeed == old_termios->c_ospeed &&\r\ntty->termios.c_ispeed == old_termios->c_ispeed &&\r\n((tty->termios.c_iflag ^ old_termios->c_iflag) & iflag_mask) == 0 &&\r\n!sw_changed) {\r\nreturn;\r\n}\r\nuart_change_speed(tty, state, old_termios);\r\nif ((old_termios->c_cflag & CBAUD) && !(cflag & CBAUD))\r\nuart_clear_mctrl(uport, TIOCM_RTS | TIOCM_DTR);\r\nelse if (!(old_termios->c_cflag & CBAUD) && (cflag & CBAUD)) {\r\nunsigned int mask = TIOCM_DTR;\r\nif (!(cflag & CRTSCTS) ||\r\n!test_bit(TTY_THROTTLED, &tty->flags))\r\nmask |= TIOCM_RTS;\r\nuart_set_mctrl(uport, mask);\r\n}\r\nif (uport->flags & UPF_HARD_FLOW)\r\nreturn;\r\nif ((old_termios->c_cflag & CRTSCTS) && !(cflag & CRTSCTS)) {\r\nspin_lock_irqsave(&uport->lock, flags);\r\ntty->hw_stopped = 0;\r\n__uart_start(tty);\r\nspin_unlock_irqrestore(&uport->lock, flags);\r\n}\r\nelse if (!(old_termios->c_cflag & CRTSCTS) && (cflag & CRTSCTS)) {\r\nspin_lock_irqsave(&uport->lock, flags);\r\nif (!(uport->ops->get_mctrl(uport) & TIOCM_CTS)) {\r\ntty->hw_stopped = 1;\r\nuport->ops->stop_tx(uport);\r\n}\r\nspin_unlock_irqrestore(&uport->lock, flags);\r\n}\r\n}\r\nstatic void uart_close(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nstruct tty_port *port;\r\nstruct uart_port *uport;\r\nunsigned long flags;\r\nif (!state)\r\nreturn;\r\nuport = state->uart_port;\r\nport = &state->port;\r\npr_debug("uart_close(%d) called\n", uport->line);\r\nif (tty_port_close_start(port, tty, filp) == 0)\r\nreturn;\r\nif (port->flags & ASYNC_INITIALIZED) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&uport->lock, flags);\r\nuport->ops->stop_rx(uport);\r\nspin_unlock_irqrestore(&uport->lock, flags);\r\nuart_wait_until_sent(tty, uport->timeout);\r\n}\r\nmutex_lock(&port->mutex);\r\nuart_shutdown(tty, state);\r\nuart_flush_buffer(tty);\r\ntty_ldisc_flush(tty);\r\ntty_port_tty_set(port, NULL);\r\nspin_lock_irqsave(&port->lock, flags);\r\ntty->closing = 0;\r\nif (port->blocked_open) {\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (port->close_delay)\r\nmsleep_interruptible(\r\njiffies_to_msecs(port->close_delay));\r\nspin_lock_irqsave(&port->lock, flags);\r\n} else if (!uart_console(uport)) {\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nuart_change_pm(state, UART_PM_STATE_OFF);\r\nspin_lock_irqsave(&port->lock, flags);\r\n}\r\nclear_bit(ASYNCB_NORMAL_ACTIVE, &port->flags);\r\nclear_bit(ASYNCB_CLOSING, &port->flags);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nwake_up_interruptible(&port->open_wait);\r\nwake_up_interruptible(&port->close_wait);\r\nmutex_unlock(&port->mutex);\r\n}\r\nstatic void uart_wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nstruct uart_port *port = state->uart_port;\r\nunsigned long char_time, expire;\r\nif (port->type == PORT_UNKNOWN || port->fifosize == 0)\r\nreturn;\r\nchar_time = (port->timeout - HZ/50) / port->fifosize;\r\nchar_time = char_time / 5;\r\nif (char_time == 0)\r\nchar_time = 1;\r\nif (timeout && timeout < char_time)\r\nchar_time = timeout;\r\nif (timeout == 0 || timeout > 2 * port->timeout)\r\ntimeout = 2 * port->timeout;\r\nexpire = jiffies + timeout;\r\npr_debug("uart_wait_until_sent(%d), jiffies=%lu, expire=%lu...\n",\r\nport->line, jiffies, expire);\r\nwhile (!port->ops->tx_empty(port)) {\r\nmsleep_interruptible(jiffies_to_msecs(char_time));\r\nif (signal_pending(current))\r\nbreak;\r\nif (time_after(jiffies, expire))\r\nbreak;\r\n}\r\n}\r\nstatic void uart_hangup(struct tty_struct *tty)\r\n{\r\nstruct uart_state *state = tty->driver_data;\r\nstruct tty_port *port = &state->port;\r\nunsigned long flags;\r\npr_debug("uart_hangup(%d)\n", state->uart_port->line);\r\nmutex_lock(&port->mutex);\r\nif (port->flags & ASYNC_NORMAL_ACTIVE) {\r\nuart_flush_buffer(tty);\r\nuart_shutdown(tty, state);\r\nspin_lock_irqsave(&port->lock, flags);\r\nport->count = 0;\r\nclear_bit(ASYNCB_NORMAL_ACTIVE, &port->flags);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\ntty_port_tty_set(port, NULL);\r\nwake_up_interruptible(&port->open_wait);\r\nwake_up_interruptible(&port->delta_msr_wait);\r\n}\r\nmutex_unlock(&port->mutex);\r\n}\r\nstatic int uart_port_activate(struct tty_port *port, struct tty_struct *tty)\r\n{\r\nreturn 0;\r\n}\r\nstatic void uart_port_shutdown(struct tty_port *port)\r\n{\r\nstruct uart_state *state = container_of(port, struct uart_state, port);\r\nstruct uart_port *uport = state->uart_port;\r\nwake_up_interruptible(&port->delta_msr_wait);\r\nuport->ops->shutdown(uport);\r\nsynchronize_irq(uport->irq);\r\n}\r\nstatic int uart_carrier_raised(struct tty_port *port)\r\n{\r\nstruct uart_state *state = container_of(port, struct uart_state, port);\r\nstruct uart_port *uport = state->uart_port;\r\nint mctrl;\r\nspin_lock_irq(&uport->lock);\r\nuport->ops->enable_ms(uport);\r\nmctrl = uport->ops->get_mctrl(uport);\r\nspin_unlock_irq(&uport->lock);\r\nif (mctrl & TIOCM_CAR)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void uart_dtr_rts(struct tty_port *port, int onoff)\r\n{\r\nstruct uart_state *state = container_of(port, struct uart_state, port);\r\nstruct uart_port *uport = state->uart_port;\r\nif (onoff)\r\nuart_set_mctrl(uport, TIOCM_DTR | TIOCM_RTS);\r\nelse\r\nuart_clear_mctrl(uport, TIOCM_DTR | TIOCM_RTS);\r\n}\r\nstatic int uart_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct uart_driver *drv = (struct uart_driver *)tty->driver->driver_state;\r\nint retval, line = tty->index;\r\nstruct uart_state *state = drv->state + line;\r\nstruct tty_port *port = &state->port;\r\npr_debug("uart_open(%d) called\n", line);\r\nif (mutex_lock_interruptible(&port->mutex)) {\r\nretval = -ERESTARTSYS;\r\ngoto end;\r\n}\r\nport->count++;\r\nif (!state->uart_port || state->uart_port->flags & UPF_DEAD) {\r\nretval = -ENXIO;\r\ngoto err_dec_count;\r\n}\r\ntty->driver_data = state;\r\nstate->uart_port->state = state;\r\nstate->port.low_latency =\r\n(state->uart_port->flags & UPF_LOW_LATENCY) ? 1 : 0;\r\ntty_port_tty_set(port, tty);\r\nif (tty_hung_up_p(filp)) {\r\nretval = -EAGAIN;\r\ngoto err_dec_count;\r\n}\r\nif (port->count == 1)\r\nuart_change_pm(state, UART_PM_STATE_ON);\r\nretval = uart_startup(tty, state, 0);\r\nmutex_unlock(&port->mutex);\r\nif (retval == 0)\r\nretval = tty_port_block_til_ready(port, tty, filp);\r\nend:\r\nreturn retval;\r\nerr_dec_count:\r\nport->count--;\r\nmutex_unlock(&port->mutex);\r\ngoto end;\r\n}\r\nstatic const char *uart_type(struct uart_port *port)\r\n{\r\nconst char *str = NULL;\r\nif (port->ops->type)\r\nstr = port->ops->type(port);\r\nif (!str)\r\nstr = "unknown";\r\nreturn str;\r\n}\r\nstatic void uart_line_info(struct seq_file *m, struct uart_driver *drv, int i)\r\n{\r\nstruct uart_state *state = drv->state + i;\r\nstruct tty_port *port = &state->port;\r\nenum uart_pm_state pm_state;\r\nstruct uart_port *uport = state->uart_port;\r\nchar stat_buf[32];\r\nunsigned int status;\r\nint mmio;\r\nif (!uport)\r\nreturn;\r\nmmio = uport->iotype >= UPIO_MEM;\r\nseq_printf(m, "%d: uart:%s %s%08llX irq:%d",\r\nuport->line, uart_type(uport),\r\nmmio ? "mmio:0x" : "port:",\r\nmmio ? (unsigned long long)uport->mapbase\r\n: (unsigned long long)uport->iobase,\r\nuport->irq);\r\nif (uport->type == PORT_UNKNOWN) {\r\nseq_putc(m, '\n');\r\nreturn;\r\n}\r\nif (capable(CAP_SYS_ADMIN)) {\r\nmutex_lock(&port->mutex);\r\npm_state = state->pm_state;\r\nif (pm_state != UART_PM_STATE_ON)\r\nuart_change_pm(state, UART_PM_STATE_ON);\r\nspin_lock_irq(&uport->lock);\r\nstatus = uport->ops->get_mctrl(uport);\r\nspin_unlock_irq(&uport->lock);\r\nif (pm_state != UART_PM_STATE_ON)\r\nuart_change_pm(state, pm_state);\r\nmutex_unlock(&port->mutex);\r\nseq_printf(m, " tx:%d rx:%d",\r\nuport->icount.tx, uport->icount.rx);\r\nif (uport->icount.frame)\r\nseq_printf(m, " fe:%d",\r\nuport->icount.frame);\r\nif (uport->icount.parity)\r\nseq_printf(m, " pe:%d",\r\nuport->icount.parity);\r\nif (uport->icount.brk)\r\nseq_printf(m, " brk:%d",\r\nuport->icount.brk);\r\nif (uport->icount.overrun)\r\nseq_printf(m, " oe:%d",\r\nuport->icount.overrun);\r\n#define INFOBIT(bit, str) \\r\nif (uport->mctrl & (bit)) \\r\nstrncat(stat_buf, (str), sizeof(stat_buf) - \\r\nstrlen(stat_buf) - 2)\r\n#define STATBIT(bit, str) \\r\nif (status & (bit)) \\r\nstrncat(stat_buf, (str), sizeof(stat_buf) - \\r\nstrlen(stat_buf) - 2)\r\nstat_buf[0] = '\0';\r\nstat_buf[1] = '\0';\r\nINFOBIT(TIOCM_RTS, "|RTS");\r\nSTATBIT(TIOCM_CTS, "|CTS");\r\nINFOBIT(TIOCM_DTR, "|DTR");\r\nSTATBIT(TIOCM_DSR, "|DSR");\r\nSTATBIT(TIOCM_CAR, "|CD");\r\nSTATBIT(TIOCM_RNG, "|RI");\r\nif (stat_buf[0])\r\nstat_buf[0] = ' ';\r\nseq_puts(m, stat_buf);\r\n}\r\nseq_putc(m, '\n');\r\n#undef STATBIT\r\n#undef INFOBIT\r\n}\r\nstatic int uart_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct tty_driver *ttydrv = m->private;\r\nstruct uart_driver *drv = ttydrv->driver_state;\r\nint i;\r\nseq_printf(m, "serinfo:1.0 driver%s%s revision:%s\n",\r\n"", "", "");\r\nfor (i = 0; i < drv->nr; i++)\r\nuart_line_info(m, drv, i);\r\nreturn 0;\r\n}\r\nstatic int uart_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, uart_proc_show, PDE_DATA(inode));\r\n}\r\nvoid uart_console_write(struct uart_port *port, const char *s,\r\nunsigned int count,\r\nvoid (*putchar)(struct uart_port *, int))\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < count; i++, s++) {\r\nif (*s == '\n')\r\nputchar(port, '\r');\r\nputchar(port, *s);\r\n}\r\n}\r\nstruct uart_port * __init\r\nuart_get_console(struct uart_port *ports, int nr, struct console *co)\r\n{\r\nint idx = co->index;\r\nif (idx < 0 || idx >= nr || (ports[idx].iobase == 0 &&\r\nports[idx].membase == NULL))\r\nfor (idx = 0; idx < nr; idx++)\r\nif (ports[idx].iobase != 0 ||\r\nports[idx].membase != NULL)\r\nbreak;\r\nco->index = idx;\r\nreturn ports + idx;\r\n}\r\nvoid\r\nuart_parse_options(char *options, int *baud, int *parity, int *bits, int *flow)\r\n{\r\nchar *s = options;\r\n*baud = simple_strtoul(s, NULL, 10);\r\nwhile (*s >= '0' && *s <= '9')\r\ns++;\r\nif (*s)\r\n*parity = *s++;\r\nif (*s)\r\n*bits = *s++ - '0';\r\nif (*s)\r\n*flow = *s;\r\n}\r\nint\r\nuart_set_options(struct uart_port *port, struct console *co,\r\nint baud, int parity, int bits, int flow)\r\n{\r\nstruct ktermios termios;\r\nstatic struct ktermios dummy;\r\nint i;\r\nspin_lock_init(&port->lock);\r\nlockdep_set_class(&port->lock, &port_lock_key);\r\nmemset(&termios, 0, sizeof(struct ktermios));\r\ntermios.c_cflag = CREAD | HUPCL | CLOCAL;\r\nfor (i = 0; baud_rates[i].rate; i++)\r\nif (baud_rates[i].rate <= baud)\r\nbreak;\r\ntermios.c_cflag |= baud_rates[i].cflag;\r\nif (bits == 7)\r\ntermios.c_cflag |= CS7;\r\nelse\r\ntermios.c_cflag |= CS8;\r\nswitch (parity) {\r\ncase 'o': case 'O':\r\ntermios.c_cflag |= PARODD;\r\ncase 'e': case 'E':\r\ntermios.c_cflag |= PARENB;\r\nbreak;\r\n}\r\nif (flow == 'r')\r\ntermios.c_cflag |= CRTSCTS;\r\nport->mctrl |= TIOCM_DTR;\r\nport->ops->set_termios(port, &termios, &dummy);\r\nif (co)\r\nco->cflag = termios.c_cflag;\r\nreturn 0;\r\n}\r\nstatic void uart_change_pm(struct uart_state *state,\r\nenum uart_pm_state pm_state)\r\n{\r\nstruct uart_port *port = state->uart_port;\r\nif (state->pm_state != pm_state) {\r\nif (port->ops->pm)\r\nport->ops->pm(port, pm_state, state->pm_state);\r\nstate->pm_state = pm_state;\r\n}\r\n}\r\nstatic int serial_match_port(struct device *dev, void *data)\r\n{\r\nstruct uart_match *match = data;\r\nstruct tty_driver *tty_drv = match->driver->tty_driver;\r\ndev_t devt = MKDEV(tty_drv->major, tty_drv->minor_start) +\r\nmatch->port->line;\r\nreturn dev->devt == devt;\r\n}\r\nint uart_suspend_port(struct uart_driver *drv, struct uart_port *uport)\r\n{\r\nstruct uart_state *state = drv->state + uport->line;\r\nstruct tty_port *port = &state->port;\r\nstruct device *tty_dev;\r\nstruct uart_match match = {uport, drv};\r\nmutex_lock(&port->mutex);\r\ntty_dev = device_find_child(uport->dev, &match, serial_match_port);\r\nif (device_may_wakeup(tty_dev)) {\r\nif (!enable_irq_wake(uport->irq))\r\nuport->irq_wake = 1;\r\nput_device(tty_dev);\r\nmutex_unlock(&port->mutex);\r\nreturn 0;\r\n}\r\nput_device(tty_dev);\r\nif (console_suspend_enabled || !uart_console(uport))\r\nuport->suspended = 1;\r\nif (port->flags & ASYNC_INITIALIZED) {\r\nconst struct uart_ops *ops = uport->ops;\r\nint tries;\r\nif (console_suspend_enabled || !uart_console(uport)) {\r\nset_bit(ASYNCB_SUSPENDED, &port->flags);\r\nclear_bit(ASYNCB_INITIALIZED, &port->flags);\r\nspin_lock_irq(&uport->lock);\r\nops->stop_tx(uport);\r\nops->set_mctrl(uport, 0);\r\nops->stop_rx(uport);\r\nspin_unlock_irq(&uport->lock);\r\n}\r\nfor (tries = 3; !ops->tx_empty(uport) && tries; tries--)\r\nmsleep(10);\r\nif (!tries)\r\nprintk(KERN_ERR "%s%s%s%d: Unable to drain "\r\n"transmitter\n",\r\nuport->dev ? dev_name(uport->dev) : "",\r\nuport->dev ? ": " : "",\r\ndrv->dev_name,\r\ndrv->tty_driver->name_base + uport->line);\r\nif (console_suspend_enabled || !uart_console(uport))\r\nops->shutdown(uport);\r\n}\r\nif (console_suspend_enabled && uart_console(uport))\r\nconsole_stop(uport->cons);\r\nif (console_suspend_enabled || !uart_console(uport))\r\nuart_change_pm(state, UART_PM_STATE_OFF);\r\nmutex_unlock(&port->mutex);\r\nreturn 0;\r\n}\r\nint uart_resume_port(struct uart_driver *drv, struct uart_port *uport)\r\n{\r\nstruct uart_state *state = drv->state + uport->line;\r\nstruct tty_port *port = &state->port;\r\nstruct device *tty_dev;\r\nstruct uart_match match = {uport, drv};\r\nstruct ktermios termios;\r\nmutex_lock(&port->mutex);\r\ntty_dev = device_find_child(uport->dev, &match, serial_match_port);\r\nif (!uport->suspended && device_may_wakeup(tty_dev)) {\r\nif (uport->irq_wake) {\r\ndisable_irq_wake(uport->irq);\r\nuport->irq_wake = 0;\r\n}\r\nput_device(tty_dev);\r\nmutex_unlock(&port->mutex);\r\nreturn 0;\r\n}\r\nput_device(tty_dev);\r\nuport->suspended = 0;\r\nif (uart_console(uport)) {\r\nmemset(&termios, 0, sizeof(struct ktermios));\r\ntermios.c_cflag = uport->cons->cflag;\r\nif (port->tty && termios.c_cflag == 0)\r\ntermios = port->tty->termios;\r\nif (console_suspend_enabled)\r\nuart_change_pm(state, UART_PM_STATE_ON);\r\nuport->ops->set_termios(uport, &termios, NULL);\r\nif (console_suspend_enabled)\r\nconsole_start(uport->cons);\r\n}\r\nif (port->flags & ASYNC_SUSPENDED) {\r\nconst struct uart_ops *ops = uport->ops;\r\nint ret;\r\nuart_change_pm(state, UART_PM_STATE_ON);\r\nspin_lock_irq(&uport->lock);\r\nops->set_mctrl(uport, 0);\r\nspin_unlock_irq(&uport->lock);\r\nif (console_suspend_enabled || !uart_console(uport)) {\r\nstruct tty_struct *tty = port->tty;\r\nret = ops->startup(uport);\r\nif (ret == 0) {\r\nif (tty)\r\nuart_change_speed(tty, state, NULL);\r\nspin_lock_irq(&uport->lock);\r\nops->set_mctrl(uport, uport->mctrl);\r\nops->start_tx(uport);\r\nspin_unlock_irq(&uport->lock);\r\nset_bit(ASYNCB_INITIALIZED, &port->flags);\r\n} else {\r\nuart_shutdown(tty, state);\r\n}\r\n}\r\nclear_bit(ASYNCB_SUSPENDED, &port->flags);\r\n}\r\nmutex_unlock(&port->mutex);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nuart_report_port(struct uart_driver *drv, struct uart_port *port)\r\n{\r\nchar address[64];\r\nswitch (port->iotype) {\r\ncase UPIO_PORT:\r\nsnprintf(address, sizeof(address), "I/O 0x%lx", port->iobase);\r\nbreak;\r\ncase UPIO_HUB6:\r\nsnprintf(address, sizeof(address),\r\n"I/O 0x%lx offset 0x%x", port->iobase, port->hub6);\r\nbreak;\r\ncase UPIO_MEM:\r\ncase UPIO_MEM32:\r\ncase UPIO_AU:\r\ncase UPIO_TSI:\r\nsnprintf(address, sizeof(address),\r\n"MMIO 0x%llx", (unsigned long long)port->mapbase);\r\nbreak;\r\ndefault:\r\nstrlcpy(address, "*unknown*", sizeof(address));\r\nbreak;\r\n}\r\nprintk(KERN_INFO "%s%s%s%d at %s (irq = %d, base_baud = %d) is a %s\n",\r\nport->dev ? dev_name(port->dev) : "",\r\nport->dev ? ": " : "",\r\ndrv->dev_name,\r\ndrv->tty_driver->name_base + port->line,\r\naddress, port->irq, port->uartclk / 16, uart_type(port));\r\n}\r\nstatic void\r\nuart_configure_port(struct uart_driver *drv, struct uart_state *state,\r\nstruct uart_port *port)\r\n{\r\nunsigned int flags;\r\nif (!port->iobase && !port->mapbase && !port->membase)\r\nreturn;\r\nflags = 0;\r\nif (port->flags & UPF_AUTO_IRQ)\r\nflags |= UART_CONFIG_IRQ;\r\nif (port->flags & UPF_BOOT_AUTOCONF) {\r\nif (!(port->flags & UPF_FIXED_TYPE)) {\r\nport->type = PORT_UNKNOWN;\r\nflags |= UART_CONFIG_TYPE;\r\n}\r\nport->ops->config_port(port, flags);\r\n}\r\nif (port->type != PORT_UNKNOWN) {\r\nunsigned long flags;\r\nuart_report_port(drv, port);\r\nuart_change_pm(state, UART_PM_STATE_ON);\r\nspin_lock_irqsave(&port->lock, flags);\r\nport->ops->set_mctrl(port, port->mctrl & TIOCM_DTR);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (port->cons && !(port->cons->flags & CON_ENABLED))\r\nregister_console(port->cons);\r\nif (!uart_console(port))\r\nuart_change_pm(state, UART_PM_STATE_OFF);\r\n}\r\n}\r\nstatic int uart_poll_init(struct tty_driver *driver, int line, char *options)\r\n{\r\nstruct uart_driver *drv = driver->driver_state;\r\nstruct uart_state *state = drv->state + line;\r\nstruct uart_port *port;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nint ret;\r\nif (!state || !state->uart_port)\r\nreturn -1;\r\nport = state->uart_port;\r\nif (!(port->ops->poll_get_char && port->ops->poll_put_char))\r\nreturn -1;\r\nif (port->ops->poll_init) {\r\nstruct tty_port *tport = &state->port;\r\nret = 0;\r\nmutex_lock(&tport->mutex);\r\nif (!test_bit(ASYNCB_INITIALIZED, &tport->flags))\r\nret = port->ops->poll_init(port);\r\nmutex_unlock(&tport->mutex);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (options) {\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(port, NULL, baud, parity, bits, flow);\r\n}\r\nreturn 0;\r\n}\r\nstatic int uart_poll_get_char(struct tty_driver *driver, int line)\r\n{\r\nstruct uart_driver *drv = driver->driver_state;\r\nstruct uart_state *state = drv->state + line;\r\nstruct uart_port *port;\r\nif (!state || !state->uart_port)\r\nreturn -1;\r\nport = state->uart_port;\r\nreturn port->ops->poll_get_char(port);\r\n}\r\nstatic void uart_poll_put_char(struct tty_driver *driver, int line, char ch)\r\n{\r\nstruct uart_driver *drv = driver->driver_state;\r\nstruct uart_state *state = drv->state + line;\r\nstruct uart_port *port;\r\nif (!state || !state->uart_port)\r\nreturn;\r\nport = state->uart_port;\r\nport->ops->poll_put_char(port, ch);\r\n}\r\nint uart_register_driver(struct uart_driver *drv)\r\n{\r\nstruct tty_driver *normal;\r\nint i, retval;\r\nBUG_ON(drv->state);\r\ndrv->state = kzalloc(sizeof(struct uart_state) * drv->nr, GFP_KERNEL);\r\nif (!drv->state)\r\ngoto out;\r\nnormal = alloc_tty_driver(drv->nr);\r\nif (!normal)\r\ngoto out_kfree;\r\ndrv->tty_driver = normal;\r\nnormal->driver_name = drv->driver_name;\r\nnormal->name = drv->dev_name;\r\nnormal->major = drv->major;\r\nnormal->minor_start = drv->minor;\r\nnormal->type = TTY_DRIVER_TYPE_SERIAL;\r\nnormal->subtype = SERIAL_TYPE_NORMAL;\r\nnormal->init_termios = tty_std_termios;\r\nnormal->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;\r\nnormal->init_termios.c_ispeed = normal->init_termios.c_ospeed = 9600;\r\nnormal->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;\r\nnormal->driver_state = drv;\r\ntty_set_operations(normal, &uart_ops);\r\nfor (i = 0; i < drv->nr; i++) {\r\nstruct uart_state *state = drv->state + i;\r\nstruct tty_port *port = &state->port;\r\ntty_port_init(port);\r\nport->ops = &uart_port_ops;\r\nport->close_delay = HZ / 2;\r\nport->closing_wait = 30 * HZ;\r\n}\r\nretval = tty_register_driver(normal);\r\nif (retval >= 0)\r\nreturn retval;\r\nfor (i = 0; i < drv->nr; i++)\r\ntty_port_destroy(&drv->state[i].port);\r\nput_tty_driver(normal);\r\nout_kfree:\r\nkfree(drv->state);\r\nout:\r\nreturn -ENOMEM;\r\n}\r\nvoid uart_unregister_driver(struct uart_driver *drv)\r\n{\r\nstruct tty_driver *p = drv->tty_driver;\r\nunsigned int i;\r\ntty_unregister_driver(p);\r\nput_tty_driver(p);\r\nfor (i = 0; i < drv->nr; i++)\r\ntty_port_destroy(&drv->state[i].port);\r\nkfree(drv->state);\r\ndrv->state = NULL;\r\ndrv->tty_driver = NULL;\r\n}\r\nstruct tty_driver *uart_console_device(struct console *co, int *index)\r\n{\r\nstruct uart_driver *p = co->data;\r\n*index = co->index;\r\nreturn p->tty_driver;\r\n}\r\nstatic ssize_t uart_get_attr_uartclk(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct serial_struct tmp;\r\nstruct tty_port *port = dev_get_drvdata(dev);\r\nuart_get_info(port, &tmp);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", tmp.baud_base * 16);\r\n}\r\nstatic ssize_t uart_get_attr_type(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct serial_struct tmp;\r\nstruct tty_port *port = dev_get_drvdata(dev);\r\nuart_get_info(port, &tmp);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", tmp.type);\r\n}\r\nstatic ssize_t uart_get_attr_line(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct serial_struct tmp;\r\nstruct tty_port *port = dev_get_drvdata(dev);\r\nuart_get_info(port, &tmp);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", tmp.line);\r\n}\r\nstatic ssize_t uart_get_attr_port(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct serial_struct tmp;\r\nstruct tty_port *port = dev_get_drvdata(dev);\r\nunsigned long ioaddr;\r\nuart_get_info(port, &tmp);\r\nioaddr = tmp.port;\r\nif (HIGH_BITS_OFFSET)\r\nioaddr |= (unsigned long)tmp.port_high << HIGH_BITS_OFFSET;\r\nreturn snprintf(buf, PAGE_SIZE, "0x%lX\n", ioaddr);\r\n}\r\nstatic ssize_t uart_get_attr_irq(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct serial_struct tmp;\r\nstruct tty_port *port = dev_get_drvdata(dev);\r\nuart_get_info(port, &tmp);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", tmp.irq);\r\n}\r\nstatic ssize_t uart_get_attr_flags(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct serial_struct tmp;\r\nstruct tty_port *port = dev_get_drvdata(dev);\r\nuart_get_info(port, &tmp);\r\nreturn snprintf(buf, PAGE_SIZE, "0x%X\n", tmp.flags);\r\n}\r\nstatic ssize_t uart_get_attr_xmit_fifo_size(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct serial_struct tmp;\r\nstruct tty_port *port = dev_get_drvdata(dev);\r\nuart_get_info(port, &tmp);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", tmp.xmit_fifo_size);\r\n}\r\nstatic ssize_t uart_get_attr_close_delay(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct serial_struct tmp;\r\nstruct tty_port *port = dev_get_drvdata(dev);\r\nuart_get_info(port, &tmp);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", tmp.close_delay);\r\n}\r\nstatic ssize_t uart_get_attr_closing_wait(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct serial_struct tmp;\r\nstruct tty_port *port = dev_get_drvdata(dev);\r\nuart_get_info(port, &tmp);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", tmp.closing_wait);\r\n}\r\nstatic ssize_t uart_get_attr_custom_divisor(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct serial_struct tmp;\r\nstruct tty_port *port = dev_get_drvdata(dev);\r\nuart_get_info(port, &tmp);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", tmp.custom_divisor);\r\n}\r\nstatic ssize_t uart_get_attr_io_type(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct serial_struct tmp;\r\nstruct tty_port *port = dev_get_drvdata(dev);\r\nuart_get_info(port, &tmp);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", tmp.io_type);\r\n}\r\nstatic ssize_t uart_get_attr_iomem_base(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct serial_struct tmp;\r\nstruct tty_port *port = dev_get_drvdata(dev);\r\nuart_get_info(port, &tmp);\r\nreturn snprintf(buf, PAGE_SIZE, "0x%lX\n", (unsigned long)tmp.iomem_base);\r\n}\r\nstatic ssize_t uart_get_attr_iomem_reg_shift(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct serial_struct tmp;\r\nstruct tty_port *port = dev_get_drvdata(dev);\r\nuart_get_info(port, &tmp);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", tmp.iomem_reg_shift);\r\n}\r\nint uart_add_one_port(struct uart_driver *drv, struct uart_port *uport)\r\n{\r\nstruct uart_state *state;\r\nstruct tty_port *port;\r\nint ret = 0;\r\nstruct device *tty_dev;\r\nBUG_ON(in_interrupt());\r\nif (uport->line >= drv->nr)\r\nreturn -EINVAL;\r\nstate = drv->state + uport->line;\r\nport = &state->port;\r\nmutex_lock(&port_mutex);\r\nmutex_lock(&port->mutex);\r\nif (state->uart_port) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nstate->uart_port = uport;\r\nstate->pm_state = UART_PM_STATE_UNDEFINED;\r\nuport->cons = drv->cons;\r\nuport->state = state;\r\nif (!(uart_console(uport) && (uport->cons->flags & CON_ENABLED))) {\r\nspin_lock_init(&uport->lock);\r\nlockdep_set_class(&uport->lock, &port_lock_key);\r\n}\r\nuart_configure_port(drv, state, uport);\r\ntty_dev = tty_port_register_device_attr(port, drv->tty_driver,\r\nuport->line, uport->dev, port, tty_dev_attr_groups);\r\nif (likely(!IS_ERR(tty_dev))) {\r\ndevice_set_wakeup_capable(tty_dev, 1);\r\n} else {\r\nprintk(KERN_ERR "Cannot register tty device on line %d\n",\r\nuport->line);\r\n}\r\nuport->flags &= ~UPF_DEAD;\r\nout:\r\nmutex_unlock(&port->mutex);\r\nmutex_unlock(&port_mutex);\r\nreturn ret;\r\n}\r\nint uart_remove_one_port(struct uart_driver *drv, struct uart_port *uport)\r\n{\r\nstruct uart_state *state = drv->state + uport->line;\r\nstruct tty_port *port = &state->port;\r\nint ret = 0;\r\nBUG_ON(in_interrupt());\r\nif (state->uart_port != uport)\r\nprintk(KERN_ALERT "Removing wrong port: %p != %p\n",\r\nstate->uart_port, uport);\r\nmutex_lock(&port_mutex);\r\nmutex_lock(&port->mutex);\r\nif (!state->uart_port) {\r\nmutex_unlock(&port->mutex);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nuport->flags |= UPF_DEAD;\r\nmutex_unlock(&port->mutex);\r\ntty_unregister_device(drv->tty_driver, uport->line);\r\nif (port->tty)\r\ntty_vhangup(port->tty);\r\nif (uport->type != PORT_UNKNOWN)\r\nuport->ops->release_port(uport);\r\nuport->type = PORT_UNKNOWN;\r\nstate->uart_port = NULL;\r\nout:\r\nmutex_unlock(&port_mutex);\r\nreturn ret;\r\n}\r\nint uart_match_port(struct uart_port *port1, struct uart_port *port2)\r\n{\r\nif (port1->iotype != port2->iotype)\r\nreturn 0;\r\nswitch (port1->iotype) {\r\ncase UPIO_PORT:\r\nreturn (port1->iobase == port2->iobase);\r\ncase UPIO_HUB6:\r\nreturn (port1->iobase == port2->iobase) &&\r\n(port1->hub6 == port2->hub6);\r\ncase UPIO_MEM:\r\ncase UPIO_MEM32:\r\ncase UPIO_AU:\r\ncase UPIO_TSI:\r\nreturn (port1->mapbase == port2->mapbase);\r\n}\r\nreturn 0;\r\n}\r\nvoid uart_handle_dcd_change(struct uart_port *uport, unsigned int status)\r\n{\r\nstruct tty_port *port = &uport->state->port;\r\nstruct tty_struct *tty = port->tty;\r\nstruct tty_ldisc *ld = tty ? tty_ldisc_ref(tty) : NULL;\r\nif (ld) {\r\nif (ld->ops->dcd_change)\r\nld->ops->dcd_change(tty, status);\r\ntty_ldisc_deref(ld);\r\n}\r\nuport->icount.dcd++;\r\nif (port->flags & ASYNC_CHECK_CD) {\r\nif (status)\r\nwake_up_interruptible(&port->open_wait);\r\nelse if (tty)\r\ntty_hangup(tty);\r\n}\r\n}\r\nvoid uart_handle_cts_change(struct uart_port *uport, unsigned int status)\r\n{\r\nstruct tty_port *port = &uport->state->port;\r\nstruct tty_struct *tty = port->tty;\r\nuport->icount.cts++;\r\nif (tty_port_cts_enabled(port)) {\r\nif (tty->hw_stopped) {\r\nif (status) {\r\ntty->hw_stopped = 0;\r\nuport->ops->start_tx(uport);\r\nuart_write_wakeup(uport);\r\n}\r\n} else {\r\nif (!status) {\r\ntty->hw_stopped = 1;\r\nuport->ops->stop_tx(uport);\r\n}\r\n}\r\n}\r\n}\r\nvoid uart_insert_char(struct uart_port *port, unsigned int status,\r\nunsigned int overrun, unsigned int ch, unsigned int flag)\r\n{\r\nstruct tty_port *tport = &port->state->port;\r\nif ((status & port->ignore_status_mask & ~overrun) == 0)\r\nif (tty_insert_flip_char(tport, ch, flag) == 0)\r\n++port->icount.buf_overrun;\r\nif (status & ~port->ignore_status_mask & overrun)\r\nif (tty_insert_flip_char(tport, 0, TTY_OVERRUN) == 0)\r\n++port->icount.buf_overrun;\r\n}
