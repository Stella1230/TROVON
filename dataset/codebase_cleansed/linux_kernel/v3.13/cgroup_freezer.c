static inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\r\n{\r\nreturn css ? container_of(css, struct freezer, css) : NULL;\r\n}\r\nstatic inline struct freezer *task_freezer(struct task_struct *task)\r\n{\r\nreturn css_freezer(task_css(task, freezer_subsys_id));\r\n}\r\nstatic struct freezer *parent_freezer(struct freezer *freezer)\r\n{\r\nreturn css_freezer(css_parent(&freezer->css));\r\n}\r\nbool cgroup_freezing(struct task_struct *task)\r\n{\r\nbool ret;\r\nrcu_read_lock();\r\nret = task_freezer(task)->state & CGROUP_FREEZING;\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic const char *freezer_state_strs(unsigned int state)\r\n{\r\nif (state & CGROUP_FROZEN)\r\nreturn "FROZEN";\r\nif (state & CGROUP_FREEZING)\r\nreturn "FREEZING";\r\nreturn "THAWED";\r\n}\r\nstatic struct cgroup_subsys_state *\r\nfreezer_css_alloc(struct cgroup_subsys_state *parent_css)\r\n{\r\nstruct freezer *freezer;\r\nfreezer = kzalloc(sizeof(struct freezer), GFP_KERNEL);\r\nif (!freezer)\r\nreturn ERR_PTR(-ENOMEM);\r\nspin_lock_init(&freezer->lock);\r\nreturn &freezer->css;\r\n}\r\nstatic int freezer_css_online(struct cgroup_subsys_state *css)\r\n{\r\nstruct freezer *freezer = css_freezer(css);\r\nstruct freezer *parent = parent_freezer(freezer);\r\nif (parent)\r\nspin_lock_irq(&parent->lock);\r\nspin_lock_nested(&freezer->lock, SINGLE_DEPTH_NESTING);\r\nfreezer->state |= CGROUP_FREEZER_ONLINE;\r\nif (parent && (parent->state & CGROUP_FREEZING)) {\r\nfreezer->state |= CGROUP_FREEZING_PARENT | CGROUP_FROZEN;\r\natomic_inc(&system_freezing_cnt);\r\n}\r\nspin_unlock(&freezer->lock);\r\nif (parent)\r\nspin_unlock_irq(&parent->lock);\r\nreturn 0;\r\n}\r\nstatic void freezer_css_offline(struct cgroup_subsys_state *css)\r\n{\r\nstruct freezer *freezer = css_freezer(css);\r\nspin_lock_irq(&freezer->lock);\r\nif (freezer->state & CGROUP_FREEZING)\r\natomic_dec(&system_freezing_cnt);\r\nfreezer->state = 0;\r\nspin_unlock_irq(&freezer->lock);\r\n}\r\nstatic void freezer_css_free(struct cgroup_subsys_state *css)\r\n{\r\nkfree(css_freezer(css));\r\n}\r\nstatic void freezer_attach(struct cgroup_subsys_state *new_css,\r\nstruct cgroup_taskset *tset)\r\n{\r\nstruct freezer *freezer = css_freezer(new_css);\r\nstruct task_struct *task;\r\nbool clear_frozen = false;\r\nspin_lock_irq(&freezer->lock);\r\ncgroup_taskset_for_each(task, new_css, tset) {\r\nif (!(freezer->state & CGROUP_FREEZING)) {\r\n__thaw_task(task);\r\n} else {\r\nfreeze_task(task);\r\nfreezer->state &= ~CGROUP_FROZEN;\r\nclear_frozen = true;\r\n}\r\n}\r\nspin_unlock_irq(&freezer->lock);\r\nwhile (clear_frozen && (freezer = parent_freezer(freezer))) {\r\nspin_lock_irq(&freezer->lock);\r\nfreezer->state &= ~CGROUP_FROZEN;\r\nclear_frozen = freezer->state & CGROUP_FREEZING;\r\nspin_unlock_irq(&freezer->lock);\r\n}\r\n}\r\nstatic void freezer_fork(struct task_struct *task)\r\n{\r\nstruct freezer *freezer;\r\nrcu_read_lock();\r\nfreezer = task_freezer(task);\r\nif (!parent_freezer(freezer))\r\ngoto out;\r\nspin_lock_irq(&freezer->lock);\r\nif (freezer->state & CGROUP_FREEZING)\r\nfreeze_task(task);\r\nspin_unlock_irq(&freezer->lock);\r\nout:\r\nrcu_read_unlock();\r\n}\r\nstatic void update_if_frozen(struct cgroup_subsys_state *css)\r\n{\r\nstruct freezer *freezer = css_freezer(css);\r\nstruct cgroup_subsys_state *pos;\r\nstruct css_task_iter it;\r\nstruct task_struct *task;\r\nWARN_ON_ONCE(!rcu_read_lock_held());\r\nspin_lock_irq(&freezer->lock);\r\nif (!(freezer->state & CGROUP_FREEZING) ||\r\n(freezer->state & CGROUP_FROZEN))\r\ngoto out_unlock;\r\ncss_for_each_child(pos, css) {\r\nstruct freezer *child = css_freezer(pos);\r\nif ((child->state & CGROUP_FREEZER_ONLINE) &&\r\n!(child->state & CGROUP_FROZEN))\r\ngoto out_unlock;\r\n}\r\ncss_task_iter_start(css, &it);\r\nwhile ((task = css_task_iter_next(&it))) {\r\nif (freezing(task)) {\r\nif (!frozen(task) && !freezer_should_skip(task))\r\ngoto out_iter_end;\r\n}\r\n}\r\nfreezer->state |= CGROUP_FROZEN;\r\nout_iter_end:\r\ncss_task_iter_end(&it);\r\nout_unlock:\r\nspin_unlock_irq(&freezer->lock);\r\n}\r\nstatic int freezer_read(struct cgroup_subsys_state *css, struct cftype *cft,\r\nstruct seq_file *m)\r\n{\r\nstruct cgroup_subsys_state *pos;\r\nrcu_read_lock();\r\ncss_for_each_descendant_post(pos, css)\r\nupdate_if_frozen(pos);\r\nrcu_read_unlock();\r\nseq_puts(m, freezer_state_strs(css_freezer(css)->state));\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic void freeze_cgroup(struct freezer *freezer)\r\n{\r\nstruct css_task_iter it;\r\nstruct task_struct *task;\r\ncss_task_iter_start(&freezer->css, &it);\r\nwhile ((task = css_task_iter_next(&it)))\r\nfreeze_task(task);\r\ncss_task_iter_end(&it);\r\n}\r\nstatic void unfreeze_cgroup(struct freezer *freezer)\r\n{\r\nstruct css_task_iter it;\r\nstruct task_struct *task;\r\ncss_task_iter_start(&freezer->css, &it);\r\nwhile ((task = css_task_iter_next(&it)))\r\n__thaw_task(task);\r\ncss_task_iter_end(&it);\r\n}\r\nstatic void freezer_apply_state(struct freezer *freezer, bool freeze,\r\nunsigned int state)\r\n{\r\nlockdep_assert_held(&freezer->lock);\r\nif (!(freezer->state & CGROUP_FREEZER_ONLINE))\r\nreturn;\r\nif (freeze) {\r\nif (!(freezer->state & CGROUP_FREEZING))\r\natomic_inc(&system_freezing_cnt);\r\nfreezer->state |= state;\r\nfreeze_cgroup(freezer);\r\n} else {\r\nbool was_freezing = freezer->state & CGROUP_FREEZING;\r\nfreezer->state &= ~state;\r\nif (!(freezer->state & CGROUP_FREEZING)) {\r\nif (was_freezing)\r\natomic_dec(&system_freezing_cnt);\r\nfreezer->state &= ~CGROUP_FROZEN;\r\nunfreeze_cgroup(freezer);\r\n}\r\n}\r\n}\r\nstatic void freezer_change_state(struct freezer *freezer, bool freeze)\r\n{\r\nstruct cgroup_subsys_state *pos;\r\nrcu_read_lock();\r\ncss_for_each_descendant_pre(pos, &freezer->css) {\r\nstruct freezer *pos_f = css_freezer(pos);\r\nstruct freezer *parent = parent_freezer(pos_f);\r\nspin_lock_irq(&pos_f->lock);\r\nif (pos_f == freezer) {\r\nfreezer_apply_state(pos_f, freeze,\r\nCGROUP_FREEZING_SELF);\r\n} else {\r\nfreezer_apply_state(pos_f,\r\nparent->state & CGROUP_FREEZING,\r\nCGROUP_FREEZING_PARENT);\r\n}\r\nspin_unlock_irq(&pos_f->lock);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic int freezer_write(struct cgroup_subsys_state *css, struct cftype *cft,\r\nconst char *buffer)\r\n{\r\nbool freeze;\r\nif (strcmp(buffer, freezer_state_strs(0)) == 0)\r\nfreeze = false;\r\nelse if (strcmp(buffer, freezer_state_strs(CGROUP_FROZEN)) == 0)\r\nfreeze = true;\r\nelse\r\nreturn -EINVAL;\r\nfreezer_change_state(css_freezer(css), freeze);\r\nreturn 0;\r\n}\r\nstatic u64 freezer_self_freezing_read(struct cgroup_subsys_state *css,\r\nstruct cftype *cft)\r\n{\r\nstruct freezer *freezer = css_freezer(css);\r\nreturn (bool)(freezer->state & CGROUP_FREEZING_SELF);\r\n}\r\nstatic u64 freezer_parent_freezing_read(struct cgroup_subsys_state *css,\r\nstruct cftype *cft)\r\n{\r\nstruct freezer *freezer = css_freezer(css);\r\nreturn (bool)(freezer->state & CGROUP_FREEZING_PARENT);\r\n}
