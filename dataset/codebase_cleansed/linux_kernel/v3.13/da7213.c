static int da7213_get_alc_data(struct snd_soc_codec *codec, u8 reg_val)\r\n{\r\nint mid_data, top_data;\r\nint sum = 0;\r\nu8 iteration;\r\nfor (iteration = 0; iteration < DA7213_ALC_AVG_ITERATIONS;\r\niteration++) {\r\nsnd_soc_write(codec, DA7213_ALC_CIC_OP_LVL_CTRL, reg_val);\r\nsnd_soc_write(codec, DA7213_ALC_CIC_OP_LVL_CTRL,\r\nreg_val | DA7213_ALC_DATA_MIDDLE);\r\nmid_data = snd_soc_read(codec, DA7213_ALC_CIC_OP_LVL_DATA);\r\nsnd_soc_write(codec, DA7213_ALC_CIC_OP_LVL_CTRL,\r\nreg_val | DA7213_ALC_DATA_TOP);\r\ntop_data = snd_soc_read(codec, DA7213_ALC_CIC_OP_LVL_DATA);\r\nsum += ((mid_data << 8) | (top_data << 16));\r\n}\r\nreturn sum / DA7213_ALC_AVG_ITERATIONS;\r\n}\r\nstatic void da7213_alc_calib_man(struct snd_soc_codec *codec)\r\n{\r\nu8 reg_val;\r\nint avg_left_data, avg_right_data, offset_l, offset_r;\r\navg_left_data = da7213_get_alc_data(codec,\r\nDA7213_ALC_CIC_OP_CHANNEL_LEFT);\r\navg_right_data = da7213_get_alc_data(codec,\r\nDA7213_ALC_CIC_OP_CHANNEL_RIGHT);\r\noffset_l = -avg_left_data;\r\noffset_r = -avg_right_data;\r\nreg_val = (offset_l & DA7213_ALC_OFFSET_15_8) >> 8;\r\nsnd_soc_write(codec, DA7213_ALC_OFFSET_MAN_M_L, reg_val);\r\nreg_val = (offset_l & DA7213_ALC_OFFSET_19_16) >> 16;\r\nsnd_soc_write(codec, DA7213_ALC_OFFSET_MAN_U_L, reg_val);\r\nreg_val = (offset_r & DA7213_ALC_OFFSET_15_8) >> 8;\r\nsnd_soc_write(codec, DA7213_ALC_OFFSET_MAN_M_R, reg_val);\r\nreg_val = (offset_r & DA7213_ALC_OFFSET_19_16) >> 16;\r\nsnd_soc_write(codec, DA7213_ALC_OFFSET_MAN_U_R, reg_val);\r\nsnd_soc_update_bits(codec, DA7213_ALC_CTRL1,\r\nDA7213_ALC_OFFSET_EN | DA7213_ALC_SYNC_MODE,\r\nDA7213_ALC_OFFSET_EN | DA7213_ALC_SYNC_MODE);\r\n}\r\nstatic void da7213_alc_calib_auto(struct snd_soc_codec *codec)\r\n{\r\nu8 alc_ctrl1;\r\nsnd_soc_update_bits(codec, DA7213_ALC_CTRL1, DA7213_ALC_AUTO_CALIB_EN,\r\nDA7213_ALC_AUTO_CALIB_EN);\r\ndo {\r\nalc_ctrl1 = snd_soc_read(codec, DA7213_ALC_CTRL1);\r\n} while (alc_ctrl1 & DA7213_ALC_AUTO_CALIB_EN);\r\nif (alc_ctrl1 & DA7213_ALC_CALIB_OVERFLOW) {\r\ndev_warn(codec->dev,\r\n"ALC auto calibration failed with overflow\n");\r\nsnd_soc_update_bits(codec, DA7213_ALC_CTRL1,\r\nDA7213_ALC_OFFSET_EN | DA7213_ALC_SYNC_MODE,\r\n0);\r\n} else {\r\nsnd_soc_update_bits(codec, DA7213_ALC_CTRL1,\r\nDA7213_ALC_OFFSET_EN | DA7213_ALC_SYNC_MODE,\r\nDA7213_ALC_OFFSET_EN | DA7213_ALC_SYNC_MODE);\r\n}\r\n}\r\nstatic void da7213_alc_calib(struct snd_soc_codec *codec)\r\n{\r\nstruct da7213_priv *da7213 = snd_soc_codec_get_drvdata(codec);\r\nu8 adc_l_ctrl, adc_r_ctrl;\r\nu8 mixin_l_sel, mixin_r_sel;\r\nu8 mic_1_ctrl, mic_2_ctrl;\r\nadc_l_ctrl = snd_soc_read(codec, DA7213_ADC_L_CTRL);\r\nadc_r_ctrl = snd_soc_read(codec, DA7213_ADC_R_CTRL);\r\nmixin_l_sel = snd_soc_read(codec, DA7213_MIXIN_L_SELECT);\r\nmixin_r_sel = snd_soc_read(codec, DA7213_MIXIN_R_SELECT);\r\nmic_1_ctrl = snd_soc_read(codec, DA7213_MIC_1_CTRL);\r\nmic_2_ctrl = snd_soc_read(codec, DA7213_MIC_2_CTRL);\r\nsnd_soc_update_bits(codec, DA7213_ADC_L_CTRL, DA7213_ADC_EN,\r\nDA7213_ADC_EN);\r\nsnd_soc_update_bits(codec, DA7213_ADC_R_CTRL, DA7213_ADC_EN,\r\nDA7213_ADC_EN);\r\nsnd_soc_update_bits(codec, DA7213_MIXIN_L_SELECT,\r\nDA7213_MIXIN_L_MIX_SELECT_MIC_1 |\r\nDA7213_MIXIN_L_MIX_SELECT_MIC_2,\r\nDA7213_MIXIN_L_MIX_SELECT_MIC_1 |\r\nDA7213_MIXIN_L_MIX_SELECT_MIC_2);\r\nsnd_soc_update_bits(codec, DA7213_MIXIN_R_SELECT,\r\nDA7213_MIXIN_R_MIX_SELECT_MIC_2 |\r\nDA7213_MIXIN_R_MIX_SELECT_MIC_1,\r\nDA7213_MIXIN_R_MIX_SELECT_MIC_2 |\r\nDA7213_MIXIN_R_MIX_SELECT_MIC_1);\r\nsnd_soc_update_bits(codec, DA7213_MIC_1_CTRL, DA7213_MUTE_EN,\r\nDA7213_MUTE_EN);\r\nsnd_soc_update_bits(codec, DA7213_MIC_2_CTRL, DA7213_MUTE_EN,\r\nDA7213_MUTE_EN);\r\nif (da7213->alc_calib_auto)\r\nda7213_alc_calib_auto(codec);\r\nelse\r\nda7213_alc_calib_man(codec);\r\nsnd_soc_write(codec, DA7213_MIXIN_L_SELECT, mixin_l_sel);\r\nsnd_soc_write(codec, DA7213_MIXIN_R_SELECT, mixin_r_sel);\r\nsnd_soc_write(codec, DA7213_ADC_L_CTRL, adc_l_ctrl);\r\nsnd_soc_write(codec, DA7213_ADC_R_CTRL, adc_r_ctrl);\r\nsnd_soc_write(codec, DA7213_MIC_1_CTRL, mic_1_ctrl);\r\nsnd_soc_write(codec, DA7213_MIC_2_CTRL, mic_2_ctrl);\r\n}\r\nstatic int da7213_put_mixin_gain(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct da7213_priv *da7213 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = snd_soc_put_volsw_2r(kcontrol, ucontrol);\r\nif ((!ret) && (da7213->alc_en))\r\nda7213_alc_calib(codec);\r\nreturn ret;\r\n}\r\nstatic int da7213_put_alc_sw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct da7213_priv *da7213 = snd_soc_codec_get_drvdata(codec);\r\nif (ucontrol->value.integer.value[0] ||\r\nucontrol->value.integer.value[1]) {\r\nif (!da7213->alc_en) {\r\nda7213_alc_calib(codec);\r\nda7213->alc_en = true;\r\n}\r\n} else {\r\nda7213->alc_en = false;\r\n}\r\nreturn snd_soc_put_volsw(kcontrol, ucontrol);\r\n}\r\nstatic bool da7213_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase DA7213_STATUS1:\r\ncase DA7213_PLL_STATUS:\r\ncase DA7213_AUX_L_GAIN_STATUS:\r\ncase DA7213_AUX_R_GAIN_STATUS:\r\ncase DA7213_MIC_1_GAIN_STATUS:\r\ncase DA7213_MIC_2_GAIN_STATUS:\r\ncase DA7213_MIXIN_L_GAIN_STATUS:\r\ncase DA7213_MIXIN_R_GAIN_STATUS:\r\ncase DA7213_ADC_L_GAIN_STATUS:\r\ncase DA7213_ADC_R_GAIN_STATUS:\r\ncase DA7213_DAC_L_GAIN_STATUS:\r\ncase DA7213_DAC_R_GAIN_STATUS:\r\ncase DA7213_HP_L_GAIN_STATUS:\r\ncase DA7213_HP_R_GAIN_STATUS:\r\ncase DA7213_LINE_GAIN_STATUS:\r\ncase DA7213_ALC_CTRL1:\r\ncase DA7213_ALC_OFFSET_AUTO_M_L:\r\ncase DA7213_ALC_OFFSET_AUTO_U_L:\r\ncase DA7213_ALC_OFFSET_AUTO_M_R:\r\ncase DA7213_ALC_OFFSET_AUTO_U_R:\r\ncase DA7213_ALC_CIC_OP_LVL_DATA:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int da7213_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 dai_ctrl = 0;\r\nu8 fs;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\ndai_ctrl |= DA7213_DAI_WORD_LENGTH_S16_LE;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\ndai_ctrl |= DA7213_DAI_WORD_LENGTH_S20_LE;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\ndai_ctrl |= DA7213_DAI_WORD_LENGTH_S24_LE;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\ndai_ctrl |= DA7213_DAI_WORD_LENGTH_S32_LE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\nfs = DA7213_SR_8000;\r\nbreak;\r\ncase 11025:\r\nfs = DA7213_SR_11025;\r\nbreak;\r\ncase 12000:\r\nfs = DA7213_SR_12000;\r\nbreak;\r\ncase 16000:\r\nfs = DA7213_SR_16000;\r\nbreak;\r\ncase 22050:\r\nfs = DA7213_SR_22050;\r\nbreak;\r\ncase 32000:\r\nfs = DA7213_SR_32000;\r\nbreak;\r\ncase 44100:\r\nfs = DA7213_SR_44100;\r\nbreak;\r\ncase 48000:\r\nfs = DA7213_SR_48000;\r\nbreak;\r\ncase 88200:\r\nfs = DA7213_SR_88200;\r\nbreak;\r\ncase 96000:\r\nfs = DA7213_SR_96000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, DA7213_DAI_CTRL, DA7213_DAI_WORD_LENGTH_MASK,\r\ndai_ctrl);\r\nsnd_soc_write(codec, DA7213_SR, fs);\r\nreturn 0;\r\n}\r\nstatic int da7213_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct da7213_priv *da7213 = snd_soc_codec_get_drvdata(codec);\r\nu8 dai_clk_mode = 0, dai_ctrl = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ndai_clk_mode |= DA7213_DAI_CLK_EN_MASTER_MODE;\r\nda7213->master = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\ndai_clk_mode |= DA7213_DAI_CLK_EN_SLAVE_MODE;\r\nda7213->master = false;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\ndai_clk_mode |= DA7213_DAI_WCLK_POL_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\ndai_clk_mode |= DA7213_DAI_CLK_POL_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\ndai_clk_mode |= DA7213_DAI_WCLK_POL_INV | DA7213_DAI_CLK_POL_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ndai_ctrl |= DA7213_DAI_FORMAT_I2S_MODE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ndai_ctrl |= DA7213_DAI_FORMAT_LEFT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ndai_ctrl |= DA7213_DAI_FORMAT_RIGHT_J;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndai_clk_mode |= DA7213_DAI_BCLKS_PER_WCLK_32;\r\nsnd_soc_write(codec, DA7213_DAI_CLK_MODE, dai_clk_mode);\r\nsnd_soc_update_bits(codec, DA7213_DAI_CTRL, DA7213_DAI_FORMAT_MASK,\r\ndai_ctrl);\r\nreturn 0;\r\n}\r\nstatic int da7213_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nif (mute) {\r\nsnd_soc_update_bits(codec, DA7213_DAC_L_CTRL,\r\nDA7213_MUTE_EN, DA7213_MUTE_EN);\r\nsnd_soc_update_bits(codec, DA7213_DAC_R_CTRL,\r\nDA7213_MUTE_EN, DA7213_MUTE_EN);\r\n} else {\r\nsnd_soc_update_bits(codec, DA7213_DAC_L_CTRL,\r\nDA7213_MUTE_EN, 0);\r\nsnd_soc_update_bits(codec, DA7213_DAC_R_CTRL,\r\nDA7213_MUTE_EN, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int da7213_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct da7213_priv *da7213 = snd_soc_codec_get_drvdata(codec);\r\nswitch (clk_id) {\r\ncase DA7213_CLKSRC_MCLK:\r\nif ((freq == 32768) ||\r\n((freq >= 5000000) && (freq <= 54000000))) {\r\nda7213->mclk_rate = freq;\r\nreturn 0;\r\n} else {\r\ndev_err(codec_dai->dev, "Unsupported MCLK value %d\n",\r\nfreq);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(codec_dai->dev, "Unknown clock source %d\n", clk_id);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int da7213_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\r\nint source, unsigned int fref, unsigned int fout)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct da7213_priv *da7213 = snd_soc_codec_get_drvdata(codec);\r\nu8 pll_ctrl, indiv_bits, indiv;\r\nu8 pll_frac_top, pll_frac_bot, pll_integer;\r\nu32 freq_ref;\r\nu64 frac_div;\r\nsnd_soc_write(codec, DA7213_PLL_CTRL, 0);\r\npll_ctrl = 0;\r\nif ((da7213->mclk_rate == 32768) && (source == DA7213_SYSCLK_PLL)) {\r\nindiv_bits = DA7213_PLL_INDIV_10_20_MHZ;\r\nindiv = DA7213_PLL_INDIV_10_20_MHZ_VAL;\r\nfreq_ref = 3750000;\r\npll_ctrl |= DA7213_PLL_32K_MODE;\r\n} else {\r\nif (da7213->mclk_rate < 5000000) {\r\ngoto pll_err;\r\n} else if (da7213->mclk_rate <= 10000000) {\r\nindiv_bits = DA7213_PLL_INDIV_5_10_MHZ;\r\nindiv = DA7213_PLL_INDIV_5_10_MHZ_VAL;\r\n} else if (da7213->mclk_rate <= 20000000) {\r\nindiv_bits = DA7213_PLL_INDIV_10_20_MHZ;\r\nindiv = DA7213_PLL_INDIV_10_20_MHZ_VAL;\r\n} else if (da7213->mclk_rate <= 40000000) {\r\nindiv_bits = DA7213_PLL_INDIV_20_40_MHZ;\r\nindiv = DA7213_PLL_INDIV_20_40_MHZ_VAL;\r\n} else if (da7213->mclk_rate <= 54000000) {\r\nindiv_bits = DA7213_PLL_INDIV_40_54_MHZ;\r\nindiv = DA7213_PLL_INDIV_40_54_MHZ_VAL;\r\n} else {\r\ngoto pll_err;\r\n}\r\nfreq_ref = (da7213->mclk_rate / indiv);\r\n}\r\npll_ctrl |= indiv_bits;\r\nif (source == DA7213_SYSCLK_MCLK) {\r\nsnd_soc_write(codec, DA7213_PLL_CTRL, pll_ctrl);\r\nreturn 0;\r\n}\r\nif (!da7213->master && da7213->srm_en) {\r\nfout = DA7213_PLL_FREQ_OUT_94310400;\r\npll_ctrl |= DA7213_PLL_SRM_EN;\r\n}\r\nif (da7213->mclk_squarer_en)\r\npll_ctrl |= DA7213_PLL_MCLK_SQR_EN;\r\npll_integer = fout / freq_ref;\r\nfrac_div = (u64)(fout % freq_ref) * 8192ULL;\r\ndo_div(frac_div, freq_ref);\r\npll_frac_top = (frac_div >> DA7213_BYTE_SHIFT) & DA7213_BYTE_MASK;\r\npll_frac_bot = (frac_div) & DA7213_BYTE_MASK;\r\nsnd_soc_write(codec, DA7213_PLL_FRAC_TOP, pll_frac_top);\r\nsnd_soc_write(codec, DA7213_PLL_FRAC_BOT, pll_frac_bot);\r\nsnd_soc_write(codec, DA7213_PLL_INTEGER, pll_integer);\r\npll_ctrl |= DA7213_PLL_EN;\r\nsnd_soc_write(codec, DA7213_PLL_CTRL, pll_ctrl);\r\nreturn 0;\r\npll_err:\r\ndev_err(codec_dai->dev, "Unsupported PLL input frequency %d\n",\r\nda7213->mclk_rate);\r\nreturn -EINVAL;\r\n}\r\nstatic int da7213_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nsnd_soc_update_bits(codec, DA7213_REFERENCES,\r\nDA7213_VMID_EN | DA7213_BIAS_EN,\r\nDA7213_VMID_EN | DA7213_BIAS_EN);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, DA7213_REFERENCES,\r\nDA7213_VMID_EN | DA7213_BIAS_EN, 0);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int da7213_probe(struct snd_soc_codec *codec)\r\n{\r\nint ret;\r\nstruct da7213_priv *da7213 = snd_soc_codec_get_drvdata(codec);\r\nstruct da7213_platform_data *pdata = da7213->pdata;\r\ncodec->control_data = da7213->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_REGMAP);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nsnd_soc_update_bits(codec, DA7213_ALC_CTRL1,\r\nDA7213_ALC_CALIB_MODE_MAN, 0);\r\nda7213->alc_calib_auto = true;\r\nda7213->srm_en = true;\r\nsnd_soc_update_bits(codec, DA7213_AUX_L_CTRL,\r\nDA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\r\nsnd_soc_update_bits(codec, DA7213_AUX_R_CTRL,\r\nDA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\r\nsnd_soc_update_bits(codec, DA7213_MIXIN_L_CTRL,\r\nDA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\r\nsnd_soc_update_bits(codec, DA7213_MIXIN_R_CTRL,\r\nDA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\r\nsnd_soc_update_bits(codec, DA7213_ADC_L_CTRL,\r\nDA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\r\nsnd_soc_update_bits(codec, DA7213_ADC_R_CTRL,\r\nDA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\r\nsnd_soc_update_bits(codec, DA7213_DAC_L_CTRL,\r\nDA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\r\nsnd_soc_update_bits(codec, DA7213_DAC_R_CTRL,\r\nDA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\r\nsnd_soc_update_bits(codec, DA7213_HP_L_CTRL,\r\nDA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\r\nsnd_soc_update_bits(codec, DA7213_HP_R_CTRL,\r\nDA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\r\nsnd_soc_update_bits(codec, DA7213_LINE_CTRL,\r\nDA7213_GAIN_RAMP_EN, DA7213_GAIN_RAMP_EN);\r\nsnd_soc_update_bits(codec, DA7213_MIXIN_L_CTRL,\r\nDA7213_MIXIN_MIX_EN, DA7213_MIXIN_MIX_EN);\r\nsnd_soc_update_bits(codec, DA7213_MIXIN_R_CTRL,\r\nDA7213_MIXIN_MIX_EN, DA7213_MIXIN_MIX_EN);\r\nsnd_soc_update_bits(codec, DA7213_MIXOUT_L_CTRL,\r\nDA7213_MIXOUT_MIX_EN, DA7213_MIXOUT_MIX_EN);\r\nsnd_soc_update_bits(codec, DA7213_MIXOUT_R_CTRL,\r\nDA7213_MIXOUT_MIX_EN, DA7213_MIXOUT_MIX_EN);\r\nsnd_soc_update_bits(codec, DA7213_HP_L_CTRL,\r\nDA7213_HP_AMP_OE, DA7213_HP_AMP_OE);\r\nsnd_soc_update_bits(codec, DA7213_HP_R_CTRL,\r\nDA7213_HP_AMP_OE, DA7213_HP_AMP_OE);\r\nsnd_soc_update_bits(codec, DA7213_LINE_CTRL,\r\nDA7213_LINE_AMP_OE, DA7213_LINE_AMP_OE);\r\nif (da7213->pdata) {\r\nu8 micbias_lvl = 0, dmic_cfg = 0;\r\nswitch (pdata->micbias1_lvl) {\r\ncase DA7213_MICBIAS_1_6V:\r\ncase DA7213_MICBIAS_2_2V:\r\ncase DA7213_MICBIAS_2_5V:\r\ncase DA7213_MICBIAS_3_0V:\r\nmicbias_lvl |= (pdata->micbias1_lvl <<\r\nDA7213_MICBIAS1_LEVEL_SHIFT);\r\nbreak;\r\n}\r\nswitch (pdata->micbias2_lvl) {\r\ncase DA7213_MICBIAS_1_6V:\r\ncase DA7213_MICBIAS_2_2V:\r\ncase DA7213_MICBIAS_2_5V:\r\ncase DA7213_MICBIAS_3_0V:\r\nmicbias_lvl |= (pdata->micbias2_lvl <<\r\nDA7213_MICBIAS2_LEVEL_SHIFT);\r\nbreak;\r\n}\r\nsnd_soc_update_bits(codec, DA7213_MICBIAS_CTRL,\r\nDA7213_MICBIAS1_LEVEL_MASK |\r\nDA7213_MICBIAS2_LEVEL_MASK, micbias_lvl);\r\nswitch (pdata->dmic_data_sel) {\r\ncase DA7213_DMIC_DATA_LFALL_RRISE:\r\ncase DA7213_DMIC_DATA_LRISE_RFALL:\r\ndmic_cfg |= (pdata->dmic_data_sel <<\r\nDA7213_DMIC_DATA_SEL_SHIFT);\r\nbreak;\r\n}\r\nswitch (pdata->dmic_samplephase) {\r\ncase DA7213_DMIC_SAMPLE_ON_CLKEDGE:\r\ncase DA7213_DMIC_SAMPLE_BETWEEN_CLKEDGE:\r\ndmic_cfg |= (pdata->dmic_samplephase <<\r\nDA7213_DMIC_SAMPLEPHASE_SHIFT);\r\nbreak;\r\n}\r\nswitch (pdata->dmic_clk_rate) {\r\ncase DA7213_DMIC_CLK_3_0MHZ:\r\ncase DA7213_DMIC_CLK_1_5MHZ:\r\ndmic_cfg |= (pdata->dmic_clk_rate <<\r\nDA7213_DMIC_CLK_RATE_SHIFT);\r\nbreak;\r\n}\r\nsnd_soc_update_bits(codec, DA7213_MIC_CONFIG,\r\nDA7213_DMIC_DATA_SEL_MASK |\r\nDA7213_DMIC_SAMPLEPHASE_MASK |\r\nDA7213_DMIC_CLK_RATE_MASK, dmic_cfg);\r\nda7213->mclk_squarer_en = pdata->mclk_squaring;\r\n}\r\nreturn 0;\r\n}\r\nstatic int da7213_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct da7213_priv *da7213;\r\nstruct da7213_platform_data *pdata = dev_get_platdata(&i2c->dev);\r\nint ret;\r\nda7213 = devm_kzalloc(&i2c->dev, sizeof(struct da7213_priv),\r\nGFP_KERNEL);\r\nif (!da7213)\r\nreturn -ENOMEM;\r\nif (pdata)\r\nda7213->pdata = pdata;\r\ni2c_set_clientdata(i2c, da7213);\r\nda7213->regmap = devm_regmap_init_i2c(i2c, &da7213_regmap_config);\r\nif (IS_ERR(da7213->regmap)) {\r\nret = PTR_ERR(da7213->regmap);\r\ndev_err(&i2c->dev, "regmap_init() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_da7213, &da7213_dai, 1);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to register da7213 codec: %d\n",\r\nret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int da7213_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
