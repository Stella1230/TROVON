static void __init em_x270_init_dm9000(void)\r\n{\r\nem_x270_dm9000_platdata.flags |= dm9000_flags;\r\nplatform_device_register(&em_x270_dm9000);\r\n}\r\nstatic inline void em_x270_init_dm9000(void) {}\r\nstatic void __init em_x270_init_rtc(void)\r\n{\r\nplatform_device_register(&em_x270_rtc);\r\n}\r\nstatic inline void em_x270_init_rtc(void) {}\r\nstatic inline void nand_cs_on(void)\r\n{\r\ngpio_set_value(GPIO11_NAND_CS, 0);\r\n}\r\nstatic void nand_cs_off(void)\r\n{\r\ndsb();\r\ngpio_set_value(GPIO11_NAND_CS, 1);\r\n}\r\nstatic void em_x270_nand_cmd_ctl(struct mtd_info *mtd, int dat,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nunsigned long nandaddr = (unsigned long)this->IO_ADDR_W;\r\ndsb();\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nif (ctrl & NAND_ALE)\r\nnandaddr |= (1 << 3);\r\nelse\r\nnandaddr &= ~(1 << 3);\r\nif (ctrl & NAND_CLE)\r\nnandaddr |= (1 << 2);\r\nelse\r\nnandaddr &= ~(1 << 2);\r\nif (ctrl & NAND_NCE)\r\nnand_cs_on();\r\nelse\r\nnand_cs_off();\r\n}\r\ndsb();\r\nthis->IO_ADDR_W = (void __iomem *)nandaddr;\r\nif (dat != NAND_CMD_NONE)\r\nwritel(dat, this->IO_ADDR_W);\r\ndsb();\r\n}\r\nstatic int em_x270_nand_device_ready(struct mtd_info *mtd)\r\n{\r\ndsb();\r\nreturn gpio_get_value(nand_rb);\r\n}\r\nstatic void __init em_x270_init_nand(void)\r\n{\r\nint err;\r\nerr = gpio_request(GPIO11_NAND_CS, "NAND CS");\r\nif (err) {\r\npr_warning("EM-X270: failed to request NAND CS gpio\n");\r\nreturn;\r\n}\r\ngpio_direction_output(GPIO11_NAND_CS, 1);\r\nerr = gpio_request(nand_rb, "NAND R/B");\r\nif (err) {\r\npr_warning("EM-X270: failed to request NAND R/B gpio\n");\r\ngpio_free(GPIO11_NAND_CS);\r\nreturn;\r\n}\r\ngpio_direction_input(nand_rb);\r\nplatform_device_register(&em_x270_nand);\r\n}\r\nstatic inline void em_x270_init_nand(void) {}\r\nstatic void __init em_x270_init_nor(void)\r\n{\r\nplatform_device_register(&em_x270_physmap_flash);\r\n}\r\nstatic inline void em_x270_init_nor(void) {}\r\nstatic int em_x270_usb_hub_init(void)\r\n{\r\nint err;\r\nem_x270_usb_ldo = regulator_get(NULL, "vcc usb");\r\nif (IS_ERR(em_x270_usb_ldo))\r\nreturn PTR_ERR(em_x270_usb_ldo);\r\nerr = gpio_request(GPIO9_USB_VBUS_EN, "vbus en");\r\nif (err)\r\ngoto err_free_usb_ldo;\r\nerr = gpio_request(usb_hub_reset, "hub rst");\r\nif (err)\r\ngoto err_free_vbus_gpio;\r\ngpio_direction_output(usb_hub_reset, 1);\r\ngpio_direction_output(GPIO9_USB_VBUS_EN, 0);\r\nerr = regulator_enable(em_x270_usb_ldo);\r\nif (err)\r\ngoto err_free_rst_gpio;\r\ngpio_set_value(usb_hub_reset, 0);\r\ngpio_set_value(usb_hub_reset, 1);\r\nregulator_disable(em_x270_usb_ldo);\r\nerr = regulator_enable(em_x270_usb_ldo);\r\nif (err)\r\ngoto err_free_rst_gpio;\r\ngpio_set_value(usb_hub_reset, 0);\r\ngpio_set_value(GPIO9_USB_VBUS_EN, 1);\r\nreturn 0;\r\nerr_free_rst_gpio:\r\ngpio_free(usb_hub_reset);\r\nerr_free_vbus_gpio:\r\ngpio_free(GPIO9_USB_VBUS_EN);\r\nerr_free_usb_ldo:\r\nregulator_put(em_x270_usb_ldo);\r\nreturn err;\r\n}\r\nstatic int em_x270_ohci_init(struct device *dev)\r\n{\r\nint err;\r\nerr = em_x270_usb_hub_init();\r\nif (err)\r\npr_err("USB Hub initialization failed: %d\n", err);\r\nUP2OCR = UP2OCR_HXS | UP2OCR_HXOE;\r\nreturn 0;\r\n}\r\nstatic void em_x270_ohci_exit(struct device *dev)\r\n{\r\ngpio_free(usb_hub_reset);\r\ngpio_free(GPIO9_USB_VBUS_EN);\r\nif (!IS_ERR(em_x270_usb_ldo)) {\r\nif (regulator_is_enabled(em_x270_usb_ldo))\r\nregulator_disable(em_x270_usb_ldo);\r\nregulator_put(em_x270_usb_ldo);\r\n}\r\n}\r\nstatic void __init em_x270_init_ohci(void)\r\n{\r\npxa_set_ohci_info(&em_x270_ohci_platform_data);\r\n}\r\nstatic inline void em_x270_init_ohci(void) {}\r\nstatic int em_x270_mci_init(struct device *dev,\r\nirq_handler_t em_x270_detect_int,\r\nvoid *data)\r\n{\r\nint err;\r\nem_x270_sdio_ldo = regulator_get(dev, "vcc sdio");\r\nif (IS_ERR(em_x270_sdio_ldo)) {\r\ndev_err(dev, "can't request SDIO power supply: %ld\n",\r\nPTR_ERR(em_x270_sdio_ldo));\r\nreturn PTR_ERR(em_x270_sdio_ldo);\r\n}\r\nerr = request_irq(gpio_to_irq(mmc_cd), em_x270_detect_int,\r\nIRQF_DISABLED | IRQF_TRIGGER_RISING |\r\nIRQF_TRIGGER_FALLING,\r\n"MMC card detect", data);\r\nif (err) {\r\ndev_err(dev, "can't request MMC card detect IRQ: %d\n", err);\r\ngoto err_irq;\r\n}\r\nif (machine_is_em_x270()) {\r\nerr = gpio_request(GPIO95_MMC_WP, "MMC WP");\r\nif (err) {\r\ndev_err(dev, "can't request MMC write protect: %d\n",\r\nerr);\r\ngoto err_gpio_wp;\r\n}\r\ngpio_direction_input(GPIO95_MMC_WP);\r\n} else {\r\nerr = gpio_request(GPIO38_SD_PWEN, "sdio power");\r\nif (err) {\r\ndev_err(dev, "can't request MMC power control : %d\n",\r\nerr);\r\ngoto err_gpio_wp;\r\n}\r\ngpio_direction_output(GPIO38_SD_PWEN, 1);\r\n}\r\nreturn 0;\r\nerr_gpio_wp:\r\nfree_irq(gpio_to_irq(mmc_cd), data);\r\nerr_irq:\r\nregulator_put(em_x270_sdio_ldo);\r\nreturn err;\r\n}\r\nstatic int em_x270_mci_setpower(struct device *dev, unsigned int vdd)\r\n{\r\nstruct pxamci_platform_data* p_d = dev->platform_data;\r\nif ((1 << vdd) & p_d->ocr_mask) {\r\nint vdd_uV = (2000 + (vdd - __ffs(MMC_VDD_20_21)) * 100) * 1000;\r\nregulator_set_voltage(em_x270_sdio_ldo, vdd_uV, vdd_uV);\r\nreturn regulator_enable(em_x270_sdio_ldo);\r\n} else {\r\nregulator_disable(em_x270_sdio_ldo);\r\n}\r\nreturn 0;\r\n}\r\nstatic void em_x270_mci_exit(struct device *dev, void *data)\r\n{\r\nfree_irq(gpio_to_irq(mmc_cd), data);\r\nregulator_put(em_x270_sdio_ldo);\r\nif (machine_is_em_x270())\r\ngpio_free(GPIO95_MMC_WP);\r\nelse\r\ngpio_free(GPIO38_SD_PWEN);\r\n}\r\nstatic int em_x270_mci_get_ro(struct device *dev)\r\n{\r\nreturn gpio_get_value(GPIO95_MMC_WP);\r\n}\r\nstatic void __init em_x270_init_mmc(void)\r\n{\r\nif (machine_is_em_x270())\r\nem_x270_mci_platform_data.get_ro = em_x270_mci_get_ro;\r\npxa_set_mci_info(&em_x270_mci_platform_data);\r\n}\r\nstatic inline void em_x270_init_mmc(void) {}\r\nstatic void __init em_x270_init_lcd(void)\r\n{\r\npxa_set_fb_info(NULL, &em_x270_lcd);\r\n}\r\nstatic inline void em_x270_init_lcd(void) {}\r\nstatic int em_x270_libertas_setup(struct spi_device *spi)\r\n{\r\nint err = gpio_request(GPIO115_WLAN_PWEN, "WLAN PWEN");\r\nif (err)\r\nreturn err;\r\nerr = gpio_request(GPIO19_WLAN_STRAP, "WLAN STRAP");\r\nif (err)\r\ngoto err_free_pwen;\r\nif (machine_is_exeda()) {\r\nerr = gpio_request(GPIO37_WLAN_RST, "WLAN RST");\r\nif (err)\r\ngoto err_free_strap;\r\ngpio_direction_output(GPIO37_WLAN_RST, 1);\r\nmsleep(100);\r\n}\r\ngpio_direction_output(GPIO19_WLAN_STRAP, 1);\r\nmsleep(100);\r\npxa2xx_mfp_config(ARRAY_AND_SIZE(em_x270_libertas_pin_config));\r\ngpio_direction_output(GPIO115_WLAN_PWEN, 0);\r\nmsleep(100);\r\ngpio_set_value(GPIO115_WLAN_PWEN, 1);\r\nmsleep(100);\r\nspi->bits_per_word = 16;\r\nspi_setup(spi);\r\nreturn 0;\r\nerr_free_strap:\r\ngpio_free(GPIO19_WLAN_STRAP);\r\nerr_free_pwen:\r\ngpio_free(GPIO115_WLAN_PWEN);\r\nreturn err;\r\n}\r\nstatic int em_x270_libertas_teardown(struct spi_device *spi)\r\n{\r\ngpio_set_value(GPIO115_WLAN_PWEN, 0);\r\ngpio_free(GPIO115_WLAN_PWEN);\r\ngpio_free(GPIO19_WLAN_STRAP);\r\nif (machine_is_exeda()) {\r\ngpio_set_value(GPIO37_WLAN_RST, 0);\r\ngpio_free(GPIO37_WLAN_RST);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init em_x270_init_spi(void)\r\n{\r\npxa2xx_set_spi_info(1, &em_x270_spi_info);\r\npxa2xx_set_spi_info(2, &em_x270_spi_2_info);\r\nspi_register_board_info(ARRAY_AND_SIZE(em_x270_spi_devices));\r\n}\r\nstatic inline void em_x270_init_spi(void) {}\r\nstatic void __init em_x270_init_ac97(void)\r\n{\r\npxa_set_ac97_info(&em_x270_ac97_info);\r\n}\r\nstatic inline void em_x270_init_ac97(void) {}\r\nstatic void __init em_x270_init_keypad(void)\r\n{\r\nif (machine_is_em_x270())\r\npxa_set_keypad_info(&em_x270_module_keypad_info);\r\nelse\r\npxa_set_keypad_info(&em_x270_exeda_keypad_info);\r\n}\r\nstatic inline void em_x270_init_keypad(void) {}\r\nstatic void __init em_x270_init_gpio_keys(void)\r\n{\r\nplatform_device_register(&em_x270_gpio_keys);\r\n}\r\nstatic inline void em_x270_init_gpio_keys(void) {}\r\nstatic int em_x270_sensor_init(void)\r\n{\r\nint ret;\r\nret = gpio_request(cam_reset, "camera reset");\r\nif (ret)\r\nreturn ret;\r\ngpio_direction_output(cam_reset, 0);\r\nem_x270_camera_ldo = regulator_get(NULL, "vcc cam");\r\nif (em_x270_camera_ldo == NULL) {\r\ngpio_free(cam_reset);\r\nreturn -ENODEV;\r\n}\r\nret = regulator_enable(em_x270_camera_ldo);\r\nif (ret) {\r\nregulator_put(em_x270_camera_ldo);\r\ngpio_free(cam_reset);\r\nreturn ret;\r\n}\r\ngpio_set_value(cam_reset, 1);\r\nreturn 0;\r\n}\r\nstatic int em_x270_sensor_power(struct device *dev, int on)\r\n{\r\nint ret;\r\nint is_on = regulator_is_enabled(em_x270_camera_ldo);\r\nif (on == is_on)\r\nreturn 0;\r\ngpio_set_value(cam_reset, !on);\r\nif (on)\r\nret = regulator_enable(em_x270_camera_ldo);\r\nelse\r\nret = regulator_disable(em_x270_camera_ldo);\r\nif (ret)\r\nreturn ret;\r\ngpio_set_value(cam_reset, on);\r\nreturn 0;\r\n}\r\nstatic void __init em_x270_init_camera(void)\r\n{\r\nif (em_x270_sensor_init() == 0) {\r\npxa_set_camera_info(&em_x270_camera_platform_data);\r\nplatform_device_register(&em_x270_camera);\r\n}\r\n}\r\nstatic inline void em_x270_init_camera(void) {}\r\nstatic void __init em_x270_userspace_consumers_init(void)\r\n{\r\nplatform_add_devices(ARRAY_AND_SIZE(em_x270_userspace_consumers));\r\n}\r\nstatic void em_x270_battery_low(void)\r\n{\r\n#if defined(CONFIG_APM_EMULATION)\r\napm_queue_event(APM_LOW_BATTERY);\r\n#endif\r\n}\r\nstatic void em_x270_battery_critical(void)\r\n{\r\n#if defined(CONFIG_APM_EMULATION)\r\napm_queue_event(APM_CRITICAL_SUSPEND);\r\n#endif\r\n}\r\nstatic void __init em_x270_init_da9030(void)\r\n{\r\npxa27x_set_i2c_power_info(&em_x270_pwr_i2c_info);\r\ni2c_register_board_info(1, &em_x270_i2c_pmic_info, 1);\r\n}\r\nstatic void __init em_x270_init_i2c(void)\r\n{\r\npxa_set_i2c_info(&em_x270_i2c_info);\r\nif (machine_is_exeda())\r\ni2c_register_board_info(0, ARRAY_AND_SIZE(exeda_i2c_info));\r\n}\r\nstatic void __init em_x270_module_init(void)\r\n{\r\npxa2xx_mfp_config(ARRAY_AND_SIZE(em_x270_pin_config));\r\nmmc_cd = GPIO13_MMC_CD;\r\nnand_rb = GPIO56_NAND_RB;\r\ndm9000_flags = DM9000_PLATF_32BITONLY;\r\ncam_reset = GPIO93_CAM_RESET;\r\nusb_hub_reset = GPIO16_USB_HUB_RESET;\r\n}\r\nstatic void __init em_x270_exeda_init(void)\r\n{\r\npxa2xx_mfp_config(ARRAY_AND_SIZE(exeda_pin_config));\r\nmmc_cd = GPIO114_MMC_CD;\r\nnand_rb = GPIO20_NAND_RB;\r\ndm9000_flags = DM9000_PLATF_16BITONLY;\r\ncam_reset = GPIO130_CAM_RESET;\r\nusb_hub_reset = GPIO10_USB_HUB_RESET;\r\n}\r\nstatic void __init em_x270_init(void)\r\n{\r\npxa2xx_mfp_config(ARRAY_AND_SIZE(common_pin_config));\r\npxa_set_ffuart_info(NULL);\r\npxa_set_btuart_info(NULL);\r\npxa_set_stuart_info(NULL);\r\n#ifdef CONFIG_PM\r\npxa27x_set_pwrmode(PWRMODE_DEEPSLEEP);\r\n#endif\r\nif (machine_is_em_x270())\r\nem_x270_module_init();\r\nelse if (machine_is_exeda())\r\nem_x270_exeda_init();\r\nelse\r\npanic("Unsupported machine: %d\n", machine_arch_type);\r\nem_x270_init_da9030();\r\nem_x270_init_dm9000();\r\nem_x270_init_rtc();\r\nem_x270_init_nand();\r\nem_x270_init_nor();\r\nem_x270_init_lcd();\r\nem_x270_init_mmc();\r\nem_x270_init_ohci();\r\nem_x270_init_keypad();\r\nem_x270_init_gpio_keys();\r\nem_x270_init_ac97();\r\nem_x270_init_spi();\r\nem_x270_init_i2c();\r\nem_x270_init_camera();\r\nem_x270_userspace_consumers_init();\r\n}
