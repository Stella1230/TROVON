static void ctr_set_enable(u64 *state, int ctr_set)\r\n{\r\n*state |= cpumf_state_ctl[ctr_set] << CPUMF_LCCTL_ENABLE_SHIFT;\r\n}\r\nstatic void ctr_set_disable(u64 *state, int ctr_set)\r\n{\r\n*state &= ~(cpumf_state_ctl[ctr_set] << CPUMF_LCCTL_ENABLE_SHIFT);\r\n}\r\nstatic void ctr_set_start(u64 *state, int ctr_set)\r\n{\r\n*state |= cpumf_state_ctl[ctr_set] << CPUMF_LCCTL_ACTCTL_SHIFT;\r\n}\r\nstatic void ctr_set_stop(u64 *state, int ctr_set)\r\n{\r\n*state &= ~(cpumf_state_ctl[ctr_set] << CPUMF_LCCTL_ACTCTL_SHIFT);\r\n}\r\nstatic int get_counter_set(u64 event)\r\n{\r\nint set = -1;\r\nif (event < 32)\r\nset = CPUMF_CTR_SET_BASIC;\r\nelse if (event < 64)\r\nset = CPUMF_CTR_SET_USER;\r\nelse if (event < 128)\r\nset = CPUMF_CTR_SET_CRYPTO;\r\nelse if (event < 256)\r\nset = CPUMF_CTR_SET_EXT;\r\nreturn set;\r\n}\r\nstatic int validate_event(const struct hw_perf_event *hwc)\r\n{\r\nswitch (hwc->config_base) {\r\ncase CPUMF_CTR_SET_BASIC:\r\ncase CPUMF_CTR_SET_USER:\r\ncase CPUMF_CTR_SET_CRYPTO:\r\ncase CPUMF_CTR_SET_EXT:\r\nif ((hwc->config >= 6 && hwc->config <= 31) ||\r\n(hwc->config >= 38 && hwc->config <= 63) ||\r\n(hwc->config >= 80 && hwc->config <= 127))\r\nreturn -EOPNOTSUPP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int validate_ctr_version(const struct hw_perf_event *hwc)\r\n{\r\nstruct cpu_hw_events *cpuhw;\r\nint err = 0;\r\ncpuhw = &get_cpu_var(cpu_hw_events);\r\nswitch (hwc->config_base) {\r\ncase CPUMF_CTR_SET_BASIC:\r\ncase CPUMF_CTR_SET_USER:\r\nif (cpuhw->info.cfvn < 1)\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\ncase CPUMF_CTR_SET_CRYPTO:\r\ncase CPUMF_CTR_SET_EXT:\r\nif (cpuhw->info.csvn < 1)\r\nerr = -EOPNOTSUPP;\r\nif ((cpuhw->info.csvn == 1 && hwc->config > 159) ||\r\n(cpuhw->info.csvn == 2 && hwc->config > 175) ||\r\n(cpuhw->info.csvn > 2 && hwc->config > 255))\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nput_cpu_var(cpu_hw_events);\r\nreturn err;\r\n}\r\nstatic int validate_ctr_auth(const struct hw_perf_event *hwc)\r\n{\r\nstruct cpu_hw_events *cpuhw;\r\nu64 ctrs_state;\r\nint err = 0;\r\ncpuhw = &get_cpu_var(cpu_hw_events);\r\nctrs_state = cpumf_state_ctl[hwc->config_base];\r\nif (!(ctrs_state & cpuhw->info.auth_ctl))\r\nerr = -EPERM;\r\nput_cpu_var(cpu_hw_events);\r\nreturn err;\r\n}\r\nstatic void cpumf_pmu_enable(struct pmu *pmu)\r\n{\r\nstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\r\nint err;\r\nif (cpuhw->flags & PMU_F_ENABLED)\r\nreturn;\r\nerr = lcctl(cpuhw->state);\r\nif (err) {\r\npr_err("Enabling the performance measuring unit "\r\n"failed with rc=%x\n", err);\r\nreturn;\r\n}\r\ncpuhw->flags |= PMU_F_ENABLED;\r\n}\r\nstatic void cpumf_pmu_disable(struct pmu *pmu)\r\n{\r\nstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\r\nint err;\r\nu64 inactive;\r\nif (!(cpuhw->flags & PMU_F_ENABLED))\r\nreturn;\r\ninactive = cpuhw->state & ~((1 << CPUMF_LCCTL_ENABLE_SHIFT) - 1);\r\nerr = lcctl(inactive);\r\nif (err) {\r\npr_err("Disabling the performance measuring unit "\r\n"failed with rc=%x\n", err);\r\nreturn;\r\n}\r\ncpuhw->flags &= ~PMU_F_ENABLED;\r\n}\r\nstatic void cpumf_measurement_alert(struct ext_code ext_code,\r\nunsigned int alert, unsigned long unused)\r\n{\r\nstruct cpu_hw_events *cpuhw;\r\nif (!(alert & CPU_MF_INT_CF_MASK))\r\nreturn;\r\ninc_irq_stat(IRQEXT_CMC);\r\ncpuhw = &__get_cpu_var(cpu_hw_events);\r\nif (!(cpuhw->flags & PMU_F_RESERVED))\r\nreturn;\r\nif (alert & CPU_MF_INT_CF_CACA)\r\nqctri(&cpuhw->info);\r\nif (alert & CPU_MF_INT_CF_LCDA)\r\npr_err("CPU[%i] Counter data was lost\n", smp_processor_id());\r\n}\r\nstatic void setup_pmc_cpu(void *flags)\r\n{\r\nstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\r\nswitch (*((int *) flags)) {\r\ncase PMC_INIT:\r\nmemset(&cpuhw->info, 0, sizeof(cpuhw->info));\r\nqctri(&cpuhw->info);\r\ncpuhw->flags |= PMU_F_RESERVED;\r\nbreak;\r\ncase PMC_RELEASE:\r\ncpuhw->flags &= ~PMU_F_RESERVED;\r\nbreak;\r\n}\r\nlcctl(0);\r\n}\r\nstatic int reserve_pmc_hardware(void)\r\n{\r\nint flags = PMC_INIT;\r\non_each_cpu(setup_pmc_cpu, &flags, 1);\r\nirq_subclass_register(IRQ_SUBCLASS_MEASUREMENT_ALERT);\r\nreturn 0;\r\n}\r\nstatic void release_pmc_hardware(void)\r\n{\r\nint flags = PMC_RELEASE;\r\non_each_cpu(setup_pmc_cpu, &flags, 1);\r\nirq_subclass_unregister(IRQ_SUBCLASS_MEASUREMENT_ALERT);\r\n}\r\nstatic void hw_perf_event_destroy(struct perf_event *event)\r\n{\r\nif (!atomic_add_unless(&num_events, -1, 1)) {\r\nmutex_lock(&pmc_reserve_mutex);\r\nif (atomic_dec_return(&num_events) == 0)\r\nrelease_pmc_hardware();\r\nmutex_unlock(&pmc_reserve_mutex);\r\n}\r\n}\r\nstatic int __hw_perf_event_init(struct perf_event *event)\r\n{\r\nstruct perf_event_attr *attr = &event->attr;\r\nstruct hw_perf_event *hwc = &event->hw;\r\nint err;\r\nu64 ev;\r\nswitch (attr->type) {\r\ncase PERF_TYPE_RAW:\r\nif (attr->exclude_kernel || attr->exclude_user ||\r\nattr->exclude_hv)\r\nreturn -EOPNOTSUPP;\r\nev = attr->config;\r\nbreak;\r\ncase PERF_TYPE_HARDWARE:\r\nev = attr->config;\r\nif (!attr->exclude_user && attr->exclude_kernel) {\r\nif (ev >= ARRAY_SIZE(cpumf_generic_events_user))\r\nreturn -EOPNOTSUPP;\r\nev = cpumf_generic_events_user[ev];\r\n} else if (!attr->exclude_kernel && attr->exclude_user) {\r\nreturn -EOPNOTSUPP;\r\n} else {\r\nif (ev >= ARRAY_SIZE(cpumf_generic_events_basic))\r\nreturn -EOPNOTSUPP;\r\nev = cpumf_generic_events_basic[ev];\r\n}\r\nbreak;\r\ndefault:\r\nreturn -ENOENT;\r\n}\r\nif (ev == -1)\r\nreturn -ENOENT;\r\nif (ev >= PERF_CPUM_CF_MAX_CTR)\r\nreturn -EINVAL;\r\nhwc->config = ev;\r\nhwc->config_base = get_counter_set(ev);\r\nerr = validate_event(hwc);\r\nif (err)\r\nreturn err;\r\nif (!atomic_inc_not_zero(&num_events)) {\r\nmutex_lock(&pmc_reserve_mutex);\r\nif (atomic_read(&num_events) == 0 && reserve_pmc_hardware())\r\nerr = -EBUSY;\r\nelse\r\natomic_inc(&num_events);\r\nmutex_unlock(&pmc_reserve_mutex);\r\n}\r\nevent->destroy = hw_perf_event_destroy;\r\nerr = validate_ctr_auth(hwc);\r\nif (!err)\r\nerr = validate_ctr_version(hwc);\r\nreturn err;\r\n}\r\nstatic int cpumf_pmu_event_init(struct perf_event *event)\r\n{\r\nint err;\r\nswitch (event->attr.type) {\r\ncase PERF_TYPE_HARDWARE:\r\ncase PERF_TYPE_HW_CACHE:\r\ncase PERF_TYPE_RAW:\r\nif (is_sampling_event(event))\r\nreturn -ENOENT;\r\nerr = __hw_perf_event_init(event);\r\nbreak;\r\ndefault:\r\nreturn -ENOENT;\r\n}\r\nif (unlikely(err) && event->destroy)\r\nevent->destroy(event);\r\nreturn err;\r\n}\r\nstatic int hw_perf_event_reset(struct perf_event *event)\r\n{\r\nu64 prev, new;\r\nint err;\r\ndo {\r\nprev = local64_read(&event->hw.prev_count);\r\nerr = ecctr(event->hw.config, &new);\r\nif (err) {\r\nif (err != 3)\r\nbreak;\r\nnew = 0;\r\n}\r\n} while (local64_cmpxchg(&event->hw.prev_count, prev, new) != prev);\r\nreturn err;\r\n}\r\nstatic int hw_perf_event_update(struct perf_event *event)\r\n{\r\nu64 prev, new, delta;\r\nint err;\r\ndo {\r\nprev = local64_read(&event->hw.prev_count);\r\nerr = ecctr(event->hw.config, &new);\r\nif (err)\r\ngoto out;\r\n} while (local64_cmpxchg(&event->hw.prev_count, prev, new) != prev);\r\ndelta = (prev <= new) ? new - prev\r\n: (-1ULL - prev) + new + 1;\r\nlocal64_add(delta, &event->count);\r\nout:\r\nreturn err;\r\n}\r\nstatic void cpumf_pmu_read(struct perf_event *event)\r\n{\r\nif (event->hw.state & PERF_HES_STOPPED)\r\nreturn;\r\nhw_perf_event_update(event);\r\n}\r\nstatic void cpumf_pmu_start(struct perf_event *event, int flags)\r\n{\r\nstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\r\nstruct hw_perf_event *hwc = &event->hw;\r\nif (WARN_ON_ONCE(!(hwc->state & PERF_HES_STOPPED)))\r\nreturn;\r\nif (WARN_ON_ONCE(hwc->config == -1))\r\nreturn;\r\nif (flags & PERF_EF_RELOAD)\r\nWARN_ON_ONCE(!(hwc->state & PERF_HES_UPTODATE));\r\nhwc->state = 0;\r\nctr_set_enable(&cpuhw->state, hwc->config_base);\r\nctr_set_start(&cpuhw->state, hwc->config_base);\r\nhw_perf_event_reset(event);\r\natomic_inc(&cpuhw->ctr_set[hwc->config_base]);\r\n}\r\nstatic void cpumf_pmu_stop(struct perf_event *event, int flags)\r\n{\r\nstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\r\nstruct hw_perf_event *hwc = &event->hw;\r\nif (!(hwc->state & PERF_HES_STOPPED)) {\r\nif (!atomic_dec_return(&cpuhw->ctr_set[hwc->config_base]))\r\nctr_set_stop(&cpuhw->state, hwc->config_base);\r\nevent->hw.state |= PERF_HES_STOPPED;\r\n}\r\nif ((flags & PERF_EF_UPDATE) && !(hwc->state & PERF_HES_UPTODATE)) {\r\nhw_perf_event_update(event);\r\nevent->hw.state |= PERF_HES_UPTODATE;\r\n}\r\n}\r\nstatic int cpumf_pmu_add(struct perf_event *event, int flags)\r\n{\r\nstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\r\nif (!(cpuhw->flags & PERF_EVENT_TXN))\r\nif (validate_ctr_auth(&event->hw))\r\nreturn -EPERM;\r\nctr_set_enable(&cpuhw->state, event->hw.config_base);\r\nevent->hw.state = PERF_HES_UPTODATE | PERF_HES_STOPPED;\r\nif (flags & PERF_EF_START)\r\ncpumf_pmu_start(event, PERF_EF_RELOAD);\r\nperf_event_update_userpage(event);\r\nreturn 0;\r\n}\r\nstatic void cpumf_pmu_del(struct perf_event *event, int flags)\r\n{\r\nstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\r\ncpumf_pmu_stop(event, PERF_EF_UPDATE);\r\nif (!atomic_read(&cpuhw->ctr_set[event->hw.config_base]))\r\nctr_set_disable(&cpuhw->state, event->hw.config_base);\r\nperf_event_update_userpage(event);\r\n}\r\nstatic void cpumf_pmu_start_txn(struct pmu *pmu)\r\n{\r\nstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\r\nperf_pmu_disable(pmu);\r\ncpuhw->flags |= PERF_EVENT_TXN;\r\ncpuhw->tx_state = cpuhw->state;\r\n}\r\nstatic void cpumf_pmu_cancel_txn(struct pmu *pmu)\r\n{\r\nstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\r\nWARN_ON(cpuhw->tx_state != cpuhw->state);\r\ncpuhw->flags &= ~PERF_EVENT_TXN;\r\nperf_pmu_enable(pmu);\r\n}\r\nstatic int cpumf_pmu_commit_txn(struct pmu *pmu)\r\n{\r\nstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\r\nu64 state;\r\nstate = cpuhw->state & ~((1 << CPUMF_LCCTL_ENABLE_SHIFT) - 1);\r\nstate >>= CPUMF_LCCTL_ENABLE_SHIFT;\r\nif ((state & cpuhw->info.auth_ctl) != state)\r\nreturn -EPERM;\r\ncpuhw->flags &= ~PERF_EVENT_TXN;\r\nperf_pmu_enable(pmu);\r\nreturn 0;\r\n}\r\nstatic int cpumf_pmu_notifier(struct notifier_block *self, unsigned long action,\r\nvoid *hcpu)\r\n{\r\nunsigned int cpu = (long) hcpu;\r\nint flags;\r\nswitch (action & ~CPU_TASKS_FROZEN) {\r\ncase CPU_ONLINE:\r\nflags = PMC_INIT;\r\nsmp_call_function_single(cpu, setup_pmc_cpu, &flags, 1);\r\nbreak;\r\ncase CPU_DOWN_PREPARE:\r\nflags = PMC_RELEASE;\r\nsmp_call_function_single(cpu, setup_pmc_cpu, &flags, 1);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int __init cpumf_pmu_init(void)\r\n{\r\nint rc;\r\nif (!cpum_cf_avail())\r\nreturn -ENODEV;\r\nctl_clear_bit(0, 48);\r\nrc = register_external_interrupt(0x1407, cpumf_measurement_alert);\r\nif (rc) {\r\npr_err("Registering for CPU-measurement alerts "\r\n"failed with rc=%i\n", rc);\r\ngoto out;\r\n}\r\nrc = perf_pmu_register(&cpumf_pmu, "cpum_cf", PERF_TYPE_RAW);\r\nif (rc) {\r\npr_err("Registering the cpum_cf PMU failed with rc=%i\n", rc);\r\nunregister_external_interrupt(0x1407, cpumf_measurement_alert);\r\ngoto out;\r\n}\r\nperf_cpu_notifier(cpumf_pmu_notifier);\r\nout:\r\nreturn rc;\r\n}
