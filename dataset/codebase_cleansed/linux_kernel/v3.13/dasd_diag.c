static inline int dia250(void *iob, int cmd)\r\n{\r\nregister unsigned long reg2 asm ("2") = (unsigned long) iob;\r\ntypedef union {\r\nstruct dasd_diag_init_io init_io;\r\nstruct dasd_diag_rw_io rw_io;\r\n} addr_type;\r\nint rc;\r\nrc = 3;\r\nasm volatile(\r\n" diag 2,%2,0x250\n"\r\n"0: ipm %0\n"\r\n" srl %0,28\n"\r\n" or %0,3\n"\r\n"1:\n"\r\nEX_TABLE(0b,1b)\r\n: "+d" (rc), "=m" (*(addr_type *) iob)\r\n: "d" (cmd), "d" (reg2), "m" (*(addr_type *) iob)\r\n: "3", "cc");\r\nreturn rc;\r\n}\r\nstatic inline int\r\nmdsk_init_io(struct dasd_device *device, unsigned int blocksize,\r\nblocknum_t offset, blocknum_t *end_block)\r\n{\r\nstruct dasd_diag_private *private;\r\nstruct dasd_diag_init_io *iib;\r\nint rc;\r\nprivate = (struct dasd_diag_private *) device->private;\r\niib = &private->iib;\r\nmemset(iib, 0, sizeof (struct dasd_diag_init_io));\r\niib->dev_nr = private->dev_id.devno;\r\niib->block_size = blocksize;\r\niib->offset = offset;\r\niib->flaga = DASD_DIAG_FLAGA_DEFAULT;\r\nrc = dia250(iib, INIT_BIO);\r\nif ((rc & 3) == 0 && end_block)\r\n*end_block = iib->end_block;\r\nreturn rc;\r\n}\r\nstatic inline int\r\nmdsk_term_io(struct dasd_device * device)\r\n{\r\nstruct dasd_diag_private *private;\r\nstruct dasd_diag_init_io *iib;\r\nint rc;\r\nprivate = (struct dasd_diag_private *) device->private;\r\niib = &private->iib;\r\nmemset(iib, 0, sizeof (struct dasd_diag_init_io));\r\niib->dev_nr = private->dev_id.devno;\r\nrc = dia250(iib, TERM_BIO);\r\nreturn rc;\r\n}\r\nstatic void\r\ndasd_diag_erp(struct dasd_device *device)\r\n{\r\nint rc;\r\nmdsk_term_io(device);\r\nrc = mdsk_init_io(device, device->block->bp_block, 0, NULL);\r\nif (rc == 4) {\r\nif (!(test_and_set_bit(DASD_FLAG_DEVICE_RO, &device->flags)))\r\npr_warning("%s: The access mode of a DIAG device "\r\n"changed to read-only\n",\r\ndev_name(&device->cdev->dev));\r\nrc = 0;\r\n}\r\nif (rc)\r\npr_warning("%s: DIAG ERP failed with "\r\n"rc=%d\n", dev_name(&device->cdev->dev), rc);\r\n}\r\nstatic int\r\ndasd_start_diag(struct dasd_ccw_req * cqr)\r\n{\r\nstruct dasd_device *device;\r\nstruct dasd_diag_private *private;\r\nstruct dasd_diag_req *dreq;\r\nint rc;\r\ndevice = cqr->startdev;\r\nif (cqr->retries < 0) {\r\nDBF_DEV_EVENT(DBF_ERR, device, "DIAG start_IO: request %p "\r\n"- no retry left)", cqr);\r\ncqr->status = DASD_CQR_ERROR;\r\nreturn -EIO;\r\n}\r\nprivate = (struct dasd_diag_private *) device->private;\r\ndreq = (struct dasd_diag_req *) cqr->data;\r\nprivate->iob.dev_nr = private->dev_id.devno;\r\nprivate->iob.key = 0;\r\nprivate->iob.flags = DASD_DIAG_RWFLAG_ASYNC;\r\nprivate->iob.block_count = dreq->block_count;\r\nprivate->iob.interrupt_params = (addr_t) cqr;\r\nprivate->iob.bio_list = dreq->bio;\r\nprivate->iob.flaga = DASD_DIAG_FLAGA_DEFAULT;\r\ncqr->startclk = get_tod_clock();\r\ncqr->starttime = jiffies;\r\ncqr->retries--;\r\nrc = dia250(&private->iob, RW_BIO);\r\nswitch (rc) {\r\ncase 0:\r\ncqr->stopclk = get_tod_clock();\r\ncqr->status = DASD_CQR_SUCCESS;\r\nrc = -EACCES;\r\nbreak;\r\ncase 8:\r\ncqr->status = DASD_CQR_IN_IO;\r\nrc = 0;\r\nbreak;\r\ndefault:\r\ncqr->status = DASD_CQR_QUEUED;\r\nDBF_DEV_EVENT(DBF_WARNING, device, "dia250 returned rc=%d", rc);\r\ndasd_diag_erp(device);\r\nrc = -EIO;\r\nbreak;\r\n}\r\ncqr->intrc = rc;\r\nreturn rc;\r\n}\r\nstatic int\r\ndasd_diag_term_IO(struct dasd_ccw_req * cqr)\r\n{\r\nstruct dasd_device *device;\r\ndevice = cqr->startdev;\r\nmdsk_term_io(device);\r\nmdsk_init_io(device, device->block->bp_block, 0, NULL);\r\ncqr->status = DASD_CQR_CLEAR_PENDING;\r\ncqr->stopclk = get_tod_clock();\r\ndasd_schedule_device_bh(device);\r\nreturn 0;\r\n}\r\nstatic void dasd_ext_handler(struct ext_code ext_code,\r\nunsigned int param32, unsigned long param64)\r\n{\r\nstruct dasd_ccw_req *cqr, *next;\r\nstruct dasd_device *device;\r\nunsigned long long expires;\r\nunsigned long flags;\r\naddr_t ip;\r\nint rc;\r\nswitch (ext_code.subcode >> 8) {\r\ncase DASD_DIAG_CODE_31BIT:\r\nip = (addr_t) param32;\r\nbreak;\r\ncase DASD_DIAG_CODE_64BIT:\r\nip = (addr_t) param64;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\ninc_irq_stat(IRQEXT_DSD);\r\nif (!ip) {\r\nDBF_EVENT(DBF_NOTICE, "%s", "caught unsolicited "\r\n"interrupt");\r\nreturn;\r\n}\r\ncqr = (struct dasd_ccw_req *) ip;\r\ndevice = (struct dasd_device *) cqr->startdev;\r\nif (strncmp(device->discipline->ebcname, (char *) &cqr->magic, 4)) {\r\nDBF_DEV_EVENT(DBF_WARNING, device,\r\n" magic number of dasd_ccw_req 0x%08X doesn't"\r\n" match discipline 0x%08X",\r\ncqr->magic, *(int *) (&device->discipline->name));\r\nreturn;\r\n}\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\nif (cqr->status == DASD_CQR_CLEAR_PENDING) {\r\ncqr->status = DASD_CQR_CLEARED;\r\ndasd_device_clear_timer(device);\r\ndasd_schedule_device_bh(device);\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\nreturn;\r\n}\r\ncqr->stopclk = get_tod_clock();\r\nexpires = 0;\r\nif ((ext_code.subcode & 0xff) == 0) {\r\ncqr->status = DASD_CQR_SUCCESS;\r\nif (!list_empty(&device->ccw_queue)) {\r\nnext = list_entry(device->ccw_queue.next,\r\nstruct dasd_ccw_req, devlist);\r\nif (next->status == DASD_CQR_QUEUED) {\r\nrc = dasd_start_diag(next);\r\nif (rc == 0)\r\nexpires = next->expires;\r\n}\r\n}\r\n} else {\r\ncqr->status = DASD_CQR_QUEUED;\r\nDBF_DEV_EVENT(DBF_DEBUG, device, "interrupt status for "\r\n"request %p was %d (%d retries left)", cqr,\r\next_code.subcode & 0xff, cqr->retries);\r\ndasd_diag_erp(device);\r\n}\r\nif (expires != 0)\r\ndasd_device_set_timer(device, expires);\r\nelse\r\ndasd_device_clear_timer(device);\r\ndasd_schedule_device_bh(device);\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\n}\r\nstatic int\r\ndasd_diag_check_device(struct dasd_device *device)\r\n{\r\nstruct dasd_block *block;\r\nstruct dasd_diag_private *private;\r\nstruct dasd_diag_characteristics *rdc_data;\r\nstruct dasd_diag_bio bio;\r\nstruct vtoc_cms_label *label;\r\nblocknum_t end_block;\r\nunsigned int sb, bsize;\r\nint rc;\r\nprivate = (struct dasd_diag_private *) device->private;\r\nif (private == NULL) {\r\nprivate = kzalloc(sizeof(struct dasd_diag_private),GFP_KERNEL);\r\nif (private == NULL) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"Allocating memory for private DASD data "\r\n"failed\n");\r\nreturn -ENOMEM;\r\n}\r\nccw_device_get_id(device->cdev, &private->dev_id);\r\ndevice->private = (void *) private;\r\n}\r\nblock = dasd_alloc_block();\r\nif (IS_ERR(block)) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"could not allocate dasd block structure");\r\ndevice->private = NULL;\r\nkfree(private);\r\nreturn PTR_ERR(block);\r\n}\r\ndevice->block = block;\r\nblock->base = device;\r\nrdc_data = (void *) &(private->rdc_data);\r\nrdc_data->dev_nr = private->dev_id.devno;\r\nrdc_data->rdc_len = sizeof (struct dasd_diag_characteristics);\r\nrc = diag210((struct diag210 *) rdc_data);\r\nif (rc) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "failed to retrieve device "\r\n"information (rc=%d)", rc);\r\nrc = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\ndevice->default_expires = DIAG_TIMEOUT;\r\ndevice->default_retries = DIAG_MAX_RETRIES;\r\nswitch (private->rdc_data.vdev_class) {\r\ncase DEV_CLASS_FBA:\r\nprivate->pt_block = 1;\r\nbreak;\r\ncase DEV_CLASS_ECKD:\r\nprivate->pt_block = 2;\r\nbreak;\r\ndefault:\r\npr_warning("%s: Device type %d is not supported "\r\n"in DIAG mode\n", dev_name(&device->cdev->dev),\r\nprivate->rdc_data.vdev_class);\r\nrc = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nDBF_DEV_EVENT(DBF_INFO, device,\r\n"%04X: %04X on real %04X/%02X",\r\nrdc_data->dev_nr,\r\nrdc_data->vdev_type,\r\nrdc_data->rdev_type, rdc_data->rdev_model);\r\nmdsk_term_io(device);\r\nlabel = (struct vtoc_cms_label *) get_zeroed_page(GFP_KERNEL);\r\nif (label == NULL) {\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"No memory to allocate initialization request");\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nrc = 0;\r\nend_block = 0;\r\nfor (bsize = 512; bsize <= PAGE_SIZE; bsize <<= 1) {\r\nmdsk_init_io(device, bsize, 0, &end_block);\r\nmemset(&bio, 0, sizeof (struct dasd_diag_bio));\r\nbio.type = MDSK_READ_REQ;\r\nbio.block_number = private->pt_block + 1;\r\nbio.buffer = label;\r\nmemset(&private->iob, 0, sizeof (struct dasd_diag_rw_io));\r\nprivate->iob.dev_nr = rdc_data->dev_nr;\r\nprivate->iob.key = 0;\r\nprivate->iob.flags = 0;\r\nprivate->iob.block_count = 1;\r\nprivate->iob.interrupt_params = 0;\r\nprivate->iob.bio_list = &bio;\r\nprivate->iob.flaga = DASD_DIAG_FLAGA_DEFAULT;\r\nrc = dia250(&private->iob, RW_BIO);\r\nif (rc == 3) {\r\npr_warning("%s: A 64-bit DIAG call failed\n",\r\ndev_name(&device->cdev->dev));\r\nrc = -EOPNOTSUPP;\r\ngoto out_label;\r\n}\r\nmdsk_term_io(device);\r\nif (rc == 0)\r\nbreak;\r\n}\r\nif (bsize > PAGE_SIZE) {\r\npr_warning("%s: Accessing the DASD failed because of an "\r\n"incorrect format (rc=%d)\n",\r\ndev_name(&device->cdev->dev), rc);\r\nrc = -EIO;\r\ngoto out_label;\r\n}\r\nif (memcmp(label->label_id, DASD_DIAG_CMS1,\r\nsizeof(DASD_DIAG_CMS1)) == 0) {\r\nbsize = (unsigned int) label->block_size;\r\nblock->blocks = (unsigned long) label->block_count;\r\n} else\r\nblock->blocks = end_block;\r\nblock->bp_block = bsize;\r\nblock->s2b_shift = 0;\r\nfor (sb = 512; sb < bsize; sb = sb << 1)\r\nblock->s2b_shift++;\r\nrc = mdsk_init_io(device, block->bp_block, 0, NULL);\r\nif (rc && (rc != 4)) {\r\npr_warning("%s: DIAG initialization failed with rc=%d\n",\r\ndev_name(&device->cdev->dev), rc);\r\nrc = -EIO;\r\n} else {\r\nif (rc == 4)\r\nset_bit(DASD_FLAG_DEVICE_RO, &device->flags);\r\npr_info("%s: New DASD with %ld byte/block, total size %ld "\r\n"KB%s\n", dev_name(&device->cdev->dev),\r\n(unsigned long) block->bp_block,\r\n(unsigned long) (block->blocks <<\r\nblock->s2b_shift) >> 1,\r\n(rc == 4) ? ", read-only device" : "");\r\nrc = 0;\r\n}\r\nout_label:\r\nfree_page((long) label);\r\nout:\r\nif (rc) {\r\ndevice->block = NULL;\r\ndasd_free_block(block);\r\ndevice->private = NULL;\r\nkfree(private);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\ndasd_diag_fill_geometry(struct dasd_block *block, struct hd_geometry *geo)\r\n{\r\nif (dasd_check_blocksize(block->bp_block) != 0)\r\nreturn -EINVAL;\r\ngeo->cylinders = (block->blocks << block->s2b_shift) >> 10;\r\ngeo->heads = 16;\r\ngeo->sectors = 128 >> block->s2b_shift;\r\nreturn 0;\r\n}\r\nstatic dasd_erp_fn_t\r\ndasd_diag_erp_action(struct dasd_ccw_req * cqr)\r\n{\r\nreturn dasd_default_erp_action;\r\n}\r\nstatic dasd_erp_fn_t\r\ndasd_diag_erp_postaction(struct dasd_ccw_req * cqr)\r\n{\r\nreturn dasd_default_erp_postaction;\r\n}\r\nstatic struct dasd_ccw_req *dasd_diag_build_cp(struct dasd_device *memdev,\r\nstruct dasd_block *block,\r\nstruct request *req)\r\n{\r\nstruct dasd_ccw_req *cqr;\r\nstruct dasd_diag_req *dreq;\r\nstruct dasd_diag_bio *dbio;\r\nstruct req_iterator iter;\r\nstruct bio_vec *bv;\r\nchar *dst;\r\nunsigned int count, datasize;\r\nsector_t recid, first_rec, last_rec;\r\nunsigned int blksize, off;\r\nunsigned char rw_cmd;\r\nif (rq_data_dir(req) == READ)\r\nrw_cmd = MDSK_READ_REQ;\r\nelse if (rq_data_dir(req) == WRITE)\r\nrw_cmd = MDSK_WRITE_REQ;\r\nelse\r\nreturn ERR_PTR(-EINVAL);\r\nblksize = block->bp_block;\r\nfirst_rec = blk_rq_pos(req) >> block->s2b_shift;\r\nlast_rec =\r\n(blk_rq_pos(req) + blk_rq_sectors(req) - 1) >> block->s2b_shift;\r\ncount = 0;\r\nrq_for_each_segment(bv, req, iter) {\r\nif (bv->bv_len & (blksize - 1))\r\nreturn ERR_PTR(-EINVAL);\r\ncount += bv->bv_len >> (block->s2b_shift + 9);\r\n}\r\nif (count != last_rec - first_rec + 1)\r\nreturn ERR_PTR(-EINVAL);\r\ndatasize = sizeof(struct dasd_diag_req) +\r\ncount*sizeof(struct dasd_diag_bio);\r\ncqr = dasd_smalloc_request(DASD_DIAG_MAGIC, 0, datasize, memdev);\r\nif (IS_ERR(cqr))\r\nreturn cqr;\r\ndreq = (struct dasd_diag_req *) cqr->data;\r\ndreq->block_count = count;\r\ndbio = dreq->bio;\r\nrecid = first_rec;\r\nrq_for_each_segment(bv, req, iter) {\r\ndst = page_address(bv->bv_page) + bv->bv_offset;\r\nfor (off = 0; off < bv->bv_len; off += blksize) {\r\nmemset(dbio, 0, sizeof (struct dasd_diag_bio));\r\ndbio->type = rw_cmd;\r\ndbio->block_number = recid + 1;\r\ndbio->buffer = dst;\r\ndbio++;\r\ndst += blksize;\r\nrecid++;\r\n}\r\n}\r\ncqr->retries = memdev->default_retries;\r\ncqr->buildclk = get_tod_clock();\r\nif (blk_noretry_request(req) ||\r\nblock->base->features & DASD_FEATURE_FAILFAST)\r\nset_bit(DASD_CQR_FLAGS_FAILFAST, &cqr->flags);\r\ncqr->startdev = memdev;\r\ncqr->memdev = memdev;\r\ncqr->block = block;\r\ncqr->expires = memdev->default_expires * HZ;\r\ncqr->status = DASD_CQR_FILLED;\r\nreturn cqr;\r\n}\r\nstatic int\r\ndasd_diag_free_cp(struct dasd_ccw_req *cqr, struct request *req)\r\n{\r\nint status;\r\nstatus = cqr->status == DASD_CQR_DONE;\r\ndasd_sfree_request(cqr, cqr->memdev);\r\nreturn status;\r\n}\r\nstatic void dasd_diag_handle_terminated_request(struct dasd_ccw_req *cqr)\r\n{\r\nif (cqr->retries < 0)\r\ncqr->status = DASD_CQR_FAILED;\r\nelse\r\ncqr->status = DASD_CQR_FILLED;\r\n}\r\nstatic int\r\ndasd_diag_fill_info(struct dasd_device * device,\r\nstruct dasd_information2_t * info)\r\n{\r\nstruct dasd_diag_private *private;\r\nprivate = (struct dasd_diag_private *) device->private;\r\ninfo->label_block = (unsigned int) private->pt_block;\r\ninfo->FBA_layout = 1;\r\ninfo->format = DASD_FORMAT_LDL;\r\ninfo->characteristics_size = sizeof (struct dasd_diag_characteristics);\r\nmemcpy(info->characteristics,\r\n&((struct dasd_diag_private *) device->private)->rdc_data,\r\nsizeof (struct dasd_diag_characteristics));\r\ninfo->confdata_size = 0;\r\nreturn 0;\r\n}\r\nstatic void\r\ndasd_diag_dump_sense(struct dasd_device *device, struct dasd_ccw_req * req,\r\nstruct irb *stat)\r\n{\r\nDBF_DEV_EVENT(DBF_WARNING, device, "%s",\r\n"dump sense not available for DIAG data");\r\n}\r\nstatic int __init\r\ndasd_diag_init(void)\r\n{\r\nif (!MACHINE_IS_VM) {\r\npr_info("Discipline %s cannot be used without z/VM\n",\r\ndasd_diag_discipline.name);\r\nreturn -ENODEV;\r\n}\r\nASCEBC(dasd_diag_discipline.ebcname, 4);\r\nirq_subclass_register(IRQ_SUBCLASS_SERVICE_SIGNAL);\r\nregister_external_interrupt(0x2603, dasd_ext_handler);\r\ndasd_diag_discipline_pointer = &dasd_diag_discipline;\r\nreturn 0;\r\n}\r\nstatic void __exit\r\ndasd_diag_cleanup(void)\r\n{\r\nunregister_external_interrupt(0x2603, dasd_ext_handler);\r\nirq_subclass_unregister(IRQ_SUBCLASS_SERVICE_SIGNAL);\r\ndasd_diag_discipline_pointer = NULL;\r\n}
