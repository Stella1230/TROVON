int bigendian(void)\r\n{\r\nunsigned char str[] = { 0x1, 0x2, 0x3, 0x4, 0x0, 0x0, 0x0, 0x0};\r\nunsigned int *ptr;\r\nptr = (unsigned int *)(void *)str;\r\nreturn *ptr == 0x01020304;\r\n}\r\nstatic int record_file(const char *file, ssize_t hdr_sz)\r\n{\r\nunsigned long long size = 0;\r\nchar buf[BUFSIZ], *sizep;\r\noff_t hdr_pos = lseek(output_fd, 0, SEEK_CUR);\r\nint r, fd;\r\nint err = -EIO;\r\nfd = open(file, O_RDONLY);\r\nif (fd < 0) {\r\npr_debug("Can't read '%s'", file);\r\nreturn -errno;\r\n}\r\nif (hdr_sz) {\r\nif (write(output_fd, &size, hdr_sz) != hdr_sz)\r\ngoto out;\r\n}\r\ndo {\r\nr = read(fd, buf, BUFSIZ);\r\nif (r > 0) {\r\nsize += r;\r\nif (write(output_fd, buf, r) != r)\r\ngoto out;\r\n}\r\n} while (r > 0);\r\nsizep = (char*)&size;\r\nif (bigendian())\r\nsizep += sizeof(u64) - hdr_sz;\r\nif (hdr_sz && pwrite(output_fd, sizep, hdr_sz, hdr_pos) < 0) {\r\npr_debug("writing file size failed\n");\r\ngoto out;\r\n}\r\nerr = 0;\r\nout:\r\nclose(fd);\r\nreturn err;\r\n}\r\nstatic int record_header_files(void)\r\n{\r\nchar *path;\r\nstruct stat st;\r\nint err = -EIO;\r\npath = get_tracing_file("events/header_page");\r\nif (!path) {\r\npr_debug("can't get tracing/events/header_page");\r\nreturn -ENOMEM;\r\n}\r\nif (stat(path, &st) < 0) {\r\npr_debug("can't read '%s'", path);\r\ngoto out;\r\n}\r\nif (write(output_fd, "header_page", 12) != 12) {\r\npr_debug("can't write header_page\n");\r\ngoto out;\r\n}\r\nif (record_file(path, 8) < 0) {\r\npr_debug("can't record header_page file\n");\r\ngoto out;\r\n}\r\nput_tracing_file(path);\r\npath = get_tracing_file("events/header_event");\r\nif (!path) {\r\npr_debug("can't get tracing/events/header_event");\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nif (stat(path, &st) < 0) {\r\npr_debug("can't read '%s'", path);\r\ngoto out;\r\n}\r\nif (write(output_fd, "header_event", 13) != 13) {\r\npr_debug("can't write header_event\n");\r\ngoto out;\r\n}\r\nif (record_file(path, 8) < 0) {\r\npr_debug("can't record header_event file\n");\r\ngoto out;\r\n}\r\nerr = 0;\r\nout:\r\nput_tracing_file(path);\r\nreturn err;\r\n}\r\nstatic bool name_in_tp_list(char *sys, struct tracepoint_path *tps)\r\n{\r\nwhile (tps) {\r\nif (!strcmp(sys, tps->name))\r\nreturn true;\r\ntps = tps->next;\r\n}\r\nreturn false;\r\n}\r\nstatic int copy_event_system(const char *sys, struct tracepoint_path *tps)\r\n{\r\nstruct dirent *dent;\r\nstruct stat st;\r\nchar *format;\r\nDIR *dir;\r\nint count = 0;\r\nint ret;\r\nint err;\r\ndir = opendir(sys);\r\nif (!dir) {\r\npr_debug("can't read directory '%s'", sys);\r\nreturn -errno;\r\n}\r\nwhile ((dent = readdir(dir))) {\r\nif (dent->d_type != DT_DIR ||\r\nstrcmp(dent->d_name, ".") == 0 ||\r\nstrcmp(dent->d_name, "..") == 0 ||\r\n!name_in_tp_list(dent->d_name, tps))\r\ncontinue;\r\nformat = malloc(strlen(sys) + strlen(dent->d_name) + 10);\r\nif (!format) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nsprintf(format, "%s/%s/format", sys, dent->d_name);\r\nret = stat(format, &st);\r\nfree(format);\r\nif (ret < 0)\r\ncontinue;\r\ncount++;\r\n}\r\nif (write(output_fd, &count, 4) != 4) {\r\nerr = -EIO;\r\npr_debug("can't write count\n");\r\ngoto out;\r\n}\r\nrewinddir(dir);\r\nwhile ((dent = readdir(dir))) {\r\nif (dent->d_type != DT_DIR ||\r\nstrcmp(dent->d_name, ".") == 0 ||\r\nstrcmp(dent->d_name, "..") == 0 ||\r\n!name_in_tp_list(dent->d_name, tps))\r\ncontinue;\r\nformat = malloc(strlen(sys) + strlen(dent->d_name) + 10);\r\nif (!format) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nsprintf(format, "%s/%s/format", sys, dent->d_name);\r\nret = stat(format, &st);\r\nif (ret >= 0) {\r\nerr = record_file(format, 8);\r\nif (err) {\r\nfree(format);\r\ngoto out;\r\n}\r\n}\r\nfree(format);\r\n}\r\nerr = 0;\r\nout:\r\nclosedir(dir);\r\nreturn err;\r\n}\r\nstatic int record_ftrace_files(struct tracepoint_path *tps)\r\n{\r\nchar *path;\r\nint ret;\r\npath = get_tracing_file("events/ftrace");\r\nif (!path) {\r\npr_debug("can't get tracing/events/ftrace");\r\nreturn -ENOMEM;\r\n}\r\nret = copy_event_system(path, tps);\r\nput_tracing_file(path);\r\nreturn ret;\r\n}\r\nstatic bool system_in_tp_list(char *sys, struct tracepoint_path *tps)\r\n{\r\nwhile (tps) {\r\nif (!strcmp(sys, tps->system))\r\nreturn true;\r\ntps = tps->next;\r\n}\r\nreturn false;\r\n}\r\nstatic int record_event_files(struct tracepoint_path *tps)\r\n{\r\nstruct dirent *dent;\r\nstruct stat st;\r\nchar *path;\r\nchar *sys;\r\nDIR *dir;\r\nint count = 0;\r\nint ret;\r\nint err;\r\npath = get_tracing_file("events");\r\nif (!path) {\r\npr_debug("can't get tracing/events");\r\nreturn -ENOMEM;\r\n}\r\ndir = opendir(path);\r\nif (!dir) {\r\nerr = -errno;\r\npr_debug("can't read directory '%s'", path);\r\ngoto out;\r\n}\r\nwhile ((dent = readdir(dir))) {\r\nif (dent->d_type != DT_DIR ||\r\nstrcmp(dent->d_name, ".") == 0 ||\r\nstrcmp(dent->d_name, "..") == 0 ||\r\nstrcmp(dent->d_name, "ftrace") == 0 ||\r\n!system_in_tp_list(dent->d_name, tps))\r\ncontinue;\r\ncount++;\r\n}\r\nif (write(output_fd, &count, 4) != 4) {\r\nerr = -EIO;\r\npr_debug("can't write count\n");\r\ngoto out;\r\n}\r\nrewinddir(dir);\r\nwhile ((dent = readdir(dir))) {\r\nif (dent->d_type != DT_DIR ||\r\nstrcmp(dent->d_name, ".") == 0 ||\r\nstrcmp(dent->d_name, "..") == 0 ||\r\nstrcmp(dent->d_name, "ftrace") == 0 ||\r\n!system_in_tp_list(dent->d_name, tps))\r\ncontinue;\r\nsys = malloc(strlen(path) + strlen(dent->d_name) + 2);\r\nif (!sys) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nsprintf(sys, "%s/%s", path, dent->d_name);\r\nret = stat(sys, &st);\r\nif (ret >= 0) {\r\nssize_t size = strlen(dent->d_name) + 1;\r\nif (write(output_fd, dent->d_name, size) != size ||\r\ncopy_event_system(sys, tps) < 0) {\r\nerr = -EIO;\r\nfree(sys);\r\ngoto out;\r\n}\r\n}\r\nfree(sys);\r\n}\r\nerr = 0;\r\nout:\r\nclosedir(dir);\r\nput_tracing_file(path);\r\nreturn err;\r\n}\r\nstatic int record_proc_kallsyms(void)\r\n{\r\nunsigned int size;\r\nconst char *path = "/proc/kallsyms";\r\nstruct stat st;\r\nint ret, err = 0;\r\nret = stat(path, &st);\r\nif (ret < 0) {\r\nsize = 0;\r\nif (write(output_fd, &size, 4) != 4)\r\nerr = -EIO;\r\nreturn err;\r\n}\r\nreturn record_file(path, 4);\r\n}\r\nstatic int record_ftrace_printk(void)\r\n{\r\nunsigned int size;\r\nchar *path;\r\nstruct stat st;\r\nint ret, err = 0;\r\npath = get_tracing_file("printk_formats");\r\nif (!path) {\r\npr_debug("can't get tracing/printk_formats");\r\nreturn -ENOMEM;\r\n}\r\nret = stat(path, &st);\r\nif (ret < 0) {\r\nsize = 0;\r\nif (write(output_fd, &size, 4) != 4)\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nerr = record_file(path, 4);\r\nout:\r\nput_tracing_file(path);\r\nreturn err;\r\n}\r\nstatic void\r\nput_tracepoints_path(struct tracepoint_path *tps)\r\n{\r\nwhile (tps) {\r\nstruct tracepoint_path *t = tps;\r\ntps = tps->next;\r\nfree(t->name);\r\nfree(t->system);\r\nfree(t);\r\n}\r\n}\r\nstatic struct tracepoint_path *\r\nget_tracepoints_path(struct list_head *pattrs)\r\n{\r\nstruct tracepoint_path path, *ppath = &path;\r\nstruct perf_evsel *pos;\r\nint nr_tracepoints = 0;\r\nlist_for_each_entry(pos, pattrs, node) {\r\nif (pos->attr.type != PERF_TYPE_TRACEPOINT)\r\ncontinue;\r\n++nr_tracepoints;\r\nif (pos->name) {\r\nppath->next = tracepoint_name_to_path(pos->name);\r\nif (ppath->next)\r\ngoto next;\r\nif (strchr(pos->name, ':') == NULL)\r\ngoto try_id;\r\ngoto error;\r\n}\r\ntry_id:\r\nppath->next = tracepoint_id_to_path(pos->attr.config);\r\nif (!ppath->next) {\r\nerror:\r\npr_debug("No memory to alloc tracepoints list\n");\r\nput_tracepoints_path(&path);\r\nreturn NULL;\r\n}\r\nnext:\r\nppath = ppath->next;\r\n}\r\nreturn nr_tracepoints > 0 ? path.next : NULL;\r\n}\r\nbool have_tracepoints(struct list_head *pattrs)\r\n{\r\nstruct perf_evsel *pos;\r\nlist_for_each_entry(pos, pattrs, node)\r\nif (pos->attr.type == PERF_TYPE_TRACEPOINT)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int tracing_data_header(void)\r\n{\r\nchar buf[20];\r\nssize_t size;\r\nbuf[0] = 23;\r\nbuf[1] = 8;\r\nbuf[2] = 68;\r\nmemcpy(buf + 3, "tracing", 7);\r\nif (write(output_fd, buf, 10) != 10)\r\nreturn -1;\r\nsize = strlen(VERSION) + 1;\r\nif (write(output_fd, VERSION, size) != size)\r\nreturn -1;\r\nif (bigendian())\r\nbuf[0] = 1;\r\nelse\r\nbuf[0] = 0;\r\nif (write(output_fd, buf, 1) != 1)\r\nreturn -1;\r\nbuf[0] = sizeof(long);\r\nif (write(output_fd, buf, 1) != 1)\r\nreturn -1;\r\nif (write(output_fd, &page_size, 4) != 4)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstruct tracing_data *tracing_data_get(struct list_head *pattrs,\r\nint fd, bool temp)\r\n{\r\nstruct tracepoint_path *tps;\r\nstruct tracing_data *tdata;\r\nint err;\r\noutput_fd = fd;\r\ntps = get_tracepoints_path(pattrs);\r\nif (!tps)\r\nreturn NULL;\r\ntdata = malloc(sizeof(*tdata));\r\nif (!tdata)\r\nreturn NULL;\r\ntdata->temp = temp;\r\ntdata->size = 0;\r\nif (temp) {\r\nint temp_fd;\r\nsnprintf(tdata->temp_file, sizeof(tdata->temp_file),\r\n"/tmp/perf-XXXXXX");\r\nif (!mkstemp(tdata->temp_file)) {\r\npr_debug("Can't make temp file");\r\nreturn NULL;\r\n}\r\ntemp_fd = open(tdata->temp_file, O_RDWR);\r\nif (temp_fd < 0) {\r\npr_debug("Can't read '%s'", tdata->temp_file);\r\nreturn NULL;\r\n}\r\noutput_fd = temp_fd;\r\n}\r\nerr = tracing_data_header();\r\nif (err)\r\ngoto out;\r\nerr = record_header_files();\r\nif (err)\r\ngoto out;\r\nerr = record_ftrace_files(tps);\r\nif (err)\r\ngoto out;\r\nerr = record_event_files(tps);\r\nif (err)\r\ngoto out;\r\nerr = record_proc_kallsyms();\r\nif (err)\r\ngoto out;\r\nerr = record_ftrace_printk();\r\nout:\r\nif (temp) {\r\ntdata->size = lseek(output_fd, 0, SEEK_CUR);\r\nclose(output_fd);\r\noutput_fd = fd;\r\n}\r\nif (err) {\r\nfree(tdata);\r\ntdata = NULL;\r\n}\r\nput_tracepoints_path(tps);\r\nreturn tdata;\r\n}\r\nint tracing_data_put(struct tracing_data *tdata)\r\n{\r\nint err = 0;\r\nif (tdata->temp) {\r\nerr = record_file(tdata->temp_file, 0);\r\nunlink(tdata->temp_file);\r\n}\r\nfree(tdata);\r\nreturn err;\r\n}\r\nint read_tracing_data(int fd, struct list_head *pattrs)\r\n{\r\nint err;\r\nstruct tracing_data *tdata;\r\ntdata = tracing_data_get(pattrs, fd, false);\r\nif (!tdata)\r\nreturn -ENOMEM;\r\nerr = tracing_data_put(tdata);\r\nreturn err;\r\n}
