static void exynos_drm_connector_power(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_connector *connector;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nif (exynos_drm_best_encoder(connector) == encoder) {\r\nDRM_DEBUG_KMS("connector[%d] dpms[%d]\n",\r\nconnector->base.id, mode);\r\nexynos_drm_display_power(connector, mode);\r\n}\r\n}\r\n}\r\nstatic void exynos_drm_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct exynos_drm_manager *manager = exynos_drm_get_manager(encoder);\r\nstruct exynos_drm_manager_ops *manager_ops = manager->ops;\r\nstruct exynos_drm_encoder *exynos_encoder = to_exynos_encoder(encoder);\r\nDRM_DEBUG_KMS("encoder dpms: %d\n", mode);\r\nif (exynos_encoder->dpms == mode) {\r\nDRM_DEBUG_KMS("desired dpms mode is same as previous one.\n");\r\nreturn;\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nif (manager_ops && manager_ops->apply)\r\nif (!exynos_encoder->updated)\r\nmanager_ops->apply(manager->dev);\r\nexynos_drm_connector_power(encoder, mode);\r\nexynos_encoder->dpms = mode;\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ncase DRM_MODE_DPMS_OFF:\r\nexynos_drm_connector_power(encoder, mode);\r\nexynos_encoder->dpms = mode;\r\nexynos_encoder->updated = false;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unspecified mode %d\n", mode);\r\nbreak;\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\n}\r\nstatic bool\r\nexynos_drm_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_connector *connector;\r\nstruct exynos_drm_manager *manager = exynos_drm_get_manager(encoder);\r\nstruct exynos_drm_manager_ops *manager_ops = manager->ops;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nif (connector->encoder == encoder)\r\nif (manager_ops && manager_ops->mode_fixup)\r\nmanager_ops->mode_fixup(manager->dev, connector,\r\nmode, adjusted_mode);\r\n}\r\nreturn true;\r\n}\r\nstatic void disable_plane_to_crtc(struct drm_device *dev,\r\nstruct drm_crtc *old_crtc,\r\nstruct drm_crtc *new_crtc)\r\n{\r\nstruct drm_plane *plane;\r\nlist_for_each_entry(plane, &dev->mode_config.plane_list, head) {\r\nif (plane->crtc == old_crtc) {\r\nplane->crtc = new_crtc;\r\nplane->funcs->disable_plane(plane);\r\n}\r\n}\r\n}\r\nstatic void exynos_drm_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_connector *connector;\r\nstruct exynos_drm_manager *manager;\r\nstruct exynos_drm_manager_ops *manager_ops;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nif (connector->encoder == encoder) {\r\nstruct exynos_drm_encoder *exynos_encoder;\r\nexynos_encoder = to_exynos_encoder(encoder);\r\nif (exynos_encoder->old_crtc != encoder->crtc &&\r\nexynos_encoder->old_crtc) {\r\ndisable_plane_to_crtc(dev,\r\nexynos_encoder->old_crtc,\r\nencoder->crtc);\r\n}\r\nmanager = exynos_drm_get_manager(encoder);\r\nmanager_ops = manager->ops;\r\nif (manager_ops && manager_ops->mode_set)\r\nmanager_ops->mode_set(manager->dev,\r\nadjusted_mode);\r\nexynos_encoder->old_crtc = encoder->crtc;\r\n}\r\n}\r\n}\r\nstatic void exynos_drm_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void exynos_drm_encoder_commit(struct drm_encoder *encoder)\r\n{\r\nstruct exynos_drm_encoder *exynos_encoder = to_exynos_encoder(encoder);\r\nstruct exynos_drm_manager *manager = exynos_encoder->manager;\r\nstruct exynos_drm_manager_ops *manager_ops = manager->ops;\r\nif (manager_ops && manager_ops->commit)\r\nmanager_ops->commit(manager->dev);\r\nexynos_encoder->updated = true;\r\nexynos_encoder->dpms = DRM_MODE_DPMS_ON;\r\n}\r\nvoid exynos_drm_encoder_complete_scanout(struct drm_framebuffer *fb)\r\n{\r\nstruct exynos_drm_encoder *exynos_encoder;\r\nstruct exynos_drm_manager_ops *ops;\r\nstruct drm_device *dev = fb->dev;\r\nstruct drm_encoder *encoder;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nexynos_encoder = to_exynos_encoder(encoder);\r\nops = exynos_encoder->manager->ops;\r\nif (ops->wait_for_vblank)\r\nops->wait_for_vblank(exynos_encoder->manager->dev);\r\n}\r\n}\r\nstatic void exynos_drm_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct drm_plane *plane;\r\nstruct drm_device *dev = encoder->dev;\r\nexynos_drm_encoder_dpms(encoder, DRM_MODE_DPMS_OFF);\r\nlist_for_each_entry(plane, &dev->mode_config.plane_list, head) {\r\nif (plane->crtc == encoder->crtc)\r\nplane->funcs->disable_plane(plane);\r\n}\r\n}\r\nstatic void exynos_drm_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct exynos_drm_encoder *exynos_encoder =\r\nto_exynos_encoder(encoder);\r\nexynos_encoder->manager->pipe = -1;\r\ndrm_encoder_cleanup(encoder);\r\nkfree(exynos_encoder);\r\n}\r\nstatic unsigned int exynos_drm_encoder_clones(struct drm_encoder *encoder)\r\n{\r\nstruct drm_encoder *clone;\r\nstruct drm_device *dev = encoder->dev;\r\nstruct exynos_drm_encoder *exynos_encoder = to_exynos_encoder(encoder);\r\nstruct exynos_drm_display_ops *display_ops =\r\nexynos_encoder->manager->display_ops;\r\nunsigned int clone_mask = 0;\r\nint cnt = 0;\r\nlist_for_each_entry(clone, &dev->mode_config.encoder_list, head) {\r\nswitch (display_ops->type) {\r\ncase EXYNOS_DISPLAY_TYPE_LCD:\r\ncase EXYNOS_DISPLAY_TYPE_HDMI:\r\ncase EXYNOS_DISPLAY_TYPE_VIDI:\r\nclone_mask |= (1 << (cnt++));\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\n}\r\nreturn clone_mask;\r\n}\r\nvoid exynos_drm_encoder_setup(struct drm_device *dev)\r\n{\r\nstruct drm_encoder *encoder;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head)\r\nencoder->possible_clones = exynos_drm_encoder_clones(encoder);\r\n}\r\nstruct drm_encoder *\r\nexynos_drm_encoder_create(struct drm_device *dev,\r\nstruct exynos_drm_manager *manager,\r\nunsigned int possible_crtcs)\r\n{\r\nstruct drm_encoder *encoder;\r\nstruct exynos_drm_encoder *exynos_encoder;\r\nif (!manager || !possible_crtcs)\r\nreturn NULL;\r\nif (!manager->dev)\r\nreturn NULL;\r\nexynos_encoder = kzalloc(sizeof(*exynos_encoder), GFP_KERNEL);\r\nif (!exynos_encoder)\r\nreturn NULL;\r\nexynos_encoder->dpms = DRM_MODE_DPMS_OFF;\r\nexynos_encoder->manager = manager;\r\nencoder = &exynos_encoder->drm_encoder;\r\nencoder->possible_crtcs = possible_crtcs;\r\nDRM_DEBUG_KMS("possible_crtcs = 0x%x\n", encoder->possible_crtcs);\r\ndrm_encoder_init(dev, encoder, &exynos_encoder_funcs,\r\nDRM_MODE_ENCODER_TMDS);\r\ndrm_encoder_helper_add(encoder, &exynos_encoder_helper_funcs);\r\nDRM_DEBUG_KMS("encoder has been created\n");\r\nreturn encoder;\r\n}\r\nstruct exynos_drm_manager *exynos_drm_get_manager(struct drm_encoder *encoder)\r\n{\r\nreturn to_exynos_encoder(encoder)->manager;\r\n}\r\nvoid exynos_drm_fn_encoder(struct drm_crtc *crtc, void *data,\r\nvoid (*fn)(struct drm_encoder *, void *))\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_encoder *encoder;\r\nstruct exynos_drm_private *private = dev->dev_private;\r\nstruct exynos_drm_manager *manager;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (!encoder->crtc) {\r\nmanager = to_exynos_encoder(encoder)->manager;\r\nif (manager->pipe < 0 ||\r\nprivate->crtc[manager->pipe] != crtc)\r\ncontinue;\r\n} else {\r\nif (encoder->crtc != crtc)\r\ncontinue;\r\n}\r\nfn(encoder, data);\r\n}\r\n}\r\nvoid exynos_drm_enable_vblank(struct drm_encoder *encoder, void *data)\r\n{\r\nstruct exynos_drm_manager *manager =\r\nto_exynos_encoder(encoder)->manager;\r\nstruct exynos_drm_manager_ops *manager_ops = manager->ops;\r\nint crtc = *(int *)data;\r\nif (manager->pipe != crtc)\r\nreturn;\r\nif (manager_ops->enable_vblank)\r\nmanager_ops->enable_vblank(manager->dev);\r\n}\r\nvoid exynos_drm_disable_vblank(struct drm_encoder *encoder, void *data)\r\n{\r\nstruct exynos_drm_manager *manager =\r\nto_exynos_encoder(encoder)->manager;\r\nstruct exynos_drm_manager_ops *manager_ops = manager->ops;\r\nint crtc = *(int *)data;\r\nif (manager->pipe != crtc)\r\nreturn;\r\nif (manager_ops->disable_vblank)\r\nmanager_ops->disable_vblank(manager->dev);\r\n}\r\nvoid exynos_drm_encoder_crtc_dpms(struct drm_encoder *encoder, void *data)\r\n{\r\nstruct exynos_drm_encoder *exynos_encoder = to_exynos_encoder(encoder);\r\nstruct exynos_drm_manager *manager = exynos_encoder->manager;\r\nstruct exynos_drm_manager_ops *manager_ops = manager->ops;\r\nint mode = *(int *)data;\r\nif (manager_ops && manager_ops->dpms)\r\nmanager_ops->dpms(manager->dev, mode);\r\nif (mode > DRM_MODE_DPMS_ON) {\r\nif (!encoder->crtc)\r\nmanager->pipe = -1;\r\n}\r\n}\r\nvoid exynos_drm_encoder_crtc_pipe(struct drm_encoder *encoder, void *data)\r\n{\r\nstruct exynos_drm_manager *manager =\r\nto_exynos_encoder(encoder)->manager;\r\nint pipe = *(int *)data;\r\nmanager->pipe = pipe;\r\n}\r\nvoid exynos_drm_encoder_plane_mode_set(struct drm_encoder *encoder, void *data)\r\n{\r\nstruct exynos_drm_manager *manager =\r\nto_exynos_encoder(encoder)->manager;\r\nstruct exynos_drm_overlay_ops *overlay_ops = manager->overlay_ops;\r\nstruct exynos_drm_overlay *overlay = data;\r\nif (overlay_ops && overlay_ops->mode_set)\r\noverlay_ops->mode_set(manager->dev, overlay);\r\n}\r\nvoid exynos_drm_encoder_plane_commit(struct drm_encoder *encoder, void *data)\r\n{\r\nstruct exynos_drm_manager *manager =\r\nto_exynos_encoder(encoder)->manager;\r\nstruct exynos_drm_overlay_ops *overlay_ops = manager->overlay_ops;\r\nint zpos = DEFAULT_ZPOS;\r\nif (data)\r\nzpos = *(int *)data;\r\nif (overlay_ops && overlay_ops->commit)\r\noverlay_ops->commit(manager->dev, zpos);\r\n}\r\nvoid exynos_drm_encoder_plane_enable(struct drm_encoder *encoder, void *data)\r\n{\r\nstruct exynos_drm_manager *manager =\r\nto_exynos_encoder(encoder)->manager;\r\nstruct exynos_drm_overlay_ops *overlay_ops = manager->overlay_ops;\r\nint zpos = DEFAULT_ZPOS;\r\nif (data)\r\nzpos = *(int *)data;\r\nif (overlay_ops && overlay_ops->enable)\r\noverlay_ops->enable(manager->dev, zpos);\r\n}\r\nvoid exynos_drm_encoder_plane_disable(struct drm_encoder *encoder, void *data)\r\n{\r\nstruct exynos_drm_manager *manager =\r\nto_exynos_encoder(encoder)->manager;\r\nstruct exynos_drm_overlay_ops *overlay_ops = manager->overlay_ops;\r\nint zpos = DEFAULT_ZPOS;\r\nif (data)\r\nzpos = *(int *)data;\r\nif (overlay_ops && overlay_ops->disable)\r\noverlay_ops->disable(manager->dev, zpos);\r\n}
