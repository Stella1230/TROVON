int go7007_read_interrupt(struct go7007 *go, u16 *value, u16 *data)\r\n{\r\ngo->interrupt_available = 0;\r\ngo->hpi_ops->read_interrupt(go);\r\nif (wait_event_timeout(go->interrupt_waitq,\r\ngo->interrupt_available, 5*HZ) < 0) {\r\nv4l2_err(&go->v4l2_dev, "timeout waiting for read interrupt\n");\r\nreturn -1;\r\n}\r\nif (!go->interrupt_available)\r\nreturn -1;\r\ngo->interrupt_available = 0;\r\n*value = go->interrupt_value & 0xfffe;\r\n*data = go->interrupt_data;\r\nreturn 0;\r\n}\r\nint go7007_read_addr(struct go7007 *go, u16 addr, u16 *data)\r\n{\r\nint count = 100;\r\nu16 value;\r\nif (go7007_write_interrupt(go, 0x0010, addr) < 0)\r\nreturn -EIO;\r\nwhile (count-- > 0) {\r\nif (go7007_read_interrupt(go, &value, data) == 0 &&\r\nvalue == 0xa000)\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int go7007_load_encoder(struct go7007 *go)\r\n{\r\nconst struct firmware *fw_entry;\r\nchar fw_name[] = "go7007/go7007fw.bin";\r\nvoid *bounce;\r\nint fw_len, rv = 0;\r\nu16 intr_val, intr_data;\r\nif (go->boot_fw == NULL) {\r\nif (request_firmware(&fw_entry, fw_name, go->dev)) {\r\nv4l2_err(go, "unable to load firmware from file \"%s\"\n", fw_name);\r\nreturn -1;\r\n}\r\nif (fw_entry->size < 16 || memcmp(fw_entry->data, "WISGO7007FW", 11)) {\r\nv4l2_err(go, "file \"%s\" does not appear to be go7007 firmware\n", fw_name);\r\nrelease_firmware(fw_entry);\r\nreturn -1;\r\n}\r\nfw_len = fw_entry->size - 16;\r\nbounce = kmemdup(fw_entry->data + 16, fw_len, GFP_KERNEL);\r\nif (bounce == NULL) {\r\nv4l2_err(go, "unable to allocate %d bytes for firmware transfer\n", fw_len);\r\nrelease_firmware(fw_entry);\r\nreturn -1;\r\n}\r\nrelease_firmware(fw_entry);\r\ngo->boot_fw_len = fw_len;\r\ngo->boot_fw = bounce;\r\n}\r\nif (go7007_interface_reset(go) < 0 ||\r\ngo7007_send_firmware(go, go->boot_fw, go->boot_fw_len) < 0 ||\r\ngo7007_read_interrupt(go, &intr_val, &intr_data) < 0 ||\r\n(intr_val & ~0x1) != 0x5a5a) {\r\nv4l2_err(go, "error transferring firmware\n");\r\nrv = -1;\r\n}\r\nreturn rv;\r\n}\r\nint go7007_boot_encoder(struct go7007 *go, int init_i2c)\r\n{\r\nint ret;\r\nmutex_lock(&go->hw_lock);\r\nret = go7007_load_encoder(go);\r\nmutex_unlock(&go->hw_lock);\r\nif (ret < 0)\r\nreturn -1;\r\nif (!init_i2c)\r\nreturn 0;\r\nif (go7007_i2c_init(go) < 0)\r\nreturn -1;\r\ngo->i2c_adapter_online = 1;\r\nreturn 0;\r\n}\r\nstatic int go7007_init_encoder(struct go7007 *go)\r\n{\r\nif (go->board_info->audio_flags & GO7007_AUDIO_I2S_MASTER) {\r\ngo7007_write_addr(go, 0x1000, 0x0811);\r\ngo7007_write_addr(go, 0x1000, 0x0c11);\r\n}\r\nswitch (go->board_id) {\r\ncase GO7007_BOARDID_MATRIX_REV:\r\ngo7007_write_addr(go, 0x3c82, 0x0001);\r\ngo7007_write_addr(go, 0x3c80, 0x00fe);\r\nbreak;\r\ncase GO7007_BOARDID_ADLINK_MPG24:\r\ngo7007_write_addr(go, 0x3c82, 0x0000);\r\ngo7007_write_addr(go, 0x3c80, 0x00df);\r\nbreak;\r\ncase GO7007_BOARDID_ADS_USBAV_709:\r\ngo7007_write_addr(go, 0x3c82, 0x000d);\r\ngo7007_write_addr(go, 0x3c80, 0x00f2);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint go7007_reset_encoder(struct go7007 *go)\r\n{\r\nif (go7007_load_encoder(go) < 0)\r\nreturn -1;\r\nreturn go7007_init_encoder(go);\r\n}\r\nstatic int init_i2c_module(struct i2c_adapter *adapter, const struct go_i2c *const i2c)\r\n{\r\nstruct go7007 *go = i2c_get_adapdata(adapter);\r\nstruct v4l2_device *v4l2_dev = &go->v4l2_dev;\r\nstruct v4l2_subdev *sd;\r\nstruct i2c_board_info info;\r\nmemset(&info, 0, sizeof(info));\r\nstrlcpy(info.type, i2c->type, sizeof(info.type));\r\ninfo.addr = i2c->addr;\r\ninfo.flags = i2c->flags;\r\nsd = v4l2_i2c_new_subdev_board(v4l2_dev, adapter, &info, NULL);\r\nif (sd) {\r\nif (i2c->is_video)\r\ngo->sd_video = sd;\r\nif (i2c->is_audio)\r\ngo->sd_audio = sd;\r\nreturn 0;\r\n}\r\nprintk(KERN_INFO "go7007: probing for module i2c:%s failed\n", i2c->type);\r\nreturn -EINVAL;\r\n}\r\nstatic void go7007_remove(struct v4l2_device *v4l2_dev)\r\n{\r\nstruct go7007 *go = container_of(v4l2_dev, struct go7007, v4l2_dev);\r\nv4l2_device_unregister(v4l2_dev);\r\nif (go->hpi_ops->release)\r\ngo->hpi_ops->release(go);\r\nif (go->i2c_adapter_online) {\r\ni2c_del_adapter(&go->i2c_adapter);\r\ngo->i2c_adapter_online = 0;\r\n}\r\nkfree(go->boot_fw);\r\ngo7007_v4l2_remove(go);\r\nkfree(go);\r\n}\r\nint go7007_register_encoder(struct go7007 *go, unsigned num_i2c_devs)\r\n{\r\nint i, ret;\r\ndev_info(go->dev, "go7007: registering new %s\n", go->name);\r\ngo->v4l2_dev.release = go7007_remove;\r\nret = v4l2_device_register(go->dev, &go->v4l2_dev);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&go->hw_lock);\r\nret = go7007_init_encoder(go);\r\nmutex_unlock(&go->hw_lock);\r\nif (ret < 0)\r\nreturn ret;\r\nret = go7007_v4l2_ctrl_init(go);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!go->i2c_adapter_online &&\r\ngo->board_info->flags & GO7007_BOARD_USE_ONBOARD_I2C) {\r\nret = go7007_i2c_init(go);\r\nif (ret < 0)\r\nreturn ret;\r\ngo->i2c_adapter_online = 1;\r\n}\r\nif (go->i2c_adapter_online) {\r\nif (go->board_id == GO7007_BOARDID_ADS_USBAV_709) {\r\ngo7007_write_addr(go, 0x3c82, 0x0009);\r\nmsleep(50);\r\ngo7007_write_addr(go, 0x3c82, 0x000d);\r\n}\r\nfor (i = 0; i < num_i2c_devs; ++i)\r\ninit_i2c_module(&go->i2c_adapter, &go->board_info->i2c_devs[i]);\r\nif (go->tuner_type >= 0) {\r\nstruct tuner_setup setup = {\r\n.addr = ADDR_UNSET,\r\n.type = go->tuner_type,\r\n.mode_mask = T_ANALOG_TV,\r\n};\r\nv4l2_device_call_all(&go->v4l2_dev, 0, tuner,\r\ns_type_addr, &setup);\r\n}\r\nif (go->board_id == GO7007_BOARDID_ADLINK_MPG24)\r\nv4l2_subdev_call(go->sd_video, video, s_routing,\r\n0, 0, go->channel_number + 1);\r\n}\r\nret = go7007_v4l2_init(go);\r\nif (ret < 0)\r\nreturn ret;\r\nif (go->board_info->flags & GO7007_BOARD_HAS_AUDIO) {\r\ngo->audio_enabled = 1;\r\ngo7007_snd_init(go);\r\n}\r\nreturn 0;\r\n}\r\nint go7007_start_encoder(struct go7007 *go)\r\n{\r\nu8 *fw;\r\nint fw_len, rv = 0, i;\r\nu16 intr_val, intr_data;\r\ngo->modet_enable = 0;\r\nif (!go->dvd_mode)\r\nfor (i = 0; i < 4; ++i) {\r\nif (go->modet[i].enable) {\r\ngo->modet_enable = 1;\r\ncontinue;\r\n}\r\ngo->modet[i].pixel_threshold = 32767;\r\ngo->modet[i].motion_threshold = 32767;\r\ngo->modet[i].mb_threshold = 32767;\r\n}\r\nif (go7007_construct_fw_image(go, &fw, &fw_len) < 0)\r\nreturn -1;\r\nif (go7007_send_firmware(go, fw, fw_len) < 0 ||\r\ngo7007_read_interrupt(go, &intr_val, &intr_data) < 0) {\r\nv4l2_err(&go->v4l2_dev, "error transferring firmware\n");\r\nrv = -1;\r\ngoto start_error;\r\n}\r\ngo->state = STATE_DATA;\r\ngo->parse_length = 0;\r\ngo->seen_frame = 0;\r\nif (go7007_stream_start(go) < 0) {\r\nv4l2_err(&go->v4l2_dev, "error starting stream transfer\n");\r\nrv = -1;\r\ngoto start_error;\r\n}\r\nstart_error:\r\nkfree(fw);\r\nreturn rv;\r\n}\r\nstatic inline void store_byte(struct go7007_buffer *vb, u8 byte)\r\n{\r\nif (vb && vb->vb.v4l2_planes[0].bytesused < GO7007_BUF_SIZE) {\r\nu8 *ptr = vb2_plane_vaddr(&vb->vb, 0);\r\nptr[vb->vb.v4l2_planes[0].bytesused++] = byte;\r\n}\r\n}\r\nstatic struct go7007_buffer *frame_boundary(struct go7007 *go, struct go7007_buffer *vb)\r\n{\r\nstruct go7007_buffer *vb_tmp = NULL;\r\nu32 *bytesused = &vb->vb.v4l2_planes[0].bytesused;\r\nint i;\r\nif (vb) {\r\nif (vb->modet_active) {\r\nif (*bytesused + 216 < GO7007_BUF_SIZE) {\r\nfor (i = 0; i < 216; ++i)\r\nstore_byte(vb, go->active_map[i]);\r\n*bytesused -= 216;\r\n} else\r\nvb->modet_active = 0;\r\n}\r\nvb->vb.v4l2_buf.sequence = go->next_seq++;\r\nv4l2_get_timestamp(&vb->vb.v4l2_buf.timestamp);\r\nvb_tmp = vb;\r\nspin_lock(&go->spinlock);\r\nlist_del(&vb->list);\r\nif (list_empty(&go->vidq_active))\r\nvb = NULL;\r\nelse\r\nvb = list_first_entry(&go->vidq_active, struct go7007_buffer, list);\r\ngo->active_buf = vb;\r\nspin_unlock(&go->spinlock);\r\nvb2_buffer_done(&vb_tmp->vb, VB2_BUF_STATE_DONE);\r\nreturn vb;\r\n}\r\nspin_lock(&go->spinlock);\r\nif (!list_empty(&go->vidq_active))\r\nvb = go->active_buf =\r\nlist_first_entry(&go->vidq_active, struct go7007_buffer, list);\r\nspin_unlock(&go->spinlock);\r\ngo->next_seq++;\r\nreturn vb;\r\n}\r\nstatic void write_bitmap_word(struct go7007 *go)\r\n{\r\nint x, y, i, stride = ((go->width >> 4) + 7) >> 3;\r\nfor (i = 0; i < 16; ++i) {\r\ny = (((go->parse_length - 1) << 3) + i) / (go->width >> 4);\r\nx = (((go->parse_length - 1) << 3) + i) % (go->width >> 4);\r\nif (stride * y + (x >> 3) < sizeof(go->active_map))\r\ngo->active_map[stride * y + (x >> 3)] |=\r\n(go->modet_word & 1) << (x & 0x7);\r\ngo->modet_word >>= 1;\r\n}\r\n}\r\nvoid go7007_parse_video_stream(struct go7007 *go, u8 *buf, int length)\r\n{\r\nstruct go7007_buffer *vb = go->active_buf;\r\nint i, seq_start_code = -1, gop_start_code = -1, frame_start_code = -1;\r\nswitch (go->format) {\r\ncase V4L2_PIX_FMT_MPEG4:\r\nseq_start_code = 0xB0;\r\ngop_start_code = 0xB3;\r\nframe_start_code = 0xB6;\r\nbreak;\r\ncase V4L2_PIX_FMT_MPEG1:\r\ncase V4L2_PIX_FMT_MPEG2:\r\nseq_start_code = 0xB3;\r\ngop_start_code = 0xB8;\r\nframe_start_code = 0x00;\r\nbreak;\r\n}\r\nfor (i = 0; i < length; ++i) {\r\nif (vb && vb->vb.v4l2_planes[0].bytesused >= GO7007_BUF_SIZE - 3) {\r\nv4l2_info(&go->v4l2_dev, "dropping oversized frame\n");\r\nvb->vb.v4l2_planes[0].bytesused = 0;\r\nvb->frame_offset = 0;\r\nvb->modet_active = 0;\r\nvb = go->active_buf = NULL;\r\n}\r\nswitch (go->state) {\r\ncase STATE_DATA:\r\nswitch (buf[i]) {\r\ncase 0x00:\r\ngo->state = STATE_00;\r\nbreak;\r\ncase 0xFF:\r\ngo->state = STATE_FF;\r\nbreak;\r\ndefault:\r\nstore_byte(vb, buf[i]);\r\nbreak;\r\n}\r\nbreak;\r\ncase STATE_00:\r\nswitch (buf[i]) {\r\ncase 0x00:\r\ngo->state = STATE_00_00;\r\nbreak;\r\ncase 0xFF:\r\nstore_byte(vb, 0x00);\r\ngo->state = STATE_FF;\r\nbreak;\r\ndefault:\r\nstore_byte(vb, 0x00);\r\nstore_byte(vb, buf[i]);\r\ngo->state = STATE_DATA;\r\nbreak;\r\n}\r\nbreak;\r\ncase STATE_00_00:\r\nswitch (buf[i]) {\r\ncase 0x00:\r\nstore_byte(vb, 0x00);\r\nbreak;\r\ncase 0x01:\r\ngo->state = STATE_00_00_01;\r\nbreak;\r\ncase 0xFF:\r\nstore_byte(vb, 0x00);\r\nstore_byte(vb, 0x00);\r\ngo->state = STATE_FF;\r\nbreak;\r\ndefault:\r\nstore_byte(vb, 0x00);\r\nstore_byte(vb, 0x00);\r\nstore_byte(vb, buf[i]);\r\ngo->state = STATE_DATA;\r\nbreak;\r\n}\r\nbreak;\r\ncase STATE_00_00_01:\r\nif (buf[i] == 0xF8 && go->modet_enable == 0) {\r\nstore_byte(vb, 0x00);\r\nstore_byte(vb, 0x00);\r\nstore_byte(vb, 0x01);\r\nstore_byte(vb, 0xF8);\r\ngo->state = STATE_DATA;\r\nbreak;\r\n}\r\nif ((go->format == V4L2_PIX_FMT_MPEG1 ||\r\ngo->format == V4L2_PIX_FMT_MPEG2 ||\r\ngo->format == V4L2_PIX_FMT_MPEG4) &&\r\n(buf[i] == seq_start_code ||\r\nbuf[i] == gop_start_code ||\r\nbuf[i] == frame_start_code)) {\r\nif (vb == NULL || go->seen_frame)\r\nvb = frame_boundary(go, vb);\r\ngo->seen_frame = buf[i] == frame_start_code;\r\nif (vb && go->seen_frame)\r\nvb->frame_offset = vb->vb.v4l2_planes[0].bytesused;\r\n}\r\nswitch (buf[i]) {\r\ncase 0xF5:\r\ngo->parse_length = 12;\r\ngo->state = STATE_UNPARSED;\r\nbreak;\r\ncase 0xF6:\r\ngo->state = STATE_VBI_LEN_A;\r\nbreak;\r\ncase 0xF8:\r\ngo->parse_length = 0;\r\nmemset(go->active_map, 0,\r\nsizeof(go->active_map));\r\ngo->state = STATE_MODET_MAP;\r\nbreak;\r\ncase 0xFF:\r\nstore_byte(vb, 0x00);\r\nstore_byte(vb, 0x00);\r\nstore_byte(vb, 0x01);\r\ngo->state = STATE_FF;\r\nbreak;\r\ndefault:\r\nstore_byte(vb, 0x00);\r\nstore_byte(vb, 0x00);\r\nstore_byte(vb, 0x01);\r\nstore_byte(vb, buf[i]);\r\ngo->state = STATE_DATA;\r\nbreak;\r\n}\r\nbreak;\r\ncase STATE_FF:\r\nswitch (buf[i]) {\r\ncase 0x00:\r\nstore_byte(vb, 0xFF);\r\ngo->state = STATE_00;\r\nbreak;\r\ncase 0xFF:\r\nstore_byte(vb, 0xFF);\r\nbreak;\r\ncase 0xD8:\r\nif (go->format == V4L2_PIX_FMT_MJPEG)\r\nvb = frame_boundary(go, vb);\r\ndefault:\r\nstore_byte(vb, 0xFF);\r\nstore_byte(vb, buf[i]);\r\ngo->state = STATE_DATA;\r\nbreak;\r\n}\r\nbreak;\r\ncase STATE_VBI_LEN_A:\r\ngo->parse_length = buf[i] << 8;\r\ngo->state = STATE_VBI_LEN_B;\r\nbreak;\r\ncase STATE_VBI_LEN_B:\r\ngo->parse_length |= buf[i];\r\nif (go->parse_length > 0)\r\ngo->state = STATE_UNPARSED;\r\nelse\r\ngo->state = STATE_DATA;\r\nbreak;\r\ncase STATE_MODET_MAP:\r\nif (go->parse_length < 204) {\r\nif (go->parse_length & 1) {\r\ngo->modet_word |= buf[i];\r\nwrite_bitmap_word(go);\r\n} else\r\ngo->modet_word = buf[i] << 8;\r\n} else if (go->parse_length == 207 && vb) {\r\nvb->modet_active = buf[i];\r\n}\r\nif (++go->parse_length == 208)\r\ngo->state = STATE_DATA;\r\nbreak;\r\ncase STATE_UNPARSED:\r\nif (--go->parse_length == 0)\r\ngo->state = STATE_DATA;\r\nbreak;\r\n}\r\n}\r\n}\r\nstruct go7007 *go7007_alloc(const struct go7007_board_info *board,\r\nstruct device *dev)\r\n{\r\nstruct go7007 *go;\r\nint i;\r\ngo = kzalloc(sizeof(struct go7007), GFP_KERNEL);\r\nif (go == NULL)\r\nreturn NULL;\r\ngo->dev = dev;\r\ngo->board_info = board;\r\ngo->board_id = 0;\r\ngo->tuner_type = -1;\r\ngo->channel_number = 0;\r\ngo->name[0] = 0;\r\nmutex_init(&go->hw_lock);\r\ninit_waitqueue_head(&go->frame_waitq);\r\nspin_lock_init(&go->spinlock);\r\ngo->status = STATUS_INIT;\r\nmemset(&go->i2c_adapter, 0, sizeof(go->i2c_adapter));\r\ngo->i2c_adapter_online = 0;\r\ngo->interrupt_available = 0;\r\ninit_waitqueue_head(&go->interrupt_waitq);\r\ngo->input = 0;\r\ngo7007_update_board(go);\r\ngo->encoder_h_halve = 0;\r\ngo->encoder_v_halve = 0;\r\ngo->encoder_subsample = 0;\r\ngo->format = V4L2_PIX_FMT_MJPEG;\r\ngo->bitrate = 1500000;\r\ngo->fps_scale = 1;\r\ngo->pali = 0;\r\ngo->aspect_ratio = GO7007_RATIO_1_1;\r\ngo->gop_size = 0;\r\ngo->ipb = 0;\r\ngo->closed_gop = 0;\r\ngo->repeat_seqhead = 0;\r\ngo->seq_header_enable = 0;\r\ngo->gop_header_enable = 0;\r\ngo->dvd_mode = 0;\r\ngo->interlace_coding = 0;\r\nfor (i = 0; i < 4; ++i)\r\ngo->modet[i].enable = 0;\r\nfor (i = 0; i < 1624; ++i)\r\ngo->modet_map[i] = 0;\r\ngo->audio_deliver = NULL;\r\ngo->audio_enabled = 0;\r\nreturn go;\r\n}\r\nvoid go7007_update_board(struct go7007 *go)\r\n{\r\nconst struct go7007_board_info *board = go->board_info;\r\nif (board->sensor_flags & GO7007_SENSOR_TV) {\r\ngo->standard = GO7007_STD_NTSC;\r\ngo->std = V4L2_STD_NTSC_M;\r\ngo->width = 720;\r\ngo->height = 480;\r\ngo->sensor_framerate = 30000;\r\n} else {\r\ngo->standard = GO7007_STD_OTHER;\r\ngo->width = board->sensor_width;\r\ngo->height = board->sensor_height;\r\ngo->sensor_framerate = board->sensor_framerate;\r\n}\r\ngo->encoder_v_offset = board->sensor_v_offset;\r\ngo->encoder_h_offset = board->sensor_h_offset;\r\n}
