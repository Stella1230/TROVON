static struct poll_delay_t poll_delay_min_max(int min, int max)\r\n{\r\nstruct poll_delay_t result;\r\nresult.min = min;\r\nresult.max = max;\r\nreturn result;\r\n}\r\nstatic int is_complete(struct jr3_channel __iomem *channel)\r\n{\r\nreturn get_s16(&channel->command_word0) == 0;\r\n}\r\nstatic void set_transforms(struct jr3_channel __iomem *channel,\r\nstruct transform_t transf, short num)\r\n{\r\nint i;\r\nnum &= 0x000f;\r\nfor (i = 0; i < 8; i++) {\r\nset_u16(&channel->transforms[num].link[i].link_type,\r\ntransf.link[i].link_type);\r\nudelay(1);\r\nset_s16(&channel->transforms[num].link[i].link_amount,\r\ntransf.link[i].link_amount);\r\nudelay(1);\r\nif (transf.link[i].link_type == end_x_form)\r\nbreak;\r\n}\r\n}\r\nstatic void use_transform(struct jr3_channel __iomem *channel,\r\nshort transf_num)\r\n{\r\nset_s16(&channel->command_word0, 0x0500 + (transf_num & 0x000f));\r\n}\r\nstatic void use_offset(struct jr3_channel __iomem *channel, short offset_num)\r\n{\r\nset_s16(&channel->command_word0, 0x0600 + (offset_num & 0x000f));\r\n}\r\nstatic void set_offset(struct jr3_channel __iomem *channel)\r\n{\r\nset_s16(&channel->command_word0, 0x0700);\r\n}\r\nstatic void set_full_scales(struct jr3_channel __iomem *channel,\r\nstruct six_axis_t full_scale)\r\n{\r\nset_s16(&channel->full_scale.fx, full_scale.fx);\r\nset_s16(&channel->full_scale.fy, full_scale.fy);\r\nset_s16(&channel->full_scale.fz, full_scale.fz);\r\nset_s16(&channel->full_scale.mx, full_scale.mx);\r\nset_s16(&channel->full_scale.my, full_scale.my);\r\nset_s16(&channel->full_scale.mz, full_scale.mz);\r\nset_s16(&channel->command_word0, 0x0a00);\r\n}\r\nstatic struct six_axis_t get_min_full_scales(struct jr3_channel __iomem\r\n*channel)\r\n{\r\nstruct six_axis_t result;\r\nresult.fx = get_s16(&channel->min_full_scale.fx);\r\nresult.fy = get_s16(&channel->min_full_scale.fy);\r\nresult.fz = get_s16(&channel->min_full_scale.fz);\r\nresult.mx = get_s16(&channel->min_full_scale.mx);\r\nresult.my = get_s16(&channel->min_full_scale.my);\r\nresult.mz = get_s16(&channel->min_full_scale.mz);\r\nreturn result;\r\n}\r\nstatic struct six_axis_t get_max_full_scales(struct jr3_channel __iomem\r\n*channel)\r\n{\r\nstruct six_axis_t result;\r\nresult.fx = get_s16(&channel->max_full_scale.fx);\r\nresult.fy = get_s16(&channel->max_full_scale.fy);\r\nresult.fz = get_s16(&channel->max_full_scale.fz);\r\nresult.mx = get_s16(&channel->max_full_scale.mx);\r\nresult.my = get_s16(&channel->max_full_scale.my);\r\nresult.mz = get_s16(&channel->max_full_scale.mz);\r\nreturn result;\r\n}\r\nstatic int jr3_pci_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nint result;\r\nstruct jr3_pci_subdev_private *p;\r\nint channel;\r\np = s->private;\r\nchannel = CR_CHAN(insn->chanspec);\r\nif (p == NULL || channel > 57) {\r\nresult = -EINVAL;\r\n} else {\r\nint i;\r\nresult = insn->n;\r\nif (p->state != state_jr3_done ||\r\n(get_u16(&p->channel->errors) & (watch_dog | watch_dog2 |\r\nsensor_change))) {\r\nif (p->state == state_jr3_done) {\r\np->state = state_jr3_poll;\r\n}\r\nresult = -EAGAIN;\r\n}\r\nfor (i = 0; i < insn->n; i++) {\r\nif (channel < 56) {\r\nint axis, filter;\r\naxis = channel % 8;\r\nfilter = channel / 8;\r\nif (p->state != state_jr3_done) {\r\ndata[i] = 0;\r\n} else {\r\nint F = 0;\r\nswitch (axis) {\r\ncase 0:\r\nF = get_s16(&p->channel->\r\nfilter[filter].fx);\r\nbreak;\r\ncase 1:\r\nF = get_s16(&p->channel->\r\nfilter[filter].fy);\r\nbreak;\r\ncase 2:\r\nF = get_s16(&p->channel->\r\nfilter[filter].fz);\r\nbreak;\r\ncase 3:\r\nF = get_s16(&p->channel->\r\nfilter[filter].mx);\r\nbreak;\r\ncase 4:\r\nF = get_s16(&p->channel->\r\nfilter[filter].my);\r\nbreak;\r\ncase 5:\r\nF = get_s16(&p->channel->\r\nfilter[filter].mz);\r\nbreak;\r\ncase 6:\r\nF = get_s16(&p->channel->\r\nfilter[filter].v1);\r\nbreak;\r\ncase 7:\r\nF = get_s16(&p->channel->\r\nfilter[filter].v2);\r\nbreak;\r\n}\r\ndata[i] = F + 0x4000;\r\n}\r\n} else if (channel == 56) {\r\nif (p->state != state_jr3_done)\r\ndata[i] = 0;\r\nelse\r\ndata[i] =\r\nget_u16(&p->channel->model_no);\r\n} else if (channel == 57) {\r\nif (p->state != state_jr3_done)\r\ndata[i] = 0;\r\nelse\r\ndata[i] =\r\nget_u16(&p->channel->serial_no);\r\n}\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int jr3_pci_open(struct comedi_device *dev)\r\n{\r\nint i;\r\nstruct jr3_pci_dev_private *devpriv = dev->private;\r\ndev_dbg(dev->class_dev, "jr3_pci_open\n");\r\nfor (i = 0; i < devpriv->n_channels; i++) {\r\nstruct jr3_pci_subdev_private *p;\r\np = dev->subdevices[i].private;\r\nif (p) {\r\ndev_dbg(dev->class_dev, "serial: %p %d (%d)\n", p,\r\np->serial_no, p->channel_no);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_idm_word(const u8 *data, size_t size, int *pos,\r\nunsigned int *val)\r\n{\r\nint result = 0;\r\nif (pos && val) {\r\nfor (; *pos < size && !isxdigit(data[*pos]); (*pos)++)\r\n;\r\n*val = 0;\r\nfor (; *pos < size; (*pos)++) {\r\nint value;\r\nvalue = hex_to_bin(data[*pos]);\r\nif (value >= 0) {\r\nresult = 1;\r\n*val = (*val << 4) + value;\r\n} else {\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int jr3_download_firmware(struct comedi_device *dev,\r\nconst u8 *data, size_t size,\r\nunsigned long context)\r\n{\r\nint result, more, pos, OK;\r\nresult = 0;\r\nmore = 1;\r\npos = 0;\r\nOK = 0;\r\nwhile (more) {\r\nunsigned int count, addr;\r\nmore = more && read_idm_word(data, size, &pos, &count);\r\nif (more && count == 0xffff) {\r\nOK = 1;\r\nbreak;\r\n}\r\nmore = more && read_idm_word(data, size, &pos, &addr);\r\nwhile (more && count > 0) {\r\nunsigned int dummy;\r\nmore = more && read_idm_word(data, size, &pos, &dummy);\r\ncount--;\r\n}\r\n}\r\nif (!OK) {\r\nresult = -ENODATA;\r\n} else {\r\nint i;\r\nstruct jr3_pci_dev_private *p = dev->private;\r\nfor (i = 0; i < p->n_channels; i++) {\r\nstruct jr3_pci_subdev_private *sp;\r\nsp = dev->subdevices[i].private;\r\nmore = 1;\r\npos = 0;\r\nwhile (more) {\r\nunsigned int count, addr;\r\nmore = more &&\r\nread_idm_word(data, size, &pos, &count);\r\nif (more && count == 0xffff)\r\nbreak;\r\nmore = more &&\r\nread_idm_word(data, size, &pos, &addr);\r\ndev_dbg(dev->class_dev,\r\n"Loading#%d %4.4x bytes at %4.4x\n",\r\ni, count, addr);\r\nwhile (more && count > 0) {\r\nif (addr & 0x4000) {\r\nunsigned int data1;\r\nmore = more &&\r\nread_idm_word(data,\r\nsize, &pos,\r\n&data1);\r\ncount--;\r\n} else {\r\nunsigned int data1, data2;\r\nmore = more &&\r\nread_idm_word(data,\r\nsize, &pos,\r\n&data1);\r\nmore = more &&\r\nread_idm_word(data, size,\r\n&pos,\r\n&data2);\r\ncount -= 2;\r\nif (more) {\r\nset_u16(&p->\r\niobase->channel\r\n[i].program_low\r\n[addr], data1);\r\nudelay(1);\r\nset_u16(&p->\r\niobase->channel\r\n[i].program_high\r\n[addr], data2);\r\nudelay(1);\r\n}\r\n}\r\naddr++;\r\n}\r\n}\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic struct poll_delay_t jr3_pci_poll_subdevice(struct comedi_subdevice *s)\r\n{\r\nstruct poll_delay_t result = poll_delay_min_max(1000, 2000);\r\nstruct jr3_pci_subdev_private *p = s->private;\r\nint i;\r\nif (p) {\r\nstruct jr3_channel __iomem *channel = p->channel;\r\nint errors = get_u16(&channel->errors);\r\nif (errors != p->errors)\r\np->errors = errors;\r\nif (errors & (watch_dog | watch_dog2 | sensor_change))\r\np->state = state_jr3_poll;\r\nswitch (p->state) {\r\ncase state_jr3_poll: {\r\nu16 model_no = get_u16(&channel->model_no);\r\nu16 serial_no = get_u16(&channel->serial_no);\r\nif ((errors & (watch_dog | watch_dog2)) ||\r\nmodel_no == 0 || serial_no == 0) {\r\nresult = poll_delay_min_max(1000, 2000);\r\n} else {\r\np->retries = 0;\r\np->state =\r\nstate_jr3_init_wait_for_offset;\r\nresult = poll_delay_min_max(1000, 2000);\r\n}\r\n}\r\nbreak;\r\ncase state_jr3_init_wait_for_offset:\r\np->retries++;\r\nif (p->retries < 10) {\r\nresult = poll_delay_min_max(1000, 2000);\r\n} else {\r\nstruct transform_t transf;\r\np->model_no = get_u16(&channel->model_no);\r\np->serial_no = get_u16(&channel->serial_no);\r\nfor (i = 0; i < ARRAY_SIZE(transf.link); i++) {\r\ntransf.link[i].link_type =\r\n(enum link_types)0;\r\ntransf.link[i].link_amount = 0;\r\n}\r\nset_transforms(channel, transf, 0);\r\nuse_transform(channel, 0);\r\np->state = state_jr3_init_transform_complete;\r\nresult = poll_delay_min_max(20, 100);\r\n}\r\nbreak;\r\ncase state_jr3_init_transform_complete:\r\nif (!is_complete(channel)) {\r\nresult = poll_delay_min_max(20, 100);\r\n} else {\r\nstruct six_axis_t min_full_scale;\r\nstruct six_axis_t max_full_scale;\r\nmin_full_scale = get_min_full_scales(channel);\r\nmax_full_scale = get_max_full_scales(channel);\r\nset_full_scales(channel, max_full_scale);\r\np->state =\r\nstate_jr3_init_set_full_scale_complete;\r\nresult = poll_delay_min_max(20, 100);\r\n}\r\nbreak;\r\ncase state_jr3_init_set_full_scale_complete:\r\nif (!is_complete(channel)) {\r\nresult = poll_delay_min_max(20, 100);\r\n} else {\r\nstruct force_array __iomem *full_scale;\r\nfull_scale = &channel->full_scale;\r\np->range[0].range.min =\r\n-get_s16(&full_scale->fx) * 1000;\r\np->range[0].range.max =\r\nget_s16(&full_scale->fx) * 1000;\r\np->range[1].range.min =\r\n-get_s16(&full_scale->fy) * 1000;\r\np->range[1].range.max =\r\nget_s16(&full_scale->fy) * 1000;\r\np->range[2].range.min =\r\n-get_s16(&full_scale->fz) * 1000;\r\np->range[2].range.max =\r\nget_s16(&full_scale->fz) * 1000;\r\np->range[3].range.min =\r\n-get_s16(&full_scale->mx) * 100;\r\np->range[3].range.max =\r\nget_s16(&full_scale->mx) * 100;\r\np->range[4].range.min =\r\n-get_s16(&full_scale->my) * 100;\r\np->range[4].range.max =\r\nget_s16(&full_scale->my) * 100;\r\np->range[5].range.min =\r\n-get_s16(&full_scale->mz) * 100;\r\np->range[5].range.max =\r\nget_s16(&full_scale->mz) * 100;\r\np->range[6].range.min =\r\n-get_s16(&full_scale->v1) * 100;\r\np->range[6].range.max =\r\nget_s16(&full_scale->v1) * 100;\r\np->range[7].range.min =\r\n-get_s16(&full_scale->v2) * 100;\r\np->range[7].range.max =\r\nget_s16(&full_scale->v2) * 100;\r\np->range[8].range.min = 0;\r\np->range[8].range.max = 65535;\r\nuse_offset(channel, 0);\r\np->state = state_jr3_init_use_offset_complete;\r\nresult = poll_delay_min_max(40, 100);\r\n}\r\nbreak;\r\ncase state_jr3_init_use_offset_complete:\r\nif (!is_complete(channel)) {\r\nresult = poll_delay_min_max(20, 100);\r\n} else {\r\nset_s16(&channel->offsets.fx, 0);\r\nset_s16(&channel->offsets.fy, 0);\r\nset_s16(&channel->offsets.fz, 0);\r\nset_s16(&channel->offsets.mx, 0);\r\nset_s16(&channel->offsets.my, 0);\r\nset_s16(&channel->offsets.mz, 0);\r\nset_offset(channel);\r\np->state = state_jr3_done;\r\n}\r\nbreak;\r\ncase state_jr3_done:\r\npoll_delay_min_max(10000, 20000);\r\nbreak;\r\ndefault:\r\npoll_delay_min_max(1000, 2000);\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic void jr3_pci_poll_dev(unsigned long data)\r\n{\r\nunsigned long flags;\r\nstruct comedi_device *dev = (struct comedi_device *)data;\r\nstruct jr3_pci_dev_private *devpriv = dev->private;\r\nunsigned long now;\r\nint delay;\r\nint i;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndelay = 1000;\r\nnow = jiffies;\r\nfor (i = 0; i < devpriv->n_channels; i++) {\r\nstruct jr3_pci_subdev_private *subdevpriv =\r\ndev->subdevices[i].private;\r\nif (now > subdevpriv->next_time_min) {\r\nstruct poll_delay_t sub_delay;\r\nsub_delay = jr3_pci_poll_subdevice(&dev->subdevices[i]);\r\nsubdevpriv->next_time_min =\r\njiffies + msecs_to_jiffies(sub_delay.min);\r\nsubdevpriv->next_time_max =\r\njiffies + msecs_to_jiffies(sub_delay.max);\r\nif (sub_delay.max && sub_delay.max < delay)\r\ndelay = sub_delay.max;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\ndevpriv->timer.expires = jiffies + msecs_to_jiffies(delay);\r\nadd_timer(&devpriv->timer);\r\n}\r\nstatic int jr3_pci_auto_attach(struct comedi_device *dev,\r\nunsigned long context_unused)\r\n{\r\nint result;\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nint i;\r\nstruct jr3_pci_dev_private *devpriv;\r\nif (sizeof(struct jr3_channel) != 0xc00) {\r\ndev_err(dev->class_dev,\r\n"sizeof(struct jr3_channel) = %x [expected %x]\n",\r\n(unsigned)sizeof(struct jr3_channel), 0xc00);\r\nreturn -EINVAL;\r\n}\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\ninit_timer(&devpriv->timer);\r\nswitch (pcidev->device) {\r\ncase PCI_DEVICE_ID_JR3_1_CHANNEL:\r\ncase PCI_DEVICE_ID_JR3_1_CHANNEL_NEW:\r\ndevpriv->n_channels = 1;\r\nbreak;\r\ncase PCI_DEVICE_ID_JR3_2_CHANNEL:\r\ndevpriv->n_channels = 2;\r\nbreak;\r\ncase PCI_DEVICE_ID_JR3_3_CHANNEL:\r\ndevpriv->n_channels = 3;\r\nbreak;\r\ncase PCI_DEVICE_ID_JR3_4_CHANNEL:\r\ndevpriv->n_channels = 4;\r\nbreak;\r\ndefault:\r\ndev_err(dev->class_dev, "jr3_pci: pci %s not supported\n",\r\npci_name(pcidev));\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nresult = comedi_pci_enable(dev);\r\nif (result)\r\nreturn result;\r\ndevpriv->iobase = pci_ioremap_bar(pcidev, 0);\r\nif (!devpriv->iobase)\r\nreturn -ENOMEM;\r\nresult = comedi_alloc_subdevices(dev, devpriv->n_channels);\r\nif (result)\r\nreturn result;\r\ndev->open = jr3_pci_open;\r\nfor (i = 0; i < devpriv->n_channels; i++) {\r\ndev->subdevices[i].type = COMEDI_SUBD_AI;\r\ndev->subdevices[i].subdev_flags = SDF_READABLE | SDF_GROUND;\r\ndev->subdevices[i].n_chan = 8 * 7 + 2;\r\ndev->subdevices[i].insn_read = jr3_pci_ai_insn_read;\r\ndev->subdevices[i].private =\r\nkzalloc(sizeof(struct jr3_pci_subdev_private),\r\nGFP_KERNEL);\r\nif (dev->subdevices[i].private) {\r\nstruct jr3_pci_subdev_private *p;\r\nint j;\r\np = dev->subdevices[i].private;\r\np->channel = &devpriv->iobase->channel[i].data;\r\ndev_dbg(dev->class_dev, "p->channel %p %p (%tx)\n",\r\np->channel, devpriv->iobase,\r\n((char __iomem *)p->channel -\r\n(char __iomem *)devpriv->iobase));\r\np->channel_no = i;\r\nfor (j = 0; j < 8; j++) {\r\nint k;\r\np->range[j].length = 1;\r\np->range[j].range.min = -1000000;\r\np->range[j].range.max = 1000000;\r\nfor (k = 0; k < 7; k++) {\r\np->range_table_list[j + k * 8] =\r\n(struct comedi_lrange *)&p->\r\nrange[j];\r\np->maxdata_list[j + k * 8] = 0x7fff;\r\n}\r\n}\r\np->range[8].length = 1;\r\np->range[8].range.min = 0;\r\np->range[8].range.max = 65536;\r\np->range_table_list[56] =\r\n(struct comedi_lrange *)&p->range[8];\r\np->range_table_list[57] =\r\n(struct comedi_lrange *)&p->range[8];\r\np->maxdata_list[56] = 0xffff;\r\np->maxdata_list[57] = 0xffff;\r\ndev->subdevices[i].range_table = NULL;\r\ndev->subdevices[i].range_table_list =\r\np->range_table_list;\r\ndev->subdevices[i].maxdata = 0;\r\ndev->subdevices[i].maxdata_list = p->maxdata_list;\r\n}\r\n}\r\nwritel(0, &devpriv->iobase->channel[0].reset);\r\nresult = comedi_load_firmware(dev, &comedi_to_pci_dev(dev)->dev,\r\n"comedi/jr3pci.idm",\r\njr3_download_firmware, 0);\r\ndev_dbg(dev->class_dev, "Firmare load %d\n", result);\r\nif (result < 0)\r\nreturn result;\r\nmsleep_interruptible(25);\r\nfor (i = 0; i < 0x18; i++) {\r\ndev_dbg(dev->class_dev, "%c\n",\r\nget_u16(&devpriv->iobase->channel[0].\r\ndata.copyright[i]) >> 8);\r\n}\r\nfor (i = 0; i < devpriv->n_channels; i++) {\r\nstruct jr3_pci_subdev_private *p = dev->subdevices[i].private;\r\np->next_time_min = jiffies + msecs_to_jiffies(500);\r\np->next_time_max = jiffies + msecs_to_jiffies(2000);\r\n}\r\ndevpriv->timer.data = (unsigned long)dev;\r\ndevpriv->timer.function = jr3_pci_poll_dev;\r\ndevpriv->timer.expires = jiffies + msecs_to_jiffies(1000);\r\nadd_timer(&devpriv->timer);\r\nreturn result;\r\n}\r\nstatic void jr3_pci_detach(struct comedi_device *dev)\r\n{\r\nint i;\r\nstruct jr3_pci_dev_private *devpriv = dev->private;\r\nif (devpriv) {\r\ndel_timer_sync(&devpriv->timer);\r\nif (dev->subdevices) {\r\nfor (i = 0; i < devpriv->n_channels; i++)\r\nkfree(dev->subdevices[i].private);\r\n}\r\nif (devpriv->iobase)\r\niounmap(devpriv->iobase);\r\n}\r\ncomedi_pci_disable(dev);\r\n}\r\nstatic int jr3_pci_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &jr3_pci_driver, id->driver_data);\r\n}
