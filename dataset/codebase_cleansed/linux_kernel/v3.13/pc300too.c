static void pc300_set_iface(port_t *port)\r\n{\r\ncard_t *card = port->card;\r\nu32 __iomem * init_ctrl = &card->plxbase->init_ctrl;\r\nu16 msci = get_msci(port);\r\nu8 rxs = port->rxs & CLK_BRG_MASK;\r\nu8 txs = port->txs & CLK_BRG_MASK;\r\nsca_out(EXS_TES1, (port->chan ? MSCI1_OFFSET : MSCI0_OFFSET) + EXS,\r\nport->card);\r\nswitch(port->settings.clock_type) {\r\ncase CLOCK_INT:\r\nrxs |= CLK_BRG;\r\ntxs |= CLK_PIN_OUT | CLK_TX_RXCLK;\r\nbreak;\r\ncase CLOCK_TXINT:\r\nrxs |= CLK_LINE;\r\ntxs |= CLK_PIN_OUT | CLK_BRG;\r\nbreak;\r\ncase CLOCK_TXFROMRX:\r\nrxs |= CLK_LINE;\r\ntxs |= CLK_PIN_OUT | CLK_TX_RXCLK;\r\nbreak;\r\ndefault:\r\nrxs |= CLK_LINE;\r\ntxs |= CLK_PIN_OUT | CLK_LINE;\r\nbreak;\r\n}\r\nport->rxs = rxs;\r\nport->txs = txs;\r\nsca_out(rxs, msci + RXS, card);\r\nsca_out(txs, msci + TXS, card);\r\nsca_set_port(port);\r\nif (port->card->type == PC300_RSV) {\r\nif (port->iface == IF_IFACE_V35)\r\nwritel(card->init_ctrl_value |\r\nPC300_CHMEDIA_MASK(port->chan), init_ctrl);\r\nelse\r\nwritel(card->init_ctrl_value &\r\n~PC300_CHMEDIA_MASK(port->chan), init_ctrl);\r\n}\r\n}\r\nstatic int pc300_open(struct net_device *dev)\r\n{\r\nport_t *port = dev_to_port(dev);\r\nint result = hdlc_open(dev);\r\nif (result)\r\nreturn result;\r\nsca_open(dev);\r\npc300_set_iface(port);\r\nreturn 0;\r\n}\r\nstatic int pc300_close(struct net_device *dev)\r\n{\r\nsca_close(dev);\r\nhdlc_close(dev);\r\nreturn 0;\r\n}\r\nstatic int pc300_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nconst size_t size = sizeof(sync_serial_settings);\r\nsync_serial_settings new_line;\r\nsync_serial_settings __user *line = ifr->ifr_settings.ifs_ifsu.sync;\r\nint new_type;\r\nport_t *port = dev_to_port(dev);\r\n#ifdef DEBUG_RINGS\r\nif (cmd == SIOCDEVPRIVATE) {\r\nsca_dump_rings(dev);\r\nreturn 0;\r\n}\r\n#endif\r\nif (cmd != SIOCWANDEV)\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\nif (ifr->ifr_settings.type == IF_GET_IFACE) {\r\nifr->ifr_settings.type = port->iface;\r\nif (ifr->ifr_settings.size < size) {\r\nifr->ifr_settings.size = size;\r\nreturn -ENOBUFS;\r\n}\r\nif (copy_to_user(line, &port->settings, size))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nif (port->card->type == PC300_X21 &&\r\n(ifr->ifr_settings.type == IF_IFACE_SYNC_SERIAL ||\r\nifr->ifr_settings.type == IF_IFACE_X21))\r\nnew_type = IF_IFACE_X21;\r\nelse if (port->card->type == PC300_RSV &&\r\n(ifr->ifr_settings.type == IF_IFACE_SYNC_SERIAL ||\r\nifr->ifr_settings.type == IF_IFACE_V35))\r\nnew_type = IF_IFACE_V35;\r\nelse if (port->card->type == PC300_RSV &&\r\nifr->ifr_settings.type == IF_IFACE_V24)\r\nnew_type = IF_IFACE_V24;\r\nelse\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (copy_from_user(&new_line, line, size))\r\nreturn -EFAULT;\r\nif (new_line.clock_type != CLOCK_EXT &&\r\nnew_line.clock_type != CLOCK_TXFROMRX &&\r\nnew_line.clock_type != CLOCK_INT &&\r\nnew_line.clock_type != CLOCK_TXINT)\r\nreturn -EINVAL;\r\nif (new_line.loopback != 0 && new_line.loopback != 1)\r\nreturn -EINVAL;\r\nmemcpy(&port->settings, &new_line, size);\r\nport->iface = new_type;\r\npc300_set_iface(port);\r\nreturn 0;\r\n}\r\nstatic void pc300_pci_remove_one(struct pci_dev *pdev)\r\n{\r\nint i;\r\ncard_t *card = pci_get_drvdata(pdev);\r\nfor (i = 0; i < 2; i++)\r\nif (card->ports[i].card)\r\nunregister_hdlc_device(card->ports[i].netdev);\r\nif (card->irq)\r\nfree_irq(card->irq, card);\r\nif (card->rambase)\r\niounmap(card->rambase);\r\nif (card->scabase)\r\niounmap(card->scabase);\r\nif (card->plxbase)\r\niounmap(card->plxbase);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\npci_set_drvdata(pdev, NULL);\r\nif (card->ports[0].netdev)\r\nfree_netdev(card->ports[0].netdev);\r\nif (card->ports[1].netdev)\r\nfree_netdev(card->ports[1].netdev);\r\nkfree(card);\r\n}\r\nstatic int pc300_pci_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\ncard_t *card;\r\nu32 __iomem *p;\r\nint i;\r\nu32 ramsize;\r\nu32 ramphys;\r\nu32 scaphys;\r\nu32 plxphys;\r\ni = pci_enable_device(pdev);\r\nif (i)\r\nreturn i;\r\ni = pci_request_regions(pdev, "PC300");\r\nif (i) {\r\npci_disable_device(pdev);\r\nreturn i;\r\n}\r\ncard = kzalloc(sizeof(card_t), GFP_KERNEL);\r\nif (card == NULL) {\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nreturn -ENOBUFS;\r\n}\r\npci_set_drvdata(pdev, card);\r\nif (pci_resource_len(pdev, 0) != PC300_PLX_SIZE ||\r\npci_resource_len(pdev, 2) != PC300_SCA_SIZE ||\r\npci_resource_len(pdev, 3) < 16384) {\r\npr_err("invalid card EEPROM parameters\n");\r\npc300_pci_remove_one(pdev);\r\nreturn -EFAULT;\r\n}\r\nplxphys = pci_resource_start(pdev, 0) & PCI_BASE_ADDRESS_MEM_MASK;\r\ncard->plxbase = ioremap(plxphys, PC300_PLX_SIZE);\r\nscaphys = pci_resource_start(pdev, 2) & PCI_BASE_ADDRESS_MEM_MASK;\r\ncard->scabase = ioremap(scaphys, PC300_SCA_SIZE);\r\nramphys = pci_resource_start(pdev, 3) & PCI_BASE_ADDRESS_MEM_MASK;\r\ncard->rambase = pci_ioremap_bar(pdev, 3);\r\nif (card->plxbase == NULL ||\r\ncard->scabase == NULL ||\r\ncard->rambase == NULL) {\r\npr_err("ioremap() failed\n");\r\npc300_pci_remove_one(pdev);\r\n}\r\npci_write_config_dword(pdev, PCI_BASE_ADDRESS_0, scaphys);\r\ncard->init_ctrl_value = readl(&((plx9050 __iomem *)card->scabase)->init_ctrl);\r\npci_write_config_dword(pdev, PCI_BASE_ADDRESS_0, plxphys);\r\nif (pdev->device == PCI_DEVICE_ID_PC300_TE_1 ||\r\npdev->device == PCI_DEVICE_ID_PC300_TE_2)\r\ncard->type = PC300_TE;\r\nelse if (card->init_ctrl_value & PC300_CTYPE_MASK)\r\ncard->type = PC300_X21;\r\nelse\r\ncard->type = PC300_RSV;\r\nif (pdev->device == PCI_DEVICE_ID_PC300_RX_1 ||\r\npdev->device == PCI_DEVICE_ID_PC300_TE_1)\r\ncard->n_ports = 1;\r\nelse\r\ncard->n_ports = 2;\r\nfor (i = 0; i < card->n_ports; i++)\r\nif (!(card->ports[i].netdev = alloc_hdlcdev(&card->ports[i]))) {\r\npr_err("unable to allocate memory\n");\r\npc300_pci_remove_one(pdev);\r\nreturn -ENOMEM;\r\n}\r\np = &card->plxbase->init_ctrl;\r\nwritel(card->init_ctrl_value | 0x40000000, p);\r\nreadl(p);\r\nudelay(1);\r\nwritel(card->init_ctrl_value, p);\r\nreadl(p);\r\nudelay(1);\r\nwritel(card->init_ctrl_value | 0x20000000, p);\r\nreadl(p);\r\nudelay(1);\r\nwritel(card->init_ctrl_value, p);\r\nreadl(p);\r\nudelay(1);\r\nramsize = sca_detect_ram(card, card->rambase,\r\npci_resource_len(pdev, 3));\r\nif (use_crystal_clock)\r\ncard->init_ctrl_value &= ~PC300_CLKSEL_MASK;\r\nelse\r\ncard->init_ctrl_value |= PC300_CLKSEL_MASK;\r\nwritel(card->init_ctrl_value, &card->plxbase->init_ctrl);\r\ni = ramsize / (card->n_ports * (sizeof(pkt_desc) + HDLC_MAX_MRU));\r\ncard->tx_ring_buffers = min(i / 2, MAX_TX_BUFFERS);\r\ncard->rx_ring_buffers = i - card->tx_ring_buffers;\r\ncard->buff_offset = card->n_ports * sizeof(pkt_desc) *\r\n(card->tx_ring_buffers + card->rx_ring_buffers);\r\npr_info("PC300/%s, %u KB RAM at 0x%x, IRQ%u, using %u TX + %u RX packets rings\n",\r\ncard->type == PC300_X21 ? "X21" :\r\ncard->type == PC300_TE ? "TE" : "RSV",\r\nramsize / 1024, ramphys, pdev->irq,\r\ncard->tx_ring_buffers, card->rx_ring_buffers);\r\nif (card->tx_ring_buffers < 1) {\r\npr_err("RAM test failed\n");\r\npc300_pci_remove_one(pdev);\r\nreturn -EFAULT;\r\n}\r\nwritew(0x0041, &card->plxbase->intr_ctrl_stat);\r\nif (request_irq(pdev->irq, sca_intr, IRQF_SHARED, "pc300", card)) {\r\npr_warn("could not allocate IRQ%d\n", pdev->irq);\r\npc300_pci_remove_one(pdev);\r\nreturn -EBUSY;\r\n}\r\ncard->irq = pdev->irq;\r\nsca_init(card, 0);\r\nsca_out(0x10, BTCR, card);\r\nfor (i = 0; i < card->n_ports; i++) {\r\nport_t *port = &card->ports[i];\r\nstruct net_device *dev = port->netdev;\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nport->chan = i;\r\nspin_lock_init(&port->lock);\r\ndev->irq = card->irq;\r\ndev->mem_start = ramphys;\r\ndev->mem_end = ramphys + ramsize - 1;\r\ndev->tx_queue_len = 50;\r\ndev->netdev_ops = &pc300_ops;\r\nhdlc->attach = sca_attach;\r\nhdlc->xmit = sca_xmit;\r\nport->settings.clock_type = CLOCK_EXT;\r\nport->card = card;\r\nif (card->type == PC300_X21)\r\nport->iface = IF_IFACE_X21;\r\nelse\r\nport->iface = IF_IFACE_V35;\r\nsca_init_port(port);\r\nif (register_hdlc_device(dev)) {\r\npr_err("unable to register hdlc device\n");\r\nport->card = NULL;\r\npc300_pci_remove_one(pdev);\r\nreturn -ENOBUFS;\r\n}\r\nnetdev_info(dev, "PC300 channel %d\n", port->chan);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init pc300_init_module(void)\r\n{\r\nif (pci_clock_freq < 1000000 || pci_clock_freq > 80000000) {\r\npr_err("Invalid PCI clock frequency\n");\r\nreturn -EINVAL;\r\n}\r\nif (use_crystal_clock != 0 && use_crystal_clock != 1) {\r\npr_err("Invalid 'use_crystal_clock' value\n");\r\nreturn -EINVAL;\r\n}\r\nCLOCK_BASE = use_crystal_clock ? 24576000 : pci_clock_freq;\r\nreturn pci_register_driver(&pc300_pci_driver);\r\n}\r\nstatic void __exit pc300_cleanup_module(void)\r\n{\r\npci_unregister_driver(&pc300_pci_driver);\r\n}
