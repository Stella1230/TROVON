int inv_mpu6050_write_reg(struct inv_mpu6050_state *st, int reg, u8 d)\r\n{\r\nreturn i2c_smbus_write_i2c_block_data(st->client, reg, 1, &d);\r\n}\r\nint inv_mpu6050_switch_engine(struct inv_mpu6050_state *st, bool en, u32 mask)\r\n{\r\nu8 d, mgmt_1;\r\nint result;\r\nif (INV_MPU6050_BIT_PWR_GYRO_STBY == mask) {\r\nresult = i2c_smbus_read_i2c_block_data(st->client,\r\nst->reg->pwr_mgmt_1, 1, &mgmt_1);\r\nif (result != 1)\r\nreturn result;\r\nmgmt_1 &= ~INV_MPU6050_BIT_CLK_MASK;\r\n}\r\nif ((INV_MPU6050_BIT_PWR_GYRO_STBY == mask) && (!en)) {\r\nmgmt_1 |= INV_CLK_INTERNAL;\r\nresult = inv_mpu6050_write_reg(st, st->reg->pwr_mgmt_1, mgmt_1);\r\nif (result)\r\nreturn result;\r\n}\r\nresult = i2c_smbus_read_i2c_block_data(st->client,\r\nst->reg->pwr_mgmt_2, 1, &d);\r\nif (result != 1)\r\nreturn result;\r\nif (en)\r\nd &= ~mask;\r\nelse\r\nd |= mask;\r\nresult = inv_mpu6050_write_reg(st, st->reg->pwr_mgmt_2, d);\r\nif (result)\r\nreturn result;\r\nif (en) {\r\nmsleep(INV_MPU6050_TEMP_UP_TIME);\r\nif (INV_MPU6050_BIT_PWR_GYRO_STBY == mask) {\r\nmgmt_1 |= INV_CLK_PLL;\r\nresult = inv_mpu6050_write_reg(st,\r\nst->reg->pwr_mgmt_1, mgmt_1);\r\nif (result)\r\nreturn result;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint inv_mpu6050_set_power_itg(struct inv_mpu6050_state *st, bool power_on)\r\n{\r\nint result;\r\nif (power_on)\r\nresult = inv_mpu6050_write_reg(st, st->reg->pwr_mgmt_1, 0);\r\nelse\r\nresult = inv_mpu6050_write_reg(st, st->reg->pwr_mgmt_1,\r\nINV_MPU6050_BIT_SLEEP);\r\nif (result)\r\nreturn result;\r\nif (power_on)\r\nmsleep(INV_MPU6050_REG_UP_TIME);\r\nreturn 0;\r\n}\r\nstatic int inv_mpu6050_init_config(struct iio_dev *indio_dev)\r\n{\r\nint result;\r\nu8 d;\r\nstruct inv_mpu6050_state *st = iio_priv(indio_dev);\r\nresult = inv_mpu6050_set_power_itg(st, true);\r\nif (result)\r\nreturn result;\r\nd = (INV_MPU6050_FSR_2000DPS << INV_MPU6050_GYRO_CONFIG_FSR_SHIFT);\r\nresult = inv_mpu6050_write_reg(st, st->reg->gyro_config, d);\r\nif (result)\r\nreturn result;\r\nd = INV_MPU6050_FILTER_20HZ;\r\nresult = inv_mpu6050_write_reg(st, st->reg->lpf, d);\r\nif (result)\r\nreturn result;\r\nd = INV_MPU6050_ONE_K_HZ / INV_MPU6050_INIT_FIFO_RATE - 1;\r\nresult = inv_mpu6050_write_reg(st, st->reg->sample_rate_div, d);\r\nif (result)\r\nreturn result;\r\nd = (INV_MPU6050_FS_02G << INV_MPU6050_ACCL_CONFIG_FSR_SHIFT);\r\nresult = inv_mpu6050_write_reg(st, st->reg->accl_config, d);\r\nif (result)\r\nreturn result;\r\nmemcpy(&st->chip_config, hw_info[st->chip_type].config,\r\nsizeof(struct inv_mpu6050_chip_config));\r\nresult = inv_mpu6050_set_power_itg(st, false);\r\nreturn result;\r\n}\r\nstatic int inv_mpu6050_sensor_show(struct inv_mpu6050_state *st, int reg,\r\nint axis, int *val)\r\n{\r\nint ind, result;\r\n__be16 d;\r\nind = (axis - IIO_MOD_X) * 2;\r\nresult = i2c_smbus_read_i2c_block_data(st->client, reg + ind, 2,\r\n(u8 *)&d);\r\nif (result != 2)\r\nreturn -EINVAL;\r\n*val = (short)be16_to_cpup(&d);\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int inv_mpu6050_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong mask) {\r\nstruct inv_mpu6050_state *st = iio_priv(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\n{\r\nint ret, result;\r\nret = IIO_VAL_INT;\r\nresult = 0;\r\nmutex_lock(&indio_dev->mlock);\r\nif (!st->chip_config.enable) {\r\nresult = inv_mpu6050_set_power_itg(st, true);\r\nif (result)\r\ngoto error_read_raw;\r\n}\r\nswitch (chan->type) {\r\ncase IIO_ANGL_VEL:\r\nif (!st->chip_config.gyro_fifo_enable ||\r\n!st->chip_config.enable) {\r\nresult = inv_mpu6050_switch_engine(st, true,\r\nINV_MPU6050_BIT_PWR_GYRO_STBY);\r\nif (result)\r\ngoto error_read_raw;\r\n}\r\nret = inv_mpu6050_sensor_show(st, st->reg->raw_gyro,\r\nchan->channel2, val);\r\nif (!st->chip_config.gyro_fifo_enable ||\r\n!st->chip_config.enable) {\r\nresult = inv_mpu6050_switch_engine(st, false,\r\nINV_MPU6050_BIT_PWR_GYRO_STBY);\r\nif (result)\r\ngoto error_read_raw;\r\n}\r\nbreak;\r\ncase IIO_ACCEL:\r\nif (!st->chip_config.accl_fifo_enable ||\r\n!st->chip_config.enable) {\r\nresult = inv_mpu6050_switch_engine(st, true,\r\nINV_MPU6050_BIT_PWR_ACCL_STBY);\r\nif (result)\r\ngoto error_read_raw;\r\n}\r\nret = inv_mpu6050_sensor_show(st, st->reg->raw_accl,\r\nchan->channel2, val);\r\nif (!st->chip_config.accl_fifo_enable ||\r\n!st->chip_config.enable) {\r\nresult = inv_mpu6050_switch_engine(st, false,\r\nINV_MPU6050_BIT_PWR_ACCL_STBY);\r\nif (result)\r\ngoto error_read_raw;\r\n}\r\nbreak;\r\ncase IIO_TEMP:\r\nmsleep(INV_MPU6050_SENSOR_UP_TIME);\r\ninv_mpu6050_sensor_show(st, st->reg->temperature,\r\nIIO_MOD_X, val);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nerror_read_raw:\r\nif (!st->chip_config.enable)\r\nresult |= inv_mpu6050_set_power_itg(st, false);\r\nmutex_unlock(&indio_dev->mlock);\r\nif (result)\r\nreturn result;\r\nreturn ret;\r\n}\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_ANGL_VEL:\r\n*val = 0;\r\n*val2 = gyro_scale_6050[st->chip_config.fsr];\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\ncase IIO_ACCEL:\r\n*val = 0;\r\n*val2 = accel_scale[st->chip_config.accl_fs];\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_TEMP:\r\n*val = 0;\r\n*val2 = INV_MPU6050_TEMP_SCALE;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_OFFSET:\r\nswitch (chan->type) {\r\ncase IIO_TEMP:\r\n*val = INV_MPU6050_TEMP_OFFSET;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int inv_mpu6050_write_fsr(struct inv_mpu6050_state *st, int fsr)\r\n{\r\nint result;\r\nu8 d;\r\nif (fsr < 0 || fsr > INV_MPU6050_MAX_GYRO_FS_PARAM)\r\nreturn -EINVAL;\r\nif (fsr == st->chip_config.fsr)\r\nreturn 0;\r\nd = (fsr << INV_MPU6050_GYRO_CONFIG_FSR_SHIFT);\r\nresult = inv_mpu6050_write_reg(st, st->reg->gyro_config, d);\r\nif (result)\r\nreturn result;\r\nst->chip_config.fsr = fsr;\r\nreturn 0;\r\n}\r\nstatic int inv_mpu6050_write_accel_fs(struct inv_mpu6050_state *st, int fs)\r\n{\r\nint result;\r\nu8 d;\r\nif (fs < 0 || fs > INV_MPU6050_MAX_ACCL_FS_PARAM)\r\nreturn -EINVAL;\r\nif (fs == st->chip_config.accl_fs)\r\nreturn 0;\r\nd = (fs << INV_MPU6050_ACCL_CONFIG_FSR_SHIFT);\r\nresult = inv_mpu6050_write_reg(st, st->reg->accl_config, d);\r\nif (result)\r\nreturn result;\r\nst->chip_config.accl_fs = fs;\r\nreturn 0;\r\n}\r\nstatic int inv_mpu6050_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val,\r\nint val2,\r\nlong mask) {\r\nstruct inv_mpu6050_state *st = iio_priv(indio_dev);\r\nint result;\r\nmutex_lock(&indio_dev->mlock);\r\nif (st->chip_config.enable) {\r\nresult = -EBUSY;\r\ngoto error_write_raw;\r\n}\r\nresult = inv_mpu6050_set_power_itg(st, true);\r\nif (result)\r\ngoto error_write_raw;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_ANGL_VEL:\r\nresult = inv_mpu6050_write_fsr(st, val);\r\nbreak;\r\ncase IIO_ACCEL:\r\nresult = inv_mpu6050_write_accel_fs(st, val);\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nerror_write_raw:\r\nresult |= inv_mpu6050_set_power_itg(st, false);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn result;\r\n}\r\nstatic int inv_mpu6050_set_lpf(struct inv_mpu6050_state *st, int rate)\r\n{\r\nconst int hz[] = {188, 98, 42, 20, 10, 5};\r\nconst int d[] = {INV_MPU6050_FILTER_188HZ, INV_MPU6050_FILTER_98HZ,\r\nINV_MPU6050_FILTER_42HZ, INV_MPU6050_FILTER_20HZ,\r\nINV_MPU6050_FILTER_10HZ, INV_MPU6050_FILTER_5HZ};\r\nint i, h, result;\r\nu8 data;\r\nh = (rate >> 1);\r\ni = 0;\r\nwhile ((h < hz[i]) && (i < ARRAY_SIZE(d) - 1))\r\ni++;\r\ndata = d[i];\r\nresult = inv_mpu6050_write_reg(st, st->reg->lpf, data);\r\nif (result)\r\nreturn result;\r\nst->chip_config.lpf = data;\r\nreturn 0;\r\n}\r\nstatic ssize_t inv_mpu6050_fifo_rate_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\ns32 fifo_rate;\r\nu8 d;\r\nint result;\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct inv_mpu6050_state *st = iio_priv(indio_dev);\r\nif (kstrtoint(buf, 10, &fifo_rate))\r\nreturn -EINVAL;\r\nif (fifo_rate < INV_MPU6050_MIN_FIFO_RATE ||\r\nfifo_rate > INV_MPU6050_MAX_FIFO_RATE)\r\nreturn -EINVAL;\r\nif (fifo_rate == st->chip_config.fifo_rate)\r\nreturn count;\r\nmutex_lock(&indio_dev->mlock);\r\nif (st->chip_config.enable) {\r\nresult = -EBUSY;\r\ngoto fifo_rate_fail;\r\n}\r\nresult = inv_mpu6050_set_power_itg(st, true);\r\nif (result)\r\ngoto fifo_rate_fail;\r\nd = INV_MPU6050_ONE_K_HZ / fifo_rate - 1;\r\nresult = inv_mpu6050_write_reg(st, st->reg->sample_rate_div, d);\r\nif (result)\r\ngoto fifo_rate_fail;\r\nst->chip_config.fifo_rate = fifo_rate;\r\nresult = inv_mpu6050_set_lpf(st, fifo_rate);\r\nif (result)\r\ngoto fifo_rate_fail;\r\nfifo_rate_fail:\r\nresult |= inv_mpu6050_set_power_itg(st, false);\r\nmutex_unlock(&indio_dev->mlock);\r\nif (result)\r\nreturn result;\r\nreturn count;\r\n}\r\nstatic ssize_t inv_fifo_rate_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct inv_mpu6050_state *st = iio_priv(dev_to_iio_dev(dev));\r\nreturn sprintf(buf, "%d\n", st->chip_config.fifo_rate);\r\n}\r\nstatic ssize_t inv_attr_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct inv_mpu6050_state *st = iio_priv(dev_to_iio_dev(dev));\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\ns8 *m;\r\nswitch (this_attr->address) {\r\ncase ATTR_GYRO_MATRIX:\r\ncase ATTR_ACCL_MATRIX:\r\nm = st->plat_data.orientation;\r\nreturn sprintf(buf, "%d, %d, %d; %d, %d, %d; %d, %d, %d\n",\r\nm[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int inv_mpu6050_validate_trigger(struct iio_dev *indio_dev,\r\nstruct iio_trigger *trig)\r\n{\r\nstruct inv_mpu6050_state *st = iio_priv(indio_dev);\r\nif (st->trig != trig)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int inv_check_and_setup_chip(struct inv_mpu6050_state *st,\r\nconst struct i2c_device_id *id)\r\n{\r\nint result;\r\nst->chip_type = INV_MPU6050;\r\nst->hw = &hw_info[st->chip_type];\r\nst->reg = hw_info[st->chip_type].reg;\r\nresult = inv_mpu6050_write_reg(st, st->reg->pwr_mgmt_1,\r\nINV_MPU6050_BIT_H_RESET);\r\nif (result)\r\nreturn result;\r\nmsleep(INV_MPU6050_POWER_UP_TIME);\r\nresult = inv_mpu6050_set_power_itg(st, false);\r\nif (result)\r\nreturn result;\r\nresult = inv_mpu6050_set_power_itg(st, true);\r\nif (result)\r\nreturn result;\r\nresult = inv_mpu6050_switch_engine(st, false,\r\nINV_MPU6050_BIT_PWR_ACCL_STBY);\r\nif (result)\r\nreturn result;\r\nresult = inv_mpu6050_switch_engine(st, false,\r\nINV_MPU6050_BIT_PWR_GYRO_STBY);\r\nif (result)\r\nreturn result;\r\nreturn 0;\r\n}\r\nstatic int inv_mpu_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct inv_mpu6050_state *st;\r\nstruct iio_dev *indio_dev;\r\nint result;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_I2C_BLOCK))\r\nreturn -ENOSYS;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*st));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nst = iio_priv(indio_dev);\r\nst->client = client;\r\nst->plat_data = *(struct inv_mpu6050_platform_data\r\n*)dev_get_platdata(&client->dev);\r\nresult = inv_check_and_setup_chip(st, id);\r\nif (result)\r\nreturn result;\r\nresult = inv_mpu6050_init_config(indio_dev);\r\nif (result) {\r\ndev_err(&client->dev,\r\n"Could not initialize device.\n");\r\nreturn result;\r\n}\r\ni2c_set_clientdata(client, indio_dev);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->name = id->name;\r\nindio_dev->channels = inv_mpu_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(inv_mpu_channels);\r\nindio_dev->info = &mpu_info;\r\nindio_dev->modes = INDIO_BUFFER_TRIGGERED;\r\nresult = iio_triggered_buffer_setup(indio_dev,\r\ninv_mpu6050_irq_handler,\r\ninv_mpu6050_read_fifo,\r\nNULL);\r\nif (result) {\r\ndev_err(&st->client->dev, "configure buffer fail %d\n",\r\nresult);\r\nreturn result;\r\n}\r\nresult = inv_mpu6050_probe_trigger(indio_dev);\r\nif (result) {\r\ndev_err(&st->client->dev, "trigger probe fail %d\n", result);\r\ngoto out_unreg_ring;\r\n}\r\nINIT_KFIFO(st->timestamps);\r\nspin_lock_init(&st->time_stamp_lock);\r\nresult = iio_device_register(indio_dev);\r\nif (result) {\r\ndev_err(&st->client->dev, "IIO register fail %d\n", result);\r\ngoto out_remove_trigger;\r\n}\r\nreturn 0;\r\nout_remove_trigger:\r\ninv_mpu6050_remove_trigger(st);\r\nout_unreg_ring:\r\niio_triggered_buffer_cleanup(indio_dev);\r\nreturn result;\r\n}\r\nstatic int inv_mpu_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct inv_mpu6050_state *st = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\ninv_mpu6050_remove_trigger(st);\r\niio_triggered_buffer_cleanup(indio_dev);\r\nreturn 0;\r\n}\r\nstatic int inv_mpu_resume(struct device *dev)\r\n{\r\nreturn inv_mpu6050_set_power_itg(\r\niio_priv(i2c_get_clientdata(to_i2c_client(dev))), true);\r\n}\r\nstatic int inv_mpu_suspend(struct device *dev)\r\n{\r\nreturn inv_mpu6050_set_power_itg(\r\niio_priv(i2c_get_clientdata(to_i2c_client(dev))), false);\r\n}
