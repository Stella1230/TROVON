static inline struct s5p_jpeg_ctx *ctrl_to_ctx(struct v4l2_ctrl *c)\r\n{\r\nreturn container_of(c->handler, struct s5p_jpeg_ctx, ctrl_handler);\r\n}\r\nstatic inline struct s5p_jpeg_ctx *fh_to_ctx(struct v4l2_fh *fh)\r\n{\r\nreturn container_of(fh, struct s5p_jpeg_ctx, fh);\r\n}\r\nstatic inline void jpeg_set_qtbl(void __iomem *regs, const unsigned char *qtbl,\r\nunsigned long tab, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nwritel((unsigned int)qtbl[i], regs + tab + (i * 0x04));\r\n}\r\nstatic inline void jpeg_set_qtbl_lum(void __iomem *regs, int quality)\r\n{\r\njpeg_set_qtbl(regs, qtbl_luminance[quality], S5P_JPG_QTBL_CONTENT(0),\r\nARRAY_SIZE(qtbl_luminance[quality]));\r\n}\r\nstatic inline void jpeg_set_qtbl_chr(void __iomem *regs, int quality)\r\n{\r\njpeg_set_qtbl(regs, qtbl_chrominance[quality], S5P_JPG_QTBL_CONTENT(1),\r\nARRAY_SIZE(qtbl_chrominance[quality]));\r\n}\r\nstatic inline void jpeg_set_htbl(void __iomem *regs, const unsigned char *htbl,\r\nunsigned long tab, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nwritel((unsigned int)htbl[i], regs + tab + (i * 0x04));\r\n}\r\nstatic inline void jpeg_set_hdctbl(void __iomem *regs)\r\n{\r\njpeg_set_htbl(regs, hdctbl0, S5P_JPG_HDCTBL(0), ARRAY_SIZE(hdctbl0));\r\n}\r\nstatic inline void jpeg_set_hdctblg(void __iomem *regs)\r\n{\r\njpeg_set_htbl(regs, hdctblg0, S5P_JPG_HDCTBLG(0), ARRAY_SIZE(hdctblg0));\r\n}\r\nstatic inline void jpeg_set_hactbl(void __iomem *regs)\r\n{\r\njpeg_set_htbl(regs, hactbl0, S5P_JPG_HACTBL(0), ARRAY_SIZE(hactbl0));\r\n}\r\nstatic inline void jpeg_set_hactblg(void __iomem *regs)\r\n{\r\njpeg_set_htbl(regs, hactblg0, S5P_JPG_HACTBLG(0), ARRAY_SIZE(hactblg0));\r\n}\r\nstatic int s5p_jpeg_open(struct file *file)\r\n{\r\nstruct s5p_jpeg *jpeg = video_drvdata(file);\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct s5p_jpeg_ctx *ctx;\r\nstruct s5p_jpeg_fmt *out_fmt;\r\nint ret = 0;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nif (mutex_lock_interruptible(&jpeg->lock)) {\r\nret = -ERESTARTSYS;\r\ngoto free;\r\n}\r\nv4l2_fh_init(&ctx->fh, vfd);\r\nctx->fh.ctrl_handler = &ctx->ctrl_handler;\r\nfile->private_data = &ctx->fh;\r\nv4l2_fh_add(&ctx->fh);\r\nctx->jpeg = jpeg;\r\nif (vfd == jpeg->vfd_encoder) {\r\nctx->mode = S5P_JPEG_ENCODE;\r\nout_fmt = s5p_jpeg_find_format(ctx->mode, V4L2_PIX_FMT_RGB565);\r\n} else {\r\nctx->mode = S5P_JPEG_DECODE;\r\nout_fmt = s5p_jpeg_find_format(ctx->mode, V4L2_PIX_FMT_JPEG);\r\n}\r\nret = s5p_jpeg_controls_create(ctx);\r\nif (ret < 0)\r\ngoto error;\r\nctx->m2m_ctx = v4l2_m2m_ctx_init(jpeg->m2m_dev, ctx, queue_init);\r\nif (IS_ERR(ctx->m2m_ctx)) {\r\nret = PTR_ERR(ctx->m2m_ctx);\r\ngoto error;\r\n}\r\nctx->out_q.fmt = out_fmt;\r\nctx->cap_q.fmt = s5p_jpeg_find_format(ctx->mode, V4L2_PIX_FMT_YUYV);\r\nmutex_unlock(&jpeg->lock);\r\nreturn 0;\r\nerror:\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nmutex_unlock(&jpeg->lock);\r\nfree:\r\nkfree(ctx);\r\nreturn ret;\r\n}\r\nstatic int s5p_jpeg_release(struct file *file)\r\n{\r\nstruct s5p_jpeg *jpeg = video_drvdata(file);\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(file->private_data);\r\nmutex_lock(&jpeg->lock);\r\nv4l2_m2m_ctx_release(ctx->m2m_ctx);\r\nmutex_unlock(&jpeg->lock);\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nkfree(ctx);\r\nreturn 0;\r\n}\r\nstatic unsigned int s5p_jpeg_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct s5p_jpeg *jpeg = video_drvdata(file);\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(file->private_data);\r\nunsigned int res;\r\nmutex_lock(&jpeg->lock);\r\nres = v4l2_m2m_poll(file, ctx->m2m_ctx, wait);\r\nmutex_unlock(&jpeg->lock);\r\nreturn res;\r\n}\r\nstatic int s5p_jpeg_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct s5p_jpeg *jpeg = video_drvdata(file);\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(file->private_data);\r\nint ret;\r\nif (mutex_lock_interruptible(&jpeg->lock))\r\nreturn -ERESTARTSYS;\r\nret = v4l2_m2m_mmap(file, ctx->m2m_ctx, vma);\r\nmutex_unlock(&jpeg->lock);\r\nreturn ret;\r\n}\r\nstatic int get_byte(struct s5p_jpeg_buffer *buf)\r\n{\r\nif (buf->curr >= buf->size)\r\nreturn -1;\r\nreturn ((unsigned char *)buf->data)[buf->curr++];\r\n}\r\nstatic int get_word_be(struct s5p_jpeg_buffer *buf, unsigned int *word)\r\n{\r\nunsigned int temp;\r\nint byte;\r\nbyte = get_byte(buf);\r\nif (byte == -1)\r\nreturn -1;\r\ntemp = byte << 8;\r\nbyte = get_byte(buf);\r\nif (byte == -1)\r\nreturn -1;\r\n*word = (unsigned int)byte | temp;\r\nreturn 0;\r\n}\r\nstatic void skip(struct s5p_jpeg_buffer *buf, long len)\r\n{\r\nif (len <= 0)\r\nreturn;\r\nwhile (len--)\r\nget_byte(buf);\r\n}\r\nstatic bool s5p_jpeg_parse_hdr(struct s5p_jpeg_q_data *result,\r\nunsigned long buffer, unsigned long size)\r\n{\r\nint c, components, notfound;\r\nunsigned int height, width, word;\r\nlong length;\r\nstruct s5p_jpeg_buffer jpeg_buffer;\r\njpeg_buffer.size = size;\r\njpeg_buffer.data = buffer;\r\njpeg_buffer.curr = 0;\r\nnotfound = 1;\r\nwhile (notfound) {\r\nc = get_byte(&jpeg_buffer);\r\nif (c == -1)\r\nbreak;\r\nif (c != 0xff)\r\ncontinue;\r\ndo\r\nc = get_byte(&jpeg_buffer);\r\nwhile (c == 0xff);\r\nif (c == -1)\r\nbreak;\r\nif (c == 0)\r\ncontinue;\r\nlength = 0;\r\nswitch (c) {\r\ncase SOF0:\r\nif (get_word_be(&jpeg_buffer, &word))\r\nbreak;\r\nif (get_byte(&jpeg_buffer) == -1)\r\nbreak;\r\nif (get_word_be(&jpeg_buffer, &height))\r\nbreak;\r\nif (get_word_be(&jpeg_buffer, &width))\r\nbreak;\r\ncomponents = get_byte(&jpeg_buffer);\r\nif (components == -1)\r\nbreak;\r\nnotfound = 0;\r\nskip(&jpeg_buffer, components * 3);\r\nbreak;\r\ncase RST ... RST + 7:\r\ncase SOI:\r\ncase EOI:\r\ncase TEM:\r\nbreak;\r\ndefault:\r\nif (get_word_be(&jpeg_buffer, &word))\r\nbreak;\r\nlength = (long)word - 2;\r\nskip(&jpeg_buffer, length);\r\nbreak;\r\n}\r\n}\r\nresult->w = width;\r\nresult->h = height;\r\nresult->size = components;\r\nreturn !notfound;\r\n}\r\nstatic int s5p_jpeg_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\r\nif (ctx->mode == S5P_JPEG_ENCODE) {\r\nstrlcpy(cap->driver, S5P_JPEG_M2M_NAME " encoder",\r\nsizeof(cap->driver));\r\nstrlcpy(cap->card, S5P_JPEG_M2M_NAME " encoder",\r\nsizeof(cap->card));\r\n} else {\r\nstrlcpy(cap->driver, S5P_JPEG_M2M_NAME " decoder",\r\nsizeof(cap->driver));\r\nstrlcpy(cap->card, S5P_JPEG_M2M_NAME " decoder",\r\nsizeof(cap->card));\r\n}\r\ncap->bus_info[0] = 0;\r\ncap->capabilities = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M |\r\nV4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\r\nreturn 0;\r\n}\r\nstatic int enum_fmt(struct s5p_jpeg_fmt *formats, int n,\r\nstruct v4l2_fmtdesc *f, u32 type)\r\n{\r\nint i, num = 0;\r\nfor (i = 0; i < n; ++i) {\r\nif (formats[i].types & type) {\r\nif (num == f->index)\r\nbreak;\r\n++num;\r\n}\r\n}\r\nif (i >= n)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, formats[i].name, sizeof(f->description));\r\nf->pixelformat = formats[i].fourcc;\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\r\nif (ctx->mode == S5P_JPEG_ENCODE)\r\nreturn enum_fmt(formats_enc, NUM_FORMATS_ENC, f,\r\nMEM2MEM_CAPTURE);\r\nreturn enum_fmt(formats_dec, NUM_FORMATS_DEC, f, MEM2MEM_CAPTURE);\r\n}\r\nstatic int s5p_jpeg_enum_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\r\nif (ctx->mode == S5P_JPEG_ENCODE)\r\nreturn enum_fmt(formats_enc, NUM_FORMATS_ENC, f,\r\nMEM2MEM_OUTPUT);\r\nreturn enum_fmt(formats_dec, NUM_FORMATS_DEC, f, MEM2MEM_OUTPUT);\r\n}\r\nstatic struct s5p_jpeg_q_data *get_q_data(struct s5p_jpeg_ctx *ctx,\r\nenum v4l2_buf_type type)\r\n{\r\nif (type == V4L2_BUF_TYPE_VIDEO_OUTPUT)\r\nreturn &ctx->out_q;\r\nif (type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn &ctx->cap_q;\r\nreturn NULL;\r\n}\r\nstatic int s5p_jpeg_g_fmt(struct file *file, void *priv, struct v4l2_format *f)\r\n{\r\nstruct vb2_queue *vq;\r\nstruct s5p_jpeg_q_data *q_data = NULL;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct s5p_jpeg_ctx *ct = fh_to_ctx(priv);\r\nvq = v4l2_m2m_get_vq(ct->m2m_ctx, f->type);\r\nif (!vq)\r\nreturn -EINVAL;\r\nif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\nct->mode == S5P_JPEG_DECODE && !ct->hdr_parsed)\r\nreturn -EINVAL;\r\nq_data = get_q_data(ct, f->type);\r\nBUG_ON(q_data == NULL);\r\npix->width = q_data->w;\r\npix->height = q_data->h;\r\npix->field = V4L2_FIELD_NONE;\r\npix->pixelformat = q_data->fmt->fourcc;\r\npix->bytesperline = 0;\r\nif (q_data->fmt->fourcc != V4L2_PIX_FMT_JPEG) {\r\nu32 bpl = q_data->w;\r\nif (q_data->fmt->colplanes == 1)\r\nbpl = (bpl * q_data->fmt->depth) >> 3;\r\npix->bytesperline = bpl;\r\n}\r\npix->sizeimage = q_data->size;\r\nreturn 0;\r\n}\r\nstatic struct s5p_jpeg_fmt *s5p_jpeg_find_format(unsigned int mode,\r\nu32 pixelformat)\r\n{\r\nunsigned int k;\r\nstruct s5p_jpeg_fmt *formats;\r\nint n;\r\nif (mode == S5P_JPEG_ENCODE) {\r\nformats = formats_enc;\r\nn = NUM_FORMATS_ENC;\r\n} else {\r\nformats = formats_dec;\r\nn = NUM_FORMATS_DEC;\r\n}\r\nfor (k = 0; k < n; k++) {\r\nstruct s5p_jpeg_fmt *fmt = &formats[k];\r\nif (fmt->fourcc == pixelformat)\r\nreturn fmt;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void jpeg_bound_align_image(u32 *w, unsigned int wmin, unsigned int wmax,\r\nunsigned int walign,\r\nu32 *h, unsigned int hmin, unsigned int hmax,\r\nunsigned int halign)\r\n{\r\nint width, height, w_step, h_step;\r\nwidth = *w;\r\nheight = *h;\r\nw_step = 1 << walign;\r\nh_step = 1 << halign;\r\nv4l_bound_align_image(w, wmin, wmax, walign, h, hmin, hmax, halign, 0);\r\nif (*w < width && (*w + w_step) < wmax)\r\n*w += w_step;\r\nif (*h < height && (*h + h_step) < hmax)\r\n*h += h_step;\r\n}\r\nstatic int vidioc_try_fmt(struct v4l2_format *f, struct s5p_jpeg_fmt *fmt,\r\nstruct s5p_jpeg_ctx *ctx, int q_type)\r\n{\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nif (pix->field == V4L2_FIELD_ANY)\r\npix->field = V4L2_FIELD_NONE;\r\nelse if (pix->field != V4L2_FIELD_NONE)\r\nreturn -EINVAL;\r\nif (q_type == MEM2MEM_OUTPUT)\r\njpeg_bound_align_image(&pix->width, S5P_JPEG_MIN_WIDTH,\r\nS5P_JPEG_MAX_WIDTH, 0,\r\n&pix->height, S5P_JPEG_MIN_HEIGHT,\r\nS5P_JPEG_MAX_HEIGHT, 0);\r\nelse\r\njpeg_bound_align_image(&pix->width, S5P_JPEG_MIN_WIDTH,\r\nS5P_JPEG_MAX_WIDTH, fmt->h_align,\r\n&pix->height, S5P_JPEG_MIN_HEIGHT,\r\nS5P_JPEG_MAX_HEIGHT, fmt->v_align);\r\nif (fmt->fourcc == V4L2_PIX_FMT_JPEG) {\r\nif (pix->sizeimage <= 0)\r\npix->sizeimage = PAGE_SIZE;\r\npix->bytesperline = 0;\r\n} else {\r\nu32 bpl = pix->bytesperline;\r\nif (fmt->colplanes > 1 && bpl < pix->width)\r\nbpl = pix->width;\r\nif (fmt->colplanes == 1 &&\r\n(bpl << 3) * fmt->depth < pix->width)\r\nbpl = (pix->width * fmt->depth) >> 3;\r\npix->bytesperline = bpl;\r\npix->sizeimage = (pix->width * pix->height * fmt->depth) >> 3;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\r\nstruct s5p_jpeg_fmt *fmt;\r\nfmt = s5p_jpeg_find_format(ctx->mode, f->fmt.pix.pixelformat);\r\nif (!fmt || !(fmt->types & MEM2MEM_CAPTURE)) {\r\nv4l2_err(&ctx->jpeg->v4l2_dev,\r\n"Fourcc format (0x%08x) invalid.\n",\r\nf->fmt.pix.pixelformat);\r\nreturn -EINVAL;\r\n}\r\nreturn vidioc_try_fmt(f, fmt, ctx, MEM2MEM_CAPTURE);\r\n}\r\nstatic int s5p_jpeg_try_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\r\nstruct s5p_jpeg_fmt *fmt;\r\nfmt = s5p_jpeg_find_format(ctx->mode, f->fmt.pix.pixelformat);\r\nif (!fmt || !(fmt->types & MEM2MEM_OUTPUT)) {\r\nv4l2_err(&ctx->jpeg->v4l2_dev,\r\n"Fourcc format (0x%08x) invalid.\n",\r\nf->fmt.pix.pixelformat);\r\nreturn -EINVAL;\r\n}\r\nreturn vidioc_try_fmt(f, fmt, ctx, MEM2MEM_OUTPUT);\r\n}\r\nstatic int s5p_jpeg_s_fmt(struct s5p_jpeg_ctx *ct, struct v4l2_format *f)\r\n{\r\nstruct vb2_queue *vq;\r\nstruct s5p_jpeg_q_data *q_data = NULL;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nvq = v4l2_m2m_get_vq(ct->m2m_ctx, f->type);\r\nif (!vq)\r\nreturn -EINVAL;\r\nq_data = get_q_data(ct, f->type);\r\nBUG_ON(q_data == NULL);\r\nif (vb2_is_busy(vq)) {\r\nv4l2_err(&ct->jpeg->v4l2_dev, "%s queue busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nq_data->fmt = s5p_jpeg_find_format(ct->mode, pix->pixelformat);\r\nq_data->w = pix->width;\r\nq_data->h = pix->height;\r\nif (q_data->fmt->fourcc != V4L2_PIX_FMT_JPEG)\r\nq_data->size = q_data->w * q_data->h * q_data->fmt->depth >> 3;\r\nelse\r\nq_data->size = pix->sizeimage;\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nint ret;\r\nret = s5p_jpeg_try_fmt_vid_cap(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nreturn s5p_jpeg_s_fmt(fh_to_ctx(priv), f);\r\n}\r\nstatic int s5p_jpeg_s_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nint ret;\r\nret = s5p_jpeg_try_fmt_vid_out(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nreturn s5p_jpeg_s_fmt(fh_to_ctx(priv), f);\r\n}\r\nstatic int s5p_jpeg_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *reqbufs)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\r\nreturn v4l2_m2m_reqbufs(file, ctx->m2m_ctx, reqbufs);\r\n}\r\nstatic int s5p_jpeg_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\r\nreturn v4l2_m2m_querybuf(file, ctx->m2m_ctx, buf);\r\n}\r\nstatic int s5p_jpeg_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\r\nreturn v4l2_m2m_qbuf(file, ctx->m2m_ctx, buf);\r\n}\r\nstatic int s5p_jpeg_dqbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\r\nreturn v4l2_m2m_dqbuf(file, ctx->m2m_ctx, buf);\r\n}\r\nstatic int s5p_jpeg_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\r\nreturn v4l2_m2m_streamon(file, ctx->m2m_ctx, type);\r\n}\r\nstatic int s5p_jpeg_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\r\nreturn v4l2_m2m_streamoff(file, ctx->m2m_ctx, type);\r\n}\r\nstatic int s5p_jpeg_g_selection(struct file *file, void *priv,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = fh_to_ctx(priv);\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&\r\ns->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_CROP:\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\ncase V4L2_SEL_TGT_COMPOSE:\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\ns->r.width = ctx->out_q.w;\r\ns->r.height = ctx->out_q.h;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\ncase V4L2_SEL_TGT_COMPOSE_PADDED:\r\ns->r.width = ctx->cap_q.w;\r\ns->r.height = ctx->cap_q.h;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ns->r.left = 0;\r\ns->r.top = 0;\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_g_volatile_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = ctrl_to_ctx(ctrl);\r\nstruct s5p_jpeg *jpeg = ctx->jpeg;\r\nunsigned long flags;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_JPEG_CHROMA_SUBSAMPLING:\r\nspin_lock_irqsave(&jpeg->slock, flags);\r\nWARN_ON(ctx->subsampling > S5P_SUBSAMPLING_MODE_GRAY);\r\nif (ctx->subsampling > 2)\r\nctrl->val = V4L2_JPEG_CHROMA_SUBSAMPLING_GRAY;\r\nelse\r\nctrl->val = ctx->subsampling;\r\nspin_unlock_irqrestore(&jpeg->slock, flags);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = ctrl_to_ctx(ctrl);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ctx->jpeg->slock, flags);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_JPEG_COMPRESSION_QUALITY:\r\nctx->compr_quality = S5P_JPEG_COMPR_QUAL_WORST - ctrl->val;\r\nbreak;\r\ncase V4L2_CID_JPEG_RESTART_INTERVAL:\r\nctx->restart_interval = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_JPEG_CHROMA_SUBSAMPLING:\r\nctx->subsampling = ctrl->val;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&ctx->jpeg->slock, flags);\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_controls_create(struct s5p_jpeg_ctx *ctx)\r\n{\r\nunsigned int mask = ~0x27;\r\nstruct v4l2_ctrl *ctrl;\r\nv4l2_ctrl_handler_init(&ctx->ctrl_handler, 3);\r\nif (ctx->mode == S5P_JPEG_ENCODE) {\r\nv4l2_ctrl_new_std(&ctx->ctrl_handler, &s5p_jpeg_ctrl_ops,\r\nV4L2_CID_JPEG_COMPRESSION_QUALITY,\r\n0, 3, 1, 3);\r\nv4l2_ctrl_new_std(&ctx->ctrl_handler, &s5p_jpeg_ctrl_ops,\r\nV4L2_CID_JPEG_RESTART_INTERVAL,\r\n0, 3, 0xffff, 0);\r\nmask = ~0x06;\r\n}\r\nctrl = v4l2_ctrl_new_std_menu(&ctx->ctrl_handler, &s5p_jpeg_ctrl_ops,\r\nV4L2_CID_JPEG_CHROMA_SUBSAMPLING,\r\nV4L2_JPEG_CHROMA_SUBSAMPLING_GRAY, mask,\r\nV4L2_JPEG_CHROMA_SUBSAMPLING_422);\r\nif (ctx->ctrl_handler.error)\r\nreturn ctx->ctrl_handler.error;\r\nif (ctx->mode == S5P_JPEG_DECODE)\r\nctrl->flags |= V4L2_CTRL_FLAG_VOLATILE |\r\nV4L2_CTRL_FLAG_READ_ONLY;\r\nreturn 0;\r\n}\r\nstatic void s5p_jpeg_device_run(void *priv)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = priv;\r\nstruct s5p_jpeg *jpeg = ctx->jpeg;\r\nstruct vb2_buffer *src_buf, *dst_buf;\r\nunsigned long src_addr, dst_addr;\r\nsrc_buf = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\r\ndst_buf = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);\r\nsrc_addr = vb2_dma_contig_plane_dma_addr(src_buf, 0);\r\ndst_addr = vb2_dma_contig_plane_dma_addr(dst_buf, 0);\r\njpeg_reset(jpeg->regs);\r\njpeg_poweron(jpeg->regs);\r\njpeg_proc_mode(jpeg->regs, ctx->mode);\r\nif (ctx->mode == S5P_JPEG_ENCODE) {\r\nif (ctx->out_q.fmt->fourcc == V4L2_PIX_FMT_RGB565)\r\njpeg_input_raw_mode(jpeg->regs, S5P_JPEG_RAW_IN_565);\r\nelse\r\njpeg_input_raw_mode(jpeg->regs, S5P_JPEG_RAW_IN_422);\r\njpeg_subsampling_mode(jpeg->regs, ctx->subsampling);\r\njpeg_dri(jpeg->regs, ctx->restart_interval);\r\njpeg_x(jpeg->regs, ctx->out_q.w);\r\njpeg_y(jpeg->regs, ctx->out_q.h);\r\njpeg_imgadr(jpeg->regs, src_addr);\r\njpeg_jpgadr(jpeg->regs, dst_addr);\r\njpeg_enc_stream_int(jpeg->regs, ctx->cap_q.size);\r\njpeg_coef(jpeg->regs, 1, 1, S5P_JPEG_COEF11);\r\njpeg_coef(jpeg->regs, 1, 2, S5P_JPEG_COEF12);\r\njpeg_coef(jpeg->regs, 1, 3, S5P_JPEG_COEF13);\r\njpeg_coef(jpeg->regs, 2, 1, S5P_JPEG_COEF21);\r\njpeg_coef(jpeg->regs, 2, 2, S5P_JPEG_COEF22);\r\njpeg_coef(jpeg->regs, 2, 3, S5P_JPEG_COEF23);\r\njpeg_coef(jpeg->regs, 3, 1, S5P_JPEG_COEF31);\r\njpeg_coef(jpeg->regs, 3, 2, S5P_JPEG_COEF32);\r\njpeg_coef(jpeg->regs, 3, 3, S5P_JPEG_COEF33);\r\njpeg_set_qtbl_lum(jpeg->regs, ctx->compr_quality);\r\njpeg_set_qtbl_chr(jpeg->regs, ctx->compr_quality);\r\njpeg_qtbl(jpeg->regs, 1, 0);\r\njpeg_qtbl(jpeg->regs, 2, 1);\r\njpeg_qtbl(jpeg->regs, 3, 1);\r\njpeg_htbl_ac(jpeg->regs, 1);\r\njpeg_htbl_dc(jpeg->regs, 1);\r\njpeg_htbl_ac(jpeg->regs, 2);\r\njpeg_htbl_dc(jpeg->regs, 2);\r\njpeg_htbl_ac(jpeg->regs, 3);\r\njpeg_htbl_dc(jpeg->regs, 3);\r\n} else {\r\njpeg_rst_int_enable(jpeg->regs, true);\r\njpeg_data_num_int_enable(jpeg->regs, true);\r\njpeg_final_mcu_num_int_enable(jpeg->regs, true);\r\nif (ctx->cap_q.fmt->fourcc == V4L2_PIX_FMT_YUYV)\r\njpeg_outform_raw(jpeg->regs, S5P_JPEG_RAW_OUT_422);\r\nelse\r\njpeg_outform_raw(jpeg->regs, S5P_JPEG_RAW_OUT_420);\r\njpeg_jpgadr(jpeg->regs, src_addr);\r\njpeg_imgadr(jpeg->regs, dst_addr);\r\n}\r\njpeg_start(jpeg->regs);\r\n}\r\nstatic int s5p_jpeg_job_ready(void *priv)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = priv;\r\nif (ctx->mode == S5P_JPEG_DECODE)\r\nreturn ctx->hdr_parsed;\r\nreturn 1;\r\n}\r\nstatic void s5p_jpeg_job_abort(void *priv)\r\n{\r\n}\r\nstatic int s5p_jpeg_queue_setup(struct vb2_queue *vq,\r\nconst struct v4l2_format *fmt,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct s5p_jpeg_q_data *q_data = NULL;\r\nunsigned int size, count = *nbuffers;\r\nq_data = get_q_data(ctx, vq->type);\r\nBUG_ON(q_data == NULL);\r\nsize = q_data->size;\r\nif (ctx->mode == S5P_JPEG_DECODE)\r\ncount = 1;\r\n*nbuffers = count;\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nalloc_ctxs[0] = ctx->jpeg->alloc_ctx;\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct s5p_jpeg_q_data *q_data = NULL;\r\nq_data = get_q_data(ctx, vb->vb2_queue->type);\r\nBUG_ON(q_data == NULL);\r\nif (vb2_plane_size(vb, 0) < q_data->size) {\r\npr_err("%s data will not fit into plane (%lu < %lu)\n",\r\n__func__, vb2_plane_size(vb, 0),\r\n(long)q_data->size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, 0, q_data->size);\r\nreturn 0;\r\n}\r\nstatic void s5p_jpeg_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nif (ctx->mode == S5P_JPEG_DECODE &&\r\nvb->vb2_queue->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nstruct s5p_jpeg_q_data tmp, *q_data;\r\nctx->hdr_parsed = s5p_jpeg_parse_hdr(&tmp,\r\n(unsigned long)vb2_plane_vaddr(vb, 0),\r\nmin((unsigned long)ctx->out_q.size,\r\nvb2_get_plane_payload(vb, 0)));\r\nif (!ctx->hdr_parsed) {\r\nvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\r\nreturn;\r\n}\r\nq_data = &ctx->out_q;\r\nq_data->w = tmp.w;\r\nq_data->h = tmp.h;\r\nq_data = &ctx->cap_q;\r\nq_data->w = tmp.w;\r\nq_data->h = tmp.h;\r\njpeg_bound_align_image(&q_data->w, S5P_JPEG_MIN_WIDTH,\r\nS5P_JPEG_MAX_WIDTH, q_data->fmt->h_align,\r\n&q_data->h, S5P_JPEG_MIN_HEIGHT,\r\nS5P_JPEG_MAX_HEIGHT, q_data->fmt->v_align\r\n);\r\nq_data->size = q_data->w * q_data->h * q_data->fmt->depth >> 3;\r\n}\r\nif (ctx->m2m_ctx)\r\nv4l2_m2m_buf_queue(ctx->m2m_ctx, vb);\r\n}\r\nstatic void s5p_jpeg_wait_prepare(struct vb2_queue *vq)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(vq);\r\nmutex_unlock(&ctx->jpeg->lock);\r\n}\r\nstatic void s5p_jpeg_wait_finish(struct vb2_queue *vq)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(vq);\r\nmutex_lock(&ctx->jpeg->lock);\r\n}\r\nstatic int s5p_jpeg_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(q);\r\nint ret;\r\nret = pm_runtime_get_sync(ctx->jpeg->dev);\r\nreturn ret > 0 ? 0 : ret;\r\n}\r\nstatic int s5p_jpeg_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(q);\r\npm_runtime_put(ctx->jpeg->dev);\r\nreturn 0;\r\n}\r\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\r\nstruct vb2_queue *dst_vq)\r\n{\r\nstruct s5p_jpeg_ctx *ctx = priv;\r\nint ret;\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR;\r\nsrc_vq->drv_priv = ctx;\r\nsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\nsrc_vq->ops = &s5p_jpeg_qops;\r\nsrc_vq->mem_ops = &vb2_dma_contig_memops;\r\nsrc_vq->timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nret = vb2_queue_init(src_vq);\r\nif (ret)\r\nreturn ret;\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ndst_vq->io_modes = VB2_MMAP | VB2_USERPTR;\r\ndst_vq->drv_priv = ctx;\r\ndst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\ndst_vq->ops = &s5p_jpeg_qops;\r\ndst_vq->mem_ops = &vb2_dma_contig_memops;\r\ndst_vq->timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nreturn vb2_queue_init(dst_vq);\r\n}\r\nstatic irqreturn_t s5p_jpeg_irq(int irq, void *dev_id)\r\n{\r\nstruct s5p_jpeg *jpeg = dev_id;\r\nstruct s5p_jpeg_ctx *curr_ctx;\r\nstruct vb2_buffer *src_buf, *dst_buf;\r\nunsigned long payload_size = 0;\r\nenum vb2_buffer_state state = VB2_BUF_STATE_DONE;\r\nbool enc_jpeg_too_large = false;\r\nbool timer_elapsed = false;\r\nbool op_completed = false;\r\nspin_lock(&jpeg->slock);\r\ncurr_ctx = v4l2_m2m_get_curr_priv(jpeg->m2m_dev);\r\nsrc_buf = v4l2_m2m_src_buf_remove(curr_ctx->m2m_ctx);\r\ndst_buf = v4l2_m2m_dst_buf_remove(curr_ctx->m2m_ctx);\r\nif (curr_ctx->mode == S5P_JPEG_ENCODE)\r\nenc_jpeg_too_large = jpeg_enc_stream_stat(jpeg->regs);\r\ntimer_elapsed = jpeg_timer_stat(jpeg->regs);\r\nop_completed = jpeg_result_stat_ok(jpeg->regs);\r\nif (curr_ctx->mode == S5P_JPEG_DECODE)\r\nop_completed = op_completed && jpeg_stream_stat_ok(jpeg->regs);\r\nif (enc_jpeg_too_large) {\r\nstate = VB2_BUF_STATE_ERROR;\r\njpeg_clear_enc_stream_stat(jpeg->regs);\r\n} else if (timer_elapsed) {\r\nstate = VB2_BUF_STATE_ERROR;\r\njpeg_clear_timer_stat(jpeg->regs);\r\n} else if (!op_completed) {\r\nstate = VB2_BUF_STATE_ERROR;\r\n} else {\r\npayload_size = jpeg_compressed_size(jpeg->regs);\r\n}\r\ndst_buf->v4l2_buf.timecode = src_buf->v4l2_buf.timecode;\r\ndst_buf->v4l2_buf.timestamp = src_buf->v4l2_buf.timestamp;\r\nv4l2_m2m_buf_done(src_buf, state);\r\nif (curr_ctx->mode == S5P_JPEG_ENCODE)\r\nvb2_set_plane_payload(dst_buf, 0, payload_size);\r\nv4l2_m2m_buf_done(dst_buf, state);\r\nv4l2_m2m_job_finish(jpeg->m2m_dev, curr_ctx->m2m_ctx);\r\ncurr_ctx->subsampling = jpeg_get_subsampling_mode(jpeg->regs);\r\nspin_unlock(&jpeg->slock);\r\njpeg_clear_int(jpeg->regs);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s5p_jpeg_probe(struct platform_device *pdev)\r\n{\r\nstruct s5p_jpeg *jpeg;\r\nstruct resource *res;\r\nint ret;\r\njpeg = devm_kzalloc(&pdev->dev, sizeof(struct s5p_jpeg), GFP_KERNEL);\r\nif (!jpeg)\r\nreturn -ENOMEM;\r\nmutex_init(&jpeg->lock);\r\nspin_lock_init(&jpeg->slock);\r\njpeg->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\njpeg->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(jpeg->regs))\r\nreturn PTR_ERR(jpeg->regs);\r\njpeg->irq = ret = platform_get_irq(pdev, 0);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "cannot find IRQ\n");\r\nreturn ret;\r\n}\r\nret = devm_request_irq(&pdev->dev, jpeg->irq, s5p_jpeg_irq, 0,\r\ndev_name(&pdev->dev), jpeg);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot claim IRQ %d\n", jpeg->irq);\r\nreturn ret;\r\n}\r\njpeg->clk = clk_get(&pdev->dev, "jpeg");\r\nif (IS_ERR(jpeg->clk)) {\r\ndev_err(&pdev->dev, "cannot get clock\n");\r\nret = PTR_ERR(jpeg->clk);\r\nreturn ret;\r\n}\r\ndev_dbg(&pdev->dev, "clock source %p\n", jpeg->clk);\r\nclk_prepare_enable(jpeg->clk);\r\nret = v4l2_device_register(&pdev->dev, &jpeg->v4l2_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to register v4l2 device\n");\r\ngoto clk_get_rollback;\r\n}\r\njpeg->m2m_dev = v4l2_m2m_init(&s5p_jpeg_m2m_ops);\r\nif (IS_ERR(jpeg->m2m_dev)) {\r\nv4l2_err(&jpeg->v4l2_dev, "Failed to init mem2mem device\n");\r\nret = PTR_ERR(jpeg->m2m_dev);\r\ngoto device_register_rollback;\r\n}\r\njpeg->alloc_ctx = vb2_dma_contig_init_ctx(&pdev->dev);\r\nif (IS_ERR(jpeg->alloc_ctx)) {\r\nv4l2_err(&jpeg->v4l2_dev, "Failed to init memory allocator\n");\r\nret = PTR_ERR(jpeg->alloc_ctx);\r\ngoto m2m_init_rollback;\r\n}\r\njpeg->vfd_encoder = video_device_alloc();\r\nif (!jpeg->vfd_encoder) {\r\nv4l2_err(&jpeg->v4l2_dev, "Failed to allocate video device\n");\r\nret = -ENOMEM;\r\ngoto vb2_allocator_rollback;\r\n}\r\nstrlcpy(jpeg->vfd_encoder->name, S5P_JPEG_M2M_NAME,\r\nsizeof(jpeg->vfd_encoder->name));\r\njpeg->vfd_encoder->fops = &s5p_jpeg_fops;\r\njpeg->vfd_encoder->ioctl_ops = &s5p_jpeg_ioctl_ops;\r\njpeg->vfd_encoder->minor = -1;\r\njpeg->vfd_encoder->release = video_device_release;\r\njpeg->vfd_encoder->lock = &jpeg->lock;\r\njpeg->vfd_encoder->v4l2_dev = &jpeg->v4l2_dev;\r\njpeg->vfd_encoder->vfl_dir = VFL_DIR_M2M;\r\nret = video_register_device(jpeg->vfd_encoder, VFL_TYPE_GRABBER, -1);\r\nif (ret) {\r\nv4l2_err(&jpeg->v4l2_dev, "Failed to register video device\n");\r\ngoto enc_vdev_alloc_rollback;\r\n}\r\nvideo_set_drvdata(jpeg->vfd_encoder, jpeg);\r\nv4l2_info(&jpeg->v4l2_dev,\r\n"encoder device registered as /dev/video%d\n",\r\njpeg->vfd_encoder->num);\r\njpeg->vfd_decoder = video_device_alloc();\r\nif (!jpeg->vfd_decoder) {\r\nv4l2_err(&jpeg->v4l2_dev, "Failed to allocate video device\n");\r\nret = -ENOMEM;\r\ngoto enc_vdev_register_rollback;\r\n}\r\nstrlcpy(jpeg->vfd_decoder->name, S5P_JPEG_M2M_NAME,\r\nsizeof(jpeg->vfd_decoder->name));\r\njpeg->vfd_decoder->fops = &s5p_jpeg_fops;\r\njpeg->vfd_decoder->ioctl_ops = &s5p_jpeg_ioctl_ops;\r\njpeg->vfd_decoder->minor = -1;\r\njpeg->vfd_decoder->release = video_device_release;\r\njpeg->vfd_decoder->lock = &jpeg->lock;\r\njpeg->vfd_decoder->v4l2_dev = &jpeg->v4l2_dev;\r\njpeg->vfd_decoder->vfl_dir = VFL_DIR_M2M;\r\nret = video_register_device(jpeg->vfd_decoder, VFL_TYPE_GRABBER, -1);\r\nif (ret) {\r\nv4l2_err(&jpeg->v4l2_dev, "Failed to register video device\n");\r\ngoto dec_vdev_alloc_rollback;\r\n}\r\nvideo_set_drvdata(jpeg->vfd_decoder, jpeg);\r\nv4l2_info(&jpeg->v4l2_dev,\r\n"decoder device registered as /dev/video%d\n",\r\njpeg->vfd_decoder->num);\r\nplatform_set_drvdata(pdev, jpeg);\r\npm_runtime_enable(&pdev->dev);\r\nv4l2_info(&jpeg->v4l2_dev, "Samsung S5P JPEG codec\n");\r\nreturn 0;\r\ndec_vdev_alloc_rollback:\r\nvideo_device_release(jpeg->vfd_decoder);\r\nenc_vdev_register_rollback:\r\nvideo_unregister_device(jpeg->vfd_encoder);\r\nenc_vdev_alloc_rollback:\r\nvideo_device_release(jpeg->vfd_encoder);\r\nvb2_allocator_rollback:\r\nvb2_dma_contig_cleanup_ctx(jpeg->alloc_ctx);\r\nm2m_init_rollback:\r\nv4l2_m2m_release(jpeg->m2m_dev);\r\ndevice_register_rollback:\r\nv4l2_device_unregister(&jpeg->v4l2_dev);\r\nclk_get_rollback:\r\nclk_disable_unprepare(jpeg->clk);\r\nclk_put(jpeg->clk);\r\nreturn ret;\r\n}\r\nstatic int s5p_jpeg_remove(struct platform_device *pdev)\r\n{\r\nstruct s5p_jpeg *jpeg = platform_get_drvdata(pdev);\r\npm_runtime_disable(jpeg->dev);\r\nvideo_unregister_device(jpeg->vfd_decoder);\r\nvideo_device_release(jpeg->vfd_decoder);\r\nvideo_unregister_device(jpeg->vfd_encoder);\r\nvideo_device_release(jpeg->vfd_encoder);\r\nvb2_dma_contig_cleanup_ctx(jpeg->alloc_ctx);\r\nv4l2_m2m_release(jpeg->m2m_dev);\r\nv4l2_device_unregister(&jpeg->v4l2_dev);\r\nclk_disable_unprepare(jpeg->clk);\r\nclk_put(jpeg->clk);\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_runtime_suspend(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int s5p_jpeg_runtime_resume(struct device *dev)\r\n{\r\nstruct s5p_jpeg *jpeg = dev_get_drvdata(dev);\r\njpeg_set_hdctbl(jpeg->regs);\r\njpeg_set_hdctblg(jpeg->regs);\r\njpeg_set_hactbl(jpeg->regs);\r\njpeg_set_hactblg(jpeg->regs);\r\nreturn 0;\r\n}
