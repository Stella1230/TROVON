static int sis_fb_init(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_sis_private_t *dev_priv = dev->dev_private;\r\ndrm_sis_fb_t *fb = data;\r\nmutex_lock(&dev->struct_mutex);\r\ndrm_mm_init(&dev_priv->vram_mm, 0, fb->size >> SIS_MM_ALIGN_SHIFT);\r\ndev_priv->vram_initialized = 1;\r\ndev_priv->vram_offset = fb->offset;\r\nmutex_unlock(&dev->struct_mutex);\r\nDRM_DEBUG("offset = %lu, size = %lu\n", fb->offset, fb->size);\r\nreturn 0;\r\n}\r\nstatic int sis_drm_alloc(struct drm_device *dev, struct drm_file *file,\r\nvoid *data, int pool)\r\n{\r\ndrm_sis_private_t *dev_priv = dev->dev_private;\r\ndrm_sis_mem_t *mem = data;\r\nint retval = 0, user_key;\r\nstruct sis_memblock *item;\r\nstruct sis_file_private *file_priv = file->driver_priv;\r\nunsigned long offset;\r\nmutex_lock(&dev->struct_mutex);\r\nif (0 == ((pool == 0) ? dev_priv->vram_initialized :\r\ndev_priv->agp_initialized)) {\r\nDRM_ERROR\r\n("Attempt to allocate from uninitialized memory manager.\n");\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn -EINVAL;\r\n}\r\nitem = kzalloc(sizeof(*item), GFP_KERNEL);\r\nif (!item) {\r\nretval = -ENOMEM;\r\ngoto fail_alloc;\r\n}\r\nmem->size = (mem->size + SIS_MM_ALIGN_MASK) >> SIS_MM_ALIGN_SHIFT;\r\nif (pool == AGP_TYPE) {\r\nretval = drm_mm_insert_node(&dev_priv->agp_mm,\r\n&item->mm_node,\r\nmem->size, 0,\r\nDRM_MM_SEARCH_DEFAULT);\r\noffset = item->mm_node.start;\r\n} else {\r\n#if defined(CONFIG_FB_SIS) || defined(CONFIG_FB_SIS_MODULE)\r\nitem->req.size = mem->size;\r\nsis_malloc(&item->req);\r\nif (item->req.size == 0)\r\nretval = -ENOMEM;\r\noffset = item->req.offset;\r\n#else\r\nretval = drm_mm_insert_node(&dev_priv->vram_mm,\r\n&item->mm_node,\r\nmem->size, 0,\r\nDRM_MM_SEARCH_DEFAULT);\r\noffset = item->mm_node.start;\r\n#endif\r\n}\r\nif (retval)\r\ngoto fail_alloc;\r\nretval = idr_alloc(&dev_priv->object_idr, item, 1, 0, GFP_KERNEL);\r\nif (retval < 0)\r\ngoto fail_idr;\r\nuser_key = retval;\r\nlist_add(&item->owner_list, &file_priv->obj_list);\r\nmutex_unlock(&dev->struct_mutex);\r\nmem->offset = ((pool == 0) ?\r\ndev_priv->vram_offset : dev_priv->agp_offset) +\r\n(offset << SIS_MM_ALIGN_SHIFT);\r\nmem->free = user_key;\r\nmem->size = mem->size << SIS_MM_ALIGN_SHIFT;\r\nreturn 0;\r\nfail_idr:\r\ndrm_mm_remove_node(&item->mm_node);\r\nfail_alloc:\r\nkfree(item);\r\nmutex_unlock(&dev->struct_mutex);\r\nmem->offset = 0;\r\nmem->size = 0;\r\nmem->free = 0;\r\nDRM_DEBUG("alloc %d, size = %ld, offset = %ld\n", pool, mem->size,\r\nmem->offset);\r\nreturn retval;\r\n}\r\nstatic int sis_drm_free(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_sis_private_t *dev_priv = dev->dev_private;\r\ndrm_sis_mem_t *mem = data;\r\nstruct sis_memblock *obj;\r\nmutex_lock(&dev->struct_mutex);\r\nobj = idr_find(&dev_priv->object_idr, mem->free);\r\nif (obj == NULL) {\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn -EINVAL;\r\n}\r\nidr_remove(&dev_priv->object_idr, mem->free);\r\nlist_del(&obj->owner_list);\r\nif (drm_mm_node_allocated(&obj->mm_node))\r\ndrm_mm_remove_node(&obj->mm_node);\r\n#if defined(CONFIG_FB_SIS) || defined(CONFIG_FB_SIS_MODULE)\r\nelse\r\nsis_free(obj->req.offset);\r\n#endif\r\nkfree(obj);\r\nmutex_unlock(&dev->struct_mutex);\r\nDRM_DEBUG("free = 0x%lx\n", mem->free);\r\nreturn 0;\r\n}\r\nstatic int sis_fb_alloc(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nreturn sis_drm_alloc(dev, file_priv, data, VIDEO_TYPE);\r\n}\r\nstatic int sis_ioctl_agp_init(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\ndrm_sis_private_t *dev_priv = dev->dev_private;\r\ndrm_sis_agp_t *agp = data;\r\ndev_priv = dev->dev_private;\r\nmutex_lock(&dev->struct_mutex);\r\ndrm_mm_init(&dev_priv->agp_mm, 0, agp->size >> SIS_MM_ALIGN_SHIFT);\r\ndev_priv->agp_initialized = 1;\r\ndev_priv->agp_offset = agp->offset;\r\nmutex_unlock(&dev->struct_mutex);\r\nDRM_DEBUG("offset = %lu, size = %lu\n", agp->offset, agp->size);\r\nreturn 0;\r\n}\r\nstatic int sis_ioctl_agp_alloc(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nreturn sis_drm_alloc(dev, file_priv, data, AGP_TYPE);\r\n}\r\nstatic drm_local_map_t *sis_reg_init(struct drm_device *dev)\r\n{\r\nstruct drm_map_list *entry;\r\ndrm_local_map_t *map;\r\nlist_for_each_entry(entry, &dev->maplist, head) {\r\nmap = entry->map;\r\nif (!map)\r\ncontinue;\r\nif (map->type == _DRM_REGISTERS)\r\nreturn map;\r\n}\r\nreturn NULL;\r\n}\r\nint sis_idle(struct drm_device *dev)\r\n{\r\ndrm_sis_private_t *dev_priv = dev->dev_private;\r\nuint32_t idle_reg;\r\nunsigned long end;\r\nint i;\r\nif (dev_priv->idle_fault)\r\nreturn 0;\r\nif (dev_priv->mmio == NULL) {\r\ndev_priv->mmio = sis_reg_init(dev);\r\nif (dev_priv->mmio == NULL) {\r\nDRM_ERROR("Could not find register map.\n");\r\nreturn 0;\r\n}\r\n}\r\nif (dev_priv->chipset != SIS_CHIP_315)\r\nreturn 0;\r\nend = jiffies + (DRM_HZ * 3);\r\nfor (i = 0; i < 4; ++i) {\r\ndo {\r\nidle_reg = SIS_READ(0x85cc);\r\n} while (!time_after_eq(jiffies, end) &&\r\n((idle_reg & 0x80000000) != 0x80000000));\r\n}\r\nif (time_after_eq(jiffies, end)) {\r\nDRM_ERROR("Graphics engine idle timeout. "\r\n"Disabling idle check\n");\r\ndev_priv->idle_fault = 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid sis_lastclose(struct drm_device *dev)\r\n{\r\ndrm_sis_private_t *dev_priv = dev->dev_private;\r\nif (!dev_priv)\r\nreturn;\r\nmutex_lock(&dev->struct_mutex);\r\nif (dev_priv->vram_initialized) {\r\ndrm_mm_takedown(&dev_priv->vram_mm);\r\ndev_priv->vram_initialized = 0;\r\n}\r\nif (dev_priv->agp_initialized) {\r\ndrm_mm_takedown(&dev_priv->agp_mm);\r\ndev_priv->agp_initialized = 0;\r\n}\r\ndev_priv->mmio = NULL;\r\nmutex_unlock(&dev->struct_mutex);\r\n}\r\nvoid sis_reclaim_buffers_locked(struct drm_device *dev,\r\nstruct drm_file *file)\r\n{\r\nstruct sis_file_private *file_priv = file->driver_priv;\r\nstruct sis_memblock *entry, *next;\r\nif (!(file->minor->master && file->master->lock.hw_lock))\r\nreturn;\r\ndrm_idlelock_take(&file->master->lock);\r\nmutex_lock(&dev->struct_mutex);\r\nif (list_empty(&file_priv->obj_list)) {\r\nmutex_unlock(&dev->struct_mutex);\r\ndrm_idlelock_release(&file->master->lock);\r\nreturn;\r\n}\r\nsis_idle(dev);\r\nlist_for_each_entry_safe(entry, next, &file_priv->obj_list,\r\nowner_list) {\r\nlist_del(&entry->owner_list);\r\nif (drm_mm_node_allocated(&entry->mm_node))\r\ndrm_mm_remove_node(&entry->mm_node);\r\n#if defined(CONFIG_FB_SIS) || defined(CONFIG_FB_SIS_MODULE)\r\nelse\r\nsis_free(entry->req.offset);\r\n#endif\r\nkfree(entry);\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\ndrm_idlelock_release(&file->master->lock);\r\nreturn;\r\n}
