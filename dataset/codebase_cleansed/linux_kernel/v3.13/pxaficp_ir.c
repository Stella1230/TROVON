static inline void pxa_irda_disable_clk(struct pxa_irda *si)\r\n{\r\nif (si->cur_clk)\r\nclk_disable_unprepare(si->cur_clk);\r\nsi->cur_clk = NULL;\r\n}\r\nstatic inline void pxa_irda_enable_firclk(struct pxa_irda *si)\r\n{\r\nsi->cur_clk = si->fir_clk;\r\nclk_prepare_enable(si->fir_clk);\r\n}\r\nstatic inline void pxa_irda_enable_sirclk(struct pxa_irda *si)\r\n{\r\nsi->cur_clk = si->sir_clk;\r\nclk_prepare_enable(si->sir_clk);\r\n}\r\ninline static void pxa_irda_fir_dma_rx_start(struct pxa_irda *si)\r\n{\r\nDCSR(si->rxdma) = DCSR_NODESC;\r\nDSADR(si->rxdma) = __PREG(ICDR);\r\nDTADR(si->rxdma) = si->dma_rx_buff_phy;\r\nDCMD(si->rxdma) = DCMD_INCTRGADDR | DCMD_FLOWSRC | DCMD_WIDTH1 | DCMD_BURST32 | IRDA_FRAME_SIZE_LIMIT;\r\nDCSR(si->rxdma) |= DCSR_RUN;\r\n}\r\ninline static void pxa_irda_fir_dma_tx_start(struct pxa_irda *si)\r\n{\r\nDCSR(si->txdma) = DCSR_NODESC;\r\nDSADR(si->txdma) = si->dma_tx_buff_phy;\r\nDTADR(si->txdma) = __PREG(ICDR);\r\nDCMD(si->txdma) = DCMD_INCSRCADDR | DCMD_FLOWTRG | DCMD_ENDIRQEN | DCMD_WIDTH1 | DCMD_BURST32 | si->dma_tx_buff_len;\r\nDCSR(si->txdma) |= DCSR_RUN;\r\n}\r\nstatic void pxa_irda_set_mode(struct pxa_irda *si, int mode)\r\n{\r\nif (si->pdata->transceiver_mode)\r\nsi->pdata->transceiver_mode(si->dev, mode);\r\nelse {\r\nif (gpio_is_valid(si->pdata->gpio_pwdown))\r\ngpio_set_value(si->pdata->gpio_pwdown,\r\n!(mode & IR_OFF) ^\r\n!si->pdata->gpio_pwdown_inverted);\r\npxa2xx_transceiver_mode(si->dev, mode);\r\n}\r\n}\r\nstatic int pxa_irda_set_speed(struct pxa_irda *si, int speed)\r\n{\r\nunsigned long flags;\r\nunsigned int divisor;\r\nswitch (speed) {\r\ncase 9600: case 19200: case 38400:\r\ncase 57600: case 115200:\r\ndivisor = 14745600 / (16 * speed);\r\nlocal_irq_save(flags);\r\nif (IS_FIR(si)) {\r\nDCSR(si->rxdma) &= ~DCSR_RUN;\r\nICCR0 = 0;\r\npxa_irda_disable_clk(si);\r\npxa_irda_set_mode(si, IR_SIRMODE);\r\npxa_irda_enable_sirclk(si);\r\n}\r\nSTIER = 0;\r\nSTLCR |= LCR_DLAB;\r\nSTDLL = divisor & 0xff;\r\nSTDLH = divisor >> 8;\r\nSTLCR &= ~LCR_DLAB;\r\nsi->speed = speed;\r\nSTISR = IrSR_IR_RECEIVE_ON | IrSR_XMODE_PULSE_1_6;\r\nSTIER = IER_UUE | IER_RLSE | IER_RAVIE | IER_RTIOE;\r\nlocal_irq_restore(flags);\r\nbreak;\r\ncase 4000000:\r\nlocal_irq_save(flags);\r\nSTIER = 0;\r\nSTISR = 0;\r\npxa_irda_disable_clk(si);\r\nICCR0 = 0;\r\npxa_irda_set_mode(si, IR_FIRMODE);\r\npxa_irda_enable_firclk(si);\r\nsi->speed = speed;\r\npxa_irda_fir_dma_rx_start(si);\r\nICCR0 = ICCR0_ITR | ICCR0_RXE;\r\nlocal_irq_restore(flags);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t pxa_irda_sir_irq(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct pxa_irda *si = netdev_priv(dev);\r\nint iir, lsr, data;\r\niir = STIIR;\r\nswitch (iir & 0x0F) {\r\ncase 0x06:\r\nlsr = STLSR;\r\nwhile (lsr & LSR_FIFOE) {\r\ndata = STRBR;\r\nif (lsr & (LSR_OE | LSR_PE | LSR_FE | LSR_BI)) {\r\nprintk(KERN_DEBUG "pxa_ir: sir receiving error\n");\r\ndev->stats.rx_errors++;\r\nif (lsr & LSR_FE)\r\ndev->stats.rx_frame_errors++;\r\nif (lsr & LSR_OE)\r\ndev->stats.rx_fifo_errors++;\r\n} else {\r\ndev->stats.rx_bytes++;\r\nasync_unwrap_char(dev, &dev->stats,\r\n&si->rx_buff, data);\r\n}\r\nlsr = STLSR;\r\n}\r\nsi->last_oscr = readl_relaxed(OSCR);\r\nbreak;\r\ncase 0x04:\r\ncase 0x0C:\r\ndo {\r\ndev->stats.rx_bytes++;\r\nasync_unwrap_char(dev, &dev->stats, &si->rx_buff, STRBR);\r\n} while (STLSR & LSR_DR);\r\nsi->last_oscr = readl_relaxed(OSCR);\r\nbreak;\r\ncase 0x02:\r\nwhile ((si->tx_buff.len) && (STLSR & LSR_TDRQ)) {\r\nSTTHR = *si->tx_buff.data++;\r\nsi->tx_buff.len -= 1;\r\n}\r\nif (si->tx_buff.len == 0) {\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += si->tx_buff.data - si->tx_buff.head;\r\nwhile ((STLSR & LSR_TEMT) == 0)\r\ncpu_relax();\r\nsi->last_oscr = readl_relaxed(OSCR);\r\nif (si->newspeed) {\r\npxa_irda_set_speed(si, si->newspeed);\r\nsi->newspeed = 0;\r\n} else {\r\nSTISR = IrSR_IR_RECEIVE_ON | IrSR_XMODE_PULSE_1_6;\r\nSTIER = IER_UUE | IER_RLSE | IER_RAVIE | IER_RTIOE;\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pxa_irda_fir_dma_rx_irq(int channel, void *data)\r\n{\r\nint dcsr = DCSR(channel);\r\nDCSR(channel) = dcsr & ~DCSR_RUN;\r\nprintk(KERN_DEBUG "pxa_ir: fir rx dma bus error %#x\n", dcsr);\r\n}\r\nstatic void pxa_irda_fir_dma_tx_irq(int channel, void *data)\r\n{\r\nstruct net_device *dev = data;\r\nstruct pxa_irda *si = netdev_priv(dev);\r\nint dcsr;\r\ndcsr = DCSR(channel);\r\nDCSR(channel) = dcsr & ~DCSR_RUN;\r\nif (dcsr & DCSR_ENDINTR) {\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += si->dma_tx_buff_len;\r\n} else {\r\ndev->stats.tx_errors++;\r\n}\r\nwhile (ICSR1 & ICSR1_TBY)\r\ncpu_relax();\r\nsi->last_oscr = readl_relaxed(OSCR);\r\nudelay(120);\r\nif (si->newspeed) {\r\npxa_irda_set_speed(si, si->newspeed);\r\nsi->newspeed = 0;\r\n} else {\r\nint i = 64;\r\nICCR0 = 0;\r\npxa_irda_fir_dma_rx_start(si);\r\nwhile ((ICSR1 & ICSR1_RNE) && i--)\r\n(void)ICDR;\r\nICCR0 = ICCR0_ITR | ICCR0_RXE;\r\nif (i < 0)\r\nprintk(KERN_ERR "pxa_ir: cannot clear Rx FIFO!\n");\r\n}\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void pxa_irda_fir_irq_eif(struct pxa_irda *si, struct net_device *dev, int icsr0)\r\n{\r\nunsigned int len, stat, data;\r\nlen = DTADR(si->rxdma) - si->dma_rx_buff_phy;\r\ndo {\r\nstat = ICSR1;\r\nrmb();\r\ndata = ICDR;\r\nif (stat & (ICSR1_CRE | ICSR1_ROR)) {\r\ndev->stats.rx_errors++;\r\nif (stat & ICSR1_CRE) {\r\nprintk(KERN_DEBUG "pxa_ir: fir receive CRC error\n");\r\ndev->stats.rx_crc_errors++;\r\n}\r\nif (stat & ICSR1_ROR) {\r\nprintk(KERN_DEBUG "pxa_ir: fir receive overrun\n");\r\ndev->stats.rx_over_errors++;\r\n}\r\n} else {\r\nsi->dma_rx_buff[len++] = data;\r\n}\r\nif (stat & ICSR1_EOF)\r\nbreak;\r\n} while (ICSR0 & ICSR0_EIF);\r\nif (stat & ICSR1_EOF) {\r\nstruct sk_buff *skb;\r\nif (icsr0 & ICSR0_FRE) {\r\nprintk(KERN_ERR "pxa_ir: dropping erroneous frame\n");\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb = alloc_skb(len+1,GFP_ATOMIC);\r\nif (!skb) {\r\nprintk(KERN_ERR "pxa_ir: fir out of memory for receive skb\n");\r\ndev->stats.rx_dropped++;\r\nreturn;\r\n}\r\nskb_reserve(skb, 1);\r\nskb_copy_to_linear_data(skb, si->dma_rx_buff, len);\r\nskb_put(skb, len);\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\nskb->protocol = htons(ETH_P_IRDA);\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\n}\r\n}\r\nstatic irqreturn_t pxa_irda_fir_irq(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct pxa_irda *si = netdev_priv(dev);\r\nint icsr0, i = 64;\r\nDCSR(si->rxdma) &= ~DCSR_RUN;\r\nsi->last_oscr = readl_relaxed(OSCR);\r\nicsr0 = ICSR0;\r\nif (icsr0 & (ICSR0_FRE | ICSR0_RAB)) {\r\nif (icsr0 & ICSR0_FRE) {\r\nprintk(KERN_DEBUG "pxa_ir: fir receive frame error\n");\r\ndev->stats.rx_frame_errors++;\r\n} else {\r\nprintk(KERN_DEBUG "pxa_ir: fir receive abort\n");\r\ndev->stats.rx_errors++;\r\n}\r\nICSR0 = icsr0 & (ICSR0_FRE | ICSR0_RAB);\r\n}\r\nif (icsr0 & ICSR0_EIF) {\r\npxa_irda_fir_irq_eif(si, dev, icsr0);\r\n}\r\nICCR0 = 0;\r\npxa_irda_fir_dma_rx_start(si);\r\nwhile ((ICSR1 & ICSR1_RNE) && i--)\r\n(void)ICDR;\r\nICCR0 = ICCR0_ITR | ICCR0_RXE;\r\nif (i < 0)\r\nprintk(KERN_ERR "pxa_ir: cannot clear Rx FIFO!\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pxa_irda_hard_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct pxa_irda *si = netdev_priv(dev);\r\nint speed = irda_get_next_speed(skb);\r\nif (speed != si->speed && speed != -1)\r\nsi->newspeed = speed;\r\nif (skb->len == 0) {\r\nif (si->newspeed) {\r\nsi->newspeed = 0;\r\npxa_irda_set_speed(si, speed);\r\n}\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nnetif_stop_queue(dev);\r\nif (!IS_FIR(si)) {\r\nsi->tx_buff.data = si->tx_buff.head;\r\nsi->tx_buff.len = async_wrap_skb(skb, si->tx_buff.data, si->tx_buff.truesize);\r\nSTIER = 0;\r\nSTISR = IrSR_IR_TRANSMIT_ON | IrSR_XMODE_PULSE_1_6;\r\nSTIER = IER_UUE | IER_TIE;\r\n} else {\r\nunsigned long mtt = irda_get_mtt(skb);\r\nsi->dma_tx_buff_len = skb->len;\r\nskb_copy_from_linear_data(skb, si->dma_tx_buff, skb->len);\r\nif (mtt)\r\nwhile ((unsigned)(readl_relaxed(OSCR) - si->last_oscr)/4 < mtt)\r\ncpu_relax();\r\nDCSR(si->rxdma) &= ~DCSR_RUN;\r\nICCR0 = 0;\r\npxa_irda_fir_dma_tx_start(si);\r\nICCR0 = ICCR0_ITR | ICCR0_TXE;\r\n}\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int pxa_irda_ioctl(struct net_device *dev, struct ifreq *ifreq, int cmd)\r\n{\r\nstruct if_irda_req *rq = (struct if_irda_req *)ifreq;\r\nstruct pxa_irda *si = netdev_priv(dev);\r\nint ret;\r\nswitch (cmd) {\r\ncase SIOCSBANDWIDTH:\r\nret = -EPERM;\r\nif (capable(CAP_NET_ADMIN)) {\r\nif (netif_running(dev)) {\r\nret = pxa_irda_set_speed(si,\r\nrq->ifr_baudrate);\r\n} else {\r\nprintk(KERN_INFO "pxa_ir: SIOCSBANDWIDTH: !netif_running\n");\r\nret = 0;\r\n}\r\n}\r\nbreak;\r\ncase SIOCSMEDIABUSY:\r\nret = -EPERM;\r\nif (capable(CAP_NET_ADMIN)) {\r\nirda_device_set_media_busy(dev, TRUE);\r\nret = 0;\r\n}\r\nbreak;\r\ncase SIOCGRECEIVING:\r\nret = 0;\r\nrq->ifr_receiving = IS_FIR(si) ? 0\r\n: si->rx_buff.state != OUTSIDE_FRAME;\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void pxa_irda_startup(struct pxa_irda *si)\r\n{\r\nSTIER = 0;\r\nSTMCR = MCR_OUT2;\r\nSTLCR = LCR_WLS0 | LCR_WLS1;\r\nSTFCR = FCR_TRFIFOE | FCR_ITL_32;\r\nICCR0 = 0;\r\nICCR2 = ICCR2_TXP | ICCR2_TRIG_32;\r\nDRCMR(17) = si->rxdma | DRCMR_MAPVLD;\r\nDRCMR(18) = si->txdma | DRCMR_MAPVLD;\r\nsi->speed = 4000000;\r\npxa_irda_set_speed(si, 9600);\r\nprintk(KERN_DEBUG "pxa_ir: irda startup\n");\r\n}\r\nstatic void pxa_irda_shutdown(struct pxa_irda *si)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nSTIER = 0;\r\nSTISR = 0;\r\nDCSR(si->txdma) &= ~DCSR_RUN;\r\nDCSR(si->rxdma) &= ~DCSR_RUN;\r\nICCR0 = 0;\r\npxa_irda_disable_clk(si);\r\nDRCMR(17) = 0;\r\nDRCMR(18) = 0;\r\nlocal_irq_restore(flags);\r\npxa_irda_set_mode(si, IR_OFF);\r\nprintk(KERN_DEBUG "pxa_ir: irda shutdown\n");\r\n}\r\nstatic int pxa_irda_start(struct net_device *dev)\r\n{\r\nstruct pxa_irda *si = netdev_priv(dev);\r\nint err;\r\nsi->speed = 9600;\r\nerr = request_irq(si->uart_irq, pxa_irda_sir_irq, 0, dev->name, dev);\r\nif (err)\r\ngoto err_irq1;\r\nerr = request_irq(si->icp_irq, pxa_irda_fir_irq, 0, dev->name, dev);\r\nif (err)\r\ngoto err_irq2;\r\ndisable_irq(si->uart_irq);\r\ndisable_irq(si->icp_irq);\r\nerr = -EBUSY;\r\nsi->rxdma = pxa_request_dma("FICP_RX",DMA_PRIO_LOW, pxa_irda_fir_dma_rx_irq, dev);\r\nif (si->rxdma < 0)\r\ngoto err_rx_dma;\r\nsi->txdma = pxa_request_dma("FICP_TX",DMA_PRIO_LOW, pxa_irda_fir_dma_tx_irq, dev);\r\nif (si->txdma < 0)\r\ngoto err_tx_dma;\r\nerr = -ENOMEM;\r\nsi->dma_rx_buff = dma_alloc_coherent(si->dev, IRDA_FRAME_SIZE_LIMIT,\r\n&si->dma_rx_buff_phy, GFP_KERNEL);\r\nif (!si->dma_rx_buff)\r\ngoto err_dma_rx_buff;\r\nsi->dma_tx_buff = dma_alloc_coherent(si->dev, IRDA_FRAME_SIZE_LIMIT,\r\n&si->dma_tx_buff_phy, GFP_KERNEL);\r\nif (!si->dma_tx_buff)\r\ngoto err_dma_tx_buff;\r\npxa_irda_startup(si);\r\nsi->irlap = irlap_open(dev, &si->qos, "pxa");\r\nerr = -ENOMEM;\r\nif (!si->irlap)\r\ngoto err_irlap;\r\nenable_irq(si->uart_irq);\r\nenable_irq(si->icp_irq);\r\nnetif_start_queue(dev);\r\nprintk(KERN_DEBUG "pxa_ir: irda driver opened\n");\r\nreturn 0;\r\nerr_irlap:\r\npxa_irda_shutdown(si);\r\ndma_free_coherent(si->dev, IRDA_FRAME_SIZE_LIMIT, si->dma_tx_buff, si->dma_tx_buff_phy);\r\nerr_dma_tx_buff:\r\ndma_free_coherent(si->dev, IRDA_FRAME_SIZE_LIMIT, si->dma_rx_buff, si->dma_rx_buff_phy);\r\nerr_dma_rx_buff:\r\npxa_free_dma(si->txdma);\r\nerr_tx_dma:\r\npxa_free_dma(si->rxdma);\r\nerr_rx_dma:\r\nfree_irq(si->icp_irq, dev);\r\nerr_irq2:\r\nfree_irq(si->uart_irq, dev);\r\nerr_irq1:\r\nreturn err;\r\n}\r\nstatic int pxa_irda_stop(struct net_device *dev)\r\n{\r\nstruct pxa_irda *si = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\npxa_irda_shutdown(si);\r\nif (si->irlap) {\r\nirlap_close(si->irlap);\r\nsi->irlap = NULL;\r\n}\r\nfree_irq(si->uart_irq, dev);\r\nfree_irq(si->icp_irq, dev);\r\npxa_free_dma(si->rxdma);\r\npxa_free_dma(si->txdma);\r\nif (si->dma_rx_buff)\r\ndma_free_coherent(si->dev, IRDA_FRAME_SIZE_LIMIT, si->dma_tx_buff, si->dma_tx_buff_phy);\r\nif (si->dma_tx_buff)\r\ndma_free_coherent(si->dev, IRDA_FRAME_SIZE_LIMIT, si->dma_rx_buff, si->dma_rx_buff_phy);\r\nprintk(KERN_DEBUG "pxa_ir: irda driver closed\n");\r\nreturn 0;\r\n}\r\nstatic int pxa_irda_suspend(struct platform_device *_dev, pm_message_t state)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(_dev);\r\nstruct pxa_irda *si;\r\nif (dev && netif_running(dev)) {\r\nsi = netdev_priv(dev);\r\nnetif_device_detach(dev);\r\npxa_irda_shutdown(si);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pxa_irda_resume(struct platform_device *_dev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(_dev);\r\nstruct pxa_irda *si;\r\nif (dev && netif_running(dev)) {\r\nsi = netdev_priv(dev);\r\npxa_irda_startup(si);\r\nnetif_device_attach(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pxa_irda_init_iobuf(iobuff_t *io, int size)\r\n{\r\nio->head = kmalloc(size, GFP_KERNEL | GFP_DMA);\r\nif (io->head != NULL) {\r\nio->truesize = size;\r\nio->in_frame = FALSE;\r\nio->state = OUTSIDE_FRAME;\r\nio->data = io->head;\r\n}\r\nreturn io->head ? 0 : -ENOMEM;\r\n}\r\nstatic int pxa_irda_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct pxa_irda *si;\r\nunsigned int baudrate_mask;\r\nint err;\r\nif (!pdev->dev.platform_data)\r\nreturn -ENODEV;\r\nerr = request_mem_region(__PREG(STUART), 0x24, "IrDA") ? 0 : -EBUSY;\r\nif (err)\r\ngoto err_mem_1;\r\nerr = request_mem_region(__PREG(FICP), 0x1c, "IrDA") ? 0 : -EBUSY;\r\nif (err)\r\ngoto err_mem_2;\r\ndev = alloc_irdadev(sizeof(struct pxa_irda));\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto err_mem_3;\r\n}\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nsi = netdev_priv(dev);\r\nsi->dev = &pdev->dev;\r\nsi->pdata = pdev->dev.platform_data;\r\nsi->uart_irq = platform_get_irq(pdev, 0);\r\nsi->icp_irq = platform_get_irq(pdev, 1);\r\nsi->sir_clk = clk_get(&pdev->dev, "UARTCLK");\r\nsi->fir_clk = clk_get(&pdev->dev, "FICPCLK");\r\nif (IS_ERR(si->sir_clk) || IS_ERR(si->fir_clk)) {\r\nerr = PTR_ERR(IS_ERR(si->sir_clk) ? si->sir_clk : si->fir_clk);\r\ngoto err_mem_4;\r\n}\r\nerr = pxa_irda_init_iobuf(&si->rx_buff, 14384);\r\nif (err)\r\ngoto err_mem_4;\r\nerr = pxa_irda_init_iobuf(&si->tx_buff, 4000);\r\nif (err)\r\ngoto err_mem_5;\r\nif (gpio_is_valid(si->pdata->gpio_pwdown)) {\r\nerr = gpio_request(si->pdata->gpio_pwdown, "IrDA switch");\r\nif (err)\r\ngoto err_startup;\r\nerr = gpio_direction_output(si->pdata->gpio_pwdown,\r\n!si->pdata->gpio_pwdown_inverted);\r\nif (err) {\r\ngpio_free(si->pdata->gpio_pwdown);\r\ngoto err_startup;\r\n}\r\n}\r\nif (si->pdata->startup) {\r\nerr = si->pdata->startup(si->dev);\r\nif (err)\r\ngoto err_startup;\r\n}\r\nif (gpio_is_valid(si->pdata->gpio_pwdown) && si->pdata->startup)\r\ndev_warn(si->dev, "gpio_pwdown and startup() both defined!\n");\r\ndev->netdev_ops = &pxa_irda_netdev_ops;\r\nirda_init_max_qos_capabilies(&si->qos);\r\nbaudrate_mask = 0;\r\nif (si->pdata->transceiver_cap & IR_SIRMODE)\r\nbaudrate_mask |= IR_9600|IR_19200|IR_38400|IR_57600|IR_115200;\r\nif (si->pdata->transceiver_cap & IR_FIRMODE)\r\nbaudrate_mask |= IR_4000000 << 8;\r\nsi->qos.baud_rate.bits &= baudrate_mask;\r\nsi->qos.min_turn_time.bits = 7;\r\nirda_qos_bits_to_value(&si->qos);\r\nerr = register_netdev(dev);\r\nif (err == 0)\r\nplatform_set_drvdata(pdev, dev);\r\nif (err) {\r\nif (si->pdata->shutdown)\r\nsi->pdata->shutdown(si->dev);\r\nerr_startup:\r\nkfree(si->tx_buff.head);\r\nerr_mem_5:\r\nkfree(si->rx_buff.head);\r\nerr_mem_4:\r\nif (si->sir_clk && !IS_ERR(si->sir_clk))\r\nclk_put(si->sir_clk);\r\nif (si->fir_clk && !IS_ERR(si->fir_clk))\r\nclk_put(si->fir_clk);\r\nfree_netdev(dev);\r\nerr_mem_3:\r\nrelease_mem_region(__PREG(FICP), 0x1c);\r\nerr_mem_2:\r\nrelease_mem_region(__PREG(STUART), 0x24);\r\n}\r\nerr_mem_1:\r\nreturn err;\r\n}\r\nstatic int pxa_irda_remove(struct platform_device *_dev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(_dev);\r\nif (dev) {\r\nstruct pxa_irda *si = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nif (gpio_is_valid(si->pdata->gpio_pwdown))\r\ngpio_free(si->pdata->gpio_pwdown);\r\nif (si->pdata->shutdown)\r\nsi->pdata->shutdown(si->dev);\r\nkfree(si->tx_buff.head);\r\nkfree(si->rx_buff.head);\r\nclk_put(si->fir_clk);\r\nclk_put(si->sir_clk);\r\nfree_netdev(dev);\r\n}\r\nrelease_mem_region(__PREG(STUART), 0x24);\r\nrelease_mem_region(__PREG(FICP), 0x1c);\r\nreturn 0;\r\n}
