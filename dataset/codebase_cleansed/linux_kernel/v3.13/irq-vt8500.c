static void vt8500_irq_mask(struct irq_data *d)\r\n{\r\nstruct vt8500_irq_data *priv = d->domain->host_data;\r\nvoid __iomem *base = priv->base;\r\nvoid __iomem *stat_reg = base + VT8500_ICIS + (d->hwirq < 32 ? 0 : 4);\r\nu8 edge, dctr;\r\nu32 status;\r\nedge = readb(base + VT8500_ICDC + d->hwirq) & VT8500_EDGE;\r\nif (edge) {\r\nstatus = readl(stat_reg);\r\nstatus |= (1 << (d->hwirq & 0x1f));\r\nwritel(status, stat_reg);\r\n} else {\r\ndctr = readb(base + VT8500_ICDC + d->hwirq);\r\ndctr &= ~VT8500_INT_ENABLE;\r\nwriteb(dctr, base + VT8500_ICDC + d->hwirq);\r\n}\r\n}\r\nstatic void vt8500_irq_unmask(struct irq_data *d)\r\n{\r\nstruct vt8500_irq_data *priv = d->domain->host_data;\r\nvoid __iomem *base = priv->base;\r\nu8 dctr;\r\ndctr = readb(base + VT8500_ICDC + d->hwirq);\r\ndctr |= VT8500_INT_ENABLE;\r\nwriteb(dctr, base + VT8500_ICDC + d->hwirq);\r\n}\r\nstatic int vt8500_irq_set_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nstruct vt8500_irq_data *priv = d->domain->host_data;\r\nvoid __iomem *base = priv->base;\r\nu8 dctr;\r\ndctr = readb(base + VT8500_ICDC + d->hwirq);\r\ndctr &= ~VT8500_EDGE;\r\nswitch (flow_type) {\r\ncase IRQF_TRIGGER_LOW:\r\nreturn -EINVAL;\r\ncase IRQF_TRIGGER_HIGH:\r\ndctr |= VT8500_TRIGGER_HIGH;\r\n__irq_set_handler_locked(d->irq, handle_level_irq);\r\nbreak;\r\ncase IRQF_TRIGGER_FALLING:\r\ndctr |= VT8500_TRIGGER_FALLING;\r\n__irq_set_handler_locked(d->irq, handle_edge_irq);\r\nbreak;\r\ncase IRQF_TRIGGER_RISING:\r\ndctr |= VT8500_TRIGGER_RISING;\r\n__irq_set_handler_locked(d->irq, handle_edge_irq);\r\nbreak;\r\n}\r\nwriteb(dctr, base + VT8500_ICDC + d->hwirq);\r\nreturn 0;\r\n}\r\nstatic void __init vt8500_init_irq_hw(void __iomem *base)\r\n{\r\nu32 i;\r\nwritel(ICPC_ROTATE, base + VT8500_ICPC_IRQ);\r\nwritel(0x00, base + VT8500_ICPC_FIQ);\r\nfor (i = 0; i < 64; i++)\r\nwriteb(VT8500_INT_DISABLE | ICDC_IRQ, base + VT8500_ICDC + i);\r\n}\r\nstatic int vt8500_irq_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nirq_set_chip_and_handler(virq, &vt8500_irq_chip, handle_level_irq);\r\nset_irq_flags(virq, IRQF_VALID);\r\nreturn 0;\r\n}\r\nstatic asmlinkage\r\nvoid __exception_irq_entry vt8500_handle_irq(struct pt_regs *regs)\r\n{\r\nu32 stat, i;\r\nint irqnr, virq;\r\nvoid __iomem *base;\r\nfor (i=0; i<active_cnt; i++) {\r\nbase = intc[i].base;\r\nirqnr = readl_relaxed(base) & 0x3F;\r\nif (irqnr == 63) {\r\nstat = readl_relaxed(base + VT8500_ICIS + 4);\r\nif (!(stat & BIT(31)))\r\ncontinue;\r\n}\r\nvirq = irq_find_mapping(intc[i].domain, irqnr);\r\nhandle_IRQ(virq, regs);\r\n}\r\n}\r\nstatic int __init vt8500_irq_init(struct device_node *node,\r\nstruct device_node *parent)\r\n{\r\nint irq, i;\r\nstruct device_node *np = node;\r\nif (active_cnt == VT8500_INTC_MAX) {\r\npr_err("%s: Interrupt controllers > VT8500_INTC_MAX\n",\r\n__func__);\r\ngoto out;\r\n}\r\nintc[active_cnt].base = of_iomap(np, 0);\r\nintc[active_cnt].domain = irq_domain_add_linear(node, 64,\r\n&vt8500_irq_domain_ops, &intc[active_cnt]);\r\nif (!intc[active_cnt].base) {\r\npr_err("%s: Unable to map IO memory\n", __func__);\r\ngoto out;\r\n}\r\nif (!intc[active_cnt].domain) {\r\npr_err("%s: Unable to add irq domain!\n", __func__);\r\ngoto out;\r\n}\r\nset_handle_irq(vt8500_handle_irq);\r\nvt8500_init_irq_hw(intc[active_cnt].base);\r\npr_info("vt8500-irq: Added interrupt controller\n");\r\nactive_cnt++;\r\nif (of_irq_count(np) != 0) {\r\nif (of_irq_count(np) != 8) {\r\npr_err("%s: Incorrect IRQ map for slaved controller\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nirq = irq_of_parse_and_map(np, i);\r\nenable_irq(irq);\r\n}\r\npr_info("vt8500-irq: Enabled slave->parent interrupts\n");\r\n}\r\nout:\r\nreturn 0;\r\n}
