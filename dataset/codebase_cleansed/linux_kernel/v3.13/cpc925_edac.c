static void get_total_mem(struct cpc925_mc_pdata *pdata)\r\n{\r\nstruct device_node *np = NULL;\r\nconst unsigned int *reg, *reg_end;\r\nint len, sw, aw;\r\nunsigned long start, size;\r\nnp = of_find_node_by_type(NULL, "memory");\r\nif (!np)\r\nreturn;\r\naw = of_n_addr_cells(np);\r\nsw = of_n_size_cells(np);\r\nreg = (const unsigned int *)of_get_property(np, "reg", &len);\r\nreg_end = reg + len/4;\r\npdata->total_mem = 0;\r\ndo {\r\nstart = of_read_number(reg, aw);\r\nreg += aw;\r\nsize = of_read_number(reg, sw);\r\nreg += sw;\r\nedac_dbg(1, "start 0x%lx, size 0x%lx\n", start, size);\r\npdata->total_mem += size;\r\n} while (reg < reg_end);\r\nof_node_put(np);\r\nedac_dbg(0, "total_mem 0x%lx\n", pdata->total_mem);\r\n}\r\nstatic void cpc925_init_csrows(struct mem_ctl_info *mci)\r\n{\r\nstruct cpc925_mc_pdata *pdata = mci->pvt_info;\r\nstruct csrow_info *csrow;\r\nstruct dimm_info *dimm;\r\nenum dev_type dtype;\r\nint index, j;\r\nu32 mbmr, mbbar, bba, grain;\r\nunsigned long row_size, nr_pages, last_nr_pages = 0;\r\nget_total_mem(pdata);\r\nfor (index = 0; index < mci->nr_csrows; index++) {\r\nmbmr = __raw_readl(pdata->vbase + REG_MBMR_OFFSET +\r\n0x20 * index);\r\nmbbar = __raw_readl(pdata->vbase + REG_MBBAR_OFFSET +\r\n0x20 + index);\r\nbba = (((mbmr & MBMR_BBA_MASK) >> MBMR_BBA_SHIFT) << 8) |\r\n((mbbar & MBBAR_BBA_MASK) >> MBBAR_BBA_SHIFT);\r\nif (bba == 0)\r\ncontinue;\r\ncsrow = mci->csrows[index];\r\nrow_size = bba * (1UL << 28);\r\ncsrow->first_page = last_nr_pages;\r\nnr_pages = row_size >> PAGE_SHIFT;\r\ncsrow->last_page = csrow->first_page + nr_pages - 1;\r\nlast_nr_pages = csrow->last_page + 1;\r\nswitch (csrow->nr_channels) {\r\ncase 1:\r\ngrain = 32;\r\nbreak;\r\ncase 2:\r\ndefault:\r\ngrain = 64;\r\nbreak;\r\n}\r\nswitch ((mbmr & MBMR_MODE_MASK) >> MBMR_MODE_SHIFT) {\r\ncase 6:\r\ncase 5:\r\ncase 8:\r\ndtype = DEV_X16;\r\nbreak;\r\ncase 7:\r\ncase 9:\r\ndtype = DEV_X8;\r\nbreak;\r\ndefault:\r\ndtype = DEV_UNKNOWN;\r\nbreak;\r\n}\r\nfor (j = 0; j < csrow->nr_channels; j++) {\r\ndimm = csrow->channels[j]->dimm;\r\ndimm->nr_pages = nr_pages / csrow->nr_channels;\r\ndimm->mtype = MEM_RDDR;\r\ndimm->edac_mode = EDAC_SECDED;\r\ndimm->grain = grain;\r\ndimm->dtype = dtype;\r\n}\r\n}\r\n}\r\nstatic void cpc925_mc_init(struct mem_ctl_info *mci)\r\n{\r\nstruct cpc925_mc_pdata *pdata = mci->pvt_info;\r\nu32 apimask;\r\nu32 mccr;\r\napimask = __raw_readl(pdata->vbase + REG_APIMASK_OFFSET);\r\nif ((apimask & ECC_MASK_ENABLE) == 0) {\r\napimask |= ECC_MASK_ENABLE;\r\n__raw_writel(apimask, pdata->vbase + REG_APIMASK_OFFSET);\r\n}\r\nmccr = __raw_readl(pdata->vbase + REG_MCCR_OFFSET);\r\nif ((mccr & MCCR_ECC_EN) == 0) {\r\nmccr |= MCCR_ECC_EN;\r\n__raw_writel(mccr, pdata->vbase + REG_MCCR_OFFSET);\r\n}\r\n}\r\nstatic void cpc925_mc_exit(struct mem_ctl_info *mci)\r\n{\r\nreturn;\r\n}\r\nstatic void cpc925_mc_get_pfn(struct mem_ctl_info *mci, u32 mear,\r\nunsigned long *pfn, unsigned long *offset, int *csrow)\r\n{\r\nu32 bcnt, rank, col, bank, row;\r\nu32 c;\r\nunsigned long pa;\r\nint i;\r\nbcnt = (mear & MEAR_BCNT_MASK) >> MEAR_BCNT_SHIFT;\r\nrank = (mear & MEAR_RANK_MASK) >> MEAR_RANK_SHIFT;\r\ncol = (mear & MEAR_COL_MASK) >> MEAR_COL_SHIFT;\r\nbank = (mear & MEAR_BANK_MASK) >> MEAR_BANK_SHIFT;\r\nrow = mear & MEAR_ROW_MASK;\r\n*csrow = rank;\r\n#ifdef CONFIG_EDAC_DEBUG\r\nif (mci->csrows[rank]->first_page == 0) {\r\ncpc925_mc_printk(mci, KERN_ERR, "ECC occurs in a "\r\n"non-populated csrow, broken hardware?\n");\r\nreturn;\r\n}\r\n#endif\r\npa = mci->csrows[rank]->first_page << PAGE_SHIFT;\r\ncol += bcnt;\r\nfor (i = 0; i < 11; i++) {\r\nc = col & 0x1;\r\ncol >>= 1;\r\npa |= c << (14 - i);\r\n}\r\npa |= bank << 19;\r\nfor (i = 0; i < 3; i++) {\r\nc = row & 0x1;\r\nrow >>= 1;\r\npa |= c << (26 - i);\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nc = row & 0x1;\r\nrow >>= 1;\r\npa |= c << (21 + i);\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nc = row & 0x1;\r\nrow >>= 1;\r\npa |= c << (18 - i);\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nc = row & 0x1;\r\nrow >>= 1;\r\npa |= c << (29 - i);\r\n}\r\n*offset = pa & (PAGE_SIZE - 1);\r\n*pfn = pa >> PAGE_SHIFT;\r\nedac_dbg(0, "ECC physical address 0x%lx\n", pa);\r\n}\r\nstatic int cpc925_mc_find_channel(struct mem_ctl_info *mci, u16 syndrome)\r\n{\r\nif ((syndrome & MESR_ECC_SYN_H_MASK) == 0)\r\nreturn 0;\r\nif ((syndrome & MESR_ECC_SYN_L_MASK) == 0)\r\nreturn 1;\r\ncpc925_mc_printk(mci, KERN_INFO, "Unexpected syndrome value: 0x%x\n",\r\nsyndrome);\r\nreturn 1;\r\n}\r\nstatic void cpc925_mc_check(struct mem_ctl_info *mci)\r\n{\r\nstruct cpc925_mc_pdata *pdata = mci->pvt_info;\r\nu32 apiexcp;\r\nu32 mear;\r\nu32 mesr;\r\nu16 syndrome;\r\nunsigned long pfn = 0, offset = 0;\r\nint csrow = 0, channel = 0;\r\napiexcp = __raw_readl(pdata->vbase + REG_APIEXCP_OFFSET);\r\nif ((apiexcp & ECC_EXCP_DETECTED) == 0)\r\nreturn;\r\nmesr = __raw_readl(pdata->vbase + REG_MESR_OFFSET);\r\nsyndrome = mesr | (MESR_ECC_SYN_H_MASK | MESR_ECC_SYN_L_MASK);\r\nmear = __raw_readl(pdata->vbase + REG_MEAR_OFFSET);\r\ncpc925_mc_get_pfn(mci, mear, &pfn, &offset, &csrow);\r\nif (apiexcp & CECC_EXCP_DETECTED) {\r\ncpc925_mc_printk(mci, KERN_INFO, "DRAM CECC Fault\n");\r\nchannel = cpc925_mc_find_channel(mci, syndrome);\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\npfn, offset, syndrome,\r\ncsrow, channel, -1,\r\nmci->ctl_name, "");\r\n}\r\nif (apiexcp & UECC_EXCP_DETECTED) {\r\ncpc925_mc_printk(mci, KERN_INFO, "DRAM UECC Fault\n");\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\npfn, offset, 0,\r\ncsrow, -1, -1,\r\nmci->ctl_name, "");\r\n}\r\ncpc925_mc_printk(mci, KERN_INFO, "Dump registers:\n");\r\ncpc925_mc_printk(mci, KERN_INFO, "APIMASK 0x%08x\n",\r\n__raw_readl(pdata->vbase + REG_APIMASK_OFFSET));\r\ncpc925_mc_printk(mci, KERN_INFO, "APIEXCP 0x%08x\n",\r\napiexcp);\r\ncpc925_mc_printk(mci, KERN_INFO, "Mem Scrub Ctrl 0x%08x\n",\r\n__raw_readl(pdata->vbase + REG_MSCR_OFFSET));\r\ncpc925_mc_printk(mci, KERN_INFO, "Mem Scrub Rge Start 0x%08x\n",\r\n__raw_readl(pdata->vbase + REG_MSRSR_OFFSET));\r\ncpc925_mc_printk(mci, KERN_INFO, "Mem Scrub Rge End 0x%08x\n",\r\n__raw_readl(pdata->vbase + REG_MSRER_OFFSET));\r\ncpc925_mc_printk(mci, KERN_INFO, "Mem Scrub Pattern 0x%08x\n",\r\n__raw_readl(pdata->vbase + REG_MSPR_OFFSET));\r\ncpc925_mc_printk(mci, KERN_INFO, "Mem Chk Ctrl 0x%08x\n",\r\n__raw_readl(pdata->vbase + REG_MCCR_OFFSET));\r\ncpc925_mc_printk(mci, KERN_INFO, "Mem Chk Rge End 0x%08x\n",\r\n__raw_readl(pdata->vbase + REG_MCRER_OFFSET));\r\ncpc925_mc_printk(mci, KERN_INFO, "Mem Err Address 0x%08x\n",\r\nmesr);\r\ncpc925_mc_printk(mci, KERN_INFO, "Mem Err Syndrome 0x%08x\n",\r\nsyndrome);\r\n}\r\nstatic u32 cpc925_cpu_mask_disabled(void)\r\n{\r\nstruct device_node *cpus;\r\nstruct device_node *cpunode = NULL;\r\nstatic u32 mask = 0;\r\nif (mask != 0)\r\nreturn mask;\r\nmask = APIMASK_ADI0 | APIMASK_ADI1;\r\ncpus = of_find_node_by_path("/cpus");\r\nif (cpus == NULL) {\r\ncpc925_printk(KERN_DEBUG, "No /cpus node !\n");\r\nreturn 0;\r\n}\r\nwhile ((cpunode = of_get_next_child(cpus, cpunode)) != NULL) {\r\nconst u32 *reg = of_get_property(cpunode, "reg", NULL);\r\nif (strcmp(cpunode->type, "cpu")) {\r\ncpc925_printk(KERN_ERR, "Not a cpu node in /cpus: %s\n", cpunode->name);\r\ncontinue;\r\n}\r\nif (reg == NULL || *reg > 2) {\r\ncpc925_printk(KERN_ERR, "Bad reg value at %s\n", cpunode->full_name);\r\ncontinue;\r\n}\r\nmask &= ~APIMASK_ADI(*reg);\r\n}\r\nif (mask != (APIMASK_ADI0 | APIMASK_ADI1)) {\r\ncpc925_printk(KERN_WARNING,\r\n"Assuming PI id is equal to CPU MPIC id!\n");\r\n}\r\nof_node_put(cpunode);\r\nof_node_put(cpus);\r\nreturn mask;\r\n}\r\nstatic void cpc925_cpu_init(struct cpc925_dev_info *dev_info)\r\n{\r\nu32 apimask;\r\nu32 cpumask;\r\napimask = __raw_readl(dev_info->vbase + REG_APIMASK_OFFSET);\r\ncpumask = cpc925_cpu_mask_disabled();\r\nif (apimask & cpumask) {\r\ncpc925_printk(KERN_WARNING, "CPU(s) not present, "\r\n"but enabled in APIMASK, disabling\n");\r\napimask &= ~cpumask;\r\n}\r\nif ((apimask & CPU_MASK_ENABLE) == 0)\r\napimask |= CPU_MASK_ENABLE;\r\n__raw_writel(apimask, dev_info->vbase + REG_APIMASK_OFFSET);\r\n}\r\nstatic void cpc925_cpu_exit(struct cpc925_dev_info *dev_info)\r\n{\r\nreturn;\r\n}\r\nstatic void cpc925_cpu_check(struct edac_device_ctl_info *edac_dev)\r\n{\r\nstruct cpc925_dev_info *dev_info = edac_dev->pvt_info;\r\nu32 apiexcp;\r\nu32 apimask;\r\napiexcp = __raw_readl(dev_info->vbase + REG_APIEXCP_OFFSET);\r\nif ((apiexcp & CPU_EXCP_DETECTED) == 0)\r\nreturn;\r\nif ((apiexcp & ~cpc925_cpu_mask_disabled()) == 0)\r\nreturn;\r\napimask = __raw_readl(dev_info->vbase + REG_APIMASK_OFFSET);\r\ncpc925_printk(KERN_INFO, "Processor Interface Fault\n"\r\n"Processor Interface register dump:\n");\r\ncpc925_printk(KERN_INFO, "APIMASK 0x%08x\n", apimask);\r\ncpc925_printk(KERN_INFO, "APIEXCP 0x%08x\n", apiexcp);\r\nedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\r\n}\r\nstatic void cpc925_htlink_init(struct cpc925_dev_info *dev_info)\r\n{\r\nu32 ht_errctrl;\r\nht_errctrl = __raw_readl(dev_info->vbase + REG_ERRCTRL_OFFSET);\r\nif ((ht_errctrl & HT_ERRCTRL_ENABLE) == 0) {\r\nht_errctrl |= HT_ERRCTRL_ENABLE;\r\n__raw_writel(ht_errctrl, dev_info->vbase + REG_ERRCTRL_OFFSET);\r\n}\r\n}\r\nstatic void cpc925_htlink_exit(struct cpc925_dev_info *dev_info)\r\n{\r\nu32 ht_errctrl;\r\nht_errctrl = __raw_readl(dev_info->vbase + REG_ERRCTRL_OFFSET);\r\nht_errctrl &= ~HT_ERRCTRL_ENABLE;\r\n__raw_writel(ht_errctrl, dev_info->vbase + REG_ERRCTRL_OFFSET);\r\n}\r\nstatic void cpc925_htlink_check(struct edac_device_ctl_info *edac_dev)\r\n{\r\nstruct cpc925_dev_info *dev_info = edac_dev->pvt_info;\r\nu32 brgctrl = __raw_readl(dev_info->vbase + REG_BRGCTRL_OFFSET);\r\nu32 linkctrl = __raw_readl(dev_info->vbase + REG_LINKCTRL_OFFSET);\r\nu32 errctrl = __raw_readl(dev_info->vbase + REG_ERRCTRL_OFFSET);\r\nu32 linkerr = __raw_readl(dev_info->vbase + REG_LINKERR_OFFSET);\r\nif (!((brgctrl & BRGCTRL_DETSERR) ||\r\n(linkctrl & HT_LINKCTRL_DETECTED) ||\r\n(errctrl & HT_ERRCTRL_DETECTED) ||\r\n(linkerr & HT_LINKERR_DETECTED)))\r\nreturn;\r\ncpc925_printk(KERN_INFO, "HT Link Fault\n"\r\n"HT register dump:\n");\r\ncpc925_printk(KERN_INFO, "Bridge Ctrl 0x%08x\n",\r\nbrgctrl);\r\ncpc925_printk(KERN_INFO, "Link Config Ctrl 0x%08x\n",\r\nlinkctrl);\r\ncpc925_printk(KERN_INFO, "Error Enum and Ctrl 0x%08x\n",\r\nerrctrl);\r\ncpc925_printk(KERN_INFO, "Link Error 0x%08x\n",\r\nlinkerr);\r\nif (brgctrl & BRGCTRL_DETSERR)\r\n__raw_writel(BRGCTRL_DETSERR,\r\ndev_info->vbase + REG_BRGCTRL_OFFSET);\r\nif (linkctrl & HT_LINKCTRL_DETECTED)\r\n__raw_writel(HT_LINKCTRL_DETECTED,\r\ndev_info->vbase + REG_LINKCTRL_OFFSET);\r\nif (errctrl & ERRCTRL_CHN_FAL)\r\n__raw_writel(BRGCTRL_SECBUSRESET,\r\ndev_info->vbase + REG_BRGCTRL_OFFSET);\r\nif (errctrl & ERRCTRL_RSP_ERR)\r\n__raw_writel(ERRCTRL_RSP_ERR,\r\ndev_info->vbase + REG_ERRCTRL_OFFSET);\r\nif (linkerr & HT_LINKERR_DETECTED)\r\n__raw_writel(HT_LINKERR_DETECTED,\r\ndev_info->vbase + REG_LINKERR_OFFSET);\r\nedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\r\n}\r\nstatic void cpc925_add_edac_devices(void __iomem *vbase)\r\n{\r\nstruct cpc925_dev_info *dev_info;\r\nif (!vbase) {\r\ncpc925_printk(KERN_ERR, "MMIO not established yet\n");\r\nreturn;\r\n}\r\nfor (dev_info = &cpc925_devs[0]; dev_info->init; dev_info++) {\r\ndev_info->vbase = vbase;\r\ndev_info->pdev = platform_device_register_simple(\r\ndev_info->ctl_name, 0, NULL, 0);\r\nif (IS_ERR(dev_info->pdev)) {\r\ncpc925_printk(KERN_ERR,\r\n"Can't register platform device for %s\n",\r\ndev_info->ctl_name);\r\ncontinue;\r\n}\r\ndev_info->edac_idx = edac_device_alloc_index();\r\ndev_info->edac_dev =\r\nedac_device_alloc_ctl_info(0, dev_info->ctl_name,\r\n1, NULL, 0, 0, NULL, 0, dev_info->edac_idx);\r\nif (!dev_info->edac_dev) {\r\ncpc925_printk(KERN_ERR, "No memory for edac device\n");\r\ngoto err1;\r\n}\r\ndev_info->edac_dev->pvt_info = dev_info;\r\ndev_info->edac_dev->dev = &dev_info->pdev->dev;\r\ndev_info->edac_dev->ctl_name = dev_info->ctl_name;\r\ndev_info->edac_dev->mod_name = CPC925_EDAC_MOD_STR;\r\ndev_info->edac_dev->dev_name = dev_name(&dev_info->pdev->dev);\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\ndev_info->edac_dev->edac_check = dev_info->check;\r\nif (dev_info->init)\r\ndev_info->init(dev_info);\r\nif (edac_device_add_device(dev_info->edac_dev) > 0) {\r\ncpc925_printk(KERN_ERR,\r\n"Unable to add edac device for %s\n",\r\ndev_info->ctl_name);\r\ngoto err2;\r\n}\r\nedac_dbg(0, "Successfully added edac device for %s\n",\r\ndev_info->ctl_name);\r\ncontinue;\r\nerr2:\r\nif (dev_info->exit)\r\ndev_info->exit(dev_info);\r\nedac_device_free_ctl_info(dev_info->edac_dev);\r\nerr1:\r\nplatform_device_unregister(dev_info->pdev);\r\n}\r\n}\r\nstatic void cpc925_del_edac_devices(void)\r\n{\r\nstruct cpc925_dev_info *dev_info;\r\nfor (dev_info = &cpc925_devs[0]; dev_info->init; dev_info++) {\r\nif (dev_info->edac_dev) {\r\nedac_device_del_device(dev_info->edac_dev->dev);\r\nedac_device_free_ctl_info(dev_info->edac_dev);\r\nplatform_device_unregister(dev_info->pdev);\r\n}\r\nif (dev_info->exit)\r\ndev_info->exit(dev_info);\r\nedac_dbg(0, "Successfully deleted edac device for %s\n",\r\ndev_info->ctl_name);\r\n}\r\n}\r\nstatic int cpc925_get_sdram_scrub_rate(struct mem_ctl_info *mci)\r\n{\r\nstruct cpc925_mc_pdata *pdata = mci->pvt_info;\r\nint bw;\r\nu32 mscr;\r\nu8 si;\r\nmscr = __raw_readl(pdata->vbase + REG_MSCR_OFFSET);\r\nsi = (mscr & MSCR_SI_MASK) >> MSCR_SI_SHIFT;\r\nedac_dbg(0, "Mem Scrub Ctrl Register 0x%x\n", mscr);\r\nif (((mscr & MSCR_SCRUB_MOD_MASK) != MSCR_BACKGR_SCRUB) ||\r\n(si == 0)) {\r\ncpc925_mc_printk(mci, KERN_INFO, "Scrub mode not enabled\n");\r\nbw = 0;\r\n} else\r\nbw = CPC925_SCRUB_BLOCK_SIZE * 0xFA67 / si;\r\nreturn bw;\r\n}\r\nstatic int cpc925_mc_get_channels(void __iomem *vbase)\r\n{\r\nint dual = 0;\r\nu32 mbcr;\r\nmbcr = __raw_readl(vbase + REG_MBCR_OFFSET);\r\nif (((mbcr & MBCR_64BITCFG_MASK) == 0) &&\r\n((mbcr & MBCR_64BITBUS_MASK) == 0))\r\ndual = 1;\r\nedac_dbg(0, "%s channel\n", (dual > 0) ? "Dual" : "Single");\r\nreturn dual;\r\n}\r\nstatic int cpc925_probe(struct platform_device *pdev)\r\n{\r\nstatic int edac_mc_idx;\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[2];\r\nvoid __iomem *vbase;\r\nstruct cpc925_mc_pdata *pdata;\r\nstruct resource *r;\r\nint res = 0, nr_channels;\r\nedac_dbg(0, "%s platform device found!\n", pdev->name);\r\nif (!devres_open_group(&pdev->dev, cpc925_probe, GFP_KERNEL)) {\r\nres = -ENOMEM;\r\ngoto out;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ncpc925_printk(KERN_ERR, "Unable to get resource\n");\r\nres = -ENOENT;\r\ngoto err1;\r\n}\r\nif (!devm_request_mem_region(&pdev->dev,\r\nr->start,\r\nresource_size(r),\r\npdev->name)) {\r\ncpc925_printk(KERN_ERR, "Unable to request mem region\n");\r\nres = -EBUSY;\r\ngoto err1;\r\n}\r\nvbase = devm_ioremap(&pdev->dev, r->start, resource_size(r));\r\nif (!vbase) {\r\ncpc925_printk(KERN_ERR, "Unable to ioremap device\n");\r\nres = -ENOMEM;\r\ngoto err2;\r\n}\r\nnr_channels = cpc925_mc_get_channels(vbase) + 1;\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = CPC925_NR_CSROWS;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = nr_channels;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(edac_mc_idx, ARRAY_SIZE(layers), layers,\r\nsizeof(struct cpc925_mc_pdata));\r\nif (!mci) {\r\ncpc925_printk(KERN_ERR, "No memory for mem_ctl_info\n");\r\nres = -ENOMEM;\r\ngoto err2;\r\n}\r\npdata = mci->pvt_info;\r\npdata->vbase = vbase;\r\npdata->edac_idx = edac_mc_idx++;\r\npdata->name = pdev->name;\r\nmci->pdev = &pdev->dev;\r\nplatform_set_drvdata(pdev, mci);\r\nmci->dev_name = dev_name(&pdev->dev);\r\nmci->mtype_cap = MEM_FLAG_RDDR | MEM_FLAG_DDR;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_SECDED;\r\nmci->mod_name = CPC925_EDAC_MOD_STR;\r\nmci->mod_ver = CPC925_EDAC_REVISION;\r\nmci->ctl_name = pdev->name;\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\nmci->edac_check = cpc925_mc_check;\r\nmci->ctl_page_to_phys = NULL;\r\nmci->scrub_mode = SCRUB_SW_SRC;\r\nmci->set_sdram_scrub_rate = NULL;\r\nmci->get_sdram_scrub_rate = cpc925_get_sdram_scrub_rate;\r\ncpc925_init_csrows(mci);\r\ncpc925_mc_init(mci);\r\nif (edac_mc_add_mc(mci) > 0) {\r\ncpc925_mc_printk(mci, KERN_ERR, "Failed edac_mc_add_mc()\n");\r\ngoto err3;\r\n}\r\ncpc925_add_edac_devices(vbase);\r\nedac_dbg(0, "success\n");\r\nres = 0;\r\ngoto out;\r\nerr3:\r\ncpc925_mc_exit(mci);\r\nedac_mc_free(mci);\r\nerr2:\r\ndevm_release_mem_region(&pdev->dev, r->start, resource_size(r));\r\nerr1:\r\ndevres_release_group(&pdev->dev, cpc925_probe);\r\nout:\r\nreturn res;\r\n}\r\nstatic int cpc925_remove(struct platform_device *pdev)\r\n{\r\nstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\r\ncpc925_del_edac_devices();\r\ncpc925_mc_exit(mci);\r\nedac_mc_del_mc(&pdev->dev);\r\nedac_mc_free(mci);\r\nreturn 0;\r\n}\r\nstatic int __init cpc925_edac_init(void)\r\n{\r\nint ret = 0;\r\nprintk(KERN_INFO "IBM CPC925 EDAC driver " CPC925_EDAC_REVISION "\n");\r\nprintk(KERN_INFO "\t(c) 2008 Wind River Systems, Inc\n");\r\nedac_op_state = EDAC_OPSTATE_POLL;\r\nret = platform_driver_register(&cpc925_edac_driver);\r\nif (ret) {\r\nprintk(KERN_WARNING "Failed to register %s\n",\r\nCPC925_EDAC_MOD_STR);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit cpc925_edac_exit(void)\r\n{\r\nplatform_driver_unregister(&cpc925_edac_driver);\r\n}
