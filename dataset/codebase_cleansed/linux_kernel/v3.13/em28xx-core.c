int em28xx_read_reg_req_len(struct em28xx *dev, u8 req, u16 reg,\r\nchar *buf, int len)\r\n{\r\nint ret;\r\nint pipe = usb_rcvctrlpipe(dev->udev, 0);\r\nif (dev->disconnected)\r\nreturn -ENODEV;\r\nif (len > URB_MAX_CTRL_SIZE)\r\nreturn -EINVAL;\r\nif (reg_debug) {\r\nprintk(KERN_DEBUG "(pipe 0x%08x): "\r\n"IN: %02x %02x %02x %02x %02x %02x %02x %02x ",\r\npipe,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nreq, 0, 0,\r\nreg & 0xff, reg >> 8,\r\nlen & 0xff, len >> 8);\r\n}\r\nmutex_lock(&dev->ctrl_urb_lock);\r\nret = usb_control_msg(dev->udev, pipe, req,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x0000, reg, dev->urb_buf, len, HZ);\r\nif (ret < 0) {\r\nif (reg_debug)\r\nprintk(" failed!\n");\r\nmutex_unlock(&dev->ctrl_urb_lock);\r\nreturn usb_translate_errors(ret);\r\n}\r\nif (len)\r\nmemcpy(buf, dev->urb_buf, len);\r\nmutex_unlock(&dev->ctrl_urb_lock);\r\nif (reg_debug) {\r\nint byte;\r\nprintk("<<<");\r\nfor (byte = 0; byte < len; byte++)\r\nprintk(" %02x", (unsigned char)buf[byte]);\r\nprintk("\n");\r\n}\r\nreturn ret;\r\n}\r\nint em28xx_read_reg_req(struct em28xx *dev, u8 req, u16 reg)\r\n{\r\nint ret;\r\nu8 val;\r\nret = em28xx_read_reg_req_len(dev, req, reg, &val, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn val;\r\n}\r\nint em28xx_read_reg(struct em28xx *dev, u16 reg)\r\n{\r\nreturn em28xx_read_reg_req(dev, USB_REQ_GET_STATUS, reg);\r\n}\r\nint em28xx_write_regs_req(struct em28xx *dev, u8 req, u16 reg, char *buf,\r\nint len)\r\n{\r\nint ret;\r\nint pipe = usb_sndctrlpipe(dev->udev, 0);\r\nif (dev->disconnected)\r\nreturn -ENODEV;\r\nif ((len < 1) || (len > URB_MAX_CTRL_SIZE))\r\nreturn -EINVAL;\r\nif (reg_debug) {\r\nint byte;\r\nprintk(KERN_DEBUG "(pipe 0x%08x): "\r\n"OUT: %02x %02x %02x %02x %02x %02x %02x %02x >>>",\r\npipe,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nreq, 0, 0,\r\nreg & 0xff, reg >> 8,\r\nlen & 0xff, len >> 8);\r\nfor (byte = 0; byte < len; byte++)\r\nprintk(" %02x", (unsigned char)buf[byte]);\r\nprintk("\n");\r\n}\r\nmutex_lock(&dev->ctrl_urb_lock);\r\nmemcpy(dev->urb_buf, buf, len);\r\nret = usb_control_msg(dev->udev, pipe, req,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x0000, reg, dev->urb_buf, len, HZ);\r\nmutex_unlock(&dev->ctrl_urb_lock);\r\nif (ret < 0)\r\nreturn usb_translate_errors(ret);\r\nif (dev->wait_after_write)\r\nmsleep(dev->wait_after_write);\r\nreturn ret;\r\n}\r\nint em28xx_write_regs(struct em28xx *dev, u16 reg, char *buf, int len)\r\n{\r\nreturn em28xx_write_regs_req(dev, USB_REQ_GET_STATUS, reg, buf, len);\r\n}\r\nint em28xx_write_reg(struct em28xx *dev, u16 reg, u8 val)\r\n{\r\nreturn em28xx_write_regs(dev, reg, &val, 1);\r\n}\r\nint em28xx_write_reg_bits(struct em28xx *dev, u16 reg, u8 val,\r\nu8 bitmask)\r\n{\r\nint oldval;\r\nu8 newval;\r\noldval = em28xx_read_reg(dev, reg);\r\nif (oldval < 0)\r\nreturn oldval;\r\nnewval = (((u8) oldval) & ~bitmask) | (val & bitmask);\r\nreturn em28xx_write_regs(dev, reg, &newval, 1);\r\n}\r\nstatic int em28xx_is_ac97_ready(struct em28xx *dev)\r\n{\r\nint ret, i;\r\nfor (i = 0; i < 10; i++, msleep(5)) {\r\nret = em28xx_read_reg(dev, EM28XX_R43_AC97BUSY);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(ret & 0x01))\r\nreturn 0;\r\n}\r\nem28xx_warn("AC97 command still being executed: not handled properly!\n");\r\nreturn -EBUSY;\r\n}\r\nint em28xx_read_ac97(struct em28xx *dev, u8 reg)\r\n{\r\nint ret;\r\nu8 addr = (reg & 0x7f) | 0x80;\r\nu16 val;\r\nret = em28xx_is_ac97_ready(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = em28xx_write_regs(dev, EM28XX_R42_AC97ADDR, &addr, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = dev->em28xx_read_reg_req_len(dev, 0, EM28XX_R40_AC97LSB,\r\n(u8 *)&val, sizeof(val));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn le16_to_cpu(val);\r\n}\r\nint em28xx_write_ac97(struct em28xx *dev, u8 reg, u16 val)\r\n{\r\nint ret;\r\nu8 addr = reg & 0x7f;\r\n__le16 value;\r\nvalue = cpu_to_le16(val);\r\nret = em28xx_is_ac97_ready(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = em28xx_write_regs(dev, EM28XX_R40_AC97LSB, (u8 *) &value, 2);\r\nif (ret < 0)\r\nreturn ret;\r\nret = em28xx_write_regs(dev, EM28XX_R42_AC97ADDR, &addr, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int set_ac97_input(struct em28xx *dev)\r\n{\r\nint ret, i;\r\nenum em28xx_amux amux = dev->ctl_ainput;\r\nif (amux == EM28XX_AMUX_VIDEO2)\r\namux = EM28XX_AMUX_VIDEO;\r\nfor (i = 0; i < ARRAY_SIZE(inputs); i++) {\r\nif (amux == inputs[i].mux)\r\nret = em28xx_write_ac97(dev, inputs[i].reg, 0x0808);\r\nelse\r\nret = em28xx_write_ac97(dev, inputs[i].reg, 0x8000);\r\nif (ret < 0)\r\nem28xx_warn("couldn't setup AC97 register %d\n",\r\ninputs[i].reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int em28xx_set_audio_source(struct em28xx *dev)\r\n{\r\nint ret;\r\nu8 input;\r\nif (dev->board.is_em2800) {\r\nif (dev->ctl_ainput == EM28XX_AMUX_VIDEO)\r\ninput = EM2800_AUDIO_SRC_TUNER;\r\nelse\r\ninput = EM2800_AUDIO_SRC_LINE;\r\nret = em28xx_write_regs(dev, EM2800_R08_AUDIOSRC, &input, 1);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (dev->board.has_msp34xx)\r\ninput = EM28XX_AUDIO_SRC_TUNER;\r\nelse {\r\nswitch (dev->ctl_ainput) {\r\ncase EM28XX_AMUX_VIDEO:\r\ninput = EM28XX_AUDIO_SRC_TUNER;\r\nbreak;\r\ndefault:\r\ninput = EM28XX_AUDIO_SRC_LINE;\r\nbreak;\r\n}\r\n}\r\nif (dev->board.mute_gpio && dev->mute)\r\nem28xx_gpio_set(dev, dev->board.mute_gpio);\r\nelse\r\nem28xx_gpio_set(dev, INPUT(dev->ctl_input)->gpio);\r\nret = em28xx_write_reg_bits(dev, EM28XX_R0E_AUDIOSRC, input, 0xc0);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(5);\r\nswitch (dev->audio_mode.ac97) {\r\ncase EM28XX_NO_AC97:\r\nbreak;\r\ndefault:\r\nret = set_ac97_input(dev);\r\n}\r\nreturn ret;\r\n}\r\nint em28xx_audio_analog_set(struct em28xx *dev)\r\n{\r\nint ret, i;\r\nu8 xclk;\r\nif (!dev->audio_mode.has_audio)\r\nreturn 0;\r\nif (dev->audio_mode.ac97 != EM28XX_NO_AC97) {\r\nfor (i = 0; i < ARRAY_SIZE(outputs); i++) {\r\nret = em28xx_write_ac97(dev, outputs[i].reg, 0x8000);\r\nif (ret < 0)\r\nem28xx_warn("couldn't setup AC97 register %d\n",\r\noutputs[i].reg);\r\n}\r\n}\r\nxclk = dev->board.xclk & 0x7f;\r\nif (!dev->mute)\r\nxclk |= EM28XX_XCLK_AUDIO_UNMUTE;\r\nret = em28xx_write_reg(dev, EM28XX_R0F_XCLK, xclk);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(10);\r\nret = em28xx_set_audio_source(dev);\r\nif (dev->audio_mode.ac97 != EM28XX_NO_AC97) {\r\nint vol;\r\nem28xx_write_ac97(dev, AC97_POWERDOWN, 0x4200);\r\nem28xx_write_ac97(dev, AC97_EXTENDED_STATUS, 0x0031);\r\nem28xx_write_ac97(dev, AC97_PCM_LR_ADC_RATE, 0xbb80);\r\nvol = (0x1f - dev->volume) | ((0x1f - dev->volume) << 8);\r\nif (dev->mute)\r\nvol |= 0x8000;\r\nfor (i = 0; i < ARRAY_SIZE(outputs); i++) {\r\nif (dev->ctl_aoutput & outputs[i].mux)\r\nret = em28xx_write_ac97(dev, outputs[i].reg,\r\nvol);\r\nif (ret < 0)\r\nem28xx_warn("couldn't setup AC97 register %d\n",\r\noutputs[i].reg);\r\n}\r\nif (dev->ctl_aoutput & EM28XX_AOUT_PCM_IN) {\r\nint sel = ac97_return_record_select(dev->ctl_aoutput);\r\nsel |= (sel << 8);\r\nem28xx_write_ac97(dev, AC97_REC_SEL, sel);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint em28xx_audio_setup(struct em28xx *dev)\r\n{\r\nint vid1, vid2, feat, cfg;\r\nu32 vid;\r\nif (dev->chip_id == CHIP_ID_EM2870 || dev->chip_id == CHIP_ID_EM2874\r\n|| dev->chip_id == CHIP_ID_EM28174) {\r\ndev->audio_mode.has_audio = false;\r\ndev->has_audio_class = false;\r\ndev->has_alsa_audio = false;\r\nreturn 0;\r\n}\r\ndev->audio_mode.has_audio = true;\r\ncfg = em28xx_read_reg(dev, EM28XX_R00_CHIPCFG);\r\nem28xx_info("Config register raw data: 0x%02x\n", cfg);\r\nif (cfg < 0) {\r\ncfg = EM28XX_CHIPCFG_AC97;\r\n} else if ((cfg & EM28XX_CHIPCFG_AUDIOMASK) == 0x00) {\r\ndev->has_alsa_audio = false;\r\ndev->audio_mode.has_audio = false;\r\nreturn 0;\r\n} else if ((cfg & EM28XX_CHIPCFG_AUDIOMASK) ==\r\nEM28XX_CHIPCFG_I2S_3_SAMPRATES) {\r\nem28xx_info("I2S Audio (3 sample rates)\n");\r\ndev->audio_mode.i2s_3rates = 1;\r\n} else if ((cfg & EM28XX_CHIPCFG_AUDIOMASK) ==\r\nEM28XX_CHIPCFG_I2S_5_SAMPRATES) {\r\nem28xx_info("I2S Audio (5 sample rates)\n");\r\ndev->audio_mode.i2s_5rates = 1;\r\n}\r\nif ((cfg & EM28XX_CHIPCFG_AUDIOMASK) != EM28XX_CHIPCFG_AC97) {\r\ndev->audio_mode.ac97 = EM28XX_NO_AC97;\r\ngoto init_audio;\r\n}\r\ndev->audio_mode.ac97 = EM28XX_AC97_OTHER;\r\nvid1 = em28xx_read_ac97(dev, AC97_VENDOR_ID1);\r\nif (vid1 < 0) {\r\nem28xx_warn("AC97 chip type couldn't be determined\n");\r\ndev->audio_mode.ac97 = EM28XX_NO_AC97;\r\ndev->has_alsa_audio = false;\r\ndev->audio_mode.has_audio = false;\r\ngoto init_audio;\r\n}\r\nvid2 = em28xx_read_ac97(dev, AC97_VENDOR_ID2);\r\nif (vid2 < 0)\r\ngoto init_audio;\r\nvid = vid1 << 16 | vid2;\r\ndev->audio_mode.ac97_vendor_id = vid;\r\nem28xx_warn("AC97 vendor ID = 0x%08x\n", vid);\r\nfeat = em28xx_read_ac97(dev, AC97_RESET);\r\nif (feat < 0)\r\ngoto init_audio;\r\ndev->audio_mode.ac97_feat = feat;\r\nem28xx_warn("AC97 features = 0x%04x\n", feat);\r\nif (((vid == 0xffffffff) || (vid == 0x83847650)) && (feat == 0x6a90))\r\ndev->audio_mode.ac97 = EM28XX_AC97_EM202;\r\nelse if ((vid >> 8) == 0x838476)\r\ndev->audio_mode.ac97 = EM28XX_AC97_SIGMATEL;\r\ninit_audio:\r\nswitch (dev->audio_mode.ac97) {\r\ncase EM28XX_NO_AC97:\r\nem28xx_info("No AC97 audio processor\n");\r\nbreak;\r\ncase EM28XX_AC97_EM202:\r\nem28xx_info("Empia 202 AC97 audio processor detected\n");\r\nbreak;\r\ncase EM28XX_AC97_SIGMATEL:\r\nem28xx_info("Sigmatel audio processor detected(stac 97%02x)\n",\r\ndev->audio_mode.ac97_vendor_id & 0xff);\r\nbreak;\r\ncase EM28XX_AC97_OTHER:\r\nem28xx_warn("Unknown AC97 audio processor detected!\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn em28xx_audio_analog_set(dev);\r\n}\r\nint em28xx_colorlevels_set_default(struct em28xx *dev)\r\n{\r\nem28xx_write_reg(dev, EM28XX_R20_YGAIN, CONTRAST_DEFAULT);\r\nem28xx_write_reg(dev, EM28XX_R21_YOFFSET, BRIGHTNESS_DEFAULT);\r\nem28xx_write_reg(dev, EM28XX_R22_UVGAIN, SATURATION_DEFAULT);\r\nem28xx_write_reg(dev, EM28XX_R23_UOFFSET, BLUE_BALANCE_DEFAULT);\r\nem28xx_write_reg(dev, EM28XX_R24_VOFFSET, RED_BALANCE_DEFAULT);\r\nem28xx_write_reg(dev, EM28XX_R25_SHARPNESS, SHARPNESS_DEFAULT);\r\nem28xx_write_reg(dev, EM28XX_R14_GAMMA, 0x20);\r\nem28xx_write_reg(dev, EM28XX_R15_RGAIN, 0x20);\r\nem28xx_write_reg(dev, EM28XX_R16_GGAIN, 0x20);\r\nem28xx_write_reg(dev, EM28XX_R17_BGAIN, 0x20);\r\nem28xx_write_reg(dev, EM28XX_R18_ROFFSET, 0x00);\r\nem28xx_write_reg(dev, EM28XX_R19_GOFFSET, 0x00);\r\nreturn em28xx_write_reg(dev, EM28XX_R1A_BOFFSET, 0x00);\r\n}\r\nint em28xx_capture_start(struct em28xx *dev, int start)\r\n{\r\nint rc;\r\nif (dev->chip_id == CHIP_ID_EM2874 ||\r\ndev->chip_id == CHIP_ID_EM2884 ||\r\ndev->chip_id == CHIP_ID_EM28174) {\r\nif (!start) {\r\nrc = em28xx_write_reg_bits(dev, EM2874_R5F_TS_ENABLE,\r\n0x00,\r\nEM2874_TS1_CAPTURE_ENABLE);\r\nreturn rc;\r\n}\r\nrc = em28xx_write_reg_bits(dev, EM2874_R5F_TS_ENABLE,\r\nEM2874_TS1_CAPTURE_ENABLE,\r\nEM2874_TS1_CAPTURE_ENABLE);\r\nreturn rc;\r\n}\r\nrc = em28xx_write_reg_bits(dev, EM28XX_R0C_USBSUSP,\r\nstart ? 0x10 : 0x00, 0x10);\r\nif (rc < 0)\r\nreturn rc;\r\nif (!start) {\r\nrc = em28xx_write_reg(dev, EM28XX_R12_VINENABLE, 0x27);\r\nreturn rc;\r\n}\r\nif (dev->board.is_webcam)\r\nrc = em28xx_write_reg(dev, 0x13, 0x0c);\r\nrc = em28xx_write_reg(dev, 0x48, 0x00);\r\nif (dev->mode == EM28XX_ANALOG_MODE)\r\nrc = em28xx_write_reg(dev, EM28XX_R12_VINENABLE, 0x67);\r\nelse\r\nrc = em28xx_write_reg(dev, EM28XX_R12_VINENABLE, 0x37);\r\nmsleep(6);\r\nreturn rc;\r\n}\r\nint em28xx_vbi_supported(struct em28xx *dev)\r\n{\r\nif (disable_vbi == 1)\r\nreturn 0;\r\nif (dev->board.is_webcam)\r\nreturn 0;\r\nif (dev->chip_id == CHIP_ID_EM2860 ||\r\ndev->chip_id == CHIP_ID_EM2883)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint em28xx_set_outfmt(struct em28xx *dev)\r\n{\r\nint ret;\r\nu8 fmt, vinctrl;\r\nfmt = dev->format->reg;\r\nif (!dev->is_em25xx)\r\nfmt |= 0x20;\r\nret = em28xx_write_reg(dev, EM28XX_R27_OUTFMT, fmt);\r\nif (ret < 0)\r\nreturn ret;\r\nret = em28xx_write_reg(dev, EM28XX_R10_VINMODE, dev->vinmode);\r\nif (ret < 0)\r\nreturn ret;\r\nvinctrl = dev->vinctl;\r\nif (em28xx_vbi_supported(dev) == 1) {\r\nvinctrl |= EM28XX_VINCTRL_VBI_RAW;\r\nem28xx_write_reg(dev, EM28XX_R34_VBI_START_H, 0x00);\r\nem28xx_write_reg(dev, EM28XX_R36_VBI_WIDTH, dev->vbi_width/4);\r\nem28xx_write_reg(dev, EM28XX_R37_VBI_HEIGHT, dev->vbi_height);\r\nif (dev->norm & V4L2_STD_525_60) {\r\nem28xx_write_reg(dev, EM28XX_R35_VBI_START_V, 0x09);\r\n} else if (dev->norm & V4L2_STD_625_50) {\r\nem28xx_write_reg(dev, EM28XX_R35_VBI_START_V, 0x07);\r\n}\r\n}\r\nreturn em28xx_write_reg(dev, EM28XX_R11_VINCTRL, vinctrl);\r\n}\r\nstatic int em28xx_accumulator_set(struct em28xx *dev, u8 xmin, u8 xmax,\r\nu8 ymin, u8 ymax)\r\n{\r\nem28xx_coredbg("em28xx Scale: (%d,%d)-(%d,%d)\n",\r\nxmin, ymin, xmax, ymax);\r\nem28xx_write_regs(dev, EM28XX_R28_XMIN, &xmin, 1);\r\nem28xx_write_regs(dev, EM28XX_R29_XMAX, &xmax, 1);\r\nem28xx_write_regs(dev, EM28XX_R2A_YMIN, &ymin, 1);\r\nreturn em28xx_write_regs(dev, EM28XX_R2B_YMAX, &ymax, 1);\r\n}\r\nstatic void em28xx_capture_area_set(struct em28xx *dev, u8 hstart, u8 vstart,\r\nu16 width, u16 height)\r\n{\r\nu8 cwidth = width >> 2;\r\nu8 cheight = height >> 2;\r\nu8 overflow = (height >> 9 & 0x02) | (width >> 10 & 0x01);\r\nem28xx_coredbg("capture area set to (%d,%d): %dx%d\n",\r\nhstart, vstart,\r\n((overflow & 2) << 9 | cwidth << 2),\r\n((overflow & 1) << 10 | cheight << 2));\r\nem28xx_write_regs(dev, EM28XX_R1C_HSTART, &hstart, 1);\r\nem28xx_write_regs(dev, EM28XX_R1D_VSTART, &vstart, 1);\r\nem28xx_write_regs(dev, EM28XX_R1E_CWIDTH, &cwidth, 1);\r\nem28xx_write_regs(dev, EM28XX_R1F_CHEIGHT, &cheight, 1);\r\nem28xx_write_regs(dev, EM28XX_R1B_OFLOW, &overflow, 1);\r\nif (dev->is_em25xx) {\r\nem28xx_write_reg(dev, 0x34, width >> 4);\r\nem28xx_write_reg(dev, 0x35, height >> 4);\r\n}\r\n}\r\nstatic int em28xx_scaler_set(struct em28xx *dev, u16 h, u16 v)\r\n{\r\nu8 mode;\r\nif (dev->board.is_em2800) {\r\nmode = (v ? 0x20 : 0x00) | (h ? 0x10 : 0x00);\r\n} else {\r\nu8 buf[2];\r\nbuf[0] = h;\r\nbuf[1] = h >> 8;\r\nem28xx_write_regs(dev, EM28XX_R30_HSCALELOW, (char *)buf, 2);\r\nbuf[0] = v;\r\nbuf[1] = v >> 8;\r\nem28xx_write_regs(dev, EM28XX_R32_VSCALELOW, (char *)buf, 2);\r\nmode = (h || v) ? 0x30 : 0x00;\r\n}\r\nreturn em28xx_write_reg_bits(dev, EM28XX_R26_COMPR, mode, 0x30);\r\n}\r\nint em28xx_resolution_set(struct em28xx *dev)\r\n{\r\nint width, height;\r\nwidth = norm_maxw(dev);\r\nheight = norm_maxh(dev);\r\ndev->vbi_width = 720;\r\nif (dev->norm & V4L2_STD_525_60)\r\ndev->vbi_height = 12;\r\nelse\r\ndev->vbi_height = 18;\r\nem28xx_set_outfmt(dev);\r\nem28xx_accumulator_set(dev, 1, (width - 4) >> 2, 1, (height - 4) >> 2);\r\nif (em28xx_vbi_supported(dev) == 1)\r\nem28xx_capture_area_set(dev, 0, 2, width, height);\r\nelse\r\nem28xx_capture_area_set(dev, 0, 0, width, height);\r\nreturn em28xx_scaler_set(dev, dev->hscale, dev->vscale);\r\n}\r\nint em28xx_set_alternate(struct em28xx *dev)\r\n{\r\nint errCode;\r\nint i;\r\nunsigned int min_pkt_size = dev->width * 2 + 4;\r\ndev->alt = 0;\r\nif ((alt > 0) && (alt < dev->num_alt)) {\r\nem28xx_coredbg("alternate forced to %d\n", dev->alt);\r\ndev->alt = alt;\r\ngoto set_alt;\r\n}\r\nif (dev->analog_xfer_bulk)\r\ngoto set_alt;\r\nif (dev->width * 2 * dev->height > 720 * 240 * 2)\r\nmin_pkt_size *= 2;\r\nfor (i = 0; i < dev->num_alt; i++) {\r\nif (dev->alt_max_pkt_size_isoc[i] >= min_pkt_size) {\r\ndev->alt = i;\r\nbreak;\r\n} else if (dev->alt_max_pkt_size_isoc[i] >\r\ndev->alt_max_pkt_size_isoc[dev->alt])\r\ndev->alt = i;\r\n}\r\nset_alt:\r\nif (dev->analog_xfer_bulk) {\r\ndev->max_pkt_size = 512;\r\ndev->packet_multiplier = EM28XX_BULK_PACKET_MULTIPLIER;\r\n} else {\r\nem28xx_coredbg("minimum isoc packet size: %u (alt=%d)\n",\r\nmin_pkt_size, dev->alt);\r\ndev->max_pkt_size =\r\ndev->alt_max_pkt_size_isoc[dev->alt];\r\ndev->packet_multiplier = EM28XX_NUM_ISOC_PACKETS;\r\n}\r\nem28xx_coredbg("setting alternate %d with wMaxPacketSize=%u\n",\r\ndev->alt, dev->max_pkt_size);\r\nerrCode = usb_set_interface(dev->udev, 0, dev->alt);\r\nif (errCode < 0) {\r\nem28xx_errdev("cannot change alternate number to %d (error=%i)\n",\r\ndev->alt, errCode);\r\nreturn errCode;\r\n}\r\nreturn 0;\r\n}\r\nint em28xx_gpio_set(struct em28xx *dev, struct em28xx_reg_seq *gpio)\r\n{\r\nint rc = 0;\r\nif (!gpio)\r\nreturn rc;\r\nif (dev->mode != EM28XX_SUSPEND) {\r\nem28xx_write_reg(dev, 0x48, 0x00);\r\nif (dev->mode == EM28XX_ANALOG_MODE)\r\nem28xx_write_reg(dev, EM28XX_R12_VINENABLE, 0x67);\r\nelse\r\nem28xx_write_reg(dev, EM28XX_R12_VINENABLE, 0x37);\r\nmsleep(6);\r\n}\r\nwhile (gpio->sleep >= 0) {\r\nif (gpio->reg >= 0) {\r\nrc = em28xx_write_reg_bits(dev,\r\ngpio->reg,\r\ngpio->val,\r\ngpio->mask);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nif (gpio->sleep > 0)\r\nmsleep(gpio->sleep);\r\ngpio++;\r\n}\r\nreturn rc;\r\n}\r\nint em28xx_set_mode(struct em28xx *dev, enum em28xx_mode set_mode)\r\n{\r\nif (dev->mode == set_mode)\r\nreturn 0;\r\nif (set_mode == EM28XX_SUSPEND) {\r\ndev->mode = set_mode;\r\nreturn em28xx_gpio_set(dev, dev->board.suspend_gpio);\r\n}\r\ndev->mode = set_mode;\r\nif (dev->mode == EM28XX_DIGITAL_MODE)\r\nreturn em28xx_gpio_set(dev, dev->board.dvb_gpio);\r\nelse\r\nreturn em28xx_gpio_set(dev, INPUT(dev->ctl_input)->gpio);\r\n}\r\nstatic void em28xx_irq_callback(struct urb *urb)\r\n{\r\nstruct em28xx *dev = urb->context;\r\nint i;\r\nswitch (urb->status) {\r\ncase 0:\r\ncase -ETIMEDOUT:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\nem28xx_isocdbg("urb completition error %d.\n", urb->status);\r\nbreak;\r\n}\r\nspin_lock(&dev->slock);\r\ndev->usb_ctl.urb_data_copy(dev, urb);\r\nspin_unlock(&dev->slock);\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nurb->iso_frame_desc[i].status = 0;\r\nurb->iso_frame_desc[i].actual_length = 0;\r\n}\r\nurb->status = 0;\r\nurb->status = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (urb->status) {\r\nem28xx_isocdbg("urb resubmit failed (error=%i)\n",\r\nurb->status);\r\n}\r\n}\r\nvoid em28xx_uninit_usb_xfer(struct em28xx *dev, enum em28xx_mode mode)\r\n{\r\nstruct urb *urb;\r\nstruct em28xx_usb_bufs *usb_bufs;\r\nint i;\r\nem28xx_isocdbg("em28xx: called em28xx_uninit_usb_xfer in mode %d\n",\r\nmode);\r\nif (mode == EM28XX_DIGITAL_MODE)\r\nusb_bufs = &dev->usb_ctl.digital_bufs;\r\nelse\r\nusb_bufs = &dev->usb_ctl.analog_bufs;\r\nfor (i = 0; i < usb_bufs->num_bufs; i++) {\r\nurb = usb_bufs->urb[i];\r\nif (urb) {\r\nif (!irqs_disabled())\r\nusb_kill_urb(urb);\r\nelse\r\nusb_unlink_urb(urb);\r\nif (usb_bufs->transfer_buffer[i]) {\r\nusb_free_coherent(dev->udev,\r\nurb->transfer_buffer_length,\r\nusb_bufs->transfer_buffer[i],\r\nurb->transfer_dma);\r\n}\r\nusb_free_urb(urb);\r\nusb_bufs->urb[i] = NULL;\r\n}\r\nusb_bufs->transfer_buffer[i] = NULL;\r\n}\r\nkfree(usb_bufs->urb);\r\nkfree(usb_bufs->transfer_buffer);\r\nusb_bufs->urb = NULL;\r\nusb_bufs->transfer_buffer = NULL;\r\nusb_bufs->num_bufs = 0;\r\nem28xx_capture_start(dev, 0);\r\n}\r\nvoid em28xx_stop_urbs(struct em28xx *dev)\r\n{\r\nint i;\r\nstruct urb *urb;\r\nstruct em28xx_usb_bufs *isoc_bufs = &dev->usb_ctl.digital_bufs;\r\nem28xx_isocdbg("em28xx: called em28xx_stop_urbs\n");\r\nfor (i = 0; i < isoc_bufs->num_bufs; i++) {\r\nurb = isoc_bufs->urb[i];\r\nif (urb) {\r\nif (!irqs_disabled())\r\nusb_kill_urb(urb);\r\nelse\r\nusb_unlink_urb(urb);\r\n}\r\n}\r\nem28xx_capture_start(dev, 0);\r\n}\r\nint em28xx_alloc_urbs(struct em28xx *dev, enum em28xx_mode mode, int xfer_bulk,\r\nint num_bufs, int max_pkt_size, int packet_multiplier)\r\n{\r\nstruct em28xx_usb_bufs *usb_bufs;\r\nint i;\r\nint sb_size, pipe;\r\nstruct urb *urb;\r\nint j, k;\r\nem28xx_isocdbg("em28xx: called em28xx_alloc_isoc in mode %d\n", mode);\r\nif (mode == EM28XX_DIGITAL_MODE) {\r\nif ((xfer_bulk && !dev->dvb_ep_bulk) ||\r\n(!xfer_bulk && !dev->dvb_ep_isoc)) {\r\nem28xx_errdev("no endpoint for DVB mode and transfer type %d\n",\r\nxfer_bulk > 0);\r\nreturn -EINVAL;\r\n}\r\nusb_bufs = &dev->usb_ctl.digital_bufs;\r\n} else if (mode == EM28XX_ANALOG_MODE) {\r\nif ((xfer_bulk && !dev->analog_ep_bulk) ||\r\n(!xfer_bulk && !dev->analog_ep_isoc)) {\r\nem28xx_errdev("no endpoint for analog mode and transfer type %d\n",\r\nxfer_bulk > 0);\r\nreturn -EINVAL;\r\n}\r\nusb_bufs = &dev->usb_ctl.analog_bufs;\r\n} else {\r\nem28xx_errdev("invalid mode selected\n");\r\nreturn -EINVAL;\r\n}\r\nem28xx_uninit_usb_xfer(dev, mode);\r\nusb_bufs->num_bufs = num_bufs;\r\nusb_bufs->urb = kzalloc(sizeof(void *)*num_bufs, GFP_KERNEL);\r\nif (!usb_bufs->urb) {\r\nem28xx_errdev("cannot alloc memory for usb buffers\n");\r\nreturn -ENOMEM;\r\n}\r\nusb_bufs->transfer_buffer = kzalloc(sizeof(void *)*num_bufs,\r\nGFP_KERNEL);\r\nif (!usb_bufs->transfer_buffer) {\r\nem28xx_errdev("cannot allocate memory for usb transfer\n");\r\nkfree(usb_bufs->urb);\r\nreturn -ENOMEM;\r\n}\r\nusb_bufs->max_pkt_size = max_pkt_size;\r\nif (xfer_bulk)\r\nusb_bufs->num_packets = 0;\r\nelse\r\nusb_bufs->num_packets = packet_multiplier;\r\ndev->usb_ctl.vid_buf = NULL;\r\ndev->usb_ctl.vbi_buf = NULL;\r\nsb_size = packet_multiplier * usb_bufs->max_pkt_size;\r\nfor (i = 0; i < usb_bufs->num_bufs; i++) {\r\nurb = usb_alloc_urb(usb_bufs->num_packets, GFP_KERNEL);\r\nif (!urb) {\r\nem28xx_err("cannot alloc usb_ctl.urb %i\n", i);\r\nem28xx_uninit_usb_xfer(dev, mode);\r\nreturn -ENOMEM;\r\n}\r\nusb_bufs->urb[i] = urb;\r\nusb_bufs->transfer_buffer[i] = usb_alloc_coherent(dev->udev,\r\nsb_size, GFP_KERNEL, &urb->transfer_dma);\r\nif (!usb_bufs->transfer_buffer[i]) {\r\nem28xx_err("unable to allocate %i bytes for transfer"\r\n" buffer %i%s\n",\r\nsb_size, i,\r\nin_interrupt() ? " while in int" : "");\r\nem28xx_uninit_usb_xfer(dev, mode);\r\nreturn -ENOMEM;\r\n}\r\nmemset(usb_bufs->transfer_buffer[i], 0, sb_size);\r\nif (xfer_bulk) {\r\npipe = usb_rcvbulkpipe(dev->udev,\r\nmode == EM28XX_ANALOG_MODE ?\r\ndev->analog_ep_bulk :\r\ndev->dvb_ep_bulk);\r\nusb_fill_bulk_urb(urb, dev->udev, pipe,\r\nusb_bufs->transfer_buffer[i], sb_size,\r\nem28xx_irq_callback, dev);\r\nurb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\r\n} else {\r\npipe = usb_rcvisocpipe(dev->udev,\r\nmode == EM28XX_ANALOG_MODE ?\r\ndev->analog_ep_isoc :\r\ndev->dvb_ep_isoc);\r\nusb_fill_int_urb(urb, dev->udev, pipe,\r\nusb_bufs->transfer_buffer[i], sb_size,\r\nem28xx_irq_callback, dev, 1);\r\nurb->transfer_flags = URB_ISO_ASAP |\r\nURB_NO_TRANSFER_DMA_MAP;\r\nk = 0;\r\nfor (j = 0; j < usb_bufs->num_packets; j++) {\r\nurb->iso_frame_desc[j].offset = k;\r\nurb->iso_frame_desc[j].length =\r\nusb_bufs->max_pkt_size;\r\nk += usb_bufs->max_pkt_size;\r\n}\r\n}\r\nurb->number_of_packets = usb_bufs->num_packets;\r\n}\r\nreturn 0;\r\n}\r\nint em28xx_init_usb_xfer(struct em28xx *dev, enum em28xx_mode mode,\r\nint xfer_bulk, int num_bufs, int max_pkt_size,\r\nint packet_multiplier,\r\nint (*urb_data_copy) (struct em28xx *dev, struct urb *urb))\r\n{\r\nstruct em28xx_dmaqueue *dma_q = &dev->vidq;\r\nstruct em28xx_dmaqueue *vbi_dma_q = &dev->vbiq;\r\nstruct em28xx_usb_bufs *usb_bufs;\r\nint i;\r\nint rc;\r\nint alloc;\r\nem28xx_isocdbg("em28xx: called em28xx_init_usb_xfer in mode %d\n",\r\nmode);\r\ndev->usb_ctl.urb_data_copy = urb_data_copy;\r\nif (mode == EM28XX_DIGITAL_MODE) {\r\nusb_bufs = &dev->usb_ctl.digital_bufs;\r\nalloc = 0;\r\n} else {\r\nusb_bufs = &dev->usb_ctl.analog_bufs;\r\nalloc = 1;\r\n}\r\nif (alloc) {\r\nrc = em28xx_alloc_urbs(dev, mode, xfer_bulk, num_bufs,\r\nmax_pkt_size, packet_multiplier);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (xfer_bulk) {\r\nrc = usb_clear_halt(dev->udev, usb_bufs->urb[0]->pipe);\r\nif (rc < 0) {\r\nem28xx_err("failed to clear USB bulk endpoint stall/halt condition (error=%i)\n",\r\nrc);\r\nem28xx_uninit_usb_xfer(dev, mode);\r\nreturn rc;\r\n}\r\n}\r\ninit_waitqueue_head(&dma_q->wq);\r\ninit_waitqueue_head(&vbi_dma_q->wq);\r\nem28xx_capture_start(dev, 1);\r\nfor (i = 0; i < usb_bufs->num_bufs; i++) {\r\nrc = usb_submit_urb(usb_bufs->urb[i], GFP_ATOMIC);\r\nif (rc) {\r\nem28xx_err("submit of urb %i failed (error=%i)\n", i,\r\nrc);\r\nem28xx_uninit_usb_xfer(dev, mode);\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid em28xx_wake_i2c(struct em28xx *dev)\r\n{\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, core, reset, 0);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_routing,\r\nINPUT(dev->ctl_input)->vmux, 0, 0);\r\nv4l2_device_call_all(&dev->v4l2_dev, 0, video, s_stream, 0);\r\n}\r\nint em28xx_register_extension(struct em28xx_ops *ops)\r\n{\r\nstruct em28xx *dev = NULL;\r\nmutex_lock(&em28xx_devlist_mutex);\r\nlist_add_tail(&ops->next, &em28xx_extension_devlist);\r\nlist_for_each_entry(dev, &em28xx_devlist, devlist) {\r\nops->init(dev);\r\n}\r\nmutex_unlock(&em28xx_devlist_mutex);\r\nprintk(KERN_INFO "Em28xx: Initialized (%s) extension\n", ops->name);\r\nreturn 0;\r\n}\r\nvoid em28xx_unregister_extension(struct em28xx_ops *ops)\r\n{\r\nstruct em28xx *dev = NULL;\r\nmutex_lock(&em28xx_devlist_mutex);\r\nlist_for_each_entry(dev, &em28xx_devlist, devlist) {\r\nops->fini(dev);\r\n}\r\nlist_del(&ops->next);\r\nmutex_unlock(&em28xx_devlist_mutex);\r\nprintk(KERN_INFO "Em28xx: Removed (%s) extension\n", ops->name);\r\n}\r\nvoid em28xx_init_extension(struct em28xx *dev)\r\n{\r\nconst struct em28xx_ops *ops = NULL;\r\nmutex_lock(&em28xx_devlist_mutex);\r\nlist_add_tail(&dev->devlist, &em28xx_devlist);\r\nlist_for_each_entry(ops, &em28xx_extension_devlist, next) {\r\nif (ops->init)\r\nops->init(dev);\r\n}\r\nmutex_unlock(&em28xx_devlist_mutex);\r\n}\r\nvoid em28xx_close_extension(struct em28xx *dev)\r\n{\r\nconst struct em28xx_ops *ops = NULL;\r\nmutex_lock(&em28xx_devlist_mutex);\r\nlist_for_each_entry(ops, &em28xx_extension_devlist, next) {\r\nif (ops->fini)\r\nops->fini(dev);\r\n}\r\nlist_del(&dev->devlist);\r\nmutex_unlock(&em28xx_devlist_mutex);\r\n}
