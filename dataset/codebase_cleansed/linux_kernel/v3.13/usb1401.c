static void ced_delete(struct kref *kref)\r\n{\r\nDEVICE_EXTENSION *pdx = to_DEVICE_EXTENSION(kref);\r\nusb_free_coherent(pdx->udev, OUTBUF_SZ, pdx->pCoherCharOut,\r\npdx->pUrbCharOut->transfer_dma);\r\nusb_free_urb(pdx->pUrbCharOut);\r\nusb_free_coherent(pdx->udev, INBUF_SZ, pdx->pCoherCharIn,\r\npdx->pUrbCharIn->transfer_dma);\r\nusb_free_urb(pdx->pUrbCharIn);\r\nusb_free_coherent(pdx->udev, STAGED_SZ, pdx->pCoherStagedIO,\r\npdx->pStagedUrb->transfer_dma);\r\nusb_free_urb(pdx->pStagedUrb);\r\nusb_put_dev(pdx->udev);\r\nkfree(pdx);\r\n}\r\nstatic int ced_open(struct inode *inode, struct file *file)\r\n{\r\nDEVICE_EXTENSION *pdx;\r\nint retval = 0;\r\nint subminor = iminor(inode);\r\nstruct usb_interface *interface =\r\nusb_find_interface(&ced_driver, subminor);\r\nif (!interface) {\r\npr_err("%s - error, can't find device for minor %d", __func__,\r\nsubminor);\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\npdx = usb_get_intfdata(interface);\r\nif (!pdx) {\r\nretval = -ENODEV;\r\ngoto exit;\r\n}\r\ndev_dbg(&interface->dev, "%s got pdx", __func__);\r\nkref_get(&pdx->kref);\r\nmutex_lock(&pdx->io_mutex);\r\nif (!pdx->open_count++) {\r\nretval = usb_autopm_get_interface(interface);\r\nif (retval) {\r\npdx->open_count--;\r\nmutex_unlock(&pdx->io_mutex);\r\nkref_put(&pdx->kref, ced_delete);\r\ngoto exit;\r\n}\r\n} else {\r\ndev_err(&interface->dev, "%s fail: already open", __func__);\r\nretval = -EBUSY;\r\npdx->open_count--;\r\nmutex_unlock(&pdx->io_mutex);\r\nkref_put(&pdx->kref, ced_delete);\r\ngoto exit;\r\n}\r\nfile->private_data = pdx;\r\nmutex_unlock(&pdx->io_mutex);\r\nexit:\r\nreturn retval;\r\n}\r\nstatic int ced_release(struct inode *inode, struct file *file)\r\n{\r\nDEVICE_EXTENSION *pdx = file->private_data;\r\nif (pdx == NULL)\r\nreturn -ENODEV;\r\ndev_dbg(&pdx->interface->dev, "%s called", __func__);\r\nmutex_lock(&pdx->io_mutex);\r\nif (!--pdx->open_count && pdx->interface)\r\nusb_autopm_put_interface(pdx->interface);\r\nmutex_unlock(&pdx->io_mutex);\r\nkref_put(&pdx->kref, ced_delete);\r\nreturn 0;\r\n}\r\nstatic int ced_flush(struct file *file, fl_owner_t id)\r\n{\r\nint res;\r\nDEVICE_EXTENSION *pdx = file->private_data;\r\nif (pdx == NULL)\r\nreturn -ENODEV;\r\ndev_dbg(&pdx->interface->dev, "%s char in pend=%d", __func__,\r\npdx->bReadCharsPending);\r\nmutex_lock(&pdx->io_mutex);\r\ndev_dbg(&pdx->interface->dev, "%s got io_mutex", __func__);\r\nced_draw_down(pdx);\r\nspin_lock_irq(&pdx->err_lock);\r\nres = pdx->errors ? (pdx->errors == -EPIPE ? -EPIPE : -EIO) : 0;\r\npdx->errors = 0;\r\nspin_unlock_irq(&pdx->err_lock);\r\nmutex_unlock(&pdx->io_mutex);\r\ndev_dbg(&pdx->interface->dev, "%s exit reached", __func__);\r\nreturn res;\r\n}\r\nstatic bool CanAcceptIoRequests(DEVICE_EXTENSION *pdx)\r\n{\r\nreturn pdx && pdx->interface;\r\n}\r\nstatic void ced_writechar_callback(struct urb *pUrb)\r\n{\r\nDEVICE_EXTENSION *pdx = pUrb->context;\r\nint nGot = pUrb->actual_length;\r\nif (pUrb->status) {\r\nif (!\r\n(pUrb->status == -ENOENT || pUrb->status == -ECONNRESET\r\n|| pUrb->status == -ESHUTDOWN)) {\r\ndev_err(&pdx->interface->dev,\r\n"%s - nonzero write bulk status received: %d",\r\n__func__, pUrb->status);\r\n}\r\nspin_lock(&pdx->err_lock);\r\npdx->errors = pUrb->status;\r\nspin_unlock(&pdx->err_lock);\r\nnGot = 0;\r\nspin_lock(&pdx->charOutLock);\r\npdx->dwOutBuffGet = 0;\r\npdx->dwOutBuffPut = 0;\r\npdx->dwNumOutput = 0;\r\npdx->bPipeError[0] = 1;\r\npdx->bSendCharsPending = false;\r\nspin_unlock(&pdx->charOutLock);\r\ndev_dbg(&pdx->interface->dev,\r\n"%s - char out done, 0 chars sent", __func__);\r\n} else {\r\ndev_dbg(&pdx->interface->dev,\r\n"%s - char out done, %d chars sent", __func__, nGot);\r\nspin_lock(&pdx->charOutLock);\r\npdx->dwNumOutput -= nGot;\r\npdx->dwOutBuffGet += nGot;\r\nif (pdx->dwOutBuffGet >= OUTBUF_SZ)\r\npdx->dwOutBuffGet = 0;\r\nif (pdx->dwNumOutput > 0) {\r\nint nPipe = 0;\r\nint iReturn;\r\nchar *pDat = &pdx->outputBuffer[pdx->dwOutBuffGet];\r\nunsigned int dwCount = pdx->dwNumOutput;\r\nif ((pdx->dwOutBuffGet + dwCount) > OUTBUF_SZ)\r\ndwCount = OUTBUF_SZ - pdx->dwOutBuffGet;\r\nspin_unlock(&pdx->charOutLock);\r\nmemcpy(pdx->pCoherCharOut, pDat, dwCount);\r\nusb_fill_bulk_urb(pdx->pUrbCharOut, pdx->udev,\r\nusb_sndbulkpipe(pdx->udev,\r\npdx->epAddr[0]),\r\npdx->pCoherCharOut, dwCount,\r\nced_writechar_callback, pdx);\r\npdx->pUrbCharOut->transfer_flags |=\r\nURB_NO_TRANSFER_DMA_MAP;\r\nusb_anchor_urb(pdx->pUrbCharOut, &pdx->submitted);\r\niReturn = usb_submit_urb(pdx->pUrbCharOut, GFP_ATOMIC);\r\ndev_dbg(&pdx->interface->dev, "%s n=%d>%s<", __func__,\r\ndwCount, pDat);\r\nspin_lock(&pdx->charOutLock);\r\nif (iReturn) {\r\npdx->bPipeError[nPipe] = 1;\r\npdx->bSendCharsPending = false;\r\nusb_unanchor_urb(pdx->pUrbCharOut);\r\ndev_err(&pdx->interface->dev,\r\n"%s usb_submit_urb() returned %d",\r\n__func__, iReturn);\r\n}\r\n} else\r\npdx->bSendCharsPending = false;\r\nspin_unlock(&pdx->charOutLock);\r\n}\r\n}\r\nint SendChars(DEVICE_EXTENSION *pdx)\r\n{\r\nint iReturn = U14ERR_NOERROR;\r\nspin_lock_irq(&pdx->charOutLock);\r\nif ((!pdx->bSendCharsPending) &&\r\n(pdx->dwNumOutput > 0) &&\r\n(CanAcceptIoRequests(pdx))) {\r\nunsigned int dwCount = pdx->dwNumOutput;\r\npdx->bSendCharsPending = true;\r\ndev_dbg(&pdx->interface->dev,\r\n"Send %d chars to 1401, EP0 flag %d\n", dwCount,\r\npdx->nPipes == 3);\r\nif (pdx->nPipes == 3) {\r\nunsigned int count = dwCount;\r\nunsigned int index = 0;\r\nspin_unlock_irq(&pdx->charOutLock);\r\nwhile ((count > 0) && (iReturn == U14ERR_NOERROR)) {\r\nint n = count > 64 ? 64 : count;\r\nint nSent = usb_control_msg(pdx->udev,\r\nusb_sndctrlpipe(pdx->udev, 0),\r\nDB_CHARS,\r\n(H_TO_D | VENDOR | DEVREQ),\r\n0, 0,\r\n&pdx->outputBuffer[index],\r\nn,\r\n1000);\r\nif (nSent <= 0) {\r\niReturn = nSent ? nSent : -ETIMEDOUT;\r\ndev_err(&pdx->interface->dev,\r\n"Send %d chars by EP0 failed: %d",\r\nn, iReturn);\r\n} else {\r\ndev_dbg(&pdx->interface->dev,\r\n"Sent %d chars by EP0", n);\r\ncount -= nSent;\r\nindex += nSent;\r\n}\r\n}\r\nspin_lock_irq(&pdx->charOutLock);\r\npdx->dwOutBuffGet = 0;\r\npdx->dwOutBuffPut = 0;\r\npdx->dwNumOutput = 0;\r\npdx->bSendCharsPending = false;\r\n} else {\r\nint nPipe = 0;\r\nchar *pDat = &pdx->outputBuffer[pdx->dwOutBuffGet];\r\nif ((pdx->dwOutBuffGet + dwCount) > OUTBUF_SZ)\r\ndwCount = OUTBUF_SZ - pdx->dwOutBuffGet;\r\nspin_unlock_irq(&pdx->charOutLock);\r\nmemcpy(pdx->pCoherCharOut, pDat, dwCount);\r\nusb_fill_bulk_urb(pdx->pUrbCharOut, pdx->udev,\r\nusb_sndbulkpipe(pdx->udev,\r\npdx->epAddr[0]),\r\npdx->pCoherCharOut, dwCount,\r\nced_writechar_callback, pdx);\r\npdx->pUrbCharOut->transfer_flags |=\r\nURB_NO_TRANSFER_DMA_MAP;\r\nusb_anchor_urb(pdx->pUrbCharOut, &pdx->submitted);\r\niReturn = usb_submit_urb(pdx->pUrbCharOut, GFP_KERNEL);\r\nspin_lock_irq(&pdx->charOutLock);\r\nif (iReturn) {\r\npdx->bPipeError[nPipe] = 1;\r\npdx->bSendCharsPending = false;\r\nusb_unanchor_urb(pdx->pUrbCharOut);\r\n}\r\n}\r\n} else if (pdx->bSendCharsPending && (pdx->dwNumOutput > 0))\r\ndev_dbg(&pdx->interface->dev,\r\n"SendChars bSendCharsPending:true");\r\ndev_dbg(&pdx->interface->dev, "SendChars exit code: %d", iReturn);\r\nspin_unlock_irq(&pdx->charOutLock);\r\nreturn iReturn;\r\n}\r\nstatic void CopyUserSpace(DEVICE_EXTENSION *pdx, int n)\r\n{\r\nunsigned int nArea = pdx->StagedId;\r\nif (nArea < MAX_TRANSAREAS) {\r\nTRANSAREA *pArea = &pdx->rTransDef[nArea];\r\nunsigned int dwOffset =\r\npdx->StagedDone + pdx->StagedOffset + pArea->dwBaseOffset;\r\nchar *pCoherBuf = pdx->pCoherStagedIO;\r\nif (!pArea->bUsed) {\r\ndev_err(&pdx->interface->dev, "%s area %d unused",\r\n__func__, nArea);\r\nreturn;\r\n}\r\nwhile (n) {\r\nint nPage = dwOffset >> PAGE_SHIFT;\r\nif (nPage < pArea->nPages) {\r\nchar *pvAddress =\r\n(char *)kmap_atomic(pArea->pPages[nPage]);\r\nif (pvAddress) {\r\nunsigned int uiPageOff = dwOffset & (PAGE_SIZE - 1);\r\nsize_t uiXfer = PAGE_SIZE - uiPageOff;\r\nif (uiXfer > n)\r\nuiXfer = n;\r\nif (pdx->StagedRead)\r\nmemcpy(pvAddress + uiPageOff,\r\npCoherBuf, uiXfer);\r\nelse\r\nmemcpy(pCoherBuf,\r\npvAddress + uiPageOff,\r\nuiXfer);\r\nkunmap_atomic(pvAddress);\r\ndwOffset += uiXfer;\r\npCoherBuf += uiXfer;\r\nn -= uiXfer;\r\n} else {\r\ndev_err(&pdx->interface->dev,\r\n"%s did not map page %d",\r\n__func__, nPage);\r\nreturn;\r\n}\r\n} else {\r\ndev_err(&pdx->interface->dev,\r\n"%s exceeded pages %d", __func__,\r\nnPage);\r\nreturn;\r\n}\r\n}\r\n} else\r\ndev_err(&pdx->interface->dev, "%s bad area %d", __func__,\r\nnArea);\r\n}\r\nstatic void staged_callback(struct urb *pUrb)\r\n{\r\nDEVICE_EXTENSION *pdx = pUrb->context;\r\nunsigned int nGot = pUrb->actual_length;\r\nbool bCancel = false;\r\nbool bRestartCharInput;\r\nspin_lock(&pdx->stagedLock);\r\npdx->bStagedUrbPending = false;\r\nif (pUrb->status) {\r\nif (!\r\n(pUrb->status == -ENOENT || pUrb->status == -ECONNRESET\r\n|| pUrb->status == -ESHUTDOWN)) {\r\ndev_err(&pdx->interface->dev,\r\n"%s - nonzero write bulk status received: %d",\r\n__func__, pUrb->status);\r\n} else\r\ndev_info(&pdx->interface->dev,\r\n"%s - staged xfer cancelled", __func__);\r\nspin_lock(&pdx->err_lock);\r\npdx->errors = pUrb->status;\r\nspin_unlock(&pdx->err_lock);\r\nnGot = 0;\r\nbCancel = true;\r\n} else {\r\ndev_dbg(&pdx->interface->dev, "%s %d chars xferred", __func__,\r\nnGot);\r\nif (pdx->StagedRead)\r\nCopyUserSpace(pdx, nGot);\r\nif (nGot == 0)\r\ndev_dbg(&pdx->interface->dev, "%s ZLP", __func__);\r\n}\r\npdx->StagedDone += nGot;\r\ndev_dbg(&pdx->interface->dev, "%s, done %d bytes of %d", __func__,\r\npdx->StagedDone, pdx->StagedLength);\r\nif ((pdx->StagedDone == pdx->StagedLength) ||\r\n(bCancel)) {\r\nTRANSAREA *pArea = &pdx->rTransDef[pdx->StagedId];\r\ndev_dbg(&pdx->interface->dev,\r\n"%s transfer done, bytes %d, cancel %d", __func__,\r\npdx->StagedDone, bCancel);\r\nif ((pArea->bCircular) && (pArea->bCircToHost) && (!bCancel) &&\r\n(pdx->StagedRead)) {\r\nif (pArea->aBlocks[1].dwSize > 0) {\r\nif (pdx->StagedOffset ==\r\n(pArea->aBlocks[1].dwOffset +\r\npArea->aBlocks[1].dwSize)) {\r\npArea->aBlocks[1].dwSize +=\r\npdx->StagedLength;\r\ndev_dbg(&pdx->interface->dev,\r\n"RWM_Complete, circ block 1 now %d bytes at %d",\r\npArea->aBlocks[1].dwSize,\r\npArea->aBlocks[1].dwOffset);\r\n} else {\r\npArea->aBlocks[1].dwOffset =\r\npdx->StagedOffset;\r\npArea->aBlocks[1].dwSize =\r\npdx->StagedLength;\r\ndev_err(&pdx->interface->dev,\r\n"%s ERROR, circ block 1 re-started %d bytes at %d",\r\n__func__,\r\npArea->aBlocks[1].dwSize,\r\npArea->aBlocks[1].dwOffset);\r\n}\r\n} else {\r\nif (pArea->aBlocks[0].dwSize > 0) {\r\nif (pdx->StagedOffset ==\r\n(pArea->aBlocks[0].dwOffset +\r\npArea->aBlocks[0].dwSize)) {\r\npArea->aBlocks[0].dwSize += pdx->StagedLength;\r\ndev_dbg(&pdx->interface->dev,\r\n"RWM_Complete, circ block 0 now %d bytes at %d",\r\npArea->aBlocks[0].\r\ndwSize,\r\npArea->aBlocks[0].\r\ndwOffset);\r\n} else {\r\npArea->aBlocks[1].dwOffset =\r\npdx->StagedOffset;\r\npArea->aBlocks[1].dwSize =\r\npdx->StagedLength;\r\ndev_dbg(&pdx->interface->dev,\r\n"RWM_Complete, circ block 1 started %d bytes at %d",\r\npArea->aBlocks[1].\r\ndwSize,\r\npArea->aBlocks[1].\r\ndwOffset);\r\n}\r\n} else {\r\npArea->aBlocks[0].dwOffset =\r\npdx->StagedOffset;\r\npArea->aBlocks[0].dwSize =\r\npdx->StagedLength;\r\ndev_dbg(&pdx->interface->dev,\r\n"RWM_Complete, circ block 0 started %d bytes at %d",\r\npArea->aBlocks[0].dwSize,\r\npArea->aBlocks[0].dwOffset);\r\n}\r\n}\r\n}\r\nif (!bCancel) {\r\ndev_dbg(&pdx->interface->dev,\r\n"RWM_Complete, bCircular %d, bToHost %d, eStart %d, eSize %d",\r\npArea->bCircular, pArea->bEventToHost,\r\npArea->dwEventSt, pArea->dwEventSz);\r\nif ((pArea->dwEventSz) &&\r\n(pdx->StagedRead == pArea->bEventToHost)) {\r\nint iWakeUp = 0;\r\nif ((pArea->bCircular) &&\r\n(pArea->bCircToHost)) {\r\nunsigned int dwTotal =\r\npArea->aBlocks[0].dwSize +\r\npArea->aBlocks[1].dwSize;\r\niWakeUp = (dwTotal >= pArea->dwEventSz);\r\n} else {\r\nunsigned int transEnd =\r\npdx->StagedOffset +\r\npdx->StagedLength;\r\nunsigned int eventEnd =\r\npArea->dwEventSt + pArea->dwEventSz;\r\niWakeUp = (pdx->StagedOffset < eventEnd)\r\n&& (transEnd > pArea->dwEventSt);\r\n}\r\nif (iWakeUp) {\r\ndev_dbg(&pdx->interface->dev,\r\n"About to set event to notify app");\r\nwake_up_interruptible(&pArea->wqEvent);\r\n++pArea->iWakeUp;\r\n}\r\n}\r\n}\r\npdx->dwDMAFlag = MODE_CHAR;\r\nif (!bCancel) {\r\nif (pdx->bXFerWaiting) {\r\nint iReturn;\r\ndev_info(&pdx->interface->dev,\r\n"*** RWM_Complete *** pending transfer will now be set up!!!");\r\niReturn =\r\nReadWriteMem(pdx, !pdx->rDMAInfo.bOutWard,\r\npdx->rDMAInfo.wIdent,\r\npdx->rDMAInfo.dwOffset,\r\npdx->rDMAInfo.dwSize);\r\nif (iReturn)\r\ndev_err(&pdx->interface->dev,\r\n"RWM_Complete rw setup failed %d",\r\niReturn);\r\n}\r\n}\r\n} else\r\nStageChunk(pdx);\r\nbRestartCharInput = !bCancel && (pdx->dwDMAFlag == MODE_CHAR)\r\n&& !pdx->bXFerWaiting;\r\nspin_unlock(&pdx->stagedLock);\r\nif (bRestartCharInput)\r\nAllowi(pdx);\r\ndev_dbg(&pdx->interface->dev, "%s done", __func__);\r\n}\r\nstatic int StageChunk(DEVICE_EXTENSION *pdx)\r\n{\r\nint iReturn = U14ERR_NOERROR;\r\nunsigned int ChunkSize;\r\nint nPipe = pdx->StagedRead ? 3 : 2;\r\nif (pdx->nPipes == 3)\r\nnPipe--;\r\nif (nPipe < 0)\r\nreturn U14ERR_FAIL;\r\nif (!CanAcceptIoRequests(pdx)) {\r\ndev_info(&pdx->interface->dev, "%s sudden remove, giving up",\r\n__func__);\r\nreturn U14ERR_FAIL;\r\n}\r\nChunkSize = (pdx->StagedLength - pdx->StagedDone);\r\nif (ChunkSize > STAGED_SZ)\r\nChunkSize = STAGED_SZ;\r\nif (!pdx->StagedRead)\r\nCopyUserSpace(pdx, ChunkSize);\r\nusb_fill_bulk_urb(pdx->pStagedUrb, pdx->udev,\r\npdx->StagedRead ? usb_rcvbulkpipe(pdx->udev,\r\npdx->\r\nepAddr[nPipe]) :\r\nusb_sndbulkpipe(pdx->udev, pdx->epAddr[nPipe]),\r\npdx->pCoherStagedIO, ChunkSize, staged_callback, pdx);\r\npdx->pStagedUrb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_anchor_urb(pdx->pStagedUrb, &pdx->submitted);\r\niReturn = usb_submit_urb(pdx->pStagedUrb, GFP_ATOMIC);\r\nif (iReturn) {\r\nusb_unanchor_urb(pdx->pStagedUrb);\r\npdx->bPipeError[nPipe] = 1;\r\ndev_err(&pdx->interface->dev, "%s submit urb failed, code %d",\r\n__func__, iReturn);\r\n} else\r\npdx->bStagedUrbPending = true;\r\ndev_dbg(&pdx->interface->dev, "%s done so far:%d, this size:%d",\r\n__func__, pdx->StagedDone, ChunkSize);\r\nreturn iReturn;\r\n}\r\nint ReadWriteMem(DEVICE_EXTENSION *pdx, bool Read, unsigned short wIdent,\r\nunsigned int dwOffs, unsigned int dwLen)\r\n{\r\nTRANSAREA *pArea = &pdx->rTransDef[wIdent];\r\nif (!CanAcceptIoRequests(pdx)) {\r\ndev_err(&pdx->interface->dev, "%s can't accept requests",\r\n__func__);\r\nreturn U14ERR_FAIL;\r\n}\r\ndev_dbg(&pdx->interface->dev,\r\n"%s xfer %d bytes to %s, offset %d, area %d", __func__, dwLen,\r\nRead ? "host" : "1401", dwOffs, wIdent);\r\nif (pdx->bStagedUrbPending) {\r\npdx->bXFerWaiting = true;\r\ndev_info(&pdx->interface->dev,\r\n"%s xfer is waiting, as previous staged pending",\r\n__func__);\r\nreturn U14ERR_NOERROR;\r\n}\r\nif (dwLen == 0) {\r\ndev_dbg(&pdx->interface->dev,\r\n"%s OK; zero-len read/write request", __func__);\r\nreturn U14ERR_NOERROR;\r\n}\r\nif ((pArea->bCircular) &&\r\n(pArea->bCircToHost) && (Read)) {\r\nbool bWait = false;\r\ndev_dbg(&pdx->interface->dev,\r\n"Circular buffers are %d at %d and %d at %d",\r\npArea->aBlocks[0].dwSize, pArea->aBlocks[0].dwOffset,\r\npArea->aBlocks[1].dwSize, pArea->aBlocks[1].dwOffset);\r\nif (pArea->aBlocks[1].dwSize > 0) {\r\ndwOffs = pArea->aBlocks[1].dwOffset + pArea->aBlocks[1].dwSize;\r\nbWait = (dwOffs + dwLen) > pArea->aBlocks[0].dwOffset;\r\nbWait |= (dwOffs + dwLen) > pArea->dwLength;\r\n} else {\r\nif (pArea->aBlocks[0].dwSize == 0)\r\npArea->aBlocks[0].dwOffset = 0;\r\ndwOffs =\r\npArea->aBlocks[0].dwOffset +\r\npArea->aBlocks[0].dwSize;\r\nif ((dwOffs + dwLen) > pArea->dwLength) {\r\npArea->aBlocks[1].dwOffset = 0;\r\ndwOffs = 0;\r\nbWait = (dwOffs + dwLen) > pArea->aBlocks[0].dwOffset;\r\nbWait |= (dwOffs + dwLen) > pArea->dwLength;\r\n}\r\n}\r\nif (bWait) {\r\npdx->bXFerWaiting = true;\r\ndev_dbg(&pdx->interface->dev,\r\n"%s xfer waiting for circular buffer space",\r\n__func__);\r\nreturn U14ERR_NOERROR;\r\n}\r\ndev_dbg(&pdx->interface->dev,\r\n"%s circular xfer, %d bytes starting at %d", __func__,\r\ndwLen, dwOffs);\r\n}\r\npdx->StagedRead = Read;\r\npdx->StagedId = wIdent;\r\npdx->StagedOffset = dwOffs;\r\npdx->StagedLength = dwLen;\r\npdx->StagedDone = 0;\r\npdx->dwDMAFlag = MODE_LINEAR;\r\npdx->bXFerWaiting = false;\r\nStageChunk(pdx);\r\nreturn U14ERR_NOERROR;\r\n}\r\nstatic bool ReadChar(unsigned char *pChar, char *pBuf, unsigned int *pdDone,\r\nunsigned int dGot)\r\n{\r\nbool bRead = false;\r\nunsigned int dDone = *pdDone;\r\nif (dDone < dGot) {\r\n*pChar = (unsigned char)pBuf[dDone];\r\ndDone++;\r\n*pdDone = dDone;\r\nbRead = true;\r\n}\r\nreturn bRead;\r\n}\r\nstatic bool ReadWord(unsigned short *pWord, char *pBuf, unsigned int *pdDone,\r\nunsigned int dGot)\r\n{\r\nif (ReadChar((unsigned char *)pWord, pBuf, pdDone, dGot))\r\nreturn ReadChar(((unsigned char *)pWord) + 1, pBuf, pdDone,\r\ndGot);\r\nelse\r\nreturn false;\r\n}\r\nstatic bool ReadHuff(volatile unsigned int *pDWord, char *pBuf,\r\nunsigned int *pdDone, unsigned int dGot)\r\n{\r\nunsigned char ucData;\r\nbool bReturn = true;\r\nunsigned int dwData = 0;\r\nif (ReadChar(&ucData, pBuf, pdDone, dGot)) {\r\ndwData = ucData;\r\nif ((dwData & 0x00000080) != 0) {\r\ndwData &= 0x0000007F;\r\nif (ReadChar(&ucData, pBuf, pdDone, dGot)) {\r\ndwData = (dwData << 8) | ucData;\r\nif ((dwData & 0x00004000) != 0) {\r\ndwData &= 0x00003FFF;\r\nif (ReadChar\r\n(&ucData, pBuf, pdDone, dGot))\r\ndwData = (dwData << 8) | ucData;\r\nelse\r\nbReturn = false;\r\n}\r\n} else\r\nbReturn = false;\r\n}\r\n} else\r\nbReturn = false;\r\n*pDWord = dwData;\r\nreturn bReturn;\r\n}\r\nstatic bool ReadDMAInfo(volatile DMADESC *pDmaDesc, DEVICE_EXTENSION *pdx,\r\nchar *pBuf, unsigned int dwCount)\r\n{\r\nbool bResult = false;\r\nunsigned char ucData;\r\nunsigned int dDone = 0;\r\ndev_dbg(&pdx->interface->dev, "%s", __func__);\r\nif (ReadChar(&ucData, pBuf, &dDone, dwCount)) {\r\nunsigned char ucTransCode = (ucData & 0x0F);\r\nunsigned short wIdent = ((ucData >> 4) & 0x07);\r\npDmaDesc->wTransType = ucTransCode;\r\npDmaDesc->wIdent = wIdent;\r\npDmaDesc->dwSize = 0;\r\npDmaDesc->dwOffset = 0;\r\ndev_dbg(&pdx->interface->dev, "%s type: %d ident: %d", __func__,\r\npDmaDesc->wTransType, pDmaDesc->wIdent);\r\npDmaDesc->bOutWard = (ucTransCode != TM_EXTTOHOST);\r\nswitch (ucTransCode) {\r\ncase TM_EXTTOHOST:\r\ncase TM_EXTTO1401:\r\n{\r\nbResult =\r\nReadHuff(&(pDmaDesc->dwOffset), pBuf,\r\n&dDone, dwCount)\r\n&& ReadHuff(&(pDmaDesc->dwSize), pBuf,\r\n&dDone, dwCount);\r\nif (bResult) {\r\ndev_dbg(&pdx->interface->dev,\r\n"%s xfer offset & size %d %d",\r\n__func__, pDmaDesc->dwOffset,\r\npDmaDesc->dwSize);\r\nif ((wIdent >= MAX_TRANSAREAS) ||\r\n(!pdx->rTransDef[wIdent].bUsed) ||\r\n(pDmaDesc->dwOffset > pdx->rTransDef[wIdent].dwLength) ||\r\n((pDmaDesc->dwOffset +\r\npDmaDesc->dwSize) >\r\n(pdx->rTransDef[wIdent].\r\ndwLength))) {\r\nbResult = false;\r\ndev_dbg(&pdx->interface->dev,\r\n"%s bad param - id %d, bUsed %d, offset %d, size %d, area length %d",\r\n__func__, wIdent,\r\npdx->rTransDef[wIdent].\r\nbUsed,\r\npDmaDesc->dwOffset,\r\npDmaDesc->dwSize,\r\npdx->rTransDef[wIdent].\r\ndwLength);\r\n}\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\n} else\r\nbResult = false;\r\nif (!bResult)\r\ndev_err(&pdx->interface->dev, "%s error reading Esc sequence",\r\n__func__);\r\nreturn bResult;\r\n}\r\nstatic int Handle1401Esc(DEVICE_EXTENSION *pdx, char *pCh,\r\nunsigned int dwCount)\r\n{\r\nint iReturn = U14ERR_FAIL;\r\nif (pCh[0] == '?') {\r\n} else {\r\nspin_lock(&pdx->stagedLock);\r\nif (ReadDMAInfo(&pdx->rDMAInfo, pdx, pCh, dwCount)) {\r\nunsigned short wTransType = pdx->rDMAInfo.wTransType;\r\ndev_dbg(&pdx->interface->dev,\r\n"%s xfer to %s, offset %d, length %d", __func__,\r\npdx->rDMAInfo.bOutWard ? "1401" : "host",\r\npdx->rDMAInfo.dwOffset, pdx->rDMAInfo.dwSize);\r\nif (pdx->bXFerWaiting) {\r\ndev_err(&pdx->interface->dev,\r\n"ERROR: DMA setup while transfer still waiting");\r\nspin_unlock(&pdx->stagedLock);\r\n} else {\r\nif ((wTransType == TM_EXTTOHOST)\r\n|| (wTransType == TM_EXTTO1401)) {\r\niReturn =\r\nReadWriteMem(pdx,\r\n!pdx->rDMAInfo.\r\nbOutWard,\r\npdx->rDMAInfo.wIdent,\r\npdx->rDMAInfo.dwOffset,\r\npdx->rDMAInfo.dwSize);\r\nif (iReturn != U14ERR_NOERROR)\r\ndev_err(&pdx->interface->dev,\r\n"%s ReadWriteMem() failed %d",\r\n__func__, iReturn);\r\n} else\r\ndev_err(&pdx->interface->dev,\r\n"%s Unknown block xfer type %d",\r\n__func__, wTransType);\r\n}\r\n} else\r\ndev_err(&pdx->interface->dev, "%s ReadDMAInfo() fail",\r\n__func__);\r\nspin_unlock(&pdx->stagedLock);\r\n}\r\ndev_dbg(&pdx->interface->dev, "%s returns %d", __func__, iReturn);\r\nreturn iReturn;\r\n}\r\nstatic void ced_readchar_callback(struct urb *pUrb)\r\n{\r\nDEVICE_EXTENSION *pdx = pUrb->context;\r\nint nGot = pUrb->actual_length;\r\nif (pUrb->status) {\r\nint nPipe = pdx->nPipes == 4 ? 1 : 0;\r\nif (!\r\n(pUrb->status == -ENOENT || pUrb->status == -ECONNRESET\r\n|| pUrb->status == -ESHUTDOWN)) {\r\ndev_err(&pdx->interface->dev,\r\n"%s - nonzero write bulk status received: %d",\r\n__func__, pUrb->status);\r\n} else\r\ndev_dbg(&pdx->interface->dev,\r\n"%s - 0 chars pUrb->status=%d (shutdown?)",\r\n__func__, pUrb->status);\r\nspin_lock(&pdx->err_lock);\r\npdx->errors = pUrb->status;\r\nspin_unlock(&pdx->err_lock);\r\nnGot = 0;\r\nspin_lock(&pdx->charInLock);\r\npdx->bPipeError[nPipe] = 1;\r\n} else {\r\nif ((nGot > 1) && ((pdx->pCoherCharIn[0] & 0x7f) == 0x1b)) {\r\nHandle1401Esc(pdx, &pdx->pCoherCharIn[1], nGot - 1);\r\nspin_lock(&pdx->charInLock);\r\n} else {\r\nspin_lock(&pdx->charInLock);\r\nif (nGot > 0) {\r\nunsigned int i;\r\nif (nGot < INBUF_SZ) {\r\npdx->pCoherCharIn[nGot] = 0;\r\ndev_dbg(&pdx->interface->dev,\r\n"%s got %d chars >%s<",\r\n__func__, nGot,\r\npdx->pCoherCharIn);\r\n}\r\nfor (i = 0; i < nGot; i++) {\r\npdx->inputBuffer[pdx->dwInBuffPut++] =\r\npdx->pCoherCharIn[i] & 0x7F;\r\nif (pdx->dwInBuffPut >= INBUF_SZ)\r\npdx->dwInBuffPut = 0;\r\n}\r\nif ((pdx->dwNumInput + nGot) <= INBUF_SZ)\r\npdx->dwNumInput += nGot;\r\n} else\r\ndev_dbg(&pdx->interface->dev, "%s read ZLP",\r\n__func__);\r\n}\r\n}\r\npdx->bReadCharsPending = false;\r\nspin_unlock(&pdx->charInLock);\r\nAllowi(pdx);\r\n}\r\nint Allowi(DEVICE_EXTENSION *pdx)\r\n{\r\nint iReturn = U14ERR_NOERROR;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pdx->charInLock, flags);\r\nif (!pdx->bInDrawDown &&\r\n!pdx->bReadCharsPending &&\r\n(pdx->dwNumInput < (INBUF_SZ / 2)) &&\r\n(pdx->dwDMAFlag == MODE_CHAR) &&\r\n(!pdx->bXFerWaiting) &&\r\n(CanAcceptIoRequests(pdx))) {\r\nunsigned int nMax = INBUF_SZ - pdx->dwNumInput;\r\nint nPipe = pdx->nPipes == 4 ? 1 : 0;\r\ndev_dbg(&pdx->interface->dev, "%s %d chars in input buffer",\r\n__func__, pdx->dwNumInput);\r\nusb_fill_int_urb(pdx->pUrbCharIn, pdx->udev,\r\nusb_rcvintpipe(pdx->udev, pdx->epAddr[nPipe]),\r\npdx->pCoherCharIn, nMax, ced_readchar_callback,\r\npdx, pdx->bInterval);\r\npdx->pUrbCharIn->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_anchor_urb(pdx->pUrbCharIn, &pdx->submitted);\r\niReturn = usb_submit_urb(pdx->pUrbCharIn, GFP_ATOMIC);\r\nif (iReturn) {\r\nusb_unanchor_urb(pdx->pUrbCharIn);\r\npdx->bPipeError[nPipe] = 1;\r\ndev_err(&pdx->interface->dev,\r\n"%s submit urb failed: %d", __func__, iReturn);\r\n} else\r\npdx->bReadCharsPending = true;\r\n}\r\nspin_unlock_irqrestore(&pdx->charInLock, flags);\r\nreturn iReturn;\r\n}\r\nstatic long ced_ioctl(struct file *file, unsigned int cmd, unsigned long ulArg)\r\n{\r\nint err = 0;\r\nDEVICE_EXTENSION *pdx = file->private_data;\r\nif (!CanAcceptIoRequests(pdx))\r\nreturn -ENODEV;\r\nif (_IOC_DIR(cmd) & _IOC_READ)\r\nerr = !access_ok(VERIFY_WRITE, (void __user *)ulArg, _IOC_SIZE(cmd));\r\nelse if (_IOC_DIR(cmd) & _IOC_WRITE)\r\nerr = !access_ok(VERIFY_READ, (void __user *)ulArg, _IOC_SIZE(cmd));\r\nif (err)\r\nreturn -EFAULT;\r\nswitch (_IOC_NR(cmd)) {\r\ncase _IOC_NR(IOCTL_CED_SENDSTRING(0)):\r\nreturn SendString(pdx, (const char __user *)ulArg,\r\n_IOC_SIZE(cmd));\r\ncase _IOC_NR(IOCTL_CED_RESET1401):\r\nreturn Reset1401(pdx);\r\ncase _IOC_NR(IOCTL_CED_GETCHAR):\r\nreturn GetChar(pdx);\r\ncase _IOC_NR(IOCTL_CED_SENDCHAR):\r\nreturn SendChar(pdx, (char)ulArg);\r\ncase _IOC_NR(IOCTL_CED_STAT1401):\r\nreturn Stat1401(pdx);\r\ncase _IOC_NR(IOCTL_CED_LINECOUNT):\r\nreturn LineCount(pdx);\r\ncase _IOC_NR(IOCTL_CED_GETSTRING(0)):\r\nreturn GetString(pdx, (char __user *)ulArg, _IOC_SIZE(cmd));\r\ncase _IOC_NR(IOCTL_CED_SETTRANSFER):\r\nreturn SetTransfer(pdx, (TRANSFERDESC __user *) ulArg);\r\ncase _IOC_NR(IOCTL_CED_UNSETTRANSFER):\r\nreturn UnsetTransfer(pdx, (int)ulArg);\r\ncase _IOC_NR(IOCTL_CED_SETEVENT):\r\nreturn SetEvent(pdx, (TRANSFEREVENT __user *) ulArg);\r\ncase _IOC_NR(IOCTL_CED_GETOUTBUFSPACE):\r\nreturn GetOutBufSpace(pdx);\r\ncase _IOC_NR(IOCTL_CED_GETBASEADDRESS):\r\nreturn -1;\r\ncase _IOC_NR(IOCTL_CED_GETDRIVERREVISION):\r\nreturn (2 << 24) | (DRIVERMAJREV << 16) | DRIVERMINREV;\r\ncase _IOC_NR(IOCTL_CED_GETTRANSFER):\r\nreturn GetTransfer(pdx, (TGET_TX_BLOCK __user *) ulArg);\r\ncase _IOC_NR(IOCTL_CED_KILLIO1401):\r\nreturn KillIO1401(pdx);\r\ncase _IOC_NR(IOCTL_CED_STATEOF1401):\r\nreturn StateOf1401(pdx);\r\ncase _IOC_NR(IOCTL_CED_GRAB1401):\r\ncase _IOC_NR(IOCTL_CED_FREE1401):\r\nreturn U14ERR_NOERROR;\r\ncase _IOC_NR(IOCTL_CED_STARTSELFTEST):\r\nreturn StartSelfTest(pdx);\r\ncase _IOC_NR(IOCTL_CED_CHECKSELFTEST):\r\nreturn CheckSelfTest(pdx, (TGET_SELFTEST __user *) ulArg);\r\ncase _IOC_NR(IOCTL_CED_TYPEOF1401):\r\nreturn TypeOf1401(pdx);\r\ncase _IOC_NR(IOCTL_CED_TRANSFERFLAGS):\r\nreturn TransferFlags(pdx);\r\ncase _IOC_NR(IOCTL_CED_DBGPEEK):\r\nreturn DbgPeek(pdx, (TDBGBLOCK __user *) ulArg);\r\ncase _IOC_NR(IOCTL_CED_DBGPOKE):\r\nreturn DbgPoke(pdx, (TDBGBLOCK __user *) ulArg);\r\ncase _IOC_NR(IOCTL_CED_DBGRAMPDATA):\r\nreturn DbgRampData(pdx, (TDBGBLOCK __user *) ulArg);\r\ncase _IOC_NR(IOCTL_CED_DBGRAMPADDR):\r\nreturn DbgRampAddr(pdx, (TDBGBLOCK __user *) ulArg);\r\ncase _IOC_NR(IOCTL_CED_DBGGETDATA):\r\nreturn DbgGetData(pdx, (TDBGBLOCK __user *) ulArg);\r\ncase _IOC_NR(IOCTL_CED_DBGSTOPLOOP):\r\nreturn DbgStopLoop(pdx);\r\ncase _IOC_NR(IOCTL_CED_FULLRESET):\r\npdx->bForceReset = true;\r\nbreak;\r\ncase _IOC_NR(IOCTL_CED_SETCIRCULAR):\r\nreturn SetCircular(pdx, (TRANSFERDESC __user *) ulArg);\r\ncase _IOC_NR(IOCTL_CED_GETCIRCBLOCK):\r\nreturn GetCircBlock(pdx, (TCIRCBLOCK __user *) ulArg);\r\ncase _IOC_NR(IOCTL_CED_FREECIRCBLOCK):\r\nreturn FreeCircBlock(pdx, (TCIRCBLOCK __user *) ulArg);\r\ncase _IOC_NR(IOCTL_CED_WAITEVENT):\r\nreturn WaitEvent(pdx, (int)(ulArg & 0xff), (int)(ulArg >> 8));\r\ncase _IOC_NR(IOCTL_CED_TESTEVENT):\r\nreturn TestEvent(pdx, (int)ulArg);\r\ndefault:\r\nreturn U14ERR_NO_SUCH_FN;\r\n}\r\nreturn U14ERR_NOERROR;\r\n}\r\nstatic int ced_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nDEVICE_EXTENSION *pdx;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint i, bcdDevice;\r\nint retval = -ENOMEM;\r\npdx = kzalloc(sizeof(*pdx), GFP_KERNEL);\r\nif (!pdx)\r\ngoto error;\r\nfor (i = 0; i < MAX_TRANSAREAS; ++i) {\r\ninit_waitqueue_head(&pdx->rTransDef[i].wqEvent);\r\n}\r\nspin_lock_init(&pdx->charOutLock);\r\nspin_lock_init(&pdx->charInLock);\r\nspin_lock_init(&pdx->stagedLock);\r\nkref_init(&pdx->kref);\r\nmutex_init(&pdx->io_mutex);\r\nspin_lock_init(&pdx->err_lock);\r\ninit_usb_anchor(&pdx->submitted);\r\npdx->udev = usb_get_dev(interface_to_usbdev(interface));\r\npdx->interface = interface;\r\nbcdDevice = pdx->udev->descriptor.bcdDevice;\r\ni = (bcdDevice >> 8);\r\nif (i == 0)\r\npdx->s1401Type = TYPEU1401;\r\nelse if ((i >= 1) && (i <= 23))\r\npdx->s1401Type = i + 2;\r\nelse {\r\ndev_err(&interface->dev, "%s Unknown device. bcdDevice = %d",\r\n__func__, bcdDevice);\r\ngoto error;\r\n}\r\niface_desc = interface->cur_altsetting;\r\npdx->nPipes = iface_desc->desc.bNumEndpoints;\r\ndev_info(&interface->dev, "1401Type=%d with %d End Points",\r\npdx->s1401Type, pdx->nPipes);\r\nif ((pdx->nPipes < 3) || (pdx->nPipes > 4))\r\ngoto error;\r\npdx->pUrbCharOut = usb_alloc_urb(0, GFP_KERNEL);\r\npdx->pUrbCharIn = usb_alloc_urb(0, GFP_KERNEL);\r\npdx->pStagedUrb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!pdx->pUrbCharOut || !pdx->pUrbCharIn || !pdx->pStagedUrb) {\r\ndev_err(&interface->dev, "%s URB alloc failed", __func__);\r\ngoto error;\r\n}\r\npdx->pCoherStagedIO =\r\nusb_alloc_coherent(pdx->udev, STAGED_SZ, GFP_KERNEL,\r\n&pdx->pStagedUrb->transfer_dma);\r\npdx->pCoherCharOut =\r\nusb_alloc_coherent(pdx->udev, OUTBUF_SZ, GFP_KERNEL,\r\n&pdx->pUrbCharOut->transfer_dma);\r\npdx->pCoherCharIn =\r\nusb_alloc_coherent(pdx->udev, INBUF_SZ, GFP_KERNEL,\r\n&pdx->pUrbCharIn->transfer_dma);\r\nif (!pdx->pCoherCharOut || !pdx->pCoherCharIn || !pdx->pCoherStagedIO) {\r\ndev_err(&interface->dev, "%s Coherent buffer alloc failed",\r\n__func__);\r\ngoto error;\r\n}\r\nfor (i = 0; i < pdx->nPipes; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\npdx->epAddr[i] = endpoint->bEndpointAddress;\r\ndev_info(&interface->dev, "Pipe %d, ep address %02x", i,\r\npdx->epAddr[i]);\r\nif (((pdx->nPipes == 3) && (i == 0)) ||\r\n((pdx->nPipes == 4) && (i == 1))) {\r\npdx->bInterval = endpoint->bInterval;\r\ndev_info(&interface->dev, "Pipe %d, bInterval = %d", i,\r\npdx->bInterval);\r\n}\r\nif (i == pdx->nPipes - 1) {\r\npdx->bIsUSB2 =\r\nle16_to_cpu(endpoint->wMaxPacketSize) > 64;\r\ndev_info(&pdx->interface->dev, "USB%d",\r\npdx->bIsUSB2 + 1);\r\n}\r\n}\r\nusb_set_intfdata(interface, pdx);\r\nretval = usb_register_dev(interface, &ced_class);\r\nif (retval) {\r\ndev_err(&interface->dev,\r\n"Not able to get a minor for this device.\n");\r\nusb_set_intfdata(interface, NULL);\r\ngoto error;\r\n}\r\ndev_info(&interface->dev,\r\n"USB CEDUSB device now attached to cedusb #%d",\r\ninterface->minor);\r\nreturn 0;\r\nerror:\r\nif (pdx)\r\nkref_put(&pdx->kref, ced_delete);\r\nreturn retval;\r\n}\r\nstatic void ced_disconnect(struct usb_interface *interface)\r\n{\r\nDEVICE_EXTENSION *pdx = usb_get_intfdata(interface);\r\nint minor = interface->minor;\r\nint i;\r\nusb_set_intfdata(interface, NULL);\r\nusb_deregister_dev(interface, &ced_class);\r\nmutex_lock(&pdx->io_mutex);\r\nced_draw_down(pdx);\r\nfor (i = 0; i < MAX_TRANSAREAS; ++i) {\r\nint iErr = ClearArea(pdx, i);\r\nif (iErr == U14ERR_UNLOCKFAIL)\r\ndev_err(&pdx->interface->dev, "%s Area %d was in used",\r\n__func__, i);\r\n}\r\npdx->interface = NULL;\r\nmutex_unlock(&pdx->io_mutex);\r\nusb_kill_anchored_urbs(&pdx->submitted);\r\nkref_put(&pdx->kref, ced_delete);\r\ndev_info(&interface->dev, "USB cedusb #%d now disconnected", minor);\r\n}\r\nvoid ced_draw_down(DEVICE_EXTENSION *pdx)\r\n{\r\nint time;\r\ndev_dbg(&pdx->interface->dev, "%s called", __func__);\r\npdx->bInDrawDown = true;\r\ntime = usb_wait_anchor_empty_timeout(&pdx->submitted, 3000);\r\nif (!time) {\r\nusb_kill_anchored_urbs(&pdx->submitted);\r\ndev_err(&pdx->interface->dev, "%s timed out", __func__);\r\n}\r\npdx->bInDrawDown = false;\r\n}\r\nstatic int ced_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nDEVICE_EXTENSION *pdx = usb_get_intfdata(intf);\r\nif (!pdx)\r\nreturn 0;\r\nced_draw_down(pdx);\r\ndev_dbg(&pdx->interface->dev, "%s called", __func__);\r\nreturn 0;\r\n}\r\nstatic int ced_resume(struct usb_interface *intf)\r\n{\r\nDEVICE_EXTENSION *pdx = usb_get_intfdata(intf);\r\nif (!pdx)\r\nreturn 0;\r\ndev_dbg(&pdx->interface->dev, "%s called", __func__);\r\nreturn 0;\r\n}\r\nstatic int ced_pre_reset(struct usb_interface *intf)\r\n{\r\nDEVICE_EXTENSION *pdx = usb_get_intfdata(intf);\r\ndev_dbg(&pdx->interface->dev, "%s", __func__);\r\nmutex_lock(&pdx->io_mutex);\r\nced_draw_down(pdx);\r\nreturn 0;\r\n}\r\nstatic int ced_post_reset(struct usb_interface *intf)\r\n{\r\nDEVICE_EXTENSION *pdx = usb_get_intfdata(intf);\r\ndev_dbg(&pdx->interface->dev, "%s", __func__);\r\npdx->errors = -EPIPE;\r\nmutex_unlock(&pdx->io_mutex);\r\nreturn 0;\r\n}
