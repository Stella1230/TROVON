static bool radeon_dig_encoder(struct drm_encoder *encoder)\r\n{\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVDS:\r\ncase ENCODER_OBJECT_ID_INTERNAL_TMDS1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_DVO1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_DDI:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY:\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:\r\ncase ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int r600_audio_chipset_supported(struct radeon_device *rdev)\r\n{\r\nreturn ASIC_IS_DCE2(rdev) && !ASIC_IS_NODCE(rdev);\r\n}\r\nstruct r600_audio_pin r600_audio_status(struct radeon_device *rdev)\r\n{\r\nstruct r600_audio_pin status;\r\nuint32_t value;\r\nvalue = RREG32(R600_AUDIO_RATE_BPS_CHANNEL);\r\nstatus.channels = (value & 0x7) + 1;\r\nswitch ((value & 0xF0) >> 4) {\r\ncase 0x0:\r\nstatus.bits_per_sample = 8;\r\nbreak;\r\ncase 0x1:\r\nstatus.bits_per_sample = 16;\r\nbreak;\r\ncase 0x2:\r\nstatus.bits_per_sample = 20;\r\nbreak;\r\ncase 0x3:\r\nstatus.bits_per_sample = 24;\r\nbreak;\r\ncase 0x4:\r\nstatus.bits_per_sample = 32;\r\nbreak;\r\ndefault:\r\ndev_err(rdev->dev, "Unknown bits per sample 0x%x, using 16\n",\r\n(int)value);\r\nstatus.bits_per_sample = 16;\r\n}\r\nif (value & 0x4000)\r\nstatus.rate = 44100;\r\nelse\r\nstatus.rate = 48000;\r\nstatus.rate *= ((value >> 11) & 0x7) + 1;\r\nstatus.rate /= ((value >> 8) & 0x7) + 1;\r\nvalue = RREG32(R600_AUDIO_STATUS_BITS);\r\nstatus.status_bits = value & 0xff;\r\nstatus.category_code = (value >> 8) & 0xff;\r\nreturn status;\r\n}\r\nvoid r600_audio_update_hdmi(struct work_struct *work)\r\n{\r\nstruct radeon_device *rdev = container_of(work, struct radeon_device,\r\naudio_work);\r\nstruct drm_device *dev = rdev->ddev;\r\nstruct r600_audio_pin audio_status = r600_audio_status(rdev);\r\nstruct drm_encoder *encoder;\r\nbool changed = false;\r\nif (rdev->audio.pin[0].channels != audio_status.channels ||\r\nrdev->audio.pin[0].rate != audio_status.rate ||\r\nrdev->audio.pin[0].bits_per_sample != audio_status.bits_per_sample ||\r\nrdev->audio.pin[0].status_bits != audio_status.status_bits ||\r\nrdev->audio.pin[0].category_code != audio_status.category_code) {\r\nrdev->audio.pin[0] = audio_status;\r\nchanged = true;\r\n}\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (!radeon_dig_encoder(encoder))\r\ncontinue;\r\nif (changed || r600_hdmi_buffer_status_changed(encoder))\r\nr600_hdmi_update_audio_settings(encoder);\r\n}\r\n}\r\nstatic void r600_audio_enable(struct radeon_device *rdev,\r\nstruct r600_audio_pin *pin,\r\nbool enable)\r\n{\r\nu32 value = 0;\r\nif (ASIC_IS_DCE4(rdev)) {\r\nif (enable) {\r\nvalue |= 0x81000000;\r\nvalue |= 0x0e1000f0;\r\n}\r\nWREG32(EVERGREEN_AUDIO_ENABLE, value);\r\n} else {\r\nWREG32_P(R600_AUDIO_ENABLE,\r\nenable ? 0x81000000 : 0x0, ~0x81000000);\r\n}\r\nDRM_INFO("%s audio %d support\n", enable ? "Enabling" : "Disabling", pin->id);\r\n}\r\nint r600_audio_init(struct radeon_device *rdev)\r\n{\r\nif (!radeon_audio || !r600_audio_chipset_supported(rdev))\r\nreturn 0;\r\nrdev->audio.enabled = true;\r\nrdev->audio.num_pins = 1;\r\nrdev->audio.pin[0].channels = -1;\r\nrdev->audio.pin[0].rate = -1;\r\nrdev->audio.pin[0].bits_per_sample = -1;\r\nrdev->audio.pin[0].status_bits = 0;\r\nrdev->audio.pin[0].category_code = 0;\r\nrdev->audio.pin[0].id = 0;\r\nr600_audio_enable(rdev, &rdev->audio.pin[0], true);\r\nreturn 0;\r\n}\r\nvoid r600_audio_fini(struct radeon_device *rdev)\r\n{\r\nif (!rdev->audio.enabled)\r\nreturn;\r\nr600_audio_enable(rdev, &rdev->audio.pin[0], false);\r\nrdev->audio.enabled = false;\r\n}\r\nstruct r600_audio_pin *r600_audio_get_pin(struct radeon_device *rdev)\r\n{\r\nreturn &rdev->audio.pin[0];\r\n}
