void show_mem(unsigned int filter)\r\n{\r\nprintk("Mem-info:\n");\r\nshow_free_areas(filter);\r\nprintk("Free swap: %6ldkB\n",\r\nget_nr_swap_pages() << (PAGE_SHIFT-10));\r\nprintk("%ld pages of RAM\n", totalram_pages);\r\nprintk("%ld free pages\n", nr_free_pages());\r\n}\r\nunsigned long calc_highpages(void)\r\n{\r\nint i;\r\nint nr = 0;\r\nfor (i = 0; sp_banks[i].num_bytes != 0; i++) {\r\nunsigned long start_pfn = sp_banks[i].base_addr >> PAGE_SHIFT;\r\nunsigned long end_pfn = (sp_banks[i].base_addr + sp_banks[i].num_bytes) >> PAGE_SHIFT;\r\nif (end_pfn <= max_low_pfn)\r\ncontinue;\r\nif (start_pfn < max_low_pfn)\r\nstart_pfn = max_low_pfn;\r\nnr += end_pfn - start_pfn;\r\n}\r\nreturn nr;\r\n}\r\nstatic unsigned long calc_max_low_pfn(void)\r\n{\r\nint i;\r\nunsigned long tmp = pfn_base + (SRMMU_MAXMEM >> PAGE_SHIFT);\r\nunsigned long curr_pfn, last_pfn;\r\nlast_pfn = (sp_banks[0].base_addr + sp_banks[0].num_bytes) >> PAGE_SHIFT;\r\nfor (i = 1; sp_banks[i].num_bytes != 0; i++) {\r\ncurr_pfn = sp_banks[i].base_addr >> PAGE_SHIFT;\r\nif (curr_pfn >= tmp) {\r\nif (last_pfn < tmp)\r\ntmp = last_pfn;\r\nbreak;\r\n}\r\nlast_pfn = (sp_banks[i].base_addr + sp_banks[i].num_bytes) >> PAGE_SHIFT;\r\n}\r\nreturn tmp;\r\n}\r\nunsigned long __init bootmem_init(unsigned long *pages_avail)\r\n{\r\nunsigned long bootmap_size, start_pfn;\r\nunsigned long end_of_phys_memory = 0UL;\r\nunsigned long bootmap_pfn, bytes_avail, size;\r\nint i;\r\nbytes_avail = 0UL;\r\nfor (i = 0; sp_banks[i].num_bytes != 0; i++) {\r\nend_of_phys_memory = sp_banks[i].base_addr +\r\nsp_banks[i].num_bytes;\r\nbytes_avail += sp_banks[i].num_bytes;\r\nif (cmdline_memory_size) {\r\nif (bytes_avail > cmdline_memory_size) {\r\nunsigned long slack = bytes_avail - cmdline_memory_size;\r\nbytes_avail -= slack;\r\nend_of_phys_memory -= slack;\r\nsp_banks[i].num_bytes -= slack;\r\nif (sp_banks[i].num_bytes == 0) {\r\nsp_banks[i].base_addr = 0xdeadbeef;\r\n} else {\r\nsp_banks[i+1].num_bytes = 0;\r\nsp_banks[i+1].base_addr = 0xdeadbeef;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nstart_pfn = (unsigned long)__pa(PAGE_ALIGN((unsigned long) &_end));\r\nstart_pfn >>= PAGE_SHIFT;\r\nbootmap_pfn = start_pfn;\r\nmax_pfn = end_of_phys_memory >> PAGE_SHIFT;\r\nmax_low_pfn = max_pfn;\r\nhighstart_pfn = highend_pfn = max_pfn;\r\nif (max_low_pfn > pfn_base + (SRMMU_MAXMEM >> PAGE_SHIFT)) {\r\nhighstart_pfn = pfn_base + (SRMMU_MAXMEM >> PAGE_SHIFT);\r\nmax_low_pfn = calc_max_low_pfn();\r\nprintk(KERN_NOTICE "%ldMB HIGHMEM available.\n",\r\ncalc_highpages() >> (20 - PAGE_SHIFT));\r\n}\r\n#ifdef CONFIG_BLK_DEV_INITRD\r\nif (sparc_ramdisk_image) {\r\nif (sparc_ramdisk_image >= (unsigned long)&_end - 2 * PAGE_SIZE)\r\nsparc_ramdisk_image -= KERNBASE;\r\ninitrd_start = sparc_ramdisk_image + phys_base;\r\ninitrd_end = initrd_start + sparc_ramdisk_size;\r\nif (initrd_end > end_of_phys_memory) {\r\nprintk(KERN_CRIT "initrd extends beyond end of memory "\r\n"(0x%016lx > 0x%016lx)\ndisabling initrd\n",\r\ninitrd_end, end_of_phys_memory);\r\ninitrd_start = 0;\r\n}\r\nif (initrd_start) {\r\nif (initrd_start >= (start_pfn << PAGE_SHIFT) &&\r\ninitrd_start < (start_pfn << PAGE_SHIFT) + 2 * PAGE_SIZE)\r\nbootmap_pfn = PAGE_ALIGN (initrd_end) >> PAGE_SHIFT;\r\n}\r\n}\r\n#endif\r\nbootmap_size = init_bootmem_node(NODE_DATA(0), bootmap_pfn, pfn_base,\r\nmax_low_pfn);\r\n*pages_avail = 0;\r\nfor (i = 0; sp_banks[i].num_bytes != 0; i++) {\r\nunsigned long curr_pfn, last_pfn;\r\ncurr_pfn = sp_banks[i].base_addr >> PAGE_SHIFT;\r\nif (curr_pfn >= max_low_pfn)\r\nbreak;\r\nlast_pfn = (sp_banks[i].base_addr + sp_banks[i].num_bytes) >> PAGE_SHIFT;\r\nif (last_pfn > max_low_pfn)\r\nlast_pfn = max_low_pfn;\r\nif (last_pfn <= curr_pfn)\r\ncontinue;\r\nsize = (last_pfn - curr_pfn) << PAGE_SHIFT;\r\n*pages_avail += last_pfn - curr_pfn;\r\nfree_bootmem(sp_banks[i].base_addr, size);\r\n}\r\n#ifdef CONFIG_BLK_DEV_INITRD\r\nif (initrd_start) {\r\nsize = initrd_end - initrd_start;\r\nreserve_bootmem(initrd_start, size, BOOTMEM_DEFAULT);\r\n*pages_avail -= PAGE_ALIGN(size) >> PAGE_SHIFT;\r\ninitrd_start = (initrd_start - phys_base) + PAGE_OFFSET;\r\ninitrd_end = (initrd_end - phys_base) + PAGE_OFFSET;\r\n}\r\n#endif\r\nsize = (start_pfn << PAGE_SHIFT) - phys_base;\r\nreserve_bootmem(phys_base, size, BOOTMEM_DEFAULT);\r\n*pages_avail -= PAGE_ALIGN(size) >> PAGE_SHIFT;\r\nsize = bootmap_size;\r\nreserve_bootmem((bootmap_pfn << PAGE_SHIFT), size, BOOTMEM_DEFAULT);\r\n*pages_avail -= PAGE_ALIGN(size) >> PAGE_SHIFT;\r\nreturn max_pfn;\r\n}\r\nvoid __init paging_init(void)\r\n{\r\nsrmmu_paging_init();\r\nprom_build_devicetree();\r\nof_fill_in_cpu_data();\r\ndevice_scan();\r\n}\r\nstatic void __init taint_real_pages(void)\r\n{\r\nint i;\r\nfor (i = 0; sp_banks[i].num_bytes; i++) {\r\nunsigned long start, end;\r\nstart = sp_banks[i].base_addr;\r\nend = start + sp_banks[i].num_bytes;\r\nwhile (start < end) {\r\nset_bit(start >> 20, sparc_valid_addr_bitmap);\r\nstart += PAGE_SIZE;\r\n}\r\n}\r\n}\r\nstatic void map_high_region(unsigned long start_pfn, unsigned long end_pfn)\r\n{\r\nunsigned long tmp;\r\n#ifdef CONFIG_DEBUG_HIGHMEM\r\nprintk("mapping high region %08lx - %08lx\n", start_pfn, end_pfn);\r\n#endif\r\nfor (tmp = start_pfn; tmp < end_pfn; tmp++)\r\nfree_highmem_page(pfn_to_page(tmp));\r\n}\r\nvoid __init mem_init(void)\r\n{\r\nint i;\r\nif (PKMAP_BASE+LAST_PKMAP*PAGE_SIZE >= FIXADDR_START) {\r\nprom_printf("BUG: fixmap and pkmap areas overlap\n");\r\nprom_printf("pkbase: 0x%lx pkend: 0x%lx fixstart 0x%lx\n",\r\nPKMAP_BASE,\r\n(unsigned long)PKMAP_BASE+LAST_PKMAP*PAGE_SIZE,\r\nFIXADDR_START);\r\nprom_printf("Please mail sparclinux@vger.kernel.org.\n");\r\nprom_halt();\r\n}\r\nmemset((void *)&empty_zero_page, 0, PAGE_SIZE);\r\ni = last_valid_pfn >> ((20 - PAGE_SHIFT) + 5);\r\ni += 1;\r\nsparc_valid_addr_bitmap = (unsigned long *)\r\n__alloc_bootmem(i << 2, SMP_CACHE_BYTES, 0UL);\r\nif (sparc_valid_addr_bitmap == NULL) {\r\nprom_printf("mem_init: Cannot alloc valid_addr_bitmap.\n");\r\nprom_halt();\r\n}\r\nmemset(sparc_valid_addr_bitmap, 0, i << 2);\r\ntaint_real_pages();\r\nmax_mapnr = last_valid_pfn - pfn_base;\r\nhigh_memory = __va(max_low_pfn << PAGE_SHIFT);\r\nfree_all_bootmem();\r\nfor (i = 0; sp_banks[i].num_bytes != 0; i++) {\r\nunsigned long start_pfn = sp_banks[i].base_addr >> PAGE_SHIFT;\r\nunsigned long end_pfn = (sp_banks[i].base_addr + sp_banks[i].num_bytes) >> PAGE_SHIFT;\r\nif (end_pfn <= highstart_pfn)\r\ncontinue;\r\nif (start_pfn < highstart_pfn)\r\nstart_pfn = highstart_pfn;\r\nmap_high_region(start_pfn, end_pfn);\r\n}\r\nmem_init_print_info(NULL);\r\n}\r\nvoid free_initmem (void)\r\n{\r\nfree_initmem_default(POISON_FREE_INITMEM);\r\n}\r\nvoid free_initrd_mem(unsigned long start, unsigned long end)\r\n{\r\nfree_reserved_area((void *)start, (void *)end, POISON_FREE_INITMEM,\r\n"initrd");\r\n}\r\nvoid sparc_flush_page_to_ram(struct page *page)\r\n{\r\nunsigned long vaddr = (unsigned long)page_address(page);\r\nif (vaddr)\r\n__flush_page_to_ram(vaddr);\r\n}
