static void __init db1300_gpio_config(void)\r\n{\r\nint *i;\r\ni = &db1300_dev_pins[0];\r\nwhile (*i != -1)\r\nau1300_pinfunc_to_dev(*i++);\r\ni = &db1300_gpio_pins[0];\r\nwhile (*i != -1)\r\nau1300_gpio_direction_input(*i++);\r\nau1300_set_dbdma_gpio(1, AU1300_PIN_FG3AUX);\r\n}\r\nstatic void au1300_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nunsigned long ioaddr = (unsigned long)this->IO_ADDR_W;\r\nioaddr &= 0xffffff00;\r\nif (ctrl & NAND_CLE) {\r\nioaddr += MEM_STNAND_CMD;\r\n} else if (ctrl & NAND_ALE) {\r\nioaddr += MEM_STNAND_ADDR;\r\n} else {\r\nioaddr += MEM_STNAND_DATA;\r\n}\r\nthis->IO_ADDR_R = this->IO_ADDR_W = (void __iomem *)ioaddr;\r\nif (cmd != NAND_CMD_NONE) {\r\n__raw_writeb(cmd, this->IO_ADDR_W);\r\nwmb();\r\n}\r\n}\r\nstatic int au1300_nand_device_ready(struct mtd_info *mtd)\r\n{\r\nreturn __raw_readl((void __iomem *)MEM_STSTAT) & 1;\r\n}\r\nstatic irqreturn_t db1300_mmc_cd(int irq, void *ptr)\r\n{\r\nvoid(*mmc_cd)(struct mmc_host *, unsigned long);\r\nif (irq == DB1300_SD1_INSERT_INT) {\r\ndisable_irq_nosync(DB1300_SD1_INSERT_INT);\r\nenable_irq(DB1300_SD1_EJECT_INT);\r\n} else {\r\ndisable_irq_nosync(DB1300_SD1_EJECT_INT);\r\nenable_irq(DB1300_SD1_INSERT_INT);\r\n}\r\nmmc_cd = symbol_get(mmc_detect_change);\r\nmmc_cd(ptr, msecs_to_jiffies(500));\r\nsymbol_put(mmc_detect_change);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int db1300_mmc_card_readonly(void *mmc_host)\r\n{\r\nreturn bcsr_read(BCSR_STATUS) & BCSR_STATUS_SD0WP;\r\n}\r\nstatic int db1300_mmc_card_inserted(void *mmc_host)\r\n{\r\nreturn bcsr_read(BCSR_SIGSTAT) & (1 << 12);\r\n}\r\nstatic int db1300_mmc_cd_setup(void *mmc_host, int en)\r\n{\r\nint ret;\r\nif (en) {\r\nret = request_irq(DB1300_SD1_INSERT_INT, db1300_mmc_cd, 0,\r\n"sd_insert", mmc_host);\r\nif (ret)\r\ngoto out;\r\nret = request_irq(DB1300_SD1_EJECT_INT, db1300_mmc_cd, 0,\r\n"sd_eject", mmc_host);\r\nif (ret) {\r\nfree_irq(DB1300_SD1_INSERT_INT, mmc_host);\r\ngoto out;\r\n}\r\nif (db1300_mmc_card_inserted(mmc_host))\r\nenable_irq(DB1300_SD1_EJECT_INT);\r\nelse\r\nenable_irq(DB1300_SD1_INSERT_INT);\r\n} else {\r\nfree_irq(DB1300_SD1_INSERT_INT, mmc_host);\r\nfree_irq(DB1300_SD1_EJECT_INT, mmc_host);\r\n}\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void db1300_mmcled_set(struct led_classdev *led,\r\nenum led_brightness brightness)\r\n{\r\nif (brightness != LED_OFF)\r\nbcsr_mod(BCSR_LEDS, BCSR_LEDS_LED0, 0);\r\nelse\r\nbcsr_mod(BCSR_LEDS, 0, BCSR_LEDS_LED0);\r\n}\r\nstatic int db1300_movinand_inserted(void *mmc_host)\r\n{\r\nreturn 0;\r\n}\r\nstatic int db1300_movinand_readonly(void *mmc_host)\r\n{\r\nreturn 0;\r\n}\r\nstatic void db1300_movinand_led_set(struct led_classdev *led,\r\nenum led_brightness brightness)\r\n{\r\nif (brightness != LED_OFF)\r\nbcsr_mod(BCSR_LEDS, BCSR_LEDS_LED1, 0);\r\nelse\r\nbcsr_mod(BCSR_LEDS, 0, BCSR_LEDS_LED1);\r\n}\r\nstatic int db1300fb_panel_index(void)\r\n{\r\nreturn 9;\r\n}\r\nstatic int db1300fb_panel_init(void)\r\n{\r\nbcsr_mod(BCSR_BOARD, BCSR_BOARD_LCDVEE | BCSR_BOARD_LCDVDD,\r\nBCSR_BOARD_LCDBL);\r\nreturn 0;\r\n}\r\nstatic int db1300fb_panel_shutdown(void)\r\n{\r\nbcsr_mod(BCSR_BOARD, BCSR_BOARD_LCDBL,\r\nBCSR_BOARD_LCDVEE | BCSR_BOARD_LCDVDD);\r\nreturn 0;\r\n}\r\nint __init db1300_dev_setup(void)\r\n{\r\nint swapped, cpldirq;\r\ncpldirq = au1300_gpio_to_irq(AU1300_PIN_EXTCLK1);\r\nirq_set_irq_type(cpldirq, IRQ_TYPE_LEVEL_HIGH);\r\nbcsr_init_irq(DB1300_FIRST_INT, DB1300_LAST_INT, cpldirq);\r\nirq_set_status_flags(DB1300_SD1_INSERT_INT, IRQ_NOAUTOEN);\r\nirq_set_status_flags(DB1300_SD1_EJECT_INT, IRQ_NOAUTOEN);\r\nirq_set_status_flags(DB1300_CF_INSERT_INT, IRQ_NOAUTOEN);\r\nirq_set_status_flags(DB1300_CF_EJECT_INT, IRQ_NOAUTOEN);\r\nprom_get_ethernet_addr(&db1300_eth_config.mac[0]);\r\ni2c_register_board_info(0, db1300_i2c_devs,\r\nARRAY_SIZE(db1300_i2c_devs));\r\n__raw_writel(PSC_SEL_CLK_SERCLK,\r\n(void __iomem *)KSEG1ADDR(AU1300_PSC1_PHYS_ADDR) + PSC_SEL_OFFSET);\r\nwmb();\r\n__raw_writel(PSC_SEL_CLK_SERCLK,\r\n(void __iomem *)KSEG1ADDR(AU1300_PSC2_PHYS_ADDR) + PSC_SEL_OFFSET);\r\nwmb();\r\n__raw_writel(PSC_SEL_CLK_INTCLK,\r\n(void __iomem *)KSEG1ADDR(AU1300_PSC3_PHYS_ADDR) + PSC_SEL_OFFSET);\r\nwmb();\r\nbcsr_mod(BCSR_RESETS, 0, BCSR_RESETS_USBHPWR | BCSR_RESETS_OTGPWR);\r\ndb1x_register_pcmcia_socket(\r\nAU1000_PCMCIA_ATTR_PHYS_ADDR,\r\nAU1000_PCMCIA_ATTR_PHYS_ADDR + 0x00400000 - 1,\r\nAU1000_PCMCIA_MEM_PHYS_ADDR,\r\nAU1000_PCMCIA_MEM_PHYS_ADDR + 0x00400000 - 1,\r\nAU1000_PCMCIA_IO_PHYS_ADDR,\r\nAU1000_PCMCIA_IO_PHYS_ADDR + 0x00010000 - 1,\r\nDB1300_CF_INT, DB1300_CF_INSERT_INT, 0, DB1300_CF_EJECT_INT, 1);\r\nswapped = bcsr_read(BCSR_STATUS) & BCSR_STATUS_DB1200_SWAPBOOT;\r\ndb1x_register_norflash(64 << 20, 2, swapped);\r\nreturn platform_add_devices(db1300_dev, ARRAY_SIZE(db1300_dev));\r\n}\r\nint __init db1300_board_setup(void)\r\n{\r\nunsigned short whoami;\r\ndb1300_gpio_config();\r\nbcsr_init(DB1300_BCSR_PHYS_ADDR,\r\nDB1300_BCSR_PHYS_ADDR + DB1300_BCSR_HEXLED_OFS);\r\nwhoami = bcsr_read(BCSR_WHOAMI);\r\nprintk(KERN_INFO "NetLogic DBAu1300 Development Platform.\n\t"\r\n"BoardID %d CPLD Rev %d DaughtercardID %d\n",\r\nBCSR_WHOAMI_BOARD(whoami), BCSR_WHOAMI_CPLD(whoami),\r\nBCSR_WHOAMI_DCID(whoami));\r\nalchemy_uart_enable(AU1300_UART0_PHYS_ADDR);\r\nalchemy_uart_enable(AU1300_UART1_PHYS_ADDR);\r\nalchemy_uart_enable(AU1300_UART3_PHYS_ADDR);\r\nreturn 0;\r\n}
