static enum drm_connector_status imx_pd_connector_detect(\r\nstruct drm_connector *connector, bool force)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nstatic void imx_pd_connector_destroy(struct drm_connector *connector)\r\n{\r\n}\r\nstatic int imx_pd_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct imx_parallel_display *imxpd = con_to_imxpd(connector);\r\nstruct device_node *np = imxpd->dev->of_node;\r\nint num_modes = 0;\r\nif (imxpd->edid) {\r\ndrm_mode_connector_update_edid_property(connector, imxpd->edid);\r\nnum_modes = drm_add_edid_modes(connector, imxpd->edid);\r\n}\r\nif (imxpd->mode_valid) {\r\nstruct drm_display_mode *mode = drm_mode_create(connector->dev);\r\ndrm_mode_copy(mode, &imxpd->mode);\r\nmode->type |= DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,\r\ndrm_mode_probed_add(connector, mode);\r\nnum_modes++;\r\n}\r\nif (np) {\r\nstruct drm_display_mode *mode = drm_mode_create(connector->dev);\r\nof_get_drm_display_mode(np, &imxpd->mode, 0);\r\ndrm_mode_copy(mode, &imxpd->mode);\r\nmode->type |= DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,\r\ndrm_mode_probed_add(connector, mode);\r\nnum_modes++;\r\n}\r\nreturn num_modes;\r\n}\r\nstatic int imx_pd_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nreturn 0;\r\n}\r\nstatic struct drm_encoder *imx_pd_connector_best_encoder(\r\nstruct drm_connector *connector)\r\n{\r\nstruct imx_parallel_display *imxpd = con_to_imxpd(connector);\r\nreturn &imxpd->encoder;\r\n}\r\nstatic void imx_pd_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\n}\r\nstatic bool imx_pd_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void imx_pd_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\nstruct imx_parallel_display *imxpd = enc_to_imxpd(encoder);\r\nimx_drm_crtc_panel_format(encoder->crtc, DRM_MODE_ENCODER_NONE,\r\nimxpd->interface_pix_fmt);\r\n}\r\nstatic void imx_pd_encoder_commit(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void imx_pd_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\n}\r\nstatic void imx_pd_encoder_disable(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void imx_pd_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic int imx_pd_register(struct imx_parallel_display *imxpd)\r\n{\r\nint ret;\r\ndrm_mode_connector_attach_encoder(&imxpd->connector, &imxpd->encoder);\r\nimxpd->connector.funcs = &imx_pd_connector_funcs;\r\nimxpd->encoder.funcs = &imx_pd_encoder_funcs;\r\nimxpd->encoder.encoder_type = DRM_MODE_ENCODER_NONE;\r\nimxpd->connector.connector_type = DRM_MODE_CONNECTOR_VGA;\r\ndrm_encoder_helper_add(&imxpd->encoder, &imx_pd_encoder_helper_funcs);\r\nret = imx_drm_add_encoder(&imxpd->encoder, &imxpd->imx_drm_encoder,\r\nTHIS_MODULE);\r\nif (ret) {\r\ndev_err(imxpd->dev, "adding encoder failed with %d\n", ret);\r\nreturn ret;\r\n}\r\ndrm_connector_helper_add(&imxpd->connector,\r\n&imx_pd_connector_helper_funcs);\r\nret = imx_drm_add_connector(&imxpd->connector,\r\n&imxpd->imx_drm_connector, THIS_MODULE);\r\nif (ret) {\r\nimx_drm_remove_encoder(imxpd->imx_drm_encoder);\r\ndev_err(imxpd->dev, "adding connector failed with %d\n", ret);\r\nreturn ret;\r\n}\r\nimxpd->connector.encoder = &imxpd->encoder;\r\nreturn 0;\r\n}\r\nstatic int imx_pd_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst u8 *edidp;\r\nstruct imx_parallel_display *imxpd;\r\nint ret;\r\nconst char *fmt;\r\nimxpd = devm_kzalloc(&pdev->dev, sizeof(*imxpd), GFP_KERNEL);\r\nif (!imxpd)\r\nreturn -ENOMEM;\r\nedidp = of_get_property(np, "edid", &imxpd->edid_len);\r\nif (edidp)\r\nimxpd->edid = kmemdup(edidp, imxpd->edid_len, GFP_KERNEL);\r\nret = of_property_read_string(np, "interface-pix-fmt", &fmt);\r\nif (!ret) {\r\nif (!strcmp(fmt, "rgb24"))\r\nimxpd->interface_pix_fmt = V4L2_PIX_FMT_RGB24;\r\nelse if (!strcmp(fmt, "rgb565"))\r\nimxpd->interface_pix_fmt = V4L2_PIX_FMT_RGB565;\r\nelse if (!strcmp(fmt, "bgr666"))\r\nimxpd->interface_pix_fmt = V4L2_PIX_FMT_BGR666;\r\n}\r\nimxpd->dev = &pdev->dev;\r\nret = imx_pd_register(imxpd);\r\nif (ret)\r\nreturn ret;\r\nret = imx_drm_encoder_add_possible_crtcs(imxpd->imx_drm_encoder, np);\r\nplatform_set_drvdata(pdev, imxpd);\r\nreturn 0;\r\n}\r\nstatic int imx_pd_remove(struct platform_device *pdev)\r\n{\r\nstruct imx_parallel_display *imxpd = platform_get_drvdata(pdev);\r\nstruct drm_connector *connector = &imxpd->connector;\r\nstruct drm_encoder *encoder = &imxpd->encoder;\r\ndrm_mode_connector_detach_encoder(connector, encoder);\r\nimx_drm_remove_connector(imxpd->imx_drm_connector);\r\nimx_drm_remove_encoder(imxpd->imx_drm_encoder);\r\nreturn 0;\r\n}
