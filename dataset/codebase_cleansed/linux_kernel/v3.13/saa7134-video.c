static const struct v4l2_queryctrl* ctrl_by_id(unsigned int id)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < CTRLS; i++)\r\nif (video_ctrls[i].id == id)\r\nreturn video_ctrls+i;\r\nreturn NULL;\r\n}\r\nstatic struct saa7134_format* format_by_fourcc(unsigned int fourcc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < FORMATS; i++)\r\nif (formats[i].fourcc == fourcc)\r\nreturn formats+i;\r\nreturn NULL;\r\n}\r\nstatic int res_get(struct saa7134_dev *dev, struct saa7134_fh *fh, unsigned int bit)\r\n{\r\nif (fh->resources & bit)\r\nreturn 1;\r\nmutex_lock(&dev->lock);\r\nif (dev->resources & bit) {\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nfh->resources |= bit;\r\ndev->resources |= bit;\r\ndprintk("res: get %d\n",bit);\r\nmutex_unlock(&dev->lock);\r\nreturn 1;\r\n}\r\nstatic int res_check(struct saa7134_fh *fh, unsigned int bit)\r\n{\r\nreturn (fh->resources & bit);\r\n}\r\nstatic int res_locked(struct saa7134_dev *dev, unsigned int bit)\r\n{\r\nreturn (dev->resources & bit);\r\n}\r\nstatic\r\nvoid res_free(struct saa7134_dev *dev, struct saa7134_fh *fh, unsigned int bits)\r\n{\r\nBUG_ON((fh->resources & bits) != bits);\r\nmutex_lock(&dev->lock);\r\nfh->resources &= ~bits;\r\ndev->resources &= ~bits;\r\ndprintk("res: put %d\n",bits);\r\nmutex_unlock(&dev->lock);\r\n}\r\nstatic void set_tvnorm(struct saa7134_dev *dev, struct saa7134_tvnorm *norm)\r\n{\r\ndprintk("set tv norm = %s\n",norm->name);\r\ndev->tvnorm = norm;\r\ndev->crop_bounds.left = norm->h_start;\r\ndev->crop_defrect.left = norm->h_start;\r\ndev->crop_bounds.width = norm->h_stop - norm->h_start +1;\r\ndev->crop_defrect.width = norm->h_stop - norm->h_start +1;\r\ndev->crop_bounds.top = (norm->vbi_v_stop_0+1)*2;\r\ndev->crop_defrect.top = norm->video_v_start*2;\r\ndev->crop_bounds.height = ((norm->id & V4L2_STD_525_60) ? 524 : 624)\r\n- dev->crop_bounds.top;\r\ndev->crop_defrect.height = (norm->video_v_stop - norm->video_v_start +1)*2;\r\ndev->crop_current = dev->crop_defrect;\r\nsaa7134_set_tvnorm_hw(dev);\r\n}\r\nstatic void video_mux(struct saa7134_dev *dev, int input)\r\n{\r\ndprintk("video input = %d [%s]\n", input, card_in(dev, input).name);\r\ndev->ctl_input = input;\r\nset_tvnorm(dev, dev->tvnorm);\r\nsaa7134_tvaudio_setinput(dev, &card_in(dev, input));\r\n}\r\nstatic void saa7134_set_decoder(struct saa7134_dev *dev)\r\n{\r\nint luma_control, sync_control, mux;\r\nstruct saa7134_tvnorm *norm = dev->tvnorm;\r\nmux = card_in(dev, dev->ctl_input).vmux;\r\nluma_control = norm->luma_control;\r\nsync_control = norm->sync_control;\r\nif (mux > 5)\r\nluma_control |= 0x80;\r\nif (noninterlaced || dev->nosignal)\r\nsync_control |= 0x20;\r\nsaa_writeb(SAA7134_INCR_DELAY, 0x08);\r\nsaa_writeb(SAA7134_ANALOG_IN_CTRL1, 0xc0 | mux);\r\nsaa_writeb(SAA7134_ANALOG_IN_CTRL2, 0x00);\r\nsaa_writeb(SAA7134_ANALOG_IN_CTRL3, 0x90);\r\nsaa_writeb(SAA7134_ANALOG_IN_CTRL4, 0x90);\r\nsaa_writeb(SAA7134_HSYNC_START, 0xeb);\r\nsaa_writeb(SAA7134_HSYNC_STOP, 0xe0);\r\nsaa_writeb(SAA7134_SOURCE_TIMING1, norm->src_timing);\r\nsaa_writeb(SAA7134_SYNC_CTRL, sync_control);\r\nsaa_writeb(SAA7134_LUMA_CTRL, luma_control);\r\nsaa_writeb(SAA7134_DEC_LUMA_BRIGHT, dev->ctl_bright);\r\nsaa_writeb(SAA7134_DEC_LUMA_CONTRAST,\r\ndev->ctl_invert ? -dev->ctl_contrast : dev->ctl_contrast);\r\nsaa_writeb(SAA7134_DEC_CHROMA_SATURATION,\r\ndev->ctl_invert ? -dev->ctl_saturation : dev->ctl_saturation);\r\nsaa_writeb(SAA7134_DEC_CHROMA_HUE, dev->ctl_hue);\r\nsaa_writeb(SAA7134_CHROMA_CTRL1, norm->chroma_ctrl1);\r\nsaa_writeb(SAA7134_CHROMA_GAIN, norm->chroma_gain);\r\nsaa_writeb(SAA7134_CHROMA_CTRL2, norm->chroma_ctrl2);\r\nsaa_writeb(SAA7134_MODE_DELAY_CTRL, 0x00);\r\nsaa_writeb(SAA7134_ANALOG_ADC, 0x01);\r\nsaa_writeb(SAA7134_VGATE_START, 0x11);\r\nsaa_writeb(SAA7134_VGATE_STOP, 0xfe);\r\nsaa_writeb(SAA7134_MISC_VGATE_MSB, norm->vgate_misc);\r\nsaa_writeb(SAA7134_RAW_DATA_GAIN, 0x40);\r\nsaa_writeb(SAA7134_RAW_DATA_OFFSET, 0x80);\r\n}\r\nvoid saa7134_set_tvnorm_hw(struct saa7134_dev *dev)\r\n{\r\nsaa7134_set_decoder(dev);\r\nif (card_in(dev, dev->ctl_input).tv)\r\nsaa_call_all(dev, core, s_std, dev->tvnorm->id);\r\nsaa_call_empress(dev, core, s_std, dev->tvnorm->id);\r\n}\r\nstatic void set_h_prescale(struct saa7134_dev *dev, int task, int prescale)\r\n{\r\nstatic const struct {\r\nint xpsc;\r\nint xacl;\r\nint xc2_1;\r\nint xdcg;\r\nint vpfy;\r\n} vals[] = {\r\n{ 1, 0, 0, 0, 0 },\r\n{ 2, 2, 1, 2, 2 },\r\n{ 3, 4, 1, 3, 2 },\r\n{ 4, 8, 1, 4, 2 },\r\n{ 5, 8, 1, 4, 2 },\r\n{ 6, 8, 1, 4, 3 },\r\n{ 7, 8, 1, 4, 3 },\r\n{ 8, 15, 0, 4, 3 },\r\n{ 9, 15, 0, 4, 3 },\r\n{ 10, 16, 1, 5, 3 },\r\n};\r\nstatic const int count = ARRAY_SIZE(vals);\r\nint i;\r\nfor (i = 0; i < count; i++)\r\nif (vals[i].xpsc == prescale)\r\nbreak;\r\nif (i == count)\r\nreturn;\r\nsaa_writeb(SAA7134_H_PRESCALE(task), vals[i].xpsc);\r\nsaa_writeb(SAA7134_ACC_LENGTH(task), vals[i].xacl);\r\nsaa_writeb(SAA7134_LEVEL_CTRL(task),\r\n(vals[i].xc2_1 << 3) | (vals[i].xdcg));\r\nsaa_andorb(SAA7134_FIR_PREFILTER_CTRL(task), 0x0f,\r\n(vals[i].vpfy << 2) | vals[i].vpfy);\r\n}\r\nstatic void set_v_scale(struct saa7134_dev *dev, int task, int yscale)\r\n{\r\nint val,mirror;\r\nsaa_writeb(SAA7134_V_SCALE_RATIO1(task), yscale & 0xff);\r\nsaa_writeb(SAA7134_V_SCALE_RATIO2(task), yscale >> 8);\r\nmirror = (dev->ctl_mirror) ? 0x02 : 0x00;\r\nif (yscale < 2048) {\r\ndprintk("yscale LPI yscale=%d\n",yscale);\r\nsaa_writeb(SAA7134_V_FILTER(task), 0x00 | mirror);\r\nsaa_writeb(SAA7134_LUMA_CONTRAST(task), 0x40);\r\nsaa_writeb(SAA7134_CHROMA_SATURATION(task), 0x40);\r\n} else {\r\nval = 0x40 * 1024 / yscale;\r\ndprintk("yscale ACM yscale=%d val=0x%x\n",yscale,val);\r\nsaa_writeb(SAA7134_V_FILTER(task), 0x01 | mirror);\r\nsaa_writeb(SAA7134_LUMA_CONTRAST(task), val);\r\nsaa_writeb(SAA7134_CHROMA_SATURATION(task), val);\r\n}\r\nsaa_writeb(SAA7134_LUMA_BRIGHT(task), 0x80);\r\n}\r\nstatic void set_size(struct saa7134_dev *dev, int task,\r\nint width, int height, int interlace)\r\n{\r\nint prescale,xscale,yscale,y_even,y_odd;\r\nint h_start, h_stop, v_start, v_stop;\r\nint div = interlace ? 2 : 1;\r\nh_start = dev->crop_current.left;\r\nv_start = dev->crop_current.top/2;\r\nh_stop = (dev->crop_current.left + dev->crop_current.width -1);\r\nv_stop = (dev->crop_current.top + dev->crop_current.height -1)/2;\r\nsaa_writeb(SAA7134_VIDEO_H_START1(task), h_start & 0xff);\r\nsaa_writeb(SAA7134_VIDEO_H_START2(task), h_start >> 8);\r\nsaa_writeb(SAA7134_VIDEO_H_STOP1(task), h_stop & 0xff);\r\nsaa_writeb(SAA7134_VIDEO_H_STOP2(task), h_stop >> 8);\r\nsaa_writeb(SAA7134_VIDEO_V_START1(task), v_start & 0xff);\r\nsaa_writeb(SAA7134_VIDEO_V_START2(task), v_start >> 8);\r\nsaa_writeb(SAA7134_VIDEO_V_STOP1(task), v_stop & 0xff);\r\nsaa_writeb(SAA7134_VIDEO_V_STOP2(task), v_stop >> 8);\r\nprescale = dev->crop_current.width / width;\r\nif (0 == prescale)\r\nprescale = 1;\r\nxscale = 1024 * dev->crop_current.width / prescale / width;\r\nyscale = 512 * div * dev->crop_current.height / height;\r\ndprintk("prescale=%d xscale=%d yscale=%d\n",prescale,xscale,yscale);\r\nset_h_prescale(dev,task,prescale);\r\nsaa_writeb(SAA7134_H_SCALE_INC1(task), xscale & 0xff);\r\nsaa_writeb(SAA7134_H_SCALE_INC2(task), xscale >> 8);\r\nset_v_scale(dev,task,yscale);\r\nsaa_writeb(SAA7134_VIDEO_PIXELS1(task), width & 0xff);\r\nsaa_writeb(SAA7134_VIDEO_PIXELS2(task), width >> 8);\r\nsaa_writeb(SAA7134_VIDEO_LINES1(task), height/div & 0xff);\r\nsaa_writeb(SAA7134_VIDEO_LINES2(task), height/div >> 8);\r\ny_odd = dev->ctl_y_odd;\r\ny_even = dev->ctl_y_even;\r\nsaa_writeb(SAA7134_V_PHASE_OFFSET0(task), y_odd);\r\nsaa_writeb(SAA7134_V_PHASE_OFFSET1(task), y_even);\r\nsaa_writeb(SAA7134_V_PHASE_OFFSET2(task), y_odd);\r\nsaa_writeb(SAA7134_V_PHASE_OFFSET3(task), y_even);\r\n}\r\nstatic void set_cliplist(struct saa7134_dev *dev, int reg,\r\nstruct cliplist *cl, int entries, char *name)\r\n{\r\n__u8 winbits = 0;\r\nint i;\r\nfor (i = 0; i < entries; i++) {\r\nwinbits |= cl[i].enable;\r\nwinbits &= ~cl[i].disable;\r\nif (i < 15 && cl[i].position == cl[i+1].position)\r\ncontinue;\r\nsaa_writeb(reg + 0, winbits);\r\nsaa_writeb(reg + 2, cl[i].position & 0xff);\r\nsaa_writeb(reg + 3, cl[i].position >> 8);\r\ndprintk("clip: %s winbits=%02x pos=%d\n",\r\nname,winbits,cl[i].position);\r\nreg += 8;\r\n}\r\nfor (; reg < 0x400; reg += 8) {\r\nsaa_writeb(reg+ 0, 0);\r\nsaa_writeb(reg + 1, 0);\r\nsaa_writeb(reg + 2, 0);\r\nsaa_writeb(reg + 3, 0);\r\n}\r\n}\r\nstatic int clip_range(int val)\r\n{\r\nif (val < 0)\r\nval = 0;\r\nreturn val;\r\n}\r\nstatic int cliplist_cmp(const void *a, const void *b)\r\n{\r\nconst struct cliplist *cla = a;\r\nconst struct cliplist *clb = b;\r\nif (cla->position < clb->position)\r\nreturn -1;\r\nif (cla->position > clb->position)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int setup_clipping(struct saa7134_dev *dev, struct v4l2_clip *clips,\r\nint nclips, int interlace)\r\n{\r\nstruct cliplist col[16], row[16];\r\nint cols = 0, rows = 0, i;\r\nint div = interlace ? 2 : 1;\r\nmemset(col, 0, sizeof(col));\r\nmemset(row, 0, sizeof(row));\r\nfor (i = 0; i < nclips && i < 8; i++) {\r\ncol[cols].position = clip_range(clips[i].c.left);\r\ncol[cols].enable = (1 << i);\r\ncols++;\r\ncol[cols].position = clip_range(clips[i].c.left+clips[i].c.width);\r\ncol[cols].disable = (1 << i);\r\ncols++;\r\nrow[rows].position = clip_range(clips[i].c.top / div);\r\nrow[rows].enable = (1 << i);\r\nrows++;\r\nrow[rows].position = clip_range((clips[i].c.top + clips[i].c.height)\r\n/ div);\r\nrow[rows].disable = (1 << i);\r\nrows++;\r\n}\r\nsort(col, cols, sizeof col[0], cliplist_cmp, NULL);\r\nsort(row, rows, sizeof row[0], cliplist_cmp, NULL);\r\nset_cliplist(dev,0x380,col,cols,"cols");\r\nset_cliplist(dev,0x384,row,rows,"rows");\r\nreturn 0;\r\n}\r\nstatic int verify_preview(struct saa7134_dev *dev, struct v4l2_window *win, bool try)\r\n{\r\nenum v4l2_field field;\r\nint maxw, maxh;\r\nif (!try && (dev->ovbuf.base == NULL || dev->ovfmt == NULL))\r\nreturn -EINVAL;\r\nif (win->w.width < 48)\r\nwin->w.width = 48;\r\nif (win->w.height < 32)\r\nwin->w.height = 32;\r\nif (win->clipcount > 8)\r\nwin->clipcount = 8;\r\nwin->chromakey = 0;\r\nwin->global_alpha = 0;\r\nfield = win->field;\r\nmaxw = dev->crop_current.width;\r\nmaxh = dev->crop_current.height;\r\nif (V4L2_FIELD_ANY == field) {\r\nfield = (win->w.height > maxh/2)\r\n? V4L2_FIELD_INTERLACED\r\n: V4L2_FIELD_TOP;\r\n}\r\nswitch (field) {\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\nmaxh = maxh / 2;\r\nbreak;\r\ndefault:\r\nfield = V4L2_FIELD_INTERLACED;\r\nbreak;\r\n}\r\nwin->field = field;\r\nif (win->w.width > maxw)\r\nwin->w.width = maxw;\r\nif (win->w.height > maxh)\r\nwin->w.height = maxh;\r\nreturn 0;\r\n}\r\nstatic int start_preview(struct saa7134_dev *dev, struct saa7134_fh *fh)\r\n{\r\nunsigned long base,control,bpl;\r\nint err;\r\nerr = verify_preview(dev, &dev->win, false);\r\nif (0 != err)\r\nreturn err;\r\ndev->ovfield = dev->win.field;\r\ndprintk("start_preview %dx%d+%d+%d %s field=%s\n",\r\ndev->win.w.width, dev->win.w.height,\r\ndev->win.w.left, dev->win.w.top,\r\ndev->ovfmt->name, v4l2_field_names[dev->ovfield]);\r\nset_size(dev, TASK_B, dev->win.w.width, dev->win.w.height,\r\nV4L2_FIELD_HAS_BOTH(dev->ovfield));\r\nsetup_clipping(dev, dev->clips, dev->nclips,\r\nV4L2_FIELD_HAS_BOTH(dev->ovfield));\r\nif (dev->ovfmt->yuv)\r\nsaa_andorb(SAA7134_DATA_PATH(TASK_B), 0x3f, 0x03);\r\nelse\r\nsaa_andorb(SAA7134_DATA_PATH(TASK_B), 0x3f, 0x01);\r\nsaa_writeb(SAA7134_OFMT_VIDEO_B, dev->ovfmt->pm | 0x20);\r\nbase = (unsigned long)dev->ovbuf.base;\r\nbase += dev->ovbuf.fmt.bytesperline * dev->win.w.top;\r\nbase += dev->ovfmt->depth/8 * dev->win.w.left;\r\nbpl = dev->ovbuf.fmt.bytesperline;\r\ncontrol = SAA7134_RS_CONTROL_BURST_16;\r\nif (dev->ovfmt->bswap)\r\ncontrol |= SAA7134_RS_CONTROL_BSWAP;\r\nif (dev->ovfmt->wswap)\r\ncontrol |= SAA7134_RS_CONTROL_WSWAP;\r\nif (V4L2_FIELD_HAS_BOTH(dev->ovfield)) {\r\nsaa_writel(SAA7134_RS_BA1(1),base);\r\nsaa_writel(SAA7134_RS_BA2(1),base+bpl);\r\nsaa_writel(SAA7134_RS_PITCH(1),bpl*2);\r\nsaa_writel(SAA7134_RS_CONTROL(1),control);\r\n} else {\r\nsaa_writel(SAA7134_RS_BA1(1),base);\r\nsaa_writel(SAA7134_RS_BA2(1),base);\r\nsaa_writel(SAA7134_RS_PITCH(1),bpl);\r\nsaa_writel(SAA7134_RS_CONTROL(1),control);\r\n}\r\ndev->ovenable = 1;\r\nsaa7134_set_dmabits(dev);\r\nreturn 0;\r\n}\r\nstatic int stop_preview(struct saa7134_dev *dev, struct saa7134_fh *fh)\r\n{\r\ndev->ovenable = 0;\r\nsaa7134_set_dmabits(dev);\r\nreturn 0;\r\n}\r\nstatic int buffer_activate(struct saa7134_dev *dev,\r\nstruct saa7134_buf *buf,\r\nstruct saa7134_buf *next)\r\n{\r\nunsigned long base,control,bpl;\r\nunsigned long bpl_uv,lines_uv,base2,base3,tmp;\r\ndprintk("buffer_activate buf=%p\n",buf);\r\nbuf->vb.state = VIDEOBUF_ACTIVE;\r\nbuf->top_seen = 0;\r\nset_size(dev,TASK_A,buf->vb.width,buf->vb.height,\r\nV4L2_FIELD_HAS_BOTH(buf->vb.field));\r\nif (buf->fmt->yuv)\r\nsaa_andorb(SAA7134_DATA_PATH(TASK_A), 0x3f, 0x03);\r\nelse\r\nsaa_andorb(SAA7134_DATA_PATH(TASK_A), 0x3f, 0x01);\r\nsaa_writeb(SAA7134_OFMT_VIDEO_A, buf->fmt->pm);\r\nbase = saa7134_buffer_base(buf);\r\nif (buf->fmt->planar)\r\nbpl = buf->vb.width;\r\nelse\r\nbpl = (buf->vb.width * buf->fmt->depth) / 8;\r\ncontrol = SAA7134_RS_CONTROL_BURST_16 |\r\nSAA7134_RS_CONTROL_ME |\r\n(buf->pt->dma >> 12);\r\nif (buf->fmt->bswap)\r\ncontrol |= SAA7134_RS_CONTROL_BSWAP;\r\nif (buf->fmt->wswap)\r\ncontrol |= SAA7134_RS_CONTROL_WSWAP;\r\nif (V4L2_FIELD_HAS_BOTH(buf->vb.field)) {\r\nsaa_writel(SAA7134_RS_BA1(0),base);\r\nsaa_writel(SAA7134_RS_BA2(0),base+bpl);\r\nsaa_writel(SAA7134_RS_PITCH(0),bpl*2);\r\n} else {\r\nsaa_writel(SAA7134_RS_BA1(0),base);\r\nsaa_writel(SAA7134_RS_BA2(0),base);\r\nsaa_writel(SAA7134_RS_PITCH(0),bpl);\r\n}\r\nsaa_writel(SAA7134_RS_CONTROL(0),control);\r\nif (buf->fmt->planar) {\r\nbpl_uv = bpl >> buf->fmt->hshift;\r\nlines_uv = buf->vb.height >> buf->fmt->vshift;\r\nbase2 = base + bpl * buf->vb.height;\r\nbase3 = base2 + bpl_uv * lines_uv;\r\nif (buf->fmt->uvswap)\r\ntmp = base2, base2 = base3, base3 = tmp;\r\ndprintk("uv: bpl=%ld lines=%ld base2/3=%ld/%ld\n",\r\nbpl_uv,lines_uv,base2,base3);\r\nif (V4L2_FIELD_HAS_BOTH(buf->vb.field)) {\r\nsaa_writel(SAA7134_RS_BA1(4),base2);\r\nsaa_writel(SAA7134_RS_BA2(4),base2+bpl_uv);\r\nsaa_writel(SAA7134_RS_PITCH(4),bpl_uv*2);\r\nsaa_writel(SAA7134_RS_BA1(5),base3);\r\nsaa_writel(SAA7134_RS_BA2(5),base3+bpl_uv);\r\nsaa_writel(SAA7134_RS_PITCH(5),bpl_uv*2);\r\n} else {\r\nsaa_writel(SAA7134_RS_BA1(4),base2);\r\nsaa_writel(SAA7134_RS_BA2(4),base2);\r\nsaa_writel(SAA7134_RS_PITCH(4),bpl_uv);\r\nsaa_writel(SAA7134_RS_BA1(5),base3);\r\nsaa_writel(SAA7134_RS_BA2(5),base3);\r\nsaa_writel(SAA7134_RS_PITCH(5),bpl_uv);\r\n}\r\nsaa_writel(SAA7134_RS_CONTROL(4),control);\r\nsaa_writel(SAA7134_RS_CONTROL(5),control);\r\n}\r\nsaa7134_set_dmabits(dev);\r\nmod_timer(&dev->video_q.timeout, jiffies+BUFFER_TIMEOUT);\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct saa7134_fh *fh = q->priv_data;\r\nstruct saa7134_dev *dev = fh->dev;\r\nstruct saa7134_buf *buf = container_of(vb,struct saa7134_buf,vb);\r\nunsigned int size;\r\nint err;\r\nif (NULL == dev->fmt)\r\nreturn -EINVAL;\r\nif (dev->width < 48 ||\r\ndev->height < 32 ||\r\ndev->width/4 > dev->crop_current.width ||\r\ndev->height/4 > dev->crop_current.height ||\r\ndev->width > dev->crop_bounds.width ||\r\ndev->height > dev->crop_bounds.height)\r\nreturn -EINVAL;\r\nsize = (dev->width * dev->height * dev->fmt->depth) >> 3;\r\nif (0 != buf->vb.baddr && buf->vb.bsize < size)\r\nreturn -EINVAL;\r\ndprintk("buffer_prepare [%d,size=%dx%d,bytes=%d,fields=%s,%s]\n",\r\nvb->i, dev->width, dev->height, size, v4l2_field_names[field],\r\ndev->fmt->name);\r\nif (buf->vb.width != dev->width ||\r\nbuf->vb.height != dev->height ||\r\nbuf->vb.size != size ||\r\nbuf->vb.field != field ||\r\nbuf->fmt != dev->fmt) {\r\nsaa7134_dma_free(q,buf);\r\n}\r\nif (VIDEOBUF_NEEDS_INIT == buf->vb.state) {\r\nstruct videobuf_dmabuf *dma=videobuf_to_dma(&buf->vb);\r\nbuf->vb.width = dev->width;\r\nbuf->vb.height = dev->height;\r\nbuf->vb.size = size;\r\nbuf->vb.field = field;\r\nbuf->fmt = dev->fmt;\r\nbuf->pt = &fh->pt_cap;\r\ndev->video_q.curr = NULL;\r\nerr = videobuf_iolock(q,&buf->vb,&dev->ovbuf);\r\nif (err)\r\ngoto oops;\r\nerr = saa7134_pgtable_build(dev->pci,buf->pt,\r\ndma->sglist,\r\ndma->sglen,\r\nsaa7134_buffer_startpage(buf));\r\nif (err)\r\ngoto oops;\r\n}\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nbuf->activate = buffer_activate;\r\nreturn 0;\r\noops:\r\nsaa7134_dma_free(q,buf);\r\nreturn err;\r\n}\r\nstatic int\r\nbuffer_setup(struct videobuf_queue *q, unsigned int *count, unsigned int *size)\r\n{\r\nstruct saa7134_fh *fh = q->priv_data;\r\nstruct saa7134_dev *dev = fh->dev;\r\n*size = dev->fmt->depth * dev->width * dev->height >> 3;\r\nif (0 == *count)\r\n*count = gbuffers;\r\n*count = saa7134_buffer_count(*size,*count);\r\nreturn 0;\r\n}\r\nstatic void buffer_queue(struct videobuf_queue *q, struct videobuf_buffer *vb)\r\n{\r\nstruct saa7134_fh *fh = q->priv_data;\r\nstruct saa7134_buf *buf = container_of(vb,struct saa7134_buf,vb);\r\nsaa7134_buffer_queue(fh->dev,&fh->dev->video_q,buf);\r\n}\r\nstatic void buffer_release(struct videobuf_queue *q, struct videobuf_buffer *vb)\r\n{\r\nstruct saa7134_buf *buf = container_of(vb,struct saa7134_buf,vb);\r\nsaa7134_dma_free(q,buf);\r\n}\r\nint saa7134_g_ctrl_internal(struct saa7134_dev *dev, struct saa7134_fh *fh, struct v4l2_control *c)\r\n{\r\nconst struct v4l2_queryctrl* ctrl;\r\nctrl = ctrl_by_id(c->id);\r\nif (NULL == ctrl)\r\nreturn -EINVAL;\r\nswitch (c->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nc->value = dev->ctl_bright;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nc->value = dev->ctl_hue;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nc->value = dev->ctl_contrast;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nc->value = dev->ctl_saturation;\r\nbreak;\r\ncase V4L2_CID_AUDIO_MUTE:\r\nc->value = dev->ctl_mute;\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\nc->value = dev->ctl_volume;\r\nbreak;\r\ncase V4L2_CID_PRIVATE_INVERT:\r\nc->value = dev->ctl_invert;\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\nc->value = dev->ctl_mirror;\r\nbreak;\r\ncase V4L2_CID_PRIVATE_Y_EVEN:\r\nc->value = dev->ctl_y_even;\r\nbreak;\r\ncase V4L2_CID_PRIVATE_Y_ODD:\r\nc->value = dev->ctl_y_odd;\r\nbreak;\r\ncase V4L2_CID_PRIVATE_AUTOMUTE:\r\nc->value = dev->ctl_automute;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7134_g_ctrl(struct file *file, void *priv, struct v4l2_control *c)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nreturn saa7134_g_ctrl_internal(fh->dev, fh, c);\r\n}\r\nint saa7134_s_ctrl_internal(struct saa7134_dev *dev, struct saa7134_fh *fh, struct v4l2_control *c)\r\n{\r\nconst struct v4l2_queryctrl* ctrl;\r\nunsigned long flags;\r\nint restart_overlay = 0;\r\nint err;\r\nerr = -EINVAL;\r\nmutex_lock(&dev->lock);\r\nctrl = ctrl_by_id(c->id);\r\nif (NULL == ctrl)\r\ngoto error;\r\ndprintk("set_control name=%s val=%d\n",ctrl->name,c->value);\r\nswitch (ctrl->type) {\r\ncase V4L2_CTRL_TYPE_BOOLEAN:\r\ncase V4L2_CTRL_TYPE_MENU:\r\ncase V4L2_CTRL_TYPE_INTEGER:\r\nif (c->value < ctrl->minimum)\r\nc->value = ctrl->minimum;\r\nif (c->value > ctrl->maximum)\r\nc->value = ctrl->maximum;\r\nbreak;\r\ndefault:\r\n;\r\n}\r\nswitch (c->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ndev->ctl_bright = c->value;\r\nsaa_writeb(SAA7134_DEC_LUMA_BRIGHT, dev->ctl_bright);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\ndev->ctl_hue = c->value;\r\nsaa_writeb(SAA7134_DEC_CHROMA_HUE, dev->ctl_hue);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\ndev->ctl_contrast = c->value;\r\nsaa_writeb(SAA7134_DEC_LUMA_CONTRAST,\r\ndev->ctl_invert ? -dev->ctl_contrast : dev->ctl_contrast);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\ndev->ctl_saturation = c->value;\r\nsaa_writeb(SAA7134_DEC_CHROMA_SATURATION,\r\ndev->ctl_invert ? -dev->ctl_saturation : dev->ctl_saturation);\r\nbreak;\r\ncase V4L2_CID_AUDIO_MUTE:\r\ndev->ctl_mute = c->value;\r\nsaa7134_tvaudio_setmute(dev);\r\nbreak;\r\ncase V4L2_CID_AUDIO_VOLUME:\r\ndev->ctl_volume = c->value;\r\nsaa7134_tvaudio_setvolume(dev,dev->ctl_volume);\r\nbreak;\r\ncase V4L2_CID_PRIVATE_INVERT:\r\ndev->ctl_invert = c->value;\r\nsaa_writeb(SAA7134_DEC_LUMA_CONTRAST,\r\ndev->ctl_invert ? -dev->ctl_contrast : dev->ctl_contrast);\r\nsaa_writeb(SAA7134_DEC_CHROMA_SATURATION,\r\ndev->ctl_invert ? -dev->ctl_saturation : dev->ctl_saturation);\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\ndev->ctl_mirror = c->value;\r\nrestart_overlay = 1;\r\nbreak;\r\ncase V4L2_CID_PRIVATE_Y_EVEN:\r\ndev->ctl_y_even = c->value;\r\nrestart_overlay = 1;\r\nbreak;\r\ncase V4L2_CID_PRIVATE_Y_ODD:\r\ndev->ctl_y_odd = c->value;\r\nrestart_overlay = 1;\r\nbreak;\r\ncase V4L2_CID_PRIVATE_AUTOMUTE:\r\n{\r\nstruct v4l2_priv_tun_config tda9887_cfg;\r\ntda9887_cfg.tuner = TUNER_TDA9887;\r\ntda9887_cfg.priv = &dev->tda9887_conf;\r\ndev->ctl_automute = c->value;\r\nif (dev->tda9887_conf) {\r\nif (dev->ctl_automute)\r\ndev->tda9887_conf |= TDA9887_AUTOMUTE;\r\nelse\r\ndev->tda9887_conf &= ~TDA9887_AUTOMUTE;\r\nsaa_call_all(dev, tuner, s_config, &tda9887_cfg);\r\n}\r\nbreak;\r\n}\r\ndefault:\r\ngoto error;\r\n}\r\nif (restart_overlay && fh && res_check(fh, RESOURCE_OVERLAY)) {\r\nspin_lock_irqsave(&dev->slock,flags);\r\nstop_preview(dev,fh);\r\nstart_preview(dev,fh);\r\nspin_unlock_irqrestore(&dev->slock,flags);\r\n}\r\nerr = 0;\r\nerror:\r\nmutex_unlock(&dev->lock);\r\nreturn err;\r\n}\r\nstatic int saa7134_s_ctrl(struct file *file, void *f, struct v4l2_control *c)\r\n{\r\nstruct saa7134_fh *fh = f;\r\nreturn saa7134_s_ctrl_internal(fh->dev, fh, c);\r\n}\r\nstatic struct videobuf_queue *saa7134_queue(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct saa7134_fh *fh = file->private_data;\r\nstruct videobuf_queue *q = NULL;\r\nswitch (vdev->vfl_type) {\r\ncase VFL_TYPE_GRABBER:\r\nq = &fh->cap;\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\nq = &fh->vbi;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn q;\r\n}\r\nstatic int saa7134_resource(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nif (vdev->vfl_type == VFL_TYPE_GRABBER)\r\nreturn RESOURCE_VIDEO;\r\nif (vdev->vfl_type == VFL_TYPE_VBI)\r\nreturn RESOURCE_VBI;\r\nBUG();\r\nreturn 0;\r\n}\r\nstatic int video_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nstruct saa7134_fh *fh;\r\nfh = kzalloc(sizeof(*fh),GFP_KERNEL);\r\nif (NULL == fh)\r\nreturn -ENOMEM;\r\nv4l2_fh_init(&fh->fh, vdev);\r\nfile->private_data = fh;\r\nfh->dev = dev;\r\nvideobuf_queue_sg_init(&fh->cap, &video_qops,\r\n&dev->pci->dev, &dev->slock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_INTERLACED,\r\nsizeof(struct saa7134_buf),\r\nfh, NULL);\r\nvideobuf_queue_sg_init(&fh->vbi, &saa7134_vbi_qops,\r\n&dev->pci->dev, &dev->slock,\r\nV4L2_BUF_TYPE_VBI_CAPTURE,\r\nV4L2_FIELD_SEQ_TB,\r\nsizeof(struct saa7134_buf),\r\nfh, NULL);\r\nsaa7134_pgtable_alloc(dev->pci,&fh->pt_cap);\r\nsaa7134_pgtable_alloc(dev->pci,&fh->pt_vbi);\r\nif (vdev->vfl_type == VFL_TYPE_RADIO) {\r\nsaa7134_tvaudio_setinput(dev,&card(dev).radio);\r\nsaa_call_all(dev, tuner, s_radio);\r\n} else {\r\nvideo_mux(dev,dev->ctl_input);\r\n}\r\nv4l2_fh_add(&fh->fh);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nvideo_read(struct file *file, char __user *data, size_t count, loff_t *ppos)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct saa7134_fh *fh = file->private_data;\r\nswitch (vdev->vfl_type) {\r\ncase VFL_TYPE_GRABBER:\r\nif (res_locked(fh->dev,RESOURCE_VIDEO))\r\nreturn -EBUSY;\r\nreturn videobuf_read_one(saa7134_queue(file),\r\ndata, count, ppos,\r\nfile->f_flags & O_NONBLOCK);\r\ncase VFL_TYPE_VBI:\r\nif (!res_get(fh->dev,fh,RESOURCE_VBI))\r\nreturn -EBUSY;\r\nreturn videobuf_read_stream(saa7134_queue(file),\r\ndata, count, ppos, 1,\r\nfile->f_flags & O_NONBLOCK);\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nstatic unsigned int\r\nvideo_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct saa7134_fh *fh = file->private_data;\r\nstruct videobuf_buffer *buf = NULL;\r\nunsigned int rc = 0;\r\nif (vdev->vfl_type == VFL_TYPE_VBI)\r\nreturn videobuf_poll_stream(file, &fh->vbi, wait);\r\nif (res_check(fh,RESOURCE_VIDEO)) {\r\nmutex_lock(&fh->cap.vb_lock);\r\nif (!list_empty(&fh->cap.stream))\r\nbuf = list_entry(fh->cap.stream.next, struct videobuf_buffer, stream);\r\n} else {\r\nmutex_lock(&fh->cap.vb_lock);\r\nif (UNSET == fh->cap.read_off) {\r\nif (res_locked(fh->dev,RESOURCE_VIDEO))\r\ngoto err;\r\nif (0 != fh->cap.ops->buf_prepare(&fh->cap,fh->cap.read_buf,fh->cap.field))\r\ngoto err;\r\nfh->cap.ops->buf_queue(&fh->cap,fh->cap.read_buf);\r\nfh->cap.read_off = 0;\r\n}\r\nbuf = fh->cap.read_buf;\r\n}\r\nif (!buf)\r\ngoto err;\r\npoll_wait(file, &buf->done, wait);\r\nif (buf->state == VIDEOBUF_DONE ||\r\nbuf->state == VIDEOBUF_ERROR)\r\nrc = POLLIN|POLLRDNORM;\r\nmutex_unlock(&fh->cap.vb_lock);\r\nreturn rc;\r\nerr:\r\nmutex_unlock(&fh->cap.vb_lock);\r\nreturn POLLERR;\r\n}\r\nstatic int video_release(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct saa7134_fh *fh = file->private_data;\r\nstruct saa7134_dev *dev = fh->dev;\r\nstruct saa6588_command cmd;\r\nunsigned long flags;\r\nsaa7134_tvaudio_close(dev);\r\nif (res_check(fh, RESOURCE_OVERLAY)) {\r\nspin_lock_irqsave(&dev->slock,flags);\r\nstop_preview(dev,fh);\r\nspin_unlock_irqrestore(&dev->slock,flags);\r\nres_free(dev,fh,RESOURCE_OVERLAY);\r\n}\r\nif (res_check(fh, RESOURCE_VIDEO)) {\r\npm_qos_remove_request(&dev->qos_request);\r\nvideobuf_streamoff(&fh->cap);\r\nres_free(dev,fh,RESOURCE_VIDEO);\r\n}\r\nif (fh->cap.read_buf) {\r\nbuffer_release(&fh->cap,fh->cap.read_buf);\r\nkfree(fh->cap.read_buf);\r\n}\r\nif (res_check(fh, RESOURCE_VBI)) {\r\nvideobuf_stop(&fh->vbi);\r\nres_free(dev,fh,RESOURCE_VBI);\r\n}\r\nsaa_andorb(SAA7134_OFMT_VIDEO_A, 0x1f, 0);\r\nsaa_andorb(SAA7134_OFMT_VIDEO_B, 0x1f, 0);\r\nsaa_andorb(SAA7134_OFMT_DATA_A, 0x1f, 0);\r\nsaa_andorb(SAA7134_OFMT_DATA_B, 0x1f, 0);\r\nsaa_call_all(dev, core, s_power, 0);\r\nif (vdev->vfl_type == VFL_TYPE_RADIO)\r\nsaa_call_all(dev, core, ioctl, SAA6588_CMD_CLOSE, &cmd);\r\nvideobuf_mmap_free(&fh->cap);\r\nvideobuf_mmap_free(&fh->vbi);\r\nsaa7134_pgtable_free(dev->pci,&fh->pt_cap);\r\nsaa7134_pgtable_free(dev->pci,&fh->pt_vbi);\r\nv4l2_fh_del(&fh->fh);\r\nv4l2_fh_exit(&fh->fh);\r\nfile->private_data = NULL;\r\nkfree(fh);\r\nreturn 0;\r\n}\r\nstatic int video_mmap(struct file *file, struct vm_area_struct * vma)\r\n{\r\nreturn videobuf_mmap_mapper(saa7134_queue(file), vma);\r\n}\r\nstatic ssize_t radio_read(struct file *file, char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct saa7134_fh *fh = file->private_data;\r\nstruct saa7134_dev *dev = fh->dev;\r\nstruct saa6588_command cmd;\r\ncmd.block_count = count/3;\r\ncmd.buffer = data;\r\ncmd.instance = file;\r\ncmd.result = -ENODEV;\r\nsaa_call_all(dev, core, ioctl, SAA6588_CMD_READ, &cmd);\r\nreturn cmd.result;\r\n}\r\nstatic unsigned int radio_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct saa7134_fh *fh = file->private_data;\r\nstruct saa7134_dev *dev = fh->dev;\r\nstruct saa6588_command cmd;\r\ncmd.instance = file;\r\ncmd.event_list = wait;\r\ncmd.result = -ENODEV;\r\nsaa_call_all(dev, core, ioctl, SAA6588_CMD_POLL, &cmd);\r\nreturn cmd.result;\r\n}\r\nstatic int saa7134_try_get_set_fmt_vbi_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nstruct saa7134_tvnorm *norm = dev->tvnorm;\r\nmemset(&f->fmt.vbi.reserved, 0, sizeof(f->fmt.vbi.reserved));\r\nf->fmt.vbi.sampling_rate = 6750000 * 4;\r\nf->fmt.vbi.samples_per_line = 2048 ;\r\nf->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;\r\nf->fmt.vbi.offset = 64 * 4;\r\nf->fmt.vbi.start[0] = norm->vbi_v_start_0;\r\nf->fmt.vbi.count[0] = norm->vbi_v_stop_0 - norm->vbi_v_start_0 +1;\r\nf->fmt.vbi.start[1] = norm->vbi_v_start_1;\r\nf->fmt.vbi.count[1] = f->fmt.vbi.count[0];\r\nf->fmt.vbi.flags = 0;\r\nreturn 0;\r\n}\r\nstatic int saa7134_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nf->fmt.pix.width = dev->width;\r\nf->fmt.pix.height = dev->height;\r\nf->fmt.pix.field = fh->cap.field;\r\nf->fmt.pix.pixelformat = dev->fmt->fourcc;\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * dev->fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int saa7134_g_fmt_vid_overlay(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nstruct v4l2_clip __user *clips = f->fmt.win.clips;\r\nu32 clipcount = f->fmt.win.clipcount;\r\nint err = 0;\r\nint i;\r\nif (saa7134_no_overlay > 0) {\r\nprintk(KERN_ERR "V4L2_BUF_TYPE_VIDEO_OVERLAY: no_overlay\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&dev->lock);\r\nf->fmt.win = dev->win;\r\nf->fmt.win.clips = clips;\r\nif (clips == NULL)\r\nclipcount = 0;\r\nif (dev->nclips < clipcount)\r\nclipcount = dev->nclips;\r\nf->fmt.win.clipcount = clipcount;\r\nfor (i = 0; !err && i < clipcount; i++) {\r\nif (copy_to_user(&f->fmt.win.clips[i].c, &dev->clips[i].c,\r\nsizeof(struct v4l2_rect)))\r\nerr = -EFAULT;\r\n}\r\nmutex_unlock(&dev->lock);\r\nreturn err;\r\n}\r\nstatic int saa7134_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nstruct saa7134_format *fmt;\r\nenum v4l2_field field;\r\nunsigned int maxw, maxh;\r\nfmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\nif (NULL == fmt)\r\nreturn -EINVAL;\r\nfield = f->fmt.pix.field;\r\nmaxw = min(dev->crop_current.width*4, dev->crop_bounds.width);\r\nmaxh = min(dev->crop_current.height*4, dev->crop_bounds.height);\r\nif (V4L2_FIELD_ANY == field) {\r\nfield = (f->fmt.pix.height > maxh/2)\r\n? V4L2_FIELD_INTERLACED\r\n: V4L2_FIELD_BOTTOM;\r\n}\r\nswitch (field) {\r\ncase V4L2_FIELD_TOP:\r\ncase V4L2_FIELD_BOTTOM:\r\nmaxh = maxh / 2;\r\nbreak;\r\ndefault:\r\nfield = V4L2_FIELD_INTERLACED;\r\nbreak;\r\n}\r\nf->fmt.pix.field = field;\r\nif (f->fmt.pix.width < 48)\r\nf->fmt.pix.width = 48;\r\nif (f->fmt.pix.height < 32)\r\nf->fmt.pix.height = 32;\r\nif (f->fmt.pix.width > maxw)\r\nf->fmt.pix.width = maxw;\r\nif (f->fmt.pix.height > maxh)\r\nf->fmt.pix.height = maxh;\r\nf->fmt.pix.width &= ~0x03;\r\nf->fmt.pix.bytesperline =\r\n(f->fmt.pix.width * fmt->depth) >> 3;\r\nf->fmt.pix.sizeimage =\r\nf->fmt.pix.height * f->fmt.pix.bytesperline;\r\nf->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int saa7134_try_fmt_vid_overlay(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nif (saa7134_no_overlay > 0) {\r\nprintk(KERN_ERR "V4L2_BUF_TYPE_VIDEO_OVERLAY: no_overlay\n");\r\nreturn -EINVAL;\r\n}\r\nif (f->fmt.win.clips == NULL)\r\nf->fmt.win.clipcount = 0;\r\nreturn verify_preview(dev, &f->fmt.win, true);\r\n}\r\nstatic int saa7134_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nint err;\r\nerr = saa7134_try_fmt_vid_cap(file, priv, f);\r\nif (0 != err)\r\nreturn err;\r\ndev->fmt = format_by_fourcc(f->fmt.pix.pixelformat);\r\ndev->width = f->fmt.pix.width;\r\ndev->height = f->fmt.pix.height;\r\nfh->cap.field = f->fmt.pix.field;\r\nreturn 0;\r\n}\r\nstatic int saa7134_s_fmt_vid_overlay(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nint err;\r\nunsigned long flags;\r\nif (saa7134_no_overlay > 0) {\r\nprintk(KERN_ERR "V4L2_BUF_TYPE_VIDEO_OVERLAY: no_overlay\n");\r\nreturn -EINVAL;\r\n}\r\nif (f->fmt.win.clips == NULL)\r\nf->fmt.win.clipcount = 0;\r\nerr = verify_preview(dev, &f->fmt.win, true);\r\nif (0 != err)\r\nreturn err;\r\nmutex_lock(&dev->lock);\r\ndev->win = f->fmt.win;\r\ndev->nclips = f->fmt.win.clipcount;\r\nif (copy_from_user(dev->clips, f->fmt.win.clips,\r\nsizeof(struct v4l2_clip) * dev->nclips)) {\r\nmutex_unlock(&dev->lock);\r\nreturn -EFAULT;\r\n}\r\nif (res_check(fh, RESOURCE_OVERLAY)) {\r\nspin_lock_irqsave(&dev->slock, flags);\r\nstop_preview(dev, fh);\r\nstart_preview(dev, fh);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nint saa7134_queryctrl(struct file *file, void *priv, struct v4l2_queryctrl *c)\r\n{\r\nconst struct v4l2_queryctrl *ctrl;\r\nif ((c->id < V4L2_CID_BASE ||\r\nc->id >= V4L2_CID_LASTP1) &&\r\n(c->id < V4L2_CID_PRIVATE_BASE ||\r\nc->id >= V4L2_CID_PRIVATE_LASTP1))\r\nreturn -EINVAL;\r\nctrl = ctrl_by_id(c->id);\r\n*c = (NULL != ctrl) ? *ctrl : no_ctrl;\r\nreturn 0;\r\n}\r\nstatic int saa7134_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nunsigned int n;\r\nn = i->index;\r\nif (n >= SAA7134_INPUT_MAX)\r\nreturn -EINVAL;\r\nif (NULL == card_in(dev, i->index).name)\r\nreturn -EINVAL;\r\ni->index = n;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrcpy(i->name, card_in(dev, n).name);\r\nif (card_in(dev, n).tv)\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\nif (n == dev->ctl_input) {\r\nint v1 = saa_readb(SAA7134_STATUS_VIDEO1);\r\nint v2 = saa_readb(SAA7134_STATUS_VIDEO2);\r\nif (0 != (v1 & 0x40))\r\ni->status |= V4L2_IN_ST_NO_H_LOCK;\r\nif (0 != (v2 & 0x40))\r\ni->status |= V4L2_IN_ST_NO_SYNC;\r\nif (0 != (v2 & 0x0e))\r\ni->status |= V4L2_IN_ST_MACROVISION;\r\n}\r\ni->std = SAA7134_NORMS;\r\nreturn 0;\r\n}\r\nstatic int saa7134_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\n*i = dev->ctl_input;\r\nreturn 0;\r\n}\r\nstatic int saa7134_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nif (i >= SAA7134_INPUT_MAX)\r\nreturn -EINVAL;\r\nif (NULL == card_in(dev, i).name)\r\nreturn -EINVAL;\r\nmutex_lock(&dev->lock);\r\nvideo_mux(dev, i);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic int saa7134_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nstruct video_device *vdev = video_devdata(file);\r\nu32 radio_caps, video_caps, vbi_caps;\r\nunsigned int tuner_type = dev->tuner_type;\r\nstrcpy(cap->driver, "saa7134");\r\nstrlcpy(cap->card, saa7134_boards[dev->board].name,\r\nsizeof(cap->card));\r\nsprintf(cap->bus_info, "PCI:%s", pci_name(dev->pci));\r\ncap->device_caps = V4L2_CAP_READWRITE | V4L2_CAP_STREAMING;\r\nif ((tuner_type != TUNER_ABSENT) && (tuner_type != UNSET))\r\ncap->device_caps |= V4L2_CAP_TUNER;\r\nradio_caps = V4L2_CAP_RADIO;\r\nif (dev->has_rds)\r\nradio_caps |= V4L2_CAP_RDS_CAPTURE;\r\nvideo_caps = V4L2_CAP_VIDEO_CAPTURE;\r\nif (saa7134_no_overlay <= 0)\r\nvideo_caps |= V4L2_CAP_VIDEO_OVERLAY;\r\nvbi_caps = V4L2_CAP_VBI_CAPTURE;\r\nswitch (vdev->vfl_type) {\r\ncase VFL_TYPE_RADIO:\r\ncap->device_caps |= radio_caps;\r\nbreak;\r\ncase VFL_TYPE_GRABBER:\r\ncap->device_caps |= video_caps;\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\ncap->device_caps |= vbi_caps;\r\nbreak;\r\n}\r\ncap->capabilities = radio_caps | video_caps | vbi_caps |\r\ncap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nif (vdev->vfl_type == VFL_TYPE_RADIO) {\r\ncap->device_caps &= ~V4L2_CAP_STREAMING;\r\nif (!dev->has_rds)\r\ncap->device_caps &= ~V4L2_CAP_READWRITE;\r\n}\r\nreturn 0;\r\n}\r\nint saa7134_s_std_internal(struct saa7134_dev *dev, struct saa7134_fh *fh, v4l2_std_id id)\r\n{\r\nunsigned long flags;\r\nunsigned int i;\r\nv4l2_std_id fixup;\r\nif (!fh && res_locked(dev, RESOURCE_OVERLAY)) {\r\nreturn -EBUSY;\r\n}\r\nfor (i = 0; i < TVNORMS; i++)\r\nif (id == tvnorms[i].id)\r\nbreak;\r\nif (i == TVNORMS)\r\nfor (i = 0; i < TVNORMS; i++)\r\nif (id & tvnorms[i].id)\r\nbreak;\r\nif (i == TVNORMS)\r\nreturn -EINVAL;\r\nif ((id & V4L2_STD_SECAM) && (secam[0] != '-')) {\r\nif (secam[0] == 'L' || secam[0] == 'l') {\r\nif (secam[1] == 'C' || secam[1] == 'c')\r\nfixup = V4L2_STD_SECAM_LC;\r\nelse\r\nfixup = V4L2_STD_SECAM_L;\r\n} else {\r\nif (secam[0] == 'D' || secam[0] == 'd')\r\nfixup = V4L2_STD_SECAM_DK;\r\nelse\r\nfixup = V4L2_STD_SECAM;\r\n}\r\nfor (i = 0; i < TVNORMS; i++) {\r\nif (fixup == tvnorms[i].id)\r\nbreak;\r\n}\r\nif (i == TVNORMS)\r\nreturn -EINVAL;\r\n}\r\nid = tvnorms[i].id;\r\nmutex_lock(&dev->lock);\r\nif (fh && res_check(fh, RESOURCE_OVERLAY)) {\r\nspin_lock_irqsave(&dev->slock, flags);\r\nstop_preview(dev, fh);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nset_tvnorm(dev, &tvnorms[i]);\r\nspin_lock_irqsave(&dev->slock, flags);\r\nstart_preview(dev, fh);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n} else\r\nset_tvnorm(dev, &tvnorms[i]);\r\nsaa7134_tvaudio_do_scan(dev);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic int saa7134_s_std(struct file *file, void *priv, v4l2_std_id id)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nreturn saa7134_s_std_internal(fh->dev, fh, id);\r\n}\r\nstatic int saa7134_g_std(struct file *file, void *priv, v4l2_std_id *id)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\n*id = dev->tvnorm->id;\r\nreturn 0;\r\n}\r\nstatic int saa7134_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *cap)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nif (cap->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\ncap->type != V4L2_BUF_TYPE_VIDEO_OVERLAY)\r\nreturn -EINVAL;\r\ncap->bounds = dev->crop_bounds;\r\ncap->defrect = dev->crop_defrect;\r\ncap->pixelaspect.numerator = 1;\r\ncap->pixelaspect.denominator = 1;\r\nif (dev->tvnorm->id & V4L2_STD_525_60) {\r\ncap->pixelaspect.numerator = 11;\r\ncap->pixelaspect.denominator = 10;\r\n}\r\nif (dev->tvnorm->id & V4L2_STD_625_50) {\r\ncap->pixelaspect.numerator = 54;\r\ncap->pixelaspect.denominator = 59;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7134_g_crop(struct file *file, void *f, struct v4l2_crop *crop)\r\n{\r\nstruct saa7134_fh *fh = f;\r\nstruct saa7134_dev *dev = fh->dev;\r\nif (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\ncrop->type != V4L2_BUF_TYPE_VIDEO_OVERLAY)\r\nreturn -EINVAL;\r\ncrop->c = dev->crop_current;\r\nreturn 0;\r\n}\r\nstatic int saa7134_s_crop(struct file *file, void *f, const struct v4l2_crop *crop)\r\n{\r\nstruct saa7134_fh *fh = f;\r\nstruct saa7134_dev *dev = fh->dev;\r\nstruct v4l2_rect *b = &dev->crop_bounds;\r\nstruct v4l2_rect *c = &dev->crop_current;\r\nif (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\ncrop->type != V4L2_BUF_TYPE_VIDEO_OVERLAY)\r\nreturn -EINVAL;\r\nif (crop->c.height < 0)\r\nreturn -EINVAL;\r\nif (crop->c.width < 0)\r\nreturn -EINVAL;\r\nif (res_locked(fh->dev, RESOURCE_OVERLAY))\r\nreturn -EBUSY;\r\nif (res_locked(fh->dev, RESOURCE_VIDEO))\r\nreturn -EBUSY;\r\n*c = crop->c;\r\nif (c->top < b->top)\r\nc->top = b->top;\r\nif (c->top > b->top + b->height)\r\nc->top = b->top + b->height;\r\nif (c->height > b->top - c->top + b->height)\r\nc->height = b->top - c->top + b->height;\r\nif (c->left < b->left)\r\nc->left = b->left;\r\nif (c->left > b->left + b->width)\r\nc->left = b->left + b->width;\r\nif (c->width > b->left - c->left + b->width)\r\nc->width = b->left - c->left + b->width;\r\nreturn 0;\r\n}\r\nstatic int saa7134_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nint n;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nmemset(t, 0, sizeof(*t));\r\nfor (n = 0; n < SAA7134_INPUT_MAX; n++) {\r\nif (card_in(dev, n).tv)\r\nbreak;\r\n}\r\nif (n == SAA7134_INPUT_MAX)\r\nreturn -EINVAL;\r\nif (NULL != card_in(dev, n).name) {\r\nstrcpy(t->name, "Television");\r\nt->type = V4L2_TUNER_ANALOG_TV;\r\nsaa_call_all(dev, tuner, g_tuner, t);\r\nt->capability = V4L2_TUNER_CAP_NORM |\r\nV4L2_TUNER_CAP_STEREO |\r\nV4L2_TUNER_CAP_LANG1 |\r\nV4L2_TUNER_CAP_LANG2;\r\nt->rxsubchans = saa7134_tvaudio_getstereo(dev);\r\nt->audmode = saa7134_tvaudio_rx2mode(t->rxsubchans);\r\n}\r\nif (0 != (saa_readb(SAA7134_STATUS_VIDEO1) & 0x03))\r\nt->signal = 0xffff;\r\nreturn 0;\r\n}\r\nstatic int saa7134_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *t)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nint rx, mode;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nmode = dev->thread.mode;\r\nif (UNSET == mode) {\r\nrx = saa7134_tvaudio_getstereo(dev);\r\nmode = saa7134_tvaudio_rx2mode(rx);\r\n}\r\nif (mode != t->audmode)\r\ndev->thread.mode = t->audmode;\r\nreturn 0;\r\n}\r\nstatic int saa7134_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nif (0 != f->tuner)\r\nreturn -EINVAL;\r\nsaa_call_all(dev, tuner, g_frequency, f);\r\nreturn 0;\r\n}\r\nstatic int saa7134_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nif (0 != f->tuner)\r\nreturn -EINVAL;\r\nmutex_lock(&dev->lock);\r\nsaa_call_all(dev, tuner, s_frequency, f);\r\nsaa7134_tvaudio_do_scan(dev);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic int saa7134_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index >= FORMATS)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, formats[f->index].name,\r\nsizeof(f->description));\r\nf->pixelformat = formats[f->index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int saa7134_enum_fmt_vid_overlay(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (saa7134_no_overlay > 0) {\r\nprintk(KERN_ERR "V4L2_BUF_TYPE_VIDEO_OVERLAY: no_overlay\n");\r\nreturn -EINVAL;\r\n}\r\nif ((f->index >= FORMATS) || formats[f->index].planar)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, formats[f->index].name,\r\nsizeof(f->description));\r\nf->pixelformat = formats[f->index].fourcc;\r\nreturn 0;\r\n}\r\nstatic int saa7134_g_fbuf(struct file *file, void *f,\r\nstruct v4l2_framebuffer *fb)\r\n{\r\nstruct saa7134_fh *fh = f;\r\nstruct saa7134_dev *dev = fh->dev;\r\n*fb = dev->ovbuf;\r\nfb->capability = V4L2_FBUF_CAP_LIST_CLIPPING;\r\nreturn 0;\r\n}\r\nstatic int saa7134_s_fbuf(struct file *file, void *f,\r\nconst struct v4l2_framebuffer *fb)\r\n{\r\nstruct saa7134_fh *fh = f;\r\nstruct saa7134_dev *dev = fh->dev;\r\nstruct saa7134_format *fmt;\r\nif (!capable(CAP_SYS_ADMIN) &&\r\n!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nfmt = format_by_fourcc(fb->fmt.pixelformat);\r\nif (NULL == fmt)\r\nreturn -EINVAL;\r\ndev->ovbuf = *fb;\r\ndev->ovfmt = fmt;\r\nif (0 == dev->ovbuf.fmt.bytesperline)\r\ndev->ovbuf.fmt.bytesperline =\r\ndev->ovbuf.fmt.width*fmt->depth/8;\r\nreturn 0;\r\n}\r\nstatic int saa7134_overlay(struct file *file, void *f, unsigned int on)\r\n{\r\nstruct saa7134_fh *fh = f;\r\nstruct saa7134_dev *dev = fh->dev;\r\nunsigned long flags;\r\nif (on) {\r\nif (saa7134_no_overlay > 0) {\r\ndprintk("no_overlay\n");\r\nreturn -EINVAL;\r\n}\r\nif (!res_get(dev, fh, RESOURCE_OVERLAY))\r\nreturn -EBUSY;\r\nspin_lock_irqsave(&dev->slock, flags);\r\nstart_preview(dev, fh);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\n}\r\nif (!on) {\r\nif (!res_check(fh, RESOURCE_OVERLAY))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&dev->slock, flags);\r\nstop_preview(dev, fh);\r\nspin_unlock_irqrestore(&dev->slock, flags);\r\nres_free(dev, fh, RESOURCE_OVERLAY);\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7134_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nreturn videobuf_reqbufs(saa7134_queue(file), p);\r\n}\r\nstatic int saa7134_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *b)\r\n{\r\nreturn videobuf_querybuf(saa7134_queue(file), b);\r\n}\r\nstatic int saa7134_qbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nreturn videobuf_qbuf(saa7134_queue(file), b);\r\n}\r\nstatic int saa7134_dqbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nreturn videobuf_dqbuf(saa7134_queue(file), b,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nstatic int saa7134_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nint res = saa7134_resource(file);\r\nif (!res_get(dev, fh, res))\r\nreturn -EBUSY;\r\npm_qos_add_request(&dev->qos_request,\r\nPM_QOS_CPU_DMA_LATENCY,\r\n20);\r\nreturn videobuf_streamon(saa7134_queue(file));\r\n}\r\nstatic int saa7134_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nint err;\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nint res = saa7134_resource(file);\r\npm_qos_remove_request(&dev->qos_request);\r\nerr = videobuf_streamoff(saa7134_queue(file));\r\nif (err < 0)\r\nreturn err;\r\nres_free(dev, fh, res);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_register (struct file *file, void *priv,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nreg->val = saa_readb(reg->reg & 0xffffff);\r\nreg->size = 1;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_register (struct file *file, void *priv,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct saa7134_fh *fh = priv;\r\nstruct saa7134_dev *dev = fh->dev;\r\nsaa_writeb(reg->reg & 0xffffff, reg->val);\r\nreturn 0;\r\n}\r\nstatic int radio_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *t)\r\n{\r\nstruct saa7134_fh *fh = file->private_data;\r\nstruct saa7134_dev *dev = fh->dev;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nstrcpy(t->name, "Radio");\r\nsaa_call_all(dev, tuner, g_tuner, t);\r\nt->audmode &= V4L2_TUNER_MODE_MONO | V4L2_TUNER_MODE_STEREO;\r\nif (dev->input->amux == TV) {\r\nt->signal = 0xf800 - ((saa_readb(0x581) & 0x1f) << 11);\r\nt->rxsubchans = (saa_readb(0x529) & 0x08) ?\r\nV4L2_TUNER_SUB_STEREO : V4L2_TUNER_SUB_MONO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int radio_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *t)\r\n{\r\nstruct saa7134_fh *fh = file->private_data;\r\nstruct saa7134_dev *dev = fh->dev;\r\nif (0 != t->index)\r\nreturn -EINVAL;\r\nsaa_call_all(dev, tuner, s_tuner, t);\r\nreturn 0;\r\n}\r\nstatic int radio_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nif (i->index != 0)\r\nreturn -EINVAL;\r\nstrcpy(i->name, "Radio");\r\ni->type = V4L2_INPUT_TYPE_TUNER;\r\nreturn 0;\r\n}\r\nstatic int radio_g_input(struct file *filp, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int radio_s_input(struct file *filp, void *priv, unsigned int i)\r\n{\r\nreturn 0;\r\n}\r\nstatic int radio_s_std(struct file *file, void *fh, v4l2_std_id norm)\r\n{\r\nreturn 0;\r\n}\r\nstatic int radio_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *c)\r\n{\r\nconst struct v4l2_queryctrl *ctrl;\r\nif (c->id < V4L2_CID_BASE ||\r\nc->id >= V4L2_CID_LASTP1)\r\nreturn -EINVAL;\r\nif (c->id == V4L2_CID_AUDIO_MUTE) {\r\nctrl = ctrl_by_id(c->id);\r\n*c = *ctrl;\r\n} else\r\n*c = no_ctrl;\r\nreturn 0;\r\n}\r\nint saa7134_video_init1(struct saa7134_dev *dev)\r\n{\r\nif (gbuffers < 2 || gbuffers > VIDEO_MAX_FRAME)\r\ngbuffers = 2;\r\nif (gbufsize > gbufsize_max)\r\ngbufsize = gbufsize_max;\r\ngbufsize = (gbufsize + PAGE_SIZE - 1) & PAGE_MASK;\r\ndev->ctl_bright = ctrl_by_id(V4L2_CID_BRIGHTNESS)->default_value;\r\ndev->ctl_contrast = ctrl_by_id(V4L2_CID_CONTRAST)->default_value;\r\ndev->ctl_hue = ctrl_by_id(V4L2_CID_HUE)->default_value;\r\ndev->ctl_saturation = ctrl_by_id(V4L2_CID_SATURATION)->default_value;\r\ndev->ctl_volume = ctrl_by_id(V4L2_CID_AUDIO_VOLUME)->default_value;\r\ndev->ctl_mute = 1;\r\ndev->ctl_invert = ctrl_by_id(V4L2_CID_PRIVATE_INVERT)->default_value;\r\ndev->ctl_automute = ctrl_by_id(V4L2_CID_PRIVATE_AUTOMUTE)->default_value;\r\nif (dev->tda9887_conf && dev->ctl_automute)\r\ndev->tda9887_conf |= TDA9887_AUTOMUTE;\r\ndev->automute = 0;\r\nINIT_LIST_HEAD(&dev->video_q.queue);\r\ninit_timer(&dev->video_q.timeout);\r\ndev->video_q.timeout.function = saa7134_buffer_timeout;\r\ndev->video_q.timeout.data = (unsigned long)(&dev->video_q);\r\ndev->video_q.dev = dev;\r\ndev->fmt = format_by_fourcc(V4L2_PIX_FMT_BGR24);\r\ndev->width = 720;\r\ndev->height = 576;\r\ndev->win.w.width = dev->width;\r\ndev->win.w.height = dev->height;\r\ndev->win.field = V4L2_FIELD_INTERLACED;\r\ndev->ovbuf.fmt.width = dev->width;\r\ndev->ovbuf.fmt.height = dev->height;\r\ndev->ovbuf.fmt.pixelformat = dev->fmt->fourcc;\r\ndev->ovbuf.fmt.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nif (saa7134_boards[dev->board].video_out)\r\nsaa7134_videoport_init(dev);\r\nreturn 0;\r\n}\r\nint saa7134_videoport_init(struct saa7134_dev *dev)\r\n{\r\nint vo = saa7134_boards[dev->board].video_out;\r\nint video_reg;\r\nunsigned int vid_port_opts = saa7134_boards[dev->board].vid_port_opts;\r\nsaa_writeb(SAA7134_VIDEO_PORT_CTRL0, video_out[vo][0]);\r\nvideo_reg = video_out[vo][1];\r\nif (vid_port_opts & SET_T_CODE_POLARITY_NON_INVERTED)\r\nvideo_reg &= ~VP_T_CODE_P_INVERTED;\r\nsaa_writeb(SAA7134_VIDEO_PORT_CTRL1, video_reg);\r\nsaa_writeb(SAA7134_VIDEO_PORT_CTRL2, video_out[vo][2]);\r\nsaa_writeb(SAA7134_VIDEO_PORT_CTRL4, video_out[vo][4]);\r\nvideo_reg = video_out[vo][5];\r\nif (vid_port_opts & SET_CLOCK_NOT_DELAYED)\r\nvideo_reg &= ~VP_CLK_CTRL2_DELAYED;\r\nif (vid_port_opts & SET_CLOCK_INVERTED)\r\nvideo_reg |= VP_CLK_CTRL1_INVERTED;\r\nsaa_writeb(SAA7134_VIDEO_PORT_CTRL5, video_reg);\r\nvideo_reg = video_out[vo][6];\r\nif (vid_port_opts & SET_VSYNC_OFF) {\r\nvideo_reg &= ~VP_VS_TYPE_MASK;\r\nvideo_reg |= VP_VS_TYPE_OFF;\r\n}\r\nsaa_writeb(SAA7134_VIDEO_PORT_CTRL6, video_reg);\r\nsaa_writeb(SAA7134_VIDEO_PORT_CTRL7, video_out[vo][7]);\r\nsaa_writeb(SAA7134_VIDEO_PORT_CTRL8, video_out[vo][8]);\r\nsaa_writeb(SAA7134_VIDEO_PORT_CTRL3, video_out[vo][3]);\r\nreturn 0;\r\n}\r\nint saa7134_video_init2(struct saa7134_dev *dev)\r\n{\r\nset_tvnorm(dev,&tvnorms[0]);\r\nvideo_mux(dev,0);\r\nsaa7134_tvaudio_setmute(dev);\r\nsaa7134_tvaudio_setvolume(dev,dev->ctl_volume);\r\nreturn 0;\r\n}\r\nvoid saa7134_irq_video_signalchange(struct saa7134_dev *dev)\r\n{\r\nstatic const char *st[] = {\r\n"(no signal)", "NTSC", "PAL", "SECAM" };\r\nu32 st1,st2;\r\nst1 = saa_readb(SAA7134_STATUS_VIDEO1);\r\nst2 = saa_readb(SAA7134_STATUS_VIDEO2);\r\ndprintk("DCSDT: pll: %s, sync: %s, norm: %s\n",\r\n(st1 & 0x40) ? "not locked" : "locked",\r\n(st2 & 0x40) ? "no" : "yes",\r\nst[st1 & 0x03]);\r\ndev->nosignal = (st1 & 0x40) || (st2 & 0x40) || !(st2 & 0x1);\r\nif (dev->nosignal) {\r\nif (dev->ctl_automute)\r\ndev->automute = 1;\r\nsaa7134_tvaudio_setmute(dev);\r\n} else {\r\nsaa7134_tvaudio_do_scan(dev);\r\n}\r\nif ((st2 & 0x80) && !noninterlaced && !dev->nosignal)\r\nsaa_clearb(SAA7134_SYNC_CTRL, 0x20);\r\nelse\r\nsaa_setb(SAA7134_SYNC_CTRL, 0x20);\r\nif (dev->mops && dev->mops->signal_change)\r\ndev->mops->signal_change(dev);\r\n}\r\nvoid saa7134_irq_video_done(struct saa7134_dev *dev, unsigned long status)\r\n{\r\nenum v4l2_field field;\r\nspin_lock(&dev->slock);\r\nif (dev->video_q.curr) {\r\ndev->video_fieldcount++;\r\nfield = dev->video_q.curr->vb.field;\r\nif (V4L2_FIELD_HAS_BOTH(field)) {\r\nif ((status & 0x10) == 0x00) {\r\ndev->video_q.curr->top_seen = 1;\r\ngoto done;\r\n}\r\nif (!dev->video_q.curr->top_seen)\r\ngoto done;\r\n} else if (field == V4L2_FIELD_TOP) {\r\nif ((status & 0x10) != 0x10)\r\ngoto done;\r\n} else if (field == V4L2_FIELD_BOTTOM) {\r\nif ((status & 0x10) != 0x00)\r\ngoto done;\r\n}\r\ndev->video_q.curr->vb.field_count = dev->video_fieldcount;\r\nsaa7134_buffer_finish(dev,&dev->video_q,VIDEOBUF_DONE);\r\n}\r\nsaa7134_buffer_next(dev,&dev->video_q);\r\ndone:\r\nspin_unlock(&dev->slock);\r\n}
