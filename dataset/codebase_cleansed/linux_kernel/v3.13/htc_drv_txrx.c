int get_hw_qnum(u16 queue, int *hwq_map)\r\n{\r\nswitch (queue) {\r\ncase 0:\r\nreturn hwq_map[IEEE80211_AC_VO];\r\ncase 1:\r\nreturn hwq_map[IEEE80211_AC_VI];\r\ncase 2:\r\nreturn hwq_map[IEEE80211_AC_BE];\r\ncase 3:\r\nreturn hwq_map[IEEE80211_AC_BK];\r\ndefault:\r\nreturn hwq_map[IEEE80211_AC_BE];\r\n}\r\n}\r\nvoid ath9k_htc_check_stop_queues(struct ath9k_htc_priv *priv)\r\n{\r\nspin_lock_bh(&priv->tx.tx_lock);\r\npriv->tx.queued_cnt++;\r\nif ((priv->tx.queued_cnt >= ATH9K_HTC_TX_THRESHOLD) &&\r\n!(priv->tx.flags & ATH9K_HTC_OP_TX_QUEUES_STOP)) {\r\npriv->tx.flags |= ATH9K_HTC_OP_TX_QUEUES_STOP;\r\nieee80211_stop_queues(priv->hw);\r\n}\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\n}\r\nvoid ath9k_htc_check_wake_queues(struct ath9k_htc_priv *priv)\r\n{\r\nspin_lock_bh(&priv->tx.tx_lock);\r\nif ((priv->tx.queued_cnt < ATH9K_HTC_TX_THRESHOLD) &&\r\n(priv->tx.flags & ATH9K_HTC_OP_TX_QUEUES_STOP)) {\r\npriv->tx.flags &= ~ATH9K_HTC_OP_TX_QUEUES_STOP;\r\nieee80211_wake_queues(priv->hw);\r\n}\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\n}\r\nint ath9k_htc_tx_get_slot(struct ath9k_htc_priv *priv)\r\n{\r\nint slot;\r\nspin_lock_bh(&priv->tx.tx_lock);\r\nslot = find_first_zero_bit(priv->tx.tx_slot, MAX_TX_BUF_NUM);\r\nif (slot >= MAX_TX_BUF_NUM) {\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\nreturn -ENOBUFS;\r\n}\r\n__set_bit(slot, priv->tx.tx_slot);\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\nreturn slot;\r\n}\r\nvoid ath9k_htc_tx_clear_slot(struct ath9k_htc_priv *priv, int slot)\r\n{\r\nspin_lock_bh(&priv->tx.tx_lock);\r\n__clear_bit(slot, priv->tx.tx_slot);\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\n}\r\nstatic inline enum htc_endpoint_id get_htc_epid(struct ath9k_htc_priv *priv,\r\nu16 qnum)\r\n{\r\nenum htc_endpoint_id epid;\r\nswitch (qnum) {\r\ncase 0:\r\nTX_QSTAT_INC(IEEE80211_AC_VO);\r\nepid = priv->data_vo_ep;\r\nbreak;\r\ncase 1:\r\nTX_QSTAT_INC(IEEE80211_AC_VI);\r\nepid = priv->data_vi_ep;\r\nbreak;\r\ncase 2:\r\nTX_QSTAT_INC(IEEE80211_AC_BE);\r\nepid = priv->data_be_ep;\r\nbreak;\r\ncase 3:\r\ndefault:\r\nTX_QSTAT_INC(IEEE80211_AC_BK);\r\nepid = priv->data_bk_ep;\r\nbreak;\r\n}\r\nreturn epid;\r\n}\r\nstatic inline struct sk_buff_head*\r\nget_htc_epid_queue(struct ath9k_htc_priv *priv, u8 epid)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct sk_buff_head *epid_queue = NULL;\r\nif (epid == priv->mgmt_ep)\r\nepid_queue = &priv->tx.mgmt_ep_queue;\r\nelse if (epid == priv->cab_ep)\r\nepid_queue = &priv->tx.cab_ep_queue;\r\nelse if (epid == priv->data_be_ep)\r\nepid_queue = &priv->tx.data_be_queue;\r\nelse if (epid == priv->data_bk_ep)\r\nepid_queue = &priv->tx.data_bk_queue;\r\nelse if (epid == priv->data_vi_ep)\r\nepid_queue = &priv->tx.data_vi_queue;\r\nelse if (epid == priv->data_vo_ep)\r\nepid_queue = &priv->tx.data_vo_queue;\r\nelse\r\nath_err(common, "Invalid EPID: %d\n", epid);\r\nreturn epid_queue;\r\n}\r\nstatic inline int strip_drv_header(struct ath9k_htc_priv *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_tx_ctl *tx_ctl;\r\nint slot;\r\ntx_ctl = HTC_SKB_CB(skb);\r\nif (tx_ctl->epid == priv->mgmt_ep) {\r\nstruct tx_mgmt_hdr *tx_mhdr =\r\n(struct tx_mgmt_hdr *)skb->data;\r\nslot = tx_mhdr->cookie;\r\nskb_pull(skb, sizeof(struct tx_mgmt_hdr));\r\n} else if ((tx_ctl->epid == priv->data_bk_ep) ||\r\n(tx_ctl->epid == priv->data_be_ep) ||\r\n(tx_ctl->epid == priv->data_vi_ep) ||\r\n(tx_ctl->epid == priv->data_vo_ep) ||\r\n(tx_ctl->epid == priv->cab_ep)) {\r\nstruct tx_frame_hdr *tx_fhdr =\r\n(struct tx_frame_hdr *)skb->data;\r\nslot = tx_fhdr->cookie;\r\nskb_pull(skb, sizeof(struct tx_frame_hdr));\r\n} else {\r\nath_err(common, "Unsupported EPID: %d\n", tx_ctl->epid);\r\nslot = -EINVAL;\r\n}\r\nreturn slot;\r\n}\r\nint ath_htc_txq_update(struct ath9k_htc_priv *priv, int qnum,\r\nstruct ath9k_tx_queue_info *qinfo)\r\n{\r\nstruct ath_hw *ah = priv->ah;\r\nint error = 0;\r\nstruct ath9k_tx_queue_info qi;\r\nath9k_hw_get_txq_props(ah, qnum, &qi);\r\nqi.tqi_aifs = qinfo->tqi_aifs;\r\nqi.tqi_cwmin = qinfo->tqi_cwmin / 2;\r\nqi.tqi_cwmax = qinfo->tqi_cwmax;\r\nqi.tqi_burstTime = qinfo->tqi_burstTime;\r\nqi.tqi_readyTime = qinfo->tqi_readyTime;\r\nif (!ath9k_hw_set_txq_props(ah, qnum, &qi)) {\r\nath_err(ath9k_hw_common(ah),\r\n"Unable to update hardware queue %u!\n", qnum);\r\nerror = -EIO;\r\n} else {\r\nath9k_hw_resettxqueue(ah, qnum);\r\n}\r\nreturn error;\r\n}\r\nstatic void ath9k_htc_tx_mgmt(struct ath9k_htc_priv *priv,\r\nstruct ath9k_htc_vif *avp,\r\nstruct sk_buff *skb,\r\nu8 sta_idx, u8 vif_idx, u8 slot)\r\n{\r\nstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_mgmt *mgmt;\r\nstruct ieee80211_hdr *hdr;\r\nstruct tx_mgmt_hdr mgmt_hdr;\r\nstruct ath9k_htc_tx_ctl *tx_ctl;\r\nu8 *tx_fhdr;\r\ntx_ctl = HTC_SKB_CB(skb);\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nmemset(tx_ctl, 0, sizeof(*tx_ctl));\r\nmemset(&mgmt_hdr, 0, sizeof(struct tx_mgmt_hdr));\r\nif (avp && unlikely(ieee80211_is_probe_resp(hdr->frame_control))) {\r\nmgmt = (struct ieee80211_mgmt *)skb->data;\r\nmgmt->u.probe_resp.timestamp = avp->tsfadjust;\r\n}\r\ntx_ctl->type = ATH9K_HTC_MGMT;\r\nmgmt_hdr.node_idx = sta_idx;\r\nmgmt_hdr.vif_idx = vif_idx;\r\nmgmt_hdr.tidno = 0;\r\nmgmt_hdr.flags = 0;\r\nmgmt_hdr.cookie = slot;\r\nmgmt_hdr.key_type = ath9k_cmn_get_hw_crypto_keytype(skb);\r\nif (mgmt_hdr.key_type == ATH9K_KEY_TYPE_CLEAR)\r\nmgmt_hdr.keyix = (u8) ATH9K_TXKEYIX_INVALID;\r\nelse\r\nmgmt_hdr.keyix = tx_info->control.hw_key->hw_key_idx;\r\ntx_fhdr = skb_push(skb, sizeof(mgmt_hdr));\r\nmemcpy(tx_fhdr, (u8 *) &mgmt_hdr, sizeof(mgmt_hdr));\r\ntx_ctl->epid = priv->mgmt_ep;\r\n}\r\nstatic void ath9k_htc_tx_data(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_vif *vif,\r\nstruct sk_buff *skb,\r\nu8 sta_idx, u8 vif_idx, u8 slot,\r\nbool is_cab)\r\n{\r\nstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hdr *hdr;\r\nstruct ath9k_htc_tx_ctl *tx_ctl;\r\nstruct tx_frame_hdr tx_hdr;\r\nu32 flags = 0;\r\nu8 *qc, *tx_fhdr;\r\nu16 qnum;\r\ntx_ctl = HTC_SKB_CB(skb);\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nmemset(tx_ctl, 0, sizeof(*tx_ctl));\r\nmemset(&tx_hdr, 0, sizeof(struct tx_frame_hdr));\r\ntx_hdr.node_idx = sta_idx;\r\ntx_hdr.vif_idx = vif_idx;\r\ntx_hdr.cookie = slot;\r\ntx_ctl->sta_idx = sta_idx;\r\nif (tx_info->flags & IEEE80211_TX_CTL_AMPDU) {\r\ntx_ctl->type = ATH9K_HTC_AMPDU;\r\ntx_hdr.data_type = ATH9K_HTC_AMPDU;\r\n} else {\r\ntx_ctl->type = ATH9K_HTC_NORMAL;\r\ntx_hdr.data_type = ATH9K_HTC_NORMAL;\r\n}\r\nif (ieee80211_is_data_qos(hdr->frame_control)) {\r\nqc = ieee80211_get_qos_ctl(hdr);\r\ntx_hdr.tidno = qc[0] & IEEE80211_QOS_CTL_TID_MASK;\r\n}\r\nif (priv->hw->wiphy->rts_threshold != (u32) -1)\r\nif (skb->len > priv->hw->wiphy->rts_threshold)\r\nflags |= ATH9K_HTC_TX_RTSCTS;\r\nif (!(flags & ATH9K_HTC_TX_RTSCTS) &&\r\n(vif && vif->bss_conf.use_cts_prot))\r\nflags |= ATH9K_HTC_TX_CTSONLY;\r\ntx_hdr.flags = cpu_to_be32(flags);\r\ntx_hdr.key_type = ath9k_cmn_get_hw_crypto_keytype(skb);\r\nif (tx_hdr.key_type == ATH9K_KEY_TYPE_CLEAR)\r\ntx_hdr.keyix = (u8) ATH9K_TXKEYIX_INVALID;\r\nelse\r\ntx_hdr.keyix = tx_info->control.hw_key->hw_key_idx;\r\ntx_fhdr = skb_push(skb, sizeof(tx_hdr));\r\nmemcpy(tx_fhdr, (u8 *) &tx_hdr, sizeof(tx_hdr));\r\nif (is_cab) {\r\nCAB_STAT_INC;\r\ntx_ctl->epid = priv->cab_ep;\r\nreturn;\r\n}\r\nqnum = skb_get_queue_mapping(skb);\r\ntx_ctl->epid = get_htc_epid(priv, qnum);\r\n}\r\nint ath9k_htc_tx_start(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_sta *sta,\r\nstruct sk_buff *skb,\r\nu8 slot, bool is_cab)\r\n{\r\nstruct ieee80211_hdr *hdr;\r\nstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_vif *vif = tx_info->control.vif;\r\nstruct ath9k_htc_sta *ista;\r\nstruct ath9k_htc_vif *avp = NULL;\r\nu8 sta_idx, vif_idx;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nif (vif) {\r\navp = (struct ath9k_htc_vif *) vif->drv_priv;\r\nvif_idx = avp->index;\r\n} else {\r\nif (!priv->ah->is_monitoring) {\r\nath_dbg(ath9k_hw_common(priv->ah), XMIT,\r\n"VIF is null, but no monitor interface !\n");\r\nreturn -EINVAL;\r\n}\r\nvif_idx = priv->mon_vif_idx;\r\n}\r\nif (sta) {\r\nista = (struct ath9k_htc_sta *) sta->drv_priv;\r\nsta_idx = ista->index;\r\n} else {\r\nsta_idx = priv->vif_sta_pos[vif_idx];\r\n}\r\nif (ieee80211_is_data(hdr->frame_control))\r\nath9k_htc_tx_data(priv, vif, skb,\r\nsta_idx, vif_idx, slot, is_cab);\r\nelse\r\nath9k_htc_tx_mgmt(priv, avp, skb,\r\nsta_idx, vif_idx, slot);\r\nreturn htc_send(priv->htc, skb);\r\n}\r\nstatic inline bool __ath9k_htc_check_tx_aggr(struct ath9k_htc_priv *priv,\r\nstruct ath9k_htc_sta *ista, u8 tid)\r\n{\r\nbool ret = false;\r\nspin_lock_bh(&priv->tx.tx_lock);\r\nif ((tid < ATH9K_HTC_MAX_TID) && (ista->tid_state[tid] == AGGR_STOP))\r\nret = true;\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\nreturn ret;\r\n}\r\nstatic void ath9k_htc_check_tx_aggr(struct ath9k_htc_priv *priv,\r\nstruct ieee80211_vif *vif,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_sta *sta;\r\nstruct ieee80211_hdr *hdr;\r\n__le16 fc;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nfc = hdr->frame_control;\r\nrcu_read_lock();\r\nsta = ieee80211_find_sta(vif, hdr->addr1);\r\nif (!sta) {\r\nrcu_read_unlock();\r\nreturn;\r\n}\r\nif (sta && conf_is_ht(&priv->hw->conf) &&\r\n!(skb->protocol == cpu_to_be16(ETH_P_PAE))) {\r\nif (ieee80211_is_data_qos(fc)) {\r\nu8 *qc, tid;\r\nstruct ath9k_htc_sta *ista;\r\nqc = ieee80211_get_qos_ctl(hdr);\r\ntid = qc[0] & 0xf;\r\nista = (struct ath9k_htc_sta *)sta->drv_priv;\r\nif (__ath9k_htc_check_tx_aggr(priv, ista, tid)) {\r\nieee80211_start_tx_ba_session(sta, tid, 0);\r\nspin_lock_bh(&priv->tx.tx_lock);\r\nista->tid_state[tid] = AGGR_PROGRESS;\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\n}\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void ath9k_htc_tx_process(struct ath9k_htc_priv *priv,\r\nstruct sk_buff *skb,\r\nstruct __wmi_event_txstatus *txs)\r\n{\r\nstruct ieee80211_vif *vif;\r\nstruct ath9k_htc_tx_ctl *tx_ctl;\r\nstruct ieee80211_tx_info *tx_info;\r\nstruct ieee80211_tx_rate *rate;\r\nstruct ieee80211_conf *cur_conf = &priv->hw->conf;\r\nbool txok;\r\nint slot;\r\nint hdrlen, padsize;\r\nslot = strip_drv_header(priv, skb);\r\nif (slot < 0) {\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\ntx_ctl = HTC_SKB_CB(skb);\r\ntxok = tx_ctl->txok;\r\ntx_info = IEEE80211_SKB_CB(skb);\r\nvif = tx_info->control.vif;\r\nrate = &tx_info->status.rates[0];\r\nmemset(&tx_info->status, 0, sizeof(tx_info->status));\r\nif (!txok || !vif || !txs)\r\ngoto send_mac80211;\r\nif (txs->ts_flags & ATH9K_HTC_TXSTAT_ACK)\r\ntx_info->flags |= IEEE80211_TX_STAT_ACK;\r\nif (txs->ts_flags & ATH9K_HTC_TXSTAT_FILT)\r\ntx_info->flags |= IEEE80211_TX_STAT_TX_FILTERED;\r\nif (txs->ts_flags & ATH9K_HTC_TXSTAT_RTC_CTS)\r\nrate->flags |= IEEE80211_TX_RC_USE_RTS_CTS;\r\nrate->count = 1;\r\nrate->idx = MS(txs->ts_rate, ATH9K_HTC_TXSTAT_RATE);\r\nif (txs->ts_flags & ATH9K_HTC_TXSTAT_MCS) {\r\nrate->flags |= IEEE80211_TX_RC_MCS;\r\nif (txs->ts_flags & ATH9K_HTC_TXSTAT_CW40)\r\nrate->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\r\nif (txs->ts_flags & ATH9K_HTC_TXSTAT_SGI)\r\nrate->flags |= IEEE80211_TX_RC_SHORT_GI;\r\n} else {\r\nif (cur_conf->chandef.chan->band == IEEE80211_BAND_5GHZ)\r\nrate->idx += 4;\r\n}\r\nath9k_htc_check_tx_aggr(priv, vif, skb);\r\nsend_mac80211:\r\nspin_lock_bh(&priv->tx.tx_lock);\r\nif (WARN_ON(--priv->tx.queued_cnt < 0))\r\npriv->tx.queued_cnt = 0;\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\nath9k_htc_tx_clear_slot(priv, slot);\r\nhdrlen = ieee80211_get_hdrlen_from_skb(skb);\r\npadsize = hdrlen & 3;\r\nif (padsize && skb->len > hdrlen + padsize) {\r\nmemmove(skb->data + padsize, skb->data, hdrlen);\r\nskb_pull(skb, padsize);\r\n}\r\nieee80211_tx_status(priv->hw, skb);\r\n}\r\nstatic inline void ath9k_htc_tx_drainq(struct ath9k_htc_priv *priv,\r\nstruct sk_buff_head *queue)\r\n{\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(queue)) != NULL) {\r\nath9k_htc_tx_process(priv, skb, NULL);\r\n}\r\n}\r\nvoid ath9k_htc_tx_drain(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath9k_htc_tx_event *event, *tmp;\r\nspin_lock_bh(&priv->tx.tx_lock);\r\npriv->tx.flags |= ATH9K_HTC_OP_TX_DRAIN;\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\nhtc_stop(priv->htc);\r\ntasklet_kill(&priv->wmi->wmi_event_tasklet);\r\ntasklet_kill(&priv->tx_failed_tasklet);\r\nath9k_htc_tx_drainq(priv, &priv->tx.mgmt_ep_queue);\r\nath9k_htc_tx_drainq(priv, &priv->tx.cab_ep_queue);\r\nath9k_htc_tx_drainq(priv, &priv->tx.data_be_queue);\r\nath9k_htc_tx_drainq(priv, &priv->tx.data_bk_queue);\r\nath9k_htc_tx_drainq(priv, &priv->tx.data_vi_queue);\r\nath9k_htc_tx_drainq(priv, &priv->tx.data_vo_queue);\r\nath9k_htc_tx_drainq(priv, &priv->tx.tx_failed);\r\nspin_lock_bh(&priv->wmi->event_lock);\r\nlist_for_each_entry_safe(event, tmp, &priv->wmi->pending_tx_events, list) {\r\nlist_del(&event->list);\r\nkfree(event);\r\n}\r\nspin_unlock_bh(&priv->wmi->event_lock);\r\nspin_lock_bh(&priv->tx.tx_lock);\r\npriv->tx.flags &= ~ATH9K_HTC_OP_TX_DRAIN;\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\n}\r\nvoid ath9k_tx_failed_tasklet(unsigned long data)\r\n{\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *)data;\r\nspin_lock_bh(&priv->tx.tx_lock);\r\nif (priv->tx.flags & ATH9K_HTC_OP_TX_DRAIN) {\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\nreturn;\r\n}\r\nspin_unlock_bh(&priv->tx.tx_lock);\r\nath9k_htc_tx_drainq(priv, &priv->tx.tx_failed);\r\n}\r\nstatic inline bool check_cookie(struct ath9k_htc_priv *priv,\r\nstruct sk_buff *skb,\r\nu8 cookie, u8 epid)\r\n{\r\nu8 fcookie = 0;\r\nif (epid == priv->mgmt_ep) {\r\nstruct tx_mgmt_hdr *hdr;\r\nhdr = (struct tx_mgmt_hdr *) skb->data;\r\nfcookie = hdr->cookie;\r\n} else if ((epid == priv->data_bk_ep) ||\r\n(epid == priv->data_be_ep) ||\r\n(epid == priv->data_vi_ep) ||\r\n(epid == priv->data_vo_ep) ||\r\n(epid == priv->cab_ep)) {\r\nstruct tx_frame_hdr *hdr;\r\nhdr = (struct tx_frame_hdr *) skb->data;\r\nfcookie = hdr->cookie;\r\n}\r\nif (fcookie == cookie)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic struct sk_buff* ath9k_htc_tx_get_packet(struct ath9k_htc_priv *priv,\r\nstruct __wmi_event_txstatus *txs)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct sk_buff_head *epid_queue;\r\nstruct sk_buff *skb, *tmp;\r\nunsigned long flags;\r\nu8 epid = MS(txs->ts_rate, ATH9K_HTC_TXSTAT_EPID);\r\nepid_queue = get_htc_epid_queue(priv, epid);\r\nif (!epid_queue)\r\nreturn NULL;\r\nspin_lock_irqsave(&epid_queue->lock, flags);\r\nskb_queue_walk_safe(epid_queue, skb, tmp) {\r\nif (check_cookie(priv, skb, txs->cookie, epid)) {\r\n__skb_unlink(skb, epid_queue);\r\nspin_unlock_irqrestore(&epid_queue->lock, flags);\r\nreturn skb;\r\n}\r\n}\r\nspin_unlock_irqrestore(&epid_queue->lock, flags);\r\nath_dbg(common, XMIT, "No matching packet for cookie: %d, epid: %d\n",\r\ntxs->cookie, epid);\r\nreturn NULL;\r\n}\r\nvoid ath9k_htc_txstatus(struct ath9k_htc_priv *priv, void *wmi_event)\r\n{\r\nstruct wmi_event_txstatus *txs = (struct wmi_event_txstatus *)wmi_event;\r\nstruct __wmi_event_txstatus *__txs;\r\nstruct sk_buff *skb;\r\nstruct ath9k_htc_tx_event *tx_pend;\r\nint i;\r\nfor (i = 0; i < txs->cnt; i++) {\r\nWARN_ON(txs->cnt > HTC_MAX_TX_STATUS);\r\n__txs = &txs->txstatus[i];\r\nskb = ath9k_htc_tx_get_packet(priv, __txs);\r\nif (!skb) {\r\ntx_pend = kzalloc(sizeof(struct ath9k_htc_tx_event),\r\nGFP_ATOMIC);\r\nif (!tx_pend)\r\ncontinue;\r\nmemcpy(&tx_pend->txs, __txs,\r\nsizeof(struct __wmi_event_txstatus));\r\nspin_lock(&priv->wmi->event_lock);\r\nlist_add_tail(&tx_pend->list,\r\n&priv->wmi->pending_tx_events);\r\nspin_unlock(&priv->wmi->event_lock);\r\ncontinue;\r\n}\r\nath9k_htc_tx_process(priv, skb, __txs);\r\n}\r\nath9k_htc_check_wake_queues(priv);\r\n}\r\nvoid ath9k_htc_txep(void *drv_priv, struct sk_buff *skb,\r\nenum htc_endpoint_id ep_id, bool txok)\r\n{\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) drv_priv;\r\nstruct ath9k_htc_tx_ctl *tx_ctl;\r\nstruct sk_buff_head *epid_queue;\r\ntx_ctl = HTC_SKB_CB(skb);\r\ntx_ctl->txok = txok;\r\ntx_ctl->timestamp = jiffies;\r\nif (!txok) {\r\nskb_queue_tail(&priv->tx.tx_failed, skb);\r\ntasklet_schedule(&priv->tx_failed_tasklet);\r\nreturn;\r\n}\r\nepid_queue = get_htc_epid_queue(priv, ep_id);\r\nif (!epid_queue) {\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\nskb_queue_tail(epid_queue, skb);\r\n}\r\nstatic inline bool check_packet(struct ath9k_htc_priv *priv, struct sk_buff *skb)\r\n{\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_tx_ctl *tx_ctl;\r\ntx_ctl = HTC_SKB_CB(skb);\r\nif (time_after(jiffies,\r\ntx_ctl->timestamp +\r\nmsecs_to_jiffies(ATH9K_HTC_TX_TIMEOUT_INTERVAL))) {\r\nath_dbg(common, XMIT, "Dropping a packet due to TX timeout\n");\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void ath9k_htc_tx_cleanup_queue(struct ath9k_htc_priv *priv,\r\nstruct sk_buff_head *epid_queue)\r\n{\r\nbool process = false;\r\nunsigned long flags;\r\nstruct sk_buff *skb, *tmp;\r\nstruct sk_buff_head queue;\r\nskb_queue_head_init(&queue);\r\nspin_lock_irqsave(&epid_queue->lock, flags);\r\nskb_queue_walk_safe(epid_queue, skb, tmp) {\r\nif (check_packet(priv, skb)) {\r\n__skb_unlink(skb, epid_queue);\r\n__skb_queue_tail(&queue, skb);\r\nprocess = true;\r\n}\r\n}\r\nspin_unlock_irqrestore(&epid_queue->lock, flags);\r\nif (process) {\r\nskb_queue_walk_safe(&queue, skb, tmp) {\r\n__skb_unlink(skb, &queue);\r\nath9k_htc_tx_process(priv, skb, NULL);\r\n}\r\n}\r\n}\r\nvoid ath9k_htc_tx_cleanup_timer(unsigned long data)\r\n{\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *) data;\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath9k_htc_tx_event *event, *tmp;\r\nstruct sk_buff *skb;\r\nspin_lock(&priv->wmi->event_lock);\r\nlist_for_each_entry_safe(event, tmp, &priv->wmi->pending_tx_events, list) {\r\nskb = ath9k_htc_tx_get_packet(priv, &event->txs);\r\nif (skb) {\r\nath_dbg(common, XMIT,\r\n"Found packet for cookie: %d, epid: %d\n",\r\nevent->txs.cookie,\r\nMS(event->txs.ts_rate, ATH9K_HTC_TXSTAT_EPID));\r\nath9k_htc_tx_process(priv, skb, &event->txs);\r\nlist_del(&event->list);\r\nkfree(event);\r\ncontinue;\r\n}\r\nif (++event->count >= ATH9K_HTC_TX_TIMEOUT_COUNT) {\r\nlist_del(&event->list);\r\nkfree(event);\r\n}\r\n}\r\nspin_unlock(&priv->wmi->event_lock);\r\nath9k_htc_tx_cleanup_queue(priv, &priv->tx.mgmt_ep_queue);\r\nath9k_htc_tx_cleanup_queue(priv, &priv->tx.cab_ep_queue);\r\nath9k_htc_tx_cleanup_queue(priv, &priv->tx.data_be_queue);\r\nath9k_htc_tx_cleanup_queue(priv, &priv->tx.data_bk_queue);\r\nath9k_htc_tx_cleanup_queue(priv, &priv->tx.data_vi_queue);\r\nath9k_htc_tx_cleanup_queue(priv, &priv->tx.data_vo_queue);\r\nath9k_htc_check_wake_queues(priv);\r\nmod_timer(&priv->tx.cleanup_timer,\r\njiffies + msecs_to_jiffies(ATH9K_HTC_TX_CLEANUP_INTERVAL));\r\n}\r\nint ath9k_tx_init(struct ath9k_htc_priv *priv)\r\n{\r\nskb_queue_head_init(&priv->tx.mgmt_ep_queue);\r\nskb_queue_head_init(&priv->tx.cab_ep_queue);\r\nskb_queue_head_init(&priv->tx.data_be_queue);\r\nskb_queue_head_init(&priv->tx.data_bk_queue);\r\nskb_queue_head_init(&priv->tx.data_vi_queue);\r\nskb_queue_head_init(&priv->tx.data_vo_queue);\r\nskb_queue_head_init(&priv->tx.tx_failed);\r\nreturn 0;\r\n}\r\nvoid ath9k_tx_cleanup(struct ath9k_htc_priv *priv)\r\n{\r\n}\r\nbool ath9k_htc_txq_setup(struct ath9k_htc_priv *priv, int subtype)\r\n{\r\nstruct ath_hw *ah = priv->ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_tx_queue_info qi;\r\nint qnum;\r\nmemset(&qi, 0, sizeof(qi));\r\nATH9K_HTC_INIT_TXQ(subtype);\r\nqnum = ath9k_hw_setuptxqueue(priv->ah, ATH9K_TX_QUEUE_DATA, &qi);\r\nif (qnum == -1)\r\nreturn false;\r\nif (qnum >= ARRAY_SIZE(priv->hwq_map)) {\r\nath_err(common, "qnum %u out of range, max %zu!\n",\r\nqnum, ARRAY_SIZE(priv->hwq_map));\r\nath9k_hw_releasetxqueue(ah, qnum);\r\nreturn false;\r\n}\r\npriv->hwq_map[subtype] = qnum;\r\nreturn true;\r\n}\r\nint ath9k_htc_cabq_setup(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath9k_tx_queue_info qi;\r\nmemset(&qi, 0, sizeof(qi));\r\nATH9K_HTC_INIT_TXQ(0);\r\nreturn ath9k_hw_setuptxqueue(priv->ah, ATH9K_TX_QUEUE_CAB, &qi);\r\n}\r\nu32 ath9k_htc_calcrxfilter(struct ath9k_htc_priv *priv)\r\n{\r\n#define RX_FILTER_PRESERVE (ATH9K_RX_FILTER_PHYERR | ATH9K_RX_FILTER_PHYRADAR)\r\nstruct ath_hw *ah = priv->ah;\r\nu32 rfilt;\r\nrfilt = (ath9k_hw_getrxfilter(ah) & RX_FILTER_PRESERVE)\r\n| ATH9K_RX_FILTER_UCAST | ATH9K_RX_FILTER_BCAST\r\n| ATH9K_RX_FILTER_MCAST;\r\nif (priv->rxfilter & FIF_PROBE_REQ)\r\nrfilt |= ATH9K_RX_FILTER_PROBEREQ;\r\nif (((ah->opmode != NL80211_IFTYPE_AP) &&\r\n(priv->rxfilter & FIF_PROMISC_IN_BSS)) ||\r\nah->is_monitoring)\r\nrfilt |= ATH9K_RX_FILTER_PROM;\r\nif (priv->rxfilter & FIF_CONTROL)\r\nrfilt |= ATH9K_RX_FILTER_CONTROL;\r\nif ((ah->opmode == NL80211_IFTYPE_STATION) &&\r\n(priv->nvifs <= 1) &&\r\n!(priv->rxfilter & FIF_BCN_PRBRESP_PROMISC))\r\nrfilt |= ATH9K_RX_FILTER_MYBEACON;\r\nelse\r\nrfilt |= ATH9K_RX_FILTER_BEACON;\r\nif (conf_is_ht(&priv->hw->conf)) {\r\nrfilt |= ATH9K_RX_FILTER_COMP_BAR;\r\nrfilt |= ATH9K_RX_FILTER_UNCOMP_BA_BAR;\r\n}\r\nif (priv->rxfilter & FIF_PSPOLL)\r\nrfilt |= ATH9K_RX_FILTER_PSPOLL;\r\nif (priv->nvifs > 1 || priv->rxfilter & FIF_OTHER_BSS)\r\nrfilt |= ATH9K_RX_FILTER_MCAST_BCAST_ALL;\r\nreturn rfilt;\r\n#undef RX_FILTER_PRESERVE\r\n}\r\nstatic void ath9k_htc_opmode_init(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath_hw *ah = priv->ah;\r\nu32 rfilt, mfilt[2];\r\nrfilt = ath9k_htc_calcrxfilter(priv);\r\nath9k_hw_setrxfilter(ah, rfilt);\r\nmfilt[0] = mfilt[1] = ~0;\r\nath9k_hw_setmcastfilter(ah, mfilt[0], mfilt[1]);\r\n}\r\nvoid ath9k_host_rx_init(struct ath9k_htc_priv *priv)\r\n{\r\nath9k_hw_rxena(priv->ah);\r\nath9k_htc_opmode_init(priv);\r\nath9k_hw_startpcureceive(priv->ah, test_bit(OP_SCANNING, &priv->op_flags));\r\npriv->rx.last_rssi = ATH_RSSI_DUMMY_MARKER;\r\n}\r\nstatic void ath9k_process_rate(struct ieee80211_hw *hw,\r\nstruct ieee80211_rx_status *rxs,\r\nu8 rx_rate, u8 rs_flags)\r\n{\r\nstruct ieee80211_supported_band *sband;\r\nenum ieee80211_band band;\r\nunsigned int i = 0;\r\nif (rx_rate & 0x80) {\r\nrxs->flag |= RX_FLAG_HT;\r\nif (rs_flags & ATH9K_RX_2040)\r\nrxs->flag |= RX_FLAG_40MHZ;\r\nif (rs_flags & ATH9K_RX_GI)\r\nrxs->flag |= RX_FLAG_SHORT_GI;\r\nrxs->rate_idx = rx_rate & 0x7f;\r\nreturn;\r\n}\r\nband = hw->conf.chandef.chan->band;\r\nsband = hw->wiphy->bands[band];\r\nfor (i = 0; i < sband->n_bitrates; i++) {\r\nif (sband->bitrates[i].hw_value == rx_rate) {\r\nrxs->rate_idx = i;\r\nreturn;\r\n}\r\nif (sband->bitrates[i].hw_value_short == rx_rate) {\r\nrxs->rate_idx = i;\r\nrxs->flag |= RX_FLAG_SHORTPRE;\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic bool ath9k_rx_prepare(struct ath9k_htc_priv *priv,\r\nstruct ath9k_htc_rxbuf *rxbuf,\r\nstruct ieee80211_rx_status *rx_status)\r\n{\r\nstruct ieee80211_hdr *hdr;\r\nstruct ieee80211_hw *hw = priv->hw;\r\nstruct sk_buff *skb = rxbuf->skb;\r\nstruct ath_common *common = ath9k_hw_common(priv->ah);\r\nstruct ath_htc_rx_status *rxstatus;\r\nint hdrlen, padsize;\r\nint last_rssi = ATH_RSSI_DUMMY_MARKER;\r\n__le16 fc;\r\nif (skb->len < HTC_RX_FRAME_HEADER_SIZE) {\r\nath_err(common, "Corrupted RX frame, dropping (len: %d)\n",\r\nskb->len);\r\ngoto rx_next;\r\n}\r\nrxstatus = (struct ath_htc_rx_status *)skb->data;\r\nif (be16_to_cpu(rxstatus->rs_datalen) -\r\n(skb->len - HTC_RX_FRAME_HEADER_SIZE) != 0) {\r\nath_err(common,\r\n"Corrupted RX data len, dropping (dlen: %d, skblen: %d)\n",\r\nrxstatus->rs_datalen, skb->len);\r\ngoto rx_next;\r\n}\r\nath9k_htc_err_stat_rx(priv, rxstatus);\r\nmemcpy(&rxbuf->rxstatus, rxstatus, HTC_RX_FRAME_HEADER_SIZE);\r\nskb_pull(skb, HTC_RX_FRAME_HEADER_SIZE);\r\nhdr = (struct ieee80211_hdr *)skb->data;\r\nfc = hdr->frame_control;\r\nhdrlen = ieee80211_get_hdrlen_from_skb(skb);\r\npadsize = hdrlen & 3;\r\nif (padsize && skb->len >= hdrlen+padsize+FCS_LEN) {\r\nmemmove(skb->data + padsize, skb->data, hdrlen);\r\nskb_pull(skb, padsize);\r\n}\r\nmemset(rx_status, 0, sizeof(struct ieee80211_rx_status));\r\nif (rxbuf->rxstatus.rs_status != 0) {\r\nif (rxbuf->rxstatus.rs_status & ATH9K_RXERR_CRC)\r\nrx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\r\nif (rxbuf->rxstatus.rs_status & ATH9K_RXERR_PHY)\r\ngoto rx_next;\r\nif (rxbuf->rxstatus.rs_status & ATH9K_RXERR_DECRYPT) {\r\n} else if (rxbuf->rxstatus.rs_status & ATH9K_RXERR_MIC) {\r\nif (ieee80211_is_ctl(fc))\r\nrxbuf->rxstatus.rs_status &= ~ATH9K_RXERR_MIC;\r\nelse\r\nrx_status->flag |= RX_FLAG_MMIC_ERROR;\r\n}\r\nif (priv->ah->opmode == NL80211_IFTYPE_MONITOR) {\r\nif (rxbuf->rxstatus.rs_status &\r\n~(ATH9K_RXERR_DECRYPT | ATH9K_RXERR_MIC |\r\nATH9K_RXERR_CRC))\r\ngoto rx_next;\r\n} else {\r\nif (rxbuf->rxstatus.rs_status &\r\n~(ATH9K_RXERR_DECRYPT | ATH9K_RXERR_MIC)) {\r\ngoto rx_next;\r\n}\r\n}\r\n}\r\nif (!(rxbuf->rxstatus.rs_status & ATH9K_RXERR_DECRYPT)) {\r\nu8 keyix;\r\nkeyix = rxbuf->rxstatus.rs_keyix;\r\nif (keyix != ATH9K_RXKEYIX_INVALID) {\r\nrx_status->flag |= RX_FLAG_DECRYPTED;\r\n} else if (ieee80211_has_protected(fc) &&\r\nskb->len >= hdrlen + 4) {\r\nkeyix = skb->data[hdrlen + 3] >> 6;\r\nif (test_bit(keyix, common->keymap))\r\nrx_status->flag |= RX_FLAG_DECRYPTED;\r\n}\r\n}\r\nath9k_process_rate(hw, rx_status, rxbuf->rxstatus.rs_rate,\r\nrxbuf->rxstatus.rs_flags);\r\nif (rxbuf->rxstatus.rs_rssi != ATH9K_RSSI_BAD &&\r\n!rxbuf->rxstatus.rs_moreaggr)\r\nATH_RSSI_LPF(priv->rx.last_rssi,\r\nrxbuf->rxstatus.rs_rssi);\r\nlast_rssi = priv->rx.last_rssi;\r\nif (ieee80211_is_beacon(hdr->frame_control) &&\r\n!is_zero_ether_addr(common->curbssid) &&\r\nether_addr_equal(hdr->addr3, common->curbssid)) {\r\ns8 rssi = rxbuf->rxstatus.rs_rssi;\r\nif (likely(last_rssi != ATH_RSSI_DUMMY_MARKER))\r\nrssi = ATH_EP_RND(last_rssi, ATH_RSSI_EP_MULTIPLIER);\r\nif (rssi < 0)\r\nrssi = 0;\r\npriv->ah->stats.avgbrssi = rssi;\r\n}\r\nrx_status->mactime = be64_to_cpu(rxbuf->rxstatus.rs_tstamp);\r\nrx_status->band = hw->conf.chandef.chan->band;\r\nrx_status->freq = hw->conf.chandef.chan->center_freq;\r\nrx_status->signal = rxbuf->rxstatus.rs_rssi + ATH_DEFAULT_NOISE_FLOOR;\r\nrx_status->antenna = rxbuf->rxstatus.rs_antenna;\r\nrx_status->flag |= RX_FLAG_MACTIME_END;\r\nreturn true;\r\nrx_next:\r\nreturn false;\r\n}\r\nvoid ath9k_rx_tasklet(unsigned long data)\r\n{\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *)data;\r\nstruct ath9k_htc_rxbuf *rxbuf = NULL, *tmp_buf = NULL;\r\nstruct ieee80211_rx_status rx_status;\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nstruct ieee80211_hdr *hdr;\r\ndo {\r\nspin_lock_irqsave(&priv->rx.rxbuflock, flags);\r\nlist_for_each_entry(tmp_buf, &priv->rx.rxbuf, list) {\r\nif (tmp_buf->in_process) {\r\nrxbuf = tmp_buf;\r\nbreak;\r\n}\r\n}\r\nif (rxbuf == NULL) {\r\nspin_unlock_irqrestore(&priv->rx.rxbuflock, flags);\r\nbreak;\r\n}\r\nif (!rxbuf->skb)\r\ngoto requeue;\r\nif (!ath9k_rx_prepare(priv, rxbuf, &rx_status)) {\r\ndev_kfree_skb_any(rxbuf->skb);\r\ngoto requeue;\r\n}\r\nmemcpy(IEEE80211_SKB_RXCB(rxbuf->skb), &rx_status,\r\nsizeof(struct ieee80211_rx_status));\r\nskb = rxbuf->skb;\r\nhdr = (struct ieee80211_hdr *) skb->data;\r\nif (ieee80211_is_beacon(hdr->frame_control) && priv->ps_enabled)\r\nieee80211_queue_work(priv->hw, &priv->ps_work);\r\nspin_unlock_irqrestore(&priv->rx.rxbuflock, flags);\r\nieee80211_rx(priv->hw, skb);\r\nspin_lock_irqsave(&priv->rx.rxbuflock, flags);\r\nrequeue:\r\nrxbuf->in_process = false;\r\nrxbuf->skb = NULL;\r\nlist_move_tail(&rxbuf->list, &priv->rx.rxbuf);\r\nrxbuf = NULL;\r\nspin_unlock_irqrestore(&priv->rx.rxbuflock, flags);\r\n} while (1);\r\n}\r\nvoid ath9k_htc_rxep(void *drv_priv, struct sk_buff *skb,\r\nenum htc_endpoint_id ep_id)\r\n{\r\nstruct ath9k_htc_priv *priv = (struct ath9k_htc_priv *)drv_priv;\r\nstruct ath_hw *ah = priv->ah;\r\nstruct ath_common *common = ath9k_hw_common(ah);\r\nstruct ath9k_htc_rxbuf *rxbuf = NULL, *tmp_buf = NULL;\r\nspin_lock(&priv->rx.rxbuflock);\r\nlist_for_each_entry(tmp_buf, &priv->rx.rxbuf, list) {\r\nif (!tmp_buf->in_process) {\r\nrxbuf = tmp_buf;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&priv->rx.rxbuflock);\r\nif (rxbuf == NULL) {\r\nath_dbg(common, ANY, "No free RX buffer\n");\r\ngoto err;\r\n}\r\nspin_lock(&priv->rx.rxbuflock);\r\nrxbuf->skb = skb;\r\nrxbuf->in_process = true;\r\nspin_unlock(&priv->rx.rxbuflock);\r\ntasklet_schedule(&priv->rx_tasklet);\r\nreturn;\r\nerr:\r\ndev_kfree_skb_any(skb);\r\n}\r\nvoid ath9k_rx_cleanup(struct ath9k_htc_priv *priv)\r\n{\r\nstruct ath9k_htc_rxbuf *rxbuf, *tbuf;\r\nlist_for_each_entry_safe(rxbuf, tbuf, &priv->rx.rxbuf, list) {\r\nlist_del(&rxbuf->list);\r\nif (rxbuf->skb)\r\ndev_kfree_skb_any(rxbuf->skb);\r\nkfree(rxbuf);\r\n}\r\n}\r\nint ath9k_rx_init(struct ath9k_htc_priv *priv)\r\n{\r\nint i = 0;\r\nINIT_LIST_HEAD(&priv->rx.rxbuf);\r\nspin_lock_init(&priv->rx.rxbuflock);\r\nfor (i = 0; i < ATH9K_HTC_RXBUF; i++) {\r\nstruct ath9k_htc_rxbuf *rxbuf =\r\nkzalloc(sizeof(struct ath9k_htc_rxbuf), GFP_KERNEL);\r\nif (rxbuf == NULL)\r\ngoto err;\r\nlist_add_tail(&rxbuf->list, &priv->rx.rxbuf);\r\n}\r\nreturn 0;\r\nerr:\r\nath9k_rx_cleanup(priv);\r\nreturn -ENOMEM;\r\n}
