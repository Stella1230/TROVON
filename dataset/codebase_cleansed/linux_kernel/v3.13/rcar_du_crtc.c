static u32 rcar_du_crtc_read(struct rcar_du_crtc *rcrtc, u32 reg)\r\n{\r\nstruct rcar_du_device *rcdu = rcrtc->group->dev;\r\nreturn rcar_du_read(rcdu, rcrtc->mmio_offset + reg);\r\n}\r\nstatic void rcar_du_crtc_write(struct rcar_du_crtc *rcrtc, u32 reg, u32 data)\r\n{\r\nstruct rcar_du_device *rcdu = rcrtc->group->dev;\r\nrcar_du_write(rcdu, rcrtc->mmio_offset + reg, data);\r\n}\r\nstatic void rcar_du_crtc_clr(struct rcar_du_crtc *rcrtc, u32 reg, u32 clr)\r\n{\r\nstruct rcar_du_device *rcdu = rcrtc->group->dev;\r\nrcar_du_write(rcdu, rcrtc->mmio_offset + reg,\r\nrcar_du_read(rcdu, rcrtc->mmio_offset + reg) & ~clr);\r\n}\r\nstatic void rcar_du_crtc_set(struct rcar_du_crtc *rcrtc, u32 reg, u32 set)\r\n{\r\nstruct rcar_du_device *rcdu = rcrtc->group->dev;\r\nrcar_du_write(rcdu, rcrtc->mmio_offset + reg,\r\nrcar_du_read(rcdu, rcrtc->mmio_offset + reg) | set);\r\n}\r\nstatic void rcar_du_crtc_clr_set(struct rcar_du_crtc *rcrtc, u32 reg,\r\nu32 clr, u32 set)\r\n{\r\nstruct rcar_du_device *rcdu = rcrtc->group->dev;\r\nu32 value = rcar_du_read(rcdu, rcrtc->mmio_offset + reg);\r\nrcar_du_write(rcdu, rcrtc->mmio_offset + reg, (value & ~clr) | set);\r\n}\r\nstatic int rcar_du_crtc_get(struct rcar_du_crtc *rcrtc)\r\n{\r\nint ret;\r\nret = clk_prepare_enable(rcrtc->clock);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rcar_du_group_get(rcrtc->group);\r\nif (ret < 0)\r\nclk_disable_unprepare(rcrtc->clock);\r\nreturn ret;\r\n}\r\nstatic void rcar_du_crtc_put(struct rcar_du_crtc *rcrtc)\r\n{\r\nrcar_du_group_put(rcrtc->group);\r\nclk_disable_unprepare(rcrtc->clock);\r\n}\r\nstatic void rcar_du_crtc_set_display_timing(struct rcar_du_crtc *rcrtc)\r\n{\r\nconst struct drm_display_mode *mode = &rcrtc->crtc.mode;\r\nunsigned long clk;\r\nu32 value;\r\nu32 div;\r\nclk = clk_get_rate(rcrtc->clock);\r\ndiv = DIV_ROUND_CLOSEST(clk, mode->clock * 1000);\r\ndiv = clamp(div, 1U, 64U) - 1;\r\nrcar_du_group_write(rcrtc->group, rcrtc->index % 2 ? ESCR2 : ESCR,\r\nESCR_DCLKSEL_CLKS | div);\r\nrcar_du_group_write(rcrtc->group, rcrtc->index % 2 ? OTAR2 : OTAR, 0);\r\nvalue = ((mode->flags & DRM_MODE_FLAG_PVSYNC) ? 0 : DSMR_VSL)\r\n| ((mode->flags & DRM_MODE_FLAG_PHSYNC) ? 0 : DSMR_HSL)\r\n| DSMR_DIPM_DE;\r\nrcar_du_crtc_write(rcrtc, DSMR, value);\r\nrcar_du_crtc_write(rcrtc, HDSR, mode->htotal - mode->hsync_start - 19);\r\nrcar_du_crtc_write(rcrtc, HDER, mode->htotal - mode->hsync_start +\r\nmode->hdisplay - 19);\r\nrcar_du_crtc_write(rcrtc, HSWR, mode->hsync_end -\r\nmode->hsync_start - 1);\r\nrcar_du_crtc_write(rcrtc, HCR, mode->htotal - 1);\r\nrcar_du_crtc_write(rcrtc, VDSR, mode->vtotal - mode->vsync_end - 2);\r\nrcar_du_crtc_write(rcrtc, VDER, mode->vtotal - mode->vsync_end +\r\nmode->vdisplay - 2);\r\nrcar_du_crtc_write(rcrtc, VSPR, mode->vtotal - mode->vsync_end +\r\nmode->vsync_start - 1);\r\nrcar_du_crtc_write(rcrtc, VCR, mode->vtotal - 1);\r\nrcar_du_crtc_write(rcrtc, DESR, mode->htotal - mode->hsync_start);\r\nrcar_du_crtc_write(rcrtc, DEWR, mode->hdisplay);\r\n}\r\nvoid rcar_du_crtc_route_output(struct drm_crtc *crtc,\r\nenum rcar_du_output output)\r\n{\r\nstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\r\nstruct rcar_du_device *rcdu = rcrtc->group->dev;\r\nrcrtc->outputs |= BIT(output);\r\nif (rcar_du_has(rcdu, RCAR_DU_FEATURE_DEFR8) &&\r\noutput == RCAR_DU_OUTPUT_DPAD0)\r\nrcdu->dpad0_source = rcrtc->index;\r\n}\r\nvoid rcar_du_crtc_update_planes(struct drm_crtc *crtc)\r\n{\r\nstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\r\nstruct rcar_du_plane *planes[RCAR_DU_NUM_HW_PLANES];\r\nunsigned int num_planes = 0;\r\nunsigned int prio = 0;\r\nunsigned int i;\r\nu32 dptsr = 0;\r\nu32 dspr = 0;\r\nfor (i = 0; i < ARRAY_SIZE(rcrtc->group->planes.planes); ++i) {\r\nstruct rcar_du_plane *plane = &rcrtc->group->planes.planes[i];\r\nunsigned int j;\r\nif (plane->crtc != &rcrtc->crtc || !plane->enabled)\r\ncontinue;\r\nfor (j = num_planes++; j > 0; --j) {\r\nif (planes[j-1]->zpos <= plane->zpos)\r\nbreak;\r\nplanes[j] = planes[j-1];\r\n}\r\nplanes[j] = plane;\r\nprio += plane->format->planes * 4;\r\n}\r\nfor (i = 0; i < num_planes; ++i) {\r\nstruct rcar_du_plane *plane = planes[i];\r\nunsigned int index = plane->hwindex;\r\nprio -= 4;\r\ndspr |= (index + 1) << prio;\r\ndptsr |= DPTSR_PnDK(index) | DPTSR_PnTS(index);\r\nif (plane->format->planes == 2) {\r\nindex = (index + 1) % 8;\r\nprio -= 4;\r\ndspr |= (index + 1) << prio;\r\ndptsr |= DPTSR_PnDK(index) | DPTSR_PnTS(index);\r\n}\r\n}\r\nif (rcrtc->index % 2) {\r\nu32 value = rcar_du_group_read(rcrtc->group, DPTSR);\r\nif (value != dptsr) {\r\nrcar_du_group_write(rcrtc->group, DPTSR, dptsr);\r\nif (rcrtc->group->used_crtcs)\r\nrcar_du_group_restart(rcrtc->group);\r\n}\r\n}\r\nrcar_du_group_write(rcrtc->group, rcrtc->index % 2 ? DS2PR : DS1PR,\r\ndspr);\r\n}\r\nstatic void rcar_du_crtc_start(struct rcar_du_crtc *rcrtc)\r\n{\r\nstruct drm_crtc *crtc = &rcrtc->crtc;\r\nunsigned int i;\r\nif (rcrtc->started)\r\nreturn;\r\nif (WARN_ON(rcrtc->plane->format == NULL))\r\nreturn;\r\nrcar_du_crtc_write(rcrtc, DOOR, DOOR_RGB(0, 0, 0));\r\nrcar_du_crtc_write(rcrtc, BPOR, BPOR_RGB(0, 0, 0));\r\nrcar_du_crtc_set_display_timing(rcrtc);\r\nrcar_du_group_set_routing(rcrtc->group);\r\nmutex_lock(&rcrtc->group->planes.lock);\r\nrcrtc->plane->enabled = true;\r\nrcar_du_crtc_update_planes(crtc);\r\nmutex_unlock(&rcrtc->group->planes.lock);\r\nfor (i = 0; i < ARRAY_SIZE(rcrtc->group->planes.planes); ++i) {\r\nstruct rcar_du_plane *plane = &rcrtc->group->planes.planes[i];\r\nif (plane->crtc != crtc || !plane->enabled)\r\ncontinue;\r\nrcar_du_plane_setup(plane);\r\n}\r\nrcar_du_crtc_clr_set(rcrtc, DSYSR, DSYSR_TVM_MASK, DSYSR_TVM_MASTER);\r\nrcar_du_group_start_stop(rcrtc->group, true);\r\nrcrtc->started = true;\r\n}\r\nstatic void rcar_du_crtc_stop(struct rcar_du_crtc *rcrtc)\r\n{\r\nstruct drm_crtc *crtc = &rcrtc->crtc;\r\nif (!rcrtc->started)\r\nreturn;\r\nmutex_lock(&rcrtc->group->planes.lock);\r\nrcrtc->plane->enabled = false;\r\nrcar_du_crtc_update_planes(crtc);\r\nmutex_unlock(&rcrtc->group->planes.lock);\r\nrcar_du_crtc_clr_set(rcrtc, DSYSR, DSYSR_TVM_MASK, DSYSR_TVM_SWITCH);\r\nrcar_du_group_start_stop(rcrtc->group, false);\r\nrcrtc->started = false;\r\n}\r\nvoid rcar_du_crtc_suspend(struct rcar_du_crtc *rcrtc)\r\n{\r\nrcar_du_crtc_stop(rcrtc);\r\nrcar_du_crtc_put(rcrtc);\r\n}\r\nvoid rcar_du_crtc_resume(struct rcar_du_crtc *rcrtc)\r\n{\r\nif (rcrtc->dpms != DRM_MODE_DPMS_ON)\r\nreturn;\r\nrcar_du_crtc_get(rcrtc);\r\nrcar_du_crtc_start(rcrtc);\r\n}\r\nstatic void rcar_du_crtc_update_base(struct rcar_du_crtc *rcrtc)\r\n{\r\nstruct drm_crtc *crtc = &rcrtc->crtc;\r\nrcar_du_plane_compute_base(rcrtc->plane, crtc->fb);\r\nrcar_du_plane_update_base(rcrtc->plane);\r\n}\r\nstatic void rcar_du_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\r\nif (rcrtc->dpms == mode)\r\nreturn;\r\nif (mode == DRM_MODE_DPMS_ON) {\r\nrcar_du_crtc_get(rcrtc);\r\nrcar_du_crtc_start(rcrtc);\r\n} else {\r\nrcar_du_crtc_stop(rcrtc);\r\nrcar_du_crtc_put(rcrtc);\r\n}\r\nrcrtc->dpms = mode;\r\n}\r\nstatic bool rcar_du_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void rcar_du_crtc_mode_prepare(struct drm_crtc *crtc)\r\n{\r\nstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\r\nrcar_du_crtc_get(rcrtc);\r\nrcar_du_crtc_stop(rcrtc);\r\nrcar_du_plane_release(rcrtc->plane);\r\nrcrtc->dpms = DRM_MODE_DPMS_OFF;\r\n}\r\nstatic int rcar_du_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\r\nstruct rcar_du_device *rcdu = rcrtc->group->dev;\r\nconst struct rcar_du_format_info *format;\r\nint ret;\r\nformat = rcar_du_format_info(crtc->fb->pixel_format);\r\nif (format == NULL) {\r\ndev_dbg(rcdu->dev, "mode_set: unsupported format %08x\n",\r\ncrtc->fb->pixel_format);\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nret = rcar_du_plane_reserve(rcrtc->plane, format);\r\nif (ret < 0)\r\ngoto error;\r\nrcrtc->plane->format = format;\r\nrcrtc->plane->pitch = crtc->fb->pitches[0];\r\nrcrtc->plane->src_x = x;\r\nrcrtc->plane->src_y = y;\r\nrcrtc->plane->width = mode->hdisplay;\r\nrcrtc->plane->height = mode->vdisplay;\r\nrcar_du_plane_compute_base(rcrtc->plane, crtc->fb);\r\nrcrtc->outputs = 0;\r\nreturn 0;\r\nerror:\r\nrcar_du_crtc_put(rcrtc);\r\nreturn ret;\r\n}\r\nstatic void rcar_du_crtc_mode_commit(struct drm_crtc *crtc)\r\n{\r\nstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\r\nrcar_du_crtc_start(rcrtc);\r\nrcrtc->dpms = DRM_MODE_DPMS_ON;\r\n}\r\nstatic int rcar_du_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\r\nrcrtc->plane->src_x = x;\r\nrcrtc->plane->src_y = y;\r\nrcar_du_crtc_update_base(to_rcar_crtc(crtc));\r\nreturn 0;\r\n}\r\nstatic void rcar_du_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\r\nrcar_du_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);\r\nrcar_du_plane_release(rcrtc->plane);\r\n}\r\nvoid rcar_du_crtc_cancel_page_flip(struct rcar_du_crtc *rcrtc,\r\nstruct drm_file *file)\r\n{\r\nstruct drm_pending_vblank_event *event;\r\nstruct drm_device *dev = rcrtc->crtc.dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nevent = rcrtc->event;\r\nif (event && event->base.file_priv == file) {\r\nrcrtc->event = NULL;\r\nevent->base.destroy(&event->base);\r\ndrm_vblank_put(dev, rcrtc->index);\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nstatic void rcar_du_crtc_finish_page_flip(struct rcar_du_crtc *rcrtc)\r\n{\r\nstruct drm_pending_vblank_event *event;\r\nstruct drm_device *dev = rcrtc->crtc.dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nevent = rcrtc->event;\r\nrcrtc->event = NULL;\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nif (event == NULL)\r\nreturn;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\ndrm_send_vblank_event(dev, rcrtc->index, event);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\ndrm_vblank_put(dev, rcrtc->index);\r\n}\r\nstatic irqreturn_t rcar_du_crtc_irq(int irq, void *arg)\r\n{\r\nstruct rcar_du_crtc *rcrtc = arg;\r\nirqreturn_t ret = IRQ_NONE;\r\nu32 status;\r\nstatus = rcar_du_crtc_read(rcrtc, DSSR);\r\nrcar_du_crtc_write(rcrtc, DSRCR, status & DSRCR_MASK);\r\nif (status & DSSR_VBK) {\r\ndrm_handle_vblank(rcrtc->crtc.dev, rcrtc->index);\r\nrcar_du_crtc_finish_page_flip(rcrtc);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rcar_du_crtc_page_flip(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nstruct drm_pending_vblank_event *event,\r\nuint32_t page_flip_flags)\r\n{\r\nstruct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);\r\nstruct drm_device *dev = rcrtc->crtc.dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nif (rcrtc->event != NULL) {\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nreturn -EBUSY;\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\ncrtc->fb = fb;\r\nrcar_du_crtc_update_base(rcrtc);\r\nif (event) {\r\nevent->pipe = rcrtc->index;\r\ndrm_vblank_get(dev, rcrtc->index);\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nrcrtc->event = event;\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nint rcar_du_crtc_create(struct rcar_du_group *rgrp, unsigned int index)\r\n{\r\nstatic const unsigned int mmio_offsets[] = {\r\nDU0_REG_OFFSET, DU1_REG_OFFSET, DU2_REG_OFFSET\r\n};\r\nstruct rcar_du_device *rcdu = rgrp->dev;\r\nstruct platform_device *pdev = to_platform_device(rcdu->dev);\r\nstruct rcar_du_crtc *rcrtc = &rcdu->crtcs[index];\r\nstruct drm_crtc *crtc = &rcrtc->crtc;\r\nunsigned int irqflags;\r\nchar clk_name[5];\r\nchar *name;\r\nint irq;\r\nint ret;\r\nif (rcar_du_has(rcdu, RCAR_DU_FEATURE_CRTC_IRQ_CLOCK)) {\r\nsprintf(clk_name, "du.%u", index);\r\nname = clk_name;\r\n} else {\r\nname = NULL;\r\n}\r\nrcrtc->clock = devm_clk_get(rcdu->dev, name);\r\nif (IS_ERR(rcrtc->clock)) {\r\ndev_err(rcdu->dev, "no clock for CRTC %u\n", index);\r\nreturn PTR_ERR(rcrtc->clock);\r\n}\r\nrcrtc->group = rgrp;\r\nrcrtc->mmio_offset = mmio_offsets[index];\r\nrcrtc->index = index;\r\nrcrtc->dpms = DRM_MODE_DPMS_OFF;\r\nrcrtc->plane = &rgrp->planes.planes[index % 2];\r\nrcrtc->plane->crtc = crtc;\r\nret = drm_crtc_init(rcdu->ddev, crtc, &crtc_funcs);\r\nif (ret < 0)\r\nreturn ret;\r\ndrm_crtc_helper_add(crtc, &crtc_helper_funcs);\r\nif (rcar_du_has(rcdu, RCAR_DU_FEATURE_CRTC_IRQ_CLOCK)) {\r\nirq = platform_get_irq(pdev, index);\r\nirqflags = 0;\r\n} else {\r\nirq = platform_get_irq(pdev, 0);\r\nirqflags = IRQF_SHARED;\r\n}\r\nif (irq < 0) {\r\ndev_err(rcdu->dev, "no IRQ for CRTC %u\n", index);\r\nreturn ret;\r\n}\r\nret = devm_request_irq(rcdu->dev, irq, rcar_du_crtc_irq, irqflags,\r\ndev_name(rcdu->dev), rcrtc);\r\nif (ret < 0) {\r\ndev_err(rcdu->dev,\r\n"failed to register IRQ for CRTC %u\n", index);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid rcar_du_crtc_enable_vblank(struct rcar_du_crtc *rcrtc, bool enable)\r\n{\r\nif (enable) {\r\nrcar_du_crtc_write(rcrtc, DSRCR, DSRCR_VBCL);\r\nrcar_du_crtc_set(rcrtc, DIER, DIER_VBE);\r\n} else {\r\nrcar_du_crtc_clr(rcrtc, DIER, DIER_VBE);\r\n}\r\n}
