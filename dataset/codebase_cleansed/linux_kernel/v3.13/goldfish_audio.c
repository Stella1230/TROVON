static ssize_t goldfish_audio_read(struct file *fp, char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct goldfish_audio *data = fp->private_data;\r\nint length;\r\nint result = 0;\r\nif (!data->read_supported)\r\nreturn -ENODEV;\r\nwhile (count > 0) {\r\nlength = (count > READ_BUFFER_SIZE ? READ_BUFFER_SIZE : count);\r\nAUDIO_WRITE(data, AUDIO_START_READ, length);\r\nwait_event_interruptible(data->wait,\r\n(data->buffer_status & AUDIO_INT_READ_BUFFER_FULL));\r\nlength = AUDIO_READ(data,\r\nAUDIO_READ_BUFFER_AVAILABLE);\r\nif (copy_to_user(buf, data->read_buffer, length))\r\nreturn -EFAULT;\r\nresult += length;\r\nbuf += length;\r\ncount -= length;\r\n}\r\nreturn result;\r\n}\r\nstatic ssize_t goldfish_audio_write(struct file *fp, const char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct goldfish_audio *data = fp->private_data;\r\nunsigned long irq_flags;\r\nssize_t result = 0;\r\nchar __iomem *kbuf;\r\nwhile (count > 0) {\r\nssize_t copy = count;\r\nif (copy > WRITE_BUFFER_SIZE)\r\ncopy = WRITE_BUFFER_SIZE;\r\nwait_event_interruptible(data->wait, (data->buffer_status &\r\n(AUDIO_INT_WRITE_BUFFER_1_EMPTY |\r\nAUDIO_INT_WRITE_BUFFER_2_EMPTY)));\r\nif ((data->buffer_status & AUDIO_INT_WRITE_BUFFER_1_EMPTY) != 0)\r\nkbuf = data->write_buffer1;\r\nelse\r\nkbuf = data->write_buffer2;\r\nif (copy_from_user(kbuf, buf, copy)) {\r\nresult = -EFAULT;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&data->lock, irq_flags);\r\nif (kbuf == data->write_buffer1) {\r\ndata->buffer_status &= ~AUDIO_INT_WRITE_BUFFER_1_EMPTY;\r\nAUDIO_WRITE(data, AUDIO_WRITE_BUFFER_1, copy);\r\n} else {\r\ndata->buffer_status &= ~AUDIO_INT_WRITE_BUFFER_2_EMPTY;\r\nAUDIO_WRITE(data, AUDIO_WRITE_BUFFER_2, copy);\r\n}\r\nspin_unlock_irqrestore(&data->lock, irq_flags);\r\nbuf += copy;\r\nresult += copy;\r\ncount -= copy;\r\n}\r\nreturn result;\r\n}\r\nstatic int goldfish_audio_open(struct inode *ip, struct file *fp)\r\n{\r\nif (!audio_data)\r\nreturn -ENODEV;\r\nif (atomic_inc_return(&open_count) == 1) {\r\nfp->private_data = audio_data;\r\naudio_data->buffer_status = (AUDIO_INT_WRITE_BUFFER_1_EMPTY |\r\nAUDIO_INT_WRITE_BUFFER_2_EMPTY);\r\nAUDIO_WRITE(audio_data, AUDIO_INT_ENABLE, AUDIO_INT_MASK);\r\nreturn 0;\r\n} else {\r\natomic_dec(&open_count);\r\nreturn -EBUSY;\r\n}\r\n}\r\nstatic int goldfish_audio_release(struct inode *ip, struct file *fp)\r\n{\r\natomic_dec(&open_count);\r\nAUDIO_WRITE(audio_data, AUDIO_INT_ENABLE, 0);\r\nreturn 0;\r\n}\r\nstatic long goldfish_audio_ioctl(struct file *fp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nif (cmd == 315)\r\nreturn -1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic irqreturn_t goldfish_audio_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned long irq_flags;\r\nstruct goldfish_audio *data = dev_id;\r\nu32 status;\r\nspin_lock_irqsave(&data->lock, irq_flags);\r\nstatus = AUDIO_READ(data, AUDIO_INT_STATUS);\r\nstatus &= AUDIO_INT_MASK;\r\nif (status) {\r\ndata->buffer_status = status;\r\nwake_up(&data->wait);\r\n}\r\nspin_unlock_irqrestore(&data->lock, irq_flags);\r\nreturn status ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int goldfish_audio_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct resource *r;\r\nstruct goldfish_audio *data;\r\ndma_addr_t buf_addr;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (data == NULL) {\r\nret = -ENOMEM;\r\ngoto err_data_alloc_failed;\r\n}\r\nspin_lock_init(&data->lock);\r\ninit_waitqueue_head(&data->wait);\r\nplatform_set_drvdata(pdev, data);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (r == NULL) {\r\ndev_err(&pdev->dev, "platform_get_resource failed\n");\r\nret = -ENODEV;\r\ngoto err_no_io_base;\r\n}\r\ndata->reg_base = ioremap(r->start, PAGE_SIZE);\r\nif (data->reg_base == NULL) {\r\nret = -ENOMEM;\r\ngoto err_no_io_base;\r\n}\r\ndata->irq = platform_get_irq(pdev, 0);\r\nif (data->irq < 0) {\r\ndev_err(&pdev->dev, "platform_get_irq failed\n");\r\nret = -ENODEV;\r\ngoto err_no_irq;\r\n}\r\ndata->buffer_virt = dma_alloc_coherent(&pdev->dev,\r\nCOMBINED_BUFFER_SIZE, &buf_addr, GFP_KERNEL);\r\nif (data->buffer_virt == 0) {\r\nret = -ENOMEM;\r\ndev_err(&pdev->dev, "allocate buffer failed\n");\r\ngoto err_alloc_write_buffer_failed;\r\n}\r\ndata->buffer_phys = buf_addr;\r\ndata->write_buffer1 = data->buffer_virt;\r\ndata->write_buffer2 = data->buffer_virt + WRITE_BUFFER_SIZE;\r\ndata->read_buffer = data->buffer_virt + 2 * WRITE_BUFFER_SIZE;\r\nret = request_irq(data->irq, goldfish_audio_interrupt,\r\nIRQF_SHARED, pdev->name, data);\r\nif (ret) {\r\ndev_err(&pdev->dev, "request_irq failed\n");\r\ngoto err_request_irq_failed;\r\n}\r\nret = misc_register(&goldfish_audio_device);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"misc_register returned %d in goldfish_audio_init\n",\r\nret);\r\ngoto err_misc_register_failed;\r\n}\r\nAUDIO_WRITE(data, AUDIO_SET_WRITE_BUFFER_1, buf_addr);\r\nAUDIO_WRITE(data, AUDIO_SET_WRITE_BUFFER_2,\r\nbuf_addr + WRITE_BUFFER_SIZE);\r\ndata->read_supported = AUDIO_READ(data, AUDIO_READ_SUPPORTED);\r\nif (data->read_supported)\r\nAUDIO_WRITE(data, AUDIO_SET_READ_BUFFER,\r\nbuf_addr + 2 * WRITE_BUFFER_SIZE);\r\naudio_data = data;\r\nreturn 0;\r\nerr_misc_register_failed:\r\nerr_request_irq_failed:\r\ndma_free_coherent(&pdev->dev, COMBINED_BUFFER_SIZE,\r\ndata->buffer_virt, data->buffer_phys);\r\nerr_alloc_write_buffer_failed:\r\nerr_no_irq:\r\niounmap(data->reg_base);\r\nerr_no_io_base:\r\nkfree(data);\r\nerr_data_alloc_failed:\r\nreturn ret;\r\n}\r\nstatic int goldfish_audio_remove(struct platform_device *pdev)\r\n{\r\nstruct goldfish_audio *data = platform_get_drvdata(pdev);\r\nmisc_deregister(&goldfish_audio_device);\r\nfree_irq(data->irq, data);\r\ndma_free_coherent(&pdev->dev, COMBINED_BUFFER_SIZE,\r\ndata->buffer_virt, data->buffer_phys);\r\niounmap(data->reg_base);\r\nkfree(data);\r\naudio_data = NULL;\r\nreturn 0;\r\n}
