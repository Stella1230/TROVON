static inline void rb_set_black(struct rb_node *rb)\r\n{\r\nrb->__rb_parent_color |= RB_BLACK;\r\n}\r\nstatic inline struct rb_node *rb_red_parent(struct rb_node *red)\r\n{\r\nreturn (struct rb_node *)red->__rb_parent_color;\r\n}\r\nstatic inline void\r\n__rb_rotate_set_parents(struct rb_node *old, struct rb_node *new,\r\nstruct rb_root *root, int color)\r\n{\r\nstruct rb_node *parent = rb_parent(old);\r\nnew->__rb_parent_color = old->__rb_parent_color;\r\nrb_set_parent_color(old, new, color);\r\n__rb_change_child(old, new, parent, root);\r\n}\r\nstatic __always_inline void\r\n__rb_insert(struct rb_node *node, struct rb_root *root,\r\nvoid (*augment_rotate)(struct rb_node *old, struct rb_node *new))\r\n{\r\nstruct rb_node *parent = rb_red_parent(node), *gparent, *tmp;\r\nwhile (true) {\r\nif (!parent) {\r\nrb_set_parent_color(node, NULL, RB_BLACK);\r\nbreak;\r\n} else if (rb_is_black(parent))\r\nbreak;\r\ngparent = rb_red_parent(parent);\r\ntmp = gparent->rb_right;\r\nif (parent != tmp) {\r\nif (tmp && rb_is_red(tmp)) {\r\nrb_set_parent_color(tmp, gparent, RB_BLACK);\r\nrb_set_parent_color(parent, gparent, RB_BLACK);\r\nnode = gparent;\r\nparent = rb_parent(node);\r\nrb_set_parent_color(node, parent, RB_RED);\r\ncontinue;\r\n}\r\ntmp = parent->rb_right;\r\nif (node == tmp) {\r\nparent->rb_right = tmp = node->rb_left;\r\nnode->rb_left = parent;\r\nif (tmp)\r\nrb_set_parent_color(tmp, parent,\r\nRB_BLACK);\r\nrb_set_parent_color(parent, node, RB_RED);\r\naugment_rotate(parent, node);\r\nparent = node;\r\ntmp = node->rb_right;\r\n}\r\ngparent->rb_left = tmp;\r\nparent->rb_right = gparent;\r\nif (tmp)\r\nrb_set_parent_color(tmp, gparent, RB_BLACK);\r\n__rb_rotate_set_parents(gparent, parent, root, RB_RED);\r\naugment_rotate(gparent, parent);\r\nbreak;\r\n} else {\r\ntmp = gparent->rb_left;\r\nif (tmp && rb_is_red(tmp)) {\r\nrb_set_parent_color(tmp, gparent, RB_BLACK);\r\nrb_set_parent_color(parent, gparent, RB_BLACK);\r\nnode = gparent;\r\nparent = rb_parent(node);\r\nrb_set_parent_color(node, parent, RB_RED);\r\ncontinue;\r\n}\r\ntmp = parent->rb_left;\r\nif (node == tmp) {\r\nparent->rb_left = tmp = node->rb_right;\r\nnode->rb_right = parent;\r\nif (tmp)\r\nrb_set_parent_color(tmp, parent,\r\nRB_BLACK);\r\nrb_set_parent_color(parent, node, RB_RED);\r\naugment_rotate(parent, node);\r\nparent = node;\r\ntmp = node->rb_left;\r\n}\r\ngparent->rb_right = tmp;\r\nparent->rb_left = gparent;\r\nif (tmp)\r\nrb_set_parent_color(tmp, gparent, RB_BLACK);\r\n__rb_rotate_set_parents(gparent, parent, root, RB_RED);\r\naugment_rotate(gparent, parent);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic __always_inline void\r\n____rb_erase_color(struct rb_node *parent, struct rb_root *root,\r\nvoid (*augment_rotate)(struct rb_node *old, struct rb_node *new))\r\n{\r\nstruct rb_node *node = NULL, *sibling, *tmp1, *tmp2;\r\nwhile (true) {\r\nsibling = parent->rb_right;\r\nif (node != sibling) {\r\nif (rb_is_red(sibling)) {\r\nparent->rb_right = tmp1 = sibling->rb_left;\r\nsibling->rb_left = parent;\r\nrb_set_parent_color(tmp1, parent, RB_BLACK);\r\n__rb_rotate_set_parents(parent, sibling, root,\r\nRB_RED);\r\naugment_rotate(parent, sibling);\r\nsibling = tmp1;\r\n}\r\ntmp1 = sibling->rb_right;\r\nif (!tmp1 || rb_is_black(tmp1)) {\r\ntmp2 = sibling->rb_left;\r\nif (!tmp2 || rb_is_black(tmp2)) {\r\nrb_set_parent_color(sibling, parent,\r\nRB_RED);\r\nif (rb_is_red(parent))\r\nrb_set_black(parent);\r\nelse {\r\nnode = parent;\r\nparent = rb_parent(node);\r\nif (parent)\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nsibling->rb_left = tmp1 = tmp2->rb_right;\r\ntmp2->rb_right = sibling;\r\nparent->rb_right = tmp2;\r\nif (tmp1)\r\nrb_set_parent_color(tmp1, sibling,\r\nRB_BLACK);\r\naugment_rotate(sibling, tmp2);\r\ntmp1 = sibling;\r\nsibling = tmp2;\r\n}\r\nparent->rb_right = tmp2 = sibling->rb_left;\r\nsibling->rb_left = parent;\r\nrb_set_parent_color(tmp1, sibling, RB_BLACK);\r\nif (tmp2)\r\nrb_set_parent(tmp2, parent);\r\n__rb_rotate_set_parents(parent, sibling, root,\r\nRB_BLACK);\r\naugment_rotate(parent, sibling);\r\nbreak;\r\n} else {\r\nsibling = parent->rb_left;\r\nif (rb_is_red(sibling)) {\r\nparent->rb_left = tmp1 = sibling->rb_right;\r\nsibling->rb_right = parent;\r\nrb_set_parent_color(tmp1, parent, RB_BLACK);\r\n__rb_rotate_set_parents(parent, sibling, root,\r\nRB_RED);\r\naugment_rotate(parent, sibling);\r\nsibling = tmp1;\r\n}\r\ntmp1 = sibling->rb_left;\r\nif (!tmp1 || rb_is_black(tmp1)) {\r\ntmp2 = sibling->rb_right;\r\nif (!tmp2 || rb_is_black(tmp2)) {\r\nrb_set_parent_color(sibling, parent,\r\nRB_RED);\r\nif (rb_is_red(parent))\r\nrb_set_black(parent);\r\nelse {\r\nnode = parent;\r\nparent = rb_parent(node);\r\nif (parent)\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nsibling->rb_right = tmp1 = tmp2->rb_left;\r\ntmp2->rb_left = sibling;\r\nparent->rb_left = tmp2;\r\nif (tmp1)\r\nrb_set_parent_color(tmp1, sibling,\r\nRB_BLACK);\r\naugment_rotate(sibling, tmp2);\r\ntmp1 = sibling;\r\nsibling = tmp2;\r\n}\r\nparent->rb_left = tmp2 = sibling->rb_right;\r\nsibling->rb_right = parent;\r\nrb_set_parent_color(tmp1, sibling, RB_BLACK);\r\nif (tmp2)\r\nrb_set_parent(tmp2, parent);\r\n__rb_rotate_set_parents(parent, sibling, root,\r\nRB_BLACK);\r\naugment_rotate(parent, sibling);\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid __rb_erase_color(struct rb_node *parent, struct rb_root *root,\r\nvoid (*augment_rotate)(struct rb_node *old, struct rb_node *new))\r\n{\r\n____rb_erase_color(parent, root, augment_rotate);\r\n}\r\nstatic inline void dummy_propagate(struct rb_node *node, struct rb_node *stop) {}\r\nstatic inline void dummy_copy(struct rb_node *old, struct rb_node *new) {}\r\nstatic inline void dummy_rotate(struct rb_node *old, struct rb_node *new) {}\r\nvoid rb_insert_color(struct rb_node *node, struct rb_root *root)\r\n{\r\n__rb_insert(node, root, dummy_rotate);\r\n}\r\nvoid rb_erase(struct rb_node *node, struct rb_root *root)\r\n{\r\nstruct rb_node *rebalance;\r\nrebalance = __rb_erase_augmented(node, root, &dummy_callbacks);\r\nif (rebalance)\r\n____rb_erase_color(rebalance, root, dummy_rotate);\r\n}\r\nvoid __rb_insert_augmented(struct rb_node *node, struct rb_root *root,\r\nvoid (*augment_rotate)(struct rb_node *old, struct rb_node *new))\r\n{\r\n__rb_insert(node, root, augment_rotate);\r\n}\r\nstruct rb_node *rb_first(const struct rb_root *root)\r\n{\r\nstruct rb_node *n;\r\nn = root->rb_node;\r\nif (!n)\r\nreturn NULL;\r\nwhile (n->rb_left)\r\nn = n->rb_left;\r\nreturn n;\r\n}\r\nstruct rb_node *rb_last(const struct rb_root *root)\r\n{\r\nstruct rb_node *n;\r\nn = root->rb_node;\r\nif (!n)\r\nreturn NULL;\r\nwhile (n->rb_right)\r\nn = n->rb_right;\r\nreturn n;\r\n}\r\nstruct rb_node *rb_next(const struct rb_node *node)\r\n{\r\nstruct rb_node *parent;\r\nif (RB_EMPTY_NODE(node))\r\nreturn NULL;\r\nif (node->rb_right) {\r\nnode = node->rb_right;\r\nwhile (node->rb_left)\r\nnode=node->rb_left;\r\nreturn (struct rb_node *)node;\r\n}\r\nwhile ((parent = rb_parent(node)) && node == parent->rb_right)\r\nnode = parent;\r\nreturn parent;\r\n}\r\nstruct rb_node *rb_prev(const struct rb_node *node)\r\n{\r\nstruct rb_node *parent;\r\nif (RB_EMPTY_NODE(node))\r\nreturn NULL;\r\nif (node->rb_left) {\r\nnode = node->rb_left;\r\nwhile (node->rb_right)\r\nnode=node->rb_right;\r\nreturn (struct rb_node *)node;\r\n}\r\nwhile ((parent = rb_parent(node)) && node == parent->rb_left)\r\nnode = parent;\r\nreturn parent;\r\n}\r\nvoid rb_replace_node(struct rb_node *victim, struct rb_node *new,\r\nstruct rb_root *root)\r\n{\r\nstruct rb_node *parent = rb_parent(victim);\r\n__rb_change_child(victim, new, parent, root);\r\nif (victim->rb_left)\r\nrb_set_parent(victim->rb_left, new);\r\nif (victim->rb_right)\r\nrb_set_parent(victim->rb_right, new);\r\n*new = *victim;\r\n}\r\nstatic struct rb_node *rb_left_deepest_node(const struct rb_node *node)\r\n{\r\nfor (;;) {\r\nif (node->rb_left)\r\nnode = node->rb_left;\r\nelse if (node->rb_right)\r\nnode = node->rb_right;\r\nelse\r\nreturn (struct rb_node *)node;\r\n}\r\n}\r\nstruct rb_node *rb_next_postorder(const struct rb_node *node)\r\n{\r\nconst struct rb_node *parent;\r\nif (!node)\r\nreturn NULL;\r\nparent = rb_parent(node);\r\nif (parent && node == parent->rb_left && parent->rb_right) {\r\nreturn rb_left_deepest_node(parent->rb_right);\r\n} else\r\nreturn (struct rb_node *)parent;\r\n}\r\nstruct rb_node *rb_first_postorder(const struct rb_root *root)\r\n{\r\nif (!root->rb_node)\r\nreturn NULL;\r\nreturn rb_left_deepest_node(root->rb_node);\r\n}
