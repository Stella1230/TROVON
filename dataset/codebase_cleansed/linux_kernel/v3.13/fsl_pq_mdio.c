static int fsl_pq_mdio_write(struct mii_bus *bus, int mii_id, int regnum,\r\nu16 value)\r\n{\r\nstruct fsl_pq_mdio_priv *priv = bus->priv;\r\nstruct fsl_pq_mii __iomem *regs = priv->regs;\r\nu32 status;\r\nout_be32(&regs->miimadd, (mii_id << 8) | regnum);\r\nout_be32(&regs->miimcon, value);\r\nstatus = spin_event_timeout(!(in_be32(&regs->miimind) & MIIMIND_BUSY),\r\nMII_TIMEOUT, 0);\r\nreturn status ? 0 : -ETIMEDOUT;\r\n}\r\nstatic int fsl_pq_mdio_read(struct mii_bus *bus, int mii_id, int regnum)\r\n{\r\nstruct fsl_pq_mdio_priv *priv = bus->priv;\r\nstruct fsl_pq_mii __iomem *regs = priv->regs;\r\nu32 status;\r\nu16 value;\r\nout_be32(&regs->miimadd, (mii_id << 8) | regnum);\r\nout_be32(&regs->miimcom, 0);\r\nout_be32(&regs->miimcom, MII_READ_COMMAND);\r\nstatus = spin_event_timeout(!(in_be32(&regs->miimind) &\r\n(MIIMIND_NOTVALID | MIIMIND_BUSY)),\r\nMII_TIMEOUT, 0);\r\nif (!status)\r\nreturn -ETIMEDOUT;\r\nvalue = in_be32(&regs->miimstat);\r\ndev_dbg(&bus->dev, "read %04x from address %x/%x\n", value, mii_id, regnum);\r\nreturn value;\r\n}\r\nstatic int fsl_pq_mdio_reset(struct mii_bus *bus)\r\n{\r\nstruct fsl_pq_mdio_priv *priv = bus->priv;\r\nstruct fsl_pq_mii __iomem *regs = priv->regs;\r\nu32 status;\r\nmutex_lock(&bus->mdio_lock);\r\nout_be32(&regs->miimcfg, MIIMCFG_RESET);\r\nout_be32(&regs->miimcfg, MIIMCFG_INIT_VALUE);\r\nstatus = spin_event_timeout(!(in_be32(&regs->miimind) & MIIMIND_BUSY),\r\nMII_TIMEOUT, 0);\r\nmutex_unlock(&bus->mdio_lock);\r\nif (!status) {\r\ndev_err(&bus->dev, "timeout waiting for MII bus\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic uint32_t __iomem *get_gfar_tbipa(void __iomem *p)\r\n{\r\nstruct gfar __iomem *enet_regs = p;\r\nreturn &enet_regs->tbipa;\r\n}\r\nstatic uint32_t __iomem *get_etsec_tbipa(void __iomem *p)\r\n{\r\nreturn p;\r\n}\r\nstatic uint32_t __iomem *get_ucc_tbipa(void __iomem *p)\r\n{\r\nstruct fsl_pq_mdio __iomem *mdio = p;\r\nreturn &mdio->utbipar;\r\n}\r\nstatic void ucc_configure(phys_addr_t start, phys_addr_t end)\r\n{\r\nstatic bool found_mii_master;\r\nstruct device_node *np = NULL;\r\nif (found_mii_master)\r\nreturn;\r\nfor_each_compatible_node(np, NULL, "ucc_geth") {\r\nstruct resource res;\r\nconst uint32_t *iprop;\r\nuint32_t id;\r\nint ret;\r\nret = of_address_to_resource(np, 0, &res);\r\nif (ret < 0) {\r\npr_debug("fsl-pq-mdio: no address range in node %s\n",\r\nnp->full_name);\r\ncontinue;\r\n}\r\nif ((start < res.start) || (end > res.end))\r\ncontinue;\r\niprop = of_get_property(np, "cell-index", NULL);\r\nif (!iprop) {\r\niprop = of_get_property(np, "device-id", NULL);\r\nif (!iprop) {\r\npr_debug("fsl-pq-mdio: no UCC ID in node %s\n",\r\nnp->full_name);\r\ncontinue;\r\n}\r\n}\r\nid = be32_to_cpup(iprop);\r\nif (ucc_set_qe_mux_mii_mng(id - 1) < 0) {\r\npr_debug("fsl-pq-mdio: invalid UCC ID in node %s\n",\r\nnp->full_name);\r\ncontinue;\r\n}\r\npr_debug("fsl-pq-mdio: setting node UCC%u to MII master\n", id);\r\nfound_mii_master = true;\r\n}\r\n}\r\nstatic int fsl_pq_mdio_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *id =\r\nof_match_device(fsl_pq_mdio_match, &pdev->dev);\r\nconst struct fsl_pq_mdio_data *data = id->data;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct resource res;\r\nstruct device_node *tbi;\r\nstruct fsl_pq_mdio_priv *priv;\r\nstruct mii_bus *new_bus;\r\nint err;\r\ndev_dbg(&pdev->dev, "found %s compatible node\n", id->compatible);\r\nnew_bus = mdiobus_alloc_size(sizeof(*priv));\r\nif (!new_bus)\r\nreturn -ENOMEM;\r\npriv = new_bus->priv;\r\nnew_bus->name = "Freescale PowerQUICC MII Bus",\r\nnew_bus->read = &fsl_pq_mdio_read;\r\nnew_bus->write = &fsl_pq_mdio_write;\r\nnew_bus->reset = &fsl_pq_mdio_reset;\r\nnew_bus->irq = priv->irqs;\r\nerr = of_address_to_resource(np, 0, &res);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "could not obtain address information\n");\r\ngoto error;\r\n}\r\nsnprintf(new_bus->id, MII_BUS_ID_SIZE, "%s@%llx", np->name,\r\n(unsigned long long)res.start);\r\npriv->map = of_iomap(np, 0);\r\nif (!priv->map) {\r\nerr = -ENOMEM;\r\ngoto error;\r\n}\r\nif (data->mii_offset > resource_size(&res)) {\r\ndev_err(&pdev->dev, "invalid register map\n");\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\npriv->regs = priv->map + data->mii_offset;\r\nnew_bus->parent = &pdev->dev;\r\nplatform_set_drvdata(pdev, new_bus);\r\nif (data->get_tbipa) {\r\nfor_each_child_of_node(np, tbi) {\r\nif (strcmp(tbi->type, "tbi-phy") == 0) {\r\ndev_dbg(&pdev->dev, "found TBI PHY node %s\n",\r\nstrrchr(tbi->full_name, '/') + 1);\r\nbreak;\r\n}\r\n}\r\nif (tbi) {\r\nconst u32 *prop = of_get_property(tbi, "reg", NULL);\r\nuint32_t __iomem *tbipa;\r\nif (!prop) {\r\ndev_err(&pdev->dev,\r\n"missing 'reg' property in node %s\n",\r\ntbi->full_name);\r\nerr = -EBUSY;\r\ngoto error;\r\n}\r\ntbipa = data->get_tbipa(priv->map);\r\nout_be32(tbipa, be32_to_cpup(prop));\r\n}\r\n}\r\nif (data->ucc_configure)\r\ndata->ucc_configure(res.start, res.end);\r\nerr = of_mdiobus_register(new_bus, np);\r\nif (err) {\r\ndev_err(&pdev->dev, "cannot register %s as MDIO bus\n",\r\nnew_bus->name);\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nif (priv->map)\r\niounmap(priv->map);\r\nkfree(new_bus);\r\nreturn err;\r\n}\r\nstatic int fsl_pq_mdio_remove(struct platform_device *pdev)\r\n{\r\nstruct device *device = &pdev->dev;\r\nstruct mii_bus *bus = dev_get_drvdata(device);\r\nstruct fsl_pq_mdio_priv *priv = bus->priv;\r\nmdiobus_unregister(bus);\r\niounmap(priv->map);\r\nmdiobus_free(bus);\r\nreturn 0;\r\n}
