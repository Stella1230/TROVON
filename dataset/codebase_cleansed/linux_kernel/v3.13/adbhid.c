static void\r\nadbhid_keyboard_input(unsigned char *data, int nb, int apoll)\r\n{\r\nint id = (data[0] >> 4) & 0x0f;\r\nif (!adbhid[id]) {\r\nprintk(KERN_ERR "ADB HID on ID %d not yet registered, packet %#02x, %#02x, %#02x, %#02x\n",\r\nid, data[0], data[1], data[2], data[3]);\r\nreturn;\r\n}\r\nif (nb != 3 || (data[0] & 3) != KEYB_KEYREG)\r\nreturn;\r\nadbhid_input_keycode(id, data[1], 0);\r\nif (!(data[2] == 0xff || (data[2] == 0x7f && data[1] == 0x7f)))\r\nadbhid_input_keycode(id, data[2], 0);\r\n}\r\nstatic void\r\nadbhid_input_keycode(int id, int scancode, int repeat)\r\n{\r\nstruct adbhid *ahid = adbhid[id];\r\nint keycode, up_flag, key;\r\nkeycode = scancode & 0x7f;\r\nup_flag = scancode & 0x80;\r\nif (restore_capslock_events) {\r\nif (keycode == ADB_KEY_CAPSLOCK && !up_flag) {\r\nif (ahid->flags & FLAG_CAPSLOCK_IGNORE_NEXT) {\r\nahid->flags &= ~FLAG_CAPSLOCK_IGNORE_NEXT;\r\nreturn;\r\n} else {\r\nahid->flags |= FLAG_CAPSLOCK_TRANSLATE\r\n| FLAG_CAPSLOCK_DOWN;\r\n}\r\n} else if (scancode == 0xff &&\r\n!(ahid->flags & FLAG_POWER_KEY_PRESSED)) {\r\nif (ahid->flags & FLAG_CAPSLOCK_TRANSLATE) {\r\nkeycode = ADB_KEY_CAPSLOCK;\r\nif (ahid->flags & FLAG_CAPSLOCK_DOWN) {\r\nup_flag = 1;\r\nahid->flags &= ~FLAG_CAPSLOCK_DOWN;\r\n} else {\r\nup_flag = 0;\r\nahid->flags &= ~FLAG_CAPSLOCK_TRANSLATE;\r\n}\r\n} else {\r\nprintk(KERN_INFO "Spurious caps lock event "\r\n"(scancode 0xff).\n");\r\n}\r\n}\r\n}\r\nswitch (keycode) {\r\ncase ADB_KEY_CAPSLOCK:\r\nif (!restore_capslock_events) {\r\ninput_report_key(ahid->input, KEY_CAPSLOCK, 1);\r\ninput_sync(ahid->input);\r\ninput_report_key(ahid->input, KEY_CAPSLOCK, 0);\r\ninput_sync(ahid->input);\r\nreturn;\r\n}\r\nbreak;\r\n#ifdef CONFIG_PPC_PMAC\r\ncase ADB_KEY_POWER_OLD:\r\nswitch(pmac_call_feature(PMAC_FTR_GET_MB_INFO,\r\nNULL, PMAC_MB_INFO_MODEL, 0)) {\r\ncase PMAC_TYPE_COMET:\r\ncase PMAC_TYPE_HOOPER:\r\ncase PMAC_TYPE_KANGA:\r\nkeycode = ADB_KEY_POWER;\r\n}\r\nbreak;\r\ncase ADB_KEY_POWER:\r\nif (up_flag)\r\nahid->flags &= ~FLAG_POWER_KEY_PRESSED;\r\nelse\r\nahid->flags |= FLAG_POWER_KEY_PRESSED;\r\nif (ahid->flags & FLAG_FN_KEY_PRESSED) {\r\nkeycode = ADB_KEY_CMD;\r\nif (up_flag)\r\nahid->flags &= ~FLAG_POWER_FROM_FN;\r\nelse\r\nahid->flags |= FLAG_POWER_FROM_FN;\r\n} else if (ahid->flags & FLAG_POWER_FROM_FN) {\r\nkeycode = ADB_KEY_CMD;\r\nahid->flags &= ~FLAG_POWER_FROM_FN;\r\n}\r\nbreak;\r\ncase ADB_KEY_FN:\r\nif (up_flag) {\r\nahid->flags &= ~FLAG_FN_KEY_PRESSED;\r\nif (ahid->flags & FLAG_EMU_FWDEL_DOWN) {\r\nahid->flags &= ~FLAG_EMU_FWDEL_DOWN;\r\nkeycode = ADB_KEY_FWDEL;\r\nbreak;\r\n}\r\n} else\r\nahid->flags |= FLAG_FN_KEY_PRESSED;\r\nbreak;\r\ncase ADB_KEY_DEL:\r\nif (ahid->flags & FLAG_FN_KEY_PRESSED) {\r\nkeycode = ADB_KEY_FWDEL;\r\nif (up_flag)\r\nahid->flags &= ~FLAG_EMU_FWDEL_DOWN;\r\nelse\r\nahid->flags |= FLAG_EMU_FWDEL_DOWN;\r\n}\r\nbreak;\r\n#endif\r\n}\r\nkey = adbhid[id]->keycode[keycode];\r\nif (key) {\r\ninput_report_key(adbhid[id]->input, key, !up_flag);\r\ninput_sync(adbhid[id]->input);\r\n} else\r\nprintk(KERN_INFO "Unhandled ADB key (scancode %#02x) %s.\n", keycode,\r\nup_flag ? "released" : "pressed");\r\n}\r\nstatic void\r\nadbhid_mouse_input(unsigned char *data, int nb, int autopoll)\r\n{\r\nint id = (data[0] >> 4) & 0x0f;\r\nif (!adbhid[id]) {\r\nprintk(KERN_ERR "ADB HID on ID %d not yet registered\n", id);\r\nreturn;\r\n}\r\nswitch (adbhid[id]->mouse_kind)\r\n{\r\ncase ADBMOUSE_TRACKPAD:\r\ndata[1] = (data[1] & 0x7f) | ((data[1] & data[2]) & 0x80);\r\ndata[2] = data[2] | 0x80;\r\nbreak;\r\ncase ADBMOUSE_MICROSPEED:\r\ndata[1] = (data[1] & 0x7f) | ((data[3] & 0x01) << 7);\r\ndata[2] = (data[2] & 0x7f) | ((data[3] & 0x02) << 6);\r\ndata[3] = (data[3] & 0x77) | ((data[3] & 0x04) << 5)\r\n| (data[3] & 0x08);\r\nbreak;\r\ncase ADBMOUSE_TRACKBALLPRO:\r\ndata[1] = (data[1] & 0x7f) | (((data[3] & 0x04) << 5)\r\n& ((data[3] & 0x08) << 4));\r\ndata[2] = (data[2] & 0x7f) | ((data[3] & 0x01) << 7);\r\ndata[3] = (data[3] & 0x77) | ((data[3] & 0x02) << 6);\r\nbreak;\r\ncase ADBMOUSE_MS_A3:\r\ndata[1] = (data[1] & 0x7f) | ((data[3] & 0x01) << 7);\r\ndata[2] = (data[2] & 0x7f) | ((data[3] & 0x02) << 6);\r\ndata[3] = ((data[3] & 0x04) << 5);\r\nbreak;\r\ncase ADBMOUSE_MACALLY2:\r\ndata[3] = (data[2] & 0x80) ? 0x80 : 0x00;\r\ndata[2] |= 0x80;\r\nnb=4;\r\nbreak;\r\n}\r\ninput_report_key(adbhid[id]->input, BTN_LEFT, !((data[1] >> 7) & 1));\r\ninput_report_key(adbhid[id]->input, BTN_MIDDLE, !((data[2] >> 7) & 1));\r\nif (nb >= 4 && adbhid[id]->mouse_kind != ADBMOUSE_TRACKPAD)\r\ninput_report_key(adbhid[id]->input, BTN_RIGHT, !((data[3] >> 7) & 1));\r\ninput_report_rel(adbhid[id]->input, REL_X,\r\n((data[2]&0x7f) < 64 ? (data[2]&0x7f) : (data[2]&0x7f)-128 ));\r\ninput_report_rel(adbhid[id]->input, REL_Y,\r\n((data[1]&0x7f) < 64 ? (data[1]&0x7f) : (data[1]&0x7f)-128 ));\r\ninput_sync(adbhid[id]->input);\r\n}\r\nstatic void\r\nadbhid_buttons_input(unsigned char *data, int nb, int autopoll)\r\n{\r\nint id = (data[0] >> 4) & 0x0f;\r\nif (!adbhid[id]) {\r\nprintk(KERN_ERR "ADB HID on ID %d not yet registered\n", id);\r\nreturn;\r\n}\r\nswitch (adbhid[id]->original_handler_id) {\r\ndefault:\r\ncase 0x02:\r\n{\r\nint down = (data[1] == (data[1] & 0xf));\r\nswitch (data[1] & 0x0f) {\r\ncase 0x0:\r\ninput_report_key(adbhid[id]->input, KEY_SOUND, down);\r\nbreak;\r\ncase 0x1:\r\ninput_report_key(adbhid[id]->input, KEY_MUTE, down);\r\nbreak;\r\ncase 0x2:\r\ninput_report_key(adbhid[id]->input, KEY_VOLUMEDOWN, down);\r\nbreak;\r\ncase 0x3:\r\ninput_report_key(adbhid[id]->input, KEY_VOLUMEUP, down);\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "Unhandled ADB_MISC event %02x, %02x, %02x, %02x\n",\r\ndata[0], data[1], data[2], data[3]);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase 0x1f:\r\n{\r\nint down = (data[1] == (data[1] & 0xf));\r\nswitch (data[1] & 0x0f) {\r\ncase 0x8:\r\ninput_report_key(adbhid[id]->input, KEY_MUTE, down);\r\nbreak;\r\ncase 0x7:\r\ninput_report_key(adbhid[id]->input, KEY_VOLUMEDOWN, down);\r\nbreak;\r\ncase 0x6:\r\ninput_report_key(adbhid[id]->input, KEY_VOLUMEUP, down);\r\nbreak;\r\ncase 0xb:\r\ninput_report_key(adbhid[id]->input, KEY_EJECTCD, down);\r\nbreak;\r\ncase 0xa:\r\n#ifdef CONFIG_PMAC_BACKLIGHT\r\nif (down)\r\npmac_backlight_key_down();\r\n#endif\r\ninput_report_key(adbhid[id]->input, KEY_BRIGHTNESSDOWN, down);\r\nbreak;\r\ncase 0x9:\r\n#ifdef CONFIG_PMAC_BACKLIGHT\r\nif (down)\r\npmac_backlight_key_up();\r\n#endif\r\ninput_report_key(adbhid[id]->input, KEY_BRIGHTNESSUP, down);\r\nbreak;\r\ncase 0xc:\r\ninput_report_key(adbhid[id]->input, KEY_SWITCHVIDEOMODE, down);\r\nbreak;\r\ncase 0xd:\r\ninput_report_key(adbhid[id]->input, KEY_KBDILLUMTOGGLE, down);\r\nbreak;\r\ncase 0xe:\r\ninput_report_key(adbhid[id]->input, KEY_KBDILLUMDOWN, down);\r\nbreak;\r\ncase 0xf:\r\nswitch (data[1]) {\r\ncase 0x8f:\r\ncase 0x0f:\r\ninput_report_key(adbhid[id]->input, KEY_KBDILLUMUP, down);\r\nbreak;\r\ncase 0x7f:\r\ncase 0xff:\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "Unhandled ADB_MISC event %02x, %02x, %02x, %02x\n",\r\ndata[0], data[1], data[2], data[3]);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "Unhandled ADB_MISC event %02x, %02x, %02x, %02x\n",\r\ndata[0], data[1], data[2], data[3]);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\n}\r\ninput_sync(adbhid[id]->input);\r\n}\r\nstatic void leds_done(struct adb_request *req)\r\n{\r\nint leds = 0, device = 0, pending = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&leds_lock, flags);\r\nif (pending_led_start != pending_led_end) {\r\ndevice = pending_devs[pending_led_start];\r\nleds = leds_pending[device] & 0xff;\r\nleds_pending[device] = 0;\r\npending_led_start++;\r\npending_led_start = (pending_led_start < 16) ? pending_led_start : 0;\r\npending = leds_req_pending;\r\n} else\r\nleds_req_pending = 0;\r\nspin_unlock_irqrestore(&leds_lock, flags);\r\nif (pending)\r\nadb_request(&led_request, leds_done, 0, 3,\r\nADB_WRITEREG(device, KEYB_LEDREG), 0xff, ~leds);\r\n}\r\nstatic void real_leds(unsigned char leds, int device)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&leds_lock, flags);\r\nif (!leds_req_pending) {\r\nleds_req_pending = 1;\r\nspin_unlock_irqrestore(&leds_lock, flags);\r\nadb_request(&led_request, leds_done, 0, 3,\r\nADB_WRITEREG(device, KEYB_LEDREG), 0xff, ~leds);\r\nreturn;\r\n} else {\r\nif (!(leds_pending[device] & 0x100)) {\r\npending_devs[pending_led_end] = device;\r\npending_led_end++;\r\npending_led_end = (pending_led_end < 16) ? pending_led_end : 0;\r\n}\r\nleds_pending[device] = leds | 0x100;\r\n}\r\nspin_unlock_irqrestore(&leds_lock, flags);\r\n}\r\nstatic int adbhid_kbd_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)\r\n{\r\nstruct adbhid *adbhid = input_get_drvdata(dev);\r\nunsigned char leds;\r\nswitch (type) {\r\ncase EV_LED:\r\nleds = (test_bit(LED_SCROLLL, dev->led) ? 4 : 0) |\r\n(test_bit(LED_NUML, dev->led) ? 1 : 0) |\r\n(test_bit(LED_CAPSL, dev->led) ? 2 : 0);\r\nreal_leds(leds, adbhid->id);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic void\r\nadbhid_kbd_capslock_remember(void)\r\n{\r\nstruct adbhid *ahid;\r\nint i;\r\nfor (i = 1; i < 16; i++) {\r\nahid = adbhid[i];\r\nif (ahid && ahid->id == ADB_KEYBOARD)\r\nif (ahid->flags & FLAG_CAPSLOCK_TRANSLATE)\r\nahid->flags |= FLAG_CAPSLOCK_IGNORE_NEXT;\r\n}\r\n}\r\nstatic int\r\nadb_message_handler(struct notifier_block *this, unsigned long code, void *x)\r\n{\r\nswitch (code) {\r\ncase ADB_MSG_PRE_RESET:\r\ncase ADB_MSG_POWERDOWN:\r\n{\r\nint i;\r\nfor (i = 1; i < 16; i++) {\r\nif (adbhid[i])\r\ndel_timer_sync(&adbhid[i]->input->timer);\r\n}\r\n}\r\nwhile (leds_req_pending)\r\nadb_poll();\r\nif (restore_capslock_events)\r\nadbhid_kbd_capslock_remember();\r\nbreak;\r\ncase ADB_MSG_POST_RESET:\r\nadbhid_probe();\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int\r\nadbhid_input_register(int id, int default_id, int original_handler_id,\r\nint current_handler_id, int mouse_kind)\r\n{\r\nstruct adbhid *hid;\r\nstruct input_dev *input_dev;\r\nint err;\r\nint i;\r\nif (adbhid[id]) {\r\nprintk(KERN_ERR "Trying to reregister ADB HID on ID %d\n", id);\r\nreturn -EEXIST;\r\n}\r\nadbhid[id] = hid = kzalloc(sizeof(struct adbhid), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!hid || !input_dev) {\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nsprintf(hid->phys, "adb%d:%d.%02x/input", id, default_id, original_handler_id);\r\nhid->input = input_dev;\r\nhid->id = default_id;\r\nhid->original_handler_id = original_handler_id;\r\nhid->current_handler_id = current_handler_id;\r\nhid->mouse_kind = mouse_kind;\r\nhid->flags = 0;\r\ninput_set_drvdata(input_dev, hid);\r\ninput_dev->name = hid->name;\r\ninput_dev->phys = hid->phys;\r\ninput_dev->id.bustype = BUS_ADB;\r\ninput_dev->id.vendor = 0x0001;\r\ninput_dev->id.product = (id << 12) | (default_id << 8) | original_handler_id;\r\ninput_dev->id.version = 0x0100;\r\nswitch (default_id) {\r\ncase ADB_KEYBOARD:\r\nhid->keycode = kmalloc(sizeof(adb_to_linux_keycodes), GFP_KERNEL);\r\nif (!hid->keycode) {\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nsprintf(hid->name, "ADB keyboard");\r\nmemcpy(hid->keycode, adb_to_linux_keycodes, sizeof(adb_to_linux_keycodes));\r\nprintk(KERN_INFO "Detected ADB keyboard, type ");\r\nswitch (original_handler_id) {\r\ndefault:\r\nprintk("<unknown>.\n");\r\ninput_dev->id.version = ADB_KEYBOARD_UNKNOWN;\r\nbreak;\r\ncase 0x01: case 0x02: case 0x03: case 0x06: case 0x08:\r\ncase 0x0C: case 0x10: case 0x18: case 0x1B: case 0x1C:\r\ncase 0xC0: case 0xC3: case 0xC6:\r\nprintk("ANSI.\n");\r\ninput_dev->id.version = ADB_KEYBOARD_ANSI;\r\nbreak;\r\ncase 0x04: case 0x05: case 0x07: case 0x09: case 0x0D:\r\ncase 0x11: case 0x14: case 0x19: case 0x1D: case 0xC1:\r\ncase 0xC4: case 0xC7:\r\nprintk("ISO, swapping keys.\n");\r\ninput_dev->id.version = ADB_KEYBOARD_ISO;\r\ni = hid->keycode[10];\r\nhid->keycode[10] = hid->keycode[50];\r\nhid->keycode[50] = i;\r\nbreak;\r\ncase 0x12: case 0x15: case 0x16: case 0x17: case 0x1A:\r\ncase 0x1E: case 0xC2: case 0xC5: case 0xC8: case 0xC9:\r\nprintk("JIS.\n");\r\ninput_dev->id.version = ADB_KEYBOARD_JIS;\r\nbreak;\r\n}\r\nfor (i = 0; i < 128; i++)\r\nif (hid->keycode[i])\r\nset_bit(hid->keycode[i], input_dev->keybit);\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_LED) |\r\nBIT_MASK(EV_REP);\r\ninput_dev->ledbit[0] = BIT_MASK(LED_SCROLLL) |\r\nBIT_MASK(LED_CAPSL) | BIT_MASK(LED_NUML);\r\ninput_dev->event = adbhid_kbd_event;\r\ninput_dev->keycodemax = KEY_FN;\r\ninput_dev->keycodesize = sizeof(hid->keycode[0]);\r\nbreak;\r\ncase ADB_MOUSE:\r\nsprintf(hid->name, "ADB mouse");\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL);\r\ninput_dev->keybit[BIT_WORD(BTN_MOUSE)] = BIT_MASK(BTN_LEFT) |\r\nBIT_MASK(BTN_MIDDLE) | BIT_MASK(BTN_RIGHT);\r\ninput_dev->relbit[0] = BIT_MASK(REL_X) | BIT_MASK(REL_Y);\r\nbreak;\r\ncase ADB_MISC:\r\nswitch (original_handler_id) {\r\ncase 0x02:\r\nsprintf(hid->name, "ADB adjustable keyboard buttons");\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) |\r\nBIT_MASK(EV_REP);\r\nset_bit(KEY_SOUND, input_dev->keybit);\r\nset_bit(KEY_MUTE, input_dev->keybit);\r\nset_bit(KEY_VOLUMEUP, input_dev->keybit);\r\nset_bit(KEY_VOLUMEDOWN, input_dev->keybit);\r\nbreak;\r\ncase 0x1f:\r\nsprintf(hid->name, "ADB Powerbook buttons");\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) |\r\nBIT_MASK(EV_REP);\r\nset_bit(KEY_MUTE, input_dev->keybit);\r\nset_bit(KEY_VOLUMEUP, input_dev->keybit);\r\nset_bit(KEY_VOLUMEDOWN, input_dev->keybit);\r\nset_bit(KEY_BRIGHTNESSUP, input_dev->keybit);\r\nset_bit(KEY_BRIGHTNESSDOWN, input_dev->keybit);\r\nset_bit(KEY_EJECTCD, input_dev->keybit);\r\nset_bit(KEY_SWITCHVIDEOMODE, input_dev->keybit);\r\nset_bit(KEY_KBDILLUMTOGGLE, input_dev->keybit);\r\nset_bit(KEY_KBDILLUMDOWN, input_dev->keybit);\r\nset_bit(KEY_KBDILLUMUP, input_dev->keybit);\r\nbreak;\r\n}\r\nif (hid->name[0])\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "Trying to register unknown ADB device to input layer.\n");\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\ninput_dev->keycode = hid->keycode;\r\nerr = input_register_device(input_dev);\r\nif (err)\r\ngoto fail;\r\nif (default_id == ADB_KEYBOARD) {\r\ninput_dev->rep[REP_DELAY] = 500;\r\ninput_dev->rep[REP_PERIOD] = 66;\r\n}\r\nreturn 0;\r\nfail: input_free_device(input_dev);\r\nif (hid) {\r\nkfree(hid->keycode);\r\nkfree(hid);\r\n}\r\nadbhid[id] = NULL;\r\nreturn err;\r\n}\r\nstatic void adbhid_input_unregister(int id)\r\n{\r\ninput_unregister_device(adbhid[id]->input);\r\nkfree(adbhid[id]->keycode);\r\nkfree(adbhid[id]);\r\nadbhid[id] = NULL;\r\n}\r\nstatic u16\r\nadbhid_input_reregister(int id, int default_id, int org_handler_id,\r\nint cur_handler_id, int mk)\r\n{\r\nif (adbhid[id]) {\r\nif (adbhid[id]->input->id.product !=\r\n((id << 12)|(default_id << 8)|org_handler_id)) {\r\nadbhid_input_unregister(id);\r\nadbhid_input_register(id, default_id, org_handler_id,\r\ncur_handler_id, mk);\r\n}\r\n} else\r\nadbhid_input_register(id, default_id, org_handler_id,\r\ncur_handler_id, mk);\r\nreturn 1<<id;\r\n}\r\nstatic void\r\nadbhid_input_devcleanup(u16 exist)\r\n{\r\nint i;\r\nfor(i=1; i<16; i++)\r\nif (adbhid[i] && !(exist&(1<<i)))\r\nadbhid_input_unregister(i);\r\n}\r\nstatic void\r\nadbhid_probe(void)\r\n{\r\nstruct adb_request req;\r\nint i, default_id, org_handler_id, cur_handler_id;\r\nu16 reg = 0;\r\nadb_register(ADB_MOUSE, 0, &mouse_ids, adbhid_mouse_input);\r\nadb_register(ADB_KEYBOARD, 0, &keyboard_ids, adbhid_keyboard_input);\r\nadb_register(ADB_MISC, 0, &buttons_ids, adbhid_buttons_input);\r\nfor (i = 0; i < keyboard_ids.nids; i++) {\r\nint id = keyboard_ids.id[i];\r\nadb_get_infos(id, &default_id, &org_handler_id);\r\nadb_request(&req, NULL, ADBREQ_SYNC, 3,\r\nADB_WRITEREG(id, KEYB_LEDREG), 0xff, 0xff);\r\n#if 0\r\nif (adb_try_handler_change(id, 5))\r\nprintk("ADB keyboard at %d, handler set to 5\n", id);\r\nelse\r\n#endif\r\nif (adb_try_handler_change(id, 3))\r\nprintk("ADB keyboard at %d, handler set to 3\n", id);\r\nelse\r\nprintk("ADB keyboard at %d, handler 1\n", id);\r\nadb_get_infos(id, &default_id, &cur_handler_id);\r\nreg |= adbhid_input_reregister(id, default_id, org_handler_id,\r\ncur_handler_id, 0);\r\n}\r\nfor (i = 0; i < buttons_ids.nids; i++) {\r\nint id = buttons_ids.id[i];\r\nadb_get_infos(id, &default_id, &org_handler_id);\r\nreg |= adbhid_input_reregister(id, default_id, org_handler_id,\r\norg_handler_id, 0);\r\n}\r\nfor (i = 0; i < mouse_ids.nids; i++) {\r\nint id = mouse_ids.id[i];\r\nint mouse_kind;\r\nadb_get_infos(id, &default_id, &org_handler_id);\r\nif (adb_try_handler_change(id, 4)) {\r\nprintk("ADB mouse at %d, handler set to 4", id);\r\nmouse_kind = ADBMOUSE_EXTENDED;\r\n}\r\nelse if (adb_try_handler_change(id, 0x2F)) {\r\nprintk("ADB mouse at %d, handler set to 0x2F", id);\r\nmouse_kind = ADBMOUSE_MICROSPEED;\r\n}\r\nelse if (adb_try_handler_change(id, 0x42)) {\r\nprintk("ADB mouse at %d, handler set to 0x42", id);\r\nmouse_kind = ADBMOUSE_TRACKBALLPRO;\r\n}\r\nelse if (adb_try_handler_change(id, 0x66)) {\r\nprintk("ADB mouse at %d, handler set to 0x66", id);\r\nmouse_kind = ADBMOUSE_MICROSPEED;\r\n}\r\nelse if (adb_try_handler_change(id, 0x5F)) {\r\nprintk("ADB mouse at %d, handler set to 0x5F", id);\r\nmouse_kind = ADBMOUSE_MICROSPEED;\r\n}\r\nelse if (adb_try_handler_change(id, 3)) {\r\nprintk("ADB mouse at %d, handler set to 3", id);\r\nmouse_kind = ADBMOUSE_MS_A3;\r\n}\r\nelse if (adb_try_handler_change(id, 2)) {\r\nprintk("ADB mouse at %d, handler set to 2", id);\r\nmouse_kind = ADBMOUSE_STANDARD_200;\r\n}\r\nelse {\r\nprintk("ADB mouse at %d, handler 1", id);\r\nmouse_kind = ADBMOUSE_STANDARD_100;\r\n}\r\nif ((mouse_kind == ADBMOUSE_TRACKBALLPRO)\r\n|| (mouse_kind == ADBMOUSE_MICROSPEED)) {\r\ninit_microspeed(id);\r\n} else if (mouse_kind == ADBMOUSE_MS_A3) {\r\ninit_ms_a3(id);\r\n} else if (mouse_kind == ADBMOUSE_EXTENDED) {\r\nadb_request(&req, NULL, ADBREQ_SYNC | ADBREQ_REPLY, 1,\r\nADB_READREG(id, 1));\r\nif ((req.reply_len) &&\r\n(req.reply[1] == 0x9a) && ((req.reply[2] == 0x21)\r\n|| (req.reply[2] == 0x20))) {\r\nmouse_kind = ADBMOUSE_TRACKBALL;\r\ninit_trackball(id);\r\n}\r\nelse if ((req.reply_len >= 4) &&\r\n(req.reply[1] == 0x74) && (req.reply[2] == 0x70) &&\r\n(req.reply[3] == 0x61) && (req.reply[4] == 0x64)) {\r\nmouse_kind = ADBMOUSE_TRACKPAD;\r\ninit_trackpad(id);\r\n}\r\nelse if ((req.reply_len >= 4) &&\r\n(req.reply[1] == 0x4b) && (req.reply[2] == 0x4d) &&\r\n(req.reply[3] == 0x4c) && (req.reply[4] == 0x31)) {\r\nmouse_kind = ADBMOUSE_TURBOMOUSE5;\r\ninit_turbomouse(id);\r\n}\r\nelse if ((req.reply_len == 9) &&\r\n(req.reply[1] == 0x4b) && (req.reply[2] == 0x4f) &&\r\n(req.reply[3] == 0x49) && (req.reply[4] == 0x54)) {\r\nif (adb_try_handler_change(id, 0x42)) {\r\nprintk("\nADB MacAlly 2-button mouse at %d, handler set to 0x42", id);\r\nmouse_kind = ADBMOUSE_MACALLY2;\r\n}\r\n}\r\n}\r\nprintk("\n");\r\nadb_get_infos(id, &default_id, &cur_handler_id);\r\nreg |= adbhid_input_reregister(id, default_id, org_handler_id,\r\ncur_handler_id, mouse_kind);\r\n}\r\nadbhid_input_devcleanup(reg);\r\n}\r\nstatic void\r\ninit_trackpad(int id)\r\n{\r\nstruct adb_request req;\r\nunsigned char r1_buffer[8];\r\nprintk(" (trackpad)");\r\nadb_request(&req, NULL, ADBREQ_SYNC | ADBREQ_REPLY, 1,\r\nADB_READREG(id,1));\r\nif (req.reply_len < 8)\r\nprintk("bad length for reg. 1\n");\r\nelse\r\n{\r\nmemcpy(r1_buffer, &req.reply[1], 8);\r\nadb_request(&req, NULL, ADBREQ_SYNC, 9,\r\nADB_WRITEREG(id,1),\r\nr1_buffer[0],\r\nr1_buffer[1],\r\nr1_buffer[2],\r\nr1_buffer[3],\r\nr1_buffer[4],\r\nr1_buffer[5],\r\n0x0d,\r\nr1_buffer[7]);\r\nadb_request(&req, NULL, ADBREQ_SYNC, 9,\r\nADB_WRITEREG(id,2),\r\n0x99,\r\n0x94,\r\n0x19,\r\n0xff,\r\n0xb2,\r\n0x8a,\r\n0x1b,\r\n0x50);\r\nadb_request(&req, NULL, ADBREQ_SYNC, 9,\r\nADB_WRITEREG(id,1),\r\nr1_buffer[0],\r\nr1_buffer[1],\r\nr1_buffer[2],\r\nr1_buffer[3],\r\nr1_buffer[4],\r\nr1_buffer[5],\r\n0x03,\r\nr1_buffer[7]);\r\nadb_request(&req, NULL, ADBREQ_SYNC, 1, ADB_FLUSH(id));\r\n}\r\n}\r\nstatic void\r\ninit_trackball(int id)\r\n{\r\nstruct adb_request req;\r\nprintk(" (trackman/mouseman)");\r\nadb_request(&req, NULL, ADBREQ_SYNC, 3,\r\nADB_WRITEREG(id,1), 00,0x81);\r\nadb_request(&req, NULL, ADBREQ_SYNC, 3,\r\nADB_WRITEREG(id,1), 01,0x81);\r\nadb_request(&req, NULL, ADBREQ_SYNC, 3,\r\nADB_WRITEREG(id,1), 02,0x81);\r\nadb_request(&req, NULL, ADBREQ_SYNC, 3,\r\nADB_WRITEREG(id,1), 03,0x38);\r\nadb_request(&req, NULL, ADBREQ_SYNC, 3,\r\nADB_WRITEREG(id,1), 00,0x81);\r\nadb_request(&req, NULL, ADBREQ_SYNC, 3,\r\nADB_WRITEREG(id,1), 01,0x81);\r\nadb_request(&req, NULL, ADBREQ_SYNC, 3,\r\nADB_WRITEREG(id,1), 02,0x81);\r\nadb_request(&req, NULL, ADBREQ_SYNC, 3,\r\nADB_WRITEREG(id,1), 03,0x38);\r\n}\r\nstatic void\r\ninit_turbomouse(int id)\r\n{\r\nstruct adb_request req;\r\nprintk(" (TurboMouse 5)");\r\nadb_request(&req, NULL, ADBREQ_SYNC, 1, ADB_FLUSH(id));\r\nadb_request(&req, NULL, ADBREQ_SYNC, 1, ADB_FLUSH(3));\r\nadb_request(&req, NULL, ADBREQ_SYNC, 9,\r\nADB_WRITEREG(3,2),\r\n0xe7,\r\n0x8c,\r\n0,\r\n0,\r\n0,\r\n0xff,\r\n0xff,\r\n0x94);\r\nadb_request(&req, NULL, ADBREQ_SYNC, 1, ADB_FLUSH(3));\r\nadb_request(&req, NULL, ADBREQ_SYNC, 9,\r\nADB_WRITEREG(3,2),\r\n0xa5,\r\n0x14,\r\n0,\r\n0,\r\n0x69,\r\n0xff,\r\n0xff,\r\n0x27);\r\n}\r\nstatic void\r\ninit_microspeed(int id)\r\n{\r\nstruct adb_request req;\r\nprintk(" (Microspeed/MacPoint or compatible)");\r\nadb_request(&req, NULL, ADBREQ_SYNC, 1, ADB_FLUSH(id));\r\nadb_request(&req, NULL, ADBREQ_SYNC, 5,\r\nADB_WRITEREG(id,1),\r\n0x20,\r\n0x00,\r\n0x10,\r\n0x07);\r\nadb_request(&req, NULL, ADBREQ_SYNC, 1, ADB_FLUSH(id));\r\n}\r\nstatic void\r\ninit_ms_a3(int id)\r\n{\r\nstruct adb_request req;\r\nprintk(" (Mouse Systems A3 Mouse, or compatible)");\r\nadb_request(&req, NULL, ADBREQ_SYNC, 3,\r\nADB_WRITEREG(id, 0x2),\r\n0x00,\r\n0x07);\r\nadb_request(&req, NULL, ADBREQ_SYNC, 1, ADB_FLUSH(id));\r\n}\r\nstatic int __init adbhid_init(void)\r\n{\r\n#ifndef CONFIG_MAC\r\nif (!machine_is(chrp) && !machine_is(powermac))\r\nreturn 0;\r\n#endif\r\nled_request.complete = 1;\r\nadbhid_probe();\r\nblocking_notifier_chain_register(&adb_client_list,\r\n&adbhid_adb_notifier);\r\nreturn 0;\r\n}\r\nstatic void __exit adbhid_exit(void)\r\n{\r\n}
