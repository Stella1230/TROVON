static ssize_t uevent_seqnum_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%llu\n", (unsigned long long)uevent_seqnum);\r\n}\r\nstatic ssize_t uevent_helper_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", uevent_helper);\r\n}\r\nstatic ssize_t uevent_helper_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nif (count+1 > UEVENT_HELPER_PATH_LEN)\r\nreturn -ENOENT;\r\nmemcpy(uevent_helper, buf, count);\r\nuevent_helper[count] = '\0';\r\nif (count && uevent_helper[count-1] == '\n')\r\nuevent_helper[count-1] = '\0';\r\nreturn count;\r\n}\r\nstatic ssize_t profiling_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", prof_on);\r\n}\r\nstatic ssize_t profiling_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret;\r\nif (prof_on)\r\nreturn -EEXIST;\r\nprofile_setup((char *)buf);\r\nret = profile_init();\r\nif (ret)\r\nreturn ret;\r\nret = create_proc_profile();\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t kexec_loaded_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", !!kexec_image);\r\n}\r\nstatic ssize_t kexec_crash_loaded_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", !!kexec_crash_image);\r\n}\r\nstatic ssize_t kexec_crash_size_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%zu\n", crash_get_memory_size());\r\n}\r\nstatic ssize_t kexec_crash_size_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned long cnt;\r\nint ret;\r\nif (kstrtoul(buf, 0, &cnt))\r\nreturn -EINVAL;\r\nret = crash_shrink_memory(cnt);\r\nreturn ret < 0 ? ret : count;\r\n}\r\nstatic ssize_t vmcoreinfo_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%lx %x\n",\r\npaddr_vmcoreinfo_note(),\r\n(unsigned int)vmcoreinfo_max_size);\r\n}\r\nstatic ssize_t fscaps_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", file_caps_enabled);\r\n}\r\nstatic ssize_t rcu_expedited_show(struct kobject *kobj,\r\nstruct kobj_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", rcu_expedited);\r\n}\r\nstatic ssize_t rcu_expedited_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nif (kstrtoint(buf, 0, &rcu_expedited))\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic ssize_t notes_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nmemcpy(buf, &__start_notes + off, count);\r\nreturn count;\r\n}\r\nstatic int __init ksysfs_init(void)\r\n{\r\nint error;\r\nkernel_kobj = kobject_create_and_add("kernel", NULL);\r\nif (!kernel_kobj) {\r\nerror = -ENOMEM;\r\ngoto exit;\r\n}\r\nerror = sysfs_create_group(kernel_kobj, &kernel_attr_group);\r\nif (error)\r\ngoto kset_exit;\r\nif (notes_size > 0) {\r\nnotes_attr.size = notes_size;\r\nerror = sysfs_create_bin_file(kernel_kobj, &notes_attr);\r\nif (error)\r\ngoto group_exit;\r\n}\r\nreturn 0;\r\ngroup_exit:\r\nsysfs_remove_group(kernel_kobj, &kernel_attr_group);\r\nkset_exit:\r\nkobject_put(kernel_kobj);\r\nexit:\r\nreturn error;\r\n}
