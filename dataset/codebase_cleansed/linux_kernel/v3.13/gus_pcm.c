static void snd_gf1_pcm_block_change_ack(struct snd_gus_card * gus, void *private_data)\r\n{\r\nstruct gus_pcm_private *pcmp = private_data;\r\nif (pcmp) {\r\natomic_dec(&pcmp->dma_count);\r\nwake_up(&pcmp->sleep);\r\n}\r\n}\r\nstatic int snd_gf1_pcm_block_change(struct snd_pcm_substream *substream,\r\nunsigned int offset,\r\nunsigned int addr,\r\nunsigned int count)\r\n{\r\nstruct snd_gf1_dma_block block;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct gus_pcm_private *pcmp = runtime->private_data;\r\ncount += offset & 31;\r\noffset &= ~31;\r\nmemset(&block, 0, sizeof(block));\r\nblock.cmd = SNDRV_GF1_DMA_IRQ;\r\nif (snd_pcm_format_unsigned(runtime->format))\r\nblock.cmd |= SNDRV_GF1_DMA_UNSIGNED;\r\nif (snd_pcm_format_width(runtime->format) == 16)\r\nblock.cmd |= SNDRV_GF1_DMA_16BIT;\r\nblock.addr = addr & ~31;\r\nblock.buffer = runtime->dma_area + offset;\r\nblock.buf_addr = runtime->dma_addr + offset;\r\nblock.count = count;\r\nblock.private_data = pcmp;\r\nblock.ack = snd_gf1_pcm_block_change_ack;\r\nif (!snd_gf1_dma_transfer_block(pcmp->gus, &block, 0, 0))\r\natomic_inc(&pcmp->dma_count);\r\nreturn 0;\r\n}\r\nstatic void snd_gf1_pcm_trigger_up(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct gus_pcm_private *pcmp = runtime->private_data;\r\nstruct snd_gus_card * gus = pcmp->gus;\r\nunsigned long flags;\r\nunsigned char voice_ctrl, ramp_ctrl;\r\nunsigned short rate;\r\nunsigned int curr, begin, end;\r\nunsigned short vol;\r\nunsigned char pan;\r\nunsigned int voice;\r\nspin_lock_irqsave(&pcmp->lock, flags);\r\nif (pcmp->flags & SNDRV_GF1_PCM_PFLG_ACTIVE) {\r\nspin_unlock_irqrestore(&pcmp->lock, flags);\r\nreturn;\r\n}\r\npcmp->flags |= SNDRV_GF1_PCM_PFLG_ACTIVE;\r\npcmp->final_volume = 0;\r\nspin_unlock_irqrestore(&pcmp->lock, flags);\r\nrate = snd_gf1_translate_freq(gus, runtime->rate << 4);\r\nvoice_ctrl = snd_pcm_format_width(runtime->format) == 16 ? 0x24 : 0x20;\r\nramp_ctrl = 0x24;\r\nif (pcmp->blocks == 1) {\r\nvoice_ctrl |= 0x08;\r\nramp_ctrl &= ~0x04;\r\n}\r\nfor (voice = 0; voice < pcmp->voices; voice++) {\r\nbegin = pcmp->memory + voice * (pcmp->dma_size / runtime->channels);\r\ncurr = begin + (pcmp->bpos * pcmp->block_size) / runtime->channels;\r\nend = curr + (pcmp->block_size / runtime->channels);\r\nend -= snd_pcm_format_width(runtime->format) == 16 ? 2 : 1;\r\npan = runtime->channels == 2 ? (!voice ? 1 : 14) : 8;\r\nvol = !voice ? gus->gf1.pcm_volume_level_left : gus->gf1.pcm_volume_level_right;\r\nspin_lock_irqsave(&gus->reg_lock, flags);\r\nsnd_gf1_select_voice(gus, pcmp->pvoices[voice]->number);\r\nsnd_gf1_write8(gus, SNDRV_GF1_VB_PAN, pan);\r\nsnd_gf1_write16(gus, SNDRV_GF1_VW_FREQUENCY, rate);\r\nsnd_gf1_write_addr(gus, SNDRV_GF1_VA_START, begin << 4, voice_ctrl & 4);\r\nsnd_gf1_write_addr(gus, SNDRV_GF1_VA_END, end << 4, voice_ctrl & 4);\r\nsnd_gf1_write_addr(gus, SNDRV_GF1_VA_CURRENT, curr << 4, voice_ctrl & 4);\r\nsnd_gf1_write16(gus, SNDRV_GF1_VW_VOLUME, SNDRV_GF1_MIN_VOLUME << 4);\r\nsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_RATE, 0x2f);\r\nsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_START, SNDRV_GF1_MIN_OFFSET);\r\nsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_END, vol >> 8);\r\nsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_CONTROL, ramp_ctrl);\r\nif (!gus->gf1.enh_mode) {\r\nsnd_gf1_delay(gus);\r\nsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_CONTROL, ramp_ctrl);\r\n}\r\nspin_unlock_irqrestore(&gus->reg_lock, flags);\r\n}\r\nspin_lock_irqsave(&gus->reg_lock, flags);\r\nfor (voice = 0; voice < pcmp->voices; voice++) {\r\nsnd_gf1_select_voice(gus, pcmp->pvoices[voice]->number);\r\nif (gus->gf1.enh_mode)\r\nsnd_gf1_write8(gus, SNDRV_GF1_VB_MODE, 0x00);\r\nsnd_gf1_write8(gus, SNDRV_GF1_VB_ADDRESS_CONTROL, voice_ctrl);\r\nvoice_ctrl &= ~0x20;\r\n}\r\nvoice_ctrl |= 0x20;\r\nif (!gus->gf1.enh_mode) {\r\nsnd_gf1_delay(gus);\r\nfor (voice = 0; voice < pcmp->voices; voice++) {\r\nsnd_gf1_select_voice(gus, pcmp->pvoices[voice]->number);\r\nsnd_gf1_write8(gus, SNDRV_GF1_VB_ADDRESS_CONTROL, voice_ctrl);\r\nvoice_ctrl &= ~0x20;\r\n}\r\n}\r\nspin_unlock_irqrestore(&gus->reg_lock, flags);\r\n}\r\nstatic void snd_gf1_pcm_interrupt_wave(struct snd_gus_card * gus,\r\nstruct snd_gus_voice *pvoice)\r\n{\r\nstruct gus_pcm_private * pcmp;\r\nstruct snd_pcm_runtime *runtime;\r\nunsigned char voice_ctrl, ramp_ctrl;\r\nunsigned int idx;\r\nunsigned int end, step;\r\nif (!pvoice->private_data) {\r\nsnd_printd("snd_gf1_pcm: unknown wave irq?\n");\r\nsnd_gf1_smart_stop_voice(gus, pvoice->number);\r\nreturn;\r\n}\r\npcmp = pvoice->private_data;\r\nif (pcmp == NULL) {\r\nsnd_printd("snd_gf1_pcm: unknown wave irq?\n");\r\nsnd_gf1_smart_stop_voice(gus, pvoice->number);\r\nreturn;\r\n}\r\ngus = pcmp->gus;\r\nruntime = pcmp->substream->runtime;\r\nspin_lock(&gus->reg_lock);\r\nsnd_gf1_select_voice(gus, pvoice->number);\r\nvoice_ctrl = snd_gf1_read8(gus, SNDRV_GF1_VB_ADDRESS_CONTROL) & ~0x8b;\r\nramp_ctrl = (snd_gf1_read8(gus, SNDRV_GF1_VB_VOLUME_CONTROL) & ~0xa4) | 0x03;\r\n#if 0\r\nsnd_gf1_select_voice(gus, pvoice->number);\r\nprintk(KERN_DEBUG "position = 0x%x\n",\r\n(snd_gf1_read_addr(gus, SNDRV_GF1_VA_CURRENT, voice_ctrl & 4) >> 4));\r\nsnd_gf1_select_voice(gus, pcmp->pvoices[1]->number);\r\nprintk(KERN_DEBUG "position = 0x%x\n",\r\n(snd_gf1_read_addr(gus, SNDRV_GF1_VA_CURRENT, voice_ctrl & 4) >> 4));\r\nsnd_gf1_select_voice(gus, pvoice->number);\r\n#endif\r\npcmp->bpos++;\r\npcmp->bpos %= pcmp->blocks;\r\nif (pcmp->bpos + 1 >= pcmp->blocks) {\r\nvoice_ctrl |= 0x08;\r\n} else {\r\nramp_ctrl |= 0x04;\r\n}\r\nend = pcmp->memory + (((pcmp->bpos + 1) * pcmp->block_size) / runtime->channels);\r\nend -= voice_ctrl & 4 ? 2 : 1;\r\nstep = pcmp->dma_size / runtime->channels;\r\nvoice_ctrl |= 0x20;\r\nif (!pcmp->final_volume) {\r\nramp_ctrl |= 0x20;\r\nramp_ctrl &= ~0x03;\r\n}\r\nfor (idx = 0; idx < pcmp->voices; idx++, end += step) {\r\nsnd_gf1_select_voice(gus, pcmp->pvoices[idx]->number);\r\nsnd_gf1_write_addr(gus, SNDRV_GF1_VA_END, end << 4, voice_ctrl & 4);\r\nsnd_gf1_write8(gus, SNDRV_GF1_VB_ADDRESS_CONTROL, voice_ctrl);\r\nsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_CONTROL, ramp_ctrl);\r\nvoice_ctrl &= ~0x20;\r\n}\r\nif (!gus->gf1.enh_mode) {\r\nsnd_gf1_delay(gus);\r\nvoice_ctrl |= 0x20;\r\nfor (idx = 0; idx < pcmp->voices; idx++) {\r\nsnd_gf1_select_voice(gus, pcmp->pvoices[idx]->number);\r\nsnd_gf1_write8(gus, SNDRV_GF1_VB_ADDRESS_CONTROL, voice_ctrl);\r\nsnd_gf1_write8(gus, SNDRV_GF1_VB_VOLUME_CONTROL, ramp_ctrl);\r\nvoice_ctrl &= ~0x20;\r\n}\r\n}\r\nspin_unlock(&gus->reg_lock);\r\nsnd_pcm_period_elapsed(pcmp->substream);\r\n#if 0\r\nif ((runtime->flags & SNDRV_PCM_FLG_MMAP) &&\r\n*runtime->state == SNDRV_PCM_STATE_RUNNING) {\r\nend = pcmp->bpos * pcmp->block_size;\r\nif (runtime->channels > 1) {\r\nsnd_gf1_pcm_block_change(pcmp->substream, end, pcmp->memory + (end / 2), pcmp->block_size / 2);\r\nsnd_gf1_pcm_block_change(pcmp->substream, end + (pcmp->block_size / 2), pcmp->memory + (pcmp->dma_size / 2) + (end / 2), pcmp->block_size / 2);\r\n} else {\r\nsnd_gf1_pcm_block_change(pcmp->substream, end, pcmp->memory + end, pcmp->block_size);\r\n}\r\n}\r\n#endif\r\n}\r\nstatic void snd_gf1_pcm_interrupt_volume(struct snd_gus_card * gus,\r\nstruct snd_gus_voice * pvoice)\r\n{\r\nunsigned short vol;\r\nint cvoice;\r\nstruct gus_pcm_private *pcmp = pvoice->private_data;\r\nspin_lock(&gus->reg_lock);\r\nsnd_gf1_select_voice(gus, pvoice->number);\r\nsnd_gf1_ctrl_stop(gus, SNDRV_GF1_VB_VOLUME_CONTROL);\r\nspin_unlock(&gus->reg_lock);\r\nif (pcmp == NULL)\r\nreturn;\r\nif (!(pcmp->flags & SNDRV_GF1_PCM_PFLG_ACTIVE))\r\nreturn;\r\ncvoice = pcmp->pvoices[0] == pvoice ? 0 : 1;\r\nif (pcmp->substream == NULL)\r\nreturn;\r\nvol = !cvoice ? gus->gf1.pcm_volume_level_left : gus->gf1.pcm_volume_level_right;\r\nspin_lock(&gus->reg_lock);\r\nsnd_gf1_select_voice(gus, pvoice->number);\r\nsnd_gf1_write16(gus, SNDRV_GF1_VW_VOLUME, vol);\r\npcmp->final_volume = 1;\r\nspin_unlock(&gus->reg_lock);\r\n}\r\nstatic void snd_gf1_pcm_volume_change(struct snd_gus_card * gus)\r\n{\r\n}\r\nstatic int snd_gf1_pcm_poke_block(struct snd_gus_card *gus, unsigned char *buf,\r\nunsigned int pos, unsigned int count,\r\nint w16, int invert)\r\n{\r\nunsigned int len;\r\nunsigned long flags;\r\nwhile (count > 0) {\r\nlen = count;\r\nif (len > 512)\r\nlen = 512;\r\ncount -= len;\r\nif (gus->interwave) {\r\nspin_lock_irqsave(&gus->reg_lock, flags);\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_MEMORY_CONTROL, 0x01 | (invert ? 0x08 : 0x00));\r\nsnd_gf1_dram_addr(gus, pos);\r\nif (w16) {\r\noutb(SNDRV_GF1_GW_DRAM_IO16, GUSP(gus, GF1REGSEL));\r\noutsw(GUSP(gus, GF1DATALOW), buf, len >> 1);\r\n} else {\r\noutsb(GUSP(gus, DRAM), buf, len);\r\n}\r\nspin_unlock_irqrestore(&gus->reg_lock, flags);\r\nbuf += 512;\r\npos += 512;\r\n} else {\r\ninvert = invert ? 0x80 : 0x00;\r\nif (w16) {\r\nlen >>= 1;\r\nwhile (len--) {\r\nsnd_gf1_poke(gus, pos++, *buf++);\r\nsnd_gf1_poke(gus, pos++, *buf++ ^ invert);\r\n}\r\n} else {\r\nwhile (len--)\r\nsnd_gf1_poke(gus, pos++, *buf++ ^ invert);\r\n}\r\n}\r\nif (count > 0 && !in_interrupt()) {\r\nschedule_timeout_interruptible(1);\r\nif (signal_pending(current))\r\nreturn -EAGAIN;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_gf1_pcm_playback_copy(struct snd_pcm_substream *substream,\r\nint voice,\r\nsnd_pcm_uframes_t pos,\r\nvoid __user *src,\r\nsnd_pcm_uframes_t count)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct gus_pcm_private *pcmp = runtime->private_data;\r\nunsigned int bpos, len;\r\nbpos = samples_to_bytes(runtime, pos) + (voice * (pcmp->dma_size / 2));\r\nlen = samples_to_bytes(runtime, count);\r\nif (snd_BUG_ON(bpos > pcmp->dma_size))\r\nreturn -EIO;\r\nif (snd_BUG_ON(bpos + len > pcmp->dma_size))\r\nreturn -EIO;\r\nif (copy_from_user(runtime->dma_area + bpos, src, len))\r\nreturn -EFAULT;\r\nif (snd_gf1_pcm_use_dma && len > 32) {\r\nreturn snd_gf1_pcm_block_change(substream, bpos, pcmp->memory + bpos, len);\r\n} else {\r\nstruct snd_gus_card *gus = pcmp->gus;\r\nint err, w16, invert;\r\nw16 = (snd_pcm_format_width(runtime->format) == 16);\r\ninvert = snd_pcm_format_unsigned(runtime->format);\r\nif ((err = snd_gf1_pcm_poke_block(gus, runtime->dma_area + bpos, pcmp->memory + bpos, len, w16, invert)) < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_gf1_pcm_playback_silence(struct snd_pcm_substream *substream,\r\nint voice,\r\nsnd_pcm_uframes_t pos,\r\nsnd_pcm_uframes_t count)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct gus_pcm_private *pcmp = runtime->private_data;\r\nunsigned int bpos, len;\r\nbpos = samples_to_bytes(runtime, pos) + (voice * (pcmp->dma_size / 2));\r\nlen = samples_to_bytes(runtime, count);\r\nif (snd_BUG_ON(bpos > pcmp->dma_size))\r\nreturn -EIO;\r\nif (snd_BUG_ON(bpos + len > pcmp->dma_size))\r\nreturn -EIO;\r\nsnd_pcm_format_set_silence(runtime->format, runtime->dma_area + bpos, count);\r\nif (snd_gf1_pcm_use_dma && len > 32) {\r\nreturn snd_gf1_pcm_block_change(substream, bpos, pcmp->memory + bpos, len);\r\n} else {\r\nstruct snd_gus_card *gus = pcmp->gus;\r\nint err, w16, invert;\r\nw16 = (snd_pcm_format_width(runtime->format) == 16);\r\ninvert = snd_pcm_format_unsigned(runtime->format);\r\nif ((err = snd_gf1_pcm_poke_block(gus, runtime->dma_area + bpos, pcmp->memory + bpos, len, w16, invert)) < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_gf1_pcm_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct gus_pcm_private *pcmp = runtime->private_data;\r\nint err;\r\nif ((err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)\r\nreturn err;\r\nif (err > 0) {\r\nstruct snd_gf1_mem_block *block;\r\nif (pcmp->memory > 0) {\r\nsnd_gf1_mem_free(&gus->gf1.mem_alloc, pcmp->memory);\r\npcmp->memory = 0;\r\n}\r\nif ((block = snd_gf1_mem_alloc(&gus->gf1.mem_alloc,\r\nSNDRV_GF1_MEM_OWNER_DRIVER,\r\n"GF1 PCM",\r\nruntime->dma_bytes, 1, 32,\r\nNULL)) == NULL)\r\nreturn -ENOMEM;\r\npcmp->memory = block->ptr;\r\n}\r\npcmp->voices = params_channels(hw_params);\r\nif (pcmp->pvoices[0] == NULL) {\r\nif ((pcmp->pvoices[0] = snd_gf1_alloc_voice(pcmp->gus, SNDRV_GF1_VOICE_TYPE_PCM, 0, 0)) == NULL)\r\nreturn -ENOMEM;\r\npcmp->pvoices[0]->handler_wave = snd_gf1_pcm_interrupt_wave;\r\npcmp->pvoices[0]->handler_volume = snd_gf1_pcm_interrupt_volume;\r\npcmp->pvoices[0]->volume_change = snd_gf1_pcm_volume_change;\r\npcmp->pvoices[0]->private_data = pcmp;\r\n}\r\nif (pcmp->voices > 1 && pcmp->pvoices[1] == NULL) {\r\nif ((pcmp->pvoices[1] = snd_gf1_alloc_voice(pcmp->gus, SNDRV_GF1_VOICE_TYPE_PCM, 0, 0)) == NULL)\r\nreturn -ENOMEM;\r\npcmp->pvoices[1]->handler_wave = snd_gf1_pcm_interrupt_wave;\r\npcmp->pvoices[1]->handler_volume = snd_gf1_pcm_interrupt_volume;\r\npcmp->pvoices[1]->volume_change = snd_gf1_pcm_volume_change;\r\npcmp->pvoices[1]->private_data = pcmp;\r\n} else if (pcmp->voices == 1) {\r\nif (pcmp->pvoices[1]) {\r\nsnd_gf1_free_voice(pcmp->gus, pcmp->pvoices[1]);\r\npcmp->pvoices[1] = NULL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_gf1_pcm_playback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct gus_pcm_private *pcmp = runtime->private_data;\r\nsnd_pcm_lib_free_pages(substream);\r\nif (pcmp->pvoices[0]) {\r\nsnd_gf1_free_voice(pcmp->gus, pcmp->pvoices[0]);\r\npcmp->pvoices[0] = NULL;\r\n}\r\nif (pcmp->pvoices[1]) {\r\nsnd_gf1_free_voice(pcmp->gus, pcmp->pvoices[1]);\r\npcmp->pvoices[1] = NULL;\r\n}\r\nif (pcmp->memory > 0) {\r\nsnd_gf1_mem_free(&pcmp->gus->gf1.mem_alloc, pcmp->memory);\r\npcmp->memory = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_gf1_pcm_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct gus_pcm_private *pcmp = runtime->private_data;\r\npcmp->bpos = 0;\r\npcmp->dma_size = snd_pcm_lib_buffer_bytes(substream);\r\npcmp->block_size = snd_pcm_lib_period_bytes(substream);\r\npcmp->blocks = pcmp->dma_size / pcmp->block_size;\r\nreturn 0;\r\n}\r\nstatic int snd_gf1_pcm_playback_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct gus_pcm_private *pcmp = runtime->private_data;\r\nint voice;\r\nif (cmd == SNDRV_PCM_TRIGGER_START) {\r\nsnd_gf1_pcm_trigger_up(substream);\r\n} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\r\nspin_lock(&pcmp->lock);\r\npcmp->flags &= ~SNDRV_GF1_PCM_PFLG_ACTIVE;\r\nspin_unlock(&pcmp->lock);\r\nvoice = pcmp->pvoices[0]->number;\r\nsnd_gf1_stop_voices(gus, voice, voice);\r\nif (pcmp->pvoices[1]) {\r\nvoice = pcmp->pvoices[1]->number;\r\nsnd_gf1_stop_voices(gus, voice, voice);\r\n}\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_gf1_pcm_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct gus_pcm_private *pcmp = runtime->private_data;\r\nunsigned int pos;\r\nunsigned char voice_ctrl;\r\npos = 0;\r\nspin_lock(&gus->reg_lock);\r\nif (pcmp->flags & SNDRV_GF1_PCM_PFLG_ACTIVE) {\r\nsnd_gf1_select_voice(gus, pcmp->pvoices[0]->number);\r\nvoice_ctrl = snd_gf1_read8(gus, SNDRV_GF1_VB_ADDRESS_CONTROL);\r\npos = (snd_gf1_read_addr(gus, SNDRV_GF1_VA_CURRENT, voice_ctrl & 4) >> 4) - pcmp->memory;\r\nif (substream->runtime->channels > 1)\r\npos <<= 1;\r\npos = bytes_to_frames(runtime, pos);\r\n}\r\nspin_unlock(&gus->reg_lock);\r\nreturn pos;\r\n}\r\nstatic int snd_gf1_pcm_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\r\ngus->c_dma_size = params_buffer_bytes(hw_params);\r\ngus->c_period_size = params_period_bytes(hw_params);\r\ngus->c_pos = 0;\r\ngus->gf1.pcm_rcntrl_reg = 0x21;\r\nif (params_channels(hw_params) > 1)\r\ngus->gf1.pcm_rcntrl_reg |= 2;\r\nif (gus->gf1.dma2 > 3)\r\ngus->gf1.pcm_rcntrl_reg |= 4;\r\nif (snd_pcm_format_unsigned(params_format(hw_params)))\r\ngus->gf1.pcm_rcntrl_reg |= 0x80;\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_gf1_pcm_capture_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_gf1_pcm_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RECORD_RATE, runtime->rate_den - 2);\r\nsnd_gf1_i_write8(gus, SNDRV_GF1_GB_REC_DMA_CONTROL, 0);\r\nsnd_gf1_i_look8(gus, SNDRV_GF1_GB_REC_DMA_CONTROL);\r\nsnd_dma_program(gus->gf1.dma2, runtime->dma_addr, gus->c_period_size, DMA_MODE_READ);\r\nreturn 0;\r\n}\r\nstatic int snd_gf1_pcm_capture_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\r\nint val;\r\nif (cmd == SNDRV_PCM_TRIGGER_START) {\r\nval = gus->gf1.pcm_rcntrl_reg;\r\n} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\r\nval = 0;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&gus->reg_lock);\r\nsnd_gf1_write8(gus, SNDRV_GF1_GB_REC_DMA_CONTROL, val);\r\nsnd_gf1_look8(gus, SNDRV_GF1_GB_REC_DMA_CONTROL);\r\nspin_unlock(&gus->reg_lock);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_gf1_pcm_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\r\nint pos = snd_dma_pointer(gus->gf1.dma2, gus->c_period_size);\r\npos = bytes_to_frames(substream->runtime, (gus->c_pos + pos) % gus->c_dma_size);\r\nreturn pos;\r\n}\r\nstatic void snd_gf1_pcm_interrupt_dma_read(struct snd_gus_card * gus)\r\n{\r\nsnd_gf1_i_write8(gus, SNDRV_GF1_GB_REC_DMA_CONTROL, 0);\r\nsnd_gf1_i_look8(gus, SNDRV_GF1_GB_REC_DMA_CONTROL);\r\nif (gus->pcm_cap_substream != NULL) {\r\nsnd_gf1_pcm_capture_prepare(gus->pcm_cap_substream);\r\nsnd_gf1_pcm_capture_trigger(gus->pcm_cap_substream, SNDRV_PCM_TRIGGER_START);\r\ngus->c_pos += gus->c_period_size;\r\nsnd_pcm_period_elapsed(gus->pcm_cap_substream);\r\n}\r\n}\r\nstatic void snd_gf1_pcm_playback_free(struct snd_pcm_runtime *runtime)\r\n{\r\nkfree(runtime->private_data);\r\n}\r\nstatic int snd_gf1_pcm_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct gus_pcm_private *pcmp;\r\nstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\npcmp = kzalloc(sizeof(*pcmp), GFP_KERNEL);\r\nif (pcmp == NULL)\r\nreturn -ENOMEM;\r\npcmp->gus = gus;\r\nspin_lock_init(&pcmp->lock);\r\ninit_waitqueue_head(&pcmp->sleep);\r\natomic_set(&pcmp->dma_count, 0);\r\nruntime->private_data = pcmp;\r\nruntime->private_free = snd_gf1_pcm_playback_free;\r\n#if 0\r\nprintk(KERN_DEBUG "playback.buffer = 0x%lx, gf1.pcm_buffer = 0x%lx\n",\r\n(long) pcm->playback.buffer, (long) gus->gf1.pcm_buffer);\r\n#endif\r\nif ((err = snd_gf1_dma_init(gus)) < 0)\r\nreturn err;\r\npcmp->flags = SNDRV_GF1_PCM_PFLG_NONE;\r\npcmp->substream = substream;\r\nruntime->hw = snd_gf1_pcm_playback;\r\nsnd_pcm_limit_isa_dma_size(gus->gf1.dma1, &runtime->hw.buffer_bytes_max);\r\nsnd_pcm_limit_isa_dma_size(gus->gf1.dma1, &runtime->hw.period_bytes_max);\r\nsnd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 64);\r\nreturn 0;\r\n}\r\nstatic int snd_gf1_pcm_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct gus_pcm_private *pcmp = runtime->private_data;\r\nif (!wait_event_timeout(pcmp->sleep, (atomic_read(&pcmp->dma_count) <= 0), 2*HZ))\r\nsnd_printk(KERN_ERR "gf1 pcm - serious DMA problem\n");\r\nsnd_gf1_dma_done(gus);\r\nreturn 0;\r\n}\r\nstatic int snd_gf1_pcm_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\r\ngus->gf1.interrupt_handler_dma_read = snd_gf1_pcm_interrupt_dma_read;\r\ngus->pcm_cap_substream = substream;\r\nsubstream->runtime->hw = snd_gf1_pcm_capture;\r\nsnd_pcm_limit_isa_dma_size(gus->gf1.dma2, &runtime->hw.buffer_bytes_max);\r\nsnd_pcm_limit_isa_dma_size(gus->gf1.dma2, &runtime->hw.period_bytes_max);\r\nsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&hw_constraints_clocks);\r\nreturn 0;\r\n}\r\nstatic int snd_gf1_pcm_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_gus_card *gus = snd_pcm_substream_chip(substream);\r\ngus->pcm_cap_substream = NULL;\r\nsnd_gf1_set_default_handlers(gus, SNDRV_GF1_HANDLER_DMA_READ);\r\nreturn 0;\r\n}\r\nstatic int snd_gf1_pcm_volume_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 127;\r\nreturn 0;\r\n}\r\nstatic int snd_gf1_pcm_volume_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_gus_card *gus = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nspin_lock_irqsave(&gus->pcm_volume_level_lock, flags);\r\nucontrol->value.integer.value[0] = gus->gf1.pcm_volume_level_left1;\r\nucontrol->value.integer.value[1] = gus->gf1.pcm_volume_level_right1;\r\nspin_unlock_irqrestore(&gus->pcm_volume_level_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_gf1_pcm_volume_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_gus_card *gus = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint change;\r\nunsigned int idx;\r\nunsigned short val1, val2, vol;\r\nstruct gus_pcm_private *pcmp;\r\nstruct snd_gus_voice *pvoice;\r\nval1 = ucontrol->value.integer.value[0] & 127;\r\nval2 = ucontrol->value.integer.value[1] & 127;\r\nspin_lock_irqsave(&gus->pcm_volume_level_lock, flags);\r\nchange = val1 != gus->gf1.pcm_volume_level_left1 ||\r\nval2 != gus->gf1.pcm_volume_level_right1;\r\ngus->gf1.pcm_volume_level_left1 = val1;\r\ngus->gf1.pcm_volume_level_right1 = val2;\r\ngus->gf1.pcm_volume_level_left = snd_gf1_lvol_to_gvol_raw(val1 << 9) << 4;\r\ngus->gf1.pcm_volume_level_right = snd_gf1_lvol_to_gvol_raw(val2 << 9) << 4;\r\nspin_unlock_irqrestore(&gus->pcm_volume_level_lock, flags);\r\nspin_lock_irqsave(&gus->voice_alloc, flags);\r\nfor (idx = 0; idx < 32; idx++) {\r\npvoice = &gus->gf1.voices[idx];\r\nif (!pvoice->pcm)\r\ncontinue;\r\npcmp = pvoice->private_data;\r\nif (!(pcmp->flags & SNDRV_GF1_PCM_PFLG_ACTIVE))\r\ncontinue;\r\nspin_lock(&gus->reg_lock);\r\nsnd_gf1_select_voice(gus, pvoice->number);\r\nsnd_gf1_ctrl_stop(gus, SNDRV_GF1_VB_VOLUME_CONTROL);\r\nvol = pvoice == pcmp->pvoices[0] ? gus->gf1.pcm_volume_level_left : gus->gf1.pcm_volume_level_right;\r\nsnd_gf1_write16(gus, SNDRV_GF1_VW_VOLUME, vol);\r\npcmp->final_volume = 1;\r\nspin_unlock(&gus->reg_lock);\r\n}\r\nspin_unlock_irqrestore(&gus->voice_alloc, flags);\r\nreturn change;\r\n}\r\nint snd_gf1_pcm_new(struct snd_gus_card * gus, int pcm_dev, int control_index, struct snd_pcm ** rpcm)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_pcm *pcm;\r\nstruct snd_pcm_substream *substream;\r\nint capture, err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\ncard = gus->card;\r\ncapture = !gus->interwave && !gus->ess_flag && !gus->ace_flag ? 1 : 0;\r\nerr = snd_pcm_new(card,\r\ngus->interwave ? "AMD InterWave" : "GF1",\r\npcm_dev,\r\ngus->gf1.pcm_channels / 2,\r\ncapture,\r\n&pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = gus;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_gf1_pcm_playback_ops);\r\nfor (substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream; substream; substream = substream->next)\r\nsnd_pcm_lib_preallocate_pages(substream, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_isa_data(),\r\n64*1024, gus->gf1.dma1 > 3 ? 128*1024 : 64*1024);\r\npcm->info_flags = 0;\r\npcm->dev_subclass = SNDRV_PCM_SUBCLASS_GENERIC_MIX;\r\nif (capture) {\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_gf1_pcm_capture_ops);\r\nif (gus->gf1.dma2 == gus->gf1.dma1)\r\npcm->info_flags |= SNDRV_PCM_INFO_HALF_DUPLEX;\r\nsnd_pcm_lib_preallocate_pages(pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream,\r\nSNDRV_DMA_TYPE_DEV, snd_dma_isa_data(),\r\n64*1024, gus->gf1.dma2 > 3 ? 128*1024 : 64*1024);\r\n}\r\nstrcpy(pcm->name, pcm->id);\r\nif (gus->interwave) {\r\nsprintf(pcm->name + strlen(pcm->name), " rev %c", gus->revision + 'A');\r\n}\r\nstrcat(pcm->name, " (synth)");\r\ngus->pcm = pcm;\r\nif (gus->codec_flag)\r\nkctl = snd_ctl_new1(&snd_gf1_pcm_volume_control1, gus);\r\nelse\r\nkctl = snd_ctl_new1(&snd_gf1_pcm_volume_control, gus);\r\nif ((err = snd_ctl_add(card, kctl)) < 0)\r\nreturn err;\r\nkctl->id.index = control_index;\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}
