static inline int translation_enabled(struct iommu_table *tbl)\r\n{\r\nreturn (tbl != NULL);\r\n}\r\nstatic void iommu_range_reserve(struct iommu_table *tbl,\r\nunsigned long start_addr, unsigned int npages)\r\n{\r\nunsigned long index;\r\nunsigned long end;\r\nunsigned long flags;\r\nindex = start_addr >> PAGE_SHIFT;\r\nif (index >= tbl->it_size)\r\nreturn;\r\nend = index + npages;\r\nif (end > tbl->it_size)\r\nend = tbl->it_size;\r\nspin_lock_irqsave(&tbl->it_lock, flags);\r\nbitmap_set(tbl->it_map, index, npages);\r\nspin_unlock_irqrestore(&tbl->it_lock, flags);\r\n}\r\nstatic unsigned long iommu_range_alloc(struct device *dev,\r\nstruct iommu_table *tbl,\r\nunsigned int npages)\r\n{\r\nunsigned long flags;\r\nunsigned long offset;\r\nunsigned long boundary_size;\r\nboundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,\r\nPAGE_SIZE) >> PAGE_SHIFT;\r\nBUG_ON(npages == 0);\r\nspin_lock_irqsave(&tbl->it_lock, flags);\r\noffset = iommu_area_alloc(tbl->it_map, tbl->it_size, tbl->it_hint,\r\nnpages, 0, boundary_size, 0);\r\nif (offset == ~0UL) {\r\ntbl->chip_ops->tce_cache_blast(tbl);\r\noffset = iommu_area_alloc(tbl->it_map, tbl->it_size, 0,\r\nnpages, 0, boundary_size, 0);\r\nif (offset == ~0UL) {\r\npr_warn("IOMMU full\n");\r\nspin_unlock_irqrestore(&tbl->it_lock, flags);\r\nif (panic_on_overflow)\r\npanic("Calgary: fix the allocator.\n");\r\nelse\r\nreturn DMA_ERROR_CODE;\r\n}\r\n}\r\ntbl->it_hint = offset + npages;\r\nBUG_ON(tbl->it_hint > tbl->it_size);\r\nspin_unlock_irqrestore(&tbl->it_lock, flags);\r\nreturn offset;\r\n}\r\nstatic dma_addr_t iommu_alloc(struct device *dev, struct iommu_table *tbl,\r\nvoid *vaddr, unsigned int npages, int direction)\r\n{\r\nunsigned long entry;\r\ndma_addr_t ret;\r\nentry = iommu_range_alloc(dev, tbl, npages);\r\nif (unlikely(entry == DMA_ERROR_CODE)) {\r\npr_warn("failed to allocate %u pages in iommu %p\n",\r\nnpages, tbl);\r\nreturn DMA_ERROR_CODE;\r\n}\r\nret = (entry << PAGE_SHIFT) | ((unsigned long)vaddr & ~PAGE_MASK);\r\ntce_build(tbl, entry, npages, (unsigned long)vaddr & PAGE_MASK,\r\ndirection);\r\nreturn ret;\r\n}\r\nstatic void iommu_free(struct iommu_table *tbl, dma_addr_t dma_addr,\r\nunsigned int npages)\r\n{\r\nunsigned long entry;\r\nunsigned long badend;\r\nunsigned long flags;\r\nbadend = DMA_ERROR_CODE + (EMERGENCY_PAGES * PAGE_SIZE);\r\nif (unlikely((dma_addr >= DMA_ERROR_CODE) && (dma_addr < badend))) {\r\nWARN(1, KERN_ERR "Calgary: driver tried unmapping bad DMA "\r\n"address 0x%Lx\n", dma_addr);\r\nreturn;\r\n}\r\nentry = dma_addr >> PAGE_SHIFT;\r\nBUG_ON(entry + npages > tbl->it_size);\r\ntce_free(tbl, entry, npages);\r\nspin_lock_irqsave(&tbl->it_lock, flags);\r\nbitmap_clear(tbl->it_map, entry, npages);\r\nspin_unlock_irqrestore(&tbl->it_lock, flags);\r\n}\r\nstatic inline struct iommu_table *find_iommu_table(struct device *dev)\r\n{\r\nstruct pci_dev *pdev;\r\nstruct pci_bus *pbus;\r\nstruct iommu_table *tbl;\r\npdev = to_pci_dev(dev);\r\npbus = pdev->bus;\r\ndo {\r\ntbl = pci_iommu(pbus);\r\nif (tbl && tbl->it_busno == pbus->number)\r\nbreak;\r\ntbl = NULL;\r\npbus = pbus->parent;\r\n} while (pbus);\r\nBUG_ON(tbl && (tbl->it_busno != pbus->number));\r\nreturn tbl;\r\n}\r\nstatic void calgary_unmap_sg(struct device *dev, struct scatterlist *sglist,\r\nint nelems,enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct iommu_table *tbl = find_iommu_table(dev);\r\nstruct scatterlist *s;\r\nint i;\r\nif (!translation_enabled(tbl))\r\nreturn;\r\nfor_each_sg(sglist, s, nelems, i) {\r\nunsigned int npages;\r\ndma_addr_t dma = s->dma_address;\r\nunsigned int dmalen = s->dma_length;\r\nif (dmalen == 0)\r\nbreak;\r\nnpages = iommu_num_pages(dma, dmalen, PAGE_SIZE);\r\niommu_free(tbl, dma, npages);\r\n}\r\n}\r\nstatic int calgary_map_sg(struct device *dev, struct scatterlist *sg,\r\nint nelems, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct iommu_table *tbl = find_iommu_table(dev);\r\nstruct scatterlist *s;\r\nunsigned long vaddr;\r\nunsigned int npages;\r\nunsigned long entry;\r\nint i;\r\nfor_each_sg(sg, s, nelems, i) {\r\nBUG_ON(!sg_page(s));\r\nvaddr = (unsigned long) sg_virt(s);\r\nnpages = iommu_num_pages(vaddr, s->length, PAGE_SIZE);\r\nentry = iommu_range_alloc(dev, tbl, npages);\r\nif (entry == DMA_ERROR_CODE) {\r\ns->dma_length = 0;\r\ngoto error;\r\n}\r\ns->dma_address = (entry << PAGE_SHIFT) | s->offset;\r\ntce_build(tbl, entry, npages, vaddr & PAGE_MASK, dir);\r\ns->dma_length = s->length;\r\n}\r\nreturn nelems;\r\nerror:\r\ncalgary_unmap_sg(dev, sg, nelems, dir, NULL);\r\nfor_each_sg(sg, s, nelems, i) {\r\nsg->dma_address = DMA_ERROR_CODE;\r\nsg->dma_length = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic dma_addr_t calgary_map_page(struct device *dev, struct page *page,\r\nunsigned long offset, size_t size,\r\nenum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nvoid *vaddr = page_address(page) + offset;\r\nunsigned long uaddr;\r\nunsigned int npages;\r\nstruct iommu_table *tbl = find_iommu_table(dev);\r\nuaddr = (unsigned long)vaddr;\r\nnpages = iommu_num_pages(uaddr, size, PAGE_SIZE);\r\nreturn iommu_alloc(dev, tbl, vaddr, npages, dir);\r\n}\r\nstatic void calgary_unmap_page(struct device *dev, dma_addr_t dma_addr,\r\nsize_t size, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nstruct iommu_table *tbl = find_iommu_table(dev);\r\nunsigned int npages;\r\nnpages = iommu_num_pages(dma_addr, size, PAGE_SIZE);\r\niommu_free(tbl, dma_addr, npages);\r\n}\r\nstatic void* calgary_alloc_coherent(struct device *dev, size_t size,\r\ndma_addr_t *dma_handle, gfp_t flag, struct dma_attrs *attrs)\r\n{\r\nvoid *ret = NULL;\r\ndma_addr_t mapping;\r\nunsigned int npages, order;\r\nstruct iommu_table *tbl = find_iommu_table(dev);\r\nsize = PAGE_ALIGN(size);\r\nnpages = size >> PAGE_SHIFT;\r\norder = get_order(size);\r\nflag &= ~(__GFP_DMA | __GFP_HIGHMEM | __GFP_DMA32);\r\nret = (void *)__get_free_pages(flag, order);\r\nif (!ret)\r\ngoto error;\r\nmemset(ret, 0, size);\r\nmapping = iommu_alloc(dev, tbl, ret, npages, DMA_BIDIRECTIONAL);\r\nif (mapping == DMA_ERROR_CODE)\r\ngoto free;\r\n*dma_handle = mapping;\r\nreturn ret;\r\nfree:\r\nfree_pages((unsigned long)ret, get_order(size));\r\nret = NULL;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic void calgary_free_coherent(struct device *dev, size_t size,\r\nvoid *vaddr, dma_addr_t dma_handle,\r\nstruct dma_attrs *attrs)\r\n{\r\nunsigned int npages;\r\nstruct iommu_table *tbl = find_iommu_table(dev);\r\nsize = PAGE_ALIGN(size);\r\nnpages = size >> PAGE_SHIFT;\r\niommu_free(tbl, dma_handle, npages);\r\nfree_pages((unsigned long)vaddr, get_order(size));\r\n}\r\nstatic inline void __iomem * busno_to_bbar(unsigned char num)\r\n{\r\nreturn bus_info[num].bbar;\r\n}\r\nstatic inline int busno_to_phbid(unsigned char num)\r\n{\r\nreturn bus_info[num].phbid;\r\n}\r\nstatic inline unsigned long split_queue_offset(unsigned char num)\r\n{\r\nsize_t idx = busno_to_phbid(num);\r\nreturn split_queue_offsets[idx];\r\n}\r\nstatic inline unsigned long tar_offset(unsigned char num)\r\n{\r\nsize_t idx = busno_to_phbid(num);\r\nreturn tar_offsets[idx];\r\n}\r\nstatic inline unsigned long phb_offset(unsigned char num)\r\n{\r\nsize_t idx = busno_to_phbid(num);\r\nreturn phb_offsets[idx];\r\n}\r\nstatic inline void __iomem* calgary_reg(void __iomem *bar, unsigned long offset)\r\n{\r\nunsigned long target = ((unsigned long)bar) | offset;\r\nreturn (void __iomem*)target;\r\n}\r\nstatic inline int is_calioc2(unsigned short device)\r\n{\r\nreturn (device == PCI_DEVICE_ID_IBM_CALIOC2);\r\n}\r\nstatic inline int is_calgary(unsigned short device)\r\n{\r\nreturn (device == PCI_DEVICE_ID_IBM_CALGARY);\r\n}\r\nstatic inline int is_cal_pci_dev(unsigned short device)\r\n{\r\nreturn (is_calgary(device) || is_calioc2(device));\r\n}\r\nstatic void calgary_tce_cache_blast(struct iommu_table *tbl)\r\n{\r\nu64 val;\r\nu32 aer;\r\nint i = 0;\r\nvoid __iomem *bbar = tbl->bbar;\r\nvoid __iomem *target;\r\ntarget = calgary_reg(bbar, phb_offset(tbl->it_busno) | PHB_AER_OFFSET);\r\naer = readl(target);\r\nwritel(0, target);\r\ntarget = calgary_reg(bbar, phb_offset(tbl->it_busno) | PHB_PLSSR_OFFSET);\r\nval = readl(target);\r\ntarget = calgary_reg(bbar, split_queue_offset(tbl->it_busno));\r\ndo {\r\nval = readq(target);\r\ni++;\r\n} while ((val & 0xff) != 0xff && i < 100);\r\nif (i == 100)\r\npr_warn("PCI bus not quiesced, continuing anyway\n");\r\ntarget = calgary_reg(bbar, tar_offset(tbl->it_busno));\r\nwriteq(tbl->tar_val, target);\r\ntarget = calgary_reg(bbar, phb_offset(tbl->it_busno) | PHB_AER_OFFSET);\r\nwritel(aer, target);\r\n(void)readl(target);\r\n}\r\nstatic void calioc2_tce_cache_blast(struct iommu_table *tbl)\r\n{\r\nvoid __iomem *bbar = tbl->bbar;\r\nvoid __iomem *target;\r\nu64 val64;\r\nu32 val;\r\nint i = 0;\r\nint count = 1;\r\nunsigned char bus = tbl->it_busno;\r\nbegin:\r\nprintk(KERN_DEBUG "Calgary: CalIOC2 bus 0x%x entering tce cache blast "\r\n"sequence - count %d\n", bus, count);\r\ntarget = calgary_reg(bbar, phb_offset(bus) | PHB_PAGE_MIG_CTRL);\r\nval = be32_to_cpu(readl(target));\r\nprintk(KERN_DEBUG "1a. read 0x%x [LE] from %p\n", val, target);\r\nval |= PMR_SOFTSTOP;\r\nprintk(KERN_DEBUG "1b. writing 0x%x [LE] to %p\n", val, target);\r\nwritel(cpu_to_be32(val), target);\r\nprintk(KERN_DEBUG "2a. starting to poll split queues\n");\r\ntarget = calgary_reg(bbar, split_queue_offset(bus));\r\ndo {\r\nval64 = readq(target);\r\ni++;\r\n} while ((val64 & 0xff) != 0xff && i < 100);\r\nif (i == 100)\r\npr_warn("CalIOC2: PCI bus not quiesced, continuing anyway\n");\r\ntarget = calgary_reg(bbar, phb_offset(bus) | PHB_PAGE_MIG_DEBUG);\r\nval = be32_to_cpu(readl(target));\r\nprintk(KERN_DEBUG "3. read 0x%x [LE] from %p\n", val, target);\r\nif (val & PMR_SOFTSTOPFAULT) {\r\nif (++count < 100)\r\ngoto begin;\r\nelse {\r\npr_warn("CalIOC2: too many SoftStopFaults, aborting TCE cache flush sequence!\n");\r\nreturn;\r\n}\r\n}\r\ntarget = calgary_reg(bbar, phb_offset(bus) | PHB_PAGE_MIG_CTRL);\r\nprintk(KERN_DEBUG "5a. slamming into HardStop by reading %p\n", target);\r\nval = be32_to_cpu(readl(target));\r\nprintk(KERN_DEBUG "5b. read 0x%x [LE] from %p\n", val, target);\r\ntarget = calgary_reg(bbar, phb_offset(bus) | PHB_PAGE_MIG_DEBUG);\r\nval = be32_to_cpu(readl(target));\r\nprintk(KERN_DEBUG "5c. read 0x%x [LE] from %p (debug)\n", val, target);\r\nprintk(KERN_DEBUG "6. invalidating TCE cache\n");\r\ntarget = calgary_reg(bbar, tar_offset(bus));\r\nwriteq(tbl->tar_val, target);\r\nprintk(KERN_DEBUG "7a. Re-reading PMCR\n");\r\ntarget = calgary_reg(bbar, phb_offset(bus) | PHB_PAGE_MIG_CTRL);\r\nval = be32_to_cpu(readl(target));\r\nprintk(KERN_DEBUG "7b. read 0x%x [LE] from %p\n", val, target);\r\nprintk(KERN_DEBUG "8a. removing HardStop from PMCR\n");\r\ntarget = calgary_reg(bbar, phb_offset(bus) | PHB_PAGE_MIG_CTRL);\r\nval = 0;\r\nprintk(KERN_DEBUG "8b. writing 0x%x [LE] to %p\n", val, target);\r\nwritel(cpu_to_be32(val), target);\r\nval = be32_to_cpu(readl(target));\r\nprintk(KERN_DEBUG "8c. read 0x%x [LE] from %p\n", val, target);\r\n}\r\nstatic void __init calgary_reserve_mem_region(struct pci_dev *dev, u64 start,\r\nu64 limit)\r\n{\r\nunsigned int numpages;\r\nlimit = limit | 0xfffff;\r\nlimit++;\r\nnumpages = ((limit - start) >> PAGE_SHIFT);\r\niommu_range_reserve(pci_iommu(dev->bus), start, numpages);\r\n}\r\nstatic void __init calgary_reserve_peripheral_mem_1(struct pci_dev *dev)\r\n{\r\nvoid __iomem *target;\r\nu64 low, high, sizelow;\r\nu64 start, limit;\r\nstruct iommu_table *tbl = pci_iommu(dev->bus);\r\nunsigned char busnum = dev->bus->number;\r\nvoid __iomem *bbar = tbl->bbar;\r\ntarget = calgary_reg(bbar, phb_offset(busnum) | PHB_MEM_1_LOW);\r\nlow = be32_to_cpu(readl(target));\r\ntarget = calgary_reg(bbar, phb_offset(busnum) | PHB_MEM_1_HIGH);\r\nhigh = be32_to_cpu(readl(target));\r\ntarget = calgary_reg(bbar, phb_offset(busnum) | PHB_MEM_1_SIZE);\r\nsizelow = be32_to_cpu(readl(target));\r\nstart = (high << 32) | low;\r\nlimit = sizelow;\r\ncalgary_reserve_mem_region(dev, start, limit);\r\n}\r\nstatic void __init calgary_reserve_peripheral_mem_2(struct pci_dev *dev)\r\n{\r\nvoid __iomem *target;\r\nu32 val32;\r\nu64 low, high, sizelow, sizehigh;\r\nu64 start, limit;\r\nstruct iommu_table *tbl = pci_iommu(dev->bus);\r\nunsigned char busnum = dev->bus->number;\r\nvoid __iomem *bbar = tbl->bbar;\r\ntarget = calgary_reg(bbar, phb_offset(busnum) | PHB_CONFIG_RW_OFFSET);\r\nval32 = be32_to_cpu(readl(target));\r\nif (!(val32 & PHB_MEM2_ENABLE))\r\nreturn;\r\ntarget = calgary_reg(bbar, phb_offset(busnum) | PHB_MEM_2_LOW);\r\nlow = be32_to_cpu(readl(target));\r\ntarget = calgary_reg(bbar, phb_offset(busnum) | PHB_MEM_2_HIGH);\r\nhigh = be32_to_cpu(readl(target));\r\ntarget = calgary_reg(bbar, phb_offset(busnum) | PHB_MEM_2_SIZE_LOW);\r\nsizelow = be32_to_cpu(readl(target));\r\ntarget = calgary_reg(bbar, phb_offset(busnum) | PHB_MEM_2_SIZE_HIGH);\r\nsizehigh = be32_to_cpu(readl(target));\r\nstart = (high << 32) | low;\r\nlimit = (sizehigh << 32) | sizelow;\r\ncalgary_reserve_mem_region(dev, start, limit);\r\n}\r\nstatic void __init calgary_reserve_regions(struct pci_dev *dev)\r\n{\r\nunsigned int npages;\r\nu64 start;\r\nstruct iommu_table *tbl = pci_iommu(dev->bus);\r\niommu_range_reserve(tbl, DMA_ERROR_CODE, EMERGENCY_PAGES);\r\nif (is_calgary(dev->device)) {\r\nstart = (640 * 1024);\r\nnpages = ((1024 - 640) * 1024) >> PAGE_SHIFT;\r\n} else {\r\nstart = 0;\r\nnpages = (1 * 1024 * 1024) >> PAGE_SHIFT;\r\n}\r\niommu_range_reserve(tbl, start, npages);\r\ncalgary_reserve_peripheral_mem_1(dev);\r\ncalgary_reserve_peripheral_mem_2(dev);\r\n}\r\nstatic int __init calgary_setup_tar(struct pci_dev *dev, void __iomem *bbar)\r\n{\r\nu64 val64;\r\nu64 table_phys;\r\nvoid __iomem *target;\r\nint ret;\r\nstruct iommu_table *tbl;\r\nret = build_tce_table(dev, bbar);\r\nif (ret)\r\nreturn ret;\r\ntbl = pci_iommu(dev->bus);\r\ntbl->it_base = (unsigned long)bus_info[dev->bus->number].tce_space;\r\nif (is_kdump_kernel())\r\ncalgary_init_bitmap_from_tce_table(tbl);\r\nelse\r\ntce_free(tbl, 0, tbl->it_size);\r\nif (is_calgary(dev->device))\r\ntbl->chip_ops = &calgary_chip_ops;\r\nelse if (is_calioc2(dev->device))\r\ntbl->chip_ops = &calioc2_chip_ops;\r\nelse\r\nBUG();\r\ncalgary_reserve_regions(dev);\r\ntarget = calgary_reg(bbar, tar_offset(dev->bus->number));\r\nval64 = be64_to_cpu(readq(target));\r\nval64 &= ~TAR_SW_BITS;\r\ntable_phys = (u64)__pa(tbl->it_base);\r\nval64 |= table_phys;\r\nBUG_ON(specified_table_size > TCE_TABLE_SIZE_8M);\r\nval64 |= (u64) specified_table_size;\r\ntbl->tar_val = cpu_to_be64(val64);\r\nwriteq(tbl->tar_val, target);\r\nreadq(target);\r\nreturn 0;\r\n}\r\nstatic void __init calgary_free_bus(struct pci_dev *dev)\r\n{\r\nu64 val64;\r\nstruct iommu_table *tbl = pci_iommu(dev->bus);\r\nvoid __iomem *target;\r\nunsigned int bitmapsz;\r\ntarget = calgary_reg(tbl->bbar, tar_offset(dev->bus->number));\r\nval64 = be64_to_cpu(readq(target));\r\nval64 &= ~TAR_SW_BITS;\r\nwriteq(cpu_to_be64(val64), target);\r\nreadq(target);\r\nbitmapsz = tbl->it_size / BITS_PER_BYTE;\r\nfree_pages((unsigned long)tbl->it_map, get_order(bitmapsz));\r\ntbl->it_map = NULL;\r\nkfree(tbl);\r\nset_pci_iommu(dev->bus, NULL);\r\nbus_info[dev->bus->number].tce_space = NULL;\r\n}\r\nstatic void calgary_dump_error_regs(struct iommu_table *tbl)\r\n{\r\nvoid __iomem *bbar = tbl->bbar;\r\nvoid __iomem *target;\r\nu32 csr, plssr;\r\ntarget = calgary_reg(bbar, phb_offset(tbl->it_busno) | PHB_CSR_OFFSET);\r\ncsr = be32_to_cpu(readl(target));\r\ntarget = calgary_reg(bbar, phb_offset(tbl->it_busno) | PHB_PLSSR_OFFSET);\r\nplssr = be32_to_cpu(readl(target));\r\npr_emerg("DMA error on Calgary PHB 0x%x, 0x%08x@CSR 0x%08x@PLSSR\n",\r\ntbl->it_busno, csr, plssr);\r\n}\r\nstatic void calioc2_dump_error_regs(struct iommu_table *tbl)\r\n{\r\nvoid __iomem *bbar = tbl->bbar;\r\nu32 csr, csmr, plssr, mck, rcstat;\r\nvoid __iomem *target;\r\nunsigned long phboff = phb_offset(tbl->it_busno);\r\nunsigned long erroff;\r\nu32 errregs[7];\r\nint i;\r\ntarget = calgary_reg(bbar, phboff | PHB_CSR_OFFSET);\r\ncsr = be32_to_cpu(readl(target));\r\ntarget = calgary_reg(bbar, phboff | PHB_PLSSR_OFFSET);\r\nplssr = be32_to_cpu(readl(target));\r\ntarget = calgary_reg(bbar, phboff | 0x290);\r\ncsmr = be32_to_cpu(readl(target));\r\ntarget = calgary_reg(bbar, phboff | 0x800);\r\nmck = be32_to_cpu(readl(target));\r\npr_emerg("DMA error on CalIOC2 PHB 0x%x\n", tbl->it_busno);\r\npr_emerg("0x%08x@CSR 0x%08x@PLSSR 0x%08x@CSMR 0x%08x@MCK\n",\r\ncsr, plssr, csmr, mck);\r\npr_emerg("");\r\nfor (i = 0; i < ARRAY_SIZE(errregs); i++) {\r\nerroff = (0x810 + (i * 0x10));\r\ntarget = calgary_reg(bbar, phboff | erroff);\r\nerrregs[i] = be32_to_cpu(readl(target));\r\npr_cont("0x%08x@0x%lx ", errregs[i], erroff);\r\n}\r\npr_cont("\n");\r\ntarget = calgary_reg(bbar, phboff | PHB_ROOT_COMPLEX_STATUS);\r\nrcstat = be32_to_cpu(readl(target));\r\nprintk(KERN_EMERG "Calgary: 0x%08x@0x%x\n", rcstat,\r\nPHB_ROOT_COMPLEX_STATUS);\r\n}\r\nstatic void calgary_watchdog(unsigned long data)\r\n{\r\nstruct pci_dev *dev = (struct pci_dev *)data;\r\nstruct iommu_table *tbl = pci_iommu(dev->bus);\r\nvoid __iomem *bbar = tbl->bbar;\r\nu32 val32;\r\nvoid __iomem *target;\r\ntarget = calgary_reg(bbar, phb_offset(tbl->it_busno) | PHB_CSR_OFFSET);\r\nval32 = be32_to_cpu(readl(target));\r\nif (val32 & CSR_AGENT_MASK) {\r\ntbl->chip_ops->dump_error_regs(tbl);\r\nwritel(0, target);\r\ntarget = calgary_reg(bbar, phb_offset(tbl->it_busno) |\r\nPHB_CONFIG_RW_OFFSET);\r\nval32 = be32_to_cpu(readl(target));\r\nval32 |= PHB_SLOT_DISABLE;\r\nwritel(cpu_to_be32(val32), target);\r\nreadl(target);\r\n} else {\r\nmod_timer(&tbl->watchdog_timer, jiffies + 2 * HZ);\r\n}\r\n}\r\nstatic void __init calgary_set_split_completion_timeout(void __iomem *bbar,\r\nunsigned char busnum, unsigned long timeout)\r\n{\r\nu64 val64;\r\nvoid __iomem *target;\r\nunsigned int phb_shift = ~0;\r\nu64 mask;\r\nswitch (busno_to_phbid(busnum)) {\r\ncase 0: phb_shift = (63 - 19);\r\nbreak;\r\ncase 1: phb_shift = (63 - 23);\r\nbreak;\r\ncase 2: phb_shift = (63 - 27);\r\nbreak;\r\ncase 3: phb_shift = (63 - 35);\r\nbreak;\r\ndefault:\r\nBUG_ON(busno_to_phbid(busnum));\r\n}\r\ntarget = calgary_reg(bbar, CALGARY_CONFIG_REG);\r\nval64 = be64_to_cpu(readq(target));\r\nmask = ~(0xFUL << phb_shift);\r\nval64 &= mask;\r\nval64 |= (timeout << phb_shift);\r\nwriteq(cpu_to_be64(val64), target);\r\nreadq(target);\r\n}\r\nstatic void __init calioc2_handle_quirks(struct iommu_table *tbl, struct pci_dev *dev)\r\n{\r\nunsigned char busnum = dev->bus->number;\r\nvoid __iomem *bbar = tbl->bbar;\r\nvoid __iomem *target;\r\nu32 val;\r\ntarget = calgary_reg(bbar, phb_offset(busnum) | PHB_SAVIOR_L2);\r\nval = cpu_to_be32(readl(target));\r\nval |= 0x00800000;\r\nwritel(cpu_to_be32(val), target);\r\n}\r\nstatic void __init calgary_handle_quirks(struct iommu_table *tbl, struct pci_dev *dev)\r\n{\r\nunsigned char busnum = dev->bus->number;\r\nif (is_calgary(dev->device) && (busnum == 1))\r\ncalgary_set_split_completion_timeout(tbl->bbar, busnum,\r\nCCR_2SEC_TIMEOUT);\r\n}\r\nstatic void __init calgary_enable_translation(struct pci_dev *dev)\r\n{\r\nu32 val32;\r\nunsigned char busnum;\r\nvoid __iomem *target;\r\nvoid __iomem *bbar;\r\nstruct iommu_table *tbl;\r\nbusnum = dev->bus->number;\r\ntbl = pci_iommu(dev->bus);\r\nbbar = tbl->bbar;\r\ntarget = calgary_reg(bbar, phb_offset(busnum) | PHB_CONFIG_RW_OFFSET);\r\nval32 = be32_to_cpu(readl(target));\r\nval32 |= PHB_TCE_ENABLE | PHB_DAC_DISABLE | PHB_MCSR_ENABLE;\r\nprintk(KERN_INFO "Calgary: enabling translation on %s PHB %#x\n",\r\n(dev->device == PCI_DEVICE_ID_IBM_CALGARY) ?\r\n"Calgary" : "CalIOC2", busnum);\r\nprintk(KERN_INFO "Calgary: errant DMAs will now be prevented on this "\r\n"bus.\n");\r\nwritel(cpu_to_be32(val32), target);\r\nreadl(target);\r\ninit_timer(&tbl->watchdog_timer);\r\ntbl->watchdog_timer.function = &calgary_watchdog;\r\ntbl->watchdog_timer.data = (unsigned long)dev;\r\nmod_timer(&tbl->watchdog_timer, jiffies);\r\n}\r\nstatic void __init calgary_disable_translation(struct pci_dev *dev)\r\n{\r\nu32 val32;\r\nunsigned char busnum;\r\nvoid __iomem *target;\r\nvoid __iomem *bbar;\r\nstruct iommu_table *tbl;\r\nbusnum = dev->bus->number;\r\ntbl = pci_iommu(dev->bus);\r\nbbar = tbl->bbar;\r\ntarget = calgary_reg(bbar, phb_offset(busnum) | PHB_CONFIG_RW_OFFSET);\r\nval32 = be32_to_cpu(readl(target));\r\nval32 &= ~(PHB_TCE_ENABLE | PHB_DAC_DISABLE | PHB_MCSR_ENABLE);\r\nprintk(KERN_INFO "Calgary: disabling translation on PHB %#x!\n", busnum);\r\nwritel(cpu_to_be32(val32), target);\r\nreadl(target);\r\ndel_timer_sync(&tbl->watchdog_timer);\r\n}\r\nstatic void __init calgary_init_one_nontraslated(struct pci_dev *dev)\r\n{\r\npci_dev_get(dev);\r\nset_pci_iommu(dev->bus, NULL);\r\nif (dev->bus->parent)\r\ndev->bus->parent->self = dev;\r\nelse\r\ndev->bus->self = dev;\r\n}\r\nstatic int __init calgary_init_one(struct pci_dev *dev)\r\n{\r\nvoid __iomem *bbar;\r\nstruct iommu_table *tbl;\r\nint ret;\r\nbbar = busno_to_bbar(dev->bus->number);\r\nret = calgary_setup_tar(dev, bbar);\r\nif (ret)\r\ngoto done;\r\npci_dev_get(dev);\r\nif (dev->bus->parent) {\r\nif (dev->bus->parent->self)\r\nprintk(KERN_WARNING "Calgary: IEEEE, dev %p has "\r\n"bus->parent->self!\n", dev);\r\ndev->bus->parent->self = dev;\r\n} else\r\ndev->bus->self = dev;\r\ntbl = pci_iommu(dev->bus);\r\ntbl->chip_ops->handle_quirks(tbl, dev);\r\ncalgary_enable_translation(dev);\r\nreturn 0;\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int __init calgary_locate_bbars(void)\r\n{\r\nint ret;\r\nint rioidx, phb, bus;\r\nvoid __iomem *bbar;\r\nvoid __iomem *target;\r\nunsigned long offset;\r\nu8 start_bus, end_bus;\r\nu32 val;\r\nret = -ENODATA;\r\nfor (rioidx = 0; rioidx < rio_table_hdr->num_rio_dev; rioidx++) {\r\nstruct rio_detail *rio = rio_devs[rioidx];\r\nif ((rio->type != COMPAT_CALGARY) && (rio->type != ALT_CALGARY))\r\ncontinue;\r\nbbar = ioremap_nocache(rio->BBAR, 1024 * 1024);\r\nif (!bbar)\r\ngoto error;\r\nfor (phb = 0; phb < PHBS_PER_CALGARY; phb++) {\r\noffset = phb_debug_offsets[phb] | PHB_DEBUG_STUFF_OFFSET;\r\ntarget = calgary_reg(bbar, offset);\r\nval = be32_to_cpu(readl(target));\r\nstart_bus = (u8)((val & 0x00FF0000) >> 16);\r\nend_bus = (u8)((val & 0x0000FF00) >> 8);\r\nif (end_bus) {\r\nfor (bus = start_bus; bus <= end_bus; bus++) {\r\nbus_info[bus].bbar = bbar;\r\nbus_info[bus].phbid = phb;\r\n}\r\n} else {\r\nbus_info[start_bus].bbar = bbar;\r\nbus_info[start_bus].phbid = phb;\r\n}\r\n}\r\n}\r\nreturn 0;\r\nerror:\r\nfor (bus = 0; bus < ARRAY_SIZE(bus_info); bus++)\r\nif (bus_info[bus].bbar)\r\niounmap(bus_info[bus].bbar);\r\nreturn ret;\r\n}\r\nstatic int __init calgary_init(void)\r\n{\r\nint ret;\r\nstruct pci_dev *dev = NULL;\r\nstruct calgary_bus_info *info;\r\nret = calgary_locate_bbars();\r\nif (ret)\r\nreturn ret;\r\nif (is_kdump_kernel())\r\nget_tce_space_from_tar();\r\ndo {\r\ndev = pci_get_device(PCI_VENDOR_ID_IBM, PCI_ANY_ID, dev);\r\nif (!dev)\r\nbreak;\r\nif (!is_cal_pci_dev(dev->device))\r\ncontinue;\r\ninfo = &bus_info[dev->bus->number];\r\nif (info->translation_disabled) {\r\ncalgary_init_one_nontraslated(dev);\r\ncontinue;\r\n}\r\nif (!info->tce_space && !translate_empty_slots)\r\ncontinue;\r\nret = calgary_init_one(dev);\r\nif (ret)\r\ngoto error;\r\n} while (1);\r\ndev = NULL;\r\nfor_each_pci_dev(dev) {\r\nstruct iommu_table *tbl;\r\ntbl = find_iommu_table(&dev->dev);\r\nif (translation_enabled(tbl))\r\ndev->dev.archdata.dma_ops = &calgary_dma_ops;\r\n}\r\nreturn ret;\r\nerror:\r\ndo {\r\ndev = pci_get_device(PCI_VENDOR_ID_IBM, PCI_ANY_ID, dev);\r\nif (!dev)\r\nbreak;\r\nif (!is_cal_pci_dev(dev->device))\r\ncontinue;\r\ninfo = &bus_info[dev->bus->number];\r\nif (info->translation_disabled) {\r\npci_dev_put(dev);\r\ncontinue;\r\n}\r\nif (!info->tce_space && !translate_empty_slots)\r\ncontinue;\r\ncalgary_disable_translation(dev);\r\ncalgary_free_bus(dev);\r\npci_dev_put(dev);\r\ndev->dev.archdata.dma_ops = NULL;\r\n} while (1);\r\nreturn ret;\r\n}\r\nstatic inline int __init determine_tce_table_size(u64 ram)\r\n{\r\nint ret;\r\nif (specified_table_size != TCE_TABLE_SIZE_UNSPECIFIED)\r\nreturn specified_table_size;\r\nret = get_order(ram >> 13);\r\nif (ret > TCE_TABLE_SIZE_8M)\r\nret = TCE_TABLE_SIZE_8M;\r\nreturn ret;\r\n}\r\nstatic int __init build_detail_arrays(void)\r\n{\r\nunsigned long ptr;\r\nunsigned numnodes, i;\r\nint scal_detail_size, rio_detail_size;\r\nnumnodes = rio_table_hdr->num_scal_dev;\r\nif (numnodes > MAX_NUMNODES){\r\nprintk(KERN_WARNING\r\n"Calgary: MAX_NUMNODES too low! Defined as %d, "\r\n"but system has %d nodes.\n",\r\nMAX_NUMNODES, numnodes);\r\nreturn -ENODEV;\r\n}\r\nswitch (rio_table_hdr->version){\r\ncase 2:\r\nscal_detail_size = 11;\r\nrio_detail_size = 13;\r\nbreak;\r\ncase 3:\r\nscal_detail_size = 12;\r\nrio_detail_size = 15;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"Calgary: Invalid Rio Grande Table Version: %d\n",\r\nrio_table_hdr->version);\r\nreturn -EPROTO;\r\n}\r\nptr = ((unsigned long)rio_table_hdr) + 3;\r\nfor (i = 0; i < numnodes; i++, ptr += scal_detail_size)\r\nscal_devs[i] = (struct scal_detail *)ptr;\r\nfor (i = 0; i < rio_table_hdr->num_rio_dev;\r\ni++, ptr += rio_detail_size)\r\nrio_devs[i] = (struct rio_detail *)ptr;\r\nreturn 0;\r\n}\r\nstatic int __init calgary_bus_has_devices(int bus, unsigned short pci_dev)\r\n{\r\nint dev;\r\nu32 val;\r\nif (pci_dev == PCI_DEVICE_ID_IBM_CALIOC2) {\r\nreturn 1;\r\n}\r\nfor (dev = 1; dev < 8; dev++) {\r\nval = read_pci_config(bus, dev, 0, 0);\r\nif (val != 0xffffffff)\r\nbreak;\r\n}\r\nreturn (val != 0xffffffff);\r\n}\r\nstatic void calgary_init_bitmap_from_tce_table(struct iommu_table *tbl)\r\n{\r\nu64 *tp;\r\nunsigned int index;\r\ntp = ((u64 *)tbl->it_base);\r\nfor (index = 0 ; index < tbl->it_size; index++) {\r\nif (*tp != 0x0)\r\nset_bit(index, tbl->it_map);\r\ntp++;\r\n}\r\n}\r\nstatic void __init get_tce_space_from_tar(void)\r\n{\r\nint bus;\r\nvoid __iomem *target;\r\nunsigned long tce_space;\r\nfor (bus = 0; bus < MAX_PHB_BUS_NUM; bus++) {\r\nstruct calgary_bus_info *info = &bus_info[bus];\r\nunsigned short pci_device;\r\nu32 val;\r\nval = read_pci_config(bus, 0, 0, 0);\r\npci_device = (val & 0xFFFF0000) >> 16;\r\nif (!is_cal_pci_dev(pci_device))\r\ncontinue;\r\nif (info->translation_disabled)\r\ncontinue;\r\nif (calgary_bus_has_devices(bus, pci_device) ||\r\ntranslate_empty_slots) {\r\ntarget = calgary_reg(bus_info[bus].bbar,\r\ntar_offset(bus));\r\ntce_space = be64_to_cpu(readq(target));\r\ntce_space = tce_space & TAR_SW_BITS;\r\ntce_space = tce_space & (~specified_table_size);\r\ninfo->tce_space = (u64 *)__va(tce_space);\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic int __init calgary_iommu_init(void)\r\n{\r\nint ret;\r\nprintk(KERN_INFO "PCI-DMA: Using Calgary IOMMU\n");\r\nret = calgary_init();\r\nif (ret) {\r\nprintk(KERN_ERR "PCI-DMA: Calgary init failed %d, "\r\n"falling back to no_iommu\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint __init detect_calgary(void)\r\n{\r\nint bus;\r\nvoid *tbl;\r\nint calgary_found = 0;\r\nunsigned long ptr;\r\nunsigned int offset, prev_offset;\r\nint ret;\r\nif (no_iommu || iommu_detected)\r\nreturn -ENODEV;\r\nif (!use_calgary)\r\nreturn -ENODEV;\r\nif (!early_pci_allowed())\r\nreturn -ENODEV;\r\nprintk(KERN_DEBUG "Calgary: detecting Calgary via BIOS EBDA area\n");\r\nptr = (unsigned long)phys_to_virt(get_bios_ebda());\r\nrio_table_hdr = NULL;\r\nprev_offset = 0;\r\noffset = 0x180;\r\nwhile (offset > prev_offset) {\r\nif (*((unsigned short *)(ptr + offset + 2)) == 0x4752){\r\nrio_table_hdr = (struct rio_table_hdr *)(ptr + offset + 4);\r\nbreak;\r\n}\r\nprev_offset = offset;\r\noffset = *((unsigned short *)(ptr + offset));\r\n}\r\nif (!rio_table_hdr) {\r\nprintk(KERN_DEBUG "Calgary: Unable to locate Rio Grande table "\r\n"in EBDA - bailing!\n");\r\nreturn -ENODEV;\r\n}\r\nret = build_detail_arrays();\r\nif (ret) {\r\nprintk(KERN_DEBUG "Calgary: build_detail_arrays ret %d\n", ret);\r\nreturn -ENOMEM;\r\n}\r\nspecified_table_size = determine_tce_table_size((is_kdump_kernel() ?\r\nsaved_max_pfn : max_pfn) * PAGE_SIZE);\r\nfor (bus = 0; bus < MAX_PHB_BUS_NUM; bus++) {\r\nstruct calgary_bus_info *info = &bus_info[bus];\r\nunsigned short pci_device;\r\nu32 val;\r\nval = read_pci_config(bus, 0, 0, 0);\r\npci_device = (val & 0xFFFF0000) >> 16;\r\nif (!is_cal_pci_dev(pci_device))\r\ncontinue;\r\nif (info->translation_disabled)\r\ncontinue;\r\nif (calgary_bus_has_devices(bus, pci_device) ||\r\ntranslate_empty_slots) {\r\nif (!is_kdump_kernel()) {\r\ntbl = alloc_tce_table();\r\nif (!tbl)\r\ngoto cleanup;\r\ninfo->tce_space = tbl;\r\n}\r\ncalgary_found = 1;\r\n}\r\n}\r\nprintk(KERN_DEBUG "Calgary: finished detection, Calgary %s\n",\r\ncalgary_found ? "found" : "not found");\r\nif (calgary_found) {\r\niommu_detected = 1;\r\ncalgary_detected = 1;\r\nprintk(KERN_INFO "PCI-DMA: Calgary IOMMU detected.\n");\r\nprintk(KERN_INFO "PCI-DMA: Calgary TCE table spec is %d\n",\r\nspecified_table_size);\r\nx86_init.iommu.iommu_init = calgary_iommu_init;\r\n}\r\nreturn calgary_found;\r\ncleanup:\r\nfor (--bus; bus >= 0; --bus) {\r\nstruct calgary_bus_info *info = &bus_info[bus];\r\nif (info->tce_space)\r\nfree_tce_table(info->tce_space);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic int __init calgary_parse_options(char *p)\r\n{\r\nunsigned int bridge;\r\nunsigned long val;\r\nsize_t len;\r\nssize_t ret;\r\nwhile (*p) {\r\nif (!strncmp(p, "64k", 3))\r\nspecified_table_size = TCE_TABLE_SIZE_64K;\r\nelse if (!strncmp(p, "128k", 4))\r\nspecified_table_size = TCE_TABLE_SIZE_128K;\r\nelse if (!strncmp(p, "256k", 4))\r\nspecified_table_size = TCE_TABLE_SIZE_256K;\r\nelse if (!strncmp(p, "512k", 4))\r\nspecified_table_size = TCE_TABLE_SIZE_512K;\r\nelse if (!strncmp(p, "1M", 2))\r\nspecified_table_size = TCE_TABLE_SIZE_1M;\r\nelse if (!strncmp(p, "2M", 2))\r\nspecified_table_size = TCE_TABLE_SIZE_2M;\r\nelse if (!strncmp(p, "4M", 2))\r\nspecified_table_size = TCE_TABLE_SIZE_4M;\r\nelse if (!strncmp(p, "8M", 2))\r\nspecified_table_size = TCE_TABLE_SIZE_8M;\r\nlen = strlen("translate_empty_slots");\r\nif (!strncmp(p, "translate_empty_slots", len))\r\ntranslate_empty_slots = 1;\r\nlen = strlen("disable");\r\nif (!strncmp(p, "disable", len)) {\r\np += len;\r\nif (*p == '=')\r\n++p;\r\nif (*p == '\0')\r\nbreak;\r\nret = kstrtoul(p, 0, &val);\r\nif (ret)\r\nbreak;\r\nbridge = val;\r\nif (bridge < MAX_PHB_BUS_NUM) {\r\nprintk(KERN_INFO "Calgary: disabling "\r\n"translation for PHB %#x\n", bridge);\r\nbus_info[bridge].translation_disabled = 1;\r\n}\r\n}\r\np = strpbrk(p, ",");\r\nif (!p)\r\nbreak;\r\np++;\r\n}\r\nreturn 1;\r\n}\r\nstatic void __init calgary_fixup_one_tce_space(struct pci_dev *dev)\r\n{\r\nstruct iommu_table *tbl;\r\nunsigned int npages;\r\nint i;\r\ntbl = pci_iommu(dev->bus);\r\nfor (i = 0; i < 4; i++) {\r\nstruct resource *r = &dev->resource[PCI_BRIDGE_RESOURCES + i];\r\nif (!(r->flags & IORESOURCE_MEM))\r\ncontinue;\r\nif (!r->start)\r\ncontinue;\r\nnpages = resource_size(r) >> PAGE_SHIFT;\r\nnpages++;\r\niommu_range_reserve(tbl, r->start, npages);\r\n}\r\n}\r\nstatic int __init calgary_fixup_tce_spaces(void)\r\n{\r\nstruct pci_dev *dev = NULL;\r\nstruct calgary_bus_info *info;\r\nif (no_iommu || swiotlb || !calgary_detected)\r\nreturn -ENODEV;\r\nprintk(KERN_DEBUG "Calgary: fixing up tce spaces\n");\r\ndo {\r\ndev = pci_get_device(PCI_VENDOR_ID_IBM, PCI_ANY_ID, dev);\r\nif (!dev)\r\nbreak;\r\nif (!is_cal_pci_dev(dev->device))\r\ncontinue;\r\ninfo = &bus_info[dev->bus->number];\r\nif (info->translation_disabled)\r\ncontinue;\r\nif (!info->tce_space)\r\ncontinue;\r\ncalgary_fixup_one_tce_space(dev);\r\n} while (1);\r\nreturn 0;\r\n}
