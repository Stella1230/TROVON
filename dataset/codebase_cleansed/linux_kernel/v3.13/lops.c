void gfs2_pin(struct gfs2_sbd *sdp, struct buffer_head *bh)\r\n{\r\nstruct gfs2_bufdata *bd;\r\nBUG_ON(!current->journal_info);\r\nclear_buffer_dirty(bh);\r\nif (test_set_buffer_pinned(bh))\r\ngfs2_assert_withdraw(sdp, 0);\r\nif (!buffer_uptodate(bh))\r\ngfs2_io_error_bh(sdp, bh);\r\nbd = bh->b_private;\r\nspin_lock(&sdp->sd_ail_lock);\r\nif (bd->bd_tr)\r\nlist_move(&bd->bd_ail_st_list, &bd->bd_tr->tr_ail2_list);\r\nspin_unlock(&sdp->sd_ail_lock);\r\nget_bh(bh);\r\natomic_inc(&sdp->sd_log_pinned);\r\ntrace_gfs2_pin(bd, 1);\r\n}\r\nstatic bool buffer_is_rgrp(const struct gfs2_bufdata *bd)\r\n{\r\nreturn bd->bd_gl->gl_name.ln_type == LM_TYPE_RGRP;\r\n}\r\nstatic void maybe_release_space(struct gfs2_bufdata *bd)\r\n{\r\nstruct gfs2_glock *gl = bd->bd_gl;\r\nstruct gfs2_sbd *sdp = gl->gl_sbd;\r\nstruct gfs2_rgrpd *rgd = gl->gl_object;\r\nunsigned int index = bd->bd_bh->b_blocknr - gl->gl_name.ln_number;\r\nstruct gfs2_bitmap *bi = rgd->rd_bits + index;\r\nif (bi->bi_clone == 0)\r\nreturn;\r\nif (sdp->sd_args.ar_discard)\r\ngfs2_rgrp_send_discards(sdp, rgd->rd_data0, bd->bd_bh, bi, 1, NULL);\r\nmemcpy(bi->bi_clone + bi->bi_offset,\r\nbd->bd_bh->b_data + bi->bi_offset, bi->bi_len);\r\nclear_bit(GBF_FULL, &bi->bi_flags);\r\nrgd->rd_free_clone = rgd->rd_free;\r\n}\r\nstatic void gfs2_unpin(struct gfs2_sbd *sdp, struct buffer_head *bh,\r\nstruct gfs2_trans *tr)\r\n{\r\nstruct gfs2_bufdata *bd = bh->b_private;\r\nBUG_ON(!buffer_uptodate(bh));\r\nBUG_ON(!buffer_pinned(bh));\r\nlock_buffer(bh);\r\nmark_buffer_dirty(bh);\r\nclear_buffer_pinned(bh);\r\nif (buffer_is_rgrp(bd))\r\nmaybe_release_space(bd);\r\nspin_lock(&sdp->sd_ail_lock);\r\nif (bd->bd_tr) {\r\nlist_del(&bd->bd_ail_st_list);\r\nbrelse(bh);\r\n} else {\r\nstruct gfs2_glock *gl = bd->bd_gl;\r\nlist_add(&bd->bd_ail_gl_list, &gl->gl_ail_list);\r\natomic_inc(&gl->gl_ail_count);\r\n}\r\nbd->bd_tr = tr;\r\nlist_add(&bd->bd_ail_st_list, &tr->tr_ail1_list);\r\nspin_unlock(&sdp->sd_ail_lock);\r\nclear_bit(GLF_LFLUSH, &bd->bd_gl->gl_flags);\r\ntrace_gfs2_pin(bd, 0);\r\nunlock_buffer(bh);\r\natomic_dec(&sdp->sd_log_pinned);\r\n}\r\nstatic void gfs2_log_incr_head(struct gfs2_sbd *sdp)\r\n{\r\nBUG_ON((sdp->sd_log_flush_head == sdp->sd_log_tail) &&\r\n(sdp->sd_log_flush_head != sdp->sd_log_head));\r\nif (++sdp->sd_log_flush_head == sdp->sd_jdesc->jd_blocks) {\r\nsdp->sd_log_flush_head = 0;\r\nsdp->sd_log_flush_wrapped = 1;\r\n}\r\n}\r\nstatic u64 gfs2_log_bmap(struct gfs2_sbd *sdp)\r\n{\r\nunsigned int lbn = sdp->sd_log_flush_head;\r\nstruct gfs2_journal_extent *je;\r\nu64 block;\r\nlist_for_each_entry(je, &sdp->sd_jdesc->extent_list, extent_list) {\r\nif (lbn >= je->lblock && lbn < je->lblock + je->blocks) {\r\nblock = je->dblock + lbn - je->lblock;\r\ngfs2_log_incr_head(sdp);\r\nreturn block;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic void gfs2_end_log_write_bh(struct gfs2_sbd *sdp, struct bio_vec *bvec,\r\nint error)\r\n{\r\nstruct buffer_head *bh, *next;\r\nstruct page *page = bvec->bv_page;\r\nunsigned size;\r\nbh = page_buffers(page);\r\nsize = bvec->bv_len;\r\nwhile (bh_offset(bh) < bvec->bv_offset)\r\nbh = bh->b_this_page;\r\ndo {\r\nif (error)\r\nset_buffer_write_io_error(bh);\r\nunlock_buffer(bh);\r\nnext = bh->b_this_page;\r\nsize -= bh->b_size;\r\nbrelse(bh);\r\nbh = next;\r\n} while(bh && size);\r\n}\r\nstatic void gfs2_end_log_write(struct bio *bio, int error)\r\n{\r\nstruct gfs2_sbd *sdp = bio->bi_private;\r\nstruct bio_vec *bvec;\r\nstruct page *page;\r\nint i;\r\nif (error) {\r\nsdp->sd_log_error = error;\r\nfs_err(sdp, "Error %d writing to log\n", error);\r\n}\r\nbio_for_each_segment_all(bvec, bio, i) {\r\npage = bvec->bv_page;\r\nif (page_has_buffers(page))\r\ngfs2_end_log_write_bh(sdp, bvec, error);\r\nelse\r\nmempool_free(page, gfs2_page_pool);\r\n}\r\nbio_put(bio);\r\nif (atomic_dec_and_test(&sdp->sd_log_in_flight))\r\nwake_up(&sdp->sd_log_flush_wait);\r\n}\r\nvoid gfs2_log_flush_bio(struct gfs2_sbd *sdp, int rw)\r\n{\r\nif (sdp->sd_log_bio) {\r\natomic_inc(&sdp->sd_log_in_flight);\r\nsubmit_bio(rw, sdp->sd_log_bio);\r\nsdp->sd_log_bio = NULL;\r\n}\r\n}\r\nstatic struct bio *gfs2_log_alloc_bio(struct gfs2_sbd *sdp, u64 blkno)\r\n{\r\nstruct super_block *sb = sdp->sd_vfs;\r\nunsigned nrvecs = bio_get_nr_vecs(sb->s_bdev);\r\nstruct bio *bio;\r\nBUG_ON(sdp->sd_log_bio);\r\nwhile (1) {\r\nbio = bio_alloc(GFP_NOIO, nrvecs);\r\nif (likely(bio))\r\nbreak;\r\nnrvecs = max(nrvecs/2, 1U);\r\n}\r\nbio->bi_sector = blkno * (sb->s_blocksize >> 9);\r\nbio->bi_bdev = sb->s_bdev;\r\nbio->bi_end_io = gfs2_end_log_write;\r\nbio->bi_private = sdp;\r\nsdp->sd_log_bio = bio;\r\nreturn bio;\r\n}\r\nstatic struct bio *gfs2_log_get_bio(struct gfs2_sbd *sdp, u64 blkno)\r\n{\r\nstruct bio *bio = sdp->sd_log_bio;\r\nu64 nblk;\r\nif (bio) {\r\nnblk = bio_end_sector(bio);\r\nnblk >>= sdp->sd_fsb2bb_shift;\r\nif (blkno == nblk)\r\nreturn bio;\r\ngfs2_log_flush_bio(sdp, WRITE);\r\n}\r\nreturn gfs2_log_alloc_bio(sdp, blkno);\r\n}\r\nstatic void gfs2_log_write(struct gfs2_sbd *sdp, struct page *page,\r\nunsigned size, unsigned offset)\r\n{\r\nu64 blkno = gfs2_log_bmap(sdp);\r\nstruct bio *bio;\r\nint ret;\r\nbio = gfs2_log_get_bio(sdp, blkno);\r\nret = bio_add_page(bio, page, size, offset);\r\nif (ret == 0) {\r\ngfs2_log_flush_bio(sdp, WRITE);\r\nbio = gfs2_log_alloc_bio(sdp, blkno);\r\nret = bio_add_page(bio, page, size, offset);\r\nWARN_ON(ret == 0);\r\n}\r\n}\r\nstatic void gfs2_log_write_bh(struct gfs2_sbd *sdp, struct buffer_head *bh)\r\n{\r\ngfs2_log_write(sdp, bh->b_page, bh->b_size, bh_offset(bh));\r\n}\r\nvoid gfs2_log_write_page(struct gfs2_sbd *sdp, struct page *page)\r\n{\r\nstruct super_block *sb = sdp->sd_vfs;\r\ngfs2_log_write(sdp, page, sb->s_blocksize, 0);\r\n}\r\nstatic struct page *gfs2_get_log_desc(struct gfs2_sbd *sdp, u32 ld_type,\r\nu32 ld_length, u32 ld_data1)\r\n{\r\nstruct page *page = mempool_alloc(gfs2_page_pool, GFP_NOIO);\r\nstruct gfs2_log_descriptor *ld = page_address(page);\r\nclear_page(ld);\r\nld->ld_header.mh_magic = cpu_to_be32(GFS2_MAGIC);\r\nld->ld_header.mh_type = cpu_to_be32(GFS2_METATYPE_LD);\r\nld->ld_header.mh_format = cpu_to_be32(GFS2_FORMAT_LD);\r\nld->ld_type = cpu_to_be32(ld_type);\r\nld->ld_length = cpu_to_be32(ld_length);\r\nld->ld_data1 = cpu_to_be32(ld_data1);\r\nld->ld_data2 = 0;\r\nreturn page;\r\n}\r\nstatic void gfs2_check_magic(struct buffer_head *bh)\r\n{\r\nvoid *kaddr;\r\n__be32 *ptr;\r\nclear_buffer_escaped(bh);\r\nkaddr = kmap_atomic(bh->b_page);\r\nptr = kaddr + bh_offset(bh);\r\nif (*ptr == cpu_to_be32(GFS2_MAGIC))\r\nset_buffer_escaped(bh);\r\nkunmap_atomic(kaddr);\r\n}\r\nstatic int blocknr_cmp(void *priv, struct list_head *a, struct list_head *b)\r\n{\r\nstruct gfs2_bufdata *bda, *bdb;\r\nbda = list_entry(a, struct gfs2_bufdata, bd_list);\r\nbdb = list_entry(b, struct gfs2_bufdata, bd_list);\r\nif (bda->bd_bh->b_blocknr < bdb->bd_bh->b_blocknr)\r\nreturn -1;\r\nif (bda->bd_bh->b_blocknr > bdb->bd_bh->b_blocknr)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void gfs2_before_commit(struct gfs2_sbd *sdp, unsigned int limit,\r\nunsigned int total, struct list_head *blist,\r\nbool is_databuf)\r\n{\r\nstruct gfs2_log_descriptor *ld;\r\nstruct gfs2_bufdata *bd1 = NULL, *bd2;\r\nstruct page *page;\r\nunsigned int num;\r\nunsigned n;\r\n__be64 *ptr;\r\ngfs2_log_lock(sdp);\r\nlist_sort(NULL, blist, blocknr_cmp);\r\nbd1 = bd2 = list_prepare_entry(bd1, blist, bd_list);\r\nwhile(total) {\r\nnum = total;\r\nif (total > limit)\r\nnum = limit;\r\ngfs2_log_unlock(sdp);\r\npage = gfs2_get_log_desc(sdp,\r\nis_databuf ? GFS2_LOG_DESC_JDATA :\r\nGFS2_LOG_DESC_METADATA, num + 1, num);\r\nld = page_address(page);\r\ngfs2_log_lock(sdp);\r\nptr = (__be64 *)(ld + 1);\r\nn = 0;\r\nlist_for_each_entry_continue(bd1, blist, bd_list) {\r\n*ptr++ = cpu_to_be64(bd1->bd_bh->b_blocknr);\r\nif (is_databuf) {\r\ngfs2_check_magic(bd1->bd_bh);\r\n*ptr++ = cpu_to_be64(buffer_escaped(bd1->bd_bh) ? 1 : 0);\r\n}\r\nif (++n >= num)\r\nbreak;\r\n}\r\ngfs2_log_unlock(sdp);\r\ngfs2_log_write_page(sdp, page);\r\ngfs2_log_lock(sdp);\r\nn = 0;\r\nlist_for_each_entry_continue(bd2, blist, bd_list) {\r\nget_bh(bd2->bd_bh);\r\ngfs2_log_unlock(sdp);\r\nlock_buffer(bd2->bd_bh);\r\nif (buffer_escaped(bd2->bd_bh)) {\r\nvoid *kaddr;\r\npage = mempool_alloc(gfs2_page_pool, GFP_NOIO);\r\nptr = page_address(page);\r\nkaddr = kmap_atomic(bd2->bd_bh->b_page);\r\nmemcpy(ptr, kaddr + bh_offset(bd2->bd_bh),\r\nbd2->bd_bh->b_size);\r\nkunmap_atomic(kaddr);\r\n*(__be32 *)ptr = 0;\r\nclear_buffer_escaped(bd2->bd_bh);\r\nunlock_buffer(bd2->bd_bh);\r\nbrelse(bd2->bd_bh);\r\ngfs2_log_write_page(sdp, page);\r\n} else {\r\ngfs2_log_write_bh(sdp, bd2->bd_bh);\r\n}\r\ngfs2_log_lock(sdp);\r\nif (++n >= num)\r\nbreak;\r\n}\r\nBUG_ON(total < num);\r\ntotal -= num;\r\n}\r\ngfs2_log_unlock(sdp);\r\n}\r\nstatic void buf_lo_before_commit(struct gfs2_sbd *sdp)\r\n{\r\nunsigned int limit = buf_limit(sdp);\r\ngfs2_before_commit(sdp, limit, sdp->sd_log_num_buf,\r\n&sdp->sd_log_le_buf, 0);\r\n}\r\nstatic void buf_lo_after_commit(struct gfs2_sbd *sdp, struct gfs2_trans *tr)\r\n{\r\nstruct list_head *head = &sdp->sd_log_le_buf;\r\nstruct gfs2_bufdata *bd;\r\nif (tr == NULL) {\r\ngfs2_assert(sdp, list_empty(head));\r\nreturn;\r\n}\r\nwhile (!list_empty(head)) {\r\nbd = list_entry(head->next, struct gfs2_bufdata, bd_list);\r\nlist_del_init(&bd->bd_list);\r\nsdp->sd_log_num_buf--;\r\ngfs2_unpin(sdp, bd->bd_bh, tr);\r\n}\r\ngfs2_assert_warn(sdp, !sdp->sd_log_num_buf);\r\n}\r\nstatic void buf_lo_before_scan(struct gfs2_jdesc *jd,\r\nstruct gfs2_log_header_host *head, int pass)\r\n{\r\nstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\r\nif (pass != 0)\r\nreturn;\r\nsdp->sd_found_blocks = 0;\r\nsdp->sd_replayed_blocks = 0;\r\n}\r\nstatic int buf_lo_scan_elements(struct gfs2_jdesc *jd, unsigned int start,\r\nstruct gfs2_log_descriptor *ld, __be64 *ptr,\r\nint pass)\r\n{\r\nstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\r\nstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\r\nstruct gfs2_glock *gl = ip->i_gl;\r\nunsigned int blks = be32_to_cpu(ld->ld_data1);\r\nstruct buffer_head *bh_log, *bh_ip;\r\nu64 blkno;\r\nint error = 0;\r\nif (pass != 1 || be32_to_cpu(ld->ld_type) != GFS2_LOG_DESC_METADATA)\r\nreturn 0;\r\ngfs2_replay_incr_blk(sdp, &start);\r\nfor (; blks; gfs2_replay_incr_blk(sdp, &start), blks--) {\r\nblkno = be64_to_cpu(*ptr++);\r\nsdp->sd_found_blocks++;\r\nif (gfs2_revoke_check(sdp, blkno, start))\r\ncontinue;\r\nerror = gfs2_replay_read_block(jd, start, &bh_log);\r\nif (error)\r\nreturn error;\r\nbh_ip = gfs2_meta_new(gl, blkno);\r\nmemcpy(bh_ip->b_data, bh_log->b_data, bh_log->b_size);\r\nif (gfs2_meta_check(sdp, bh_ip))\r\nerror = -EIO;\r\nelse\r\nmark_buffer_dirty(bh_ip);\r\nbrelse(bh_log);\r\nbrelse(bh_ip);\r\nif (error)\r\nbreak;\r\nsdp->sd_replayed_blocks++;\r\n}\r\nreturn error;\r\n}\r\nstatic void gfs2_meta_sync(struct gfs2_glock *gl)\r\n{\r\nstruct address_space *mapping = gfs2_glock2aspace(gl);\r\nint error;\r\nfilemap_fdatawrite(mapping);\r\nerror = filemap_fdatawait(mapping);\r\nif (error)\r\ngfs2_io_error(gl->gl_sbd);\r\n}\r\nstatic void buf_lo_after_scan(struct gfs2_jdesc *jd, int error, int pass)\r\n{\r\nstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\r\nstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\r\nif (error) {\r\ngfs2_meta_sync(ip->i_gl);\r\nreturn;\r\n}\r\nif (pass != 1)\r\nreturn;\r\ngfs2_meta_sync(ip->i_gl);\r\nfs_info(sdp, "jid=%u: Replayed %u of %u blocks\n",\r\njd->jd_jid, sdp->sd_replayed_blocks, sdp->sd_found_blocks);\r\n}\r\nstatic void revoke_lo_before_commit(struct gfs2_sbd *sdp)\r\n{\r\nstruct gfs2_meta_header *mh;\r\nunsigned int offset;\r\nstruct list_head *head = &sdp->sd_log_le_revoke;\r\nstruct gfs2_bufdata *bd;\r\nstruct page *page;\r\nunsigned int length;\r\ngfs2_write_revokes(sdp);\r\nif (!sdp->sd_log_num_revoke)\r\nreturn;\r\nlength = gfs2_struct2blk(sdp, sdp->sd_log_num_revoke, sizeof(u64));\r\npage = gfs2_get_log_desc(sdp, GFS2_LOG_DESC_REVOKE, length, sdp->sd_log_num_revoke);\r\noffset = sizeof(struct gfs2_log_descriptor);\r\nlist_for_each_entry(bd, head, bd_list) {\r\nsdp->sd_log_num_revoke--;\r\nif (offset + sizeof(u64) > sdp->sd_sb.sb_bsize) {\r\ngfs2_log_write_page(sdp, page);\r\npage = mempool_alloc(gfs2_page_pool, GFP_NOIO);\r\nmh = page_address(page);\r\nclear_page(mh);\r\nmh->mh_magic = cpu_to_be32(GFS2_MAGIC);\r\nmh->mh_type = cpu_to_be32(GFS2_METATYPE_LB);\r\nmh->mh_format = cpu_to_be32(GFS2_FORMAT_LB);\r\noffset = sizeof(struct gfs2_meta_header);\r\n}\r\n*(__be64 *)(page_address(page) + offset) = cpu_to_be64(bd->bd_blkno);\r\noffset += sizeof(u64);\r\n}\r\ngfs2_assert_withdraw(sdp, !sdp->sd_log_num_revoke);\r\ngfs2_log_write_page(sdp, page);\r\n}\r\nstatic void revoke_lo_after_commit(struct gfs2_sbd *sdp, struct gfs2_trans *tr)\r\n{\r\nstruct list_head *head = &sdp->sd_log_le_revoke;\r\nstruct gfs2_bufdata *bd;\r\nstruct gfs2_glock *gl;\r\nwhile (!list_empty(head)) {\r\nbd = list_entry(head->next, struct gfs2_bufdata, bd_list);\r\nlist_del_init(&bd->bd_list);\r\ngl = bd->bd_gl;\r\natomic_dec(&gl->gl_revokes);\r\nclear_bit(GLF_LFLUSH, &gl->gl_flags);\r\nkmem_cache_free(gfs2_bufdata_cachep, bd);\r\n}\r\n}\r\nstatic void revoke_lo_before_scan(struct gfs2_jdesc *jd,\r\nstruct gfs2_log_header_host *head, int pass)\r\n{\r\nstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\r\nif (pass != 0)\r\nreturn;\r\nsdp->sd_found_revokes = 0;\r\nsdp->sd_replay_tail = head->lh_tail;\r\n}\r\nstatic int revoke_lo_scan_elements(struct gfs2_jdesc *jd, unsigned int start,\r\nstruct gfs2_log_descriptor *ld, __be64 *ptr,\r\nint pass)\r\n{\r\nstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\r\nunsigned int blks = be32_to_cpu(ld->ld_length);\r\nunsigned int revokes = be32_to_cpu(ld->ld_data1);\r\nstruct buffer_head *bh;\r\nunsigned int offset;\r\nu64 blkno;\r\nint first = 1;\r\nint error;\r\nif (pass != 0 || be32_to_cpu(ld->ld_type) != GFS2_LOG_DESC_REVOKE)\r\nreturn 0;\r\noffset = sizeof(struct gfs2_log_descriptor);\r\nfor (; blks; gfs2_replay_incr_blk(sdp, &start), blks--) {\r\nerror = gfs2_replay_read_block(jd, start, &bh);\r\nif (error)\r\nreturn error;\r\nif (!first)\r\ngfs2_metatype_check(sdp, bh, GFS2_METATYPE_LB);\r\nwhile (offset + sizeof(u64) <= sdp->sd_sb.sb_bsize) {\r\nblkno = be64_to_cpu(*(__be64 *)(bh->b_data + offset));\r\nerror = gfs2_revoke_add(sdp, blkno, start);\r\nif (error < 0) {\r\nbrelse(bh);\r\nreturn error;\r\n}\r\nelse if (error)\r\nsdp->sd_found_revokes++;\r\nif (!--revokes)\r\nbreak;\r\noffset += sizeof(u64);\r\n}\r\nbrelse(bh);\r\noffset = sizeof(struct gfs2_meta_header);\r\nfirst = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void revoke_lo_after_scan(struct gfs2_jdesc *jd, int error, int pass)\r\n{\r\nstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\r\nif (error) {\r\ngfs2_revoke_clean(sdp);\r\nreturn;\r\n}\r\nif (pass != 1)\r\nreturn;\r\nfs_info(sdp, "jid=%u: Found %u revoke tags\n",\r\njd->jd_jid, sdp->sd_found_revokes);\r\ngfs2_revoke_clean(sdp);\r\n}\r\nstatic void databuf_lo_before_commit(struct gfs2_sbd *sdp)\r\n{\r\nunsigned int limit = buf_limit(sdp) / 2;\r\ngfs2_before_commit(sdp, limit, sdp->sd_log_num_databuf,\r\n&sdp->sd_log_le_databuf, 1);\r\n}\r\nstatic int databuf_lo_scan_elements(struct gfs2_jdesc *jd, unsigned int start,\r\nstruct gfs2_log_descriptor *ld,\r\n__be64 *ptr, int pass)\r\n{\r\nstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\r\nstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\r\nstruct gfs2_glock *gl = ip->i_gl;\r\nunsigned int blks = be32_to_cpu(ld->ld_data1);\r\nstruct buffer_head *bh_log, *bh_ip;\r\nu64 blkno;\r\nu64 esc;\r\nint error = 0;\r\nif (pass != 1 || be32_to_cpu(ld->ld_type) != GFS2_LOG_DESC_JDATA)\r\nreturn 0;\r\ngfs2_replay_incr_blk(sdp, &start);\r\nfor (; blks; gfs2_replay_incr_blk(sdp, &start), blks--) {\r\nblkno = be64_to_cpu(*ptr++);\r\nesc = be64_to_cpu(*ptr++);\r\nsdp->sd_found_blocks++;\r\nif (gfs2_revoke_check(sdp, blkno, start))\r\ncontinue;\r\nerror = gfs2_replay_read_block(jd, start, &bh_log);\r\nif (error)\r\nreturn error;\r\nbh_ip = gfs2_meta_new(gl, blkno);\r\nmemcpy(bh_ip->b_data, bh_log->b_data, bh_log->b_size);\r\nif (esc) {\r\n__be32 *eptr = (__be32 *)bh_ip->b_data;\r\n*eptr = cpu_to_be32(GFS2_MAGIC);\r\n}\r\nmark_buffer_dirty(bh_ip);\r\nbrelse(bh_log);\r\nbrelse(bh_ip);\r\nsdp->sd_replayed_blocks++;\r\n}\r\nreturn error;\r\n}\r\nstatic void databuf_lo_after_scan(struct gfs2_jdesc *jd, int error, int pass)\r\n{\r\nstruct gfs2_inode *ip = GFS2_I(jd->jd_inode);\r\nstruct gfs2_sbd *sdp = GFS2_SB(jd->jd_inode);\r\nif (error) {\r\ngfs2_meta_sync(ip->i_gl);\r\nreturn;\r\n}\r\nif (pass != 1)\r\nreturn;\r\ngfs2_meta_sync(ip->i_gl);\r\nfs_info(sdp, "jid=%u: Replayed %u of %u data blocks\n",\r\njd->jd_jid, sdp->sd_replayed_blocks, sdp->sd_found_blocks);\r\n}\r\nstatic void databuf_lo_after_commit(struct gfs2_sbd *sdp, struct gfs2_trans *tr)\r\n{\r\nstruct list_head *head = &sdp->sd_log_le_databuf;\r\nstruct gfs2_bufdata *bd;\r\nif (tr == NULL) {\r\ngfs2_assert(sdp, list_empty(head));\r\nreturn;\r\n}\r\nwhile (!list_empty(head)) {\r\nbd = list_entry(head->next, struct gfs2_bufdata, bd_list);\r\nlist_del_init(&bd->bd_list);\r\nsdp->sd_log_num_databuf--;\r\ngfs2_unpin(sdp, bd->bd_bh, tr);\r\n}\r\ngfs2_assert_warn(sdp, !sdp->sd_log_num_databuf);\r\n}
