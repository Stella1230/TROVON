static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct addi_private *devpriv = dev->private;\r\nint i_PatternPolarity = 0, i_PatternTransition = 0, i_PatternMask = 0;\r\nint i_MaxChannel = 0, i_Count = 0, i_EventMask = 0;\r\nint i_PatternTransitionCount = 0, i_RegValue;\r\nint i;\r\noutb(APCI1500_RW_MASTER_INTERRUPT_CONTROL,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x00, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\nif (data[0] == 1) {\r\ni_MaxChannel = 8;\r\n}\r\nelse {\r\nif (data[0] == 2) {\r\ni_MaxChannel = 6;\r\n}\r\nelse {\r\nprintk("\nThe specified port event does not exist\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nswitch (data[1]) {\r\ncase 0:\r\ndata[1] = APCI1500_AND;\r\nbreak;\r\ncase 1:\r\ndata[1] = APCI1500_OR;\r\nbreak;\r\ncase 2:\r\ndata[1] = APCI1500_OR_PRIORITY;\r\nbreak;\r\ndefault:\r\nprintk("\nThe specified interrupt logic does not exist\n");\r\nreturn -EINVAL;\r\n}\r\ni_Logic = data[1];\r\nfor (i_Count = i_MaxChannel, i = 0; i_Count > 0; i_Count--, i++) {\r\ni_EventMask = data[2 + i];\r\nswitch (i_EventMask) {\r\ncase 0:\r\ni_PatternMask =\r\ni_PatternMask | (1 << (i_MaxChannel - i_Count));\r\nbreak;\r\ncase 1:\r\ni_PatternMask =\r\ni_PatternMask | (1 << (i_MaxChannel - i_Count));\r\ni_PatternPolarity =\r\ni_PatternPolarity | (1 << (i_MaxChannel -\r\ni_Count));\r\nbreak;\r\ncase 2:\r\ni_PatternMask =\r\ni_PatternMask | (1 << (i_MaxChannel - i_Count));\r\ni_PatternTransition =\r\ni_PatternTransition | (1 << (i_MaxChannel -\r\ni_Count));\r\nbreak;\r\ncase 3:\r\ni_PatternMask =\r\ni_PatternMask | (1 << (i_MaxChannel - i_Count));\r\ni_PatternPolarity =\r\ni_PatternPolarity | (1 << (i_MaxChannel -\r\ni_Count));\r\ni_PatternTransition =\r\ni_PatternTransition | (1 << (i_MaxChannel -\r\ni_Count));\r\nbreak;\r\ncase 4:\r\ni_PatternTransition =\r\ni_PatternTransition | (1 << (i_MaxChannel -\r\ni_Count));\r\nbreak;\r\ncase 5:\r\nbreak;\r\ndefault:\r\nprintk("\nThe option indicated in the event mask does not exist\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (data[0] == 1) {\r\nif (data[1] == APCI1500_AND ||\r\ndata[1] == APCI1500_OR ||\r\ndata[1] == APCI1500_OR_PRIORITY) {\r\nif (data[1] == APCI1500_OR_PRIORITY\r\n&& i_PatternTransition != 0) {\r\nprintk("\nTransition error on an OR PRIORITY logic\n");\r\nreturn -EINVAL;\r\n}\r\nif (data[1] == APCI1500_AND) {\r\nfor (i_Count = 0; i_Count < 8; i_Count++) {\r\ni_PatternTransitionCount =\r\ni_PatternTransitionCount +\r\n((i_PatternTransition >>\r\ni_Count) & 0x1);\r\n}\r\nif (i_PatternTransitionCount > 1) {\r\nprintk("\n Transition error on an AND logic\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xF0,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_PATTERN_POLARITY,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_PatternPolarity,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_PATTERN_MASK,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_PatternMask,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_PATTERN_TRANSITION,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_PatternTransition,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_SPECIFICATION,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue =\r\ninb(devpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_SPECIFICATION,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = (i_RegValue & 0xF9) | data[1] | 0x9;\r\noutb(i_RegValue,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_Event1Status = 1;\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xF4,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\n}\r\nelse {\r\nprintk("\nThe choice for interrupt logic does not exist\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (data[0] == 2) {\r\nif (data[1] == APCI1500_OR) {\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x74,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_SPECIFICATION,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue =\r\ninb(devpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_SPECIFICATION,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = i_RegValue & 0xF9;\r\noutb(i_RegValue,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_PatternMask = (i_PatternMask | 0xC0);\r\ni_PatternPolarity = (i_PatternPolarity | 0xC0);\r\ni_PatternTransition = (i_PatternTransition | 0xC0);\r\noutb(APCI1500_RW_PORT_B_PATTERN_POLARITY,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_PatternPolarity,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_PATTERN_TRANSITION,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_PatternTransition,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_PATTERN_MASK,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_PatternMask,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_SPECIFICATION,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue =\r\ninb(devpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_SPECIFICATION,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = (i_RegValue & 0xF9) | 4;\r\noutb(i_RegValue,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_Event2Status = 1;\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xF4,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\n}\r\nelse {\r\nprintk("\nThe choice for interrupt logic does not exist\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int i_APCI1500_StartStopInputEvent(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct addi_private *devpriv = dev->private;\r\nint i_Event1InterruptStatus = 0, i_Event2InterruptStatus =\r\n0, i_RegValue;\r\nswitch (data[0]) {\r\ncase START:\r\nif (data[1] == 1 || data[1] == 2) {\r\nif (data[1] == 1) {\r\nif (i_Event1Status == 1) {\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xF0,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_COMMAND_AND_STATUS, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xC0,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xF4,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_Event1InterruptStatus = 1;\r\noutb(APCI1500_RW_PORT_A_SPECIFICATION,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue =\r\ninb(devpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_MASTER_INTERRUPT_CONTROL, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xD0,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\n}\r\nelse {\r\nprintk("\nEvent 1 not initialised\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (data[1] == 2) {\r\nif (i_Event2Status == 1) {\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x74,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xC0,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xF4,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_MASTER_INTERRUPT_CONTROL, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xD0,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_Event2InterruptStatus = 1;\r\n}\r\nelse {\r\nprintk("\nEvent 2 not initialised\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nelse {\r\nprintk("\nThe port parameter is in error\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase STOP:\r\nif (data[1] == 1 || data[1] == 2) {\r\nif (data[1] == 1) {\r\nif (i_Event1Status == 1) {\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xF0,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_COMMAND_AND_STATUS, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xE0,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xF4,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_Event1InterruptStatus = 0;\r\n}\r\nelse {\r\nprintk("\nEvent 1 not initialised\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (data[1] == 2) {\r\nif (i_Event2Status == 1) {\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x74,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xE0,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xF4,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_Event2InterruptStatus = 0;\r\n}\r\nelse {\r\nprintk("\nEvent 2 not initialised\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nelse {\r\nprintk("\nThe port parameter is in error\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nprintk("\nThe option of START/STOP logic does not exist\n");\r\nreturn -EINVAL;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int i_APCI1500_Initialisation(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct addi_private *devpriv = dev->private;\r\nint i_DummyRead = 0;\r\ni_DummyRead = inb(devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_DummyRead = inb(devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(1, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xF4, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_SPECIFICATION,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x10, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_DATA_PCITCH_POLARITY,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xFF, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_DATA_DIRECTION,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xFF, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_COMMAND_AND_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x20, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_COMMAND_AND_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xE0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_HANDSHAKE_SPECIFICATION,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_SPECIFICATION,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x10, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_DATA_PCITCH_POLARITY,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x7F, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_DATA_DIRECTION,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xFF, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x20, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xE0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_HANDSHAKE_SPECIFICATION,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_C_DATA_PCITCH_POLARITY,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x9, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_C_DATA_DIRECTION,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x0E, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_C_SPECIAL_IO_CONTROL,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR1_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x20, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR1_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xE0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR2_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x20, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR2_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xE0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR3_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x20, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR3_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xE0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_MASTER_INTERRUPT_CONTROL,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\nreturn insn->n;\r\n}\r\nstatic int apci1500_di_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct addi_private *devpriv = dev->private;\r\ndata[1] = inw(devpriv->i_IobaseAddon + APCI1500_DIGITAL_IP);\r\nreturn insn->n;\r\n}\r\nstatic int i_APCI1500_ConfigDigitalOutputErrorInterrupt(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct addi_private *devpriv = dev->private;\r\ndevpriv->b_OutputMemoryStatus = data[0];\r\nreturn insn->n;\r\n}\r\nstatic int i_APCI1500_WriteDigitalOutput(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct addi_private *devpriv = dev->private;\r\nstatic unsigned int ui_Temp = 0;\r\nunsigned int ui_Temp1;\r\nunsigned int ui_NoOfChannel = CR_CHAN(insn->chanspec);\r\nif (!devpriv->b_OutputMemoryStatus) {\r\nui_Temp = 0;\r\n}\r\nif (data[3] == 0) {\r\nif (data[1] == 0) {\r\ndata[0] = (data[0] << ui_NoOfChannel) | ui_Temp;\r\noutw(data[0],\r\ndevpriv->i_IobaseAddon + APCI1500_DIGITAL_OP);\r\n}\r\nelse {\r\nif (data[1] == 1) {\r\nswitch (ui_NoOfChannel) {\r\ncase 2:\r\ndata[0] =\r\n(data[0] << (2 *\r\ndata[2])) | ui_Temp;\r\nbreak;\r\ncase 4:\r\ndata[0] =\r\n(data[0] << (4 *\r\ndata[2])) | ui_Temp;\r\nbreak;\r\ncase 8:\r\ndata[0] =\r\n(data[0] << (8 *\r\ndata[2])) | ui_Temp;\r\nbreak;\r\ncase 15:\r\ndata[0] = data[0] | ui_Temp;\r\nbreak;\r\ndefault:\r\ncomedi_error(dev, " chan spec wrong");\r\nreturn -EINVAL;\r\n}\r\noutw(data[0],\r\ndevpriv->i_IobaseAddon +\r\nAPCI1500_DIGITAL_OP);\r\n}\r\nelse {\r\nprintk("\nSpecified channel not supported\n");\r\n}\r\n}\r\n}\r\nelse {\r\nif (data[3] == 1) {\r\nif (data[1] == 0) {\r\ndata[0] = ~data[0] & 0x1;\r\nui_Temp1 = 1;\r\nui_Temp1 = ui_Temp1 << ui_NoOfChannel;\r\nui_Temp = ui_Temp | ui_Temp1;\r\ndata[0] =\r\n(data[0] << ui_NoOfChannel) ^\r\n0xffffffff;\r\ndata[0] = data[0] & ui_Temp;\r\noutw(data[0],\r\ndevpriv->i_IobaseAddon +\r\nAPCI1500_DIGITAL_OP);\r\n}\r\nelse {\r\nif (data[1] == 1) {\r\nswitch (ui_NoOfChannel) {\r\ncase 2:\r\ndata[0] = ~data[0] & 0x3;\r\nui_Temp1 = 3;\r\nui_Temp1 =\r\nui_Temp1 << 2 * data[2];\r\nui_Temp = ui_Temp | ui_Temp1;\r\ndata[0] =\r\n((data[0] << (2 *\r\ndata\r\n[2])) ^\r\n0xffffffff) & ui_Temp;\r\nbreak;\r\ncase 4:\r\ndata[0] = ~data[0] & 0xf;\r\nui_Temp1 = 15;\r\nui_Temp1 =\r\nui_Temp1 << 4 * data[2];\r\nui_Temp = ui_Temp | ui_Temp1;\r\ndata[0] =\r\n((data[0] << (4 *\r\ndata\r\n[2])) ^\r\n0xffffffff) & ui_Temp;\r\nbreak;\r\ncase 8:\r\ndata[0] = ~data[0] & 0xff;\r\nui_Temp1 = 255;\r\nui_Temp1 =\r\nui_Temp1 << 8 * data[2];\r\nui_Temp = ui_Temp | ui_Temp1;\r\ndata[0] =\r\n((data[0] << (8 *\r\ndata\r\n[2])) ^\r\n0xffffffff) & ui_Temp;\r\nbreak;\r\ncase 15:\r\nbreak;\r\ndefault:\r\ncomedi_error(dev,\r\n" chan spec wrong");\r\nreturn -EINVAL;\r\n}\r\noutw(data[0],\r\ndevpriv->i_IobaseAddon +\r\nAPCI1500_DIGITAL_OP);\r\n}\r\nelse {\r\nprintk("\nSpecified channel not supported\n");\r\n}\r\n}\r\n}\r\nelse {\r\nprintk("\nSpecified functionality does not exist\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nui_Temp = data[0];\r\nreturn insn->n;\r\n}\r\nstatic int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct addi_private *devpriv = dev->private;\r\nint i_TimerCounterMode, i_MasterConfiguration;\r\ndevpriv->tsk_Current = current;\r\nif (data[0] == 0 || data[0] == 1 || data[0] == 2) {\r\noutw(data[0], devpriv->i_IobaseAddon + APCI1500_CLK_SELECT);\r\n}\r\nelse {\r\nif (data[0] != 3) {\r\nprintk("\nThe option for input clock selection does not exist\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nswitch (data[1]) {\r\ncase COUNTER1:\r\nswitch (data[2]) {\r\ncase 0:\r\ndata[2] = APCI1500_COUNTER;\r\nbreak;\r\ncase 1:\r\ndata[2] = APCI1500_TIMER;\r\nbreak;\r\ndefault:\r\nprintk("\nThis choice is not a timer nor a counter\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (data[4]) {\r\ncase 0:\r\ndata[4] = APCI1500_CONTINUOUS;\r\nbreak;\r\ncase 1:\r\ndata[4] = APCI1500_SINGLE;\r\nbreak;\r\ndefault:\r\nprintk("\nThis option for single/continuous mode does not exist\n");\r\nreturn -EINVAL;\r\n}\r\ni_TimerCounterMode = data[2] | data[4] | 7;\r\nif ((data[3] >= 0) && (data[3] <= 65535)) {\r\nif (data[7] == APCI1500_ENABLE\r\n|| data[7] == APCI1500_DISABLE) {\r\noutb(APCI1500_RW_CPT_TMR1_MODE_SPECIFICATION,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_TimerCounterMode,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR1_TIME_CST_LOW,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(data[3],\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR1_TIME_CST_HIGH,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ndata[3] = data[3] >> 8;\r\noutb(data[3],\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_MasterConfiguration =\r\ninb(devpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_MasterConfiguration =\r\ni_MasterConfiguration | 0x40;\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_MasterConfiguration,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR1_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x0,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR1_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x2,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\n}\r\nelse {\r\nprintk("\nError in selection of interrupt enable or disable\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nelse {\r\nprintk("\nError in selection of reload value\n");\r\nreturn -EINVAL;\r\n}\r\ni_TimerCounterWatchdogInterrupt = data[7];\r\ni_TimerCounter1Init = 1;\r\nbreak;\r\ncase COUNTER2:\r\nswitch (data[2]) {\r\ncase 0:\r\ndata[2] = APCI1500_COUNTER;\r\nbreak;\r\ncase 1:\r\ndata[2] = APCI1500_TIMER;\r\nbreak;\r\ndefault:\r\nprintk("\nThis choice is not a timer nor a counter\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (data[4]) {\r\ncase 0:\r\ndata[4] = APCI1500_CONTINUOUS;\r\nbreak;\r\ncase 1:\r\ndata[4] = APCI1500_SINGLE;\r\nbreak;\r\ndefault:\r\nprintk("\nThis option for single/continuous mode does not exist\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (data[5]) {\r\ncase 0:\r\ndata[5] = APCI1500_SOFTWARE_TRIGGER;\r\nbreak;\r\ncase 1:\r\ndata[5] = APCI1500_HARDWARE_TRIGGER;\r\nbreak;\r\ndefault:\r\nprintk("\nThis choice for software or hardware trigger does not exist\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (data[6]) {\r\ncase 0:\r\ndata[6] = APCI1500_SOFTWARE_GATE;\r\nbreak;\r\ncase 1:\r\ndata[6] = APCI1500_HARDWARE_GATE;\r\nbreak;\r\ndefault:\r\nprintk("\nThis choice for software or hardware gate does not exist\n");\r\nreturn -EINVAL;\r\n}\r\ni_TimerCounterMode = data[2] | data[4] | data[5] | data[6] | 7;\r\nif ((data[3] >= 0) && (data[3] <= 65535)) {\r\nif (data[7] == APCI1500_ENABLE\r\n|| data[7] == APCI1500_DISABLE) {\r\noutb(APCI1500_RW_CPT_TMR2_MODE_SPECIFICATION,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_TimerCounterMode,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR2_TIME_CST_LOW,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(data[3],\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR2_TIME_CST_HIGH,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ndata[3] = data[3] >> 8;\r\noutb(data[3],\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_MasterConfiguration =\r\ninb(devpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_MasterConfiguration =\r\ni_MasterConfiguration | 0x20;\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_MasterConfiguration,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR2_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x0,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR2_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x2,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\n}\r\nelse {\r\nprintk("\nError in selection of interrupt enable or disable\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nelse {\r\nprintk("\nError in selection of reload value\n");\r\nreturn -EINVAL;\r\n}\r\ni_TimerCounterWatchdogInterrupt = data[7];\r\ni_TimerCounter2Init = 1;\r\nbreak;\r\ncase COUNTER3:\r\nswitch (data[2]) {\r\ncase 0:\r\ndata[2] = APCI1500_COUNTER;\r\nbreak;\r\ncase 1:\r\ndata[2] = APCI1500_WATCHDOG;\r\nbreak;\r\ndefault:\r\nprintk("\nThis choice is not a watchdog nor a counter\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (data[4]) {\r\ncase 0:\r\ndata[4] = APCI1500_CONTINUOUS;\r\nbreak;\r\ncase 1:\r\ndata[4] = APCI1500_SINGLE;\r\nbreak;\r\ndefault:\r\nprintk("\nThis option for single/continuous mode does not exist\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (data[6]) {\r\ncase 0:\r\ndata[6] = APCI1500_SOFTWARE_GATE;\r\nbreak;\r\ncase 1:\r\ndata[6] = APCI1500_HARDWARE_GATE;\r\nbreak;\r\ndefault:\r\nprintk("\nThis choice for software or hardware gate does not exist\n");\r\nreturn -EINVAL;\r\n}\r\nif (data[2] == APCI1500_WATCHDOG) {\r\ni_TimerCounterMode = data[2] | data[4] | 0x54;\r\n}\r\nelse {\r\ni_TimerCounterMode = data[2] | data[4] | data[6] | 7;\r\n}\r\nif ((data[3] >= 0) && (data[3] <= 65535)) {\r\nif (data[7] == APCI1500_ENABLE\r\n|| data[7] == APCI1500_DISABLE) {\r\noutb(APCI1500_RW_CPT_TMR3_MODE_SPECIFICATION,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_TimerCounterMode,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR3_TIME_CST_LOW,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(data[3],\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR3_TIME_CST_HIGH,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ndata[3] = data[3] >> 8;\r\noutb(data[3],\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_MasterConfiguration =\r\ninb(devpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_MasterConfiguration =\r\ni_MasterConfiguration | 0x10;\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_MasterConfiguration,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\nif (data[2] == APCI1500_COUNTER) {\r\noutb(APCI1500_RW_CPT_TMR3_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x0,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR3_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x2,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\n}\r\n}\r\nelse {\r\nprintk("\nError in selection of interrupt enable or disable\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nelse {\r\nprintk("\nError in selection of reload value\n");\r\nreturn -EINVAL;\r\n}\r\ni_TimerCounterWatchdogInterrupt = data[7];\r\ni_WatchdogCounter3Init = 1;\r\nbreak;\r\ndefault:\r\nprintk("\nThe specified counter\timer option does not exist\n");\r\n}\r\ni_CounterLogic = data[2];\r\nreturn insn->n;\r\n}\r\nstatic int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct addi_private *devpriv = dev->private;\r\nint i_CommandAndStatusValue;\r\nswitch (data[0]) {\r\ncase COUNTER1:\r\nswitch (data[1]) {\r\ncase START:\r\nif (i_TimerCounter1Init == 1) {\r\nif (i_TimerCounterWatchdogInterrupt == 1) {\r\ni_CommandAndStatusValue = 0xC4;\r\n}\r\nelse {\r\ni_CommandAndStatusValue = 0xE4;\r\n}\r\ni_TimerCounter1Enabled = 1;\r\noutb(APCI1500_RW_CPT_TMR1_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_CommandAndStatusValue,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\n}\r\nelse {\r\nprintk("\nCounter/Timer1 not configured\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase STOP:\r\noutb(APCI1500_RW_CPT_TMR1_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x00,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_TimerCounter1Enabled = 0;\r\nbreak;\r\ncase TRIGGER:\r\nif (i_TimerCounter1Init == 1) {\r\nif (i_TimerCounter1Enabled == 1) {\r\ni_CommandAndStatusValue = 0x6;\r\n}\r\nelse {\r\ni_CommandAndStatusValue = 0x2;\r\n}\r\noutb(APCI1500_RW_CPT_TMR1_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_CommandAndStatusValue,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\n}\r\nelse {\r\nprintk("\nCounter/Timer1 not configured\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nprintk("\nThe specified option for start/stop/trigger does not exist\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase COUNTER2:\r\nswitch (data[1]) {\r\ncase START:\r\nif (i_TimerCounter2Init == 1) {\r\nif (i_TimerCounterWatchdogInterrupt == 1) {\r\ni_CommandAndStatusValue = 0xC4;\r\n}\r\nelse {\r\ni_CommandAndStatusValue = 0xE4;\r\n}\r\ni_TimerCounter2Enabled = 1;\r\noutb(APCI1500_RW_CPT_TMR2_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_CommandAndStatusValue,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\n}\r\nelse {\r\nprintk("\nCounter/Timer2 not configured\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase STOP:\r\noutb(APCI1500_RW_CPT_TMR2_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x00,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_TimerCounter2Enabled = 0;\r\nbreak;\r\ncase TRIGGER:\r\nif (i_TimerCounter2Init == 1) {\r\nif (i_TimerCounter2Enabled == 1) {\r\ni_CommandAndStatusValue = 0x6;\r\n}\r\nelse {\r\ni_CommandAndStatusValue = 0x2;\r\n}\r\noutb(APCI1500_RW_CPT_TMR2_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_CommandAndStatusValue,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\n}\r\nelse {\r\nprintk("\nCounter/Timer2 not configured\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nprintk("\nThe specified option for start/stop/trigger does not exist\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase COUNTER3:\r\nswitch (data[1]) {\r\ncase START:\r\nif (i_WatchdogCounter3Init == 1) {\r\nif (i_TimerCounterWatchdogInterrupt == 1) {\r\ni_CommandAndStatusValue = 0xC4;\r\n}\r\nelse {\r\ni_CommandAndStatusValue = 0xE4;\r\n}\r\ni_WatchdogCounter3Enabled = 1;\r\noutb(APCI1500_RW_CPT_TMR3_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_CommandAndStatusValue,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\n}\r\nelse {\r\nprintk("\nWatchdog/Counter3 not configured\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase STOP:\r\noutb(APCI1500_RW_CPT_TMR3_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x00,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_WatchdogCounter3Enabled = 0;\r\nbreak;\r\ncase TRIGGER:\r\nswitch (data[2]) {\r\ncase 0:\r\nif (i_WatchdogCounter3Init == 1) {\r\nif (i_WatchdogCounter3Enabled == 1) {\r\ni_CommandAndStatusValue = 0x6;\r\n}\r\nelse {\r\ni_CommandAndStatusValue = 0x2;\r\n}\r\noutb(APCI1500_RW_CPT_TMR3_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_CommandAndStatusValue,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\n}\r\nelse {\r\nprintk("\nCounter3 not configured\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 1:\r\nif (i_WatchdogCounter3Init == 1) {\r\noutb(APCI1500_RW_CPT_TMR3_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x6,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\n}\r\nelse {\r\nprintk("\nWatchdog 3 not configured\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nprintk("\nWrong choice of watchdog/counter3\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nprintk("\nThe specified option for start/stop/trigger does not exist\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nprintk("\nThe specified choice for counter/watchdog/timer does not exist\n");\r\nreturn -EINVAL;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int i_APCI1500_ReadCounterTimerWatchdog(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct addi_private *devpriv = dev->private;\r\nint i_CommandAndStatusValue;\r\nswitch (data[0]) {\r\ncase COUNTER1:\r\nif (i_TimerCounter1Init == 1) {\r\nif (i_TimerCounter1Enabled == 1) {\r\ni_CommandAndStatusValue = 0xC;\r\n}\r\nelse {\r\ni_CommandAndStatusValue = 0x8;\r\n}\r\noutb(APCI1500_RW_CPT_TMR1_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_CommandAndStatusValue,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_R_CPT_TMR1_VALUE_HIGH,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ndata[0] =\r\ninb(devpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ndata[0] = data[0] << 8;\r\ndata[0] = data[0] & 0xff00;\r\noutb(APCI1500_R_CPT_TMR1_VALUE_LOW,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ndata[0] =\r\ndata[0] | inb(devpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\n}\r\nelse {\r\nprintk("\nTimer/Counter1 not configured\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase COUNTER2:\r\nif (i_TimerCounter2Init == 1) {\r\nif (i_TimerCounter2Enabled == 1) {\r\ni_CommandAndStatusValue = 0xC;\r\n}\r\nelse {\r\ni_CommandAndStatusValue = 0x8;\r\n}\r\noutb(APCI1500_RW_CPT_TMR2_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_CommandAndStatusValue,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_R_CPT_TMR2_VALUE_HIGH,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ndata[0] =\r\ninb(devpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ndata[0] = data[0] << 8;\r\ndata[0] = data[0] & 0xff00;\r\noutb(APCI1500_R_CPT_TMR2_VALUE_LOW,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ndata[0] =\r\ndata[0] | inb(devpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\n}\r\nelse {\r\nprintk("\nTimer/Counter2 not configured\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase COUNTER3:\r\nif (i_WatchdogCounter3Init == 1) {\r\nif (i_WatchdogCounter3Enabled == 1) {\r\ni_CommandAndStatusValue = 0xC;\r\n}\r\nelse {\r\ni_CommandAndStatusValue = 0x8;\r\n}\r\noutb(APCI1500_RW_CPT_TMR3_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_CommandAndStatusValue,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_R_CPT_TMR3_VALUE_HIGH,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ndata[0] =\r\ninb(devpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ndata[0] = data[0] << 8;\r\ndata[0] = data[0] & 0xff00;\r\noutb(APCI1500_R_CPT_TMR3_VALUE_LOW,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ndata[0] =\r\ndata[0] | inb(devpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\n}\r\nelse {\r\nprintk("\nWatchdogCounter3 not configured\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nprintk("\nThe choice of timer/counter/watchdog does not exist\n");\r\nreturn -EINVAL;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int i_APCI1500_ReadInterruptMask(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ndata[0] = i_InterruptMask;\r\ndata[1] = i_InputChannel;\r\ni_InterruptMask = 0;\r\nreturn insn->n;\r\n}\r\nstatic int i_APCI1500_ConfigureInterrupt(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct addi_private *devpriv = dev->private;\r\nunsigned int ui_Status;\r\nint i_RegValue;\r\nint i_Constant;\r\ndevpriv->tsk_Current = current;\r\noutl(0x0, devpriv->i_IobaseAmcc + 0x38);\r\nif (data[0] == 1) {\r\ni_Constant = 0xC0;\r\n}\r\nelse {\r\nif (data[0] == 0) {\r\ni_Constant = 0x00;\r\n}\r\nelse {\r\nprintk("\nThe parameter passed to driver is in error for enabling the voltage interrupt\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\noutb(APCI1500_RW_PORT_B_SPECIFICATION,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = inb(devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_SPECIFICATION,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = (i_RegValue & 0xF9) | APCI1500_OR;\r\noutb(i_RegValue, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xC0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_PATTERN_POLARITY,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_Constant, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_PATTERN_TRANSITION,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_Constant, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_PATTERN_MASK,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(i_Constant, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_COMMAND_AND_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = inb(devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_COMMAND_AND_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = (i_RegValue & 0x0F) | 0x20;\r\noutb(i_RegValue, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = inb(devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = (i_RegValue & 0x0F) | 0x20;\r\noutb(i_RegValue, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR1_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = inb(devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR1_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = (i_RegValue & 0x0F) | 0x20;\r\noutb(i_RegValue, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR2_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = inb(devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR2_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = (i_RegValue & 0x0F) | 0x20;\r\noutb(i_RegValue, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR3_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = inb(devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR3_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = (i_RegValue & 0x0F) | 0x20;\r\noutb(i_RegValue, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_MASTER_INTERRUPT_CONTROL,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xD0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutl(0x3000, devpriv->i_IobaseAmcc + 0x38);\r\nui_Status = inl(devpriv->i_IobaseAmcc + 0x10);\r\nui_Status = inl(devpriv->i_IobaseAmcc + 0x38);\r\noutl(0x23000, devpriv->i_IobaseAmcc + 0x38);\r\nreturn insn->n;\r\n}\r\nstatic void v_APCI1500_Interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct addi_private *devpriv = dev->private;\r\nunsigned int ui_InterruptStatus = 0;\r\nint i_RegValue = 0;\r\ni_InterruptMask = 0;\r\nui_InterruptStatus = inl(devpriv->i_IobaseAmcc + 0x38);\r\nif ((ui_InterruptStatus & 0x800000) == 0x800000) {\r\noutb(APCI1500_RW_PORT_A_COMMAND_AND_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue =\r\ninb(devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\nif ((i_RegValue & 0x60) == 0x60) {\r\noutb(APCI1500_RW_PORT_A_COMMAND_AND_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = (i_RegValue & 0x0F) | 0x20;\r\noutb(i_RegValue,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_InterruptMask = i_InterruptMask | 1;\r\nif (i_Logic == APCI1500_OR_PRIORITY) {\r\noutb(APCI1500_RW_PORT_A_SPECIFICATION,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue =\r\ninb(devpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_INTERRUPT_CONTROL,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue =\r\ninb(devpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_InputChannel = 1 + (i_RegValue >> 1);\r\n}\r\nelse {\r\ni_InputChannel = 0;\r\n}\r\n}\r\noutb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue =\r\ninb(devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\nif ((i_RegValue & 0x60) == 0x60) {\r\noutb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = (i_RegValue & 0x0F) | 0x20;\r\noutb(i_RegValue,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\nprintk("\n\n\n");\r\ni_RegValue =\r\ninb((unsigned int) devpriv->iobase +\r\nAPCI1500_Z8536_PORT_B);\r\ni_RegValue = i_RegValue & 0xC0;\r\nif (i_RegValue) {\r\noutl(0x0, devpriv->i_IobaseAmcc + 0x38);\r\nif (i_RegValue & 0x80) {\r\ni_InterruptMask =\r\ni_InterruptMask | 0x40;\r\n}\r\nif (i_RegValue & 0x40) {\r\ni_InterruptMask =\r\ni_InterruptMask | 0x80;\r\n}\r\n}\r\nelse {\r\ni_InterruptMask = i_InterruptMask | 2;\r\n}\r\n}\r\noutb(APCI1500_RW_CPT_TMR1_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue =\r\ninb(devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\nif ((i_RegValue & 0x60) == 0x60) {\r\noutb(APCI1500_RW_CPT_TMR1_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = (i_RegValue & 0x0F) | 0x20;\r\noutb(i_RegValue,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_InterruptMask = i_InterruptMask | 4;\r\n}\r\noutb(APCI1500_RW_CPT_TMR2_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue =\r\ninb(devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\nif ((i_RegValue & 0x60) == 0x60) {\r\noutb(APCI1500_RW_CPT_TMR2_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = (i_RegValue & 0x0F) | 0x20;\r\noutb(i_RegValue,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_InterruptMask = i_InterruptMask | 8;\r\n}\r\noutb(APCI1500_RW_CPT_TMR3_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue =\r\ninb(devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\nif ((i_RegValue & 0x60) == 0x60) {\r\noutb(APCI1500_RW_CPT_TMR3_CMD_STATUS,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\ni_RegValue = (i_RegValue & 0x0F) | 0x20;\r\noutb(i_RegValue,\r\ndevpriv->iobase +\r\nAPCI1500_Z8536_CONTROL_REGISTER);\r\nif (i_CounterLogic == APCI1500_COUNTER) {\r\ni_InterruptMask = i_InterruptMask | 0x10;\r\n}\r\nelse {\r\ni_InterruptMask = i_InterruptMask | 0x20;\r\n}\r\n}\r\nsend_sig(SIGIO, devpriv->tsk_Current, 0);\r\noutb(APCI1500_RW_MASTER_INTERRUPT_CONTROL,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xD0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\n}\r\nelse {\r\nprintk("\nInterrupt from unknown source\n");\r\n}\r\nreturn;\r\n}\r\nstatic int i_APCI1500_Reset(struct comedi_device *dev)\r\n{\r\nstruct addi_private *devpriv = dev->private;\r\nint i_DummyRead = 0;\r\ni_TimerCounter1Init = 0;\r\ni_TimerCounter2Init = 0;\r\ni_WatchdogCounter3Init = 0;\r\ni_Event1Status = 0;\r\ni_Event2Status = 0;\r\ni_TimerCounterWatchdogInterrupt = 0;\r\ni_Logic = 0;\r\ni_CounterLogic = 0;\r\ni_InterruptMask = 0;\r\ni_InputChannel = 0;\r\ni_TimerCounter1Enabled = 0;\r\ni_TimerCounter2Enabled = 0;\r\ni_WatchdogCounter3Enabled = 0;\r\ni_DummyRead = inb(devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\ni_DummyRead = inb(devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(1, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xF4, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_SPECIFICATION,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x10, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_DATA_PCITCH_POLARITY,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xFF, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_DATA_DIRECTION,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xFF, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_COMMAND_AND_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x20, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_COMMAND_AND_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xE0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_HANDSHAKE_SPECIFICATION,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_SPECIFICATION,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x10, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_DATA_PCITCH_POLARITY,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x7F, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_DATA_DIRECTION,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xFF, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x20, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xE0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_HANDSHAKE_SPECIFICATION,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_C_DATA_PCITCH_POLARITY,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x9, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_C_DATA_DIRECTION,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x0E, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_C_SPECIAL_IO_CONTROL,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR1_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x20, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR1_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xE0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR2_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x20, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR2_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xE0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR3_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x20, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR3_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0xE0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_MASTER_INTERRUPT_CONTROL,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutw(0x0, devpriv->i_IobaseAddon + APCI1500_DIGITAL_OP);\r\noutb(APCI1500_RW_MASTER_INTERRUPT_CONTROL,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_A_COMMAND_AND_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x00, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x00, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR1_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x00, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR2_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x00, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(APCI1500_RW_CPT_TMR3_CMD_STATUS,\r\ndevpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\noutb(0x00, devpriv->iobase + APCI1500_Z8536_CONTROL_REGISTER);\r\nreturn 0;\r\n}
