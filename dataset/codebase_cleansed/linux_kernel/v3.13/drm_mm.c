static void drm_mm_insert_helper(struct drm_mm_node *hole_node,\r\nstruct drm_mm_node *node,\r\nunsigned long size, unsigned alignment,\r\nunsigned long color)\r\n{\r\nstruct drm_mm *mm = hole_node->mm;\r\nunsigned long hole_start = drm_mm_hole_node_start(hole_node);\r\nunsigned long hole_end = drm_mm_hole_node_end(hole_node);\r\nunsigned long adj_start = hole_start;\r\nunsigned long adj_end = hole_end;\r\nBUG_ON(node->allocated);\r\nif (mm->color_adjust)\r\nmm->color_adjust(hole_node, color, &adj_start, &adj_end);\r\nif (alignment) {\r\nunsigned tmp = adj_start % alignment;\r\nif (tmp)\r\nadj_start += alignment - tmp;\r\n}\r\nif (adj_start == hole_start) {\r\nhole_node->hole_follows = 0;\r\nlist_del(&hole_node->hole_stack);\r\n}\r\nnode->start = adj_start;\r\nnode->size = size;\r\nnode->mm = mm;\r\nnode->color = color;\r\nnode->allocated = 1;\r\nINIT_LIST_HEAD(&node->hole_stack);\r\nlist_add(&node->node_list, &hole_node->node_list);\r\nBUG_ON(node->start + node->size > adj_end);\r\nnode->hole_follows = 0;\r\nif (__drm_mm_hole_node_start(node) < hole_end) {\r\nlist_add(&node->hole_stack, &mm->hole_stack);\r\nnode->hole_follows = 1;\r\n}\r\n}\r\nint drm_mm_reserve_node(struct drm_mm *mm, struct drm_mm_node *node)\r\n{\r\nstruct drm_mm_node *hole;\r\nunsigned long end = node->start + node->size;\r\nunsigned long hole_start;\r\nunsigned long hole_end;\r\nBUG_ON(node == NULL);\r\ndrm_mm_for_each_hole(hole, mm, hole_start, hole_end) {\r\nif (hole_start > node->start || hole_end < end)\r\ncontinue;\r\nnode->mm = mm;\r\nnode->allocated = 1;\r\nINIT_LIST_HEAD(&node->hole_stack);\r\nlist_add(&node->node_list, &hole->node_list);\r\nif (node->start == hole_start) {\r\nhole->hole_follows = 0;\r\nlist_del_init(&hole->hole_stack);\r\n}\r\nnode->hole_follows = 0;\r\nif (end != hole_end) {\r\nlist_add(&node->hole_stack, &mm->hole_stack);\r\nnode->hole_follows = 1;\r\n}\r\nreturn 0;\r\n}\r\nWARN(1, "no hole found for node 0x%lx + 0x%lx\n",\r\nnode->start, node->size);\r\nreturn -ENOSPC;\r\n}\r\nint drm_mm_insert_node_generic(struct drm_mm *mm, struct drm_mm_node *node,\r\nunsigned long size, unsigned alignment,\r\nunsigned long color,\r\nenum drm_mm_search_flags flags)\r\n{\r\nstruct drm_mm_node *hole_node;\r\nhole_node = drm_mm_search_free_generic(mm, size, alignment,\r\ncolor, flags);\r\nif (!hole_node)\r\nreturn -ENOSPC;\r\ndrm_mm_insert_helper(hole_node, node, size, alignment, color);\r\nreturn 0;\r\n}\r\nstatic void drm_mm_insert_helper_range(struct drm_mm_node *hole_node,\r\nstruct drm_mm_node *node,\r\nunsigned long size, unsigned alignment,\r\nunsigned long color,\r\nunsigned long start, unsigned long end)\r\n{\r\nstruct drm_mm *mm = hole_node->mm;\r\nunsigned long hole_start = drm_mm_hole_node_start(hole_node);\r\nunsigned long hole_end = drm_mm_hole_node_end(hole_node);\r\nunsigned long adj_start = hole_start;\r\nunsigned long adj_end = hole_end;\r\nBUG_ON(!hole_node->hole_follows || node->allocated);\r\nif (adj_start < start)\r\nadj_start = start;\r\nif (adj_end > end)\r\nadj_end = end;\r\nif (mm->color_adjust)\r\nmm->color_adjust(hole_node, color, &adj_start, &adj_end);\r\nif (alignment) {\r\nunsigned tmp = adj_start % alignment;\r\nif (tmp)\r\nadj_start += alignment - tmp;\r\n}\r\nif (adj_start == hole_start) {\r\nhole_node->hole_follows = 0;\r\nlist_del(&hole_node->hole_stack);\r\n}\r\nnode->start = adj_start;\r\nnode->size = size;\r\nnode->mm = mm;\r\nnode->color = color;\r\nnode->allocated = 1;\r\nINIT_LIST_HEAD(&node->hole_stack);\r\nlist_add(&node->node_list, &hole_node->node_list);\r\nBUG_ON(node->start + node->size > adj_end);\r\nBUG_ON(node->start + node->size > end);\r\nnode->hole_follows = 0;\r\nif (__drm_mm_hole_node_start(node) < hole_end) {\r\nlist_add(&node->hole_stack, &mm->hole_stack);\r\nnode->hole_follows = 1;\r\n}\r\n}\r\nint drm_mm_insert_node_in_range_generic(struct drm_mm *mm, struct drm_mm_node *node,\r\nunsigned long size, unsigned alignment, unsigned long color,\r\nunsigned long start, unsigned long end,\r\nenum drm_mm_search_flags flags)\r\n{\r\nstruct drm_mm_node *hole_node;\r\nhole_node = drm_mm_search_free_in_range_generic(mm,\r\nsize, alignment, color,\r\nstart, end, flags);\r\nif (!hole_node)\r\nreturn -ENOSPC;\r\ndrm_mm_insert_helper_range(hole_node, node,\r\nsize, alignment, color,\r\nstart, end);\r\nreturn 0;\r\n}\r\nvoid drm_mm_remove_node(struct drm_mm_node *node)\r\n{\r\nstruct drm_mm *mm = node->mm;\r\nstruct drm_mm_node *prev_node;\r\nif (WARN_ON(!node->allocated))\r\nreturn;\r\nBUG_ON(node->scanned_block || node->scanned_prev_free\r\n|| node->scanned_next_free);\r\nprev_node =\r\nlist_entry(node->node_list.prev, struct drm_mm_node, node_list);\r\nif (node->hole_follows) {\r\nBUG_ON(__drm_mm_hole_node_start(node) ==\r\n__drm_mm_hole_node_end(node));\r\nlist_del(&node->hole_stack);\r\n} else\r\nBUG_ON(__drm_mm_hole_node_start(node) !=\r\n__drm_mm_hole_node_end(node));\r\nif (!prev_node->hole_follows) {\r\nprev_node->hole_follows = 1;\r\nlist_add(&prev_node->hole_stack, &mm->hole_stack);\r\n} else\r\nlist_move(&prev_node->hole_stack, &mm->hole_stack);\r\nlist_del(&node->node_list);\r\nnode->allocated = 0;\r\n}\r\nstatic int check_free_hole(unsigned long start, unsigned long end,\r\nunsigned long size, unsigned alignment)\r\n{\r\nif (end - start < size)\r\nreturn 0;\r\nif (alignment) {\r\nunsigned tmp = start % alignment;\r\nif (tmp)\r\nstart += alignment - tmp;\r\n}\r\nreturn end >= start + size;\r\n}\r\nstatic struct drm_mm_node *drm_mm_search_free_generic(const struct drm_mm *mm,\r\nunsigned long size,\r\nunsigned alignment,\r\nunsigned long color,\r\nenum drm_mm_search_flags flags)\r\n{\r\nstruct drm_mm_node *entry;\r\nstruct drm_mm_node *best;\r\nunsigned long adj_start;\r\nunsigned long adj_end;\r\nunsigned long best_size;\r\nBUG_ON(mm->scanned_blocks);\r\nbest = NULL;\r\nbest_size = ~0UL;\r\ndrm_mm_for_each_hole(entry, mm, adj_start, adj_end) {\r\nif (mm->color_adjust) {\r\nmm->color_adjust(entry, color, &adj_start, &adj_end);\r\nif (adj_end <= adj_start)\r\ncontinue;\r\n}\r\nif (!check_free_hole(adj_start, adj_end, size, alignment))\r\ncontinue;\r\nif (!(flags & DRM_MM_SEARCH_BEST))\r\nreturn entry;\r\nif (entry->size < best_size) {\r\nbest = entry;\r\nbest_size = entry->size;\r\n}\r\n}\r\nreturn best;\r\n}\r\nstatic struct drm_mm_node *drm_mm_search_free_in_range_generic(const struct drm_mm *mm,\r\nunsigned long size,\r\nunsigned alignment,\r\nunsigned long color,\r\nunsigned long start,\r\nunsigned long end,\r\nenum drm_mm_search_flags flags)\r\n{\r\nstruct drm_mm_node *entry;\r\nstruct drm_mm_node *best;\r\nunsigned long adj_start;\r\nunsigned long adj_end;\r\nunsigned long best_size;\r\nBUG_ON(mm->scanned_blocks);\r\nbest = NULL;\r\nbest_size = ~0UL;\r\ndrm_mm_for_each_hole(entry, mm, adj_start, adj_end) {\r\nif (adj_start < start)\r\nadj_start = start;\r\nif (adj_end > end)\r\nadj_end = end;\r\nif (mm->color_adjust) {\r\nmm->color_adjust(entry, color, &adj_start, &adj_end);\r\nif (adj_end <= adj_start)\r\ncontinue;\r\n}\r\nif (!check_free_hole(adj_start, adj_end, size, alignment))\r\ncontinue;\r\nif (!(flags & DRM_MM_SEARCH_BEST))\r\nreturn entry;\r\nif (entry->size < best_size) {\r\nbest = entry;\r\nbest_size = entry->size;\r\n}\r\n}\r\nreturn best;\r\n}\r\nvoid drm_mm_replace_node(struct drm_mm_node *old, struct drm_mm_node *new)\r\n{\r\nlist_replace(&old->node_list, &new->node_list);\r\nlist_replace(&old->hole_stack, &new->hole_stack);\r\nnew->hole_follows = old->hole_follows;\r\nnew->mm = old->mm;\r\nnew->start = old->start;\r\nnew->size = old->size;\r\nnew->color = old->color;\r\nold->allocated = 0;\r\nnew->allocated = 1;\r\n}\r\nvoid drm_mm_init_scan(struct drm_mm *mm,\r\nunsigned long size,\r\nunsigned alignment,\r\nunsigned long color)\r\n{\r\nmm->scan_color = color;\r\nmm->scan_alignment = alignment;\r\nmm->scan_size = size;\r\nmm->scanned_blocks = 0;\r\nmm->scan_hit_start = 0;\r\nmm->scan_hit_end = 0;\r\nmm->scan_check_range = 0;\r\nmm->prev_scanned_node = NULL;\r\n}\r\nvoid drm_mm_init_scan_with_range(struct drm_mm *mm,\r\nunsigned long size,\r\nunsigned alignment,\r\nunsigned long color,\r\nunsigned long start,\r\nunsigned long end)\r\n{\r\nmm->scan_color = color;\r\nmm->scan_alignment = alignment;\r\nmm->scan_size = size;\r\nmm->scanned_blocks = 0;\r\nmm->scan_hit_start = 0;\r\nmm->scan_hit_end = 0;\r\nmm->scan_start = start;\r\nmm->scan_end = end;\r\nmm->scan_check_range = 1;\r\nmm->prev_scanned_node = NULL;\r\n}\r\nint drm_mm_scan_add_block(struct drm_mm_node *node)\r\n{\r\nstruct drm_mm *mm = node->mm;\r\nstruct drm_mm_node *prev_node;\r\nunsigned long hole_start, hole_end;\r\nunsigned long adj_start, adj_end;\r\nmm->scanned_blocks++;\r\nBUG_ON(node->scanned_block);\r\nnode->scanned_block = 1;\r\nprev_node = list_entry(node->node_list.prev, struct drm_mm_node,\r\nnode_list);\r\nnode->scanned_preceeds_hole = prev_node->hole_follows;\r\nprev_node->hole_follows = 1;\r\nlist_del(&node->node_list);\r\nnode->node_list.prev = &prev_node->node_list;\r\nnode->node_list.next = &mm->prev_scanned_node->node_list;\r\nmm->prev_scanned_node = node;\r\nadj_start = hole_start = drm_mm_hole_node_start(prev_node);\r\nadj_end = hole_end = drm_mm_hole_node_end(prev_node);\r\nif (mm->scan_check_range) {\r\nif (adj_start < mm->scan_start)\r\nadj_start = mm->scan_start;\r\nif (adj_end > mm->scan_end)\r\nadj_end = mm->scan_end;\r\n}\r\nif (mm->color_adjust)\r\nmm->color_adjust(prev_node, mm->scan_color,\r\n&adj_start, &adj_end);\r\nif (check_free_hole(adj_start, adj_end,\r\nmm->scan_size, mm->scan_alignment)) {\r\nmm->scan_hit_start = hole_start;\r\nmm->scan_hit_end = hole_end;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint drm_mm_scan_remove_block(struct drm_mm_node *node)\r\n{\r\nstruct drm_mm *mm = node->mm;\r\nstruct drm_mm_node *prev_node;\r\nmm->scanned_blocks--;\r\nBUG_ON(!node->scanned_block);\r\nnode->scanned_block = 0;\r\nprev_node = list_entry(node->node_list.prev, struct drm_mm_node,\r\nnode_list);\r\nprev_node->hole_follows = node->scanned_preceeds_hole;\r\nlist_add(&node->node_list, &prev_node->node_list);\r\nreturn (drm_mm_hole_node_end(node) > mm->scan_hit_start &&\r\nnode->start < mm->scan_hit_end);\r\n}\r\nint drm_mm_clean(struct drm_mm * mm)\r\n{\r\nstruct list_head *head = &mm->head_node.node_list;\r\nreturn (head->next->next == head);\r\n}\r\nvoid drm_mm_init(struct drm_mm * mm, unsigned long start, unsigned long size)\r\n{\r\nINIT_LIST_HEAD(&mm->hole_stack);\r\nmm->scanned_blocks = 0;\r\nINIT_LIST_HEAD(&mm->head_node.node_list);\r\nINIT_LIST_HEAD(&mm->head_node.hole_stack);\r\nmm->head_node.hole_follows = 1;\r\nmm->head_node.scanned_block = 0;\r\nmm->head_node.scanned_prev_free = 0;\r\nmm->head_node.scanned_next_free = 0;\r\nmm->head_node.mm = mm;\r\nmm->head_node.start = start + size;\r\nmm->head_node.size = start - mm->head_node.start;\r\nlist_add_tail(&mm->head_node.hole_stack, &mm->hole_stack);\r\nmm->color_adjust = NULL;\r\n}\r\nvoid drm_mm_takedown(struct drm_mm * mm)\r\n{\r\nWARN(!list_empty(&mm->head_node.node_list),\r\n"Memory manager not clean during takedown.\n");\r\n}\r\nstatic unsigned long drm_mm_debug_hole(struct drm_mm_node *entry,\r\nconst char *prefix)\r\n{\r\nunsigned long hole_start, hole_end, hole_size;\r\nif (entry->hole_follows) {\r\nhole_start = drm_mm_hole_node_start(entry);\r\nhole_end = drm_mm_hole_node_end(entry);\r\nhole_size = hole_end - hole_start;\r\nprintk(KERN_DEBUG "%s 0x%08lx-0x%08lx: %8lu: free\n",\r\nprefix, hole_start, hole_end,\r\nhole_size);\r\nreturn hole_size;\r\n}\r\nreturn 0;\r\n}\r\nvoid drm_mm_debug_table(struct drm_mm *mm, const char *prefix)\r\n{\r\nstruct drm_mm_node *entry;\r\nunsigned long total_used = 0, total_free = 0, total = 0;\r\ntotal_free += drm_mm_debug_hole(&mm->head_node, prefix);\r\ndrm_mm_for_each_node(entry, mm) {\r\nprintk(KERN_DEBUG "%s 0x%08lx-0x%08lx: %8lu: used\n",\r\nprefix, entry->start, entry->start + entry->size,\r\nentry->size);\r\ntotal_used += entry->size;\r\ntotal_free += drm_mm_debug_hole(entry, prefix);\r\n}\r\ntotal = total_free + total_used;\r\nprintk(KERN_DEBUG "%s total: %lu, used %lu free %lu\n", prefix, total,\r\ntotal_used, total_free);\r\n}\r\nstatic unsigned long drm_mm_dump_hole(struct seq_file *m, struct drm_mm_node *entry)\r\n{\r\nunsigned long hole_start, hole_end, hole_size;\r\nif (entry->hole_follows) {\r\nhole_start = drm_mm_hole_node_start(entry);\r\nhole_end = drm_mm_hole_node_end(entry);\r\nhole_size = hole_end - hole_start;\r\nseq_printf(m, "0x%08lx-0x%08lx: 0x%08lx: free\n",\r\nhole_start, hole_end, hole_size);\r\nreturn hole_size;\r\n}\r\nreturn 0;\r\n}\r\nint drm_mm_dump_table(struct seq_file *m, struct drm_mm *mm)\r\n{\r\nstruct drm_mm_node *entry;\r\nunsigned long total_used = 0, total_free = 0, total = 0;\r\ntotal_free += drm_mm_dump_hole(m, &mm->head_node);\r\ndrm_mm_for_each_node(entry, mm) {\r\nseq_printf(m, "0x%08lx-0x%08lx: 0x%08lx: used\n",\r\nentry->start, entry->start + entry->size,\r\nentry->size);\r\ntotal_used += entry->size;\r\ntotal_free += drm_mm_dump_hole(m, entry);\r\n}\r\ntotal = total_free + total_used;\r\nseq_printf(m, "total: %lu, used %lu free %lu\n", total, total_used, total_free);\r\nreturn 0;\r\n}
