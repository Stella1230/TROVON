void\r\nprint_ds(struct nfs4_pnfs_ds *ds)\r\n{\r\nif (ds == NULL) {\r\nprintk("%s NULL device\n", __func__);\r\nreturn;\r\n}\r\nprintk(" ds %s\n"\r\n" ref count %d\n"\r\n" client %p\n"\r\n" cl_exchange_flags %x\n",\r\nds->ds_remotestr,\r\natomic_read(&ds->ds_count), ds->ds_clp,\r\nds->ds_clp ? ds->ds_clp->cl_exchange_flags : 0);\r\n}\r\nstatic bool\r\nsame_sockaddr(struct sockaddr *addr1, struct sockaddr *addr2)\r\n{\r\nstruct sockaddr_in *a, *b;\r\nstruct sockaddr_in6 *a6, *b6;\r\nif (addr1->sa_family != addr2->sa_family)\r\nreturn false;\r\nswitch (addr1->sa_family) {\r\ncase AF_INET:\r\na = (struct sockaddr_in *)addr1;\r\nb = (struct sockaddr_in *)addr2;\r\nif (a->sin_addr.s_addr == b->sin_addr.s_addr &&\r\na->sin_port == b->sin_port)\r\nreturn true;\r\nbreak;\r\ncase AF_INET6:\r\na6 = (struct sockaddr_in6 *)addr1;\r\nb6 = (struct sockaddr_in6 *)addr2;\r\nif (ipv6_addr_scope(&a6->sin6_addr) ==\r\nIPV6_ADDR_SCOPE_LINKLOCAL &&\r\na6->sin6_scope_id != b6->sin6_scope_id)\r\nreturn false;\r\nif (ipv6_addr_equal(&a6->sin6_addr, &b6->sin6_addr) &&\r\na6->sin6_port == b6->sin6_port)\r\nreturn true;\r\nbreak;\r\ndefault:\r\ndprintk("%s: unhandled address family: %u\n",\r\n__func__, addr1->sa_family);\r\nreturn false;\r\n}\r\nreturn false;\r\n}\r\nstatic bool\r\n_same_data_server_addrs_locked(const struct list_head *dsaddrs1,\r\nconst struct list_head *dsaddrs2)\r\n{\r\nstruct nfs4_pnfs_ds_addr *da1, *da2;\r\nfor (da1 = list_first_entry(dsaddrs1, typeof(*da1), da_node),\r\nda2 = list_first_entry(dsaddrs2, typeof(*da2), da_node);\r\nda1 != NULL && da2 != NULL;\r\nda1 = list_entry(da1->da_node.next, typeof(*da1), da_node),\r\nda2 = list_entry(da2->da_node.next, typeof(*da2), da_node)) {\r\nif (!same_sockaddr((struct sockaddr *)&da1->da_addr,\r\n(struct sockaddr *)&da2->da_addr))\r\nreturn false;\r\n}\r\nif (da1 == NULL && da2 == NULL)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic struct nfs4_pnfs_ds *\r\n_data_server_lookup_locked(const struct list_head *dsaddrs)\r\n{\r\nstruct nfs4_pnfs_ds *ds;\r\nlist_for_each_entry(ds, &nfs4_data_server_cache, ds_node)\r\nif (_same_data_server_addrs_locked(&ds->ds_addrs, dsaddrs))\r\nreturn ds;\r\nreturn NULL;\r\n}\r\nstatic int\r\nnfs4_ds_connect(struct nfs_server *mds_srv, struct nfs4_pnfs_ds *ds)\r\n{\r\nstruct nfs_client *clp = ERR_PTR(-EIO);\r\nstruct nfs4_pnfs_ds_addr *da;\r\nint status = 0;\r\ndprintk("--> %s DS %s au_flavor %d\n", __func__, ds->ds_remotestr,\r\nmds_srv->nfs_client->cl_rpcclient->cl_auth->au_flavor);\r\nlist_for_each_entry(da, &ds->ds_addrs, da_node) {\r\ndprintk("%s: DS %s: trying address %s\n",\r\n__func__, ds->ds_remotestr, da->da_remotestr);\r\nclp = nfs4_set_ds_client(mds_srv->nfs_client,\r\n(struct sockaddr *)&da->da_addr,\r\nda->da_addrlen, IPPROTO_TCP,\r\ndataserver_timeo, dataserver_retrans);\r\nif (!IS_ERR(clp))\r\nbreak;\r\n}\r\nif (IS_ERR(clp)) {\r\nstatus = PTR_ERR(clp);\r\ngoto out;\r\n}\r\nstatus = nfs4_init_ds_session(clp, mds_srv->nfs_client->cl_lease_time);\r\nif (status)\r\ngoto out_put;\r\nsmp_wmb();\r\nds->ds_clp = clp;\r\ndprintk("%s [new] addr: %s\n", __func__, ds->ds_remotestr);\r\nout:\r\nreturn status;\r\nout_put:\r\nnfs_put_client(clp);\r\ngoto out;\r\n}\r\nstatic void\r\ndestroy_ds(struct nfs4_pnfs_ds *ds)\r\n{\r\nstruct nfs4_pnfs_ds_addr *da;\r\ndprintk("--> %s\n", __func__);\r\nifdebug(FACILITY)\r\nprint_ds(ds);\r\nif (ds->ds_clp)\r\nnfs_put_client(ds->ds_clp);\r\nwhile (!list_empty(&ds->ds_addrs)) {\r\nda = list_first_entry(&ds->ds_addrs,\r\nstruct nfs4_pnfs_ds_addr,\r\nda_node);\r\nlist_del_init(&da->da_node);\r\nkfree(da->da_remotestr);\r\nkfree(da);\r\n}\r\nkfree(ds->ds_remotestr);\r\nkfree(ds);\r\n}\r\nvoid\r\nnfs4_fl_free_deviceid(struct nfs4_file_layout_dsaddr *dsaddr)\r\n{\r\nstruct nfs4_pnfs_ds *ds;\r\nint i;\r\nnfs4_print_deviceid(&dsaddr->id_node.deviceid);\r\nfor (i = 0; i < dsaddr->ds_num; i++) {\r\nds = dsaddr->ds_list[i];\r\nif (ds != NULL) {\r\nif (atomic_dec_and_lock(&ds->ds_count,\r\n&nfs4_ds_cache_lock)) {\r\nlist_del_init(&ds->ds_node);\r\nspin_unlock(&nfs4_ds_cache_lock);\r\ndestroy_ds(ds);\r\n}\r\n}\r\n}\r\nkfree(dsaddr->stripe_indices);\r\nkfree(dsaddr);\r\n}\r\nstatic char *\r\nnfs4_pnfs_remotestr(struct list_head *dsaddrs, gfp_t gfp_flags)\r\n{\r\nstruct nfs4_pnfs_ds_addr *da;\r\nchar *remotestr;\r\nsize_t len;\r\nchar *p;\r\nlen = 3;\r\nlist_for_each_entry(da, dsaddrs, da_node) {\r\nlen += strlen(da->da_remotestr) + 1;\r\n}\r\nremotestr = kzalloc(len, gfp_flags);\r\nif (!remotestr)\r\nreturn NULL;\r\np = remotestr;\r\n*(p++) = '{';\r\nlen--;\r\nlist_for_each_entry(da, dsaddrs, da_node) {\r\nsize_t ll = strlen(da->da_remotestr);\r\nif (ll > len)\r\ngoto out_err;\r\nmemcpy(p, da->da_remotestr, ll);\r\np += ll;\r\nlen -= ll;\r\nif (len < 1)\r\ngoto out_err;\r\n(*p++) = ',';\r\nlen--;\r\n}\r\nif (len < 2)\r\ngoto out_err;\r\n*(p++) = '}';\r\n*p = '\0';\r\nreturn remotestr;\r\nout_err:\r\nkfree(remotestr);\r\nreturn NULL;\r\n}\r\nstatic struct nfs4_pnfs_ds *\r\nnfs4_pnfs_ds_add(struct list_head *dsaddrs, gfp_t gfp_flags)\r\n{\r\nstruct nfs4_pnfs_ds *tmp_ds, *ds = NULL;\r\nchar *remotestr;\r\nif (list_empty(dsaddrs)) {\r\ndprintk("%s: no addresses defined\n", __func__);\r\ngoto out;\r\n}\r\nds = kzalloc(sizeof(*ds), gfp_flags);\r\nif (!ds)\r\ngoto out;\r\nremotestr = nfs4_pnfs_remotestr(dsaddrs, gfp_flags);\r\nspin_lock(&nfs4_ds_cache_lock);\r\ntmp_ds = _data_server_lookup_locked(dsaddrs);\r\nif (tmp_ds == NULL) {\r\nINIT_LIST_HEAD(&ds->ds_addrs);\r\nlist_splice_init(dsaddrs, &ds->ds_addrs);\r\nds->ds_remotestr = remotestr;\r\natomic_set(&ds->ds_count, 1);\r\nINIT_LIST_HEAD(&ds->ds_node);\r\nds->ds_clp = NULL;\r\nlist_add(&ds->ds_node, &nfs4_data_server_cache);\r\ndprintk("%s add new data server %s\n", __func__,\r\nds->ds_remotestr);\r\n} else {\r\nkfree(remotestr);\r\nkfree(ds);\r\natomic_inc(&tmp_ds->ds_count);\r\ndprintk("%s data server %s found, inc'ed ds_count to %d\n",\r\n__func__, tmp_ds->ds_remotestr,\r\natomic_read(&tmp_ds->ds_count));\r\nds = tmp_ds;\r\n}\r\nspin_unlock(&nfs4_ds_cache_lock);\r\nout:\r\nreturn ds;\r\n}\r\nstatic struct nfs4_pnfs_ds_addr *\r\ndecode_ds_addr(struct net *net, struct xdr_stream *streamp, gfp_t gfp_flags)\r\n{\r\nstruct nfs4_pnfs_ds_addr *da = NULL;\r\nchar *buf, *portstr;\r\n__be16 port;\r\nint nlen, rlen;\r\nint tmp[2];\r\n__be32 *p;\r\nchar *netid, *match_netid;\r\nsize_t len, match_netid_len;\r\nchar *startsep = "";\r\nchar *endsep = "";\r\np = xdr_inline_decode(streamp, 4);\r\nif (unlikely(!p))\r\ngoto out_err;\r\nnlen = be32_to_cpup(p++);\r\np = xdr_inline_decode(streamp, nlen);\r\nif (unlikely(!p))\r\ngoto out_err;\r\nnetid = kmalloc(nlen+1, gfp_flags);\r\nif (unlikely(!netid))\r\ngoto out_err;\r\nnetid[nlen] = '\0';\r\nmemcpy(netid, p, nlen);\r\np = xdr_inline_decode(streamp, 4);\r\nif (unlikely(!p))\r\ngoto out_free_netid;\r\nrlen = be32_to_cpup(p);\r\np = xdr_inline_decode(streamp, rlen);\r\nif (unlikely(!p))\r\ngoto out_free_netid;\r\nif (rlen > INET6_ADDRSTRLEN + IPV6_SCOPE_ID_LEN + 8) {\r\ndprintk("%s: Invalid address, length %d\n", __func__,\r\nrlen);\r\ngoto out_free_netid;\r\n}\r\nbuf = kmalloc(rlen + 1, gfp_flags);\r\nif (!buf) {\r\ndprintk("%s: Not enough memory\n", __func__);\r\ngoto out_free_netid;\r\n}\r\nbuf[rlen] = '\0';\r\nmemcpy(buf, p, rlen);\r\nportstr = strrchr(buf, '.');\r\nif (!portstr) {\r\ndprintk("%s: Failed finding expected dot in port\n",\r\n__func__);\r\ngoto out_free_buf;\r\n}\r\n*portstr = '-';\r\nportstr = strrchr(buf, '.');\r\nif (!portstr) {\r\ndprintk("%s: Failed finding expected dot between address and "\r\n"port\n", __func__);\r\ngoto out_free_buf;\r\n}\r\n*portstr = '\0';\r\nda = kzalloc(sizeof(*da), gfp_flags);\r\nif (unlikely(!da))\r\ngoto out_free_buf;\r\nINIT_LIST_HEAD(&da->da_node);\r\nif (!rpc_pton(net, buf, portstr-buf, (struct sockaddr *)&da->da_addr,\r\nsizeof(da->da_addr))) {\r\ndprintk("%s: error parsing address %s\n", __func__, buf);\r\ngoto out_free_da;\r\n}\r\nportstr++;\r\nsscanf(portstr, "%d-%d", &tmp[0], &tmp[1]);\r\nport = htons((tmp[0] << 8) | (tmp[1]));\r\nswitch (da->da_addr.ss_family) {\r\ncase AF_INET:\r\n((struct sockaddr_in *)&da->da_addr)->sin_port = port;\r\nda->da_addrlen = sizeof(struct sockaddr_in);\r\nmatch_netid = "tcp";\r\nmatch_netid_len = 3;\r\nbreak;\r\ncase AF_INET6:\r\n((struct sockaddr_in6 *)&da->da_addr)->sin6_port = port;\r\nda->da_addrlen = sizeof(struct sockaddr_in6);\r\nmatch_netid = "tcp6";\r\nmatch_netid_len = 4;\r\nstartsep = "[";\r\nendsep = "]";\r\nbreak;\r\ndefault:\r\ndprintk("%s: unsupported address family: %u\n",\r\n__func__, da->da_addr.ss_family);\r\ngoto out_free_da;\r\n}\r\nif (nlen != match_netid_len || strncmp(netid, match_netid, nlen)) {\r\ndprintk("%s: ERROR: r_netid \"%s\" != \"%s\"\n",\r\n__func__, netid, match_netid);\r\ngoto out_free_da;\r\n}\r\nlen = strlen(startsep) + strlen(buf) + strlen(endsep) + 7;\r\nda->da_remotestr = kzalloc(len, gfp_flags);\r\nif (da->da_remotestr)\r\nsnprintf(da->da_remotestr, len, "%s%s%s:%u", startsep,\r\nbuf, endsep, ntohs(port));\r\ndprintk("%s: Parsed DS addr %s\n", __func__, da->da_remotestr);\r\nkfree(buf);\r\nkfree(netid);\r\nreturn da;\r\nout_free_da:\r\nkfree(da);\r\nout_free_buf:\r\ndprintk("%s: Error parsing DS addr: %s\n", __func__, buf);\r\nkfree(buf);\r\nout_free_netid:\r\nkfree(netid);\r\nout_err:\r\nreturn NULL;\r\n}\r\nstatic struct nfs4_file_layout_dsaddr*\r\ndecode_device(struct inode *ino, struct pnfs_device *pdev, gfp_t gfp_flags)\r\n{\r\nint i;\r\nu32 cnt, num;\r\nu8 *indexp;\r\n__be32 *p;\r\nu8 *stripe_indices;\r\nu8 max_stripe_index;\r\nstruct nfs4_file_layout_dsaddr *dsaddr = NULL;\r\nstruct xdr_stream stream;\r\nstruct xdr_buf buf;\r\nstruct page *scratch;\r\nstruct list_head dsaddrs;\r\nstruct nfs4_pnfs_ds_addr *da;\r\nscratch = alloc_page(gfp_flags);\r\nif (!scratch)\r\ngoto out_err;\r\nxdr_init_decode_pages(&stream, &buf, pdev->pages, pdev->pglen);\r\nxdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\r\np = xdr_inline_decode(&stream, 4);\r\nif (unlikely(!p))\r\ngoto out_err_free_scratch;\r\ncnt = be32_to_cpup(p);\r\ndprintk("%s stripe count %d\n", __func__, cnt);\r\nif (cnt > NFS4_PNFS_MAX_STRIPE_CNT) {\r\nprintk(KERN_WARNING "NFS: %s: stripe count %d greater than "\r\n"supported maximum %d\n", __func__,\r\ncnt, NFS4_PNFS_MAX_STRIPE_CNT);\r\ngoto out_err_free_scratch;\r\n}\r\nstripe_indices = kcalloc(cnt, sizeof(u8), gfp_flags);\r\nif (!stripe_indices)\r\ngoto out_err_free_scratch;\r\np = xdr_inline_decode(&stream, cnt << 2);\r\nif (unlikely(!p))\r\ngoto out_err_free_stripe_indices;\r\nindexp = &stripe_indices[0];\r\nmax_stripe_index = 0;\r\nfor (i = 0; i < cnt; i++) {\r\n*indexp = be32_to_cpup(p++);\r\nmax_stripe_index = max(max_stripe_index, *indexp);\r\nindexp++;\r\n}\r\np = xdr_inline_decode(&stream, 4);\r\nif (unlikely(!p))\r\ngoto out_err_free_stripe_indices;\r\nnum = be32_to_cpup(p);\r\ndprintk("%s ds_num %u\n", __func__, num);\r\nif (num > NFS4_PNFS_MAX_MULTI_CNT) {\r\nprintk(KERN_WARNING "NFS: %s: multipath count %d greater than "\r\n"supported maximum %d\n", __func__,\r\nnum, NFS4_PNFS_MAX_MULTI_CNT);\r\ngoto out_err_free_stripe_indices;\r\n}\r\nif (max_stripe_index >= num) {\r\nprintk(KERN_WARNING "NFS: %s: stripe index %u >= num ds %u\n",\r\n__func__, max_stripe_index, num);\r\ngoto out_err_free_stripe_indices;\r\n}\r\ndsaddr = kzalloc(sizeof(*dsaddr) +\r\n(sizeof(struct nfs4_pnfs_ds *) * (num - 1)),\r\ngfp_flags);\r\nif (!dsaddr)\r\ngoto out_err_free_stripe_indices;\r\ndsaddr->stripe_count = cnt;\r\ndsaddr->stripe_indices = stripe_indices;\r\nstripe_indices = NULL;\r\ndsaddr->ds_num = num;\r\nnfs4_init_deviceid_node(&dsaddr->id_node,\r\nNFS_SERVER(ino)->pnfs_curr_ld,\r\nNFS_SERVER(ino)->nfs_client,\r\n&pdev->dev_id);\r\nINIT_LIST_HEAD(&dsaddrs);\r\nfor (i = 0; i < dsaddr->ds_num; i++) {\r\nint j;\r\nu32 mp_count;\r\np = xdr_inline_decode(&stream, 4);\r\nif (unlikely(!p))\r\ngoto out_err_free_deviceid;\r\nmp_count = be32_to_cpup(p);\r\nfor (j = 0; j < mp_count; j++) {\r\nda = decode_ds_addr(NFS_SERVER(ino)->nfs_client->cl_net,\r\n&stream, gfp_flags);\r\nif (da)\r\nlist_add_tail(&da->da_node, &dsaddrs);\r\n}\r\nif (list_empty(&dsaddrs)) {\r\ndprintk("%s: no suitable DS addresses found\n",\r\n__func__);\r\ngoto out_err_free_deviceid;\r\n}\r\ndsaddr->ds_list[i] = nfs4_pnfs_ds_add(&dsaddrs, gfp_flags);\r\nif (!dsaddr->ds_list[i])\r\ngoto out_err_drain_dsaddrs;\r\nwhile (!list_empty(&dsaddrs)) {\r\nda = list_first_entry(&dsaddrs,\r\nstruct nfs4_pnfs_ds_addr,\r\nda_node);\r\nlist_del_init(&da->da_node);\r\nkfree(da->da_remotestr);\r\nkfree(da);\r\n}\r\n}\r\n__free_page(scratch);\r\nreturn dsaddr;\r\nout_err_drain_dsaddrs:\r\nwhile (!list_empty(&dsaddrs)) {\r\nda = list_first_entry(&dsaddrs, struct nfs4_pnfs_ds_addr,\r\nda_node);\r\nlist_del_init(&da->da_node);\r\nkfree(da->da_remotestr);\r\nkfree(da);\r\n}\r\nout_err_free_deviceid:\r\nnfs4_fl_free_deviceid(dsaddr);\r\ngoto out_err_free_scratch;\r\nout_err_free_stripe_indices:\r\nkfree(stripe_indices);\r\nout_err_free_scratch:\r\n__free_page(scratch);\r\nout_err:\r\ndprintk("%s ERROR: returning NULL\n", __func__);\r\nreturn NULL;\r\n}\r\nstatic struct nfs4_file_layout_dsaddr *\r\ndecode_and_add_device(struct inode *inode, struct pnfs_device *dev, gfp_t gfp_flags)\r\n{\r\nstruct nfs4_deviceid_node *d;\r\nstruct nfs4_file_layout_dsaddr *n, *new;\r\nnew = decode_device(inode, dev, gfp_flags);\r\nif (!new) {\r\nprintk(KERN_WARNING "NFS: %s: Could not decode or add device\n",\r\n__func__);\r\nreturn NULL;\r\n}\r\nd = nfs4_insert_deviceid_node(&new->id_node);\r\nn = container_of(d, struct nfs4_file_layout_dsaddr, id_node);\r\nif (n != new) {\r\nnfs4_fl_free_deviceid(new);\r\nreturn n;\r\n}\r\nreturn new;\r\n}\r\nstruct nfs4_file_layout_dsaddr *\r\nfilelayout_get_device_info(struct inode *inode,\r\nstruct nfs4_deviceid *dev_id,\r\nstruct rpc_cred *cred,\r\ngfp_t gfp_flags)\r\n{\r\nstruct pnfs_device *pdev = NULL;\r\nu32 max_resp_sz;\r\nint max_pages;\r\nstruct page **pages = NULL;\r\nstruct nfs4_file_layout_dsaddr *dsaddr = NULL;\r\nint rc, i;\r\nstruct nfs_server *server = NFS_SERVER(inode);\r\nmax_resp_sz = server->nfs_client->cl_session->fc_attrs.max_resp_sz;\r\nmax_pages = nfs_page_array_len(0, max_resp_sz);\r\ndprintk("%s inode %p max_resp_sz %u max_pages %d\n",\r\n__func__, inode, max_resp_sz, max_pages);\r\npdev = kzalloc(sizeof(struct pnfs_device), gfp_flags);\r\nif (pdev == NULL)\r\nreturn NULL;\r\npages = kzalloc(max_pages * sizeof(struct page *), gfp_flags);\r\nif (pages == NULL) {\r\nkfree(pdev);\r\nreturn NULL;\r\n}\r\nfor (i = 0; i < max_pages; i++) {\r\npages[i] = alloc_page(gfp_flags);\r\nif (!pages[i])\r\ngoto out_free;\r\n}\r\nmemcpy(&pdev->dev_id, dev_id, sizeof(*dev_id));\r\npdev->layout_type = LAYOUT_NFSV4_1_FILES;\r\npdev->pages = pages;\r\npdev->pgbase = 0;\r\npdev->pglen = max_resp_sz;\r\npdev->mincount = 0;\r\npdev->maxcount = max_resp_sz - nfs41_maxgetdevinfo_overhead;\r\nrc = nfs4_proc_getdeviceinfo(server, pdev, cred);\r\ndprintk("%s getdevice info returns %d\n", __func__, rc);\r\nif (rc)\r\ngoto out_free;\r\ndsaddr = decode_and_add_device(inode, pdev, gfp_flags);\r\nout_free:\r\nfor (i = 0; i < max_pages; i++)\r\n__free_page(pages[i]);\r\nkfree(pages);\r\nkfree(pdev);\r\ndprintk("<-- %s dsaddr %p\n", __func__, dsaddr);\r\nreturn dsaddr;\r\n}\r\nvoid\r\nnfs4_fl_put_deviceid(struct nfs4_file_layout_dsaddr *dsaddr)\r\n{\r\nnfs4_put_deviceid_node(&dsaddr->id_node);\r\n}\r\nu32\r\nnfs4_fl_calc_j_index(struct pnfs_layout_segment *lseg, loff_t offset)\r\n{\r\nstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\r\nu64 tmp;\r\ntmp = offset - flseg->pattern_offset;\r\ndo_div(tmp, flseg->stripe_unit);\r\ntmp += flseg->first_stripe_index;\r\nreturn do_div(tmp, flseg->dsaddr->stripe_count);\r\n}\r\nu32\r\nnfs4_fl_calc_ds_index(struct pnfs_layout_segment *lseg, u32 j)\r\n{\r\nreturn FILELAYOUT_LSEG(lseg)->dsaddr->stripe_indices[j];\r\n}\r\nstruct nfs_fh *\r\nnfs4_fl_select_ds_fh(struct pnfs_layout_segment *lseg, u32 j)\r\n{\r\nstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\r\nu32 i;\r\nif (flseg->stripe_type == STRIPE_SPARSE) {\r\nif (flseg->num_fh == 1)\r\ni = 0;\r\nelse if (flseg->num_fh == 0)\r\nreturn NULL;\r\nelse\r\ni = nfs4_fl_calc_ds_index(lseg, j);\r\n} else\r\ni = j;\r\nreturn flseg->fh_array[i];\r\n}\r\nstatic void nfs4_wait_ds_connect(struct nfs4_pnfs_ds *ds)\r\n{\r\nmight_sleep();\r\nwait_on_bit(&ds->ds_state, NFS4DS_CONNECTING,\r\nnfs_wait_bit_killable, TASK_KILLABLE);\r\n}\r\nstatic void nfs4_clear_ds_conn_bit(struct nfs4_pnfs_ds *ds)\r\n{\r\nsmp_mb__before_clear_bit();\r\nclear_bit(NFS4DS_CONNECTING, &ds->ds_state);\r\nsmp_mb__after_clear_bit();\r\nwake_up_bit(&ds->ds_state, NFS4DS_CONNECTING);\r\n}\r\nstruct nfs4_pnfs_ds *\r\nnfs4_fl_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx)\r\n{\r\nstruct nfs4_file_layout_dsaddr *dsaddr = FILELAYOUT_LSEG(lseg)->dsaddr;\r\nstruct nfs4_pnfs_ds *ds = dsaddr->ds_list[ds_idx];\r\nstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\r\nstruct nfs4_pnfs_ds *ret = ds;\r\nif (ds == NULL) {\r\nprintk(KERN_ERR "NFS: %s: No data server for offset index %d\n",\r\n__func__, ds_idx);\r\nfilelayout_mark_devid_invalid(devid);\r\ngoto out;\r\n}\r\nsmp_rmb();\r\nif (ds->ds_clp)\r\ngoto out_test_devid;\r\nif (test_and_set_bit(NFS4DS_CONNECTING, &ds->ds_state) == 0) {\r\nstruct nfs_server *s = NFS_SERVER(lseg->pls_layout->plh_inode);\r\nint err;\r\nerr = nfs4_ds_connect(s, ds);\r\nif (err)\r\nnfs4_mark_deviceid_unavailable(devid);\r\nnfs4_clear_ds_conn_bit(ds);\r\n} else {\r\nnfs4_wait_ds_connect(ds);\r\n}\r\nout_test_devid:\r\nif (filelayout_test_devid_unavailable(devid))\r\nret = NULL;\r\nout:\r\nreturn ret;\r\n}
