static __u32\r\nzoran_v4l2_calc_bufsize (struct zoran_jpg_settings *settings)\r\n{\r\n__u8 div = settings->VerDcm * settings->HorDcm * settings->TmpDcm;\r\n__u32 num = (1024 * 512) / (div);\r\n__u32 result = 2;\r\nnum--;\r\nwhile (num) {\r\nnum >>= 1;\r\nresult <<= 1;\r\n}\r\nif (result > jpg_bufsize)\r\nreturn jpg_bufsize;\r\nif (result < 8192)\r\nreturn 8192;\r\nreturn result;\r\n}\r\nstatic void map_mode_raw(struct zoran_fh *fh)\r\n{\r\nfh->map_mode = ZORAN_MAP_MODE_RAW;\r\nfh->buffers.buffer_size = v4l_bufsize;\r\nfh->buffers.num_buffers = v4l_nbufs;\r\n}\r\nstatic void map_mode_jpg(struct zoran_fh *fh, int play)\r\n{\r\nfh->map_mode = play ? ZORAN_MAP_MODE_JPG_PLAY : ZORAN_MAP_MODE_JPG_REC;\r\nfh->buffers.buffer_size = jpg_bufsize;\r\nfh->buffers.num_buffers = jpg_nbufs;\r\n}\r\nstatic inline const char *mode_name(enum zoran_map_mode mode)\r\n{\r\nreturn mode == ZORAN_MAP_MODE_RAW ? "V4L" : "JPG";\r\n}\r\nstatic int v4l_fbuffer_alloc(struct zoran_fh *fh)\r\n{\r\nstruct zoran *zr = fh->zr;\r\nint i, off;\r\nunsigned char *mem;\r\nfor (i = 0; i < fh->buffers.num_buffers; i++) {\r\nif (fh->buffers.buffer[i].v4l.fbuffer)\r\ndprintk(2,\r\nKERN_WARNING\r\n"%s: %s - buffer %d already allocated!?\n",\r\nZR_DEVNAME(zr), __func__, i);\r\nmem = kmalloc(fh->buffers.buffer_size,\r\nGFP_KERNEL | __GFP_NOWARN);\r\nif (!mem) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - kmalloc for V4L buf %d failed\n",\r\nZR_DEVNAME(zr), __func__, i);\r\nv4l_fbuffer_free(fh);\r\nreturn -ENOBUFS;\r\n}\r\nfh->buffers.buffer[i].v4l.fbuffer = mem;\r\nfh->buffers.buffer[i].v4l.fbuffer_phys = virt_to_phys(mem);\r\nfh->buffers.buffer[i].v4l.fbuffer_bus = virt_to_bus(mem);\r\nfor (off = 0; off < fh->buffers.buffer_size;\r\noff += PAGE_SIZE)\r\nSetPageReserved(virt_to_page(mem + off));\r\ndprintk(4,\r\nKERN_INFO\r\n"%s: %s - V4L frame %d mem 0x%lx (bus: 0x%llx)\n",\r\nZR_DEVNAME(zr), __func__, i, (unsigned long) mem,\r\n(unsigned long long)virt_to_bus(mem));\r\n}\r\nfh->buffers.allocated = 1;\r\nreturn 0;\r\n}\r\nstatic void v4l_fbuffer_free(struct zoran_fh *fh)\r\n{\r\nstruct zoran *zr = fh->zr;\r\nint i, off;\r\nunsigned char *mem;\r\ndprintk(4, KERN_INFO "%s: %s\n", ZR_DEVNAME(zr), __func__);\r\nfor (i = 0; i < fh->buffers.num_buffers; i++) {\r\nif (!fh->buffers.buffer[i].v4l.fbuffer)\r\ncontinue;\r\nmem = fh->buffers.buffer[i].v4l.fbuffer;\r\nfor (off = 0; off < fh->buffers.buffer_size;\r\noff += PAGE_SIZE)\r\nClearPageReserved(virt_to_page(mem + off));\r\nkfree(fh->buffers.buffer[i].v4l.fbuffer);\r\nfh->buffers.buffer[i].v4l.fbuffer = NULL;\r\n}\r\nfh->buffers.allocated = 0;\r\n}\r\nstatic int jpg_fbuffer_alloc(struct zoran_fh *fh)\r\n{\r\nstruct zoran *zr = fh->zr;\r\nint i, j, off;\r\nu8 *mem;\r\nfor (i = 0; i < fh->buffers.num_buffers; i++) {\r\nif (fh->buffers.buffer[i].jpg.frag_tab)\r\ndprintk(2,\r\nKERN_WARNING\r\n"%s: %s - buffer %d already allocated!?\n",\r\nZR_DEVNAME(zr), __func__, i);\r\nmem = (void *)get_zeroed_page(GFP_KERNEL);\r\nif (!mem) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - get_zeroed_page (frag_tab) failed for buffer %d\n",\r\nZR_DEVNAME(zr), __func__, i);\r\njpg_fbuffer_free(fh);\r\nreturn -ENOBUFS;\r\n}\r\nfh->buffers.buffer[i].jpg.frag_tab = (__le32 *)mem;\r\nfh->buffers.buffer[i].jpg.frag_tab_bus = virt_to_bus(mem);\r\nif (fh->buffers.need_contiguous) {\r\nmem = kmalloc(fh->buffers.buffer_size, GFP_KERNEL);\r\nif (mem == NULL) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - kmalloc failed for buffer %d\n",\r\nZR_DEVNAME(zr), __func__, i);\r\njpg_fbuffer_free(fh);\r\nreturn -ENOBUFS;\r\n}\r\nfh->buffers.buffer[i].jpg.frag_tab[0] =\r\ncpu_to_le32(virt_to_bus(mem));\r\nfh->buffers.buffer[i].jpg.frag_tab[1] =\r\ncpu_to_le32((fh->buffers.buffer_size >> 1) | 1);\r\nfor (off = 0; off < fh->buffers.buffer_size; off += PAGE_SIZE)\r\nSetPageReserved(virt_to_page(mem + off));\r\n} else {\r\nfor (j = 0; j < fh->buffers.buffer_size / PAGE_SIZE; j++) {\r\nmem = (void *)get_zeroed_page(GFP_KERNEL);\r\nif (mem == NULL) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - get_zeroed_page failed for buffer %d\n",\r\nZR_DEVNAME(zr), __func__, i);\r\njpg_fbuffer_free(fh);\r\nreturn -ENOBUFS;\r\n}\r\nfh->buffers.buffer[i].jpg.frag_tab[2 * j] =\r\ncpu_to_le32(virt_to_bus(mem));\r\nfh->buffers.buffer[i].jpg.frag_tab[2 * j + 1] =\r\ncpu_to_le32((PAGE_SIZE >> 2) << 1);\r\nSetPageReserved(virt_to_page(mem));\r\n}\r\nfh->buffers.buffer[i].jpg.frag_tab[2 * j - 1] |= cpu_to_le32(1);\r\n}\r\n}\r\ndprintk(4,\r\nKERN_DEBUG "%s: %s - %d KB allocated\n",\r\nZR_DEVNAME(zr), __func__,\r\n(fh->buffers.num_buffers * fh->buffers.buffer_size) >> 10);\r\nfh->buffers.allocated = 1;\r\nreturn 0;\r\n}\r\nstatic void jpg_fbuffer_free(struct zoran_fh *fh)\r\n{\r\nstruct zoran *zr = fh->zr;\r\nint i, j, off;\r\nunsigned char *mem;\r\n__le32 frag_tab;\r\nstruct zoran_buffer *buffer;\r\ndprintk(4, KERN_DEBUG "%s: %s\n", ZR_DEVNAME(zr), __func__);\r\nfor (i = 0, buffer = &fh->buffers.buffer[0];\r\ni < fh->buffers.num_buffers; i++, buffer++) {\r\nif (!buffer->jpg.frag_tab)\r\ncontinue;\r\nif (fh->buffers.need_contiguous) {\r\nfrag_tab = buffer->jpg.frag_tab[0];\r\nif (frag_tab) {\r\nmem = bus_to_virt(le32_to_cpu(frag_tab));\r\nfor (off = 0; off < fh->buffers.buffer_size; off += PAGE_SIZE)\r\nClearPageReserved(virt_to_page(mem + off));\r\nkfree(mem);\r\nbuffer->jpg.frag_tab[0] = 0;\r\nbuffer->jpg.frag_tab[1] = 0;\r\n}\r\n} else {\r\nfor (j = 0; j < fh->buffers.buffer_size / PAGE_SIZE; j++) {\r\nfrag_tab = buffer->jpg.frag_tab[2 * j];\r\nif (!frag_tab)\r\nbreak;\r\nClearPageReserved(virt_to_page(bus_to_virt(le32_to_cpu(frag_tab))));\r\nfree_page((unsigned long)bus_to_virt(le32_to_cpu(frag_tab)));\r\nbuffer->jpg.frag_tab[2 * j] = 0;\r\nbuffer->jpg.frag_tab[2 * j + 1] = 0;\r\n}\r\n}\r\nfree_page((unsigned long)buffer->jpg.frag_tab);\r\nbuffer->jpg.frag_tab = NULL;\r\n}\r\nfh->buffers.allocated = 0;\r\n}\r\nstatic int\r\nzoran_v4l_set_format (struct zoran_fh *fh,\r\nint width,\r\nint height,\r\nconst struct zoran_format *format)\r\n{\r\nstruct zoran *zr = fh->zr;\r\nint bpp;\r\nif (height < BUZ_MIN_HEIGHT || width < BUZ_MIN_WIDTH ||\r\nheight > BUZ_MAX_HEIGHT || width > BUZ_MAX_WIDTH) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - wrong frame size (%dx%d)\n",\r\nZR_DEVNAME(zr), __func__, width, height);\r\nreturn -EINVAL;\r\n}\r\nbpp = (format->depth + 7) / 8;\r\nif (height * width * bpp > fh->buffers.buffer_size) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - video buffer size (%d kB) is too small\n",\r\nZR_DEVNAME(zr), __func__, fh->buffers.buffer_size >> 10);\r\nreturn -EINVAL;\r\n}\r\nif ((bpp == 2 && (width & 1)) || (bpp == 3 && (width & 3))) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - wrong frame alignment\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EINVAL;\r\n}\r\nfh->v4l_settings.width = width;\r\nfh->v4l_settings.height = height;\r\nfh->v4l_settings.format = format;\r\nfh->v4l_settings.bytesperline = bpp * fh->v4l_settings.width;\r\nreturn 0;\r\n}\r\nstatic int zoran_v4l_queue_frame(struct zoran_fh *fh, int num)\r\n{\r\nstruct zoran *zr = fh->zr;\r\nunsigned long flags;\r\nint res = 0;\r\nif (!fh->buffers.allocated) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - buffers not yet allocated\n",\r\nZR_DEVNAME(zr), __func__);\r\nres = -ENOMEM;\r\n}\r\nif (num >= fh->buffers.num_buffers || num < 0) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - buffer %d is out of range\n",\r\nZR_DEVNAME(zr), __func__, num);\r\nres = -EINVAL;\r\n}\r\nspin_lock_irqsave(&zr->spinlock, flags);\r\nif (fh->buffers.active == ZORAN_FREE) {\r\nif (zr->v4l_buffers.active == ZORAN_FREE) {\r\nzr->v4l_buffers = fh->buffers;\r\nfh->buffers.active = ZORAN_ACTIVE;\r\n} else {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - another session is already capturing\n",\r\nZR_DEVNAME(zr), __func__);\r\nres = -EBUSY;\r\n}\r\n}\r\nif (!res) {\r\nswitch (zr->v4l_buffers.buffer[num].state) {\r\ndefault:\r\ncase BUZ_STATE_PEND:\r\nif (zr->v4l_buffers.active == ZORAN_FREE) {\r\nfh->buffers.active = ZORAN_FREE;\r\nzr->v4l_buffers.allocated = 0;\r\n}\r\nres = -EBUSY;\r\nbreak;\r\ncase BUZ_STATE_DONE:\r\ndprintk(2,\r\nKERN_WARNING\r\n"%s: %s - queueing buffer %d in state DONE!?\n",\r\nZR_DEVNAME(zr), __func__, num);\r\ncase BUZ_STATE_USER:\r\nzr->v4l_pend[zr->v4l_pend_head++ & V4L_MASK_FRAME] = num;\r\nzr->v4l_buffers.buffer[num].state = BUZ_STATE_PEND;\r\nzr->v4l_buffers.buffer[num].bs.length =\r\nfh->v4l_settings.bytesperline *\r\nzr->v4l_settings.height;\r\nfh->buffers.buffer[num] = zr->v4l_buffers.buffer[num];\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&zr->spinlock, flags);\r\nif (!res && zr->v4l_buffers.active == ZORAN_FREE)\r\nzr->v4l_buffers.active = fh->buffers.active;\r\nreturn res;\r\n}\r\nstatic int v4l_sync(struct zoran_fh *fh, int frame)\r\n{\r\nstruct zoran *zr = fh->zr;\r\nunsigned long flags;\r\nif (fh->buffers.active == ZORAN_FREE) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - no grab active for this session\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EINVAL;\r\n}\r\nif (frame >= fh->buffers.num_buffers || frame < 0) {\r\ndprintk(1,\r\nKERN_ERR "%s: %s - frame %d is invalid\n",\r\nZR_DEVNAME(zr), __func__, frame);\r\nreturn -EINVAL;\r\n}\r\nif (zr->v4l_buffers.buffer[frame].state == BUZ_STATE_USER) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - attempt to sync on a buffer which was not queued?\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EPROTO;\r\n}\r\nif (!wait_event_interruptible_timeout(zr->v4l_capq,\r\n(zr->v4l_buffers.buffer[frame].state != BUZ_STATE_PEND), 10*HZ))\r\nreturn -ETIME;\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nif (zr->v4l_buffers.buffer[frame].state != BUZ_STATE_DONE)\r\ndprintk(2,\r\nKERN_ERR "%s: %s - internal state error\n",\r\nZR_DEVNAME(zr), __func__);\r\nzr->v4l_buffers.buffer[frame].state = BUZ_STATE_USER;\r\nfh->buffers.buffer[frame] = zr->v4l_buffers.buffer[frame];\r\nspin_lock_irqsave(&zr->spinlock, flags);\r\nif (zr->v4l_pend_tail == zr->v4l_pend_head) {\r\nzr36057_set_memgrab(zr, 0);\r\nif (zr->v4l_buffers.active == ZORAN_ACTIVE) {\r\nfh->buffers.active = zr->v4l_buffers.active = ZORAN_FREE;\r\nzr->v4l_buffers.allocated = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&zr->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic int zoran_jpg_queue_frame(struct zoran_fh *fh, int num,\r\nenum zoran_codec_mode mode)\r\n{\r\nstruct zoran *zr = fh->zr;\r\nunsigned long flags;\r\nint res = 0;\r\nif (!fh->buffers.allocated) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - buffers not yet allocated\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -ENOMEM;\r\n}\r\nif (num >= fh->buffers.num_buffers || num < 0) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - buffer %d out of range\n",\r\nZR_DEVNAME(zr), __func__, num);\r\nreturn -EINVAL;\r\n}\r\nif (zr->codec_mode == BUZ_MODE_IDLE) {\r\nzr->jpg_settings = fh->jpg_settings;\r\n} else if (zr->codec_mode != mode) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - codec in wrong mode\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EINVAL;\r\n}\r\nif (fh->buffers.active == ZORAN_FREE) {\r\nif (zr->jpg_buffers.active == ZORAN_FREE) {\r\nzr->jpg_buffers = fh->buffers;\r\nfh->buffers.active = ZORAN_ACTIVE;\r\n} else {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - another session is already capturing\n",\r\nZR_DEVNAME(zr), __func__);\r\nres = -EBUSY;\r\n}\r\n}\r\nif (!res && zr->codec_mode == BUZ_MODE_IDLE) {\r\nzr36057_enable_jpg(zr, mode);\r\n}\r\nspin_lock_irqsave(&zr->spinlock, flags);\r\nif (!res) {\r\nswitch (zr->jpg_buffers.buffer[num].state) {\r\ncase BUZ_STATE_DONE:\r\ndprintk(2,\r\nKERN_WARNING\r\n"%s: %s - queing frame in BUZ_STATE_DONE state!?\n",\r\nZR_DEVNAME(zr), __func__);\r\ncase BUZ_STATE_USER:\r\nzr->jpg_pend[zr->jpg_que_head++ & BUZ_MASK_FRAME] = num;\r\nzr->jpg_buffers.buffer[num].state = BUZ_STATE_PEND;\r\nfh->buffers.buffer[num] = zr->jpg_buffers.buffer[num];\r\nzoran_feed_stat_com(zr);\r\nbreak;\r\ndefault:\r\ncase BUZ_STATE_DMA:\r\ncase BUZ_STATE_PEND:\r\nif (zr->jpg_buffers.active == ZORAN_FREE) {\r\nfh->buffers.active = ZORAN_FREE;\r\nzr->jpg_buffers.allocated = 0;\r\n}\r\nres = -EBUSY;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&zr->spinlock, flags);\r\nif (!res && zr->jpg_buffers.active == ZORAN_FREE)\r\nzr->jpg_buffers.active = fh->buffers.active;\r\nreturn res;\r\n}\r\nstatic int jpg_qbuf(struct zoran_fh *fh, int frame, enum zoran_codec_mode mode)\r\n{\r\nstruct zoran *zr = fh->zr;\r\nint res = 0;\r\nif (frame < 0) {\r\nif (zr->codec_mode == mode) {\r\nif (fh->buffers.active == ZORAN_FREE) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s(-1) - session not active\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EINVAL;\r\n}\r\nfh->buffers.active = zr->jpg_buffers.active = ZORAN_FREE;\r\nzr->jpg_buffers.allocated = 0;\r\nzr36057_enable_jpg(zr, BUZ_MODE_IDLE);\r\nreturn 0;\r\n} else {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - stop streaming but not in streaming mode\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif ((res = zoran_jpg_queue_frame(fh, frame, mode)))\r\nreturn res;\r\nif (!res && zr->jpg_que_head == 1)\r\njpeg_start(zr);\r\nreturn res;\r\n}\r\nstatic int jpg_sync(struct zoran_fh *fh, struct zoran_sync *bs)\r\n{\r\nstruct zoran *zr = fh->zr;\r\nunsigned long flags;\r\nint frame;\r\nif (fh->buffers.active == ZORAN_FREE) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - capture is not currently active\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EINVAL;\r\n}\r\nif (zr->codec_mode != BUZ_MODE_MOTION_DECOMPRESS &&\r\nzr->codec_mode != BUZ_MODE_MOTION_COMPRESS) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - codec not in streaming mode\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EINVAL;\r\n}\r\nif (!wait_event_interruptible_timeout(zr->jpg_capq,\r\n(zr->jpg_que_tail != zr->jpg_dma_tail ||\r\nzr->jpg_dma_tail == zr->jpg_dma_head),\r\n10*HZ)) {\r\nint isr;\r\nbtand(~ZR36057_JMC_Go_en, ZR36057_JMC);\r\nudelay(1);\r\nzr->codec->control(zr->codec, CODEC_G_STATUS,\r\nsizeof(isr), &isr);\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - timeout: codec isr=0x%02x\n",\r\nZR_DEVNAME(zr), __func__, isr);\r\nreturn -ETIME;\r\n}\r\nif (signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nspin_lock_irqsave(&zr->spinlock, flags);\r\nif (zr->jpg_dma_tail != zr->jpg_dma_head)\r\nframe = zr->jpg_pend[zr->jpg_que_tail++ & BUZ_MASK_FRAME];\r\nelse\r\nframe = zr->jpg_pend[zr->jpg_que_tail & BUZ_MASK_FRAME];\r\nif (zr->jpg_buffers.buffer[frame].state != BUZ_STATE_DONE)\r\ndprintk(2,\r\nKERN_ERR "%s: %s - internal state error\n",\r\nZR_DEVNAME(zr), __func__);\r\n*bs = zr->jpg_buffers.buffer[frame].bs;\r\nbs->frame = frame;\r\nzr->jpg_buffers.buffer[frame].state = BUZ_STATE_USER;\r\nfh->buffers.buffer[frame] = zr->jpg_buffers.buffer[frame];\r\nspin_unlock_irqrestore(&zr->spinlock, flags);\r\nreturn 0;\r\n}\r\nstatic void zoran_open_init_session(struct zoran_fh *fh)\r\n{\r\nint i;\r\nstruct zoran *zr = fh->zr;\r\nmap_mode_raw(fh);\r\nfh->overlay_settings = zr->overlay_settings;\r\nfh->overlay_settings.is_set = 0;\r\nfh->overlay_settings.format = zr->overlay_settings.format;\r\nfh->overlay_active = ZORAN_FREE;\r\nfh->v4l_settings = zr->v4l_settings;\r\nfh->jpg_settings = zr->jpg_settings;\r\nmemset(&fh->buffers, 0, sizeof(fh->buffers));\r\nfor (i = 0; i < MAX_FRAME; i++) {\r\nfh->buffers.buffer[i].state = BUZ_STATE_USER;\r\nfh->buffers.buffer[i].bs.frame = i;\r\n}\r\nfh->buffers.allocated = 0;\r\nfh->buffers.active = ZORAN_FREE;\r\n}\r\nstatic void zoran_close_end_session(struct zoran_fh *fh)\r\n{\r\nstruct zoran *zr = fh->zr;\r\nif (fh->overlay_active != ZORAN_FREE) {\r\nfh->overlay_active = zr->overlay_active = ZORAN_FREE;\r\nzr->v4l_overlay_active = 0;\r\nif (!zr->v4l_memgrab_active)\r\nzr36057_overlay(zr, 0);\r\nzr->overlay_mask = NULL;\r\n}\r\nif (fh->map_mode == ZORAN_MAP_MODE_RAW) {\r\nif (fh->buffers.active != ZORAN_FREE) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&zr->spinlock, flags);\r\nzr36057_set_memgrab(zr, 0);\r\nzr->v4l_buffers.allocated = 0;\r\nzr->v4l_buffers.active = fh->buffers.active = ZORAN_FREE;\r\nspin_unlock_irqrestore(&zr->spinlock, flags);\r\n}\r\nif (fh->buffers.allocated)\r\nv4l_fbuffer_free(fh);\r\n} else {\r\nif (fh->buffers.active != ZORAN_FREE) {\r\nzr36057_enable_jpg(zr, BUZ_MODE_IDLE);\r\nzr->jpg_buffers.allocated = 0;\r\nzr->jpg_buffers.active = fh->buffers.active = ZORAN_FREE;\r\n}\r\nif (fh->buffers.allocated)\r\njpg_fbuffer_free(fh);\r\n}\r\n}\r\nstatic int zoran_open(struct file *file)\r\n{\r\nstruct zoran *zr = video_drvdata(file);\r\nstruct zoran_fh *fh;\r\nint res, first_open = 0;\r\ndprintk(2, KERN_INFO "%s: %s(%s, pid=[%d]), users(-)=%d\n",\r\nZR_DEVNAME(zr), __func__, current->comm, task_pid_nr(current), zr->user + 1);\r\nmutex_lock(&zr->other_lock);\r\nif (zr->user >= 2048) {\r\ndprintk(1, KERN_ERR "%s: too many users (%d) on device\n",\r\nZR_DEVNAME(zr), zr->user);\r\nres = -EBUSY;\r\ngoto fail_unlock;\r\n}\r\nfh = kzalloc(sizeof(struct zoran_fh), GFP_KERNEL);\r\nif (!fh) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - allocation of zoran_fh failed\n",\r\nZR_DEVNAME(zr), __func__);\r\nres = -ENOMEM;\r\ngoto fail_unlock;\r\n}\r\nfh->overlay_mask =\r\nkmalloc(((768 + 31) / 32) * 576 * 4, GFP_KERNEL);\r\nif (!fh->overlay_mask) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - allocation of overlay_mask failed\n",\r\nZR_DEVNAME(zr), __func__);\r\nres = -ENOMEM;\r\ngoto fail_fh;\r\n}\r\nif (zr->user++ == 0)\r\nfirst_open = 1;\r\nif (first_open) {\r\nzr36057_restart(zr);\r\nzoran_open_init_params(zr);\r\nzoran_init_hardware(zr);\r\nbtor(ZR36057_ICR_IntPinEn, ZR36057_ICR);\r\n}\r\nfile->private_data = fh;\r\nfh->zr = zr;\r\nzoran_open_init_session(fh);\r\nmutex_unlock(&zr->other_lock);\r\nreturn 0;\r\nfail_fh:\r\nkfree(fh);\r\nfail_unlock:\r\nmutex_unlock(&zr->other_lock);\r\ndprintk(2, KERN_INFO "%s: open failed (%d), users(-)=%d\n",\r\nZR_DEVNAME(zr), res, zr->user);\r\nreturn res;\r\n}\r\nstatic int\r\nzoran_close(struct file *file)\r\n{\r\nstruct zoran_fh *fh = file->private_data;\r\nstruct zoran *zr = fh->zr;\r\ndprintk(2, KERN_INFO "%s: %s(%s, pid=[%d]), users(+)=%d\n",\r\nZR_DEVNAME(zr), __func__, current->comm, task_pid_nr(current), zr->user - 1);\r\nmutex_lock(&zr->other_lock);\r\nzoran_close_end_session(fh);\r\nif (zr->user-- == 1) {\r\nwake_up_interruptible(&zr->jpg_capq);\r\nzr36057_enable_jpg(zr, BUZ_MODE_IDLE);\r\nzr->jpg_buffers.allocated = 0;\r\nzr->jpg_buffers.active = ZORAN_FREE;\r\nbtand(~ZR36057_ICR_IntPinEn, ZR36057_ICR);\r\nif (zr36067_debug > 1)\r\nprint_interrupts(zr);\r\nzr->v4l_overlay_active = 0;\r\nzr36057_overlay(zr, 0);\r\nzr->overlay_mask = NULL;\r\nwake_up_interruptible(&zr->v4l_capq);\r\nzr36057_set_memgrab(zr, 0);\r\nzr->v4l_buffers.allocated = 0;\r\nzr->v4l_buffers.active = ZORAN_FREE;\r\nzoran_set_pci_master(zr, 0);\r\nif (!pass_through) {\r\ndecoder_call(zr, video, s_stream, 0);\r\nencoder_call(zr, video, s_routing, 2, 0, 0);\r\n}\r\n}\r\nmutex_unlock(&zr->other_lock);\r\nfile->private_data = NULL;\r\nkfree(fh->overlay_mask);\r\nkfree(fh);\r\ndprintk(4, KERN_INFO "%s: %s done\n", ZR_DEVNAME(zr), __func__);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nzoran_read (struct file *file,\r\nchar __user *data,\r\nsize_t count,\r\nloff_t *ppos)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t\r\nzoran_write (struct file *file,\r\nconst char __user *data,\r\nsize_t count,\r\nloff_t *ppos)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int setup_fbuffer(struct zoran_fh *fh,\r\nvoid *base,\r\nconst struct zoran_format *fmt,\r\nint width,\r\nint height,\r\nint bytesperline)\r\n{\r\nstruct zoran *zr = fh->zr;\r\nif (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nif (pci_pci_problems & (PCIPCI_FAIL | PCIAGP_FAIL | PCIPCI_ALIMAGIK))\r\nreturn -ENXIO;\r\nif (!bytesperline)\r\nbytesperline = width * ((fmt->depth + 7) & ~7) / 8;\r\n#if 0\r\nif (zr->overlay_active) {\r\ndprintk(3,\r\nKERN_ERR\r\n"%s: %s - forced overlay turnoff because framebuffer changed\n",\r\nZR_DEVNAME(zr), __func__);\r\nzr36057_overlay(zr, 0);\r\n}\r\n#endif\r\nif (!(fmt->flags & ZORAN_FORMAT_OVERLAY)) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - no valid overlay format given\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EINVAL;\r\n}\r\nif (height <= 0 || width <= 0 || bytesperline <= 0) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - invalid height/width/bpl value (%d|%d|%d)\n",\r\nZR_DEVNAME(zr), __func__, width, height, bytesperline);\r\nreturn -EINVAL;\r\n}\r\nif (bytesperline & 3) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - bytesperline (%d) must be 4-byte aligned\n",\r\nZR_DEVNAME(zr), __func__, bytesperline);\r\nreturn -EINVAL;\r\n}\r\nzr->vbuf_base = (void *) ((unsigned long) base & ~3);\r\nzr->vbuf_height = height;\r\nzr->vbuf_width = width;\r\nzr->vbuf_depth = fmt->depth;\r\nzr->overlay_settings.format = fmt;\r\nzr->vbuf_bytesperline = bytesperline;\r\nzr->overlay_settings.is_set = 0;\r\nreturn 0;\r\n}\r\nstatic int setup_window(struct zoran_fh *fh,\r\nint x,\r\nint y,\r\nint width,\r\nint height,\r\nstruct v4l2_clip __user *clips,\r\nunsigned int clipcount,\r\nvoid __user *bitmap)\r\n{\r\nstruct zoran *zr = fh->zr;\r\nstruct v4l2_clip *vcp = NULL;\r\nint on, end;\r\nif (!zr->vbuf_base) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - frame buffer has to be set first\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EINVAL;\r\n}\r\nif (!fh->overlay_settings.format) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - no overlay format set\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EINVAL;\r\n}\r\nif (clipcount > 2048) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - invalid clipcount\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EINVAL;\r\n}\r\nif (zr->vbuf_depth == 15 || zr->vbuf_depth == 16) {\r\nend = (x + width) & ~1;\r\nx = (x + 1) & ~1;\r\nwidth = end - x;\r\n}\r\nif (zr->vbuf_depth == 24) {\r\nend = (x + width) & ~3;\r\nx = (x + 3) & ~3;\r\nwidth = end - x;\r\n}\r\nif (width > BUZ_MAX_WIDTH)\r\nwidth = BUZ_MAX_WIDTH;\r\nif (height > BUZ_MAX_HEIGHT)\r\nheight = BUZ_MAX_HEIGHT;\r\nif (width < BUZ_MIN_WIDTH || height < BUZ_MIN_HEIGHT ||\r\nwidth > BUZ_MAX_WIDTH || height > BUZ_MAX_HEIGHT) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - width = %d or height = %d invalid\n",\r\nZR_DEVNAME(zr), __func__, width, height);\r\nreturn -EINVAL;\r\n}\r\nfh->overlay_settings.x = x;\r\nfh->overlay_settings.y = y;\r\nfh->overlay_settings.width = width;\r\nfh->overlay_settings.height = height;\r\nfh->overlay_settings.clipcount = clipcount;\r\non = zr->v4l_overlay_active && !zr->v4l_memgrab_active &&\r\nzr->overlay_active != ZORAN_FREE &&\r\nfh->overlay_active != ZORAN_FREE;\r\nif (on)\r\nzr36057_overlay(zr, 0);\r\nif (bitmap) {\r\nfh->overlay_settings.clipcount = 1;\r\nif (copy_from_user(fh->overlay_mask, bitmap,\r\n(width * height + 7) / 8)) {\r\nreturn -EFAULT;\r\n}\r\n} else if (clipcount) {\r\nvcp = vmalloc(sizeof(struct v4l2_clip) * (clipcount + 4));\r\nif (vcp == NULL) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - Alloc of clip mask failed\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -ENOMEM;\r\n}\r\nif (copy_from_user\r\n(vcp, clips, sizeof(struct v4l2_clip) * clipcount)) {\r\nvfree(vcp);\r\nreturn -EFAULT;\r\n}\r\nwrite_overlay_mask(fh, vcp, clipcount);\r\nvfree(vcp);\r\n}\r\nfh->overlay_settings.is_set = 1;\r\nif (fh->overlay_active != ZORAN_FREE &&\r\nzr->overlay_active != ZORAN_FREE)\r\nzr->overlay_settings = fh->overlay_settings;\r\nif (on)\r\nzr36057_overlay(zr, 1);\r\nreturn wait_grab_pending(zr);\r\n}\r\nstatic int setup_overlay(struct zoran_fh *fh, int on)\r\n{\r\nstruct zoran *zr = fh->zr;\r\nif ((on && fh->overlay_active != ZORAN_FREE) ||\r\n(!on && fh->overlay_active == ZORAN_FREE))\r\nreturn 0;\r\nif (on && zr->overlay_active != ZORAN_FREE &&\r\nfh->overlay_active == ZORAN_FREE) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - overlay is already active for another session\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EBUSY;\r\n}\r\nif (!on && zr->overlay_active != ZORAN_FREE &&\r\nfh->overlay_active == ZORAN_FREE) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - you cannot cancel someone else's session\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EPERM;\r\n}\r\nif (on == 0) {\r\nzr->overlay_active = fh->overlay_active = ZORAN_FREE;\r\nzr->v4l_overlay_active = 0;\r\nif (!zr->v4l_memgrab_active)\r\nzr36057_overlay(zr, 0);\r\nzr->overlay_mask = NULL;\r\n} else {\r\nif (!zr->vbuf_base || !fh->overlay_settings.is_set) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - buffer or window not set\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EINVAL;\r\n}\r\nif (!fh->overlay_settings.format) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - no overlay format set\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EINVAL;\r\n}\r\nzr->overlay_active = fh->overlay_active = ZORAN_LOCKED;\r\nzr->v4l_overlay_active = 1;\r\nzr->overlay_mask = fh->overlay_mask;\r\nzr->overlay_settings = fh->overlay_settings;\r\nif (!zr->v4l_memgrab_active)\r\nzr36057_overlay(zr, 1);\r\n}\r\nreturn wait_grab_pending(zr);\r\n}\r\nstatic int zoran_v4l2_buffer_status(struct zoran_fh *fh,\r\nstruct v4l2_buffer *buf, int num)\r\n{\r\nstruct zoran *zr = fh->zr;\r\nunsigned long flags;\r\nbuf->flags = V4L2_BUF_FLAG_MAPPED | V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nswitch (fh->map_mode) {\r\ncase ZORAN_MAP_MODE_RAW:\r\nif (num < 0 || num >= fh->buffers.num_buffers ||\r\n!fh->buffers.allocated) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - wrong number or buffers not allocated\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&zr->spinlock, flags);\r\ndprintk(3,\r\nKERN_DEBUG\r\n"%s: %s() - raw active=%c, buffer %d: state=%c, map=%c\n",\r\nZR_DEVNAME(zr), __func__,\r\n"FAL"[fh->buffers.active], num,\r\n"UPMD"[zr->v4l_buffers.buffer[num].state],\r\nfh->buffers.buffer[num].map ? 'Y' : 'N');\r\nspin_unlock_irqrestore(&zr->spinlock, flags);\r\nbuf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nbuf->length = fh->buffers.buffer_size;\r\nbuf->bytesused = fh->buffers.buffer[num].bs.length;\r\nif (fh->buffers.buffer[num].state == BUZ_STATE_DONE ||\r\nfh->buffers.buffer[num].state == BUZ_STATE_USER) {\r\nbuf->sequence = fh->buffers.buffer[num].bs.seq;\r\nbuf->flags |= V4L2_BUF_FLAG_DONE;\r\nbuf->timestamp = fh->buffers.buffer[num].bs.timestamp;\r\n} else {\r\nbuf->flags |= V4L2_BUF_FLAG_QUEUED;\r\n}\r\nif (fh->v4l_settings.height <= BUZ_MAX_HEIGHT / 2)\r\nbuf->field = V4L2_FIELD_TOP;\r\nelse\r\nbuf->field = V4L2_FIELD_INTERLACED;\r\nbreak;\r\ncase ZORAN_MAP_MODE_JPG_REC:\r\ncase ZORAN_MAP_MODE_JPG_PLAY:\r\nif (num < 0 || num >= fh->buffers.num_buffers ||\r\n!fh->buffers.allocated) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - wrong number or buffers not allocated\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EINVAL;\r\n}\r\nbuf->type = (fh->map_mode == ZORAN_MAP_MODE_JPG_REC) ?\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE :\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nbuf->length = fh->buffers.buffer_size;\r\nif (fh->buffers.buffer[num].state == BUZ_STATE_DONE ||\r\nfh->buffers.buffer[num].state == BUZ_STATE_USER) {\r\nbuf->sequence = fh->buffers.buffer[num].bs.seq;\r\nbuf->timestamp = fh->buffers.buffer[num].bs.timestamp;\r\nbuf->bytesused = fh->buffers.buffer[num].bs.length;\r\nbuf->flags |= V4L2_BUF_FLAG_DONE;\r\n} else {\r\nbuf->flags |= V4L2_BUF_FLAG_QUEUED;\r\n}\r\nif (fh->jpg_settings.TmpDcm != 1)\r\nbuf->field = fh->jpg_settings.odd_even ?\r\nV4L2_FIELD_TOP : V4L2_FIELD_BOTTOM;\r\nelse\r\nbuf->field = fh->jpg_settings.odd_even ?\r\nV4L2_FIELD_SEQ_TB : V4L2_FIELD_SEQ_BT;\r\nbreak;\r\ndefault:\r\ndprintk(5,\r\nKERN_ERR\r\n"%s: %s - invalid buffer type|map_mode (%d|%d)\n",\r\nZR_DEVNAME(zr), __func__, buf->type, fh->map_mode);\r\nreturn -EINVAL;\r\n}\r\nbuf->memory = V4L2_MEMORY_MMAP;\r\nbuf->index = num;\r\nbuf->m.offset = buf->length * num;\r\nreturn 0;\r\n}\r\nstatic int\r\nzoran_set_norm (struct zoran *zr,\r\nv4l2_std_id norm)\r\n{\r\nint on;\r\nif (zr->v4l_buffers.active != ZORAN_FREE ||\r\nzr->jpg_buffers.active != ZORAN_FREE) {\r\ndprintk(1,\r\nKERN_WARNING\r\n"%s: %s called while in playback/capture mode\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EBUSY;\r\n}\r\nif (!(norm & zr->card.norms)) {\r\ndprintk(1,\r\nKERN_ERR "%s: %s - unsupported norm %llx\n",\r\nZR_DEVNAME(zr), __func__, norm);\r\nreturn -EINVAL;\r\n}\r\nif (norm & V4L2_STD_SECAM)\r\nzr->timing = zr->card.tvn[2];\r\nelse if (norm & V4L2_STD_NTSC)\r\nzr->timing = zr->card.tvn[1];\r\nelse\r\nzr->timing = zr->card.tvn[0];\r\non = zr->overlay_active && !zr->v4l_memgrab_active;\r\nif (on)\r\nzr36057_overlay(zr, 0);\r\ndecoder_call(zr, core, s_std, norm);\r\nencoder_call(zr, video, s_std_output, norm);\r\nif (on)\r\nzr36057_overlay(zr, 1);\r\nzr->norm = norm;\r\nreturn 0;\r\n}\r\nstatic int\r\nzoran_set_input (struct zoran *zr,\r\nint input)\r\n{\r\nif (input == zr->input) {\r\nreturn 0;\r\n}\r\nif (zr->v4l_buffers.active != ZORAN_FREE ||\r\nzr->jpg_buffers.active != ZORAN_FREE) {\r\ndprintk(1,\r\nKERN_WARNING\r\n"%s: %s called while in playback/capture mode\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EBUSY;\r\n}\r\nif (input < 0 || input >= zr->card.inputs) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - unnsupported input %d\n",\r\nZR_DEVNAME(zr), __func__, input);\r\nreturn -EINVAL;\r\n}\r\nzr->input = input;\r\ndecoder_call(zr, video, s_routing,\r\nzr->card.input[input].muxsel, 0, 0);\r\nreturn 0;\r\n}\r\nstatic int zoran_querycap(struct file *file, void *__fh, struct v4l2_capability *cap)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nmemset(cap, 0, sizeof(*cap));\r\nstrncpy(cap->card, ZR_DEVNAME(zr), sizeof(cap->card)-1);\r\nstrncpy(cap->driver, "zoran", sizeof(cap->driver)-1);\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "PCI:%s",\r\npci_name(zr->pci_dev));\r\ncap->capabilities = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_VIDEO_OVERLAY;\r\nreturn 0;\r\n}\r\nstatic int zoran_enum_fmt(struct zoran *zr, struct v4l2_fmtdesc *fmt, int flag)\r\n{\r\nunsigned int num, i;\r\nfor (num = i = 0; i < NUM_FORMATS; i++) {\r\nif (zoran_formats[i].flags & flag && num++ == fmt->index) {\r\nstrncpy(fmt->description, zoran_formats[i].name,\r\nsizeof(fmt->description) - 1);\r\nfmt->pixelformat = zoran_formats[i].fourcc;\r\nif (zoran_formats[i].flags & ZORAN_FORMAT_COMPRESSED)\r\nfmt->flags |= V4L2_FMT_FLAG_COMPRESSED;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int zoran_enum_fmt_vid_cap(struct file *file, void *__fh,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nreturn zoran_enum_fmt(zr, f, ZORAN_FORMAT_CAPTURE);\r\n}\r\nstatic int zoran_enum_fmt_vid_out(struct file *file, void *__fh,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nreturn zoran_enum_fmt(zr, f, ZORAN_FORMAT_PLAYBACK);\r\n}\r\nstatic int zoran_enum_fmt_vid_overlay(struct file *file, void *__fh,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nreturn zoran_enum_fmt(zr, f, ZORAN_FORMAT_OVERLAY);\r\n}\r\nstatic int zoran_g_fmt_vid_out(struct file *file, void *__fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nmutex_lock(&zr->resource_lock);\r\nfmt->fmt.pix.width = fh->jpg_settings.img_width / fh->jpg_settings.HorDcm;\r\nfmt->fmt.pix.height = fh->jpg_settings.img_height * 2 /\r\n(fh->jpg_settings.VerDcm * fh->jpg_settings.TmpDcm);\r\nfmt->fmt.pix.sizeimage = zoran_v4l2_calc_bufsize(&fh->jpg_settings);\r\nfmt->fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG;\r\nif (fh->jpg_settings.TmpDcm == 1)\r\nfmt->fmt.pix.field = (fh->jpg_settings.odd_even ?\r\nV4L2_FIELD_SEQ_TB : V4L2_FIELD_SEQ_BT);\r\nelse\r\nfmt->fmt.pix.field = (fh->jpg_settings.odd_even ?\r\nV4L2_FIELD_TOP : V4L2_FIELD_BOTTOM);\r\nfmt->fmt.pix.bytesperline = 0;\r\nfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nmutex_unlock(&zr->resource_lock);\r\nreturn 0;\r\n}\r\nstatic int zoran_g_fmt_vid_cap(struct file *file, void *__fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nif (fh->map_mode != ZORAN_MAP_MODE_RAW)\r\nreturn zoran_g_fmt_vid_out(file, fh, fmt);\r\nmutex_lock(&zr->resource_lock);\r\nfmt->fmt.pix.width = fh->v4l_settings.width;\r\nfmt->fmt.pix.height = fh->v4l_settings.height;\r\nfmt->fmt.pix.sizeimage = fh->v4l_settings.bytesperline *\r\nfh->v4l_settings.height;\r\nfmt->fmt.pix.pixelformat = fh->v4l_settings.format->fourcc;\r\nfmt->fmt.pix.colorspace = fh->v4l_settings.format->colorspace;\r\nfmt->fmt.pix.bytesperline = fh->v4l_settings.bytesperline;\r\nif (BUZ_MAX_HEIGHT < (fh->v4l_settings.height * 2))\r\nfmt->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nelse\r\nfmt->fmt.pix.field = V4L2_FIELD_TOP;\r\nmutex_unlock(&zr->resource_lock);\r\nreturn 0;\r\n}\r\nstatic int zoran_g_fmt_vid_overlay(struct file *file, void *__fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nmutex_lock(&zr->resource_lock);\r\nfmt->fmt.win.w.left = fh->overlay_settings.x;\r\nfmt->fmt.win.w.top = fh->overlay_settings.y;\r\nfmt->fmt.win.w.width = fh->overlay_settings.width;\r\nfmt->fmt.win.w.height = fh->overlay_settings.height;\r\nif (fh->overlay_settings.width * 2 > BUZ_MAX_HEIGHT)\r\nfmt->fmt.win.field = V4L2_FIELD_INTERLACED;\r\nelse\r\nfmt->fmt.win.field = V4L2_FIELD_TOP;\r\nmutex_unlock(&zr->resource_lock);\r\nreturn 0;\r\n}\r\nstatic int zoran_try_fmt_vid_overlay(struct file *file, void *__fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nmutex_lock(&zr->resource_lock);\r\nif (fmt->fmt.win.w.width > BUZ_MAX_WIDTH)\r\nfmt->fmt.win.w.width = BUZ_MAX_WIDTH;\r\nif (fmt->fmt.win.w.width < BUZ_MIN_WIDTH)\r\nfmt->fmt.win.w.width = BUZ_MIN_WIDTH;\r\nif (fmt->fmt.win.w.height > BUZ_MAX_HEIGHT)\r\nfmt->fmt.win.w.height = BUZ_MAX_HEIGHT;\r\nif (fmt->fmt.win.w.height < BUZ_MIN_HEIGHT)\r\nfmt->fmt.win.w.height = BUZ_MIN_HEIGHT;\r\nmutex_unlock(&zr->resource_lock);\r\nreturn 0;\r\n}\r\nstatic int zoran_try_fmt_vid_out(struct file *file, void *__fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nstruct zoran_jpg_settings settings;\r\nint res = 0;\r\nif (fmt->fmt.pix.pixelformat != V4L2_PIX_FMT_MJPEG)\r\nreturn -EINVAL;\r\nmutex_lock(&zr->resource_lock);\r\nsettings = fh->jpg_settings;\r\nif ((fmt->fmt.pix.height * 2) > BUZ_MAX_HEIGHT)\r\nsettings.TmpDcm = 1;\r\nelse\r\nsettings.TmpDcm = 2;\r\nsettings.decimation = 0;\r\nif (fmt->fmt.pix.height <= fh->jpg_settings.img_height / 2)\r\nsettings.VerDcm = 2;\r\nelse\r\nsettings.VerDcm = 1;\r\nif (fmt->fmt.pix.width <= fh->jpg_settings.img_width / 4)\r\nsettings.HorDcm = 4;\r\nelse if (fmt->fmt.pix.width <= fh->jpg_settings.img_width / 2)\r\nsettings.HorDcm = 2;\r\nelse\r\nsettings.HorDcm = 1;\r\nif (settings.TmpDcm == 1)\r\nsettings.field_per_buff = 2;\r\nelse\r\nsettings.field_per_buff = 1;\r\nif (settings.HorDcm > 1) {\r\nsettings.img_x = (BUZ_MAX_WIDTH == 720) ? 8 : 0;\r\nsettings.img_width = (BUZ_MAX_WIDTH == 720) ? 704 : BUZ_MAX_WIDTH;\r\n} else {\r\nsettings.img_x = 0;\r\nsettings.img_width = BUZ_MAX_WIDTH;\r\n}\r\nres = zoran_check_jpg_settings(zr, &settings, 1);\r\nif (res)\r\ngoto tryfmt_unlock_and_return;\r\nfmt->fmt.pix.width = settings.img_width / settings.HorDcm;\r\nfmt->fmt.pix.height = settings.img_height * 2 /\r\n(settings.TmpDcm * settings.VerDcm);\r\nif (settings.TmpDcm == 1)\r\nfmt->fmt.pix.field = (fh->jpg_settings.odd_even ?\r\nV4L2_FIELD_SEQ_TB : V4L2_FIELD_SEQ_BT);\r\nelse\r\nfmt->fmt.pix.field = (fh->jpg_settings.odd_even ?\r\nV4L2_FIELD_TOP : V4L2_FIELD_BOTTOM);\r\nfmt->fmt.pix.sizeimage = zoran_v4l2_calc_bufsize(&settings);\r\nfmt->fmt.pix.bytesperline = 0;\r\nfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\ntryfmt_unlock_and_return:\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic int zoran_try_fmt_vid_cap(struct file *file, void *__fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nint bpp;\r\nint i;\r\nif (fmt->fmt.pix.pixelformat == V4L2_PIX_FMT_MJPEG)\r\nreturn zoran_try_fmt_vid_out(file, fh, fmt);\r\nmutex_lock(&zr->resource_lock);\r\nfor (i = 0; i < NUM_FORMATS; i++)\r\nif (zoran_formats[i].fourcc == fmt->fmt.pix.pixelformat)\r\nbreak;\r\nif (i == NUM_FORMATS) {\r\nmutex_unlock(&zr->resource_lock);\r\nreturn -EINVAL;\r\n}\r\nbpp = DIV_ROUND_UP(zoran_formats[i].depth, 8);\r\nv4l_bound_align_image(\r\n&fmt->fmt.pix.width, BUZ_MIN_WIDTH, BUZ_MAX_WIDTH, bpp == 2 ? 1 : 2,\r\n&fmt->fmt.pix.height, BUZ_MIN_HEIGHT, BUZ_MAX_HEIGHT, 0, 0);\r\nmutex_unlock(&zr->resource_lock);\r\nreturn 0;\r\n}\r\nstatic int zoran_s_fmt_vid_overlay(struct file *file, void *__fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nint res;\r\ndprintk(3, "x=%d, y=%d, w=%d, h=%d, cnt=%d, map=0x%p\n",\r\nfmt->fmt.win.w.left, fmt->fmt.win.w.top,\r\nfmt->fmt.win.w.width,\r\nfmt->fmt.win.w.height,\r\nfmt->fmt.win.clipcount,\r\nfmt->fmt.win.bitmap);\r\nmutex_lock(&zr->resource_lock);\r\nres = setup_window(fh, fmt->fmt.win.w.left, fmt->fmt.win.w.top,\r\nfmt->fmt.win.w.width, fmt->fmt.win.w.height,\r\n(struct v4l2_clip __user *)fmt->fmt.win.clips,\r\nfmt->fmt.win.clipcount, fmt->fmt.win.bitmap);\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic int zoran_s_fmt_vid_out(struct file *file, void *__fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\n__le32 printformat = __cpu_to_le32(fmt->fmt.pix.pixelformat);\r\nstruct zoran_jpg_settings settings;\r\nint res = 0;\r\ndprintk(3, "size=%dx%d, fmt=0x%x (%4.4s)\n",\r\nfmt->fmt.pix.width, fmt->fmt.pix.height,\r\nfmt->fmt.pix.pixelformat,\r\n(char *) &printformat);\r\nif (fmt->fmt.pix.pixelformat != V4L2_PIX_FMT_MJPEG)\r\nreturn -EINVAL;\r\nmutex_lock(&zr->resource_lock);\r\nif (fh->buffers.allocated) {\r\ndprintk(1, KERN_ERR "%s: VIDIOC_S_FMT - cannot change capture mode\n",\r\nZR_DEVNAME(zr));\r\nres = -EBUSY;\r\ngoto sfmtjpg_unlock_and_return;\r\n}\r\nsettings = fh->jpg_settings;\r\nif (fmt->fmt.pix.height * 2 > BUZ_MAX_HEIGHT)\r\nsettings.TmpDcm = 1;\r\nelse\r\nsettings.TmpDcm = 2;\r\nsettings.decimation = 0;\r\nif (fmt->fmt.pix.height <= fh->jpg_settings.img_height / 2)\r\nsettings.VerDcm = 2;\r\nelse\r\nsettings.VerDcm = 1;\r\nif (fmt->fmt.pix.width <= fh->jpg_settings.img_width / 4)\r\nsettings.HorDcm = 4;\r\nelse if (fmt->fmt.pix.width <= fh->jpg_settings.img_width / 2)\r\nsettings.HorDcm = 2;\r\nelse\r\nsettings.HorDcm = 1;\r\nif (settings.TmpDcm == 1)\r\nsettings.field_per_buff = 2;\r\nelse\r\nsettings.field_per_buff = 1;\r\nif (settings.HorDcm > 1) {\r\nsettings.img_x = (BUZ_MAX_WIDTH == 720) ? 8 : 0;\r\nsettings.img_width = (BUZ_MAX_WIDTH == 720) ? 704 : BUZ_MAX_WIDTH;\r\n} else {\r\nsettings.img_x = 0;\r\nsettings.img_width = BUZ_MAX_WIDTH;\r\n}\r\nres = zoran_check_jpg_settings(zr, &settings, 0);\r\nif (res)\r\ngoto sfmtjpg_unlock_and_return;\r\nfh->jpg_settings = settings;\r\nmap_mode_jpg(fh, fmt->type == V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nfh->buffers.buffer_size = zoran_v4l2_calc_bufsize(&fh->jpg_settings);\r\nfmt->fmt.pix.width = settings.img_width / settings.HorDcm;\r\nfmt->fmt.pix.height = settings.img_height * 2 /\r\n(settings.TmpDcm * settings.VerDcm);\r\nif (settings.TmpDcm == 1)\r\nfmt->fmt.pix.field = (fh->jpg_settings.odd_even ?\r\nV4L2_FIELD_SEQ_TB : V4L2_FIELD_SEQ_BT);\r\nelse\r\nfmt->fmt.pix.field = (fh->jpg_settings.odd_even ?\r\nV4L2_FIELD_TOP : V4L2_FIELD_BOTTOM);\r\nfmt->fmt.pix.bytesperline = 0;\r\nfmt->fmt.pix.sizeimage = fh->buffers.buffer_size;\r\nfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nsfmtjpg_unlock_and_return:\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic int zoran_s_fmt_vid_cap(struct file *file, void *__fh,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nint i;\r\nint res = 0;\r\nif (fmt->fmt.pix.pixelformat == V4L2_PIX_FMT_MJPEG)\r\nreturn zoran_s_fmt_vid_out(file, fh, fmt);\r\nfor (i = 0; i < NUM_FORMATS; i++)\r\nif (fmt->fmt.pix.pixelformat == zoran_formats[i].fourcc)\r\nbreak;\r\nif (i == NUM_FORMATS) {\r\ndprintk(1, KERN_ERR "%s: VIDIOC_S_FMT - unknown/unsupported format 0x%x\n",\r\nZR_DEVNAME(zr), fmt->fmt.pix.pixelformat);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&zr->resource_lock);\r\nif ((fh->map_mode != ZORAN_MAP_MODE_RAW && fh->buffers.allocated) ||\r\nfh->buffers.active != ZORAN_FREE) {\r\ndprintk(1, KERN_ERR "%s: VIDIOC_S_FMT - cannot change capture mode\n",\r\nZR_DEVNAME(zr));\r\nres = -EBUSY;\r\ngoto sfmtv4l_unlock_and_return;\r\n}\r\nif (fmt->fmt.pix.height > BUZ_MAX_HEIGHT)\r\nfmt->fmt.pix.height = BUZ_MAX_HEIGHT;\r\nif (fmt->fmt.pix.width > BUZ_MAX_WIDTH)\r\nfmt->fmt.pix.width = BUZ_MAX_WIDTH;\r\nmap_mode_raw(fh);\r\nres = zoran_v4l_set_format(fh, fmt->fmt.pix.width, fmt->fmt.pix.height,\r\n&zoran_formats[i]);\r\nif (res)\r\ngoto sfmtv4l_unlock_and_return;\r\nfmt->fmt.pix.bytesperline = fh->v4l_settings.bytesperline;\r\nfmt->fmt.pix.sizeimage = fh->v4l_settings.height * fh->v4l_settings.bytesperline;\r\nfmt->fmt.pix.colorspace = fh->v4l_settings.format->colorspace;\r\nif (BUZ_MAX_HEIGHT < (fh->v4l_settings.height * 2))\r\nfmt->fmt.pix.field = V4L2_FIELD_INTERLACED;\r\nelse\r\nfmt->fmt.pix.field = V4L2_FIELD_TOP;\r\nsfmtv4l_unlock_and_return:\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic int zoran_g_fbuf(struct file *file, void *__fh,\r\nstruct v4l2_framebuffer *fb)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nmemset(fb, 0, sizeof(*fb));\r\nmutex_lock(&zr->resource_lock);\r\nfb->base = zr->vbuf_base;\r\nfb->fmt.width = zr->vbuf_width;\r\nfb->fmt.height = zr->vbuf_height;\r\nif (zr->overlay_settings.format)\r\nfb->fmt.pixelformat = fh->overlay_settings.format->fourcc;\r\nfb->fmt.bytesperline = zr->vbuf_bytesperline;\r\nmutex_unlock(&zr->resource_lock);\r\nfb->fmt.colorspace = V4L2_COLORSPACE_SRGB;\r\nfb->fmt.field = V4L2_FIELD_INTERLACED;\r\nfb->capability = V4L2_FBUF_CAP_LIST_CLIPPING;\r\nreturn 0;\r\n}\r\nstatic int zoran_s_fbuf(struct file *file, void *__fh,\r\nconst struct v4l2_framebuffer *fb)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nint i, res = 0;\r\n__le32 printformat = __cpu_to_le32(fb->fmt.pixelformat);\r\nfor (i = 0; i < NUM_FORMATS; i++)\r\nif (zoran_formats[i].fourcc == fb->fmt.pixelformat)\r\nbreak;\r\nif (i == NUM_FORMATS) {\r\ndprintk(1, KERN_ERR "%s: VIDIOC_S_FBUF - format=0x%x (%4.4s) not allowed\n",\r\nZR_DEVNAME(zr), fb->fmt.pixelformat,\r\n(char *)&printformat);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&zr->resource_lock);\r\nres = setup_fbuffer(fh, fb->base, &zoran_formats[i], fb->fmt.width,\r\nfb->fmt.height, fb->fmt.bytesperline);\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic int zoran_overlay(struct file *file, void *__fh, unsigned int on)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nint res;\r\nmutex_lock(&zr->resource_lock);\r\nres = setup_overlay(fh, on);\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic int zoran_reqbufs(struct file *file, void *__fh, struct v4l2_requestbuffers *req)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nint res = 0;\r\nif (req->memory != V4L2_MEMORY_MMAP) {\r\ndprintk(2,\r\nKERN_ERR\r\n"%s: only MEMORY_MMAP capture is supported, not %d\n",\r\nZR_DEVNAME(zr), req->memory);\r\nreturn -EINVAL;\r\n}\r\nif (req->count == 0)\r\nreturn zoran_streamoff(file, fh, req->type);\r\nmutex_lock(&zr->resource_lock);\r\nif (fh->buffers.allocated) {\r\ndprintk(2,\r\nKERN_ERR\r\n"%s: VIDIOC_REQBUFS - buffers already allocated\n",\r\nZR_DEVNAME(zr));\r\nres = -EBUSY;\r\ngoto v4l2reqbuf_unlock_and_return;\r\n}\r\nif (fh->map_mode == ZORAN_MAP_MODE_RAW &&\r\nreq->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nif (req->count < 2)\r\nreq->count = 2;\r\nif (req->count > v4l_nbufs)\r\nreq->count = v4l_nbufs;\r\nmap_mode_raw(fh);\r\nfh->buffers.num_buffers = req->count;\r\nif (v4l_fbuffer_alloc(fh)) {\r\nres = -ENOMEM;\r\ngoto v4l2reqbuf_unlock_and_return;\r\n}\r\n} else if (fh->map_mode == ZORAN_MAP_MODE_JPG_REC ||\r\nfh->map_mode == ZORAN_MAP_MODE_JPG_PLAY) {\r\nif (req->count < 4)\r\nreq->count = 4;\r\nif (req->count > jpg_nbufs)\r\nreq->count = jpg_nbufs;\r\nmap_mode_jpg(fh, req->type == V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\nfh->buffers.num_buffers = req->count;\r\nfh->buffers.buffer_size = zoran_v4l2_calc_bufsize(&fh->jpg_settings);\r\nif (jpg_fbuffer_alloc(fh)) {\r\nres = -ENOMEM;\r\ngoto v4l2reqbuf_unlock_and_return;\r\n}\r\n} else {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: VIDIOC_REQBUFS - unknown type %d\n",\r\nZR_DEVNAME(zr), req->type);\r\nres = -EINVAL;\r\ngoto v4l2reqbuf_unlock_and_return;\r\n}\r\nv4l2reqbuf_unlock_and_return:\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic int zoran_querybuf(struct file *file, void *__fh, struct v4l2_buffer *buf)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nint res;\r\nmutex_lock(&zr->resource_lock);\r\nres = zoran_v4l2_buffer_status(fh, buf, buf->index);\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic int zoran_qbuf(struct file *file, void *__fh, struct v4l2_buffer *buf)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nint res = 0, codec_mode, buf_type;\r\nmutex_lock(&zr->resource_lock);\r\nswitch (fh->map_mode) {\r\ncase ZORAN_MAP_MODE_RAW:\r\nif (buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\ndprintk(1, KERN_ERR\r\n"%s: VIDIOC_QBUF - invalid buf->type=%d for map_mode=%d\n",\r\nZR_DEVNAME(zr), buf->type, fh->map_mode);\r\nres = -EINVAL;\r\ngoto qbuf_unlock_and_return;\r\n}\r\nres = zoran_v4l_queue_frame(fh, buf->index);\r\nif (res)\r\ngoto qbuf_unlock_and_return;\r\nif (!zr->v4l_memgrab_active && fh->buffers.active == ZORAN_LOCKED)\r\nzr36057_set_memgrab(zr, 1);\r\nbreak;\r\ncase ZORAN_MAP_MODE_JPG_REC:\r\ncase ZORAN_MAP_MODE_JPG_PLAY:\r\nif (fh->map_mode == ZORAN_MAP_MODE_JPG_PLAY) {\r\nbuf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\ncodec_mode = BUZ_MODE_MOTION_DECOMPRESS;\r\n} else {\r\nbuf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ncodec_mode = BUZ_MODE_MOTION_COMPRESS;\r\n}\r\nif (buf->type != buf_type) {\r\ndprintk(1, KERN_ERR\r\n"%s: VIDIOC_QBUF - invalid buf->type=%d for map_mode=%d\n",\r\nZR_DEVNAME(zr), buf->type, fh->map_mode);\r\nres = -EINVAL;\r\ngoto qbuf_unlock_and_return;\r\n}\r\nres = zoran_jpg_queue_frame(fh, buf->index, codec_mode);\r\nif (res != 0)\r\ngoto qbuf_unlock_and_return;\r\nif (zr->codec_mode == BUZ_MODE_IDLE &&\r\nfh->buffers.active == ZORAN_LOCKED)\r\nzr36057_enable_jpg(zr, codec_mode);\r\nbreak;\r\ndefault:\r\ndprintk(1, KERN_ERR\r\n"%s: VIDIOC_QBUF - unsupported type %d\n",\r\nZR_DEVNAME(zr), buf->type);\r\nres = -EINVAL;\r\nbreak;\r\n}\r\nqbuf_unlock_and_return:\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic int zoran_dqbuf(struct file *file, void *__fh, struct v4l2_buffer *buf)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nint res = 0, buf_type, num = -1;\r\nmutex_lock(&zr->resource_lock);\r\nswitch (fh->map_mode) {\r\ncase ZORAN_MAP_MODE_RAW:\r\nif (buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\ndprintk(1, KERN_ERR\r\n"%s: VIDIOC_QBUF - invalid buf->type=%d for map_mode=%d\n",\r\nZR_DEVNAME(zr), buf->type, fh->map_mode);\r\nres = -EINVAL;\r\ngoto dqbuf_unlock_and_return;\r\n}\r\nnum = zr->v4l_pend[zr->v4l_sync_tail & V4L_MASK_FRAME];\r\nif (file->f_flags & O_NONBLOCK &&\r\nzr->v4l_buffers.buffer[num].state != BUZ_STATE_DONE) {\r\nres = -EAGAIN;\r\ngoto dqbuf_unlock_and_return;\r\n}\r\nres = v4l_sync(fh, num);\r\nif (res)\r\ngoto dqbuf_unlock_and_return;\r\nzr->v4l_sync_tail++;\r\nres = zoran_v4l2_buffer_status(fh, buf, num);\r\nbreak;\r\ncase ZORAN_MAP_MODE_JPG_REC:\r\ncase ZORAN_MAP_MODE_JPG_PLAY:\r\n{\r\nstruct zoran_sync bs;\r\nif (fh->map_mode == ZORAN_MAP_MODE_JPG_PLAY)\r\nbuf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nelse\r\nbuf_type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nif (buf->type != buf_type) {\r\ndprintk(1, KERN_ERR\r\n"%s: VIDIOC_QBUF - invalid buf->type=%d for map_mode=%d\n",\r\nZR_DEVNAME(zr), buf->type, fh->map_mode);\r\nres = -EINVAL;\r\ngoto dqbuf_unlock_and_return;\r\n}\r\nnum = zr->jpg_pend[zr->jpg_que_tail & BUZ_MASK_FRAME];\r\nif (file->f_flags & O_NONBLOCK &&\r\nzr->jpg_buffers.buffer[num].state != BUZ_STATE_DONE) {\r\nres = -EAGAIN;\r\ngoto dqbuf_unlock_and_return;\r\n}\r\nbs.frame = 0;\r\nres = jpg_sync(fh, &bs);\r\nif (res)\r\ngoto dqbuf_unlock_and_return;\r\nres = zoran_v4l2_buffer_status(fh, buf, bs.frame);\r\nbreak;\r\n}\r\ndefault:\r\ndprintk(1, KERN_ERR\r\n"%s: VIDIOC_DQBUF - unsupported type %d\n",\r\nZR_DEVNAME(zr), buf->type);\r\nres = -EINVAL;\r\nbreak;\r\n}\r\ndqbuf_unlock_and_return:\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic int zoran_streamon(struct file *file, void *__fh, enum v4l2_buf_type type)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nint res = 0;\r\nmutex_lock(&zr->resource_lock);\r\nswitch (fh->map_mode) {\r\ncase ZORAN_MAP_MODE_RAW:\r\nif (zr->v4l_buffers.active != ZORAN_ACTIVE ||\r\nfh->buffers.active != ZORAN_ACTIVE) {\r\nres = -EBUSY;\r\ngoto strmon_unlock_and_return;\r\n}\r\nzr->v4l_buffers.active = fh->buffers.active = ZORAN_LOCKED;\r\nzr->v4l_settings = fh->v4l_settings;\r\nzr->v4l_sync_tail = zr->v4l_pend_tail;\r\nif (!zr->v4l_memgrab_active &&\r\nzr->v4l_pend_head != zr->v4l_pend_tail) {\r\nzr36057_set_memgrab(zr, 1);\r\n}\r\nbreak;\r\ncase ZORAN_MAP_MODE_JPG_REC:\r\ncase ZORAN_MAP_MODE_JPG_PLAY:\r\nif (zr->jpg_buffers.active != ZORAN_ACTIVE ||\r\nfh->buffers.active != ZORAN_ACTIVE) {\r\nres = -EBUSY;\r\ngoto strmon_unlock_and_return;\r\n}\r\nzr->jpg_buffers.active = fh->buffers.active = ZORAN_LOCKED;\r\nif (zr->jpg_que_head != zr->jpg_que_tail) {\r\njpeg_start(zr);\r\n}\r\nbreak;\r\ndefault:\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: VIDIOC_STREAMON - invalid map mode %d\n",\r\nZR_DEVNAME(zr), fh->map_mode);\r\nres = -EINVAL;\r\nbreak;\r\n}\r\nstrmon_unlock_and_return:\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic int zoran_streamoff(struct file *file, void *__fh, enum v4l2_buf_type type)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nint i, res = 0;\r\nunsigned long flags;\r\nmutex_lock(&zr->resource_lock);\r\nswitch (fh->map_mode) {\r\ncase ZORAN_MAP_MODE_RAW:\r\nif (fh->buffers.active == ZORAN_FREE &&\r\nzr->v4l_buffers.active != ZORAN_FREE) {\r\nres = -EPERM;\r\ngoto strmoff_unlock_and_return;\r\n}\r\nif (zr->v4l_buffers.active == ZORAN_FREE)\r\ngoto strmoff_unlock_and_return;\r\nspin_lock_irqsave(&zr->spinlock, flags);\r\nif (zr->v4l_memgrab_active) {\r\nzr36057_set_memgrab(zr, 0);\r\n}\r\nfor (i = 0; i < fh->buffers.num_buffers; i++)\r\nzr->v4l_buffers.buffer[i].state = BUZ_STATE_USER;\r\nfh->buffers = zr->v4l_buffers;\r\nzr->v4l_buffers.active = fh->buffers.active = ZORAN_FREE;\r\nzr->v4l_grab_seq = 0;\r\nzr->v4l_pend_head = zr->v4l_pend_tail = 0;\r\nzr->v4l_sync_tail = 0;\r\nspin_unlock_irqrestore(&zr->spinlock, flags);\r\nbreak;\r\ncase ZORAN_MAP_MODE_JPG_REC:\r\ncase ZORAN_MAP_MODE_JPG_PLAY:\r\nif (fh->buffers.active == ZORAN_FREE &&\r\nzr->jpg_buffers.active != ZORAN_FREE) {\r\nres = -EPERM;\r\ngoto strmoff_unlock_and_return;\r\n}\r\nif (zr->jpg_buffers.active == ZORAN_FREE)\r\ngoto strmoff_unlock_and_return;\r\nres = jpg_qbuf(fh, -1,\r\n(fh->map_mode == ZORAN_MAP_MODE_JPG_REC) ?\r\nBUZ_MODE_MOTION_COMPRESS :\r\nBUZ_MODE_MOTION_DECOMPRESS);\r\nif (res)\r\ngoto strmoff_unlock_and_return;\r\nbreak;\r\ndefault:\r\ndprintk(1, KERN_ERR\r\n"%s: VIDIOC_STREAMOFF - invalid map mode %d\n",\r\nZR_DEVNAME(zr), fh->map_mode);\r\nres = -EINVAL;\r\nbreak;\r\n}\r\nstrmoff_unlock_and_return:\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic int zoran_queryctrl(struct file *file, void *__fh,\r\nstruct v4l2_queryctrl *ctrl)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nif (ctrl->id < V4L2_CID_BRIGHTNESS ||\r\nctrl->id > V4L2_CID_HUE)\r\nreturn -EINVAL;\r\ndecoder_call(zr, core, queryctrl, ctrl);\r\nreturn 0;\r\n}\r\nstatic int zoran_g_ctrl(struct file *file, void *__fh, struct v4l2_control *ctrl)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nif (ctrl->id < V4L2_CID_BRIGHTNESS ||\r\nctrl->id > V4L2_CID_HUE)\r\nreturn -EINVAL;\r\nmutex_lock(&zr->resource_lock);\r\ndecoder_call(zr, core, g_ctrl, ctrl);\r\nmutex_unlock(&zr->resource_lock);\r\nreturn 0;\r\n}\r\nstatic int zoran_s_ctrl(struct file *file, void *__fh, struct v4l2_control *ctrl)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nif (ctrl->id < V4L2_CID_BRIGHTNESS ||\r\nctrl->id > V4L2_CID_HUE)\r\nreturn -EINVAL;\r\nmutex_lock(&zr->resource_lock);\r\ndecoder_call(zr, core, s_ctrl, ctrl);\r\nmutex_unlock(&zr->resource_lock);\r\nreturn 0;\r\n}\r\nstatic int zoran_g_std(struct file *file, void *__fh, v4l2_std_id *std)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nmutex_lock(&zr->resource_lock);\r\n*std = zr->norm;\r\nmutex_unlock(&zr->resource_lock);\r\nreturn 0;\r\n}\r\nstatic int zoran_s_std(struct file *file, void *__fh, v4l2_std_id std)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nint res = 0;\r\nmutex_lock(&zr->resource_lock);\r\nres = zoran_set_norm(zr, std);\r\nif (res)\r\ngoto sstd_unlock_and_return;\r\nres = wait_grab_pending(zr);\r\nsstd_unlock_and_return:\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic int zoran_enum_input(struct file *file, void *__fh,\r\nstruct v4l2_input *inp)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nif (inp->index >= zr->card.inputs)\r\nreturn -EINVAL;\r\nstrncpy(inp->name, zr->card.input[inp->index].name,\r\nsizeof(inp->name) - 1);\r\ninp->type = V4L2_INPUT_TYPE_CAMERA;\r\ninp->std = V4L2_STD_ALL;\r\nmutex_lock(&zr->resource_lock);\r\ndecoder_call(zr, video, g_input_status, &inp->status);\r\nmutex_unlock(&zr->resource_lock);\r\nreturn 0;\r\n}\r\nstatic int zoran_g_input(struct file *file, void *__fh, unsigned int *input)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nmutex_lock(&zr->resource_lock);\r\n*input = zr->input;\r\nmutex_unlock(&zr->resource_lock);\r\nreturn 0;\r\n}\r\nstatic int zoran_s_input(struct file *file, void *__fh, unsigned int input)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nint res;\r\nmutex_lock(&zr->resource_lock);\r\nres = zoran_set_input(zr, input);\r\nif (res)\r\ngoto sinput_unlock_and_return;\r\nres = wait_grab_pending(zr);\r\nsinput_unlock_and_return:\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic int zoran_enum_output(struct file *file, void *__fh,\r\nstruct v4l2_output *outp)\r\n{\r\nif (outp->index != 0)\r\nreturn -EINVAL;\r\noutp->index = 0;\r\noutp->type = V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY;\r\nstrncpy(outp->name, "Autodetect", sizeof(outp->name)-1);\r\nreturn 0;\r\n}\r\nstatic int zoran_g_output(struct file *file, void *__fh, unsigned int *output)\r\n{\r\n*output = 0;\r\nreturn 0;\r\n}\r\nstatic int zoran_s_output(struct file *file, void *__fh, unsigned int output)\r\n{\r\nif (output != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int zoran_cropcap(struct file *file, void *__fh,\r\nstruct v4l2_cropcap *cropcap)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nint type = cropcap->type, res = 0;\r\nmemset(cropcap, 0, sizeof(*cropcap));\r\ncropcap->type = type;\r\nmutex_lock(&zr->resource_lock);\r\nif (cropcap->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&\r\n(cropcap->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\r\nfh->map_mode == ZORAN_MAP_MODE_RAW)) {\r\ndprintk(1, KERN_ERR\r\n"%s: VIDIOC_CROPCAP - subcapture only supported for compressed capture\n",\r\nZR_DEVNAME(zr));\r\nres = -EINVAL;\r\ngoto cropcap_unlock_and_return;\r\n}\r\ncropcap->bounds.top = cropcap->bounds.left = 0;\r\ncropcap->bounds.width = BUZ_MAX_WIDTH;\r\ncropcap->bounds.height = BUZ_MAX_HEIGHT;\r\ncropcap->defrect.top = cropcap->defrect.left = 0;\r\ncropcap->defrect.width = BUZ_MIN_WIDTH;\r\ncropcap->defrect.height = BUZ_MIN_HEIGHT;\r\ncropcap_unlock_and_return:\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic int zoran_g_crop(struct file *file, void *__fh, struct v4l2_crop *crop)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nint type = crop->type, res = 0;\r\nmemset(crop, 0, sizeof(*crop));\r\ncrop->type = type;\r\nmutex_lock(&zr->resource_lock);\r\nif (crop->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&\r\n(crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\r\nfh->map_mode == ZORAN_MAP_MODE_RAW)) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: VIDIOC_G_CROP - subcapture only supported for compressed capture\n",\r\nZR_DEVNAME(zr));\r\nres = -EINVAL;\r\ngoto gcrop_unlock_and_return;\r\n}\r\ncrop->c.top = fh->jpg_settings.img_y;\r\ncrop->c.left = fh->jpg_settings.img_x;\r\ncrop->c.width = fh->jpg_settings.img_width;\r\ncrop->c.height = fh->jpg_settings.img_height;\r\ngcrop_unlock_and_return:\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic int zoran_s_crop(struct file *file, void *__fh, const struct v4l2_crop *crop)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nint res = 0;\r\nstruct zoran_jpg_settings settings;\r\nsettings = fh->jpg_settings;\r\nmutex_lock(&zr->resource_lock);\r\nif (fh->buffers.allocated) {\r\ndprintk(1, KERN_ERR\r\n"%s: VIDIOC_S_CROP - cannot change settings while active\n",\r\nZR_DEVNAME(zr));\r\nres = -EBUSY;\r\ngoto scrop_unlock_and_return;\r\n}\r\nif (crop->type != V4L2_BUF_TYPE_VIDEO_OUTPUT &&\r\n(crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\r\nfh->map_mode == ZORAN_MAP_MODE_RAW)) {\r\ndprintk(1, KERN_ERR\r\n"%s: VIDIOC_G_CROP - subcapture only supported for compressed capture\n",\r\nZR_DEVNAME(zr));\r\nres = -EINVAL;\r\ngoto scrop_unlock_and_return;\r\n}\r\nsettings.img_x = crop->c.left;\r\nsettings.img_y = crop->c.top;\r\nsettings.img_width = crop->c.width;\r\nsettings.img_height = crop->c.height;\r\nres = zoran_check_jpg_settings(zr, &settings, 0);\r\nif (res)\r\ngoto scrop_unlock_and_return;\r\nfh->jpg_settings = settings;\r\nscrop_unlock_and_return:\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic int zoran_g_jpegcomp(struct file *file, void *__fh,\r\nstruct v4l2_jpegcompression *params)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nmemset(params, 0, sizeof(*params));\r\nmutex_lock(&zr->resource_lock);\r\nparams->quality = fh->jpg_settings.jpg_comp.quality;\r\nparams->APPn = fh->jpg_settings.jpg_comp.APPn;\r\nmemcpy(params->APP_data,\r\nfh->jpg_settings.jpg_comp.APP_data,\r\nfh->jpg_settings.jpg_comp.APP_len);\r\nparams->APP_len = fh->jpg_settings.jpg_comp.APP_len;\r\nmemcpy(params->COM_data,\r\nfh->jpg_settings.jpg_comp.COM_data,\r\nfh->jpg_settings.jpg_comp.COM_len);\r\nparams->COM_len = fh->jpg_settings.jpg_comp.COM_len;\r\nparams->jpeg_markers =\r\nfh->jpg_settings.jpg_comp.jpeg_markers;\r\nmutex_unlock(&zr->resource_lock);\r\nreturn 0;\r\n}\r\nstatic int zoran_s_jpegcomp(struct file *file, void *__fh,\r\nconst struct v4l2_jpegcompression *params)\r\n{\r\nstruct zoran_fh *fh = __fh;\r\nstruct zoran *zr = fh->zr;\r\nint res = 0;\r\nstruct zoran_jpg_settings settings;\r\nsettings = fh->jpg_settings;\r\nsettings.jpg_comp = *params;\r\nmutex_lock(&zr->resource_lock);\r\nif (fh->buffers.active != ZORAN_FREE) {\r\ndprintk(1, KERN_WARNING\r\n"%s: VIDIOC_S_JPEGCOMP called while in playback/capture mode\n",\r\nZR_DEVNAME(zr));\r\nres = -EBUSY;\r\ngoto sjpegc_unlock_and_return;\r\n}\r\nres = zoran_check_jpg_settings(zr, &settings, 0);\r\nif (res)\r\ngoto sjpegc_unlock_and_return;\r\nif (!fh->buffers.allocated)\r\nfh->buffers.buffer_size =\r\nzoran_v4l2_calc_bufsize(&fh->jpg_settings);\r\nfh->jpg_settings.jpg_comp = settings.jpg_comp;\r\nsjpegc_unlock_and_return:\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic unsigned int\r\nzoran_poll (struct file *file,\r\npoll_table *wait)\r\n{\r\nstruct zoran_fh *fh = file->private_data;\r\nstruct zoran *zr = fh->zr;\r\nint res = 0, frame;\r\nunsigned long flags;\r\nmutex_lock(&zr->resource_lock);\r\nswitch (fh->map_mode) {\r\ncase ZORAN_MAP_MODE_RAW:\r\npoll_wait(file, &zr->v4l_capq, wait);\r\nframe = zr->v4l_pend[zr->v4l_sync_tail & V4L_MASK_FRAME];\r\nspin_lock_irqsave(&zr->spinlock, flags);\r\ndprintk(3,\r\nKERN_DEBUG\r\n"%s: %s() raw - active=%c, sync_tail=%lu/%c, pend_tail=%lu, pend_head=%lu\n",\r\nZR_DEVNAME(zr), __func__,\r\n"FAL"[fh->buffers.active], zr->v4l_sync_tail,\r\n"UPMD"[zr->v4l_buffers.buffer[frame].state],\r\nzr->v4l_pend_tail, zr->v4l_pend_head);\r\nif (fh->buffers.active != ZORAN_FREE &&\r\nzr->v4l_buffers.buffer[frame].state == BUZ_STATE_DONE)\r\nres = POLLIN | POLLRDNORM;\r\nspin_unlock_irqrestore(&zr->spinlock, flags);\r\nbreak;\r\ncase ZORAN_MAP_MODE_JPG_REC:\r\ncase ZORAN_MAP_MODE_JPG_PLAY:\r\npoll_wait(file, &zr->jpg_capq, wait);\r\nframe = zr->jpg_pend[zr->jpg_que_tail & BUZ_MASK_FRAME];\r\nspin_lock_irqsave(&zr->spinlock, flags);\r\ndprintk(3,\r\nKERN_DEBUG\r\n"%s: %s() jpg - active=%c, que_tail=%lu/%c, que_head=%lu, dma=%lu/%lu\n",\r\nZR_DEVNAME(zr), __func__,\r\n"FAL"[fh->buffers.active], zr->jpg_que_tail,\r\n"UPMD"[zr->jpg_buffers.buffer[frame].state],\r\nzr->jpg_que_head, zr->jpg_dma_tail, zr->jpg_dma_head);\r\nif (fh->buffers.active != ZORAN_FREE &&\r\nzr->jpg_buffers.buffer[frame].state == BUZ_STATE_DONE) {\r\nif (fh->map_mode == ZORAN_MAP_MODE_JPG_REC)\r\nres = POLLIN | POLLRDNORM;\r\nelse\r\nres = POLLOUT | POLLWRNORM;\r\n}\r\nspin_unlock_irqrestore(&zr->spinlock, flags);\r\nbreak;\r\ndefault:\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - internal error, unknown map_mode=%d\n",\r\nZR_DEVNAME(zr), __func__, fh->map_mode);\r\nres = POLLNVAL;\r\n}\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic void\r\nzoran_vm_open (struct vm_area_struct *vma)\r\n{\r\nstruct zoran_mapping *map = vma->vm_private_data;\r\natomic_inc(&map->count);\r\n}\r\nstatic void\r\nzoran_vm_close (struct vm_area_struct *vma)\r\n{\r\nstruct zoran_mapping *map = vma->vm_private_data;\r\nstruct zoran_fh *fh = map->fh;\r\nstruct zoran *zr = fh->zr;\r\nint i;\r\nif (!atomic_dec_and_mutex_lock(&map->count, &zr->resource_lock))\r\nreturn;\r\ndprintk(3, KERN_INFO "%s: %s - munmap(%s)\n", ZR_DEVNAME(zr),\r\n__func__, mode_name(fh->map_mode));\r\nfor (i = 0; i < fh->buffers.num_buffers; i++) {\r\nif (fh->buffers.buffer[i].map == map)\r\nfh->buffers.buffer[i].map = NULL;\r\n}\r\nkfree(map);\r\nfor (i = 0; i < fh->buffers.num_buffers; i++) {\r\nif (fh->buffers.buffer[i].map) {\r\nmutex_unlock(&zr->resource_lock);\r\nreturn;\r\n}\r\n}\r\ndprintk(3, KERN_INFO "%s: %s - free %s buffers\n", ZR_DEVNAME(zr),\r\n__func__, mode_name(fh->map_mode));\r\nif (fh->map_mode == ZORAN_MAP_MODE_RAW) {\r\nif (fh->buffers.active != ZORAN_FREE) {\r\nunsigned long flags;\r\nspin_lock_irqsave(&zr->spinlock, flags);\r\nzr36057_set_memgrab(zr, 0);\r\nzr->v4l_buffers.allocated = 0;\r\nzr->v4l_buffers.active = fh->buffers.active = ZORAN_FREE;\r\nspin_unlock_irqrestore(&zr->spinlock, flags);\r\n}\r\nv4l_fbuffer_free(fh);\r\n} else {\r\nif (fh->buffers.active != ZORAN_FREE) {\r\njpg_qbuf(fh, -1, zr->codec_mode);\r\nzr->jpg_buffers.allocated = 0;\r\nzr->jpg_buffers.active = fh->buffers.active = ZORAN_FREE;\r\n}\r\njpg_fbuffer_free(fh);\r\n}\r\nmutex_unlock(&zr->resource_lock);\r\n}\r\nstatic int\r\nzoran_mmap (struct file *file,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct zoran_fh *fh = file->private_data;\r\nstruct zoran *zr = fh->zr;\r\nunsigned long size = (vma->vm_end - vma->vm_start);\r\nunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\r\nint i, j;\r\nunsigned long page, start = vma->vm_start, todo, pos, fraglen;\r\nint first, last;\r\nstruct zoran_mapping *map;\r\nint res = 0;\r\ndprintk(3,\r\nKERN_INFO "%s: %s(%s) of 0x%08lx-0x%08lx (size=%lu)\n",\r\nZR_DEVNAME(zr), __func__,\r\nmode_name(fh->map_mode), vma->vm_start, vma->vm_end, size);\r\nif (!(vma->vm_flags & VM_SHARED) || !(vma->vm_flags & VM_READ) ||\r\n!(vma->vm_flags & VM_WRITE)) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s - no MAP_SHARED/PROT_{READ,WRITE} given\n",\r\nZR_DEVNAME(zr), __func__);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&zr->resource_lock);\r\nif (!fh->buffers.allocated) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s(%s) - buffers not yet allocated\n",\r\nZR_DEVNAME(zr), __func__, mode_name(fh->map_mode));\r\nres = -ENOMEM;\r\ngoto mmap_unlock_and_return;\r\n}\r\nfirst = offset / fh->buffers.buffer_size;\r\nlast = first - 1 + size / fh->buffers.buffer_size;\r\nif (offset % fh->buffers.buffer_size != 0 ||\r\nsize % fh->buffers.buffer_size != 0 || first < 0 ||\r\nlast < 0 || first >= fh->buffers.num_buffers ||\r\nlast >= fh->buffers.buffer_size) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s(%s) - offset=%lu or size=%lu invalid for bufsize=%d and numbufs=%d\n",\r\nZR_DEVNAME(zr), __func__, mode_name(fh->map_mode), offset, size,\r\nfh->buffers.buffer_size,\r\nfh->buffers.num_buffers);\r\nres = -EINVAL;\r\ngoto mmap_unlock_and_return;\r\n}\r\nfor (i = first; i <= last; i++) {\r\nif (fh->buffers.buffer[i].map) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s(%s) - buffer %d already mapped\n",\r\nZR_DEVNAME(zr), __func__, mode_name(fh->map_mode), i);\r\nres = -EBUSY;\r\ngoto mmap_unlock_and_return;\r\n}\r\n}\r\nmap = kmalloc(sizeof(struct zoran_mapping), GFP_KERNEL);\r\nif (!map) {\r\nres = -ENOMEM;\r\ngoto mmap_unlock_and_return;\r\n}\r\nmap->fh = fh;\r\natomic_set(&map->count, 1);\r\nvma->vm_ops = &zoran_vm_ops;\r\nvma->vm_flags |= VM_DONTEXPAND;\r\nvma->vm_private_data = map;\r\nif (fh->map_mode == ZORAN_MAP_MODE_RAW) {\r\nfor (i = first; i <= last; i++) {\r\ntodo = size;\r\nif (todo > fh->buffers.buffer_size)\r\ntodo = fh->buffers.buffer_size;\r\npage = fh->buffers.buffer[i].v4l.fbuffer_phys;\r\nif (remap_pfn_range(vma, start, page >> PAGE_SHIFT,\r\ntodo, PAGE_SHARED)) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s(V4L) - remap_pfn_range failed\n",\r\nZR_DEVNAME(zr), __func__);\r\nres = -EAGAIN;\r\ngoto mmap_unlock_and_return;\r\n}\r\nsize -= todo;\r\nstart += todo;\r\nfh->buffers.buffer[i].map = map;\r\nif (size == 0)\r\nbreak;\r\n}\r\n} else {\r\nfor (i = first; i <= last; i++) {\r\nfor (j = 0;\r\nj < fh->buffers.buffer_size / PAGE_SIZE;\r\nj++) {\r\nfraglen =\r\n(le32_to_cpu(fh->buffers.buffer[i].jpg.\r\nfrag_tab[2 * j + 1]) & ~1) << 1;\r\ntodo = size;\r\nif (todo > fraglen)\r\ntodo = fraglen;\r\npos =\r\nle32_to_cpu(fh->buffers.\r\nbuffer[i].jpg.frag_tab[2 * j]);\r\npage = virt_to_phys(bus_to_virt(pos))\r\n>> PAGE_SHIFT;\r\nif (remap_pfn_range(vma, start, page,\r\ntodo, PAGE_SHARED)) {\r\ndprintk(1,\r\nKERN_ERR\r\n"%s: %s(V4L) - remap_pfn_range failed\n",\r\nZR_DEVNAME(zr), __func__);\r\nres = -EAGAIN;\r\ngoto mmap_unlock_and_return;\r\n}\r\nsize -= todo;\r\nstart += todo;\r\nif (size == 0)\r\nbreak;\r\nif (le32_to_cpu(fh->buffers.buffer[i].jpg.\r\nfrag_tab[2 * j + 1]) & 1)\r\nbreak;\r\n}\r\nfh->buffers.buffer[i].map = map;\r\nif (size == 0)\r\nbreak;\r\n}\r\n}\r\nmmap_unlock_and_return:\r\nmutex_unlock(&zr->resource_lock);\r\nreturn res;\r\n}\r\nstatic long zoran_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct zoran_fh *fh = file->private_data;\r\nstruct zoran *zr = fh->zr;\r\nint ret;\r\nmutex_lock(&zr->other_lock);\r\nret = video_ioctl2(file, cmd, arg);\r\nmutex_unlock(&zr->other_lock);\r\nreturn ret;\r\n}
