int nf_conntrack_broadcast_help(struct sk_buff *skb,\r\nunsigned int protoff,\r\nstruct nf_conn *ct,\r\nenum ip_conntrack_info ctinfo,\r\nunsigned int timeout)\r\n{\r\nstruct nf_conntrack_expect *exp;\r\nstruct iphdr *iph = ip_hdr(skb);\r\nstruct rtable *rt = skb_rtable(skb);\r\nstruct in_device *in_dev;\r\nstruct nf_conn_help *help = nfct_help(ct);\r\n__be32 mask = 0;\r\nif (skb->sk == NULL)\r\ngoto out;\r\nif (rt == NULL || !(rt->rt_flags & RTCF_BROADCAST))\r\ngoto out;\r\nif (CTINFO2DIR(ctinfo) != IP_CT_DIR_ORIGINAL)\r\ngoto out;\r\nrcu_read_lock();\r\nin_dev = __in_dev_get_rcu(rt->dst.dev);\r\nif (in_dev != NULL) {\r\nfor_primary_ifa(in_dev) {\r\nif (ifa->ifa_broadcast == iph->daddr) {\r\nmask = ifa->ifa_mask;\r\nbreak;\r\n}\r\n} endfor_ifa(in_dev);\r\n}\r\nrcu_read_unlock();\r\nif (mask == 0)\r\ngoto out;\r\nexp = nf_ct_expect_alloc(ct);\r\nif (exp == NULL)\r\ngoto out;\r\nexp->tuple = ct->tuplehash[IP_CT_DIR_REPLY].tuple;\r\nexp->tuple.src.u.udp.port = help->helper->tuple.src.u.udp.port;\r\nexp->mask.src.u3.ip = mask;\r\nexp->mask.src.u.udp.port = htons(0xFFFF);\r\nexp->expectfn = NULL;\r\nexp->flags = NF_CT_EXPECT_PERMANENT;\r\nexp->class = NF_CT_EXPECT_CLASS_DEFAULT;\r\nexp->helper = NULL;\r\nnf_ct_expect_related(exp);\r\nnf_ct_expect_put(exp);\r\nnf_ct_refresh(ct, skb, timeout * HZ);\r\nout:\r\nreturn NF_ACCEPT;\r\n}
