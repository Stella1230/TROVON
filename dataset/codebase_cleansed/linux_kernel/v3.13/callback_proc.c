__be32 nfs4_callback_getattr(struct cb_getattrargs *args,\r\nstruct cb_getattrres *res,\r\nstruct cb_process_state *cps)\r\n{\r\nstruct nfs_delegation *delegation;\r\nstruct nfs_inode *nfsi;\r\nstruct inode *inode;\r\nres->status = htonl(NFS4ERR_OP_NOT_IN_SESSION);\r\nif (!cps->clp)\r\ngoto out;\r\nres->bitmap[0] = res->bitmap[1] = 0;\r\nres->status = htonl(NFS4ERR_BADHANDLE);\r\ndprintk_rcu("NFS: GETATTR callback request from %s\n",\r\nrpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR));\r\ninode = nfs_delegation_find_inode(cps->clp, &args->fh);\r\nif (inode == NULL)\r\ngoto out;\r\nnfsi = NFS_I(inode);\r\nrcu_read_lock();\r\ndelegation = rcu_dereference(nfsi->delegation);\r\nif (delegation == NULL || (delegation->type & FMODE_WRITE) == 0)\r\ngoto out_iput;\r\nres->size = i_size_read(inode);\r\nres->change_attr = delegation->change_attr;\r\nif (nfsi->npages != 0)\r\nres->change_attr++;\r\nres->ctime = inode->i_ctime;\r\nres->mtime = inode->i_mtime;\r\nres->bitmap[0] = (FATTR4_WORD0_CHANGE|FATTR4_WORD0_SIZE) &\r\nargs->bitmap[0];\r\nres->bitmap[1] = (FATTR4_WORD1_TIME_METADATA|FATTR4_WORD1_TIME_MODIFY) &\r\nargs->bitmap[1];\r\nres->status = 0;\r\nout_iput:\r\nrcu_read_unlock();\r\niput(inode);\r\nout:\r\ndprintk("%s: exit with status = %d\n", __func__, ntohl(res->status));\r\nreturn res->status;\r\n}\r\n__be32 nfs4_callback_recall(struct cb_recallargs *args, void *dummy,\r\nstruct cb_process_state *cps)\r\n{\r\nstruct inode *inode;\r\n__be32 res;\r\nres = htonl(NFS4ERR_OP_NOT_IN_SESSION);\r\nif (!cps->clp)\r\ngoto out;\r\ndprintk_rcu("NFS: RECALL callback request from %s\n",\r\nrpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR));\r\nres = htonl(NFS4ERR_BADHANDLE);\r\ninode = nfs_delegation_find_inode(cps->clp, &args->fh);\r\nif (inode == NULL)\r\ngoto out;\r\nswitch (nfs_async_inode_return_delegation(inode, &args->stateid)) {\r\ncase 0:\r\nres = 0;\r\nbreak;\r\ncase -ENOENT:\r\nres = htonl(NFS4ERR_BAD_STATEID);\r\nbreak;\r\ndefault:\r\nres = htonl(NFS4ERR_RESOURCE);\r\n}\r\ntrace_nfs4_recall_delegation(inode, -ntohl(res));\r\niput(inode);\r\nout:\r\ndprintk("%s: exit with status = %d\n", __func__, ntohl(res));\r\nreturn res;\r\n}\r\nstatic struct pnfs_layout_hdr * get_layout_by_fh_locked(struct nfs_client *clp, struct nfs_fh *fh)\r\n{\r\nstruct nfs_server *server;\r\nstruct inode *ino;\r\nstruct pnfs_layout_hdr *lo;\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\r\nlist_for_each_entry(lo, &server->layouts, plh_layouts) {\r\nif (nfs_compare_fh(fh, &NFS_I(lo->plh_inode)->fh))\r\ncontinue;\r\nino = igrab(lo->plh_inode);\r\nif (!ino)\r\ncontinue;\r\nspin_lock(&ino->i_lock);\r\nif (NFS_I(ino)->layout != lo) {\r\nspin_unlock(&ino->i_lock);\r\niput(ino);\r\ncontinue;\r\n}\r\npnfs_get_layout_hdr(lo);\r\nspin_unlock(&ino->i_lock);\r\nreturn lo;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct pnfs_layout_hdr * get_layout_by_fh(struct nfs_client *clp, struct nfs_fh *fh)\r\n{\r\nstruct pnfs_layout_hdr *lo;\r\nspin_lock(&clp->cl_lock);\r\nrcu_read_lock();\r\nlo = get_layout_by_fh_locked(clp, fh);\r\nrcu_read_unlock();\r\nspin_unlock(&clp->cl_lock);\r\nreturn lo;\r\n}\r\nstatic u32 initiate_file_draining(struct nfs_client *clp,\r\nstruct cb_layoutrecallargs *args)\r\n{\r\nstruct inode *ino;\r\nstruct pnfs_layout_hdr *lo;\r\nu32 rv = NFS4ERR_NOMATCHING_LAYOUT;\r\nLIST_HEAD(free_me_list);\r\nlo = get_layout_by_fh(clp, &args->cbl_fh);\r\nif (!lo)\r\nreturn NFS4ERR_NOMATCHING_LAYOUT;\r\nino = lo->plh_inode;\r\nspin_lock(&ino->i_lock);\r\nif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags) ||\r\npnfs_mark_matching_lsegs_invalid(lo, &free_me_list,\r\n&args->cbl_range))\r\nrv = NFS4ERR_DELAY;\r\nelse\r\nrv = NFS4ERR_NOMATCHING_LAYOUT;\r\npnfs_set_layout_stateid(lo, &args->cbl_stateid, true);\r\nspin_unlock(&ino->i_lock);\r\npnfs_free_lseg_list(&free_me_list);\r\npnfs_put_layout_hdr(lo);\r\niput(ino);\r\nreturn rv;\r\n}\r\nstatic u32 initiate_bulk_draining(struct nfs_client *clp,\r\nstruct cb_layoutrecallargs *args)\r\n{\r\nint stat;\r\nif (args->cbl_recall_type == RETURN_FSID)\r\nstat = pnfs_destroy_layouts_byfsid(clp, &args->cbl_fsid, true);\r\nelse\r\nstat = pnfs_destroy_layouts_byclid(clp, true);\r\nif (stat != 0)\r\nreturn NFS4ERR_DELAY;\r\nreturn NFS4ERR_NOMATCHING_LAYOUT;\r\n}\r\nstatic u32 do_callback_layoutrecall(struct nfs_client *clp,\r\nstruct cb_layoutrecallargs *args)\r\n{\r\nu32 res;\r\ndprintk("%s enter, type=%i\n", __func__, args->cbl_recall_type);\r\nif (args->cbl_recall_type == RETURN_FILE)\r\nres = initiate_file_draining(clp, args);\r\nelse\r\nres = initiate_bulk_draining(clp, args);\r\ndprintk("%s returning %i\n", __func__, res);\r\nreturn res;\r\n}\r\n__be32 nfs4_callback_layoutrecall(struct cb_layoutrecallargs *args,\r\nvoid *dummy, struct cb_process_state *cps)\r\n{\r\nu32 res;\r\ndprintk("%s: -->\n", __func__);\r\nif (cps->clp)\r\nres = do_callback_layoutrecall(cps->clp, args);\r\nelse\r\nres = NFS4ERR_OP_NOT_IN_SESSION;\r\ndprintk("%s: exit with status = %d\n", __func__, res);\r\nreturn cpu_to_be32(res);\r\n}\r\nstatic void pnfs_recall_all_layouts(struct nfs_client *clp)\r\n{\r\nstruct cb_layoutrecallargs args;\r\nmemset(&args, 0, sizeof(args));\r\nargs.cbl_recall_type = RETURN_ALL;\r\ndo_callback_layoutrecall(clp, &args);\r\n}\r\n__be32 nfs4_callback_devicenotify(struct cb_devicenotifyargs *args,\r\nvoid *dummy, struct cb_process_state *cps)\r\n{\r\nint i;\r\n__be32 res = 0;\r\nstruct nfs_client *clp = cps->clp;\r\nstruct nfs_server *server = NULL;\r\ndprintk("%s: -->\n", __func__);\r\nif (!clp) {\r\nres = cpu_to_be32(NFS4ERR_OP_NOT_IN_SESSION);\r\ngoto out;\r\n}\r\nfor (i = 0; i < args->ndevs; i++) {\r\nstruct cb_devicenotifyitem *dev = &args->devs[i];\r\nif (!server ||\r\nserver->pnfs_curr_ld->id != dev->cbd_layout_type) {\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link)\r\nif (server->pnfs_curr_ld &&\r\nserver->pnfs_curr_ld->id == dev->cbd_layout_type) {\r\nrcu_read_unlock();\r\ngoto found;\r\n}\r\nrcu_read_unlock();\r\ndprintk("%s: layout type %u not found\n",\r\n__func__, dev->cbd_layout_type);\r\ncontinue;\r\n}\r\nfound:\r\nif (dev->cbd_notify_type == NOTIFY_DEVICEID4_CHANGE)\r\ndprintk("%s: NOTIFY_DEVICEID4_CHANGE not supported, "\r\n"deleting instead\n", __func__);\r\nnfs4_delete_deviceid(server->pnfs_curr_ld, clp, &dev->cbd_dev_id);\r\n}\r\nout:\r\nkfree(args->devs);\r\ndprintk("%s: exit with status = %u\n",\r\n__func__, be32_to_cpu(res));\r\nreturn res;\r\n}\r\nstatic __be32\r\nvalidate_seqid(struct nfs4_slot_table *tbl, struct cb_sequenceargs * args)\r\n{\r\nstruct nfs4_slot *slot;\r\ndprintk("%s enter. slotid %u seqid %u\n",\r\n__func__, args->csa_slotid, args->csa_sequenceid);\r\nif (args->csa_slotid >= NFS41_BC_MAX_CALLBACKS)\r\nreturn htonl(NFS4ERR_BADSLOT);\r\nslot = tbl->slots + args->csa_slotid;\r\ndprintk("%s slot table seqid: %u\n", __func__, slot->seq_nr);\r\nif (likely(args->csa_sequenceid == slot->seq_nr + 1)) {\r\nslot->seq_nr++;\r\ngoto out_ok;\r\n}\r\nif (args->csa_sequenceid == slot->seq_nr) {\r\ndprintk("%s seqid %u is a replay\n",\r\n__func__, args->csa_sequenceid);\r\nif (args->csa_cachethis == 0)\r\nreturn htonl(NFS4ERR_RETRY_UNCACHED_REP);\r\nelse if (args->csa_cachethis == 1)\r\nreturn htonl(NFS4ERR_REP_TOO_BIG_TO_CACHE);\r\n}\r\nif (args->csa_sequenceid == 1 && (slot->seq_nr + 1) == 0) {\r\nslot->seq_nr = 1;\r\ngoto out_ok;\r\n}\r\nreturn htonl(NFS4ERR_SEQ_MISORDERED);\r\nout_ok:\r\ntbl->highest_used_slotid = args->csa_slotid;\r\nreturn htonl(NFS4_OK);\r\n}\r\nstatic bool referring_call_exists(struct nfs_client *clp,\r\nuint32_t nrclists,\r\nstruct referring_call_list *rclists)\r\n{\r\nbool status = 0;\r\nint i, j;\r\nstruct nfs4_session *session;\r\nstruct nfs4_slot_table *tbl;\r\nstruct referring_call_list *rclist;\r\nstruct referring_call *ref;\r\nsession = clp->cl_session;\r\ntbl = &session->fc_slot_table;\r\nfor (i = 0; i < nrclists; i++) {\r\nrclist = &rclists[i];\r\nif (memcmp(session->sess_id.data,\r\nrclist->rcl_sessionid.data,\r\nNFS4_MAX_SESSIONID_LEN) != 0)\r\ncontinue;\r\nfor (j = 0; j < rclist->rcl_nrefcalls; j++) {\r\nref = &rclist->rcl_refcalls[j];\r\ndprintk("%s: sessionid %x:%x:%x:%x sequenceid %u "\r\n"slotid %u\n", __func__,\r\n((u32 *)&rclist->rcl_sessionid.data)[0],\r\n((u32 *)&rclist->rcl_sessionid.data)[1],\r\n((u32 *)&rclist->rcl_sessionid.data)[2],\r\n((u32 *)&rclist->rcl_sessionid.data)[3],\r\nref->rc_sequenceid, ref->rc_slotid);\r\nspin_lock(&tbl->slot_tbl_lock);\r\nstatus = (test_bit(ref->rc_slotid, tbl->used_slots) &&\r\ntbl->slots[ref->rc_slotid].seq_nr ==\r\nref->rc_sequenceid);\r\nspin_unlock(&tbl->slot_tbl_lock);\r\nif (status)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn status;\r\n}\r\n__be32 nfs4_callback_sequence(struct cb_sequenceargs *args,\r\nstruct cb_sequenceres *res,\r\nstruct cb_process_state *cps)\r\n{\r\nstruct nfs4_slot_table *tbl;\r\nstruct nfs_client *clp;\r\nint i;\r\n__be32 status = htonl(NFS4ERR_BADSESSION);\r\nclp = nfs4_find_client_sessionid(cps->net, args->csa_addr,\r\n&args->csa_sessionid, cps->minorversion);\r\nif (clp == NULL)\r\ngoto out;\r\ntbl = &clp->cl_session->bc_slot_table;\r\nspin_lock(&tbl->slot_tbl_lock);\r\nif (test_bit(NFS4_SLOT_TBL_DRAINING, &tbl->slot_tbl_state)) {\r\nspin_unlock(&tbl->slot_tbl_lock);\r\nstatus = htonl(NFS4ERR_DELAY);\r\nif (test_bit(NFS4CLNT_SESSION_RESET, &clp->cl_state))\r\nstatus = htonl(NFS4ERR_BADSESSION);\r\ngoto out;\r\n}\r\nstatus = validate_seqid(&clp->cl_session->bc_slot_table, args);\r\nspin_unlock(&tbl->slot_tbl_lock);\r\nif (status)\r\ngoto out;\r\ncps->slotid = args->csa_slotid;\r\nif (referring_call_exists(clp, args->csa_nrclists, args->csa_rclists)) {\r\nstatus = htonl(NFS4ERR_DELAY);\r\ngoto out;\r\n}\r\nmemcpy(&res->csr_sessionid, &args->csa_sessionid,\r\nsizeof(res->csr_sessionid));\r\nres->csr_sequenceid = args->csa_sequenceid;\r\nres->csr_slotid = args->csa_slotid;\r\nres->csr_highestslotid = NFS41_BC_MAX_CALLBACKS - 1;\r\nres->csr_target_highestslotid = NFS41_BC_MAX_CALLBACKS - 1;\r\nout:\r\ncps->clp = clp;\r\nfor (i = 0; i < args->csa_nrclists; i++)\r\nkfree(args->csa_rclists[i].rcl_refcalls);\r\nkfree(args->csa_rclists);\r\nif (status == htonl(NFS4ERR_RETRY_UNCACHED_REP)) {\r\ncps->drc_status = status;\r\nstatus = 0;\r\n} else\r\nres->csr_status = status;\r\ntrace_nfs4_cb_sequence(args, res, status);\r\ndprintk("%s: exit with status = %d res->csr_status %d\n", __func__,\r\nntohl(status), ntohl(res->csr_status));\r\nreturn status;\r\n}\r\nstatic bool\r\nvalidate_bitmap_values(unsigned long mask)\r\n{\r\nreturn (mask & ~RCA4_TYPE_MASK_ALL) == 0;\r\n}\r\n__be32 nfs4_callback_recallany(struct cb_recallanyargs *args, void *dummy,\r\nstruct cb_process_state *cps)\r\n{\r\n__be32 status;\r\nfmode_t flags = 0;\r\nstatus = cpu_to_be32(NFS4ERR_OP_NOT_IN_SESSION);\r\nif (!cps->clp)\r\ngoto out;\r\ndprintk_rcu("NFS: RECALL_ANY callback request from %s\n",\r\nrpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR));\r\nstatus = cpu_to_be32(NFS4ERR_INVAL);\r\nif (!validate_bitmap_values(args->craa_type_mask))\r\ngoto out;\r\nstatus = cpu_to_be32(NFS4_OK);\r\nif (test_bit(RCA4_TYPE_MASK_RDATA_DLG, (const unsigned long *)\r\n&args->craa_type_mask))\r\nflags = FMODE_READ;\r\nif (test_bit(RCA4_TYPE_MASK_WDATA_DLG, (const unsigned long *)\r\n&args->craa_type_mask))\r\nflags |= FMODE_WRITE;\r\nif (test_bit(RCA4_TYPE_MASK_FILE_LAYOUT, (const unsigned long *)\r\n&args->craa_type_mask))\r\npnfs_recall_all_layouts(cps->clp);\r\nif (flags)\r\nnfs_expire_unused_delegation_types(cps->clp, flags);\r\nout:\r\ndprintk("%s: exit with status = %d\n", __func__, ntohl(status));\r\nreturn status;\r\n}\r\n__be32 nfs4_callback_recallslot(struct cb_recallslotargs *args, void *dummy,\r\nstruct cb_process_state *cps)\r\n{\r\nstruct nfs4_slot_table *fc_tbl;\r\n__be32 status;\r\nstatus = htonl(NFS4ERR_OP_NOT_IN_SESSION);\r\nif (!cps->clp)\r\ngoto out;\r\ndprintk_rcu("NFS: CB_RECALL_SLOT request from %s target highest slotid %u\n",\r\nrpc_peeraddr2str(cps->clp->cl_rpcclient, RPC_DISPLAY_ADDR),\r\nargs->crsa_target_highest_slotid);\r\nfc_tbl = &cps->clp->cl_session->fc_slot_table;\r\nstatus = htonl(NFS4_OK);\r\nnfs41_set_target_slotid(fc_tbl, args->crsa_target_highest_slotid);\r\nnfs41_server_notify_target_slotid_update(cps->clp);\r\nout:\r\ndprintk("%s: exit with status = %d\n", __func__, ntohl(status));\r\nreturn status;\r\n}
