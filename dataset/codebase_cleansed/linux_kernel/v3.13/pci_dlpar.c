static struct pci_bus *\r\nfind_bus_among_children(struct pci_bus *bus,\r\nstruct device_node *dn)\r\n{\r\nstruct pci_bus *child = NULL;\r\nstruct list_head *tmp;\r\nstruct device_node *busdn;\r\nbusdn = pci_bus_to_OF_node(bus);\r\nif (busdn == dn)\r\nreturn bus;\r\nlist_for_each(tmp, &bus->children) {\r\nchild = find_bus_among_children(pci_bus_b(tmp), dn);\r\nif (child)\r\nbreak;\r\n};\r\nreturn child;\r\n}\r\nstruct pci_bus *\r\npcibios_find_pci_bus(struct device_node *dn)\r\n{\r\nstruct pci_dn *pdn = dn->data;\r\nif (!pdn || !pdn->phb || !pdn->phb->bus)\r\nreturn NULL;\r\nreturn find_bus_among_children(pdn->phb->bus, dn);\r\n}\r\nstruct pci_controller *init_phb_dynamic(struct device_node *dn)\r\n{\r\nstruct pci_controller *phb;\r\npr_debug("PCI: Initializing new hotplug PHB %s\n", dn->full_name);\r\nphb = pcibios_alloc_controller(dn);\r\nif (!phb)\r\nreturn NULL;\r\nrtas_setup_phb(phb);\r\npci_process_bridge_OF_ranges(phb, dn, 0);\r\npci_devs_phb_init_dynamic(phb);\r\neeh_dev_phb_init_dynamic(phb);\r\nif (dn->child)\r\neeh_add_device_tree_early(dn);\r\npcibios_scan_phb(phb);\r\npcibios_finish_adding_to_bus(phb->bus);\r\nreturn phb;\r\n}\r\nint remove_phb_dynamic(struct pci_controller *phb)\r\n{\r\nstruct pci_bus *b = phb->bus;\r\nstruct resource *res;\r\nint rc, i;\r\npr_debug("PCI: Removing PHB %04x:%02x...\n",\r\npci_domain_nr(b), b->number);\r\nif (!(list_empty(&b->children) && list_empty(&b->devices)))\r\nreturn -EBUSY;\r\nres = &phb->io_resource;\r\nif (res->flags & IORESOURCE_IO) {\r\nrc = pcibios_unmap_io_space(b);\r\nif (rc) {\r\nprintk(KERN_ERR "%s: failed to unmap IO on bus %s\n",\r\n__func__, b->name);\r\nreturn 1;\r\n}\r\n}\r\ndevice_unregister(b->bridge);\r\nphb->bus = NULL;\r\npci_remove_bus(b);\r\nif (res->flags & IORESOURCE_IO)\r\nrelease_resource(res);\r\nfor (i = 0; i < 3; ++i) {\r\nres = &phb->mem_resources[i];\r\nif (!(res->flags & IORESOURCE_MEM))\r\ncontinue;\r\nrelease_resource(res);\r\n}\r\npcibios_free_controller(phb);\r\nreturn 0;\r\n}
