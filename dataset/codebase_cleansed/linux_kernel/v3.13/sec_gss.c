static inline int msg_last_segidx(struct lustre_msg *msg)\r\n{\r\nLASSERT(msg->lm_bufcount > 0);\r\nreturn msg->lm_bufcount - 1;\r\n}\r\nstatic inline int msg_last_seglen(struct lustre_msg *msg)\r\n{\r\nreturn msg->lm_buflens[msg_last_segidx(msg)];\r\n}\r\nstatic\r\nvoid gss_header_swabber(struct gss_header *ghdr)\r\n{\r\n__swab32s(&ghdr->gh_flags);\r\n__swab32s(&ghdr->gh_proc);\r\n__swab32s(&ghdr->gh_seq);\r\n__swab32s(&ghdr->gh_svc);\r\n__swab32s(&ghdr->gh_pad1);\r\n__swab32s(&ghdr->gh_handle.len);\r\n}\r\nstruct gss_header *gss_swab_header(struct lustre_msg *msg, int segment,\r\nint swabbed)\r\n{\r\nstruct gss_header *ghdr;\r\nghdr = lustre_msg_buf(msg, segment, sizeof(*ghdr));\r\nif (ghdr == NULL)\r\nreturn NULL;\r\nif (swabbed)\r\ngss_header_swabber(ghdr);\r\nif (sizeof(*ghdr) + ghdr->gh_handle.len > msg->lm_buflens[segment]) {\r\nCERROR("gss header has length %d, now %u received\n",\r\n(int) sizeof(*ghdr) + ghdr->gh_handle.len,\r\nmsg->lm_buflens[segment]);\r\nreturn NULL;\r\n}\r\nreturn ghdr;\r\n}\r\nstatic inline\r\nint gss_mech_payload(struct gss_ctx *mechctx, int msgsize, int privacy)\r\n{\r\nif (privacy)\r\nreturn GSS_KRB5_INTEG_MAX_PAYLOAD + 16 + 16 + 16 + msgsize;\r\nelse\r\nreturn GSS_KRB5_INTEG_MAX_PAYLOAD;\r\n}\r\nstatic int gss_sign_msg(struct lustre_msg *msg,\r\nstruct gss_ctx *mechctx,\r\nenum lustre_sec_part sp,\r\n__u32 flags, __u32 proc, __u32 seq, __u32 svc,\r\nrawobj_t *handle)\r\n{\r\nstruct gss_header *ghdr;\r\nrawobj_t text[4], mic;\r\nint textcnt, max_textcnt, mic_idx;\r\n__u32 major;\r\nLASSERT(msg->lm_bufcount >= 2);\r\nLASSERT(msg->lm_buflens[0] >=\r\nsizeof(*ghdr) + (handle ? handle->len : 0));\r\nghdr = lustre_msg_buf(msg, 0, 0);\r\nghdr->gh_version = PTLRPC_GSS_VERSION;\r\nghdr->gh_sp = (__u8) sp;\r\nghdr->gh_flags = flags;\r\nghdr->gh_proc = proc;\r\nghdr->gh_seq = seq;\r\nghdr->gh_svc = svc;\r\nif (!handle) {\r\nghdr->gh_handle.len = 0;\r\n} else {\r\nghdr->gh_handle.len = handle->len;\r\nmemcpy(ghdr->gh_handle.data, handle->data, handle->len);\r\n}\r\nif (svc == SPTLRPC_SVC_NULL)\r\nreturn lustre_msg_size_v2(msg->lm_bufcount, msg->lm_buflens);\r\nmic_idx = msg_last_segidx(msg);\r\nmax_textcnt = (svc == SPTLRPC_SVC_AUTH) ? 1 : mic_idx;\r\nfor (textcnt = 0; textcnt < max_textcnt; textcnt++) {\r\ntext[textcnt].len = msg->lm_buflens[textcnt];\r\ntext[textcnt].data = lustre_msg_buf(msg, textcnt, 0);\r\n}\r\nmic.len = msg->lm_buflens[mic_idx];\r\nmic.data = lustre_msg_buf(msg, mic_idx, 0);\r\nmajor = lgss_get_mic(mechctx, textcnt, text, 0, NULL, &mic);\r\nif (major != GSS_S_COMPLETE) {\r\nCERROR("fail to generate MIC: %08x\n", major);\r\nreturn -EPERM;\r\n}\r\nLASSERT(mic.len <= msg->lm_buflens[mic_idx]);\r\nreturn lustre_shrink_msg(msg, mic_idx, mic.len, 0);\r\n}\r\nstatic\r\n__u32 gss_verify_msg(struct lustre_msg *msg,\r\nstruct gss_ctx *mechctx,\r\n__u32 svc)\r\n{\r\nrawobj_t text[4], mic;\r\nint textcnt, max_textcnt;\r\nint mic_idx;\r\n__u32 major;\r\nLASSERT(msg->lm_bufcount >= 2);\r\nif (svc == SPTLRPC_SVC_NULL)\r\nreturn GSS_S_COMPLETE;\r\nmic_idx = msg_last_segidx(msg);\r\nmax_textcnt = (svc == SPTLRPC_SVC_AUTH) ? 1 : mic_idx;\r\nfor (textcnt = 0; textcnt < max_textcnt; textcnt++) {\r\ntext[textcnt].len = msg->lm_buflens[textcnt];\r\ntext[textcnt].data = lustre_msg_buf(msg, textcnt, 0);\r\n}\r\nmic.len = msg->lm_buflens[mic_idx];\r\nmic.data = lustre_msg_buf(msg, mic_idx, 0);\r\nmajor = lgss_verify_mic(mechctx, textcnt, text, 0, NULL, &mic);\r\nif (major != GSS_S_COMPLETE)\r\nCERROR("mic verify error: %08x\n", major);\r\nreturn major;\r\n}\r\nstatic\r\n__u32 gss_unseal_msg(struct gss_ctx *mechctx,\r\nstruct lustre_msg *msgbuf,\r\nint *msg_len, int msgbuf_len)\r\n{\r\nrawobj_t clear_obj, hdrobj, token;\r\n__u8 *clear_buf;\r\nint clear_buflen;\r\n__u32 major;\r\nif (msgbuf->lm_bufcount != 2) {\r\nCERROR("invalid bufcount %d\n", msgbuf->lm_bufcount);\r\nreturn GSS_S_FAILURE;\r\n}\r\nclear_buflen = lustre_msg_buflen(msgbuf, 1);\r\nOBD_ALLOC_LARGE(clear_buf, clear_buflen);\r\nif (!clear_buf)\r\nreturn GSS_S_FAILURE;\r\nhdrobj.len = lustre_msg_buflen(msgbuf, 0);\r\nhdrobj.data = lustre_msg_buf(msgbuf, 0, 0);\r\ntoken.len = lustre_msg_buflen(msgbuf, 1);\r\ntoken.data = lustre_msg_buf(msgbuf, 1, 0);\r\nclear_obj.len = clear_buflen;\r\nclear_obj.data = clear_buf;\r\nmajor = lgss_unwrap(mechctx, &hdrobj, &token, &clear_obj);\r\nif (major != GSS_S_COMPLETE) {\r\nCERROR("unwrap message error: %08x\n", major);\r\nGOTO(out_free, major = GSS_S_FAILURE);\r\n}\r\nLASSERT(clear_obj.len <= clear_buflen);\r\nLASSERT(clear_obj.len <= msgbuf_len);\r\nmemcpy(msgbuf, clear_obj.data, clear_obj.len);\r\n*msg_len = clear_obj.len;\r\nmajor = GSS_S_COMPLETE;\r\nout_free:\r\nOBD_FREE_LARGE(clear_buf, clear_buflen);\r\nreturn major;\r\n}\r\nint cli_ctx_expire(struct ptlrpc_cli_ctx *ctx)\r\n{\r\nLASSERT(atomic_read(&ctx->cc_refcount));\r\nif (!test_and_set_bit(PTLRPC_CTX_DEAD_BIT, &ctx->cc_flags)) {\r\nif (!ctx->cc_early_expire)\r\nclear_bit(PTLRPC_CTX_UPTODATE_BIT, &ctx->cc_flags);\r\nCWARN("ctx %p(%u->%s) get expired: %lu(%+lds)\n",\r\nctx, ctx->cc_vcred.vc_uid, sec2target_str(ctx->cc_sec),\r\nctx->cc_expire,\r\nctx->cc_expire == 0 ? 0 :\r\ncfs_time_sub(ctx->cc_expire, cfs_time_current_sec()));\r\nsptlrpc_cli_ctx_wakeup(ctx);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint cli_ctx_check_death(struct ptlrpc_cli_ctx *ctx)\r\n{\r\nif (unlikely(cli_ctx_is_dead(ctx)))\r\nreturn 1;\r\nif (ctx->cc_expire == 0)\r\nreturn 0;\r\nif (cfs_time_after(ctx->cc_expire, cfs_time_current_sec()))\r\nreturn 0;\r\ncli_ctx_expire(ctx);\r\nreturn 1;\r\n}\r\nvoid gss_cli_ctx_uptodate(struct gss_cli_ctx *gctx)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx = &gctx->gc_base;\r\nunsigned long ctx_expiry;\r\nif (lgss_inquire_context(gctx->gc_mechctx, &ctx_expiry)) {\r\nCERROR("ctx %p(%u): unable to inquire, expire it now\n",\r\ngctx, ctx->cc_vcred.vc_uid);\r\nctx_expiry = 1;\r\n}\r\nctx->cc_expire = gss_round_ctx_expiry(ctx_expiry,\r\nctx->cc_sec->ps_flvr.sf_flags);\r\nset_bit(PTLRPC_CTX_UPTODATE_BIT, &ctx->cc_flags);\r\nif (sec_is_reverse(ctx->cc_sec)) {\r\nCWARN("server installed reverse ctx %p idx "LPX64", "\r\n"expiry %lu(%+lds)\n", ctx,\r\ngss_handle_to_u64(&gctx->gc_handle),\r\nctx->cc_expire, ctx->cc_expire - cfs_time_current_sec());\r\n} else {\r\nCWARN("client refreshed ctx %p idx "LPX64" (%u->%s), "\r\n"expiry %lu(%+lds)\n", ctx,\r\ngss_handle_to_u64(&gctx->gc_handle),\r\nctx->cc_vcred.vc_uid, sec2target_str(ctx->cc_sec),\r\nctx->cc_expire, ctx->cc_expire - cfs_time_current_sec());\r\nif (ctx->cc_vcred.vc_uid == 0)\r\ngss_sec_install_rctx(ctx->cc_sec->ps_import,\r\nctx->cc_sec, ctx);\r\n}\r\nsptlrpc_cli_ctx_wakeup(ctx);\r\n}\r\nstatic void gss_cli_ctx_finalize(struct gss_cli_ctx *gctx)\r\n{\r\nLASSERT(gctx->gc_base.cc_sec);\r\nif (gctx->gc_mechctx) {\r\nlgss_delete_sec_context(&gctx->gc_mechctx);\r\ngctx->gc_mechctx = NULL;\r\n}\r\nif (!rawobj_empty(&gctx->gc_svc_handle)) {\r\nif (!sec_is_reverse(gctx->gc_base.cc_sec) &&\r\n!rawobj_empty(&gctx->gc_svc_handle))\r\ngss_svc_upcall_expire_rvs_ctx(&gctx->gc_svc_handle);\r\nrawobj_free(&gctx->gc_svc_handle);\r\n}\r\nrawobj_free(&gctx->gc_handle);\r\n}\r\nstatic\r\nint gss_do_check_seq(unsigned long *window, __u32 win_size, __u32 *max_seq,\r\n__u32 seq_num, int phase)\r\n{\r\nLASSERT(phase >= 0 && phase <= 2);\r\nif (seq_num > *max_seq) {\r\nif (phase == 0)\r\nreturn 0;\r\nif (seq_num >= *max_seq + win_size) {\r\nmemset(window, 0, win_size / 8);\r\n*max_seq = seq_num;\r\n} else {\r\nwhile(*max_seq < seq_num) {\r\n(*max_seq)++;\r\n__clear_bit((*max_seq) % win_size, window);\r\n}\r\n}\r\n__set_bit(seq_num % win_size, window);\r\n} else if (seq_num + win_size <= *max_seq) {\r\nif (phase == 0 || phase == 2)\r\ngoto replay;\r\nCWARN("seq %u is %u behind (size %d), check backup window\n",\r\nseq_num, *max_seq - win_size - seq_num, win_size);\r\nreturn 1;\r\n} else {\r\nswitch (phase) {\r\ncase 0:\r\nif (test_bit(seq_num % win_size, window))\r\ngoto replay;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nif (__test_and_set_bit(seq_num % win_size, window))\r\ngoto replay;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\nreplay:\r\nCERROR("seq %u (%s %s window) is a replay: max %u, winsize %d\n",\r\nseq_num,\r\nseq_num + win_size > *max_seq ? "in" : "behind",\r\nphase == 2 ? "backup " : "main",\r\n*max_seq, win_size);\r\nreturn -1;\r\n}\r\nint gss_check_seq_num(struct gss_svc_seq_data *ssd, __u32 seq_num, int set)\r\n{\r\nint rc = 0;\r\nspin_lock(&ssd->ssd_lock);\r\nif (set == 0) {\r\nrc = gss_do_check_seq(ssd->ssd_win_main, GSS_SEQ_WIN_MAIN,\r\n&ssd->ssd_max_main, seq_num, 0);\r\nif (unlikely(rc))\r\ngss_stat_oos_record_svc(0, 1);\r\n} else {\r\nrc = gss_do_check_seq(ssd->ssd_win_main, GSS_SEQ_WIN_MAIN,\r\n&ssd->ssd_max_main, seq_num, 1);\r\nswitch (rc) {\r\ncase -1:\r\ngss_stat_oos_record_svc(1, 1);\r\ncase 0:\r\ngoto exit;\r\n}\r\nrc = gss_do_check_seq(ssd->ssd_win_back, GSS_SEQ_WIN_BACK,\r\n&ssd->ssd_max_back, seq_num, 2);\r\nif (rc)\r\ngss_stat_oos_record_svc(2, 1);\r\nelse\r\ngss_stat_oos_record_svc(2, 0);\r\n}\r\nexit:\r\nspin_unlock(&ssd->ssd_lock);\r\nreturn rc;\r\n}\r\nstatic inline int gss_cli_payload(struct ptlrpc_cli_ctx *ctx,\r\nint msgsize, int privacy)\r\n{\r\nreturn gss_mech_payload(NULL, msgsize, privacy);\r\n}\r\nstatic int gss_cli_bulk_payload(struct ptlrpc_cli_ctx *ctx,\r\nstruct sptlrpc_flavor *flvr,\r\nint reply, int read)\r\n{\r\nint payload = sizeof(struct ptlrpc_bulk_sec_desc);\r\nLASSERT(SPTLRPC_FLVR_BULK_TYPE(flvr->sf_rpc) == SPTLRPC_BULK_DEFAULT);\r\nif ((!reply && !read) || (reply && read)) {\r\nswitch (SPTLRPC_FLVR_BULK_SVC(flvr->sf_rpc)) {\r\ncase SPTLRPC_BULK_SVC_NULL:\r\nbreak;\r\ncase SPTLRPC_BULK_SVC_INTG:\r\npayload += gss_cli_payload(ctx, 0, 0);\r\nbreak;\r\ncase SPTLRPC_BULK_SVC_PRIV:\r\npayload += gss_cli_payload(ctx, 0, 1);\r\nbreak;\r\ncase SPTLRPC_BULK_SVC_AUTH:\r\ndefault:\r\nLBUG();\r\n}\r\n}\r\nreturn payload;\r\n}\r\nint gss_cli_ctx_match(struct ptlrpc_cli_ctx *ctx, struct vfs_cred *vcred)\r\n{\r\nreturn (ctx->cc_vcred.vc_uid == vcred->vc_uid);\r\n}\r\nvoid gss_cli_ctx_flags2str(unsigned long flags, char *buf, int bufsize)\r\n{\r\nbuf[0] = '\0';\r\nif (flags & PTLRPC_CTX_NEW)\r\nstrncat(buf, "new,", bufsize);\r\nif (flags & PTLRPC_CTX_UPTODATE)\r\nstrncat(buf, "uptodate,", bufsize);\r\nif (flags & PTLRPC_CTX_DEAD)\r\nstrncat(buf, "dead,", bufsize);\r\nif (flags & PTLRPC_CTX_ERROR)\r\nstrncat(buf, "error,", bufsize);\r\nif (flags & PTLRPC_CTX_CACHED)\r\nstrncat(buf, "cached,", bufsize);\r\nif (flags & PTLRPC_CTX_ETERNAL)\r\nstrncat(buf, "eternal,", bufsize);\r\nif (buf[0] == '\0')\r\nstrncat(buf, "-,", bufsize);\r\nbuf[strlen(buf) - 1] = '\0';\r\n}\r\nint gss_cli_ctx_sign(struct ptlrpc_cli_ctx *ctx,\r\nstruct ptlrpc_request *req)\r\n{\r\nstruct gss_cli_ctx *gctx = ctx2gctx(ctx);\r\n__u32 flags = 0, seq, svc;\r\nint rc;\r\nLASSERT(req->rq_reqbuf);\r\nLASSERT(req->rq_reqbuf->lm_bufcount >= 2);\r\nLASSERT(req->rq_cli_ctx == ctx);\r\nif (req->rq_ctx_init)\r\nreturn 0;\r\nsvc = SPTLRPC_FLVR_SVC(req->rq_flvr.sf_rpc);\r\nif (req->rq_pack_bulk)\r\nflags |= LUSTRE_GSS_PACK_BULK;\r\nif (req->rq_pack_udesc)\r\nflags |= LUSTRE_GSS_PACK_USER;\r\nredo:\r\nseq = atomic_inc_return(&gctx->gc_seq);\r\nrc = gss_sign_msg(req->rq_reqbuf, gctx->gc_mechctx,\r\nctx->cc_sec->ps_part,\r\nflags, gctx->gc_proc, seq, svc,\r\n&gctx->gc_handle);\r\nif (rc < 0)\r\nreturn rc;\r\nif (svc != SPTLRPC_SVC_NULL &&\r\natomic_read(&gctx->gc_seq) - seq > GSS_SEQ_REPACK_THRESHOLD) {\r\nint behind = atomic_read(&gctx->gc_seq) - seq;\r\ngss_stat_oos_record_cli(behind);\r\nCWARN("req %p: %u behind, retry signing\n", req, behind);\r\ngoto redo;\r\n}\r\nreq->rq_reqdata_len = rc;\r\nreturn 0;\r\n}\r\nstatic\r\nint gss_cli_ctx_handle_err_notify(struct ptlrpc_cli_ctx *ctx,\r\nstruct ptlrpc_request *req,\r\nstruct gss_header *ghdr)\r\n{\r\nstruct gss_err_header *errhdr;\r\nint rc;\r\nLASSERT(ghdr->gh_proc == PTLRPC_GSS_PROC_ERR);\r\nerrhdr = (struct gss_err_header *) ghdr;\r\nCWARN("req x"LPU64"/t"LPU64", ctx %p idx "LPX64"(%u->%s): "\r\n"%sserver respond (%08x/%08x)\n",\r\nreq->rq_xid, req->rq_transno, ctx,\r\ngss_handle_to_u64(&ctx2gctx(ctx)->gc_handle),\r\nctx->cc_vcred.vc_uid, sec2target_str(ctx->cc_sec),\r\nsec_is_reverse(ctx->cc_sec) ? "reverse" : "",\r\nerrhdr->gh_major, errhdr->gh_minor);\r\nif (req->rq_ctx_fini) {\r\nCWARN("context fini rpc failed\n");\r\nreturn -EINVAL;\r\n}\r\nif (sec_is_reverse(ctx->cc_sec))\r\nreturn -EINVAL;\r\nif (errhdr->gh_major != GSS_S_NO_CONTEXT &&\r\nerrhdr->gh_major != GSS_S_BAD_SIG)\r\nreturn -EACCES;\r\nCWARN("%s: server might lost the context, retrying\n",\r\nerrhdr->gh_major == GSS_S_NO_CONTEXT ? "NO_CONTEXT" : "BAD_SIG");\r\nsptlrpc_cli_ctx_expire(ctx);\r\nrc = sptlrpc_req_replace_dead_ctx(req);\r\nif (rc == 0)\r\nreq->rq_resend = 1;\r\nreturn rc;\r\n}\r\nint gss_cli_ctx_verify(struct ptlrpc_cli_ctx *ctx,\r\nstruct ptlrpc_request *req)\r\n{\r\nstruct gss_cli_ctx *gctx;\r\nstruct gss_header *ghdr, *reqhdr;\r\nstruct lustre_msg *msg = req->rq_repdata;\r\n__u32 major;\r\nint pack_bulk, swabbed, rc = 0;\r\nLASSERT(req->rq_cli_ctx == ctx);\r\nLASSERT(msg);\r\ngctx = container_of(ctx, struct gss_cli_ctx, gc_base);\r\nif (req->rq_ctx_init && !req->rq_early) {\r\nreq->rq_repmsg = lustre_msg_buf(msg, 1, 0);\r\nreq->rq_replen = msg->lm_buflens[1];\r\nreturn 0;\r\n}\r\nif (msg->lm_bufcount < 2 || msg->lm_bufcount > 4) {\r\nCERROR("unexpected bufcount %u\n", msg->lm_bufcount);\r\nreturn -EPROTO;\r\n}\r\nswabbed = ptlrpc_rep_need_swab(req);\r\nghdr = gss_swab_header(msg, 0, swabbed);\r\nif (ghdr == NULL) {\r\nCERROR("can't decode gss header\n");\r\nreturn -EPROTO;\r\n}\r\nreqhdr = lustre_msg_buf(msg, 0, sizeof(*reqhdr));\r\nLASSERT(reqhdr);\r\nif (ghdr->gh_version != reqhdr->gh_version) {\r\nCERROR("gss version %u mismatch, expect %u\n",\r\nghdr->gh_version, reqhdr->gh_version);\r\nreturn -EPROTO;\r\n}\r\nswitch (ghdr->gh_proc) {\r\ncase PTLRPC_GSS_PROC_DATA:\r\npack_bulk = ghdr->gh_flags & LUSTRE_GSS_PACK_BULK;\r\nif (!req->rq_early && !equi(req->rq_pack_bulk == 1, pack_bulk)){\r\nCERROR("%s bulk flag in reply\n",\r\nreq->rq_pack_bulk ? "missing" : "unexpected");\r\nreturn -EPROTO;\r\n}\r\nif (ghdr->gh_seq != reqhdr->gh_seq) {\r\nCERROR("seqnum %u mismatch, expect %u\n",\r\nghdr->gh_seq, reqhdr->gh_seq);\r\nreturn -EPROTO;\r\n}\r\nif (ghdr->gh_svc != reqhdr->gh_svc) {\r\nCERROR("svc %u mismatch, expect %u\n",\r\nghdr->gh_svc, reqhdr->gh_svc);\r\nreturn -EPROTO;\r\n}\r\nif (swabbed)\r\ngss_header_swabber(ghdr);\r\nmajor = gss_verify_msg(msg, gctx->gc_mechctx, reqhdr->gh_svc);\r\nif (major != GSS_S_COMPLETE) {\r\nCERROR("failed to verify reply: %x\n", major);\r\nreturn -EPERM;\r\n}\r\nif (req->rq_early && reqhdr->gh_svc == SPTLRPC_SVC_NULL) {\r\n__u32 cksum;\r\ncksum = crc32_le(!(__u32) 0,\r\nlustre_msg_buf(msg, 1, 0),\r\nlustre_msg_buflen(msg, 1));\r\nif (cksum != msg->lm_cksum) {\r\nCWARN("early reply checksum mismatch: "\r\n"%08x != %08x\n", cksum, msg->lm_cksum);\r\nreturn -EPROTO;\r\n}\r\n}\r\nif (pack_bulk) {\r\nif (msg->lm_bufcount < 3) {\r\nCERROR("Invalid reply bufcount %u\n",\r\nmsg->lm_bufcount);\r\nreturn -EPROTO;\r\n}\r\nrc = bulk_sec_desc_unpack(msg, 2, swabbed);\r\nif (rc) {\r\nCERROR("unpack bulk desc: %d\n", rc);\r\nreturn rc;\r\n}\r\n}\r\nreq->rq_repmsg = lustre_msg_buf(msg, 1, 0);\r\nreq->rq_replen = msg->lm_buflens[1];\r\nbreak;\r\ncase PTLRPC_GSS_PROC_ERR:\r\nif (req->rq_early) {\r\nCERROR("server return error with early reply\n");\r\nrc = -EPROTO;\r\n} else {\r\nrc = gss_cli_ctx_handle_err_notify(ctx, req, ghdr);\r\n}\r\nbreak;\r\ndefault:\r\nCERROR("unknown gss proc %d\n", ghdr->gh_proc);\r\nrc = -EPROTO;\r\n}\r\nreturn rc;\r\n}\r\nint gss_cli_ctx_seal(struct ptlrpc_cli_ctx *ctx,\r\nstruct ptlrpc_request *req)\r\n{\r\nstruct gss_cli_ctx *gctx;\r\nrawobj_t hdrobj, msgobj, token;\r\nstruct gss_header *ghdr;\r\n__u32 buflens[2], major;\r\nint wiresize, rc;\r\nLASSERT(req->rq_clrbuf);\r\nLASSERT(req->rq_cli_ctx == ctx);\r\nLASSERT(req->rq_reqlen);\r\ngctx = container_of(ctx, struct gss_cli_ctx, gc_base);\r\nreq->rq_clrdata_len = lustre_msg_size_v2(req->rq_clrbuf->lm_bufcount,\r\nreq->rq_clrbuf->lm_buflens);\r\nbuflens[0] = PTLRPC_GSS_HEADER_SIZE;\r\nbuflens[1] = gss_cli_payload(&gctx->gc_base, req->rq_clrdata_len, 1);\r\nwiresize = lustre_msg_size_v2(2, buflens);\r\nif (req->rq_pool) {\r\nLASSERT(req->rq_reqbuf);\r\nLASSERT(req->rq_reqbuf != req->rq_clrbuf);\r\nLASSERT(req->rq_reqbuf_len >= wiresize);\r\n} else {\r\nOBD_ALLOC_LARGE(req->rq_reqbuf, wiresize);\r\nif (!req->rq_reqbuf)\r\nreturn -ENOMEM;\r\nreq->rq_reqbuf_len = wiresize;\r\n}\r\nlustre_init_msg_v2(req->rq_reqbuf, 2, buflens, NULL);\r\nreq->rq_reqbuf->lm_secflvr = req->rq_flvr.sf_rpc;\r\nghdr = lustre_msg_buf(req->rq_reqbuf, 0, 0);\r\nghdr->gh_version = PTLRPC_GSS_VERSION;\r\nghdr->gh_sp = (__u8) ctx->cc_sec->ps_part;\r\nghdr->gh_flags = 0;\r\nghdr->gh_proc = gctx->gc_proc;\r\nghdr->gh_svc = SPTLRPC_SVC_PRIV;\r\nghdr->gh_handle.len = gctx->gc_handle.len;\r\nmemcpy(ghdr->gh_handle.data, gctx->gc_handle.data, gctx->gc_handle.len);\r\nif (req->rq_pack_bulk)\r\nghdr->gh_flags |= LUSTRE_GSS_PACK_BULK;\r\nif (req->rq_pack_udesc)\r\nghdr->gh_flags |= LUSTRE_GSS_PACK_USER;\r\nredo:\r\nghdr->gh_seq = atomic_inc_return(&gctx->gc_seq);\r\nhdrobj.len = PTLRPC_GSS_HEADER_SIZE;\r\nhdrobj.data = (__u8 *) ghdr;\r\nmsgobj.len = req->rq_clrdata_len;\r\nmsgobj.data = (__u8 *) req->rq_clrbuf;\r\ntoken.len = lustre_msg_buflen(req->rq_reqbuf, 1);\r\ntoken.data = lustre_msg_buf(req->rq_reqbuf, 1, 0);\r\nmajor = lgss_wrap(gctx->gc_mechctx, &hdrobj, &msgobj,\r\nreq->rq_clrbuf_len, &token);\r\nif (major != GSS_S_COMPLETE) {\r\nCERROR("priv: wrap message error: %08x\n", major);\r\nGOTO(err_free, rc = -EPERM);\r\n}\r\nLASSERT(token.len <= buflens[1]);\r\nif (unlikely(atomic_read(&gctx->gc_seq) - ghdr->gh_seq >\r\nGSS_SEQ_REPACK_THRESHOLD)) {\r\nint behind = atomic_read(&gctx->gc_seq) - ghdr->gh_seq;\r\ngss_stat_oos_record_cli(behind);\r\nCWARN("req %p: %u behind, retry sealing\n", req, behind);\r\nghdr->gh_seq = atomic_inc_return(&gctx->gc_seq);\r\ngoto redo;\r\n}\r\nreq->rq_reqdata_len = lustre_shrink_msg(req->rq_reqbuf, 1, token.len,0);\r\nreturn 0;\r\nerr_free:\r\nif (!req->rq_pool) {\r\nOBD_FREE_LARGE(req->rq_reqbuf, req->rq_reqbuf_len);\r\nreq->rq_reqbuf = NULL;\r\nreq->rq_reqbuf_len = 0;\r\n}\r\nreturn rc;\r\n}\r\nint gss_cli_ctx_unseal(struct ptlrpc_cli_ctx *ctx,\r\nstruct ptlrpc_request *req)\r\n{\r\nstruct gss_cli_ctx *gctx;\r\nstruct gss_header *ghdr;\r\nstruct lustre_msg *msg = req->rq_repdata;\r\nint msglen, pack_bulk, swabbed, rc;\r\n__u32 major;\r\nLASSERT(req->rq_cli_ctx == ctx);\r\nLASSERT(req->rq_ctx_init == 0);\r\nLASSERT(msg);\r\ngctx = container_of(ctx, struct gss_cli_ctx, gc_base);\r\nswabbed = ptlrpc_rep_need_swab(req);\r\nghdr = gss_swab_header(msg, 0, swabbed);\r\nif (ghdr == NULL) {\r\nCERROR("can't decode gss header\n");\r\nreturn -EPROTO;\r\n}\r\nif (ghdr->gh_version != PTLRPC_GSS_VERSION) {\r\nCERROR("gss version %u mismatch, expect %u\n",\r\nghdr->gh_version, PTLRPC_GSS_VERSION);\r\nreturn -EPROTO;\r\n}\r\nswitch (ghdr->gh_proc) {\r\ncase PTLRPC_GSS_PROC_DATA:\r\npack_bulk = ghdr->gh_flags & LUSTRE_GSS_PACK_BULK;\r\nif (!req->rq_early && !equi(req->rq_pack_bulk == 1, pack_bulk)){\r\nCERROR("%s bulk flag in reply\n",\r\nreq->rq_pack_bulk ? "missing" : "unexpected");\r\nreturn -EPROTO;\r\n}\r\nif (swabbed)\r\ngss_header_swabber(ghdr);\r\nmajor = gss_unseal_msg(gctx->gc_mechctx, msg,\r\n&msglen, req->rq_repdata_len);\r\nif (major != GSS_S_COMPLETE) {\r\nCERROR("failed to unwrap reply: %x\n", major);\r\nrc = -EPERM;\r\nbreak;\r\n}\r\nswabbed = __lustre_unpack_msg(msg, msglen);\r\nif (swabbed < 0) {\r\nCERROR("Failed to unpack after decryption\n");\r\nreturn -EPROTO;\r\n}\r\nif (msg->lm_bufcount < 1) {\r\nCERROR("Invalid reply buffer: empty\n");\r\nreturn -EPROTO;\r\n}\r\nif (pack_bulk) {\r\nif (msg->lm_bufcount < 2) {\r\nCERROR("bufcount %u: missing bulk sec desc\n",\r\nmsg->lm_bufcount);\r\nreturn -EPROTO;\r\n}\r\nif (bulk_sec_desc_unpack(msg, msg->lm_bufcount - 1,\r\nswabbed))\r\nreturn -EPROTO;\r\n}\r\nreq->rq_repmsg = lustre_msg_buf(msg, 0, 0);\r\nreq->rq_replen = msg->lm_buflens[0];\r\nrc = 0;\r\nbreak;\r\ncase PTLRPC_GSS_PROC_ERR:\r\nif (req->rq_early) {\r\nCERROR("server return error with early reply\n");\r\nrc = -EPROTO;\r\n} else {\r\nrc = gss_cli_ctx_handle_err_notify(ctx, req, ghdr);\r\n}\r\nbreak;\r\ndefault:\r\nCERROR("unexpected proc %d\n", ghdr->gh_proc);\r\nrc = -EPERM;\r\n}\r\nreturn rc;\r\n}\r\nstatic inline\r\nint gss_install_rvs_svc_ctx(struct obd_import *imp,\r\nstruct gss_sec *gsec,\r\nstruct gss_cli_ctx *gctx)\r\n{\r\nreturn gss_svc_upcall_install_rvs_ctx(imp, gsec, gctx);\r\n}\r\nint gss_sec_create_common(struct gss_sec *gsec,\r\nstruct ptlrpc_sec_policy *policy,\r\nstruct obd_import *imp,\r\nstruct ptlrpc_svc_ctx *svcctx,\r\nstruct sptlrpc_flavor *sf)\r\n{\r\nstruct ptlrpc_sec *sec;\r\nLASSERT(imp);\r\nLASSERT(SPTLRPC_FLVR_POLICY(sf->sf_rpc) == SPTLRPC_POLICY_GSS);\r\ngsec->gs_mech = lgss_subflavor_to_mech(\r\nSPTLRPC_FLVR_BASE_SUB(sf->sf_rpc));\r\nif (!gsec->gs_mech) {\r\nCERROR("gss backend 0x%x not found\n",\r\nSPTLRPC_FLVR_BASE_SUB(sf->sf_rpc));\r\nreturn -EOPNOTSUPP;\r\n}\r\nspin_lock_init(&gsec->gs_lock);\r\ngsec->gs_rvs_hdl = 0ULL;\r\nsec = &gsec->gs_base;\r\nsec->ps_policy = policy;\r\natomic_set(&sec->ps_refcount, 0);\r\natomic_set(&sec->ps_nctx, 0);\r\nsec->ps_id = sptlrpc_get_next_secid();\r\nsec->ps_flvr = *sf;\r\nsec->ps_import = class_import_get(imp);\r\nspin_lock_init(&sec->ps_lock);\r\nINIT_LIST_HEAD(&sec->ps_gc_list);\r\nif (!svcctx) {\r\nsec->ps_gc_interval = GSS_GC_INTERVAL;\r\n} else {\r\nLASSERT(sec_is_reverse(sec));\r\nsec->ps_gc_interval = 0;\r\n}\r\nif (SPTLRPC_FLVR_BULK_SVC(sec->ps_flvr.sf_rpc) == SPTLRPC_BULK_SVC_PRIV)\r\nsptlrpc_enc_pool_add_user();\r\nCDEBUG(D_SEC, "create %s%s@%p\n", (svcctx ? "reverse " : ""),\r\npolicy->sp_name, gsec);\r\nreturn 0;\r\n}\r\nvoid gss_sec_destroy_common(struct gss_sec *gsec)\r\n{\r\nstruct ptlrpc_sec *sec = &gsec->gs_base;\r\nLASSERT(sec->ps_import);\r\nLASSERT(atomic_read(&sec->ps_refcount) == 0);\r\nLASSERT(atomic_read(&sec->ps_nctx) == 0);\r\nif (gsec->gs_mech) {\r\nlgss_mech_put(gsec->gs_mech);\r\ngsec->gs_mech = NULL;\r\n}\r\nclass_import_put(sec->ps_import);\r\nif (SPTLRPC_FLVR_BULK_SVC(sec->ps_flvr.sf_rpc) == SPTLRPC_BULK_SVC_PRIV)\r\nsptlrpc_enc_pool_del_user();\r\n}\r\nvoid gss_sec_kill(struct ptlrpc_sec *sec)\r\n{\r\nsec->ps_dying = 1;\r\n}\r\nint gss_cli_ctx_init_common(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_cli_ctx *ctx,\r\nstruct ptlrpc_ctx_ops *ctxops,\r\nstruct vfs_cred *vcred)\r\n{\r\nstruct gss_cli_ctx *gctx = ctx2gctx(ctx);\r\ngctx->gc_win = 0;\r\natomic_set(&gctx->gc_seq, 0);\r\nINIT_HLIST_NODE(&ctx->cc_cache);\r\natomic_set(&ctx->cc_refcount, 0);\r\nctx->cc_sec = sec;\r\nctx->cc_ops = ctxops;\r\nctx->cc_expire = 0;\r\nctx->cc_flags = PTLRPC_CTX_NEW;\r\nctx->cc_vcred = *vcred;\r\nspin_lock_init(&ctx->cc_lock);\r\nINIT_LIST_HEAD(&ctx->cc_req_list);\r\nINIT_LIST_HEAD(&ctx->cc_gc_chain);\r\natomic_inc(&sec->ps_refcount);\r\natomic_inc(&sec->ps_nctx);\r\nCDEBUG(D_SEC, "%s@%p: create ctx %p(%u->%s)\n",\r\nsec->ps_policy->sp_name, ctx->cc_sec,\r\nctx, ctx->cc_vcred.vc_uid, sec2target_str(ctx->cc_sec));\r\nreturn 0;\r\n}\r\nint gss_cli_ctx_fini_common(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_cli_ctx *ctx)\r\n{\r\nstruct gss_cli_ctx *gctx = ctx2gctx(ctx);\r\nLASSERT(atomic_read(&sec->ps_nctx) > 0);\r\nLASSERT(atomic_read(&ctx->cc_refcount) == 0);\r\nLASSERT(ctx->cc_sec == sec);\r\nif (sec_is_reverse(sec))\r\nctx->cc_flags &= ~PTLRPC_CTX_UPTODATE;\r\nif (gctx->gc_mechctx) {\r\natomic_inc(&ctx->cc_refcount);\r\ngss_do_ctx_fini_rpc(gctx);\r\ngss_cli_ctx_finalize(gctx);\r\nif (!atomic_dec_and_test(&ctx->cc_refcount))\r\nreturn 1;\r\n}\r\nif (sec_is_reverse(sec))\r\nCWARN("reverse sec %p: destroy ctx %p\n",\r\nctx->cc_sec, ctx);\r\nelse\r\nCWARN("%s@%p: destroy ctx %p(%u->%s)\n",\r\nsec->ps_policy->sp_name, ctx->cc_sec,\r\nctx, ctx->cc_vcred.vc_uid, sec2target_str(ctx->cc_sec));\r\nreturn 0;\r\n}\r\nstatic\r\nint gss_alloc_reqbuf_intg(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req,\r\nint svc, int msgsize)\r\n{\r\nint bufsize, txtsize;\r\nint bufcnt = 2;\r\n__u32 buflens[5];\r\nbuflens[0] = PTLRPC_GSS_HEADER_SIZE;\r\ntxtsize = buflens[0];\r\nbuflens[1] = msgsize;\r\nif (svc == SPTLRPC_SVC_INTG)\r\ntxtsize += buflens[1];\r\nif (req->rq_pack_udesc) {\r\nbuflens[bufcnt] = sptlrpc_current_user_desc_size();\r\nif (svc == SPTLRPC_SVC_INTG)\r\ntxtsize += buflens[bufcnt];\r\nbufcnt++;\r\n}\r\nif (req->rq_pack_bulk) {\r\nbuflens[bufcnt] = gss_cli_bulk_payload(req->rq_cli_ctx,\r\n&req->rq_flvr,\r\n0, req->rq_bulk_read);\r\nif (svc == SPTLRPC_SVC_INTG)\r\ntxtsize += buflens[bufcnt];\r\nbufcnt++;\r\n}\r\nif (req->rq_ctx_init)\r\nbuflens[bufcnt++] = GSS_CTX_INIT_MAX_LEN;\r\nelse if (svc != SPTLRPC_SVC_NULL)\r\nbuflens[bufcnt++] = gss_cli_payload(req->rq_cli_ctx, txtsize,0);\r\nbufsize = lustre_msg_size_v2(bufcnt, buflens);\r\nif (!req->rq_reqbuf) {\r\nbufsize = size_roundup_power2(bufsize);\r\nOBD_ALLOC_LARGE(req->rq_reqbuf, bufsize);\r\nif (!req->rq_reqbuf)\r\nreturn -ENOMEM;\r\nreq->rq_reqbuf_len = bufsize;\r\n} else {\r\nLASSERT(req->rq_pool);\r\nLASSERT(req->rq_reqbuf_len >= bufsize);\r\nmemset(req->rq_reqbuf, 0, bufsize);\r\n}\r\nlustre_init_msg_v2(req->rq_reqbuf, bufcnt, buflens, NULL);\r\nreq->rq_reqbuf->lm_secflvr = req->rq_flvr.sf_rpc;\r\nreq->rq_reqmsg = lustre_msg_buf(req->rq_reqbuf, 1, msgsize);\r\nLASSERT(req->rq_reqmsg);\r\nif (req->rq_pack_udesc)\r\nsptlrpc_pack_user_desc(req->rq_reqbuf, 2);\r\nreturn 0;\r\n}\r\nstatic\r\nint gss_alloc_reqbuf_priv(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req,\r\nint msgsize)\r\n{\r\n__u32 ibuflens[3], wbuflens[2];\r\nint ibufcnt;\r\nint clearsize, wiresize;\r\nLASSERT(req->rq_clrbuf == NULL);\r\nLASSERT(req->rq_clrbuf_len == 0);\r\nibufcnt = 1;\r\nibuflens[0] = msgsize;\r\nif (req->rq_pack_udesc)\r\nibuflens[ibufcnt++] = sptlrpc_current_user_desc_size();\r\nif (req->rq_pack_bulk)\r\nibuflens[ibufcnt++] = gss_cli_bulk_payload(req->rq_cli_ctx,\r\n&req->rq_flvr, 0,\r\nreq->rq_bulk_read);\r\nclearsize = lustre_msg_size_v2(ibufcnt, ibuflens);\r\nclearsize += GSS_MAX_CIPHER_BLOCK;\r\nwbuflens[0] = PTLRPC_GSS_HEADER_SIZE;\r\nwbuflens[1] = gss_cli_payload(req->rq_cli_ctx, clearsize, 1);\r\nwiresize = lustre_msg_size_v2(2, wbuflens);\r\nif (req->rq_pool) {\r\nLASSERT(req->rq_reqbuf);\r\nLASSERT(req->rq_reqbuf_len >= wiresize);\r\nmemset(req->rq_reqbuf, 0, req->rq_reqbuf_len);\r\nif (clearsize + wiresize <= req->rq_reqbuf_len) {\r\nreq->rq_clrbuf =\r\n(void *) (((char *) req->rq_reqbuf) + wiresize);\r\n} else {\r\nCWARN("pre-allocated buf size %d is not enough for "\r\n"both clear (%d) and cipher (%d) text, proceed "\r\n"with extra allocation\n", req->rq_reqbuf_len,\r\nclearsize, wiresize);\r\n}\r\n}\r\nif (!req->rq_clrbuf) {\r\nclearsize = size_roundup_power2(clearsize);\r\nOBD_ALLOC_LARGE(req->rq_clrbuf, clearsize);\r\nif (!req->rq_clrbuf)\r\nreturn -ENOMEM;\r\n}\r\nreq->rq_clrbuf_len = clearsize;\r\nlustre_init_msg_v2(req->rq_clrbuf, ibufcnt, ibuflens, NULL);\r\nreq->rq_reqmsg = lustre_msg_buf(req->rq_clrbuf, 0, msgsize);\r\nif (req->rq_pack_udesc)\r\nsptlrpc_pack_user_desc(req->rq_clrbuf, 1);\r\nreturn 0;\r\n}\r\nint gss_alloc_reqbuf(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req,\r\nint msgsize)\r\n{\r\nint svc = SPTLRPC_FLVR_SVC(req->rq_flvr.sf_rpc);\r\nLASSERT(!req->rq_pack_bulk ||\r\n(req->rq_bulk_read || req->rq_bulk_write));\r\nswitch (svc) {\r\ncase SPTLRPC_SVC_NULL:\r\ncase SPTLRPC_SVC_AUTH:\r\ncase SPTLRPC_SVC_INTG:\r\nreturn gss_alloc_reqbuf_intg(sec, req, svc, msgsize);\r\ncase SPTLRPC_SVC_PRIV:\r\nreturn gss_alloc_reqbuf_priv(sec, req, msgsize);\r\ndefault:\r\nLASSERTF(0, "bad rpc flavor %x\n", req->rq_flvr.sf_rpc);\r\nreturn 0;\r\n}\r\n}\r\nvoid gss_free_reqbuf(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req)\r\n{\r\nint privacy;\r\nLASSERT(!req->rq_pool || req->rq_reqbuf);\r\nprivacy = SPTLRPC_FLVR_SVC(req->rq_flvr.sf_rpc) == SPTLRPC_SVC_PRIV;\r\nif (!req->rq_clrbuf)\r\ngoto release_reqbuf;\r\nLASSERT(privacy);\r\nLASSERT(req->rq_clrbuf_len);\r\nif (req->rq_pool == NULL ||\r\nreq->rq_clrbuf < req->rq_reqbuf ||\r\n(char *) req->rq_clrbuf >=\r\n(char *) req->rq_reqbuf + req->rq_reqbuf_len)\r\nOBD_FREE_LARGE(req->rq_clrbuf, req->rq_clrbuf_len);\r\nreq->rq_clrbuf = NULL;\r\nreq->rq_clrbuf_len = 0;\r\nrelease_reqbuf:\r\nif (!req->rq_pool && req->rq_reqbuf) {\r\nLASSERT(req->rq_reqbuf_len);\r\nOBD_FREE_LARGE(req->rq_reqbuf, req->rq_reqbuf_len);\r\nreq->rq_reqbuf = NULL;\r\nreq->rq_reqbuf_len = 0;\r\n}\r\n}\r\nstatic int do_alloc_repbuf(struct ptlrpc_request *req, int bufsize)\r\n{\r\nbufsize = size_roundup_power2(bufsize);\r\nOBD_ALLOC_LARGE(req->rq_repbuf, bufsize);\r\nif (!req->rq_repbuf)\r\nreturn -ENOMEM;\r\nreq->rq_repbuf_len = bufsize;\r\nreturn 0;\r\n}\r\nstatic\r\nint gss_alloc_repbuf_intg(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req,\r\nint svc, int msgsize)\r\n{\r\nint txtsize;\r\n__u32 buflens[4];\r\nint bufcnt = 2;\r\nint alloc_size;\r\nbuflens[0] = PTLRPC_GSS_HEADER_SIZE;\r\ntxtsize = buflens[0];\r\nbuflens[1] = msgsize;\r\nif (svc == SPTLRPC_SVC_INTG)\r\ntxtsize += buflens[1];\r\nif (req->rq_pack_bulk) {\r\nbuflens[bufcnt] = gss_cli_bulk_payload(req->rq_cli_ctx,\r\n&req->rq_flvr,\r\n1, req->rq_bulk_read);\r\nif (svc == SPTLRPC_SVC_INTG)\r\ntxtsize += buflens[bufcnt];\r\nbufcnt++;\r\n}\r\nif (req->rq_ctx_init)\r\nbuflens[bufcnt++] = GSS_CTX_INIT_MAX_LEN;\r\nelse if (svc != SPTLRPC_SVC_NULL)\r\nbuflens[bufcnt++] = gss_cli_payload(req->rq_cli_ctx, txtsize,0);\r\nalloc_size = lustre_msg_size_v2(bufcnt, buflens);\r\nalloc_size += gss_at_reply_off_integ;\r\nreturn do_alloc_repbuf(req, alloc_size);\r\n}\r\nstatic\r\nint gss_alloc_repbuf_priv(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req,\r\nint msgsize)\r\n{\r\nint txtsize;\r\n__u32 buflens[2];\r\nint bufcnt;\r\nint alloc_size;\r\nbufcnt = 1;\r\nbuflens[0] = msgsize;\r\nif (req->rq_pack_bulk)\r\nbuflens[bufcnt++] = gss_cli_bulk_payload(req->rq_cli_ctx,\r\n&req->rq_flvr,\r\n1, req->rq_bulk_read);\r\ntxtsize = lustre_msg_size_v2(bufcnt, buflens);\r\ntxtsize += GSS_MAX_CIPHER_BLOCK;\r\nbufcnt = 2;\r\nbuflens[0] = PTLRPC_GSS_HEADER_SIZE;\r\nbuflens[1] = gss_cli_payload(req->rq_cli_ctx, txtsize, 1);\r\nalloc_size = lustre_msg_size_v2(bufcnt, buflens);\r\nalloc_size += gss_at_reply_off_priv;\r\nreturn do_alloc_repbuf(req, alloc_size);\r\n}\r\nint gss_alloc_repbuf(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req,\r\nint msgsize)\r\n{\r\nint svc = SPTLRPC_FLVR_SVC(req->rq_flvr.sf_rpc);\r\nLASSERT(!req->rq_pack_bulk ||\r\n(req->rq_bulk_read || req->rq_bulk_write));\r\nswitch (svc) {\r\ncase SPTLRPC_SVC_NULL:\r\ncase SPTLRPC_SVC_AUTH:\r\ncase SPTLRPC_SVC_INTG:\r\nreturn gss_alloc_repbuf_intg(sec, req, svc, msgsize);\r\ncase SPTLRPC_SVC_PRIV:\r\nreturn gss_alloc_repbuf_priv(sec, req, msgsize);\r\ndefault:\r\nLASSERTF(0, "bad rpc flavor %x\n", req->rq_flvr.sf_rpc);\r\nreturn 0;\r\n}\r\n}\r\nvoid gss_free_repbuf(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req)\r\n{\r\nOBD_FREE_LARGE(req->rq_repbuf, req->rq_repbuf_len);\r\nreq->rq_repbuf = NULL;\r\nreq->rq_repbuf_len = 0;\r\nreq->rq_repdata = NULL;\r\nreq->rq_repdata_len = 0;\r\n}\r\nstatic int get_enlarged_msgsize(struct lustre_msg *msg,\r\nint segment, int newsize)\r\n{\r\nint save, newmsg_size;\r\nLASSERT(newsize >= msg->lm_buflens[segment]);\r\nsave = msg->lm_buflens[segment];\r\nmsg->lm_buflens[segment] = newsize;\r\nnewmsg_size = lustre_msg_size_v2(msg->lm_bufcount, msg->lm_buflens);\r\nmsg->lm_buflens[segment] = save;\r\nreturn newmsg_size;\r\n}\r\nstatic int get_enlarged_msgsize2(struct lustre_msg *msg,\r\nint segment1, int newsize1,\r\nint segment2, int newsize2)\r\n{\r\nint save1, save2, newmsg_size;\r\nLASSERT(newsize1 >= msg->lm_buflens[segment1]);\r\nLASSERT(newsize2 >= msg->lm_buflens[segment2]);\r\nsave1 = msg->lm_buflens[segment1];\r\nsave2 = msg->lm_buflens[segment2];\r\nmsg->lm_buflens[segment1] = newsize1;\r\nmsg->lm_buflens[segment2] = newsize2;\r\nnewmsg_size = lustre_msg_size_v2(msg->lm_bufcount, msg->lm_buflens);\r\nmsg->lm_buflens[segment1] = save1;\r\nmsg->lm_buflens[segment2] = save2;\r\nreturn newmsg_size;\r\n}\r\nstatic\r\nint gss_enlarge_reqbuf_intg(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req,\r\nint svc,\r\nint segment, int newsize)\r\n{\r\nstruct lustre_msg *newbuf;\r\nint txtsize, sigsize = 0, i;\r\nint newmsg_size, newbuf_size;\r\nLASSERT(req->rq_reqbuf);\r\nLASSERT(req->rq_reqbuf_len > req->rq_reqlen);\r\nLASSERT(req->rq_reqbuf->lm_bufcount >= 2);\r\nLASSERT(lustre_msg_buf(req->rq_reqbuf, 1, 0) == req->rq_reqmsg);\r\nnewmsg_size = get_enlarged_msgsize(req->rq_reqmsg, segment, newsize);\r\nLASSERT(newmsg_size >= req->rq_reqbuf->lm_buflens[1]);\r\nif (svc == SPTLRPC_SVC_NULL) {\r\nnewbuf_size = get_enlarged_msgsize(req->rq_reqbuf,\r\n1, newmsg_size);\r\n} else {\r\ntxtsize = req->rq_reqbuf->lm_buflens[0];\r\nif (svc == SPTLRPC_SVC_INTG) {\r\nfor (i = 1; i < req->rq_reqbuf->lm_bufcount; i++)\r\ntxtsize += req->rq_reqbuf->lm_buflens[i];\r\ntxtsize += newmsg_size - req->rq_reqbuf->lm_buflens[1];\r\n}\r\nsigsize = gss_cli_payload(req->rq_cli_ctx, txtsize, 0);\r\nLASSERT(sigsize >= msg_last_seglen(req->rq_reqbuf));\r\nnewbuf_size = get_enlarged_msgsize2(\r\nreq->rq_reqbuf,\r\n1, newmsg_size,\r\nmsg_last_segidx(req->rq_reqbuf),\r\nsigsize);\r\n}\r\nLASSERT(!req->rq_pool || req->rq_reqbuf_len >= newbuf_size);\r\nif (req->rq_reqbuf_len < newbuf_size) {\r\nnewbuf_size = size_roundup_power2(newbuf_size);\r\nOBD_ALLOC_LARGE(newbuf, newbuf_size);\r\nif (newbuf == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(newbuf, req->rq_reqbuf, req->rq_reqbuf_len);\r\nOBD_FREE_LARGE(req->rq_reqbuf, req->rq_reqbuf_len);\r\nreq->rq_reqbuf = newbuf;\r\nreq->rq_reqbuf_len = newbuf_size;\r\nreq->rq_reqmsg = lustre_msg_buf(req->rq_reqbuf, 1, 0);\r\n}\r\nif (svc != SPTLRPC_SVC_NULL)\r\n_sptlrpc_enlarge_msg_inplace(req->rq_reqbuf,\r\nmsg_last_segidx(req->rq_reqbuf),\r\nsigsize);\r\n_sptlrpc_enlarge_msg_inplace(req->rq_reqbuf, 1, newmsg_size);\r\n_sptlrpc_enlarge_msg_inplace(req->rq_reqmsg, segment, newsize);\r\nreq->rq_reqlen = newmsg_size;\r\nreturn 0;\r\n}\r\nstatic\r\nint gss_enlarge_reqbuf_priv(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req,\r\nint segment, int newsize)\r\n{\r\nstruct lustre_msg *newclrbuf;\r\nint newmsg_size, newclrbuf_size, newcipbuf_size;\r\n__u32 buflens[3];\r\nLASSERT(req->rq_pool ||\r\n(req->rq_reqbuf == NULL && req->rq_reqbuf_len == 0));\r\nLASSERT(req->rq_reqbuf == NULL ||\r\n(req->rq_pool && req->rq_reqbuf->lm_bufcount == 3));\r\nLASSERT(req->rq_clrbuf);\r\nLASSERT(req->rq_clrbuf_len > req->rq_reqlen);\r\nLASSERT(lustre_msg_buf(req->rq_clrbuf, 0, 0) == req->rq_reqmsg);\r\nnewmsg_size = get_enlarged_msgsize(req->rq_reqmsg, segment, newsize);\r\nnewclrbuf_size = get_enlarged_msgsize(req->rq_clrbuf, 0, newmsg_size);\r\nnewclrbuf_size += GSS_MAX_CIPHER_BLOCK;\r\nbuflens[0] = PTLRPC_GSS_HEADER_SIZE;\r\nbuflens[1] = gss_cli_payload(req->rq_cli_ctx, buflens[0], 0);\r\nbuflens[2] = gss_cli_payload(req->rq_cli_ctx, newclrbuf_size, 1);\r\nnewcipbuf_size = lustre_msg_size_v2(3, buflens);\r\nif (unlikely(req->rq_pool) &&\r\nreq->rq_clrbuf >= req->rq_reqbuf &&\r\n(char *) req->rq_clrbuf <\r\n(char *) req->rq_reqbuf + req->rq_reqbuf_len) {\r\nif (newclrbuf_size + newcipbuf_size <= req->rq_reqbuf_len) {\r\nvoid *src, *dst;\r\nsrc = req->rq_clrbuf;\r\ndst = (char *) req->rq_reqbuf + newcipbuf_size;\r\nmemmove(dst, src, req->rq_clrbuf_len);\r\nreq->rq_clrbuf = (struct lustre_msg *) dst;\r\nreq->rq_clrbuf_len = newclrbuf_size;\r\nreq->rq_reqmsg = lustre_msg_buf(req->rq_clrbuf, 0, 0);\r\n} else {\r\nLASSERT(req->rq_reqbuf_len >= newcipbuf_size);\r\nLASSERT(req->rq_clrbuf_len < newclrbuf_size);\r\n}\r\n}\r\nif (req->rq_clrbuf_len < newclrbuf_size) {\r\nnewclrbuf_size = size_roundup_power2(newclrbuf_size);\r\nOBD_ALLOC_LARGE(newclrbuf, newclrbuf_size);\r\nif (newclrbuf == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(newclrbuf, req->rq_clrbuf, req->rq_clrbuf_len);\r\nif (req->rq_reqbuf == NULL ||\r\nreq->rq_clrbuf < req->rq_reqbuf ||\r\n(char *) req->rq_clrbuf >=\r\n(char *) req->rq_reqbuf + req->rq_reqbuf_len) {\r\nOBD_FREE_LARGE(req->rq_clrbuf, req->rq_clrbuf_len);\r\n}\r\nreq->rq_clrbuf = newclrbuf;\r\nreq->rq_clrbuf_len = newclrbuf_size;\r\nreq->rq_reqmsg = lustre_msg_buf(req->rq_clrbuf, 0, 0);\r\n}\r\n_sptlrpc_enlarge_msg_inplace(req->rq_clrbuf, 0, newmsg_size);\r\n_sptlrpc_enlarge_msg_inplace(req->rq_reqmsg, segment, newsize);\r\nreq->rq_reqlen = newmsg_size;\r\nreturn 0;\r\n}\r\nint gss_enlarge_reqbuf(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req,\r\nint segment, int newsize)\r\n{\r\nint svc = SPTLRPC_FLVR_SVC(req->rq_flvr.sf_rpc);\r\nLASSERT(!req->rq_ctx_init && !req->rq_ctx_fini);\r\nswitch (svc) {\r\ncase SPTLRPC_SVC_NULL:\r\ncase SPTLRPC_SVC_AUTH:\r\ncase SPTLRPC_SVC_INTG:\r\nreturn gss_enlarge_reqbuf_intg(sec, req, svc, segment, newsize);\r\ncase SPTLRPC_SVC_PRIV:\r\nreturn gss_enlarge_reqbuf_priv(sec, req, segment, newsize);\r\ndefault:\r\nLASSERTF(0, "bad rpc flavor %x\n", req->rq_flvr.sf_rpc);\r\nreturn 0;\r\n}\r\n}\r\nint gss_sec_install_rctx(struct obd_import *imp,\r\nstruct ptlrpc_sec *sec,\r\nstruct ptlrpc_cli_ctx *ctx)\r\n{\r\nstruct gss_sec *gsec;\r\nstruct gss_cli_ctx *gctx;\r\nint rc;\r\ngsec = container_of(sec, struct gss_sec, gs_base);\r\ngctx = container_of(ctx, struct gss_cli_ctx, gc_base);\r\nrc = gss_install_rvs_svc_ctx(imp, gsec, gctx);\r\nreturn rc;\r\n}\r\nstatic inline\r\nint gss_svc_reqctx_is_special(struct gss_svc_reqctx *grctx)\r\n{\r\nLASSERT(grctx);\r\nreturn (grctx->src_init || grctx->src_init_continue ||\r\ngrctx->src_err_notify);\r\n}\r\nstatic\r\nvoid gss_svc_reqctx_free(struct gss_svc_reqctx *grctx)\r\n{\r\nif (grctx->src_ctx)\r\ngss_svc_upcall_put_ctx(grctx->src_ctx);\r\nsptlrpc_policy_put(grctx->src_base.sc_policy);\r\nOBD_FREE_PTR(grctx);\r\n}\r\nstatic inline\r\nvoid gss_svc_reqctx_addref(struct gss_svc_reqctx *grctx)\r\n{\r\nLASSERT(atomic_read(&grctx->src_base.sc_refcount) > 0);\r\natomic_inc(&grctx->src_base.sc_refcount);\r\n}\r\nstatic inline\r\nvoid gss_svc_reqctx_decref(struct gss_svc_reqctx *grctx)\r\n{\r\nLASSERT(atomic_read(&grctx->src_base.sc_refcount) > 0);\r\nif (atomic_dec_and_test(&grctx->src_base.sc_refcount))\r\ngss_svc_reqctx_free(grctx);\r\n}\r\nstatic\r\nint gss_svc_sign(struct ptlrpc_request *req,\r\nstruct ptlrpc_reply_state *rs,\r\nstruct gss_svc_reqctx *grctx,\r\n__u32 svc)\r\n{\r\n__u32 flags = 0;\r\nint rc;\r\nLASSERT(rs->rs_msg == lustre_msg_buf(rs->rs_repbuf, 1, 0));\r\nif (req->rq_replen != rs->rs_repbuf->lm_buflens[1])\r\nlustre_shrink_msg(rs->rs_repbuf, 1, req->rq_replen, 1);\r\nif (req->rq_pack_bulk)\r\nflags |= LUSTRE_GSS_PACK_BULK;\r\nrc = gss_sign_msg(rs->rs_repbuf, grctx->src_ctx->gsc_mechctx,\r\nLUSTRE_SP_ANY, flags, PTLRPC_GSS_PROC_DATA,\r\ngrctx->src_wirectx.gw_seq, svc, NULL);\r\nif (rc < 0)\r\nreturn rc;\r\nrs->rs_repdata_len = rc;\r\nif (likely(req->rq_packed_final)) {\r\nif (lustre_msghdr_get_flags(req->rq_reqmsg) & MSGHDR_AT_SUPPORT)\r\nreq->rq_reply_off = gss_at_reply_off_integ;\r\nelse\r\nreq->rq_reply_off = 0;\r\n} else {\r\nif (svc == SPTLRPC_SVC_NULL)\r\nrs->rs_repbuf->lm_cksum = crc32_le(!(__u32) 0,\r\nlustre_msg_buf(rs->rs_repbuf, 1, 0),\r\nlustre_msg_buflen(rs->rs_repbuf, 1));\r\nreq->rq_reply_off = 0;\r\n}\r\nreturn 0;\r\n}\r\nint gss_pack_err_notify(struct ptlrpc_request *req, __u32 major, __u32 minor)\r\n{\r\nstruct gss_svc_reqctx *grctx = gss_svc_ctx2reqctx(req->rq_svc_ctx);\r\nstruct ptlrpc_reply_state *rs;\r\nstruct gss_err_header *ghdr;\r\nint replen = sizeof(struct ptlrpc_body);\r\nint rc;\r\ngrctx->src_err_notify = 1;\r\ngrctx->src_reserve_len = 0;\r\nrc = lustre_pack_reply_v2(req, 1, &replen, NULL, 0);\r\nif (rc) {\r\nCERROR("could not pack reply, err %d\n", rc);\r\nreturn rc;\r\n}\r\nrs = req->rq_reply_state;\r\nLASSERT(rs->rs_repbuf->lm_buflens[1] >= sizeof(*ghdr));\r\nghdr = lustre_msg_buf(rs->rs_repbuf, 0, 0);\r\nghdr->gh_version = PTLRPC_GSS_VERSION;\r\nghdr->gh_flags = 0;\r\nghdr->gh_proc = PTLRPC_GSS_PROC_ERR;\r\nghdr->gh_major = major;\r\nghdr->gh_minor = minor;\r\nghdr->gh_handle.len = 0;\r\nrs->rs_repdata_len = lustre_msg_size_v2(rs->rs_repbuf->lm_bufcount,\r\nrs->rs_repbuf->lm_buflens);\r\nCDEBUG(D_SEC, "prepare gss error notify(0x%x/0x%x) to %s\n",\r\nmajor, minor, libcfs_nid2str(req->rq_peer.nid));\r\nreturn 0;\r\n}\r\nstatic\r\nint gss_svc_handle_init(struct ptlrpc_request *req,\r\nstruct gss_wire_ctx *gw)\r\n{\r\nstruct gss_svc_reqctx *grctx = gss_svc_ctx2reqctx(req->rq_svc_ctx);\r\nstruct lustre_msg *reqbuf = req->rq_reqbuf;\r\nstruct obd_uuid *uuid;\r\nstruct obd_device *target;\r\nrawobj_t uuid_obj, rvs_hdl, in_token;\r\n__u32 lustre_svc;\r\n__u32 *secdata, seclen;\r\nint swabbed, rc;\r\nCDEBUG(D_SEC, "processing gss init(%d) request from %s\n", gw->gw_proc,\r\nlibcfs_nid2str(req->rq_peer.nid));\r\nreq->rq_ctx_init = 1;\r\nif (gw->gw_flags & LUSTRE_GSS_PACK_BULK) {\r\nCERROR("unexpected bulk flag\n");\r\nreturn SECSVC_DROP;\r\n}\r\nif (gw->gw_proc == PTLRPC_GSS_PROC_INIT && gw->gw_handle.len != 0) {\r\nCERROR("proc %u: invalid handle length %u\n",\r\ngw->gw_proc, gw->gw_handle.len);\r\nreturn SECSVC_DROP;\r\n}\r\nif (reqbuf->lm_bufcount < 3 || reqbuf->lm_bufcount > 4){\r\nCERROR("Invalid bufcount %d\n", reqbuf->lm_bufcount);\r\nreturn SECSVC_DROP;\r\n}\r\nswabbed = ptlrpc_req_need_swab(req);\r\nsecdata = lustre_msg_buf(reqbuf, reqbuf->lm_bufcount - 1, 0);\r\nseclen = reqbuf->lm_buflens[reqbuf->lm_bufcount - 1];\r\nif (seclen < 4 + 4) {\r\nCERROR("sec size %d too small\n", seclen);\r\nreturn SECSVC_DROP;\r\n}\r\nlustre_svc = le32_to_cpu(*secdata++);\r\nseclen -= 4;\r\nif (rawobj_extract(&uuid_obj, &secdata, &seclen)) {\r\nCERROR("failed to extract target uuid\n");\r\nreturn SECSVC_DROP;\r\n}\r\nuuid_obj.data[uuid_obj.len - 1] = '\0';\r\nuuid = (struct obd_uuid *) uuid_obj.data;\r\ntarget = class_uuid2obd(uuid);\r\nif (!target || target->obd_stopping || !target->obd_set_up) {\r\nCERROR("target '%s' is not available for context init (%s)\n",\r\nuuid->uuid, target == NULL ? "no target" :\r\n(target->obd_stopping ? "stopping" : "not set up"));\r\nreturn SECSVC_DROP;\r\n}\r\nif (rawobj_extract(&rvs_hdl, &secdata, &seclen)) {\r\nCERROR("failed extract reverse handle\n");\r\nreturn SECSVC_DROP;\r\n}\r\nif (rawobj_extract(&in_token, &secdata, &seclen)) {\r\nCERROR("can't extract token\n");\r\nreturn SECSVC_DROP;\r\n}\r\nrc = gss_svc_upcall_handle_init(req, grctx, gw, target, lustre_svc,\r\n&rvs_hdl, &in_token);\r\nif (rc != SECSVC_OK)\r\nreturn rc;\r\nif (grctx->src_ctx->gsc_usr_mds || grctx->src_ctx->gsc_usr_oss ||\r\ngrctx->src_ctx->gsc_usr_root)\r\nCWARN("create svc ctx %p: user from %s authenticated as %s\n",\r\ngrctx->src_ctx, libcfs_nid2str(req->rq_peer.nid),\r\ngrctx->src_ctx->gsc_usr_mds ? "mds" :\r\n(grctx->src_ctx->gsc_usr_oss ? "oss" : "root"));\r\nelse\r\nCWARN("create svc ctx %p: accept user %u from %s\n",\r\ngrctx->src_ctx, grctx->src_ctx->gsc_uid,\r\nlibcfs_nid2str(req->rq_peer.nid));\r\nif (gw->gw_flags & LUSTRE_GSS_PACK_USER) {\r\nif (reqbuf->lm_bufcount < 4) {\r\nCERROR("missing user descriptor\n");\r\nreturn SECSVC_DROP;\r\n}\r\nif (sptlrpc_unpack_user_desc(reqbuf, 2, swabbed)) {\r\nCERROR("Mal-formed user descriptor\n");\r\nreturn SECSVC_DROP;\r\n}\r\nreq->rq_pack_udesc = 1;\r\nreq->rq_user_desc = lustre_msg_buf(reqbuf, 2, 0);\r\n}\r\nreq->rq_reqmsg = lustre_msg_buf(reqbuf, 1, 0);\r\nreq->rq_reqlen = lustre_msg_buflen(reqbuf, 1);\r\nreturn rc;\r\n}\r\nstatic\r\nint gss_svc_verify_request(struct ptlrpc_request *req,\r\nstruct gss_svc_reqctx *grctx,\r\nstruct gss_wire_ctx *gw,\r\n__u32 *major)\r\n{\r\nstruct gss_svc_ctx *gctx = grctx->src_ctx;\r\nstruct lustre_msg *msg = req->rq_reqbuf;\r\nint offset = 2;\r\nint swabbed;\r\n*major = GSS_S_COMPLETE;\r\nif (msg->lm_bufcount < 2) {\r\nCERROR("Too few segments (%u) in request\n", msg->lm_bufcount);\r\nreturn -EINVAL;\r\n}\r\nif (gw->gw_svc == SPTLRPC_SVC_NULL)\r\ngoto verified;\r\nif (gss_check_seq_num(&gctx->gsc_seqdata, gw->gw_seq, 0)) {\r\nCERROR("phase 0: discard replayed req: seq %u\n", gw->gw_seq);\r\n*major = GSS_S_DUPLICATE_TOKEN;\r\nreturn -EACCES;\r\n}\r\n*major = gss_verify_msg(msg, gctx->gsc_mechctx, gw->gw_svc);\r\nif (*major != GSS_S_COMPLETE) {\r\nCERROR("failed to verify request: %x\n", *major);\r\nreturn -EACCES;\r\n}\r\nif (gctx->gsc_reverse == 0 &&\r\ngss_check_seq_num(&gctx->gsc_seqdata, gw->gw_seq, 1)) {\r\nCERROR("phase 1+: discard replayed req: seq %u\n", gw->gw_seq);\r\n*major = GSS_S_DUPLICATE_TOKEN;\r\nreturn -EACCES;\r\n}\r\nverified:\r\nswabbed = ptlrpc_req_need_swab(req);\r\nif (gw->gw_flags & LUSTRE_GSS_PACK_USER) {\r\nif (msg->lm_bufcount < (offset + 1)) {\r\nCERROR("no user desc included\n");\r\nreturn -EINVAL;\r\n}\r\nif (sptlrpc_unpack_user_desc(msg, offset, swabbed)) {\r\nCERROR("Mal-formed user descriptor\n");\r\nreturn -EINVAL;\r\n}\r\nreq->rq_pack_udesc = 1;\r\nreq->rq_user_desc = lustre_msg_buf(msg, offset, 0);\r\noffset++;\r\n}\r\nif (gw->gw_flags & LUSTRE_GSS_PACK_BULK) {\r\nif (msg->lm_bufcount < (offset + 1)) {\r\nCERROR("missing bulk sec descriptor\n");\r\nreturn -EINVAL;\r\n}\r\nif (bulk_sec_desc_unpack(msg, offset, swabbed))\r\nreturn -EINVAL;\r\nreq->rq_pack_bulk = 1;\r\ngrctx->src_reqbsd = lustre_msg_buf(msg, offset, 0);\r\ngrctx->src_reqbsd_size = lustre_msg_buflen(msg, offset);\r\n}\r\nreq->rq_reqmsg = lustre_msg_buf(msg, 1, 0);\r\nreq->rq_reqlen = msg->lm_buflens[1];\r\nreturn 0;\r\n}\r\nstatic\r\nint gss_svc_unseal_request(struct ptlrpc_request *req,\r\nstruct gss_svc_reqctx *grctx,\r\nstruct gss_wire_ctx *gw,\r\n__u32 *major)\r\n{\r\nstruct gss_svc_ctx *gctx = grctx->src_ctx;\r\nstruct lustre_msg *msg = req->rq_reqbuf;\r\nint swabbed, msglen, offset = 1;\r\nif (gss_check_seq_num(&gctx->gsc_seqdata, gw->gw_seq, 0)) {\r\nCERROR("phase 0: discard replayed req: seq %u\n", gw->gw_seq);\r\n*major = GSS_S_DUPLICATE_TOKEN;\r\nreturn -EACCES;\r\n}\r\n*major = gss_unseal_msg(gctx->gsc_mechctx, msg,\r\n&msglen, req->rq_reqdata_len);\r\nif (*major != GSS_S_COMPLETE) {\r\nCERROR("failed to unwrap request: %x\n", *major);\r\nreturn -EACCES;\r\n}\r\nif (gss_check_seq_num(&gctx->gsc_seqdata, gw->gw_seq, 1)) {\r\nCERROR("phase 1+: discard replayed req: seq %u\n", gw->gw_seq);\r\n*major = GSS_S_DUPLICATE_TOKEN;\r\nreturn -EACCES;\r\n}\r\nswabbed = __lustre_unpack_msg(msg, msglen);\r\nif (swabbed < 0) {\r\nCERROR("Failed to unpack after decryption\n");\r\nreturn -EINVAL;\r\n}\r\nreq->rq_reqdata_len = msglen;\r\nif (msg->lm_bufcount < 1) {\r\nCERROR("Invalid buffer: is empty\n");\r\nreturn -EINVAL;\r\n}\r\nif (gw->gw_flags & LUSTRE_GSS_PACK_USER) {\r\nif (msg->lm_bufcount < offset + 1) {\r\nCERROR("no user descriptor included\n");\r\nreturn -EINVAL;\r\n}\r\nif (sptlrpc_unpack_user_desc(msg, offset, swabbed)) {\r\nCERROR("Mal-formed user descriptor\n");\r\nreturn -EINVAL;\r\n}\r\nreq->rq_pack_udesc = 1;\r\nreq->rq_user_desc = lustre_msg_buf(msg, offset, 0);\r\noffset++;\r\n}\r\nif (gw->gw_flags & LUSTRE_GSS_PACK_BULK) {\r\nif (msg->lm_bufcount < offset + 1) {\r\nCERROR("no bulk checksum included\n");\r\nreturn -EINVAL;\r\n}\r\nif (bulk_sec_desc_unpack(msg, offset, swabbed))\r\nreturn -EINVAL;\r\nreq->rq_pack_bulk = 1;\r\ngrctx->src_reqbsd = lustre_msg_buf(msg, offset, 0);\r\ngrctx->src_reqbsd_size = lustre_msg_buflen(msg, offset);\r\n}\r\nreq->rq_reqmsg = lustre_msg_buf(req->rq_reqbuf, 0, 0);\r\nreq->rq_reqlen = req->rq_reqbuf->lm_buflens[0];\r\nreturn 0;\r\n}\r\nstatic\r\nint gss_svc_handle_data(struct ptlrpc_request *req,\r\nstruct gss_wire_ctx *gw)\r\n{\r\nstruct gss_svc_reqctx *grctx = gss_svc_ctx2reqctx(req->rq_svc_ctx);\r\n__u32 major = 0;\r\nint rc = 0;\r\ngrctx->src_ctx = gss_svc_upcall_get_ctx(req, gw);\r\nif (!grctx->src_ctx) {\r\nmajor = GSS_S_NO_CONTEXT;\r\ngoto error;\r\n}\r\nswitch (gw->gw_svc) {\r\ncase SPTLRPC_SVC_NULL:\r\ncase SPTLRPC_SVC_AUTH:\r\ncase SPTLRPC_SVC_INTG:\r\nrc = gss_svc_verify_request(req, grctx, gw, &major);\r\nbreak;\r\ncase SPTLRPC_SVC_PRIV:\r\nrc = gss_svc_unseal_request(req, grctx, gw, &major);\r\nbreak;\r\ndefault:\r\nCERROR("unsupported gss service %d\n", gw->gw_svc);\r\nrc = -EINVAL;\r\n}\r\nif (rc == 0)\r\nreturn SECSVC_OK;\r\nCERROR("svc %u failed: major 0x%08x: req xid "LPU64" ctx %p idx "\r\nLPX64"(%u->%s)\n", gw->gw_svc, major, req->rq_xid,\r\ngrctx->src_ctx, gss_handle_to_u64(&gw->gw_handle),\r\ngrctx->src_ctx->gsc_uid, libcfs_nid2str(req->rq_peer.nid));\r\nerror:\r\nif ((major == GSS_S_NO_CONTEXT || major == GSS_S_BAD_SIG) &&\r\ngss_pack_err_notify(req, major, 0) == 0)\r\nreturn SECSVC_COMPLETE;\r\nreturn SECSVC_DROP;\r\n}\r\nstatic\r\nint gss_svc_handle_destroy(struct ptlrpc_request *req,\r\nstruct gss_wire_ctx *gw)\r\n{\r\nstruct gss_svc_reqctx *grctx = gss_svc_ctx2reqctx(req->rq_svc_ctx);\r\n__u32 major;\r\nreq->rq_ctx_fini = 1;\r\nreq->rq_no_reply = 1;\r\ngrctx->src_ctx = gss_svc_upcall_get_ctx(req, gw);\r\nif (!grctx->src_ctx) {\r\nCDEBUG(D_SEC, "invalid gss context handle for destroy.\n");\r\nreturn SECSVC_DROP;\r\n}\r\nif (gw->gw_svc != SPTLRPC_SVC_INTG) {\r\nCERROR("svc %u is not supported in destroy.\n", gw->gw_svc);\r\nreturn SECSVC_DROP;\r\n}\r\nif (gss_svc_verify_request(req, grctx, gw, &major))\r\nreturn SECSVC_DROP;\r\nCWARN("destroy svc ctx %p idx "LPX64" (%u->%s)\n",\r\ngrctx->src_ctx, gss_handle_to_u64(&gw->gw_handle),\r\ngrctx->src_ctx->gsc_uid, libcfs_nid2str(req->rq_peer.nid));\r\ngss_svc_upcall_destroy_ctx(grctx->src_ctx);\r\nif (gw->gw_flags & LUSTRE_GSS_PACK_USER) {\r\nif (req->rq_reqbuf->lm_bufcount < 4) {\r\nCERROR("missing user descriptor, ignore it\n");\r\nreturn SECSVC_OK;\r\n}\r\nif (sptlrpc_unpack_user_desc(req->rq_reqbuf, 2,\r\nptlrpc_req_need_swab(req))) {\r\nCERROR("Mal-formed user descriptor, ignore it\n");\r\nreturn SECSVC_OK;\r\n}\r\nreq->rq_pack_udesc = 1;\r\nreq->rq_user_desc = lustre_msg_buf(req->rq_reqbuf, 2, 0);\r\n}\r\nreturn SECSVC_OK;\r\n}\r\nint gss_svc_accept(struct ptlrpc_sec_policy *policy, struct ptlrpc_request *req)\r\n{\r\nstruct gss_header *ghdr;\r\nstruct gss_svc_reqctx *grctx;\r\nstruct gss_wire_ctx *gw;\r\nint swabbed, rc;\r\nLASSERT(req->rq_reqbuf);\r\nLASSERT(req->rq_svc_ctx == NULL);\r\nif (req->rq_reqbuf->lm_bufcount < 2) {\r\nCERROR("buf count only %d\n", req->rq_reqbuf->lm_bufcount);\r\nreturn SECSVC_DROP;\r\n}\r\nswabbed = ptlrpc_req_need_swab(req);\r\nghdr = gss_swab_header(req->rq_reqbuf, 0, swabbed);\r\nif (ghdr == NULL) {\r\nCERROR("can't decode gss header\n");\r\nreturn SECSVC_DROP;\r\n}\r\nif (ghdr->gh_version != PTLRPC_GSS_VERSION) {\r\nCERROR("gss version %u, expect %u\n", ghdr->gh_version,\r\nPTLRPC_GSS_VERSION);\r\nreturn SECSVC_DROP;\r\n}\r\nreq->rq_sp_from = ghdr->gh_sp;\r\nOBD_ALLOC_PTR(grctx);\r\nif (!grctx)\r\nreturn SECSVC_DROP;\r\ngrctx->src_base.sc_policy = sptlrpc_policy_get(policy);\r\natomic_set(&grctx->src_base.sc_refcount, 1);\r\nreq->rq_svc_ctx = &grctx->src_base;\r\ngw = &grctx->src_wirectx;\r\ngw->gw_flags = ghdr->gh_flags;\r\ngw->gw_proc = ghdr->gh_proc;\r\ngw->gw_seq = ghdr->gh_seq;\r\ngw->gw_svc = ghdr->gh_svc;\r\nrawobj_from_netobj(&gw->gw_handle, &ghdr->gh_handle);\r\nif (swabbed)\r\ngss_header_swabber(ghdr);\r\nswitch(ghdr->gh_proc) {\r\ncase PTLRPC_GSS_PROC_INIT:\r\ncase PTLRPC_GSS_PROC_CONTINUE_INIT:\r\nrc = gss_svc_handle_init(req, gw);\r\nbreak;\r\ncase PTLRPC_GSS_PROC_DATA:\r\nrc = gss_svc_handle_data(req, gw);\r\nbreak;\r\ncase PTLRPC_GSS_PROC_DESTROY:\r\nrc = gss_svc_handle_destroy(req, gw);\r\nbreak;\r\ndefault:\r\nCERROR("unknown proc %u\n", gw->gw_proc);\r\nrc = SECSVC_DROP;\r\nbreak;\r\n}\r\nswitch (rc) {\r\ncase SECSVC_OK:\r\nLASSERT (grctx->src_ctx);\r\nreq->rq_auth_gss = 1;\r\nreq->rq_auth_remote = grctx->src_ctx->gsc_remote;\r\nreq->rq_auth_usr_mdt = grctx->src_ctx->gsc_usr_mds;\r\nreq->rq_auth_usr_ost = grctx->src_ctx->gsc_usr_oss;\r\nreq->rq_auth_usr_root = grctx->src_ctx->gsc_usr_root;\r\nreq->rq_auth_uid = grctx->src_ctx->gsc_uid;\r\nreq->rq_auth_mapped_uid = grctx->src_ctx->gsc_mapped_uid;\r\nbreak;\r\ncase SECSVC_COMPLETE:\r\nbreak;\r\ncase SECSVC_DROP:\r\ngss_svc_reqctx_free(grctx);\r\nreq->rq_svc_ctx = NULL;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nvoid gss_svc_invalidate_ctx(struct ptlrpc_svc_ctx *svc_ctx)\r\n{\r\nstruct gss_svc_reqctx *grctx;\r\nif (svc_ctx == NULL) {\r\nreturn;\r\n}\r\ngrctx = gss_svc_ctx2reqctx(svc_ctx);\r\nCWARN("gss svc invalidate ctx %p(%u)\n",\r\ngrctx->src_ctx, grctx->src_ctx->gsc_uid);\r\ngss_svc_upcall_destroy_ctx(grctx->src_ctx);\r\n}\r\nstatic inline\r\nint gss_svc_payload(struct gss_svc_reqctx *grctx, int early,\r\nint msgsize, int privacy)\r\n{\r\nif (early == 0 && gss_svc_reqctx_is_special(grctx))\r\nreturn grctx->src_reserve_len;\r\nreturn gss_mech_payload(NULL, msgsize, privacy);\r\n}\r\nstatic int gss_svc_bulk_payload(struct gss_svc_ctx *gctx,\r\nstruct sptlrpc_flavor *flvr,\r\nint read)\r\n{\r\nint payload = sizeof(struct ptlrpc_bulk_sec_desc);\r\nif (read) {\r\nswitch (SPTLRPC_FLVR_BULK_SVC(flvr->sf_rpc)) {\r\ncase SPTLRPC_BULK_SVC_NULL:\r\nbreak;\r\ncase SPTLRPC_BULK_SVC_INTG:\r\npayload += gss_mech_payload(NULL, 0, 0);\r\nbreak;\r\ncase SPTLRPC_BULK_SVC_PRIV:\r\npayload += gss_mech_payload(NULL, 0, 1);\r\nbreak;\r\ncase SPTLRPC_BULK_SVC_AUTH:\r\ndefault:\r\nLBUG();\r\n}\r\n}\r\nreturn payload;\r\n}\r\nint gss_svc_alloc_rs(struct ptlrpc_request *req, int msglen)\r\n{\r\nstruct gss_svc_reqctx *grctx;\r\nstruct ptlrpc_reply_state *rs;\r\nint early, privacy, svc, bsd_off = 0;\r\n__u32 ibuflens[2], buflens[4];\r\nint ibufcnt = 0, bufcnt;\r\nint txtsize, wmsg_size, rs_size;\r\nLASSERT(msglen % 8 == 0);\r\nif (req->rq_pack_bulk && !req->rq_bulk_read && !req->rq_bulk_write) {\r\nCERROR("client request bulk sec on non-bulk rpc\n");\r\nreturn -EPROTO;\r\n}\r\nsvc = SPTLRPC_FLVR_SVC(req->rq_flvr.sf_rpc);\r\nearly = (req->rq_packed_final == 0);\r\ngrctx = gss_svc_ctx2reqctx(req->rq_svc_ctx);\r\nif (!early && gss_svc_reqctx_is_special(grctx))\r\nprivacy = 0;\r\nelse\r\nprivacy = (svc == SPTLRPC_SVC_PRIV);\r\nif (privacy) {\r\nibufcnt = 1;\r\nibuflens[0] = msglen;\r\nif (req->rq_pack_bulk) {\r\nLASSERT(grctx->src_reqbsd);\r\nbsd_off = ibufcnt;\r\nibuflens[ibufcnt++] = gss_svc_bulk_payload(\r\ngrctx->src_ctx,\r\n&req->rq_flvr,\r\nreq->rq_bulk_read);\r\n}\r\ntxtsize = lustre_msg_size_v2(ibufcnt, ibuflens);\r\ntxtsize += GSS_MAX_CIPHER_BLOCK;\r\nbufcnt = 2;\r\nbuflens[0] = PTLRPC_GSS_HEADER_SIZE;\r\nbuflens[1] = gss_svc_payload(grctx, early, txtsize, 1);\r\n} else {\r\nbufcnt = 2;\r\nbuflens[0] = PTLRPC_GSS_HEADER_SIZE;\r\nbuflens[1] = msglen;\r\ntxtsize = buflens[0];\r\nif (svc == SPTLRPC_SVC_INTG)\r\ntxtsize += buflens[1];\r\nif (req->rq_pack_bulk) {\r\nLASSERT(grctx->src_reqbsd);\r\nbsd_off = bufcnt;\r\nbuflens[bufcnt] = gss_svc_bulk_payload(\r\ngrctx->src_ctx,\r\n&req->rq_flvr,\r\nreq->rq_bulk_read);\r\nif (svc == SPTLRPC_SVC_INTG)\r\ntxtsize += buflens[bufcnt];\r\nbufcnt++;\r\n}\r\nif ((!early && gss_svc_reqctx_is_special(grctx)) ||\r\nsvc != SPTLRPC_SVC_NULL)\r\nbuflens[bufcnt++] = gss_svc_payload(grctx, early,\r\ntxtsize, 0);\r\n}\r\nwmsg_size = lustre_msg_size_v2(bufcnt, buflens);\r\nrs_size = sizeof(*rs) + wmsg_size;\r\nrs = req->rq_reply_state;\r\nif (rs) {\r\nLASSERT(rs->rs_size >= rs_size);\r\n} else {\r\nOBD_ALLOC_LARGE(rs, rs_size);\r\nif (rs == NULL)\r\nreturn -ENOMEM;\r\nrs->rs_size = rs_size;\r\n}\r\nrs->rs_repbuf = (struct lustre_msg *) (rs + 1);\r\nrs->rs_repbuf_len = wmsg_size;\r\nif (privacy) {\r\nlustre_init_msg_v2(rs->rs_repbuf, ibufcnt, ibuflens, NULL);\r\nrs->rs_msg = lustre_msg_buf(rs->rs_repbuf, 0, msglen);\r\n} else {\r\nlustre_init_msg_v2(rs->rs_repbuf, bufcnt, buflens, NULL);\r\nrs->rs_repbuf->lm_secflvr = req->rq_flvr.sf_rpc;\r\nrs->rs_msg = lustre_msg_buf(rs->rs_repbuf, 1, 0);\r\n}\r\nif (bsd_off) {\r\ngrctx->src_repbsd = lustre_msg_buf(rs->rs_repbuf, bsd_off, 0);\r\ngrctx->src_repbsd_size = lustre_msg_buflen(rs->rs_repbuf,\r\nbsd_off);\r\n}\r\ngss_svc_reqctx_addref(grctx);\r\nrs->rs_svc_ctx = req->rq_svc_ctx;\r\nLASSERT(rs->rs_msg);\r\nreq->rq_reply_state = rs;\r\nreturn 0;\r\n}\r\nstatic int gss_svc_seal(struct ptlrpc_request *req,\r\nstruct ptlrpc_reply_state *rs,\r\nstruct gss_svc_reqctx *grctx)\r\n{\r\nstruct gss_svc_ctx *gctx = grctx->src_ctx;\r\nrawobj_t hdrobj, msgobj, token;\r\nstruct gss_header *ghdr;\r\n__u8 *token_buf;\r\nint token_buflen;\r\n__u32 buflens[2], major;\r\nint msglen, rc;\r\nif (req->rq_replen != lustre_msg_buflen(rs->rs_repbuf, 0))\r\nmsglen = lustre_shrink_msg(rs->rs_repbuf, 0, req->rq_replen, 1);\r\nelse\r\nmsglen = lustre_msg_size_v2(rs->rs_repbuf->lm_bufcount,\r\nrs->rs_repbuf->lm_buflens);\r\nLASSERT(msglen + PTLRPC_GSS_HEADER_SIZE <= rs->rs_repbuf_len);\r\nghdr = (struct gss_header *) ((char *) rs->rs_repbuf +\r\nrs->rs_repbuf_len - PTLRPC_GSS_HEADER_SIZE);\r\nghdr->gh_version = PTLRPC_GSS_VERSION;\r\nghdr->gh_sp = LUSTRE_SP_ANY;\r\nghdr->gh_flags = 0;\r\nghdr->gh_proc = PTLRPC_GSS_PROC_DATA;\r\nghdr->gh_seq = grctx->src_wirectx.gw_seq;\r\nghdr->gh_svc = SPTLRPC_SVC_PRIV;\r\nghdr->gh_handle.len = 0;\r\nif (req->rq_pack_bulk)\r\nghdr->gh_flags |= LUSTRE_GSS_PACK_BULK;\r\ntoken_buflen = gss_mech_payload(gctx->gsc_mechctx, msglen, 1);\r\nOBD_ALLOC_LARGE(token_buf, token_buflen);\r\nif (token_buf == NULL)\r\nreturn -ENOMEM;\r\nhdrobj.len = PTLRPC_GSS_HEADER_SIZE;\r\nhdrobj.data = (__u8 *) ghdr;\r\nmsgobj.len = msglen;\r\nmsgobj.data = (__u8 *) rs->rs_repbuf;\r\ntoken.len = token_buflen;\r\ntoken.data = token_buf;\r\nmajor = lgss_wrap(gctx->gsc_mechctx, &hdrobj, &msgobj,\r\nrs->rs_repbuf_len - PTLRPC_GSS_HEADER_SIZE, &token);\r\nif (major != GSS_S_COMPLETE) {\r\nCERROR("wrap message error: %08x\n", major);\r\nGOTO(out_free, rc = -EPERM);\r\n}\r\nLASSERT(token.len <= token_buflen);\r\nif (req->rq_pack_bulk) {\r\ngrctx->src_repbsd = NULL;\r\ngrctx->src_repbsd_size = 0;\r\n}\r\nbuflens[0] = PTLRPC_GSS_HEADER_SIZE;\r\nbuflens[1] = token.len;\r\nrs->rs_repdata_len = lustre_msg_size_v2(2, buflens);\r\nLASSERT(rs->rs_repdata_len <= rs->rs_repbuf_len);\r\nlustre_init_msg_v2(rs->rs_repbuf, 2, buflens, NULL);\r\nrs->rs_repbuf->lm_secflvr = req->rq_flvr.sf_rpc;\r\nmemcpy(lustre_msg_buf(rs->rs_repbuf, 0, 0), ghdr,\r\nPTLRPC_GSS_HEADER_SIZE);\r\nmemcpy(lustre_msg_buf(rs->rs_repbuf, 1, 0), token.data, token.len);\r\nif (req->rq_packed_final &&\r\n(lustre_msghdr_get_flags(req->rq_reqmsg) & MSGHDR_AT_SUPPORT))\r\nreq->rq_reply_off = gss_at_reply_off_priv;\r\nelse\r\nreq->rq_reply_off = 0;\r\nrs->rs_msg = NULL;\r\nreq->rq_repmsg = NULL;\r\nreq->rq_replen = 0;\r\nrc = 0;\r\nout_free:\r\nOBD_FREE_LARGE(token_buf, token_buflen);\r\nreturn rc;\r\n}\r\nint gss_svc_authorize(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_reply_state *rs = req->rq_reply_state;\r\nstruct gss_svc_reqctx *grctx = gss_svc_ctx2reqctx(req->rq_svc_ctx);\r\nstruct gss_wire_ctx *gw = &grctx->src_wirectx;\r\nint early, rc;\r\nearly = (req->rq_packed_final == 0);\r\nif (!early && gss_svc_reqctx_is_special(grctx)) {\r\nLASSERT(rs->rs_repdata_len != 0);\r\nreq->rq_reply_off = gss_at_reply_off_integ;\r\nreturn 0;\r\n}\r\nif (!early &&\r\ngw->gw_proc != PTLRPC_GSS_PROC_DATA &&\r\ngw->gw_proc != PTLRPC_GSS_PROC_DESTROY) {\r\nCERROR("proc %d not support\n", gw->gw_proc);\r\nreturn -EINVAL;\r\n}\r\nLASSERT(grctx->src_ctx);\r\nswitch (gw->gw_svc) {\r\ncase SPTLRPC_SVC_NULL:\r\ncase SPTLRPC_SVC_AUTH:\r\ncase SPTLRPC_SVC_INTG:\r\nrc = gss_svc_sign(req, rs, grctx, gw->gw_svc);\r\nbreak;\r\ncase SPTLRPC_SVC_PRIV:\r\nrc = gss_svc_seal(req, rs, grctx);\r\nbreak;\r\ndefault:\r\nCERROR("Unknown service %d\n", gw->gw_svc);\r\nGOTO(out, rc = -EINVAL);\r\n}\r\nrc = 0;\r\nout:\r\nreturn rc;\r\n}\r\nvoid gss_svc_free_rs(struct ptlrpc_reply_state *rs)\r\n{\r\nstruct gss_svc_reqctx *grctx;\r\nLASSERT(rs->rs_svc_ctx);\r\ngrctx = container_of(rs->rs_svc_ctx, struct gss_svc_reqctx, src_base);\r\ngss_svc_reqctx_decref(grctx);\r\nrs->rs_svc_ctx = NULL;\r\nif (!rs->rs_prealloc)\r\nOBD_FREE_LARGE(rs, rs->rs_size);\r\n}\r\nvoid gss_svc_free_ctx(struct ptlrpc_svc_ctx *ctx)\r\n{\r\nLASSERT(atomic_read(&ctx->sc_refcount) == 0);\r\ngss_svc_reqctx_free(gss_svc_ctx2reqctx(ctx));\r\n}\r\nint gss_copy_rvc_cli_ctx(struct ptlrpc_cli_ctx *cli_ctx,\r\nstruct ptlrpc_svc_ctx *svc_ctx)\r\n{\r\nstruct gss_cli_ctx *cli_gctx = ctx2gctx(cli_ctx);\r\nstruct gss_svc_ctx *svc_gctx = gss_svc_ctx2gssctx(svc_ctx);\r\nstruct gss_ctx *mechctx = NULL;\r\nLASSERT(cli_gctx);\r\nLASSERT(svc_gctx && svc_gctx->gsc_mechctx);\r\ncli_gctx->gc_proc = PTLRPC_GSS_PROC_DATA;\r\ncli_gctx->gc_win = GSS_SEQ_WIN;\r\natomic_set(&cli_gctx->gc_seq, svc_gctx->gsc_rvs_seq);\r\nif (gss_svc_upcall_dup_handle(&cli_gctx->gc_svc_handle, svc_gctx)) {\r\nCERROR("failed to dup svc handle\n");\r\ngoto err_out;\r\n}\r\nif (lgss_copy_reverse_context(svc_gctx->gsc_mechctx, &mechctx) !=\r\nGSS_S_COMPLETE) {\r\nCERROR("failed to copy mech context\n");\r\ngoto err_svc_handle;\r\n}\r\nif (rawobj_dup(&cli_gctx->gc_handle, &svc_gctx->gsc_rvs_hdl)) {\r\nCERROR("failed to dup reverse handle\n");\r\ngoto err_ctx;\r\n}\r\ncli_gctx->gc_mechctx = mechctx;\r\ngss_cli_ctx_uptodate(cli_gctx);\r\nreturn 0;\r\nerr_ctx:\r\nlgss_delete_sec_context(&mechctx);\r\nerr_svc_handle:\r\nrawobj_free(&cli_gctx->gc_svc_handle);\r\nerr_out:\r\nreturn -ENOMEM;\r\n}\r\nstatic void gss_init_at_reply_offset(void)\r\n{\r\n__u32 buflens[3];\r\nint clearsize;\r\nbuflens[0] = PTLRPC_GSS_HEADER_SIZE;\r\nbuflens[1] = lustre_msg_early_size();\r\nbuflens[2] = gss_cli_payload(NULL, buflens[1], 0);\r\ngss_at_reply_off_integ = lustre_msg_size_v2(3, buflens);\r\nbuflens[0] = lustre_msg_early_size();\r\nclearsize = lustre_msg_size_v2(1, buflens);\r\nbuflens[0] = PTLRPC_GSS_HEADER_SIZE;\r\nbuflens[1] = gss_cli_payload(NULL, clearsize, 0);\r\nbuflens[2] = gss_cli_payload(NULL, clearsize, 1);\r\ngss_at_reply_off_priv = lustre_msg_size_v2(3, buflens);\r\n}\r\nint __init sptlrpc_gss_init(void)\r\n{\r\nint rc;\r\nrc = gss_init_lproc();\r\nif (rc)\r\nreturn rc;\r\nrc = gss_init_cli_upcall();\r\nif (rc)\r\ngoto out_lproc;\r\nrc = gss_init_svc_upcall();\r\nif (rc)\r\ngoto out_cli_upcall;\r\nrc = init_kerberos_module();\r\nif (rc)\r\ngoto out_svc_upcall;\r\nrc = gss_init_keyring();\r\nif (rc)\r\ngoto out_kerberos;\r\n#ifdef HAVE_GSS_PIPEFS\r\nrc = gss_init_pipefs();\r\nif (rc)\r\ngoto out_keyring;\r\n#endif\r\ngss_init_at_reply_offset();\r\nreturn 0;\r\n#ifdef HAVE_GSS_PIPEFS\r\nout_keyring:\r\ngss_exit_keyring();\r\n#endif\r\nout_kerberos:\r\ncleanup_kerberos_module();\r\nout_svc_upcall:\r\ngss_exit_svc_upcall();\r\nout_cli_upcall:\r\ngss_exit_cli_upcall();\r\nout_lproc:\r\ngss_exit_lproc();\r\nreturn rc;\r\n}\r\nstatic void __exit sptlrpc_gss_exit(void)\r\n{\r\ngss_exit_keyring();\r\n#ifdef HAVE_GSS_PIPEFS\r\ngss_exit_pipefs();\r\n#endif\r\ncleanup_kerberos_module();\r\ngss_exit_svc_upcall();\r\ngss_exit_cli_upcall();\r\ngss_exit_lproc();\r\n}
