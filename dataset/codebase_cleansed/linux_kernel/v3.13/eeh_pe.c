static struct eeh_pe *eeh_pe_alloc(struct pci_controller *phb, int type)\r\n{\r\nstruct eeh_pe *pe;\r\npe = kzalloc(sizeof(struct eeh_pe), GFP_KERNEL);\r\nif (!pe) return NULL;\r\npe->type = type;\r\npe->phb = phb;\r\nINIT_LIST_HEAD(&pe->child_list);\r\nINIT_LIST_HEAD(&pe->child);\r\nINIT_LIST_HEAD(&pe->edevs);\r\nreturn pe;\r\n}\r\nint eeh_phb_pe_create(struct pci_controller *phb)\r\n{\r\nstruct eeh_pe *pe;\r\npe = eeh_pe_alloc(phb, EEH_PE_PHB);\r\nif (!pe) {\r\npr_err("%s: out of memory!\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nlist_add_tail(&pe->child, &eeh_phb_pe);\r\npr_debug("EEH: Add PE for PHB#%d\n", phb->global_number);\r\nreturn 0;\r\n}\r\nstruct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\r\n{\r\nstruct eeh_pe *pe;\r\nlist_for_each_entry(pe, &eeh_phb_pe, child) {\r\nif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\r\nreturn pe;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct eeh_pe *eeh_pe_next(struct eeh_pe *pe,\r\nstruct eeh_pe *root)\r\n{\r\nstruct list_head *next = pe->child_list.next;\r\nif (next == &pe->child_list) {\r\nwhile (1) {\r\nif (pe == root)\r\nreturn NULL;\r\nnext = pe->child.next;\r\nif (next != &pe->parent->child_list)\r\nbreak;\r\npe = pe->parent;\r\n}\r\n}\r\nreturn list_entry(next, struct eeh_pe, child);\r\n}\r\nvoid *eeh_pe_traverse(struct eeh_pe *root,\r\neeh_traverse_func fn, void *flag)\r\n{\r\nstruct eeh_pe *pe;\r\nvoid *ret;\r\nfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\r\nret = fn(pe, flag);\r\nif (ret) return ret;\r\n}\r\nreturn NULL;\r\n}\r\nvoid *eeh_pe_dev_traverse(struct eeh_pe *root,\r\neeh_traverse_func fn, void *flag)\r\n{\r\nstruct eeh_pe *pe;\r\nstruct eeh_dev *edev, *tmp;\r\nvoid *ret;\r\nif (!root) {\r\npr_warning("%s: Invalid PE %p\n", __func__, root);\r\nreturn NULL;\r\n}\r\nfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\r\neeh_pe_for_each_dev(pe, edev, tmp) {\r\nret = fn(edev, flag);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *__eeh_pe_get(void *data, void *flag)\r\n{\r\nstruct eeh_pe *pe = (struct eeh_pe *)data;\r\nstruct eeh_dev *edev = (struct eeh_dev *)flag;\r\nif (pe->type & EEH_PE_PHB)\r\nreturn NULL;\r\nif (edev->pe_config_addr &&\r\n(edev->pe_config_addr == pe->addr))\r\nreturn pe;\r\nif (edev->config_addr &&\r\n(edev->config_addr == pe->config_addr))\r\nreturn pe;\r\nreturn NULL;\r\n}\r\nstruct eeh_pe *eeh_pe_get(struct eeh_dev *edev)\r\n{\r\nstruct eeh_pe *root = eeh_phb_pe_get(edev->phb);\r\nstruct eeh_pe *pe;\r\npe = eeh_pe_traverse(root, __eeh_pe_get, edev);\r\nreturn pe;\r\n}\r\nstatic struct eeh_pe *eeh_pe_get_parent(struct eeh_dev *edev)\r\n{\r\nstruct device_node *dn;\r\nstruct eeh_dev *parent;\r\ndn = edev->dn->parent;\r\nwhile (dn) {\r\nif (!PCI_DN(dn)) return NULL;\r\nparent = of_node_to_eeh_dev(dn);\r\nif (!parent) return NULL;\r\nif (parent->pe)\r\nreturn parent->pe;\r\ndn = dn->parent;\r\n}\r\nreturn NULL;\r\n}\r\nint eeh_add_to_parent_pe(struct eeh_dev *edev)\r\n{\r\nstruct eeh_pe *pe, *parent;\r\npe = eeh_pe_get(edev);\r\nif (pe && !(pe->type & EEH_PE_INVALID)) {\r\nif (!edev->pe_config_addr) {\r\npr_err("%s: PE with addr 0x%x already exists\n",\r\n__func__, edev->config_addr);\r\nreturn -EEXIST;\r\n}\r\npe->type = EEH_PE_BUS;\r\nedev->pe = pe;\r\nlist_add_tail(&edev->list, &pe->edevs);\r\npr_debug("EEH: Add %s to Bus PE#%x\n",\r\nedev->dn->full_name, pe->addr);\r\nreturn 0;\r\n} else if (pe && (pe->type & EEH_PE_INVALID)) {\r\nlist_add_tail(&edev->list, &pe->edevs);\r\nedev->pe = pe;\r\nparent = pe;\r\nwhile (parent) {\r\nif (!(parent->type & EEH_PE_INVALID))\r\nbreak;\r\nparent->type &= ~(EEH_PE_INVALID | EEH_PE_KEEP);\r\nparent = parent->parent;\r\n}\r\npr_debug("EEH: Add %s to Device PE#%x, Parent PE#%x\n",\r\nedev->dn->full_name, pe->addr, pe->parent->addr);\r\nreturn 0;\r\n}\r\npe = eeh_pe_alloc(edev->phb, EEH_PE_DEVICE);\r\nif (!pe) {\r\npr_err("%s: out of memory!\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\npe->addr = edev->pe_config_addr;\r\npe->config_addr = edev->config_addr;\r\nif (eeh_probe_mode_dev())\r\npe->bus = eeh_dev_to_pci_dev(edev)->bus;\r\nparent = eeh_pe_get_parent(edev);\r\nif (!parent) {\r\nparent = eeh_phb_pe_get(edev->phb);\r\nif (!parent) {\r\npr_err("%s: No PHB PE is found (PHB Domain=%d)\n",\r\n__func__, edev->phb->global_number);\r\nedev->pe = NULL;\r\nkfree(pe);\r\nreturn -EEXIST;\r\n}\r\n}\r\npe->parent = parent;\r\nlist_add_tail(&pe->child, &parent->child_list);\r\nlist_add_tail(&edev->list, &pe->edevs);\r\nedev->pe = pe;\r\npr_debug("EEH: Add %s to Device PE#%x, Parent PE#%x\n",\r\nedev->dn->full_name, pe->addr, pe->parent->addr);\r\nreturn 0;\r\n}\r\nint eeh_rmv_from_parent_pe(struct eeh_dev *edev)\r\n{\r\nstruct eeh_pe *pe, *parent, *child;\r\nint cnt;\r\nif (!edev->pe) {\r\npr_debug("%s: No PE found for EEH device %s\n",\r\n__func__, edev->dn->full_name);\r\nreturn -EEXIST;\r\n}\r\npe = edev->pe;\r\nedev->pe = NULL;\r\nlist_del(&edev->list);\r\nwhile (1) {\r\nparent = pe->parent;\r\nif (pe->type & EEH_PE_PHB)\r\nbreak;\r\nif (!(pe->state & EEH_PE_KEEP)) {\r\nif (list_empty(&pe->edevs) &&\r\nlist_empty(&pe->child_list)) {\r\nlist_del(&pe->child);\r\nkfree(pe);\r\n} else {\r\nbreak;\r\n}\r\n} else {\r\nif (list_empty(&pe->edevs)) {\r\ncnt = 0;\r\nlist_for_each_entry(child, &pe->child_list, child) {\r\nif (!(child->type & EEH_PE_INVALID)) {\r\ncnt++;\r\nbreak;\r\n}\r\n}\r\nif (!cnt)\r\npe->type |= EEH_PE_INVALID;\r\nelse\r\nbreak;\r\n}\r\n}\r\npe = parent;\r\n}\r\nreturn 0;\r\n}\r\nvoid eeh_pe_update_time_stamp(struct eeh_pe *pe)\r\n{\r\nstruct timeval tstamp;\r\nif (!pe) return;\r\nif (pe->freeze_count <= 0) {\r\npe->freeze_count = 0;\r\ndo_gettimeofday(&pe->tstamp);\r\n} else {\r\ndo_gettimeofday(&tstamp);\r\nif (tstamp.tv_sec - pe->tstamp.tv_sec > 3600) {\r\npe->tstamp = tstamp;\r\npe->freeze_count = 0;\r\n}\r\n}\r\n}\r\nstatic void *__eeh_pe_state_mark(void *data, void *flag)\r\n{\r\nstruct eeh_pe *pe = (struct eeh_pe *)data;\r\nint state = *((int *)flag);\r\nstruct eeh_dev *edev, *tmp;\r\nstruct pci_dev *pdev;\r\npe->state |= state;\r\neeh_pe_for_each_dev(pe, edev, tmp) {\r\npdev = eeh_dev_to_pci_dev(edev);\r\nif (pdev)\r\npdev->error_state = pci_channel_io_frozen;\r\n}\r\nreturn NULL;\r\n}\r\nvoid eeh_pe_state_mark(struct eeh_pe *pe, int state)\r\n{\r\neeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\r\n}\r\nstatic void *__eeh_pe_state_clear(void *data, void *flag)\r\n{\r\nstruct eeh_pe *pe = (struct eeh_pe *)data;\r\nint state = *((int *)flag);\r\npe->state &= ~state;\r\npe->check_count = 0;\r\nreturn NULL;\r\n}\r\nvoid eeh_pe_state_clear(struct eeh_pe *pe, int state)\r\n{\r\neeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\r\n}\r\nstatic void eeh_bridge_check_link(struct eeh_dev *edev,\r\nstruct device_node *dn)\r\n{\r\nint cap;\r\nuint32_t val;\r\nint timeout = 0;\r\nif (!(edev->mode & (EEH_DEV_ROOT_PORT | EEH_DEV_DS_PORT)))\r\nreturn;\r\npr_debug("%s: Check PCIe link for %04x:%02x:%02x.%01x ...\n",\r\n__func__, edev->phb->global_number,\r\nedev->config_addr >> 8,\r\nPCI_SLOT(edev->config_addr & 0xFF),\r\nPCI_FUNC(edev->config_addr & 0xFF));\r\ncap = edev->pcie_cap;\r\neeh_ops->read_config(dn, cap + PCI_EXP_SLTSTA, 2, &val);\r\nif (!(val & PCI_EXP_SLTSTA_PDS)) {\r\npr_debug(" No card in the slot (0x%04x) !\n", val);\r\nreturn;\r\n}\r\neeh_ops->read_config(dn, cap + PCI_EXP_SLTCAP, 2, &val);\r\nif (val & PCI_EXP_SLTCAP_PCP) {\r\neeh_ops->read_config(dn, cap + PCI_EXP_SLTCTL, 2, &val);\r\nif (val & PCI_EXP_SLTCTL_PCC) {\r\npr_debug(" In power-off state, power it on ...\n");\r\nval &= ~(PCI_EXP_SLTCTL_PCC | PCI_EXP_SLTCTL_PIC);\r\nval |= (0x0100 & PCI_EXP_SLTCTL_PIC);\r\neeh_ops->write_config(dn, cap + PCI_EXP_SLTCTL, 2, val);\r\nmsleep(2 * 1000);\r\n}\r\n}\r\neeh_ops->read_config(dn, cap + PCI_EXP_LNKCTL, 2, &val);\r\nval &= ~PCI_EXP_LNKCTL_LD;\r\neeh_ops->write_config(dn, cap + PCI_EXP_LNKCTL, 2, val);\r\neeh_ops->read_config(dn, cap + PCI_EXP_LNKCAP, 4, &val);\r\nif (!(val & PCI_EXP_LNKCAP_DLLLARC)) {\r\npr_debug(" No link reporting capability (0x%08x) \n", val);\r\nmsleep(1000);\r\nreturn;\r\n}\r\ntimeout = 0;\r\nwhile (timeout < 5000) {\r\nmsleep(20);\r\ntimeout += 20;\r\neeh_ops->read_config(dn, cap + PCI_EXP_LNKSTA, 2, &val);\r\nif (val & PCI_EXP_LNKSTA_DLLLA)\r\nbreak;\r\n}\r\nif (val & PCI_EXP_LNKSTA_DLLLA)\r\npr_debug(" Link up (%s)\n",\r\n(val & PCI_EXP_LNKSTA_CLS_2_5GB) ? "2.5GB" : "5GB");\r\nelse\r\npr_debug(" Link not ready (0x%04x)\n", val);\r\n}\r\nstatic void eeh_restore_bridge_bars(struct eeh_dev *edev,\r\nstruct device_node *dn)\r\n{\r\nint i;\r\nfor (i = 4; i < 13; i++)\r\neeh_ops->write_config(dn, i*4, 4, edev->config_space[i]);\r\neeh_ops->write_config(dn, 14*4, 4, edev->config_space[14]);\r\neeh_ops->write_config(dn, PCI_CACHE_LINE_SIZE, 1,\r\nSAVED_BYTE(PCI_CACHE_LINE_SIZE));\r\neeh_ops->write_config(dn, PCI_LATENCY_TIMER, 1,\r\nSAVED_BYTE(PCI_LATENCY_TIMER));\r\neeh_ops->write_config(dn, 15*4, 4, edev->config_space[15]);\r\neeh_ops->write_config(dn, PCI_COMMAND, 4, edev->config_space[1]);\r\neeh_bridge_check_link(edev, dn);\r\n}\r\nstatic void eeh_restore_device_bars(struct eeh_dev *edev,\r\nstruct device_node *dn)\r\n{\r\nint i;\r\nu32 cmd;\r\nfor (i = 4; i < 10; i++)\r\neeh_ops->write_config(dn, i*4, 4, edev->config_space[i]);\r\neeh_ops->write_config(dn, 12*4, 4, edev->config_space[12]);\r\neeh_ops->write_config(dn, PCI_CACHE_LINE_SIZE, 1,\r\nSAVED_BYTE(PCI_CACHE_LINE_SIZE));\r\neeh_ops->write_config(dn, PCI_LATENCY_TIMER, 1,\r\nSAVED_BYTE(PCI_LATENCY_TIMER));\r\neeh_ops->write_config(dn, 15*4, 4, edev->config_space[15]);\r\neeh_ops->read_config(dn, PCI_COMMAND, 4, &cmd);\r\nif (edev->config_space[1] & PCI_COMMAND_PARITY)\r\ncmd |= PCI_COMMAND_PARITY;\r\nelse\r\ncmd &= ~PCI_COMMAND_PARITY;\r\nif (edev->config_space[1] & PCI_COMMAND_SERR)\r\ncmd |= PCI_COMMAND_SERR;\r\nelse\r\ncmd &= ~PCI_COMMAND_SERR;\r\neeh_ops->write_config(dn, PCI_COMMAND, 4, cmd);\r\n}\r\nstatic void *eeh_restore_one_device_bars(void *data, void *flag)\r\n{\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct device_node *dn = eeh_dev_to_of_node(edev);\r\nif (edev->mode & EEH_DEV_BRIDGE)\r\neeh_restore_bridge_bars(edev, dn);\r\nelse\r\neeh_restore_device_bars(edev, dn);\r\nreturn NULL;\r\n}\r\nvoid eeh_pe_restore_bars(struct eeh_pe *pe)\r\n{\r\neeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\r\n}\r\nstruct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\r\n{\r\nstruct pci_bus *bus = NULL;\r\nstruct eeh_dev *edev;\r\nstruct pci_dev *pdev;\r\nif (pe->type & EEH_PE_PHB) {\r\nbus = pe->phb->bus;\r\n} else if (pe->type & EEH_PE_BUS ||\r\npe->type & EEH_PE_DEVICE) {\r\nif (pe->bus) {\r\nbus = pe->bus;\r\ngoto out;\r\n}\r\nedev = list_first_entry(&pe->edevs, struct eeh_dev, list);\r\npdev = eeh_dev_to_pci_dev(edev);\r\nif (pdev)\r\nbus = pdev->bus;\r\n}\r\nout:\r\nreturn bus;\r\n}
