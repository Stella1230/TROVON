static char *decode_ep0stage(u8 stage)\r\n{\r\nswitch (stage) {\r\ncase MUSB_EP0_STAGE_IDLE: return "idle";\r\ncase MUSB_EP0_STAGE_SETUP: return "setup";\r\ncase MUSB_EP0_STAGE_TX: return "in";\r\ncase MUSB_EP0_STAGE_RX: return "out";\r\ncase MUSB_EP0_STAGE_ACKWAIT: return "wait";\r\ncase MUSB_EP0_STAGE_STATUSIN: return "in/status";\r\ncase MUSB_EP0_STAGE_STATUSOUT: return "out/status";\r\ndefault: return "?";\r\n}\r\n}\r\nstatic int service_tx_status_request(\r\nstruct musb *musb,\r\nconst struct usb_ctrlrequest *ctrlrequest)\r\n{\r\nvoid __iomem *mbase = musb->mregs;\r\nint handled = 1;\r\nu8 result[2], epnum = 0;\r\nconst u8 recip = ctrlrequest->bRequestType & USB_RECIP_MASK;\r\nresult[1] = 0;\r\nswitch (recip) {\r\ncase USB_RECIP_DEVICE:\r\nresult[0] = musb->is_self_powered << USB_DEVICE_SELF_POWERED;\r\nresult[0] |= musb->may_wakeup << USB_DEVICE_REMOTE_WAKEUP;\r\nif (musb->g.is_otg) {\r\nresult[0] |= musb->g.b_hnp_enable\r\n<< USB_DEVICE_B_HNP_ENABLE;\r\nresult[0] |= musb->g.a_alt_hnp_support\r\n<< USB_DEVICE_A_ALT_HNP_SUPPORT;\r\nresult[0] |= musb->g.a_hnp_support\r\n<< USB_DEVICE_A_HNP_SUPPORT;\r\n}\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nresult[0] = 0;\r\nbreak;\r\ncase USB_RECIP_ENDPOINT: {\r\nint is_in;\r\nstruct musb_ep *ep;\r\nu16 tmp;\r\nvoid __iomem *regs;\r\nepnum = (u8) ctrlrequest->wIndex;\r\nif (!epnum) {\r\nresult[0] = 0;\r\nbreak;\r\n}\r\nis_in = epnum & USB_DIR_IN;\r\nif (is_in) {\r\nepnum &= 0x0f;\r\nep = &musb->endpoints[epnum].ep_in;\r\n} else {\r\nep = &musb->endpoints[epnum].ep_out;\r\n}\r\nregs = musb->endpoints[epnum].regs;\r\nif (epnum >= MUSB_C_NUM_EPS || !ep->desc) {\r\nhandled = -EINVAL;\r\nbreak;\r\n}\r\nmusb_ep_select(mbase, epnum);\r\nif (is_in)\r\ntmp = musb_readw(regs, MUSB_TXCSR)\r\n& MUSB_TXCSR_P_SENDSTALL;\r\nelse\r\ntmp = musb_readw(regs, MUSB_RXCSR)\r\n& MUSB_RXCSR_P_SENDSTALL;\r\nmusb_ep_select(mbase, 0);\r\nresult[0] = tmp ? 1 : 0;\r\n} break;\r\ndefault:\r\nhandled = 0;\r\nbreak;\r\n}\r\nif (handled > 0) {\r\nu16 len = le16_to_cpu(ctrlrequest->wLength);\r\nif (len > 2)\r\nlen = 2;\r\nmusb_write_fifo(&musb->endpoints[0], len, result);\r\n}\r\nreturn handled;\r\n}\r\nstatic int\r\nservice_in_request(struct musb *musb, const struct usb_ctrlrequest *ctrlrequest)\r\n{\r\nint handled = 0;\r\nif ((ctrlrequest->bRequestType & USB_TYPE_MASK)\r\n== USB_TYPE_STANDARD) {\r\nswitch (ctrlrequest->bRequest) {\r\ncase USB_REQ_GET_STATUS:\r\nhandled = service_tx_status_request(musb,\r\nctrlrequest);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn handled;\r\n}\r\nstatic void musb_g_ep0_giveback(struct musb *musb, struct usb_request *req)\r\n{\r\nmusb_g_giveback(&musb->endpoints[0].ep_in, req, 0);\r\n}\r\nstatic inline void musb_try_b_hnp_enable(struct musb *musb)\r\n{\r\nvoid __iomem *mbase = musb->mregs;\r\nu8 devctl;\r\ndev_dbg(musb->controller, "HNP: Setting HR\n");\r\ndevctl = musb_readb(mbase, MUSB_DEVCTL);\r\nmusb_writeb(mbase, MUSB_DEVCTL, devctl | MUSB_DEVCTL_HR);\r\n}\r\nstatic int\r\nservice_zero_data_request(struct musb *musb,\r\nstruct usb_ctrlrequest *ctrlrequest)\r\n__releases(musb->lock)\r\n__acquires(musb->lock)\r\n{\r\nint handled = -EINVAL;\r\nvoid __iomem *mbase = musb->mregs;\r\nconst u8 recip = ctrlrequest->bRequestType & USB_RECIP_MASK;\r\nif ((ctrlrequest->bRequestType & USB_TYPE_MASK)\r\n== USB_TYPE_STANDARD) {\r\nswitch (ctrlrequest->bRequest) {\r\ncase USB_REQ_SET_ADDRESS:\r\nmusb->set_address = true;\r\nmusb->address = (u8) (ctrlrequest->wValue & 0x7f);\r\nhandled = 1;\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\nswitch (recip) {\r\ncase USB_RECIP_DEVICE:\r\nif (ctrlrequest->wValue\r\n!= USB_DEVICE_REMOTE_WAKEUP)\r\nbreak;\r\nmusb->may_wakeup = 0;\r\nhandled = 1;\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:{\r\nconst u8 epnum =\r\nctrlrequest->wIndex & 0x0f;\r\nstruct musb_ep *musb_ep;\r\nstruct musb_hw_ep *ep;\r\nstruct musb_request *request;\r\nvoid __iomem *regs;\r\nint is_in;\r\nu16 csr;\r\nif (epnum == 0 || epnum >= MUSB_C_NUM_EPS ||\r\nctrlrequest->wValue != USB_ENDPOINT_HALT)\r\nbreak;\r\nep = musb->endpoints + epnum;\r\nregs = ep->regs;\r\nis_in = ctrlrequest->wIndex & USB_DIR_IN;\r\nif (is_in)\r\nmusb_ep = &ep->ep_in;\r\nelse\r\nmusb_ep = &ep->ep_out;\r\nif (!musb_ep->desc)\r\nbreak;\r\nhandled = 1;\r\nif (musb_ep->wedged)\r\nbreak;\r\nmusb_ep_select(mbase, epnum);\r\nif (is_in) {\r\ncsr = musb_readw(regs, MUSB_TXCSR);\r\ncsr |= MUSB_TXCSR_CLRDATATOG |\r\nMUSB_TXCSR_P_WZC_BITS;\r\ncsr &= ~(MUSB_TXCSR_P_SENDSTALL |\r\nMUSB_TXCSR_P_SENTSTALL |\r\nMUSB_TXCSR_TXPKTRDY);\r\nmusb_writew(regs, MUSB_TXCSR, csr);\r\n} else {\r\ncsr = musb_readw(regs, MUSB_RXCSR);\r\ncsr |= MUSB_RXCSR_CLRDATATOG |\r\nMUSB_RXCSR_P_WZC_BITS;\r\ncsr &= ~(MUSB_RXCSR_P_SENDSTALL |\r\nMUSB_RXCSR_P_SENTSTALL);\r\nmusb_writew(regs, MUSB_RXCSR, csr);\r\n}\r\nrequest = next_request(musb_ep);\r\nif (!musb_ep->busy && request) {\r\ndev_dbg(musb->controller, "restarting the request\n");\r\nmusb_ep_restart(musb, request);\r\n}\r\nmusb_ep_select(mbase, 0);\r\n} break;\r\ndefault:\r\nhandled = 0;\r\nbreak;\r\n}\r\nbreak;\r\ncase USB_REQ_SET_FEATURE:\r\nswitch (recip) {\r\ncase USB_RECIP_DEVICE:\r\nhandled = 1;\r\nswitch (ctrlrequest->wValue) {\r\ncase USB_DEVICE_REMOTE_WAKEUP:\r\nmusb->may_wakeup = 1;\r\nbreak;\r\ncase USB_DEVICE_TEST_MODE:\r\nif (musb->g.speed != USB_SPEED_HIGH)\r\ngoto stall;\r\nif (ctrlrequest->wIndex & 0xff)\r\ngoto stall;\r\nswitch (ctrlrequest->wIndex >> 8) {\r\ncase 1:\r\npr_debug("TEST_J\n");\r\nmusb->test_mode_nr =\r\nMUSB_TEST_J;\r\nbreak;\r\ncase 2:\r\npr_debug("TEST_K\n");\r\nmusb->test_mode_nr =\r\nMUSB_TEST_K;\r\nbreak;\r\ncase 3:\r\npr_debug("TEST_SE0_NAK\n");\r\nmusb->test_mode_nr =\r\nMUSB_TEST_SE0_NAK;\r\nbreak;\r\ncase 4:\r\npr_debug("TEST_PACKET\n");\r\nmusb->test_mode_nr =\r\nMUSB_TEST_PACKET;\r\nbreak;\r\ncase 0xc0:\r\npr_debug("TEST_FORCE_HS\n");\r\nmusb->test_mode_nr =\r\nMUSB_TEST_FORCE_HS;\r\nbreak;\r\ncase 0xc1:\r\npr_debug("TEST_FORCE_FS\n");\r\nmusb->test_mode_nr =\r\nMUSB_TEST_FORCE_FS;\r\nbreak;\r\ncase 0xc2:\r\npr_debug("TEST_FIFO_ACCESS\n");\r\nmusb->test_mode_nr =\r\nMUSB_TEST_FIFO_ACCESS;\r\nbreak;\r\ncase 0xc3:\r\npr_debug("TEST_FORCE_HOST\n");\r\nmusb->test_mode_nr =\r\nMUSB_TEST_FORCE_HOST;\r\nbreak;\r\ndefault:\r\ngoto stall;\r\n}\r\nif (handled > 0)\r\nmusb->test_mode = true;\r\nbreak;\r\ncase USB_DEVICE_B_HNP_ENABLE:\r\nif (!musb->g.is_otg)\r\ngoto stall;\r\nmusb->g.b_hnp_enable = 1;\r\nmusb_try_b_hnp_enable(musb);\r\nbreak;\r\ncase USB_DEVICE_A_HNP_SUPPORT:\r\nif (!musb->g.is_otg)\r\ngoto stall;\r\nmusb->g.a_hnp_support = 1;\r\nbreak;\r\ncase USB_DEVICE_A_ALT_HNP_SUPPORT:\r\nif (!musb->g.is_otg)\r\ngoto stall;\r\nmusb->g.a_alt_hnp_support = 1;\r\nbreak;\r\ncase USB_DEVICE_DEBUG_MODE:\r\nhandled = 0;\r\nbreak;\r\nstall:\r\ndefault:\r\nhandled = -EINVAL;\r\nbreak;\r\n}\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:{\r\nconst u8 epnum =\r\nctrlrequest->wIndex & 0x0f;\r\nstruct musb_ep *musb_ep;\r\nstruct musb_hw_ep *ep;\r\nvoid __iomem *regs;\r\nint is_in;\r\nu16 csr;\r\nif (epnum == 0 || epnum >= MUSB_C_NUM_EPS ||\r\nctrlrequest->wValue != USB_ENDPOINT_HALT)\r\nbreak;\r\nep = musb->endpoints + epnum;\r\nregs = ep->regs;\r\nis_in = ctrlrequest->wIndex & USB_DIR_IN;\r\nif (is_in)\r\nmusb_ep = &ep->ep_in;\r\nelse\r\nmusb_ep = &ep->ep_out;\r\nif (!musb_ep->desc)\r\nbreak;\r\nmusb_ep_select(mbase, epnum);\r\nif (is_in) {\r\ncsr = musb_readw(regs, MUSB_TXCSR);\r\nif (csr & MUSB_TXCSR_FIFONOTEMPTY)\r\ncsr |= MUSB_TXCSR_FLUSHFIFO;\r\ncsr |= MUSB_TXCSR_P_SENDSTALL\r\n| MUSB_TXCSR_CLRDATATOG\r\n| MUSB_TXCSR_P_WZC_BITS;\r\nmusb_writew(regs, MUSB_TXCSR, csr);\r\n} else {\r\ncsr = musb_readw(regs, MUSB_RXCSR);\r\ncsr |= MUSB_RXCSR_P_SENDSTALL\r\n| MUSB_RXCSR_FLUSHFIFO\r\n| MUSB_RXCSR_CLRDATATOG\r\n| MUSB_RXCSR_P_WZC_BITS;\r\nmusb_writew(regs, MUSB_RXCSR, csr);\r\n}\r\nmusb_ep_select(mbase, 0);\r\nhandled = 1;\r\n} break;\r\ndefault:\r\nhandled = 0;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nhandled = 0;\r\n}\r\n} else\r\nhandled = 0;\r\nreturn handled;\r\n}\r\nstatic void ep0_rxstate(struct musb *musb)\r\n{\r\nvoid __iomem *regs = musb->control_ep->regs;\r\nstruct musb_request *request;\r\nstruct usb_request *req;\r\nu16 count, csr;\r\nrequest = next_ep0_request(musb);\r\nreq = &request->request;\r\nif (req) {\r\nvoid *buf = req->buf + req->actual;\r\nunsigned len = req->length - req->actual;\r\ncount = musb_readb(regs, MUSB_COUNT0);\r\nif (count > len) {\r\nreq->status = -EOVERFLOW;\r\ncount = len;\r\n}\r\nif (count > 0) {\r\nmusb_read_fifo(&musb->endpoints[0], count, buf);\r\nreq->actual += count;\r\n}\r\ncsr = MUSB_CSR0_P_SVDRXPKTRDY;\r\nif (count < 64 || req->actual == req->length) {\r\nmusb->ep0_state = MUSB_EP0_STAGE_STATUSIN;\r\ncsr |= MUSB_CSR0_P_DATAEND;\r\n} else\r\nreq = NULL;\r\n} else\r\ncsr = MUSB_CSR0_P_SVDRXPKTRDY | MUSB_CSR0_P_SENDSTALL;\r\nif (req) {\r\nmusb->ackpend = csr;\r\nmusb_g_ep0_giveback(musb, req);\r\nif (!musb->ackpend)\r\nreturn;\r\nmusb->ackpend = 0;\r\n}\r\nmusb_ep_select(musb->mregs, 0);\r\nmusb_writew(regs, MUSB_CSR0, csr);\r\n}\r\nstatic void ep0_txstate(struct musb *musb)\r\n{\r\nvoid __iomem *regs = musb->control_ep->regs;\r\nstruct musb_request *req = next_ep0_request(musb);\r\nstruct usb_request *request;\r\nu16 csr = MUSB_CSR0_TXPKTRDY;\r\nu8 *fifo_src;\r\nu8 fifo_count;\r\nif (!req) {\r\ndev_dbg(musb->controller, "odd; csr0 %04x\n", musb_readw(regs, MUSB_CSR0));\r\nreturn;\r\n}\r\nrequest = &req->request;\r\nfifo_src = (u8 *) request->buf + request->actual;\r\nfifo_count = min((unsigned) MUSB_EP0_FIFOSIZE,\r\nrequest->length - request->actual);\r\nmusb_write_fifo(&musb->endpoints[0], fifo_count, fifo_src);\r\nrequest->actual += fifo_count;\r\nif (fifo_count < MUSB_MAX_END0_PACKET\r\n|| (request->actual == request->length\r\n&& !request->zero)) {\r\nmusb->ep0_state = MUSB_EP0_STAGE_STATUSOUT;\r\ncsr |= MUSB_CSR0_P_DATAEND;\r\n} else\r\nrequest = NULL;\r\nif (request) {\r\nmusb->ackpend = csr;\r\nmusb_g_ep0_giveback(musb, request);\r\nif (!musb->ackpend)\r\nreturn;\r\nmusb->ackpend = 0;\r\n}\r\nmusb_ep_select(musb->mregs, 0);\r\nmusb_writew(regs, MUSB_CSR0, csr);\r\n}\r\nstatic void\r\nmusb_read_setup(struct musb *musb, struct usb_ctrlrequest *req)\r\n{\r\nstruct musb_request *r;\r\nvoid __iomem *regs = musb->control_ep->regs;\r\nmusb_read_fifo(&musb->endpoints[0], sizeof *req, (u8 *)req);\r\ndev_dbg(musb->controller, "SETUP req%02x.%02x v%04x i%04x l%d\n",\r\nreq->bRequestType,\r\nreq->bRequest,\r\nle16_to_cpu(req->wValue),\r\nle16_to_cpu(req->wIndex),\r\nle16_to_cpu(req->wLength));\r\nr = next_ep0_request(musb);\r\nif (r)\r\nmusb_g_ep0_giveback(musb, &r->request);\r\nmusb->set_address = false;\r\nmusb->ackpend = MUSB_CSR0_P_SVDRXPKTRDY;\r\nif (req->wLength == 0) {\r\nif (req->bRequestType & USB_DIR_IN)\r\nmusb->ackpend |= MUSB_CSR0_TXPKTRDY;\r\nmusb->ep0_state = MUSB_EP0_STAGE_ACKWAIT;\r\n} else if (req->bRequestType & USB_DIR_IN) {\r\nmusb->ep0_state = MUSB_EP0_STAGE_TX;\r\nmusb_writew(regs, MUSB_CSR0, MUSB_CSR0_P_SVDRXPKTRDY);\r\nwhile ((musb_readw(regs, MUSB_CSR0)\r\n& MUSB_CSR0_RXPKTRDY) != 0)\r\ncpu_relax();\r\nmusb->ackpend = 0;\r\n} else\r\nmusb->ep0_state = MUSB_EP0_STAGE_RX;\r\n}\r\nstatic int\r\nforward_to_driver(struct musb *musb, const struct usb_ctrlrequest *ctrlrequest)\r\n__releases(musb->lock)\r\n__acquires(musb->lock)\r\n{\r\nint retval;\r\nif (!musb->gadget_driver)\r\nreturn -EOPNOTSUPP;\r\nspin_unlock(&musb->lock);\r\nretval = musb->gadget_driver->setup(&musb->g, ctrlrequest);\r\nspin_lock(&musb->lock);\r\nreturn retval;\r\n}\r\nirqreturn_t musb_g_ep0_irq(struct musb *musb)\r\n{\r\nu16 csr;\r\nu16 len;\r\nvoid __iomem *mbase = musb->mregs;\r\nvoid __iomem *regs = musb->endpoints[0].regs;\r\nirqreturn_t retval = IRQ_NONE;\r\nmusb_ep_select(mbase, 0);\r\ncsr = musb_readw(regs, MUSB_CSR0);\r\nlen = musb_readb(regs, MUSB_COUNT0);\r\ndev_dbg(musb->controller, "csr %04x, count %d, ep0stage %s\n",\r\ncsr, len, decode_ep0stage(musb->ep0_state));\r\nif (csr & MUSB_CSR0_P_DATAEND) {\r\nreturn IRQ_HANDLED;\r\n}\r\nif (csr & MUSB_CSR0_P_SENTSTALL) {\r\nmusb_writew(regs, MUSB_CSR0,\r\ncsr & ~MUSB_CSR0_P_SENTSTALL);\r\nretval = IRQ_HANDLED;\r\nmusb->ep0_state = MUSB_EP0_STAGE_IDLE;\r\ncsr = musb_readw(regs, MUSB_CSR0);\r\n}\r\nif (csr & MUSB_CSR0_P_SETUPEND) {\r\nmusb_writew(regs, MUSB_CSR0, MUSB_CSR0_P_SVDSETUPEND);\r\nretval = IRQ_HANDLED;\r\nswitch (musb->ep0_state) {\r\ncase MUSB_EP0_STAGE_TX:\r\nmusb->ep0_state = MUSB_EP0_STAGE_STATUSOUT;\r\nbreak;\r\ncase MUSB_EP0_STAGE_RX:\r\nmusb->ep0_state = MUSB_EP0_STAGE_STATUSIN;\r\nbreak;\r\ndefault:\r\nERR("SetupEnd came in a wrong ep0stage %s\n",\r\ndecode_ep0stage(musb->ep0_state));\r\n}\r\ncsr = musb_readw(regs, MUSB_CSR0);\r\n}\r\nswitch (musb->ep0_state) {\r\ncase MUSB_EP0_STAGE_TX:\r\nif ((csr & MUSB_CSR0_TXPKTRDY) == 0) {\r\nep0_txstate(musb);\r\nretval = IRQ_HANDLED;\r\n}\r\nbreak;\r\ncase MUSB_EP0_STAGE_RX:\r\nif (csr & MUSB_CSR0_RXPKTRDY) {\r\nep0_rxstate(musb);\r\nretval = IRQ_HANDLED;\r\n}\r\nbreak;\r\ncase MUSB_EP0_STAGE_STATUSIN:\r\nif (musb->set_address) {\r\nmusb->set_address = false;\r\nmusb_writeb(mbase, MUSB_FADDR, musb->address);\r\n}\r\nelse if (musb->test_mode) {\r\ndev_dbg(musb->controller, "entering TESTMODE\n");\r\nif (MUSB_TEST_PACKET == musb->test_mode_nr)\r\nmusb_load_testpacket(musb);\r\nmusb_writeb(mbase, MUSB_TESTMODE,\r\nmusb->test_mode_nr);\r\n}\r\ncase MUSB_EP0_STAGE_STATUSOUT:\r\n{\r\nstruct musb_request *req;\r\nreq = next_ep0_request(musb);\r\nif (req)\r\nmusb_g_ep0_giveback(musb, &req->request);\r\n}\r\nif (csr & MUSB_CSR0_RXPKTRDY)\r\ngoto setup;\r\nretval = IRQ_HANDLED;\r\nmusb->ep0_state = MUSB_EP0_STAGE_IDLE;\r\nbreak;\r\ncase MUSB_EP0_STAGE_IDLE:\r\nretval = IRQ_HANDLED;\r\nmusb->ep0_state = MUSB_EP0_STAGE_SETUP;\r\ncase MUSB_EP0_STAGE_SETUP:\r\nsetup:\r\nif (csr & MUSB_CSR0_RXPKTRDY) {\r\nstruct usb_ctrlrequest setup;\r\nint handled = 0;\r\nif (len != 8) {\r\nERR("SETUP packet len %d != 8 ?\n", len);\r\nbreak;\r\n}\r\nmusb_read_setup(musb, &setup);\r\nretval = IRQ_HANDLED;\r\nif (unlikely(musb->g.speed == USB_SPEED_UNKNOWN)) {\r\nu8 power;\r\nprintk(KERN_NOTICE "%s: peripheral reset "\r\n"irq lost!\n",\r\nmusb_driver_name);\r\npower = musb_readb(mbase, MUSB_POWER);\r\nmusb->g.speed = (power & MUSB_POWER_HSMODE)\r\n? USB_SPEED_HIGH : USB_SPEED_FULL;\r\n}\r\nswitch (musb->ep0_state) {\r\ncase MUSB_EP0_STAGE_ACKWAIT:\r\nhandled = service_zero_data_request(\r\nmusb, &setup);\r\nmusb->ackpend |= MUSB_CSR0_P_DATAEND;\r\nif (handled > 0)\r\nmusb->ep0_state =\r\nMUSB_EP0_STAGE_STATUSIN;\r\nbreak;\r\ncase MUSB_EP0_STAGE_TX:\r\nhandled = service_in_request(musb, &setup);\r\nif (handled > 0) {\r\nmusb->ackpend = MUSB_CSR0_TXPKTRDY\r\n| MUSB_CSR0_P_DATAEND;\r\nmusb->ep0_state =\r\nMUSB_EP0_STAGE_STATUSOUT;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndev_dbg(musb->controller, "handled %d, csr %04x, ep0stage %s\n",\r\nhandled, csr,\r\ndecode_ep0stage(musb->ep0_state));\r\nif (handled < 0)\r\ngoto stall;\r\nelse if (handled > 0)\r\ngoto finish;\r\nhandled = forward_to_driver(musb, &setup);\r\nif (handled < 0) {\r\nmusb_ep_select(mbase, 0);\r\nstall:\r\ndev_dbg(musb->controller, "stall (%d)\n", handled);\r\nmusb->ackpend |= MUSB_CSR0_P_SENDSTALL;\r\nmusb->ep0_state = MUSB_EP0_STAGE_IDLE;\r\nfinish:\r\nmusb_writew(regs, MUSB_CSR0,\r\nmusb->ackpend);\r\nmusb->ackpend = 0;\r\n}\r\n}\r\nbreak;\r\ncase MUSB_EP0_STAGE_ACKWAIT:\r\nretval = IRQ_HANDLED;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nmusb_writew(regs, MUSB_CSR0, MUSB_CSR0_P_SENDSTALL);\r\nmusb->ep0_state = MUSB_EP0_STAGE_IDLE;\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic int\r\nmusb_g_ep0_enable(struct usb_ep *ep, const struct usb_endpoint_descriptor *desc)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int musb_g_ep0_disable(struct usb_ep *e)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nmusb_g_ep0_queue(struct usb_ep *e, struct usb_request *r, gfp_t gfp_flags)\r\n{\r\nstruct musb_ep *ep;\r\nstruct musb_request *req;\r\nstruct musb *musb;\r\nint status;\r\nunsigned long lockflags;\r\nvoid __iomem *regs;\r\nif (!e || !r)\r\nreturn -EINVAL;\r\nep = to_musb_ep(e);\r\nmusb = ep->musb;\r\nregs = musb->control_ep->regs;\r\nreq = to_musb_request(r);\r\nreq->musb = musb;\r\nreq->request.actual = 0;\r\nreq->request.status = -EINPROGRESS;\r\nreq->tx = ep->is_in;\r\nspin_lock_irqsave(&musb->lock, lockflags);\r\nif (!list_empty(&ep->req_list)) {\r\nstatus = -EBUSY;\r\ngoto cleanup;\r\n}\r\nswitch (musb->ep0_state) {\r\ncase MUSB_EP0_STAGE_RX:\r\ncase MUSB_EP0_STAGE_TX:\r\ncase MUSB_EP0_STAGE_ACKWAIT:\r\nstatus = 0;\r\nbreak;\r\ndefault:\r\ndev_dbg(musb->controller, "ep0 request queued in state %d\n",\r\nmusb->ep0_state);\r\nstatus = -EINVAL;\r\ngoto cleanup;\r\n}\r\nlist_add_tail(&req->list, &ep->req_list);\r\ndev_dbg(musb->controller, "queue to %s (%s), length=%d\n",\r\nep->name, ep->is_in ? "IN/TX" : "OUT/RX",\r\nreq->request.length);\r\nmusb_ep_select(musb->mregs, 0);\r\nif (musb->ep0_state == MUSB_EP0_STAGE_TX)\r\nep0_txstate(musb);\r\nelse if (musb->ep0_state == MUSB_EP0_STAGE_ACKWAIT) {\r\nif (req->request.length)\r\nstatus = -EINVAL;\r\nelse {\r\nmusb->ep0_state = MUSB_EP0_STAGE_STATUSIN;\r\nmusb_writew(regs, MUSB_CSR0,\r\nmusb->ackpend | MUSB_CSR0_P_DATAEND);\r\nmusb->ackpend = 0;\r\nmusb_g_ep0_giveback(ep->musb, r);\r\n}\r\n} else if (musb->ackpend) {\r\nmusb_writew(regs, MUSB_CSR0, musb->ackpend);\r\nmusb->ackpend = 0;\r\n}\r\ncleanup:\r\nspin_unlock_irqrestore(&musb->lock, lockflags);\r\nreturn status;\r\n}\r\nstatic int musb_g_ep0_dequeue(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int musb_g_ep0_halt(struct usb_ep *e, int value)\r\n{\r\nstruct musb_ep *ep;\r\nstruct musb *musb;\r\nvoid __iomem *base, *regs;\r\nunsigned long flags;\r\nint status;\r\nu16 csr;\r\nif (!e || !value)\r\nreturn -EINVAL;\r\nep = to_musb_ep(e);\r\nmusb = ep->musb;\r\nbase = musb->mregs;\r\nregs = musb->control_ep->regs;\r\nstatus = 0;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nif (!list_empty(&ep->req_list)) {\r\nstatus = -EBUSY;\r\ngoto cleanup;\r\n}\r\nmusb_ep_select(base, 0);\r\ncsr = musb->ackpend;\r\nswitch (musb->ep0_state) {\r\ncase MUSB_EP0_STAGE_TX:\r\ncase MUSB_EP0_STAGE_ACKWAIT:\r\ncase MUSB_EP0_STAGE_RX:\r\ncsr = musb_readw(regs, MUSB_CSR0);\r\ncase MUSB_EP0_STAGE_STATUSIN:\r\ncase MUSB_EP0_STAGE_STATUSOUT:\r\ncsr |= MUSB_CSR0_P_SENDSTALL;\r\nmusb_writew(regs, MUSB_CSR0, csr);\r\nmusb->ep0_state = MUSB_EP0_STAGE_IDLE;\r\nmusb->ackpend = 0;\r\nbreak;\r\ndefault:\r\ndev_dbg(musb->controller, "ep0 can't halt in state %d\n", musb->ep0_state);\r\nstatus = -EINVAL;\r\n}\r\ncleanup:\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn status;\r\n}
