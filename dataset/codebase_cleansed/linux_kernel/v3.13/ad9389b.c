static inline struct ad9389b_state *get_ad9389b_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct ad9389b_state, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct ad9389b_state, hdl)->sd;\r\n}\r\nstatic int ad9389b_rd(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int ad9389b_wr(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nret = i2c_smbus_write_byte_data(client, reg, val);\r\nif (ret == 0)\r\nreturn 0;\r\n}\r\nv4l2_err(sd, "I2C Write Problem\n");\r\nreturn ret;\r\n}\r\nstatic inline void ad9389b_wr_and_or(struct v4l2_subdev *sd, u8 reg,\r\nu8 clr_mask, u8 val_mask)\r\n{\r\nad9389b_wr(sd, reg, (ad9389b_rd(sd, reg) & clr_mask) | val_mask);\r\n}\r\nstatic void ad9389b_edid_rd(struct v4l2_subdev *sd, u16 len, u8 *buf)\r\n{\r\nstruct ad9389b_state *state = get_ad9389b_state(sd);\r\nint i;\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = i2c_smbus_read_byte_data(state->edid_i2c_client, i);\r\n}\r\nstatic inline bool ad9389b_have_hotplug(struct v4l2_subdev *sd)\r\n{\r\nreturn ad9389b_rd(sd, 0x42) & MASK_AD9389B_HPD_DETECT;\r\n}\r\nstatic inline bool ad9389b_have_rx_sense(struct v4l2_subdev *sd)\r\n{\r\nreturn ad9389b_rd(sd, 0x42) & MASK_AD9389B_MSEN_DETECT;\r\n}\r\nstatic void ad9389b_csc_conversion_mode(struct v4l2_subdev *sd, u8 mode)\r\n{\r\nad9389b_wr_and_or(sd, 0x17, 0xe7, (mode & 0x3)<<3);\r\nad9389b_wr_and_or(sd, 0x18, 0x9f, (mode & 0x3)<<5);\r\n}\r\nstatic void ad9389b_csc_coeff(struct v4l2_subdev *sd,\r\nu16 A1, u16 A2, u16 A3, u16 A4,\r\nu16 B1, u16 B2, u16 B3, u16 B4,\r\nu16 C1, u16 C2, u16 C3, u16 C4)\r\n{\r\nad9389b_wr_and_or(sd, 0x18, 0xe0, A1>>8);\r\nad9389b_wr(sd, 0x19, A1);\r\nad9389b_wr_and_or(sd, 0x1A, 0xe0, A2>>8);\r\nad9389b_wr(sd, 0x1B, A2);\r\nad9389b_wr_and_or(sd, 0x1c, 0xe0, A3>>8);\r\nad9389b_wr(sd, 0x1d, A3);\r\nad9389b_wr_and_or(sd, 0x1e, 0xe0, A4>>8);\r\nad9389b_wr(sd, 0x1f, A4);\r\nad9389b_wr_and_or(sd, 0x20, 0xe0, B1>>8);\r\nad9389b_wr(sd, 0x21, B1);\r\nad9389b_wr_and_or(sd, 0x22, 0xe0, B2>>8);\r\nad9389b_wr(sd, 0x23, B2);\r\nad9389b_wr_and_or(sd, 0x24, 0xe0, B3>>8);\r\nad9389b_wr(sd, 0x25, B3);\r\nad9389b_wr_and_or(sd, 0x26, 0xe0, B4>>8);\r\nad9389b_wr(sd, 0x27, B4);\r\nad9389b_wr_and_or(sd, 0x28, 0xe0, C1>>8);\r\nad9389b_wr(sd, 0x29, C1);\r\nad9389b_wr_and_or(sd, 0x2A, 0xe0, C2>>8);\r\nad9389b_wr(sd, 0x2B, C2);\r\nad9389b_wr_and_or(sd, 0x2C, 0xe0, C3>>8);\r\nad9389b_wr(sd, 0x2D, C3);\r\nad9389b_wr_and_or(sd, 0x2E, 0xe0, C4>>8);\r\nad9389b_wr(sd, 0x2F, C4);\r\n}\r\nstatic void ad9389b_csc_rgb_full2limit(struct v4l2_subdev *sd, bool enable)\r\n{\r\nif (enable) {\r\nu8 csc_mode = 0;\r\nad9389b_csc_conversion_mode(sd, csc_mode);\r\nad9389b_csc_coeff(sd,\r\n4096-564, 0, 0, 256,\r\n0, 4096-564, 0, 256,\r\n0, 0, 4096-564, 256);\r\nad9389b_wr_and_or(sd, 0x3b, 0xfe, 0x1);\r\nad9389b_wr_and_or(sd, 0xcd, 0xf9, 0x02);\r\n} else {\r\nad9389b_wr_and_or(sd, 0x3b, 0xfe, 0x0);\r\nad9389b_wr_and_or(sd, 0xcd, 0xf9, 0x04);\r\n}\r\n}\r\nstatic void ad9389b_set_IT_content_AVI_InfoFrame(struct v4l2_subdev *sd)\r\n{\r\nstruct ad9389b_state *state = get_ad9389b_state(sd);\r\nif (state->dv_timings.bt.standards & V4L2_DV_BT_STD_CEA861) {\r\nad9389b_wr_and_or(sd, 0xcd, 0xbf, 0x00);\r\n} else {\r\nad9389b_wr_and_or(sd, 0xcd, 0xbf, 0x40);\r\n}\r\n}\r\nstatic int ad9389b_set_rgb_quantization_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)\r\n{\r\nstruct ad9389b_state *state = get_ad9389b_state(sd);\r\nswitch (ctrl->val) {\r\ncase V4L2_DV_RGB_RANGE_AUTO:\r\nif (state->dv_timings.bt.standards & V4L2_DV_BT_STD_CEA861) {\r\nad9389b_csc_rgb_full2limit(sd, true);\r\n} else {\r\nad9389b_csc_rgb_full2limit(sd, false);\r\n}\r\nbreak;\r\ncase V4L2_DV_RGB_RANGE_LIMITED:\r\nad9389b_csc_rgb_full2limit(sd, true);\r\nbreak;\r\ncase V4L2_DV_RGB_RANGE_FULL:\r\nad9389b_csc_rgb_full2limit(sd, false);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ad9389b_set_manual_pll_gear(struct v4l2_subdev *sd, u32 pixelclock)\r\n{\r\nu8 gear;\r\nif (pixelclock > 140000000)\r\ngear = 0xc0;\r\nelse if (pixelclock > 117000000)\r\ngear = 0xb0;\r\nelse if (pixelclock > 87000000)\r\ngear = 0xa0;\r\nelse if (pixelclock > 60000000)\r\ngear = 0x90;\r\nelse\r\ngear = 0x80;\r\nad9389b_wr_and_or(sd, 0x98, 0x0f, gear);\r\n}\r\nstatic int ad9389b_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nstruct ad9389b_state *state = get_ad9389b_state(sd);\r\nv4l2_dbg(1, debug, sd,\r\n"%s: ctrl id: %d, ctrl->val %d\n", __func__, ctrl->id, ctrl->val);\r\nif (state->hdmi_mode_ctrl == ctrl) {\r\nad9389b_wr_and_or(sd, 0xaf, 0xfd,\r\nctrl->val == V4L2_DV_TX_MODE_HDMI ? 0x02 : 0x00);\r\nreturn 0;\r\n}\r\nif (state->rgb_quantization_range_ctrl == ctrl)\r\nreturn ad9389b_set_rgb_quantization_mode(sd, ctrl);\r\nreturn -EINVAL;\r\n}\r\nstatic int ad9389b_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nreg->val = ad9389b_rd(sd, reg->reg & 0xff);\r\nreg->size = 1;\r\nreturn 0;\r\n}\r\nstatic int ad9389b_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)\r\n{\r\nad9389b_wr(sd, reg->reg & 0xff, reg->val & 0xff);\r\nreturn 0;\r\n}\r\nstatic int ad9389b_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct ad9389b_state *state = get_ad9389b_state(sd);\r\nstruct ad9389b_state_edid *edid = &state->edid;\r\nstatic const char * const states[] = {\r\n"in reset",\r\n"reading EDID",\r\n"idle",\r\n"initializing HDCP",\r\n"HDCP enabled",\r\n"initializing HDCP repeater",\r\n"6", "7", "8", "9", "A", "B", "C", "D", "E", "F"\r\n};\r\nstatic const char * const errors[] = {\r\n"no error",\r\n"bad receiver BKSV",\r\n"Ri mismatch",\r\n"Pj mismatch",\r\n"i2c error",\r\n"timed out",\r\n"max repeater cascade exceeded",\r\n"hash check failed",\r\n"too many devices",\r\n"9", "A", "B", "C", "D", "E", "F"\r\n};\r\nu8 manual_gear;\r\nv4l2_info(sd, "chip revision %d\n", state->chip_revision);\r\nv4l2_info(sd, "power %s\n", state->power_on ? "on" : "off");\r\nv4l2_info(sd, "%s hotplug, %s Rx Sense, %s EDID (%d block(s))\n",\r\n(ad9389b_rd(sd, 0x42) & MASK_AD9389B_HPD_DETECT) ?\r\n"detected" : "no",\r\n(ad9389b_rd(sd, 0x42) & MASK_AD9389B_MSEN_DETECT) ?\r\n"detected" : "no",\r\nedid->segments ? "found" : "no", edid->blocks);\r\nif (state->have_monitor) {\r\nv4l2_info(sd, "%s output %s\n",\r\n(ad9389b_rd(sd, 0xaf) & 0x02) ?\r\n"HDMI" : "DVI-D",\r\n(ad9389b_rd(sd, 0xa1) & 0x3c) ?\r\n"disabled" : "enabled");\r\n}\r\nv4l2_info(sd, "ad9389b: %s\n", (ad9389b_rd(sd, 0xb8) & 0x40) ?\r\n"encrypted" : "no encryption");\r\nv4l2_info(sd, "state: %s, error: %s, detect count: %u, msk/irq: %02x/%02x\n",\r\nstates[ad9389b_rd(sd, 0xc8) & 0xf],\r\nerrors[ad9389b_rd(sd, 0xc8) >> 4],\r\nstate->edid_detect_counter,\r\nad9389b_rd(sd, 0x94), ad9389b_rd(sd, 0x96));\r\nmanual_gear = ad9389b_rd(sd, 0x98) & 0x80;\r\nv4l2_info(sd, "ad9389b: RGB quantization: %s range\n",\r\nad9389b_rd(sd, 0x3b) & 0x01 ? "limited" : "full");\r\nv4l2_info(sd, "ad9389b: %s gear %d\n",\r\nmanual_gear ? "manual" : "automatic",\r\nmanual_gear ? ((ad9389b_rd(sd, 0x98) & 0x70) >> 4) :\r\n((ad9389b_rd(sd, 0x9e) & 0x0e) >> 1));\r\nif (state->have_monitor) {\r\nif (ad9389b_rd(sd, 0xaf) & 0x02) {\r\nu8 manual_cts = ad9389b_rd(sd, 0x0a) & 0x80;\r\nu32 N = (ad9389b_rd(sd, 0x01) & 0xf) << 16 |\r\nad9389b_rd(sd, 0x02) << 8 |\r\nad9389b_rd(sd, 0x03);\r\nu8 vic_detect = ad9389b_rd(sd, 0x3e) >> 2;\r\nu8 vic_sent = ad9389b_rd(sd, 0x3d) & 0x3f;\r\nu32 CTS;\r\nif (manual_cts)\r\nCTS = (ad9389b_rd(sd, 0x07) & 0xf) << 16 |\r\nad9389b_rd(sd, 0x08) << 8 |\r\nad9389b_rd(sd, 0x09);\r\nelse\r\nCTS = (ad9389b_rd(sd, 0x04) & 0xf) << 16 |\r\nad9389b_rd(sd, 0x05) << 8 |\r\nad9389b_rd(sd, 0x06);\r\nN = (ad9389b_rd(sd, 0x01) & 0xf) << 16 |\r\nad9389b_rd(sd, 0x02) << 8 |\r\nad9389b_rd(sd, 0x03);\r\nv4l2_info(sd, "ad9389b: CTS %s mode: N %d, CTS %d\n",\r\nmanual_cts ? "manual" : "automatic", N, CTS);\r\nv4l2_info(sd, "ad9389b: VIC: detected %d, sent %d\n",\r\nvic_detect, vic_sent);\r\n}\r\n}\r\nif (state->dv_timings.type == V4L2_DV_BT_656_1120)\r\nv4l2_print_dv_timings(sd->name, "timings: ",\r\n&state->dv_timings, false);\r\nelse\r\nv4l2_info(sd, "no timings set\n");\r\nreturn 0;\r\n}\r\nstatic int ad9389b_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct ad9389b_state *state = get_ad9389b_state(sd);\r\nstruct ad9389b_platform_data *pdata = &state->pdata;\r\nconst int retries = 20;\r\nint i;\r\nv4l2_dbg(1, debug, sd, "%s: power %s\n", __func__, on ? "on" : "off");\r\nstate->power_on = on;\r\nif (!on) {\r\nad9389b_wr_and_or(sd, 0x41, 0xbf, 0x40);\r\nreturn true;\r\n}\r\nfor (i = 0; i < retries; i++) {\r\nad9389b_wr_and_or(sd, 0x41, 0xbf, 0x0);\r\nif ((ad9389b_rd(sd, 0x41) & 0x40) == 0)\r\nbreak;\r\nad9389b_wr_and_or(sd, 0x41, 0xbf, 0x40);\r\nmsleep(10);\r\n}\r\nif (i == retries) {\r\nv4l2_dbg(1, debug, sd, "failed to powerup the ad9389b\n");\r\nad9389b_s_power(sd, 0);\r\nreturn false;\r\n}\r\nif (i > 1)\r\nv4l2_dbg(1, debug, sd,\r\n"needed %d retries to powerup the ad9389b\n", i);\r\nad9389b_wr_and_or(sd, 0xba, 0xef, 0x10);\r\nad9389b_wr_and_or(sd, 0x98, 0xf0, 0x07);\r\nad9389b_wr(sd, 0x9c, 0x38);\r\nad9389b_wr_and_or(sd, 0x9d, 0xfc, 0x01);\r\nif (pdata->diff_data_drive_strength > 0)\r\nad9389b_wr(sd, 0xa2, pdata->diff_data_drive_strength);\r\nelse\r\nad9389b_wr(sd, 0xa2, 0x87);\r\nif (pdata->diff_clk_drive_strength > 0)\r\nad9389b_wr(sd, 0xa3, pdata->diff_clk_drive_strength);\r\nelse\r\nad9389b_wr(sd, 0xa3, 0x87);\r\nad9389b_wr(sd, 0x0a, 0x01);\r\nad9389b_wr(sd, 0xbb, 0xff);\r\nad9389b_wr(sd, 0xc9, 0xf);\r\nreturn true;\r\n}\r\nstatic void ad9389b_set_isr(struct v4l2_subdev *sd, bool enable)\r\n{\r\nu8 irqs = MASK_AD9389B_HPD_INT | MASK_AD9389B_MSEN_INT;\r\nu8 irqs_rd;\r\nint retries = 100;\r\nif (!enable)\r\nirqs = 0;\r\nelse if (ad9389b_have_hotplug(sd))\r\nirqs |= MASK_AD9389B_EDID_RDY_INT;\r\ndo {\r\nad9389b_wr(sd, 0x94, irqs);\r\nirqs_rd = ad9389b_rd(sd, 0x94);\r\n} while (retries-- && irqs_rd != irqs);\r\nif (irqs_rd != irqs)\r\nv4l2_err(sd, "Could not set interrupts: hw failure?\n");\r\n}\r\nstatic int ad9389b_isr(struct v4l2_subdev *sd, u32 status, bool *handled)\r\n{\r\nu8 irq_status;\r\nad9389b_set_isr(sd, false);\r\nirq_status = ad9389b_rd(sd, 0x96);\r\nad9389b_wr(sd, 0x96, irq_status);\r\nif (irq_status & (MASK_AD9389B_HPD_INT | MASK_AD9389B_MSEN_INT))\r\nad9389b_check_monitor_present_status(sd);\r\nif (irq_status & MASK_AD9389B_EDID_RDY_INT)\r\nad9389b_check_edid_status(sd);\r\nad9389b_set_isr(sd, true);\r\n*handled = true;\r\nreturn 0;\r\n}\r\nstatic int ad9389b_get_edid(struct v4l2_subdev *sd, struct v4l2_subdev_edid *edid)\r\n{\r\nstruct ad9389b_state *state = get_ad9389b_state(sd);\r\nif (edid->pad != 0)\r\nreturn -EINVAL;\r\nif (edid->blocks == 0 || edid->blocks > 256)\r\nreturn -EINVAL;\r\nif (!edid->edid)\r\nreturn -EINVAL;\r\nif (!state->edid.segments) {\r\nv4l2_dbg(1, debug, sd, "EDID segment 0 not found\n");\r\nreturn -ENODATA;\r\n}\r\nif (edid->start_block >= state->edid.segments * 2)\r\nreturn -E2BIG;\r\nif (edid->blocks + edid->start_block >= state->edid.segments * 2)\r\nedid->blocks = state->edid.segments * 2 - edid->start_block;\r\nmemcpy(edid->edid, &state->edid.data[edid->start_block * 128],\r\n128 * edid->blocks);\r\nreturn 0;\r\n}\r\nstatic int ad9389b_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct ad9389b_state *state = get_ad9389b_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s: %sable\n", __func__, (enable ? "en" : "dis"));\r\nad9389b_wr_and_or(sd, 0xa1, ~0x3c, (enable ? 0 : 0x3c));\r\nif (enable) {\r\nad9389b_check_monitor_present_status(sd);\r\n} else {\r\nad9389b_s_power(sd, 0);\r\nstate->have_monitor = false;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ad9389b_s_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct ad9389b_state *state = get_ad9389b_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nif (!v4l2_valid_dv_timings(timings, &ad9389b_timings_cap, NULL, NULL))\r\nreturn -EINVAL;\r\nv4l2_find_dv_timings_cap(timings, &ad9389b_timings_cap, 0, NULL, NULL);\r\ntimings->bt.flags &= ~V4L2_DV_FL_REDUCED_FPS;\r\nstate->dv_timings = *timings;\r\nad9389b_set_rgb_quantization_mode(sd, state->rgb_quantization_range_ctrl);\r\nif (state->pdata.tmds_pll_gear == AD9389B_TMDS_PLL_GEAR_SEMI_AUTOMATIC)\r\nad9389b_set_manual_pll_gear(sd, (u32)timings->bt.pixelclock);\r\nad9389b_set_IT_content_AVI_InfoFrame(sd);\r\nreturn 0;\r\n}\r\nstatic int ad9389b_g_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct ad9389b_state *state = get_ad9389b_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nif (!timings)\r\nreturn -EINVAL;\r\n*timings = state->dv_timings;\r\nreturn 0;\r\n}\r\nstatic int ad9389b_enum_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nreturn v4l2_enum_dv_timings_cap(timings, &ad9389b_timings_cap,\r\nNULL, NULL);\r\n}\r\nstatic int ad9389b_dv_timings_cap(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings_cap *cap)\r\n{\r\n*cap = ad9389b_timings_cap;\r\nreturn 0;\r\n}\r\nstatic int ad9389b_s_audio_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nv4l2_dbg(1, debug, sd, "%s: %sable\n", __func__, (enable ? "en" : "dis"));\r\nif (enable)\r\nad9389b_wr_and_or(sd, 0x45, 0x3f, 0x80);\r\nelse\r\nad9389b_wr_and_or(sd, 0x45, 0x3f, 0x40);\r\nreturn 0;\r\n}\r\nstatic int ad9389b_s_clock_freq(struct v4l2_subdev *sd, u32 freq)\r\n{\r\nu32 N;\r\nswitch (freq) {\r\ncase 32000: N = 4096; break;\r\ncase 44100: N = 6272; break;\r\ncase 48000: N = 6144; break;\r\ncase 88200: N = 12544; break;\r\ncase 96000: N = 12288; break;\r\ncase 176400: N = 25088; break;\r\ncase 192000: N = 24576; break;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nad9389b_wr(sd, 0x01, (N >> 16) & 0xf);\r\nad9389b_wr(sd, 0x02, (N >> 8) & 0xff);\r\nad9389b_wr(sd, 0x03, N & 0xff);\r\nreturn 0;\r\n}\r\nstatic int ad9389b_s_i2s_clock_freq(struct v4l2_subdev *sd, u32 freq)\r\n{\r\nu32 i2s_sf;\r\nswitch (freq) {\r\ncase 32000: i2s_sf = 0x30; break;\r\ncase 44100: i2s_sf = 0x00; break;\r\ncase 48000: i2s_sf = 0x20; break;\r\ncase 88200: i2s_sf = 0x80; break;\r\ncase 96000: i2s_sf = 0xa0; break;\r\ncase 176400: i2s_sf = 0xc0; break;\r\ncase 192000: i2s_sf = 0xe0; break;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nad9389b_wr_and_or(sd, 0x15, 0xf, i2s_sf);\r\nreturn 0;\r\n}\r\nstatic int ad9389b_s_routing(struct v4l2_subdev *sd, u32 input, u32 output, u32 config)\r\n{\r\nad9389b_wr_and_or(sd, 0x50, 0x1f, 0x20);\r\nad9389b_wr(sd, 0x51, 0x00);\r\nad9389b_wr_and_or(sd, 0x14, 0xf0, 0x02);\r\nreturn 0;\r\n}\r\nstatic void ad9389b_dbg_dump_edid(int lvl, int debug, struct v4l2_subdev *sd,\r\nint segment, u8 *buf)\r\n{\r\nint i, j;\r\nif (debug < lvl)\r\nreturn;\r\nv4l2_dbg(lvl, debug, sd, "edid segment %d\n", segment);\r\nfor (i = 0; i < 256; i += 16) {\r\nu8 b[128];\r\nu8 *bp = b;\r\nif (i == 128)\r\nv4l2_dbg(lvl, debug, sd, "\n");\r\nfor (j = i; j < i + 16; j++) {\r\nsprintf(bp, "0x%02x, ", buf[j]);\r\nbp += 6;\r\n}\r\nbp[0] = '\0';\r\nv4l2_dbg(lvl, debug, sd, "%s\n", b);\r\n}\r\n}\r\nstatic void ad9389b_edid_handler(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct ad9389b_state *state = container_of(dwork,\r\nstruct ad9389b_state, edid_handler);\r\nstruct v4l2_subdev *sd = &state->sd;\r\nstruct ad9389b_edid_detect ed;\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nif (ad9389b_check_edid_status(sd)) {\r\nreturn;\r\n}\r\nif (ad9389b_have_hotplug(sd)) {\r\nif (state->edid.read_retries) {\r\nstate->edid.read_retries--;\r\nv4l2_dbg(1, debug, sd, "%s: edid read failed\n", __func__);\r\nstate->have_monitor = false;\r\nad9389b_s_power(sd, false);\r\nad9389b_s_power(sd, true);\r\nqueue_delayed_work(state->work_queue,\r\n&state->edid_handler, EDID_DELAY);\r\nreturn;\r\n}\r\n}\r\ned.present = false;\r\ned.segment = ad9389b_rd(sd, 0xc4);\r\nv4l2_subdev_notify(sd, AD9389B_EDID_DETECT, (void *)&ed);\r\nv4l2_dbg(1, debug, sd, "%s: no edid found\n", __func__);\r\n}\r\nstatic void ad9389b_audio_setup(struct v4l2_subdev *sd)\r\n{\r\nv4l2_dbg(1, debug, sd, "%s\n", __func__);\r\nad9389b_s_i2s_clock_freq(sd, 48000);\r\nad9389b_s_clock_freq(sd, 48000);\r\nad9389b_s_routing(sd, 0, 0, 0);\r\n}\r\nstatic void ad9389b_setup(struct v4l2_subdev *sd)\r\n{\r\nstruct ad9389b_state *state = get_ad9389b_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s\n", __func__);\r\nad9389b_wr_and_or(sd, 0x15, 0xf1, 0x0);\r\nad9389b_wr_and_or(sd, 0x16, 0x3f, 0x0);\r\nad9389b_wr_and_or(sd, 0x17, 0xf9, 0x06);\r\nad9389b_wr_and_or(sd, 0x45, 0xc7, 0x08);\r\nad9389b_wr_and_or(sd, 0x46, 0x3f, 0x80);\r\nad9389b_wr(sd, 0x3c, 0x0);\r\nad9389b_wr(sd, 0x47, 0x80);\r\nad9389b_wr_and_or(sd, 0xaf, 0xef, 0x0);\r\nad9389b_wr_and_or(sd, 0xba, 0x1f, 0x60);\r\nad9389b_audio_setup(sd);\r\nv4l2_ctrl_handler_setup(&state->hdl);\r\nad9389b_set_IT_content_AVI_InfoFrame(sd);\r\n}\r\nstatic void ad9389b_notify_monitor_detect(struct v4l2_subdev *sd)\r\n{\r\nstruct ad9389b_monitor_detect mdt;\r\nstruct ad9389b_state *state = get_ad9389b_state(sd);\r\nmdt.present = state->have_monitor;\r\nv4l2_subdev_notify(sd, AD9389B_MONITOR_DETECT, (void *)&mdt);\r\n}\r\nstatic void ad9389b_check_monitor_present_status(struct v4l2_subdev *sd)\r\n{\r\nstruct ad9389b_state *state = get_ad9389b_state(sd);\r\nu8 status = ad9389b_rd(sd, 0x42);\r\nv4l2_dbg(1, debug, sd, "%s: status: 0x%x%s%s\n",\r\n__func__,\r\nstatus,\r\nstatus & MASK_AD9389B_HPD_DETECT ? ", hotplug" : "",\r\nstatus & MASK_AD9389B_MSEN_DETECT ? ", rx-sense" : "");\r\nif ((status & MASK_AD9389B_HPD_DETECT) &&\r\n((status & MASK_AD9389B_MSEN_DETECT) || state->edid.segments)) {\r\nv4l2_dbg(1, debug, sd,\r\n"%s: hotplug and (rx-sense or edid)\n", __func__);\r\nif (!state->have_monitor) {\r\nv4l2_dbg(1, debug, sd, "%s: monitor detected\n", __func__);\r\nstate->have_monitor = true;\r\nad9389b_set_isr(sd, true);\r\nif (!ad9389b_s_power(sd, true)) {\r\nv4l2_dbg(1, debug, sd,\r\n"%s: monitor detected, powerup failed\n", __func__);\r\nreturn;\r\n}\r\nad9389b_setup(sd);\r\nad9389b_notify_monitor_detect(sd);\r\nstate->edid.read_retries = EDID_MAX_RETRIES;\r\nqueue_delayed_work(state->work_queue,\r\n&state->edid_handler, EDID_DELAY);\r\n}\r\n} else if (status & MASK_AD9389B_HPD_DETECT) {\r\nv4l2_dbg(1, debug, sd, "%s: hotplug detected\n", __func__);\r\nstate->edid.read_retries = EDID_MAX_RETRIES;\r\nqueue_delayed_work(state->work_queue,\r\n&state->edid_handler, EDID_DELAY);\r\n} else if (!(status & MASK_AD9389B_HPD_DETECT)) {\r\nv4l2_dbg(1, debug, sd, "%s: hotplug not detected\n", __func__);\r\nif (state->have_monitor) {\r\nv4l2_dbg(1, debug, sd, "%s: monitor not detected\n", __func__);\r\nstate->have_monitor = false;\r\nad9389b_notify_monitor_detect(sd);\r\n}\r\nad9389b_s_power(sd, false);\r\nmemset(&state->edid, 0, sizeof(struct ad9389b_state_edid));\r\n}\r\nv4l2_ctrl_s_ctrl(state->hotplug_ctrl, ad9389b_have_hotplug(sd) ? 0x1 : 0x0);\r\nv4l2_ctrl_s_ctrl(state->rx_sense_ctrl, ad9389b_have_rx_sense(sd) ? 0x1 : 0x0);\r\nv4l2_ctrl_s_ctrl(state->have_edid0_ctrl, state->edid.segments ? 0x1 : 0x0);\r\n}\r\nstatic bool edid_block_verify_crc(u8 *edid_block)\r\n{\r\nu8 sum = 0;\r\nint i;\r\nfor (i = 0; i < 128; i++)\r\nsum += edid_block[i];\r\nreturn sum == 0;\r\n}\r\nstatic bool edid_segment_verify_crc(struct v4l2_subdev *sd, u32 segment)\r\n{\r\nstruct ad9389b_state *state = get_ad9389b_state(sd);\r\nu32 blocks = state->edid.blocks;\r\nu8 *data = state->edid.data;\r\nif (edid_block_verify_crc(&data[segment * 256])) {\r\nif ((segment + 1) * 2 <= blocks)\r\nreturn edid_block_verify_crc(&data[segment * 256 + 128]);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool ad9389b_check_edid_status(struct v4l2_subdev *sd)\r\n{\r\nstruct ad9389b_state *state = get_ad9389b_state(sd);\r\nstruct ad9389b_edid_detect ed;\r\nint segment;\r\nu8 edidRdy = ad9389b_rd(sd, 0xc5);\r\nv4l2_dbg(1, debug, sd, "%s: edid ready (retries: %d)\n",\r\n__func__, EDID_MAX_RETRIES - state->edid.read_retries);\r\nif (!(edidRdy & MASK_AD9389B_EDID_RDY))\r\nreturn false;\r\nsegment = ad9389b_rd(sd, 0xc4);\r\nif (segment >= EDID_MAX_SEGM) {\r\nv4l2_err(sd, "edid segment number too big\n");\r\nreturn false;\r\n}\r\nv4l2_dbg(1, debug, sd, "%s: got segment %d\n", __func__, segment);\r\nad9389b_edid_rd(sd, 256, &state->edid.data[segment * 256]);\r\nad9389b_dbg_dump_edid(2, debug, sd, segment,\r\n&state->edid.data[segment * 256]);\r\nif (segment == 0) {\r\nstate->edid.blocks = state->edid.data[0x7e] + 1;\r\nv4l2_dbg(1, debug, sd, "%s: %d blocks in total\n",\r\n__func__, state->edid.blocks);\r\n}\r\nif (!edid_segment_verify_crc(sd, segment)) {\r\nv4l2_err(sd, "%s: edid crc error\n", __func__);\r\nstate->have_monitor = false;\r\nad9389b_s_power(sd, false);\r\nad9389b_s_power(sd, true);\r\nreturn false;\r\n}\r\nstate->edid.segments = segment + 1;\r\nif (((state->edid.data[0x7e] >> 1) + 1) > state->edid.segments) {\r\nv4l2_dbg(1, debug, sd, "%s: request segment %d\n",\r\n__func__, state->edid.segments);\r\nad9389b_wr(sd, 0xc9, 0xf);\r\nad9389b_wr(sd, 0xc4, state->edid.segments);\r\nstate->edid.read_retries = EDID_MAX_RETRIES;\r\nqueue_delayed_work(state->work_queue,\r\n&state->edid_handler, EDID_DELAY);\r\nreturn false;\r\n}\r\ned.present = true;\r\ned.segment = 0;\r\nv4l2_subdev_notify(sd, AD9389B_EDID_DETECT, (void *)&ed);\r\nstate->edid_detect_counter++;\r\nv4l2_ctrl_s_ctrl(state->have_edid0_ctrl, state->edid.segments ? 0x1 : 0x0);\r\nreturn ed.present;\r\n}\r\nstatic void ad9389b_init_setup(struct v4l2_subdev *sd)\r\n{\r\nstruct ad9389b_state *state = get_ad9389b_state(sd);\r\nstruct ad9389b_state_edid *edid = &state->edid;\r\nv4l2_dbg(1, debug, sd, "%s\n", __func__);\r\nad9389b_wr(sd, 0x96, 0xff);\r\nmemset(edid, 0, sizeof(struct ad9389b_state_edid));\r\nstate->have_monitor = false;\r\nad9389b_set_isr(sd, false);\r\n}\r\nstatic int ad9389b_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nconst struct v4l2_dv_timings dv1080p60 = V4L2_DV_BT_CEA_1920X1080P60;\r\nstruct ad9389b_state *state;\r\nstruct ad9389b_platform_data *pdata = client->dev.platform_data;\r\nstruct v4l2_ctrl_handler *hdl;\r\nstruct v4l2_subdev *sd;\r\nint err = -EIO;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nv4l_dbg(1, debug, client, "detecting ad9389b client on address 0x%x\n",\r\nclient->addr << 1);\r\nstate = devm_kzalloc(&client->dev, sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nif (pdata == NULL) {\r\nv4l_err(client, "No platform data!\n");\r\nreturn -ENODEV;\r\n}\r\nmemcpy(&state->pdata, pdata, sizeof(state->pdata));\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &ad9389b_ops);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nhdl = &state->hdl;\r\nv4l2_ctrl_handler_init(hdl, 5);\r\nstate->hdmi_mode_ctrl = v4l2_ctrl_new_std_menu(hdl, &ad9389b_ctrl_ops,\r\nV4L2_CID_DV_TX_MODE, V4L2_DV_TX_MODE_HDMI,\r\n0, V4L2_DV_TX_MODE_DVI_D);\r\nstate->hotplug_ctrl = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_DV_TX_HOTPLUG, 0, 1, 0, 0);\r\nstate->rx_sense_ctrl = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_DV_TX_RXSENSE, 0, 1, 0, 0);\r\nstate->have_edid0_ctrl = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_DV_TX_EDID_PRESENT, 0, 1, 0, 0);\r\nstate->rgb_quantization_range_ctrl =\r\nv4l2_ctrl_new_std_menu(hdl, &ad9389b_ctrl_ops,\r\nV4L2_CID_DV_TX_RGB_RANGE, V4L2_DV_RGB_RANGE_FULL,\r\n0, V4L2_DV_RGB_RANGE_AUTO);\r\nsd->ctrl_handler = hdl;\r\nif (hdl->error) {\r\nerr = hdl->error;\r\ngoto err_hdl;\r\n}\r\nstate->hdmi_mode_ctrl->is_private = true;\r\nstate->hotplug_ctrl->is_private = true;\r\nstate->rx_sense_ctrl->is_private = true;\r\nstate->have_edid0_ctrl->is_private = true;\r\nstate->rgb_quantization_range_ctrl->is_private = true;\r\nstate->pad.flags = MEDIA_PAD_FL_SINK;\r\nerr = media_entity_init(&sd->entity, 1, &state->pad, 0);\r\nif (err)\r\ngoto err_hdl;\r\nstate->chip_revision = ad9389b_rd(sd, 0x0);\r\nif (state->chip_revision != 2) {\r\nv4l2_err(sd, "chip_revision %d != 2\n", state->chip_revision);\r\nerr = -EIO;\r\ngoto err_entity;\r\n}\r\nv4l2_dbg(1, debug, sd, "reg 0x41 0x%x, chip version (reg 0x00) 0x%x\n",\r\nad9389b_rd(sd, 0x41), state->chip_revision);\r\nstate->edid_i2c_client = i2c_new_dummy(client->adapter, (0x7e>>1));\r\nif (state->edid_i2c_client == NULL) {\r\nv4l2_err(sd, "failed to register edid i2c client\n");\r\nerr = -ENOMEM;\r\ngoto err_entity;\r\n}\r\nstate->work_queue = create_singlethread_workqueue(sd->name);\r\nif (state->work_queue == NULL) {\r\nv4l2_err(sd, "could not create workqueue\n");\r\nerr = -ENOMEM;\r\ngoto err_unreg;\r\n}\r\nINIT_DELAYED_WORK(&state->edid_handler, ad9389b_edid_handler);\r\nstate->dv_timings = dv1080p60;\r\nad9389b_init_setup(sd);\r\nad9389b_set_isr(sd, true);\r\nv4l2_info(sd, "%s found @ 0x%x (%s)\n", client->name,\r\nclient->addr << 1, client->adapter->name);\r\nreturn 0;\r\nerr_unreg:\r\ni2c_unregister_device(state->edid_i2c_client);\r\nerr_entity:\r\nmedia_entity_cleanup(&sd->entity);\r\nerr_hdl:\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nreturn err;\r\n}\r\nstatic int ad9389b_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct ad9389b_state *state = get_ad9389b_state(sd);\r\nstate->chip_revision = -1;\r\nv4l2_dbg(1, debug, sd, "%s removed @ 0x%x (%s)\n", client->name,\r\nclient->addr << 1, client->adapter->name);\r\nad9389b_s_stream(sd, false);\r\nad9389b_s_audio_stream(sd, false);\r\nad9389b_init_setup(sd);\r\ncancel_delayed_work(&state->edid_handler);\r\ni2c_unregister_device(state->edid_i2c_client);\r\ndestroy_workqueue(state->work_queue);\r\nv4l2_device_unregister_subdev(sd);\r\nmedia_entity_cleanup(&sd->entity);\r\nv4l2_ctrl_handler_free(sd->ctrl_handler);\r\nreturn 0;\r\n}
