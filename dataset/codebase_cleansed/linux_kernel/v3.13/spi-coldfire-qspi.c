static void mcfqspi_wr_qmr(struct mcfqspi *mcfqspi, u16 val)\r\n{\r\nwritew(val, mcfqspi->iobase + MCFQSPI_QMR);\r\n}\r\nstatic void mcfqspi_wr_qdlyr(struct mcfqspi *mcfqspi, u16 val)\r\n{\r\nwritew(val, mcfqspi->iobase + MCFQSPI_QDLYR);\r\n}\r\nstatic u16 mcfqspi_rd_qdlyr(struct mcfqspi *mcfqspi)\r\n{\r\nreturn readw(mcfqspi->iobase + MCFQSPI_QDLYR);\r\n}\r\nstatic void mcfqspi_wr_qwr(struct mcfqspi *mcfqspi, u16 val)\r\n{\r\nwritew(val, mcfqspi->iobase + MCFQSPI_QWR);\r\n}\r\nstatic void mcfqspi_wr_qir(struct mcfqspi *mcfqspi, u16 val)\r\n{\r\nwritew(val, mcfqspi->iobase + MCFQSPI_QIR);\r\n}\r\nstatic void mcfqspi_wr_qar(struct mcfqspi *mcfqspi, u16 val)\r\n{\r\nwritew(val, mcfqspi->iobase + MCFQSPI_QAR);\r\n}\r\nstatic void mcfqspi_wr_qdr(struct mcfqspi *mcfqspi, u16 val)\r\n{\r\nwritew(val, mcfqspi->iobase + MCFQSPI_QDR);\r\n}\r\nstatic u16 mcfqspi_rd_qdr(struct mcfqspi *mcfqspi)\r\n{\r\nreturn readw(mcfqspi->iobase + MCFQSPI_QDR);\r\n}\r\nstatic void mcfqspi_cs_select(struct mcfqspi *mcfqspi, u8 chip_select,\r\nbool cs_high)\r\n{\r\nmcfqspi->cs_control->select(mcfqspi->cs_control, chip_select, cs_high);\r\n}\r\nstatic void mcfqspi_cs_deselect(struct mcfqspi *mcfqspi, u8 chip_select,\r\nbool cs_high)\r\n{\r\nmcfqspi->cs_control->deselect(mcfqspi->cs_control, chip_select, cs_high);\r\n}\r\nstatic int mcfqspi_cs_setup(struct mcfqspi *mcfqspi)\r\n{\r\nreturn (mcfqspi->cs_control && mcfqspi->cs_control->setup) ?\r\nmcfqspi->cs_control->setup(mcfqspi->cs_control) : 0;\r\n}\r\nstatic void mcfqspi_cs_teardown(struct mcfqspi *mcfqspi)\r\n{\r\nif (mcfqspi->cs_control && mcfqspi->cs_control->teardown)\r\nmcfqspi->cs_control->teardown(mcfqspi->cs_control);\r\n}\r\nstatic u8 mcfqspi_qmr_baud(u32 speed_hz)\r\n{\r\nreturn clamp((MCFQSPI_BUSCLK + speed_hz - 1) / speed_hz, 2u, 255u);\r\n}\r\nstatic bool mcfqspi_qdlyr_spe(struct mcfqspi *mcfqspi)\r\n{\r\nreturn mcfqspi_rd_qdlyr(mcfqspi) & MCFQSPI_QDLYR_SPE;\r\n}\r\nstatic irqreturn_t mcfqspi_irq_handler(int this_irq, void *dev_id)\r\n{\r\nstruct mcfqspi *mcfqspi = dev_id;\r\nmcfqspi_wr_qir(mcfqspi, MCFQSPI_QIR_SPIFE | MCFQSPI_QIR_SPIF);\r\nwake_up(&mcfqspi->waitq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mcfqspi_transfer_msg8(struct mcfqspi *mcfqspi, unsigned count,\r\nconst u8 *txbuf, u8 *rxbuf)\r\n{\r\nunsigned i, n, offset = 0;\r\nn = min(count, 16u);\r\nmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_CMDBUF);\r\nfor (i = 0; i < n; ++i)\r\nmcfqspi_wr_qdr(mcfqspi, MCFQSPI_QCR_BITSE);\r\nmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_TXBUF);\r\nif (txbuf)\r\nfor (i = 0; i < n; ++i)\r\nmcfqspi_wr_qdr(mcfqspi, *txbuf++);\r\nelse\r\nfor (i = 0; i < count; ++i)\r\nmcfqspi_wr_qdr(mcfqspi, 0);\r\ncount -= n;\r\nif (count) {\r\nu16 qwr = 0xf08;\r\nmcfqspi_wr_qwr(mcfqspi, 0x700);\r\nmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\r\ndo {\r\nwait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));\r\nmcfqspi_wr_qwr(mcfqspi, qwr);\r\nmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\r\nif (rxbuf) {\r\nmcfqspi_wr_qar(mcfqspi,\r\nMCFQSPI_QAR_RXBUF + offset);\r\nfor (i = 0; i < 8; ++i)\r\n*rxbuf++ = mcfqspi_rd_qdr(mcfqspi);\r\n}\r\nn = min(count, 8u);\r\nif (txbuf) {\r\nmcfqspi_wr_qar(mcfqspi,\r\nMCFQSPI_QAR_TXBUF + offset);\r\nfor (i = 0; i < n; ++i)\r\nmcfqspi_wr_qdr(mcfqspi, *txbuf++);\r\n}\r\nqwr = (offset ? 0x808 : 0) + ((n - 1) << 8);\r\noffset ^= 8;\r\ncount -= n;\r\n} while (count);\r\nwait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));\r\nmcfqspi_wr_qwr(mcfqspi, qwr);\r\nmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\r\nif (rxbuf) {\r\nmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_RXBUF + offset);\r\nfor (i = 0; i < 8; ++i)\r\n*rxbuf++ = mcfqspi_rd_qdr(mcfqspi);\r\noffset ^= 8;\r\n}\r\n} else {\r\nmcfqspi_wr_qwr(mcfqspi, (n - 1) << 8);\r\nmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\r\n}\r\nwait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));\r\nif (rxbuf) {\r\nmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_RXBUF + offset);\r\nfor (i = 0; i < n; ++i)\r\n*rxbuf++ = mcfqspi_rd_qdr(mcfqspi);\r\n}\r\n}\r\nstatic void mcfqspi_transfer_msg16(struct mcfqspi *mcfqspi, unsigned count,\r\nconst u16 *txbuf, u16 *rxbuf)\r\n{\r\nunsigned i, n, offset = 0;\r\nn = min(count, 16u);\r\nmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_CMDBUF);\r\nfor (i = 0; i < n; ++i)\r\nmcfqspi_wr_qdr(mcfqspi, MCFQSPI_QCR_BITSE);\r\nmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_TXBUF);\r\nif (txbuf)\r\nfor (i = 0; i < n; ++i)\r\nmcfqspi_wr_qdr(mcfqspi, *txbuf++);\r\nelse\r\nfor (i = 0; i < count; ++i)\r\nmcfqspi_wr_qdr(mcfqspi, 0);\r\ncount -= n;\r\nif (count) {\r\nu16 qwr = 0xf08;\r\nmcfqspi_wr_qwr(mcfqspi, 0x700);\r\nmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\r\ndo {\r\nwait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));\r\nmcfqspi_wr_qwr(mcfqspi, qwr);\r\nmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\r\nif (rxbuf) {\r\nmcfqspi_wr_qar(mcfqspi,\r\nMCFQSPI_QAR_RXBUF + offset);\r\nfor (i = 0; i < 8; ++i)\r\n*rxbuf++ = mcfqspi_rd_qdr(mcfqspi);\r\n}\r\nn = min(count, 8u);\r\nif (txbuf) {\r\nmcfqspi_wr_qar(mcfqspi,\r\nMCFQSPI_QAR_TXBUF + offset);\r\nfor (i = 0; i < n; ++i)\r\nmcfqspi_wr_qdr(mcfqspi, *txbuf++);\r\n}\r\nqwr = (offset ? 0x808 : 0x000) + ((n - 1) << 8);\r\noffset ^= 8;\r\ncount -= n;\r\n} while (count);\r\nwait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));\r\nmcfqspi_wr_qwr(mcfqspi, qwr);\r\nmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\r\nif (rxbuf) {\r\nmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_RXBUF + offset);\r\nfor (i = 0; i < 8; ++i)\r\n*rxbuf++ = mcfqspi_rd_qdr(mcfqspi);\r\noffset ^= 8;\r\n}\r\n} else {\r\nmcfqspi_wr_qwr(mcfqspi, (n - 1) << 8);\r\nmcfqspi_wr_qdlyr(mcfqspi, MCFQSPI_QDLYR_SPE);\r\n}\r\nwait_event(mcfqspi->waitq, !mcfqspi_qdlyr_spe(mcfqspi));\r\nif (rxbuf) {\r\nmcfqspi_wr_qar(mcfqspi, MCFQSPI_QAR_RXBUF + offset);\r\nfor (i = 0; i < n; ++i)\r\n*rxbuf++ = mcfqspi_rd_qdr(mcfqspi);\r\n}\r\n}\r\nstatic int mcfqspi_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct mcfqspi *mcfqspi = spi_master_get_devdata(master);\r\nstruct spi_device *spi = msg->spi;\r\nstruct spi_transfer *t;\r\nint status = 0;\r\nlist_for_each_entry(t, &msg->transfers, transfer_list) {\r\nbool cs_high = spi->mode & SPI_CS_HIGH;\r\nu16 qmr = MCFQSPI_QMR_MSTR;\r\nqmr |= t->bits_per_word << 10;\r\nif (spi->mode & SPI_CPHA)\r\nqmr |= MCFQSPI_QMR_CPHA;\r\nif (spi->mode & SPI_CPOL)\r\nqmr |= MCFQSPI_QMR_CPOL;\r\nif (t->speed_hz)\r\nqmr |= mcfqspi_qmr_baud(t->speed_hz);\r\nelse\r\nqmr |= mcfqspi_qmr_baud(spi->max_speed_hz);\r\nmcfqspi_wr_qmr(mcfqspi, qmr);\r\nmcfqspi_cs_select(mcfqspi, spi->chip_select, cs_high);\r\nmcfqspi_wr_qir(mcfqspi, MCFQSPI_QIR_SPIFE);\r\nif (t->bits_per_word == 8)\r\nmcfqspi_transfer_msg8(mcfqspi, t->len, t->tx_buf,\r\nt->rx_buf);\r\nelse\r\nmcfqspi_transfer_msg16(mcfqspi, t->len / 2, t->tx_buf,\r\nt->rx_buf);\r\nmcfqspi_wr_qir(mcfqspi, 0);\r\nif (t->delay_usecs)\r\nudelay(t->delay_usecs);\r\nif (t->cs_change) {\r\nif (!list_is_last(&t->transfer_list, &msg->transfers))\r\nmcfqspi_cs_deselect(mcfqspi, spi->chip_select,\r\ncs_high);\r\n} else {\r\nif (list_is_last(&t->transfer_list, &msg->transfers))\r\nmcfqspi_cs_deselect(mcfqspi, spi->chip_select,\r\ncs_high);\r\n}\r\nmsg->actual_length += t->len;\r\n}\r\nmsg->status = status;\r\nspi_finalize_current_message(master);\r\nreturn status;\r\n}\r\nstatic int mcfqspi_setup(struct spi_device *spi)\r\n{\r\nif (spi->chip_select >= spi->master->num_chipselect) {\r\ndev_dbg(&spi->dev, "%d chip select is out of range\n",\r\nspi->chip_select);\r\nreturn -EINVAL;\r\n}\r\nmcfqspi_cs_deselect(spi_master_get_devdata(spi->master),\r\nspi->chip_select, spi->mode & SPI_CS_HIGH);\r\ndev_dbg(&spi->dev,\r\n"bits per word %d, chip select %d, speed %d KHz\n",\r\nspi->bits_per_word, spi->chip_select,\r\n(MCFQSPI_BUSCLK / mcfqspi_qmr_baud(spi->max_speed_hz))\r\n/ 1000);\r\nreturn 0;\r\n}\r\nstatic int mcfqspi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct mcfqspi *mcfqspi;\r\nstruct resource *res;\r\nstruct mcfqspi_platform_data *pdata;\r\nint status;\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (!pdata) {\r\ndev_dbg(&pdev->dev, "platform data is missing\n");\r\nreturn -ENOENT;\r\n}\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*mcfqspi));\r\nif (master == NULL) {\r\ndev_dbg(&pdev->dev, "spi_alloc_master failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmcfqspi = spi_master_get_devdata(master);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_dbg(&pdev->dev, "platform_get_resource failed\n");\r\nstatus = -ENXIO;\r\ngoto fail0;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res), pdev->name)) {\r\ndev_dbg(&pdev->dev, "request_mem_region failed\n");\r\nstatus = -EBUSY;\r\ngoto fail0;\r\n}\r\nmcfqspi->iobase = ioremap(res->start, resource_size(res));\r\nif (!mcfqspi->iobase) {\r\ndev_dbg(&pdev->dev, "ioremap failed\n");\r\nstatus = -ENOMEM;\r\ngoto fail1;\r\n}\r\nmcfqspi->irq = platform_get_irq(pdev, 0);\r\nif (mcfqspi->irq < 0) {\r\ndev_dbg(&pdev->dev, "platform_get_irq failed\n");\r\nstatus = -ENXIO;\r\ngoto fail2;\r\n}\r\nstatus = request_irq(mcfqspi->irq, mcfqspi_irq_handler, 0,\r\npdev->name, mcfqspi);\r\nif (status) {\r\ndev_dbg(&pdev->dev, "request_irq failed\n");\r\ngoto fail2;\r\n}\r\nmcfqspi->clk = clk_get(&pdev->dev, "qspi_clk");\r\nif (IS_ERR(mcfqspi->clk)) {\r\ndev_dbg(&pdev->dev, "clk_get failed\n");\r\nstatus = PTR_ERR(mcfqspi->clk);\r\ngoto fail3;\r\n}\r\nclk_enable(mcfqspi->clk);\r\nmaster->bus_num = pdata->bus_num;\r\nmaster->num_chipselect = pdata->num_chipselect;\r\nmcfqspi->cs_control = pdata->cs_control;\r\nstatus = mcfqspi_cs_setup(mcfqspi);\r\nif (status) {\r\ndev_dbg(&pdev->dev, "error initializing cs_control\n");\r\ngoto fail4;\r\n}\r\ninit_waitqueue_head(&mcfqspi->waitq);\r\nmcfqspi->dev = &pdev->dev;\r\nmaster->mode_bits = SPI_CS_HIGH | SPI_CPOL | SPI_CPHA;\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 16);\r\nmaster->setup = mcfqspi_setup;\r\nmaster->transfer_one_message = mcfqspi_transfer_one_message;\r\nmaster->auto_runtime_pm = true;\r\nplatform_set_drvdata(pdev, master);\r\nstatus = spi_register_master(master);\r\nif (status) {\r\ndev_dbg(&pdev->dev, "spi_register_master failed\n");\r\ngoto fail5;\r\n}\r\npm_runtime_enable(mcfqspi->dev);\r\ndev_info(&pdev->dev, "Coldfire QSPI bus driver\n");\r\nreturn 0;\r\nfail5:\r\nmcfqspi_cs_teardown(mcfqspi);\r\nfail4:\r\nclk_disable(mcfqspi->clk);\r\nclk_put(mcfqspi->clk);\r\nfail3:\r\nfree_irq(mcfqspi->irq, mcfqspi);\r\nfail2:\r\niounmap(mcfqspi->iobase);\r\nfail1:\r\nrelease_mem_region(res->start, resource_size(res));\r\nfail0:\r\nspi_master_put(master);\r\ndev_dbg(&pdev->dev, "Coldfire QSPI probe failed\n");\r\nreturn status;\r\n}\r\nstatic int mcfqspi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct mcfqspi *mcfqspi = spi_master_get_devdata(master);\r\nstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npm_runtime_disable(mcfqspi->dev);\r\nmcfqspi_wr_qmr(mcfqspi, MCFQSPI_QMR_MSTR);\r\nmcfqspi_cs_teardown(mcfqspi);\r\nclk_disable(mcfqspi->clk);\r\nclk_put(mcfqspi->clk);\r\nfree_irq(mcfqspi->irq, mcfqspi);\r\niounmap(mcfqspi->iobase);\r\nrelease_mem_region(res->start, resource_size(res));\r\nspi_unregister_master(master);\r\nreturn 0;\r\n}\r\nstatic int mcfqspi_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct mcfqspi *mcfqspi = spi_master_get_devdata(master);\r\nspi_master_suspend(master);\r\nclk_disable(mcfqspi->clk);\r\nreturn 0;\r\n}\r\nstatic int mcfqspi_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct mcfqspi *mcfqspi = spi_master_get_devdata(master);\r\nspi_master_resume(master);\r\nclk_enable(mcfqspi->clk);\r\nreturn 0;\r\n}\r\nstatic int mcfqspi_runtime_suspend(struct device *dev)\r\n{\r\nstruct mcfqspi *mcfqspi = dev_get_drvdata(dev);\r\nclk_disable(mcfqspi->clk);\r\nreturn 0;\r\n}\r\nstatic int mcfqspi_runtime_resume(struct device *dev)\r\n{\r\nstruct mcfqspi *mcfqspi = dev_get_drvdata(dev);\r\nclk_enable(mcfqspi->clk);\r\nreturn 0;\r\n}
