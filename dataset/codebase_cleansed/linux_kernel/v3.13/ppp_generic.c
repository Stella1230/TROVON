static inline struct ppp_net *ppp_pernet(struct net *net)\r\n{\r\nBUG_ON(!net);\r\nreturn net_generic(net, ppp_net_id);\r\n}\r\nstatic inline int proto_to_npindex(int proto)\r\n{\r\nswitch (proto) {\r\ncase PPP_IP:\r\nreturn NP_IP;\r\ncase PPP_IPV6:\r\nreturn NP_IPV6;\r\ncase PPP_IPX:\r\nreturn NP_IPX;\r\ncase PPP_AT:\r\nreturn NP_AT;\r\ncase PPP_MPLS_UC:\r\nreturn NP_MPLS_UC;\r\ncase PPP_MPLS_MC:\r\nreturn NP_MPLS_MC;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic inline int ethertype_to_npindex(int ethertype)\r\n{\r\nswitch (ethertype) {\r\ncase ETH_P_IP:\r\nreturn NP_IP;\r\ncase ETH_P_IPV6:\r\nreturn NP_IPV6;\r\ncase ETH_P_IPX:\r\nreturn NP_IPX;\r\ncase ETH_P_PPPTALK:\r\ncase ETH_P_ATALK:\r\nreturn NP_AT;\r\ncase ETH_P_MPLS_UC:\r\nreturn NP_MPLS_UC;\r\ncase ETH_P_MPLS_MC:\r\nreturn NP_MPLS_MC;\r\n}\r\nreturn -1;\r\n}\r\nstatic int ppp_open(struct inode *inode, struct file *file)\r\n{\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nreturn 0;\r\n}\r\nstatic int ppp_release(struct inode *unused, struct file *file)\r\n{\r\nstruct ppp_file *pf = file->private_data;\r\nstruct ppp *ppp;\r\nif (pf) {\r\nfile->private_data = NULL;\r\nif (pf->kind == INTERFACE) {\r\nppp = PF_TO_PPP(pf);\r\nif (file == ppp->owner)\r\nppp_shutdown_interface(ppp);\r\n}\r\nif (atomic_dec_and_test(&pf->refcnt)) {\r\nswitch (pf->kind) {\r\ncase INTERFACE:\r\nppp_destroy_interface(PF_TO_PPP(pf));\r\nbreak;\r\ncase CHANNEL:\r\nppp_destroy_channel(PF_TO_CHANNEL(pf));\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t ppp_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ppp_file *pf = file->private_data;\r\nDECLARE_WAITQUEUE(wait, current);\r\nssize_t ret;\r\nstruct sk_buff *skb = NULL;\r\nstruct iovec iov;\r\nret = count;\r\nif (!pf)\r\nreturn -ENXIO;\r\nadd_wait_queue(&pf->rwait, &wait);\r\nfor (;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nskb = skb_dequeue(&pf->rq);\r\nif (skb)\r\nbreak;\r\nret = 0;\r\nif (pf->dead)\r\nbreak;\r\nif (pf->kind == INTERFACE) {\r\nstruct ppp *ppp = PF_TO_PPP(pf);\r\nif (ppp->n_channels == 0 &&\r\n(ppp->flags & SC_LOOP_TRAFFIC) == 0)\r\nbreak;\r\n}\r\nret = -EAGAIN;\r\nif (file->f_flags & O_NONBLOCK)\r\nbreak;\r\nret = -ERESTARTSYS;\r\nif (signal_pending(current))\r\nbreak;\r\nschedule();\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&pf->rwait, &wait);\r\nif (!skb)\r\ngoto out;\r\nret = -EOVERFLOW;\r\nif (skb->len > count)\r\ngoto outf;\r\nret = -EFAULT;\r\niov.iov_base = buf;\r\niov.iov_len = count;\r\nif (skb_copy_datagram_iovec(skb, 0, &iov, skb->len))\r\ngoto outf;\r\nret = skb->len;\r\noutf:\r\nkfree_skb(skb);\r\nout:\r\nreturn ret;\r\n}\r\nstatic ssize_t ppp_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ppp_file *pf = file->private_data;\r\nstruct sk_buff *skb;\r\nssize_t ret;\r\nif (!pf)\r\nreturn -ENXIO;\r\nret = -ENOMEM;\r\nskb = alloc_skb(count + pf->hdrlen, GFP_KERNEL);\r\nif (!skb)\r\ngoto out;\r\nskb_reserve(skb, pf->hdrlen);\r\nret = -EFAULT;\r\nif (copy_from_user(skb_put(skb, count), buf, count)) {\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nskb_queue_tail(&pf->xq, skb);\r\nswitch (pf->kind) {\r\ncase INTERFACE:\r\nppp_xmit_process(PF_TO_PPP(pf));\r\nbreak;\r\ncase CHANNEL:\r\nppp_channel_push(PF_TO_CHANNEL(pf));\r\nbreak;\r\n}\r\nret = count;\r\nout:\r\nreturn ret;\r\n}\r\nstatic unsigned int ppp_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct ppp_file *pf = file->private_data;\r\nunsigned int mask;\r\nif (!pf)\r\nreturn 0;\r\npoll_wait(file, &pf->rwait, wait);\r\nmask = POLLOUT | POLLWRNORM;\r\nif (skb_peek(&pf->rq))\r\nmask |= POLLIN | POLLRDNORM;\r\nif (pf->dead)\r\nmask |= POLLHUP;\r\nelse if (pf->kind == INTERFACE) {\r\nstruct ppp *ppp = PF_TO_PPP(pf);\r\nif (ppp->n_channels == 0 &&\r\n(ppp->flags & SC_LOOP_TRAFFIC) == 0)\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\nreturn mask;\r\n}\r\nstatic int get_filter(void __user *arg, struct sock_filter **p)\r\n{\r\nstruct sock_fprog uprog;\r\nstruct sock_filter *code = NULL;\r\nint len, err;\r\nif (copy_from_user(&uprog, arg, sizeof(uprog)))\r\nreturn -EFAULT;\r\nif (!uprog.len) {\r\n*p = NULL;\r\nreturn 0;\r\n}\r\nlen = uprog.len * sizeof(struct sock_filter);\r\ncode = memdup_user(uprog.filter, len);\r\nif (IS_ERR(code))\r\nreturn PTR_ERR(code);\r\nerr = sk_chk_filter(code, uprog.len);\r\nif (err) {\r\nkfree(code);\r\nreturn err;\r\n}\r\n*p = code;\r\nreturn uprog.len;\r\n}\r\nstatic long ppp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct ppp_file *pf = file->private_data;\r\nstruct ppp *ppp;\r\nint err = -EFAULT, val, val2, i;\r\nstruct ppp_idle idle;\r\nstruct npioctl npi;\r\nint unit, cflags;\r\nstruct slcompress *vj;\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nif (!pf)\r\nreturn ppp_unattached_ioctl(current->nsproxy->net_ns,\r\npf, file, cmd, arg);\r\nif (cmd == PPPIOCDETACH) {\r\nerr = -EINVAL;\r\nmutex_lock(&ppp_mutex);\r\nif (pf->kind == INTERFACE) {\r\nppp = PF_TO_PPP(pf);\r\nif (file == ppp->owner)\r\nppp_shutdown_interface(ppp);\r\n}\r\nif (atomic_long_read(&file->f_count) <= 2) {\r\nppp_release(NULL, file);\r\nerr = 0;\r\n} else\r\npr_warn("PPPIOCDETACH file->f_count=%ld\n",\r\natomic_long_read(&file->f_count));\r\nmutex_unlock(&ppp_mutex);\r\nreturn err;\r\n}\r\nif (pf->kind == CHANNEL) {\r\nstruct channel *pch;\r\nstruct ppp_channel *chan;\r\nmutex_lock(&ppp_mutex);\r\npch = PF_TO_CHANNEL(pf);\r\nswitch (cmd) {\r\ncase PPPIOCCONNECT:\r\nif (get_user(unit, p))\r\nbreak;\r\nerr = ppp_connect_channel(pch, unit);\r\nbreak;\r\ncase PPPIOCDISCONN:\r\nerr = ppp_disconnect_channel(pch);\r\nbreak;\r\ndefault:\r\ndown_read(&pch->chan_sem);\r\nchan = pch->chan;\r\nerr = -ENOTTY;\r\nif (chan && chan->ops->ioctl)\r\nerr = chan->ops->ioctl(chan, cmd, arg);\r\nup_read(&pch->chan_sem);\r\n}\r\nmutex_unlock(&ppp_mutex);\r\nreturn err;\r\n}\r\nif (pf->kind != INTERFACE) {\r\npr_err("PPP: not interface or channel??\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&ppp_mutex);\r\nppp = PF_TO_PPP(pf);\r\nswitch (cmd) {\r\ncase PPPIOCSMRU:\r\nif (get_user(val, p))\r\nbreak;\r\nppp->mru = val;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCSFLAGS:\r\nif (get_user(val, p))\r\nbreak;\r\nppp_lock(ppp);\r\ncflags = ppp->flags & ~val;\r\nppp->flags = val & SC_FLAG_BITS;\r\nppp_unlock(ppp);\r\nif (cflags & SC_CCP_OPEN)\r\nppp_ccp_closed(ppp);\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCGFLAGS:\r\nval = ppp->flags | ppp->xstate | ppp->rstate;\r\nif (put_user(val, p))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCSCOMPRESS:\r\nerr = ppp_set_compress(ppp, arg);\r\nbreak;\r\ncase PPPIOCGUNIT:\r\nif (put_user(ppp->file.index, p))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCSDEBUG:\r\nif (get_user(val, p))\r\nbreak;\r\nppp->debug = val;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCGDEBUG:\r\nif (put_user(ppp->debug, p))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCGIDLE:\r\nidle.xmit_idle = (jiffies - ppp->last_xmit) / HZ;\r\nidle.recv_idle = (jiffies - ppp->last_recv) / HZ;\r\nif (copy_to_user(argp, &idle, sizeof(idle)))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCSMAXCID:\r\nif (get_user(val, p))\r\nbreak;\r\nval2 = 15;\r\nif ((val >> 16) != 0) {\r\nval2 = val >> 16;\r\nval &= 0xffff;\r\n}\r\nvj = slhc_init(val2+1, val+1);\r\nif (!vj) {\r\nnetdev_err(ppp->dev,\r\n"PPP: no memory (VJ compressor)\n");\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\nppp_lock(ppp);\r\nif (ppp->vj)\r\nslhc_free(ppp->vj);\r\nppp->vj = vj;\r\nppp_unlock(ppp);\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCGNPMODE:\r\ncase PPPIOCSNPMODE:\r\nif (copy_from_user(&npi, argp, sizeof(npi)))\r\nbreak;\r\nerr = proto_to_npindex(npi.protocol);\r\nif (err < 0)\r\nbreak;\r\ni = err;\r\nif (cmd == PPPIOCGNPMODE) {\r\nerr = -EFAULT;\r\nnpi.mode = ppp->npmode[i];\r\nif (copy_to_user(argp, &npi, sizeof(npi)))\r\nbreak;\r\n} else {\r\nppp->npmode[i] = npi.mode;\r\nnetif_wake_queue(ppp->dev);\r\n}\r\nerr = 0;\r\nbreak;\r\n#ifdef CONFIG_PPP_FILTER\r\ncase PPPIOCSPASS:\r\n{\r\nstruct sock_filter *code;\r\nerr = get_filter(argp, &code);\r\nif (err >= 0) {\r\nppp_lock(ppp);\r\nkfree(ppp->pass_filter);\r\nppp->pass_filter = code;\r\nppp->pass_len = err;\r\nppp_unlock(ppp);\r\nerr = 0;\r\n}\r\nbreak;\r\n}\r\ncase PPPIOCSACTIVE:\r\n{\r\nstruct sock_filter *code;\r\nerr = get_filter(argp, &code);\r\nif (err >= 0) {\r\nppp_lock(ppp);\r\nkfree(ppp->active_filter);\r\nppp->active_filter = code;\r\nppp->active_len = err;\r\nppp_unlock(ppp);\r\nerr = 0;\r\n}\r\nbreak;\r\n}\r\n#endif\r\n#ifdef CONFIG_PPP_MULTILINK\r\ncase PPPIOCSMRRU:\r\nif (get_user(val, p))\r\nbreak;\r\nppp_recv_lock(ppp);\r\nppp->mrru = val;\r\nppp_recv_unlock(ppp);\r\nerr = 0;\r\nbreak;\r\n#endif\r\ndefault:\r\nerr = -ENOTTY;\r\n}\r\nmutex_unlock(&ppp_mutex);\r\nreturn err;\r\n}\r\nstatic int ppp_unattached_ioctl(struct net *net, struct ppp_file *pf,\r\nstruct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nint unit, err = -EFAULT;\r\nstruct ppp *ppp;\r\nstruct channel *chan;\r\nstruct ppp_net *pn;\r\nint __user *p = (int __user *)arg;\r\nmutex_lock(&ppp_mutex);\r\nswitch (cmd) {\r\ncase PPPIOCNEWUNIT:\r\nif (get_user(unit, p))\r\nbreak;\r\nppp = ppp_create_interface(net, unit, &err);\r\nif (!ppp)\r\nbreak;\r\nfile->private_data = &ppp->file;\r\nppp->owner = file;\r\nerr = -EFAULT;\r\nif (put_user(ppp->file.index, p))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCATTACH:\r\nif (get_user(unit, p))\r\nbreak;\r\nerr = -ENXIO;\r\npn = ppp_pernet(net);\r\nmutex_lock(&pn->all_ppp_mutex);\r\nppp = ppp_find_unit(pn, unit);\r\nif (ppp) {\r\natomic_inc(&ppp->file.refcnt);\r\nfile->private_data = &ppp->file;\r\nerr = 0;\r\n}\r\nmutex_unlock(&pn->all_ppp_mutex);\r\nbreak;\r\ncase PPPIOCATTCHAN:\r\nif (get_user(unit, p))\r\nbreak;\r\nerr = -ENXIO;\r\npn = ppp_pernet(net);\r\nspin_lock_bh(&pn->all_channels_lock);\r\nchan = ppp_find_channel(pn, unit);\r\nif (chan) {\r\natomic_inc(&chan->file.refcnt);\r\nfile->private_data = &chan->file;\r\nerr = 0;\r\n}\r\nspin_unlock_bh(&pn->all_channels_lock);\r\nbreak;\r\ndefault:\r\nerr = -ENOTTY;\r\n}\r\nmutex_unlock(&ppp_mutex);\r\nreturn err;\r\n}\r\nstatic __net_init int ppp_init_net(struct net *net)\r\n{\r\nstruct ppp_net *pn = net_generic(net, ppp_net_id);\r\nidr_init(&pn->units_idr);\r\nmutex_init(&pn->all_ppp_mutex);\r\nINIT_LIST_HEAD(&pn->all_channels);\r\nINIT_LIST_HEAD(&pn->new_channels);\r\nspin_lock_init(&pn->all_channels_lock);\r\nreturn 0;\r\n}\r\nstatic __net_exit void ppp_exit_net(struct net *net)\r\n{\r\nstruct ppp_net *pn = net_generic(net, ppp_net_id);\r\nidr_destroy(&pn->units_idr);\r\n}\r\nstatic int __init ppp_init(void)\r\n{\r\nint err;\r\npr_info("PPP generic driver version " PPP_VERSION "\n");\r\nerr = register_pernet_device(&ppp_net_ops);\r\nif (err) {\r\npr_err("failed to register PPP pernet device (%d)\n", err);\r\ngoto out;\r\n}\r\nerr = register_chrdev(PPP_MAJOR, "ppp", &ppp_device_fops);\r\nif (err) {\r\npr_err("failed to register PPP device (%d)\n", err);\r\ngoto out_net;\r\n}\r\nppp_class = class_create(THIS_MODULE, "ppp");\r\nif (IS_ERR(ppp_class)) {\r\nerr = PTR_ERR(ppp_class);\r\ngoto out_chrdev;\r\n}\r\ndevice_create(ppp_class, NULL, MKDEV(PPP_MAJOR, 0), NULL, "ppp");\r\nreturn 0;\r\nout_chrdev:\r\nunregister_chrdev(PPP_MAJOR, "ppp");\r\nout_net:\r\nunregister_pernet_device(&ppp_net_ops);\r\nout:\r\nreturn err;\r\n}\r\nstatic netdev_tx_t\r\nppp_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ppp *ppp = netdev_priv(dev);\r\nint npi, proto;\r\nunsigned char *pp;\r\nnpi = ethertype_to_npindex(ntohs(skb->protocol));\r\nif (npi < 0)\r\ngoto outf;\r\nswitch (ppp->npmode[npi]) {\r\ncase NPMODE_PASS:\r\nbreak;\r\ncase NPMODE_QUEUE:\r\ngoto outf;\r\ncase NPMODE_DROP:\r\ncase NPMODE_ERROR:\r\ngoto outf;\r\n}\r\nif (skb_cow_head(skb, PPP_HDRLEN))\r\ngoto outf;\r\npp = skb_push(skb, 2);\r\nproto = npindex_to_proto[npi];\r\nput_unaligned_be16(proto, pp);\r\nskb_queue_tail(&ppp->file.xq, skb);\r\nppp_xmit_process(ppp);\r\nreturn NETDEV_TX_OK;\r\noutf:\r\nkfree_skb(skb);\r\n++dev->stats.tx_dropped;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int\r\nppp_net_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct ppp *ppp = netdev_priv(dev);\r\nint err = -EFAULT;\r\nvoid __user *addr = (void __user *) ifr->ifr_ifru.ifru_data;\r\nstruct ppp_stats stats;\r\nstruct ppp_comp_stats cstats;\r\nchar *vers;\r\nswitch (cmd) {\r\ncase SIOCGPPPSTATS:\r\nppp_get_stats(ppp, &stats);\r\nif (copy_to_user(addr, &stats, sizeof(stats)))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase SIOCGPPPCSTATS:\r\nmemset(&cstats, 0, sizeof(cstats));\r\nif (ppp->xc_state)\r\nppp->xcomp->comp_stat(ppp->xc_state, &cstats.c);\r\nif (ppp->rc_state)\r\nppp->rcomp->decomp_stat(ppp->rc_state, &cstats.d);\r\nif (copy_to_user(addr, &cstats, sizeof(cstats)))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ncase SIOCGPPPVER:\r\nvers = PPP_VERSION;\r\nif (copy_to_user(addr, vers, strlen(vers) + 1))\r\nbreak;\r\nerr = 0;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic struct rtnl_link_stats64*\r\nppp_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats64)\r\n{\r\nstruct ppp *ppp = netdev_priv(dev);\r\nppp_recv_lock(ppp);\r\nstats64->rx_packets = ppp->stats64.rx_packets;\r\nstats64->rx_bytes = ppp->stats64.rx_bytes;\r\nppp_recv_unlock(ppp);\r\nppp_xmit_lock(ppp);\r\nstats64->tx_packets = ppp->stats64.tx_packets;\r\nstats64->tx_bytes = ppp->stats64.tx_bytes;\r\nppp_xmit_unlock(ppp);\r\nstats64->rx_errors = dev->stats.rx_errors;\r\nstats64->tx_errors = dev->stats.tx_errors;\r\nstats64->rx_dropped = dev->stats.rx_dropped;\r\nstats64->tx_dropped = dev->stats.tx_dropped;\r\nstats64->rx_length_errors = dev->stats.rx_length_errors;\r\nreturn stats64;\r\n}\r\nstatic int ppp_dev_init(struct net_device *dev)\r\n{\r\ndev->qdisc_tx_busylock = &ppp_tx_busylock;\r\nreturn 0;\r\n}\r\nstatic void ppp_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &ppp_netdev_ops;\r\ndev->hard_header_len = PPP_HDRLEN;\r\ndev->mtu = PPP_MRU;\r\ndev->addr_len = 0;\r\ndev->tx_queue_len = 3;\r\ndev->type = ARPHRD_PPP;\r\ndev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\r\ndev->features |= NETIF_F_NETNS_LOCAL;\r\ndev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\r\n}\r\nstatic void\r\nppp_xmit_process(struct ppp *ppp)\r\n{\r\nstruct sk_buff *skb;\r\nppp_xmit_lock(ppp);\r\nif (!ppp->closing) {\r\nppp_push(ppp);\r\nwhile (!ppp->xmit_pending &&\r\n(skb = skb_dequeue(&ppp->file.xq)))\r\nppp_send_frame(ppp, skb);\r\nif (!ppp->xmit_pending && !skb_peek(&ppp->file.xq))\r\nnetif_wake_queue(ppp->dev);\r\nelse\r\nnetif_stop_queue(ppp->dev);\r\n}\r\nppp_xmit_unlock(ppp);\r\n}\r\nstatic inline struct sk_buff *\r\npad_compress_skb(struct ppp *ppp, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *new_skb;\r\nint len;\r\nint new_skb_size = ppp->dev->mtu +\r\nppp->xcomp->comp_extra + ppp->dev->hard_header_len;\r\nint compressor_skb_size = ppp->dev->mtu +\r\nppp->xcomp->comp_extra + PPP_HDRLEN;\r\nnew_skb = alloc_skb(new_skb_size, GFP_ATOMIC);\r\nif (!new_skb) {\r\nif (net_ratelimit())\r\nnetdev_err(ppp->dev, "PPP: no memory (comp pkt)\n");\r\nreturn NULL;\r\n}\r\nif (ppp->dev->hard_header_len > PPP_HDRLEN)\r\nskb_reserve(new_skb,\r\nppp->dev->hard_header_len - PPP_HDRLEN);\r\nlen = ppp->xcomp->compress(ppp->xc_state, skb->data - 2,\r\nnew_skb->data, skb->len + 2,\r\ncompressor_skb_size);\r\nif (len > 0 && (ppp->flags & SC_CCP_UP)) {\r\nconsume_skb(skb);\r\nskb = new_skb;\r\nskb_put(skb, len);\r\nskb_pull(skb, 2);\r\n} else if (len == 0) {\r\nconsume_skb(new_skb);\r\nnew_skb = skb;\r\n} else {\r\nif (net_ratelimit())\r\nnetdev_err(ppp->dev, "ppp: compressor dropped pkt\n");\r\nkfree_skb(skb);\r\nconsume_skb(new_skb);\r\nnew_skb = NULL;\r\n}\r\nreturn new_skb;\r\n}\r\nstatic void\r\nppp_send_frame(struct ppp *ppp, struct sk_buff *skb)\r\n{\r\nint proto = PPP_PROTO(skb);\r\nstruct sk_buff *new_skb;\r\nint len;\r\nunsigned char *cp;\r\nif (proto < 0x8000) {\r\n#ifdef CONFIG_PPP_FILTER\r\n*skb_push(skb, 2) = 1;\r\nif (ppp->pass_filter &&\r\nsk_run_filter(skb, ppp->pass_filter) == 0) {\r\nif (ppp->debug & 1)\r\nnetdev_printk(KERN_DEBUG, ppp->dev,\r\n"PPP: outbound frame "\r\n"not passed\n");\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (!(ppp->active_filter &&\r\nsk_run_filter(skb, ppp->active_filter) == 0))\r\nppp->last_xmit = jiffies;\r\nskb_pull(skb, 2);\r\n#else\r\nppp->last_xmit = jiffies;\r\n#endif\r\n}\r\n++ppp->stats64.tx_packets;\r\nppp->stats64.tx_bytes += skb->len - 2;\r\nswitch (proto) {\r\ncase PPP_IP:\r\nif (!ppp->vj || (ppp->flags & SC_COMP_TCP) == 0)\r\nbreak;\r\nnew_skb = alloc_skb(skb->len + ppp->dev->hard_header_len - 2,\r\nGFP_ATOMIC);\r\nif (!new_skb) {\r\nnetdev_err(ppp->dev, "PPP: no memory (VJ comp pkt)\n");\r\ngoto drop;\r\n}\r\nskb_reserve(new_skb, ppp->dev->hard_header_len - 2);\r\ncp = skb->data + 2;\r\nlen = slhc_compress(ppp->vj, cp, skb->len - 2,\r\nnew_skb->data + 2, &cp,\r\n!(ppp->flags & SC_NO_TCP_CCID));\r\nif (cp == skb->data + 2) {\r\nconsume_skb(new_skb);\r\n} else {\r\nif (cp[0] & SL_TYPE_COMPRESSED_TCP) {\r\nproto = PPP_VJC_COMP;\r\ncp[0] &= ~SL_TYPE_COMPRESSED_TCP;\r\n} else {\r\nproto = PPP_VJC_UNCOMP;\r\ncp[0] = skb->data[2];\r\n}\r\nconsume_skb(skb);\r\nskb = new_skb;\r\ncp = skb_put(skb, len + 2);\r\ncp[0] = 0;\r\ncp[1] = proto;\r\n}\r\nbreak;\r\ncase PPP_CCP:\r\nppp_ccp_peek(ppp, skb, 0);\r\nbreak;\r\n}\r\nif ((ppp->xstate & SC_COMP_RUN) && ppp->xc_state &&\r\nproto != PPP_LCP && proto != PPP_CCP) {\r\nif (!(ppp->flags & SC_CCP_UP) && (ppp->flags & SC_MUST_COMP)) {\r\nif (net_ratelimit())\r\nnetdev_err(ppp->dev,\r\n"ppp: compression required but "\r\n"down - pkt dropped.\n");\r\ngoto drop;\r\n}\r\nskb = pad_compress_skb(ppp, skb);\r\nif (!skb)\r\ngoto drop;\r\n}\r\nif (ppp->flags & SC_LOOP_TRAFFIC) {\r\nif (ppp->file.rq.qlen > PPP_MAX_RQLEN)\r\ngoto drop;\r\nskb_queue_tail(&ppp->file.rq, skb);\r\nwake_up_interruptible(&ppp->file.rwait);\r\nreturn;\r\n}\r\nppp->xmit_pending = skb;\r\nppp_push(ppp);\r\nreturn;\r\ndrop:\r\nkfree_skb(skb);\r\n++ppp->dev->stats.tx_errors;\r\n}\r\nstatic void\r\nppp_push(struct ppp *ppp)\r\n{\r\nstruct list_head *list;\r\nstruct channel *pch;\r\nstruct sk_buff *skb = ppp->xmit_pending;\r\nif (!skb)\r\nreturn;\r\nlist = &ppp->channels;\r\nif (list_empty(list)) {\r\nppp->xmit_pending = NULL;\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif ((ppp->flags & SC_MULTILINK) == 0) {\r\nlist = list->next;\r\npch = list_entry(list, struct channel, clist);\r\nspin_lock_bh(&pch->downl);\r\nif (pch->chan) {\r\nif (pch->chan->ops->start_xmit(pch->chan, skb))\r\nppp->xmit_pending = NULL;\r\n} else {\r\nkfree_skb(skb);\r\nppp->xmit_pending = NULL;\r\n}\r\nspin_unlock_bh(&pch->downl);\r\nreturn;\r\n}\r\n#ifdef CONFIG_PPP_MULTILINK\r\nif (!ppp_mp_explode(ppp, skb))\r\nreturn;\r\n#endif\r\nppp->xmit_pending = NULL;\r\nkfree_skb(skb);\r\n}\r\nstatic int ppp_mp_explode(struct ppp *ppp, struct sk_buff *skb)\r\n{\r\nint len, totlen;\r\nint i, bits, hdrlen, mtu;\r\nint flen;\r\nint navail, nfree, nzero;\r\nint nbigger;\r\nint totspeed;\r\nint totfree;\r\nunsigned char *p, *q;\r\nstruct list_head *list;\r\nstruct channel *pch;\r\nstruct sk_buff *frag;\r\nstruct ppp_channel *chan;\r\ntotspeed = 0;\r\nnfree = 0;\r\nnavail = 0;\r\nnzero = 0;\r\ntotfree = 0;\r\nhdrlen = (ppp->flags & SC_MP_XSHORTSEQ)? MPHDRLEN_SSN: MPHDRLEN;\r\ni = 0;\r\nlist_for_each_entry(pch, &ppp->channels, clist) {\r\nif (pch->chan) {\r\npch->avail = 1;\r\nnavail++;\r\npch->speed = pch->chan->speed;\r\n} else {\r\npch->avail = 0;\r\n}\r\nif (pch->avail) {\r\nif (skb_queue_empty(&pch->file.xq) ||\r\n!pch->had_frag) {\r\nif (pch->speed == 0)\r\nnzero++;\r\nelse\r\ntotspeed += pch->speed;\r\npch->avail = 2;\r\n++nfree;\r\n++totfree;\r\n}\r\nif (!pch->had_frag && i < ppp->nxchan)\r\nppp->nxchan = i;\r\n}\r\n++i;\r\n}\r\nif (nfree == 0 || nfree < navail / 2)\r\nreturn 0;\r\np = skb->data;\r\nlen = skb->len;\r\nif (*p == 0 && mp_protocol_compress) {\r\n++p;\r\n--len;\r\n}\r\ntotlen = len;\r\nnbigger = len % nfree;\r\nlist = &ppp->channels;\r\nfor (i = 0; i < ppp->nxchan; ++i) {\r\nlist = list->next;\r\nif (list == &ppp->channels) {\r\ni = 0;\r\nbreak;\r\n}\r\n}\r\nbits = B;\r\nwhile (len > 0) {\r\nlist = list->next;\r\nif (list == &ppp->channels) {\r\ni = 0;\r\ncontinue;\r\n}\r\npch = list_entry(list, struct channel, clist);\r\n++i;\r\nif (!pch->avail)\r\ncontinue;\r\nif (pch->avail == 1) {\r\nif (nfree > 0)\r\ncontinue;\r\n} else {\r\npch->avail = 1;\r\n}\r\nspin_lock_bh(&pch->downl);\r\nif (pch->chan == NULL) {\r\nif (pch->speed == 0)\r\nnzero--;\r\nelse\r\ntotspeed -= pch->speed;\r\nspin_unlock_bh(&pch->downl);\r\npch->avail = 0;\r\ntotlen = len;\r\ntotfree--;\r\nnfree--;\r\nif (--navail == 0)\r\nbreak;\r\ncontinue;\r\n}\r\nflen = len;\r\nif (nfree > 0) {\r\nif (pch->speed == 0) {\r\nflen = len/nfree;\r\nif (nbigger > 0) {\r\nflen++;\r\nnbigger--;\r\n}\r\n} else {\r\nflen = (((totfree - nzero)*(totlen + hdrlen*totfree)) /\r\n((totspeed*totfree)/pch->speed)) - hdrlen;\r\nif (nbigger > 0) {\r\nflen += ((totfree - nzero)*pch->speed)/totspeed;\r\nnbigger -= ((totfree - nzero)*pch->speed)/\r\ntotspeed;\r\n}\r\n}\r\nnfree--;\r\n}\r\nif ((nfree <= 0) || (flen > len))\r\nflen = len;\r\nif (flen <= 0) {\r\npch->avail = 2;\r\nspin_unlock_bh(&pch->downl);\r\ncontinue;\r\n}\r\nmtu = pch->chan->mtu - (hdrlen - 2);\r\nif (mtu < 4)\r\nmtu = 4;\r\nif (flen > mtu)\r\nflen = mtu;\r\nif (flen == len)\r\nbits |= E;\r\nfrag = alloc_skb(flen + hdrlen + (flen == 0), GFP_ATOMIC);\r\nif (!frag)\r\ngoto noskb;\r\nq = skb_put(frag, flen + hdrlen);\r\nput_unaligned_be16(PPP_MP, q);\r\nif (ppp->flags & SC_MP_XSHORTSEQ) {\r\nq[2] = bits + ((ppp->nxseq >> 8) & 0xf);\r\nq[3] = ppp->nxseq;\r\n} else {\r\nq[2] = bits;\r\nq[3] = ppp->nxseq >> 16;\r\nq[4] = ppp->nxseq >> 8;\r\nq[5] = ppp->nxseq;\r\n}\r\nmemcpy(q + hdrlen, p, flen);\r\nchan = pch->chan;\r\nif (!skb_queue_empty(&pch->file.xq) ||\r\n!chan->ops->start_xmit(chan, frag))\r\nskb_queue_tail(&pch->file.xq, frag);\r\npch->had_frag = 1;\r\np += flen;\r\nlen -= flen;\r\n++ppp->nxseq;\r\nbits = 0;\r\nspin_unlock_bh(&pch->downl);\r\n}\r\nppp->nxchan = i;\r\nreturn 1;\r\nnoskb:\r\nspin_unlock_bh(&pch->downl);\r\nif (ppp->debug & 1)\r\nnetdev_err(ppp->dev, "PPP: no memory (fragment)\n");\r\n++ppp->dev->stats.tx_errors;\r\n++ppp->nxseq;\r\nreturn 1;\r\n}\r\nstatic void\r\nppp_channel_push(struct channel *pch)\r\n{\r\nstruct sk_buff *skb;\r\nstruct ppp *ppp;\r\nspin_lock_bh(&pch->downl);\r\nif (pch->chan) {\r\nwhile (!skb_queue_empty(&pch->file.xq)) {\r\nskb = skb_dequeue(&pch->file.xq);\r\nif (!pch->chan->ops->start_xmit(pch->chan, skb)) {\r\nskb_queue_head(&pch->file.xq, skb);\r\nbreak;\r\n}\r\n}\r\n} else {\r\nskb_queue_purge(&pch->file.xq);\r\n}\r\nspin_unlock_bh(&pch->downl);\r\nif (skb_queue_empty(&pch->file.xq)) {\r\nread_lock_bh(&pch->upl);\r\nppp = pch->ppp;\r\nif (ppp)\r\nppp_xmit_process(ppp);\r\nread_unlock_bh(&pch->upl);\r\n}\r\n}\r\nstatic inline void\r\nppp_do_recv(struct ppp *ppp, struct sk_buff *skb, struct channel *pch)\r\n{\r\nppp_recv_lock(ppp);\r\nif (!ppp->closing)\r\nppp_receive_frame(ppp, skb, pch);\r\nelse\r\nkfree_skb(skb);\r\nppp_recv_unlock(ppp);\r\n}\r\nvoid\r\nppp_input(struct ppp_channel *chan, struct sk_buff *skb)\r\n{\r\nstruct channel *pch = chan->ppp;\r\nint proto;\r\nif (!pch) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nread_lock_bh(&pch->upl);\r\nif (!pskb_may_pull(skb, 2)) {\r\nkfree_skb(skb);\r\nif (pch->ppp) {\r\n++pch->ppp->dev->stats.rx_length_errors;\r\nppp_receive_error(pch->ppp);\r\n}\r\ngoto done;\r\n}\r\nproto = PPP_PROTO(skb);\r\nif (!pch->ppp || proto >= 0xc000 || proto == PPP_CCPFRAG) {\r\nskb_queue_tail(&pch->file.rq, skb);\r\nwhile (pch->file.rq.qlen > PPP_MAX_RQLEN &&\r\n(skb = skb_dequeue(&pch->file.rq)))\r\nkfree_skb(skb);\r\nwake_up_interruptible(&pch->file.rwait);\r\n} else {\r\nppp_do_recv(pch->ppp, skb, pch);\r\n}\r\ndone:\r\nread_unlock_bh(&pch->upl);\r\n}\r\nvoid\r\nppp_input_error(struct ppp_channel *chan, int code)\r\n{\r\nstruct channel *pch = chan->ppp;\r\nstruct sk_buff *skb;\r\nif (!pch)\r\nreturn;\r\nread_lock_bh(&pch->upl);\r\nif (pch->ppp) {\r\nskb = alloc_skb(0, GFP_ATOMIC);\r\nif (skb) {\r\nskb->len = 0;\r\nskb->cb[0] = code;\r\nppp_do_recv(pch->ppp, skb, pch);\r\n}\r\n}\r\nread_unlock_bh(&pch->upl);\r\n}\r\nstatic void\r\nppp_receive_frame(struct ppp *ppp, struct sk_buff *skb, struct channel *pch)\r\n{\r\nif (skb->len > 0) {\r\n#ifdef CONFIG_PPP_MULTILINK\r\nif (PPP_PROTO(skb) == PPP_MP)\r\nppp_receive_mp_frame(ppp, skb, pch);\r\nelse\r\n#endif\r\nppp_receive_nonmp_frame(ppp, skb);\r\n} else {\r\nkfree_skb(skb);\r\nppp_receive_error(ppp);\r\n}\r\n}\r\nstatic void\r\nppp_receive_error(struct ppp *ppp)\r\n{\r\n++ppp->dev->stats.rx_errors;\r\nif (ppp->vj)\r\nslhc_toss(ppp->vj);\r\n}\r\nstatic void\r\nppp_receive_nonmp_frame(struct ppp *ppp, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *ns;\r\nint proto, len, npi;\r\nif (ppp->rc_state && (ppp->rstate & SC_DECOMP_RUN) &&\r\n(ppp->rstate & (SC_DC_FERROR | SC_DC_ERROR)) == 0)\r\nskb = ppp_decompress_frame(ppp, skb);\r\nif (ppp->flags & SC_MUST_COMP && ppp->rstate & SC_DC_FERROR)\r\ngoto err;\r\nproto = PPP_PROTO(skb);\r\nswitch (proto) {\r\ncase PPP_VJC_COMP:\r\nif (!ppp->vj || (ppp->flags & SC_REJ_COMP_TCP))\r\ngoto err;\r\nif (skb_tailroom(skb) < 124 || skb_cloned(skb)) {\r\nns = dev_alloc_skb(skb->len + 128);\r\nif (!ns) {\r\nnetdev_err(ppp->dev, "PPP: no memory "\r\n"(VJ decomp)\n");\r\ngoto err;\r\n}\r\nskb_reserve(ns, 2);\r\nskb_copy_bits(skb, 0, skb_put(ns, skb->len), skb->len);\r\nconsume_skb(skb);\r\nskb = ns;\r\n}\r\nelse\r\nskb->ip_summed = CHECKSUM_NONE;\r\nlen = slhc_uncompress(ppp->vj, skb->data + 2, skb->len - 2);\r\nif (len <= 0) {\r\nnetdev_printk(KERN_DEBUG, ppp->dev,\r\n"PPP: VJ decompression error\n");\r\ngoto err;\r\n}\r\nlen += 2;\r\nif (len > skb->len)\r\nskb_put(skb, len - skb->len);\r\nelse if (len < skb->len)\r\nskb_trim(skb, len);\r\nproto = PPP_IP;\r\nbreak;\r\ncase PPP_VJC_UNCOMP:\r\nif (!ppp->vj || (ppp->flags & SC_REJ_COMP_TCP))\r\ngoto err;\r\nif (!pskb_may_pull(skb, skb->len))\r\ngoto err;\r\nif (slhc_remember(ppp->vj, skb->data + 2, skb->len - 2) <= 0) {\r\nnetdev_err(ppp->dev, "PPP: VJ uncompressed error\n");\r\ngoto err;\r\n}\r\nproto = PPP_IP;\r\nbreak;\r\ncase PPP_CCP:\r\nppp_ccp_peek(ppp, skb, 1);\r\nbreak;\r\n}\r\n++ppp->stats64.rx_packets;\r\nppp->stats64.rx_bytes += skb->len - 2;\r\nnpi = proto_to_npindex(proto);\r\nif (npi < 0) {\r\nskb_queue_tail(&ppp->file.rq, skb);\r\nwhile (ppp->file.rq.qlen > PPP_MAX_RQLEN &&\r\n(skb = skb_dequeue(&ppp->file.rq)))\r\nkfree_skb(skb);\r\nwake_up_interruptible(&ppp->file.rwait);\r\n} else {\r\n#ifdef CONFIG_PPP_FILTER\r\nif (ppp->pass_filter || ppp->active_filter) {\r\nif (skb_unclone(skb, GFP_ATOMIC))\r\ngoto err;\r\n*skb_push(skb, 2) = 0;\r\nif (ppp->pass_filter &&\r\nsk_run_filter(skb, ppp->pass_filter) == 0) {\r\nif (ppp->debug & 1)\r\nnetdev_printk(KERN_DEBUG, ppp->dev,\r\n"PPP: inbound frame "\r\n"not passed\n");\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (!(ppp->active_filter &&\r\nsk_run_filter(skb, ppp->active_filter) == 0))\r\nppp->last_recv = jiffies;\r\n__skb_pull(skb, 2);\r\n} else\r\n#endif\r\nppp->last_recv = jiffies;\r\nif ((ppp->dev->flags & IFF_UP) == 0 ||\r\nppp->npmode[npi] != NPMODE_PASS) {\r\nkfree_skb(skb);\r\n} else {\r\nskb_pull_rcsum(skb, 2);\r\nskb->dev = ppp->dev;\r\nskb->protocol = htons(npindex_to_ethertype[npi]);\r\nskb_reset_mac_header(skb);\r\nnetif_rx(skb);\r\n}\r\n}\r\nreturn;\r\nerr:\r\nkfree_skb(skb);\r\nppp_receive_error(ppp);\r\n}\r\nstatic struct sk_buff *\r\nppp_decompress_frame(struct ppp *ppp, struct sk_buff *skb)\r\n{\r\nint proto = PPP_PROTO(skb);\r\nstruct sk_buff *ns;\r\nint len;\r\nif (!pskb_may_pull(skb, skb->len))\r\ngoto err;\r\nif (proto == PPP_COMP) {\r\nint obuff_size;\r\nswitch(ppp->rcomp->compress_proto) {\r\ncase CI_MPPE:\r\nobuff_size = ppp->mru + PPP_HDRLEN + 1;\r\nbreak;\r\ndefault:\r\nobuff_size = ppp->mru + PPP_HDRLEN;\r\nbreak;\r\n}\r\nns = dev_alloc_skb(obuff_size);\r\nif (!ns) {\r\nnetdev_err(ppp->dev, "ppp_decompress_frame: "\r\n"no memory\n");\r\ngoto err;\r\n}\r\nlen = ppp->rcomp->decompress(ppp->rc_state, skb->data - 2,\r\nskb->len + 2, ns->data, obuff_size);\r\nif (len < 0) {\r\nif (len == DECOMP_FATALERROR)\r\nppp->rstate |= SC_DC_FERROR;\r\nkfree_skb(ns);\r\ngoto err;\r\n}\r\nconsume_skb(skb);\r\nskb = ns;\r\nskb_put(skb, len);\r\nskb_pull(skb, 2);\r\n} else {\r\nif (ppp->rcomp->incomp)\r\nppp->rcomp->incomp(ppp->rc_state, skb->data - 2,\r\nskb->len + 2);\r\n}\r\nreturn skb;\r\nerr:\r\nppp->rstate |= SC_DC_ERROR;\r\nppp_receive_error(ppp);\r\nreturn skb;\r\n}\r\nstatic void\r\nppp_receive_mp_frame(struct ppp *ppp, struct sk_buff *skb, struct channel *pch)\r\n{\r\nu32 mask, seq;\r\nstruct channel *ch;\r\nint mphdrlen = (ppp->flags & SC_MP_SHORTSEQ)? MPHDRLEN_SSN: MPHDRLEN;\r\nif (!pskb_may_pull(skb, mphdrlen + 1) || ppp->mrru == 0)\r\ngoto err;\r\nif (ppp->flags & SC_MP_SHORTSEQ) {\r\nseq = ((skb->data[2] & 0x0f) << 8) | skb->data[3];\r\nmask = 0xfff;\r\n} else {\r\nseq = (skb->data[3] << 16) | (skb->data[4] << 8)| skb->data[5];\r\nmask = 0xffffff;\r\n}\r\nPPP_MP_CB(skb)->BEbits = skb->data[2];\r\nskb_pull(skb, mphdrlen);\r\nif ((PPP_MP_CB(skb)->BEbits & B) && (skb->data[0] & 1))\r\n*skb_push(skb, 1) = 0;\r\nseq |= ppp->minseq & ~mask;\r\nif ((int)(ppp->minseq - seq) > (int)(mask >> 1))\r\nseq += mask + 1;\r\nelse if ((int)(seq - ppp->minseq) > (int)(mask >> 1))\r\nseq -= mask + 1;\r\nPPP_MP_CB(skb)->sequence = seq;\r\npch->lastseq = seq;\r\nif (seq_before(seq, ppp->nextseq)) {\r\nkfree_skb(skb);\r\n++ppp->dev->stats.rx_dropped;\r\nppp_receive_error(ppp);\r\nreturn;\r\n}\r\nlist_for_each_entry(ch, &ppp->channels, clist) {\r\nif (seq_before(ch->lastseq, seq))\r\nseq = ch->lastseq;\r\n}\r\nif (seq_before(ppp->minseq, seq))\r\nppp->minseq = seq;\r\nppp_mp_insert(ppp, skb);\r\nif (skb_queue_len(&ppp->mrq) >= PPP_MP_MAX_QLEN) {\r\nstruct sk_buff *mskb = skb_peek(&ppp->mrq);\r\nif (seq_before(ppp->minseq, PPP_MP_CB(mskb)->sequence))\r\nppp->minseq = PPP_MP_CB(mskb)->sequence;\r\n}\r\nwhile ((skb = ppp_mp_reconstruct(ppp))) {\r\nif (pskb_may_pull(skb, 2))\r\nppp_receive_nonmp_frame(ppp, skb);\r\nelse {\r\n++ppp->dev->stats.rx_length_errors;\r\nkfree_skb(skb);\r\nppp_receive_error(ppp);\r\n}\r\n}\r\nreturn;\r\nerr:\r\nkfree_skb(skb);\r\nppp_receive_error(ppp);\r\n}\r\nstatic void\r\nppp_mp_insert(struct ppp *ppp, struct sk_buff *skb)\r\n{\r\nstruct sk_buff *p;\r\nstruct sk_buff_head *list = &ppp->mrq;\r\nu32 seq = PPP_MP_CB(skb)->sequence;\r\nskb_queue_walk(list, p) {\r\nif (seq_before(seq, PPP_MP_CB(p)->sequence))\r\nbreak;\r\n}\r\n__skb_queue_before(list, p, skb);\r\n}\r\nstatic struct sk_buff *\r\nppp_mp_reconstruct(struct ppp *ppp)\r\n{\r\nu32 seq = ppp->nextseq;\r\nu32 minseq = ppp->minseq;\r\nstruct sk_buff_head *list = &ppp->mrq;\r\nstruct sk_buff *p, *tmp;\r\nstruct sk_buff *head, *tail;\r\nstruct sk_buff *skb = NULL;\r\nint lost = 0, len = 0;\r\nif (ppp->mrru == 0)\r\nreturn NULL;\r\nhead = list->next;\r\ntail = NULL;\r\nskb_queue_walk_safe(list, p, tmp) {\r\nagain:\r\nif (seq_before(PPP_MP_CB(p)->sequence, seq)) {\r\nnetdev_err(ppp->dev, "ppp_mp_reconstruct bad "\r\n"seq %u < %u\n",\r\nPPP_MP_CB(p)->sequence, seq);\r\n__skb_unlink(p, list);\r\nkfree_skb(p);\r\ncontinue;\r\n}\r\nif (PPP_MP_CB(p)->sequence != seq) {\r\nu32 oldseq;\r\nif (seq_after(seq, minseq))\r\nbreak;\r\nlost = 1;\r\noldseq = seq;\r\nseq = seq_before(minseq, PPP_MP_CB(p)->sequence)?\r\nminseq + 1: PPP_MP_CB(p)->sequence;\r\nif (ppp->debug & 1)\r\nnetdev_printk(KERN_DEBUG, ppp->dev,\r\n"lost frag %u..%u\n",\r\noldseq, seq-1);\r\ngoto again;\r\n}\r\nif (PPP_MP_CB(p)->BEbits & B) {\r\nhead = p;\r\nlost = 0;\r\nlen = 0;\r\n}\r\nlen += p->len;\r\nif (lost == 0 && (PPP_MP_CB(p)->BEbits & E) &&\r\n(PPP_MP_CB(head)->BEbits & B)) {\r\nif (len > ppp->mrru + 2) {\r\n++ppp->dev->stats.rx_length_errors;\r\nnetdev_printk(KERN_DEBUG, ppp->dev,\r\n"PPP: reconstructed packet"\r\n" is too long (%d)\n", len);\r\n} else {\r\ntail = p;\r\nbreak;\r\n}\r\nppp->nextseq = seq + 1;\r\n}\r\nif (PPP_MP_CB(p)->BEbits & E) {\r\nstruct sk_buff *tmp2;\r\nskb_queue_reverse_walk_from_safe(list, p, tmp2) {\r\nif (ppp->debug & 1)\r\nnetdev_printk(KERN_DEBUG, ppp->dev,\r\n"discarding frag %u\n",\r\nPPP_MP_CB(p)->sequence);\r\n__skb_unlink(p, list);\r\nkfree_skb(p);\r\n}\r\nhead = skb_peek(list);\r\nif (!head)\r\nbreak;\r\n}\r\n++seq;\r\n}\r\nif (tail != NULL) {\r\nif (PPP_MP_CB(head)->sequence != ppp->nextseq) {\r\nskb_queue_walk_safe(list, p, tmp) {\r\nif (p == head)\r\nbreak;\r\nif (ppp->debug & 1)\r\nnetdev_printk(KERN_DEBUG, ppp->dev,\r\n"discarding frag %u\n",\r\nPPP_MP_CB(p)->sequence);\r\n__skb_unlink(p, list);\r\nkfree_skb(p);\r\n}\r\nif (ppp->debug & 1)\r\nnetdev_printk(KERN_DEBUG, ppp->dev,\r\n" missed pkts %u..%u\n",\r\nppp->nextseq,\r\nPPP_MP_CB(head)->sequence-1);\r\n++ppp->dev->stats.rx_dropped;\r\nppp_receive_error(ppp);\r\n}\r\nskb = head;\r\nif (head != tail) {\r\nstruct sk_buff **fragpp = &skb_shinfo(skb)->frag_list;\r\np = skb_queue_next(list, head);\r\n__skb_unlink(skb, list);\r\nskb_queue_walk_from_safe(list, p, tmp) {\r\n__skb_unlink(p, list);\r\n*fragpp = p;\r\np->next = NULL;\r\nfragpp = &p->next;\r\nskb->len += p->len;\r\nskb->data_len += p->len;\r\nskb->truesize += p->truesize;\r\nif (p == tail)\r\nbreak;\r\n}\r\n} else {\r\n__skb_unlink(skb, list);\r\n}\r\nppp->nextseq = PPP_MP_CB(tail)->sequence + 1;\r\n}\r\nreturn skb;\r\n}\r\nint ppp_register_channel(struct ppp_channel *chan)\r\n{\r\nreturn ppp_register_net_channel(current->nsproxy->net_ns, chan);\r\n}\r\nint ppp_register_net_channel(struct net *net, struct ppp_channel *chan)\r\n{\r\nstruct channel *pch;\r\nstruct ppp_net *pn;\r\npch = kzalloc(sizeof(struct channel), GFP_KERNEL);\r\nif (!pch)\r\nreturn -ENOMEM;\r\npn = ppp_pernet(net);\r\npch->ppp = NULL;\r\npch->chan = chan;\r\npch->chan_net = net;\r\nchan->ppp = pch;\r\ninit_ppp_file(&pch->file, CHANNEL);\r\npch->file.hdrlen = chan->hdrlen;\r\n#ifdef CONFIG_PPP_MULTILINK\r\npch->lastseq = -1;\r\n#endif\r\ninit_rwsem(&pch->chan_sem);\r\nspin_lock_init(&pch->downl);\r\nrwlock_init(&pch->upl);\r\nspin_lock_bh(&pn->all_channels_lock);\r\npch->file.index = ++pn->last_channel_index;\r\nlist_add(&pch->list, &pn->new_channels);\r\natomic_inc(&channel_count);\r\nspin_unlock_bh(&pn->all_channels_lock);\r\nreturn 0;\r\n}\r\nint ppp_channel_index(struct ppp_channel *chan)\r\n{\r\nstruct channel *pch = chan->ppp;\r\nif (pch)\r\nreturn pch->file.index;\r\nreturn -1;\r\n}\r\nint ppp_unit_number(struct ppp_channel *chan)\r\n{\r\nstruct channel *pch = chan->ppp;\r\nint unit = -1;\r\nif (pch) {\r\nread_lock_bh(&pch->upl);\r\nif (pch->ppp)\r\nunit = pch->ppp->file.index;\r\nread_unlock_bh(&pch->upl);\r\n}\r\nreturn unit;\r\n}\r\nchar *ppp_dev_name(struct ppp_channel *chan)\r\n{\r\nstruct channel *pch = chan->ppp;\r\nchar *name = NULL;\r\nif (pch) {\r\nread_lock_bh(&pch->upl);\r\nif (pch->ppp && pch->ppp->dev)\r\nname = pch->ppp->dev->name;\r\nread_unlock_bh(&pch->upl);\r\n}\r\nreturn name;\r\n}\r\nvoid\r\nppp_unregister_channel(struct ppp_channel *chan)\r\n{\r\nstruct channel *pch = chan->ppp;\r\nstruct ppp_net *pn;\r\nif (!pch)\r\nreturn;\r\nchan->ppp = NULL;\r\ndown_write(&pch->chan_sem);\r\nspin_lock_bh(&pch->downl);\r\npch->chan = NULL;\r\nspin_unlock_bh(&pch->downl);\r\nup_write(&pch->chan_sem);\r\nppp_disconnect_channel(pch);\r\npn = ppp_pernet(pch->chan_net);\r\nspin_lock_bh(&pn->all_channels_lock);\r\nlist_del(&pch->list);\r\nspin_unlock_bh(&pn->all_channels_lock);\r\npch->file.dead = 1;\r\nwake_up_interruptible(&pch->file.rwait);\r\nif (atomic_dec_and_test(&pch->file.refcnt))\r\nppp_destroy_channel(pch);\r\n}\r\nvoid\r\nppp_output_wakeup(struct ppp_channel *chan)\r\n{\r\nstruct channel *pch = chan->ppp;\r\nif (!pch)\r\nreturn;\r\nppp_channel_push(pch);\r\n}\r\nstatic int\r\nppp_set_compress(struct ppp *ppp, unsigned long arg)\r\n{\r\nint err;\r\nstruct compressor *cp, *ocomp;\r\nstruct ppp_option_data data;\r\nvoid *state, *ostate;\r\nunsigned char ccp_option[CCP_MAX_OPTION_LENGTH];\r\nerr = -EFAULT;\r\nif (copy_from_user(&data, (void __user *) arg, sizeof(data)) ||\r\n(data.length <= CCP_MAX_OPTION_LENGTH &&\r\ncopy_from_user(ccp_option, (void __user *) data.ptr, data.length)))\r\ngoto out;\r\nerr = -EINVAL;\r\nif (data.length > CCP_MAX_OPTION_LENGTH ||\r\nccp_option[1] < 2 || ccp_option[1] > data.length)\r\ngoto out;\r\ncp = try_then_request_module(\r\nfind_compressor(ccp_option[0]),\r\n"ppp-compress-%d", ccp_option[0]);\r\nif (!cp)\r\ngoto out;\r\nerr = -ENOBUFS;\r\nif (data.transmit) {\r\nstate = cp->comp_alloc(ccp_option, data.length);\r\nif (state) {\r\nppp_xmit_lock(ppp);\r\nppp->xstate &= ~SC_COMP_RUN;\r\nocomp = ppp->xcomp;\r\nostate = ppp->xc_state;\r\nppp->xcomp = cp;\r\nppp->xc_state = state;\r\nppp_xmit_unlock(ppp);\r\nif (ostate) {\r\nocomp->comp_free(ostate);\r\nmodule_put(ocomp->owner);\r\n}\r\nerr = 0;\r\n} else\r\nmodule_put(cp->owner);\r\n} else {\r\nstate = cp->decomp_alloc(ccp_option, data.length);\r\nif (state) {\r\nppp_recv_lock(ppp);\r\nppp->rstate &= ~SC_DECOMP_RUN;\r\nocomp = ppp->rcomp;\r\nostate = ppp->rc_state;\r\nppp->rcomp = cp;\r\nppp->rc_state = state;\r\nppp_recv_unlock(ppp);\r\nif (ostate) {\r\nocomp->decomp_free(ostate);\r\nmodule_put(ocomp->owner);\r\n}\r\nerr = 0;\r\n} else\r\nmodule_put(cp->owner);\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic void\r\nppp_ccp_peek(struct ppp *ppp, struct sk_buff *skb, int inbound)\r\n{\r\nunsigned char *dp;\r\nint len;\r\nif (!pskb_may_pull(skb, CCP_HDRLEN + 2))\r\nreturn;\r\ndp = skb->data + 2;\r\nswitch (CCP_CODE(dp)) {\r\ncase CCP_CONFREQ:\r\nif(inbound)\r\nppp->xstate &= ~SC_COMP_RUN;\r\nelse\r\nppp->rstate &= ~SC_DECOMP_RUN;\r\nbreak;\r\ncase CCP_TERMREQ:\r\ncase CCP_TERMACK:\r\nppp->rstate &= ~SC_DECOMP_RUN;\r\nppp->xstate &= ~SC_COMP_RUN;\r\nbreak;\r\ncase CCP_CONFACK:\r\nif ((ppp->flags & (SC_CCP_OPEN | SC_CCP_UP)) != SC_CCP_OPEN)\r\nbreak;\r\nlen = CCP_LENGTH(dp);\r\nif (!pskb_may_pull(skb, len + 2))\r\nreturn;\r\ndp += CCP_HDRLEN;\r\nlen -= CCP_HDRLEN;\r\nif (len < CCP_OPT_MINLEN || len < CCP_OPT_LENGTH(dp))\r\nbreak;\r\nif (inbound) {\r\nif (!ppp->rc_state)\r\nbreak;\r\nif (ppp->rcomp->decomp_init(ppp->rc_state, dp, len,\r\nppp->file.index, 0, ppp->mru, ppp->debug)) {\r\nppp->rstate |= SC_DECOMP_RUN;\r\nppp->rstate &= ~(SC_DC_ERROR | SC_DC_FERROR);\r\n}\r\n} else {\r\nif (!ppp->xc_state)\r\nbreak;\r\nif (ppp->xcomp->comp_init(ppp->xc_state, dp, len,\r\nppp->file.index, 0, ppp->debug))\r\nppp->xstate |= SC_COMP_RUN;\r\n}\r\nbreak;\r\ncase CCP_RESETACK:\r\nif ((ppp->flags & SC_CCP_UP) == 0)\r\nbreak;\r\nif (inbound) {\r\nif (ppp->rc_state && (ppp->rstate & SC_DECOMP_RUN)) {\r\nppp->rcomp->decomp_reset(ppp->rc_state);\r\nppp->rstate &= ~SC_DC_ERROR;\r\n}\r\n} else {\r\nif (ppp->xc_state && (ppp->xstate & SC_COMP_RUN))\r\nppp->xcomp->comp_reset(ppp->xc_state);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nppp_ccp_closed(struct ppp *ppp)\r\n{\r\nvoid *xstate, *rstate;\r\nstruct compressor *xcomp, *rcomp;\r\nppp_lock(ppp);\r\nppp->flags &= ~(SC_CCP_OPEN | SC_CCP_UP);\r\nppp->xstate = 0;\r\nxcomp = ppp->xcomp;\r\nxstate = ppp->xc_state;\r\nppp->xc_state = NULL;\r\nppp->rstate = 0;\r\nrcomp = ppp->rcomp;\r\nrstate = ppp->rc_state;\r\nppp->rc_state = NULL;\r\nppp_unlock(ppp);\r\nif (xstate) {\r\nxcomp->comp_free(xstate);\r\nmodule_put(xcomp->owner);\r\n}\r\nif (rstate) {\r\nrcomp->decomp_free(rstate);\r\nmodule_put(rcomp->owner);\r\n}\r\n}\r\nstatic struct compressor_entry *\r\nfind_comp_entry(int proto)\r\n{\r\nstruct compressor_entry *ce;\r\nlist_for_each_entry(ce, &compressor_list, list) {\r\nif (ce->comp->compress_proto == proto)\r\nreturn ce;\r\n}\r\nreturn NULL;\r\n}\r\nint\r\nppp_register_compressor(struct compressor *cp)\r\n{\r\nstruct compressor_entry *ce;\r\nint ret;\r\nspin_lock(&compressor_list_lock);\r\nret = -EEXIST;\r\nif (find_comp_entry(cp->compress_proto))\r\ngoto out;\r\nret = -ENOMEM;\r\nce = kmalloc(sizeof(struct compressor_entry), GFP_ATOMIC);\r\nif (!ce)\r\ngoto out;\r\nret = 0;\r\nce->comp = cp;\r\nlist_add(&ce->list, &compressor_list);\r\nout:\r\nspin_unlock(&compressor_list_lock);\r\nreturn ret;\r\n}\r\nvoid\r\nppp_unregister_compressor(struct compressor *cp)\r\n{\r\nstruct compressor_entry *ce;\r\nspin_lock(&compressor_list_lock);\r\nce = find_comp_entry(cp->compress_proto);\r\nif (ce && ce->comp == cp) {\r\nlist_del(&ce->list);\r\nkfree(ce);\r\n}\r\nspin_unlock(&compressor_list_lock);\r\n}\r\nstatic struct compressor *\r\nfind_compressor(int type)\r\n{\r\nstruct compressor_entry *ce;\r\nstruct compressor *cp = NULL;\r\nspin_lock(&compressor_list_lock);\r\nce = find_comp_entry(type);\r\nif (ce) {\r\ncp = ce->comp;\r\nif (!try_module_get(cp->owner))\r\ncp = NULL;\r\n}\r\nspin_unlock(&compressor_list_lock);\r\nreturn cp;\r\n}\r\nstatic void\r\nppp_get_stats(struct ppp *ppp, struct ppp_stats *st)\r\n{\r\nstruct slcompress *vj = ppp->vj;\r\nmemset(st, 0, sizeof(*st));\r\nst->p.ppp_ipackets = ppp->stats64.rx_packets;\r\nst->p.ppp_ierrors = ppp->dev->stats.rx_errors;\r\nst->p.ppp_ibytes = ppp->stats64.rx_bytes;\r\nst->p.ppp_opackets = ppp->stats64.tx_packets;\r\nst->p.ppp_oerrors = ppp->dev->stats.tx_errors;\r\nst->p.ppp_obytes = ppp->stats64.tx_bytes;\r\nif (!vj)\r\nreturn;\r\nst->vj.vjs_packets = vj->sls_o_compressed + vj->sls_o_uncompressed;\r\nst->vj.vjs_compressed = vj->sls_o_compressed;\r\nst->vj.vjs_searches = vj->sls_o_searches;\r\nst->vj.vjs_misses = vj->sls_o_misses;\r\nst->vj.vjs_errorin = vj->sls_i_error;\r\nst->vj.vjs_tossed = vj->sls_i_tossed;\r\nst->vj.vjs_uncompressedin = vj->sls_i_uncompressed;\r\nst->vj.vjs_compressedin = vj->sls_i_compressed;\r\n}\r\nstatic struct ppp *\r\nppp_create_interface(struct net *net, int unit, int *retp)\r\n{\r\nstruct ppp *ppp;\r\nstruct ppp_net *pn;\r\nstruct net_device *dev = NULL;\r\nint ret = -ENOMEM;\r\nint i;\r\ndev = alloc_netdev(sizeof(struct ppp), "", ppp_setup);\r\nif (!dev)\r\ngoto out1;\r\npn = ppp_pernet(net);\r\nppp = netdev_priv(dev);\r\nppp->dev = dev;\r\nppp->mru = PPP_MRU;\r\ninit_ppp_file(&ppp->file, INTERFACE);\r\nppp->file.hdrlen = PPP_HDRLEN - 2;\r\nfor (i = 0; i < NUM_NP; ++i)\r\nppp->npmode[i] = NPMODE_PASS;\r\nINIT_LIST_HEAD(&ppp->channels);\r\nspin_lock_init(&ppp->rlock);\r\nspin_lock_init(&ppp->wlock);\r\n#ifdef CONFIG_PPP_MULTILINK\r\nppp->minseq = -1;\r\nskb_queue_head_init(&ppp->mrq);\r\n#endif\r\ndev_net_set(dev, net);\r\nmutex_lock(&pn->all_ppp_mutex);\r\nif (unit < 0) {\r\nunit = unit_get(&pn->units_idr, ppp);\r\nif (unit < 0) {\r\nret = unit;\r\ngoto out2;\r\n}\r\n} else {\r\nret = -EEXIST;\r\nif (unit_find(&pn->units_idr, unit))\r\ngoto out2;\r\nunit = unit_set(&pn->units_idr, ppp, unit);\r\nif (unit < 0)\r\ngoto out2;\r\n}\r\nppp->file.index = unit;\r\nsprintf(dev->name, "ppp%d", unit);\r\nret = register_netdev(dev);\r\nif (ret != 0) {\r\nunit_put(&pn->units_idr, unit);\r\nnetdev_err(ppp->dev, "PPP: couldn't register device %s (%d)\n",\r\ndev->name, ret);\r\ngoto out2;\r\n}\r\nppp->ppp_net = net;\r\natomic_inc(&ppp_unit_count);\r\nmutex_unlock(&pn->all_ppp_mutex);\r\n*retp = 0;\r\nreturn ppp;\r\nout2:\r\nmutex_unlock(&pn->all_ppp_mutex);\r\nfree_netdev(dev);\r\nout1:\r\n*retp = ret;\r\nreturn NULL;\r\n}\r\nstatic void\r\ninit_ppp_file(struct ppp_file *pf, int kind)\r\n{\r\npf->kind = kind;\r\nskb_queue_head_init(&pf->xq);\r\nskb_queue_head_init(&pf->rq);\r\natomic_set(&pf->refcnt, 1);\r\ninit_waitqueue_head(&pf->rwait);\r\n}\r\nstatic void ppp_shutdown_interface(struct ppp *ppp)\r\n{\r\nstruct ppp_net *pn;\r\npn = ppp_pernet(ppp->ppp_net);\r\nmutex_lock(&pn->all_ppp_mutex);\r\nppp_lock(ppp);\r\nif (!ppp->closing) {\r\nppp->closing = 1;\r\nppp_unlock(ppp);\r\nunregister_netdev(ppp->dev);\r\nunit_put(&pn->units_idr, ppp->file.index);\r\n} else\r\nppp_unlock(ppp);\r\nppp->file.dead = 1;\r\nppp->owner = NULL;\r\nwake_up_interruptible(&ppp->file.rwait);\r\nmutex_unlock(&pn->all_ppp_mutex);\r\n}\r\nstatic void ppp_destroy_interface(struct ppp *ppp)\r\n{\r\natomic_dec(&ppp_unit_count);\r\nif (!ppp->file.dead || ppp->n_channels) {\r\nnetdev_err(ppp->dev, "ppp: destroying ppp struct %p "\r\n"but dead=%d n_channels=%d !\n",\r\nppp, ppp->file.dead, ppp->n_channels);\r\nreturn;\r\n}\r\nppp_ccp_closed(ppp);\r\nif (ppp->vj) {\r\nslhc_free(ppp->vj);\r\nppp->vj = NULL;\r\n}\r\nskb_queue_purge(&ppp->file.xq);\r\nskb_queue_purge(&ppp->file.rq);\r\n#ifdef CONFIG_PPP_MULTILINK\r\nskb_queue_purge(&ppp->mrq);\r\n#endif\r\n#ifdef CONFIG_PPP_FILTER\r\nkfree(ppp->pass_filter);\r\nppp->pass_filter = NULL;\r\nkfree(ppp->active_filter);\r\nppp->active_filter = NULL;\r\n#endif\r\nkfree_skb(ppp->xmit_pending);\r\nfree_netdev(ppp->dev);\r\n}\r\nstatic struct ppp *\r\nppp_find_unit(struct ppp_net *pn, int unit)\r\n{\r\nreturn unit_find(&pn->units_idr, unit);\r\n}\r\nstatic struct channel *\r\nppp_find_channel(struct ppp_net *pn, int unit)\r\n{\r\nstruct channel *pch;\r\nlist_for_each_entry(pch, &pn->new_channels, list) {\r\nif (pch->file.index == unit) {\r\nlist_move(&pch->list, &pn->all_channels);\r\nreturn pch;\r\n}\r\n}\r\nlist_for_each_entry(pch, &pn->all_channels, list) {\r\nif (pch->file.index == unit)\r\nreturn pch;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\nppp_connect_channel(struct channel *pch, int unit)\r\n{\r\nstruct ppp *ppp;\r\nstruct ppp_net *pn;\r\nint ret = -ENXIO;\r\nint hdrlen;\r\npn = ppp_pernet(pch->chan_net);\r\nmutex_lock(&pn->all_ppp_mutex);\r\nppp = ppp_find_unit(pn, unit);\r\nif (!ppp)\r\ngoto out;\r\nwrite_lock_bh(&pch->upl);\r\nret = -EINVAL;\r\nif (pch->ppp)\r\ngoto outl;\r\nppp_lock(ppp);\r\nif (pch->file.hdrlen > ppp->file.hdrlen)\r\nppp->file.hdrlen = pch->file.hdrlen;\r\nhdrlen = pch->file.hdrlen + 2;\r\nif (hdrlen > ppp->dev->hard_header_len)\r\nppp->dev->hard_header_len = hdrlen;\r\nlist_add_tail(&pch->clist, &ppp->channels);\r\n++ppp->n_channels;\r\npch->ppp = ppp;\r\natomic_inc(&ppp->file.refcnt);\r\nppp_unlock(ppp);\r\nret = 0;\r\noutl:\r\nwrite_unlock_bh(&pch->upl);\r\nout:\r\nmutex_unlock(&pn->all_ppp_mutex);\r\nreturn ret;\r\n}\r\nstatic int\r\nppp_disconnect_channel(struct channel *pch)\r\n{\r\nstruct ppp *ppp;\r\nint err = -EINVAL;\r\nwrite_lock_bh(&pch->upl);\r\nppp = pch->ppp;\r\npch->ppp = NULL;\r\nwrite_unlock_bh(&pch->upl);\r\nif (ppp) {\r\nppp_lock(ppp);\r\nlist_del(&pch->clist);\r\nif (--ppp->n_channels == 0)\r\nwake_up_interruptible(&ppp->file.rwait);\r\nppp_unlock(ppp);\r\nif (atomic_dec_and_test(&ppp->file.refcnt))\r\nppp_destroy_interface(ppp);\r\nerr = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic void ppp_destroy_channel(struct channel *pch)\r\n{\r\natomic_dec(&channel_count);\r\nif (!pch->file.dead) {\r\npr_err("ppp: destroying undead channel %p !\n", pch);\r\nreturn;\r\n}\r\nskb_queue_purge(&pch->file.xq);\r\nskb_queue_purge(&pch->file.rq);\r\nkfree(pch);\r\n}\r\nstatic void __exit ppp_cleanup(void)\r\n{\r\nif (atomic_read(&ppp_unit_count) || atomic_read(&channel_count))\r\npr_err("PPP: removing module but units remain!\n");\r\nunregister_chrdev(PPP_MAJOR, "ppp");\r\ndevice_destroy(ppp_class, MKDEV(PPP_MAJOR, 0));\r\nclass_destroy(ppp_class);\r\nunregister_pernet_device(&ppp_net_ops);\r\n}\r\nstatic int unit_set(struct idr *p, void *ptr, int n)\r\n{\r\nint unit;\r\nunit = idr_alloc(p, ptr, n, n + 1, GFP_KERNEL);\r\nif (unit == -ENOSPC)\r\nunit = -EINVAL;\r\nreturn unit;\r\n}\r\nstatic int unit_get(struct idr *p, void *ptr)\r\n{\r\nreturn idr_alloc(p, ptr, 0, 0, GFP_KERNEL);\r\n}\r\nstatic void unit_put(struct idr *p, int n)\r\n{\r\nidr_remove(p, n);\r\n}\r\nstatic void *unit_find(struct idr *p, int n)\r\n{\r\nreturn idr_find(p, n);\r\n}
