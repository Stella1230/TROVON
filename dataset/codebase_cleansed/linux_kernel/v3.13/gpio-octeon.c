static unsigned int bit_cfg_reg(unsigned int offset)\r\n{\r\nif (offset < 16)\r\nreturn 8 * offset;\r\nelse\r\nreturn 8 * (offset - 16) + 0x100;\r\n}\r\nstatic int octeon_gpio_dir_in(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct octeon_gpio *gpio = container_of(chip, struct octeon_gpio, chip);\r\ncvmx_write_csr(gpio->register_base + bit_cfg_reg(offset), 0);\r\nreturn 0;\r\n}\r\nstatic void octeon_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct octeon_gpio *gpio = container_of(chip, struct octeon_gpio, chip);\r\nu64 mask = 1ull << offset;\r\nu64 reg = gpio->register_base + (value ? TX_SET : TX_CLEAR);\r\ncvmx_write_csr(reg, mask);\r\n}\r\nstatic int octeon_gpio_dir_out(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nstruct octeon_gpio *gpio = container_of(chip, struct octeon_gpio, chip);\r\nunion cvmx_gpio_bit_cfgx cfgx;\r\nocteon_gpio_set(chip, offset, value);\r\ncfgx.u64 = 0;\r\ncfgx.s.tx_oe = 1;\r\ncvmx_write_csr(gpio->register_base + bit_cfg_reg(offset), cfgx.u64);\r\nreturn 0;\r\n}\r\nstatic int octeon_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct octeon_gpio *gpio = container_of(chip, struct octeon_gpio, chip);\r\nu64 read_bits = cvmx_read_csr(gpio->register_base + RX_DAT);\r\nreturn ((1ull << offset) & read_bits) != 0;\r\n}\r\nstatic int octeon_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct octeon_gpio *gpio;\r\nstruct gpio_chip *chip;\r\nstruct resource *res_mem;\r\nint err = 0;\r\ngpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);\r\nif (!gpio)\r\nreturn -ENOMEM;\r\nchip = &gpio->chip;\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res_mem == NULL) {\r\ndev_err(&pdev->dev, "found no memory resource\n");\r\nerr = -ENXIO;\r\ngoto out;\r\n}\r\nif (!devm_request_mem_region(&pdev->dev, res_mem->start,\r\nresource_size(res_mem),\r\nres_mem->name)) {\r\ndev_err(&pdev->dev, "request_mem_region failed\n");\r\nerr = -ENXIO;\r\ngoto out;\r\n}\r\ngpio->register_base = (u64)devm_ioremap(&pdev->dev, res_mem->start,\r\nresource_size(res_mem));\r\npdev->dev.platform_data = chip;\r\nchip->label = "octeon-gpio";\r\nchip->dev = &pdev->dev;\r\nchip->owner = THIS_MODULE;\r\nchip->base = 0;\r\nchip->can_sleep = 0;\r\nchip->ngpio = 20;\r\nchip->direction_input = octeon_gpio_dir_in;\r\nchip->get = octeon_gpio_get;\r\nchip->direction_output = octeon_gpio_dir_out;\r\nchip->set = octeon_gpio_set;\r\nerr = gpiochip_add(chip);\r\nif (err)\r\ngoto out;\r\ndev_info(&pdev->dev, "OCTEON GPIO driver probed.\n");\r\nout:\r\nreturn err;\r\n}\r\nstatic int octeon_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct gpio_chip *chip = pdev->dev.platform_data;\r\nreturn gpiochip_remove(chip);\r\n}
