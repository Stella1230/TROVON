static inline struct hppfs_inode_info *HPPFS_I(struct inode *inode)\r\n{\r\nreturn container_of(inode, struct hppfs_inode_info, vfs_inode);\r\n}\r\nstatic int is_pid(struct dentry *dentry)\r\n{\r\nstruct super_block *sb;\r\nint i;\r\nsb = dentry->d_sb;\r\nif (dentry->d_parent != sb->s_root)\r\nreturn 0;\r\nfor (i = 0; i < dentry->d_name.len; i++) {\r\nif (!isdigit(dentry->d_name.name[i]))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic char *dentry_name(struct dentry *dentry, int extra)\r\n{\r\nstruct dentry *parent;\r\nchar *root, *name;\r\nconst char *seg_name;\r\nint len, seg_len, root_len;\r\nlen = 0;\r\nparent = dentry;\r\nwhile (parent->d_parent != parent) {\r\nif (is_pid(parent))\r\nlen += strlen("pid") + 1;\r\nelse len += parent->d_name.len + 1;\r\nparent = parent->d_parent;\r\n}\r\nroot = "proc";\r\nroot_len = strlen(root);\r\nlen += root_len;\r\nname = kmalloc(len + extra + 1, GFP_KERNEL);\r\nif (name == NULL)\r\nreturn NULL;\r\nname[len] = '\0';\r\nparent = dentry;\r\nwhile (parent->d_parent != parent) {\r\nif (is_pid(parent)) {\r\nseg_name = "pid";\r\nseg_len = strlen(seg_name);\r\n}\r\nelse {\r\nseg_name = parent->d_name.name;\r\nseg_len = parent->d_name.len;\r\n}\r\nlen -= seg_len + 1;\r\nname[len] = '/';\r\nmemcpy(&name[len + 1], seg_name, seg_len);\r\nparent = parent->d_parent;\r\n}\r\nmemcpy(name, root, root_len);\r\nreturn name;\r\n}\r\nstatic int file_removed(struct dentry *dentry, const char *file)\r\n{\r\nchar *host_file;\r\nint extra, fd;\r\nextra = 0;\r\nif (file != NULL)\r\nextra += strlen(file) + 1;\r\nhost_file = dentry_name(dentry, extra + strlen("/remove"));\r\nif (host_file == NULL) {\r\nprintk(KERN_ERR "file_removed : allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nif (file != NULL) {\r\nstrcat(host_file, "/");\r\nstrcat(host_file, file);\r\n}\r\nstrcat(host_file, "/remove");\r\nfd = os_open_file(host_file, of_read(OPENFLAGS()), 0);\r\nkfree(host_file);\r\nif (fd > 0) {\r\nos_close_file(fd);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct dentry *hppfs_lookup(struct inode *ino, struct dentry *dentry,\r\nunsigned int flags)\r\n{\r\nstruct dentry *proc_dentry, *parent;\r\nstruct qstr *name = &dentry->d_name;\r\nstruct inode *inode;\r\nint err, deleted;\r\ndeleted = file_removed(dentry, NULL);\r\nif (deleted < 0)\r\nreturn ERR_PTR(deleted);\r\nelse if (deleted)\r\nreturn ERR_PTR(-ENOENT);\r\nparent = HPPFS_I(ino)->proc_dentry;\r\nmutex_lock(&parent->d_inode->i_mutex);\r\nproc_dentry = lookup_one_len(name->name, parent, name->len);\r\nmutex_unlock(&parent->d_inode->i_mutex);\r\nif (IS_ERR(proc_dentry))\r\nreturn proc_dentry;\r\nerr = -ENOMEM;\r\ninode = get_inode(ino->i_sb, proc_dentry);\r\nif (!inode)\r\ngoto out;\r\nd_add(dentry, inode);\r\nreturn NULL;\r\nout:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic ssize_t read_proc(struct file *file, char __user *buf, ssize_t count,\r\nloff_t *ppos, int is_user)\r\n{\r\nssize_t (*read)(struct file *, char __user *, size_t, loff_t *);\r\nssize_t n;\r\nread = file_inode(file)->i_fop->read;\r\nif (!is_user)\r\nset_fs(KERNEL_DS);\r\nn = (*read)(file, buf, count, &file->f_pos);\r\nif (!is_user)\r\nset_fs(USER_DS);\r\nif (ppos)\r\n*ppos = file->f_pos;\r\nreturn n;\r\n}\r\nstatic ssize_t hppfs_read_file(int fd, char __user *buf, ssize_t count)\r\n{\r\nssize_t n;\r\nint cur, err;\r\nchar *new_buf;\r\nn = -ENOMEM;\r\nnew_buf = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (new_buf == NULL) {\r\nprintk(KERN_ERR "hppfs_read_file : kmalloc failed\n");\r\ngoto out;\r\n}\r\nn = 0;\r\nwhile (count > 0) {\r\ncur = min_t(ssize_t, count, PAGE_SIZE);\r\nerr = os_read_file(fd, new_buf, cur);\r\nif (err < 0) {\r\nprintk(KERN_ERR "hppfs_read : read failed, "\r\n"errno = %d\n", err);\r\nn = err;\r\ngoto out_free;\r\n} else if (err == 0)\r\nbreak;\r\nif (copy_to_user(buf, new_buf, err)) {\r\nn = -EFAULT;\r\ngoto out_free;\r\n}\r\nn += err;\r\ncount -= err;\r\n}\r\nout_free:\r\nkfree(new_buf);\r\nout:\r\nreturn n;\r\n}\r\nstatic ssize_t hppfs_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct hppfs_private *hppfs = file->private_data;\r\nstruct hppfs_data *data;\r\nloff_t off;\r\nint err;\r\nif (hppfs->contents != NULL) {\r\nint rem;\r\nif (*ppos >= hppfs->len)\r\nreturn 0;\r\ndata = hppfs->contents;\r\noff = *ppos;\r\nwhile (off >= sizeof(data->contents)) {\r\ndata = list_entry(data->list.next, struct hppfs_data,\r\nlist);\r\noff -= sizeof(data->contents);\r\n}\r\nif (off + count > hppfs->len)\r\ncount = hppfs->len - off;\r\nrem = copy_to_user(buf, &data->contents[off], count);\r\n*ppos += count - rem;\r\nif (rem > 0)\r\nreturn -EFAULT;\r\n} else if (hppfs->host_fd != -1) {\r\nerr = os_seek_file(hppfs->host_fd, *ppos);\r\nif (err) {\r\nprintk(KERN_ERR "hppfs_read : seek failed, "\r\n"errno = %d\n", err);\r\nreturn err;\r\n}\r\nerr = hppfs_read_file(hppfs->host_fd, buf, count);\r\nif (err < 0) {\r\nprintk(KERN_ERR "hppfs_read: read failed: %d\n", err);\r\nreturn err;\r\n}\r\ncount = err;\r\nif (count > 0)\r\n*ppos += count;\r\n}\r\nelse count = read_proc(hppfs->proc_file, buf, count, ppos, 1);\r\nreturn count;\r\n}\r\nstatic ssize_t hppfs_write(struct file *file, const char __user *buf,\r\nsize_t len, loff_t *ppos)\r\n{\r\nstruct hppfs_private *data = file->private_data;\r\nstruct file *proc_file = data->proc_file;\r\nssize_t (*write)(struct file *, const char __user *, size_t, loff_t *);\r\nwrite = file_inode(proc_file)->i_fop->write;\r\nreturn (*write)(proc_file, buf, len, ppos);\r\n}\r\nstatic int open_host_sock(char *host_file, int *filter_out)\r\n{\r\nchar *end;\r\nint fd;\r\nend = &host_file[strlen(host_file)];\r\nstrcpy(end, "/rw");\r\n*filter_out = 1;\r\nfd = os_connect_socket(host_file);\r\nif (fd > 0)\r\nreturn fd;\r\nstrcpy(end, "/r");\r\n*filter_out = 0;\r\nfd = os_connect_socket(host_file);\r\nreturn fd;\r\n}\r\nstatic void free_contents(struct hppfs_data *head)\r\n{\r\nstruct hppfs_data *data;\r\nstruct list_head *ele, *next;\r\nif (head == NULL)\r\nreturn;\r\nlist_for_each_safe(ele, next, &head->list) {\r\ndata = list_entry(ele, struct hppfs_data, list);\r\nkfree(data);\r\n}\r\nkfree(head);\r\n}\r\nstatic struct hppfs_data *hppfs_get_data(int fd, int filter,\r\nstruct file *proc_file,\r\nstruct file *hppfs_file,\r\nloff_t *size_out)\r\n{\r\nstruct hppfs_data *data, *new, *head;\r\nint n, err;\r\nerr = -ENOMEM;\r\ndata = kmalloc(sizeof(*data), GFP_KERNEL);\r\nif (data == NULL) {\r\nprintk(KERN_ERR "hppfs_get_data : head allocation failed\n");\r\ngoto failed;\r\n}\r\nINIT_LIST_HEAD(&data->list);\r\nhead = data;\r\n*size_out = 0;\r\nif (filter) {\r\nwhile ((n = read_proc(proc_file, data->contents,\r\nsizeof(data->contents), NULL, 0)) > 0)\r\nos_write_file(fd, data->contents, n);\r\nerr = os_shutdown_socket(fd, 0, 1);\r\nif (err) {\r\nprintk(KERN_ERR "hppfs_get_data : failed to shut down "\r\n"socket\n");\r\ngoto failed_free;\r\n}\r\n}\r\nwhile (1) {\r\nn = os_read_file(fd, data->contents, sizeof(data->contents));\r\nif (n < 0) {\r\nerr = n;\r\nprintk(KERN_ERR "hppfs_get_data : read failed, "\r\n"errno = %d\n", err);\r\ngoto failed_free;\r\n} else if (n == 0)\r\nbreak;\r\n*size_out += n;\r\nif (n < sizeof(data->contents))\r\nbreak;\r\nnew = kmalloc(sizeof(*data), GFP_KERNEL);\r\nif (new == 0) {\r\nprintk(KERN_ERR "hppfs_get_data : data allocation "\r\n"failed\n");\r\nerr = -ENOMEM;\r\ngoto failed_free;\r\n}\r\nINIT_LIST_HEAD(&new->list);\r\nlist_add(&new->list, &data->list);\r\ndata = new;\r\n}\r\nreturn head;\r\nfailed_free:\r\nfree_contents(head);\r\nfailed:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic struct hppfs_private *hppfs_data(void)\r\n{\r\nstruct hppfs_private *data;\r\ndata = kmalloc(sizeof(*data), GFP_KERNEL);\r\nif (data == NULL)\r\nreturn data;\r\n*data = ((struct hppfs_private ) { .host_fd = -1,\r\n.len = -1,\r\n.contents = NULL } );\r\nreturn data;\r\n}\r\nstatic int file_mode(int fmode)\r\n{\r\nif (fmode == (FMODE_READ | FMODE_WRITE))\r\nreturn O_RDWR;\r\nif (fmode == FMODE_READ)\r\nreturn O_RDONLY;\r\nif (fmode == FMODE_WRITE)\r\nreturn O_WRONLY;\r\nreturn 0;\r\n}\r\nstatic int hppfs_open(struct inode *inode, struct file *file)\r\n{\r\nconst struct cred *cred = file->f_cred;\r\nstruct hppfs_private *data;\r\nstruct path path;\r\nchar *host_file;\r\nint err, fd, type, filter;\r\nerr = -ENOMEM;\r\ndata = hppfs_data();\r\nif (data == NULL)\r\ngoto out;\r\nhost_file = dentry_name(file->f_path.dentry, strlen("/rw"));\r\nif (host_file == NULL)\r\ngoto out_free2;\r\npath.mnt = inode->i_sb->s_fs_info;\r\npath.dentry = HPPFS_I(inode)->proc_dentry;\r\ndata->proc_file = dentry_open(&path, file_mode(file->f_mode), cred);\r\nerr = PTR_ERR(data->proc_file);\r\nif (IS_ERR(data->proc_file))\r\ngoto out_free1;\r\ntype = os_file_type(host_file);\r\nif (type == OS_TYPE_FILE) {\r\nfd = os_open_file(host_file, of_read(OPENFLAGS()), 0);\r\nif (fd >= 0)\r\ndata->host_fd = fd;\r\nelse\r\nprintk(KERN_ERR "hppfs_open : failed to open '%s', "\r\n"errno = %d\n", host_file, -fd);\r\ndata->contents = NULL;\r\n} else if (type == OS_TYPE_DIR) {\r\nfd = open_host_sock(host_file, &filter);\r\nif (fd > 0) {\r\ndata->contents = hppfs_get_data(fd, filter,\r\ndata->proc_file,\r\nfile, &data->len);\r\nif (!IS_ERR(data->contents))\r\ndata->host_fd = fd;\r\n} else\r\nprintk(KERN_ERR "hppfs_open : failed to open a socket "\r\n"in '%s', errno = %d\n", host_file, -fd);\r\n}\r\nkfree(host_file);\r\nfile->private_data = data;\r\nreturn 0;\r\nout_free1:\r\nkfree(host_file);\r\nout_free2:\r\nfree_contents(data->contents);\r\nkfree(data);\r\nout:\r\nreturn err;\r\n}\r\nstatic int hppfs_dir_open(struct inode *inode, struct file *file)\r\n{\r\nconst struct cred *cred = file->f_cred;\r\nstruct hppfs_private *data;\r\nstruct path path;\r\nint err;\r\nerr = -ENOMEM;\r\ndata = hppfs_data();\r\nif (data == NULL)\r\ngoto out;\r\npath.mnt = inode->i_sb->s_fs_info;\r\npath.dentry = HPPFS_I(inode)->proc_dentry;\r\ndata->proc_file = dentry_open(&path, file_mode(file->f_mode), cred);\r\nerr = PTR_ERR(data->proc_file);\r\nif (IS_ERR(data->proc_file))\r\ngoto out_free;\r\nfile->private_data = data;\r\nreturn 0;\r\nout_free:\r\nkfree(data);\r\nout:\r\nreturn err;\r\n}\r\nstatic loff_t hppfs_llseek(struct file *file, loff_t off, int where)\r\n{\r\nstruct hppfs_private *data = file->private_data;\r\nstruct file *proc_file = data->proc_file;\r\nloff_t (*llseek)(struct file *, loff_t, int);\r\nloff_t ret;\r\nllseek = file_inode(proc_file)->i_fop->llseek;\r\nif (llseek != NULL) {\r\nret = (*llseek)(proc_file, off, where);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn default_llseek(file, off, where);\r\n}\r\nstatic int hppfs_release(struct inode *inode, struct file *file)\r\n{\r\nstruct hppfs_private *data = file->private_data;\r\nstruct file *proc_file = data->proc_file;\r\nif (proc_file)\r\nfput(proc_file);\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int hppfs_filldir(void *d, const char *name, int size,\r\nloff_t offset, u64 inode, unsigned int type)\r\n{\r\nstruct hppfs_dirent *dirent = d;\r\nif (file_removed(dirent->dentry, name))\r\nreturn 0;\r\ndirent->caller->pos = dirent->ctx.pos;\r\nreturn !dir_emit(dirent->caller, name, size, inode, type);\r\n}\r\nstatic int hppfs_readdir(struct file *file, struct dir_context *ctx)\r\n{\r\nstruct hppfs_private *data = file->private_data;\r\nstruct file *proc_file = data->proc_file;\r\nstruct hppfs_dirent d = {\r\n.ctx.actor = hppfs_filldir,\r\n.caller = ctx,\r\n.dentry = file->f_path.dentry\r\n};\r\nint err;\r\nproc_file->f_pos = ctx->pos;\r\nerr = iterate_dir(proc_file, &d.ctx);\r\nctx->pos = d.ctx.pos;\r\nreturn err;\r\n}\r\nstatic int hppfs_statfs(struct dentry *dentry, struct kstatfs *sf)\r\n{\r\nsf->f_blocks = 0;\r\nsf->f_bfree = 0;\r\nsf->f_bavail = 0;\r\nsf->f_files = 0;\r\nsf->f_ffree = 0;\r\nsf->f_type = HPPFS_SUPER_MAGIC;\r\nreturn 0;\r\n}\r\nstatic struct inode *hppfs_alloc_inode(struct super_block *sb)\r\n{\r\nstruct hppfs_inode_info *hi;\r\nhi = kmalloc(sizeof(*hi), GFP_KERNEL);\r\nif (!hi)\r\nreturn NULL;\r\nhi->proc_dentry = NULL;\r\ninode_init_once(&hi->vfs_inode);\r\nreturn &hi->vfs_inode;\r\n}\r\nvoid hppfs_evict_inode(struct inode *ino)\r\n{\r\nclear_inode(ino);\r\ndput(HPPFS_I(ino)->proc_dentry);\r\nmntput(ino->i_sb->s_fs_info);\r\n}\r\nstatic void hppfs_i_callback(struct rcu_head *head)\r\n{\r\nstruct inode *inode = container_of(head, struct inode, i_rcu);\r\nkfree(HPPFS_I(inode));\r\n}\r\nstatic void hppfs_destroy_inode(struct inode *inode)\r\n{\r\ncall_rcu(&inode->i_rcu, hppfs_i_callback);\r\n}\r\nstatic int hppfs_readlink(struct dentry *dentry, char __user *buffer,\r\nint buflen)\r\n{\r\nstruct dentry *proc_dentry = HPPFS_I(dentry->d_inode)->proc_dentry;\r\nreturn proc_dentry->d_inode->i_op->readlink(proc_dentry, buffer,\r\nbuflen);\r\n}\r\nstatic void *hppfs_follow_link(struct dentry *dentry, struct nameidata *nd)\r\n{\r\nstruct dentry *proc_dentry = HPPFS_I(dentry->d_inode)->proc_dentry;\r\nreturn proc_dentry->d_inode->i_op->follow_link(proc_dentry, nd);\r\n}\r\nstatic void hppfs_put_link(struct dentry *dentry, struct nameidata *nd,\r\nvoid *cookie)\r\n{\r\nstruct dentry *proc_dentry = HPPFS_I(dentry->d_inode)->proc_dentry;\r\nif (proc_dentry->d_inode->i_op->put_link)\r\nproc_dentry->d_inode->i_op->put_link(proc_dentry, nd, cookie);\r\n}\r\nstatic struct inode *get_inode(struct super_block *sb, struct dentry *dentry)\r\n{\r\nstruct inode *proc_ino = dentry->d_inode;\r\nstruct inode *inode = new_inode(sb);\r\nif (!inode) {\r\ndput(dentry);\r\nreturn NULL;\r\n}\r\nif (S_ISDIR(dentry->d_inode->i_mode)) {\r\ninode->i_op = &hppfs_dir_iops;\r\ninode->i_fop = &hppfs_dir_fops;\r\n} else if (S_ISLNK(dentry->d_inode->i_mode)) {\r\ninode->i_op = &hppfs_link_iops;\r\ninode->i_fop = &hppfs_file_fops;\r\n} else {\r\ninode->i_op = &hppfs_file_iops;\r\ninode->i_fop = &hppfs_file_fops;\r\n}\r\nHPPFS_I(inode)->proc_dentry = dentry;\r\ninode->i_uid = proc_ino->i_uid;\r\ninode->i_gid = proc_ino->i_gid;\r\ninode->i_atime = proc_ino->i_atime;\r\ninode->i_mtime = proc_ino->i_mtime;\r\ninode->i_ctime = proc_ino->i_ctime;\r\ninode->i_ino = proc_ino->i_ino;\r\ninode->i_mode = proc_ino->i_mode;\r\nset_nlink(inode, proc_ino->i_nlink);\r\ninode->i_size = proc_ino->i_size;\r\ninode->i_blocks = proc_ino->i_blocks;\r\nreturn inode;\r\n}\r\nstatic int hppfs_fill_super(struct super_block *sb, void *d, int silent)\r\n{\r\nstruct inode *root_inode;\r\nstruct vfsmount *proc_mnt;\r\nint err = -ENOENT;\r\nproc_mnt = mntget(task_active_pid_ns(current)->proc_mnt);\r\nif (IS_ERR(proc_mnt))\r\ngoto out;\r\nsb->s_blocksize = 1024;\r\nsb->s_blocksize_bits = 10;\r\nsb->s_magic = HPPFS_SUPER_MAGIC;\r\nsb->s_op = &hppfs_sbops;\r\nsb->s_fs_info = proc_mnt;\r\nerr = -ENOMEM;\r\nroot_inode = get_inode(sb, dget(proc_mnt->mnt_root));\r\nsb->s_root = d_make_root(root_inode);\r\nif (!sb->s_root)\r\ngoto out_mntput;\r\nreturn 0;\r\nout_mntput:\r\nmntput(proc_mnt);\r\nout:\r\nreturn(err);\r\n}\r\nstatic struct dentry *hppfs_read_super(struct file_system_type *type,\r\nint flags, const char *dev_name,\r\nvoid *data)\r\n{\r\nreturn mount_nodev(type, flags, data, hppfs_fill_super);\r\n}\r\nstatic int __init init_hppfs(void)\r\n{\r\nreturn register_filesystem(&hppfs_type);\r\n}\r\nstatic void __exit exit_hppfs(void)\r\n{\r\nunregister_filesystem(&hppfs_type);\r\n}
