struct cleancache_ops *cleancache_register_ops(struct cleancache_ops *ops)\r\n{\r\nstruct cleancache_ops *old = cleancache_ops;\r\nint i;\r\nmutex_lock(&poolid_mutex);\r\nfor (i = 0; i < MAX_INITIALIZABLE_FS; i++) {\r\nif (fs_poolid_map[i] == FS_NO_BACKEND)\r\nfs_poolid_map[i] = ops->init_fs(PAGE_SIZE);\r\nif (shared_fs_poolid_map[i] == FS_NO_BACKEND)\r\nshared_fs_poolid_map[i] = ops->init_shared_fs\r\n(uuids[i], PAGE_SIZE);\r\n}\r\nbarrier();\r\ncleancache_ops = ops;\r\nmutex_unlock(&poolid_mutex);\r\nreturn old;\r\n}\r\nvoid __cleancache_init_fs(struct super_block *sb)\r\n{\r\nint i;\r\nmutex_lock(&poolid_mutex);\r\nfor (i = 0; i < MAX_INITIALIZABLE_FS; i++) {\r\nif (fs_poolid_map[i] == FS_UNKNOWN) {\r\nsb->cleancache_poolid = i + FAKE_FS_POOLID_OFFSET;\r\nif (cleancache_ops)\r\nfs_poolid_map[i] = cleancache_ops->init_fs(PAGE_SIZE);\r\nelse\r\nfs_poolid_map[i] = FS_NO_BACKEND;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&poolid_mutex);\r\n}\r\nvoid __cleancache_init_shared_fs(char *uuid, struct super_block *sb)\r\n{\r\nint i;\r\nmutex_lock(&poolid_mutex);\r\nfor (i = 0; i < MAX_INITIALIZABLE_FS; i++) {\r\nif (shared_fs_poolid_map[i] == FS_UNKNOWN) {\r\nsb->cleancache_poolid = i + FAKE_SHARED_FS_POOLID_OFFSET;\r\nuuids[i] = uuid;\r\nif (cleancache_ops)\r\nshared_fs_poolid_map[i] = cleancache_ops->init_shared_fs\r\n(uuid, PAGE_SIZE);\r\nelse\r\nshared_fs_poolid_map[i] = FS_NO_BACKEND;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&poolid_mutex);\r\n}\r\nstatic int cleancache_get_key(struct inode *inode,\r\nstruct cleancache_filekey *key)\r\n{\r\nint (*fhfn)(struct inode *, __u32 *fh, int *, struct inode *);\r\nint len = 0, maxlen = CLEANCACHE_KEY_MAX;\r\nstruct super_block *sb = inode->i_sb;\r\nkey->u.ino = inode->i_ino;\r\nif (sb->s_export_op != NULL) {\r\nfhfn = sb->s_export_op->encode_fh;\r\nif (fhfn) {\r\nlen = (*fhfn)(inode, &key->u.fh[0], &maxlen, NULL);\r\nif (len <= FILEID_ROOT || len == FILEID_INVALID)\r\nreturn -1;\r\nif (maxlen > CLEANCACHE_KEY_MAX)\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_poolid_from_fake(int fake_pool_id)\r\n{\r\nif (fake_pool_id >= FAKE_SHARED_FS_POOLID_OFFSET)\r\nreturn shared_fs_poolid_map[fake_pool_id -\r\nFAKE_SHARED_FS_POOLID_OFFSET];\r\nelse if (fake_pool_id >= FAKE_FS_POOLID_OFFSET)\r\nreturn fs_poolid_map[fake_pool_id - FAKE_FS_POOLID_OFFSET];\r\nreturn FS_NO_BACKEND;\r\n}\r\nint __cleancache_get_page(struct page *page)\r\n{\r\nint ret = -1;\r\nint pool_id;\r\nint fake_pool_id;\r\nstruct cleancache_filekey key = { .u.key = { 0 } };\r\nif (!cleancache_ops) {\r\ncleancache_failed_gets++;\r\ngoto out;\r\n}\r\nVM_BUG_ON(!PageLocked(page));\r\nfake_pool_id = page->mapping->host->i_sb->cleancache_poolid;\r\nif (fake_pool_id < 0)\r\ngoto out;\r\npool_id = get_poolid_from_fake(fake_pool_id);\r\nif (cleancache_get_key(page->mapping->host, &key) < 0)\r\ngoto out;\r\nif (pool_id >= 0)\r\nret = cleancache_ops->get_page(pool_id,\r\nkey, page->index, page);\r\nif (ret == 0)\r\ncleancache_succ_gets++;\r\nelse\r\ncleancache_failed_gets++;\r\nout:\r\nreturn ret;\r\n}\r\nvoid __cleancache_put_page(struct page *page)\r\n{\r\nint pool_id;\r\nint fake_pool_id;\r\nstruct cleancache_filekey key = { .u.key = { 0 } };\r\nif (!cleancache_ops) {\r\ncleancache_puts++;\r\nreturn;\r\n}\r\nVM_BUG_ON(!PageLocked(page));\r\nfake_pool_id = page->mapping->host->i_sb->cleancache_poolid;\r\nif (fake_pool_id < 0)\r\nreturn;\r\npool_id = get_poolid_from_fake(fake_pool_id);\r\nif (pool_id >= 0 &&\r\ncleancache_get_key(page->mapping->host, &key) >= 0) {\r\ncleancache_ops->put_page(pool_id, key, page->index, page);\r\ncleancache_puts++;\r\n}\r\n}\r\nvoid __cleancache_invalidate_page(struct address_space *mapping,\r\nstruct page *page)\r\n{\r\nint pool_id;\r\nint fake_pool_id = mapping->host->i_sb->cleancache_poolid;\r\nstruct cleancache_filekey key = { .u.key = { 0 } };\r\nif (!cleancache_ops)\r\nreturn;\r\nif (fake_pool_id >= 0) {\r\npool_id = get_poolid_from_fake(fake_pool_id);\r\nif (pool_id < 0)\r\nreturn;\r\nVM_BUG_ON(!PageLocked(page));\r\nif (cleancache_get_key(mapping->host, &key) >= 0) {\r\ncleancache_ops->invalidate_page(pool_id,\r\nkey, page->index);\r\ncleancache_invalidates++;\r\n}\r\n}\r\n}\r\nvoid __cleancache_invalidate_inode(struct address_space *mapping)\r\n{\r\nint pool_id;\r\nint fake_pool_id = mapping->host->i_sb->cleancache_poolid;\r\nstruct cleancache_filekey key = { .u.key = { 0 } };\r\nif (!cleancache_ops)\r\nreturn;\r\nif (fake_pool_id < 0)\r\nreturn;\r\npool_id = get_poolid_from_fake(fake_pool_id);\r\nif (pool_id >= 0 && cleancache_get_key(mapping->host, &key) >= 0)\r\ncleancache_ops->invalidate_inode(pool_id, key);\r\n}\r\nvoid __cleancache_invalidate_fs(struct super_block *sb)\r\n{\r\nint index;\r\nint fake_pool_id = sb->cleancache_poolid;\r\nint old_poolid = fake_pool_id;\r\nmutex_lock(&poolid_mutex);\r\nif (fake_pool_id >= FAKE_SHARED_FS_POOLID_OFFSET) {\r\nindex = fake_pool_id - FAKE_SHARED_FS_POOLID_OFFSET;\r\nold_poolid = shared_fs_poolid_map[index];\r\nshared_fs_poolid_map[index] = FS_UNKNOWN;\r\nuuids[index] = NULL;\r\n} else if (fake_pool_id >= FAKE_FS_POOLID_OFFSET) {\r\nindex = fake_pool_id - FAKE_FS_POOLID_OFFSET;\r\nold_poolid = fs_poolid_map[index];\r\nfs_poolid_map[index] = FS_UNKNOWN;\r\n}\r\nsb->cleancache_poolid = -1;\r\nif (cleancache_ops)\r\ncleancache_ops->invalidate_fs(old_poolid);\r\nmutex_unlock(&poolid_mutex);\r\n}\r\nstatic int __init init_cleancache(void)\r\n{\r\nint i;\r\n#ifdef CONFIG_DEBUG_FS\r\nstruct dentry *root = debugfs_create_dir("cleancache", NULL);\r\nif (root == NULL)\r\nreturn -ENXIO;\r\ndebugfs_create_u64("succ_gets", S_IRUGO, root, &cleancache_succ_gets);\r\ndebugfs_create_u64("failed_gets", S_IRUGO,\r\nroot, &cleancache_failed_gets);\r\ndebugfs_create_u64("puts", S_IRUGO, root, &cleancache_puts);\r\ndebugfs_create_u64("invalidates", S_IRUGO,\r\nroot, &cleancache_invalidates);\r\n#endif\r\nfor (i = 0; i < MAX_INITIALIZABLE_FS; i++) {\r\nfs_poolid_map[i] = FS_UNKNOWN;\r\nshared_fs_poolid_map[i] = FS_UNKNOWN;\r\n}\r\nreturn 0;\r\n}
