static void camif_cfg_video_path(struct camif_vp *vp)\r\n{\r\nWARN_ON(s3c_camif_get_scaler_config(vp, &vp->scaler));\r\ncamif_hw_set_scaler(vp);\r\ncamif_hw_set_flip(vp);\r\ncamif_hw_set_target_format(vp);\r\ncamif_hw_set_output_dma(vp);\r\n}\r\nstatic void camif_prepare_dma_offset(struct camif_vp *vp)\r\n{\r\nstruct camif_frame *f = &vp->out_frame;\r\nf->dma_offset.initial = f->rect.top * f->f_width + f->rect.left;\r\nf->dma_offset.line = f->f_width - (f->rect.left + f->rect.width);\r\npr_debug("dma_offset: initial: %d, line: %d\n",\r\nf->dma_offset.initial, f->dma_offset.line);\r\n}\r\nstatic int s3c_camif_hw_init(struct camif_dev *camif, struct camif_vp *vp)\r\n{\r\nconst struct s3c_camif_variant *variant = camif->variant;\r\nif (camif->sensor.sd == NULL || vp->out_fmt == NULL)\r\nreturn -EINVAL;\r\nif (variant->ip_revision == S3C244X_CAMIF_IP_REV)\r\ncamif_hw_clear_fifo_overflow(vp);\r\ncamif_hw_set_camera_bus(camif);\r\ncamif_hw_set_source_format(camif);\r\ncamif_hw_set_camera_crop(camif);\r\ncamif_hw_set_test_pattern(camif, camif->test_pattern);\r\nif (variant->has_img_effect)\r\ncamif_hw_set_effect(camif, camif->colorfx,\r\ncamif->colorfx_cb, camif->colorfx_cr);\r\nif (variant->ip_revision == S3C6410_CAMIF_IP_REV)\r\ncamif_hw_set_input_path(vp);\r\ncamif_cfg_video_path(vp);\r\nvp->state &= ~ST_VP_CONFIG;\r\nreturn 0;\r\n}\r\nstatic int s3c_camif_hw_vp_init(struct camif_dev *camif, struct camif_vp *vp)\r\n{\r\nunsigned int ip_rev = camif->variant->ip_revision;\r\nif (vp->out_fmt == NULL)\r\nreturn -EINVAL;\r\ncamif_prepare_dma_offset(vp);\r\nif (ip_rev == S3C244X_CAMIF_IP_REV)\r\ncamif_hw_clear_fifo_overflow(vp);\r\ncamif_cfg_video_path(vp);\r\nvp->state &= ~ST_VP_CONFIG;\r\nreturn 0;\r\n}\r\nstatic int sensor_set_power(struct camif_dev *camif, int on)\r\n{\r\nstruct cam_sensor *sensor = &camif->sensor;\r\nint err = 0;\r\nif (!on == camif->sensor.power_count)\r\nerr = v4l2_subdev_call(sensor->sd, core, s_power, on);\r\nif (!err)\r\nsensor->power_count += on ? 1 : -1;\r\npr_debug("on: %d, power_count: %d, err: %d\n",\r\non, sensor->power_count, err);\r\nreturn err;\r\n}\r\nstatic int sensor_set_streaming(struct camif_dev *camif, int on)\r\n{\r\nstruct cam_sensor *sensor = &camif->sensor;\r\nint err = 0;\r\nif (!on == camif->sensor.stream_count)\r\nerr = v4l2_subdev_call(sensor->sd, video, s_stream, on);\r\nif (!err)\r\nsensor->stream_count += on ? 1 : -1;\r\npr_debug("on: %d, stream_count: %d, err: %d\n",\r\non, sensor->stream_count, err);\r\nreturn err;\r\n}\r\nstatic int camif_reinitialize(struct camif_vp *vp)\r\n{\r\nstruct camif_dev *camif = vp->camif;\r\nstruct camif_buffer *buf;\r\nunsigned long flags;\r\nbool streaming;\r\nspin_lock_irqsave(&camif->slock, flags);\r\nstreaming = vp->state & ST_VP_SENSOR_STREAMING;\r\nvp->state &= ~(ST_VP_PENDING | ST_VP_RUNNING | ST_VP_OFF |\r\nST_VP_ABORTING | ST_VP_STREAMING |\r\nST_VP_SENSOR_STREAMING | ST_VP_LASTIRQ);\r\nwhile (!list_empty(&vp->pending_buf_q)) {\r\nbuf = camif_pending_queue_pop(vp);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\n}\r\nwhile (!list_empty(&vp->active_buf_q)) {\r\nbuf = camif_active_queue_pop(vp);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&camif->slock, flags);\r\nif (!streaming)\r\nreturn 0;\r\nreturn sensor_set_streaming(camif, 0);\r\n}\r\nstatic bool s3c_vp_active(struct camif_vp *vp)\r\n{\r\nstruct camif_dev *camif = vp->camif;\r\nunsigned long flags;\r\nbool ret;\r\nspin_lock_irqsave(&camif->slock, flags);\r\nret = (vp->state & ST_VP_RUNNING) || (vp->state & ST_VP_PENDING);\r\nspin_unlock_irqrestore(&camif->slock, flags);\r\nreturn ret;\r\n}\r\nstatic bool camif_is_streaming(struct camif_dev *camif)\r\n{\r\nunsigned long flags;\r\nbool status;\r\nspin_lock_irqsave(&camif->slock, flags);\r\nstatus = camif->stream_count > 0;\r\nspin_unlock_irqrestore(&camif->slock, flags);\r\nreturn status;\r\n}\r\nstatic int camif_stop_capture(struct camif_vp *vp)\r\n{\r\nstruct camif_dev *camif = vp->camif;\r\nunsigned long flags;\r\nint ret;\r\nif (!s3c_vp_active(vp))\r\nreturn 0;\r\nspin_lock_irqsave(&camif->slock, flags);\r\nvp->state &= ~(ST_VP_OFF | ST_VP_LASTIRQ);\r\nvp->state |= ST_VP_ABORTING;\r\nspin_unlock_irqrestore(&camif->slock, flags);\r\nret = wait_event_timeout(vp->irq_queue,\r\n!(vp->state & ST_VP_ABORTING),\r\nmsecs_to_jiffies(CAMIF_STOP_TIMEOUT));\r\nspin_lock_irqsave(&camif->slock, flags);\r\nif (ret == 0 && !(vp->state & ST_VP_OFF)) {\r\nvp->state &= ~(ST_VP_OFF | ST_VP_ABORTING |\r\nST_VP_LASTIRQ);\r\ncamif_hw_disable_capture(vp);\r\ncamif_hw_enable_scaler(vp, false);\r\n}\r\nspin_unlock_irqrestore(&camif->slock, flags);\r\nreturn camif_reinitialize(vp);\r\n}\r\nstatic int camif_prepare_addr(struct camif_vp *vp, struct vb2_buffer *vb,\r\nstruct camif_addr *paddr)\r\n{\r\nstruct camif_frame *frame = &vp->out_frame;\r\nu32 pix_size;\r\nif (vb == NULL || frame == NULL)\r\nreturn -EINVAL;\r\npix_size = frame->rect.width * frame->rect.height;\r\npr_debug("colplanes: %d, pix_size: %u\n",\r\nvp->out_fmt->colplanes, pix_size);\r\npaddr->y = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nswitch (vp->out_fmt->colplanes) {\r\ncase 1:\r\npaddr->cb = 0;\r\npaddr->cr = 0;\r\nbreak;\r\ncase 2:\r\npaddr->cb = (u32)(paddr->y + pix_size);\r\npaddr->cr = 0;\r\nbreak;\r\ncase 3:\r\npaddr->cb = (u32)(paddr->y + pix_size);\r\nif (vp->out_fmt->color == IMG_FMT_YCBCR422P)\r\npaddr->cr = (u32)(paddr->cb + (pix_size >> 1));\r\nelse\r\npaddr->cr = (u32)(paddr->cb + (pix_size >> 2));\r\nif (vp->out_fmt->color == IMG_FMT_YCRCB420)\r\nswap(paddr->cb, paddr->cr);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npr_debug("DMA address: y: %#x cb: %#x cr: %#x\n",\r\npaddr->y, paddr->cb, paddr->cr);\r\nreturn 0;\r\n}\r\nirqreturn_t s3c_camif_irq_handler(int irq, void *priv)\r\n{\r\nstruct camif_vp *vp = priv;\r\nstruct camif_dev *camif = vp->camif;\r\nunsigned int ip_rev = camif->variant->ip_revision;\r\nunsigned int status;\r\nspin_lock(&camif->slock);\r\nif (ip_rev == S3C6410_CAMIF_IP_REV)\r\ncamif_hw_clear_pending_irq(vp);\r\nstatus = camif_hw_get_status(vp);\r\nif (ip_rev == S3C244X_CAMIF_IP_REV && (status & CISTATUS_OVF_MASK)) {\r\ncamif_hw_clear_fifo_overflow(vp);\r\ngoto unlock;\r\n}\r\nif (vp->state & ST_VP_ABORTING) {\r\nif (vp->state & ST_VP_OFF) {\r\nvp->state &= ~(ST_VP_OFF | ST_VP_ABORTING |\r\nST_VP_LASTIRQ);\r\nwake_up(&vp->irq_queue);\r\ngoto unlock;\r\n} else if (vp->state & ST_VP_LASTIRQ) {\r\ncamif_hw_disable_capture(vp);\r\ncamif_hw_enable_scaler(vp, false);\r\ncamif_hw_set_lastirq(vp, false);\r\nvp->state |= ST_VP_OFF;\r\n} else {\r\ncamif_hw_set_lastirq(vp, true);\r\nvp->state |= ST_VP_LASTIRQ;\r\n}\r\n}\r\nif (!list_empty(&vp->pending_buf_q) && (vp->state & ST_VP_RUNNING) &&\r\n!list_empty(&vp->active_buf_q)) {\r\nunsigned int index;\r\nstruct camif_buffer *vbuf;\r\nstruct timeval *tv;\r\nstruct timespec ts;\r\nindex = (CISTATUS_FRAMECNT(status) + 2) & 1;\r\nktime_get_ts(&ts);\r\nvbuf = camif_active_queue_peek(vp, index);\r\nif (!WARN_ON(vbuf == NULL)) {\r\ntv = &vbuf->vb.v4l2_buf.timestamp;\r\ntv->tv_sec = ts.tv_sec;\r\ntv->tv_usec = ts.tv_nsec / NSEC_PER_USEC;\r\nvbuf->vb.v4l2_buf.sequence = vp->frame_sequence++;\r\nvb2_buffer_done(&vbuf->vb, VB2_BUF_STATE_DONE);\r\nvbuf = camif_pending_queue_pop(vp);\r\nvbuf->index = index;\r\ncamif_hw_set_output_addr(vp, &vbuf->paddr, index);\r\ncamif_hw_set_output_addr(vp, &vbuf->paddr, index + 2);\r\ncamif_active_queue_add(vp, vbuf);\r\n}\r\n} else if (!(vp->state & ST_VP_ABORTING) &&\r\n(vp->state & ST_VP_PENDING)) {\r\nvp->state |= ST_VP_RUNNING;\r\n}\r\nif (vp->state & ST_VP_CONFIG) {\r\ncamif_prepare_dma_offset(vp);\r\ncamif_hw_set_camera_crop(camif);\r\ncamif_hw_set_scaler(vp);\r\ncamif_hw_set_flip(vp);\r\ncamif_hw_set_test_pattern(camif, camif->test_pattern);\r\nif (camif->variant->has_img_effect)\r\ncamif_hw_set_effect(camif, camif->colorfx,\r\ncamif->colorfx_cb, camif->colorfx_cr);\r\nvp->state &= ~ST_VP_CONFIG;\r\n}\r\nunlock:\r\nspin_unlock(&camif->slock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct camif_vp *vp = vb2_get_drv_priv(vq);\r\nstruct camif_dev *camif = vp->camif;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&camif->slock, flags);\r\nif (camif->stream_count == 0) {\r\ncamif_hw_reset(camif);\r\nret = s3c_camif_hw_init(camif, vp);\r\n} else {\r\nret = s3c_camif_hw_vp_init(camif, vp);\r\n}\r\nspin_unlock_irqrestore(&camif->slock, flags);\r\nif (ret < 0) {\r\ncamif_reinitialize(vp);\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&camif->slock, flags);\r\nvp->frame_sequence = 0;\r\nvp->state |= ST_VP_PENDING;\r\nif (!list_empty(&vp->pending_buf_q) &&\r\n(!(vp->state & ST_VP_STREAMING) ||\r\n!(vp->state & ST_VP_SENSOR_STREAMING))) {\r\ncamif_hw_enable_scaler(vp, vp->scaler.enable);\r\ncamif_hw_enable_capture(vp);\r\nvp->state |= ST_VP_STREAMING;\r\nif (!(vp->state & ST_VP_SENSOR_STREAMING)) {\r\nvp->state |= ST_VP_SENSOR_STREAMING;\r\nspin_unlock_irqrestore(&camif->slock, flags);\r\nret = sensor_set_streaming(camif, 1);\r\nif (ret)\r\nv4l2_err(&vp->vdev, "Sensor s_stream failed\n");\r\nif (debug)\r\ncamif_hw_dump_regs(camif, __func__);\r\nreturn ret;\r\n}\r\n}\r\nspin_unlock_irqrestore(&camif->slock, flags);\r\nreturn 0;\r\n}\r\nstatic int stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct camif_vp *vp = vb2_get_drv_priv(vq);\r\nreturn camif_stop_capture(vp);\r\n}\r\nstatic int queue_setup(struct vb2_queue *vq, const struct v4l2_format *pfmt,\r\nunsigned int *num_buffers, unsigned int *num_planes,\r\nunsigned int sizes[], void *allocators[])\r\n{\r\nconst struct v4l2_pix_format *pix = NULL;\r\nstruct camif_vp *vp = vb2_get_drv_priv(vq);\r\nstruct camif_dev *camif = vp->camif;\r\nstruct camif_frame *frame = &vp->out_frame;\r\nconst struct camif_fmt *fmt = vp->out_fmt;\r\nunsigned int size;\r\nif (pfmt) {\r\npix = &pfmt->fmt.pix;\r\nfmt = s3c_camif_find_format(vp, &pix->pixelformat, -1);\r\nsize = (pix->width * pix->height * fmt->depth) / 8;\r\n} else {\r\nsize = (frame->f_width * frame->f_height * fmt->depth) / 8;\r\n}\r\nif (fmt == NULL)\r\nreturn -EINVAL;\r\n*num_planes = 1;\r\nif (pix)\r\nsizes[0] = max(size, pix->sizeimage);\r\nelse\r\nsizes[0] = size;\r\nallocators[0] = camif->alloc_ctx;\r\npr_debug("size: %u\n", sizes[0]);\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct camif_vp *vp = vb2_get_drv_priv(vb->vb2_queue);\r\nif (vp->out_fmt == NULL)\r\nreturn -EINVAL;\r\nif (vb2_plane_size(vb, 0) < vp->payload) {\r\nv4l2_err(&vp->vdev, "buffer too small: %lu, required: %u\n",\r\nvb2_plane_size(vb, 0), vp->payload);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, 0, vp->payload);\r\nreturn 0;\r\n}\r\nstatic void buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct camif_buffer *buf = container_of(vb, struct camif_buffer, vb);\r\nstruct camif_vp *vp = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct camif_dev *camif = vp->camif;\r\nunsigned long flags;\r\nspin_lock_irqsave(&camif->slock, flags);\r\nWARN_ON(camif_prepare_addr(vp, &buf->vb, &buf->paddr));\r\nif (!(vp->state & ST_VP_STREAMING) && vp->active_buffers < 2) {\r\nbuf->index = vp->buf_index;\r\ncamif_hw_set_output_addr(vp, &buf->paddr, buf->index);\r\ncamif_hw_set_output_addr(vp, &buf->paddr, buf->index + 2);\r\ncamif_active_queue_add(vp, buf);\r\nvp->buf_index = !vp->buf_index;\r\n} else {\r\ncamif_pending_queue_add(vp, buf);\r\n}\r\nif (vb2_is_streaming(&vp->vb_queue) && !list_empty(&vp->pending_buf_q)\r\n&& !(vp->state & ST_VP_STREAMING)) {\r\nvp->state |= ST_VP_STREAMING;\r\ncamif_hw_enable_scaler(vp, vp->scaler.enable);\r\ncamif_hw_enable_capture(vp);\r\nspin_unlock_irqrestore(&camif->slock, flags);\r\nif (!(vp->state & ST_VP_SENSOR_STREAMING)) {\r\nif (sensor_set_streaming(camif, 1) == 0)\r\nvp->state |= ST_VP_SENSOR_STREAMING;\r\nelse\r\nv4l2_err(&vp->vdev, "Sensor s_stream failed\n");\r\nif (debug)\r\ncamif_hw_dump_regs(camif, __func__);\r\n}\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&camif->slock, flags);\r\n}\r\nstatic void camif_lock(struct vb2_queue *vq)\r\n{\r\nstruct camif_vp *vp = vb2_get_drv_priv(vq);\r\nmutex_lock(&vp->camif->lock);\r\n}\r\nstatic void camif_unlock(struct vb2_queue *vq)\r\n{\r\nstruct camif_vp *vp = vb2_get_drv_priv(vq);\r\nmutex_unlock(&vp->camif->lock);\r\n}\r\nstatic int s3c_camif_open(struct file *file)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\nstruct camif_dev *camif = vp->camif;\r\nint ret;\r\npr_debug("[vp%d] state: %#x, owner: %p, pid: %d\n", vp->id,\r\nvp->state, vp->owner, task_pid_nr(current));\r\nif (mutex_lock_interruptible(&camif->lock))\r\nreturn -ERESTARTSYS;\r\nret = v4l2_fh_open(file);\r\nif (ret < 0)\r\ngoto unlock;\r\nret = pm_runtime_get_sync(camif->dev);\r\nif (ret < 0)\r\ngoto err_pm;\r\nret = sensor_set_power(camif, 1);\r\nif (!ret)\r\ngoto unlock;\r\npm_runtime_put(camif->dev);\r\nerr_pm:\r\nv4l2_fh_release(file);\r\nunlock:\r\nmutex_unlock(&camif->lock);\r\nreturn ret;\r\n}\r\nstatic int s3c_camif_close(struct file *file)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\nstruct camif_dev *camif = vp->camif;\r\nint ret;\r\npr_debug("[vp%d] state: %#x, owner: %p, pid: %d\n", vp->id,\r\nvp->state, vp->owner, task_pid_nr(current));\r\nmutex_lock(&camif->lock);\r\nif (vp->owner == file->private_data) {\r\ncamif_stop_capture(vp);\r\nvb2_queue_release(&vp->vb_queue);\r\nvp->owner = NULL;\r\n}\r\nsensor_set_power(camif, 0);\r\npm_runtime_put(camif->dev);\r\nret = v4l2_fh_release(file);\r\nmutex_unlock(&camif->lock);\r\nreturn ret;\r\n}\r\nstatic unsigned int s3c_camif_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\nstruct camif_dev *camif = vp->camif;\r\nint ret;\r\nmutex_lock(&camif->lock);\r\nif (vp->owner && vp->owner != file->private_data)\r\nret = -EBUSY;\r\nelse\r\nret = vb2_poll(&vp->vb_queue, file, wait);\r\nmutex_unlock(&camif->lock);\r\nreturn ret;\r\n}\r\nstatic int s3c_camif_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\nint ret;\r\nif (vp->owner && vp->owner != file->private_data)\r\nret = -EBUSY;\r\nelse\r\nret = vb2_mmap(&vp->vb_queue, vma);\r\nreturn ret;\r\n}\r\nstatic int s3c_camif_vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\nstrlcpy(cap->driver, S3C_CAMIF_DRIVER_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, S3C_CAMIF_DRIVER_NAME, sizeof(cap->card));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s.%d",\r\ndev_name(vp->camif->dev), vp->id);\r\ncap->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_CAPTURE;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int s3c_camif_vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *input)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\nstruct v4l2_subdev *sensor = vp->camif->sensor.sd;\r\nif (input->index || sensor == NULL)\r\nreturn -EINVAL;\r\ninput->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrlcpy(input->name, sensor->name, sizeof(input->name));\r\nreturn 0;\r\n}\r\nstatic int s3c_camif_vidioc_s_input(struct file *file, void *priv,\r\nunsigned int i)\r\n{\r\nreturn i == 0 ? 0 : -EINVAL;\r\n}\r\nstatic int s3c_camif_vidioc_g_input(struct file *file, void *priv,\r\nunsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int s3c_camif_vidioc_enum_fmt(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\nconst struct camif_fmt *fmt;\r\nfmt = s3c_camif_find_format(vp, NULL, f->index);\r\nif (!fmt)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, fmt->name, sizeof(f->description));\r\nf->pixelformat = fmt->fourcc;\r\npr_debug("fmt(%d): %s\n", f->index, f->description);\r\nreturn 0;\r\n}\r\nstatic int s3c_camif_vidioc_g_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct camif_frame *frame = &vp->out_frame;\r\nconst struct camif_fmt *fmt = vp->out_fmt;\r\npix->bytesperline = frame->f_width * fmt->ybpp;\r\npix->sizeimage = vp->payload;\r\npix->pixelformat = fmt->fourcc;\r\npix->width = frame->f_width;\r\npix->height = frame->f_height;\r\npix->field = V4L2_FIELD_NONE;\r\npix->colorspace = V4L2_COLORSPACE_JPEG;\r\nreturn 0;\r\n}\r\nstatic int __camif_video_try_format(struct camif_vp *vp,\r\nstruct v4l2_pix_format *pix,\r\nconst struct camif_fmt **ffmt)\r\n{\r\nstruct camif_dev *camif = vp->camif;\r\nstruct v4l2_rect *crop = &camif->camif_crop;\r\nunsigned int wmin, hmin, sc_hrmax, sc_vrmax;\r\nconst struct vp_pix_limits *pix_lim;\r\nconst struct camif_fmt *fmt;\r\nfmt = s3c_camif_find_format(vp, &pix->pixelformat, 0);\r\nif (WARN_ON(fmt == NULL))\r\nreturn -EINVAL;\r\nif (ffmt)\r\n*ffmt = fmt;\r\npix_lim = &camif->variant->vp_pix_limits[vp->id];\r\npr_debug("fmt: %ux%u, crop: %ux%u, bytesperline: %u\n",\r\npix->width, pix->height, crop->width, crop->height,\r\npix->bytesperline);\r\nsc_hrmax = min(SCALER_MAX_RATIO, 1 << (ffs(crop->width) - 3));\r\nsc_vrmax = min(SCALER_MAX_RATIO, 1 << (ffs(crop->height) - 1));\r\nwmin = max_t(u32, pix_lim->min_out_width, crop->width / sc_hrmax);\r\nwmin = round_up(wmin, pix_lim->out_width_align);\r\nhmin = max_t(u32, 8, crop->height / sc_vrmax);\r\nhmin = round_up(hmin, 8);\r\nv4l_bound_align_image(&pix->width, wmin, pix_lim->max_sc_out_width,\r\nffs(pix_lim->out_width_align) - 1,\r\n&pix->height, hmin, pix_lim->max_height, 0, 0);\r\npix->bytesperline = pix->width * fmt->ybpp;\r\npix->sizeimage = (pix->width * pix->height * fmt->depth) / 8;\r\npix->pixelformat = fmt->fourcc;\r\npix->colorspace = V4L2_COLORSPACE_JPEG;\r\npix->field = V4L2_FIELD_NONE;\r\npr_debug("%ux%u, wmin: %d, hmin: %d, sc_hrmax: %d, sc_vrmax: %d\n",\r\npix->width, pix->height, wmin, hmin, sc_hrmax, sc_vrmax);\r\nreturn 0;\r\n}\r\nstatic int s3c_camif_vidioc_try_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\nreturn __camif_video_try_format(vp, &f->fmt.pix, NULL);\r\n}\r\nstatic int s3c_camif_vidioc_s_fmt(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct camif_vp *vp = video_drvdata(file);\r\nstruct camif_frame *out_frame = &vp->out_frame;\r\nconst struct camif_fmt *fmt = NULL;\r\nint ret;\r\npr_debug("[vp%d]\n", vp->id);\r\nif (vb2_is_busy(&vp->vb_queue))\r\nreturn -EBUSY;\r\nret = __camif_video_try_format(vp, &f->fmt.pix, &fmt);\r\nif (ret < 0)\r\nreturn ret;\r\nvp->out_fmt = fmt;\r\nvp->payload = pix->sizeimage;\r\nout_frame->f_width = pix->width;\r\nout_frame->f_height = pix->height;\r\nout_frame->rect.width = pix->width;\r\nout_frame->rect.height = pix->height;\r\nout_frame->rect.left = 0;\r\nout_frame->rect.top = 0;\r\nif (vp->owner == NULL)\r\nvp->owner = priv;\r\npr_debug("%ux%u. payload: %u. fmt: %s. %d %d. sizeimage: %d. bpl: %d\n",\r\nout_frame->f_width, out_frame->f_height, vp->payload, fmt->name,\r\npix->width * pix->height * fmt->depth, fmt->depth,\r\npix->sizeimage, pix->bytesperline);\r\nreturn 0;\r\n}\r\nstatic int camif_pipeline_validate(struct camif_dev *camif)\r\n{\r\nstruct v4l2_subdev_format src_fmt;\r\nstruct media_pad *pad;\r\nint ret;\r\npad = media_entity_remote_pad(&camif->pads[0]);\r\nif (!pad || media_entity_type(pad->entity) != MEDIA_ENT_T_V4L2_SUBDEV)\r\nreturn -EPIPE;\r\nsrc_fmt.pad = pad->index;\r\nsrc_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nret = v4l2_subdev_call(camif->sensor.sd, pad, get_fmt, NULL, &src_fmt);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn -EPIPE;\r\nif (src_fmt.format.width != camif->mbus_fmt.width ||\r\nsrc_fmt.format.height != camif->mbus_fmt.height ||\r\nsrc_fmt.format.code != camif->mbus_fmt.code)\r\nreturn -EPIPE;\r\nreturn 0;\r\n}\r\nstatic int s3c_camif_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\nstruct camif_dev *camif = vp->camif;\r\nstruct media_entity *sensor = &camif->sensor.sd->entity;\r\nint ret;\r\npr_debug("[vp%d]\n", vp->id);\r\nif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (vp->owner && vp->owner != priv)\r\nreturn -EBUSY;\r\nif (s3c_vp_active(vp))\r\nreturn 0;\r\nret = media_entity_pipeline_start(sensor, camif->m_pipeline);\r\nif (ret < 0)\r\nreturn ret;\r\nret = camif_pipeline_validate(camif);\r\nif (ret < 0) {\r\nmedia_entity_pipeline_stop(sensor);\r\nreturn ret;\r\n}\r\nreturn vb2_streamon(&vp->vb_queue, type);\r\n}\r\nstatic int s3c_camif_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\nstruct camif_dev *camif = vp->camif;\r\nint ret;\r\npr_debug("[vp%d]\n", vp->id);\r\nif (type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif (vp->owner && vp->owner != priv)\r\nreturn -EBUSY;\r\nret = vb2_streamoff(&vp->vb_queue, type);\r\nif (ret == 0)\r\nmedia_entity_pipeline_stop(&camif->sensor.sd->entity);\r\nreturn ret;\r\n}\r\nstatic int s3c_camif_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\nint ret;\r\npr_debug("[vp%d] rb count: %d, owner: %p, priv: %p\n",\r\nvp->id, rb->count, vp->owner, priv);\r\nif (vp->owner && vp->owner != priv)\r\nreturn -EBUSY;\r\nif (rb->count)\r\nrb->count = max_t(u32, CAMIF_REQ_BUFS_MIN, rb->count);\r\nelse\r\nvp->owner = NULL;\r\nret = vb2_reqbufs(&vp->vb_queue, rb);\r\nif (ret < 0)\r\nreturn ret;\r\nif (rb->count && rb->count < CAMIF_REQ_BUFS_MIN) {\r\nrb->count = 0;\r\nvb2_reqbufs(&vp->vb_queue, rb);\r\nret = -ENOMEM;\r\n}\r\nvp->reqbufs_count = rb->count;\r\nif (vp->owner == NULL && rb->count > 0)\r\nvp->owner = priv;\r\nreturn ret;\r\n}\r\nstatic int s3c_camif_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\nreturn vb2_querybuf(&vp->vb_queue, buf);\r\n}\r\nstatic int s3c_camif_qbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\npr_debug("[vp%d]\n", vp->id);\r\nif (vp->owner && vp->owner != priv)\r\nreturn -EBUSY;\r\nreturn vb2_qbuf(&vp->vb_queue, buf);\r\n}\r\nstatic int s3c_camif_dqbuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\npr_debug("[vp%d] sequence: %d\n", vp->id, vp->frame_sequence);\r\nif (vp->owner && vp->owner != priv)\r\nreturn -EBUSY;\r\nreturn vb2_dqbuf(&vp->vb_queue, buf, file->f_flags & O_NONBLOCK);\r\n}\r\nstatic int s3c_camif_create_bufs(struct file *file, void *priv,\r\nstruct v4l2_create_buffers *create)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\nint ret;\r\nif (vp->owner && vp->owner != priv)\r\nreturn -EBUSY;\r\ncreate->count = max_t(u32, 1, create->count);\r\nret = vb2_create_bufs(&vp->vb_queue, create);\r\nif (!ret && vp->owner == NULL)\r\nvp->owner = priv;\r\nreturn ret;\r\n}\r\nstatic int s3c_camif_prepare_buf(struct file *file, void *priv,\r\nstruct v4l2_buffer *b)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\nreturn vb2_prepare_buf(&vp->vb_queue, b);\r\n}\r\nstatic int s3c_camif_g_selection(struct file *file, void *priv,\r\nstruct v4l2_selection *sel)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\nif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\nsel->r.width = vp->out_frame.f_width;\r\nsel->r.height = vp->out_frame.f_height;\r\nreturn 0;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\nsel->r = vp->out_frame.rect;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void __camif_try_compose(struct camif_dev *camif, struct camif_vp *vp,\r\nstruct v4l2_rect *r)\r\n{\r\nif (camif->variant->ip_revision == S3C244X_CAMIF_IP_REV) {\r\n*r = vp->out_frame.rect;\r\nreturn;\r\n}\r\n}\r\nstatic int s3c_camif_s_selection(struct file *file, void *priv,\r\nstruct v4l2_selection *sel)\r\n{\r\nstruct camif_vp *vp = video_drvdata(file);\r\nstruct camif_dev *camif = vp->camif;\r\nstruct v4l2_rect rect = sel->r;\r\nunsigned long flags;\r\nif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\r\nsel->target != V4L2_SEL_TGT_COMPOSE)\r\nreturn -EINVAL;\r\n__camif_try_compose(camif, vp, &rect);\r\nsel->r = rect;\r\nspin_lock_irqsave(&camif->slock, flags);\r\nvp->out_frame.rect = rect;\r\nvp->state |= ST_VP_CONFIG;\r\nspin_unlock_irqrestore(&camif->slock, flags);\r\npr_debug("type: %#x, target: %#x, flags: %#x, (%d,%d)/%dx%d\n",\r\nsel->type, sel->target, sel->flags,\r\nsel->r.left, sel->r.top, sel->r.width, sel->r.height);\r\nreturn 0;\r\n}\r\nstatic int s3c_camif_video_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct camif_vp *vp = ctrl->priv;\r\nstruct camif_dev *camif = vp->camif;\r\nunsigned long flags;\r\npr_debug("[vp%d] ctrl: %s, value: %d\n", vp->id,\r\nctrl->name, ctrl->val);\r\nspin_lock_irqsave(&camif->slock, flags);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_HFLIP:\r\nvp->hflip = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nvp->vflip = ctrl->val;\r\nbreak;\r\n}\r\nvp->state |= ST_VP_CONFIG;\r\nspin_unlock_irqrestore(&camif->slock, flags);\r\nreturn 0;\r\n}\r\nint s3c_camif_register_video_node(struct camif_dev *camif, int idx)\r\n{\r\nstruct camif_vp *vp = &camif->vp[idx];\r\nstruct vb2_queue *q = &vp->vb_queue;\r\nstruct video_device *vfd = &vp->vdev;\r\nstruct v4l2_ctrl *ctrl;\r\nint ret;\r\nmemset(vfd, 0, sizeof(*vfd));\r\nsnprintf(vfd->name, sizeof(vfd->name), "camif-%s",\r\nvp->id == 0 ? "codec" : "preview");\r\nvfd->fops = &s3c_camif_fops;\r\nvfd->ioctl_ops = &s3c_camif_ioctl_ops;\r\nvfd->v4l2_dev = &camif->v4l2_dev;\r\nvfd->minor = -1;\r\nvfd->release = video_device_release_empty;\r\nvfd->lock = &camif->lock;\r\nvp->reqbufs_count = 0;\r\nINIT_LIST_HEAD(&vp->pending_buf_q);\r\nINIT_LIST_HEAD(&vp->active_buf_q);\r\nmemset(q, 0, sizeof(*q));\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR;\r\nq->ops = &s3c_camif_qops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->buf_struct_size = sizeof(struct camif_buffer);\r\nq->drv_priv = vp;\r\nq->timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nret = vb2_queue_init(q);\r\nif (ret)\r\ngoto err_vd_rel;\r\nvp->pad.flags = MEDIA_PAD_FL_SINK;\r\nret = media_entity_init(&vfd->entity, 1, &vp->pad, 0);\r\nif (ret)\r\ngoto err_vd_rel;\r\nvideo_set_drvdata(vfd, vp);\r\nset_bit(V4L2_FL_USE_FH_PRIO, &vfd->flags);\r\nv4l2_ctrl_handler_init(&vp->ctrl_handler, 1);\r\nctrl = v4l2_ctrl_new_std(&vp->ctrl_handler, &s3c_camif_video_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nif (ctrl)\r\nctrl->priv = vp;\r\nctrl = v4l2_ctrl_new_std(&vp->ctrl_handler, &s3c_camif_video_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nif (ctrl)\r\nctrl->priv = vp;\r\nret = vp->ctrl_handler.error;\r\nif (ret < 0)\r\ngoto err_me_cleanup;\r\nvfd->ctrl_handler = &vp->ctrl_handler;\r\nret = video_register_device(vfd, VFL_TYPE_GRABBER, -1);\r\nif (ret)\r\ngoto err_ctrlh_free;\r\nv4l2_info(&camif->v4l2_dev, "registered %s as /dev/%s\n",\r\nvfd->name, video_device_node_name(vfd));\r\nreturn 0;\r\nerr_ctrlh_free:\r\nv4l2_ctrl_handler_free(&vp->ctrl_handler);\r\nerr_me_cleanup:\r\nmedia_entity_cleanup(&vfd->entity);\r\nerr_vd_rel:\r\nvideo_device_release(vfd);\r\nreturn ret;\r\n}\r\nvoid s3c_camif_unregister_video_node(struct camif_dev *camif, int idx)\r\n{\r\nstruct video_device *vfd = &camif->vp[idx].vdev;\r\nif (video_is_registered(vfd)) {\r\nvideo_unregister_device(vfd);\r\nmedia_entity_cleanup(&vfd->entity);\r\nv4l2_ctrl_handler_free(vfd->ctrl_handler);\r\n}\r\n}\r\nstatic int s3c_camif_subdev_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->index >= ARRAY_SIZE(camif_mbus_formats))\r\nreturn -EINVAL;\r\ncode->code = camif_mbus_formats[code->index];\r\nreturn 0;\r\n}\r\nstatic int s3c_camif_subdev_get_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct camif_dev *camif = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *mf = &fmt->format;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nmf = v4l2_subdev_get_try_format(fh, fmt->pad);\r\nfmt->format = *mf;\r\nreturn 0;\r\n}\r\nmutex_lock(&camif->lock);\r\nswitch (fmt->pad) {\r\ncase CAMIF_SD_PAD_SINK:\r\n*mf = camif->mbus_fmt;\r\nbreak;\r\ncase CAMIF_SD_PAD_SOURCE_C...CAMIF_SD_PAD_SOURCE_P:\r\nmf->width = camif->camif_crop.width;\r\nmf->height = camif->camif_crop.height;\r\nmf->code = camif->mbus_fmt.code;\r\nbreak;\r\n}\r\nmutex_unlock(&camif->lock);\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\nreturn 0;\r\n}\r\nstatic void __camif_subdev_try_format(struct camif_dev *camif,\r\nstruct v4l2_mbus_framefmt *mf, int pad)\r\n{\r\nconst struct s3c_camif_variant *variant = camif->variant;\r\nconst struct vp_pix_limits *pix_lim;\r\nint i = ARRAY_SIZE(camif_mbus_formats);\r\npix_lim = &variant->vp_pix_limits[VP_CODEC];\r\nwhile (i-- >= 0)\r\nif (camif_mbus_formats[i] == mf->code)\r\nbreak;\r\nmf->code = camif_mbus_formats[i];\r\nif (pad == CAMIF_SD_PAD_SINK) {\r\nv4l_bound_align_image(&mf->width, 8, CAMIF_MAX_PIX_WIDTH,\r\nffs(pix_lim->out_width_align) - 1,\r\n&mf->height, 8, CAMIF_MAX_PIX_HEIGHT, 0,\r\n0);\r\n} else {\r\nstruct v4l2_rect *crop = &camif->camif_crop;\r\nv4l_bound_align_image(&mf->width, 8, crop->width,\r\nffs(pix_lim->out_width_align) - 1,\r\n&mf->height, 8, crop->height,\r\n0, 0);\r\n}\r\nv4l2_dbg(1, debug, &camif->subdev, "%ux%u\n", mf->width, mf->height);\r\n}\r\nstatic int s3c_camif_subdev_set_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct camif_dev *camif = v4l2_get_subdevdata(sd);\r\nstruct v4l2_mbus_framefmt *mf = &fmt->format;\r\nstruct v4l2_rect *crop = &camif->camif_crop;\r\nint i;\r\nv4l2_dbg(1, debug, sd, "pad%d: code: 0x%x, %ux%u\n",\r\nfmt->pad, mf->code, mf->width, mf->height);\r\nmf->colorspace = V4L2_COLORSPACE_JPEG;\r\nmutex_lock(&camif->lock);\r\nif (vb2_is_busy(&camif->vp[VP_CODEC].vb_queue) ||\r\nvb2_is_busy(&camif->vp[VP_PREVIEW].vb_queue)) {\r\nmutex_unlock(&camif->lock);\r\nreturn -EBUSY;\r\n}\r\n__camif_subdev_try_format(camif, mf, fmt->pad);\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nmf = v4l2_subdev_get_try_format(fh, fmt->pad);\r\n*mf = fmt->format;\r\nmutex_unlock(&camif->lock);\r\nreturn 0;\r\n}\r\nswitch (fmt->pad) {\r\ncase CAMIF_SD_PAD_SINK:\r\ncamif->mbus_fmt = *mf;\r\ncrop->width = mf->width;\r\ncrop->height = mf->height;\r\ncrop->left = 0;\r\ncrop->top = 0;\r\nfor (i = 0; i < CAMIF_VP_NUM; i++) {\r\nstruct camif_frame *frame = &camif->vp[i].out_frame;\r\nframe->rect = *crop;\r\nframe->f_width = mf->width;\r\nframe->f_height = mf->height;\r\n}\r\nbreak;\r\ncase CAMIF_SD_PAD_SOURCE_C...CAMIF_SD_PAD_SOURCE_P:\r\nmf->code = camif->mbus_fmt.code;\r\nmf->width = crop->width;\r\nmf->height = crop->height;\r\nbreak;\r\n}\r\nmutex_unlock(&camif->lock);\r\nreturn 0;\r\n}\r\nstatic int s3c_camif_subdev_get_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct camif_dev *camif = v4l2_get_subdevdata(sd);\r\nstruct v4l2_rect *crop = &camif->camif_crop;\r\nstruct v4l2_mbus_framefmt *mf = &camif->mbus_fmt;\r\nif ((sel->target != V4L2_SEL_TGT_CROP &&\r\nsel->target != V4L2_SEL_TGT_CROP_BOUNDS) ||\r\nsel->pad != CAMIF_SD_PAD_SINK)\r\nreturn -EINVAL;\r\nif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nsel->r = *v4l2_subdev_get_try_crop(fh, sel->pad);\r\nreturn 0;\r\n}\r\nmutex_lock(&camif->lock);\r\nif (sel->target == V4L2_SEL_TGT_CROP) {\r\nsel->r = *crop;\r\n} else {\r\nsel->r.width = mf->width;\r\nsel->r.height = mf->height;\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\n}\r\nmutex_unlock(&camif->lock);\r\nv4l2_dbg(1, debug, sd, "%s: crop: (%d,%d) %dx%d, size: %ux%u\n",\r\n__func__, crop->left, crop->top, crop->width,\r\ncrop->height, mf->width, mf->height);\r\nreturn 0;\r\n}\r\nstatic void __camif_try_crop(struct camif_dev *camif, struct v4l2_rect *r)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = &camif->mbus_fmt;\r\nconst struct camif_pix_limits *pix_lim = &camif->variant->pix_limits;\r\nunsigned int left = 2 * r->left;\r\nunsigned int top = 2 * r->top;\r\nv4l_bound_align_image(&r->width, 0, mf->width,\r\nffs(pix_lim->win_hor_offset_align) - 1,\r\n&r->height, 0, mf->height, 1, 0);\r\nv4l_bound_align_image(&left, 0, mf->width - r->width,\r\nffs(pix_lim->win_hor_offset_align),\r\n&top, 0, mf->height - r->height, 2, 0);\r\nr->left = left / 2;\r\nr->top = top / 2;\r\nr->width = mf->width - left;\r\nr->height = mf->height - top;\r\nif (camif->variant->ip_revision == S3C244X_CAMIF_IP_REV &&\r\ncamif_is_streaming(camif)) {\r\nunsigned int i;\r\nfor (i = 0; i < CAMIF_VP_NUM; i++) {\r\nstruct v4l2_rect *or = &camif->vp[i].out_frame.rect;\r\nif ((or->width > r->width) == (or->height > r->height))\r\ncontinue;\r\n*r = camif->camif_crop;\r\npr_debug("Width/height scaling direction limitation\n");\r\nbreak;\r\n}\r\n}\r\nv4l2_dbg(1, debug, &camif->v4l2_dev, "crop: (%d,%d)/%dx%d, fmt: %ux%u\n",\r\nr->left, r->top, r->width, r->height, mf->width, mf->height);\r\n}\r\nstatic int s3c_camif_subdev_set_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct camif_dev *camif = v4l2_get_subdevdata(sd);\r\nstruct v4l2_rect *crop = &camif->camif_crop;\r\nstruct camif_scaler scaler;\r\nif (sel->target != V4L2_SEL_TGT_CROP || sel->pad != CAMIF_SD_PAD_SINK)\r\nreturn -EINVAL;\r\nmutex_lock(&camif->lock);\r\n__camif_try_crop(camif, &sel->r);\r\nif (sel->which == V4L2_SUBDEV_FORMAT_TRY) {\r\n*v4l2_subdev_get_try_crop(fh, sel->pad) = sel->r;\r\n} else {\r\nunsigned long flags;\r\nunsigned int i;\r\nspin_lock_irqsave(&camif->slock, flags);\r\n*crop = sel->r;\r\nfor (i = 0; i < CAMIF_VP_NUM; i++) {\r\nstruct camif_vp *vp = &camif->vp[i];\r\nscaler = vp->scaler;\r\nif (s3c_camif_get_scaler_config(vp, &scaler))\r\ncontinue;\r\nvp->scaler = scaler;\r\nvp->state |= ST_VP_CONFIG;\r\n}\r\nspin_unlock_irqrestore(&camif->slock, flags);\r\n}\r\nmutex_unlock(&camif->lock);\r\nv4l2_dbg(1, debug, sd, "%s: (%d,%d) %dx%d, f_w: %u, f_h: %u\n",\r\n__func__, crop->left, crop->top, crop->width, crop->height,\r\ncamif->mbus_fmt.width, camif->mbus_fmt.height);\r\nreturn 0;\r\n}\r\nstatic int s3c_camif_subdev_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct camif_dev *camif = container_of(ctrl->handler, struct camif_dev,\r\nctrl_handler);\r\nunsigned long flags;\r\nspin_lock_irqsave(&camif->slock, flags);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_COLORFX:\r\ncamif->colorfx = camif->ctrl_colorfx->val;\r\nswitch (ctrl->val) {\r\ncase V4L2_COLORFX_SEPIA:\r\ncamif->colorfx_cb = 115;\r\ncamif->colorfx_cr = 145;\r\nbreak;\r\ncase V4L2_COLORFX_SET_CBCR:\r\ncamif->colorfx_cb = camif->ctrl_colorfx_cbcr->val >> 8;\r\ncamif->colorfx_cr = camif->ctrl_colorfx_cbcr->val & 0xff;\r\nbreak;\r\ndefault:\r\ncamif->colorfx_cb = 128;\r\ncamif->colorfx_cr = 128;\r\n}\r\nbreak;\r\ncase V4L2_CID_TEST_PATTERN:\r\ncamif->test_pattern = camif->ctrl_test_pattern->val;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\n}\r\ncamif->vp[VP_CODEC].state |= ST_VP_CONFIG;\r\ncamif->vp[VP_PREVIEW].state |= ST_VP_CONFIG;\r\nspin_unlock_irqrestore(&camif->slock, flags);\r\nreturn 0;\r\n}\r\nint s3c_camif_create_subdev(struct camif_dev *camif)\r\n{\r\nstruct v4l2_ctrl_handler *handler = &camif->ctrl_handler;\r\nstruct v4l2_subdev *sd = &camif->subdev;\r\nint ret;\r\nv4l2_subdev_init(sd, &s3c_camif_subdev_ops);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nstrlcpy(sd->name, "S3C-CAMIF", sizeof(sd->name));\r\ncamif->pads[CAMIF_SD_PAD_SINK].flags = MEDIA_PAD_FL_SINK;\r\ncamif->pads[CAMIF_SD_PAD_SOURCE_C].flags = MEDIA_PAD_FL_SOURCE;\r\ncamif->pads[CAMIF_SD_PAD_SOURCE_P].flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_init(&sd->entity, CAMIF_SD_PADS_NUM,\r\ncamif->pads, 0);\r\nif (ret)\r\nreturn ret;\r\nv4l2_ctrl_handler_init(handler, 3);\r\ncamif->ctrl_test_pattern = v4l2_ctrl_new_std_menu_items(handler,\r\n&s3c_camif_subdev_ctrl_ops, V4L2_CID_TEST_PATTERN,\r\nARRAY_SIZE(s3c_camif_test_pattern_menu) - 1, 0, 0,\r\ns3c_camif_test_pattern_menu);\r\ncamif->ctrl_colorfx = v4l2_ctrl_new_std_menu(handler,\r\n&s3c_camif_subdev_ctrl_ops,\r\nV4L2_CID_COLORFX, V4L2_COLORFX_SET_CBCR,\r\n~0x981f, V4L2_COLORFX_NONE);\r\ncamif->ctrl_colorfx_cbcr = v4l2_ctrl_new_std(handler,\r\n&s3c_camif_subdev_ctrl_ops,\r\nV4L2_CID_COLORFX_CBCR, 0, 0xffff, 1, 0);\r\nif (handler->error) {\r\nv4l2_ctrl_handler_free(handler);\r\nmedia_entity_cleanup(&sd->entity);\r\nreturn handler->error;\r\n}\r\nv4l2_ctrl_auto_cluster(2, &camif->ctrl_colorfx,\r\nV4L2_COLORFX_SET_CBCR, false);\r\nif (!camif->variant->has_img_effect) {\r\ncamif->ctrl_colorfx->flags |= V4L2_CTRL_FLAG_DISABLED;\r\ncamif->ctrl_colorfx_cbcr->flags |= V4L2_CTRL_FLAG_DISABLED;\r\n}\r\nsd->ctrl_handler = handler;\r\nv4l2_set_subdevdata(sd, camif);\r\nreturn 0;\r\n}\r\nvoid s3c_camif_unregister_subdev(struct camif_dev *camif)\r\n{\r\nstruct v4l2_subdev *sd = &camif->subdev;\r\nif (v4l2_get_subdevdata(sd) == NULL)\r\nreturn;\r\nv4l2_device_unregister_subdev(sd);\r\nmedia_entity_cleanup(&sd->entity);\r\nv4l2_ctrl_handler_free(&camif->ctrl_handler);\r\nv4l2_set_subdevdata(sd, NULL);\r\n}\r\nint s3c_camif_set_defaults(struct camif_dev *camif)\r\n{\r\nunsigned int ip_rev = camif->variant->ip_revision;\r\nint i;\r\nfor (i = 0; i < CAMIF_VP_NUM; i++) {\r\nstruct camif_vp *vp = &camif->vp[i];\r\nstruct camif_frame *f = &vp->out_frame;\r\nvp->camif = camif;\r\nvp->id = i;\r\nvp->offset = camif->variant->vp_offset;\r\nif (ip_rev == S3C244X_CAMIF_IP_REV)\r\nvp->fmt_flags = i ? FMT_FL_S3C24XX_PREVIEW :\r\nFMT_FL_S3C24XX_CODEC;\r\nelse\r\nvp->fmt_flags = FMT_FL_S3C64XX;\r\nvp->out_fmt = s3c_camif_find_format(vp, NULL, 0);\r\nBUG_ON(vp->out_fmt == NULL);\r\nmemset(f, 0, sizeof(*f));\r\nf->f_width = CAMIF_DEF_WIDTH;\r\nf->f_height = CAMIF_DEF_HEIGHT;\r\nf->rect.width = CAMIF_DEF_WIDTH;\r\nf->rect.height = CAMIF_DEF_HEIGHT;\r\nvp->scaler.enable = 1;\r\nvp->payload = (f->f_width * f->f_height *\r\nvp->out_fmt->depth) / 8;\r\n}\r\nmemset(&camif->mbus_fmt, 0, sizeof(camif->mbus_fmt));\r\ncamif->mbus_fmt.width = CAMIF_DEF_WIDTH;\r\ncamif->mbus_fmt.height = CAMIF_DEF_HEIGHT;\r\ncamif->mbus_fmt.code = camif_mbus_formats[0];\r\nmemset(&camif->camif_crop, 0, sizeof(camif->camif_crop));\r\ncamif->camif_crop.width = CAMIF_DEF_WIDTH;\r\ncamif->camif_crop.height = CAMIF_DEF_HEIGHT;\r\nreturn 0;\r\n}
