static void plist_check_prev_next(struct list_head *t, struct list_head *p,\r\nstruct list_head *n)\r\n{\r\nWARN(n->prev != p || p->next != n,\r\n"top: %p, n: %p, p: %p\n"\r\n"prev: %p, n: %p, p: %p\n"\r\n"next: %p, n: %p, p: %p\n",\r\nt, t->next, t->prev,\r\np, p->next, p->prev,\r\nn, n->next, n->prev);\r\n}\r\nstatic void plist_check_list(struct list_head *top)\r\n{\r\nstruct list_head *prev = top, *next = top->next;\r\nplist_check_prev_next(top, prev, next);\r\nwhile (next != top) {\r\nprev = next;\r\nnext = prev->next;\r\nplist_check_prev_next(top, prev, next);\r\n}\r\n}\r\nstatic void plist_check_head(struct plist_head *head)\r\n{\r\nif (!plist_head_empty(head))\r\nplist_check_list(&plist_first(head)->prio_list);\r\nplist_check_list(&head->node_list);\r\n}\r\nvoid plist_add(struct plist_node *node, struct plist_head *head)\r\n{\r\nstruct plist_node *first, *iter, *prev = NULL;\r\nstruct list_head *node_next = &head->node_list;\r\nplist_check_head(head);\r\nWARN_ON(!plist_node_empty(node));\r\nWARN_ON(!list_empty(&node->prio_list));\r\nif (plist_head_empty(head))\r\ngoto ins_node;\r\nfirst = iter = plist_first(head);\r\ndo {\r\nif (node->prio < iter->prio) {\r\nnode_next = &iter->node_list;\r\nbreak;\r\n}\r\nprev = iter;\r\niter = list_entry(iter->prio_list.next,\r\nstruct plist_node, prio_list);\r\n} while (iter != first);\r\nif (!prev || prev->prio != node->prio)\r\nlist_add_tail(&node->prio_list, &iter->prio_list);\r\nins_node:\r\nlist_add_tail(&node->node_list, node_next);\r\nplist_check_head(head);\r\n}\r\nvoid plist_del(struct plist_node *node, struct plist_head *head)\r\n{\r\nplist_check_head(head);\r\nif (!list_empty(&node->prio_list)) {\r\nif (node->node_list.next != &head->node_list) {\r\nstruct plist_node *next;\r\nnext = list_entry(node->node_list.next,\r\nstruct plist_node, node_list);\r\nif (list_empty(&next->prio_list))\r\nlist_add(&next->prio_list, &node->prio_list);\r\n}\r\nlist_del_init(&node->prio_list);\r\n}\r\nlist_del_init(&node->node_list);\r\nplist_check_head(head);\r\n}\r\nstatic void __init plist_test_check(int nr_expect)\r\n{\r\nstruct plist_node *first, *prio_pos, *node_pos;\r\nif (plist_head_empty(&test_head)) {\r\nBUG_ON(nr_expect != 0);\r\nreturn;\r\n}\r\nprio_pos = first = plist_first(&test_head);\r\nplist_for_each(node_pos, &test_head) {\r\nif (nr_expect-- < 0)\r\nbreak;\r\nif (node_pos == first)\r\ncontinue;\r\nif (node_pos->prio == prio_pos->prio) {\r\nBUG_ON(!list_empty(&node_pos->prio_list));\r\ncontinue;\r\n}\r\nBUG_ON(prio_pos->prio > node_pos->prio);\r\nBUG_ON(prio_pos->prio_list.next != &node_pos->prio_list);\r\nprio_pos = node_pos;\r\n}\r\nBUG_ON(nr_expect != 0);\r\nBUG_ON(prio_pos->prio_list.next != &first->prio_list);\r\n}\r\nstatic int __init plist_test(void)\r\n{\r\nint nr_expect = 0, i, loop;\r\nunsigned int r = local_clock();\r\npr_debug("start plist test\n");\r\nplist_head_init(&test_head);\r\nfor (i = 0; i < ARRAY_SIZE(test_node); i++)\r\nplist_node_init(test_node + i, 0);\r\nfor (loop = 0; loop < 1000; loop++) {\r\nr = r * 193939 % 47629;\r\ni = r % ARRAY_SIZE(test_node);\r\nif (plist_node_empty(test_node + i)) {\r\nr = r * 193939 % 47629;\r\ntest_node[i].prio = r % 99;\r\nplist_add(test_node + i, &test_head);\r\nnr_expect++;\r\n} else {\r\nplist_del(test_node + i, &test_head);\r\nnr_expect--;\r\n}\r\nplist_test_check(nr_expect);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(test_node); i++) {\r\nif (plist_node_empty(test_node + i))\r\ncontinue;\r\nplist_del(test_node + i, &test_head);\r\nnr_expect--;\r\nplist_test_check(nr_expect);\r\n}\r\npr_debug("end plist test\n");\r\nreturn 0;\r\n}
