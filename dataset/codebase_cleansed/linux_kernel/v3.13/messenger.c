static bool con_flag_valid(unsigned long con_flag)\r\n{\r\nswitch (con_flag) {\r\ncase CON_FLAG_LOSSYTX:\r\ncase CON_FLAG_KEEPALIVE_PENDING:\r\ncase CON_FLAG_WRITE_PENDING:\r\ncase CON_FLAG_SOCK_CLOSED:\r\ncase CON_FLAG_BACKOFF:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic void con_flag_clear(struct ceph_connection *con, unsigned long con_flag)\r\n{\r\nBUG_ON(!con_flag_valid(con_flag));\r\nclear_bit(con_flag, &con->flags);\r\n}\r\nstatic void con_flag_set(struct ceph_connection *con, unsigned long con_flag)\r\n{\r\nBUG_ON(!con_flag_valid(con_flag));\r\nset_bit(con_flag, &con->flags);\r\n}\r\nstatic bool con_flag_test(struct ceph_connection *con, unsigned long con_flag)\r\n{\r\nBUG_ON(!con_flag_valid(con_flag));\r\nreturn test_bit(con_flag, &con->flags);\r\n}\r\nstatic bool con_flag_test_and_clear(struct ceph_connection *con,\r\nunsigned long con_flag)\r\n{\r\nBUG_ON(!con_flag_valid(con_flag));\r\nreturn test_and_clear_bit(con_flag, &con->flags);\r\n}\r\nstatic bool con_flag_test_and_set(struct ceph_connection *con,\r\nunsigned long con_flag)\r\n{\r\nBUG_ON(!con_flag_valid(con_flag));\r\nreturn test_and_set_bit(con_flag, &con->flags);\r\n}\r\nconst char *ceph_pr_addr(const struct sockaddr_storage *ss)\r\n{\r\nint i;\r\nchar *s;\r\nstruct sockaddr_in *in4 = (struct sockaddr_in *) ss;\r\nstruct sockaddr_in6 *in6 = (struct sockaddr_in6 *) ss;\r\ni = atomic_inc_return(&addr_str_seq) & ADDR_STR_COUNT_MASK;\r\ns = addr_str[i];\r\nswitch (ss->ss_family) {\r\ncase AF_INET:\r\nsnprintf(s, MAX_ADDR_STR_LEN, "%pI4:%hu", &in4->sin_addr,\r\nntohs(in4->sin_port));\r\nbreak;\r\ncase AF_INET6:\r\nsnprintf(s, MAX_ADDR_STR_LEN, "[%pI6c]:%hu", &in6->sin6_addr,\r\nntohs(in6->sin6_port));\r\nbreak;\r\ndefault:\r\nsnprintf(s, MAX_ADDR_STR_LEN, "(unknown sockaddr family %hu)",\r\nss->ss_family);\r\n}\r\nreturn s;\r\n}\r\nstatic void encode_my_addr(struct ceph_messenger *msgr)\r\n{\r\nmemcpy(&msgr->my_enc_addr, &msgr->inst.addr, sizeof(msgr->my_enc_addr));\r\nceph_encode_addr(&msgr->my_enc_addr);\r\n}\r\nstatic int ceph_msgr_slab_init(void)\r\n{\r\nBUG_ON(ceph_msg_cache);\r\nceph_msg_cache = kmem_cache_create("ceph_msg",\r\nsizeof (struct ceph_msg),\r\n__alignof__(struct ceph_msg), 0, NULL);\r\nif (!ceph_msg_cache)\r\nreturn -ENOMEM;\r\nBUG_ON(ceph_msg_data_cache);\r\nceph_msg_data_cache = kmem_cache_create("ceph_msg_data",\r\nsizeof (struct ceph_msg_data),\r\n__alignof__(struct ceph_msg_data),\r\n0, NULL);\r\nif (ceph_msg_data_cache)\r\nreturn 0;\r\nkmem_cache_destroy(ceph_msg_cache);\r\nceph_msg_cache = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic void ceph_msgr_slab_exit(void)\r\n{\r\nBUG_ON(!ceph_msg_data_cache);\r\nkmem_cache_destroy(ceph_msg_data_cache);\r\nceph_msg_data_cache = NULL;\r\nBUG_ON(!ceph_msg_cache);\r\nkmem_cache_destroy(ceph_msg_cache);\r\nceph_msg_cache = NULL;\r\n}\r\nstatic void _ceph_msgr_exit(void)\r\n{\r\nif (ceph_msgr_wq) {\r\ndestroy_workqueue(ceph_msgr_wq);\r\nceph_msgr_wq = NULL;\r\n}\r\nceph_msgr_slab_exit();\r\nBUG_ON(zero_page == NULL);\r\nkunmap(zero_page);\r\npage_cache_release(zero_page);\r\nzero_page = NULL;\r\n}\r\nint ceph_msgr_init(void)\r\n{\r\nBUG_ON(zero_page != NULL);\r\nzero_page = ZERO_PAGE(0);\r\npage_cache_get(zero_page);\r\nif (ceph_msgr_slab_init())\r\nreturn -ENOMEM;\r\nceph_msgr_wq = alloc_workqueue("ceph-msgr", 0, 0);\r\nif (ceph_msgr_wq)\r\nreturn 0;\r\npr_err("msgr_init failed to create workqueue\n");\r\n_ceph_msgr_exit();\r\nreturn -ENOMEM;\r\n}\r\nvoid ceph_msgr_exit(void)\r\n{\r\nBUG_ON(ceph_msgr_wq == NULL);\r\n_ceph_msgr_exit();\r\n}\r\nvoid ceph_msgr_flush(void)\r\n{\r\nflush_workqueue(ceph_msgr_wq);\r\n}\r\nstatic void con_sock_state_init(struct ceph_connection *con)\r\n{\r\nint old_state;\r\nold_state = atomic_xchg(&con->sock_state, CON_SOCK_STATE_CLOSED);\r\nif (WARN_ON(old_state != CON_SOCK_STATE_NEW))\r\nprintk("%s: unexpected old state %d\n", __func__, old_state);\r\ndout("%s con %p sock %d -> %d\n", __func__, con, old_state,\r\nCON_SOCK_STATE_CLOSED);\r\n}\r\nstatic void con_sock_state_connecting(struct ceph_connection *con)\r\n{\r\nint old_state;\r\nold_state = atomic_xchg(&con->sock_state, CON_SOCK_STATE_CONNECTING);\r\nif (WARN_ON(old_state != CON_SOCK_STATE_CLOSED))\r\nprintk("%s: unexpected old state %d\n", __func__, old_state);\r\ndout("%s con %p sock %d -> %d\n", __func__, con, old_state,\r\nCON_SOCK_STATE_CONNECTING);\r\n}\r\nstatic void con_sock_state_connected(struct ceph_connection *con)\r\n{\r\nint old_state;\r\nold_state = atomic_xchg(&con->sock_state, CON_SOCK_STATE_CONNECTED);\r\nif (WARN_ON(old_state != CON_SOCK_STATE_CONNECTING))\r\nprintk("%s: unexpected old state %d\n", __func__, old_state);\r\ndout("%s con %p sock %d -> %d\n", __func__, con, old_state,\r\nCON_SOCK_STATE_CONNECTED);\r\n}\r\nstatic void con_sock_state_closing(struct ceph_connection *con)\r\n{\r\nint old_state;\r\nold_state = atomic_xchg(&con->sock_state, CON_SOCK_STATE_CLOSING);\r\nif (WARN_ON(old_state != CON_SOCK_STATE_CONNECTING &&\r\nold_state != CON_SOCK_STATE_CONNECTED &&\r\nold_state != CON_SOCK_STATE_CLOSING))\r\nprintk("%s: unexpected old state %d\n", __func__, old_state);\r\ndout("%s con %p sock %d -> %d\n", __func__, con, old_state,\r\nCON_SOCK_STATE_CLOSING);\r\n}\r\nstatic void con_sock_state_closed(struct ceph_connection *con)\r\n{\r\nint old_state;\r\nold_state = atomic_xchg(&con->sock_state, CON_SOCK_STATE_CLOSED);\r\nif (WARN_ON(old_state != CON_SOCK_STATE_CONNECTED &&\r\nold_state != CON_SOCK_STATE_CLOSING &&\r\nold_state != CON_SOCK_STATE_CONNECTING &&\r\nold_state != CON_SOCK_STATE_CLOSED))\r\nprintk("%s: unexpected old state %d\n", __func__, old_state);\r\ndout("%s con %p sock %d -> %d\n", __func__, con, old_state,\r\nCON_SOCK_STATE_CLOSED);\r\n}\r\nstatic void ceph_sock_data_ready(struct sock *sk, int count_unused)\r\n{\r\nstruct ceph_connection *con = sk->sk_user_data;\r\nif (atomic_read(&con->msgr->stopping)) {\r\nreturn;\r\n}\r\nif (sk->sk_state != TCP_CLOSE_WAIT) {\r\ndout("%s on %p state = %lu, queueing work\n", __func__,\r\ncon, con->state);\r\nqueue_con(con);\r\n}\r\n}\r\nstatic void ceph_sock_write_space(struct sock *sk)\r\n{\r\nstruct ceph_connection *con = sk->sk_user_data;\r\nif (con_flag_test(con, CON_FLAG_WRITE_PENDING)) {\r\nif (sk_stream_is_writeable(sk)) {\r\ndout("%s %p queueing write work\n", __func__, con);\r\nclear_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\r\nqueue_con(con);\r\n}\r\n} else {\r\ndout("%s %p nothing to write\n", __func__, con);\r\n}\r\n}\r\nstatic void ceph_sock_state_change(struct sock *sk)\r\n{\r\nstruct ceph_connection *con = sk->sk_user_data;\r\ndout("%s %p state = %lu sk_state = %u\n", __func__,\r\ncon, con->state, sk->sk_state);\r\nswitch (sk->sk_state) {\r\ncase TCP_CLOSE:\r\ndout("%s TCP_CLOSE\n", __func__);\r\ncase TCP_CLOSE_WAIT:\r\ndout("%s TCP_CLOSE_WAIT\n", __func__);\r\ncon_sock_state_closing(con);\r\ncon_flag_set(con, CON_FLAG_SOCK_CLOSED);\r\nqueue_con(con);\r\nbreak;\r\ncase TCP_ESTABLISHED:\r\ndout("%s TCP_ESTABLISHED\n", __func__);\r\ncon_sock_state_connected(con);\r\nqueue_con(con);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void set_sock_callbacks(struct socket *sock,\r\nstruct ceph_connection *con)\r\n{\r\nstruct sock *sk = sock->sk;\r\nsk->sk_user_data = con;\r\nsk->sk_data_ready = ceph_sock_data_ready;\r\nsk->sk_write_space = ceph_sock_write_space;\r\nsk->sk_state_change = ceph_sock_state_change;\r\n}\r\nstatic int ceph_tcp_connect(struct ceph_connection *con)\r\n{\r\nstruct sockaddr_storage *paddr = &con->peer_addr.in_addr;\r\nstruct socket *sock;\r\nint ret;\r\nBUG_ON(con->sock);\r\nret = sock_create_kern(con->peer_addr.in_addr.ss_family, SOCK_STREAM,\r\nIPPROTO_TCP, &sock);\r\nif (ret)\r\nreturn ret;\r\nsock->sk->sk_allocation = GFP_NOFS;\r\n#ifdef CONFIG_LOCKDEP\r\nlockdep_set_class(&sock->sk->sk_lock, &socket_class);\r\n#endif\r\nset_sock_callbacks(sock, con);\r\ndout("connect %s\n", ceph_pr_addr(&con->peer_addr.in_addr));\r\ncon_sock_state_connecting(con);\r\nret = sock->ops->connect(sock, (struct sockaddr *)paddr, sizeof(*paddr),\r\nO_NONBLOCK);\r\nif (ret == -EINPROGRESS) {\r\ndout("connect %s EINPROGRESS sk_state = %u\n",\r\nceph_pr_addr(&con->peer_addr.in_addr),\r\nsock->sk->sk_state);\r\n} else if (ret < 0) {\r\npr_err("connect %s error %d\n",\r\nceph_pr_addr(&con->peer_addr.in_addr), ret);\r\nsock_release(sock);\r\ncon->error_msg = "connect error";\r\nreturn ret;\r\n}\r\ncon->sock = sock;\r\nreturn 0;\r\n}\r\nstatic int ceph_tcp_recvmsg(struct socket *sock, void *buf, size_t len)\r\n{\r\nstruct kvec iov = {buf, len};\r\nstruct msghdr msg = { .msg_flags = MSG_DONTWAIT | MSG_NOSIGNAL };\r\nint r;\r\nr = kernel_recvmsg(sock, &msg, &iov, 1, len, msg.msg_flags);\r\nif (r == -EAGAIN)\r\nr = 0;\r\nreturn r;\r\n}\r\nstatic int ceph_tcp_recvpage(struct socket *sock, struct page *page,\r\nint page_offset, size_t length)\r\n{\r\nvoid *kaddr;\r\nint ret;\r\nBUG_ON(page_offset + length > PAGE_SIZE);\r\nkaddr = kmap(page);\r\nBUG_ON(!kaddr);\r\nret = ceph_tcp_recvmsg(sock, kaddr + page_offset, length);\r\nkunmap(page);\r\nreturn ret;\r\n}\r\nstatic int ceph_tcp_sendmsg(struct socket *sock, struct kvec *iov,\r\nsize_t kvlen, size_t len, int more)\r\n{\r\nstruct msghdr msg = { .msg_flags = MSG_DONTWAIT | MSG_NOSIGNAL };\r\nint r;\r\nif (more)\r\nmsg.msg_flags |= MSG_MORE;\r\nelse\r\nmsg.msg_flags |= MSG_EOR;\r\nr = kernel_sendmsg(sock, &msg, iov, kvlen, len);\r\nif (r == -EAGAIN)\r\nr = 0;\r\nreturn r;\r\n}\r\nstatic int ceph_tcp_sendpage(struct socket *sock, struct page *page,\r\nint offset, size_t size, bool more)\r\n{\r\nint flags = MSG_DONTWAIT | MSG_NOSIGNAL | (more ? MSG_MORE : MSG_EOR);\r\nint ret;\r\nret = kernel_sendpage(sock, page, offset, size, flags);\r\nif (ret == -EAGAIN)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int con_close_socket(struct ceph_connection *con)\r\n{\r\nint rc = 0;\r\ndout("con_close_socket on %p sock %p\n", con, con->sock);\r\nif (con->sock) {\r\nrc = con->sock->ops->shutdown(con->sock, SHUT_RDWR);\r\nsock_release(con->sock);\r\ncon->sock = NULL;\r\n}\r\ncon_flag_clear(con, CON_FLAG_SOCK_CLOSED);\r\ncon_sock_state_closed(con);\r\nreturn rc;\r\n}\r\nstatic void ceph_msg_remove(struct ceph_msg *msg)\r\n{\r\nlist_del_init(&msg->list_head);\r\nBUG_ON(msg->con == NULL);\r\nmsg->con->ops->put(msg->con);\r\nmsg->con = NULL;\r\nceph_msg_put(msg);\r\n}\r\nstatic void ceph_msg_remove_list(struct list_head *head)\r\n{\r\nwhile (!list_empty(head)) {\r\nstruct ceph_msg *msg = list_first_entry(head, struct ceph_msg,\r\nlist_head);\r\nceph_msg_remove(msg);\r\n}\r\n}\r\nstatic void reset_connection(struct ceph_connection *con)\r\n{\r\ndout("reset_connection %p\n", con);\r\nceph_msg_remove_list(&con->out_queue);\r\nceph_msg_remove_list(&con->out_sent);\r\nif (con->in_msg) {\r\nBUG_ON(con->in_msg->con != con);\r\ncon->in_msg->con = NULL;\r\nceph_msg_put(con->in_msg);\r\ncon->in_msg = NULL;\r\ncon->ops->put(con);\r\n}\r\ncon->connect_seq = 0;\r\ncon->out_seq = 0;\r\nif (con->out_msg) {\r\nceph_msg_put(con->out_msg);\r\ncon->out_msg = NULL;\r\n}\r\ncon->in_seq = 0;\r\ncon->in_seq_acked = 0;\r\n}\r\nvoid ceph_con_close(struct ceph_connection *con)\r\n{\r\nmutex_lock(&con->mutex);\r\ndout("con_close %p peer %s\n", con,\r\nceph_pr_addr(&con->peer_addr.in_addr));\r\ncon->state = CON_STATE_CLOSED;\r\ncon_flag_clear(con, CON_FLAG_LOSSYTX);\r\ncon_flag_clear(con, CON_FLAG_KEEPALIVE_PENDING);\r\ncon_flag_clear(con, CON_FLAG_WRITE_PENDING);\r\ncon_flag_clear(con, CON_FLAG_BACKOFF);\r\nreset_connection(con);\r\ncon->peer_global_seq = 0;\r\ncancel_delayed_work(&con->work);\r\ncon_close_socket(con);\r\nmutex_unlock(&con->mutex);\r\n}\r\nvoid ceph_con_open(struct ceph_connection *con,\r\n__u8 entity_type, __u64 entity_num,\r\nstruct ceph_entity_addr *addr)\r\n{\r\nmutex_lock(&con->mutex);\r\ndout("con_open %p %s\n", con, ceph_pr_addr(&addr->in_addr));\r\nWARN_ON(con->state != CON_STATE_CLOSED);\r\ncon->state = CON_STATE_PREOPEN;\r\ncon->peer_name.type = (__u8) entity_type;\r\ncon->peer_name.num = cpu_to_le64(entity_num);\r\nmemcpy(&con->peer_addr, addr, sizeof(*addr));\r\ncon->delay = 0;\r\nmutex_unlock(&con->mutex);\r\nqueue_con(con);\r\n}\r\nbool ceph_con_opened(struct ceph_connection *con)\r\n{\r\nreturn con->connect_seq > 0;\r\n}\r\nvoid ceph_con_init(struct ceph_connection *con, void *private,\r\nconst struct ceph_connection_operations *ops,\r\nstruct ceph_messenger *msgr)\r\n{\r\ndout("con_init %p\n", con);\r\nmemset(con, 0, sizeof(*con));\r\ncon->private = private;\r\ncon->ops = ops;\r\ncon->msgr = msgr;\r\ncon_sock_state_init(con);\r\nmutex_init(&con->mutex);\r\nINIT_LIST_HEAD(&con->out_queue);\r\nINIT_LIST_HEAD(&con->out_sent);\r\nINIT_DELAYED_WORK(&con->work, con_work);\r\ncon->state = CON_STATE_CLOSED;\r\n}\r\nstatic u32 get_global_seq(struct ceph_messenger *msgr, u32 gt)\r\n{\r\nu32 ret;\r\nspin_lock(&msgr->global_seq_lock);\r\nif (msgr->global_seq < gt)\r\nmsgr->global_seq = gt;\r\nret = ++msgr->global_seq;\r\nspin_unlock(&msgr->global_seq_lock);\r\nreturn ret;\r\n}\r\nstatic void con_out_kvec_reset(struct ceph_connection *con)\r\n{\r\ncon->out_kvec_left = 0;\r\ncon->out_kvec_bytes = 0;\r\ncon->out_kvec_cur = &con->out_kvec[0];\r\n}\r\nstatic void con_out_kvec_add(struct ceph_connection *con,\r\nsize_t size, void *data)\r\n{\r\nint index;\r\nindex = con->out_kvec_left;\r\nBUG_ON(index >= ARRAY_SIZE(con->out_kvec));\r\ncon->out_kvec[index].iov_len = size;\r\ncon->out_kvec[index].iov_base = data;\r\ncon->out_kvec_left++;\r\ncon->out_kvec_bytes += size;\r\n}\r\nstatic void ceph_msg_data_bio_cursor_init(struct ceph_msg_data_cursor *cursor,\r\nsize_t length)\r\n{\r\nstruct ceph_msg_data *data = cursor->data;\r\nstruct bio *bio;\r\nBUG_ON(data->type != CEPH_MSG_DATA_BIO);\r\nbio = data->bio;\r\nBUG_ON(!bio);\r\nBUG_ON(!bio->bi_vcnt);\r\ncursor->resid = min(length, data->bio_length);\r\ncursor->bio = bio;\r\ncursor->vector_index = 0;\r\ncursor->vector_offset = 0;\r\ncursor->last_piece = length <= bio->bi_io_vec[0].bv_len;\r\n}\r\nstatic struct page *ceph_msg_data_bio_next(struct ceph_msg_data_cursor *cursor,\r\nsize_t *page_offset,\r\nsize_t *length)\r\n{\r\nstruct ceph_msg_data *data = cursor->data;\r\nstruct bio *bio;\r\nstruct bio_vec *bio_vec;\r\nunsigned int index;\r\nBUG_ON(data->type != CEPH_MSG_DATA_BIO);\r\nbio = cursor->bio;\r\nBUG_ON(!bio);\r\nindex = cursor->vector_index;\r\nBUG_ON(index >= (unsigned int) bio->bi_vcnt);\r\nbio_vec = &bio->bi_io_vec[index];\r\nBUG_ON(cursor->vector_offset >= bio_vec->bv_len);\r\n*page_offset = (size_t) (bio_vec->bv_offset + cursor->vector_offset);\r\nBUG_ON(*page_offset >= PAGE_SIZE);\r\nif (cursor->last_piece)\r\n*length = cursor->resid;\r\nelse\r\n*length = (size_t) (bio_vec->bv_len - cursor->vector_offset);\r\nBUG_ON(*length > cursor->resid);\r\nBUG_ON(*page_offset + *length > PAGE_SIZE);\r\nreturn bio_vec->bv_page;\r\n}\r\nstatic bool ceph_msg_data_bio_advance(struct ceph_msg_data_cursor *cursor,\r\nsize_t bytes)\r\n{\r\nstruct bio *bio;\r\nstruct bio_vec *bio_vec;\r\nunsigned int index;\r\nBUG_ON(cursor->data->type != CEPH_MSG_DATA_BIO);\r\nbio = cursor->bio;\r\nBUG_ON(!bio);\r\nindex = cursor->vector_index;\r\nBUG_ON(index >= (unsigned int) bio->bi_vcnt);\r\nbio_vec = &bio->bi_io_vec[index];\r\nBUG_ON(cursor->resid < bytes);\r\ncursor->resid -= bytes;\r\ncursor->vector_offset += bytes;\r\nif (cursor->vector_offset < bio_vec->bv_len)\r\nreturn false;\r\nBUG_ON(cursor->vector_offset != bio_vec->bv_len);\r\nif (++index == (unsigned int) bio->bi_vcnt) {\r\nbio = bio->bi_next;\r\nindex = 0;\r\n}\r\ncursor->bio = bio;\r\ncursor->vector_index = index;\r\ncursor->vector_offset = 0;\r\nif (!cursor->last_piece) {\r\nBUG_ON(!cursor->resid);\r\nBUG_ON(!bio);\r\nif (cursor->resid <= bio->bi_io_vec[index].bv_len)\r\ncursor->last_piece = true;\r\n}\r\nreturn true;\r\n}\r\nstatic void ceph_msg_data_pages_cursor_init(struct ceph_msg_data_cursor *cursor,\r\nsize_t length)\r\n{\r\nstruct ceph_msg_data *data = cursor->data;\r\nint page_count;\r\nBUG_ON(data->type != CEPH_MSG_DATA_PAGES);\r\nBUG_ON(!data->pages);\r\nBUG_ON(!data->length);\r\ncursor->resid = min(length, data->length);\r\npage_count = calc_pages_for(data->alignment, (u64)data->length);\r\ncursor->page_offset = data->alignment & ~PAGE_MASK;\r\ncursor->page_index = 0;\r\nBUG_ON(page_count > (int)USHRT_MAX);\r\ncursor->page_count = (unsigned short)page_count;\r\nBUG_ON(length > SIZE_MAX - cursor->page_offset);\r\ncursor->last_piece = (size_t)cursor->page_offset + length <= PAGE_SIZE;\r\n}\r\nstatic struct page *\r\nceph_msg_data_pages_next(struct ceph_msg_data_cursor *cursor,\r\nsize_t *page_offset, size_t *length)\r\n{\r\nstruct ceph_msg_data *data = cursor->data;\r\nBUG_ON(data->type != CEPH_MSG_DATA_PAGES);\r\nBUG_ON(cursor->page_index >= cursor->page_count);\r\nBUG_ON(cursor->page_offset >= PAGE_SIZE);\r\n*page_offset = cursor->page_offset;\r\nif (cursor->last_piece)\r\n*length = cursor->resid;\r\nelse\r\n*length = PAGE_SIZE - *page_offset;\r\nreturn data->pages[cursor->page_index];\r\n}\r\nstatic bool ceph_msg_data_pages_advance(struct ceph_msg_data_cursor *cursor,\r\nsize_t bytes)\r\n{\r\nBUG_ON(cursor->data->type != CEPH_MSG_DATA_PAGES);\r\nBUG_ON(cursor->page_offset + bytes > PAGE_SIZE);\r\ncursor->resid -= bytes;\r\ncursor->page_offset = (cursor->page_offset + bytes) & ~PAGE_MASK;\r\nif (!bytes || cursor->page_offset)\r\nreturn false;\r\nBUG_ON(cursor->page_index >= cursor->page_count);\r\ncursor->page_index++;\r\ncursor->last_piece = cursor->resid <= PAGE_SIZE;\r\nreturn true;\r\n}\r\nstatic void\r\nceph_msg_data_pagelist_cursor_init(struct ceph_msg_data_cursor *cursor,\r\nsize_t length)\r\n{\r\nstruct ceph_msg_data *data = cursor->data;\r\nstruct ceph_pagelist *pagelist;\r\nstruct page *page;\r\nBUG_ON(data->type != CEPH_MSG_DATA_PAGELIST);\r\npagelist = data->pagelist;\r\nBUG_ON(!pagelist);\r\nif (!length)\r\nreturn;\r\nBUG_ON(list_empty(&pagelist->head));\r\npage = list_first_entry(&pagelist->head, struct page, lru);\r\ncursor->resid = min(length, pagelist->length);\r\ncursor->page = page;\r\ncursor->offset = 0;\r\ncursor->last_piece = cursor->resid <= PAGE_SIZE;\r\n}\r\nstatic struct page *\r\nceph_msg_data_pagelist_next(struct ceph_msg_data_cursor *cursor,\r\nsize_t *page_offset, size_t *length)\r\n{\r\nstruct ceph_msg_data *data = cursor->data;\r\nstruct ceph_pagelist *pagelist;\r\nBUG_ON(data->type != CEPH_MSG_DATA_PAGELIST);\r\npagelist = data->pagelist;\r\nBUG_ON(!pagelist);\r\nBUG_ON(!cursor->page);\r\nBUG_ON(cursor->offset + cursor->resid != pagelist->length);\r\n*page_offset = cursor->offset & ~PAGE_MASK;\r\nif (cursor->last_piece)\r\n*length = cursor->resid;\r\nelse\r\n*length = PAGE_SIZE - *page_offset;\r\nreturn cursor->page;\r\n}\r\nstatic bool ceph_msg_data_pagelist_advance(struct ceph_msg_data_cursor *cursor,\r\nsize_t bytes)\r\n{\r\nstruct ceph_msg_data *data = cursor->data;\r\nstruct ceph_pagelist *pagelist;\r\nBUG_ON(data->type != CEPH_MSG_DATA_PAGELIST);\r\npagelist = data->pagelist;\r\nBUG_ON(!pagelist);\r\nBUG_ON(cursor->offset + cursor->resid != pagelist->length);\r\nBUG_ON((cursor->offset & ~PAGE_MASK) + bytes > PAGE_SIZE);\r\ncursor->resid -= bytes;\r\ncursor->offset += bytes;\r\nif (!bytes || cursor->offset & ~PAGE_MASK)\r\nreturn false;\r\nBUG_ON(list_is_last(&cursor->page->lru, &pagelist->head));\r\ncursor->page = list_entry_next(cursor->page, lru);\r\ncursor->last_piece = cursor->resid <= PAGE_SIZE;\r\nreturn true;\r\n}\r\nstatic void __ceph_msg_data_cursor_init(struct ceph_msg_data_cursor *cursor)\r\n{\r\nsize_t length = cursor->total_resid;\r\nswitch (cursor->data->type) {\r\ncase CEPH_MSG_DATA_PAGELIST:\r\nceph_msg_data_pagelist_cursor_init(cursor, length);\r\nbreak;\r\ncase CEPH_MSG_DATA_PAGES:\r\nceph_msg_data_pages_cursor_init(cursor, length);\r\nbreak;\r\n#ifdef CONFIG_BLOCK\r\ncase CEPH_MSG_DATA_BIO:\r\nceph_msg_data_bio_cursor_init(cursor, length);\r\nbreak;\r\n#endif\r\ncase CEPH_MSG_DATA_NONE:\r\ndefault:\r\nbreak;\r\n}\r\ncursor->need_crc = true;\r\n}\r\nstatic void ceph_msg_data_cursor_init(struct ceph_msg *msg, size_t length)\r\n{\r\nstruct ceph_msg_data_cursor *cursor = &msg->cursor;\r\nstruct ceph_msg_data *data;\r\nBUG_ON(!length);\r\nBUG_ON(length > msg->data_length);\r\nBUG_ON(list_empty(&msg->data));\r\ncursor->data_head = &msg->data;\r\ncursor->total_resid = length;\r\ndata = list_first_entry(&msg->data, struct ceph_msg_data, links);\r\ncursor->data = data;\r\n__ceph_msg_data_cursor_init(cursor);\r\n}\r\nstatic struct page *ceph_msg_data_next(struct ceph_msg_data_cursor *cursor,\r\nsize_t *page_offset, size_t *length,\r\nbool *last_piece)\r\n{\r\nstruct page *page;\r\nswitch (cursor->data->type) {\r\ncase CEPH_MSG_DATA_PAGELIST:\r\npage = ceph_msg_data_pagelist_next(cursor, page_offset, length);\r\nbreak;\r\ncase CEPH_MSG_DATA_PAGES:\r\npage = ceph_msg_data_pages_next(cursor, page_offset, length);\r\nbreak;\r\n#ifdef CONFIG_BLOCK\r\ncase CEPH_MSG_DATA_BIO:\r\npage = ceph_msg_data_bio_next(cursor, page_offset, length);\r\nbreak;\r\n#endif\r\ncase CEPH_MSG_DATA_NONE:\r\ndefault:\r\npage = NULL;\r\nbreak;\r\n}\r\nBUG_ON(!page);\r\nBUG_ON(*page_offset + *length > PAGE_SIZE);\r\nBUG_ON(!*length);\r\nif (last_piece)\r\n*last_piece = cursor->last_piece;\r\nreturn page;\r\n}\r\nstatic bool ceph_msg_data_advance(struct ceph_msg_data_cursor *cursor,\r\nsize_t bytes)\r\n{\r\nbool new_piece;\r\nBUG_ON(bytes > cursor->resid);\r\nswitch (cursor->data->type) {\r\ncase CEPH_MSG_DATA_PAGELIST:\r\nnew_piece = ceph_msg_data_pagelist_advance(cursor, bytes);\r\nbreak;\r\ncase CEPH_MSG_DATA_PAGES:\r\nnew_piece = ceph_msg_data_pages_advance(cursor, bytes);\r\nbreak;\r\n#ifdef CONFIG_BLOCK\r\ncase CEPH_MSG_DATA_BIO:\r\nnew_piece = ceph_msg_data_bio_advance(cursor, bytes);\r\nbreak;\r\n#endif\r\ncase CEPH_MSG_DATA_NONE:\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\ncursor->total_resid -= bytes;\r\nif (!cursor->resid && cursor->total_resid) {\r\nWARN_ON(!cursor->last_piece);\r\nBUG_ON(list_is_last(&cursor->data->links, cursor->data_head));\r\ncursor->data = list_entry_next(cursor->data, links);\r\n__ceph_msg_data_cursor_init(cursor);\r\nnew_piece = true;\r\n}\r\ncursor->need_crc = new_piece;\r\nreturn new_piece;\r\n}\r\nstatic void prepare_message_data(struct ceph_msg *msg, u32 data_len)\r\n{\r\nBUG_ON(!msg);\r\nBUG_ON(!data_len);\r\nceph_msg_data_cursor_init(msg, (size_t)data_len);\r\n}\r\nstatic void prepare_write_message_footer(struct ceph_connection *con)\r\n{\r\nstruct ceph_msg *m = con->out_msg;\r\nint v = con->out_kvec_left;\r\nm->footer.flags |= CEPH_MSG_FOOTER_COMPLETE;\r\ndout("prepare_write_message_footer %p\n", con);\r\ncon->out_kvec_is_msg = true;\r\ncon->out_kvec[v].iov_base = &m->footer;\r\ncon->out_kvec[v].iov_len = sizeof(m->footer);\r\ncon->out_kvec_bytes += sizeof(m->footer);\r\ncon->out_kvec_left++;\r\ncon->out_more = m->more_to_follow;\r\ncon->out_msg_done = true;\r\n}\r\nstatic void prepare_write_message(struct ceph_connection *con)\r\n{\r\nstruct ceph_msg *m;\r\nu32 crc;\r\ncon_out_kvec_reset(con);\r\ncon->out_kvec_is_msg = true;\r\ncon->out_msg_done = false;\r\nif (con->in_seq > con->in_seq_acked) {\r\ncon->in_seq_acked = con->in_seq;\r\ncon_out_kvec_add(con, sizeof (tag_ack), &tag_ack);\r\ncon->out_temp_ack = cpu_to_le64(con->in_seq_acked);\r\ncon_out_kvec_add(con, sizeof (con->out_temp_ack),\r\n&con->out_temp_ack);\r\n}\r\nBUG_ON(list_empty(&con->out_queue));\r\nm = list_first_entry(&con->out_queue, struct ceph_msg, list_head);\r\ncon->out_msg = m;\r\nBUG_ON(m->con != con);\r\nceph_msg_get(m);\r\nlist_move_tail(&m->list_head, &con->out_sent);\r\nif (m->needs_out_seq) {\r\nm->hdr.seq = cpu_to_le64(++con->out_seq);\r\nm->needs_out_seq = false;\r\n}\r\nWARN_ON(m->data_length != le32_to_cpu(m->hdr.data_len));\r\ndout("prepare_write_message %p seq %lld type %d len %d+%d+%zd\n",\r\nm, con->out_seq, le16_to_cpu(m->hdr.type),\r\nle32_to_cpu(m->hdr.front_len), le32_to_cpu(m->hdr.middle_len),\r\nm->data_length);\r\nBUG_ON(le32_to_cpu(m->hdr.front_len) != m->front.iov_len);\r\ncon_out_kvec_add(con, sizeof (tag_msg), &tag_msg);\r\ncon_out_kvec_add(con, sizeof (m->hdr), &m->hdr);\r\ncon_out_kvec_add(con, m->front.iov_len, m->front.iov_base);\r\nif (m->middle)\r\ncon_out_kvec_add(con, m->middle->vec.iov_len,\r\nm->middle->vec.iov_base);\r\ncrc = crc32c(0, &m->hdr, offsetof(struct ceph_msg_header, crc));\r\ncon->out_msg->hdr.crc = cpu_to_le32(crc);\r\ncon->out_msg->footer.flags = 0;\r\ncrc = crc32c(0, m->front.iov_base, m->front.iov_len);\r\ncon->out_msg->footer.front_crc = cpu_to_le32(crc);\r\nif (m->middle) {\r\ncrc = crc32c(0, m->middle->vec.iov_base,\r\nm->middle->vec.iov_len);\r\ncon->out_msg->footer.middle_crc = cpu_to_le32(crc);\r\n} else\r\ncon->out_msg->footer.middle_crc = 0;\r\ndout("%s front_crc %u middle_crc %u\n", __func__,\r\nle32_to_cpu(con->out_msg->footer.front_crc),\r\nle32_to_cpu(con->out_msg->footer.middle_crc));\r\ncon->out_msg->footer.data_crc = 0;\r\nif (m->data_length) {\r\nprepare_message_data(con->out_msg, m->data_length);\r\ncon->out_more = 1;\r\n} else {\r\nprepare_write_message_footer(con);\r\n}\r\ncon_flag_set(con, CON_FLAG_WRITE_PENDING);\r\n}\r\nstatic void prepare_write_ack(struct ceph_connection *con)\r\n{\r\ndout("prepare_write_ack %p %llu -> %llu\n", con,\r\ncon->in_seq_acked, con->in_seq);\r\ncon->in_seq_acked = con->in_seq;\r\ncon_out_kvec_reset(con);\r\ncon_out_kvec_add(con, sizeof (tag_ack), &tag_ack);\r\ncon->out_temp_ack = cpu_to_le64(con->in_seq_acked);\r\ncon_out_kvec_add(con, sizeof (con->out_temp_ack),\r\n&con->out_temp_ack);\r\ncon->out_more = 1;\r\ncon_flag_set(con, CON_FLAG_WRITE_PENDING);\r\n}\r\nstatic void prepare_write_seq(struct ceph_connection *con)\r\n{\r\ndout("prepare_write_seq %p %llu -> %llu\n", con,\r\ncon->in_seq_acked, con->in_seq);\r\ncon->in_seq_acked = con->in_seq;\r\ncon_out_kvec_reset(con);\r\ncon->out_temp_ack = cpu_to_le64(con->in_seq_acked);\r\ncon_out_kvec_add(con, sizeof (con->out_temp_ack),\r\n&con->out_temp_ack);\r\ncon_flag_set(con, CON_FLAG_WRITE_PENDING);\r\n}\r\nstatic void prepare_write_keepalive(struct ceph_connection *con)\r\n{\r\ndout("prepare_write_keepalive %p\n", con);\r\ncon_out_kvec_reset(con);\r\ncon_out_kvec_add(con, sizeof (tag_keepalive), &tag_keepalive);\r\ncon_flag_set(con, CON_FLAG_WRITE_PENDING);\r\n}\r\nstatic struct ceph_auth_handshake *get_connect_authorizer(struct ceph_connection *con,\r\nint *auth_proto)\r\n{\r\nstruct ceph_auth_handshake *auth;\r\nif (!con->ops->get_authorizer) {\r\ncon->out_connect.authorizer_protocol = CEPH_AUTH_UNKNOWN;\r\ncon->out_connect.authorizer_len = 0;\r\nreturn NULL;\r\n}\r\nmutex_unlock(&con->mutex);\r\nauth = con->ops->get_authorizer(con, auth_proto, con->auth_retry);\r\nmutex_lock(&con->mutex);\r\nif (IS_ERR(auth))\r\nreturn auth;\r\nif (con->state != CON_STATE_NEGOTIATING)\r\nreturn ERR_PTR(-EAGAIN);\r\ncon->auth_reply_buf = auth->authorizer_reply_buf;\r\ncon->auth_reply_buf_len = auth->authorizer_reply_buf_len;\r\nreturn auth;\r\n}\r\nstatic void prepare_write_banner(struct ceph_connection *con)\r\n{\r\ncon_out_kvec_add(con, strlen(CEPH_BANNER), CEPH_BANNER);\r\ncon_out_kvec_add(con, sizeof (con->msgr->my_enc_addr),\r\n&con->msgr->my_enc_addr);\r\ncon->out_more = 0;\r\ncon_flag_set(con, CON_FLAG_WRITE_PENDING);\r\n}\r\nstatic int prepare_write_connect(struct ceph_connection *con)\r\n{\r\nunsigned int global_seq = get_global_seq(con->msgr, 0);\r\nint proto;\r\nint auth_proto;\r\nstruct ceph_auth_handshake *auth;\r\nswitch (con->peer_name.type) {\r\ncase CEPH_ENTITY_TYPE_MON:\r\nproto = CEPH_MONC_PROTOCOL;\r\nbreak;\r\ncase CEPH_ENTITY_TYPE_OSD:\r\nproto = CEPH_OSDC_PROTOCOL;\r\nbreak;\r\ncase CEPH_ENTITY_TYPE_MDS:\r\nproto = CEPH_MDSC_PROTOCOL;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\ndout("prepare_write_connect %p cseq=%d gseq=%d proto=%d\n", con,\r\ncon->connect_seq, global_seq, proto);\r\ncon->out_connect.features = cpu_to_le64(con->msgr->supported_features);\r\ncon->out_connect.host_type = cpu_to_le32(CEPH_ENTITY_TYPE_CLIENT);\r\ncon->out_connect.connect_seq = cpu_to_le32(con->connect_seq);\r\ncon->out_connect.global_seq = cpu_to_le32(global_seq);\r\ncon->out_connect.protocol_version = cpu_to_le32(proto);\r\ncon->out_connect.flags = 0;\r\nauth_proto = CEPH_AUTH_UNKNOWN;\r\nauth = get_connect_authorizer(con, &auth_proto);\r\nif (IS_ERR(auth))\r\nreturn PTR_ERR(auth);\r\ncon->out_connect.authorizer_protocol = cpu_to_le32(auth_proto);\r\ncon->out_connect.authorizer_len = auth ?\r\ncpu_to_le32(auth->authorizer_buf_len) : 0;\r\ncon_out_kvec_add(con, sizeof (con->out_connect),\r\n&con->out_connect);\r\nif (auth && auth->authorizer_buf_len)\r\ncon_out_kvec_add(con, auth->authorizer_buf_len,\r\nauth->authorizer_buf);\r\ncon->out_more = 0;\r\ncon_flag_set(con, CON_FLAG_WRITE_PENDING);\r\nreturn 0;\r\n}\r\nstatic int write_partial_kvec(struct ceph_connection *con)\r\n{\r\nint ret;\r\ndout("write_partial_kvec %p %d left\n", con, con->out_kvec_bytes);\r\nwhile (con->out_kvec_bytes > 0) {\r\nret = ceph_tcp_sendmsg(con->sock, con->out_kvec_cur,\r\ncon->out_kvec_left, con->out_kvec_bytes,\r\ncon->out_more);\r\nif (ret <= 0)\r\ngoto out;\r\ncon->out_kvec_bytes -= ret;\r\nif (con->out_kvec_bytes == 0)\r\nbreak;\r\nwhile (ret >= con->out_kvec_cur->iov_len) {\r\nBUG_ON(!con->out_kvec_left);\r\nret -= con->out_kvec_cur->iov_len;\r\ncon->out_kvec_cur++;\r\ncon->out_kvec_left--;\r\n}\r\nif (ret) {\r\ncon->out_kvec_cur->iov_len -= ret;\r\ncon->out_kvec_cur->iov_base += ret;\r\n}\r\n}\r\ncon->out_kvec_left = 0;\r\ncon->out_kvec_is_msg = false;\r\nret = 1;\r\nout:\r\ndout("write_partial_kvec %p %d left in %d kvecs ret = %d\n", con,\r\ncon->out_kvec_bytes, con->out_kvec_left, ret);\r\nreturn ret;\r\n}\r\nstatic u32 ceph_crc32c_page(u32 crc, struct page *page,\r\nunsigned int page_offset,\r\nunsigned int length)\r\n{\r\nchar *kaddr;\r\nkaddr = kmap(page);\r\nBUG_ON(kaddr == NULL);\r\ncrc = crc32c(crc, kaddr + page_offset, length);\r\nkunmap(page);\r\nreturn crc;\r\n}\r\nstatic int write_partial_message_data(struct ceph_connection *con)\r\n{\r\nstruct ceph_msg *msg = con->out_msg;\r\nstruct ceph_msg_data_cursor *cursor = &msg->cursor;\r\nbool do_datacrc = !con->msgr->nocrc;\r\nu32 crc;\r\ndout("%s %p msg %p\n", __func__, con, msg);\r\nif (list_empty(&msg->data))\r\nreturn -EINVAL;\r\ncrc = do_datacrc ? le32_to_cpu(msg->footer.data_crc) : 0;\r\nwhile (cursor->resid) {\r\nstruct page *page;\r\nsize_t page_offset;\r\nsize_t length;\r\nbool last_piece;\r\nbool need_crc;\r\nint ret;\r\npage = ceph_msg_data_next(&msg->cursor, &page_offset, &length,\r\n&last_piece);\r\nret = ceph_tcp_sendpage(con->sock, page, page_offset,\r\nlength, last_piece);\r\nif (ret <= 0) {\r\nif (do_datacrc)\r\nmsg->footer.data_crc = cpu_to_le32(crc);\r\nreturn ret;\r\n}\r\nif (do_datacrc && cursor->need_crc)\r\ncrc = ceph_crc32c_page(crc, page, page_offset, length);\r\nneed_crc = ceph_msg_data_advance(&msg->cursor, (size_t)ret);\r\n}\r\ndout("%s %p msg %p done\n", __func__, con, msg);\r\nif (do_datacrc)\r\nmsg->footer.data_crc = cpu_to_le32(crc);\r\nelse\r\nmsg->footer.flags |= CEPH_MSG_FOOTER_NOCRC;\r\ncon_out_kvec_reset(con);\r\nprepare_write_message_footer(con);\r\nreturn 1;\r\n}\r\nstatic int write_partial_skip(struct ceph_connection *con)\r\n{\r\nint ret;\r\nwhile (con->out_skip > 0) {\r\nsize_t size = min(con->out_skip, (int) PAGE_CACHE_SIZE);\r\nret = ceph_tcp_sendpage(con->sock, zero_page, 0, size, true);\r\nif (ret <= 0)\r\ngoto out;\r\ncon->out_skip -= ret;\r\n}\r\nret = 1;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void prepare_read_banner(struct ceph_connection *con)\r\n{\r\ndout("prepare_read_banner %p\n", con);\r\ncon->in_base_pos = 0;\r\n}\r\nstatic void prepare_read_connect(struct ceph_connection *con)\r\n{\r\ndout("prepare_read_connect %p\n", con);\r\ncon->in_base_pos = 0;\r\n}\r\nstatic void prepare_read_ack(struct ceph_connection *con)\r\n{\r\ndout("prepare_read_ack %p\n", con);\r\ncon->in_base_pos = 0;\r\n}\r\nstatic void prepare_read_seq(struct ceph_connection *con)\r\n{\r\ndout("prepare_read_seq %p\n", con);\r\ncon->in_base_pos = 0;\r\ncon->in_tag = CEPH_MSGR_TAG_SEQ;\r\n}\r\nstatic void prepare_read_tag(struct ceph_connection *con)\r\n{\r\ndout("prepare_read_tag %p\n", con);\r\ncon->in_base_pos = 0;\r\ncon->in_tag = CEPH_MSGR_TAG_READY;\r\n}\r\nstatic int prepare_read_message(struct ceph_connection *con)\r\n{\r\ndout("prepare_read_message %p\n", con);\r\nBUG_ON(con->in_msg != NULL);\r\ncon->in_base_pos = 0;\r\ncon->in_front_crc = con->in_middle_crc = con->in_data_crc = 0;\r\nreturn 0;\r\n}\r\nstatic int read_partial(struct ceph_connection *con,\r\nint end, int size, void *object)\r\n{\r\nwhile (con->in_base_pos < end) {\r\nint left = end - con->in_base_pos;\r\nint have = size - left;\r\nint ret = ceph_tcp_recvmsg(con->sock, object + have, left);\r\nif (ret <= 0)\r\nreturn ret;\r\ncon->in_base_pos += ret;\r\n}\r\nreturn 1;\r\n}\r\nstatic int read_partial_banner(struct ceph_connection *con)\r\n{\r\nint size;\r\nint end;\r\nint ret;\r\ndout("read_partial_banner %p at %d\n", con, con->in_base_pos);\r\nsize = strlen(CEPH_BANNER);\r\nend = size;\r\nret = read_partial(con, end, size, con->in_banner);\r\nif (ret <= 0)\r\ngoto out;\r\nsize = sizeof (con->actual_peer_addr);\r\nend += size;\r\nret = read_partial(con, end, size, &con->actual_peer_addr);\r\nif (ret <= 0)\r\ngoto out;\r\nsize = sizeof (con->peer_addr_for_me);\r\nend += size;\r\nret = read_partial(con, end, size, &con->peer_addr_for_me);\r\nif (ret <= 0)\r\ngoto out;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int read_partial_connect(struct ceph_connection *con)\r\n{\r\nint size;\r\nint end;\r\nint ret;\r\ndout("read_partial_connect %p at %d\n", con, con->in_base_pos);\r\nsize = sizeof (con->in_reply);\r\nend = size;\r\nret = read_partial(con, end, size, &con->in_reply);\r\nif (ret <= 0)\r\ngoto out;\r\nsize = le32_to_cpu(con->in_reply.authorizer_len);\r\nend += size;\r\nret = read_partial(con, end, size, con->auth_reply_buf);\r\nif (ret <= 0)\r\ngoto out;\r\ndout("read_partial_connect %p tag %d, con_seq = %u, g_seq = %u\n",\r\ncon, (int)con->in_reply.tag,\r\nle32_to_cpu(con->in_reply.connect_seq),\r\nle32_to_cpu(con->in_reply.global_seq));\r\nout:\r\nreturn ret;\r\n}\r\nstatic int verify_hello(struct ceph_connection *con)\r\n{\r\nif (memcmp(con->in_banner, CEPH_BANNER, strlen(CEPH_BANNER))) {\r\npr_err("connect to %s got bad banner\n",\r\nceph_pr_addr(&con->peer_addr.in_addr));\r\ncon->error_msg = "protocol error, bad banner";\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool addr_is_blank(struct sockaddr_storage *ss)\r\n{\r\nswitch (ss->ss_family) {\r\ncase AF_INET:\r\nreturn ((struct sockaddr_in *)ss)->sin_addr.s_addr == 0;\r\ncase AF_INET6:\r\nreturn\r\n((struct sockaddr_in6 *)ss)->sin6_addr.s6_addr32[0] == 0 &&\r\n((struct sockaddr_in6 *)ss)->sin6_addr.s6_addr32[1] == 0 &&\r\n((struct sockaddr_in6 *)ss)->sin6_addr.s6_addr32[2] == 0 &&\r\n((struct sockaddr_in6 *)ss)->sin6_addr.s6_addr32[3] == 0;\r\n}\r\nreturn false;\r\n}\r\nstatic int addr_port(struct sockaddr_storage *ss)\r\n{\r\nswitch (ss->ss_family) {\r\ncase AF_INET:\r\nreturn ntohs(((struct sockaddr_in *)ss)->sin_port);\r\ncase AF_INET6:\r\nreturn ntohs(((struct sockaddr_in6 *)ss)->sin6_port);\r\n}\r\nreturn 0;\r\n}\r\nstatic void addr_set_port(struct sockaddr_storage *ss, int p)\r\n{\r\nswitch (ss->ss_family) {\r\ncase AF_INET:\r\n((struct sockaddr_in *)ss)->sin_port = htons(p);\r\nbreak;\r\ncase AF_INET6:\r\n((struct sockaddr_in6 *)ss)->sin6_port = htons(p);\r\nbreak;\r\n}\r\n}\r\nstatic int ceph_pton(const char *str, size_t len, struct sockaddr_storage *ss,\r\nchar delim, const char **ipend)\r\n{\r\nstruct sockaddr_in *in4 = (struct sockaddr_in *) ss;\r\nstruct sockaddr_in6 *in6 = (struct sockaddr_in6 *) ss;\r\nmemset(ss, 0, sizeof(*ss));\r\nif (in4_pton(str, len, (u8 *)&in4->sin_addr.s_addr, delim, ipend)) {\r\nss->ss_family = AF_INET;\r\nreturn 0;\r\n}\r\nif (in6_pton(str, len, (u8 *)&in6->sin6_addr.s6_addr, delim, ipend)) {\r\nss->ss_family = AF_INET6;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ceph_dns_resolve_name(const char *name, size_t namelen,\r\nstruct sockaddr_storage *ss, char delim, const char **ipend)\r\n{\r\nconst char *end, *delim_p;\r\nchar *colon_p, *ip_addr = NULL;\r\nint ip_len, ret;\r\ndelim_p = memchr(name, delim, namelen);\r\ncolon_p = memchr(name, ':', namelen);\r\nif (delim_p && colon_p)\r\nend = delim_p < colon_p ? delim_p : colon_p;\r\nelse if (!delim_p && colon_p)\r\nend = colon_p;\r\nelse {\r\nend = delim_p;\r\nif (!end)\r\nend = name + namelen;\r\n}\r\nif (end <= name)\r\nreturn -EINVAL;\r\nip_len = dns_query(NULL, name, end - name, NULL, &ip_addr, NULL);\r\nif (ip_len > 0)\r\nret = ceph_pton(ip_addr, ip_len, ss, -1, NULL);\r\nelse\r\nret = -ESRCH;\r\nkfree(ip_addr);\r\n*ipend = end;\r\npr_info("resolve '%.*s' (ret=%d): %s\n", (int)(end - name), name,\r\nret, ret ? "failed" : ceph_pr_addr(ss));\r\nreturn ret;\r\n}\r\nstatic inline int ceph_dns_resolve_name(const char *name, size_t namelen,\r\nstruct sockaddr_storage *ss, char delim, const char **ipend)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int ceph_parse_server_name(const char *name, size_t namelen,\r\nstruct sockaddr_storage *ss, char delim, const char **ipend)\r\n{\r\nint ret;\r\nret = ceph_pton(name, namelen, ss, delim, ipend);\r\nif (ret)\r\nret = ceph_dns_resolve_name(name, namelen, ss, delim, ipend);\r\nreturn ret;\r\n}\r\nint ceph_parse_ips(const char *c, const char *end,\r\nstruct ceph_entity_addr *addr,\r\nint max_count, int *count)\r\n{\r\nint i, ret = -EINVAL;\r\nconst char *p = c;\r\ndout("parse_ips on '%.*s'\n", (int)(end-c), c);\r\nfor (i = 0; i < max_count; i++) {\r\nconst char *ipend;\r\nstruct sockaddr_storage *ss = &addr[i].in_addr;\r\nint port;\r\nchar delim = ',';\r\nif (*p == '[') {\r\ndelim = ']';\r\np++;\r\n}\r\nret = ceph_parse_server_name(p, end - p, ss, delim, &ipend);\r\nif (ret)\r\ngoto bad;\r\nret = -EINVAL;\r\np = ipend;\r\nif (delim == ']') {\r\nif (*p != ']') {\r\ndout("missing matching ']'\n");\r\ngoto bad;\r\n}\r\np++;\r\n}\r\nif (p < end && *p == ':') {\r\nport = 0;\r\np++;\r\nwhile (p < end && *p >= '0' && *p <= '9') {\r\nport = (port * 10) + (*p - '0');\r\np++;\r\n}\r\nif (port > 65535 || port == 0)\r\ngoto bad;\r\n} else {\r\nport = CEPH_MON_PORT;\r\n}\r\naddr_set_port(ss, port);\r\ndout("parse_ips got %s\n", ceph_pr_addr(ss));\r\nif (p == end)\r\nbreak;\r\nif (*p != ',')\r\ngoto bad;\r\np++;\r\n}\r\nif (p != end)\r\ngoto bad;\r\nif (count)\r\n*count = i + 1;\r\nreturn 0;\r\nbad:\r\npr_err("parse_ips bad ip '%.*s'\n", (int)(end - c), c);\r\nreturn ret;\r\n}\r\nstatic int process_banner(struct ceph_connection *con)\r\n{\r\ndout("process_banner on %p\n", con);\r\nif (verify_hello(con) < 0)\r\nreturn -1;\r\nceph_decode_addr(&con->actual_peer_addr);\r\nceph_decode_addr(&con->peer_addr_for_me);\r\nif (memcmp(&con->peer_addr, &con->actual_peer_addr,\r\nsizeof(con->peer_addr)) != 0 &&\r\n!(addr_is_blank(&con->actual_peer_addr.in_addr) &&\r\ncon->actual_peer_addr.nonce == con->peer_addr.nonce)) {\r\npr_warning("wrong peer, want %s/%d, got %s/%d\n",\r\nceph_pr_addr(&con->peer_addr.in_addr),\r\n(int)le32_to_cpu(con->peer_addr.nonce),\r\nceph_pr_addr(&con->actual_peer_addr.in_addr),\r\n(int)le32_to_cpu(con->actual_peer_addr.nonce));\r\ncon->error_msg = "wrong peer at address";\r\nreturn -1;\r\n}\r\nif (addr_is_blank(&con->msgr->inst.addr.in_addr)) {\r\nint port = addr_port(&con->msgr->inst.addr.in_addr);\r\nmemcpy(&con->msgr->inst.addr.in_addr,\r\n&con->peer_addr_for_me.in_addr,\r\nsizeof(con->peer_addr_for_me.in_addr));\r\naddr_set_port(&con->msgr->inst.addr.in_addr, port);\r\nencode_my_addr(con->msgr);\r\ndout("process_banner learned my addr is %s\n",\r\nceph_pr_addr(&con->msgr->inst.addr.in_addr));\r\n}\r\nreturn 0;\r\n}\r\nstatic int process_connect(struct ceph_connection *con)\r\n{\r\nu64 sup_feat = con->msgr->supported_features;\r\nu64 req_feat = con->msgr->required_features;\r\nu64 server_feat = le64_to_cpu(con->in_reply.features);\r\nint ret;\r\ndout("process_connect on %p tag %d\n", con, (int)con->in_tag);\r\nswitch (con->in_reply.tag) {\r\ncase CEPH_MSGR_TAG_FEATURES:\r\npr_err("%s%lld %s feature set mismatch,"\r\n" my %llx < server's %llx, missing %llx\n",\r\nENTITY_NAME(con->peer_name),\r\nceph_pr_addr(&con->peer_addr.in_addr),\r\nsup_feat, server_feat, server_feat & ~sup_feat);\r\ncon->error_msg = "missing required protocol features";\r\nreset_connection(con);\r\nreturn -1;\r\ncase CEPH_MSGR_TAG_BADPROTOVER:\r\npr_err("%s%lld %s protocol version mismatch,"\r\n" my %d != server's %d\n",\r\nENTITY_NAME(con->peer_name),\r\nceph_pr_addr(&con->peer_addr.in_addr),\r\nle32_to_cpu(con->out_connect.protocol_version),\r\nle32_to_cpu(con->in_reply.protocol_version));\r\ncon->error_msg = "protocol version mismatch";\r\nreset_connection(con);\r\nreturn -1;\r\ncase CEPH_MSGR_TAG_BADAUTHORIZER:\r\ncon->auth_retry++;\r\ndout("process_connect %p got BADAUTHORIZER attempt %d\n", con,\r\ncon->auth_retry);\r\nif (con->auth_retry == 2) {\r\ncon->error_msg = "connect authorization failure";\r\nreturn -1;\r\n}\r\ncon_out_kvec_reset(con);\r\nret = prepare_write_connect(con);\r\nif (ret < 0)\r\nreturn ret;\r\nprepare_read_connect(con);\r\nbreak;\r\ncase CEPH_MSGR_TAG_RESETSESSION:\r\ndout("process_connect got RESET peer seq %u\n",\r\nle32_to_cpu(con->in_reply.connect_seq));\r\npr_err("%s%lld %s connection reset\n",\r\nENTITY_NAME(con->peer_name),\r\nceph_pr_addr(&con->peer_addr.in_addr));\r\nreset_connection(con);\r\ncon_out_kvec_reset(con);\r\nret = prepare_write_connect(con);\r\nif (ret < 0)\r\nreturn ret;\r\nprepare_read_connect(con);\r\nmutex_unlock(&con->mutex);\r\npr_info("reset on %s%lld\n", ENTITY_NAME(con->peer_name));\r\nif (con->ops->peer_reset)\r\ncon->ops->peer_reset(con);\r\nmutex_lock(&con->mutex);\r\nif (con->state != CON_STATE_NEGOTIATING)\r\nreturn -EAGAIN;\r\nbreak;\r\ncase CEPH_MSGR_TAG_RETRY_SESSION:\r\ndout("process_connect got RETRY_SESSION my seq %u, peer %u\n",\r\nle32_to_cpu(con->out_connect.connect_seq),\r\nle32_to_cpu(con->in_reply.connect_seq));\r\ncon->connect_seq = le32_to_cpu(con->in_reply.connect_seq);\r\ncon_out_kvec_reset(con);\r\nret = prepare_write_connect(con);\r\nif (ret < 0)\r\nreturn ret;\r\nprepare_read_connect(con);\r\nbreak;\r\ncase CEPH_MSGR_TAG_RETRY_GLOBAL:\r\ndout("process_connect got RETRY_GLOBAL my %u peer_gseq %u\n",\r\ncon->peer_global_seq,\r\nle32_to_cpu(con->in_reply.global_seq));\r\nget_global_seq(con->msgr,\r\nle32_to_cpu(con->in_reply.global_seq));\r\ncon_out_kvec_reset(con);\r\nret = prepare_write_connect(con);\r\nif (ret < 0)\r\nreturn ret;\r\nprepare_read_connect(con);\r\nbreak;\r\ncase CEPH_MSGR_TAG_SEQ:\r\ncase CEPH_MSGR_TAG_READY:\r\nif (req_feat & ~server_feat) {\r\npr_err("%s%lld %s protocol feature mismatch,"\r\n" my required %llx > server's %llx, need %llx\n",\r\nENTITY_NAME(con->peer_name),\r\nceph_pr_addr(&con->peer_addr.in_addr),\r\nreq_feat, server_feat, req_feat & ~server_feat);\r\ncon->error_msg = "missing required protocol features";\r\nreset_connection(con);\r\nreturn -1;\r\n}\r\nWARN_ON(con->state != CON_STATE_NEGOTIATING);\r\ncon->state = CON_STATE_OPEN;\r\ncon->auth_retry = 0;\r\ncon->peer_global_seq = le32_to_cpu(con->in_reply.global_seq);\r\ncon->connect_seq++;\r\ncon->peer_features = server_feat;\r\ndout("process_connect got READY gseq %d cseq %d (%d)\n",\r\ncon->peer_global_seq,\r\nle32_to_cpu(con->in_reply.connect_seq),\r\ncon->connect_seq);\r\nWARN_ON(con->connect_seq !=\r\nle32_to_cpu(con->in_reply.connect_seq));\r\nif (con->in_reply.flags & CEPH_MSG_CONNECT_LOSSY)\r\ncon_flag_set(con, CON_FLAG_LOSSYTX);\r\ncon->delay = 0;\r\nif (con->in_reply.tag == CEPH_MSGR_TAG_SEQ) {\r\nprepare_write_seq(con);\r\nprepare_read_seq(con);\r\n} else {\r\nprepare_read_tag(con);\r\n}\r\nbreak;\r\ncase CEPH_MSGR_TAG_WAIT:\r\npr_err("process_connect got WAIT as client\n");\r\ncon->error_msg = "protocol error, got WAIT as client";\r\nreturn -1;\r\ndefault:\r\npr_err("connect protocol error, will retry\n");\r\ncon->error_msg = "protocol error, garbage tag during connect";\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_partial_ack(struct ceph_connection *con)\r\n{\r\nint size = sizeof (con->in_temp_ack);\r\nint end = size;\r\nreturn read_partial(con, end, size, &con->in_temp_ack);\r\n}\r\nstatic void process_ack(struct ceph_connection *con)\r\n{\r\nstruct ceph_msg *m;\r\nu64 ack = le64_to_cpu(con->in_temp_ack);\r\nu64 seq;\r\nwhile (!list_empty(&con->out_sent)) {\r\nm = list_first_entry(&con->out_sent, struct ceph_msg,\r\nlist_head);\r\nseq = le64_to_cpu(m->hdr.seq);\r\nif (seq > ack)\r\nbreak;\r\ndout("got ack for seq %llu type %d at %p\n", seq,\r\nle16_to_cpu(m->hdr.type), m);\r\nm->ack_stamp = jiffies;\r\nceph_msg_remove(m);\r\n}\r\nprepare_read_tag(con);\r\n}\r\nstatic int read_partial_message_section(struct ceph_connection *con,\r\nstruct kvec *section,\r\nunsigned int sec_len, u32 *crc)\r\n{\r\nint ret, left;\r\nBUG_ON(!section);\r\nwhile (section->iov_len < sec_len) {\r\nBUG_ON(section->iov_base == NULL);\r\nleft = sec_len - section->iov_len;\r\nret = ceph_tcp_recvmsg(con->sock, (char *)section->iov_base +\r\nsection->iov_len, left);\r\nif (ret <= 0)\r\nreturn ret;\r\nsection->iov_len += ret;\r\n}\r\nif (section->iov_len == sec_len)\r\n*crc = crc32c(0, section->iov_base, section->iov_len);\r\nreturn 1;\r\n}\r\nstatic int read_partial_msg_data(struct ceph_connection *con)\r\n{\r\nstruct ceph_msg *msg = con->in_msg;\r\nstruct ceph_msg_data_cursor *cursor = &msg->cursor;\r\nconst bool do_datacrc = !con->msgr->nocrc;\r\nstruct page *page;\r\nsize_t page_offset;\r\nsize_t length;\r\nu32 crc = 0;\r\nint ret;\r\nBUG_ON(!msg);\r\nif (list_empty(&msg->data))\r\nreturn -EIO;\r\nif (do_datacrc)\r\ncrc = con->in_data_crc;\r\nwhile (cursor->resid) {\r\npage = ceph_msg_data_next(&msg->cursor, &page_offset, &length,\r\nNULL);\r\nret = ceph_tcp_recvpage(con->sock, page, page_offset, length);\r\nif (ret <= 0) {\r\nif (do_datacrc)\r\ncon->in_data_crc = crc;\r\nreturn ret;\r\n}\r\nif (do_datacrc)\r\ncrc = ceph_crc32c_page(crc, page, page_offset, ret);\r\n(void) ceph_msg_data_advance(&msg->cursor, (size_t)ret);\r\n}\r\nif (do_datacrc)\r\ncon->in_data_crc = crc;\r\nreturn 1;\r\n}\r\nstatic int read_partial_message(struct ceph_connection *con)\r\n{\r\nstruct ceph_msg *m = con->in_msg;\r\nint size;\r\nint end;\r\nint ret;\r\nunsigned int front_len, middle_len, data_len;\r\nbool do_datacrc = !con->msgr->nocrc;\r\nu64 seq;\r\nu32 crc;\r\ndout("read_partial_message con %p msg %p\n", con, m);\r\nsize = sizeof (con->in_hdr);\r\nend = size;\r\nret = read_partial(con, end, size, &con->in_hdr);\r\nif (ret <= 0)\r\nreturn ret;\r\ncrc = crc32c(0, &con->in_hdr, offsetof(struct ceph_msg_header, crc));\r\nif (cpu_to_le32(crc) != con->in_hdr.crc) {\r\npr_err("read_partial_message bad hdr "\r\n" crc %u != expected %u\n",\r\ncrc, con->in_hdr.crc);\r\nreturn -EBADMSG;\r\n}\r\nfront_len = le32_to_cpu(con->in_hdr.front_len);\r\nif (front_len > CEPH_MSG_MAX_FRONT_LEN)\r\nreturn -EIO;\r\nmiddle_len = le32_to_cpu(con->in_hdr.middle_len);\r\nif (middle_len > CEPH_MSG_MAX_MIDDLE_LEN)\r\nreturn -EIO;\r\ndata_len = le32_to_cpu(con->in_hdr.data_len);\r\nif (data_len > CEPH_MSG_MAX_DATA_LEN)\r\nreturn -EIO;\r\nseq = le64_to_cpu(con->in_hdr.seq);\r\nif ((s64)seq - (s64)con->in_seq < 1) {\r\npr_info("skipping %s%lld %s seq %lld expected %lld\n",\r\nENTITY_NAME(con->peer_name),\r\nceph_pr_addr(&con->peer_addr.in_addr),\r\nseq, con->in_seq + 1);\r\ncon->in_base_pos = -front_len - middle_len - data_len -\r\nsizeof(m->footer);\r\ncon->in_tag = CEPH_MSGR_TAG_READY;\r\nreturn 0;\r\n} else if ((s64)seq - (s64)con->in_seq > 1) {\r\npr_err("read_partial_message bad seq %lld expected %lld\n",\r\nseq, con->in_seq + 1);\r\ncon->error_msg = "bad message sequence # for incoming message";\r\nreturn -EBADMSG;\r\n}\r\nif (!con->in_msg) {\r\nint skip = 0;\r\ndout("got hdr type %d front %d data %d\n", con->in_hdr.type,\r\nfront_len, data_len);\r\nret = ceph_con_in_msg_alloc(con, &skip);\r\nif (ret < 0)\r\nreturn ret;\r\nBUG_ON(!con->in_msg ^ skip);\r\nif (con->in_msg && data_len > con->in_msg->data_length) {\r\npr_warning("%s skipping long message (%u > %zd)\n",\r\n__func__, data_len, con->in_msg->data_length);\r\nceph_msg_put(con->in_msg);\r\ncon->in_msg = NULL;\r\nskip = 1;\r\n}\r\nif (skip) {\r\ndout("alloc_msg said skip message\n");\r\ncon->in_base_pos = -front_len - middle_len - data_len -\r\nsizeof(m->footer);\r\ncon->in_tag = CEPH_MSGR_TAG_READY;\r\ncon->in_seq++;\r\nreturn 0;\r\n}\r\nBUG_ON(!con->in_msg);\r\nBUG_ON(con->in_msg->con != con);\r\nm = con->in_msg;\r\nm->front.iov_len = 0;\r\nif (m->middle)\r\nm->middle->vec.iov_len = 0;\r\nif (data_len)\r\nprepare_message_data(con->in_msg, data_len);\r\n}\r\nret = read_partial_message_section(con, &m->front, front_len,\r\n&con->in_front_crc);\r\nif (ret <= 0)\r\nreturn ret;\r\nif (m->middle) {\r\nret = read_partial_message_section(con, &m->middle->vec,\r\nmiddle_len,\r\n&con->in_middle_crc);\r\nif (ret <= 0)\r\nreturn ret;\r\n}\r\nif (data_len) {\r\nret = read_partial_msg_data(con);\r\nif (ret <= 0)\r\nreturn ret;\r\n}\r\nsize = sizeof (m->footer);\r\nend += size;\r\nret = read_partial(con, end, size, &m->footer);\r\nif (ret <= 0)\r\nreturn ret;\r\ndout("read_partial_message got msg %p %d (%u) + %d (%u) + %d (%u)\n",\r\nm, front_len, m->footer.front_crc, middle_len,\r\nm->footer.middle_crc, data_len, m->footer.data_crc);\r\nif (con->in_front_crc != le32_to_cpu(m->footer.front_crc)) {\r\npr_err("read_partial_message %p front crc %u != exp. %u\n",\r\nm, con->in_front_crc, m->footer.front_crc);\r\nreturn -EBADMSG;\r\n}\r\nif (con->in_middle_crc != le32_to_cpu(m->footer.middle_crc)) {\r\npr_err("read_partial_message %p middle crc %u != exp %u\n",\r\nm, con->in_middle_crc, m->footer.middle_crc);\r\nreturn -EBADMSG;\r\n}\r\nif (do_datacrc &&\r\n(m->footer.flags & CEPH_MSG_FOOTER_NOCRC) == 0 &&\r\ncon->in_data_crc != le32_to_cpu(m->footer.data_crc)) {\r\npr_err("read_partial_message %p data crc %u != exp. %u\n", m,\r\ncon->in_data_crc, le32_to_cpu(m->footer.data_crc));\r\nreturn -EBADMSG;\r\n}\r\nreturn 1;\r\n}\r\nstatic void process_message(struct ceph_connection *con)\r\n{\r\nstruct ceph_msg *msg;\r\nBUG_ON(con->in_msg->con != con);\r\ncon->in_msg->con = NULL;\r\nmsg = con->in_msg;\r\ncon->in_msg = NULL;\r\ncon->ops->put(con);\r\nif (con->peer_name.type == 0)\r\ncon->peer_name = msg->hdr.src;\r\ncon->in_seq++;\r\nmutex_unlock(&con->mutex);\r\ndout("===== %p %llu from %s%lld %d=%s len %d+%d (%u %u %u) =====\n",\r\nmsg, le64_to_cpu(msg->hdr.seq),\r\nENTITY_NAME(msg->hdr.src),\r\nle16_to_cpu(msg->hdr.type),\r\nceph_msg_type_name(le16_to_cpu(msg->hdr.type)),\r\nle32_to_cpu(msg->hdr.front_len),\r\nle32_to_cpu(msg->hdr.data_len),\r\ncon->in_front_crc, con->in_middle_crc, con->in_data_crc);\r\ncon->ops->dispatch(con, msg);\r\nmutex_lock(&con->mutex);\r\n}\r\nstatic int try_write(struct ceph_connection *con)\r\n{\r\nint ret = 1;\r\ndout("try_write start %p state %lu\n", con, con->state);\r\nmore:\r\ndout("try_write out_kvec_bytes %d\n", con->out_kvec_bytes);\r\nif (con->state == CON_STATE_PREOPEN) {\r\nBUG_ON(con->sock);\r\ncon->state = CON_STATE_CONNECTING;\r\ncon_out_kvec_reset(con);\r\nprepare_write_banner(con);\r\nprepare_read_banner(con);\r\nBUG_ON(con->in_msg);\r\ncon->in_tag = CEPH_MSGR_TAG_READY;\r\ndout("try_write initiating connect on %p new state %lu\n",\r\ncon, con->state);\r\nret = ceph_tcp_connect(con);\r\nif (ret < 0) {\r\ncon->error_msg = "connect error";\r\ngoto out;\r\n}\r\n}\r\nmore_kvec:\r\nif (con->out_skip) {\r\nret = write_partial_skip(con);\r\nif (ret <= 0)\r\ngoto out;\r\n}\r\nif (con->out_kvec_left) {\r\nret = write_partial_kvec(con);\r\nif (ret <= 0)\r\ngoto out;\r\n}\r\nif (con->out_msg) {\r\nif (con->out_msg_done) {\r\nceph_msg_put(con->out_msg);\r\ncon->out_msg = NULL;\r\ngoto do_next;\r\n}\r\nret = write_partial_message_data(con);\r\nif (ret == 1)\r\ngoto more_kvec;\r\nif (ret == 0)\r\ngoto out;\r\nif (ret < 0) {\r\ndout("try_write write_partial_message_data err %d\n",\r\nret);\r\ngoto out;\r\n}\r\n}\r\ndo_next:\r\nif (con->state == CON_STATE_OPEN) {\r\nif (!list_empty(&con->out_queue)) {\r\nprepare_write_message(con);\r\ngoto more;\r\n}\r\nif (con->in_seq > con->in_seq_acked) {\r\nprepare_write_ack(con);\r\ngoto more;\r\n}\r\nif (con_flag_test_and_clear(con, CON_FLAG_KEEPALIVE_PENDING)) {\r\nprepare_write_keepalive(con);\r\ngoto more;\r\n}\r\n}\r\ncon_flag_clear(con, CON_FLAG_WRITE_PENDING);\r\ndout("try_write nothing else to write.\n");\r\nret = 0;\r\nout:\r\ndout("try_write done on %p ret %d\n", con, ret);\r\nreturn ret;\r\n}\r\nstatic int try_read(struct ceph_connection *con)\r\n{\r\nint ret = -1;\r\nmore:\r\ndout("try_read start on %p state %lu\n", con, con->state);\r\nif (con->state != CON_STATE_CONNECTING &&\r\ncon->state != CON_STATE_NEGOTIATING &&\r\ncon->state != CON_STATE_OPEN)\r\nreturn 0;\r\nBUG_ON(!con->sock);\r\ndout("try_read tag %d in_base_pos %d\n", (int)con->in_tag,\r\ncon->in_base_pos);\r\nif (con->state == CON_STATE_CONNECTING) {\r\ndout("try_read connecting\n");\r\nret = read_partial_banner(con);\r\nif (ret <= 0)\r\ngoto out;\r\nret = process_banner(con);\r\nif (ret < 0)\r\ngoto out;\r\ncon->state = CON_STATE_NEGOTIATING;\r\nret = prepare_write_connect(con);\r\nif (ret < 0)\r\ngoto out;\r\nprepare_read_connect(con);\r\ngoto out;\r\n}\r\nif (con->state == CON_STATE_NEGOTIATING) {\r\ndout("try_read negotiating\n");\r\nret = read_partial_connect(con);\r\nif (ret <= 0)\r\ngoto out;\r\nret = process_connect(con);\r\nif (ret < 0)\r\ngoto out;\r\ngoto more;\r\n}\r\nWARN_ON(con->state != CON_STATE_OPEN);\r\nif (con->in_base_pos < 0) {\r\nstatic char buf[SKIP_BUF_SIZE];\r\nint skip = min((int) sizeof (buf), -con->in_base_pos);\r\ndout("skipping %d / %d bytes\n", skip, -con->in_base_pos);\r\nret = ceph_tcp_recvmsg(con->sock, buf, skip);\r\nif (ret <= 0)\r\ngoto out;\r\ncon->in_base_pos += ret;\r\nif (con->in_base_pos)\r\ngoto more;\r\n}\r\nif (con->in_tag == CEPH_MSGR_TAG_READY) {\r\nret = ceph_tcp_recvmsg(con->sock, &con->in_tag, 1);\r\nif (ret <= 0)\r\ngoto out;\r\ndout("try_read got tag %d\n", (int)con->in_tag);\r\nswitch (con->in_tag) {\r\ncase CEPH_MSGR_TAG_MSG:\r\nprepare_read_message(con);\r\nbreak;\r\ncase CEPH_MSGR_TAG_ACK:\r\nprepare_read_ack(con);\r\nbreak;\r\ncase CEPH_MSGR_TAG_CLOSE:\r\ncon_close_socket(con);\r\ncon->state = CON_STATE_CLOSED;\r\ngoto out;\r\ndefault:\r\ngoto bad_tag;\r\n}\r\n}\r\nif (con->in_tag == CEPH_MSGR_TAG_MSG) {\r\nret = read_partial_message(con);\r\nif (ret <= 0) {\r\nswitch (ret) {\r\ncase -EBADMSG:\r\ncon->error_msg = "bad crc";\r\nret = -EIO;\r\nbreak;\r\ncase -EIO:\r\ncon->error_msg = "io error";\r\nbreak;\r\n}\r\ngoto out;\r\n}\r\nif (con->in_tag == CEPH_MSGR_TAG_READY)\r\ngoto more;\r\nprocess_message(con);\r\nif (con->state == CON_STATE_OPEN)\r\nprepare_read_tag(con);\r\ngoto more;\r\n}\r\nif (con->in_tag == CEPH_MSGR_TAG_ACK ||\r\ncon->in_tag == CEPH_MSGR_TAG_SEQ) {\r\nret = read_partial_ack(con);\r\nif (ret <= 0)\r\ngoto out;\r\nprocess_ack(con);\r\ngoto more;\r\n}\r\nout:\r\ndout("try_read done on %p ret %d\n", con, ret);\r\nreturn ret;\r\nbad_tag:\r\npr_err("try_read bad con->in_tag = %d\n", (int)con->in_tag);\r\ncon->error_msg = "protocol error, garbage tag";\r\nret = -1;\r\ngoto out;\r\n}\r\nstatic int queue_con_delay(struct ceph_connection *con, unsigned long delay)\r\n{\r\nif (!con->ops->get(con)) {\r\ndout("%s %p ref count 0\n", __func__, con);\r\nreturn -ENOENT;\r\n}\r\nif (!queue_delayed_work(ceph_msgr_wq, &con->work, delay)) {\r\ndout("%s %p - already queued\n", __func__, con);\r\ncon->ops->put(con);\r\nreturn -EBUSY;\r\n}\r\ndout("%s %p %lu\n", __func__, con, delay);\r\nreturn 0;\r\n}\r\nstatic void queue_con(struct ceph_connection *con)\r\n{\r\n(void) queue_con_delay(con, 0);\r\n}\r\nstatic bool con_sock_closed(struct ceph_connection *con)\r\n{\r\nif (!con_flag_test_and_clear(con, CON_FLAG_SOCK_CLOSED))\r\nreturn false;\r\n#define CASE(x) \\r\ncase CON_STATE_ ## x: \\r\ncon->error_msg = "socket closed (con state " #x ")"; \\r\nbreak;\r\nswitch (con->state) {\r\nCASE(CLOSED);\r\nCASE(PREOPEN);\r\nCASE(CONNECTING);\r\nCASE(NEGOTIATING);\r\nCASE(OPEN);\r\nCASE(STANDBY);\r\ndefault:\r\npr_warning("%s con %p unrecognized state %lu\n",\r\n__func__, con, con->state);\r\ncon->error_msg = "unrecognized con state";\r\nBUG();\r\nbreak;\r\n}\r\n#undef CASE\r\nreturn true;\r\n}\r\nstatic bool con_backoff(struct ceph_connection *con)\r\n{\r\nint ret;\r\nif (!con_flag_test_and_clear(con, CON_FLAG_BACKOFF))\r\nreturn false;\r\nret = queue_con_delay(con, round_jiffies_relative(con->delay));\r\nif (ret) {\r\ndout("%s: con %p FAILED to back off %lu\n", __func__,\r\ncon, con->delay);\r\nBUG_ON(ret == -ENOENT);\r\ncon_flag_set(con, CON_FLAG_BACKOFF);\r\n}\r\nreturn true;\r\n}\r\nstatic void con_fault_finish(struct ceph_connection *con)\r\n{\r\nif (con->auth_retry && con->ops->invalidate_authorizer) {\r\ndout("calling invalidate_authorizer()\n");\r\ncon->ops->invalidate_authorizer(con);\r\n}\r\nif (con->ops->fault)\r\ncon->ops->fault(con);\r\n}\r\nstatic void con_work(struct work_struct *work)\r\n{\r\nstruct ceph_connection *con = container_of(work, struct ceph_connection,\r\nwork.work);\r\nbool fault;\r\nmutex_lock(&con->mutex);\r\nwhile (true) {\r\nint ret;\r\nif ((fault = con_sock_closed(con))) {\r\ndout("%s: con %p SOCK_CLOSED\n", __func__, con);\r\nbreak;\r\n}\r\nif (con_backoff(con)) {\r\ndout("%s: con %p BACKOFF\n", __func__, con);\r\nbreak;\r\n}\r\nif (con->state == CON_STATE_STANDBY) {\r\ndout("%s: con %p STANDBY\n", __func__, con);\r\nbreak;\r\n}\r\nif (con->state == CON_STATE_CLOSED) {\r\ndout("%s: con %p CLOSED\n", __func__, con);\r\nBUG_ON(con->sock);\r\nbreak;\r\n}\r\nif (con->state == CON_STATE_PREOPEN) {\r\ndout("%s: con %p PREOPEN\n", __func__, con);\r\nBUG_ON(con->sock);\r\n}\r\nret = try_read(con);\r\nif (ret < 0) {\r\nif (ret == -EAGAIN)\r\ncontinue;\r\ncon->error_msg = "socket error on read";\r\nfault = true;\r\nbreak;\r\n}\r\nret = try_write(con);\r\nif (ret < 0) {\r\nif (ret == -EAGAIN)\r\ncontinue;\r\ncon->error_msg = "socket error on write";\r\nfault = true;\r\n}\r\nbreak;\r\n}\r\nif (fault)\r\ncon_fault(con);\r\nmutex_unlock(&con->mutex);\r\nif (fault)\r\ncon_fault_finish(con);\r\ncon->ops->put(con);\r\n}\r\nstatic void con_fault(struct ceph_connection *con)\r\n{\r\npr_warning("%s%lld %s %s\n", ENTITY_NAME(con->peer_name),\r\nceph_pr_addr(&con->peer_addr.in_addr), con->error_msg);\r\ndout("fault %p state %lu to peer %s\n",\r\ncon, con->state, ceph_pr_addr(&con->peer_addr.in_addr));\r\nWARN_ON(con->state != CON_STATE_CONNECTING &&\r\ncon->state != CON_STATE_NEGOTIATING &&\r\ncon->state != CON_STATE_OPEN);\r\ncon_close_socket(con);\r\nif (con_flag_test(con, CON_FLAG_LOSSYTX)) {\r\ndout("fault on LOSSYTX channel, marking CLOSED\n");\r\ncon->state = CON_STATE_CLOSED;\r\nreturn;\r\n}\r\nif (con->in_msg) {\r\nBUG_ON(con->in_msg->con != con);\r\ncon->in_msg->con = NULL;\r\nceph_msg_put(con->in_msg);\r\ncon->in_msg = NULL;\r\ncon->ops->put(con);\r\n}\r\nlist_splice_init(&con->out_sent, &con->out_queue);\r\nif (list_empty(&con->out_queue) &&\r\n!con_flag_test(con, CON_FLAG_KEEPALIVE_PENDING)) {\r\ndout("fault %p setting STANDBY clearing WRITE_PENDING\n", con);\r\ncon_flag_clear(con, CON_FLAG_WRITE_PENDING);\r\ncon->state = CON_STATE_STANDBY;\r\n} else {\r\ncon->state = CON_STATE_PREOPEN;\r\nif (con->delay == 0)\r\ncon->delay = BASE_DELAY_INTERVAL;\r\nelse if (con->delay < MAX_DELAY_INTERVAL)\r\ncon->delay *= 2;\r\ncon_flag_set(con, CON_FLAG_BACKOFF);\r\nqueue_con(con);\r\n}\r\n}\r\nvoid ceph_messenger_init(struct ceph_messenger *msgr,\r\nstruct ceph_entity_addr *myaddr,\r\nu32 supported_features,\r\nu32 required_features,\r\nbool nocrc)\r\n{\r\nmsgr->supported_features = supported_features;\r\nmsgr->required_features = required_features;\r\nspin_lock_init(&msgr->global_seq_lock);\r\nif (myaddr)\r\nmsgr->inst.addr = *myaddr;\r\nmsgr->inst.addr.type = 0;\r\nget_random_bytes(&msgr->inst.addr.nonce, sizeof(msgr->inst.addr.nonce));\r\nencode_my_addr(msgr);\r\nmsgr->nocrc = nocrc;\r\natomic_set(&msgr->stopping, 0);\r\ndout("%s %p\n", __func__, msgr);\r\n}\r\nstatic void clear_standby(struct ceph_connection *con)\r\n{\r\nif (con->state == CON_STATE_STANDBY) {\r\ndout("clear_standby %p and ++connect_seq\n", con);\r\ncon->state = CON_STATE_PREOPEN;\r\ncon->connect_seq++;\r\nWARN_ON(con_flag_test(con, CON_FLAG_WRITE_PENDING));\r\nWARN_ON(con_flag_test(con, CON_FLAG_KEEPALIVE_PENDING));\r\n}\r\n}\r\nvoid ceph_con_send(struct ceph_connection *con, struct ceph_msg *msg)\r\n{\r\nmsg->hdr.src = con->msgr->inst.name;\r\nBUG_ON(msg->front.iov_len != le32_to_cpu(msg->hdr.front_len));\r\nmsg->needs_out_seq = true;\r\nmutex_lock(&con->mutex);\r\nif (con->state == CON_STATE_CLOSED) {\r\ndout("con_send %p closed, dropping %p\n", con, msg);\r\nceph_msg_put(msg);\r\nmutex_unlock(&con->mutex);\r\nreturn;\r\n}\r\nBUG_ON(msg->con != NULL);\r\nmsg->con = con->ops->get(con);\r\nBUG_ON(msg->con == NULL);\r\nBUG_ON(!list_empty(&msg->list_head));\r\nlist_add_tail(&msg->list_head, &con->out_queue);\r\ndout("----- %p to %s%lld %d=%s len %d+%d+%d -----\n", msg,\r\nENTITY_NAME(con->peer_name), le16_to_cpu(msg->hdr.type),\r\nceph_msg_type_name(le16_to_cpu(msg->hdr.type)),\r\nle32_to_cpu(msg->hdr.front_len),\r\nle32_to_cpu(msg->hdr.middle_len),\r\nle32_to_cpu(msg->hdr.data_len));\r\nclear_standby(con);\r\nmutex_unlock(&con->mutex);\r\nif (con_flag_test_and_set(con, CON_FLAG_WRITE_PENDING) == 0)\r\nqueue_con(con);\r\n}\r\nvoid ceph_msg_revoke(struct ceph_msg *msg)\r\n{\r\nstruct ceph_connection *con = msg->con;\r\nif (!con)\r\nreturn;\r\nmutex_lock(&con->mutex);\r\nif (!list_empty(&msg->list_head)) {\r\ndout("%s %p msg %p - was on queue\n", __func__, con, msg);\r\nlist_del_init(&msg->list_head);\r\nBUG_ON(msg->con == NULL);\r\nmsg->con->ops->put(msg->con);\r\nmsg->con = NULL;\r\nmsg->hdr.seq = 0;\r\nceph_msg_put(msg);\r\n}\r\nif (con->out_msg == msg) {\r\ndout("%s %p msg %p - was sending\n", __func__, con, msg);\r\ncon->out_msg = NULL;\r\nif (con->out_kvec_is_msg) {\r\ncon->out_skip = con->out_kvec_bytes;\r\ncon->out_kvec_is_msg = false;\r\n}\r\nmsg->hdr.seq = 0;\r\nceph_msg_put(msg);\r\n}\r\nmutex_unlock(&con->mutex);\r\n}\r\nvoid ceph_msg_revoke_incoming(struct ceph_msg *msg)\r\n{\r\nstruct ceph_connection *con;\r\nBUG_ON(msg == NULL);\r\nif (!msg->con) {\r\ndout("%s msg %p null con\n", __func__, msg);\r\nreturn;\r\n}\r\ncon = msg->con;\r\nmutex_lock(&con->mutex);\r\nif (con->in_msg == msg) {\r\nunsigned int front_len = le32_to_cpu(con->in_hdr.front_len);\r\nunsigned int middle_len = le32_to_cpu(con->in_hdr.middle_len);\r\nunsigned int data_len = le32_to_cpu(con->in_hdr.data_len);\r\ndout("%s %p msg %p revoked\n", __func__, con, msg);\r\ncon->in_base_pos = con->in_base_pos -\r\nsizeof(struct ceph_msg_header) -\r\nfront_len -\r\nmiddle_len -\r\ndata_len -\r\nsizeof(struct ceph_msg_footer);\r\nceph_msg_put(con->in_msg);\r\ncon->in_msg = NULL;\r\ncon->in_tag = CEPH_MSGR_TAG_READY;\r\ncon->in_seq++;\r\n} else {\r\ndout("%s %p in_msg %p msg %p no-op\n",\r\n__func__, con, con->in_msg, msg);\r\n}\r\nmutex_unlock(&con->mutex);\r\n}\r\nvoid ceph_con_keepalive(struct ceph_connection *con)\r\n{\r\ndout("con_keepalive %p\n", con);\r\nmutex_lock(&con->mutex);\r\nclear_standby(con);\r\nmutex_unlock(&con->mutex);\r\nif (con_flag_test_and_set(con, CON_FLAG_KEEPALIVE_PENDING) == 0 &&\r\ncon_flag_test_and_set(con, CON_FLAG_WRITE_PENDING) == 0)\r\nqueue_con(con);\r\n}\r\nstatic struct ceph_msg_data *ceph_msg_data_create(enum ceph_msg_data_type type)\r\n{\r\nstruct ceph_msg_data *data;\r\nif (WARN_ON(!ceph_msg_data_type_valid(type)))\r\nreturn NULL;\r\ndata = kmem_cache_zalloc(ceph_msg_data_cache, GFP_NOFS);\r\nif (data)\r\ndata->type = type;\r\nINIT_LIST_HEAD(&data->links);\r\nreturn data;\r\n}\r\nstatic void ceph_msg_data_destroy(struct ceph_msg_data *data)\r\n{\r\nif (!data)\r\nreturn;\r\nWARN_ON(!list_empty(&data->links));\r\nif (data->type == CEPH_MSG_DATA_PAGELIST) {\r\nceph_pagelist_release(data->pagelist);\r\nkfree(data->pagelist);\r\n}\r\nkmem_cache_free(ceph_msg_data_cache, data);\r\n}\r\nvoid ceph_msg_data_add_pages(struct ceph_msg *msg, struct page **pages,\r\nsize_t length, size_t alignment)\r\n{\r\nstruct ceph_msg_data *data;\r\nBUG_ON(!pages);\r\nBUG_ON(!length);\r\ndata = ceph_msg_data_create(CEPH_MSG_DATA_PAGES);\r\nBUG_ON(!data);\r\ndata->pages = pages;\r\ndata->length = length;\r\ndata->alignment = alignment & ~PAGE_MASK;\r\nlist_add_tail(&data->links, &msg->data);\r\nmsg->data_length += length;\r\n}\r\nvoid ceph_msg_data_add_pagelist(struct ceph_msg *msg,\r\nstruct ceph_pagelist *pagelist)\r\n{\r\nstruct ceph_msg_data *data;\r\nBUG_ON(!pagelist);\r\nBUG_ON(!pagelist->length);\r\ndata = ceph_msg_data_create(CEPH_MSG_DATA_PAGELIST);\r\nBUG_ON(!data);\r\ndata->pagelist = pagelist;\r\nlist_add_tail(&data->links, &msg->data);\r\nmsg->data_length += pagelist->length;\r\n}\r\nvoid ceph_msg_data_add_bio(struct ceph_msg *msg, struct bio *bio,\r\nsize_t length)\r\n{\r\nstruct ceph_msg_data *data;\r\nBUG_ON(!bio);\r\ndata = ceph_msg_data_create(CEPH_MSG_DATA_BIO);\r\nBUG_ON(!data);\r\ndata->bio = bio;\r\ndata->bio_length = length;\r\nlist_add_tail(&data->links, &msg->data);\r\nmsg->data_length += length;\r\n}\r\nstruct ceph_msg *ceph_msg_new(int type, int front_len, gfp_t flags,\r\nbool can_fail)\r\n{\r\nstruct ceph_msg *m;\r\nm = kmem_cache_zalloc(ceph_msg_cache, flags);\r\nif (m == NULL)\r\ngoto out;\r\nm->hdr.type = cpu_to_le16(type);\r\nm->hdr.priority = cpu_to_le16(CEPH_MSG_PRIO_DEFAULT);\r\nm->hdr.front_len = cpu_to_le32(front_len);\r\nINIT_LIST_HEAD(&m->list_head);\r\nkref_init(&m->kref);\r\nINIT_LIST_HEAD(&m->data);\r\nm->front_max = front_len;\r\nif (front_len) {\r\nif (front_len > PAGE_CACHE_SIZE) {\r\nm->front.iov_base = __vmalloc(front_len, flags,\r\nPAGE_KERNEL);\r\nm->front_is_vmalloc = true;\r\n} else {\r\nm->front.iov_base = kmalloc(front_len, flags);\r\n}\r\nif (m->front.iov_base == NULL) {\r\ndout("ceph_msg_new can't allocate %d bytes\n",\r\nfront_len);\r\ngoto out2;\r\n}\r\n} else {\r\nm->front.iov_base = NULL;\r\n}\r\nm->front.iov_len = front_len;\r\ndout("ceph_msg_new %p front %d\n", m, front_len);\r\nreturn m;\r\nout2:\r\nceph_msg_put(m);\r\nout:\r\nif (!can_fail) {\r\npr_err("msg_new can't create type %d front %d\n", type,\r\nfront_len);\r\nWARN_ON(1);\r\n} else {\r\ndout("msg_new can't create type %d front %d\n", type,\r\nfront_len);\r\n}\r\nreturn NULL;\r\n}\r\nstatic int ceph_alloc_middle(struct ceph_connection *con, struct ceph_msg *msg)\r\n{\r\nint type = le16_to_cpu(msg->hdr.type);\r\nint middle_len = le32_to_cpu(msg->hdr.middle_len);\r\ndout("alloc_middle %p type %d %s middle_len %d\n", msg, type,\r\nceph_msg_type_name(type), middle_len);\r\nBUG_ON(!middle_len);\r\nBUG_ON(msg->middle);\r\nmsg->middle = ceph_buffer_new(middle_len, GFP_NOFS);\r\nif (!msg->middle)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int ceph_con_in_msg_alloc(struct ceph_connection *con, int *skip)\r\n{\r\nstruct ceph_msg_header *hdr = &con->in_hdr;\r\nint middle_len = le32_to_cpu(hdr->middle_len);\r\nstruct ceph_msg *msg;\r\nint ret = 0;\r\nBUG_ON(con->in_msg != NULL);\r\nBUG_ON(!con->ops->alloc_msg);\r\nmutex_unlock(&con->mutex);\r\nmsg = con->ops->alloc_msg(con, hdr, skip);\r\nmutex_lock(&con->mutex);\r\nif (con->state != CON_STATE_OPEN) {\r\nif (msg)\r\nceph_msg_put(msg);\r\nreturn -EAGAIN;\r\n}\r\nif (msg) {\r\nBUG_ON(*skip);\r\ncon->in_msg = msg;\r\ncon->in_msg->con = con->ops->get(con);\r\nBUG_ON(con->in_msg->con == NULL);\r\n} else {\r\nif (*skip)\r\nreturn 0;\r\ncon->error_msg = "error allocating memory for incoming message";\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(&con->in_msg->hdr, &con->in_hdr, sizeof(con->in_hdr));\r\nif (middle_len && !con->in_msg->middle) {\r\nret = ceph_alloc_middle(con, con->in_msg);\r\nif (ret < 0) {\r\nceph_msg_put(con->in_msg);\r\ncon->in_msg = NULL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid ceph_msg_kfree(struct ceph_msg *m)\r\n{\r\ndout("msg_kfree %p\n", m);\r\nif (m->front_is_vmalloc)\r\nvfree(m->front.iov_base);\r\nelse\r\nkfree(m->front.iov_base);\r\nkmem_cache_free(ceph_msg_cache, m);\r\n}\r\nvoid ceph_msg_last_put(struct kref *kref)\r\n{\r\nstruct ceph_msg *m = container_of(kref, struct ceph_msg, kref);\r\nLIST_HEAD(data);\r\nstruct list_head *links;\r\nstruct list_head *next;\r\ndout("ceph_msg_put last one on %p\n", m);\r\nWARN_ON(!list_empty(&m->list_head));\r\nif (m->middle) {\r\nceph_buffer_put(m->middle);\r\nm->middle = NULL;\r\n}\r\nlist_splice_init(&m->data, &data);\r\nlist_for_each_safe(links, next, &data) {\r\nstruct ceph_msg_data *data;\r\ndata = list_entry(links, struct ceph_msg_data, links);\r\nlist_del_init(links);\r\nceph_msg_data_destroy(data);\r\n}\r\nm->data_length = 0;\r\nif (m->pool)\r\nceph_msgpool_put(m->pool, m);\r\nelse\r\nceph_msg_kfree(m);\r\n}\r\nvoid ceph_msg_dump(struct ceph_msg *msg)\r\n{\r\npr_debug("msg_dump %p (front_max %d length %zd)\n", msg,\r\nmsg->front_max, msg->data_length);\r\nprint_hex_dump(KERN_DEBUG, "header: ",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\n&msg->hdr, sizeof(msg->hdr), true);\r\nprint_hex_dump(KERN_DEBUG, " front: ",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\nmsg->front.iov_base, msg->front.iov_len, true);\r\nif (msg->middle)\r\nprint_hex_dump(KERN_DEBUG, "middle: ",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\nmsg->middle->vec.iov_base,\r\nmsg->middle->vec.iov_len, true);\r\nprint_hex_dump(KERN_DEBUG, "footer: ",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\n&msg->footer, sizeof(msg->footer), true);\r\n}
