static void e_series_win_out(struct comedi_device *dev, uint16_t data, int reg)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&devpriv->window_lock, flags);\r\nni_writew(reg, Window_Address);\r\nni_writew(data, Window_Data);\r\nspin_unlock_irqrestore(&devpriv->window_lock, flags);\r\n}\r\nstatic uint16_t e_series_win_in(struct comedi_device *dev, int reg)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned long flags;\r\nuint16_t ret;\r\nspin_lock_irqsave(&devpriv->window_lock, flags);\r\nni_writew(reg, Window_Address);\r\nret = ni_readw(Window_Data);\r\nspin_unlock_irqrestore(&devpriv->window_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void m_series_stc_writew(struct comedi_device *dev, uint16_t data,\r\nint reg)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned offset;\r\nswitch (reg) {\r\ncase ADC_FIFO_Clear:\r\noffset = M_Offset_AI_FIFO_Clear;\r\nbreak;\r\ncase AI_Command_1_Register:\r\noffset = M_Offset_AI_Command_1;\r\nbreak;\r\ncase AI_Command_2_Register:\r\noffset = M_Offset_AI_Command_2;\r\nbreak;\r\ncase AI_Mode_1_Register:\r\noffset = M_Offset_AI_Mode_1;\r\nbreak;\r\ncase AI_Mode_2_Register:\r\noffset = M_Offset_AI_Mode_2;\r\nbreak;\r\ncase AI_Mode_3_Register:\r\noffset = M_Offset_AI_Mode_3;\r\nbreak;\r\ncase AI_Output_Control_Register:\r\noffset = M_Offset_AI_Output_Control;\r\nbreak;\r\ncase AI_Personal_Register:\r\noffset = M_Offset_AI_Personal;\r\nbreak;\r\ncase AI_SI2_Load_A_Register:\r\nni_writel(data, M_Offset_AI_SI2_Load_A);\r\nreturn;\r\nbreak;\r\ncase AI_SI2_Load_B_Register:\r\nni_writel(data, M_Offset_AI_SI2_Load_B);\r\nreturn;\r\nbreak;\r\ncase AI_START_STOP_Select_Register:\r\noffset = M_Offset_AI_START_STOP_Select;\r\nbreak;\r\ncase AI_Trigger_Select_Register:\r\noffset = M_Offset_AI_Trigger_Select;\r\nbreak;\r\ncase Analog_Trigger_Etc_Register:\r\noffset = M_Offset_Analog_Trigger_Etc;\r\nbreak;\r\ncase AO_Command_1_Register:\r\noffset = M_Offset_AO_Command_1;\r\nbreak;\r\ncase AO_Command_2_Register:\r\noffset = M_Offset_AO_Command_2;\r\nbreak;\r\ncase AO_Mode_1_Register:\r\noffset = M_Offset_AO_Mode_1;\r\nbreak;\r\ncase AO_Mode_2_Register:\r\noffset = M_Offset_AO_Mode_2;\r\nbreak;\r\ncase AO_Mode_3_Register:\r\noffset = M_Offset_AO_Mode_3;\r\nbreak;\r\ncase AO_Output_Control_Register:\r\noffset = M_Offset_AO_Output_Control;\r\nbreak;\r\ncase AO_Personal_Register:\r\noffset = M_Offset_AO_Personal;\r\nbreak;\r\ncase AO_Start_Select_Register:\r\noffset = M_Offset_AO_Start_Select;\r\nbreak;\r\ncase AO_Trigger_Select_Register:\r\noffset = M_Offset_AO_Trigger_Select;\r\nbreak;\r\ncase Clock_and_FOUT_Register:\r\noffset = M_Offset_Clock_and_FOUT;\r\nbreak;\r\ncase Configuration_Memory_Clear:\r\noffset = M_Offset_Configuration_Memory_Clear;\r\nbreak;\r\ncase DAC_FIFO_Clear:\r\noffset = M_Offset_AO_FIFO_Clear;\r\nbreak;\r\ncase DIO_Control_Register:\r\nprintk\r\n("%s: FIXME: register 0x%x does not map cleanly on to m-series boards.\n",\r\n__func__, reg);\r\nreturn;\r\nbreak;\r\ncase G_Autoincrement_Register(0):\r\noffset = M_Offset_G0_Autoincrement;\r\nbreak;\r\ncase G_Autoincrement_Register(1):\r\noffset = M_Offset_G1_Autoincrement;\r\nbreak;\r\ncase G_Command_Register(0):\r\noffset = M_Offset_G0_Command;\r\nbreak;\r\ncase G_Command_Register(1):\r\noffset = M_Offset_G1_Command;\r\nbreak;\r\ncase G_Input_Select_Register(0):\r\noffset = M_Offset_G0_Input_Select;\r\nbreak;\r\ncase G_Input_Select_Register(1):\r\noffset = M_Offset_G1_Input_Select;\r\nbreak;\r\ncase G_Mode_Register(0):\r\noffset = M_Offset_G0_Mode;\r\nbreak;\r\ncase G_Mode_Register(1):\r\noffset = M_Offset_G1_Mode;\r\nbreak;\r\ncase Interrupt_A_Ack_Register:\r\noffset = M_Offset_Interrupt_A_Ack;\r\nbreak;\r\ncase Interrupt_A_Enable_Register:\r\noffset = M_Offset_Interrupt_A_Enable;\r\nbreak;\r\ncase Interrupt_B_Ack_Register:\r\noffset = M_Offset_Interrupt_B_Ack;\r\nbreak;\r\ncase Interrupt_B_Enable_Register:\r\noffset = M_Offset_Interrupt_B_Enable;\r\nbreak;\r\ncase Interrupt_Control_Register:\r\noffset = M_Offset_Interrupt_Control;\r\nbreak;\r\ncase IO_Bidirection_Pin_Register:\r\noffset = M_Offset_IO_Bidirection_Pin;\r\nbreak;\r\ncase Joint_Reset_Register:\r\noffset = M_Offset_Joint_Reset;\r\nbreak;\r\ncase RTSI_Trig_A_Output_Register:\r\noffset = M_Offset_RTSI_Trig_A_Output;\r\nbreak;\r\ncase RTSI_Trig_B_Output_Register:\r\noffset = M_Offset_RTSI_Trig_B_Output;\r\nbreak;\r\ncase RTSI_Trig_Direction_Register:\r\noffset = M_Offset_RTSI_Trig_Direction;\r\nbreak;\r\ndefault:\r\ndev_warn(dev->class_dev,\r\n"%s: bug! unhandled register=0x%x in switch.\n",\r\n__func__, reg);\r\nBUG();\r\nreturn;\r\nbreak;\r\n}\r\nni_writew(data, offset);\r\n}\r\nstatic uint16_t m_series_stc_readw(struct comedi_device *dev, int reg)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned offset;\r\nswitch (reg) {\r\ncase AI_Status_1_Register:\r\noffset = M_Offset_AI_Status_1;\r\nbreak;\r\ncase AO_Status_1_Register:\r\noffset = M_Offset_AO_Status_1;\r\nbreak;\r\ncase AO_Status_2_Register:\r\noffset = M_Offset_AO_Status_2;\r\nbreak;\r\ncase DIO_Serial_Input_Register:\r\nreturn ni_readb(M_Offset_SCXI_Serial_Data_In);\r\nbreak;\r\ncase Joint_Status_1_Register:\r\noffset = M_Offset_Joint_Status_1;\r\nbreak;\r\ncase Joint_Status_2_Register:\r\noffset = M_Offset_Joint_Status_2;\r\nbreak;\r\ncase G_Status_Register:\r\noffset = M_Offset_G01_Status;\r\nbreak;\r\ndefault:\r\ndev_warn(dev->class_dev,\r\n"%s: bug! unhandled register=0x%x in switch.\n",\r\n__func__, reg);\r\nBUG();\r\nreturn 0;\r\nbreak;\r\n}\r\nreturn ni_readw(offset);\r\n}\r\nstatic void m_series_stc_writel(struct comedi_device *dev, uint32_t data,\r\nint reg)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned offset;\r\nswitch (reg) {\r\ncase AI_SC_Load_A_Registers:\r\noffset = M_Offset_AI_SC_Load_A;\r\nbreak;\r\ncase AI_SI_Load_A_Registers:\r\noffset = M_Offset_AI_SI_Load_A;\r\nbreak;\r\ncase AO_BC_Load_A_Register:\r\noffset = M_Offset_AO_BC_Load_A;\r\nbreak;\r\ncase AO_UC_Load_A_Register:\r\noffset = M_Offset_AO_UC_Load_A;\r\nbreak;\r\ncase AO_UI_Load_A_Register:\r\noffset = M_Offset_AO_UI_Load_A;\r\nbreak;\r\ncase G_Load_A_Register(0):\r\noffset = M_Offset_G0_Load_A;\r\nbreak;\r\ncase G_Load_A_Register(1):\r\noffset = M_Offset_G1_Load_A;\r\nbreak;\r\ncase G_Load_B_Register(0):\r\noffset = M_Offset_G0_Load_B;\r\nbreak;\r\ncase G_Load_B_Register(1):\r\noffset = M_Offset_G1_Load_B;\r\nbreak;\r\ndefault:\r\ndev_warn(dev->class_dev,\r\n"%s: bug! unhandled register=0x%x in switch.\n",\r\n__func__, reg);\r\nBUG();\r\nreturn;\r\nbreak;\r\n}\r\nni_writel(data, offset);\r\n}\r\nstatic uint32_t m_series_stc_readl(struct comedi_device *dev, int reg)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nunsigned offset;\r\nswitch (reg) {\r\ncase G_HW_Save_Register(0):\r\noffset = M_Offset_G0_HW_Save;\r\nbreak;\r\ncase G_HW_Save_Register(1):\r\noffset = M_Offset_G1_HW_Save;\r\nbreak;\r\ncase G_Save_Register(0):\r\noffset = M_Offset_G0_Save;\r\nbreak;\r\ncase G_Save_Register(1):\r\noffset = M_Offset_G1_Save;\r\nbreak;\r\ndefault:\r\ndev_warn(dev->class_dev,\r\n"%s: bug! unhandled register=0x%x in switch.\n",\r\n__func__, reg);\r\nBUG();\r\nreturn 0;\r\nbreak;\r\n}\r\nreturn ni_readl(offset);\r\n}\r\nstatic void m_series_init_eeprom_buffer(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nstatic const int Start_Cal_EEPROM = 0x400;\r\nstatic const unsigned window_size = 10;\r\nstatic const int serial_number_eeprom_offset = 0x4;\r\nstatic const int serial_number_eeprom_length = 0x4;\r\nunsigned old_iodwbsr_bits;\r\nunsigned old_iodwbsr1_bits;\r\nunsigned old_iodwcr1_bits;\r\nint i;\r\nold_iodwbsr_bits = readl(devpriv->mite->mite_io_addr + MITE_IODWBSR);\r\nold_iodwbsr1_bits = readl(devpriv->mite->mite_io_addr + MITE_IODWBSR_1);\r\nold_iodwcr1_bits = readl(devpriv->mite->mite_io_addr + MITE_IODWCR_1);\r\nwritel(0x0, devpriv->mite->mite_io_addr + MITE_IODWBSR);\r\nwritel(((0x80 | window_size) | devpriv->mite->daq_phys_addr),\r\ndevpriv->mite->mite_io_addr + MITE_IODWBSR_1);\r\nwritel(0x1 | old_iodwcr1_bits,\r\ndevpriv->mite->mite_io_addr + MITE_IODWCR_1);\r\nwritel(0xf, devpriv->mite->mite_io_addr + 0x30);\r\nBUG_ON(serial_number_eeprom_length > sizeof(devpriv->serial_number));\r\nfor (i = 0; i < serial_number_eeprom_length; ++i) {\r\nchar *byte_ptr = (char *)&devpriv->serial_number + i;\r\n*byte_ptr = ni_readb(serial_number_eeprom_offset + i);\r\n}\r\ndevpriv->serial_number = be32_to_cpu(devpriv->serial_number);\r\nfor (i = 0; i < M_SERIES_EEPROM_SIZE; ++i)\r\ndevpriv->eeprom_buffer[i] = ni_readb(Start_Cal_EEPROM + i);\r\nwritel(old_iodwbsr1_bits, devpriv->mite->mite_io_addr + MITE_IODWBSR_1);\r\nwritel(old_iodwbsr_bits, devpriv->mite->mite_io_addr + MITE_IODWBSR);\r\nwritel(old_iodwcr1_bits, devpriv->mite->mite_io_addr + MITE_IODWCR_1);\r\nwritel(0x0, devpriv->mite->mite_io_addr + 0x30);\r\n}\r\nstatic void init_6143(struct comedi_device *dev)\r\n{\r\nconst struct ni_board_struct *board = comedi_board(dev);\r\nstruct ni_private *devpriv = dev->private;\r\ndevpriv->stc_writew(dev, 0, Interrupt_Control_Register);\r\nni_writeb(0x00, Magic_6143);\r\nni_writeb(0x80, PipelineDelay_6143);\r\nni_writeb(0x00, EOC_Set_6143);\r\nni_writel(board->ai_fifo_depth / 2, AIFIFO_Flag_6143);\r\ndevpriv->ai_calib_source_enabled = 0;\r\nni_writew(devpriv->ai_calib_source | Calibration_Channel_6143_RelayOff,\r\nCalibration_Channel_6143);\r\nni_writew(devpriv->ai_calib_source, Calibration_Channel_6143);\r\n}\r\nstatic void pcimio_detach(struct comedi_device *dev)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nmio_common_detach(dev);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (devpriv) {\r\nmite_free_ring(devpriv->ai_mite_ring);\r\nmite_free_ring(devpriv->ao_mite_ring);\r\nmite_free_ring(devpriv->cdo_mite_ring);\r\nmite_free_ring(devpriv->gpct_mite_ring[0]);\r\nmite_free_ring(devpriv->gpct_mite_ring[1]);\r\nif (devpriv->mite) {\r\nmite_unsetup(devpriv->mite);\r\nmite_free(devpriv->mite);\r\n}\r\n}\r\ncomedi_pci_disable(dev);\r\n}\r\nstatic int pcimio_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct ni_board_struct *board = NULL;\r\nstruct ni_private *devpriv;\r\nint ret;\r\nif (context < ARRAY_SIZE(ni_boards))\r\nboard = &ni_boards[context];\r\nif (!board)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\nret = ni_alloc_private(dev);\r\nif (ret)\r\nreturn ret;\r\ndevpriv = dev->private;\r\ndevpriv->mite = mite_alloc(pcidev);\r\nif (!devpriv->mite)\r\nreturn -ENOMEM;\r\nif (board->reg_type & ni_reg_m_series_mask) {\r\ndevpriv->stc_writew = &m_series_stc_writew;\r\ndevpriv->stc_readw = &m_series_stc_readw;\r\ndevpriv->stc_writel = &m_series_stc_writel;\r\ndevpriv->stc_readl = &m_series_stc_readl;\r\n} else {\r\ndevpriv->stc_writew = &e_series_win_out;\r\ndevpriv->stc_readw = &e_series_win_in;\r\ndevpriv->stc_writel = &win_out2;\r\ndevpriv->stc_readl = &win_in2;\r\n}\r\nret = mite_setup(devpriv->mite);\r\nif (ret < 0) {\r\npr_warn("error setting up mite\n");\r\nreturn ret;\r\n}\r\ndevpriv->ai_mite_ring = mite_alloc_ring(devpriv->mite);\r\nif (devpriv->ai_mite_ring == NULL)\r\nreturn -ENOMEM;\r\ndevpriv->ao_mite_ring = mite_alloc_ring(devpriv->mite);\r\nif (devpriv->ao_mite_ring == NULL)\r\nreturn -ENOMEM;\r\ndevpriv->cdo_mite_ring = mite_alloc_ring(devpriv->mite);\r\nif (devpriv->cdo_mite_ring == NULL)\r\nreturn -ENOMEM;\r\ndevpriv->gpct_mite_ring[0] = mite_alloc_ring(devpriv->mite);\r\nif (devpriv->gpct_mite_ring[0] == NULL)\r\nreturn -ENOMEM;\r\ndevpriv->gpct_mite_ring[1] = mite_alloc_ring(devpriv->mite);\r\nif (devpriv->gpct_mite_ring[1] == NULL)\r\nreturn -ENOMEM;\r\nif (board->reg_type & ni_reg_m_series_mask)\r\nm_series_init_eeprom_buffer(dev);\r\nif (board->reg_type == ni_reg_6143)\r\ninit_6143(dev);\r\ndev->irq = mite_irq(devpriv->mite);\r\nif (dev->irq == 0) {\r\npr_warn("unknown irq (bad)\n");\r\n} else {\r\npr_debug("( irq = %u )\n", dev->irq);\r\nret = request_irq(dev->irq, ni_E_interrupt, NI_E_IRQ_FLAGS,\r\nDRV_NAME, dev);\r\nif (ret < 0) {\r\npr_warn("irq not available\n");\r\ndev->irq = 0;\r\n}\r\n}\r\nret = ni_E_init(dev);\r\nif (ret < 0)\r\nreturn ret;\r\ndev->subdevices[NI_AI_SUBDEV].buf_change = &pcimio_ai_change;\r\ndev->subdevices[NI_AO_SUBDEV].buf_change = &pcimio_ao_change;\r\ndev->subdevices[NI_GPCT_SUBDEV(0)].buf_change = &pcimio_gpct0_change;\r\ndev->subdevices[NI_GPCT_SUBDEV(1)].buf_change = &pcimio_gpct1_change;\r\ndev->subdevices[NI_DIO_SUBDEV].buf_change = &pcimio_dio_change;\r\nreturn ret;\r\n}\r\nstatic int pcimio_ai_change(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, unsigned long new_size)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nint ret;\r\nret = mite_buf_change(devpriv->ai_mite_ring, s->async);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int pcimio_ao_change(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, unsigned long new_size)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nint ret;\r\nret = mite_buf_change(devpriv->ao_mite_ring, s->async);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int pcimio_gpct0_change(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned long new_size)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nint ret;\r\nret = mite_buf_change(devpriv->gpct_mite_ring[0], s->async);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int pcimio_gpct1_change(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned long new_size)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nint ret;\r\nret = mite_buf_change(devpriv->gpct_mite_ring[1], s->async);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int pcimio_dio_change(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, unsigned long new_size)\r\n{\r\nstruct ni_private *devpriv = dev->private;\r\nint ret;\r\nret = mite_buf_change(devpriv->cdo_mite_ring, s->async);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ni_pcimio_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &ni_pcimio_driver, id->driver_data);\r\n}
