static void snd_es1938_mixer_write(struct es1938 *chip, unsigned char reg, unsigned char val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->mixer_lock, flags);\r\noutb(reg, SLSB_REG(chip, MIXERADDR));\r\noutb(val, SLSB_REG(chip, MIXERDATA));\r\nspin_unlock_irqrestore(&chip->mixer_lock, flags);\r\n#ifdef REG_DEBUG\r\nsnd_printk(KERN_DEBUG "Mixer reg %02x set to %02x\n", reg, val);\r\n#endif\r\n}\r\nstatic int snd_es1938_mixer_read(struct es1938 *chip, unsigned char reg)\r\n{\r\nint data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->mixer_lock, flags);\r\noutb(reg, SLSB_REG(chip, MIXERADDR));\r\ndata = inb(SLSB_REG(chip, MIXERDATA));\r\nspin_unlock_irqrestore(&chip->mixer_lock, flags);\r\n#ifdef REG_DEBUG\r\nsnd_printk(KERN_DEBUG "Mixer reg %02x now is %02x\n", reg, data);\r\n#endif\r\nreturn data;\r\n}\r\nstatic int snd_es1938_mixer_bits(struct es1938 *chip, unsigned char reg,\r\nunsigned char mask, unsigned char val)\r\n{\r\nunsigned long flags;\r\nunsigned char old, new, oval;\r\nspin_lock_irqsave(&chip->mixer_lock, flags);\r\noutb(reg, SLSB_REG(chip, MIXERADDR));\r\nold = inb(SLSB_REG(chip, MIXERDATA));\r\noval = old & mask;\r\nif (val != oval) {\r\nnew = (old & ~mask) | (val & mask);\r\noutb(new, SLSB_REG(chip, MIXERDATA));\r\n#ifdef REG_DEBUG\r\nsnd_printk(KERN_DEBUG "Mixer reg %02x was %02x, set to %02x\n",\r\nreg, old, new);\r\n#endif\r\n}\r\nspin_unlock_irqrestore(&chip->mixer_lock, flags);\r\nreturn oval;\r\n}\r\nstatic void snd_es1938_write_cmd(struct es1938 *chip, unsigned char cmd)\r\n{\r\nint i;\r\nunsigned char v;\r\nfor (i = 0; i < WRITE_LOOP_TIMEOUT; i++) {\r\nif (!(v = inb(SLSB_REG(chip, READSTATUS)) & 0x80)) {\r\noutb(cmd, SLSB_REG(chip, WRITEDATA));\r\nreturn;\r\n}\r\n}\r\nprintk(KERN_ERR "snd_es1938_write_cmd timeout (0x02%x/0x02%x)\n", cmd, v);\r\n}\r\nstatic int snd_es1938_get_byte(struct es1938 *chip)\r\n{\r\nint i;\r\nunsigned char v;\r\nfor (i = GET_LOOP_TIMEOUT; i; i--)\r\nif ((v = inb(SLSB_REG(chip, STATUS))) & 0x80)\r\nreturn inb(SLSB_REG(chip, READDATA));\r\nsnd_printk(KERN_ERR "get_byte timeout: status 0x02%x\n", v);\r\nreturn -ENODEV;\r\n}\r\nstatic void snd_es1938_write(struct es1938 *chip, unsigned char reg, unsigned char val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_es1938_write_cmd(chip, reg);\r\nsnd_es1938_write_cmd(chip, val);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n#ifdef REG_DEBUG\r\nsnd_printk(KERN_DEBUG "Reg %02x set to %02x\n", reg, val);\r\n#endif\r\n}\r\nstatic unsigned char snd_es1938_read(struct es1938 *chip, unsigned char reg)\r\n{\r\nunsigned char val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_es1938_write_cmd(chip, ESS_CMD_READREG);\r\nsnd_es1938_write_cmd(chip, reg);\r\nval = snd_es1938_get_byte(chip);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n#ifdef REG_DEBUG\r\nsnd_printk(KERN_DEBUG "Reg %02x now is %02x\n", reg, val);\r\n#endif\r\nreturn val;\r\n}\r\nstatic int snd_es1938_bits(struct es1938 *chip, unsigned char reg, unsigned char mask,\r\nunsigned char val)\r\n{\r\nunsigned long flags;\r\nunsigned char old, new, oval;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_es1938_write_cmd(chip, ESS_CMD_READREG);\r\nsnd_es1938_write_cmd(chip, reg);\r\nold = snd_es1938_get_byte(chip);\r\noval = old & mask;\r\nif (val != oval) {\r\nsnd_es1938_write_cmd(chip, reg);\r\nnew = (old & ~mask) | (val & mask);\r\nsnd_es1938_write_cmd(chip, new);\r\n#ifdef REG_DEBUG\r\nsnd_printk(KERN_DEBUG "Reg %02x was %02x, set to %02x\n",\r\nreg, old, new);\r\n#endif\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn oval;\r\n}\r\nstatic void snd_es1938_reset(struct es1938 *chip)\r\n{\r\nint i;\r\noutb(3, SLSB_REG(chip, RESET));\r\ninb(SLSB_REG(chip, RESET));\r\noutb(0, SLSB_REG(chip, RESET));\r\nfor (i = 0; i < RESET_LOOP_TIMEOUT; i++) {\r\nif (inb(SLSB_REG(chip, STATUS)) & 0x80) {\r\nif (inb(SLSB_REG(chip, READDATA)) == 0xaa)\r\ngoto __next;\r\n}\r\n}\r\nsnd_printk(KERN_ERR "ESS Solo-1 reset failed\n");\r\n__next:\r\nsnd_es1938_write_cmd(chip, ESS_CMD_ENABLEEXT);\r\nsnd_es1938_write(chip, ESS_CMD_DMATYPE, 2);\r\nsnd_es1938_mixer_write(chip, ESSSB_IREG_AUDIO2MODE, 0x32);\r\nsnd_es1938_bits(chip, ESS_CMD_IRQCONTROL, 0xf0, 0x50);\r\nsnd_es1938_bits(chip, ESS_CMD_DRQCONTROL, 0xf0, 0x50);\r\nsnd_es1938_write_cmd(chip, ESS_CMD_ENABLEAUDIO1);\r\nsnd_es1938_mixer_write(chip, 0x54, 0x8f);\r\nsnd_es1938_mixer_write(chip, 0x56, 0x95);\r\nsnd_es1938_mixer_write(chip, 0x58, 0x94);\r\nsnd_es1938_mixer_write(chip, 0x5a, 0x80);\r\n}\r\nstatic void snd_es1938_reset_fifo(struct es1938 *chip)\r\n{\r\noutb(2, SLSB_REG(chip, RESET));\r\noutb(0, SLSB_REG(chip, RESET));\r\n}\r\nstatic void snd_es1938_rate_set(struct es1938 *chip,\r\nstruct snd_pcm_substream *substream,\r\nint mode)\r\n{\r\nunsigned int bits, div0;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (runtime->rate_num == clocks[0].num)\r\nbits = 128 - runtime->rate_den;\r\nelse\r\nbits = 256 - runtime->rate_den;\r\ndiv0 = 256 - 7160000*20/(8*82*runtime->rate);\r\nif (mode == DAC2) {\r\nsnd_es1938_mixer_write(chip, 0x70, bits);\r\nsnd_es1938_mixer_write(chip, 0x72, div0);\r\n} else {\r\nsnd_es1938_write(chip, 0xA1, bits);\r\nsnd_es1938_write(chip, 0xA2, div0);\r\n}\r\n}\r\nstatic void snd_es1938_playback1_setdma(struct es1938 *chip)\r\n{\r\noutb(0x00, SLIO_REG(chip, AUDIO2MODE));\r\noutl(chip->dma2_start, SLIO_REG(chip, AUDIO2DMAADDR));\r\noutw(0, SLIO_REG(chip, AUDIO2DMACOUNT));\r\noutw(chip->dma2_size, SLIO_REG(chip, AUDIO2DMACOUNT));\r\n}\r\nstatic void snd_es1938_playback2_setdma(struct es1938 *chip)\r\n{\r\noutb(0xc4, SLDM_REG(chip, DMACOMMAND));\r\noutb(0, SLDM_REG(chip, DMACLEAR));\r\noutb(1, SLDM_REG(chip, DMAMASK));\r\noutb(0x18, SLDM_REG(chip, DMAMODE));\r\noutl(chip->dma1_start, SLDM_REG(chip, DMAADDR));\r\noutw(chip->dma1_size - 1, SLDM_REG(chip, DMACOUNT));\r\noutb(0, SLDM_REG(chip, DMAMASK));\r\n}\r\nstatic void snd_es1938_capture_setdma(struct es1938 *chip)\r\n{\r\noutb(0xc4, SLDM_REG(chip, DMACOMMAND));\r\noutb(0, SLDM_REG(chip, DMACLEAR));\r\noutb(1, SLDM_REG(chip, DMAMASK));\r\noutb(0x14, SLDM_REG(chip, DMAMODE));\r\noutl(chip->dma1_start, SLDM_REG(chip, DMAADDR));\r\nchip->last_capture_dmaaddr = chip->dma1_start;\r\noutw(chip->dma1_size - 1, SLDM_REG(chip, DMACOUNT));\r\noutb(0, SLDM_REG(chip, DMAMASK));\r\n}\r\nstatic int snd_es1938_capture_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct es1938 *chip = snd_pcm_substream_chip(substream);\r\nint val;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nval = 0x0f;\r\nchip->active |= ADC1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nval = 0x00;\r\nchip->active &= ~ADC1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_es1938_write(chip, ESS_CMD_DMACONTROL, val);\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_playback1_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct es1938 *chip = snd_pcm_substream_chip(substream);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nsnd_es1938_mixer_write(chip, ESSSB_IREG_AUDIO2CONTROL1, 0x92);\r\nudelay(10);\r\nsnd_es1938_mixer_write(chip, ESSSB_IREG_AUDIO2CONTROL1, 0x93);\r\noutb(0x0a, SLIO_REG(chip, AUDIO2MODE));\r\nchip->active |= DAC2;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\noutb(0, SLIO_REG(chip, AUDIO2MODE));\r\nsnd_es1938_mixer_write(chip, ESSSB_IREG_AUDIO2CONTROL1, 0);\r\nchip->active &= ~DAC2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_playback2_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct es1938 *chip = snd_pcm_substream_chip(substream);\r\nint val;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nval = 5;\r\nchip->active |= DAC1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nval = 0;\r\nchip->active &= ~DAC1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_es1938_write(chip, ESS_CMD_DMACONTROL, val);\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_playback_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nswitch (substream->number) {\r\ncase 0:\r\nreturn snd_es1938_playback1_trigger(substream, cmd);\r\ncase 1:\r\nreturn snd_es1938_playback2_trigger(substream, cmd);\r\n}\r\nsnd_BUG();\r\nreturn -EINVAL;\r\n}\r\nstatic int snd_es1938_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct es1938 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint u, is8, mono;\r\nunsigned int size = snd_pcm_lib_buffer_bytes(substream);\r\nunsigned int count = snd_pcm_lib_period_bytes(substream);\r\nchip->dma1_size = size;\r\nchip->dma1_start = runtime->dma_addr;\r\nmono = (runtime->channels > 1) ? 0 : 1;\r\nis8 = snd_pcm_format_width(runtime->format) == 16 ? 0 : 1;\r\nu = snd_pcm_format_unsigned(runtime->format);\r\nchip->dma1_shift = 2 - mono - is8;\r\nsnd_es1938_reset_fifo(chip);\r\nsnd_es1938_bits(chip, ESS_CMD_ANALOGCONTROL, 0x03, (mono ? 2 : 1));\r\nsnd_es1938_rate_set(chip, substream, ADC1);\r\ncount = 0x10000 - count;\r\nsnd_es1938_write(chip, ESS_CMD_DMACNTRELOADL, count & 0xff);\r\nsnd_es1938_write(chip, ESS_CMD_DMACNTRELOADH, count >> 8);\r\nsnd_es1938_write(chip, ESS_CMD_SETFORMAT2, u ? 0x51 : 0x71);\r\nsnd_es1938_write(chip, ESS_CMD_SETFORMAT2, 0x90 |\r\n(u ? 0x00 : 0x20) |\r\n(is8 ? 0x00 : 0x04) |\r\n(mono ? 0x40 : 0x08));\r\nsnd_es1938_capture_setdma(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_playback1_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct es1938 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint u, is8, mono;\r\nunsigned int size = snd_pcm_lib_buffer_bytes(substream);\r\nunsigned int count = snd_pcm_lib_period_bytes(substream);\r\nchip->dma2_size = size;\r\nchip->dma2_start = runtime->dma_addr;\r\nmono = (runtime->channels > 1) ? 0 : 1;\r\nis8 = snd_pcm_format_width(runtime->format) == 16 ? 0 : 1;\r\nu = snd_pcm_format_unsigned(runtime->format);\r\nchip->dma2_shift = 2 - mono - is8;\r\nsnd_es1938_reset_fifo(chip);\r\nsnd_es1938_rate_set(chip, substream, DAC2);\r\ncount >>= 1;\r\ncount = 0x10000 - count;\r\nsnd_es1938_mixer_write(chip, ESSSB_IREG_AUDIO2TCOUNTL, count & 0xff);\r\nsnd_es1938_mixer_write(chip, ESSSB_IREG_AUDIO2TCOUNTH, count >> 8);\r\nsnd_es1938_mixer_write(chip, ESSSB_IREG_AUDIO2CONTROL2, 0x40 | (u ? 0 : 4) |\r\n(mono ? 0 : 2) | (is8 ? 0 : 1));\r\nsnd_es1938_playback1_setdma(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_playback2_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct es1938 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint u, is8, mono;\r\nunsigned int size = snd_pcm_lib_buffer_bytes(substream);\r\nunsigned int count = snd_pcm_lib_period_bytes(substream);\r\nchip->dma1_size = size;\r\nchip->dma1_start = runtime->dma_addr;\r\nmono = (runtime->channels > 1) ? 0 : 1;\r\nis8 = snd_pcm_format_width(runtime->format) == 16 ? 0 : 1;\r\nu = snd_pcm_format_unsigned(runtime->format);\r\nchip->dma1_shift = 2 - mono - is8;\r\ncount = 0x10000 - count;\r\nsnd_es1938_reset_fifo(chip);\r\nsnd_es1938_bits(chip, ESS_CMD_ANALOGCONTROL, 0x03, (mono ? 2 : 1));\r\nsnd_es1938_rate_set(chip, substream, DAC1);\r\nsnd_es1938_write(chip, ESS_CMD_DMACNTRELOADL, count & 0xff);\r\nsnd_es1938_write(chip, ESS_CMD_DMACNTRELOADH, count >> 8);\r\nsnd_es1938_write(chip, ESS_CMD_SETFORMAT, u ? 0x80 : 0x00);\r\nsnd_es1938_write(chip, ESS_CMD_SETFORMAT, u ? 0x51 : 0x71);\r\nsnd_es1938_write(chip, ESS_CMD_SETFORMAT2,\r\n0x90 | (mono ? 0x40 : 0x08) |\r\n(is8 ? 0x00 : 0x04) | (u ? 0x00 : 0x20));\r\nsnd_es1938_playback2_setdma(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nswitch (substream->number) {\r\ncase 0:\r\nreturn snd_es1938_playback1_prepare(substream);\r\ncase 1:\r\nreturn snd_es1938_playback2_prepare(substream);\r\n}\r\nsnd_BUG();\r\nreturn -EINVAL;\r\n}\r\nstatic snd_pcm_uframes_t snd_es1938_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct es1938 *chip = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\n#if 0\r\nsize_t old, new;\r\nold = inw(SLDM_REG(chip, DMACOUNT));\r\nwhile ((new = inw(SLDM_REG(chip, DMACOUNT))) != old)\r\nold = new;\r\nptr = chip->dma1_size - 1 - new;\r\n#else\r\nsize_t count;\r\nunsigned int diff;\r\nptr = inl(SLDM_REG(chip, DMAADDR));\r\ncount = inw(SLDM_REG(chip, DMACOUNT));\r\ndiff = chip->dma1_start + chip->dma1_size - ptr - count;\r\nif (diff > 3 || ptr < chip->dma1_start\r\n|| ptr >= chip->dma1_start+chip->dma1_size)\r\nptr = chip->last_capture_dmaaddr;\r\nelse\r\nchip->last_capture_dmaaddr = ptr;\r\nptr -= chip->dma1_start;\r\n#endif\r\nreturn ptr >> chip->dma1_shift;\r\n}\r\nstatic snd_pcm_uframes_t snd_es1938_playback1_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct es1938 *chip = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\n#if 1\r\nptr = chip->dma2_size - inw(SLIO_REG(chip, AUDIO2DMACOUNT));\r\n#else\r\nptr = inl(SLIO_REG(chip, AUDIO2DMAADDR)) - chip->dma2_start;\r\n#endif\r\nreturn ptr >> chip->dma2_shift;\r\n}\r\nstatic snd_pcm_uframes_t snd_es1938_playback2_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct es1938 *chip = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nsize_t old, new;\r\n#if 1\r\nold = inw(SLDM_REG(chip, DMACOUNT));\r\nwhile ((new = inw(SLDM_REG(chip, DMACOUNT))) != old)\r\nold = new;\r\nptr = chip->dma1_size - 1 - new;\r\n#else\r\nptr = inl(SLDM_REG(chip, DMAADDR)) - chip->dma1_start;\r\n#endif\r\nreturn ptr >> chip->dma1_shift;\r\n}\r\nstatic snd_pcm_uframes_t snd_es1938_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nswitch (substream->number) {\r\ncase 0:\r\nreturn snd_es1938_playback1_pointer(substream);\r\ncase 1:\r\nreturn snd_es1938_playback2_pointer(substream);\r\n}\r\nsnd_BUG();\r\nreturn -EINVAL;\r\n}\r\nstatic int snd_es1938_capture_copy(struct snd_pcm_substream *substream,\r\nint channel,\r\nsnd_pcm_uframes_t pos,\r\nvoid __user *dst,\r\nsnd_pcm_uframes_t count)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct es1938 *chip = snd_pcm_substream_chip(substream);\r\npos <<= chip->dma1_shift;\r\ncount <<= chip->dma1_shift;\r\nif (snd_BUG_ON(pos + count > chip->dma1_size))\r\nreturn -EINVAL;\r\nif (pos + count < chip->dma1_size) {\r\nif (copy_to_user(dst, runtime->dma_area + pos + 1, count))\r\nreturn -EFAULT;\r\n} else {\r\nif (copy_to_user(dst, runtime->dma_area + pos + 1, count - 1))\r\nreturn -EFAULT;\r\nif (put_user(runtime->dma_area[0], ((unsigned char __user *)dst) + count - 1))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nint err;\r\nif ((err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_es1938_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct es1938 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (chip->playback2_substream)\r\nreturn -EAGAIN;\r\nchip->capture_substream = substream;\r\nruntime->hw = snd_es1938_capture;\r\nsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&hw_constraints_clocks);\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 0, 0xff00);\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct es1938 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nswitch (substream->number) {\r\ncase 0:\r\nchip->playback1_substream = substream;\r\nbreak;\r\ncase 1:\r\nif (chip->capture_substream)\r\nreturn -EAGAIN;\r\nchip->playback2_substream = substream;\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nreturn -EINVAL;\r\n}\r\nruntime->hw = snd_es1938_playback;\r\nsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&hw_constraints_clocks);\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 0, 0xff00);\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct es1938 *chip = snd_pcm_substream_chip(substream);\r\nchip->capture_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct es1938 *chip = snd_pcm_substream_chip(substream);\r\nswitch (substream->number) {\r\ncase 0:\r\nchip->playback1_substream = NULL;\r\nbreak;\r\ncase 1:\r\nchip->playback2_substream = NULL;\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_new_pcm(struct es1938 *chip, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif ((err = snd_pcm_new(chip->card, "es-1938-1946", device, 2, 1, &pcm)) < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_es1938_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_es1938_capture_ops);\r\npcm->private_data = chip;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "ESS Solo-1");\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci), 64*1024, 64*1024);\r\nchip->pcm = pcm;\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_info_mux(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[8] = {\r\n"Mic", "Mic Master", "CD", "AOUT",\r\n"Mic1", "Mix", "Line", "Master"\r\n};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 8;\r\nif (uinfo->value.enumerated.item > 7)\r\nuinfo->value.enumerated.item = 7;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_get_mux(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = snd_es1938_mixer_read(chip, 0x1c) & 0x07;\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_put_mux(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned char val = ucontrol->value.enumerated.item[0];\r\nif (val > 7)\r\nreturn -EINVAL;\r\nreturn snd_es1938_mixer_bits(chip, 0x1c, 0x07, val) != val;\r\n}\r\nstatic int snd_es1938_get_spatializer_enable(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned char val = snd_es1938_mixer_read(chip, 0x50);\r\nucontrol->value.integer.value[0] = !!(val & 8);\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_put_spatializer_enable(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned char oval, nval;\r\nint change;\r\nnval = ucontrol->value.integer.value[0] ? 0x0c : 0x04;\r\noval = snd_es1938_mixer_read(chip, 0x50) & 0x0c;\r\nchange = nval != oval;\r\nif (change) {\r\nsnd_es1938_mixer_write(chip, 0x50, nval & ~0x04);\r\nsnd_es1938_mixer_write(chip, 0x50, nval);\r\n}\r\nreturn change;\r\n}\r\nstatic int snd_es1938_info_hw_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 63;\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_get_hw_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = snd_es1938_mixer_read(chip, 0x61) & 0x3f;\r\nucontrol->value.integer.value[1] = snd_es1938_mixer_read(chip, 0x63) & 0x3f;\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_get_hw_switch(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = !(snd_es1938_mixer_read(chip, 0x61) & 0x40);\r\nucontrol->value.integer.value[1] = !(snd_es1938_mixer_read(chip, 0x63) & 0x40);\r\nreturn 0;\r\n}\r\nstatic void snd_es1938_hwv_free(struct snd_kcontrol *kcontrol)\r\n{\r\nstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\r\nchip->master_volume = NULL;\r\nchip->master_switch = NULL;\r\nchip->hw_volume = NULL;\r\nchip->hw_switch = NULL;\r\n}\r\nstatic int snd_es1938_reg_bits(struct es1938 *chip, unsigned char reg,\r\nunsigned char mask, unsigned char val)\r\n{\r\nif (reg < 0xa0)\r\nreturn snd_es1938_mixer_bits(chip, reg, mask, val);\r\nelse\r\nreturn snd_es1938_bits(chip, reg, mask, val);\r\n}\r\nstatic int snd_es1938_reg_read(struct es1938 *chip, unsigned char reg)\r\n{\r\nif (reg < 0xa0)\r\nreturn snd_es1938_mixer_read(chip, reg);\r\nelse\r\nreturn snd_es1938_read(chip, reg);\r\n}\r\nstatic int snd_es1938_info_single(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_get_single(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nint val;\r\nval = snd_es1938_reg_read(chip, reg);\r\nucontrol->value.integer.value[0] = (val >> shift) & mask;\r\nif (invert)\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_put_single(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nunsigned char val;\r\nval = (ucontrol->value.integer.value[0] & mask);\r\nif (invert)\r\nval = mask - val;\r\nmask <<= shift;\r\nval <<= shift;\r\nreturn snd_es1938_reg_bits(chip, reg, mask, val) != val;\r\n}\r\nstatic int snd_es1938_info_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_get_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint shift_left = (kcontrol->private_value >> 16) & 0x07;\r\nint shift_right = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nunsigned char left, right;\r\nleft = snd_es1938_reg_read(chip, left_reg);\r\nif (left_reg != right_reg)\r\nright = snd_es1938_reg_read(chip, right_reg);\r\nelse\r\nright = left;\r\nucontrol->value.integer.value[0] = (left >> shift_left) & mask;\r\nucontrol->value.integer.value[1] = (right >> shift_right) & mask;\r\nif (invert) {\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_put_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct es1938 *chip = snd_kcontrol_chip(kcontrol);\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint shift_left = (kcontrol->private_value >> 16) & 0x07;\r\nint shift_right = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nint change;\r\nunsigned char val1, val2, mask1, mask2;\r\nval1 = ucontrol->value.integer.value[0] & mask;\r\nval2 = ucontrol->value.integer.value[1] & mask;\r\nif (invert) {\r\nval1 = mask - val1;\r\nval2 = mask - val2;\r\n}\r\nval1 <<= shift_left;\r\nval2 <<= shift_right;\r\nmask1 = mask << shift_left;\r\nmask2 = mask << shift_right;\r\nif (left_reg != right_reg) {\r\nchange = 0;\r\nif (snd_es1938_reg_bits(chip, left_reg, mask1, val1) != val1)\r\nchange = 1;\r\nif (snd_es1938_reg_bits(chip, right_reg, mask2, val2) != val2)\r\nchange = 1;\r\n} else {\r\nchange = (snd_es1938_reg_bits(chip, left_reg, mask1 | mask2,\r\nval1 | val2) != (val1 | val2));\r\n}\r\nreturn change;\r\n}\r\nstatic void snd_es1938_chip_init(struct es1938 *chip)\r\n{\r\nsnd_es1938_reset(chip);\r\npci_set_master(chip->pci);\r\npci_write_config_word(chip->pci, SL_PCI_LEGACYCONTROL, 0x805f);\r\npci_write_config_word(chip->pci, SL_PCI_DDMACONTROL, chip->ddma_port | 1);\r\npci_write_config_dword(chip->pci, SL_PCI_CONFIG, 0);\r\noutb(0xf0, SLIO_REG(chip, IRQCONTROL));\r\noutb(0, SLDM_REG(chip, DMACLEAR));\r\n}\r\nstatic int es1938_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct es1938 *chip = card->private_data;\r\nunsigned char *s, *d;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(chip->pcm);\r\nfor (s = saved_regs, d = chip->saved_regs; *s; s++, d++)\r\n*d = snd_es1938_reg_read(chip, *s);\r\noutb(0x00, SLIO_REG(chip, IRQCONTROL));\r\nif (chip->irq >= 0) {\r\nfree_irq(chip->irq, chip);\r\nchip->irq = -1;\r\n}\r\npci_disable_device(pci);\r\npci_save_state(pci);\r\npci_set_power_state(pci, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int es1938_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct es1938 *chip = card->private_data;\r\nunsigned char *s, *d;\r\npci_set_power_state(pci, PCI_D0);\r\npci_restore_state(pci);\r\nif (pci_enable_device(pci) < 0) {\r\nprintk(KERN_ERR "es1938: pci_enable_device failed, "\r\n"disabling device\n");\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\nif (request_irq(pci->irq, snd_es1938_interrupt,\r\nIRQF_SHARED, KBUILD_MODNAME, chip)) {\r\nprintk(KERN_ERR "es1938: unable to grab IRQ %d, "\r\n"disabling device\n", pci->irq);\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\nchip->irq = pci->irq;\r\nsnd_es1938_chip_init(chip);\r\nfor (s = saved_regs, d = chip->saved_regs; *s; s++, d++) {\r\nif (*s < 0xa0)\r\nsnd_es1938_mixer_write(chip, *s, *d);\r\nelse\r\nsnd_es1938_write(chip, *s, *d);\r\n}\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_create_gameport(struct es1938 *chip)\r\n{\r\nstruct gameport *gp;\r\nchip->gameport = gp = gameport_allocate_port();\r\nif (!gp) {\r\nprintk(KERN_ERR "es1938: cannot allocate memory for gameport\n");\r\nreturn -ENOMEM;\r\n}\r\ngameport_set_name(gp, "ES1938");\r\ngameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));\r\ngameport_set_dev_parent(gp, &chip->pci->dev);\r\ngp->io = chip->game_port;\r\ngameport_register_port(gp);\r\nreturn 0;\r\n}\r\nstatic void snd_es1938_free_gameport(struct es1938 *chip)\r\n{\r\nif (chip->gameport) {\r\ngameport_unregister_port(chip->gameport);\r\nchip->gameport = NULL;\r\n}\r\n}\r\nstatic inline int snd_es1938_create_gameport(struct es1938 *chip) { return -ENOSYS; }\r\nstatic inline void snd_es1938_free_gameport(struct es1938 *chip) { }\r\nstatic int snd_es1938_free(struct es1938 *chip)\r\n{\r\noutb(0x00, SLIO_REG(chip, IRQCONTROL));\r\nif (chip->rmidi)\r\nsnd_es1938_mixer_bits(chip, ESSSB_IREG_MPU401CONTROL, 0x40, 0);\r\nsnd_es1938_free_gameport(chip);\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\npci_release_regions(chip->pci);\r\npci_disable_device(chip->pci);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_dev_free(struct snd_device *device)\r\n{\r\nstruct es1938 *chip = device->device_data;\r\nreturn snd_es1938_free(chip);\r\n}\r\nstatic int snd_es1938_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nstruct es1938 **rchip)\r\n{\r\nstruct es1938 *chip;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_es1938_dev_free,\r\n};\r\n*rchip = NULL;\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nif (pci_set_dma_mask(pci, DMA_BIT_MASK(24)) < 0 ||\r\npci_set_consistent_dma_mask(pci, DMA_BIT_MASK(24)) < 0) {\r\nsnd_printk(KERN_ERR "architecture does not support 24bit PCI busmaster DMA\n");\r\npci_disable_device(pci);\r\nreturn -ENXIO;\r\n}\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&chip->reg_lock);\r\nspin_lock_init(&chip->mixer_lock);\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nif ((err = pci_request_regions(pci, "ESS Solo-1")) < 0) {\r\nkfree(chip);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nchip->io_port = pci_resource_start(pci, 0);\r\nchip->sb_port = pci_resource_start(pci, 1);\r\nchip->vc_port = pci_resource_start(pci, 2);\r\nchip->mpu_port = pci_resource_start(pci, 3);\r\nchip->game_port = pci_resource_start(pci, 4);\r\nif (request_irq(pci->irq, snd_es1938_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, chip)) {\r\nsnd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);\r\nsnd_es1938_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->irq = pci->irq;\r\n#ifdef ES1938_DDEBUG\r\nsnd_printk(KERN_DEBUG "create: io: 0x%lx, sb: 0x%lx, vc: 0x%lx, mpu: 0x%lx, game: 0x%lx\n",\r\nchip->io_port, chip->sb_port, chip->vc_port, chip->mpu_port, chip->game_port);\r\n#endif\r\nchip->ddma_port = chip->vc_port + 0x00;\r\nsnd_es1938_chip_init(chip);\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\r\nsnd_es1938_free(chip);\r\nreturn err;\r\n}\r\nsnd_card_set_dev(card, &pci->dev);\r\n*rchip = chip;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t snd_es1938_interrupt(int irq, void *dev_id)\r\n{\r\nstruct es1938 *chip = dev_id;\r\nunsigned char status, audiostatus;\r\nint handled = 0;\r\nstatus = inb(SLIO_REG(chip, IRQCONTROL));\r\n#if 0\r\nprintk(KERN_DEBUG "Es1938debug - interrupt status: =0x%x\n", status);\r\n#endif\r\nif (status & 0x10) {\r\n#if 0\r\nprintk(KERN_DEBUG\r\n"Es1938debug - AUDIO channel 1 interrupt\n");\r\nprintk(KERN_DEBUG\r\n"Es1938debug - AUDIO channel 1 DMAC DMA count: %u\n",\r\ninw(SLDM_REG(chip, DMACOUNT)));\r\nprintk(KERN_DEBUG\r\n"Es1938debug - AUDIO channel 1 DMAC DMA base: %u\n",\r\ninl(SLDM_REG(chip, DMAADDR)));\r\nprintk(KERN_DEBUG\r\n"Es1938debug - AUDIO channel 1 DMAC DMA status: 0x%x\n",\r\ninl(SLDM_REG(chip, DMASTATUS)));\r\n#endif\r\nhandled = 1;\r\naudiostatus = inb(SLSB_REG(chip, STATUS));\r\nif (chip->active & ADC1)\r\nsnd_pcm_period_elapsed(chip->capture_substream);\r\nelse if (chip->active & DAC1)\r\nsnd_pcm_period_elapsed(chip->playback2_substream);\r\n}\r\nif (status & 0x20) {\r\n#if 0\r\nprintk(KERN_DEBUG\r\n"Es1938debug - AUDIO channel 2 interrupt\n");\r\nprintk(KERN_DEBUG\r\n"Es1938debug - AUDIO channel 2 DMAC DMA count: %u\n",\r\ninw(SLIO_REG(chip, AUDIO2DMACOUNT)));\r\nprintk(KERN_DEBUG\r\n"Es1938debug - AUDIO channel 2 DMAC DMA base: %u\n",\r\ninl(SLIO_REG(chip, AUDIO2DMAADDR)));\r\n#endif\r\nhandled = 1;\r\nsnd_es1938_mixer_bits(chip, ESSSB_IREG_AUDIO2CONTROL2, 0x80, 0);\r\nif (chip->active & DAC2)\r\nsnd_pcm_period_elapsed(chip->playback1_substream);\r\n}\r\nif (status & 0x40) {\r\nint split = snd_es1938_mixer_read(chip, 0x64) & 0x80;\r\nhandled = 1;\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE, &chip->hw_switch->id);\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE, &chip->hw_volume->id);\r\nif (!split) {\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->master_switch->id);\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->master_volume->id);\r\n}\r\nsnd_es1938_mixer_write(chip, 0x66, 0x00);\r\n}\r\nif (status & 0x80) {\r\nif (chip->rmidi) {\r\nhandled = 1;\r\nsnd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);\r\n}\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int snd_es1938_mixer(struct es1938 *chip)\r\n{\r\nstruct snd_card *card;\r\nunsigned int idx;\r\nint err;\r\ncard = chip->card;\r\nstrcpy(card->mixername, "ESS Solo-1");\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_es1938_controls); idx++) {\r\nstruct snd_kcontrol *kctl;\r\nkctl = snd_ctl_new1(&snd_es1938_controls[idx], chip);\r\nswitch (idx) {\r\ncase 0:\r\nchip->master_volume = kctl;\r\nkctl->private_free = snd_es1938_hwv_free;\r\nbreak;\r\ncase 1:\r\nchip->master_switch = kctl;\r\nkctl->private_free = snd_es1938_hwv_free;\r\nbreak;\r\ncase 2:\r\nchip->hw_volume = kctl;\r\nkctl->private_free = snd_es1938_hwv_free;\r\nbreak;\r\ncase 3:\r\nchip->hw_switch = kctl;\r\nkctl->private_free = snd_es1938_hwv_free;\r\nbreak;\r\n}\r\nif ((err = snd_ctl_add(card, kctl)) < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_es1938_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct es1938 *chip;\r\nstruct snd_opl3 *opl3;\r\nint idx, err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nfor (idx = 0; idx < 5; idx++) {\r\nif (pci_resource_start(pci, idx) == 0 ||\r\n!(pci_resource_flags(pci, idx) & IORESOURCE_IO)) {\r\nsnd_card_free(card);\r\nreturn -ENODEV;\r\n}\r\n}\r\nif ((err = snd_es1938_create(card, pci, &chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ncard->private_data = chip;\r\nstrcpy(card->driver, "ES1938");\r\nstrcpy(card->shortname, "ESS ES1938 (Solo-1)");\r\nsprintf(card->longname, "%s rev %i, irq %i",\r\ncard->shortname,\r\nchip->revision,\r\nchip->irq);\r\nif ((err = snd_es1938_new_pcm(chip, 0)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_es1938_mixer(chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif (snd_opl3_create(card,\r\nSLSB_REG(chip, FMLOWADDR),\r\nSLSB_REG(chip, FMHIGHADDR),\r\nOPL3_HW_OPL3, 1, &opl3) < 0) {\r\nprintk(KERN_ERR "es1938: OPL3 not detected at 0x%lx\n",\r\nSLSB_REG(chip, FMLOWADDR));\r\n} else {\r\nif ((err = snd_opl3_timer_new(opl3, 0, 1)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_opl3_hwdep_new(opl3, 0, 1, NULL)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n}\r\nif (snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,\r\nchip->mpu_port,\r\nMPU401_INFO_INTEGRATED | MPU401_INFO_IRQ_HOOK,\r\n-1, &chip->rmidi) < 0) {\r\nprintk(KERN_ERR "es1938: unable to initialize MPU-401\n");\r\n} else {\r\nsnd_es1938_mixer_bits(chip, ESSSB_IREG_MPU401CONTROL, 0x40, 0x40);\r\n}\r\nsnd_es1938_create_gameport(chip);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_es1938_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\n}
