static void __init\r\nenable_board( int board_num, unsigned short port )\r\n{\r\noutb( 0xbc + board_num, MASTER_ADDRESS_PTR );\r\noutb( port >> 2, MASTER_ADDRESS_PTR );\r\n}\r\nstatic void __init\r\ninit_board( unsigned short io_port, int irq, int force_irq )\r\n{\r\nunsigned int tmp;\r\nunsigned int pas_irq_code;\r\noutb( 0x30, io_port + P_TIMEOUT_COUNTER_REG );\r\noutb( 0x01, io_port + P_TIMEOUT_STATUS_REG_OFFSET );\r\noutb( 0x01, io_port + WAIT_STATE );\r\nNCR5380_read( RESET_PARITY_INTERRUPT_REG );\r\npas_irq_code = ( irq < 16 ) ? scsi_irq_translate[irq] : 0;\r\ntmp = inb( io_port + IO_CONFIG_3 );\r\nif( (( tmp & 0x0f ) == pas_irq_code) && pas_irq_code > 0\r\n&& !force_irq )\r\n{\r\nprintk( "pas16: WARNING: Can't use same irq as sound "\r\n"driver -- interrupts disabled\n" );\r\noutb( 0x4d, io_port + SYS_CONFIG_4 );\r\n}\r\nelse\r\n{\r\ntmp = ( tmp & 0x0f ) | ( pas_irq_code << 4 );\r\noutb( tmp, io_port + IO_CONFIG_3 );\r\noutb( 0x6d, io_port + SYS_CONFIG_4 );\r\n}\r\n}\r\nstatic int __init\r\npas16_hw_detect( unsigned short board_num )\r\n{\r\nunsigned char board_rev, tmp;\r\nunsigned short io_port = bases[ board_num ].io_port;\r\nenable_board( board_num, io_port );\r\nboard_rev = inb( io_port + PCB_CONFIG );\r\nif( board_rev == 0xff )\r\nreturn 0;\r\ntmp = board_rev ^ 0xe0;\r\noutb( tmp, io_port + PCB_CONFIG );\r\ntmp = inb( io_port + PCB_CONFIG );\r\noutb( board_rev, io_port + PCB_CONFIG );\r\nif( board_rev != tmp )\r\nreturn 0;\r\nif( ( inb( io_port + OPERATION_MODE_1 ) & 0x03 ) != 0x03 )\r\nreturn 0;\r\noutb( 0x01, io_port + WAIT_STATE );\r\nNCR5380_write( MODE_REG, 0x20 );\r\nif( NCR5380_read( MODE_REG ) != 0x20 )\r\nreturn 0;\r\nNCR5380_write( MODE_REG, 0x00 );\r\nif( NCR5380_read( MODE_REG ) != 0x00 )\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid __init pas16_setup(char *str, int *ints)\r\n{\r\nstatic int commandline_current = 0;\r\nint i;\r\nif (ints[0] != 2)\r\nprintk("pas16_setup : usage pas16=io_port,irq\n");\r\nelse\r\nif (commandline_current < NO_OVERRIDES) {\r\noverrides[commandline_current].io_port = (unsigned short) ints[1];\r\noverrides[commandline_current].irq = ints[2];\r\nfor (i = 0; i < NO_BASES; ++i)\r\nif (bases[i].io_port == (unsigned short) ints[1]) {\r\nbases[i].noauto = 1;\r\nbreak;\r\n}\r\n++commandline_current;\r\n}\r\n}\r\nint __init pas16_detect(struct scsi_host_template * tpnt)\r\n{\r\nstatic int current_override = 0;\r\nstatic unsigned short current_base = 0;\r\nstruct Scsi_Host *instance;\r\nunsigned short io_port;\r\nint count;\r\ntpnt->proc_name = "pas16";\r\ntpnt->show_info = pas16_show_info;\r\ntpnt->write_info = pas16_write_info;\r\nif (pas16_addr != 0) {\r\noverrides[0].io_port = pas16_addr;\r\nfor (count = 0; count < NO_BASES; ++count)\r\nif (bases[count].io_port == pas16_addr) {\r\nbases[count].noauto = 1;\r\nbreak;\r\n}\r\n}\r\nif (pas16_irq != 0)\r\noverrides[0].irq = pas16_irq;\r\nfor (count = 0; current_override < NO_OVERRIDES; ++current_override) {\r\nio_port = 0;\r\nif (overrides[current_override].io_port)\r\n{\r\nio_port = overrides[current_override].io_port;\r\nenable_board( current_override, io_port );\r\ninit_board( io_port, overrides[current_override].irq, 1 );\r\n}\r\nelse\r\nfor (; !io_port && (current_base < NO_BASES); ++current_base) {\r\n#if (PDEBUG & PDEBUG_INIT)\r\nprintk("scsi-pas16 : probing io_port %04x\n", (unsigned int) bases[current_base].io_port);\r\n#endif\r\nif ( !bases[current_base].noauto &&\r\npas16_hw_detect( current_base ) ){\r\nio_port = bases[current_base].io_port;\r\ninit_board( io_port, default_irqs[ current_base ], 0 );\r\n#if (PDEBUG & PDEBUG_INIT)\r\nprintk("scsi-pas16 : detected board.\n");\r\n#endif\r\n}\r\n}\r\n#if defined(PDEBUG) && (PDEBUG & PDEBUG_INIT)\r\nprintk("scsi-pas16 : io_port = %04x\n", (unsigned int) io_port);\r\n#endif\r\nif (!io_port)\r\nbreak;\r\ninstance = scsi_register (tpnt, sizeof(struct NCR5380_hostdata));\r\nif(instance == NULL)\r\nbreak;\r\ninstance->io_port = io_port;\r\nNCR5380_init(instance, 0);\r\nif (overrides[current_override].irq != IRQ_AUTO)\r\ninstance->irq = overrides[current_override].irq;\r\nelse\r\ninstance->irq = NCR5380_probe_irq(instance, PAS16_IRQS);\r\nif (instance->irq != SCSI_IRQ_NONE)\r\nif (request_irq(instance->irq, pas16_intr, IRQF_DISABLED,\r\n"pas16", instance)) {\r\nprintk("scsi%d : IRQ%d not free, interrupts disabled\n",\r\ninstance->host_no, instance->irq);\r\ninstance->irq = SCSI_IRQ_NONE;\r\n}\r\nif (instance->irq == SCSI_IRQ_NONE) {\r\nprintk("scsi%d : interrupts not enabled. for better interactive performance,\n", instance->host_no);\r\nprintk("scsi%d : please jumper the board for a free IRQ.\n", instance->host_no);\r\noutb( 0x4d, io_port + SYS_CONFIG_4 );\r\noutb( (inb(io_port + IO_CONFIG_3) & 0x0f), io_port + IO_CONFIG_3 );\r\n}\r\n#if defined(PDEBUG) && (PDEBUG & PDEBUG_INIT)\r\nprintk("scsi%d : irq = %d\n", instance->host_no, instance->irq);\r\n#endif\r\nprintk("scsi%d : at 0x%04x", instance->host_no, (int)\r\ninstance->io_port);\r\nif (instance->irq == SCSI_IRQ_NONE)\r\nprintk (" interrupts disabled");\r\nelse\r\nprintk (" irq %d", instance->irq);\r\nprintk(" options CAN_QUEUE=%d CMD_PER_LUN=%d release=%d",\r\nCAN_QUEUE, CMD_PER_LUN, PAS16_PUBLIC_RELEASE);\r\nNCR5380_print_options(instance);\r\nprintk("\n");\r\n++current_override;\r\n++count;\r\n}\r\nreturn count;\r\n}\r\nint pas16_biosparam(struct scsi_device *sdev, struct block_device *dev,\r\nsector_t capacity, int * ip)\r\n{\r\nint size = capacity;\r\nip[0] = 64;\r\nip[1] = 32;\r\nip[2] = size >> 11;\r\nif( ip[2] > 1024 ) {\r\nip[0]=255;\r\nip[1]=63;\r\nip[2]=size/(63*255);\r\nif( ip[2] > 1023 )\r\nip[2] = 1023;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int NCR5380_pread (struct Scsi_Host *instance, unsigned char *dst,\r\nint len) {\r\nregister unsigned char *d = dst;\r\nregister unsigned short reg = (unsigned short) (instance->io_port +\r\nP_DATA_REG_OFFSET);\r\nregister int i = len;\r\nint ii = 0;\r\nwhile ( !(inb(instance->io_port + P_STATUS_REG_OFFSET) & P_ST_RDY) )\r\n++ii;\r\ninsb( reg, d, i );\r\nif ( inb(instance->io_port + P_TIMEOUT_STATUS_REG_OFFSET) & P_TS_TIM) {\r\noutb( P_TS_CT, instance->io_port + P_TIMEOUT_STATUS_REG_OFFSET);\r\nprintk("scsi%d : watchdog timer fired in NCR5380_pread()\n",\r\ninstance->host_no);\r\nreturn -1;\r\n}\r\nif (ii > pas_maxi)\r\npas_maxi = ii;\r\nreturn 0;\r\n}\r\nstatic inline int NCR5380_pwrite (struct Scsi_Host *instance, unsigned char *src,\r\nint len) {\r\nregister unsigned char *s = src;\r\nregister unsigned short reg = (instance->io_port + P_DATA_REG_OFFSET);\r\nregister int i = len;\r\nint ii = 0;\r\nwhile ( !((inb(instance->io_port + P_STATUS_REG_OFFSET)) & P_ST_RDY) )\r\n++ii;\r\noutsb( reg, s, i );\r\nif (inb(instance->io_port + P_TIMEOUT_STATUS_REG_OFFSET) & P_TS_TIM) {\r\noutb( P_TS_CT, instance->io_port + P_TIMEOUT_STATUS_REG_OFFSET);\r\nprintk("scsi%d : watchdog timer fired in NCR5380_pwrite()\n",\r\ninstance->host_no);\r\nreturn -1;\r\n}\r\nif (ii > pas_maxi)\r\npas_wmaxi = ii;\r\nreturn 0;\r\n}\r\nstatic int pas16_release(struct Scsi_Host *shost)\r\n{\r\nif (shost->irq)\r\nfree_irq(shost->irq, shost);\r\nNCR5380_exit(shost);\r\nif (shost->dma_channel != 0xff)\r\nfree_dma(shost->dma_channel);\r\nif (shost->io_port && shost->n_io_port)\r\nrelease_region(shost->io_port, shost->n_io_port);\r\nscsi_unregister(shost);\r\nreturn 0;\r\n}
