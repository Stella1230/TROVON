static void ni_tio_configure_dma(struct ni_gpct *counter, short enable,\r\nshort read_not_write)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nunsigned input_select_bits = 0;\r\nif (enable) {\r\nif (read_not_write)\r\ninput_select_bits |= Gi_Read_Acknowledges_Irq;\r\nelse\r\ninput_select_bits |= Gi_Write_Acknowledges_Irq;\r\n}\r\nni_tio_set_bits(counter,\r\nNITIO_Gi_Input_Select_Reg(counter->counter_index),\r\nGi_Read_Acknowledges_Irq | Gi_Write_Acknowledges_Irq,\r\ninput_select_bits);\r\nswitch (counter_dev->variant) {\r\ncase ni_gpct_variant_e_series:\r\nbreak;\r\ncase ni_gpct_variant_m_series:\r\ncase ni_gpct_variant_660x:\r\n{\r\nunsigned gi_dma_config_bits = 0;\r\nif (enable) {\r\ngi_dma_config_bits |= Gi_DMA_Enable_Bit;\r\ngi_dma_config_bits |= Gi_DMA_Int_Bit;\r\n}\r\nif (read_not_write == 0)\r\ngi_dma_config_bits |= Gi_DMA_Write_Bit;\r\nni_tio_set_bits(counter,\r\nNITIO_Gi_DMA_Config_Reg(counter->\r\ncounter_index),\r\nGi_DMA_Enable_Bit | Gi_DMA_Int_Bit |\r\nGi_DMA_Write_Bit, gi_dma_config_bits);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int ni_tio_input_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trignum)\r\n{\r\nunsigned long flags;\r\nint retval = 0;\r\nstruct ni_gpct *counter = s->private;\r\nBUG_ON(counter == NULL);\r\nif (trignum != 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&counter->lock, flags);\r\nif (counter->mite_chan)\r\nmite_dma_arm(counter->mite_chan);\r\nelse\r\nretval = -EIO;\r\nspin_unlock_irqrestore(&counter->lock, flags);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);\r\ns->async->inttrig = NULL;\r\nreturn retval;\r\n}\r\nstatic int ni_tio_input_cmd(struct ni_gpct *counter, struct comedi_async *async)\r\n{\r\nstruct ni_gpct_device *counter_dev = counter->counter_dev;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nint retval = 0;\r\ncomedi_buf_write_alloc(async, async->prealloc_bufsz);\r\ncounter->mite_chan->dir = COMEDI_INPUT;\r\nswitch (counter_dev->variant) {\r\ncase ni_gpct_variant_m_series:\r\ncase ni_gpct_variant_660x:\r\nmite_prep_dma(counter->mite_chan, 32, 32);\r\nbreak;\r\ncase ni_gpct_variant_e_series:\r\nmite_prep_dma(counter->mite_chan, 16, 32);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nni_tio_set_bits(counter, NITIO_Gi_Command_Reg(counter->counter_index),\r\nGi_Save_Trace_Bit, 0);\r\nni_tio_configure_dma(counter, 1, 1);\r\nswitch (cmd->start_src) {\r\ncase TRIG_NOW:\r\nasync->inttrig = NULL;\r\nmite_dma_arm(counter->mite_chan);\r\nretval = ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);\r\nbreak;\r\ncase TRIG_INT:\r\nasync->inttrig = &ni_tio_input_inttrig;\r\nbreak;\r\ncase TRIG_EXT:\r\nasync->inttrig = NULL;\r\nmite_dma_arm(counter->mite_chan);\r\nretval = ni_tio_arm(counter, 1, cmd->start_arg);\r\nbreak;\r\ncase TRIG_OTHER:\r\nasync->inttrig = NULL;\r\nmite_dma_arm(counter->mite_chan);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic int ni_tio_output_cmd(struct ni_gpct *counter,\r\nstruct comedi_async *async)\r\n{\r\ndev_err(counter->counter_dev->dev->class_dev,\r\n"output commands not yet implemented.\n");\r\nreturn -ENOTSUPP;\r\ncounter->mite_chan->dir = COMEDI_OUTPUT;\r\nmite_prep_dma(counter->mite_chan, 32, 32);\r\nni_tio_configure_dma(counter, 1, 0);\r\nmite_dma_arm(counter->mite_chan);\r\nreturn ni_tio_arm(counter, 1, NI_GPCT_ARM_IMMEDIATE);\r\n}\r\nstatic int ni_tio_cmd_setup(struct ni_gpct *counter, struct comedi_async *async)\r\n{\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nint set_gate_source = 0;\r\nunsigned gate_source;\r\nint retval = 0;\r\nif (cmd->scan_begin_src == TRIG_EXT) {\r\nset_gate_source = 1;\r\ngate_source = cmd->scan_begin_arg;\r\n} else if (cmd->convert_src == TRIG_EXT) {\r\nset_gate_source = 1;\r\ngate_source = cmd->convert_arg;\r\n}\r\nif (set_gate_source)\r\nretval = ni_tio_set_gate_src(counter, 0, gate_source);\r\nif (cmd->flags & TRIG_WAKE_EOS) {\r\nni_tio_set_bits(counter,\r\nNITIO_Gi_Interrupt_Enable_Reg(counter->\r\ncounter_index),\r\nGi_Gate_Interrupt_Enable_Bit(counter->\r\ncounter_index),\r\nGi_Gate_Interrupt_Enable_Bit(counter->\r\ncounter_index));\r\n}\r\nreturn retval;\r\n}\r\nint ni_tio_cmd(struct ni_gpct *counter, struct comedi_async *async)\r\n{\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nint retval = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&counter->lock, flags);\r\nif (counter->mite_chan == NULL) {\r\ndev_err(counter->counter_dev->dev->class_dev,\r\n"commands only supported with DMA. ");\r\ndev_err(counter->counter_dev->dev->class_dev,\r\n"Interrupt-driven commands not yet implemented.\n");\r\nretval = -EIO;\r\n} else {\r\nretval = ni_tio_cmd_setup(counter, async);\r\nif (retval == 0) {\r\nif (cmd->flags & CMDF_WRITE)\r\nretval = ni_tio_output_cmd(counter, async);\r\nelse\r\nretval = ni_tio_input_cmd(counter, async);\r\n}\r\n}\r\nspin_unlock_irqrestore(&counter->lock, flags);\r\nreturn retval;\r\n}\r\nint ni_tio_cmdtest(struct ni_gpct *counter, struct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nunsigned int sources;\r\nsources = TRIG_NOW | TRIG_INT | TRIG_OTHER;\r\nif (ni_tio_counting_mode_registers_present(counter->counter_dev))\r\nsources |= TRIG_EXT;\r\nerr |= cfc_check_trigger_src(&cmd->start_src, sources);\r\nerr |= cfc_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_FOLLOW | TRIG_EXT | TRIG_OTHER);\r\nerr |= cfc_check_trigger_src(&cmd->convert_src,\r\nTRIG_NOW | TRIG_EXT | TRIG_OTHER);\r\nerr |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= cfc_check_trigger_src(&cmd->stop_src, TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= cfc_check_trigger_is_unique(cmd->start_src);\r\nerr |= cfc_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= cfc_check_trigger_is_unique(cmd->convert_src);\r\nif (cmd->convert_src != TRIG_NOW && cmd->scan_begin_src != TRIG_FOLLOW)\r\nerr |= -EINVAL;\r\nif (err)\r\nreturn 2;\r\nif (cmd->start_src != TRIG_EXT)\r\nerr |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (cmd->scan_begin_src != TRIG_EXT)\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nif (cmd->convert_src != TRIG_EXT)\r\nerr |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);\r\nerr |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nint ni_tio_cancel(struct ni_gpct *counter)\r\n{\r\nunsigned long flags;\r\nni_tio_arm(counter, 0, 0);\r\nspin_lock_irqsave(&counter->lock, flags);\r\nif (counter->mite_chan)\r\nmite_dma_disarm(counter->mite_chan);\r\nspin_unlock_irqrestore(&counter->lock, flags);\r\nni_tio_configure_dma(counter, 0, 0);\r\nni_tio_set_bits(counter,\r\nNITIO_Gi_Interrupt_Enable_Reg(counter->counter_index),\r\nGi_Gate_Interrupt_Enable_Bit(counter->counter_index),\r\n0x0);\r\nreturn 0;\r\n}\r\nstatic int should_ack_gate(struct ni_gpct *counter)\r\n{\r\nunsigned long flags;\r\nint retval = 0;\r\nswitch (counter->counter_dev->variant) {\r\ncase ni_gpct_variant_m_series:\r\ncase ni_gpct_variant_660x:\r\nreturn 1;\r\nbreak;\r\ncase ni_gpct_variant_e_series:\r\nspin_lock_irqsave(&counter->lock, flags);\r\n{\r\nif (counter->mite_chan == NULL ||\r\ncounter->mite_chan->dir != COMEDI_INPUT ||\r\n(mite_done(counter->mite_chan))) {\r\nretval = 1;\r\n}\r\n}\r\nspin_unlock_irqrestore(&counter->lock, flags);\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nvoid ni_tio_acknowledge_and_confirm(struct ni_gpct *counter, int *gate_error,\r\nint *tc_error, int *perm_stale_data,\r\nint *stale_data)\r\n{\r\nconst unsigned short gxx_status = read_register(counter,\r\nNITIO_Gxx_Status_Reg\r\n(counter->\r\ncounter_index));\r\nconst unsigned short gi_status = read_register(counter,\r\nNITIO_Gi_Status_Reg\r\n(counter->\r\ncounter_index));\r\nunsigned ack = 0;\r\nif (gate_error)\r\n*gate_error = 0;\r\nif (tc_error)\r\n*tc_error = 0;\r\nif (perm_stale_data)\r\n*perm_stale_data = 0;\r\nif (stale_data)\r\n*stale_data = 0;\r\nif (gxx_status & Gi_Gate_Error_Bit(counter->counter_index)) {\r\nack |= Gi_Gate_Error_Confirm_Bit(counter->counter_index);\r\nif (gate_error) {\r\nif (counter->counter_dev->variant !=\r\nni_gpct_variant_660x) {\r\n*gate_error = 1;\r\n}\r\n}\r\n}\r\nif (gxx_status & Gi_TC_Error_Bit(counter->counter_index)) {\r\nack |= Gi_TC_Error_Confirm_Bit(counter->counter_index);\r\nif (tc_error)\r\n*tc_error = 1;\r\n}\r\nif (gi_status & Gi_TC_Bit)\r\nack |= Gi_TC_Interrupt_Ack_Bit;\r\nif (gi_status & Gi_Gate_Interrupt_Bit) {\r\nif (should_ack_gate(counter))\r\nack |= Gi_Gate_Interrupt_Ack_Bit;\r\n}\r\nif (ack)\r\nwrite_register(counter, ack,\r\nNITIO_Gi_Interrupt_Acknowledge_Reg\r\n(counter->counter_index));\r\nif (ni_tio_get_soft_copy\r\n(counter,\r\nNITIO_Gi_Mode_Reg(counter->counter_index)) &\r\nGi_Loading_On_Gate_Bit) {\r\nif (gxx_status & Gi_Stale_Data_Bit(counter->counter_index)) {\r\nif (stale_data)\r\n*stale_data = 1;\r\n}\r\nif (read_register(counter,\r\nNITIO_Gxx_Joint_Status2_Reg\r\n(counter->counter_index)) &\r\nGi_Permanent_Stale_Bit(counter->counter_index)) {\r\ndev_info(counter->counter_dev->dev->class_dev,\r\n"%s: Gi_Permanent_Stale_Data detected.\n",\r\n__func__);\r\nif (perm_stale_data)\r\n*perm_stale_data = 1;\r\n}\r\n}\r\n}\r\nvoid ni_tio_handle_interrupt(struct ni_gpct *counter,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned gpct_mite_status;\r\nunsigned long flags;\r\nint gate_error;\r\nint tc_error;\r\nint perm_stale_data;\r\nni_tio_acknowledge_and_confirm(counter, &gate_error, &tc_error,\r\n&perm_stale_data, NULL);\r\nif (gate_error) {\r\ndev_notice(counter->counter_dev->dev->class_dev,\r\n"%s: Gi_Gate_Error detected.\n", __func__);\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\n}\r\nif (perm_stale_data)\r\ns->async->events |= COMEDI_CB_ERROR;\r\nswitch (counter->counter_dev->variant) {\r\ncase ni_gpct_variant_m_series:\r\ncase ni_gpct_variant_660x:\r\nif (read_register(counter,\r\nNITIO_Gi_DMA_Status_Reg\r\n(counter->counter_index)) & Gi_DRQ_Error_Bit) {\r\ndev_notice(counter->counter_dev->dev->class_dev,\r\n"%s: Gi_DRQ_Error detected.\n", __func__);\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\n}\r\nbreak;\r\ncase ni_gpct_variant_e_series:\r\nbreak;\r\n}\r\nspin_lock_irqsave(&counter->lock, flags);\r\nif (counter->mite_chan == NULL) {\r\nspin_unlock_irqrestore(&counter->lock, flags);\r\nreturn;\r\n}\r\ngpct_mite_status = mite_get_status(counter->mite_chan);\r\nif (gpct_mite_status & CHSR_LINKC) {\r\nwritel(CHOR_CLRLC,\r\ncounter->mite_chan->mite->mite_io_addr +\r\nMITE_CHOR(counter->mite_chan->channel));\r\n}\r\nmite_sync_input_dma(counter->mite_chan, s->async);\r\nspin_unlock_irqrestore(&counter->lock, flags);\r\n}\r\nvoid ni_tio_set_mite_channel(struct ni_gpct *counter,\r\nstruct mite_channel *mite_chan)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&counter->lock, flags);\r\ncounter->mite_chan = mite_chan;\r\nspin_unlock_irqrestore(&counter->lock, flags);\r\n}\r\nstatic int __init ni_tiocmd_init_module(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit ni_tiocmd_cleanup_module(void)\r\n{\r\n}
