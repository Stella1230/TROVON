static inline struct fw_device *device_of(struct firedtv *fdtv)\r\n{\r\nreturn fw_device(fdtv->device->parent);\r\n}\r\nstatic int node_req(struct firedtv *fdtv, u64 addr, void *data, size_t len,\r\nint tcode)\r\n{\r\nstruct fw_device *device = device_of(fdtv);\r\nint rcode, generation = device->generation;\r\nsmp_rmb();\r\nrcode = fw_run_transaction(device->card, tcode, device->node_id,\r\ngeneration, device->max_speed, addr, data, len);\r\nreturn rcode != RCODE_COMPLETE ? -EIO : 0;\r\n}\r\nint fdtv_lock(struct firedtv *fdtv, u64 addr, void *data)\r\n{\r\nreturn node_req(fdtv, addr, data, 8, TCODE_LOCK_COMPARE_SWAP);\r\n}\r\nint fdtv_read(struct firedtv *fdtv, u64 addr, void *data)\r\n{\r\nreturn node_req(fdtv, addr, data, 4, TCODE_READ_QUADLET_REQUEST);\r\n}\r\nint fdtv_write(struct firedtv *fdtv, u64 addr, void *data, size_t len)\r\n{\r\nreturn node_req(fdtv, addr, data, len, TCODE_WRITE_BLOCK_REQUEST);\r\n}\r\nstatic int queue_iso(struct fdtv_ir_context *ctx, int index)\r\n{\r\nstruct fw_iso_packet p;\r\np.payload_length = MAX_PACKET_SIZE;\r\np.interrupt = !(++ctx->interrupt_packet & (IRQ_INTERVAL - 1));\r\np.skip = 0;\r\np.header_length = ISO_HEADER_SIZE;\r\nreturn fw_iso_context_queue(ctx->context, &p, &ctx->buffer,\r\nindex * MAX_PACKET_SIZE);\r\n}\r\nstatic void handle_iso(struct fw_iso_context *context, u32 cycle,\r\nsize_t header_length, void *header, void *data)\r\n{\r\nstruct firedtv *fdtv = data;\r\nstruct fdtv_ir_context *ctx = fdtv->ir_context;\r\n__be32 *h, *h_end;\r\nint length, err, i = ctx->current_packet;\r\nchar *p, *p_end;\r\nfor (h = header, h_end = h + header_length / 4; h < h_end; h++) {\r\nlength = be32_to_cpup(h) >> 16;\r\nif (unlikely(length > MAX_PACKET_SIZE)) {\r\ndev_err(fdtv->device, "length = %d\n", length);\r\nlength = MAX_PACKET_SIZE;\r\n}\r\np = ctx->pages[i / PACKETS_PER_PAGE]\r\n+ (i % PACKETS_PER_PAGE) * MAX_PACKET_SIZE;\r\np_end = p + length;\r\nfor (p += CIP_HEADER_SIZE + MPEG2_TS_HEADER_SIZE; p < p_end;\r\np += MPEG2_TS_SOURCE_PACKET_SIZE)\r\ndvb_dmx_swfilter_packets(&fdtv->demux, p, 1);\r\nerr = queue_iso(ctx, i);\r\nif (unlikely(err))\r\ndev_err(fdtv->device, "requeue failed\n");\r\ni = (i + 1) & (N_PACKETS - 1);\r\n}\r\nfw_iso_context_queue_flush(ctx->context);\r\nctx->current_packet = i;\r\n}\r\nint fdtv_start_iso(struct firedtv *fdtv)\r\n{\r\nstruct fdtv_ir_context *ctx;\r\nstruct fw_device *device = device_of(fdtv);\r\nint i, err;\r\nctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->context = fw_iso_context_create(device->card,\r\nFW_ISO_CONTEXT_RECEIVE, fdtv->isochannel,\r\ndevice->max_speed, ISO_HEADER_SIZE, handle_iso, fdtv);\r\nif (IS_ERR(ctx->context)) {\r\nerr = PTR_ERR(ctx->context);\r\ngoto fail_free;\r\n}\r\nerr = fw_iso_buffer_init(&ctx->buffer, device->card,\r\nN_PAGES, DMA_FROM_DEVICE);\r\nif (err)\r\ngoto fail_context_destroy;\r\nctx->interrupt_packet = 0;\r\nctx->current_packet = 0;\r\nfor (i = 0; i < N_PAGES; i++)\r\nctx->pages[i] = page_address(ctx->buffer.pages[i]);\r\nfor (i = 0; i < N_PACKETS; i++) {\r\nerr = queue_iso(ctx, i);\r\nif (err)\r\ngoto fail;\r\n}\r\nerr = fw_iso_context_start(ctx->context, -1, 0,\r\nFW_ISO_CONTEXT_MATCH_ALL_TAGS);\r\nif (err)\r\ngoto fail;\r\nfdtv->ir_context = ctx;\r\nreturn 0;\r\nfail:\r\nfw_iso_buffer_destroy(&ctx->buffer, device->card);\r\nfail_context_destroy:\r\nfw_iso_context_destroy(ctx->context);\r\nfail_free:\r\nkfree(ctx);\r\nreturn err;\r\n}\r\nvoid fdtv_stop_iso(struct firedtv *fdtv)\r\n{\r\nstruct fdtv_ir_context *ctx = fdtv->ir_context;\r\nfw_iso_context_stop(ctx->context);\r\nfw_iso_buffer_destroy(&ctx->buffer, device_of(fdtv)->card);\r\nfw_iso_context_destroy(ctx->context);\r\nkfree(ctx);\r\n}\r\nstatic void handle_fcp(struct fw_card *card, struct fw_request *request,\r\nint tcode, int destination, int source, int generation,\r\nunsigned long long offset, void *payload, size_t length,\r\nvoid *callback_data)\r\n{\r\nstruct firedtv *f, *fdtv = NULL;\r\nstruct fw_device *device;\r\nunsigned long flags;\r\nint su;\r\nif (length < 2 || (((u8 *)payload)[0] & 0xf0) != 0)\r\nreturn;\r\nsu = ((u8 *)payload)[1] & 0x7;\r\nspin_lock_irqsave(&node_list_lock, flags);\r\nlist_for_each_entry(f, &node_list, list) {\r\ndevice = device_of(f);\r\nif (device->generation != generation)\r\ncontinue;\r\nsmp_rmb();\r\nif (device->card == card &&\r\ndevice->node_id == source &&\r\n(f->subunit == su || (f->subunit == 0 && su == 0x7))) {\r\nfdtv = f;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&node_list_lock, flags);\r\nif (fdtv)\r\navc_recv(fdtv, payload, length);\r\n}\r\nstatic int node_probe(struct fw_unit *unit, const struct ieee1394_device_id *id)\r\n{\r\nstruct firedtv *fdtv;\r\nchar name[MAX_MODEL_NAME_LEN];\r\nint name_len, i, err;\r\nfdtv = kzalloc(sizeof(*fdtv), GFP_KERNEL);\r\nif (!fdtv)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&unit->device, fdtv);\r\nfdtv->device = &unit->device;\r\nfdtv->isochannel = -1;\r\nfdtv->voltage = 0xff;\r\nfdtv->tone = 0xff;\r\nmutex_init(&fdtv->avc_mutex);\r\ninit_waitqueue_head(&fdtv->avc_wait);\r\nmutex_init(&fdtv->demux_mutex);\r\nINIT_WORK(&fdtv->remote_ctrl_work, avc_remote_ctrl_work);\r\nname_len = fw_csr_string(unit->directory, CSR_MODEL,\r\nname, sizeof(name));\r\nfor (i = ARRAY_SIZE(model_names); --i; )\r\nif (strlen(model_names[i]) <= name_len &&\r\nstrncmp(name, model_names[i], name_len) == 0)\r\nbreak;\r\nfdtv->type = i;\r\nerr = fdtv_register_rc(fdtv, &unit->device);\r\nif (err)\r\ngoto fail_free;\r\nspin_lock_irq(&node_list_lock);\r\nlist_add_tail(&fdtv->list, &node_list);\r\nspin_unlock_irq(&node_list_lock);\r\nerr = avc_identify_subunit(fdtv);\r\nif (err)\r\ngoto fail;\r\nerr = fdtv_dvb_register(fdtv, model_names[fdtv->type]);\r\nif (err)\r\ngoto fail;\r\navc_register_remote_control(fdtv);\r\nreturn 0;\r\nfail:\r\nspin_lock_irq(&node_list_lock);\r\nlist_del(&fdtv->list);\r\nspin_unlock_irq(&node_list_lock);\r\nfdtv_unregister_rc(fdtv);\r\nfail_free:\r\nkfree(fdtv);\r\nreturn err;\r\n}\r\nstatic void node_remove(struct fw_unit *unit)\r\n{\r\nstruct firedtv *fdtv = dev_get_drvdata(&unit->device);\r\nfdtv_dvb_unregister(fdtv);\r\nspin_lock_irq(&node_list_lock);\r\nlist_del(&fdtv->list);\r\nspin_unlock_irq(&node_list_lock);\r\nfdtv_unregister_rc(fdtv);\r\nkfree(fdtv);\r\n}\r\nstatic void node_update(struct fw_unit *unit)\r\n{\r\nstruct firedtv *fdtv = dev_get_drvdata(&unit->device);\r\nif (fdtv->isochannel >= 0)\r\ncmp_establish_pp_connection(fdtv, fdtv->subunit,\r\nfdtv->isochannel);\r\n}\r\nstatic int __init fdtv_init(void)\r\n{\r\nint ret;\r\nret = fw_core_add_address_handler(&fcp_handler, &fcp_region);\r\nif (ret < 0)\r\nreturn ret;\r\nret = driver_register(&fdtv_driver.driver);\r\nif (ret < 0)\r\nfw_core_remove_address_handler(&fcp_handler);\r\nreturn ret;\r\n}\r\nstatic void __exit fdtv_exit(void)\r\n{\r\ndriver_unregister(&fdtv_driver.driver);\r\nfw_core_remove_address_handler(&fcp_handler);\r\n}
