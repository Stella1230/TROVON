static int\r\ncheck_smb2_hdr(struct smb2_hdr *hdr, __u64 mid)\r\n{\r\nif ((*(__le32 *)hdr->ProtocolId == SMB2_PROTO_NUMBER) &&\r\n(mid == hdr->MessageId)) {\r\nif (hdr->Flags & SMB2_FLAGS_SERVER_TO_REDIR)\r\nreturn 0;\r\nelse {\r\nif (hdr->Command == SMB2_OPLOCK_BREAK)\r\nreturn 0;\r\nelse\r\ncifs_dbg(VFS, "Received Request not response\n");\r\n}\r\n} else {\r\nif (*(__le32 *)hdr->ProtocolId != SMB2_PROTO_NUMBER)\r\ncifs_dbg(VFS, "Bad protocol string signature header %x\n",\r\n*(unsigned int *) hdr->ProtocolId);\r\nif (mid != hdr->MessageId)\r\ncifs_dbg(VFS, "Mids do not match: %llu and %llu\n",\r\nmid, hdr->MessageId);\r\n}\r\ncifs_dbg(VFS, "Bad SMB detected. The Mid=%llu\n", hdr->MessageId);\r\nreturn 1;\r\n}\r\nint\r\nsmb2_check_message(char *buf, unsigned int length)\r\n{\r\nstruct smb2_hdr *hdr = (struct smb2_hdr *)buf;\r\nstruct smb2_pdu *pdu = (struct smb2_pdu *)hdr;\r\n__u64 mid = hdr->MessageId;\r\n__u32 len = get_rfc1002_length(buf);\r\n__u32 clc_len;\r\nint command;\r\ncifs_dbg(FYI, "%s length: 0x%x, smb_buf_length: 0x%x\n",\r\n__func__, length, len);\r\nif (length < sizeof(struct smb2_pdu)) {\r\nif ((length >= sizeof(struct smb2_hdr)) && (hdr->Status != 0)) {\r\npdu->StructureSize2 = 0;\r\nreturn 0;\r\n} else {\r\ncifs_dbg(VFS, "Length less than SMB header size\n");\r\n}\r\nreturn 1;\r\n}\r\nif (len > CIFSMaxBufSize + MAX_SMB2_HDR_SIZE - 4) {\r\ncifs_dbg(VFS, "SMB length greater than maximum, mid=%llu\n",\r\nmid);\r\nreturn 1;\r\n}\r\nif (check_smb2_hdr(hdr, mid))\r\nreturn 1;\r\nif (hdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {\r\ncifs_dbg(VFS, "Illegal structure size %u\n",\r\nle16_to_cpu(hdr->StructureSize));\r\nreturn 1;\r\n}\r\ncommand = le16_to_cpu(hdr->Command);\r\nif (command >= NUMBER_OF_SMB2_COMMANDS) {\r\ncifs_dbg(VFS, "Illegal SMB2 command %d\n", command);\r\nreturn 1;\r\n}\r\nif (smb2_rsp_struct_sizes[command] != pdu->StructureSize2) {\r\nif (command != SMB2_OPLOCK_BREAK_HE && (hdr->Status == 0 ||\r\npdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2)) {\r\ncifs_dbg(VFS, "Illegal response size %u for command %d\n",\r\nle16_to_cpu(pdu->StructureSize2), command);\r\nreturn 1;\r\n} else if (command == SMB2_OPLOCK_BREAK_HE && (hdr->Status == 0)\r\n&& (le16_to_cpu(pdu->StructureSize2) != 44)\r\n&& (le16_to_cpu(pdu->StructureSize2) != 36)) {\r\ncifs_dbg(VFS, "Illegal response size %d for oplock break\n",\r\nle16_to_cpu(pdu->StructureSize2));\r\nreturn 1;\r\n}\r\n}\r\nif (4 + len != length) {\r\ncifs_dbg(VFS, "Total length %u RFC1002 length %u mismatch mid %llu\n",\r\nlength, 4 + len, mid);\r\nreturn 1;\r\n}\r\nclc_len = smb2_calc_size(hdr);\r\nif (4 + len != clc_len) {\r\ncifs_dbg(FYI, "Calculated size %u length %u mismatch mid %llu\n",\r\nclc_len, 4 + len, mid);\r\nif (command == SMB2_CREATE_HE &&\r\nhdr->Status == STATUS_STOPPED_ON_SYMLINK)\r\nreturn 0;\r\nif (clc_len + 20 == len && command == SMB2_OPLOCK_BREAK_HE)\r\nreturn 0;\r\nif (clc_len == 4 + len + 1)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nchar *\r\nsmb2_get_data_area_len(int *off, int *len, struct smb2_hdr *hdr)\r\n{\r\n*off = 0;\r\n*len = 0;\r\nif (hdr->Status && hdr->Status != STATUS_MORE_PROCESSING_REQUIRED &&\r\n(((struct smb2_err_rsp *)hdr)->StructureSize) ==\r\nSMB2_ERROR_STRUCTURE_SIZE2)\r\nreturn NULL;\r\nswitch (hdr->Command) {\r\ncase SMB2_NEGOTIATE:\r\n*off = le16_to_cpu(\r\n((struct smb2_negotiate_rsp *)hdr)->SecurityBufferOffset);\r\n*len = le16_to_cpu(\r\n((struct smb2_negotiate_rsp *)hdr)->SecurityBufferLength);\r\nbreak;\r\ncase SMB2_SESSION_SETUP:\r\n*off = le16_to_cpu(\r\n((struct smb2_sess_setup_rsp *)hdr)->SecurityBufferOffset);\r\n*len = le16_to_cpu(\r\n((struct smb2_sess_setup_rsp *)hdr)->SecurityBufferLength);\r\nbreak;\r\ncase SMB2_CREATE:\r\n*off = le32_to_cpu(\r\n((struct smb2_create_rsp *)hdr)->CreateContextsOffset);\r\n*len = le32_to_cpu(\r\n((struct smb2_create_rsp *)hdr)->CreateContextsLength);\r\nbreak;\r\ncase SMB2_QUERY_INFO:\r\n*off = le16_to_cpu(\r\n((struct smb2_query_info_rsp *)hdr)->OutputBufferOffset);\r\n*len = le32_to_cpu(\r\n((struct smb2_query_info_rsp *)hdr)->OutputBufferLength);\r\nbreak;\r\ncase SMB2_READ:\r\n*off = ((struct smb2_read_rsp *)hdr)->DataOffset;\r\n*len = le32_to_cpu(((struct smb2_read_rsp *)hdr)->DataLength);\r\nbreak;\r\ncase SMB2_QUERY_DIRECTORY:\r\n*off = le16_to_cpu(\r\n((struct smb2_query_directory_rsp *)hdr)->OutputBufferOffset);\r\n*len = le32_to_cpu(\r\n((struct smb2_query_directory_rsp *)hdr)->OutputBufferLength);\r\nbreak;\r\ncase SMB2_IOCTL:\r\n*off = le32_to_cpu(\r\n((struct smb2_ioctl_rsp *)hdr)->OutputOffset);\r\n*len = le32_to_cpu(((struct smb2_ioctl_rsp *)hdr)->OutputCount);\r\nbreak;\r\ncase SMB2_CHANGE_NOTIFY:\r\ndefault:\r\ncifs_dbg(VFS, "no length check for command\n");\r\nbreak;\r\n}\r\nif (*off > 4096) {\r\ncifs_dbg(VFS, "offset %d too large, data area ignored\n", *off);\r\n*len = 0;\r\n*off = 0;\r\n} else if (*off < 0) {\r\ncifs_dbg(VFS, "negative offset %d to data invalid ignore data area\n",\r\n*off);\r\n*off = 0;\r\n*len = 0;\r\n} else if (*len < 0) {\r\ncifs_dbg(VFS, "negative data length %d invalid, data area ignored\n",\r\n*len);\r\n*len = 0;\r\n} else if (*len > 128 * 1024) {\r\ncifs_dbg(VFS, "data area larger than 128K: %d\n", *len);\r\n*len = 0;\r\n}\r\nif ((*off != 0) && (*len != 0))\r\nreturn hdr->ProtocolId + *off;\r\nelse\r\nreturn NULL;\r\n}\r\nunsigned int\r\nsmb2_calc_size(void *buf)\r\n{\r\nstruct smb2_hdr *hdr = (struct smb2_hdr *)buf;\r\nstruct smb2_pdu *pdu = (struct smb2_pdu *)hdr;\r\nint offset;\r\nint data_length;\r\nint len = 4 + le16_to_cpu(pdu->hdr.StructureSize);\r\nlen += le16_to_cpu(pdu->StructureSize2);\r\nif (has_smb2_data_area[le16_to_cpu(hdr->Command)] == false)\r\ngoto calc_size_exit;\r\nsmb2_get_data_area_len(&offset, &data_length, hdr);\r\ncifs_dbg(FYI, "SMB2 data length %d offset %d\n", data_length, offset);\r\nif (data_length > 0) {\r\nif (offset + 4 + 1 < len) {\r\ncifs_dbg(VFS, "data area offset %d overlaps SMB2 header %d\n",\r\noffset + 4 + 1, len);\r\ndata_length = 0;\r\n} else {\r\nlen = 4 + offset + data_length;\r\n}\r\n}\r\ncalc_size_exit:\r\ncifs_dbg(FYI, "SMB2 len %d\n", len);\r\nreturn len;\r\n}\r\n__le16 *\r\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\r\n{\r\nint len;\r\nconst char *start_of_path;\r\n__le16 *to;\r\nif (from[0] == '\\')\r\nstart_of_path = from + 1;\r\nelse\r\nstart_of_path = from;\r\nto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\r\ncifs_sb->local_nls,\r\ncifs_sb->mnt_cifs_flags &\r\nCIFS_MOUNT_MAP_SPECIAL_CHR);\r\nreturn to;\r\n}\r\n__le32\r\nsmb2_get_lease_state(struct cifsInodeInfo *cinode)\r\n{\r\n__le32 lease = 0;\r\nif (CIFS_CACHE_WRITE(cinode))\r\nlease |= SMB2_LEASE_WRITE_CACHING;\r\nif (CIFS_CACHE_HANDLE(cinode))\r\nlease |= SMB2_LEASE_HANDLE_CACHING;\r\nif (CIFS_CACHE_READ(cinode))\r\nlease |= SMB2_LEASE_READ_CACHING;\r\nreturn lease;\r\n}\r\nstatic void\r\ncifs_ses_oplock_break(struct work_struct *work)\r\n{\r\nstruct smb2_lease_break_work *lw = container_of(work,\r\nstruct smb2_lease_break_work, lease_break);\r\nint rc;\r\nrc = SMB2_lease_break(0, tlink_tcon(lw->tlink), lw->lease_key,\r\nlw->lease_state);\r\ncifs_dbg(FYI, "Lease release rc %d\n", rc);\r\ncifs_put_tlink(lw->tlink);\r\nkfree(lw);\r\n}\r\nstatic bool\r\nsmb2_tcon_has_lease(struct cifs_tcon *tcon, struct smb2_lease_break *rsp,\r\nstruct smb2_lease_break_work *lw)\r\n{\r\nbool found;\r\n__u8 lease_state;\r\nstruct list_head *tmp;\r\nstruct cifsFileInfo *cfile;\r\nstruct TCP_Server_Info *server = tcon->ses->server;\r\nstruct cifs_pending_open *open;\r\nstruct cifsInodeInfo *cinode;\r\nint ack_req = le32_to_cpu(rsp->Flags &\r\nSMB2_NOTIFY_BREAK_LEASE_FLAG_ACK_REQUIRED);\r\nlease_state = le32_to_cpu(rsp->NewLeaseState);\r\nlist_for_each(tmp, &tcon->openFileList) {\r\ncfile = list_entry(tmp, struct cifsFileInfo, tlist);\r\ncinode = CIFS_I(cfile->dentry->d_inode);\r\nif (memcmp(cinode->lease_key, rsp->LeaseKey,\r\nSMB2_LEASE_KEY_SIZE))\r\ncontinue;\r\ncifs_dbg(FYI, "found in the open list\n");\r\ncifs_dbg(FYI, "lease key match, lease break 0x%d\n",\r\nle32_to_cpu(rsp->NewLeaseState));\r\nserver->ops->set_oplock_level(cinode, lease_state, 0, NULL);\r\nif (ack_req)\r\ncfile->oplock_break_cancelled = false;\r\nelse\r\ncfile->oplock_break_cancelled = true;\r\nqueue_work(cifsiod_wq, &cfile->oplock_break);\r\nkfree(lw);\r\nreturn true;\r\n}\r\nfound = false;\r\nlist_for_each_entry(open, &tcon->pending_opens, olist) {\r\nif (memcmp(open->lease_key, rsp->LeaseKey,\r\nSMB2_LEASE_KEY_SIZE))\r\ncontinue;\r\nif (!found && ack_req) {\r\nfound = true;\r\nmemcpy(lw->lease_key, open->lease_key,\r\nSMB2_LEASE_KEY_SIZE);\r\nlw->tlink = cifs_get_tlink(open->tlink);\r\nqueue_work(cifsiod_wq, &lw->lease_break);\r\n}\r\ncifs_dbg(FYI, "found in the pending open list\n");\r\ncifs_dbg(FYI, "lease key match, lease break 0x%d\n",\r\nle32_to_cpu(rsp->NewLeaseState));\r\nopen->oplock = lease_state;\r\n}\r\nreturn found;\r\n}\r\nstatic bool\r\nsmb2_is_valid_lease_break(char *buffer)\r\n{\r\nstruct smb2_lease_break *rsp = (struct smb2_lease_break *)buffer;\r\nstruct list_head *tmp, *tmp1, *tmp2;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_ses *ses;\r\nstruct cifs_tcon *tcon;\r\nstruct smb2_lease_break_work *lw;\r\nlw = kmalloc(sizeof(struct smb2_lease_break_work), GFP_KERNEL);\r\nif (!lw)\r\nreturn false;\r\nINIT_WORK(&lw->lease_break, cifs_ses_oplock_break);\r\nlw->lease_state = rsp->NewLeaseState;\r\ncifs_dbg(FYI, "Checking for lease break\n");\r\nspin_lock(&cifs_tcp_ses_lock);\r\nlist_for_each(tmp, &cifs_tcp_ses_list) {\r\nserver = list_entry(tmp, struct TCP_Server_Info, tcp_ses_list);\r\nlist_for_each(tmp1, &server->smb_ses_list) {\r\nses = list_entry(tmp1, struct cifs_ses, smb_ses_list);\r\nspin_lock(&cifs_file_list_lock);\r\nlist_for_each(tmp2, &ses->tcon_list) {\r\ntcon = list_entry(tmp2, struct cifs_tcon,\r\ntcon_list);\r\ncifs_stats_inc(\r\n&tcon->stats.cifs_stats.num_oplock_brks);\r\nif (smb2_tcon_has_lease(tcon, rsp, lw)) {\r\nspin_unlock(&cifs_file_list_lock);\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nreturn true;\r\n}\r\n}\r\nspin_unlock(&cifs_file_list_lock);\r\n}\r\n}\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nkfree(lw);\r\ncifs_dbg(FYI, "Can not process lease break - no lease matched\n");\r\nreturn false;\r\n}\r\nbool\r\nsmb2_is_valid_oplock_break(char *buffer, struct TCP_Server_Info *server)\r\n{\r\nstruct smb2_oplock_break *rsp = (struct smb2_oplock_break *)buffer;\r\nstruct list_head *tmp, *tmp1, *tmp2;\r\nstruct cifs_ses *ses;\r\nstruct cifs_tcon *tcon;\r\nstruct cifsInodeInfo *cinode;\r\nstruct cifsFileInfo *cfile;\r\ncifs_dbg(FYI, "Checking for oplock break\n");\r\nif (rsp->hdr.Command != SMB2_OPLOCK_BREAK)\r\nreturn false;\r\nif (rsp->StructureSize !=\r\nsmb2_rsp_struct_sizes[SMB2_OPLOCK_BREAK_HE]) {\r\nif (le16_to_cpu(rsp->StructureSize) == 44)\r\nreturn smb2_is_valid_lease_break(buffer);\r\nelse\r\nreturn false;\r\n}\r\ncifs_dbg(FYI, "oplock level 0x%d\n", rsp->OplockLevel);\r\nspin_lock(&cifs_tcp_ses_lock);\r\nlist_for_each(tmp, &server->smb_ses_list) {\r\nses = list_entry(tmp, struct cifs_ses, smb_ses_list);\r\nlist_for_each(tmp1, &ses->tcon_list) {\r\ntcon = list_entry(tmp1, struct cifs_tcon, tcon_list);\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_oplock_brks);\r\nspin_lock(&cifs_file_list_lock);\r\nlist_for_each(tmp2, &tcon->openFileList) {\r\ncfile = list_entry(tmp2, struct cifsFileInfo,\r\ntlist);\r\nif (rsp->PersistentFid !=\r\ncfile->fid.persistent_fid ||\r\nrsp->VolatileFid !=\r\ncfile->fid.volatile_fid)\r\ncontinue;\r\ncifs_dbg(FYI, "file id match, oplock break\n");\r\ncinode = CIFS_I(cfile->dentry->d_inode);\r\nif (!CIFS_CACHE_WRITE(cinode) &&\r\nrsp->OplockLevel == SMB2_OPLOCK_LEVEL_NONE)\r\ncfile->oplock_break_cancelled = true;\r\nelse\r\ncfile->oplock_break_cancelled = false;\r\nserver->ops->set_oplock_level(cinode,\r\nrsp->OplockLevel ? SMB2_OPLOCK_LEVEL_II : 0,\r\n0, NULL);\r\nqueue_work(cifsiod_wq, &cfile->oplock_break);\r\nspin_unlock(&cifs_file_list_lock);\r\nspin_unlock(&cifs_tcp_ses_lock);\r\nreturn true;\r\n}\r\nspin_unlock(&cifs_file_list_lock);\r\nspin_unlock(&cifs_tcp_ses_lock);\r\ncifs_dbg(FYI, "No matching file for oplock break\n");\r\nreturn true;\r\n}\r\n}\r\nspin_unlock(&cifs_tcp_ses_lock);\r\ncifs_dbg(FYI, "Can not process oplock break for non-existent connection\n");\r\nreturn false;\r\n}
