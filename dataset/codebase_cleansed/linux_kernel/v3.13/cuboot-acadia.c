static void get_clocks(void)\r\n{\r\nunsigned long sysclk, cpr_plld, cpr_pllc, cpr_primad, plloutb, i;\r\nunsigned long pllFwdDiv, pllFwdDivB, pllFbkDiv, pllPlbDiv, pllExtBusDiv;\r\nunsigned long pllOpbDiv, freqEBC, freqUART, freqOPB;\r\nunsigned long div;\r\nunsigned long umin;\r\nunsigned short diff;\r\nunsigned long udiv;\r\nunsigned short idiff;\r\nunsigned short ibdiv;\r\nunsigned long est;\r\nunsigned long baud;\r\nvoid *np;\r\nsysclk = (in_8((unsigned char *)0x80000000) == 0xc) ? 66666666 : 33333000;\r\ncpr_plld = CPR0_READ(DCRN_CPR0_PLLD);\r\ncpr_pllc = CPR0_READ(DCRN_CPR0_PLLC);\r\npllFwdDiv = ((cpr_plld & PLLD_FWDVA_MASK) >> 16);\r\npllFwdDivB = ((cpr_plld & PLLD_FWDVB_MASK) >> 8);\r\nif (pllFwdDivB == 0)\r\npllFwdDivB = 8;\r\npllFbkDiv = ((cpr_plld & PLLD_FBDV_MASK) >> 24);\r\nif (pllFbkDiv == 0)\r\npllFbkDiv = 256;\r\ncpr_primad = CPR0_READ(DCRN_CPR0_PRIMAD);\r\npllPlbDiv = ((cpr_primad & PRIMAD_PLBDV_MASK) >> 16);\r\nif (pllPlbDiv == 0)\r\npllPlbDiv = 16;\r\npllExtBusDiv = (cpr_primad & PRIMAD_EBCDV_MASK);\r\nif (pllExtBusDiv == 0)\r\npllExtBusDiv = 16;\r\npllOpbDiv = ((cpr_primad & PRIMAD_OPBDV_MASK) >> 8);\r\nif (pllOpbDiv == 0)\r\npllOpbDiv = 16;\r\nfreqOPB = (sysclk *pllFbkDiv) /pllOpbDiv;\r\nfreqEBC = (sysclk * pllFbkDiv) / pllExtBusDiv;\r\nplloutb = ((sysclk * ((cpr_pllc & PLLC_SRC_MASK) ?\r\npllFwdDivB : pllFwdDiv) *\r\npllFbkDiv) / pllFwdDivB);\r\nnp = find_node_by_alias("serial0");\r\nif (getprop(np, "current-speed", &baud, sizeof(baud)) != sizeof(baud))\r\nfatal("no current-speed property\n\r");\r\nudiv = 256;\r\ndiv = plloutb / (16 * baud);\r\numin = (plloutb / freqOPB) << 1;\r\ndiff = 256;\r\nfor (i = 256; i > umin; i--) {\r\nibdiv = div / i;\r\nest = i * ibdiv;\r\nidiff = (est > div) ? (est-div) : (div-est);\r\nif (idiff == 0) {\r\nudiv = i;\r\nbreak;\r\n} else if (idiff < diff) {\r\nudiv = i;\r\ndiff = idiff;\r\n}\r\n}\r\nfreqUART = plloutb / udiv;\r\ndt_fixup_cpu_clocks(bd.bi_procfreq, bd.bi_intfreq, bd.bi_plb_busfreq);\r\ndt_fixup_clock("/plb/ebc", freqEBC);\r\ndt_fixup_clock("/plb/opb", freqOPB);\r\ndt_fixup_clock("/plb/opb/serial@ef600300", freqUART);\r\ndt_fixup_clock("/plb/opb/serial@ef600400", freqUART);\r\n}\r\nstatic void acadia_fixups(void)\r\n{\r\ndt_fixup_memory(bd.bi_memstart, bd.bi_memsize);\r\nget_clocks();\r\ndt_fixup_mac_address_by_alias("ethernet0", bd.bi_enetaddr);\r\n}\r\nvoid platform_init(unsigned long r3, unsigned long r4, unsigned long r5,\r\nunsigned long r6, unsigned long r7)\r\n{\r\nCUBOOT_INIT();\r\nplatform_ops.fixups = acadia_fixups;\r\nplatform_ops.exit = ibm40x_dbcr_reset;\r\nfdt_init(_dtb_start);\r\nserial_console_init();\r\n}
