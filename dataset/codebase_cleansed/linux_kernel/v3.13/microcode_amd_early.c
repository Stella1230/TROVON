static struct cpio_data __init find_ucode_in_initrd(void)\r\n{\r\nlong offset = 0;\r\nchar *path;\r\nvoid *start;\r\nsize_t size;\r\nunsigned long *uoffset;\r\nsize_t *usize;\r\nstruct cpio_data cd;\r\n#ifdef CONFIG_X86_32\r\nstruct boot_params *p;\r\np = (struct boot_params *)__pa_nodebug(&boot_params);\r\npath = (char *)__pa_nodebug(ucode_path);\r\nstart = (void *)p->hdr.ramdisk_image;\r\nsize = p->hdr.ramdisk_size;\r\nuoffset = (unsigned long *)__pa_nodebug(&ucode_offset);\r\nusize = (size_t *)__pa_nodebug(&ucode_size);\r\n#else\r\npath = ucode_path;\r\nstart = (void *)(boot_params.hdr.ramdisk_image + PAGE_OFFSET);\r\nsize = boot_params.hdr.ramdisk_size;\r\nuoffset = &ucode_offset;\r\nusize = &ucode_size;\r\n#endif\r\ncd = find_cpio_data(path, start, size, &offset);\r\nif (!cd.data)\r\nreturn cd;\r\nif (*(u32 *)cd.data != UCODE_MAGIC) {\r\ncd.data = NULL;\r\ncd.size = 0;\r\nreturn cd;\r\n}\r\n*uoffset = (u8 *)cd.data - (u8 *)start;\r\n*usize = cd.size;\r\nreturn cd;\r\n}\r\nstatic void apply_ucode_in_initrd(void *ucode, size_t size)\r\n{\r\nstruct equiv_cpu_entry *eq;\r\nu32 *header;\r\nu8 *data;\r\nu16 eq_id = 0;\r\nint offset, left;\r\nu32 rev, eax;\r\nu32 *new_rev;\r\nunsigned long *uoffset;\r\nsize_t *usize;\r\n#ifdef CONFIG_X86_32\r\nnew_rev = (u32 *)__pa_nodebug(&ucode_new_rev);\r\nuoffset = (unsigned long *)__pa_nodebug(&ucode_offset);\r\nusize = (size_t *)__pa_nodebug(&ucode_size);\r\n#else\r\nnew_rev = &ucode_new_rev;\r\nuoffset = &ucode_offset;\r\nusize = &ucode_size;\r\n#endif\r\ndata = ucode;\r\nleft = size;\r\nheader = (u32 *)data;\r\nif (header[1] != UCODE_EQUIV_CPU_TABLE_TYPE ||\r\nheader[2] == 0)\r\nreturn;\r\neax = cpuid_eax(0x00000001);\r\nwhile (left > 0) {\r\neq = (struct equiv_cpu_entry *)(data + CONTAINER_HDR_SZ);\r\noffset = header[2] + CONTAINER_HDR_SZ;\r\ndata += offset;\r\nleft -= offset;\r\neq_id = find_equiv_id(eq, eax);\r\nif (eq_id)\r\nbreak;\r\nwhile (left > 0) {\r\nheader = (u32 *)data;\r\nif (header[0] == UCODE_MAGIC &&\r\nheader[1] == UCODE_EQUIV_CPU_TABLE_TYPE)\r\nbreak;\r\noffset = header[1] + SECTION_HDR_SIZE;\r\ndata += offset;\r\nleft -= offset;\r\n}\r\noffset = data - (u8 *)ucode;\r\n*uoffset += offset;\r\n*usize -= offset;\r\nucode = data;\r\n}\r\nif (!eq_id) {\r\n*usize = 0;\r\nreturn;\r\n}\r\nrdmsr(MSR_AMD64_PATCH_LEVEL, rev, eax);\r\nwhile (left > 0) {\r\nstruct microcode_amd *mc;\r\nheader = (u32 *)data;\r\nif (header[0] != UCODE_UCODE_TYPE ||\r\nheader[1] == 0)\r\nbreak;\r\nmc = (struct microcode_amd *)(data + SECTION_HDR_SIZE);\r\nif (eq_id == mc->hdr.processor_rev_id && rev < mc->hdr.patch_id)\r\nif (__apply_microcode_amd(mc) == 0) {\r\nrev = mc->hdr.patch_id;\r\n*new_rev = rev;\r\n}\r\noffset = header[1] + SECTION_HDR_SIZE;\r\ndata += offset;\r\nleft -= offset;\r\n}\r\noffset = *usize - (data - (u8 *)ucode);\r\n*usize -= offset;\r\nif (!(*new_rev))\r\n*usize = 0;\r\n}\r\nvoid __init load_ucode_amd_bsp(void)\r\n{\r\nstruct cpio_data cd = find_ucode_in_initrd();\r\nif (!cd.data)\r\nreturn;\r\napply_ucode_in_initrd(cd.data, cd.size);\r\n}\r\nvoid load_ucode_amd_ap(void)\r\n{\r\nstruct microcode_amd *mc;\r\nunsigned long *initrd;\r\nunsigned long *uoffset;\r\nsize_t *usize;\r\nvoid *ucode;\r\nmc = (struct microcode_amd *)__pa(amd_bsp_mpb);\r\nif (mc->hdr.patch_id && mc->hdr.processor_rev_id) {\r\n__apply_microcode_amd(mc);\r\nreturn;\r\n}\r\ninitrd = (unsigned long *)__pa(&initrd_start);\r\nuoffset = (unsigned long *)__pa(&ucode_offset);\r\nusize = (size_t *)__pa(&ucode_size);\r\nif (!*usize || !*initrd)\r\nreturn;\r\nucode = (void *)((unsigned long)__pa(*initrd) + *uoffset);\r\napply_ucode_in_initrd(ucode, *usize);\r\n}\r\nstatic void __init collect_cpu_sig_on_bsp(void *arg)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nuci->cpu_sig.sig = cpuid_eax(0x00000001);\r\n}\r\nvoid load_ucode_amd_ap(void)\r\n{\r\nunsigned int cpu = smp_processor_id();\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + cpu;\r\nu32 rev, eax;\r\nrdmsr(MSR_AMD64_PATCH_LEVEL, rev, eax);\r\neax = cpuid_eax(0x00000001);\r\nuci->cpu_sig.rev = rev;\r\nuci->cpu_sig.sig = eax;\r\nif (cpu && !ucode_loaded) {\r\nvoid *ucode;\r\nif (!ucode_size || !initrd_start)\r\nreturn;\r\nucode = (void *)(initrd_start + ucode_offset);\r\neax = ((eax >> 8) & 0xf) + ((eax >> 20) & 0xff);\r\nif (load_microcode_amd(eax, ucode, ucode_size) != UCODE_OK)\r\nreturn;\r\nucode_loaded = true;\r\n}\r\napply_microcode_amd(cpu);\r\n}\r\nint __init save_microcode_in_initrd_amd(void)\r\n{\r\nenum ucode_state ret;\r\nvoid *ucode;\r\nu32 eax;\r\n#ifdef CONFIG_X86_32\r\nunsigned int bsp = boot_cpu_data.cpu_index;\r\nstruct ucode_cpu_info *uci = ucode_cpu_info + bsp;\r\nif (!uci->cpu_sig.sig)\r\nsmp_call_function_single(bsp, collect_cpu_sig_on_bsp, NULL, 1);\r\n#endif\r\nif (ucode_new_rev)\r\npr_info("microcode: updated early to new patch_level=0x%08x\n",\r\nucode_new_rev);\r\nif (ucode_loaded || !ucode_size || !initrd_start)\r\nreturn 0;\r\nucode = (void *)(initrd_start + ucode_offset);\r\neax = cpuid_eax(0x00000001);\r\neax = ((eax >> 8) & 0xf) + ((eax >> 20) & 0xff);\r\nret = load_microcode_amd(eax, ucode, ucode_size);\r\nif (ret != UCODE_OK)\r\nreturn -EINVAL;\r\nucode_loaded = true;\r\nreturn 0;\r\n}
