int __init br_fdb_init(void)\r\n{\r\nbr_fdb_cache = kmem_cache_create("bridge_fdb_cache",\r\nsizeof(struct net_bridge_fdb_entry),\r\n0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!br_fdb_cache)\r\nreturn -ENOMEM;\r\nget_random_bytes(&fdb_salt, sizeof(fdb_salt));\r\nreturn 0;\r\n}\r\nvoid br_fdb_fini(void)\r\n{\r\nkmem_cache_destroy(br_fdb_cache);\r\n}\r\nstatic inline unsigned long hold_time(const struct net_bridge *br)\r\n{\r\nreturn br->topology_change ? br->forward_delay : br->ageing_time;\r\n}\r\nstatic inline int has_expired(const struct net_bridge *br,\r\nconst struct net_bridge_fdb_entry *fdb)\r\n{\r\nreturn !fdb->is_static &&\r\ntime_before_eq(fdb->updated + hold_time(br), jiffies);\r\n}\r\nstatic inline int br_mac_hash(const unsigned char *mac, __u16 vid)\r\n{\r\nu32 key = get_unaligned((u32 *)(mac + 2));\r\nreturn jhash_2words(key, vid, fdb_salt) & (BR_HASH_SIZE - 1);\r\n}\r\nstatic void fdb_rcu_free(struct rcu_head *head)\r\n{\r\nstruct net_bridge_fdb_entry *ent\r\n= container_of(head, struct net_bridge_fdb_entry, rcu);\r\nkmem_cache_free(br_fdb_cache, ent);\r\n}\r\nstatic void fdb_delete(struct net_bridge *br, struct net_bridge_fdb_entry *f)\r\n{\r\nhlist_del_rcu(&f->hlist);\r\nfdb_notify(br, f, RTM_DELNEIGH);\r\ncall_rcu(&f->rcu, fdb_rcu_free);\r\n}\r\nvoid br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr)\r\n{\r\nstruct net_bridge *br = p->br;\r\nbool no_vlan = (nbp_get_vlan_info(p) == NULL) ? true : false;\r\nint i;\r\nspin_lock_bh(&br->hash_lock);\r\nfor (i = 0; i < BR_HASH_SIZE; i++) {\r\nstruct hlist_node *h;\r\nhlist_for_each(h, &br->hash[i]) {\r\nstruct net_bridge_fdb_entry *f;\r\nf = hlist_entry(h, struct net_bridge_fdb_entry, hlist);\r\nif (f->dst == p && f->is_local) {\r\nstruct net_bridge_port *op;\r\nu16 vid = f->vlan_id;\r\nlist_for_each_entry(op, &br->port_list, list) {\r\nif (op != p &&\r\nether_addr_equal(op->dev->dev_addr,\r\nf->addr.addr) &&\r\nnbp_vlan_find(op, vid)) {\r\nf->dst = op;\r\ngoto insert;\r\n}\r\n}\r\nfdb_delete(br, f);\r\ninsert:\r\nfdb_insert(br, p, newaddr, vid);\r\nif (no_vlan)\r\ngoto done;\r\n}\r\n}\r\n}\r\ndone:\r\nspin_unlock_bh(&br->hash_lock);\r\n}\r\nvoid br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr)\r\n{\r\nstruct net_bridge_fdb_entry *f;\r\nstruct net_port_vlans *pv;\r\nu16 vid = 0;\r\nf = __br_fdb_get(br, br->dev->dev_addr, 0);\r\nif (f && f->is_local && !f->dst)\r\nfdb_delete(br, f);\r\nfdb_insert(br, NULL, newaddr, 0);\r\npv = br_get_vlan_info(br);\r\nif (!pv)\r\nreturn;\r\nfor_each_set_bit_from(vid, pv->vlan_bitmap, VLAN_N_VID) {\r\nf = __br_fdb_get(br, br->dev->dev_addr, vid);\r\nif (f && f->is_local && !f->dst)\r\nfdb_delete(br, f);\r\nfdb_insert(br, NULL, newaddr, vid);\r\n}\r\n}\r\nvoid br_fdb_cleanup(unsigned long _data)\r\n{\r\nstruct net_bridge *br = (struct net_bridge *)_data;\r\nunsigned long delay = hold_time(br);\r\nunsigned long next_timer = jiffies + br->ageing_time;\r\nint i;\r\nspin_lock(&br->hash_lock);\r\nfor (i = 0; i < BR_HASH_SIZE; i++) {\r\nstruct net_bridge_fdb_entry *f;\r\nstruct hlist_node *n;\r\nhlist_for_each_entry_safe(f, n, &br->hash[i], hlist) {\r\nunsigned long this_timer;\r\nif (f->is_static)\r\ncontinue;\r\nthis_timer = f->updated + delay;\r\nif (time_before_eq(this_timer, jiffies))\r\nfdb_delete(br, f);\r\nelse if (time_before(this_timer, next_timer))\r\nnext_timer = this_timer;\r\n}\r\n}\r\nspin_unlock(&br->hash_lock);\r\nmod_timer(&br->gc_timer, round_jiffies_up(next_timer));\r\n}\r\nvoid br_fdb_flush(struct net_bridge *br)\r\n{\r\nint i;\r\nspin_lock_bh(&br->hash_lock);\r\nfor (i = 0; i < BR_HASH_SIZE; i++) {\r\nstruct net_bridge_fdb_entry *f;\r\nstruct hlist_node *n;\r\nhlist_for_each_entry_safe(f, n, &br->hash[i], hlist) {\r\nif (!f->is_static)\r\nfdb_delete(br, f);\r\n}\r\n}\r\nspin_unlock_bh(&br->hash_lock);\r\n}\r\nvoid br_fdb_delete_by_port(struct net_bridge *br,\r\nconst struct net_bridge_port *p,\r\nint do_all)\r\n{\r\nint i;\r\nspin_lock_bh(&br->hash_lock);\r\nfor (i = 0; i < BR_HASH_SIZE; i++) {\r\nstruct hlist_node *h, *g;\r\nhlist_for_each_safe(h, g, &br->hash[i]) {\r\nstruct net_bridge_fdb_entry *f\r\n= hlist_entry(h, struct net_bridge_fdb_entry, hlist);\r\nif (f->dst != p)\r\ncontinue;\r\nif (f->is_static && !do_all)\r\ncontinue;\r\nif (f->is_local) {\r\nstruct net_bridge_port *op;\r\nlist_for_each_entry(op, &br->port_list, list) {\r\nif (op != p &&\r\nether_addr_equal(op->dev->dev_addr,\r\nf->addr.addr)) {\r\nf->dst = op;\r\ngoto skip_delete;\r\n}\r\n}\r\n}\r\nfdb_delete(br, f);\r\nskip_delete: ;\r\n}\r\n}\r\nspin_unlock_bh(&br->hash_lock);\r\n}\r\nstruct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,\r\nconst unsigned char *addr,\r\n__u16 vid)\r\n{\r\nstruct net_bridge_fdb_entry *fdb;\r\nhlist_for_each_entry_rcu(fdb,\r\n&br->hash[br_mac_hash(addr, vid)], hlist) {\r\nif (ether_addr_equal(fdb->addr.addr, addr) &&\r\nfdb->vlan_id == vid) {\r\nif (unlikely(has_expired(br, fdb)))\r\nbreak;\r\nreturn fdb;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nint br_fdb_test_addr(struct net_device *dev, unsigned char *addr)\r\n{\r\nstruct net_bridge_fdb_entry *fdb;\r\nstruct net_bridge_port *port;\r\nint ret;\r\nrcu_read_lock();\r\nport = br_port_get_rcu(dev);\r\nif (!port)\r\nret = 0;\r\nelse {\r\nfdb = __br_fdb_get(port->br, addr, 0);\r\nret = fdb && fdb->dst && fdb->dst->dev != dev &&\r\nfdb->dst->state == BR_STATE_FORWARDING;\r\n}\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nint br_fdb_fillbuf(struct net_bridge *br, void *buf,\r\nunsigned long maxnum, unsigned long skip)\r\n{\r\nstruct __fdb_entry *fe = buf;\r\nint i, num = 0;\r\nstruct net_bridge_fdb_entry *f;\r\nmemset(buf, 0, maxnum*sizeof(struct __fdb_entry));\r\nrcu_read_lock();\r\nfor (i = 0; i < BR_HASH_SIZE; i++) {\r\nhlist_for_each_entry_rcu(f, &br->hash[i], hlist) {\r\nif (num >= maxnum)\r\ngoto out;\r\nif (has_expired(br, f))\r\ncontinue;\r\nif (!f->dst)\r\ncontinue;\r\nif (skip) {\r\n--skip;\r\ncontinue;\r\n}\r\nmemcpy(fe->mac_addr, f->addr.addr, ETH_ALEN);\r\nfe->port_no = f->dst->port_no;\r\nfe->port_hi = f->dst->port_no >> 8;\r\nfe->is_local = f->is_local;\r\nif (!f->is_static)\r\nfe->ageing_timer_value = jiffies_delta_to_clock_t(jiffies - f->updated);\r\n++fe;\r\n++num;\r\n}\r\n}\r\nout:\r\nrcu_read_unlock();\r\nreturn num;\r\n}\r\nstatic struct net_bridge_fdb_entry *fdb_find(struct hlist_head *head,\r\nconst unsigned char *addr,\r\n__u16 vid)\r\n{\r\nstruct net_bridge_fdb_entry *fdb;\r\nhlist_for_each_entry(fdb, head, hlist) {\r\nif (ether_addr_equal(fdb->addr.addr, addr) &&\r\nfdb->vlan_id == vid)\r\nreturn fdb;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct net_bridge_fdb_entry *fdb_find_rcu(struct hlist_head *head,\r\nconst unsigned char *addr,\r\n__u16 vid)\r\n{\r\nstruct net_bridge_fdb_entry *fdb;\r\nhlist_for_each_entry_rcu(fdb, head, hlist) {\r\nif (ether_addr_equal(fdb->addr.addr, addr) &&\r\nfdb->vlan_id == vid)\r\nreturn fdb;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct net_bridge_fdb_entry *fdb_create(struct hlist_head *head,\r\nstruct net_bridge_port *source,\r\nconst unsigned char *addr,\r\n__u16 vid)\r\n{\r\nstruct net_bridge_fdb_entry *fdb;\r\nfdb = kmem_cache_alloc(br_fdb_cache, GFP_ATOMIC);\r\nif (fdb) {\r\nmemcpy(fdb->addr.addr, addr, ETH_ALEN);\r\nfdb->dst = source;\r\nfdb->vlan_id = vid;\r\nfdb->is_local = 0;\r\nfdb->is_static = 0;\r\nfdb->updated = fdb->used = jiffies;\r\nhlist_add_head_rcu(&fdb->hlist, head);\r\n}\r\nreturn fdb;\r\n}\r\nstatic int fdb_insert(struct net_bridge *br, struct net_bridge_port *source,\r\nconst unsigned char *addr, u16 vid)\r\n{\r\nstruct hlist_head *head = &br->hash[br_mac_hash(addr, vid)];\r\nstruct net_bridge_fdb_entry *fdb;\r\nif (!is_valid_ether_addr(addr))\r\nreturn -EINVAL;\r\nfdb = fdb_find(head, addr, vid);\r\nif (fdb) {\r\nif (fdb->is_local)\r\nreturn 0;\r\nbr_warn(br, "adding interface %s with same address "\r\n"as a received packet\n",\r\nsource ? source->dev->name : br->dev->name);\r\nfdb_delete(br, fdb);\r\n}\r\nfdb = fdb_create(head, source, addr, vid);\r\nif (!fdb)\r\nreturn -ENOMEM;\r\nfdb->is_local = fdb->is_static = 1;\r\nfdb_notify(br, fdb, RTM_NEWNEIGH);\r\nreturn 0;\r\n}\r\nint br_fdb_insert(struct net_bridge *br, struct net_bridge_port *source,\r\nconst unsigned char *addr, u16 vid)\r\n{\r\nint ret;\r\nspin_lock_bh(&br->hash_lock);\r\nret = fdb_insert(br, source, addr, vid);\r\nspin_unlock_bh(&br->hash_lock);\r\nreturn ret;\r\n}\r\nvoid br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,\r\nconst unsigned char *addr, u16 vid)\r\n{\r\nstruct hlist_head *head = &br->hash[br_mac_hash(addr, vid)];\r\nstruct net_bridge_fdb_entry *fdb;\r\nif (hold_time(br) == 0)\r\nreturn;\r\nif (!(source->state == BR_STATE_LEARNING ||\r\nsource->state == BR_STATE_FORWARDING))\r\nreturn;\r\nfdb = fdb_find_rcu(head, addr, vid);\r\nif (likely(fdb)) {\r\nif (unlikely(fdb->is_local)) {\r\nif (net_ratelimit())\r\nbr_warn(br, "received packet on %s with "\r\n"own address as source address\n",\r\nsource->dev->name);\r\n} else {\r\nfdb->dst = source;\r\nfdb->updated = jiffies;\r\n}\r\n} else {\r\nspin_lock(&br->hash_lock);\r\nif (likely(!fdb_find(head, addr, vid))) {\r\nfdb = fdb_create(head, source, addr, vid);\r\nif (fdb)\r\nfdb_notify(br, fdb, RTM_NEWNEIGH);\r\n}\r\nspin_unlock(&br->hash_lock);\r\n}\r\n}\r\nstatic int fdb_to_nud(const struct net_bridge_fdb_entry *fdb)\r\n{\r\nif (fdb->is_local)\r\nreturn NUD_PERMANENT;\r\nelse if (fdb->is_static)\r\nreturn NUD_NOARP;\r\nelse if (has_expired(fdb->dst->br, fdb))\r\nreturn NUD_STALE;\r\nelse\r\nreturn NUD_REACHABLE;\r\n}\r\nstatic int fdb_fill_info(struct sk_buff *skb, const struct net_bridge *br,\r\nconst struct net_bridge_fdb_entry *fdb,\r\nu32 portid, u32 seq, int type, unsigned int flags)\r\n{\r\nunsigned long now = jiffies;\r\nstruct nda_cacheinfo ci;\r\nstruct nlmsghdr *nlh;\r\nstruct ndmsg *ndm;\r\nnlh = nlmsg_put(skb, portid, seq, type, sizeof(*ndm), flags);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nndm = nlmsg_data(nlh);\r\nndm->ndm_family = AF_BRIDGE;\r\nndm->ndm_pad1 = 0;\r\nndm->ndm_pad2 = 0;\r\nndm->ndm_flags = 0;\r\nndm->ndm_type = 0;\r\nndm->ndm_ifindex = fdb->dst ? fdb->dst->dev->ifindex : br->dev->ifindex;\r\nndm->ndm_state = fdb_to_nud(fdb);\r\nif (nla_put(skb, NDA_LLADDR, ETH_ALEN, &fdb->addr))\r\ngoto nla_put_failure;\r\nci.ndm_used = jiffies_to_clock_t(now - fdb->used);\r\nci.ndm_confirmed = 0;\r\nci.ndm_updated = jiffies_to_clock_t(now - fdb->updated);\r\nci.ndm_refcnt = 0;\r\nif (nla_put(skb, NDA_CACHEINFO, sizeof(ci), &ci))\r\ngoto nla_put_failure;\r\nif (nla_put(skb, NDA_VLAN, sizeof(u16), &fdb->vlan_id))\r\ngoto nla_put_failure;\r\nreturn nlmsg_end(skb, nlh);\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic inline size_t fdb_nlmsg_size(void)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct ndmsg))\r\n+ nla_total_size(ETH_ALEN)\r\n+ nla_total_size(sizeof(u16))\r\n+ nla_total_size(sizeof(struct nda_cacheinfo));\r\n}\r\nstatic void fdb_notify(struct net_bridge *br,\r\nconst struct net_bridge_fdb_entry *fdb, int type)\r\n{\r\nstruct net *net = dev_net(br->dev);\r\nstruct sk_buff *skb;\r\nint err = -ENOBUFS;\r\nskb = nlmsg_new(fdb_nlmsg_size(), GFP_ATOMIC);\r\nif (skb == NULL)\r\ngoto errout;\r\nerr = fdb_fill_info(skb, br, fdb, 0, 0, type, 0);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, net, 0, RTNLGRP_NEIGH, NULL, GFP_ATOMIC);\r\nreturn;\r\nerrout:\r\nif (err < 0)\r\nrtnl_set_sk_err(net, RTNLGRP_NEIGH, err);\r\n}\r\nint br_fdb_dump(struct sk_buff *skb,\r\nstruct netlink_callback *cb,\r\nstruct net_device *dev,\r\nint idx)\r\n{\r\nstruct net_bridge *br = netdev_priv(dev);\r\nint i;\r\nif (!(dev->priv_flags & IFF_EBRIDGE))\r\ngoto out;\r\nfor (i = 0; i < BR_HASH_SIZE; i++) {\r\nstruct net_bridge_fdb_entry *f;\r\nhlist_for_each_entry_rcu(f, &br->hash[i], hlist) {\r\nif (idx < cb->args[0])\r\ngoto skip;\r\nif (fdb_fill_info(skb, br, f,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq,\r\nRTM_NEWNEIGH,\r\nNLM_F_MULTI) < 0)\r\nbreak;\r\nskip:\r\n++idx;\r\n}\r\n}\r\nout:\r\nreturn idx;\r\n}\r\nstatic int fdb_add_entry(struct net_bridge_port *source, const __u8 *addr,\r\n__u16 state, __u16 flags, __u16 vid)\r\n{\r\nstruct net_bridge *br = source->br;\r\nstruct hlist_head *head = &br->hash[br_mac_hash(addr, vid)];\r\nstruct net_bridge_fdb_entry *fdb;\r\nbool modified = false;\r\nfdb = fdb_find(head, addr, vid);\r\nif (fdb == NULL) {\r\nif (!(flags & NLM_F_CREATE))\r\nreturn -ENOENT;\r\nfdb = fdb_create(head, source, addr, vid);\r\nif (!fdb)\r\nreturn -ENOMEM;\r\nmodified = true;\r\n} else {\r\nif (flags & NLM_F_EXCL)\r\nreturn -EEXIST;\r\nif (fdb->dst != source) {\r\nfdb->dst = source;\r\nmodified = true;\r\n}\r\n}\r\nif (fdb_to_nud(fdb) != state) {\r\nif (state & NUD_PERMANENT)\r\nfdb->is_local = fdb->is_static = 1;\r\nelse if (state & NUD_NOARP) {\r\nfdb->is_local = 0;\r\nfdb->is_static = 1;\r\n} else\r\nfdb->is_local = fdb->is_static = 0;\r\nmodified = true;\r\n}\r\nfdb->used = jiffies;\r\nif (modified) {\r\nfdb->updated = jiffies;\r\nfdb_notify(br, fdb, RTM_NEWNEIGH);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __br_fdb_add(struct ndmsg *ndm, struct net_bridge_port *p,\r\nconst unsigned char *addr, u16 nlh_flags, u16 vid)\r\n{\r\nint err = 0;\r\nif (ndm->ndm_flags & NTF_USE) {\r\nrcu_read_lock();\r\nbr_fdb_update(p->br, p, addr, vid);\r\nrcu_read_unlock();\r\n} else {\r\nspin_lock_bh(&p->br->hash_lock);\r\nerr = fdb_add_entry(p, addr, ndm->ndm_state,\r\nnlh_flags, vid);\r\nspin_unlock_bh(&p->br->hash_lock);\r\n}\r\nreturn err;\r\n}\r\nint br_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],\r\nstruct net_device *dev,\r\nconst unsigned char *addr, u16 nlh_flags)\r\n{\r\nstruct net_bridge_port *p;\r\nint err = 0;\r\nstruct net_port_vlans *pv;\r\nunsigned short vid = VLAN_N_VID;\r\nif (!(ndm->ndm_state & (NUD_PERMANENT|NUD_NOARP|NUD_REACHABLE))) {\r\npr_info("bridge: RTM_NEWNEIGH with invalid state %#x\n", ndm->ndm_state);\r\nreturn -EINVAL;\r\n}\r\nif (tb[NDA_VLAN]) {\r\nif (nla_len(tb[NDA_VLAN]) != sizeof(unsigned short)) {\r\npr_info("bridge: RTM_NEWNEIGH with invalid vlan\n");\r\nreturn -EINVAL;\r\n}\r\nvid = nla_get_u16(tb[NDA_VLAN]);\r\nif (!vid || vid >= VLAN_VID_MASK) {\r\npr_info("bridge: RTM_NEWNEIGH with invalid vlan id %d\n",\r\nvid);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (is_zero_ether_addr(addr)) {\r\npr_info("bridge: RTM_NEWNEIGH with invalid ether address\n");\r\nreturn -EINVAL;\r\n}\r\np = br_port_get_rtnl(dev);\r\nif (p == NULL) {\r\npr_info("bridge: RTM_NEWNEIGH %s not a bridge port\n",\r\ndev->name);\r\nreturn -EINVAL;\r\n}\r\npv = nbp_get_vlan_info(p);\r\nif (vid != VLAN_N_VID) {\r\nif (!pv || !test_bit(vid, pv->vlan_bitmap)) {\r\npr_info("bridge: RTM_NEWNEIGH with unconfigured "\r\n"vlan %d on port %s\n", vid, dev->name);\r\nreturn -EINVAL;\r\n}\r\nerr = __br_fdb_add(ndm, p, addr, nlh_flags, vid);\r\n} else {\r\nif (!pv || bitmap_empty(pv->vlan_bitmap, VLAN_N_VID)) {\r\nerr = __br_fdb_add(ndm, p, addr, nlh_flags, 0);\r\ngoto out;\r\n}\r\nfor_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID) {\r\nerr = __br_fdb_add(ndm, p, addr, nlh_flags, vid);\r\nif (err)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn err;\r\n}\r\nint fdb_delete_by_addr(struct net_bridge *br, const u8 *addr,\r\nu16 vlan)\r\n{\r\nstruct hlist_head *head = &br->hash[br_mac_hash(addr, vlan)];\r\nstruct net_bridge_fdb_entry *fdb;\r\nfdb = fdb_find(head, addr, vlan);\r\nif (!fdb)\r\nreturn -ENOENT;\r\nfdb_delete(br, fdb);\r\nreturn 0;\r\n}\r\nstatic int __br_fdb_delete(struct net_bridge_port *p,\r\nconst unsigned char *addr, u16 vid)\r\n{\r\nint err;\r\nspin_lock_bh(&p->br->hash_lock);\r\nerr = fdb_delete_by_addr(p->br, addr, vid);\r\nspin_unlock_bh(&p->br->hash_lock);\r\nreturn err;\r\n}\r\nint br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],\r\nstruct net_device *dev,\r\nconst unsigned char *addr)\r\n{\r\nstruct net_bridge_port *p;\r\nint err;\r\nstruct net_port_vlans *pv;\r\nunsigned short vid = VLAN_N_VID;\r\nif (tb[NDA_VLAN]) {\r\nif (nla_len(tb[NDA_VLAN]) != sizeof(unsigned short)) {\r\npr_info("bridge: RTM_NEWNEIGH with invalid vlan\n");\r\nreturn -EINVAL;\r\n}\r\nvid = nla_get_u16(tb[NDA_VLAN]);\r\nif (!vid || vid >= VLAN_VID_MASK) {\r\npr_info("bridge: RTM_NEWNEIGH with invalid vlan id %d\n",\r\nvid);\r\nreturn -EINVAL;\r\n}\r\n}\r\np = br_port_get_rtnl(dev);\r\nif (p == NULL) {\r\npr_info("bridge: RTM_DELNEIGH %s not a bridge port\n",\r\ndev->name);\r\nreturn -EINVAL;\r\n}\r\npv = nbp_get_vlan_info(p);\r\nif (vid != VLAN_N_VID) {\r\nif (!pv || !test_bit(vid, pv->vlan_bitmap)) {\r\npr_info("bridge: RTM_DELNEIGH with unconfigured "\r\n"vlan %d on port %s\n", vid, dev->name);\r\nreturn -EINVAL;\r\n}\r\nerr = __br_fdb_delete(p, addr, vid);\r\n} else {\r\nif (!pv || bitmap_empty(pv->vlan_bitmap, VLAN_N_VID)) {\r\nerr = __br_fdb_delete(p, addr, 0);\r\ngoto out;\r\n}\r\nerr = -ENOENT;\r\nfor_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID) {\r\nerr &= __br_fdb_delete(p, addr, vid);\r\n}\r\n}\r\nout:\r\nreturn err;\r\n}
