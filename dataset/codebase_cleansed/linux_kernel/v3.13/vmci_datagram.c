static int dg_create_handle(u32 resource_id,\r\nu32 flags,\r\nu32 priv_flags,\r\nvmci_datagram_recv_cb recv_cb,\r\nvoid *client_data, struct vmci_handle *out_handle)\r\n{\r\nint result;\r\nu32 context_id;\r\nstruct vmci_handle handle;\r\nstruct datagram_entry *entry;\r\nif ((flags & VMCI_FLAG_WELLKNOWN_DG_HND) != 0)\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\nif ((flags & VMCI_FLAG_ANYCID_DG_HND) != 0) {\r\ncontext_id = VMCI_INVALID_ID;\r\n} else {\r\ncontext_id = vmci_get_context_id();\r\nif (context_id == VMCI_INVALID_ID)\r\nreturn VMCI_ERROR_NO_RESOURCES;\r\n}\r\nhandle = vmci_make_handle(context_id, resource_id);\r\nentry = kmalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry) {\r\npr_warn("Failed allocating memory for datagram entry\n");\r\nreturn VMCI_ERROR_NO_MEM;\r\n}\r\nentry->run_delayed = (flags & VMCI_FLAG_DG_DELAYED_CB) ? true : false;\r\nentry->flags = flags;\r\nentry->recv_cb = recv_cb;\r\nentry->client_data = client_data;\r\nentry->priv_flags = priv_flags;\r\nresult = vmci_resource_add(&entry->resource,\r\nVMCI_RESOURCE_TYPE_DATAGRAM,\r\nhandle);\r\nif (result != VMCI_SUCCESS) {\r\npr_warn("Failed to add new resource (handle=0x%x:0x%x), error: %d\n",\r\nhandle.context, handle.resource, result);\r\nkfree(entry);\r\nreturn result;\r\n}\r\n*out_handle = vmci_resource_handle(&entry->resource);\r\nreturn VMCI_SUCCESS;\r\n}\r\nstatic int vmci_datagram_get_priv_flags(u32 context_id,\r\nstruct vmci_handle handle,\r\nu32 *priv_flags)\r\n{\r\nif (context_id == VMCI_INVALID_ID)\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\nif (context_id == VMCI_HOST_CONTEXT_ID) {\r\nstruct datagram_entry *src_entry;\r\nstruct vmci_resource *resource;\r\nresource = vmci_resource_by_handle(handle,\r\nVMCI_RESOURCE_TYPE_DATAGRAM);\r\nif (!resource)\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\nsrc_entry = container_of(resource, struct datagram_entry,\r\nresource);\r\n*priv_flags = src_entry->priv_flags;\r\nvmci_resource_put(resource);\r\n} else if (context_id == VMCI_HYPERVISOR_CONTEXT_ID)\r\n*priv_flags = VMCI_MAX_PRIVILEGE_FLAGS;\r\nelse\r\n*priv_flags = vmci_context_get_priv_flags(context_id);\r\nreturn VMCI_SUCCESS;\r\n}\r\nstatic void dg_delayed_dispatch(struct work_struct *work)\r\n{\r\nstruct delayed_datagram_info *dg_info =\r\ncontainer_of(work, struct delayed_datagram_info, work);\r\ndg_info->entry->recv_cb(dg_info->entry->client_data, &dg_info->msg);\r\nvmci_resource_put(&dg_info->entry->resource);\r\nif (dg_info->in_dg_host_queue)\r\natomic_dec(&delayed_dg_host_queue_size);\r\nkfree(dg_info);\r\n}\r\nstatic int dg_dispatch_as_host(u32 context_id, struct vmci_datagram *dg)\r\n{\r\nint retval;\r\nsize_t dg_size;\r\nu32 src_priv_flags;\r\ndg_size = VMCI_DG_SIZE(dg);\r\nif (dg->dst.context == VMCI_HYPERVISOR_CONTEXT_ID)\r\nreturn VMCI_ERROR_DST_UNREACHABLE;\r\nif (dg->src.context != context_id) {\r\npr_devel("Sender context (ID=0x%x) is not owner of src datagram entry (handle=0x%x:0x%x)\n",\r\ncontext_id, dg->src.context, dg->src.resource);\r\nreturn VMCI_ERROR_NO_ACCESS;\r\n}\r\nretval = vmci_datagram_get_priv_flags(context_id, dg->src,\r\n&src_priv_flags);\r\nif (retval != VMCI_SUCCESS) {\r\npr_warn("Couldn't get privileges (handle=0x%x:0x%x)\n",\r\ndg->src.context, dg->src.resource);\r\nreturn retval;\r\n}\r\nif (dg->dst.context == VMCI_HOST_CONTEXT_ID) {\r\nstruct datagram_entry *dst_entry;\r\nstruct vmci_resource *resource;\r\nif (dg->src.context == VMCI_HYPERVISOR_CONTEXT_ID &&\r\ndg->dst.resource == VMCI_EVENT_HANDLER) {\r\nreturn vmci_event_dispatch(dg);\r\n}\r\nresource = vmci_resource_by_handle(dg->dst,\r\nVMCI_RESOURCE_TYPE_DATAGRAM);\r\nif (!resource) {\r\npr_devel("Sending to invalid destination (handle=0x%x:0x%x)\n",\r\ndg->dst.context, dg->dst.resource);\r\nreturn VMCI_ERROR_INVALID_RESOURCE;\r\n}\r\ndst_entry = container_of(resource, struct datagram_entry,\r\nresource);\r\nif (vmci_deny_interaction(src_priv_flags,\r\ndst_entry->priv_flags)) {\r\nvmci_resource_put(resource);\r\nreturn VMCI_ERROR_NO_ACCESS;\r\n}\r\nif (dst_entry->run_delayed ||\r\ndg->src.context == VMCI_HOST_CONTEXT_ID) {\r\nstruct delayed_datagram_info *dg_info;\r\nif (atomic_add_return(1, &delayed_dg_host_queue_size)\r\n== VMCI_MAX_DELAYED_DG_HOST_QUEUE_SIZE) {\r\natomic_dec(&delayed_dg_host_queue_size);\r\nvmci_resource_put(resource);\r\nreturn VMCI_ERROR_NO_MEM;\r\n}\r\ndg_info = kmalloc(sizeof(*dg_info) +\r\n(size_t) dg->payload_size, GFP_ATOMIC);\r\nif (!dg_info) {\r\natomic_dec(&delayed_dg_host_queue_size);\r\nvmci_resource_put(resource);\r\nreturn VMCI_ERROR_NO_MEM;\r\n}\r\ndg_info->in_dg_host_queue = true;\r\ndg_info->entry = dst_entry;\r\nmemcpy(&dg_info->msg, dg, dg_size);\r\nINIT_WORK(&dg_info->work, dg_delayed_dispatch);\r\nschedule_work(&dg_info->work);\r\nretval = VMCI_SUCCESS;\r\n} else {\r\nretval = dst_entry->recv_cb(dst_entry->client_data, dg);\r\nvmci_resource_put(resource);\r\nif (retval < VMCI_SUCCESS)\r\nreturn retval;\r\n}\r\n} else {\r\nstruct vmci_datagram *new_dg;\r\nif (context_id != dg->dst.context) {\r\nif (vmci_deny_interaction(src_priv_flags,\r\nvmci_context_get_priv_flags\r\n(dg->dst.context))) {\r\nreturn VMCI_ERROR_NO_ACCESS;\r\n} else if (VMCI_CONTEXT_IS_VM(context_id)) {\r\npr_devel("Datagram communication between VMs not supported (src=0x%x, dst=0x%x)\n",\r\ncontext_id, dg->dst.context);\r\nreturn VMCI_ERROR_DST_UNREACHABLE;\r\n}\r\n}\r\nnew_dg = kmalloc(dg_size, GFP_KERNEL);\r\nif (new_dg == NULL)\r\nreturn VMCI_ERROR_NO_MEM;\r\nmemcpy(new_dg, dg, dg_size);\r\nretval = vmci_ctx_enqueue_datagram(dg->dst.context, new_dg);\r\nif (retval < VMCI_SUCCESS) {\r\nkfree(new_dg);\r\nreturn retval;\r\n}\r\n}\r\nreturn (int)dg_size;\r\n}\r\nstatic int dg_dispatch_as_guest(struct vmci_datagram *dg)\r\n{\r\nint retval;\r\nstruct vmci_resource *resource;\r\nresource = vmci_resource_by_handle(dg->src,\r\nVMCI_RESOURCE_TYPE_DATAGRAM);\r\nif (!resource)\r\nreturn VMCI_ERROR_NO_HANDLE;\r\nretval = vmci_send_datagram(dg);\r\nvmci_resource_put(resource);\r\nreturn retval;\r\n}\r\nint vmci_datagram_dispatch(u32 context_id,\r\nstruct vmci_datagram *dg, bool from_guest)\r\n{\r\nint retval;\r\nenum vmci_route route;\r\nBUILD_BUG_ON(sizeof(struct vmci_datagram) != 24);\r\nif (VMCI_DG_SIZE(dg) > VMCI_MAX_DG_SIZE) {\r\npr_devel("Payload (size=%llu bytes) too big to send\n",\r\n(unsigned long long)dg->payload_size);\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\n}\r\nretval = vmci_route(&dg->src, &dg->dst, from_guest, &route);\r\nif (retval < VMCI_SUCCESS) {\r\npr_devel("Failed to route datagram (src=0x%x, dst=0x%x, err=%d)\n",\r\ndg->src.context, dg->dst.context, retval);\r\nreturn retval;\r\n}\r\nif (VMCI_ROUTE_AS_HOST == route) {\r\nif (VMCI_INVALID_ID == context_id)\r\ncontext_id = VMCI_HOST_CONTEXT_ID;\r\nreturn dg_dispatch_as_host(context_id, dg);\r\n}\r\nif (VMCI_ROUTE_AS_GUEST == route)\r\nreturn dg_dispatch_as_guest(dg);\r\npr_warn("Unknown route (%d) for datagram\n", route);\r\nreturn VMCI_ERROR_DST_UNREACHABLE;\r\n}\r\nint vmci_datagram_invoke_guest_handler(struct vmci_datagram *dg)\r\n{\r\nstruct vmci_resource *resource;\r\nstruct datagram_entry *dst_entry;\r\nresource = vmci_resource_by_handle(dg->dst,\r\nVMCI_RESOURCE_TYPE_DATAGRAM);\r\nif (!resource) {\r\npr_devel("destination (handle=0x%x:0x%x) doesn't exist\n",\r\ndg->dst.context, dg->dst.resource);\r\nreturn VMCI_ERROR_NO_HANDLE;\r\n}\r\ndst_entry = container_of(resource, struct datagram_entry, resource);\r\nif (dst_entry->run_delayed) {\r\nstruct delayed_datagram_info *dg_info;\r\ndg_info = kmalloc(sizeof(*dg_info) + (size_t)dg->payload_size,\r\nGFP_ATOMIC);\r\nif (!dg_info) {\r\nvmci_resource_put(resource);\r\nreturn VMCI_ERROR_NO_MEM;\r\n}\r\ndg_info->in_dg_host_queue = false;\r\ndg_info->entry = dst_entry;\r\nmemcpy(&dg_info->msg, dg, VMCI_DG_SIZE(dg));\r\nINIT_WORK(&dg_info->work, dg_delayed_dispatch);\r\nschedule_work(&dg_info->work);\r\n} else {\r\ndst_entry->recv_cb(dst_entry->client_data, dg);\r\nvmci_resource_put(resource);\r\n}\r\nreturn VMCI_SUCCESS;\r\n}\r\nint vmci_datagram_create_handle_priv(u32 resource_id,\r\nu32 flags,\r\nu32 priv_flags,\r\nvmci_datagram_recv_cb recv_cb,\r\nvoid *client_data,\r\nstruct vmci_handle *out_handle)\r\n{\r\nif (out_handle == NULL)\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\nif (recv_cb == NULL) {\r\npr_devel("Client callback needed when creating datagram\n");\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\n}\r\nif (priv_flags & ~VMCI_PRIVILEGE_ALL_FLAGS)\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\nreturn dg_create_handle(resource_id, flags, priv_flags, recv_cb,\r\nclient_data, out_handle);\r\n}\r\nint vmci_datagram_create_handle(u32 resource_id,\r\nu32 flags,\r\nvmci_datagram_recv_cb recv_cb,\r\nvoid *client_data,\r\nstruct vmci_handle *out_handle)\r\n{\r\nreturn vmci_datagram_create_handle_priv(\r\nresource_id, flags,\r\nVMCI_DEFAULT_PROC_PRIVILEGE_FLAGS,\r\nrecv_cb, client_data,\r\nout_handle);\r\n}\r\nint vmci_datagram_destroy_handle(struct vmci_handle handle)\r\n{\r\nstruct datagram_entry *entry;\r\nstruct vmci_resource *resource;\r\nresource = vmci_resource_by_handle(handle, VMCI_RESOURCE_TYPE_DATAGRAM);\r\nif (!resource) {\r\npr_devel("Failed to destroy datagram (handle=0x%x:0x%x)\n",\r\nhandle.context, handle.resource);\r\nreturn VMCI_ERROR_NOT_FOUND;\r\n}\r\nentry = container_of(resource, struct datagram_entry, resource);\r\nvmci_resource_put(&entry->resource);\r\nvmci_resource_remove(&entry->resource);\r\nkfree(entry);\r\nreturn VMCI_SUCCESS;\r\n}\r\nint vmci_datagram_send(struct vmci_datagram *msg)\r\n{\r\nif (msg == NULL)\r\nreturn VMCI_ERROR_INVALID_ARGS;\r\nreturn vmci_datagram_dispatch(VMCI_INVALID_ID, msg, false);\r\n}
