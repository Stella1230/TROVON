static struct mem_block *split_block(struct mem_block *p, int start, int size,\r\nstruct drm_file *file_priv)\r\n{\r\nif (start > p->start) {\r\nstruct mem_block *newblock = kmalloc(sizeof(*newblock),\r\nGFP_KERNEL);\r\nif (!newblock)\r\ngoto out;\r\nnewblock->start = start;\r\nnewblock->size = p->size - (start - p->start);\r\nnewblock->file_priv = NULL;\r\nnewblock->next = p->next;\r\nnewblock->prev = p;\r\np->next->prev = newblock;\r\np->next = newblock;\r\np->size -= newblock->size;\r\np = newblock;\r\n}\r\nif (size < p->size) {\r\nstruct mem_block *newblock = kmalloc(sizeof(*newblock),\r\nGFP_KERNEL);\r\nif (!newblock)\r\ngoto out;\r\nnewblock->start = start + size;\r\nnewblock->size = p->size - size;\r\nnewblock->file_priv = NULL;\r\nnewblock->next = p->next;\r\nnewblock->prev = p;\r\np->next->prev = newblock;\r\np->next = newblock;\r\np->size = size;\r\n}\r\nout:\r\np->file_priv = file_priv;\r\nreturn p;\r\n}\r\nstatic struct mem_block *alloc_block(struct mem_block *heap, int size,\r\nint align2, struct drm_file *file_priv)\r\n{\r\nstruct mem_block *p;\r\nint mask = (1 << align2) - 1;\r\nlist_for_each(p, heap) {\r\nint start = (p->start + mask) & ~mask;\r\nif (p->file_priv == NULL && start + size <= p->start + p->size)\r\nreturn split_block(p, start, size, file_priv);\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct mem_block *find_block(struct mem_block *heap, int start)\r\n{\r\nstruct mem_block *p;\r\nlist_for_each(p, heap)\r\nif (p->start == start)\r\nreturn p;\r\nreturn NULL;\r\n}\r\nstatic void free_block(struct mem_block *p)\r\n{\r\np->file_priv = NULL;\r\nif (p->next->file_priv == NULL) {\r\nstruct mem_block *q = p->next;\r\np->size += q->size;\r\np->next = q->next;\r\np->next->prev = p;\r\nkfree(q);\r\n}\r\nif (p->prev->file_priv == NULL) {\r\nstruct mem_block *q = p->prev;\r\nq->size += p->size;\r\nq->next = p->next;\r\nq->next->prev = q;\r\nkfree(p);\r\n}\r\n}\r\nstatic int init_heap(struct mem_block **heap, int start, int size)\r\n{\r\nstruct mem_block *blocks = kmalloc(sizeof(*blocks), GFP_KERNEL);\r\nif (!blocks)\r\nreturn -ENOMEM;\r\n*heap = kzalloc(sizeof(**heap), GFP_KERNEL);\r\nif (!*heap) {\r\nkfree(blocks);\r\nreturn -ENOMEM;\r\n}\r\nblocks->start = start;\r\nblocks->size = size;\r\nblocks->file_priv = NULL;\r\nblocks->next = blocks->prev = *heap;\r\n(*heap)->file_priv = (struct drm_file *) - 1;\r\n(*heap)->next = (*heap)->prev = blocks;\r\nreturn 0;\r\n}\r\nvoid radeon_mem_release(struct drm_file *file_priv, struct mem_block *heap)\r\n{\r\nstruct mem_block *p;\r\nif (!heap || !heap->next)\r\nreturn;\r\nlist_for_each(p, heap) {\r\nif (p->file_priv == file_priv)\r\np->file_priv = NULL;\r\n}\r\nlist_for_each(p, heap) {\r\nwhile (p->file_priv == NULL && p->next->file_priv == NULL) {\r\nstruct mem_block *q = p->next;\r\np->size += q->size;\r\np->next = q->next;\r\np->next->prev = p;\r\nkfree(q);\r\n}\r\n}\r\n}\r\nvoid radeon_mem_takedown(struct mem_block **heap)\r\n{\r\nstruct mem_block *p;\r\nif (!*heap)\r\nreturn;\r\nfor (p = (*heap)->next; p != *heap;) {\r\nstruct mem_block *q = p;\r\np = p->next;\r\nkfree(q);\r\n}\r\nkfree(*heap);\r\n*heap = NULL;\r\n}\r\nstatic struct mem_block **get_heap(drm_radeon_private_t * dev_priv, int region)\r\n{\r\nswitch (region) {\r\ncase RADEON_MEM_REGION_GART:\r\nreturn &dev_priv->gart_heap;\r\ncase RADEON_MEM_REGION_FB:\r\nreturn &dev_priv->fb_heap;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nint radeon_mem_alloc(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\ndrm_radeon_mem_alloc_t *alloc = data;\r\nstruct mem_block *block, **heap;\r\nif (!dev_priv) {\r\nDRM_ERROR("called with no initialization\n");\r\nreturn -EINVAL;\r\n}\r\nheap = get_heap(dev_priv, alloc->region);\r\nif (!heap || !*heap)\r\nreturn -EFAULT;\r\nif (alloc->alignment < 12)\r\nalloc->alignment = 12;\r\nblock = alloc_block(*heap, alloc->size, alloc->alignment, file_priv);\r\nif (!block)\r\nreturn -ENOMEM;\r\nif (DRM_COPY_TO_USER(alloc->region_offset, &block->start,\r\nsizeof(int))) {\r\nDRM_ERROR("copy_to_user\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nint radeon_mem_free(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\ndrm_radeon_mem_free_t *memfree = data;\r\nstruct mem_block *block, **heap;\r\nif (!dev_priv) {\r\nDRM_ERROR("called with no initialization\n");\r\nreturn -EINVAL;\r\n}\r\nheap = get_heap(dev_priv, memfree->region);\r\nif (!heap || !*heap)\r\nreturn -EFAULT;\r\nblock = find_block(*heap, memfree->region_offset);\r\nif (!block)\r\nreturn -EFAULT;\r\nif (block->file_priv != file_priv)\r\nreturn -EPERM;\r\nfree_block(block);\r\nreturn 0;\r\n}\r\nint radeon_mem_init_heap(struct drm_device *dev, void *data, struct drm_file *file_priv)\r\n{\r\ndrm_radeon_private_t *dev_priv = dev->dev_private;\r\ndrm_radeon_mem_init_heap_t *initheap = data;\r\nstruct mem_block **heap;\r\nif (!dev_priv) {\r\nDRM_ERROR("called with no initialization\n");\r\nreturn -EINVAL;\r\n}\r\nheap = get_heap(dev_priv, initheap->region);\r\nif (!heap)\r\nreturn -EFAULT;\r\nif (*heap) {\r\nDRM_ERROR("heap already initialized?");\r\nreturn -EFAULT;\r\n}\r\nreturn init_heap(heap, initheap->start, initheap->size);\r\n}
