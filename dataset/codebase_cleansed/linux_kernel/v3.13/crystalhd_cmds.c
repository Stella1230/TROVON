static struct crystalhd_user *bc_cproc_get_uid(struct crystalhd_cmd *ctx)\r\n{\r\nstruct crystalhd_user *user = NULL;\r\nint i;\r\nfor (i = 0; i < BC_LINK_MAX_OPENS; i++) {\r\nif (!ctx->user[i].in_use) {\r\nuser = &ctx->user[i];\r\nbreak;\r\n}\r\n}\r\nreturn user;\r\n}\r\nstatic int bc_cproc_get_user_count(struct crystalhd_cmd *ctx)\r\n{\r\nint i, count = 0;\r\nfor (i = 0; i < BC_LINK_MAX_OPENS; i++) {\r\nif (ctx->user[i].in_use)\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic void bc_cproc_mark_pwr_state(struct crystalhd_cmd *ctx)\r\n{\r\nint i;\r\nfor (i = 0; i < BC_LINK_MAX_OPENS; i++) {\r\nif (!ctx->user[i].in_use)\r\ncontinue;\r\nif (ctx->user[i].mode == DTS_DIAG_MODE ||\r\nctx->user[i].mode == DTS_PLAYBACK_MODE) {\r\nctx->pwr_state_change = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic enum BC_STATUS bc_cproc_notify_mode(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nint rc = 0, i = 0;\r\nif (!ctx || !idata) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nif (ctx->user[idata->u_id].mode != DTS_MODE_INV) {\r\nBCMLOG_ERR("Close the handle first..\n");\r\nreturn BC_STS_ERR_USAGE;\r\n}\r\nif (idata->udata.u.NotifyMode.Mode == DTS_MONITOR_MODE) {\r\nctx->user[idata->u_id].mode = idata->udata.u.NotifyMode.Mode;\r\nreturn BC_STS_SUCCESS;\r\n}\r\nif (ctx->state != BC_LINK_INVALID) {\r\nBCMLOG_ERR("Link invalid state %d\n", ctx->state);\r\nreturn BC_STS_ERR_USAGE;\r\n}\r\nfor (i = 0; i < BC_LINK_MAX_OPENS; i++) {\r\nif (ctx->user[i].mode == DTS_DIAG_MODE ||\r\nctx->user[i].mode == DTS_PLAYBACK_MODE) {\r\nBCMLOG_ERR("multiple playback sessions are not supported..\n");\r\nreturn BC_STS_ERR_USAGE;\r\n}\r\n}\r\nctx->cin_wait_exit = 0;\r\nctx->user[idata->u_id].mode = idata->udata.u.NotifyMode.Mode;\r\nrc = crystalhd_create_dio_pool(ctx->adp, BC_LINK_MAX_SGLS);\r\nif (rc)\r\nreturn BC_STS_ERROR;\r\nreturn crystalhd_hw_setup_dma_rings(&ctx->hw_ctx);\r\n}\r\nstatic enum BC_STATUS bc_cproc_get_version(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nif (!ctx || !idata) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nidata->udata.u.VerInfo.DriverMajor = crystalhd_kmod_major;\r\nidata->udata.u.VerInfo.DriverMinor = crystalhd_kmod_minor;\r\nidata->udata.u.VerInfo.DriverRevision = crystalhd_kmod_rev;\r\nreturn BC_STS_SUCCESS;\r\n}\r\nstatic enum BC_STATUS bc_cproc_get_hwtype(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nif (!ctx || !idata) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\ncrystalhd_pci_cfg_rd(ctx->adp, 0, 2,\r\n(uint32_t *)&idata->udata.u.hwType.PciVenId);\r\ncrystalhd_pci_cfg_rd(ctx->adp, 2, 2,\r\n(uint32_t *)&idata->udata.u.hwType.PciDevId);\r\ncrystalhd_pci_cfg_rd(ctx->adp, 8, 1,\r\n(uint32_t *)&idata->udata.u.hwType.HwRev);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nstatic enum BC_STATUS bc_cproc_reg_rd(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nif (!ctx || !idata)\r\nreturn BC_STS_INV_ARG;\r\nidata->udata.u.regAcc.Value = bc_dec_reg_rd(ctx->adp,\r\nidata->udata.u.regAcc.Offset);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nstatic enum BC_STATUS bc_cproc_reg_wr(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nif (!ctx || !idata)\r\nreturn BC_STS_INV_ARG;\r\nbc_dec_reg_wr(ctx->adp, idata->udata.u.regAcc.Offset,\r\nidata->udata.u.regAcc.Value);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nstatic enum BC_STATUS bc_cproc_link_reg_rd(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nif (!ctx || !idata)\r\nreturn BC_STS_INV_ARG;\r\nidata->udata.u.regAcc.Value = crystalhd_reg_rd(ctx->adp,\r\nidata->udata.u.regAcc.Offset);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nstatic enum BC_STATUS bc_cproc_link_reg_wr(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nif (!ctx || !idata)\r\nreturn BC_STS_INV_ARG;\r\ncrystalhd_reg_wr(ctx->adp, idata->udata.u.regAcc.Offset,\r\nidata->udata.u.regAcc.Value);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nstatic enum BC_STATUS bc_cproc_mem_rd(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nif (!ctx || !idata || !idata->add_cdata)\r\nreturn BC_STS_INV_ARG;\r\nif (idata->udata.u.devMem.NumDwords > (idata->add_cdata_sz / 4)) {\r\nBCMLOG_ERR("insufficient buffer\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nsts = crystalhd_mem_rd(ctx->adp, idata->udata.u.devMem.StartOff,\r\nidata->udata.u.devMem.NumDwords,\r\n(uint32_t *)idata->add_cdata);\r\nreturn sts;\r\n}\r\nstatic enum BC_STATUS bc_cproc_mem_wr(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nif (!ctx || !idata || !idata->add_cdata)\r\nreturn BC_STS_INV_ARG;\r\nif (idata->udata.u.devMem.NumDwords > (idata->add_cdata_sz / 4)) {\r\nBCMLOG_ERR("insufficient buffer\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nsts = crystalhd_mem_wr(ctx->adp, idata->udata.u.devMem.StartOff,\r\nidata->udata.u.devMem.NumDwords,\r\n(uint32_t *)idata->add_cdata);\r\nreturn sts;\r\n}\r\nstatic enum BC_STATUS bc_cproc_cfg_rd(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nuint32_t ix, cnt, off, len;\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nuint32_t *temp;\r\nif (!ctx || !idata)\r\nreturn BC_STS_INV_ARG;\r\ntemp = (uint32_t *) idata->udata.u.pciCfg.pci_cfg_space;\r\noff = idata->udata.u.pciCfg.Offset;\r\nlen = idata->udata.u.pciCfg.Size;\r\nif (len <= 4)\r\nreturn crystalhd_pci_cfg_rd(ctx->adp, off, len, temp);\r\nlen = 4;\r\ncnt = idata->udata.u.pciCfg.Size / len;\r\nfor (ix = 0; ix < cnt; ix++) {\r\nsts = crystalhd_pci_cfg_rd(ctx->adp, off, len, &temp[ix]);\r\nif (sts != BC_STS_SUCCESS) {\r\nBCMLOG_ERR("config read : %d\n", sts);\r\nreturn sts;\r\n}\r\noff += len;\r\n}\r\nreturn sts;\r\n}\r\nstatic enum BC_STATUS bc_cproc_cfg_wr(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nuint32_t ix, cnt, off, len;\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nuint32_t *temp;\r\nif (!ctx || !idata)\r\nreturn BC_STS_INV_ARG;\r\ntemp = (uint32_t *) idata->udata.u.pciCfg.pci_cfg_space;\r\noff = idata->udata.u.pciCfg.Offset;\r\nlen = idata->udata.u.pciCfg.Size;\r\nif (len <= 4)\r\nreturn crystalhd_pci_cfg_wr(ctx->adp, off, len, temp[0]);\r\nlen = 4;\r\ncnt = idata->udata.u.pciCfg.Size / len;\r\nfor (ix = 0; ix < cnt; ix++) {\r\nsts = crystalhd_pci_cfg_wr(ctx->adp, off, len, temp[ix]);\r\nif (sts != BC_STS_SUCCESS) {\r\nBCMLOG_ERR("config write : %d\n", sts);\r\nreturn sts;\r\n}\r\noff += len;\r\n}\r\nreturn sts;\r\n}\r\nstatic enum BC_STATUS bc_cproc_download_fw(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nif (!ctx || !idata || !idata->add_cdata || !idata->add_cdata_sz) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nif (ctx->state != BC_LINK_INVALID) {\r\nBCMLOG_ERR("Link invalid state %d\n", ctx->state);\r\nreturn BC_STS_ERR_USAGE;\r\n}\r\nsts = crystalhd_download_fw(ctx->adp, (uint8_t *)idata->add_cdata,\r\nidata->add_cdata_sz);\r\nif (sts != BC_STS_SUCCESS)\r\nBCMLOG_ERR("Firmware Download Failure!! - %d\n", sts);\r\nelse\r\nctx->state |= BC_LINK_INIT;\r\nreturn sts;\r\n}\r\nstatic enum BC_STATUS bc_cproc_do_fw_cmd(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nenum BC_STATUS sts;\r\nuint32_t *cmd;\r\nif (!(ctx->state & BC_LINK_INIT)) {\r\nBCMLOG_ERR("Link invalid state %d\n", ctx->state);\r\nreturn BC_STS_ERR_USAGE;\r\n}\r\ncmd = idata->udata.u.fwCmd.cmd;\r\nif (cmd[0] == eCMD_C011_DEC_CHAN_PAUSE) {\r\nif (!cmd[3]) {\r\nctx->state &= ~BC_LINK_PAUSED;\r\ncrystalhd_hw_unpause(&ctx->hw_ctx);\r\n}\r\n} else if (cmd[0] == eCMD_C011_DEC_CHAN_FLUSH) {\r\nBCMLOG(BCMLOG_INFO, "Flush issued\n");\r\nif (cmd[3])\r\nctx->cin_wait_exit = 1;\r\n}\r\nsts = crystalhd_do_fw_cmd(&ctx->hw_ctx, &idata->udata.u.fwCmd);\r\nif (sts != BC_STS_SUCCESS) {\r\nBCMLOG(BCMLOG_INFO, "fw cmd %x failed\n", cmd[0]);\r\nreturn sts;\r\n}\r\nif (cmd[0] == eCMD_C011_DEC_CHAN_PAUSE) {\r\nif (cmd[3]) {\r\nctx->state |= BC_LINK_PAUSED;\r\ncrystalhd_hw_pause(&ctx->hw_ctx);\r\n}\r\n}\r\nreturn sts;\r\n}\r\nstatic void bc_proc_in_completion(struct crystalhd_dio_req *dio_hnd,\r\nwait_queue_head_t *event, enum BC_STATUS sts)\r\n{\r\nif (!dio_hnd || !event) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn;\r\n}\r\nif (sts == BC_STS_IO_USER_ABORT)\r\nreturn;\r\ndio_hnd->uinfo.comp_sts = sts;\r\ndio_hnd->uinfo.ev_sts = 1;\r\ncrystalhd_set_event(event);\r\n}\r\nstatic enum BC_STATUS bc_cproc_codein_sleep(struct crystalhd_cmd *ctx)\r\n{\r\nwait_queue_head_t sleep_ev;\r\nint rc = 0;\r\nif (ctx->state & BC_LINK_SUSPEND)\r\nreturn BC_STS_IO_USER_ABORT;\r\nif (ctx->cin_wait_exit) {\r\nctx->cin_wait_exit = 0;\r\nreturn BC_STS_CMD_CANCELLED;\r\n}\r\ncrystalhd_create_event(&sleep_ev);\r\ncrystalhd_wait_on_event(&sleep_ev, 0, 100, rc, 0);\r\nif (rc == -EINTR)\r\nreturn BC_STS_IO_USER_ABORT;\r\nreturn BC_STS_SUCCESS;\r\n}\r\nstatic enum BC_STATUS bc_cproc_hw_txdma(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata,\r\nstruct crystalhd_dio_req *dio)\r\n{\r\nuint32_t tx_listid = 0;\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nwait_queue_head_t event;\r\nint rc = 0;\r\nif (!ctx || !idata || !dio) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\ncrystalhd_create_event(&event);\r\nctx->tx_list_id = 0;\r\nsts = crystalhd_hw_post_tx(&ctx->hw_ctx, dio, bc_proc_in_completion,\r\n&event, &tx_listid,\r\nidata->udata.u.ProcInput.Encrypted);\r\nwhile (sts == BC_STS_BUSY) {\r\nsts = bc_cproc_codein_sleep(ctx);\r\nif (sts != BC_STS_SUCCESS)\r\nbreak;\r\nsts = crystalhd_hw_post_tx(&ctx->hw_ctx, dio,\r\nbc_proc_in_completion,\r\n&event, &tx_listid,\r\nidata->udata.u.ProcInput.Encrypted);\r\n}\r\nif (sts != BC_STS_SUCCESS) {\r\nBCMLOG(BCMLOG_DBG, "_hw_txdma returning sts:%d\n", sts);\r\nreturn sts;\r\n}\r\nif (ctx->cin_wait_exit)\r\nctx->cin_wait_exit = 0;\r\nctx->tx_list_id = tx_listid;\r\ncrystalhd_wait_on_event(&event, (dio->uinfo.ev_sts), 3000, rc, 0);\r\nctx->tx_list_id = 0;\r\nif (!rc) {\r\nreturn dio->uinfo.comp_sts;\r\n} else if (rc == -EBUSY) {\r\nBCMLOG(BCMLOG_DBG, "_tx_post() T/O\n");\r\nsts = BC_STS_TIMEOUT;\r\n} else if (rc == -EINTR) {\r\nBCMLOG(BCMLOG_DBG, "Tx Wait Signal int.\n");\r\nsts = BC_STS_IO_USER_ABORT;\r\n} else {\r\nsts = BC_STS_IO_ERROR;\r\n}\r\ncrystalhd_hw_cancel_tx(&ctx->hw_ctx, tx_listid);\r\nreturn sts;\r\n}\r\nstatic enum BC_STATUS bc_cproc_check_inbuffs(bool pin, void *ubuff,\r\nuint32_t ub_sz, uint32_t uv_off, bool en_422)\r\n{\r\nif (!ubuff || !ub_sz) {\r\nBCMLOG_ERR("%s->Invalid Arg %p %x\n",\r\n((pin) ? "TX" : "RX"), ubuff, ub_sz);\r\nreturn BC_STS_INV_ARG;\r\n}\r\nif (((uintptr_t)ubuff) & 0x03) {\r\nBCMLOG_ERR(\r\n"%s-->Un-aligned address not implemented yet.. %p\n",\r\n((pin) ? "TX" : "RX"), ubuff);\r\nreturn BC_STS_NOT_IMPL;\r\n}\r\nif (pin)\r\nreturn BC_STS_SUCCESS;\r\nif (!en_422 && !uv_off) {\r\nBCMLOG_ERR("Need UV offset for 420 mode.\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nif (en_422 && uv_off) {\r\nBCMLOG_ERR("UV offset in 422 mode ??\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nreturn BC_STS_SUCCESS;\r\n}\r\nstatic enum BC_STATUS bc_cproc_proc_input(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nvoid *ubuff;\r\nuint32_t ub_sz;\r\nstruct crystalhd_dio_req *dio_hnd = NULL;\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nif (!ctx || !idata) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nubuff = idata->udata.u.ProcInput.pDmaBuff;\r\nub_sz = idata->udata.u.ProcInput.BuffSz;\r\nsts = bc_cproc_check_inbuffs(1, ubuff, ub_sz, 0, 0);\r\nif (sts != BC_STS_SUCCESS)\r\nreturn sts;\r\nsts = crystalhd_map_dio(ctx->adp, ubuff, ub_sz, 0, 0, 1, &dio_hnd);\r\nif (sts != BC_STS_SUCCESS) {\r\nBCMLOG_ERR("dio map - %d\n", sts);\r\nreturn sts;\r\n}\r\nif (!dio_hnd)\r\nreturn BC_STS_ERROR;\r\nsts = bc_cproc_hw_txdma(ctx, idata, dio_hnd);\r\ncrystalhd_unmap_dio(ctx->adp, dio_hnd);\r\nreturn sts;\r\n}\r\nstatic enum BC_STATUS bc_cproc_add_cap_buff(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nvoid *ubuff;\r\nuint32_t ub_sz, uv_off;\r\nbool en_422;\r\nstruct crystalhd_dio_req *dio_hnd = NULL;\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nif (!ctx || !idata) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nubuff = idata->udata.u.RxBuffs.YuvBuff;\r\nub_sz = idata->udata.u.RxBuffs.YuvBuffSz;\r\nuv_off = idata->udata.u.RxBuffs.UVbuffOffset;\r\nen_422 = idata->udata.u.RxBuffs.b422Mode;\r\nsts = bc_cproc_check_inbuffs(0, ubuff, ub_sz, uv_off, en_422);\r\nif (sts != BC_STS_SUCCESS)\r\nreturn sts;\r\nsts = crystalhd_map_dio(ctx->adp, ubuff, ub_sz, uv_off,\r\nen_422, 0, &dio_hnd);\r\nif (sts != BC_STS_SUCCESS) {\r\nBCMLOG_ERR("dio map - %d\n", sts);\r\nreturn sts;\r\n}\r\nif (!dio_hnd)\r\nreturn BC_STS_ERROR;\r\nsts = crystalhd_hw_add_cap_buffer(&ctx->hw_ctx, dio_hnd,\r\n(ctx->state == BC_LINK_READY));\r\nif ((sts != BC_STS_SUCCESS) && (sts != BC_STS_BUSY)) {\r\ncrystalhd_unmap_dio(ctx->adp, dio_hnd);\r\nreturn sts;\r\n}\r\nreturn BC_STS_SUCCESS;\r\n}\r\nstatic enum BC_STATUS bc_cproc_fmt_change(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_dio_req *dio)\r\n{\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nsts = crystalhd_hw_add_cap_buffer(&ctx->hw_ctx, dio, 0);\r\nif (sts != BC_STS_SUCCESS)\r\nreturn sts;\r\nctx->state |= BC_LINK_FMT_CHG;\r\nif (ctx->state == BC_LINK_READY)\r\nsts = crystalhd_hw_start_capture(&ctx->hw_ctx);\r\nreturn sts;\r\n}\r\nstatic enum BC_STATUS bc_cproc_fetch_frame(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nstruct crystalhd_dio_req *dio = NULL;\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nstruct BC_DEC_OUT_BUFF *frame;\r\nif (!ctx || !idata) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nif (!(ctx->state & BC_LINK_CAP_EN)) {\r\nBCMLOG(BCMLOG_DBG, "Capture not enabled..%x\n", ctx->state);\r\nreturn BC_STS_ERR_USAGE;\r\n}\r\nframe = &idata->udata.u.DecOutData;\r\nsts = crystalhd_hw_get_cap_buffer(&ctx->hw_ctx, &frame->PibInfo, &dio);\r\nif (sts != BC_STS_SUCCESS)\r\nreturn (ctx->state & BC_LINK_SUSPEND) ?\r\nBC_STS_IO_USER_ABORT : sts;\r\nframe->Flags = dio->uinfo.comp_flags;\r\nif (frame->Flags & COMP_FLAG_FMT_CHANGE)\r\nreturn bc_cproc_fmt_change(ctx, dio);\r\nframe->OutPutBuffs.YuvBuff = dio->uinfo.xfr_buff;\r\nframe->OutPutBuffs.YuvBuffSz = dio->uinfo.xfr_len;\r\nframe->OutPutBuffs.UVbuffOffset = dio->uinfo.uv_offset;\r\nframe->OutPutBuffs.b422Mode = dio->uinfo.b422mode;\r\nframe->OutPutBuffs.YBuffDoneSz = dio->uinfo.y_done_sz;\r\nframe->OutPutBuffs.UVBuffDoneSz = dio->uinfo.uv_done_sz;\r\ncrystalhd_unmap_dio(ctx->adp, dio);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nstatic enum BC_STATUS bc_cproc_start_capture(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nctx->state |= BC_LINK_CAP_EN;\r\nif (ctx->state == BC_LINK_READY)\r\nreturn crystalhd_hw_start_capture(&ctx->hw_ctx);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nstatic enum BC_STATUS bc_cproc_flush_cap_buffs(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nstruct crystalhd_dio_req *dio = NULL;\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nstruct BC_DEC_OUT_BUFF *frame;\r\nuint32_t count;\r\nif (!ctx || !idata) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nif (!(ctx->state & BC_LINK_CAP_EN))\r\nreturn BC_STS_ERR_USAGE;\r\nif (!(ctx->state & BC_LINK_READY))\r\nreturn crystalhd_hw_stop_capture(&ctx->hw_ctx);\r\nctx->state &= ~(BC_LINK_CAP_EN|BC_LINK_FMT_CHG);\r\nframe = &idata->udata.u.DecOutData;\r\nfor (count = 0; count < BC_RX_LIST_CNT; count++) {\r\nsts = crystalhd_hw_get_cap_buffer(&ctx->hw_ctx,\r\n&frame->PibInfo, &dio);\r\nif (sts != BC_STS_SUCCESS)\r\nbreak;\r\ncrystalhd_unmap_dio(ctx->adp, dio);\r\n}\r\nreturn crystalhd_hw_stop_capture(&ctx->hw_ctx);\r\n}\r\nstatic enum BC_STATUS bc_cproc_get_stats(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nstruct BC_DTS_STATS *stats;\r\nstruct crystalhd_hw_stats hw_stats;\r\nif (!ctx || !idata) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\ncrystalhd_hw_stats(&ctx->hw_ctx, &hw_stats);\r\nstats = &idata->udata.u.drvStat;\r\nstats->drvRLL = hw_stats.rdyq_count;\r\nstats->drvFLL = hw_stats.freeq_count;\r\nstats->DrvTotalFrmDropped = hw_stats.rx_errors;\r\nstats->DrvTotalHWErrs = hw_stats.rx_errors + hw_stats.tx_errors;\r\nstats->intCount = hw_stats.num_interrupts;\r\nstats->DrvIgnIntrCnt = hw_stats.num_interrupts -\r\nhw_stats.dev_interrupts;\r\nstats->TxFifoBsyCnt = hw_stats.cin_busy;\r\nstats->pauseCount = hw_stats.pause_cnt;\r\nif (ctx->pwr_state_change)\r\nstats->pwr_state_change = 1;\r\nif (ctx->state & BC_LINK_PAUSED)\r\nstats->DrvPauseTime = 1;\r\nreturn BC_STS_SUCCESS;\r\n}\r\nstatic enum BC_STATUS bc_cproc_reset_stats(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\ncrystalhd_hw_stats(&ctx->hw_ctx, NULL);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nstatic enum BC_STATUS bc_cproc_chg_clk(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nstruct BC_CLOCK *clock;\r\nuint32_t oldClk;\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nif (!ctx || !idata) {\r\nBCMLOG_ERR("Invalid Arg!!\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nclock = &idata->udata.u.clockValue;\r\noldClk = ctx->hw_ctx.core_clock_mhz;\r\nctx->hw_ctx.core_clock_mhz = clock->clk;\r\nif (ctx->state & BC_LINK_READY) {\r\nsts = crystalhd_hw_set_core_clock(&ctx->hw_ctx);\r\nif (sts == BC_STS_CLK_NOCHG)\r\nctx->hw_ctx.core_clock_mhz = oldClk;\r\n}\r\nclock->clk = ctx->hw_ctx.core_clock_mhz;\r\nreturn sts;\r\n}\r\nenum BC_STATUS crystalhd_suspend(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_ioctl_data *idata)\r\n{\r\nenum BC_STATUS sts = BC_STS_SUCCESS;\r\nif (!ctx || !idata) {\r\nBCMLOG_ERR("Invalid Parameters\n");\r\nreturn BC_STS_ERROR;\r\n}\r\nif (ctx->state & BC_LINK_SUSPEND)\r\nreturn BC_STS_SUCCESS;\r\nif (ctx->state == BC_LINK_INVALID) {\r\nBCMLOG(BCMLOG_DBG, "Nothing To Do Suspend Success\n");\r\nreturn BC_STS_SUCCESS;\r\n}\r\nctx->state |= BC_LINK_SUSPEND;\r\nbc_cproc_mark_pwr_state(ctx);\r\nif (ctx->state & BC_LINK_CAP_EN) {\r\nsts = bc_cproc_flush_cap_buffs(ctx, idata);\r\nif (sts != BC_STS_SUCCESS)\r\nreturn sts;\r\n}\r\nif (ctx->tx_list_id) {\r\nsts = crystalhd_hw_cancel_tx(&ctx->hw_ctx, ctx->tx_list_id);\r\nif (sts != BC_STS_SUCCESS)\r\nreturn sts;\r\n}\r\nsts = crystalhd_hw_suspend(&ctx->hw_ctx);\r\nif (sts != BC_STS_SUCCESS)\r\nreturn sts;\r\nBCMLOG(BCMLOG_DBG, "BCM70012 suspend success\n");\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_resume(struct crystalhd_cmd *ctx)\r\n{\r\nBCMLOG(BCMLOG_DBG, "crystalhd_resume Success %x\n", ctx->state);\r\nbc_cproc_mark_pwr_state(ctx);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_user_open(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_user **user_ctx)\r\n{\r\nstruct crystalhd_user *uc;\r\nif (!ctx || !user_ctx) {\r\nBCMLOG_ERR("Invalid arg..\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nuc = bc_cproc_get_uid(ctx);\r\nif (!uc) {\r\nBCMLOG(BCMLOG_INFO, "No free user context...\n");\r\nreturn BC_STS_BUSY;\r\n}\r\nBCMLOG(BCMLOG_INFO, "Opening new user[%x] handle\n", uc->uid);\r\ncrystalhd_hw_open(&ctx->hw_ctx, ctx->adp);\r\nuc->in_use = 1;\r\n*user_ctx = uc;\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_user_close(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_user *uc)\r\n{\r\nuint32_t mode = uc->mode;\r\nctx->user[uc->uid].mode = DTS_MODE_INV;\r\nctx->user[uc->uid].in_use = 0;\r\nctx->cin_wait_exit = 1;\r\nctx->pwr_state_change = 0;\r\nBCMLOG(BCMLOG_INFO, "Closing user[%x] handle\n", uc->uid);\r\nif ((mode == DTS_DIAG_MODE) || (mode == DTS_PLAYBACK_MODE)) {\r\ncrystalhd_hw_free_dma_rings(&ctx->hw_ctx);\r\ncrystalhd_destroy_dio_pool(ctx->adp);\r\n} else if (bc_cproc_get_user_count(ctx)) {\r\nreturn BC_STS_SUCCESS;\r\n}\r\ncrystalhd_hw_close(&ctx->hw_ctx);\r\nctx->state = BC_LINK_INVALID;\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_setup_cmd_context(struct crystalhd_cmd *ctx,\r\nstruct crystalhd_adp *adp)\r\n{\r\nint i = 0;\r\nif (!ctx || !adp) {\r\nBCMLOG_ERR("Invalid arg!!\n");\r\nreturn BC_STS_INV_ARG;\r\n}\r\nif (ctx->adp)\r\nBCMLOG(BCMLOG_DBG, "Resetting Cmd context delete missing..\n");\r\nctx->adp = adp;\r\nfor (i = 0; i < BC_LINK_MAX_OPENS; i++) {\r\nctx->user[i].uid = i;\r\nctx->user[i].in_use = 0;\r\nctx->user[i].mode = DTS_MODE_INV;\r\n}\r\ncrystalhd_hw_open(&ctx->hw_ctx, ctx->adp);\r\ncrystalhd_hw_close(&ctx->hw_ctx);\r\nreturn BC_STS_SUCCESS;\r\n}\r\nenum BC_STATUS crystalhd_delete_cmd_context(struct crystalhd_cmd *ctx)\r\n{\r\nBCMLOG(BCMLOG_DBG, "Deleting Command context..\n");\r\nctx->adp = NULL;\r\nreturn BC_STS_SUCCESS;\r\n}\r\ncrystalhd_cmd_proc crystalhd_get_cmd_proc(struct crystalhd_cmd *ctx,\r\nuint32_t cmd, struct crystalhd_user *uc)\r\n{\r\ncrystalhd_cmd_proc cproc = NULL;\r\nunsigned int i, tbl_sz;\r\nif (!ctx) {\r\nBCMLOG_ERR("Invalid arg.. Cmd[%d]\n", cmd);\r\nreturn NULL;\r\n}\r\nif ((cmd != BCM_IOC_GET_DRV_STAT) && (ctx->state & BC_LINK_SUSPEND)) {\r\nBCMLOG_ERR("Invalid State [suspend Set].. Cmd[%d]\n", cmd);\r\nreturn NULL;\r\n}\r\ntbl_sz = sizeof(g_crystalhd_cproc_tbl) /\r\nsizeof(struct crystalhd_cmd_tbl);\r\nfor (i = 0; i < tbl_sz; i++) {\r\nif (g_crystalhd_cproc_tbl[i].cmd_id == cmd) {\r\nif ((uc->mode == DTS_MONITOR_MODE) &&\r\n(g_crystalhd_cproc_tbl[i].block_mon)) {\r\nBCMLOG(BCMLOG_INFO, "Blocking cmd %d\n", cmd);\r\nbreak;\r\n}\r\ncproc = g_crystalhd_cproc_tbl[i].cmd_proc;\r\nbreak;\r\n}\r\n}\r\nreturn cproc;\r\n}\r\nbool crystalhd_cmd_interrupt(struct crystalhd_cmd *ctx)\r\n{\r\nif (!ctx) {\r\nBCMLOG_ERR("Invalid arg..\n");\r\nreturn 0;\r\n}\r\nreturn crystalhd_hw_interrupt(ctx->adp, &ctx->hw_ctx);\r\n}
