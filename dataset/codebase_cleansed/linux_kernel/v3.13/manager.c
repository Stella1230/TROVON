int dss_init_overlay_managers(void)\r\n{\r\nint i;\r\nnum_managers = dss_feat_get_num_mgrs();\r\nmanagers = kzalloc(sizeof(struct omap_overlay_manager) * num_managers,\r\nGFP_KERNEL);\r\nBUG_ON(managers == NULL);\r\nfor (i = 0; i < num_managers; ++i) {\r\nstruct omap_overlay_manager *mgr = &managers[i];\r\nswitch (i) {\r\ncase 0:\r\nmgr->name = "lcd";\r\nmgr->id = OMAP_DSS_CHANNEL_LCD;\r\nbreak;\r\ncase 1:\r\nmgr->name = "tv";\r\nmgr->id = OMAP_DSS_CHANNEL_DIGIT;\r\nbreak;\r\ncase 2:\r\nmgr->name = "lcd2";\r\nmgr->id = OMAP_DSS_CHANNEL_LCD2;\r\nbreak;\r\ncase 3:\r\nmgr->name = "lcd3";\r\nmgr->id = OMAP_DSS_CHANNEL_LCD3;\r\nbreak;\r\n}\r\nmgr->caps = 0;\r\nmgr->supported_displays =\r\ndss_feat_get_supported_displays(mgr->id);\r\nmgr->supported_outputs =\r\ndss_feat_get_supported_outputs(mgr->id);\r\nINIT_LIST_HEAD(&mgr->overlays);\r\n}\r\nreturn 0;\r\n}\r\nint dss_init_overlay_managers_sysfs(struct platform_device *pdev)\r\n{\r\nint i, r;\r\nfor (i = 0; i < num_managers; ++i) {\r\nstruct omap_overlay_manager *mgr = &managers[i];\r\nr = dss_manager_kobj_init(mgr, pdev);\r\nif (r)\r\nDSSERR("failed to create sysfs file\n");\r\n}\r\nreturn 0;\r\n}\r\nvoid dss_uninit_overlay_managers(void)\r\n{\r\nkfree(managers);\r\nmanagers = NULL;\r\nnum_managers = 0;\r\n}\r\nvoid dss_uninit_overlay_managers_sysfs(struct platform_device *pdev)\r\n{\r\nint i;\r\nfor (i = 0; i < num_managers; ++i) {\r\nstruct omap_overlay_manager *mgr = &managers[i];\r\ndss_manager_kobj_uninit(mgr);\r\n}\r\n}\r\nint omap_dss_get_num_overlay_managers(void)\r\n{\r\nreturn num_managers;\r\n}\r\nstruct omap_overlay_manager *omap_dss_get_overlay_manager(int num)\r\n{\r\nif (num >= num_managers)\r\nreturn NULL;\r\nreturn &managers[num];\r\n}\r\nint dss_mgr_simple_check(struct omap_overlay_manager *mgr,\r\nconst struct omap_overlay_manager_info *info)\r\n{\r\nif (dss_has_feature(FEAT_ALPHA_FIXED_ZORDER)) {\r\nif (info->partial_alpha_enabled && info->trans_enabled\r\n&& info->trans_key_type != OMAP_DSS_COLOR_KEY_GFX_DST) {\r\nDSSERR("check_manager: illegal transparency key\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dss_mgr_check_zorder(struct omap_overlay_manager *mgr,\r\nstruct omap_overlay_info **overlay_infos)\r\n{\r\nstruct omap_overlay *ovl1, *ovl2;\r\nstruct omap_overlay_info *info1, *info2;\r\nlist_for_each_entry(ovl1, &mgr->overlays, list) {\r\ninfo1 = overlay_infos[ovl1->id];\r\nif (info1 == NULL)\r\ncontinue;\r\nlist_for_each_entry(ovl2, &mgr->overlays, list) {\r\nif (ovl1 == ovl2)\r\ncontinue;\r\ninfo2 = overlay_infos[ovl2->id];\r\nif (info2 == NULL)\r\ncontinue;\r\nif (info1->zorder == info2->zorder) {\r\nDSSERR("overlays %d and %d have the same "\r\n"zorder %d\n",\r\novl1->id, ovl2->id, info1->zorder);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint dss_mgr_check_timings(struct omap_overlay_manager *mgr,\r\nconst struct omap_video_timings *timings)\r\n{\r\nif (!dispc_mgr_timings_ok(mgr->id, timings)) {\r\nDSSERR("check_manager: invalid timings\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dss_mgr_check_lcd_config(struct omap_overlay_manager *mgr,\r\nconst struct dss_lcd_mgr_config *config)\r\n{\r\nstruct dispc_clock_info cinfo = config->clock_info;\r\nint dl = config->video_port_width;\r\nbool stallmode = config->stallmode;\r\nbool fifohandcheck = config->fifohandcheck;\r\nif (cinfo.lck_div < 1 || cinfo.lck_div > 255)\r\nreturn -EINVAL;\r\nif (cinfo.pck_div < 1 || cinfo.pck_div > 255)\r\nreturn -EINVAL;\r\nif (dl != 12 && dl != 16 && dl != 18 && dl != 24)\r\nreturn -EINVAL;\r\nif (stallmode == false && fifohandcheck == true)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint dss_mgr_check(struct omap_overlay_manager *mgr,\r\nstruct omap_overlay_manager_info *info,\r\nconst struct omap_video_timings *mgr_timings,\r\nconst struct dss_lcd_mgr_config *lcd_config,\r\nstruct omap_overlay_info **overlay_infos)\r\n{\r\nstruct omap_overlay *ovl;\r\nint r;\r\nif (dss_has_feature(FEAT_ALPHA_FREE_ZORDER)) {\r\nr = dss_mgr_check_zorder(mgr, overlay_infos);\r\nif (r)\r\nreturn r;\r\n}\r\nr = dss_mgr_check_timings(mgr, mgr_timings);\r\nif (r)\r\nreturn r;\r\nr = dss_mgr_check_lcd_config(mgr, lcd_config);\r\nif (r)\r\nreturn r;\r\nlist_for_each_entry(ovl, &mgr->overlays, list) {\r\nstruct omap_overlay_info *oi;\r\nint r;\r\noi = overlay_infos[ovl->id];\r\nif (oi == NULL)\r\ncontinue;\r\nr = dss_ovl_check(ovl, oi, mgr_timings);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn 0;\r\n}
