static struct usbip_imported_device *\r\nimported_device_init(struct usbip_imported_device *idev, char *busid)\r\n{\r\nstruct sysfs_device *sudev;\r\nsudev = sysfs_open_device("usb", busid);\r\nif (!sudev) {\r\ndbg("sysfs_open_device failed: %s", busid);\r\ngoto err;\r\n}\r\nread_usb_device(sudev, &idev->udev);\r\nsysfs_close_device(sudev);\r\nstruct usbip_class_device *cdev;\r\ndlist_for_each_data(vhci_driver->cdev_list, cdev,\r\nstruct usbip_class_device) {\r\nif (!strncmp(cdev->dev_path, idev->udev.path,\r\nstrlen(idev->udev.path))) {\r\nstruct usbip_class_device *new_cdev;\r\nnew_cdev = calloc(1, sizeof(*new_cdev));\r\nif (!new_cdev)\r\ngoto err;\r\nmemcpy(new_cdev, cdev, sizeof(*new_cdev));\r\ndlist_unshift(idev->cdev_list, (void *) new_cdev);\r\n}\r\n}\r\nreturn idev;\r\nerr:\r\nreturn NULL;\r\n}\r\nstatic int parse_status(char *value)\r\n{\r\nint ret = 0;\r\nchar *c;\r\nfor (int i = 0; i < vhci_driver->nports; i++)\r\nmemset(&vhci_driver->idev[i], 0, sizeof(vhci_driver->idev[i]));\r\nc = strchr(value, '\n');\r\nif (!c)\r\nreturn -1;\r\nc++;\r\nwhile (*c != '\0') {\r\nint port, status, speed, devid;\r\nunsigned long socket;\r\nchar lbusid[SYSFS_BUS_ID_SIZE];\r\nret = sscanf(c, "%d %d %d %x %lx %s\n",\r\n&port, &status, &speed,\r\n&devid, &socket, lbusid);\r\nif (ret < 5) {\r\ndbg("sscanf failed: %d", ret);\r\nBUG();\r\n}\r\ndbg("port %d status %d speed %d devid %x",\r\nport, status, speed, devid);\r\ndbg("socket %lx lbusid %s", socket, lbusid);\r\n{\r\nstruct usbip_imported_device *idev = &vhci_driver->idev[port];\r\nidev->port = port;\r\nidev->status = status;\r\nidev->devid = devid;\r\nidev->busnum = (devid >> 16);\r\nidev->devnum = (devid & 0x0000ffff);\r\nidev->cdev_list = dlist_new(sizeof(struct usbip_class_device));\r\nif (!idev->cdev_list) {\r\ndbg("dlist_new failed");\r\nreturn -1;\r\n}\r\nif (idev->status != VDEV_ST_NULL\r\n&& idev->status != VDEV_ST_NOTASSIGNED) {\r\nidev = imported_device_init(idev, lbusid);\r\nif (!idev) {\r\ndbg("imported_device_init failed");\r\nreturn -1;\r\n}\r\n}\r\n}\r\nc = strchr(c, '\n');\r\nif (!c)\r\nbreak;\r\nc++;\r\n}\r\ndbg("exit");\r\nreturn 0;\r\n}\r\nstatic int check_usbip_device(struct sysfs_class_device *cdev)\r\n{\r\nchar class_path[SYSFS_PATH_MAX];\r\nchar dev_path[SYSFS_PATH_MAX];\r\nint ret;\r\nstruct usbip_class_device *usbip_cdev;\r\nsnprintf(class_path, sizeof(class_path), "%s/device", cdev->path);\r\nret = sysfs_get_link(class_path, dev_path, sizeof(dev_path));\r\nif (ret == 0) {\r\nif (!strncmp(dev_path, vhci_driver->hc_device->path,\r\nstrlen(vhci_driver->hc_device->path))) {\r\nusbip_cdev = calloc(1, sizeof(*usbip_cdev));\r\nif (!usbip_cdev) {\r\ndbg("calloc failed");\r\nreturn -1;\r\n}\r\ndlist_unshift(vhci_driver->cdev_list, usbip_cdev);\r\nstrncpy(usbip_cdev->class_path, class_path,\r\nsizeof(usbip_cdev->class_path));\r\nstrncpy(usbip_cdev->dev_path, dev_path,\r\nsizeof(usbip_cdev->dev_path));\r\ndbg("found: %s %s", class_path, dev_path);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int search_class_for_usbip_device(char *cname)\r\n{\r\nstruct sysfs_class *class;\r\nstruct dlist *cdev_list;\r\nstruct sysfs_class_device *cdev;\r\nint ret = 0;\r\nclass = sysfs_open_class(cname);\r\nif (!class) {\r\ndbg("sysfs_open_class failed");\r\nreturn -1;\r\n}\r\ndbg("class: %s", class->name);\r\ncdev_list = sysfs_get_class_devices(class);\r\nif (!cdev_list)\r\ngoto out;\r\ndlist_for_each_data(cdev_list, cdev, struct sysfs_class_device) {\r\ndbg("cdev: %s", cdev->name);\r\nret = check_usbip_device(cdev);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nout:\r\nsysfs_close_class(class);\r\nreturn ret;\r\n}\r\nstatic int refresh_class_device_list(void)\r\n{\r\nint ret;\r\nstruct dlist *cname_list;\r\nchar *cname;\r\nchar sysfs_mntpath[SYSFS_PATH_MAX];\r\nchar class_path[SYSFS_PATH_MAX];\r\nret = sysfs_get_mnt_path(sysfs_mntpath, SYSFS_PATH_MAX);\r\nif (ret < 0) {\r\ndbg("sysfs_get_mnt_path failed");\r\nreturn -1;\r\n}\r\nsnprintf(class_path, sizeof(class_path), "%s/%s", sysfs_mntpath,\r\nSYSFS_CLASS_NAME);\r\ncname_list = sysfs_open_directory_list(class_path);\r\nif (!cname_list) {\r\ndbg("sysfs_open_directory failed");\r\nreturn -1;\r\n}\r\ndlist_for_each_data(cname_list, cname, char) {\r\nret = search_class_for_usbip_device(cname);\r\nif (ret < 0) {\r\nsysfs_close_list(cname_list);\r\nreturn -1;\r\n}\r\n}\r\nsysfs_close_list(cname_list);\r\nret = search_class_for_usbip_device(SYSFS_BLOCK_NAME);\r\nif (ret < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int refresh_imported_device_list(void)\r\n{\r\nstruct sysfs_attribute *attr_status;\r\nattr_status = sysfs_get_device_attr(vhci_driver->hc_device, "status");\r\nif (!attr_status) {\r\ndbg("sysfs_get_device_attr(\"status\") failed: %s",\r\nvhci_driver->hc_device->name);\r\nreturn -1;\r\n}\r\ndbg("name: %s path: %s len: %d method: %d value: %s",\r\nattr_status->name, attr_status->path, attr_status->len,\r\nattr_status->method, attr_status->value);\r\nreturn parse_status(attr_status->value);\r\n}\r\nstatic int get_nports(void)\r\n{\r\nchar *c;\r\nint nports = 0;\r\nstruct sysfs_attribute *attr_status;\r\nattr_status = sysfs_get_device_attr(vhci_driver->hc_device, "status");\r\nif (!attr_status) {\r\ndbg("sysfs_get_device_attr(\"status\") failed: %s",\r\nvhci_driver->hc_device->name);\r\nreturn -1;\r\n}\r\ndbg("name: %s path: %s len: %d method: %d value: %s",\r\nattr_status->name, attr_status->path, attr_status->len,\r\nattr_status->method, attr_status->value);\r\nc = strchr(attr_status->value, '\n');\r\nif (!c)\r\nreturn 0;\r\nc++;\r\nwhile (*c != '\0') {\r\nc = strchr(c, '\n');\r\nif (!c)\r\nreturn nports;\r\nc++;\r\nnports += 1;\r\n}\r\nreturn nports;\r\n}\r\nstatic int get_hc_busid(char *sysfs_mntpath, char *hc_busid)\r\n{\r\nstruct sysfs_driver *sdriver;\r\nchar sdriver_path[SYSFS_PATH_MAX];\r\nstruct sysfs_device *hc_dev;\r\nstruct dlist *hc_devs;\r\nint found = 0;\r\nsnprintf(sdriver_path, SYSFS_PATH_MAX, "%s/%s/%s/%s/%s", sysfs_mntpath,\r\nSYSFS_BUS_NAME, USBIP_VHCI_BUS_TYPE, SYSFS_DRIVERS_NAME,\r\nUSBIP_VHCI_DRV_NAME);\r\nsdriver = sysfs_open_driver_path(sdriver_path);\r\nif (!sdriver) {\r\ndbg("sysfs_open_driver_path failed: %s", sdriver_path);\r\ndbg("make sure " USBIP_CORE_MOD_NAME ".ko and "\r\nUSBIP_VHCI_DRV_NAME ".ko are loaded!");\r\nreturn -1;\r\n}\r\nhc_devs = sysfs_get_driver_devices(sdriver);\r\nif (!hc_devs) {\r\ndbg("sysfs_get_driver failed");\r\ngoto err;\r\n}\r\ndlist_for_each_data(hc_devs, hc_dev, struct sysfs_device) {\r\nstrncpy(hc_busid, hc_dev->bus_id, SYSFS_BUS_ID_SIZE);\r\nfound = 1;\r\n}\r\nerr:\r\nsysfs_close_driver(sdriver);\r\nif (found)\r\nreturn 0;\r\ndbg("%s not found", hc_busid);\r\nreturn -1;\r\n}\r\nint usbip_vhci_driver_open(void)\r\n{\r\nint ret;\r\nchar hc_busid[SYSFS_BUS_ID_SIZE];\r\nvhci_driver = (struct usbip_vhci_driver *) calloc(1, sizeof(*vhci_driver));\r\nif (!vhci_driver) {\r\ndbg("calloc failed");\r\nreturn -1;\r\n}\r\nret = sysfs_get_mnt_path(vhci_driver->sysfs_mntpath, SYSFS_PATH_MAX);\r\nif (ret < 0) {\r\ndbg("sysfs_get_mnt_path failed");\r\ngoto err;\r\n}\r\nret = get_hc_busid(vhci_driver->sysfs_mntpath, hc_busid);\r\nif (ret < 0)\r\ngoto err;\r\nvhci_driver->hc_device = sysfs_open_device(USBIP_VHCI_BUS_TYPE,\r\nhc_busid);\r\nif (!vhci_driver->hc_device) {\r\ndbg("sysfs_open_device failed");\r\ngoto err;\r\n}\r\nvhci_driver->nports = get_nports();\r\ndbg("available ports: %d", vhci_driver->nports);\r\nvhci_driver->cdev_list = dlist_new(sizeof(struct usbip_class_device));\r\nif (!vhci_driver->cdev_list)\r\ngoto err;\r\nif (refresh_class_device_list())\r\ngoto err;\r\nif (refresh_imported_device_list())\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nif (vhci_driver->cdev_list)\r\ndlist_destroy(vhci_driver->cdev_list);\r\nif (vhci_driver->hc_device)\r\nsysfs_close_device(vhci_driver->hc_device);\r\nif (vhci_driver)\r\nfree(vhci_driver);\r\nvhci_driver = NULL;\r\nreturn -1;\r\n}\r\nvoid usbip_vhci_driver_close()\r\n{\r\nif (!vhci_driver)\r\nreturn;\r\nif (vhci_driver->cdev_list)\r\ndlist_destroy(vhci_driver->cdev_list);\r\nfor (int i = 0; i < vhci_driver->nports; i++) {\r\nif (vhci_driver->idev[i].cdev_list)\r\ndlist_destroy(vhci_driver->idev[i].cdev_list);\r\n}\r\nif (vhci_driver->hc_device)\r\nsysfs_close_device(vhci_driver->hc_device);\r\nfree(vhci_driver);\r\nvhci_driver = NULL;\r\n}\r\nint usbip_vhci_refresh_device_list(void)\r\n{\r\nif (vhci_driver->cdev_list)\r\ndlist_destroy(vhci_driver->cdev_list);\r\nfor (int i = 0; i < vhci_driver->nports; i++) {\r\nif (vhci_driver->idev[i].cdev_list)\r\ndlist_destroy(vhci_driver->idev[i].cdev_list);\r\n}\r\nvhci_driver->cdev_list = dlist_new(sizeof(struct usbip_class_device));\r\nif (!vhci_driver->cdev_list)\r\ngoto err;\r\nif (refresh_class_device_list())\r\ngoto err;\r\nif (refresh_imported_device_list())\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nif (vhci_driver->cdev_list)\r\ndlist_destroy(vhci_driver->cdev_list);\r\nfor (int i = 0; i < vhci_driver->nports; i++) {\r\nif (vhci_driver->idev[i].cdev_list)\r\ndlist_destroy(vhci_driver->idev[i].cdev_list);\r\n}\r\ndbg("failed to refresh device list");\r\nreturn -1;\r\n}\r\nint usbip_vhci_get_free_port(void)\r\n{\r\nfor (int i = 0; i < vhci_driver->nports; i++) {\r\nif (vhci_driver->idev[i].status == VDEV_ST_NULL)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nint usbip_vhci_attach_device2(uint8_t port, int sockfd, uint32_t devid,\r\nuint32_t speed) {\r\nstruct sysfs_attribute *attr_attach;\r\nchar buff[200];\r\nint ret;\r\nattr_attach = sysfs_get_device_attr(vhci_driver->hc_device, "attach");\r\nif (!attr_attach) {\r\ndbg("sysfs_get_device_attr(\"attach\") failed: %s",\r\nvhci_driver->hc_device->name);\r\nreturn -1;\r\n}\r\nsnprintf(buff, sizeof(buff), "%u %u %u %u",\r\nport, sockfd, devid, speed);\r\ndbg("writing: %s", buff);\r\nret = sysfs_write_attribute(attr_attach, buff, strlen(buff));\r\nif (ret < 0) {\r\ndbg("sysfs_write_attribute failed");\r\nreturn -1;\r\n}\r\ndbg("attached port: %d", port);\r\nreturn 0;\r\n}\r\nstatic unsigned long get_devid(uint8_t busnum, uint8_t devnum)\r\n{\r\nreturn (busnum << 16) | devnum;\r\n}\r\nint usbip_vhci_attach_device(uint8_t port, int sockfd, uint8_t busnum,\r\nuint8_t devnum, uint32_t speed)\r\n{\r\nint devid = get_devid(busnum, devnum);\r\nreturn usbip_vhci_attach_device2(port, sockfd, devid, speed);\r\n}\r\nint usbip_vhci_detach_device(uint8_t port)\r\n{\r\nstruct sysfs_attribute *attr_detach;\r\nchar buff[200];\r\nint ret;\r\nattr_detach = sysfs_get_device_attr(vhci_driver->hc_device, "detach");\r\nif (!attr_detach) {\r\ndbg("sysfs_get_device_attr(\"detach\") failed: %s",\r\nvhci_driver->hc_device->name);\r\nreturn -1;\r\n}\r\nsnprintf(buff, sizeof(buff), "%u", port);\r\ndbg("writing: %s", buff);\r\nret = sysfs_write_attribute(attr_detach, buff, strlen(buff));\r\nif (ret < 0) {\r\ndbg("sysfs_write_attribute failed");\r\nreturn -1;\r\n}\r\ndbg("detached port: %d", port);\r\nreturn 0;\r\n}
