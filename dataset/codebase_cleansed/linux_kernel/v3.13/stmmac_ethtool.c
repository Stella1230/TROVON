static void stmmac_ethtool_getdrvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nif (priv->plat->has_gmac)\r\nstrlcpy(info->driver, GMAC_ETHTOOL_NAME, sizeof(info->driver));\r\nelse\r\nstrlcpy(info->driver, MAC100_ETHTOOL_NAME,\r\nsizeof(info->driver));\r\nstrlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));\r\n}\r\nstatic int stmmac_ethtool_getsettings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nstruct phy_device *phy = priv->phydev;\r\nint rc;\r\nif ((priv->pcs & STMMAC_PCS_RGMII) || (priv->pcs & STMMAC_PCS_SGMII)) {\r\nstruct rgmii_adv adv;\r\nif (!priv->xstats.pcs_link) {\r\nethtool_cmd_speed_set(cmd, SPEED_UNKNOWN);\r\ncmd->duplex = DUPLEX_UNKNOWN;\r\nreturn 0;\r\n}\r\ncmd->duplex = priv->xstats.pcs_duplex;\r\nethtool_cmd_speed_set(cmd, priv->xstats.pcs_speed);\r\nif (priv->hw->mac->get_adv)\r\npriv->hw->mac->get_adv(priv->ioaddr, &adv);\r\nelse\r\nreturn -EOPNOTSUPP;\r\nif (adv.pause & STMMAC_PCS_PAUSE)\r\ncmd->advertising |= ADVERTISED_Pause;\r\nif (adv.pause & STMMAC_PCS_ASYM_PAUSE)\r\ncmd->advertising |= ADVERTISED_Asym_Pause;\r\nif (adv.lp_pause & STMMAC_PCS_PAUSE)\r\ncmd->lp_advertising |= ADVERTISED_Pause;\r\nif (adv.lp_pause & STMMAC_PCS_ASYM_PAUSE)\r\ncmd->lp_advertising |= ADVERTISED_Asym_Pause;\r\ncmd->autoneg = ADVERTISED_Autoneg;\r\ncmd->supported |= SUPPORTED_Autoneg;\r\ncmd->advertising |= ADVERTISED_Autoneg;\r\ncmd->lp_advertising |= ADVERTISED_Autoneg;\r\nif (adv.duplex) {\r\ncmd->supported |= (SUPPORTED_1000baseT_Full |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_10baseT_Full);\r\ncmd->advertising |= (ADVERTISED_1000baseT_Full |\r\nADVERTISED_100baseT_Full |\r\nADVERTISED_10baseT_Full);\r\n} else {\r\ncmd->supported |= (SUPPORTED_1000baseT_Half |\r\nSUPPORTED_100baseT_Half |\r\nSUPPORTED_10baseT_Half);\r\ncmd->advertising |= (ADVERTISED_1000baseT_Half |\r\nADVERTISED_100baseT_Half |\r\nADVERTISED_10baseT_Half);\r\n}\r\nif (adv.lp_duplex)\r\ncmd->lp_advertising |= (ADVERTISED_1000baseT_Full |\r\nADVERTISED_100baseT_Full |\r\nADVERTISED_10baseT_Full);\r\nelse\r\ncmd->lp_advertising |= (ADVERTISED_1000baseT_Half |\r\nADVERTISED_100baseT_Half |\r\nADVERTISED_10baseT_Half);\r\ncmd->port = PORT_OTHER;\r\nreturn 0;\r\n}\r\nif (phy == NULL) {\r\npr_err("%s: %s: PHY is not registered\n",\r\n__func__, dev->name);\r\nreturn -ENODEV;\r\n}\r\nif (!netif_running(dev)) {\r\npr_err("%s: interface is disabled: we cannot track "\r\n"link speed / duplex setting\n", dev->name);\r\nreturn -EBUSY;\r\n}\r\ncmd->transceiver = XCVR_INTERNAL;\r\nspin_lock_irq(&priv->lock);\r\nrc = phy_ethtool_gset(phy, cmd);\r\nspin_unlock_irq(&priv->lock);\r\nreturn rc;\r\n}\r\nstatic int stmmac_ethtool_setsettings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nstruct phy_device *phy = priv->phydev;\r\nint rc;\r\nif ((priv->pcs & STMMAC_PCS_RGMII) || (priv->pcs & STMMAC_PCS_SGMII)) {\r\nu32 mask = ADVERTISED_Autoneg | ADVERTISED_Pause;\r\nif (cmd->autoneg != AUTONEG_ENABLE)\r\nreturn -EINVAL;\r\nif (cmd->autoneg == AUTONEG_ENABLE) {\r\nmask &= (ADVERTISED_1000baseT_Half |\r\nADVERTISED_1000baseT_Full |\r\nADVERTISED_100baseT_Half |\r\nADVERTISED_100baseT_Full |\r\nADVERTISED_10baseT_Half |\r\nADVERTISED_10baseT_Full);\r\nspin_lock(&priv->lock);\r\nif (priv->hw->mac->ctrl_ane)\r\npriv->hw->mac->ctrl_ane(priv->ioaddr, 1);\r\nspin_unlock(&priv->lock);\r\n}\r\nreturn 0;\r\n}\r\nspin_lock(&priv->lock);\r\nrc = phy_ethtool_sset(phy, cmd);\r\nspin_unlock(&priv->lock);\r\nreturn rc;\r\n}\r\nstatic u32 stmmac_ethtool_getmsglevel(struct net_device *dev)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nreturn priv->msg_enable;\r\n}\r\nstatic void stmmac_ethtool_setmsglevel(struct net_device *dev, u32 level)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\npriv->msg_enable = level;\r\n}\r\nstatic int stmmac_check_if_running(struct net_device *dev)\r\n{\r\nif (!netif_running(dev))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int stmmac_ethtool_get_regs_len(struct net_device *dev)\r\n{\r\nreturn REG_SPACE_SIZE;\r\n}\r\nstatic void stmmac_ethtool_gregs(struct net_device *dev,\r\nstruct ethtool_regs *regs, void *space)\r\n{\r\nint i;\r\nu32 *reg_space = (u32 *) space;\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nmemset(reg_space, 0x0, REG_SPACE_SIZE);\r\nif (!priv->plat->has_gmac) {\r\nfor (i = 0; i < 12; i++)\r\nreg_space[i] = readl(priv->ioaddr + (i * 4));\r\nfor (i = 0; i < 9; i++)\r\nreg_space[i + 12] =\r\nreadl(priv->ioaddr + (DMA_BUS_MODE + (i * 4)));\r\nreg_space[22] = readl(priv->ioaddr + DMA_CUR_TX_BUF_ADDR);\r\nreg_space[23] = readl(priv->ioaddr + DMA_CUR_RX_BUF_ADDR);\r\n} else {\r\nfor (i = 0; i < 55; i++)\r\nreg_space[i] = readl(priv->ioaddr + (i * 4));\r\nfor (i = 0; i < 22; i++)\r\nreg_space[i + 55] =\r\nreadl(priv->ioaddr + (DMA_BUS_MODE + (i * 4)));\r\n}\r\n}\r\nstatic void\r\nstmmac_get_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(netdev);\r\nif (priv->pcs)\r\nreturn;\r\nspin_lock(&priv->lock);\r\npause->rx_pause = 0;\r\npause->tx_pause = 0;\r\npause->autoneg = priv->phydev->autoneg;\r\nif (priv->flow_ctrl & FLOW_RX)\r\npause->rx_pause = 1;\r\nif (priv->flow_ctrl & FLOW_TX)\r\npause->tx_pause = 1;\r\nspin_unlock(&priv->lock);\r\n}\r\nstatic int\r\nstmmac_set_pauseparam(struct net_device *netdev,\r\nstruct ethtool_pauseparam *pause)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(netdev);\r\nstruct phy_device *phy = priv->phydev;\r\nint new_pause = FLOW_OFF;\r\nint ret = 0;\r\nif (priv->pcs)\r\nreturn -EOPNOTSUPP;\r\nspin_lock(&priv->lock);\r\nif (pause->rx_pause)\r\nnew_pause |= FLOW_RX;\r\nif (pause->tx_pause)\r\nnew_pause |= FLOW_TX;\r\npriv->flow_ctrl = new_pause;\r\nphy->autoneg = pause->autoneg;\r\nif (phy->autoneg) {\r\nif (netif_running(netdev))\r\nret = phy_start_aneg(phy);\r\n} else\r\npriv->hw->mac->flow_ctrl(priv->ioaddr, phy->duplex,\r\npriv->flow_ctrl, priv->pause);\r\nspin_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic void stmmac_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *dummy, u64 *data)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nint i, j = 0;\r\nif (!priv->plat->has_gmac)\r\npriv->hw->dma->dma_diagnostic_fr(&dev->stats,\r\n(void *) &priv->xstats,\r\npriv->ioaddr);\r\nelse {\r\nif (priv->dma_cap.rmon) {\r\ndwmac_mmc_read(priv->ioaddr, &priv->mmc);\r\nfor (i = 0; i < STMMAC_MMC_STATS_LEN; i++) {\r\nchar *p;\r\np = (char *)priv + stmmac_mmc[i].stat_offset;\r\ndata[j++] = (stmmac_mmc[i].sizeof_stat ==\r\nsizeof(u64)) ? (*(u64 *)p) :\r\n(*(u32 *)p);\r\n}\r\n}\r\nif (priv->eee_enabled) {\r\nint val = phy_get_eee_err(priv->phydev);\r\nif (val)\r\npriv->xstats.phy_eee_wakeup_error_n = val;\r\n}\r\n}\r\nfor (i = 0; i < STMMAC_STATS_LEN; i++) {\r\nchar *p = (char *)priv + stmmac_gstrings_stats[i].stat_offset;\r\ndata[j++] = (stmmac_gstrings_stats[i].sizeof_stat ==\r\nsizeof(u64)) ? (*(u64 *)p) : (*(u32 *)p);\r\n}\r\n}\r\nstatic int stmmac_get_sset_count(struct net_device *netdev, int sset)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(netdev);\r\nint len;\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nlen = STMMAC_STATS_LEN;\r\nif (priv->dma_cap.rmon)\r\nlen += STMMAC_MMC_STATS_LEN;\r\nreturn len;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void stmmac_get_strings(struct net_device *dev, u32 stringset, u8 *data)\r\n{\r\nint i;\r\nu8 *p = data;\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nif (priv->dma_cap.rmon)\r\nfor (i = 0; i < STMMAC_MMC_STATS_LEN; i++) {\r\nmemcpy(p, stmmac_mmc[i].stat_string,\r\nETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\n}\r\nfor (i = 0; i < STMMAC_STATS_LEN; i++) {\r\nmemcpy(p, stmmac_gstrings_stats[i].stat_string,\r\nETH_GSTRING_LEN);\r\np += ETH_GSTRING_LEN;\r\n}\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\n}\r\nstatic void stmmac_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nspin_lock_irq(&priv->lock);\r\nif (device_can_wakeup(priv->device)) {\r\nwol->supported = WAKE_MAGIC | WAKE_UCAST;\r\nwol->wolopts = priv->wolopts;\r\n}\r\nspin_unlock_irq(&priv->lock);\r\n}\r\nstatic int stmmac_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nu32 support = WAKE_MAGIC | WAKE_UCAST;\r\nif ((priv->hw_cap_support) && (!priv->dma_cap.pmt_magic_frame))\r\nwol->wolopts &= ~WAKE_MAGIC;\r\nif (!device_can_wakeup(priv->device))\r\nreturn -EINVAL;\r\nif (wol->wolopts & ~support)\r\nreturn -EINVAL;\r\nif (wol->wolopts) {\r\npr_info("stmmac: wakeup enable\n");\r\ndevice_set_wakeup_enable(priv->device, 1);\r\nenable_irq_wake(priv->wol_irq);\r\n} else {\r\ndevice_set_wakeup_enable(priv->device, 0);\r\ndisable_irq_wake(priv->wol_irq);\r\n}\r\nspin_lock_irq(&priv->lock);\r\npriv->wolopts = wol->wolopts;\r\nspin_unlock_irq(&priv->lock);\r\nreturn 0;\r\n}\r\nstatic int stmmac_ethtool_op_get_eee(struct net_device *dev,\r\nstruct ethtool_eee *edata)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nif (!priv->dma_cap.eee)\r\nreturn -EOPNOTSUPP;\r\nedata->eee_enabled = priv->eee_enabled;\r\nedata->eee_active = priv->eee_active;\r\nedata->tx_lpi_timer = priv->tx_lpi_timer;\r\nreturn phy_ethtool_get_eee(priv->phydev, edata);\r\n}\r\nstatic int stmmac_ethtool_op_set_eee(struct net_device *dev,\r\nstruct ethtool_eee *edata)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\npriv->eee_enabled = edata->eee_enabled;\r\nif (!priv->eee_enabled)\r\nstmmac_disable_eee_mode(priv);\r\nelse {\r\npriv->eee_enabled = stmmac_eee_init(priv);\r\nif (!priv->eee_enabled)\r\nreturn -EOPNOTSUPP;\r\npriv->tx_lpi_timer = edata->tx_lpi_timer;\r\n}\r\nreturn phy_ethtool_set_eee(priv->phydev, edata);\r\n}\r\nstatic u32 stmmac_usec2riwt(u32 usec, struct stmmac_priv *priv)\r\n{\r\nunsigned long clk = clk_get_rate(priv->stmmac_clk);\r\nif (!clk)\r\nreturn 0;\r\nreturn (usec * (clk / 1000000)) / 256;\r\n}\r\nstatic u32 stmmac_riwt2usec(u32 riwt, struct stmmac_priv *priv)\r\n{\r\nunsigned long clk = clk_get_rate(priv->stmmac_clk);\r\nif (!clk)\r\nreturn 0;\r\nreturn (riwt * 256) / (clk / 1000000);\r\n}\r\nstatic int stmmac_get_coalesce(struct net_device *dev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nec->tx_coalesce_usecs = priv->tx_coal_timer;\r\nec->tx_max_coalesced_frames = priv->tx_coal_frames;\r\nif (priv->use_riwt)\r\nec->rx_coalesce_usecs = stmmac_riwt2usec(priv->rx_riwt, priv);\r\nreturn 0;\r\n}\r\nstatic int stmmac_set_coalesce(struct net_device *dev,\r\nstruct ethtool_coalesce *ec)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nunsigned int rx_riwt;\r\nif ((ec->rx_max_coalesced_frames) || (ec->rx_coalesce_usecs_irq) ||\r\n(ec->rx_max_coalesced_frames_irq) || (ec->tx_coalesce_usecs_irq) ||\r\n(ec->use_adaptive_rx_coalesce) || (ec->use_adaptive_tx_coalesce) ||\r\n(ec->pkt_rate_low) || (ec->rx_coalesce_usecs_low) ||\r\n(ec->rx_max_coalesced_frames_low) || (ec->tx_coalesce_usecs_high) ||\r\n(ec->tx_max_coalesced_frames_low) || (ec->pkt_rate_high) ||\r\n(ec->tx_coalesce_usecs_low) || (ec->rx_coalesce_usecs_high) ||\r\n(ec->rx_max_coalesced_frames_high) ||\r\n(ec->tx_max_coalesced_frames_irq) ||\r\n(ec->stats_block_coalesce_usecs) ||\r\n(ec->tx_max_coalesced_frames_high) || (ec->rate_sample_interval))\r\nreturn -EOPNOTSUPP;\r\nif (ec->rx_coalesce_usecs == 0)\r\nreturn -EINVAL;\r\nif ((ec->tx_coalesce_usecs == 0) &&\r\n(ec->tx_max_coalesced_frames == 0))\r\nreturn -EINVAL;\r\nif ((ec->tx_coalesce_usecs > STMMAC_COAL_TX_TIMER) ||\r\n(ec->tx_max_coalesced_frames > STMMAC_TX_MAX_FRAMES))\r\nreturn -EINVAL;\r\nrx_riwt = stmmac_usec2riwt(ec->rx_coalesce_usecs, priv);\r\nif ((rx_riwt > MAX_DMA_RIWT) || (rx_riwt < MIN_DMA_RIWT))\r\nreturn -EINVAL;\r\nelse if (!priv->use_riwt)\r\nreturn -EOPNOTSUPP;\r\npriv->tx_coal_frames = ec->tx_max_coalesced_frames;\r\npriv->tx_coal_timer = ec->tx_coalesce_usecs;\r\npriv->rx_riwt = rx_riwt;\r\npriv->hw->dma->rx_watchdog(priv->ioaddr, priv->rx_riwt);\r\nreturn 0;\r\n}\r\nstatic int stmmac_get_ts_info(struct net_device *dev,\r\nstruct ethtool_ts_info *info)\r\n{\r\nstruct stmmac_priv *priv = netdev_priv(dev);\r\nif ((priv->hwts_tx_en) && (priv->hwts_rx_en)) {\r\ninfo->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |\r\nSOF_TIMESTAMPING_RX_HARDWARE |\r\nSOF_TIMESTAMPING_RAW_HARDWARE;\r\nif (priv->ptp_clock)\r\ninfo->phc_index = ptp_clock_index(priv->ptp_clock);\r\ninfo->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);\r\ninfo->rx_filters = ((1 << HWTSTAMP_FILTER_NONE) |\r\n(1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |\r\n(1 << HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_SYNC) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) |\r\n(1 << HWTSTAMP_FILTER_ALL));\r\nreturn 0;\r\n} else\r\nreturn ethtool_op_get_ts_info(dev, info);\r\n}\r\nvoid stmmac_set_ethtool_ops(struct net_device *netdev)\r\n{\r\nSET_ETHTOOL_OPS(netdev, &stmmac_ethtool_ops);\r\n}
