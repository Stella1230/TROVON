static struct bio *get_swap_bio(gfp_t gfp_flags,\r\nstruct page *page, bio_end_io_t end_io)\r\n{\r\nstruct bio *bio;\r\nbio = bio_alloc(gfp_flags, 1);\r\nif (bio) {\r\nbio->bi_sector = map_swap_page(page, &bio->bi_bdev);\r\nbio->bi_sector <<= PAGE_SHIFT - 9;\r\nbio->bi_io_vec[0].bv_page = page;\r\nbio->bi_io_vec[0].bv_len = PAGE_SIZE;\r\nbio->bi_io_vec[0].bv_offset = 0;\r\nbio->bi_vcnt = 1;\r\nbio->bi_size = PAGE_SIZE;\r\nbio->bi_end_io = end_io;\r\n}\r\nreturn bio;\r\n}\r\nvoid end_swap_bio_write(struct bio *bio, int err)\r\n{\r\nconst int uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags);\r\nstruct page *page = bio->bi_io_vec[0].bv_page;\r\nif (!uptodate) {\r\nSetPageError(page);\r\nset_page_dirty(page);\r\nprintk(KERN_ALERT "Write-error on swap-device (%u:%u:%Lu)\n",\r\nimajor(bio->bi_bdev->bd_inode),\r\niminor(bio->bi_bdev->bd_inode),\r\n(unsigned long long)bio->bi_sector);\r\nClearPageReclaim(page);\r\n}\r\nend_page_writeback(page);\r\nbio_put(bio);\r\n}\r\nvoid end_swap_bio_read(struct bio *bio, int err)\r\n{\r\nconst int uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags);\r\nstruct page *page = bio->bi_io_vec[0].bv_page;\r\nif (!uptodate) {\r\nSetPageError(page);\r\nClearPageUptodate(page);\r\nprintk(KERN_ALERT "Read-error on swap-device (%u:%u:%Lu)\n",\r\nimajor(bio->bi_bdev->bd_inode),\r\niminor(bio->bi_bdev->bd_inode),\r\n(unsigned long long)bio->bi_sector);\r\ngoto out;\r\n}\r\nSetPageUptodate(page);\r\nif (likely(PageSwapCache(page))) {\r\nstruct swap_info_struct *sis;\r\nsis = page_swap_info(page);\r\nif (sis->flags & SWP_BLKDEV) {\r\nstruct gendisk *disk = sis->bdev->bd_disk;\r\nif (disk->fops->swap_slot_free_notify) {\r\nswp_entry_t entry;\r\nunsigned long offset;\r\nentry.val = page_private(page);\r\noffset = swp_offset(entry);\r\nSetPageDirty(page);\r\ndisk->fops->swap_slot_free_notify(sis->bdev,\r\noffset);\r\n}\r\n}\r\n}\r\nout:\r\nunlock_page(page);\r\nbio_put(bio);\r\n}\r\nint generic_swapfile_activate(struct swap_info_struct *sis,\r\nstruct file *swap_file,\r\nsector_t *span)\r\n{\r\nstruct address_space *mapping = swap_file->f_mapping;\r\nstruct inode *inode = mapping->host;\r\nunsigned blocks_per_page;\r\nunsigned long page_no;\r\nunsigned blkbits;\r\nsector_t probe_block;\r\nsector_t last_block;\r\nsector_t lowest_block = -1;\r\nsector_t highest_block = 0;\r\nint nr_extents = 0;\r\nint ret;\r\nblkbits = inode->i_blkbits;\r\nblocks_per_page = PAGE_SIZE >> blkbits;\r\nprobe_block = 0;\r\npage_no = 0;\r\nlast_block = i_size_read(inode) >> blkbits;\r\nwhile ((probe_block + blocks_per_page) <= last_block &&\r\npage_no < sis->max) {\r\nunsigned block_in_page;\r\nsector_t first_block;\r\nfirst_block = bmap(inode, probe_block);\r\nif (first_block == 0)\r\ngoto bad_bmap;\r\nif (first_block & (blocks_per_page - 1)) {\r\nprobe_block++;\r\ngoto reprobe;\r\n}\r\nfor (block_in_page = 1; block_in_page < blocks_per_page;\r\nblock_in_page++) {\r\nsector_t block;\r\nblock = bmap(inode, probe_block + block_in_page);\r\nif (block == 0)\r\ngoto bad_bmap;\r\nif (block != first_block + block_in_page) {\r\nprobe_block++;\r\ngoto reprobe;\r\n}\r\n}\r\nfirst_block >>= (PAGE_SHIFT - blkbits);\r\nif (page_no) {\r\nif (first_block < lowest_block)\r\nlowest_block = first_block;\r\nif (first_block > highest_block)\r\nhighest_block = first_block;\r\n}\r\nret = add_swap_extent(sis, page_no, 1, first_block);\r\nif (ret < 0)\r\ngoto out;\r\nnr_extents += ret;\r\npage_no++;\r\nprobe_block += blocks_per_page;\r\nreprobe:\r\ncontinue;\r\n}\r\nret = nr_extents;\r\n*span = 1 + highest_block - lowest_block;\r\nif (page_no == 0)\r\npage_no = 1;\r\nsis->max = page_no;\r\nsis->pages = page_no - 1;\r\nsis->highest_bit = page_no - 1;\r\nout:\r\nreturn ret;\r\nbad_bmap:\r\nprintk(KERN_ERR "swapon: swapfile has holes\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nint swap_writepage(struct page *page, struct writeback_control *wbc)\r\n{\r\nint ret = 0;\r\nif (try_to_free_swap(page)) {\r\nunlock_page(page);\r\ngoto out;\r\n}\r\nif (frontswap_store(page) == 0) {\r\nset_page_writeback(page);\r\nunlock_page(page);\r\nend_page_writeback(page);\r\ngoto out;\r\n}\r\nret = __swap_writepage(page, wbc, end_swap_bio_write);\r\nout:\r\nreturn ret;\r\n}\r\nint __swap_writepage(struct page *page, struct writeback_control *wbc,\r\nvoid (*end_write_func)(struct bio *, int))\r\n{\r\nstruct bio *bio;\r\nint ret = 0, rw = WRITE;\r\nstruct swap_info_struct *sis = page_swap_info(page);\r\nif (sis->flags & SWP_FILE) {\r\nstruct kiocb kiocb;\r\nstruct file *swap_file = sis->swap_file;\r\nstruct address_space *mapping = swap_file->f_mapping;\r\nstruct iovec iov = {\r\n.iov_base = kmap(page),\r\n.iov_len = PAGE_SIZE,\r\n};\r\ninit_sync_kiocb(&kiocb, swap_file);\r\nkiocb.ki_pos = page_file_offset(page);\r\nkiocb.ki_nbytes = PAGE_SIZE;\r\nset_page_writeback(page);\r\nunlock_page(page);\r\nret = mapping->a_ops->direct_IO(KERNEL_WRITE,\r\n&kiocb, &iov,\r\nkiocb.ki_pos, 1);\r\nkunmap(page);\r\nif (ret == PAGE_SIZE) {\r\ncount_vm_event(PSWPOUT);\r\nret = 0;\r\n} else {\r\nset_page_dirty(page);\r\nClearPageReclaim(page);\r\npr_err_ratelimited("Write error on dio swapfile (%Lu)\n",\r\npage_file_offset(page));\r\n}\r\nend_page_writeback(page);\r\nreturn ret;\r\n}\r\nbio = get_swap_bio(GFP_NOIO, page, end_write_func);\r\nif (bio == NULL) {\r\nset_page_dirty(page);\r\nunlock_page(page);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (wbc->sync_mode == WB_SYNC_ALL)\r\nrw |= REQ_SYNC;\r\ncount_vm_event(PSWPOUT);\r\nset_page_writeback(page);\r\nunlock_page(page);\r\nsubmit_bio(rw, bio);\r\nout:\r\nreturn ret;\r\n}\r\nint swap_readpage(struct page *page)\r\n{\r\nstruct bio *bio;\r\nint ret = 0;\r\nstruct swap_info_struct *sis = page_swap_info(page);\r\nVM_BUG_ON(!PageLocked(page));\r\nVM_BUG_ON(PageUptodate(page));\r\nif (frontswap_load(page) == 0) {\r\nSetPageUptodate(page);\r\nunlock_page(page);\r\ngoto out;\r\n}\r\nif (sis->flags & SWP_FILE) {\r\nstruct file *swap_file = sis->swap_file;\r\nstruct address_space *mapping = swap_file->f_mapping;\r\nret = mapping->a_ops->readpage(swap_file, page);\r\nif (!ret)\r\ncount_vm_event(PSWPIN);\r\nreturn ret;\r\n}\r\nbio = get_swap_bio(GFP_KERNEL, page, end_swap_bio_read);\r\nif (bio == NULL) {\r\nunlock_page(page);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ncount_vm_event(PSWPIN);\r\nsubmit_bio(READ, bio);\r\nout:\r\nreturn ret;\r\n}\r\nint swap_set_page_dirty(struct page *page)\r\n{\r\nstruct swap_info_struct *sis = page_swap_info(page);\r\nif (sis->flags & SWP_FILE) {\r\nstruct address_space *mapping = sis->swap_file->f_mapping;\r\nreturn mapping->a_ops->set_page_dirty(page);\r\n} else {\r\nreturn __set_page_dirty_no_writeback(page);\r\n}\r\n}
