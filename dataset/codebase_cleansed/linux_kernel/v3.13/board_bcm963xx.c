int bcm63xx_get_fallback_sprom(struct ssb_bus *bus, struct ssb_sprom *out)\r\n{\r\nif (bus->bustype == SSB_BUSTYPE_PCI) {\r\nmemcpy(out, &bcm63xx_sprom, sizeof(struct ssb_sprom));\r\nreturn 0;\r\n} else {\r\nprintk(KERN_ERR PFX "unable to fill SPROM for given bustype.\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nconst char *board_get_name(void)\r\n{\r\nreturn board.name;\r\n}\r\nvoid __init board_prom_init(void)\r\n{\r\nunsigned int i;\r\nu8 *boot_addr, *cfe;\r\nchar cfe_version[32];\r\nchar *board_name = NULL;\r\nu32 val;\r\nstruct bcm_hcs *hcs;\r\nif (BCMCPU_IS_6328() || BCMCPU_IS_6362()) {\r\nval = 0x18000000;\r\n} else {\r\nval = bcm_mpi_readl(MPI_CSBASE_REG(0));\r\nval &= MPI_CSBASE_BASE_MASK;\r\n}\r\nboot_addr = (u8 *)KSEG1ADDR(val);\r\ncfe = boot_addr + BCM963XX_CFE_VERSION_OFFSET;\r\nif (!memcmp(cfe, "cfe-v", 5))\r\nsnprintf(cfe_version, sizeof(cfe_version), "%u.%u.%u-%u.%u",\r\ncfe[5], cfe[6], cfe[7], cfe[8], cfe[9]);\r\nelse\r\nstrcpy(cfe_version, "unknown");\r\nprintk(KERN_INFO PFX "CFE version: %s\n", cfe_version);\r\nbcm63xx_nvram_init(boot_addr + BCM963XX_NVRAM_OFFSET);\r\nif (BCMCPU_IS_3368()) {\r\nhcs = (struct bcm_hcs *)boot_addr;\r\nboard_name = hcs->filename;\r\n} else {\r\nboard_name = bcm63xx_nvram_get_name();\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(bcm963xx_boards); i++) {\r\nif (strncmp(board_name, bcm963xx_boards[i]->name, 16))\r\ncontinue;\r\nmemcpy(&board, bcm963xx_boards[i], sizeof(board));\r\nbreak;\r\n}\r\nif (!board.name[0]) {\r\nchar name[17];\r\nmemcpy(name, board_name, 16);\r\nname[16] = 0;\r\nprintk(KERN_ERR PFX "unknown bcm963xx board: %s\n",\r\nname);\r\nreturn;\r\n}\r\nval = 0;\r\n#ifdef CONFIG_PCI\r\nif (board.has_pci) {\r\nbcm63xx_pci_enabled = 1;\r\nif (BCMCPU_IS_6348())\r\nval |= GPIO_MODE_6348_G2_PCI;\r\n}\r\n#endif\r\nif (board.has_pccard) {\r\nif (BCMCPU_IS_6348())\r\nval |= GPIO_MODE_6348_G1_MII_PCCARD;\r\n}\r\nif (board.has_enet0 && !board.enet0.use_internal_phy) {\r\nif (BCMCPU_IS_6348())\r\nval |= GPIO_MODE_6348_G3_EXT_MII |\r\nGPIO_MODE_6348_G0_EXT_MII;\r\n}\r\nif (board.has_enet1 && !board.enet1.use_internal_phy) {\r\nif (BCMCPU_IS_6348())\r\nval |= GPIO_MODE_6348_G3_EXT_MII |\r\nGPIO_MODE_6348_G0_EXT_MII;\r\n}\r\nbcm_gpio_writel(val, GPIO_MODE_REG);\r\n}\r\nvoid __init board_setup(void)\r\n{\r\nif (!board.name[0])\r\npanic("unable to detect bcm963xx board");\r\nprintk(KERN_INFO PFX "board name: %s\n", board.name);\r\nif (bcm63xx_get_cpu_id() != board.expected_cpu_id)\r\npanic("unexpected CPU for bcm963xx board");\r\n}\r\nint __init board_register_devices(void)\r\n{\r\nif (board.has_uart0)\r\nbcm63xx_uart_register(0);\r\nif (board.has_uart1)\r\nbcm63xx_uart_register(1);\r\nif (board.has_pccard)\r\nbcm63xx_pcmcia_register();\r\nif (board.has_enet0 &&\r\n!bcm63xx_nvram_get_mac_address(board.enet0.mac_addr))\r\nbcm63xx_enet_register(0, &board.enet0);\r\nif (board.has_enet1 &&\r\n!bcm63xx_nvram_get_mac_address(board.enet1.mac_addr))\r\nbcm63xx_enet_register(1, &board.enet1);\r\nif (board.has_enetsw &&\r\n!bcm63xx_nvram_get_mac_address(board.enetsw.mac_addr))\r\nbcm63xx_enetsw_register(&board.enetsw);\r\nif (board.has_usbd)\r\nbcm63xx_usbd_register(&board.usbd);\r\nif (board.has_dsp)\r\nbcm63xx_dsp_register(&board.dsp);\r\n#ifdef CONFIG_SSB_PCIHOST\r\nif (!bcm63xx_nvram_get_mac_address(bcm63xx_sprom.il0mac)) {\r\nmemcpy(bcm63xx_sprom.et0mac, bcm63xx_sprom.il0mac, ETH_ALEN);\r\nmemcpy(bcm63xx_sprom.et1mac, bcm63xx_sprom.il0mac, ETH_ALEN);\r\nif (ssb_arch_register_fallback_sprom(\r\n&bcm63xx_get_fallback_sprom) < 0)\r\npr_err(PFX "failed to register fallback SPROM\n");\r\n}\r\n#endif\r\nbcm63xx_spi_register();\r\nbcm63xx_flash_register();\r\nbcm63xx_led_data.num_leds = ARRAY_SIZE(board.leds);\r\nbcm63xx_led_data.leds = board.leds;\r\nplatform_device_register(&bcm63xx_gpio_leds);\r\nif (board.ephy_reset_gpio && board.ephy_reset_gpio_flags)\r\ngpio_request_one(board.ephy_reset_gpio,\r\nboard.ephy_reset_gpio_flags, "ephy-reset");\r\nreturn 0;\r\n}
