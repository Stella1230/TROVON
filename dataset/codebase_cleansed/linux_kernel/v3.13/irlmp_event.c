static inline void irlmp_next_lap_state(struct lap_cb *self,\r\nIRLMP_STATE state)\r\n{\r\nself->lap_state = state;\r\n}\r\nstatic inline void irlmp_next_lsap_state(struct lsap_cb *self,\r\nLSAP_STATE state)\r\n{\r\nself->lsap_state = state;\r\n}\r\nint irlmp_do_lsap_event(struct lsap_cb *self, IRLMP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return -1;);\r\nIRDA_DEBUG(4, "%s(), EVENT = %s, STATE = %s\n",\r\n__func__, irlmp_event[event], irlsap_state[ self->lsap_state]);\r\nreturn (*lsap_state[self->lsap_state]) (self, event, skb);\r\n}\r\nvoid irlmp_do_lap_event(struct lap_cb *self, IRLMP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LMP_LAP_MAGIC, return;);\r\nIRDA_DEBUG(4, "%s(), EVENT = %s, STATE = %s\n", __func__,\r\nirlmp_event[event],\r\nirlmp_state[self->lap_state]);\r\n(*lap_state[self->lap_state]) (self, event, skb);\r\n}\r\nvoid irlmp_discovery_timer_expired(void *data)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nirlmp_do_expiry();\r\nirlmp_do_discovery(sysctl_discovery_slots);\r\nirlmp_start_discovery_timer(irlmp, sysctl_discovery_timeout * HZ);\r\n}\r\nvoid irlmp_watchdog_timer_expired(void *data)\r\n{\r\nstruct lsap_cb *self = (struct lsap_cb *) data;\r\nIRDA_DEBUG(2, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return;);\r\nirlmp_do_lsap_event(self, LM_WATCHDOG_TIMEOUT, NULL);\r\n}\r\nvoid irlmp_idle_timer_expired(void *data)\r\n{\r\nstruct lap_cb *self = (struct lap_cb *) data;\r\nIRDA_DEBUG(2, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == LMP_LAP_MAGIC, return;);\r\nirlmp_do_lap_event(self, LM_LAP_IDLE_TIMEOUT, NULL);\r\n}\r\nstatic inline void\r\nirlmp_do_all_lsap_event(hashbin_t * lsap_hashbin,\r\nIRLMP_EVENT event)\r\n{\r\nstruct lsap_cb *lsap;\r\nstruct lsap_cb *lsap_next;\r\nlsap = (struct lsap_cb *) hashbin_get_first(lsap_hashbin);\r\nwhile (NULL != hashbin_find_next(lsap_hashbin,\r\n(long) lsap,\r\nNULL,\r\n(void *) &lsap_next) ) {\r\nirlmp_do_lsap_event(lsap, event, NULL);\r\nlsap = lsap_next;\r\n}\r\n}\r\nstatic void irlmp_state_standby(struct lap_cb *self, IRLMP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self->irlap != NULL, return;);\r\nswitch (event) {\r\ncase LM_LAP_DISCOVERY_REQUEST:\r\nirlap_discovery_request(self->irlap, &irlmp->discovery_cmd);\r\nbreak;\r\ncase LM_LAP_CONNECT_INDICATION:\r\nirlmp_next_lap_state(self, LAP_ACTIVE);\r\nirlap_connect_response(self->irlap, skb);\r\nbreak;\r\ncase LM_LAP_CONNECT_REQUEST:\r\nIRDA_DEBUG(4, "%s() LS_CONNECT_REQUEST\n", __func__);\r\nirlmp_next_lap_state(self, LAP_U_CONNECT);\r\nirlap_connect_request(self->irlap, self->daddr, NULL, 0);\r\nbreak;\r\ncase LM_LAP_DISCONNECT_INDICATION:\r\nIRDA_DEBUG(4, "%s(), Error LM_LAP_DISCONNECT_INDICATION\n",\r\n__func__);\r\nirlmp_next_lap_state(self, LAP_STANDBY);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(0, "%s(), Unknown event %s\n",\r\n__func__, irlmp_event[event]);\r\nbreak;\r\n}\r\n}\r\nstatic void irlmp_state_u_connect(struct lap_cb *self, IRLMP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_DEBUG(2, "%s(), event=%s\n", __func__, irlmp_event[event]);\r\nswitch (event) {\r\ncase LM_LAP_CONNECT_INDICATION:\r\nirlmp_next_lap_state(self, LAP_ACTIVE);\r\nirlap_connect_response(self->irlap, skb);\r\nirlmp_do_all_lsap_event(self->lsaps, LM_LAP_CONNECT_CONFIRM);\r\nif (HASHBIN_GET_SIZE(self->lsaps) == 0) {\r\nIRDA_DEBUG(0, "%s() NO LSAPs !\n", __func__);\r\nirlmp_start_idle_timer(self, LM_IDLE_TIMEOUT);\r\n}\r\nbreak;\r\ncase LM_LAP_CONNECT_REQUEST:\r\nbreak;\r\ncase LM_LAP_CONNECT_CONFIRM:\r\nirlmp_next_lap_state(self, LAP_ACTIVE);\r\nirlmp_do_all_lsap_event(self->lsaps, LM_LAP_CONNECT_CONFIRM);\r\nif (HASHBIN_GET_SIZE(self->lsaps) == 0) {\r\nIRDA_DEBUG(0, "%s() NO LSAPs !\n", __func__);\r\nirlmp_start_idle_timer(self, LM_IDLE_TIMEOUT);\r\n}\r\nbreak;\r\ncase LM_LAP_DISCONNECT_INDICATION:\r\nIRDA_DEBUG(4, "%s(), LM_LAP_DISCONNECT_INDICATION\n", __func__);\r\nirlmp_next_lap_state(self, LAP_STANDBY);\r\nirlmp_do_all_lsap_event(self->lsaps,\r\nLM_LAP_DISCONNECT_INDICATION);\r\nbreak;\r\ncase LM_LAP_DISCONNECT_REQUEST:\r\nIRDA_DEBUG(4, "%s(), LM_LAP_DISCONNECT_REQUEST\n", __func__);\r\nif (HASHBIN_GET_SIZE(self->lsaps) <= 1) {\r\nirlap_disconnect_request(self->irlap);\r\n}\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(0, "%s(), Unknown event %s\n",\r\n__func__, irlmp_event[event]);\r\nbreak;\r\n}\r\n}\r\nstatic void irlmp_state_active(struct lap_cb *self, IRLMP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nswitch (event) {\r\ncase LM_LAP_CONNECT_REQUEST:\r\nIRDA_DEBUG(4, "%s(), LS_CONNECT_REQUEST\n", __func__);\r\nirlap_clear_disconnect(self->irlap);\r\nirlmp_do_all_lsap_event(self->lsaps, LM_LAP_CONNECT_CONFIRM);\r\nirlmp_do_all_lsap_event(irlmp->unconnected_lsaps,\r\nLM_LAP_CONNECT_CONFIRM);\r\nbreak;\r\ncase LM_LAP_DISCONNECT_REQUEST:\r\nif (HASHBIN_GET_SIZE(self->lsaps) > 0) {\r\nirlmp_start_idle_timer(self, sysctl_lap_keepalive_time * HZ / 1000);\r\n} else {\r\nirlap_disconnect_request(self->irlap);\r\n}\r\nbreak;\r\ncase LM_LAP_IDLE_TIMEOUT:\r\nif (HASHBIN_GET_SIZE(self->lsaps) == 0) {\r\nirlap_disconnect_request(self->irlap);\r\n}\r\nbreak;\r\ncase LM_LAP_DISCONNECT_INDICATION:\r\nirlmp_next_lap_state(self, LAP_STANDBY);\r\nirlmp_stop_idle_timer(self);\r\nirlmp_do_all_lsap_event(self->lsaps,\r\nLM_LAP_DISCONNECT_INDICATION);\r\nirlmp_do_expiry();\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(0, "%s(), Unknown event %s\n",\r\n__func__, irlmp_event[event]);\r\nbreak;\r\n}\r\n}\r\nstatic int irlmp_state_disconnected(struct lsap_cb *self, IRLMP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nint ret = 0;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return -1;);\r\nswitch (event) {\r\n#ifdef CONFIG_IRDA_ULTRA\r\ncase LM_UDATA_INDICATION:\r\nirlmp_connless_data_indication(self, skb);\r\nbreak;\r\n#endif\r\ncase LM_CONNECT_REQUEST:\r\nIRDA_DEBUG(4, "%s(), LM_CONNECT_REQUEST\n", __func__);\r\nif (self->conn_skb) {\r\nIRDA_WARNING("%s: busy with another request!\n",\r\n__func__);\r\nreturn -EBUSY;\r\n}\r\nskb_get(skb);\r\nself->conn_skb = skb;\r\nirlmp_next_lsap_state(self, LSAP_SETUP_PEND);\r\nirlmp_start_watchdog_timer(self, 5*HZ);\r\nirlmp_do_lap_event(self->lap, LM_LAP_CONNECT_REQUEST, NULL);\r\nbreak;\r\ncase LM_CONNECT_INDICATION:\r\nif (self->conn_skb) {\r\nIRDA_WARNING("%s: busy with another request!\n",\r\n__func__);\r\nreturn -EBUSY;\r\n}\r\nskb_get(skb);\r\nself->conn_skb = skb;\r\nirlmp_next_lsap_state(self, LSAP_CONNECT_PEND);\r\nirlmp_start_watchdog_timer(self, 1*HZ);\r\nirlmp_do_lap_event(self->lap, LM_LAP_CONNECT_REQUEST, NULL);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(1, "%s(), Unknown event %s on LSAP %#02x\n",\r\n__func__, irlmp_event[event], self->slsap_sel);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int irlmp_state_connect(struct lsap_cb *self, IRLMP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nstruct lsap_cb *lsap;\r\nint ret = 0;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return -1;);\r\nswitch (event) {\r\ncase LM_CONNECT_RESPONSE:\r\nlsap = hashbin_remove(irlmp->unconnected_lsaps, (long) self,\r\nNULL);\r\nIRDA_ASSERT(lsap == self, return -1;);\r\nIRDA_ASSERT(self->lap != NULL, return -1;);\r\nIRDA_ASSERT(self->lap->lsaps != NULL, return -1;);\r\nhashbin_insert(self->lap->lsaps, (irda_queue_t *) self,\r\n(long) self, NULL);\r\nset_bit(0, &self->connected);\r\nirlmp_send_lcf_pdu(self->lap, self->dlsap_sel,\r\nself->slsap_sel, CONNECT_CNF, skb);\r\ndel_timer(&self->watchdog_timer);\r\nirlmp_next_lsap_state(self, LSAP_DATA_TRANSFER_READY);\r\nbreak;\r\ncase LM_WATCHDOG_TIMEOUT:\r\nIRDA_DEBUG(0, "%s() WATCHDOG_TIMEOUT!\n", __func__);\r\nself->lap = NULL;\r\nself->dlsap_sel = LSAP_ANY;\r\nirlmp_next_lsap_state(self, LSAP_DISCONNECTED);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(0, "%s(), Unknown event %s on LSAP %#02x\n",\r\n__func__, irlmp_event[event], self->slsap_sel);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int irlmp_state_connect_pend(struct lsap_cb *self, IRLMP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sk_buff *tx_skb;\r\nint ret = 0;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return -1;);\r\nswitch (event) {\r\ncase LM_CONNECT_REQUEST:\r\nbreak;\r\ncase LM_CONNECT_RESPONSE:\r\nIRDA_DEBUG(0, "%s(), LM_CONNECT_RESPONSE, "\r\n"no indication issued yet\n", __func__);\r\nbreak;\r\ncase LM_DISCONNECT_REQUEST:\r\nIRDA_DEBUG(0, "%s(), LM_DISCONNECT_REQUEST, "\r\n"not yet bound to IrLAP connection\n", __func__);\r\nbreak;\r\ncase LM_LAP_CONNECT_CONFIRM:\r\nIRDA_DEBUG(4, "%s(), LS_CONNECT_CONFIRM\n", __func__);\r\nirlmp_next_lsap_state(self, LSAP_CONNECT);\r\ntx_skb = self->conn_skb;\r\nself->conn_skb = NULL;\r\nirlmp_connect_indication(self, tx_skb);\r\ndev_kfree_skb(tx_skb);\r\nbreak;\r\ncase LM_WATCHDOG_TIMEOUT:\r\nIRDA_DEBUG(0, "%s() WATCHDOG_TIMEOUT!\n", __func__);\r\nself->lap = NULL;\r\nself->dlsap_sel = LSAP_ANY;\r\nif(self->conn_skb)\r\ndev_kfree_skb(self->conn_skb);\r\nself->conn_skb = NULL;\r\nirlmp_next_lsap_state(self, LSAP_DISCONNECTED);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(0, "%s(), Unknown event %s on LSAP %#02x\n",\r\n__func__, irlmp_event[event], self->slsap_sel);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int irlmp_state_dtr(struct lsap_cb *self, IRLMP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nLM_REASON reason;\r\nint ret = 0;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return -1;);\r\nIRDA_ASSERT(self->lap != NULL, return -1;);\r\nswitch (event) {\r\ncase LM_DATA_REQUEST:\r\nirlmp_send_data_pdu(self->lap, self->dlsap_sel,\r\nself->slsap_sel, FALSE, skb);\r\nbreak;\r\ncase LM_DATA_INDICATION:\r\nirlmp_data_indication(self, skb);\r\nbreak;\r\ncase LM_UDATA_REQUEST:\r\nIRDA_ASSERT(skb != NULL, return -1;);\r\nirlmp_send_data_pdu(self->lap, self->dlsap_sel,\r\nself->slsap_sel, TRUE, skb);\r\nbreak;\r\ncase LM_UDATA_INDICATION:\r\nirlmp_udata_indication(self, skb);\r\nbreak;\r\ncase LM_CONNECT_REQUEST:\r\nIRDA_DEBUG(0, "%s(), LM_CONNECT_REQUEST, "\r\n"error, LSAP already connected\n", __func__);\r\nbreak;\r\ncase LM_CONNECT_RESPONSE:\r\nIRDA_DEBUG(0, "%s(), LM_CONNECT_RESPONSE, "\r\n"error, LSAP already connected\n", __func__);\r\nbreak;\r\ncase LM_DISCONNECT_REQUEST:\r\nirlmp_send_lcf_pdu(self->lap, self->dlsap_sel, self->slsap_sel,\r\nDISCONNECT, skb);\r\nirlmp_next_lsap_state(self, LSAP_DISCONNECTED);\r\nif (self->lap) {\r\nIRDA_DEBUG(4, "%s(), trying to close IrLAP\n",\r\n__func__);\r\nirlmp_do_lap_event(self->lap,\r\nLM_LAP_DISCONNECT_REQUEST,\r\nNULL);\r\n}\r\nbreak;\r\ncase LM_LAP_DISCONNECT_INDICATION:\r\nirlmp_next_lsap_state(self, LSAP_DISCONNECTED);\r\nreason = irlmp_convert_lap_reason(self->lap->reason);\r\nirlmp_disconnect_indication(self, reason, NULL);\r\nbreak;\r\ncase LM_DISCONNECT_INDICATION:\r\nirlmp_next_lsap_state(self, LSAP_DISCONNECTED);\r\nIRDA_ASSERT(self->lap != NULL, return -1;);\r\nIRDA_ASSERT(self->lap->magic == LMP_LAP_MAGIC, return -1;);\r\nIRDA_ASSERT(skb != NULL, return -1;);\r\nIRDA_ASSERT(skb->len > 3, return -1;);\r\nreason = skb->data[3];\r\nIRDA_DEBUG(4, "%s(), trying to close IrLAP\n", __func__);\r\nirlmp_do_lap_event(self->lap, LM_LAP_DISCONNECT_REQUEST, NULL);\r\nirlmp_disconnect_indication(self, reason, skb);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(0, "%s(), Unknown event %s on LSAP %#02x\n",\r\n__func__, irlmp_event[event], self->slsap_sel);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int irlmp_state_setup(struct lsap_cb *self, IRLMP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nLM_REASON reason;\r\nint ret = 0;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == LMP_LSAP_MAGIC, return -1;);\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nswitch (event) {\r\ncase LM_CONNECT_CONFIRM:\r\nirlmp_next_lsap_state(self, LSAP_DATA_TRANSFER_READY);\r\ndel_timer(&self->watchdog_timer);\r\nirlmp_connect_confirm(self, skb);\r\nbreak;\r\ncase LM_DISCONNECT_INDICATION:\r\nirlmp_next_lsap_state(self, LSAP_DISCONNECTED);\r\nIRDA_ASSERT(self->lap != NULL, return -1;);\r\nIRDA_ASSERT(self->lap->magic == LMP_LAP_MAGIC, return -1;);\r\nIRDA_ASSERT(skb != NULL, return -1;);\r\nIRDA_ASSERT(skb->len > 3, return -1;);\r\nreason = skb->data[3];\r\nIRDA_DEBUG(4, "%s(), trying to close IrLAP\n", __func__);\r\nirlmp_do_lap_event(self->lap, LM_LAP_DISCONNECT_REQUEST, NULL);\r\nirlmp_disconnect_indication(self, reason, skb);\r\nbreak;\r\ncase LM_LAP_DISCONNECT_INDICATION:\r\nirlmp_next_lsap_state(self, LSAP_DISCONNECTED);\r\ndel_timer(&self->watchdog_timer);\r\nIRDA_ASSERT(self->lap != NULL, return -1;);\r\nIRDA_ASSERT(self->lap->magic == LMP_LAP_MAGIC, return -1;);\r\nreason = irlmp_convert_lap_reason(self->lap->reason);\r\nirlmp_disconnect_indication(self, reason, skb);\r\nbreak;\r\ncase LM_WATCHDOG_TIMEOUT:\r\nIRDA_DEBUG(0, "%s() WATCHDOG_TIMEOUT!\n", __func__);\r\nIRDA_ASSERT(self->lap != NULL, return -1;);\r\nirlmp_do_lap_event(self->lap, LM_LAP_DISCONNECT_REQUEST, NULL);\r\nirlmp_next_lsap_state(self, LSAP_DISCONNECTED);\r\nirlmp_disconnect_indication(self, LM_CONNECT_FAILURE, NULL);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(0, "%s(), Unknown event %s on LSAP %#02x\n",\r\n__func__, irlmp_event[event], self->slsap_sel);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int irlmp_state_setup_pend(struct lsap_cb *self, IRLMP_EVENT event,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sk_buff *tx_skb;\r\nLM_REASON reason;\r\nint ret = 0;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(irlmp != NULL, return -1;);\r\nswitch (event) {\r\ncase LM_LAP_CONNECT_CONFIRM:\r\nIRDA_ASSERT(self->conn_skb != NULL, return -1;);\r\ntx_skb = self->conn_skb;\r\nself->conn_skb = NULL;\r\nirlmp_send_lcf_pdu(self->lap, self->dlsap_sel,\r\nself->slsap_sel, CONNECT_CMD, tx_skb);\r\ndev_kfree_skb(tx_skb);\r\nirlmp_next_lsap_state(self, LSAP_SETUP);\r\nbreak;\r\ncase LM_WATCHDOG_TIMEOUT:\r\nIRDA_DEBUG(0, "%s() : WATCHDOG_TIMEOUT !\n", __func__);\r\nIRDA_ASSERT(self->lap != NULL, return -1;);\r\nirlmp_do_lap_event(self->lap, LM_LAP_DISCONNECT_REQUEST, NULL);\r\nirlmp_next_lsap_state(self, LSAP_DISCONNECTED);\r\nirlmp_disconnect_indication(self, LM_CONNECT_FAILURE, NULL);\r\nbreak;\r\ncase LM_LAP_DISCONNECT_INDICATION:\r\ndel_timer( &self->watchdog_timer);\r\nirlmp_next_lsap_state(self, LSAP_DISCONNECTED);\r\nreason = irlmp_convert_lap_reason(self->lap->reason);\r\nirlmp_disconnect_indication(self, reason, NULL);\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(0, "%s(), Unknown event %s on LSAP %#02x\n",\r\n__func__, irlmp_event[event], self->slsap_sel);\r\nbreak;\r\n}\r\nreturn ret;\r\n}
