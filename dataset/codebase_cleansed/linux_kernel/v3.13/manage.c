static u8 e1000_calculate_checksum(u8 *buffer, u32 length)\r\n{\r\nu32 i;\r\nu8 sum = 0;\r\nif (!buffer)\r\nreturn 0;\r\nfor (i = 0; i < length; i++)\r\nsum += buffer[i];\r\nreturn (u8)(0 - sum);\r\n}\r\nstatic s32 e1000_mng_enable_host_if(struct e1000_hw *hw)\r\n{\r\nu32 hicr;\r\nu8 i;\r\nif (!hw->mac.arc_subsystem_valid) {\r\ne_dbg("ARC subsystem not valid.\n");\r\nreturn -E1000_ERR_HOST_INTERFACE_COMMAND;\r\n}\r\nhicr = er32(HICR);\r\nif (!(hicr & E1000_HICR_EN)) {\r\ne_dbg("E1000_HOST_EN bit disabled.\n");\r\nreturn -E1000_ERR_HOST_INTERFACE_COMMAND;\r\n}\r\nfor (i = 0; i < E1000_MNG_DHCP_COMMAND_TIMEOUT; i++) {\r\nhicr = er32(HICR);\r\nif (!(hicr & E1000_HICR_C))\r\nbreak;\r\nmdelay(1);\r\n}\r\nif (i == E1000_MNG_DHCP_COMMAND_TIMEOUT) {\r\ne_dbg("Previous command timeout failed .\n");\r\nreturn -E1000_ERR_HOST_INTERFACE_COMMAND;\r\n}\r\nreturn 0;\r\n}\r\nbool e1000e_check_mng_mode_generic(struct e1000_hw *hw)\r\n{\r\nu32 fwsm = er32(FWSM);\r\nreturn (fwsm & E1000_FWSM_MODE_MASK) ==\r\n(E1000_MNG_IAMT_MODE << E1000_FWSM_MODE_SHIFT);\r\n}\r\nbool e1000e_enable_tx_pkt_filtering(struct e1000_hw *hw)\r\n{\r\nstruct e1000_host_mng_dhcp_cookie *hdr = &hw->mng_cookie;\r\nu32 *buffer = (u32 *)&hw->mng_cookie;\r\nu32 offset;\r\ns32 ret_val, hdr_csum, csum;\r\nu8 i, len;\r\nhw->mac.tx_pkt_filtering = true;\r\nif (!hw->mac.ops.check_mng_mode(hw)) {\r\nhw->mac.tx_pkt_filtering = false;\r\nreturn hw->mac.tx_pkt_filtering;\r\n}\r\nret_val = e1000_mng_enable_host_if(hw);\r\nif (ret_val) {\r\nhw->mac.tx_pkt_filtering = false;\r\nreturn hw->mac.tx_pkt_filtering;\r\n}\r\nlen = E1000_MNG_DHCP_COOKIE_LENGTH >> 2;\r\noffset = E1000_MNG_DHCP_COOKIE_OFFSET >> 2;\r\nfor (i = 0; i < len; i++)\r\n*(buffer + i) = E1000_READ_REG_ARRAY(hw, E1000_HOST_IF,\r\noffset + i);\r\nhdr_csum = hdr->checksum;\r\nhdr->checksum = 0;\r\ncsum = e1000_calculate_checksum((u8 *)hdr,\r\nE1000_MNG_DHCP_COOKIE_LENGTH);\r\nif ((hdr_csum != csum) || (hdr->signature != E1000_IAMT_SIGNATURE)) {\r\nhw->mac.tx_pkt_filtering = true;\r\nreturn hw->mac.tx_pkt_filtering;\r\n}\r\nif (!(hdr->status & E1000_MNG_DHCP_COOKIE_STATUS_PARSING))\r\nhw->mac.tx_pkt_filtering = false;\r\nreturn hw->mac.tx_pkt_filtering;\r\n}\r\nstatic s32 e1000_mng_write_cmd_header(struct e1000_hw *hw,\r\nstruct e1000_host_mng_command_header *hdr)\r\n{\r\nu16 i, length = sizeof(struct e1000_host_mng_command_header);\r\nhdr->checksum = e1000_calculate_checksum((u8 *)hdr, length);\r\nlength >>= 2;\r\nfor (i = 0; i < length; i++) {\r\nE1000_WRITE_REG_ARRAY(hw, E1000_HOST_IF, i, *((u32 *)hdr + i));\r\ne1e_flush();\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 e1000_mng_host_if_write(struct e1000_hw *hw, u8 *buffer,\r\nu16 length, u16 offset, u8 *sum)\r\n{\r\nu8 *tmp;\r\nu8 *bufptr = buffer;\r\nu32 data = 0;\r\nu16 remaining, i, j, prev_bytes;\r\nif (length == 0 || offset + length > E1000_HI_MAX_MNG_DATA_LENGTH)\r\nreturn -E1000_ERR_PARAM;\r\ntmp = (u8 *)&data;\r\nprev_bytes = offset & 0x3;\r\noffset >>= 2;\r\nif (prev_bytes) {\r\ndata = E1000_READ_REG_ARRAY(hw, E1000_HOST_IF, offset);\r\nfor (j = prev_bytes; j < sizeof(u32); j++) {\r\n*(tmp + j) = *bufptr++;\r\n*sum += *(tmp + j);\r\n}\r\nE1000_WRITE_REG_ARRAY(hw, E1000_HOST_IF, offset, data);\r\nlength -= j - prev_bytes;\r\noffset++;\r\n}\r\nremaining = length & 0x3;\r\nlength -= remaining;\r\nlength >>= 2;\r\nfor (i = 0; i < length; i++) {\r\nfor (j = 0; j < sizeof(u32); j++) {\r\n*(tmp + j) = *bufptr++;\r\n*sum += *(tmp + j);\r\n}\r\nE1000_WRITE_REG_ARRAY(hw, E1000_HOST_IF, offset + i, data);\r\n}\r\nif (remaining) {\r\nfor (j = 0; j < sizeof(u32); j++) {\r\nif (j < remaining)\r\n*(tmp + j) = *bufptr++;\r\nelse\r\n*(tmp + j) = 0;\r\n*sum += *(tmp + j);\r\n}\r\nE1000_WRITE_REG_ARRAY(hw, E1000_HOST_IF, offset + i, data);\r\n}\r\nreturn 0;\r\n}\r\ns32 e1000e_mng_write_dhcp_info(struct e1000_hw *hw, u8 *buffer, u16 length)\r\n{\r\nstruct e1000_host_mng_command_header hdr;\r\ns32 ret_val;\r\nu32 hicr;\r\nhdr.command_id = E1000_MNG_DHCP_TX_PAYLOAD_CMD;\r\nhdr.command_length = length;\r\nhdr.reserved1 = 0;\r\nhdr.reserved2 = 0;\r\nhdr.checksum = 0;\r\nret_val = e1000_mng_enable_host_if(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_mng_host_if_write(hw, buffer, length,\r\nsizeof(hdr), &(hdr.checksum));\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = e1000_mng_write_cmd_header(hw, &hdr);\r\nif (ret_val)\r\nreturn ret_val;\r\nhicr = er32(HICR);\r\new32(HICR, hicr | E1000_HICR_C);\r\nreturn 0;\r\n}\r\nbool e1000e_enable_mng_pass_thru(struct e1000_hw *hw)\r\n{\r\nu32 manc;\r\nu32 fwsm, factps;\r\nmanc = er32(MANC);\r\nif (!(manc & E1000_MANC_RCV_TCO_EN))\r\nreturn false;\r\nif (hw->mac.has_fwsm) {\r\nfwsm = er32(FWSM);\r\nfactps = er32(FACTPS);\r\nif (!(factps & E1000_FACTPS_MNGCG) &&\r\n((fwsm & E1000_FWSM_MODE_MASK) ==\r\n(e1000_mng_mode_pt << E1000_FWSM_MODE_SHIFT)))\r\nreturn true;\r\n} else if ((hw->mac.type == e1000_82574) ||\r\n(hw->mac.type == e1000_82583)) {\r\nu16 data;\r\nfactps = er32(FACTPS);\r\ne1000_read_nvm(hw, NVM_INIT_CONTROL2_REG, 1, &data);\r\nif (!(factps & E1000_FACTPS_MNGCG) &&\r\n((data & E1000_NVM_INIT_CTRL2_MNGM) ==\r\n(e1000_mng_mode_pt << 13)))\r\nreturn true;\r\n} else if ((manc & E1000_MANC_SMBUS_EN) &&\r\n!(manc & E1000_MANC_ASF_EN)) {\r\nreturn true;\r\n}\r\nreturn false;\r\n}
