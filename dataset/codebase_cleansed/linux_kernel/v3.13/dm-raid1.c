static void wakeup_mirrord(void *context)\r\n{\r\nstruct mirror_set *ms = context;\r\nqueue_work(ms->kmirrord_wq, &ms->kmirrord_work);\r\n}\r\nstatic void delayed_wake_fn(unsigned long data)\r\n{\r\nstruct mirror_set *ms = (struct mirror_set *) data;\r\nclear_bit(0, &ms->timer_pending);\r\nwakeup_mirrord(ms);\r\n}\r\nstatic void delayed_wake(struct mirror_set *ms)\r\n{\r\nif (test_and_set_bit(0, &ms->timer_pending))\r\nreturn;\r\nms->timer.expires = jiffies + HZ / 5;\r\nms->timer.data = (unsigned long) ms;\r\nms->timer.function = delayed_wake_fn;\r\nadd_timer(&ms->timer);\r\n}\r\nstatic void wakeup_all_recovery_waiters(void *context)\r\n{\r\nwake_up_all(&_kmirrord_recovery_stopped);\r\n}\r\nstatic void queue_bio(struct mirror_set *ms, struct bio *bio, int rw)\r\n{\r\nunsigned long flags;\r\nint should_wake = 0;\r\nstruct bio_list *bl;\r\nbl = (rw == WRITE) ? &ms->writes : &ms->reads;\r\nspin_lock_irqsave(&ms->lock, flags);\r\nshould_wake = !(bl->head);\r\nbio_list_add(bl, bio);\r\nspin_unlock_irqrestore(&ms->lock, flags);\r\nif (should_wake)\r\nwakeup_mirrord(ms);\r\n}\r\nstatic void dispatch_bios(void *context, struct bio_list *bio_list)\r\n{\r\nstruct mirror_set *ms = context;\r\nstruct bio *bio;\r\nwhile ((bio = bio_list_pop(bio_list)))\r\nqueue_bio(ms, bio, WRITE);\r\n}\r\nstatic struct mirror *bio_get_m(struct bio *bio)\r\n{\r\nreturn (struct mirror *) bio->bi_next;\r\n}\r\nstatic void bio_set_m(struct bio *bio, struct mirror *m)\r\n{\r\nbio->bi_next = (struct bio *) m;\r\n}\r\nstatic struct mirror *get_default_mirror(struct mirror_set *ms)\r\n{\r\nreturn &ms->mirror[atomic_read(&ms->default_mirror)];\r\n}\r\nstatic void set_default_mirror(struct mirror *m)\r\n{\r\nstruct mirror_set *ms = m->ms;\r\nstruct mirror *m0 = &(ms->mirror[0]);\r\natomic_set(&ms->default_mirror, m - m0);\r\n}\r\nstatic struct mirror *get_valid_mirror(struct mirror_set *ms)\r\n{\r\nstruct mirror *m;\r\nfor (m = ms->mirror; m < ms->mirror + ms->nr_mirrors; m++)\r\nif (!atomic_read(&m->error_count))\r\nreturn m;\r\nreturn NULL;\r\n}\r\nstatic void fail_mirror(struct mirror *m, enum dm_raid1_error error_type)\r\n{\r\nstruct mirror_set *ms = m->ms;\r\nstruct mirror *new;\r\nms->leg_failure = 1;\r\natomic_inc(&m->error_count);\r\nif (test_and_set_bit(error_type, &m->error_type))\r\nreturn;\r\nif (!errors_handled(ms))\r\nreturn;\r\nif (m != get_default_mirror(ms))\r\ngoto out;\r\nif (!ms->in_sync) {\r\nDMERR("Primary mirror (%s) failed while out-of-sync: "\r\n"Reads may fail.", m->dev->name);\r\ngoto out;\r\n}\r\nnew = get_valid_mirror(ms);\r\nif (new)\r\nset_default_mirror(new);\r\nelse\r\nDMWARN("All sides of mirror have failed.");\r\nout:\r\nschedule_work(&ms->trigger_event);\r\n}\r\nstatic int mirror_flush(struct dm_target *ti)\r\n{\r\nstruct mirror_set *ms = ti->private;\r\nunsigned long error_bits;\r\nunsigned int i;\r\nstruct dm_io_region io[ms->nr_mirrors];\r\nstruct mirror *m;\r\nstruct dm_io_request io_req = {\r\n.bi_rw = WRITE_FLUSH,\r\n.mem.type = DM_IO_KMEM,\r\n.mem.ptr.addr = NULL,\r\n.client = ms->io_client,\r\n};\r\nfor (i = 0, m = ms->mirror; i < ms->nr_mirrors; i++, m++) {\r\nio[i].bdev = m->dev->bdev;\r\nio[i].sector = 0;\r\nio[i].count = 0;\r\n}\r\nerror_bits = -1;\r\ndm_io(&io_req, ms->nr_mirrors, io, &error_bits);\r\nif (unlikely(error_bits != 0)) {\r\nfor (i = 0; i < ms->nr_mirrors; i++)\r\nif (test_bit(i, &error_bits))\r\nfail_mirror(ms->mirror + i,\r\nDM_RAID1_FLUSH_ERROR);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void recovery_complete(int read_err, unsigned long write_err,\r\nvoid *context)\r\n{\r\nstruct dm_region *reg = context;\r\nstruct mirror_set *ms = dm_rh_region_context(reg);\r\nint m, bit = 0;\r\nif (read_err) {\r\nDMERR_LIMIT("Unable to read primary mirror during recovery");\r\nfail_mirror(get_default_mirror(ms), DM_RAID1_SYNC_ERROR);\r\n}\r\nif (write_err) {\r\nDMERR_LIMIT("Write error during recovery (error = 0x%lx)",\r\nwrite_err);\r\nfor (m = 0; m < ms->nr_mirrors; m++) {\r\nif (&ms->mirror[m] == get_default_mirror(ms))\r\ncontinue;\r\nif (test_bit(bit, &write_err))\r\nfail_mirror(ms->mirror + m,\r\nDM_RAID1_SYNC_ERROR);\r\nbit++;\r\n}\r\n}\r\ndm_rh_recovery_end(reg, !(read_err || write_err));\r\n}\r\nstatic int recover(struct mirror_set *ms, struct dm_region *reg)\r\n{\r\nint r;\r\nunsigned i;\r\nstruct dm_io_region from, to[DM_KCOPYD_MAX_REGIONS], *dest;\r\nstruct mirror *m;\r\nunsigned long flags = 0;\r\nregion_t key = dm_rh_get_region_key(reg);\r\nsector_t region_size = dm_rh_get_region_size(ms->rh);\r\nm = get_default_mirror(ms);\r\nfrom.bdev = m->dev->bdev;\r\nfrom.sector = m->offset + dm_rh_region_to_sector(ms->rh, key);\r\nif (key == (ms->nr_regions - 1)) {\r\nfrom.count = ms->ti->len & (region_size - 1);\r\nif (!from.count)\r\nfrom.count = region_size;\r\n} else\r\nfrom.count = region_size;\r\nfor (i = 0, dest = to; i < ms->nr_mirrors; i++) {\r\nif (&ms->mirror[i] == get_default_mirror(ms))\r\ncontinue;\r\nm = ms->mirror + i;\r\ndest->bdev = m->dev->bdev;\r\ndest->sector = m->offset + dm_rh_region_to_sector(ms->rh, key);\r\ndest->count = from.count;\r\ndest++;\r\n}\r\nif (!errors_handled(ms))\r\nset_bit(DM_KCOPYD_IGNORE_ERROR, &flags);\r\nr = dm_kcopyd_copy(ms->kcopyd_client, &from, ms->nr_mirrors - 1, to,\r\nflags, recovery_complete, reg);\r\nreturn r;\r\n}\r\nstatic void do_recovery(struct mirror_set *ms)\r\n{\r\nstruct dm_region *reg;\r\nstruct dm_dirty_log *log = dm_rh_dirty_log(ms->rh);\r\nint r;\r\ndm_rh_recovery_prepare(ms->rh);\r\nwhile ((reg = dm_rh_recovery_start(ms->rh))) {\r\nr = recover(ms, reg);\r\nif (r)\r\ndm_rh_recovery_end(reg, 0);\r\n}\r\nif (!ms->in_sync &&\r\n(log->type->get_sync_count(log) == ms->nr_regions)) {\r\ndm_table_event(ms->ti->table);\r\nms->in_sync = 1;\r\n}\r\n}\r\nstatic struct mirror *choose_mirror(struct mirror_set *ms, sector_t sector)\r\n{\r\nstruct mirror *m = get_default_mirror(ms);\r\ndo {\r\nif (likely(!atomic_read(&m->error_count)))\r\nreturn m;\r\nif (m-- == ms->mirror)\r\nm += ms->nr_mirrors;\r\n} while (m != get_default_mirror(ms));\r\nreturn NULL;\r\n}\r\nstatic int default_ok(struct mirror *m)\r\n{\r\nstruct mirror *default_mirror = get_default_mirror(m->ms);\r\nreturn !atomic_read(&default_mirror->error_count);\r\n}\r\nstatic int mirror_available(struct mirror_set *ms, struct bio *bio)\r\n{\r\nstruct dm_dirty_log *log = dm_rh_dirty_log(ms->rh);\r\nregion_t region = dm_rh_bio_to_region(ms->rh, bio);\r\nif (log->type->in_sync(log, region, 0))\r\nreturn choose_mirror(ms, bio->bi_sector) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic sector_t map_sector(struct mirror *m, struct bio *bio)\r\n{\r\nif (unlikely(!bio->bi_size))\r\nreturn 0;\r\nreturn m->offset + dm_target_offset(m->ms->ti, bio->bi_sector);\r\n}\r\nstatic void map_bio(struct mirror *m, struct bio *bio)\r\n{\r\nbio->bi_bdev = m->dev->bdev;\r\nbio->bi_sector = map_sector(m, bio);\r\n}\r\nstatic void map_region(struct dm_io_region *io, struct mirror *m,\r\nstruct bio *bio)\r\n{\r\nio->bdev = m->dev->bdev;\r\nio->sector = map_sector(m, bio);\r\nio->count = bio_sectors(bio);\r\n}\r\nstatic void hold_bio(struct mirror_set *ms, struct bio *bio)\r\n{\r\nspin_lock_irq(&ms->lock);\r\nif (atomic_read(&ms->suspend)) {\r\nspin_unlock_irq(&ms->lock);\r\nif (dm_noflush_suspending(ms->ti))\r\nbio_endio(bio, DM_ENDIO_REQUEUE);\r\nelse\r\nbio_endio(bio, -EIO);\r\nreturn;\r\n}\r\nbio_list_add(&ms->holds, bio);\r\nspin_unlock_irq(&ms->lock);\r\n}\r\nstatic void read_callback(unsigned long error, void *context)\r\n{\r\nstruct bio *bio = context;\r\nstruct mirror *m;\r\nm = bio_get_m(bio);\r\nbio_set_m(bio, NULL);\r\nif (likely(!error)) {\r\nbio_endio(bio, 0);\r\nreturn;\r\n}\r\nfail_mirror(m, DM_RAID1_READ_ERROR);\r\nif (likely(default_ok(m)) || mirror_available(m->ms, bio)) {\r\nDMWARN_LIMIT("Read failure on mirror device %s. "\r\n"Trying alternative device.",\r\nm->dev->name);\r\nqueue_bio(m->ms, bio, bio_rw(bio));\r\nreturn;\r\n}\r\nDMERR_LIMIT("Read failure on mirror device %s. Failing I/O.",\r\nm->dev->name);\r\nbio_endio(bio, -EIO);\r\n}\r\nstatic void read_async_bio(struct mirror *m, struct bio *bio)\r\n{\r\nstruct dm_io_region io;\r\nstruct dm_io_request io_req = {\r\n.bi_rw = READ,\r\n.mem.type = DM_IO_BVEC,\r\n.mem.ptr.bvec = bio->bi_io_vec + bio->bi_idx,\r\n.notify.fn = read_callback,\r\n.notify.context = bio,\r\n.client = m->ms->io_client,\r\n};\r\nmap_region(&io, m, bio);\r\nbio_set_m(bio, m);\r\nBUG_ON(dm_io(&io_req, 1, &io, NULL));\r\n}\r\nstatic inline int region_in_sync(struct mirror_set *ms, region_t region,\r\nint may_block)\r\n{\r\nint state = dm_rh_get_state(ms->rh, region, may_block);\r\nreturn state == DM_RH_CLEAN || state == DM_RH_DIRTY;\r\n}\r\nstatic void do_reads(struct mirror_set *ms, struct bio_list *reads)\r\n{\r\nregion_t region;\r\nstruct bio *bio;\r\nstruct mirror *m;\r\nwhile ((bio = bio_list_pop(reads))) {\r\nregion = dm_rh_bio_to_region(ms->rh, bio);\r\nm = get_default_mirror(ms);\r\nif (likely(region_in_sync(ms, region, 1)))\r\nm = choose_mirror(ms, bio->bi_sector);\r\nelse if (m && atomic_read(&m->error_count))\r\nm = NULL;\r\nif (likely(m))\r\nread_async_bio(m, bio);\r\nelse\r\nbio_endio(bio, -EIO);\r\n}\r\n}\r\nstatic void write_callback(unsigned long error, void *context)\r\n{\r\nunsigned i, ret = 0;\r\nstruct bio *bio = (struct bio *) context;\r\nstruct mirror_set *ms;\r\nint should_wake = 0;\r\nunsigned long flags;\r\nms = bio_get_m(bio)->ms;\r\nbio_set_m(bio, NULL);\r\nif (likely(!error)) {\r\nbio_endio(bio, ret);\r\nreturn;\r\n}\r\nfor (i = 0; i < ms->nr_mirrors; i++)\r\nif (test_bit(i, &error))\r\nfail_mirror(ms->mirror + i, DM_RAID1_WRITE_ERROR);\r\nspin_lock_irqsave(&ms->lock, flags);\r\nif (!ms->failures.head)\r\nshould_wake = 1;\r\nbio_list_add(&ms->failures, bio);\r\nspin_unlock_irqrestore(&ms->lock, flags);\r\nif (should_wake)\r\nwakeup_mirrord(ms);\r\n}\r\nstatic void do_write(struct mirror_set *ms, struct bio *bio)\r\n{\r\nunsigned int i;\r\nstruct dm_io_region io[ms->nr_mirrors], *dest = io;\r\nstruct mirror *m;\r\nstruct dm_io_request io_req = {\r\n.bi_rw = WRITE | (bio->bi_rw & WRITE_FLUSH_FUA),\r\n.mem.type = DM_IO_BVEC,\r\n.mem.ptr.bvec = bio->bi_io_vec + bio->bi_idx,\r\n.notify.fn = write_callback,\r\n.notify.context = bio,\r\n.client = ms->io_client,\r\n};\r\nif (bio->bi_rw & REQ_DISCARD) {\r\nio_req.bi_rw |= REQ_DISCARD;\r\nio_req.mem.type = DM_IO_KMEM;\r\nio_req.mem.ptr.addr = NULL;\r\n}\r\nfor (i = 0, m = ms->mirror; i < ms->nr_mirrors; i++, m++)\r\nmap_region(dest++, m, bio);\r\nbio_set_m(bio, get_default_mirror(ms));\r\nBUG_ON(dm_io(&io_req, ms->nr_mirrors, io, NULL));\r\n}\r\nstatic void do_writes(struct mirror_set *ms, struct bio_list *writes)\r\n{\r\nint state;\r\nstruct bio *bio;\r\nstruct bio_list sync, nosync, recover, *this_list = NULL;\r\nstruct bio_list requeue;\r\nstruct dm_dirty_log *log = dm_rh_dirty_log(ms->rh);\r\nregion_t region;\r\nif (!writes->head)\r\nreturn;\r\nbio_list_init(&sync);\r\nbio_list_init(&nosync);\r\nbio_list_init(&recover);\r\nbio_list_init(&requeue);\r\nwhile ((bio = bio_list_pop(writes))) {\r\nif ((bio->bi_rw & REQ_FLUSH) ||\r\n(bio->bi_rw & REQ_DISCARD)) {\r\nbio_list_add(&sync, bio);\r\ncontinue;\r\n}\r\nregion = dm_rh_bio_to_region(ms->rh, bio);\r\nif (log->type->is_remote_recovering &&\r\nlog->type->is_remote_recovering(log, region)) {\r\nbio_list_add(&requeue, bio);\r\ncontinue;\r\n}\r\nstate = dm_rh_get_state(ms->rh, region, 1);\r\nswitch (state) {\r\ncase DM_RH_CLEAN:\r\ncase DM_RH_DIRTY:\r\nthis_list = &sync;\r\nbreak;\r\ncase DM_RH_NOSYNC:\r\nthis_list = &nosync;\r\nbreak;\r\ncase DM_RH_RECOVERING:\r\nthis_list = &recover;\r\nbreak;\r\n}\r\nbio_list_add(this_list, bio);\r\n}\r\nif (unlikely(requeue.head)) {\r\nspin_lock_irq(&ms->lock);\r\nbio_list_merge(&ms->writes, &requeue);\r\nspin_unlock_irq(&ms->lock);\r\ndelayed_wake(ms);\r\n}\r\ndm_rh_inc_pending(ms->rh, &sync);\r\ndm_rh_inc_pending(ms->rh, &nosync);\r\nms->log_failure = dm_rh_flush(ms->rh) ? 1 : ms->log_failure;\r\nif (unlikely(ms->log_failure) && errors_handled(ms)) {\r\nspin_lock_irq(&ms->lock);\r\nbio_list_merge(&ms->failures, &sync);\r\nspin_unlock_irq(&ms->lock);\r\nwakeup_mirrord(ms);\r\n} else\r\nwhile ((bio = bio_list_pop(&sync)))\r\ndo_write(ms, bio);\r\nwhile ((bio = bio_list_pop(&recover)))\r\ndm_rh_delay(ms->rh, bio);\r\nwhile ((bio = bio_list_pop(&nosync))) {\r\nif (unlikely(ms->leg_failure) && errors_handled(ms)) {\r\nspin_lock_irq(&ms->lock);\r\nbio_list_add(&ms->failures, bio);\r\nspin_unlock_irq(&ms->lock);\r\nwakeup_mirrord(ms);\r\n} else {\r\nmap_bio(get_default_mirror(ms), bio);\r\ngeneric_make_request(bio);\r\n}\r\n}\r\n}\r\nstatic void do_failures(struct mirror_set *ms, struct bio_list *failures)\r\n{\r\nstruct bio *bio;\r\nif (likely(!failures->head))\r\nreturn;\r\nwhile ((bio = bio_list_pop(failures))) {\r\nif (!ms->log_failure) {\r\nms->in_sync = 0;\r\ndm_rh_mark_nosync(ms->rh, bio);\r\n}\r\nif (!get_valid_mirror(ms))\r\nbio_endio(bio, -EIO);\r\nelse if (errors_handled(ms))\r\nhold_bio(ms, bio);\r\nelse\r\nbio_endio(bio, 0);\r\n}\r\n}\r\nstatic void trigger_event(struct work_struct *work)\r\n{\r\nstruct mirror_set *ms =\r\ncontainer_of(work, struct mirror_set, trigger_event);\r\ndm_table_event(ms->ti->table);\r\n}\r\nstatic void do_mirror(struct work_struct *work)\r\n{\r\nstruct mirror_set *ms = container_of(work, struct mirror_set,\r\nkmirrord_work);\r\nstruct bio_list reads, writes, failures;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ms->lock, flags);\r\nreads = ms->reads;\r\nwrites = ms->writes;\r\nfailures = ms->failures;\r\nbio_list_init(&ms->reads);\r\nbio_list_init(&ms->writes);\r\nbio_list_init(&ms->failures);\r\nspin_unlock_irqrestore(&ms->lock, flags);\r\ndm_rh_update_states(ms->rh, errors_handled(ms));\r\ndo_recovery(ms);\r\ndo_reads(ms, &reads);\r\ndo_writes(ms, &writes);\r\ndo_failures(ms, &failures);\r\n}\r\nstatic struct mirror_set *alloc_context(unsigned int nr_mirrors,\r\nuint32_t region_size,\r\nstruct dm_target *ti,\r\nstruct dm_dirty_log *dl)\r\n{\r\nsize_t len;\r\nstruct mirror_set *ms = NULL;\r\nlen = sizeof(*ms) + (sizeof(ms->mirror[0]) * nr_mirrors);\r\nms = kzalloc(len, GFP_KERNEL);\r\nif (!ms) {\r\nti->error = "Cannot allocate mirror context";\r\nreturn NULL;\r\n}\r\nspin_lock_init(&ms->lock);\r\nbio_list_init(&ms->reads);\r\nbio_list_init(&ms->writes);\r\nbio_list_init(&ms->failures);\r\nbio_list_init(&ms->holds);\r\nms->ti = ti;\r\nms->nr_mirrors = nr_mirrors;\r\nms->nr_regions = dm_sector_div_up(ti->len, region_size);\r\nms->in_sync = 0;\r\nms->log_failure = 0;\r\nms->leg_failure = 0;\r\natomic_set(&ms->suspend, 0);\r\natomic_set(&ms->default_mirror, DEFAULT_MIRROR);\r\nms->io_client = dm_io_client_create();\r\nif (IS_ERR(ms->io_client)) {\r\nti->error = "Error creating dm_io client";\r\nkfree(ms);\r\nreturn NULL;\r\n}\r\nms->rh = dm_region_hash_create(ms, dispatch_bios, wakeup_mirrord,\r\nwakeup_all_recovery_waiters,\r\nms->ti->begin, MAX_RECOVERY,\r\ndl, region_size, ms->nr_regions);\r\nif (IS_ERR(ms->rh)) {\r\nti->error = "Error creating dirty region hash";\r\ndm_io_client_destroy(ms->io_client);\r\nkfree(ms);\r\nreturn NULL;\r\n}\r\nreturn ms;\r\n}\r\nstatic void free_context(struct mirror_set *ms, struct dm_target *ti,\r\nunsigned int m)\r\n{\r\nwhile (m--)\r\ndm_put_device(ti, ms->mirror[m].dev);\r\ndm_io_client_destroy(ms->io_client);\r\ndm_region_hash_destroy(ms->rh);\r\nkfree(ms);\r\n}\r\nstatic int get_mirror(struct mirror_set *ms, struct dm_target *ti,\r\nunsigned int mirror, char **argv)\r\n{\r\nunsigned long long offset;\r\nchar dummy;\r\nif (sscanf(argv[1], "%llu%c", &offset, &dummy) != 1) {\r\nti->error = "Invalid offset";\r\nreturn -EINVAL;\r\n}\r\nif (dm_get_device(ti, argv[0], dm_table_get_mode(ti->table),\r\n&ms->mirror[mirror].dev)) {\r\nti->error = "Device lookup failure";\r\nreturn -ENXIO;\r\n}\r\nms->mirror[mirror].ms = ms;\r\natomic_set(&(ms->mirror[mirror].error_count), 0);\r\nms->mirror[mirror].error_type = 0;\r\nms->mirror[mirror].offset = offset;\r\nreturn 0;\r\n}\r\nstatic struct dm_dirty_log *create_dirty_log(struct dm_target *ti,\r\nunsigned argc, char **argv,\r\nunsigned *args_used)\r\n{\r\nunsigned param_count;\r\nstruct dm_dirty_log *dl;\r\nchar dummy;\r\nif (argc < 2) {\r\nti->error = "Insufficient mirror log arguments";\r\nreturn NULL;\r\n}\r\nif (sscanf(argv[1], "%u%c", &param_count, &dummy) != 1) {\r\nti->error = "Invalid mirror log argument count";\r\nreturn NULL;\r\n}\r\n*args_used = 2 + param_count;\r\nif (argc < *args_used) {\r\nti->error = "Insufficient mirror log arguments";\r\nreturn NULL;\r\n}\r\ndl = dm_dirty_log_create(argv[0], ti, mirror_flush, param_count,\r\nargv + 2);\r\nif (!dl) {\r\nti->error = "Error creating mirror dirty log";\r\nreturn NULL;\r\n}\r\nreturn dl;\r\n}\r\nstatic int parse_features(struct mirror_set *ms, unsigned argc, char **argv,\r\nunsigned *args_used)\r\n{\r\nunsigned num_features;\r\nstruct dm_target *ti = ms->ti;\r\nchar dummy;\r\n*args_used = 0;\r\nif (!argc)\r\nreturn 0;\r\nif (sscanf(argv[0], "%u%c", &num_features, &dummy) != 1) {\r\nti->error = "Invalid number of features";\r\nreturn -EINVAL;\r\n}\r\nargc--;\r\nargv++;\r\n(*args_used)++;\r\nif (num_features > argc) {\r\nti->error = "Not enough arguments to support feature count";\r\nreturn -EINVAL;\r\n}\r\nif (!strcmp("handle_errors", argv[0]))\r\nms->features |= DM_RAID1_HANDLE_ERRORS;\r\nelse {\r\nti->error = "Unrecognised feature requested";\r\nreturn -EINVAL;\r\n}\r\n(*args_used)++;\r\nreturn 0;\r\n}\r\nstatic int mirror_ctr(struct dm_target *ti, unsigned int argc, char **argv)\r\n{\r\nint r;\r\nunsigned int nr_mirrors, m, args_used;\r\nstruct mirror_set *ms;\r\nstruct dm_dirty_log *dl;\r\nchar dummy;\r\ndl = create_dirty_log(ti, argc, argv, &args_used);\r\nif (!dl)\r\nreturn -EINVAL;\r\nargv += args_used;\r\nargc -= args_used;\r\nif (!argc || sscanf(argv[0], "%u%c", &nr_mirrors, &dummy) != 1 ||\r\nnr_mirrors < 2 || nr_mirrors > DM_KCOPYD_MAX_REGIONS + 1) {\r\nti->error = "Invalid number of mirrors";\r\ndm_dirty_log_destroy(dl);\r\nreturn -EINVAL;\r\n}\r\nargv++, argc--;\r\nif (argc < nr_mirrors * 2) {\r\nti->error = "Too few mirror arguments";\r\ndm_dirty_log_destroy(dl);\r\nreturn -EINVAL;\r\n}\r\nms = alloc_context(nr_mirrors, dl->type->get_region_size(dl), ti, dl);\r\nif (!ms) {\r\ndm_dirty_log_destroy(dl);\r\nreturn -ENOMEM;\r\n}\r\nfor (m = 0; m < nr_mirrors; m++) {\r\nr = get_mirror(ms, ti, m, argv);\r\nif (r) {\r\nfree_context(ms, ti, m);\r\nreturn r;\r\n}\r\nargv += 2;\r\nargc -= 2;\r\n}\r\nti->private = ms;\r\nr = dm_set_target_max_io_len(ti, dm_rh_get_region_size(ms->rh));\r\nif (r)\r\ngoto err_free_context;\r\nti->num_flush_bios = 1;\r\nti->num_discard_bios = 1;\r\nti->per_bio_data_size = sizeof(struct dm_raid1_bio_record);\r\nti->discard_zeroes_data_unsupported = true;\r\nms->kmirrord_wq = alloc_workqueue("kmirrord", WQ_MEM_RECLAIM, 0);\r\nif (!ms->kmirrord_wq) {\r\nDMERR("couldn't start kmirrord");\r\nr = -ENOMEM;\r\ngoto err_free_context;\r\n}\r\nINIT_WORK(&ms->kmirrord_work, do_mirror);\r\ninit_timer(&ms->timer);\r\nms->timer_pending = 0;\r\nINIT_WORK(&ms->trigger_event, trigger_event);\r\nr = parse_features(ms, argc, argv, &args_used);\r\nif (r)\r\ngoto err_destroy_wq;\r\nargv += args_used;\r\nargc -= args_used;\r\nif (argc) {\r\nti->error = "Too many mirror arguments";\r\nr = -EINVAL;\r\ngoto err_destroy_wq;\r\n}\r\nms->kcopyd_client = dm_kcopyd_client_create(&dm_kcopyd_throttle);\r\nif (IS_ERR(ms->kcopyd_client)) {\r\nr = PTR_ERR(ms->kcopyd_client);\r\ngoto err_destroy_wq;\r\n}\r\nwakeup_mirrord(ms);\r\nreturn 0;\r\nerr_destroy_wq:\r\ndestroy_workqueue(ms->kmirrord_wq);\r\nerr_free_context:\r\nfree_context(ms, ti, ms->nr_mirrors);\r\nreturn r;\r\n}\r\nstatic void mirror_dtr(struct dm_target *ti)\r\n{\r\nstruct mirror_set *ms = (struct mirror_set *) ti->private;\r\ndel_timer_sync(&ms->timer);\r\nflush_workqueue(ms->kmirrord_wq);\r\nflush_work(&ms->trigger_event);\r\ndm_kcopyd_client_destroy(ms->kcopyd_client);\r\ndestroy_workqueue(ms->kmirrord_wq);\r\nfree_context(ms, ti, ms->nr_mirrors);\r\n}\r\nstatic int mirror_map(struct dm_target *ti, struct bio *bio)\r\n{\r\nint r, rw = bio_rw(bio);\r\nstruct mirror *m;\r\nstruct mirror_set *ms = ti->private;\r\nstruct dm_dirty_log *log = dm_rh_dirty_log(ms->rh);\r\nstruct dm_raid1_bio_record *bio_record =\r\ndm_per_bio_data(bio, sizeof(struct dm_raid1_bio_record));\r\nbio_record->details.bi_bdev = NULL;\r\nif (rw == WRITE) {\r\nbio_record->write_region = dm_rh_bio_to_region(ms->rh, bio);\r\nqueue_bio(ms, bio, rw);\r\nreturn DM_MAPIO_SUBMITTED;\r\n}\r\nr = log->type->in_sync(log, dm_rh_bio_to_region(ms->rh, bio), 0);\r\nif (r < 0 && r != -EWOULDBLOCK)\r\nreturn r;\r\nif (!r || (r == -EWOULDBLOCK)) {\r\nif (rw == READA)\r\nreturn -EWOULDBLOCK;\r\nqueue_bio(ms, bio, rw);\r\nreturn DM_MAPIO_SUBMITTED;\r\n}\r\nm = choose_mirror(ms, bio->bi_sector);\r\nif (unlikely(!m))\r\nreturn -EIO;\r\ndm_bio_record(&bio_record->details, bio);\r\nbio_record->m = m;\r\nmap_bio(m, bio);\r\nreturn DM_MAPIO_REMAPPED;\r\n}\r\nstatic int mirror_end_io(struct dm_target *ti, struct bio *bio, int error)\r\n{\r\nint rw = bio_rw(bio);\r\nstruct mirror_set *ms = (struct mirror_set *) ti->private;\r\nstruct mirror *m = NULL;\r\nstruct dm_bio_details *bd = NULL;\r\nstruct dm_raid1_bio_record *bio_record =\r\ndm_per_bio_data(bio, sizeof(struct dm_raid1_bio_record));\r\nif (rw == WRITE) {\r\nif (!(bio->bi_rw & (REQ_FLUSH | REQ_DISCARD)))\r\ndm_rh_dec(ms->rh, bio_record->write_region);\r\nreturn error;\r\n}\r\nif (error == -EOPNOTSUPP)\r\ngoto out;\r\nif ((error == -EWOULDBLOCK) && (bio->bi_rw & REQ_RAHEAD))\r\ngoto out;\r\nif (unlikely(error)) {\r\nif (!bio_record->details.bi_bdev) {\r\nDMERR_LIMIT("Mirror read failed.");\r\nreturn -EIO;\r\n}\r\nm = bio_record->m;\r\nDMERR("Mirror read failed from %s. Trying alternative device.",\r\nm->dev->name);\r\nfail_mirror(m, DM_RAID1_READ_ERROR);\r\nif (default_ok(m) || mirror_available(ms, bio)) {\r\nbd = &bio_record->details;\r\ndm_bio_restore(bd, bio);\r\nbio_record->details.bi_bdev = NULL;\r\nqueue_bio(ms, bio, rw);\r\nreturn DM_ENDIO_INCOMPLETE;\r\n}\r\nDMERR("All replicated volumes dead, failing I/O");\r\n}\r\nout:\r\nbio_record->details.bi_bdev = NULL;\r\nreturn error;\r\n}\r\nstatic void mirror_presuspend(struct dm_target *ti)\r\n{\r\nstruct mirror_set *ms = (struct mirror_set *) ti->private;\r\nstruct dm_dirty_log *log = dm_rh_dirty_log(ms->rh);\r\nstruct bio_list holds;\r\nstruct bio *bio;\r\natomic_set(&ms->suspend, 1);\r\nspin_lock_irq(&ms->lock);\r\nholds = ms->holds;\r\nbio_list_init(&ms->holds);\r\nspin_unlock_irq(&ms->lock);\r\nwhile ((bio = bio_list_pop(&holds)))\r\nhold_bio(ms, bio);\r\ndm_rh_stop_recovery(ms->rh);\r\nwait_event(_kmirrord_recovery_stopped,\r\n!dm_rh_recovery_in_flight(ms->rh));\r\nif (log->type->presuspend && log->type->presuspend(log))\r\nDMWARN("log presuspend failed");\r\nflush_workqueue(ms->kmirrord_wq);\r\n}\r\nstatic void mirror_postsuspend(struct dm_target *ti)\r\n{\r\nstruct mirror_set *ms = ti->private;\r\nstruct dm_dirty_log *log = dm_rh_dirty_log(ms->rh);\r\nif (log->type->postsuspend && log->type->postsuspend(log))\r\nDMWARN("log postsuspend failed");\r\n}\r\nstatic void mirror_resume(struct dm_target *ti)\r\n{\r\nstruct mirror_set *ms = ti->private;\r\nstruct dm_dirty_log *log = dm_rh_dirty_log(ms->rh);\r\natomic_set(&ms->suspend, 0);\r\nif (log->type->resume && log->type->resume(log))\r\nDMWARN("log resume failed");\r\ndm_rh_start_recovery(ms->rh);\r\n}\r\nstatic char device_status_char(struct mirror *m)\r\n{\r\nif (!atomic_read(&(m->error_count)))\r\nreturn 'A';\r\nreturn (test_bit(DM_RAID1_FLUSH_ERROR, &(m->error_type))) ? 'F' :\r\n(test_bit(DM_RAID1_WRITE_ERROR, &(m->error_type))) ? 'D' :\r\n(test_bit(DM_RAID1_SYNC_ERROR, &(m->error_type))) ? 'S' :\r\n(test_bit(DM_RAID1_READ_ERROR, &(m->error_type))) ? 'R' : 'U';\r\n}\r\nstatic void mirror_status(struct dm_target *ti, status_type_t type,\r\nunsigned status_flags, char *result, unsigned maxlen)\r\n{\r\nunsigned int m, sz = 0;\r\nstruct mirror_set *ms = (struct mirror_set *) ti->private;\r\nstruct dm_dirty_log *log = dm_rh_dirty_log(ms->rh);\r\nchar buffer[ms->nr_mirrors + 1];\r\nswitch (type) {\r\ncase STATUSTYPE_INFO:\r\nDMEMIT("%d ", ms->nr_mirrors);\r\nfor (m = 0; m < ms->nr_mirrors; m++) {\r\nDMEMIT("%s ", ms->mirror[m].dev->name);\r\nbuffer[m] = device_status_char(&(ms->mirror[m]));\r\n}\r\nbuffer[m] = '\0';\r\nDMEMIT("%llu/%llu 1 %s ",\r\n(unsigned long long)log->type->get_sync_count(log),\r\n(unsigned long long)ms->nr_regions, buffer);\r\nsz += log->type->status(log, type, result+sz, maxlen-sz);\r\nbreak;\r\ncase STATUSTYPE_TABLE:\r\nsz = log->type->status(log, type, result, maxlen);\r\nDMEMIT("%d", ms->nr_mirrors);\r\nfor (m = 0; m < ms->nr_mirrors; m++)\r\nDMEMIT(" %s %llu", ms->mirror[m].dev->name,\r\n(unsigned long long)ms->mirror[m].offset);\r\nif (ms->features & DM_RAID1_HANDLE_ERRORS)\r\nDMEMIT(" 1 handle_errors");\r\n}\r\n}\r\nstatic int mirror_iterate_devices(struct dm_target *ti,\r\niterate_devices_callout_fn fn, void *data)\r\n{\r\nstruct mirror_set *ms = ti->private;\r\nint ret = 0;\r\nunsigned i;\r\nfor (i = 0; !ret && i < ms->nr_mirrors; i++)\r\nret = fn(ti, ms->mirror[i].dev,\r\nms->mirror[i].offset, ti->len, data);\r\nreturn ret;\r\n}\r\nstatic int __init dm_mirror_init(void)\r\n{\r\nint r;\r\nr = dm_register_target(&mirror_target);\r\nif (r < 0) {\r\nDMERR("Failed to register mirror target");\r\ngoto bad_target;\r\n}\r\nreturn 0;\r\nbad_target:\r\nreturn r;\r\n}\r\nstatic void __exit dm_mirror_exit(void)\r\n{\r\ndm_unregister_target(&mirror_target);\r\n}
