int blk_rq_count_integrity_sg(struct request_queue *q, struct bio *bio)\r\n{\r\nstruct bio_vec *iv, *ivprv = NULL;\r\nunsigned int segments = 0;\r\nunsigned int seg_size = 0;\r\nunsigned int i = 0;\r\nbio_for_each_integrity_vec(iv, bio, i) {\r\nif (ivprv) {\r\nif (!BIOVEC_PHYS_MERGEABLE(ivprv, iv))\r\ngoto new_segment;\r\nif (!BIOVEC_SEG_BOUNDARY(q, ivprv, iv))\r\ngoto new_segment;\r\nif (seg_size + iv->bv_len > queue_max_segment_size(q))\r\ngoto new_segment;\r\nseg_size += iv->bv_len;\r\n} else {\r\nnew_segment:\r\nsegments++;\r\nseg_size = iv->bv_len;\r\n}\r\nivprv = iv;\r\n}\r\nreturn segments;\r\n}\r\nint blk_rq_map_integrity_sg(struct request_queue *q, struct bio *bio,\r\nstruct scatterlist *sglist)\r\n{\r\nstruct bio_vec *iv, *ivprv = NULL;\r\nstruct scatterlist *sg = NULL;\r\nunsigned int segments = 0;\r\nunsigned int i = 0;\r\nbio_for_each_integrity_vec(iv, bio, i) {\r\nif (ivprv) {\r\nif (!BIOVEC_PHYS_MERGEABLE(ivprv, iv))\r\ngoto new_segment;\r\nif (!BIOVEC_SEG_BOUNDARY(q, ivprv, iv))\r\ngoto new_segment;\r\nif (sg->length + iv->bv_len > queue_max_segment_size(q))\r\ngoto new_segment;\r\nsg->length += iv->bv_len;\r\n} else {\r\nnew_segment:\r\nif (!sg)\r\nsg = sglist;\r\nelse {\r\nsg_unmark_end(sg);\r\nsg = sg_next(sg);\r\n}\r\nsg_set_page(sg, iv->bv_page, iv->bv_len, iv->bv_offset);\r\nsegments++;\r\n}\r\nivprv = iv;\r\n}\r\nif (sg)\r\nsg_mark_end(sg);\r\nreturn segments;\r\n}\r\nint blk_integrity_compare(struct gendisk *gd1, struct gendisk *gd2)\r\n{\r\nstruct blk_integrity *b1 = gd1->integrity;\r\nstruct blk_integrity *b2 = gd2->integrity;\r\nif (!b1 && !b2)\r\nreturn 0;\r\nif (!b1 || !b2)\r\nreturn -1;\r\nif (b1->sector_size != b2->sector_size) {\r\nprintk(KERN_ERR "%s: %s/%s sector sz %u != %u\n", __func__,\r\ngd1->disk_name, gd2->disk_name,\r\nb1->sector_size, b2->sector_size);\r\nreturn -1;\r\n}\r\nif (b1->tuple_size != b2->tuple_size) {\r\nprintk(KERN_ERR "%s: %s/%s tuple sz %u != %u\n", __func__,\r\ngd1->disk_name, gd2->disk_name,\r\nb1->tuple_size, b2->tuple_size);\r\nreturn -1;\r\n}\r\nif (b1->tag_size && b2->tag_size && (b1->tag_size != b2->tag_size)) {\r\nprintk(KERN_ERR "%s: %s/%s tag sz %u != %u\n", __func__,\r\ngd1->disk_name, gd2->disk_name,\r\nb1->tag_size, b2->tag_size);\r\nreturn -1;\r\n}\r\nif (strcmp(b1->name, b2->name)) {\r\nprintk(KERN_ERR "%s: %s/%s type %s != %s\n", __func__,\r\ngd1->disk_name, gd2->disk_name,\r\nb1->name, b2->name);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint blk_integrity_merge_rq(struct request_queue *q, struct request *req,\r\nstruct request *next)\r\n{\r\nif (blk_integrity_rq(req) != blk_integrity_rq(next))\r\nreturn -1;\r\nif (req->nr_integrity_segments + next->nr_integrity_segments >\r\nq->limits.max_integrity_segments)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nint blk_integrity_merge_bio(struct request_queue *q, struct request *req,\r\nstruct bio *bio)\r\n{\r\nint nr_integrity_segs;\r\nstruct bio *next = bio->bi_next;\r\nbio->bi_next = NULL;\r\nnr_integrity_segs = blk_rq_count_integrity_sg(q, bio);\r\nbio->bi_next = next;\r\nif (req->nr_integrity_segments + nr_integrity_segs >\r\nq->limits.max_integrity_segments)\r\nreturn -1;\r\nreq->nr_integrity_segments += nr_integrity_segs;\r\nreturn 0;\r\n}\r\nstatic ssize_t integrity_attr_show(struct kobject *kobj, struct attribute *attr,\r\nchar *page)\r\n{\r\nstruct blk_integrity *bi =\r\ncontainer_of(kobj, struct blk_integrity, kobj);\r\nstruct integrity_sysfs_entry *entry =\r\ncontainer_of(attr, struct integrity_sysfs_entry, attr);\r\nreturn entry->show(bi, page);\r\n}\r\nstatic ssize_t integrity_attr_store(struct kobject *kobj,\r\nstruct attribute *attr, const char *page,\r\nsize_t count)\r\n{\r\nstruct blk_integrity *bi =\r\ncontainer_of(kobj, struct blk_integrity, kobj);\r\nstruct integrity_sysfs_entry *entry =\r\ncontainer_of(attr, struct integrity_sysfs_entry, attr);\r\nssize_t ret = 0;\r\nif (entry->store)\r\nret = entry->store(bi, page, count);\r\nreturn ret;\r\n}\r\nstatic ssize_t integrity_format_show(struct blk_integrity *bi, char *page)\r\n{\r\nif (bi != NULL && bi->name != NULL)\r\nreturn sprintf(page, "%s\n", bi->name);\r\nelse\r\nreturn sprintf(page, "none\n");\r\n}\r\nstatic ssize_t integrity_tag_size_show(struct blk_integrity *bi, char *page)\r\n{\r\nif (bi != NULL)\r\nreturn sprintf(page, "%u\n", bi->tag_size);\r\nelse\r\nreturn sprintf(page, "0\n");\r\n}\r\nstatic ssize_t integrity_read_store(struct blk_integrity *bi,\r\nconst char *page, size_t count)\r\n{\r\nchar *p = (char *) page;\r\nunsigned long val = simple_strtoul(p, &p, 10);\r\nif (val)\r\nbi->flags |= INTEGRITY_FLAG_READ;\r\nelse\r\nbi->flags &= ~INTEGRITY_FLAG_READ;\r\nreturn count;\r\n}\r\nstatic ssize_t integrity_read_show(struct blk_integrity *bi, char *page)\r\n{\r\nreturn sprintf(page, "%d\n", (bi->flags & INTEGRITY_FLAG_READ) != 0);\r\n}\r\nstatic ssize_t integrity_write_store(struct blk_integrity *bi,\r\nconst char *page, size_t count)\r\n{\r\nchar *p = (char *) page;\r\nunsigned long val = simple_strtoul(p, &p, 10);\r\nif (val)\r\nbi->flags |= INTEGRITY_FLAG_WRITE;\r\nelse\r\nbi->flags &= ~INTEGRITY_FLAG_WRITE;\r\nreturn count;\r\n}\r\nstatic ssize_t integrity_write_show(struct blk_integrity *bi, char *page)\r\n{\r\nreturn sprintf(page, "%d\n", (bi->flags & INTEGRITY_FLAG_WRITE) != 0);\r\n}\r\nstatic int __init blk_dev_integrity_init(void)\r\n{\r\nintegrity_cachep = kmem_cache_create("blkdev_integrity",\r\nsizeof(struct blk_integrity),\r\n0, SLAB_PANIC, NULL);\r\nreturn 0;\r\n}\r\nstatic void blk_integrity_release(struct kobject *kobj)\r\n{\r\nstruct blk_integrity *bi =\r\ncontainer_of(kobj, struct blk_integrity, kobj);\r\nkmem_cache_free(integrity_cachep, bi);\r\n}\r\nbool blk_integrity_is_initialized(struct gendisk *disk)\r\n{\r\nstruct blk_integrity *bi = blk_get_integrity(disk);\r\nreturn (bi && bi->name && strcmp(bi->name, bi_unsupported_name) != 0);\r\n}\r\nint blk_integrity_register(struct gendisk *disk, struct blk_integrity *template)\r\n{\r\nstruct blk_integrity *bi;\r\nBUG_ON(disk == NULL);\r\nif (disk->integrity == NULL) {\r\nbi = kmem_cache_alloc(integrity_cachep,\r\nGFP_KERNEL | __GFP_ZERO);\r\nif (!bi)\r\nreturn -1;\r\nif (kobject_init_and_add(&bi->kobj, &integrity_ktype,\r\n&disk_to_dev(disk)->kobj,\r\n"%s", "integrity")) {\r\nkmem_cache_free(integrity_cachep, bi);\r\nreturn -1;\r\n}\r\nkobject_uevent(&bi->kobj, KOBJ_ADD);\r\nbi->flags |= INTEGRITY_FLAG_READ | INTEGRITY_FLAG_WRITE;\r\nbi->sector_size = queue_logical_block_size(disk->queue);\r\ndisk->integrity = bi;\r\n} else\r\nbi = disk->integrity;\r\nif (template != NULL) {\r\nbi->name = template->name;\r\nbi->generate_fn = template->generate_fn;\r\nbi->verify_fn = template->verify_fn;\r\nbi->tuple_size = template->tuple_size;\r\nbi->set_tag_fn = template->set_tag_fn;\r\nbi->get_tag_fn = template->get_tag_fn;\r\nbi->tag_size = template->tag_size;\r\n} else\r\nbi->name = bi_unsupported_name;\r\ndisk->queue->backing_dev_info.capabilities |= BDI_CAP_STABLE_WRITES;\r\nreturn 0;\r\n}\r\nvoid blk_integrity_unregister(struct gendisk *disk)\r\n{\r\nstruct blk_integrity *bi;\r\nif (!disk || !disk->integrity)\r\nreturn;\r\ndisk->queue->backing_dev_info.capabilities &= ~BDI_CAP_STABLE_WRITES;\r\nbi = disk->integrity;\r\nkobject_uevent(&bi->kobj, KOBJ_REMOVE);\r\nkobject_del(&bi->kobj);\r\nkobject_put(&bi->kobj);\r\ndisk->integrity = NULL;\r\n}
