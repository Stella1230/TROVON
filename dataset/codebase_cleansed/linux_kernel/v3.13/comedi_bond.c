static int bonding_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct comedi_bond_private *devpriv = dev->private;\r\nunsigned int n_left, n_done, base_chan;\r\nunsigned int write_mask, data_bits;\r\nstruct bonded_device **devs;\r\nwrite_mask = data[0];\r\ndata_bits = data[1];\r\nbase_chan = CR_CHAN(insn->chanspec);\r\nn_left = devpriv->nchans - base_chan;\r\nif (n_left > 32)\r\nn_left = 32;\r\nn_done = 0;\r\ndevs = devpriv->devs;\r\ndo {\r\nstruct bonded_device *bdev = *devs++;\r\nif (base_chan < bdev->nchans) {\r\nunsigned int b_chans, b_mask, b_write_mask, b_data_bits;\r\nint ret;\r\nb_chans = bdev->nchans - base_chan;\r\nif (b_chans > n_left)\r\nb_chans = n_left;\r\nb_mask = (1U << b_chans) - 1;\r\nb_write_mask = (write_mask >> n_done) & b_mask;\r\nb_data_bits = (data_bits >> n_done) & b_mask;\r\nret = comedi_dio_bitfield2(bdev->dev, bdev->subdev,\r\nb_write_mask, &b_data_bits,\r\nbase_chan);\r\nif (ret < 0)\r\nreturn ret;\r\ndata[1] &= ~(b_mask << n_done);\r\ndata[1] |= (b_data_bits & b_mask) << n_done;\r\nbase_chan = 0;\r\nn_done += b_chans;\r\nn_left -= b_chans;\r\n} else {\r\nbase_chan -= bdev->nchans;\r\n}\r\n} while (n_left);\r\nreturn insn->n;\r\n}\r\nstatic int bonding_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct comedi_bond_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint ret;\r\nstruct bonded_device *bdev;\r\nstruct bonded_device **devs;\r\ndevs = devpriv->devs;\r\nfor (bdev = *devs++; chan >= bdev->nchans; bdev = *devs++)\r\nchan -= bdev->nchans;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\ncase INSN_CONFIG_DIO_INPUT:\r\nret = comedi_dio_config(bdev->dev, bdev->subdev, chan, data[0]);\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\nret = comedi_dio_get_config(bdev->dev, bdev->subdev, chan,\r\n&data[1]);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (ret >= 0)\r\nret = insn->n;\r\nreturn ret;\r\n}\r\nstatic int do_dev_config(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct comedi_bond_private *devpriv = dev->private;\r\nDECLARE_BITMAP(devs_opened, COMEDI_NUM_BOARD_MINORS);\r\nint i;\r\nmemset(&devs_opened, 0, sizeof(devs_opened));\r\ndevpriv->name[0] = 0;\r\nfor (i = 0; i < COMEDI_NDEVCONFOPTS && (!i || it->options[i]); ++i) {\r\nchar file[sizeof("/dev/comediXXXXXX")];\r\nint minor = it->options[i];\r\nstruct comedi_device *d;\r\nint sdev = -1, nchans;\r\nstruct bonded_device *bdev;\r\nstruct bonded_device **devs;\r\nif (minor < 0 || minor >= COMEDI_NUM_BOARD_MINORS) {\r\ndev_err(dev->class_dev,\r\n"Minor %d is invalid!\n", minor);\r\nreturn -EINVAL;\r\n}\r\nif (minor == dev->minor) {\r\ndev_err(dev->class_dev,\r\n"Cannot bond this driver to itself!\n");\r\nreturn -EINVAL;\r\n}\r\nif (test_and_set_bit(minor, devs_opened)) {\r\ndev_err(dev->class_dev,\r\n"Minor %d specified more than once!\n", minor);\r\nreturn -EINVAL;\r\n}\r\nsnprintf(file, sizeof(file), "/dev/comedi%u", minor);\r\nfile[sizeof(file) - 1] = 0;\r\nd = comedi_open(file);\r\nif (!d) {\r\ndev_err(dev->class_dev,\r\n"Minor %u could not be opened\n", minor);\r\nreturn -ENODEV;\r\n}\r\nwhile ((sdev = comedi_find_subdevice_by_type(d, COMEDI_SUBD_DIO,\r\nsdev + 1)) > -1) {\r\nnchans = comedi_get_n_channels(d, sdev);\r\nif (nchans <= 0) {\r\ndev_err(dev->class_dev,\r\n"comedi_get_n_channels() returned %d on minor %u subdev %d!\n",\r\nnchans, minor, sdev);\r\nreturn -EINVAL;\r\n}\r\nbdev = kmalloc(sizeof(*bdev), GFP_KERNEL);\r\nif (!bdev)\r\nreturn -ENOMEM;\r\nbdev->dev = d;\r\nbdev->minor = minor;\r\nbdev->subdev = sdev;\r\nbdev->nchans = nchans;\r\ndevpriv->nchans += nchans;\r\ndevs = krealloc(devpriv->devs,\r\n(devpriv->ndevs + 1) * sizeof(*devs),\r\nGFP_KERNEL);\r\nif (!devs) {\r\ndev_err(dev->class_dev,\r\n"Could not allocate memory. Out of memory?\n");\r\nreturn -ENOMEM;\r\n}\r\ndevpriv->devs = devs;\r\ndevpriv->devs[devpriv->ndevs++] = bdev;\r\n{\r\nchar buf[20];\r\nint left =\r\nMAX_BOARD_NAME - strlen(devpriv->name) - 1;\r\nsnprintf(buf, sizeof(buf), "%d:%d ",\r\nbdev->minor, bdev->subdev);\r\nbuf[sizeof(buf) - 1] = 0;\r\nstrncat(devpriv->name, buf, left);\r\n}\r\n}\r\n}\r\nif (!devpriv->nchans) {\r\ndev_err(dev->class_dev, "No channels found!\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bonding_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct comedi_bond_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = do_dev_config(dev, it);\r\nif (ret)\r\nreturn ret;\r\ndev->board_name = devpriv->name;\r\nret = comedi_alloc_subdevices(dev, 1);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = devpriv->nchans;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = bonding_dio_insn_bits;\r\ns->insn_config = bonding_dio_insn_config;\r\ndev_info(dev->class_dev,\r\n"%s: %s attached, %u channels from %u devices\n",\r\ndev->driver->driver_name, dev->board_name,\r\ndevpriv->nchans, devpriv->ndevs);\r\nreturn 0;\r\n}\r\nstatic void bonding_detach(struct comedi_device *dev)\r\n{\r\nstruct comedi_bond_private *devpriv = dev->private;\r\nif (devpriv && devpriv->devs) {\r\nDECLARE_BITMAP(devs_closed, COMEDI_NUM_BOARD_MINORS);\r\nmemset(&devs_closed, 0, sizeof(devs_closed));\r\nwhile (devpriv->ndevs--) {\r\nstruct bonded_device *bdev;\r\nbdev = devpriv->devs[devpriv->ndevs];\r\nif (!bdev)\r\ncontinue;\r\nif (!test_and_set_bit(bdev->minor, devs_closed))\r\ncomedi_close(bdev->dev);\r\nkfree(bdev);\r\n}\r\nkfree(devpriv->devs);\r\ndevpriv->devs = NULL;\r\n}\r\n}
