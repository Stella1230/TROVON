static const char *state_to_str(u8 state)\r\n{\r\nswitch (state) {\r\ncase LDC_STATE_INVALID:\r\nreturn "INVALID";\r\ncase LDC_STATE_INIT:\r\nreturn "INIT";\r\ncase LDC_STATE_BOUND:\r\nreturn "BOUND";\r\ncase LDC_STATE_READY:\r\nreturn "READY";\r\ncase LDC_STATE_CONNECTED:\r\nreturn "CONNECTED";\r\ndefault:\r\nreturn "<UNKNOWN>";\r\n}\r\n}\r\nstatic void ldc_set_state(struct ldc_channel *lp, u8 state)\r\n{\r\nldcdbg(STATE, "STATE (%s) --> (%s)\n",\r\nstate_to_str(lp->state),\r\nstate_to_str(state));\r\nlp->state = state;\r\n}\r\nstatic unsigned long __advance(unsigned long off, unsigned long num_entries)\r\n{\r\noff += LDC_PACKET_SIZE;\r\nif (off == (num_entries * LDC_PACKET_SIZE))\r\noff = 0;\r\nreturn off;\r\n}\r\nstatic unsigned long rx_advance(struct ldc_channel *lp, unsigned long off)\r\n{\r\nreturn __advance(off, lp->rx_num_entries);\r\n}\r\nstatic unsigned long tx_advance(struct ldc_channel *lp, unsigned long off)\r\n{\r\nreturn __advance(off, lp->tx_num_entries);\r\n}\r\nstatic struct ldc_packet *handshake_get_tx_packet(struct ldc_channel *lp,\r\nunsigned long *new_tail)\r\n{\r\nstruct ldc_packet *p;\r\nunsigned long t;\r\nt = tx_advance(lp, lp->tx_tail);\r\nif (t == lp->tx_head)\r\nreturn NULL;\r\n*new_tail = t;\r\np = lp->tx_base;\r\nreturn p + (lp->tx_tail / LDC_PACKET_SIZE);\r\n}\r\nstatic unsigned long head_for_data(struct ldc_channel *lp)\r\n{\r\nif (lp->cfg.mode == LDC_MODE_STREAM)\r\nreturn lp->tx_acked;\r\nreturn lp->tx_head;\r\n}\r\nstatic int tx_has_space_for(struct ldc_channel *lp, unsigned int size)\r\n{\r\nunsigned long limit, tail, new_tail, diff;\r\nunsigned int mss;\r\nlimit = head_for_data(lp);\r\ntail = lp->tx_tail;\r\nnew_tail = tx_advance(lp, tail);\r\nif (new_tail == limit)\r\nreturn 0;\r\nif (limit > new_tail)\r\ndiff = limit - new_tail;\r\nelse\r\ndiff = (limit +\r\n((lp->tx_num_entries * LDC_PACKET_SIZE) - new_tail));\r\ndiff /= LDC_PACKET_SIZE;\r\nmss = lp->mss;\r\nif (diff * mss < size)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic struct ldc_packet *data_get_tx_packet(struct ldc_channel *lp,\r\nunsigned long *new_tail)\r\n{\r\nstruct ldc_packet *p;\r\nunsigned long h, t;\r\nh = head_for_data(lp);\r\nt = tx_advance(lp, lp->tx_tail);\r\nif (t == h)\r\nreturn NULL;\r\n*new_tail = t;\r\np = lp->tx_base;\r\nreturn p + (lp->tx_tail / LDC_PACKET_SIZE);\r\n}\r\nstatic int set_tx_tail(struct ldc_channel *lp, unsigned long tail)\r\n{\r\nunsigned long orig_tail = lp->tx_tail;\r\nint limit = 1000;\r\nlp->tx_tail = tail;\r\nwhile (limit-- > 0) {\r\nunsigned long err;\r\nerr = sun4v_ldc_tx_set_qtail(lp->id, tail);\r\nif (!err)\r\nreturn 0;\r\nif (err != HV_EWOULDBLOCK) {\r\nlp->tx_tail = orig_tail;\r\nreturn -EINVAL;\r\n}\r\nudelay(1);\r\n}\r\nlp->tx_tail = orig_tail;\r\nreturn -EBUSY;\r\n}\r\nstatic int __set_rx_head(struct ldc_channel *lp, unsigned long head)\r\n{\r\nint limit = 1000;\r\nwhile (limit-- > 0) {\r\nunsigned long err;\r\nerr = sun4v_ldc_rx_set_qhead(lp->id, head);\r\nif (!err)\r\nreturn 0;\r\nif (err != HV_EWOULDBLOCK)\r\nreturn -EINVAL;\r\nudelay(1);\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int send_tx_packet(struct ldc_channel *lp,\r\nstruct ldc_packet *p,\r\nunsigned long new_tail)\r\n{\r\nBUG_ON(p != (lp->tx_base + (lp->tx_tail / LDC_PACKET_SIZE)));\r\nreturn set_tx_tail(lp, new_tail);\r\n}\r\nstatic struct ldc_packet *handshake_compose_ctrl(struct ldc_channel *lp,\r\nu8 stype, u8 ctrl,\r\nvoid *data, int dlen,\r\nunsigned long *new_tail)\r\n{\r\nstruct ldc_packet *p = handshake_get_tx_packet(lp, new_tail);\r\nif (p) {\r\nmemset(p, 0, sizeof(*p));\r\np->type = LDC_CTRL;\r\np->stype = stype;\r\np->ctrl = ctrl;\r\nif (data)\r\nmemcpy(p->u.u_data, data, dlen);\r\n}\r\nreturn p;\r\n}\r\nstatic int start_handshake(struct ldc_channel *lp)\r\n{\r\nstruct ldc_packet *p;\r\nstruct ldc_version *ver;\r\nunsigned long new_tail;\r\nver = &ver_arr[0];\r\nldcdbg(HS, "SEND VER INFO maj[%u] min[%u]\n",\r\nver->major, ver->minor);\r\np = handshake_compose_ctrl(lp, LDC_INFO, LDC_VERS,\r\nver, sizeof(*ver), &new_tail);\r\nif (p) {\r\nint err = send_tx_packet(lp, p, new_tail);\r\nif (!err)\r\nlp->flags &= ~LDC_FLAG_RESET;\r\nreturn err;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int send_version_nack(struct ldc_channel *lp,\r\nu16 major, u16 minor)\r\n{\r\nstruct ldc_packet *p;\r\nstruct ldc_version ver;\r\nunsigned long new_tail;\r\nver.major = major;\r\nver.minor = minor;\r\np = handshake_compose_ctrl(lp, LDC_NACK, LDC_VERS,\r\n&ver, sizeof(ver), &new_tail);\r\nif (p) {\r\nldcdbg(HS, "SEND VER NACK maj[%u] min[%u]\n",\r\nver.major, ver.minor);\r\nreturn send_tx_packet(lp, p, new_tail);\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int send_version_ack(struct ldc_channel *lp,\r\nstruct ldc_version *vp)\r\n{\r\nstruct ldc_packet *p;\r\nunsigned long new_tail;\r\np = handshake_compose_ctrl(lp, LDC_ACK, LDC_VERS,\r\nvp, sizeof(*vp), &new_tail);\r\nif (p) {\r\nldcdbg(HS, "SEND VER ACK maj[%u] min[%u]\n",\r\nvp->major, vp->minor);\r\nreturn send_tx_packet(lp, p, new_tail);\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int send_rts(struct ldc_channel *lp)\r\n{\r\nstruct ldc_packet *p;\r\nunsigned long new_tail;\r\np = handshake_compose_ctrl(lp, LDC_INFO, LDC_RTS, NULL, 0,\r\n&new_tail);\r\nif (p) {\r\np->env = lp->cfg.mode;\r\np->seqid = 0;\r\nlp->rcv_nxt = 0;\r\nldcdbg(HS, "SEND RTS env[0x%x] seqid[0x%x]\n",\r\np->env, p->seqid);\r\nreturn send_tx_packet(lp, p, new_tail);\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int send_rtr(struct ldc_channel *lp)\r\n{\r\nstruct ldc_packet *p;\r\nunsigned long new_tail;\r\np = handshake_compose_ctrl(lp, LDC_INFO, LDC_RTR, NULL, 0,\r\n&new_tail);\r\nif (p) {\r\np->env = lp->cfg.mode;\r\np->seqid = 0;\r\nldcdbg(HS, "SEND RTR env[0x%x] seqid[0x%x]\n",\r\np->env, p->seqid);\r\nreturn send_tx_packet(lp, p, new_tail);\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int send_rdx(struct ldc_channel *lp)\r\n{\r\nstruct ldc_packet *p;\r\nunsigned long new_tail;\r\np = handshake_compose_ctrl(lp, LDC_INFO, LDC_RDX, NULL, 0,\r\n&new_tail);\r\nif (p) {\r\np->env = 0;\r\np->seqid = ++lp->snd_nxt;\r\np->u.r.ackid = lp->rcv_nxt;\r\nldcdbg(HS, "SEND RDX env[0x%x] seqid[0x%x] ackid[0x%x]\n",\r\np->env, p->seqid, p->u.r.ackid);\r\nreturn send_tx_packet(lp, p, new_tail);\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int send_data_nack(struct ldc_channel *lp, struct ldc_packet *data_pkt)\r\n{\r\nstruct ldc_packet *p;\r\nunsigned long new_tail;\r\nint err;\r\np = data_get_tx_packet(lp, &new_tail);\r\nif (!p)\r\nreturn -EBUSY;\r\nmemset(p, 0, sizeof(*p));\r\np->type = data_pkt->type;\r\np->stype = LDC_NACK;\r\np->ctrl = data_pkt->ctrl & LDC_CTRL_MSK;\r\np->seqid = lp->snd_nxt + 1;\r\np->u.r.ackid = lp->rcv_nxt;\r\nldcdbg(HS, "SEND DATA NACK type[0x%x] ctl[0x%x] seq[0x%x] ack[0x%x]\n",\r\np->type, p->ctrl, p->seqid, p->u.r.ackid);\r\nerr = send_tx_packet(lp, p, new_tail);\r\nif (!err)\r\nlp->snd_nxt++;\r\nreturn err;\r\n}\r\nstatic int ldc_abort(struct ldc_channel *lp)\r\n{\r\nunsigned long hv_err;\r\nldcdbg(STATE, "ABORT\n");\r\nhv_err = sun4v_ldc_tx_qconf(lp->id, lp->tx_ra, lp->tx_num_entries);\r\nif (hv_err)\r\nprintk(KERN_ERR PFX "ldc_abort: "\r\n"sun4v_ldc_tx_qconf(%lx,%lx,%lx) failed, err=%lu\n",\r\nlp->id, lp->tx_ra, lp->tx_num_entries, hv_err);\r\nhv_err = sun4v_ldc_tx_get_state(lp->id,\r\n&lp->tx_head,\r\n&lp->tx_tail,\r\n&lp->chan_state);\r\nif (hv_err)\r\nprintk(KERN_ERR PFX "ldc_abort: "\r\n"sun4v_ldc_tx_get_state(%lx,...) failed, err=%lu\n",\r\nlp->id, hv_err);\r\nhv_err = sun4v_ldc_rx_qconf(lp->id, lp->rx_ra, lp->rx_num_entries);\r\nif (hv_err)\r\nprintk(KERN_ERR PFX "ldc_abort: "\r\n"sun4v_ldc_rx_qconf(%lx,%lx,%lx) failed, err=%lu\n",\r\nlp->id, lp->rx_ra, lp->rx_num_entries, hv_err);\r\nhv_err = sun4v_ldc_rx_get_state(lp->id,\r\n&lp->rx_head,\r\n&lp->rx_tail,\r\n&lp->chan_state);\r\nif (hv_err)\r\nprintk(KERN_ERR PFX "ldc_abort: "\r\n"sun4v_ldc_rx_get_state(%lx,...) failed, err=%lu\n",\r\nlp->id, hv_err);\r\nreturn -ECONNRESET;\r\n}\r\nstatic struct ldc_version *find_by_major(u16 major)\r\n{\r\nstruct ldc_version *ret = NULL;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ver_arr); i++) {\r\nstruct ldc_version *v = &ver_arr[i];\r\nif (v->major <= major) {\r\nret = v;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int process_ver_info(struct ldc_channel *lp, struct ldc_version *vp)\r\n{\r\nstruct ldc_version *vap;\r\nint err;\r\nldcdbg(HS, "GOT VERSION INFO major[%x] minor[%x]\n",\r\nvp->major, vp->minor);\r\nif (lp->hs_state == LDC_HS_GOTVERS) {\r\nlp->hs_state = LDC_HS_OPEN;\r\nmemset(&lp->ver, 0, sizeof(lp->ver));\r\n}\r\nvap = find_by_major(vp->major);\r\nif (!vap) {\r\nerr = send_version_nack(lp, 0, 0);\r\n} else if (vap->major != vp->major) {\r\nerr = send_version_nack(lp, vap->major, vap->minor);\r\n} else {\r\nstruct ldc_version ver = *vp;\r\nif (ver.minor > vap->minor)\r\nver.minor = vap->minor;\r\nerr = send_version_ack(lp, &ver);\r\nif (!err) {\r\nlp->ver = ver;\r\nlp->hs_state = LDC_HS_GOTVERS;\r\n}\r\n}\r\nif (err)\r\nreturn ldc_abort(lp);\r\nreturn 0;\r\n}\r\nstatic int process_ver_ack(struct ldc_channel *lp, struct ldc_version *vp)\r\n{\r\nldcdbg(HS, "GOT VERSION ACK major[%x] minor[%x]\n",\r\nvp->major, vp->minor);\r\nif (lp->hs_state == LDC_HS_GOTVERS) {\r\nif (lp->ver.major != vp->major ||\r\nlp->ver.minor != vp->minor)\r\nreturn ldc_abort(lp);\r\n} else {\r\nlp->ver = *vp;\r\nlp->hs_state = LDC_HS_GOTVERS;\r\n}\r\nif (send_rts(lp))\r\nreturn ldc_abort(lp);\r\nreturn 0;\r\n}\r\nstatic int process_ver_nack(struct ldc_channel *lp, struct ldc_version *vp)\r\n{\r\nstruct ldc_version *vap;\r\nstruct ldc_packet *p;\r\nunsigned long new_tail;\r\nif (vp->major == 0 && vp->minor == 0)\r\nreturn ldc_abort(lp);\r\nvap = find_by_major(vp->major);\r\nif (!vap)\r\nreturn ldc_abort(lp);\r\np = handshake_compose_ctrl(lp, LDC_INFO, LDC_VERS,\r\nvap, sizeof(*vap),\r\n&new_tail);\r\nif (!p)\r\nreturn ldc_abort(lp);\r\nreturn send_tx_packet(lp, p, new_tail);\r\n}\r\nstatic int process_version(struct ldc_channel *lp,\r\nstruct ldc_packet *p)\r\n{\r\nstruct ldc_version *vp;\r\nvp = (struct ldc_version *) p->u.u_data;\r\nswitch (p->stype) {\r\ncase LDC_INFO:\r\nreturn process_ver_info(lp, vp);\r\ncase LDC_ACK:\r\nreturn process_ver_ack(lp, vp);\r\ncase LDC_NACK:\r\nreturn process_ver_nack(lp, vp);\r\ndefault:\r\nreturn ldc_abort(lp);\r\n}\r\n}\r\nstatic int process_rts(struct ldc_channel *lp,\r\nstruct ldc_packet *p)\r\n{\r\nldcdbg(HS, "GOT RTS stype[%x] seqid[%x] env[%x]\n",\r\np->stype, p->seqid, p->env);\r\nif (p->stype != LDC_INFO ||\r\nlp->hs_state != LDC_HS_GOTVERS ||\r\np->env != lp->cfg.mode)\r\nreturn ldc_abort(lp);\r\nlp->snd_nxt = p->seqid;\r\nlp->rcv_nxt = p->seqid;\r\nlp->hs_state = LDC_HS_SENTRTR;\r\nif (send_rtr(lp))\r\nreturn ldc_abort(lp);\r\nreturn 0;\r\n}\r\nstatic int process_rtr(struct ldc_channel *lp,\r\nstruct ldc_packet *p)\r\n{\r\nldcdbg(HS, "GOT RTR stype[%x] seqid[%x] env[%x]\n",\r\np->stype, p->seqid, p->env);\r\nif (p->stype != LDC_INFO ||\r\np->env != lp->cfg.mode)\r\nreturn ldc_abort(lp);\r\nlp->snd_nxt = p->seqid;\r\nlp->hs_state = LDC_HS_COMPLETE;\r\nldc_set_state(lp, LDC_STATE_CONNECTED);\r\nsend_rdx(lp);\r\nreturn LDC_EVENT_UP;\r\n}\r\nstatic int rx_seq_ok(struct ldc_channel *lp, u32 seqid)\r\n{\r\nreturn lp->rcv_nxt + 1 == seqid;\r\n}\r\nstatic int process_rdx(struct ldc_channel *lp,\r\nstruct ldc_packet *p)\r\n{\r\nldcdbg(HS, "GOT RDX stype[%x] seqid[%x] env[%x] ackid[%x]\n",\r\np->stype, p->seqid, p->env, p->u.r.ackid);\r\nif (p->stype != LDC_INFO ||\r\n!(rx_seq_ok(lp, p->seqid)))\r\nreturn ldc_abort(lp);\r\nlp->rcv_nxt = p->seqid;\r\nlp->hs_state = LDC_HS_COMPLETE;\r\nldc_set_state(lp, LDC_STATE_CONNECTED);\r\nreturn LDC_EVENT_UP;\r\n}\r\nstatic int process_control_frame(struct ldc_channel *lp,\r\nstruct ldc_packet *p)\r\n{\r\nswitch (p->ctrl) {\r\ncase LDC_VERS:\r\nreturn process_version(lp, p);\r\ncase LDC_RTS:\r\nreturn process_rts(lp, p);\r\ncase LDC_RTR:\r\nreturn process_rtr(lp, p);\r\ncase LDC_RDX:\r\nreturn process_rdx(lp, p);\r\ndefault:\r\nreturn ldc_abort(lp);\r\n}\r\n}\r\nstatic int process_error_frame(struct ldc_channel *lp,\r\nstruct ldc_packet *p)\r\n{\r\nreturn ldc_abort(lp);\r\n}\r\nstatic int process_data_ack(struct ldc_channel *lp,\r\nstruct ldc_packet *ack)\r\n{\r\nunsigned long head = lp->tx_acked;\r\nu32 ackid = ack->u.r.ackid;\r\nwhile (1) {\r\nstruct ldc_packet *p = lp->tx_base + (head / LDC_PACKET_SIZE);\r\nhead = tx_advance(lp, head);\r\nif (p->seqid == ackid) {\r\nlp->tx_acked = head;\r\nreturn 0;\r\n}\r\nif (head == lp->tx_tail)\r\nreturn ldc_abort(lp);\r\n}\r\nreturn 0;\r\n}\r\nstatic void send_events(struct ldc_channel *lp, unsigned int event_mask)\r\n{\r\nif (event_mask & LDC_EVENT_RESET)\r\nlp->cfg.event(lp->event_arg, LDC_EVENT_RESET);\r\nif (event_mask & LDC_EVENT_UP)\r\nlp->cfg.event(lp->event_arg, LDC_EVENT_UP);\r\nif (event_mask & LDC_EVENT_DATA_READY)\r\nlp->cfg.event(lp->event_arg, LDC_EVENT_DATA_READY);\r\n}\r\nstatic irqreturn_t ldc_rx(int irq, void *dev_id)\r\n{\r\nstruct ldc_channel *lp = dev_id;\r\nunsigned long orig_state, flags;\r\nunsigned int event_mask;\r\nspin_lock_irqsave(&lp->lock, flags);\r\norig_state = lp->chan_state;\r\nsun4v_ldc_rx_get_state(lp->id,\r\n&lp->rx_head,\r\n&lp->rx_tail,\r\n&lp->chan_state);\r\nldcdbg(RX, "RX state[0x%02lx:0x%02lx] head[0x%04lx] tail[0x%04lx]\n",\r\norig_state, lp->chan_state, lp->rx_head, lp->rx_tail);\r\nevent_mask = 0;\r\nif (lp->cfg.mode == LDC_MODE_RAW &&\r\nlp->chan_state == LDC_CHANNEL_UP) {\r\nlp->hs_state = LDC_HS_COMPLETE;\r\nldc_set_state(lp, LDC_STATE_CONNECTED);\r\nevent_mask |= LDC_EVENT_UP;\r\norig_state = lp->chan_state;\r\n}\r\nif (lp->flags & LDC_FLAG_RESET) {\r\n(void) __set_rx_head(lp, lp->rx_tail);\r\ngoto out;\r\n}\r\nif (lp->hs_state == LDC_HS_COMPLETE) {\r\nhandshake_complete:\r\nif (lp->chan_state != orig_state) {\r\nunsigned int event = LDC_EVENT_RESET;\r\nif (lp->chan_state == LDC_CHANNEL_UP)\r\nevent = LDC_EVENT_UP;\r\nevent_mask |= event;\r\n}\r\nif (lp->rx_head != lp->rx_tail)\r\nevent_mask |= LDC_EVENT_DATA_READY;\r\ngoto out;\r\n}\r\nif (lp->chan_state != orig_state)\r\ngoto out;\r\nwhile (lp->rx_head != lp->rx_tail) {\r\nstruct ldc_packet *p;\r\nunsigned long new;\r\nint err;\r\np = lp->rx_base + (lp->rx_head / LDC_PACKET_SIZE);\r\nswitch (p->type) {\r\ncase LDC_CTRL:\r\nerr = process_control_frame(lp, p);\r\nif (err > 0)\r\nevent_mask |= err;\r\nbreak;\r\ncase LDC_DATA:\r\nevent_mask |= LDC_EVENT_DATA_READY;\r\nerr = 0;\r\nbreak;\r\ncase LDC_ERR:\r\nerr = process_error_frame(lp, p);\r\nbreak;\r\ndefault:\r\nerr = ldc_abort(lp);\r\nbreak;\r\n}\r\nif (err < 0)\r\nbreak;\r\nnew = lp->rx_head;\r\nnew += LDC_PACKET_SIZE;\r\nif (new == (lp->rx_num_entries * LDC_PACKET_SIZE))\r\nnew = 0;\r\nlp->rx_head = new;\r\nerr = __set_rx_head(lp, new);\r\nif (err < 0) {\r\n(void) ldc_abort(lp);\r\nbreak;\r\n}\r\nif (lp->hs_state == LDC_HS_COMPLETE)\r\ngoto handshake_complete;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nsend_events(lp, event_mask);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ldc_tx(int irq, void *dev_id)\r\n{\r\nstruct ldc_channel *lp = dev_id;\r\nunsigned long flags, orig_state;\r\nunsigned int event_mask = 0;\r\nspin_lock_irqsave(&lp->lock, flags);\r\norig_state = lp->chan_state;\r\nsun4v_ldc_tx_get_state(lp->id,\r\n&lp->tx_head,\r\n&lp->tx_tail,\r\n&lp->chan_state);\r\nldcdbg(TX, " TX state[0x%02lx:0x%02lx] head[0x%04lx] tail[0x%04lx]\n",\r\norig_state, lp->chan_state, lp->tx_head, lp->tx_tail);\r\nif (lp->cfg.mode == LDC_MODE_RAW &&\r\nlp->chan_state == LDC_CHANNEL_UP) {\r\nlp->hs_state = LDC_HS_COMPLETE;\r\nldc_set_state(lp, LDC_STATE_CONNECTED);\r\nevent_mask |= LDC_EVENT_UP;\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nsend_events(lp, event_mask);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __ldc_channel_exists(unsigned long id)\r\n{\r\nstruct ldc_channel *lp;\r\nhlist_for_each_entry(lp, &ldc_channel_list, list) {\r\nif (lp->id == id)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alloc_queue(const char *name, unsigned long num_entries,\r\nstruct ldc_packet **base, unsigned long *ra)\r\n{\r\nunsigned long size, order;\r\nvoid *q;\r\nsize = num_entries * LDC_PACKET_SIZE;\r\norder = get_order(size);\r\nq = (void *) __get_free_pages(GFP_KERNEL, order);\r\nif (!q) {\r\nprintk(KERN_ERR PFX "Alloc of %s queue failed with "\r\n"size=%lu order=%lu\n", name, size, order);\r\nreturn -ENOMEM;\r\n}\r\nmemset(q, 0, PAGE_SIZE << order);\r\n*base = q;\r\n*ra = __pa(q);\r\nreturn 0;\r\n}\r\nstatic void free_queue(unsigned long num_entries, struct ldc_packet *q)\r\n{\r\nunsigned long size, order;\r\nif (!q)\r\nreturn;\r\nsize = num_entries * LDC_PACKET_SIZE;\r\norder = get_order(size);\r\nfree_pages((unsigned long)q, order);\r\n}\r\nstatic int ldc_iommu_init(struct ldc_channel *lp)\r\n{\r\nunsigned long sz, num_tsb_entries, tsbsize, order;\r\nstruct ldc_iommu *iommu = &lp->iommu;\r\nstruct ldc_mtable_entry *table;\r\nunsigned long hv_err;\r\nint err;\r\nnum_tsb_entries = LDC_IOTABLE_SIZE;\r\ntsbsize = num_tsb_entries * sizeof(struct ldc_mtable_entry);\r\nspin_lock_init(&iommu->lock);\r\nsz = num_tsb_entries / 8;\r\nsz = (sz + 7UL) & ~7UL;\r\niommu->arena.map = kzalloc(sz, GFP_KERNEL);\r\nif (!iommu->arena.map) {\r\nprintk(KERN_ERR PFX "Alloc of arena map failed, sz=%lu\n", sz);\r\nreturn -ENOMEM;\r\n}\r\niommu->arena.limit = num_tsb_entries;\r\norder = get_order(tsbsize);\r\ntable = (struct ldc_mtable_entry *)\r\n__get_free_pages(GFP_KERNEL, order);\r\nerr = -ENOMEM;\r\nif (!table) {\r\nprintk(KERN_ERR PFX "Alloc of MTE table failed, "\r\n"size=%lu order=%lu\n", tsbsize, order);\r\ngoto out_free_map;\r\n}\r\nmemset(table, 0, PAGE_SIZE << order);\r\niommu->page_table = table;\r\nhv_err = sun4v_ldc_set_map_table(lp->id, __pa(table),\r\nnum_tsb_entries);\r\nerr = -EINVAL;\r\nif (hv_err)\r\ngoto out_free_table;\r\nreturn 0;\r\nout_free_table:\r\nfree_pages((unsigned long) table, order);\r\niommu->page_table = NULL;\r\nout_free_map:\r\nkfree(iommu->arena.map);\r\niommu->arena.map = NULL;\r\nreturn err;\r\n}\r\nstatic void ldc_iommu_release(struct ldc_channel *lp)\r\n{\r\nstruct ldc_iommu *iommu = &lp->iommu;\r\nunsigned long num_tsb_entries, tsbsize, order;\r\n(void) sun4v_ldc_set_map_table(lp->id, 0, 0);\r\nnum_tsb_entries = iommu->arena.limit;\r\ntsbsize = num_tsb_entries * sizeof(struct ldc_mtable_entry);\r\norder = get_order(tsbsize);\r\nfree_pages((unsigned long) iommu->page_table, order);\r\niommu->page_table = NULL;\r\nkfree(iommu->arena.map);\r\niommu->arena.map = NULL;\r\n}\r\nstruct ldc_channel *ldc_alloc(unsigned long id,\r\nconst struct ldc_channel_config *cfgp,\r\nvoid *event_arg)\r\n{\r\nstruct ldc_channel *lp;\r\nconst struct ldc_mode_ops *mops;\r\nunsigned long dummy1, dummy2, hv_err;\r\nu8 mss, *mssbuf;\r\nint err;\r\nerr = -ENODEV;\r\nif (!ldom_domaining_enabled)\r\ngoto out_err;\r\nerr = -EINVAL;\r\nif (!cfgp)\r\ngoto out_err;\r\nswitch (cfgp->mode) {\r\ncase LDC_MODE_RAW:\r\nmops = &raw_ops;\r\nmss = LDC_PACKET_SIZE;\r\nbreak;\r\ncase LDC_MODE_UNRELIABLE:\r\nmops = &nonraw_ops;\r\nmss = LDC_PACKET_SIZE - 8;\r\nbreak;\r\ncase LDC_MODE_STREAM:\r\nmops = &stream_ops;\r\nmss = LDC_PACKET_SIZE - 8 - 8;\r\nbreak;\r\ndefault:\r\ngoto out_err;\r\n}\r\nif (!cfgp->event || !event_arg || !cfgp->rx_irq || !cfgp->tx_irq)\r\ngoto out_err;\r\nhv_err = sun4v_ldc_tx_qinfo(id, &dummy1, &dummy2);\r\nerr = -ENODEV;\r\nif (hv_err == HV_ECHANNEL)\r\ngoto out_err;\r\nerr = -EEXIST;\r\nif (__ldc_channel_exists(id))\r\ngoto out_err;\r\nmssbuf = NULL;\r\nlp = kzalloc(sizeof(*lp), GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!lp)\r\ngoto out_err;\r\nspin_lock_init(&lp->lock);\r\nlp->id = id;\r\nerr = ldc_iommu_init(lp);\r\nif (err)\r\ngoto out_free_ldc;\r\nlp->mops = mops;\r\nlp->mss = mss;\r\nlp->cfg = *cfgp;\r\nif (!lp->cfg.mtu)\r\nlp->cfg.mtu = LDC_DEFAULT_MTU;\r\nif (lp->cfg.mode == LDC_MODE_STREAM) {\r\nmssbuf = kzalloc(lp->cfg.mtu, GFP_KERNEL);\r\nif (!mssbuf) {\r\nerr = -ENOMEM;\r\ngoto out_free_iommu;\r\n}\r\nlp->mssbuf = mssbuf;\r\n}\r\nlp->event_arg = event_arg;\r\nlp->tx_num_entries = LDC_DEFAULT_NUM_ENTRIES;\r\nlp->rx_num_entries = LDC_DEFAULT_NUM_ENTRIES;\r\nerr = alloc_queue("TX", lp->tx_num_entries,\r\n&lp->tx_base, &lp->tx_ra);\r\nif (err)\r\ngoto out_free_mssbuf;\r\nerr = alloc_queue("RX", lp->rx_num_entries,\r\n&lp->rx_base, &lp->rx_ra);\r\nif (err)\r\ngoto out_free_txq;\r\nlp->flags |= LDC_FLAG_ALLOCED_QUEUES;\r\nlp->hs_state = LDC_HS_CLOSED;\r\nldc_set_state(lp, LDC_STATE_INIT);\r\nINIT_HLIST_NODE(&lp->list);\r\nhlist_add_head(&lp->list, &ldc_channel_list);\r\nINIT_HLIST_HEAD(&lp->mh_list);\r\nreturn lp;\r\nout_free_txq:\r\nfree_queue(lp->tx_num_entries, lp->tx_base);\r\nout_free_mssbuf:\r\nkfree(mssbuf);\r\nout_free_iommu:\r\nldc_iommu_release(lp);\r\nout_free_ldc:\r\nkfree(lp);\r\nout_err:\r\nreturn ERR_PTR(err);\r\n}\r\nvoid ldc_free(struct ldc_channel *lp)\r\n{\r\nif (lp->flags & LDC_FLAG_REGISTERED_IRQS) {\r\nfree_irq(lp->cfg.rx_irq, lp);\r\nfree_irq(lp->cfg.tx_irq, lp);\r\n}\r\nif (lp->flags & LDC_FLAG_REGISTERED_QUEUES) {\r\nsun4v_ldc_tx_qconf(lp->id, 0, 0);\r\nsun4v_ldc_rx_qconf(lp->id, 0, 0);\r\nlp->flags &= ~LDC_FLAG_REGISTERED_QUEUES;\r\n}\r\nif (lp->flags & LDC_FLAG_ALLOCED_QUEUES) {\r\nfree_queue(lp->tx_num_entries, lp->tx_base);\r\nfree_queue(lp->rx_num_entries, lp->rx_base);\r\nlp->flags &= ~LDC_FLAG_ALLOCED_QUEUES;\r\n}\r\nhlist_del(&lp->list);\r\nkfree(lp->mssbuf);\r\nldc_iommu_release(lp);\r\nkfree(lp);\r\n}\r\nint ldc_bind(struct ldc_channel *lp, const char *name)\r\n{\r\nunsigned long hv_err, flags;\r\nint err = -EINVAL;\r\nif (!name ||\r\n(lp->state != LDC_STATE_INIT))\r\nreturn -EINVAL;\r\nsnprintf(lp->rx_irq_name, LDC_IRQ_NAME_MAX, "%s RX", name);\r\nsnprintf(lp->tx_irq_name, LDC_IRQ_NAME_MAX, "%s TX", name);\r\nerr = request_irq(lp->cfg.rx_irq, ldc_rx, 0,\r\nlp->rx_irq_name, lp);\r\nif (err)\r\nreturn err;\r\nerr = request_irq(lp->cfg.tx_irq, ldc_tx, 0,\r\nlp->tx_irq_name, lp);\r\nif (err) {\r\nfree_irq(lp->cfg.rx_irq, lp);\r\nreturn err;\r\n}\r\nspin_lock_irqsave(&lp->lock, flags);\r\nenable_irq(lp->cfg.rx_irq);\r\nenable_irq(lp->cfg.tx_irq);\r\nlp->flags |= LDC_FLAG_REGISTERED_IRQS;\r\nerr = -ENODEV;\r\nhv_err = sun4v_ldc_tx_qconf(lp->id, 0, 0);\r\nif (hv_err)\r\ngoto out_free_irqs;\r\nhv_err = sun4v_ldc_tx_qconf(lp->id, lp->tx_ra, lp->tx_num_entries);\r\nif (hv_err)\r\ngoto out_free_irqs;\r\nhv_err = sun4v_ldc_rx_qconf(lp->id, 0, 0);\r\nif (hv_err)\r\ngoto out_unmap_tx;\r\nhv_err = sun4v_ldc_rx_qconf(lp->id, lp->rx_ra, lp->rx_num_entries);\r\nif (hv_err)\r\ngoto out_unmap_tx;\r\nlp->flags |= LDC_FLAG_REGISTERED_QUEUES;\r\nhv_err = sun4v_ldc_tx_get_state(lp->id,\r\n&lp->tx_head,\r\n&lp->tx_tail,\r\n&lp->chan_state);\r\nerr = -EBUSY;\r\nif (hv_err)\r\ngoto out_unmap_rx;\r\nlp->tx_acked = lp->tx_head;\r\nlp->hs_state = LDC_HS_OPEN;\r\nldc_set_state(lp, LDC_STATE_BOUND);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn 0;\r\nout_unmap_rx:\r\nlp->flags &= ~LDC_FLAG_REGISTERED_QUEUES;\r\nsun4v_ldc_rx_qconf(lp->id, 0, 0);\r\nout_unmap_tx:\r\nsun4v_ldc_tx_qconf(lp->id, 0, 0);\r\nout_free_irqs:\r\nlp->flags &= ~LDC_FLAG_REGISTERED_IRQS;\r\nfree_irq(lp->cfg.tx_irq, lp);\r\nfree_irq(lp->cfg.rx_irq, lp);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn err;\r\n}\r\nint ldc_connect(struct ldc_channel *lp)\r\n{\r\nunsigned long flags;\r\nint err;\r\nif (lp->cfg.mode == LDC_MODE_RAW)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif (!(lp->flags & LDC_FLAG_ALLOCED_QUEUES) ||\r\n!(lp->flags & LDC_FLAG_REGISTERED_QUEUES) ||\r\nlp->hs_state != LDC_HS_OPEN)\r\nerr = -EINVAL;\r\nelse\r\nerr = start_handshake(lp);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn err;\r\n}\r\nint ldc_disconnect(struct ldc_channel *lp)\r\n{\r\nunsigned long hv_err, flags;\r\nint err;\r\nif (lp->cfg.mode == LDC_MODE_RAW)\r\nreturn -EINVAL;\r\nif (!(lp->flags & LDC_FLAG_ALLOCED_QUEUES) ||\r\n!(lp->flags & LDC_FLAG_REGISTERED_QUEUES))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nerr = -ENODEV;\r\nhv_err = sun4v_ldc_tx_qconf(lp->id, 0, 0);\r\nif (hv_err)\r\ngoto out_err;\r\nhv_err = sun4v_ldc_tx_qconf(lp->id, lp->tx_ra, lp->tx_num_entries);\r\nif (hv_err)\r\ngoto out_err;\r\nhv_err = sun4v_ldc_rx_qconf(lp->id, 0, 0);\r\nif (hv_err)\r\ngoto out_err;\r\nhv_err = sun4v_ldc_rx_qconf(lp->id, lp->rx_ra, lp->rx_num_entries);\r\nif (hv_err)\r\ngoto out_err;\r\nldc_set_state(lp, LDC_STATE_BOUND);\r\nlp->hs_state = LDC_HS_OPEN;\r\nlp->flags |= LDC_FLAG_RESET;\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn 0;\r\nout_err:\r\nsun4v_ldc_tx_qconf(lp->id, 0, 0);\r\nsun4v_ldc_rx_qconf(lp->id, 0, 0);\r\nfree_irq(lp->cfg.tx_irq, lp);\r\nfree_irq(lp->cfg.rx_irq, lp);\r\nlp->flags &= ~(LDC_FLAG_REGISTERED_IRQS |\r\nLDC_FLAG_REGISTERED_QUEUES);\r\nldc_set_state(lp, LDC_STATE_INIT);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn err;\r\n}\r\nint ldc_state(struct ldc_channel *lp)\r\n{\r\nreturn lp->state;\r\n}\r\nstatic int write_raw(struct ldc_channel *lp, const void *buf, unsigned int size)\r\n{\r\nstruct ldc_packet *p;\r\nunsigned long new_tail;\r\nint err;\r\nif (size > LDC_PACKET_SIZE)\r\nreturn -EMSGSIZE;\r\np = data_get_tx_packet(lp, &new_tail);\r\nif (!p)\r\nreturn -EAGAIN;\r\nmemcpy(p, buf, size);\r\nerr = send_tx_packet(lp, p, new_tail);\r\nif (!err)\r\nerr = size;\r\nreturn err;\r\n}\r\nstatic int read_raw(struct ldc_channel *lp, void *buf, unsigned int size)\r\n{\r\nstruct ldc_packet *p;\r\nunsigned long hv_err, new;\r\nint err;\r\nif (size < LDC_PACKET_SIZE)\r\nreturn -EINVAL;\r\nhv_err = sun4v_ldc_rx_get_state(lp->id,\r\n&lp->rx_head,\r\n&lp->rx_tail,\r\n&lp->chan_state);\r\nif (hv_err)\r\nreturn ldc_abort(lp);\r\nif (lp->chan_state == LDC_CHANNEL_DOWN ||\r\nlp->chan_state == LDC_CHANNEL_RESETTING)\r\nreturn -ECONNRESET;\r\nif (lp->rx_head == lp->rx_tail)\r\nreturn 0;\r\np = lp->rx_base + (lp->rx_head / LDC_PACKET_SIZE);\r\nmemcpy(buf, p, LDC_PACKET_SIZE);\r\nnew = rx_advance(lp, lp->rx_head);\r\nlp->rx_head = new;\r\nerr = __set_rx_head(lp, new);\r\nif (err < 0)\r\nerr = -ECONNRESET;\r\nelse\r\nerr = LDC_PACKET_SIZE;\r\nreturn err;\r\n}\r\nstatic int write_nonraw(struct ldc_channel *lp, const void *buf,\r\nunsigned int size)\r\n{\r\nunsigned long hv_err, tail;\r\nunsigned int copied;\r\nu32 seq;\r\nint err;\r\nhv_err = sun4v_ldc_tx_get_state(lp->id, &lp->tx_head, &lp->tx_tail,\r\n&lp->chan_state);\r\nif (unlikely(hv_err))\r\nreturn -EBUSY;\r\nif (unlikely(lp->chan_state != LDC_CHANNEL_UP))\r\nreturn ldc_abort(lp);\r\nif (!tx_has_space_for(lp, size))\r\nreturn -EAGAIN;\r\nseq = lp->snd_nxt;\r\ncopied = 0;\r\ntail = lp->tx_tail;\r\nwhile (copied < size) {\r\nstruct ldc_packet *p = lp->tx_base + (tail / LDC_PACKET_SIZE);\r\nu8 *data = ((lp->cfg.mode == LDC_MODE_UNRELIABLE) ?\r\np->u.u_data :\r\np->u.r.r_data);\r\nint data_len;\r\np->type = LDC_DATA;\r\np->stype = LDC_INFO;\r\np->ctrl = 0;\r\ndata_len = size - copied;\r\nif (data_len > lp->mss)\r\ndata_len = lp->mss;\r\nBUG_ON(data_len > LDC_LEN);\r\np->env = (data_len |\r\n(copied == 0 ? LDC_START : 0) |\r\n(data_len == size - copied ? LDC_STOP : 0));\r\np->seqid = ++seq;\r\nldcdbg(DATA, "SENT DATA [%02x:%02x:%02x:%02x:%08x]\n",\r\np->type,\r\np->stype,\r\np->ctrl,\r\np->env,\r\np->seqid);\r\nmemcpy(data, buf, data_len);\r\nbuf += data_len;\r\ncopied += data_len;\r\ntail = tx_advance(lp, tail);\r\n}\r\nerr = set_tx_tail(lp, tail);\r\nif (!err) {\r\nlp->snd_nxt = seq;\r\nerr = size;\r\n}\r\nreturn err;\r\n}\r\nstatic int rx_bad_seq(struct ldc_channel *lp, struct ldc_packet *p,\r\nstruct ldc_packet *first_frag)\r\n{\r\nint err;\r\nif (first_frag)\r\nlp->rcv_nxt = first_frag->seqid - 1;\r\nerr = send_data_nack(lp, p);\r\nif (err)\r\nreturn err;\r\nerr = __set_rx_head(lp, lp->rx_tail);\r\nif (err < 0)\r\nreturn ldc_abort(lp);\r\nreturn 0;\r\n}\r\nstatic int data_ack_nack(struct ldc_channel *lp, struct ldc_packet *p)\r\n{\r\nif (p->stype & LDC_ACK) {\r\nint err = process_data_ack(lp, p);\r\nif (err)\r\nreturn err;\r\n}\r\nif (p->stype & LDC_NACK)\r\nreturn ldc_abort(lp);\r\nreturn 0;\r\n}\r\nstatic int rx_data_wait(struct ldc_channel *lp, unsigned long cur_head)\r\n{\r\nunsigned long dummy;\r\nint limit = 1000;\r\nldcdbg(DATA, "DATA WAIT cur_head[%lx] rx_head[%lx] rx_tail[%lx]\n",\r\ncur_head, lp->rx_head, lp->rx_tail);\r\nwhile (limit-- > 0) {\r\nunsigned long hv_err;\r\nhv_err = sun4v_ldc_rx_get_state(lp->id,\r\n&dummy,\r\n&lp->rx_tail,\r\n&lp->chan_state);\r\nif (hv_err)\r\nreturn ldc_abort(lp);\r\nif (lp->chan_state == LDC_CHANNEL_DOWN ||\r\nlp->chan_state == LDC_CHANNEL_RESETTING)\r\nreturn -ECONNRESET;\r\nif (cur_head != lp->rx_tail) {\r\nldcdbg(DATA, "DATA WAIT DONE "\r\n"head[%lx] tail[%lx] chan_state[%lx]\n",\r\ndummy, lp->rx_tail, lp->chan_state);\r\nreturn 0;\r\n}\r\nudelay(1);\r\n}\r\nreturn -EAGAIN;\r\n}\r\nstatic int rx_set_head(struct ldc_channel *lp, unsigned long head)\r\n{\r\nint err = __set_rx_head(lp, head);\r\nif (err < 0)\r\nreturn ldc_abort(lp);\r\nlp->rx_head = head;\r\nreturn 0;\r\n}\r\nstatic void send_data_ack(struct ldc_channel *lp)\r\n{\r\nunsigned long new_tail;\r\nstruct ldc_packet *p;\r\np = data_get_tx_packet(lp, &new_tail);\r\nif (likely(p)) {\r\nint err;\r\nmemset(p, 0, sizeof(*p));\r\np->type = LDC_DATA;\r\np->stype = LDC_ACK;\r\np->ctrl = 0;\r\np->seqid = lp->snd_nxt + 1;\r\np->u.r.ackid = lp->rcv_nxt;\r\nerr = send_tx_packet(lp, p, new_tail);\r\nif (!err)\r\nlp->snd_nxt++;\r\n}\r\n}\r\nstatic int read_nonraw(struct ldc_channel *lp, void *buf, unsigned int size)\r\n{\r\nstruct ldc_packet *first_frag;\r\nunsigned long hv_err, new;\r\nint err, copied;\r\nhv_err = sun4v_ldc_rx_get_state(lp->id,\r\n&lp->rx_head,\r\n&lp->rx_tail,\r\n&lp->chan_state);\r\nif (hv_err)\r\nreturn ldc_abort(lp);\r\nif (lp->chan_state == LDC_CHANNEL_DOWN ||\r\nlp->chan_state == LDC_CHANNEL_RESETTING)\r\nreturn -ECONNRESET;\r\nif (lp->rx_head == lp->rx_tail)\r\nreturn 0;\r\nfirst_frag = NULL;\r\ncopied = err = 0;\r\nnew = lp->rx_head;\r\nwhile (1) {\r\nstruct ldc_packet *p;\r\nint pkt_len;\r\nBUG_ON(new == lp->rx_tail);\r\np = lp->rx_base + (new / LDC_PACKET_SIZE);\r\nldcdbg(RX, "RX read pkt[%02x:%02x:%02x:%02x:%08x:%08x] "\r\n"rcv_nxt[%08x]\n",\r\np->type,\r\np->stype,\r\np->ctrl,\r\np->env,\r\np->seqid,\r\np->u.r.ackid,\r\nlp->rcv_nxt);\r\nif (unlikely(!rx_seq_ok(lp, p->seqid))) {\r\nerr = rx_bad_seq(lp, p, first_frag);\r\ncopied = 0;\r\nbreak;\r\n}\r\nif (p->type & LDC_CTRL) {\r\nerr = process_control_frame(lp, p);\r\nif (err < 0)\r\nbreak;\r\nerr = 0;\r\n}\r\nlp->rcv_nxt = p->seqid;\r\nif (!(p->type & LDC_DATA)) {\r\nnew = rx_advance(lp, new);\r\ngoto no_data;\r\n}\r\nif (p->stype & (LDC_ACK | LDC_NACK)) {\r\nerr = data_ack_nack(lp, p);\r\nif (err)\r\nbreak;\r\n}\r\nif (!(p->stype & LDC_INFO)) {\r\nnew = rx_advance(lp, new);\r\nerr = rx_set_head(lp, new);\r\nif (err)\r\nbreak;\r\ngoto no_data;\r\n}\r\npkt_len = p->env & LDC_LEN;\r\nif ((first_frag == NULL && !(p->env & LDC_START)) ||\r\n(first_frag != NULL && (p->env & LDC_START))) {\r\nif (!first_frag)\r\nnew = rx_advance(lp, new);\r\nerr = rx_set_head(lp, new);\r\nif (err)\r\nbreak;\r\nif (!first_frag)\r\ngoto no_data;\r\n}\r\nif (!first_frag)\r\nfirst_frag = p;\r\nif (pkt_len > size - copied) {\r\nerr = -EMSGSIZE;\r\nbreak;\r\n}\r\nnew = rx_advance(lp, new);\r\nmemcpy(buf,\r\n(lp->cfg.mode == LDC_MODE_UNRELIABLE ?\r\np->u.u_data : p->u.r.r_data), pkt_len);\r\nbuf += pkt_len;\r\ncopied += pkt_len;\r\nif (p->env & LDC_STOP)\r\nbreak;\r\nno_data:\r\nif (new == lp->rx_tail) {\r\nerr = rx_data_wait(lp, new);\r\nif (err)\r\nbreak;\r\n}\r\n}\r\nif (!err)\r\nerr = rx_set_head(lp, new);\r\nif (err && first_frag)\r\nlp->rcv_nxt = first_frag->seqid - 1;\r\nif (!err) {\r\nerr = copied;\r\nif (err > 0 && lp->cfg.mode != LDC_MODE_UNRELIABLE)\r\nsend_data_ack(lp);\r\n}\r\nreturn err;\r\n}\r\nstatic int write_stream(struct ldc_channel *lp, const void *buf,\r\nunsigned int size)\r\n{\r\nif (size > lp->cfg.mtu)\r\nsize = lp->cfg.mtu;\r\nreturn write_nonraw(lp, buf, size);\r\n}\r\nstatic int read_stream(struct ldc_channel *lp, void *buf, unsigned int size)\r\n{\r\nif (!lp->mssbuf_len) {\r\nint err = read_nonraw(lp, lp->mssbuf, lp->cfg.mtu);\r\nif (err < 0)\r\nreturn err;\r\nlp->mssbuf_len = err;\r\nlp->mssbuf_off = 0;\r\n}\r\nif (size > lp->mssbuf_len)\r\nsize = lp->mssbuf_len;\r\nmemcpy(buf, lp->mssbuf + lp->mssbuf_off, size);\r\nlp->mssbuf_off += size;\r\nlp->mssbuf_len -= size;\r\nreturn size;\r\n}\r\nint ldc_write(struct ldc_channel *lp, const void *buf, unsigned int size)\r\n{\r\nunsigned long flags;\r\nint err;\r\nif (!buf)\r\nreturn -EINVAL;\r\nif (!size)\r\nreturn 0;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif (lp->hs_state != LDC_HS_COMPLETE)\r\nerr = -ENOTCONN;\r\nelse\r\nerr = lp->mops->write(lp, buf, size);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn err;\r\n}\r\nint ldc_read(struct ldc_channel *lp, void *buf, unsigned int size)\r\n{\r\nunsigned long flags;\r\nint err;\r\nif (!buf)\r\nreturn -EINVAL;\r\nif (!size)\r\nreturn 0;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif (lp->hs_state != LDC_HS_COMPLETE)\r\nerr = -ENOTCONN;\r\nelse\r\nerr = lp->mops->read(lp, buf, size);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn err;\r\n}\r\nstatic long arena_alloc(struct ldc_iommu *iommu, unsigned long npages)\r\n{\r\nstruct iommu_arena *arena = &iommu->arena;\r\nunsigned long n, start, end, limit;\r\nint pass;\r\nlimit = arena->limit;\r\nstart = arena->hint;\r\npass = 0;\r\nagain:\r\nn = bitmap_find_next_zero_area(arena->map, limit, start, npages, 0);\r\nend = n + npages;\r\nif (unlikely(end >= limit)) {\r\nif (likely(pass < 1)) {\r\nlimit = start;\r\nstart = 0;\r\npass++;\r\ngoto again;\r\n} else {\r\nreturn -1;\r\n}\r\n}\r\nbitmap_set(arena->map, n, npages);\r\narena->hint = end;\r\nreturn n;\r\n}\r\nstatic u64 pagesize_code(void)\r\n{\r\nswitch (PAGE_SIZE) {\r\ndefault:\r\ncase (8ULL * 1024ULL):\r\nreturn 0;\r\ncase (64ULL * 1024ULL):\r\nreturn 1;\r\ncase (512ULL * 1024ULL):\r\nreturn 2;\r\ncase (4ULL * 1024ULL * 1024ULL):\r\nreturn 3;\r\ncase (32ULL * 1024ULL * 1024ULL):\r\nreturn 4;\r\ncase (256ULL * 1024ULL * 1024ULL):\r\nreturn 5;\r\n}\r\n}\r\nstatic u64 make_cookie(u64 index, u64 pgsz_code, u64 page_offset)\r\n{\r\nreturn ((pgsz_code << COOKIE_PGSZ_CODE_SHIFT) |\r\n(index << PAGE_SHIFT) |\r\npage_offset);\r\n}\r\nstatic u64 cookie_to_index(u64 cookie, unsigned long *shift)\r\n{\r\nu64 szcode = cookie >> COOKIE_PGSZ_CODE_SHIFT;\r\ncookie &= ~COOKIE_PGSZ_CODE;\r\n*shift = szcode * 3;\r\nreturn (cookie >> (13ULL + (szcode * 3ULL)));\r\n}\r\nstatic struct ldc_mtable_entry *alloc_npages(struct ldc_iommu *iommu,\r\nunsigned long npages)\r\n{\r\nlong entry;\r\nentry = arena_alloc(iommu, npages);\r\nif (unlikely(entry < 0))\r\nreturn NULL;\r\nreturn iommu->page_table + entry;\r\n}\r\nstatic u64 perm_to_mte(unsigned int map_perm)\r\n{\r\nu64 mte_base;\r\nmte_base = pagesize_code();\r\nif (map_perm & LDC_MAP_SHADOW) {\r\nif (map_perm & LDC_MAP_R)\r\nmte_base |= LDC_MTE_COPY_R;\r\nif (map_perm & LDC_MAP_W)\r\nmte_base |= LDC_MTE_COPY_W;\r\n}\r\nif (map_perm & LDC_MAP_DIRECT) {\r\nif (map_perm & LDC_MAP_R)\r\nmte_base |= LDC_MTE_READ;\r\nif (map_perm & LDC_MAP_W)\r\nmte_base |= LDC_MTE_WRITE;\r\nif (map_perm & LDC_MAP_X)\r\nmte_base |= LDC_MTE_EXEC;\r\n}\r\nif (map_perm & LDC_MAP_IO) {\r\nif (map_perm & LDC_MAP_R)\r\nmte_base |= LDC_MTE_IOMMU_R;\r\nif (map_perm & LDC_MAP_W)\r\nmte_base |= LDC_MTE_IOMMU_W;\r\n}\r\nreturn mte_base;\r\n}\r\nstatic int pages_in_region(unsigned long base, long len)\r\n{\r\nint count = 0;\r\ndo {\r\nunsigned long new = (base + PAGE_SIZE) & PAGE_MASK;\r\nlen -= (new - base);\r\nbase = new;\r\ncount++;\r\n} while (len > 0);\r\nreturn count;\r\n}\r\nstatic void fill_cookies(struct cookie_state *sp, unsigned long pa,\r\nunsigned long off, unsigned long len)\r\n{\r\ndo {\r\nunsigned long tlen, new = pa + PAGE_SIZE;\r\nu64 this_cookie;\r\nsp->page_table[sp->pte_idx].mte = sp->mte_base | pa;\r\ntlen = PAGE_SIZE;\r\nif (off)\r\ntlen = PAGE_SIZE - off;\r\nif (tlen > len)\r\ntlen = len;\r\nthis_cookie = make_cookie(sp->pte_idx,\r\npagesize_code(), off);\r\noff = 0;\r\nif (this_cookie == sp->prev_cookie) {\r\nsp->cookies[sp->nc - 1].cookie_size += tlen;\r\n} else {\r\nsp->cookies[sp->nc].cookie_addr = this_cookie;\r\nsp->cookies[sp->nc].cookie_size = tlen;\r\nsp->nc++;\r\n}\r\nsp->prev_cookie = this_cookie + tlen;\r\nsp->pte_idx++;\r\nlen -= tlen;\r\npa = new;\r\n} while (len > 0);\r\n}\r\nstatic int sg_count_one(struct scatterlist *sg)\r\n{\r\nunsigned long base = page_to_pfn(sg_page(sg)) << PAGE_SHIFT;\r\nlong len = sg->length;\r\nif ((sg->offset | len) & (8UL - 1))\r\nreturn -EFAULT;\r\nreturn pages_in_region(base + sg->offset, len);\r\n}\r\nstatic int sg_count_pages(struct scatterlist *sg, int num_sg)\r\n{\r\nint count;\r\nint i;\r\ncount = 0;\r\nfor (i = 0; i < num_sg; i++) {\r\nint err = sg_count_one(sg + i);\r\nif (err < 0)\r\nreturn err;\r\ncount += err;\r\n}\r\nreturn count;\r\n}\r\nint ldc_map_sg(struct ldc_channel *lp,\r\nstruct scatterlist *sg, int num_sg,\r\nstruct ldc_trans_cookie *cookies, int ncookies,\r\nunsigned int map_perm)\r\n{\r\nunsigned long i, npages, flags;\r\nstruct ldc_mtable_entry *base;\r\nstruct cookie_state state;\r\nstruct ldc_iommu *iommu;\r\nint err;\r\nif (map_perm & ~LDC_MAP_ALL)\r\nreturn -EINVAL;\r\nerr = sg_count_pages(sg, num_sg);\r\nif (err < 0)\r\nreturn err;\r\nnpages = err;\r\nif (err > ncookies)\r\nreturn -EMSGSIZE;\r\niommu = &lp->iommu;\r\nspin_lock_irqsave(&iommu->lock, flags);\r\nbase = alloc_npages(iommu, npages);\r\nspin_unlock_irqrestore(&iommu->lock, flags);\r\nif (!base)\r\nreturn -ENOMEM;\r\nstate.page_table = iommu->page_table;\r\nstate.cookies = cookies;\r\nstate.mte_base = perm_to_mte(map_perm);\r\nstate.prev_cookie = ~(u64)0;\r\nstate.pte_idx = (base - iommu->page_table);\r\nstate.nc = 0;\r\nfor (i = 0; i < num_sg; i++)\r\nfill_cookies(&state, page_to_pfn(sg_page(&sg[i])) << PAGE_SHIFT,\r\nsg[i].offset, sg[i].length);\r\nreturn state.nc;\r\n}\r\nint ldc_map_single(struct ldc_channel *lp,\r\nvoid *buf, unsigned int len,\r\nstruct ldc_trans_cookie *cookies, int ncookies,\r\nunsigned int map_perm)\r\n{\r\nunsigned long npages, pa, flags;\r\nstruct ldc_mtable_entry *base;\r\nstruct cookie_state state;\r\nstruct ldc_iommu *iommu;\r\nif ((map_perm & ~LDC_MAP_ALL) || (ncookies < 1))\r\nreturn -EINVAL;\r\npa = __pa(buf);\r\nif ((pa | len) & (8UL - 1))\r\nreturn -EFAULT;\r\nnpages = pages_in_region(pa, len);\r\niommu = &lp->iommu;\r\nspin_lock_irqsave(&iommu->lock, flags);\r\nbase = alloc_npages(iommu, npages);\r\nspin_unlock_irqrestore(&iommu->lock, flags);\r\nif (!base)\r\nreturn -ENOMEM;\r\nstate.page_table = iommu->page_table;\r\nstate.cookies = cookies;\r\nstate.mte_base = perm_to_mte(map_perm);\r\nstate.prev_cookie = ~(u64)0;\r\nstate.pte_idx = (base - iommu->page_table);\r\nstate.nc = 0;\r\nfill_cookies(&state, (pa & PAGE_MASK), (pa & ~PAGE_MASK), len);\r\nBUG_ON(state.nc != 1);\r\nreturn state.nc;\r\n}\r\nstatic void free_npages(unsigned long id, struct ldc_iommu *iommu,\r\nu64 cookie, u64 size)\r\n{\r\nstruct iommu_arena *arena = &iommu->arena;\r\nunsigned long i, shift, index, npages;\r\nstruct ldc_mtable_entry *base;\r\nnpages = PAGE_ALIGN(((cookie & ~PAGE_MASK) + size)) >> PAGE_SHIFT;\r\nindex = cookie_to_index(cookie, &shift);\r\nbase = iommu->page_table + index;\r\nBUG_ON(index > arena->limit ||\r\n(index + npages) > arena->limit);\r\nfor (i = 0; i < npages; i++) {\r\nif (base->cookie)\r\nsun4v_ldc_revoke(id, cookie + (i << shift),\r\nbase->cookie);\r\nbase->mte = 0;\r\n__clear_bit(index + i, arena->map);\r\n}\r\n}\r\nvoid ldc_unmap(struct ldc_channel *lp, struct ldc_trans_cookie *cookies,\r\nint ncookies)\r\n{\r\nstruct ldc_iommu *iommu = &lp->iommu;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&iommu->lock, flags);\r\nfor (i = 0; i < ncookies; i++) {\r\nu64 addr = cookies[i].cookie_addr;\r\nu64 size = cookies[i].cookie_size;\r\nfree_npages(lp->id, iommu, addr, size);\r\n}\r\nspin_unlock_irqrestore(&iommu->lock, flags);\r\n}\r\nint ldc_copy(struct ldc_channel *lp, int copy_dir,\r\nvoid *buf, unsigned int len, unsigned long offset,\r\nstruct ldc_trans_cookie *cookies, int ncookies)\r\n{\r\nunsigned int orig_len;\r\nunsigned long ra;\r\nint i;\r\nif (copy_dir != LDC_COPY_IN && copy_dir != LDC_COPY_OUT) {\r\nprintk(KERN_ERR PFX "ldc_copy: ID[%lu] Bad copy_dir[%d]\n",\r\nlp->id, copy_dir);\r\nreturn -EINVAL;\r\n}\r\nra = __pa(buf);\r\nif ((ra | len | offset) & (8UL - 1)) {\r\nprintk(KERN_ERR PFX "ldc_copy: ID[%lu] Unaligned buffer "\r\n"ra[%lx] len[%x] offset[%lx]\n",\r\nlp->id, ra, len, offset);\r\nreturn -EFAULT;\r\n}\r\nif (lp->hs_state != LDC_HS_COMPLETE ||\r\n(lp->flags & LDC_FLAG_RESET)) {\r\nprintk(KERN_ERR PFX "ldc_copy: ID[%lu] Link down hs_state[%x] "\r\n"flags[%x]\n", lp->id, lp->hs_state, lp->flags);\r\nreturn -ECONNRESET;\r\n}\r\norig_len = len;\r\nfor (i = 0; i < ncookies; i++) {\r\nunsigned long cookie_raddr = cookies[i].cookie_addr;\r\nunsigned long this_len = cookies[i].cookie_size;\r\nunsigned long actual_len;\r\nif (unlikely(offset)) {\r\nunsigned long this_off = offset;\r\nif (this_off > this_len)\r\nthis_off = this_len;\r\noffset -= this_off;\r\nthis_len -= this_off;\r\nif (!this_len)\r\ncontinue;\r\ncookie_raddr += this_off;\r\n}\r\nif (this_len > len)\r\nthis_len = len;\r\nwhile (1) {\r\nunsigned long hv_err;\r\nhv_err = sun4v_ldc_copy(lp->id, copy_dir,\r\ncookie_raddr, ra,\r\nthis_len, &actual_len);\r\nif (unlikely(hv_err)) {\r\nprintk(KERN_ERR PFX "ldc_copy: ID[%lu] "\r\n"HV error %lu\n",\r\nlp->id, hv_err);\r\nif (lp->hs_state != LDC_HS_COMPLETE ||\r\n(lp->flags & LDC_FLAG_RESET))\r\nreturn -ECONNRESET;\r\nelse\r\nreturn -EFAULT;\r\n}\r\ncookie_raddr += actual_len;\r\nra += actual_len;\r\nlen -= actual_len;\r\nif (actual_len == this_len)\r\nbreak;\r\nthis_len -= actual_len;\r\n}\r\nif (!len)\r\nbreak;\r\n}\r\nreturn orig_len - len;\r\n}\r\nvoid *ldc_alloc_exp_dring(struct ldc_channel *lp, unsigned int len,\r\nstruct ldc_trans_cookie *cookies, int *ncookies,\r\nunsigned int map_perm)\r\n{\r\nvoid *buf;\r\nint err;\r\nif (len & (8UL - 1))\r\nreturn ERR_PTR(-EINVAL);\r\nbuf = kzalloc(len, GFP_KERNEL);\r\nif (!buf)\r\nreturn ERR_PTR(-ENOMEM);\r\nerr = ldc_map_single(lp, buf, len, cookies, *ncookies, map_perm);\r\nif (err < 0) {\r\nkfree(buf);\r\nreturn ERR_PTR(err);\r\n}\r\n*ncookies = err;\r\nreturn buf;\r\n}\r\nvoid ldc_free_exp_dring(struct ldc_channel *lp, void *buf, unsigned int len,\r\nstruct ldc_trans_cookie *cookies, int ncookies)\r\n{\r\nldc_unmap(lp, cookies, ncookies);\r\nkfree(buf);\r\n}\r\nstatic int __init ldc_init(void)\r\n{\r\nunsigned long major, minor;\r\nstruct mdesc_handle *hp;\r\nconst u64 *v;\r\nint err;\r\nu64 mp;\r\nhp = mdesc_grab();\r\nif (!hp)\r\nreturn -ENODEV;\r\nmp = mdesc_node_by_name(hp, MDESC_NODE_NULL, "platform");\r\nerr = -ENODEV;\r\nif (mp == MDESC_NODE_NULL)\r\ngoto out;\r\nv = mdesc_get_property(hp, mp, "domaining-enabled", NULL);\r\nif (!v)\r\ngoto out;\r\nmajor = 1;\r\nminor = 0;\r\nif (sun4v_hvapi_register(HV_GRP_LDOM, major, &minor)) {\r\nprintk(KERN_INFO PFX "Could not register LDOM hvapi.\n");\r\ngoto out;\r\n}\r\nprintk(KERN_INFO "%s", version);\r\nif (!*v) {\r\nprintk(KERN_INFO PFX "Domaining disabled.\n");\r\ngoto out;\r\n}\r\nldom_domaining_enabled = 1;\r\nerr = 0;\r\nout:\r\nmdesc_release(hp);\r\nreturn err;\r\n}
