static void ipcomp6_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\r\nu8 type, u8 code, int offset, __be32 info)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\n__be32 spi;\r\nconst struct ipv6hdr *iph = (const struct ipv6hdr *)skb->data;\r\nstruct ip_comp_hdr *ipcomph =\r\n(struct ip_comp_hdr *)(skb->data + offset);\r\nstruct xfrm_state *x;\r\nif (type != ICMPV6_PKT_TOOBIG &&\r\ntype != NDISC_REDIRECT)\r\nreturn;\r\nspi = htonl(ntohs(ipcomph->cpi));\r\nx = xfrm_state_lookup(net, skb->mark, (const xfrm_address_t *)&iph->daddr,\r\nspi, IPPROTO_COMP, AF_INET6);\r\nif (!x)\r\nreturn;\r\nif (type == NDISC_REDIRECT)\r\nip6_redirect(skb, net, skb->dev->ifindex, 0);\r\nelse\r\nip6_update_pmtu(skb, net, info, 0, 0);\r\nxfrm_state_put(x);\r\n}\r\nstatic struct xfrm_state *ipcomp6_tunnel_create(struct xfrm_state *x)\r\n{\r\nstruct net *net = xs_net(x);\r\nstruct xfrm_state *t = NULL;\r\nt = xfrm_state_alloc(net);\r\nif (!t)\r\ngoto out;\r\nt->id.proto = IPPROTO_IPV6;\r\nt->id.spi = xfrm6_tunnel_alloc_spi(net, (xfrm_address_t *)&x->props.saddr);\r\nif (!t->id.spi)\r\ngoto error;\r\nmemcpy(t->id.daddr.a6, x->id.daddr.a6, sizeof(struct in6_addr));\r\nmemcpy(&t->sel, &x->sel, sizeof(t->sel));\r\nt->props.family = AF_INET6;\r\nt->props.mode = x->props.mode;\r\nmemcpy(t->props.saddr.a6, x->props.saddr.a6, sizeof(struct in6_addr));\r\nmemcpy(&t->mark, &x->mark, sizeof(t->mark));\r\nif (xfrm_init_state(t))\r\ngoto error;\r\natomic_set(&t->tunnel_users, 1);\r\nout:\r\nreturn t;\r\nerror:\r\nt->km.state = XFRM_STATE_DEAD;\r\nxfrm_state_put(t);\r\nt = NULL;\r\ngoto out;\r\n}\r\nstatic int ipcomp6_tunnel_attach(struct xfrm_state *x)\r\n{\r\nstruct net *net = xs_net(x);\r\nint err = 0;\r\nstruct xfrm_state *t = NULL;\r\n__be32 spi;\r\nu32 mark = x->mark.m & x->mark.v;\r\nspi = xfrm6_tunnel_spi_lookup(net, (xfrm_address_t *)&x->props.saddr);\r\nif (spi)\r\nt = xfrm_state_lookup(net, mark, (xfrm_address_t *)&x->id.daddr,\r\nspi, IPPROTO_IPV6, AF_INET6);\r\nif (!t) {\r\nt = ipcomp6_tunnel_create(x);\r\nif (!t) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nxfrm_state_insert(t);\r\nxfrm_state_hold(t);\r\n}\r\nx->tunnel = t;\r\natomic_inc(&t->tunnel_users);\r\nout:\r\nreturn err;\r\n}\r\nstatic int ipcomp6_init_state(struct xfrm_state *x)\r\n{\r\nint err = -EINVAL;\r\nx->props.header_len = 0;\r\nswitch (x->props.mode) {\r\ncase XFRM_MODE_TRANSPORT:\r\nbreak;\r\ncase XFRM_MODE_TUNNEL:\r\nx->props.header_len += sizeof(struct ipv6hdr);\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nerr = ipcomp_init_state(x);\r\nif (err)\r\ngoto out;\r\nif (x->props.mode == XFRM_MODE_TUNNEL) {\r\nerr = ipcomp6_tunnel_attach(x);\r\nif (err)\r\ngoto out;\r\n}\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int __init ipcomp6_init(void)\r\n{\r\nif (xfrm_register_type(&ipcomp6_type, AF_INET6) < 0) {\r\npr_info("%s: can't add xfrm type\n", __func__);\r\nreturn -EAGAIN;\r\n}\r\nif (inet6_add_protocol(&ipcomp6_protocol, IPPROTO_COMP) < 0) {\r\npr_info("%s: can't add protocol\n", __func__);\r\nxfrm_unregister_type(&ipcomp6_type, AF_INET6);\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit ipcomp6_fini(void)\r\n{\r\nif (inet6_del_protocol(&ipcomp6_protocol, IPPROTO_COMP) < 0)\r\npr_info("%s: can't remove protocol\n", __func__);\r\nif (xfrm_unregister_type(&ipcomp6_type, AF_INET6) < 0)\r\npr_info("%s: can't remove xfrm type\n", __func__);\r\n}
