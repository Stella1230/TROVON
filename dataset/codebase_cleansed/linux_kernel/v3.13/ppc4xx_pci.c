static inline int ppc440spe_revA(void)\r\n{\r\nif ((mfspr(SPRN_PVR) & 0xffefffff) == 0x53421890)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void fixup_ppc4xx_pci_bridge(struct pci_dev *dev)\r\n{\r\nstruct pci_controller *hose;\r\nint i;\r\nif (dev->devfn != 0 || dev->bus->self != NULL)\r\nreturn;\r\nhose = pci_bus_to_host(dev->bus);\r\nif (hose == NULL)\r\nreturn;\r\nif (!of_device_is_compatible(hose->dn, "ibm,plb-pciex") &&\r\n!of_device_is_compatible(hose->dn, "ibm,plb-pcix") &&\r\n!of_device_is_compatible(hose->dn, "ibm,plb-pci"))\r\nreturn;\r\nif (of_device_is_compatible(hose->dn, "ibm,plb440epx-pci") ||\r\nof_device_is_compatible(hose->dn, "ibm,plb440grx-pci")) {\r\nhose->indirect_type |= PPC_INDIRECT_TYPE_BROKEN_MRM;\r\n}\r\nfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\r\ndev->resource[i].start = dev->resource[i].end = 0;\r\ndev->resource[i].flags = 0;\r\n}\r\nprintk(KERN_INFO "PCI: Hiding 4xx host bridge resources %s\n",\r\npci_name(dev));\r\n}\r\nstatic int __init ppc4xx_parse_dma_ranges(struct pci_controller *hose,\r\nvoid __iomem *reg,\r\nstruct resource *res)\r\n{\r\nu64 size;\r\nconst u32 *ranges;\r\nint rlen;\r\nint pna = of_n_addr_cells(hose->dn);\r\nint np = pna + 5;\r\nres->start = 0;\r\nsize = 0x80000000;\r\nres->end = size - 1;\r\nres->flags = IORESOURCE_MEM | IORESOURCE_PREFETCH;\r\nranges = of_get_property(hose->dn, "dma-ranges", &rlen);\r\nif (ranges == NULL)\r\ngoto out;\r\nwhile ((rlen -= np * 4) >= 0) {\r\nu32 pci_space = ranges[0];\r\nu64 pci_addr = of_read_number(ranges + 1, 2);\r\nu64 cpu_addr = of_translate_dma_address(hose->dn, ranges + 3);\r\nsize = of_read_number(ranges + pna + 3, 2);\r\nranges += np;\r\nif (cpu_addr == OF_BAD_ADDR || size == 0)\r\ncontinue;\r\nif ((pci_space & 0x03000000) != 0x02000000)\r\ncontinue;\r\nif (cpu_addr != 0 || pci_addr > 0xffffffff) {\r\nprintk(KERN_WARNING "%s: Ignored unsupported dma range"\r\n" 0x%016llx...0x%016llx -> 0x%016llx\n",\r\nhose->dn->full_name,\r\npci_addr, pci_addr + size - 1, cpu_addr);\r\ncontinue;\r\n}\r\nif (!(pci_space & 0x40000000))\r\nres->flags &= ~IORESOURCE_PREFETCH;\r\nres->start = pci_addr;\r\nif (sizeof(resource_size_t) == sizeof(u32) &&\r\n(pci_addr + size) > 0x100000000ull)\r\nres->end = 0xffffffff;\r\nelse\r\nres->end = res->start + size - 1;\r\nbreak;\r\n}\r\nif (dma_offset_set && pci_dram_offset != res->start) {\r\nprintk(KERN_ERR "%s: dma-ranges(s) mismatch\n",\r\nhose->dn->full_name);\r\nreturn -ENXIO;\r\n}\r\nif (size < total_memory) {\r\nprintk(KERN_ERR "%s: dma-ranges too small "\r\n"(size=%llx total_memory=%llx)\n",\r\nhose->dn->full_name, size, (u64)total_memory);\r\nreturn -ENXIO;\r\n}\r\nif ((size & (size - 1)) != 0 ||\r\n(res->start & (size - 1)) != 0) {\r\nprintk(KERN_ERR "%s: dma-ranges unaligned\n",\r\nhose->dn->full_name);\r\nreturn -ENXIO;\r\n}\r\nif (res->end > 0xffffffff) {\r\nprintk(KERN_ERR "%s: dma-ranges outside of 32 bits space\n",\r\nhose->dn->full_name);\r\nreturn -ENXIO;\r\n}\r\nout:\r\ndma_offset_set = 1;\r\npci_dram_offset = res->start;\r\nhose->dma_window_base_cur = res->start;\r\nhose->dma_window_size = resource_size(res);\r\nprintk(KERN_INFO "4xx PCI DMA offset set to 0x%08lx\n",\r\npci_dram_offset);\r\nprintk(KERN_INFO "4xx PCI DMA window base to 0x%016llx\n",\r\n(unsigned long long)hose->dma_window_base_cur);\r\nprintk(KERN_INFO "DMA window size 0x%016llx\n",\r\n(unsigned long long)hose->dma_window_size);\r\nreturn 0;\r\n}\r\nstatic int __init ppc4xx_setup_one_pci_PMM(struct pci_controller *hose,\r\nvoid __iomem *reg,\r\nu64 plb_addr,\r\nu64 pci_addr,\r\nu64 size,\r\nunsigned int flags,\r\nint index)\r\n{\r\nu32 ma, pcila, pciha;\r\nplb_addr &= 0xffffffffull;\r\nif ((plb_addr + size) > 0xffffffffull || !is_power_of_2(size) ||\r\nsize < 0x1000 || (plb_addr & (size - 1)) != 0) {\r\nprintk(KERN_WARNING "%s: Resource out of range\n",\r\nhose->dn->full_name);\r\nreturn -1;\r\n}\r\nma = (0xffffffffu << ilog2(size)) | 1;\r\nif (flags & IORESOURCE_PREFETCH)\r\nma |= 2;\r\npciha = RES_TO_U32_HIGH(pci_addr);\r\npcila = RES_TO_U32_LOW(pci_addr);\r\nwritel(plb_addr, reg + PCIL0_PMM0LA + (0x10 * index));\r\nwritel(pcila, reg + PCIL0_PMM0PCILA + (0x10 * index));\r\nwritel(pciha, reg + PCIL0_PMM0PCIHA + (0x10 * index));\r\nwritel(ma, reg + PCIL0_PMM0MA + (0x10 * index));\r\nreturn 0;\r\n}\r\nstatic void __init ppc4xx_configure_pci_PMMs(struct pci_controller *hose,\r\nvoid __iomem *reg)\r\n{\r\nint i, j, found_isa_hole = 0;\r\nfor (i = j = 0; i < 3; i++) {\r\nstruct resource *res = &hose->mem_resources[i];\r\nresource_size_t offset = hose->mem_offset[i];\r\nif (!(res->flags & IORESOURCE_MEM))\r\ncontinue;\r\nif (j > 2) {\r\nprintk(KERN_WARNING "%s: Too many ranges\n",\r\nhose->dn->full_name);\r\nbreak;\r\n}\r\nif (ppc4xx_setup_one_pci_PMM(hose, reg,\r\nres->start,\r\nres->start - offset,\r\nresource_size(res),\r\nres->flags,\r\nj) == 0) {\r\nj++;\r\nif (res->start == offset)\r\nfound_isa_hole = 1;\r\n}\r\n}\r\nif (j <= 2 && !found_isa_hole && hose->isa_mem_size)\r\nif (ppc4xx_setup_one_pci_PMM(hose, reg, hose->isa_mem_phys, 0,\r\nhose->isa_mem_size, 0, j) == 0)\r\nprintk(KERN_INFO "%s: Legacy ISA memory support enabled\n",\r\nhose->dn->full_name);\r\n}\r\nstatic void __init ppc4xx_configure_pci_PTMs(struct pci_controller *hose,\r\nvoid __iomem *reg,\r\nconst struct resource *res)\r\n{\r\nresource_size_t size = resource_size(res);\r\nu32 sa;\r\nsa = (0xffffffffu << ilog2(size)) | 1;\r\nsa |= 0x1;\r\nwritel(0, reg + PCIL0_PTM1LA);\r\nwritel(sa, reg + PCIL0_PTM1MS);\r\nearly_write_config_dword(hose, hose->first_busno, 0,\r\nPCI_BASE_ADDRESS_1, res->start);\r\nearly_write_config_dword(hose, hose->first_busno, 0,\r\nPCI_BASE_ADDRESS_2, 0x00000000);\r\nearly_write_config_word(hose, hose->first_busno, 0,\r\nPCI_COMMAND, 0x0006);\r\n}\r\nstatic void __init ppc4xx_probe_pci_bridge(struct device_node *np)\r\n{\r\nstruct resource rsrc_cfg;\r\nstruct resource rsrc_reg;\r\nstruct resource dma_window;\r\nstruct pci_controller *hose = NULL;\r\nvoid __iomem *reg = NULL;\r\nconst int *bus_range;\r\nint primary = 0;\r\nif (!of_device_is_available(np)) {\r\nprintk(KERN_INFO "%s: Port disabled via device-tree\n",\r\nnp->full_name);\r\nreturn;\r\n}\r\nif (of_address_to_resource(np, 0, &rsrc_cfg)) {\r\nprintk(KERN_ERR "%s: Can't get PCI config register base !",\r\nnp->full_name);\r\nreturn;\r\n}\r\nif (of_address_to_resource(np, 3, &rsrc_reg)) {\r\nprintk(KERN_ERR "%s: Can't get PCI internal register base !",\r\nnp->full_name);\r\nreturn;\r\n}\r\nif (of_get_property(np, "primary", NULL))\r\nprimary = 1;\r\nbus_range = of_get_property(np, "bus-range", NULL);\r\nreg = ioremap(rsrc_reg.start, resource_size(&rsrc_reg));\r\nif (reg == NULL) {\r\nprintk(KERN_ERR "%s: Can't map registers !", np->full_name);\r\ngoto fail;\r\n}\r\nhose = pcibios_alloc_controller(np);\r\nif (!hose)\r\ngoto fail;\r\nhose->first_busno = bus_range ? bus_range[0] : 0x0;\r\nhose->last_busno = bus_range ? bus_range[1] : 0xff;\r\nsetup_indirect_pci(hose, rsrc_cfg.start, rsrc_cfg.start + 0x4, 0);\r\nwritel(0, reg + PCIL0_PMM0MA);\r\nwritel(0, reg + PCIL0_PMM1MA);\r\nwritel(0, reg + PCIL0_PMM2MA);\r\nwritel(0, reg + PCIL0_PTM1MS);\r\nwritel(0, reg + PCIL0_PTM2MS);\r\npci_process_bridge_OF_ranges(hose, np, primary);\r\nif (ppc4xx_parse_dma_ranges(hose, reg, &dma_window) != 0)\r\ngoto fail;\r\nppc4xx_configure_pci_PMMs(hose, reg);\r\nppc4xx_configure_pci_PTMs(hose, reg, &dma_window);\r\niounmap(reg);\r\nreturn;\r\nfail:\r\nif (hose)\r\npcibios_free_controller(hose);\r\nif (reg)\r\niounmap(reg);\r\n}\r\nstatic int __init ppc4xx_setup_one_pcix_POM(struct pci_controller *hose,\r\nvoid __iomem *reg,\r\nu64 plb_addr,\r\nu64 pci_addr,\r\nu64 size,\r\nunsigned int flags,\r\nint index)\r\n{\r\nu32 lah, lal, pciah, pcial, sa;\r\nif (!is_power_of_2(size) || size < 0x1000 ||\r\n(plb_addr & (size - 1)) != 0) {\r\nprintk(KERN_WARNING "%s: Resource out of range\n",\r\nhose->dn->full_name);\r\nreturn -1;\r\n}\r\nlah = RES_TO_U32_HIGH(plb_addr);\r\nlal = RES_TO_U32_LOW(plb_addr);\r\npciah = RES_TO_U32_HIGH(pci_addr);\r\npcial = RES_TO_U32_LOW(pci_addr);\r\nsa = (0xffffffffu << ilog2(size)) | 0x1;\r\nif (index == 0) {\r\nwritel(lah, reg + PCIX0_POM0LAH);\r\nwritel(lal, reg + PCIX0_POM0LAL);\r\nwritel(pciah, reg + PCIX0_POM0PCIAH);\r\nwritel(pcial, reg + PCIX0_POM0PCIAL);\r\nwritel(sa, reg + PCIX0_POM0SA);\r\n} else {\r\nwritel(lah, reg + PCIX0_POM1LAH);\r\nwritel(lal, reg + PCIX0_POM1LAL);\r\nwritel(pciah, reg + PCIX0_POM1PCIAH);\r\nwritel(pcial, reg + PCIX0_POM1PCIAL);\r\nwritel(sa, reg + PCIX0_POM1SA);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init ppc4xx_configure_pcix_POMs(struct pci_controller *hose,\r\nvoid __iomem *reg)\r\n{\r\nint i, j, found_isa_hole = 0;\r\nfor (i = j = 0; i < 3; i++) {\r\nstruct resource *res = &hose->mem_resources[i];\r\nresource_size_t offset = hose->mem_offset[i];\r\nif (!(res->flags & IORESOURCE_MEM))\r\ncontinue;\r\nif (j > 1) {\r\nprintk(KERN_WARNING "%s: Too many ranges\n",\r\nhose->dn->full_name);\r\nbreak;\r\n}\r\nif (ppc4xx_setup_one_pcix_POM(hose, reg,\r\nres->start,\r\nres->start - offset,\r\nresource_size(res),\r\nres->flags,\r\nj) == 0) {\r\nj++;\r\nif (res->start == offset)\r\nfound_isa_hole = 1;\r\n}\r\n}\r\nif (j <= 1 && !found_isa_hole && hose->isa_mem_size)\r\nif (ppc4xx_setup_one_pcix_POM(hose, reg, hose->isa_mem_phys, 0,\r\nhose->isa_mem_size, 0, j) == 0)\r\nprintk(KERN_INFO "%s: Legacy ISA memory support enabled\n",\r\nhose->dn->full_name);\r\n}\r\nstatic void __init ppc4xx_configure_pcix_PIMs(struct pci_controller *hose,\r\nvoid __iomem *reg,\r\nconst struct resource *res,\r\nint big_pim,\r\nint enable_msi_hole)\r\n{\r\nresource_size_t size = resource_size(res);\r\nu32 sa;\r\nwritel(0x00000000, reg + PCIX0_PIM0LAH);\r\nwritel(0x00000000, reg + PCIX0_PIM0LAL);\r\nsa = (0xffffffffu << ilog2(size)) | 1;\r\nsa |= 0x1;\r\nif (res->flags & IORESOURCE_PREFETCH)\r\nsa |= 0x2;\r\nif (enable_msi_hole)\r\nsa |= 0x4;\r\nwritel(sa, reg + PCIX0_PIM0SA);\r\nif (big_pim)\r\nwritel(0xffffffff, reg + PCIX0_PIM0SAH);\r\nwritel(0x00000000, reg + PCIX0_BAR0H);\r\nwritel(res->start, reg + PCIX0_BAR0L);\r\nwritew(0x0006, reg + PCIX0_COMMAND);\r\n}\r\nstatic void __init ppc4xx_probe_pcix_bridge(struct device_node *np)\r\n{\r\nstruct resource rsrc_cfg;\r\nstruct resource rsrc_reg;\r\nstruct resource dma_window;\r\nstruct pci_controller *hose = NULL;\r\nvoid __iomem *reg = NULL;\r\nconst int *bus_range;\r\nint big_pim = 0, msi = 0, primary = 0;\r\nif (of_address_to_resource(np, 0, &rsrc_cfg)) {\r\nprintk(KERN_ERR "%s:Can't get PCI-X config register base !",\r\nnp->full_name);\r\nreturn;\r\n}\r\nif (of_address_to_resource(np, 3, &rsrc_reg)) {\r\nprintk(KERN_ERR "%s: Can't get PCI-X internal register base !",\r\nnp->full_name);\r\nreturn;\r\n}\r\nif (of_get_property(np, "large-inbound-windows", NULL))\r\nbig_pim = 1;\r\nif (of_get_property(np, "enable-msi-hole", NULL))\r\nmsi = 1;\r\nif (of_get_property(np, "primary", NULL))\r\nprimary = 1;\r\nbus_range = of_get_property(np, "bus-range", NULL);\r\nreg = ioremap(rsrc_reg.start, resource_size(&rsrc_reg));\r\nif (reg == NULL) {\r\nprintk(KERN_ERR "%s: Can't map registers !", np->full_name);\r\ngoto fail;\r\n}\r\nhose = pcibios_alloc_controller(np);\r\nif (!hose)\r\ngoto fail;\r\nhose->first_busno = bus_range ? bus_range[0] : 0x0;\r\nhose->last_busno = bus_range ? bus_range[1] : 0xff;\r\nsetup_indirect_pci(hose, rsrc_cfg.start, rsrc_cfg.start + 0x4,\r\nPPC_INDIRECT_TYPE_SET_CFG_TYPE);\r\nwritel(0, reg + PCIX0_POM0SA);\r\nwritel(0, reg + PCIX0_POM1SA);\r\nwritel(0, reg + PCIX0_POM2SA);\r\nwritel(0, reg + PCIX0_PIM0SA);\r\nwritel(0, reg + PCIX0_PIM1SA);\r\nwritel(0, reg + PCIX0_PIM2SA);\r\nif (big_pim) {\r\nwritel(0, reg + PCIX0_PIM0SAH);\r\nwritel(0, reg + PCIX0_PIM2SAH);\r\n}\r\npci_process_bridge_OF_ranges(hose, np, primary);\r\nif (ppc4xx_parse_dma_ranges(hose, reg, &dma_window) != 0)\r\ngoto fail;\r\nppc4xx_configure_pcix_POMs(hose, reg);\r\nppc4xx_configure_pcix_PIMs(hose, reg, &dma_window, big_pim, msi);\r\niounmap(reg);\r\nreturn;\r\nfail:\r\nif (hose)\r\npcibios_free_controller(hose);\r\nif (reg)\r\niounmap(reg);\r\n}\r\nstatic int __init ppc4xx_pciex_wait_on_sdr(struct ppc4xx_pciex_port *port,\r\nunsigned int sdr_offset,\r\nunsigned int mask,\r\nunsigned int value,\r\nint timeout_ms)\r\n{\r\nu32 val;\r\nwhile(timeout_ms--) {\r\nval = mfdcri(SDR0, port->sdr_base + sdr_offset);\r\nif ((val & mask) == value) {\r\npr_debug("PCIE%d: Wait on SDR %x success with tm %d (%08x)\n",\r\nport->index, sdr_offset, timeout_ms, val);\r\nreturn 0;\r\n}\r\nmsleep(1);\r\n}\r\nreturn -1;\r\n}\r\nstatic int __init ppc4xx_pciex_port_reset_sdr(struct ppc4xx_pciex_port *port)\r\n{\r\nif (ppc4xx_pciex_wait_on_sdr(port, PESDRn_RCSSTS, 1 << 20, 0, 10)) {\r\nprintk(KERN_WARNING "PCIE%d: PGRST failed\n",\r\nport->index);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init ppc4xx_pciex_check_link_sdr(struct ppc4xx_pciex_port *port)\r\n{\r\nprintk(KERN_INFO "PCIE%d: Checking link...\n", port->index);\r\nif (!port->has_ibpre ||\r\n!ppc4xx_pciex_wait_on_sdr(port, PESDRn_LOOP,\r\n1 << 28, 1 << 28, 100)) {\r\nprintk(KERN_INFO\r\n"PCIE%d: Device detected, waiting for link...\n",\r\nport->index);\r\nif (ppc4xx_pciex_wait_on_sdr(port, PESDRn_LOOP,\r\n0x1000, 0x1000, 2000))\r\nprintk(KERN_WARNING\r\n"PCIE%d: Link up failed\n", port->index);\r\nelse {\r\nprintk(KERN_INFO\r\n"PCIE%d: link is up !\n", port->index);\r\nport->link = 1;\r\n}\r\n} else\r\nprintk(KERN_INFO "PCIE%d: No device detected.\n", port->index);\r\n}\r\nstatic int __init ppc440spe_pciex_check_reset(struct device_node *np)\r\n{\r\nu32 valPE0, valPE1, valPE2;\r\nint err = 0;\r\nif (!(mfdcri(SDR0, PESDR0_PLLLCT1) & 0x01000000)) {\r\npr_debug("PCIE: SDR0_PLLLCT1 already reset.\n");\r\nmtdcri(SDR0, PESDR0_440SPE_RCSSET, 0x01010000);\r\nmtdcri(SDR0, PESDR1_440SPE_RCSSET, 0x01010000);\r\nmtdcri(SDR0, PESDR2_440SPE_RCSSET, 0x01010000);\r\n}\r\nvalPE0 = mfdcri(SDR0, PESDR0_440SPE_RCSSET);\r\nvalPE1 = mfdcri(SDR0, PESDR1_440SPE_RCSSET);\r\nvalPE2 = mfdcri(SDR0, PESDR2_440SPE_RCSSET);\r\nif (!(valPE0 & 0x01000000) ||\r\n!(valPE1 & 0x01000000) ||\r\n!(valPE2 & 0x01000000)) {\r\nprintk(KERN_INFO "PCIE: SDR0_PExRCSSET rstgu error\n");\r\nerr = -1;\r\n}\r\nif (!(valPE0 & 0x00010000) ||\r\n!(valPE1 & 0x00010000) ||\r\n!(valPE2 & 0x00010000)) {\r\nprintk(KERN_INFO "PCIE: SDR0_PExRCSSET rstdl error\n");\r\nerr = -1;\r\n}\r\nif ((valPE0 & 0x00001000) ||\r\n(valPE1 & 0x00001000) ||\r\n(valPE2 & 0x00001000)) {\r\nprintk(KERN_INFO "PCIE: SDR0_PExRCSSET rstpyn error\n");\r\nerr = -1;\r\n}\r\nif ((valPE0 & 0x10000000) ||\r\n(valPE1 & 0x10000000) ||\r\n(valPE2 & 0x10000000)) {\r\nprintk(KERN_INFO "PCIE: SDR0_PExRCSSET hldplb error\n");\r\nerr = -1;\r\n}\r\nif ((valPE0 & 0x00100000) ||\r\n(valPE1 & 0x00100000) ||\r\n(valPE2 & 0x00100000)) {\r\nprintk(KERN_INFO "PCIE: SDR0_PExRCSSET rdy error\n");\r\nerr = -1;\r\n}\r\nif ((valPE0 & 0x00000100) ||\r\n(valPE1 & 0x00000100) ||\r\n(valPE2 & 0x00000100)) {\r\nprintk(KERN_INFO "PCIE: SDR0_PExRCSSET shutdown error\n");\r\nerr = -1;\r\n}\r\nreturn err;\r\n}\r\nstatic int __init ppc440spe_pciex_core_init(struct device_node *np)\r\n{\r\nint time_out = 20;\r\ndcri_clrset(SDR0, PESDR0_PLLLCT1, 0, 1 << 28);\r\nif (ppc440spe_pciex_check_reset(np))\r\nreturn -ENXIO;\r\nif (!(mfdcri(SDR0, PESDR0_PLLLCT2) & 0x10000)) {\r\nprintk(KERN_INFO "PCIE: PESDR_PLLCT2 resistance calibration "\r\n"failed (0x%08x)\n",\r\nmfdcri(SDR0, PESDR0_PLLLCT2));\r\nreturn -1;\r\n}\r\ndcri_clrset(SDR0, PESDR0_PLLLCT1, 1 << 24, 0);\r\nudelay(3);\r\nwhile (time_out) {\r\nif (!(mfdcri(SDR0, PESDR0_PLLLCT3) & 0x10000000)) {\r\ntime_out--;\r\nudelay(1);\r\n} else\r\nbreak;\r\n}\r\nif (!time_out) {\r\nprintk(KERN_INFO "PCIE: VCO output not locked\n");\r\nreturn -1;\r\n}\r\npr_debug("PCIE initialization OK\n");\r\nreturn 3;\r\n}\r\nstatic int __init ppc440spe_pciex_init_port_hw(struct ppc4xx_pciex_port *port)\r\n{\r\nu32 val = 1 << 24;\r\nif (port->endpoint)\r\nval = PTYPE_LEGACY_ENDPOINT << 20;\r\nelse\r\nval = PTYPE_ROOT_PORT << 20;\r\nif (port->index == 0)\r\nval |= LNKW_X8 << 12;\r\nelse\r\nval |= LNKW_X4 << 12;\r\nmtdcri(SDR0, port->sdr_base + PESDRn_DLPSET, val);\r\nmtdcri(SDR0, port->sdr_base + PESDRn_UTLSET1, 0x20222222);\r\nif (ppc440spe_revA())\r\nmtdcri(SDR0, port->sdr_base + PESDRn_UTLSET2, 0x11000000);\r\nmtdcri(SDR0, port->sdr_base + PESDRn_440SPE_HSSL0SET1, 0x35000000);\r\nmtdcri(SDR0, port->sdr_base + PESDRn_440SPE_HSSL1SET1, 0x35000000);\r\nmtdcri(SDR0, port->sdr_base + PESDRn_440SPE_HSSL2SET1, 0x35000000);\r\nmtdcri(SDR0, port->sdr_base + PESDRn_440SPE_HSSL3SET1, 0x35000000);\r\nif (port->index == 0) {\r\nmtdcri(SDR0, port->sdr_base + PESDRn_440SPE_HSSL4SET1,\r\n0x35000000);\r\nmtdcri(SDR0, port->sdr_base + PESDRn_440SPE_HSSL5SET1,\r\n0x35000000);\r\nmtdcri(SDR0, port->sdr_base + PESDRn_440SPE_HSSL6SET1,\r\n0x35000000);\r\nmtdcri(SDR0, port->sdr_base + PESDRn_440SPE_HSSL7SET1,\r\n0x35000000);\r\n}\r\ndcri_clrset(SDR0, port->sdr_base + PESDRn_RCSSET,\r\n(1 << 24) | (1 << 16), 1 << 12);\r\nreturn ppc4xx_pciex_port_reset_sdr(port);\r\n}\r\nstatic int __init ppc440speA_pciex_init_port_hw(struct ppc4xx_pciex_port *port)\r\n{\r\nreturn ppc440spe_pciex_init_port_hw(port);\r\n}\r\nstatic int __init ppc440speB_pciex_init_port_hw(struct ppc4xx_pciex_port *port)\r\n{\r\nint rc = ppc440spe_pciex_init_port_hw(port);\r\nport->has_ibpre = 1;\r\nreturn rc;\r\n}\r\nstatic int ppc440speA_pciex_init_utl(struct ppc4xx_pciex_port *port)\r\n{\r\ndcr_write(port->dcrs, DCRO_PEGPL_SPECIAL, 0x68782800);\r\nout_be32(port->utl_base + PEUTL_OUTTR, 0x08000000);\r\nout_be32(port->utl_base + PEUTL_INTR, 0x02000000);\r\nout_be32(port->utl_base + PEUTL_OPDBSZ, 0x10000000);\r\nout_be32(port->utl_base + PEUTL_PBBSZ, 0x53000000);\r\nout_be32(port->utl_base + PEUTL_IPHBSZ, 0x08000000);\r\nout_be32(port->utl_base + PEUTL_IPDBSZ, 0x10000000);\r\nout_be32(port->utl_base + PEUTL_RCIRQEN, 0x00f00000);\r\nout_be32(port->utl_base + PEUTL_PCTL, 0x80800066);\r\nreturn 0;\r\n}\r\nstatic int ppc440speB_pciex_init_utl(struct ppc4xx_pciex_port *port)\r\n{\r\nout_be32(port->utl_base + PEUTL_PBCTL, 0x08000000);\r\nreturn 0;\r\n}\r\nstatic int __init ppc460ex_pciex_core_init(struct device_node *np)\r\n{\r\nreturn 2;\r\n}\r\nstatic int __init ppc460ex_pciex_init_port_hw(struct ppc4xx_pciex_port *port)\r\n{\r\nu32 val;\r\nu32 utlset1;\r\nif (port->endpoint)\r\nval = PTYPE_LEGACY_ENDPOINT << 20;\r\nelse\r\nval = PTYPE_ROOT_PORT << 20;\r\nif (port->index == 0) {\r\nval |= LNKW_X1 << 12;\r\nutlset1 = 0x20000000;\r\n} else {\r\nval |= LNKW_X4 << 12;\r\nutlset1 = 0x20101101;\r\n}\r\nmtdcri(SDR0, port->sdr_base + PESDRn_DLPSET, val);\r\nmtdcri(SDR0, port->sdr_base + PESDRn_UTLSET1, utlset1);\r\nmtdcri(SDR0, port->sdr_base + PESDRn_UTLSET2, 0x01210000);\r\nswitch (port->index) {\r\ncase 0:\r\nmtdcri(SDR0, PESDR0_460EX_L0CDRCTL, 0x00003230);\r\nmtdcri(SDR0, PESDR0_460EX_L0DRV, 0x00000130);\r\nmtdcri(SDR0, PESDR0_460EX_L0CLK, 0x00000006);\r\nmtdcri(SDR0, PESDR0_460EX_PHY_CTL_RST,0x10000000);\r\nbreak;\r\ncase 1:\r\nmtdcri(SDR0, PESDR1_460EX_L0CDRCTL, 0x00003230);\r\nmtdcri(SDR0, PESDR1_460EX_L1CDRCTL, 0x00003230);\r\nmtdcri(SDR0, PESDR1_460EX_L2CDRCTL, 0x00003230);\r\nmtdcri(SDR0, PESDR1_460EX_L3CDRCTL, 0x00003230);\r\nmtdcri(SDR0, PESDR1_460EX_L0DRV, 0x00000130);\r\nmtdcri(SDR0, PESDR1_460EX_L1DRV, 0x00000130);\r\nmtdcri(SDR0, PESDR1_460EX_L2DRV, 0x00000130);\r\nmtdcri(SDR0, PESDR1_460EX_L3DRV, 0x00000130);\r\nmtdcri(SDR0, PESDR1_460EX_L0CLK, 0x00000006);\r\nmtdcri(SDR0, PESDR1_460EX_L1CLK, 0x00000006);\r\nmtdcri(SDR0, PESDR1_460EX_L2CLK, 0x00000006);\r\nmtdcri(SDR0, PESDR1_460EX_L3CLK, 0x00000006);\r\nmtdcri(SDR0, PESDR1_460EX_PHY_CTL_RST,0x10000000);\r\nbreak;\r\n}\r\nmtdcri(SDR0, port->sdr_base + PESDRn_RCSSET,\r\nmfdcri(SDR0, port->sdr_base + PESDRn_RCSSET) |\r\n(PESDRx_RCSSET_RSTGU | PESDRx_RCSSET_RSTPYN));\r\nswitch (port->index) {\r\ncase 0:\r\nwhile (!(mfdcri(SDR0, PESDR0_460EX_RSTSTA) & 0x1))\r\nudelay(10);\r\nbreak;\r\ncase 1:\r\nwhile (!(mfdcri(SDR0, PESDR1_460EX_RSTSTA) & 0x1))\r\nudelay(10);\r\nbreak;\r\n}\r\nmtdcri(SDR0, port->sdr_base + PESDRn_RCSSET,\r\n(mfdcri(SDR0, port->sdr_base + PESDRn_RCSSET) &\r\n~(PESDRx_RCSSET_RSTGU | PESDRx_RCSSET_RSTDL)) |\r\nPESDRx_RCSSET_RSTPYN);\r\nport->has_ibpre = 1;\r\nreturn ppc4xx_pciex_port_reset_sdr(port);\r\n}\r\nstatic int ppc460ex_pciex_init_utl(struct ppc4xx_pciex_port *port)\r\n{\r\ndcr_write(port->dcrs, DCRO_PEGPL_SPECIAL, 0x0);\r\nout_be32(port->utl_base + PEUTL_PBCTL, 0x0800000c);\r\nout_be32(port->utl_base + PEUTL_OUTTR, 0x08000000);\r\nout_be32(port->utl_base + PEUTL_INTR, 0x02000000);\r\nout_be32(port->utl_base + PEUTL_OPDBSZ, 0x04000000);\r\nout_be32(port->utl_base + PEUTL_PBBSZ, 0x00000000);\r\nout_be32(port->utl_base + PEUTL_IPHBSZ, 0x02000000);\r\nout_be32(port->utl_base + PEUTL_IPDBSZ, 0x04000000);\r\nout_be32(port->utl_base + PEUTL_RCIRQEN,0x00f00000);\r\nout_be32(port->utl_base + PEUTL_PCTL, 0x80800066);\r\nreturn 0;\r\n}\r\nstatic int __init apm821xx_pciex_core_init(struct device_node *np)\r\n{\r\nreturn 1;\r\n}\r\nstatic int apm821xx_pciex_init_port_hw(struct ppc4xx_pciex_port *port)\r\n{\r\nu32 val;\r\nmtdcri(SDR0, PESDR0_460EX_PHY_CTL_RST, 0x0);\r\nmdelay(10);\r\nif (port->endpoint)\r\nval = PTYPE_LEGACY_ENDPOINT << 20;\r\nelse\r\nval = PTYPE_ROOT_PORT << 20;\r\nval |= LNKW_X1 << 12;\r\nmtdcri(SDR0, port->sdr_base + PESDRn_DLPSET, val);\r\nmtdcri(SDR0, port->sdr_base + PESDRn_UTLSET1, 0x00000000);\r\nmtdcri(SDR0, port->sdr_base + PESDRn_UTLSET2, 0x01010000);\r\nmtdcri(SDR0, PESDR0_460EX_L0CDRCTL, 0x00003230);\r\nmtdcri(SDR0, PESDR0_460EX_L0DRV, 0x00000130);\r\nmtdcri(SDR0, PESDR0_460EX_L0CLK, 0x00000006);\r\nmtdcri(SDR0, PESDR0_460EX_PHY_CTL_RST, 0x10000000);\r\nmdelay(50);\r\nmtdcri(SDR0, PESDR0_460EX_PHY_CTL_RST, 0x30000000);\r\nmtdcri(SDR0, port->sdr_base + PESDRn_RCSSET,\r\nmfdcri(SDR0, port->sdr_base + PESDRn_RCSSET) |\r\n(PESDRx_RCSSET_RSTGU | PESDRx_RCSSET_RSTPYN));\r\nval = PESDR0_460EX_RSTSTA - port->sdr_base;\r\nif (ppc4xx_pciex_wait_on_sdr(port, val, 0x1, 1, 100)) {\r\nprintk(KERN_WARNING "%s: PCIE: Can't reset PHY\n", __func__);\r\nreturn -EBUSY;\r\n} else {\r\nmtdcri(SDR0, port->sdr_base + PESDRn_RCSSET,\r\n(mfdcri(SDR0, port->sdr_base + PESDRn_RCSSET) &\r\n~(PESDRx_RCSSET_RSTGU | PESDRx_RCSSET_RSTDL)) |\r\nPESDRx_RCSSET_RSTPYN);\r\nport->has_ibpre = 1;\r\nreturn 0;\r\n}\r\n}\r\nstatic int __init ppc460sx_pciex_core_init(struct device_node *np)\r\n{\r\nmtdcri(SDR0, PESDR0_460SX_HSSL0DAMP, 0xB9843211);\r\nmtdcri(SDR0, PESDR0_460SX_HSSL1DAMP, 0xB9843211);\r\nmtdcri(SDR0, PESDR0_460SX_HSSL2DAMP, 0xB9843211);\r\nmtdcri(SDR0, PESDR0_460SX_HSSL3DAMP, 0xB9843211);\r\nmtdcri(SDR0, PESDR0_460SX_HSSL4DAMP, 0xB9843211);\r\nmtdcri(SDR0, PESDR0_460SX_HSSL5DAMP, 0xB9843211);\r\nmtdcri(SDR0, PESDR0_460SX_HSSL6DAMP, 0xB9843211);\r\nmtdcri(SDR0, PESDR0_460SX_HSSL7DAMP, 0xB9843211);\r\nmtdcri(SDR0, PESDR1_460SX_HSSL0DAMP, 0xB9843211);\r\nmtdcri(SDR0, PESDR1_460SX_HSSL1DAMP, 0xB9843211);\r\nmtdcri(SDR0, PESDR1_460SX_HSSL2DAMP, 0xB9843211);\r\nmtdcri(SDR0, PESDR1_460SX_HSSL3DAMP, 0xB9843211);\r\nmtdcri(SDR0, PESDR2_460SX_HSSL0DAMP, 0xB9843211);\r\nmtdcri(SDR0, PESDR2_460SX_HSSL1DAMP, 0xB9843211);\r\nmtdcri(SDR0, PESDR2_460SX_HSSL2DAMP, 0xB9843211);\r\nmtdcri(SDR0, PESDR2_460SX_HSSL3DAMP, 0xB9843211);\r\nmtdcri(SDR0, PESDR0_460SX_HSSL0COEFA, 0xDCB98987);\r\nmtdcri(SDR0, PESDR0_460SX_HSSL1COEFA, 0xDCB98987);\r\nmtdcri(SDR0, PESDR0_460SX_HSSL2COEFA, 0xDCB98987);\r\nmtdcri(SDR0, PESDR0_460SX_HSSL3COEFA, 0xDCB98987);\r\nmtdcri(SDR0, PESDR0_460SX_HSSL4COEFA, 0xDCB98987);\r\nmtdcri(SDR0, PESDR0_460SX_HSSL5COEFA, 0xDCB98987);\r\nmtdcri(SDR0, PESDR0_460SX_HSSL6COEFA, 0xDCB98987);\r\nmtdcri(SDR0, PESDR0_460SX_HSSL7COEFA, 0xDCB98987);\r\nmtdcri(SDR0, PESDR1_460SX_HSSL0COEFA, 0xDCB98987);\r\nmtdcri(SDR0, PESDR1_460SX_HSSL1COEFA, 0xDCB98987);\r\nmtdcri(SDR0, PESDR1_460SX_HSSL2COEFA, 0xDCB98987);\r\nmtdcri(SDR0, PESDR1_460SX_HSSL3COEFA, 0xDCB98987);\r\nmtdcri(SDR0, PESDR2_460SX_HSSL0COEFA, 0xDCB98987);\r\nmtdcri(SDR0, PESDR2_460SX_HSSL1COEFA, 0xDCB98987);\r\nmtdcri(SDR0, PESDR2_460SX_HSSL2COEFA, 0xDCB98987);\r\nmtdcri(SDR0, PESDR2_460SX_HSSL3COEFA, 0xDCB98987);\r\nmtdcri(SDR0, PESDR0_460SX_HSSL1CALDRV, 0x22222222);\r\nmtdcri(SDR0, PESDR1_460SX_HSSL1CALDRV, 0x22220000);\r\nmtdcri(SDR0, PESDR2_460SX_HSSL1CALDRV, 0x22220000);\r\nmtdcri(SDR0, PESDR0_460SX_HSSSLEW, 0xFFFFFFFF);\r\nmtdcri(SDR0, PESDR1_460SX_HSSSLEW, 0xFFFF0000);\r\nmtdcri(SDR0, PESDR2_460SX_HSSSLEW, 0xFFFF0000);\r\nmtdcri(SDR0, PESDR0_460SX_HSSCTLSET, 0x00001130);\r\nmtdcri(SDR0, PESDR2_460SX_HSSCTLSET, 0x00001130);\r\nudelay(100);\r\ndcri_clrset(SDR0, PESDR0_PLLLCT2, 0x00000100, 0);\r\nmtdcri(SDR0, PESDR0_460SX_RCSSET,\r\nPESDRx_RCSSET_RSTDL | PESDRx_RCSSET_RSTGU);\r\nmtdcri(SDR0, PESDR1_460SX_RCSSET,\r\nPESDRx_RCSSET_RSTDL | PESDRx_RCSSET_RSTGU);\r\nmtdcri(SDR0, PESDR2_460SX_RCSSET,\r\nPESDRx_RCSSET_RSTDL | PESDRx_RCSSET_RSTGU);\r\nudelay(100);\r\nif (((mfdcri(SDR0, PESDR1_460SX_HSSCTLSET) & 0x00000001) ==\r\n0x00000001)) {\r\nprintk(KERN_INFO "PCI: PCIE bifurcation setup successfully.\n");\r\nprintk(KERN_INFO "PCI: Total 3 PCIE ports are present\n");\r\nreturn 3;\r\n}\r\nprintk(KERN_INFO "PCI: Total 2 PCIE ports are present\n");\r\nreturn 2;\r\n}\r\nstatic int __init ppc460sx_pciex_init_port_hw(struct ppc4xx_pciex_port *port)\r\n{\r\nif (port->endpoint)\r\ndcri_clrset(SDR0, port->sdr_base + PESDRn_UTLSET2,\r\n0x01000000, 0);\r\nelse\r\ndcri_clrset(SDR0, port->sdr_base + PESDRn_UTLSET2,\r\n0, 0x01000000);\r\ndcri_clrset(SDR0, port->sdr_base + PESDRn_RCSSET,\r\n(PESDRx_RCSSET_RSTGU | PESDRx_RCSSET_RSTDL),\r\nPESDRx_RCSSET_RSTPYN);\r\nport->has_ibpre = 1;\r\nreturn ppc4xx_pciex_port_reset_sdr(port);\r\n}\r\nstatic int ppc460sx_pciex_init_utl(struct ppc4xx_pciex_port *port)\r\n{\r\nout_be32 (port->utl_base + PEUTL_PBBSZ, 0x00000000);\r\nout_be32(port->utl_base + PEUTL_PCTL, 0x80800000);\r\nreturn 0;\r\n}\r\nstatic void __init ppc460sx_pciex_check_link(struct ppc4xx_pciex_port *port)\r\n{\r\nvoid __iomem *mbase;\r\nint attempt = 50;\r\nport->link = 0;\r\nmbase = ioremap(port->cfg_space.start + 0x10000000, 0x1000);\r\nif (mbase == NULL) {\r\nprintk(KERN_ERR "%s: Can't map internal config space !",\r\nport->node->full_name);\r\ngoto done;\r\n}\r\nwhile (attempt && (0 == (in_le32(mbase + PECFG_460SX_DLLSTA)\r\n& PECFG_460SX_DLLSTA_LINKUP))) {\r\nattempt--;\r\nmdelay(10);\r\n}\r\nif (attempt)\r\nport->link = 1;\r\ndone:\r\niounmap(mbase);\r\n}\r\nstatic int __init ppc405ex_pciex_core_init(struct device_node *np)\r\n{\r\nreturn 2;\r\n}\r\nstatic void ppc405ex_pcie_phy_reset(struct ppc4xx_pciex_port *port)\r\n{\r\nmtdcri(SDR0, port->sdr_base + PESDRn_RCSSET, 0x01010000);\r\nmsleep(1);\r\nif (port->endpoint)\r\nmtdcri(SDR0, port->sdr_base + PESDRn_RCSSET, 0x01111000);\r\nelse\r\nmtdcri(SDR0, port->sdr_base + PESDRn_RCSSET, 0x01101000);\r\nwhile (!(mfdcri(SDR0, port->sdr_base + PESDRn_405EX_PHYSTA) & 0x00001000))\r\n;\r\nmtdcri(SDR0, port->sdr_base + PESDRn_RCSSET, 0x00101000);\r\n}\r\nstatic int __init ppc405ex_pciex_init_port_hw(struct ppc4xx_pciex_port *port)\r\n{\r\nu32 val;\r\nif (port->endpoint)\r\nval = PTYPE_LEGACY_ENDPOINT;\r\nelse\r\nval = PTYPE_ROOT_PORT;\r\nmtdcri(SDR0, port->sdr_base + PESDRn_DLPSET,\r\n1 << 24 | val << 20 | LNKW_X1 << 12);\r\nmtdcri(SDR0, port->sdr_base + PESDRn_UTLSET1, 0x00000000);\r\nmtdcri(SDR0, port->sdr_base + PESDRn_UTLSET2, 0x01010000);\r\nmtdcri(SDR0, port->sdr_base + PESDRn_405EX_PHYSET1, 0x720F0000);\r\nmtdcri(SDR0, port->sdr_base + PESDRn_405EX_PHYSET2, 0x70600003);\r\nval = mfdcri(SDR0, port->sdr_base + PESDRn_LOOP);\r\nif (!(val & 0x00001000))\r\nppc405ex_pcie_phy_reset(port);\r\ndcr_write(port->dcrs, DCRO_PEGPL_CFG, 0x10000000);\r\nport->has_ibpre = 1;\r\nreturn ppc4xx_pciex_port_reset_sdr(port);\r\n}\r\nstatic int ppc405ex_pciex_init_utl(struct ppc4xx_pciex_port *port)\r\n{\r\ndcr_write(port->dcrs, DCRO_PEGPL_SPECIAL, 0x0);\r\nout_be32(port->utl_base + PEUTL_OUTTR, 0x02000000);\r\nout_be32(port->utl_base + PEUTL_INTR, 0x02000000);\r\nout_be32(port->utl_base + PEUTL_OPDBSZ, 0x04000000);\r\nout_be32(port->utl_base + PEUTL_PBBSZ, 0x21000000);\r\nout_be32(port->utl_base + PEUTL_IPHBSZ, 0x02000000);\r\nout_be32(port->utl_base + PEUTL_IPDBSZ, 0x04000000);\r\nout_be32(port->utl_base + PEUTL_RCIRQEN, 0x00f00000);\r\nout_be32(port->utl_base + PEUTL_PCTL, 0x80800066);\r\nout_be32(port->utl_base + PEUTL_PBCTL, 0x08000000);\r\nreturn 0;\r\n}\r\nstatic int __init ppc_476fpe_pciex_core_init(struct device_node *np)\r\n{\r\nreturn 4;\r\n}\r\nstatic void __init ppc_476fpe_pciex_check_link(struct ppc4xx_pciex_port *port)\r\n{\r\nu32 timeout_ms = 20;\r\nu32 val = 0, mask = (PECFG_TLDLP_LNKUP|PECFG_TLDLP_PRESENT);\r\nvoid __iomem *mbase = ioremap(port->cfg_space.start + 0x10000000,\r\n0x1000);\r\nprintk(KERN_INFO "PCIE%d: Checking link...\n", port->index);\r\nif (mbase == NULL) {\r\nprintk(KERN_WARNING "PCIE%d: failed to get cfg space\n",\r\nport->index);\r\nreturn;\r\n}\r\nwhile (timeout_ms--) {\r\nval = in_le32(mbase + PECFG_TLDLP);\r\nif ((val & mask) == mask)\r\nbreak;\r\nmsleep(10);\r\n}\r\nif (val & PECFG_TLDLP_PRESENT) {\r\nprintk(KERN_INFO "PCIE%d: link is up !\n", port->index);\r\nport->link = 1;\r\n} else\r\nprintk(KERN_WARNING "PCIE%d: Link up failed\n", port->index);\r\niounmap(mbase);\r\nreturn;\r\n}\r\nstatic int __init ppc4xx_pciex_check_core_init(struct device_node *np)\r\n{\r\nstatic int core_init;\r\nint count = -ENODEV;\r\nif (core_init++)\r\nreturn 0;\r\n#ifdef CONFIG_44x\r\nif (of_device_is_compatible(np, "ibm,plb-pciex-440spe")) {\r\nif (ppc440spe_revA())\r\nppc4xx_pciex_hwops = &ppc440speA_pcie_hwops;\r\nelse\r\nppc4xx_pciex_hwops = &ppc440speB_pcie_hwops;\r\n}\r\nif (of_device_is_compatible(np, "ibm,plb-pciex-460ex"))\r\nppc4xx_pciex_hwops = &ppc460ex_pcie_hwops;\r\nif (of_device_is_compatible(np, "ibm,plb-pciex-460sx"))\r\nppc4xx_pciex_hwops = &ppc460sx_pcie_hwops;\r\nif (of_device_is_compatible(np, "ibm,plb-pciex-apm821xx"))\r\nppc4xx_pciex_hwops = &apm821xx_pcie_hwops;\r\n#endif\r\n#ifdef CONFIG_40x\r\nif (of_device_is_compatible(np, "ibm,plb-pciex-405ex"))\r\nppc4xx_pciex_hwops = &ppc405ex_pcie_hwops;\r\n#endif\r\n#ifdef CONFIG_476FPE\r\nif (of_device_is_compatible(np, "ibm,plb-pciex-476fpe"))\r\nppc4xx_pciex_hwops = &ppc_476fpe_pcie_hwops;\r\n#endif\r\nif (ppc4xx_pciex_hwops == NULL) {\r\nprintk(KERN_WARNING "PCIE: unknown host type %s\n",\r\nnp->full_name);\r\nreturn -ENODEV;\r\n}\r\ncount = ppc4xx_pciex_hwops->core_init(np);\r\nif (count > 0) {\r\nppc4xx_pciex_ports =\r\nkzalloc(count * sizeof(struct ppc4xx_pciex_port),\r\nGFP_KERNEL);\r\nif (ppc4xx_pciex_ports) {\r\nppc4xx_pciex_port_count = count;\r\nreturn 0;\r\n}\r\nprintk(KERN_WARNING "PCIE: failed to allocate ports array\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void __init ppc4xx_pciex_port_init_mapping(struct ppc4xx_pciex_port *port)\r\n{\r\ndcr_write(port->dcrs, DCRO_PEGPL_CFGBAH,\r\nRES_TO_U32_HIGH(port->cfg_space.start));\r\ndcr_write(port->dcrs, DCRO_PEGPL_CFGBAL,\r\nRES_TO_U32_LOW(port->cfg_space.start));\r\ndcr_write(port->dcrs, DCRO_PEGPL_CFGMSK, 0xe0000001);\r\ndcr_write(port->dcrs, DCRO_PEGPL_REGBAH,\r\nRES_TO_U32_HIGH(port->utl_regs.start));\r\ndcr_write(port->dcrs, DCRO_PEGPL_REGBAL,\r\nRES_TO_U32_LOW(port->utl_regs.start));\r\ndcr_write(port->dcrs, DCRO_PEGPL_REGMSK, 0x00007001);\r\ndcr_write(port->dcrs, DCRO_PEGPL_OMR1MSKL, 0);\r\ndcr_write(port->dcrs, DCRO_PEGPL_OMR2MSKL, 0);\r\ndcr_write(port->dcrs, DCRO_PEGPL_OMR3MSKL, 0);\r\ndcr_write(port->dcrs, DCRO_PEGPL_MSGMSK, 0);\r\n}\r\nstatic int __init ppc4xx_pciex_port_init(struct ppc4xx_pciex_port *port)\r\n{\r\nint rc = 0;\r\nif (ppc4xx_pciex_hwops->port_init_hw)\r\nrc = ppc4xx_pciex_hwops->port_init_hw(port);\r\nif (rc != 0)\r\nreturn rc;\r\nppc4xx_pciex_port_init_mapping(port);\r\nif (ppc4xx_pciex_hwops->check_link)\r\nppc4xx_pciex_hwops->check_link(port);\r\nport->utl_base = ioremap(port->utl_regs.start, 0x100);\r\nBUG_ON(port->utl_base == NULL);\r\nif (ppc4xx_pciex_hwops->setup_utl)\r\nppc4xx_pciex_hwops->setup_utl(port);\r\nif (port->sdr_base) {\r\nif (of_device_is_compatible(port->node,\r\n"ibm,plb-pciex-460sx")){\r\nif (port->link && ppc4xx_pciex_wait_on_sdr(port,\r\nPESDRn_RCSSTS,\r\n1 << 12, 1 << 12, 5000)) {\r\nprintk(KERN_INFO "PCIE%d: PLL not locked\n",\r\nport->index);\r\nport->link = 0;\r\n}\r\n} else if (port->link &&\r\nppc4xx_pciex_wait_on_sdr(port, PESDRn_RCSSTS,\r\n1 << 16, 1 << 16, 5000)) {\r\nprintk(KERN_INFO "PCIE%d: VC0 not active\n",\r\nport->index);\r\nport->link = 0;\r\n}\r\ndcri_clrset(SDR0, port->sdr_base + PESDRn_RCSSET, 0, 1 << 20);\r\n}\r\nmsleep(100);\r\nreturn 0;\r\n}\r\nstatic int ppc4xx_pciex_validate_bdf(struct ppc4xx_pciex_port *port,\r\nstruct pci_bus *bus,\r\nunsigned int devfn)\r\n{\r\nstatic int message;\r\nif (port->endpoint && bus->number != port->hose->first_busno)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (bus->number > port->hose->last_busno) {\r\nif (!message) {\r\nprintk(KERN_WARNING "Warning! Probing bus %u"\r\n" out of range !\n", bus->number);\r\nmessage++;\r\n}\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nif (bus->number == port->hose->first_busno && devfn != 0)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (bus->number == (port->hose->first_busno + 1) &&\r\nPCI_SLOT(devfn) != 0)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif ((bus->number != port->hose->first_busno) && !port->link)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nreturn 0;\r\n}\r\nstatic void __iomem *ppc4xx_pciex_get_config_base(struct ppc4xx_pciex_port *port,\r\nstruct pci_bus *bus,\r\nunsigned int devfn)\r\n{\r\nint relbus;\r\nif (bus->number == port->hose->first_busno)\r\nreturn (void __iomem *)port->hose->cfg_addr;\r\nrelbus = bus->number - (port->hose->first_busno + 1);\r\nreturn (void __iomem *)port->hose->cfg_data +\r\n((relbus << 20) | (devfn << 12));\r\n}\r\nstatic int ppc4xx_pciex_read_config(struct pci_bus *bus, unsigned int devfn,\r\nint offset, int len, u32 *val)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nstruct ppc4xx_pciex_port *port =\r\n&ppc4xx_pciex_ports[hose->indirect_type];\r\nvoid __iomem *addr;\r\nu32 gpl_cfg;\r\nBUG_ON(hose != port->hose);\r\nif (ppc4xx_pciex_validate_bdf(port, bus, devfn) != 0)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\naddr = ppc4xx_pciex_get_config_base(port, bus, devfn);\r\ngpl_cfg = dcr_read(port->dcrs, DCRO_PEGPL_CFG);\r\ndcr_write(port->dcrs, DCRO_PEGPL_CFG, gpl_cfg | GPL_DMER_MASK_DISA);\r\nout_be32(port->utl_base + PEUTL_RCSTA, 0x00040000);\r\nswitch (len) {\r\ncase 1:\r\n*val = in_8((u8 *)(addr + offset));\r\nbreak;\r\ncase 2:\r\n*val = in_le16((u16 *)(addr + offset));\r\nbreak;\r\ndefault:\r\n*val = in_le32((u32 *)(addr + offset));\r\nbreak;\r\n}\r\npr_debug("pcie-config-read: bus=%3d [%3d..%3d] devfn=0x%04x"\r\n" offset=0x%04x len=%d, addr=0x%p val=0x%08x\n",\r\nbus->number, hose->first_busno, hose->last_busno,\r\ndevfn, offset, len, addr + offset, *val);\r\nif (in_be32(port->utl_base + PEUTL_RCSTA) & 0x00040000) {\r\npr_debug("Got CRS !\n");\r\nif (len != 4 || offset != 0)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n*val = 0xffff0001;\r\n}\r\ndcr_write(port->dcrs, DCRO_PEGPL_CFG, gpl_cfg);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int ppc4xx_pciex_write_config(struct pci_bus *bus, unsigned int devfn,\r\nint offset, int len, u32 val)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(bus);\r\nstruct ppc4xx_pciex_port *port =\r\n&ppc4xx_pciex_ports[hose->indirect_type];\r\nvoid __iomem *addr;\r\nu32 gpl_cfg;\r\nif (ppc4xx_pciex_validate_bdf(port, bus, devfn) != 0)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\naddr = ppc4xx_pciex_get_config_base(port, bus, devfn);\r\ngpl_cfg = dcr_read(port->dcrs, DCRO_PEGPL_CFG);\r\ndcr_write(port->dcrs, DCRO_PEGPL_CFG, gpl_cfg | GPL_DMER_MASK_DISA);\r\npr_debug("pcie-config-write: bus=%3d [%3d..%3d] devfn=0x%04x"\r\n" offset=0x%04x len=%d, addr=0x%p val=0x%08x\n",\r\nbus->number, hose->first_busno, hose->last_busno,\r\ndevfn, offset, len, addr + offset, val);\r\nswitch (len) {\r\ncase 1:\r\nout_8((u8 *)(addr + offset), val);\r\nbreak;\r\ncase 2:\r\nout_le16((u16 *)(addr + offset), val);\r\nbreak;\r\ndefault:\r\nout_le32((u32 *)(addr + offset), val);\r\nbreak;\r\n}\r\ndcr_write(port->dcrs, DCRO_PEGPL_CFG, gpl_cfg);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int __init ppc4xx_setup_one_pciex_POM(struct ppc4xx_pciex_port *port,\r\nstruct pci_controller *hose,\r\nvoid __iomem *mbase,\r\nu64 plb_addr,\r\nu64 pci_addr,\r\nu64 size,\r\nunsigned int flags,\r\nint index)\r\n{\r\nu32 lah, lal, pciah, pcial, sa;\r\nif (!is_power_of_2(size) ||\r\n(index < 2 && size < 0x100000) ||\r\n(index == 2 && size < 0x100) ||\r\n(plb_addr & (size - 1)) != 0) {\r\nprintk(KERN_WARNING "%s: Resource out of range\n",\r\nhose->dn->full_name);\r\nreturn -1;\r\n}\r\nlah = RES_TO_U32_HIGH(plb_addr);\r\nlal = RES_TO_U32_LOW(plb_addr);\r\npciah = RES_TO_U32_HIGH(pci_addr);\r\npcial = RES_TO_U32_LOW(pci_addr);\r\nsa = (0xffffffffu << ilog2(size)) | 0x1;\r\nswitch (index) {\r\ncase 0:\r\nout_le32(mbase + PECFG_POM0LAH, pciah);\r\nout_le32(mbase + PECFG_POM0LAL, pcial);\r\ndcr_write(port->dcrs, DCRO_PEGPL_OMR1BAH, lah);\r\ndcr_write(port->dcrs, DCRO_PEGPL_OMR1BAL, lal);\r\ndcr_write(port->dcrs, DCRO_PEGPL_OMR1MSKH, 0x7fffffff);\r\nif (of_device_is_compatible(port->node, "ibm,plb-pciex-460sx"))\r\ndcr_write(port->dcrs, DCRO_PEGPL_OMR1MSKL,\r\nsa | DCRO_PEGPL_460SX_OMR1MSKL_UOT\r\n| DCRO_PEGPL_OMRxMSKL_VAL);\r\nelse if (of_device_is_compatible(port->node, "ibm,plb-pciex-476fpe"))\r\ndcr_write(port->dcrs, DCRO_PEGPL_OMR1MSKL,\r\nsa | DCRO_PEGPL_476FPE_OMR1MSKL_UOT\r\n| DCRO_PEGPL_OMRxMSKL_VAL);\r\nelse\r\ndcr_write(port->dcrs, DCRO_PEGPL_OMR1MSKL,\r\nsa | DCRO_PEGPL_OMR1MSKL_UOT\r\n| DCRO_PEGPL_OMRxMSKL_VAL);\r\nbreak;\r\ncase 1:\r\nout_le32(mbase + PECFG_POM1LAH, pciah);\r\nout_le32(mbase + PECFG_POM1LAL, pcial);\r\ndcr_write(port->dcrs, DCRO_PEGPL_OMR2BAH, lah);\r\ndcr_write(port->dcrs, DCRO_PEGPL_OMR2BAL, lal);\r\ndcr_write(port->dcrs, DCRO_PEGPL_OMR2MSKH, 0x7fffffff);\r\ndcr_write(port->dcrs, DCRO_PEGPL_OMR2MSKL,\r\nsa | DCRO_PEGPL_OMRxMSKL_VAL);\r\nbreak;\r\ncase 2:\r\nout_le32(mbase + PECFG_POM2LAH, pciah);\r\nout_le32(mbase + PECFG_POM2LAL, pcial);\r\ndcr_write(port->dcrs, DCRO_PEGPL_OMR3BAH, lah);\r\ndcr_write(port->dcrs, DCRO_PEGPL_OMR3BAL, lal);\r\ndcr_write(port->dcrs, DCRO_PEGPL_OMR3MSKH, 0x7fffffff);\r\ndcr_write(port->dcrs, DCRO_PEGPL_OMR3MSKL,\r\nsa | DCRO_PEGPL_OMR3MSKL_IO\r\n| DCRO_PEGPL_OMRxMSKL_VAL);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init ppc4xx_configure_pciex_POMs(struct ppc4xx_pciex_port *port,\r\nstruct pci_controller *hose,\r\nvoid __iomem *mbase)\r\n{\r\nint i, j, found_isa_hole = 0;\r\nfor (i = j = 0; i < 3; i++) {\r\nstruct resource *res = &hose->mem_resources[i];\r\nresource_size_t offset = hose->mem_offset[i];\r\nif (!(res->flags & IORESOURCE_MEM))\r\ncontinue;\r\nif (j > 1) {\r\nprintk(KERN_WARNING "%s: Too many ranges\n",\r\nport->node->full_name);\r\nbreak;\r\n}\r\nif (ppc4xx_setup_one_pciex_POM(port, hose, mbase,\r\nres->start,\r\nres->start - offset,\r\nresource_size(res),\r\nres->flags,\r\nj) == 0) {\r\nj++;\r\nif (res->start == offset)\r\nfound_isa_hole = 1;\r\n}\r\n}\r\nif (j <= 1 && !found_isa_hole && hose->isa_mem_size)\r\nif (ppc4xx_setup_one_pciex_POM(port, hose, mbase,\r\nhose->isa_mem_phys, 0,\r\nhose->isa_mem_size, 0, j) == 0)\r\nprintk(KERN_INFO "%s: Legacy ISA memory support enabled\n",\r\nhose->dn->full_name);\r\nif (hose->io_resource.flags & IORESOURCE_IO)\r\nppc4xx_setup_one_pciex_POM(port, hose, mbase,\r\nhose->io_base_phys, 0,\r\n0x10000, IORESOURCE_IO, 2);\r\n}\r\nstatic void __init ppc4xx_configure_pciex_PIMs(struct ppc4xx_pciex_port *port,\r\nstruct pci_controller *hose,\r\nvoid __iomem *mbase,\r\nstruct resource *res)\r\n{\r\nresource_size_t size = resource_size(res);\r\nu64 sa;\r\nif (port->endpoint) {\r\nresource_size_t ep_addr = 0;\r\nresource_size_t ep_size = 32 << 20;\r\nsa = (0xffffffffffffffffull << ilog2(ep_size));\r\nout_le32(mbase + PECFG_BAR0HMPA, RES_TO_U32_HIGH(sa));\r\nout_le32(mbase + PECFG_BAR0LMPA, RES_TO_U32_LOW(sa) |\r\nPCI_BASE_ADDRESS_MEM_TYPE_64);\r\nout_le32(mbase + PECFG_BAR1MPA, 0);\r\nout_le32(mbase + PECFG_BAR2HMPA, 0);\r\nout_le32(mbase + PECFG_BAR2LMPA, 0);\r\nout_le32(mbase + PECFG_PIM01SAH, RES_TO_U32_HIGH(sa));\r\nout_le32(mbase + PECFG_PIM01SAL, RES_TO_U32_LOW(sa));\r\nout_le32(mbase + PCI_BASE_ADDRESS_0, RES_TO_U32_LOW(ep_addr));\r\nout_le32(mbase + PCI_BASE_ADDRESS_1, RES_TO_U32_HIGH(ep_addr));\r\n} else {\r\nsa = (0xffffffffffffffffull << ilog2(size));\r\nif (res->flags & IORESOURCE_PREFETCH)\r\nsa |= PCI_BASE_ADDRESS_MEM_PREFETCH;\r\nif (of_device_is_compatible(port->node, "ibm,plb-pciex-460sx") ||\r\nof_device_is_compatible(port->node, "ibm,plb-pciex-476fpe"))\r\nsa |= PCI_BASE_ADDRESS_MEM_TYPE_64;\r\nout_le32(mbase + PECFG_BAR0HMPA, RES_TO_U32_HIGH(sa));\r\nout_le32(mbase + PECFG_BAR0LMPA, RES_TO_U32_LOW(sa));\r\nout_le32(mbase + PECFG_PIM0LAL, 0x00000000);\r\nout_le32(mbase + PECFG_PIM0LAH, 0x00000000);\r\nout_le32(mbase + PECFG_PIM1LAL, 0x00000000);\r\nout_le32(mbase + PECFG_PIM1LAH, 0x00000000);\r\nout_le32(mbase + PECFG_PIM01SAH, 0xffff0000);\r\nout_le32(mbase + PECFG_PIM01SAL, 0x00000000);\r\nout_le32(mbase + PCI_BASE_ADDRESS_0, RES_TO_U32_LOW(res->start));\r\nout_le32(mbase + PCI_BASE_ADDRESS_1, RES_TO_U32_HIGH(res->start));\r\n}\r\nout_le32(mbase + PECFG_PIMEN, 0x1);\r\nout_le16(mbase + PCI_COMMAND,\r\nin_le16(mbase + PCI_COMMAND) |\r\nPCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);\r\n}\r\nstatic void __init ppc4xx_pciex_port_setup_hose(struct ppc4xx_pciex_port *port)\r\n{\r\nstruct resource dma_window;\r\nstruct pci_controller *hose = NULL;\r\nconst int *bus_range;\r\nint primary = 0, busses;\r\nvoid __iomem *mbase = NULL, *cfg_data = NULL;\r\nconst u32 *pval;\r\nu32 val;\r\nif (of_get_property(port->node, "primary", NULL))\r\nprimary = 1;\r\nbus_range = of_get_property(port->node, "bus-range", NULL);\r\nhose = pcibios_alloc_controller(port->node);\r\nif (!hose)\r\ngoto fail;\r\nhose->indirect_type = port->index;\r\nhose->first_busno = bus_range ? bus_range[0] : 0x0;\r\nhose->last_busno = bus_range ? bus_range[1] : 0xff;\r\nbusses = hose->last_busno - hose->first_busno;\r\nif (busses > MAX_PCIE_BUS_MAPPED) {\r\nbusses = MAX_PCIE_BUS_MAPPED;\r\nhose->last_busno = hose->first_busno + busses;\r\n}\r\nif (!port->endpoint) {\r\ncfg_data = ioremap(port->cfg_space.start +\r\n(hose->first_busno + 1) * 0x100000,\r\nbusses * 0x100000);\r\nif (cfg_data == NULL) {\r\nprintk(KERN_ERR "%s: Can't map external config space !",\r\nport->node->full_name);\r\ngoto fail;\r\n}\r\nhose->cfg_data = cfg_data;\r\n}\r\nmbase = ioremap(port->cfg_space.start + 0x10000000, 0x1000);\r\nif (mbase == NULL) {\r\nprintk(KERN_ERR "%s: Can't map internal config space !",\r\nport->node->full_name);\r\ngoto fail;\r\n}\r\nhose->cfg_addr = mbase;\r\npr_debug("PCIE %s, bus %d..%d\n", port->node->full_name,\r\nhose->first_busno, hose->last_busno);\r\npr_debug(" config space mapped at: root @0x%p, other @0x%p\n",\r\nhose->cfg_addr, hose->cfg_data);\r\nhose->ops = &ppc4xx_pciex_pci_ops;\r\nport->hose = hose;\r\nmbase = (void __iomem *)hose->cfg_addr;\r\nif (!port->endpoint) {\r\nout_8(mbase + PCI_PRIMARY_BUS, hose->first_busno);\r\nout_8(mbase + PCI_SECONDARY_BUS, hose->first_busno + 1);\r\nout_8(mbase + PCI_SUBORDINATE_BUS, hose->last_busno);\r\n}\r\nout_le32(mbase + PECFG_PIMEN, 0);\r\npci_process_bridge_OF_ranges(hose, port->node, primary);\r\nif (ppc4xx_parse_dma_ranges(hose, mbase, &dma_window) != 0)\r\ngoto fail;\r\nppc4xx_configure_pciex_POMs(port, hose, mbase);\r\nppc4xx_configure_pciex_PIMs(port, hose, mbase, &dma_window);\r\npval = of_get_property(port->node, "vendor-id", NULL);\r\nif (pval) {\r\nval = *pval;\r\n} else {\r\nif (!port->endpoint)\r\nval = 0xaaa0 + port->index;\r\nelse\r\nval = 0xeee0 + port->index;\r\n}\r\nout_le16(mbase + 0x200, val);\r\npval = of_get_property(port->node, "device-id", NULL);\r\nif (pval) {\r\nval = *pval;\r\n} else {\r\nif (!port->endpoint)\r\nval = 0xbed0 + port->index;\r\nelse\r\nval = 0xfed0 + port->index;\r\n}\r\nout_le16(mbase + 0x202, val);\r\nif (of_device_is_compatible(port->node, "ibm,plb-pciex-460sx"))\r\nout_le16(mbase + 0x204, 0x7);\r\nif (!port->endpoint) {\r\nout_le32(mbase + 0x208, 0x06040001);\r\nprintk(KERN_INFO "PCIE%d: successfully set as root-complex\n",\r\nport->index);\r\n} else {\r\nout_le32(mbase + 0x208, 0x0b200001);\r\nprintk(KERN_INFO "PCIE%d: successfully set as endpoint\n",\r\nport->index);\r\n}\r\nreturn;\r\nfail:\r\nif (hose)\r\npcibios_free_controller(hose);\r\nif (cfg_data)\r\niounmap(cfg_data);\r\nif (mbase)\r\niounmap(mbase);\r\n}\r\nstatic void __init ppc4xx_probe_pciex_bridge(struct device_node *np)\r\n{\r\nstruct ppc4xx_pciex_port *port;\r\nconst u32 *pval;\r\nint portno;\r\nunsigned int dcrs;\r\nconst char *val;\r\nif (ppc4xx_pciex_check_core_init(np))\r\nreturn;\r\npval = of_get_property(np, "port", NULL);\r\nif (pval == NULL) {\r\nprintk(KERN_ERR "PCIE: Can't find port number for %s\n",\r\nnp->full_name);\r\nreturn;\r\n}\r\nportno = *pval;\r\nif (portno >= ppc4xx_pciex_port_count) {\r\nprintk(KERN_ERR "PCIE: port number out of range for %s\n",\r\nnp->full_name);\r\nreturn;\r\n}\r\nport = &ppc4xx_pciex_ports[portno];\r\nport->index = portno;\r\nif (!of_device_is_available(np)) {\r\nprintk(KERN_INFO "PCIE%d: Port disabled via device-tree\n", port->index);\r\nreturn;\r\n}\r\nport->node = of_node_get(np);\r\nif (ppc4xx_pciex_hwops->want_sdr) {\r\npval = of_get_property(np, "sdr-base", NULL);\r\nif (pval == NULL) {\r\nprintk(KERN_ERR "PCIE: missing sdr-base for %s\n",\r\nnp->full_name);\r\nreturn;\r\n}\r\nport->sdr_base = *pval;\r\n}\r\nval = of_get_property(port->node, "device_type", NULL);\r\nif (!strcmp(val, "pci-endpoint")) {\r\nport->endpoint = 1;\r\n} else if (!strcmp(val, "pci")) {\r\nport->endpoint = 0;\r\n} else {\r\nprintk(KERN_ERR "PCIE: missing or incorrect device_type for %s\n",\r\nnp->full_name);\r\nreturn;\r\n}\r\nif (of_address_to_resource(np, 0, &port->cfg_space)) {\r\nprintk(KERN_ERR "%s: Can't get PCI-E config space !",\r\nnp->full_name);\r\nreturn;\r\n}\r\nif (of_address_to_resource(np, 1, &port->utl_regs)) {\r\nprintk(KERN_ERR "%s: Can't get UTL register base !",\r\nnp->full_name);\r\nreturn;\r\n}\r\ndcrs = dcr_resource_start(np, 0);\r\nif (dcrs == 0) {\r\nprintk(KERN_ERR "%s: Can't get DCR register base !",\r\nnp->full_name);\r\nreturn;\r\n}\r\nport->dcrs = dcr_map(np, dcrs, dcr_resource_len(np, 0));\r\nif (ppc4xx_pciex_port_init(port)) {\r\nprintk(KERN_WARNING "PCIE%d: Port init failed\n", port->index);\r\nreturn;\r\n}\r\nppc4xx_pciex_port_setup_hose(port);\r\n}\r\nstatic int __init ppc4xx_pci_find_bridges(void)\r\n{\r\nstruct device_node *np;\r\npci_add_flags(PCI_ENABLE_PROC_DOMAINS | PCI_COMPAT_DOMAIN_0);\r\n#ifdef CONFIG_PPC4xx_PCI_EXPRESS\r\nfor_each_compatible_node(np, NULL, "ibm,plb-pciex")\r\nppc4xx_probe_pciex_bridge(np);\r\n#endif\r\nfor_each_compatible_node(np, NULL, "ibm,plb-pcix")\r\nppc4xx_probe_pcix_bridge(np);\r\nfor_each_compatible_node(np, NULL, "ibm,plb-pci")\r\nppc4xx_probe_pci_bridge(np);\r\nreturn 0;\r\n}
