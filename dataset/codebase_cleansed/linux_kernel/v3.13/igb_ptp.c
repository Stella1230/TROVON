static cycle_t igb_ptp_read_82576(const struct cyclecounter *cc)\r\n{\r\nstruct igb_adapter *igb = container_of(cc, struct igb_adapter, cc);\r\nstruct e1000_hw *hw = &igb->hw;\r\nu64 val;\r\nu32 lo, hi;\r\nlo = rd32(E1000_SYSTIML);\r\nhi = rd32(E1000_SYSTIMH);\r\nval = ((u64) hi) << 32;\r\nval |= lo;\r\nreturn val;\r\n}\r\nstatic cycle_t igb_ptp_read_82580(const struct cyclecounter *cc)\r\n{\r\nstruct igb_adapter *igb = container_of(cc, struct igb_adapter, cc);\r\nstruct e1000_hw *hw = &igb->hw;\r\nu32 lo, hi;\r\nu64 val;\r\nrd32(E1000_SYSTIMR);\r\nlo = rd32(E1000_SYSTIML);\r\nhi = rd32(E1000_SYSTIMH);\r\nval = ((u64) hi) << 32;\r\nval |= lo;\r\nreturn val;\r\n}\r\nstatic void igb_ptp_read_i210(struct igb_adapter *adapter, struct timespec *ts)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 sec, nsec;\r\nrd32(E1000_SYSTIMR);\r\nnsec = rd32(E1000_SYSTIML);\r\nsec = rd32(E1000_SYSTIMH);\r\nts->tv_sec = sec;\r\nts->tv_nsec = nsec;\r\n}\r\nstatic void igb_ptp_write_i210(struct igb_adapter *adapter,\r\nconst struct timespec *ts)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nwr32(E1000_SYSTIML, ts->tv_nsec);\r\nwr32(E1000_SYSTIMH, ts->tv_sec);\r\n}\r\nstatic void igb_ptp_systim_to_hwtstamp(struct igb_adapter *adapter,\r\nstruct skb_shared_hwtstamps *hwtstamps,\r\nu64 systim)\r\n{\r\nunsigned long flags;\r\nu64 ns;\r\nswitch (adapter->hw.mac.type) {\r\ncase e1000_82576:\r\ncase e1000_82580:\r\ncase e1000_i354:\r\ncase e1000_i350:\r\nspin_lock_irqsave(&adapter->tmreg_lock, flags);\r\nns = timecounter_cyc2time(&adapter->tc, systim);\r\nspin_unlock_irqrestore(&adapter->tmreg_lock, flags);\r\nmemset(hwtstamps, 0, sizeof(*hwtstamps));\r\nhwtstamps->hwtstamp = ns_to_ktime(ns);\r\nbreak;\r\ncase e1000_i210:\r\ncase e1000_i211:\r\nmemset(hwtstamps, 0, sizeof(*hwtstamps));\r\nhwtstamps->hwtstamp = ktime_set(systim >> 32,\r\nsystim & 0xFFFFFFFF);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int igb_ptp_adjfreq_82576(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\r\nptp_caps);\r\nstruct e1000_hw *hw = &igb->hw;\r\nint neg_adj = 0;\r\nu64 rate;\r\nu32 incvalue;\r\nif (ppb < 0) {\r\nneg_adj = 1;\r\nppb = -ppb;\r\n}\r\nrate = ppb;\r\nrate <<= 14;\r\nrate = div_u64(rate, 1953125);\r\nincvalue = 16 << IGB_82576_TSYNC_SHIFT;\r\nif (neg_adj)\r\nincvalue -= rate;\r\nelse\r\nincvalue += rate;\r\nwr32(E1000_TIMINCA, INCPERIOD_82576 | (incvalue & INCVALUE_82576_MASK));\r\nreturn 0;\r\n}\r\nstatic int igb_ptp_adjfreq_82580(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\r\nptp_caps);\r\nstruct e1000_hw *hw = &igb->hw;\r\nint neg_adj = 0;\r\nu64 rate;\r\nu32 inca;\r\nif (ppb < 0) {\r\nneg_adj = 1;\r\nppb = -ppb;\r\n}\r\nrate = ppb;\r\nrate <<= 26;\r\nrate = div_u64(rate, 1953125);\r\ninca = rate & INCVALUE_MASK;\r\nif (neg_adj)\r\ninca |= ISGN;\r\nwr32(E1000_TIMINCA, inca);\r\nreturn 0;\r\n}\r\nstatic int igb_ptp_adjtime_82576(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\r\nptp_caps);\r\nunsigned long flags;\r\ns64 now;\r\nspin_lock_irqsave(&igb->tmreg_lock, flags);\r\nnow = timecounter_read(&igb->tc);\r\nnow += delta;\r\ntimecounter_init(&igb->tc, &igb->cc, now);\r\nspin_unlock_irqrestore(&igb->tmreg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int igb_ptp_adjtime_i210(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\r\nptp_caps);\r\nunsigned long flags;\r\nstruct timespec now, then = ns_to_timespec(delta);\r\nspin_lock_irqsave(&igb->tmreg_lock, flags);\r\nigb_ptp_read_i210(igb, &now);\r\nnow = timespec_add(now, then);\r\nigb_ptp_write_i210(igb, (const struct timespec *)&now);\r\nspin_unlock_irqrestore(&igb->tmreg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int igb_ptp_gettime_82576(struct ptp_clock_info *ptp,\r\nstruct timespec *ts)\r\n{\r\nstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\r\nptp_caps);\r\nunsigned long flags;\r\nu64 ns;\r\nu32 remainder;\r\nspin_lock_irqsave(&igb->tmreg_lock, flags);\r\nns = timecounter_read(&igb->tc);\r\nspin_unlock_irqrestore(&igb->tmreg_lock, flags);\r\nts->tv_sec = div_u64_rem(ns, 1000000000, &remainder);\r\nts->tv_nsec = remainder;\r\nreturn 0;\r\n}\r\nstatic int igb_ptp_gettime_i210(struct ptp_clock_info *ptp,\r\nstruct timespec *ts)\r\n{\r\nstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\r\nptp_caps);\r\nunsigned long flags;\r\nspin_lock_irqsave(&igb->tmreg_lock, flags);\r\nigb_ptp_read_i210(igb, ts);\r\nspin_unlock_irqrestore(&igb->tmreg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int igb_ptp_settime_82576(struct ptp_clock_info *ptp,\r\nconst struct timespec *ts)\r\n{\r\nstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\r\nptp_caps);\r\nunsigned long flags;\r\nu64 ns;\r\nns = ts->tv_sec * 1000000000ULL;\r\nns += ts->tv_nsec;\r\nspin_lock_irqsave(&igb->tmreg_lock, flags);\r\ntimecounter_init(&igb->tc, &igb->cc, ns);\r\nspin_unlock_irqrestore(&igb->tmreg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int igb_ptp_settime_i210(struct ptp_clock_info *ptp,\r\nconst struct timespec *ts)\r\n{\r\nstruct igb_adapter *igb = container_of(ptp, struct igb_adapter,\r\nptp_caps);\r\nunsigned long flags;\r\nspin_lock_irqsave(&igb->tmreg_lock, flags);\r\nigb_ptp_write_i210(igb, ts);\r\nspin_unlock_irqrestore(&igb->tmreg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int igb_ptp_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq, int on)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nvoid igb_ptp_tx_work(struct work_struct *work)\r\n{\r\nstruct igb_adapter *adapter = container_of(work, struct igb_adapter,\r\nptp_tx_work);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu32 tsynctxctl;\r\nif (!adapter->ptp_tx_skb)\r\nreturn;\r\nif (time_is_before_jiffies(adapter->ptp_tx_start +\r\nIGB_PTP_TX_TIMEOUT)) {\r\ndev_kfree_skb_any(adapter->ptp_tx_skb);\r\nadapter->ptp_tx_skb = NULL;\r\nadapter->tx_hwtstamp_timeouts++;\r\ndev_warn(&adapter->pdev->dev, "clearing Tx timestamp hang");\r\nreturn;\r\n}\r\ntsynctxctl = rd32(E1000_TSYNCTXCTL);\r\nif (tsynctxctl & E1000_TSYNCTXCTL_VALID)\r\nigb_ptp_tx_hwtstamp(adapter);\r\nelse\r\nschedule_work(&adapter->ptp_tx_work);\r\n}\r\nstatic void igb_ptp_overflow_check(struct work_struct *work)\r\n{\r\nstruct igb_adapter *igb =\r\ncontainer_of(work, struct igb_adapter, ptp_overflow_work.work);\r\nstruct timespec ts;\r\nigb->ptp_caps.gettime(&igb->ptp_caps, &ts);\r\npr_debug("igb overflow check at %ld.%09lu\n", ts.tv_sec, ts.tv_nsec);\r\nschedule_delayed_work(&igb->ptp_overflow_work,\r\nIGB_SYSTIM_OVERFLOW_PERIOD);\r\n}\r\nvoid igb_ptp_rx_hang(struct igb_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct igb_ring *rx_ring;\r\nu32 tsyncrxctl = rd32(E1000_TSYNCRXCTL);\r\nunsigned long rx_event;\r\nint n;\r\nif (hw->mac.type != e1000_82576)\r\nreturn;\r\nif (!(tsyncrxctl & E1000_TSYNCRXCTL_VALID)) {\r\nadapter->last_rx_ptp_check = jiffies;\r\nreturn;\r\n}\r\nrx_event = adapter->last_rx_ptp_check;\r\nfor (n = 0; n < adapter->num_rx_queues; n++) {\r\nrx_ring = adapter->rx_ring[n];\r\nif (time_after(rx_ring->last_rx_timestamp, rx_event))\r\nrx_event = rx_ring->last_rx_timestamp;\r\n}\r\nif (time_is_before_jiffies(rx_event + 5 * HZ)) {\r\nrd32(E1000_RXSTMPH);\r\nadapter->last_rx_ptp_check = jiffies;\r\nadapter->rx_hwtstamp_cleared++;\r\ndev_warn(&adapter->pdev->dev, "clearing Rx timestamp hang");\r\n}\r\n}\r\nvoid igb_ptp_tx_hwtstamp(struct igb_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct skb_shared_hwtstamps shhwtstamps;\r\nu64 regval;\r\nregval = rd32(E1000_TXSTMPL);\r\nregval |= (u64)rd32(E1000_TXSTMPH) << 32;\r\nigb_ptp_systim_to_hwtstamp(adapter, &shhwtstamps, regval);\r\nskb_tstamp_tx(adapter->ptp_tx_skb, &shhwtstamps);\r\ndev_kfree_skb_any(adapter->ptp_tx_skb);\r\nadapter->ptp_tx_skb = NULL;\r\n}\r\nvoid igb_ptp_rx_pktstamp(struct igb_q_vector *q_vector,\r\nunsigned char *va,\r\nstruct sk_buff *skb)\r\n{\r\n__le64 *regval = (__le64 *)va;\r\nigb_ptp_systim_to_hwtstamp(q_vector->adapter, skb_hwtstamps(skb),\r\nle64_to_cpu(regval[1]));\r\n}\r\nvoid igb_ptp_rx_rgtstamp(struct igb_q_vector *q_vector,\r\nstruct sk_buff *skb)\r\n{\r\nstruct igb_adapter *adapter = q_vector->adapter;\r\nstruct e1000_hw *hw = &adapter->hw;\r\nu64 regval;\r\nif (!(rd32(E1000_TSYNCRXCTL) & E1000_TSYNCRXCTL_VALID))\r\nreturn;\r\nregval = rd32(E1000_RXSTMPL);\r\nregval |= (u64)rd32(E1000_RXSTMPH) << 32;\r\nigb_ptp_systim_to_hwtstamp(adapter, skb_hwtstamps(skb), regval);\r\n}\r\nint igb_ptp_hwtstamp_ioctl(struct net_device *netdev,\r\nstruct ifreq *ifr, int cmd)\r\n{\r\nstruct igb_adapter *adapter = netdev_priv(netdev);\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct hwtstamp_config config;\r\nu32 tsync_tx_ctl = E1000_TSYNCTXCTL_ENABLED;\r\nu32 tsync_rx_ctl = E1000_TSYNCRXCTL_ENABLED;\r\nu32 tsync_rx_cfg = 0;\r\nbool is_l4 = false;\r\nbool is_l2 = false;\r\nu32 regval;\r\nif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\r\nreturn -EFAULT;\r\nif (config.flags)\r\nreturn -EINVAL;\r\nswitch (config.tx_type) {\r\ncase HWTSTAMP_TX_OFF:\r\ntsync_tx_ctl = 0;\r\ncase HWTSTAMP_TX_ON:\r\nbreak;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\nswitch (config.rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\ntsync_rx_ctl = 0;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\r\ntsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L4_V1;\r\ntsync_rx_cfg = E1000_TSYNCRXCFG_PTP_V1_SYNC_MESSAGE;\r\nis_l4 = true;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\r\ntsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_L4_V1;\r\ntsync_rx_cfg = E1000_TSYNCRXCFG_PTP_V1_DELAY_REQ_MESSAGE;\r\nis_l4 = true;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\r\ntsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_EVENT_V2;\r\nconfig.rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\r\nis_l2 = true;\r\nis_l4 = true;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\r\ncase HWTSTAMP_FILTER_ALL:\r\nif (hw->mac.type != e1000_82576) {\r\ntsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_ALL;\r\nconfig.rx_filter = HWTSTAMP_FILTER_ALL;\r\nbreak;\r\n}\r\ndefault:\r\nconfig.rx_filter = HWTSTAMP_FILTER_NONE;\r\nreturn -ERANGE;\r\n}\r\nif (hw->mac.type == e1000_82575) {\r\nif (tsync_rx_ctl | tsync_tx_ctl)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nif ((hw->mac.type >= e1000_82580) && tsync_rx_ctl) {\r\ntsync_rx_ctl = E1000_TSYNCRXCTL_ENABLED;\r\ntsync_rx_ctl |= E1000_TSYNCRXCTL_TYPE_ALL;\r\nconfig.rx_filter = HWTSTAMP_FILTER_ALL;\r\nis_l2 = true;\r\nis_l4 = true;\r\nif ((hw->mac.type == e1000_i210) ||\r\n(hw->mac.type == e1000_i211)) {\r\nregval = rd32(E1000_RXPBS);\r\nregval |= E1000_RXPBS_CFG_TS_EN;\r\nwr32(E1000_RXPBS, regval);\r\n}\r\n}\r\nregval = rd32(E1000_TSYNCTXCTL);\r\nregval &= ~E1000_TSYNCTXCTL_ENABLED;\r\nregval |= tsync_tx_ctl;\r\nwr32(E1000_TSYNCTXCTL, regval);\r\nregval = rd32(E1000_TSYNCRXCTL);\r\nregval &= ~(E1000_TSYNCRXCTL_ENABLED | E1000_TSYNCRXCTL_TYPE_MASK);\r\nregval |= tsync_rx_ctl;\r\nwr32(E1000_TSYNCRXCTL, regval);\r\nwr32(E1000_TSYNCRXCFG, tsync_rx_cfg);\r\nif (is_l2)\r\nwr32(E1000_ETQF(3),\r\n(E1000_ETQF_FILTER_ENABLE |\r\nE1000_ETQF_1588 |\r\nETH_P_1588));\r\nelse\r\nwr32(E1000_ETQF(3), 0);\r\nif (is_l4) {\r\nu32 ftqf = (IPPROTO_UDP\r\n| E1000_FTQF_VF_BP\r\n| E1000_FTQF_1588_TIME_STAMP\r\n| E1000_FTQF_MASK);\r\nftqf &= ~E1000_FTQF_MASK_PROTO_BP;\r\nwr32(E1000_IMIR(3), htons(PTP_EV_PORT));\r\nwr32(E1000_IMIREXT(3),\r\n(E1000_IMIREXT_SIZE_BP | E1000_IMIREXT_CTRL_BP));\r\nif (hw->mac.type == e1000_82576) {\r\nwr32(E1000_SPQF(3), htons(PTP_EV_PORT));\r\nftqf &= ~E1000_FTQF_MASK_SOURCE_PORT_BP;\r\n}\r\nwr32(E1000_FTQF(3), ftqf);\r\n} else {\r\nwr32(E1000_FTQF(3), E1000_FTQF_MASK);\r\n}\r\nwrfl();\r\nregval = rd32(E1000_TXSTMPL);\r\nregval = rd32(E1000_TXSTMPH);\r\nregval = rd32(E1000_RXSTMPL);\r\nregval = rd32(E1000_RXSTMPH);\r\nreturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\r\n-EFAULT : 0;\r\n}\r\nvoid igb_ptp_init(struct igb_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nstruct net_device *netdev = adapter->netdev;\r\nswitch (hw->mac.type) {\r\ncase e1000_82576:\r\nsnprintf(adapter->ptp_caps.name, 16, "%pm", netdev->dev_addr);\r\nadapter->ptp_caps.owner = THIS_MODULE;\r\nadapter->ptp_caps.max_adj = 999999881;\r\nadapter->ptp_caps.n_ext_ts = 0;\r\nadapter->ptp_caps.pps = 0;\r\nadapter->ptp_caps.adjfreq = igb_ptp_adjfreq_82576;\r\nadapter->ptp_caps.adjtime = igb_ptp_adjtime_82576;\r\nadapter->ptp_caps.gettime = igb_ptp_gettime_82576;\r\nadapter->ptp_caps.settime = igb_ptp_settime_82576;\r\nadapter->ptp_caps.enable = igb_ptp_enable;\r\nadapter->cc.read = igb_ptp_read_82576;\r\nadapter->cc.mask = CLOCKSOURCE_MASK(64);\r\nadapter->cc.mult = 1;\r\nadapter->cc.shift = IGB_82576_TSYNC_SHIFT;\r\nwr32(E1000_TIMINCA, INCPERIOD_82576 | INCVALUE_82576);\r\nbreak;\r\ncase e1000_82580:\r\ncase e1000_i354:\r\ncase e1000_i350:\r\nsnprintf(adapter->ptp_caps.name, 16, "%pm", netdev->dev_addr);\r\nadapter->ptp_caps.owner = THIS_MODULE;\r\nadapter->ptp_caps.max_adj = 62499999;\r\nadapter->ptp_caps.n_ext_ts = 0;\r\nadapter->ptp_caps.pps = 0;\r\nadapter->ptp_caps.adjfreq = igb_ptp_adjfreq_82580;\r\nadapter->ptp_caps.adjtime = igb_ptp_adjtime_82576;\r\nadapter->ptp_caps.gettime = igb_ptp_gettime_82576;\r\nadapter->ptp_caps.settime = igb_ptp_settime_82576;\r\nadapter->ptp_caps.enable = igb_ptp_enable;\r\nadapter->cc.read = igb_ptp_read_82580;\r\nadapter->cc.mask = CLOCKSOURCE_MASK(IGB_NBITS_82580);\r\nadapter->cc.mult = 1;\r\nadapter->cc.shift = 0;\r\nwr32(E1000_TSAUXC, 0x0);\r\nbreak;\r\ncase e1000_i210:\r\ncase e1000_i211:\r\nsnprintf(adapter->ptp_caps.name, 16, "%pm", netdev->dev_addr);\r\nadapter->ptp_caps.owner = THIS_MODULE;\r\nadapter->ptp_caps.max_adj = 62499999;\r\nadapter->ptp_caps.n_ext_ts = 0;\r\nadapter->ptp_caps.pps = 0;\r\nadapter->ptp_caps.adjfreq = igb_ptp_adjfreq_82580;\r\nadapter->ptp_caps.adjtime = igb_ptp_adjtime_i210;\r\nadapter->ptp_caps.gettime = igb_ptp_gettime_i210;\r\nadapter->ptp_caps.settime = igb_ptp_settime_i210;\r\nadapter->ptp_caps.enable = igb_ptp_enable;\r\nwr32(E1000_TSAUXC, 0x0);\r\nbreak;\r\ndefault:\r\nadapter->ptp_clock = NULL;\r\nreturn;\r\n}\r\nwrfl();\r\nspin_lock_init(&adapter->tmreg_lock);\r\nINIT_WORK(&adapter->ptp_tx_work, igb_ptp_tx_work);\r\nif ((hw->mac.type == e1000_i210) || (hw->mac.type == e1000_i211)) {\r\nstruct timespec ts = ktime_to_timespec(ktime_get_real());\r\nigb_ptp_settime_i210(&adapter->ptp_caps, &ts);\r\n} else {\r\ntimecounter_init(&adapter->tc, &adapter->cc,\r\nktime_to_ns(ktime_get_real()));\r\nINIT_DELAYED_WORK(&adapter->ptp_overflow_work,\r\nigb_ptp_overflow_check);\r\nschedule_delayed_work(&adapter->ptp_overflow_work,\r\nIGB_SYSTIM_OVERFLOW_PERIOD);\r\n}\r\nif (hw->mac.type >= e1000_82580) {\r\nwr32(E1000_TSIM, E1000_TSIM_TXTS);\r\nwr32(E1000_IMS, E1000_IMS_TS);\r\n}\r\nadapter->ptp_clock = ptp_clock_register(&adapter->ptp_caps,\r\n&adapter->pdev->dev);\r\nif (IS_ERR(adapter->ptp_clock)) {\r\nadapter->ptp_clock = NULL;\r\ndev_err(&adapter->pdev->dev, "ptp_clock_register failed\n");\r\n} else {\r\ndev_info(&adapter->pdev->dev, "added PHC on %s\n",\r\nadapter->netdev->name);\r\nadapter->flags |= IGB_FLAG_PTP;\r\n}\r\n}\r\nvoid igb_ptp_stop(struct igb_adapter *adapter)\r\n{\r\nswitch (adapter->hw.mac.type) {\r\ncase e1000_82576:\r\ncase e1000_82580:\r\ncase e1000_i354:\r\ncase e1000_i350:\r\ncancel_delayed_work_sync(&adapter->ptp_overflow_work);\r\nbreak;\r\ncase e1000_i210:\r\ncase e1000_i211:\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\ncancel_work_sync(&adapter->ptp_tx_work);\r\nif (adapter->ptp_tx_skb) {\r\ndev_kfree_skb_any(adapter->ptp_tx_skb);\r\nadapter->ptp_tx_skb = NULL;\r\n}\r\nif (adapter->ptp_clock) {\r\nptp_clock_unregister(adapter->ptp_clock);\r\ndev_info(&adapter->pdev->dev, "removed PHC on %s\n",\r\nadapter->netdev->name);\r\nadapter->flags &= ~IGB_FLAG_PTP;\r\n}\r\n}\r\nvoid igb_ptp_reset(struct igb_adapter *adapter)\r\n{\r\nstruct e1000_hw *hw = &adapter->hw;\r\nif (!(adapter->flags & IGB_FLAG_PTP))\r\nreturn;\r\nswitch (adapter->hw.mac.type) {\r\ncase e1000_82576:\r\nwr32(E1000_TIMINCA, INCPERIOD_82576 | INCVALUE_82576);\r\nbreak;\r\ncase e1000_82580:\r\ncase e1000_i354:\r\ncase e1000_i350:\r\ncase e1000_i210:\r\ncase e1000_i211:\r\nwr32(E1000_TSAUXC, 0x0);\r\nwr32(E1000_TSIM, E1000_TSIM_TXTS);\r\nwr32(E1000_IMS, E1000_IMS_TS);\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif ((hw->mac.type == e1000_i210) || (hw->mac.type == e1000_i211)) {\r\nstruct timespec ts = ktime_to_timespec(ktime_get_real());\r\nigb_ptp_settime_i210(&adapter->ptp_caps, &ts);\r\n} else {\r\ntimecounter_init(&adapter->tc, &adapter->cc,\r\nktime_to_ns(ktime_get_real()));\r\n}\r\n}
