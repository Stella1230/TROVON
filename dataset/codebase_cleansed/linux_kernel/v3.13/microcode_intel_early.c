static enum ucode_state\r\ngeneric_load_microcode_early(struct microcode_intel **mc_saved_p,\r\nunsigned int mc_saved_count,\r\nstruct ucode_cpu_info *uci)\r\n{\r\nstruct microcode_intel *ucode_ptr, *new_mc = NULL;\r\nint new_rev = uci->cpu_sig.rev;\r\nenum ucode_state state = UCODE_OK;\r\nunsigned int mc_size;\r\nstruct microcode_header_intel *mc_header;\r\nunsigned int csig = uci->cpu_sig.sig;\r\nunsigned int cpf = uci->cpu_sig.pf;\r\nint i;\r\nfor (i = 0; i < mc_saved_count; i++) {\r\nucode_ptr = mc_saved_p[i];\r\nmc_header = (struct microcode_header_intel *)ucode_ptr;\r\nmc_size = get_totalsize(mc_header);\r\nif (get_matching_microcode(csig, cpf, ucode_ptr, new_rev)) {\r\nnew_rev = mc_header->rev;\r\nnew_mc = ucode_ptr;\r\n}\r\n}\r\nif (!new_mc) {\r\nstate = UCODE_NFOUND;\r\ngoto out;\r\n}\r\nuci->mc = (struct microcode_intel *)new_mc;\r\nout:\r\nreturn state;\r\n}\r\nstatic void\r\nmicrocode_pointer(struct microcode_intel **mc_saved,\r\nunsigned long *mc_saved_in_initrd,\r\nunsigned long initrd_start, int mc_saved_count)\r\n{\r\nint i;\r\nfor (i = 0; i < mc_saved_count; i++)\r\nmc_saved[i] = (struct microcode_intel *)\r\n(mc_saved_in_initrd[i] + initrd_start);\r\n}\r\nstatic void\r\nmicrocode_phys(struct microcode_intel **mc_saved_tmp,\r\nstruct mc_saved_data *mc_saved_data)\r\n{\r\nint i;\r\nstruct microcode_intel ***mc_saved;\r\nmc_saved = (struct microcode_intel ***)\r\n__pa_nodebug(&mc_saved_data->mc_saved);\r\nfor (i = 0; i < mc_saved_data->mc_saved_count; i++) {\r\nstruct microcode_intel *p;\r\np = *(struct microcode_intel **)\r\n__pa_nodebug(mc_saved_data->mc_saved + i);\r\nmc_saved_tmp[i] = (struct microcode_intel *)__pa_nodebug(p);\r\n}\r\n}\r\nstatic enum ucode_state\r\nload_microcode(struct mc_saved_data *mc_saved_data,\r\nunsigned long *mc_saved_in_initrd,\r\nunsigned long initrd_start,\r\nstruct ucode_cpu_info *uci)\r\n{\r\nstruct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];\r\nunsigned int count = mc_saved_data->mc_saved_count;\r\nif (!mc_saved_data->mc_saved) {\r\nmicrocode_pointer(mc_saved_tmp, mc_saved_in_initrd,\r\ninitrd_start, count);\r\nreturn generic_load_microcode_early(mc_saved_tmp, count, uci);\r\n} else {\r\n#ifdef CONFIG_X86_32\r\nmicrocode_phys(mc_saved_tmp, mc_saved_data);\r\nreturn generic_load_microcode_early(mc_saved_tmp, count, uci);\r\n#else\r\nreturn generic_load_microcode_early(mc_saved_data->mc_saved,\r\ncount, uci);\r\n#endif\r\n}\r\n}\r\nstatic u8 get_x86_family(unsigned long sig)\r\n{\r\nu8 x86;\r\nx86 = (sig >> 8) & 0xf;\r\nif (x86 == 0xf)\r\nx86 += (sig >> 20) & 0xff;\r\nreturn x86;\r\n}\r\nstatic u8 get_x86_model(unsigned long sig)\r\n{\r\nu8 x86, x86_model;\r\nx86 = get_x86_family(sig);\r\nx86_model = (sig >> 4) & 0xf;\r\nif (x86 == 0x6 || x86 == 0xf)\r\nx86_model += ((sig >> 16) & 0xf) << 4;\r\nreturn x86_model;\r\n}\r\nstatic enum ucode_state\r\nmatching_model_microcode(struct microcode_header_intel *mc_header,\r\nunsigned long sig)\r\n{\r\nu8 x86, x86_model;\r\nu8 x86_ucode, x86_model_ucode;\r\nstruct extended_sigtable *ext_header;\r\nunsigned long total_size = get_totalsize(mc_header);\r\nunsigned long data_size = get_datasize(mc_header);\r\nint ext_sigcount, i;\r\nstruct extended_signature *ext_sig;\r\nx86 = get_x86_family(sig);\r\nx86_model = get_x86_model(sig);\r\nx86_ucode = get_x86_family(mc_header->sig);\r\nx86_model_ucode = get_x86_model(mc_header->sig);\r\nif (x86 == x86_ucode && x86_model == x86_model_ucode)\r\nreturn UCODE_OK;\r\nif (total_size <= data_size + MC_HEADER_SIZE)\r\nreturn UCODE_NFOUND;\r\next_header = (struct extended_sigtable *)\r\nmc_header + data_size + MC_HEADER_SIZE;\r\next_sigcount = ext_header->count;\r\next_sig = (void *)ext_header + EXT_HEADER_SIZE;\r\nfor (i = 0; i < ext_sigcount; i++) {\r\nx86_ucode = get_x86_family(ext_sig->sig);\r\nx86_model_ucode = get_x86_model(ext_sig->sig);\r\nif (x86 == x86_ucode && x86_model == x86_model_ucode)\r\nreturn UCODE_OK;\r\next_sig++;\r\n}\r\nreturn UCODE_NFOUND;\r\n}\r\nstatic int\r\nsave_microcode(struct mc_saved_data *mc_saved_data,\r\nstruct microcode_intel **mc_saved_src,\r\nunsigned int mc_saved_count)\r\n{\r\nint i, j;\r\nstruct microcode_intel **mc_saved_p;\r\nint ret;\r\nif (!mc_saved_count)\r\nreturn -EINVAL;\r\nmc_saved_p = kmalloc(mc_saved_count*sizeof(struct microcode_intel *),\r\nGFP_KERNEL);\r\nif (!mc_saved_p)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < mc_saved_count; i++) {\r\nstruct microcode_intel *mc = mc_saved_src[i];\r\nstruct microcode_header_intel *mc_header = &mc->hdr;\r\nunsigned long mc_size = get_totalsize(mc_header);\r\nmc_saved_p[i] = kmalloc(mc_size, GFP_KERNEL);\r\nif (!mc_saved_p[i]) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nif (!mc_saved_src[i]) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nmemcpy(mc_saved_p[i], mc, mc_size);\r\n}\r\nmc_saved_data->mc_saved = mc_saved_p;\r\nmc_saved_data->mc_saved_count = mc_saved_count;\r\nreturn 0;\r\nerr:\r\nfor (j = 0; j <= i; j++)\r\nkfree(mc_saved_p[j]);\r\nkfree(mc_saved_p);\r\nreturn ret;\r\n}\r\nstatic void _save_mc(struct microcode_intel **mc_saved, u8 *ucode_ptr,\r\nunsigned int *mc_saved_count_p)\r\n{\r\nint i;\r\nint found = 0;\r\nunsigned int mc_saved_count = *mc_saved_count_p;\r\nstruct microcode_header_intel *mc_header;\r\nmc_header = (struct microcode_header_intel *)ucode_ptr;\r\nfor (i = 0; i < mc_saved_count; i++) {\r\nunsigned int sig, pf;\r\nunsigned int new_rev;\r\nstruct microcode_header_intel *mc_saved_header =\r\n(struct microcode_header_intel *)mc_saved[i];\r\nsig = mc_saved_header->sig;\r\npf = mc_saved_header->pf;\r\nnew_rev = mc_header->rev;\r\nif (get_matching_sig(sig, pf, ucode_ptr, new_rev)) {\r\nfound = 1;\r\nif (update_match_revision(mc_header, new_rev)) {\r\nmc_saved[i] =\r\n(struct microcode_intel *)ucode_ptr;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (i >= mc_saved_count && !found)\r\nmc_saved[mc_saved_count++] =\r\n(struct microcode_intel *)ucode_ptr;\r\n*mc_saved_count_p = mc_saved_count;\r\n}\r\nstatic enum ucode_state __init\r\nget_matching_model_microcode(int cpu, unsigned long start,\r\nvoid *data, size_t size,\r\nstruct mc_saved_data *mc_saved_data,\r\nunsigned long *mc_saved_in_initrd,\r\nstruct ucode_cpu_info *uci)\r\n{\r\nu8 *ucode_ptr = data;\r\nunsigned int leftover = size;\r\nenum ucode_state state = UCODE_OK;\r\nunsigned int mc_size;\r\nstruct microcode_header_intel *mc_header;\r\nstruct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];\r\nunsigned int mc_saved_count = mc_saved_data->mc_saved_count;\r\nint i;\r\nwhile (leftover) {\r\nmc_header = (struct microcode_header_intel *)ucode_ptr;\r\nmc_size = get_totalsize(mc_header);\r\nif (!mc_size || mc_size > leftover ||\r\nmicrocode_sanity_check(ucode_ptr, 0) < 0)\r\nbreak;\r\nleftover -= mc_size;\r\nif (matching_model_microcode(mc_header, uci->cpu_sig.sig) !=\r\nUCODE_OK) {\r\nucode_ptr += mc_size;\r\ncontinue;\r\n}\r\n_save_mc(mc_saved_tmp, ucode_ptr, &mc_saved_count);\r\nucode_ptr += mc_size;\r\n}\r\nif (leftover) {\r\nstate = UCODE_ERROR;\r\ngoto out;\r\n}\r\nif (mc_saved_count == 0) {\r\nstate = UCODE_NFOUND;\r\ngoto out;\r\n}\r\nfor (i = 0; i < mc_saved_count; i++)\r\nmc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;\r\nmc_saved_data->mc_saved_count = mc_saved_count;\r\nout:\r\nreturn state;\r\n}\r\nstatic int collect_cpu_info_early(struct ucode_cpu_info *uci)\r\n{\r\nunsigned int val[2];\r\nu8 x86, x86_model;\r\nstruct cpu_signature csig;\r\nunsigned int eax, ebx, ecx, edx;\r\ncsig.sig = 0;\r\ncsig.pf = 0;\r\ncsig.rev = 0;\r\nmemset(uci, 0, sizeof(*uci));\r\neax = 0x00000001;\r\necx = 0;\r\nnative_cpuid(&eax, &ebx, &ecx, &edx);\r\ncsig.sig = eax;\r\nx86 = get_x86_family(csig.sig);\r\nx86_model = get_x86_model(csig.sig);\r\nif ((x86_model >= 5) || (x86 > 6)) {\r\nnative_rdmsr(MSR_IA32_PLATFORM_ID, val[0], val[1]);\r\ncsig.pf = 1 << ((val[1] >> 18) & 7);\r\n}\r\nnative_wrmsr(MSR_IA32_UCODE_REV, 0, 0);\r\nsync_core();\r\nnative_rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);\r\ncsig.rev = val[1];\r\nuci->cpu_sig = csig;\r\nuci->valid = 1;\r\nreturn 0;\r\n}\r\nstatic void __ref show_saved_mc(void)\r\n{\r\nint i, j;\r\nunsigned int sig, pf, rev, total_size, data_size, date;\r\nstruct ucode_cpu_info uci;\r\nif (mc_saved_data.mc_saved_count == 0) {\r\npr_debug("no micorcode data saved.\n");\r\nreturn;\r\n}\r\npr_debug("Total microcode saved: %d\n", mc_saved_data.mc_saved_count);\r\ncollect_cpu_info_early(&uci);\r\nsig = uci.cpu_sig.sig;\r\npf = uci.cpu_sig.pf;\r\nrev = uci.cpu_sig.rev;\r\npr_debug("CPU%d: sig=0x%x, pf=0x%x, rev=0x%x\n",\r\nsmp_processor_id(), sig, pf, rev);\r\nfor (i = 0; i < mc_saved_data.mc_saved_count; i++) {\r\nstruct microcode_header_intel *mc_saved_header;\r\nstruct extended_sigtable *ext_header;\r\nint ext_sigcount;\r\nstruct extended_signature *ext_sig;\r\nmc_saved_header = (struct microcode_header_intel *)\r\nmc_saved_data.mc_saved[i];\r\nsig = mc_saved_header->sig;\r\npf = mc_saved_header->pf;\r\nrev = mc_saved_header->rev;\r\ntotal_size = get_totalsize(mc_saved_header);\r\ndata_size = get_datasize(mc_saved_header);\r\ndate = mc_saved_header->date;\r\npr_debug("mc_saved[%d]: sig=0x%x, pf=0x%x, rev=0x%x, toal size=0x%x, date = %04x-%02x-%02x\n",\r\ni, sig, pf, rev, total_size,\r\ndate & 0xffff,\r\ndate >> 24,\r\n(date >> 16) & 0xff);\r\nif (total_size <= data_size + MC_HEADER_SIZE)\r\ncontinue;\r\next_header = (struct extended_sigtable *)\r\nmc_saved_header + data_size + MC_HEADER_SIZE;\r\next_sigcount = ext_header->count;\r\next_sig = (void *)ext_header + EXT_HEADER_SIZE;\r\nfor (j = 0; j < ext_sigcount; j++) {\r\nsig = ext_sig->sig;\r\npf = ext_sig->pf;\r\npr_debug("\tExtended[%d]: sig=0x%x, pf=0x%x\n",\r\nj, sig, pf);\r\next_sig++;\r\n}\r\n}\r\n}\r\nstatic inline void show_saved_mc(void)\r\n{\r\n}\r\nint save_mc_for_early(u8 *mc)\r\n{\r\nstruct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];\r\nunsigned int mc_saved_count_init;\r\nunsigned int mc_saved_count;\r\nstruct microcode_intel **mc_saved;\r\nint ret = 0;\r\nint i;\r\nmutex_lock(&x86_cpu_microcode_mutex);\r\nmc_saved_count_init = mc_saved_data.mc_saved_count;\r\nmc_saved_count = mc_saved_data.mc_saved_count;\r\nmc_saved = mc_saved_data.mc_saved;\r\nif (mc_saved && mc_saved_count)\r\nmemcpy(mc_saved_tmp, mc_saved,\r\nmc_saved_count * sizeof(struct mirocode_intel *));\r\n_save_mc(mc_saved_tmp, mc, &mc_saved_count);\r\nret = save_microcode(&mc_saved_data, mc_saved_tmp, mc_saved_count);\r\nif (ret) {\r\npr_err("Cannot save microcode patch.\n");\r\ngoto out;\r\n}\r\nshow_saved_mc();\r\nif (mc_saved) {\r\nfor (i = 0; i < mc_saved_count_init; i++)\r\nkfree(mc_saved[i]);\r\nkfree(mc_saved);\r\n}\r\nout:\r\nmutex_unlock(&x86_cpu_microcode_mutex);\r\nreturn ret;\r\n}\r\nstatic __init enum ucode_state\r\nscan_microcode(unsigned long start, unsigned long end,\r\nstruct mc_saved_data *mc_saved_data,\r\nunsigned long *mc_saved_in_initrd,\r\nstruct ucode_cpu_info *uci)\r\n{\r\nunsigned int size = end - start + 1;\r\nstruct cpio_data cd;\r\nlong offset = 0;\r\n#ifdef CONFIG_X86_32\r\nchar *p = (char *)__pa_nodebug(ucode_name);\r\n#else\r\nchar *p = ucode_name;\r\n#endif\r\ncd.data = NULL;\r\ncd.size = 0;\r\ncd = find_cpio_data(p, (void *)start, size, &offset);\r\nif (!cd.data)\r\nreturn UCODE_ERROR;\r\nreturn get_matching_model_microcode(0, start, cd.data, cd.size,\r\nmc_saved_data, mc_saved_in_initrd,\r\nuci);\r\n}\r\nstatic void\r\nprint_ucode_info(struct ucode_cpu_info *uci, unsigned int date)\r\n{\r\nint cpu = smp_processor_id();\r\npr_info("CPU%d microcode updated early to revision 0x%x, date = %04x-%02x-%02x\n",\r\ncpu,\r\nuci->cpu_sig.rev,\r\ndate & 0xffff,\r\ndate >> 24,\r\n(date >> 16) & 0xff);\r\n}\r\nvoid show_ucode_info_early(void)\r\n{\r\nstruct ucode_cpu_info uci;\r\nif (delay_ucode_info) {\r\ncollect_cpu_info_early(&uci);\r\nprint_ucode_info(&uci, current_mc_date);\r\ndelay_ucode_info = 0;\r\n}\r\n}\r\nstatic void print_ucode(struct ucode_cpu_info *uci)\r\n{\r\nstruct microcode_intel *mc_intel;\r\nint *delay_ucode_info_p;\r\nint *current_mc_date_p;\r\nmc_intel = uci->mc;\r\nif (mc_intel == NULL)\r\nreturn;\r\ndelay_ucode_info_p = (int *)__pa_nodebug(&delay_ucode_info);\r\ncurrent_mc_date_p = (int *)__pa_nodebug(&current_mc_date);\r\n*delay_ucode_info_p = 1;\r\n*current_mc_date_p = mc_intel->hdr.date;\r\n}\r\nstatic inline void flush_tlb_early(void)\r\n{\r\n__native_flush_tlb_global_irq_disabled();\r\n}\r\nstatic inline void print_ucode(struct ucode_cpu_info *uci)\r\n{\r\nstruct microcode_intel *mc_intel;\r\nmc_intel = uci->mc;\r\nif (mc_intel == NULL)\r\nreturn;\r\nprint_ucode_info(uci, mc_intel->hdr.date);\r\n}\r\nstatic int apply_microcode_early(struct mc_saved_data *mc_saved_data,\r\nstruct ucode_cpu_info *uci)\r\n{\r\nstruct microcode_intel *mc_intel;\r\nunsigned int val[2];\r\nmc_intel = uci->mc;\r\nif (mc_intel == NULL)\r\nreturn 0;\r\nnative_wrmsr(MSR_IA32_UCODE_WRITE,\r\n(unsigned long) mc_intel->bits,\r\n(unsigned long) mc_intel->bits >> 16 >> 16);\r\nnative_wrmsr(MSR_IA32_UCODE_REV, 0, 0);\r\nsync_core();\r\nnative_rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);\r\nif (val[1] != mc_intel->hdr.rev)\r\nreturn -1;\r\n#ifdef CONFIG_X86_64\r\nflush_tlb_early();\r\n#endif\r\nuci->cpu_sig.rev = val[1];\r\nprint_ucode(uci);\r\nreturn 0;\r\n}\r\nint __init save_microcode_in_initrd_intel(void)\r\n{\r\nunsigned int count = mc_saved_data.mc_saved_count;\r\nstruct microcode_intel *mc_saved[MAX_UCODE_COUNT];\r\nint ret = 0;\r\nif (count == 0)\r\nreturn ret;\r\nmicrocode_pointer(mc_saved, mc_saved_in_initrd, initrd_start, count);\r\nret = save_microcode(&mc_saved_data, mc_saved, count);\r\nif (ret)\r\npr_err("Cannot save microcode patches from initrd.\n");\r\nshow_saved_mc();\r\nreturn ret;\r\n}\r\nstatic void __init\r\n_load_ucode_intel_bsp(struct mc_saved_data *mc_saved_data,\r\nunsigned long *mc_saved_in_initrd,\r\nunsigned long initrd_start_early,\r\nunsigned long initrd_end_early,\r\nstruct ucode_cpu_info *uci)\r\n{\r\ncollect_cpu_info_early(uci);\r\nscan_microcode(initrd_start_early, initrd_end_early, mc_saved_data,\r\nmc_saved_in_initrd, uci);\r\nload_microcode(mc_saved_data, mc_saved_in_initrd,\r\ninitrd_start_early, uci);\r\napply_microcode_early(mc_saved_data, uci);\r\n}\r\nvoid __init\r\nload_ucode_intel_bsp(void)\r\n{\r\nu64 ramdisk_image, ramdisk_size;\r\nunsigned long initrd_start_early, initrd_end_early;\r\nstruct ucode_cpu_info uci;\r\n#ifdef CONFIG_X86_32\r\nstruct boot_params *boot_params_p;\r\nboot_params_p = (struct boot_params *)__pa_nodebug(&boot_params);\r\nramdisk_image = boot_params_p->hdr.ramdisk_image;\r\nramdisk_size = boot_params_p->hdr.ramdisk_size;\r\ninitrd_start_early = ramdisk_image;\r\ninitrd_end_early = initrd_start_early + ramdisk_size;\r\n_load_ucode_intel_bsp(\r\n(struct mc_saved_data *)__pa_nodebug(&mc_saved_data),\r\n(unsigned long *)__pa_nodebug(&mc_saved_in_initrd),\r\ninitrd_start_early, initrd_end_early, &uci);\r\n#else\r\nramdisk_image = boot_params.hdr.ramdisk_image;\r\nramdisk_size = boot_params.hdr.ramdisk_size;\r\ninitrd_start_early = ramdisk_image + PAGE_OFFSET;\r\ninitrd_end_early = initrd_start_early + ramdisk_size;\r\n_load_ucode_intel_bsp(&mc_saved_data, mc_saved_in_initrd,\r\ninitrd_start_early, initrd_end_early, &uci);\r\n#endif\r\n}\r\nvoid load_ucode_intel_ap(void)\r\n{\r\nstruct mc_saved_data *mc_saved_data_p;\r\nstruct ucode_cpu_info uci;\r\nunsigned long *mc_saved_in_initrd_p;\r\nunsigned long initrd_start_addr;\r\n#ifdef CONFIG_X86_32\r\nunsigned long *initrd_start_p;\r\nmc_saved_in_initrd_p =\r\n(unsigned long *)__pa_nodebug(mc_saved_in_initrd);\r\nmc_saved_data_p = (struct mc_saved_data *)__pa_nodebug(&mc_saved_data);\r\ninitrd_start_p = (unsigned long *)__pa_nodebug(&initrd_start);\r\ninitrd_start_addr = (unsigned long)__pa_nodebug(*initrd_start_p);\r\n#else\r\nmc_saved_data_p = &mc_saved_data;\r\nmc_saved_in_initrd_p = mc_saved_in_initrd;\r\ninitrd_start_addr = initrd_start;\r\n#endif\r\nif (mc_saved_data_p->mc_saved_count == 0)\r\nreturn;\r\ncollect_cpu_info_early(&uci);\r\nload_microcode(mc_saved_data_p, mc_saved_in_initrd_p,\r\ninitrd_start_addr, &uci);\r\napply_microcode_early(mc_saved_data_p, &uci);\r\n}
