static int llog_origin_close(const struct lu_env *env, struct llog_handle *lgh)\r\n{\r\nif (lgh->lgh_hdr != NULL && lgh->lgh_hdr->llh_flags & LLOG_F_IS_CAT)\r\nreturn llog_cat_close(env, lgh);\r\nelse\r\nreturn llog_close(env, lgh);\r\n}\r\nint llog_origin_handle_open(struct ptlrpc_request *req)\r\n{\r\nstruct obd_export *exp = req->rq_export;\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct obd_device *disk_obd;\r\nstruct lvfs_run_ctxt saved;\r\nstruct llog_handle *loghandle;\r\nstruct llogd_body *body;\r\nstruct llog_logid *logid = NULL;\r\nstruct llog_ctxt *ctxt;\r\nchar *name = NULL;\r\nint rc;\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_LLOGD_BODY);\r\nif (body == NULL)\r\nreturn -EFAULT;\r\nif (ostid_id(&body->lgd_logid.lgl_oi) > 0)\r\nlogid = &body->lgd_logid;\r\nif (req_capsule_field_present(&req->rq_pill, &RMF_NAME, RCL_CLIENT)) {\r\nname = req_capsule_client_get(&req->rq_pill, &RMF_NAME);\r\nif (name == NULL)\r\nreturn -EFAULT;\r\nCDEBUG(D_INFO, "%s: opening log %s\n", obd->obd_name, name);\r\n}\r\nctxt = llog_get_context(obd, body->lgd_ctxt_idx);\r\nif (ctxt == NULL) {\r\nCDEBUG(D_WARNING, "%s: no ctxt. group=%p idx=%d name=%s\n",\r\nobd->obd_name, &obd->obd_olg, body->lgd_ctxt_idx, name);\r\nreturn -ENODEV;\r\n}\r\ndisk_obd = ctxt->loc_exp->exp_obd;\r\npush_ctxt(&saved, &disk_obd->obd_lvfs_ctxt, NULL);\r\nrc = llog_open(req->rq_svc_thread->t_env, ctxt, &loghandle, logid,\r\nname, LLOG_OPEN_EXISTS);\r\nif (rc)\r\nGOTO(out_pop, rc);\r\nrc = req_capsule_server_pack(&req->rq_pill);\r\nif (rc)\r\nGOTO(out_close, rc = -ENOMEM);\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_LLOGD_BODY);\r\nbody->lgd_logid = loghandle->lgh_id;\r\nout_close:\r\nllog_origin_close(req->rq_svc_thread->t_env, loghandle);\r\nout_pop:\r\npop_ctxt(&saved, &disk_obd->obd_lvfs_ctxt, NULL);\r\nllog_ctxt_put(ctxt);\r\nreturn rc;\r\n}\r\nint llog_origin_handle_destroy(struct ptlrpc_request *req)\r\n{\r\nstruct obd_device *disk_obd;\r\nstruct lvfs_run_ctxt saved;\r\nstruct llogd_body *body;\r\nstruct llog_logid *logid = NULL;\r\nstruct llog_ctxt *ctxt;\r\nint rc;\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_LLOGD_BODY);\r\nif (body == NULL)\r\nreturn -EFAULT;\r\nif (ostid_id(&body->lgd_logid.lgl_oi) > 0)\r\nlogid = &body->lgd_logid;\r\nif (!(body->lgd_llh_flags & LLOG_F_IS_PLAIN))\r\nCERROR("%s: wrong llog flags %x\n",\r\nreq->rq_export->exp_obd->obd_name, body->lgd_llh_flags);\r\nctxt = llog_get_context(req->rq_export->exp_obd, body->lgd_ctxt_idx);\r\nif (ctxt == NULL)\r\nreturn -ENODEV;\r\ndisk_obd = ctxt->loc_exp->exp_obd;\r\npush_ctxt(&saved, &disk_obd->obd_lvfs_ctxt, NULL);\r\nrc = req_capsule_server_pack(&req->rq_pill);\r\nif (rc == 0)\r\nrc = llog_erase(req->rq_svc_thread->t_env, ctxt, logid, NULL);\r\npop_ctxt(&saved, &disk_obd->obd_lvfs_ctxt, NULL);\r\nllog_ctxt_put(ctxt);\r\nreturn rc;\r\n}\r\nint llog_origin_handle_next_block(struct ptlrpc_request *req)\r\n{\r\nstruct obd_device *disk_obd;\r\nstruct llog_handle *loghandle;\r\nstruct llogd_body *body;\r\nstruct llogd_body *repbody;\r\nstruct lvfs_run_ctxt saved;\r\nstruct llog_ctxt *ctxt;\r\n__u32 flags;\r\nvoid *ptr;\r\nint rc;\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_LLOGD_BODY);\r\nif (body == NULL)\r\nreturn -EFAULT;\r\nctxt = llog_get_context(req->rq_export->exp_obd, body->lgd_ctxt_idx);\r\nif (ctxt == NULL)\r\nreturn -ENODEV;\r\ndisk_obd = ctxt->loc_exp->exp_obd;\r\npush_ctxt(&saved, &disk_obd->obd_lvfs_ctxt, NULL);\r\nrc = llog_open(req->rq_svc_thread->t_env, ctxt, &loghandle,\r\n&body->lgd_logid, NULL, LLOG_OPEN_EXISTS);\r\nif (rc)\r\nGOTO(out_pop, rc);\r\nflags = body->lgd_llh_flags;\r\nrc = llog_init_handle(req->rq_svc_thread->t_env, loghandle, flags,\r\nNULL);\r\nif (rc)\r\nGOTO(out_close, rc);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_EADATA, RCL_SERVER,\r\nLLOG_CHUNK_SIZE);\r\nrc = req_capsule_server_pack(&req->rq_pill);\r\nif (rc)\r\nGOTO(out_close, rc = -ENOMEM);\r\nrepbody = req_capsule_server_get(&req->rq_pill, &RMF_LLOGD_BODY);\r\n*repbody = *body;\r\nptr = req_capsule_server_get(&req->rq_pill, &RMF_EADATA);\r\nrc = llog_next_block(req->rq_svc_thread->t_env, loghandle,\r\n&repbody->lgd_saved_index, repbody->lgd_index,\r\n&repbody->lgd_cur_offset, ptr, LLOG_CHUNK_SIZE);\r\nif (rc)\r\nGOTO(out_close, rc);\r\nout_close:\r\nllog_origin_close(req->rq_svc_thread->t_env, loghandle);\r\nout_pop:\r\npop_ctxt(&saved, &disk_obd->obd_lvfs_ctxt, NULL);\r\nllog_ctxt_put(ctxt);\r\nreturn rc;\r\n}\r\nint llog_origin_handle_prev_block(struct ptlrpc_request *req)\r\n{\r\nstruct llog_handle *loghandle;\r\nstruct llogd_body *body;\r\nstruct llogd_body *repbody;\r\nstruct obd_device *disk_obd;\r\nstruct lvfs_run_ctxt saved;\r\nstruct llog_ctxt *ctxt;\r\n__u32 flags;\r\nvoid *ptr;\r\nint rc;\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_LLOGD_BODY);\r\nif (body == NULL)\r\nreturn -EFAULT;\r\nctxt = llog_get_context(req->rq_export->exp_obd, body->lgd_ctxt_idx);\r\nif (ctxt == NULL)\r\nreturn -ENODEV;\r\ndisk_obd = ctxt->loc_exp->exp_obd;\r\npush_ctxt(&saved, &disk_obd->obd_lvfs_ctxt, NULL);\r\nrc = llog_open(req->rq_svc_thread->t_env, ctxt, &loghandle,\r\n&body->lgd_logid, NULL, LLOG_OPEN_EXISTS);\r\nif (rc)\r\nGOTO(out_pop, rc);\r\nflags = body->lgd_llh_flags;\r\nrc = llog_init_handle(req->rq_svc_thread->t_env, loghandle, flags,\r\nNULL);\r\nif (rc)\r\nGOTO(out_close, rc);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_EADATA, RCL_SERVER,\r\nLLOG_CHUNK_SIZE);\r\nrc = req_capsule_server_pack(&req->rq_pill);\r\nif (rc)\r\nGOTO(out_close, rc = -ENOMEM);\r\nrepbody = req_capsule_server_get(&req->rq_pill, &RMF_LLOGD_BODY);\r\n*repbody = *body;\r\nptr = req_capsule_server_get(&req->rq_pill, &RMF_EADATA);\r\nrc = llog_prev_block(req->rq_svc_thread->t_env, loghandle,\r\nbody->lgd_index, ptr, LLOG_CHUNK_SIZE);\r\nif (rc)\r\nGOTO(out_close, rc);\r\nout_close:\r\nllog_origin_close(req->rq_svc_thread->t_env, loghandle);\r\nout_pop:\r\npop_ctxt(&saved, &disk_obd->obd_lvfs_ctxt, NULL);\r\nllog_ctxt_put(ctxt);\r\nreturn rc;\r\n}\r\nint llog_origin_handle_read_header(struct ptlrpc_request *req)\r\n{\r\nstruct obd_device *disk_obd;\r\nstruct llog_handle *loghandle;\r\nstruct llogd_body *body;\r\nstruct llog_log_hdr *hdr;\r\nstruct lvfs_run_ctxt saved;\r\nstruct llog_ctxt *ctxt;\r\n__u32 flags;\r\nint rc;\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_LLOGD_BODY);\r\nif (body == NULL)\r\nreturn -EFAULT;\r\nctxt = llog_get_context(req->rq_export->exp_obd, body->lgd_ctxt_idx);\r\nif (ctxt == NULL)\r\nreturn -ENODEV;\r\ndisk_obd = ctxt->loc_exp->exp_obd;\r\npush_ctxt(&saved, &disk_obd->obd_lvfs_ctxt, NULL);\r\nrc = llog_open(req->rq_svc_thread->t_env, ctxt, &loghandle,\r\n&body->lgd_logid, NULL, LLOG_OPEN_EXISTS);\r\nif (rc)\r\nGOTO(out_pop, rc);\r\nflags = body->lgd_llh_flags;\r\nrc = llog_init_handle(req->rq_svc_thread->t_env, loghandle, flags,\r\nNULL);\r\nif (rc)\r\nGOTO(out_close, rc);\r\nflags = loghandle->lgh_hdr->llh_flags;\r\nrc = req_capsule_server_pack(&req->rq_pill);\r\nif (rc)\r\nGOTO(out_close, rc = -ENOMEM);\r\nhdr = req_capsule_server_get(&req->rq_pill, &RMF_LLOG_LOG_HDR);\r\n*hdr = *loghandle->lgh_hdr;\r\nout_close:\r\nllog_origin_close(req->rq_svc_thread->t_env, loghandle);\r\nout_pop:\r\npop_ctxt(&saved, &disk_obd->obd_lvfs_ctxt, NULL);\r\nllog_ctxt_put(ctxt);\r\nreturn rc;\r\n}\r\nint llog_origin_handle_close(struct ptlrpc_request *req)\r\n{\r\nreturn 0;\r\n}\r\nint llog_origin_handle_cancel(struct ptlrpc_request *req)\r\n{\r\nint num_cookies, rc = 0, err, i, failed = 0;\r\nstruct obd_device *disk_obd;\r\nstruct llog_cookie *logcookies;\r\nstruct llog_ctxt *ctxt = NULL;\r\nstruct lvfs_run_ctxt saved;\r\nstruct llog_handle *cathandle;\r\nstruct inode *inode;\r\nvoid *handle;\r\nlogcookies = req_capsule_client_get(&req->rq_pill, &RMF_LOGCOOKIES);\r\nnum_cookies = req_capsule_get_size(&req->rq_pill, &RMF_LOGCOOKIES,\r\nRCL_CLIENT) / sizeof(*logcookies);\r\nif (logcookies == NULL || num_cookies == 0) {\r\nDEBUG_REQ(D_HA, req, "No llog cookies sent");\r\nreturn -EFAULT;\r\n}\r\nctxt = llog_get_context(req->rq_export->exp_obd,\r\nlogcookies->lgc_subsys);\r\nif (ctxt == NULL)\r\nreturn -ENODEV;\r\ndisk_obd = ctxt->loc_exp->exp_obd;\r\npush_ctxt(&saved, &disk_obd->obd_lvfs_ctxt, NULL);\r\nfor (i = 0; i < num_cookies; i++, logcookies++) {\r\ncathandle = ctxt->loc_handle;\r\nLASSERT(cathandle != NULL);\r\ninode = cathandle->lgh_file->f_dentry->d_inode;\r\nhandle = fsfilt_start_log(disk_obd, inode,\r\nFSFILT_OP_CANCEL_UNLINK, NULL, 1);\r\nif (IS_ERR(handle)) {\r\nCERROR("fsfilt_start_log() failed: %ld\n",\r\nPTR_ERR(handle));\r\nGOTO(pop_ctxt, rc = PTR_ERR(handle));\r\n}\r\nrc = llog_cat_cancel_records(req->rq_svc_thread->t_env,\r\ncathandle, 1, logcookies);\r\nif (rc == -ENOENT &&\r\n(lustre_msg_get_flags(req->rq_reqmsg) & MSG_RESENT)) {\r\nCDEBUG(D_RPCTRACE, "RESENT cancel req %p - ignored\n",\r\nreq);\r\nrc = 0;\r\n} else if (rc == 0) {\r\nCDEBUG(D_RPCTRACE, "Canceled %d llog-records\n",\r\nnum_cookies);\r\n}\r\nerr = fsfilt_commit(disk_obd, inode, handle, 0);\r\nif (err) {\r\nCERROR("Error committing transaction: %d\n", err);\r\nif (!rc)\r\nrc = err;\r\nfailed++;\r\nGOTO(pop_ctxt, rc);\r\n} else if (rc)\r\nfailed++;\r\n}\r\nGOTO(pop_ctxt, rc);\r\npop_ctxt:\r\npop_ctxt(&saved, &disk_obd->obd_lvfs_ctxt, NULL);\r\nif (rc)\r\nCERROR("Cancel %d of %d llog-records failed: %d\n",\r\nfailed, num_cookies, rc);\r\nllog_ctxt_put(ctxt);\r\nreturn rc;\r\n}\r\nint llog_origin_handle_open(struct ptlrpc_request *req)\r\n{\r\nLBUG();\r\nreturn 0;\r\n}\r\nint llog_origin_handle_destroy(struct ptlrpc_request *req)\r\n{\r\nLBUG();\r\nreturn 0;\r\n}\r\nint llog_origin_handle_next_block(struct ptlrpc_request *req)\r\n{\r\nLBUG();\r\nreturn 0;\r\n}\r\nint llog_origin_handle_prev_block(struct ptlrpc_request *req)\r\n{\r\nLBUG();\r\nreturn 0;\r\n}\r\nint llog_origin_handle_read_header(struct ptlrpc_request *req)\r\n{\r\nLBUG();\r\nreturn 0;\r\n}\r\nint llog_origin_handle_close(struct ptlrpc_request *req)\r\n{\r\nLBUG();\r\nreturn 0;\r\n}\r\nint llog_origin_handle_cancel(struct ptlrpc_request *req)\r\n{\r\nLBUG();\r\nreturn 0;\r\n}
