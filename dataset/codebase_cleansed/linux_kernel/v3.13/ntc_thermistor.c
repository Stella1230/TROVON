static int ntc_adc_iio_read(struct ntc_thermistor_platform_data *pdata)\r\n{\r\nstruct iio_channel *channel = pdata->chan;\r\nunsigned int result;\r\nint val, ret;\r\nret = iio_read_channel_raw(channel, &val);\r\nif (ret < 0) {\r\npr_err("read channel() error: %d\n", ret);\r\nreturn ret;\r\n}\r\nresult = pdata->pullup_uv * val;\r\nresult >>= 12;\r\nreturn result;\r\n}\r\nstatic struct ntc_thermistor_platform_data *\r\nntc_thermistor_parse_dt(struct platform_device *pdev)\r\n{\r\nstruct iio_channel *chan;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct ntc_thermistor_platform_data *pdata;\r\nif (!np)\r\nreturn NULL;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\nchan = iio_channel_get(&pdev->dev, NULL);\r\nif (IS_ERR(chan))\r\nreturn ERR_CAST(chan);\r\nif (of_property_read_u32(np, "pullup-uv", &pdata->pullup_uv))\r\nreturn ERR_PTR(-ENODEV);\r\nif (of_property_read_u32(np, "pullup-ohm", &pdata->pullup_ohm))\r\nreturn ERR_PTR(-ENODEV);\r\nif (of_property_read_u32(np, "pulldown-ohm", &pdata->pulldown_ohm))\r\nreturn ERR_PTR(-ENODEV);\r\nif (of_find_property(np, "connected-positive", NULL))\r\npdata->connect = NTC_CONNECTED_POSITIVE;\r\nelse\r\npdata->connect = NTC_CONNECTED_GROUND;\r\npdata->chan = chan;\r\npdata->read_uv = ntc_adc_iio_read;\r\nreturn pdata;\r\n}\r\nstatic void ntc_iio_channel_release(struct ntc_thermistor_platform_data *pdata)\r\n{\r\nif (pdata->chan)\r\niio_channel_release(pdata->chan);\r\n}\r\nstatic struct ntc_thermistor_platform_data *\r\nntc_thermistor_parse_dt(struct platform_device *pdev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic void ntc_iio_channel_release(struct ntc_thermistor_platform_data *pdata)\r\n{ }\r\nstatic inline u64 div64_u64_safe(u64 dividend, u64 divisor)\r\n{\r\nif (divisor == 0 && dividend == 0)\r\nreturn 0;\r\nif (divisor == 0)\r\nreturn UINT_MAX;\r\nreturn div64_u64(dividend, divisor);\r\n}\r\nstatic int get_ohm_of_thermistor(struct ntc_data *data, unsigned int uv)\r\n{\r\nstruct ntc_thermistor_platform_data *pdata = data->pdata;\r\nu64 mv = uv / 1000;\r\nu64 pmv = pdata->pullup_uv / 1000;\r\nu64 n, puo, pdo;\r\npuo = pdata->pullup_ohm;\r\npdo = pdata->pulldown_ohm;\r\nif (mv == 0) {\r\nif (pdata->connect == NTC_CONNECTED_POSITIVE)\r\nreturn INT_MAX;\r\nreturn 0;\r\n}\r\nif (mv >= pmv)\r\nreturn (pdata->connect == NTC_CONNECTED_POSITIVE) ?\r\n0 : INT_MAX;\r\nif (pdata->connect == NTC_CONNECTED_POSITIVE && puo == 0)\r\nn = div64_u64_safe(pdo * (pmv - mv), mv);\r\nelse if (pdata->connect == NTC_CONNECTED_GROUND && pdo == 0)\r\nn = div64_u64_safe(puo * mv, pmv - mv);\r\nelse if (pdata->connect == NTC_CONNECTED_POSITIVE)\r\nn = div64_u64_safe(pdo * puo * (pmv - mv),\r\npuo * mv - pdo * (pmv - mv));\r\nelse\r\nn = div64_u64_safe(pdo * puo * mv, pdo * (pmv - mv) - puo * mv);\r\nif (n > INT_MAX)\r\nn = INT_MAX;\r\nreturn n;\r\n}\r\nstatic void lookup_comp(struct ntc_data *data, unsigned int ohm,\r\nint *i_low, int *i_high)\r\n{\r\nint start, end, mid;\r\nif (ohm >= data->comp[0].ohm) {\r\n*i_low = 0;\r\n*i_high = 0;\r\nreturn;\r\n}\r\nif (ohm <= data->comp[data->n_comp - 1].ohm) {\r\n*i_low = data->n_comp - 1;\r\n*i_high = data->n_comp - 1;\r\nreturn;\r\n}\r\nstart = 0;\r\nend = data->n_comp;\r\nwhile (start < end) {\r\nmid = start + (end - start) / 2;\r\nif (ohm >= data->comp[mid].ohm) {\r\nend = mid;\r\n} else {\r\nstart = mid + 1;\r\nif (ohm >= data->comp[start].ohm)\r\nend = start;\r\n}\r\n}\r\n*i_low = end;\r\nif (ohm == data->comp[end].ohm)\r\n*i_high = end;\r\nelse\r\n*i_high = end - 1;\r\n}\r\nstatic int get_temp_mc(struct ntc_data *data, unsigned int ohm)\r\n{\r\nint low, high;\r\nint temp;\r\nlookup_comp(data, ohm, &low, &high);\r\nif (low == high) {\r\ntemp = data->comp[low].temp_c * 1000;\r\n} else {\r\ntemp = data->comp[low].temp_c * 1000 +\r\n((data->comp[high].temp_c - data->comp[low].temp_c) *\r\n1000 * ((int)ohm - (int)data->comp[low].ohm)) /\r\n((int)data->comp[high].ohm - (int)data->comp[low].ohm);\r\n}\r\nreturn temp;\r\n}\r\nstatic int ntc_thermistor_get_ohm(struct ntc_data *data)\r\n{\r\nint read_uv;\r\nif (data->pdata->read_ohm)\r\nreturn data->pdata->read_ohm();\r\nif (data->pdata->read_uv) {\r\nread_uv = data->pdata->read_uv(data->pdata);\r\nif (read_uv < 0)\r\nreturn read_uv;\r\nreturn get_ohm_of_thermistor(data, read_uv);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t ntc_show_name(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ntc_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", data->name);\r\n}\r\nstatic ssize_t ntc_show_type(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "4\n");\r\n}\r\nstatic ssize_t ntc_show_temp(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ntc_data *data = dev_get_drvdata(dev);\r\nint ohm;\r\nohm = ntc_thermistor_get_ohm(data);\r\nif (ohm < 0)\r\nreturn ohm;\r\nreturn sprintf(buf, "%d\n", get_temp_mc(data, ohm));\r\n}\r\nstatic int ntc_thermistor_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(of_match_ptr(ntc_match), &pdev->dev);\r\nconst struct platform_device_id *pdev_id;\r\nstruct ntc_thermistor_platform_data *pdata;\r\nstruct ntc_data *data;\r\nint ret;\r\npdata = ntc_thermistor_parse_dt(pdev);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\nelse if (pdata == NULL)\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "No platform init data supplied.\n");\r\nreturn -ENODEV;\r\n}\r\nif (!pdata->read_uv && !pdata->read_ohm) {\r\ndev_err(&pdev->dev,\r\n"Both read_uv and read_ohm missing. Need either one of the two.\n");\r\nreturn -EINVAL;\r\n}\r\nif (pdata->read_uv && pdata->read_ohm) {\r\ndev_warn(&pdev->dev,\r\n"Only one of read_uv and read_ohm is needed; ignoring read_uv.\n");\r\npdata->read_uv = NULL;\r\n}\r\nif (pdata->read_uv && (pdata->pullup_uv == 0 ||\r\n(pdata->pullup_ohm == 0 && pdata->connect ==\r\nNTC_CONNECTED_GROUND) ||\r\n(pdata->pulldown_ohm == 0 && pdata->connect ==\r\nNTC_CONNECTED_POSITIVE) ||\r\n(pdata->connect != NTC_CONNECTED_POSITIVE &&\r\npdata->connect != NTC_CONNECTED_GROUND))) {\r\ndev_err(&pdev->dev,\r\n"Required data to use read_uv not supplied.\n");\r\nreturn -EINVAL;\r\n}\r\ndata = devm_kzalloc(&pdev->dev, sizeof(struct ntc_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\npdev_id = of_id ? of_id->data : platform_get_device_id(pdev);\r\ndata->dev = &pdev->dev;\r\ndata->pdata = pdata;\r\nstrlcpy(data->name, pdev_id->name, sizeof(data->name));\r\nswitch (pdev_id->driver_data) {\r\ncase TYPE_NCPXXWB473:\r\ndata->comp = ncpXXwb473;\r\ndata->n_comp = ARRAY_SIZE(ncpXXwb473);\r\nbreak;\r\ncase TYPE_NCPXXWL333:\r\ndata->comp = ncpXXwl333;\r\ndata->n_comp = ARRAY_SIZE(ncpXXwl333);\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "Unknown device type: %lu(%s)\n",\r\npdev_id->driver_data, pdev_id->name);\r\nreturn -EINVAL;\r\n}\r\nplatform_set_drvdata(pdev, data);\r\nret = sysfs_create_group(&data->dev->kobj, &ntc_attr_group);\r\nif (ret) {\r\ndev_err(data->dev, "unable to create sysfs files\n");\r\nreturn ret;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(data->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\ndev_err(data->dev, "unable to register as hwmon device.\n");\r\nret = PTR_ERR(data->hwmon_dev);\r\ngoto err_after_sysfs;\r\n}\r\ndev_info(&pdev->dev, "Thermistor type: %s successfully probed.\n",\r\npdev->name);\r\nreturn 0;\r\nerr_after_sysfs:\r\nsysfs_remove_group(&data->dev->kobj, &ntc_attr_group);\r\nntc_iio_channel_release(pdata);\r\nreturn ret;\r\n}\r\nstatic int ntc_thermistor_remove(struct platform_device *pdev)\r\n{\r\nstruct ntc_data *data = platform_get_drvdata(pdev);\r\nstruct ntc_thermistor_platform_data *pdata = data->pdata;\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&data->dev->kobj, &ntc_attr_group);\r\nntc_iio_channel_release(pdata);\r\nreturn 0;\r\n}
