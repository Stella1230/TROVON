int sequencer_read(int dev, struct file *file, char __user *buf, int count)\r\n{\r\nint c = count, p = 0;\r\nint ev_len;\r\nunsigned long flags;\r\ndev = dev >> 4;\r\nev_len = seq_mode == SEQ_1 ? 4 : 8;\r\nspin_lock_irqsave(&lock,flags);\r\nif (!iqlen)\r\n{\r\nspin_unlock_irqrestore(&lock,flags);\r\nif (file->f_flags & O_NONBLOCK) {\r\nreturn -EAGAIN;\r\n}\r\ninterruptible_sleep_on_timeout(&midi_sleeper,\r\npre_event_timeout);\r\nspin_lock_irqsave(&lock,flags);\r\nif (!iqlen)\r\n{\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn 0;\r\n}\r\n}\r\nwhile (iqlen && c >= ev_len)\r\n{\r\nchar *fixit = (char *) &iqueue[iqhead * IEV_SZ];\r\nspin_unlock_irqrestore(&lock,flags);\r\nif (copy_to_user(&(buf)[p], fixit, ev_len))\r\nreturn count - c;\r\np += ev_len;\r\nc -= ev_len;\r\nspin_lock_irqsave(&lock,flags);\r\niqhead = (iqhead + 1) % SEQ_MAX_QUEUE;\r\niqlen--;\r\n}\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn count - c;\r\n}\r\nstatic void sequencer_midi_output(int dev)\r\n{\r\n}\r\nvoid seq_copy_to_input(unsigned char *event_rec, int len)\r\n{\r\nunsigned long flags;\r\nif (len != 4 && len != 8)\r\nreturn;\r\nif ((seq_mode == SEQ_1) != (len == 4))\r\nreturn;\r\nif (iqlen >= (SEQ_MAX_QUEUE - 1))\r\nreturn;\r\nspin_lock_irqsave(&lock,flags);\r\nmemcpy(&iqueue[iqtail * IEV_SZ], event_rec, len);\r\niqlen++;\r\niqtail = (iqtail + 1) % SEQ_MAX_QUEUE;\r\nwake_up(&midi_sleeper);\r\nspin_unlock_irqrestore(&lock,flags);\r\n}\r\nstatic void sequencer_midi_input(int dev, unsigned char data)\r\n{\r\nunsigned int tstamp;\r\nunsigned char event_rec[4];\r\nif (data == 0xfe)\r\nreturn;\r\ntstamp = jiffies - seq_time;\r\nif (tstamp != prev_input_time)\r\n{\r\ntstamp = (tstamp << 8) | SEQ_WAIT;\r\nseq_copy_to_input((unsigned char *) &tstamp, 4);\r\nprev_input_time = tstamp;\r\n}\r\nevent_rec[0] = SEQ_MIDIPUTC;\r\nevent_rec[1] = data;\r\nevent_rec[2] = dev;\r\nevent_rec[3] = 0;\r\nseq_copy_to_input(event_rec, 4);\r\n}\r\nvoid seq_input_event(unsigned char *event_rec, int len)\r\n{\r\nunsigned long this_time;\r\nif (seq_mode == SEQ_2)\r\nthis_time = tmr->get_time(tmr_no);\r\nelse\r\nthis_time = jiffies - seq_time;\r\nif (this_time != prev_input_time)\r\n{\r\nunsigned char tmp_event[8];\r\ntmp_event[0] = EV_TIMING;\r\ntmp_event[1] = TMR_WAIT_ABS;\r\ntmp_event[2] = 0;\r\ntmp_event[3] = 0;\r\n*(unsigned int *) &tmp_event[4] = this_time;\r\nseq_copy_to_input(tmp_event, 8);\r\nprev_input_time = this_time;\r\n}\r\nseq_copy_to_input(event_rec, len);\r\n}\r\nint sequencer_write(int dev, struct file *file, const char __user *buf, int count)\r\n{\r\nunsigned char event_rec[EV_SZ], ev_code;\r\nint p = 0, c, ev_size;\r\nint mode = translate_mode(file);\r\ndev = dev >> 4;\r\nDEB(printk("sequencer_write(dev=%d, count=%d)\n", dev, count));\r\nif (mode == OPEN_READ)\r\nreturn -EIO;\r\nc = count;\r\nwhile (c >= 4)\r\n{\r\nif (copy_from_user((char *) event_rec, &(buf)[p], 4))\r\ngoto out;\r\nev_code = event_rec[0];\r\nif (ev_code == SEQ_FULLSIZE)\r\n{\r\nint err, fmt;\r\ndev = *(unsigned short *) &event_rec[2];\r\nif (dev < 0 || dev >= max_synthdev || synth_devs[dev] == NULL)\r\nreturn -ENXIO;\r\nif (!(synth_open_mask & (1 << dev)))\r\nreturn -ENXIO;\r\nfmt = (*(short *) &event_rec[0]) & 0xffff;\r\nerr = synth_devs[dev]->load_patch(dev, fmt, buf + p, c, 0);\r\nif (err < 0)\r\nreturn err;\r\nreturn err;\r\n}\r\nif (ev_code >= 128)\r\n{\r\nif (seq_mode == SEQ_2 && ev_code == SEQ_EXTENDED)\r\n{\r\nprintk(KERN_WARNING "Sequencer: Invalid level 2 event %x\n", ev_code);\r\nreturn -EINVAL;\r\n}\r\nev_size = 8;\r\nif (c < ev_size)\r\n{\r\nif (!seq_playing)\r\nseq_startplay();\r\nreturn count - c;\r\n}\r\nif (copy_from_user((char *)&event_rec[4],\r\n&(buf)[p + 4], 4))\r\ngoto out;\r\n}\r\nelse\r\n{\r\nif (seq_mode == SEQ_2)\r\n{\r\nprintk(KERN_WARNING "Sequencer: 4 byte event in level 2 mode\n");\r\nreturn -EINVAL;\r\n}\r\nev_size = 4;\r\nif (event_rec[0] != SEQ_MIDIPUTC)\r\nobsolete_api_used = 1;\r\n}\r\nif (event_rec[0] == SEQ_MIDIPUTC)\r\n{\r\nif (!midi_opened[event_rec[2]])\r\n{\r\nint err, mode;\r\nint dev = event_rec[2];\r\nif (dev >= max_mididev || midi_devs[dev]==NULL)\r\n{\r\nreturn -ENXIO;\r\n}\r\nmode = translate_mode(file);\r\nif ((err = midi_devs[dev]->open(dev, mode,\r\nsequencer_midi_input, sequencer_midi_output)) < 0)\r\n{\r\nseq_reset();\r\nprintk(KERN_WARNING "Sequencer Error: Unable to open Midi #%d\n", dev);\r\nreturn err;\r\n}\r\nmidi_opened[dev] = 1;\r\n}\r\n}\r\nif (!seq_queue(event_rec, (file->f_flags & (O_NONBLOCK) ? 1 : 0)))\r\n{\r\nint processed = count - c;\r\nif (!seq_playing)\r\nseq_startplay();\r\nif (!processed && (file->f_flags & O_NONBLOCK))\r\nreturn -EAGAIN;\r\nelse\r\nreturn processed;\r\n}\r\np += ev_size;\r\nc -= ev_size;\r\n}\r\nif (!seq_playing)\r\nseq_startplay();\r\nout:\r\nreturn count;\r\n}\r\nstatic int seq_queue(unsigned char *note, char nonblock)\r\n{\r\nif (qlen >= SEQ_MAX_QUEUE)\r\nif (!seq_playing)\r\nseq_startplay();\r\nif (!nonblock && qlen >= SEQ_MAX_QUEUE && !waitqueue_active(&seq_sleeper)) {\r\ninterruptible_sleep_on(&seq_sleeper);\r\n}\r\nif (qlen >= SEQ_MAX_QUEUE)\r\n{\r\nreturn 0;\r\n}\r\nmemcpy(&queue[qtail * EV_SZ], note, EV_SZ);\r\nqtail = (qtail + 1) % SEQ_MAX_QUEUE;\r\nqlen++;\r\nreturn 1;\r\n}\r\nstatic int extended_event(unsigned char *q)\r\n{\r\nint dev = q[2];\r\nif (dev < 0 || dev >= max_synthdev)\r\nreturn -ENXIO;\r\nif (!(synth_open_mask & (1 << dev)))\r\nreturn -ENXIO;\r\nswitch (q[1])\r\n{\r\ncase SEQ_NOTEOFF:\r\nsynth_devs[dev]->kill_note(dev, q[3], q[4], q[5]);\r\nbreak;\r\ncase SEQ_NOTEON:\r\nif (q[4] > 127 && q[4] != 255)\r\nreturn 0;\r\nif (q[5] == 0)\r\n{\r\nsynth_devs[dev]->kill_note(dev, q[3], q[4], q[5]);\r\nbreak;\r\n}\r\nsynth_devs[dev]->start_note(dev, q[3], q[4], q[5]);\r\nbreak;\r\ncase SEQ_PGMCHANGE:\r\nsynth_devs[dev]->set_instr(dev, q[3], q[4]);\r\nbreak;\r\ncase SEQ_AFTERTOUCH:\r\nsynth_devs[dev]->aftertouch(dev, q[3], q[4]);\r\nbreak;\r\ncase SEQ_BALANCE:\r\nsynth_devs[dev]->panning(dev, q[3], (char) q[4]);\r\nbreak;\r\ncase SEQ_CONTROLLER:\r\nsynth_devs[dev]->controller(dev, q[3], q[4], (short) (q[5] | (q[6] << 8)));\r\nbreak;\r\ncase SEQ_VOLMODE:\r\nif (synth_devs[dev]->volume_method != NULL)\r\nsynth_devs[dev]->volume_method(dev, q[3]);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int find_voice(int dev, int chn, int note)\r\n{\r\nunsigned short key;\r\nint i;\r\nkey = (chn << 8) | (note + 1);\r\nfor (i = 0; i < synth_devs[dev]->alloc.max_voice; i++)\r\nif (synth_devs[dev]->alloc.map[i] == key)\r\nreturn i;\r\nreturn -1;\r\n}\r\nstatic int alloc_voice(int dev, int chn, int note)\r\n{\r\nunsigned short key;\r\nint voice;\r\nkey = (chn << 8) | (note + 1);\r\nvoice = synth_devs[dev]->alloc_voice(dev, chn, note,\r\n&synth_devs[dev]->alloc);\r\nsynth_devs[dev]->alloc.map[voice] = key;\r\nsynth_devs[dev]->alloc.alloc_times[voice] =\r\nsynth_devs[dev]->alloc.timestamp++;\r\nreturn voice;\r\n}\r\nstatic void seq_chn_voice_event(unsigned char *event_rec)\r\n{\r\n#define dev event_rec[1]\r\n#define cmd event_rec[2]\r\n#define chn event_rec[3]\r\n#define note event_rec[4]\r\n#define parm event_rec[5]\r\nint voice = -1;\r\nif ((int) dev > max_synthdev || synth_devs[dev] == NULL)\r\nreturn;\r\nif (!(synth_open_mask & (1 << dev)))\r\nreturn;\r\nif (!synth_devs[dev])\r\nreturn;\r\nif (seq_mode == SEQ_2)\r\n{\r\nif (synth_devs[dev]->alloc_voice)\r\nvoice = find_voice(dev, chn, note);\r\nif (cmd == MIDI_NOTEON && parm == 0)\r\n{\r\ncmd = MIDI_NOTEOFF;\r\nparm = 64;\r\n}\r\n}\r\nswitch (cmd)\r\n{\r\ncase MIDI_NOTEON:\r\nif (note > 127 && note != 255)\r\nreturn;\r\nif (voice == -1 && seq_mode == SEQ_2 && synth_devs[dev]->alloc_voice)\r\n{\r\nvoice = alloc_voice(dev, chn, note);\r\n}\r\nif (voice == -1)\r\nvoice = chn;\r\nif (seq_mode == SEQ_2 && (int) dev < num_synths)\r\n{\r\nif (chn == 9)\r\n{\r\nsynth_devs[dev]->set_instr(dev, voice, 128 + note);\r\nsynth_devs[dev]->chn_info[chn].pgm_num = 128 + note;\r\n}\r\nsynth_devs[dev]->setup_voice(dev, voice, chn);\r\n}\r\nsynth_devs[dev]->start_note(dev, voice, note, parm);\r\nbreak;\r\ncase MIDI_NOTEOFF:\r\nif (voice == -1)\r\nvoice = chn;\r\nsynth_devs[dev]->kill_note(dev, voice, note, parm);\r\nbreak;\r\ncase MIDI_KEY_PRESSURE:\r\nif (voice == -1)\r\nvoice = chn;\r\nsynth_devs[dev]->aftertouch(dev, voice, parm);\r\nbreak;\r\ndefault:;\r\n}\r\n#undef dev\r\n#undef cmd\r\n#undef chn\r\n#undef note\r\n#undef parm\r\n}\r\nstatic void seq_chn_common_event(unsigned char *event_rec)\r\n{\r\nunsigned char dev = event_rec[1];\r\nunsigned char cmd = event_rec[2];\r\nunsigned char chn = event_rec[3];\r\nunsigned char p1 = event_rec[4];\r\nunsigned short w14 = *(short *) &event_rec[6];\r\nif ((int) dev > max_synthdev || synth_devs[dev] == NULL)\r\nreturn;\r\nif (!(synth_open_mask & (1 << dev)))\r\nreturn;\r\nif (!synth_devs[dev])\r\nreturn;\r\nswitch (cmd)\r\n{\r\ncase MIDI_PGM_CHANGE:\r\nif (seq_mode == SEQ_2)\r\n{\r\nif (chn > 15)\r\nbreak;\r\nsynth_devs[dev]->chn_info[chn].pgm_num = p1;\r\nif ((int) dev >= num_synths)\r\nsynth_devs[dev]->set_instr(dev, chn, p1);\r\n}\r\nelse\r\nsynth_devs[dev]->set_instr(dev, chn, p1);\r\nbreak;\r\ncase MIDI_CTL_CHANGE:\r\nif (seq_mode == SEQ_2)\r\n{\r\nif (chn > 15 || p1 > 127)\r\nbreak;\r\nsynth_devs[dev]->chn_info[chn].controllers[p1] = w14 & 0x7f;\r\nif (p1 < 32)\r\nsynth_devs[dev]->chn_info[chn].controllers[p1 + 32] = 0;\r\nif ((int) dev < num_synths)\r\n{\r\nint val = w14 & 0x7f;\r\nint i, key;\r\nif (p1 < 64)\r\n{\r\nval = ((synth_devs[dev]->\r\nchn_info[chn].controllers[p1 & ~32] & 0x7f) << 7)\r\n| (synth_devs[dev]->\r\nchn_info[chn].controllers[p1 | 32] & 0x7f);\r\np1 &= ~32;\r\n}\r\nkey = ((int) chn << 8);\r\nfor (i = 0; i < synth_devs[dev]->alloc.max_voice; i++)\r\nif ((synth_devs[dev]->alloc.map[i] & 0xff00) == key)\r\nsynth_devs[dev]->controller(dev, i, p1, val);\r\n}\r\nelse\r\nsynth_devs[dev]->controller(dev, chn, p1, w14);\r\n}\r\nelse\r\nsynth_devs[dev]->controller(dev, chn, p1, w14);\r\nbreak;\r\ncase MIDI_PITCH_BEND:\r\nif (seq_mode == SEQ_2)\r\n{\r\nif (chn > 15)\r\nbreak;\r\nsynth_devs[dev]->chn_info[chn].bender_value = w14;\r\nif ((int) dev < num_synths)\r\n{\r\nint i, key;\r\nkey = (chn << 8);\r\nfor (i = 0; i < synth_devs[dev]->alloc.max_voice; i++)\r\nif ((synth_devs[dev]->alloc.map[i] & 0xff00) == key)\r\nsynth_devs[dev]->bender(dev, i, w14);\r\n}\r\nelse\r\nsynth_devs[dev]->bender(dev, chn, w14);\r\n}\r\nelse\r\nsynth_devs[dev]->bender(dev, chn, w14);\r\nbreak;\r\ndefault:;\r\n}\r\n}\r\nstatic int seq_timing_event(unsigned char *event_rec)\r\n{\r\nunsigned char cmd = event_rec[1];\r\nunsigned int parm = *(int *) &event_rec[4];\r\nif (seq_mode == SEQ_2)\r\n{\r\nint ret;\r\nif ((ret = tmr->event(tmr_no, event_rec)) == TIMER_ARMED)\r\nif ((SEQ_MAX_QUEUE - qlen) >= output_threshold)\r\nwake_up(&seq_sleeper);\r\nreturn ret;\r\n}\r\nswitch (cmd)\r\n{\r\ncase TMR_WAIT_REL:\r\nparm += prev_event_time;\r\ncase TMR_WAIT_ABS:\r\nif (parm > 0)\r\n{\r\nlong time;\r\ntime = parm;\r\nprev_event_time = time;\r\nseq_playing = 1;\r\nrequest_sound_timer(time);\r\nif ((SEQ_MAX_QUEUE - qlen) >= output_threshold)\r\nwake_up(&seq_sleeper);\r\nreturn TIMER_ARMED;\r\n}\r\nbreak;\r\ncase TMR_START:\r\nseq_time = jiffies;\r\nprev_input_time = 0;\r\nprev_event_time = 0;\r\nbreak;\r\ncase TMR_STOP:\r\nbreak;\r\ncase TMR_CONTINUE:\r\nbreak;\r\ncase TMR_TEMPO:\r\nbreak;\r\ncase TMR_ECHO:\r\nif (seq_mode == SEQ_2)\r\nseq_copy_to_input(event_rec, 8);\r\nelse\r\n{\r\nparm = (parm << 8 | SEQ_ECHO);\r\nseq_copy_to_input((unsigned char *) &parm, 4);\r\n}\r\nbreak;\r\ndefault:;\r\n}\r\nreturn TIMER_NOT_ARMED;\r\n}\r\nstatic void seq_local_event(unsigned char *event_rec)\r\n{\r\nunsigned char cmd = event_rec[1];\r\nunsigned int parm = *((unsigned int *) &event_rec[4]);\r\nswitch (cmd)\r\n{\r\ncase LOCL_STARTAUDIO:\r\nDMAbuf_start_devices(parm);\r\nbreak;\r\ndefault:;\r\n}\r\n}\r\nstatic void seq_sysex_message(unsigned char *event_rec)\r\n{\r\nunsigned int dev = event_rec[1];\r\nint i, l = 0;\r\nunsigned char *buf = &event_rec[2];\r\nif (dev > max_synthdev)\r\nreturn;\r\nif (!(synth_open_mask & (1 << dev)))\r\nreturn;\r\nif (!synth_devs[dev])\r\nreturn;\r\nl = 0;\r\nfor (i = 0; i < 6 && buf[i] != 0xff; i++)\r\nl = i + 1;\r\nif (!synth_devs[dev]->send_sysex)\r\nreturn;\r\nif (l > 0)\r\nsynth_devs[dev]->send_sysex(dev, buf, l);\r\n}\r\nstatic int play_event(unsigned char *q)\r\n{\r\nunsigned int *delay;\r\nswitch (q[0])\r\n{\r\ncase SEQ_NOTEOFF:\r\nif (synth_open_mask & (1 << 0))\r\nif (synth_devs[0])\r\nsynth_devs[0]->kill_note(0, q[1], 255, q[3]);\r\nbreak;\r\ncase SEQ_NOTEON:\r\nif (q[4] < 128 || q[4] == 255)\r\nif (synth_open_mask & (1 << 0))\r\nif (synth_devs[0])\r\nsynth_devs[0]->start_note(0, q[1], q[2], q[3]);\r\nbreak;\r\ncase SEQ_WAIT:\r\ndelay = (unsigned int *) q;\r\n*delay = (*delay >> 8) & 0xffffff;\r\nif (*delay > 0)\r\n{\r\nlong time;\r\nseq_playing = 1;\r\ntime = *delay;\r\nprev_event_time = time;\r\nrequest_sound_timer(time);\r\nif ((SEQ_MAX_QUEUE - qlen) >= output_threshold)\r\nwake_up(&seq_sleeper);\r\nreturn 1;\r\n}\r\nbreak;\r\ncase SEQ_PGMCHANGE:\r\nif (synth_open_mask & (1 << 0))\r\nif (synth_devs[0])\r\nsynth_devs[0]->set_instr(0, q[1], q[2]);\r\nbreak;\r\ncase SEQ_SYNCTIMER:\r\nseq_time = jiffies;\r\nprev_input_time = 0;\r\nprev_event_time = 0;\r\nbreak;\r\ncase SEQ_MIDIPUTC:\r\nif (midi_opened[q[2]])\r\n{\r\nint dev;\r\ndev = q[2];\r\nif (dev < 0 || dev >= num_midis || midi_devs[dev] == NULL)\r\nbreak;\r\nif (!midi_devs[dev]->outputc(dev, q[1]))\r\n{\r\nseq_playing = 1;\r\nrequest_sound_timer(-1);\r\nreturn 2;\r\n}\r\nelse\r\nmidi_written[dev] = 1;\r\n}\r\nbreak;\r\ncase SEQ_ECHO:\r\nseq_copy_to_input(q, 4);\r\nbreak;\r\ncase SEQ_PRIVATE:\r\nif ((int) q[1] < max_synthdev)\r\nsynth_devs[q[1]]->hw_control(q[1], q);\r\nbreak;\r\ncase SEQ_EXTENDED:\r\nextended_event(q);\r\nbreak;\r\ncase EV_CHN_VOICE:\r\nseq_chn_voice_event(q);\r\nbreak;\r\ncase EV_CHN_COMMON:\r\nseq_chn_common_event(q);\r\nbreak;\r\ncase EV_TIMING:\r\nif (seq_timing_event(q) == TIMER_ARMED)\r\n{\r\nreturn 1;\r\n}\r\nbreak;\r\ncase EV_SEQ_LOCAL:\r\nseq_local_event(q);\r\nbreak;\r\ncase EV_SYSEX:\r\nseq_sysex_message(q);\r\nbreak;\r\ndefault:;\r\n}\r\nreturn 0;\r\n}\r\nstatic void seq_startplay(void)\r\n{\r\nint this_one, action;\r\nunsigned long flags;\r\nwhile (qlen > 0)\r\n{\r\nspin_lock_irqsave(&lock,flags);\r\nqhead = ((this_one = qhead) + 1) % SEQ_MAX_QUEUE;\r\nqlen--;\r\nspin_unlock_irqrestore(&lock,flags);\r\nseq_playing = 1;\r\nif ((action = play_event(&queue[this_one * EV_SZ])))\r\n{\r\nif (action == 2)\r\n{\r\nqlen++;\r\nqhead = this_one;\r\n}\r\nreturn;\r\n}\r\n}\r\nseq_playing = 0;\r\nif ((SEQ_MAX_QUEUE - qlen) >= output_threshold)\r\nwake_up(&seq_sleeper);\r\n}\r\nstatic void reset_controllers(int dev, unsigned char *controller, int update_dev)\r\n{\r\nint i;\r\nfor (i = 0; i < 128; i++)\r\ncontroller[i] = ctrl_def_values[i];\r\n}\r\nstatic void setup_mode2(void)\r\n{\r\nint dev;\r\nmax_synthdev = num_synths;\r\nfor (dev = 0; dev < num_midis; dev++)\r\n{\r\nif (midi_devs[dev] && midi_devs[dev]->converter != NULL)\r\n{\r\nsynth_devs[max_synthdev++] = midi_devs[dev]->converter;\r\n}\r\n}\r\nfor (dev = 0; dev < max_synthdev; dev++)\r\n{\r\nint chn;\r\nsynth_devs[dev]->sysex_ptr = 0;\r\nsynth_devs[dev]->emulation = 0;\r\nfor (chn = 0; chn < 16; chn++)\r\n{\r\nsynth_devs[dev]->chn_info[chn].pgm_num = 0;\r\nreset_controllers(dev,\r\nsynth_devs[dev]->chn_info[chn].controllers,0);\r\nsynth_devs[dev]->chn_info[chn].bender_value = (1 << 7);\r\nsynth_devs[dev]->chn_info[chn].bender_range = 200;\r\n}\r\n}\r\nmax_mididev = 0;\r\nseq_mode = SEQ_2;\r\n}\r\nint sequencer_open(int dev, struct file *file)\r\n{\r\nint retval, mode, i;\r\nint level, tmp;\r\nif (!sequencer_ok)\r\nsequencer_init();\r\nlevel = ((dev & 0x0f) == SND_DEV_SEQ2) ? 2 : 1;\r\ndev = dev >> 4;\r\nmode = translate_mode(file);\r\nDEB(printk("sequencer_open(dev=%d)\n", dev));\r\nif (!sequencer_ok)\r\n{\r\nreturn -ENXIO;\r\n}\r\nif (dev)\r\nreturn -ENXIO;\r\nif(synth_devs[dev] == NULL)\r\nrequest_module("synth0");\r\nif (mode == OPEN_READ)\r\n{\r\nif (!num_midis)\r\n{\r\nsequencer_busy = 0;\r\nreturn -ENXIO;\r\n}\r\n}\r\nif (sequencer_busy)\r\n{\r\nreturn -EBUSY;\r\n}\r\nsequencer_busy = 1;\r\nobsolete_api_used = 0;\r\nmax_mididev = num_midis;\r\nmax_synthdev = num_synths;\r\npre_event_timeout = MAX_SCHEDULE_TIMEOUT;\r\nseq_mode = SEQ_1;\r\nif (pending_timer != -1)\r\n{\r\ntmr_no = pending_timer;\r\npending_timer = -1;\r\n}\r\nif (tmr_no == -1)\r\n{\r\nint i, best;\r\nbest = -1;\r\nfor (i = 0; i < num_sound_timers; i++)\r\nif (sound_timer_devs[i] && sound_timer_devs[i]->priority > best)\r\n{\r\ntmr_no = i;\r\nbest = sound_timer_devs[i]->priority;\r\n}\r\nif (tmr_no == -1)\r\ntmr_no = 0;\r\n}\r\ntmr = sound_timer_devs[tmr_no];\r\nif (level == 2)\r\n{\r\nif (tmr == NULL)\r\n{\r\nsequencer_busy = 0;\r\nreturn -ENXIO;\r\n}\r\nsetup_mode2();\r\n}\r\nif (!max_synthdev && !max_mididev)\r\n{\r\nsequencer_busy=0;\r\nreturn -ENXIO;\r\n}\r\nsynth_open_mask = 0;\r\nfor (i = 0; i < max_mididev; i++)\r\n{\r\nmidi_opened[i] = 0;\r\nmidi_written[i] = 0;\r\n}\r\nfor (i = 0; i < max_synthdev; i++)\r\n{\r\nif (synth_devs[i]==NULL)\r\ncontinue;\r\nif (!try_module_get(synth_devs[i]->owner))\r\ncontinue;\r\nif ((tmp = synth_devs[i]->open(i, mode)) < 0)\r\n{\r\nprintk(KERN_WARNING "Sequencer: Warning! Cannot open synth device #%d (%d)\n", i, tmp);\r\nif (synth_devs[i]->midi_dev)\r\nprintk(KERN_WARNING "(Maps to MIDI dev #%d)\n", synth_devs[i]->midi_dev);\r\n}\r\nelse\r\n{\r\nsynth_open_mask |= (1 << i);\r\nif (synth_devs[i]->midi_dev)\r\nmidi_opened[synth_devs[i]->midi_dev] = 1;\r\n}\r\n}\r\nseq_time = jiffies;\r\nprev_input_time = 0;\r\nprev_event_time = 0;\r\nif (seq_mode == SEQ_1 && (mode == OPEN_READ || mode == OPEN_READWRITE))\r\n{\r\nfor (i = 0; i < max_mididev; i++)\r\nif (!midi_opened[i] && midi_devs[i])\r\n{\r\nif (!try_module_get(midi_devs[i]->owner))\r\ncontinue;\r\nif ((retval = midi_devs[i]->open(i, mode,\r\nsequencer_midi_input, sequencer_midi_output)) >= 0)\r\n{\r\nmidi_opened[i] = 1;\r\n}\r\n}\r\n}\r\nif (seq_mode == SEQ_2) {\r\nif (try_module_get(tmr->owner))\r\ntmr->open(tmr_no, seq_mode);\r\n}\r\ninit_waitqueue_head(&seq_sleeper);\r\ninit_waitqueue_head(&midi_sleeper);\r\noutput_threshold = SEQ_MAX_QUEUE / 2;\r\nreturn 0;\r\n}\r\nstatic void seq_drain_midi_queues(void)\r\n{\r\nint i, n;\r\nn = 1;\r\nwhile (!signal_pending(current) && n)\r\n{\r\nn = 0;\r\nfor (i = 0; i < max_mididev; i++)\r\nif (midi_opened[i] && midi_written[i])\r\nif (midi_devs[i]->buffer_status != NULL)\r\nif (midi_devs[i]->buffer_status(i))\r\nn++;\r\nif (n)\r\ninterruptible_sleep_on_timeout(&seq_sleeper,\r\nHZ/10);\r\n}\r\n}\r\nvoid sequencer_release(int dev, struct file *file)\r\n{\r\nint i;\r\nint mode = translate_mode(file);\r\ndev = dev >> 4;\r\nDEB(printk("sequencer_release(dev=%d)\n", dev));\r\nif (mode != OPEN_READ && !(file->f_flags & O_NONBLOCK))\r\n{\r\nwhile (!signal_pending(current) && qlen > 0)\r\n{\r\nseq_sync();\r\ninterruptible_sleep_on_timeout(&seq_sleeper,\r\n3*HZ);\r\n}\r\n}\r\nif (mode != OPEN_READ)\r\nseq_drain_midi_queues();\r\nseq_reset();\r\nif (mode != OPEN_READ)\r\nseq_drain_midi_queues();\r\nfor (i = 0; i < max_synthdev; i++)\r\n{\r\nif (synth_open_mask & (1 << i))\r\nif (synth_devs[i])\r\n{\r\nsynth_devs[i]->close(i);\r\nmodule_put(synth_devs[i]->owner);\r\nif (synth_devs[i]->midi_dev)\r\nmidi_opened[synth_devs[i]->midi_dev] = 0;\r\n}\r\n}\r\nfor (i = 0; i < max_mididev; i++)\r\n{\r\nif (midi_opened[i]) {\r\nmidi_devs[i]->close(i);\r\nmodule_put(midi_devs[i]->owner);\r\n}\r\n}\r\nif (seq_mode == SEQ_2) {\r\ntmr->close(tmr_no);\r\nmodule_put(tmr->owner);\r\n}\r\nif (obsolete_api_used)\r\nprintk(KERN_WARNING "/dev/music: Obsolete (4 byte) API was used by %s\n", current->comm);\r\nsequencer_busy = 0;\r\n}\r\nstatic int seq_sync(void)\r\n{\r\nif (qlen && !seq_playing && !signal_pending(current))\r\nseq_startplay();\r\nif (qlen > 0)\r\ninterruptible_sleep_on_timeout(&seq_sleeper, HZ);\r\nreturn qlen;\r\n}\r\nstatic void midi_outc(int dev, unsigned char data)\r\n{\r\nint n;\r\nunsigned long flags;\r\nn = 3 * HZ;\r\nspin_lock_irqsave(&lock,flags);\r\nwhile (n && !midi_devs[dev]->outputc(dev, data)) {\r\ninterruptible_sleep_on_timeout(&seq_sleeper, HZ/25);\r\nn--;\r\n}\r\nspin_unlock_irqrestore(&lock,flags);\r\n}\r\nstatic void seq_reset(void)\r\n{\r\nint i;\r\nint chn;\r\nunsigned long flags;\r\nsound_stop_timer();\r\nseq_time = jiffies;\r\nprev_input_time = 0;\r\nprev_event_time = 0;\r\nqlen = qhead = qtail = 0;\r\niqlen = iqhead = iqtail = 0;\r\nfor (i = 0; i < max_synthdev; i++)\r\nif (synth_open_mask & (1 << i))\r\nif (synth_devs[i])\r\nsynth_devs[i]->reset(i);\r\nif (seq_mode == SEQ_2)\r\n{\r\nfor (chn = 0; chn < 16; chn++)\r\nfor (i = 0; i < max_synthdev; i++)\r\nif (synth_open_mask & (1 << i))\r\nif (synth_devs[i])\r\n{\r\nsynth_devs[i]->controller(i, chn, 123, 0);\r\nsynth_devs[i]->controller(i, chn, 121, 0);\r\nsynth_devs[i]->bender(i, chn, 1 << 13);\r\n}\r\n}\r\nelse\r\n{\r\nfor (i = 0; i < max_mididev; i++)\r\nif (midi_written[i])\r\n{\r\nmidi_outc(i, 0xfe);\r\nfor (chn = 0; chn < 16; chn++)\r\n{\r\nmidi_outc(i, (unsigned char) (0xb0 + (chn & 0x0f)));\r\nmidi_outc(i, 0x7b);\r\nmidi_outc(i, 0);\r\n}\r\nmidi_devs[i]->close(i);\r\nmidi_written[i] = 0;\r\nmidi_opened[i] = 0;\r\n}\r\n}\r\nseq_playing = 0;\r\nspin_lock_irqsave(&lock,flags);\r\nif (waitqueue_active(&seq_sleeper)) {\r\nwake_up(&seq_sleeper);\r\n}\r\nspin_unlock_irqrestore(&lock,flags);\r\n}\r\nstatic void seq_panic(void)\r\n{\r\nseq_reset();\r\n}\r\nint sequencer_ioctl(int dev, struct file *file, unsigned int cmd, void __user *arg)\r\n{\r\nint midi_dev, orig_dev, val, err;\r\nint mode = translate_mode(file);\r\nstruct synth_info inf;\r\nstruct seq_event_rec event_rec;\r\nunsigned long flags;\r\nint __user *p = arg;\r\norig_dev = dev = dev >> 4;\r\nswitch (cmd)\r\n{\r\ncase SNDCTL_TMR_TIMEBASE:\r\ncase SNDCTL_TMR_TEMPO:\r\ncase SNDCTL_TMR_START:\r\ncase SNDCTL_TMR_STOP:\r\ncase SNDCTL_TMR_CONTINUE:\r\ncase SNDCTL_TMR_METRONOME:\r\ncase SNDCTL_TMR_SOURCE:\r\nif (seq_mode != SEQ_2)\r\nreturn -EINVAL;\r\nreturn tmr->ioctl(tmr_no, cmd, arg);\r\ncase SNDCTL_TMR_SELECT:\r\nif (seq_mode != SEQ_2)\r\nreturn -EINVAL;\r\nif (get_user(pending_timer, p))\r\nreturn -EFAULT;\r\nif (pending_timer < 0 || pending_timer >= num_sound_timers || sound_timer_devs[pending_timer] == NULL)\r\n{\r\npending_timer = -1;\r\nreturn -EINVAL;\r\n}\r\nval = pending_timer;\r\nbreak;\r\ncase SNDCTL_SEQ_PANIC:\r\nseq_panic();\r\nreturn -EINVAL;\r\ncase SNDCTL_SEQ_SYNC:\r\nif (mode == OPEN_READ)\r\nreturn 0;\r\nwhile (qlen > 0 && !signal_pending(current))\r\nseq_sync();\r\nreturn qlen ? -EINTR : 0;\r\ncase SNDCTL_SEQ_RESET:\r\nseq_reset();\r\nreturn 0;\r\ncase SNDCTL_SEQ_TESTMIDI:\r\nif (__get_user(midi_dev, p))\r\nreturn -EFAULT;\r\nif (midi_dev < 0 || midi_dev >= max_mididev || !midi_devs[midi_dev])\r\nreturn -ENXIO;\r\nif (!midi_opened[midi_dev] &&\r\n(err = midi_devs[midi_dev]->open(midi_dev, mode, sequencer_midi_input,\r\nsequencer_midi_output)) < 0)\r\nreturn err;\r\nmidi_opened[midi_dev] = 1;\r\nreturn 0;\r\ncase SNDCTL_SEQ_GETINCOUNT:\r\nif (mode == OPEN_WRITE)\r\nreturn 0;\r\nval = iqlen;\r\nbreak;\r\ncase SNDCTL_SEQ_GETOUTCOUNT:\r\nif (mode == OPEN_READ)\r\nreturn 0;\r\nval = SEQ_MAX_QUEUE - qlen;\r\nbreak;\r\ncase SNDCTL_SEQ_GETTIME:\r\nif (seq_mode == SEQ_2)\r\nreturn tmr->ioctl(tmr_no, cmd, arg);\r\nval = jiffies - seq_time;\r\nbreak;\r\ncase SNDCTL_SEQ_CTRLRATE:\r\nif (seq_mode == SEQ_2)\r\nreturn tmr->ioctl(tmr_no, cmd, arg);\r\nif (get_user(val, p))\r\nreturn -EFAULT;\r\nif (val != 0)\r\nreturn -EINVAL;\r\nval = HZ;\r\nbreak;\r\ncase SNDCTL_SEQ_RESETSAMPLES:\r\ncase SNDCTL_SYNTH_REMOVESAMPLE:\r\ncase SNDCTL_SYNTH_CONTROL:\r\nif (get_user(dev, p))\r\nreturn -EFAULT;\r\nif (dev < 0 || dev >= num_synths || synth_devs[dev] == NULL)\r\nreturn -ENXIO;\r\nif (!(synth_open_mask & (1 << dev)) && !orig_dev)\r\nreturn -EBUSY;\r\nreturn synth_devs[dev]->ioctl(dev, cmd, arg);\r\ncase SNDCTL_SEQ_NRSYNTHS:\r\nval = max_synthdev;\r\nbreak;\r\ncase SNDCTL_SEQ_NRMIDIS:\r\nval = max_mididev;\r\nbreak;\r\ncase SNDCTL_SYNTH_MEMAVL:\r\nif (get_user(dev, p))\r\nreturn -EFAULT;\r\nif (dev < 0 || dev >= num_synths || synth_devs[dev] == NULL)\r\nreturn -ENXIO;\r\nif (!(synth_open_mask & (1 << dev)) && !orig_dev)\r\nreturn -EBUSY;\r\nval = synth_devs[dev]->ioctl(dev, cmd, arg);\r\nbreak;\r\ncase SNDCTL_FM_4OP_ENABLE:\r\nif (get_user(dev, p))\r\nreturn -EFAULT;\r\nif (dev < 0 || dev >= num_synths || synth_devs[dev] == NULL)\r\nreturn -ENXIO;\r\nif (!(synth_open_mask & (1 << dev)))\r\nreturn -ENXIO;\r\nsynth_devs[dev]->ioctl(dev, cmd, arg);\r\nreturn 0;\r\ncase SNDCTL_SYNTH_INFO:\r\nif (get_user(dev, &((struct synth_info __user *)arg)->device))\r\nreturn -EFAULT;\r\nif (dev < 0 || dev >= max_synthdev)\r\nreturn -ENXIO;\r\nif (!(synth_open_mask & (1 << dev)) && !orig_dev)\r\nreturn -EBUSY;\r\nreturn synth_devs[dev]->ioctl(dev, cmd, arg);\r\ncase SNDCTL_SYNTH_ID:\r\nif (get_user(dev, &((struct synth_info __user *)arg)->device))\r\nreturn -EFAULT;\r\nif (dev < 0 || dev >= max_synthdev)\r\nreturn -ENXIO;\r\nif (!(synth_open_mask & (1 << dev)) && !orig_dev)\r\nreturn -EBUSY;\r\nmemcpy(&inf, synth_devs[dev]->info, sizeof(inf));\r\nstrlcpy(inf.name, synth_devs[dev]->id, sizeof(inf.name));\r\ninf.device = dev;\r\nreturn copy_to_user(arg, &inf, sizeof(inf))?-EFAULT:0;\r\ncase SNDCTL_SEQ_OUTOFBAND:\r\nif (copy_from_user(&event_rec, arg, sizeof(event_rec)))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&lock,flags);\r\nplay_event(event_rec.arr);\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn 0;\r\ncase SNDCTL_MIDI_INFO:\r\nif (get_user(dev, &((struct midi_info __user *)arg)->device))\r\nreturn -EFAULT;\r\nif (dev < 0 || dev >= max_mididev || !midi_devs[dev])\r\nreturn -ENXIO;\r\nmidi_devs[dev]->info.device = dev;\r\nreturn copy_to_user(arg, &midi_devs[dev]->info, sizeof(struct midi_info))?-EFAULT:0;\r\ncase SNDCTL_SEQ_THRESHOLD:\r\nif (get_user(val, p))\r\nreturn -EFAULT;\r\nif (val < 1)\r\nval = 1;\r\nif (val >= SEQ_MAX_QUEUE)\r\nval = SEQ_MAX_QUEUE - 1;\r\noutput_threshold = val;\r\nreturn 0;\r\ncase SNDCTL_MIDI_PRETIME:\r\nif (get_user(val, p))\r\nreturn -EFAULT;\r\nif (val < 0)\r\nval = 0;\r\nval = (HZ * val) / 10;\r\npre_event_timeout = val;\r\nbreak;\r\ndefault:\r\nif (mode == OPEN_READ)\r\nreturn -EIO;\r\nif (!synth_devs[0])\r\nreturn -ENXIO;\r\nif (!(synth_open_mask & (1 << 0)))\r\nreturn -ENXIO;\r\nif (!synth_devs[0]->ioctl)\r\nreturn -EINVAL;\r\nreturn synth_devs[0]->ioctl(0, cmd, arg);\r\n}\r\nreturn put_user(val, p);\r\n}\r\nunsigned int sequencer_poll(int dev, struct file *file, poll_table * wait)\r\n{\r\nunsigned long flags;\r\nunsigned int mask = 0;\r\ndev = dev >> 4;\r\nspin_lock_irqsave(&lock,flags);\r\npoll_wait(file, &midi_sleeper, wait);\r\nif (iqlen)\r\nmask |= POLLIN | POLLRDNORM;\r\npoll_wait(file, &seq_sleeper, wait);\r\nif ((SEQ_MAX_QUEUE - qlen) >= output_threshold)\r\nmask |= POLLOUT | POLLWRNORM;\r\nspin_unlock_irqrestore(&lock,flags);\r\nreturn mask;\r\n}\r\nvoid sequencer_timer(unsigned long dummy)\r\n{\r\nseq_startplay();\r\n}\r\nint note_to_freq(int note_num)\r\n{\r\nint note, octave, note_freq;\r\nstatic int notes[] =\r\n{\r\n261632, 277189, 293671, 311132, 329632, 349232,\r\n369998, 391998, 415306, 440000, 466162, 493880\r\n};\r\n#define BASE_OCTAVE 5\r\noctave = note_num / 12;\r\nnote = note_num % 12;\r\nnote_freq = notes[note];\r\nif (octave < BASE_OCTAVE)\r\nnote_freq >>= (BASE_OCTAVE - octave);\r\nelse if (octave > BASE_OCTAVE)\r\nnote_freq <<= (octave - BASE_OCTAVE);\r\nreturn note_freq;\r\n}\r\nunsigned long compute_finetune(unsigned long base_freq, int bend, int range,\r\nint vibrato_cents)\r\n{\r\nunsigned long amount;\r\nint negative, semitones, cents, multiplier = 1;\r\nif (!bend)\r\nreturn base_freq;\r\nif (!range)\r\nreturn base_freq;\r\nif (!base_freq)\r\nreturn base_freq;\r\nif (range >= 8192)\r\nrange = 8192;\r\nbend = bend * range / 8192;\r\nbend += vibrato_cents;\r\nif (!bend)\r\nreturn base_freq;\r\nnegative = bend < 0 ? 1 : 0;\r\nif (bend < 0)\r\nbend *= -1;\r\nif (bend > range)\r\nbend = range;\r\nwhile (bend > 2399)\r\n{\r\nmultiplier *= 4;\r\nbend -= 2400;\r\n}\r\nsemitones = bend / 100;\r\ncents = bend % 100;\r\namount = (int) (semitone_tuning[semitones] * multiplier * cent_tuning[cents]) / 10000;\r\nif (negative)\r\nreturn (base_freq * 10000) / amount;\r\nelse\r\nreturn (base_freq * amount) / 10000;\r\n}\r\nvoid sequencer_init(void)\r\n{\r\nif (sequencer_ok)\r\nreturn;\r\nqueue = vmalloc(SEQ_MAX_QUEUE * EV_SZ);\r\nif (queue == NULL)\r\n{\r\nprintk(KERN_ERR "sequencer: Can't allocate memory for sequencer output queue\n");\r\nreturn;\r\n}\r\niqueue = vmalloc(SEQ_MAX_QUEUE * IEV_SZ);\r\nif (iqueue == NULL)\r\n{\r\nprintk(KERN_ERR "sequencer: Can't allocate memory for sequencer input queue\n");\r\nvfree(queue);\r\nreturn;\r\n}\r\nsequencer_ok = 1;\r\n}\r\nvoid sequencer_unload(void)\r\n{\r\nvfree(queue);\r\nvfree(iqueue);\r\nqueue = iqueue = NULL;\r\n}
