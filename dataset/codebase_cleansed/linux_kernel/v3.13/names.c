static unsigned int hashnum(unsigned int num)\r\n{\r\nunsigned int mask1 = HASH1 << 27, mask2 = HASH2 << 27;\r\nfor (; mask1 >= HASH1; mask1 >>= 1, mask2 >>= 1)\r\nif (num & mask1)\r\nnum ^= mask2;\r\nreturn num & (HASHSZ-1);\r\n}\r\nconst char *names_vendor(u_int16_t vendorid)\r\n{\r\nstruct vendor *v;\r\nv = vendors[hashnum(vendorid)];\r\nfor (; v; v = v->next)\r\nif (v->vendorid == vendorid)\r\nreturn v->name;\r\nreturn NULL;\r\n}\r\nconst char *names_product(u_int16_t vendorid, u_int16_t productid)\r\n{\r\nstruct product *p;\r\np = products[hashnum((vendorid << 16) | productid)];\r\nfor (; p; p = p->next)\r\nif (p->vendorid == vendorid && p->productid == productid)\r\nreturn p->name;\r\nreturn NULL;\r\n}\r\nconst char *names_class(u_int8_t classid)\r\n{\r\nstruct class *c;\r\nc = classes[hashnum(classid)];\r\nfor (; c; c = c->next)\r\nif (c->classid == classid)\r\nreturn c->name;\r\nreturn NULL;\r\n}\r\nconst char *names_subclass(u_int8_t classid, u_int8_t subclassid)\r\n{\r\nstruct subclass *s;\r\ns = subclasses[hashnum((classid << 8) | subclassid)];\r\nfor (; s; s = s->next)\r\nif (s->classid == classid && s->subclassid == subclassid)\r\nreturn s->name;\r\nreturn NULL;\r\n}\r\nconst char *names_protocol(u_int8_t classid, u_int8_t subclassid,\r\nu_int8_t protocolid)\r\n{\r\nstruct protocol *p;\r\np = protocols[hashnum((classid << 16) | (subclassid << 8)\r\n| protocolid)];\r\nfor (; p; p = p->next)\r\nif (p->classid == classid && p->subclassid == subclassid &&\r\np->protocolid == protocolid)\r\nreturn p->name;\r\nreturn NULL;\r\n}\r\nstatic void *my_malloc(size_t size)\r\n{\r\nstruct pool *p;\r\np = calloc(1, sizeof(struct pool));\r\nif (!p) {\r\nfree(p);\r\nreturn NULL;\r\n}\r\np->mem = calloc(1, size);\r\nif (!p->mem)\r\nreturn NULL;\r\np->next = pool_head;\r\npool_head = p;\r\nreturn p->mem;\r\n}\r\nvoid names_free(void)\r\n{\r\nstruct pool *pool;\r\nif (!pool_head)\r\nreturn;\r\nfor (pool = pool_head; pool != NULL; ) {\r\nstruct pool *tmp;\r\nif (pool->mem)\r\nfree(pool->mem);\r\ntmp = pool;\r\npool = pool->next;\r\nfree(tmp);\r\n}\r\n}\r\nstatic int new_vendor(const char *name, u_int16_t vendorid)\r\n{\r\nstruct vendor *v;\r\nunsigned int h = hashnum(vendorid);\r\nv = vendors[h];\r\nfor (; v; v = v->next)\r\nif (v->vendorid == vendorid)\r\nreturn -1;\r\nv = my_malloc(sizeof(struct vendor) + strlen(name));\r\nif (!v)\r\nreturn -1;\r\nstrcpy(v->name, name);\r\nv->vendorid = vendorid;\r\nv->next = vendors[h];\r\nvendors[h] = v;\r\nreturn 0;\r\n}\r\nstatic int new_product(const char *name, u_int16_t vendorid,\r\nu_int16_t productid)\r\n{\r\nstruct product *p;\r\nunsigned int h = hashnum((vendorid << 16) | productid);\r\np = products[h];\r\nfor (; p; p = p->next)\r\nif (p->vendorid == vendorid && p->productid == productid)\r\nreturn -1;\r\np = my_malloc(sizeof(struct product) + strlen(name));\r\nif (!p)\r\nreturn -1;\r\nstrcpy(p->name, name);\r\np->vendorid = vendorid;\r\np->productid = productid;\r\np->next = products[h];\r\nproducts[h] = p;\r\nreturn 0;\r\n}\r\nstatic int new_class(const char *name, u_int8_t classid)\r\n{\r\nstruct class *c;\r\nunsigned int h = hashnum(classid);\r\nc = classes[h];\r\nfor (; c; c = c->next)\r\nif (c->classid == classid)\r\nreturn -1;\r\nc = my_malloc(sizeof(struct class) + strlen(name));\r\nif (!c)\r\nreturn -1;\r\nstrcpy(c->name, name);\r\nc->classid = classid;\r\nc->next = classes[h];\r\nclasses[h] = c;\r\nreturn 0;\r\n}\r\nstatic int new_subclass(const char *name, u_int8_t classid, u_int8_t subclassid)\r\n{\r\nstruct subclass *s;\r\nunsigned int h = hashnum((classid << 8) | subclassid);\r\ns = subclasses[h];\r\nfor (; s; s = s->next)\r\nif (s->classid == classid && s->subclassid == subclassid)\r\nreturn -1;\r\ns = my_malloc(sizeof(struct subclass) + strlen(name));\r\nif (!s)\r\nreturn -1;\r\nstrcpy(s->name, name);\r\ns->classid = classid;\r\ns->subclassid = subclassid;\r\ns->next = subclasses[h];\r\nsubclasses[h] = s;\r\nreturn 0;\r\n}\r\nstatic int new_protocol(const char *name, u_int8_t classid, u_int8_t subclassid,\r\nu_int8_t protocolid)\r\n{\r\nstruct protocol *p;\r\nunsigned int h = hashnum((classid << 16) | (subclassid << 8)\r\n| protocolid);\r\np = protocols[h];\r\nfor (; p; p = p->next)\r\nif (p->classid == classid && p->subclassid == subclassid\r\n&& p->protocolid == protocolid)\r\nreturn -1;\r\np = my_malloc(sizeof(struct protocol) + strlen(name));\r\nif (!p)\r\nreturn -1;\r\nstrcpy(p->name, name);\r\np->classid = classid;\r\np->subclassid = subclassid;\r\np->protocolid = protocolid;\r\np->next = protocols[h];\r\nprotocols[h] = p;\r\nreturn 0;\r\n}\r\nstatic void parse(FILE *f)\r\n{\r\nchar buf[512], *cp;\r\nunsigned int linectr = 0;\r\nint lastvendor = -1;\r\nint lastclass = -1;\r\nint lastsubclass = -1;\r\nint lasthut = -1;\r\nint lastlang = -1;\r\nunsigned int u;\r\nwhile (fgets(buf, sizeof(buf), f)) {\r\nlinectr++;\r\ncp = strchr(buf, '\r');\r\nif (cp)\r\n*cp = 0;\r\ncp = strchr(buf, '\n');\r\nif (cp)\r\n*cp = 0;\r\nif (buf[0] == '#' || !buf[0])\r\ncontinue;\r\ncp = buf;\r\nif (buf[0] == 'P' && buf[1] == 'H' && buf[2] == 'Y' &&\r\nbuf[3] == 'S' && buf[4] == 'D' &&\r\nbuf[5] == 'E' && buf[6] == 'S' &&\r\nbuf[7] == ' ') {\r\ncontinue;\r\n}\r\nif (buf[0] == 'P' && buf[1] == 'H' &&\r\nbuf[2] == 'Y' && buf[3] == ' ') {\r\ncontinue;\r\n}\r\nif (buf[0] == 'B' && buf[1] == 'I' && buf[2] == 'A' &&\r\nbuf[3] == 'S' && buf[4] == ' ') {\r\ncontinue;\r\n}\r\nif (buf[0] == 'L' && buf[1] == ' ') {\r\nlasthut = lastclass = lastvendor = lastsubclass = -1;\r\nlastlang = 1;\r\ncontinue;\r\n}\r\nif (buf[0] == 'C' && buf[1] == ' ') {\r\ncp = buf+2;\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!isxdigit(*cp)) {\r\nerr("Invalid class spec at line %u", linectr);\r\ncontinue;\r\n}\r\nu = strtoul(cp, &cp, 16);\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!*cp) {\r\nerr("Invalid class spec at line %u", linectr);\r\ncontinue;\r\n}\r\nif (new_class(cp, u))\r\nerr("Duplicate class spec at line %u class %04x %s",\r\nlinectr, u, cp);\r\ndbg("line %5u class %02x %s", linectr, u, cp);\r\nlasthut = lastlang = lastvendor = lastsubclass = -1;\r\nlastclass = u;\r\ncontinue;\r\n}\r\nif (buf[0] == 'A' && buf[1] == 'T' && isspace(buf[2])) {\r\ncontinue;\r\n}\r\nif (buf[0] == 'H' && buf[1] == 'C' && buf[2] == 'C'\r\n&& isspace(buf[3])) {\r\ncontinue;\r\n}\r\nif (isxdigit(*cp)) {\r\nu = strtoul(cp, &cp, 16);\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!*cp) {\r\nerr("Invalid vendor spec at line %u", linectr);\r\ncontinue;\r\n}\r\nif (new_vendor(cp, u))\r\nerr("Duplicate vendor spec at line %u vendor %04x %s",\r\nlinectr, u, cp);\r\ndbg("line %5u vendor %04x %s", linectr, u, cp);\r\nlastvendor = u;\r\nlasthut = lastlang = lastclass = lastsubclass = -1;\r\ncontinue;\r\n}\r\nif (buf[0] == '\t' && isxdigit(buf[1])) {\r\nu = strtoul(buf+1, &cp, 16);\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!*cp) {\r\nerr("Invalid product/subclass spec at line %u",\r\nlinectr);\r\ncontinue;\r\n}\r\nif (lastvendor != -1) {\r\nif (new_product(cp, lastvendor, u))\r\nerr("Duplicate product spec at line %u product %04x:%04x %s",\r\nlinectr, lastvendor, u, cp);\r\ndbg("line %5u product %04x:%04x %s", linectr,\r\nlastvendor, u, cp);\r\ncontinue;\r\n}\r\nif (lastclass != -1) {\r\nif (new_subclass(cp, lastclass, u))\r\nerr("Duplicate subclass spec at line %u class %02x:%02x %s",\r\nlinectr, lastclass, u, cp);\r\ndbg("line %5u subclass %02x:%02x %s", linectr,\r\nlastclass, u, cp);\r\nlastsubclass = u;\r\ncontinue;\r\n}\r\nif (lasthut != -1) {\r\ncontinue;\r\n}\r\nif (lastlang != -1) {\r\ncontinue;\r\n}\r\nerr("Product/Subclass spec without prior Vendor/Class spec at line %u",\r\nlinectr);\r\ncontinue;\r\n}\r\nif (buf[0] == '\t' && buf[1] == '\t' && isxdigit(buf[2])) {\r\nu = strtoul(buf+2, &cp, 16);\r\nwhile (isspace(*cp))\r\ncp++;\r\nif (!*cp) {\r\nerr("Invalid protocol spec at line %u",\r\nlinectr);\r\ncontinue;\r\n}\r\nif (lastclass != -1 && lastsubclass != -1) {\r\nif (new_protocol(cp, lastclass, lastsubclass,\r\nu))\r\nerr("Duplicate protocol spec at line %u class %02x:%02x:%02x %s",\r\nlinectr, lastclass, lastsubclass,\r\nu, cp);\r\ndbg("line %5u protocol %02x:%02x:%02x %s",\r\nlinectr, lastclass, lastsubclass, u, cp);\r\ncontinue;\r\n}\r\nerr("Protocol spec without prior Class and Subclass spec at line %u",\r\nlinectr);\r\ncontinue;\r\n}\r\nif (buf[0] == 'H' && buf[1] == 'I' &&\r\nbuf[2] == 'D' && buf[3] == ' ') {\r\ncontinue;\r\n}\r\nif (buf[0] == 'H' && buf[1] == 'U' &&\r\nbuf[2] == 'T' && buf[3] == ' ') {\r\nlastlang = lastclass = lastvendor = lastsubclass = -1;\r\nlasthut = 1;\r\ncontinue;\r\n}\r\nif (buf[0] == 'R' && buf[1] == ' ')\r\ncontinue;\r\nif (buf[0] == 'V' && buf[1] == 'T')\r\ncontinue;\r\nerr("Unknown line at line %u", linectr);\r\n}\r\n}\r\nint names_init(char *n)\r\n{\r\nFILE *f;\r\nf = fopen(n, "r");\r\nif (!f)\r\nreturn errno;\r\nparse(f);\r\nfclose(f);\r\nreturn 0;\r\n}
