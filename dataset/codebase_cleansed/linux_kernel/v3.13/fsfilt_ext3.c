static char *fsfilt_ext3_get_label(struct super_block *sb)\r\n{\r\nreturn EXT3_SB(sb)->s_es->s_volume_name;\r\n}\r\nstatic void *fsfilt_ext3_start(struct inode *inode, int op, void *desc_private,\r\nint logs)\r\n{\r\nint nblocks = FSFILT_SINGLEDATA_TRANS_BLOCKS(inode->i_sb);\r\njournal_t *journal;\r\nvoid *handle;\r\nif (current->journal_info) {\r\nCDEBUG(D_INODE, "increasing refcount on %p\n",\r\ncurrent->journal_info);\r\ngoto journal_start;\r\n}\r\nswitch(op) {\r\ncase FSFILT_OP_UNLINK:\r\nnblocks += EXT3_DELETE_TRANS_BLOCKS(inode->i_sb);\r\nnblocks += (EXT3_INDEX_EXTRA_TRANS_BLOCKS +\r\nFSFILT_SINGLEDATA_TRANS_BLOCKS(inode->i_sb)) * logs;\r\nbreak;\r\ncase FSFILT_OP_CANCEL_UNLINK:\r\nLASSERT(logs == 1);\r\nnblocks = (LLOG_CHUNK_SIZE >> inode->i_blkbits) +\r\nEXT3_DELETE_TRANS_BLOCKS(inode->i_sb) +\r\next4_blocks_for_truncate(inode) + 3;\r\nbreak;\r\ndefault: CERROR("unknown transaction start op %d\n", op);\r\nLBUG();\r\n}\r\nLASSERT(current->journal_info == desc_private);\r\njournal = EXT3_SB(inode->i_sb)->s_journal;\r\nif (nblocks > journal->j_max_transaction_buffers) {\r\nCWARN("too many credits %d for op %ux%u using %d instead\n",\r\nnblocks, op, logs, journal->j_max_transaction_buffers);\r\nnblocks = journal->j_max_transaction_buffers;\r\n}\r\njournal_start:\r\nLASSERTF(nblocks > 0, "can't start %d credit transaction\n", nblocks);\r\nhandle = ext3_journal_start(inode, nblocks);\r\nif (!IS_ERR(handle))\r\nLASSERT(current->journal_info == handle);\r\nelse\r\nCERROR("error starting handle for op %u (%u credits): rc %ld\n",\r\nop, nblocks, PTR_ERR(handle));\r\nreturn handle;\r\n}\r\nstatic int fsfilt_ext3_commit(struct inode *inode, void *h, int force_sync)\r\n{\r\nint rc;\r\nhandle_t *handle = h;\r\nLASSERT(current->journal_info == handle);\r\nif (force_sync)\r\nhandle->h_sync = 1;\r\nrc = ext3_journal_stop(handle);\r\nreturn rc;\r\n}\r\nstatic long ext3_ext_find_goal(struct inode *inode, struct ext3_ext_path *path,\r\nunsigned long block, int *aflags)\r\n{\r\nstruct ext3_inode_info *ei = EXT3_I(inode);\r\nunsigned long bg_start;\r\nunsigned long colour;\r\nint depth;\r\nif (path) {\r\nstruct ext3_extent *ex;\r\ndepth = path->p_depth;\r\nif ((ex = path[depth].p_ext))\r\nreturn ext4_ext_pblock(ex) + (block - le32_to_cpu(ex->ee_block));\r\nif (path[depth].p_bh)\r\nreturn path[depth].p_bh->b_blocknr;\r\n}\r\nbg_start = (ei->i_block_group * EXT3_BLOCKS_PER_GROUP(inode->i_sb)) +\r\nle32_to_cpu(EXT3_SB(inode->i_sb)->s_es->s_first_data_block);\r\ncolour = (current->pid % 16) *\r\n(EXT3_BLOCKS_PER_GROUP(inode->i_sb) / 16);\r\nreturn bg_start + colour + block;\r\n}\r\nstatic unsigned long new_blocks(handle_t *handle, struct ext3_ext_base *base,\r\nstruct ext3_ext_path *path, unsigned long block,\r\nunsigned long *count, int *err)\r\n{\r\nunsigned long pblock, goal;\r\nint aflags = 0;\r\nstruct inode *inode = ext3_ext_base2inode(base);\r\ngoal = ext3_ext_find_goal(inode, path, block, &aflags);\r\naflags |= 2;\r\npblock = ext3_mb_new_blocks(handle, inode, goal, count, aflags, err);\r\nreturn pblock;\r\n}\r\nstatic unsigned long new_blocks(handle_t *handle, struct ext3_ext_base *base,\r\nstruct ext3_ext_path *path, unsigned long block,\r\nunsigned long *count, int *err)\r\n{\r\nstruct inode *inode = ext3_ext_base2inode(base);\r\nstruct ext3_allocation_request ar;\r\nunsigned long pblock;\r\nint aflags;\r\nar.lleft = block;\r\n*err = ext3_ext_search_left(base, path, &ar.lleft, &ar.pleft);\r\nif (*err)\r\nreturn 0;\r\nar.lright = block;\r\n*err = ext3_ext_search_right(base, path, &ar.lright, &ar.pright);\r\nif (*err)\r\nreturn 0;\r\nar.goal = ext3_ext_find_goal(inode, path, block, &aflags);\r\nar.inode = inode;\r\nar.logical = block;\r\nar.len = *count;\r\nar.flags = EXT3_MB_HINT_DATA;\r\npblock = ext3_mb_new_blocks(handle, &ar, err);\r\n*count = ar.len;\r\nreturn pblock;\r\n}\r\nstatic int ext3_ext_new_extent_cb(struct ext3_ext_base *base,\r\nstruct ext3_ext_path *path,\r\nstruct ext3_ext_cache *cex,\r\n#ifdef HAVE_EXT_PREPARE_CB_EXTENT\r\nstruct ext3_extent *ex,\r\n#endif\r\nvoid *cbdata)\r\n{\r\nstruct bpointers *bp = cbdata;\r\nstruct inode *inode = ext3_ext_base2inode(base);\r\nstruct ext3_extent nex;\r\nunsigned long pblock;\r\nunsigned long tgen;\r\nint err, i;\r\nunsigned long count;\r\nhandle_t *handle;\r\n#ifdef EXT3_EXT_CACHE_EXTENT\r\nif (cex->ec_type == EXT3_EXT_CACHE_EXTENT)\r\n#else\r\nif ((cex->ec_len != 0) && (cex->ec_start != 0))\r\n#endif\r\n{\r\nerr = EXT_CONTINUE;\r\ngoto map;\r\n}\r\nif (bp->create == 0) {\r\ni = 0;\r\nif (cex->ec_block < bp->start)\r\ni = bp->start - cex->ec_block;\r\nif (i >= cex->ec_len)\r\nCERROR("nothing to do?! i = %d, e_num = %u\n",\r\ni, cex->ec_len);\r\nfor (; i < cex->ec_len && bp->num; i++) {\r\n*(bp->blocks) = 0;\r\nbp->blocks++;\r\nbp->num--;\r\nbp->start++;\r\n}\r\nreturn EXT_CONTINUE;\r\n}\r\ntgen = EXT_GENERATION(base);\r\ncount = ext3_ext_calc_credits_for_insert(base, path);\r\nhandle = ext3_journal_start(inode, count+EXT3_ALLOC_NEEDED+1);\r\nif (IS_ERR(handle)) {\r\nreturn PTR_ERR(handle);\r\n}\r\nif (tgen != EXT_GENERATION(base)) {\r\next3_journal_stop(handle);\r\nreturn EXT_REPEAT;\r\n}\r\ndown_write((&EXT4_I(inode)->i_data_sem));\r\nif (EXT_GENERATION(base) != path[0].p_generation) {\r\nup_write(&EXT4_I(inode)->i_data_sem);\r\next3_journal_stop(handle);\r\nreturn EXT_REPEAT;\r\n}\r\ncount = cex->ec_len;\r\npblock = new_blocks(handle, base, path, cex->ec_block, &count, &err);\r\nif (!pblock)\r\ngoto out;\r\nEXT_ASSERT(count <= cex->ec_len);\r\nnex.ee_block = cpu_to_le32(cex->ec_block);\r\next3_ext_store_pblock(&nex, pblock);\r\nnex.ee_len = cpu_to_le16(count);\r\nerr = fsfilt_ext3_ext_insert_extent(handle, base, path, &nex, 0);\r\nif (err) {\r\n#ifdef EXT3_MB_HINT_GROUP_ALLOC\r\next3_mb_discard_inode_preallocations(inode);\r\n#endif\r\n#ifdef HAVE_EXT_FREE_BLOCK_WITH_BUFFER_HEAD\r\next3_free_blocks(handle, inode, NULL, ext4_ext_pblock(&nex),\r\ncpu_to_le16(nex.ee_len), 0);\r\n#else\r\next3_free_blocks(handle, inode, ext4_ext_pblock(&nex),\r\ncpu_to_le16(nex.ee_len), 0);\r\n#endif\r\ngoto out;\r\n}\r\ncex->ec_len = le16_to_cpu(nex.ee_len);\r\ncex->ec_start = ext4_ext_pblock(&nex);\r\nBUG_ON(le16_to_cpu(nex.ee_len) == 0);\r\nBUG_ON(le32_to_cpu(nex.ee_block) != cex->ec_block);\r\nout:\r\nup_write((&EXT4_I(inode)->i_data_sem));\r\next3_journal_stop(handle);\r\nmap:\r\nif (err >= 0) {\r\nif (bp->num == 0) {\r\nCERROR("hmm. why do we find this extent?\n");\r\nCERROR("initial space: %lu:%u\n",\r\nbp->start, bp->init_num);\r\n#ifdef EXT3_EXT_CACHE_EXTENT\r\nCERROR("current extent: %u/%u/%llu %d\n",\r\ncex->ec_block, cex->ec_len,\r\n(unsigned long long)cex->ec_start,\r\ncex->ec_type);\r\n#else\r\nCERROR("current extent: %u/%u/%llu\n",\r\ncex->ec_block, cex->ec_len,\r\n(unsigned long long)cex->ec_start);\r\n#endif\r\n}\r\ni = 0;\r\nif (cex->ec_block < bp->start)\r\ni = bp->start - cex->ec_block;\r\nif (i >= cex->ec_len)\r\nCERROR("nothing to do?! i = %d, e_num = %u\n",\r\ni, cex->ec_len);\r\nfor (; i < cex->ec_len && bp->num; i++) {\r\n*(bp->blocks) = cex->ec_start + i;\r\n#ifdef EXT3_EXT_CACHE_EXTENT\r\nif (cex->ec_type != EXT3_EXT_CACHE_EXTENT)\r\n#else\r\nif ((cex->ec_len == 0) || (cex->ec_start == 0))\r\n#endif\r\n{\r\nll_unmap_underlying_metadata(inode->i_sb,\r\n*(bp->blocks));\r\n}\r\nbp->blocks++;\r\nbp->num--;\r\nbp->start++;\r\n}\r\n}\r\nreturn err;\r\n}\r\nint fsfilt_map_nblocks(struct inode *inode, unsigned long block,\r\nunsigned long num, unsigned long *blocks,\r\nint create)\r\n{\r\nstruct ext3_ext_base *base = inode;\r\nstruct bpointers bp;\r\nint err;\r\nCDEBUG(D_OTHER, "blocks %lu-%lu requested for inode %u\n",\r\nblock, block + num - 1, (unsigned) inode->i_ino);\r\nbp.blocks = blocks;\r\nbp.start = block;\r\nbp.init_num = bp.num = num;\r\nbp.create = create;\r\nerr = fsfilt_ext3_ext_walk_space(base, block, num,\r\next3_ext_new_extent_cb, &bp);\r\next3_ext_invalidate_cache(base);\r\nreturn err;\r\n}\r\nint fsfilt_ext3_map_ext_inode_pages(struct inode *inode, struct page **page,\r\nint pages, unsigned long *blocks,\r\nint create)\r\n{\r\nint blocks_per_page = PAGE_CACHE_SIZE >> inode->i_blkbits;\r\nint rc = 0, i = 0;\r\nstruct page *fp = NULL;\r\nint clen = 0;\r\nCDEBUG(D_OTHER, "inode %lu: map %d pages from %lu\n",\r\ninode->i_ino, pages, (*page)->index);\r\nwhile (i < pages) {\r\nif (fp == NULL) {\r\nfp = *page++;\r\nclen = 1;\r\ni++;\r\ncontinue;\r\n} else if (fp->index + clen == (*page)->index) {\r\npage++;\r\nclen++;\r\ni++;\r\ncontinue;\r\n}\r\nrc = fsfilt_map_nblocks(inode, fp->index * blocks_per_page,\r\nclen * blocks_per_page, blocks,\r\ncreate);\r\nif (rc)\r\nGOTO(cleanup, rc);\r\nfp = NULL;\r\nblocks += blocks_per_page * clen;\r\n}\r\nif (fp)\r\nrc = fsfilt_map_nblocks(inode, fp->index * blocks_per_page,\r\nclen * blocks_per_page, blocks,\r\ncreate);\r\ncleanup:\r\nreturn rc;\r\n}\r\nint fsfilt_ext3_map_bm_inode_pages(struct inode *inode, struct page **page,\r\nint pages, unsigned long *blocks,\r\nint create)\r\n{\r\nint blocks_per_page = PAGE_CACHE_SIZE >> inode->i_blkbits;\r\nunsigned long *b;\r\nint rc = 0, i;\r\nfor (i = 0, b = blocks; i < pages; i++, page++) {\r\nrc = ext3_map_inode_page(inode, *page, b, create);\r\nif (rc) {\r\nCERROR("ino %lu, blk %lu create %d: rc %d\n",\r\ninode->i_ino, *b, create, rc);\r\nbreak;\r\n}\r\nb += blocks_per_page;\r\n}\r\nreturn rc;\r\n}\r\nint fsfilt_ext3_map_inode_pages(struct inode *inode, struct page **page,\r\nint pages, unsigned long *blocks,\r\nint create, struct mutex *optional_mutex)\r\n{\r\nint rc;\r\nif (EXT3_I(inode)->i_flags & EXT3_EXTENTS_FL) {\r\nrc = fsfilt_ext3_map_ext_inode_pages(inode, page, pages,\r\nblocks, create);\r\nreturn rc;\r\n}\r\nif (optional_mutex != NULL)\r\nmutex_lock(optional_mutex);\r\nrc = fsfilt_ext3_map_bm_inode_pages(inode, page, pages, blocks, create);\r\nif (optional_mutex != NULL)\r\nmutex_unlock(optional_mutex);\r\nreturn rc;\r\n}\r\nint fsfilt_ext3_read(struct inode *inode, void *buf, int size, loff_t *offs)\r\n{\r\nunsigned long block;\r\nstruct buffer_head *bh;\r\nint err, blocksize, csize, boffs, osize = size;\r\nspin_lock(&inode->i_lock);\r\nif (i_size_read(inode) < *offs + size) {\r\nsize = i_size_read(inode) - *offs;\r\nspin_unlock(&inode->i_lock);\r\nif (size < 0) {\r\nCDEBUG(D_EXT2, "size %llu is too short for read @%llu\n",\r\ni_size_read(inode), *offs);\r\nreturn -EBADR;\r\n} else if (size == 0) {\r\nreturn 0;\r\n}\r\n} else {\r\nspin_unlock(&inode->i_lock);\r\n}\r\nblocksize = 1 << inode->i_blkbits;\r\nwhile (size > 0) {\r\nblock = *offs >> inode->i_blkbits;\r\nboffs = *offs & (blocksize - 1);\r\ncsize = min(blocksize - boffs, size);\r\nbh = ext3_bread(NULL, inode, block, 0, &err);\r\nif (!bh) {\r\nCERROR("can't read block: %d\n", err);\r\nreturn err;\r\n}\r\nmemcpy(buf, bh->b_data + boffs, csize);\r\nbrelse(bh);\r\n*offs += csize;\r\nbuf += csize;\r\nsize -= csize;\r\n}\r\nreturn osize;\r\n}\r\nstatic int fsfilt_ext3_read_record(struct file * file, void *buf,\r\nint size, loff_t *offs)\r\n{\r\nint rc;\r\nrc = fsfilt_ext3_read(file->f_dentry->d_inode, buf, size, offs);\r\nif (rc > 0)\r\nrc = 0;\r\nreturn rc;\r\n}\r\nint fsfilt_ext3_write_handle(struct inode *inode, void *buf, int bufsize,\r\nloff_t *offs, handle_t *handle)\r\n{\r\nstruct buffer_head *bh = NULL;\r\nloff_t old_size = i_size_read(inode), offset = *offs;\r\nloff_t new_size = i_size_read(inode);\r\nunsigned long block;\r\nint err = 0, blocksize = 1 << inode->i_blkbits, size, boffs;\r\nwhile (bufsize > 0) {\r\nif (bh != NULL)\r\nbrelse(bh);\r\nblock = offset >> inode->i_blkbits;\r\nboffs = offset & (blocksize - 1);\r\nsize = min(blocksize - boffs, bufsize);\r\nbh = ext3_bread(handle, inode, block, 1, &err);\r\nif (!bh) {\r\nCERROR("can't read/create block: %d\n", err);\r\nbreak;\r\n}\r\nerr = ext3_journal_get_write_access(handle, bh);\r\nif (err) {\r\nCERROR("journal_get_write_access() returned error %d\n",\r\nerr);\r\nbreak;\r\n}\r\nLASSERT(bh->b_data + boffs + size <= bh->b_data + bh->b_size);\r\nmemcpy(bh->b_data + boffs, buf, size);\r\nerr = ext3_journal_dirty_metadata(handle, bh);\r\nif (err) {\r\nCERROR("journal_dirty_metadata() returned error %d\n",\r\nerr);\r\nbreak;\r\n}\r\nif (offset + size > new_size)\r\nnew_size = offset + size;\r\noffset += size;\r\nbufsize -= size;\r\nbuf += size;\r\n}\r\nif (bh)\r\nbrelse(bh);\r\nif (new_size > i_size_read(inode)) {\r\nspin_lock(&inode->i_lock);\r\nif (new_size > i_size_read(inode))\r\ni_size_write(inode, new_size);\r\nif (i_size_read(inode) > EXT3_I(inode)->i_disksize)\r\nEXT3_I(inode)->i_disksize = i_size_read(inode);\r\nif (i_size_read(inode) > old_size) {\r\nspin_unlock(&inode->i_lock);\r\nmark_inode_dirty(inode);\r\n} else {\r\nspin_unlock(&inode->i_lock);\r\n}\r\n}\r\nif (err == 0)\r\n*offs = offset;\r\nreturn err;\r\n}\r\nstatic int fsfilt_ext3_write_record(struct file *file, void *buf, int bufsize,\r\nloff_t *offs, int force_sync)\r\n{\r\nstruct inode *inode = file->f_dentry->d_inode;\r\nhandle_t *handle;\r\nint err, block_count = 0, blocksize;\r\nblocksize = 1 << inode->i_blkbits;\r\nblock_count = (*offs & (blocksize - 1)) + bufsize;\r\nblock_count = (block_count + blocksize - 1) >> inode->i_blkbits;\r\nhandle = ext3_journal_start(inode,\r\nblock_count * EXT3_DATA_TRANS_BLOCKS(inode->i_sb) + 2);\r\nif (IS_ERR(handle)) {\r\nCERROR("can't start transaction for %d blocks (%d bytes)\n",\r\nblock_count * EXT3_DATA_TRANS_BLOCKS(inode->i_sb) + 2,\r\nbufsize);\r\nreturn PTR_ERR(handle);\r\n}\r\nerr = fsfilt_ext3_write_handle(inode, buf, bufsize, offs, handle);\r\nif (!err && force_sync)\r\nhandle->h_sync = 1;\r\next3_journal_stop(handle);\r\nreturn err;\r\n}\r\nstatic int fsfilt_ext3_setup(struct super_block *sb)\r\n{\r\nif (!EXT3_HAS_COMPAT_FEATURE(sb,\r\nEXT3_FEATURE_COMPAT_HAS_JOURNAL)) {\r\nCERROR("ext3 mounted without journal\n");\r\nreturn -EINVAL;\r\n}\r\n#ifdef S_PDIROPS\r\nCWARN("Enabling PDIROPS\n");\r\nset_opt(EXT3_SB(sb)->s_mount_opt, PDIROPS);\r\nsb->s_flags |= S_PDIROPS;\r\n#endif\r\nif (!EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_DIR_INDEX))\r\nCWARN("filesystem doesn't have dir_index feature enabled\n");\r\nreturn 0;\r\n}\r\nstatic int __init fsfilt_ext3_init(void)\r\n{\r\nint rc;\r\nfcb_cache = kmem_cache_create("fsfilt_ext3_fcb",\r\nsizeof(struct fsfilt_cb_data), 0, 0);\r\nif (!fcb_cache) {\r\nCERROR("error allocating fsfilt journal callback cache\n");\r\nGOTO(out, rc = -ENOMEM);\r\n}\r\nrc = fsfilt_register_ops(&fsfilt_ext3_ops);\r\nif (rc) {\r\nint err = kmem_cache_destroy(fcb_cache);\r\nLASSERTF(err == 0, "error destroying new cache: rc %d\n", err);\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic void __exit fsfilt_ext3_exit(void)\r\n{\r\nint rc;\r\nfsfilt_unregister_ops(&fsfilt_ext3_ops);\r\nrc = kmem_cache_destroy(fcb_cache);\r\nLASSERTF(rc == 0, "couldn't destroy fcb_cache slab\n");\r\n}
