static void vvp_page_fini_common(struct ccc_page *cp)\r\n{\r\nstruct page *vmpage = cp->cpg_page;\r\nLASSERT(vmpage != NULL);\r\npage_cache_release(vmpage);\r\n}\r\nstatic void vvp_page_fini(const struct lu_env *env,\r\nstruct cl_page_slice *slice)\r\n{\r\nstruct ccc_page *cp = cl2ccc_page(slice);\r\nstruct page *vmpage = cp->cpg_page;\r\nLASSERT((struct cl_page *)vmpage->private != slice->cpl_page);\r\nvvp_page_fini_common(cp);\r\n}\r\nstatic int vvp_page_own(const struct lu_env *env,\r\nconst struct cl_page_slice *slice, struct cl_io *io,\r\nint nonblock)\r\n{\r\nstruct ccc_page *vpg = cl2ccc_page(slice);\r\nstruct page *vmpage = vpg->cpg_page;\r\nLASSERT(vmpage != NULL);\r\nif (nonblock) {\r\nif (!trylock_page(vmpage))\r\nreturn -EAGAIN;\r\nif (unlikely(PageWriteback(vmpage))) {\r\nunlock_page(vmpage);\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nlock_page(vmpage);\r\nwait_on_page_writeback(vmpage);\r\nreturn 0;\r\n}\r\nstatic void vvp_page_assume(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\nstruct page *vmpage = cl2vm_page(slice);\r\nLASSERT(vmpage != NULL);\r\nLASSERT(PageLocked(vmpage));\r\nwait_on_page_writeback(vmpage);\r\n}\r\nstatic void vvp_page_unassume(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\nstruct page *vmpage = cl2vm_page(slice);\r\nLASSERT(vmpage != NULL);\r\nLASSERT(PageLocked(vmpage));\r\n}\r\nstatic void vvp_page_disown(const struct lu_env *env,\r\nconst struct cl_page_slice *slice, struct cl_io *io)\r\n{\r\nstruct page *vmpage = cl2vm_page(slice);\r\nLASSERT(vmpage != NULL);\r\nLASSERT(PageLocked(vmpage));\r\nunlock_page(cl2vm_page(slice));\r\n}\r\nstatic void vvp_page_discard(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\nstruct page *vmpage = cl2vm_page(slice);\r\nstruct address_space *mapping;\r\nstruct ccc_page *cpg = cl2ccc_page(slice);\r\nLASSERT(vmpage != NULL);\r\nLASSERT(PageLocked(vmpage));\r\nmapping = vmpage->mapping;\r\nif (cpg->cpg_defer_uptodate && !cpg->cpg_ra_used)\r\nll_ra_stats_inc(mapping, RA_STAT_DISCARDED);\r\ntruncate_complete_page(mapping, vmpage);\r\n}\r\nstatic int vvp_page_unmap(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\nstruct page *vmpage = cl2vm_page(slice);\r\n__u64 offset;\r\nLASSERT(vmpage != NULL);\r\nLASSERT(PageLocked(vmpage));\r\noffset = vmpage->index << PAGE_CACHE_SHIFT;\r\nll_teardown_mmaps(vmpage->mapping, offset, offset + PAGE_CACHE_SIZE);\r\nreturn 0;\r\n}\r\nstatic void vvp_page_delete(const struct lu_env *env,\r\nconst struct cl_page_slice *slice)\r\n{\r\nstruct page *vmpage = cl2vm_page(slice);\r\nstruct inode *inode = vmpage->mapping->host;\r\nstruct cl_object *obj = slice->cpl_obj;\r\nLASSERT(PageLocked(vmpage));\r\nLASSERT((struct cl_page *)vmpage->private == slice->cpl_page);\r\nLASSERT(inode == ccc_object_inode(obj));\r\nvvp_write_complete(cl2ccc(obj), cl2ccc_page(slice));\r\nClearPagePrivate(vmpage);\r\nvmpage->private = 0;\r\n}\r\nstatic void vvp_page_export(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nint uptodate)\r\n{\r\nstruct page *vmpage = cl2vm_page(slice);\r\nLASSERT(vmpage != NULL);\r\nLASSERT(PageLocked(vmpage));\r\nif (uptodate)\r\nSetPageUptodate(vmpage);\r\nelse\r\nClearPageUptodate(vmpage);\r\n}\r\nstatic int vvp_page_is_vmlocked(const struct lu_env *env,\r\nconst struct cl_page_slice *slice)\r\n{\r\nreturn PageLocked(cl2vm_page(slice)) ? -EBUSY : -ENODATA;\r\n}\r\nstatic int vvp_page_prep_read(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\nreturn PageUptodate(cl2vm_page(slice)) ? -EALREADY : 0;\r\n}\r\nstatic int vvp_page_prep_write(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\nstruct page *vmpage = cl2vm_page(slice);\r\nLASSERT(PageLocked(vmpage));\r\nLASSERT(!PageDirty(vmpage));\r\nset_page_writeback(vmpage);\r\nvvp_write_pending(cl2ccc(slice->cpl_obj), cl2ccc_page(slice));\r\nreturn 0;\r\n}\r\nstatic void vvp_vmpage_error(struct inode *inode, struct page *vmpage, int ioret)\r\n{\r\nstruct ccc_object *obj = cl_inode2ccc(inode);\r\nif (ioret == 0) {\r\nClearPageError(vmpage);\r\nobj->cob_discard_page_warned = 0;\r\n} else {\r\nSetPageError(vmpage);\r\nif (ioret == -ENOSPC)\r\nset_bit(AS_ENOSPC, &inode->i_mapping->flags);\r\nelse\r\nset_bit(AS_EIO, &inode->i_mapping->flags);\r\nif ((ioret == -ESHUTDOWN || ioret == -EINTR) &&\r\nobj->cob_discard_page_warned == 0) {\r\nobj->cob_discard_page_warned = 1;\r\nll_dirty_page_discard_warn(vmpage, ioret);\r\n}\r\n}\r\n}\r\nstatic void vvp_page_completion_read(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nint ioret)\r\n{\r\nstruct ccc_page *cp = cl2ccc_page(slice);\r\nstruct page *vmpage = cp->cpg_page;\r\nstruct cl_page *page = cl_page_top(slice->cpl_page);\r\nstruct inode *inode = ccc_object_inode(page->cp_obj);\r\nLASSERT(PageLocked(vmpage));\r\nCL_PAGE_HEADER(D_PAGE, env, page, "completing READ with %d\n", ioret);\r\nif (cp->cpg_defer_uptodate)\r\nll_ra_count_put(ll_i2sbi(inode), 1);\r\nif (ioret == 0) {\r\nif (!cp->cpg_defer_uptodate)\r\ncl_page_export(env, page, 1);\r\n} else\r\ncp->cpg_defer_uptodate = 0;\r\nif (page->cp_sync_io == NULL)\r\nunlock_page(vmpage);\r\n}\r\nstatic void vvp_page_completion_write(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nint ioret)\r\n{\r\nstruct ccc_page *cp = cl2ccc_page(slice);\r\nstruct cl_page *pg = slice->cpl_page;\r\nstruct page *vmpage = cp->cpg_page;\r\nLASSERT(ergo(pg->cp_sync_io != NULL, PageLocked(vmpage)));\r\nLASSERT(PageWriteback(vmpage));\r\nCL_PAGE_HEADER(D_PAGE, env, pg, "completing WRITE with %d\n", ioret);\r\ncp->cpg_write_queued = 0;\r\nvvp_write_complete(cl2ccc(slice->cpl_obj), cp);\r\nif (pg->cp_sync_io == NULL)\r\nvvp_vmpage_error(ccc_object_inode(pg->cp_obj), vmpage, ioret);\r\nend_page_writeback(vmpage);\r\n}\r\nstatic int vvp_page_make_ready(const struct lu_env *env,\r\nconst struct cl_page_slice *slice)\r\n{\r\nstruct page *vmpage = cl2vm_page(slice);\r\nstruct cl_page *pg = slice->cpl_page;\r\nint result = 0;\r\nlock_page(vmpage);\r\nif (clear_page_dirty_for_io(vmpage)) {\r\nLASSERT(pg->cp_state == CPS_CACHED);\r\nset_page_writeback(vmpage);\r\nvvp_write_pending(cl2ccc(slice->cpl_obj),\r\ncl2ccc_page(slice));\r\nCL_PAGE_HEADER(D_PAGE, env, pg, "readied\n");\r\n} else if (pg->cp_state == CPS_PAGEOUT) {\r\nresult = -EALREADY;\r\n} else {\r\nCL_PAGE_DEBUG(D_ERROR, env, pg, "Unexpecting page state %d.\n",\r\npg->cp_state);\r\nLBUG();\r\n}\r\nunlock_page(vmpage);\r\nreturn result;\r\n}\r\nstatic int vvp_page_print(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nvoid *cookie, lu_printer_t printer)\r\n{\r\nstruct ccc_page *vp = cl2ccc_page(slice);\r\nstruct page *vmpage = vp->cpg_page;\r\n(*printer)(env, cookie, LUSTRE_VVP_NAME"-page@%p(%d:%d:%d) "\r\n"vm@%p ",\r\nvp, vp->cpg_defer_uptodate, vp->cpg_ra_used,\r\nvp->cpg_write_queued, vmpage);\r\nif (vmpage != NULL) {\r\n(*printer)(env, cookie, "%lx %d:%d %lx %lu %slru",\r\n(long)vmpage->flags, page_count(vmpage),\r\npage_mapcount(vmpage), vmpage->private,\r\npage_index(vmpage),\r\nlist_empty(&vmpage->lru) ? "not-" : "");\r\n}\r\n(*printer)(env, cookie, "\n");\r\nreturn 0;\r\n}\r\nstatic void vvp_transient_page_verify(const struct cl_page *page)\r\n{\r\nstruct inode *inode = ccc_object_inode(page->cp_obj);\r\nLASSERT(!mutex_trylock(&inode->i_mutex));\r\n}\r\nstatic int vvp_transient_page_own(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused, int nonblock)\r\n{\r\nvvp_transient_page_verify(slice->cpl_page);\r\nreturn 0;\r\n}\r\nstatic void vvp_transient_page_assume(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\nvvp_transient_page_verify(slice->cpl_page);\r\n}\r\nstatic void vvp_transient_page_unassume(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\nvvp_transient_page_verify(slice->cpl_page);\r\n}\r\nstatic void vvp_transient_page_disown(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\nvvp_transient_page_verify(slice->cpl_page);\r\n}\r\nstatic void vvp_transient_page_discard(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\nstruct cl_page *page = slice->cpl_page;\r\nvvp_transient_page_verify(slice->cpl_page);\r\ncl_page_delete(env, page);\r\n}\r\nstatic int vvp_transient_page_is_vmlocked(const struct lu_env *env,\r\nconst struct cl_page_slice *slice)\r\n{\r\nstruct inode *inode = ccc_object_inode(slice->cpl_obj);\r\nint locked;\r\nlocked = !mutex_trylock(&inode->i_mutex);\r\nif (!locked)\r\nmutex_unlock(&inode->i_mutex);\r\nreturn locked ? -EBUSY : -ENODATA;\r\n}\r\nstatic void\r\nvvp_transient_page_completion(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nint ioret)\r\n{\r\nvvp_transient_page_verify(slice->cpl_page);\r\n}\r\nstatic void vvp_transient_page_fini(const struct lu_env *env,\r\nstruct cl_page_slice *slice)\r\n{\r\nstruct ccc_page *cp = cl2ccc_page(slice);\r\nstruct cl_page *clp = slice->cpl_page;\r\nstruct ccc_object *clobj = cl2ccc(clp->cp_obj);\r\nvvp_page_fini_common(cp);\r\nLASSERT(!mutex_trylock(&clobj->cob_inode->i_mutex));\r\nclobj->cob_transient_pages--;\r\n}\r\nint vvp_page_init(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_page *page, struct page *vmpage)\r\n{\r\nstruct ccc_page *cpg = cl_object_page_slice(obj, page);\r\nCLOBINVRNT(env, obj, ccc_object_invariant(obj));\r\ncpg->cpg_page = vmpage;\r\npage_cache_get(vmpage);\r\nINIT_LIST_HEAD(&cpg->cpg_pending_linkage);\r\nif (page->cp_type == CPT_CACHEABLE) {\r\nSetPagePrivate(vmpage);\r\nvmpage->private = (unsigned long)page;\r\ncl_page_slice_add(page, &cpg->cpg_cl, obj,\r\n&vvp_page_ops);\r\n} else {\r\nstruct ccc_object *clobj = cl2ccc(obj);\r\nLASSERT(!mutex_trylock(&clobj->cob_inode->i_mutex));\r\ncl_page_slice_add(page, &cpg->cpg_cl, obj,\r\n&vvp_transient_page_ops);\r\nclobj->cob_transient_pages++;\r\n}\r\nreturn 0;\r\n}
