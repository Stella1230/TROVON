static void print_page(struct page *page)\r\n{\r\ndprintk("PRINTPAGE page %p\n", page);\r\ndprintk(" PagePrivate %d\n", PagePrivate(page));\r\ndprintk(" PageUptodate %d\n", PageUptodate(page));\r\ndprintk(" PageError %d\n", PageError(page));\r\ndprintk(" PageDirty %d\n", PageDirty(page));\r\ndprintk(" PageReferenced %d\n", PageReferenced(page));\r\ndprintk(" PageLocked %d\n", PageLocked(page));\r\ndprintk(" PageWriteback %d\n", PageWriteback(page));\r\ndprintk(" PageMappedToDisk %d\n", PageMappedToDisk(page));\r\ndprintk("\n");\r\n}\r\nstatic int is_hole(struct pnfs_block_extent *be, sector_t isect)\r\n{\r\nif (be->be_state == PNFS_BLOCK_NONE_DATA)\r\nreturn 1;\r\nelse if (be->be_state != PNFS_BLOCK_INVALID_DATA)\r\nreturn 0;\r\nelse\r\nreturn !bl_is_sector_init(be->be_inval, isect);\r\n}\r\nstatic int is_writable(struct pnfs_block_extent *be, sector_t isect)\r\n{\r\nreturn (be->be_state == PNFS_BLOCK_READWRITE_DATA ||\r\nbe->be_state == PNFS_BLOCK_INVALID_DATA);\r\n}\r\nstatic inline struct parallel_io *alloc_parallel(void *data)\r\n{\r\nstruct parallel_io *rv;\r\nrv = kmalloc(sizeof(*rv), GFP_NOFS);\r\nif (rv) {\r\nrv->data = data;\r\nkref_init(&rv->refcnt);\r\nrv->bse_count = 0;\r\n}\r\nreturn rv;\r\n}\r\nstatic inline void get_parallel(struct parallel_io *p)\r\n{\r\nkref_get(&p->refcnt);\r\n}\r\nstatic void destroy_parallel(struct kref *kref)\r\n{\r\nstruct parallel_io *p = container_of(kref, struct parallel_io, refcnt);\r\ndprintk("%s enter\n", __func__);\r\np->pnfs_callback(p->data, p->bse_count);\r\nkfree(p);\r\n}\r\nstatic inline void put_parallel(struct parallel_io *p)\r\n{\r\nkref_put(&p->refcnt, destroy_parallel);\r\n}\r\nstatic struct bio *\r\nbl_submit_bio(int rw, struct bio *bio)\r\n{\r\nif (bio) {\r\nget_parallel(bio->bi_private);\r\ndprintk("%s submitting %s bio %u@%llu\n", __func__,\r\nrw == READ ? "read" : "write",\r\nbio->bi_size, (unsigned long long)bio->bi_sector);\r\nsubmit_bio(rw, bio);\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct bio *bl_alloc_init_bio(int npg, sector_t isect,\r\nstruct pnfs_block_extent *be,\r\nvoid (*end_io)(struct bio *, int err),\r\nstruct parallel_io *par)\r\n{\r\nstruct bio *bio;\r\nnpg = min(npg, BIO_MAX_PAGES);\r\nbio = bio_alloc(GFP_NOIO, npg);\r\nif (!bio && (current->flags & PF_MEMALLOC)) {\r\nwhile (!bio && (npg /= 2))\r\nbio = bio_alloc(GFP_NOIO, npg);\r\n}\r\nif (bio) {\r\nbio->bi_sector = isect - be->be_f_offset + be->be_v_offset;\r\nbio->bi_bdev = be->be_mdev;\r\nbio->bi_end_io = end_io;\r\nbio->bi_private = par;\r\n}\r\nreturn bio;\r\n}\r\nstatic struct bio *do_add_page_to_bio(struct bio *bio, int npg, int rw,\r\nsector_t isect, struct page *page,\r\nstruct pnfs_block_extent *be,\r\nvoid (*end_io)(struct bio *, int err),\r\nstruct parallel_io *par,\r\nunsigned int offset, int len)\r\n{\r\nisect = isect + (offset >> SECTOR_SHIFT);\r\ndprintk("%s: npg %d rw %d isect %llu offset %u len %d\n", __func__,\r\nnpg, rw, (unsigned long long)isect, offset, len);\r\nretry:\r\nif (!bio) {\r\nbio = bl_alloc_init_bio(npg, isect, be, end_io, par);\r\nif (!bio)\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nif (bio_add_page(bio, page, len, offset) < len) {\r\nbio = bl_submit_bio(rw, bio);\r\ngoto retry;\r\n}\r\nreturn bio;\r\n}\r\nstatic struct bio *bl_add_page_to_bio(struct bio *bio, int npg, int rw,\r\nsector_t isect, struct page *page,\r\nstruct pnfs_block_extent *be,\r\nvoid (*end_io)(struct bio *, int err),\r\nstruct parallel_io *par)\r\n{\r\nreturn do_add_page_to_bio(bio, npg, rw, isect, page, be,\r\nend_io, par, 0, PAGE_CACHE_SIZE);\r\n}\r\nstatic void bl_end_io_read(struct bio *bio, int err)\r\n{\r\nstruct parallel_io *par = bio->bi_private;\r\nconst int uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags);\r\nstruct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;\r\ndo {\r\nstruct page *page = bvec->bv_page;\r\nif (--bvec >= bio->bi_io_vec)\r\nprefetchw(&bvec->bv_page->flags);\r\nif (uptodate)\r\nSetPageUptodate(page);\r\n} while (bvec >= bio->bi_io_vec);\r\nif (!uptodate) {\r\nstruct nfs_read_data *rdata = par->data;\r\nstruct nfs_pgio_header *header = rdata->header;\r\nif (!header->pnfs_error)\r\nheader->pnfs_error = -EIO;\r\npnfs_set_lo_fail(header->lseg);\r\n}\r\nbio_put(bio);\r\nput_parallel(par);\r\n}\r\nstatic void bl_read_cleanup(struct work_struct *work)\r\n{\r\nstruct rpc_task *task;\r\nstruct nfs_read_data *rdata;\r\ndprintk("%s enter\n", __func__);\r\ntask = container_of(work, struct rpc_task, u.tk_work);\r\nrdata = container_of(task, struct nfs_read_data, task);\r\npnfs_ld_read_done(rdata);\r\n}\r\nstatic void\r\nbl_end_par_io_read(void *data, int unused)\r\n{\r\nstruct nfs_read_data *rdata = data;\r\nrdata->task.tk_status = rdata->header->pnfs_error;\r\nINIT_WORK(&rdata->task.u.tk_work, bl_read_cleanup);\r\nschedule_work(&rdata->task.u.tk_work);\r\n}\r\nstatic enum pnfs_try_status\r\nbl_read_pagelist(struct nfs_read_data *rdata)\r\n{\r\nstruct nfs_pgio_header *header = rdata->header;\r\nint i, hole;\r\nstruct bio *bio = NULL;\r\nstruct pnfs_block_extent *be = NULL, *cow_read = NULL;\r\nsector_t isect, extent_length = 0;\r\nstruct parallel_io *par;\r\nloff_t f_offset = rdata->args.offset;\r\nsize_t bytes_left = rdata->args.count;\r\nunsigned int pg_offset, pg_len;\r\nstruct page **pages = rdata->args.pages;\r\nint pg_index = rdata->args.pgbase >> PAGE_CACHE_SHIFT;\r\nconst bool is_dio = (header->dreq != NULL);\r\ndprintk("%s enter nr_pages %u offset %lld count %u\n", __func__,\r\nrdata->pages.npages, f_offset, (unsigned int)rdata->args.count);\r\npar = alloc_parallel(rdata);\r\nif (!par)\r\ngoto use_mds;\r\npar->pnfs_callback = bl_end_par_io_read;\r\nisect = (sector_t) (f_offset >> SECTOR_SHIFT);\r\nfor (i = pg_index; i < rdata->pages.npages; i++) {\r\nif (!extent_length) {\r\nbl_put_extent(be);\r\nbl_put_extent(cow_read);\r\nbio = bl_submit_bio(READ, bio);\r\nbe = bl_find_get_extent(BLK_LSEG2EXT(header->lseg),\r\nisect, &cow_read);\r\nif (!be) {\r\nheader->pnfs_error = -EIO;\r\ngoto out;\r\n}\r\nextent_length = be->be_length -\r\n(isect - be->be_f_offset);\r\nif (cow_read) {\r\nsector_t cow_length = cow_read->be_length -\r\n(isect - cow_read->be_f_offset);\r\nextent_length = min(extent_length, cow_length);\r\n}\r\n}\r\nif (is_dio) {\r\npg_offset = f_offset & ~PAGE_CACHE_MASK;\r\nif (pg_offset + bytes_left > PAGE_CACHE_SIZE)\r\npg_len = PAGE_CACHE_SIZE - pg_offset;\r\nelse\r\npg_len = bytes_left;\r\nf_offset += pg_len;\r\nbytes_left -= pg_len;\r\nisect += (pg_offset >> SECTOR_SHIFT);\r\n} else {\r\npg_offset = 0;\r\npg_len = PAGE_CACHE_SIZE;\r\n}\r\nhole = is_hole(be, isect);\r\nif (hole && !cow_read) {\r\nbio = bl_submit_bio(READ, bio);\r\ndprintk("%s Zeroing page for hole\n", __func__);\r\nzero_user_segment(pages[i], pg_offset, pg_len);\r\nprint_page(pages[i]);\r\nSetPageUptodate(pages[i]);\r\n} else {\r\nstruct pnfs_block_extent *be_read;\r\nbe_read = (hole && cow_read) ? cow_read : be;\r\nbio = do_add_page_to_bio(bio, rdata->pages.npages - i,\r\nREAD,\r\nisect, pages[i], be_read,\r\nbl_end_io_read, par,\r\npg_offset, pg_len);\r\nif (IS_ERR(bio)) {\r\nheader->pnfs_error = PTR_ERR(bio);\r\nbio = NULL;\r\ngoto out;\r\n}\r\n}\r\nisect += (pg_len >> SECTOR_SHIFT);\r\nextent_length -= PAGE_CACHE_SECTORS;\r\n}\r\nif ((isect << SECTOR_SHIFT) >= header->inode->i_size) {\r\nrdata->res.eof = 1;\r\nrdata->res.count = header->inode->i_size - rdata->args.offset;\r\n} else {\r\nrdata->res.count = (isect << SECTOR_SHIFT) - rdata->args.offset;\r\n}\r\nout:\r\nbl_put_extent(be);\r\nbl_put_extent(cow_read);\r\nbl_submit_bio(READ, bio);\r\nput_parallel(par);\r\nreturn PNFS_ATTEMPTED;\r\nuse_mds:\r\ndprintk("Giving up and using normal NFS\n");\r\nreturn PNFS_NOT_ATTEMPTED;\r\n}\r\nstatic void mark_extents_written(struct pnfs_block_layout *bl,\r\n__u64 offset, __u32 count)\r\n{\r\nsector_t isect, end;\r\nstruct pnfs_block_extent *be;\r\nstruct pnfs_block_short_extent *se;\r\ndprintk("%s(%llu, %u)\n", __func__, offset, count);\r\nif (count == 0)\r\nreturn;\r\nisect = (offset & (long)(PAGE_CACHE_MASK)) >> SECTOR_SHIFT;\r\nend = (offset + count + PAGE_CACHE_SIZE - 1) & (long)(PAGE_CACHE_MASK);\r\nend >>= SECTOR_SHIFT;\r\nwhile (isect < end) {\r\nsector_t len;\r\nbe = bl_find_get_extent(bl, isect, NULL);\r\nBUG_ON(!be);\r\nlen = min(end, be->be_f_offset + be->be_length) - isect;\r\nif (be->be_state == PNFS_BLOCK_INVALID_DATA) {\r\nse = bl_pop_one_short_extent(be->be_inval);\r\nBUG_ON(!se);\r\nbl_mark_for_commit(be, isect, len, se);\r\n}\r\nisect += len;\r\nbl_put_extent(be);\r\n}\r\n}\r\nstatic void bl_end_io_write_zero(struct bio *bio, int err)\r\n{\r\nstruct parallel_io *par = bio->bi_private;\r\nconst int uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags);\r\nstruct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;\r\ndo {\r\nstruct page *page = bvec->bv_page;\r\nif (--bvec >= bio->bi_io_vec)\r\nprefetchw(&bvec->bv_page->flags);\r\nend_page_writeback(page);\r\npage_cache_release(page);\r\n} while (bvec >= bio->bi_io_vec);\r\nif (unlikely(!uptodate)) {\r\nstruct nfs_write_data *data = par->data;\r\nstruct nfs_pgio_header *header = data->header;\r\nif (!header->pnfs_error)\r\nheader->pnfs_error = -EIO;\r\npnfs_set_lo_fail(header->lseg);\r\n}\r\nbio_put(bio);\r\nput_parallel(par);\r\n}\r\nstatic void bl_end_io_write(struct bio *bio, int err)\r\n{\r\nstruct parallel_io *par = bio->bi_private;\r\nconst int uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags);\r\nstruct nfs_write_data *data = par->data;\r\nstruct nfs_pgio_header *header = data->header;\r\nif (!uptodate) {\r\nif (!header->pnfs_error)\r\nheader->pnfs_error = -EIO;\r\npnfs_set_lo_fail(header->lseg);\r\n}\r\nbio_put(bio);\r\nput_parallel(par);\r\n}\r\nstatic void bl_write_cleanup(struct work_struct *work)\r\n{\r\nstruct rpc_task *task;\r\nstruct nfs_write_data *wdata;\r\ndprintk("%s enter\n", __func__);\r\ntask = container_of(work, struct rpc_task, u.tk_work);\r\nwdata = container_of(task, struct nfs_write_data, task);\r\nif (likely(!wdata->header->pnfs_error)) {\r\nmark_extents_written(BLK_LSEG2EXT(wdata->header->lseg),\r\nwdata->args.offset, wdata->args.count);\r\n}\r\npnfs_ld_write_done(wdata);\r\n}\r\nstatic void bl_end_par_io_write(void *data, int num_se)\r\n{\r\nstruct nfs_write_data *wdata = data;\r\nif (unlikely(wdata->header->pnfs_error)) {\r\nbl_free_short_extents(&BLK_LSEG2EXT(wdata->header->lseg)->bl_inval,\r\nnum_se);\r\n}\r\nwdata->task.tk_status = wdata->header->pnfs_error;\r\nwdata->verf.committed = NFS_FILE_SYNC;\r\nINIT_WORK(&wdata->task.u.tk_work, bl_write_cleanup);\r\nschedule_work(&wdata->task.u.tk_work);\r\n}\r\nstatic void mark_bad_read(void)\r\n{\r\nreturn;\r\n}\r\nstatic void\r\nmap_block(struct buffer_head *bh, sector_t isect, struct pnfs_block_extent *be)\r\n{\r\ndprintk("%s enter be=%p\n", __func__, be);\r\nset_buffer_mapped(bh);\r\nbh->b_bdev = be->be_mdev;\r\nbh->b_blocknr = (isect - be->be_f_offset + be->be_v_offset) >>\r\n(be->be_mdev->bd_inode->i_blkbits - SECTOR_SHIFT);\r\ndprintk("%s isect %llu, bh->b_blocknr %ld, using bsize %Zd\n",\r\n__func__, (unsigned long long)isect, (long)bh->b_blocknr,\r\nbh->b_size);\r\nreturn;\r\n}\r\nstatic void\r\nbl_read_single_end_io(struct bio *bio, int error)\r\n{\r\nstruct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;\r\nstruct page *page = bvec->bv_page;\r\nunlock_page(page);\r\n}\r\nstatic int\r\nbl_do_readpage_sync(struct page *page, struct pnfs_block_extent *be,\r\nunsigned int offset, unsigned int len)\r\n{\r\nstruct bio *bio;\r\nstruct page *shadow_page;\r\nsector_t isect;\r\nchar *kaddr, *kshadow_addr;\r\nint ret = 0;\r\ndprintk("%s: offset %u len %u\n", __func__, offset, len);\r\nshadow_page = alloc_page(GFP_NOFS | __GFP_HIGHMEM);\r\nif (shadow_page == NULL)\r\nreturn -ENOMEM;\r\nbio = bio_alloc(GFP_NOIO, 1);\r\nif (bio == NULL)\r\nreturn -ENOMEM;\r\nisect = (page->index << PAGE_CACHE_SECTOR_SHIFT) +\r\n(offset / SECTOR_SIZE);\r\nbio->bi_sector = isect - be->be_f_offset + be->be_v_offset;\r\nbio->bi_bdev = be->be_mdev;\r\nbio->bi_end_io = bl_read_single_end_io;\r\nlock_page(shadow_page);\r\nif (bio_add_page(bio, shadow_page,\r\nSECTOR_SIZE, round_down(offset, SECTOR_SIZE)) == 0) {\r\nunlock_page(shadow_page);\r\nbio_put(bio);\r\nreturn -EIO;\r\n}\r\nsubmit_bio(READ, bio);\r\nwait_on_page_locked(shadow_page);\r\nif (unlikely(!test_bit(BIO_UPTODATE, &bio->bi_flags))) {\r\nret = -EIO;\r\n} else {\r\nkaddr = kmap_atomic(page);\r\nkshadow_addr = kmap_atomic(shadow_page);\r\nmemcpy(kaddr + offset, kshadow_addr + offset, len);\r\nkunmap_atomic(kshadow_addr);\r\nkunmap_atomic(kaddr);\r\n}\r\n__free_page(shadow_page);\r\nbio_put(bio);\r\nreturn ret;\r\n}\r\nstatic int\r\nbl_read_partial_page_sync(struct page *page, struct pnfs_block_extent *be,\r\nunsigned int dirty_offset, unsigned int dirty_len,\r\nbool full_page)\r\n{\r\nint ret = 0;\r\nunsigned int start, end;\r\nif (full_page) {\r\nstart = 0;\r\nend = PAGE_CACHE_SIZE;\r\n} else {\r\nstart = round_down(dirty_offset, SECTOR_SIZE);\r\nend = round_up(dirty_offset + dirty_len, SECTOR_SIZE);\r\n}\r\ndprintk("%s: offset %u len %d\n", __func__, dirty_offset, dirty_len);\r\nif (!be) {\r\nzero_user_segments(page, start, dirty_offset,\r\ndirty_offset + dirty_len, end);\r\nif (start == 0 && end == PAGE_CACHE_SIZE &&\r\ntrylock_page(page)) {\r\nSetPageUptodate(page);\r\nunlock_page(page);\r\n}\r\nreturn ret;\r\n}\r\nif (start != dirty_offset)\r\nret = bl_do_readpage_sync(page, be, start, dirty_offset - start);\r\nif (!ret && (dirty_offset + dirty_len < end))\r\nret = bl_do_readpage_sync(page, be, dirty_offset + dirty_len,\r\nend - dirty_offset - dirty_len);\r\nreturn ret;\r\n}\r\nstatic int\r\ninit_page_for_write(struct page *page, struct pnfs_block_extent *cow_read)\r\n{\r\nstruct buffer_head *bh = NULL;\r\nint ret = 0;\r\nsector_t isect;\r\ndprintk("%s enter, %p\n", __func__, page);\r\nBUG_ON(PageUptodate(page));\r\nif (!cow_read) {\r\nzero_user_segment(page, 0, PAGE_SIZE);\r\nSetPageUptodate(page);\r\ngoto cleanup;\r\n}\r\nbh = alloc_page_buffers(page, PAGE_CACHE_SIZE, 0);\r\nif (!bh) {\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nisect = (sector_t) page->index << PAGE_CACHE_SECTOR_SHIFT;\r\nmap_block(bh, isect, cow_read);\r\nif (!bh_uptodate_or_lock(bh))\r\nret = bh_submit_read(bh);\r\nif (ret)\r\ngoto cleanup;\r\nSetPageUptodate(page);\r\ncleanup:\r\nif (bh)\r\nfree_buffer_head(bh);\r\nif (ret) {\r\nmark_bad_read();\r\n}\r\nreturn ret;\r\n}\r\nstatic struct page *\r\nbl_find_get_zeroing_page(struct inode *inode, pgoff_t index,\r\nstruct pnfs_block_extent *cow_read)\r\n{\r\nstruct page *page;\r\nint locked = 0;\r\npage = find_get_page(inode->i_mapping, index);\r\nif (page)\r\ngoto check_page;\r\npage = find_or_create_page(inode->i_mapping, index, GFP_NOFS);\r\nif (unlikely(!page)) {\r\ndprintk("%s oom\n", __func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nlocked = 1;\r\ncheck_page:\r\nif (PageDirty(page) || PageWriteback(page)) {\r\nprint_page(page);\r\nif (locked)\r\nunlock_page(page);\r\npage_cache_release(page);\r\nreturn NULL;\r\n}\r\nif (!locked) {\r\nlock_page(page);\r\nlocked = 1;\r\ngoto check_page;\r\n}\r\nif (!PageUptodate(page)) {\r\ninit_page_for_write(page, cow_read);\r\n}\r\nset_page_writeback(page);\r\nunlock_page(page);\r\nreturn page;\r\n}\r\nstatic enum pnfs_try_status\r\nbl_write_pagelist(struct nfs_write_data *wdata, int sync)\r\n{\r\nstruct nfs_pgio_header *header = wdata->header;\r\nint i, ret, npg_zero, pg_index, last = 0;\r\nstruct bio *bio = NULL;\r\nstruct pnfs_block_extent *be = NULL, *cow_read = NULL;\r\nsector_t isect, last_isect = 0, extent_length = 0;\r\nstruct parallel_io *par = NULL;\r\nloff_t offset = wdata->args.offset;\r\nsize_t count = wdata->args.count;\r\nunsigned int pg_offset, pg_len, saved_len;\r\nstruct page **pages = wdata->args.pages;\r\nstruct page *page;\r\npgoff_t index;\r\nu64 temp;\r\nint npg_per_block =\r\nNFS_SERVER(header->inode)->pnfs_blksize >> PAGE_CACHE_SHIFT;\r\ndprintk("%s enter, %Zu@%lld\n", __func__, count, offset);\r\nif (header->dreq != NULL &&\r\n(!IS_ALIGNED(offset, NFS_SERVER(header->inode)->pnfs_blksize) ||\r\n!IS_ALIGNED(count, NFS_SERVER(header->inode)->pnfs_blksize))) {\r\ndprintk("pnfsblock nonblock aligned DIO writes. Resend MDS\n");\r\ngoto out_mds;\r\n}\r\npar = alloc_parallel(wdata);\r\nif (!par)\r\ngoto out_mds;\r\npar->pnfs_callback = bl_end_par_io_write;\r\nisect = (sector_t) ((offset & (long)PAGE_CACHE_MASK) >> SECTOR_SHIFT);\r\nbe = bl_find_get_extent(BLK_LSEG2EXT(header->lseg), isect, &cow_read);\r\nif (!be || !is_writable(be, isect)) {\r\ndprintk("%s no matching extents!\n", __func__);\r\ngoto out_mds;\r\n}\r\nif (be->be_state == PNFS_BLOCK_INVALID_DATA) {\r\nif (likely(!bl_push_one_short_extent(be->be_inval)))\r\npar->bse_count++;\r\nelse\r\ngoto out_mds;\r\ntemp = offset >> PAGE_CACHE_SHIFT;\r\nnpg_zero = do_div(temp, npg_per_block);\r\nisect = (sector_t) (((offset - npg_zero * PAGE_CACHE_SIZE) &\r\n(long)PAGE_CACHE_MASK) >> SECTOR_SHIFT);\r\nextent_length = be->be_length - (isect - be->be_f_offset);\r\nfill_invalid_ext:\r\ndprintk("%s need to zero %d pages\n", __func__, npg_zero);\r\nfor (;npg_zero > 0; npg_zero--) {\r\nif (bl_is_sector_init(be->be_inval, isect)) {\r\ndprintk("isect %llu already init\n",\r\n(unsigned long long)isect);\r\ngoto next_page;\r\n}\r\nindex = isect >> PAGE_CACHE_SECTOR_SHIFT;\r\ndprintk("%s zero %dth page: index %lu isect %llu\n",\r\n__func__, npg_zero, index,\r\n(unsigned long long)isect);\r\npage = bl_find_get_zeroing_page(header->inode, index,\r\ncow_read);\r\nif (unlikely(IS_ERR(page))) {\r\nheader->pnfs_error = PTR_ERR(page);\r\ngoto out;\r\n} else if (page == NULL)\r\ngoto next_page;\r\nret = bl_mark_sectors_init(be->be_inval, isect,\r\nPAGE_CACHE_SECTORS);\r\nif (unlikely(ret)) {\r\ndprintk("%s bl_mark_sectors_init fail %d\n",\r\n__func__, ret);\r\nend_page_writeback(page);\r\npage_cache_release(page);\r\nheader->pnfs_error = ret;\r\ngoto out;\r\n}\r\nif (likely(!bl_push_one_short_extent(be->be_inval)))\r\npar->bse_count++;\r\nelse {\r\nend_page_writeback(page);\r\npage_cache_release(page);\r\nheader->pnfs_error = -ENOMEM;\r\ngoto out;\r\n}\r\nmark_extents_written(BLK_LSEG2EXT(header->lseg),\r\npage->index << PAGE_CACHE_SHIFT,\r\nPAGE_CACHE_SIZE);\r\nbio = bl_add_page_to_bio(bio, npg_zero, WRITE,\r\nisect, page, be,\r\nbl_end_io_write_zero, par);\r\nif (IS_ERR(bio)) {\r\nheader->pnfs_error = PTR_ERR(bio);\r\nbio = NULL;\r\ngoto out;\r\n}\r\nnext_page:\r\nisect += PAGE_CACHE_SECTORS;\r\nextent_length -= PAGE_CACHE_SECTORS;\r\n}\r\nif (last)\r\ngoto write_done;\r\n}\r\nbio = bl_submit_bio(WRITE, bio);\r\npg_index = wdata->args.pgbase >> PAGE_CACHE_SHIFT;\r\nfor (i = pg_index; i < wdata->pages.npages; i++) {\r\nif (!extent_length) {\r\nbl_put_extent(be);\r\nbl_put_extent(cow_read);\r\nbio = bl_submit_bio(WRITE, bio);\r\nbe = bl_find_get_extent(BLK_LSEG2EXT(header->lseg),\r\nisect, &cow_read);\r\nif (!be || !is_writable(be, isect)) {\r\nheader->pnfs_error = -EINVAL;\r\ngoto out;\r\n}\r\nif (be->be_state == PNFS_BLOCK_INVALID_DATA) {\r\nif (likely(!bl_push_one_short_extent(\r\nbe->be_inval)))\r\npar->bse_count++;\r\nelse {\r\nheader->pnfs_error = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nextent_length = be->be_length -\r\n(isect - be->be_f_offset);\r\n}\r\ndprintk("%s offset %lld count %Zu\n", __func__, offset, count);\r\npg_offset = offset & ~PAGE_CACHE_MASK;\r\nif (pg_offset + count > PAGE_CACHE_SIZE)\r\npg_len = PAGE_CACHE_SIZE - pg_offset;\r\nelse\r\npg_len = count;\r\nsaved_len = pg_len;\r\nif (be->be_state == PNFS_BLOCK_INVALID_DATA &&\r\n!bl_is_sector_init(be->be_inval, isect)) {\r\nret = bl_read_partial_page_sync(pages[i], cow_read,\r\npg_offset, pg_len, true);\r\nif (ret) {\r\ndprintk("%s bl_read_partial_page_sync fail %d\n",\r\n__func__, ret);\r\nheader->pnfs_error = ret;\r\ngoto out;\r\n}\r\nret = bl_mark_sectors_init(be->be_inval, isect,\r\nPAGE_CACHE_SECTORS);\r\nif (unlikely(ret)) {\r\ndprintk("%s bl_mark_sectors_init fail %d\n",\r\n__func__, ret);\r\nheader->pnfs_error = ret;\r\ngoto out;\r\n}\r\npg_offset = 0;\r\npg_len = PAGE_CACHE_SIZE;\r\n} else if ((pg_offset & (SECTOR_SIZE - 1)) ||\r\n(pg_len & (SECTOR_SIZE - 1))){\r\nunsigned int saved_offset = pg_offset;\r\nret = bl_read_partial_page_sync(pages[i], be, pg_offset,\r\npg_len, false);\r\npg_offset = round_down(pg_offset, SECTOR_SIZE);\r\npg_len = round_up(saved_offset + pg_len, SECTOR_SIZE)\r\n- pg_offset;\r\n}\r\nbio = do_add_page_to_bio(bio, wdata->pages.npages - i, WRITE,\r\nisect, pages[i], be,\r\nbl_end_io_write, par,\r\npg_offset, pg_len);\r\nif (IS_ERR(bio)) {\r\nheader->pnfs_error = PTR_ERR(bio);\r\nbio = NULL;\r\ngoto out;\r\n}\r\noffset += saved_len;\r\ncount -= saved_len;\r\nisect += PAGE_CACHE_SECTORS;\r\nlast_isect = isect;\r\nextent_length -= PAGE_CACHE_SECTORS;\r\n}\r\nif (be->be_state == PNFS_BLOCK_INVALID_DATA) {\r\nbio = bl_submit_bio(WRITE, bio);\r\ntemp = last_isect >> PAGE_CACHE_SECTOR_SHIFT;\r\nnpg_zero = npg_per_block - do_div(temp, npg_per_block);\r\nif (npg_zero < npg_per_block) {\r\nlast = 1;\r\ngoto fill_invalid_ext;\r\n}\r\n}\r\nwrite_done:\r\nwdata->res.count = wdata->args.count;\r\nout:\r\nbl_put_extent(be);\r\nbl_put_extent(cow_read);\r\nbl_submit_bio(WRITE, bio);\r\nput_parallel(par);\r\nreturn PNFS_ATTEMPTED;\r\nout_mds:\r\nbl_put_extent(be);\r\nbl_put_extent(cow_read);\r\nkfree(par);\r\nreturn PNFS_NOT_ATTEMPTED;\r\n}\r\nstatic void\r\nrelease_extents(struct pnfs_block_layout *bl, struct pnfs_layout_range *range)\r\n{\r\nint i;\r\nstruct pnfs_block_extent *be;\r\nspin_lock(&bl->bl_ext_lock);\r\nfor (i = 0; i < EXTENT_LISTS; i++) {\r\nwhile (!list_empty(&bl->bl_extents[i])) {\r\nbe = list_first_entry(&bl->bl_extents[i],\r\nstruct pnfs_block_extent,\r\nbe_node);\r\nlist_del(&be->be_node);\r\nbl_put_extent(be);\r\n}\r\n}\r\nspin_unlock(&bl->bl_ext_lock);\r\n}\r\nstatic void\r\nrelease_inval_marks(struct pnfs_inval_markings *marks)\r\n{\r\nstruct pnfs_inval_tracking *pos, *temp;\r\nstruct pnfs_block_short_extent *se, *stemp;\r\nlist_for_each_entry_safe(pos, temp, &marks->im_tree.mtt_stub, it_link) {\r\nlist_del(&pos->it_link);\r\nkfree(pos);\r\n}\r\nlist_for_each_entry_safe(se, stemp, &marks->im_extents, bse_node) {\r\nlist_del(&se->bse_node);\r\nkfree(se);\r\n}\r\nreturn;\r\n}\r\nstatic void bl_free_layout_hdr(struct pnfs_layout_hdr *lo)\r\n{\r\nstruct pnfs_block_layout *bl = BLK_LO2EXT(lo);\r\ndprintk("%s enter\n", __func__);\r\nrelease_extents(bl, NULL);\r\nrelease_inval_marks(&bl->bl_inval);\r\nkfree(bl);\r\n}\r\nstatic struct pnfs_layout_hdr *bl_alloc_layout_hdr(struct inode *inode,\r\ngfp_t gfp_flags)\r\n{\r\nstruct pnfs_block_layout *bl;\r\ndprintk("%s enter\n", __func__);\r\nbl = kzalloc(sizeof(*bl), gfp_flags);\r\nif (!bl)\r\nreturn NULL;\r\nspin_lock_init(&bl->bl_ext_lock);\r\nINIT_LIST_HEAD(&bl->bl_extents[0]);\r\nINIT_LIST_HEAD(&bl->bl_extents[1]);\r\nINIT_LIST_HEAD(&bl->bl_commit);\r\nINIT_LIST_HEAD(&bl->bl_committing);\r\nbl->bl_count = 0;\r\nbl->bl_blocksize = NFS_SERVER(inode)->pnfs_blksize >> SECTOR_SHIFT;\r\nBL_INIT_INVAL_MARKS(&bl->bl_inval, bl->bl_blocksize);\r\nreturn &bl->bl_layout;\r\n}\r\nstatic void bl_free_lseg(struct pnfs_layout_segment *lseg)\r\n{\r\ndprintk("%s enter\n", __func__);\r\nkfree(lseg);\r\n}\r\nstatic struct pnfs_layout_segment *bl_alloc_lseg(struct pnfs_layout_hdr *lo,\r\nstruct nfs4_layoutget_res *lgr,\r\ngfp_t gfp_flags)\r\n{\r\nstruct pnfs_layout_segment *lseg;\r\nint status;\r\ndprintk("%s enter\n", __func__);\r\nlseg = kzalloc(sizeof(*lseg), gfp_flags);\r\nif (!lseg)\r\nreturn ERR_PTR(-ENOMEM);\r\nstatus = nfs4_blk_process_layoutget(lo, lgr, gfp_flags);\r\nif (status) {\r\nkfree(lseg);\r\nreturn ERR_PTR(status);\r\n}\r\nreturn lseg;\r\n}\r\nstatic void\r\nbl_encode_layoutcommit(struct pnfs_layout_hdr *lo, struct xdr_stream *xdr,\r\nconst struct nfs4_layoutcommit_args *arg)\r\n{\r\ndprintk("%s enter\n", __func__);\r\nencode_pnfs_block_layoutupdate(BLK_LO2EXT(lo), xdr, arg);\r\n}\r\nstatic void\r\nbl_cleanup_layoutcommit(struct nfs4_layoutcommit_data *lcdata)\r\n{\r\nstruct pnfs_layout_hdr *lo = NFS_I(lcdata->args.inode)->layout;\r\ndprintk("%s enter\n", __func__);\r\nclean_pnfs_block_layoutupdate(BLK_LO2EXT(lo), &lcdata->args, lcdata->res.status);\r\n}\r\nstatic void free_blk_mountid(struct block_mount_id *mid)\r\n{\r\nif (mid) {\r\nstruct pnfs_block_dev *dev, *tmp;\r\nlist_for_each_entry_safe(dev, tmp, &mid->bm_devlist, bm_node) {\r\nlist_del(&dev->bm_node);\r\nbl_free_block_dev(dev);\r\n}\r\nkfree(mid);\r\n}\r\n}\r\nstatic struct pnfs_block_dev *\r\nnfs4_blk_get_deviceinfo(struct nfs_server *server, const struct nfs_fh *fh,\r\nstruct nfs4_deviceid *d_id)\r\n{\r\nstruct pnfs_device *dev;\r\nstruct pnfs_block_dev *rv;\r\nu32 max_resp_sz;\r\nint max_pages;\r\nstruct page **pages = NULL;\r\nint i, rc;\r\nmax_resp_sz = server->nfs_client->cl_session->fc_attrs.max_resp_sz;\r\nmax_pages = nfs_page_array_len(0, max_resp_sz);\r\ndprintk("%s max_resp_sz %u max_pages %d\n",\r\n__func__, max_resp_sz, max_pages);\r\ndev = kmalloc(sizeof(*dev), GFP_NOFS);\r\nif (!dev) {\r\ndprintk("%s kmalloc failed\n", __func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\npages = kzalloc(max_pages * sizeof(struct page *), GFP_NOFS);\r\nif (pages == NULL) {\r\nkfree(dev);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nfor (i = 0; i < max_pages; i++) {\r\npages[i] = alloc_page(GFP_NOFS);\r\nif (!pages[i]) {\r\nrv = ERR_PTR(-ENOMEM);\r\ngoto out_free;\r\n}\r\n}\r\nmemcpy(&dev->dev_id, d_id, sizeof(*d_id));\r\ndev->layout_type = LAYOUT_BLOCK_VOLUME;\r\ndev->pages = pages;\r\ndev->pgbase = 0;\r\ndev->pglen = PAGE_SIZE * max_pages;\r\ndev->mincount = 0;\r\ndev->maxcount = max_resp_sz - nfs41_maxgetdevinfo_overhead;\r\ndprintk("%s: dev_id: %s\n", __func__, dev->dev_id.data);\r\nrc = nfs4_proc_getdeviceinfo(server, dev, NULL);\r\ndprintk("%s getdevice info returns %d\n", __func__, rc);\r\nif (rc) {\r\nrv = ERR_PTR(rc);\r\ngoto out_free;\r\n}\r\nrv = nfs4_blk_decode_device(server, dev);\r\nout_free:\r\nfor (i = 0; i < max_pages; i++)\r\n__free_page(pages[i]);\r\nkfree(pages);\r\nkfree(dev);\r\nreturn rv;\r\n}\r\nstatic int\r\nbl_set_layoutdriver(struct nfs_server *server, const struct nfs_fh *fh)\r\n{\r\nstruct block_mount_id *b_mt_id = NULL;\r\nstruct pnfs_devicelist *dlist = NULL;\r\nstruct pnfs_block_dev *bdev;\r\nLIST_HEAD(block_disklist);\r\nint status, i;\r\ndprintk("%s enter\n", __func__);\r\nif (server->pnfs_blksize == 0) {\r\ndprintk("%s Server did not return blksize\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nb_mt_id = kzalloc(sizeof(struct block_mount_id), GFP_NOFS);\r\nif (!b_mt_id) {\r\nstatus = -ENOMEM;\r\ngoto out_error;\r\n}\r\nspin_lock_init(&b_mt_id->bm_lock);\r\nINIT_LIST_HEAD(&b_mt_id->bm_devlist);\r\ndlist = kmalloc(sizeof(struct pnfs_devicelist), GFP_NOFS);\r\nif (!dlist) {\r\nstatus = -ENOMEM;\r\ngoto out_error;\r\n}\r\ndlist->eof = 0;\r\nwhile (!dlist->eof) {\r\nstatus = nfs4_proc_getdevicelist(server, fh, dlist);\r\nif (status)\r\ngoto out_error;\r\ndprintk("%s GETDEVICELIST numdevs=%i, eof=%i\n",\r\n__func__, dlist->num_devs, dlist->eof);\r\nfor (i = 0; i < dlist->num_devs; i++) {\r\nbdev = nfs4_blk_get_deviceinfo(server, fh,\r\n&dlist->dev_id[i]);\r\nif (IS_ERR(bdev)) {\r\nstatus = PTR_ERR(bdev);\r\ngoto out_error;\r\n}\r\nspin_lock(&b_mt_id->bm_lock);\r\nlist_add(&bdev->bm_node, &b_mt_id->bm_devlist);\r\nspin_unlock(&b_mt_id->bm_lock);\r\n}\r\n}\r\ndprintk("%s SUCCESS\n", __func__);\r\nserver->pnfs_ld_data = b_mt_id;\r\nout_return:\r\nkfree(dlist);\r\nreturn status;\r\nout_error:\r\nfree_blk_mountid(b_mt_id);\r\ngoto out_return;\r\n}\r\nstatic int\r\nbl_clear_layoutdriver(struct nfs_server *server)\r\n{\r\nstruct block_mount_id *b_mt_id = server->pnfs_ld_data;\r\ndprintk("%s enter\n", __func__);\r\nfree_blk_mountid(b_mt_id);\r\ndprintk("%s RETURNS\n", __func__);\r\nreturn 0;\r\n}\r\nstatic bool\r\nis_aligned_req(struct nfs_page *req, unsigned int alignment)\r\n{\r\nreturn IS_ALIGNED(req->wb_offset, alignment) &&\r\nIS_ALIGNED(req->wb_bytes, alignment);\r\n}\r\nstatic void\r\nbl_pg_init_read(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\r\n{\r\nif (pgio->pg_dreq != NULL &&\r\n!is_aligned_req(req, SECTOR_SIZE))\r\nnfs_pageio_reset_read_mds(pgio);\r\nelse\r\npnfs_generic_pg_init_read(pgio, req);\r\n}\r\nstatic bool\r\nbl_pg_test_read(struct nfs_pageio_descriptor *pgio, struct nfs_page *prev,\r\nstruct nfs_page *req)\r\n{\r\nif (pgio->pg_dreq != NULL &&\r\n!is_aligned_req(req, SECTOR_SIZE))\r\nreturn false;\r\nreturn pnfs_generic_pg_test(pgio, prev, req);\r\n}\r\nstatic u64 pnfs_num_cont_bytes(struct inode *inode, pgoff_t idx)\r\n{\r\nstruct address_space *mapping = inode->i_mapping;\r\npgoff_t end;\r\nend = DIV_ROUND_UP(i_size_read(inode), PAGE_CACHE_SIZE);\r\nif (end != NFS_I(inode)->npages) {\r\nrcu_read_lock();\r\nend = radix_tree_next_hole(&mapping->page_tree, idx + 1, ULONG_MAX);\r\nrcu_read_unlock();\r\n}\r\nif (!end)\r\nreturn i_size_read(inode) - (idx << PAGE_CACHE_SHIFT);\r\nelse\r\nreturn (end - idx) << PAGE_CACHE_SHIFT;\r\n}\r\nstatic void\r\nbl_pg_init_write(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\r\n{\r\nif (pgio->pg_dreq != NULL &&\r\n!is_aligned_req(req, PAGE_CACHE_SIZE)) {\r\nnfs_pageio_reset_write_mds(pgio);\r\n} else {\r\nu64 wb_size;\r\nif (pgio->pg_dreq == NULL)\r\nwb_size = pnfs_num_cont_bytes(pgio->pg_inode,\r\nreq->wb_index);\r\nelse\r\nwb_size = nfs_dreq_bytes_left(pgio->pg_dreq);\r\npnfs_generic_pg_init_write(pgio, req, wb_size);\r\n}\r\n}\r\nstatic bool\r\nbl_pg_test_write(struct nfs_pageio_descriptor *pgio, struct nfs_page *prev,\r\nstruct nfs_page *req)\r\n{\r\nif (pgio->pg_dreq != NULL &&\r\n!is_aligned_req(req, PAGE_CACHE_SIZE))\r\nreturn false;\r\nreturn pnfs_generic_pg_test(pgio, prev, req);\r\n}\r\nstatic struct dentry *nfs4blocklayout_register_sb(struct super_block *sb,\r\nstruct rpc_pipe *pipe)\r\n{\r\nstruct dentry *dir, *dentry;\r\ndir = rpc_d_lookup_sb(sb, NFS_PIPE_DIRNAME);\r\nif (dir == NULL)\r\nreturn ERR_PTR(-ENOENT);\r\ndentry = rpc_mkpipe_dentry(dir, "blocklayout", NULL, pipe);\r\ndput(dir);\r\nreturn dentry;\r\n}\r\nstatic void nfs4blocklayout_unregister_sb(struct super_block *sb,\r\nstruct rpc_pipe *pipe)\r\n{\r\nif (pipe->dentry)\r\nrpc_unlink(pipe->dentry);\r\n}\r\nstatic int rpc_pipefs_event(struct notifier_block *nb, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct super_block *sb = ptr;\r\nstruct net *net = sb->s_fs_info;\r\nstruct nfs_net *nn = net_generic(net, nfs_net_id);\r\nstruct dentry *dentry;\r\nint ret = 0;\r\nif (!try_module_get(THIS_MODULE))\r\nreturn 0;\r\nif (nn->bl_device_pipe == NULL) {\r\nmodule_put(THIS_MODULE);\r\nreturn 0;\r\n}\r\nswitch (event) {\r\ncase RPC_PIPEFS_MOUNT:\r\ndentry = nfs4blocklayout_register_sb(sb, nn->bl_device_pipe);\r\nif (IS_ERR(dentry)) {\r\nret = PTR_ERR(dentry);\r\nbreak;\r\n}\r\nnn->bl_device_pipe->dentry = dentry;\r\nbreak;\r\ncase RPC_PIPEFS_UMOUNT:\r\nif (nn->bl_device_pipe->dentry)\r\nnfs4blocklayout_unregister_sb(sb, nn->bl_device_pipe);\r\nbreak;\r\ndefault:\r\nret = -ENOTSUPP;\r\nbreak;\r\n}\r\nmodule_put(THIS_MODULE);\r\nreturn ret;\r\n}\r\nstatic struct dentry *nfs4blocklayout_register_net(struct net *net,\r\nstruct rpc_pipe *pipe)\r\n{\r\nstruct super_block *pipefs_sb;\r\nstruct dentry *dentry;\r\npipefs_sb = rpc_get_sb_net(net);\r\nif (!pipefs_sb)\r\nreturn NULL;\r\ndentry = nfs4blocklayout_register_sb(pipefs_sb, pipe);\r\nrpc_put_sb_net(net);\r\nreturn dentry;\r\n}\r\nstatic void nfs4blocklayout_unregister_net(struct net *net,\r\nstruct rpc_pipe *pipe)\r\n{\r\nstruct super_block *pipefs_sb;\r\npipefs_sb = rpc_get_sb_net(net);\r\nif (pipefs_sb) {\r\nnfs4blocklayout_unregister_sb(pipefs_sb, pipe);\r\nrpc_put_sb_net(net);\r\n}\r\n}\r\nstatic int nfs4blocklayout_net_init(struct net *net)\r\n{\r\nstruct nfs_net *nn = net_generic(net, nfs_net_id);\r\nstruct dentry *dentry;\r\ninit_waitqueue_head(&nn->bl_wq);\r\nnn->bl_device_pipe = rpc_mkpipe_data(&bl_upcall_ops, 0);\r\nif (IS_ERR(nn->bl_device_pipe))\r\nreturn PTR_ERR(nn->bl_device_pipe);\r\ndentry = nfs4blocklayout_register_net(net, nn->bl_device_pipe);\r\nif (IS_ERR(dentry)) {\r\nrpc_destroy_pipe_data(nn->bl_device_pipe);\r\nreturn PTR_ERR(dentry);\r\n}\r\nnn->bl_device_pipe->dentry = dentry;\r\nreturn 0;\r\n}\r\nstatic void nfs4blocklayout_net_exit(struct net *net)\r\n{\r\nstruct nfs_net *nn = net_generic(net, nfs_net_id);\r\nnfs4blocklayout_unregister_net(net, nn->bl_device_pipe);\r\nrpc_destroy_pipe_data(nn->bl_device_pipe);\r\nnn->bl_device_pipe = NULL;\r\n}\r\nstatic int __init nfs4blocklayout_init(void)\r\n{\r\nint ret;\r\ndprintk("%s: NFSv4 Block Layout Driver Registering...\n", __func__);\r\nret = pnfs_register_layoutdriver(&blocklayout_type);\r\nif (ret)\r\ngoto out;\r\nret = rpc_pipefs_notifier_register(&nfs4blocklayout_block);\r\nif (ret)\r\ngoto out_remove;\r\nret = register_pernet_subsys(&nfs4blocklayout_net_ops);\r\nif (ret)\r\ngoto out_notifier;\r\nout:\r\nreturn ret;\r\nout_notifier:\r\nrpc_pipefs_notifier_unregister(&nfs4blocklayout_block);\r\nout_remove:\r\npnfs_unregister_layoutdriver(&blocklayout_type);\r\nreturn ret;\r\n}\r\nstatic void __exit nfs4blocklayout_exit(void)\r\n{\r\ndprintk("%s: NFSv4 Block Layout Driver Unregistering...\n",\r\n__func__);\r\nrpc_pipefs_notifier_unregister(&nfs4blocklayout_block);\r\nunregister_pernet_subsys(&nfs4blocklayout_net_ops);\r\npnfs_unregister_layoutdriver(&blocklayout_type);\r\n}
