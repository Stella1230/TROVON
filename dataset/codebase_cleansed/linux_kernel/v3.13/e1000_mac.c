s32 igb_get_bus_info_pcie(struct e1000_hw *hw)\r\n{\r\nstruct e1000_bus_info *bus = &hw->bus;\r\ns32 ret_val;\r\nu32 reg;\r\nu16 pcie_link_status;\r\nbus->type = e1000_bus_type_pci_express;\r\nret_val = igb_read_pcie_cap_reg(hw,\r\nPCI_EXP_LNKSTA,\r\n&pcie_link_status);\r\nif (ret_val) {\r\nbus->width = e1000_bus_width_unknown;\r\nbus->speed = e1000_bus_speed_unknown;\r\n} else {\r\nswitch (pcie_link_status & PCI_EXP_LNKSTA_CLS) {\r\ncase PCI_EXP_LNKSTA_CLS_2_5GB:\r\nbus->speed = e1000_bus_speed_2500;\r\nbreak;\r\ncase PCI_EXP_LNKSTA_CLS_5_0GB:\r\nbus->speed = e1000_bus_speed_5000;\r\nbreak;\r\ndefault:\r\nbus->speed = e1000_bus_speed_unknown;\r\nbreak;\r\n}\r\nbus->width = (enum e1000_bus_width)((pcie_link_status &\r\nPCI_EXP_LNKSTA_NLW) >>\r\nPCI_EXP_LNKSTA_NLW_SHIFT);\r\n}\r\nreg = rd32(E1000_STATUS);\r\nbus->func = (reg & E1000_STATUS_FUNC_MASK) >> E1000_STATUS_FUNC_SHIFT;\r\nreturn 0;\r\n}\r\nvoid igb_clear_vfta(struct e1000_hw *hw)\r\n{\r\nu32 offset;\r\nfor (offset = 0; offset < E1000_VLAN_FILTER_TBL_SIZE; offset++) {\r\narray_wr32(E1000_VFTA, offset, 0);\r\nwrfl();\r\n}\r\n}\r\nstatic void igb_write_vfta(struct e1000_hw *hw, u32 offset, u32 value)\r\n{\r\narray_wr32(E1000_VFTA, offset, value);\r\nwrfl();\r\n}\r\nvoid igb_clear_vfta_i350(struct e1000_hw *hw)\r\n{\r\nu32 offset;\r\nint i;\r\nfor (offset = 0; offset < E1000_VLAN_FILTER_TBL_SIZE; offset++) {\r\nfor (i = 0; i < 10; i++)\r\narray_wr32(E1000_VFTA, offset, 0);\r\nwrfl();\r\n}\r\n}\r\nstatic void igb_write_vfta_i350(struct e1000_hw *hw, u32 offset, u32 value)\r\n{\r\nint i;\r\nfor (i = 0; i < 10; i++)\r\narray_wr32(E1000_VFTA, offset, value);\r\nwrfl();\r\n}\r\nvoid igb_init_rx_addrs(struct e1000_hw *hw, u16 rar_count)\r\n{\r\nu32 i;\r\nu8 mac_addr[ETH_ALEN] = {0};\r\nhw_dbg("Programming MAC Address into RAR[0]\n");\r\nhw->mac.ops.rar_set(hw, hw->mac.addr, 0);\r\nhw_dbg("Clearing RAR[1-%u]\n", rar_count-1);\r\nfor (i = 1; i < rar_count; i++)\r\nhw->mac.ops.rar_set(hw, mac_addr, i);\r\n}\r\ns32 igb_vfta_set(struct e1000_hw *hw, u32 vid, bool add)\r\n{\r\nu32 index = (vid >> E1000_VFTA_ENTRY_SHIFT) & E1000_VFTA_ENTRY_MASK;\r\nu32 mask = 1 << (vid & E1000_VFTA_ENTRY_BIT_SHIFT_MASK);\r\nu32 vfta;\r\nstruct igb_adapter *adapter = hw->back;\r\ns32 ret_val = 0;\r\nvfta = adapter->shadow_vfta[index];\r\nif ((!!(vfta & mask)) == add) {\r\nret_val = -E1000_ERR_CONFIG;\r\n} else {\r\nif (add)\r\nvfta |= mask;\r\nelse\r\nvfta &= ~mask;\r\n}\r\nif ((hw->mac.type == e1000_i350) || (hw->mac.type == e1000_i354))\r\nigb_write_vfta_i350(hw, index, vfta);\r\nelse\r\nigb_write_vfta(hw, index, vfta);\r\nadapter->shadow_vfta[index] = vfta;\r\nreturn ret_val;\r\n}\r\ns32 igb_check_alt_mac_addr(struct e1000_hw *hw)\r\n{\r\nu32 i;\r\ns32 ret_val = 0;\r\nu16 offset, nvm_alt_mac_addr_offset, nvm_data;\r\nu8 alt_mac_addr[ETH_ALEN];\r\nif (hw->mac.type >= e1000_82580)\r\ngoto out;\r\nret_val = hw->nvm.ops.read(hw, NVM_ALT_MAC_ADDR_PTR, 1,\r\n&nvm_alt_mac_addr_offset);\r\nif (ret_val) {\r\nhw_dbg("NVM Read Error\n");\r\ngoto out;\r\n}\r\nif ((nvm_alt_mac_addr_offset == 0xFFFF) ||\r\n(nvm_alt_mac_addr_offset == 0x0000))\r\ngoto out;\r\nif (hw->bus.func == E1000_FUNC_1)\r\nnvm_alt_mac_addr_offset += E1000_ALT_MAC_ADDRESS_OFFSET_LAN1;\r\nif (hw->bus.func == E1000_FUNC_2)\r\nnvm_alt_mac_addr_offset += E1000_ALT_MAC_ADDRESS_OFFSET_LAN2;\r\nif (hw->bus.func == E1000_FUNC_3)\r\nnvm_alt_mac_addr_offset += E1000_ALT_MAC_ADDRESS_OFFSET_LAN3;\r\nfor (i = 0; i < ETH_ALEN; i += 2) {\r\noffset = nvm_alt_mac_addr_offset + (i >> 1);\r\nret_val = hw->nvm.ops.read(hw, offset, 1, &nvm_data);\r\nif (ret_val) {\r\nhw_dbg("NVM Read Error\n");\r\ngoto out;\r\n}\r\nalt_mac_addr[i] = (u8)(nvm_data & 0xFF);\r\nalt_mac_addr[i + 1] = (u8)(nvm_data >> 8);\r\n}\r\nif (is_multicast_ether_addr(alt_mac_addr)) {\r\nhw_dbg("Ignoring Alternate Mac Address with MC bit set\n");\r\ngoto out;\r\n}\r\nhw->mac.ops.rar_set(hw, alt_mac_addr, 0);\r\nout:\r\nreturn ret_val;\r\n}\r\nvoid igb_rar_set(struct e1000_hw *hw, u8 *addr, u32 index)\r\n{\r\nu32 rar_low, rar_high;\r\nrar_low = ((u32) addr[0] |\r\n((u32) addr[1] << 8) |\r\n((u32) addr[2] << 16) | ((u32) addr[3] << 24));\r\nrar_high = ((u32) addr[4] | ((u32) addr[5] << 8));\r\nif (rar_low || rar_high)\r\nrar_high |= E1000_RAH_AV;\r\nwr32(E1000_RAL(index), rar_low);\r\nwrfl();\r\nwr32(E1000_RAH(index), rar_high);\r\nwrfl();\r\n}\r\nvoid igb_mta_set(struct e1000_hw *hw, u32 hash_value)\r\n{\r\nu32 hash_bit, hash_reg, mta;\r\nhash_reg = (hash_value >> 5) & (hw->mac.mta_reg_count - 1);\r\nhash_bit = hash_value & 0x1F;\r\nmta = array_rd32(E1000_MTA, hash_reg);\r\nmta |= (1 << hash_bit);\r\narray_wr32(E1000_MTA, hash_reg, mta);\r\nwrfl();\r\n}\r\nstatic u32 igb_hash_mc_addr(struct e1000_hw *hw, u8 *mc_addr)\r\n{\r\nu32 hash_value, hash_mask;\r\nu8 bit_shift = 0;\r\nhash_mask = (hw->mac.mta_reg_count * 32) - 1;\r\nwhile (hash_mask >> bit_shift != 0xFF)\r\nbit_shift++;\r\nswitch (hw->mac.mc_filter_type) {\r\ndefault:\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nbit_shift += 1;\r\nbreak;\r\ncase 2:\r\nbit_shift += 2;\r\nbreak;\r\ncase 3:\r\nbit_shift += 4;\r\nbreak;\r\n}\r\nhash_value = hash_mask & (((mc_addr[4] >> (8 - bit_shift)) |\r\n(((u16) mc_addr[5]) << bit_shift)));\r\nreturn hash_value;\r\n}\r\nvoid igb_update_mc_addr_list(struct e1000_hw *hw,\r\nu8 *mc_addr_list, u32 mc_addr_count)\r\n{\r\nu32 hash_value, hash_bit, hash_reg;\r\nint i;\r\nmemset(&hw->mac.mta_shadow, 0, sizeof(hw->mac.mta_shadow));\r\nfor (i = 0; (u32) i < mc_addr_count; i++) {\r\nhash_value = igb_hash_mc_addr(hw, mc_addr_list);\r\nhash_reg = (hash_value >> 5) & (hw->mac.mta_reg_count - 1);\r\nhash_bit = hash_value & 0x1F;\r\nhw->mac.mta_shadow[hash_reg] |= (1 << hash_bit);\r\nmc_addr_list += (ETH_ALEN);\r\n}\r\nfor (i = hw->mac.mta_reg_count - 1; i >= 0; i--)\r\narray_wr32(E1000_MTA, i, hw->mac.mta_shadow[i]);\r\nwrfl();\r\n}\r\nvoid igb_clear_hw_cntrs_base(struct e1000_hw *hw)\r\n{\r\nrd32(E1000_CRCERRS);\r\nrd32(E1000_SYMERRS);\r\nrd32(E1000_MPC);\r\nrd32(E1000_SCC);\r\nrd32(E1000_ECOL);\r\nrd32(E1000_MCC);\r\nrd32(E1000_LATECOL);\r\nrd32(E1000_COLC);\r\nrd32(E1000_DC);\r\nrd32(E1000_SEC);\r\nrd32(E1000_RLEC);\r\nrd32(E1000_XONRXC);\r\nrd32(E1000_XONTXC);\r\nrd32(E1000_XOFFRXC);\r\nrd32(E1000_XOFFTXC);\r\nrd32(E1000_FCRUC);\r\nrd32(E1000_GPRC);\r\nrd32(E1000_BPRC);\r\nrd32(E1000_MPRC);\r\nrd32(E1000_GPTC);\r\nrd32(E1000_GORCL);\r\nrd32(E1000_GORCH);\r\nrd32(E1000_GOTCL);\r\nrd32(E1000_GOTCH);\r\nrd32(E1000_RNBC);\r\nrd32(E1000_RUC);\r\nrd32(E1000_RFC);\r\nrd32(E1000_ROC);\r\nrd32(E1000_RJC);\r\nrd32(E1000_TORL);\r\nrd32(E1000_TORH);\r\nrd32(E1000_TOTL);\r\nrd32(E1000_TOTH);\r\nrd32(E1000_TPR);\r\nrd32(E1000_TPT);\r\nrd32(E1000_MPTC);\r\nrd32(E1000_BPTC);\r\n}\r\ns32 igb_check_for_copper_link(struct e1000_hw *hw)\r\n{\r\nstruct e1000_mac_info *mac = &hw->mac;\r\ns32 ret_val;\r\nbool link;\r\nif (!mac->get_link_status) {\r\nret_val = 0;\r\ngoto out;\r\n}\r\nret_val = igb_phy_has_link(hw, 1, 0, &link);\r\nif (ret_val)\r\ngoto out;\r\nif (!link)\r\ngoto out;\r\nmac->get_link_status = false;\r\nigb_check_downshift(hw);\r\nif (!mac->autoneg) {\r\nret_val = -E1000_ERR_CONFIG;\r\ngoto out;\r\n}\r\nigb_config_collision_dist(hw);\r\nret_val = igb_config_fc_after_link_up(hw);\r\nif (ret_val)\r\nhw_dbg("Error configuring flow control\n");\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 igb_setup_link(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nif (igb_check_reset_block(hw))\r\ngoto out;\r\nif (hw->fc.requested_mode == e1000_fc_default) {\r\nret_val = igb_set_default_fc(hw);\r\nif (ret_val)\r\ngoto out;\r\n}\r\nhw->fc.current_mode = hw->fc.requested_mode;\r\nhw_dbg("After fix-ups FlowControl is now = %x\n", hw->fc.current_mode);\r\nret_val = hw->mac.ops.setup_physical_interface(hw);\r\nif (ret_val)\r\ngoto out;\r\nhw_dbg("Initializing the Flow Control address, type and timer regs\n");\r\nwr32(E1000_FCT, FLOW_CONTROL_TYPE);\r\nwr32(E1000_FCAH, FLOW_CONTROL_ADDRESS_HIGH);\r\nwr32(E1000_FCAL, FLOW_CONTROL_ADDRESS_LOW);\r\nwr32(E1000_FCTTV, hw->fc.pause_time);\r\nret_val = igb_set_fc_watermarks(hw);\r\nout:\r\nreturn ret_val;\r\n}\r\nvoid igb_config_collision_dist(struct e1000_hw *hw)\r\n{\r\nu32 tctl;\r\ntctl = rd32(E1000_TCTL);\r\ntctl &= ~E1000_TCTL_COLD;\r\ntctl |= E1000_COLLISION_DISTANCE << E1000_COLD_SHIFT;\r\nwr32(E1000_TCTL, tctl);\r\nwrfl();\r\n}\r\nstatic s32 igb_set_fc_watermarks(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nu32 fcrtl = 0, fcrth = 0;\r\nif (hw->fc.current_mode & e1000_fc_tx_pause) {\r\nfcrtl = hw->fc.low_water;\r\nif (hw->fc.send_xon)\r\nfcrtl |= E1000_FCRTL_XONE;\r\nfcrth = hw->fc.high_water;\r\n}\r\nwr32(E1000_FCRTL, fcrtl);\r\nwr32(E1000_FCRTH, fcrth);\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_set_default_fc(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nu16 lan_offset;\r\nu16 nvm_data;\r\nif (hw->mac.type == e1000_i350) {\r\nlan_offset = NVM_82580_LAN_FUNC_OFFSET(hw->bus.func);\r\nret_val = hw->nvm.ops.read(hw, NVM_INIT_CONTROL2_REG\r\n+ lan_offset, 1, &nvm_data);\r\n} else {\r\nret_val = hw->nvm.ops.read(hw, NVM_INIT_CONTROL2_REG,\r\n1, &nvm_data);\r\n}\r\nif (ret_val) {\r\nhw_dbg("NVM Read Error\n");\r\ngoto out;\r\n}\r\nif ((nvm_data & NVM_WORD0F_PAUSE_MASK) == 0)\r\nhw->fc.requested_mode = e1000_fc_none;\r\nelse if ((nvm_data & NVM_WORD0F_PAUSE_MASK) ==\r\nNVM_WORD0F_ASM_DIR)\r\nhw->fc.requested_mode = e1000_fc_tx_pause;\r\nelse\r\nhw->fc.requested_mode = e1000_fc_full;\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 igb_force_mac_fc(struct e1000_hw *hw)\r\n{\r\nu32 ctrl;\r\ns32 ret_val = 0;\r\nctrl = rd32(E1000_CTRL);\r\nhw_dbg("hw->fc.current_mode = %u\n", hw->fc.current_mode);\r\nswitch (hw->fc.current_mode) {\r\ncase e1000_fc_none:\r\nctrl &= (~(E1000_CTRL_TFCE | E1000_CTRL_RFCE));\r\nbreak;\r\ncase e1000_fc_rx_pause:\r\nctrl &= (~E1000_CTRL_TFCE);\r\nctrl |= E1000_CTRL_RFCE;\r\nbreak;\r\ncase e1000_fc_tx_pause:\r\nctrl &= (~E1000_CTRL_RFCE);\r\nctrl |= E1000_CTRL_TFCE;\r\nbreak;\r\ncase e1000_fc_full:\r\nctrl |= (E1000_CTRL_TFCE | E1000_CTRL_RFCE);\r\nbreak;\r\ndefault:\r\nhw_dbg("Flow control param set incorrectly\n");\r\nret_val = -E1000_ERR_CONFIG;\r\ngoto out;\r\n}\r\nwr32(E1000_CTRL, ctrl);\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 igb_config_fc_after_link_up(struct e1000_hw *hw)\r\n{\r\nstruct e1000_mac_info *mac = &hw->mac;\r\ns32 ret_val = 0;\r\nu32 pcs_status_reg, pcs_adv_reg, pcs_lp_ability_reg, pcs_ctrl_reg;\r\nu16 mii_status_reg, mii_nway_adv_reg, mii_nway_lp_ability_reg;\r\nu16 speed, duplex;\r\nif (mac->autoneg_failed) {\r\nif (hw->phy.media_type == e1000_media_type_internal_serdes)\r\nret_val = igb_force_mac_fc(hw);\r\n} else {\r\nif (hw->phy.media_type == e1000_media_type_copper)\r\nret_val = igb_force_mac_fc(hw);\r\n}\r\nif (ret_val) {\r\nhw_dbg("Error forcing flow control settings\n");\r\ngoto out;\r\n}\r\nif ((hw->phy.media_type == e1000_media_type_copper) && mac->autoneg) {\r\nret_val = hw->phy.ops.read_reg(hw, PHY_STATUS,\r\n&mii_status_reg);\r\nif (ret_val)\r\ngoto out;\r\nret_val = hw->phy.ops.read_reg(hw, PHY_STATUS,\r\n&mii_status_reg);\r\nif (ret_val)\r\ngoto out;\r\nif (!(mii_status_reg & MII_SR_AUTONEG_COMPLETE)) {\r\nhw_dbg("Copper PHY and Auto Neg "\r\n"has not completed.\n");\r\ngoto out;\r\n}\r\nret_val = hw->phy.ops.read_reg(hw, PHY_AUTONEG_ADV,\r\n&mii_nway_adv_reg);\r\nif (ret_val)\r\ngoto out;\r\nret_val = hw->phy.ops.read_reg(hw, PHY_LP_ABILITY,\r\n&mii_nway_lp_ability_reg);\r\nif (ret_val)\r\ngoto out;\r\nif ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&\r\n(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE)) {\r\nif (hw->fc.requested_mode == e1000_fc_full) {\r\nhw->fc.current_mode = e1000_fc_full;\r\nhw_dbg("Flow Control = FULL.\r\n");\r\n} else {\r\nhw->fc.current_mode = e1000_fc_rx_pause;\r\nhw_dbg("Flow Control = "\r\n"RX PAUSE frames only.\r\n");\r\n}\r\n}\r\nelse if (!(mii_nway_adv_reg & NWAY_AR_PAUSE) &&\r\n(mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&\r\n(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&\r\n(mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {\r\nhw->fc.current_mode = e1000_fc_tx_pause;\r\nhw_dbg("Flow Control = TX PAUSE frames only.\r\n");\r\n}\r\nelse if ((mii_nway_adv_reg & NWAY_AR_PAUSE) &&\r\n(mii_nway_adv_reg & NWAY_AR_ASM_DIR) &&\r\n!(mii_nway_lp_ability_reg & NWAY_LPAR_PAUSE) &&\r\n(mii_nway_lp_ability_reg & NWAY_LPAR_ASM_DIR)) {\r\nhw->fc.current_mode = e1000_fc_rx_pause;\r\nhw_dbg("Flow Control = RX PAUSE frames only.\r\n");\r\n}\r\nelse if ((hw->fc.requested_mode == e1000_fc_none) ||\r\n(hw->fc.requested_mode == e1000_fc_tx_pause) ||\r\n(hw->fc.strict_ieee)) {\r\nhw->fc.current_mode = e1000_fc_none;\r\nhw_dbg("Flow Control = NONE.\r\n");\r\n} else {\r\nhw->fc.current_mode = e1000_fc_rx_pause;\r\nhw_dbg("Flow Control = RX PAUSE frames only.\r\n");\r\n}\r\nret_val = hw->mac.ops.get_speed_and_duplex(hw, &speed, &duplex);\r\nif (ret_val) {\r\nhw_dbg("Error getting link speed and duplex\n");\r\ngoto out;\r\n}\r\nif (duplex == HALF_DUPLEX)\r\nhw->fc.current_mode = e1000_fc_none;\r\nret_val = igb_force_mac_fc(hw);\r\nif (ret_val) {\r\nhw_dbg("Error forcing flow control settings\n");\r\ngoto out;\r\n}\r\n}\r\nif ((hw->phy.media_type == e1000_media_type_internal_serdes)\r\n&& mac->autoneg) {\r\npcs_status_reg = rd32(E1000_PCS_LSTAT);\r\nif (!(pcs_status_reg & E1000_PCS_LSTS_AN_COMPLETE)) {\r\nhw_dbg("PCS Auto Neg has not completed.\n");\r\nreturn ret_val;\r\n}\r\npcs_adv_reg = rd32(E1000_PCS_ANADV);\r\npcs_lp_ability_reg = rd32(E1000_PCS_LPAB);\r\nif ((pcs_adv_reg & E1000_TXCW_PAUSE) &&\r\n(pcs_lp_ability_reg & E1000_TXCW_PAUSE)) {\r\nif (hw->fc.requested_mode == e1000_fc_full) {\r\nhw->fc.current_mode = e1000_fc_full;\r\nhw_dbg("Flow Control = FULL.\n");\r\n} else {\r\nhw->fc.current_mode = e1000_fc_rx_pause;\r\nhw_dbg("Flow Control = Rx PAUSE frames only.\n");\r\n}\r\n}\r\nelse if (!(pcs_adv_reg & E1000_TXCW_PAUSE) &&\r\n(pcs_adv_reg & E1000_TXCW_ASM_DIR) &&\r\n(pcs_lp_ability_reg & E1000_TXCW_PAUSE) &&\r\n(pcs_lp_ability_reg & E1000_TXCW_ASM_DIR)) {\r\nhw->fc.current_mode = e1000_fc_tx_pause;\r\nhw_dbg("Flow Control = Tx PAUSE frames only.\n");\r\n}\r\nelse if ((pcs_adv_reg & E1000_TXCW_PAUSE) &&\r\n(pcs_adv_reg & E1000_TXCW_ASM_DIR) &&\r\n!(pcs_lp_ability_reg & E1000_TXCW_PAUSE) &&\r\n(pcs_lp_ability_reg & E1000_TXCW_ASM_DIR)) {\r\nhw->fc.current_mode = e1000_fc_rx_pause;\r\nhw_dbg("Flow Control = Rx PAUSE frames only.\n");\r\n} else {\r\nhw->fc.current_mode = e1000_fc_none;\r\nhw_dbg("Flow Control = NONE.\n");\r\n}\r\npcs_ctrl_reg = rd32(E1000_PCS_LCTL);\r\npcs_ctrl_reg |= E1000_PCS_LCTL_FORCE_FCTRL;\r\nwr32(E1000_PCS_LCTL, pcs_ctrl_reg);\r\nret_val = igb_force_mac_fc(hw);\r\nif (ret_val) {\r\nhw_dbg("Error forcing flow control settings\n");\r\nreturn ret_val;\r\n}\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 igb_get_speed_and_duplex_copper(struct e1000_hw *hw, u16 *speed,\r\nu16 *duplex)\r\n{\r\nu32 status;\r\nstatus = rd32(E1000_STATUS);\r\nif (status & E1000_STATUS_SPEED_1000) {\r\n*speed = SPEED_1000;\r\nhw_dbg("1000 Mbs, ");\r\n} else if (status & E1000_STATUS_SPEED_100) {\r\n*speed = SPEED_100;\r\nhw_dbg("100 Mbs, ");\r\n} else {\r\n*speed = SPEED_10;\r\nhw_dbg("10 Mbs, ");\r\n}\r\nif (status & E1000_STATUS_FD) {\r\n*duplex = FULL_DUPLEX;\r\nhw_dbg("Full Duplex\n");\r\n} else {\r\n*duplex = HALF_DUPLEX;\r\nhw_dbg("Half Duplex\n");\r\n}\r\nreturn 0;\r\n}\r\ns32 igb_get_hw_semaphore(struct e1000_hw *hw)\r\n{\r\nu32 swsm;\r\ns32 ret_val = 0;\r\ns32 timeout = hw->nvm.word_size + 1;\r\ns32 i = 0;\r\nwhile (i < timeout) {\r\nswsm = rd32(E1000_SWSM);\r\nif (!(swsm & E1000_SWSM_SMBI))\r\nbreak;\r\nudelay(50);\r\ni++;\r\n}\r\nif (i == timeout) {\r\nhw_dbg("Driver can't access device - SMBI bit is set.\n");\r\nret_val = -E1000_ERR_NVM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < timeout; i++) {\r\nswsm = rd32(E1000_SWSM);\r\nwr32(E1000_SWSM, swsm | E1000_SWSM_SWESMBI);\r\nif (rd32(E1000_SWSM) & E1000_SWSM_SWESMBI)\r\nbreak;\r\nudelay(50);\r\n}\r\nif (i == timeout) {\r\nigb_put_hw_semaphore(hw);\r\nhw_dbg("Driver can't access the NVM\n");\r\nret_val = -E1000_ERR_NVM;\r\ngoto out;\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\nvoid igb_put_hw_semaphore(struct e1000_hw *hw)\r\n{\r\nu32 swsm;\r\nswsm = rd32(E1000_SWSM);\r\nswsm &= ~(E1000_SWSM_SMBI | E1000_SWSM_SWESMBI);\r\nwr32(E1000_SWSM, swsm);\r\n}\r\ns32 igb_get_auto_rd_done(struct e1000_hw *hw)\r\n{\r\ns32 i = 0;\r\ns32 ret_val = 0;\r\nwhile (i < AUTO_READ_DONE_TIMEOUT) {\r\nif (rd32(E1000_EECD) & E1000_EECD_AUTO_RD)\r\nbreak;\r\nmsleep(1);\r\ni++;\r\n}\r\nif (i == AUTO_READ_DONE_TIMEOUT) {\r\nhw_dbg("Auto read by HW from NVM has not completed.\n");\r\nret_val = -E1000_ERR_RESET;\r\ngoto out;\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_valid_led_default(struct e1000_hw *hw, u16 *data)\r\n{\r\ns32 ret_val;\r\nret_val = hw->nvm.ops.read(hw, NVM_ID_LED_SETTINGS, 1, data);\r\nif (ret_val) {\r\nhw_dbg("NVM Read Error\n");\r\ngoto out;\r\n}\r\nif (*data == ID_LED_RESERVED_0000 || *data == ID_LED_RESERVED_FFFF) {\r\nswitch(hw->phy.media_type) {\r\ncase e1000_media_type_internal_serdes:\r\n*data = ID_LED_DEFAULT_82575_SERDES;\r\nbreak;\r\ncase e1000_media_type_copper:\r\ndefault:\r\n*data = ID_LED_DEFAULT;\r\nbreak;\r\n}\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 igb_id_led_init(struct e1000_hw *hw)\r\n{\r\nstruct e1000_mac_info *mac = &hw->mac;\r\ns32 ret_val;\r\nconst u32 ledctl_mask = 0x000000FF;\r\nconst u32 ledctl_on = E1000_LEDCTL_MODE_LED_ON;\r\nconst u32 ledctl_off = E1000_LEDCTL_MODE_LED_OFF;\r\nu16 data, i, temp;\r\nconst u16 led_mask = 0x0F;\r\nif ((hw->mac.type == e1000_i210) ||\r\n(hw->mac.type == e1000_i211))\r\nret_val = igb_valid_led_default_i210(hw, &data);\r\nelse\r\nret_val = igb_valid_led_default(hw, &data);\r\nif (ret_val)\r\ngoto out;\r\nmac->ledctl_default = rd32(E1000_LEDCTL);\r\nmac->ledctl_mode1 = mac->ledctl_default;\r\nmac->ledctl_mode2 = mac->ledctl_default;\r\nfor (i = 0; i < 4; i++) {\r\ntemp = (data >> (i << 2)) & led_mask;\r\nswitch (temp) {\r\ncase ID_LED_ON1_DEF2:\r\ncase ID_LED_ON1_ON2:\r\ncase ID_LED_ON1_OFF2:\r\nmac->ledctl_mode1 &= ~(ledctl_mask << (i << 3));\r\nmac->ledctl_mode1 |= ledctl_on << (i << 3);\r\nbreak;\r\ncase ID_LED_OFF1_DEF2:\r\ncase ID_LED_OFF1_ON2:\r\ncase ID_LED_OFF1_OFF2:\r\nmac->ledctl_mode1 &= ~(ledctl_mask << (i << 3));\r\nmac->ledctl_mode1 |= ledctl_off << (i << 3);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (temp) {\r\ncase ID_LED_DEF1_ON2:\r\ncase ID_LED_ON1_ON2:\r\ncase ID_LED_OFF1_ON2:\r\nmac->ledctl_mode2 &= ~(ledctl_mask << (i << 3));\r\nmac->ledctl_mode2 |= ledctl_on << (i << 3);\r\nbreak;\r\ncase ID_LED_DEF1_OFF2:\r\ncase ID_LED_ON1_OFF2:\r\ncase ID_LED_OFF1_OFF2:\r\nmac->ledctl_mode2 &= ~(ledctl_mask << (i << 3));\r\nmac->ledctl_mode2 |= ledctl_off << (i << 3);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 igb_cleanup_led(struct e1000_hw *hw)\r\n{\r\nwr32(E1000_LEDCTL, hw->mac.ledctl_default);\r\nreturn 0;\r\n}\r\ns32 igb_blink_led(struct e1000_hw *hw)\r\n{\r\nu32 ledctl_blink = 0;\r\nu32 i;\r\nif (hw->phy.media_type == e1000_media_type_fiber) {\r\nledctl_blink = E1000_LEDCTL_LED0_BLINK |\r\n(E1000_LEDCTL_MODE_LED_ON << E1000_LEDCTL_LED0_MODE_SHIFT);\r\n} else {\r\nledctl_blink = hw->mac.ledctl_mode2;\r\nfor (i = 0; i < 32; i += 8) {\r\nu32 mode = (hw->mac.ledctl_mode2 >> i) &\r\nE1000_LEDCTL_LED0_MODE_MASK;\r\nu32 led_default = hw->mac.ledctl_default >> i;\r\nif ((!(led_default & E1000_LEDCTL_LED0_IVRT) &&\r\n(mode == E1000_LEDCTL_MODE_LED_ON)) ||\r\n((led_default & E1000_LEDCTL_LED0_IVRT) &&\r\n(mode == E1000_LEDCTL_MODE_LED_OFF))) {\r\nledctl_blink &=\r\n~(E1000_LEDCTL_LED0_MODE_MASK << i);\r\nledctl_blink |= (E1000_LEDCTL_LED0_BLINK |\r\nE1000_LEDCTL_MODE_LED_ON) << i;\r\n}\r\n}\r\n}\r\nwr32(E1000_LEDCTL, ledctl_blink);\r\nreturn 0;\r\n}\r\ns32 igb_led_off(struct e1000_hw *hw)\r\n{\r\nswitch (hw->phy.media_type) {\r\ncase e1000_media_type_copper:\r\nwr32(E1000_LEDCTL, hw->mac.ledctl_mode1);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\ns32 igb_disable_pcie_master(struct e1000_hw *hw)\r\n{\r\nu32 ctrl;\r\ns32 timeout = MASTER_DISABLE_TIMEOUT;\r\ns32 ret_val = 0;\r\nif (hw->bus.type != e1000_bus_type_pci_express)\r\ngoto out;\r\nctrl = rd32(E1000_CTRL);\r\nctrl |= E1000_CTRL_GIO_MASTER_DISABLE;\r\nwr32(E1000_CTRL, ctrl);\r\nwhile (timeout) {\r\nif (!(rd32(E1000_STATUS) &\r\nE1000_STATUS_GIO_MASTER_ENABLE))\r\nbreak;\r\nudelay(100);\r\ntimeout--;\r\n}\r\nif (!timeout) {\r\nhw_dbg("Master requests are pending.\n");\r\nret_val = -E1000_ERR_MASTER_REQUESTS_PENDING;\r\ngoto out;\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 igb_validate_mdi_setting(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nif (hw->mac.type >= e1000_82580)\r\ngoto out;\r\nif (!hw->mac.autoneg && (hw->phy.mdix == 0 || hw->phy.mdix == 3)) {\r\nhw_dbg("Invalid MDI setting detected\n");\r\nhw->phy.mdix = 1;\r\nret_val = -E1000_ERR_CONFIG;\r\ngoto out;\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 igb_write_8bit_ctrl_reg(struct e1000_hw *hw, u32 reg,\r\nu32 offset, u8 data)\r\n{\r\nu32 i, regvalue = 0;\r\ns32 ret_val = 0;\r\nregvalue = ((u32)data) | (offset << E1000_GEN_CTL_ADDRESS_SHIFT);\r\nwr32(reg, regvalue);\r\nfor (i = 0; i < E1000_GEN_POLL_TIMEOUT; i++) {\r\nudelay(5);\r\nregvalue = rd32(reg);\r\nif (regvalue & E1000_GEN_CTL_READY)\r\nbreak;\r\n}\r\nif (!(regvalue & E1000_GEN_CTL_READY)) {\r\nhw_dbg("Reg %08x did not indicate ready\n", reg);\r\nret_val = -E1000_ERR_PHY;\r\ngoto out;\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\nbool igb_enable_mng_pass_thru(struct e1000_hw *hw)\r\n{\r\nu32 manc;\r\nu32 fwsm, factps;\r\nbool ret_val = false;\r\nif (!hw->mac.asf_firmware_present)\r\ngoto out;\r\nmanc = rd32(E1000_MANC);\r\nif (!(manc & E1000_MANC_RCV_TCO_EN))\r\ngoto out;\r\nif (hw->mac.arc_subsystem_valid) {\r\nfwsm = rd32(E1000_FWSM);\r\nfactps = rd32(E1000_FACTPS);\r\nif (!(factps & E1000_FACTPS_MNGCG) &&\r\n((fwsm & E1000_FWSM_MODE_MASK) ==\r\n(e1000_mng_mode_pt << E1000_FWSM_MODE_SHIFT))) {\r\nret_val = true;\r\ngoto out;\r\n}\r\n} else {\r\nif ((manc & E1000_MANC_SMBUS_EN) &&\r\n!(manc & E1000_MANC_ASF_EN)) {\r\nret_val = true;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn ret_val;\r\n}
