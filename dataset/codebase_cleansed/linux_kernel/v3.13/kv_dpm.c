static struct kv_ps *kv_get_ps(struct radeon_ps *rps)\r\n{\r\nstruct kv_ps *ps = rps->ps_priv;\r\nreturn ps;\r\n}\r\nstatic struct kv_power_info *kv_get_pi(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = rdev->pm.dpm.priv;\r\nreturn pi;\r\n}\r\nstatic int kv_program_pt_config_registers(struct radeon_device *rdev,\r\nconst struct kv_pt_config_reg *cac_config_regs)\r\n{\r\nconst struct kv_pt_config_reg *config_regs = cac_config_regs;\r\nu32 data;\r\nu32 cache = 0;\r\nif (config_regs == NULL)\r\nreturn -EINVAL;\r\nwhile (config_regs->offset != 0xFFFFFFFF) {\r\nif (config_regs->type == KV_CONFIGREG_CACHE) {\r\ncache |= ((config_regs->value << config_regs->shift) & config_regs->mask);\r\n} else {\r\nswitch (config_regs->type) {\r\ncase KV_CONFIGREG_SMC_IND:\r\ndata = RREG32_SMC(config_regs->offset);\r\nbreak;\r\ncase KV_CONFIGREG_DIDT_IND:\r\ndata = RREG32_DIDT(config_regs->offset);\r\nbreak;\r\ndefault:\r\ndata = RREG32(config_regs->offset << 2);\r\nbreak;\r\n}\r\ndata &= ~config_regs->mask;\r\ndata |= ((config_regs->value << config_regs->shift) & config_regs->mask);\r\ndata |= cache;\r\ncache = 0;\r\nswitch (config_regs->type) {\r\ncase KV_CONFIGREG_SMC_IND:\r\nWREG32_SMC(config_regs->offset, data);\r\nbreak;\r\ncase KV_CONFIGREG_DIDT_IND:\r\nWREG32_DIDT(config_regs->offset, data);\r\nbreak;\r\ndefault:\r\nWREG32(config_regs->offset << 2, data);\r\nbreak;\r\n}\r\n}\r\nconfig_regs++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void kv_do_enable_didt(struct radeon_device *rdev, bool enable)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu32 data;\r\nif (pi->caps_sq_ramping) {\r\ndata = RREG32_DIDT(DIDT_SQ_CTRL0);\r\nif (enable)\r\ndata |= DIDT_CTRL_EN;\r\nelse\r\ndata &= ~DIDT_CTRL_EN;\r\nWREG32_DIDT(DIDT_SQ_CTRL0, data);\r\n}\r\nif (pi->caps_db_ramping) {\r\ndata = RREG32_DIDT(DIDT_DB_CTRL0);\r\nif (enable)\r\ndata |= DIDT_CTRL_EN;\r\nelse\r\ndata &= ~DIDT_CTRL_EN;\r\nWREG32_DIDT(DIDT_DB_CTRL0, data);\r\n}\r\nif (pi->caps_td_ramping) {\r\ndata = RREG32_DIDT(DIDT_TD_CTRL0);\r\nif (enable)\r\ndata |= DIDT_CTRL_EN;\r\nelse\r\ndata &= ~DIDT_CTRL_EN;\r\nWREG32_DIDT(DIDT_TD_CTRL0, data);\r\n}\r\nif (pi->caps_tcp_ramping) {\r\ndata = RREG32_DIDT(DIDT_TCP_CTRL0);\r\nif (enable)\r\ndata |= DIDT_CTRL_EN;\r\nelse\r\ndata &= ~DIDT_CTRL_EN;\r\nWREG32_DIDT(DIDT_TCP_CTRL0, data);\r\n}\r\n}\r\nstatic int kv_enable_didt(struct radeon_device *rdev, bool enable)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nint ret;\r\nif (pi->caps_sq_ramping ||\r\npi->caps_db_ramping ||\r\npi->caps_td_ramping ||\r\npi->caps_tcp_ramping) {\r\ncik_enter_rlc_safe_mode(rdev);\r\nif (enable) {\r\nret = kv_program_pt_config_registers(rdev, didt_config_kv);\r\nif (ret) {\r\ncik_exit_rlc_safe_mode(rdev);\r\nreturn ret;\r\n}\r\n}\r\nkv_do_enable_didt(rdev, enable);\r\ncik_exit_rlc_safe_mode(rdev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int kv_enable_smc_cac(struct radeon_device *rdev, bool enable)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nint ret = 0;\r\nif (pi->caps_cac) {\r\nif (enable) {\r\nret = kv_notify_message_to_smu(rdev, PPSMC_MSG_EnableCac);\r\nif (ret)\r\npi->cac_enabled = false;\r\nelse\r\npi->cac_enabled = true;\r\n} else if (pi->cac_enabled) {\r\nkv_notify_message_to_smu(rdev, PPSMC_MSG_DisableCac);\r\npi->cac_enabled = false;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int kv_process_firmware_header(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu32 tmp;\r\nint ret;\r\nret = kv_read_smc_sram_dword(rdev, SMU7_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU7_Firmware_Header, DpmTable),\r\n&tmp, pi->sram_end);\r\nif (ret == 0)\r\npi->dpm_table_start = tmp;\r\nret = kv_read_smc_sram_dword(rdev, SMU7_FIRMWARE_HEADER_LOCATION +\r\noffsetof(SMU7_Firmware_Header, SoftRegisters),\r\n&tmp, pi->sram_end);\r\nif (ret == 0)\r\npi->soft_regs_start = tmp;\r\nreturn ret;\r\n}\r\nstatic int kv_enable_dpm_voltage_scaling(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nint ret;\r\npi->graphics_voltage_change_enable = 1;\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, GraphicsVoltageChangeEnable),\r\n&pi->graphics_voltage_change_enable,\r\nsizeof(u8), pi->sram_end);\r\nreturn ret;\r\n}\r\nstatic int kv_set_dpm_interval(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nint ret;\r\npi->graphics_interval = 1;\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, GraphicsInterval),\r\n&pi->graphics_interval,\r\nsizeof(u8), pi->sram_end);\r\nreturn ret;\r\n}\r\nstatic int kv_set_dpm_boot_state(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nint ret;\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, GraphicsBootLevel),\r\n&pi->graphics_boot_level,\r\nsizeof(u8), pi->sram_end);\r\nreturn ret;\r\n}\r\nstatic void kv_program_vc(struct radeon_device *rdev)\r\n{\r\nWREG32_SMC(CG_FTV_0, 0x3FFFC100);\r\n}\r\nstatic void kv_clear_vc(struct radeon_device *rdev)\r\n{\r\nWREG32_SMC(CG_FTV_0, 0);\r\n}\r\nstatic int kv_set_divider_value(struct radeon_device *rdev,\r\nu32 index, u32 sclk)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nstruct atom_clock_dividers dividers;\r\nint ret;\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\r\nsclk, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\npi->graphics_level[index].SclkDid = (u8)dividers.post_div;\r\npi->graphics_level[index].SclkFrequency = cpu_to_be32(sclk);\r\nreturn 0;\r\n}\r\nstatic u16 kv_convert_8bit_index_to_voltage(struct radeon_device *rdev,\r\nu16 voltage)\r\n{\r\nreturn 6200 - (voltage * 25);\r\n}\r\nstatic u16 kv_convert_2bit_index_to_voltage(struct radeon_device *rdev,\r\nu32 vid_2bit)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu32 vid_8bit = sumo_convert_vid2_to_vid7(rdev,\r\n&pi->sys_info.vid_mapping_table,\r\nvid_2bit);\r\nreturn kv_convert_8bit_index_to_voltage(rdev, (u16)vid_8bit);\r\n}\r\nstatic int kv_set_vid(struct radeon_device *rdev, u32 index, u32 vid)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\npi->graphics_level[index].VoltageDownH = (u8)pi->voltage_drop_t;\r\npi->graphics_level[index].MinVddNb =\r\ncpu_to_be32(kv_convert_2bit_index_to_voltage(rdev, vid));\r\nreturn 0;\r\n}\r\nstatic int kv_set_at(struct radeon_device *rdev, u32 index, u32 at)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\npi->graphics_level[index].AT = cpu_to_be16((u16)at);\r\nreturn 0;\r\n}\r\nstatic void kv_dpm_power_level_enable(struct radeon_device *rdev,\r\nu32 index, bool enable)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\npi->graphics_level[index].EnabledForActivity = enable ? 1 : 0;\r\n}\r\nstatic void kv_start_dpm(struct radeon_device *rdev)\r\n{\r\nu32 tmp = RREG32_SMC(GENERAL_PWRMGT);\r\ntmp |= GLOBAL_PWRMGT_EN;\r\nWREG32_SMC(GENERAL_PWRMGT, tmp);\r\nkv_smc_dpm_enable(rdev, true);\r\n}\r\nstatic void kv_stop_dpm(struct radeon_device *rdev)\r\n{\r\nkv_smc_dpm_enable(rdev, false);\r\n}\r\nstatic void kv_start_am(struct radeon_device *rdev)\r\n{\r\nu32 sclk_pwrmgt_cntl = RREG32_SMC(SCLK_PWRMGT_CNTL);\r\nsclk_pwrmgt_cntl &= ~(RESET_SCLK_CNT | RESET_BUSY_CNT);\r\nsclk_pwrmgt_cntl |= DYNAMIC_PM_EN;\r\nWREG32_SMC(SCLK_PWRMGT_CNTL, sclk_pwrmgt_cntl);\r\n}\r\nstatic void kv_reset_am(struct radeon_device *rdev)\r\n{\r\nu32 sclk_pwrmgt_cntl = RREG32_SMC(SCLK_PWRMGT_CNTL);\r\nsclk_pwrmgt_cntl |= (RESET_SCLK_CNT | RESET_BUSY_CNT);\r\nWREG32_SMC(SCLK_PWRMGT_CNTL, sclk_pwrmgt_cntl);\r\n}\r\nstatic int kv_freeze_sclk_dpm(struct radeon_device *rdev, bool freeze)\r\n{\r\nreturn kv_notify_message_to_smu(rdev, freeze ?\r\nPPSMC_MSG_SCLKDPM_FreezeLevel : PPSMC_MSG_SCLKDPM_UnfreezeLevel);\r\n}\r\nstatic int kv_force_lowest_valid(struct radeon_device *rdev)\r\n{\r\nreturn kv_force_dpm_lowest(rdev);\r\n}\r\nstatic int kv_unforce_levels(struct radeon_device *rdev)\r\n{\r\nif (rdev->family == CHIP_KABINI)\r\nreturn kv_notify_message_to_smu(rdev, PPSMC_MSG_NoForcedLevel);\r\nelse\r\nreturn kv_set_enabled_levels(rdev);\r\n}\r\nstatic int kv_update_sclk_t(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu32 low_sclk_interrupt_t = 0;\r\nint ret = 0;\r\nif (pi->caps_sclk_throttle_low_notification) {\r\nlow_sclk_interrupt_t = cpu_to_be32(pi->low_sclk_interrupt_t);\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, LowSclkInterruptT),\r\n(u8 *)&low_sclk_interrupt_t,\r\nsizeof(u32), pi->sram_end);\r\n}\r\nreturn ret;\r\n}\r\nstatic int kv_program_bootup_state(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu32 i;\r\nstruct radeon_clock_voltage_dependency_table *table =\r\n&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\r\nif (table && table->count) {\r\nfor (i = pi->graphics_dpm_level_count - 1; i > 0; i--) {\r\nif (table->entries[i].clk == pi->boot_pl.sclk)\r\nbreak;\r\n}\r\npi->graphics_boot_level = (u8)i;\r\nkv_dpm_power_level_enable(rdev, i, true);\r\n} else {\r\nstruct sumo_sclk_voltage_mapping_table *table =\r\n&pi->sys_info.sclk_voltage_mapping_table;\r\nif (table->num_max_dpm_entries == 0)\r\nreturn -EINVAL;\r\nfor (i = pi->graphics_dpm_level_count - 1; i > 0; i--) {\r\nif (table->entries[i].sclk_frequency == pi->boot_pl.sclk)\r\nbreak;\r\n}\r\npi->graphics_boot_level = (u8)i;\r\nkv_dpm_power_level_enable(rdev, i, true);\r\n}\r\nreturn 0;\r\n}\r\nstatic int kv_enable_auto_thermal_throttling(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nint ret;\r\npi->graphics_therm_throttle_enable = 1;\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, GraphicsThermThrottleEnable),\r\n&pi->graphics_therm_throttle_enable,\r\nsizeof(u8), pi->sram_end);\r\nreturn ret;\r\n}\r\nstatic int kv_upload_dpm_settings(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nint ret;\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, GraphicsLevel),\r\n(u8 *)&pi->graphics_level,\r\nsizeof(SMU7_Fusion_GraphicsLevel) * SMU7_MAX_LEVELS_GRAPHICS,\r\npi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, GraphicsDpmLevelCount),\r\n&pi->graphics_dpm_level_count,\r\nsizeof(u8), pi->sram_end);\r\nreturn ret;\r\n}\r\nstatic u32 kv_get_clock_difference(u32 a, u32 b)\r\n{\r\nreturn (a >= b) ? a - b : b - a;\r\n}\r\nstatic u32 kv_get_clk_bypass(struct radeon_device *rdev, u32 clk)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu32 value;\r\nif (pi->caps_enable_dfs_bypass) {\r\nif (kv_get_clock_difference(clk, 40000) < 200)\r\nvalue = 3;\r\nelse if (kv_get_clock_difference(clk, 30000) < 200)\r\nvalue = 2;\r\nelse if (kv_get_clock_difference(clk, 20000) < 200)\r\nvalue = 7;\r\nelse if (kv_get_clock_difference(clk, 15000) < 200)\r\nvalue = 6;\r\nelse if (kv_get_clock_difference(clk, 10000) < 200)\r\nvalue = 8;\r\nelse\r\nvalue = 0;\r\n} else {\r\nvalue = 0;\r\n}\r\nreturn value;\r\n}\r\nstatic int kv_populate_uvd_table(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nstruct radeon_uvd_clock_voltage_dependency_table *table =\r\n&rdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table;\r\nstruct atom_clock_dividers dividers;\r\nint ret;\r\nu32 i;\r\nif (table == NULL || table->count == 0)\r\nreturn 0;\r\npi->uvd_level_count = 0;\r\nfor (i = 0; i < table->count; i++) {\r\nif (pi->high_voltage_t &&\r\n(pi->high_voltage_t < table->entries[i].v))\r\nbreak;\r\npi->uvd_level[i].VclkFrequency = cpu_to_be32(table->entries[i].vclk);\r\npi->uvd_level[i].DclkFrequency = cpu_to_be32(table->entries[i].dclk);\r\npi->uvd_level[i].MinVddNb = cpu_to_be16(table->entries[i].v);\r\npi->uvd_level[i].VClkBypassCntl =\r\n(u8)kv_get_clk_bypass(rdev, table->entries[i].vclk);\r\npi->uvd_level[i].DClkBypassCntl =\r\n(u8)kv_get_clk_bypass(rdev, table->entries[i].dclk);\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\r\ntable->entries[i].vclk, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\npi->uvd_level[i].VclkDivider = (u8)dividers.post_div;\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\r\ntable->entries[i].dclk, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\npi->uvd_level[i].DclkDivider = (u8)dividers.post_div;\r\npi->uvd_level_count++;\r\n}\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, UvdLevelCount),\r\n(u8 *)&pi->uvd_level_count,\r\nsizeof(u8), pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\npi->uvd_interval = 1;\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, UVDInterval),\r\n&pi->uvd_interval,\r\nsizeof(u8), pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, UvdLevel),\r\n(u8 *)&pi->uvd_level,\r\nsizeof(SMU7_Fusion_UvdLevel) * SMU7_MAX_LEVELS_UVD,\r\npi->sram_end);\r\nreturn ret;\r\n}\r\nstatic int kv_populate_vce_table(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nint ret;\r\nu32 i;\r\nstruct radeon_vce_clock_voltage_dependency_table *table =\r\n&rdev->pm.dpm.dyn_state.vce_clock_voltage_dependency_table;\r\nstruct atom_clock_dividers dividers;\r\nif (table == NULL || table->count == 0)\r\nreturn 0;\r\npi->vce_level_count = 0;\r\nfor (i = 0; i < table->count; i++) {\r\nif (pi->high_voltage_t &&\r\npi->high_voltage_t < table->entries[i].v)\r\nbreak;\r\npi->vce_level[i].Frequency = cpu_to_be32(table->entries[i].evclk);\r\npi->vce_level[i].MinVoltage = cpu_to_be16(table->entries[i].v);\r\npi->vce_level[i].ClkBypassCntl =\r\n(u8)kv_get_clk_bypass(rdev, table->entries[i].evclk);\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\r\ntable->entries[i].evclk, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\npi->vce_level[i].Divider = (u8)dividers.post_div;\r\npi->vce_level_count++;\r\n}\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, VceLevelCount),\r\n(u8 *)&pi->vce_level_count,\r\nsizeof(u8),\r\npi->sram_end);\r\nif (ret)\r\nreturn ret;\r\npi->vce_interval = 1;\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, VCEInterval),\r\n(u8 *)&pi->vce_interval,\r\nsizeof(u8),\r\npi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, VceLevel),\r\n(u8 *)&pi->vce_level,\r\nsizeof(SMU7_Fusion_ExtClkLevel) * SMU7_MAX_LEVELS_VCE,\r\npi->sram_end);\r\nreturn ret;\r\n}\r\nstatic int kv_populate_samu_table(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nstruct radeon_clock_voltage_dependency_table *table =\r\n&rdev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table;\r\nstruct atom_clock_dividers dividers;\r\nint ret;\r\nu32 i;\r\nif (table == NULL || table->count == 0)\r\nreturn 0;\r\npi->samu_level_count = 0;\r\nfor (i = 0; i < table->count; i++) {\r\nif (pi->high_voltage_t &&\r\npi->high_voltage_t < table->entries[i].v)\r\nbreak;\r\npi->samu_level[i].Frequency = cpu_to_be32(table->entries[i].clk);\r\npi->samu_level[i].MinVoltage = cpu_to_be16(table->entries[i].v);\r\npi->samu_level[i].ClkBypassCntl =\r\n(u8)kv_get_clk_bypass(rdev, table->entries[i].clk);\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\r\ntable->entries[i].clk, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\npi->samu_level[i].Divider = (u8)dividers.post_div;\r\npi->samu_level_count++;\r\n}\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, SamuLevelCount),\r\n(u8 *)&pi->samu_level_count,\r\nsizeof(u8),\r\npi->sram_end);\r\nif (ret)\r\nreturn ret;\r\npi->samu_interval = 1;\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, SAMUInterval),\r\n(u8 *)&pi->samu_interval,\r\nsizeof(u8),\r\npi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, SamuLevel),\r\n(u8 *)&pi->samu_level,\r\nsizeof(SMU7_Fusion_ExtClkLevel) * SMU7_MAX_LEVELS_SAMU,\r\npi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nstatic int kv_populate_acp_table(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nstruct radeon_clock_voltage_dependency_table *table =\r\n&rdev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table;\r\nstruct atom_clock_dividers dividers;\r\nint ret;\r\nu32 i;\r\nif (table == NULL || table->count == 0)\r\nreturn 0;\r\npi->acp_level_count = 0;\r\nfor (i = 0; i < table->count; i++) {\r\npi->acp_level[i].Frequency = cpu_to_be32(table->entries[i].clk);\r\npi->acp_level[i].MinVoltage = cpu_to_be16(table->entries[i].v);\r\nret = radeon_atom_get_clock_dividers(rdev, COMPUTE_ENGINE_PLL_PARAM,\r\ntable->entries[i].clk, false, &dividers);\r\nif (ret)\r\nreturn ret;\r\npi->acp_level[i].Divider = (u8)dividers.post_div;\r\npi->acp_level_count++;\r\n}\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, AcpLevelCount),\r\n(u8 *)&pi->acp_level_count,\r\nsizeof(u8),\r\npi->sram_end);\r\nif (ret)\r\nreturn ret;\r\npi->acp_interval = 1;\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, ACPInterval),\r\n(u8 *)&pi->acp_interval,\r\nsizeof(u8),\r\npi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, AcpLevel),\r\n(u8 *)&pi->acp_level,\r\nsizeof(SMU7_Fusion_ExtClkLevel) * SMU7_MAX_LEVELS_ACP,\r\npi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nstatic void kv_calculate_dfs_bypass_settings(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu32 i;\r\nstruct radeon_clock_voltage_dependency_table *table =\r\n&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\r\nif (table && table->count) {\r\nfor (i = 0; i < pi->graphics_dpm_level_count; i++) {\r\nif (pi->caps_enable_dfs_bypass) {\r\nif (kv_get_clock_difference(table->entries[i].clk, 40000) < 200)\r\npi->graphics_level[i].ClkBypassCntl = 3;\r\nelse if (kv_get_clock_difference(table->entries[i].clk, 30000) < 200)\r\npi->graphics_level[i].ClkBypassCntl = 2;\r\nelse if (kv_get_clock_difference(table->entries[i].clk, 26600) < 200)\r\npi->graphics_level[i].ClkBypassCntl = 7;\r\nelse if (kv_get_clock_difference(table->entries[i].clk , 20000) < 200)\r\npi->graphics_level[i].ClkBypassCntl = 6;\r\nelse if (kv_get_clock_difference(table->entries[i].clk , 10000) < 200)\r\npi->graphics_level[i].ClkBypassCntl = 8;\r\nelse\r\npi->graphics_level[i].ClkBypassCntl = 0;\r\n} else {\r\npi->graphics_level[i].ClkBypassCntl = 0;\r\n}\r\n}\r\n} else {\r\nstruct sumo_sclk_voltage_mapping_table *table =\r\n&pi->sys_info.sclk_voltage_mapping_table;\r\nfor (i = 0; i < pi->graphics_dpm_level_count; i++) {\r\nif (pi->caps_enable_dfs_bypass) {\r\nif (kv_get_clock_difference(table->entries[i].sclk_frequency, 40000) < 200)\r\npi->graphics_level[i].ClkBypassCntl = 3;\r\nelse if (kv_get_clock_difference(table->entries[i].sclk_frequency, 30000) < 200)\r\npi->graphics_level[i].ClkBypassCntl = 2;\r\nelse if (kv_get_clock_difference(table->entries[i].sclk_frequency, 26600) < 200)\r\npi->graphics_level[i].ClkBypassCntl = 7;\r\nelse if (kv_get_clock_difference(table->entries[i].sclk_frequency, 20000) < 200)\r\npi->graphics_level[i].ClkBypassCntl = 6;\r\nelse if (kv_get_clock_difference(table->entries[i].sclk_frequency, 10000) < 200)\r\npi->graphics_level[i].ClkBypassCntl = 8;\r\nelse\r\npi->graphics_level[i].ClkBypassCntl = 0;\r\n} else {\r\npi->graphics_level[i].ClkBypassCntl = 0;\r\n}\r\n}\r\n}\r\n}\r\nstatic int kv_enable_ulv(struct radeon_device *rdev, bool enable)\r\n{\r\nreturn kv_notify_message_to_smu(rdev, enable ?\r\nPPSMC_MSG_EnableULV : PPSMC_MSG_DisableULV);\r\n}\r\nstatic void kv_reset_acp_boot_level(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\npi->acp_boot_level = 0xff;\r\n}\r\nstatic void kv_update_current_ps(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct kv_ps *new_ps = kv_get_ps(rps);\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\npi->current_rps = *rps;\r\npi->current_ps = *new_ps;\r\npi->current_rps.ps_priv = &pi->current_ps;\r\n}\r\nstatic void kv_update_requested_ps(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nstruct kv_ps *new_ps = kv_get_ps(rps);\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\npi->requested_rps = *rps;\r\npi->requested_ps = *new_ps;\r\npi->requested_rps.ps_priv = &pi->requested_ps;\r\n}\r\nvoid kv_dpm_enable_bapm(struct radeon_device *rdev, bool enable)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nint ret;\r\nif (pi->bapm_enable) {\r\nret = kv_smc_bapm_enable(rdev, enable);\r\nif (ret)\r\nDRM_ERROR("kv_smc_bapm_enable failed\n");\r\n}\r\n}\r\nint kv_dpm_enable(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nint ret;\r\ncik_update_cg(rdev, (RADEON_CG_BLOCK_GFX |\r\nRADEON_CG_BLOCK_SDMA |\r\nRADEON_CG_BLOCK_BIF |\r\nRADEON_CG_BLOCK_HDP), false);\r\nret = kv_process_firmware_header(rdev);\r\nif (ret) {\r\nDRM_ERROR("kv_process_firmware_header failed\n");\r\nreturn ret;\r\n}\r\nkv_init_fps_limits(rdev);\r\nkv_init_graphics_levels(rdev);\r\nret = kv_program_bootup_state(rdev);\r\nif (ret) {\r\nDRM_ERROR("kv_program_bootup_state failed\n");\r\nreturn ret;\r\n}\r\nkv_calculate_dfs_bypass_settings(rdev);\r\nret = kv_upload_dpm_settings(rdev);\r\nif (ret) {\r\nDRM_ERROR("kv_upload_dpm_settings failed\n");\r\nreturn ret;\r\n}\r\nret = kv_populate_uvd_table(rdev);\r\nif (ret) {\r\nDRM_ERROR("kv_populate_uvd_table failed\n");\r\nreturn ret;\r\n}\r\nret = kv_populate_vce_table(rdev);\r\nif (ret) {\r\nDRM_ERROR("kv_populate_vce_table failed\n");\r\nreturn ret;\r\n}\r\nret = kv_populate_samu_table(rdev);\r\nif (ret) {\r\nDRM_ERROR("kv_populate_samu_table failed\n");\r\nreturn ret;\r\n}\r\nret = kv_populate_acp_table(rdev);\r\nif (ret) {\r\nDRM_ERROR("kv_populate_acp_table failed\n");\r\nreturn ret;\r\n}\r\nkv_program_vc(rdev);\r\n#if 0\r\nkv_initialize_hardware_cac_manager(rdev);\r\n#endif\r\nkv_start_am(rdev);\r\nif (pi->enable_auto_thermal_throttling) {\r\nret = kv_enable_auto_thermal_throttling(rdev);\r\nif (ret) {\r\nDRM_ERROR("kv_enable_auto_thermal_throttling failed\n");\r\nreturn ret;\r\n}\r\n}\r\nret = kv_enable_dpm_voltage_scaling(rdev);\r\nif (ret) {\r\nDRM_ERROR("kv_enable_dpm_voltage_scaling failed\n");\r\nreturn ret;\r\n}\r\nret = kv_set_dpm_interval(rdev);\r\nif (ret) {\r\nDRM_ERROR("kv_set_dpm_interval failed\n");\r\nreturn ret;\r\n}\r\nret = kv_set_dpm_boot_state(rdev);\r\nif (ret) {\r\nDRM_ERROR("kv_set_dpm_boot_state failed\n");\r\nreturn ret;\r\n}\r\nret = kv_enable_ulv(rdev, true);\r\nif (ret) {\r\nDRM_ERROR("kv_enable_ulv failed\n");\r\nreturn ret;\r\n}\r\nkv_start_dpm(rdev);\r\nret = kv_enable_didt(rdev, true);\r\nif (ret) {\r\nDRM_ERROR("kv_enable_didt failed\n");\r\nreturn ret;\r\n}\r\nret = kv_enable_smc_cac(rdev, true);\r\nif (ret) {\r\nDRM_ERROR("kv_enable_smc_cac failed\n");\r\nreturn ret;\r\n}\r\nkv_reset_acp_boot_level(rdev);\r\nif (rdev->irq.installed &&\r\nr600_is_internal_thermal_sensor(rdev->pm.int_thermal_type)) {\r\nret = kv_set_thermal_temperature_range(rdev, R600_TEMP_RANGE_MIN, R600_TEMP_RANGE_MAX);\r\nif (ret) {\r\nDRM_ERROR("kv_set_thermal_temperature_range failed\n");\r\nreturn ret;\r\n}\r\nrdev->irq.dpm_thermal = true;\r\nradeon_irq_set(rdev);\r\n}\r\nret = kv_smc_bapm_enable(rdev, false);\r\nif (ret) {\r\nDRM_ERROR("kv_smc_bapm_enable failed\n");\r\nreturn ret;\r\n}\r\nkv_dpm_powergate_acp(rdev, true);\r\nkv_dpm_powergate_samu(rdev, true);\r\nkv_dpm_powergate_vce(rdev, true);\r\nkv_dpm_powergate_uvd(rdev, true);\r\ncik_update_cg(rdev, (RADEON_CG_BLOCK_GFX |\r\nRADEON_CG_BLOCK_SDMA |\r\nRADEON_CG_BLOCK_BIF |\r\nRADEON_CG_BLOCK_HDP), true);\r\nkv_update_current_ps(rdev, rdev->pm.dpm.boot_ps);\r\nreturn ret;\r\n}\r\nvoid kv_dpm_disable(struct radeon_device *rdev)\r\n{\r\ncik_update_cg(rdev, (RADEON_CG_BLOCK_GFX |\r\nRADEON_CG_BLOCK_SDMA |\r\nRADEON_CG_BLOCK_BIF |\r\nRADEON_CG_BLOCK_HDP), false);\r\nkv_smc_bapm_enable(rdev, false);\r\nkv_dpm_powergate_acp(rdev, false);\r\nkv_dpm_powergate_samu(rdev, false);\r\nkv_dpm_powergate_vce(rdev, false);\r\nkv_dpm_powergate_uvd(rdev, false);\r\nkv_enable_smc_cac(rdev, false);\r\nkv_enable_didt(rdev, false);\r\nkv_clear_vc(rdev);\r\nkv_stop_dpm(rdev);\r\nkv_enable_ulv(rdev, false);\r\nkv_reset_am(rdev);\r\nkv_update_current_ps(rdev, rdev->pm.dpm.boot_ps);\r\n}\r\nstatic void kv_init_sclk_t(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\npi->low_sclk_interrupt_t = 0;\r\n}\r\nstatic int kv_init_fps_limits(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nint ret = 0;\r\nif (pi->caps_fps) {\r\nu16 tmp;\r\ntmp = 45;\r\npi->fps_high_t = cpu_to_be16(tmp);\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, FpsHighT),\r\n(u8 *)&pi->fps_high_t,\r\nsizeof(u16), pi->sram_end);\r\ntmp = 30;\r\npi->fps_low_t = cpu_to_be16(tmp);\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, FpsLowT),\r\n(u8 *)&pi->fps_low_t,\r\nsizeof(u16), pi->sram_end);\r\n}\r\nreturn ret;\r\n}\r\nstatic void kv_init_powergate_state(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\npi->uvd_power_gated = false;\r\npi->vce_power_gated = false;\r\npi->samu_power_gated = false;\r\npi->acp_power_gated = false;\r\n}\r\nstatic int kv_enable_uvd_dpm(struct radeon_device *rdev, bool enable)\r\n{\r\nreturn kv_notify_message_to_smu(rdev, enable ?\r\nPPSMC_MSG_UVDDPM_Enable : PPSMC_MSG_UVDDPM_Disable);\r\n}\r\nstatic int kv_enable_samu_dpm(struct radeon_device *rdev, bool enable)\r\n{\r\nreturn kv_notify_message_to_smu(rdev, enable ?\r\nPPSMC_MSG_SAMUDPM_Enable : PPSMC_MSG_SAMUDPM_Disable);\r\n}\r\nstatic int kv_enable_acp_dpm(struct radeon_device *rdev, bool enable)\r\n{\r\nreturn kv_notify_message_to_smu(rdev, enable ?\r\nPPSMC_MSG_ACPDPM_Enable : PPSMC_MSG_ACPDPM_Disable);\r\n}\r\nstatic int kv_update_uvd_dpm(struct radeon_device *rdev, bool gate)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nstruct radeon_uvd_clock_voltage_dependency_table *table =\r\n&rdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table;\r\nint ret;\r\nif (!gate) {\r\nif (!pi->caps_uvd_dpm || table->count || pi->caps_stable_p_state)\r\npi->uvd_boot_level = table->count - 1;\r\nelse\r\npi->uvd_boot_level = 0;\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, UvdBootLevel),\r\n(uint8_t *)&pi->uvd_boot_level,\r\nsizeof(u8), pi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nif (!pi->caps_uvd_dpm ||\r\npi->caps_stable_p_state)\r\nkv_send_msg_to_smc_with_parameter(rdev,\r\nPPSMC_MSG_UVDDPM_SetEnabledMask,\r\n(1 << pi->uvd_boot_level));\r\n}\r\nreturn kv_enable_uvd_dpm(rdev, !gate);\r\n}\r\nstatic int kv_update_samu_dpm(struct radeon_device *rdev, bool gate)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nstruct radeon_clock_voltage_dependency_table *table =\r\n&rdev->pm.dpm.dyn_state.samu_clock_voltage_dependency_table;\r\nint ret;\r\nif (!gate) {\r\nif (pi->caps_stable_p_state)\r\npi->samu_boot_level = table->count - 1;\r\nelse\r\npi->samu_boot_level = 0;\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, SamuBootLevel),\r\n(u8 *)&pi->samu_boot_level,\r\nsizeof(u8),\r\npi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nif (pi->caps_stable_p_state)\r\nkv_send_msg_to_smc_with_parameter(rdev,\r\nPPSMC_MSG_SAMUDPM_SetEnabledMask,\r\n(1 << pi->samu_boot_level));\r\n}\r\nreturn kv_enable_samu_dpm(rdev, !gate);\r\n}\r\nstatic u8 kv_get_acp_boot_level(struct radeon_device *rdev)\r\n{\r\nu8 i;\r\nstruct radeon_clock_voltage_dependency_table *table =\r\n&rdev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table;\r\nfor (i = 0; i < table->count; i++) {\r\nif (table->entries[i].clk >= 0)\r\nbreak;\r\n}\r\nif (i >= table->count)\r\ni = table->count - 1;\r\nreturn i;\r\n}\r\nstatic void kv_update_acp_boot_level(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu8 acp_boot_level;\r\nif (!pi->caps_stable_p_state) {\r\nacp_boot_level = kv_get_acp_boot_level(rdev);\r\nif (acp_boot_level != pi->acp_boot_level) {\r\npi->acp_boot_level = acp_boot_level;\r\nkv_send_msg_to_smc_with_parameter(rdev,\r\nPPSMC_MSG_ACPDPM_SetEnabledMask,\r\n(1 << pi->acp_boot_level));\r\n}\r\n}\r\n}\r\nstatic int kv_update_acp_dpm(struct radeon_device *rdev, bool gate)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nstruct radeon_clock_voltage_dependency_table *table =\r\n&rdev->pm.dpm.dyn_state.acp_clock_voltage_dependency_table;\r\nint ret;\r\nif (!gate) {\r\nif (pi->caps_stable_p_state)\r\npi->acp_boot_level = table->count - 1;\r\nelse\r\npi->acp_boot_level = kv_get_acp_boot_level(rdev);\r\nret = kv_copy_bytes_to_smc(rdev,\r\npi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, AcpBootLevel),\r\n(u8 *)&pi->acp_boot_level,\r\nsizeof(u8),\r\npi->sram_end);\r\nif (ret)\r\nreturn ret;\r\nif (pi->caps_stable_p_state)\r\nkv_send_msg_to_smc_with_parameter(rdev,\r\nPPSMC_MSG_ACPDPM_SetEnabledMask,\r\n(1 << pi->acp_boot_level));\r\n}\r\nreturn kv_enable_acp_dpm(rdev, !gate);\r\n}\r\nvoid kv_dpm_powergate_uvd(struct radeon_device *rdev, bool gate)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nif (pi->uvd_power_gated == gate)\r\nreturn;\r\npi->uvd_power_gated = gate;\r\nif (gate) {\r\nif (pi->caps_uvd_pg) {\r\nuvd_v1_0_stop(rdev);\r\ncik_update_cg(rdev, RADEON_CG_BLOCK_UVD, false);\r\n}\r\nkv_update_uvd_dpm(rdev, gate);\r\nif (pi->caps_uvd_pg)\r\nkv_notify_message_to_smu(rdev, PPSMC_MSG_UVDPowerOFF);\r\n} else {\r\nif (pi->caps_uvd_pg) {\r\nkv_notify_message_to_smu(rdev, PPSMC_MSG_UVDPowerON);\r\nuvd_v4_2_resume(rdev);\r\nuvd_v1_0_start(rdev);\r\ncik_update_cg(rdev, RADEON_CG_BLOCK_UVD, true);\r\n}\r\nkv_update_uvd_dpm(rdev, gate);\r\n}\r\n}\r\nstatic void kv_dpm_powergate_vce(struct radeon_device *rdev, bool gate)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nif (pi->vce_power_gated == gate)\r\nreturn;\r\npi->vce_power_gated = gate;\r\nif (gate) {\r\nif (pi->caps_vce_pg)\r\nkv_notify_message_to_smu(rdev, PPSMC_MSG_VCEPowerOFF);\r\n} else {\r\nif (pi->caps_vce_pg)\r\nkv_notify_message_to_smu(rdev, PPSMC_MSG_VCEPowerON);\r\n}\r\n}\r\nstatic void kv_dpm_powergate_samu(struct radeon_device *rdev, bool gate)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nif (pi->samu_power_gated == gate)\r\nreturn;\r\npi->samu_power_gated = gate;\r\nif (gate) {\r\nkv_update_samu_dpm(rdev, true);\r\nif (pi->caps_samu_pg)\r\nkv_notify_message_to_smu(rdev, PPSMC_MSG_SAMPowerOFF);\r\n} else {\r\nif (pi->caps_samu_pg)\r\nkv_notify_message_to_smu(rdev, PPSMC_MSG_SAMPowerON);\r\nkv_update_samu_dpm(rdev, false);\r\n}\r\n}\r\nstatic void kv_dpm_powergate_acp(struct radeon_device *rdev, bool gate)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nif (pi->acp_power_gated == gate)\r\nreturn;\r\nif (rdev->family == CHIP_KABINI)\r\nreturn;\r\npi->acp_power_gated = gate;\r\nif (gate) {\r\nkv_update_acp_dpm(rdev, true);\r\nif (pi->caps_acp_pg)\r\nkv_notify_message_to_smu(rdev, PPSMC_MSG_ACPPowerOFF);\r\n} else {\r\nif (pi->caps_acp_pg)\r\nkv_notify_message_to_smu(rdev, PPSMC_MSG_ACPPowerON);\r\nkv_update_acp_dpm(rdev, false);\r\n}\r\n}\r\nstatic void kv_set_valid_clock_range(struct radeon_device *rdev,\r\nstruct radeon_ps *new_rps)\r\n{\r\nstruct kv_ps *new_ps = kv_get_ps(new_rps);\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu32 i;\r\nstruct radeon_clock_voltage_dependency_table *table =\r\n&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\r\nif (table && table->count) {\r\nfor (i = 0; i < pi->graphics_dpm_level_count; i++) {\r\nif ((table->entries[i].clk >= new_ps->levels[0].sclk) ||\r\n(i == (pi->graphics_dpm_level_count - 1))) {\r\npi->lowest_valid = i;\r\nbreak;\r\n}\r\n}\r\nfor (i = pi->graphics_dpm_level_count - 1; i > 0; i--) {\r\nif (table->entries[i].clk <= new_ps->levels[new_ps->num_levels - 1].sclk)\r\nbreak;\r\n}\r\npi->highest_valid = i;\r\nif (pi->lowest_valid > pi->highest_valid) {\r\nif ((new_ps->levels[0].sclk - table->entries[pi->highest_valid].clk) >\r\n(table->entries[pi->lowest_valid].clk - new_ps->levels[new_ps->num_levels - 1].sclk))\r\npi->highest_valid = pi->lowest_valid;\r\nelse\r\npi->lowest_valid = pi->highest_valid;\r\n}\r\n} else {\r\nstruct sumo_sclk_voltage_mapping_table *table =\r\n&pi->sys_info.sclk_voltage_mapping_table;\r\nfor (i = 0; i < (int)pi->graphics_dpm_level_count; i++) {\r\nif (table->entries[i].sclk_frequency >= new_ps->levels[0].sclk ||\r\ni == (int)(pi->graphics_dpm_level_count - 1)) {\r\npi->lowest_valid = i;\r\nbreak;\r\n}\r\n}\r\nfor (i = pi->graphics_dpm_level_count - 1; i > 0; i--) {\r\nif (table->entries[i].sclk_frequency <=\r\nnew_ps->levels[new_ps->num_levels - 1].sclk)\r\nbreak;\r\n}\r\npi->highest_valid = i;\r\nif (pi->lowest_valid > pi->highest_valid) {\r\nif ((new_ps->levels[0].sclk -\r\ntable->entries[pi->highest_valid].sclk_frequency) >\r\n(table->entries[pi->lowest_valid].sclk_frequency -\r\nnew_ps->levels[new_ps->num_levels -1].sclk))\r\npi->highest_valid = pi->lowest_valid;\r\nelse\r\npi->lowest_valid = pi->highest_valid;\r\n}\r\n}\r\n}\r\nstatic int kv_update_dfs_bypass_settings(struct radeon_device *rdev,\r\nstruct radeon_ps *new_rps)\r\n{\r\nstruct kv_ps *new_ps = kv_get_ps(new_rps);\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nint ret = 0;\r\nu8 clk_bypass_cntl;\r\nif (pi->caps_enable_dfs_bypass) {\r\nclk_bypass_cntl = new_ps->need_dfs_bypass ?\r\npi->graphics_level[pi->graphics_boot_level].ClkBypassCntl : 0;\r\nret = kv_copy_bytes_to_smc(rdev,\r\n(pi->dpm_table_start +\r\noffsetof(SMU7_Fusion_DpmTable, GraphicsLevel) +\r\n(pi->graphics_boot_level * sizeof(SMU7_Fusion_GraphicsLevel)) +\r\noffsetof(SMU7_Fusion_GraphicsLevel, ClkBypassCntl)),\r\n&clk_bypass_cntl,\r\nsizeof(u8), pi->sram_end);\r\n}\r\nreturn ret;\r\n}\r\nstatic int kv_enable_nb_dpm(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nint ret = 0;\r\nif (pi->enable_nb_dpm && !pi->nb_dpm_enabled) {\r\nret = kv_notify_message_to_smu(rdev, PPSMC_MSG_NBDPM_Enable);\r\nif (ret == 0)\r\npi->nb_dpm_enabled = true;\r\n}\r\nreturn ret;\r\n}\r\nint kv_dpm_force_performance_level(struct radeon_device *rdev,\r\nenum radeon_dpm_forced_level level)\r\n{\r\nint ret;\r\nif (level == RADEON_DPM_FORCED_LEVEL_HIGH) {\r\nret = kv_force_dpm_highest(rdev);\r\nif (ret)\r\nreturn ret;\r\n} else if (level == RADEON_DPM_FORCED_LEVEL_LOW) {\r\nret = kv_force_dpm_lowest(rdev);\r\nif (ret)\r\nreturn ret;\r\n} else if (level == RADEON_DPM_FORCED_LEVEL_AUTO) {\r\nret = kv_unforce_levels(rdev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nrdev->pm.dpm.forced_level = level;\r\nreturn 0;\r\n}\r\nint kv_dpm_pre_set_power_state(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nstruct radeon_ps requested_ps = *rdev->pm.dpm.requested_ps;\r\nstruct radeon_ps *new_ps = &requested_ps;\r\nkv_update_requested_ps(rdev, new_ps);\r\nkv_apply_state_adjust_rules(rdev,\r\n&pi->requested_rps,\r\n&pi->current_rps);\r\nreturn 0;\r\n}\r\nint kv_dpm_set_power_state(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nstruct radeon_ps *new_ps = &pi->requested_rps;\r\nint ret;\r\ncik_update_cg(rdev, (RADEON_CG_BLOCK_GFX |\r\nRADEON_CG_BLOCK_SDMA |\r\nRADEON_CG_BLOCK_BIF |\r\nRADEON_CG_BLOCK_HDP), false);\r\nif (pi->bapm_enable) {\r\nret = kv_smc_bapm_enable(rdev, rdev->pm.dpm.ac_power);\r\nif (ret) {\r\nDRM_ERROR("kv_smc_bapm_enable failed\n");\r\nreturn ret;\r\n}\r\n}\r\nif (rdev->family == CHIP_KABINI) {\r\nif (pi->enable_dpm) {\r\nkv_set_valid_clock_range(rdev, new_ps);\r\nkv_update_dfs_bypass_settings(rdev, new_ps);\r\nret = kv_calculate_ds_divider(rdev);\r\nif (ret) {\r\nDRM_ERROR("kv_calculate_ds_divider failed\n");\r\nreturn ret;\r\n}\r\nkv_calculate_nbps_level_settings(rdev);\r\nkv_calculate_dpm_settings(rdev);\r\nkv_force_lowest_valid(rdev);\r\nkv_enable_new_levels(rdev);\r\nkv_upload_dpm_settings(rdev);\r\nkv_program_nbps_index_settings(rdev, new_ps);\r\nkv_unforce_levels(rdev);\r\nkv_set_enabled_levels(rdev);\r\nkv_force_lowest_valid(rdev);\r\nkv_unforce_levels(rdev);\r\n#if 0\r\nret = kv_update_vce_dpm(rdev, new_ps, old_ps);\r\nif (ret) {\r\nDRM_ERROR("kv_update_vce_dpm failed\n");\r\nreturn ret;\r\n}\r\n#endif\r\nkv_update_sclk_t(rdev);\r\n}\r\n} else {\r\nif (pi->enable_dpm) {\r\nkv_set_valid_clock_range(rdev, new_ps);\r\nkv_update_dfs_bypass_settings(rdev, new_ps);\r\nret = kv_calculate_ds_divider(rdev);\r\nif (ret) {\r\nDRM_ERROR("kv_calculate_ds_divider failed\n");\r\nreturn ret;\r\n}\r\nkv_calculate_nbps_level_settings(rdev);\r\nkv_calculate_dpm_settings(rdev);\r\nkv_freeze_sclk_dpm(rdev, true);\r\nkv_upload_dpm_settings(rdev);\r\nkv_program_nbps_index_settings(rdev, new_ps);\r\nkv_freeze_sclk_dpm(rdev, false);\r\nkv_set_enabled_levels(rdev);\r\n#if 0\r\nret = kv_update_vce_dpm(rdev, new_ps, old_ps);\r\nif (ret) {\r\nDRM_ERROR("kv_update_vce_dpm failed\n");\r\nreturn ret;\r\n}\r\n#endif\r\nkv_update_acp_boot_level(rdev);\r\nkv_update_sclk_t(rdev);\r\nkv_enable_nb_dpm(rdev);\r\n}\r\n}\r\ncik_update_cg(rdev, (RADEON_CG_BLOCK_GFX |\r\nRADEON_CG_BLOCK_SDMA |\r\nRADEON_CG_BLOCK_BIF |\r\nRADEON_CG_BLOCK_HDP), true);\r\nreturn 0;\r\n}\r\nvoid kv_dpm_post_set_power_state(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nstruct radeon_ps *new_ps = &pi->requested_rps;\r\nkv_update_current_ps(rdev, new_ps);\r\n}\r\nvoid kv_dpm_setup_asic(struct radeon_device *rdev)\r\n{\r\nsumo_take_smu_control(rdev, true);\r\nkv_init_powergate_state(rdev);\r\nkv_init_sclk_t(rdev);\r\n}\r\nvoid kv_dpm_reset_asic(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nif (rdev->family == CHIP_KABINI) {\r\nkv_force_lowest_valid(rdev);\r\nkv_init_graphics_levels(rdev);\r\nkv_program_bootup_state(rdev);\r\nkv_upload_dpm_settings(rdev);\r\nkv_force_lowest_valid(rdev);\r\nkv_unforce_levels(rdev);\r\n} else {\r\nkv_init_graphics_levels(rdev);\r\nkv_program_bootup_state(rdev);\r\nkv_freeze_sclk_dpm(rdev, true);\r\nkv_upload_dpm_settings(rdev);\r\nkv_freeze_sclk_dpm(rdev, false);\r\nkv_set_enabled_level(rdev, pi->graphics_boot_level);\r\n}\r\n}\r\nstatic void kv_construct_max_power_limits_table(struct radeon_device *rdev,\r\nstruct radeon_clock_and_voltage_limits *table)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nif (pi->sys_info.sclk_voltage_mapping_table.num_max_dpm_entries > 0) {\r\nint idx = pi->sys_info.sclk_voltage_mapping_table.num_max_dpm_entries - 1;\r\ntable->sclk =\r\npi->sys_info.sclk_voltage_mapping_table.entries[idx].sclk_frequency;\r\ntable->vddc =\r\nkv_convert_2bit_index_to_voltage(rdev,\r\npi->sys_info.sclk_voltage_mapping_table.entries[idx].vid_2bit);\r\n}\r\ntable->mclk = pi->sys_info.nbp_memory_clock[0];\r\n}\r\nstatic void kv_patch_voltage_values(struct radeon_device *rdev)\r\n{\r\nint i;\r\nstruct radeon_uvd_clock_voltage_dependency_table *table =\r\n&rdev->pm.dpm.dyn_state.uvd_clock_voltage_dependency_table;\r\nif (table->count) {\r\nfor (i = 0; i < table->count; i++)\r\ntable->entries[i].v =\r\nkv_convert_8bit_index_to_voltage(rdev,\r\ntable->entries[i].v);\r\n}\r\n}\r\nstatic void kv_construct_boot_state(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\npi->boot_pl.sclk = pi->sys_info.bootup_sclk;\r\npi->boot_pl.vddc_index = pi->sys_info.bootup_nb_voltage_index;\r\npi->boot_pl.ds_divider_index = 0;\r\npi->boot_pl.ss_divider_index = 0;\r\npi->boot_pl.allow_gnb_slow = 1;\r\npi->boot_pl.force_nbp_state = 0;\r\npi->boot_pl.display_wm = 0;\r\npi->boot_pl.vce_wm = 0;\r\n}\r\nstatic int kv_force_dpm_highest(struct radeon_device *rdev)\r\n{\r\nint ret;\r\nu32 enable_mask, i;\r\nret = kv_dpm_get_enable_mask(rdev, &enable_mask);\r\nif (ret)\r\nreturn ret;\r\nfor (i = SMU7_MAX_LEVELS_GRAPHICS - 1; i > 0; i--) {\r\nif (enable_mask & (1 << i))\r\nbreak;\r\n}\r\nif (rdev->family == CHIP_KABINI)\r\nreturn kv_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_DPM_ForceState, i);\r\nelse\r\nreturn kv_set_enabled_level(rdev, i);\r\n}\r\nstatic int kv_force_dpm_lowest(struct radeon_device *rdev)\r\n{\r\nint ret;\r\nu32 enable_mask, i;\r\nret = kv_dpm_get_enable_mask(rdev, &enable_mask);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < SMU7_MAX_LEVELS_GRAPHICS; i++) {\r\nif (enable_mask & (1 << i))\r\nbreak;\r\n}\r\nif (rdev->family == CHIP_KABINI)\r\nreturn kv_send_msg_to_smc_with_parameter(rdev, PPSMC_MSG_DPM_ForceState, i);\r\nelse\r\nreturn kv_set_enabled_level(rdev, i);\r\n}\r\nstatic u8 kv_get_sleep_divider_id_from_clock(struct radeon_device *rdev,\r\nu32 sclk, u32 min_sclk_in_sr)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu32 i;\r\nu32 temp;\r\nu32 min = (min_sclk_in_sr > KV_MINIMUM_ENGINE_CLOCK) ?\r\nmin_sclk_in_sr : KV_MINIMUM_ENGINE_CLOCK;\r\nif (sclk < min)\r\nreturn 0;\r\nif (!pi->caps_sclk_ds)\r\nreturn 0;\r\nfor (i = KV_MAX_DEEPSLEEP_DIVIDER_ID; i > 0; i--) {\r\ntemp = sclk / sumo_get_sleep_divider_from_id(i);\r\nif (temp >= min)\r\nbreak;\r\n}\r\nreturn (u8)i;\r\n}\r\nstatic int kv_get_high_voltage_limit(struct radeon_device *rdev, int *limit)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nstruct radeon_clock_voltage_dependency_table *table =\r\n&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\r\nint i;\r\nif (table && table->count) {\r\nfor (i = table->count - 1; i >= 0; i--) {\r\nif (pi->high_voltage_t &&\r\n(kv_convert_8bit_index_to_voltage(rdev, table->entries[i].v) <=\r\npi->high_voltage_t)) {\r\n*limit = i;\r\nreturn 0;\r\n}\r\n}\r\n} else {\r\nstruct sumo_sclk_voltage_mapping_table *table =\r\n&pi->sys_info.sclk_voltage_mapping_table;\r\nfor (i = table->num_max_dpm_entries - 1; i >= 0; i--) {\r\nif (pi->high_voltage_t &&\r\n(kv_convert_2bit_index_to_voltage(rdev, table->entries[i].vid_2bit) <=\r\npi->high_voltage_t)) {\r\n*limit = i;\r\nreturn 0;\r\n}\r\n}\r\n}\r\n*limit = 0;\r\nreturn 0;\r\n}\r\nstatic void kv_apply_state_adjust_rules(struct radeon_device *rdev,\r\nstruct radeon_ps *new_rps,\r\nstruct radeon_ps *old_rps)\r\n{\r\nstruct kv_ps *ps = kv_get_ps(new_rps);\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu32 min_sclk = 10000;\r\nu32 sclk, mclk = 0;\r\nint i, limit;\r\nbool force_high;\r\nstruct radeon_clock_voltage_dependency_table *table =\r\n&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\r\nu32 stable_p_state_sclk = 0;\r\nstruct radeon_clock_and_voltage_limits *max_limits =\r\n&rdev->pm.dpm.dyn_state.max_clock_voltage_on_ac;\r\nmclk = max_limits->mclk;\r\nsclk = min_sclk;\r\nif (pi->caps_stable_p_state) {\r\nstable_p_state_sclk = (max_limits->sclk * 75) / 100;\r\nfor (i = table->count - 1; i >= 0; i++) {\r\nif (stable_p_state_sclk >= table->entries[i].clk) {\r\nstable_p_state_sclk = table->entries[i].clk;\r\nbreak;\r\n}\r\n}\r\nif (i > 0)\r\nstable_p_state_sclk = table->entries[0].clk;\r\nsclk = stable_p_state_sclk;\r\n}\r\nps->need_dfs_bypass = true;\r\nfor (i = 0; i < ps->num_levels; i++) {\r\nif (ps->levels[i].sclk < sclk)\r\nps->levels[i].sclk = sclk;\r\n}\r\nif (table && table->count) {\r\nfor (i = 0; i < ps->num_levels; i++) {\r\nif (pi->high_voltage_t &&\r\n(pi->high_voltage_t <\r\nkv_convert_8bit_index_to_voltage(rdev, ps->levels[i].vddc_index))) {\r\nkv_get_high_voltage_limit(rdev, &limit);\r\nps->levels[i].sclk = table->entries[limit].clk;\r\n}\r\n}\r\n} else {\r\nstruct sumo_sclk_voltage_mapping_table *table =\r\n&pi->sys_info.sclk_voltage_mapping_table;\r\nfor (i = 0; i < ps->num_levels; i++) {\r\nif (pi->high_voltage_t &&\r\n(pi->high_voltage_t <\r\nkv_convert_8bit_index_to_voltage(rdev, ps->levels[i].vddc_index))) {\r\nkv_get_high_voltage_limit(rdev, &limit);\r\nps->levels[i].sclk = table->entries[limit].sclk_frequency;\r\n}\r\n}\r\n}\r\nif (pi->caps_stable_p_state) {\r\nfor (i = 0; i < ps->num_levels; i++) {\r\nps->levels[i].sclk = stable_p_state_sclk;\r\n}\r\n}\r\npi->video_start = new_rps->dclk || new_rps->vclk;\r\nif ((new_rps->class & ATOM_PPLIB_CLASSIFICATION_UI_MASK) ==\r\nATOM_PPLIB_CLASSIFICATION_UI_BATTERY)\r\npi->battery_state = true;\r\nelse\r\npi->battery_state = false;\r\nif (rdev->family == CHIP_KABINI) {\r\nps->dpm0_pg_nb_ps_lo = 0x1;\r\nps->dpm0_pg_nb_ps_hi = 0x0;\r\nps->dpmx_nb_ps_lo = 0x1;\r\nps->dpmx_nb_ps_hi = 0x0;\r\n} else {\r\nps->dpm0_pg_nb_ps_lo = 0x3;\r\nps->dpm0_pg_nb_ps_hi = 0x0;\r\nps->dpmx_nb_ps_lo = 0x3;\r\nps->dpmx_nb_ps_hi = 0x0;\r\nif (pi->sys_info.nb_dpm_enable) {\r\nforce_high = (mclk >= pi->sys_info.nbp_memory_clock[3]) ||\r\npi->video_start || (rdev->pm.dpm.new_active_crtc_count >= 3) ||\r\npi->disable_nb_ps3_in_battery;\r\nps->dpm0_pg_nb_ps_lo = force_high ? 0x2 : 0x3;\r\nps->dpm0_pg_nb_ps_hi = 0x2;\r\nps->dpmx_nb_ps_lo = force_high ? 0x2 : 0x3;\r\nps->dpmx_nb_ps_hi = 0x2;\r\n}\r\n}\r\n}\r\nstatic void kv_dpm_power_level_enabled_for_throttle(struct radeon_device *rdev,\r\nu32 index, bool enable)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\npi->graphics_level[index].EnabledForThrottle = enable ? 1 : 0;\r\n}\r\nstatic int kv_calculate_ds_divider(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu32 sclk_in_sr = 10000;\r\nu32 i;\r\nif (pi->lowest_valid > pi->highest_valid)\r\nreturn -EINVAL;\r\nfor (i = pi->lowest_valid; i <= pi->highest_valid; i++) {\r\npi->graphics_level[i].DeepSleepDivId =\r\nkv_get_sleep_divider_id_from_clock(rdev,\r\nbe32_to_cpu(pi->graphics_level[i].SclkFrequency),\r\nsclk_in_sr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int kv_calculate_nbps_level_settings(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu32 i;\r\nbool force_high;\r\nstruct radeon_clock_and_voltage_limits *max_limits =\r\n&rdev->pm.dpm.dyn_state.max_clock_voltage_on_ac;\r\nu32 mclk = max_limits->mclk;\r\nif (pi->lowest_valid > pi->highest_valid)\r\nreturn -EINVAL;\r\nif (rdev->family == CHIP_KABINI) {\r\nfor (i = pi->lowest_valid; i <= pi->highest_valid; i++) {\r\npi->graphics_level[i].GnbSlow = 1;\r\npi->graphics_level[i].ForceNbPs1 = 0;\r\npi->graphics_level[i].UpH = 0;\r\n}\r\nif (!pi->sys_info.nb_dpm_enable)\r\nreturn 0;\r\nforce_high = ((mclk >= pi->sys_info.nbp_memory_clock[3]) ||\r\n(rdev->pm.dpm.new_active_crtc_count >= 3) || pi->video_start);\r\nif (force_high) {\r\nfor (i = pi->lowest_valid; i <= pi->highest_valid; i++)\r\npi->graphics_level[i].GnbSlow = 0;\r\n} else {\r\nif (pi->battery_state)\r\npi->graphics_level[0].ForceNbPs1 = 1;\r\npi->graphics_level[1].GnbSlow = 0;\r\npi->graphics_level[2].GnbSlow = 0;\r\npi->graphics_level[3].GnbSlow = 0;\r\npi->graphics_level[4].GnbSlow = 0;\r\n}\r\n} else {\r\nfor (i = pi->lowest_valid; i <= pi->highest_valid; i++) {\r\npi->graphics_level[i].GnbSlow = 1;\r\npi->graphics_level[i].ForceNbPs1 = 0;\r\npi->graphics_level[i].UpH = 0;\r\n}\r\nif (pi->sys_info.nb_dpm_enable && pi->battery_state) {\r\npi->graphics_level[pi->lowest_valid].UpH = 0x28;\r\npi->graphics_level[pi->lowest_valid].GnbSlow = 0;\r\nif (pi->lowest_valid != pi->highest_valid)\r\npi->graphics_level[pi->lowest_valid].ForceNbPs1 = 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int kv_calculate_dpm_settings(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu32 i;\r\nif (pi->lowest_valid > pi->highest_valid)\r\nreturn -EINVAL;\r\nfor (i = pi->lowest_valid; i <= pi->highest_valid; i++)\r\npi->graphics_level[i].DisplayWatermark = (i == pi->highest_valid) ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic void kv_init_graphics_levels(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu32 i;\r\nstruct radeon_clock_voltage_dependency_table *table =\r\n&rdev->pm.dpm.dyn_state.vddc_dependency_on_sclk;\r\nif (table && table->count) {\r\nu32 vid_2bit;\r\npi->graphics_dpm_level_count = 0;\r\nfor (i = 0; i < table->count; i++) {\r\nif (pi->high_voltage_t &&\r\n(pi->high_voltage_t <\r\nkv_convert_8bit_index_to_voltage(rdev, table->entries[i].v)))\r\nbreak;\r\nkv_set_divider_value(rdev, i, table->entries[i].clk);\r\nvid_2bit = sumo_convert_vid7_to_vid2(rdev,\r\n&pi->sys_info.vid_mapping_table,\r\ntable->entries[i].v);\r\nkv_set_vid(rdev, i, vid_2bit);\r\nkv_set_at(rdev, i, pi->at[i]);\r\nkv_dpm_power_level_enabled_for_throttle(rdev, i, true);\r\npi->graphics_dpm_level_count++;\r\n}\r\n} else {\r\nstruct sumo_sclk_voltage_mapping_table *table =\r\n&pi->sys_info.sclk_voltage_mapping_table;\r\npi->graphics_dpm_level_count = 0;\r\nfor (i = 0; i < table->num_max_dpm_entries; i++) {\r\nif (pi->high_voltage_t &&\r\npi->high_voltage_t <\r\nkv_convert_2bit_index_to_voltage(rdev, table->entries[i].vid_2bit))\r\nbreak;\r\nkv_set_divider_value(rdev, i, table->entries[i].sclk_frequency);\r\nkv_set_vid(rdev, i, table->entries[i].vid_2bit);\r\nkv_set_at(rdev, i, pi->at[i]);\r\nkv_dpm_power_level_enabled_for_throttle(rdev, i, true);\r\npi->graphics_dpm_level_count++;\r\n}\r\n}\r\nfor (i = 0; i < SMU7_MAX_LEVELS_GRAPHICS; i++)\r\nkv_dpm_power_level_enable(rdev, i, false);\r\n}\r\nstatic void kv_enable_new_levels(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu32 i;\r\nfor (i = 0; i < SMU7_MAX_LEVELS_GRAPHICS; i++) {\r\nif (i >= pi->lowest_valid && i <= pi->highest_valid)\r\nkv_dpm_power_level_enable(rdev, i, true);\r\n}\r\n}\r\nstatic int kv_set_enabled_level(struct radeon_device *rdev, u32 level)\r\n{\r\nu32 new_mask = (1 << level);\r\nreturn kv_send_msg_to_smc_with_parameter(rdev,\r\nPPSMC_MSG_SCLKDPM_SetEnabledMask,\r\nnew_mask);\r\n}\r\nstatic int kv_set_enabled_levels(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu32 i, new_mask = 0;\r\nfor (i = pi->lowest_valid; i <= pi->highest_valid; i++)\r\nnew_mask |= (1 << i);\r\nreturn kv_send_msg_to_smc_with_parameter(rdev,\r\nPPSMC_MSG_SCLKDPM_SetEnabledMask,\r\nnew_mask);\r\n}\r\nstatic void kv_program_nbps_index_settings(struct radeon_device *rdev,\r\nstruct radeon_ps *new_rps)\r\n{\r\nstruct kv_ps *new_ps = kv_get_ps(new_rps);\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu32 nbdpmconfig1;\r\nif (rdev->family == CHIP_KABINI)\r\nreturn;\r\nif (pi->sys_info.nb_dpm_enable) {\r\nnbdpmconfig1 = RREG32_SMC(NB_DPM_CONFIG_1);\r\nnbdpmconfig1 &= ~(Dpm0PgNbPsLo_MASK | Dpm0PgNbPsHi_MASK |\r\nDpmXNbPsLo_MASK | DpmXNbPsHi_MASK);\r\nnbdpmconfig1 |= (Dpm0PgNbPsLo(new_ps->dpm0_pg_nb_ps_lo) |\r\nDpm0PgNbPsHi(new_ps->dpm0_pg_nb_ps_hi) |\r\nDpmXNbPsLo(new_ps->dpmx_nb_ps_lo) |\r\nDpmXNbPsHi(new_ps->dpmx_nb_ps_hi));\r\nWREG32_SMC(NB_DPM_CONFIG_1, nbdpmconfig1);\r\n}\r\n}\r\nstatic int kv_set_thermal_temperature_range(struct radeon_device *rdev,\r\nint min_temp, int max_temp)\r\n{\r\nint low_temp = 0 * 1000;\r\nint high_temp = 255 * 1000;\r\nu32 tmp;\r\nif (low_temp < min_temp)\r\nlow_temp = min_temp;\r\nif (high_temp > max_temp)\r\nhigh_temp = max_temp;\r\nif (high_temp < low_temp) {\r\nDRM_ERROR("invalid thermal range: %d - %d\n", low_temp, high_temp);\r\nreturn -EINVAL;\r\n}\r\ntmp = RREG32_SMC(CG_THERMAL_INT_CTRL);\r\ntmp &= ~(DIG_THERM_INTH_MASK | DIG_THERM_INTL_MASK);\r\ntmp |= (DIG_THERM_INTH(49 + (high_temp / 1000)) |\r\nDIG_THERM_INTL(49 + (low_temp / 1000)));\r\nWREG32_SMC(CG_THERMAL_INT_CTRL, tmp);\r\nrdev->pm.dpm.thermal.min_temp = low_temp;\r\nrdev->pm.dpm.thermal.max_temp = high_temp;\r\nreturn 0;\r\n}\r\nstatic int kv_parse_sys_info_table(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nint index = GetIndexIntoMasterTable(DATA, IntegratedSystemInfo);\r\nunion igp_info *igp_info;\r\nu8 frev, crev;\r\nu16 data_offset;\r\nint i;\r\nif (atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset)) {\r\nigp_info = (union igp_info *)(mode_info->atom_context->bios +\r\ndata_offset);\r\nif (crev != 8) {\r\nDRM_ERROR("Unsupported IGP table: %d %d\n", frev, crev);\r\nreturn -EINVAL;\r\n}\r\npi->sys_info.bootup_sclk = le32_to_cpu(igp_info->info_8.ulBootUpEngineClock);\r\npi->sys_info.bootup_uma_clk = le32_to_cpu(igp_info->info_8.ulBootUpUMAClock);\r\npi->sys_info.bootup_nb_voltage_index =\r\nle16_to_cpu(igp_info->info_8.usBootUpNBVoltage);\r\nif (igp_info->info_8.ucHtcTmpLmt == 0)\r\npi->sys_info.htc_tmp_lmt = 203;\r\nelse\r\npi->sys_info.htc_tmp_lmt = igp_info->info_8.ucHtcTmpLmt;\r\nif (igp_info->info_8.ucHtcHystLmt == 0)\r\npi->sys_info.htc_hyst_lmt = 5;\r\nelse\r\npi->sys_info.htc_hyst_lmt = igp_info->info_8.ucHtcHystLmt;\r\nif (pi->sys_info.htc_tmp_lmt <= pi->sys_info.htc_hyst_lmt) {\r\nDRM_ERROR("The htcTmpLmt should be larger than htcHystLmt.\n");\r\n}\r\nif (le32_to_cpu(igp_info->info_8.ulSystemConfig) & (1 << 3))\r\npi->sys_info.nb_dpm_enable = true;\r\nelse\r\npi->sys_info.nb_dpm_enable = false;\r\nfor (i = 0; i < KV_NUM_NBPSTATES; i++) {\r\npi->sys_info.nbp_memory_clock[i] =\r\nle32_to_cpu(igp_info->info_8.ulNbpStateMemclkFreq[i]);\r\npi->sys_info.nbp_n_clock[i] =\r\nle32_to_cpu(igp_info->info_8.ulNbpStateNClkFreq[i]);\r\n}\r\nif (le32_to_cpu(igp_info->info_8.ulGPUCapInfo) &\r\nSYS_INFO_GPUCAPS__ENABEL_DFS_BYPASS)\r\npi->caps_enable_dfs_bypass = true;\r\nsumo_construct_sclk_voltage_mapping_table(rdev,\r\n&pi->sys_info.sclk_voltage_mapping_table,\r\nigp_info->info_8.sAvail_SCLK);\r\nsumo_construct_vid_mapping_table(rdev,\r\n&pi->sys_info.vid_mapping_table,\r\nigp_info->info_8.sAvail_SCLK);\r\nkv_construct_max_power_limits_table(rdev,\r\n&rdev->pm.dpm.dyn_state.max_clock_voltage_on_ac);\r\n}\r\nreturn 0;\r\n}\r\nstatic void kv_patch_boot_state(struct radeon_device *rdev,\r\nstruct kv_ps *ps)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nps->num_levels = 1;\r\nps->levels[0] = pi->boot_pl;\r\n}\r\nstatic void kv_parse_pplib_non_clock_info(struct radeon_device *rdev,\r\nstruct radeon_ps *rps,\r\nstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info,\r\nu8 table_rev)\r\n{\r\nstruct kv_ps *ps = kv_get_ps(rps);\r\nrps->caps = le32_to_cpu(non_clock_info->ulCapsAndSettings);\r\nrps->class = le16_to_cpu(non_clock_info->usClassification);\r\nrps->class2 = le16_to_cpu(non_clock_info->usClassification2);\r\nif (ATOM_PPLIB_NONCLOCKINFO_VER1 < table_rev) {\r\nrps->vclk = le32_to_cpu(non_clock_info->ulVCLK);\r\nrps->dclk = le32_to_cpu(non_clock_info->ulDCLK);\r\n} else {\r\nrps->vclk = 0;\r\nrps->dclk = 0;\r\n}\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_BOOT) {\r\nrdev->pm.dpm.boot_ps = rps;\r\nkv_patch_boot_state(rdev, ps);\r\n}\r\nif (rps->class & ATOM_PPLIB_CLASSIFICATION_UVDSTATE)\r\nrdev->pm.dpm.uvd_ps = rps;\r\n}\r\nstatic void kv_parse_pplib_clock_info(struct radeon_device *rdev,\r\nstruct radeon_ps *rps, int index,\r\nunion pplib_clock_info *clock_info)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nstruct kv_ps *ps = kv_get_ps(rps);\r\nstruct kv_pl *pl = &ps->levels[index];\r\nu32 sclk;\r\nsclk = le16_to_cpu(clock_info->sumo.usEngineClockLow);\r\nsclk |= clock_info->sumo.ucEngineClockHigh << 16;\r\npl->sclk = sclk;\r\npl->vddc_index = clock_info->sumo.vddcIndex;\r\nps->num_levels = index + 1;\r\nif (pi->caps_sclk_ds) {\r\npl->ds_divider_index = 5;\r\npl->ss_divider_index = 5;\r\n}\r\n}\r\nstatic int kv_parse_power_table(struct radeon_device *rdev)\r\n{\r\nstruct radeon_mode_info *mode_info = &rdev->mode_info;\r\nstruct _ATOM_PPLIB_NONCLOCK_INFO *non_clock_info;\r\nunion pplib_power_state *power_state;\r\nint i, j, k, non_clock_array_index, clock_array_index;\r\nunion pplib_clock_info *clock_info;\r\nstruct _StateArray *state_array;\r\nstruct _ClockInfoArray *clock_info_array;\r\nstruct _NonClockInfoArray *non_clock_info_array;\r\nunion power_info *power_info;\r\nint index = GetIndexIntoMasterTable(DATA, PowerPlayInfo);\r\nu16 data_offset;\r\nu8 frev, crev;\r\nu8 *power_state_offset;\r\nstruct kv_ps *ps;\r\nif (!atom_parse_data_header(mode_info->atom_context, index, NULL,\r\n&frev, &crev, &data_offset))\r\nreturn -EINVAL;\r\npower_info = (union power_info *)(mode_info->atom_context->bios + data_offset);\r\nstate_array = (struct _StateArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usStateArrayOffset));\r\nclock_info_array = (struct _ClockInfoArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usClockInfoArrayOffset));\r\nnon_clock_info_array = (struct _NonClockInfoArray *)\r\n(mode_info->atom_context->bios + data_offset +\r\nle16_to_cpu(power_info->pplib.usNonClockInfoArrayOffset));\r\nrdev->pm.dpm.ps = kzalloc(sizeof(struct radeon_ps) *\r\nstate_array->ucNumEntries, GFP_KERNEL);\r\nif (!rdev->pm.dpm.ps)\r\nreturn -ENOMEM;\r\npower_state_offset = (u8 *)state_array->states;\r\nrdev->pm.dpm.platform_caps = le32_to_cpu(power_info->pplib.ulPlatformCaps);\r\nrdev->pm.dpm.backbias_response_time = le16_to_cpu(power_info->pplib.usBackbiasTime);\r\nrdev->pm.dpm.voltage_response_time = le16_to_cpu(power_info->pplib.usVoltageTime);\r\nfor (i = 0; i < state_array->ucNumEntries; i++) {\r\nu8 *idx;\r\npower_state = (union pplib_power_state *)power_state_offset;\r\nnon_clock_array_index = power_state->v2.nonClockInfoIndex;\r\nnon_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)\r\n&non_clock_info_array->nonClockInfo[non_clock_array_index];\r\nif (!rdev->pm.power_state[i].clock_info)\r\nreturn -EINVAL;\r\nps = kzalloc(sizeof(struct kv_ps), GFP_KERNEL);\r\nif (ps == NULL) {\r\nkfree(rdev->pm.dpm.ps);\r\nreturn -ENOMEM;\r\n}\r\nrdev->pm.dpm.ps[i].ps_priv = ps;\r\nk = 0;\r\nidx = (u8 *)&power_state->v2.clockInfoIndex[0];\r\nfor (j = 0; j < power_state->v2.ucNumDPMLevels; j++) {\r\nclock_array_index = idx[j];\r\nif (clock_array_index >= clock_info_array->ucNumEntries)\r\ncontinue;\r\nif (k >= SUMO_MAX_HARDWARE_POWERLEVELS)\r\nbreak;\r\nclock_info = (union pplib_clock_info *)\r\n((u8 *)&clock_info_array->clockInfo[0] +\r\n(clock_array_index * clock_info_array->ucEntrySize));\r\nkv_parse_pplib_clock_info(rdev,\r\n&rdev->pm.dpm.ps[i], k,\r\nclock_info);\r\nk++;\r\n}\r\nkv_parse_pplib_non_clock_info(rdev, &rdev->pm.dpm.ps[i],\r\nnon_clock_info,\r\nnon_clock_info_array->ucEntrySize);\r\npower_state_offset += 2 + power_state->v2.ucNumDPMLevels;\r\n}\r\nrdev->pm.dpm.num_ps = state_array->ucNumEntries;\r\nreturn 0;\r\n}\r\nint kv_dpm_init(struct radeon_device *rdev)\r\n{\r\nstruct kv_power_info *pi;\r\nint ret, i;\r\npi = kzalloc(sizeof(struct kv_power_info), GFP_KERNEL);\r\nif (pi == NULL)\r\nreturn -ENOMEM;\r\nrdev->pm.dpm.priv = pi;\r\nret = r600_parse_extended_power_table(rdev);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < SUMO_MAX_HARDWARE_POWERLEVELS; i++)\r\npi->at[i] = TRINITY_AT_DFLT;\r\npi->sram_end = SMC_RAM_END;\r\nif (rdev->family == CHIP_KABINI)\r\npi->high_voltage_t = 4001;\r\npi->enable_nb_dpm = true;\r\npi->caps_power_containment = true;\r\npi->caps_cac = true;\r\npi->enable_didt = false;\r\nif (pi->enable_didt) {\r\npi->caps_sq_ramping = true;\r\npi->caps_db_ramping = true;\r\npi->caps_td_ramping = true;\r\npi->caps_tcp_ramping = true;\r\n}\r\npi->caps_sclk_ds = true;\r\npi->enable_auto_thermal_throttling = true;\r\npi->disable_nb_ps3_in_battery = false;\r\npi->bapm_enable = false;\r\npi->voltage_drop_t = 0;\r\npi->caps_sclk_throttle_low_notification = false;\r\npi->caps_fps = false;\r\npi->caps_uvd_pg = true;\r\npi->caps_uvd_dpm = true;\r\npi->caps_vce_pg = false;\r\npi->caps_samu_pg = false;\r\npi->caps_acp_pg = false;\r\npi->caps_stable_p_state = false;\r\nret = kv_parse_sys_info_table(rdev);\r\nif (ret)\r\nreturn ret;\r\nkv_patch_voltage_values(rdev);\r\nkv_construct_boot_state(rdev);\r\nret = kv_parse_power_table(rdev);\r\nif (ret)\r\nreturn ret;\r\npi->enable_dpm = true;\r\nreturn 0;\r\n}\r\nvoid kv_dpm_debugfs_print_current_performance_level(struct radeon_device *rdev,\r\nstruct seq_file *m)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nu32 current_index =\r\n(RREG32_SMC(TARGET_AND_CURRENT_PROFILE_INDEX) & CURR_SCLK_INDEX_MASK) >>\r\nCURR_SCLK_INDEX_SHIFT;\r\nu32 sclk, tmp;\r\nu16 vddc;\r\nif (current_index >= SMU__NUM_SCLK_DPM_STATE) {\r\nseq_printf(m, "invalid dpm profile %d\n", current_index);\r\n} else {\r\nsclk = be32_to_cpu(pi->graphics_level[current_index].SclkFrequency);\r\ntmp = (RREG32_SMC(SMU_VOLTAGE_STATUS) & SMU_VOLTAGE_CURRENT_LEVEL_MASK) >>\r\nSMU_VOLTAGE_CURRENT_LEVEL_SHIFT;\r\nvddc = kv_convert_8bit_index_to_voltage(rdev, (u16)tmp);\r\nseq_printf(m, "power level %d sclk: %u vddc: %u\n",\r\ncurrent_index, sclk, vddc);\r\n}\r\n}\r\nvoid kv_dpm_print_power_state(struct radeon_device *rdev,\r\nstruct radeon_ps *rps)\r\n{\r\nint i;\r\nstruct kv_ps *ps = kv_get_ps(rps);\r\nr600_dpm_print_class_info(rps->class, rps->class2);\r\nr600_dpm_print_cap_info(rps->caps);\r\nprintk("\tuvd vclk: %d dclk: %d\n", rps->vclk, rps->dclk);\r\nfor (i = 0; i < ps->num_levels; i++) {\r\nstruct kv_pl *pl = &ps->levels[i];\r\nprintk("\t\tpower level %d sclk: %u vddc: %u\n",\r\ni, pl->sclk,\r\nkv_convert_8bit_index_to_voltage(rdev, pl->vddc_index));\r\n}\r\nr600_dpm_print_ps_status(rdev, rps);\r\n}\r\nvoid kv_dpm_fini(struct radeon_device *rdev)\r\n{\r\nint i;\r\nfor (i = 0; i < rdev->pm.dpm.num_ps; i++) {\r\nkfree(rdev->pm.dpm.ps[i].ps_priv);\r\n}\r\nkfree(rdev->pm.dpm.ps);\r\nkfree(rdev->pm.dpm.priv);\r\nr600_free_extended_power_table(rdev);\r\n}\r\nvoid kv_dpm_display_configuration_changed(struct radeon_device *rdev)\r\n{\r\n}\r\nu32 kv_dpm_get_sclk(struct radeon_device *rdev, bool low)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nstruct kv_ps *requested_state = kv_get_ps(&pi->requested_rps);\r\nif (low)\r\nreturn requested_state->levels[0].sclk;\r\nelse\r\nreturn requested_state->levels[requested_state->num_levels - 1].sclk;\r\n}\r\nu32 kv_dpm_get_mclk(struct radeon_device *rdev, bool low)\r\n{\r\nstruct kv_power_info *pi = kv_get_pi(rdev);\r\nreturn pi->sys_info.bootup_uma_clk;\r\n}
