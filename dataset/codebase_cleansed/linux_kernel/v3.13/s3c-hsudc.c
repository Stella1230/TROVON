static inline struct s3c_hsudc_req *our_req(struct usb_request *req)\r\n{\r\nreturn container_of(req, struct s3c_hsudc_req, req);\r\n}\r\nstatic inline struct s3c_hsudc_ep *our_ep(struct usb_ep *ep)\r\n{\r\nreturn container_of(ep, struct s3c_hsudc_ep, ep);\r\n}\r\nstatic inline struct s3c_hsudc *to_hsudc(struct usb_gadget *gadget)\r\n{\r\nreturn container_of(gadget, struct s3c_hsudc, gadget);\r\n}\r\nstatic inline void set_index(struct s3c_hsudc *hsudc, int ep_addr)\r\n{\r\nep_addr &= USB_ENDPOINT_NUMBER_MASK;\r\nwritel(ep_addr, hsudc->regs + S3C_IR);\r\n}\r\nstatic inline void __orr32(void __iomem *ptr, u32 val)\r\n{\r\nwritel(readl(ptr) | val, ptr);\r\n}\r\nstatic void s3c_hsudc_init_phy(void)\r\n{\r\nu32 cfg;\r\ncfg = readl(S3C2443_PWRCFG) | S3C2443_PWRCFG_USBPHY;\r\nwritel(cfg, S3C2443_PWRCFG);\r\ncfg = readl(S3C2443_URSTCON);\r\ncfg |= (S3C2443_URSTCON_FUNCRST | S3C2443_URSTCON_PHYRST);\r\nwritel(cfg, S3C2443_URSTCON);\r\nmdelay(1);\r\ncfg = readl(S3C2443_URSTCON);\r\ncfg &= ~(S3C2443_URSTCON_FUNCRST | S3C2443_URSTCON_PHYRST);\r\nwritel(cfg, S3C2443_URSTCON);\r\ncfg = readl(S3C2443_PHYCTRL);\r\ncfg &= ~(S3C2443_PHYCTRL_CLKSEL | S3C2443_PHYCTRL_DSPORT);\r\ncfg |= (S3C2443_PHYCTRL_EXTCLK | S3C2443_PHYCTRL_PLLSEL);\r\nwritel(cfg, S3C2443_PHYCTRL);\r\ncfg = readl(S3C2443_PHYPWR);\r\ncfg &= ~(S3C2443_PHYPWR_FSUSPEND | S3C2443_PHYPWR_PLL_PWRDN |\r\nS3C2443_PHYPWR_XO_ON | S3C2443_PHYPWR_PLL_REFCLK |\r\nS3C2443_PHYPWR_ANALOG_PD);\r\ncfg |= S3C2443_PHYPWR_COMMON_ON;\r\nwritel(cfg, S3C2443_PHYPWR);\r\ncfg = readl(S3C2443_UCLKCON);\r\ncfg |= (S3C2443_UCLKCON_DETECT_VBUS | S3C2443_UCLKCON_FUNC_CLKEN |\r\nS3C2443_UCLKCON_TCLKEN);\r\nwritel(cfg, S3C2443_UCLKCON);\r\n}\r\nstatic void s3c_hsudc_uninit_phy(void)\r\n{\r\nu32 cfg;\r\ncfg = readl(S3C2443_PWRCFG) & ~S3C2443_PWRCFG_USBPHY;\r\nwritel(cfg, S3C2443_PWRCFG);\r\nwritel(S3C2443_PHYPWR_FSUSPEND, S3C2443_PHYPWR);\r\ncfg = readl(S3C2443_UCLKCON) & ~S3C2443_UCLKCON_FUNC_CLKEN;\r\nwritel(cfg, S3C2443_UCLKCON);\r\n}\r\nstatic void s3c_hsudc_complete_request(struct s3c_hsudc_ep *hsep,\r\nstruct s3c_hsudc_req *hsreq, int status)\r\n{\r\nunsigned int stopped = hsep->stopped;\r\nstruct s3c_hsudc *hsudc = hsep->dev;\r\nlist_del_init(&hsreq->queue);\r\nhsreq->req.status = status;\r\nif (!ep_index(hsep)) {\r\nhsudc->ep0state = WAIT_FOR_SETUP;\r\nhsep->bEndpointAddress &= ~USB_DIR_IN;\r\n}\r\nhsep->stopped = 1;\r\nspin_unlock(&hsudc->lock);\r\nif (hsreq->req.complete != NULL)\r\nhsreq->req.complete(&hsep->ep, &hsreq->req);\r\nspin_lock(&hsudc->lock);\r\nhsep->stopped = stopped;\r\n}\r\nstatic void s3c_hsudc_nuke_ep(struct s3c_hsudc_ep *hsep, int status)\r\n{\r\nstruct s3c_hsudc_req *hsreq;\r\nwhile (!list_empty(&hsep->queue)) {\r\nhsreq = list_entry(hsep->queue.next,\r\nstruct s3c_hsudc_req, queue);\r\ns3c_hsudc_complete_request(hsep, hsreq, status);\r\n}\r\n}\r\nstatic void s3c_hsudc_stop_activity(struct s3c_hsudc *hsudc)\r\n{\r\nstruct s3c_hsudc_ep *hsep;\r\nint epnum;\r\nhsudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nfor (epnum = 0; epnum < hsudc->pd->epnum; epnum++) {\r\nhsep = &hsudc->ep[epnum];\r\nhsep->stopped = 1;\r\ns3c_hsudc_nuke_ep(hsep, -ESHUTDOWN);\r\n}\r\n}\r\nstatic void s3c_hsudc_read_setup_pkt(struct s3c_hsudc *hsudc, u16 *buf)\r\n{\r\nint count;\r\ncount = readl(hsudc->regs + S3C_BRCR);\r\nwhile (count--)\r\n*buf++ = (u16)readl(hsudc->regs + S3C_BR(0));\r\nwritel(S3C_EP0SR_RX_SUCCESS, hsudc->regs + S3C_EP0SR);\r\n}\r\nstatic int s3c_hsudc_write_fifo(struct s3c_hsudc_ep *hsep,\r\nstruct s3c_hsudc_req *hsreq)\r\n{\r\nu16 *buf;\r\nu32 max = ep_maxpacket(hsep);\r\nu32 count, length;\r\nbool is_last;\r\nvoid __iomem *fifo = hsep->fifo;\r\nbuf = hsreq->req.buf + hsreq->req.actual;\r\nprefetch(buf);\r\nlength = hsreq->req.length - hsreq->req.actual;\r\nlength = min(length, max);\r\nhsreq->req.actual += length;\r\nwritel(length, hsep->dev->regs + S3C_BWCR);\r\nfor (count = 0; count < length; count += 2)\r\nwritel(*buf++, fifo);\r\nif (count != max) {\r\nis_last = true;\r\n} else {\r\nif (hsreq->req.length != hsreq->req.actual || hsreq->req.zero)\r\nis_last = false;\r\nelse\r\nis_last = true;\r\n}\r\nif (is_last) {\r\ns3c_hsudc_complete_request(hsep, hsreq, 0);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3c_hsudc_read_fifo(struct s3c_hsudc_ep *hsep,\r\nstruct s3c_hsudc_req *hsreq)\r\n{\r\nstruct s3c_hsudc *hsudc = hsep->dev;\r\nu32 csr, offset;\r\nu16 *buf, word;\r\nu32 buflen, rcnt, rlen;\r\nvoid __iomem *fifo = hsep->fifo;\r\nu32 is_short = 0;\r\noffset = (ep_index(hsep)) ? S3C_ESR : S3C_EP0SR;\r\ncsr = readl(hsudc->regs + offset);\r\nif (!(csr & S3C_ESR_RX_SUCCESS))\r\nreturn -EINVAL;\r\nbuf = hsreq->req.buf + hsreq->req.actual;\r\nprefetchw(buf);\r\nbuflen = hsreq->req.length - hsreq->req.actual;\r\nrcnt = readl(hsudc->regs + S3C_BRCR);\r\nrlen = (csr & S3C_ESR_LWO) ? (rcnt * 2 - 1) : (rcnt * 2);\r\nhsreq->req.actual += min(rlen, buflen);\r\nis_short = (rlen < hsep->ep.maxpacket);\r\nwhile (rcnt-- != 0) {\r\nword = (u16)readl(fifo);\r\nif (buflen) {\r\n*buf++ = word;\r\nbuflen--;\r\n} else {\r\nhsreq->req.status = -EOVERFLOW;\r\n}\r\n}\r\nwritel(S3C_ESR_RX_SUCCESS, hsudc->regs + offset);\r\nif (is_short || hsreq->req.actual == hsreq->req.length) {\r\ns3c_hsudc_complete_request(hsep, hsreq, 0);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void s3c_hsudc_epin_intr(struct s3c_hsudc *hsudc, u32 ep_idx)\r\n{\r\nstruct s3c_hsudc_ep *hsep = &hsudc->ep[ep_idx];\r\nstruct s3c_hsudc_req *hsreq;\r\nu32 csr;\r\ncsr = readl(hsudc->regs + S3C_ESR);\r\nif (csr & S3C_ESR_STALL) {\r\nwritel(S3C_ESR_STALL, hsudc->regs + S3C_ESR);\r\nreturn;\r\n}\r\nif (csr & S3C_ESR_TX_SUCCESS) {\r\nwritel(S3C_ESR_TX_SUCCESS, hsudc->regs + S3C_ESR);\r\nif (list_empty(&hsep->queue))\r\nreturn;\r\nhsreq = list_entry(hsep->queue.next,\r\nstruct s3c_hsudc_req, queue);\r\nif ((s3c_hsudc_write_fifo(hsep, hsreq) == 0) &&\r\n(csr & S3C_ESR_PSIF_TWO))\r\ns3c_hsudc_write_fifo(hsep, hsreq);\r\n}\r\n}\r\nstatic void s3c_hsudc_epout_intr(struct s3c_hsudc *hsudc, u32 ep_idx)\r\n{\r\nstruct s3c_hsudc_ep *hsep = &hsudc->ep[ep_idx];\r\nstruct s3c_hsudc_req *hsreq;\r\nu32 csr;\r\ncsr = readl(hsudc->regs + S3C_ESR);\r\nif (csr & S3C_ESR_STALL) {\r\nwritel(S3C_ESR_STALL, hsudc->regs + S3C_ESR);\r\nreturn;\r\n}\r\nif (csr & S3C_ESR_FLUSH) {\r\n__orr32(hsudc->regs + S3C_ECR, S3C_ECR_FLUSH);\r\nreturn;\r\n}\r\nif (csr & S3C_ESR_RX_SUCCESS) {\r\nif (list_empty(&hsep->queue))\r\nreturn;\r\nhsreq = list_entry(hsep->queue.next,\r\nstruct s3c_hsudc_req, queue);\r\nif (((s3c_hsudc_read_fifo(hsep, hsreq)) == 0) &&\r\n(csr & S3C_ESR_PSIF_TWO))\r\ns3c_hsudc_read_fifo(hsep, hsreq);\r\n}\r\n}\r\nstatic int s3c_hsudc_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nstruct s3c_hsudc_ep *hsep = our_ep(_ep);\r\nstruct s3c_hsudc *hsudc = hsep->dev;\r\nstruct s3c_hsudc_req *hsreq;\r\nunsigned long irqflags;\r\nu32 ecr;\r\nu32 offset;\r\nif (value && ep_is_in(hsep) && !list_empty(&hsep->queue))\r\nreturn -EAGAIN;\r\nspin_lock_irqsave(&hsudc->lock, irqflags);\r\nset_index(hsudc, ep_index(hsep));\r\noffset = (ep_index(hsep)) ? S3C_ECR : S3C_EP0CR;\r\necr = readl(hsudc->regs + offset);\r\nif (value) {\r\necr |= S3C_ECR_STALL;\r\nif (ep_index(hsep))\r\necr |= S3C_ECR_FLUSH;\r\nhsep->stopped = 1;\r\n} else {\r\necr &= ~S3C_ECR_STALL;\r\nhsep->stopped = hsep->wedge = 0;\r\n}\r\nwritel(ecr, hsudc->regs + offset);\r\nif (ep_is_in(hsep) && !list_empty(&hsep->queue) && !value) {\r\nhsreq = list_entry(hsep->queue.next,\r\nstruct s3c_hsudc_req, queue);\r\nif (hsreq)\r\ns3c_hsudc_write_fifo(hsep, hsreq);\r\n}\r\nspin_unlock_irqrestore(&hsudc->lock, irqflags);\r\nreturn 0;\r\n}\r\nstatic int s3c_hsudc_set_wedge(struct usb_ep *_ep)\r\n{\r\nstruct s3c_hsudc_ep *hsep = our_ep(_ep);\r\nif (!hsep)\r\nreturn -EINVAL;\r\nhsep->wedge = 1;\r\nreturn usb_ep_set_halt(_ep);\r\n}\r\nstatic int s3c_hsudc_handle_reqfeat(struct s3c_hsudc *hsudc,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct s3c_hsudc_ep *hsep;\r\nbool set = (ctrl->bRequest == USB_REQ_SET_FEATURE);\r\nu8 ep_num = ctrl->wIndex & USB_ENDPOINT_NUMBER_MASK;\r\nif (ctrl->bRequestType == USB_RECIP_ENDPOINT) {\r\nhsep = &hsudc->ep[ep_num];\r\nswitch (le16_to_cpu(ctrl->wValue)) {\r\ncase USB_ENDPOINT_HALT:\r\nif (set || (!set && !hsep->wedge))\r\ns3c_hsudc_set_halt(&hsep->ep, set);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic void s3c_hsudc_process_req_status(struct s3c_hsudc *hsudc,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct s3c_hsudc_ep *hsep0 = &hsudc->ep[0];\r\nstruct s3c_hsudc_req hsreq;\r\nstruct s3c_hsudc_ep *hsep;\r\n__le16 reply;\r\nu8 epnum;\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nreply = cpu_to_le16(0);\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nreply = cpu_to_le16(0);\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nepnum = le16_to_cpu(ctrl->wIndex) & USB_ENDPOINT_NUMBER_MASK;\r\nhsep = &hsudc->ep[epnum];\r\nreply = cpu_to_le16(hsep->stopped ? 1 : 0);\r\nbreak;\r\n}\r\nINIT_LIST_HEAD(&hsreq.queue);\r\nhsreq.req.length = 2;\r\nhsreq.req.buf = &reply;\r\nhsreq.req.actual = 0;\r\nhsreq.req.complete = NULL;\r\ns3c_hsudc_write_fifo(hsep0, &hsreq);\r\n}\r\nstatic void s3c_hsudc_process_setup(struct s3c_hsudc *hsudc)\r\n{\r\nstruct s3c_hsudc_ep *hsep = &hsudc->ep[0];\r\nstruct usb_ctrlrequest ctrl = {0};\r\nint ret;\r\ns3c_hsudc_nuke_ep(hsep, -EPROTO);\r\ns3c_hsudc_read_setup_pkt(hsudc, (u16 *)&ctrl);\r\nif (ctrl.bRequestType & USB_DIR_IN) {\r\nhsep->bEndpointAddress |= USB_DIR_IN;\r\nhsudc->ep0state = DATA_STATE_XMIT;\r\n} else {\r\nhsep->bEndpointAddress &= ~USB_DIR_IN;\r\nhsudc->ep0state = DATA_STATE_RECV;\r\n}\r\nswitch (ctrl.bRequest) {\r\ncase USB_REQ_SET_ADDRESS:\r\nif (ctrl.bRequestType != (USB_TYPE_STANDARD | USB_RECIP_DEVICE))\r\nbreak;\r\nhsudc->ep0state = WAIT_FOR_SETUP;\r\nreturn;\r\ncase USB_REQ_GET_STATUS:\r\nif ((ctrl.bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)\r\nbreak;\r\ns3c_hsudc_process_req_status(hsudc, &ctrl);\r\nreturn;\r\ncase USB_REQ_SET_FEATURE:\r\ncase USB_REQ_CLEAR_FEATURE:\r\nif ((ctrl.bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)\r\nbreak;\r\ns3c_hsudc_handle_reqfeat(hsudc, &ctrl);\r\nhsudc->ep0state = WAIT_FOR_SETUP;\r\nreturn;\r\n}\r\nif (hsudc->driver) {\r\nspin_unlock(&hsudc->lock);\r\nret = hsudc->driver->setup(&hsudc->gadget, &ctrl);\r\nspin_lock(&hsudc->lock);\r\nif (ctrl.bRequest == USB_REQ_SET_CONFIGURATION) {\r\nhsep->bEndpointAddress &= ~USB_DIR_IN;\r\nhsudc->ep0state = WAIT_FOR_SETUP;\r\n}\r\nif (ret < 0) {\r\ndev_err(hsudc->dev, "setup failed, returned %d\n",\r\nret);\r\ns3c_hsudc_set_halt(&hsep->ep, 1);\r\nhsudc->ep0state = WAIT_FOR_SETUP;\r\nhsep->bEndpointAddress &= ~USB_DIR_IN;\r\n}\r\n}\r\n}\r\nstatic void s3c_hsudc_handle_ep0_intr(struct s3c_hsudc *hsudc)\r\n{\r\nstruct s3c_hsudc_ep *hsep = &hsudc->ep[0];\r\nstruct s3c_hsudc_req *hsreq;\r\nu32 csr = readl(hsudc->regs + S3C_EP0SR);\r\nu32 ecr;\r\nif (csr & S3C_EP0SR_STALL) {\r\necr = readl(hsudc->regs + S3C_EP0CR);\r\necr &= ~(S3C_ECR_STALL | S3C_ECR_FLUSH);\r\nwritel(ecr, hsudc->regs + S3C_EP0CR);\r\nwritel(S3C_EP0SR_STALL, hsudc->regs + S3C_EP0SR);\r\nhsep->stopped = 0;\r\ns3c_hsudc_nuke_ep(hsep, -ECONNABORTED);\r\nhsudc->ep0state = WAIT_FOR_SETUP;\r\nhsep->bEndpointAddress &= ~USB_DIR_IN;\r\nreturn;\r\n}\r\nif (csr & S3C_EP0SR_TX_SUCCESS) {\r\nwritel(S3C_EP0SR_TX_SUCCESS, hsudc->regs + S3C_EP0SR);\r\nif (ep_is_in(hsep)) {\r\nif (list_empty(&hsep->queue))\r\nreturn;\r\nhsreq = list_entry(hsep->queue.next,\r\nstruct s3c_hsudc_req, queue);\r\ns3c_hsudc_write_fifo(hsep, hsreq);\r\n}\r\n}\r\nif (csr & S3C_EP0SR_RX_SUCCESS) {\r\nif (hsudc->ep0state == WAIT_FOR_SETUP)\r\ns3c_hsudc_process_setup(hsudc);\r\nelse {\r\nif (!ep_is_in(hsep)) {\r\nif (list_empty(&hsep->queue))\r\nreturn;\r\nhsreq = list_entry(hsep->queue.next,\r\nstruct s3c_hsudc_req, queue);\r\ns3c_hsudc_read_fifo(hsep, hsreq);\r\n}\r\n}\r\n}\r\n}\r\nstatic int s3c_hsudc_ep_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct s3c_hsudc_ep *hsep;\r\nstruct s3c_hsudc *hsudc;\r\nunsigned long flags;\r\nu32 ecr = 0;\r\nhsep = our_ep(_ep);\r\nif (!_ep || !desc || _ep->name == ep0name\r\n|| desc->bDescriptorType != USB_DT_ENDPOINT\r\n|| hsep->bEndpointAddress != desc->bEndpointAddress\r\n|| ep_maxpacket(hsep) < usb_endpoint_maxp(desc))\r\nreturn -EINVAL;\r\nif ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK\r\n&& usb_endpoint_maxp(desc) != ep_maxpacket(hsep))\r\n|| !desc->wMaxPacketSize)\r\nreturn -ERANGE;\r\nhsudc = hsep->dev;\r\nif (!hsudc->driver || hsudc->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nspin_lock_irqsave(&hsudc->lock, flags);\r\nset_index(hsudc, hsep->bEndpointAddress);\r\necr |= ((usb_endpoint_xfer_int(desc)) ? S3C_ECR_IEMS : S3C_ECR_DUEN);\r\nwritel(ecr, hsudc->regs + S3C_ECR);\r\nhsep->stopped = hsep->wedge = 0;\r\nhsep->ep.desc = desc;\r\nhsep->ep.maxpacket = usb_endpoint_maxp(desc);\r\ns3c_hsudc_set_halt(_ep, 0);\r\n__set_bit(ep_index(hsep), hsudc->regs + S3C_EIER);\r\nspin_unlock_irqrestore(&hsudc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int s3c_hsudc_ep_disable(struct usb_ep *_ep)\r\n{\r\nstruct s3c_hsudc_ep *hsep = our_ep(_ep);\r\nstruct s3c_hsudc *hsudc = hsep->dev;\r\nunsigned long flags;\r\nif (!_ep || !hsep->ep.desc)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&hsudc->lock, flags);\r\nset_index(hsudc, hsep->bEndpointAddress);\r\n__clear_bit(ep_index(hsep), hsudc->regs + S3C_EIER);\r\ns3c_hsudc_nuke_ep(hsep, -ESHUTDOWN);\r\nhsep->ep.desc = NULL;\r\nhsep->stopped = 1;\r\nspin_unlock_irqrestore(&hsudc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *s3c_hsudc_alloc_request(struct usb_ep *_ep,\r\ngfp_t gfp_flags)\r\n{\r\nstruct s3c_hsudc_req *hsreq;\r\nhsreq = kzalloc(sizeof(*hsreq), gfp_flags);\r\nif (!hsreq)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&hsreq->queue);\r\nreturn &hsreq->req;\r\n}\r\nstatic void s3c_hsudc_free_request(struct usb_ep *ep, struct usb_request *_req)\r\n{\r\nstruct s3c_hsudc_req *hsreq;\r\nhsreq = our_req(_req);\r\nWARN_ON(!list_empty(&hsreq->queue));\r\nkfree(hsreq);\r\n}\r\nstatic int s3c_hsudc_queue(struct usb_ep *_ep, struct usb_request *_req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct s3c_hsudc_req *hsreq;\r\nstruct s3c_hsudc_ep *hsep;\r\nstruct s3c_hsudc *hsudc;\r\nunsigned long flags;\r\nu32 offset;\r\nu32 csr;\r\nhsreq = our_req(_req);\r\nif ((!_req || !_req->complete || !_req->buf ||\r\n!list_empty(&hsreq->queue)))\r\nreturn -EINVAL;\r\nhsep = our_ep(_ep);\r\nhsudc = hsep->dev;\r\nif (!hsudc->driver || hsudc->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nspin_lock_irqsave(&hsudc->lock, flags);\r\nset_index(hsudc, hsep->bEndpointAddress);\r\n_req->status = -EINPROGRESS;\r\n_req->actual = 0;\r\nif (!ep_index(hsep) && _req->length == 0) {\r\nhsudc->ep0state = WAIT_FOR_SETUP;\r\ns3c_hsudc_complete_request(hsep, hsreq, 0);\r\nspin_unlock_irqrestore(&hsudc->lock, flags);\r\nreturn 0;\r\n}\r\nif (list_empty(&hsep->queue) && !hsep->stopped) {\r\noffset = (ep_index(hsep)) ? S3C_ESR : S3C_EP0SR;\r\nif (ep_is_in(hsep)) {\r\ncsr = readl(hsudc->regs + offset);\r\nif (!(csr & S3C_ESR_TX_SUCCESS) &&\r\n(s3c_hsudc_write_fifo(hsep, hsreq) == 1))\r\nhsreq = NULL;\r\n} else {\r\ncsr = readl(hsudc->regs + offset);\r\nif ((csr & S3C_ESR_RX_SUCCESS)\r\n&& (s3c_hsudc_read_fifo(hsep, hsreq) == 1))\r\nhsreq = NULL;\r\n}\r\n}\r\nif (hsreq)\r\nlist_add_tail(&hsreq->queue, &hsep->queue);\r\nspin_unlock_irqrestore(&hsudc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int s3c_hsudc_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct s3c_hsudc_ep *hsep = our_ep(_ep);\r\nstruct s3c_hsudc *hsudc = hsep->dev;\r\nstruct s3c_hsudc_req *hsreq;\r\nunsigned long flags;\r\nhsep = our_ep(_ep);\r\nif (!_ep || hsep->ep.name == ep0name)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&hsudc->lock, flags);\r\nlist_for_each_entry(hsreq, &hsep->queue, queue) {\r\nif (&hsreq->req == _req)\r\nbreak;\r\n}\r\nif (&hsreq->req != _req) {\r\nspin_unlock_irqrestore(&hsudc->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nset_index(hsudc, hsep->bEndpointAddress);\r\ns3c_hsudc_complete_request(hsep, hsreq, -ECONNRESET);\r\nspin_unlock_irqrestore(&hsudc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void s3c_hsudc_initep(struct s3c_hsudc *hsudc,\r\nstruct s3c_hsudc_ep *hsep, int epnum)\r\n{\r\nchar *dir;\r\nif ((epnum % 2) == 0) {\r\ndir = "out";\r\n} else {\r\ndir = "in";\r\nhsep->bEndpointAddress = USB_DIR_IN;\r\n}\r\nhsep->bEndpointAddress |= epnum;\r\nif (epnum)\r\nsnprintf(hsep->name, sizeof(hsep->name), "ep%d%s", epnum, dir);\r\nelse\r\nsnprintf(hsep->name, sizeof(hsep->name), "%s", ep0name);\r\nINIT_LIST_HEAD(&hsep->queue);\r\nINIT_LIST_HEAD(&hsep->ep.ep_list);\r\nif (epnum)\r\nlist_add_tail(&hsep->ep.ep_list, &hsudc->gadget.ep_list);\r\nhsep->dev = hsudc;\r\nhsep->ep.name = hsep->name;\r\nhsep->ep.maxpacket = epnum ? 512 : 64;\r\nhsep->ep.ops = &s3c_hsudc_ep_ops;\r\nhsep->fifo = hsudc->regs + S3C_BR(epnum);\r\nhsep->ep.desc = NULL;\r\nhsep->stopped = 0;\r\nhsep->wedge = 0;\r\nset_index(hsudc, epnum);\r\nwritel(hsep->ep.maxpacket, hsudc->regs + S3C_MPR);\r\n}\r\nstatic void s3c_hsudc_setup_ep(struct s3c_hsudc *hsudc)\r\n{\r\nint epnum;\r\nhsudc->ep0state = WAIT_FOR_SETUP;\r\nINIT_LIST_HEAD(&hsudc->gadget.ep_list);\r\nfor (epnum = 0; epnum < hsudc->pd->epnum; epnum++)\r\ns3c_hsudc_initep(hsudc, &hsudc->ep[epnum], epnum);\r\n}\r\nstatic void s3c_hsudc_reconfig(struct s3c_hsudc *hsudc)\r\n{\r\nwritel(0xAA, hsudc->regs + S3C_EDR);\r\nwritel(1, hsudc->regs + S3C_EIER);\r\nwritel(0, hsudc->regs + S3C_TR);\r\nwritel(S3C_SCR_DTZIEN_EN | S3C_SCR_RRD_EN | S3C_SCR_SUS_EN |\r\nS3C_SCR_RST_EN, hsudc->regs + S3C_SCR);\r\nwritel(0, hsudc->regs + S3C_EP0CR);\r\ns3c_hsudc_setup_ep(hsudc);\r\n}\r\nstatic irqreturn_t s3c_hsudc_irq(int irq, void *_dev)\r\n{\r\nstruct s3c_hsudc *hsudc = _dev;\r\nstruct s3c_hsudc_ep *hsep;\r\nu32 ep_intr;\r\nu32 sys_status;\r\nu32 ep_idx;\r\nspin_lock(&hsudc->lock);\r\nsys_status = readl(hsudc->regs + S3C_SSR);\r\nep_intr = readl(hsudc->regs + S3C_EIR) & 0x3FF;\r\nif (!ep_intr && !(sys_status & S3C_SSR_DTZIEN_EN)) {\r\nspin_unlock(&hsudc->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (sys_status) {\r\nif (sys_status & S3C_SSR_VBUSON)\r\nwritel(S3C_SSR_VBUSON, hsudc->regs + S3C_SSR);\r\nif (sys_status & S3C_SSR_ERR)\r\nwritel(S3C_SSR_ERR, hsudc->regs + S3C_SSR);\r\nif (sys_status & S3C_SSR_SDE) {\r\nwritel(S3C_SSR_SDE, hsudc->regs + S3C_SSR);\r\nhsudc->gadget.speed = (sys_status & S3C_SSR_HSP) ?\r\nUSB_SPEED_HIGH : USB_SPEED_FULL;\r\n}\r\nif (sys_status & S3C_SSR_SUSPEND) {\r\nwritel(S3C_SSR_SUSPEND, hsudc->regs + S3C_SSR);\r\nif (hsudc->gadget.speed != USB_SPEED_UNKNOWN\r\n&& hsudc->driver && hsudc->driver->suspend)\r\nhsudc->driver->suspend(&hsudc->gadget);\r\n}\r\nif (sys_status & S3C_SSR_RESUME) {\r\nwritel(S3C_SSR_RESUME, hsudc->regs + S3C_SSR);\r\nif (hsudc->gadget.speed != USB_SPEED_UNKNOWN\r\n&& hsudc->driver && hsudc->driver->resume)\r\nhsudc->driver->resume(&hsudc->gadget);\r\n}\r\nif (sys_status & S3C_SSR_RESET) {\r\nwritel(S3C_SSR_RESET, hsudc->regs + S3C_SSR);\r\nfor (ep_idx = 0; ep_idx < hsudc->pd->epnum; ep_idx++) {\r\nhsep = &hsudc->ep[ep_idx];\r\nhsep->stopped = 1;\r\ns3c_hsudc_nuke_ep(hsep, -ECONNRESET);\r\n}\r\ns3c_hsudc_reconfig(hsudc);\r\nhsudc->ep0state = WAIT_FOR_SETUP;\r\n}\r\n}\r\nif (ep_intr & S3C_EIR_EP0) {\r\nwritel(S3C_EIR_EP0, hsudc->regs + S3C_EIR);\r\nset_index(hsudc, 0);\r\ns3c_hsudc_handle_ep0_intr(hsudc);\r\n}\r\nep_intr >>= 1;\r\nep_idx = 1;\r\nwhile (ep_intr) {\r\nif (ep_intr & 1) {\r\nhsep = &hsudc->ep[ep_idx];\r\nset_index(hsudc, ep_idx);\r\nwritel(1 << ep_idx, hsudc->regs + S3C_EIR);\r\nif (ep_is_in(hsep))\r\ns3c_hsudc_epin_intr(hsudc, ep_idx);\r\nelse\r\ns3c_hsudc_epout_intr(hsudc, ep_idx);\r\n}\r\nep_intr >>= 1;\r\nep_idx++;\r\n}\r\nspin_unlock(&hsudc->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s3c_hsudc_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct s3c_hsudc *hsudc = to_hsudc(gadget);\r\nint ret;\r\nif (!driver\r\n|| driver->max_speed < USB_SPEED_FULL\r\n|| !driver->setup)\r\nreturn -EINVAL;\r\nif (!hsudc)\r\nreturn -ENODEV;\r\nif (hsudc->driver)\r\nreturn -EBUSY;\r\nhsudc->driver = driver;\r\nret = regulator_bulk_enable(ARRAY_SIZE(hsudc->supplies),\r\nhsudc->supplies);\r\nif (ret != 0) {\r\ndev_err(hsudc->dev, "failed to enable supplies: %d\n", ret);\r\ngoto err_supplies;\r\n}\r\nif (!IS_ERR_OR_NULL(hsudc->transceiver)) {\r\nret = otg_set_peripheral(hsudc->transceiver->otg,\r\n&hsudc->gadget);\r\nif (ret) {\r\ndev_err(hsudc->dev, "%s: can't bind to transceiver\n",\r\nhsudc->gadget.name);\r\ngoto err_otg;\r\n}\r\n}\r\nenable_irq(hsudc->irq);\r\ndev_info(hsudc->dev, "bound driver %s\n", driver->driver.name);\r\ns3c_hsudc_reconfig(hsudc);\r\npm_runtime_get_sync(hsudc->dev);\r\ns3c_hsudc_init_phy();\r\nif (hsudc->pd->gpio_init)\r\nhsudc->pd->gpio_init();\r\nreturn 0;\r\nerr_otg:\r\nregulator_bulk_disable(ARRAY_SIZE(hsudc->supplies), hsudc->supplies);\r\nerr_supplies:\r\nhsudc->driver = NULL;\r\nreturn ret;\r\n}\r\nstatic int s3c_hsudc_stop(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct s3c_hsudc *hsudc = to_hsudc(gadget);\r\nunsigned long flags;\r\nif (!hsudc)\r\nreturn -ENODEV;\r\nif (!driver || driver != hsudc->driver)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&hsudc->lock, flags);\r\nhsudc->driver = NULL;\r\nhsudc->gadget.speed = USB_SPEED_UNKNOWN;\r\ns3c_hsudc_uninit_phy();\r\npm_runtime_put(hsudc->dev);\r\nif (hsudc->pd->gpio_uninit)\r\nhsudc->pd->gpio_uninit();\r\ns3c_hsudc_stop_activity(hsudc);\r\nspin_unlock_irqrestore(&hsudc->lock, flags);\r\nif (!IS_ERR_OR_NULL(hsudc->transceiver))\r\n(void) otg_set_peripheral(hsudc->transceiver->otg, NULL);\r\ndisable_irq(hsudc->irq);\r\nregulator_bulk_disable(ARRAY_SIZE(hsudc->supplies), hsudc->supplies);\r\ndev_info(hsudc->dev, "unregistered gadget driver '%s'\n",\r\ndriver->driver.name);\r\nreturn 0;\r\n}\r\nstatic inline u32 s3c_hsudc_read_frameno(struct s3c_hsudc *hsudc)\r\n{\r\nreturn readl(hsudc->regs + S3C_FNR) & 0x3FF;\r\n}\r\nstatic int s3c_hsudc_gadget_getframe(struct usb_gadget *gadget)\r\n{\r\nreturn s3c_hsudc_read_frameno(to_hsudc(gadget));\r\n}\r\nstatic int s3c_hsudc_vbus_draw(struct usb_gadget *gadget, unsigned mA)\r\n{\r\nstruct s3c_hsudc *hsudc = to_hsudc(gadget);\r\nif (!hsudc)\r\nreturn -ENODEV;\r\nif (!IS_ERR_OR_NULL(hsudc->transceiver))\r\nreturn usb_phy_set_power(hsudc->transceiver, mA);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int s3c_hsudc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct s3c_hsudc *hsudc;\r\nstruct s3c24xx_hsudc_platdata *pd = dev_get_platdata(&pdev->dev);\r\nint ret, i;\r\nhsudc = devm_kzalloc(&pdev->dev, sizeof(struct s3c_hsudc) +\r\nsizeof(struct s3c_hsudc_ep) * pd->epnum,\r\nGFP_KERNEL);\r\nif (!hsudc) {\r\ndev_err(dev, "cannot allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, dev);\r\nhsudc->dev = dev;\r\nhsudc->pd = dev_get_platdata(&pdev->dev);\r\nhsudc->transceiver = usb_get_phy(USB_PHY_TYPE_USB2);\r\nfor (i = 0; i < ARRAY_SIZE(hsudc->supplies); i++)\r\nhsudc->supplies[i].supply = s3c_hsudc_supply_names[i];\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(hsudc->supplies),\r\nhsudc->supplies);\r\nif (ret != 0) {\r\ndev_err(dev, "failed to request supplies: %d\n", ret);\r\ngoto err_supplies;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhsudc->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(hsudc->regs)) {\r\nret = PTR_ERR(hsudc->regs);\r\ngoto err_res;\r\n}\r\nspin_lock_init(&hsudc->lock);\r\nhsudc->gadget.max_speed = USB_SPEED_HIGH;\r\nhsudc->gadget.ops = &s3c_hsudc_gadget_ops;\r\nhsudc->gadget.name = dev_name(dev);\r\nhsudc->gadget.ep0 = &hsudc->ep[0].ep;\r\nhsudc->gadget.is_otg = 0;\r\nhsudc->gadget.is_a_peripheral = 0;\r\nhsudc->gadget.speed = USB_SPEED_UNKNOWN;\r\ns3c_hsudc_setup_ep(hsudc);\r\nret = platform_get_irq(pdev, 0);\r\nif (ret < 0) {\r\ndev_err(dev, "unable to obtain IRQ number\n");\r\ngoto err_res;\r\n}\r\nhsudc->irq = ret;\r\nret = devm_request_irq(&pdev->dev, hsudc->irq, s3c_hsudc_irq, 0,\r\ndriver_name, hsudc);\r\nif (ret < 0) {\r\ndev_err(dev, "irq request failed\n");\r\ngoto err_res;\r\n}\r\nhsudc->uclk = devm_clk_get(&pdev->dev, "usb-device");\r\nif (IS_ERR(hsudc->uclk)) {\r\ndev_err(dev, "failed to find usb-device clock source\n");\r\nret = PTR_ERR(hsudc->uclk);\r\ngoto err_res;\r\n}\r\nclk_enable(hsudc->uclk);\r\nlocal_irq_disable();\r\ndisable_irq(hsudc->irq);\r\nlocal_irq_enable();\r\nret = usb_add_gadget_udc(&pdev->dev, &hsudc->gadget);\r\nif (ret)\r\ngoto err_add_udc;\r\npm_runtime_enable(dev);\r\nreturn 0;\r\nerr_add_udc:\r\nerr_add_device:\r\nclk_disable(hsudc->uclk);\r\nerr_res:\r\nif (!IS_ERR_OR_NULL(hsudc->transceiver))\r\nusb_put_phy(hsudc->transceiver);\r\nerr_supplies:\r\nreturn ret;\r\n}
