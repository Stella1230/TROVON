static void lapb_free_cb(struct lapb_cb *lapb)\r\n{\r\nkfree(lapb);\r\n}\r\nstatic __inline__ void lapb_hold(struct lapb_cb *lapb)\r\n{\r\natomic_inc(&lapb->refcnt);\r\n}\r\nstatic __inline__ void lapb_put(struct lapb_cb *lapb)\r\n{\r\nif (atomic_dec_and_test(&lapb->refcnt))\r\nlapb_free_cb(lapb);\r\n}\r\nstatic void __lapb_remove_cb(struct lapb_cb *lapb)\r\n{\r\nif (lapb->node.next) {\r\nlist_del(&lapb->node);\r\nlapb_put(lapb);\r\n}\r\n}\r\nstatic void __lapb_insert_cb(struct lapb_cb *lapb)\r\n{\r\nlist_add(&lapb->node, &lapb_list);\r\nlapb_hold(lapb);\r\n}\r\nstatic struct lapb_cb *__lapb_devtostruct(struct net_device *dev)\r\n{\r\nstruct list_head *entry;\r\nstruct lapb_cb *lapb, *use = NULL;\r\nlist_for_each(entry, &lapb_list) {\r\nlapb = list_entry(entry, struct lapb_cb, node);\r\nif (lapb->dev == dev) {\r\nuse = lapb;\r\nbreak;\r\n}\r\n}\r\nif (use)\r\nlapb_hold(use);\r\nreturn use;\r\n}\r\nstatic struct lapb_cb *lapb_devtostruct(struct net_device *dev)\r\n{\r\nstruct lapb_cb *rc;\r\nread_lock_bh(&lapb_list_lock);\r\nrc = __lapb_devtostruct(dev);\r\nread_unlock_bh(&lapb_list_lock);\r\nreturn rc;\r\n}\r\nstatic struct lapb_cb *lapb_create_cb(void)\r\n{\r\nstruct lapb_cb *lapb = kzalloc(sizeof(*lapb), GFP_ATOMIC);\r\nif (!lapb)\r\ngoto out;\r\nskb_queue_head_init(&lapb->write_queue);\r\nskb_queue_head_init(&lapb->ack_queue);\r\ninit_timer(&lapb->t1timer);\r\ninit_timer(&lapb->t2timer);\r\nlapb->t1 = LAPB_DEFAULT_T1;\r\nlapb->t2 = LAPB_DEFAULT_T2;\r\nlapb->n2 = LAPB_DEFAULT_N2;\r\nlapb->mode = LAPB_DEFAULT_MODE;\r\nlapb->window = LAPB_DEFAULT_WINDOW;\r\nlapb->state = LAPB_STATE_0;\r\natomic_set(&lapb->refcnt, 1);\r\nout:\r\nreturn lapb;\r\n}\r\nint lapb_register(struct net_device *dev,\r\nconst struct lapb_register_struct *callbacks)\r\n{\r\nstruct lapb_cb *lapb;\r\nint rc = LAPB_BADTOKEN;\r\nwrite_lock_bh(&lapb_list_lock);\r\nlapb = __lapb_devtostruct(dev);\r\nif (lapb) {\r\nlapb_put(lapb);\r\ngoto out;\r\n}\r\nlapb = lapb_create_cb();\r\nrc = LAPB_NOMEM;\r\nif (!lapb)\r\ngoto out;\r\nlapb->dev = dev;\r\nlapb->callbacks = callbacks;\r\n__lapb_insert_cb(lapb);\r\nlapb_start_t1timer(lapb);\r\nrc = LAPB_OK;\r\nout:\r\nwrite_unlock_bh(&lapb_list_lock);\r\nreturn rc;\r\n}\r\nint lapb_unregister(struct net_device *dev)\r\n{\r\nstruct lapb_cb *lapb;\r\nint rc = LAPB_BADTOKEN;\r\nwrite_lock_bh(&lapb_list_lock);\r\nlapb = __lapb_devtostruct(dev);\r\nif (!lapb)\r\ngoto out;\r\nlapb_stop_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb_clear_queues(lapb);\r\n__lapb_remove_cb(lapb);\r\nlapb_put(lapb);\r\nrc = LAPB_OK;\r\nout:\r\nwrite_unlock_bh(&lapb_list_lock);\r\nreturn rc;\r\n}\r\nint lapb_getparms(struct net_device *dev, struct lapb_parms_struct *parms)\r\n{\r\nint rc = LAPB_BADTOKEN;\r\nstruct lapb_cb *lapb = lapb_devtostruct(dev);\r\nif (!lapb)\r\ngoto out;\r\nparms->t1 = lapb->t1 / HZ;\r\nparms->t2 = lapb->t2 / HZ;\r\nparms->n2 = lapb->n2;\r\nparms->n2count = lapb->n2count;\r\nparms->state = lapb->state;\r\nparms->window = lapb->window;\r\nparms->mode = lapb->mode;\r\nif (!timer_pending(&lapb->t1timer))\r\nparms->t1timer = 0;\r\nelse\r\nparms->t1timer = (lapb->t1timer.expires - jiffies) / HZ;\r\nif (!timer_pending(&lapb->t2timer))\r\nparms->t2timer = 0;\r\nelse\r\nparms->t2timer = (lapb->t2timer.expires - jiffies) / HZ;\r\nlapb_put(lapb);\r\nrc = LAPB_OK;\r\nout:\r\nreturn rc;\r\n}\r\nint lapb_setparms(struct net_device *dev, struct lapb_parms_struct *parms)\r\n{\r\nint rc = LAPB_BADTOKEN;\r\nstruct lapb_cb *lapb = lapb_devtostruct(dev);\r\nif (!lapb)\r\ngoto out;\r\nrc = LAPB_INVALUE;\r\nif (parms->t1 < 1 || parms->t2 < 1 || parms->n2 < 1)\r\ngoto out_put;\r\nif (lapb->state == LAPB_STATE_0) {\r\nif (parms->mode & LAPB_EXTENDED) {\r\nif (parms->window < 1 || parms->window > 127)\r\ngoto out_put;\r\n} else {\r\nif (parms->window < 1 || parms->window > 7)\r\ngoto out_put;\r\n}\r\nlapb->mode = parms->mode;\r\nlapb->window = parms->window;\r\n}\r\nlapb->t1 = parms->t1 * HZ;\r\nlapb->t2 = parms->t2 * HZ;\r\nlapb->n2 = parms->n2;\r\nrc = LAPB_OK;\r\nout_put:\r\nlapb_put(lapb);\r\nout:\r\nreturn rc;\r\n}\r\nint lapb_connect_request(struct net_device *dev)\r\n{\r\nstruct lapb_cb *lapb = lapb_devtostruct(dev);\r\nint rc = LAPB_BADTOKEN;\r\nif (!lapb)\r\ngoto out;\r\nrc = LAPB_OK;\r\nif (lapb->state == LAPB_STATE_1)\r\ngoto out_put;\r\nrc = LAPB_CONNECTED;\r\nif (lapb->state == LAPB_STATE_3 || lapb->state == LAPB_STATE_4)\r\ngoto out_put;\r\nlapb_establish_data_link(lapb);\r\nlapb_dbg(0, "(%p) S0 -> S1\n", lapb->dev);\r\nlapb->state = LAPB_STATE_1;\r\nrc = LAPB_OK;\r\nout_put:\r\nlapb_put(lapb);\r\nout:\r\nreturn rc;\r\n}\r\nint lapb_disconnect_request(struct net_device *dev)\r\n{\r\nstruct lapb_cb *lapb = lapb_devtostruct(dev);\r\nint rc = LAPB_BADTOKEN;\r\nif (!lapb)\r\ngoto out;\r\nswitch (lapb->state) {\r\ncase LAPB_STATE_0:\r\nrc = LAPB_NOTCONNECTED;\r\ngoto out_put;\r\ncase LAPB_STATE_1:\r\nlapb_dbg(1, "(%p) S1 TX DISC(1)\n", lapb->dev);\r\nlapb_dbg(0, "(%p) S1 -> S0\n", lapb->dev);\r\nlapb_send_control(lapb, LAPB_DISC, LAPB_POLLON, LAPB_COMMAND);\r\nlapb->state = LAPB_STATE_0;\r\nlapb_start_t1timer(lapb);\r\nrc = LAPB_NOTCONNECTED;\r\ngoto out_put;\r\ncase LAPB_STATE_2:\r\nrc = LAPB_OK;\r\ngoto out_put;\r\n}\r\nlapb_clear_queues(lapb);\r\nlapb->n2count = 0;\r\nlapb_send_control(lapb, LAPB_DISC, LAPB_POLLON, LAPB_COMMAND);\r\nlapb_start_t1timer(lapb);\r\nlapb_stop_t2timer(lapb);\r\nlapb->state = LAPB_STATE_2;\r\nlapb_dbg(1, "(%p) S3 DISC(1)\n", lapb->dev);\r\nlapb_dbg(0, "(%p) S3 -> S2\n", lapb->dev);\r\nrc = LAPB_OK;\r\nout_put:\r\nlapb_put(lapb);\r\nout:\r\nreturn rc;\r\n}\r\nint lapb_data_request(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct lapb_cb *lapb = lapb_devtostruct(dev);\r\nint rc = LAPB_BADTOKEN;\r\nif (!lapb)\r\ngoto out;\r\nrc = LAPB_NOTCONNECTED;\r\nif (lapb->state != LAPB_STATE_3 && lapb->state != LAPB_STATE_4)\r\ngoto out_put;\r\nskb_queue_tail(&lapb->write_queue, skb);\r\nlapb_kick(lapb);\r\nrc = LAPB_OK;\r\nout_put:\r\nlapb_put(lapb);\r\nout:\r\nreturn rc;\r\n}\r\nint lapb_data_received(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct lapb_cb *lapb = lapb_devtostruct(dev);\r\nint rc = LAPB_BADTOKEN;\r\nif (lapb) {\r\nlapb_data_input(lapb, skb);\r\nlapb_put(lapb);\r\nrc = LAPB_OK;\r\n}\r\nreturn rc;\r\n}\r\nvoid lapb_connect_confirmation(struct lapb_cb *lapb, int reason)\r\n{\r\nif (lapb->callbacks->connect_confirmation)\r\nlapb->callbacks->connect_confirmation(lapb->dev, reason);\r\n}\r\nvoid lapb_connect_indication(struct lapb_cb *lapb, int reason)\r\n{\r\nif (lapb->callbacks->connect_indication)\r\nlapb->callbacks->connect_indication(lapb->dev, reason);\r\n}\r\nvoid lapb_disconnect_confirmation(struct lapb_cb *lapb, int reason)\r\n{\r\nif (lapb->callbacks->disconnect_confirmation)\r\nlapb->callbacks->disconnect_confirmation(lapb->dev, reason);\r\n}\r\nvoid lapb_disconnect_indication(struct lapb_cb *lapb, int reason)\r\n{\r\nif (lapb->callbacks->disconnect_indication)\r\nlapb->callbacks->disconnect_indication(lapb->dev, reason);\r\n}\r\nint lapb_data_indication(struct lapb_cb *lapb, struct sk_buff *skb)\r\n{\r\nif (lapb->callbacks->data_indication)\r\nreturn lapb->callbacks->data_indication(lapb->dev, skb);\r\nkfree_skb(skb);\r\nreturn NET_RX_SUCCESS;\r\n}\r\nint lapb_data_transmit(struct lapb_cb *lapb, struct sk_buff *skb)\r\n{\r\nint used = 0;\r\nif (lapb->callbacks->data_transmit) {\r\nlapb->callbacks->data_transmit(lapb->dev, skb);\r\nused = 1;\r\n}\r\nreturn used;\r\n}\r\nstatic int __init lapb_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit lapb_exit(void)\r\n{\r\nWARN_ON(!list_empty(&lapb_list));\r\n}
