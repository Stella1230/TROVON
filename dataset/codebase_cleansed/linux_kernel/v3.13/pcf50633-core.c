int pcf50633_read_block(struct pcf50633 *pcf, u8 reg,\r\nint nr_regs, u8 *data)\r\n{\r\nint ret;\r\nret = regmap_raw_read(pcf->regmap, reg, data, nr_regs);\r\nif (ret != 0)\r\nreturn ret;\r\nreturn nr_regs;\r\n}\r\nint pcf50633_write_block(struct pcf50633 *pcf , u8 reg,\r\nint nr_regs, u8 *data)\r\n{\r\nreturn regmap_raw_write(pcf->regmap, reg, data, nr_regs);\r\n}\r\nu8 pcf50633_reg_read(struct pcf50633 *pcf, u8 reg)\r\n{\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(pcf->regmap, reg, &val);\r\nif (ret < 0)\r\nreturn -1;\r\nreturn val;\r\n}\r\nint pcf50633_reg_write(struct pcf50633 *pcf, u8 reg, u8 val)\r\n{\r\nreturn regmap_write(pcf->regmap, reg, val);\r\n}\r\nint pcf50633_reg_set_bit_mask(struct pcf50633 *pcf, u8 reg, u8 mask, u8 val)\r\n{\r\nreturn regmap_update_bits(pcf->regmap, reg, mask, val);\r\n}\r\nint pcf50633_reg_clear_bits(struct pcf50633 *pcf, u8 reg, u8 val)\r\n{\r\nreturn regmap_update_bits(pcf->regmap, reg, val, 0);\r\n}\r\nstatic ssize_t show_dump_regs(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct pcf50633 *pcf = dev_get_drvdata(dev);\r\nu8 dump[16];\r\nint n, n1, idx = 0;\r\nchar *buf1 = buf;\r\nstatic u8 address_no_read[] = {\r\nPCF50633_REG_INT1,\r\nPCF50633_REG_INT2,\r\nPCF50633_REG_INT3,\r\nPCF50633_REG_INT4,\r\nPCF50633_REG_INT5,\r\n0\r\n};\r\nfor (n = 0; n < 256; n += sizeof(dump)) {\r\nfor (n1 = 0; n1 < sizeof(dump); n1++)\r\nif (n == address_no_read[idx]) {\r\nidx++;\r\ndump[n1] = 0x00;\r\n} else\r\ndump[n1] = pcf50633_reg_read(pcf, n + n1);\r\nhex_dump_to_buffer(dump, sizeof(dump), 16, 1, buf1, 128, 0);\r\nbuf1 += strlen(buf1);\r\n*buf1++ = '\n';\r\n*buf1 = '\0';\r\n}\r\nreturn buf1 - buf;\r\n}\r\nstatic ssize_t show_resume_reason(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct pcf50633 *pcf = dev_get_drvdata(dev);\r\nint n;\r\nn = sprintf(buf, "%02x%02x%02x%02x%02x\n",\r\npcf->resume_reason[0],\r\npcf->resume_reason[1],\r\npcf->resume_reason[2],\r\npcf->resume_reason[3],\r\npcf->resume_reason[4]);\r\nreturn n;\r\n}\r\nstatic void\r\npcf50633_client_dev_register(struct pcf50633 *pcf, const char *name,\r\nstruct platform_device **pdev)\r\n{\r\nint ret;\r\n*pdev = platform_device_alloc(name, -1);\r\nif (!*pdev) {\r\ndev_err(pcf->dev, "Falied to allocate %s\n", name);\r\nreturn;\r\n}\r\n(*pdev)->dev.parent = pcf->dev;\r\nret = platform_device_add(*pdev);\r\nif (ret) {\r\ndev_err(pcf->dev, "Failed to register %s: %d\n", name, ret);\r\nplatform_device_put(*pdev);\r\n*pdev = NULL;\r\n}\r\n}\r\nstatic int pcf50633_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct pcf50633 *pcf = i2c_get_clientdata(client);\r\nreturn pcf50633_irq_suspend(pcf);\r\n}\r\nstatic int pcf50633_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct pcf50633 *pcf = i2c_get_clientdata(client);\r\nreturn pcf50633_irq_resume(pcf);\r\n}\r\nstatic int pcf50633_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *ids)\r\n{\r\nstruct pcf50633 *pcf;\r\nstruct pcf50633_platform_data *pdata = dev_get_platdata(&client->dev);\r\nint i, ret;\r\nint version, variant;\r\nif (!client->irq) {\r\ndev_err(&client->dev, "Missing IRQ\n");\r\nreturn -ENOENT;\r\n}\r\npcf = devm_kzalloc(&client->dev, sizeof(*pcf), GFP_KERNEL);\r\nif (!pcf)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, pcf);\r\npcf->dev = &client->dev;\r\npcf->pdata = pdata;\r\nmutex_init(&pcf->lock);\r\npcf->regmap = devm_regmap_init_i2c(client, &pcf50633_regmap_config);\r\nif (IS_ERR(pcf->regmap)) {\r\nret = PTR_ERR(pcf->regmap);\r\ndev_err(pcf->dev, "Failed to allocate register map: %d\n", ret);\r\nreturn ret;\r\n}\r\nversion = pcf50633_reg_read(pcf, 0);\r\nvariant = pcf50633_reg_read(pcf, 1);\r\nif (version < 0 || variant < 0) {\r\ndev_err(pcf->dev, "Unable to probe pcf50633\n");\r\nret = -ENODEV;\r\nreturn ret;\r\n}\r\ndev_info(pcf->dev, "Probed device version %d variant %d\n",\r\nversion, variant);\r\npcf50633_irq_init(pcf, client->irq);\r\npcf50633_client_dev_register(pcf, "pcf50633-input", &pcf->input_pdev);\r\npcf50633_client_dev_register(pcf, "pcf50633-rtc", &pcf->rtc_pdev);\r\npcf50633_client_dev_register(pcf, "pcf50633-mbc", &pcf->mbc_pdev);\r\npcf50633_client_dev_register(pcf, "pcf50633-adc", &pcf->adc_pdev);\r\npcf50633_client_dev_register(pcf, "pcf50633-backlight", &pcf->bl_pdev);\r\nfor (i = 0; i < PCF50633_NUM_REGULATORS; i++) {\r\nstruct platform_device *pdev;\r\npdev = platform_device_alloc("pcf50633-regltr", i);\r\nif (!pdev) {\r\ndev_err(pcf->dev, "Cannot create regulator %d\n", i);\r\ncontinue;\r\n}\r\npdev->dev.parent = pcf->dev;\r\nif (platform_device_add_data(pdev, &pdata->reg_init_data[i],\r\nsizeof(pdata->reg_init_data[i])) < 0) {\r\nplatform_device_put(pdev);\r\ndev_err(pcf->dev, "Out of memory for regulator parameters %d\n",\r\ni);\r\ncontinue;\r\n}\r\npcf->regulator_pdev[i] = pdev;\r\nplatform_device_add(pdev);\r\n}\r\nret = sysfs_create_group(&client->dev.kobj, &pcf_attr_group);\r\nif (ret)\r\ndev_err(pcf->dev, "error creating sysfs entries\n");\r\nif (pdata->probe_done)\r\npdata->probe_done(pcf);\r\nreturn 0;\r\n}\r\nstatic int pcf50633_remove(struct i2c_client *client)\r\n{\r\nstruct pcf50633 *pcf = i2c_get_clientdata(client);\r\nint i;\r\nsysfs_remove_group(&client->dev.kobj, &pcf_attr_group);\r\npcf50633_irq_free(pcf);\r\nplatform_device_unregister(pcf->input_pdev);\r\nplatform_device_unregister(pcf->rtc_pdev);\r\nplatform_device_unregister(pcf->mbc_pdev);\r\nplatform_device_unregister(pcf->adc_pdev);\r\nplatform_device_unregister(pcf->bl_pdev);\r\nfor (i = 0; i < PCF50633_NUM_REGULATORS; i++)\r\nplatform_device_unregister(pcf->regulator_pdev[i]);\r\nreturn 0;\r\n}\r\nstatic int __init pcf50633_init(void)\r\n{\r\nreturn i2c_add_driver(&pcf50633_driver);\r\n}\r\nstatic void __exit pcf50633_exit(void)\r\n{\r\ni2c_del_driver(&pcf50633_driver);\r\n}
