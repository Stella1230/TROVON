static int ati_create_page_map(struct ati_page_map *page_map)\r\n{\r\nint i, err = 0;\r\npage_map->real = (unsigned long *) __get_free_page(GFP_KERNEL);\r\nif (page_map->real == NULL)\r\nreturn -ENOMEM;\r\nset_memory_uc((unsigned long)page_map->real, 1);\r\nerr = map_page_into_agp(virt_to_page(page_map->real));\r\npage_map->remapped = page_map->real;\r\nfor (i = 0; i < PAGE_SIZE / sizeof(unsigned long); i++) {\r\nwritel(agp_bridge->scratch_page, page_map->remapped+i);\r\nreadl(page_map->remapped+i);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ati_free_page_map(struct ati_page_map *page_map)\r\n{\r\nunmap_page_from_agp(virt_to_page(page_map->real));\r\nset_memory_wb((unsigned long)page_map->real, 1);\r\nfree_page((unsigned long) page_map->real);\r\n}\r\nstatic void ati_free_gatt_pages(void)\r\n{\r\nint i;\r\nstruct ati_page_map **tables;\r\nstruct ati_page_map *entry;\r\ntables = ati_generic_private.gatt_pages;\r\nfor (i = 0; i < ati_generic_private.num_tables; i++) {\r\nentry = tables[i];\r\nif (entry != NULL) {\r\nif (entry->real != NULL)\r\nati_free_page_map(entry);\r\nkfree(entry);\r\n}\r\n}\r\nkfree(tables);\r\n}\r\nstatic int ati_create_gatt_pages(int nr_tables)\r\n{\r\nstruct ati_page_map **tables;\r\nstruct ati_page_map *entry;\r\nint retval = 0;\r\nint i;\r\ntables = kzalloc((nr_tables + 1) * sizeof(struct ati_page_map *),GFP_KERNEL);\r\nif (tables == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < nr_tables; i++) {\r\nentry = kzalloc(sizeof(struct ati_page_map), GFP_KERNEL);\r\ntables[i] = entry;\r\nif (entry == NULL) {\r\nretval = -ENOMEM;\r\nbreak;\r\n}\r\nretval = ati_create_page_map(entry);\r\nif (retval != 0)\r\nbreak;\r\n}\r\nati_generic_private.num_tables = i;\r\nati_generic_private.gatt_pages = tables;\r\nif (retval != 0)\r\nati_free_gatt_pages();\r\nreturn retval;\r\n}\r\nstatic int is_r200(void)\r\n{\r\nif ((agp_bridge->dev->device == PCI_DEVICE_ID_ATI_RS100) ||\r\n(agp_bridge->dev->device == PCI_DEVICE_ID_ATI_RS200) ||\r\n(agp_bridge->dev->device == PCI_DEVICE_ID_ATI_RS200_B) ||\r\n(agp_bridge->dev->device == PCI_DEVICE_ID_ATI_RS250))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int ati_fetch_size(void)\r\n{\r\nint i;\r\nu32 temp;\r\nstruct aper_size_info_lvl2 *values;\r\nif (is_r200())\r\npci_read_config_dword(agp_bridge->dev, ATI_RS100_APSIZE, &temp);\r\nelse\r\npci_read_config_dword(agp_bridge->dev, ATI_RS300_APSIZE, &temp);\r\ntemp = (temp & 0x0000000e);\r\nvalues = A_SIZE_LVL2(agp_bridge->driver->aperture_sizes);\r\nfor (i = 0; i < agp_bridge->driver->num_aperture_sizes; i++) {\r\nif (temp == values[i].size_value) {\r\nagp_bridge->previous_size =\r\nagp_bridge->current_size = (void *) (values + i);\r\nagp_bridge->aperture_size_idx = i;\r\nreturn values[i].size;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ati_tlbflush(struct agp_memory * mem)\r\n{\r\nwritel(1, ati_generic_private.registers+ATI_GART_CACHE_CNTRL);\r\nreadl(ati_generic_private.registers+ATI_GART_CACHE_CNTRL);\r\n}\r\nstatic void ati_cleanup(void)\r\n{\r\nstruct aper_size_info_lvl2 *previous_size;\r\nu32 temp;\r\nprevious_size = A_SIZE_LVL2(agp_bridge->previous_size);\r\nif (is_r200()) {\r\npci_read_config_dword(agp_bridge->dev, ATI_RS100_APSIZE, &temp);\r\ntemp = ((temp & ~(0x0000000f)) | previous_size->size_value);\r\npci_write_config_dword(agp_bridge->dev, ATI_RS100_APSIZE, temp);\r\n} else {\r\npci_read_config_dword(agp_bridge->dev, ATI_RS300_APSIZE, &temp);\r\ntemp = ((temp & ~(0x0000000f)) | previous_size->size_value);\r\npci_write_config_dword(agp_bridge->dev, ATI_RS300_APSIZE, temp);\r\n}\r\niounmap((volatile u8 __iomem *)ati_generic_private.registers);\r\n}\r\nstatic int ati_configure(void)\r\n{\r\nu32 temp;\r\npci_read_config_dword(agp_bridge->dev, ATI_GART_MMBASE_ADDR, &temp);\r\ntemp = (temp & 0xfffff000);\r\nati_generic_private.registers = (volatile u8 __iomem *) ioremap(temp, 4096);\r\nif (!ati_generic_private.registers)\r\nreturn -ENOMEM;\r\nif (is_r200())\r\npci_write_config_dword(agp_bridge->dev, ATI_RS100_IG_AGPMODE, 0x20000);\r\nelse\r\npci_write_config_dword(agp_bridge->dev, ATI_RS300_IG_AGPMODE, 0x20000);\r\nwritel(0x60000, ati_generic_private.registers+ATI_GART_FEATURE_ID);\r\nreadl(ati_generic_private.registers+ATI_GART_FEATURE_ID);\r\npci_read_config_dword(agp_bridge->dev, 4, &temp);\r\npci_write_config_dword(agp_bridge->dev, 4, temp | (1<<14));\r\nwritel(agp_bridge->gatt_bus_addr, ati_generic_private.registers+ATI_GART_BASE);\r\nreadl(ati_generic_private.registers+ATI_GART_BASE);\r\nreturn 0;\r\n}\r\nstatic int agp_ati_suspend(struct pci_dev *dev, pm_message_t state)\r\n{\r\npci_save_state(dev);\r\npci_set_power_state(dev, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int agp_ati_resume(struct pci_dev *dev)\r\n{\r\npci_set_power_state(dev, PCI_D0);\r\npci_restore_state(dev);\r\nreturn ati_configure();\r\n}\r\nstatic int ati_insert_memory(struct agp_memory * mem,\r\noff_t pg_start, int type)\r\n{\r\nint i, j, num_entries;\r\nunsigned long __iomem *cur_gatt;\r\nunsigned long addr;\r\nint mask_type;\r\nnum_entries = A_SIZE_LVL2(agp_bridge->current_size)->num_entries;\r\nmask_type = agp_generic_type_to_mask_type(mem->bridge, type);\r\nif (mask_type != 0 || type != mem->type)\r\nreturn -EINVAL;\r\nif (mem->page_count == 0)\r\nreturn 0;\r\nif ((pg_start + mem->page_count) > num_entries)\r\nreturn -EINVAL;\r\nj = pg_start;\r\nwhile (j < (pg_start + mem->page_count)) {\r\naddr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;\r\ncur_gatt = GET_GATT(addr);\r\nif (!PGE_EMPTY(agp_bridge,readl(cur_gatt+GET_GATT_OFF(addr))))\r\nreturn -EBUSY;\r\nj++;\r\n}\r\nif (!mem->is_flushed) {\r\nglobal_cache_flush();\r\nmem->is_flushed = true;\r\n}\r\nfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\r\naddr = (j * PAGE_SIZE) + agp_bridge->gart_bus_addr;\r\ncur_gatt = GET_GATT(addr);\r\nwritel(agp_bridge->driver->mask_memory(agp_bridge,\r\npage_to_phys(mem->pages[i]),\r\nmem->type),\r\ncur_gatt+GET_GATT_OFF(addr));\r\n}\r\nreadl(GET_GATT(agp_bridge->gart_bus_addr));\r\nagp_bridge->driver->tlb_flush(mem);\r\nreturn 0;\r\n}\r\nstatic int ati_remove_memory(struct agp_memory * mem, off_t pg_start,\r\nint type)\r\n{\r\nint i;\r\nunsigned long __iomem *cur_gatt;\r\nunsigned long addr;\r\nint mask_type;\r\nmask_type = agp_generic_type_to_mask_type(mem->bridge, type);\r\nif (mask_type != 0 || type != mem->type)\r\nreturn -EINVAL;\r\nif (mem->page_count == 0)\r\nreturn 0;\r\nfor (i = pg_start; i < (mem->page_count + pg_start); i++) {\r\naddr = (i * PAGE_SIZE) + agp_bridge->gart_bus_addr;\r\ncur_gatt = GET_GATT(addr);\r\nwritel(agp_bridge->scratch_page, cur_gatt+GET_GATT_OFF(addr));\r\n}\r\nreadl(GET_GATT(agp_bridge->gart_bus_addr));\r\nagp_bridge->driver->tlb_flush(mem);\r\nreturn 0;\r\n}\r\nstatic int ati_create_gatt_table(struct agp_bridge_data *bridge)\r\n{\r\nstruct aper_size_info_lvl2 *value;\r\nstruct ati_page_map page_dir;\r\nunsigned long __iomem *cur_gatt;\r\nunsigned long addr;\r\nint retval;\r\nu32 temp;\r\nint i;\r\nstruct aper_size_info_lvl2 *current_size;\r\nvalue = A_SIZE_LVL2(agp_bridge->current_size);\r\nretval = ati_create_page_map(&page_dir);\r\nif (retval != 0)\r\nreturn retval;\r\nretval = ati_create_gatt_pages(value->num_entries / 1024);\r\nif (retval != 0) {\r\nati_free_page_map(&page_dir);\r\nreturn retval;\r\n}\r\nagp_bridge->gatt_table_real = (u32 *)page_dir.real;\r\nagp_bridge->gatt_table = (u32 __iomem *) page_dir.remapped;\r\nagp_bridge->gatt_bus_addr = virt_to_phys(page_dir.real);\r\ncurrent_size = A_SIZE_LVL2(agp_bridge->current_size);\r\nif (is_r200()) {\r\npci_read_config_dword(agp_bridge->dev, ATI_RS100_APSIZE, &temp);\r\ntemp = (((temp & ~(0x0000000e)) | current_size->size_value)\r\n| 0x00000001);\r\npci_write_config_dword(agp_bridge->dev, ATI_RS100_APSIZE, temp);\r\npci_read_config_dword(agp_bridge->dev, ATI_RS100_APSIZE, &temp);\r\n} else {\r\npci_read_config_dword(agp_bridge->dev, ATI_RS300_APSIZE, &temp);\r\ntemp = (((temp & ~(0x0000000e)) | current_size->size_value)\r\n| 0x00000001);\r\npci_write_config_dword(agp_bridge->dev, ATI_RS300_APSIZE, temp);\r\npci_read_config_dword(agp_bridge->dev, ATI_RS300_APSIZE, &temp);\r\n}\r\npci_read_config_dword(agp_bridge->dev, AGP_APBASE, &temp);\r\naddr = (temp & PCI_BASE_ADDRESS_MEM_MASK);\r\nagp_bridge->gart_bus_addr = addr;\r\nfor (i = 0; i < value->num_entries / 1024; i++, addr += 0x00400000) {\r\nwritel(virt_to_phys(ati_generic_private.gatt_pages[i]->real) | 1,\r\npage_dir.remapped+GET_PAGE_DIR_OFF(addr));\r\nreadl(page_dir.remapped+GET_PAGE_DIR_OFF(addr));\r\n}\r\nfor (i = 0; i < value->num_entries; i++) {\r\naddr = (i * PAGE_SIZE) + agp_bridge->gart_bus_addr;\r\ncur_gatt = GET_GATT(addr);\r\nwritel(agp_bridge->scratch_page, cur_gatt+GET_GATT_OFF(addr));\r\n}\r\nreturn 0;\r\n}\r\nstatic int ati_free_gatt_table(struct agp_bridge_data *bridge)\r\n{\r\nstruct ati_page_map page_dir;\r\npage_dir.real = (unsigned long *)agp_bridge->gatt_table_real;\r\npage_dir.remapped = (unsigned long __iomem *)agp_bridge->gatt_table;\r\nati_free_gatt_pages();\r\nati_free_page_map(&page_dir);\r\nreturn 0;\r\n}\r\nstatic int agp_ati_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct agp_device_ids *devs = ati_agp_device_ids;\r\nstruct agp_bridge_data *bridge;\r\nu8 cap_ptr;\r\nint j;\r\ncap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);\r\nif (!cap_ptr)\r\nreturn -ENODEV;\r\nfor (j = 0; devs[j].chipset_name; j++) {\r\nif (pdev->device == devs[j].device_id)\r\ngoto found;\r\n}\r\ndev_err(&pdev->dev, "unsupported Ati chipset [%04x/%04x])\n",\r\npdev->vendor, pdev->device);\r\nreturn -ENODEV;\r\nfound:\r\nbridge = agp_alloc_bridge();\r\nif (!bridge)\r\nreturn -ENOMEM;\r\nbridge->dev = pdev;\r\nbridge->capndx = cap_ptr;\r\nbridge->driver = &ati_generic_bridge;\r\ndev_info(&pdev->dev, "Ati %s chipset\n", devs[j].chipset_name);\r\npci_read_config_dword(pdev,\r\nbridge->capndx+PCI_AGP_STATUS,\r\n&bridge->mode);\r\npci_set_drvdata(pdev, bridge);\r\nreturn agp_add_bridge(bridge);\r\n}\r\nstatic void agp_ati_remove(struct pci_dev *pdev)\r\n{\r\nstruct agp_bridge_data *bridge = pci_get_drvdata(pdev);\r\nagp_remove_bridge(bridge);\r\nagp_put_bridge(bridge);\r\n}\r\nstatic int __init agp_ati_init(void)\r\n{\r\nif (agp_off)\r\nreturn -EINVAL;\r\nreturn pci_register_driver(&agp_ati_pci_driver);\r\n}\r\nstatic void __exit agp_ati_cleanup(void)\r\n{\r\npci_unregister_driver(&agp_ati_pci_driver);\r\n}
