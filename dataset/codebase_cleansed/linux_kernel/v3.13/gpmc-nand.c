static bool gpmc_hwecc_bch_capable(enum omap_ecc ecc_opt)\r\n{\r\nif (!cpu_is_omap34xx() && !soc_is_am33xx()) {\r\npr_err("BCH ecc is not supported on this CPU\n");\r\nreturn 0;\r\n}\r\nif ((ecc_opt == OMAP_ECC_BCH4_CODE_HW) &&\r\n(!cpu_is_omap3630() || (GET_OMAP_REVISION() == 0)) &&\r\n(!soc_is_am33xx())) {\r\npr_err("BCH 4-bit mode is not supported on this CPU\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint gpmc_nand_init(struct omap_nand_platform_data *gpmc_nand_data,\r\nstruct gpmc_timings *gpmc_t)\r\n{\r\nint err = 0;\r\nstruct gpmc_settings s;\r\nstruct device *dev = &gpmc_nand_device.dev;\r\nmemset(&s, 0, sizeof(struct gpmc_settings));\r\ngpmc_nand_device.dev.platform_data = gpmc_nand_data;\r\nerr = gpmc_cs_request(gpmc_nand_data->cs, NAND_IO_SIZE,\r\n(unsigned long *)&gpmc_nand_resource[0].start);\r\nif (err < 0) {\r\ndev_err(dev, "Cannot request GPMC CS %d, error %d\n",\r\ngpmc_nand_data->cs, err);\r\nreturn err;\r\n}\r\ngpmc_nand_resource[0].end = gpmc_nand_resource[0].start +\r\nNAND_IO_SIZE - 1;\r\ngpmc_nand_resource[1].start =\r\ngpmc_get_client_irq(GPMC_IRQ_FIFOEVENTENABLE);\r\ngpmc_nand_resource[2].start =\r\ngpmc_get_client_irq(GPMC_IRQ_COUNT_EVENT);\r\nif (gpmc_t) {\r\nerr = gpmc_cs_set_timings(gpmc_nand_data->cs, gpmc_t);\r\nif (err < 0) {\r\ndev_err(dev, "Unable to set gpmc timings: %d\n", err);\r\nreturn err;\r\n}\r\nif (gpmc_nand_data->of_node) {\r\ngpmc_read_settings_dt(gpmc_nand_data->of_node, &s);\r\n} else {\r\nif (gpmc_nand_data->dev_ready) {\r\ns.wait_on_read = true;\r\ns.wait_on_write = true;\r\n}\r\n}\r\ns.device_nand = true;\r\nif (gpmc_nand_data->devsize == NAND_BUSWIDTH_16)\r\ns.device_width = GPMC_DEVWIDTH_16BIT;\r\nelse\r\ns.device_width = GPMC_DEVWIDTH_8BIT;\r\nerr = gpmc_cs_program_settings(gpmc_nand_data->cs, &s);\r\nif (err < 0)\r\ngoto out_free_cs;\r\nerr = gpmc_configure(GPMC_CONFIG_WP, 0);\r\nif (err < 0)\r\ngoto out_free_cs;\r\n}\r\ngpmc_update_nand_reg(&gpmc_nand_data->reg, gpmc_nand_data->cs);\r\nif (!gpmc_hwecc_bch_capable(gpmc_nand_data->ecc_opt))\r\nreturn -EINVAL;\r\nerr = platform_device_register(&gpmc_nand_device);\r\nif (err < 0) {\r\ndev_err(dev, "Unable to register NAND device\n");\r\ngoto out_free_cs;\r\n}\r\nreturn 0;\r\nout_free_cs:\r\ngpmc_cs_free(gpmc_nand_data->cs);\r\nreturn err;\r\n}
