static struct fpga_inode *find_inode(void *dev)\r\n{\r\nstruct fpga_inode *temp_chip = fpga_first_inode;\r\nif (temp_chip == NULL)\r\nreturn temp_chip;\r\nwhile ((temp_chip != NULL) &&\r\n(temp_chip->internal->dev != dev))\r\ntemp_chip = temp_chip->next_inode;\r\nreturn temp_chip;\r\n}\r\nstatic struct fpga_internal *check_filter(struct fpga_internal *temp_int,\r\nvoid *demux_dev, int filt_nr)\r\n{\r\nif (temp_int == NULL)\r\nreturn NULL;\r\nif ((temp_int->pid_filt[filt_nr]) == NULL)\r\nreturn NULL;\r\nif (temp_int->pid_filt[filt_nr]->demux == demux_dev)\r\nreturn temp_int;\r\nreturn NULL;\r\n}\r\nstatic struct fpga_inode *find_dinode(void *demux_dev)\r\n{\r\nstruct fpga_inode *temp_chip = fpga_first_inode;\r\nstruct fpga_internal *temp_int;\r\nwhile (temp_chip != NULL) {\r\nif (temp_chip->internal != NULL) {\r\ntemp_int = temp_chip->internal;\r\nif (check_filter(temp_int, demux_dev, 0))\r\nbreak;\r\nif (check_filter(temp_int, demux_dev, 1))\r\nbreak;\r\n}\r\ntemp_chip = temp_chip->next_inode;\r\n}\r\nreturn temp_chip;\r\n}\r\nstatic void remove_inode(struct fpga_internal *internal)\r\n{\r\nstruct fpga_inode *prev_node = fpga_first_inode;\r\nstruct fpga_inode *del_node = find_inode(internal->dev);\r\nif (del_node != NULL) {\r\nif (del_node == fpga_first_inode) {\r\nfpga_first_inode = del_node->next_inode;\r\n} else {\r\nwhile (prev_node->next_inode != del_node)\r\nprev_node = prev_node->next_inode;\r\nif (del_node->next_inode == NULL)\r\nprev_node->next_inode = NULL;\r\nelse\r\nprev_node->next_inode =\r\nprev_node->next_inode->next_inode;\r\n}\r\nkfree(del_node);\r\n}\r\n}\r\nstatic struct fpga_inode *append_internal(struct fpga_internal *internal)\r\n{\r\nstruct fpga_inode *new_node = fpga_first_inode;\r\nif (new_node == NULL) {\r\nnew_node = kmalloc(sizeof(struct fpga_inode), GFP_KERNEL);\r\nfpga_first_inode = new_node;\r\n} else {\r\nwhile (new_node->next_inode != NULL)\r\nnew_node = new_node->next_inode;\r\nnew_node->next_inode =\r\nkmalloc(sizeof(struct fpga_inode), GFP_KERNEL);\r\nif (new_node->next_inode != NULL)\r\nnew_node = new_node->next_inode;\r\nelse\r\nnew_node = NULL;\r\n}\r\nif (new_node != NULL) {\r\nnew_node->internal = internal;\r\nnew_node->next_inode = NULL;\r\n}\r\nreturn new_node;\r\n}\r\nstatic int netup_fpga_op_rw(struct fpga_internal *inter, int addr,\r\nu8 val, u8 read)\r\n{\r\ninter->fpga_rw(inter->dev, NETUP_CI_FLG_AD, addr, 0);\r\nreturn inter->fpga_rw(inter->dev, 0, val, read);\r\n}\r\nstatic int altera_ci_op_cam(struct dvb_ca_en50221 *en50221, int slot,\r\nu8 flag, u8 read, int addr, u8 val)\r\n{\r\nstruct altera_ci_state *state = en50221->data;\r\nstruct fpga_internal *inter = state->internal;\r\nu8 store;\r\nint mem = 0;\r\nif (0 != slot)\r\nreturn -EINVAL;\r\nmutex_lock(&inter->fpga_mutex);\r\nnetup_fpga_op_rw(inter, NETUP_CI_ADDR0, ((addr << 1) & 0xfe), 0);\r\nnetup_fpga_op_rw(inter, NETUP_CI_ADDR1, ((addr >> 7) & 0x7f), 0);\r\nstore = netup_fpga_op_rw(inter, NETUP_CI_BUSCTRL, 0, NETUP_CI_FLG_RD);\r\nstore &= 0x0f;\r\nstore |= ((state->nr << 7) | (flag << 6));\r\nnetup_fpga_op_rw(inter, NETUP_CI_BUSCTRL, store, 0);\r\nmem = netup_fpga_op_rw(inter, NETUP_CI_DATA, val, read);\r\nmutex_unlock(&inter->fpga_mutex);\r\nci_dbg_print("%s: %s: addr=[0x%02x], %s=%x\n", __func__,\r\n(read) ? "read" : "write", addr,\r\n(flag == NETUP_CI_FLG_CTL) ? "ctl" : "mem",\r\n(read) ? mem : val);\r\nreturn mem;\r\n}\r\nstatic int altera_ci_read_attribute_mem(struct dvb_ca_en50221 *en50221,\r\nint slot, int addr)\r\n{\r\nreturn altera_ci_op_cam(en50221, slot, 0, NETUP_CI_FLG_RD, addr, 0);\r\n}\r\nstatic int altera_ci_write_attribute_mem(struct dvb_ca_en50221 *en50221,\r\nint slot, int addr, u8 data)\r\n{\r\nreturn altera_ci_op_cam(en50221, slot, 0, 0, addr, data);\r\n}\r\nstatic int altera_ci_read_cam_ctl(struct dvb_ca_en50221 *en50221,\r\nint slot, u8 addr)\r\n{\r\nreturn altera_ci_op_cam(en50221, slot, NETUP_CI_FLG_CTL,\r\nNETUP_CI_FLG_RD, addr, 0);\r\n}\r\nstatic int altera_ci_write_cam_ctl(struct dvb_ca_en50221 *en50221, int slot,\r\nu8 addr, u8 data)\r\n{\r\nreturn altera_ci_op_cam(en50221, slot, NETUP_CI_FLG_CTL, 0, addr, data);\r\n}\r\nstatic int altera_ci_slot_reset(struct dvb_ca_en50221 *en50221, int slot)\r\n{\r\nstruct altera_ci_state *state = en50221->data;\r\nstruct fpga_internal *inter = state->internal;\r\nunsigned long t_out = jiffies + msecs_to_jiffies(9999);\r\nint ret;\r\nci_dbg_print("%s\n", __func__);\r\nif (0 != slot)\r\nreturn -EINVAL;\r\nmutex_lock(&inter->fpga_mutex);\r\nret = netup_fpga_op_rw(inter, NETUP_CI_BUSCTRL, 0, NETUP_CI_FLG_RD);\r\nnetup_fpga_op_rw(inter, NETUP_CI_BUSCTRL,\r\n(ret & 0xcf) | (1 << (5 - state->nr)), 0);\r\nmutex_unlock(&inter->fpga_mutex);\r\nfor (;;) {\r\nmdelay(50);\r\nmutex_lock(&inter->fpga_mutex);\r\nret = netup_fpga_op_rw(inter, NETUP_CI_BUSCTRL,\r\n0, NETUP_CI_FLG_RD);\r\nmutex_unlock(&inter->fpga_mutex);\r\nif ((ret & (1 << (5 - state->nr))) == 0)\r\nbreak;\r\nif (time_after(jiffies, t_out))\r\nbreak;\r\n}\r\nci_dbg_print("%s: %d msecs\n", __func__,\r\njiffies_to_msecs(jiffies + msecs_to_jiffies(9999) - t_out));\r\nreturn 0;\r\n}\r\nstatic int altera_ci_slot_shutdown(struct dvb_ca_en50221 *en50221, int slot)\r\n{\r\nreturn 0;\r\n}\r\nstatic int altera_ci_slot_ts_ctl(struct dvb_ca_en50221 *en50221, int slot)\r\n{\r\nstruct altera_ci_state *state = en50221->data;\r\nstruct fpga_internal *inter = state->internal;\r\nint ret;\r\nci_dbg_print("%s\n", __func__);\r\nif (0 != slot)\r\nreturn -EINVAL;\r\nmutex_lock(&inter->fpga_mutex);\r\nret = netup_fpga_op_rw(inter, NETUP_CI_BUSCTRL, 0, NETUP_CI_FLG_RD);\r\nnetup_fpga_op_rw(inter, NETUP_CI_BUSCTRL,\r\n(ret & 0x0f) | (1 << (3 - state->nr)), 0);\r\nmutex_unlock(&inter->fpga_mutex);\r\nreturn 0;\r\n}\r\nstatic void netup_read_ci_status(struct work_struct *work)\r\n{\r\nstruct fpga_internal *inter =\r\ncontainer_of(work, struct fpga_internal, work);\r\nint ret;\r\nci_dbg_print("%s\n", __func__);\r\nmutex_lock(&inter->fpga_mutex);\r\nret = netup_fpga_op_rw(inter, NETUP_CI_INT_CTRL, 0, NETUP_CI_FLG_RD);\r\nret = netup_fpga_op_rw(inter, NETUP_CI_BUSCTRL, 0, NETUP_CI_FLG_RD);\r\nmutex_unlock(&inter->fpga_mutex);\r\nif (inter->state[1] != NULL) {\r\ninter->state[1]->status =\r\n((ret & 1) == 0 ?\r\nDVB_CA_EN50221_POLL_CAM_PRESENT |\r\nDVB_CA_EN50221_POLL_CAM_READY : 0);\r\nci_dbg_print("%s: setting CI[1] status = 0x%x\n",\r\n__func__, inter->state[1]->status);\r\n}\r\nif (inter->state[0] != NULL) {\r\ninter->state[0]->status =\r\n((ret & 2) == 0 ?\r\nDVB_CA_EN50221_POLL_CAM_PRESENT |\r\nDVB_CA_EN50221_POLL_CAM_READY : 0);\r\nci_dbg_print("%s: setting CI[0] status = 0x%x\n",\r\n__func__, inter->state[0]->status);\r\n}\r\n}\r\nint altera_ci_irq(void *dev)\r\n{\r\nstruct fpga_inode *temp_int = NULL;\r\nstruct fpga_internal *inter = NULL;\r\nci_dbg_print("%s\n", __func__);\r\nif (dev != NULL) {\r\ntemp_int = find_inode(dev);\r\nif (temp_int != NULL) {\r\ninter = temp_int->internal;\r\nschedule_work(&inter->work);\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int altera_poll_ci_slot_status(struct dvb_ca_en50221 *en50221,\r\nint slot, int open)\r\n{\r\nstruct altera_ci_state *state = en50221->data;\r\nif (0 != slot)\r\nreturn -EINVAL;\r\nreturn state->status;\r\n}\r\nstatic void altera_hw_filt_release(void *main_dev, int filt_nr)\r\n{\r\nstruct fpga_inode *temp_int = find_inode(main_dev);\r\nstruct netup_hw_pid_filter *pid_filt = NULL;\r\nci_dbg_print("%s\n", __func__);\r\nif (temp_int != NULL) {\r\npid_filt = temp_int->internal->pid_filt[filt_nr - 1];\r\npid_filt->demux->start_feed = pid_filt->start_feed;\r\npid_filt->demux->stop_feed = pid_filt->stop_feed;\r\nif (((--(temp_int->internal->filts_used)) <= 0) &&\r\n((temp_int->internal->cis_used) <= 0)) {\r\nci_dbg_print("%s: Actually removing\n", __func__);\r\nremove_inode(temp_int->internal);\r\nkfree(pid_filt->internal);\r\n}\r\nkfree(pid_filt);\r\n}\r\n}\r\nvoid altera_ci_release(void *dev, int ci_nr)\r\n{\r\nstruct fpga_inode *temp_int = find_inode(dev);\r\nstruct altera_ci_state *state = NULL;\r\nci_dbg_print("%s\n", __func__);\r\nif (temp_int != NULL) {\r\nstate = temp_int->internal->state[ci_nr - 1];\r\naltera_hw_filt_release(dev, ci_nr);\r\nif (((temp_int->internal->filts_used) <= 0) &&\r\n((--(temp_int->internal->cis_used)) <= 0)) {\r\nci_dbg_print("%s: Actually removing\n", __func__);\r\nremove_inode(temp_int->internal);\r\nkfree(state->internal);\r\n}\r\nif (state != NULL) {\r\nif (state->ca.data != NULL)\r\ndvb_ca_en50221_release(&state->ca);\r\nkfree(state);\r\n}\r\n}\r\n}\r\nstatic void altera_pid_control(struct netup_hw_pid_filter *pid_filt,\r\nu16 pid, int onoff)\r\n{\r\nstruct fpga_internal *inter = pid_filt->internal;\r\nu8 store = 0;\r\nif ((pid == 0x2000) || (pid < 0x20))\r\nreturn;\r\nmutex_lock(&inter->fpga_mutex);\r\nnetup_fpga_op_rw(inter, NETUP_CI_PID_ADDR0, (pid >> 3) & 0xff, 0);\r\nnetup_fpga_op_rw(inter, NETUP_CI_PID_ADDR1,\r\n((pid >> 11) & 0x03) | (pid_filt->nr << 2), 0);\r\nstore = netup_fpga_op_rw(inter, NETUP_CI_PID_DATA, 0, NETUP_CI_FLG_RD);\r\nif (onoff)\r\nstore |= (1 << (pid & 7));\r\nelse\r\nstore &= ~(1 << (pid & 7));\r\nnetup_fpga_op_rw(inter, NETUP_CI_PID_DATA, store, 0);\r\nmutex_unlock(&inter->fpga_mutex);\r\npid_dbg_print("%s: (%d) set pid: %5d 0x%04x '%s'\n", __func__,\r\npid_filt->nr, pid, pid, onoff ? "off" : "on");\r\n}\r\nstatic void altera_toggle_fullts_streaming(struct netup_hw_pid_filter *pid_filt,\r\nint filt_nr, int onoff)\r\n{\r\nstruct fpga_internal *inter = pid_filt->internal;\r\nu8 store = 0;\r\nint i;\r\npid_dbg_print("%s: pid_filt->nr[%d] now %s\n", __func__, pid_filt->nr,\r\nonoff ? "off" : "on");\r\nif (onoff)\r\nstore = 0xff;\r\nelse\r\nstore = 0;\r\nmutex_lock(&inter->fpga_mutex);\r\nfor (i = 0; i < 1024; i++) {\r\nnetup_fpga_op_rw(inter, NETUP_CI_PID_ADDR0, i & 0xff, 0);\r\nnetup_fpga_op_rw(inter, NETUP_CI_PID_ADDR1,\r\n((i >> 8) & 0x03) | (pid_filt->nr << 2), 0);\r\nnetup_fpga_op_rw(inter, NETUP_CI_PID_DATA,\r\n(i > 3 ? store : 0), 0);\r\n}\r\nmutex_unlock(&inter->fpga_mutex);\r\n}\r\nstatic int altera_pid_feed_control(void *demux_dev, int filt_nr,\r\nstruct dvb_demux_feed *feed, int onoff)\r\n{\r\nstruct fpga_inode *temp_int = find_dinode(demux_dev);\r\nstruct fpga_internal *inter = temp_int->internal;\r\nstruct netup_hw_pid_filter *pid_filt = inter->pid_filt[filt_nr - 1];\r\naltera_pid_control(pid_filt, feed->pid, onoff ? 0 : 1);\r\nif (onoff)\r\npid_filt->start_feed(feed);\r\nelse\r\npid_filt->stop_feed(feed);\r\nif (feed->pid == 0x2000)\r\naltera_toggle_fullts_streaming(pid_filt, filt_nr,\r\nonoff ? 0 : 1);\r\nreturn 0;\r\n}\r\nstatic int altera_ci_start_feed(struct dvb_demux_feed *feed, int num)\r\n{\r\naltera_pid_feed_control(feed->demux, num, feed, 1);\r\nreturn 0;\r\n}\r\nstatic int altera_ci_stop_feed(struct dvb_demux_feed *feed, int num)\r\n{\r\naltera_pid_feed_control(feed->demux, num, feed, 0);\r\nreturn 0;\r\n}\r\nstatic int altera_ci_start_feed_1(struct dvb_demux_feed *feed)\r\n{\r\nreturn altera_ci_start_feed(feed, 1);\r\n}\r\nstatic int altera_ci_stop_feed_1(struct dvb_demux_feed *feed)\r\n{\r\nreturn altera_ci_stop_feed(feed, 1);\r\n}\r\nstatic int altera_ci_start_feed_2(struct dvb_demux_feed *feed)\r\n{\r\nreturn altera_ci_start_feed(feed, 2);\r\n}\r\nstatic int altera_ci_stop_feed_2(struct dvb_demux_feed *feed)\r\n{\r\nreturn altera_ci_stop_feed(feed, 2);\r\n}\r\nstatic int altera_hw_filt_init(struct altera_ci_config *config, int hw_filt_nr)\r\n{\r\nstruct netup_hw_pid_filter *pid_filt = NULL;\r\nstruct fpga_inode *temp_int = find_inode(config->dev);\r\nstruct fpga_internal *inter = NULL;\r\nint ret = 0;\r\npid_filt = kzalloc(sizeof(struct netup_hw_pid_filter), GFP_KERNEL);\r\nci_dbg_print("%s\n", __func__);\r\nif (!pid_filt) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nif (temp_int != NULL) {\r\ninter = temp_int->internal;\r\n(inter->filts_used)++;\r\nci_dbg_print("%s: Find Internal Structure!\n", __func__);\r\n} else {\r\ninter = kzalloc(sizeof(struct fpga_internal), GFP_KERNEL);\r\nif (!inter) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ntemp_int = append_internal(inter);\r\ninter->filts_used = 1;\r\ninter->dev = config->dev;\r\ninter->fpga_rw = config->fpga_rw;\r\nmutex_init(&inter->fpga_mutex);\r\ninter->strt_wrk = 1;\r\nci_dbg_print("%s: Create New Internal Structure!\n", __func__);\r\n}\r\nci_dbg_print("%s: setting hw pid filter = %p for ci = %d\n", __func__,\r\npid_filt, hw_filt_nr - 1);\r\ninter->pid_filt[hw_filt_nr - 1] = pid_filt;\r\npid_filt->demux = config->demux;\r\npid_filt->internal = inter;\r\npid_filt->nr = hw_filt_nr - 1;\r\npid_filt->start_feed = config->demux->start_feed;\r\npid_filt->stop_feed = config->demux->stop_feed;\r\nif (hw_filt_nr == 1) {\r\npid_filt->demux->start_feed = altera_ci_start_feed_1;\r\npid_filt->demux->stop_feed = altera_ci_stop_feed_1;\r\n} else if (hw_filt_nr == 2) {\r\npid_filt->demux->start_feed = altera_ci_start_feed_2;\r\npid_filt->demux->stop_feed = altera_ci_stop_feed_2;\r\n}\r\naltera_toggle_fullts_streaming(pid_filt, 0, 1);\r\nreturn 0;\r\nerr:\r\nci_dbg_print("%s: Can't init hardware filter: Error %d\n",\r\n__func__, ret);\r\nkfree(pid_filt);\r\nreturn ret;\r\n}\r\nint altera_ci_init(struct altera_ci_config *config, int ci_nr)\r\n{\r\nstruct altera_ci_state *state;\r\nstruct fpga_inode *temp_int = find_inode(config->dev);\r\nstruct fpga_internal *inter = NULL;\r\nint ret = 0;\r\nu8 store = 0;\r\nstate = kzalloc(sizeof(struct altera_ci_state), GFP_KERNEL);\r\nci_dbg_print("%s\n", __func__);\r\nif (!state) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nif (temp_int != NULL) {\r\ninter = temp_int->internal;\r\n(inter->cis_used)++;\r\ninter->fpga_rw = config->fpga_rw;\r\nci_dbg_print("%s: Find Internal Structure!\n", __func__);\r\n} else {\r\ninter = kzalloc(sizeof(struct fpga_internal), GFP_KERNEL);\r\nif (!inter) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ntemp_int = append_internal(inter);\r\ninter->cis_used = 1;\r\ninter->dev = config->dev;\r\ninter->fpga_rw = config->fpga_rw;\r\nmutex_init(&inter->fpga_mutex);\r\ninter->strt_wrk = 1;\r\nci_dbg_print("%s: Create New Internal Structure!\n", __func__);\r\n}\r\nci_dbg_print("%s: setting state = %p for ci = %d\n", __func__,\r\nstate, ci_nr - 1);\r\nstate->internal = inter;\r\nstate->nr = ci_nr - 1;\r\nstate->ca.owner = THIS_MODULE;\r\nstate->ca.read_attribute_mem = altera_ci_read_attribute_mem;\r\nstate->ca.write_attribute_mem = altera_ci_write_attribute_mem;\r\nstate->ca.read_cam_control = altera_ci_read_cam_ctl;\r\nstate->ca.write_cam_control = altera_ci_write_cam_ctl;\r\nstate->ca.slot_reset = altera_ci_slot_reset;\r\nstate->ca.slot_shutdown = altera_ci_slot_shutdown;\r\nstate->ca.slot_ts_enable = altera_ci_slot_ts_ctl;\r\nstate->ca.poll_slot_status = altera_poll_ci_slot_status;\r\nstate->ca.data = state;\r\nret = dvb_ca_en50221_init(config->adapter,\r\n&state->ca,\r\n0,\r\n1);\r\nif (0 != ret)\r\ngoto err;\r\ninter->state[ci_nr - 1] = state;\r\naltera_hw_filt_init(config, ci_nr);\r\nif (inter->strt_wrk) {\r\nINIT_WORK(&inter->work, netup_read_ci_status);\r\ninter->strt_wrk = 0;\r\n}\r\nci_dbg_print("%s: CI initialized!\n", __func__);\r\nmutex_lock(&inter->fpga_mutex);\r\nnetup_fpga_op_rw(inter, NETUP_CI_TSA_DIV, 0x0, 0);\r\nnetup_fpga_op_rw(inter, NETUP_CI_TSB_DIV, 0x0, 0);\r\nstore = netup_fpga_op_rw(inter, NETUP_CI_BUSCTRL2, 0, NETUP_CI_FLG_RD);\r\nstore |= (3 << 4);\r\nnetup_fpga_op_rw(inter, NETUP_CI_BUSCTRL2, store, 0);\r\nret = netup_fpga_op_rw(inter, NETUP_CI_REVISION, 0, NETUP_CI_FLG_RD);\r\nnetup_fpga_op_rw(inter, NETUP_CI_INT_CTRL, 0x44, 0);\r\nmutex_unlock(&inter->fpga_mutex);\r\nci_dbg_print("%s: NetUP CI Revision = 0x%x\n", __func__, ret);\r\nschedule_work(&inter->work);\r\nreturn 0;\r\nerr:\r\nci_dbg_print("%s: Cannot initialize CI: Error %d.\n", __func__, ret);\r\nkfree(state);\r\nreturn ret;\r\n}\r\nint altera_ci_tuner_reset(void *dev, int ci_nr)\r\n{\r\nstruct fpga_inode *temp_int = find_inode(dev);\r\nstruct fpga_internal *inter = NULL;\r\nu8 store;\r\nci_dbg_print("%s\n", __func__);\r\nif (temp_int == NULL)\r\nreturn -1;\r\nif (temp_int->internal == NULL)\r\nreturn -1;\r\ninter = temp_int->internal;\r\nmutex_lock(&inter->fpga_mutex);\r\nstore = netup_fpga_op_rw(inter, NETUP_CI_BUSCTRL2, 0, NETUP_CI_FLG_RD);\r\nstore &= ~(4 << (2 - ci_nr));\r\nnetup_fpga_op_rw(inter, NETUP_CI_BUSCTRL2, store, 0);\r\nmsleep(100);\r\nstore |= (4 << (2 - ci_nr));\r\nnetup_fpga_op_rw(inter, NETUP_CI_BUSCTRL2, store, 0);\r\nmutex_unlock(&inter->fpga_mutex);\r\nreturn 0;\r\n}
