int cros_ec_prepare_tx(struct cros_ec_device *ec_dev,\r\nstruct cros_ec_msg *msg)\r\n{\r\nuint8_t *out;\r\nint csum, i;\r\nBUG_ON(msg->out_len > EC_HOST_PARAM_SIZE);\r\nout = ec_dev->dout;\r\nout[0] = EC_CMD_VERSION0 + msg->version;\r\nout[1] = msg->cmd;\r\nout[2] = msg->out_len;\r\ncsum = out[0] + out[1] + out[2];\r\nfor (i = 0; i < msg->out_len; i++)\r\ncsum += out[EC_MSG_TX_HEADER_BYTES + i] = msg->out_buf[i];\r\nout[EC_MSG_TX_HEADER_BYTES + msg->out_len] = (uint8_t)(csum & 0xff);\r\nreturn EC_MSG_TX_PROTO_BYTES + msg->out_len;\r\n}\r\nstatic int cros_ec_command_sendrecv(struct cros_ec_device *ec_dev,\r\nuint16_t cmd, void *out_buf, int out_len,\r\nvoid *in_buf, int in_len)\r\n{\r\nstruct cros_ec_msg msg;\r\nmsg.version = cmd >> 8;\r\nmsg.cmd = cmd & 0xff;\r\nmsg.out_buf = out_buf;\r\nmsg.out_len = out_len;\r\nmsg.in_buf = in_buf;\r\nmsg.in_len = in_len;\r\nreturn ec_dev->command_xfer(ec_dev, &msg);\r\n}\r\nstatic int cros_ec_command_recv(struct cros_ec_device *ec_dev,\r\nuint16_t cmd, void *buf, int buf_len)\r\n{\r\nreturn cros_ec_command_sendrecv(ec_dev, cmd, NULL, 0, buf, buf_len);\r\n}\r\nstatic int cros_ec_command_send(struct cros_ec_device *ec_dev,\r\nuint16_t cmd, void *buf, int buf_len)\r\n{\r\nreturn cros_ec_command_sendrecv(ec_dev, cmd, buf, buf_len, NULL, 0);\r\n}\r\nstatic irqreturn_t ec_irq_thread(int irq, void *data)\r\n{\r\nstruct cros_ec_device *ec_dev = data;\r\nif (device_may_wakeup(ec_dev->dev))\r\npm_wakeup_event(ec_dev->dev, 0);\r\nblocking_notifier_call_chain(&ec_dev->event_notifier, 1, ec_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nint cros_ec_register(struct cros_ec_device *ec_dev)\r\n{\r\nstruct device *dev = ec_dev->dev;\r\nint err = 0;\r\nBLOCKING_INIT_NOTIFIER_HEAD(&ec_dev->event_notifier);\r\nec_dev->command_send = cros_ec_command_send;\r\nec_dev->command_recv = cros_ec_command_recv;\r\nec_dev->command_sendrecv = cros_ec_command_sendrecv;\r\nif (ec_dev->din_size) {\r\nec_dev->din = devm_kzalloc(dev, ec_dev->din_size, GFP_KERNEL);\r\nif (!ec_dev->din)\r\nreturn -ENOMEM;\r\n}\r\nif (ec_dev->dout_size) {\r\nec_dev->dout = devm_kzalloc(dev, ec_dev->dout_size, GFP_KERNEL);\r\nif (!ec_dev->dout)\r\nreturn -ENOMEM;\r\n}\r\nif (!ec_dev->irq) {\r\ndev_dbg(dev, "no valid IRQ: %d\n", ec_dev->irq);\r\nreturn err;\r\n}\r\nerr = request_threaded_irq(ec_dev->irq, NULL, ec_irq_thread,\r\nIRQF_TRIGGER_LOW | IRQF_ONESHOT,\r\n"chromeos-ec", ec_dev);\r\nif (err) {\r\ndev_err(dev, "request irq %d: error %d\n", ec_dev->irq, err);\r\nreturn err;\r\n}\r\nerr = mfd_add_devices(dev, 0, cros_devs,\r\nARRAY_SIZE(cros_devs),\r\nNULL, ec_dev->irq, NULL);\r\nif (err) {\r\ndev_err(dev, "failed to add mfd devices\n");\r\ngoto fail_mfd;\r\n}\r\ndev_info(dev, "Chrome EC (%s)\n", ec_dev->name);\r\nreturn 0;\r\nfail_mfd:\r\nfree_irq(ec_dev->irq, ec_dev);\r\nreturn err;\r\n}\r\nint cros_ec_remove(struct cros_ec_device *ec_dev)\r\n{\r\nmfd_remove_devices(ec_dev->dev);\r\nfree_irq(ec_dev->irq, ec_dev);\r\nreturn 0;\r\n}\r\nint cros_ec_suspend(struct cros_ec_device *ec_dev)\r\n{\r\nstruct device *dev = ec_dev->dev;\r\nif (device_may_wakeup(dev))\r\nec_dev->wake_enabled = !enable_irq_wake(ec_dev->irq);\r\ndisable_irq(ec_dev->irq);\r\nec_dev->was_wake_device = ec_dev->wake_enabled;\r\nreturn 0;\r\n}\r\nint cros_ec_resume(struct cros_ec_device *ec_dev)\r\n{\r\nenable_irq(ec_dev->irq);\r\nif (ec_dev->wake_enabled) {\r\ndisable_irq_wake(ec_dev->irq);\r\nec_dev->wake_enabled = 0;\r\n}\r\nreturn 0;\r\n}
