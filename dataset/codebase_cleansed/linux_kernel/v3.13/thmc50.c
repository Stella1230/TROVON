static ssize_t show_analog_out(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct thmc50_data *data = thmc50_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->analog_out);\r\n}\r\nstatic ssize_t set_analog_out(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct thmc50_data *data = i2c_get_clientdata(client);\r\nint config;\r\nunsigned long tmp;\r\nint err;\r\nerr = kstrtoul(buf, 10, &tmp);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->analog_out = clamp_val(tmp, 0, 255);\r\ni2c_smbus_write_byte_data(client, THMC50_REG_ANALOG_OUT,\r\ndata->analog_out);\r\nconfig = i2c_smbus_read_byte_data(client, THMC50_REG_CONF);\r\nif (data->analog_out == 0)\r\nconfig &= ~THMC50_REG_CONF_nFANOFF;\r\nelse\r\nconfig |= THMC50_REG_CONF_nFANOFF;\r\ni2c_smbus_write_byte_data(client, THMC50_REG_CONF, config);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_mode(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct thmc50_data *data = thmc50_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->temp_input[nr] * 1000);\r\n}\r\nstatic ssize_t show_temp_min(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct thmc50_data *data = thmc50_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->temp_min[nr] * 1000);\r\n}\r\nstatic ssize_t set_temp_min(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct thmc50_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_min[nr] = clamp_val(val / 1000, -128, 127);\r\ni2c_smbus_write_byte_data(client, THMC50_REG_TEMP_MIN[nr],\r\ndata->temp_min[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_max(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct thmc50_data *data = thmc50_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->temp_max[nr] * 1000);\r\n}\r\nstatic ssize_t set_temp_max(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct thmc50_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_max[nr] = clamp_val(val / 1000, -128, 127);\r\ni2c_smbus_write_byte_data(client, THMC50_REG_TEMP_MAX[nr],\r\ndata->temp_max[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_critical(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint nr = to_sensor_dev_attr(attr)->index;\r\nstruct thmc50_data *data = thmc50_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->temp_critical[nr] * 1000);\r\n}\r\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint index = to_sensor_dev_attr(attr)->index;\r\nstruct thmc50_data *data = thmc50_update_device(dev);\r\nreturn sprintf(buf, "%u\n", (data->alarms >> index) & 1);\r\n}\r\nstatic int thmc50_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nunsigned company;\r\nunsigned revision;\r\nunsigned config;\r\nstruct i2c_adapter *adapter = client->adapter;\r\nconst char *type_name;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\npr_debug("thmc50: detect failed, smbus byte data not supported!\n");\r\nreturn -ENODEV;\r\n}\r\npr_debug("thmc50: Probing for THMC50 at 0x%2X on bus %d\n",\r\nclient->addr, i2c_adapter_id(client->adapter));\r\ncompany = i2c_smbus_read_byte_data(client, THMC50_REG_COMPANY_ID);\r\nrevision = i2c_smbus_read_byte_data(client, THMC50_REG_DIE_CODE);\r\nconfig = i2c_smbus_read_byte_data(client, THMC50_REG_CONF);\r\nif (revision < 0xc0 || (config & 0x10))\r\nreturn -ENODEV;\r\nif (company == 0x41) {\r\nint id = i2c_adapter_id(client->adapter);\r\nint i;\r\ntype_name = "adm1022";\r\nfor (i = 0; i + 1 < adm1022_temp3_num; i += 2)\r\nif (adm1022_temp3[i] == id &&\r\nadm1022_temp3[i + 1] == client->addr) {\r\nconfig |= (1 << 7);\r\ni2c_smbus_write_byte_data(client,\r\nTHMC50_REG_CONF,\r\nconfig);\r\nbreak;\r\n}\r\n} else if (company == 0x49) {\r\ntype_name = "thmc50";\r\n} else {\r\npr_debug("thmc50: Detection of THMC50/ADM1022 failed\n");\r\nreturn -ENODEV;\r\n}\r\npr_debug("thmc50: Detected %s (version %x, revision %x)\n",\r\ntype_name, (revision >> 4) - 0xc, revision & 0xf);\r\nstrlcpy(info->type, type_name, I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int thmc50_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct thmc50_data *data;\r\nint err;\r\ndata = devm_kzalloc(&client->dev, sizeof(struct thmc50_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\ndata->type = id->driver_data;\r\nmutex_init(&data->update_lock);\r\nthmc50_init_client(client);\r\nerr = sysfs_create_group(&client->dev.kobj, &thmc50_group);\r\nif (err)\r\nreturn err;\r\nif (data->has_temp3) {\r\nerr = sysfs_create_group(&client->dev.kobj, &temp3_group);\r\nif (err)\r\ngoto exit_remove_sysfs_thmc50;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove_sysfs;\r\n}\r\nreturn 0;\r\nexit_remove_sysfs:\r\nif (data->has_temp3)\r\nsysfs_remove_group(&client->dev.kobj, &temp3_group);\r\nexit_remove_sysfs_thmc50:\r\nsysfs_remove_group(&client->dev.kobj, &thmc50_group);\r\nreturn err;\r\n}\r\nstatic int thmc50_remove(struct i2c_client *client)\r\n{\r\nstruct thmc50_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &thmc50_group);\r\nif (data->has_temp3)\r\nsysfs_remove_group(&client->dev.kobj, &temp3_group);\r\nreturn 0;\r\n}\r\nstatic void thmc50_init_client(struct i2c_client *client)\r\n{\r\nstruct thmc50_data *data = i2c_get_clientdata(client);\r\nint config;\r\ndata->analog_out = i2c_smbus_read_byte_data(client,\r\nTHMC50_REG_ANALOG_OUT);\r\nif (data->analog_out == 0) {\r\ndata->analog_out = 1;\r\ni2c_smbus_write_byte_data(client, THMC50_REG_ANALOG_OUT,\r\ndata->analog_out);\r\n}\r\nconfig = i2c_smbus_read_byte_data(client, THMC50_REG_CONF);\r\nconfig |= 0x1;\r\nif (data->type == adm1022 && (config & (1 << 7)))\r\ndata->has_temp3 = 1;\r\ni2c_smbus_write_byte_data(client, THMC50_REG_CONF, config);\r\n}\r\nstatic struct thmc50_data *thmc50_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct thmc50_data *data = i2c_get_clientdata(client);\r\nint timeout = HZ / 5 + (data->type == thmc50 ? HZ : 0);\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + timeout)\r\n|| !data->valid) {\r\nint temps = data->has_temp3 ? 3 : 2;\r\nint i;\r\nint prog = i2c_smbus_read_byte_data(client, THMC50_REG_CONF);\r\nprog &= THMC50_REG_CONF_PROGRAMMED;\r\nfor (i = 0; i < temps; i++) {\r\ndata->temp_input[i] = i2c_smbus_read_byte_data(client,\r\nTHMC50_REG_TEMP[i]);\r\ndata->temp_max[i] = i2c_smbus_read_byte_data(client,\r\nTHMC50_REG_TEMP_MAX[i]);\r\ndata->temp_min[i] = i2c_smbus_read_byte_data(client,\r\nTHMC50_REG_TEMP_MIN[i]);\r\ndata->temp_critical[i] =\r\ni2c_smbus_read_byte_data(client,\r\nprog ? THMC50_REG_TEMP_CRITICAL[i]\r\n: THMC50_REG_TEMP_DEFAULT[i]);\r\n}\r\ndata->analog_out =\r\ni2c_smbus_read_byte_data(client, THMC50_REG_ANALOG_OUT);\r\ndata->alarms =\r\ni2c_smbus_read_byte_data(client, THMC50_REG_INTR);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}
