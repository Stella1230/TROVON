s64 ieee754sp_tlong(ieee754sp x)\r\n{\r\nCOMPXDP;\r\nCLEARCX;\r\nEXPLODEXSP;\r\nFLUSHXSP;\r\nswitch (xc) {\r\ncase IEEE754_CLASS_SNAN:\r\ncase IEEE754_CLASS_QNAN:\r\ncase IEEE754_CLASS_INF:\r\nSETCX(IEEE754_INVALID_OPERATION);\r\nreturn ieee754di_xcpt(ieee754di_indef(), "sp_tlong", x);\r\ncase IEEE754_CLASS_ZERO:\r\nreturn 0;\r\ncase IEEE754_CLASS_DNORM:\r\ncase IEEE754_CLASS_NORM:\r\nbreak;\r\n}\r\nif (xe >= 63) {\r\nif (xe == 63 && xs && xm == SP_HIDDEN_BIT)\r\nreturn -0x8000000000000000LL;\r\nSETCX(IEEE754_INVALID_OPERATION);\r\nreturn ieee754di_xcpt(ieee754di_indef(), "sp_tlong", x);\r\n}\r\nif (xe > SP_MBITS) {\r\nxm <<= xe - SP_MBITS;\r\n} else if (xe < SP_MBITS) {\r\nu32 residue;\r\nint round;\r\nint sticky;\r\nint odd;\r\nif (xe < -1) {\r\nresidue = xm;\r\nround = 0;\r\nsticky = residue != 0;\r\nxm = 0;\r\n} else {\r\nresidue = xm << (32 - SP_MBITS + xe);\r\nround = (residue >> 31) != 0;\r\nsticky = (residue << 1) != 0;\r\nxm >>= SP_MBITS - xe;\r\n}\r\nodd = (xm & 0x1) != 0x0;\r\nswitch (ieee754_csr.rm) {\r\ncase IEEE754_RN:\r\nif (round && (sticky || odd))\r\nxm++;\r\nbreak;\r\ncase IEEE754_RZ:\r\nbreak;\r\ncase IEEE754_RU:\r\nif ((round || sticky) && !xs)\r\nxm++;\r\nbreak;\r\ncase IEEE754_RD:\r\nif ((round || sticky) && xs)\r\nxm++;\r\nbreak;\r\n}\r\nif ((xm >> 63) != 0) {\r\nSETCX(IEEE754_INVALID_OPERATION);\r\nreturn ieee754di_xcpt(ieee754di_indef(), "sp_tlong", x);\r\n}\r\nif (round || sticky)\r\nSETCX(IEEE754_INEXACT);\r\n}\r\nif (xs)\r\nreturn -xm;\r\nelse\r\nreturn xm;\r\n}\r\nu64 ieee754sp_tulong(ieee754sp x)\r\n{\r\nieee754sp hb = ieee754sp_1e63();\r\nif (ieee754sp_lt(x, hb))\r\nreturn (u64) ieee754sp_tlong(x);\r\nreturn (u64) ieee754sp_tlong(ieee754sp_sub(x, hb)) |\r\n(1ULL << 63);\r\n}
