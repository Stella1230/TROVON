static void falcon_setsda(void *data, int state)\r\n{\r\nstruct efx_nic *efx = (struct efx_nic *)data;\r\nefx_oword_t reg;\r\nefx_reado(efx, &reg, FR_AB_GPIO_CTL);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_GPIO3_OEN, !state);\r\nefx_writeo(efx, &reg, FR_AB_GPIO_CTL);\r\n}\r\nstatic void falcon_setscl(void *data, int state)\r\n{\r\nstruct efx_nic *efx = (struct efx_nic *)data;\r\nefx_oword_t reg;\r\nefx_reado(efx, &reg, FR_AB_GPIO_CTL);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_GPIO0_OEN, !state);\r\nefx_writeo(efx, &reg, FR_AB_GPIO_CTL);\r\n}\r\nstatic int falcon_getsda(void *data)\r\n{\r\nstruct efx_nic *efx = (struct efx_nic *)data;\r\nefx_oword_t reg;\r\nefx_reado(efx, &reg, FR_AB_GPIO_CTL);\r\nreturn EFX_OWORD_FIELD(reg, FRF_AB_GPIO3_IN);\r\n}\r\nstatic int falcon_getscl(void *data)\r\n{\r\nstruct efx_nic *efx = (struct efx_nic *)data;\r\nefx_oword_t reg;\r\nefx_reado(efx, &reg, FR_AB_GPIO_CTL);\r\nreturn EFX_OWORD_FIELD(reg, FRF_AB_GPIO0_IN);\r\n}\r\nstatic void falcon_push_irq_moderation(struct efx_channel *channel)\r\n{\r\nefx_dword_t timer_cmd;\r\nstruct efx_nic *efx = channel->efx;\r\nif (channel->irq_moderation) {\r\nEFX_POPULATE_DWORD_2(timer_cmd,\r\nFRF_AB_TC_TIMER_MODE,\r\nFFE_BB_TIMER_MODE_INT_HLDOFF,\r\nFRF_AB_TC_TIMER_VAL,\r\nchannel->irq_moderation - 1);\r\n} else {\r\nEFX_POPULATE_DWORD_2(timer_cmd,\r\nFRF_AB_TC_TIMER_MODE,\r\nFFE_BB_TIMER_MODE_DIS,\r\nFRF_AB_TC_TIMER_VAL, 0);\r\n}\r\nBUILD_BUG_ON(FR_AA_TIMER_COMMAND_KER != FR_BZ_TIMER_COMMAND_P0);\r\nefx_writed_page_locked(efx, &timer_cmd, FR_BZ_TIMER_COMMAND_P0,\r\nchannel->channel);\r\n}\r\nstatic void falcon_prepare_flush(struct efx_nic *efx)\r\n{\r\nfalcon_deconfigure_mac_wrapper(efx);\r\nmsleep(10);\r\n}\r\nstatic inline void falcon_irq_ack_a1(struct efx_nic *efx)\r\n{\r\nefx_dword_t reg;\r\nEFX_POPULATE_DWORD_1(reg, FRF_AA_INT_ACK_KER_FIELD, 0xb7eb7e);\r\nefx_writed(efx, &reg, FR_AA_INT_ACK_KER);\r\nefx_readd(efx, &reg, FR_AA_WORK_AROUND_BROKEN_PCI_READS);\r\n}\r\nstatic irqreturn_t falcon_legacy_interrupt_a1(int irq, void *dev_id)\r\n{\r\nstruct efx_nic *efx = dev_id;\r\nefx_oword_t *int_ker = efx->irq_status.addr;\r\nint syserr;\r\nint queues;\r\nif (unlikely(EFX_OWORD_IS_ZERO(*int_ker))) {\r\nnetif_vdbg(efx, intr, efx->net_dev,\r\n"IRQ %d on CPU %d not for me\n", irq,\r\nraw_smp_processor_id());\r\nreturn IRQ_NONE;\r\n}\r\nefx->last_irq_cpu = raw_smp_processor_id();\r\nnetif_vdbg(efx, intr, efx->net_dev,\r\n"IRQ %d on CPU %d status " EFX_OWORD_FMT "\n",\r\nirq, raw_smp_processor_id(), EFX_OWORD_VAL(*int_ker));\r\nif (!likely(ACCESS_ONCE(efx->irq_soft_enabled)))\r\nreturn IRQ_HANDLED;\r\nsyserr = EFX_OWORD_FIELD(*int_ker, FSF_AZ_NET_IVEC_FATAL_INT);\r\nif (unlikely(syserr))\r\nreturn efx_farch_fatal_interrupt(efx);\r\nBUILD_BUG_ON(FSF_AZ_NET_IVEC_INT_Q_WIDTH > EFX_MAX_CHANNELS);\r\nqueues = EFX_OWORD_FIELD(*int_ker, FSF_AZ_NET_IVEC_INT_Q);\r\nEFX_ZERO_OWORD(*int_ker);\r\nwmb();\r\nfalcon_irq_ack_a1(efx);\r\nif (queues & 1)\r\nefx_schedule_channel_irq(efx_get_channel(efx, 0));\r\nif (queues & 2)\r\nefx_schedule_channel_irq(efx_get_channel(efx, 1));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int falcon_spi_poll(struct efx_nic *efx)\r\n{\r\nefx_oword_t reg;\r\nefx_reado(efx, &reg, FR_AB_EE_SPI_HCMD);\r\nreturn EFX_OWORD_FIELD(reg, FRF_AB_EE_SPI_HCMD_CMD_EN) ? -EBUSY : 0;\r\n}\r\nstatic int falcon_spi_wait(struct efx_nic *efx)\r\n{\r\nunsigned long timeout = jiffies + 1 + DIV_ROUND_UP(HZ, 10);\r\nint i;\r\nfor (i = 0; i < 10; i++) {\r\nif (!falcon_spi_poll(efx))\r\nreturn 0;\r\nudelay(10);\r\n}\r\nfor (;;) {\r\nif (!falcon_spi_poll(efx))\r\nreturn 0;\r\nif (time_after_eq(jiffies, timeout)) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"timed out waiting for SPI\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nschedule_timeout_uninterruptible(1);\r\n}\r\n}\r\nstatic int\r\nfalcon_spi_cmd(struct efx_nic *efx, const struct falcon_spi_device *spi,\r\nunsigned int command, int address,\r\nconst void *in, void *out, size_t len)\r\n{\r\nbool addressed = (address >= 0);\r\nbool reading = (out != NULL);\r\nefx_oword_t reg;\r\nint rc;\r\nif (len > FALCON_SPI_MAX_LEN)\r\nreturn -EINVAL;\r\nrc = falcon_spi_poll(efx);\r\nif (rc)\r\nreturn rc;\r\nif (addressed) {\r\nEFX_POPULATE_OWORD_1(reg, FRF_AB_EE_SPI_HADR_ADR, address);\r\nefx_writeo(efx, &reg, FR_AB_EE_SPI_HADR);\r\n}\r\nif (in != NULL) {\r\nmemcpy(&reg, in, len);\r\nefx_writeo(efx, &reg, FR_AB_EE_SPI_HDATA);\r\n}\r\nEFX_POPULATE_OWORD_7(reg,\r\nFRF_AB_EE_SPI_HCMD_CMD_EN, 1,\r\nFRF_AB_EE_SPI_HCMD_SF_SEL, spi->device_id,\r\nFRF_AB_EE_SPI_HCMD_DABCNT, len,\r\nFRF_AB_EE_SPI_HCMD_READ, reading,\r\nFRF_AB_EE_SPI_HCMD_DUBCNT, 0,\r\nFRF_AB_EE_SPI_HCMD_ADBCNT,\r\n(addressed ? spi->addr_len : 0),\r\nFRF_AB_EE_SPI_HCMD_ENC, command);\r\nefx_writeo(efx, &reg, FR_AB_EE_SPI_HCMD);\r\nrc = falcon_spi_wait(efx);\r\nif (rc)\r\nreturn rc;\r\nif (out != NULL) {\r\nefx_reado(efx, &reg, FR_AB_EE_SPI_HDATA);\r\nmemcpy(out, &reg, len);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline u8\r\nfalcon_spi_munge_command(const struct falcon_spi_device *spi,\r\nconst u8 command, const unsigned int address)\r\n{\r\nreturn command | (((address >> 8) & spi->munge_address) << 3);\r\n}\r\nstatic int\r\nfalcon_spi_read(struct efx_nic *efx, const struct falcon_spi_device *spi,\r\nloff_t start, size_t len, size_t *retlen, u8 *buffer)\r\n{\r\nsize_t block_len, pos = 0;\r\nunsigned int command;\r\nint rc = 0;\r\nwhile (pos < len) {\r\nblock_len = min(len - pos, FALCON_SPI_MAX_LEN);\r\ncommand = falcon_spi_munge_command(spi, SPI_READ, start + pos);\r\nrc = falcon_spi_cmd(efx, spi, command, start + pos, NULL,\r\nbuffer + pos, block_len);\r\nif (rc)\r\nbreak;\r\npos += block_len;\r\ncond_resched();\r\nif (signal_pending(current)) {\r\nrc = -EINTR;\r\nbreak;\r\n}\r\n}\r\nif (retlen)\r\n*retlen = pos;\r\nreturn rc;\r\n}\r\nstatic size_t\r\nfalcon_spi_write_limit(const struct falcon_spi_device *spi, size_t start)\r\n{\r\nreturn min(FALCON_SPI_MAX_LEN,\r\n(spi->block_size - (start & (spi->block_size - 1))));\r\n}\r\nstatic int\r\nfalcon_spi_wait_write(struct efx_nic *efx, const struct falcon_spi_device *spi)\r\n{\r\nunsigned long timeout = jiffies + 1 + DIV_ROUND_UP(HZ, 100);\r\nu8 status;\r\nint rc;\r\nfor (;;) {\r\nrc = falcon_spi_cmd(efx, spi, SPI_RDSR, -1, NULL,\r\n&status, sizeof(status));\r\nif (rc)\r\nreturn rc;\r\nif (!(status & SPI_STATUS_NRDY))\r\nreturn 0;\r\nif (time_after_eq(jiffies, timeout)) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"SPI write timeout on device %d"\r\n" last status=0x%02x\n",\r\nspi->device_id, status);\r\nreturn -ETIMEDOUT;\r\n}\r\nschedule_timeout_uninterruptible(1);\r\n}\r\n}\r\nstatic int\r\nfalcon_spi_write(struct efx_nic *efx, const struct falcon_spi_device *spi,\r\nloff_t start, size_t len, size_t *retlen, const u8 *buffer)\r\n{\r\nu8 verify_buffer[FALCON_SPI_MAX_LEN];\r\nsize_t block_len, pos = 0;\r\nunsigned int command;\r\nint rc = 0;\r\nwhile (pos < len) {\r\nrc = falcon_spi_cmd(efx, spi, SPI_WREN, -1, NULL, NULL, 0);\r\nif (rc)\r\nbreak;\r\nblock_len = min(len - pos,\r\nfalcon_spi_write_limit(spi, start + pos));\r\ncommand = falcon_spi_munge_command(spi, SPI_WRITE, start + pos);\r\nrc = falcon_spi_cmd(efx, spi, command, start + pos,\r\nbuffer + pos, NULL, block_len);\r\nif (rc)\r\nbreak;\r\nrc = falcon_spi_wait_write(efx, spi);\r\nif (rc)\r\nbreak;\r\ncommand = falcon_spi_munge_command(spi, SPI_READ, start + pos);\r\nrc = falcon_spi_cmd(efx, spi, command, start + pos,\r\nNULL, verify_buffer, block_len);\r\nif (memcmp(verify_buffer, buffer + pos, block_len)) {\r\nrc = -EIO;\r\nbreak;\r\n}\r\npos += block_len;\r\ncond_resched();\r\nif (signal_pending(current)) {\r\nrc = -EINTR;\r\nbreak;\r\n}\r\n}\r\nif (retlen)\r\n*retlen = pos;\r\nreturn rc;\r\n}\r\nstatic int\r\nfalcon_spi_slow_wait(struct falcon_mtd_partition *part, bool uninterruptible)\r\n{\r\nconst struct falcon_spi_device *spi = part->spi;\r\nstruct efx_nic *efx = part->common.mtd.priv;\r\nu8 status;\r\nint rc, i;\r\nfor (i = 0; i < 40; i++) {\r\n__set_current_state(uninterruptible ?\r\nTASK_UNINTERRUPTIBLE : TASK_INTERRUPTIBLE);\r\nschedule_timeout(HZ / 10);\r\nrc = falcon_spi_cmd(efx, spi, SPI_RDSR, -1, NULL,\r\n&status, sizeof(status));\r\nif (rc)\r\nreturn rc;\r\nif (!(status & SPI_STATUS_NRDY))\r\nreturn 0;\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\n}\r\npr_err("%s: timed out waiting for %s\n",\r\npart->common.name, part->common.dev_type_name);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int\r\nfalcon_spi_unlock(struct efx_nic *efx, const struct falcon_spi_device *spi)\r\n{\r\nconst u8 unlock_mask = (SPI_STATUS_BP2 | SPI_STATUS_BP1 |\r\nSPI_STATUS_BP0);\r\nu8 status;\r\nint rc;\r\nrc = falcon_spi_cmd(efx, spi, SPI_RDSR, -1, NULL,\r\n&status, sizeof(status));\r\nif (rc)\r\nreturn rc;\r\nif (!(status & unlock_mask))\r\nreturn 0;\r\nrc = falcon_spi_cmd(efx, spi, SPI_WREN, -1, NULL, NULL, 0);\r\nif (rc)\r\nreturn rc;\r\nrc = falcon_spi_cmd(efx, spi, SPI_SST_EWSR, -1, NULL, NULL, 0);\r\nif (rc)\r\nreturn rc;\r\nstatus &= ~unlock_mask;\r\nrc = falcon_spi_cmd(efx, spi, SPI_WRSR, -1, &status,\r\nNULL, sizeof(status));\r\nif (rc)\r\nreturn rc;\r\nrc = falcon_spi_wait_write(efx, spi);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int\r\nfalcon_spi_erase(struct falcon_mtd_partition *part, loff_t start, size_t len)\r\n{\r\nconst struct falcon_spi_device *spi = part->spi;\r\nstruct efx_nic *efx = part->common.mtd.priv;\r\nunsigned pos, block_len;\r\nu8 empty[FALCON_SPI_VERIFY_BUF_LEN];\r\nu8 buffer[FALCON_SPI_VERIFY_BUF_LEN];\r\nint rc;\r\nif (len != spi->erase_size)\r\nreturn -EINVAL;\r\nif (spi->erase_command == 0)\r\nreturn -EOPNOTSUPP;\r\nrc = falcon_spi_unlock(efx, spi);\r\nif (rc)\r\nreturn rc;\r\nrc = falcon_spi_cmd(efx, spi, SPI_WREN, -1, NULL, NULL, 0);\r\nif (rc)\r\nreturn rc;\r\nrc = falcon_spi_cmd(efx, spi, spi->erase_command, start, NULL,\r\nNULL, 0);\r\nif (rc)\r\nreturn rc;\r\nrc = falcon_spi_slow_wait(part, false);\r\nmemset(empty, 0xff, sizeof(empty));\r\nfor (pos = 0; pos < len; pos += block_len) {\r\nblock_len = min(len - pos, sizeof(buffer));\r\nrc = falcon_spi_read(efx, spi, start + pos, block_len,\r\nNULL, buffer);\r\nif (rc)\r\nreturn rc;\r\nif (memcmp(empty, buffer, block_len))\r\nreturn -EIO;\r\ncond_resched();\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\n}\r\nreturn rc;\r\n}\r\nstatic void falcon_mtd_rename(struct efx_mtd_partition *part)\r\n{\r\nstruct efx_nic *efx = part->mtd.priv;\r\nsnprintf(part->name, sizeof(part->name), "%s %s",\r\nefx->name, part->type_name);\r\n}\r\nstatic int falcon_mtd_read(struct mtd_info *mtd, loff_t start,\r\nsize_t len, size_t *retlen, u8 *buffer)\r\n{\r\nstruct falcon_mtd_partition *part = to_falcon_mtd_partition(mtd);\r\nstruct efx_nic *efx = mtd->priv;\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nint rc;\r\nrc = mutex_lock_interruptible(&nic_data->spi_lock);\r\nif (rc)\r\nreturn rc;\r\nrc = falcon_spi_read(efx, part->spi, part->offset + start,\r\nlen, retlen, buffer);\r\nmutex_unlock(&nic_data->spi_lock);\r\nreturn rc;\r\n}\r\nstatic int falcon_mtd_erase(struct mtd_info *mtd, loff_t start, size_t len)\r\n{\r\nstruct falcon_mtd_partition *part = to_falcon_mtd_partition(mtd);\r\nstruct efx_nic *efx = mtd->priv;\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nint rc;\r\nrc = mutex_lock_interruptible(&nic_data->spi_lock);\r\nif (rc)\r\nreturn rc;\r\nrc = falcon_spi_erase(part, part->offset + start, len);\r\nmutex_unlock(&nic_data->spi_lock);\r\nreturn rc;\r\n}\r\nstatic int falcon_mtd_write(struct mtd_info *mtd, loff_t start,\r\nsize_t len, size_t *retlen, const u8 *buffer)\r\n{\r\nstruct falcon_mtd_partition *part = to_falcon_mtd_partition(mtd);\r\nstruct efx_nic *efx = mtd->priv;\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nint rc;\r\nrc = mutex_lock_interruptible(&nic_data->spi_lock);\r\nif (rc)\r\nreturn rc;\r\nrc = falcon_spi_write(efx, part->spi, part->offset + start,\r\nlen, retlen, buffer);\r\nmutex_unlock(&nic_data->spi_lock);\r\nreturn rc;\r\n}\r\nstatic int falcon_mtd_sync(struct mtd_info *mtd)\r\n{\r\nstruct falcon_mtd_partition *part = to_falcon_mtd_partition(mtd);\r\nstruct efx_nic *efx = mtd->priv;\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nint rc;\r\nmutex_lock(&nic_data->spi_lock);\r\nrc = falcon_spi_slow_wait(part, true);\r\nmutex_unlock(&nic_data->spi_lock);\r\nreturn rc;\r\n}\r\nstatic int falcon_mtd_probe(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nstruct falcon_mtd_partition *parts;\r\nstruct falcon_spi_device *spi;\r\nsize_t n_parts;\r\nint rc = -ENODEV;\r\nASSERT_RTNL();\r\nparts = kcalloc(2, sizeof(*parts), GFP_KERNEL);\r\nif (!parts)\r\nreturn -ENOMEM;\r\nn_parts = 0;\r\nspi = &nic_data->spi_flash;\r\nif (falcon_spi_present(spi) && spi->size > FALCON_FLASH_BOOTCODE_START) {\r\nparts[n_parts].spi = spi;\r\nparts[n_parts].offset = FALCON_FLASH_BOOTCODE_START;\r\nparts[n_parts].common.dev_type_name = "flash";\r\nparts[n_parts].common.type_name = "sfc_flash_bootrom";\r\nparts[n_parts].common.mtd.type = MTD_NORFLASH;\r\nparts[n_parts].common.mtd.flags = MTD_CAP_NORFLASH;\r\nparts[n_parts].common.mtd.size = spi->size - FALCON_FLASH_BOOTCODE_START;\r\nparts[n_parts].common.mtd.erasesize = spi->erase_size;\r\nn_parts++;\r\n}\r\nspi = &nic_data->spi_eeprom;\r\nif (falcon_spi_present(spi) && spi->size > FALCON_EEPROM_BOOTCONFIG_START) {\r\nparts[n_parts].spi = spi;\r\nparts[n_parts].offset = FALCON_EEPROM_BOOTCONFIG_START;\r\nparts[n_parts].common.dev_type_name = "EEPROM";\r\nparts[n_parts].common.type_name = "sfc_bootconfig";\r\nparts[n_parts].common.mtd.type = MTD_RAM;\r\nparts[n_parts].common.mtd.flags = MTD_CAP_RAM;\r\nparts[n_parts].common.mtd.size =\r\nmin(spi->size, FALCON_EEPROM_BOOTCONFIG_END) -\r\nFALCON_EEPROM_BOOTCONFIG_START;\r\nparts[n_parts].common.mtd.erasesize = spi->erase_size;\r\nn_parts++;\r\n}\r\nrc = efx_mtd_add(efx, &parts[0].common, n_parts, sizeof(*parts));\r\nif (rc)\r\nkfree(parts);\r\nreturn rc;\r\n}\r\nstatic void falcon_setup_xaui(struct efx_nic *efx)\r\n{\r\nefx_oword_t sdctl, txdrv;\r\nif (efx->phy_type == PHY_TYPE_NONE)\r\nreturn;\r\nefx_reado(efx, &sdctl, FR_AB_XX_SD_CTL);\r\nEFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_HIDRVD, FFE_AB_XX_SD_CTL_DRV_DEF);\r\nEFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_LODRVD, FFE_AB_XX_SD_CTL_DRV_DEF);\r\nEFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_HIDRVC, FFE_AB_XX_SD_CTL_DRV_DEF);\r\nEFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_LODRVC, FFE_AB_XX_SD_CTL_DRV_DEF);\r\nEFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_HIDRVB, FFE_AB_XX_SD_CTL_DRV_DEF);\r\nEFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_LODRVB, FFE_AB_XX_SD_CTL_DRV_DEF);\r\nEFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_HIDRVA, FFE_AB_XX_SD_CTL_DRV_DEF);\r\nEFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_LODRVA, FFE_AB_XX_SD_CTL_DRV_DEF);\r\nefx_writeo(efx, &sdctl, FR_AB_XX_SD_CTL);\r\nEFX_POPULATE_OWORD_8(txdrv,\r\nFRF_AB_XX_DEQD, FFE_AB_XX_TXDRV_DEQ_DEF,\r\nFRF_AB_XX_DEQC, FFE_AB_XX_TXDRV_DEQ_DEF,\r\nFRF_AB_XX_DEQB, FFE_AB_XX_TXDRV_DEQ_DEF,\r\nFRF_AB_XX_DEQA, FFE_AB_XX_TXDRV_DEQ_DEF,\r\nFRF_AB_XX_DTXD, FFE_AB_XX_TXDRV_DTX_DEF,\r\nFRF_AB_XX_DTXC, FFE_AB_XX_TXDRV_DTX_DEF,\r\nFRF_AB_XX_DTXB, FFE_AB_XX_TXDRV_DTX_DEF,\r\nFRF_AB_XX_DTXA, FFE_AB_XX_TXDRV_DTX_DEF);\r\nefx_writeo(efx, &txdrv, FR_AB_XX_TXDRV_CTL);\r\n}\r\nint falcon_reset_xaui(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nefx_oword_t reg;\r\nint count;\r\nWARN_ON(nic_data->stats_disable_count == 0);\r\nEFX_POPULATE_OWORD_1(reg, FRF_AB_XX_RST_XX_EN, 1);\r\nefx_writeo(efx, &reg, FR_AB_XX_PWR_RST);\r\nfor (count = 0; count < 1000; count++) {\r\nefx_reado(efx, &reg, FR_AB_XX_PWR_RST);\r\nif (EFX_OWORD_FIELD(reg, FRF_AB_XX_RST_XX_EN) == 0 &&\r\nEFX_OWORD_FIELD(reg, FRF_AB_XX_SD_RST_ACT) == 0) {\r\nfalcon_setup_xaui(efx);\r\nreturn 0;\r\n}\r\nudelay(10);\r\n}\r\nnetif_err(efx, hw, efx->net_dev,\r\n"timed out waiting for XAUI/XGXS reset\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void falcon_ack_status_intr(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nefx_oword_t reg;\r\nif ((efx_nic_rev(efx) != EFX_REV_FALCON_B0) || LOOPBACK_INTERNAL(efx))\r\nreturn;\r\nif (!efx->link_state.up)\r\nreturn;\r\nif (nic_data->xmac_poll_required)\r\nreturn;\r\nefx_reado(efx, &reg, FR_AB_XM_MGT_INT_MSK);\r\n}\r\nstatic bool falcon_xgxs_link_ok(struct efx_nic *efx)\r\n{\r\nefx_oword_t reg;\r\nbool align_done, link_ok = false;\r\nint sync_status;\r\nefx_reado(efx, &reg, FR_AB_XX_CORE_STAT);\r\nalign_done = EFX_OWORD_FIELD(reg, FRF_AB_XX_ALIGN_DONE);\r\nsync_status = EFX_OWORD_FIELD(reg, FRF_AB_XX_SYNC_STAT);\r\nif (align_done && (sync_status == FFE_AB_XX_STAT_ALL_LANES))\r\nlink_ok = true;\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_XX_COMMA_DET, FFE_AB_XX_STAT_ALL_LANES);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_XX_CHAR_ERR, FFE_AB_XX_STAT_ALL_LANES);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_XX_DISPERR, FFE_AB_XX_STAT_ALL_LANES);\r\nefx_writeo(efx, &reg, FR_AB_XX_CORE_STAT);\r\nreturn link_ok;\r\n}\r\nstatic bool falcon_xmac_link_ok(struct efx_nic *efx)\r\n{\r\nreturn (efx->loopback_mode == LOOPBACK_XGMII ||\r\nfalcon_xgxs_link_ok(efx)) &&\r\n(!(efx->mdio.mmds & (1 << MDIO_MMD_PHYXS)) ||\r\nLOOPBACK_INTERNAL(efx) ||\r\nefx_mdio_phyxgxs_lane_sync(efx));\r\n}\r\nstatic void falcon_reconfigure_xmac_core(struct efx_nic *efx)\r\n{\r\nunsigned int max_frame_len;\r\nefx_oword_t reg;\r\nbool rx_fc = !!(efx->link_state.fc & EFX_FC_RX);\r\nbool tx_fc = !!(efx->link_state.fc & EFX_FC_TX);\r\nEFX_POPULATE_OWORD_3(reg,\r\nFRF_AB_XM_RX_JUMBO_MODE, 1,\r\nFRF_AB_XM_TX_STAT_EN, 1,\r\nFRF_AB_XM_RX_STAT_EN, 1);\r\nefx_writeo(efx, &reg, FR_AB_XM_GLB_CFG);\r\nEFX_POPULATE_OWORD_6(reg,\r\nFRF_AB_XM_TXEN, 1,\r\nFRF_AB_XM_TX_PRMBL, 1,\r\nFRF_AB_XM_AUTO_PAD, 1,\r\nFRF_AB_XM_TXCRC, 1,\r\nFRF_AB_XM_FCNTL, tx_fc,\r\nFRF_AB_XM_IPG, 0x3);\r\nefx_writeo(efx, &reg, FR_AB_XM_TX_CFG);\r\nEFX_POPULATE_OWORD_5(reg,\r\nFRF_AB_XM_RXEN, 1,\r\nFRF_AB_XM_AUTO_DEPAD, 0,\r\nFRF_AB_XM_ACPT_ALL_MCAST, 1,\r\nFRF_AB_XM_ACPT_ALL_UCAST, !efx->unicast_filter,\r\nFRF_AB_XM_PASS_CRC_ERR, 1);\r\nefx_writeo(efx, &reg, FR_AB_XM_RX_CFG);\r\nmax_frame_len = EFX_MAX_FRAME_LEN(efx->net_dev->mtu);\r\nEFX_POPULATE_OWORD_1(reg, FRF_AB_XM_MAX_RX_FRM_SIZE, max_frame_len);\r\nefx_writeo(efx, &reg, FR_AB_XM_RX_PARAM);\r\nEFX_POPULATE_OWORD_2(reg,\r\nFRF_AB_XM_MAX_TX_FRM_SIZE, max_frame_len,\r\nFRF_AB_XM_TX_JUMBO_MODE, 1);\r\nefx_writeo(efx, &reg, FR_AB_XM_TX_PARAM);\r\nEFX_POPULATE_OWORD_2(reg,\r\nFRF_AB_XM_PAUSE_TIME, 0xfffe,\r\nFRF_AB_XM_DIS_FCNTL, !rx_fc);\r\nefx_writeo(efx, &reg, FR_AB_XM_FC);\r\nmemcpy(&reg, &efx->net_dev->dev_addr[0], 4);\r\nefx_writeo(efx, &reg, FR_AB_XM_ADR_LO);\r\nmemcpy(&reg, &efx->net_dev->dev_addr[4], 2);\r\nefx_writeo(efx, &reg, FR_AB_XM_ADR_HI);\r\n}\r\nstatic void falcon_reconfigure_xgxs_core(struct efx_nic *efx)\r\n{\r\nefx_oword_t reg;\r\nbool xgxs_loopback = (efx->loopback_mode == LOOPBACK_XGXS);\r\nbool xaui_loopback = (efx->loopback_mode == LOOPBACK_XAUI);\r\nbool xgmii_loopback = (efx->loopback_mode == LOOPBACK_XGMII);\r\nbool old_xgmii_loopback, old_xgxs_loopback, old_xaui_loopback;\r\nefx_reado(efx, &reg, FR_AB_XX_CORE_STAT);\r\nold_xgxs_loopback = EFX_OWORD_FIELD(reg, FRF_AB_XX_XGXS_LB_EN);\r\nold_xgmii_loopback = EFX_OWORD_FIELD(reg, FRF_AB_XX_XGMII_LB_EN);\r\nefx_reado(efx, &reg, FR_AB_XX_SD_CTL);\r\nold_xaui_loopback = EFX_OWORD_FIELD(reg, FRF_AB_XX_LPBKA);\r\nif ((xgxs_loopback != old_xgxs_loopback) ||\r\n(xaui_loopback != old_xaui_loopback) ||\r\n(xgmii_loopback != old_xgmii_loopback))\r\nfalcon_reset_xaui(efx);\r\nefx_reado(efx, &reg, FR_AB_XX_CORE_STAT);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_XX_FORCE_SIG,\r\n(xgxs_loopback || xaui_loopback) ?\r\nFFE_AB_XX_FORCE_SIG_ALL_LANES : 0);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_XX_XGXS_LB_EN, xgxs_loopback);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_XX_XGMII_LB_EN, xgmii_loopback);\r\nefx_writeo(efx, &reg, FR_AB_XX_CORE_STAT);\r\nefx_reado(efx, &reg, FR_AB_XX_SD_CTL);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_XX_LPBKD, xaui_loopback);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_XX_LPBKC, xaui_loopback);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_XX_LPBKB, xaui_loopback);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_XX_LPBKA, xaui_loopback);\r\nefx_writeo(efx, &reg, FR_AB_XX_SD_CTL);\r\n}\r\nstatic bool falcon_xmac_link_ok_retry(struct efx_nic *efx, int tries)\r\n{\r\nbool mac_up = falcon_xmac_link_ok(efx);\r\nif (LOOPBACK_MASK(efx) & LOOPBACKS_EXTERNAL(efx) & LOOPBACKS_WS ||\r\nefx_phy_mode_disabled(efx->phy_mode))\r\nreturn mac_up;\r\nfalcon_stop_nic_stats(efx);\r\nwhile (!mac_up && tries) {\r\nnetif_dbg(efx, hw, efx->net_dev, "bashing xaui\n");\r\nfalcon_reset_xaui(efx);\r\nudelay(200);\r\nmac_up = falcon_xmac_link_ok(efx);\r\n--tries;\r\n}\r\nfalcon_start_nic_stats(efx);\r\nreturn mac_up;\r\n}\r\nstatic bool falcon_xmac_check_fault(struct efx_nic *efx)\r\n{\r\nreturn !falcon_xmac_link_ok_retry(efx, 5);\r\n}\r\nstatic int falcon_reconfigure_xmac(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nefx_farch_filter_sync_rx_mode(efx);\r\nfalcon_reconfigure_xgxs_core(efx);\r\nfalcon_reconfigure_xmac_core(efx);\r\nfalcon_reconfigure_mac_wrapper(efx);\r\nnic_data->xmac_poll_required = !falcon_xmac_link_ok_retry(efx, 5);\r\nfalcon_ack_status_intr(efx);\r\nreturn 0;\r\n}\r\nstatic void falcon_poll_xmac(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nif (!efx->link_state.up || !nic_data->xmac_poll_required)\r\nreturn;\r\nnic_data->xmac_poll_required = !falcon_xmac_link_ok_retry(efx, 1);\r\nfalcon_ack_status_intr(efx);\r\n}\r\nstatic void falcon_push_multicast_hash(struct efx_nic *efx)\r\n{\r\nunion efx_multicast_hash *mc_hash = &efx->multicast_hash;\r\nWARN_ON(!mutex_is_locked(&efx->mac_lock));\r\nefx_writeo(efx, &mc_hash->oword[0], FR_AB_MAC_MC_HASH_REG0);\r\nefx_writeo(efx, &mc_hash->oword[1], FR_AB_MAC_MC_HASH_REG1);\r\n}\r\nstatic void falcon_reset_macs(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nefx_oword_t reg, mac_ctrl;\r\nint count;\r\nif (efx_nic_rev(efx) < EFX_REV_FALCON_B0) {\r\nEFX_POPULATE_OWORD_1(reg, FRF_AB_XM_CORE_RST, 1);\r\nefx_writeo(efx, &reg, FR_AB_XM_GLB_CFG);\r\nfor (count = 0; count < 10000; count++) {\r\nefx_reado(efx, &reg, FR_AB_XM_GLB_CFG);\r\nif (EFX_OWORD_FIELD(reg, FRF_AB_XM_CORE_RST) ==\r\n0)\r\nreturn;\r\nudelay(10);\r\n}\r\nnetif_err(efx, hw, efx->net_dev,\r\n"timed out waiting for XMAC core reset\n");\r\n}\r\nWARN_ON(nic_data->stats_disable_count == 0);\r\nefx_reado(efx, &mac_ctrl, FR_AB_MAC_CTRL);\r\nEFX_SET_OWORD_FIELD(mac_ctrl, FRF_BB_TXFIFO_DRAIN_EN, 1);\r\nefx_writeo(efx, &mac_ctrl, FR_AB_MAC_CTRL);\r\nefx_reado(efx, &reg, FR_AB_GLB_CTL);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_RST_XGTX, 1);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_RST_XGRX, 1);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AB_RST_EM, 1);\r\nefx_writeo(efx, &reg, FR_AB_GLB_CTL);\r\ncount = 0;\r\nwhile (1) {\r\nefx_reado(efx, &reg, FR_AB_GLB_CTL);\r\nif (!EFX_OWORD_FIELD(reg, FRF_AB_RST_XGTX) &&\r\n!EFX_OWORD_FIELD(reg, FRF_AB_RST_XGRX) &&\r\n!EFX_OWORD_FIELD(reg, FRF_AB_RST_EM)) {\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"Completed MAC reset after %d loops\n",\r\ncount);\r\nbreak;\r\n}\r\nif (count > 20) {\r\nnetif_err(efx, hw, efx->net_dev, "MAC reset failed\n");\r\nbreak;\r\n}\r\ncount++;\r\nudelay(10);\r\n}\r\nefx_writeo(efx, &mac_ctrl, FR_AB_MAC_CTRL);\r\nfalcon_setup_xaui(efx);\r\n}\r\nstatic void falcon_drain_tx_fifo(struct efx_nic *efx)\r\n{\r\nefx_oword_t reg;\r\nif ((efx_nic_rev(efx) < EFX_REV_FALCON_B0) ||\r\n(efx->loopback_mode != LOOPBACK_NONE))\r\nreturn;\r\nefx_reado(efx, &reg, FR_AB_MAC_CTRL);\r\nif (EFX_OWORD_FIELD(reg, FRF_BB_TXFIFO_DRAIN_EN))\r\nreturn;\r\nfalcon_reset_macs(efx);\r\n}\r\nstatic void falcon_deconfigure_mac_wrapper(struct efx_nic *efx)\r\n{\r\nefx_oword_t reg;\r\nif (efx_nic_rev(efx) < EFX_REV_FALCON_B0)\r\nreturn;\r\nefx_reado(efx, &reg, FR_AZ_RX_CFG);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_INGR_EN, 0);\r\nefx_writeo(efx, &reg, FR_AZ_RX_CFG);\r\nfalcon_drain_tx_fifo(efx);\r\n}\r\nstatic void falcon_reconfigure_mac_wrapper(struct efx_nic *efx)\r\n{\r\nstruct efx_link_state *link_state = &efx->link_state;\r\nefx_oword_t reg;\r\nint link_speed, isolate;\r\nisolate = !!ACCESS_ONCE(efx->reset_pending);\r\nswitch (link_state->speed) {\r\ncase 10000: link_speed = 3; break;\r\ncase 1000: link_speed = 2; break;\r\ncase 100: link_speed = 1; break;\r\ndefault: link_speed = 0; break;\r\n}\r\nEFX_POPULATE_OWORD_5(reg,\r\nFRF_AB_MAC_XOFF_VAL, 0xffff ,\r\nFRF_AB_MAC_BCAD_ACPT, 1,\r\nFRF_AB_MAC_UC_PROM, !efx->unicast_filter,\r\nFRF_AB_MAC_LINK_STATUS, 1,\r\nFRF_AB_MAC_SPEED, link_speed);\r\nif (efx_nic_rev(efx) >= EFX_REV_FALCON_B0) {\r\nEFX_SET_OWORD_FIELD(reg, FRF_BB_TXFIFO_DRAIN_EN,\r\n!link_state->up || isolate);\r\n}\r\nefx_writeo(efx, &reg, FR_AB_MAC_CTRL);\r\nfalcon_push_multicast_hash(efx);\r\nefx_reado(efx, &reg, FR_AZ_RX_CFG);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AZ_RX_XOFF_MAC_EN, 1);\r\nif (efx_nic_rev(efx) >= EFX_REV_FALCON_B0)\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_INGR_EN, !isolate);\r\nefx_writeo(efx, &reg, FR_AZ_RX_CFG);\r\n}\r\nstatic void falcon_stats_request(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nefx_oword_t reg;\r\nWARN_ON(nic_data->stats_pending);\r\nWARN_ON(nic_data->stats_disable_count);\r\nFALCON_XMAC_STATS_DMA_FLAG(efx) = 0;\r\nnic_data->stats_pending = true;\r\nwmb();\r\nEFX_POPULATE_OWORD_2(reg,\r\nFRF_AB_MAC_STAT_DMA_CMD, 1,\r\nFRF_AB_MAC_STAT_DMA_ADR,\r\nefx->stats_buffer.dma_addr);\r\nefx_writeo(efx, &reg, FR_AB_MAC_STAT_DMA);\r\nmod_timer(&nic_data->stats_timer, round_jiffies_up(jiffies + HZ / 2));\r\n}\r\nstatic void falcon_stats_complete(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nif (!nic_data->stats_pending)\r\nreturn;\r\nnic_data->stats_pending = false;\r\nif (FALCON_XMAC_STATS_DMA_FLAG(efx)) {\r\nrmb();\r\nefx_nic_update_stats(falcon_stat_desc, FALCON_STAT_COUNT,\r\nfalcon_stat_mask, nic_data->stats,\r\nefx->stats_buffer.addr, true);\r\n} else {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"timed out waiting for statistics\n");\r\n}\r\n}\r\nstatic void falcon_stats_timer_func(unsigned long context)\r\n{\r\nstruct efx_nic *efx = (struct efx_nic *)context;\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nspin_lock(&efx->stats_lock);\r\nfalcon_stats_complete(efx);\r\nif (nic_data->stats_disable_count == 0)\r\nfalcon_stats_request(efx);\r\nspin_unlock(&efx->stats_lock);\r\n}\r\nstatic bool falcon_loopback_link_poll(struct efx_nic *efx)\r\n{\r\nstruct efx_link_state old_state = efx->link_state;\r\nWARN_ON(!mutex_is_locked(&efx->mac_lock));\r\nWARN_ON(!LOOPBACK_INTERNAL(efx));\r\nefx->link_state.fd = true;\r\nefx->link_state.fc = efx->wanted_fc;\r\nefx->link_state.up = true;\r\nefx->link_state.speed = 10000;\r\nreturn !efx_link_state_equal(&efx->link_state, &old_state);\r\n}\r\nstatic int falcon_reconfigure_port(struct efx_nic *efx)\r\n{\r\nint rc;\r\nWARN_ON(efx_nic_rev(efx) > EFX_REV_FALCON_B0);\r\nif (LOOPBACK_INTERNAL(efx))\r\nfalcon_loopback_link_poll(efx);\r\nelse\r\nefx->phy_op->poll(efx);\r\nfalcon_stop_nic_stats(efx);\r\nfalcon_deconfigure_mac_wrapper(efx);\r\nfalcon_reset_macs(efx);\r\nefx->phy_op->reconfigure(efx);\r\nrc = falcon_reconfigure_xmac(efx);\r\nBUG_ON(rc);\r\nfalcon_start_nic_stats(efx);\r\nefx_link_status_changed(efx);\r\nreturn 0;\r\n}\r\nstatic void falcon_a1_prepare_enable_fc_tx(struct efx_nic *efx)\r\n{\r\nefx_schedule_reset(efx, RESET_TYPE_INVISIBLE);\r\n}\r\nstatic void falcon_b0_prepare_enable_fc_tx(struct efx_nic *efx)\r\n{\r\nfalcon_stop_nic_stats(efx);\r\nfalcon_drain_tx_fifo(efx);\r\nfalcon_reconfigure_xmac(efx);\r\nfalcon_start_nic_stats(efx);\r\n}\r\nstatic int falcon_gmii_wait(struct efx_nic *efx)\r\n{\r\nefx_oword_t md_stat;\r\nint count;\r\nfor (count = 0; count < 5000; count++) {\r\nefx_reado(efx, &md_stat, FR_AB_MD_STAT);\r\nif (EFX_OWORD_FIELD(md_stat, FRF_AB_MD_BSY) == 0) {\r\nif (EFX_OWORD_FIELD(md_stat, FRF_AB_MD_LNFL) != 0 ||\r\nEFX_OWORD_FIELD(md_stat, FRF_AB_MD_BSERR) != 0) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"error from GMII access "\r\nEFX_OWORD_FMT"\n",\r\nEFX_OWORD_VAL(md_stat));\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nudelay(10);\r\n}\r\nnetif_err(efx, hw, efx->net_dev, "timed out waiting for GMII\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int falcon_mdio_write(struct net_device *net_dev,\r\nint prtad, int devad, u16 addr, u16 value)\r\n{\r\nstruct efx_nic *efx = netdev_priv(net_dev);\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nefx_oword_t reg;\r\nint rc;\r\nnetif_vdbg(efx, hw, efx->net_dev,\r\n"writing MDIO %d register %d.%d with 0x%04x\n",\r\nprtad, devad, addr, value);\r\nmutex_lock(&nic_data->mdio_lock);\r\nrc = falcon_gmii_wait(efx);\r\nif (rc)\r\ngoto out;\r\nEFX_POPULATE_OWORD_1(reg, FRF_AB_MD_PHY_ADR, addr);\r\nefx_writeo(efx, &reg, FR_AB_MD_PHY_ADR);\r\nEFX_POPULATE_OWORD_2(reg, FRF_AB_MD_PRT_ADR, prtad,\r\nFRF_AB_MD_DEV_ADR, devad);\r\nefx_writeo(efx, &reg, FR_AB_MD_ID);\r\nEFX_POPULATE_OWORD_1(reg, FRF_AB_MD_TXD, value);\r\nefx_writeo(efx, &reg, FR_AB_MD_TXD);\r\nEFX_POPULATE_OWORD_2(reg,\r\nFRF_AB_MD_WRC, 1,\r\nFRF_AB_MD_GC, 0);\r\nefx_writeo(efx, &reg, FR_AB_MD_CS);\r\nrc = falcon_gmii_wait(efx);\r\nif (rc) {\r\nEFX_POPULATE_OWORD_2(reg,\r\nFRF_AB_MD_WRC, 0,\r\nFRF_AB_MD_GC, 1);\r\nefx_writeo(efx, &reg, FR_AB_MD_CS);\r\nudelay(10);\r\n}\r\nout:\r\nmutex_unlock(&nic_data->mdio_lock);\r\nreturn rc;\r\n}\r\nstatic int falcon_mdio_read(struct net_device *net_dev,\r\nint prtad, int devad, u16 addr)\r\n{\r\nstruct efx_nic *efx = netdev_priv(net_dev);\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nefx_oword_t reg;\r\nint rc;\r\nmutex_lock(&nic_data->mdio_lock);\r\nrc = falcon_gmii_wait(efx);\r\nif (rc)\r\ngoto out;\r\nEFX_POPULATE_OWORD_1(reg, FRF_AB_MD_PHY_ADR, addr);\r\nefx_writeo(efx, &reg, FR_AB_MD_PHY_ADR);\r\nEFX_POPULATE_OWORD_2(reg, FRF_AB_MD_PRT_ADR, prtad,\r\nFRF_AB_MD_DEV_ADR, devad);\r\nefx_writeo(efx, &reg, FR_AB_MD_ID);\r\nEFX_POPULATE_OWORD_2(reg, FRF_AB_MD_RDC, 1, FRF_AB_MD_GC, 0);\r\nefx_writeo(efx, &reg, FR_AB_MD_CS);\r\nrc = falcon_gmii_wait(efx);\r\nif (rc == 0) {\r\nefx_reado(efx, &reg, FR_AB_MD_RXD);\r\nrc = EFX_OWORD_FIELD(reg, FRF_AB_MD_RXD);\r\nnetif_vdbg(efx, hw, efx->net_dev,\r\n"read from MDIO %d register %d.%d, got %04x\n",\r\nprtad, devad, addr, rc);\r\n} else {\r\nEFX_POPULATE_OWORD_2(reg,\r\nFRF_AB_MD_RIC, 0,\r\nFRF_AB_MD_GC, 1);\r\nefx_writeo(efx, &reg, FR_AB_MD_CS);\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"read from MDIO %d register %d.%d, got error %d\n",\r\nprtad, devad, addr, rc);\r\n}\r\nout:\r\nmutex_unlock(&nic_data->mdio_lock);\r\nreturn rc;\r\n}\r\nstatic int falcon_probe_port(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nint rc;\r\nswitch (efx->phy_type) {\r\ncase PHY_TYPE_SFX7101:\r\nefx->phy_op = &falcon_sfx7101_phy_ops;\r\nbreak;\r\ncase PHY_TYPE_QT2022C2:\r\ncase PHY_TYPE_QT2025C:\r\nefx->phy_op = &falcon_qt202x_phy_ops;\r\nbreak;\r\ncase PHY_TYPE_TXC43128:\r\nefx->phy_op = &falcon_txc_phy_ops;\r\nbreak;\r\ndefault:\r\nnetif_err(efx, probe, efx->net_dev, "Unknown PHY type %d\n",\r\nefx->phy_type);\r\nreturn -ENODEV;\r\n}\r\nmutex_init(&nic_data->mdio_lock);\r\nefx->mdio.mdio_read = falcon_mdio_read;\r\nefx->mdio.mdio_write = falcon_mdio_write;\r\nrc = efx->phy_op->probe(efx);\r\nif (rc != 0)\r\nreturn rc;\r\nefx->link_state.speed = 10000;\r\nefx->link_state.fd = true;\r\nif (efx_nic_rev(efx) >= EFX_REV_FALCON_B0)\r\nefx->wanted_fc = EFX_FC_RX | EFX_FC_TX;\r\nelse\r\nefx->wanted_fc = EFX_FC_RX;\r\nif (efx->mdio.mmds & MDIO_DEVS_AN)\r\nefx->wanted_fc |= EFX_FC_AUTO;\r\nrc = efx_nic_alloc_buffer(efx, &efx->stats_buffer,\r\nFALCON_MAC_STATS_SIZE, GFP_KERNEL);\r\nif (rc)\r\nreturn rc;\r\nnetif_dbg(efx, probe, efx->net_dev,\r\n"stats buffer at %llx (virt %p phys %llx)\n",\r\n(u64)efx->stats_buffer.dma_addr,\r\nefx->stats_buffer.addr,\r\n(u64)virt_to_phys(efx->stats_buffer.addr));\r\nreturn 0;\r\n}\r\nstatic void falcon_remove_port(struct efx_nic *efx)\r\n{\r\nefx->phy_op->remove(efx);\r\nefx_nic_free_buffer(efx, &efx->stats_buffer);\r\n}\r\nstatic bool\r\nfalcon_handle_global_event(struct efx_channel *channel, efx_qword_t *event)\r\n{\r\nstruct efx_nic *efx = channel->efx;\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nif (EFX_QWORD_FIELD(*event, FSF_AB_GLB_EV_G_PHY0_INTR) ||\r\nEFX_QWORD_FIELD(*event, FSF_AB_GLB_EV_XG_PHY0_INTR) ||\r\nEFX_QWORD_FIELD(*event, FSF_AB_GLB_EV_XFP_PHY0_INTR))\r\nreturn true;\r\nif ((efx_nic_rev(efx) == EFX_REV_FALCON_B0) &&\r\nEFX_QWORD_FIELD(*event, FSF_BB_GLB_EV_XG_MGT_INTR)) {\r\nnic_data->xmac_poll_required = true;\r\nreturn true;\r\n}\r\nif (efx_nic_rev(efx) <= EFX_REV_FALCON_A1 ?\r\nEFX_QWORD_FIELD(*event, FSF_AA_GLB_EV_RX_RECOVERY) :\r\nEFX_QWORD_FIELD(*event, FSF_BB_GLB_EV_RX_RECOVERY)) {\r\nnetif_err(efx, rx_err, efx->net_dev,\r\n"channel %d seen global RX_RESET event. Resetting.\n",\r\nchannel->channel);\r\natomic_inc(&efx->rx_reset);\r\nefx_schedule_reset(efx, EFX_WORKAROUND_6555(efx) ?\r\nRESET_TYPE_RX_RECOVERY : RESET_TYPE_DISABLE);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int\r\nfalcon_read_nvram(struct efx_nic *efx, struct falcon_nvconfig *nvconfig_out)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nstruct falcon_nvconfig *nvconfig;\r\nstruct falcon_spi_device *spi;\r\nvoid *region;\r\nint rc, magic_num, struct_ver;\r\n__le16 *word, *limit;\r\nu32 csum;\r\nif (falcon_spi_present(&nic_data->spi_flash))\r\nspi = &nic_data->spi_flash;\r\nelse if (falcon_spi_present(&nic_data->spi_eeprom))\r\nspi = &nic_data->spi_eeprom;\r\nelse\r\nreturn -EINVAL;\r\nregion = kmalloc(FALCON_NVCONFIG_END, GFP_KERNEL);\r\nif (!region)\r\nreturn -ENOMEM;\r\nnvconfig = region + FALCON_NVCONFIG_OFFSET;\r\nmutex_lock(&nic_data->spi_lock);\r\nrc = falcon_spi_read(efx, spi, 0, FALCON_NVCONFIG_END, NULL, region);\r\nmutex_unlock(&nic_data->spi_lock);\r\nif (rc) {\r\nnetif_err(efx, hw, efx->net_dev, "Failed to read %s\n",\r\nfalcon_spi_present(&nic_data->spi_flash) ?\r\n"flash" : "EEPROM");\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nmagic_num = le16_to_cpu(nvconfig->board_magic_num);\r\nstruct_ver = le16_to_cpu(nvconfig->board_struct_ver);\r\nrc = -EINVAL;\r\nif (magic_num != FALCON_NVCONFIG_BOARD_MAGIC_NUM) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"NVRAM bad magic 0x%x\n", magic_num);\r\ngoto out;\r\n}\r\nif (struct_ver < 2) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"NVRAM has ancient version 0x%x\n", struct_ver);\r\ngoto out;\r\n} else if (struct_ver < 4) {\r\nword = &nvconfig->board_magic_num;\r\nlimit = (__le16 *) (nvconfig + 1);\r\n} else {\r\nword = region;\r\nlimit = region + FALCON_NVCONFIG_END;\r\n}\r\nfor (csum = 0; word < limit; ++word)\r\ncsum += le16_to_cpu(*word);\r\nif (~csum & 0xffff) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"NVRAM has incorrect checksum\n");\r\ngoto out;\r\n}\r\nrc = 0;\r\nif (nvconfig_out)\r\nmemcpy(nvconfig_out, nvconfig, sizeof(*nvconfig));\r\nout:\r\nkfree(region);\r\nreturn rc;\r\n}\r\nstatic int falcon_test_nvram(struct efx_nic *efx)\r\n{\r\nreturn falcon_read_nvram(efx, NULL);\r\n}\r\nstatic int\r\nfalcon_b0_test_chip(struct efx_nic *efx, struct efx_self_tests *tests)\r\n{\r\nenum reset_type reset_method = RESET_TYPE_INVISIBLE;\r\nint rc, rc2;\r\nmutex_lock(&efx->mac_lock);\r\nif (efx->loopback_modes) {\r\nif (efx->loopback_modes & (1 << LOOPBACK_XGMII))\r\nefx->loopback_mode = LOOPBACK_XGMII;\r\nelse\r\nefx->loopback_mode = __ffs(efx->loopback_modes);\r\n}\r\n__efx_reconfigure_port(efx);\r\nmutex_unlock(&efx->mac_lock);\r\nefx_reset_down(efx, reset_method);\r\ntests->registers =\r\nefx_farch_test_registers(efx, falcon_b0_register_tests,\r\nARRAY_SIZE(falcon_b0_register_tests))\r\n? -1 : 1;\r\nrc = falcon_reset_hw(efx, reset_method);\r\nrc2 = efx_reset_up(efx, reset_method, rc == 0);\r\nreturn rc ? rc : rc2;\r\n}\r\nstatic enum reset_type falcon_map_reset_reason(enum reset_type reason)\r\n{\r\nswitch (reason) {\r\ncase RESET_TYPE_RX_RECOVERY:\r\ncase RESET_TYPE_DMA_ERROR:\r\ncase RESET_TYPE_TX_SKIP:\r\nreturn RESET_TYPE_INVISIBLE;\r\ndefault:\r\nreturn RESET_TYPE_ALL;\r\n}\r\n}\r\nstatic int falcon_map_reset_flags(u32 *flags)\r\n{\r\nenum {\r\nFALCON_RESET_INVISIBLE = (ETH_RESET_DMA | ETH_RESET_FILTER |\r\nETH_RESET_OFFLOAD | ETH_RESET_MAC),\r\nFALCON_RESET_ALL = FALCON_RESET_INVISIBLE | ETH_RESET_PHY,\r\nFALCON_RESET_WORLD = FALCON_RESET_ALL | ETH_RESET_IRQ,\r\n};\r\nif ((*flags & FALCON_RESET_WORLD) == FALCON_RESET_WORLD) {\r\n*flags &= ~FALCON_RESET_WORLD;\r\nreturn RESET_TYPE_WORLD;\r\n}\r\nif ((*flags & FALCON_RESET_ALL) == FALCON_RESET_ALL) {\r\n*flags &= ~FALCON_RESET_ALL;\r\nreturn RESET_TYPE_ALL;\r\n}\r\nif ((*flags & FALCON_RESET_INVISIBLE) == FALCON_RESET_INVISIBLE) {\r\n*flags &= ~FALCON_RESET_INVISIBLE;\r\nreturn RESET_TYPE_INVISIBLE;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __falcon_reset_hw(struct efx_nic *efx, enum reset_type method)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nefx_oword_t glb_ctl_reg_ker;\r\nint rc;\r\nnetif_dbg(efx, hw, efx->net_dev, "performing %s hardware reset\n",\r\nRESET_TYPE(method));\r\nif (method == RESET_TYPE_WORLD) {\r\nrc = pci_save_state(efx->pci_dev);\r\nif (rc) {\r\nnetif_err(efx, drv, efx->net_dev,\r\n"failed to backup PCI state of primary "\r\n"function prior to hardware reset\n");\r\ngoto fail1;\r\n}\r\nif (efx_nic_is_dual_func(efx)) {\r\nrc = pci_save_state(nic_data->pci_dev2);\r\nif (rc) {\r\nnetif_err(efx, drv, efx->net_dev,\r\n"failed to backup PCI state of "\r\n"secondary function prior to "\r\n"hardware reset\n");\r\ngoto fail2;\r\n}\r\n}\r\nEFX_POPULATE_OWORD_2(glb_ctl_reg_ker,\r\nFRF_AB_EXT_PHY_RST_DUR,\r\nFFE_AB_EXT_PHY_RST_DUR_10240US,\r\nFRF_AB_SWRST, 1);\r\n} else {\r\nEFX_POPULATE_OWORD_7(glb_ctl_reg_ker,\r\nFRF_AB_EXT_PHY_RST_CTL,\r\nmethod == RESET_TYPE_INVISIBLE,\r\nFRF_AB_PCIE_CORE_RST_CTL, 1,\r\nFRF_AB_PCIE_NSTKY_RST_CTL, 1,\r\nFRF_AB_PCIE_SD_RST_CTL, 1,\r\nFRF_AB_EE_RST_CTL, 1,\r\nFRF_AB_EXT_PHY_RST_DUR,\r\nFFE_AB_EXT_PHY_RST_DUR_10240US,\r\nFRF_AB_SWRST, 1);\r\n}\r\nefx_writeo(efx, &glb_ctl_reg_ker, FR_AB_GLB_CTL);\r\nnetif_dbg(efx, hw, efx->net_dev, "waiting for hardware reset\n");\r\nschedule_timeout_uninterruptible(HZ / 20);\r\nif (method == RESET_TYPE_WORLD) {\r\nif (efx_nic_is_dual_func(efx))\r\npci_restore_state(nic_data->pci_dev2);\r\npci_restore_state(efx->pci_dev);\r\nnetif_dbg(efx, drv, efx->net_dev,\r\n"successfully restored PCI config\n");\r\n}\r\nefx_reado(efx, &glb_ctl_reg_ker, FR_AB_GLB_CTL);\r\nif (EFX_OWORD_FIELD(glb_ctl_reg_ker, FRF_AB_SWRST) != 0) {\r\nrc = -ETIMEDOUT;\r\nnetif_err(efx, hw, efx->net_dev,\r\n"timed out waiting for hardware reset\n");\r\ngoto fail3;\r\n}\r\nnetif_dbg(efx, hw, efx->net_dev, "hardware reset complete\n");\r\nreturn 0;\r\nfail2:\r\npci_restore_state(efx->pci_dev);\r\nfail1:\r\nfail3:\r\nreturn rc;\r\n}\r\nstatic int falcon_reset_hw(struct efx_nic *efx, enum reset_type method)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nint rc;\r\nmutex_lock(&nic_data->spi_lock);\r\nrc = __falcon_reset_hw(efx, method);\r\nmutex_unlock(&nic_data->spi_lock);\r\nreturn rc;\r\n}\r\nstatic void falcon_monitor(struct efx_nic *efx)\r\n{\r\nbool link_changed;\r\nint rc;\r\nBUG_ON(!mutex_is_locked(&efx->mac_lock));\r\nrc = falcon_board(efx)->type->monitor(efx);\r\nif (rc) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"Board sensor %s; shutting down PHY\n",\r\n(rc == -ERANGE) ? "reported fault" : "failed");\r\nefx->phy_mode |= PHY_MODE_LOW_POWER;\r\nrc = __efx_reconfigure_port(efx);\r\nWARN_ON(rc);\r\n}\r\nif (LOOPBACK_INTERNAL(efx))\r\nlink_changed = falcon_loopback_link_poll(efx);\r\nelse\r\nlink_changed = efx->phy_op->poll(efx);\r\nif (link_changed) {\r\nfalcon_stop_nic_stats(efx);\r\nfalcon_deconfigure_mac_wrapper(efx);\r\nfalcon_reset_macs(efx);\r\nrc = falcon_reconfigure_xmac(efx);\r\nBUG_ON(rc);\r\nfalcon_start_nic_stats(efx);\r\nefx_link_status_changed(efx);\r\n}\r\nfalcon_poll_xmac(efx);\r\n}\r\nstatic int falcon_reset_sram(struct efx_nic *efx)\r\n{\r\nefx_oword_t srm_cfg_reg_ker, gpio_cfg_reg_ker;\r\nint count;\r\nefx_reado(efx, &gpio_cfg_reg_ker, FR_AB_GPIO_CTL);\r\nEFX_SET_OWORD_FIELD(gpio_cfg_reg_ker, FRF_AB_GPIO1_OEN, 1);\r\nEFX_SET_OWORD_FIELD(gpio_cfg_reg_ker, FRF_AB_GPIO1_OUT, 1);\r\nefx_writeo(efx, &gpio_cfg_reg_ker, FR_AB_GPIO_CTL);\r\nEFX_POPULATE_OWORD_2(srm_cfg_reg_ker,\r\nFRF_AZ_SRM_INIT_EN, 1,\r\nFRF_AZ_SRM_NB_SZ, 0);\r\nefx_writeo(efx, &srm_cfg_reg_ker, FR_AZ_SRM_CFG);\r\ncount = 0;\r\ndo {\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"waiting for SRAM reset (attempt %d)...\n", count);\r\nschedule_timeout_uninterruptible(HZ / 50);\r\nefx_reado(efx, &srm_cfg_reg_ker, FR_AZ_SRM_CFG);\r\nif (!EFX_OWORD_FIELD(srm_cfg_reg_ker, FRF_AZ_SRM_INIT_EN)) {\r\nnetif_dbg(efx, hw, efx->net_dev,\r\n"SRAM reset complete\n");\r\nreturn 0;\r\n}\r\n} while (++count < 20);\r\nnetif_err(efx, hw, efx->net_dev, "timed out waiting for SRAM reset\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void falcon_spi_device_init(struct efx_nic *efx,\r\nstruct falcon_spi_device *spi_device,\r\nunsigned int device_id, u32 device_type)\r\n{\r\nif (device_type != 0) {\r\nspi_device->device_id = device_id;\r\nspi_device->size =\r\n1 << SPI_DEV_TYPE_FIELD(device_type, SPI_DEV_TYPE_SIZE);\r\nspi_device->addr_len =\r\nSPI_DEV_TYPE_FIELD(device_type, SPI_DEV_TYPE_ADDR_LEN);\r\nspi_device->munge_address = (spi_device->size == 1 << 9 &&\r\nspi_device->addr_len == 1);\r\nspi_device->erase_command =\r\nSPI_DEV_TYPE_FIELD(device_type, SPI_DEV_TYPE_ERASE_CMD);\r\nspi_device->erase_size =\r\n1 << SPI_DEV_TYPE_FIELD(device_type,\r\nSPI_DEV_TYPE_ERASE_SIZE);\r\nspi_device->block_size =\r\n1 << SPI_DEV_TYPE_FIELD(device_type,\r\nSPI_DEV_TYPE_BLOCK_SIZE);\r\n} else {\r\nspi_device->size = 0;\r\n}\r\n}\r\nstatic int falcon_probe_nvconfig(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nstruct falcon_nvconfig *nvconfig;\r\nint rc;\r\nnvconfig = kmalloc(sizeof(*nvconfig), GFP_KERNEL);\r\nif (!nvconfig)\r\nreturn -ENOMEM;\r\nrc = falcon_read_nvram(efx, nvconfig);\r\nif (rc)\r\ngoto out;\r\nefx->phy_type = nvconfig->board_v2.port0_phy_type;\r\nefx->mdio.prtad = nvconfig->board_v2.port0_phy_addr;\r\nif (le16_to_cpu(nvconfig->board_struct_ver) >= 3) {\r\nfalcon_spi_device_init(\r\nefx, &nic_data->spi_flash, FFE_AB_SPI_DEVICE_FLASH,\r\nle32_to_cpu(nvconfig->board_v3\r\n.spi_device_type[FFE_AB_SPI_DEVICE_FLASH]));\r\nfalcon_spi_device_init(\r\nefx, &nic_data->spi_eeprom, FFE_AB_SPI_DEVICE_EEPROM,\r\nle32_to_cpu(nvconfig->board_v3\r\n.spi_device_type[FFE_AB_SPI_DEVICE_EEPROM]));\r\n}\r\nmemcpy(efx->net_dev->perm_addr, nvconfig->mac_address[0], ETH_ALEN);\r\nnetif_dbg(efx, probe, efx->net_dev, "PHY is %d phy_id %d\n",\r\nefx->phy_type, efx->mdio.prtad);\r\nrc = falcon_probe_board(efx,\r\nle16_to_cpu(nvconfig->board_v2.board_revision));\r\nout:\r\nkfree(nvconfig);\r\nreturn rc;\r\n}\r\nstatic int falcon_dimension_resources(struct efx_nic *efx)\r\n{\r\nefx->rx_dc_base = 0x20000;\r\nefx->tx_dc_base = 0x26000;\r\nreturn 0;\r\n}\r\nstatic void falcon_probe_spi_devices(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nefx_oword_t nic_stat, gpio_ctl, ee_vpd_cfg;\r\nint boot_dev;\r\nefx_reado(efx, &gpio_ctl, FR_AB_GPIO_CTL);\r\nefx_reado(efx, &nic_stat, FR_AB_NIC_STAT);\r\nefx_reado(efx, &ee_vpd_cfg, FR_AB_EE_VPD_CFG0);\r\nif (EFX_OWORD_FIELD(gpio_ctl, FRF_AB_GPIO3_PWRUP_VALUE)) {\r\nboot_dev = (EFX_OWORD_FIELD(nic_stat, FRF_AB_SF_PRST) ?\r\nFFE_AB_SPI_DEVICE_FLASH : FFE_AB_SPI_DEVICE_EEPROM);\r\nnetif_dbg(efx, probe, efx->net_dev, "Booted from %s\n",\r\nboot_dev == FFE_AB_SPI_DEVICE_FLASH ?\r\n"flash" : "EEPROM");\r\n} else {\r\nboot_dev = -1;\r\nnetif_dbg(efx, probe, efx->net_dev,\r\n"Booted from internal ASIC settings;"\r\n" setting SPI config\n");\r\nEFX_POPULATE_OWORD_3(ee_vpd_cfg, FRF_AB_EE_VPD_EN, 0,\r\nFRF_AB_EE_SF_CLOCK_DIV, 7,\r\nFRF_AB_EE_EE_CLOCK_DIV, 63);\r\nefx_writeo(efx, &ee_vpd_cfg, FR_AB_EE_VPD_CFG0);\r\n}\r\nmutex_init(&nic_data->spi_lock);\r\nif (boot_dev == FFE_AB_SPI_DEVICE_FLASH)\r\nfalcon_spi_device_init(efx, &nic_data->spi_flash,\r\nFFE_AB_SPI_DEVICE_FLASH,\r\ndefault_flash_type);\r\nif (boot_dev == FFE_AB_SPI_DEVICE_EEPROM)\r\nfalcon_spi_device_init(efx, &nic_data->spi_eeprom,\r\nFFE_AB_SPI_DEVICE_EEPROM,\r\nlarge_eeprom_type);\r\n}\r\nstatic unsigned int falcon_a1_mem_map_size(struct efx_nic *efx)\r\n{\r\nreturn 0x20000;\r\n}\r\nstatic unsigned int falcon_b0_mem_map_size(struct efx_nic *efx)\r\n{\r\nreturn FR_BZ_RX_INDIRECTION_TBL +\r\nFR_BZ_RX_INDIRECTION_TBL_STEP * FR_BZ_RX_INDIRECTION_TBL_ROWS;\r\n}\r\nstatic int falcon_probe_nic(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data;\r\nstruct falcon_board *board;\r\nint rc;\r\nnic_data = kzalloc(sizeof(*nic_data), GFP_KERNEL);\r\nif (!nic_data)\r\nreturn -ENOMEM;\r\nefx->nic_data = nic_data;\r\nrc = -ENODEV;\r\nif (efx_farch_fpga_ver(efx) != 0) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"Falcon FPGA not supported\n");\r\ngoto fail1;\r\n}\r\nif (efx_nic_rev(efx) <= EFX_REV_FALCON_A1) {\r\nefx_oword_t nic_stat;\r\nstruct pci_dev *dev;\r\nu8 pci_rev = efx->pci_dev->revision;\r\nif ((pci_rev == 0xff) || (pci_rev == 0)) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"Falcon rev A0 not supported\n");\r\ngoto fail1;\r\n}\r\nefx_reado(efx, &nic_stat, FR_AB_NIC_STAT);\r\nif (EFX_OWORD_FIELD(nic_stat, FRF_AB_STRAP_10G) == 0) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"Falcon rev A1 1G not supported\n");\r\ngoto fail1;\r\n}\r\nif (EFX_OWORD_FIELD(nic_stat, FRF_AA_STRAP_PCIE) == 0) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"Falcon rev A1 PCI-X not supported\n");\r\ngoto fail1;\r\n}\r\ndev = pci_dev_get(efx->pci_dev);\r\nwhile ((dev = pci_get_device(PCI_VENDOR_ID_SOLARFLARE,\r\nPCI_DEVICE_ID_SOLARFLARE_SFC4000A_1,\r\ndev))) {\r\nif (dev->bus == efx->pci_dev->bus &&\r\ndev->devfn == efx->pci_dev->devfn + 1) {\r\nnic_data->pci_dev2 = dev;\r\nbreak;\r\n}\r\n}\r\nif (!nic_data->pci_dev2) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"failed to find secondary function\n");\r\nrc = -ENODEV;\r\ngoto fail2;\r\n}\r\n}\r\nrc = __falcon_reset_hw(efx, RESET_TYPE_ALL);\r\nif (rc) {\r\nnetif_err(efx, probe, efx->net_dev, "failed to reset NIC\n");\r\ngoto fail3;\r\n}\r\nrc = efx_nic_alloc_buffer(efx, &efx->irq_status, sizeof(efx_oword_t),\r\nGFP_KERNEL);\r\nif (rc)\r\ngoto fail4;\r\nBUG_ON(efx->irq_status.dma_addr & 0x0f);\r\nnetif_dbg(efx, probe, efx->net_dev,\r\n"INT_KER at %llx (virt %p phys %llx)\n",\r\n(u64)efx->irq_status.dma_addr,\r\nefx->irq_status.addr,\r\n(u64)virt_to_phys(efx->irq_status.addr));\r\nfalcon_probe_spi_devices(efx);\r\nrc = falcon_probe_nvconfig(efx);\r\nif (rc) {\r\nif (rc == -EINVAL)\r\nnetif_err(efx, probe, efx->net_dev, "NVRAM is invalid\n");\r\ngoto fail5;\r\n}\r\nefx->max_channels = (efx_nic_rev(efx) <= EFX_REV_FALCON_A1 ? 4 :\r\nEFX_MAX_CHANNELS);\r\nefx->timer_quantum_ns = 4968;\r\nboard = falcon_board(efx);\r\nboard->i2c_adap.owner = THIS_MODULE;\r\nboard->i2c_data = falcon_i2c_bit_operations;\r\nboard->i2c_data.data = efx;\r\nboard->i2c_adap.algo_data = &board->i2c_data;\r\nboard->i2c_adap.dev.parent = &efx->pci_dev->dev;\r\nstrlcpy(board->i2c_adap.name, "SFC4000 GPIO",\r\nsizeof(board->i2c_adap.name));\r\nrc = i2c_bit_add_bus(&board->i2c_adap);\r\nif (rc)\r\ngoto fail5;\r\nrc = falcon_board(efx)->type->init(efx);\r\nif (rc) {\r\nnetif_err(efx, probe, efx->net_dev,\r\n"failed to initialise board\n");\r\ngoto fail6;\r\n}\r\nnic_data->stats_disable_count = 1;\r\nsetup_timer(&nic_data->stats_timer, &falcon_stats_timer_func,\r\n(unsigned long)efx);\r\nreturn 0;\r\nfail6:\r\ni2c_del_adapter(&board->i2c_adap);\r\nmemset(&board->i2c_adap, 0, sizeof(board->i2c_adap));\r\nfail5:\r\nefx_nic_free_buffer(efx, &efx->irq_status);\r\nfail4:\r\nfail3:\r\nif (nic_data->pci_dev2) {\r\npci_dev_put(nic_data->pci_dev2);\r\nnic_data->pci_dev2 = NULL;\r\n}\r\nfail2:\r\nfail1:\r\nkfree(efx->nic_data);\r\nreturn rc;\r\n}\r\nstatic void falcon_init_rx_cfg(struct efx_nic *efx)\r\n{\r\nconst unsigned ctrl_xon_thr = 20;\r\nconst unsigned ctrl_xoff_thr = 25;\r\nefx_oword_t reg;\r\nefx_reado(efx, &reg, FR_AZ_RX_CFG);\r\nif (efx_nic_rev(efx) <= EFX_REV_FALCON_A1) {\r\nEFX_SET_OWORD_FIELD(reg, FRF_AA_RX_DESC_PUSH_EN, 0);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AA_RX_USR_BUF_SIZE,\r\n(3 * 4096) >> 5);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AA_RX_XON_MAC_TH, 512 >> 8);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AA_RX_XOFF_MAC_TH, 2048 >> 8);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AA_RX_XON_TX_TH, ctrl_xon_thr);\r\nEFX_SET_OWORD_FIELD(reg, FRF_AA_RX_XOFF_TX_TH, ctrl_xoff_thr);\r\n} else {\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_DESC_PUSH_EN, 0);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_USR_BUF_SIZE,\r\nEFX_RX_USR_BUF_SIZE >> 5);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_XON_MAC_TH, 27648 >> 8);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_XOFF_MAC_TH, 54272 >> 8);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_XON_TX_TH, ctrl_xon_thr);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_XOFF_TX_TH, ctrl_xoff_thr);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_INGR_EN, 1);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_HASH_INSRT_HDR, 1);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_HASH_ALG, 1);\r\nEFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_IP_HASH, 1);\r\n}\r\nEFX_SET_OWORD_FIELD(reg, FRF_AZ_RX_XOFF_MAC_EN, 1);\r\nefx_writeo(efx, &reg, FR_AZ_RX_CFG);\r\n}\r\nstatic int falcon_init_nic(struct efx_nic *efx)\r\n{\r\nefx_oword_t temp;\r\nint rc;\r\nefx_reado(efx, &temp, FR_AB_NIC_STAT);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AB_ONCHIP_SRAM, 1);\r\nefx_writeo(efx, &temp, FR_AB_NIC_STAT);\r\nrc = falcon_reset_sram(efx);\r\nif (rc)\r\nreturn rc;\r\nif (EFX_WORKAROUND_5129(efx)) {\r\nefx_reado(efx, &temp, FR_AZ_CSR_SPARE);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AB_MEM_PERR_EN_TX_DATA, 0);\r\nefx_writeo(efx, &temp, FR_AZ_CSR_SPARE);\r\n}\r\nif (EFX_WORKAROUND_7244(efx)) {\r\nefx_reado(efx, &temp, FR_BZ_RX_FILTER_CTL);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_UDP_FULL_SRCH_LIMIT, 8);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_UDP_WILD_SRCH_LIMIT, 8);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_TCP_FULL_SRCH_LIMIT, 8);\r\nEFX_SET_OWORD_FIELD(temp, FRF_BZ_TCP_WILD_SRCH_LIMIT, 8);\r\nefx_writeo(efx, &temp, FR_BZ_RX_FILTER_CTL);\r\n}\r\nefx_reado(efx, &temp, FR_AA_RX_SELF_RST);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AA_RX_NODESC_WAIT_DIS, 1);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AA_RX_SELF_RST_EN, 1);\r\nif (EFX_WORKAROUND_5583(efx))\r\nEFX_SET_OWORD_FIELD(temp, FRF_AA_RX_ISCSI_DIS, 1);\r\nefx_writeo(efx, &temp, FR_AA_RX_SELF_RST);\r\nefx_reado(efx, &temp, FR_AZ_TX_CFG);\r\nEFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_NO_EOP_DISC_EN, 0);\r\nefx_writeo(efx, &temp, FR_AZ_TX_CFG);\r\nfalcon_init_rx_cfg(efx);\r\nif (efx_nic_rev(efx) >= EFX_REV_FALCON_B0) {\r\nmemcpy(&temp, efx->rx_hash_key, sizeof(temp));\r\nefx_writeo(efx, &temp, FR_BZ_RX_RSS_TKEY);\r\nEFX_POPULATE_OWORD_1(temp, FRF_BZ_FLS_EVQ_ID, 0);\r\nefx_writeo(efx, &temp, FR_BZ_DP_CTRL);\r\n}\r\nefx_farch_init_common(efx);\r\nreturn 0;\r\n}\r\nstatic void falcon_remove_nic(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nstruct falcon_board *board = falcon_board(efx);\r\nboard->type->fini(efx);\r\ni2c_del_adapter(&board->i2c_adap);\r\nmemset(&board->i2c_adap, 0, sizeof(board->i2c_adap));\r\nefx_nic_free_buffer(efx, &efx->irq_status);\r\n__falcon_reset_hw(efx, RESET_TYPE_ALL);\r\nif (nic_data->pci_dev2) {\r\npci_dev_put(nic_data->pci_dev2);\r\nnic_data->pci_dev2 = NULL;\r\n}\r\nkfree(efx->nic_data);\r\nefx->nic_data = NULL;\r\n}\r\nstatic size_t falcon_describe_nic_stats(struct efx_nic *efx, u8 *names)\r\n{\r\nreturn efx_nic_describe_stats(falcon_stat_desc, FALCON_STAT_COUNT,\r\nfalcon_stat_mask, names);\r\n}\r\nstatic size_t falcon_update_nic_stats(struct efx_nic *efx, u64 *full_stats,\r\nstruct rtnl_link_stats64 *core_stats)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nu64 *stats = nic_data->stats;\r\nefx_oword_t cnt;\r\nif (!nic_data->stats_disable_count) {\r\nefx_reado(efx, &cnt, FR_AZ_RX_NODESC_DROP);\r\nstats[FALCON_STAT_rx_nodesc_drop_cnt] +=\r\nEFX_OWORD_FIELD(cnt, FRF_AB_RX_NODESC_DROP_CNT);\r\nif (nic_data->stats_pending &&\r\nFALCON_XMAC_STATS_DMA_FLAG(efx)) {\r\nnic_data->stats_pending = false;\r\nrmb();\r\nefx_nic_update_stats(\r\nfalcon_stat_desc, FALCON_STAT_COUNT,\r\nfalcon_stat_mask,\r\nstats, efx->stats_buffer.addr, true);\r\n}\r\nefx_update_diff_stat(&stats[FALCON_STAT_rx_bad_bytes],\r\nstats[FALCON_STAT_rx_bytes] -\r\nstats[FALCON_STAT_rx_good_bytes] -\r\nstats[FALCON_STAT_rx_control] * 64);\r\n}\r\nif (full_stats)\r\nmemcpy(full_stats, stats, sizeof(u64) * FALCON_STAT_COUNT);\r\nif (core_stats) {\r\ncore_stats->rx_packets = stats[FALCON_STAT_rx_packets];\r\ncore_stats->tx_packets = stats[FALCON_STAT_tx_packets];\r\ncore_stats->rx_bytes = stats[FALCON_STAT_rx_bytes];\r\ncore_stats->tx_bytes = stats[FALCON_STAT_tx_bytes];\r\ncore_stats->rx_dropped = stats[FALCON_STAT_rx_nodesc_drop_cnt];\r\ncore_stats->multicast = stats[FALCON_STAT_rx_multicast];\r\ncore_stats->rx_length_errors =\r\nstats[FALCON_STAT_rx_gtjumbo] +\r\nstats[FALCON_STAT_rx_length_error];\r\ncore_stats->rx_crc_errors = stats[FALCON_STAT_rx_bad];\r\ncore_stats->rx_frame_errors = stats[FALCON_STAT_rx_align_error];\r\ncore_stats->rx_fifo_errors = stats[FALCON_STAT_rx_overflow];\r\ncore_stats->rx_errors = (core_stats->rx_length_errors +\r\ncore_stats->rx_crc_errors +\r\ncore_stats->rx_frame_errors +\r\nstats[FALCON_STAT_rx_symbol_error]);\r\n}\r\nreturn FALCON_STAT_COUNT;\r\n}\r\nvoid falcon_start_nic_stats(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nspin_lock_bh(&efx->stats_lock);\r\nif (--nic_data->stats_disable_count == 0)\r\nfalcon_stats_request(efx);\r\nspin_unlock_bh(&efx->stats_lock);\r\n}\r\nvoid falcon_stop_nic_stats(struct efx_nic *efx)\r\n{\r\nstruct falcon_nic_data *nic_data = efx->nic_data;\r\nint i;\r\nmight_sleep();\r\nspin_lock_bh(&efx->stats_lock);\r\n++nic_data->stats_disable_count;\r\nspin_unlock_bh(&efx->stats_lock);\r\ndel_timer_sync(&nic_data->stats_timer);\r\nfor (i = 0; i < 4 && nic_data->stats_pending; i++) {\r\nif (FALCON_XMAC_STATS_DMA_FLAG(efx))\r\nbreak;\r\nmsleep(1);\r\n}\r\nspin_lock_bh(&efx->stats_lock);\r\nfalcon_stats_complete(efx);\r\nspin_unlock_bh(&efx->stats_lock);\r\n}\r\nstatic void falcon_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)\r\n{\r\nfalcon_board(efx)->type->set_id_led(efx, mode);\r\n}\r\nstatic void falcon_get_wol(struct efx_nic *efx, struct ethtool_wolinfo *wol)\r\n{\r\nwol->supported = 0;\r\nwol->wolopts = 0;\r\nmemset(&wol->sopass, 0, sizeof(wol->sopass));\r\n}\r\nstatic int falcon_set_wol(struct efx_nic *efx, u32 type)\r\n{\r\nif (type != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}
