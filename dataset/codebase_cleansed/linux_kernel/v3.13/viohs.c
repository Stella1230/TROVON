int vio_ldc_send(struct vio_driver_state *vio, void *data, int len)\r\n{\r\nint err, limit = 1000;\r\nerr = -EINVAL;\r\nwhile (limit-- > 0) {\r\nerr = ldc_write(vio->lp, data, len);\r\nif (!err || (err != -EAGAIN))\r\nbreak;\r\nudelay(1);\r\n}\r\nreturn err;\r\n}\r\nstatic int send_ctrl(struct vio_driver_state *vio,\r\nstruct vio_msg_tag *tag, int len)\r\n{\r\ntag->sid = vio_send_sid(vio);\r\nreturn vio_ldc_send(vio, tag, len);\r\n}\r\nstatic void init_tag(struct vio_msg_tag *tag, u8 type, u8 stype, u16 stype_env)\r\n{\r\ntag->type = type;\r\ntag->stype = stype;\r\ntag->stype_env = stype_env;\r\n}\r\nstatic int send_version(struct vio_driver_state *vio, u16 major, u16 minor)\r\n{\r\nstruct vio_ver_info pkt;\r\nvio->_local_sid = (u32) sched_clock();\r\nmemset(&pkt, 0, sizeof(pkt));\r\ninit_tag(&pkt.tag, VIO_TYPE_CTRL, VIO_SUBTYPE_INFO, VIO_VER_INFO);\r\npkt.major = major;\r\npkt.minor = minor;\r\npkt.dev_class = vio->dev_class;\r\nviodbg(HS, "SEND VERSION INFO maj[%u] min[%u] devclass[%u]\n",\r\nmajor, minor, vio->dev_class);\r\nreturn send_ctrl(vio, &pkt.tag, sizeof(pkt));\r\n}\r\nstatic int start_handshake(struct vio_driver_state *vio)\r\n{\r\nint err;\r\nviodbg(HS, "START HANDSHAKE\n");\r\nvio->hs_state = VIO_HS_INVALID;\r\nerr = send_version(vio,\r\nvio->ver_table[0].major,\r\nvio->ver_table[0].minor);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void flush_rx_dring(struct vio_driver_state *vio)\r\n{\r\nstruct vio_dring_state *dr;\r\nu64 ident;\r\nBUG_ON(!(vio->dr_state & VIO_DR_STATE_RXREG));\r\ndr = &vio->drings[VIO_DRIVER_RX_RING];\r\nident = dr->ident;\r\nBUG_ON(!vio->desc_buf);\r\nkfree(vio->desc_buf);\r\nvio->desc_buf = NULL;\r\nmemset(dr, 0, sizeof(*dr));\r\ndr->ident = ident;\r\n}\r\nvoid vio_link_state_change(struct vio_driver_state *vio, int event)\r\n{\r\nif (event == LDC_EVENT_UP) {\r\nvio->hs_state = VIO_HS_INVALID;\r\nswitch (vio->dev_class) {\r\ncase VDEV_NETWORK:\r\ncase VDEV_NETWORK_SWITCH:\r\nvio->dr_state = (VIO_DR_STATE_TXREQ |\r\nVIO_DR_STATE_RXREQ);\r\nbreak;\r\ncase VDEV_DISK:\r\nvio->dr_state = VIO_DR_STATE_TXREQ;\r\nbreak;\r\ncase VDEV_DISK_SERVER:\r\nvio->dr_state = VIO_DR_STATE_RXREQ;\r\nbreak;\r\n}\r\nstart_handshake(vio);\r\n} else if (event == LDC_EVENT_RESET) {\r\nvio->hs_state = VIO_HS_INVALID;\r\nif (vio->dr_state & VIO_DR_STATE_RXREG)\r\nflush_rx_dring(vio);\r\nvio->dr_state = 0x00;\r\nmemset(&vio->ver, 0, sizeof(vio->ver));\r\nldc_disconnect(vio->lp);\r\n}\r\n}\r\nstatic int handshake_failure(struct vio_driver_state *vio)\r\n{\r\nstruct vio_dring_state *dr;\r\nviodbg(HS, "HANDSHAKE FAILURE\n");\r\nvio->dr_state &= ~(VIO_DR_STATE_TXREG |\r\nVIO_DR_STATE_RXREG);\r\ndr = &vio->drings[VIO_DRIVER_RX_RING];\r\nmemset(dr, 0, sizeof(*dr));\r\nkfree(vio->desc_buf);\r\nvio->desc_buf = NULL;\r\nvio->desc_buf_len = 0;\r\nvio->hs_state = VIO_HS_INVALID;\r\nreturn -ECONNRESET;\r\n}\r\nstatic int process_unknown(struct vio_driver_state *vio, void *arg)\r\n{\r\nstruct vio_msg_tag *pkt = arg;\r\nviodbg(HS, "UNKNOWN CONTROL [%02x:%02x:%04x:%08x]\n",\r\npkt->type, pkt->stype, pkt->stype_env, pkt->sid);\r\nprintk(KERN_ERR "vio: ID[%lu] Resetting connection.\n",\r\nvio->vdev->channel_id);\r\nldc_disconnect(vio->lp);\r\nreturn -ECONNRESET;\r\n}\r\nstatic int send_dreg(struct vio_driver_state *vio)\r\n{\r\nstruct vio_dring_state *dr = &vio->drings[VIO_DRIVER_TX_RING];\r\nunion {\r\nstruct vio_dring_register pkt;\r\nchar all[sizeof(struct vio_dring_register) +\r\n(sizeof(struct ldc_trans_cookie) *\r\ndr->ncookies)];\r\n} u;\r\nint i;\r\nmemset(&u, 0, sizeof(u));\r\ninit_tag(&u.pkt.tag, VIO_TYPE_CTRL, VIO_SUBTYPE_INFO, VIO_DRING_REG);\r\nu.pkt.dring_ident = 0;\r\nu.pkt.num_descr = dr->num_entries;\r\nu.pkt.descr_size = dr->entry_size;\r\nu.pkt.options = VIO_TX_DRING;\r\nu.pkt.num_cookies = dr->ncookies;\r\nviodbg(HS, "SEND DRING_REG INFO ndesc[%u] dsz[%u] opt[0x%x] "\r\n"ncookies[%u]\n",\r\nu.pkt.num_descr, u.pkt.descr_size, u.pkt.options,\r\nu.pkt.num_cookies);\r\nfor (i = 0; i < dr->ncookies; i++) {\r\nu.pkt.cookies[i] = dr->cookies[i];\r\nviodbg(HS, "DRING COOKIE(%d) [%016llx:%016llx]\n",\r\ni,\r\n(unsigned long long) u.pkt.cookies[i].cookie_addr,\r\n(unsigned long long) u.pkt.cookies[i].cookie_size);\r\n}\r\nreturn send_ctrl(vio, &u.pkt.tag, sizeof(u));\r\n}\r\nstatic int send_rdx(struct vio_driver_state *vio)\r\n{\r\nstruct vio_rdx pkt;\r\nmemset(&pkt, 0, sizeof(pkt));\r\ninit_tag(&pkt.tag, VIO_TYPE_CTRL, VIO_SUBTYPE_INFO, VIO_RDX);\r\nviodbg(HS, "SEND RDX INFO\n");\r\nreturn send_ctrl(vio, &pkt.tag, sizeof(pkt));\r\n}\r\nstatic int send_attr(struct vio_driver_state *vio)\r\n{\r\nreturn vio->ops->send_attr(vio);\r\n}\r\nstatic struct vio_version *find_by_major(struct vio_driver_state *vio,\r\nu16 major)\r\n{\r\nstruct vio_version *ret = NULL;\r\nint i;\r\nfor (i = 0; i < vio->ver_table_entries; i++) {\r\nstruct vio_version *v = &vio->ver_table[i];\r\nif (v->major <= major) {\r\nret = v;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int process_ver_info(struct vio_driver_state *vio,\r\nstruct vio_ver_info *pkt)\r\n{\r\nstruct vio_version *vap;\r\nint err;\r\nviodbg(HS, "GOT VERSION INFO maj[%u] min[%u] devclass[%u]\n",\r\npkt->major, pkt->minor, pkt->dev_class);\r\nif (vio->hs_state != VIO_HS_INVALID) {\r\nmemset(&vio->ver, 0, sizeof(vio->ver));\r\nvio->hs_state = VIO_HS_INVALID;\r\n}\r\nvap = find_by_major(vio, pkt->major);\r\nvio->_peer_sid = pkt->tag.sid;\r\nif (!vap) {\r\npkt->tag.stype = VIO_SUBTYPE_NACK;\r\npkt->major = 0;\r\npkt->minor = 0;\r\nviodbg(HS, "SEND VERSION NACK maj[0] min[0]\n");\r\nerr = send_ctrl(vio, &pkt->tag, sizeof(*pkt));\r\n} else if (vap->major != pkt->major) {\r\npkt->tag.stype = VIO_SUBTYPE_NACK;\r\npkt->major = vap->major;\r\npkt->minor = vap->minor;\r\nviodbg(HS, "SEND VERSION NACK maj[%u] min[%u]\n",\r\npkt->major, pkt->minor);\r\nerr = send_ctrl(vio, &pkt->tag, sizeof(*pkt));\r\n} else {\r\nstruct vio_version ver = {\r\n.major = pkt->major,\r\n.minor = pkt->minor,\r\n};\r\nif (ver.minor > vap->minor)\r\nver.minor = vap->minor;\r\npkt->minor = ver.minor;\r\npkt->tag.stype = VIO_SUBTYPE_ACK;\r\nviodbg(HS, "SEND VERSION ACK maj[%u] min[%u]\n",\r\npkt->major, pkt->minor);\r\nerr = send_ctrl(vio, &pkt->tag, sizeof(*pkt));\r\nif (err > 0) {\r\nvio->ver = ver;\r\nvio->hs_state = VIO_HS_GOTVERS;\r\n}\r\n}\r\nif (err < 0)\r\nreturn handshake_failure(vio);\r\nreturn 0;\r\n}\r\nstatic int process_ver_ack(struct vio_driver_state *vio,\r\nstruct vio_ver_info *pkt)\r\n{\r\nviodbg(HS, "GOT VERSION ACK maj[%u] min[%u] devclass[%u]\n",\r\npkt->major, pkt->minor, pkt->dev_class);\r\nif (vio->hs_state & VIO_HS_GOTVERS) {\r\nif (vio->ver.major != pkt->major ||\r\nvio->ver.minor != pkt->minor) {\r\npkt->tag.stype = VIO_SUBTYPE_NACK;\r\n(void) send_ctrl(vio, &pkt->tag, sizeof(*pkt));\r\nreturn handshake_failure(vio);\r\n}\r\n} else {\r\nvio->ver.major = pkt->major;\r\nvio->ver.minor = pkt->minor;\r\nvio->hs_state = VIO_HS_GOTVERS;\r\n}\r\nswitch (vio->dev_class) {\r\ncase VDEV_NETWORK:\r\ncase VDEV_DISK:\r\nif (send_attr(vio) < 0)\r\nreturn handshake_failure(vio);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int process_ver_nack(struct vio_driver_state *vio,\r\nstruct vio_ver_info *pkt)\r\n{\r\nstruct vio_version *nver;\r\nviodbg(HS, "GOT VERSION NACK maj[%u] min[%u] devclass[%u]\n",\r\npkt->major, pkt->minor, pkt->dev_class);\r\nif (pkt->major == 0 && pkt->minor == 0)\r\nreturn handshake_failure(vio);\r\nnver = find_by_major(vio, pkt->major);\r\nif (!nver)\r\nreturn handshake_failure(vio);\r\nif (send_version(vio, nver->major, nver->minor) < 0)\r\nreturn handshake_failure(vio);\r\nreturn 0;\r\n}\r\nstatic int process_ver(struct vio_driver_state *vio, struct vio_ver_info *pkt)\r\n{\r\nswitch (pkt->tag.stype) {\r\ncase VIO_SUBTYPE_INFO:\r\nreturn process_ver_info(vio, pkt);\r\ncase VIO_SUBTYPE_ACK:\r\nreturn process_ver_ack(vio, pkt);\r\ncase VIO_SUBTYPE_NACK:\r\nreturn process_ver_nack(vio, pkt);\r\ndefault:\r\nreturn handshake_failure(vio);\r\n}\r\n}\r\nstatic int process_attr(struct vio_driver_state *vio, void *pkt)\r\n{\r\nint err;\r\nif (!(vio->hs_state & VIO_HS_GOTVERS))\r\nreturn handshake_failure(vio);\r\nerr = vio->ops->handle_attr(vio, pkt);\r\nif (err < 0) {\r\nreturn handshake_failure(vio);\r\n} else {\r\nvio->hs_state |= VIO_HS_GOT_ATTR;\r\nif ((vio->dr_state & VIO_DR_STATE_TXREQ) &&\r\n!(vio->hs_state & VIO_HS_SENT_DREG)) {\r\nif (send_dreg(vio) < 0)\r\nreturn handshake_failure(vio);\r\nvio->hs_state |= VIO_HS_SENT_DREG;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int all_drings_registered(struct vio_driver_state *vio)\r\n{\r\nint need_rx, need_tx;\r\nneed_rx = (vio->dr_state & VIO_DR_STATE_RXREQ);\r\nneed_tx = (vio->dr_state & VIO_DR_STATE_TXREQ);\r\nif (need_rx &&\r\n!(vio->dr_state & VIO_DR_STATE_RXREG))\r\nreturn 0;\r\nif (need_tx &&\r\n!(vio->dr_state & VIO_DR_STATE_TXREG))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int process_dreg_info(struct vio_driver_state *vio,\r\nstruct vio_dring_register *pkt)\r\n{\r\nstruct vio_dring_state *dr;\r\nint i, len;\r\nviodbg(HS, "GOT DRING_REG INFO ident[%llx] "\r\n"ndesc[%u] dsz[%u] opt[0x%x] ncookies[%u]\n",\r\n(unsigned long long) pkt->dring_ident,\r\npkt->num_descr, pkt->descr_size, pkt->options,\r\npkt->num_cookies);\r\nif (!(vio->dr_state & VIO_DR_STATE_RXREQ))\r\ngoto send_nack;\r\nif (vio->dr_state & VIO_DR_STATE_RXREG)\r\ngoto send_nack;\r\nBUG_ON(vio->desc_buf);\r\nvio->desc_buf = kzalloc(pkt->descr_size, GFP_ATOMIC);\r\nif (!vio->desc_buf)\r\ngoto send_nack;\r\nvio->desc_buf_len = pkt->descr_size;\r\ndr = &vio->drings[VIO_DRIVER_RX_RING];\r\ndr->num_entries = pkt->num_descr;\r\ndr->entry_size = pkt->descr_size;\r\ndr->ncookies = pkt->num_cookies;\r\nfor (i = 0; i < dr->ncookies; i++) {\r\ndr->cookies[i] = pkt->cookies[i];\r\nviodbg(HS, "DRING COOKIE(%d) [%016llx:%016llx]\n",\r\ni,\r\n(unsigned long long)\r\npkt->cookies[i].cookie_addr,\r\n(unsigned long long)\r\npkt->cookies[i].cookie_size);\r\n}\r\npkt->tag.stype = VIO_SUBTYPE_ACK;\r\npkt->dring_ident = ++dr->ident;\r\nviodbg(HS, "SEND DRING_REG ACK ident[%llx]\n",\r\n(unsigned long long) pkt->dring_ident);\r\nlen = (sizeof(*pkt) +\r\n(dr->ncookies * sizeof(struct ldc_trans_cookie)));\r\nif (send_ctrl(vio, &pkt->tag, len) < 0)\r\ngoto send_nack;\r\nvio->dr_state |= VIO_DR_STATE_RXREG;\r\nreturn 0;\r\nsend_nack:\r\npkt->tag.stype = VIO_SUBTYPE_NACK;\r\nviodbg(HS, "SEND DRING_REG NACK\n");\r\n(void) send_ctrl(vio, &pkt->tag, sizeof(*pkt));\r\nreturn handshake_failure(vio);\r\n}\r\nstatic int process_dreg_ack(struct vio_driver_state *vio,\r\nstruct vio_dring_register *pkt)\r\n{\r\nstruct vio_dring_state *dr;\r\nviodbg(HS, "GOT DRING_REG ACK ident[%llx] "\r\n"ndesc[%u] dsz[%u] opt[0x%x] ncookies[%u]\n",\r\n(unsigned long long) pkt->dring_ident,\r\npkt->num_descr, pkt->descr_size, pkt->options,\r\npkt->num_cookies);\r\ndr = &vio->drings[VIO_DRIVER_TX_RING];\r\nif (!(vio->dr_state & VIO_DR_STATE_TXREQ))\r\nreturn handshake_failure(vio);\r\ndr->ident = pkt->dring_ident;\r\nvio->dr_state |= VIO_DR_STATE_TXREG;\r\nif (all_drings_registered(vio)) {\r\nif (send_rdx(vio) < 0)\r\nreturn handshake_failure(vio);\r\nvio->hs_state = VIO_HS_SENT_RDX;\r\n}\r\nreturn 0;\r\n}\r\nstatic int process_dreg_nack(struct vio_driver_state *vio,\r\nstruct vio_dring_register *pkt)\r\n{\r\nviodbg(HS, "GOT DRING_REG NACK ident[%llx] "\r\n"ndesc[%u] dsz[%u] opt[0x%x] ncookies[%u]\n",\r\n(unsigned long long) pkt->dring_ident,\r\npkt->num_descr, pkt->descr_size, pkt->options,\r\npkt->num_cookies);\r\nreturn handshake_failure(vio);\r\n}\r\nstatic int process_dreg(struct vio_driver_state *vio,\r\nstruct vio_dring_register *pkt)\r\n{\r\nif (!(vio->hs_state & VIO_HS_GOTVERS))\r\nreturn handshake_failure(vio);\r\nswitch (pkt->tag.stype) {\r\ncase VIO_SUBTYPE_INFO:\r\nreturn process_dreg_info(vio, pkt);\r\ncase VIO_SUBTYPE_ACK:\r\nreturn process_dreg_ack(vio, pkt);\r\ncase VIO_SUBTYPE_NACK:\r\nreturn process_dreg_nack(vio, pkt);\r\ndefault:\r\nreturn handshake_failure(vio);\r\n}\r\n}\r\nstatic int process_dunreg(struct vio_driver_state *vio,\r\nstruct vio_dring_unregister *pkt)\r\n{\r\nstruct vio_dring_state *dr = &vio->drings[VIO_DRIVER_RX_RING];\r\nviodbg(HS, "GOT DRING_UNREG\n");\r\nif (pkt->dring_ident != dr->ident)\r\nreturn 0;\r\nvio->dr_state &= ~VIO_DR_STATE_RXREG;\r\nmemset(dr, 0, sizeof(*dr));\r\nkfree(vio->desc_buf);\r\nvio->desc_buf = NULL;\r\nvio->desc_buf_len = 0;\r\nreturn 0;\r\n}\r\nstatic int process_rdx_info(struct vio_driver_state *vio, struct vio_rdx *pkt)\r\n{\r\nviodbg(HS, "GOT RDX INFO\n");\r\npkt->tag.stype = VIO_SUBTYPE_ACK;\r\nviodbg(HS, "SEND RDX ACK\n");\r\nif (send_ctrl(vio, &pkt->tag, sizeof(*pkt)) < 0)\r\nreturn handshake_failure(vio);\r\nvio->hs_state |= VIO_HS_SENT_RDX_ACK;\r\nreturn 0;\r\n}\r\nstatic int process_rdx_ack(struct vio_driver_state *vio, struct vio_rdx *pkt)\r\n{\r\nviodbg(HS, "GOT RDX ACK\n");\r\nif (!(vio->hs_state & VIO_HS_SENT_RDX))\r\nreturn handshake_failure(vio);\r\nvio->hs_state |= VIO_HS_GOT_RDX_ACK;\r\nreturn 0;\r\n}\r\nstatic int process_rdx_nack(struct vio_driver_state *vio, struct vio_rdx *pkt)\r\n{\r\nviodbg(HS, "GOT RDX NACK\n");\r\nreturn handshake_failure(vio);\r\n}\r\nstatic int process_rdx(struct vio_driver_state *vio, struct vio_rdx *pkt)\r\n{\r\nif (!all_drings_registered(vio))\r\nhandshake_failure(vio);\r\nswitch (pkt->tag.stype) {\r\ncase VIO_SUBTYPE_INFO:\r\nreturn process_rdx_info(vio, pkt);\r\ncase VIO_SUBTYPE_ACK:\r\nreturn process_rdx_ack(vio, pkt);\r\ncase VIO_SUBTYPE_NACK:\r\nreturn process_rdx_nack(vio, pkt);\r\ndefault:\r\nreturn handshake_failure(vio);\r\n}\r\n}\r\nint vio_control_pkt_engine(struct vio_driver_state *vio, void *pkt)\r\n{\r\nstruct vio_msg_tag *tag = pkt;\r\nu8 prev_state = vio->hs_state;\r\nint err;\r\nswitch (tag->stype_env) {\r\ncase VIO_VER_INFO:\r\nerr = process_ver(vio, pkt);\r\nbreak;\r\ncase VIO_ATTR_INFO:\r\nerr = process_attr(vio, pkt);\r\nbreak;\r\ncase VIO_DRING_REG:\r\nerr = process_dreg(vio, pkt);\r\nbreak;\r\ncase VIO_DRING_UNREG:\r\nerr = process_dunreg(vio, pkt);\r\nbreak;\r\ncase VIO_RDX:\r\nerr = process_rdx(vio, pkt);\r\nbreak;\r\ndefault:\r\nerr = process_unknown(vio, pkt);\r\nbreak;\r\n}\r\nif (!err &&\r\nvio->hs_state != prev_state &&\r\n(vio->hs_state & VIO_HS_COMPLETE))\r\nvio->ops->handshake_complete(vio);\r\nreturn err;\r\n}\r\nvoid vio_conn_reset(struct vio_driver_state *vio)\r\n{\r\n}\r\nint vio_validate_sid(struct vio_driver_state *vio, struct vio_msg_tag *tp)\r\n{\r\nu32 sid;\r\nif (tp->type == VIO_TYPE_CTRL &&\r\ntp->stype == VIO_SUBTYPE_INFO &&\r\ntp->stype_env == VIO_VER_INFO)\r\nreturn 0;\r\nswitch (vio->dev_class) {\r\ncase VDEV_NETWORK:\r\ncase VDEV_NETWORK_SWITCH:\r\ncase VDEV_DISK_SERVER:\r\ndefault:\r\nsid = vio->_peer_sid;\r\nbreak;\r\ncase VDEV_DISK:\r\nsid = vio->_local_sid;\r\nbreak;\r\n}\r\nif (sid == tp->sid)\r\nreturn 0;\r\nviodbg(DATA, "BAD SID tag->sid[%08x] peer_sid[%08x] local_sid[%08x]\n",\r\ntp->sid, vio->_peer_sid, vio->_local_sid);\r\nreturn -EINVAL;\r\n}\r\nu32 vio_send_sid(struct vio_driver_state *vio)\r\n{\r\nswitch (vio->dev_class) {\r\ncase VDEV_NETWORK:\r\ncase VDEV_NETWORK_SWITCH:\r\ncase VDEV_DISK:\r\ndefault:\r\nreturn vio->_local_sid;\r\ncase VDEV_DISK_SERVER:\r\nreturn vio->_peer_sid;\r\n}\r\n}\r\nint vio_ldc_alloc(struct vio_driver_state *vio,\r\nstruct ldc_channel_config *base_cfg,\r\nvoid *event_arg)\r\n{\r\nstruct ldc_channel_config cfg = *base_cfg;\r\nstruct ldc_channel *lp;\r\ncfg.tx_irq = vio->vdev->tx_irq;\r\ncfg.rx_irq = vio->vdev->rx_irq;\r\nlp = ldc_alloc(vio->vdev->channel_id, &cfg, event_arg);\r\nif (IS_ERR(lp))\r\nreturn PTR_ERR(lp);\r\nvio->lp = lp;\r\nreturn 0;\r\n}\r\nvoid vio_ldc_free(struct vio_driver_state *vio)\r\n{\r\nldc_free(vio->lp);\r\nvio->lp = NULL;\r\nkfree(vio->desc_buf);\r\nvio->desc_buf = NULL;\r\nvio->desc_buf_len = 0;\r\n}\r\nvoid vio_port_up(struct vio_driver_state *vio)\r\n{\r\nunsigned long flags;\r\nint err, state;\r\nspin_lock_irqsave(&vio->lock, flags);\r\nstate = ldc_state(vio->lp);\r\nerr = 0;\r\nif (state == LDC_STATE_INIT) {\r\nerr = ldc_bind(vio->lp, vio->name);\r\nif (err)\r\nprintk(KERN_WARNING "%s: Port %lu bind failed, "\r\n"err=%d\n",\r\nvio->name, vio->vdev->channel_id, err);\r\n}\r\nif (!err) {\r\nerr = ldc_connect(vio->lp);\r\nif (err)\r\nprintk(KERN_WARNING "%s: Port %lu connect failed, "\r\n"err=%d\n",\r\nvio->name, vio->vdev->channel_id, err);\r\n}\r\nif (err) {\r\nunsigned long expires = jiffies + HZ;\r\nexpires = round_jiffies(expires);\r\nmod_timer(&vio->timer, expires);\r\n}\r\nspin_unlock_irqrestore(&vio->lock, flags);\r\n}\r\nstatic void vio_port_timer(unsigned long _arg)\r\n{\r\nstruct vio_driver_state *vio = (struct vio_driver_state *) _arg;\r\nvio_port_up(vio);\r\n}\r\nint vio_driver_init(struct vio_driver_state *vio, struct vio_dev *vdev,\r\nu8 dev_class, struct vio_version *ver_table,\r\nint ver_table_size, struct vio_driver_ops *ops,\r\nchar *name)\r\n{\r\nswitch (dev_class) {\r\ncase VDEV_NETWORK:\r\ncase VDEV_NETWORK_SWITCH:\r\ncase VDEV_DISK:\r\ncase VDEV_DISK_SERVER:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!ops->send_attr ||\r\n!ops->handle_attr ||\r\n!ops->handshake_complete)\r\nreturn -EINVAL;\r\nif (!ver_table || ver_table_size < 0)\r\nreturn -EINVAL;\r\nif (!name)\r\nreturn -EINVAL;\r\nspin_lock_init(&vio->lock);\r\nvio->name = name;\r\nvio->dev_class = dev_class;\r\nvio->vdev = vdev;\r\nvio->ver_table = ver_table;\r\nvio->ver_table_entries = ver_table_size;\r\nvio->ops = ops;\r\nsetup_timer(&vio->timer, vio_port_timer, (unsigned long) vio);\r\nreturn 0;\r\n}
