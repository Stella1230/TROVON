static void reset_counters(void)\r\n{\r\nstatistics.reads = 0;\r\nstatistics.writes = 0;\r\nstatistics.ioctls = 0;\r\nstatistics.irqs = 0;\r\nstatistics.berrs = 0;\r\nstatistics.dmaerrors = 0;\r\nstatistics.timeouts = 0;\r\n}\r\nstatic int vme_user_open(struct inode *inode, struct file *file)\r\n{\r\nint err;\r\nunsigned int minor = MINOR(inode->i_rdev);\r\nmutex_lock(&image[minor].mutex);\r\nif (minor < CONTROL_MINOR && image[minor].resource == NULL) {\r\npr_err("No resources allocated for device\n");\r\nerr = -EINVAL;\r\ngoto err_res;\r\n}\r\nimage[minor].users++;\r\nmutex_unlock(&image[minor].mutex);\r\nreturn 0;\r\nerr_res:\r\nmutex_unlock(&image[minor].mutex);\r\nreturn err;\r\n}\r\nstatic int vme_user_release(struct inode *inode, struct file *file)\r\n{\r\nunsigned int minor = MINOR(inode->i_rdev);\r\nmutex_lock(&image[minor].mutex);\r\nimage[minor].users--;\r\nmutex_unlock(&image[minor].mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t resource_to_user(int minor, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nssize_t retval;\r\nssize_t copied = 0;\r\nif (count <= image[minor].size_buf) {\r\ncopied = vme_master_read(image[minor].resource,\r\nimage[minor].kern_buf, count, *ppos);\r\nif (copied < 0)\r\nreturn (int)copied;\r\nretval = __copy_to_user(buf, image[minor].kern_buf,\r\n(unsigned long)copied);\r\nif (retval != 0) {\r\ncopied = (copied - retval);\r\npr_info("User copy failed\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\npr_info("Currently don't support large transfers\n");\r\nreturn -EINVAL;\r\n}\r\nreturn copied;\r\n}\r\nstatic ssize_t resource_from_user(unsigned int minor, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nssize_t retval;\r\nssize_t copied = 0;\r\nif (count <= image[minor].size_buf) {\r\nretval = __copy_from_user(image[minor].kern_buf, buf,\r\n(unsigned long)count);\r\nif (retval != 0)\r\ncopied = (copied - retval);\r\nelse\r\ncopied = count;\r\ncopied = vme_master_write(image[minor].resource,\r\nimage[minor].kern_buf, copied, *ppos);\r\n} else {\r\npr_info("Currently don't support large transfers\n");\r\nreturn -EINVAL;\r\n}\r\nreturn copied;\r\n}\r\nstatic ssize_t buffer_to_user(unsigned int minor, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nvoid *image_ptr;\r\nssize_t retval;\r\nimage_ptr = image[minor].kern_buf + *ppos;\r\nretval = __copy_to_user(buf, image_ptr, (unsigned long)count);\r\nif (retval != 0) {\r\nretval = (count - retval);\r\npr_warn("Partial copy to userspace\n");\r\n} else\r\nretval = count;\r\nreturn retval;\r\n}\r\nstatic ssize_t buffer_from_user(unsigned int minor, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nvoid *image_ptr;\r\nsize_t retval;\r\nimage_ptr = image[minor].kern_buf + *ppos;\r\nretval = __copy_from_user(image_ptr, buf, (unsigned long)count);\r\nif (retval != 0) {\r\nretval = (count - retval);\r\npr_warn("Partial copy to userspace\n");\r\n} else\r\nretval = count;\r\nreturn retval;\r\n}\r\nstatic ssize_t vme_user_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nunsigned int minor = MINOR(file_inode(file)->i_rdev);\r\nssize_t retval;\r\nsize_t image_size;\r\nsize_t okcount;\r\nif (minor == CONTROL_MINOR)\r\nreturn 0;\r\nmutex_lock(&image[minor].mutex);\r\nimage_size = vme_get_size(image[minor].resource);\r\nif ((*ppos < 0) || (*ppos > (image_size - 1))) {\r\nmutex_unlock(&image[minor].mutex);\r\nreturn 0;\r\n}\r\nif (*ppos + count > image_size)\r\nokcount = image_size - *ppos;\r\nelse\r\nokcount = count;\r\nswitch (type[minor]) {\r\ncase MASTER_MINOR:\r\nretval = resource_to_user(minor, buf, okcount, ppos);\r\nbreak;\r\ncase SLAVE_MINOR:\r\nretval = buffer_to_user(minor, buf, okcount, ppos);\r\nbreak;\r\ndefault:\r\nretval = -EINVAL;\r\n}\r\nmutex_unlock(&image[minor].mutex);\r\nif (retval > 0)\r\n*ppos += retval;\r\nreturn retval;\r\n}\r\nstatic ssize_t vme_user_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nunsigned int minor = MINOR(file_inode(file)->i_rdev);\r\nssize_t retval;\r\nsize_t image_size;\r\nsize_t okcount;\r\nif (minor == CONTROL_MINOR)\r\nreturn 0;\r\nmutex_lock(&image[minor].mutex);\r\nimage_size = vme_get_size(image[minor].resource);\r\nif ((*ppos < 0) || (*ppos > (image_size - 1))) {\r\nmutex_unlock(&image[minor].mutex);\r\nreturn 0;\r\n}\r\nif (*ppos + count > image_size)\r\nokcount = image_size - *ppos;\r\nelse\r\nokcount = count;\r\nswitch (type[minor]) {\r\ncase MASTER_MINOR:\r\nretval = resource_from_user(minor, buf, okcount, ppos);\r\nbreak;\r\ncase SLAVE_MINOR:\r\nretval = buffer_from_user(minor, buf, okcount, ppos);\r\nbreak;\r\ndefault:\r\nretval = -EINVAL;\r\n}\r\nmutex_unlock(&image[minor].mutex);\r\nif (retval > 0)\r\n*ppos += retval;\r\nreturn retval;\r\n}\r\nstatic loff_t vme_user_llseek(struct file *file, loff_t off, int whence)\r\n{\r\nloff_t absolute = -1;\r\nunsigned int minor = MINOR(file_inode(file)->i_rdev);\r\nsize_t image_size;\r\nif (minor == CONTROL_MINOR)\r\nreturn -EINVAL;\r\nmutex_lock(&image[minor].mutex);\r\nimage_size = vme_get_size(image[minor].resource);\r\nswitch (whence) {\r\ncase SEEK_SET:\r\nabsolute = off;\r\nbreak;\r\ncase SEEK_CUR:\r\nabsolute = file->f_pos + off;\r\nbreak;\r\ncase SEEK_END:\r\nabsolute = image_size + off;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&image[minor].mutex);\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nif ((absolute < 0) || (absolute >= image_size)) {\r\nmutex_unlock(&image[minor].mutex);\r\nreturn -EINVAL;\r\n}\r\nfile->f_pos = absolute;\r\nmutex_unlock(&image[minor].mutex);\r\nreturn absolute;\r\n}\r\nstatic int vme_user_ioctl(struct inode *inode, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct vme_master master;\r\nstruct vme_slave slave;\r\nstruct vme_irq_id irq_req;\r\nunsigned long copied;\r\nunsigned int minor = MINOR(inode->i_rdev);\r\nint retval;\r\ndma_addr_t pci_addr;\r\nvoid __user *argp = (void __user *)arg;\r\nstatistics.ioctls++;\r\nswitch (type[minor]) {\r\ncase CONTROL_MINOR:\r\nswitch (cmd) {\r\ncase VME_IRQ_GEN:\r\ncopied = copy_from_user(&irq_req, argp,\r\nsizeof(struct vme_irq_id));\r\nif (copied != 0) {\r\npr_warn("Partial copy from userspace\n");\r\nreturn -EFAULT;\r\n}\r\nretval = vme_irq_generate(vme_user_bridge,\r\nirq_req.level,\r\nirq_req.statid);\r\nreturn retval;\r\n}\r\nbreak;\r\ncase MASTER_MINOR:\r\nswitch (cmd) {\r\ncase VME_GET_MASTER:\r\nmemset(&master, 0, sizeof(struct vme_master));\r\nretval = vme_master_get(image[minor].resource,\r\n&master.enable, &master.vme_addr,\r\n&master.size, &master.aspace,\r\n&master.cycle, &master.dwidth);\r\ncopied = copy_to_user(argp, &master,\r\nsizeof(struct vme_master));\r\nif (copied != 0) {\r\npr_warn("Partial copy to userspace\n");\r\nreturn -EFAULT;\r\n}\r\nreturn retval;\r\nbreak;\r\ncase VME_SET_MASTER:\r\ncopied = copy_from_user(&master, argp, sizeof(master));\r\nif (copied != 0) {\r\npr_warn("Partial copy from userspace\n");\r\nreturn -EFAULT;\r\n}\r\nreturn vme_master_set(image[minor].resource,\r\nmaster.enable, master.vme_addr, master.size,\r\nmaster.aspace, master.cycle, master.dwidth);\r\nbreak;\r\n}\r\nbreak;\r\ncase SLAVE_MINOR:\r\nswitch (cmd) {\r\ncase VME_GET_SLAVE:\r\nmemset(&slave, 0, sizeof(struct vme_slave));\r\nretval = vme_slave_get(image[minor].resource,\r\n&slave.enable, &slave.vme_addr,\r\n&slave.size, &pci_addr, &slave.aspace,\r\n&slave.cycle);\r\ncopied = copy_to_user(argp, &slave,\r\nsizeof(struct vme_slave));\r\nif (copied != 0) {\r\npr_warn("Partial copy to userspace\n");\r\nreturn -EFAULT;\r\n}\r\nreturn retval;\r\nbreak;\r\ncase VME_SET_SLAVE:\r\ncopied = copy_from_user(&slave, argp, sizeof(slave));\r\nif (copied != 0) {\r\npr_warn("Partial copy from userspace\n");\r\nreturn -EFAULT;\r\n}\r\nreturn vme_slave_set(image[minor].resource,\r\nslave.enable, slave.vme_addr, slave.size,\r\nimage[minor].pci_buf, slave.aspace,\r\nslave.cycle);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic long\r\nvme_user_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nint ret;\r\nmutex_lock(&vme_user_mutex);\r\nret = vme_user_ioctl(file_inode(file), file, cmd, arg);\r\nmutex_unlock(&vme_user_mutex);\r\nreturn ret;\r\n}\r\nstatic void buf_unalloc(int num)\r\n{\r\nif (image[num].kern_buf) {\r\n#ifdef VME_DEBUG\r\npr_debug("UniverseII:Releasing buffer at %p\n",\r\nimage[num].pci_buf);\r\n#endif\r\nvme_free_consistent(image[num].resource, image[num].size_buf,\r\nimage[num].kern_buf, image[num].pci_buf);\r\nimage[num].kern_buf = NULL;\r\nimage[num].pci_buf = 0;\r\nimage[num].size_buf = 0;\r\n#ifdef VME_DEBUG\r\n} else {\r\npr_debug("UniverseII: Buffer not allocated\n");\r\n#endif\r\n}\r\n}\r\nstatic int __init vme_user_init(void)\r\n{\r\nint retval = 0;\r\npr_info("VME User Space Access Driver\n");\r\nif (bus_num == 0) {\r\npr_err("No cards, skipping registration\n");\r\nretval = -ENODEV;\r\ngoto err_nocard;\r\n}\r\nif (bus_num > VME_USER_BUS_MAX) {\r\npr_err("Driver only able to handle %d buses\n",\r\nVME_USER_BUS_MAX);\r\nbus_num = VME_USER_BUS_MAX;\r\n}\r\nretval = vme_register_driver(&vme_user_driver, VME_MAX_SLOTS);\r\nif (retval != 0)\r\ngoto err_reg;\r\nreturn retval;\r\nerr_reg:\r\nerr_nocard:\r\nreturn retval;\r\n}\r\nstatic int vme_user_match(struct vme_dev *vdev)\r\n{\r\nif (vdev->num >= VME_USER_BUS_MAX)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int vme_user_probe(struct vme_dev *vdev)\r\n{\r\nint i, err;\r\nchar name[12];\r\nif (vme_user_bridge != NULL) {\r\ndev_err(&vdev->dev, "Driver can only be loaded for 1 device\n");\r\nerr = -EINVAL;\r\ngoto err_dev;\r\n}\r\nvme_user_bridge = vdev;\r\nfor (i = 0; i < VME_DEVS; i++) {\r\nimage[i].kern_buf = NULL;\r\nimage[i].pci_buf = 0;\r\nmutex_init(&image[i].mutex);\r\nimage[i].device = NULL;\r\nimage[i].resource = NULL;\r\nimage[i].users = 0;\r\n}\r\nreset_counters();\r\nerr = register_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS,\r\ndriver_name);\r\nif (err) {\r\ndev_warn(&vdev->dev, "Error getting Major Number %d for driver.\n",\r\nVME_MAJOR);\r\ngoto err_region;\r\n}\r\nvme_user_cdev = cdev_alloc();\r\nif (!vme_user_cdev) {\r\nerr = -ENOMEM;\r\ngoto err_char;\r\n}\r\nvme_user_cdev->ops = &vme_user_fops;\r\nvme_user_cdev->owner = THIS_MODULE;\r\nerr = cdev_add(vme_user_cdev, MKDEV(VME_MAJOR, 0), VME_DEVS);\r\nif (err) {\r\ndev_warn(&vdev->dev, "cdev_all failed\n");\r\ngoto err_char;\r\n}\r\nfor (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {\r\nimage[i].resource = vme_slave_request(vme_user_bridge,\r\nVME_A24, VME_SCT);\r\nif (image[i].resource == NULL) {\r\ndev_warn(&vdev->dev,\r\n"Unable to allocate slave resource\n");\r\nerr = -ENOMEM;\r\ngoto err_slave;\r\n}\r\nimage[i].size_buf = PCI_BUF_SIZE;\r\nimage[i].kern_buf = vme_alloc_consistent(image[i].resource,\r\nimage[i].size_buf, &image[i].pci_buf);\r\nif (image[i].kern_buf == NULL) {\r\ndev_warn(&vdev->dev,\r\n"Unable to allocate memory for buffer\n");\r\nimage[i].pci_buf = 0;\r\nvme_slave_free(image[i].resource);\r\nerr = -ENOMEM;\r\ngoto err_slave;\r\n}\r\n}\r\nfor (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++) {\r\nimage[i].resource = vme_master_request(vme_user_bridge,\r\nVME_A32, VME_SCT, VME_D32);\r\nif (image[i].resource == NULL) {\r\ndev_warn(&vdev->dev,\r\n"Unable to allocate master resource\n");\r\nerr = -ENOMEM;\r\ngoto err_master;\r\n}\r\nimage[i].size_buf = PCI_BUF_SIZE;\r\nimage[i].kern_buf = kmalloc(image[i].size_buf, GFP_KERNEL);\r\nif (image[i].kern_buf == NULL) {\r\nerr = -ENOMEM;\r\ngoto err_master_buf;\r\n}\r\n}\r\nvme_user_sysfs_class = class_create(THIS_MODULE, driver_name);\r\nif (IS_ERR(vme_user_sysfs_class)) {\r\ndev_err(&vdev->dev, "Error creating vme_user class.\n");\r\nerr = PTR_ERR(vme_user_sysfs_class);\r\ngoto err_class;\r\n}\r\nfor (i = 0; i < VME_DEVS; i++) {\r\nint num;\r\nswitch (type[i]) {\r\ncase MASTER_MINOR:\r\nsprintf(name, "bus/vme/m%%d");\r\nbreak;\r\ncase CONTROL_MINOR:\r\nsprintf(name, "bus/vme/ctl");\r\nbreak;\r\ncase SLAVE_MINOR:\r\nsprintf(name, "bus/vme/s%%d");\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto err_sysfs;\r\nbreak;\r\n}\r\nnum = (type[i] == SLAVE_MINOR) ? i - (MASTER_MAX + 1) : i;\r\nimage[i].device = device_create(vme_user_sysfs_class, NULL,\r\nMKDEV(VME_MAJOR, i), NULL, name, num);\r\nif (IS_ERR(image[i].device)) {\r\ndev_info(&vdev->dev, "Error creating sysfs device\n");\r\nerr = PTR_ERR(image[i].device);\r\ngoto err_sysfs;\r\n}\r\n}\r\nreturn 0;\r\ni = VME_DEVS;\r\nerr_sysfs:\r\nwhile (i > 0) {\r\ni--;\r\ndevice_destroy(vme_user_sysfs_class, MKDEV(VME_MAJOR, i));\r\n}\r\nclass_destroy(vme_user_sysfs_class);\r\ni = MASTER_MAX + 1;\r\nerr_master_buf:\r\nfor (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++)\r\nkfree(image[i].kern_buf);\r\nerr_master:\r\nwhile (i > MASTER_MINOR) {\r\ni--;\r\nvme_master_free(image[i].resource);\r\n}\r\ni = SLAVE_MAX + 1;\r\nerr_slave:\r\nwhile (i > SLAVE_MINOR) {\r\ni--;\r\nbuf_unalloc(i);\r\nvme_slave_free(image[i].resource);\r\n}\r\nerr_class:\r\ncdev_del(vme_user_cdev);\r\nerr_char:\r\nunregister_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS);\r\nerr_region:\r\nerr_dev:\r\nreturn err;\r\n}\r\nstatic int vme_user_remove(struct vme_dev *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < VME_DEVS; i++) {\r\nmutex_destroy(&image[i].mutex);\r\ndevice_destroy(vme_user_sysfs_class, MKDEV(VME_MAJOR, i));\r\n}\r\nclass_destroy(vme_user_sysfs_class);\r\nfor (i = MASTER_MINOR; i < (MASTER_MAX + 1); i++) {\r\nkfree(image[i].kern_buf);\r\nvme_master_free(image[i].resource);\r\n}\r\nfor (i = SLAVE_MINOR; i < (SLAVE_MAX + 1); i++) {\r\nvme_slave_set(image[i].resource, 0, 0, 0, 0, VME_A32, 0);\r\nbuf_unalloc(i);\r\nvme_slave_free(image[i].resource);\r\n}\r\ncdev_del(vme_user_cdev);\r\nunregister_chrdev_region(MKDEV(VME_MAJOR, 0), VME_DEVS);\r\nreturn 0;\r\n}\r\nstatic void __exit vme_user_exit(void)\r\n{\r\nvme_unregister_driver(&vme_user_driver);\r\n}
