static void gpio_write(struct cx18 *cx)\r\n{\r\nu32 dir_lo = cx->gpio_dir & 0xffff;\r\nu32 val_lo = cx->gpio_val & 0xffff;\r\nu32 dir_hi = cx->gpio_dir >> 16;\r\nu32 val_hi = cx->gpio_val >> 16;\r\ncx18_write_reg_expect(cx, dir_lo << 16,\r\nCX18_REG_GPIO_DIR1, ~dir_lo, dir_lo);\r\ncx18_write_reg_expect(cx, (dir_lo << 16) | val_lo,\r\nCX18_REG_GPIO_OUT1, val_lo, dir_lo);\r\ncx18_write_reg_expect(cx, dir_hi << 16,\r\nCX18_REG_GPIO_DIR2, ~dir_hi, dir_hi);\r\ncx18_write_reg_expect(cx, (dir_hi << 16) | val_hi,\r\nCX18_REG_GPIO_OUT2, val_hi, dir_hi);\r\n}\r\nstatic void gpio_update(struct cx18 *cx, u32 mask, u32 data)\r\n{\r\nif (mask == 0)\r\nreturn;\r\nmutex_lock(&cx->gpio_lock);\r\ncx->gpio_val = (cx->gpio_val & ~mask) | (data & mask);\r\ngpio_write(cx);\r\nmutex_unlock(&cx->gpio_lock);\r\n}\r\nstatic void gpio_reset_seq(struct cx18 *cx, u32 active_lo, u32 active_hi,\r\nunsigned int assert_msecs,\r\nunsigned int recovery_msecs)\r\n{\r\nu32 mask;\r\nmask = active_lo | active_hi;\r\nif (mask == 0)\r\nreturn;\r\ngpio_update(cx, mask, ~active_lo);\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(assert_msecs));\r\ngpio_update(cx, mask, ~active_hi);\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(recovery_msecs));\r\n}\r\nstatic int gpiomux_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\nmutex_lock(&cx->gpio_lock);\r\nCX18_INFO_DEV(sd, "GPIO: direction 0x%08x, value 0x%08x\n",\r\ncx->gpio_dir, cx->gpio_val);\r\nmutex_unlock(&cx->gpio_lock);\r\nreturn 0;\r\n}\r\nstatic int gpiomux_s_radio(struct v4l2_subdev *sd)\r\n{\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\ngpio_update(cx, cx->card->gpio_audio_input.mask,\r\ncx->card->gpio_audio_input.radio);\r\nreturn 0;\r\n}\r\nstatic int gpiomux_s_std(struct v4l2_subdev *sd, v4l2_std_id norm)\r\n{\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\nu32 data;\r\nswitch (cx->card->audio_inputs[cx->audio_input].muxer_input) {\r\ncase 1:\r\ndata = cx->card->gpio_audio_input.linein;\r\nbreak;\r\ncase 0:\r\ndata = cx->card->gpio_audio_input.tuner;\r\nbreak;\r\ndefault:\r\ndata = cx->card->gpio_audio_input.tuner;\r\nbreak;\r\n}\r\ngpio_update(cx, cx->card->gpio_audio_input.mask, data);\r\nreturn 0;\r\n}\r\nstatic int gpiomux_s_audio_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\nu32 data;\r\nswitch (input) {\r\ncase 0:\r\ndata = cx->card->gpio_audio_input.tuner;\r\nbreak;\r\ncase 1:\r\ndata = cx->card->gpio_audio_input.linein;\r\nbreak;\r\ncase 2:\r\ndata = cx->card->gpio_audio_input.radio;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ngpio_update(cx, cx->card->gpio_audio_input.mask, data);\r\nreturn 0;\r\n}\r\nstatic int resetctrl_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\nmutex_lock(&cx->gpio_lock);\r\nCX18_INFO_DEV(sd, "GPIO: direction 0x%08x, value 0x%08x\n",\r\ncx->gpio_dir, cx->gpio_val);\r\nmutex_unlock(&cx->gpio_lock);\r\nreturn 0;\r\n}\r\nstatic int resetctrl_reset(struct v4l2_subdev *sd, u32 val)\r\n{\r\nstruct cx18 *cx = v4l2_get_subdevdata(sd);\r\nconst struct cx18_gpio_i2c_slave_reset *p;\r\np = &cx->card->gpio_i2c_slave_reset;\r\nswitch (val) {\r\ncase CX18_GPIO_RESET_I2C:\r\ngpio_reset_seq(cx, p->active_lo_mask, p->active_hi_mask,\r\np->msecs_asserted, p->msecs_recovery);\r\nbreak;\r\ncase CX18_GPIO_RESET_Z8F0811:\r\ngpio_reset_seq(cx, p->ir_reset_mask, 0,\r\np->msecs_asserted, p->msecs_recovery);\r\nbreak;\r\ncase CX18_GPIO_RESET_XC2028:\r\nif (cx->card->tuners[0].tuner == TUNER_XC2028)\r\ngpio_reset_seq(cx, (1 << cx->card->xceive_pin), 0,\r\n1, 1);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid cx18_gpio_init(struct cx18 *cx)\r\n{\r\nmutex_lock(&cx->gpio_lock);\r\ncx->gpio_dir = cx->card->gpio_init.direction;\r\ncx->gpio_val = cx->card->gpio_init.initial_value;\r\nif (cx->card->tuners[0].tuner == TUNER_XC2028) {\r\ncx->gpio_dir |= 1 << cx->card->xceive_pin;\r\ncx->gpio_val |= 1 << cx->card->xceive_pin;\r\n}\r\nif (cx->gpio_dir == 0) {\r\nmutex_unlock(&cx->gpio_lock);\r\nreturn;\r\n}\r\nCX18_DEBUG_INFO("GPIO initial dir: %08x/%08x out: %08x/%08x\n",\r\ncx18_read_reg(cx, CX18_REG_GPIO_DIR1),\r\ncx18_read_reg(cx, CX18_REG_GPIO_DIR2),\r\ncx18_read_reg(cx, CX18_REG_GPIO_OUT1),\r\ncx18_read_reg(cx, CX18_REG_GPIO_OUT2));\r\ngpio_write(cx);\r\nmutex_unlock(&cx->gpio_lock);\r\n}\r\nint cx18_gpio_register(struct cx18 *cx, u32 hw)\r\n{\r\nstruct v4l2_subdev *sd;\r\nconst struct v4l2_subdev_ops *ops;\r\nchar *str;\r\nswitch (hw) {\r\ncase CX18_HW_GPIO_MUX:\r\nsd = &cx->sd_gpiomux;\r\nops = &gpiomux_ops;\r\nstr = "gpio-mux";\r\nbreak;\r\ncase CX18_HW_GPIO_RESET_CTRL:\r\nsd = &cx->sd_resetctrl;\r\nops = &resetctrl_ops;\r\nstr = "gpio-reset-ctrl";\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nv4l2_subdev_init(sd, ops);\r\nv4l2_set_subdevdata(sd, cx);\r\nsnprintf(sd->name, sizeof(sd->name), "%s %s", cx->v4l2_dev.name, str);\r\nsd->grp_id = hw;\r\nreturn v4l2_device_register_subdev(&cx->v4l2_dev, sd);\r\n}\r\nvoid cx18_reset_ir_gpio(void *data)\r\n{\r\nstruct cx18 *cx = to_cx18((struct v4l2_device *)data);\r\nif (cx->card->gpio_i2c_slave_reset.ir_reset_mask == 0)\r\nreturn;\r\nCX18_DEBUG_INFO("Resetting IR microcontroller\n");\r\nv4l2_subdev_call(&cx->sd_resetctrl,\r\ncore, reset, CX18_GPIO_RESET_Z8F0811);\r\n}\r\nint cx18_reset_tuner_gpio(void *dev, int component, int cmd, int value)\r\n{\r\nstruct i2c_algo_bit_data *algo = dev;\r\nstruct cx18_i2c_algo_callback_data *cb_data = algo->data;\r\nstruct cx18 *cx = cb_data->cx;\r\nif (cmd != XC2028_TUNER_RESET ||\r\ncx->card->tuners[0].tuner != TUNER_XC2028)\r\nreturn 0;\r\nCX18_DEBUG_INFO("Resetting XCeive tuner\n");\r\nreturn v4l2_subdev_call(&cx->sd_resetctrl,\r\ncore, reset, CX18_GPIO_RESET_XC2028);\r\n}
