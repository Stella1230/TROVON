static inline __u64 dru(__u64 val, __u32 shift, int round_up)\r\n{\r\nreturn (val + (round_up ? (1 << shift) - 1 : 0)) >> shift;\r\n}\r\nstatic inline __u64 ldlm_pool_slv_max(__u32 L)\r\n{\r\n__u64 lim = (__u64)L * LDLM_POOL_MAX_AGE / 1;\r\nreturn lim;\r\n}\r\nstatic inline __u64 ldlm_pool_slv_min(__u32 L)\r\n{\r\nreturn 1;\r\n}\r\nstatic inline struct ldlm_namespace *ldlm_pl2ns(struct ldlm_pool *pl)\r\n{\r\nreturn container_of(pl, struct ldlm_namespace, ns_pool);\r\n}\r\nstatic inline int ldlm_pool_t2gsp(unsigned int t)\r\n{\r\nreturn LDLM_POOL_MAX_GSP -\r\n((LDLM_POOL_MAX_GSP - LDLM_POOL_MIN_GSP) >>\r\n(t >> LDLM_POOL_GSP_STEP_SHIFT));\r\n}\r\nstatic void ldlm_pool_recalc_grant_plan(struct ldlm_pool *pl)\r\n{\r\nint granted, grant_step, limit;\r\nlimit = ldlm_pool_get_limit(pl);\r\ngranted = atomic_read(&pl->pl_granted);\r\ngrant_step = ldlm_pool_t2gsp(pl->pl_recalc_period);\r\ngrant_step = ((limit - granted) * grant_step) / 100;\r\npl->pl_grant_plan = granted + grant_step;\r\nlimit = (limit * 5) >> 2;\r\nif (pl->pl_grant_plan > limit)\r\npl->pl_grant_plan = limit;\r\n}\r\nstatic void ldlm_pool_recalc_slv(struct ldlm_pool *pl)\r\n{\r\nint granted;\r\nint grant_plan;\r\nint round_up;\r\n__u64 slv;\r\n__u64 slv_factor;\r\n__u64 grant_usage;\r\n__u32 limit;\r\nslv = pl->pl_server_lock_volume;\r\ngrant_plan = pl->pl_grant_plan;\r\nlimit = ldlm_pool_get_limit(pl);\r\ngranted = atomic_read(&pl->pl_granted);\r\nround_up = granted < limit;\r\ngrant_usage = max_t(int, limit - (granted - grant_plan), 1);\r\nslv_factor = (grant_usage << LDLM_POOL_SLV_SHIFT);\r\ndo_div(slv_factor, limit);\r\nslv = slv * slv_factor;\r\nslv = dru(slv, LDLM_POOL_SLV_SHIFT, round_up);\r\nif (slv > ldlm_pool_slv_max(limit)) {\r\nslv = ldlm_pool_slv_max(limit);\r\n} else if (slv < ldlm_pool_slv_min(limit)) {\r\nslv = ldlm_pool_slv_min(limit);\r\n}\r\npl->pl_server_lock_volume = slv;\r\n}\r\nstatic void ldlm_pool_recalc_stats(struct ldlm_pool *pl)\r\n{\r\nint grant_plan = pl->pl_grant_plan;\r\n__u64 slv = pl->pl_server_lock_volume;\r\nint granted = atomic_read(&pl->pl_granted);\r\nint grant_rate = atomic_read(&pl->pl_grant_rate);\r\nint cancel_rate = atomic_read(&pl->pl_cancel_rate);\r\nlprocfs_counter_add(pl->pl_stats, LDLM_POOL_SLV_STAT,\r\nslv);\r\nlprocfs_counter_add(pl->pl_stats, LDLM_POOL_GRANTED_STAT,\r\ngranted);\r\nlprocfs_counter_add(pl->pl_stats, LDLM_POOL_GRANT_RATE_STAT,\r\ngrant_rate);\r\nlprocfs_counter_add(pl->pl_stats, LDLM_POOL_GRANT_PLAN_STAT,\r\ngrant_plan);\r\nlprocfs_counter_add(pl->pl_stats, LDLM_POOL_CANCEL_RATE_STAT,\r\ncancel_rate);\r\n}\r\nstatic void ldlm_srv_pool_push_slv(struct ldlm_pool *pl)\r\n{\r\nstruct obd_device *obd;\r\nobd = ldlm_pl2ns(pl)->ns_obd;\r\nLASSERT(obd != NULL);\r\nwrite_lock(&obd->obd_pool_lock);\r\nobd->obd_pool_slv = pl->pl_server_lock_volume;\r\nwrite_unlock(&obd->obd_pool_lock);\r\n}\r\nstatic int ldlm_srv_pool_recalc(struct ldlm_pool *pl)\r\n{\r\ntime_t recalc_interval_sec;\r\nrecalc_interval_sec = cfs_time_current_sec() - pl->pl_recalc_time;\r\nif (recalc_interval_sec < pl->pl_recalc_period)\r\nreturn 0;\r\nspin_lock(&pl->pl_lock);\r\nrecalc_interval_sec = cfs_time_current_sec() - pl->pl_recalc_time;\r\nif (recalc_interval_sec < pl->pl_recalc_period) {\r\nspin_unlock(&pl->pl_lock);\r\nreturn 0;\r\n}\r\nldlm_pool_recalc_slv(pl);\r\nldlm_srv_pool_push_slv(pl);\r\nldlm_pool_recalc_grant_plan(pl);\r\npl->pl_recalc_time = cfs_time_current_sec();\r\nlprocfs_counter_add(pl->pl_stats, LDLM_POOL_TIMING_STAT,\r\nrecalc_interval_sec);\r\nspin_unlock(&pl->pl_lock);\r\nreturn 0;\r\n}\r\nstatic int ldlm_srv_pool_shrink(struct ldlm_pool *pl,\r\nint nr, unsigned int gfp_mask)\r\n{\r\n__u32 limit;\r\nif (nr == 0)\r\nreturn atomic_read(&pl->pl_granted);\r\nif (atomic_read(&pl->pl_granted) == 0)\r\nreturn 0;\r\nspin_lock(&pl->pl_lock);\r\nif (nr < pl->pl_server_lock_volume) {\r\npl->pl_server_lock_volume = pl->pl_server_lock_volume - nr;\r\n} else {\r\nlimit = ldlm_pool_get_limit(pl);\r\npl->pl_server_lock_volume = ldlm_pool_slv_min(limit);\r\n}\r\nldlm_srv_pool_push_slv(pl);\r\nspin_unlock(&pl->pl_lock);\r\nreturn 0;\r\n}\r\nstatic int ldlm_srv_pool_setup(struct ldlm_pool *pl, int limit)\r\n{\r\nstruct obd_device *obd;\r\nobd = ldlm_pl2ns(pl)->ns_obd;\r\nLASSERT(obd != NULL && obd != LP_POISON);\r\nLASSERT(obd->obd_type != LP_POISON);\r\nwrite_lock(&obd->obd_pool_lock);\r\nobd->obd_pool_limit = limit;\r\nwrite_unlock(&obd->obd_pool_lock);\r\nldlm_pool_set_limit(pl, limit);\r\nreturn 0;\r\n}\r\nstatic void ldlm_cli_pool_pop_slv(struct ldlm_pool *pl)\r\n{\r\nstruct obd_device *obd;\r\nobd = ldlm_pl2ns(pl)->ns_obd;\r\nLASSERT(obd != NULL);\r\nread_lock(&obd->obd_pool_lock);\r\npl->pl_server_lock_volume = obd->obd_pool_slv;\r\nldlm_pool_set_limit(pl, obd->obd_pool_limit);\r\nread_unlock(&obd->obd_pool_lock);\r\n}\r\nstatic int ldlm_cli_pool_recalc(struct ldlm_pool *pl)\r\n{\r\ntime_t recalc_interval_sec;\r\nrecalc_interval_sec = cfs_time_current_sec() - pl->pl_recalc_time;\r\nif (recalc_interval_sec < pl->pl_recalc_period)\r\nreturn 0;\r\nspin_lock(&pl->pl_lock);\r\nrecalc_interval_sec = cfs_time_current_sec() - pl->pl_recalc_time;\r\nif (recalc_interval_sec < pl->pl_recalc_period) {\r\nspin_unlock(&pl->pl_lock);\r\nreturn 0;\r\n}\r\nldlm_cli_pool_pop_slv(pl);\r\npl->pl_recalc_time = cfs_time_current_sec();\r\nlprocfs_counter_add(pl->pl_stats, LDLM_POOL_TIMING_STAT,\r\nrecalc_interval_sec);\r\nspin_unlock(&pl->pl_lock);\r\nif (!ns_connect_lru_resize(ldlm_pl2ns(pl)))\r\nreturn 0;\r\nreturn ldlm_cancel_lru(ldlm_pl2ns(pl), 0, LCF_ASYNC, LDLM_CANCEL_LRUR);\r\n}\r\nstatic int ldlm_cli_pool_shrink(struct ldlm_pool *pl,\r\nint nr, unsigned int gfp_mask)\r\n{\r\nstruct ldlm_namespace *ns;\r\nint unused;\r\nns = ldlm_pl2ns(pl);\r\nif (!ns_connect_lru_resize(ns))\r\nreturn 0;\r\nldlm_cli_pool_pop_slv(pl);\r\nspin_lock(&ns->ns_lock);\r\nunused = ns->ns_nr_unused;\r\nspin_unlock(&ns->ns_lock);\r\nif (nr == 0)\r\nreturn (unused / 100) * sysctl_vfs_cache_pressure;\r\nelse\r\nreturn ldlm_cancel_lru(ns, nr, LCF_ASYNC, LDLM_CANCEL_SHRINK);\r\n}\r\nint ldlm_pool_recalc(struct ldlm_pool *pl)\r\n{\r\ntime_t recalc_interval_sec;\r\nint count;\r\nrecalc_interval_sec = cfs_time_current_sec() - pl->pl_recalc_time;\r\nif (recalc_interval_sec <= 0)\r\ngoto recalc;\r\nspin_lock(&pl->pl_lock);\r\nif (recalc_interval_sec > 0) {\r\nldlm_pool_recalc_stats(pl);\r\natomic_set(&pl->pl_grant_rate, 0);\r\natomic_set(&pl->pl_cancel_rate, 0);\r\n}\r\nspin_unlock(&pl->pl_lock);\r\nrecalc:\r\nif (pl->pl_ops->po_recalc != NULL) {\r\ncount = pl->pl_ops->po_recalc(pl);\r\nlprocfs_counter_add(pl->pl_stats, LDLM_POOL_RECALC_STAT,\r\ncount);\r\n}\r\nrecalc_interval_sec = pl->pl_recalc_time - cfs_time_current_sec() +\r\npl->pl_recalc_period;\r\nreturn recalc_interval_sec;\r\n}\r\nint ldlm_pool_shrink(struct ldlm_pool *pl, int nr,\r\nunsigned int gfp_mask)\r\n{\r\nint cancel = 0;\r\nif (pl->pl_ops->po_shrink != NULL) {\r\ncancel = pl->pl_ops->po_shrink(pl, nr, gfp_mask);\r\nif (nr > 0) {\r\nlprocfs_counter_add(pl->pl_stats,\r\nLDLM_POOL_SHRINK_REQTD_STAT,\r\nnr);\r\nlprocfs_counter_add(pl->pl_stats,\r\nLDLM_POOL_SHRINK_FREED_STAT,\r\ncancel);\r\nCDEBUG(D_DLMTRACE, "%s: request to shrink %d locks, "\r\n"shrunk %d\n", pl->pl_name, nr, cancel);\r\n}\r\n}\r\nreturn cancel;\r\n}\r\nint ldlm_pool_setup(struct ldlm_pool *pl, int limit)\r\n{\r\nif (pl->pl_ops->po_setup != NULL)\r\nreturn(pl->pl_ops->po_setup(pl, limit));\r\nreturn 0;\r\n}\r\nstatic int lprocfs_pool_state_seq_show(struct seq_file *m, void *unused)\r\n{\r\nint granted, grant_rate, cancel_rate, grant_step;\r\nint grant_speed, grant_plan, lvf;\r\nstruct ldlm_pool *pl = m->private;\r\n__u64 slv, clv;\r\n__u32 limit;\r\nspin_lock(&pl->pl_lock);\r\nslv = pl->pl_server_lock_volume;\r\nclv = pl->pl_client_lock_volume;\r\nlimit = ldlm_pool_get_limit(pl);\r\ngrant_plan = pl->pl_grant_plan;\r\ngranted = atomic_read(&pl->pl_granted);\r\ngrant_rate = atomic_read(&pl->pl_grant_rate);\r\ncancel_rate = atomic_read(&pl->pl_cancel_rate);\r\ngrant_speed = grant_rate - cancel_rate;\r\nlvf = atomic_read(&pl->pl_lock_volume_factor);\r\ngrant_step = ldlm_pool_t2gsp(pl->pl_recalc_period);\r\nspin_unlock(&pl->pl_lock);\r\nseq_printf(m, "LDLM pool state (%s):\n"\r\n" SLV: "LPU64"\n"\r\n" CLV: "LPU64"\n"\r\n" LVF: %d\n",\r\npl->pl_name, slv, clv, lvf);\r\nif (ns_is_server(ldlm_pl2ns(pl))) {\r\nseq_printf(m, " GSP: %d%%\n"\r\n" GP: %d\n",\r\ngrant_step, grant_plan);\r\n}\r\nseq_printf(m, " GR: %d\n" " CR: %d\n" " GS: %d\n"\r\n" G: %d\n" " L: %d\n",\r\ngrant_rate, cancel_rate, grant_speed,\r\ngranted, limit);\r\nreturn 0;\r\n}\r\nstatic int lprocfs_grant_speed_seq_show(struct seq_file *m, void *unused)\r\n{\r\nstruct ldlm_pool *pl = m->private;\r\nint grant_speed;\r\nspin_lock(&pl->pl_lock);\r\ngrant_speed = atomic_read(&pl->pl_grant_rate) -\r\natomic_read(&pl->pl_cancel_rate);\r\nspin_unlock(&pl->pl_lock);\r\nreturn lprocfs_rd_uint(m, &grant_speed);\r\n}\r\nstatic ssize_t lprocfs_recalc_period_seq_write(struct file *file, const char *buf,\r\nsize_t len, loff_t *off)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nreturn lprocfs_wr_recalc_period(file, buf, len, seq->private);\r\n}\r\nstatic int ldlm_pool_proc_init(struct ldlm_pool *pl)\r\n{\r\nstruct ldlm_namespace *ns = ldlm_pl2ns(pl);\r\nstruct proc_dir_entry *parent_ns_proc;\r\nstruct lprocfs_vars pool_vars[2];\r\nchar *var_name = NULL;\r\nint rc = 0;\r\nOBD_ALLOC(var_name, MAX_STRING_SIZE + 1);\r\nif (!var_name)\r\nreturn -ENOMEM;\r\nparent_ns_proc = ns->ns_proc_dir_entry;\r\nif (parent_ns_proc == NULL) {\r\nCERROR("%s: proc entry is not initialized\n",\r\nldlm_ns_name(ns));\r\nGOTO(out_free_name, rc = -EINVAL);\r\n}\r\npl->pl_proc_dir = lprocfs_register("pool", parent_ns_proc,\r\nNULL, NULL);\r\nif (IS_ERR(pl->pl_proc_dir)) {\r\nCERROR("LProcFS failed in ldlm-pool-init\n");\r\nrc = PTR_ERR(pl->pl_proc_dir);\r\npl->pl_proc_dir = NULL;\r\nGOTO(out_free_name, rc);\r\n}\r\nvar_name[MAX_STRING_SIZE] = '\0';\r\nmemset(pool_vars, 0, sizeof(pool_vars));\r\npool_vars[0].name = var_name;\r\nLDLM_POOL_ADD_VAR("server_lock_volume", &pl->pl_server_lock_volume,\r\n&ldlm_pool_u64_fops);\r\nLDLM_POOL_ADD_VAR("limit", &pl->pl_limit, &ldlm_pool_rw_atomic_fops);\r\nLDLM_POOL_ADD_VAR("granted", &pl->pl_granted, &ldlm_pool_atomic_fops);\r\nLDLM_POOL_ADD_VAR("grant_speed", pl, &lprocfs_grant_speed_fops);\r\nLDLM_POOL_ADD_VAR("cancel_rate", &pl->pl_cancel_rate,\r\n&ldlm_pool_atomic_fops);\r\nLDLM_POOL_ADD_VAR("grant_rate", &pl->pl_grant_rate,\r\n&ldlm_pool_atomic_fops);\r\nLDLM_POOL_ADD_VAR("grant_plan", pl, &lprocfs_grant_plan_fops);\r\nLDLM_POOL_ADD_VAR("recalc_period", pl, &lprocfs_recalc_period_fops);\r\nLDLM_POOL_ADD_VAR("lock_volume_factor", &pl->pl_lock_volume_factor,\r\n&ldlm_pool_rw_atomic_fops);\r\nLDLM_POOL_ADD_VAR("state", pl, &lprocfs_pool_state_fops);\r\npl->pl_stats = lprocfs_alloc_stats(LDLM_POOL_LAST_STAT -\r\nLDLM_POOL_FIRST_STAT, 0);\r\nif (!pl->pl_stats)\r\nGOTO(out_free_name, rc = -ENOMEM);\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_GRANTED_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"granted", "locks");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_GRANT_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"grant", "locks");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_CANCEL_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"cancel", "locks");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_GRANT_RATE_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"grant_rate", "locks/s");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_CANCEL_RATE_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"cancel_rate", "locks/s");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_GRANT_PLAN_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"grant_plan", "locks/s");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_SLV_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"slv", "slv");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_SHRINK_REQTD_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"shrink_request", "locks");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_SHRINK_FREED_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"shrink_freed", "locks");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_RECALC_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"recalc_freed", "locks");\r\nlprocfs_counter_init(pl->pl_stats, LDLM_POOL_TIMING_STAT,\r\nLPROCFS_CNTR_AVGMINMAX | LPROCFS_CNTR_STDDEV,\r\n"recalc_timing", "sec");\r\nrc = lprocfs_register_stats(pl->pl_proc_dir, "stats", pl->pl_stats);\r\nout_free_name:\r\nOBD_FREE(var_name, MAX_STRING_SIZE + 1);\r\nreturn rc;\r\n}\r\nstatic void ldlm_pool_proc_fini(struct ldlm_pool *pl)\r\n{\r\nif (pl->pl_stats != NULL) {\r\nlprocfs_free_stats(&pl->pl_stats);\r\npl->pl_stats = NULL;\r\n}\r\nif (pl->pl_proc_dir != NULL) {\r\nlprocfs_remove(&pl->pl_proc_dir);\r\npl->pl_proc_dir = NULL;\r\n}\r\n}\r\nint ldlm_pool_init(struct ldlm_pool *pl, struct ldlm_namespace *ns,\r\nint idx, ldlm_side_t client)\r\n{\r\nint rc;\r\nspin_lock_init(&pl->pl_lock);\r\natomic_set(&pl->pl_granted, 0);\r\npl->pl_recalc_time = cfs_time_current_sec();\r\natomic_set(&pl->pl_lock_volume_factor, 1);\r\natomic_set(&pl->pl_grant_rate, 0);\r\natomic_set(&pl->pl_cancel_rate, 0);\r\npl->pl_grant_plan = LDLM_POOL_GP(LDLM_POOL_HOST_L);\r\nsnprintf(pl->pl_name, sizeof(pl->pl_name), "ldlm-pool-%s-%d",\r\nldlm_ns_name(ns), idx);\r\nif (client == LDLM_NAMESPACE_SERVER) {\r\npl->pl_ops = &ldlm_srv_pool_ops;\r\nldlm_pool_set_limit(pl, LDLM_POOL_HOST_L);\r\npl->pl_recalc_period = LDLM_POOL_SRV_DEF_RECALC_PERIOD;\r\npl->pl_server_lock_volume = ldlm_pool_slv_max(LDLM_POOL_HOST_L);\r\n} else {\r\nldlm_pool_set_limit(pl, 1);\r\npl->pl_server_lock_volume = 0;\r\npl->pl_ops = &ldlm_cli_pool_ops;\r\npl->pl_recalc_period = LDLM_POOL_CLI_DEF_RECALC_PERIOD;\r\n}\r\npl->pl_client_lock_volume = 0;\r\nrc = ldlm_pool_proc_init(pl);\r\nif (rc)\r\nreturn rc;\r\nCDEBUG(D_DLMTRACE, "Lock pool %s is initialized\n", pl->pl_name);\r\nreturn rc;\r\n}\r\nvoid ldlm_pool_fini(struct ldlm_pool *pl)\r\n{\r\nldlm_pool_proc_fini(pl);\r\nPOISON(pl, 0x5a, sizeof(*pl));\r\n}\r\nvoid ldlm_pool_add(struct ldlm_pool *pl, struct ldlm_lock *lock)\r\n{\r\nif (lock->l_resource->lr_type == LDLM_FLOCK)\r\nreturn;\r\natomic_inc(&pl->pl_granted);\r\natomic_inc(&pl->pl_grant_rate);\r\nlprocfs_counter_incr(pl->pl_stats, LDLM_POOL_GRANT_STAT);\r\nif (ns_is_server(ldlm_pl2ns(pl)))\r\nldlm_pool_recalc(pl);\r\n}\r\nvoid ldlm_pool_del(struct ldlm_pool *pl, struct ldlm_lock *lock)\r\n{\r\nif (lock->l_resource->lr_type == LDLM_FLOCK)\r\nreturn;\r\nLASSERT(atomic_read(&pl->pl_granted) > 0);\r\natomic_dec(&pl->pl_granted);\r\natomic_inc(&pl->pl_cancel_rate);\r\nlprocfs_counter_incr(pl->pl_stats, LDLM_POOL_CANCEL_STAT);\r\nif (ns_is_server(ldlm_pl2ns(pl)))\r\nldlm_pool_recalc(pl);\r\n}\r\n__u64 ldlm_pool_get_slv(struct ldlm_pool *pl)\r\n{\r\n__u64 slv;\r\nspin_lock(&pl->pl_lock);\r\nslv = pl->pl_server_lock_volume;\r\nspin_unlock(&pl->pl_lock);\r\nreturn slv;\r\n}\r\nvoid ldlm_pool_set_slv(struct ldlm_pool *pl, __u64 slv)\r\n{\r\nspin_lock(&pl->pl_lock);\r\npl->pl_server_lock_volume = slv;\r\nspin_unlock(&pl->pl_lock);\r\n}\r\n__u64 ldlm_pool_get_clv(struct ldlm_pool *pl)\r\n{\r\n__u64 slv;\r\nspin_lock(&pl->pl_lock);\r\nslv = pl->pl_client_lock_volume;\r\nspin_unlock(&pl->pl_lock);\r\nreturn slv;\r\n}\r\nvoid ldlm_pool_set_clv(struct ldlm_pool *pl, __u64 clv)\r\n{\r\nspin_lock(&pl->pl_lock);\r\npl->pl_client_lock_volume = clv;\r\nspin_unlock(&pl->pl_lock);\r\n}\r\n__u32 ldlm_pool_get_limit(struct ldlm_pool *pl)\r\n{\r\nreturn atomic_read(&pl->pl_limit);\r\n}\r\nvoid ldlm_pool_set_limit(struct ldlm_pool *pl, __u32 limit)\r\n{\r\natomic_set(&pl->pl_limit, limit);\r\n}\r\n__u32 ldlm_pool_get_lvf(struct ldlm_pool *pl)\r\n{\r\nreturn atomic_read(&pl->pl_lock_volume_factor);\r\n}\r\nstatic int ldlm_pool_granted(struct ldlm_pool *pl)\r\n{\r\nreturn atomic_read(&pl->pl_granted);\r\n}\r\nstatic unsigned long ldlm_pools_count(ldlm_side_t client, unsigned int gfp_mask)\r\n{\r\nint total = 0, nr_ns;\r\nstruct ldlm_namespace *ns;\r\nstruct ldlm_namespace *ns_old = NULL;\r\nvoid *cookie;\r\nif (client == LDLM_NAMESPACE_CLIENT && !(gfp_mask & __GFP_FS))\r\nreturn 0;\r\nCDEBUG(D_DLMTRACE, "Request to count %s locks from all pools\n",\r\nclient == LDLM_NAMESPACE_CLIENT ? "client" : "server");\r\ncookie = cl_env_reenter();\r\nfor (nr_ns = ldlm_namespace_nr_read(client);\r\nnr_ns > 0; nr_ns--) {\r\nmutex_lock(ldlm_namespace_lock(client));\r\nif (list_empty(ldlm_namespace_list(client))) {\r\nmutex_unlock(ldlm_namespace_lock(client));\r\ncl_env_reexit(cookie);\r\nreturn 0;\r\n}\r\nns = ldlm_namespace_first_locked(client);\r\nif (ns == ns_old) {\r\nmutex_unlock(ldlm_namespace_lock(client));\r\nbreak;\r\n}\r\nif (ldlm_ns_empty(ns)) {\r\nldlm_namespace_move_to_inactive_locked(ns, client);\r\nmutex_unlock(ldlm_namespace_lock(client));\r\ncontinue;\r\n}\r\nif (ns_old == NULL)\r\nns_old = ns;\r\nldlm_namespace_get(ns);\r\nldlm_namespace_move_to_active_locked(ns, client);\r\nmutex_unlock(ldlm_namespace_lock(client));\r\ntotal += ldlm_pool_shrink(&ns->ns_pool, 0, gfp_mask);\r\nldlm_namespace_put(ns);\r\n}\r\ncl_env_reexit(cookie);\r\nreturn total;\r\n}\r\nstatic unsigned long ldlm_pools_scan(ldlm_side_t client, int nr, unsigned int gfp_mask)\r\n{\r\nunsigned long freed = 0;\r\nint tmp, nr_ns;\r\nstruct ldlm_namespace *ns;\r\nvoid *cookie;\r\nif (client == LDLM_NAMESPACE_CLIENT && !(gfp_mask & __GFP_FS))\r\nreturn -1;\r\ncookie = cl_env_reenter();\r\nfor (tmp = nr_ns = ldlm_namespace_nr_read(client);\r\ntmp > 0; tmp--) {\r\nint cancel, nr_locks;\r\nmutex_lock(ldlm_namespace_lock(client));\r\nif (list_empty(ldlm_namespace_list(client))) {\r\nmutex_unlock(ldlm_namespace_lock(client));\r\nbreak;\r\n}\r\nns = ldlm_namespace_first_locked(client);\r\nldlm_namespace_get(ns);\r\nldlm_namespace_move_to_active_locked(ns, client);\r\nmutex_unlock(ldlm_namespace_lock(client));\r\nnr_locks = ldlm_pool_granted(&ns->ns_pool);\r\ncancel = 1 + min_t(int, nr_locks, nr / nr_ns);\r\nfreed += ldlm_pool_shrink(&ns->ns_pool, cancel, gfp_mask);\r\nldlm_namespace_put(ns);\r\n}\r\ncl_env_reexit(cookie);\r\nreturn (client == LDLM_NAMESPACE_SERVER) ? SHRINK_STOP : freed;\r\n}\r\nstatic unsigned long ldlm_pools_srv_count(struct shrinker *s, struct shrink_control *sc)\r\n{\r\nreturn ldlm_pools_count(LDLM_NAMESPACE_SERVER, sc->gfp_mask);\r\n}\r\nstatic unsigned long ldlm_pools_srv_scan(struct shrinker *s, struct shrink_control *sc)\r\n{\r\nreturn ldlm_pools_scan(LDLM_NAMESPACE_SERVER, sc->nr_to_scan,\r\nsc->gfp_mask);\r\n}\r\nstatic unsigned long ldlm_pools_cli_count(struct shrinker *s, struct shrink_control *sc)\r\n{\r\nreturn ldlm_pools_count(LDLM_NAMESPACE_CLIENT, sc->gfp_mask);\r\n}\r\nstatic unsigned long ldlm_pools_cli_scan(struct shrinker *s, struct shrink_control *sc)\r\n{\r\nreturn ldlm_pools_scan(LDLM_NAMESPACE_CLIENT, sc->nr_to_scan,\r\nsc->gfp_mask);\r\n}\r\nint ldlm_pools_recalc(ldlm_side_t client)\r\n{\r\n__u32 nr_l = 0, nr_p = 0, l;\r\nstruct ldlm_namespace *ns;\r\nstruct ldlm_namespace *ns_old = NULL;\r\nint nr, equal = 0;\r\nint time = 50;\r\nif (client == LDLM_NAMESPACE_SERVER) {\r\nmutex_lock(ldlm_namespace_lock(client));\r\nlist_for_each_entry(ns, ldlm_namespace_list(client),\r\nns_list_chain)\r\n{\r\nif (ns->ns_appetite != LDLM_NAMESPACE_MODEST)\r\ncontinue;\r\nl = ldlm_pool_granted(&ns->ns_pool);\r\nif (l == 0)\r\nl = 1;\r\nl += dru(l, LDLM_POOLS_MODEST_MARGIN_SHIFT, 0);\r\nldlm_pool_setup(&ns->ns_pool, l);\r\nnr_l += l;\r\nnr_p++;\r\n}\r\nif (nr_l >= 2 * (LDLM_POOL_HOST_L / 3)) {\r\nCWARN("\"Modest\" pools eat out 2/3 of server locks "\r\n"limit (%d of %lu). This means that you have too "\r\n"many clients for this amount of server RAM. "\r\n"Upgrade server!\n", nr_l, LDLM_POOL_HOST_L);\r\nequal = 1;\r\n}\r\nlist_for_each_entry(ns, ldlm_namespace_list(client),\r\nns_list_chain)\r\n{\r\nif (!equal && ns->ns_appetite != LDLM_NAMESPACE_GREEDY)\r\ncontinue;\r\nif (equal) {\r\nl = LDLM_POOL_HOST_L /\r\nldlm_namespace_nr_read(client);\r\n} else {\r\nl = (LDLM_POOL_HOST_L - nr_l) /\r\n(ldlm_namespace_nr_read(client) -\r\nnr_p);\r\n}\r\nldlm_pool_setup(&ns->ns_pool, l);\r\n}\r\nmutex_unlock(ldlm_namespace_lock(client));\r\n}\r\nfor (nr = ldlm_namespace_nr_read(client); nr > 0; nr--) {\r\nint skip;\r\nmutex_lock(ldlm_namespace_lock(client));\r\nif (list_empty(ldlm_namespace_list(client))) {\r\nmutex_unlock(ldlm_namespace_lock(client));\r\nbreak;\r\n}\r\nns = ldlm_namespace_first_locked(client);\r\nif (ns_old == ns) {\r\nmutex_unlock(ldlm_namespace_lock(client));\r\nbreak;\r\n}\r\nif (ldlm_ns_empty(ns)) {\r\nldlm_namespace_move_to_inactive_locked(ns, client);\r\nmutex_unlock(ldlm_namespace_lock(client));\r\ncontinue;\r\n}\r\nif (ns_old == NULL)\r\nns_old = ns;\r\nspin_lock(&ns->ns_lock);\r\nif (ns->ns_stopping) {\r\nskip = 1;\r\n} else {\r\nskip = 0;\r\nldlm_namespace_get(ns);\r\n}\r\nspin_unlock(&ns->ns_lock);\r\nldlm_namespace_move_to_active_locked(ns, client);\r\nmutex_unlock(ldlm_namespace_lock(client));\r\nif (!skip) {\r\nint ttime = ldlm_pool_recalc(&ns->ns_pool);\r\nif (ttime < time)\r\ntime = ttime;\r\nldlm_namespace_put(ns);\r\n}\r\n}\r\nreturn time;\r\n}\r\nstatic int ldlm_pools_thread_main(void *arg)\r\n{\r\nstruct ptlrpc_thread *thread = (struct ptlrpc_thread *)arg;\r\nint s_time, c_time;\r\nthread_set_flags(thread, SVC_RUNNING);\r\nwake_up(&thread->t_ctl_waitq);\r\nCDEBUG(D_DLMTRACE, "%s: pool thread starting, process %d\n",\r\n"ldlm_poold", current_pid());\r\nwhile (1) {\r\nstruct l_wait_info lwi;\r\ns_time = ldlm_pools_recalc(LDLM_NAMESPACE_SERVER);\r\nc_time = ldlm_pools_recalc(LDLM_NAMESPACE_CLIENT);\r\nlwi = LWI_TIMEOUT(cfs_time_seconds(min(s_time, c_time)),\r\nNULL, NULL);\r\nl_wait_event(thread->t_ctl_waitq,\r\nthread_is_stopping(thread) ||\r\nthread_is_event(thread),\r\n&lwi);\r\nif (thread_test_and_clear_flags(thread, SVC_STOPPING))\r\nbreak;\r\nelse\r\nthread_test_and_clear_flags(thread, SVC_EVENT);\r\n}\r\nthread_set_flags(thread, SVC_STOPPED);\r\nwake_up(&thread->t_ctl_waitq);\r\nCDEBUG(D_DLMTRACE, "%s: pool thread exiting, process %d\n",\r\n"ldlm_poold", current_pid());\r\ncomplete_and_exit(&ldlm_pools_comp, 0);\r\n}\r\nstatic int ldlm_pools_thread_start(void)\r\n{\r\nstruct l_wait_info lwi = { 0 };\r\nstruct task_struct *task;\r\nif (ldlm_pools_thread != NULL)\r\nreturn -EALREADY;\r\nOBD_ALLOC_PTR(ldlm_pools_thread);\r\nif (ldlm_pools_thread == NULL)\r\nreturn -ENOMEM;\r\ninit_completion(&ldlm_pools_comp);\r\ninit_waitqueue_head(&ldlm_pools_thread->t_ctl_waitq);\r\ntask = kthread_run(ldlm_pools_thread_main, ldlm_pools_thread,\r\n"ldlm_poold");\r\nif (IS_ERR(task)) {\r\nCERROR("Can't start pool thread, error %ld\n", PTR_ERR(task));\r\nOBD_FREE(ldlm_pools_thread, sizeof(*ldlm_pools_thread));\r\nldlm_pools_thread = NULL;\r\nreturn PTR_ERR(task);\r\n}\r\nl_wait_event(ldlm_pools_thread->t_ctl_waitq,\r\nthread_is_running(ldlm_pools_thread), &lwi);\r\nreturn 0;\r\n}\r\nstatic void ldlm_pools_thread_stop(void)\r\n{\r\nif (ldlm_pools_thread == NULL) {\r\nreturn;\r\n}\r\nthread_set_flags(ldlm_pools_thread, SVC_STOPPING);\r\nwake_up(&ldlm_pools_thread->t_ctl_waitq);\r\nwait_for_completion(&ldlm_pools_comp);\r\nOBD_FREE_PTR(ldlm_pools_thread);\r\nldlm_pools_thread = NULL;\r\n}\r\nint ldlm_pools_init(void)\r\n{\r\nint rc;\r\nrc = ldlm_pools_thread_start();\r\nif (rc == 0) {\r\nregister_shrinker(&ldlm_pools_srv_shrinker);\r\nregister_shrinker(&ldlm_pools_cli_shrinker);\r\n}\r\nreturn rc;\r\n}\r\nvoid ldlm_pools_fini(void)\r\n{\r\nunregister_shrinker(&ldlm_pools_srv_shrinker);\r\nunregister_shrinker(&ldlm_pools_cli_shrinker);\r\nldlm_pools_thread_stop();\r\n}
