static unsigned samsung_dmadev_request(enum dma_ch dma_ch,\r\nstruct samsung_dma_req *param,\r\nstruct device *dev, char *ch_name)\r\n{\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(param->cap, mask);\r\nif (dev->of_node)\r\nreturn (unsigned)dma_request_slave_channel(dev, ch_name);\r\nelse\r\nreturn (unsigned)dma_request_channel(mask, pl330_filter,\r\n(void *)dma_ch);\r\n}\r\nstatic int samsung_dmadev_release(unsigned ch, void *param)\r\n{\r\ndma_release_channel((struct dma_chan *)ch);\r\nreturn 0;\r\n}\r\nstatic int samsung_dmadev_config(unsigned ch,\r\nstruct samsung_dma_config *param)\r\n{\r\nstruct dma_chan *chan = (struct dma_chan *)ch;\r\nstruct dma_slave_config slave_config;\r\nif (param->direction == DMA_DEV_TO_MEM) {\r\nmemset(&slave_config, 0, sizeof(struct dma_slave_config));\r\nslave_config.direction = param->direction;\r\nslave_config.src_addr = param->fifo;\r\nslave_config.src_addr_width = param->width;\r\nslave_config.src_maxburst = 1;\r\ndmaengine_slave_config(chan, &slave_config);\r\n} else if (param->direction == DMA_MEM_TO_DEV) {\r\nmemset(&slave_config, 0, sizeof(struct dma_slave_config));\r\nslave_config.direction = param->direction;\r\nslave_config.dst_addr = param->fifo;\r\nslave_config.dst_addr_width = param->width;\r\nslave_config.dst_maxburst = 1;\r\ndmaengine_slave_config(chan, &slave_config);\r\n} else {\r\npr_warn("unsupported direction\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int samsung_dmadev_prepare(unsigned ch,\r\nstruct samsung_dma_prep *param)\r\n{\r\nstruct scatterlist sg;\r\nstruct dma_chan *chan = (struct dma_chan *)ch;\r\nstruct dma_async_tx_descriptor *desc;\r\nswitch (param->cap) {\r\ncase DMA_SLAVE:\r\nsg_init_table(&sg, 1);\r\nsg_dma_len(&sg) = param->len;\r\nsg_set_page(&sg, pfn_to_page(PFN_DOWN(param->buf)),\r\nparam->len, offset_in_page(param->buf));\r\nsg_dma_address(&sg) = param->buf;\r\ndesc = dmaengine_prep_slave_sg(chan,\r\n&sg, 1, param->direction, DMA_PREP_INTERRUPT);\r\nbreak;\r\ncase DMA_CYCLIC:\r\ndesc = dmaengine_prep_dma_cyclic(chan, param->buf,\r\nparam->len, param->period, param->direction,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nbreak;\r\ndefault:\r\ndev_err(&chan->dev->device, "unsupported format\n");\r\nreturn -EFAULT;\r\n}\r\nif (!desc) {\r\ndev_err(&chan->dev->device, "cannot prepare cyclic dma\n");\r\nreturn -EFAULT;\r\n}\r\ndesc->callback = param->fp;\r\ndesc->callback_param = param->fp_param;\r\ndmaengine_submit((struct dma_async_tx_descriptor *)desc);\r\nreturn 0;\r\n}\r\nstatic inline int samsung_dmadev_trigger(unsigned ch)\r\n{\r\ndma_async_issue_pending((struct dma_chan *)ch);\r\nreturn 0;\r\n}\r\nstatic inline int samsung_dmadev_flush(unsigned ch)\r\n{\r\nreturn dmaengine_terminate_all((struct dma_chan *)ch);\r\n}\r\nvoid *samsung_dmadev_get_ops(void)\r\n{\r\nreturn &dmadev_ops;\r\n}
