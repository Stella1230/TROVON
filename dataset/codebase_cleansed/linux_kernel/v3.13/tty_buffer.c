void tty_buffer_lock_exclusive(struct tty_port *port)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\natomic_inc(&buf->priority);\r\nmutex_lock(&buf->lock);\r\n}\r\nvoid tty_buffer_unlock_exclusive(struct tty_port *port)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nint restart;\r\nrestart = buf->head->commit != buf->head->read;\r\natomic_dec(&buf->priority);\r\nmutex_unlock(&buf->lock);\r\nif (restart)\r\nqueue_work(system_unbound_wq, &buf->work);\r\n}\r\nint tty_buffer_space_avail(struct tty_port *port)\r\n{\r\nint space = TTYB_MEM_LIMIT - atomic_read(&port->buf.memory_used);\r\nreturn max(space, 0);\r\n}\r\nstatic void tty_buffer_reset(struct tty_buffer *p, size_t size)\r\n{\r\np->used = 0;\r\np->size = size;\r\np->next = NULL;\r\np->commit = 0;\r\np->read = 0;\r\n}\r\nvoid tty_buffer_free_all(struct tty_port *port)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nstruct tty_buffer *p, *next;\r\nstruct llist_node *llist;\r\nwhile ((p = buf->head) != NULL) {\r\nbuf->head = p->next;\r\nif (p->size > 0)\r\nkfree(p);\r\n}\r\nllist = llist_del_all(&buf->free);\r\nllist_for_each_entry_safe(p, next, llist, free)\r\nkfree(p);\r\ntty_buffer_reset(&buf->sentinel, 0);\r\nbuf->head = &buf->sentinel;\r\nbuf->tail = &buf->sentinel;\r\natomic_set(&buf->memory_used, 0);\r\n}\r\nstatic struct tty_buffer *tty_buffer_alloc(struct tty_port *port, size_t size)\r\n{\r\nstruct llist_node *free;\r\nstruct tty_buffer *p;\r\nsize = __ALIGN_MASK(size, TTYB_ALIGN_MASK);\r\nif (size <= MIN_TTYB_SIZE) {\r\nfree = llist_del_first(&port->buf.free);\r\nif (free) {\r\np = llist_entry(free, struct tty_buffer, free);\r\ngoto found;\r\n}\r\n}\r\nif (atomic_read(&port->buf.memory_used) > TTYB_MEM_LIMIT)\r\nreturn NULL;\r\np = kmalloc(sizeof(struct tty_buffer) + 2 * size, GFP_ATOMIC);\r\nif (p == NULL)\r\nreturn NULL;\r\nfound:\r\ntty_buffer_reset(p, size);\r\natomic_add(size, &port->buf.memory_used);\r\nreturn p;\r\n}\r\nstatic void tty_buffer_free(struct tty_port *port, struct tty_buffer *b)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nWARN_ON(atomic_sub_return(b->size, &buf->memory_used) < 0);\r\nif (b->size > MIN_TTYB_SIZE)\r\nkfree(b);\r\nelse if (b->size > 0)\r\nllist_add(&b->free, &buf->free);\r\n}\r\nvoid tty_buffer_flush(struct tty_struct *tty)\r\n{\r\nstruct tty_port *port = tty->port;\r\nstruct tty_bufhead *buf = &port->buf;\r\nstruct tty_buffer *next;\r\natomic_inc(&buf->priority);\r\nmutex_lock(&buf->lock);\r\nwhile ((next = buf->head->next) != NULL) {\r\ntty_buffer_free(port, buf->head);\r\nbuf->head = next;\r\n}\r\nbuf->head->read = buf->head->commit;\r\natomic_dec(&buf->priority);\r\nmutex_unlock(&buf->lock);\r\n}\r\nint tty_buffer_request_room(struct tty_port *port, size_t size)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nstruct tty_buffer *b, *n;\r\nint left;\r\nb = buf->tail;\r\nleft = b->size - b->used;\r\nif (left < size) {\r\nif ((n = tty_buffer_alloc(port, size)) != NULL) {\r\nbuf->tail = n;\r\nb->commit = b->used;\r\nsmp_mb();\r\nb->next = n;\r\n} else\r\nsize = left;\r\n}\r\nreturn size;\r\n}\r\nint tty_insert_flip_string_fixed_flag(struct tty_port *port,\r\nconst unsigned char *chars, char flag, size_t size)\r\n{\r\nint copied = 0;\r\ndo {\r\nint goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE);\r\nint space = tty_buffer_request_room(port, goal);\r\nstruct tty_buffer *tb = port->buf.tail;\r\nif (unlikely(space == 0))\r\nbreak;\r\nmemcpy(char_buf_ptr(tb, tb->used), chars, space);\r\nmemset(flag_buf_ptr(tb, tb->used), flag, space);\r\ntb->used += space;\r\ncopied += space;\r\nchars += space;\r\n} while (unlikely(size > copied));\r\nreturn copied;\r\n}\r\nint tty_insert_flip_string_flags(struct tty_port *port,\r\nconst unsigned char *chars, const char *flags, size_t size)\r\n{\r\nint copied = 0;\r\ndo {\r\nint goal = min_t(size_t, size - copied, TTY_BUFFER_PAGE);\r\nint space = tty_buffer_request_room(port, goal);\r\nstruct tty_buffer *tb = port->buf.tail;\r\nif (unlikely(space == 0))\r\nbreak;\r\nmemcpy(char_buf_ptr(tb, tb->used), chars, space);\r\nmemcpy(flag_buf_ptr(tb, tb->used), flags, space);\r\ntb->used += space;\r\ncopied += space;\r\nchars += space;\r\nflags += space;\r\n} while (unlikely(size > copied));\r\nreturn copied;\r\n}\r\nvoid tty_schedule_flip(struct tty_port *port)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nWARN_ON(port->low_latency);\r\nbuf->tail->commit = buf->tail->used;\r\nschedule_work(&buf->work);\r\n}\r\nint tty_prepare_flip_string(struct tty_port *port, unsigned char **chars,\r\nsize_t size)\r\n{\r\nint space = tty_buffer_request_room(port, size);\r\nif (likely(space)) {\r\nstruct tty_buffer *tb = port->buf.tail;\r\n*chars = char_buf_ptr(tb, tb->used);\r\nmemset(flag_buf_ptr(tb, tb->used), TTY_NORMAL, space);\r\ntb->used += space;\r\n}\r\nreturn space;\r\n}\r\nint tty_prepare_flip_string_flags(struct tty_port *port,\r\nunsigned char **chars, char **flags, size_t size)\r\n{\r\nint space = tty_buffer_request_room(port, size);\r\nif (likely(space)) {\r\nstruct tty_buffer *tb = port->buf.tail;\r\n*chars = char_buf_ptr(tb, tb->used);\r\n*flags = flag_buf_ptr(tb, tb->used);\r\ntb->used += space;\r\n}\r\nreturn space;\r\n}\r\nstatic int\r\nreceive_buf(struct tty_struct *tty, struct tty_buffer *head, int count)\r\n{\r\nstruct tty_ldisc *disc = tty->ldisc;\r\nunsigned char *p = char_buf_ptr(head, head->read);\r\nchar *f = flag_buf_ptr(head, head->read);\r\nif (disc->ops->receive_buf2)\r\ncount = disc->ops->receive_buf2(tty, p, f, count);\r\nelse {\r\ncount = min_t(int, count, tty->receive_room);\r\nif (count)\r\ndisc->ops->receive_buf(tty, p, f, count);\r\n}\r\nhead->read += count;\r\nreturn count;\r\n}\r\nstatic void flush_to_ldisc(struct work_struct *work)\r\n{\r\nstruct tty_port *port = container_of(work, struct tty_port, buf.work);\r\nstruct tty_bufhead *buf = &port->buf;\r\nstruct tty_struct *tty;\r\nstruct tty_ldisc *disc;\r\ntty = port->itty;\r\nif (tty == NULL)\r\nreturn;\r\ndisc = tty_ldisc_ref(tty);\r\nif (disc == NULL)\r\nreturn;\r\nmutex_lock(&buf->lock);\r\nwhile (1) {\r\nstruct tty_buffer *head = buf->head;\r\nint count;\r\nif (atomic_read(&buf->priority))\r\nbreak;\r\ncount = head->commit - head->read;\r\nif (!count) {\r\nif (head->next == NULL)\r\nbreak;\r\nbuf->head = head->next;\r\ntty_buffer_free(port, head);\r\ncontinue;\r\n}\r\ncount = receive_buf(tty, head, count);\r\nif (!count)\r\nbreak;\r\n}\r\nmutex_unlock(&buf->lock);\r\ntty_ldisc_deref(disc);\r\n}\r\nvoid tty_flush_to_ldisc(struct tty_struct *tty)\r\n{\r\nif (!tty->port->low_latency)\r\nflush_work(&tty->port->buf.work);\r\n}\r\nvoid tty_flip_buffer_push(struct tty_port *port)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nbuf->tail->commit = buf->tail->used;\r\nif (port->low_latency)\r\nflush_to_ldisc(&buf->work);\r\nelse\r\nschedule_work(&buf->work);\r\n}\r\nvoid tty_buffer_init(struct tty_port *port)\r\n{\r\nstruct tty_bufhead *buf = &port->buf;\r\nmutex_init(&buf->lock);\r\ntty_buffer_reset(&buf->sentinel, 0);\r\nbuf->head = &buf->sentinel;\r\nbuf->tail = &buf->sentinel;\r\ninit_llist_head(&buf->free);\r\natomic_set(&buf->memory_used, 0);\r\natomic_set(&buf->priority, 0);\r\nINIT_WORK(&buf->work, flush_to_ldisc);\r\n}
