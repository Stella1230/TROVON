static __be32\r\nnfsd3_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)\r\n{\r\nreturn nfs_ok;\r\n}\r\nstatic __be32 nfsd3_proc_getacl(struct svc_rqst * rqstp,\r\nstruct nfsd3_getaclargs *argp, struct nfsd3_getaclres *resp)\r\n{\r\nsvc_fh *fh;\r\nstruct posix_acl *acl;\r\n__be32 nfserr = 0;\r\nfh = fh_copy(&resp->fh, &argp->fh);\r\nnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_NOP);\r\nif (nfserr)\r\nRETURN_STATUS(nfserr);\r\nif (argp->mask & ~(NFS_ACL|NFS_ACLCNT|NFS_DFACL|NFS_DFACLCNT))\r\nRETURN_STATUS(nfserr_inval);\r\nresp->mask = argp->mask;\r\nif (resp->mask & (NFS_ACL|NFS_ACLCNT)) {\r\nacl = nfsd_get_posix_acl(fh, ACL_TYPE_ACCESS);\r\nif (IS_ERR(acl)) {\r\nint err = PTR_ERR(acl);\r\nif (err == -ENODATA || err == -EOPNOTSUPP)\r\nacl = NULL;\r\nelse {\r\nnfserr = nfserrno(err);\r\ngoto fail;\r\n}\r\n}\r\nif (acl == NULL) {\r\nstruct inode *inode = fh->fh_dentry->d_inode;\r\nacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\r\n}\r\nresp->acl_access = acl;\r\n}\r\nif (resp->mask & (NFS_DFACL|NFS_DFACLCNT)) {\r\nacl = nfsd_get_posix_acl(fh, ACL_TYPE_DEFAULT);\r\nif (IS_ERR(acl)) {\r\nint err = PTR_ERR(acl);\r\nif (err == -ENODATA || err == -EOPNOTSUPP)\r\nacl = NULL;\r\nelse {\r\nnfserr = nfserrno(err);\r\ngoto fail;\r\n}\r\n}\r\nresp->acl_default = acl;\r\n}\r\nRETURN_STATUS(0);\r\nfail:\r\nposix_acl_release(resp->acl_access);\r\nposix_acl_release(resp->acl_default);\r\nRETURN_STATUS(nfserr);\r\n}\r\nstatic __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,\r\nstruct nfsd3_setaclargs *argp,\r\nstruct nfsd3_attrstat *resp)\r\n{\r\nsvc_fh *fh;\r\n__be32 nfserr = 0;\r\nfh = fh_copy(&resp->fh, &argp->fh);\r\nnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\r\nif (!nfserr) {\r\nnfserr = nfserrno( nfsd_set_posix_acl(\r\nfh, ACL_TYPE_ACCESS, argp->acl_access) );\r\n}\r\nif (!nfserr) {\r\nnfserr = nfserrno( nfsd_set_posix_acl(\r\nfh, ACL_TYPE_DEFAULT, argp->acl_default) );\r\n}\r\nposix_acl_release(argp->acl_access);\r\nposix_acl_release(argp->acl_default);\r\nRETURN_STATUS(nfserr);\r\n}\r\nstatic int nfs3svc_decode_getaclargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_getaclargs *args)\r\n{\r\nif (!(p = nfs3svc_decode_fh(p, &args->fh)))\r\nreturn 0;\r\nargs->mask = ntohl(*p); p++;\r\nreturn xdr_argsize_check(rqstp, p);\r\n}\r\nstatic int nfs3svc_decode_setaclargs(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_setaclargs *args)\r\n{\r\nstruct kvec *head = rqstp->rq_arg.head;\r\nunsigned int base;\r\nint n;\r\nif (!(p = nfs3svc_decode_fh(p, &args->fh)))\r\nreturn 0;\r\nargs->mask = ntohl(*p++);\r\nif (args->mask & ~(NFS_ACL|NFS_ACLCNT|NFS_DFACL|NFS_DFACLCNT) ||\r\n!xdr_argsize_check(rqstp, p))\r\nreturn 0;\r\nbase = (char *)p - (char *)head->iov_base;\r\nn = nfsacl_decode(&rqstp->rq_arg, base, NULL,\r\n(args->mask & NFS_ACL) ?\r\n&args->acl_access : NULL);\r\nif (n > 0)\r\nn = nfsacl_decode(&rqstp->rq_arg, base + n, NULL,\r\n(args->mask & NFS_DFACL) ?\r\n&args->acl_default : NULL);\r\nreturn (n > 0);\r\n}\r\nstatic int nfs3svc_encode_getaclres(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_getaclres *resp)\r\n{\r\nstruct dentry *dentry = resp->fh.fh_dentry;\r\np = nfs3svc_encode_post_op_attr(rqstp, p, &resp->fh);\r\nif (resp->status == 0 && dentry && dentry->d_inode) {\r\nstruct inode *inode = dentry->d_inode;\r\nstruct kvec *head = rqstp->rq_res.head;\r\nunsigned int base;\r\nint n;\r\nint w;\r\n*p++ = htonl(resp->mask);\r\nif (!xdr_ressize_check(rqstp, p))\r\nreturn 0;\r\nbase = (char *)p - (char *)head->iov_base;\r\nrqstp->rq_res.page_len = w = nfsacl_size(\r\n(resp->mask & NFS_ACL) ? resp->acl_access : NULL,\r\n(resp->mask & NFS_DFACL) ? resp->acl_default : NULL);\r\nwhile (w > 0) {\r\nif (!*(rqstp->rq_next_page++))\r\nreturn 0;\r\nw -= PAGE_SIZE;\r\n}\r\nn = nfsacl_encode(&rqstp->rq_res, base, inode,\r\nresp->acl_access,\r\nresp->mask & NFS_ACL, 0);\r\nif (n > 0)\r\nn = nfsacl_encode(&rqstp->rq_res, base + n, inode,\r\nresp->acl_default,\r\nresp->mask & NFS_DFACL,\r\nNFS_ACL_DEFAULT);\r\nif (n <= 0)\r\nreturn 0;\r\n} else\r\nif (!xdr_ressize_check(rqstp, p))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int nfs3svc_encode_setaclres(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_attrstat *resp)\r\n{\r\np = nfs3svc_encode_post_op_attr(rqstp, p, &resp->fh);\r\nreturn xdr_ressize_check(rqstp, p);\r\n}\r\nstatic int nfs3svc_release_getacl(struct svc_rqst *rqstp, __be32 *p,\r\nstruct nfsd3_getaclres *resp)\r\n{\r\nfh_put(&resp->fh);\r\nposix_acl_release(resp->acl_access);\r\nposix_acl_release(resp->acl_default);\r\nreturn 1;\r\n}
