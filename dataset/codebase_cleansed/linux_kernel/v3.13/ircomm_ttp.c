int ircomm_open_tsap(struct ircomm_cb *self)\r\n{\r\nnotify_t notify;\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nirda_notify_init(&notify);\r\nnotify.data_indication = ircomm_ttp_data_indication;\r\nnotify.connect_confirm = ircomm_ttp_connect_confirm;\r\nnotify.connect_indication = ircomm_ttp_connect_indication;\r\nnotify.flow_indication = ircomm_ttp_flow_indication;\r\nnotify.disconnect_indication = ircomm_ttp_disconnect_indication;\r\nnotify.instance = self;\r\nstrlcpy(notify.name, "IrCOMM", sizeof(notify.name));\r\nself->tsap = irttp_open_tsap(LSAP_ANY, DEFAULT_INITIAL_CREDIT,\r\n&notify);\r\nif (!self->tsap) {\r\nIRDA_DEBUG(0, "%sfailed to allocate tsap\n", __func__ );\r\nreturn -1;\r\n}\r\nself->slsap_sel = self->tsap->stsap_sel;\r\nself->issue.data_request = ircomm_ttp_data_request;\r\nself->issue.connect_request = ircomm_ttp_connect_request;\r\nself->issue.connect_response = ircomm_ttp_connect_response;\r\nself->issue.disconnect_request = ircomm_ttp_disconnect_request;\r\nreturn 0;\r\n}\r\nstatic int ircomm_ttp_connect_request(struct ircomm_cb *self,\r\nstruct sk_buff *userdata,\r\nstruct ircomm_info *info)\r\n{\r\nint ret = 0;\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nif(userdata)\r\nskb_get(userdata);\r\nret = irttp_connect_request(self->tsap, info->dlsap_sel,\r\ninfo->saddr, info->daddr, NULL,\r\nTTP_SAR_DISABLE, userdata);\r\nreturn ret;\r\n}\r\nstatic int ircomm_ttp_connect_response(struct ircomm_cb *self,\r\nstruct sk_buff *userdata)\r\n{\r\nint ret;\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nif(userdata)\r\nskb_get(userdata);\r\nret = irttp_connect_response(self->tsap, TTP_SAR_DISABLE, userdata);\r\nreturn ret;\r\n}\r\nstatic int ircomm_ttp_data_request(struct ircomm_cb *self,\r\nstruct sk_buff *skb,\r\nint clen)\r\n{\r\nint ret;\r\nIRDA_ASSERT(skb != NULL, return -1;);\r\nIRDA_DEBUG(2, "%s(), clen=%d\n", __func__ , clen);\r\nIRDA_ASSERT(skb_headroom(skb) >= IRCOMM_HEADER_SIZE, return -1;);\r\nskb_get(skb);\r\nskb_push(skb, IRCOMM_HEADER_SIZE);\r\nskb->data[0] = clen;\r\nret = irttp_data_request(self->tsap, skb);\r\nif (ret) {\r\nIRDA_ERROR("%s(), failed\n", __func__);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ircomm_ttp_data_indication(void *instance, void *sap,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ircomm_cb *self = (struct ircomm_cb *) instance;\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IRCOMM_MAGIC, return -1;);\r\nIRDA_ASSERT(skb != NULL, return -1;);\r\nircomm_do_event(self, IRCOMM_TTP_DATA_INDICATION, skb, NULL);\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void ircomm_ttp_connect_confirm(void *instance, void *sap,\r\nstruct qos_info *qos,\r\n__u32 max_sdu_size,\r\n__u8 max_header_size,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ircomm_cb *self = (struct ircomm_cb *) instance;\r\nstruct ircomm_info info;\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nIRDA_ASSERT(qos != NULL, goto out;);\r\nif (max_sdu_size != TTP_SAR_DISABLE) {\r\nIRDA_ERROR("%s(), SAR not allowed for IrCOMM!\n",\r\n__func__);\r\ngoto out;\r\n}\r\ninfo.max_data_size = irttp_get_max_seg_size(self->tsap)\r\n- IRCOMM_HEADER_SIZE;\r\ninfo.max_header_size = max_header_size + IRCOMM_HEADER_SIZE;\r\ninfo.qos = qos;\r\nircomm_do_event(self, IRCOMM_TTP_CONNECT_CONFIRM, skb, &info);\r\nout:\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void ircomm_ttp_connect_indication(void *instance, void *sap,\r\nstruct qos_info *qos,\r\n__u32 max_sdu_size,\r\n__u8 max_header_size,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ircomm_cb *self = (struct ircomm_cb *)instance;\r\nstruct ircomm_info info;\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nIRDA_ASSERT(qos != NULL, goto out;);\r\nif (max_sdu_size != TTP_SAR_DISABLE) {\r\nIRDA_ERROR("%s(), SAR not allowed for IrCOMM!\n",\r\n__func__);\r\ngoto out;\r\n}\r\ninfo.max_data_size = irttp_get_max_seg_size(self->tsap)\r\n- IRCOMM_HEADER_SIZE;\r\ninfo.max_header_size = max_header_size + IRCOMM_HEADER_SIZE;\r\ninfo.qos = qos;\r\nircomm_do_event(self, IRCOMM_TTP_CONNECT_INDICATION, skb, &info);\r\nout:\r\ndev_kfree_skb(skb);\r\n}\r\nstatic int ircomm_ttp_disconnect_request(struct ircomm_cb *self,\r\nstruct sk_buff *userdata,\r\nstruct ircomm_info *info)\r\n{\r\nint ret;\r\nif(userdata)\r\nskb_get(userdata);\r\nret = irttp_disconnect_request(self->tsap, userdata, P_NORMAL);\r\nreturn ret;\r\n}\r\nstatic void ircomm_ttp_disconnect_indication(void *instance, void *sap,\r\nLM_REASON reason,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ircomm_cb *self = (struct ircomm_cb *) instance;\r\nstruct ircomm_info info;\r\nIRDA_DEBUG(2, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_MAGIC, return;);\r\ninfo.reason = reason;\r\nircomm_do_event(self, IRCOMM_TTP_DISCONNECT_INDICATION, skb, &info);\r\nif(skb)\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void ircomm_ttp_flow_indication(void *instance, void *sap,\r\nLOCAL_FLOW cmd)\r\n{\r\nstruct ircomm_cb *self = (struct ircomm_cb *) instance;\r\nIRDA_DEBUG(4, "%s()\n", __func__ );\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IRCOMM_MAGIC, return;);\r\nif (self->notify.flow_indication)\r\nself->notify.flow_indication(self->notify.instance, self, cmd);\r\n}
