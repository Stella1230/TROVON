u32 read_macreg(struct adapter *padapter, u32 addr, u32 sz)\r\n{\r\nu32 val = 0;\r\nswitch (sz) {\r\ncase 1:\r\nval = rtw_read8(padapter, addr);\r\nbreak;\r\ncase 2:\r\nval = rtw_read16(padapter, addr);\r\nbreak;\r\ncase 4:\r\nval = rtw_read32(padapter, addr);\r\nbreak;\r\ndefault:\r\nval = 0xffffffff;\r\nbreak;\r\n}\r\nreturn val;\r\n}\r\nvoid write_macreg(struct adapter *padapter, u32 addr, u32 val, u32 sz)\r\n{\r\nswitch (sz) {\r\ncase 1:\r\nrtw_write8(padapter, addr, (u8)val);\r\nbreak;\r\ncase 2:\r\nrtw_write16(padapter, addr, (u16)val);\r\nbreak;\r\ncase 4:\r\nrtw_write32(padapter, addr, val);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nu32 read_bbreg(struct adapter *padapter, u32 addr, u32 bitmask)\r\n{\r\nreturn rtw_hal_read_bbreg(padapter, addr, bitmask);\r\n}\r\nvoid write_bbreg(struct adapter *padapter, u32 addr, u32 bitmask, u32 val)\r\n{\r\nrtw_hal_write_bbreg(padapter, addr, bitmask, val);\r\n}\r\nu32 _read_rfreg(struct adapter *padapter, u8 rfpath, u32 addr, u32 bitmask)\r\n{\r\nreturn rtw_hal_read_rfreg(padapter, (enum rf_radio_path)rfpath, addr, bitmask);\r\n}\r\nvoid _write_rfreg(struct adapter *padapter, u8 rfpath, u32 addr, u32 bitmask, u32 val)\r\n{\r\nrtw_hal_write_rfreg(padapter, (enum rf_radio_path)rfpath, addr, bitmask, val);\r\n}\r\nu32 read_rfreg(struct adapter *padapter, u8 rfpath, u32 addr)\r\n{\r\nreturn _read_rfreg(padapter, (enum rf_radio_path)rfpath, addr, bRFRegOffsetMask);\r\n}\r\nvoid write_rfreg(struct adapter *padapter, u8 rfpath, u32 addr, u32 val)\r\n{\r\n_write_rfreg(padapter, (enum rf_radio_path)rfpath, addr, bRFRegOffsetMask, val);\r\n}\r\nstatic void _init_mp_priv_(struct mp_priv *pmp_priv)\r\n{\r\nstruct wlan_bssid_ex *pnetwork;\r\n_rtw_memset(pmp_priv, 0, sizeof(struct mp_priv));\r\npmp_priv->mode = MP_OFF;\r\npmp_priv->channel = 1;\r\npmp_priv->bandwidth = HT_CHANNEL_WIDTH_20;\r\npmp_priv->prime_channel_offset = HAL_PRIME_CHNL_OFFSET_DONT_CARE;\r\npmp_priv->rateidx = MPT_RATE_1M;\r\npmp_priv->txpoweridx = 0x2A;\r\npmp_priv->antenna_tx = ANTENNA_A;\r\npmp_priv->antenna_rx = ANTENNA_AB;\r\npmp_priv->check_mp_pkt = 0;\r\npmp_priv->tx_pktcount = 0;\r\npmp_priv->rx_pktcount = 0;\r\npmp_priv->rx_crcerrpktcount = 0;\r\npmp_priv->network_macaddr[0] = 0x00;\r\npmp_priv->network_macaddr[1] = 0xE0;\r\npmp_priv->network_macaddr[2] = 0x4C;\r\npmp_priv->network_macaddr[3] = 0x87;\r\npmp_priv->network_macaddr[4] = 0x66;\r\npmp_priv->network_macaddr[5] = 0x55;\r\npnetwork = &pmp_priv->mp_network.network;\r\nmemcpy(pnetwork->MacAddress, pmp_priv->network_macaddr, ETH_ALEN);\r\npnetwork->Ssid.SsidLength = 8;\r\nmemcpy(pnetwork->Ssid.Ssid, "mp_871x", pnetwork->Ssid.SsidLength);\r\n}\r\nstatic void mp_init_xmit_attrib(struct mp_tx *pmptx, struct adapter *padapter)\r\n{\r\nstruct pkt_attrib *pattrib;\r\nstruct tx_desc *desc;\r\npattrib = &pmptx->attrib;\r\n_rtw_memset(pattrib, 0, sizeof(struct pkt_attrib));\r\ndesc = &pmptx->desc;\r\n_rtw_memset(desc, 0, TXDESC_SIZE);\r\npattrib->ether_type = 0x8712;\r\n_rtw_memset(pattrib->dst, 0xFF, ETH_ALEN);\r\npattrib->ack_policy = 0;\r\npattrib->hdrlen = WLAN_HDR_A3_LEN;\r\npattrib->subtype = WIFI_DATA;\r\npattrib->priority = 0;\r\npattrib->qsel = pattrib->priority;\r\npattrib->nr_frags = 1;\r\npattrib->encrypt = 0;\r\npattrib->bswenc = false;\r\npattrib->qos_en = false;\r\n}\r\ns32 init_mp_priv(struct adapter *padapter)\r\n{\r\nstruct mp_priv *pmppriv = &padapter->mppriv;\r\n_init_mp_priv_(pmppriv);\r\npmppriv->papdater = padapter;\r\npmppriv->tx.stop = 1;\r\nmp_init_xmit_attrib(&pmppriv->tx, padapter);\r\nswitch (padapter->registrypriv.rf_config) {\r\ncase RF_1T1R:\r\npmppriv->antenna_tx = ANTENNA_A;\r\npmppriv->antenna_rx = ANTENNA_A;\r\nbreak;\r\ncase RF_1T2R:\r\ndefault:\r\npmppriv->antenna_tx = ANTENNA_A;\r\npmppriv->antenna_rx = ANTENNA_AB;\r\nbreak;\r\ncase RF_2T2R:\r\ncase RF_2T2R_GREEN:\r\npmppriv->antenna_tx = ANTENNA_AB;\r\npmppriv->antenna_rx = ANTENNA_AB;\r\nbreak;\r\ncase RF_2T4R:\r\npmppriv->antenna_tx = ANTENNA_AB;\r\npmppriv->antenna_rx = ANTENNA_ABCD;\r\nbreak;\r\n}\r\nreturn _SUCCESS;\r\n}\r\nvoid free_mp_priv(struct mp_priv *pmp_priv)\r\n{\r\nkfree(pmp_priv->pallocated_mp_xmitframe_buf);\r\npmp_priv->pallocated_mp_xmitframe_buf = NULL;\r\npmp_priv->pmp_xmtframe_buf = NULL;\r\n}\r\ns32 MPT_InitializeAdapter(struct adapter *pAdapter, u8 Channel)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(pAdapter);\r\ns32 rtStatus = _SUCCESS;\r\nstruct mpt_context *pMptCtx = &pAdapter->mppriv.MptCtx;\r\nstruct mlme_priv *pmlmepriv = &pAdapter->mlmepriv;\r\npMptCtx->bMptDrvUnload = false;\r\npMptCtx->bMassProdTest = false;\r\npMptCtx->bMptIndexEven = true;\r\npMptCtx->h2cReqNum = 0x0;\r\npMptCtx->bMptWorkItemInProgress = false;\r\npMptCtx->CurrMptAct = NULL;\r\nrtw_write32(pAdapter, REG_RCR, 0);\r\nPHY_IQCalibrate(pAdapter, false);\r\ndm_CheckTXPowerTracking(&pHalData->odmpriv);\r\nPHY_LCCalibrate(pAdapter);\r\npMptCtx->backup0xc50 = (u8)PHY_QueryBBReg(pAdapter, rOFDM0_XAAGCCore1, bMaskByte0);\r\npMptCtx->backup0xc58 = (u8)PHY_QueryBBReg(pAdapter, rOFDM0_XBAGCCore1, bMaskByte0);\r\npMptCtx->backup0xc30 = (u8)PHY_QueryBBReg(pAdapter, rOFDM0_RxDetector1, bMaskByte0);\r\npMptCtx->backup0x52_RF_A = (u8)PHY_QueryRFReg(pAdapter, RF_PATH_A, RF_0x52, 0x000F0);\r\npMptCtx->backup0x52_RF_B = (u8)PHY_QueryRFReg(pAdapter, RF_PATH_A, RF_0x52, 0x000F0);\r\nrtw_write16(pAdapter, 0x870, 0x300);\r\nrtw_write16(pAdapter, 0x860, 0x110);\r\nif (pAdapter->registrypriv.mp_mode == 1)\r\npmlmepriv->fw_state = WIFI_MP_STATE;\r\nreturn rtStatus;\r\n}\r\nvoid MPT_DeInitAdapter(struct adapter *pAdapter)\r\n{\r\nstruct mpt_context *pMptCtx = &pAdapter->mppriv.MptCtx;\r\npMptCtx->bMptDrvUnload = true;\r\n}\r\nstatic u8 mpt_ProStartTest(struct adapter *padapter)\r\n{\r\nstruct mpt_context *pMptCtx = &padapter->mppriv.MptCtx;\r\npMptCtx->bMassProdTest = true;\r\npMptCtx->bStartContTx = false;\r\npMptCtx->bCckContTx = false;\r\npMptCtx->bOfdmContTx = false;\r\npMptCtx->bSingleCarrier = false;\r\npMptCtx->bCarrierSuppression = false;\r\npMptCtx->bSingleTone = false;\r\nreturn _SUCCESS;\r\n}\r\ns32 SetPowerTracking(struct adapter *padapter, u8 enable)\r\n{\r\nHal_SetPowerTracking(padapter, enable);\r\nreturn 0;\r\n}\r\nvoid GetPowerTracking(struct adapter *padapter, u8 *enable)\r\n{\r\nHal_GetPowerTracking(padapter, enable);\r\n}\r\nstatic void disable_dm(struct adapter *padapter)\r\n{\r\nu8 v8;\r\nv8 = rtw_read8(padapter, REG_BCN_CTRL);\r\nv8 &= ~EN_BCN_FUNCTION;\r\nrtw_write8(padapter, REG_BCN_CTRL, v8);\r\nSwitch_DM_Func(padapter, DYNAMIC_FUNC_DISABLE, false);\r\nSwitch_DM_Func(padapter, DYNAMIC_RF_CALIBRATION, true);\r\n}\r\ns32 mp_start_test(struct adapter *padapter)\r\n{\r\nstruct wlan_bssid_ex bssid;\r\nstruct sta_info *psta;\r\nu32 length;\r\nu8 val8;\r\nunsigned long irqL;\r\ns32 res = _SUCCESS;\r\nstruct mp_priv *pmppriv = &padapter->mppriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_network *tgt_network = &pmlmepriv->cur_network;\r\npadapter->registrypriv.mp_mode = 1;\r\npmppriv->bSetTxPower = 0;\r\ndisable_dm(padapter);\r\nif (padapter->registrypriv.rf_config == RF_819X_MAX_TYPE) {\r\nswitch (GET_RF_TYPE(padapter)) {\r\ncase RF_1T1R:\r\npmppriv->antenna_tx = ANTENNA_A;\r\npmppriv->antenna_rx = ANTENNA_A;\r\nbreak;\r\ncase RF_1T2R:\r\ndefault:\r\npmppriv->antenna_tx = ANTENNA_A;\r\npmppriv->antenna_rx = ANTENNA_AB;\r\nbreak;\r\ncase RF_2T2R:\r\ncase RF_2T2R_GREEN:\r\npmppriv->antenna_tx = ANTENNA_AB;\r\npmppriv->antenna_rx = ANTENNA_AB;\r\nbreak;\r\ncase RF_2T4R:\r\npmppriv->antenna_tx = ANTENNA_AB;\r\npmppriv->antenna_rx = ANTENNA_ABCD;\r\nbreak;\r\n}\r\n}\r\nmpt_ProStartTest(padapter);\r\nmemcpy(bssid.MacAddress, pmppriv->network_macaddr, ETH_ALEN);\r\nbssid.Ssid.SsidLength = strlen("mp_pseudo_adhoc");\r\nmemcpy(bssid.Ssid.Ssid, (u8 *)"mp_pseudo_adhoc", bssid.Ssid.SsidLength);\r\nbssid.InfrastructureMode = Ndis802_11IBSS;\r\nbssid.NetworkTypeInUse = Ndis802_11DS;\r\nbssid.IELength = 0;\r\nlength = get_wlan_bssid_ex_sz(&bssid);\r\nif (length % 4)\r\nbssid.Length = ((length >> 2) + 1) << 2;\r\nelse\r\nbssid.Length = length;\r\n_enter_critical_bh(&pmlmepriv->lock, &irqL);\r\nif (check_fwstate(pmlmepriv, WIFI_MP_STATE) == true)\r\ngoto end_of_mp_start_test;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == true) {\r\nrtw_disassoc_cmd(padapter, 500, true);\r\nrtw_indicate_disconnect(padapter);\r\nrtw_free_assoc_resources(padapter, 1);\r\n}\r\npmppriv->prev_fw_state = get_fwstate(pmlmepriv);\r\nif (padapter->registrypriv.mp_mode == 1)\r\npmlmepriv->fw_state = WIFI_MP_STATE;\r\nset_fwstate(pmlmepriv, _FW_UNDER_LINKING);\r\npsta = rtw_get_stainfo(&padapter->stapriv, tgt_network->network.MacAddress);\r\nif (psta)\r\nrtw_free_stainfo(padapter, psta);\r\npsta = rtw_alloc_stainfo(&padapter->stapriv, bssid.MacAddress);\r\nif (psta == NULL) {\r\nRT_TRACE(_module_mp_, _drv_err_, ("mp_start_test: Can't alloc sta_info!\n"));\r\npmlmepriv->fw_state = pmppriv->prev_fw_state;\r\nres = _FAIL;\r\ngoto end_of_mp_start_test;\r\n}\r\ntgt_network->join_res = 1;\r\ntgt_network->aid = 1;\r\npsta->aid = 1;\r\nmemcpy(&tgt_network->network, &bssid, length);\r\nrtw_indicate_connect(padapter);\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\r\nend_of_mp_start_test:\r\n_exit_critical_bh(&pmlmepriv->lock, &irqL);\r\nif (res == _SUCCESS) {\r\nval8 = rtw_read8(padapter, MSR) & 0xFC;\r\nval8 |= WIFI_FW_ADHOC_STATE;\r\nrtw_write8(padapter, MSR, val8);\r\n}\r\nreturn res;\r\n}\r\nvoid mp_stop_test(struct adapter *padapter)\r\n{\r\nstruct mp_priv *pmppriv = &padapter->mppriv;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct wlan_network *tgt_network = &pmlmepriv->cur_network;\r\nstruct sta_info *psta;\r\nunsigned long irqL;\r\nif (pmppriv->mode == MP_ON) {\r\npmppriv->bSetTxPower = 0;\r\n_enter_critical_bh(&pmlmepriv->lock, &irqL);\r\nif (check_fwstate(pmlmepriv, WIFI_MP_STATE) == false)\r\ngoto end_of_mp_stop_test;\r\nrtw_indicate_disconnect(padapter);\r\npsta = rtw_get_stainfo(&padapter->stapriv, tgt_network->network.MacAddress);\r\nif (psta)\r\nrtw_free_stainfo(padapter, psta);\r\npmlmepriv->fw_state = pmppriv->prev_fw_state;\r\n_rtw_memset(tgt_network, 0, sizeof(struct wlan_network));\r\n_clr_fwstate_(pmlmepriv, WIFI_MP_STATE);\r\nend_of_mp_stop_test:\r\n_exit_critical_bh(&pmlmepriv->lock, &irqL);\r\n}\r\n}\r\nvoid SetChannel(struct adapter *pAdapter)\r\n{\r\nHal_SetChannel(pAdapter);\r\n}\r\nvoid SetBandwidth(struct adapter *pAdapter)\r\n{\r\nHal_SetBandwidth(pAdapter);\r\n}\r\nvoid SetAntenna(struct adapter *pAdapter)\r\n{\r\nHal_SetAntenna(pAdapter);\r\n}\r\nvoid SetAntennaPathPower(struct adapter *pAdapter)\r\n{\r\nHal_SetAntennaPathPower(pAdapter);\r\n}\r\nvoid SetTxPower(struct adapter *pAdapter)\r\n{\r\nHal_SetTxPower(pAdapter);\r\n}\r\nvoid SetDataRate(struct adapter *pAdapter)\r\n{\r\nHal_SetDataRate(pAdapter);\r\n}\r\nvoid MP_PHY_SetRFPathSwitch(struct adapter *pAdapter , bool bMain)\r\n{\r\nPHY_SetRFPathSwitch(pAdapter, bMain);\r\n}\r\ns32 SetThermalMeter(struct adapter *pAdapter, u8 target_ther)\r\n{\r\nreturn Hal_SetThermalMeter(pAdapter, target_ther);\r\n}\r\nvoid GetThermalMeter(struct adapter *pAdapter, u8 *value)\r\n{\r\nHal_GetThermalMeter(pAdapter, value);\r\n}\r\nvoid SetSingleCarrierTx(struct adapter *pAdapter, u8 bStart)\r\n{\r\nPhySetTxPowerLevel(pAdapter);\r\nHal_SetSingleCarrierTx(pAdapter, bStart);\r\n}\r\nvoid SetSingleToneTx(struct adapter *pAdapter, u8 bStart)\r\n{\r\nPhySetTxPowerLevel(pAdapter);\r\nHal_SetSingleToneTx(pAdapter, bStart);\r\n}\r\nvoid SetCarrierSuppressionTx(struct adapter *pAdapter, u8 bStart)\r\n{\r\nPhySetTxPowerLevel(pAdapter);\r\nHal_SetCarrierSuppressionTx(pAdapter, bStart);\r\n}\r\nvoid SetContinuousTx(struct adapter *pAdapter, u8 bStart)\r\n{\r\nPhySetTxPowerLevel(pAdapter);\r\nHal_SetContinuousTx(pAdapter, bStart);\r\n}\r\nvoid PhySetTxPowerLevel(struct adapter *pAdapter)\r\n{\r\nstruct mp_priv *pmp_priv = &pAdapter->mppriv;\r\nif (pmp_priv->bSetTxPower == 0)\r\nPHY_SetTxPowerLevel8188E(pAdapter, pmp_priv->channel);\r\n}\r\nstatic void dump_mpframe(struct adapter *padapter, struct xmit_frame *pmpframe)\r\n{\r\nrtw_hal_mgnt_xmit(padapter, pmpframe);\r\n}\r\nstatic struct xmit_frame *alloc_mp_xmitframe(struct xmit_priv *pxmitpriv)\r\n{\r\nstruct xmit_frame *pmpframe;\r\nstruct xmit_buf *pxmitbuf;\r\npmpframe = rtw_alloc_xmitframe(pxmitpriv);\r\nif (pmpframe == NULL)\r\nreturn NULL;\r\npxmitbuf = rtw_alloc_xmitbuf(pxmitpriv);\r\nif (pxmitbuf == NULL) {\r\nrtw_free_xmitframe(pxmitpriv, pmpframe);\r\nreturn NULL;\r\n}\r\npmpframe->frame_tag = MP_FRAMETAG;\r\npmpframe->pxmitbuf = pxmitbuf;\r\npmpframe->buf_addr = pxmitbuf->pbuf;\r\npxmitbuf->priv_data = pmpframe;\r\nreturn pmpframe;\r\n}\r\nstatic int mp_xmit_packet_thread(void *context)\r\n{\r\nstruct xmit_frame *pxmitframe;\r\nstruct mp_tx *pmptx;\r\nstruct mp_priv *pmp_priv;\r\nstruct xmit_priv *pxmitpriv;\r\nstruct adapter *padapter;\r\npmp_priv = (struct mp_priv *)context;\r\npmptx = &pmp_priv->tx;\r\npadapter = pmp_priv->papdater;\r\npxmitpriv = &(padapter->xmitpriv);\r\nthread_enter("RTW_MP_THREAD");\r\nwhile (1) {\r\npxmitframe = alloc_mp_xmitframe(pxmitpriv);\r\nif (pxmitframe == NULL) {\r\nif (pmptx->stop ||\r\npadapter->bSurpriseRemoved ||\r\npadapter->bDriverStopped) {\r\ngoto exit;\r\n} else {\r\nrtw_msleep_os(1);\r\ncontinue;\r\n}\r\n}\r\nmemcpy((u8 *)(pxmitframe->buf_addr+TXDESC_OFFSET), pmptx->buf, pmptx->write_size);\r\nmemcpy(&(pxmitframe->attrib), &(pmptx->attrib), sizeof(struct pkt_attrib));\r\ndump_mpframe(padapter, pxmitframe);\r\npmptx->sended++;\r\npmp_priv->tx_pktcount++;\r\nif (pmptx->stop ||\r\npadapter->bSurpriseRemoved ||\r\npadapter->bDriverStopped)\r\ngoto exit;\r\nif ((pmptx->count != 0) &&\r\n(pmptx->count == pmptx->sended))\r\ngoto exit;\r\nflush_signals_thread();\r\n}\r\nexit:\r\nkfree(pmptx->pallocated_buf);\r\npmptx->pallocated_buf = NULL;\r\npmptx->stop = 1;\r\nthread_exit();\r\n}\r\nvoid fill_txdesc_for_mp(struct adapter *padapter, struct tx_desc *ptxdesc)\r\n{\r\nstruct mp_priv *pmp_priv = &padapter->mppriv;\r\nmemcpy(ptxdesc, &(pmp_priv->tx.desc), TXDESC_SIZE);\r\n}\r\nvoid SetPacketTx(struct adapter *padapter)\r\n{\r\nu8 *ptr, *pkt_start, *pkt_end;\r\nu32 pkt_size;\r\nstruct tx_desc *desc;\r\nstruct rtw_ieee80211_hdr *hdr;\r\nu8 payload;\r\ns32 bmcast;\r\nstruct pkt_attrib *pattrib;\r\nstruct mp_priv *pmp_priv;\r\npmp_priv = &padapter->mppriv;\r\nif (pmp_priv->tx.stop)\r\nreturn;\r\npmp_priv->tx.sended = 0;\r\npmp_priv->tx.stop = 0;\r\npmp_priv->tx_pktcount = 0;\r\npattrib = &pmp_priv->tx.attrib;\r\nmemcpy(pattrib->src, padapter->eeprompriv.mac_addr, ETH_ALEN);\r\nmemcpy(pattrib->ta, pattrib->src, ETH_ALEN);\r\nmemcpy(pattrib->ra, pattrib->dst, ETH_ALEN);\r\nbmcast = IS_MCAST(pattrib->ra);\r\nif (bmcast) {\r\npattrib->mac_id = 1;\r\npattrib->psta = rtw_get_bcmc_stainfo(padapter);\r\n} else {\r\npattrib->mac_id = 0;\r\npattrib->psta = rtw_get_stainfo(&padapter->stapriv, get_bssid(&padapter->mlmepriv));\r\n}\r\npattrib->last_txcmdsz = pattrib->hdrlen + pattrib->pktlen;\r\npkt_size = pattrib->last_txcmdsz;\r\nkfree(pmp_priv->tx.pallocated_buf);\r\npmp_priv->tx.write_size = pkt_size;\r\npmp_priv->tx.buf_size = pkt_size + XMITBUF_ALIGN_SZ;\r\npmp_priv->tx.pallocated_buf = rtw_zmalloc(pmp_priv->tx.buf_size);\r\nif (pmp_priv->tx.pallocated_buf == NULL) {\r\nDBG_88E("%s: malloc(%d) fail!!\n", __func__, pmp_priv->tx.buf_size);\r\nreturn;\r\n}\r\npmp_priv->tx.buf = (u8 *)N_BYTE_ALIGMENT((size_t)(pmp_priv->tx.pallocated_buf), XMITBUF_ALIGN_SZ);\r\nptr = pmp_priv->tx.buf;\r\ndesc = &(pmp_priv->tx.desc);\r\n_rtw_memset(desc, 0, TXDESC_SIZE);\r\npkt_start = ptr;\r\npkt_end = pkt_start + pkt_size;\r\ndesc->txdw0 |= cpu_to_le32(OWN | FSG | LSG);\r\ndesc->txdw0 |= cpu_to_le32(pkt_size & 0x0000FFFF);\r\ndesc->txdw0 |= cpu_to_le32(((TXDESC_SIZE + OFFSET_SZ) << OFFSET_SHT) & 0x00FF0000);\r\nif (bmcast)\r\ndesc->txdw0 |= cpu_to_le32(BMC);\r\ndesc->txdw1 |= cpu_to_le32((0x01 << 26) & 0xff000000);\r\ndesc->txdw1 |= cpu_to_le32((pattrib->mac_id) & 0x3F);\r\ndesc->txdw1 |= cpu_to_le32((pattrib->qsel << QSEL_SHT) & 0x00001F00);\r\ndesc->txdw1 |= cpu_to_le32((pattrib->raid << RATE_ID_SHT) & 0x000F0000);\r\ndesc->txdw3 |= cpu_to_le32((pattrib->seqnum<<16)&0x0fff0000);\r\ndesc->txdw4 |= cpu_to_le32(HW_SSN);\r\ndesc->txdw4 |= cpu_to_le32(USERATE);\r\ndesc->txdw4 |= cpu_to_le32(DISDATAFB);\r\nif (pmp_priv->preamble) {\r\nif (pmp_priv->rateidx <= MPT_RATE_54M)\r\ndesc->txdw4 |= cpu_to_le32(DATA_SHORT);\r\n}\r\nif (pmp_priv->bandwidth == HT_CHANNEL_WIDTH_40)\r\ndesc->txdw4 |= cpu_to_le32(DATA_BW);\r\ndesc->txdw5 |= cpu_to_le32(pmp_priv->rateidx & 0x0000001F);\r\nif (pmp_priv->preamble) {\r\nif (pmp_priv->rateidx > MPT_RATE_54M)\r\ndesc->txdw5 |= cpu_to_le32(SGI);\r\n}\r\ndesc->txdw5 |= cpu_to_le32(RTY_LMT_EN);\r\ndesc->txdw5 |= cpu_to_le32(0x00180000);\r\nhdr = (struct rtw_ieee80211_hdr *)pkt_start;\r\nSetFrameSubType(&hdr->frame_ctl, pattrib->subtype);\r\nmemcpy(hdr->addr1, pattrib->dst, ETH_ALEN);\r\nmemcpy(hdr->addr2, pattrib->src, ETH_ALEN);\r\nmemcpy(hdr->addr3, get_bssid(&padapter->mlmepriv), ETH_ALEN);\r\nptr = pkt_start + pattrib->hdrlen;\r\nswitch (pmp_priv->tx.payload) {\r\ncase 0:\r\npayload = 0x00;\r\nbreak;\r\ncase 1:\r\npayload = 0x5a;\r\nbreak;\r\ncase 2:\r\npayload = 0xa5;\r\nbreak;\r\ncase 3:\r\npayload = 0xff;\r\nbreak;\r\ndefault:\r\npayload = 0x00;\r\nbreak;\r\n}\r\n_rtw_memset(ptr, payload, pkt_end - ptr);\r\npmp_priv->tx.PktTxThread = kthread_run(mp_xmit_packet_thread, pmp_priv, "RTW_MP_THREAD");\r\nif (IS_ERR(pmp_priv->tx.PktTxThread))\r\nDBG_88E("Create PktTx Thread Fail !!!!!\n");\r\n}\r\nvoid SetPacketRx(struct adapter *pAdapter, u8 bStartRx)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(pAdapter);\r\nif (bStartRx) {\r\npHalData->ReceiveConfig = AAP | APM | AM | AB | APP_ICV | ADF | AMF | HTC_LOC_CTRL | APP_MIC | APP_PHYSTS;\r\npHalData->ReceiveConfig |= ACRC32;\r\nrtw_write32(pAdapter, REG_RCR, pHalData->ReceiveConfig);\r\nrtw_write16(pAdapter, REG_RXFLTMAP2, 0xFFFF);\r\n} else {\r\nrtw_write32(pAdapter, REG_RCR, 0);\r\n}\r\n}\r\nvoid ResetPhyRxPktCount(struct adapter *pAdapter)\r\n{\r\nu32 i, phyrx_set = 0;\r\nfor (i = 0; i <= 0xF; i++) {\r\nphyrx_set = 0;\r\nphyrx_set |= _RXERR_RPT_SEL(i);\r\nphyrx_set |= RXERR_RPT_RST;\r\nrtw_write32(pAdapter, REG_RXERR_RPT, phyrx_set);\r\n}\r\n}\r\nstatic u32 GetPhyRxPktCounts(struct adapter *pAdapter, u32 selbit)\r\n{\r\nu32 phyrx_set = 0, count = 0;\r\nphyrx_set = _RXERR_RPT_SEL(selbit & 0xF);\r\nrtw_write32(pAdapter, REG_RXERR_RPT, phyrx_set);\r\ncount = rtw_read32(pAdapter, REG_RXERR_RPT) & RXERR_COUNTER_MASK;\r\nreturn count;\r\n}\r\nu32 GetPhyRxPktReceived(struct adapter *pAdapter)\r\n{\r\nu32 OFDM_cnt = 0, CCK_cnt = 0, HT_cnt = 0;\r\nOFDM_cnt = GetPhyRxPktCounts(pAdapter, RXERR_TYPE_OFDM_MPDU_OK);\r\nCCK_cnt = GetPhyRxPktCounts(pAdapter, RXERR_TYPE_CCK_MPDU_OK);\r\nHT_cnt = GetPhyRxPktCounts(pAdapter, RXERR_TYPE_HT_MPDU_OK);\r\nreturn OFDM_cnt + CCK_cnt + HT_cnt;\r\n}\r\nu32 GetPhyRxPktCRC32Error(struct adapter *pAdapter)\r\n{\r\nu32 OFDM_cnt = 0, CCK_cnt = 0, HT_cnt = 0;\r\nOFDM_cnt = GetPhyRxPktCounts(pAdapter, RXERR_TYPE_OFDM_MPDU_FAIL);\r\nCCK_cnt = GetPhyRxPktCounts(pAdapter, RXERR_TYPE_CCK_MPDU_FAIL);\r\nHT_cnt = GetPhyRxPktCounts(pAdapter, RXERR_TYPE_HT_MPDU_FAIL);\r\nreturn OFDM_cnt + CCK_cnt + HT_cnt;\r\n}\r\nstatic u32 rtw_GetPSDData(struct adapter *pAdapter, u32 point)\r\n{\r\nint psd_val;\r\npsd_val = rtw_read32(pAdapter, 0x808);\r\npsd_val &= 0xFFBFFC00;\r\npsd_val |= point;\r\nrtw_write32(pAdapter, 0x808, psd_val);\r\nrtw_mdelay_os(1);\r\npsd_val |= 0x00400000;\r\nrtw_write32(pAdapter, 0x808, psd_val);\r\nrtw_mdelay_os(1);\r\npsd_val = rtw_read32(pAdapter, 0x8B4);\r\npsd_val &= 0x0000FFFF;\r\nreturn psd_val;\r\n}\r\nu32 mp_query_psd(struct adapter *pAdapter, u8 *data)\r\n{\r\nu32 i, psd_pts = 0, psd_start = 0, psd_stop = 0;\r\nu32 psd_data = 0;\r\nif (!netif_running(pAdapter->pnetdev)) {\r\nRT_TRACE(_module_mp_, _drv_warning_, ("mp_query_psd: Fail! interface not opened!\n"));\r\nreturn 0;\r\n}\r\nif (check_fwstate(&pAdapter->mlmepriv, WIFI_MP_STATE) == false) {\r\nRT_TRACE(_module_mp_, _drv_warning_, ("mp_query_psd: Fail! not in MP mode!\n"));\r\nreturn 0;\r\n}\r\nif (strlen(data) == 0) {\r\npsd_pts = 128;\r\npsd_start = 64;\r\npsd_stop = 128;\r\n} else {\r\nsscanf(data, "pts =%d, start =%d, stop =%d", &psd_pts, &psd_start, &psd_stop);\r\n}\r\n_rtw_memset(data, '\0', sizeof(*data));\r\ni = psd_start;\r\nwhile (i < psd_stop) {\r\nif (i >= psd_pts) {\r\npsd_data = rtw_GetPSDData(pAdapter, i-psd_pts);\r\n} else {\r\npsd_data = rtw_GetPSDData(pAdapter, i);\r\n}\r\nsprintf(data, "%s%x ", data, psd_data);\r\ni++;\r\n}\r\nrtw_msleep_os(100);\r\nreturn strlen(data)+1;\r\n}\r\nvoid _rtw_mp_xmit_priv(struct xmit_priv *pxmitpriv)\r\n{\r\nint i, res;\r\nstruct adapter *padapter = pxmitpriv->adapter;\r\nstruct xmit_buf *pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf;\r\nu32 max_xmit_extbuf_size = MAX_XMIT_EXTBUF_SZ;\r\nu32 num_xmit_extbuf = NR_XMIT_EXTBUFF;\r\nif (padapter->registrypriv.mp_mode == 0) {\r\nmax_xmit_extbuf_size = MAX_XMIT_EXTBUF_SZ;\r\nnum_xmit_extbuf = NR_XMIT_EXTBUFF;\r\n} else {\r\nmax_xmit_extbuf_size = 20000;\r\nnum_xmit_extbuf = 1;\r\n}\r\npxmitbuf = (struct xmit_buf *)pxmitpriv->pxmit_extbuf;\r\nfor (i = 0; i < num_xmit_extbuf; i++) {\r\nrtw_os_xmit_resource_free(padapter, pxmitbuf, (max_xmit_extbuf_size + XMITBUF_ALIGN_SZ));\r\npxmitbuf++;\r\n}\r\nif (pxmitpriv->pallocated_xmit_extbuf)\r\nrtw_vmfree(pxmitpriv->pallocated_xmit_extbuf, num_xmit_extbuf * sizeof(struct xmit_buf) + 4);\r\nif (padapter->registrypriv.mp_mode == 0) {\r\nmax_xmit_extbuf_size = 20000;\r\nnum_xmit_extbuf = 1;\r\n} else {\r\nmax_xmit_extbuf_size = MAX_XMIT_EXTBUF_SZ;\r\nnum_xmit_extbuf = NR_XMIT_EXTBUFF;\r\n}\r\n_rtw_init_queue(&pxmitpriv->free_xmit_extbuf_queue);\r\npxmitpriv->pallocated_xmit_extbuf = rtw_zvmalloc(num_xmit_extbuf * sizeof(struct xmit_buf) + 4);\r\nif (pxmitpriv->pallocated_xmit_extbuf == NULL) {\r\nRT_TRACE(_module_rtl871x_xmit_c_, _drv_err_, ("alloc xmit_extbuf fail!\n"));\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\npxmitpriv->pxmit_extbuf = (u8 *)N_BYTE_ALIGMENT((size_t)(pxmitpriv->pallocated_xmit_extbuf), 4);\r\npxmitbuf = (struct xmit_buf *)pxmitpriv->pxmit_extbuf;\r\nfor (i = 0; i < num_xmit_extbuf; i++) {\r\n_rtw_init_listhead(&pxmitbuf->list);\r\npxmitbuf->priv_data = NULL;\r\npxmitbuf->padapter = padapter;\r\npxmitbuf->ext_tag = true;\r\nres = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, max_xmit_extbuf_size + XMITBUF_ALIGN_SZ);\r\nif (res == _FAIL) {\r\nres = _FAIL;\r\ngoto exit;\r\n}\r\nrtw_list_insert_tail(&pxmitbuf->list, &(pxmitpriv->free_xmit_extbuf_queue.queue));\r\npxmitbuf++;\r\n}\r\npxmitpriv->free_xmit_extbuf_cnt = num_xmit_extbuf;\r\nexit:\r\n;\r\n}
