uint32_t pipe2vbl(struct drm_crtc *crtc)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nreturn dispc_mgr_get_vsync_irq(omap_crtc->channel);\r\n}\r\nstatic int omap_crtc_connect(struct omap_overlay_manager *mgr,\r\nstruct omap_dss_device *dst)\r\n{\r\nif (mgr->output)\r\nreturn -EINVAL;\r\nif ((mgr->supported_outputs & dst->id) == 0)\r\nreturn -EINVAL;\r\ndst->manager = mgr;\r\nmgr->output = dst;\r\nreturn 0;\r\n}\r\nstatic void omap_crtc_disconnect(struct omap_overlay_manager *mgr,\r\nstruct omap_dss_device *dst)\r\n{\r\nmgr->output->manager = NULL;\r\nmgr->output = NULL;\r\n}\r\nstatic void omap_crtc_start_update(struct omap_overlay_manager *mgr)\r\n{\r\n}\r\nstatic int omap_crtc_enable(struct omap_overlay_manager *mgr)\r\n{\r\nreturn 0;\r\n}\r\nstatic void omap_crtc_disable(struct omap_overlay_manager *mgr)\r\n{\r\n}\r\nstatic void omap_crtc_set_timings(struct omap_overlay_manager *mgr,\r\nconst struct omap_video_timings *timings)\r\n{\r\nstruct omap_crtc *omap_crtc = omap_crtcs[mgr->id];\r\nDBG("%s", omap_crtc->name);\r\nomap_crtc->timings = *timings;\r\nomap_crtc->full_update = true;\r\n}\r\nstatic void omap_crtc_set_lcd_config(struct omap_overlay_manager *mgr,\r\nconst struct dss_lcd_mgr_config *config)\r\n{\r\nstruct omap_crtc *omap_crtc = omap_crtcs[mgr->id];\r\nDBG("%s", omap_crtc->name);\r\ndispc_mgr_set_lcd_config(omap_crtc->channel, config);\r\n}\r\nstatic int omap_crtc_register_framedone_handler(\r\nstruct omap_overlay_manager *mgr,\r\nvoid (*handler)(void *), void *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic void omap_crtc_unregister_framedone_handler(\r\nstruct omap_overlay_manager *mgr,\r\nvoid (*handler)(void *), void *data)\r\n{\r\n}\r\nstatic void omap_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nDBG("%s", omap_crtc->name);\r\nWARN_ON(omap_crtc->apply_irq.registered);\r\nomap_irq_unregister(crtc->dev, &omap_crtc->error_irq);\r\nomap_crtc->plane->funcs->destroy(omap_crtc->plane);\r\ndrm_crtc_cleanup(crtc);\r\nkfree(omap_crtc);\r\n}\r\nstatic void omap_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct omap_drm_private *priv = crtc->dev->dev_private;\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nbool enabled = (mode == DRM_MODE_DPMS_ON);\r\nint i;\r\nDBG("%s: %d", omap_crtc->name, mode);\r\nif (enabled != omap_crtc->enabled) {\r\nomap_crtc->enabled = enabled;\r\nomap_crtc->full_update = true;\r\nomap_crtc_apply(crtc, &omap_crtc->apply);\r\nWARN_ON(omap_plane_dpms(omap_crtc->plane, mode));\r\nfor (i = 0; i < priv->num_planes; i++) {\r\nstruct drm_plane *plane = priv->planes[i];\r\nif (plane->crtc == crtc)\r\nWARN_ON(omap_plane_dpms(plane, mode));\r\n}\r\n}\r\n}\r\nstatic bool omap_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic int omap_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nmode = adjusted_mode;\r\nDBG("%s: set mode: %d:\"%s\" %d %d %d %d %d %d %d %d %d %d 0x%x 0x%x",\r\nomap_crtc->name, mode->base.id, mode->name,\r\nmode->vrefresh, mode->clock,\r\nmode->hdisplay, mode->hsync_start,\r\nmode->hsync_end, mode->htotal,\r\nmode->vdisplay, mode->vsync_start,\r\nmode->vsync_end, mode->vtotal,\r\nmode->type, mode->flags);\r\ncopy_timings_drm_to_omap(&omap_crtc->timings, mode);\r\nomap_crtc->full_update = true;\r\nreturn omap_plane_mode_set(omap_crtc->plane, crtc, crtc->fb,\r\n0, 0, mode->hdisplay, mode->vdisplay,\r\nx << 16, y << 16,\r\nmode->hdisplay << 16, mode->vdisplay << 16,\r\nNULL, NULL);\r\n}\r\nstatic void omap_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nDBG("%s", omap_crtc->name);\r\nomap_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);\r\n}\r\nstatic void omap_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nDBG("%s", omap_crtc->name);\r\nomap_crtc_dpms(crtc, DRM_MODE_DPMS_ON);\r\n}\r\nstatic int omap_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nstruct drm_plane *plane = omap_crtc->plane;\r\nstruct drm_display_mode *mode = &crtc->mode;\r\nreturn omap_plane_mode_set(plane, crtc, crtc->fb,\r\n0, 0, mode->hdisplay, mode->vdisplay,\r\nx << 16, y << 16,\r\nmode->hdisplay << 16, mode->vdisplay << 16,\r\nNULL, NULL);\r\n}\r\nstatic void vblank_cb(void *arg)\r\n{\r\nstruct drm_crtc *crtc = arg;\r\nstruct drm_device *dev = crtc->dev;\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nif (omap_crtc->event)\r\ndrm_send_vblank_event(dev, omap_crtc->pipe, omap_crtc->event);\r\nomap_crtc->event = NULL;\r\nomap_crtc->old_fb = NULL;\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nstatic void page_flip_worker(struct work_struct *work)\r\n{\r\nstruct omap_crtc *omap_crtc =\r\ncontainer_of(work, struct omap_crtc, page_flip_work);\r\nstruct drm_crtc *crtc = &omap_crtc->base;\r\nstruct drm_display_mode *mode = &crtc->mode;\r\nstruct drm_gem_object *bo;\r\nmutex_lock(&crtc->mutex);\r\nomap_plane_mode_set(omap_crtc->plane, crtc, crtc->fb,\r\n0, 0, mode->hdisplay, mode->vdisplay,\r\ncrtc->x << 16, crtc->y << 16,\r\nmode->hdisplay << 16, mode->vdisplay << 16,\r\nvblank_cb, crtc);\r\nmutex_unlock(&crtc->mutex);\r\nbo = omap_framebuffer_bo(crtc->fb, 0);\r\ndrm_gem_object_unreference_unlocked(bo);\r\n}\r\nstatic void page_flip_cb(void *arg)\r\n{\r\nstruct drm_crtc *crtc = arg;\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nstruct omap_drm_private *priv = crtc->dev->dev_private;\r\nqueue_work(priv->wq, &omap_crtc->page_flip_work);\r\n}\r\nstatic int omap_crtc_page_flip_locked(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nstruct drm_pending_vblank_event *event,\r\nuint32_t page_flip_flags)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nstruct drm_gem_object *bo;\r\nDBG("%d -> %d (event=%p)", crtc->fb ? crtc->fb->base.id : -1,\r\nfb->base.id, event);\r\nif (omap_crtc->old_fb) {\r\ndev_err(dev->dev, "already a pending flip\n");\r\nreturn -EINVAL;\r\n}\r\nomap_crtc->event = event;\r\ncrtc->fb = fb;\r\nbo = omap_framebuffer_bo(fb, 0);\r\ndrm_gem_object_reference(bo);\r\nomap_gem_op_async(bo, OMAP_GEM_READ, page_flip_cb, crtc);\r\nreturn 0;\r\n}\r\nstatic int omap_crtc_set_property(struct drm_crtc *crtc,\r\nstruct drm_property *property, uint64_t val)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nstruct omap_drm_private *priv = crtc->dev->dev_private;\r\nif (property == priv->rotation_prop) {\r\ncrtc->invert_dimensions =\r\n!!(val & ((1LL << DRM_ROTATE_90) | (1LL << DRM_ROTATE_270)));\r\n}\r\nreturn omap_plane_set_property(omap_crtc->plane, property, val);\r\n}\r\nconst struct omap_video_timings *omap_crtc_timings(struct drm_crtc *crtc)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nreturn &omap_crtc->timings;\r\n}\r\nenum omap_channel omap_crtc_channel(struct drm_crtc *crtc)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nreturn omap_crtc->channel;\r\n}\r\nstatic void omap_crtc_error_irq(struct omap_drm_irq *irq, uint32_t irqstatus)\r\n{\r\nstruct omap_crtc *omap_crtc =\r\ncontainer_of(irq, struct omap_crtc, error_irq);\r\nstruct drm_crtc *crtc = &omap_crtc->base;\r\nDRM_ERROR("%s: errors: %08x\n", omap_crtc->name, irqstatus);\r\nomap_irq_unregister(crtc->dev, &omap_crtc->error_irq);\r\n}\r\nstatic void omap_crtc_apply_irq(struct omap_drm_irq *irq, uint32_t irqstatus)\r\n{\r\nstruct omap_crtc *omap_crtc =\r\ncontainer_of(irq, struct omap_crtc, apply_irq);\r\nstruct drm_crtc *crtc = &omap_crtc->base;\r\nif (!omap_crtc->error_irq.registered)\r\nomap_irq_register(crtc->dev, &omap_crtc->error_irq);\r\nif (!dispc_mgr_go_busy(omap_crtc->channel)) {\r\nstruct omap_drm_private *priv =\r\ncrtc->dev->dev_private;\r\nDBG("%s: apply done", omap_crtc->name);\r\nomap_irq_unregister(crtc->dev, &omap_crtc->apply_irq);\r\nqueue_work(priv->wq, &omap_crtc->apply_work);\r\n}\r\n}\r\nstatic void apply_worker(struct work_struct *work)\r\n{\r\nstruct omap_crtc *omap_crtc =\r\ncontainer_of(work, struct omap_crtc, apply_work);\r\nstruct drm_crtc *crtc = &omap_crtc->base;\r\nstruct drm_device *dev = crtc->dev;\r\nstruct omap_drm_apply *apply, *n;\r\nbool need_apply;\r\nmutex_lock(&crtc->mutex);\r\ndispc_runtime_get();\r\nif (omap_crtc->apply_irq.registered)\r\ngoto out;\r\nlist_for_each_entry_safe(apply, n,\r\n&omap_crtc->pending_applies, pending_node) {\r\napply->post_apply(apply);\r\nlist_del(&apply->pending_node);\r\n}\r\nneed_apply = !list_empty(&omap_crtc->queued_applies);\r\nlist_for_each_entry_safe(apply, n,\r\n&omap_crtc->queued_applies, queued_node) {\r\napply->pre_apply(apply);\r\nlist_del(&apply->queued_node);\r\napply->queued = false;\r\nlist_add_tail(&apply->pending_node,\r\n&omap_crtc->pending_applies);\r\n}\r\nif (need_apply) {\r\nenum omap_channel channel = omap_crtc->channel;\r\nDBG("%s: GO", omap_crtc->name);\r\nif (dispc_mgr_is_enabled(channel)) {\r\nomap_irq_register(dev, &omap_crtc->apply_irq);\r\ndispc_mgr_go(channel);\r\n} else {\r\nstruct omap_drm_private *priv = dev->dev_private;\r\nqueue_work(priv->wq, &omap_crtc->apply_work);\r\n}\r\n}\r\nout:\r\ndispc_runtime_put();\r\nmutex_unlock(&crtc->mutex);\r\n}\r\nint omap_crtc_apply(struct drm_crtc *crtc,\r\nstruct omap_drm_apply *apply)\r\n{\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nWARN_ON(!mutex_is_locked(&crtc->mutex));\r\nif (apply->queued)\r\nreturn 0;\r\napply->queued = true;\r\nlist_add_tail(&apply->queued_node, &omap_crtc->queued_applies);\r\nif (list_empty(&omap_crtc->pending_applies)) {\r\nstruct omap_drm_private *priv = crtc->dev->dev_private;\r\nqueue_work(priv->wq, &omap_crtc->apply_work);\r\n}\r\nreturn 0;\r\n}\r\nstatic void set_enabled(struct drm_crtc *crtc, bool enable)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct omap_crtc *omap_crtc = to_omap_crtc(crtc);\r\nenum omap_channel channel = omap_crtc->channel;\r\nstruct omap_irq_wait *wait = NULL;\r\nif (dispc_mgr_is_enabled(channel) == enable)\r\nreturn;\r\nomap_irq_unregister(crtc->dev, &omap_crtc->error_irq);\r\nif (dispc_mgr_get_framedone_irq(channel)) {\r\nif (!enable) {\r\nwait = omap_irq_wait_init(dev,\r\ndispc_mgr_get_framedone_irq(channel), 1);\r\n}\r\n} else {\r\nwait = omap_irq_wait_init(dev,\r\ndispc_mgr_get_vsync_irq(channel), 2);\r\n}\r\ndispc_mgr_enable(channel, enable);\r\nif (wait) {\r\nint ret = omap_irq_wait(dev, wait, msecs_to_jiffies(100));\r\nif (ret) {\r\ndev_err(dev->dev, "%s: timeout waiting for %s\n",\r\nomap_crtc->name, enable ? "enable" : "disable");\r\n}\r\n}\r\nomap_irq_register(crtc->dev, &omap_crtc->error_irq);\r\n}\r\nstatic void omap_crtc_pre_apply(struct omap_drm_apply *apply)\r\n{\r\nstruct omap_crtc *omap_crtc =\r\ncontainer_of(apply, struct omap_crtc, apply);\r\nstruct drm_crtc *crtc = &omap_crtc->base;\r\nstruct drm_encoder *encoder = NULL;\r\nDBG("%s: enabled=%d, full=%d", omap_crtc->name,\r\nomap_crtc->enabled, omap_crtc->full_update);\r\nif (omap_crtc->full_update) {\r\nstruct omap_drm_private *priv = crtc->dev->dev_private;\r\nint i;\r\nfor (i = 0; i < priv->num_encoders; i++) {\r\nif (priv->encoders[i]->crtc == crtc) {\r\nencoder = priv->encoders[i];\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!omap_crtc->enabled) {\r\nset_enabled(&omap_crtc->base, false);\r\nif (encoder)\r\nomap_encoder_set_enabled(encoder, false);\r\n} else {\r\nif (encoder) {\r\nomap_encoder_set_enabled(encoder, false);\r\nomap_encoder_update(encoder, omap_crtc->mgr,\r\n&omap_crtc->timings);\r\nomap_encoder_set_enabled(encoder, true);\r\nomap_crtc->full_update = false;\r\n}\r\ndispc_mgr_setup(omap_crtc->channel, &omap_crtc->info);\r\ndispc_mgr_set_timings(omap_crtc->channel,\r\n&omap_crtc->timings);\r\nset_enabled(&omap_crtc->base, true);\r\n}\r\nomap_crtc->full_update = false;\r\n}\r\nstatic void omap_crtc_post_apply(struct omap_drm_apply *apply)\r\n{\r\n}\r\nvoid omap_crtc_pre_init(void)\r\n{\r\ndss_install_mgr_ops(&mgr_ops);\r\n}\r\nstruct drm_crtc *omap_crtc_init(struct drm_device *dev,\r\nstruct drm_plane *plane, enum omap_channel channel, int id)\r\n{\r\nstruct drm_crtc *crtc = NULL;\r\nstruct omap_crtc *omap_crtc;\r\nstruct omap_overlay_manager_info *info;\r\nDBG("%s", channel_names[channel]);\r\nomap_crtc = kzalloc(sizeof(*omap_crtc), GFP_KERNEL);\r\nif (!omap_crtc)\r\ngoto fail;\r\ncrtc = &omap_crtc->base;\r\nINIT_WORK(&omap_crtc->page_flip_work, page_flip_worker);\r\nINIT_WORK(&omap_crtc->apply_work, apply_worker);\r\nINIT_LIST_HEAD(&omap_crtc->pending_applies);\r\nINIT_LIST_HEAD(&omap_crtc->queued_applies);\r\nomap_crtc->apply.pre_apply = omap_crtc_pre_apply;\r\nomap_crtc->apply.post_apply = omap_crtc_post_apply;\r\nomap_crtc->channel = channel;\r\nomap_crtc->plane = plane;\r\nomap_crtc->plane->crtc = crtc;\r\nomap_crtc->name = channel_names[channel];\r\nomap_crtc->pipe = id;\r\nomap_crtc->apply_irq.irqmask = pipe2vbl(crtc);\r\nomap_crtc->apply_irq.irq = omap_crtc_apply_irq;\r\nomap_crtc->error_irq.irqmask =\r\ndispc_mgr_get_sync_lost_irq(channel);\r\nomap_crtc->error_irq.irq = omap_crtc_error_irq;\r\nomap_irq_register(dev, &omap_crtc->error_irq);\r\nomap_crtc->mgr = omap_dss_get_overlay_manager(channel);\r\ninfo = &omap_crtc->info;\r\ninfo->default_color = 0x00000000;\r\ninfo->trans_key = 0x00000000;\r\ninfo->trans_key_type = OMAP_DSS_COLOR_KEY_GFX_DST;\r\ninfo->trans_enabled = false;\r\ndrm_crtc_init(dev, crtc, &omap_crtc_funcs);\r\ndrm_crtc_helper_add(crtc, &omap_crtc_helper_funcs);\r\nomap_plane_install_properties(omap_crtc->plane, &crtc->base);\r\nomap_crtcs[channel] = omap_crtc;\r\nreturn crtc;\r\nfail:\r\nif (crtc)\r\nomap_crtc_destroy(crtc);\r\nreturn NULL;\r\n}
