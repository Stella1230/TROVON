static int is_clear_halt_cmd(struct urb *urb)\r\n{\r\nstruct usb_ctrlrequest *req;\r\nreq = (struct usb_ctrlrequest *) urb->setup_packet;\r\nreturn (req->bRequest == USB_REQ_CLEAR_FEATURE) &&\r\n(req->bRequestType == USB_RECIP_ENDPOINT) &&\r\n(req->wValue == USB_ENDPOINT_HALT);\r\n}\r\nstatic int is_set_interface_cmd(struct urb *urb)\r\n{\r\nstruct usb_ctrlrequest *req;\r\nreq = (struct usb_ctrlrequest *) urb->setup_packet;\r\nreturn (req->bRequest == USB_REQ_SET_INTERFACE) &&\r\n(req->bRequestType == USB_RECIP_INTERFACE);\r\n}\r\nstatic int is_set_configuration_cmd(struct urb *urb)\r\n{\r\nstruct usb_ctrlrequest *req;\r\nreq = (struct usb_ctrlrequest *) urb->setup_packet;\r\nreturn (req->bRequest == USB_REQ_SET_CONFIGURATION) &&\r\n(req->bRequestType == USB_RECIP_DEVICE);\r\n}\r\nstatic int is_reset_device_cmd(struct urb *urb)\r\n{\r\nstruct usb_ctrlrequest *req;\r\n__u16 value;\r\n__u16 index;\r\nreq = (struct usb_ctrlrequest *) urb->setup_packet;\r\nvalue = le16_to_cpu(req->wValue);\r\nindex = le16_to_cpu(req->wIndex);\r\nif ((req->bRequest == USB_REQ_SET_FEATURE) &&\r\n(req->bRequestType == USB_RT_PORT) &&\r\n(value == USB_PORT_FEAT_RESET)) {\r\nusbip_dbg_stub_rx("reset_device_cmd, port %u\n", index);\r\nreturn 1;\r\n} else\r\nreturn 0;\r\n}\r\nstatic int tweak_clear_halt_cmd(struct urb *urb)\r\n{\r\nstruct usb_ctrlrequest *req;\r\nint target_endp;\r\nint target_dir;\r\nint target_pipe;\r\nint ret;\r\nreq = (struct usb_ctrlrequest *) urb->setup_packet;\r\ntarget_endp = le16_to_cpu(req->wIndex) & 0x000f;\r\ntarget_dir = le16_to_cpu(req->wIndex) & 0x0080;\r\nif (target_dir)\r\ntarget_pipe = usb_rcvctrlpipe(urb->dev, target_endp);\r\nelse\r\ntarget_pipe = usb_sndctrlpipe(urb->dev, target_endp);\r\nret = usb_clear_halt(urb->dev, target_pipe);\r\nif (ret < 0)\r\ndev_err(&urb->dev->dev, "usb_clear_halt error: devnum %d endp "\r\n"%d ret %d\n", urb->dev->devnum, target_endp, ret);\r\nelse\r\ndev_info(&urb->dev->dev, "usb_clear_halt done: devnum %d endp "\r\n"%d\n", urb->dev->devnum, target_endp);\r\nreturn ret;\r\n}\r\nstatic int tweak_set_interface_cmd(struct urb *urb)\r\n{\r\nstruct usb_ctrlrequest *req;\r\n__u16 alternate;\r\n__u16 interface;\r\nint ret;\r\nreq = (struct usb_ctrlrequest *) urb->setup_packet;\r\nalternate = le16_to_cpu(req->wValue);\r\ninterface = le16_to_cpu(req->wIndex);\r\nusbip_dbg_stub_rx("set_interface: inf %u alt %u\n",\r\ninterface, alternate);\r\nret = usb_set_interface(urb->dev, interface, alternate);\r\nif (ret < 0)\r\ndev_err(&urb->dev->dev, "usb_set_interface error: inf %u alt "\r\n"%u ret %d\n", interface, alternate, ret);\r\nelse\r\ndev_info(&urb->dev->dev, "usb_set_interface done: inf %u alt "\r\n"%u\n", interface, alternate);\r\nreturn ret;\r\n}\r\nstatic int tweak_set_configuration_cmd(struct urb *urb)\r\n{\r\nstruct usb_ctrlrequest *req;\r\n__u16 config;\r\nreq = (struct usb_ctrlrequest *) urb->setup_packet;\r\nconfig = le16_to_cpu(req->wValue);\r\ndev_info(&urb->dev->dev, "usb_set_configuration %d to %s... skip!\n",\r\nconfig, dev_name(&urb->dev->dev));\r\nreturn 0;\r\n}\r\nstatic int tweak_reset_device_cmd(struct urb *urb)\r\n{\r\nstruct stub_priv *priv = (struct stub_priv *) urb->context;\r\nstruct stub_device *sdev = priv->sdev;\r\ndev_info(&urb->dev->dev, "usb_queue_reset_device\n");\r\nif (usb_lock_device_for_reset(sdev->udev, sdev->interface) < 0) {\r\ndev_err(&urb->dev->dev, "could not obtain lock to reset device\n");\r\nreturn 0;\r\n}\r\nusb_reset_device(sdev->udev);\r\nusb_unlock_device(sdev->udev);\r\nreturn 0;\r\n}\r\nstatic void tweak_special_requests(struct urb *urb)\r\n{\r\nif (!urb || !urb->setup_packet)\r\nreturn;\r\nif (usb_pipetype(urb->pipe) != PIPE_CONTROL)\r\nreturn;\r\nif (is_clear_halt_cmd(urb))\r\ntweak_clear_halt_cmd(urb);\r\nelse if (is_set_interface_cmd(urb))\r\ntweak_set_interface_cmd(urb);\r\nelse if (is_set_configuration_cmd(urb))\r\ntweak_set_configuration_cmd(urb);\r\nelse if (is_reset_device_cmd(urb))\r\ntweak_reset_device_cmd(urb);\r\nelse\r\nusbip_dbg_stub_rx("no need to tweak\n");\r\n}\r\nstatic int stub_recv_cmd_unlink(struct stub_device *sdev,\r\nstruct usbip_header *pdu)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nstruct stub_priv *priv;\r\nspin_lock_irqsave(&sdev->priv_lock, flags);\r\nlist_for_each_entry(priv, &sdev->priv_init, list) {\r\nif (priv->seqnum != pdu->u.cmd_unlink.seqnum)\r\ncontinue;\r\ndev_info(&priv->urb->dev->dev, "unlink urb %p\n",\r\npriv->urb);\r\npriv->unlinking = 1;\r\npriv->seqnum = pdu->base.seqnum;\r\nspin_unlock_irqrestore(&sdev->priv_lock, flags);\r\nret = usb_unlink_urb(priv->urb);\r\nif (ret != -EINPROGRESS)\r\ndev_err(&priv->urb->dev->dev,\r\n"failed to unlink a urb %p, ret %d\n",\r\npriv->urb, ret);\r\nreturn 0;\r\n}\r\nusbip_dbg_stub_rx("seqnum %d is not pending\n",\r\npdu->u.cmd_unlink.seqnum);\r\nstub_enqueue_ret_unlink(sdev, pdu->base.seqnum, 0);\r\nspin_unlock_irqrestore(&sdev->priv_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int valid_request(struct stub_device *sdev, struct usbip_header *pdu)\r\n{\r\nstruct usbip_device *ud = &sdev->ud;\r\nint valid = 0;\r\nif (pdu->base.devid == sdev->devid) {\r\nspin_lock_irq(&ud->lock);\r\nif (ud->status == SDEV_ST_USED) {\r\nvalid = 1;\r\n}\r\nspin_unlock_irq(&ud->lock);\r\n}\r\nreturn valid;\r\n}\r\nstatic struct stub_priv *stub_priv_alloc(struct stub_device *sdev,\r\nstruct usbip_header *pdu)\r\n{\r\nstruct stub_priv *priv;\r\nstruct usbip_device *ud = &sdev->ud;\r\nunsigned long flags;\r\nspin_lock_irqsave(&sdev->priv_lock, flags);\r\npriv = kmem_cache_zalloc(stub_priv_cache, GFP_ATOMIC);\r\nif (!priv) {\r\ndev_err(&sdev->interface->dev, "alloc stub_priv\n");\r\nspin_unlock_irqrestore(&sdev->priv_lock, flags);\r\nusbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);\r\nreturn NULL;\r\n}\r\npriv->seqnum = pdu->base.seqnum;\r\npriv->sdev = sdev;\r\nlist_add_tail(&priv->list, &sdev->priv_init);\r\nspin_unlock_irqrestore(&sdev->priv_lock, flags);\r\nreturn priv;\r\n}\r\nstatic int get_pipe(struct stub_device *sdev, int epnum, int dir)\r\n{\r\nstruct usb_device *udev = sdev->udev;\r\nstruct usb_host_endpoint *ep;\r\nstruct usb_endpoint_descriptor *epd = NULL;\r\nif (dir == USBIP_DIR_IN)\r\nep = udev->ep_in[epnum & 0x7f];\r\nelse\r\nep = udev->ep_out[epnum & 0x7f];\r\nif (!ep) {\r\ndev_err(&sdev->interface->dev, "no such endpoint?, %d\n",\r\nepnum);\r\nBUG();\r\n}\r\nepd = &ep->desc;\r\nif (usb_endpoint_xfer_control(epd)) {\r\nif (dir == USBIP_DIR_OUT)\r\nreturn usb_sndctrlpipe(udev, epnum);\r\nelse\r\nreturn usb_rcvctrlpipe(udev, epnum);\r\n}\r\nif (usb_endpoint_xfer_bulk(epd)) {\r\nif (dir == USBIP_DIR_OUT)\r\nreturn usb_sndbulkpipe(udev, epnum);\r\nelse\r\nreturn usb_rcvbulkpipe(udev, epnum);\r\n}\r\nif (usb_endpoint_xfer_int(epd)) {\r\nif (dir == USBIP_DIR_OUT)\r\nreturn usb_sndintpipe(udev, epnum);\r\nelse\r\nreturn usb_rcvintpipe(udev, epnum);\r\n}\r\nif (usb_endpoint_xfer_isoc(epd)) {\r\nif (dir == USBIP_DIR_OUT)\r\nreturn usb_sndisocpipe(udev, epnum);\r\nelse\r\nreturn usb_rcvisocpipe(udev, epnum);\r\n}\r\ndev_err(&sdev->interface->dev, "get pipe, epnum %d\n", epnum);\r\nreturn 0;\r\n}\r\nstatic void masking_bogus_flags(struct urb *urb)\r\n{\r\nint xfertype;\r\nstruct usb_device *dev;\r\nstruct usb_host_endpoint *ep;\r\nint is_out;\r\nunsigned int allowed;\r\nif (!urb || urb->hcpriv || !urb->complete)\r\nreturn;\r\ndev = urb->dev;\r\nif ((!dev) || (dev->state < USB_STATE_UNAUTHENTICATED))\r\nreturn;\r\nep = (usb_pipein(urb->pipe) ? dev->ep_in : dev->ep_out)\r\n[usb_pipeendpoint(urb->pipe)];\r\nif (!ep)\r\nreturn;\r\nxfertype = usb_endpoint_type(&ep->desc);\r\nif (xfertype == USB_ENDPOINT_XFER_CONTROL) {\r\nstruct usb_ctrlrequest *setup =\r\n(struct usb_ctrlrequest *) urb->setup_packet;\r\nif (!setup)\r\nreturn;\r\nis_out = !(setup->bRequestType & USB_DIR_IN) ||\r\n!setup->wLength;\r\n} else {\r\nis_out = usb_endpoint_dir_out(&ep->desc);\r\n}\r\nallowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_INTERRUPT |\r\nURB_DIR_MASK | URB_FREE_BUFFER);\r\nswitch (xfertype) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (is_out)\r\nallowed |= URB_ZERO_PACKET;\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\nallowed |= URB_NO_FSBR;\r\ndefault:\r\nif (!is_out)\r\nallowed |= URB_SHORT_NOT_OK;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nallowed |= URB_ISO_ASAP;\r\nbreak;\r\n}\r\nurb->transfer_flags &= allowed;\r\n}\r\nstatic void stub_recv_cmd_submit(struct stub_device *sdev,\r\nstruct usbip_header *pdu)\r\n{\r\nint ret;\r\nstruct stub_priv *priv;\r\nstruct usbip_device *ud = &sdev->ud;\r\nstruct usb_device *udev = sdev->udev;\r\nint pipe = get_pipe(sdev, pdu->base.ep, pdu->base.direction);\r\npriv = stub_priv_alloc(sdev, pdu);\r\nif (!priv)\r\nreturn;\r\nif (usb_pipeisoc(pipe))\r\npriv->urb = usb_alloc_urb(pdu->u.cmd_submit.number_of_packets,\r\nGFP_KERNEL);\r\nelse\r\npriv->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!priv->urb) {\r\ndev_err(&sdev->interface->dev, "malloc urb\n");\r\nusbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);\r\nreturn;\r\n}\r\nif (pdu->u.cmd_submit.transfer_buffer_length > 0) {\r\npriv->urb->transfer_buffer =\r\nkzalloc(pdu->u.cmd_submit.transfer_buffer_length,\r\nGFP_KERNEL);\r\nif (!priv->urb->transfer_buffer) {\r\nusbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);\r\nreturn;\r\n}\r\n}\r\npriv->urb->setup_packet = kmemdup(&pdu->u.cmd_submit.setup, 8,\r\nGFP_KERNEL);\r\nif (!priv->urb->setup_packet) {\r\ndev_err(&sdev->interface->dev, "allocate setup_packet\n");\r\nusbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);\r\nreturn;\r\n}\r\npriv->urb->context = (void *) priv;\r\npriv->urb->dev = udev;\r\npriv->urb->pipe = pipe;\r\npriv->urb->complete = stub_complete;\r\nusbip_pack_pdu(pdu, priv->urb, USBIP_CMD_SUBMIT, 0);\r\nif (usbip_recv_xbuff(ud, priv->urb) < 0)\r\nreturn;\r\nif (usbip_recv_iso(ud, priv->urb) < 0)\r\nreturn;\r\ntweak_special_requests(priv->urb);\r\nmasking_bogus_flags(priv->urb);\r\nret = usb_submit_urb(priv->urb, GFP_KERNEL);\r\nif (ret == 0)\r\nusbip_dbg_stub_rx("submit urb ok, seqnum %u\n",\r\npdu->base.seqnum);\r\nelse {\r\ndev_err(&sdev->interface->dev, "submit_urb error, %d\n", ret);\r\nusbip_dump_header(pdu);\r\nusbip_dump_urb(priv->urb);\r\nusbip_event_add(ud, SDEV_EVENT_ERROR_SUBMIT);\r\n}\r\nusbip_dbg_stub_rx("Leave\n");\r\nreturn;\r\n}\r\nstatic void stub_rx_pdu(struct usbip_device *ud)\r\n{\r\nint ret;\r\nstruct usbip_header pdu;\r\nstruct stub_device *sdev = container_of(ud, struct stub_device, ud);\r\nstruct device *dev = &sdev->interface->dev;\r\nusbip_dbg_stub_rx("Enter\n");\r\nmemset(&pdu, 0, sizeof(pdu));\r\nret = usbip_recv(ud->tcp_socket, &pdu, sizeof(pdu));\r\nif (ret != sizeof(pdu)) {\r\ndev_err(dev, "recv a header, %d\n", ret);\r\nusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\r\nreturn;\r\n}\r\nusbip_header_correct_endian(&pdu, 0);\r\nif (usbip_dbg_flag_stub_rx)\r\nusbip_dump_header(&pdu);\r\nif (!valid_request(sdev, &pdu)) {\r\ndev_err(dev, "recv invalid request\n");\r\nusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\r\nreturn;\r\n}\r\nswitch (pdu.base.command) {\r\ncase USBIP_CMD_UNLINK:\r\nstub_recv_cmd_unlink(sdev, &pdu);\r\nbreak;\r\ncase USBIP_CMD_SUBMIT:\r\nstub_recv_cmd_submit(sdev, &pdu);\r\nbreak;\r\ndefault:\r\ndev_err(dev, "unknown pdu\n");\r\nusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\r\nbreak;\r\n}\r\n}\r\nint stub_rx_loop(void *data)\r\n{\r\nstruct usbip_device *ud = data;\r\nwhile (!kthread_should_stop()) {\r\nif (usbip_event_happened(ud))\r\nbreak;\r\nstub_rx_pdu(ud);\r\n}\r\nreturn 0;\r\n}
