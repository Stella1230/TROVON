static struct iommu_dev_data *alloc_dev_data(u16 devid)\r\n{\r\nstruct iommu_dev_data *dev_data;\r\nunsigned long flags;\r\ndev_data = kzalloc(sizeof(*dev_data), GFP_KERNEL);\r\nif (!dev_data)\r\nreturn NULL;\r\ndev_data->devid = devid;\r\natomic_set(&dev_data->bind, 0);\r\nspin_lock_irqsave(&dev_data_list_lock, flags);\r\nlist_add_tail(&dev_data->dev_data_list, &dev_data_list);\r\nspin_unlock_irqrestore(&dev_data_list_lock, flags);\r\nreturn dev_data;\r\n}\r\nstatic void free_dev_data(struct iommu_dev_data *dev_data)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev_data_list_lock, flags);\r\nlist_del(&dev_data->dev_data_list);\r\nspin_unlock_irqrestore(&dev_data_list_lock, flags);\r\nif (dev_data->group)\r\niommu_group_put(dev_data->group);\r\nkfree(dev_data);\r\n}\r\nstatic struct iommu_dev_data *search_dev_data(u16 devid)\r\n{\r\nstruct iommu_dev_data *dev_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev_data_list_lock, flags);\r\nlist_for_each_entry(dev_data, &dev_data_list, dev_data_list) {\r\nif (dev_data->devid == devid)\r\ngoto out_unlock;\r\n}\r\ndev_data = NULL;\r\nout_unlock:\r\nspin_unlock_irqrestore(&dev_data_list_lock, flags);\r\nreturn dev_data;\r\n}\r\nstatic struct iommu_dev_data *find_dev_data(u16 devid)\r\n{\r\nstruct iommu_dev_data *dev_data;\r\ndev_data = search_dev_data(devid);\r\nif (dev_data == NULL)\r\ndev_data = alloc_dev_data(devid);\r\nreturn dev_data;\r\n}\r\nstatic inline u16 get_device_id(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nreturn PCI_DEVID(pdev->bus->number, pdev->devfn);\r\n}\r\nstatic struct iommu_dev_data *get_dev_data(struct device *dev)\r\n{\r\nreturn dev->archdata.iommu;\r\n}\r\nstatic bool pci_iommuv2_capable(struct pci_dev *pdev)\r\n{\r\nstatic const int caps[] = {\r\nPCI_EXT_CAP_ID_ATS,\r\nPCI_EXT_CAP_ID_PRI,\r\nPCI_EXT_CAP_ID_PASID,\r\n};\r\nint i, pos;\r\nfor (i = 0; i < 3; ++i) {\r\npos = pci_find_ext_capability(pdev, caps[i]);\r\nif (pos == 0)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool pdev_pri_erratum(struct pci_dev *pdev, u32 erratum)\r\n{\r\nstruct iommu_dev_data *dev_data;\r\ndev_data = get_dev_data(&pdev->dev);\r\nreturn dev_data->errata & (1 << erratum) ? true : false;\r\n}\r\nstatic struct dma_ops_domain *find_protection_domain(u16 devid)\r\n{\r\nstruct dma_ops_domain *entry, *ret = NULL;\r\nunsigned long flags;\r\nu16 alias = amd_iommu_alias_table[devid];\r\nif (list_empty(&iommu_pd_list))\r\nreturn NULL;\r\nspin_lock_irqsave(&iommu_pd_list_lock, flags);\r\nlist_for_each_entry(entry, &iommu_pd_list, list) {\r\nif (entry->target_dev == devid ||\r\nentry->target_dev == alias) {\r\nret = entry;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&iommu_pd_list_lock, flags);\r\nreturn ret;\r\n}\r\nstatic bool check_device(struct device *dev)\r\n{\r\nu16 devid;\r\nif (!dev || !dev->dma_mask)\r\nreturn false;\r\nif (dev->bus != &pci_bus_type)\r\nreturn false;\r\ndevid = get_device_id(dev);\r\nif (devid > amd_iommu_last_bdf)\r\nreturn false;\r\nif (amd_iommu_rlookup_table[devid] == NULL)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic struct pci_bus *find_hosted_bus(struct pci_bus *bus)\r\n{\r\nwhile (!bus->self) {\r\nif (!pci_is_root_bus(bus))\r\nbus = bus->parent;\r\nelse\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nreturn bus;\r\n}\r\nstatic struct pci_dev *get_isolation_root(struct pci_dev *pdev)\r\n{\r\nstruct pci_dev *dma_pdev = pdev;\r\nswap_pci_ref(&dma_pdev, pci_get_dma_source(dma_pdev));\r\nif (dma_pdev->multifunction &&\r\n!pci_acs_enabled(dma_pdev, REQ_ACS_FLAGS)) {\r\nu8 i, slot = PCI_SLOT(dma_pdev->devfn);\r\nfor (i = 0; i < 8; i++) {\r\nstruct pci_dev *tmp;\r\ntmp = pci_get_slot(dma_pdev->bus, PCI_DEVFN(slot, i));\r\nif (!tmp)\r\ncontinue;\r\nif (!pci_acs_enabled(tmp, REQ_ACS_FLAGS)) {\r\nswap_pci_ref(&dma_pdev, tmp);\r\nbreak;\r\n}\r\npci_dev_put(tmp);\r\n}\r\n}\r\nwhile (!pci_is_root_bus(dma_pdev->bus)) {\r\nstruct pci_bus *bus = find_hosted_bus(dma_pdev->bus);\r\nif (IS_ERR(bus))\r\nbreak;\r\nif (pci_acs_path_enabled(bus->self, NULL, REQ_ACS_FLAGS))\r\nbreak;\r\nswap_pci_ref(&dma_pdev, pci_dev_get(bus->self));\r\n}\r\nreturn dma_pdev;\r\n}\r\nstatic int use_pdev_iommu_group(struct pci_dev *pdev, struct device *dev)\r\n{\r\nstruct iommu_group *group = iommu_group_get(&pdev->dev);\r\nint ret;\r\nif (!group) {\r\ngroup = iommu_group_alloc();\r\nif (IS_ERR(group))\r\nreturn PTR_ERR(group);\r\nWARN_ON(&pdev->dev != dev);\r\n}\r\nret = iommu_group_add_device(group, dev);\r\niommu_group_put(group);\r\nreturn ret;\r\n}\r\nstatic int use_dev_data_iommu_group(struct iommu_dev_data *dev_data,\r\nstruct device *dev)\r\n{\r\nif (!dev_data->group) {\r\nstruct iommu_group *group = iommu_group_alloc();\r\nif (IS_ERR(group))\r\nreturn PTR_ERR(group);\r\ndev_data->group = group;\r\n}\r\nreturn iommu_group_add_device(dev_data->group, dev);\r\n}\r\nstatic int init_iommu_group(struct device *dev)\r\n{\r\nstruct iommu_dev_data *dev_data;\r\nstruct iommu_group *group;\r\nstruct pci_dev *dma_pdev;\r\nint ret;\r\ngroup = iommu_group_get(dev);\r\nif (group) {\r\niommu_group_put(group);\r\nreturn 0;\r\n}\r\ndev_data = find_dev_data(get_device_id(dev));\r\nif (!dev_data)\r\nreturn -ENOMEM;\r\nif (dev_data->alias_data) {\r\nu16 alias;\r\nstruct pci_bus *bus;\r\nif (dev_data->alias_data->group)\r\ngoto use_group;\r\nalias = amd_iommu_alias_table[dev_data->devid];\r\ndma_pdev = pci_get_bus_and_slot(alias >> 8, alias & 0xff);\r\nif (dma_pdev) {\r\ndma_pdev = get_isolation_root(dma_pdev);\r\ngoto use_pdev;\r\n}\r\nbus = pci_find_bus(0, alias >> 8);\r\nif (!bus)\r\ngoto use_group;\r\nbus = find_hosted_bus(bus);\r\nif (IS_ERR(bus) || !bus->self)\r\ngoto use_group;\r\ndma_pdev = get_isolation_root(pci_dev_get(bus->self));\r\nif (dma_pdev != bus->self || (dma_pdev->multifunction &&\r\n!pci_acs_enabled(dma_pdev, REQ_ACS_FLAGS)))\r\ngoto use_pdev;\r\npci_dev_put(dma_pdev);\r\ngoto use_group;\r\n}\r\ndma_pdev = get_isolation_root(pci_dev_get(to_pci_dev(dev)));\r\nuse_pdev:\r\nret = use_pdev_iommu_group(dma_pdev, dev);\r\npci_dev_put(dma_pdev);\r\nreturn ret;\r\nuse_group:\r\nreturn use_dev_data_iommu_group(dev_data->alias_data, dev);\r\n}\r\nstatic int iommu_init_device(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct iommu_dev_data *dev_data;\r\nu16 alias;\r\nint ret;\r\nif (dev->archdata.iommu)\r\nreturn 0;\r\ndev_data = find_dev_data(get_device_id(dev));\r\nif (!dev_data)\r\nreturn -ENOMEM;\r\nalias = amd_iommu_alias_table[dev_data->devid];\r\nif (alias != dev_data->devid) {\r\nstruct iommu_dev_data *alias_data;\r\nalias_data = find_dev_data(alias);\r\nif (alias_data == NULL) {\r\npr_err("AMD-Vi: Warning: Unhandled device %s\n",\r\ndev_name(dev));\r\nfree_dev_data(dev_data);\r\nreturn -ENOTSUPP;\r\n}\r\ndev_data->alias_data = alias_data;\r\n}\r\nret = init_iommu_group(dev);\r\nif (ret) {\r\nfree_dev_data(dev_data);\r\nreturn ret;\r\n}\r\nif (pci_iommuv2_capable(pdev)) {\r\nstruct amd_iommu *iommu;\r\niommu = amd_iommu_rlookup_table[dev_data->devid];\r\ndev_data->iommu_v2 = iommu->is_iommu_v2;\r\n}\r\ndev->archdata.iommu = dev_data;\r\nreturn 0;\r\n}\r\nstatic void iommu_ignore_device(struct device *dev)\r\n{\r\nu16 devid, alias;\r\ndevid = get_device_id(dev);\r\nalias = amd_iommu_alias_table[devid];\r\nmemset(&amd_iommu_dev_table[devid], 0, sizeof(struct dev_table_entry));\r\nmemset(&amd_iommu_dev_table[alias], 0, sizeof(struct dev_table_entry));\r\namd_iommu_rlookup_table[devid] = NULL;\r\namd_iommu_rlookup_table[alias] = NULL;\r\n}\r\nstatic void iommu_uninit_device(struct device *dev)\r\n{\r\niommu_group_remove_device(dev);\r\n}\r\nvoid __init amd_iommu_uninit_devices(void)\r\n{\r\nstruct iommu_dev_data *dev_data, *n;\r\nstruct pci_dev *pdev = NULL;\r\nfor_each_pci_dev(pdev) {\r\nif (!check_device(&pdev->dev))\r\ncontinue;\r\niommu_uninit_device(&pdev->dev);\r\n}\r\nlist_for_each_entry_safe(dev_data, n, &dev_data_list, dev_data_list)\r\nfree_dev_data(dev_data);\r\n}\r\nint __init amd_iommu_init_devices(void)\r\n{\r\nstruct pci_dev *pdev = NULL;\r\nint ret = 0;\r\nfor_each_pci_dev(pdev) {\r\nif (!check_device(&pdev->dev))\r\ncontinue;\r\nret = iommu_init_device(&pdev->dev);\r\nif (ret == -ENOTSUPP)\r\niommu_ignore_device(&pdev->dev);\r\nelse if (ret)\r\ngoto out_free;\r\n}\r\nreturn 0;\r\nout_free:\r\namd_iommu_uninit_devices();\r\nreturn ret;\r\n}\r\nstatic void amd_iommu_stats_add(struct __iommu_counter *cnt)\r\n{\r\nif (stats_dir == NULL)\r\nreturn;\r\ncnt->dent = debugfs_create_u64(cnt->name, 0444, stats_dir,\r\n&cnt->value);\r\n}\r\nstatic void amd_iommu_stats_init(void)\r\n{\r\nstats_dir = debugfs_create_dir("amd-iommu", NULL);\r\nif (stats_dir == NULL)\r\nreturn;\r\nde_fflush = debugfs_create_bool("fullflush", 0444, stats_dir,\r\n&amd_iommu_unmap_flush);\r\namd_iommu_stats_add(&compl_wait);\r\namd_iommu_stats_add(&cnt_map_single);\r\namd_iommu_stats_add(&cnt_unmap_single);\r\namd_iommu_stats_add(&cnt_map_sg);\r\namd_iommu_stats_add(&cnt_unmap_sg);\r\namd_iommu_stats_add(&cnt_alloc_coherent);\r\namd_iommu_stats_add(&cnt_free_coherent);\r\namd_iommu_stats_add(&cross_page);\r\namd_iommu_stats_add(&domain_flush_single);\r\namd_iommu_stats_add(&domain_flush_all);\r\namd_iommu_stats_add(&alloced_io_mem);\r\namd_iommu_stats_add(&total_map_requests);\r\namd_iommu_stats_add(&complete_ppr);\r\namd_iommu_stats_add(&invalidate_iotlb);\r\namd_iommu_stats_add(&invalidate_iotlb_all);\r\namd_iommu_stats_add(&pri_requests);\r\n}\r\nstatic void dump_dte_entry(u16 devid)\r\n{\r\nint i;\r\nfor (i = 0; i < 4; ++i)\r\npr_err("AMD-Vi: DTE[%d]: %016llx\n", i,\r\namd_iommu_dev_table[devid].data[i]);\r\n}\r\nstatic void dump_command(unsigned long phys_addr)\r\n{\r\nstruct iommu_cmd *cmd = phys_to_virt(phys_addr);\r\nint i;\r\nfor (i = 0; i < 4; ++i)\r\npr_err("AMD-Vi: CMD[%d]: %08x\n", i, cmd->data[i]);\r\n}\r\nstatic void iommu_print_event(struct amd_iommu *iommu, void *__evt)\r\n{\r\nint type, devid, domid, flags;\r\nvolatile u32 *event = __evt;\r\nint count = 0;\r\nu64 address;\r\nretry:\r\ntype = (event[1] >> EVENT_TYPE_SHIFT) & EVENT_TYPE_MASK;\r\ndevid = (event[0] >> EVENT_DEVID_SHIFT) & EVENT_DEVID_MASK;\r\ndomid = (event[1] >> EVENT_DOMID_SHIFT) & EVENT_DOMID_MASK;\r\nflags = (event[1] >> EVENT_FLAGS_SHIFT) & EVENT_FLAGS_MASK;\r\naddress = (u64)(((u64)event[3]) << 32) | event[2];\r\nif (type == 0) {\r\nif (++count == LOOP_TIMEOUT) {\r\npr_err("AMD-Vi: No event written to event log\n");\r\nreturn;\r\n}\r\nudelay(1);\r\ngoto retry;\r\n}\r\nprintk(KERN_ERR "AMD-Vi: Event logged [");\r\nswitch (type) {\r\ncase EVENT_TYPE_ILL_DEV:\r\nprintk("ILLEGAL_DEV_TABLE_ENTRY device=%02x:%02x.%x "\r\n"address=0x%016llx flags=0x%04x]\n",\r\nPCI_BUS_NUM(devid), PCI_SLOT(devid), PCI_FUNC(devid),\r\naddress, flags);\r\ndump_dte_entry(devid);\r\nbreak;\r\ncase EVENT_TYPE_IO_FAULT:\r\nprintk("IO_PAGE_FAULT device=%02x:%02x.%x "\r\n"domain=0x%04x address=0x%016llx flags=0x%04x]\n",\r\nPCI_BUS_NUM(devid), PCI_SLOT(devid), PCI_FUNC(devid),\r\ndomid, address, flags);\r\nbreak;\r\ncase EVENT_TYPE_DEV_TAB_ERR:\r\nprintk("DEV_TAB_HARDWARE_ERROR device=%02x:%02x.%x "\r\n"address=0x%016llx flags=0x%04x]\n",\r\nPCI_BUS_NUM(devid), PCI_SLOT(devid), PCI_FUNC(devid),\r\naddress, flags);\r\nbreak;\r\ncase EVENT_TYPE_PAGE_TAB_ERR:\r\nprintk("PAGE_TAB_HARDWARE_ERROR device=%02x:%02x.%x "\r\n"domain=0x%04x address=0x%016llx flags=0x%04x]\n",\r\nPCI_BUS_NUM(devid), PCI_SLOT(devid), PCI_FUNC(devid),\r\ndomid, address, flags);\r\nbreak;\r\ncase EVENT_TYPE_ILL_CMD:\r\nprintk("ILLEGAL_COMMAND_ERROR address=0x%016llx]\n", address);\r\ndump_command(address);\r\nbreak;\r\ncase EVENT_TYPE_CMD_HARD_ERR:\r\nprintk("COMMAND_HARDWARE_ERROR address=0x%016llx "\r\n"flags=0x%04x]\n", address, flags);\r\nbreak;\r\ncase EVENT_TYPE_IOTLB_INV_TO:\r\nprintk("IOTLB_INV_TIMEOUT device=%02x:%02x.%x "\r\n"address=0x%016llx]\n",\r\nPCI_BUS_NUM(devid), PCI_SLOT(devid), PCI_FUNC(devid),\r\naddress);\r\nbreak;\r\ncase EVENT_TYPE_INV_DEV_REQ:\r\nprintk("INVALID_DEVICE_REQUEST device=%02x:%02x.%x "\r\n"address=0x%016llx flags=0x%04x]\n",\r\nPCI_BUS_NUM(devid), PCI_SLOT(devid), PCI_FUNC(devid),\r\naddress, flags);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "UNKNOWN type=0x%02x]\n", type);\r\n}\r\nmemset(__evt, 0, 4 * sizeof(u32));\r\n}\r\nstatic void iommu_poll_events(struct amd_iommu *iommu)\r\n{\r\nu32 head, tail;\r\nhead = readl(iommu->mmio_base + MMIO_EVT_HEAD_OFFSET);\r\ntail = readl(iommu->mmio_base + MMIO_EVT_TAIL_OFFSET);\r\nwhile (head != tail) {\r\niommu_print_event(iommu, iommu->evt_buf + head);\r\nhead = (head + EVENT_ENTRY_SIZE) % iommu->evt_buf_size;\r\n}\r\nwritel(head, iommu->mmio_base + MMIO_EVT_HEAD_OFFSET);\r\n}\r\nstatic void iommu_handle_ppr_entry(struct amd_iommu *iommu, u64 *raw)\r\n{\r\nstruct amd_iommu_fault fault;\r\nINC_STATS_COUNTER(pri_requests);\r\nif (PPR_REQ_TYPE(raw[0]) != PPR_REQ_FAULT) {\r\npr_err_ratelimited("AMD-Vi: Unknown PPR request received\n");\r\nreturn;\r\n}\r\nfault.address = raw[1];\r\nfault.pasid = PPR_PASID(raw[0]);\r\nfault.device_id = PPR_DEVID(raw[0]);\r\nfault.tag = PPR_TAG(raw[0]);\r\nfault.flags = PPR_FLAGS(raw[0]);\r\natomic_notifier_call_chain(&ppr_notifier, 0, &fault);\r\n}\r\nstatic void iommu_poll_ppr_log(struct amd_iommu *iommu)\r\n{\r\nu32 head, tail;\r\nif (iommu->ppr_log == NULL)\r\nreturn;\r\nhead = readl(iommu->mmio_base + MMIO_PPR_HEAD_OFFSET);\r\ntail = readl(iommu->mmio_base + MMIO_PPR_TAIL_OFFSET);\r\nwhile (head != tail) {\r\nvolatile u64 *raw;\r\nu64 entry[2];\r\nint i;\r\nraw = (u64 *)(iommu->ppr_log + head);\r\nfor (i = 0; i < LOOP_TIMEOUT; ++i) {\r\nif (PPR_REQ_TYPE(raw[0]) != 0)\r\nbreak;\r\nudelay(1);\r\n}\r\nentry[0] = raw[0];\r\nentry[1] = raw[1];\r\nraw[0] = raw[1] = 0UL;\r\nhead = (head + PPR_ENTRY_SIZE) % PPR_LOG_SIZE;\r\nwritel(head, iommu->mmio_base + MMIO_PPR_HEAD_OFFSET);\r\niommu_handle_ppr_entry(iommu, entry);\r\nhead = readl(iommu->mmio_base + MMIO_PPR_HEAD_OFFSET);\r\ntail = readl(iommu->mmio_base + MMIO_PPR_TAIL_OFFSET);\r\n}\r\n}\r\nirqreturn_t amd_iommu_int_thread(int irq, void *data)\r\n{\r\nstruct amd_iommu *iommu = (struct amd_iommu *) data;\r\nu32 status = readl(iommu->mmio_base + MMIO_STATUS_OFFSET);\r\nwhile (status & (MMIO_STATUS_EVT_INT_MASK | MMIO_STATUS_PPR_INT_MASK)) {\r\nwritel((MMIO_STATUS_EVT_INT_MASK | MMIO_STATUS_PPR_INT_MASK),\r\niommu->mmio_base + MMIO_STATUS_OFFSET);\r\nif (status & MMIO_STATUS_EVT_INT_MASK) {\r\npr_devel("AMD-Vi: Processing IOMMU Event Log\n");\r\niommu_poll_events(iommu);\r\n}\r\nif (status & MMIO_STATUS_PPR_INT_MASK) {\r\npr_devel("AMD-Vi: Processing IOMMU PPR Log\n");\r\niommu_poll_ppr_log(iommu);\r\n}\r\nstatus = readl(iommu->mmio_base + MMIO_STATUS_OFFSET);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nirqreturn_t amd_iommu_int_handler(int irq, void *data)\r\n{\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic int wait_on_sem(volatile u64 *sem)\r\n{\r\nint i = 0;\r\nwhile (*sem == 0 && i < LOOP_TIMEOUT) {\r\nudelay(1);\r\ni += 1;\r\n}\r\nif (i == LOOP_TIMEOUT) {\r\npr_alert("AMD-Vi: Completion-Wait loop timed out\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void copy_cmd_to_buffer(struct amd_iommu *iommu,\r\nstruct iommu_cmd *cmd,\r\nu32 tail)\r\n{\r\nu8 *target;\r\ntarget = iommu->cmd_buf + tail;\r\ntail = (tail + sizeof(*cmd)) % iommu->cmd_buf_size;\r\nmemcpy(target, cmd, sizeof(*cmd));\r\nwritel(tail, iommu->mmio_base + MMIO_CMD_TAIL_OFFSET);\r\n}\r\nstatic void build_completion_wait(struct iommu_cmd *cmd, u64 address)\r\n{\r\nWARN_ON(address & 0x7ULL);\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->data[0] = lower_32_bits(__pa(address)) | CMD_COMPL_WAIT_STORE_MASK;\r\ncmd->data[1] = upper_32_bits(__pa(address));\r\ncmd->data[2] = 1;\r\nCMD_SET_TYPE(cmd, CMD_COMPL_WAIT);\r\n}\r\nstatic void build_inv_dte(struct iommu_cmd *cmd, u16 devid)\r\n{\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->data[0] = devid;\r\nCMD_SET_TYPE(cmd, CMD_INV_DEV_ENTRY);\r\n}\r\nstatic void build_inv_iommu_pages(struct iommu_cmd *cmd, u64 address,\r\nsize_t size, u16 domid, int pde)\r\n{\r\nu64 pages;\r\nint s;\r\npages = iommu_num_pages(address, size, PAGE_SIZE);\r\ns = 0;\r\nif (pages > 1) {\r\naddress = CMD_INV_IOMMU_ALL_PAGES_ADDRESS;\r\ns = 1;\r\n}\r\naddress &= PAGE_MASK;\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->data[1] |= domid;\r\ncmd->data[2] = lower_32_bits(address);\r\ncmd->data[3] = upper_32_bits(address);\r\nCMD_SET_TYPE(cmd, CMD_INV_IOMMU_PAGES);\r\nif (s)\r\ncmd->data[2] |= CMD_INV_IOMMU_PAGES_SIZE_MASK;\r\nif (pde)\r\ncmd->data[2] |= CMD_INV_IOMMU_PAGES_PDE_MASK;\r\n}\r\nstatic void build_inv_iotlb_pages(struct iommu_cmd *cmd, u16 devid, int qdep,\r\nu64 address, size_t size)\r\n{\r\nu64 pages;\r\nint s;\r\npages = iommu_num_pages(address, size, PAGE_SIZE);\r\ns = 0;\r\nif (pages > 1) {\r\naddress = CMD_INV_IOMMU_ALL_PAGES_ADDRESS;\r\ns = 1;\r\n}\r\naddress &= PAGE_MASK;\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->data[0] = devid;\r\ncmd->data[0] |= (qdep & 0xff) << 24;\r\ncmd->data[1] = devid;\r\ncmd->data[2] = lower_32_bits(address);\r\ncmd->data[3] = upper_32_bits(address);\r\nCMD_SET_TYPE(cmd, CMD_INV_IOTLB_PAGES);\r\nif (s)\r\ncmd->data[2] |= CMD_INV_IOMMU_PAGES_SIZE_MASK;\r\n}\r\nstatic void build_inv_iommu_pasid(struct iommu_cmd *cmd, u16 domid, int pasid,\r\nu64 address, bool size)\r\n{\r\nmemset(cmd, 0, sizeof(*cmd));\r\naddress &= ~(0xfffULL);\r\ncmd->data[0] = pasid & PASID_MASK;\r\ncmd->data[1] = domid;\r\ncmd->data[2] = lower_32_bits(address);\r\ncmd->data[3] = upper_32_bits(address);\r\ncmd->data[2] |= CMD_INV_IOMMU_PAGES_PDE_MASK;\r\ncmd->data[2] |= CMD_INV_IOMMU_PAGES_GN_MASK;\r\nif (size)\r\ncmd->data[2] |= CMD_INV_IOMMU_PAGES_SIZE_MASK;\r\nCMD_SET_TYPE(cmd, CMD_INV_IOMMU_PAGES);\r\n}\r\nstatic void build_inv_iotlb_pasid(struct iommu_cmd *cmd, u16 devid, int pasid,\r\nint qdep, u64 address, bool size)\r\n{\r\nmemset(cmd, 0, sizeof(*cmd));\r\naddress &= ~(0xfffULL);\r\ncmd->data[0] = devid;\r\ncmd->data[0] |= (pasid & 0xff) << 16;\r\ncmd->data[0] |= (qdep & 0xff) << 24;\r\ncmd->data[1] = devid;\r\ncmd->data[1] |= ((pasid >> 8) & 0xfff) << 16;\r\ncmd->data[2] = lower_32_bits(address);\r\ncmd->data[2] |= CMD_INV_IOMMU_PAGES_GN_MASK;\r\ncmd->data[3] = upper_32_bits(address);\r\nif (size)\r\ncmd->data[2] |= CMD_INV_IOMMU_PAGES_SIZE_MASK;\r\nCMD_SET_TYPE(cmd, CMD_INV_IOTLB_PAGES);\r\n}\r\nstatic void build_complete_ppr(struct iommu_cmd *cmd, u16 devid, int pasid,\r\nint status, int tag, bool gn)\r\n{\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->data[0] = devid;\r\nif (gn) {\r\ncmd->data[1] = pasid & PASID_MASK;\r\ncmd->data[2] = CMD_INV_IOMMU_PAGES_GN_MASK;\r\n}\r\ncmd->data[3] = tag & 0x1ff;\r\ncmd->data[3] |= (status & PPR_STATUS_MASK) << PPR_STATUS_SHIFT;\r\nCMD_SET_TYPE(cmd, CMD_COMPLETE_PPR);\r\n}\r\nstatic void build_inv_all(struct iommu_cmd *cmd)\r\n{\r\nmemset(cmd, 0, sizeof(*cmd));\r\nCMD_SET_TYPE(cmd, CMD_INV_ALL);\r\n}\r\nstatic void build_inv_irt(struct iommu_cmd *cmd, u16 devid)\r\n{\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->data[0] = devid;\r\nCMD_SET_TYPE(cmd, CMD_INV_IRT);\r\n}\r\nstatic int iommu_queue_command_sync(struct amd_iommu *iommu,\r\nstruct iommu_cmd *cmd,\r\nbool sync)\r\n{\r\nu32 left, tail, head, next_tail;\r\nunsigned long flags;\r\nWARN_ON(iommu->cmd_buf_size & CMD_BUFFER_UNINITIALIZED);\r\nagain:\r\nspin_lock_irqsave(&iommu->lock, flags);\r\nhead = readl(iommu->mmio_base + MMIO_CMD_HEAD_OFFSET);\r\ntail = readl(iommu->mmio_base + MMIO_CMD_TAIL_OFFSET);\r\nnext_tail = (tail + sizeof(*cmd)) % iommu->cmd_buf_size;\r\nleft = (head - next_tail) % iommu->cmd_buf_size;\r\nif (left <= 2) {\r\nstruct iommu_cmd sync_cmd;\r\nvolatile u64 sem = 0;\r\nint ret;\r\nbuild_completion_wait(&sync_cmd, (u64)&sem);\r\ncopy_cmd_to_buffer(iommu, &sync_cmd, tail);\r\nspin_unlock_irqrestore(&iommu->lock, flags);\r\nif ((ret = wait_on_sem(&sem)) != 0)\r\nreturn ret;\r\ngoto again;\r\n}\r\ncopy_cmd_to_buffer(iommu, cmd, tail);\r\niommu->need_sync = sync;\r\nspin_unlock_irqrestore(&iommu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int iommu_queue_command(struct amd_iommu *iommu, struct iommu_cmd *cmd)\r\n{\r\nreturn iommu_queue_command_sync(iommu, cmd, true);\r\n}\r\nstatic int iommu_completion_wait(struct amd_iommu *iommu)\r\n{\r\nstruct iommu_cmd cmd;\r\nvolatile u64 sem = 0;\r\nint ret;\r\nif (!iommu->need_sync)\r\nreturn 0;\r\nbuild_completion_wait(&cmd, (u64)&sem);\r\nret = iommu_queue_command_sync(iommu, &cmd, false);\r\nif (ret)\r\nreturn ret;\r\nreturn wait_on_sem(&sem);\r\n}\r\nstatic int iommu_flush_dte(struct amd_iommu *iommu, u16 devid)\r\n{\r\nstruct iommu_cmd cmd;\r\nbuild_inv_dte(&cmd, devid);\r\nreturn iommu_queue_command(iommu, &cmd);\r\n}\r\nstatic void iommu_flush_dte_all(struct amd_iommu *iommu)\r\n{\r\nu32 devid;\r\nfor (devid = 0; devid <= 0xffff; ++devid)\r\niommu_flush_dte(iommu, devid);\r\niommu_completion_wait(iommu);\r\n}\r\nstatic void iommu_flush_tlb_all(struct amd_iommu *iommu)\r\n{\r\nu32 dom_id;\r\nfor (dom_id = 0; dom_id <= 0xffff; ++dom_id) {\r\nstruct iommu_cmd cmd;\r\nbuild_inv_iommu_pages(&cmd, 0, CMD_INV_IOMMU_ALL_PAGES_ADDRESS,\r\ndom_id, 1);\r\niommu_queue_command(iommu, &cmd);\r\n}\r\niommu_completion_wait(iommu);\r\n}\r\nstatic void iommu_flush_all(struct amd_iommu *iommu)\r\n{\r\nstruct iommu_cmd cmd;\r\nbuild_inv_all(&cmd);\r\niommu_queue_command(iommu, &cmd);\r\niommu_completion_wait(iommu);\r\n}\r\nstatic void iommu_flush_irt(struct amd_iommu *iommu, u16 devid)\r\n{\r\nstruct iommu_cmd cmd;\r\nbuild_inv_irt(&cmd, devid);\r\niommu_queue_command(iommu, &cmd);\r\n}\r\nstatic void iommu_flush_irt_all(struct amd_iommu *iommu)\r\n{\r\nu32 devid;\r\nfor (devid = 0; devid <= MAX_DEV_TABLE_ENTRIES; devid++)\r\niommu_flush_irt(iommu, devid);\r\niommu_completion_wait(iommu);\r\n}\r\nvoid iommu_flush_all_caches(struct amd_iommu *iommu)\r\n{\r\nif (iommu_feature(iommu, FEATURE_IA)) {\r\niommu_flush_all(iommu);\r\n} else {\r\niommu_flush_dte_all(iommu);\r\niommu_flush_irt_all(iommu);\r\niommu_flush_tlb_all(iommu);\r\n}\r\n}\r\nstatic int device_flush_iotlb(struct iommu_dev_data *dev_data,\r\nu64 address, size_t size)\r\n{\r\nstruct amd_iommu *iommu;\r\nstruct iommu_cmd cmd;\r\nint qdep;\r\nqdep = dev_data->ats.qdep;\r\niommu = amd_iommu_rlookup_table[dev_data->devid];\r\nbuild_inv_iotlb_pages(&cmd, dev_data->devid, qdep, address, size);\r\nreturn iommu_queue_command(iommu, &cmd);\r\n}\r\nstatic int device_flush_dte(struct iommu_dev_data *dev_data)\r\n{\r\nstruct amd_iommu *iommu;\r\nint ret;\r\niommu = amd_iommu_rlookup_table[dev_data->devid];\r\nret = iommu_flush_dte(iommu, dev_data->devid);\r\nif (ret)\r\nreturn ret;\r\nif (dev_data->ats.enabled)\r\nret = device_flush_iotlb(dev_data, 0, ~0UL);\r\nreturn ret;\r\n}\r\nstatic void __domain_flush_pages(struct protection_domain *domain,\r\nu64 address, size_t size, int pde)\r\n{\r\nstruct iommu_dev_data *dev_data;\r\nstruct iommu_cmd cmd;\r\nint ret = 0, i;\r\nbuild_inv_iommu_pages(&cmd, address, size, domain->id, pde);\r\nfor (i = 0; i < amd_iommus_present; ++i) {\r\nif (!domain->dev_iommu[i])\r\ncontinue;\r\nret |= iommu_queue_command(amd_iommus[i], &cmd);\r\n}\r\nlist_for_each_entry(dev_data, &domain->dev_list, list) {\r\nif (!dev_data->ats.enabled)\r\ncontinue;\r\nret |= device_flush_iotlb(dev_data, address, size);\r\n}\r\nWARN_ON(ret);\r\n}\r\nstatic void domain_flush_pages(struct protection_domain *domain,\r\nu64 address, size_t size)\r\n{\r\n__domain_flush_pages(domain, address, size, 0);\r\n}\r\nstatic void domain_flush_tlb(struct protection_domain *domain)\r\n{\r\n__domain_flush_pages(domain, 0, CMD_INV_IOMMU_ALL_PAGES_ADDRESS, 0);\r\n}\r\nstatic void domain_flush_tlb_pde(struct protection_domain *domain)\r\n{\r\n__domain_flush_pages(domain, 0, CMD_INV_IOMMU_ALL_PAGES_ADDRESS, 1);\r\n}\r\nstatic void domain_flush_complete(struct protection_domain *domain)\r\n{\r\nint i;\r\nfor (i = 0; i < amd_iommus_present; ++i) {\r\nif (!domain->dev_iommu[i])\r\ncontinue;\r\niommu_completion_wait(amd_iommus[i]);\r\n}\r\n}\r\nstatic void domain_flush_devices(struct protection_domain *domain)\r\n{\r\nstruct iommu_dev_data *dev_data;\r\nlist_for_each_entry(dev_data, &domain->dev_list, list)\r\ndevice_flush_dte(dev_data);\r\n}\r\nstatic bool increase_address_space(struct protection_domain *domain,\r\ngfp_t gfp)\r\n{\r\nu64 *pte;\r\nif (domain->mode == PAGE_MODE_6_LEVEL)\r\nreturn false;\r\npte = (void *)get_zeroed_page(gfp);\r\nif (!pte)\r\nreturn false;\r\n*pte = PM_LEVEL_PDE(domain->mode,\r\nvirt_to_phys(domain->pt_root));\r\ndomain->pt_root = pte;\r\ndomain->mode += 1;\r\ndomain->updated = true;\r\nreturn true;\r\n}\r\nstatic u64 *alloc_pte(struct protection_domain *domain,\r\nunsigned long address,\r\nunsigned long page_size,\r\nu64 **pte_page,\r\ngfp_t gfp)\r\n{\r\nint level, end_lvl;\r\nu64 *pte, *page;\r\nBUG_ON(!is_power_of_2(page_size));\r\nwhile (address > PM_LEVEL_SIZE(domain->mode))\r\nincrease_address_space(domain, gfp);\r\nlevel = domain->mode - 1;\r\npte = &domain->pt_root[PM_LEVEL_INDEX(level, address)];\r\naddress = PAGE_SIZE_ALIGN(address, page_size);\r\nend_lvl = PAGE_SIZE_LEVEL(page_size);\r\nwhile (level > end_lvl) {\r\nif (!IOMMU_PTE_PRESENT(*pte)) {\r\npage = (u64 *)get_zeroed_page(gfp);\r\nif (!page)\r\nreturn NULL;\r\n*pte = PM_LEVEL_PDE(level, virt_to_phys(page));\r\n}\r\nif (PM_PTE_LEVEL(*pte) != level)\r\nreturn NULL;\r\nlevel -= 1;\r\npte = IOMMU_PTE_PAGE(*pte);\r\nif (pte_page && level == end_lvl)\r\n*pte_page = pte;\r\npte = &pte[PM_LEVEL_INDEX(level, address)];\r\n}\r\nreturn pte;\r\n}\r\nstatic u64 *fetch_pte(struct protection_domain *domain, unsigned long address)\r\n{\r\nint level;\r\nu64 *pte;\r\nif (address > PM_LEVEL_SIZE(domain->mode))\r\nreturn NULL;\r\nlevel = domain->mode - 1;\r\npte = &domain->pt_root[PM_LEVEL_INDEX(level, address)];\r\nwhile (level > 0) {\r\nif (!IOMMU_PTE_PRESENT(*pte))\r\nreturn NULL;\r\nif (PM_PTE_LEVEL(*pte) == 0x07) {\r\nunsigned long pte_mask, __pte;\r\npte_mask = PTE_PAGE_SIZE(*pte);\r\npte_mask = ~((PAGE_SIZE_PTE_COUNT(pte_mask) << 3) - 1);\r\n__pte = ((unsigned long)pte) & pte_mask;\r\nreturn (u64 *)__pte;\r\n}\r\nif (PM_PTE_LEVEL(*pte) != level)\r\nreturn NULL;\r\nlevel -= 1;\r\npte = IOMMU_PTE_PAGE(*pte);\r\npte = &pte[PM_LEVEL_INDEX(level, address)];\r\n}\r\nreturn pte;\r\n}\r\nstatic int iommu_map_page(struct protection_domain *dom,\r\nunsigned long bus_addr,\r\nunsigned long phys_addr,\r\nint prot,\r\nunsigned long page_size)\r\n{\r\nu64 __pte, *pte;\r\nint i, count;\r\nif (!(prot & IOMMU_PROT_MASK))\r\nreturn -EINVAL;\r\nbus_addr = PAGE_ALIGN(bus_addr);\r\nphys_addr = PAGE_ALIGN(phys_addr);\r\ncount = PAGE_SIZE_PTE_COUNT(page_size);\r\npte = alloc_pte(dom, bus_addr, page_size, NULL, GFP_KERNEL);\r\nfor (i = 0; i < count; ++i)\r\nif (IOMMU_PTE_PRESENT(pte[i]))\r\nreturn -EBUSY;\r\nif (page_size > PAGE_SIZE) {\r\n__pte = PAGE_SIZE_PTE(phys_addr, page_size);\r\n__pte |= PM_LEVEL_ENC(7) | IOMMU_PTE_P | IOMMU_PTE_FC;\r\n} else\r\n__pte = phys_addr | IOMMU_PTE_P | IOMMU_PTE_FC;\r\nif (prot & IOMMU_PROT_IR)\r\n__pte |= IOMMU_PTE_IR;\r\nif (prot & IOMMU_PROT_IW)\r\n__pte |= IOMMU_PTE_IW;\r\nfor (i = 0; i < count; ++i)\r\npte[i] = __pte;\r\nupdate_domain(dom);\r\nreturn 0;\r\n}\r\nstatic unsigned long iommu_unmap_page(struct protection_domain *dom,\r\nunsigned long bus_addr,\r\nunsigned long page_size)\r\n{\r\nunsigned long long unmap_size, unmapped;\r\nu64 *pte;\r\nBUG_ON(!is_power_of_2(page_size));\r\nunmapped = 0;\r\nwhile (unmapped < page_size) {\r\npte = fetch_pte(dom, bus_addr);\r\nif (!pte) {\r\nunmap_size = PAGE_SIZE;\r\n} else if (PM_PTE_LEVEL(*pte) == 0) {\r\nunmap_size = PAGE_SIZE;\r\n*pte = 0ULL;\r\n} else {\r\nint count, i;\r\nunmap_size = PTE_PAGE_SIZE(*pte);\r\nif ((unmap_size - 1) & bus_addr)\r\nbreak;\r\ncount = PAGE_SIZE_PTE_COUNT(unmap_size);\r\nfor (i = 0; i < count; i++)\r\npte[i] = 0ULL;\r\n}\r\nbus_addr = (bus_addr & ~(unmap_size - 1)) + unmap_size;\r\nunmapped += unmap_size;\r\n}\r\nBUG_ON(unmapped && !is_power_of_2(unmapped));\r\nreturn unmapped;\r\n}\r\nstatic int iommu_for_unity_map(struct amd_iommu *iommu,\r\nstruct unity_map_entry *entry)\r\n{\r\nu16 bdf, i;\r\nfor (i = entry->devid_start; i <= entry->devid_end; ++i) {\r\nbdf = amd_iommu_alias_table[i];\r\nif (amd_iommu_rlookup_table[bdf] == iommu)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dma_ops_unity_map(struct dma_ops_domain *dma_dom,\r\nstruct unity_map_entry *e)\r\n{\r\nu64 addr;\r\nint ret;\r\nfor (addr = e->address_start; addr < e->address_end;\r\naddr += PAGE_SIZE) {\r\nret = iommu_map_page(&dma_dom->domain, addr, addr, e->prot,\r\nPAGE_SIZE);\r\nif (ret)\r\nreturn ret;\r\nif (addr < dma_dom->aperture_size)\r\n__set_bit(addr >> PAGE_SHIFT,\r\ndma_dom->aperture[0]->bitmap);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iommu_init_unity_mappings(struct amd_iommu *iommu)\r\n{\r\nstruct unity_map_entry *entry;\r\nint ret;\r\nlist_for_each_entry(entry, &amd_iommu_unity_map, list) {\r\nif (!iommu_for_unity_map(iommu, entry))\r\ncontinue;\r\nret = dma_ops_unity_map(iommu->default_dom, entry);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int init_unity_mappings_for_device(struct dma_ops_domain *dma_dom,\r\nu16 devid)\r\n{\r\nstruct unity_map_entry *e;\r\nint ret;\r\nlist_for_each_entry(e, &amd_iommu_unity_map, list) {\r\nif (!(devid >= e->devid_start && devid <= e->devid_end))\r\ncontinue;\r\nret = dma_ops_unity_map(dma_dom, e);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dma_ops_reserve_addresses(struct dma_ops_domain *dom,\r\nunsigned long start_page,\r\nunsigned int pages)\r\n{\r\nunsigned int i, last_page = dom->aperture_size >> PAGE_SHIFT;\r\nif (start_page + pages > last_page)\r\npages = last_page - start_page;\r\nfor (i = start_page; i < start_page + pages; ++i) {\r\nint index = i / APERTURE_RANGE_PAGES;\r\nint page = i % APERTURE_RANGE_PAGES;\r\n__set_bit(page, dom->aperture[index]->bitmap);\r\n}\r\n}\r\nstatic int alloc_new_range(struct dma_ops_domain *dma_dom,\r\nbool populate, gfp_t gfp)\r\n{\r\nint index = dma_dom->aperture_size >> APERTURE_RANGE_SHIFT;\r\nstruct amd_iommu *iommu;\r\nunsigned long i, old_size;\r\n#ifdef CONFIG_IOMMU_STRESS\r\npopulate = false;\r\n#endif\r\nif (index >= APERTURE_MAX_RANGES)\r\nreturn -ENOMEM;\r\ndma_dom->aperture[index] = kzalloc(sizeof(struct aperture_range), gfp);\r\nif (!dma_dom->aperture[index])\r\nreturn -ENOMEM;\r\ndma_dom->aperture[index]->bitmap = (void *)get_zeroed_page(gfp);\r\nif (!dma_dom->aperture[index]->bitmap)\r\ngoto out_free;\r\ndma_dom->aperture[index]->offset = dma_dom->aperture_size;\r\nif (populate) {\r\nunsigned long address = dma_dom->aperture_size;\r\nint i, num_ptes = APERTURE_RANGE_PAGES / 512;\r\nu64 *pte, *pte_page;\r\nfor (i = 0; i < num_ptes; ++i) {\r\npte = alloc_pte(&dma_dom->domain, address, PAGE_SIZE,\r\n&pte_page, gfp);\r\nif (!pte)\r\ngoto out_free;\r\ndma_dom->aperture[index]->pte_pages[i] = pte_page;\r\naddress += APERTURE_RANGE_SIZE / 64;\r\n}\r\n}\r\nold_size = dma_dom->aperture_size;\r\ndma_dom->aperture_size += APERTURE_RANGE_SIZE;\r\nif (old_size < MSI_ADDR_BASE_LO &&\r\ndma_dom->aperture_size > MSI_ADDR_BASE_LO) {\r\nunsigned long spage;\r\nint pages;\r\npages = iommu_num_pages(MSI_ADDR_BASE_LO, 0x10000, PAGE_SIZE);\r\nspage = MSI_ADDR_BASE_LO >> PAGE_SHIFT;\r\ndma_ops_reserve_addresses(dma_dom, spage, pages);\r\n}\r\nfor_each_iommu(iommu) {\r\nif (iommu->exclusion_start &&\r\niommu->exclusion_start >= dma_dom->aperture[index]->offset\r\n&& iommu->exclusion_start < dma_dom->aperture_size) {\r\nunsigned long startpage;\r\nint pages = iommu_num_pages(iommu->exclusion_start,\r\niommu->exclusion_length,\r\nPAGE_SIZE);\r\nstartpage = iommu->exclusion_start >> PAGE_SHIFT;\r\ndma_ops_reserve_addresses(dma_dom, startpage, pages);\r\n}\r\n}\r\nfor (i = dma_dom->aperture[index]->offset;\r\ni < dma_dom->aperture_size;\r\ni += PAGE_SIZE) {\r\nu64 *pte = fetch_pte(&dma_dom->domain, i);\r\nif (!pte || !IOMMU_PTE_PRESENT(*pte))\r\ncontinue;\r\ndma_ops_reserve_addresses(dma_dom, i >> PAGE_SHIFT, 1);\r\n}\r\nupdate_domain(&dma_dom->domain);\r\nreturn 0;\r\nout_free:\r\nupdate_domain(&dma_dom->domain);\r\nfree_page((unsigned long)dma_dom->aperture[index]->bitmap);\r\nkfree(dma_dom->aperture[index]);\r\ndma_dom->aperture[index] = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic unsigned long dma_ops_area_alloc(struct device *dev,\r\nstruct dma_ops_domain *dom,\r\nunsigned int pages,\r\nunsigned long align_mask,\r\nu64 dma_mask,\r\nunsigned long start)\r\n{\r\nunsigned long next_bit = dom->next_address % APERTURE_RANGE_SIZE;\r\nint max_index = dom->aperture_size >> APERTURE_RANGE_SHIFT;\r\nint i = start >> APERTURE_RANGE_SHIFT;\r\nunsigned long boundary_size;\r\nunsigned long address = -1;\r\nunsigned long limit;\r\nnext_bit >>= PAGE_SHIFT;\r\nboundary_size = ALIGN(dma_get_seg_boundary(dev) + 1,\r\nPAGE_SIZE) >> PAGE_SHIFT;\r\nfor (;i < max_index; ++i) {\r\nunsigned long offset = dom->aperture[i]->offset >> PAGE_SHIFT;\r\nif (dom->aperture[i]->offset >= dma_mask)\r\nbreak;\r\nlimit = iommu_device_max_index(APERTURE_RANGE_PAGES, offset,\r\ndma_mask >> PAGE_SHIFT);\r\naddress = iommu_area_alloc(dom->aperture[i]->bitmap,\r\nlimit, next_bit, pages, 0,\r\nboundary_size, align_mask);\r\nif (address != -1) {\r\naddress = dom->aperture[i]->offset +\r\n(address << PAGE_SHIFT);\r\ndom->next_address = address + (pages << PAGE_SHIFT);\r\nbreak;\r\n}\r\nnext_bit = 0;\r\n}\r\nreturn address;\r\n}\r\nstatic unsigned long dma_ops_alloc_addresses(struct device *dev,\r\nstruct dma_ops_domain *dom,\r\nunsigned int pages,\r\nunsigned long align_mask,\r\nu64 dma_mask)\r\n{\r\nunsigned long address;\r\n#ifdef CONFIG_IOMMU_STRESS\r\ndom->next_address = 0;\r\ndom->need_flush = true;\r\n#endif\r\naddress = dma_ops_area_alloc(dev, dom, pages, align_mask,\r\ndma_mask, dom->next_address);\r\nif (address == -1) {\r\ndom->next_address = 0;\r\naddress = dma_ops_area_alloc(dev, dom, pages, align_mask,\r\ndma_mask, 0);\r\ndom->need_flush = true;\r\n}\r\nif (unlikely(address == -1))\r\naddress = DMA_ERROR_CODE;\r\nWARN_ON((address + (PAGE_SIZE*pages)) > dom->aperture_size);\r\nreturn address;\r\n}\r\nstatic void dma_ops_free_addresses(struct dma_ops_domain *dom,\r\nunsigned long address,\r\nunsigned int pages)\r\n{\r\nunsigned i = address >> APERTURE_RANGE_SHIFT;\r\nstruct aperture_range *range = dom->aperture[i];\r\nBUG_ON(i >= APERTURE_MAX_RANGES || range == NULL);\r\n#ifdef CONFIG_IOMMU_STRESS\r\nif (i < 4)\r\nreturn;\r\n#endif\r\nif (address >= dom->next_address)\r\ndom->need_flush = true;\r\naddress = (address % APERTURE_RANGE_SIZE) >> PAGE_SHIFT;\r\nbitmap_clear(range->bitmap, address, pages);\r\n}\r\nstatic void add_domain_to_list(struct protection_domain *domain)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&amd_iommu_pd_lock, flags);\r\nlist_add(&domain->list, &amd_iommu_pd_list);\r\nspin_unlock_irqrestore(&amd_iommu_pd_lock, flags);\r\n}\r\nstatic void del_domain_from_list(struct protection_domain *domain)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&amd_iommu_pd_lock, flags);\r\nlist_del(&domain->list);\r\nspin_unlock_irqrestore(&amd_iommu_pd_lock, flags);\r\n}\r\nstatic u16 domain_id_alloc(void)\r\n{\r\nunsigned long flags;\r\nint id;\r\nwrite_lock_irqsave(&amd_iommu_devtable_lock, flags);\r\nid = find_first_zero_bit(amd_iommu_pd_alloc_bitmap, MAX_DOMAIN_ID);\r\nBUG_ON(id == 0);\r\nif (id > 0 && id < MAX_DOMAIN_ID)\r\n__set_bit(id, amd_iommu_pd_alloc_bitmap);\r\nelse\r\nid = 0;\r\nwrite_unlock_irqrestore(&amd_iommu_devtable_lock, flags);\r\nreturn id;\r\n}\r\nstatic void domain_id_free(int id)\r\n{\r\nunsigned long flags;\r\nwrite_lock_irqsave(&amd_iommu_devtable_lock, flags);\r\nif (id > 0 && id < MAX_DOMAIN_ID)\r\n__clear_bit(id, amd_iommu_pd_alloc_bitmap);\r\nwrite_unlock_irqrestore(&amd_iommu_devtable_lock, flags);\r\n}\r\nstatic void free_pagetable(struct protection_domain *domain)\r\n{\r\nunsigned long root = (unsigned long)domain->pt_root;\r\nswitch (domain->mode) {\r\ncase PAGE_MODE_NONE:\r\nbreak;\r\ncase PAGE_MODE_1_LEVEL:\r\nfree_page(root);\r\nbreak;\r\ncase PAGE_MODE_2_LEVEL:\r\nfree_pt_l2(root);\r\nbreak;\r\ncase PAGE_MODE_3_LEVEL:\r\nfree_pt_l3(root);\r\nbreak;\r\ncase PAGE_MODE_4_LEVEL:\r\nfree_pt_l4(root);\r\nbreak;\r\ncase PAGE_MODE_5_LEVEL:\r\nfree_pt_l5(root);\r\nbreak;\r\ncase PAGE_MODE_6_LEVEL:\r\nfree_pt_l6(root);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void free_gcr3_tbl_level1(u64 *tbl)\r\n{\r\nu64 *ptr;\r\nint i;\r\nfor (i = 0; i < 512; ++i) {\r\nif (!(tbl[i] & GCR3_VALID))\r\ncontinue;\r\nptr = __va(tbl[i] & PAGE_MASK);\r\nfree_page((unsigned long)ptr);\r\n}\r\n}\r\nstatic void free_gcr3_tbl_level2(u64 *tbl)\r\n{\r\nu64 *ptr;\r\nint i;\r\nfor (i = 0; i < 512; ++i) {\r\nif (!(tbl[i] & GCR3_VALID))\r\ncontinue;\r\nptr = __va(tbl[i] & PAGE_MASK);\r\nfree_gcr3_tbl_level1(ptr);\r\n}\r\n}\r\nstatic void free_gcr3_table(struct protection_domain *domain)\r\n{\r\nif (domain->glx == 2)\r\nfree_gcr3_tbl_level2(domain->gcr3_tbl);\r\nelse if (domain->glx == 1)\r\nfree_gcr3_tbl_level1(domain->gcr3_tbl);\r\nelse if (domain->glx != 0)\r\nBUG();\r\nfree_page((unsigned long)domain->gcr3_tbl);\r\n}\r\nstatic void dma_ops_domain_free(struct dma_ops_domain *dom)\r\n{\r\nint i;\r\nif (!dom)\r\nreturn;\r\ndel_domain_from_list(&dom->domain);\r\nfree_pagetable(&dom->domain);\r\nfor (i = 0; i < APERTURE_MAX_RANGES; ++i) {\r\nif (!dom->aperture[i])\r\ncontinue;\r\nfree_page((unsigned long)dom->aperture[i]->bitmap);\r\nkfree(dom->aperture[i]);\r\n}\r\nkfree(dom);\r\n}\r\nstatic struct dma_ops_domain *dma_ops_domain_alloc(void)\r\n{\r\nstruct dma_ops_domain *dma_dom;\r\ndma_dom = kzalloc(sizeof(struct dma_ops_domain), GFP_KERNEL);\r\nif (!dma_dom)\r\nreturn NULL;\r\nspin_lock_init(&dma_dom->domain.lock);\r\ndma_dom->domain.id = domain_id_alloc();\r\nif (dma_dom->domain.id == 0)\r\ngoto free_dma_dom;\r\nINIT_LIST_HEAD(&dma_dom->domain.dev_list);\r\ndma_dom->domain.mode = PAGE_MODE_2_LEVEL;\r\ndma_dom->domain.pt_root = (void *)get_zeroed_page(GFP_KERNEL);\r\ndma_dom->domain.flags = PD_DMA_OPS_MASK;\r\ndma_dom->domain.priv = dma_dom;\r\nif (!dma_dom->domain.pt_root)\r\ngoto free_dma_dom;\r\ndma_dom->need_flush = false;\r\ndma_dom->target_dev = 0xffff;\r\nadd_domain_to_list(&dma_dom->domain);\r\nif (alloc_new_range(dma_dom, true, GFP_KERNEL))\r\ngoto free_dma_dom;\r\ndma_dom->aperture[0]->bitmap[0] = 1;\r\ndma_dom->next_address = 0;\r\nreturn dma_dom;\r\nfree_dma_dom:\r\ndma_ops_domain_free(dma_dom);\r\nreturn NULL;\r\n}\r\nstatic bool dma_ops_domain(struct protection_domain *domain)\r\n{\r\nreturn domain->flags & PD_DMA_OPS_MASK;\r\n}\r\nstatic void set_dte_entry(u16 devid, struct protection_domain *domain, bool ats)\r\n{\r\nu64 pte_root = 0;\r\nu64 flags = 0;\r\nif (domain->mode != PAGE_MODE_NONE)\r\npte_root = virt_to_phys(domain->pt_root);\r\npte_root |= (domain->mode & DEV_ENTRY_MODE_MASK)\r\n<< DEV_ENTRY_MODE_SHIFT;\r\npte_root |= IOMMU_PTE_IR | IOMMU_PTE_IW | IOMMU_PTE_P | IOMMU_PTE_TV;\r\nflags = amd_iommu_dev_table[devid].data[1];\r\nif (ats)\r\nflags |= DTE_FLAG_IOTLB;\r\nif (domain->flags & PD_IOMMUV2_MASK) {\r\nu64 gcr3 = __pa(domain->gcr3_tbl);\r\nu64 glx = domain->glx;\r\nu64 tmp;\r\npte_root |= DTE_FLAG_GV;\r\npte_root |= (glx & DTE_GLX_MASK) << DTE_GLX_SHIFT;\r\ntmp = DTE_GCR3_VAL_B(~0ULL) << DTE_GCR3_SHIFT_B;\r\nflags &= ~tmp;\r\ntmp = DTE_GCR3_VAL_C(~0ULL) << DTE_GCR3_SHIFT_C;\r\nflags &= ~tmp;\r\ntmp = DTE_GCR3_VAL_A(gcr3) << DTE_GCR3_SHIFT_A;\r\npte_root |= tmp;\r\ntmp = DTE_GCR3_VAL_B(gcr3) << DTE_GCR3_SHIFT_B;\r\nflags |= tmp;\r\ntmp = DTE_GCR3_VAL_C(gcr3) << DTE_GCR3_SHIFT_C;\r\nflags |= tmp;\r\n}\r\nflags &= ~(0xffffUL);\r\nflags |= domain->id;\r\namd_iommu_dev_table[devid].data[1] = flags;\r\namd_iommu_dev_table[devid].data[0] = pte_root;\r\n}\r\nstatic void clear_dte_entry(u16 devid)\r\n{\r\namd_iommu_dev_table[devid].data[0] = IOMMU_PTE_P | IOMMU_PTE_TV;\r\namd_iommu_dev_table[devid].data[1] = 0;\r\namd_iommu_apply_erratum_63(devid);\r\n}\r\nstatic void do_attach(struct iommu_dev_data *dev_data,\r\nstruct protection_domain *domain)\r\n{\r\nstruct amd_iommu *iommu;\r\nbool ats;\r\niommu = amd_iommu_rlookup_table[dev_data->devid];\r\nats = dev_data->ats.enabled;\r\ndev_data->domain = domain;\r\nlist_add(&dev_data->list, &domain->dev_list);\r\nset_dte_entry(dev_data->devid, domain, ats);\r\ndomain->dev_iommu[iommu->index] += 1;\r\ndomain->dev_cnt += 1;\r\ndevice_flush_dte(dev_data);\r\n}\r\nstatic void do_detach(struct iommu_dev_data *dev_data)\r\n{\r\nstruct amd_iommu *iommu;\r\niommu = amd_iommu_rlookup_table[dev_data->devid];\r\ndev_data->domain->dev_iommu[iommu->index] -= 1;\r\ndev_data->domain->dev_cnt -= 1;\r\ndev_data->domain = NULL;\r\nlist_del(&dev_data->list);\r\nclear_dte_entry(dev_data->devid);\r\ndevice_flush_dte(dev_data);\r\n}\r\nstatic int __attach_device(struct iommu_dev_data *dev_data,\r\nstruct protection_domain *domain)\r\n{\r\nint ret;\r\nspin_lock(&domain->lock);\r\nif (dev_data->alias_data != NULL) {\r\nstruct iommu_dev_data *alias_data = dev_data->alias_data;\r\nret = -EBUSY;\r\nif (alias_data->domain != NULL &&\r\nalias_data->domain != domain)\r\ngoto out_unlock;\r\nif (dev_data->domain != NULL &&\r\ndev_data->domain != domain)\r\ngoto out_unlock;\r\nif (alias_data->domain == NULL)\r\ndo_attach(alias_data, domain);\r\natomic_inc(&alias_data->bind);\r\n}\r\nif (dev_data->domain == NULL)\r\ndo_attach(dev_data, domain);\r\natomic_inc(&dev_data->bind);\r\nret = 0;\r\nout_unlock:\r\nspin_unlock(&domain->lock);\r\nreturn ret;\r\n}\r\nstatic void pdev_iommuv2_disable(struct pci_dev *pdev)\r\n{\r\npci_disable_ats(pdev);\r\npci_disable_pri(pdev);\r\npci_disable_pasid(pdev);\r\n}\r\nstatic int pri_reset_while_enabled(struct pci_dev *pdev)\r\n{\r\nu16 control;\r\nint pos;\r\npos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_PRI);\r\nif (!pos)\r\nreturn -EINVAL;\r\npci_read_config_word(pdev, pos + PCI_PRI_CTRL, &control);\r\ncontrol |= PCI_PRI_CTRL_RESET;\r\npci_write_config_word(pdev, pos + PCI_PRI_CTRL, control);\r\nreturn 0;\r\n}\r\nstatic int pdev_iommuv2_enable(struct pci_dev *pdev)\r\n{\r\nbool reset_enable;\r\nint reqs, ret;\r\nreqs = 32;\r\nif (pdev_pri_erratum(pdev, AMD_PRI_DEV_ERRATUM_LIMIT_REQ_ONE))\r\nreqs = 1;\r\nreset_enable = pdev_pri_erratum(pdev, AMD_PRI_DEV_ERRATUM_ENABLE_RESET);\r\nret = pci_enable_pasid(pdev, 0);\r\nif (ret)\r\ngoto out_err;\r\nret = pci_reset_pri(pdev);\r\nif (ret)\r\ngoto out_err;\r\nret = pci_enable_pri(pdev, reqs);\r\nif (ret)\r\ngoto out_err;\r\nif (reset_enable) {\r\nret = pri_reset_while_enabled(pdev);\r\nif (ret)\r\ngoto out_err;\r\n}\r\nret = pci_enable_ats(pdev, PAGE_SHIFT);\r\nif (ret)\r\ngoto out_err;\r\nreturn 0;\r\nout_err:\r\npci_disable_pri(pdev);\r\npci_disable_pasid(pdev);\r\nreturn ret;\r\n}\r\nstatic bool pci_pri_tlp_required(struct pci_dev *pdev)\r\n{\r\nu16 status;\r\nint pos;\r\npos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_PRI);\r\nif (!pos)\r\nreturn false;\r\npci_read_config_word(pdev, pos + PCI_PRI_STATUS, &status);\r\nreturn (status & PCI_PRI_TLP_OFF) ? true : false;\r\n}\r\nstatic int attach_device(struct device *dev,\r\nstruct protection_domain *domain)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct iommu_dev_data *dev_data;\r\nunsigned long flags;\r\nint ret;\r\ndev_data = get_dev_data(dev);\r\nif (domain->flags & PD_IOMMUV2_MASK) {\r\nif (!dev_data->iommu_v2 || !dev_data->passthrough)\r\nreturn -EINVAL;\r\nif (pdev_iommuv2_enable(pdev) != 0)\r\nreturn -EINVAL;\r\ndev_data->ats.enabled = true;\r\ndev_data->ats.qdep = pci_ats_queue_depth(pdev);\r\ndev_data->pri_tlp = pci_pri_tlp_required(pdev);\r\n} else if (amd_iommu_iotlb_sup &&\r\npci_enable_ats(pdev, PAGE_SHIFT) == 0) {\r\ndev_data->ats.enabled = true;\r\ndev_data->ats.qdep = pci_ats_queue_depth(pdev);\r\n}\r\nwrite_lock_irqsave(&amd_iommu_devtable_lock, flags);\r\nret = __attach_device(dev_data, domain);\r\nwrite_unlock_irqrestore(&amd_iommu_devtable_lock, flags);\r\ndomain_flush_tlb_pde(domain);\r\nreturn ret;\r\n}\r\nstatic void __detach_device(struct iommu_dev_data *dev_data)\r\n{\r\nstruct protection_domain *domain;\r\nunsigned long flags;\r\nBUG_ON(!dev_data->domain);\r\ndomain = dev_data->domain;\r\nspin_lock_irqsave(&domain->lock, flags);\r\nif (dev_data->alias_data != NULL) {\r\nstruct iommu_dev_data *alias_data = dev_data->alias_data;\r\nif (atomic_dec_and_test(&alias_data->bind))\r\ndo_detach(alias_data);\r\n}\r\nif (atomic_dec_and_test(&dev_data->bind))\r\ndo_detach(dev_data);\r\nspin_unlock_irqrestore(&domain->lock, flags);\r\nif (dev_data->passthrough &&\r\n(dev_data->domain == NULL && domain != pt_domain))\r\n__attach_device(dev_data, pt_domain);\r\n}\r\nstatic void detach_device(struct device *dev)\r\n{\r\nstruct protection_domain *domain;\r\nstruct iommu_dev_data *dev_data;\r\nunsigned long flags;\r\ndev_data = get_dev_data(dev);\r\ndomain = dev_data->domain;\r\nwrite_lock_irqsave(&amd_iommu_devtable_lock, flags);\r\n__detach_device(dev_data);\r\nwrite_unlock_irqrestore(&amd_iommu_devtable_lock, flags);\r\nif (domain->flags & PD_IOMMUV2_MASK)\r\npdev_iommuv2_disable(to_pci_dev(dev));\r\nelse if (dev_data->ats.enabled)\r\npci_disable_ats(to_pci_dev(dev));\r\ndev_data->ats.enabled = false;\r\n}\r\nstatic struct protection_domain *domain_for_device(struct device *dev)\r\n{\r\nstruct iommu_dev_data *dev_data;\r\nstruct protection_domain *dom = NULL;\r\nunsigned long flags;\r\ndev_data = get_dev_data(dev);\r\nif (dev_data->domain)\r\nreturn dev_data->domain;\r\nif (dev_data->alias_data != NULL) {\r\nstruct iommu_dev_data *alias_data = dev_data->alias_data;\r\nread_lock_irqsave(&amd_iommu_devtable_lock, flags);\r\nif (alias_data->domain != NULL) {\r\n__attach_device(dev_data, alias_data->domain);\r\ndom = alias_data->domain;\r\n}\r\nread_unlock_irqrestore(&amd_iommu_devtable_lock, flags);\r\n}\r\nreturn dom;\r\n}\r\nstatic int device_change_notifier(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct dma_ops_domain *dma_domain;\r\nstruct protection_domain *domain;\r\nstruct iommu_dev_data *dev_data;\r\nstruct device *dev = data;\r\nstruct amd_iommu *iommu;\r\nunsigned long flags;\r\nu16 devid;\r\nif (!check_device(dev))\r\nreturn 0;\r\ndevid = get_device_id(dev);\r\niommu = amd_iommu_rlookup_table[devid];\r\ndev_data = get_dev_data(dev);\r\nswitch (action) {\r\ncase BUS_NOTIFY_UNBOUND_DRIVER:\r\ndomain = domain_for_device(dev);\r\nif (!domain)\r\ngoto out;\r\nif (dev_data->passthrough)\r\nbreak;\r\ndetach_device(dev);\r\nbreak;\r\ncase BUS_NOTIFY_ADD_DEVICE:\r\niommu_init_device(dev);\r\ndev_data = get_dev_data(dev);\r\nif (iommu_pass_through || dev_data->iommu_v2) {\r\ndev_data->passthrough = true;\r\nattach_device(dev, pt_domain);\r\nbreak;\r\n}\r\ndomain = domain_for_device(dev);\r\ndma_domain = find_protection_domain(devid);\r\nif (!dma_domain) {\r\ndma_domain = dma_ops_domain_alloc();\r\nif (!dma_domain)\r\ngoto out;\r\ndma_domain->target_dev = devid;\r\nspin_lock_irqsave(&iommu_pd_list_lock, flags);\r\nlist_add_tail(&dma_domain->list, &iommu_pd_list);\r\nspin_unlock_irqrestore(&iommu_pd_list_lock, flags);\r\n}\r\ndev->archdata.dma_ops = &amd_iommu_dma_ops;\r\nbreak;\r\ncase BUS_NOTIFY_DEL_DEVICE:\r\niommu_uninit_device(dev);\r\ndefault:\r\ngoto out;\r\n}\r\niommu_completion_wait(iommu);\r\nout:\r\nreturn 0;\r\n}\r\nvoid amd_iommu_init_notifier(void)\r\n{\r\nbus_register_notifier(&pci_bus_type, &device_nb);\r\n}\r\nstatic struct protection_domain *get_domain(struct device *dev)\r\n{\r\nstruct protection_domain *domain;\r\nstruct dma_ops_domain *dma_dom;\r\nu16 devid = get_device_id(dev);\r\nif (!check_device(dev))\r\nreturn ERR_PTR(-EINVAL);\r\ndomain = domain_for_device(dev);\r\nif (domain != NULL && !dma_ops_domain(domain))\r\nreturn ERR_PTR(-EBUSY);\r\nif (domain != NULL)\r\nreturn domain;\r\ndma_dom = find_protection_domain(devid);\r\nif (!dma_dom)\r\ndma_dom = amd_iommu_rlookup_table[devid]->default_dom;\r\nattach_device(dev, &dma_dom->domain);\r\nDUMP_printk("Using protection domain %d for device %s\n",\r\ndma_dom->domain.id, dev_name(dev));\r\nreturn &dma_dom->domain;\r\n}\r\nstatic void update_device_table(struct protection_domain *domain)\r\n{\r\nstruct iommu_dev_data *dev_data;\r\nlist_for_each_entry(dev_data, &domain->dev_list, list)\r\nset_dte_entry(dev_data->devid, domain, dev_data->ats.enabled);\r\n}\r\nstatic void update_domain(struct protection_domain *domain)\r\n{\r\nif (!domain->updated)\r\nreturn;\r\nupdate_device_table(domain);\r\ndomain_flush_devices(domain);\r\ndomain_flush_tlb_pde(domain);\r\ndomain->updated = false;\r\n}\r\nstatic u64* dma_ops_get_pte(struct dma_ops_domain *dom,\r\nunsigned long address)\r\n{\r\nstruct aperture_range *aperture;\r\nu64 *pte, *pte_page;\r\naperture = dom->aperture[APERTURE_RANGE_INDEX(address)];\r\nif (!aperture)\r\nreturn NULL;\r\npte = aperture->pte_pages[APERTURE_PAGE_INDEX(address)];\r\nif (!pte) {\r\npte = alloc_pte(&dom->domain, address, PAGE_SIZE, &pte_page,\r\nGFP_ATOMIC);\r\naperture->pte_pages[APERTURE_PAGE_INDEX(address)] = pte_page;\r\n} else\r\npte += PM_LEVEL_INDEX(0, address);\r\nupdate_domain(&dom->domain);\r\nreturn pte;\r\n}\r\nstatic dma_addr_t dma_ops_domain_map(struct dma_ops_domain *dom,\r\nunsigned long address,\r\nphys_addr_t paddr,\r\nint direction)\r\n{\r\nu64 *pte, __pte;\r\nWARN_ON(address > dom->aperture_size);\r\npaddr &= PAGE_MASK;\r\npte = dma_ops_get_pte(dom, address);\r\nif (!pte)\r\nreturn DMA_ERROR_CODE;\r\n__pte = paddr | IOMMU_PTE_P | IOMMU_PTE_FC;\r\nif (direction == DMA_TO_DEVICE)\r\n__pte |= IOMMU_PTE_IR;\r\nelse if (direction == DMA_FROM_DEVICE)\r\n__pte |= IOMMU_PTE_IW;\r\nelse if (direction == DMA_BIDIRECTIONAL)\r\n__pte |= IOMMU_PTE_IR | IOMMU_PTE_IW;\r\nWARN_ON(*pte);\r\n*pte = __pte;\r\nreturn (dma_addr_t)address;\r\n}\r\nstatic void dma_ops_domain_unmap(struct dma_ops_domain *dom,\r\nunsigned long address)\r\n{\r\nstruct aperture_range *aperture;\r\nu64 *pte;\r\nif (address >= dom->aperture_size)\r\nreturn;\r\naperture = dom->aperture[APERTURE_RANGE_INDEX(address)];\r\nif (!aperture)\r\nreturn;\r\npte = aperture->pte_pages[APERTURE_PAGE_INDEX(address)];\r\nif (!pte)\r\nreturn;\r\npte += PM_LEVEL_INDEX(0, address);\r\nWARN_ON(!*pte);\r\n*pte = 0ULL;\r\n}\r\nstatic dma_addr_t __map_single(struct device *dev,\r\nstruct dma_ops_domain *dma_dom,\r\nphys_addr_t paddr,\r\nsize_t size,\r\nint dir,\r\nbool align,\r\nu64 dma_mask)\r\n{\r\ndma_addr_t offset = paddr & ~PAGE_MASK;\r\ndma_addr_t address, start, ret;\r\nunsigned int pages;\r\nunsigned long align_mask = 0;\r\nint i;\r\npages = iommu_num_pages(paddr, size, PAGE_SIZE);\r\npaddr &= PAGE_MASK;\r\nINC_STATS_COUNTER(total_map_requests);\r\nif (pages > 1)\r\nINC_STATS_COUNTER(cross_page);\r\nif (align)\r\nalign_mask = (1UL << get_order(size)) - 1;\r\nretry:\r\naddress = dma_ops_alloc_addresses(dev, dma_dom, pages, align_mask,\r\ndma_mask);\r\nif (unlikely(address == DMA_ERROR_CODE)) {\r\ndma_dom->next_address = dma_dom->aperture_size;\r\nif (alloc_new_range(dma_dom, false, GFP_ATOMIC))\r\ngoto out;\r\ngoto retry;\r\n}\r\nstart = address;\r\nfor (i = 0; i < pages; ++i) {\r\nret = dma_ops_domain_map(dma_dom, start, paddr, dir);\r\nif (ret == DMA_ERROR_CODE)\r\ngoto out_unmap;\r\npaddr += PAGE_SIZE;\r\nstart += PAGE_SIZE;\r\n}\r\naddress += offset;\r\nADD_STATS_COUNTER(alloced_io_mem, size);\r\nif (unlikely(dma_dom->need_flush && !amd_iommu_unmap_flush)) {\r\ndomain_flush_tlb(&dma_dom->domain);\r\ndma_dom->need_flush = false;\r\n} else if (unlikely(amd_iommu_np_cache))\r\ndomain_flush_pages(&dma_dom->domain, address, size);\r\nout:\r\nreturn address;\r\nout_unmap:\r\nfor (--i; i >= 0; --i) {\r\nstart -= PAGE_SIZE;\r\ndma_ops_domain_unmap(dma_dom, start);\r\n}\r\ndma_ops_free_addresses(dma_dom, address, pages);\r\nreturn DMA_ERROR_CODE;\r\n}\r\nstatic void __unmap_single(struct dma_ops_domain *dma_dom,\r\ndma_addr_t dma_addr,\r\nsize_t size,\r\nint dir)\r\n{\r\ndma_addr_t flush_addr;\r\ndma_addr_t i, start;\r\nunsigned int pages;\r\nif ((dma_addr == DMA_ERROR_CODE) ||\r\n(dma_addr + size > dma_dom->aperture_size))\r\nreturn;\r\nflush_addr = dma_addr;\r\npages = iommu_num_pages(dma_addr, size, PAGE_SIZE);\r\ndma_addr &= PAGE_MASK;\r\nstart = dma_addr;\r\nfor (i = 0; i < pages; ++i) {\r\ndma_ops_domain_unmap(dma_dom, start);\r\nstart += PAGE_SIZE;\r\n}\r\nSUB_STATS_COUNTER(alloced_io_mem, size);\r\ndma_ops_free_addresses(dma_dom, dma_addr, pages);\r\nif (amd_iommu_unmap_flush || dma_dom->need_flush) {\r\ndomain_flush_pages(&dma_dom->domain, flush_addr, size);\r\ndma_dom->need_flush = false;\r\n}\r\n}\r\nstatic dma_addr_t map_page(struct device *dev, struct page *page,\r\nunsigned long offset, size_t size,\r\nenum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nunsigned long flags;\r\nstruct protection_domain *domain;\r\ndma_addr_t addr;\r\nu64 dma_mask;\r\nphys_addr_t paddr = page_to_phys(page) + offset;\r\nINC_STATS_COUNTER(cnt_map_single);\r\ndomain = get_domain(dev);\r\nif (PTR_ERR(domain) == -EINVAL)\r\nreturn (dma_addr_t)paddr;\r\nelse if (IS_ERR(domain))\r\nreturn DMA_ERROR_CODE;\r\ndma_mask = *dev->dma_mask;\r\nspin_lock_irqsave(&domain->lock, flags);\r\naddr = __map_single(dev, domain->priv, paddr, size, dir, false,\r\ndma_mask);\r\nif (addr == DMA_ERROR_CODE)\r\ngoto out;\r\ndomain_flush_complete(domain);\r\nout:\r\nspin_unlock_irqrestore(&domain->lock, flags);\r\nreturn addr;\r\n}\r\nstatic void unmap_page(struct device *dev, dma_addr_t dma_addr, size_t size,\r\nenum dma_data_direction dir, struct dma_attrs *attrs)\r\n{\r\nunsigned long flags;\r\nstruct protection_domain *domain;\r\nINC_STATS_COUNTER(cnt_unmap_single);\r\ndomain = get_domain(dev);\r\nif (IS_ERR(domain))\r\nreturn;\r\nspin_lock_irqsave(&domain->lock, flags);\r\n__unmap_single(domain->priv, dma_addr, size, dir);\r\ndomain_flush_complete(domain);\r\nspin_unlock_irqrestore(&domain->lock, flags);\r\n}\r\nstatic int map_sg(struct device *dev, struct scatterlist *sglist,\r\nint nelems, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nunsigned long flags;\r\nstruct protection_domain *domain;\r\nint i;\r\nstruct scatterlist *s;\r\nphys_addr_t paddr;\r\nint mapped_elems = 0;\r\nu64 dma_mask;\r\nINC_STATS_COUNTER(cnt_map_sg);\r\ndomain = get_domain(dev);\r\nif (IS_ERR(domain))\r\nreturn 0;\r\ndma_mask = *dev->dma_mask;\r\nspin_lock_irqsave(&domain->lock, flags);\r\nfor_each_sg(sglist, s, nelems, i) {\r\npaddr = sg_phys(s);\r\ns->dma_address = __map_single(dev, domain->priv,\r\npaddr, s->length, dir, false,\r\ndma_mask);\r\nif (s->dma_address) {\r\ns->dma_length = s->length;\r\nmapped_elems++;\r\n} else\r\ngoto unmap;\r\n}\r\ndomain_flush_complete(domain);\r\nout:\r\nspin_unlock_irqrestore(&domain->lock, flags);\r\nreturn mapped_elems;\r\nunmap:\r\nfor_each_sg(sglist, s, mapped_elems, i) {\r\nif (s->dma_address)\r\n__unmap_single(domain->priv, s->dma_address,\r\ns->dma_length, dir);\r\ns->dma_address = s->dma_length = 0;\r\n}\r\nmapped_elems = 0;\r\ngoto out;\r\n}\r\nstatic void unmap_sg(struct device *dev, struct scatterlist *sglist,\r\nint nelems, enum dma_data_direction dir,\r\nstruct dma_attrs *attrs)\r\n{\r\nunsigned long flags;\r\nstruct protection_domain *domain;\r\nstruct scatterlist *s;\r\nint i;\r\nINC_STATS_COUNTER(cnt_unmap_sg);\r\ndomain = get_domain(dev);\r\nif (IS_ERR(domain))\r\nreturn;\r\nspin_lock_irqsave(&domain->lock, flags);\r\nfor_each_sg(sglist, s, nelems, i) {\r\n__unmap_single(domain->priv, s->dma_address,\r\ns->dma_length, dir);\r\ns->dma_address = s->dma_length = 0;\r\n}\r\ndomain_flush_complete(domain);\r\nspin_unlock_irqrestore(&domain->lock, flags);\r\n}\r\nstatic void *alloc_coherent(struct device *dev, size_t size,\r\ndma_addr_t *dma_addr, gfp_t flag,\r\nstruct dma_attrs *attrs)\r\n{\r\nunsigned long flags;\r\nvoid *virt_addr;\r\nstruct protection_domain *domain;\r\nphys_addr_t paddr;\r\nu64 dma_mask = dev->coherent_dma_mask;\r\nINC_STATS_COUNTER(cnt_alloc_coherent);\r\ndomain = get_domain(dev);\r\nif (PTR_ERR(domain) == -EINVAL) {\r\nvirt_addr = (void *)__get_free_pages(flag, get_order(size));\r\n*dma_addr = __pa(virt_addr);\r\nreturn virt_addr;\r\n} else if (IS_ERR(domain))\r\nreturn NULL;\r\ndma_mask = dev->coherent_dma_mask;\r\nflag &= ~(__GFP_DMA | __GFP_HIGHMEM | __GFP_DMA32);\r\nflag |= __GFP_ZERO;\r\nvirt_addr = (void *)__get_free_pages(flag, get_order(size));\r\nif (!virt_addr)\r\nreturn NULL;\r\npaddr = virt_to_phys(virt_addr);\r\nif (!dma_mask)\r\ndma_mask = *dev->dma_mask;\r\nspin_lock_irqsave(&domain->lock, flags);\r\n*dma_addr = __map_single(dev, domain->priv, paddr,\r\nsize, DMA_BIDIRECTIONAL, true, dma_mask);\r\nif (*dma_addr == DMA_ERROR_CODE) {\r\nspin_unlock_irqrestore(&domain->lock, flags);\r\ngoto out_free;\r\n}\r\ndomain_flush_complete(domain);\r\nspin_unlock_irqrestore(&domain->lock, flags);\r\nreturn virt_addr;\r\nout_free:\r\nfree_pages((unsigned long)virt_addr, get_order(size));\r\nreturn NULL;\r\n}\r\nstatic void free_coherent(struct device *dev, size_t size,\r\nvoid *virt_addr, dma_addr_t dma_addr,\r\nstruct dma_attrs *attrs)\r\n{\r\nunsigned long flags;\r\nstruct protection_domain *domain;\r\nINC_STATS_COUNTER(cnt_free_coherent);\r\ndomain = get_domain(dev);\r\nif (IS_ERR(domain))\r\ngoto free_mem;\r\nspin_lock_irqsave(&domain->lock, flags);\r\n__unmap_single(domain->priv, dma_addr, size, DMA_BIDIRECTIONAL);\r\ndomain_flush_complete(domain);\r\nspin_unlock_irqrestore(&domain->lock, flags);\r\nfree_mem:\r\nfree_pages((unsigned long)virt_addr, get_order(size));\r\n}\r\nstatic int amd_iommu_dma_supported(struct device *dev, u64 mask)\r\n{\r\nreturn check_device(dev);\r\n}\r\nstatic void __init prealloc_protection_domains(void)\r\n{\r\nstruct iommu_dev_data *dev_data;\r\nstruct dma_ops_domain *dma_dom;\r\nstruct pci_dev *dev = NULL;\r\nu16 devid;\r\nfor_each_pci_dev(dev) {\r\nif (!check_device(&dev->dev))\r\ncontinue;\r\ndev_data = get_dev_data(&dev->dev);\r\nif (!amd_iommu_force_isolation && dev_data->iommu_v2) {\r\nalloc_passthrough_domain();\r\ndev_data->passthrough = true;\r\nattach_device(&dev->dev, pt_domain);\r\npr_info("AMD-Vi: Using passthrough domain for device %s\n",\r\ndev_name(&dev->dev));\r\n}\r\nif (domain_for_device(&dev->dev))\r\ncontinue;\r\ndevid = get_device_id(&dev->dev);\r\ndma_dom = dma_ops_domain_alloc();\r\nif (!dma_dom)\r\ncontinue;\r\ninit_unity_mappings_for_device(dma_dom, devid);\r\ndma_dom->target_dev = devid;\r\nattach_device(&dev->dev, &dma_dom->domain);\r\nlist_add_tail(&dma_dom->list, &iommu_pd_list);\r\n}\r\n}\r\nstatic unsigned device_dma_ops_init(void)\r\n{\r\nstruct iommu_dev_data *dev_data;\r\nstruct pci_dev *pdev = NULL;\r\nunsigned unhandled = 0;\r\nfor_each_pci_dev(pdev) {\r\nif (!check_device(&pdev->dev)) {\r\niommu_ignore_device(&pdev->dev);\r\nunhandled += 1;\r\ncontinue;\r\n}\r\ndev_data = get_dev_data(&pdev->dev);\r\nif (!dev_data->passthrough)\r\npdev->dev.archdata.dma_ops = &amd_iommu_dma_ops;\r\nelse\r\npdev->dev.archdata.dma_ops = &nommu_dma_ops;\r\n}\r\nreturn unhandled;\r\n}\r\nvoid __init amd_iommu_init_api(void)\r\n{\r\nbus_set_iommu(&pci_bus_type, &amd_iommu_ops);\r\n}\r\nint __init amd_iommu_init_dma_ops(void)\r\n{\r\nstruct amd_iommu *iommu;\r\nint ret, unhandled;\r\nfor_each_iommu(iommu) {\r\niommu->default_dom = dma_ops_domain_alloc();\r\nif (iommu->default_dom == NULL)\r\nreturn -ENOMEM;\r\niommu->default_dom->domain.flags |= PD_DEFAULT_MASK;\r\nret = iommu_init_unity_mappings(iommu);\r\nif (ret)\r\ngoto free_domains;\r\n}\r\nprealloc_protection_domains();\r\niommu_detected = 1;\r\nswiotlb = 0;\r\nunhandled = device_dma_ops_init();\r\nif (unhandled && max_pfn > MAX_DMA32_PFN) {\r\nswiotlb = 1;\r\n}\r\namd_iommu_stats_init();\r\nif (amd_iommu_unmap_flush)\r\npr_info("AMD-Vi: IO/TLB flush on unmap enabled\n");\r\nelse\r\npr_info("AMD-Vi: Lazy IO/TLB flushing enabled\n");\r\nreturn 0;\r\nfree_domains:\r\nfor_each_iommu(iommu) {\r\ndma_ops_domain_free(iommu->default_dom);\r\n}\r\nreturn ret;\r\n}\r\nstatic void cleanup_domain(struct protection_domain *domain)\r\n{\r\nstruct iommu_dev_data *dev_data, *next;\r\nunsigned long flags;\r\nwrite_lock_irqsave(&amd_iommu_devtable_lock, flags);\r\nlist_for_each_entry_safe(dev_data, next, &domain->dev_list, list) {\r\n__detach_device(dev_data);\r\natomic_set(&dev_data->bind, 0);\r\n}\r\nwrite_unlock_irqrestore(&amd_iommu_devtable_lock, flags);\r\n}\r\nstatic void protection_domain_free(struct protection_domain *domain)\r\n{\r\nif (!domain)\r\nreturn;\r\ndel_domain_from_list(domain);\r\nif (domain->id)\r\ndomain_id_free(domain->id);\r\nkfree(domain);\r\n}\r\nstatic struct protection_domain *protection_domain_alloc(void)\r\n{\r\nstruct protection_domain *domain;\r\ndomain = kzalloc(sizeof(*domain), GFP_KERNEL);\r\nif (!domain)\r\nreturn NULL;\r\nspin_lock_init(&domain->lock);\r\nmutex_init(&domain->api_lock);\r\ndomain->id = domain_id_alloc();\r\nif (!domain->id)\r\ngoto out_err;\r\nINIT_LIST_HEAD(&domain->dev_list);\r\nadd_domain_to_list(domain);\r\nreturn domain;\r\nout_err:\r\nkfree(domain);\r\nreturn NULL;\r\n}\r\nstatic int __init alloc_passthrough_domain(void)\r\n{\r\nif (pt_domain != NULL)\r\nreturn 0;\r\npt_domain = protection_domain_alloc();\r\nif (!pt_domain)\r\nreturn -ENOMEM;\r\npt_domain->mode = PAGE_MODE_NONE;\r\nreturn 0;\r\n}\r\nstatic int amd_iommu_domain_init(struct iommu_domain *dom)\r\n{\r\nstruct protection_domain *domain;\r\ndomain = protection_domain_alloc();\r\nif (!domain)\r\ngoto out_free;\r\ndomain->mode = PAGE_MODE_3_LEVEL;\r\ndomain->pt_root = (void *)get_zeroed_page(GFP_KERNEL);\r\nif (!domain->pt_root)\r\ngoto out_free;\r\ndomain->iommu_domain = dom;\r\ndom->priv = domain;\r\ndom->geometry.aperture_start = 0;\r\ndom->geometry.aperture_end = ~0ULL;\r\ndom->geometry.force_aperture = true;\r\nreturn 0;\r\nout_free:\r\nprotection_domain_free(domain);\r\nreturn -ENOMEM;\r\n}\r\nstatic void amd_iommu_domain_destroy(struct iommu_domain *dom)\r\n{\r\nstruct protection_domain *domain = dom->priv;\r\nif (!domain)\r\nreturn;\r\nif (domain->dev_cnt > 0)\r\ncleanup_domain(domain);\r\nBUG_ON(domain->dev_cnt != 0);\r\nif (domain->mode != PAGE_MODE_NONE)\r\nfree_pagetable(domain);\r\nif (domain->flags & PD_IOMMUV2_MASK)\r\nfree_gcr3_table(domain);\r\nprotection_domain_free(domain);\r\ndom->priv = NULL;\r\n}\r\nstatic void amd_iommu_detach_device(struct iommu_domain *dom,\r\nstruct device *dev)\r\n{\r\nstruct iommu_dev_data *dev_data = dev->archdata.iommu;\r\nstruct amd_iommu *iommu;\r\nu16 devid;\r\nif (!check_device(dev))\r\nreturn;\r\ndevid = get_device_id(dev);\r\nif (dev_data->domain != NULL)\r\ndetach_device(dev);\r\niommu = amd_iommu_rlookup_table[devid];\r\nif (!iommu)\r\nreturn;\r\niommu_completion_wait(iommu);\r\n}\r\nstatic int amd_iommu_attach_device(struct iommu_domain *dom,\r\nstruct device *dev)\r\n{\r\nstruct protection_domain *domain = dom->priv;\r\nstruct iommu_dev_data *dev_data;\r\nstruct amd_iommu *iommu;\r\nint ret;\r\nif (!check_device(dev))\r\nreturn -EINVAL;\r\ndev_data = dev->archdata.iommu;\r\niommu = amd_iommu_rlookup_table[dev_data->devid];\r\nif (!iommu)\r\nreturn -EINVAL;\r\nif (dev_data->domain)\r\ndetach_device(dev);\r\nret = attach_device(dev, domain);\r\niommu_completion_wait(iommu);\r\nreturn ret;\r\n}\r\nstatic int amd_iommu_map(struct iommu_domain *dom, unsigned long iova,\r\nphys_addr_t paddr, size_t page_size, int iommu_prot)\r\n{\r\nstruct protection_domain *domain = dom->priv;\r\nint prot = 0;\r\nint ret;\r\nif (domain->mode == PAGE_MODE_NONE)\r\nreturn -EINVAL;\r\nif (iommu_prot & IOMMU_READ)\r\nprot |= IOMMU_PROT_IR;\r\nif (iommu_prot & IOMMU_WRITE)\r\nprot |= IOMMU_PROT_IW;\r\nmutex_lock(&domain->api_lock);\r\nret = iommu_map_page(domain, iova, paddr, prot, page_size);\r\nmutex_unlock(&domain->api_lock);\r\nreturn ret;\r\n}\r\nstatic size_t amd_iommu_unmap(struct iommu_domain *dom, unsigned long iova,\r\nsize_t page_size)\r\n{\r\nstruct protection_domain *domain = dom->priv;\r\nsize_t unmap_size;\r\nif (domain->mode == PAGE_MODE_NONE)\r\nreturn -EINVAL;\r\nmutex_lock(&domain->api_lock);\r\nunmap_size = iommu_unmap_page(domain, iova, page_size);\r\nmutex_unlock(&domain->api_lock);\r\ndomain_flush_tlb_pde(domain);\r\nreturn unmap_size;\r\n}\r\nstatic phys_addr_t amd_iommu_iova_to_phys(struct iommu_domain *dom,\r\ndma_addr_t iova)\r\n{\r\nstruct protection_domain *domain = dom->priv;\r\nunsigned long offset_mask;\r\nphys_addr_t paddr;\r\nu64 *pte, __pte;\r\nif (domain->mode == PAGE_MODE_NONE)\r\nreturn iova;\r\npte = fetch_pte(domain, iova);\r\nif (!pte || !IOMMU_PTE_PRESENT(*pte))\r\nreturn 0;\r\nif (PM_PTE_LEVEL(*pte) == 0)\r\noffset_mask = PAGE_SIZE - 1;\r\nelse\r\noffset_mask = PTE_PAGE_SIZE(*pte) - 1;\r\n__pte = *pte & PM_ADDR_MASK;\r\npaddr = (__pte & ~offset_mask) | (iova & offset_mask);\r\nreturn paddr;\r\n}\r\nstatic int amd_iommu_domain_has_cap(struct iommu_domain *domain,\r\nunsigned long cap)\r\n{\r\nswitch (cap) {\r\ncase IOMMU_CAP_CACHE_COHERENCY:\r\nreturn 1;\r\ncase IOMMU_CAP_INTR_REMAP:\r\nreturn irq_remapping_enabled;\r\n}\r\nreturn 0;\r\n}\r\nint __init amd_iommu_init_passthrough(void)\r\n{\r\nstruct iommu_dev_data *dev_data;\r\nstruct pci_dev *dev = NULL;\r\nstruct amd_iommu *iommu;\r\nu16 devid;\r\nint ret;\r\nret = alloc_passthrough_domain();\r\nif (ret)\r\nreturn ret;\r\nfor_each_pci_dev(dev) {\r\nif (!check_device(&dev->dev))\r\ncontinue;\r\ndev_data = get_dev_data(&dev->dev);\r\ndev_data->passthrough = true;\r\ndevid = get_device_id(&dev->dev);\r\niommu = amd_iommu_rlookup_table[devid];\r\nif (!iommu)\r\ncontinue;\r\nattach_device(&dev->dev, pt_domain);\r\n}\r\namd_iommu_stats_init();\r\npr_info("AMD-Vi: Initialized for Passthrough Mode\n");\r\nreturn 0;\r\n}\r\nint amd_iommu_register_ppr_notifier(struct notifier_block *nb)\r\n{\r\nreturn atomic_notifier_chain_register(&ppr_notifier, nb);\r\n}\r\nint amd_iommu_unregister_ppr_notifier(struct notifier_block *nb)\r\n{\r\nreturn atomic_notifier_chain_unregister(&ppr_notifier, nb);\r\n}\r\nvoid amd_iommu_domain_direct_map(struct iommu_domain *dom)\r\n{\r\nstruct protection_domain *domain = dom->priv;\r\nunsigned long flags;\r\nspin_lock_irqsave(&domain->lock, flags);\r\ndomain->mode = PAGE_MODE_NONE;\r\ndomain->updated = true;\r\nupdate_domain(domain);\r\nfree_pagetable(domain);\r\nspin_unlock_irqrestore(&domain->lock, flags);\r\n}\r\nint amd_iommu_domain_enable_v2(struct iommu_domain *dom, int pasids)\r\n{\r\nstruct protection_domain *domain = dom->priv;\r\nunsigned long flags;\r\nint levels, ret;\r\nif (pasids <= 0 || pasids > (PASID_MASK + 1))\r\nreturn -EINVAL;\r\nfor (levels = 0; (pasids - 1) & ~0x1ff; pasids >>= 9)\r\nlevels += 1;\r\nif (levels > amd_iommu_max_glx_val)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&domain->lock, flags);\r\nret = -EBUSY;\r\nif (domain->dev_cnt > 0 || domain->flags & PD_IOMMUV2_MASK)\r\ngoto out;\r\nret = -ENOMEM;\r\ndomain->gcr3_tbl = (void *)get_zeroed_page(GFP_ATOMIC);\r\nif (domain->gcr3_tbl == NULL)\r\ngoto out;\r\ndomain->glx = levels;\r\ndomain->flags |= PD_IOMMUV2_MASK;\r\ndomain->updated = true;\r\nupdate_domain(domain);\r\nret = 0;\r\nout:\r\nspin_unlock_irqrestore(&domain->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int __flush_pasid(struct protection_domain *domain, int pasid,\r\nu64 address, bool size)\r\n{\r\nstruct iommu_dev_data *dev_data;\r\nstruct iommu_cmd cmd;\r\nint i, ret;\r\nif (!(domain->flags & PD_IOMMUV2_MASK))\r\nreturn -EINVAL;\r\nbuild_inv_iommu_pasid(&cmd, domain->id, pasid, address, size);\r\nfor (i = 0; i < amd_iommus_present; ++i) {\r\nif (domain->dev_iommu[i] == 0)\r\ncontinue;\r\nret = iommu_queue_command(amd_iommus[i], &cmd);\r\nif (ret != 0)\r\ngoto out;\r\n}\r\ndomain_flush_complete(domain);\r\nlist_for_each_entry(dev_data, &domain->dev_list, list) {\r\nstruct amd_iommu *iommu;\r\nint qdep;\r\nBUG_ON(!dev_data->ats.enabled);\r\nqdep = dev_data->ats.qdep;\r\niommu = amd_iommu_rlookup_table[dev_data->devid];\r\nbuild_inv_iotlb_pasid(&cmd, dev_data->devid, pasid,\r\nqdep, address, size);\r\nret = iommu_queue_command(iommu, &cmd);\r\nif (ret != 0)\r\ngoto out;\r\n}\r\ndomain_flush_complete(domain);\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __amd_iommu_flush_page(struct protection_domain *domain, int pasid,\r\nu64 address)\r\n{\r\nINC_STATS_COUNTER(invalidate_iotlb);\r\nreturn __flush_pasid(domain, pasid, address, false);\r\n}\r\nint amd_iommu_flush_page(struct iommu_domain *dom, int pasid,\r\nu64 address)\r\n{\r\nstruct protection_domain *domain = dom->priv;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&domain->lock, flags);\r\nret = __amd_iommu_flush_page(domain, pasid, address);\r\nspin_unlock_irqrestore(&domain->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int __amd_iommu_flush_tlb(struct protection_domain *domain, int pasid)\r\n{\r\nINC_STATS_COUNTER(invalidate_iotlb_all);\r\nreturn __flush_pasid(domain, pasid, CMD_INV_IOMMU_ALL_PAGES_ADDRESS,\r\ntrue);\r\n}\r\nint amd_iommu_flush_tlb(struct iommu_domain *dom, int pasid)\r\n{\r\nstruct protection_domain *domain = dom->priv;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&domain->lock, flags);\r\nret = __amd_iommu_flush_tlb(domain, pasid);\r\nspin_unlock_irqrestore(&domain->lock, flags);\r\nreturn ret;\r\n}\r\nstatic u64 *__get_gcr3_pte(u64 *root, int level, int pasid, bool alloc)\r\n{\r\nint index;\r\nu64 *pte;\r\nwhile (true) {\r\nindex = (pasid >> (9 * level)) & 0x1ff;\r\npte = &root[index];\r\nif (level == 0)\r\nbreak;\r\nif (!(*pte & GCR3_VALID)) {\r\nif (!alloc)\r\nreturn NULL;\r\nroot = (void *)get_zeroed_page(GFP_ATOMIC);\r\nif (root == NULL)\r\nreturn NULL;\r\n*pte = __pa(root) | GCR3_VALID;\r\n}\r\nroot = __va(*pte & PAGE_MASK);\r\nlevel -= 1;\r\n}\r\nreturn pte;\r\n}\r\nstatic int __set_gcr3(struct protection_domain *domain, int pasid,\r\nunsigned long cr3)\r\n{\r\nu64 *pte;\r\nif (domain->mode != PAGE_MODE_NONE)\r\nreturn -EINVAL;\r\npte = __get_gcr3_pte(domain->gcr3_tbl, domain->glx, pasid, true);\r\nif (pte == NULL)\r\nreturn -ENOMEM;\r\n*pte = (cr3 & PAGE_MASK) | GCR3_VALID;\r\nreturn __amd_iommu_flush_tlb(domain, pasid);\r\n}\r\nstatic int __clear_gcr3(struct protection_domain *domain, int pasid)\r\n{\r\nu64 *pte;\r\nif (domain->mode != PAGE_MODE_NONE)\r\nreturn -EINVAL;\r\npte = __get_gcr3_pte(domain->gcr3_tbl, domain->glx, pasid, false);\r\nif (pte == NULL)\r\nreturn 0;\r\n*pte = 0;\r\nreturn __amd_iommu_flush_tlb(domain, pasid);\r\n}\r\nint amd_iommu_domain_set_gcr3(struct iommu_domain *dom, int pasid,\r\nunsigned long cr3)\r\n{\r\nstruct protection_domain *domain = dom->priv;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&domain->lock, flags);\r\nret = __set_gcr3(domain, pasid, cr3);\r\nspin_unlock_irqrestore(&domain->lock, flags);\r\nreturn ret;\r\n}\r\nint amd_iommu_domain_clear_gcr3(struct iommu_domain *dom, int pasid)\r\n{\r\nstruct protection_domain *domain = dom->priv;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&domain->lock, flags);\r\nret = __clear_gcr3(domain, pasid);\r\nspin_unlock_irqrestore(&domain->lock, flags);\r\nreturn ret;\r\n}\r\nint amd_iommu_complete_ppr(struct pci_dev *pdev, int pasid,\r\nint status, int tag)\r\n{\r\nstruct iommu_dev_data *dev_data;\r\nstruct amd_iommu *iommu;\r\nstruct iommu_cmd cmd;\r\nINC_STATS_COUNTER(complete_ppr);\r\ndev_data = get_dev_data(&pdev->dev);\r\niommu = amd_iommu_rlookup_table[dev_data->devid];\r\nbuild_complete_ppr(&cmd, dev_data->devid, pasid, status,\r\ntag, dev_data->pri_tlp);\r\nreturn iommu_queue_command(iommu, &cmd);\r\n}\r\nstruct iommu_domain *amd_iommu_get_v2_domain(struct pci_dev *pdev)\r\n{\r\nstruct protection_domain *domain;\r\ndomain = get_domain(&pdev->dev);\r\nif (IS_ERR(domain))\r\nreturn NULL;\r\nif (!(domain->flags & PD_IOMMUV2_MASK))\r\nreturn NULL;\r\nreturn domain->iommu_domain;\r\n}\r\nvoid amd_iommu_enable_device_erratum(struct pci_dev *pdev, u32 erratum)\r\n{\r\nstruct iommu_dev_data *dev_data;\r\nif (!amd_iommu_v2_supported())\r\nreturn;\r\ndev_data = get_dev_data(&pdev->dev);\r\ndev_data->errata |= (1 << erratum);\r\n}\r\nint amd_iommu_device_info(struct pci_dev *pdev,\r\nstruct amd_iommu_device_info *info)\r\n{\r\nint max_pasids;\r\nint pos;\r\nif (pdev == NULL || info == NULL)\r\nreturn -EINVAL;\r\nif (!amd_iommu_v2_supported())\r\nreturn -EINVAL;\r\nmemset(info, 0, sizeof(*info));\r\npos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_ATS);\r\nif (pos)\r\ninfo->flags |= AMD_IOMMU_DEVICE_FLAG_ATS_SUP;\r\npos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_PRI);\r\nif (pos)\r\ninfo->flags |= AMD_IOMMU_DEVICE_FLAG_PRI_SUP;\r\npos = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_PASID);\r\nif (pos) {\r\nint features;\r\nmax_pasids = 1 << (9 * (amd_iommu_max_glx_val + 1));\r\nmax_pasids = min(max_pasids, (1 << 20));\r\ninfo->flags |= AMD_IOMMU_DEVICE_FLAG_PASID_SUP;\r\ninfo->max_pasids = min(pci_max_pasids(pdev), max_pasids);\r\nfeatures = pci_pasid_features(pdev);\r\nif (features & PCI_PASID_CAP_EXEC)\r\ninfo->flags |= AMD_IOMMU_DEVICE_FLAG_EXEC_SUP;\r\nif (features & PCI_PASID_CAP_PRIV)\r\ninfo->flags |= AMD_IOMMU_DEVICE_FLAG_PRIV_SUP;\r\n}\r\nreturn 0;\r\n}\r\nstatic void set_dte_irq_entry(u16 devid, struct irq_remap_table *table)\r\n{\r\nu64 dte;\r\ndte = amd_iommu_dev_table[devid].data[2];\r\ndte &= ~DTE_IRQ_PHYS_ADDR_MASK;\r\ndte |= virt_to_phys(table->table);\r\ndte |= DTE_IRQ_REMAP_INTCTL;\r\ndte |= DTE_IRQ_TABLE_LEN;\r\ndte |= DTE_IRQ_REMAP_ENABLE;\r\namd_iommu_dev_table[devid].data[2] = dte;\r\n}\r\nstatic struct irq_remap_table *get_irq_table(u16 devid, bool ioapic)\r\n{\r\nstruct irq_remap_table *table = NULL;\r\nstruct amd_iommu *iommu;\r\nunsigned long flags;\r\nu16 alias;\r\nwrite_lock_irqsave(&amd_iommu_devtable_lock, flags);\r\niommu = amd_iommu_rlookup_table[devid];\r\nif (!iommu)\r\ngoto out_unlock;\r\ntable = irq_lookup_table[devid];\r\nif (table)\r\ngoto out;\r\nalias = amd_iommu_alias_table[devid];\r\ntable = irq_lookup_table[alias];\r\nif (table) {\r\nirq_lookup_table[devid] = table;\r\nset_dte_irq_entry(devid, table);\r\niommu_flush_dte(iommu, devid);\r\ngoto out;\r\n}\r\ntable = kzalloc(sizeof(*table), GFP_ATOMIC);\r\nif (!table)\r\ngoto out;\r\nspin_lock_init(&table->lock);\r\nif (ioapic)\r\ntable->min_index = 32;\r\ntable->table = kmem_cache_alloc(amd_iommu_irq_cache, GFP_ATOMIC);\r\nif (!table->table) {\r\nkfree(table);\r\ntable = NULL;\r\ngoto out;\r\n}\r\nmemset(table->table, 0, MAX_IRQS_PER_TABLE * sizeof(u32));\r\nif (ioapic) {\r\nint i;\r\nfor (i = 0; i < 32; ++i)\r\ntable->table[i] = IRTE_ALLOCATED;\r\n}\r\nirq_lookup_table[devid] = table;\r\nset_dte_irq_entry(devid, table);\r\niommu_flush_dte(iommu, devid);\r\nif (devid != alias) {\r\nirq_lookup_table[alias] = table;\r\nset_dte_irq_entry(devid, table);\r\niommu_flush_dte(iommu, alias);\r\n}\r\nout:\r\niommu_completion_wait(iommu);\r\nout_unlock:\r\nwrite_unlock_irqrestore(&amd_iommu_devtable_lock, flags);\r\nreturn table;\r\n}\r\nstatic int alloc_irq_index(struct irq_cfg *cfg, u16 devid, int count)\r\n{\r\nstruct irq_remap_table *table;\r\nunsigned long flags;\r\nint index, c;\r\ntable = get_irq_table(devid, false);\r\nif (!table)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&table->lock, flags);\r\nfor (c = 0, index = table->min_index;\r\nindex < MAX_IRQS_PER_TABLE;\r\n++index) {\r\nif (table->table[index] == 0)\r\nc += 1;\r\nelse\r\nc = 0;\r\nif (c == count) {\r\nstruct irq_2_irte *irte_info;\r\nfor (; c != 0; --c)\r\ntable->table[index - c + 1] = IRTE_ALLOCATED;\r\nindex -= count - 1;\r\ncfg->remapped = 1;\r\nirte_info = &cfg->irq_2_irte;\r\nirte_info->devid = devid;\r\nirte_info->index = index;\r\ngoto out;\r\n}\r\n}\r\nindex = -ENOSPC;\r\nout:\r\nspin_unlock_irqrestore(&table->lock, flags);\r\nreturn index;\r\n}\r\nstatic int get_irte(u16 devid, int index, union irte *irte)\r\n{\r\nstruct irq_remap_table *table;\r\nunsigned long flags;\r\ntable = get_irq_table(devid, false);\r\nif (!table)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&table->lock, flags);\r\nirte->val = table->table[index];\r\nspin_unlock_irqrestore(&table->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int modify_irte(u16 devid, int index, union irte irte)\r\n{\r\nstruct irq_remap_table *table;\r\nstruct amd_iommu *iommu;\r\nunsigned long flags;\r\niommu = amd_iommu_rlookup_table[devid];\r\nif (iommu == NULL)\r\nreturn -EINVAL;\r\ntable = get_irq_table(devid, false);\r\nif (!table)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&table->lock, flags);\r\ntable->table[index] = irte.val;\r\nspin_unlock_irqrestore(&table->lock, flags);\r\niommu_flush_irt(iommu, devid);\r\niommu_completion_wait(iommu);\r\nreturn 0;\r\n}\r\nstatic void free_irte(u16 devid, int index)\r\n{\r\nstruct irq_remap_table *table;\r\nstruct amd_iommu *iommu;\r\nunsigned long flags;\r\niommu = amd_iommu_rlookup_table[devid];\r\nif (iommu == NULL)\r\nreturn;\r\ntable = get_irq_table(devid, false);\r\nif (!table)\r\nreturn;\r\nspin_lock_irqsave(&table->lock, flags);\r\ntable->table[index] = 0;\r\nspin_unlock_irqrestore(&table->lock, flags);\r\niommu_flush_irt(iommu, devid);\r\niommu_completion_wait(iommu);\r\n}\r\nstatic int setup_ioapic_entry(int irq, struct IO_APIC_route_entry *entry,\r\nunsigned int destination, int vector,\r\nstruct io_apic_irq_attr *attr)\r\n{\r\nstruct irq_remap_table *table;\r\nstruct irq_2_irte *irte_info;\r\nstruct irq_cfg *cfg;\r\nunion irte irte;\r\nint ioapic_id;\r\nint index;\r\nint devid;\r\nint ret;\r\ncfg = irq_get_chip_data(irq);\r\nif (!cfg)\r\nreturn -EINVAL;\r\nirte_info = &cfg->irq_2_irte;\r\nioapic_id = mpc_ioapic_id(attr->ioapic);\r\ndevid = get_ioapic_devid(ioapic_id);\r\nif (devid < 0)\r\nreturn devid;\r\ntable = get_irq_table(devid, true);\r\nif (table == NULL)\r\nreturn -ENOMEM;\r\nindex = attr->ioapic_pin;\r\ncfg->remapped = 1;\r\nirte_info->devid = devid;\r\nirte_info->index = index;\r\nirte.val = 0;\r\nirte.fields.vector = vector;\r\nirte.fields.int_type = apic->irq_delivery_mode;\r\nirte.fields.destination = destination;\r\nirte.fields.dm = apic->irq_dest_mode;\r\nirte.fields.valid = 1;\r\nret = modify_irte(devid, index, irte);\r\nif (ret)\r\nreturn ret;\r\nmemset(entry, 0, sizeof(*entry));\r\nentry->vector = index;\r\nentry->mask = 0;\r\nentry->trigger = attr->trigger;\r\nentry->polarity = attr->polarity;\r\nif (attr->trigger)\r\nentry->mask = 1;\r\nreturn 0;\r\n}\r\nstatic int set_affinity(struct irq_data *data, const struct cpumask *mask,\r\nbool force)\r\n{\r\nstruct irq_2_irte *irte_info;\r\nunsigned int dest, irq;\r\nstruct irq_cfg *cfg;\r\nunion irte irte;\r\nint err;\r\nif (!config_enabled(CONFIG_SMP))\r\nreturn -1;\r\ncfg = data->chip_data;\r\nirq = data->irq;\r\nirte_info = &cfg->irq_2_irte;\r\nif (!cpumask_intersects(mask, cpu_online_mask))\r\nreturn -EINVAL;\r\nif (get_irte(irte_info->devid, irte_info->index, &irte))\r\nreturn -EBUSY;\r\nif (assign_irq_vector(irq, cfg, mask))\r\nreturn -EBUSY;\r\nerr = apic->cpu_mask_to_apicid_and(cfg->domain, mask, &dest);\r\nif (err) {\r\nif (assign_irq_vector(irq, cfg, data->affinity))\r\npr_err("AMD-Vi: Failed to recover vector for irq %d\n", irq);\r\nreturn err;\r\n}\r\nirte.fields.vector = cfg->vector;\r\nirte.fields.destination = dest;\r\nmodify_irte(irte_info->devid, irte_info->index, irte);\r\nif (cfg->move_in_progress)\r\nsend_cleanup_vector(cfg);\r\ncpumask_copy(data->affinity, mask);\r\nreturn 0;\r\n}\r\nstatic int free_irq(int irq)\r\n{\r\nstruct irq_2_irte *irte_info;\r\nstruct irq_cfg *cfg;\r\ncfg = irq_get_chip_data(irq);\r\nif (!cfg)\r\nreturn -EINVAL;\r\nirte_info = &cfg->irq_2_irte;\r\nfree_irte(irte_info->devid, irte_info->index);\r\nreturn 0;\r\n}\r\nstatic void compose_msi_msg(struct pci_dev *pdev,\r\nunsigned int irq, unsigned int dest,\r\nstruct msi_msg *msg, u8 hpet_id)\r\n{\r\nstruct irq_2_irte *irte_info;\r\nstruct irq_cfg *cfg;\r\nunion irte irte;\r\ncfg = irq_get_chip_data(irq);\r\nif (!cfg)\r\nreturn;\r\nirte_info = &cfg->irq_2_irte;\r\nirte.val = 0;\r\nirte.fields.vector = cfg->vector;\r\nirte.fields.int_type = apic->irq_delivery_mode;\r\nirte.fields.destination = dest;\r\nirte.fields.dm = apic->irq_dest_mode;\r\nirte.fields.valid = 1;\r\nmodify_irte(irte_info->devid, irte_info->index, irte);\r\nmsg->address_hi = MSI_ADDR_BASE_HI;\r\nmsg->address_lo = MSI_ADDR_BASE_LO;\r\nmsg->data = irte_info->index;\r\n}\r\nstatic int msi_alloc_irq(struct pci_dev *pdev, int irq, int nvec)\r\n{\r\nstruct irq_cfg *cfg;\r\nint index;\r\nu16 devid;\r\nif (!pdev)\r\nreturn -EINVAL;\r\ncfg = irq_get_chip_data(irq);\r\nif (!cfg)\r\nreturn -EINVAL;\r\ndevid = get_device_id(&pdev->dev);\r\nindex = alloc_irq_index(cfg, devid, nvec);\r\nreturn index < 0 ? MAX_IRQS_PER_TABLE : index;\r\n}\r\nstatic int msi_setup_irq(struct pci_dev *pdev, unsigned int irq,\r\nint index, int offset)\r\n{\r\nstruct irq_2_irte *irte_info;\r\nstruct irq_cfg *cfg;\r\nu16 devid;\r\nif (!pdev)\r\nreturn -EINVAL;\r\ncfg = irq_get_chip_data(irq);\r\nif (!cfg)\r\nreturn -EINVAL;\r\nif (index >= MAX_IRQS_PER_TABLE)\r\nreturn 0;\r\ndevid = get_device_id(&pdev->dev);\r\nirte_info = &cfg->irq_2_irte;\r\ncfg->remapped = 1;\r\nirte_info->devid = devid;\r\nirte_info->index = index + offset;\r\nreturn 0;\r\n}\r\nstatic int setup_hpet_msi(unsigned int irq, unsigned int id)\r\n{\r\nstruct irq_2_irte *irte_info;\r\nstruct irq_cfg *cfg;\r\nint index, devid;\r\ncfg = irq_get_chip_data(irq);\r\nif (!cfg)\r\nreturn -EINVAL;\r\nirte_info = &cfg->irq_2_irte;\r\ndevid = get_hpet_devid(id);\r\nif (devid < 0)\r\nreturn devid;\r\nindex = alloc_irq_index(cfg, devid, 1);\r\nif (index < 0)\r\nreturn index;\r\ncfg->remapped = 1;\r\nirte_info->devid = devid;\r\nirte_info->index = index;\r\nreturn 0;\r\n}
