static int create_port0_egr(struct ipath_devdata *dd)\r\n{\r\nunsigned e, egrcnt;\r\nstruct ipath_skbinfo *skbinfo;\r\nint ret;\r\negrcnt = dd->ipath_p0_rcvegrcnt;\r\nskbinfo = vmalloc(sizeof(*dd->ipath_port0_skbinfo) * egrcnt);\r\nif (skbinfo == NULL) {\r\nipath_dev_err(dd, "allocation error for eager TID "\r\n"skb array\n");\r\nret = -ENOMEM;\r\ngoto bail;\r\n}\r\nfor (e = 0; e < egrcnt; e++) {\r\nskbinfo[e].skb = ipath_alloc_skb(dd, GFP_KERNEL);\r\nif (!skbinfo[e].skb) {\r\nipath_dev_err(dd, "SKB allocation error for "\r\n"eager TID %u\n", e);\r\nwhile (e != 0)\r\ndev_kfree_skb(skbinfo[--e].skb);\r\nvfree(skbinfo);\r\nret = -ENOMEM;\r\ngoto bail;\r\n}\r\n}\r\ndd->ipath_port0_skbinfo = skbinfo;\r\nfor (e = 0; e < egrcnt; e++) {\r\ndd->ipath_port0_skbinfo[e].phys =\r\nipath_map_single(dd->pcidev,\r\ndd->ipath_port0_skbinfo[e].skb->data,\r\ndd->ipath_ibmaxlen, PCI_DMA_FROMDEVICE);\r\ndd->ipath_f_put_tid(dd, e + (u64 __iomem *)\r\n((char __iomem *) dd->ipath_kregbase +\r\ndd->ipath_rcvegrbase),\r\nRCVHQ_RCV_TYPE_EAGER,\r\ndd->ipath_port0_skbinfo[e].phys);\r\n}\r\nret = 0;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int bringup_link(struct ipath_devdata *dd)\r\n{\r\nu64 val, ibc;\r\nint ret = 0;\r\ndd->ipath_control &= ~INFINIPATH_C_LINKENABLE;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_control,\r\ndd->ipath_control);\r\nval = (dd->ipath_ibmaxlen >> 2) + 1;\r\nibc = val << dd->ibcc_mpl_shift;\r\nibc |= 0x5ULL << INFINIPATH_IBCC_FLOWCTRLWATERMARK_SHIFT;\r\nibc |= 0x3ULL << INFINIPATH_IBCC_FLOWCTRLPERIOD_SHIFT;\r\nibc |= 0xfULL << INFINIPATH_IBCC_PHYERRTHRESHOLD_SHIFT;\r\nibc |= 4ULL << INFINIPATH_IBCC_CREDITSCALE_SHIFT;\r\nibc |= 0xfULL << INFINIPATH_IBCC_OVERRUNTHRESHOLD_SHIFT;\r\ndd->ipath_ibcctrl = ibc;\r\nibc |= INFINIPATH_IBCC_LINKINITCMD_DISABLE <<\r\nINFINIPATH_IBCC_LINKINITCMD_SHIFT;\r\ndd->ipath_flags |= IPATH_IB_LINK_DISABLED;\r\nipath_cdbg(VERBOSE, "Writing 0x%llx to ibcctrl\n",\r\n(unsigned long long) ibc);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_ibcctrl, ibc);\r\nval = ipath_read_kreg64(dd, dd->ipath_kregs->kr_scratch);\r\nret = dd->ipath_f_bringup_serdes(dd);\r\nif (ret)\r\ndev_info(&dd->pcidev->dev, "Could not initialize SerDes, "\r\n"not usable\n");\r\nelse {\r\ndd->ipath_control |= INFINIPATH_C_LINKENABLE;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_control,\r\ndd->ipath_control);\r\n}\r\nreturn ret;\r\n}\r\nstatic struct ipath_portdata *create_portdata0(struct ipath_devdata *dd)\r\n{\r\nstruct ipath_portdata *pd = NULL;\r\npd = kzalloc(sizeof(*pd), GFP_KERNEL);\r\nif (pd) {\r\npd->port_dd = dd;\r\npd->port_cnt = 1;\r\npd->port_pkeys[0] = IPATH_DEFAULT_P_KEY;\r\npd->port_seq_cnt = 1;\r\n}\r\nreturn pd;\r\n}\r\nstatic int init_chip_first(struct ipath_devdata *dd)\r\n{\r\nstruct ipath_portdata *pd;\r\nint ret = 0;\r\nu64 val;\r\nspin_lock_init(&dd->ipath_kernel_tid_lock);\r\nspin_lock_init(&dd->ipath_user_tid_lock);\r\nspin_lock_init(&dd->ipath_sendctrl_lock);\r\nspin_lock_init(&dd->ipath_uctxt_lock);\r\nspin_lock_init(&dd->ipath_sdma_lock);\r\nspin_lock_init(&dd->ipath_gpio_lock);\r\nspin_lock_init(&dd->ipath_eep_st_lock);\r\nspin_lock_init(&dd->ipath_sdepb_lock);\r\nmutex_init(&dd->ipath_eep_lock);\r\ndd->ipath_f_config_ports(dd, ipath_cfgports);\r\nif (!ipath_cfgports)\r\ndd->ipath_cfgports = dd->ipath_portcnt;\r\nelse if (ipath_cfgports <= dd->ipath_portcnt) {\r\ndd->ipath_cfgports = ipath_cfgports;\r\nipath_dbg("Configured to use %u ports out of %u in chip\n",\r\ndd->ipath_cfgports, ipath_read_kreg32(dd,\r\ndd->ipath_kregs->kr_portcnt));\r\n} else {\r\ndd->ipath_cfgports = dd->ipath_portcnt;\r\nipath_dbg("Tried to configured to use %u ports; chip "\r\n"only supports %u\n", ipath_cfgports,\r\nipath_read_kreg32(dd,\r\ndd->ipath_kregs->kr_portcnt));\r\n}\r\ndd->ipath_pd = kzalloc(sizeof(*dd->ipath_pd) * dd->ipath_portcnt,\r\nGFP_KERNEL);\r\nif (!dd->ipath_pd) {\r\nipath_dev_err(dd, "Unable to allocate portdata array, "\r\n"failing\n");\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\npd = create_portdata0(dd);\r\nif (!pd) {\r\nipath_dev_err(dd, "Unable to allocate portdata for port "\r\n"0, failing\n");\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\ndd->ipath_pd[0] = pd;\r\ndd->ipath_rcvtidcnt =\r\nipath_read_kreg32(dd, dd->ipath_kregs->kr_rcvtidcnt);\r\ndd->ipath_rcvtidbase =\r\nipath_read_kreg32(dd, dd->ipath_kregs->kr_rcvtidbase);\r\ndd->ipath_rcvegrcnt =\r\nipath_read_kreg32(dd, dd->ipath_kregs->kr_rcvegrcnt);\r\ndd->ipath_rcvegrbase =\r\nipath_read_kreg32(dd, dd->ipath_kregs->kr_rcvegrbase);\r\ndd->ipath_palign =\r\nipath_read_kreg32(dd, dd->ipath_kregs->kr_pagealign);\r\ndd->ipath_piobufbase =\r\nipath_read_kreg64(dd, dd->ipath_kregs->kr_sendpiobufbase);\r\nval = ipath_read_kreg64(dd, dd->ipath_kregs->kr_sendpiosize);\r\ndd->ipath_piosize2k = val & ~0U;\r\ndd->ipath_piosize4k = val >> 32;\r\nif (dd->ipath_piosize4k == 0 && ipath_mtu4096)\r\nipath_mtu4096 = 0;\r\ndd->ipath_ibmtu = ipath_mtu4096 ? 4096 : 2048;\r\nval = ipath_read_kreg64(dd, dd->ipath_kregs->kr_sendpiobufcnt);\r\ndd->ipath_piobcnt2k = val & ~0U;\r\ndd->ipath_piobcnt4k = val >> 32;\r\ndd->ipath_pio2kbase =\r\n(u32 __iomem *) (((char __iomem *) dd->ipath_kregbase) +\r\n(dd->ipath_piobufbase & 0xffffffff));\r\nif (dd->ipath_piobcnt4k) {\r\ndd->ipath_pio4kbase = (u32 __iomem *)\r\n(((char __iomem *) dd->ipath_kregbase) +\r\n(dd->ipath_piobufbase >> 32));\r\ndd->ipath_4kalign = ALIGN(dd->ipath_piosize4k,\r\ndd->ipath_palign);\r\nipath_dbg("%u 2k(%x) piobufs @ %p, %u 4k(%x) @ %p "\r\n"(%x aligned)\n",\r\ndd->ipath_piobcnt2k, dd->ipath_piosize2k,\r\ndd->ipath_pio2kbase, dd->ipath_piobcnt4k,\r\ndd->ipath_piosize4k, dd->ipath_pio4kbase,\r\ndd->ipath_4kalign);\r\n}\r\nelse ipath_dbg("%u 2k piobufs @ %p\n",\r\ndd->ipath_piobcnt2k, dd->ipath_pio2kbase);\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int init_chip_reset(struct ipath_devdata *dd)\r\n{\r\nu32 rtmp;\r\nint i;\r\nunsigned long flags;\r\ndd->ipath_rcvctrl &= ~(1ULL << dd->ipath_r_tailupd_shift);\r\nfor (i = 0; i < dd->ipath_portcnt; i++) {\r\nclear_bit(dd->ipath_r_portenable_shift + i,\r\n&dd->ipath_rcvctrl);\r\nclear_bit(dd->ipath_r_intravail_shift + i,\r\n&dd->ipath_rcvctrl);\r\n}\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_rcvctrl,\r\ndd->ipath_rcvctrl);\r\nspin_lock_irqsave(&dd->ipath_sendctrl_lock, flags);\r\ndd->ipath_sendctrl = 0U;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_sendctrl, dd->ipath_sendctrl);\r\nipath_read_kreg64(dd, dd->ipath_kregs->kr_scratch);\r\nspin_unlock_irqrestore(&dd->ipath_sendctrl_lock, flags);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_control, 0ULL);\r\nrtmp = ipath_read_kreg32(dd, dd->ipath_kregs->kr_rcvtidcnt);\r\nif (rtmp != dd->ipath_rcvtidcnt)\r\ndev_info(&dd->pcidev->dev, "tidcnt was %u before "\r\n"reset, now %u, using original\n",\r\ndd->ipath_rcvtidcnt, rtmp);\r\nrtmp = ipath_read_kreg32(dd, dd->ipath_kregs->kr_rcvtidbase);\r\nif (rtmp != dd->ipath_rcvtidbase)\r\ndev_info(&dd->pcidev->dev, "tidbase was %u before "\r\n"reset, now %u, using original\n",\r\ndd->ipath_rcvtidbase, rtmp);\r\nrtmp = ipath_read_kreg32(dd, dd->ipath_kregs->kr_rcvegrcnt);\r\nif (rtmp != dd->ipath_rcvegrcnt)\r\ndev_info(&dd->pcidev->dev, "egrcnt was %u before "\r\n"reset, now %u, using original\n",\r\ndd->ipath_rcvegrcnt, rtmp);\r\nrtmp = ipath_read_kreg32(dd, dd->ipath_kregs->kr_rcvegrbase);\r\nif (rtmp != dd->ipath_rcvegrbase)\r\ndev_info(&dd->pcidev->dev, "egrbase was %u before "\r\n"reset, now %u, using original\n",\r\ndd->ipath_rcvegrbase, rtmp);\r\nreturn 0;\r\n}\r\nstatic int init_pioavailregs(struct ipath_devdata *dd)\r\n{\r\nint ret;\r\ndd->ipath_pioavailregs_dma = dma_alloc_coherent(\r\n&dd->pcidev->dev, PAGE_SIZE, &dd->ipath_pioavailregs_phys,\r\nGFP_KERNEL);\r\nif (!dd->ipath_pioavailregs_dma) {\r\nipath_dev_err(dd, "failed to allocate PIOavail reg area "\r\n"in memory\n");\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\ndd->ipath_statusp = (u64 *)\r\n((char *)dd->ipath_pioavailregs_dma +\r\n((2 * L1_CACHE_BYTES +\r\ndd->ipath_pioavregs * sizeof(u64)) & ~L1_CACHE_BYTES));\r\n*dd->ipath_statusp = dd->_ipath_status;\r\ndd->ipath_freezemsg = (char *)&dd->ipath_statusp[1];\r\ndd->ipath_freezelen = L1_CACHE_BYTES - sizeof(dd->ipath_statusp[0]);\r\nret = 0;\r\ndone:\r\nreturn ret;\r\n}\r\nstatic void init_shadow_tids(struct ipath_devdata *dd)\r\n{\r\nstruct page **pages;\r\ndma_addr_t *addrs;\r\npages = vzalloc(dd->ipath_cfgports * dd->ipath_rcvtidcnt *\r\nsizeof(struct page *));\r\nif (!pages) {\r\nipath_dev_err(dd, "failed to allocate shadow page * "\r\n"array, no expected sends!\n");\r\ndd->ipath_pageshadow = NULL;\r\nreturn;\r\n}\r\naddrs = vmalloc(dd->ipath_cfgports * dd->ipath_rcvtidcnt *\r\nsizeof(dma_addr_t));\r\nif (!addrs) {\r\nipath_dev_err(dd, "failed to allocate shadow dma handle "\r\n"array, no expected sends!\n");\r\nvfree(pages);\r\ndd->ipath_pageshadow = NULL;\r\nreturn;\r\n}\r\ndd->ipath_pageshadow = pages;\r\ndd->ipath_physshadow = addrs;\r\n}\r\nstatic void enable_chip(struct ipath_devdata *dd, int reinit)\r\n{\r\nu32 val;\r\nu64 rcvmask;\r\nunsigned long flags;\r\nint i;\r\nif (!reinit)\r\ninit_waitqueue_head(&ipath_state_wait);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_rcvctrl,\r\ndd->ipath_rcvctrl);\r\nspin_lock_irqsave(&dd->ipath_sendctrl_lock, flags);\r\ndd->ipath_sendctrl = INFINIPATH_S_PIOENABLE |\r\nINFINIPATH_S_PIOBUFAVAILUPD;\r\nif (dd->ipath_pioupd_thresh)\r\ndd->ipath_sendctrl |= dd->ipath_pioupd_thresh\r\n<< INFINIPATH_S_UPDTHRESH_SHIFT;\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_sendctrl, dd->ipath_sendctrl);\r\nipath_read_kreg64(dd, dd->ipath_kregs->kr_scratch);\r\nspin_unlock_irqrestore(&dd->ipath_sendctrl_lock, flags);\r\nrcvmask = 1ULL;\r\ndd->ipath_rcvctrl |= (rcvmask << dd->ipath_r_portenable_shift) |\r\n(rcvmask << dd->ipath_r_intravail_shift);\r\nif (!(dd->ipath_flags & IPATH_NODMA_RTAIL))\r\ndd->ipath_rcvctrl |= (1ULL << dd->ipath_r_tailupd_shift);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_rcvctrl,\r\ndd->ipath_rcvctrl);\r\ndd->ipath_flags |= IPATH_INITTED;\r\nval = ipath_read_ureg32(dd, ur_rcvegrindextail, 0);\r\nipath_write_ureg(dd, ur_rcvegrindexhead, val, 0);\r\nipath_write_ureg(dd, ur_rcvhdrhead,\r\ndd->ipath_rhdrhead_intr_off |\r\ndd->ipath_pd[0]->port_head, 0);\r\nfor (i = 0; i < dd->ipath_pioavregs; i++) {\r\n__le64 pioavail;\r\nif (i > 3 && (dd->ipath_flags & IPATH_SWAP_PIOBUFS))\r\npioavail = dd->ipath_pioavailregs_dma[i ^ 1];\r\nelse\r\npioavail = dd->ipath_pioavailregs_dma[i];\r\ndd->ipath_pioavailshadow[i] = le64_to_cpu(pioavail);\r\n}\r\ndd->ipath_flags |= IPATH_PRESENT;\r\n}\r\nstatic int init_housekeeping(struct ipath_devdata *dd, int reinit)\r\n{\r\nchar boardn[40];\r\nint ret = 0;\r\ndd->ipath_rcvhdrsize = 0;\r\ndd->ipath_flags |= IPATH_LINKUNK | IPATH_PRESENT;\r\ndd->ipath_flags &= ~(IPATH_LINKACTIVE | IPATH_LINKARMED |\r\nIPATH_LINKDOWN | IPATH_LINKINIT);\r\nipath_cdbg(VERBOSE, "Try to read spc chip revision\n");\r\ndd->ipath_revision =\r\nipath_read_kreg64(dd, dd->ipath_kregs->kr_revision);\r\ndd->ipath_sregbase =\r\nipath_read_kreg32(dd, dd->ipath_kregs->kr_sendregbase);\r\ndd->ipath_cregbase =\r\nipath_read_kreg32(dd, dd->ipath_kregs->kr_counterregbase);\r\ndd->ipath_uregbase =\r\nipath_read_kreg32(dd, dd->ipath_kregs->kr_userregbase);\r\nipath_cdbg(VERBOSE, "ipath_kregbase %p, sendbase %x usrbase %x, "\r\n"cntrbase %x\n", dd->ipath_kregbase, dd->ipath_sregbase,\r\ndd->ipath_uregbase, dd->ipath_cregbase);\r\nif ((dd->ipath_revision & 0xffffffff) == 0xffffffff\r\n|| (dd->ipath_sregbase & 0xffffffff) == 0xffffffff\r\n|| (dd->ipath_cregbase & 0xffffffff) == 0xffffffff\r\n|| (dd->ipath_uregbase & 0xffffffff) == 0xffffffff) {\r\nipath_dev_err(dd, "Register read failures from chip, "\r\n"giving up initialization\n");\r\ndd->ipath_flags &= ~IPATH_PRESENT;\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\nipath_write_kreg (dd, dd->ipath_kregs->kr_hwdiagctrl, 0);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_errorclear,\r\nINFINIPATH_E_RESET);\r\nipath_cdbg(VERBOSE, "Revision %llx (PCI %x)\n",\r\n(unsigned long long) dd->ipath_revision,\r\ndd->ipath_pcirev);\r\nif (((dd->ipath_revision >> INFINIPATH_R_SOFTWARE_SHIFT) &\r\nINFINIPATH_R_SOFTWARE_MASK) != IPATH_CHIP_SWVERSION) {\r\nipath_dev_err(dd, "Driver only handles version %d, "\r\n"chip swversion is %d (%llx), failng\n",\r\nIPATH_CHIP_SWVERSION,\r\n(int)(dd->ipath_revision >>\r\nINFINIPATH_R_SOFTWARE_SHIFT) &\r\nINFINIPATH_R_SOFTWARE_MASK,\r\n(unsigned long long) dd->ipath_revision);\r\nret = -ENOSYS;\r\ngoto done;\r\n}\r\ndd->ipath_majrev = (u8) ((dd->ipath_revision >>\r\nINFINIPATH_R_CHIPREVMAJOR_SHIFT) &\r\nINFINIPATH_R_CHIPREVMAJOR_MASK);\r\ndd->ipath_minrev = (u8) ((dd->ipath_revision >>\r\nINFINIPATH_R_CHIPREVMINOR_SHIFT) &\r\nINFINIPATH_R_CHIPREVMINOR_MASK);\r\ndd->ipath_boardrev = (u8) ((dd->ipath_revision >>\r\nINFINIPATH_R_BOARDID_SHIFT) &\r\nINFINIPATH_R_BOARDID_MASK);\r\nret = dd->ipath_f_get_boardname(dd, boardn, sizeof boardn);\r\nsnprintf(dd->ipath_boardversion, sizeof(dd->ipath_boardversion),\r\n"ChipABI %u.%u, %s, InfiniPath%u %u.%u, PCI %u, "\r\n"SW Compat %u\n",\r\nIPATH_CHIP_VERS_MAJ, IPATH_CHIP_VERS_MIN, boardn,\r\n(unsigned)(dd->ipath_revision >> INFINIPATH_R_ARCH_SHIFT) &\r\nINFINIPATH_R_ARCH_MASK,\r\ndd->ipath_majrev, dd->ipath_minrev, dd->ipath_pcirev,\r\n(unsigned)(dd->ipath_revision >>\r\nINFINIPATH_R_SOFTWARE_SHIFT) &\r\nINFINIPATH_R_SOFTWARE_MASK);\r\nipath_dbg("%s", dd->ipath_boardversion);\r\nif (ret)\r\ngoto done;\r\nif (reinit)\r\nret = init_chip_reset(dd);\r\nelse\r\nret = init_chip_first(dd);\r\ndone:\r\nreturn ret;\r\n}\r\nstatic void verify_interrupt(unsigned long opaque)\r\n{\r\nstruct ipath_devdata *dd = (struct ipath_devdata *) opaque;\r\nif (!dd)\r\nreturn;\r\nif (dd->ipath_int_counter == 0) {\r\nif (!dd->ipath_f_intr_fallback(dd))\r\ndev_err(&dd->pcidev->dev, "No interrupts detected, "\r\n"not usable.\n");\r\nelse\r\nmod_timer(&dd->ipath_intrchk_timer, jiffies + HZ/2);\r\n} else\r\nipath_cdbg(VERBOSE, "%u interrupts at timer check\n",\r\ndd->ipath_int_counter);\r\n}\r\nint ipath_init_chip(struct ipath_devdata *dd, int reinit)\r\n{\r\nint ret = 0;\r\nu32 kpiobufs, defkbufs;\r\nu32 piobufs, uports;\r\nu64 val;\r\nstruct ipath_portdata *pd;\r\ngfp_t gfp_flags = GFP_USER | __GFP_COMP;\r\nret = init_housekeeping(dd, reinit);\r\nif (ret)\r\ngoto done;\r\ndd->ipath_rcvhdrcnt = max(dd->ipath_p0_rcvegrcnt, dd->ipath_rcvegrcnt);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_rcvhdrcnt,\r\ndd->ipath_rcvhdrcnt);\r\npiobufs = dd->ipath_piobcnt2k + dd->ipath_piobcnt4k;\r\ndd->ipath_pioavregs = ALIGN(piobufs, sizeof(u64) * BITS_PER_BYTE / 2)\r\n/ (sizeof(u64) * BITS_PER_BYTE / 2);\r\nuports = dd->ipath_cfgports ? dd->ipath_cfgports - 1 : 0;\r\nif (piobufs > 144)\r\ndefkbufs = 32 + dd->ipath_pioreserved;\r\nelse\r\ndefkbufs = 16 + dd->ipath_pioreserved;\r\nif (ipath_kpiobufs && (ipath_kpiobufs +\r\n(uports * IPATH_MIN_USER_PORT_BUFCNT)) > piobufs) {\r\nint i = (int) piobufs -\r\n(int) (uports * IPATH_MIN_USER_PORT_BUFCNT);\r\nif (i < 1)\r\ni = 1;\r\ndev_info(&dd->pcidev->dev, "Allocating %d PIO bufs of "\r\n"%d for kernel leaves too few for %d user ports "\r\n"(%d each); using %u\n", ipath_kpiobufs,\r\npiobufs, uports, IPATH_MIN_USER_PORT_BUFCNT, i);\r\nkpiobufs = i;\r\n} else if (ipath_kpiobufs)\r\nkpiobufs = ipath_kpiobufs;\r\nelse\r\nkpiobufs = defkbufs;\r\ndd->ipath_lastport_piobuf = piobufs - kpiobufs;\r\ndd->ipath_pbufsport =\r\nuports ? dd->ipath_lastport_piobuf / uports : 0;\r\ndd->ipath_ports_extrabuf = dd->ipath_lastport_piobuf -\r\n(dd->ipath_pbufsport * uports);\r\nif (dd->ipath_ports_extrabuf)\r\nipath_dbg("%u pbufs/port leaves some unused, add 1 buffer to "\r\n"ports <= %u\n", dd->ipath_pbufsport,\r\ndd->ipath_ports_extrabuf);\r\ndd->ipath_lastpioindex = 0;\r\ndd->ipath_lastpioindexl = dd->ipath_piobcnt2k;\r\nipath_cdbg(VERBOSE, "%d PIO bufs for kernel out of %d total %u "\r\n"each for %u user ports\n", kpiobufs,\r\npiobufs, dd->ipath_pbufsport, uports);\r\nret = dd->ipath_f_early_init(dd);\r\nif (ret) {\r\nipath_dev_err(dd, "Early initialization failure\n");\r\ngoto done;\r\n}\r\ndd->ipath_hdrqlast =\r\ndd->ipath_rcvhdrentsize * (dd->ipath_rcvhdrcnt - 1);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_rcvhdrentsize,\r\ndd->ipath_rcvhdrentsize);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_rcvhdrsize,\r\ndd->ipath_rcvhdrsize);\r\nif (!reinit) {\r\nret = init_pioavailregs(dd);\r\ninit_shadow_tids(dd);\r\nif (ret)\r\ngoto done;\r\n}\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_sendpioavailaddr,\r\ndd->ipath_pioavailregs_phys);\r\nval = ipath_read_kreg64(dd, dd->ipath_kregs->kr_sendpioavailaddr);\r\nif (val != dd->ipath_pioavailregs_phys) {\r\nipath_dev_err(dd, "Catastrophic software error, "\r\n"SendPIOAvailAddr written as %lx, "\r\n"read back as %llx\n",\r\n(unsigned long) dd->ipath_pioavailregs_phys,\r\n(unsigned long long) val);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_rcvbthqp, IPATH_KD_QP);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrmask, 0ULL);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrclear,\r\n~0ULL&~INFINIPATH_HWE_MEMBISTFAILED);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_control, 0ULL);\r\nif (bringup_link(dd)) {\r\ndev_info(&dd->pcidev->dev, "Failed to bringup IB link\n");\r\nret = -ENETDOWN;\r\ngoto done;\r\n}\r\ndd->ipath_f_init_hwerrors(dd);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrclear,\r\n~0ULL&~INFINIPATH_HWE_MEMBISTFAILED);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_hwerrmask,\r\ndd->ipath_hwerrmask);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_errorclear, -1LL);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_errormask,\r\n~dd->ipath_maskederrs);\r\ndd->ipath_maskederrs = 0;\r\ndd->ipath_errormask =\r\nipath_read_kreg64(dd, dd->ipath_kregs->kr_errormask);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_intclear, -1LL);\r\ndd->ipath_f_tidtemplate(dd);\r\npd = dd->ipath_pd[0];\r\nif (reinit) {\r\nstruct ipath_portdata *npd;\r\nnpd = create_portdata0(dd);\r\nif (npd) {\r\nipath_free_pddata(dd, pd);\r\ndd->ipath_pd[0] = npd;\r\npd = npd;\r\n} else {\r\nipath_dev_err(dd, "Unable to allocate portdata"\r\n" for port 0, failing\n");\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\n}\r\nret = ipath_create_rcvhdrq(dd, pd);\r\nif (!ret)\r\nret = create_port0_egr(dd);\r\nif (ret) {\r\nipath_dev_err(dd, "failed to allocate kernel port's "\r\n"rcvhdrq and/or egr bufs\n");\r\ngoto done;\r\n}\r\nelse\r\nenable_chip(dd, reinit);\r\nipath_chg_pioavailkernel(dd, 0, piobufs, 1);\r\nipath_cancel_sends(dd, 1);\r\nif (!reinit) {\r\ndd->ipath_dummy_hdrq = dma_alloc_coherent(\r\n&dd->pcidev->dev, dd->ipath_pd[0]->port_rcvhdrq_size,\r\n&dd->ipath_dummy_hdrq_phys,\r\ngfp_flags);\r\nif (!dd->ipath_dummy_hdrq) {\r\ndev_info(&dd->pcidev->dev,\r\n"Couldn't allocate 0x%lx bytes for dummy hdrq\n",\r\ndd->ipath_pd[0]->port_rcvhdrq_size);\r\ndd->ipath_dummy_hdrq_phys = 0UL;\r\n}\r\n}\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_intclear, 0ULL);\r\nif (!dd->ipath_stats_timer_active) {\r\ninit_timer(&dd->ipath_stats_timer);\r\ndd->ipath_stats_timer.function = ipath_get_faststats;\r\ndd->ipath_stats_timer.data = (unsigned long) dd;\r\ndd->ipath_stats_timer.expires = jiffies + 5 * HZ;\r\nadd_timer(&dd->ipath_stats_timer);\r\ndd->ipath_stats_timer_active = 1;\r\n}\r\nif (dd->ipath_flags & IPATH_HAS_SEND_DMA)\r\nret = setup_sdma(dd);\r\ninit_timer(&dd->ipath_hol_timer);\r\ndd->ipath_hol_timer.function = ipath_hol_event;\r\ndd->ipath_hol_timer.data = (unsigned long)dd;\r\ndd->ipath_hol_state = IPATH_HOL_UP;\r\ndone:\r\nif (!ret) {\r\n*dd->ipath_statusp |= IPATH_STATUS_CHIP_PRESENT;\r\nif (!dd->ipath_f_intrsetup(dd)) {\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_intmask,\r\n-1LL);\r\nipath_write_kreg(dd, dd->ipath_kregs->kr_intclear,\r\n0ULL);\r\n*dd->ipath_statusp |= IPATH_STATUS_INITTED;\r\nif (!reinit) {\r\ninit_timer(&dd->ipath_intrchk_timer);\r\ndd->ipath_intrchk_timer.function =\r\nverify_interrupt;\r\ndd->ipath_intrchk_timer.data =\r\n(unsigned long) dd;\r\n}\r\ndd->ipath_intrchk_timer.expires = jiffies + HZ/2;\r\nadd_timer(&dd->ipath_intrchk_timer);\r\n} else\r\nipath_dev_err(dd, "No interrupts enabled, couldn't "\r\n"setup interrupt address\n");\r\nif (dd->ipath_cfgports > ipath_stats.sps_nports)\r\nipath_stats.sps_nports = dd->ipath_cfgports;\r\n} else\r\nipath_dbg("Failed (%d) to initialize chip\n", ret);\r\nreturn ret;\r\n}\r\nstatic int ipath_set_kpiobufs(const char *str, struct kernel_param *kp)\r\n{\r\nstruct ipath_devdata *dd;\r\nunsigned long flags;\r\nunsigned short val;\r\nint ret;\r\nret = ipath_parse_ushort(str, &val);\r\nspin_lock_irqsave(&ipath_devs_lock, flags);\r\nif (ret < 0)\r\ngoto bail;\r\nif (val == 0) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nlist_for_each_entry(dd, &ipath_dev_list, ipath_list) {\r\nif (dd->ipath_kregbase)\r\ncontinue;\r\nif (val > (dd->ipath_piobcnt2k + dd->ipath_piobcnt4k -\r\n(dd->ipath_cfgports *\r\nIPATH_MIN_USER_PORT_BUFCNT)))\r\n{\r\nipath_dev_err(\r\ndd,\r\n"Allocating %d PIO bufs for kernel leaves "\r\n"too few for %d user ports (%d each)\n",\r\nval, dd->ipath_cfgports - 1,\r\nIPATH_MIN_USER_PORT_BUFCNT);\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\ndd->ipath_lastport_piobuf =\r\ndd->ipath_piobcnt2k + dd->ipath_piobcnt4k - val;\r\n}\r\nipath_kpiobufs = val;\r\nret = 0;\r\nbail:\r\nspin_unlock_irqrestore(&ipath_devs_lock, flags);\r\nreturn ret;\r\n}
