static int sg_allow_access(struct file *filp, unsigned char *cmd)\r\n{\r\nstruct sg_fd *sfp = filp->private_data;\r\nif (sfp->parentdp->device->type == TYPE_SCANNER)\r\nreturn 0;\r\nreturn blk_verify_command(cmd, filp->f_mode & FMODE_WRITE);\r\n}\r\nstatic int get_exclude(Sg_device *sdp)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&sg_open_exclusive_lock, flags);\r\nret = sdp->exclude;\r\nspin_unlock_irqrestore(&sg_open_exclusive_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int set_exclude(Sg_device *sdp, char val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sg_open_exclusive_lock, flags);\r\nsdp->exclude = val;\r\nspin_unlock_irqrestore(&sg_open_exclusive_lock, flags);\r\nreturn val;\r\n}\r\nstatic int sfds_list_empty(Sg_device *sdp)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nread_lock_irqsave(&sg_index_lock, flags);\r\nret = list_empty(&sdp->sfds);\r\nread_unlock_irqrestore(&sg_index_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int\r\nsg_open(struct inode *inode, struct file *filp)\r\n{\r\nint dev = iminor(inode);\r\nint flags = filp->f_flags;\r\nstruct request_queue *q;\r\nSg_device *sdp;\r\nSg_fd *sfp;\r\nint res;\r\nint retval;\r\nnonseekable_open(inode, filp);\r\nSCSI_LOG_TIMEOUT(3, printk("sg_open: dev=%d, flags=0x%x\n", dev, flags));\r\nsdp = sg_get_dev(dev);\r\nif (IS_ERR(sdp)) {\r\nretval = PTR_ERR(sdp);\r\nsdp = NULL;\r\ngoto sg_put;\r\n}\r\nretval = scsi_device_get(sdp->device);\r\nif (retval)\r\ngoto sg_put;\r\nretval = scsi_autopm_get_device(sdp->device);\r\nif (retval)\r\ngoto sdp_put;\r\nif (!((flags & O_NONBLOCK) ||\r\nscsi_block_when_processing_errors(sdp->device))) {\r\nretval = -ENXIO;\r\ngoto error_out;\r\n}\r\nif (flags & O_EXCL) {\r\nif (O_RDONLY == (flags & O_ACCMODE)) {\r\nretval = -EPERM;\r\ngoto error_out;\r\n}\r\nif (!sfds_list_empty(sdp) && (flags & O_NONBLOCK)) {\r\nretval = -EBUSY;\r\ngoto error_out;\r\n}\r\nres = wait_event_interruptible(sdp->o_excl_wait,\r\n((!sfds_list_empty(sdp) || get_exclude(sdp)) ? 0 : set_exclude(sdp, 1)));\r\nif (res) {\r\nretval = res;\r\ngoto error_out;\r\n}\r\n} else if (get_exclude(sdp)) {\r\nif (flags & O_NONBLOCK) {\r\nretval = -EBUSY;\r\ngoto error_out;\r\n}\r\nres = wait_event_interruptible(sdp->o_excl_wait, !get_exclude(sdp));\r\nif (res) {\r\nretval = res;\r\ngoto error_out;\r\n}\r\n}\r\nif (sdp->detached) {\r\nretval = -ENODEV;\r\ngoto error_out;\r\n}\r\nif (sfds_list_empty(sdp)) {\r\nsdp->sgdebug = 0;\r\nq = sdp->device->request_queue;\r\nsdp->sg_tablesize = queue_max_segments(q);\r\n}\r\nif ((sfp = sg_add_sfp(sdp, dev)))\r\nfilp->private_data = sfp;\r\nelse {\r\nif (flags & O_EXCL) {\r\nset_exclude(sdp, 0);\r\nwake_up_interruptible(&sdp->o_excl_wait);\r\n}\r\nretval = -ENOMEM;\r\ngoto error_out;\r\n}\r\nretval = 0;\r\nerror_out:\r\nif (retval) {\r\nscsi_autopm_put_device(sdp->device);\r\nsdp_put:\r\nscsi_device_put(sdp->device);\r\n}\r\nsg_put:\r\nif (sdp)\r\nsg_put_dev(sdp);\r\nreturn retval;\r\n}\r\nstatic int\r\nsg_release(struct inode *inode, struct file *filp)\r\n{\r\nSg_device *sdp;\r\nSg_fd *sfp;\r\nif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\r\nreturn -ENXIO;\r\nSCSI_LOG_TIMEOUT(3, printk("sg_release: %s\n", sdp->disk->disk_name));\r\nset_exclude(sdp, 0);\r\nwake_up_interruptible(&sdp->o_excl_wait);\r\nscsi_autopm_put_device(sdp->device);\r\nkref_put(&sfp->f_ref, sg_remove_sfp);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nsg_read(struct file *filp, char __user *buf, size_t count, loff_t * ppos)\r\n{\r\nSg_device *sdp;\r\nSg_fd *sfp;\r\nSg_request *srp;\r\nint req_pack_id = -1;\r\nsg_io_hdr_t *hp;\r\nstruct sg_header *old_hdr = NULL;\r\nint retval = 0;\r\nif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\r\nreturn -ENXIO;\r\nSCSI_LOG_TIMEOUT(3, printk("sg_read: %s, count=%d\n",\r\nsdp->disk->disk_name, (int) count));\r\nif (!access_ok(VERIFY_WRITE, buf, count))\r\nreturn -EFAULT;\r\nif (sfp->force_packid && (count >= SZ_SG_HEADER)) {\r\nold_hdr = kmalloc(SZ_SG_HEADER, GFP_KERNEL);\r\nif (!old_hdr)\r\nreturn -ENOMEM;\r\nif (__copy_from_user(old_hdr, buf, SZ_SG_HEADER)) {\r\nretval = -EFAULT;\r\ngoto free_old_hdr;\r\n}\r\nif (old_hdr->reply_len < 0) {\r\nif (count >= SZ_SG_IO_HDR) {\r\nsg_io_hdr_t *new_hdr;\r\nnew_hdr = kmalloc(SZ_SG_IO_HDR, GFP_KERNEL);\r\nif (!new_hdr) {\r\nretval = -ENOMEM;\r\ngoto free_old_hdr;\r\n}\r\nretval =__copy_from_user\r\n(new_hdr, buf, SZ_SG_IO_HDR);\r\nreq_pack_id = new_hdr->pack_id;\r\nkfree(new_hdr);\r\nif (retval) {\r\nretval = -EFAULT;\r\ngoto free_old_hdr;\r\n}\r\n}\r\n} else\r\nreq_pack_id = old_hdr->pack_id;\r\n}\r\nsrp = sg_get_rq_mark(sfp, req_pack_id);\r\nif (!srp) {\r\nif (sdp->detached) {\r\nretval = -ENODEV;\r\ngoto free_old_hdr;\r\n}\r\nif (filp->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\ngoto free_old_hdr;\r\n}\r\nretval = wait_event_interruptible(sfp->read_wait,\r\n(sdp->detached ||\r\n(srp = sg_get_rq_mark(sfp, req_pack_id))));\r\nif (sdp->detached) {\r\nretval = -ENODEV;\r\ngoto free_old_hdr;\r\n}\r\nif (retval) {\r\ngoto free_old_hdr;\r\n}\r\n}\r\nif (srp->header.interface_id != '\0') {\r\nretval = sg_new_read(sfp, buf, count, srp);\r\ngoto free_old_hdr;\r\n}\r\nhp = &srp->header;\r\nif (old_hdr == NULL) {\r\nold_hdr = kmalloc(SZ_SG_HEADER, GFP_KERNEL);\r\nif (! old_hdr) {\r\nretval = -ENOMEM;\r\ngoto free_old_hdr;\r\n}\r\n}\r\nmemset(old_hdr, 0, SZ_SG_HEADER);\r\nold_hdr->reply_len = (int) hp->timeout;\r\nold_hdr->pack_len = old_hdr->reply_len;\r\nold_hdr->pack_id = hp->pack_id;\r\nold_hdr->twelve_byte =\r\n((srp->data.cmd_opcode >= 0xc0) && (12 == hp->cmd_len)) ? 1 : 0;\r\nold_hdr->target_status = hp->masked_status;\r\nold_hdr->host_status = hp->host_status;\r\nold_hdr->driver_status = hp->driver_status;\r\nif ((CHECK_CONDITION & hp->masked_status) ||\r\n(DRIVER_SENSE & hp->driver_status))\r\nmemcpy(old_hdr->sense_buffer, srp->sense_b,\r\nsizeof (old_hdr->sense_buffer));\r\nswitch (hp->host_status) {\r\ncase DID_OK:\r\ncase DID_PASSTHROUGH:\r\ncase DID_SOFT_ERROR:\r\nold_hdr->result = 0;\r\nbreak;\r\ncase DID_NO_CONNECT:\r\ncase DID_BUS_BUSY:\r\ncase DID_TIME_OUT:\r\nold_hdr->result = EBUSY;\r\nbreak;\r\ncase DID_BAD_TARGET:\r\ncase DID_ABORT:\r\ncase DID_PARITY:\r\ncase DID_RESET:\r\ncase DID_BAD_INTR:\r\nold_hdr->result = EIO;\r\nbreak;\r\ncase DID_ERROR:\r\nold_hdr->result = (srp->sense_b[0] == 0 &&\r\nhp->masked_status == GOOD) ? 0 : EIO;\r\nbreak;\r\ndefault:\r\nold_hdr->result = EIO;\r\nbreak;\r\n}\r\nif (count >= SZ_SG_HEADER) {\r\nif (__copy_to_user(buf, old_hdr, SZ_SG_HEADER)) {\r\nretval = -EFAULT;\r\ngoto free_old_hdr;\r\n}\r\nbuf += SZ_SG_HEADER;\r\nif (count > old_hdr->reply_len)\r\ncount = old_hdr->reply_len;\r\nif (count > SZ_SG_HEADER) {\r\nif (sg_read_oxfer(srp, buf, count - SZ_SG_HEADER)) {\r\nretval = -EFAULT;\r\ngoto free_old_hdr;\r\n}\r\n}\r\n} else\r\ncount = (old_hdr->result == 0) ? 0 : -EIO;\r\nsg_finish_rem_req(srp);\r\nretval = count;\r\nfree_old_hdr:\r\nkfree(old_hdr);\r\nreturn retval;\r\n}\r\nstatic ssize_t\r\nsg_new_read(Sg_fd * sfp, char __user *buf, size_t count, Sg_request * srp)\r\n{\r\nsg_io_hdr_t *hp = &srp->header;\r\nint err = 0;\r\nint len;\r\nif (count < SZ_SG_IO_HDR) {\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\nhp->sb_len_wr = 0;\r\nif ((hp->mx_sb_len > 0) && hp->sbp) {\r\nif ((CHECK_CONDITION & hp->masked_status) ||\r\n(DRIVER_SENSE & hp->driver_status)) {\r\nint sb_len = SCSI_SENSE_BUFFERSIZE;\r\nsb_len = (hp->mx_sb_len > sb_len) ? sb_len : hp->mx_sb_len;\r\nlen = 8 + (int) srp->sense_b[7];\r\nlen = (len > sb_len) ? sb_len : len;\r\nif (copy_to_user(hp->sbp, srp->sense_b, len)) {\r\nerr = -EFAULT;\r\ngoto err_out;\r\n}\r\nhp->sb_len_wr = len;\r\n}\r\n}\r\nif (hp->masked_status || hp->host_status || hp->driver_status)\r\nhp->info |= SG_INFO_CHECK;\r\nif (copy_to_user(buf, hp, SZ_SG_IO_HDR)) {\r\nerr = -EFAULT;\r\ngoto err_out;\r\n}\r\nerr_out:\r\nerr = sg_finish_rem_req(srp);\r\nreturn (0 == err) ? count : err;\r\n}\r\nstatic ssize_t\r\nsg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)\r\n{\r\nint mxsize, cmd_size, k;\r\nint input_size, blocking;\r\nunsigned char opcode;\r\nSg_device *sdp;\r\nSg_fd *sfp;\r\nSg_request *srp;\r\nstruct sg_header old_hdr;\r\nsg_io_hdr_t *hp;\r\nunsigned char cmnd[MAX_COMMAND_SIZE];\r\nif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\r\nreturn -ENXIO;\r\nSCSI_LOG_TIMEOUT(3, printk("sg_write: %s, count=%d\n",\r\nsdp->disk->disk_name, (int) count));\r\nif (sdp->detached)\r\nreturn -ENODEV;\r\nif (!((filp->f_flags & O_NONBLOCK) ||\r\nscsi_block_when_processing_errors(sdp->device)))\r\nreturn -ENXIO;\r\nif (!access_ok(VERIFY_READ, buf, count))\r\nreturn -EFAULT;\r\nif (count < SZ_SG_HEADER)\r\nreturn -EIO;\r\nif (__copy_from_user(&old_hdr, buf, SZ_SG_HEADER))\r\nreturn -EFAULT;\r\nblocking = !(filp->f_flags & O_NONBLOCK);\r\nif (old_hdr.reply_len < 0)\r\nreturn sg_new_write(sfp, filp, buf, count,\r\nblocking, 0, 0, NULL);\r\nif (count < (SZ_SG_HEADER + 6))\r\nreturn -EIO;\r\nif (!(srp = sg_add_request(sfp))) {\r\nSCSI_LOG_TIMEOUT(1, printk("sg_write: queue full\n"));\r\nreturn -EDOM;\r\n}\r\nbuf += SZ_SG_HEADER;\r\n__get_user(opcode, buf);\r\nif (sfp->next_cmd_len > 0) {\r\nif (sfp->next_cmd_len > MAX_COMMAND_SIZE) {\r\nSCSI_LOG_TIMEOUT(1, printk("sg_write: command length too long\n"));\r\nsfp->next_cmd_len = 0;\r\nsg_remove_request(sfp, srp);\r\nreturn -EIO;\r\n}\r\ncmd_size = sfp->next_cmd_len;\r\nsfp->next_cmd_len = 0;\r\n} else {\r\ncmd_size = COMMAND_SIZE(opcode);\r\nif ((opcode >= 0xc0) && old_hdr.twelve_byte)\r\ncmd_size = 12;\r\n}\r\nSCSI_LOG_TIMEOUT(4, printk(\r\n"sg_write: scsi opcode=0x%02x, cmd_size=%d\n", (int) opcode, cmd_size));\r\ninput_size = count - cmd_size;\r\nmxsize = (input_size > old_hdr.reply_len) ? input_size : old_hdr.reply_len;\r\nmxsize -= SZ_SG_HEADER;\r\ninput_size -= SZ_SG_HEADER;\r\nif (input_size < 0) {\r\nsg_remove_request(sfp, srp);\r\nreturn -EIO;\r\n}\r\nhp = &srp->header;\r\nhp->interface_id = '\0';\r\nhp->cmd_len = (unsigned char) cmd_size;\r\nhp->iovec_count = 0;\r\nhp->mx_sb_len = 0;\r\nif (input_size > 0)\r\nhp->dxfer_direction = (old_hdr.reply_len > SZ_SG_HEADER) ?\r\nSG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV;\r\nelse\r\nhp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;\r\nhp->dxfer_len = mxsize;\r\nif (hp->dxfer_direction == SG_DXFER_TO_DEV)\r\nhp->dxferp = (char __user *)buf + cmd_size;\r\nelse\r\nhp->dxferp = NULL;\r\nhp->sbp = NULL;\r\nhp->timeout = old_hdr.reply_len;\r\nhp->flags = input_size;\r\nhp->pack_id = old_hdr.pack_id;\r\nhp->usr_ptr = NULL;\r\nif (__copy_from_user(cmnd, buf, cmd_size))\r\nreturn -EFAULT;\r\nif (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV) {\r\nstatic char cmd[TASK_COMM_LEN];\r\nif (strcmp(current->comm, cmd)) {\r\nprintk_ratelimited(KERN_WARNING\r\n"sg_write: data in/out %d/%d bytes "\r\n"for SCSI command 0x%x-- guessing "\r\n"data in;\n program %s not setting "\r\n"count and/or reply_len properly\n",\r\nold_hdr.reply_len - (int)SZ_SG_HEADER,\r\ninput_size, (unsigned int) cmnd[0],\r\ncurrent->comm);\r\nstrcpy(cmd, current->comm);\r\n}\r\n}\r\nk = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking);\r\nreturn (k < 0) ? k : count;\r\n}\r\nstatic ssize_t\r\nsg_new_write(Sg_fd *sfp, struct file *file, const char __user *buf,\r\nsize_t count, int blocking, int read_only, int sg_io_owned,\r\nSg_request **o_srp)\r\n{\r\nint k;\r\nSg_request *srp;\r\nsg_io_hdr_t *hp;\r\nunsigned char cmnd[MAX_COMMAND_SIZE];\r\nint timeout;\r\nunsigned long ul_timeout;\r\nif (count < SZ_SG_IO_HDR)\r\nreturn -EINVAL;\r\nif (!access_ok(VERIFY_READ, buf, count))\r\nreturn -EFAULT;\r\nsfp->cmd_q = 1;\r\nif (!(srp = sg_add_request(sfp))) {\r\nSCSI_LOG_TIMEOUT(1, printk("sg_new_write: queue full\n"));\r\nreturn -EDOM;\r\n}\r\nsrp->sg_io_owned = sg_io_owned;\r\nhp = &srp->header;\r\nif (__copy_from_user(hp, buf, SZ_SG_IO_HDR)) {\r\nsg_remove_request(sfp, srp);\r\nreturn -EFAULT;\r\n}\r\nif (hp->interface_id != 'S') {\r\nsg_remove_request(sfp, srp);\r\nreturn -ENOSYS;\r\n}\r\nif (hp->flags & SG_FLAG_MMAP_IO) {\r\nif (hp->dxfer_len > sfp->reserve.bufflen) {\r\nsg_remove_request(sfp, srp);\r\nreturn -ENOMEM;\r\n}\r\nif (hp->flags & SG_FLAG_DIRECT_IO) {\r\nsg_remove_request(sfp, srp);\r\nreturn -EINVAL;\r\n}\r\nif (sg_res_in_use(sfp)) {\r\nsg_remove_request(sfp, srp);\r\nreturn -EBUSY;\r\n}\r\n}\r\nul_timeout = msecs_to_jiffies(srp->header.timeout);\r\ntimeout = (ul_timeout < INT_MAX) ? ul_timeout : INT_MAX;\r\nif ((!hp->cmdp) || (hp->cmd_len < 6) || (hp->cmd_len > sizeof (cmnd))) {\r\nsg_remove_request(sfp, srp);\r\nreturn -EMSGSIZE;\r\n}\r\nif (!access_ok(VERIFY_READ, hp->cmdp, hp->cmd_len)) {\r\nsg_remove_request(sfp, srp);\r\nreturn -EFAULT;\r\n}\r\nif (__copy_from_user(cmnd, hp->cmdp, hp->cmd_len)) {\r\nsg_remove_request(sfp, srp);\r\nreturn -EFAULT;\r\n}\r\nif (read_only && sg_allow_access(file, cmnd)) {\r\nsg_remove_request(sfp, srp);\r\nreturn -EPERM;\r\n}\r\nk = sg_common_write(sfp, srp, cmnd, timeout, blocking);\r\nif (k < 0)\r\nreturn k;\r\nif (o_srp)\r\n*o_srp = srp;\r\nreturn count;\r\n}\r\nstatic int\r\nsg_common_write(Sg_fd * sfp, Sg_request * srp,\r\nunsigned char *cmnd, int timeout, int blocking)\r\n{\r\nint k, data_dir;\r\nSg_device *sdp = sfp->parentdp;\r\nsg_io_hdr_t *hp = &srp->header;\r\nsrp->data.cmd_opcode = cmnd[0];\r\nhp->status = 0;\r\nhp->masked_status = 0;\r\nhp->msg_status = 0;\r\nhp->info = 0;\r\nhp->host_status = 0;\r\nhp->driver_status = 0;\r\nhp->resid = 0;\r\nSCSI_LOG_TIMEOUT(4, printk("sg_common_write: scsi opcode=0x%02x, cmd_size=%d\n",\r\n(int) cmnd[0], (int) hp->cmd_len));\r\nk = sg_start_req(srp, cmnd);\r\nif (k) {\r\nSCSI_LOG_TIMEOUT(1, printk("sg_common_write: start_req err=%d\n", k));\r\nsg_finish_rem_req(srp);\r\nreturn k;\r\n}\r\nif (sdp->detached) {\r\nif (srp->bio)\r\nblk_end_request_all(srp->rq, -EIO);\r\nsg_finish_rem_req(srp);\r\nreturn -ENODEV;\r\n}\r\nswitch (hp->dxfer_direction) {\r\ncase SG_DXFER_TO_FROM_DEV:\r\ncase SG_DXFER_FROM_DEV:\r\ndata_dir = DMA_FROM_DEVICE;\r\nbreak;\r\ncase SG_DXFER_TO_DEV:\r\ndata_dir = DMA_TO_DEVICE;\r\nbreak;\r\ncase SG_DXFER_UNKNOWN:\r\ndata_dir = DMA_BIDIRECTIONAL;\r\nbreak;\r\ndefault:\r\ndata_dir = DMA_NONE;\r\nbreak;\r\n}\r\nhp->duration = jiffies_to_msecs(jiffies);\r\nsrp->rq->timeout = timeout;\r\nkref_get(&sfp->f_ref);\r\nblk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,\r\nsrp->rq, 1, sg_rq_end_io);\r\nreturn 0;\r\n}\r\nstatic int srp_done(Sg_fd *sfp, Sg_request *srp)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nread_lock_irqsave(&sfp->rq_list_lock, flags);\r\nret = srp->done;\r\nread_unlock_irqrestore(&sfp->rq_list_lock, flags);\r\nreturn ret;\r\n}\r\nstatic long\r\nsg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)\r\n{\r\nvoid __user *p = (void __user *)arg;\r\nint __user *ip = p;\r\nint result, val, read_only;\r\nSg_device *sdp;\r\nSg_fd *sfp;\r\nSg_request *srp;\r\nunsigned long iflags;\r\nif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\r\nreturn -ENXIO;\r\nSCSI_LOG_TIMEOUT(3, printk("sg_ioctl: %s, cmd=0x%x\n",\r\nsdp->disk->disk_name, (int) cmd_in));\r\nread_only = (O_RDWR != (filp->f_flags & O_ACCMODE));\r\nswitch (cmd_in) {\r\ncase SG_IO:\r\nif (sdp->detached)\r\nreturn -ENODEV;\r\nif (!scsi_block_when_processing_errors(sdp->device))\r\nreturn -ENXIO;\r\nif (!access_ok(VERIFY_WRITE, p, SZ_SG_IO_HDR))\r\nreturn -EFAULT;\r\nresult = sg_new_write(sfp, filp, p, SZ_SG_IO_HDR,\r\n1, read_only, 1, &srp);\r\nif (result < 0)\r\nreturn result;\r\nresult = wait_event_interruptible(sfp->read_wait,\r\n(srp_done(sfp, srp) || sdp->detached));\r\nif (sdp->detached)\r\nreturn -ENODEV;\r\nwrite_lock_irq(&sfp->rq_list_lock);\r\nif (srp->done) {\r\nsrp->done = 2;\r\nwrite_unlock_irq(&sfp->rq_list_lock);\r\nresult = sg_new_read(sfp, p, SZ_SG_IO_HDR, srp);\r\nreturn (result < 0) ? result : 0;\r\n}\r\nsrp->orphan = 1;\r\nwrite_unlock_irq(&sfp->rq_list_lock);\r\nreturn result;\r\ncase SG_SET_TIMEOUT:\r\nresult = get_user(val, ip);\r\nif (result)\r\nreturn result;\r\nif (val < 0)\r\nreturn -EIO;\r\nif (val >= MULDIV (INT_MAX, USER_HZ, HZ))\r\nval = MULDIV (INT_MAX, USER_HZ, HZ);\r\nsfp->timeout_user = val;\r\nsfp->timeout = MULDIV (val, HZ, USER_HZ);\r\nreturn 0;\r\ncase SG_GET_TIMEOUT:\r\nreturn sfp->timeout_user;\r\ncase SG_SET_FORCE_LOW_DMA:\r\nresult = get_user(val, ip);\r\nif (result)\r\nreturn result;\r\nif (val) {\r\nsfp->low_dma = 1;\r\nif ((0 == sfp->low_dma) && (0 == sg_res_in_use(sfp))) {\r\nval = (int) sfp->reserve.bufflen;\r\nsg_remove_scat(&sfp->reserve);\r\nsg_build_reserve(sfp, val);\r\n}\r\n} else {\r\nif (sdp->detached)\r\nreturn -ENODEV;\r\nsfp->low_dma = sdp->device->host->unchecked_isa_dma;\r\n}\r\nreturn 0;\r\ncase SG_GET_LOW_DMA:\r\nreturn put_user((int) sfp->low_dma, ip);\r\ncase SG_GET_SCSI_ID:\r\nif (!access_ok(VERIFY_WRITE, p, sizeof (sg_scsi_id_t)))\r\nreturn -EFAULT;\r\nelse {\r\nsg_scsi_id_t __user *sg_idp = p;\r\nif (sdp->detached)\r\nreturn -ENODEV;\r\n__put_user((int) sdp->device->host->host_no,\r\n&sg_idp->host_no);\r\n__put_user((int) sdp->device->channel,\r\n&sg_idp->channel);\r\n__put_user((int) sdp->device->id, &sg_idp->scsi_id);\r\n__put_user((int) sdp->device->lun, &sg_idp->lun);\r\n__put_user((int) sdp->device->type, &sg_idp->scsi_type);\r\n__put_user((short) sdp->device->host->cmd_per_lun,\r\n&sg_idp->h_cmd_per_lun);\r\n__put_user((short) sdp->device->queue_depth,\r\n&sg_idp->d_queue_depth);\r\n__put_user(0, &sg_idp->unused[0]);\r\n__put_user(0, &sg_idp->unused[1]);\r\nreturn 0;\r\n}\r\ncase SG_SET_FORCE_PACK_ID:\r\nresult = get_user(val, ip);\r\nif (result)\r\nreturn result;\r\nsfp->force_packid = val ? 1 : 0;\r\nreturn 0;\r\ncase SG_GET_PACK_ID:\r\nif (!access_ok(VERIFY_WRITE, ip, sizeof (int)))\r\nreturn -EFAULT;\r\nread_lock_irqsave(&sfp->rq_list_lock, iflags);\r\nfor (srp = sfp->headrp; srp; srp = srp->nextrp) {\r\nif ((1 == srp->done) && (!srp->sg_io_owned)) {\r\nread_unlock_irqrestore(&sfp->rq_list_lock,\r\niflags);\r\n__put_user(srp->header.pack_id, ip);\r\nreturn 0;\r\n}\r\n}\r\nread_unlock_irqrestore(&sfp->rq_list_lock, iflags);\r\n__put_user(-1, ip);\r\nreturn 0;\r\ncase SG_GET_NUM_WAITING:\r\nread_lock_irqsave(&sfp->rq_list_lock, iflags);\r\nfor (val = 0, srp = sfp->headrp; srp; srp = srp->nextrp) {\r\nif ((1 == srp->done) && (!srp->sg_io_owned))\r\n++val;\r\n}\r\nread_unlock_irqrestore(&sfp->rq_list_lock, iflags);\r\nreturn put_user(val, ip);\r\ncase SG_GET_SG_TABLESIZE:\r\nreturn put_user(sdp->sg_tablesize, ip);\r\ncase SG_SET_RESERVED_SIZE:\r\nresult = get_user(val, ip);\r\nif (result)\r\nreturn result;\r\nif (val < 0)\r\nreturn -EINVAL;\r\nval = min_t(int, val,\r\nqueue_max_sectors(sdp->device->request_queue) * 512);\r\nif (val != sfp->reserve.bufflen) {\r\nif (sg_res_in_use(sfp) || sfp->mmap_called)\r\nreturn -EBUSY;\r\nsg_remove_scat(&sfp->reserve);\r\nsg_build_reserve(sfp, val);\r\n}\r\nreturn 0;\r\ncase SG_GET_RESERVED_SIZE:\r\nval = min_t(int, sfp->reserve.bufflen,\r\nqueue_max_sectors(sdp->device->request_queue) * 512);\r\nreturn put_user(val, ip);\r\ncase SG_SET_COMMAND_Q:\r\nresult = get_user(val, ip);\r\nif (result)\r\nreturn result;\r\nsfp->cmd_q = val ? 1 : 0;\r\nreturn 0;\r\ncase SG_GET_COMMAND_Q:\r\nreturn put_user((int) sfp->cmd_q, ip);\r\ncase SG_SET_KEEP_ORPHAN:\r\nresult = get_user(val, ip);\r\nif (result)\r\nreturn result;\r\nsfp->keep_orphan = val;\r\nreturn 0;\r\ncase SG_GET_KEEP_ORPHAN:\r\nreturn put_user((int) sfp->keep_orphan, ip);\r\ncase SG_NEXT_CMD_LEN:\r\nresult = get_user(val, ip);\r\nif (result)\r\nreturn result;\r\nsfp->next_cmd_len = (val > 0) ? val : 0;\r\nreturn 0;\r\ncase SG_GET_VERSION_NUM:\r\nreturn put_user(sg_version_num, ip);\r\ncase SG_GET_ACCESS_COUNT:\r\nval = (sdp->device ? 1 : 0);\r\nreturn put_user(val, ip);\r\ncase SG_GET_REQUEST_TABLE:\r\nif (!access_ok(VERIFY_WRITE, p, SZ_SG_REQ_INFO * SG_MAX_QUEUE))\r\nreturn -EFAULT;\r\nelse {\r\nsg_req_info_t *rinfo;\r\nunsigned int ms;\r\nrinfo = kmalloc(SZ_SG_REQ_INFO * SG_MAX_QUEUE,\r\nGFP_KERNEL);\r\nif (!rinfo)\r\nreturn -ENOMEM;\r\nread_lock_irqsave(&sfp->rq_list_lock, iflags);\r\nfor (srp = sfp->headrp, val = 0; val < SG_MAX_QUEUE;\r\n++val, srp = srp ? srp->nextrp : srp) {\r\nmemset(&rinfo[val], 0, SZ_SG_REQ_INFO);\r\nif (srp) {\r\nrinfo[val].req_state = srp->done + 1;\r\nrinfo[val].problem =\r\nsrp->header.masked_status &\r\nsrp->header.host_status &\r\nsrp->header.driver_status;\r\nif (srp->done)\r\nrinfo[val].duration =\r\nsrp->header.duration;\r\nelse {\r\nms = jiffies_to_msecs(jiffies);\r\nrinfo[val].duration =\r\n(ms > srp->header.duration) ?\r\n(ms - srp->header.duration) : 0;\r\n}\r\nrinfo[val].orphan = srp->orphan;\r\nrinfo[val].sg_io_owned =\r\nsrp->sg_io_owned;\r\nrinfo[val].pack_id =\r\nsrp->header.pack_id;\r\nrinfo[val].usr_ptr =\r\nsrp->header.usr_ptr;\r\n}\r\n}\r\nread_unlock_irqrestore(&sfp->rq_list_lock, iflags);\r\nresult = __copy_to_user(p, rinfo,\r\nSZ_SG_REQ_INFO * SG_MAX_QUEUE);\r\nresult = result ? -EFAULT : 0;\r\nkfree(rinfo);\r\nreturn result;\r\n}\r\ncase SG_EMULATED_HOST:\r\nif (sdp->detached)\r\nreturn -ENODEV;\r\nreturn put_user(sdp->device->host->hostt->emulated, ip);\r\ncase SG_SCSI_RESET:\r\nif (sdp->detached)\r\nreturn -ENODEV;\r\nif (filp->f_flags & O_NONBLOCK) {\r\nif (scsi_host_in_recovery(sdp->device->host))\r\nreturn -EBUSY;\r\n} else if (!scsi_block_when_processing_errors(sdp->device))\r\nreturn -EBUSY;\r\nresult = get_user(val, ip);\r\nif (result)\r\nreturn result;\r\nif (SG_SCSI_RESET_NOTHING == val)\r\nreturn 0;\r\nswitch (val) {\r\ncase SG_SCSI_RESET_DEVICE:\r\nval = SCSI_TRY_RESET_DEVICE;\r\nbreak;\r\ncase SG_SCSI_RESET_TARGET:\r\nval = SCSI_TRY_RESET_TARGET;\r\nbreak;\r\ncase SG_SCSI_RESET_BUS:\r\nval = SCSI_TRY_RESET_BUS;\r\nbreak;\r\ncase SG_SCSI_RESET_HOST:\r\nval = SCSI_TRY_RESET_HOST;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\nreturn (scsi_reset_provider(sdp->device, val) ==\r\nSUCCESS) ? 0 : -EIO;\r\ncase SCSI_IOCTL_SEND_COMMAND:\r\nif (sdp->detached)\r\nreturn -ENODEV;\r\nif (read_only) {\r\nunsigned char opcode = WRITE_6;\r\nScsi_Ioctl_Command __user *siocp = p;\r\nif (copy_from_user(&opcode, siocp->data, 1))\r\nreturn -EFAULT;\r\nif (sg_allow_access(filp, &opcode))\r\nreturn -EPERM;\r\n}\r\nreturn sg_scsi_ioctl(sdp->device->request_queue, NULL, filp->f_mode, p);\r\ncase SG_SET_DEBUG:\r\nresult = get_user(val, ip);\r\nif (result)\r\nreturn result;\r\nsdp->sgdebug = (char) val;\r\nreturn 0;\r\ncase SCSI_IOCTL_GET_IDLUN:\r\ncase SCSI_IOCTL_GET_BUS_NUMBER:\r\ncase SCSI_IOCTL_PROBE_HOST:\r\ncase SG_GET_TRANSFORM:\r\nif (sdp->detached)\r\nreturn -ENODEV;\r\nreturn scsi_ioctl(sdp->device, cmd_in, p);\r\ncase BLKSECTGET:\r\nreturn put_user(queue_max_sectors(sdp->device->request_queue) * 512,\r\nip);\r\ncase BLKTRACESETUP:\r\nreturn blk_trace_setup(sdp->device->request_queue,\r\nsdp->disk->disk_name,\r\nMKDEV(SCSI_GENERIC_MAJOR, sdp->index),\r\nNULL,\r\n(char *)arg);\r\ncase BLKTRACESTART:\r\nreturn blk_trace_startstop(sdp->device->request_queue, 1);\r\ncase BLKTRACESTOP:\r\nreturn blk_trace_startstop(sdp->device->request_queue, 0);\r\ncase BLKTRACETEARDOWN:\r\nreturn blk_trace_remove(sdp->device->request_queue);\r\ndefault:\r\nif (read_only)\r\nreturn -EPERM;\r\nreturn scsi_ioctl(sdp->device, cmd_in, p);\r\n}\r\n}\r\nstatic long sg_compat_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)\r\n{\r\nSg_device *sdp;\r\nSg_fd *sfp;\r\nstruct scsi_device *sdev;\r\nif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\r\nreturn -ENXIO;\r\nsdev = sdp->device;\r\nif (sdev->host->hostt->compat_ioctl) {\r\nint ret;\r\nret = sdev->host->hostt->compat_ioctl(sdev, cmd_in, (void __user *)arg);\r\nreturn ret;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic unsigned int\r\nsg_poll(struct file *filp, poll_table * wait)\r\n{\r\nunsigned int res = 0;\r\nSg_device *sdp;\r\nSg_fd *sfp;\r\nSg_request *srp;\r\nint count = 0;\r\nunsigned long iflags;\r\nsfp = filp->private_data;\r\nif (!sfp)\r\nreturn POLLERR;\r\nsdp = sfp->parentdp;\r\nif (!sdp)\r\nreturn POLLERR;\r\npoll_wait(filp, &sfp->read_wait, wait);\r\nread_lock_irqsave(&sfp->rq_list_lock, iflags);\r\nfor (srp = sfp->headrp; srp; srp = srp->nextrp) {\r\nif ((0 == res) && (1 == srp->done) && (!srp->sg_io_owned))\r\nres = POLLIN | POLLRDNORM;\r\n++count;\r\n}\r\nread_unlock_irqrestore(&sfp->rq_list_lock, iflags);\r\nif (sdp->detached)\r\nres |= POLLHUP;\r\nelse if (!sfp->cmd_q) {\r\nif (0 == count)\r\nres |= POLLOUT | POLLWRNORM;\r\n} else if (count < SG_MAX_QUEUE)\r\nres |= POLLOUT | POLLWRNORM;\r\nSCSI_LOG_TIMEOUT(3, printk("sg_poll: %s, res=0x%x\n",\r\nsdp->disk->disk_name, (int) res));\r\nreturn res;\r\n}\r\nstatic int\r\nsg_fasync(int fd, struct file *filp, int mode)\r\n{\r\nSg_device *sdp;\r\nSg_fd *sfp;\r\nif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\r\nreturn -ENXIO;\r\nSCSI_LOG_TIMEOUT(3, printk("sg_fasync: %s, mode=%d\n",\r\nsdp->disk->disk_name, mode));\r\nreturn fasync_helper(fd, filp, mode, &sfp->async_qp);\r\n}\r\nstatic int\r\nsg_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\r\n{\r\nSg_fd *sfp;\r\nunsigned long offset, len, sa;\r\nSg_scatter_hold *rsv_schp;\r\nint k, length;\r\nif ((NULL == vma) || (!(sfp = (Sg_fd *) vma->vm_private_data)))\r\nreturn VM_FAULT_SIGBUS;\r\nrsv_schp = &sfp->reserve;\r\noffset = vmf->pgoff << PAGE_SHIFT;\r\nif (offset >= rsv_schp->bufflen)\r\nreturn VM_FAULT_SIGBUS;\r\nSCSI_LOG_TIMEOUT(3, printk("sg_vma_fault: offset=%lu, scatg=%d\n",\r\noffset, rsv_schp->k_use_sg));\r\nsa = vma->vm_start;\r\nlength = 1 << (PAGE_SHIFT + rsv_schp->page_order);\r\nfor (k = 0; k < rsv_schp->k_use_sg && sa < vma->vm_end; k++) {\r\nlen = vma->vm_end - sa;\r\nlen = (len < length) ? len : length;\r\nif (offset < len) {\r\nstruct page *page = nth_page(rsv_schp->pages[k],\r\noffset >> PAGE_SHIFT);\r\nget_page(page);\r\nvmf->page = page;\r\nreturn 0;\r\n}\r\nsa += len;\r\noffset -= len;\r\n}\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\nstatic int\r\nsg_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nSg_fd *sfp;\r\nunsigned long req_sz, len, sa;\r\nSg_scatter_hold *rsv_schp;\r\nint k, length;\r\nif ((!filp) || (!vma) || (!(sfp = (Sg_fd *) filp->private_data)))\r\nreturn -ENXIO;\r\nreq_sz = vma->vm_end - vma->vm_start;\r\nSCSI_LOG_TIMEOUT(3, printk("sg_mmap starting, vm_start=%p, len=%d\n",\r\n(void *) vma->vm_start, (int) req_sz));\r\nif (vma->vm_pgoff)\r\nreturn -EINVAL;\r\nrsv_schp = &sfp->reserve;\r\nif (req_sz > rsv_schp->bufflen)\r\nreturn -ENOMEM;\r\nsa = vma->vm_start;\r\nlength = 1 << (PAGE_SHIFT + rsv_schp->page_order);\r\nfor (k = 0; k < rsv_schp->k_use_sg && sa < vma->vm_end; k++) {\r\nlen = vma->vm_end - sa;\r\nlen = (len < length) ? len : length;\r\nsa += len;\r\n}\r\nsfp->mmap_called = 1;\r\nvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\r\nvma->vm_private_data = sfp;\r\nvma->vm_ops = &sg_mmap_vm_ops;\r\nreturn 0;\r\n}\r\nstatic void sg_rq_end_io_usercontext(struct work_struct *work)\r\n{\r\nstruct sg_request *srp = container_of(work, struct sg_request, ew.work);\r\nstruct sg_fd *sfp = srp->parentfp;\r\nsg_finish_rem_req(srp);\r\nkref_put(&sfp->f_ref, sg_remove_sfp);\r\n}\r\nstatic void sg_rq_end_io(struct request *rq, int uptodate)\r\n{\r\nstruct sg_request *srp = rq->end_io_data;\r\nSg_device *sdp;\r\nSg_fd *sfp;\r\nunsigned long iflags;\r\nunsigned int ms;\r\nchar *sense;\r\nint result, resid, done = 1;\r\nif (WARN_ON(srp->done != 0))\r\nreturn;\r\nsfp = srp->parentfp;\r\nif (WARN_ON(sfp == NULL))\r\nreturn;\r\nsdp = sfp->parentdp;\r\nif (unlikely(sdp->detached))\r\nprintk(KERN_INFO "sg_rq_end_io: device detached\n");\r\nsense = rq->sense;\r\nresult = rq->errors;\r\nresid = rq->resid_len;\r\nSCSI_LOG_TIMEOUT(4, printk("sg_cmd_done: %s, pack_id=%d, res=0x%x\n",\r\nsdp->disk->disk_name, srp->header.pack_id, result));\r\nsrp->header.resid = resid;\r\nms = jiffies_to_msecs(jiffies);\r\nsrp->header.duration = (ms > srp->header.duration) ?\r\n(ms - srp->header.duration) : 0;\r\nif (0 != result) {\r\nstruct scsi_sense_hdr sshdr;\r\nsrp->header.status = 0xff & result;\r\nsrp->header.masked_status = status_byte(result);\r\nsrp->header.msg_status = msg_byte(result);\r\nsrp->header.host_status = host_byte(result);\r\nsrp->header.driver_status = driver_byte(result);\r\nif ((sdp->sgdebug > 0) &&\r\n((CHECK_CONDITION == srp->header.masked_status) ||\r\n(COMMAND_TERMINATED == srp->header.masked_status)))\r\n__scsi_print_sense("sg_cmd_done", sense,\r\nSCSI_SENSE_BUFFERSIZE);\r\nif (driver_byte(result) != 0\r\n&& scsi_normalize_sense(sense, SCSI_SENSE_BUFFERSIZE, &sshdr)\r\n&& !scsi_sense_is_deferred(&sshdr)\r\n&& sshdr.sense_key == UNIT_ATTENTION\r\n&& sdp->device->removable) {\r\nsdp->device->changed = 1;\r\n}\r\n}\r\nwrite_lock_irqsave(&sfp->rq_list_lock, iflags);\r\nif (unlikely(srp->orphan)) {\r\nif (sfp->keep_orphan)\r\nsrp->sg_io_owned = 0;\r\nelse\r\ndone = 0;\r\n}\r\nsrp->done = done;\r\nwrite_unlock_irqrestore(&sfp->rq_list_lock, iflags);\r\nif (likely(done)) {\r\nwake_up_interruptible(&sfp->read_wait);\r\nkill_fasync(&sfp->async_qp, SIGPOLL, POLL_IN);\r\nkref_put(&sfp->f_ref, sg_remove_sfp);\r\n} else {\r\nINIT_WORK(&srp->ew.work, sg_rq_end_io_usercontext);\r\nschedule_work(&srp->ew.work);\r\n}\r\n}\r\nstatic Sg_device *sg_alloc(struct gendisk *disk, struct scsi_device *scsidp)\r\n{\r\nstruct request_queue *q = scsidp->request_queue;\r\nSg_device *sdp;\r\nunsigned long iflags;\r\nint error;\r\nu32 k;\r\nsdp = kzalloc(sizeof(Sg_device), GFP_KERNEL);\r\nif (!sdp) {\r\nprintk(KERN_WARNING "kmalloc Sg_device failure\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nidr_preload(GFP_KERNEL);\r\nwrite_lock_irqsave(&sg_index_lock, iflags);\r\nerror = idr_alloc(&sg_index_idr, sdp, 0, SG_MAX_DEVS, GFP_NOWAIT);\r\nif (error < 0) {\r\nif (error == -ENOSPC) {\r\nsdev_printk(KERN_WARNING, scsidp,\r\n"Unable to attach sg device type=%d, minor number exceeds %d\n",\r\nscsidp->type, SG_MAX_DEVS - 1);\r\nerror = -ENODEV;\r\n} else {\r\nprintk(KERN_WARNING\r\n"idr allocation Sg_device failure: %d\n", error);\r\n}\r\ngoto out_unlock;\r\n}\r\nk = error;\r\nSCSI_LOG_TIMEOUT(3, printk("sg_alloc: dev=%d \n", k));\r\nsprintf(disk->disk_name, "sg%d", k);\r\ndisk->first_minor = k;\r\nsdp->disk = disk;\r\nsdp->device = scsidp;\r\nINIT_LIST_HEAD(&sdp->sfds);\r\ninit_waitqueue_head(&sdp->o_excl_wait);\r\nsdp->sg_tablesize = queue_max_segments(q);\r\nsdp->index = k;\r\nkref_init(&sdp->d_ref);\r\nerror = 0;\r\nout_unlock:\r\nwrite_unlock_irqrestore(&sg_index_lock, iflags);\r\nidr_preload_end();\r\nif (error) {\r\nkfree(sdp);\r\nreturn ERR_PTR(error);\r\n}\r\nreturn sdp;\r\n}\r\nstatic int\r\nsg_add(struct device *cl_dev, struct class_interface *cl_intf)\r\n{\r\nstruct scsi_device *scsidp = to_scsi_device(cl_dev->parent);\r\nstruct gendisk *disk;\r\nSg_device *sdp = NULL;\r\nstruct cdev * cdev = NULL;\r\nint error;\r\nunsigned long iflags;\r\ndisk = alloc_disk(1);\r\nif (!disk) {\r\nprintk(KERN_WARNING "alloc_disk failed\n");\r\nreturn -ENOMEM;\r\n}\r\ndisk->major = SCSI_GENERIC_MAJOR;\r\nerror = -ENOMEM;\r\ncdev = cdev_alloc();\r\nif (!cdev) {\r\nprintk(KERN_WARNING "cdev_alloc failed\n");\r\ngoto out;\r\n}\r\ncdev->owner = THIS_MODULE;\r\ncdev->ops = &sg_fops;\r\nsdp = sg_alloc(disk, scsidp);\r\nif (IS_ERR(sdp)) {\r\nprintk(KERN_WARNING "sg_alloc failed\n");\r\nerror = PTR_ERR(sdp);\r\ngoto out;\r\n}\r\nerror = cdev_add(cdev, MKDEV(SCSI_GENERIC_MAJOR, sdp->index), 1);\r\nif (error)\r\ngoto cdev_add_err;\r\nsdp->cdev = cdev;\r\nif (sg_sysfs_valid) {\r\nstruct device *sg_class_member;\r\nsg_class_member = device_create(sg_sysfs_class, cl_dev->parent,\r\nMKDEV(SCSI_GENERIC_MAJOR,\r\nsdp->index),\r\nsdp, "%s", disk->disk_name);\r\nif (IS_ERR(sg_class_member)) {\r\nprintk(KERN_ERR "sg_add: "\r\n"device_create failed\n");\r\nerror = PTR_ERR(sg_class_member);\r\ngoto cdev_add_err;\r\n}\r\nerror = sysfs_create_link(&scsidp->sdev_gendev.kobj,\r\n&sg_class_member->kobj, "generic");\r\nif (error)\r\nprintk(KERN_ERR "sg_add: unable to make symlink "\r\n"'generic' back to sg%d\n", sdp->index);\r\n} else\r\nprintk(KERN_WARNING "sg_add: sg_sys Invalid\n");\r\nsdev_printk(KERN_NOTICE, scsidp,\r\n"Attached scsi generic sg%d type %d\n", sdp->index,\r\nscsidp->type);\r\ndev_set_drvdata(cl_dev, sdp);\r\nreturn 0;\r\ncdev_add_err:\r\nwrite_lock_irqsave(&sg_index_lock, iflags);\r\nidr_remove(&sg_index_idr, sdp->index);\r\nwrite_unlock_irqrestore(&sg_index_lock, iflags);\r\nkfree(sdp);\r\nout:\r\nput_disk(disk);\r\nif (cdev)\r\ncdev_del(cdev);\r\nreturn error;\r\n}\r\nstatic void sg_device_destroy(struct kref *kref)\r\n{\r\nstruct sg_device *sdp = container_of(kref, struct sg_device, d_ref);\r\nunsigned long flags;\r\nwrite_lock_irqsave(&sg_index_lock, flags);\r\nidr_remove(&sg_index_idr, sdp->index);\r\nwrite_unlock_irqrestore(&sg_index_lock, flags);\r\nSCSI_LOG_TIMEOUT(3,\r\nprintk("sg_device_destroy: %s\n",\r\nsdp->disk->disk_name));\r\nput_disk(sdp->disk);\r\nkfree(sdp);\r\n}\r\nstatic void sg_remove(struct device *cl_dev, struct class_interface *cl_intf)\r\n{\r\nstruct scsi_device *scsidp = to_scsi_device(cl_dev->parent);\r\nSg_device *sdp = dev_get_drvdata(cl_dev);\r\nunsigned long iflags;\r\nSg_fd *sfp;\r\nif (!sdp || sdp->detached)\r\nreturn;\r\nSCSI_LOG_TIMEOUT(3, printk("sg_remove: %s\n", sdp->disk->disk_name));\r\nwrite_lock_irqsave(&sg_index_lock, iflags);\r\nsdp->detached = 1;\r\nlist_for_each_entry(sfp, &sdp->sfds, sfd_siblings) {\r\nwake_up_interruptible(&sfp->read_wait);\r\nkill_fasync(&sfp->async_qp, SIGPOLL, POLL_HUP);\r\n}\r\nwrite_unlock_irqrestore(&sg_index_lock, iflags);\r\nsysfs_remove_link(&scsidp->sdev_gendev.kobj, "generic");\r\ndevice_destroy(sg_sysfs_class, MKDEV(SCSI_GENERIC_MAJOR, sdp->index));\r\ncdev_del(sdp->cdev);\r\nsdp->cdev = NULL;\r\nsg_put_dev(sdp);\r\n}\r\nstatic int __init\r\ninit_sg(void)\r\n{\r\nint rc;\r\nif (scatter_elem_sz < PAGE_SIZE) {\r\nscatter_elem_sz = PAGE_SIZE;\r\nscatter_elem_sz_prev = scatter_elem_sz;\r\n}\r\nif (def_reserved_size >= 0)\r\nsg_big_buff = def_reserved_size;\r\nelse\r\ndef_reserved_size = sg_big_buff;\r\nrc = register_chrdev_region(MKDEV(SCSI_GENERIC_MAJOR, 0),\r\nSG_MAX_DEVS, "sg");\r\nif (rc)\r\nreturn rc;\r\nsg_sysfs_class = class_create(THIS_MODULE, "scsi_generic");\r\nif ( IS_ERR(sg_sysfs_class) ) {\r\nrc = PTR_ERR(sg_sysfs_class);\r\ngoto err_out;\r\n}\r\nsg_sysfs_valid = 1;\r\nrc = scsi_register_interface(&sg_interface);\r\nif (0 == rc) {\r\n#ifdef CONFIG_SCSI_PROC_FS\r\nsg_proc_init();\r\n#endif\r\nreturn 0;\r\n}\r\nclass_destroy(sg_sysfs_class);\r\nerr_out:\r\nunregister_chrdev_region(MKDEV(SCSI_GENERIC_MAJOR, 0), SG_MAX_DEVS);\r\nreturn rc;\r\n}\r\nstatic void __exit\r\nexit_sg(void)\r\n{\r\n#ifdef CONFIG_SCSI_PROC_FS\r\nsg_proc_cleanup();\r\n#endif\r\nscsi_unregister_interface(&sg_interface);\r\nclass_destroy(sg_sysfs_class);\r\nsg_sysfs_valid = 0;\r\nunregister_chrdev_region(MKDEV(SCSI_GENERIC_MAJOR, 0),\r\nSG_MAX_DEVS);\r\nidr_destroy(&sg_index_idr);\r\n}\r\nstatic int sg_start_req(Sg_request *srp, unsigned char *cmd)\r\n{\r\nint res;\r\nstruct request *rq;\r\nSg_fd *sfp = srp->parentfp;\r\nsg_io_hdr_t *hp = &srp->header;\r\nint dxfer_len = (int) hp->dxfer_len;\r\nint dxfer_dir = hp->dxfer_direction;\r\nunsigned int iov_count = hp->iovec_count;\r\nSg_scatter_hold *req_schp = &srp->data;\r\nSg_scatter_hold *rsv_schp = &sfp->reserve;\r\nstruct request_queue *q = sfp->parentdp->device->request_queue;\r\nstruct rq_map_data *md, map_data;\r\nint rw = hp->dxfer_direction == SG_DXFER_TO_DEV ? WRITE : READ;\r\nSCSI_LOG_TIMEOUT(4, printk(KERN_INFO "sg_start_req: dxfer_len=%d\n",\r\ndxfer_len));\r\nrq = blk_get_request(q, rw, GFP_ATOMIC);\r\nif (!rq)\r\nreturn -ENOMEM;\r\nmemcpy(rq->cmd, cmd, hp->cmd_len);\r\nrq->cmd_len = hp->cmd_len;\r\nrq->cmd_type = REQ_TYPE_BLOCK_PC;\r\nsrp->rq = rq;\r\nrq->end_io_data = srp;\r\nrq->sense = srp->sense_b;\r\nrq->retries = SG_DEFAULT_RETRIES;\r\nif ((dxfer_len <= 0) || (dxfer_dir == SG_DXFER_NONE))\r\nreturn 0;\r\nif (sg_allow_dio && hp->flags & SG_FLAG_DIRECT_IO &&\r\ndxfer_dir != SG_DXFER_UNKNOWN && !iov_count &&\r\n!sfp->parentdp->device->host->unchecked_isa_dma &&\r\nblk_rq_aligned(q, (unsigned long)hp->dxferp, dxfer_len))\r\nmd = NULL;\r\nelse\r\nmd = &map_data;\r\nif (md) {\r\nif (!sg_res_in_use(sfp) && dxfer_len <= rsv_schp->bufflen)\r\nsg_link_reserve(sfp, srp, dxfer_len);\r\nelse {\r\nres = sg_build_indirect(req_schp, sfp, dxfer_len);\r\nif (res)\r\nreturn res;\r\n}\r\nmd->pages = req_schp->pages;\r\nmd->page_order = req_schp->page_order;\r\nmd->nr_entries = req_schp->k_use_sg;\r\nmd->offset = 0;\r\nmd->null_mapped = hp->dxferp ? 0 : 1;\r\nif (dxfer_dir == SG_DXFER_TO_FROM_DEV)\r\nmd->from_user = 1;\r\nelse\r\nmd->from_user = 0;\r\n}\r\nif (iov_count) {\r\nint len, size = sizeof(struct sg_iovec) * iov_count;\r\nstruct iovec *iov;\r\niov = memdup_user(hp->dxferp, size);\r\nif (IS_ERR(iov))\r\nreturn PTR_ERR(iov);\r\nlen = iov_length(iov, iov_count);\r\nif (hp->dxfer_len < len) {\r\niov_count = iov_shorten(iov, iov_count, hp->dxfer_len);\r\nlen = hp->dxfer_len;\r\n}\r\nres = blk_rq_map_user_iov(q, rq, md, (struct sg_iovec *)iov,\r\niov_count,\r\nlen, GFP_ATOMIC);\r\nkfree(iov);\r\n} else\r\nres = blk_rq_map_user(q, rq, md, hp->dxferp,\r\nhp->dxfer_len, GFP_ATOMIC);\r\nif (!res) {\r\nsrp->bio = rq->bio;\r\nif (!md) {\r\nreq_schp->dio_in_use = 1;\r\nhp->info |= SG_INFO_DIRECT_IO;\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic int sg_finish_rem_req(Sg_request * srp)\r\n{\r\nint ret = 0;\r\nSg_fd *sfp = srp->parentfp;\r\nSg_scatter_hold *req_schp = &srp->data;\r\nSCSI_LOG_TIMEOUT(4, printk("sg_finish_rem_req: res_used=%d\n", (int) srp->res_used));\r\nif (srp->rq) {\r\nif (srp->bio)\r\nret = blk_rq_unmap_user(srp->bio);\r\nblk_put_request(srp->rq);\r\n}\r\nif (srp->res_used)\r\nsg_unlink_reserve(sfp, srp);\r\nelse\r\nsg_remove_scat(req_schp);\r\nsg_remove_request(sfp, srp);\r\nreturn ret;\r\n}\r\nstatic int\r\nsg_build_sgat(Sg_scatter_hold * schp, const Sg_fd * sfp, int tablesize)\r\n{\r\nint sg_bufflen = tablesize * sizeof(struct page *);\r\ngfp_t gfp_flags = GFP_ATOMIC | __GFP_NOWARN;\r\nschp->pages = kzalloc(sg_bufflen, gfp_flags);\r\nif (!schp->pages)\r\nreturn -ENOMEM;\r\nschp->sglist_len = sg_bufflen;\r\nreturn tablesize;\r\n}\r\nstatic int\r\nsg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size)\r\n{\r\nint ret_sz = 0, i, k, rem_sz, num, mx_sc_elems;\r\nint sg_tablesize = sfp->parentdp->sg_tablesize;\r\nint blk_size = buff_size, order;\r\ngfp_t gfp_mask = GFP_ATOMIC | __GFP_COMP | __GFP_NOWARN;\r\nif (blk_size < 0)\r\nreturn -EFAULT;\r\nif (0 == blk_size)\r\n++blk_size;\r\nblk_size = ALIGN(blk_size, SG_SECTOR_SZ);\r\nSCSI_LOG_TIMEOUT(4, printk("sg_build_indirect: buff_size=%d, blk_size=%d\n",\r\nbuff_size, blk_size));\r\nmx_sc_elems = sg_build_sgat(schp, sfp, sg_tablesize);\r\nif (mx_sc_elems < 0)\r\nreturn mx_sc_elems;\r\nnum = scatter_elem_sz;\r\nif (unlikely(num != scatter_elem_sz_prev)) {\r\nif (num < PAGE_SIZE) {\r\nscatter_elem_sz = PAGE_SIZE;\r\nscatter_elem_sz_prev = PAGE_SIZE;\r\n} else\r\nscatter_elem_sz_prev = num;\r\n}\r\nif (sfp->low_dma)\r\ngfp_mask |= GFP_DMA;\r\nif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\r\ngfp_mask |= __GFP_ZERO;\r\norder = get_order(num);\r\nretry:\r\nret_sz = 1 << (PAGE_SHIFT + order);\r\nfor (k = 0, rem_sz = blk_size; rem_sz > 0 && k < mx_sc_elems;\r\nk++, rem_sz -= ret_sz) {\r\nnum = (rem_sz > scatter_elem_sz_prev) ?\r\nscatter_elem_sz_prev : rem_sz;\r\nschp->pages[k] = alloc_pages(gfp_mask, order);\r\nif (!schp->pages[k])\r\ngoto out;\r\nif (num == scatter_elem_sz_prev) {\r\nif (unlikely(ret_sz > scatter_elem_sz_prev)) {\r\nscatter_elem_sz = ret_sz;\r\nscatter_elem_sz_prev = ret_sz;\r\n}\r\n}\r\nSCSI_LOG_TIMEOUT(5, printk("sg_build_indirect: k=%d, num=%d, "\r\n"ret_sz=%d\n", k, num, ret_sz));\r\n}\r\nschp->page_order = order;\r\nschp->k_use_sg = k;\r\nSCSI_LOG_TIMEOUT(5, printk("sg_build_indirect: k_use_sg=%d, "\r\n"rem_sz=%d\n", k, rem_sz));\r\nschp->bufflen = blk_size;\r\nif (rem_sz > 0)\r\nreturn -ENOMEM;\r\nreturn 0;\r\nout:\r\nfor (i = 0; i < k; i++)\r\n__free_pages(schp->pages[i], order);\r\nif (--order >= 0)\r\ngoto retry;\r\nreturn -ENOMEM;\r\n}\r\nstatic void\r\nsg_remove_scat(Sg_scatter_hold * schp)\r\n{\r\nSCSI_LOG_TIMEOUT(4, printk("sg_remove_scat: k_use_sg=%d\n", schp->k_use_sg));\r\nif (schp->pages && schp->sglist_len > 0) {\r\nif (!schp->dio_in_use) {\r\nint k;\r\nfor (k = 0; k < schp->k_use_sg && schp->pages[k]; k++) {\r\nSCSI_LOG_TIMEOUT(5, printk(\r\n"sg_remove_scat: k=%d, pg=0x%p\n",\r\nk, schp->pages[k]));\r\n__free_pages(schp->pages[k], schp->page_order);\r\n}\r\nkfree(schp->pages);\r\n}\r\n}\r\nmemset(schp, 0, sizeof (*schp));\r\n}\r\nstatic int\r\nsg_read_oxfer(Sg_request * srp, char __user *outp, int num_read_xfer)\r\n{\r\nSg_scatter_hold *schp = &srp->data;\r\nint k, num;\r\nSCSI_LOG_TIMEOUT(4, printk("sg_read_oxfer: num_read_xfer=%d\n",\r\nnum_read_xfer));\r\nif ((!outp) || (num_read_xfer <= 0))\r\nreturn 0;\r\nnum = 1 << (PAGE_SHIFT + schp->page_order);\r\nfor (k = 0; k < schp->k_use_sg && schp->pages[k]; k++) {\r\nif (num > num_read_xfer) {\r\nif (__copy_to_user(outp, page_address(schp->pages[k]),\r\nnum_read_xfer))\r\nreturn -EFAULT;\r\nbreak;\r\n} else {\r\nif (__copy_to_user(outp, page_address(schp->pages[k]),\r\nnum))\r\nreturn -EFAULT;\r\nnum_read_xfer -= num;\r\nif (num_read_xfer <= 0)\r\nbreak;\r\noutp += num;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nsg_build_reserve(Sg_fd * sfp, int req_size)\r\n{\r\nSg_scatter_hold *schp = &sfp->reserve;\r\nSCSI_LOG_TIMEOUT(4, printk("sg_build_reserve: req_size=%d\n", req_size));\r\ndo {\r\nif (req_size < PAGE_SIZE)\r\nreq_size = PAGE_SIZE;\r\nif (0 == sg_build_indirect(schp, sfp, req_size))\r\nreturn;\r\nelse\r\nsg_remove_scat(schp);\r\nreq_size >>= 1;\r\n} while (req_size > (PAGE_SIZE / 2));\r\n}\r\nstatic void\r\nsg_link_reserve(Sg_fd * sfp, Sg_request * srp, int size)\r\n{\r\nSg_scatter_hold *req_schp = &srp->data;\r\nSg_scatter_hold *rsv_schp = &sfp->reserve;\r\nint k, num, rem;\r\nsrp->res_used = 1;\r\nSCSI_LOG_TIMEOUT(4, printk("sg_link_reserve: size=%d\n", size));\r\nrem = size;\r\nnum = 1 << (PAGE_SHIFT + rsv_schp->page_order);\r\nfor (k = 0; k < rsv_schp->k_use_sg; k++) {\r\nif (rem <= num) {\r\nreq_schp->k_use_sg = k + 1;\r\nreq_schp->sglist_len = rsv_schp->sglist_len;\r\nreq_schp->pages = rsv_schp->pages;\r\nreq_schp->bufflen = size;\r\nreq_schp->page_order = rsv_schp->page_order;\r\nbreak;\r\n} else\r\nrem -= num;\r\n}\r\nif (k >= rsv_schp->k_use_sg)\r\nSCSI_LOG_TIMEOUT(1, printk("sg_link_reserve: BAD size\n"));\r\n}\r\nstatic void\r\nsg_unlink_reserve(Sg_fd * sfp, Sg_request * srp)\r\n{\r\nSg_scatter_hold *req_schp = &srp->data;\r\nSCSI_LOG_TIMEOUT(4, printk("sg_unlink_reserve: req->k_use_sg=%d\n",\r\n(int) req_schp->k_use_sg));\r\nreq_schp->k_use_sg = 0;\r\nreq_schp->bufflen = 0;\r\nreq_schp->pages = NULL;\r\nreq_schp->page_order = 0;\r\nreq_schp->sglist_len = 0;\r\nsfp->save_scat_len = 0;\r\nsrp->res_used = 0;\r\n}\r\nstatic Sg_request *\r\nsg_get_rq_mark(Sg_fd * sfp, int pack_id)\r\n{\r\nSg_request *resp;\r\nunsigned long iflags;\r\nwrite_lock_irqsave(&sfp->rq_list_lock, iflags);\r\nfor (resp = sfp->headrp; resp; resp = resp->nextrp) {\r\nif ((1 == resp->done) && (!resp->sg_io_owned) &&\r\n((-1 == pack_id) || (resp->header.pack_id == pack_id))) {\r\nresp->done = 2;\r\nbreak;\r\n}\r\n}\r\nwrite_unlock_irqrestore(&sfp->rq_list_lock, iflags);\r\nreturn resp;\r\n}\r\nstatic Sg_request *\r\nsg_add_request(Sg_fd * sfp)\r\n{\r\nint k;\r\nunsigned long iflags;\r\nSg_request *resp;\r\nSg_request *rp = sfp->req_arr;\r\nwrite_lock_irqsave(&sfp->rq_list_lock, iflags);\r\nresp = sfp->headrp;\r\nif (!resp) {\r\nmemset(rp, 0, sizeof (Sg_request));\r\nrp->parentfp = sfp;\r\nresp = rp;\r\nsfp->headrp = resp;\r\n} else {\r\nif (0 == sfp->cmd_q)\r\nresp = NULL;\r\nelse {\r\nfor (k = 0; k < SG_MAX_QUEUE; ++k, ++rp) {\r\nif (!rp->parentfp)\r\nbreak;\r\n}\r\nif (k < SG_MAX_QUEUE) {\r\nmemset(rp, 0, sizeof (Sg_request));\r\nrp->parentfp = sfp;\r\nwhile (resp->nextrp)\r\nresp = resp->nextrp;\r\nresp->nextrp = rp;\r\nresp = rp;\r\n} else\r\nresp = NULL;\r\n}\r\n}\r\nif (resp) {\r\nresp->nextrp = NULL;\r\nresp->header.duration = jiffies_to_msecs(jiffies);\r\n}\r\nwrite_unlock_irqrestore(&sfp->rq_list_lock, iflags);\r\nreturn resp;\r\n}\r\nstatic int\r\nsg_remove_request(Sg_fd * sfp, Sg_request * srp)\r\n{\r\nSg_request *prev_rp;\r\nSg_request *rp;\r\nunsigned long iflags;\r\nint res = 0;\r\nif ((!sfp) || (!srp) || (!sfp->headrp))\r\nreturn res;\r\nwrite_lock_irqsave(&sfp->rq_list_lock, iflags);\r\nprev_rp = sfp->headrp;\r\nif (srp == prev_rp) {\r\nsfp->headrp = prev_rp->nextrp;\r\nprev_rp->parentfp = NULL;\r\nres = 1;\r\n} else {\r\nwhile ((rp = prev_rp->nextrp)) {\r\nif (srp == rp) {\r\nprev_rp->nextrp = rp->nextrp;\r\nrp->parentfp = NULL;\r\nres = 1;\r\nbreak;\r\n}\r\nprev_rp = rp;\r\n}\r\n}\r\nwrite_unlock_irqrestore(&sfp->rq_list_lock, iflags);\r\nreturn res;\r\n}\r\nstatic Sg_fd *\r\nsg_add_sfp(Sg_device * sdp, int dev)\r\n{\r\nSg_fd *sfp;\r\nunsigned long iflags;\r\nint bufflen;\r\nsfp = kzalloc(sizeof(*sfp), GFP_ATOMIC | __GFP_NOWARN);\r\nif (!sfp)\r\nreturn NULL;\r\ninit_waitqueue_head(&sfp->read_wait);\r\nrwlock_init(&sfp->rq_list_lock);\r\nkref_init(&sfp->f_ref);\r\nsfp->timeout = SG_DEFAULT_TIMEOUT;\r\nsfp->timeout_user = SG_DEFAULT_TIMEOUT_USER;\r\nsfp->force_packid = SG_DEF_FORCE_PACK_ID;\r\nsfp->low_dma = (SG_DEF_FORCE_LOW_DMA == 0) ?\r\nsdp->device->host->unchecked_isa_dma : 1;\r\nsfp->cmd_q = SG_DEF_COMMAND_Q;\r\nsfp->keep_orphan = SG_DEF_KEEP_ORPHAN;\r\nsfp->parentdp = sdp;\r\nwrite_lock_irqsave(&sg_index_lock, iflags);\r\nlist_add_tail(&sfp->sfd_siblings, &sdp->sfds);\r\nwrite_unlock_irqrestore(&sg_index_lock, iflags);\r\nSCSI_LOG_TIMEOUT(3, printk("sg_add_sfp: sfp=0x%p\n", sfp));\r\nif (unlikely(sg_big_buff != def_reserved_size))\r\nsg_big_buff = def_reserved_size;\r\nbufflen = min_t(int, sg_big_buff,\r\nqueue_max_sectors(sdp->device->request_queue) * 512);\r\nsg_build_reserve(sfp, bufflen);\r\nSCSI_LOG_TIMEOUT(3, printk("sg_add_sfp: bufflen=%d, k_use_sg=%d\n",\r\nsfp->reserve.bufflen, sfp->reserve.k_use_sg));\r\nkref_get(&sdp->d_ref);\r\n__module_get(THIS_MODULE);\r\nreturn sfp;\r\n}\r\nstatic void sg_remove_sfp_usercontext(struct work_struct *work)\r\n{\r\nstruct sg_fd *sfp = container_of(work, struct sg_fd, ew.work);\r\nstruct sg_device *sdp = sfp->parentdp;\r\nwhile (sfp->headrp)\r\nsg_finish_rem_req(sfp->headrp);\r\nif (sfp->reserve.bufflen > 0) {\r\nSCSI_LOG_TIMEOUT(6,\r\nprintk("sg_remove_sfp: bufflen=%d, k_use_sg=%d\n",\r\n(int) sfp->reserve.bufflen,\r\n(int) sfp->reserve.k_use_sg));\r\nsg_remove_scat(&sfp->reserve);\r\n}\r\nSCSI_LOG_TIMEOUT(6,\r\nprintk("sg_remove_sfp: %s, sfp=0x%p\n",\r\nsdp->disk->disk_name,\r\nsfp));\r\nkfree(sfp);\r\nscsi_device_put(sdp->device);\r\nsg_put_dev(sdp);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic void sg_remove_sfp(struct kref *kref)\r\n{\r\nstruct sg_fd *sfp = container_of(kref, struct sg_fd, f_ref);\r\nstruct sg_device *sdp = sfp->parentdp;\r\nunsigned long iflags;\r\nwrite_lock_irqsave(&sg_index_lock, iflags);\r\nlist_del(&sfp->sfd_siblings);\r\nwrite_unlock_irqrestore(&sg_index_lock, iflags);\r\nwake_up_interruptible(&sdp->o_excl_wait);\r\nINIT_WORK(&sfp->ew.work, sg_remove_sfp_usercontext);\r\nschedule_work(&sfp->ew.work);\r\n}\r\nstatic int\r\nsg_res_in_use(Sg_fd * sfp)\r\n{\r\nconst Sg_request *srp;\r\nunsigned long iflags;\r\nread_lock_irqsave(&sfp->rq_list_lock, iflags);\r\nfor (srp = sfp->headrp; srp; srp = srp->nextrp)\r\nif (srp->res_used)\r\nbreak;\r\nread_unlock_irqrestore(&sfp->rq_list_lock, iflags);\r\nreturn srp ? 1 : 0;\r\n}\r\nstatic int\r\nsg_idr_max_id(int id, void *p, void *data)\r\n{\r\nint *k = data;\r\nif (*k < id)\r\n*k = id;\r\nreturn 0;\r\n}\r\nstatic int\r\nsg_last_dev(void)\r\n{\r\nint k = -1;\r\nunsigned long iflags;\r\nread_lock_irqsave(&sg_index_lock, iflags);\r\nidr_for_each(&sg_index_idr, sg_idr_max_id, &k);\r\nread_unlock_irqrestore(&sg_index_lock, iflags);\r\nreturn k + 1;\r\n}\r\nstatic Sg_device *sg_lookup_dev(int dev)\r\n{\r\nreturn idr_find(&sg_index_idr, dev);\r\n}\r\nstatic Sg_device *sg_get_dev(int dev)\r\n{\r\nstruct sg_device *sdp;\r\nunsigned long flags;\r\nread_lock_irqsave(&sg_index_lock, flags);\r\nsdp = sg_lookup_dev(dev);\r\nif (!sdp)\r\nsdp = ERR_PTR(-ENXIO);\r\nelse if (sdp->detached) {\r\nsdp = ERR_PTR(-ENODEV);\r\n} else\r\nkref_get(&sdp->d_ref);\r\nread_unlock_irqrestore(&sg_index_lock, flags);\r\nreturn sdp;\r\n}\r\nstatic void sg_put_dev(struct sg_device *sdp)\r\n{\r\nkref_put(&sdp->d_ref, sg_device_destroy);\r\n}\r\nstatic int\r\nsg_proc_init(void)\r\n{\r\nint num_leaves = ARRAY_SIZE(sg_proc_leaf_arr);\r\nint k;\r\nsg_proc_sgp = proc_mkdir(sg_proc_sg_dirname, NULL);\r\nif (!sg_proc_sgp)\r\nreturn 1;\r\nfor (k = 0; k < num_leaves; ++k) {\r\nconst struct sg_proc_leaf *leaf = &sg_proc_leaf_arr[k];\r\numode_t mask = leaf->fops->write ? S_IRUGO | S_IWUSR : S_IRUGO;\r\nproc_create(leaf->name, mask, sg_proc_sgp, leaf->fops);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nsg_proc_cleanup(void)\r\n{\r\nint k;\r\nint num_leaves = ARRAY_SIZE(sg_proc_leaf_arr);\r\nif (!sg_proc_sgp)\r\nreturn;\r\nfor (k = 0; k < num_leaves; ++k)\r\nremove_proc_entry(sg_proc_leaf_arr[k].name, sg_proc_sgp);\r\nremove_proc_entry(sg_proc_sg_dirname, NULL);\r\n}\r\nstatic int sg_proc_seq_show_int(struct seq_file *s, void *v)\r\n{\r\nseq_printf(s, "%d\n", *((int *)s->private));\r\nreturn 0;\r\n}\r\nstatic int sg_proc_single_open_adio(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, sg_proc_seq_show_int, &sg_allow_dio);\r\n}\r\nstatic ssize_t\r\nsg_proc_write_adio(struct file *filp, const char __user *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nint err;\r\nunsigned long num;\r\nif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\nerr = kstrtoul_from_user(buffer, count, 0, &num);\r\nif (err)\r\nreturn err;\r\nsg_allow_dio = num ? 1 : 0;\r\nreturn count;\r\n}\r\nstatic int sg_proc_single_open_dressz(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, sg_proc_seq_show_int, &sg_big_buff);\r\n}\r\nstatic ssize_t\r\nsg_proc_write_dressz(struct file *filp, const char __user *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nint err;\r\nunsigned long k = ULONG_MAX;\r\nif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\r\nreturn -EACCES;\r\nerr = kstrtoul_from_user(buffer, count, 0, &k);\r\nif (err)\r\nreturn err;\r\nif (k <= 1048576) {\r\nsg_big_buff = k;\r\nreturn count;\r\n}\r\nreturn -ERANGE;\r\n}\r\nstatic int sg_proc_seq_show_version(struct seq_file *s, void *v)\r\n{\r\nseq_printf(s, "%d\t%s [%s]\n", sg_version_num, SG_VERSION_STR,\r\nsg_version_date);\r\nreturn 0;\r\n}\r\nstatic int sg_proc_single_open_version(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, sg_proc_seq_show_version, NULL);\r\n}\r\nstatic int sg_proc_seq_show_devhdr(struct seq_file *s, void *v)\r\n{\r\nseq_printf(s, "host\tchan\tid\tlun\ttype\topens\tqdepth\tbusy\t"\r\n"online\n");\r\nreturn 0;\r\n}\r\nstatic int sg_proc_single_open_devhdr(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, sg_proc_seq_show_devhdr, NULL);\r\n}\r\nstatic void * dev_seq_start(struct seq_file *s, loff_t *pos)\r\n{\r\nstruct sg_proc_deviter * it = kmalloc(sizeof(*it), GFP_KERNEL);\r\ns->private = it;\r\nif (! it)\r\nreturn NULL;\r\nit->index = *pos;\r\nit->max = sg_last_dev();\r\nif (it->index >= it->max)\r\nreturn NULL;\r\nreturn it;\r\n}\r\nstatic void * dev_seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nstruct sg_proc_deviter * it = s->private;\r\n*pos = ++it->index;\r\nreturn (it->index < it->max) ? it : NULL;\r\n}\r\nstatic void dev_seq_stop(struct seq_file *s, void *v)\r\n{\r\nkfree(s->private);\r\n}\r\nstatic int sg_proc_open_dev(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &dev_seq_ops);\r\n}\r\nstatic int sg_proc_seq_show_dev(struct seq_file *s, void *v)\r\n{\r\nstruct sg_proc_deviter * it = (struct sg_proc_deviter *) v;\r\nSg_device *sdp;\r\nstruct scsi_device *scsidp;\r\nunsigned long iflags;\r\nread_lock_irqsave(&sg_index_lock, iflags);\r\nsdp = it ? sg_lookup_dev(it->index) : NULL;\r\nif (sdp && (scsidp = sdp->device) && (!sdp->detached))\r\nseq_printf(s, "%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n",\r\nscsidp->host->host_no, scsidp->channel,\r\nscsidp->id, scsidp->lun, (int) scsidp->type,\r\n1,\r\n(int) scsidp->queue_depth,\r\n(int) scsidp->device_busy,\r\n(int) scsi_device_online(scsidp));\r\nelse\r\nseq_printf(s, "-1\t-1\t-1\t-1\t-1\t-1\t-1\t-1\t-1\n");\r\nread_unlock_irqrestore(&sg_index_lock, iflags);\r\nreturn 0;\r\n}\r\nstatic int sg_proc_open_devstrs(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &devstrs_seq_ops);\r\n}\r\nstatic int sg_proc_seq_show_devstrs(struct seq_file *s, void *v)\r\n{\r\nstruct sg_proc_deviter * it = (struct sg_proc_deviter *) v;\r\nSg_device *sdp;\r\nstruct scsi_device *scsidp;\r\nunsigned long iflags;\r\nread_lock_irqsave(&sg_index_lock, iflags);\r\nsdp = it ? sg_lookup_dev(it->index) : NULL;\r\nif (sdp && (scsidp = sdp->device) && (!sdp->detached))\r\nseq_printf(s, "%8.8s\t%16.16s\t%4.4s\n",\r\nscsidp->vendor, scsidp->model, scsidp->rev);\r\nelse\r\nseq_printf(s, "<no active device>\n");\r\nread_unlock_irqrestore(&sg_index_lock, iflags);\r\nreturn 0;\r\n}\r\nstatic void sg_proc_debug_helper(struct seq_file *s, Sg_device * sdp)\r\n{\r\nint k, m, new_interface, blen, usg;\r\nSg_request *srp;\r\nSg_fd *fp;\r\nconst sg_io_hdr_t *hp;\r\nconst char * cp;\r\nunsigned int ms;\r\nk = 0;\r\nlist_for_each_entry(fp, &sdp->sfds, sfd_siblings) {\r\nk++;\r\nread_lock(&fp->rq_list_lock);\r\nseq_printf(s, " FD(%d): timeout=%dms bufflen=%d "\r\n"(res)sgat=%d low_dma=%d\n", k,\r\njiffies_to_msecs(fp->timeout),\r\nfp->reserve.bufflen,\r\n(int) fp->reserve.k_use_sg,\r\n(int) fp->low_dma);\r\nseq_printf(s, " cmd_q=%d f_packid=%d k_orphan=%d closed=0\n",\r\n(int) fp->cmd_q, (int) fp->force_packid,\r\n(int) fp->keep_orphan);\r\nfor (m = 0, srp = fp->headrp;\r\nsrp != NULL;\r\n++m, srp = srp->nextrp) {\r\nhp = &srp->header;\r\nnew_interface = (hp->interface_id == '\0') ? 0 : 1;\r\nif (srp->res_used) {\r\nif (new_interface &&\r\n(SG_FLAG_MMAP_IO & hp->flags))\r\ncp = " mmap>> ";\r\nelse\r\ncp = " rb>> ";\r\n} else {\r\nif (SG_INFO_DIRECT_IO_MASK & hp->info)\r\ncp = " dio>> ";\r\nelse\r\ncp = " ";\r\n}\r\nseq_printf(s, cp);\r\nblen = srp->data.bufflen;\r\nusg = srp->data.k_use_sg;\r\nseq_printf(s, srp->done ?\r\n((1 == srp->done) ? "rcv:" : "fin:")\r\n: "act:");\r\nseq_printf(s, " id=%d blen=%d",\r\nsrp->header.pack_id, blen);\r\nif (srp->done)\r\nseq_printf(s, " dur=%d", hp->duration);\r\nelse {\r\nms = jiffies_to_msecs(jiffies);\r\nseq_printf(s, " t_o/elap=%d/%d",\r\n(new_interface ? hp->timeout :\r\njiffies_to_msecs(fp->timeout)),\r\n(ms > hp->duration ? ms - hp->duration : 0));\r\n}\r\nseq_printf(s, "ms sgat=%d op=0x%02x\n", usg,\r\n(int) srp->data.cmd_opcode);\r\n}\r\nif (0 == m)\r\nseq_printf(s, " No requests active\n");\r\nread_unlock(&fp->rq_list_lock);\r\n}\r\n}\r\nstatic int sg_proc_open_debug(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &debug_seq_ops);\r\n}\r\nstatic int sg_proc_seq_show_debug(struct seq_file *s, void *v)\r\n{\r\nstruct sg_proc_deviter * it = (struct sg_proc_deviter *) v;\r\nSg_device *sdp;\r\nunsigned long iflags;\r\nif (it && (0 == it->index)) {\r\nseq_printf(s, "max_active_device=%d(origin 1)\n",\r\n(int)it->max);\r\nseq_printf(s, " def_reserved_size=%d\n", sg_big_buff);\r\n}\r\nread_lock_irqsave(&sg_index_lock, iflags);\r\nsdp = it ? sg_lookup_dev(it->index) : NULL;\r\nif (sdp && !list_empty(&sdp->sfds)) {\r\nstruct scsi_device *scsidp = sdp->device;\r\nseq_printf(s, " >>> device=%s ", sdp->disk->disk_name);\r\nif (sdp->detached)\r\nseq_printf(s, "detached pending close ");\r\nelse\r\nseq_printf\r\n(s, "scsi%d chan=%d id=%d lun=%d em=%d",\r\nscsidp->host->host_no,\r\nscsidp->channel, scsidp->id,\r\nscsidp->lun,\r\nscsidp->host->hostt->emulated);\r\nseq_printf(s, " sg_tablesize=%d excl=%d\n",\r\nsdp->sg_tablesize, get_exclude(sdp));\r\nsg_proc_debug_helper(s, sdp);\r\n}\r\nread_unlock_irqrestore(&sg_index_lock, iflags);\r\nreturn 0;\r\n}
