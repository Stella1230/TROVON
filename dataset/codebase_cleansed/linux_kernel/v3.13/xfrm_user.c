static inline int aead_len(struct xfrm_algo_aead *alg)\r\n{\r\nreturn sizeof(*alg) + ((alg->alg_key_len + 7) / 8);\r\n}\r\nstatic int verify_one_alg(struct nlattr **attrs, enum xfrm_attr_type_t type)\r\n{\r\nstruct nlattr *rt = attrs[type];\r\nstruct xfrm_algo *algp;\r\nif (!rt)\r\nreturn 0;\r\nalgp = nla_data(rt);\r\nif (nla_len(rt) < xfrm_alg_len(algp))\r\nreturn -EINVAL;\r\nswitch (type) {\r\ncase XFRMA_ALG_AUTH:\r\ncase XFRMA_ALG_CRYPT:\r\ncase XFRMA_ALG_COMP:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nalgp->alg_name[CRYPTO_MAX_ALG_NAME - 1] = '\0';\r\nreturn 0;\r\n}\r\nstatic int verify_auth_trunc(struct nlattr **attrs)\r\n{\r\nstruct nlattr *rt = attrs[XFRMA_ALG_AUTH_TRUNC];\r\nstruct xfrm_algo_auth *algp;\r\nif (!rt)\r\nreturn 0;\r\nalgp = nla_data(rt);\r\nif (nla_len(rt) < xfrm_alg_auth_len(algp))\r\nreturn -EINVAL;\r\nalgp->alg_name[CRYPTO_MAX_ALG_NAME - 1] = '\0';\r\nreturn 0;\r\n}\r\nstatic int verify_aead(struct nlattr **attrs)\r\n{\r\nstruct nlattr *rt = attrs[XFRMA_ALG_AEAD];\r\nstruct xfrm_algo_aead *algp;\r\nif (!rt)\r\nreturn 0;\r\nalgp = nla_data(rt);\r\nif (nla_len(rt) < aead_len(algp))\r\nreturn -EINVAL;\r\nalgp->alg_name[CRYPTO_MAX_ALG_NAME - 1] = '\0';\r\nreturn 0;\r\n}\r\nstatic void verify_one_addr(struct nlattr **attrs, enum xfrm_attr_type_t type,\r\nxfrm_address_t **addrp)\r\n{\r\nstruct nlattr *rt = attrs[type];\r\nif (rt && addrp)\r\n*addrp = nla_data(rt);\r\n}\r\nstatic inline int verify_sec_ctx_len(struct nlattr **attrs)\r\n{\r\nstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\r\nstruct xfrm_user_sec_ctx *uctx;\r\nif (!rt)\r\nreturn 0;\r\nuctx = nla_data(rt);\r\nif (uctx->len != (sizeof(struct xfrm_user_sec_ctx) + uctx->ctx_len))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic inline int verify_replay(struct xfrm_usersa_info *p,\r\nstruct nlattr **attrs)\r\n{\r\nstruct nlattr *rt = attrs[XFRMA_REPLAY_ESN_VAL];\r\nstruct xfrm_replay_state_esn *rs;\r\nif (p->flags & XFRM_STATE_ESN) {\r\nif (!rt)\r\nreturn -EINVAL;\r\nrs = nla_data(rt);\r\nif (rs->bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof(rs->bmp[0]) / 8)\r\nreturn -EINVAL;\r\nif (nla_len(rt) < xfrm_replay_state_esn_len(rs) &&\r\nnla_len(rt) != sizeof(*rs))\r\nreturn -EINVAL;\r\n}\r\nif (!rt)\r\nreturn 0;\r\nif (p->id.proto != IPPROTO_ESP)\r\nreturn -EINVAL;\r\nif (p->replay_window != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int verify_newsa_info(struct xfrm_usersa_info *p,\r\nstruct nlattr **attrs)\r\n{\r\nint err;\r\nerr = -EINVAL;\r\nswitch (p->family) {\r\ncase AF_INET:\r\nbreak;\r\ncase AF_INET6:\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nbreak;\r\n#else\r\nerr = -EAFNOSUPPORT;\r\ngoto out;\r\n#endif\r\ndefault:\r\ngoto out;\r\n}\r\nerr = -EINVAL;\r\nswitch (p->id.proto) {\r\ncase IPPROTO_AH:\r\nif ((!attrs[XFRMA_ALG_AUTH] &&\r\n!attrs[XFRMA_ALG_AUTH_TRUNC]) ||\r\nattrs[XFRMA_ALG_AEAD] ||\r\nattrs[XFRMA_ALG_CRYPT] ||\r\nattrs[XFRMA_ALG_COMP] ||\r\nattrs[XFRMA_TFCPAD])\r\ngoto out;\r\nbreak;\r\ncase IPPROTO_ESP:\r\nif (attrs[XFRMA_ALG_COMP])\r\ngoto out;\r\nif (!attrs[XFRMA_ALG_AUTH] &&\r\n!attrs[XFRMA_ALG_AUTH_TRUNC] &&\r\n!attrs[XFRMA_ALG_CRYPT] &&\r\n!attrs[XFRMA_ALG_AEAD])\r\ngoto out;\r\nif ((attrs[XFRMA_ALG_AUTH] ||\r\nattrs[XFRMA_ALG_AUTH_TRUNC] ||\r\nattrs[XFRMA_ALG_CRYPT]) &&\r\nattrs[XFRMA_ALG_AEAD])\r\ngoto out;\r\nif (attrs[XFRMA_TFCPAD] &&\r\np->mode != XFRM_MODE_TUNNEL)\r\ngoto out;\r\nbreak;\r\ncase IPPROTO_COMP:\r\nif (!attrs[XFRMA_ALG_COMP] ||\r\nattrs[XFRMA_ALG_AEAD] ||\r\nattrs[XFRMA_ALG_AUTH] ||\r\nattrs[XFRMA_ALG_AUTH_TRUNC] ||\r\nattrs[XFRMA_ALG_CRYPT] ||\r\nattrs[XFRMA_TFCPAD])\r\ngoto out;\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase IPPROTO_DSTOPTS:\r\ncase IPPROTO_ROUTING:\r\nif (attrs[XFRMA_ALG_COMP] ||\r\nattrs[XFRMA_ALG_AUTH] ||\r\nattrs[XFRMA_ALG_AUTH_TRUNC] ||\r\nattrs[XFRMA_ALG_AEAD] ||\r\nattrs[XFRMA_ALG_CRYPT] ||\r\nattrs[XFRMA_ENCAP] ||\r\nattrs[XFRMA_SEC_CTX] ||\r\nattrs[XFRMA_TFCPAD] ||\r\n!attrs[XFRMA_COADDR])\r\ngoto out;\r\nbreak;\r\n#endif\r\ndefault:\r\ngoto out;\r\n}\r\nif ((err = verify_aead(attrs)))\r\ngoto out;\r\nif ((err = verify_auth_trunc(attrs)))\r\ngoto out;\r\nif ((err = verify_one_alg(attrs, XFRMA_ALG_AUTH)))\r\ngoto out;\r\nif ((err = verify_one_alg(attrs, XFRMA_ALG_CRYPT)))\r\ngoto out;\r\nif ((err = verify_one_alg(attrs, XFRMA_ALG_COMP)))\r\ngoto out;\r\nif ((err = verify_sec_ctx_len(attrs)))\r\ngoto out;\r\nif ((err = verify_replay(p, attrs)))\r\ngoto out;\r\nerr = -EINVAL;\r\nswitch (p->mode) {\r\ncase XFRM_MODE_TRANSPORT:\r\ncase XFRM_MODE_TUNNEL:\r\ncase XFRM_MODE_ROUTEOPTIMIZATION:\r\ncase XFRM_MODE_BEET:\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int attach_auth(struct xfrm_algo_auth **algpp, u8 *props,\r\nstruct nlattr *rta)\r\n{\r\nstruct xfrm_algo *ualg;\r\nstruct xfrm_algo_auth *p;\r\nstruct xfrm_algo_desc *algo;\r\nif (!rta)\r\nreturn 0;\r\nualg = nla_data(rta);\r\nalgo = xfrm_aalg_get_byname(ualg->alg_name, 1);\r\nif (!algo)\r\nreturn -ENOSYS;\r\n*props = algo->desc.sadb_alg_id;\r\np = kmalloc(sizeof(*p) + (ualg->alg_key_len + 7) / 8, GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\nstrcpy(p->alg_name, algo->name);\r\np->alg_key_len = ualg->alg_key_len;\r\np->alg_trunc_len = algo->uinfo.auth.icv_truncbits;\r\nmemcpy(p->alg_key, ualg->alg_key, (ualg->alg_key_len + 7) / 8);\r\n*algpp = p;\r\nreturn 0;\r\n}\r\nstatic int attach_auth_trunc(struct xfrm_algo_auth **algpp, u8 *props,\r\nstruct nlattr *rta)\r\n{\r\nstruct xfrm_algo_auth *p, *ualg;\r\nstruct xfrm_algo_desc *algo;\r\nif (!rta)\r\nreturn 0;\r\nualg = nla_data(rta);\r\nalgo = xfrm_aalg_get_byname(ualg->alg_name, 1);\r\nif (!algo)\r\nreturn -ENOSYS;\r\nif ((ualg->alg_trunc_len / 8) > MAX_AH_AUTH_LEN ||\r\nualg->alg_trunc_len > algo->uinfo.auth.icv_fullbits)\r\nreturn -EINVAL;\r\n*props = algo->desc.sadb_alg_id;\r\np = kmemdup(ualg, xfrm_alg_auth_len(ualg), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\nstrcpy(p->alg_name, algo->name);\r\nif (!p->alg_trunc_len)\r\np->alg_trunc_len = algo->uinfo.auth.icv_truncbits;\r\n*algpp = p;\r\nreturn 0;\r\n}\r\nstatic int attach_aead(struct xfrm_algo_aead **algpp, u8 *props,\r\nstruct nlattr *rta)\r\n{\r\nstruct xfrm_algo_aead *p, *ualg;\r\nstruct xfrm_algo_desc *algo;\r\nif (!rta)\r\nreturn 0;\r\nualg = nla_data(rta);\r\nalgo = xfrm_aead_get_byname(ualg->alg_name, ualg->alg_icv_len, 1);\r\nif (!algo)\r\nreturn -ENOSYS;\r\n*props = algo->desc.sadb_alg_id;\r\np = kmemdup(ualg, aead_len(ualg), GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\nstrcpy(p->alg_name, algo->name);\r\n*algpp = p;\r\nreturn 0;\r\n}\r\nstatic inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\r\nstruct nlattr *rp)\r\n{\r\nstruct xfrm_replay_state_esn *up;\r\nint ulen;\r\nif (!replay_esn || !rp)\r\nreturn 0;\r\nup = nla_data(rp);\r\nulen = xfrm_replay_state_esn_len(up);\r\nif (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int xfrm_alloc_replay_state_esn(struct xfrm_replay_state_esn **replay_esn,\r\nstruct xfrm_replay_state_esn **preplay_esn,\r\nstruct nlattr *rta)\r\n{\r\nstruct xfrm_replay_state_esn *p, *pp, *up;\r\nint klen, ulen;\r\nif (!rta)\r\nreturn 0;\r\nup = nla_data(rta);\r\nklen = xfrm_replay_state_esn_len(up);\r\nulen = nla_len(rta) >= klen ? klen : sizeof(*up);\r\np = kzalloc(klen, GFP_KERNEL);\r\nif (!p)\r\nreturn -ENOMEM;\r\npp = kzalloc(klen, GFP_KERNEL);\r\nif (!pp) {\r\nkfree(p);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(p, up, ulen);\r\nmemcpy(pp, up, ulen);\r\n*replay_esn = p;\r\n*preplay_esn = pp;\r\nreturn 0;\r\n}\r\nstatic inline int xfrm_user_sec_ctx_size(struct xfrm_sec_ctx *xfrm_ctx)\r\n{\r\nint len = 0;\r\nif (xfrm_ctx) {\r\nlen += sizeof(struct xfrm_user_sec_ctx);\r\nlen += xfrm_ctx->ctx_len;\r\n}\r\nreturn len;\r\n}\r\nstatic void copy_from_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\r\n{\r\nmemcpy(&x->id, &p->id, sizeof(x->id));\r\nmemcpy(&x->sel, &p->sel, sizeof(x->sel));\r\nmemcpy(&x->lft, &p->lft, sizeof(x->lft));\r\nx->props.mode = p->mode;\r\nx->props.replay_window = min_t(unsigned int, p->replay_window,\r\nsizeof(x->replay.bitmap) * 8);\r\nx->props.reqid = p->reqid;\r\nx->props.family = p->family;\r\nmemcpy(&x->props.saddr, &p->saddr, sizeof(x->props.saddr));\r\nx->props.flags = p->flags;\r\nif (!x->sel.family && !(p->flags & XFRM_STATE_AF_UNSPEC))\r\nx->sel.family = p->family;\r\n}\r\nstatic void xfrm_update_ae_params(struct xfrm_state *x, struct nlattr **attrs,\r\nint update_esn)\r\n{\r\nstruct nlattr *rp = attrs[XFRMA_REPLAY_VAL];\r\nstruct nlattr *re = update_esn ? attrs[XFRMA_REPLAY_ESN_VAL] : NULL;\r\nstruct nlattr *lt = attrs[XFRMA_LTIME_VAL];\r\nstruct nlattr *et = attrs[XFRMA_ETIMER_THRESH];\r\nstruct nlattr *rt = attrs[XFRMA_REPLAY_THRESH];\r\nif (re) {\r\nstruct xfrm_replay_state_esn *replay_esn;\r\nreplay_esn = nla_data(re);\r\nmemcpy(x->replay_esn, replay_esn,\r\nxfrm_replay_state_esn_len(replay_esn));\r\nmemcpy(x->preplay_esn, replay_esn,\r\nxfrm_replay_state_esn_len(replay_esn));\r\n}\r\nif (rp) {\r\nstruct xfrm_replay_state *replay;\r\nreplay = nla_data(rp);\r\nmemcpy(&x->replay, replay, sizeof(*replay));\r\nmemcpy(&x->preplay, replay, sizeof(*replay));\r\n}\r\nif (lt) {\r\nstruct xfrm_lifetime_cur *ltime;\r\nltime = nla_data(lt);\r\nx->curlft.bytes = ltime->bytes;\r\nx->curlft.packets = ltime->packets;\r\nx->curlft.add_time = ltime->add_time;\r\nx->curlft.use_time = ltime->use_time;\r\n}\r\nif (et)\r\nx->replay_maxage = nla_get_u32(et);\r\nif (rt)\r\nx->replay_maxdiff = nla_get_u32(rt);\r\n}\r\nstatic struct xfrm_state *xfrm_state_construct(struct net *net,\r\nstruct xfrm_usersa_info *p,\r\nstruct nlattr **attrs,\r\nint *errp)\r\n{\r\nstruct xfrm_state *x = xfrm_state_alloc(net);\r\nint err = -ENOMEM;\r\nif (!x)\r\ngoto error_no_put;\r\ncopy_from_user_state(x, p);\r\nif (attrs[XFRMA_SA_EXTRA_FLAGS])\r\nx->props.extra_flags = nla_get_u32(attrs[XFRMA_SA_EXTRA_FLAGS]);\r\nif ((err = attach_aead(&x->aead, &x->props.ealgo,\r\nattrs[XFRMA_ALG_AEAD])))\r\ngoto error;\r\nif ((err = attach_auth_trunc(&x->aalg, &x->props.aalgo,\r\nattrs[XFRMA_ALG_AUTH_TRUNC])))\r\ngoto error;\r\nif (!x->props.aalgo) {\r\nif ((err = attach_auth(&x->aalg, &x->props.aalgo,\r\nattrs[XFRMA_ALG_AUTH])))\r\ngoto error;\r\n}\r\nif ((err = attach_one_algo(&x->ealg, &x->props.ealgo,\r\nxfrm_ealg_get_byname,\r\nattrs[XFRMA_ALG_CRYPT])))\r\ngoto error;\r\nif ((err = attach_one_algo(&x->calg, &x->props.calgo,\r\nxfrm_calg_get_byname,\r\nattrs[XFRMA_ALG_COMP])))\r\ngoto error;\r\nif (attrs[XFRMA_ENCAP]) {\r\nx->encap = kmemdup(nla_data(attrs[XFRMA_ENCAP]),\r\nsizeof(*x->encap), GFP_KERNEL);\r\nif (x->encap == NULL)\r\ngoto error;\r\n}\r\nif (attrs[XFRMA_TFCPAD])\r\nx->tfcpad = nla_get_u32(attrs[XFRMA_TFCPAD]);\r\nif (attrs[XFRMA_COADDR]) {\r\nx->coaddr = kmemdup(nla_data(attrs[XFRMA_COADDR]),\r\nsizeof(*x->coaddr), GFP_KERNEL);\r\nif (x->coaddr == NULL)\r\ngoto error;\r\n}\r\nxfrm_mark_get(attrs, &x->mark);\r\nerr = __xfrm_init_state(x, false);\r\nif (err)\r\ngoto error;\r\nif (attrs[XFRMA_SEC_CTX] &&\r\nsecurity_xfrm_state_alloc(x, nla_data(attrs[XFRMA_SEC_CTX])))\r\ngoto error;\r\nif ((err = xfrm_alloc_replay_state_esn(&x->replay_esn, &x->preplay_esn,\r\nattrs[XFRMA_REPLAY_ESN_VAL])))\r\ngoto error;\r\nx->km.seq = p->seq;\r\nx->replay_maxdiff = net->xfrm.sysctl_aevent_rseqth;\r\nx->replay_maxage = (net->xfrm.sysctl_aevent_etime*HZ)/XFRM_AE_ETH_M;\r\nif ((err = xfrm_init_replay(x)))\r\ngoto error;\r\nxfrm_update_ae_params(x, attrs, 0);\r\nreturn x;\r\nerror:\r\nx->km.state = XFRM_STATE_DEAD;\r\nxfrm_state_put(x);\r\nerror_no_put:\r\n*errp = err;\r\nreturn NULL;\r\n}\r\nstatic int xfrm_add_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct xfrm_usersa_info *p = nlmsg_data(nlh);\r\nstruct xfrm_state *x;\r\nint err;\r\nstruct km_event c;\r\nkuid_t loginuid = audit_get_loginuid(current);\r\nu32 sessionid = audit_get_sessionid(current);\r\nu32 sid;\r\nerr = verify_newsa_info(p, attrs);\r\nif (err)\r\nreturn err;\r\nx = xfrm_state_construct(net, p, attrs, &err);\r\nif (!x)\r\nreturn err;\r\nxfrm_state_hold(x);\r\nif (nlh->nlmsg_type == XFRM_MSG_NEWSA)\r\nerr = xfrm_state_add(x);\r\nelse\r\nerr = xfrm_state_update(x);\r\nsecurity_task_getsecid(current, &sid);\r\nxfrm_audit_state_add(x, err ? 0 : 1, loginuid, sessionid, sid);\r\nif (err < 0) {\r\nx->km.state = XFRM_STATE_DEAD;\r\n__xfrm_state_put(x);\r\ngoto out;\r\n}\r\nc.seq = nlh->nlmsg_seq;\r\nc.portid = nlh->nlmsg_pid;\r\nc.event = nlh->nlmsg_type;\r\nkm_state_notify(x, &c);\r\nout:\r\nxfrm_state_put(x);\r\nreturn err;\r\n}\r\nstatic struct xfrm_state *xfrm_user_state_lookup(struct net *net,\r\nstruct xfrm_usersa_id *p,\r\nstruct nlattr **attrs,\r\nint *errp)\r\n{\r\nstruct xfrm_state *x = NULL;\r\nstruct xfrm_mark m;\r\nint err;\r\nu32 mark = xfrm_mark_get(attrs, &m);\r\nif (xfrm_id_proto_match(p->proto, IPSEC_PROTO_ANY)) {\r\nerr = -ESRCH;\r\nx = xfrm_state_lookup(net, mark, &p->daddr, p->spi, p->proto, p->family);\r\n} else {\r\nxfrm_address_t *saddr = NULL;\r\nverify_one_addr(attrs, XFRMA_SRCADDR, &saddr);\r\nif (!saddr) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nerr = -ESRCH;\r\nx = xfrm_state_lookup_byaddr(net, mark,\r\n&p->daddr, saddr,\r\np->proto, p->family);\r\n}\r\nout:\r\nif (!x && errp)\r\n*errp = err;\r\nreturn x;\r\n}\r\nstatic int xfrm_del_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct xfrm_state *x;\r\nint err = -ESRCH;\r\nstruct km_event c;\r\nstruct xfrm_usersa_id *p = nlmsg_data(nlh);\r\nkuid_t loginuid = audit_get_loginuid(current);\r\nu32 sessionid = audit_get_sessionid(current);\r\nu32 sid;\r\nx = xfrm_user_state_lookup(net, p, attrs, &err);\r\nif (x == NULL)\r\nreturn err;\r\nif ((err = security_xfrm_state_delete(x)) != 0)\r\ngoto out;\r\nif (xfrm_state_kern(x)) {\r\nerr = -EPERM;\r\ngoto out;\r\n}\r\nerr = xfrm_state_delete(x);\r\nif (err < 0)\r\ngoto out;\r\nc.seq = nlh->nlmsg_seq;\r\nc.portid = nlh->nlmsg_pid;\r\nc.event = nlh->nlmsg_type;\r\nkm_state_notify(x, &c);\r\nout:\r\nsecurity_task_getsecid(current, &sid);\r\nxfrm_audit_state_delete(x, err ? 0 : 1, loginuid, sessionid, sid);\r\nxfrm_state_put(x);\r\nreturn err;\r\n}\r\nstatic void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\r\n{\r\nmemset(p, 0, sizeof(*p));\r\nmemcpy(&p->id, &x->id, sizeof(p->id));\r\nmemcpy(&p->sel, &x->sel, sizeof(p->sel));\r\nmemcpy(&p->lft, &x->lft, sizeof(p->lft));\r\nmemcpy(&p->curlft, &x->curlft, sizeof(p->curlft));\r\nmemcpy(&p->stats, &x->stats, sizeof(p->stats));\r\nmemcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));\r\np->mode = x->props.mode;\r\np->replay_window = x->props.replay_window;\r\np->reqid = x->props.reqid;\r\np->family = x->props.family;\r\np->flags = x->props.flags;\r\np->seq = x->km.seq;\r\n}\r\nstatic int copy_sec_ctx(struct xfrm_sec_ctx *s, struct sk_buff *skb)\r\n{\r\nstruct xfrm_user_sec_ctx *uctx;\r\nstruct nlattr *attr;\r\nint ctx_size = sizeof(*uctx) + s->ctx_len;\r\nattr = nla_reserve(skb, XFRMA_SEC_CTX, ctx_size);\r\nif (attr == NULL)\r\nreturn -EMSGSIZE;\r\nuctx = nla_data(attr);\r\nuctx->exttype = XFRMA_SEC_CTX;\r\nuctx->len = ctx_size;\r\nuctx->ctx_doi = s->ctx_doi;\r\nuctx->ctx_alg = s->ctx_alg;\r\nuctx->ctx_len = s->ctx_len;\r\nmemcpy(uctx + 1, s->ctx_str, s->ctx_len);\r\nreturn 0;\r\n}\r\nstatic int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\r\n{\r\nstruct xfrm_algo *algo;\r\nstruct nlattr *nla;\r\nnla = nla_reserve(skb, XFRMA_ALG_AUTH,\r\nsizeof(*algo) + (auth->alg_key_len + 7) / 8);\r\nif (!nla)\r\nreturn -EMSGSIZE;\r\nalgo = nla_data(nla);\r\nstrncpy(algo->alg_name, auth->alg_name, sizeof(algo->alg_name));\r\nmemcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);\r\nalgo->alg_key_len = auth->alg_key_len;\r\nreturn 0;\r\n}\r\nstatic int copy_to_user_state_extra(struct xfrm_state *x,\r\nstruct xfrm_usersa_info *p,\r\nstruct sk_buff *skb)\r\n{\r\nint ret = 0;\r\ncopy_to_user_state(x, p);\r\nif (x->props.extra_flags) {\r\nret = nla_put_u32(skb, XFRMA_SA_EXTRA_FLAGS,\r\nx->props.extra_flags);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (x->coaddr) {\r\nret = nla_put(skb, XFRMA_COADDR, sizeof(*x->coaddr), x->coaddr);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (x->lastused) {\r\nret = nla_put_u64(skb, XFRMA_LASTUSED, x->lastused);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (x->aead) {\r\nret = nla_put(skb, XFRMA_ALG_AEAD, aead_len(x->aead), x->aead);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (x->aalg) {\r\nret = copy_to_user_auth(x->aalg, skb);\r\nif (!ret)\r\nret = nla_put(skb, XFRMA_ALG_AUTH_TRUNC,\r\nxfrm_alg_auth_len(x->aalg), x->aalg);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (x->ealg) {\r\nret = nla_put(skb, XFRMA_ALG_CRYPT, xfrm_alg_len(x->ealg), x->ealg);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (x->calg) {\r\nret = nla_put(skb, XFRMA_ALG_COMP, sizeof(*(x->calg)), x->calg);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (x->encap) {\r\nret = nla_put(skb, XFRMA_ENCAP, sizeof(*x->encap), x->encap);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (x->tfcpad) {\r\nret = nla_put_u32(skb, XFRMA_TFCPAD, x->tfcpad);\r\nif (ret)\r\ngoto out;\r\n}\r\nret = xfrm_mark_put(skb, &x->mark);\r\nif (ret)\r\ngoto out;\r\nif (x->replay_esn) {\r\nret = nla_put(skb, XFRMA_REPLAY_ESN_VAL,\r\nxfrm_replay_state_esn_len(x->replay_esn),\r\nx->replay_esn);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (x->security)\r\nret = copy_sec_ctx(x->security, skb);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int dump_one_state(struct xfrm_state *x, int count, void *ptr)\r\n{\r\nstruct xfrm_dump_info *sp = ptr;\r\nstruct sk_buff *in_skb = sp->in_skb;\r\nstruct sk_buff *skb = sp->out_skb;\r\nstruct xfrm_usersa_info *p;\r\nstruct nlmsghdr *nlh;\r\nint err;\r\nnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, sp->nlmsg_seq,\r\nXFRM_MSG_NEWSA, sizeof(*p), sp->nlmsg_flags);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\np = nlmsg_data(nlh);\r\nerr = copy_to_user_state_extra(x, p, skb);\r\nif (err) {\r\nnlmsg_cancel(skb, nlh);\r\nreturn err;\r\n}\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\n}\r\nstatic int xfrm_dump_sa_done(struct netlink_callback *cb)\r\n{\r\nstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\r\nxfrm_state_walk_done(walk);\r\nreturn 0;\r\n}\r\nstatic int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\r\nstruct xfrm_dump_info info;\r\nBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\r\nsizeof(cb->args) - sizeof(cb->args[0]));\r\ninfo.in_skb = cb->skb;\r\ninfo.out_skb = skb;\r\ninfo.nlmsg_seq = cb->nlh->nlmsg_seq;\r\ninfo.nlmsg_flags = NLM_F_MULTI;\r\nif (!cb->args[0]) {\r\ncb->args[0] = 1;\r\nxfrm_state_walk_init(walk, 0);\r\n}\r\n(void) xfrm_state_walk(net, walk, dump_one_state, &info);\r\nreturn skb->len;\r\n}\r\nstatic struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb,\r\nstruct xfrm_state *x, u32 seq)\r\n{\r\nstruct xfrm_dump_info info;\r\nstruct sk_buff *skb;\r\nint err;\r\nskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ninfo.in_skb = in_skb;\r\ninfo.out_skb = skb;\r\ninfo.nlmsg_seq = seq;\r\ninfo.nlmsg_flags = 0;\r\nerr = dump_one_state(x, 0, &info);\r\nif (err) {\r\nkfree_skb(skb);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn skb;\r\n}\r\nstatic inline size_t xfrm_spdinfo_msgsize(void)\r\n{\r\nreturn NLMSG_ALIGN(4)\r\n+ nla_total_size(sizeof(struct xfrmu_spdinfo))\r\n+ nla_total_size(sizeof(struct xfrmu_spdhinfo));\r\n}\r\nstatic int build_spdinfo(struct sk_buff *skb, struct net *net,\r\nu32 portid, u32 seq, u32 flags)\r\n{\r\nstruct xfrmk_spdinfo si;\r\nstruct xfrmu_spdinfo spc;\r\nstruct xfrmu_spdhinfo sph;\r\nstruct nlmsghdr *nlh;\r\nint err;\r\nu32 *f;\r\nnlh = nlmsg_put(skb, portid, seq, XFRM_MSG_NEWSPDINFO, sizeof(u32), 0);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nf = nlmsg_data(nlh);\r\n*f = flags;\r\nxfrm_spd_getinfo(net, &si);\r\nspc.incnt = si.incnt;\r\nspc.outcnt = si.outcnt;\r\nspc.fwdcnt = si.fwdcnt;\r\nspc.inscnt = si.inscnt;\r\nspc.outscnt = si.outscnt;\r\nspc.fwdscnt = si.fwdscnt;\r\nsph.spdhcnt = si.spdhcnt;\r\nsph.spdhmcnt = si.spdhmcnt;\r\nerr = nla_put(skb, XFRMA_SPD_INFO, sizeof(spc), &spc);\r\nif (!err)\r\nerr = nla_put(skb, XFRMA_SPD_HINFO, sizeof(sph), &sph);\r\nif (err) {\r\nnlmsg_cancel(skb, nlh);\r\nreturn err;\r\n}\r\nreturn nlmsg_end(skb, nlh);\r\n}\r\nstatic int xfrm_get_spdinfo(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct sk_buff *r_skb;\r\nu32 *flags = nlmsg_data(nlh);\r\nu32 sportid = NETLINK_CB(skb).portid;\r\nu32 seq = nlh->nlmsg_seq;\r\nr_skb = nlmsg_new(xfrm_spdinfo_msgsize(), GFP_ATOMIC);\r\nif (r_skb == NULL)\r\nreturn -ENOMEM;\r\nif (build_spdinfo(r_skb, net, sportid, seq, *flags) < 0)\r\nBUG();\r\nreturn nlmsg_unicast(net->xfrm.nlsk, r_skb, sportid);\r\n}\r\nstatic inline size_t xfrm_sadinfo_msgsize(void)\r\n{\r\nreturn NLMSG_ALIGN(4)\r\n+ nla_total_size(sizeof(struct xfrmu_sadhinfo))\r\n+ nla_total_size(4);\r\n}\r\nstatic int build_sadinfo(struct sk_buff *skb, struct net *net,\r\nu32 portid, u32 seq, u32 flags)\r\n{\r\nstruct xfrmk_sadinfo si;\r\nstruct xfrmu_sadhinfo sh;\r\nstruct nlmsghdr *nlh;\r\nint err;\r\nu32 *f;\r\nnlh = nlmsg_put(skb, portid, seq, XFRM_MSG_NEWSADINFO, sizeof(u32), 0);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nf = nlmsg_data(nlh);\r\n*f = flags;\r\nxfrm_sad_getinfo(net, &si);\r\nsh.sadhmcnt = si.sadhmcnt;\r\nsh.sadhcnt = si.sadhcnt;\r\nerr = nla_put_u32(skb, XFRMA_SAD_CNT, si.sadcnt);\r\nif (!err)\r\nerr = nla_put(skb, XFRMA_SAD_HINFO, sizeof(sh), &sh);\r\nif (err) {\r\nnlmsg_cancel(skb, nlh);\r\nreturn err;\r\n}\r\nreturn nlmsg_end(skb, nlh);\r\n}\r\nstatic int xfrm_get_sadinfo(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct sk_buff *r_skb;\r\nu32 *flags = nlmsg_data(nlh);\r\nu32 sportid = NETLINK_CB(skb).portid;\r\nu32 seq = nlh->nlmsg_seq;\r\nr_skb = nlmsg_new(xfrm_sadinfo_msgsize(), GFP_ATOMIC);\r\nif (r_skb == NULL)\r\nreturn -ENOMEM;\r\nif (build_sadinfo(r_skb, net, sportid, seq, *flags) < 0)\r\nBUG();\r\nreturn nlmsg_unicast(net->xfrm.nlsk, r_skb, sportid);\r\n}\r\nstatic int xfrm_get_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct xfrm_usersa_id *p = nlmsg_data(nlh);\r\nstruct xfrm_state *x;\r\nstruct sk_buff *resp_skb;\r\nint err = -ESRCH;\r\nx = xfrm_user_state_lookup(net, p, attrs, &err);\r\nif (x == NULL)\r\ngoto out_noput;\r\nresp_skb = xfrm_state_netlink(skb, x, nlh->nlmsg_seq);\r\nif (IS_ERR(resp_skb)) {\r\nerr = PTR_ERR(resp_skb);\r\n} else {\r\nerr = nlmsg_unicast(net->xfrm.nlsk, resp_skb, NETLINK_CB(skb).portid);\r\n}\r\nxfrm_state_put(x);\r\nout_noput:\r\nreturn err;\r\n}\r\nstatic int verify_userspi_info(struct xfrm_userspi_info *p)\r\n{\r\nswitch (p->info.id.proto) {\r\ncase IPPROTO_AH:\r\ncase IPPROTO_ESP:\r\nbreak;\r\ncase IPPROTO_COMP:\r\nif (p->max >= 0x10000)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (p->min > p->max)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int xfrm_alloc_userspi(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct xfrm_state *x;\r\nstruct xfrm_userspi_info *p;\r\nstruct sk_buff *resp_skb;\r\nxfrm_address_t *daddr;\r\nint family;\r\nint err;\r\nu32 mark;\r\nstruct xfrm_mark m;\r\np = nlmsg_data(nlh);\r\nerr = verify_userspi_info(p);\r\nif (err)\r\ngoto out_noput;\r\nfamily = p->info.family;\r\ndaddr = &p->info.id.daddr;\r\nx = NULL;\r\nmark = xfrm_mark_get(attrs, &m);\r\nif (p->info.seq) {\r\nx = xfrm_find_acq_byseq(net, mark, p->info.seq);\r\nif (x && !xfrm_addr_equal(&x->id.daddr, daddr, family)) {\r\nxfrm_state_put(x);\r\nx = NULL;\r\n}\r\n}\r\nif (!x)\r\nx = xfrm_find_acq(net, &m, p->info.mode, p->info.reqid,\r\np->info.id.proto, daddr,\r\n&p->info.saddr, 1,\r\nfamily);\r\nerr = -ENOENT;\r\nif (x == NULL)\r\ngoto out_noput;\r\nerr = xfrm_alloc_spi(x, p->min, p->max);\r\nif (err)\r\ngoto out;\r\nresp_skb = xfrm_state_netlink(skb, x, nlh->nlmsg_seq);\r\nif (IS_ERR(resp_skb)) {\r\nerr = PTR_ERR(resp_skb);\r\ngoto out;\r\n}\r\nerr = nlmsg_unicast(net->xfrm.nlsk, resp_skb, NETLINK_CB(skb).portid);\r\nout:\r\nxfrm_state_put(x);\r\nout_noput:\r\nreturn err;\r\n}\r\nstatic int verify_policy_dir(u8 dir)\r\n{\r\nswitch (dir) {\r\ncase XFRM_POLICY_IN:\r\ncase XFRM_POLICY_OUT:\r\ncase XFRM_POLICY_FWD:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int verify_policy_type(u8 type)\r\n{\r\nswitch (type) {\r\ncase XFRM_POLICY_TYPE_MAIN:\r\n#ifdef CONFIG_XFRM_SUB_POLICY\r\ncase XFRM_POLICY_TYPE_SUB:\r\n#endif\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int verify_newpolicy_info(struct xfrm_userpolicy_info *p)\r\n{\r\nswitch (p->share) {\r\ncase XFRM_SHARE_ANY:\r\ncase XFRM_SHARE_SESSION:\r\ncase XFRM_SHARE_USER:\r\ncase XFRM_SHARE_UNIQUE:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (p->action) {\r\ncase XFRM_POLICY_ALLOW:\r\ncase XFRM_POLICY_BLOCK:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (p->sel.family) {\r\ncase AF_INET:\r\nbreak;\r\ncase AF_INET6:\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nbreak;\r\n#else\r\nreturn -EAFNOSUPPORT;\r\n#endif\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn verify_policy_dir(p->dir);\r\n}\r\nstatic int copy_from_user_sec_ctx(struct xfrm_policy *pol, struct nlattr **attrs)\r\n{\r\nstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\r\nstruct xfrm_user_sec_ctx *uctx;\r\nif (!rt)\r\nreturn 0;\r\nuctx = nla_data(rt);\r\nreturn security_xfrm_policy_alloc(&pol->security, uctx);\r\n}\r\nstatic void copy_templates(struct xfrm_policy *xp, struct xfrm_user_tmpl *ut,\r\nint nr)\r\n{\r\nint i;\r\nxp->xfrm_nr = nr;\r\nfor (i = 0; i < nr; i++, ut++) {\r\nstruct xfrm_tmpl *t = &xp->xfrm_vec[i];\r\nmemcpy(&t->id, &ut->id, sizeof(struct xfrm_id));\r\nmemcpy(&t->saddr, &ut->saddr,\r\nsizeof(xfrm_address_t));\r\nt->reqid = ut->reqid;\r\nt->mode = ut->mode;\r\nt->share = ut->share;\r\nt->optional = ut->optional;\r\nt->aalgos = ut->aalgos;\r\nt->ealgos = ut->ealgos;\r\nt->calgos = ut->calgos;\r\nt->allalgs = !~(t->aalgos & t->ealgos & t->calgos);\r\nt->encap_family = ut->family;\r\n}\r\n}\r\nstatic int validate_tmpl(int nr, struct xfrm_user_tmpl *ut, u16 family)\r\n{\r\nint i;\r\nif (nr > XFRM_MAX_DEPTH)\r\nreturn -EINVAL;\r\nfor (i = 0; i < nr; i++) {\r\nif (!ut[i].family)\r\nut[i].family = family;\r\nswitch (ut[i].family) {\r\ncase AF_INET:\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int copy_from_user_tmpl(struct xfrm_policy *pol, struct nlattr **attrs)\r\n{\r\nstruct nlattr *rt = attrs[XFRMA_TMPL];\r\nif (!rt) {\r\npol->xfrm_nr = 0;\r\n} else {\r\nstruct xfrm_user_tmpl *utmpl = nla_data(rt);\r\nint nr = nla_len(rt) / sizeof(*utmpl);\r\nint err;\r\nerr = validate_tmpl(nr, utmpl, pol->family);\r\nif (err)\r\nreturn err;\r\ncopy_templates(pol, utmpl, nr);\r\n}\r\nreturn 0;\r\n}\r\nstatic int copy_from_user_policy_type(u8 *tp, struct nlattr **attrs)\r\n{\r\nstruct nlattr *rt = attrs[XFRMA_POLICY_TYPE];\r\nstruct xfrm_userpolicy_type *upt;\r\nu8 type = XFRM_POLICY_TYPE_MAIN;\r\nint err;\r\nif (rt) {\r\nupt = nla_data(rt);\r\ntype = upt->type;\r\n}\r\nerr = verify_policy_type(type);\r\nif (err)\r\nreturn err;\r\n*tp = type;\r\nreturn 0;\r\n}\r\nstatic void copy_from_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p)\r\n{\r\nxp->priority = p->priority;\r\nxp->index = p->index;\r\nmemcpy(&xp->selector, &p->sel, sizeof(xp->selector));\r\nmemcpy(&xp->lft, &p->lft, sizeof(xp->lft));\r\nxp->action = p->action;\r\nxp->flags = p->flags;\r\nxp->family = p->sel.family;\r\n}\r\nstatic void copy_to_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p, int dir)\r\n{\r\nmemset(p, 0, sizeof(*p));\r\nmemcpy(&p->sel, &xp->selector, sizeof(p->sel));\r\nmemcpy(&p->lft, &xp->lft, sizeof(p->lft));\r\nmemcpy(&p->curlft, &xp->curlft, sizeof(p->curlft));\r\np->priority = xp->priority;\r\np->index = xp->index;\r\np->sel.family = xp->family;\r\np->dir = dir;\r\np->action = xp->action;\r\np->flags = xp->flags;\r\np->share = XFRM_SHARE_ANY;\r\n}\r\nstatic struct xfrm_policy *xfrm_policy_construct(struct net *net, struct xfrm_userpolicy_info *p, struct nlattr **attrs, int *errp)\r\n{\r\nstruct xfrm_policy *xp = xfrm_policy_alloc(net, GFP_KERNEL);\r\nint err;\r\nif (!xp) {\r\n*errp = -ENOMEM;\r\nreturn NULL;\r\n}\r\ncopy_from_user_policy(xp, p);\r\nerr = copy_from_user_policy_type(&xp->type, attrs);\r\nif (err)\r\ngoto error;\r\nif (!(err = copy_from_user_tmpl(xp, attrs)))\r\nerr = copy_from_user_sec_ctx(xp, attrs);\r\nif (err)\r\ngoto error;\r\nxfrm_mark_get(attrs, &xp->mark);\r\nreturn xp;\r\nerror:\r\n*errp = err;\r\nxp->walk.dead = 1;\r\nxfrm_policy_destroy(xp);\r\nreturn NULL;\r\n}\r\nstatic int xfrm_add_policy(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct xfrm_userpolicy_info *p = nlmsg_data(nlh);\r\nstruct xfrm_policy *xp;\r\nstruct km_event c;\r\nint err;\r\nint excl;\r\nkuid_t loginuid = audit_get_loginuid(current);\r\nu32 sessionid = audit_get_sessionid(current);\r\nu32 sid;\r\nerr = verify_newpolicy_info(p);\r\nif (err)\r\nreturn err;\r\nerr = verify_sec_ctx_len(attrs);\r\nif (err)\r\nreturn err;\r\nxp = xfrm_policy_construct(net, p, attrs, &err);\r\nif (!xp)\r\nreturn err;\r\nexcl = nlh->nlmsg_type == XFRM_MSG_NEWPOLICY;\r\nerr = xfrm_policy_insert(p->dir, xp, excl);\r\nsecurity_task_getsecid(current, &sid);\r\nxfrm_audit_policy_add(xp, err ? 0 : 1, loginuid, sessionid, sid);\r\nif (err) {\r\nsecurity_xfrm_policy_free(xp->security);\r\nkfree(xp);\r\nreturn err;\r\n}\r\nc.event = nlh->nlmsg_type;\r\nc.seq = nlh->nlmsg_seq;\r\nc.portid = nlh->nlmsg_pid;\r\nkm_policy_notify(xp, p->dir, &c);\r\nxfrm_pol_put(xp);\r\nreturn 0;\r\n}\r\nstatic int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\r\n{\r\nstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\r\nint i;\r\nif (xp->xfrm_nr == 0)\r\nreturn 0;\r\nfor (i = 0; i < xp->xfrm_nr; i++) {\r\nstruct xfrm_user_tmpl *up = &vec[i];\r\nstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\r\nmemset(up, 0, sizeof(*up));\r\nmemcpy(&up->id, &kp->id, sizeof(up->id));\r\nup->family = kp->encap_family;\r\nmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\r\nup->reqid = kp->reqid;\r\nup->mode = kp->mode;\r\nup->share = kp->share;\r\nup->optional = kp->optional;\r\nup->aalgos = kp->aalgos;\r\nup->ealgos = kp->ealgos;\r\nup->calgos = kp->calgos;\r\n}\r\nreturn nla_put(skb, XFRMA_TMPL,\r\nsizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\r\n}\r\nstatic inline int copy_to_user_state_sec_ctx(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nif (x->security) {\r\nreturn copy_sec_ctx(x->security, skb);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int copy_to_user_sec_ctx(struct xfrm_policy *xp, struct sk_buff *skb)\r\n{\r\nif (xp->security)\r\nreturn copy_sec_ctx(xp->security, skb);\r\nreturn 0;\r\n}\r\nstatic inline size_t userpolicy_type_attrsize(void)\r\n{\r\n#ifdef CONFIG_XFRM_SUB_POLICY\r\nreturn nla_total_size(sizeof(struct xfrm_userpolicy_type));\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int copy_to_user_policy_type(u8 type, struct sk_buff *skb)\r\n{\r\nstruct xfrm_userpolicy_type upt = {\r\n.type = type,\r\n};\r\nreturn nla_put(skb, XFRMA_POLICY_TYPE, sizeof(upt), &upt);\r\n}\r\nstatic inline int copy_to_user_policy_type(u8 type, struct sk_buff *skb)\r\n{\r\nreturn 0;\r\n}\r\nstatic int dump_one_policy(struct xfrm_policy *xp, int dir, int count, void *ptr)\r\n{\r\nstruct xfrm_dump_info *sp = ptr;\r\nstruct xfrm_userpolicy_info *p;\r\nstruct sk_buff *in_skb = sp->in_skb;\r\nstruct sk_buff *skb = sp->out_skb;\r\nstruct nlmsghdr *nlh;\r\nint err;\r\nnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, sp->nlmsg_seq,\r\nXFRM_MSG_NEWPOLICY, sizeof(*p), sp->nlmsg_flags);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\np = nlmsg_data(nlh);\r\ncopy_to_user_policy(xp, p, dir);\r\nerr = copy_to_user_tmpl(xp, skb);\r\nif (!err)\r\nerr = copy_to_user_sec_ctx(xp, skb);\r\nif (!err)\r\nerr = copy_to_user_policy_type(xp->type, skb);\r\nif (!err)\r\nerr = xfrm_mark_put(skb, &xp->mark);\r\nif (err) {\r\nnlmsg_cancel(skb, nlh);\r\nreturn err;\r\n}\r\nnlmsg_end(skb, nlh);\r\nreturn 0;\r\n}\r\nstatic int xfrm_dump_policy_done(struct netlink_callback *cb)\r\n{\r\nstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\r\nxfrm_policy_walk_done(walk);\r\nreturn 0;\r\n}\r\nstatic int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\r\nstruct xfrm_dump_info info;\r\nBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\r\nsizeof(cb->args) - sizeof(cb->args[0]));\r\ninfo.in_skb = cb->skb;\r\ninfo.out_skb = skb;\r\ninfo.nlmsg_seq = cb->nlh->nlmsg_seq;\r\ninfo.nlmsg_flags = NLM_F_MULTI;\r\nif (!cb->args[0]) {\r\ncb->args[0] = 1;\r\nxfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\r\n}\r\n(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\r\nreturn skb->len;\r\n}\r\nstatic struct sk_buff *xfrm_policy_netlink(struct sk_buff *in_skb,\r\nstruct xfrm_policy *xp,\r\nint dir, u32 seq)\r\n{\r\nstruct xfrm_dump_info info;\r\nstruct sk_buff *skb;\r\nint err;\r\nskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ninfo.in_skb = in_skb;\r\ninfo.out_skb = skb;\r\ninfo.nlmsg_seq = seq;\r\ninfo.nlmsg_flags = 0;\r\nerr = dump_one_policy(xp, dir, 0, &info);\r\nif (err) {\r\nkfree_skb(skb);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn skb;\r\n}\r\nstatic int xfrm_get_policy(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct xfrm_policy *xp;\r\nstruct xfrm_userpolicy_id *p;\r\nu8 type = XFRM_POLICY_TYPE_MAIN;\r\nint err;\r\nstruct km_event c;\r\nint delete;\r\nstruct xfrm_mark m;\r\nu32 mark = xfrm_mark_get(attrs, &m);\r\np = nlmsg_data(nlh);\r\ndelete = nlh->nlmsg_type == XFRM_MSG_DELPOLICY;\r\nerr = copy_from_user_policy_type(&type, attrs);\r\nif (err)\r\nreturn err;\r\nerr = verify_policy_dir(p->dir);\r\nif (err)\r\nreturn err;\r\nif (p->index)\r\nxp = xfrm_policy_byid(net, mark, type, p->dir, p->index, delete, &err);\r\nelse {\r\nstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\r\nstruct xfrm_sec_ctx *ctx;\r\nerr = verify_sec_ctx_len(attrs);\r\nif (err)\r\nreturn err;\r\nctx = NULL;\r\nif (rt) {\r\nstruct xfrm_user_sec_ctx *uctx = nla_data(rt);\r\nerr = security_xfrm_policy_alloc(&ctx, uctx);\r\nif (err)\r\nreturn err;\r\n}\r\nxp = xfrm_policy_bysel_ctx(net, mark, type, p->dir, &p->sel,\r\nctx, delete, &err);\r\nsecurity_xfrm_policy_free(ctx);\r\n}\r\nif (xp == NULL)\r\nreturn -ENOENT;\r\nif (!delete) {\r\nstruct sk_buff *resp_skb;\r\nresp_skb = xfrm_policy_netlink(skb, xp, p->dir, nlh->nlmsg_seq);\r\nif (IS_ERR(resp_skb)) {\r\nerr = PTR_ERR(resp_skb);\r\n} else {\r\nerr = nlmsg_unicast(net->xfrm.nlsk, resp_skb,\r\nNETLINK_CB(skb).portid);\r\n}\r\n} else {\r\nkuid_t loginuid = audit_get_loginuid(current);\r\nu32 sessionid = audit_get_sessionid(current);\r\nu32 sid;\r\nsecurity_task_getsecid(current, &sid);\r\nxfrm_audit_policy_delete(xp, err ? 0 : 1, loginuid, sessionid,\r\nsid);\r\nif (err != 0)\r\ngoto out;\r\nc.data.byid = p->index;\r\nc.event = nlh->nlmsg_type;\r\nc.seq = nlh->nlmsg_seq;\r\nc.portid = nlh->nlmsg_pid;\r\nkm_policy_notify(xp, p->dir, &c);\r\n}\r\nout:\r\nxfrm_pol_put(xp);\r\nif (delete && err == 0)\r\nxfrm_garbage_collect(net);\r\nreturn err;\r\n}\r\nstatic int xfrm_flush_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct km_event c;\r\nstruct xfrm_usersa_flush *p = nlmsg_data(nlh);\r\nstruct xfrm_audit audit_info;\r\nint err;\r\naudit_info.loginuid = audit_get_loginuid(current);\r\naudit_info.sessionid = audit_get_sessionid(current);\r\nsecurity_task_getsecid(current, &audit_info.secid);\r\nerr = xfrm_state_flush(net, p->proto, &audit_info);\r\nif (err) {\r\nif (err == -ESRCH)\r\nreturn 0;\r\nreturn err;\r\n}\r\nc.data.proto = p->proto;\r\nc.event = nlh->nlmsg_type;\r\nc.seq = nlh->nlmsg_seq;\r\nc.portid = nlh->nlmsg_pid;\r\nc.net = net;\r\nkm_state_notify(NULL, &c);\r\nreturn 0;\r\n}\r\nstatic inline size_t xfrm_aevent_msgsize(struct xfrm_state *x)\r\n{\r\nsize_t replay_size = x->replay_esn ?\r\nxfrm_replay_state_esn_len(x->replay_esn) :\r\nsizeof(struct xfrm_replay_state);\r\nreturn NLMSG_ALIGN(sizeof(struct xfrm_aevent_id))\r\n+ nla_total_size(replay_size)\r\n+ nla_total_size(sizeof(struct xfrm_lifetime_cur))\r\n+ nla_total_size(sizeof(struct xfrm_mark))\r\n+ nla_total_size(4)\r\n+ nla_total_size(4);\r\n}\r\nstatic int build_aevent(struct sk_buff *skb, struct xfrm_state *x, const struct km_event *c)\r\n{\r\nstruct xfrm_aevent_id *id;\r\nstruct nlmsghdr *nlh;\r\nint err;\r\nnlh = nlmsg_put(skb, c->portid, c->seq, XFRM_MSG_NEWAE, sizeof(*id), 0);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nid = nlmsg_data(nlh);\r\nmemcpy(&id->sa_id.daddr, &x->id.daddr,sizeof(x->id.daddr));\r\nid->sa_id.spi = x->id.spi;\r\nid->sa_id.family = x->props.family;\r\nid->sa_id.proto = x->id.proto;\r\nmemcpy(&id->saddr, &x->props.saddr,sizeof(x->props.saddr));\r\nid->reqid = x->props.reqid;\r\nid->flags = c->data.aevent;\r\nif (x->replay_esn) {\r\nerr = nla_put(skb, XFRMA_REPLAY_ESN_VAL,\r\nxfrm_replay_state_esn_len(x->replay_esn),\r\nx->replay_esn);\r\n} else {\r\nerr = nla_put(skb, XFRMA_REPLAY_VAL, sizeof(x->replay),\r\n&x->replay);\r\n}\r\nif (err)\r\ngoto out_cancel;\r\nerr = nla_put(skb, XFRMA_LTIME_VAL, sizeof(x->curlft), &x->curlft);\r\nif (err)\r\ngoto out_cancel;\r\nif (id->flags & XFRM_AE_RTHR) {\r\nerr = nla_put_u32(skb, XFRMA_REPLAY_THRESH, x->replay_maxdiff);\r\nif (err)\r\ngoto out_cancel;\r\n}\r\nif (id->flags & XFRM_AE_ETHR) {\r\nerr = nla_put_u32(skb, XFRMA_ETIMER_THRESH,\r\nx->replay_maxage * 10 / HZ);\r\nif (err)\r\ngoto out_cancel;\r\n}\r\nerr = xfrm_mark_put(skb, &x->mark);\r\nif (err)\r\ngoto out_cancel;\r\nreturn nlmsg_end(skb, nlh);\r\nout_cancel:\r\nnlmsg_cancel(skb, nlh);\r\nreturn err;\r\n}\r\nstatic int xfrm_get_ae(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct xfrm_state *x;\r\nstruct sk_buff *r_skb;\r\nint err;\r\nstruct km_event c;\r\nu32 mark;\r\nstruct xfrm_mark m;\r\nstruct xfrm_aevent_id *p = nlmsg_data(nlh);\r\nstruct xfrm_usersa_id *id = &p->sa_id;\r\nmark = xfrm_mark_get(attrs, &m);\r\nx = xfrm_state_lookup(net, mark, &id->daddr, id->spi, id->proto, id->family);\r\nif (x == NULL)\r\nreturn -ESRCH;\r\nr_skb = nlmsg_new(xfrm_aevent_msgsize(x), GFP_ATOMIC);\r\nif (r_skb == NULL) {\r\nxfrm_state_put(x);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_bh(&x->lock);\r\nc.data.aevent = p->flags;\r\nc.seq = nlh->nlmsg_seq;\r\nc.portid = nlh->nlmsg_pid;\r\nif (build_aevent(r_skb, x, &c) < 0)\r\nBUG();\r\nerr = nlmsg_unicast(net->xfrm.nlsk, r_skb, NETLINK_CB(skb).portid);\r\nspin_unlock_bh(&x->lock);\r\nxfrm_state_put(x);\r\nreturn err;\r\n}\r\nstatic int xfrm_new_ae(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct xfrm_state *x;\r\nstruct km_event c;\r\nint err = - EINVAL;\r\nu32 mark = 0;\r\nstruct xfrm_mark m;\r\nstruct xfrm_aevent_id *p = nlmsg_data(nlh);\r\nstruct nlattr *rp = attrs[XFRMA_REPLAY_VAL];\r\nstruct nlattr *re = attrs[XFRMA_REPLAY_ESN_VAL];\r\nstruct nlattr *lt = attrs[XFRMA_LTIME_VAL];\r\nif (!lt && !rp && !re)\r\nreturn err;\r\nif (!(nlh->nlmsg_flags&NLM_F_REPLACE))\r\nreturn err;\r\nmark = xfrm_mark_get(attrs, &m);\r\nx = xfrm_state_lookup(net, mark, &p->sa_id.daddr, p->sa_id.spi, p->sa_id.proto, p->sa_id.family);\r\nif (x == NULL)\r\nreturn -ESRCH;\r\nif (x->km.state != XFRM_STATE_VALID)\r\ngoto out;\r\nerr = xfrm_replay_verify_len(x->replay_esn, re);\r\nif (err)\r\ngoto out;\r\nspin_lock_bh(&x->lock);\r\nxfrm_update_ae_params(x, attrs, 1);\r\nspin_unlock_bh(&x->lock);\r\nc.event = nlh->nlmsg_type;\r\nc.seq = nlh->nlmsg_seq;\r\nc.portid = nlh->nlmsg_pid;\r\nc.data.aevent = XFRM_AE_CU;\r\nkm_state_notify(x, &c);\r\nerr = 0;\r\nout:\r\nxfrm_state_put(x);\r\nreturn err;\r\n}\r\nstatic int xfrm_flush_policy(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct km_event c;\r\nu8 type = XFRM_POLICY_TYPE_MAIN;\r\nint err;\r\nstruct xfrm_audit audit_info;\r\nerr = copy_from_user_policy_type(&type, attrs);\r\nif (err)\r\nreturn err;\r\naudit_info.loginuid = audit_get_loginuid(current);\r\naudit_info.sessionid = audit_get_sessionid(current);\r\nsecurity_task_getsecid(current, &audit_info.secid);\r\nerr = xfrm_policy_flush(net, type, &audit_info);\r\nif (err) {\r\nif (err == -ESRCH)\r\nreturn 0;\r\nreturn err;\r\n}\r\nc.data.type = type;\r\nc.event = nlh->nlmsg_type;\r\nc.seq = nlh->nlmsg_seq;\r\nc.portid = nlh->nlmsg_pid;\r\nc.net = net;\r\nkm_policy_notify(NULL, 0, &c);\r\nreturn 0;\r\n}\r\nstatic int xfrm_add_pol_expire(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct xfrm_policy *xp;\r\nstruct xfrm_user_polexpire *up = nlmsg_data(nlh);\r\nstruct xfrm_userpolicy_info *p = &up->pol;\r\nu8 type = XFRM_POLICY_TYPE_MAIN;\r\nint err = -ENOENT;\r\nstruct xfrm_mark m;\r\nu32 mark = xfrm_mark_get(attrs, &m);\r\nerr = copy_from_user_policy_type(&type, attrs);\r\nif (err)\r\nreturn err;\r\nerr = verify_policy_dir(p->dir);\r\nif (err)\r\nreturn err;\r\nif (p->index)\r\nxp = xfrm_policy_byid(net, mark, type, p->dir, p->index, 0, &err);\r\nelse {\r\nstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\r\nstruct xfrm_sec_ctx *ctx;\r\nerr = verify_sec_ctx_len(attrs);\r\nif (err)\r\nreturn err;\r\nctx = NULL;\r\nif (rt) {\r\nstruct xfrm_user_sec_ctx *uctx = nla_data(rt);\r\nerr = security_xfrm_policy_alloc(&ctx, uctx);\r\nif (err)\r\nreturn err;\r\n}\r\nxp = xfrm_policy_bysel_ctx(net, mark, type, p->dir,\r\n&p->sel, ctx, 0, &err);\r\nsecurity_xfrm_policy_free(ctx);\r\n}\r\nif (xp == NULL)\r\nreturn -ENOENT;\r\nif (unlikely(xp->walk.dead))\r\ngoto out;\r\nerr = 0;\r\nif (up->hard) {\r\nkuid_t loginuid = audit_get_loginuid(current);\r\nu32 sessionid = audit_get_sessionid(current);\r\nu32 sid;\r\nsecurity_task_getsecid(current, &sid);\r\nxfrm_policy_delete(xp, p->dir);\r\nxfrm_audit_policy_delete(xp, 1, loginuid, sessionid, sid);\r\n} else {\r\nWARN(1, "Dont know what to do with soft policy expire\n");\r\n}\r\nkm_policy_expired(xp, p->dir, up->hard, nlh->nlmsg_pid);\r\nout:\r\nxfrm_pol_put(xp);\r\nreturn err;\r\n}\r\nstatic int xfrm_add_sa_expire(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct xfrm_state *x;\r\nint err;\r\nstruct xfrm_user_expire *ue = nlmsg_data(nlh);\r\nstruct xfrm_usersa_info *p = &ue->state;\r\nstruct xfrm_mark m;\r\nu32 mark = xfrm_mark_get(attrs, &m);\r\nx = xfrm_state_lookup(net, mark, &p->id.daddr, p->id.spi, p->id.proto, p->family);\r\nerr = -ENOENT;\r\nif (x == NULL)\r\nreturn err;\r\nspin_lock_bh(&x->lock);\r\nerr = -EINVAL;\r\nif (x->km.state != XFRM_STATE_VALID)\r\ngoto out;\r\nkm_state_expired(x, ue->hard, nlh->nlmsg_pid);\r\nif (ue->hard) {\r\nkuid_t loginuid = audit_get_loginuid(current);\r\nu32 sessionid = audit_get_sessionid(current);\r\nu32 sid;\r\nsecurity_task_getsecid(current, &sid);\r\n__xfrm_state_delete(x);\r\nxfrm_audit_state_delete(x, 1, loginuid, sessionid, sid);\r\n}\r\nerr = 0;\r\nout:\r\nspin_unlock_bh(&x->lock);\r\nxfrm_state_put(x);\r\nreturn err;\r\n}\r\nstatic int xfrm_add_acquire(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct xfrm_policy *xp;\r\nstruct xfrm_user_tmpl *ut;\r\nint i;\r\nstruct nlattr *rt = attrs[XFRMA_TMPL];\r\nstruct xfrm_mark mark;\r\nstruct xfrm_user_acquire *ua = nlmsg_data(nlh);\r\nstruct xfrm_state *x = xfrm_state_alloc(net);\r\nint err = -ENOMEM;\r\nif (!x)\r\ngoto nomem;\r\nxfrm_mark_get(attrs, &mark);\r\nerr = verify_newpolicy_info(&ua->policy);\r\nif (err)\r\ngoto bad_policy;\r\nxp = xfrm_policy_construct(net, &ua->policy, attrs, &err);\r\nif (!xp)\r\ngoto free_state;\r\nmemcpy(&x->id, &ua->id, sizeof(ua->id));\r\nmemcpy(&x->props.saddr, &ua->saddr, sizeof(ua->saddr));\r\nmemcpy(&x->sel, &ua->sel, sizeof(ua->sel));\r\nxp->mark.m = x->mark.m = mark.m;\r\nxp->mark.v = x->mark.v = mark.v;\r\nut = nla_data(rt);\r\nfor (i = 0; i < xp->xfrm_nr; i++, ut++) {\r\nstruct xfrm_tmpl *t = &xp->xfrm_vec[i];\r\nmemcpy(&x->id, &t->id, sizeof(x->id));\r\nx->props.mode = t->mode;\r\nx->props.reqid = t->reqid;\r\nx->props.family = ut->family;\r\nt->aalgos = ua->aalgos;\r\nt->ealgos = ua->ealgos;\r\nt->calgos = ua->calgos;\r\nerr = km_query(x, t, xp);\r\n}\r\nkfree(x);\r\nkfree(xp);\r\nreturn 0;\r\nbad_policy:\r\nWARN(1, "BAD policy passed\n");\r\nfree_state:\r\nkfree(x);\r\nnomem:\r\nreturn err;\r\n}\r\nstatic int copy_from_user_migrate(struct xfrm_migrate *ma,\r\nstruct xfrm_kmaddress *k,\r\nstruct nlattr **attrs, int *num)\r\n{\r\nstruct nlattr *rt = attrs[XFRMA_MIGRATE];\r\nstruct xfrm_user_migrate *um;\r\nint i, num_migrate;\r\nif (k != NULL) {\r\nstruct xfrm_user_kmaddress *uk;\r\nuk = nla_data(attrs[XFRMA_KMADDRESS]);\r\nmemcpy(&k->local, &uk->local, sizeof(k->local));\r\nmemcpy(&k->remote, &uk->remote, sizeof(k->remote));\r\nk->family = uk->family;\r\nk->reserved = uk->reserved;\r\n}\r\num = nla_data(rt);\r\nnum_migrate = nla_len(rt) / sizeof(*um);\r\nif (num_migrate <= 0 || num_migrate > XFRM_MAX_DEPTH)\r\nreturn -EINVAL;\r\nfor (i = 0; i < num_migrate; i++, um++, ma++) {\r\nmemcpy(&ma->old_daddr, &um->old_daddr, sizeof(ma->old_daddr));\r\nmemcpy(&ma->old_saddr, &um->old_saddr, sizeof(ma->old_saddr));\r\nmemcpy(&ma->new_daddr, &um->new_daddr, sizeof(ma->new_daddr));\r\nmemcpy(&ma->new_saddr, &um->new_saddr, sizeof(ma->new_saddr));\r\nma->proto = um->proto;\r\nma->mode = um->mode;\r\nma->reqid = um->reqid;\r\nma->old_family = um->old_family;\r\nma->new_family = um->new_family;\r\n}\r\n*num = i;\r\nreturn 0;\r\n}\r\nstatic int xfrm_do_migrate(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nstruct xfrm_userpolicy_id *pi = nlmsg_data(nlh);\r\nstruct xfrm_migrate m[XFRM_MAX_DEPTH];\r\nstruct xfrm_kmaddress km, *kmp;\r\nu8 type;\r\nint err;\r\nint n = 0;\r\nif (attrs[XFRMA_MIGRATE] == NULL)\r\nreturn -EINVAL;\r\nkmp = attrs[XFRMA_KMADDRESS] ? &km : NULL;\r\nerr = copy_from_user_policy_type(&type, attrs);\r\nif (err)\r\nreturn err;\r\nerr = copy_from_user_migrate((struct xfrm_migrate *)m, kmp, attrs, &n);\r\nif (err)\r\nreturn err;\r\nif (!n)\r\nreturn 0;\r\nxfrm_migrate(&pi->sel, pi->dir, type, m, n, kmp);\r\nreturn 0;\r\n}\r\nstatic int xfrm_do_migrate(struct sk_buff *skb, struct nlmsghdr *nlh,\r\nstruct nlattr **attrs)\r\n{\r\nreturn -ENOPROTOOPT;\r\n}\r\nstatic int copy_to_user_migrate(const struct xfrm_migrate *m, struct sk_buff *skb)\r\n{\r\nstruct xfrm_user_migrate um;\r\nmemset(&um, 0, sizeof(um));\r\num.proto = m->proto;\r\num.mode = m->mode;\r\num.reqid = m->reqid;\r\num.old_family = m->old_family;\r\nmemcpy(&um.old_daddr, &m->old_daddr, sizeof(um.old_daddr));\r\nmemcpy(&um.old_saddr, &m->old_saddr, sizeof(um.old_saddr));\r\num.new_family = m->new_family;\r\nmemcpy(&um.new_daddr, &m->new_daddr, sizeof(um.new_daddr));\r\nmemcpy(&um.new_saddr, &m->new_saddr, sizeof(um.new_saddr));\r\nreturn nla_put(skb, XFRMA_MIGRATE, sizeof(um), &um);\r\n}\r\nstatic int copy_to_user_kmaddress(const struct xfrm_kmaddress *k, struct sk_buff *skb)\r\n{\r\nstruct xfrm_user_kmaddress uk;\r\nmemset(&uk, 0, sizeof(uk));\r\nuk.family = k->family;\r\nuk.reserved = k->reserved;\r\nmemcpy(&uk.local, &k->local, sizeof(uk.local));\r\nmemcpy(&uk.remote, &k->remote, sizeof(uk.remote));\r\nreturn nla_put(skb, XFRMA_KMADDRESS, sizeof(uk), &uk);\r\n}\r\nstatic inline size_t xfrm_migrate_msgsize(int num_migrate, int with_kma)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct xfrm_userpolicy_id))\r\n+ (with_kma ? nla_total_size(sizeof(struct xfrm_kmaddress)) : 0)\r\n+ nla_total_size(sizeof(struct xfrm_user_migrate) * num_migrate)\r\n+ userpolicy_type_attrsize();\r\n}\r\nstatic int build_migrate(struct sk_buff *skb, const struct xfrm_migrate *m,\r\nint num_migrate, const struct xfrm_kmaddress *k,\r\nconst struct xfrm_selector *sel, u8 dir, u8 type)\r\n{\r\nconst struct xfrm_migrate *mp;\r\nstruct xfrm_userpolicy_id *pol_id;\r\nstruct nlmsghdr *nlh;\r\nint i, err;\r\nnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_MIGRATE, sizeof(*pol_id), 0);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\npol_id = nlmsg_data(nlh);\r\nmemset(pol_id, 0, sizeof(*pol_id));\r\nmemcpy(&pol_id->sel, sel, sizeof(pol_id->sel));\r\npol_id->dir = dir;\r\nif (k != NULL) {\r\nerr = copy_to_user_kmaddress(k, skb);\r\nif (err)\r\ngoto out_cancel;\r\n}\r\nerr = copy_to_user_policy_type(type, skb);\r\nif (err)\r\ngoto out_cancel;\r\nfor (i = 0, mp = m ; i < num_migrate; i++, mp++) {\r\nerr = copy_to_user_migrate(mp, skb);\r\nif (err)\r\ngoto out_cancel;\r\n}\r\nreturn nlmsg_end(skb, nlh);\r\nout_cancel:\r\nnlmsg_cancel(skb, nlh);\r\nreturn err;\r\n}\r\nstatic int xfrm_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\r\nconst struct xfrm_migrate *m, int num_migrate,\r\nconst struct xfrm_kmaddress *k)\r\n{\r\nstruct net *net = &init_net;\r\nstruct sk_buff *skb;\r\nskb = nlmsg_new(xfrm_migrate_msgsize(num_migrate, !!k), GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nif (build_migrate(skb, m, num_migrate, k, sel, dir, type) < 0)\r\nBUG();\r\nreturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_MIGRATE, GFP_ATOMIC);\r\n}\r\nstatic int xfrm_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\r\nconst struct xfrm_migrate *m, int num_migrate,\r\nconst struct xfrm_kmaddress *k)\r\n{\r\nreturn -ENOPROTOOPT;\r\n}\r\nstatic int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct nlattr *attrs[XFRMA_MAX+1];\r\nconst struct xfrm_link *link;\r\nint type, err;\r\ntype = nlh->nlmsg_type;\r\nif (type > XFRM_MSG_MAX)\r\nreturn -EINVAL;\r\ntype -= XFRM_MSG_BASE;\r\nlink = &xfrm_dispatch[type];\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\r\ntype == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\r\n(nlh->nlmsg_flags & NLM_F_DUMP)) {\r\nif (link->dump == NULL)\r\nreturn -EINVAL;\r\n{\r\nstruct netlink_dump_control c = {\r\n.dump = link->dump,\r\n.done = link->done,\r\n};\r\nreturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\r\n}\r\n}\r\nerr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs, XFRMA_MAX,\r\nxfrma_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (link->doit == NULL)\r\nreturn -EINVAL;\r\nreturn link->doit(skb, nlh, attrs);\r\n}\r\nstatic void xfrm_netlink_rcv(struct sk_buff *skb)\r\n{\r\nmutex_lock(&xfrm_cfg_mutex);\r\nnetlink_rcv_skb(skb, &xfrm_user_rcv_msg);\r\nmutex_unlock(&xfrm_cfg_mutex);\r\n}\r\nstatic inline size_t xfrm_expire_msgsize(void)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct xfrm_user_expire))\r\n+ nla_total_size(sizeof(struct xfrm_mark));\r\n}\r\nstatic int build_expire(struct sk_buff *skb, struct xfrm_state *x, const struct km_event *c)\r\n{\r\nstruct xfrm_user_expire *ue;\r\nstruct nlmsghdr *nlh;\r\nint err;\r\nnlh = nlmsg_put(skb, c->portid, 0, XFRM_MSG_EXPIRE, sizeof(*ue), 0);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nue = nlmsg_data(nlh);\r\ncopy_to_user_state(x, &ue->state);\r\nue->hard = (c->data.hard != 0) ? 1 : 0;\r\nerr = xfrm_mark_put(skb, &x->mark);\r\nif (err)\r\nreturn err;\r\nreturn nlmsg_end(skb, nlh);\r\n}\r\nstatic int xfrm_exp_state_notify(struct xfrm_state *x, const struct km_event *c)\r\n{\r\nstruct net *net = xs_net(x);\r\nstruct sk_buff *skb;\r\nskb = nlmsg_new(xfrm_expire_msgsize(), GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nif (build_expire(skb, x, c) < 0) {\r\nkfree_skb(skb);\r\nreturn -EMSGSIZE;\r\n}\r\nreturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_EXPIRE, GFP_ATOMIC);\r\n}\r\nstatic int xfrm_aevent_state_notify(struct xfrm_state *x, const struct km_event *c)\r\n{\r\nstruct net *net = xs_net(x);\r\nstruct sk_buff *skb;\r\nskb = nlmsg_new(xfrm_aevent_msgsize(x), GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nif (build_aevent(skb, x, c) < 0)\r\nBUG();\r\nreturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_AEVENTS, GFP_ATOMIC);\r\n}\r\nstatic int xfrm_notify_sa_flush(const struct km_event *c)\r\n{\r\nstruct net *net = c->net;\r\nstruct xfrm_usersa_flush *p;\r\nstruct nlmsghdr *nlh;\r\nstruct sk_buff *skb;\r\nint len = NLMSG_ALIGN(sizeof(struct xfrm_usersa_flush));\r\nskb = nlmsg_new(len, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nnlh = nlmsg_put(skb, c->portid, c->seq, XFRM_MSG_FLUSHSA, sizeof(*p), 0);\r\nif (nlh == NULL) {\r\nkfree_skb(skb);\r\nreturn -EMSGSIZE;\r\n}\r\np = nlmsg_data(nlh);\r\np->proto = c->data.proto;\r\nnlmsg_end(skb, nlh);\r\nreturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_SA, GFP_ATOMIC);\r\n}\r\nstatic inline size_t xfrm_sa_len(struct xfrm_state *x)\r\n{\r\nsize_t l = 0;\r\nif (x->aead)\r\nl += nla_total_size(aead_len(x->aead));\r\nif (x->aalg) {\r\nl += nla_total_size(sizeof(struct xfrm_algo) +\r\n(x->aalg->alg_key_len + 7) / 8);\r\nl += nla_total_size(xfrm_alg_auth_len(x->aalg));\r\n}\r\nif (x->ealg)\r\nl += nla_total_size(xfrm_alg_len(x->ealg));\r\nif (x->calg)\r\nl += nla_total_size(sizeof(*x->calg));\r\nif (x->encap)\r\nl += nla_total_size(sizeof(*x->encap));\r\nif (x->tfcpad)\r\nl += nla_total_size(sizeof(x->tfcpad));\r\nif (x->replay_esn)\r\nl += nla_total_size(xfrm_replay_state_esn_len(x->replay_esn));\r\nif (x->security)\r\nl += nla_total_size(sizeof(struct xfrm_user_sec_ctx) +\r\nx->security->ctx_len);\r\nif (x->coaddr)\r\nl += nla_total_size(sizeof(*x->coaddr));\r\nif (x->props.extra_flags)\r\nl += nla_total_size(sizeof(x->props.extra_flags));\r\nl += nla_total_size(sizeof(u64));\r\nreturn l;\r\n}\r\nstatic int xfrm_notify_sa(struct xfrm_state *x, const struct km_event *c)\r\n{\r\nstruct net *net = xs_net(x);\r\nstruct xfrm_usersa_info *p;\r\nstruct xfrm_usersa_id *id;\r\nstruct nlmsghdr *nlh;\r\nstruct sk_buff *skb;\r\nint len = xfrm_sa_len(x);\r\nint headlen, err;\r\nheadlen = sizeof(*p);\r\nif (c->event == XFRM_MSG_DELSA) {\r\nlen += nla_total_size(headlen);\r\nheadlen = sizeof(*id);\r\nlen += nla_total_size(sizeof(struct xfrm_mark));\r\n}\r\nlen += NLMSG_ALIGN(headlen);\r\nskb = nlmsg_new(len, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nnlh = nlmsg_put(skb, c->portid, c->seq, c->event, headlen, 0);\r\nerr = -EMSGSIZE;\r\nif (nlh == NULL)\r\ngoto out_free_skb;\r\np = nlmsg_data(nlh);\r\nif (c->event == XFRM_MSG_DELSA) {\r\nstruct nlattr *attr;\r\nid = nlmsg_data(nlh);\r\nmemcpy(&id->daddr, &x->id.daddr, sizeof(id->daddr));\r\nid->spi = x->id.spi;\r\nid->family = x->props.family;\r\nid->proto = x->id.proto;\r\nattr = nla_reserve(skb, XFRMA_SA, sizeof(*p));\r\nerr = -EMSGSIZE;\r\nif (attr == NULL)\r\ngoto out_free_skb;\r\np = nla_data(attr);\r\n}\r\nerr = copy_to_user_state_extra(x, p, skb);\r\nif (err)\r\ngoto out_free_skb;\r\nnlmsg_end(skb, nlh);\r\nreturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_SA, GFP_ATOMIC);\r\nout_free_skb:\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic int xfrm_send_state_notify(struct xfrm_state *x, const struct km_event *c)\r\n{\r\nswitch (c->event) {\r\ncase XFRM_MSG_EXPIRE:\r\nreturn xfrm_exp_state_notify(x, c);\r\ncase XFRM_MSG_NEWAE:\r\nreturn xfrm_aevent_state_notify(x, c);\r\ncase XFRM_MSG_DELSA:\r\ncase XFRM_MSG_UPDSA:\r\ncase XFRM_MSG_NEWSA:\r\nreturn xfrm_notify_sa(x, c);\r\ncase XFRM_MSG_FLUSHSA:\r\nreturn xfrm_notify_sa_flush(c);\r\ndefault:\r\nprintk(KERN_NOTICE "xfrm_user: Unknown SA event %d\n",\r\nc->event);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline size_t xfrm_acquire_msgsize(struct xfrm_state *x,\r\nstruct xfrm_policy *xp)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct xfrm_user_acquire))\r\n+ nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr)\r\n+ nla_total_size(sizeof(struct xfrm_mark))\r\n+ nla_total_size(xfrm_user_sec_ctx_size(x->security))\r\n+ userpolicy_type_attrsize();\r\n}\r\nstatic int build_acquire(struct sk_buff *skb, struct xfrm_state *x,\r\nstruct xfrm_tmpl *xt, struct xfrm_policy *xp)\r\n{\r\n__u32 seq = xfrm_get_acqseq();\r\nstruct xfrm_user_acquire *ua;\r\nstruct nlmsghdr *nlh;\r\nint err;\r\nnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_ACQUIRE, sizeof(*ua), 0);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nua = nlmsg_data(nlh);\r\nmemcpy(&ua->id, &x->id, sizeof(ua->id));\r\nmemcpy(&ua->saddr, &x->props.saddr, sizeof(ua->saddr));\r\nmemcpy(&ua->sel, &x->sel, sizeof(ua->sel));\r\ncopy_to_user_policy(xp, &ua->policy, XFRM_POLICY_OUT);\r\nua->aalgos = xt->aalgos;\r\nua->ealgos = xt->ealgos;\r\nua->calgos = xt->calgos;\r\nua->seq = x->km.seq = seq;\r\nerr = copy_to_user_tmpl(xp, skb);\r\nif (!err)\r\nerr = copy_to_user_state_sec_ctx(x, skb);\r\nif (!err)\r\nerr = copy_to_user_policy_type(xp->type, skb);\r\nif (!err)\r\nerr = xfrm_mark_put(skb, &xp->mark);\r\nif (err) {\r\nnlmsg_cancel(skb, nlh);\r\nreturn err;\r\n}\r\nreturn nlmsg_end(skb, nlh);\r\n}\r\nstatic int xfrm_send_acquire(struct xfrm_state *x, struct xfrm_tmpl *xt,\r\nstruct xfrm_policy *xp)\r\n{\r\nstruct net *net = xs_net(x);\r\nstruct sk_buff *skb;\r\nskb = nlmsg_new(xfrm_acquire_msgsize(x, xp), GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nif (build_acquire(skb, x, xt, xp) < 0)\r\nBUG();\r\nreturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_ACQUIRE, GFP_ATOMIC);\r\n}\r\nstatic struct xfrm_policy *xfrm_compile_policy(struct sock *sk, int opt,\r\nu8 *data, int len, int *dir)\r\n{\r\nstruct net *net = sock_net(sk);\r\nstruct xfrm_userpolicy_info *p = (struct xfrm_userpolicy_info *)data;\r\nstruct xfrm_user_tmpl *ut = (struct xfrm_user_tmpl *) (p + 1);\r\nstruct xfrm_policy *xp;\r\nint nr;\r\nswitch (sk->sk_family) {\r\ncase AF_INET:\r\nif (opt != IP_XFRM_POLICY) {\r\n*dir = -EOPNOTSUPP;\r\nreturn NULL;\r\n}\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase AF_INET6:\r\nif (opt != IPV6_XFRM_POLICY) {\r\n*dir = -EOPNOTSUPP;\r\nreturn NULL;\r\n}\r\nbreak;\r\n#endif\r\ndefault:\r\n*dir = -EINVAL;\r\nreturn NULL;\r\n}\r\n*dir = -EINVAL;\r\nif (len < sizeof(*p) ||\r\nverify_newpolicy_info(p))\r\nreturn NULL;\r\nnr = ((len - sizeof(*p)) / sizeof(*ut));\r\nif (validate_tmpl(nr, ut, p->sel.family))\r\nreturn NULL;\r\nif (p->dir > XFRM_POLICY_OUT)\r\nreturn NULL;\r\nxp = xfrm_policy_alloc(net, GFP_ATOMIC);\r\nif (xp == NULL) {\r\n*dir = -ENOBUFS;\r\nreturn NULL;\r\n}\r\ncopy_from_user_policy(xp, p);\r\nxp->type = XFRM_POLICY_TYPE_MAIN;\r\ncopy_templates(xp, ut, nr);\r\n*dir = p->dir;\r\nreturn xp;\r\n}\r\nstatic inline size_t xfrm_polexpire_msgsize(struct xfrm_policy *xp)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct xfrm_user_polexpire))\r\n+ nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr)\r\n+ nla_total_size(xfrm_user_sec_ctx_size(xp->security))\r\n+ nla_total_size(sizeof(struct xfrm_mark))\r\n+ userpolicy_type_attrsize();\r\n}\r\nstatic int build_polexpire(struct sk_buff *skb, struct xfrm_policy *xp,\r\nint dir, const struct km_event *c)\r\n{\r\nstruct xfrm_user_polexpire *upe;\r\nint hard = c->data.hard;\r\nstruct nlmsghdr *nlh;\r\nint err;\r\nnlh = nlmsg_put(skb, c->portid, 0, XFRM_MSG_POLEXPIRE, sizeof(*upe), 0);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nupe = nlmsg_data(nlh);\r\ncopy_to_user_policy(xp, &upe->pol, dir);\r\nerr = copy_to_user_tmpl(xp, skb);\r\nif (!err)\r\nerr = copy_to_user_sec_ctx(xp, skb);\r\nif (!err)\r\nerr = copy_to_user_policy_type(xp->type, skb);\r\nif (!err)\r\nerr = xfrm_mark_put(skb, &xp->mark);\r\nif (err) {\r\nnlmsg_cancel(skb, nlh);\r\nreturn err;\r\n}\r\nupe->hard = !!hard;\r\nreturn nlmsg_end(skb, nlh);\r\n}\r\nstatic int xfrm_exp_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\r\n{\r\nstruct net *net = xp_net(xp);\r\nstruct sk_buff *skb;\r\nskb = nlmsg_new(xfrm_polexpire_msgsize(xp), GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nif (build_polexpire(skb, xp, dir, c) < 0)\r\nBUG();\r\nreturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_EXPIRE, GFP_ATOMIC);\r\n}\r\nstatic int xfrm_notify_policy(struct xfrm_policy *xp, int dir, const struct km_event *c)\r\n{\r\nint len = nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr);\r\nstruct net *net = xp_net(xp);\r\nstruct xfrm_userpolicy_info *p;\r\nstruct xfrm_userpolicy_id *id;\r\nstruct nlmsghdr *nlh;\r\nstruct sk_buff *skb;\r\nint headlen, err;\r\nheadlen = sizeof(*p);\r\nif (c->event == XFRM_MSG_DELPOLICY) {\r\nlen += nla_total_size(headlen);\r\nheadlen = sizeof(*id);\r\n}\r\nlen += userpolicy_type_attrsize();\r\nlen += nla_total_size(sizeof(struct xfrm_mark));\r\nlen += NLMSG_ALIGN(headlen);\r\nskb = nlmsg_new(len, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nnlh = nlmsg_put(skb, c->portid, c->seq, c->event, headlen, 0);\r\nerr = -EMSGSIZE;\r\nif (nlh == NULL)\r\ngoto out_free_skb;\r\np = nlmsg_data(nlh);\r\nif (c->event == XFRM_MSG_DELPOLICY) {\r\nstruct nlattr *attr;\r\nid = nlmsg_data(nlh);\r\nmemset(id, 0, sizeof(*id));\r\nid->dir = dir;\r\nif (c->data.byid)\r\nid->index = xp->index;\r\nelse\r\nmemcpy(&id->sel, &xp->selector, sizeof(id->sel));\r\nattr = nla_reserve(skb, XFRMA_POLICY, sizeof(*p));\r\nerr = -EMSGSIZE;\r\nif (attr == NULL)\r\ngoto out_free_skb;\r\np = nla_data(attr);\r\n}\r\ncopy_to_user_policy(xp, p, dir);\r\nerr = copy_to_user_tmpl(xp, skb);\r\nif (!err)\r\nerr = copy_to_user_policy_type(xp->type, skb);\r\nif (!err)\r\nerr = xfrm_mark_put(skb, &xp->mark);\r\nif (err)\r\ngoto out_free_skb;\r\nnlmsg_end(skb, nlh);\r\nreturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_POLICY, GFP_ATOMIC);\r\nout_free_skb:\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic int xfrm_notify_policy_flush(const struct km_event *c)\r\n{\r\nstruct net *net = c->net;\r\nstruct nlmsghdr *nlh;\r\nstruct sk_buff *skb;\r\nint err;\r\nskb = nlmsg_new(userpolicy_type_attrsize(), GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nnlh = nlmsg_put(skb, c->portid, c->seq, XFRM_MSG_FLUSHPOLICY, 0, 0);\r\nerr = -EMSGSIZE;\r\nif (nlh == NULL)\r\ngoto out_free_skb;\r\nerr = copy_to_user_policy_type(c->data.type, skb);\r\nif (err)\r\ngoto out_free_skb;\r\nnlmsg_end(skb, nlh);\r\nreturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_POLICY, GFP_ATOMIC);\r\nout_free_skb:\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic int xfrm_send_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\r\n{\r\nswitch (c->event) {\r\ncase XFRM_MSG_NEWPOLICY:\r\ncase XFRM_MSG_UPDPOLICY:\r\ncase XFRM_MSG_DELPOLICY:\r\nreturn xfrm_notify_policy(xp, dir, c);\r\ncase XFRM_MSG_FLUSHPOLICY:\r\nreturn xfrm_notify_policy_flush(c);\r\ncase XFRM_MSG_POLEXPIRE:\r\nreturn xfrm_exp_policy_notify(xp, dir, c);\r\ndefault:\r\nprintk(KERN_NOTICE "xfrm_user: Unknown Policy event %d\n",\r\nc->event);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline size_t xfrm_report_msgsize(void)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct xfrm_user_report));\r\n}\r\nstatic int build_report(struct sk_buff *skb, u8 proto,\r\nstruct xfrm_selector *sel, xfrm_address_t *addr)\r\n{\r\nstruct xfrm_user_report *ur;\r\nstruct nlmsghdr *nlh;\r\nnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_REPORT, sizeof(*ur), 0);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nur = nlmsg_data(nlh);\r\nur->proto = proto;\r\nmemcpy(&ur->sel, sel, sizeof(ur->sel));\r\nif (addr) {\r\nint err = nla_put(skb, XFRMA_COADDR, sizeof(*addr), addr);\r\nif (err) {\r\nnlmsg_cancel(skb, nlh);\r\nreturn err;\r\n}\r\n}\r\nreturn nlmsg_end(skb, nlh);\r\n}\r\nstatic int xfrm_send_report(struct net *net, u8 proto,\r\nstruct xfrm_selector *sel, xfrm_address_t *addr)\r\n{\r\nstruct sk_buff *skb;\r\nskb = nlmsg_new(xfrm_report_msgsize(), GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nif (build_report(skb, proto, sel, addr) < 0)\r\nBUG();\r\nreturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_REPORT, GFP_ATOMIC);\r\n}\r\nstatic inline size_t xfrm_mapping_msgsize(void)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct xfrm_user_mapping));\r\n}\r\nstatic int build_mapping(struct sk_buff *skb, struct xfrm_state *x,\r\nxfrm_address_t *new_saddr, __be16 new_sport)\r\n{\r\nstruct xfrm_user_mapping *um;\r\nstruct nlmsghdr *nlh;\r\nnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_MAPPING, sizeof(*um), 0);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\num = nlmsg_data(nlh);\r\nmemcpy(&um->id.daddr, &x->id.daddr, sizeof(um->id.daddr));\r\num->id.spi = x->id.spi;\r\num->id.family = x->props.family;\r\num->id.proto = x->id.proto;\r\nmemcpy(&um->new_saddr, new_saddr, sizeof(um->new_saddr));\r\nmemcpy(&um->old_saddr, &x->props.saddr, sizeof(um->old_saddr));\r\num->new_sport = new_sport;\r\num->old_sport = x->encap->encap_sport;\r\num->reqid = x->props.reqid;\r\nreturn nlmsg_end(skb, nlh);\r\n}\r\nstatic int xfrm_send_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr,\r\n__be16 sport)\r\n{\r\nstruct net *net = xs_net(x);\r\nstruct sk_buff *skb;\r\nif (x->id.proto != IPPROTO_ESP)\r\nreturn -EINVAL;\r\nif (!x->encap)\r\nreturn -EINVAL;\r\nskb = nlmsg_new(xfrm_mapping_msgsize(), GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nif (build_mapping(skb, x, ipaddr, sport) < 0)\r\nBUG();\r\nreturn nlmsg_multicast(net->xfrm.nlsk, skb, 0, XFRMNLGRP_MAPPING, GFP_ATOMIC);\r\n}\r\nstatic int __net_init xfrm_user_net_init(struct net *net)\r\n{\r\nstruct sock *nlsk;\r\nstruct netlink_kernel_cfg cfg = {\r\n.groups = XFRMNLGRP_MAX,\r\n.input = xfrm_netlink_rcv,\r\n};\r\nnlsk = netlink_kernel_create(net, NETLINK_XFRM, &cfg);\r\nif (nlsk == NULL)\r\nreturn -ENOMEM;\r\nnet->xfrm.nlsk_stash = nlsk;\r\nrcu_assign_pointer(net->xfrm.nlsk, nlsk);\r\nreturn 0;\r\n}\r\nstatic void __net_exit xfrm_user_net_exit(struct list_head *net_exit_list)\r\n{\r\nstruct net *net;\r\nlist_for_each_entry(net, net_exit_list, exit_list)\r\nRCU_INIT_POINTER(net->xfrm.nlsk, NULL);\r\nsynchronize_net();\r\nlist_for_each_entry(net, net_exit_list, exit_list)\r\nnetlink_kernel_release(net->xfrm.nlsk_stash);\r\n}\r\nstatic int __init xfrm_user_init(void)\r\n{\r\nint rv;\r\nprintk(KERN_INFO "Initializing XFRM netlink socket\n");\r\nrv = register_pernet_subsys(&xfrm_user_net_ops);\r\nif (rv < 0)\r\nreturn rv;\r\nrv = xfrm_register_km(&netlink_mgr);\r\nif (rv < 0)\r\nunregister_pernet_subsys(&xfrm_user_net_ops);\r\nreturn rv;\r\n}\r\nstatic void __exit xfrm_user_exit(void)\r\n{\r\nxfrm_unregister_km(&netlink_mgr);\r\nunregister_pernet_subsys(&xfrm_user_net_ops);\r\n}
