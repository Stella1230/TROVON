static uint32_t almost_full_bits(unsigned int num_words)\r\n{\r\nreturn (num_words << 16) & 0xff0000;\r\n}\r\nstatic uint32_t almost_empty_bits(unsigned int num_words)\r\n{\r\nreturn num_words & 0xffff;\r\n}\r\nstatic uint32_t intr_bit(int interrupt_source)\r\n{\r\nreturn 0x1 << interrupt_source;\r\n}\r\nstatic unsigned int fifo_size(uint32_t fifo_size_bits)\r\n{\r\nreturn fifo_size_bits & 0xfffff;\r\n}\r\nstatic int dio_config_insn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nint ret;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_BLOCK_SIZE:\r\nreturn dio_config_block_size(dev, data);\r\ndefault:\r\nret = comedi_dio_insn_config(dev, s, insn, data, 0xffffffff);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic void disable_plx_interrupts(struct comedi_device *dev)\r\n{\r\nstruct hpdi_private *devpriv = dev->private;\r\nwritel(0, devpriv->plx9080_iobase + PLX_INTRCS_REG);\r\n}\r\nstatic void init_plx9080(struct comedi_device *dev)\r\n{\r\nstruct hpdi_private *devpriv = dev->private;\r\nuint32_t bits;\r\nvoid __iomem *plx_iobase = devpriv->plx9080_iobase;\r\nDEBUG_PRINT(" plx interrupt status 0x%x\n",\r\nreadl(plx_iobase + PLX_INTRCS_REG));\r\nDEBUG_PRINT(" plx id bits 0x%x\n", readl(plx_iobase + PLX_ID_REG));\r\nDEBUG_PRINT(" plx control reg 0x%x\n",\r\nreadl(devpriv->plx9080_iobase + PLX_CONTROL_REG));\r\nDEBUG_PRINT(" plx revision 0x%x\n",\r\nreadl(plx_iobase + PLX_REVISION_REG));\r\nDEBUG_PRINT(" plx dma channel 0 mode 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA0_MODE_REG));\r\nDEBUG_PRINT(" plx dma channel 1 mode 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA1_MODE_REG));\r\nDEBUG_PRINT(" plx dma channel 0 pci address 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA0_PCI_ADDRESS_REG));\r\nDEBUG_PRINT(" plx dma channel 0 local address 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA0_LOCAL_ADDRESS_REG));\r\nDEBUG_PRINT(" plx dma channel 0 transfer size 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA0_TRANSFER_SIZE_REG));\r\nDEBUG_PRINT(" plx dma channel 0 descriptor 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA0_DESCRIPTOR_REG));\r\nDEBUG_PRINT(" plx dma channel 0 command status 0x%x\n",\r\nreadb(plx_iobase + PLX_DMA0_CS_REG));\r\nDEBUG_PRINT(" plx dma channel 0 threshold 0x%x\n",\r\nreadl(plx_iobase + PLX_DMA0_THRESHOLD_REG));\r\nDEBUG_PRINT(" plx bigend 0x%x\n", readl(plx_iobase + PLX_BIGEND_REG));\r\n#ifdef __BIG_ENDIAN\r\nbits = BIGEND_DMA0 | BIGEND_DMA1;\r\n#else\r\nbits = 0;\r\n#endif\r\nwritel(bits, devpriv->plx9080_iobase + PLX_BIGEND_REG);\r\ndisable_plx_interrupts(dev);\r\nabort_dma(dev, 0);\r\nabort_dma(dev, 1);\r\nbits = 0;\r\nbits |= PLX_DMA_EN_READYIN_BIT;\r\nbits |= PLX_EN_CHAIN_BIT;\r\nbits |= PLX_EN_DMA_DONE_INTR_BIT;\r\nbits |= PLX_LOCAL_ADDR_CONST_BIT;\r\nbits |= PLX_DMA_INTR_PCI_BIT;\r\nbits |= PLX_DEMAND_MODE_BIT;\r\nbits |= PLX_DMA_LOCAL_BURST_EN_BIT;\r\nbits |= PLX_LOCAL_BUS_32_WIDE_BITS;\r\nwritel(bits, plx_iobase + PLX_DMA0_MODE_REG);\r\n}\r\nstatic int setup_subdevices(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nret = comedi_alloc_subdevices(dev, 1);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags =\r\nSDF_READABLE | SDF_WRITEABLE | SDF_LSAMPL | SDF_CMD_READ;\r\ns->n_chan = 32;\r\ns->len_chanlist = 32;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_config = dio_config_insn;\r\ns->do_cmd = hpdi_cmd;\r\ns->do_cmdtest = hpdi_cmd_test;\r\ns->cancel = hpdi_cancel;\r\nreturn 0;\r\n}\r\nstatic int init_hpdi(struct comedi_device *dev)\r\n{\r\nstruct hpdi_private *devpriv = dev->private;\r\nuint32_t plx_intcsr_bits;\r\nwritel(BOARD_RESET_BIT, devpriv->hpdi_iobase + BOARD_CONTROL_REG);\r\nudelay(10);\r\nwritel(almost_empty_bits(32) | almost_full_bits(32),\r\ndevpriv->hpdi_iobase + RX_PROG_ALMOST_REG);\r\nwritel(almost_empty_bits(32) | almost_full_bits(32),\r\ndevpriv->hpdi_iobase + TX_PROG_ALMOST_REG);\r\ndevpriv->tx_fifo_size = fifo_size(readl(devpriv->hpdi_iobase +\r\nTX_FIFO_SIZE_REG));\r\ndevpriv->rx_fifo_size = fifo_size(readl(devpriv->hpdi_iobase +\r\nRX_FIFO_SIZE_REG));\r\nwritel(0, devpriv->hpdi_iobase + INTERRUPT_CONTROL_REG);\r\nplx_intcsr_bits =\r\nICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |\r\nICS_DMA0_E;\r\nwritel(plx_intcsr_bits, devpriv->plx9080_iobase + PLX_INTRCS_REG);\r\nreturn 0;\r\n}\r\nstatic int setup_dma_descriptors(struct comedi_device *dev,\r\nunsigned int transfer_size)\r\n{\r\nstruct hpdi_private *devpriv = dev->private;\r\nunsigned int buffer_index, buffer_offset;\r\nuint32_t next_bits = PLX_DESC_IN_PCI_BIT | PLX_INTR_TERM_COUNT |\r\nPLX_XFER_LOCAL_TO_PCI;\r\nunsigned int i;\r\nif (transfer_size > DMA_BUFFER_SIZE)\r\ntransfer_size = DMA_BUFFER_SIZE;\r\ntransfer_size -= transfer_size % sizeof(uint32_t);\r\nif (transfer_size == 0)\r\nreturn -1;\r\nDEBUG_PRINT(" transfer_size %i\n", transfer_size);\r\nDEBUG_PRINT(" descriptors at 0x%lx\n",\r\n(unsigned long)devpriv->dma_desc_phys_addr);\r\nbuffer_offset = 0;\r\nbuffer_index = 0;\r\nfor (i = 0; i < NUM_DMA_DESCRIPTORS &&\r\nbuffer_index < NUM_DMA_BUFFERS; i++) {\r\ndevpriv->dma_desc[i].pci_start_addr =\r\ncpu_to_le32(devpriv->dio_buffer_phys_addr[buffer_index] +\r\nbuffer_offset);\r\ndevpriv->dma_desc[i].local_start_addr = cpu_to_le32(FIFO_REG);\r\ndevpriv->dma_desc[i].transfer_size =\r\ncpu_to_le32(transfer_size);\r\ndevpriv->dma_desc[i].next =\r\ncpu_to_le32((devpriv->dma_desc_phys_addr + (i +\r\n1) *\r\nsizeof(devpriv->dma_desc[0])) | next_bits);\r\ndevpriv->desc_dio_buffer[i] =\r\ndevpriv->dio_buffer[buffer_index] +\r\n(buffer_offset / sizeof(uint32_t));\r\nbuffer_offset += transfer_size;\r\nif (transfer_size + buffer_offset > DMA_BUFFER_SIZE) {\r\nbuffer_offset = 0;\r\nbuffer_index++;\r\n}\r\nDEBUG_PRINT(" desc %i\n", i);\r\nDEBUG_PRINT(" start addr virt 0x%p, phys 0x%lx\n",\r\ndevpriv->desc_dio_buffer[i],\r\n(unsigned long)devpriv->dma_desc[i].\r\npci_start_addr);\r\nDEBUG_PRINT(" next 0x%lx\n",\r\n(unsigned long)devpriv->dma_desc[i].next);\r\n}\r\ndevpriv->num_dma_descriptors = i;\r\ndevpriv->dma_desc[i - 1].next =\r\ncpu_to_le32(devpriv->dma_desc_phys_addr | next_bits);\r\nDEBUG_PRINT(" desc %i next fixup 0x%lx\n", i - 1,\r\n(unsigned long)devpriv->dma_desc[i - 1].next);\r\ndevpriv->block_size = transfer_size;\r\nreturn transfer_size;\r\n}\r\nstatic const struct hpdi_board *hpdi_find_board(struct pci_dev *pcidev)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(hpdi_boards); i++)\r\nif (pcidev->device == hpdi_boards[i].device_id &&\r\npcidev->subsystem_device == hpdi_boards[i].subdevice_id)\r\nreturn &hpdi_boards[i];\r\nreturn NULL;\r\n}\r\nstatic int hpdi_auto_attach(struct comedi_device *dev,\r\nunsigned long context_unused)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct hpdi_board *thisboard;\r\nstruct hpdi_private *devpriv;\r\nint i;\r\nint retval;\r\nthisboard = hpdi_find_board(pcidev);\r\nif (!thisboard) {\r\ndev_err(dev->class_dev, "gsc_hpdi: pci %s not supported\n",\r\npci_name(pcidev));\r\nreturn -EINVAL;\r\n}\r\ndev->board_ptr = thisboard;\r\ndev->board_name = thisboard->name;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nretval = comedi_pci_enable(dev);\r\nif (retval)\r\nreturn retval;\r\npci_set_master(pcidev);\r\ndevpriv->plx9080_iobase = pci_ioremap_bar(pcidev, 0);\r\ndevpriv->hpdi_iobase = pci_ioremap_bar(pcidev, 2);\r\nif (!devpriv->plx9080_iobase || !devpriv->hpdi_iobase) {\r\ndev_warn(dev->class_dev, "failed to remap io memory\n");\r\nreturn -ENOMEM;\r\n}\r\nDEBUG_PRINT(" plx9080 remapped to 0x%p\n", devpriv->plx9080_iobase);\r\nDEBUG_PRINT(" hpdi remapped to 0x%p\n", devpriv->hpdi_iobase);\r\ninit_plx9080(dev);\r\nif (request_irq(pcidev->irq, handle_interrupt, IRQF_SHARED,\r\ndev->board_name, dev)) {\r\ndev_warn(dev->class_dev,\r\n"unable to allocate irq %u\n", pcidev->irq);\r\nreturn -EINVAL;\r\n}\r\ndev->irq = pcidev->irq;\r\ndev_dbg(dev->class_dev, " irq %u\n", dev->irq);\r\nfor (i = 0; i < NUM_DMA_BUFFERS; i++) {\r\ndevpriv->dio_buffer[i] =\r\npci_alloc_consistent(pcidev, DMA_BUFFER_SIZE,\r\n&devpriv->dio_buffer_phys_addr[i]);\r\nDEBUG_PRINT("dio_buffer at virt 0x%p, phys 0x%lx\n",\r\ndevpriv->dio_buffer[i],\r\n(unsigned long)devpriv->dio_buffer_phys_addr[i]);\r\n}\r\ndevpriv->dma_desc = pci_alloc_consistent(pcidev,\r\nsizeof(struct plx_dma_desc) *\r\nNUM_DMA_DESCRIPTORS,\r\n&devpriv->dma_desc_phys_addr);\r\nif (devpriv->dma_desc_phys_addr & 0xf) {\r\ndev_warn(dev->class_dev,\r\n" dma descriptors not quad-word aligned (bug)\n");\r\nreturn -EIO;\r\n}\r\nretval = setup_dma_descriptors(dev, 0x1000);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = setup_subdevices(dev);\r\nif (retval < 0)\r\nreturn retval;\r\nreturn init_hpdi(dev);\r\n}\r\nstatic void hpdi_detach(struct comedi_device *dev)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nstruct hpdi_private *devpriv = dev->private;\r\nunsigned int i;\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (devpriv) {\r\nif (devpriv->plx9080_iobase) {\r\ndisable_plx_interrupts(dev);\r\niounmap(devpriv->plx9080_iobase);\r\n}\r\nif (devpriv->hpdi_iobase)\r\niounmap(devpriv->hpdi_iobase);\r\nfor (i = 0; i < NUM_DMA_BUFFERS; i++) {\r\nif (devpriv->dio_buffer[i])\r\npci_free_consistent(pcidev,\r\nDMA_BUFFER_SIZE,\r\ndevpriv->dio_buffer[i],\r\ndevpriv->\r\ndio_buffer_phys_addr[i]);\r\n}\r\nif (devpriv->dma_desc)\r\npci_free_consistent(pcidev,\r\nsizeof(struct plx_dma_desc) *\r\nNUM_DMA_DESCRIPTORS,\r\ndevpriv->dma_desc,\r\ndevpriv->dma_desc_phys_addr);\r\n}\r\ncomedi_pci_disable(dev);\r\n}\r\nstatic int dio_config_block_size(struct comedi_device *dev, unsigned int *data)\r\n{\r\nunsigned int requested_block_size;\r\nint retval;\r\nrequested_block_size = data[1];\r\nretval = setup_dma_descriptors(dev, requested_block_size);\r\nif (retval < 0)\r\nreturn retval;\r\ndata[1] = retval;\r\nreturn 2;\r\n}\r\nstatic int di_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint i;\r\nerr |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nerr |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_EXT);\r\nerr |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= cfc_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nif (!cmd->chanlist_len) {\r\ncmd->chanlist_len = 32;\r\nerr |= -EINVAL;\r\n}\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);\r\nswitch (cmd->stop_src) {\r\ncase TRIG_COUNT:\r\nerr |= cfc_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nbreak;\r\ncase TRIG_NONE:\r\nerr |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (err)\r\nreturn 3;\r\nif (err)\r\nreturn 4;\r\nif (!cmd->chanlist)\r\nreturn 0;\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nif (CR_CHAN(cmd->chanlist[i]) != i) {\r\ncomedi_error(dev,\r\n"chanlist must be ch 0 to 31 in order");\r\nerr++;\r\nbreak;\r\n}\r\n}\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int hpdi_cmd_test(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nif (s->io_bits)\r\nreturn -EINVAL;\r\nelse\r\nreturn di_cmd_test(dev, s, cmd);\r\n}\r\nstatic inline void hpdi_writel(struct comedi_device *dev, uint32_t bits,\r\nunsigned int offset)\r\n{\r\nstruct hpdi_private *devpriv = dev->private;\r\nwritel(bits | devpriv->bits[offset / sizeof(uint32_t)],\r\ndevpriv->hpdi_iobase + offset);\r\n}\r\nstatic int di_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct hpdi_private *devpriv = dev->private;\r\nuint32_t bits;\r\nunsigned long flags;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nhpdi_writel(dev, RX_FIFO_RESET_BIT, BOARD_CONTROL_REG);\r\nDEBUG_PRINT("hpdi: in di_cmd\n");\r\nabort_dma(dev, 0);\r\ndevpriv->dma_desc_index = 0;\r\nwritel(0, devpriv->plx9080_iobase + PLX_DMA0_TRANSFER_SIZE_REG);\r\nwritel(0, devpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG);\r\nwritel(0, devpriv->plx9080_iobase + PLX_DMA0_LOCAL_ADDRESS_REG);\r\nbits =\r\ndevpriv->dma_desc_phys_addr | PLX_DESC_IN_PCI_BIT |\r\nPLX_INTR_TERM_COUNT | PLX_XFER_LOCAL_TO_PCI;\r\nwritel(bits, devpriv->plx9080_iobase + PLX_DMA0_DESCRIPTOR_REG);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nwriteb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT | PLX_CLEAR_DMA_INTR_BIT,\r\ndevpriv->plx9080_iobase + PLX_DMA0_CS_REG);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif (cmd->stop_src == TRIG_COUNT)\r\ndevpriv->dio_count = cmd->stop_arg;\r\nelse\r\ndevpriv->dio_count = 1;\r\nwritel(RX_UNDERRUN_BIT | RX_OVERRUN_BIT,\r\ndevpriv->hpdi_iobase + BOARD_STATUS_REG);\r\nwritel(intr_bit(RX_FULL_INTR),\r\ndevpriv->hpdi_iobase + INTERRUPT_CONTROL_REG);\r\nDEBUG_PRINT("hpdi: starting rx\n");\r\nhpdi_writel(dev, RX_ENABLE_BIT, BOARD_CONTROL_REG);\r\nreturn 0;\r\n}\r\nstatic int hpdi_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nif (s->io_bits)\r\nreturn -EINVAL;\r\nelse\r\nreturn di_cmd(dev, s);\r\n}\r\nstatic void drain_dma_buffers(struct comedi_device *dev, unsigned int channel)\r\n{\r\nstruct hpdi_private *devpriv = dev->private;\r\nstruct comedi_async *async = dev->read_subdev->async;\r\nuint32_t next_transfer_addr;\r\nint j;\r\nint num_samples = 0;\r\nvoid __iomem *pci_addr_reg;\r\nif (channel)\r\npci_addr_reg =\r\ndevpriv->plx9080_iobase + PLX_DMA1_PCI_ADDRESS_REG;\r\nelse\r\npci_addr_reg =\r\ndevpriv->plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;\r\nj = 0;\r\nfor (next_transfer_addr = readl(pci_addr_reg);\r\n(next_transfer_addr <\r\nle32_to_cpu(devpriv->dma_desc[devpriv->dma_desc_index].\r\npci_start_addr)\r\n|| next_transfer_addr >=\r\nle32_to_cpu(devpriv->dma_desc[devpriv->dma_desc_index].\r\npci_start_addr) + devpriv->block_size)\r\n&& j < devpriv->num_dma_descriptors; j++) {\r\nnum_samples = devpriv->block_size / sizeof(uint32_t);\r\nif (async->cmd.stop_src == TRIG_COUNT) {\r\nif (num_samples > devpriv->dio_count)\r\nnum_samples = devpriv->dio_count;\r\ndevpriv->dio_count -= num_samples;\r\n}\r\ncfc_write_array_to_buffer(dev->read_subdev,\r\ndevpriv->desc_dio_buffer[devpriv->\r\ndma_desc_index],\r\nnum_samples * sizeof(uint32_t));\r\ndevpriv->dma_desc_index++;\r\ndevpriv->dma_desc_index %= devpriv->num_dma_descriptors;\r\nDEBUG_PRINT("next desc addr 0x%lx\n", (unsigned long)\r\ndevpriv->dma_desc[devpriv->dma_desc_index].\r\nnext);\r\nDEBUG_PRINT("pci addr reg 0x%x\n", next_transfer_addr);\r\n}\r\n}\r\nstatic irqreturn_t handle_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct hpdi_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct comedi_async *async = s->async;\r\nuint32_t hpdi_intr_status, hpdi_board_status;\r\nuint32_t plx_status;\r\nuint32_t plx_bits;\r\nuint8_t dma0_status, dma1_status;\r\nunsigned long flags;\r\nif (!dev->attached)\r\nreturn IRQ_NONE;\r\nplx_status = readl(devpriv->plx9080_iobase + PLX_INTRCS_REG);\r\nif ((plx_status & (ICS_DMA0_A | ICS_DMA1_A | ICS_LIA)) == 0)\r\nreturn IRQ_NONE;\r\nhpdi_intr_status = readl(devpriv->hpdi_iobase + INTERRUPT_STATUS_REG);\r\nhpdi_board_status = readl(devpriv->hpdi_iobase + BOARD_STATUS_REG);\r\nasync->events = 0;\r\nif (hpdi_intr_status) {\r\nDEBUG_PRINT("hpdi: intr status 0x%x, ", hpdi_intr_status);\r\nwritel(hpdi_intr_status,\r\ndevpriv->hpdi_iobase + INTERRUPT_STATUS_REG);\r\n}\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndma0_status = readb(devpriv->plx9080_iobase + PLX_DMA0_CS_REG);\r\nif (plx_status & ICS_DMA0_A) {\r\nwriteb((dma0_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,\r\ndevpriv->plx9080_iobase + PLX_DMA0_CS_REG);\r\nDEBUG_PRINT("dma0 status 0x%x\n", dma0_status);\r\nif (dma0_status & PLX_DMA_EN_BIT)\r\ndrain_dma_buffers(dev, 0);\r\nDEBUG_PRINT(" cleared dma ch0 interrupt\n");\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\ndma1_status = readb(devpriv->plx9080_iobase + PLX_DMA1_CS_REG);\r\nif (plx_status & ICS_DMA1_A) {\r\nwriteb((dma1_status & PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,\r\ndevpriv->plx9080_iobase + PLX_DMA1_CS_REG);\r\nDEBUG_PRINT("dma1 status 0x%x\n", dma1_status);\r\nDEBUG_PRINT(" cleared dma ch1 interrupt\n");\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nif (plx_status & ICS_LDIA) {\r\nplx_bits = readl(devpriv->plx9080_iobase + PLX_DBR_OUT_REG);\r\nwritel(plx_bits, devpriv->plx9080_iobase + PLX_DBR_OUT_REG);\r\nDEBUG_PRINT(" cleared local doorbell bits 0x%x\n", plx_bits);\r\n}\r\nif (hpdi_board_status & RX_OVERRUN_BIT) {\r\ncomedi_error(dev, "rx fifo overrun");\r\nasync->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\nDEBUG_PRINT("dma0_status 0x%x\n",\r\n(int)readb(devpriv->plx9080_iobase +\r\nPLX_DMA0_CS_REG));\r\n}\r\nif (hpdi_board_status & RX_UNDERRUN_BIT) {\r\ncomedi_error(dev, "rx fifo underrun");\r\nasync->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\n}\r\nif (devpriv->dio_count == 0)\r\nasync->events |= COMEDI_CB_EOA;\r\nDEBUG_PRINT("board status 0x%x, ", hpdi_board_status);\r\nDEBUG_PRINT("plx status 0x%x\n", plx_status);\r\nif (async->events)\r\nDEBUG_PRINT(" events 0x%x\n", async->events);\r\ncfc_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void abort_dma(struct comedi_device *dev, unsigned int channel)\r\n{\r\nstruct hpdi_private *devpriv = dev->private;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nplx9080_abort_dma(devpriv->plx9080_iobase, channel);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\n}\r\nstatic int hpdi_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct hpdi_private *devpriv = dev->private;\r\nhpdi_writel(dev, 0, BOARD_CONTROL_REG);\r\nwritel(0, devpriv->hpdi_iobase + INTERRUPT_CONTROL_REG);\r\nabort_dma(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int gsc_hpdi_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &gsc_hpdi_driver, id->driver_data);\r\n}
