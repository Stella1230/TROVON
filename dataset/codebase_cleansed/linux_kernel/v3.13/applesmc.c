static int wait_read(void)\r\n{\r\nu8 status;\r\nint us;\r\nfor (us = APPLESMC_MIN_WAIT; us < APPLESMC_MAX_WAIT; us <<= 1) {\r\nudelay(us);\r\nstatus = inb(APPLESMC_CMD_PORT);\r\nif (status & 0x01)\r\nreturn 0;\r\n}\r\npr_warn("wait_read() fail: 0x%02x\n", status);\r\nreturn -EIO;\r\n}\r\nstatic int send_byte(u8 cmd, u16 port)\r\n{\r\nu8 status;\r\nint us;\r\noutb(cmd, port);\r\nfor (us = APPLESMC_MIN_WAIT; us < APPLESMC_MAX_WAIT; us <<= 1) {\r\nudelay(us);\r\nstatus = inb(APPLESMC_CMD_PORT);\r\nif (status & 0x02)\r\ncontinue;\r\nif (status & 0x04)\r\nreturn 0;\r\nif (us << 1 == APPLESMC_MAX_WAIT)\r\nbreak;\r\nudelay(APPLESMC_RETRY_WAIT);\r\noutb(cmd, port);\r\n}\r\npr_warn("send_byte(0x%02x, 0x%04x) fail: 0x%02x\n", cmd, port, status);\r\nreturn -EIO;\r\n}\r\nstatic int send_command(u8 cmd)\r\n{\r\nreturn send_byte(cmd, APPLESMC_CMD_PORT);\r\n}\r\nstatic int send_argument(const char *key)\r\n{\r\nint i;\r\nfor (i = 0; i < 4; i++)\r\nif (send_byte(key[i], APPLESMC_DATA_PORT))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int read_smc(u8 cmd, const char *key, u8 *buffer, u8 len)\r\n{\r\nu8 status, data = 0;\r\nint i;\r\nif (send_command(cmd) || send_argument(key)) {\r\npr_warn("%.4s: read arg fail\n", key);\r\nreturn -EIO;\r\n}\r\nif (send_byte(len, APPLESMC_DATA_PORT)) {\r\npr_warn("%.4s: read len fail\n", key);\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nif (wait_read()) {\r\npr_warn("%.4s: read data[%d] fail\n", key, i);\r\nreturn -EIO;\r\n}\r\nbuffer[i] = inb(APPLESMC_DATA_PORT);\r\n}\r\nfor (i = 0; i < 16; i++) {\r\nudelay(APPLESMC_MIN_WAIT);\r\nstatus = inb(APPLESMC_CMD_PORT);\r\nif (!(status & 0x01))\r\nbreak;\r\ndata = inb(APPLESMC_DATA_PORT);\r\n}\r\nif (i)\r\npr_warn("flushed %d bytes, last value is: %d\n", i, data);\r\nreturn 0;\r\n}\r\nstatic int write_smc(u8 cmd, const char *key, const u8 *buffer, u8 len)\r\n{\r\nint i;\r\nif (send_command(cmd) || send_argument(key)) {\r\npr_warn("%s: write arg fail\n", key);\r\nreturn -EIO;\r\n}\r\nif (send_byte(len, APPLESMC_DATA_PORT)) {\r\npr_warn("%.4s: write len fail\n", key);\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nif (send_byte(buffer[i], APPLESMC_DATA_PORT)) {\r\npr_warn("%s: write data fail\n", key);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_register_count(unsigned int *count)\r\n{\r\n__be32 be;\r\nint ret;\r\nret = read_smc(APPLESMC_READ_CMD, KEY_COUNT_KEY, (u8 *)&be, 4);\r\nif (ret)\r\nreturn ret;\r\n*count = be32_to_cpu(be);\r\nreturn 0;\r\n}\r\nstatic int applesmc_read_entry(const struct applesmc_entry *entry,\r\nu8 *buf, u8 len)\r\n{\r\nint ret;\r\nif (entry->len != len)\r\nreturn -EINVAL;\r\nmutex_lock(&smcreg.mutex);\r\nret = read_smc(APPLESMC_READ_CMD, entry->key, buf, len);\r\nmutex_unlock(&smcreg.mutex);\r\nreturn ret;\r\n}\r\nstatic int applesmc_write_entry(const struct applesmc_entry *entry,\r\nconst u8 *buf, u8 len)\r\n{\r\nint ret;\r\nif (entry->len != len)\r\nreturn -EINVAL;\r\nmutex_lock(&smcreg.mutex);\r\nret = write_smc(APPLESMC_WRITE_CMD, entry->key, buf, len);\r\nmutex_unlock(&smcreg.mutex);\r\nreturn ret;\r\n}\r\nstatic const struct applesmc_entry *applesmc_get_entry_by_index(int index)\r\n{\r\nstruct applesmc_entry *cache = &smcreg.cache[index];\r\nu8 key[4], info[6];\r\n__be32 be;\r\nint ret = 0;\r\nif (cache->valid)\r\nreturn cache;\r\nmutex_lock(&smcreg.mutex);\r\nif (cache->valid)\r\ngoto out;\r\nbe = cpu_to_be32(index);\r\nret = read_smc(APPLESMC_GET_KEY_BY_INDEX_CMD, (u8 *)&be, key, 4);\r\nif (ret)\r\ngoto out;\r\nret = read_smc(APPLESMC_GET_KEY_TYPE_CMD, key, info, 6);\r\nif (ret)\r\ngoto out;\r\nmemcpy(cache->key, key, 4);\r\ncache->len = info[0];\r\nmemcpy(cache->type, &info[1], 4);\r\ncache->flags = info[5];\r\ncache->valid = 1;\r\nout:\r\nmutex_unlock(&smcreg.mutex);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nreturn cache;\r\n}\r\nstatic int applesmc_get_lower_bound(unsigned int *lo, const char *key)\r\n{\r\nint begin = 0, end = smcreg.key_count;\r\nconst struct applesmc_entry *entry;\r\nwhile (begin != end) {\r\nint middle = begin + (end - begin) / 2;\r\nentry = applesmc_get_entry_by_index(middle);\r\nif (IS_ERR(entry)) {\r\n*lo = 0;\r\nreturn PTR_ERR(entry);\r\n}\r\nif (strcmp(entry->key, key) < 0)\r\nbegin = middle + 1;\r\nelse\r\nend = middle;\r\n}\r\n*lo = begin;\r\nreturn 0;\r\n}\r\nstatic int applesmc_get_upper_bound(unsigned int *hi, const char *key)\r\n{\r\nint begin = 0, end = smcreg.key_count;\r\nconst struct applesmc_entry *entry;\r\nwhile (begin != end) {\r\nint middle = begin + (end - begin) / 2;\r\nentry = applesmc_get_entry_by_index(middle);\r\nif (IS_ERR(entry)) {\r\n*hi = smcreg.key_count;\r\nreturn PTR_ERR(entry);\r\n}\r\nif (strcmp(key, entry->key) < 0)\r\nend = middle;\r\nelse\r\nbegin = middle + 1;\r\n}\r\n*hi = begin;\r\nreturn 0;\r\n}\r\nstatic const struct applesmc_entry *applesmc_get_entry_by_key(const char *key)\r\n{\r\nint begin, end;\r\nint ret;\r\nret = applesmc_get_lower_bound(&begin, key);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nret = applesmc_get_upper_bound(&end, key);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nif (end - begin != 1)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn applesmc_get_entry_by_index(begin);\r\n}\r\nstatic int applesmc_read_key(const char *key, u8 *buffer, u8 len)\r\n{\r\nconst struct applesmc_entry *entry;\r\nentry = applesmc_get_entry_by_key(key);\r\nif (IS_ERR(entry))\r\nreturn PTR_ERR(entry);\r\nreturn applesmc_read_entry(entry, buffer, len);\r\n}\r\nstatic int applesmc_write_key(const char *key, const u8 *buffer, u8 len)\r\n{\r\nconst struct applesmc_entry *entry;\r\nentry = applesmc_get_entry_by_key(key);\r\nif (IS_ERR(entry))\r\nreturn PTR_ERR(entry);\r\nreturn applesmc_write_entry(entry, buffer, len);\r\n}\r\nstatic int applesmc_has_key(const char *key, bool *value)\r\n{\r\nconst struct applesmc_entry *entry;\r\nentry = applesmc_get_entry_by_key(key);\r\nif (IS_ERR(entry) && PTR_ERR(entry) != -EINVAL)\r\nreturn PTR_ERR(entry);\r\n*value = !IS_ERR(entry);\r\nreturn 0;\r\n}\r\nstatic int applesmc_read_s16(const char *key, s16 *value)\r\n{\r\nu8 buffer[2];\r\nint ret;\r\nret = applesmc_read_key(key, buffer, 2);\r\nif (ret)\r\nreturn ret;\r\n*value = ((s16)buffer[0] << 8) | buffer[1];\r\nreturn 0;\r\n}\r\nstatic void applesmc_device_init(void)\r\n{\r\nint total;\r\nu8 buffer[2];\r\nif (!smcreg.has_accelerometer)\r\nreturn;\r\nfor (total = INIT_TIMEOUT_MSECS; total > 0; total -= INIT_WAIT_MSECS) {\r\nif (!applesmc_read_key(MOTION_SENSOR_KEY, buffer, 2) &&\r\n(buffer[0] != 0x00 || buffer[1] != 0x00))\r\nreturn;\r\nbuffer[0] = 0xe0;\r\nbuffer[1] = 0x00;\r\napplesmc_write_key(MOTION_SENSOR_KEY, buffer, 2);\r\nmsleep(INIT_WAIT_MSECS);\r\n}\r\npr_warn("failed to init the device\n");\r\n}\r\nstatic int applesmc_init_index(struct applesmc_registers *s)\r\n{\r\nconst struct applesmc_entry *entry;\r\nunsigned int i;\r\nif (s->index)\r\nreturn 0;\r\ns->index = kcalloc(s->temp_count, sizeof(s->index[0]), GFP_KERNEL);\r\nif (!s->index)\r\nreturn -ENOMEM;\r\nfor (i = s->temp_begin; i < s->temp_end; i++) {\r\nentry = applesmc_get_entry_by_index(i);\r\nif (IS_ERR(entry))\r\ncontinue;\r\nif (strcmp(entry->type, TEMP_SENSOR_TYPE))\r\ncontinue;\r\ns->index[s->index_count++] = entry->key;\r\n}\r\nreturn 0;\r\n}\r\nstatic int applesmc_init_smcreg_try(void)\r\n{\r\nstruct applesmc_registers *s = &smcreg;\r\nbool left_light_sensor, right_light_sensor;\r\nunsigned int count;\r\nu8 tmp[1];\r\nint ret;\r\nif (s->init_complete)\r\nreturn 0;\r\nret = read_register_count(&count);\r\nif (ret)\r\nreturn ret;\r\nif (s->cache && s->key_count != count) {\r\npr_warn("key count changed from %d to %d\n",\r\ns->key_count, count);\r\nkfree(s->cache);\r\ns->cache = NULL;\r\n}\r\ns->key_count = count;\r\nif (!s->cache)\r\ns->cache = kcalloc(s->key_count, sizeof(*s->cache), GFP_KERNEL);\r\nif (!s->cache)\r\nreturn -ENOMEM;\r\nret = applesmc_read_key(FANS_COUNT, tmp, 1);\r\nif (ret)\r\nreturn ret;\r\ns->fan_count = tmp[0];\r\nret = applesmc_get_lower_bound(&s->temp_begin, "T");\r\nif (ret)\r\nreturn ret;\r\nret = applesmc_get_lower_bound(&s->temp_end, "U");\r\nif (ret)\r\nreturn ret;\r\ns->temp_count = s->temp_end - s->temp_begin;\r\nret = applesmc_init_index(s);\r\nif (ret)\r\nreturn ret;\r\nret = applesmc_has_key(LIGHT_SENSOR_LEFT_KEY, &left_light_sensor);\r\nif (ret)\r\nreturn ret;\r\nret = applesmc_has_key(LIGHT_SENSOR_RIGHT_KEY, &right_light_sensor);\r\nif (ret)\r\nreturn ret;\r\nret = applesmc_has_key(MOTION_SENSOR_KEY, &s->has_accelerometer);\r\nif (ret)\r\nreturn ret;\r\nret = applesmc_has_key(BACKLIGHT_KEY, &s->has_key_backlight);\r\nif (ret)\r\nreturn ret;\r\ns->num_light_sensors = left_light_sensor + right_light_sensor;\r\ns->init_complete = true;\r\npr_info("key=%d fan=%d temp=%d index=%d acc=%d lux=%d kbd=%d\n",\r\ns->key_count, s->fan_count, s->temp_count, s->index_count,\r\ns->has_accelerometer,\r\ns->num_light_sensors,\r\ns->has_key_backlight);\r\nreturn 0;\r\n}\r\nstatic void applesmc_destroy_smcreg(void)\r\n{\r\nkfree(smcreg.index);\r\nsmcreg.index = NULL;\r\nkfree(smcreg.cache);\r\nsmcreg.cache = NULL;\r\nsmcreg.init_complete = false;\r\n}\r\nstatic int applesmc_init_smcreg(void)\r\n{\r\nint ms, ret;\r\nfor (ms = 0; ms < INIT_TIMEOUT_MSECS; ms += INIT_WAIT_MSECS) {\r\nret = applesmc_init_smcreg_try();\r\nif (!ret) {\r\nif (ms)\r\npr_info("init_smcreg() took %d ms\n", ms);\r\nreturn 0;\r\n}\r\nmsleep(INIT_WAIT_MSECS);\r\n}\r\napplesmc_destroy_smcreg();\r\nreturn ret;\r\n}\r\nstatic int applesmc_probe(struct platform_device *dev)\r\n{\r\nint ret;\r\nret = applesmc_init_smcreg();\r\nif (ret)\r\nreturn ret;\r\napplesmc_device_init();\r\nreturn 0;\r\n}\r\nstatic int applesmc_pm_resume(struct device *dev)\r\n{\r\nif (smcreg.has_key_backlight)\r\napplesmc_write_key(BACKLIGHT_KEY, backlight_state, 2);\r\nreturn 0;\r\n}\r\nstatic int applesmc_pm_restore(struct device *dev)\r\n{\r\napplesmc_device_init();\r\nreturn applesmc_pm_resume(dev);\r\n}\r\nstatic void applesmc_calibrate(void)\r\n{\r\napplesmc_read_s16(MOTION_SENSOR_X_KEY, &rest_x);\r\napplesmc_read_s16(MOTION_SENSOR_Y_KEY, &rest_y);\r\nrest_x = -rest_x;\r\n}\r\nstatic void applesmc_idev_poll(struct input_polled_dev *dev)\r\n{\r\nstruct input_dev *idev = dev->input;\r\ns16 x, y;\r\nif (applesmc_read_s16(MOTION_SENSOR_X_KEY, &x))\r\nreturn;\r\nif (applesmc_read_s16(MOTION_SENSOR_Y_KEY, &y))\r\nreturn;\r\nx = -x;\r\ninput_report_abs(idev, ABS_X, x - rest_x);\r\ninput_report_abs(idev, ABS_Y, y - rest_y);\r\ninput_sync(idev);\r\n}\r\nstatic ssize_t applesmc_name_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "applesmc\n");\r\n}\r\nstatic ssize_t applesmc_position_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\ns16 x, y, z;\r\nret = applesmc_read_s16(MOTION_SENSOR_X_KEY, &x);\r\nif (ret)\r\ngoto out;\r\nret = applesmc_read_s16(MOTION_SENSOR_Y_KEY, &y);\r\nif (ret)\r\ngoto out;\r\nret = applesmc_read_s16(MOTION_SENSOR_Z_KEY, &z);\r\nif (ret)\r\ngoto out;\r\nout:\r\nif (ret)\r\nreturn ret;\r\nelse\r\nreturn snprintf(buf, PAGE_SIZE, "(%d,%d,%d)\n", x, y, z);\r\n}\r\nstatic ssize_t applesmc_light_show(struct device *dev,\r\nstruct device_attribute *attr, char *sysfsbuf)\r\n{\r\nconst struct applesmc_entry *entry;\r\nstatic int data_length;\r\nint ret;\r\nu8 left = 0, right = 0;\r\nu8 buffer[10];\r\nif (!data_length) {\r\nentry = applesmc_get_entry_by_key(LIGHT_SENSOR_LEFT_KEY);\r\nif (IS_ERR(entry))\r\nreturn PTR_ERR(entry);\r\nif (entry->len > 10)\r\nreturn -ENXIO;\r\ndata_length = entry->len;\r\npr_info("light sensor data length set to %d\n", data_length);\r\n}\r\nret = applesmc_read_key(LIGHT_SENSOR_LEFT_KEY, buffer, data_length);\r\nif (data_length == 10) {\r\nleft = be16_to_cpu(*(__be16 *)(buffer + 6)) >> 2;\r\ngoto out;\r\n}\r\nleft = buffer[2];\r\nif (ret)\r\ngoto out;\r\nret = applesmc_read_key(LIGHT_SENSOR_RIGHT_KEY, buffer, data_length);\r\nright = buffer[2];\r\nout:\r\nif (ret)\r\nreturn ret;\r\nelse\r\nreturn snprintf(sysfsbuf, PAGE_SIZE, "(%d,%d)\n", left, right);\r\n}\r\nstatic ssize_t applesmc_show_sensor_label(struct device *dev,\r\nstruct device_attribute *devattr, char *sysfsbuf)\r\n{\r\nconst char *key = smcreg.index[to_index(devattr)];\r\nreturn snprintf(sysfsbuf, PAGE_SIZE, "%s\n", key);\r\n}\r\nstatic ssize_t applesmc_show_temperature(struct device *dev,\r\nstruct device_attribute *devattr, char *sysfsbuf)\r\n{\r\nconst char *key = smcreg.index[to_index(devattr)];\r\nint ret;\r\ns16 value;\r\nint temp;\r\nret = applesmc_read_s16(key, &value);\r\nif (ret)\r\nreturn ret;\r\ntemp = 250 * (value >> 6);\r\nreturn snprintf(sysfsbuf, PAGE_SIZE, "%d\n", temp);\r\n}\r\nstatic ssize_t applesmc_show_fan_speed(struct device *dev,\r\nstruct device_attribute *attr, char *sysfsbuf)\r\n{\r\nint ret;\r\nunsigned int speed = 0;\r\nchar newkey[5];\r\nu8 buffer[2];\r\nsprintf(newkey, fan_speed_fmt[to_option(attr)], to_index(attr));\r\nret = applesmc_read_key(newkey, buffer, 2);\r\nspeed = ((buffer[0] << 8 | buffer[1]) >> 2);\r\nif (ret)\r\nreturn ret;\r\nelse\r\nreturn snprintf(sysfsbuf, PAGE_SIZE, "%u\n", speed);\r\n}\r\nstatic ssize_t applesmc_store_fan_speed(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *sysfsbuf, size_t count)\r\n{\r\nint ret;\r\nunsigned long speed;\r\nchar newkey[5];\r\nu8 buffer[2];\r\nif (kstrtoul(sysfsbuf, 10, &speed) < 0 || speed >= 0x4000)\r\nreturn -EINVAL;\r\nsprintf(newkey, fan_speed_fmt[to_option(attr)], to_index(attr));\r\nbuffer[0] = (speed >> 6) & 0xff;\r\nbuffer[1] = (speed << 2) & 0xff;\r\nret = applesmc_write_key(newkey, buffer, 2);\r\nif (ret)\r\nreturn ret;\r\nelse\r\nreturn count;\r\n}\r\nstatic ssize_t applesmc_show_fan_manual(struct device *dev,\r\nstruct device_attribute *attr, char *sysfsbuf)\r\n{\r\nint ret;\r\nu16 manual = 0;\r\nu8 buffer[2];\r\nret = applesmc_read_key(FANS_MANUAL, buffer, 2);\r\nmanual = ((buffer[0] << 8 | buffer[1]) >> to_index(attr)) & 0x01;\r\nif (ret)\r\nreturn ret;\r\nelse\r\nreturn snprintf(sysfsbuf, PAGE_SIZE, "%d\n", manual);\r\n}\r\nstatic ssize_t applesmc_store_fan_manual(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *sysfsbuf, size_t count)\r\n{\r\nint ret;\r\nu8 buffer[2];\r\nunsigned long input;\r\nu16 val;\r\nif (kstrtoul(sysfsbuf, 10, &input) < 0)\r\nreturn -EINVAL;\r\nret = applesmc_read_key(FANS_MANUAL, buffer, 2);\r\nval = (buffer[0] << 8 | buffer[1]);\r\nif (ret)\r\ngoto out;\r\nif (input)\r\nval = val | (0x01 << to_index(attr));\r\nelse\r\nval = val & ~(0x01 << to_index(attr));\r\nbuffer[0] = (val >> 8) & 0xFF;\r\nbuffer[1] = val & 0xFF;\r\nret = applesmc_write_key(FANS_MANUAL, buffer, 2);\r\nout:\r\nif (ret)\r\nreturn ret;\r\nelse\r\nreturn count;\r\n}\r\nstatic ssize_t applesmc_show_fan_position(struct device *dev,\r\nstruct device_attribute *attr, char *sysfsbuf)\r\n{\r\nint ret;\r\nchar newkey[5];\r\nu8 buffer[17];\r\nsprintf(newkey, FAN_ID_FMT, to_index(attr));\r\nret = applesmc_read_key(newkey, buffer, 16);\r\nbuffer[16] = 0;\r\nif (ret)\r\nreturn ret;\r\nelse\r\nreturn snprintf(sysfsbuf, PAGE_SIZE, "%s\n", buffer+4);\r\n}\r\nstatic ssize_t applesmc_calibrate_show(struct device *dev,\r\nstruct device_attribute *attr, char *sysfsbuf)\r\n{\r\nreturn snprintf(sysfsbuf, PAGE_SIZE, "(%d,%d)\n", rest_x, rest_y);\r\n}\r\nstatic ssize_t applesmc_calibrate_store(struct device *dev,\r\nstruct device_attribute *attr, const char *sysfsbuf, size_t count)\r\n{\r\napplesmc_calibrate();\r\nreturn count;\r\n}\r\nstatic void applesmc_backlight_set(struct work_struct *work)\r\n{\r\napplesmc_write_key(BACKLIGHT_KEY, backlight_state, 2);\r\n}\r\nstatic void applesmc_brightness_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nint ret;\r\nbacklight_state[0] = value;\r\nret = queue_work(applesmc_led_wq, &backlight_work);\r\nif (debug && (!ret))\r\ndev_dbg(led_cdev->dev, "work was already on the queue.\n");\r\n}\r\nstatic ssize_t applesmc_key_count_show(struct device *dev,\r\nstruct device_attribute *attr, char *sysfsbuf)\r\n{\r\nint ret;\r\nu8 buffer[4];\r\nu32 count;\r\nret = applesmc_read_key(KEY_COUNT_KEY, buffer, 4);\r\ncount = ((u32)buffer[0]<<24) + ((u32)buffer[1]<<16) +\r\n((u32)buffer[2]<<8) + buffer[3];\r\nif (ret)\r\nreturn ret;\r\nelse\r\nreturn snprintf(sysfsbuf, PAGE_SIZE, "%d\n", count);\r\n}\r\nstatic ssize_t applesmc_key_at_index_read_show(struct device *dev,\r\nstruct device_attribute *attr, char *sysfsbuf)\r\n{\r\nconst struct applesmc_entry *entry;\r\nint ret;\r\nentry = applesmc_get_entry_by_index(key_at_index);\r\nif (IS_ERR(entry))\r\nreturn PTR_ERR(entry);\r\nret = applesmc_read_entry(entry, sysfsbuf, entry->len);\r\nif (ret)\r\nreturn ret;\r\nreturn entry->len;\r\n}\r\nstatic ssize_t applesmc_key_at_index_data_length_show(struct device *dev,\r\nstruct device_attribute *attr, char *sysfsbuf)\r\n{\r\nconst struct applesmc_entry *entry;\r\nentry = applesmc_get_entry_by_index(key_at_index);\r\nif (IS_ERR(entry))\r\nreturn PTR_ERR(entry);\r\nreturn snprintf(sysfsbuf, PAGE_SIZE, "%d\n", entry->len);\r\n}\r\nstatic ssize_t applesmc_key_at_index_type_show(struct device *dev,\r\nstruct device_attribute *attr, char *sysfsbuf)\r\n{\r\nconst struct applesmc_entry *entry;\r\nentry = applesmc_get_entry_by_index(key_at_index);\r\nif (IS_ERR(entry))\r\nreturn PTR_ERR(entry);\r\nreturn snprintf(sysfsbuf, PAGE_SIZE, "%s\n", entry->type);\r\n}\r\nstatic ssize_t applesmc_key_at_index_name_show(struct device *dev,\r\nstruct device_attribute *attr, char *sysfsbuf)\r\n{\r\nconst struct applesmc_entry *entry;\r\nentry = applesmc_get_entry_by_index(key_at_index);\r\nif (IS_ERR(entry))\r\nreturn PTR_ERR(entry);\r\nreturn snprintf(sysfsbuf, PAGE_SIZE, "%s\n", entry->key);\r\n}\r\nstatic ssize_t applesmc_key_at_index_show(struct device *dev,\r\nstruct device_attribute *attr, char *sysfsbuf)\r\n{\r\nreturn snprintf(sysfsbuf, PAGE_SIZE, "%d\n", key_at_index);\r\n}\r\nstatic ssize_t applesmc_key_at_index_store(struct device *dev,\r\nstruct device_attribute *attr, const char *sysfsbuf, size_t count)\r\n{\r\nunsigned long newkey;\r\nif (kstrtoul(sysfsbuf, 10, &newkey) < 0\r\n|| newkey >= smcreg.key_count)\r\nreturn -EINVAL;\r\nkey_at_index = newkey;\r\nreturn count;\r\n}\r\nstatic void applesmc_destroy_nodes(struct applesmc_node_group *groups)\r\n{\r\nstruct applesmc_node_group *grp;\r\nstruct applesmc_dev_attr *node;\r\nfor (grp = groups; grp->nodes; grp++) {\r\nfor (node = grp->nodes; node->sda.dev_attr.attr.name; node++)\r\nsysfs_remove_file(&pdev->dev.kobj,\r\n&node->sda.dev_attr.attr);\r\nkfree(grp->nodes);\r\ngrp->nodes = NULL;\r\n}\r\n}\r\nstatic int applesmc_create_nodes(struct applesmc_node_group *groups, int num)\r\n{\r\nstruct applesmc_node_group *grp;\r\nstruct applesmc_dev_attr *node;\r\nstruct attribute *attr;\r\nint ret, i;\r\nfor (grp = groups; grp->format; grp++) {\r\ngrp->nodes = kcalloc(num + 1, sizeof(*node), GFP_KERNEL);\r\nif (!grp->nodes) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < num; i++) {\r\nnode = &grp->nodes[i];\r\nsprintf(node->name, grp->format, i + 1);\r\nnode->sda.index = (grp->option << 16) | (i & 0xffff);\r\nnode->sda.dev_attr.show = grp->show;\r\nnode->sda.dev_attr.store = grp->store;\r\nattr = &node->sda.dev_attr.attr;\r\nsysfs_attr_init(attr);\r\nattr->name = node->name;\r\nattr->mode = S_IRUGO | (grp->store ? S_IWUSR : 0);\r\nret = sysfs_create_file(&pdev->dev.kobj, attr);\r\nif (ret) {\r\nattr->name = NULL;\r\ngoto out;\r\n}\r\n}\r\n}\r\nreturn 0;\r\nout:\r\napplesmc_destroy_nodes(groups);\r\nreturn ret;\r\n}\r\nstatic int applesmc_create_accelerometer(void)\r\n{\r\nstruct input_dev *idev;\r\nint ret;\r\nif (!smcreg.has_accelerometer)\r\nreturn 0;\r\nret = applesmc_create_nodes(accelerometer_group, 1);\r\nif (ret)\r\ngoto out;\r\napplesmc_idev = input_allocate_polled_device();\r\nif (!applesmc_idev) {\r\nret = -ENOMEM;\r\ngoto out_sysfs;\r\n}\r\napplesmc_idev->poll = applesmc_idev_poll;\r\napplesmc_idev->poll_interval = APPLESMC_POLL_INTERVAL;\r\napplesmc_calibrate();\r\nidev = applesmc_idev->input;\r\nidev->name = "applesmc";\r\nidev->id.bustype = BUS_HOST;\r\nidev->dev.parent = &pdev->dev;\r\nidev->evbit[0] = BIT_MASK(EV_ABS);\r\ninput_set_abs_params(idev, ABS_X,\r\n-256, 256, APPLESMC_INPUT_FUZZ, APPLESMC_INPUT_FLAT);\r\ninput_set_abs_params(idev, ABS_Y,\r\n-256, 256, APPLESMC_INPUT_FUZZ, APPLESMC_INPUT_FLAT);\r\nret = input_register_polled_device(applesmc_idev);\r\nif (ret)\r\ngoto out_idev;\r\nreturn 0;\r\nout_idev:\r\ninput_free_polled_device(applesmc_idev);\r\nout_sysfs:\r\napplesmc_destroy_nodes(accelerometer_group);\r\nout:\r\npr_warn("driver init failed (ret=%d)!\n", ret);\r\nreturn ret;\r\n}\r\nstatic void applesmc_release_accelerometer(void)\r\n{\r\nif (!smcreg.has_accelerometer)\r\nreturn;\r\ninput_unregister_polled_device(applesmc_idev);\r\ninput_free_polled_device(applesmc_idev);\r\napplesmc_destroy_nodes(accelerometer_group);\r\n}\r\nstatic int applesmc_create_light_sensor(void)\r\n{\r\nif (!smcreg.num_light_sensors)\r\nreturn 0;\r\nreturn applesmc_create_nodes(light_sensor_group, 1);\r\n}\r\nstatic void applesmc_release_light_sensor(void)\r\n{\r\nif (!smcreg.num_light_sensors)\r\nreturn;\r\napplesmc_destroy_nodes(light_sensor_group);\r\n}\r\nstatic int applesmc_create_key_backlight(void)\r\n{\r\nif (!smcreg.has_key_backlight)\r\nreturn 0;\r\napplesmc_led_wq = create_singlethread_workqueue("applesmc-led");\r\nif (!applesmc_led_wq)\r\nreturn -ENOMEM;\r\nreturn led_classdev_register(&pdev->dev, &applesmc_backlight);\r\n}\r\nstatic void applesmc_release_key_backlight(void)\r\n{\r\nif (!smcreg.has_key_backlight)\r\nreturn;\r\nled_classdev_unregister(&applesmc_backlight);\r\ndestroy_workqueue(applesmc_led_wq);\r\n}\r\nstatic int applesmc_dmi_match(const struct dmi_system_id *id)\r\n{\r\nreturn 1;\r\n}\r\nstatic int __init applesmc_init(void)\r\n{\r\nint ret;\r\nif (!dmi_check_system(applesmc_whitelist)) {\r\npr_warn("supported laptop not found!\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (!request_region(APPLESMC_DATA_PORT, APPLESMC_NR_PORTS,\r\n"applesmc")) {\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nret = platform_driver_register(&applesmc_driver);\r\nif (ret)\r\ngoto out_region;\r\npdev = platform_device_register_simple("applesmc", APPLESMC_DATA_PORT,\r\nNULL, 0);\r\nif (IS_ERR(pdev)) {\r\nret = PTR_ERR(pdev);\r\ngoto out_driver;\r\n}\r\nret = applesmc_init_smcreg();\r\nif (ret)\r\ngoto out_device;\r\nret = applesmc_create_nodes(info_group, 1);\r\nif (ret)\r\ngoto out_smcreg;\r\nret = applesmc_create_nodes(fan_group, smcreg.fan_count);\r\nif (ret)\r\ngoto out_info;\r\nret = applesmc_create_nodes(temp_group, smcreg.index_count);\r\nif (ret)\r\ngoto out_fans;\r\nret = applesmc_create_accelerometer();\r\nif (ret)\r\ngoto out_temperature;\r\nret = applesmc_create_light_sensor();\r\nif (ret)\r\ngoto out_accelerometer;\r\nret = applesmc_create_key_backlight();\r\nif (ret)\r\ngoto out_light_sysfs;\r\nhwmon_dev = hwmon_device_register(&pdev->dev);\r\nif (IS_ERR(hwmon_dev)) {\r\nret = PTR_ERR(hwmon_dev);\r\ngoto out_light_ledclass;\r\n}\r\nreturn 0;\r\nout_light_ledclass:\r\napplesmc_release_key_backlight();\r\nout_light_sysfs:\r\napplesmc_release_light_sensor();\r\nout_accelerometer:\r\napplesmc_release_accelerometer();\r\nout_temperature:\r\napplesmc_destroy_nodes(temp_group);\r\nout_fans:\r\napplesmc_destroy_nodes(fan_group);\r\nout_info:\r\napplesmc_destroy_nodes(info_group);\r\nout_smcreg:\r\napplesmc_destroy_smcreg();\r\nout_device:\r\nplatform_device_unregister(pdev);\r\nout_driver:\r\nplatform_driver_unregister(&applesmc_driver);\r\nout_region:\r\nrelease_region(APPLESMC_DATA_PORT, APPLESMC_NR_PORTS);\r\nout:\r\npr_warn("driver init failed (ret=%d)!\n", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit applesmc_exit(void)\r\n{\r\nhwmon_device_unregister(hwmon_dev);\r\napplesmc_release_key_backlight();\r\napplesmc_release_light_sensor();\r\napplesmc_release_accelerometer();\r\napplesmc_destroy_nodes(temp_group);\r\napplesmc_destroy_nodes(fan_group);\r\napplesmc_destroy_nodes(info_group);\r\napplesmc_destroy_smcreg();\r\nplatform_device_unregister(pdev);\r\nplatform_driver_unregister(&applesmc_driver);\r\nrelease_region(APPLESMC_DATA_PORT, APPLESMC_NR_PORTS);\r\n}
