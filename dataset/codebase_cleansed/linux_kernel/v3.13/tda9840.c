static void tda9840_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (i2c_smbus_write_byte_data(client, reg, val))\r\nv4l2_dbg(1, debug, sd, "error writing %02x to %02x\n",\r\nval, reg);\r\n}\r\nstatic int tda9840_status(struct v4l2_subdev *sd)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu8 byte;\r\nif (1 != i2c_master_recv(client, &byte, 1)) {\r\nv4l2_dbg(1, debug, sd,\r\n"i2c_master_recv() failed\n");\r\nreturn -EIO;\r\n}\r\nif (byte & 0x80) {\r\nv4l2_dbg(1, debug, sd,\r\n"TDA9840_DETECT: register contents invalid\n");\r\nreturn -EINVAL;\r\n}\r\nv4l2_dbg(1, debug, sd, "TDA9840_DETECT: byte: 0x%02x\n", byte);\r\nreturn byte & 0x60;\r\n}\r\nstatic int tda9840_s_tuner(struct v4l2_subdev *sd, const struct v4l2_tuner *t)\r\n{\r\nint stat = tda9840_status(sd);\r\nint byte;\r\nif (t->index)\r\nreturn -EINVAL;\r\nstat = stat < 0 ? 0 : stat;\r\nif (stat == 0 || stat == 0x60)\r\nbyte = TDA9840_SET_MONO;\r\nelse if (stat == 0x40)\r\nbyte = (t->audmode == V4L2_TUNER_MODE_MONO) ?\r\nTDA9840_SET_MONO : TDA9840_SET_STEREO;\r\nelse {\r\nswitch (t->audmode) {\r\ncase V4L2_TUNER_MODE_LANG1_LANG2:\r\nbyte = TDA9840_SET_BOTH;\r\nbreak;\r\ncase V4L2_TUNER_MODE_LANG2:\r\nbyte = TDA9840_SET_LANG2;\r\nbreak;\r\ndefault:\r\nbyte = TDA9840_SET_LANG1;\r\nbreak;\r\n}\r\n}\r\nv4l2_dbg(1, debug, sd, "TDA9840_SWITCH: 0x%02x\n", byte);\r\ntda9840_write(sd, SWITCH, byte);\r\nreturn 0;\r\n}\r\nstatic int tda9840_g_tuner(struct v4l2_subdev *sd, struct v4l2_tuner *t)\r\n{\r\nint stat = tda9840_status(sd);\r\nif (stat < 0)\r\nreturn stat;\r\nt->rxsubchans = V4L2_TUNER_SUB_MONO;\r\nswitch (stat & 0x60) {\r\ncase 0x00:\r\nt->rxsubchans = V4L2_TUNER_SUB_MONO;\r\nbreak;\r\ncase 0x20:\r\nt->rxsubchans = V4L2_TUNER_SUB_LANG1 | V4L2_TUNER_SUB_LANG2;\r\nbreak;\r\ncase 0x40:\r\nt->rxsubchans = V4L2_TUNER_SUB_STEREO | V4L2_TUNER_SUB_MONO;\r\nbreak;\r\ndefault:\r\nt->rxsubchans = V4L2_TUNER_MODE_MONO;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tda9840_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct v4l2_subdev *sd;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_READ_BYTE_DATA |\r\nI2C_FUNC_SMBUS_WRITE_BYTE_DATA))\r\nreturn -EIO;\r\nv4l_info(client, "chip found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\nsd = devm_kzalloc(&client->dev, sizeof(*sd), GFP_KERNEL);\r\nif (sd == NULL)\r\nreturn -ENOMEM;\r\nv4l2_i2c_subdev_init(sd, client, &tda9840_ops);\r\ntda9840_write(sd, LEVEL_ADJUST, 0);\r\ntda9840_write(sd, STEREO_ADJUST, 0);\r\ntda9840_write(sd, SWITCH, TDA9840_SET_STEREO);\r\nreturn 0;\r\n}\r\nstatic int tda9840_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nreturn 0;\r\n}
