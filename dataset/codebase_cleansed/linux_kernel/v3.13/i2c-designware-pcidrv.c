static int i2c_dw_pci_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = container_of(dev, struct pci_dev, dev);\r\nstruct dw_i2c_dev *i2c = pci_get_drvdata(pdev);\r\nint err;\r\ni2c_dw_disable(i2c);\r\nerr = pci_save_state(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "pci_save_state failed\n");\r\nreturn err;\r\n}\r\nerr = pci_set_power_state(pdev, PCI_D3hot);\r\nif (err) {\r\ndev_err(&pdev->dev, "pci_set_power_state failed\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_dw_pci_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = container_of(dev, struct pci_dev, dev);\r\nstruct dw_i2c_dev *i2c = pci_get_drvdata(pdev);\r\nint err;\r\nu32 enabled;\r\nenabled = i2c_dw_is_enabled(i2c);\r\nif (enabled)\r\nreturn 0;\r\nerr = pci_set_power_state(pdev, PCI_D0);\r\nif (err) {\r\ndev_err(&pdev->dev, "pci_set_power_state() failed\n");\r\nreturn err;\r\n}\r\npci_restore_state(pdev);\r\ni2c_dw_init(i2c);\r\nreturn 0;\r\n}\r\nstatic int i2c_dw_pci_runtime_idle(struct device *dev)\r\n{\r\nint err = pm_schedule_suspend(dev, 500);\r\ndev_dbg(dev, "runtime_idle called\n");\r\nif (err != 0)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)\r\n{\r\nreturn dev->controller->clk_khz;\r\n}\r\nstatic int i2c_dw_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct dw_i2c_dev *dev;\r\nstruct i2c_adapter *adap;\r\nint r;\r\nstruct dw_pci_controller *controller;\r\nif (id->driver_data >= ARRAY_SIZE(dw_pci_controllers)) {\r\ndev_err(&pdev->dev, "%s: invalid driver data %ld\n", __func__,\r\nid->driver_data);\r\nreturn -EINVAL;\r\n}\r\ncontroller = &dw_pci_controllers[id->driver_data];\r\nr = pcim_enable_device(pdev);\r\nif (r) {\r\ndev_err(&pdev->dev, "Failed to enable I2C PCI device (%d)\n",\r\nr);\r\nreturn r;\r\n}\r\nr = pcim_iomap_regions(pdev, 1 << 0, pci_name(pdev));\r\nif (r) {\r\ndev_err(&pdev->dev, "I/O memory remapping failed\n");\r\nreturn r;\r\n}\r\ndev = devm_kzalloc(&pdev->dev, sizeof(struct dw_i2c_dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ninit_completion(&dev->cmd_complete);\r\nmutex_init(&dev->lock);\r\ndev->clk = NULL;\r\ndev->controller = controller;\r\ndev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;\r\ndev->base = pcim_iomap_table(pdev)[0];\r\ndev->dev = &pdev->dev;\r\ndev->functionality =\r\nI2C_FUNC_I2C |\r\nI2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_I2C_BLOCK;\r\ndev->master_cfg = controller->bus_cfg;\r\npci_set_drvdata(pdev, dev);\r\ndev->tx_fifo_depth = controller->tx_fifo_depth;\r\ndev->rx_fifo_depth = controller->rx_fifo_depth;\r\nr = i2c_dw_init(dev);\r\nif (r)\r\nreturn r;\r\nadap = &dev->adapter;\r\ni2c_set_adapdata(adap, dev);\r\nadap->owner = THIS_MODULE;\r\nadap->class = 0;\r\nadap->algo = &i2c_dw_algo;\r\nadap->dev.parent = &pdev->dev;\r\nadap->nr = controller->bus_num;\r\nsnprintf(adap->name, sizeof(adap->name), "i2c-designware-pci-%d",\r\nadap->nr);\r\nr = devm_request_irq(&pdev->dev, pdev->irq, i2c_dw_isr, IRQF_SHARED,\r\nadap->name, dev);\r\nif (r) {\r\ndev_err(&pdev->dev, "failure requesting irq %i\n", dev->irq);\r\nreturn r;\r\n}\r\ni2c_dw_disable_int(dev);\r\ni2c_dw_clear_int(dev);\r\nr = i2c_add_numbered_adapter(adap);\r\nif (r) {\r\ndev_err(&pdev->dev, "failure adding adapter\n");\r\nreturn r;\r\n}\r\npm_runtime_set_autosuspend_delay(&pdev->dev, 1000);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_allow(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic void i2c_dw_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct dw_i2c_dev *dev = pci_get_drvdata(pdev);\r\ni2c_dw_disable(dev);\r\npm_runtime_forbid(&pdev->dev);\r\npm_runtime_get_noresume(&pdev->dev);\r\ni2c_del_adapter(&dev->adapter);\r\n}
