static int\r\nposix_acl_set(struct dentry *dentry, const char *name, const void *value,\r\nsize_t size, int flags, int type)\r\n{\r\nstruct inode *inode = dentry->d_inode;\r\nstruct posix_acl *acl;\r\nint error, error2;\r\nstruct reiserfs_transaction_handle th;\r\nsize_t jcreate_blocks;\r\nif (!reiserfs_posixacl(inode->i_sb))\r\nreturn -EOPNOTSUPP;\r\nif (!inode_owner_or_capable(inode))\r\nreturn -EPERM;\r\nif (value) {\r\nacl = posix_acl_from_xattr(&init_user_ns, value, size);\r\nif (IS_ERR(acl)) {\r\nreturn PTR_ERR(acl);\r\n} else if (acl) {\r\nerror = posix_acl_valid(acl);\r\nif (error)\r\ngoto release_and_out;\r\n}\r\n} else\r\nacl = NULL;\r\njcreate_blocks = reiserfs_xattr_jcreate_nblocks(inode) +\r\nreiserfs_xattr_nblocks(inode, size) * 2;\r\nreiserfs_write_lock(inode->i_sb);\r\nerror = journal_begin(&th, inode->i_sb, jcreate_blocks);\r\nreiserfs_write_unlock(inode->i_sb);\r\nif (error == 0) {\r\nerror = reiserfs_set_acl(&th, inode, type, acl);\r\nreiserfs_write_lock(inode->i_sb);\r\nerror2 = journal_end(&th, inode->i_sb, jcreate_blocks);\r\nreiserfs_write_unlock(inode->i_sb);\r\nif (error2)\r\nerror = error2;\r\n}\r\nrelease_and_out:\r\nposix_acl_release(acl);\r\nreturn error;\r\n}\r\nstatic int\r\nposix_acl_get(struct dentry *dentry, const char *name, void *buffer,\r\nsize_t size, int type)\r\n{\r\nstruct posix_acl *acl;\r\nint error;\r\nif (!reiserfs_posixacl(dentry->d_sb))\r\nreturn -EOPNOTSUPP;\r\nacl = reiserfs_get_acl(dentry->d_inode, type);\r\nif (IS_ERR(acl))\r\nreturn PTR_ERR(acl);\r\nif (acl == NULL)\r\nreturn -ENODATA;\r\nerror = posix_acl_to_xattr(&init_user_ns, acl, buffer, size);\r\nposix_acl_release(acl);\r\nreturn error;\r\n}\r\nstatic struct posix_acl *posix_acl_from_disk(const void *value, size_t size)\r\n{\r\nconst char *end = (char *)value + size;\r\nint n, count;\r\nstruct posix_acl *acl;\r\nif (!value)\r\nreturn NULL;\r\nif (size < sizeof(reiserfs_acl_header))\r\nreturn ERR_PTR(-EINVAL);\r\nif (((reiserfs_acl_header *) value)->a_version !=\r\ncpu_to_le32(REISERFS_ACL_VERSION))\r\nreturn ERR_PTR(-EINVAL);\r\nvalue = (char *)value + sizeof(reiserfs_acl_header);\r\ncount = reiserfs_acl_count(size);\r\nif (count < 0)\r\nreturn ERR_PTR(-EINVAL);\r\nif (count == 0)\r\nreturn NULL;\r\nacl = posix_acl_alloc(count, GFP_NOFS);\r\nif (!acl)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (n = 0; n < count; n++) {\r\nreiserfs_acl_entry *entry = (reiserfs_acl_entry *) value;\r\nif ((char *)value + sizeof(reiserfs_acl_entry_short) > end)\r\ngoto fail;\r\nacl->a_entries[n].e_tag = le16_to_cpu(entry->e_tag);\r\nacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\r\nswitch (acl->a_entries[n].e_tag) {\r\ncase ACL_USER_OBJ:\r\ncase ACL_GROUP_OBJ:\r\ncase ACL_MASK:\r\ncase ACL_OTHER:\r\nvalue = (char *)value +\r\nsizeof(reiserfs_acl_entry_short);\r\nbreak;\r\ncase ACL_USER:\r\nvalue = (char *)value + sizeof(reiserfs_acl_entry);\r\nif ((char *)value > end)\r\ngoto fail;\r\nacl->a_entries[n].e_uid =\r\nmake_kuid(&init_user_ns,\r\nle32_to_cpu(entry->e_id));\r\nbreak;\r\ncase ACL_GROUP:\r\nvalue = (char *)value + sizeof(reiserfs_acl_entry);\r\nif ((char *)value > end)\r\ngoto fail;\r\nacl->a_entries[n].e_gid =\r\nmake_kgid(&init_user_ns,\r\nle32_to_cpu(entry->e_id));\r\nbreak;\r\ndefault:\r\ngoto fail;\r\n}\r\n}\r\nif (value != end)\r\ngoto fail;\r\nreturn acl;\r\nfail:\r\nposix_acl_release(acl);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic void *posix_acl_to_disk(const struct posix_acl *acl, size_t * size)\r\n{\r\nreiserfs_acl_header *ext_acl;\r\nchar *e;\r\nint n;\r\n*size = reiserfs_acl_size(acl->a_count);\r\next_acl = kmalloc(sizeof(reiserfs_acl_header) +\r\nacl->a_count *\r\nsizeof(reiserfs_acl_entry),\r\nGFP_NOFS);\r\nif (!ext_acl)\r\nreturn ERR_PTR(-ENOMEM);\r\next_acl->a_version = cpu_to_le32(REISERFS_ACL_VERSION);\r\ne = (char *)ext_acl + sizeof(reiserfs_acl_header);\r\nfor (n = 0; n < acl->a_count; n++) {\r\nconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\r\nreiserfs_acl_entry *entry = (reiserfs_acl_entry *) e;\r\nentry->e_tag = cpu_to_le16(acl->a_entries[n].e_tag);\r\nentry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);\r\nswitch (acl->a_entries[n].e_tag) {\r\ncase ACL_USER:\r\nentry->e_id = cpu_to_le32(\r\nfrom_kuid(&init_user_ns, acl_e->e_uid));\r\ne += sizeof(reiserfs_acl_entry);\r\nbreak;\r\ncase ACL_GROUP:\r\nentry->e_id = cpu_to_le32(\r\nfrom_kgid(&init_user_ns, acl_e->e_gid));\r\ne += sizeof(reiserfs_acl_entry);\r\nbreak;\r\ncase ACL_USER_OBJ:\r\ncase ACL_GROUP_OBJ:\r\ncase ACL_MASK:\r\ncase ACL_OTHER:\r\ne += sizeof(reiserfs_acl_entry_short);\r\nbreak;\r\ndefault:\r\ngoto fail;\r\n}\r\n}\r\nreturn (char *)ext_acl;\r\nfail:\r\nkfree(ext_acl);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstruct posix_acl *reiserfs_get_acl(struct inode *inode, int type)\r\n{\r\nchar *name, *value;\r\nstruct posix_acl *acl;\r\nint size;\r\nint retval;\r\nacl = get_cached_acl(inode, type);\r\nif (acl != ACL_NOT_CACHED)\r\nreturn acl;\r\nswitch (type) {\r\ncase ACL_TYPE_ACCESS:\r\nname = POSIX_ACL_XATTR_ACCESS;\r\nbreak;\r\ncase ACL_TYPE_DEFAULT:\r\nname = POSIX_ACL_XATTR_DEFAULT;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nsize = reiserfs_xattr_get(inode, name, NULL, 0);\r\nif (size < 0) {\r\nif (size == -ENODATA || size == -ENOSYS) {\r\nset_cached_acl(inode, type, NULL);\r\nreturn NULL;\r\n}\r\nreturn ERR_PTR(size);\r\n}\r\nvalue = kmalloc(size, GFP_NOFS);\r\nif (!value)\r\nreturn ERR_PTR(-ENOMEM);\r\nretval = reiserfs_xattr_get(inode, name, value, size);\r\nif (retval == -ENODATA || retval == -ENOSYS) {\r\nacl = NULL;\r\n} else if (retval < 0) {\r\nacl = ERR_PTR(retval);\r\n} else {\r\nacl = posix_acl_from_disk(value, retval);\r\n}\r\nif (!IS_ERR(acl))\r\nset_cached_acl(inode, type, acl);\r\nkfree(value);\r\nreturn acl;\r\n}\r\nstatic int\r\nreiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\r\nint type, struct posix_acl *acl)\r\n{\r\nchar *name;\r\nvoid *value = NULL;\r\nsize_t size = 0;\r\nint error;\r\nif (S_ISLNK(inode->i_mode))\r\nreturn -EOPNOTSUPP;\r\nswitch (type) {\r\ncase ACL_TYPE_ACCESS:\r\nname = POSIX_ACL_XATTR_ACCESS;\r\nif (acl) {\r\nerror = posix_acl_equiv_mode(acl, &inode->i_mode);\r\nif (error < 0)\r\nreturn error;\r\nelse {\r\nif (error == 0)\r\nacl = NULL;\r\n}\r\n}\r\nbreak;\r\ncase ACL_TYPE_DEFAULT:\r\nname = POSIX_ACL_XATTR_DEFAULT;\r\nif (!S_ISDIR(inode->i_mode))\r\nreturn acl ? -EACCES : 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (acl) {\r\nvalue = posix_acl_to_disk(acl, &size);\r\nif (IS_ERR(value))\r\nreturn (int)PTR_ERR(value);\r\n}\r\nerror = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);\r\nif (error == -ENODATA) {\r\nerror = 0;\r\nif (type == ACL_TYPE_ACCESS) {\r\ninode->i_ctime = CURRENT_TIME_SEC;\r\nmark_inode_dirty(inode);\r\n}\r\n}\r\nkfree(value);\r\nif (!error)\r\nset_cached_acl(inode, type, acl);\r\nreturn error;\r\n}\r\nint\r\nreiserfs_inherit_default_acl(struct reiserfs_transaction_handle *th,\r\nstruct inode *dir, struct dentry *dentry,\r\nstruct inode *inode)\r\n{\r\nstruct posix_acl *acl;\r\nint err = 0;\r\nif (S_ISLNK(inode->i_mode))\r\nreturn 0;\r\nif (get_inode_sd_version(dir) == STAT_DATA_V1)\r\ngoto apply_umask;\r\nif (IS_PRIVATE(dir)) {\r\ninode->i_flags |= S_PRIVATE;\r\ngoto apply_umask;\r\n}\r\nacl = reiserfs_get_acl(dir, ACL_TYPE_DEFAULT);\r\nif (IS_ERR(acl))\r\nreturn PTR_ERR(acl);\r\nif (acl) {\r\nif (S_ISDIR(inode->i_mode)) {\r\nerr = reiserfs_set_acl(th, inode, ACL_TYPE_DEFAULT,\r\nacl);\r\nif (err)\r\ngoto cleanup;\r\n}\r\nerr = posix_acl_create(&acl, GFP_NOFS, &inode->i_mode);\r\nif (err < 0)\r\nreturn err;\r\nif (err > 0)\r\nerr = reiserfs_set_acl(th, inode, ACL_TYPE_ACCESS, acl);\r\ncleanup:\r\nposix_acl_release(acl);\r\n} else {\r\napply_umask:\r\ninode->i_mode &= ~current_umask();\r\n}\r\nreturn err;\r\n}\r\nint reiserfs_cache_default_acl(struct inode *inode)\r\n{\r\nstruct posix_acl *acl;\r\nint nblocks = 0;\r\nif (IS_PRIVATE(inode))\r\nreturn 0;\r\nacl = reiserfs_get_acl(inode, ACL_TYPE_DEFAULT);\r\nif (acl && !IS_ERR(acl)) {\r\nint size = reiserfs_acl_size(acl->a_count);\r\nnblocks = reiserfs_xattr_jcreate_nblocks(inode);\r\nnblocks += JOURNAL_BLOCKS_PER_OBJECT(inode->i_sb);\r\nREISERFS_I(inode)->i_flags |= i_has_xattr_dir;\r\nnblocks += reiserfs_xattr_nblocks(inode, size) * 4;\r\nposix_acl_release(acl);\r\n}\r\nreturn nblocks;\r\n}\r\nint reiserfs_acl_chmod(struct inode *inode)\r\n{\r\nstruct reiserfs_transaction_handle th;\r\nstruct posix_acl *acl;\r\nsize_t size;\r\nint error;\r\nif (IS_PRIVATE(inode))\r\nreturn 0;\r\nif (S_ISLNK(inode->i_mode))\r\nreturn -EOPNOTSUPP;\r\nif (get_inode_sd_version(inode) == STAT_DATA_V1 ||\r\n!reiserfs_posixacl(inode->i_sb)) {\r\nreturn 0;\r\n}\r\nacl = reiserfs_get_acl(inode, ACL_TYPE_ACCESS);\r\nif (!acl)\r\nreturn 0;\r\nif (IS_ERR(acl))\r\nreturn PTR_ERR(acl);\r\nerror = posix_acl_chmod(&acl, GFP_NOFS, inode->i_mode);\r\nif (error)\r\nreturn error;\r\nsize = reiserfs_xattr_nblocks(inode, reiserfs_acl_size(acl->a_count));\r\nreiserfs_write_lock(inode->i_sb);\r\nerror = journal_begin(&th, inode->i_sb, size * 2);\r\nreiserfs_write_unlock(inode->i_sb);\r\nif (!error) {\r\nint error2;\r\nerror = reiserfs_set_acl(&th, inode, ACL_TYPE_ACCESS, acl);\r\nreiserfs_write_lock(inode->i_sb);\r\nerror2 = journal_end(&th, inode->i_sb, size * 2);\r\nreiserfs_write_unlock(inode->i_sb);\r\nif (error2)\r\nerror = error2;\r\n}\r\nposix_acl_release(acl);\r\nreturn error;\r\n}\r\nstatic size_t posix_acl_access_list(struct dentry *dentry, char *list,\r\nsize_t list_size, const char *name,\r\nsize_t name_len, int type)\r\n{\r\nconst size_t size = sizeof(POSIX_ACL_XATTR_ACCESS);\r\nif (!reiserfs_posixacl(dentry->d_sb))\r\nreturn 0;\r\nif (list && size <= list_size)\r\nmemcpy(list, POSIX_ACL_XATTR_ACCESS, size);\r\nreturn size;\r\n}\r\nstatic size_t posix_acl_default_list(struct dentry *dentry, char *list,\r\nsize_t list_size, const char *name,\r\nsize_t name_len, int type)\r\n{\r\nconst size_t size = sizeof(POSIX_ACL_XATTR_DEFAULT);\r\nif (!reiserfs_posixacl(dentry->d_sb))\r\nreturn 0;\r\nif (list && size <= list_size)\r\nmemcpy(list, POSIX_ACL_XATTR_DEFAULT, size);\r\nreturn size;\r\n}
