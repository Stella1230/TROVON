static void quirk_ppc_currituck_usb_fixup(struct pci_dev *dev)\r\n{\r\nif (of_machine_is_compatible("ibm,currituck")) {\r\npci_write_config_dword(dev, 0xe0, 0x0114231f);\r\npci_write_config_dword(dev, 0xe4, 0x00006c40);\r\n}\r\n}\r\nstatic int __init ppc47x_device_probe(void)\r\n{\r\nof_platform_bus_probe(NULL, ppc47x_of_bus, NULL);\r\nreturn 0;\r\n}\r\nstatic void __init ppc47x_init_irq(void)\r\n{\r\nstruct device_node *np;\r\nfor_each_node_with_property(np, "interrupt-controller") {\r\nif (of_get_property(np, "interrupts", NULL) == NULL)\r\nbreak;\r\n}\r\nif (np == NULL)\r\npanic("Can't find top level interrupt controller");\r\nif (of_device_is_compatible(np, "chrp,open-pic")) {\r\nstruct mpic *mpic =\r\nmpic_alloc(np, 0, MPIC_NO_RESET, 0, 0, " MPIC ");\r\nBUG_ON(mpic == NULL);\r\nmpic_init(mpic);\r\nppc_md.get_irq = mpic_get_irq;\r\n} else\r\npanic("Unrecognized top level interrupt controller");\r\n}\r\nstatic void smp_ppc47x_setup_cpu(int cpu)\r\n{\r\nmpic_setup_this_cpu();\r\n}\r\nstatic int smp_ppc47x_kick_cpu(int cpu)\r\n{\r\nstruct device_node *cpunode = of_get_cpu_node(cpu, NULL);\r\nconst u64 *spin_table_addr_prop;\r\nu32 *spin_table;\r\nextern void start_secondary_47x(void);\r\nBUG_ON(cpunode == NULL);\r\nspin_table_addr_prop =\r\nof_get_property(cpunode, "cpu-release-addr", NULL);\r\nif (spin_table_addr_prop == NULL) {\r\npr_err("CPU%d: Can't start, missing cpu-release-addr !\n",\r\ncpu);\r\nreturn 1;\r\n}\r\nspin_table = (u32 *)__va(*spin_table_addr_prop);\r\npr_debug("CPU%d: Spin table mapped at %p\n", cpu, spin_table);\r\nspin_table[3] = cpu;\r\nsmp_wmb();\r\nspin_table[1] = __pa(start_secondary_47x);\r\nmb();\r\nreturn 0;\r\n}\r\nstatic void __init ppc47x_smp_init(void)\r\n{\r\nif (mmu_has_feature(MMU_FTR_TYPE_47x))\r\nsmp_ops = &ppc47x_smp_ops;\r\n}\r\nstatic void __init ppc47x_smp_init(void) { }\r\nstatic void __init ppc47x_setup_arch(void)\r\n{\r\nswiotlb_detect_4g();\r\nppc47x_smp_init();\r\n}\r\nstatic int __init ppc47x_probe(void)\r\n{\r\nunsigned long root = of_get_flat_dt_root();\r\nif (!of_flat_dt_is_compatible(root, "ibm,currituck"))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int __init ppc47x_get_board_rev(void)\r\n{\r\nu8 fpga_reg0;\r\nvoid *fpga;\r\nstruct device_node *np;\r\nnp = of_find_compatible_node(NULL, NULL, "ibm,currituck-fpga");\r\nif (!np)\r\ngoto fail;\r\nfpga = of_iomap(np, 0);\r\nof_node_put(np);\r\nif (!fpga)\r\ngoto fail;\r\nfpga_reg0 = ioread8(fpga);\r\nboard_rev = fpga_reg0 & 0x03;\r\npr_info("%s: Found board revision %d\n", __func__, board_rev);\r\niounmap(fpga);\r\nreturn 0;\r\nfail:\r\npr_info("%s: Unable to find board revision\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void ppc47x_pci_irq_fixup(struct pci_dev *dev)\r\n{\r\nif (dev->vendor == 0x1033 && (dev->device == 0x0035 ||\r\ndev->device == 0x00e0)) {\r\nif (board_rev == 0) {\r\ndev->irq = irq_create_mapping(NULL, 47);\r\npr_info("%s: Mapping irq %d\n", __func__, dev->irq);\r\n} else if (board_rev == 2) {\r\ndev->irq = irq_create_mapping(NULL, 49);\r\npr_info("%s: Mapping irq %d\n", __func__, dev->irq);\r\n} else {\r\npr_alert("%s: Unknown board revision\n", __func__);\r\n}\r\n}\r\n}
