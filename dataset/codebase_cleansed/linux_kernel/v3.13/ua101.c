static const char *usb_error_string(int err)\r\n{\r\nswitch (err) {\r\ncase -ENODEV:\r\nreturn "no device";\r\ncase -ENOENT:\r\nreturn "endpoint not enabled";\r\ncase -EPIPE:\r\nreturn "endpoint stalled";\r\ncase -ENOSPC:\r\nreturn "not enough bandwidth";\r\ncase -ESHUTDOWN:\r\nreturn "device disabled";\r\ncase -EHOSTUNREACH:\r\nreturn "device suspended";\r\ncase -EINVAL:\r\ncase -EAGAIN:\r\ncase -EFBIG:\r\ncase -EMSGSIZE:\r\nreturn "internal error";\r\ndefault:\r\nreturn "unknown error";\r\n}\r\n}\r\nstatic void abort_usb_capture(struct ua101 *ua)\r\n{\r\nif (test_and_clear_bit(USB_CAPTURE_RUNNING, &ua->states)) {\r\nwake_up(&ua->alsa_capture_wait);\r\nwake_up(&ua->rate_feedback_wait);\r\n}\r\n}\r\nstatic void abort_usb_playback(struct ua101 *ua)\r\n{\r\nif (test_and_clear_bit(USB_PLAYBACK_RUNNING, &ua->states))\r\nwake_up(&ua->alsa_playback_wait);\r\n}\r\nstatic void playback_urb_complete(struct urb *usb_urb)\r\n{\r\nstruct ua101_urb *urb = (struct ua101_urb *)usb_urb;\r\nstruct ua101 *ua = urb->urb.context;\r\nunsigned long flags;\r\nif (unlikely(urb->urb.status == -ENOENT ||\r\nurb->urb.status == -ENODEV ||\r\nurb->urb.status == -ECONNRESET ||\r\nurb->urb.status == -ESHUTDOWN)) {\r\nabort_usb_playback(ua);\r\nabort_alsa_playback(ua);\r\nreturn;\r\n}\r\nif (test_bit(USB_PLAYBACK_RUNNING, &ua->states)) {\r\nspin_lock_irqsave(&ua->lock, flags);\r\nlist_add_tail(&urb->ready_list, &ua->ready_playback_urbs);\r\nif (ua->rate_feedback_count > 0)\r\ntasklet_schedule(&ua->playback_tasklet);\r\nua->playback.substream->runtime->delay -=\r\nurb->urb.iso_frame_desc[0].length /\r\nua->playback.frame_bytes;\r\nspin_unlock_irqrestore(&ua->lock, flags);\r\n}\r\n}\r\nstatic void first_playback_urb_complete(struct urb *urb)\r\n{\r\nstruct ua101 *ua = urb->context;\r\nurb->complete = playback_urb_complete;\r\nplayback_urb_complete(urb);\r\nset_bit(PLAYBACK_URB_COMPLETED, &ua->states);\r\nwake_up(&ua->alsa_playback_wait);\r\n}\r\nstatic bool copy_playback_data(struct ua101_stream *stream, struct urb *urb,\r\nunsigned int frames)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nunsigned int frame_bytes, frames1;\r\nconst u8 *source;\r\nruntime = stream->substream->runtime;\r\nframe_bytes = stream->frame_bytes;\r\nsource = runtime->dma_area + stream->buffer_pos * frame_bytes;\r\nif (stream->buffer_pos + frames <= runtime->buffer_size) {\r\nmemcpy(urb->transfer_buffer, source, frames * frame_bytes);\r\n} else {\r\nframes1 = runtime->buffer_size - stream->buffer_pos;\r\nmemcpy(urb->transfer_buffer, source, frames1 * frame_bytes);\r\nmemcpy(urb->transfer_buffer + frames1 * frame_bytes,\r\nruntime->dma_area, (frames - frames1) * frame_bytes);\r\n}\r\nstream->buffer_pos += frames;\r\nif (stream->buffer_pos >= runtime->buffer_size)\r\nstream->buffer_pos -= runtime->buffer_size;\r\nstream->period_pos += frames;\r\nif (stream->period_pos >= runtime->period_size) {\r\nstream->period_pos -= runtime->period_size;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic inline void add_with_wraparound(struct ua101 *ua,\r\nunsigned int *value, unsigned int add)\r\n{\r\n*value += add;\r\nif (*value >= ua->playback.queue_length)\r\n*value -= ua->playback.queue_length;\r\n}\r\nstatic void playback_tasklet(unsigned long data)\r\n{\r\nstruct ua101 *ua = (void *)data;\r\nunsigned long flags;\r\nunsigned int frames;\r\nstruct ua101_urb *urb;\r\nbool do_period_elapsed = false;\r\nint err;\r\nif (unlikely(!test_bit(USB_PLAYBACK_RUNNING, &ua->states)))\r\nreturn;\r\nspin_lock_irqsave(&ua->lock, flags);\r\nwhile (ua->rate_feedback_count > 0 &&\r\n!list_empty(&ua->ready_playback_urbs)) {\r\nframes = ua->rate_feedback[ua->rate_feedback_start];\r\nadd_with_wraparound(ua, &ua->rate_feedback_start, 1);\r\nua->rate_feedback_count--;\r\nurb = list_first_entry(&ua->ready_playback_urbs,\r\nstruct ua101_urb, ready_list);\r\nlist_del(&urb->ready_list);\r\nurb->urb.iso_frame_desc[0].length =\r\nframes * ua->playback.frame_bytes;\r\nif (test_bit(ALSA_PLAYBACK_RUNNING, &ua->states))\r\ndo_period_elapsed |= copy_playback_data(&ua->playback,\r\n&urb->urb,\r\nframes);\r\nelse\r\nmemset(urb->urb.transfer_buffer, 0,\r\nurb->urb.iso_frame_desc[0].length);\r\nerr = usb_submit_urb(&urb->urb, GFP_ATOMIC);\r\nif (unlikely(err < 0)) {\r\nspin_unlock_irqrestore(&ua->lock, flags);\r\nabort_usb_playback(ua);\r\nabort_alsa_playback(ua);\r\ndev_err(&ua->dev->dev, "USB request error %d: %s\n",\r\nerr, usb_error_string(err));\r\nreturn;\r\n}\r\nua->playback.substream->runtime->delay += frames;\r\n}\r\nspin_unlock_irqrestore(&ua->lock, flags);\r\nif (do_period_elapsed)\r\nsnd_pcm_period_elapsed(ua->playback.substream);\r\n}\r\nstatic bool copy_capture_data(struct ua101_stream *stream, struct urb *urb,\r\nunsigned int frames)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nunsigned int frame_bytes, frames1;\r\nu8 *dest;\r\nruntime = stream->substream->runtime;\r\nframe_bytes = stream->frame_bytes;\r\ndest = runtime->dma_area + stream->buffer_pos * frame_bytes;\r\nif (stream->buffer_pos + frames <= runtime->buffer_size) {\r\nmemcpy(dest, urb->transfer_buffer, frames * frame_bytes);\r\n} else {\r\nframes1 = runtime->buffer_size - stream->buffer_pos;\r\nmemcpy(dest, urb->transfer_buffer, frames1 * frame_bytes);\r\nmemcpy(runtime->dma_area,\r\nurb->transfer_buffer + frames1 * frame_bytes,\r\n(frames - frames1) * frame_bytes);\r\n}\r\nstream->buffer_pos += frames;\r\nif (stream->buffer_pos >= runtime->buffer_size)\r\nstream->buffer_pos -= runtime->buffer_size;\r\nstream->period_pos += frames;\r\nif (stream->period_pos >= runtime->period_size) {\r\nstream->period_pos -= runtime->period_size;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void capture_urb_complete(struct urb *urb)\r\n{\r\nstruct ua101 *ua = urb->context;\r\nstruct ua101_stream *stream = &ua->capture;\r\nunsigned long flags;\r\nunsigned int frames, write_ptr;\r\nbool do_period_elapsed;\r\nint err;\r\nif (unlikely(urb->status == -ENOENT ||\r\nurb->status == -ENODEV ||\r\nurb->status == -ECONNRESET ||\r\nurb->status == -ESHUTDOWN))\r\ngoto stream_stopped;\r\nif (urb->status >= 0 && urb->iso_frame_desc[0].status >= 0)\r\nframes = urb->iso_frame_desc[0].actual_length /\r\nstream->frame_bytes;\r\nelse\r\nframes = 0;\r\nspin_lock_irqsave(&ua->lock, flags);\r\nif (frames > 0 && test_bit(ALSA_CAPTURE_RUNNING, &ua->states))\r\ndo_period_elapsed = copy_capture_data(stream, urb, frames);\r\nelse\r\ndo_period_elapsed = false;\r\nif (test_bit(USB_CAPTURE_RUNNING, &ua->states)) {\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (unlikely(err < 0)) {\r\nspin_unlock_irqrestore(&ua->lock, flags);\r\ndev_err(&ua->dev->dev, "USB request error %d: %s\n",\r\nerr, usb_error_string(err));\r\ngoto stream_stopped;\r\n}\r\nwrite_ptr = ua->rate_feedback_start;\r\nadd_with_wraparound(ua, &write_ptr, ua->rate_feedback_count);\r\nua->rate_feedback[write_ptr] = frames;\r\nif (ua->rate_feedback_count < ua->playback.queue_length) {\r\nua->rate_feedback_count++;\r\nif (ua->rate_feedback_count ==\r\nua->playback.queue_length)\r\nwake_up(&ua->rate_feedback_wait);\r\n} else {\r\nadd_with_wraparound(ua, &ua->rate_feedback_start, 1);\r\n}\r\nif (test_bit(USB_PLAYBACK_RUNNING, &ua->states) &&\r\n!list_empty(&ua->ready_playback_urbs))\r\ntasklet_schedule(&ua->playback_tasklet);\r\n}\r\nspin_unlock_irqrestore(&ua->lock, flags);\r\nif (do_period_elapsed)\r\nsnd_pcm_period_elapsed(stream->substream);\r\nreturn;\r\nstream_stopped:\r\nabort_usb_playback(ua);\r\nabort_usb_capture(ua);\r\nabort_alsa_playback(ua);\r\nabort_alsa_capture(ua);\r\n}\r\nstatic void first_capture_urb_complete(struct urb *urb)\r\n{\r\nstruct ua101 *ua = urb->context;\r\nurb->complete = capture_urb_complete;\r\ncapture_urb_complete(urb);\r\nset_bit(CAPTURE_URB_COMPLETED, &ua->states);\r\nwake_up(&ua->alsa_capture_wait);\r\n}\r\nstatic int submit_stream_urbs(struct ua101 *ua, struct ua101_stream *stream)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < stream->queue_length; ++i) {\r\nint err = usb_submit_urb(&stream->urbs[i]->urb, GFP_KERNEL);\r\nif (err < 0) {\r\ndev_err(&ua->dev->dev, "USB request error %d: %s\n",\r\nerr, usb_error_string(err));\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void kill_stream_urbs(struct ua101_stream *stream)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < stream->queue_length; ++i)\r\nif (stream->urbs[i])\r\nusb_kill_urb(&stream->urbs[i]->urb);\r\n}\r\nstatic int enable_iso_interface(struct ua101 *ua, unsigned int intf_index)\r\n{\r\nstruct usb_host_interface *alts;\r\nalts = ua->intf[intf_index]->cur_altsetting;\r\nif (alts->desc.bAlternateSetting != 1) {\r\nint err = usb_set_interface(ua->dev,\r\nalts->desc.bInterfaceNumber, 1);\r\nif (err < 0) {\r\ndev_err(&ua->dev->dev,\r\n"cannot initialize interface; error %d: %s\n",\r\nerr, usb_error_string(err));\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void disable_iso_interface(struct ua101 *ua, unsigned int intf_index)\r\n{\r\nstruct usb_host_interface *alts;\r\nif (!ua->intf[intf_index])\r\nreturn;\r\nalts = ua->intf[intf_index]->cur_altsetting;\r\nif (alts->desc.bAlternateSetting != 0) {\r\nint err = usb_set_interface(ua->dev,\r\nalts->desc.bInterfaceNumber, 0);\r\nif (err < 0 && !test_bit(DISCONNECTED, &ua->states))\r\ndev_warn(&ua->dev->dev,\r\n"interface reset failed; error %d: %s\n",\r\nerr, usb_error_string(err));\r\n}\r\n}\r\nstatic void stop_usb_capture(struct ua101 *ua)\r\n{\r\nclear_bit(USB_CAPTURE_RUNNING, &ua->states);\r\nkill_stream_urbs(&ua->capture);\r\ndisable_iso_interface(ua, INTF_CAPTURE);\r\n}\r\nstatic int start_usb_capture(struct ua101 *ua)\r\n{\r\nint err;\r\nif (test_bit(DISCONNECTED, &ua->states))\r\nreturn -ENODEV;\r\nif (test_bit(USB_CAPTURE_RUNNING, &ua->states))\r\nreturn 0;\r\nkill_stream_urbs(&ua->capture);\r\nerr = enable_iso_interface(ua, INTF_CAPTURE);\r\nif (err < 0)\r\nreturn err;\r\nclear_bit(CAPTURE_URB_COMPLETED, &ua->states);\r\nua->capture.urbs[0]->urb.complete = first_capture_urb_complete;\r\nua->rate_feedback_start = 0;\r\nua->rate_feedback_count = 0;\r\nset_bit(USB_CAPTURE_RUNNING, &ua->states);\r\nerr = submit_stream_urbs(ua, &ua->capture);\r\nif (err < 0)\r\nstop_usb_capture(ua);\r\nreturn err;\r\n}\r\nstatic void stop_usb_playback(struct ua101 *ua)\r\n{\r\nclear_bit(USB_PLAYBACK_RUNNING, &ua->states);\r\nkill_stream_urbs(&ua->playback);\r\ntasklet_kill(&ua->playback_tasklet);\r\ndisable_iso_interface(ua, INTF_PLAYBACK);\r\n}\r\nstatic int start_usb_playback(struct ua101 *ua)\r\n{\r\nunsigned int i, frames;\r\nstruct urb *urb;\r\nint err = 0;\r\nif (test_bit(DISCONNECTED, &ua->states))\r\nreturn -ENODEV;\r\nif (test_bit(USB_PLAYBACK_RUNNING, &ua->states))\r\nreturn 0;\r\nkill_stream_urbs(&ua->playback);\r\ntasklet_kill(&ua->playback_tasklet);\r\nerr = enable_iso_interface(ua, INTF_PLAYBACK);\r\nif (err < 0)\r\nreturn err;\r\nclear_bit(PLAYBACK_URB_COMPLETED, &ua->states);\r\nua->playback.urbs[0]->urb.complete =\r\nfirst_playback_urb_complete;\r\nspin_lock_irq(&ua->lock);\r\nINIT_LIST_HEAD(&ua->ready_playback_urbs);\r\nspin_unlock_irq(&ua->lock);\r\nwait_event(ua->rate_feedback_wait,\r\nua->rate_feedback_count >= ua->playback.queue_length ||\r\n!test_bit(USB_CAPTURE_RUNNING, &ua->states) ||\r\ntest_bit(DISCONNECTED, &ua->states));\r\nif (test_bit(DISCONNECTED, &ua->states)) {\r\nstop_usb_playback(ua);\r\nreturn -ENODEV;\r\n}\r\nif (!test_bit(USB_CAPTURE_RUNNING, &ua->states)) {\r\nstop_usb_playback(ua);\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < ua->playback.queue_length; ++i) {\r\nspin_lock_irq(&ua->lock);\r\nframes = ua->rate_feedback[ua->rate_feedback_start];\r\nadd_with_wraparound(ua, &ua->rate_feedback_start, 1);\r\nua->rate_feedback_count--;\r\nspin_unlock_irq(&ua->lock);\r\nurb = &ua->playback.urbs[i]->urb;\r\nurb->iso_frame_desc[0].length =\r\nframes * ua->playback.frame_bytes;\r\nmemset(urb->transfer_buffer, 0,\r\nurb->iso_frame_desc[0].length);\r\n}\r\nset_bit(USB_PLAYBACK_RUNNING, &ua->states);\r\nerr = submit_stream_urbs(ua, &ua->playback);\r\nif (err < 0)\r\nstop_usb_playback(ua);\r\nreturn err;\r\n}\r\nstatic void abort_alsa_capture(struct ua101 *ua)\r\n{\r\nunsigned long flags;\r\nif (test_bit(ALSA_CAPTURE_RUNNING, &ua->states)) {\r\nsnd_pcm_stream_lock_irqsave(ua->capture.substream, flags);\r\nsnd_pcm_stop(ua->capture.substream, SNDRV_PCM_STATE_XRUN);\r\nsnd_pcm_stream_unlock_irqrestore(ua->capture.substream, flags);\r\n}\r\n}\r\nstatic void abort_alsa_playback(struct ua101 *ua)\r\n{\r\nunsigned long flags;\r\nif (test_bit(ALSA_PLAYBACK_RUNNING, &ua->states)) {\r\nsnd_pcm_stream_lock_irqsave(ua->playback.substream, flags);\r\nsnd_pcm_stop(ua->playback.substream, SNDRV_PCM_STATE_XRUN);\r\nsnd_pcm_stream_unlock_irqrestore(ua->playback.substream, flags);\r\n}\r\n}\r\nstatic int set_stream_hw(struct ua101 *ua, struct snd_pcm_substream *substream,\r\nunsigned int channels)\r\n{\r\nint err;\r\nsubstream->runtime->hw.info =\r\nSNDRV_PCM_INFO_MMAP |\r\nSNDRV_PCM_INFO_MMAP_VALID |\r\nSNDRV_PCM_INFO_BATCH |\r\nSNDRV_PCM_INFO_INTERLEAVED |\r\nSNDRV_PCM_INFO_BLOCK_TRANSFER |\r\nSNDRV_PCM_INFO_FIFO_IN_FRAMES;\r\nsubstream->runtime->hw.formats = ua->format_bit;\r\nsubstream->runtime->hw.rates = snd_pcm_rate_to_rate_bit(ua->rate);\r\nsubstream->runtime->hw.rate_min = ua->rate;\r\nsubstream->runtime->hw.rate_max = ua->rate;\r\nsubstream->runtime->hw.channels_min = channels;\r\nsubstream->runtime->hw.channels_max = channels;\r\nsubstream->runtime->hw.buffer_bytes_max = 45000 * 1024;\r\nsubstream->runtime->hw.period_bytes_min = 1;\r\nsubstream->runtime->hw.period_bytes_max = UINT_MAX;\r\nsubstream->runtime->hw.periods_min = 2;\r\nsubstream->runtime->hw.periods_max = UINT_MAX;\r\nerr = snd_pcm_hw_constraint_minmax(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_PERIOD_TIME,\r\n1500000 / ua->packets_per_second,\r\nUINT_MAX);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_constraint_msbits(substream->runtime, 0, 32, 24);\r\nreturn err;\r\n}\r\nstatic int capture_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct ua101 *ua = substream->private_data;\r\nint err;\r\nua->capture.substream = substream;\r\nerr = set_stream_hw(ua, substream, ua->capture.channels);\r\nif (err < 0)\r\nreturn err;\r\nsubstream->runtime->hw.fifo_size =\r\nDIV_ROUND_CLOSEST(ua->rate, ua->packets_per_second);\r\nsubstream->runtime->delay = substream->runtime->hw.fifo_size;\r\nmutex_lock(&ua->mutex);\r\nerr = start_usb_capture(ua);\r\nif (err >= 0)\r\nset_bit(ALSA_CAPTURE_OPEN, &ua->states);\r\nmutex_unlock(&ua->mutex);\r\nreturn err;\r\n}\r\nstatic int playback_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct ua101 *ua = substream->private_data;\r\nint err;\r\nua->playback.substream = substream;\r\nerr = set_stream_hw(ua, substream, ua->playback.channels);\r\nif (err < 0)\r\nreturn err;\r\nsubstream->runtime->hw.fifo_size =\r\nDIV_ROUND_CLOSEST(ua->rate * ua->playback.queue_length,\r\nua->packets_per_second);\r\nmutex_lock(&ua->mutex);\r\nerr = start_usb_capture(ua);\r\nif (err < 0)\r\ngoto error;\r\nerr = start_usb_playback(ua);\r\nif (err < 0) {\r\nif (!test_bit(ALSA_CAPTURE_OPEN, &ua->states))\r\nstop_usb_capture(ua);\r\ngoto error;\r\n}\r\nset_bit(ALSA_PLAYBACK_OPEN, &ua->states);\r\nerror:\r\nmutex_unlock(&ua->mutex);\r\nreturn err;\r\n}\r\nstatic int capture_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct ua101 *ua = substream->private_data;\r\nmutex_lock(&ua->mutex);\r\nclear_bit(ALSA_CAPTURE_OPEN, &ua->states);\r\nif (!test_bit(ALSA_PLAYBACK_OPEN, &ua->states))\r\nstop_usb_capture(ua);\r\nmutex_unlock(&ua->mutex);\r\nreturn 0;\r\n}\r\nstatic int playback_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct ua101 *ua = substream->private_data;\r\nmutex_lock(&ua->mutex);\r\nstop_usb_playback(ua);\r\nclear_bit(ALSA_PLAYBACK_OPEN, &ua->states);\r\nif (!test_bit(ALSA_CAPTURE_OPEN, &ua->states))\r\nstop_usb_capture(ua);\r\nmutex_unlock(&ua->mutex);\r\nreturn 0;\r\n}\r\nstatic int capture_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct ua101 *ua = substream->private_data;\r\nint err;\r\nmutex_lock(&ua->mutex);\r\nerr = start_usb_capture(ua);\r\nmutex_unlock(&ua->mutex);\r\nif (err < 0)\r\nreturn err;\r\nreturn snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int playback_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct ua101 *ua = substream->private_data;\r\nint err;\r\nmutex_lock(&ua->mutex);\r\nerr = start_usb_capture(ua);\r\nif (err >= 0)\r\nerr = start_usb_playback(ua);\r\nmutex_unlock(&ua->mutex);\r\nif (err < 0)\r\nreturn err;\r\nreturn snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int ua101_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int capture_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct ua101 *ua = substream->private_data;\r\nint err;\r\nmutex_lock(&ua->mutex);\r\nerr = start_usb_capture(ua);\r\nmutex_unlock(&ua->mutex);\r\nif (err < 0)\r\nreturn err;\r\nwait_event(ua->alsa_capture_wait,\r\ntest_bit(CAPTURE_URB_COMPLETED, &ua->states) ||\r\n!test_bit(USB_CAPTURE_RUNNING, &ua->states));\r\nif (test_bit(DISCONNECTED, &ua->states))\r\nreturn -ENODEV;\r\nif (!test_bit(USB_CAPTURE_RUNNING, &ua->states))\r\nreturn -EIO;\r\nua->capture.period_pos = 0;\r\nua->capture.buffer_pos = 0;\r\nreturn 0;\r\n}\r\nstatic int playback_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct ua101 *ua = substream->private_data;\r\nint err;\r\nmutex_lock(&ua->mutex);\r\nerr = start_usb_capture(ua);\r\nif (err >= 0)\r\nerr = start_usb_playback(ua);\r\nmutex_unlock(&ua->mutex);\r\nif (err < 0)\r\nreturn err;\r\nwait_event(ua->alsa_playback_wait,\r\ntest_bit(PLAYBACK_URB_COMPLETED, &ua->states) ||\r\n!test_bit(USB_PLAYBACK_RUNNING, &ua->states));\r\nif (test_bit(DISCONNECTED, &ua->states))\r\nreturn -ENODEV;\r\nif (!test_bit(USB_PLAYBACK_RUNNING, &ua->states))\r\nreturn -EIO;\r\nsubstream->runtime->delay = 0;\r\nua->playback.period_pos = 0;\r\nua->playback.buffer_pos = 0;\r\nreturn 0;\r\n}\r\nstatic int capture_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct ua101 *ua = substream->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif (!test_bit(USB_CAPTURE_RUNNING, &ua->states))\r\nreturn -EIO;\r\nset_bit(ALSA_CAPTURE_RUNNING, &ua->states);\r\nreturn 0;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nclear_bit(ALSA_CAPTURE_RUNNING, &ua->states);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int playback_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct ua101 *ua = substream->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif (!test_bit(USB_PLAYBACK_RUNNING, &ua->states))\r\nreturn -EIO;\r\nset_bit(ALSA_PLAYBACK_RUNNING, &ua->states);\r\nreturn 0;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nclear_bit(ALSA_PLAYBACK_RUNNING, &ua->states);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline snd_pcm_uframes_t ua101_pcm_pointer(struct ua101 *ua,\r\nstruct ua101_stream *stream)\r\n{\r\nunsigned long flags;\r\nunsigned int pos;\r\nspin_lock_irqsave(&ua->lock, flags);\r\npos = stream->buffer_pos;\r\nspin_unlock_irqrestore(&ua->lock, flags);\r\nreturn pos;\r\n}\r\nstatic snd_pcm_uframes_t capture_pcm_pointer(struct snd_pcm_substream *subs)\r\n{\r\nstruct ua101 *ua = subs->private_data;\r\nreturn ua101_pcm_pointer(ua, &ua->capture);\r\n}\r\nstatic snd_pcm_uframes_t playback_pcm_pointer(struct snd_pcm_substream *subs)\r\n{\r\nstruct ua101 *ua = subs->private_data;\r\nreturn ua101_pcm_pointer(ua, &ua->playback);\r\n}\r\nstatic const struct uac_format_type_i_discrete_descriptor *\r\nfind_format_descriptor(struct usb_interface *interface)\r\n{\r\nstruct usb_host_interface *alt;\r\nu8 *extra;\r\nint extralen;\r\nif (interface->num_altsetting != 2) {\r\ndev_err(&interface->dev, "invalid num_altsetting\n");\r\nreturn NULL;\r\n}\r\nalt = &interface->altsetting[0];\r\nif (alt->desc.bNumEndpoints != 0) {\r\ndev_err(&interface->dev, "invalid bNumEndpoints\n");\r\nreturn NULL;\r\n}\r\nalt = &interface->altsetting[1];\r\nif (alt->desc.bNumEndpoints != 1) {\r\ndev_err(&interface->dev, "invalid bNumEndpoints\n");\r\nreturn NULL;\r\n}\r\nextra = alt->extra;\r\nextralen = alt->extralen;\r\nwhile (extralen >= sizeof(struct usb_descriptor_header)) {\r\nstruct uac_format_type_i_discrete_descriptor *desc;\r\ndesc = (struct uac_format_type_i_discrete_descriptor *)extra;\r\nif (desc->bLength > extralen) {\r\ndev_err(&interface->dev, "descriptor overflow\n");\r\nreturn NULL;\r\n}\r\nif (desc->bLength == UAC_FORMAT_TYPE_I_DISCRETE_DESC_SIZE(1) &&\r\ndesc->bDescriptorType == USB_DT_CS_INTERFACE &&\r\ndesc->bDescriptorSubtype == UAC_FORMAT_TYPE) {\r\nif (desc->bFormatType != UAC_FORMAT_TYPE_I_PCM ||\r\ndesc->bSamFreqType != 1) {\r\ndev_err(&interface->dev,\r\n"invalid format type\n");\r\nreturn NULL;\r\n}\r\nreturn desc;\r\n}\r\nextralen -= desc->bLength;\r\nextra += desc->bLength;\r\n}\r\ndev_err(&interface->dev, "sample format descriptor not found\n");\r\nreturn NULL;\r\n}\r\nstatic int detect_usb_format(struct ua101 *ua)\r\n{\r\nconst struct uac_format_type_i_discrete_descriptor *fmt_capture;\r\nconst struct uac_format_type_i_discrete_descriptor *fmt_playback;\r\nconst struct usb_endpoint_descriptor *epd;\r\nunsigned int rate2;\r\nfmt_capture = find_format_descriptor(ua->intf[INTF_CAPTURE]);\r\nfmt_playback = find_format_descriptor(ua->intf[INTF_PLAYBACK]);\r\nif (!fmt_capture || !fmt_playback)\r\nreturn -ENXIO;\r\nswitch (fmt_capture->bSubframeSize) {\r\ncase 3:\r\nua->format_bit = SNDRV_PCM_FMTBIT_S24_3LE;\r\nbreak;\r\ncase 4:\r\nua->format_bit = SNDRV_PCM_FMTBIT_S32_LE;\r\nbreak;\r\ndefault:\r\ndev_err(&ua->dev->dev, "sample width is not 24 or 32 bits\n");\r\nreturn -ENXIO;\r\n}\r\nif (fmt_capture->bSubframeSize != fmt_playback->bSubframeSize) {\r\ndev_err(&ua->dev->dev,\r\n"playback/capture sample widths do not match\n");\r\nreturn -ENXIO;\r\n}\r\nif (fmt_capture->bBitResolution != 24 ||\r\nfmt_playback->bBitResolution != 24) {\r\ndev_err(&ua->dev->dev, "sample width is not 24 bits\n");\r\nreturn -ENXIO;\r\n}\r\nua->rate = combine_triple(fmt_capture->tSamFreq[0]);\r\nrate2 = combine_triple(fmt_playback->tSamFreq[0]);\r\nif (ua->rate != rate2) {\r\ndev_err(&ua->dev->dev,\r\n"playback/capture rates do not match: %u/%u\n",\r\nrate2, ua->rate);\r\nreturn -ENXIO;\r\n}\r\nswitch (ua->dev->speed) {\r\ncase USB_SPEED_FULL:\r\nua->packets_per_second = 1000;\r\nbreak;\r\ncase USB_SPEED_HIGH:\r\nua->packets_per_second = 8000;\r\nbreak;\r\ndefault:\r\ndev_err(&ua->dev->dev, "unknown device speed\n");\r\nreturn -ENXIO;\r\n}\r\nua->capture.channels = fmt_capture->bNrChannels;\r\nua->playback.channels = fmt_playback->bNrChannels;\r\nua->capture.frame_bytes =\r\nfmt_capture->bSubframeSize * ua->capture.channels;\r\nua->playback.frame_bytes =\r\nfmt_playback->bSubframeSize * ua->playback.channels;\r\nepd = &ua->intf[INTF_CAPTURE]->altsetting[1].endpoint[0].desc;\r\nif (!usb_endpoint_is_isoc_in(epd)) {\r\ndev_err(&ua->dev->dev, "invalid capture endpoint\n");\r\nreturn -ENXIO;\r\n}\r\nua->capture.usb_pipe = usb_rcvisocpipe(ua->dev, usb_endpoint_num(epd));\r\nua->capture.max_packet_bytes = le16_to_cpu(epd->wMaxPacketSize);\r\nepd = &ua->intf[INTF_PLAYBACK]->altsetting[1].endpoint[0].desc;\r\nif (!usb_endpoint_is_isoc_out(epd)) {\r\ndev_err(&ua->dev->dev, "invalid playback endpoint\n");\r\nreturn -ENXIO;\r\n}\r\nua->playback.usb_pipe = usb_sndisocpipe(ua->dev, usb_endpoint_num(epd));\r\nua->playback.max_packet_bytes = le16_to_cpu(epd->wMaxPacketSize);\r\nreturn 0;\r\n}\r\nstatic int alloc_stream_buffers(struct ua101 *ua, struct ua101_stream *stream)\r\n{\r\nunsigned int remaining_packets, packets, packets_per_page, i;\r\nsize_t size;\r\nstream->queue_length = queue_length;\r\nstream->queue_length = max(stream->queue_length,\r\n(unsigned int)MIN_QUEUE_LENGTH);\r\nstream->queue_length = min(stream->queue_length,\r\n(unsigned int)MAX_QUEUE_LENGTH);\r\nremaining_packets = stream->queue_length;\r\npackets_per_page = PAGE_SIZE / stream->max_packet_bytes;\r\nfor (i = 0; i < ARRAY_SIZE(stream->buffers); ++i) {\r\npackets = min(remaining_packets, packets_per_page);\r\nsize = packets * stream->max_packet_bytes;\r\nstream->buffers[i].addr =\r\nusb_alloc_coherent(ua->dev, size, GFP_KERNEL,\r\n&stream->buffers[i].dma);\r\nif (!stream->buffers[i].addr)\r\nreturn -ENOMEM;\r\nstream->buffers[i].size = size;\r\nremaining_packets -= packets;\r\nif (!remaining_packets)\r\nbreak;\r\n}\r\nif (remaining_packets) {\r\ndev_err(&ua->dev->dev, "too many packets\n");\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void free_stream_buffers(struct ua101 *ua, struct ua101_stream *stream)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(stream->buffers); ++i)\r\nusb_free_coherent(ua->dev,\r\nstream->buffers[i].size,\r\nstream->buffers[i].addr,\r\nstream->buffers[i].dma);\r\n}\r\nstatic int alloc_stream_urbs(struct ua101 *ua, struct ua101_stream *stream,\r\nvoid (*urb_complete)(struct urb *))\r\n{\r\nunsigned max_packet_size = stream->max_packet_bytes;\r\nstruct ua101_urb *urb;\r\nunsigned int b, u = 0;\r\nfor (b = 0; b < ARRAY_SIZE(stream->buffers); ++b) {\r\nunsigned int size = stream->buffers[b].size;\r\nu8 *addr = stream->buffers[b].addr;\r\ndma_addr_t dma = stream->buffers[b].dma;\r\nwhile (size >= max_packet_size) {\r\nif (u >= stream->queue_length)\r\ngoto bufsize_error;\r\nurb = kmalloc(sizeof(*urb), GFP_KERNEL);\r\nif (!urb)\r\nreturn -ENOMEM;\r\nusb_init_urb(&urb->urb);\r\nurb->urb.dev = ua->dev;\r\nurb->urb.pipe = stream->usb_pipe;\r\nurb->urb.transfer_flags = URB_NO_TRANSFER_DMA_MAP;\r\nurb->urb.transfer_buffer = addr;\r\nurb->urb.transfer_dma = dma;\r\nurb->urb.transfer_buffer_length = max_packet_size;\r\nurb->urb.number_of_packets = 1;\r\nurb->urb.interval = 1;\r\nurb->urb.context = ua;\r\nurb->urb.complete = urb_complete;\r\nurb->urb.iso_frame_desc[0].offset = 0;\r\nurb->urb.iso_frame_desc[0].length = max_packet_size;\r\nstream->urbs[u++] = urb;\r\nsize -= max_packet_size;\r\naddr += max_packet_size;\r\ndma += max_packet_size;\r\n}\r\n}\r\nif (u == stream->queue_length)\r\nreturn 0;\r\nbufsize_error:\r\ndev_err(&ua->dev->dev, "internal buffer size error\n");\r\nreturn -ENXIO;\r\n}\r\nstatic void free_stream_urbs(struct ua101_stream *stream)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < stream->queue_length; ++i) {\r\nkfree(stream->urbs[i]);\r\nstream->urbs[i] = NULL;\r\n}\r\n}\r\nstatic void free_usb_related_resources(struct ua101 *ua,\r\nstruct usb_interface *interface)\r\n{\r\nunsigned int i;\r\nstruct usb_interface *intf;\r\nmutex_lock(&ua->mutex);\r\nfree_stream_urbs(&ua->capture);\r\nfree_stream_urbs(&ua->playback);\r\nmutex_unlock(&ua->mutex);\r\nfree_stream_buffers(ua, &ua->capture);\r\nfree_stream_buffers(ua, &ua->playback);\r\nfor (i = 0; i < ARRAY_SIZE(ua->intf); ++i) {\r\nmutex_lock(&ua->mutex);\r\nintf = ua->intf[i];\r\nua->intf[i] = NULL;\r\nmutex_unlock(&ua->mutex);\r\nif (intf) {\r\nusb_set_intfdata(intf, NULL);\r\nif (intf != interface)\r\nusb_driver_release_interface(&ua101_driver,\r\nintf);\r\n}\r\n}\r\n}\r\nstatic void ua101_card_free(struct snd_card *card)\r\n{\r\nstruct ua101 *ua = card->private_data;\r\nmutex_destroy(&ua->mutex);\r\n}\r\nstatic int ua101_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *usb_id)\r\n{\r\nstatic const struct snd_usb_midi_endpoint_info midi_ep = {\r\n.out_cables = 0x0001,\r\n.in_cables = 0x0001\r\n};\r\nstatic const struct snd_usb_audio_quirk midi_quirk = {\r\n.type = QUIRK_MIDI_FIXED_ENDPOINT,\r\n.data = &midi_ep\r\n};\r\nstatic const int intf_numbers[2][3] = {\r\n{\r\n[INTF_PLAYBACK] = 0,\r\n[INTF_CAPTURE] = 1,\r\n[INTF_MIDI] = 2,\r\n},\r\n{\r\n[INTF_CAPTURE] = 1,\r\n[INTF_PLAYBACK] = 2,\r\n[INTF_MIDI] = 3,\r\n},\r\n};\r\nstruct snd_card *card;\r\nstruct ua101 *ua;\r\nunsigned int card_index, i;\r\nint is_ua1000;\r\nconst char *name;\r\nchar usb_path[32];\r\nint err;\r\nis_ua1000 = usb_id->idProduct == 0x0044;\r\nif (interface->altsetting->desc.bInterfaceNumber !=\r\nintf_numbers[is_ua1000][0])\r\nreturn -ENODEV;\r\nmutex_lock(&devices_mutex);\r\nfor (card_index = 0; card_index < SNDRV_CARDS; ++card_index)\r\nif (enable[card_index] && !(devices_used & (1 << card_index)))\r\nbreak;\r\nif (card_index >= SNDRV_CARDS) {\r\nmutex_unlock(&devices_mutex);\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_create(index[card_index], id[card_index], THIS_MODULE,\r\nsizeof(*ua), &card);\r\nif (err < 0) {\r\nmutex_unlock(&devices_mutex);\r\nreturn err;\r\n}\r\ncard->private_free = ua101_card_free;\r\nua = card->private_data;\r\nua->dev = interface_to_usbdev(interface);\r\nua->card = card;\r\nua->card_index = card_index;\r\nINIT_LIST_HEAD(&ua->midi_list);\r\nspin_lock_init(&ua->lock);\r\nmutex_init(&ua->mutex);\r\nINIT_LIST_HEAD(&ua->ready_playback_urbs);\r\ntasklet_init(&ua->playback_tasklet,\r\nplayback_tasklet, (unsigned long)ua);\r\ninit_waitqueue_head(&ua->alsa_capture_wait);\r\ninit_waitqueue_head(&ua->rate_feedback_wait);\r\ninit_waitqueue_head(&ua->alsa_playback_wait);\r\nua->intf[0] = interface;\r\nfor (i = 1; i < ARRAY_SIZE(ua->intf); ++i) {\r\nua->intf[i] = usb_ifnum_to_if(ua->dev,\r\nintf_numbers[is_ua1000][i]);\r\nif (!ua->intf[i]) {\r\ndev_err(&ua->dev->dev, "interface %u not found\n",\r\nintf_numbers[is_ua1000][i]);\r\nerr = -ENXIO;\r\ngoto probe_error;\r\n}\r\nerr = usb_driver_claim_interface(&ua101_driver,\r\nua->intf[i], ua);\r\nif (err < 0) {\r\nua->intf[i] = NULL;\r\nerr = -EBUSY;\r\ngoto probe_error;\r\n}\r\n}\r\nsnd_card_set_dev(card, &interface->dev);\r\nerr = detect_usb_format(ua);\r\nif (err < 0)\r\ngoto probe_error;\r\nname = usb_id->idProduct == 0x0044 ? "UA-1000" : "UA-101";\r\nstrcpy(card->driver, "UA-101");\r\nstrcpy(card->shortname, name);\r\nusb_make_path(ua->dev, usb_path, sizeof(usb_path));\r\nsnprintf(ua->card->longname, sizeof(ua->card->longname),\r\n"EDIROL %s (serial %s), %u Hz at %s, %s speed", name,\r\nua->dev->serial ? ua->dev->serial : "?", ua->rate, usb_path,\r\nua->dev->speed == USB_SPEED_HIGH ? "high" : "full");\r\nerr = alloc_stream_buffers(ua, &ua->capture);\r\nif (err < 0)\r\ngoto probe_error;\r\nerr = alloc_stream_buffers(ua, &ua->playback);\r\nif (err < 0)\r\ngoto probe_error;\r\nerr = alloc_stream_urbs(ua, &ua->capture, capture_urb_complete);\r\nif (err < 0)\r\ngoto probe_error;\r\nerr = alloc_stream_urbs(ua, &ua->playback, playback_urb_complete);\r\nif (err < 0)\r\ngoto probe_error;\r\nerr = snd_pcm_new(card, name, 0, 1, 1, &ua->pcm);\r\nif (err < 0)\r\ngoto probe_error;\r\nua->pcm->private_data = ua;\r\nstrcpy(ua->pcm->name, name);\r\nsnd_pcm_set_ops(ua->pcm, SNDRV_PCM_STREAM_PLAYBACK, &playback_pcm_ops);\r\nsnd_pcm_set_ops(ua->pcm, SNDRV_PCM_STREAM_CAPTURE, &capture_pcm_ops);\r\nerr = snd_usbmidi_create(card, ua->intf[INTF_MIDI],\r\n&ua->midi_list, &midi_quirk);\r\nif (err < 0)\r\ngoto probe_error;\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto probe_error;\r\nusb_set_intfdata(interface, ua);\r\ndevices_used |= 1 << card_index;\r\nmutex_unlock(&devices_mutex);\r\nreturn 0;\r\nprobe_error:\r\nfree_usb_related_resources(ua, interface);\r\nsnd_card_free(card);\r\nmutex_unlock(&devices_mutex);\r\nreturn err;\r\n}\r\nstatic void ua101_disconnect(struct usb_interface *interface)\r\n{\r\nstruct ua101 *ua = usb_get_intfdata(interface);\r\nstruct list_head *midi;\r\nif (!ua)\r\nreturn;\r\nmutex_lock(&devices_mutex);\r\nset_bit(DISCONNECTED, &ua->states);\r\nwake_up(&ua->rate_feedback_wait);\r\nsnd_card_disconnect(ua->card);\r\nlist_for_each(midi, &ua->midi_list)\r\nsnd_usbmidi_disconnect(midi);\r\nabort_alsa_playback(ua);\r\nabort_alsa_capture(ua);\r\nmutex_lock(&ua->mutex);\r\nstop_usb_playback(ua);\r\nstop_usb_capture(ua);\r\nmutex_unlock(&ua->mutex);\r\nfree_usb_related_resources(ua, interface);\r\ndevices_used &= ~(1 << ua->card_index);\r\nsnd_card_free_when_closed(ua->card);\r\nmutex_unlock(&devices_mutex);\r\n}
