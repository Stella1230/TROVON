int cdv_sb_read(struct drm_device *dev, u32 reg, u32 *val)\r\n{\r\nint ret;\r\nret = wait_for((REG_READ(SB_PCKT) & SB_BUSY) == 0, 1000);\r\nif (ret) {\r\nDRM_ERROR("timeout waiting for SB to idle before read\n");\r\nreturn ret;\r\n}\r\nREG_WRITE(SB_ADDR, reg);\r\nREG_WRITE(SB_PCKT,\r\nSET_FIELD(SB_OPCODE_READ, SB_OPCODE) |\r\nSET_FIELD(SB_DEST_DPLL, SB_DEST) |\r\nSET_FIELD(0xf, SB_BYTE_ENABLE));\r\nret = wait_for((REG_READ(SB_PCKT) & SB_BUSY) == 0, 1000);\r\nif (ret) {\r\nDRM_ERROR("timeout waiting for SB to idle after read\n");\r\nreturn ret;\r\n}\r\n*val = REG_READ(SB_DATA);\r\nreturn 0;\r\n}\r\nint cdv_sb_write(struct drm_device *dev, u32 reg, u32 val)\r\n{\r\nint ret;\r\nstatic bool dpio_debug = true;\r\nu32 temp;\r\nif (dpio_debug) {\r\nif (cdv_sb_read(dev, reg, &temp) == 0)\r\nDRM_DEBUG_KMS("0x%08x: 0x%08x (before)\n", reg, temp);\r\nDRM_DEBUG_KMS("0x%08x: 0x%08x\n", reg, val);\r\n}\r\nret = wait_for((REG_READ(SB_PCKT) & SB_BUSY) == 0, 1000);\r\nif (ret) {\r\nDRM_ERROR("timeout waiting for SB to idle before write\n");\r\nreturn ret;\r\n}\r\nREG_WRITE(SB_ADDR, reg);\r\nREG_WRITE(SB_DATA, val);\r\nREG_WRITE(SB_PCKT,\r\nSET_FIELD(SB_OPCODE_WRITE, SB_OPCODE) |\r\nSET_FIELD(SB_DEST_DPLL, SB_DEST) |\r\nSET_FIELD(0xf, SB_BYTE_ENABLE));\r\nret = wait_for((REG_READ(SB_PCKT) & SB_BUSY) == 0, 1000);\r\nif (ret) {\r\nDRM_ERROR("timeout waiting for SB to idle after write\n");\r\nreturn ret;\r\n}\r\nif (dpio_debug) {\r\nif (cdv_sb_read(dev, reg, &temp) == 0)\r\nDRM_DEBUG_KMS("0x%08x: 0x%08x (after)\n", reg, temp);\r\n}\r\nreturn 0;\r\n}\r\nvoid cdv_sb_reset(struct drm_device *dev)\r\n{\r\nREG_WRITE(DPIO_CFG, 0);\r\nREG_READ(DPIO_CFG);\r\nREG_WRITE(DPIO_CFG, DPIO_MODE_SELECT_0 | DPIO_CMN_RESET_N);\r\n}\r\nstatic int\r\ncdv_dpll_set_clock_cdv(struct drm_device *dev, struct drm_crtc *crtc,\r\nstruct gma_clock_t *clock, bool is_lvds, u32 ddi_select)\r\n{\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nint pipe = gma_crtc->pipe;\r\nu32 m, n_vco, p;\r\nint ret = 0;\r\nint dpll_reg = (pipe == 0) ? DPLL_A : DPLL_B;\r\nint ref_sfr = (pipe == 0) ? SB_REF_DPLLA : SB_REF_DPLLB;\r\nu32 ref_value;\r\nu32 lane_reg, lane_value;\r\ncdv_sb_reset(dev);\r\nREG_WRITE(dpll_reg, DPLL_SYNCLOCK_ENABLE | DPLL_VGA_MODE_DIS);\r\nudelay(100);\r\nref_value = 0x68A701;\r\ncdv_sb_write(dev, SB_REF_SFR(pipe), ref_value);\r\nret = cdv_sb_read(dev, ref_sfr, &ref_value);\r\nif (ret)\r\nreturn ret;\r\nref_value &= ~(REF_CLK_MASK);\r\nif (pipe == 1 && !is_lvds && !(ddi_select & DP_MASK)) {\r\nDRM_DEBUG_KMS("use DPLLA for pipe B\n");\r\nref_value |= REF_CLK_DPLLA;\r\n} else {\r\nDRM_DEBUG_KMS("use their DPLL for pipe A/B\n");\r\nref_value |= REF_CLK_DPLL;\r\n}\r\nret = cdv_sb_write(dev, ref_sfr, ref_value);\r\nif (ret)\r\nreturn ret;\r\nret = cdv_sb_read(dev, SB_M(pipe), &m);\r\nif (ret)\r\nreturn ret;\r\nm &= ~SB_M_DIVIDER_MASK;\r\nm |= ((clock->m2) << SB_M_DIVIDER_SHIFT);\r\nret = cdv_sb_write(dev, SB_M(pipe), m);\r\nif (ret)\r\nreturn ret;\r\nret = cdv_sb_read(dev, SB_N_VCO(pipe), &n_vco);\r\nif (ret)\r\nreturn ret;\r\nn_vco &= 0xFFFF;\r\nn_vco |= 0x107;\r\nn_vco &= ~(SB_N_VCO_SEL_MASK |\r\nSB_N_DIVIDER_MASK |\r\nSB_N_CB_TUNE_MASK);\r\nn_vco |= ((clock->n) << SB_N_DIVIDER_SHIFT);\r\nif (clock->vco < 2250000) {\r\nn_vco |= (2 << SB_N_CB_TUNE_SHIFT);\r\nn_vco |= (0 << SB_N_VCO_SEL_SHIFT);\r\n} else if (clock->vco < 2750000) {\r\nn_vco |= (1 << SB_N_CB_TUNE_SHIFT);\r\nn_vco |= (1 << SB_N_VCO_SEL_SHIFT);\r\n} else if (clock->vco < 3300000) {\r\nn_vco |= (0 << SB_N_CB_TUNE_SHIFT);\r\nn_vco |= (2 << SB_N_VCO_SEL_SHIFT);\r\n} else {\r\nn_vco |= (0 << SB_N_CB_TUNE_SHIFT);\r\nn_vco |= (3 << SB_N_VCO_SEL_SHIFT);\r\n}\r\nret = cdv_sb_write(dev, SB_N_VCO(pipe), n_vco);\r\nif (ret)\r\nreturn ret;\r\nret = cdv_sb_read(dev, SB_P(pipe), &p);\r\nif (ret)\r\nreturn ret;\r\np &= ~(SB_P2_DIVIDER_MASK | SB_P1_DIVIDER_MASK);\r\np |= SET_FIELD(clock->p1, SB_P1_DIVIDER);\r\nswitch (clock->p2) {\r\ncase 5:\r\np |= SET_FIELD(SB_P2_5, SB_P2_DIVIDER);\r\nbreak;\r\ncase 10:\r\np |= SET_FIELD(SB_P2_10, SB_P2_DIVIDER);\r\nbreak;\r\ncase 14:\r\np |= SET_FIELD(SB_P2_14, SB_P2_DIVIDER);\r\nbreak;\r\ncase 7:\r\np |= SET_FIELD(SB_P2_7, SB_P2_DIVIDER);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Bad P2 clock: %d\n", clock->p2);\r\nreturn -EINVAL;\r\n}\r\nret = cdv_sb_write(dev, SB_P(pipe), p);\r\nif (ret)\r\nreturn ret;\r\nif (ddi_select) {\r\nif ((ddi_select & DDI_MASK) == DDI0_SELECT) {\r\nlane_reg = PSB_LANE0;\r\ncdv_sb_read(dev, lane_reg, &lane_value);\r\nlane_value &= ~(LANE_PLL_MASK);\r\nlane_value |= LANE_PLL_ENABLE | LANE_PLL_PIPE(pipe);\r\ncdv_sb_write(dev, lane_reg, lane_value);\r\nlane_reg = PSB_LANE1;\r\ncdv_sb_read(dev, lane_reg, &lane_value);\r\nlane_value &= ~(LANE_PLL_MASK);\r\nlane_value |= LANE_PLL_ENABLE | LANE_PLL_PIPE(pipe);\r\ncdv_sb_write(dev, lane_reg, lane_value);\r\n} else {\r\nlane_reg = PSB_LANE2;\r\ncdv_sb_read(dev, lane_reg, &lane_value);\r\nlane_value &= ~(LANE_PLL_MASK);\r\nlane_value |= LANE_PLL_ENABLE | LANE_PLL_PIPE(pipe);\r\ncdv_sb_write(dev, lane_reg, lane_value);\r\nlane_reg = PSB_LANE3;\r\ncdv_sb_read(dev, lane_reg, &lane_value);\r\nlane_value &= ~(LANE_PLL_MASK);\r\nlane_value |= LANE_PLL_ENABLE | LANE_PLL_PIPE(pipe);\r\ncdv_sb_write(dev, lane_reg, lane_value);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic const struct gma_limit_t *cdv_intel_limit(struct drm_crtc *crtc,\r\nint refclk)\r\n{\r\nconst struct gma_limit_t *limit;\r\nif (gma_pipe_has_type(crtc, INTEL_OUTPUT_LVDS)) {\r\nif (refclk == 96000)\r\nlimit = &cdv_intel_limits[CDV_LIMIT_SINGLE_LVDS_96];\r\nelse\r\nlimit = &cdv_intel_limits[CDV_LIMIT_SINGLE_LVDS_100];\r\n} else if (gma_pipe_has_type(crtc, INTEL_OUTPUT_DISPLAYPORT) ||\r\ngma_pipe_has_type(crtc, INTEL_OUTPUT_EDP)) {\r\nif (refclk == 27000)\r\nlimit = &cdv_intel_limits[CDV_LIMIT_DP_27];\r\nelse\r\nlimit = &cdv_intel_limits[CDV_LIMIT_DP_100];\r\n} else {\r\nif (refclk == 27000)\r\nlimit = &cdv_intel_limits[CDV_LIMIT_DAC_HDMI_27];\r\nelse\r\nlimit = &cdv_intel_limits[CDV_LIMIT_DAC_HDMI_96];\r\n}\r\nreturn limit;\r\n}\r\nstatic void cdv_intel_clock(int refclk, struct gma_clock_t *clock)\r\n{\r\nclock->m = clock->m2 + 2;\r\nclock->p = clock->p1 * clock->p2;\r\nclock->vco = (refclk * clock->m) / clock->n;\r\nclock->dot = clock->vco / clock->p;\r\n}\r\nstatic bool cdv_intel_find_dp_pll(const struct gma_limit_t *limit,\r\nstruct drm_crtc *crtc, int target,\r\nint refclk,\r\nstruct gma_clock_t *best_clock)\r\n{\r\nstruct gma_clock_t clock;\r\nif (refclk == 27000) {\r\nif (target < 200000) {\r\nclock.p1 = 2;\r\nclock.p2 = 10;\r\nclock.n = 1;\r\nclock.m1 = 0;\r\nclock.m2 = 118;\r\n} else {\r\nclock.p1 = 1;\r\nclock.p2 = 10;\r\nclock.n = 1;\r\nclock.m1 = 0;\r\nclock.m2 = 98;\r\n}\r\n} else if (refclk == 100000) {\r\nif (target < 200000) {\r\nclock.p1 = 2;\r\nclock.p2 = 10;\r\nclock.n = 5;\r\nclock.m1 = 0;\r\nclock.m2 = 160;\r\n} else {\r\nclock.p1 = 1;\r\nclock.p2 = 10;\r\nclock.n = 5;\r\nclock.m1 = 0;\r\nclock.m2 = 133;\r\n}\r\n} else\r\nreturn false;\r\nclock.m = clock.m2 + 2;\r\nclock.p = clock.p1 * clock.p2;\r\nclock.vco = (refclk * clock.m) / clock.n;\r\nclock.dot = clock.vco / clock.p;\r\nmemcpy(best_clock, &clock, sizeof(struct gma_clock_t));\r\nreturn true;\r\n}\r\nstatic bool cdv_intel_pipe_enabled(struct drm_device *dev, int pipe)\r\n{\r\nstruct drm_crtc *crtc;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct gma_crtc *gma_crtc = NULL;\r\ncrtc = dev_priv->pipe_to_crtc_mapping[pipe];\r\ngma_crtc = to_gma_crtc(crtc);\r\nif (crtc->fb == NULL || !gma_crtc->active)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool cdv_intel_single_pipe_active (struct drm_device *dev)\r\n{\r\nuint32_t pipe_enabled = 0;\r\nif (cdv_intel_pipe_enabled(dev, 0))\r\npipe_enabled |= FIFO_PIPEA;\r\nif (cdv_intel_pipe_enabled(dev, 1))\r\npipe_enabled |= FIFO_PIPEB;\r\nDRM_DEBUG_KMS("pipe enabled %x\n", pipe_enabled);\r\nif (pipe_enabled == FIFO_PIPEA || pipe_enabled == FIFO_PIPEB)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic bool is_pipeb_lvds(struct drm_device *dev, struct drm_crtc *crtc)\r\n{\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nstruct drm_connector *connector;\r\nif (gma_crtc->pipe != 1)\r\nreturn false;\r\nlist_for_each_entry(connector, &mode_config->connector_list, head) {\r\nstruct gma_encoder *gma_encoder =\r\ngma_attached_encoder(connector);\r\nif (!connector->encoder\r\n|| connector->encoder->crtc != crtc)\r\ncontinue;\r\nif (gma_encoder->type == INTEL_OUTPUT_LVDS)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid cdv_disable_sr(struct drm_device *dev)\r\n{\r\nif (REG_READ(FW_BLC_SELF) & FW_BLC_SELF_EN) {\r\nREG_WRITE(FW_BLC_SELF, (REG_READ(FW_BLC_SELF) & ~FW_BLC_SELF_EN));\r\nREG_READ(FW_BLC_SELF);\r\ngma_wait_for_vblank(dev);\r\nREG_WRITE(OV_OVADD, 0);\r\nREG_READ(OV_OVADD);\r\ngma_wait_for_vblank(dev);\r\n}\r\n}\r\nvoid cdv_update_wm(struct drm_device *dev, struct drm_crtc *crtc)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (cdv_intel_single_pipe_active(dev)) {\r\nu32 fw;\r\nfw = REG_READ(DSPFW1);\r\nfw &= ~DSP_FIFO_SR_WM_MASK;\r\nfw |= (0x7e << DSP_FIFO_SR_WM_SHIFT);\r\nfw &= ~CURSOR_B_FIFO_WM_MASK;\r\nfw |= (0x4 << CURSOR_B_FIFO_WM_SHIFT);\r\nREG_WRITE(DSPFW1, fw);\r\nfw = REG_READ(DSPFW2);\r\nfw &= ~CURSOR_A_FIFO_WM_MASK;\r\nfw |= (0x6 << CURSOR_A_FIFO_WM_SHIFT);\r\nfw &= ~DSP_PLANE_C_FIFO_WM_MASK;\r\nfw |= (0x8 << DSP_PLANE_C_FIFO_WM_SHIFT);\r\nREG_WRITE(DSPFW2, fw);\r\nREG_WRITE(DSPFW3, 0x36000000);\r\nif (is_pipeb_lvds(dev, crtc)) {\r\nREG_WRITE(DSPFW5, 0x00040330);\r\n} else {\r\nfw = (3 << DSP_PLANE_B_FIFO_WM1_SHIFT) |\r\n(4 << DSP_PLANE_A_FIFO_WM1_SHIFT) |\r\n(3 << CURSOR_B_FIFO_WM1_SHIFT) |\r\n(4 << CURSOR_FIFO_SR_WM1_SHIFT);\r\nREG_WRITE(DSPFW5, fw);\r\n}\r\nREG_WRITE(DSPFW6, 0x10);\r\ngma_wait_for_vblank(dev);\r\nREG_WRITE(FW_BLC_SELF, FW_BLC_SELF_EN);\r\nREG_READ(FW_BLC_SELF);\r\ngma_wait_for_vblank(dev);\r\n} else {\r\nREG_WRITE(DSPFW1, 0x3f880808);\r\nREG_WRITE(DSPFW2, 0x0b020202);\r\nREG_WRITE(DSPFW3, 0x24000000);\r\nREG_WRITE(DSPFW4, 0x08030202);\r\nREG_WRITE(DSPFW5, 0x01010101);\r\nREG_WRITE(DSPFW6, 0x1d0);\r\ngma_wait_for_vblank(dev);\r\ndev_priv->ops->disable_sr(dev);\r\n}\r\n}\r\nstatic int cdv_intel_panel_fitter_pipe(struct drm_device *dev)\r\n{\r\nu32 pfit_control;\r\npfit_control = REG_READ(PFIT_CONTROL);\r\nif ((pfit_control & PFIT_ENABLE) == 0)\r\nreturn -1;\r\nreturn (pfit_control >> 29) & 0x3;\r\n}\r\nstatic int cdv_intel_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nint pipe = gma_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nint refclk;\r\nstruct gma_clock_t clock;\r\nu32 dpll = 0, dspcntr, pipeconf;\r\nbool ok;\r\nbool is_crt = false, is_lvds = false, is_tv = false;\r\nbool is_hdmi = false, is_dp = false;\r\nstruct drm_mode_config *mode_config = &dev->mode_config;\r\nstruct drm_connector *connector;\r\nconst struct gma_limit_t *limit;\r\nu32 ddi_select = 0;\r\nbool is_edp = false;\r\nlist_for_each_entry(connector, &mode_config->connector_list, head) {\r\nstruct gma_encoder *gma_encoder =\r\ngma_attached_encoder(connector);\r\nif (!connector->encoder\r\n|| connector->encoder->crtc != crtc)\r\ncontinue;\r\nddi_select = gma_encoder->ddi_select;\r\nswitch (gma_encoder->type) {\r\ncase INTEL_OUTPUT_LVDS:\r\nis_lvds = true;\r\nbreak;\r\ncase INTEL_OUTPUT_TVOUT:\r\nis_tv = true;\r\nbreak;\r\ncase INTEL_OUTPUT_ANALOG:\r\nis_crt = true;\r\nbreak;\r\ncase INTEL_OUTPUT_HDMI:\r\nis_hdmi = true;\r\nbreak;\r\ncase INTEL_OUTPUT_DISPLAYPORT:\r\nis_dp = true;\r\nbreak;\r\ncase INTEL_OUTPUT_EDP:\r\nis_edp = true;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("invalid output type.\n");\r\nreturn 0;\r\n}\r\n}\r\nif (dev_priv->dplla_96mhz)\r\nrefclk = 96000;\r\nelse\r\nrefclk = 27000;\r\nif (is_dp || is_edp) {\r\nif (pipe == 0)\r\nrefclk = 27000;\r\nelse\r\nrefclk = 100000;\r\n}\r\nif (is_lvds && dev_priv->lvds_use_ssc) {\r\nrefclk = dev_priv->lvds_ssc_freq * 1000;\r\nDRM_DEBUG_KMS("Use SSC reference clock %d Mhz\n", dev_priv->lvds_ssc_freq);\r\n}\r\ndrm_mode_debug_printmodeline(adjusted_mode);\r\nlimit = gma_crtc->clock_funcs->limit(crtc, refclk);\r\nok = limit->find_pll(limit, crtc, adjusted_mode->clock, refclk,\r\n&clock);\r\nif (!ok) {\r\nDRM_ERROR("Couldn't find PLL settings for mode! target: %d, actual: %d",\r\nadjusted_mode->clock, clock.dot);\r\nreturn 0;\r\n}\r\ndpll = DPLL_VGA_MODE_DIS;\r\nif (is_tv) {\r\ndpll |= 3;\r\n}\r\nif (is_dp || is_edp) {\r\ncdv_intel_dp_set_m_n(crtc, mode, adjusted_mode);\r\n} else {\r\nREG_WRITE(PIPE_GMCH_DATA_M(pipe), 0);\r\nREG_WRITE(PIPE_GMCH_DATA_N(pipe), 0);\r\nREG_WRITE(PIPE_DP_LINK_M(pipe), 0);\r\nREG_WRITE(PIPE_DP_LINK_N(pipe), 0);\r\n}\r\ndpll |= DPLL_SYNCLOCK_ENABLE;\r\npipeconf = REG_READ(map->conf);\r\npipeconf &= ~(PIPE_BPC_MASK);\r\nif (is_edp) {\r\nswitch (dev_priv->edp.bpp) {\r\ncase 24:\r\npipeconf |= PIPE_8BPC;\r\nbreak;\r\ncase 18:\r\npipeconf |= PIPE_6BPC;\r\nbreak;\r\ncase 30:\r\npipeconf |= PIPE_10BPC;\r\nbreak;\r\ndefault:\r\npipeconf |= PIPE_8BPC;\r\nbreak;\r\n}\r\n} else if (is_lvds) {\r\nif ((REG_READ(LVDS) & LVDS_A3_POWER_MASK) == LVDS_A3_POWER_UP)\r\npipeconf |= PIPE_8BPC;\r\nelse\r\npipeconf |= PIPE_6BPC;\r\n} else\r\npipeconf |= PIPE_8BPC;\r\ndspcntr = DISPPLANE_GAMMA_ENABLE;\r\nif (pipe == 0)\r\ndspcntr |= DISPPLANE_SEL_PIPE_A;\r\nelse\r\ndspcntr |= DISPPLANE_SEL_PIPE_B;\r\ndspcntr |= DISPLAY_PLANE_ENABLE;\r\npipeconf |= PIPEACONF_ENABLE;\r\nREG_WRITE(map->dpll, dpll | DPLL_VGA_MODE_DIS | DPLL_SYNCLOCK_ENABLE);\r\nREG_READ(map->dpll);\r\ncdv_dpll_set_clock_cdv(dev, crtc, &clock, is_lvds, ddi_select);\r\nudelay(150);\r\nif (is_lvds) {\r\nu32 lvds = REG_READ(LVDS);\r\nlvds |=\r\nLVDS_PORT_EN | LVDS_A0A2_CLKA_POWER_UP |\r\nLVDS_PIPEB_SELECT;\r\nif (clock.p2 == 7)\r\nlvds |= LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP;\r\nelse\r\nlvds &= ~(LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP);\r\nREG_WRITE(LVDS, lvds);\r\nREG_READ(LVDS);\r\n}\r\ndpll |= DPLL_VCO_ENABLE;\r\nif (cdv_intel_panel_fitter_pipe(dev) == pipe)\r\nREG_WRITE(PFIT_CONTROL, 0);\r\nDRM_DEBUG_KMS("Mode for pipe %c:\n", pipe == 0 ? 'A' : 'B');\r\ndrm_mode_debug_printmodeline(mode);\r\nREG_WRITE(map->dpll,\r\n(REG_READ(map->dpll) & ~DPLL_LOCK) | DPLL_VCO_ENABLE);\r\nREG_READ(map->dpll);\r\nudelay(150);\r\nif (!(REG_READ(map->dpll) & DPLL_LOCK)) {\r\ndev_err(dev->dev, "Failed to get DPLL lock\n");\r\nreturn -EBUSY;\r\n}\r\n{\r\nint sdvo_pixel_multiply = adjusted_mode->clock / mode->clock;\r\nREG_WRITE(map->dpll_md, (0 << DPLL_MD_UDI_DIVIDER_SHIFT) | ((sdvo_pixel_multiply - 1) << DPLL_MD_UDI_MULTIPLIER_SHIFT));\r\n}\r\nREG_WRITE(map->htotal, (adjusted_mode->crtc_hdisplay - 1) |\r\n((adjusted_mode->crtc_htotal - 1) << 16));\r\nREG_WRITE(map->hblank, (adjusted_mode->crtc_hblank_start - 1) |\r\n((adjusted_mode->crtc_hblank_end - 1) << 16));\r\nREG_WRITE(map->hsync, (adjusted_mode->crtc_hsync_start - 1) |\r\n((adjusted_mode->crtc_hsync_end - 1) << 16));\r\nREG_WRITE(map->vtotal, (adjusted_mode->crtc_vdisplay - 1) |\r\n((adjusted_mode->crtc_vtotal - 1) << 16));\r\nREG_WRITE(map->vblank, (adjusted_mode->crtc_vblank_start - 1) |\r\n((adjusted_mode->crtc_vblank_end - 1) << 16));\r\nREG_WRITE(map->vsync, (adjusted_mode->crtc_vsync_start - 1) |\r\n((adjusted_mode->crtc_vsync_end - 1) << 16));\r\nREG_WRITE(map->size,\r\n((mode->vdisplay - 1) << 16) | (mode->hdisplay - 1));\r\nREG_WRITE(map->pos, 0);\r\nREG_WRITE(map->src,\r\n((mode->hdisplay - 1) << 16) | (mode->vdisplay - 1));\r\nREG_WRITE(map->conf, pipeconf);\r\nREG_READ(map->conf);\r\ngma_wait_for_vblank(dev);\r\nREG_WRITE(map->cntr, dspcntr);\r\n{\r\nstruct drm_crtc_helper_funcs *crtc_funcs =\r\ncrtc->helper_private;\r\ncrtc_funcs->mode_set_base(crtc, x, y, old_fb);\r\n}\r\ngma_wait_for_vblank(dev);\r\nreturn 0;\r\n}\r\nstatic void i8xx_clock(int refclk, struct gma_clock_t *clock)\r\n{\r\nclock->m = 5 * (clock->m1 + 2) + (clock->m2 + 2);\r\nclock->p = clock->p1 * clock->p2;\r\nclock->vco = refclk * clock->m / (clock->n + 2);\r\nclock->dot = clock->vco / clock->p;\r\n}\r\nstatic int cdv_intel_crtc_clock_get(struct drm_device *dev,\r\nstruct drm_crtc *crtc)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nint pipe = gma_crtc->pipe;\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nu32 dpll;\r\nu32 fp;\r\nstruct gma_clock_t clock;\r\nbool is_lvds;\r\nstruct psb_pipe *p = &dev_priv->regs.pipe[pipe];\r\nif (gma_power_begin(dev, false)) {\r\ndpll = REG_READ(map->dpll);\r\nif ((dpll & DISPLAY_RATE_SELECT_FPA1) == 0)\r\nfp = REG_READ(map->fp0);\r\nelse\r\nfp = REG_READ(map->fp1);\r\nis_lvds = (pipe == 1) && (REG_READ(LVDS) & LVDS_PORT_EN);\r\ngma_power_end(dev);\r\n} else {\r\ndpll = p->dpll;\r\nif ((dpll & DISPLAY_RATE_SELECT_FPA1) == 0)\r\nfp = p->fp0;\r\nelse\r\nfp = p->fp1;\r\nis_lvds = (pipe == 1) &&\r\n(dev_priv->regs.psb.saveLVDS & LVDS_PORT_EN);\r\n}\r\nclock.m1 = (fp & FP_M1_DIV_MASK) >> FP_M1_DIV_SHIFT;\r\nclock.m2 = (fp & FP_M2_DIV_MASK) >> FP_M2_DIV_SHIFT;\r\nclock.n = (fp & FP_N_DIV_MASK) >> FP_N_DIV_SHIFT;\r\nif (is_lvds) {\r\nclock.p1 =\r\nffs((dpll &\r\nDPLL_FPA01_P1_POST_DIV_MASK_I830_LVDS) >>\r\nDPLL_FPA01_P1_POST_DIV_SHIFT);\r\nif (clock.p1 == 0) {\r\nclock.p1 = 4;\r\ndev_err(dev->dev, "PLL %d\n", dpll);\r\n}\r\nclock.p2 = 14;\r\nif ((dpll & PLL_REF_INPUT_MASK) ==\r\nPLLB_REF_INPUT_SPREADSPECTRUMIN) {\r\ni8xx_clock(66000, &clock);\r\n} else\r\ni8xx_clock(48000, &clock);\r\n} else {\r\nif (dpll & PLL_P1_DIVIDE_BY_TWO)\r\nclock.p1 = 2;\r\nelse {\r\nclock.p1 =\r\n((dpll &\r\nDPLL_FPA01_P1_POST_DIV_MASK_I830) >>\r\nDPLL_FPA01_P1_POST_DIV_SHIFT) + 2;\r\n}\r\nif (dpll & PLL_P2_DIVIDE_BY_4)\r\nclock.p2 = 4;\r\nelse\r\nclock.p2 = 2;\r\ni8xx_clock(48000, &clock);\r\n}\r\nreturn clock.dot;\r\n}\r\nstruct drm_display_mode *cdv_intel_crtc_mode_get(struct drm_device *dev,\r\nstruct drm_crtc *crtc)\r\n{\r\nstruct gma_crtc *gma_crtc = to_gma_crtc(crtc);\r\nint pipe = gma_crtc->pipe;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_pipe *p = &dev_priv->regs.pipe[pipe];\r\nconst struct psb_offset *map = &dev_priv->regmap[pipe];\r\nstruct drm_display_mode *mode;\r\nint htot;\r\nint hsync;\r\nint vtot;\r\nint vsync;\r\nif (gma_power_begin(dev, false)) {\r\nhtot = REG_READ(map->htotal);\r\nhsync = REG_READ(map->hsync);\r\nvtot = REG_READ(map->vtotal);\r\nvsync = REG_READ(map->vsync);\r\ngma_power_end(dev);\r\n} else {\r\nhtot = p->htotal;\r\nhsync = p->hsync;\r\nvtot = p->vtotal;\r\nvsync = p->vsync;\r\n}\r\nmode = kzalloc(sizeof(*mode), GFP_KERNEL);\r\nif (!mode)\r\nreturn NULL;\r\nmode->clock = cdv_intel_crtc_clock_get(dev, crtc);\r\nmode->hdisplay = (htot & 0xffff) + 1;\r\nmode->htotal = ((htot & 0xffff0000) >> 16) + 1;\r\nmode->hsync_start = (hsync & 0xffff) + 1;\r\nmode->hsync_end = ((hsync & 0xffff0000) >> 16) + 1;\r\nmode->vdisplay = (vtot & 0xffff) + 1;\r\nmode->vtotal = ((vtot & 0xffff0000) >> 16) + 1;\r\nmode->vsync_start = (vsync & 0xffff) + 1;\r\nmode->vsync_end = ((vsync & 0xffff0000) >> 16) + 1;\r\ndrm_mode_set_name(mode);\r\ndrm_mode_set_crtcinfo(mode, 0);\r\nreturn mode;\r\n}
