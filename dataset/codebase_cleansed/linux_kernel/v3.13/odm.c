void ODM_DMInit(struct odm_dm_struct *pDM_Odm)\r\n{\r\nodm_CommonInfoSelfInit(pDM_Odm);\r\nodm_CmnInfoInit_Debug(pDM_Odm);\r\nodm_DIGInit(pDM_Odm);\r\nodm_RateAdaptiveMaskInit(pDM_Odm);\r\nif (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {\r\n;\r\n} else if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {\r\nodm_PrimaryCCA_Init(pDM_Odm);\r\nodm_DynamicBBPowerSavingInit(pDM_Odm);\r\nodm_DynamicTxPowerInit(pDM_Odm);\r\nodm_TXPowerTrackingInit(pDM_Odm);\r\nODM_EdcaTurboInit(pDM_Odm);\r\nODM_RAInfo_Init_all(pDM_Odm);\r\nif ((pDM_Odm->AntDivType == CG_TRX_HW_ANTDIV) ||\r\n(pDM_Odm->AntDivType == CGCS_RX_HW_ANTDIV) ||\r\n(pDM_Odm->AntDivType == CG_TRX_SMART_ANTDIV))\r\nodm_InitHybridAntDiv(pDM_Odm);\r\nelse if (pDM_Odm->AntDivType == CGCS_RX_SW_ANTDIV)\r\nodm_SwAntDivInit(pDM_Odm);\r\n}\r\n}\r\nvoid ODM_DMWatchdog(struct odm_dm_struct *pDM_Odm)\r\n{\r\nodm_GlobalAdapterCheck();\r\nodm_CmnInfoHook_Debug(pDM_Odm);\r\nodm_CmnInfoUpdate_Debug(pDM_Odm);\r\nodm_CommonInfoSelfUpdate(pDM_Odm);\r\nodm_FalseAlarmCounterStatistics(pDM_Odm);\r\nodm_RSSIMonitorCheck(pDM_Odm);\r\nif ((pDM_Odm->Adapter->pwrctrlpriv.pwr_mode != PS_MODE_ACTIVE) &&\r\n((pDM_Odm->SupportICType & (ODM_RTL8723A)) ||\r\n(pDM_Odm->SupportICType & (ODM_RTL8188E) &&\r\n((pDM_Odm->SupportInterface == ODM_ITRF_SDIO))))) {\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("----Step1: odm_DIG is in LPS mode\n"));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("---Step2: 8723AS is in LPS mode\n"));\r\nodm_DIGbyRSSI_LPS(pDM_Odm);\r\n} else {\r\nodm_DIG(pDM_Odm);\r\n}\r\nodm_CCKPacketDetectionThresh(pDM_Odm);\r\nif (*(pDM_Odm->pbPowerSaving))\r\nreturn;\r\nodm_RefreshRateAdaptiveMask(pDM_Odm);\r\nodm_DynamicBBPowerSaving(pDM_Odm);\r\nodm_DynamicPrimaryCCA(pDM_Odm);\r\nif ((pDM_Odm->AntDivType == CG_TRX_HW_ANTDIV) ||\r\n(pDM_Odm->AntDivType == CGCS_RX_HW_ANTDIV) ||\r\n(pDM_Odm->AntDivType == CG_TRX_SMART_ANTDIV))\r\nodm_HwAntDiv(pDM_Odm);\r\nelse if (pDM_Odm->AntDivType == CGCS_RX_SW_ANTDIV)\r\nodm_SwAntDivChkAntSwitch(pDM_Odm, SWAW_STEP_PEAK);\r\nif (pDM_Odm->SupportICType & ODM_IC_11AC_SERIES) {\r\n;\r\n} else if (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {\r\nODM_TXPowerTrackingCheck(pDM_Odm);\r\nodm_EdcaTurboCheck(pDM_Odm);\r\nodm_DynamicTxPower(pDM_Odm);\r\n}\r\nodm_dtc(pDM_Odm);\r\n}\r\nvoid ODM_CmnInfoInit(struct odm_dm_struct *pDM_Odm, enum odm_common_info_def CmnInfo, u32 Value)\r\n{\r\nswitch (CmnInfo) {\r\ncase ODM_CMNINFO_ABILITY:\r\npDM_Odm->SupportAbility = (u32)Value;\r\nbreak;\r\ncase ODM_CMNINFO_PLATFORM:\r\npDM_Odm->SupportPlatform = (u8)Value;\r\nbreak;\r\ncase ODM_CMNINFO_INTERFACE:\r\npDM_Odm->SupportInterface = (u8)Value;\r\nbreak;\r\ncase ODM_CMNINFO_MP_TEST_CHIP:\r\npDM_Odm->bIsMPChip = (u8)Value;\r\nbreak;\r\ncase ODM_CMNINFO_IC_TYPE:\r\npDM_Odm->SupportICType = Value;\r\nbreak;\r\ncase ODM_CMNINFO_CUT_VER:\r\npDM_Odm->CutVersion = (u8)Value;\r\nbreak;\r\ncase ODM_CMNINFO_FAB_VER:\r\npDM_Odm->FabVersion = (u8)Value;\r\nbreak;\r\ncase ODM_CMNINFO_RF_TYPE:\r\npDM_Odm->RFType = (u8)Value;\r\nbreak;\r\ncase ODM_CMNINFO_RF_ANTENNA_TYPE:\r\npDM_Odm->AntDivType = (u8)Value;\r\nbreak;\r\ncase ODM_CMNINFO_BOARD_TYPE:\r\npDM_Odm->BoardType = (u8)Value;\r\nbreak;\r\ncase ODM_CMNINFO_EXT_LNA:\r\npDM_Odm->ExtLNA = (u8)Value;\r\nbreak;\r\ncase ODM_CMNINFO_EXT_PA:\r\npDM_Odm->ExtPA = (u8)Value;\r\nbreak;\r\ncase ODM_CMNINFO_EXT_TRSW:\r\npDM_Odm->ExtTRSW = (u8)Value;\r\nbreak;\r\ncase ODM_CMNINFO_PATCH_ID:\r\npDM_Odm->PatchID = (u8)Value;\r\nbreak;\r\ncase ODM_CMNINFO_BINHCT_TEST:\r\npDM_Odm->bInHctTest = (bool)Value;\r\nbreak;\r\ncase ODM_CMNINFO_BWIFI_TEST:\r\npDM_Odm->bWIFITest = (bool)Value;\r\nbreak;\r\ncase ODM_CMNINFO_SMART_CONCURRENT:\r\npDM_Odm->bDualMacSmartConcurrent = (bool)Value;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npDM_Odm->BbSwingIdxOfdm = 12;\r\npDM_Odm->BbSwingIdxOfdmCurrent = 12;\r\npDM_Odm->BbSwingFlagOfdm = false;\r\n}\r\nvoid ODM_CmnInfoHook(struct odm_dm_struct *pDM_Odm, enum odm_common_info_def CmnInfo, void *pValue)\r\n{\r\nswitch (CmnInfo) {\r\ncase ODM_CMNINFO_MAC_PHY_MODE:\r\npDM_Odm->pMacPhyMode = (u8 *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_TX_UNI:\r\npDM_Odm->pNumTxBytesUnicast = (u64 *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_RX_UNI:\r\npDM_Odm->pNumRxBytesUnicast = (u64 *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_WM_MODE:\r\npDM_Odm->pWirelessMode = (u8 *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_BAND:\r\npDM_Odm->pBandType = (u8 *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_SEC_CHNL_OFFSET:\r\npDM_Odm->pSecChOffset = (u8 *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_SEC_MODE:\r\npDM_Odm->pSecurity = (u8 *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_BW:\r\npDM_Odm->pBandWidth = (u8 *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_CHNL:\r\npDM_Odm->pChannel = (u8 *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_DMSP_GET_VALUE:\r\npDM_Odm->pbGetValueFromOtherMac = (bool *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_BUDDY_ADAPTOR:\r\npDM_Odm->pBuddyAdapter = (struct adapter **)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_DMSP_IS_MASTER:\r\npDM_Odm->pbMasterOfDMSP = (bool *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_SCAN:\r\npDM_Odm->pbScanInProcess = (bool *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_POWER_SAVING:\r\npDM_Odm->pbPowerSaving = (bool *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_ONE_PATH_CCA:\r\npDM_Odm->pOnePathCCA = (u8 *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_DRV_STOP:\r\npDM_Odm->pbDriverStopped = (bool *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_PNP_IN:\r\npDM_Odm->pbDriverIsGoingToPnpSetPowerSleep = (bool *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_INIT_ON:\r\npDM_Odm->pinit_adpt_in_progress = (bool *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_ANT_TEST:\r\npDM_Odm->pAntennaTest = (u8 *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_NET_CLOSED:\r\npDM_Odm->pbNet_closed = (bool *)pValue;\r\nbreak;\r\ncase ODM_CMNINFO_MP_MODE:\r\npDM_Odm->mp_mode = (u8 *)pValue;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid ODM_CmnInfoPtrArrayHook(struct odm_dm_struct *pDM_Odm, enum odm_common_info_def CmnInfo, u16 Index, void *pValue)\r\n{\r\nswitch (CmnInfo) {\r\ncase ODM_CMNINFO_STA_STATUS:\r\npDM_Odm->pODM_StaInfo[Index] = (struct sta_info *)pValue;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid ODM_CmnInfoUpdate(struct odm_dm_struct *pDM_Odm, u32 CmnInfo, u64 Value)\r\n{\r\nswitch (CmnInfo) {\r\ncase ODM_CMNINFO_ABILITY:\r\npDM_Odm->SupportAbility = (u32)Value;\r\nbreak;\r\ncase ODM_CMNINFO_RF_TYPE:\r\npDM_Odm->RFType = (u8)Value;\r\nbreak;\r\ncase ODM_CMNINFO_WIFI_DIRECT:\r\npDM_Odm->bWIFI_Direct = (bool)Value;\r\nbreak;\r\ncase ODM_CMNINFO_WIFI_DISPLAY:\r\npDM_Odm->bWIFI_Display = (bool)Value;\r\nbreak;\r\ncase ODM_CMNINFO_LINK:\r\npDM_Odm->bLinked = (bool)Value;\r\nbreak;\r\ncase ODM_CMNINFO_RSSI_MIN:\r\npDM_Odm->RSSI_Min = (u8)Value;\r\nbreak;\r\ncase ODM_CMNINFO_DBG_COMP:\r\npDM_Odm->DebugComponents = Value;\r\nbreak;\r\ncase ODM_CMNINFO_DBG_LEVEL:\r\npDM_Odm->DebugLevel = (u32)Value;\r\nbreak;\r\ncase ODM_CMNINFO_RA_THRESHOLD_HIGH:\r\npDM_Odm->RateAdaptive.HighRSSIThresh = (u8)Value;\r\nbreak;\r\ncase ODM_CMNINFO_RA_THRESHOLD_LOW:\r\npDM_Odm->RateAdaptive.LowRSSIThresh = (u8)Value;\r\nbreak;\r\n}\r\n}\r\nvoid odm_CommonInfoSelfInit(struct odm_dm_struct *pDM_Odm)\r\n{\r\npDM_Odm->bCckHighPower = (bool) ODM_GetBBReg(pDM_Odm, 0x824, BIT9);\r\npDM_Odm->RFPathRxEnable = (u8) ODM_GetBBReg(pDM_Odm, 0xc04, 0x0F);\r\nif (pDM_Odm->SupportICType & (ODM_RTL8192C|ODM_RTL8192D))\r\npDM_Odm->AntDivType = CG_TRX_HW_ANTDIV;\r\nif (pDM_Odm->SupportICType & (ODM_RTL8723A))\r\npDM_Odm->AntDivType = CGCS_RX_SW_ANTDIV;\r\nODM_InitDebugSetting(pDM_Odm);\r\n}\r\nvoid odm_CommonInfoSelfUpdate(struct odm_dm_struct *pDM_Odm)\r\n{\r\nu8 EntryCnt = 0;\r\nu8 i;\r\nstruct sta_info *pEntry;\r\nif (*(pDM_Odm->pBandWidth) == ODM_BW40M) {\r\nif (*(pDM_Odm->pSecChOffset) == 1)\r\npDM_Odm->ControlChannel = *(pDM_Odm->pChannel) - 2;\r\nelse if (*(pDM_Odm->pSecChOffset) == 2)\r\npDM_Odm->ControlChannel = *(pDM_Odm->pChannel) + 2;\r\n} else {\r\npDM_Odm->ControlChannel = *(pDM_Odm->pChannel);\r\n}\r\nfor (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {\r\npEntry = pDM_Odm->pODM_StaInfo[i];\r\nif (IS_STA_VALID(pEntry))\r\nEntryCnt++;\r\n}\r\nif (EntryCnt == 1)\r\npDM_Odm->bOneEntryOnly = true;\r\nelse\r\npDM_Odm->bOneEntryOnly = false;\r\n}\r\nvoid odm_CmnInfoInit_Debug(struct odm_dm_struct *pDM_Odm)\r\n{\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("odm_CmnInfoInit_Debug==>\n"));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("SupportPlatform=%d\n", pDM_Odm->SupportPlatform));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("SupportAbility=0x%x\n", pDM_Odm->SupportAbility));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("SupportInterface=%d\n", pDM_Odm->SupportInterface));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("SupportICType=0x%x\n", pDM_Odm->SupportICType));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("CutVersion=%d\n", pDM_Odm->CutVersion));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("FabVersion=%d\n", pDM_Odm->FabVersion));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("RFType=%d\n", pDM_Odm->RFType));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("BoardType=%d\n", pDM_Odm->BoardType));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("ExtLNA=%d\n", pDM_Odm->ExtLNA));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("ExtPA=%d\n", pDM_Odm->ExtPA));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("ExtTRSW=%d\n", pDM_Odm->ExtTRSW));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("PatchID=%d\n", pDM_Odm->PatchID));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("bInHctTest=%d\n", pDM_Odm->bInHctTest));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("bWIFITest=%d\n", pDM_Odm->bWIFITest));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("bDualMacSmartConcurrent=%d\n", pDM_Odm->bDualMacSmartConcurrent));\r\n}\r\nvoid odm_CmnInfoHook_Debug(struct odm_dm_struct *pDM_Odm)\r\n{\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("odm_CmnInfoHook_Debug==>\n"));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("pNumTxBytesUnicast=%llu\n", *(pDM_Odm->pNumTxBytesUnicast)));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("pNumRxBytesUnicast=%llu\n", *(pDM_Odm->pNumRxBytesUnicast)));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("pWirelessMode=0x%x\n", *(pDM_Odm->pWirelessMode)));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("pSecChOffset=%d\n", *(pDM_Odm->pSecChOffset)));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("pSecurity=%d\n", *(pDM_Odm->pSecurity)));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("pBandWidth=%d\n", *(pDM_Odm->pBandWidth)));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("pChannel=%d\n", *(pDM_Odm->pChannel)));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("pbScanInProcess=%d\n", *(pDM_Odm->pbScanInProcess)));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("pbPowerSaving=%d\n", *(pDM_Odm->pbPowerSaving)));\r\nif (pDM_Odm->SupportPlatform & (ODM_AP|ODM_ADSL))\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("pOnePathCCA=%d\n", *(pDM_Odm->pOnePathCCA)));\r\n}\r\nvoid odm_CmnInfoUpdate_Debug(struct odm_dm_struct *pDM_Odm)\r\n{\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("odm_CmnInfoUpdate_Debug==>\n"));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("bWIFI_Direct=%d\n", pDM_Odm->bWIFI_Direct));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("bWIFI_Display=%d\n", pDM_Odm->bWIFI_Display));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("bLinked=%d\n", pDM_Odm->bLinked));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_COMMON, ODM_DBG_LOUD, ("RSSI_Min=%d\n", pDM_Odm->RSSI_Min));\r\n}\r\nstatic int getIGIForDiff(int value_IGI)\r\n{\r\n#define ONERCCA_LOW_TH 0x30\r\n#define ONERCCA_LOW_DIFF 8\r\nif (value_IGI < ONERCCA_LOW_TH) {\r\nif ((ONERCCA_LOW_TH - value_IGI) < ONERCCA_LOW_DIFF)\r\nreturn ONERCCA_LOW_TH;\r\nelse\r\nreturn value_IGI + ONERCCA_LOW_DIFF;\r\n} else {\r\nreturn value_IGI;\r\n}\r\n}\r\nvoid ODM_Write_DIG(struct odm_dm_struct *pDM_Odm, u8 CurrentIGI)\r\n{\r\nstruct rtw_dig *pDM_DigTable = &pDM_Odm->DM_DigTable;\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD,\r\n("ODM_REG(IGI_A,pDM_Odm)=0x%x, ODM_BIT(IGI,pDM_Odm)=0x%x\n",\r\nODM_REG(IGI_A, pDM_Odm), ODM_BIT(IGI, pDM_Odm)));\r\nif (pDM_DigTable->CurIGValue != CurrentIGI) {\r\nif (pDM_Odm->SupportPlatform & (ODM_CE|ODM_MP)) {\r\nODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A, pDM_Odm), ODM_BIT(IGI, pDM_Odm), CurrentIGI);\r\nif (pDM_Odm->SupportICType != ODM_RTL8188E)\r\nODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B, pDM_Odm), ODM_BIT(IGI, pDM_Odm), CurrentIGI);\r\n} else if (pDM_Odm->SupportPlatform & (ODM_AP|ODM_ADSL)) {\r\nswitch (*(pDM_Odm->pOnePathCCA)) {\r\ncase ODM_CCA_2R:\r\nODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A, pDM_Odm), ODM_BIT(IGI, pDM_Odm), CurrentIGI);\r\nif (pDM_Odm->SupportICType != ODM_RTL8188E)\r\nODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B, pDM_Odm), ODM_BIT(IGI, pDM_Odm), CurrentIGI);\r\nbreak;\r\ncase ODM_CCA_1R_A:\r\nODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A, pDM_Odm), ODM_BIT(IGI, pDM_Odm), CurrentIGI);\r\nif (pDM_Odm->SupportICType != ODM_RTL8188E)\r\nODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B, pDM_Odm), ODM_BIT(IGI, pDM_Odm), getIGIForDiff(CurrentIGI));\r\nbreak;\r\ncase ODM_CCA_1R_B:\r\nODM_SetBBReg(pDM_Odm, ODM_REG(IGI_A, pDM_Odm), ODM_BIT(IGI, pDM_Odm), getIGIForDiff(CurrentIGI));\r\nif (pDM_Odm->SupportICType != ODM_RTL8188E)\r\nODM_SetBBReg(pDM_Odm, ODM_REG(IGI_B, pDM_Odm), ODM_BIT(IGI, pDM_Odm), CurrentIGI);\r\nbreak;\r\n}\r\n}\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("CurrentIGI(0x%02x).\n", CurrentIGI));\r\npDM_DigTable->CurIGValue = CurrentIGI;\r\n}\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("ODM_Write_DIG():CurrentIGI=0x%x\n", CurrentIGI));\r\n}\r\nvoid odm_DIGbyRSSI_LPS(struct odm_dm_struct *pDM_Odm)\r\n{\r\nstruct adapter *pAdapter = pDM_Odm->Adapter;\r\nstruct false_alarm_stats *pFalseAlmCnt = &pDM_Odm->FalseAlmCnt;\r\nu8 RSSI_Lower = DM_DIG_MIN_NIC;\r\nu8 bFwCurrentInPSMode = false;\r\nu8 CurrentIGI = pDM_Odm->RSSI_Min;\r\nif (!(pDM_Odm->SupportICType & (ODM_RTL8723A | ODM_RTL8188E)))\r\nreturn;\r\nCurrentIGI = CurrentIGI + RSSI_OFFSET_DIG;\r\nbFwCurrentInPSMode = pAdapter->pwrctrlpriv.bFwCurrentInPSMode;\r\nif (bFwCurrentInPSMode) {\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("---Neil---odm_DIG is in LPS mode\n"));\r\nif (pFalseAlmCnt->Cnt_all > DM_DIG_FA_TH2_LPS)\r\nCurrentIGI = CurrentIGI+2;\r\nelse if (pFalseAlmCnt->Cnt_all > DM_DIG_FA_TH1_LPS)\r\nCurrentIGI = CurrentIGI+1;\r\nelse if (pFalseAlmCnt->Cnt_all < DM_DIG_FA_TH0_LPS)\r\nCurrentIGI = CurrentIGI-1;\r\n} else {\r\nCurrentIGI = RSSI_Lower;\r\n}\r\nif ((pDM_Odm->RSSI_Min-10) > DM_DIG_MIN_NIC)\r\nRSSI_Lower = (pDM_Odm->RSSI_Min-10);\r\nelse\r\nRSSI_Lower = DM_DIG_MIN_NIC;\r\nif (CurrentIGI > DM_DIG_MAX_NIC)\r\nCurrentIGI = DM_DIG_MAX_NIC;\r\nelse if (CurrentIGI < RSSI_Lower)\r\nCurrentIGI = RSSI_Lower;\r\nODM_Write_DIG(pDM_Odm, CurrentIGI);\r\n}\r\nvoid odm_DIGInit(struct odm_dm_struct *pDM_Odm)\r\n{\r\nstruct rtw_dig *pDM_DigTable = &pDM_Odm->DM_DigTable;\r\npDM_DigTable->CurIGValue = (u8) ODM_GetBBReg(pDM_Odm, ODM_REG(IGI_A, pDM_Odm), ODM_BIT(IGI, pDM_Odm));\r\npDM_DigTable->RssiLowThresh = DM_DIG_THRESH_LOW;\r\npDM_DigTable->RssiHighThresh = DM_DIG_THRESH_HIGH;\r\npDM_DigTable->FALowThresh = DM_false_ALARM_THRESH_LOW;\r\npDM_DigTable->FAHighThresh = DM_false_ALARM_THRESH_HIGH;\r\nif (pDM_Odm->BoardType == ODM_BOARD_HIGHPWR) {\r\npDM_DigTable->rx_gain_range_max = DM_DIG_MAX_NIC;\r\npDM_DigTable->rx_gain_range_min = DM_DIG_MIN_NIC;\r\n} else {\r\npDM_DigTable->rx_gain_range_max = DM_DIG_MAX_NIC;\r\npDM_DigTable->rx_gain_range_min = DM_DIG_MIN_NIC;\r\n}\r\npDM_DigTable->BackoffVal = DM_DIG_BACKOFF_DEFAULT;\r\npDM_DigTable->BackoffVal_range_max = DM_DIG_BACKOFF_MAX;\r\npDM_DigTable->BackoffVal_range_min = DM_DIG_BACKOFF_MIN;\r\npDM_DigTable->PreCCK_CCAThres = 0xFF;\r\npDM_DigTable->CurCCK_CCAThres = 0x83;\r\npDM_DigTable->ForbiddenIGI = DM_DIG_MIN_NIC;\r\npDM_DigTable->LargeFAHit = 0;\r\npDM_DigTable->Recover_cnt = 0;\r\npDM_DigTable->DIG_Dynamic_MIN_0 = DM_DIG_MIN_NIC;\r\npDM_DigTable->DIG_Dynamic_MIN_1 = DM_DIG_MIN_NIC;\r\npDM_DigTable->bMediaConnect_0 = false;\r\npDM_DigTable->bMediaConnect_1 = false;\r\npDM_Odm->bDMInitialGainEnable = true;\r\n}\r\nvoid odm_DIG(struct odm_dm_struct *pDM_Odm)\r\n{\r\nstruct rtw_dig *pDM_DigTable = &pDM_Odm->DM_DigTable;\r\nstruct false_alarm_stats *pFalseAlmCnt = &pDM_Odm->FalseAlmCnt;\r\nu8 DIG_Dynamic_MIN;\r\nu8 DIG_MaxOfMin;\r\nbool FirstConnect, FirstDisConnect;\r\nu8 dm_dig_max, dm_dig_min;\r\nu8 CurrentIGI = pDM_DigTable->CurIGValue;\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG()==>\n"));\r\nif ((!(pDM_Odm->SupportAbility&ODM_BB_DIG)) || (!(pDM_Odm->SupportAbility&ODM_BB_FA_CNT))) {\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD,\r\n("odm_DIG() Return: SupportAbility ODM_BB_DIG or ODM_BB_FA_CNT is disabled\n"));\r\nreturn;\r\n}\r\nif (*(pDM_Odm->pbScanInProcess)) {\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG() Return: In Scan Progress\n"));\r\nreturn;\r\n}\r\nif (pDM_Odm->bDMInitialGainEnable == false) {\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG() Return: PSD is Processing\n"));\r\nreturn;\r\n}\r\nif (pDM_Odm->SupportICType == ODM_RTL8192D) {\r\nif (*(pDM_Odm->pMacPhyMode) == ODM_DMSP) {\r\nif (*(pDM_Odm->pbMasterOfDMSP)) {\r\nDIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;\r\nFirstConnect = (pDM_Odm->bLinked) && (!pDM_DigTable->bMediaConnect_0);\r\nFirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0);\r\n} else {\r\nDIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_1;\r\nFirstConnect = (pDM_Odm->bLinked) && (!pDM_DigTable->bMediaConnect_1);\r\nFirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_1);\r\n}\r\n} else {\r\nif (*(pDM_Odm->pBandType) == ODM_BAND_5G) {\r\nDIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;\r\nFirstConnect = (pDM_Odm->bLinked) && (!pDM_DigTable->bMediaConnect_0);\r\nFirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0);\r\n} else {\r\nDIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_1;\r\nFirstConnect = (pDM_Odm->bLinked) && (!pDM_DigTable->bMediaConnect_1);\r\nFirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_1);\r\n}\r\n}\r\n} else {\r\nDIG_Dynamic_MIN = pDM_DigTable->DIG_Dynamic_MIN_0;\r\nFirstConnect = (pDM_Odm->bLinked) && (!pDM_DigTable->bMediaConnect_0);\r\nFirstDisConnect = (!pDM_Odm->bLinked) && (pDM_DigTable->bMediaConnect_0);\r\n}\r\nif ((pDM_Odm->SupportICType & (ODM_RTL8192C|ODM_RTL8723A)) &&\r\n((pDM_Odm->BoardType == ODM_BOARD_HIGHPWR) || pDM_Odm->ExtLNA)) {\r\nif (pDM_Odm->SupportPlatform & (ODM_AP|ODM_ADSL)) {\r\ndm_dig_max = DM_DIG_MAX_AP_HP;\r\ndm_dig_min = DM_DIG_MIN_AP_HP;\r\n} else {\r\ndm_dig_max = DM_DIG_MAX_NIC_HP;\r\ndm_dig_min = DM_DIG_MIN_NIC_HP;\r\n}\r\nDIG_MaxOfMin = DM_DIG_MAX_AP_HP;\r\n} else {\r\nif (pDM_Odm->SupportPlatform & (ODM_AP|ODM_ADSL)) {\r\ndm_dig_max = DM_DIG_MAX_AP;\r\ndm_dig_min = DM_DIG_MIN_AP;\r\nDIG_MaxOfMin = dm_dig_max;\r\n} else {\r\ndm_dig_max = DM_DIG_MAX_NIC;\r\ndm_dig_min = DM_DIG_MIN_NIC;\r\nDIG_MaxOfMin = DM_DIG_MAX_AP;\r\n}\r\n}\r\nif (pDM_Odm->bLinked) {\r\nif (pDM_Odm->SupportICType == (ODM_RTL8723A)) {\r\nif ((pDM_Odm->RSSI_Min + 10) > DM_DIG_MAX_NIC)\r\npDM_DigTable->rx_gain_range_max = DM_DIG_MAX_NIC;\r\nelse if ((pDM_Odm->RSSI_Min + 10) < DM_DIG_MIN_NIC)\r\npDM_DigTable->rx_gain_range_max = DM_DIG_MIN_NIC;\r\nelse\r\npDM_DigTable->rx_gain_range_max = pDM_Odm->RSSI_Min + 10;\r\nDIG_Dynamic_MIN = DM_DIG_MIN_NIC;\r\n} else {\r\nif ((pDM_Odm->RSSI_Min + 20) > dm_dig_max)\r\npDM_DigTable->rx_gain_range_max = dm_dig_max;\r\nelse if ((pDM_Odm->RSSI_Min + 20) < dm_dig_min)\r\npDM_DigTable->rx_gain_range_max = dm_dig_min;\r\nelse\r\npDM_DigTable->rx_gain_range_max = pDM_Odm->RSSI_Min + 20;\r\nif (pDM_Odm->bOneEntryOnly) {\r\nif (pDM_Odm->RSSI_Min < dm_dig_min)\r\nDIG_Dynamic_MIN = dm_dig_min;\r\nelse if (pDM_Odm->RSSI_Min > DIG_MaxOfMin)\r\nDIG_Dynamic_MIN = DIG_MaxOfMin;\r\nelse\r\nDIG_Dynamic_MIN = pDM_Odm->RSSI_Min;\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD,\r\n("odm_DIG() : bOneEntryOnly=true, DIG_Dynamic_MIN=0x%x\n",\r\nDIG_Dynamic_MIN));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD,\r\n("odm_DIG() : pDM_Odm->RSSI_Min=%d\n",\r\npDM_Odm->RSSI_Min));\r\n} else if ((pDM_Odm->SupportICType == ODM_RTL8188E) &&\r\n(pDM_Odm->SupportAbility & ODM_BB_ANT_DIV)) {\r\nif (pDM_Odm->AntDivType == CG_TRX_HW_ANTDIV) {\r\nDIG_Dynamic_MIN = (u8) pDM_DigTable->AntDiv_RSSI_max;\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,\r\n("odm_DIG(): pDM_DigTable->AntDiv_RSSI_max=%d\n",\r\npDM_DigTable->AntDiv_RSSI_max));\r\n}\r\n} else {\r\nDIG_Dynamic_MIN = dm_dig_min;\r\n}\r\n}\r\n} else {\r\npDM_DigTable->rx_gain_range_max = dm_dig_max;\r\nDIG_Dynamic_MIN = dm_dig_min;\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG() : No Link\n"));\r\n}\r\nif (pFalseAlmCnt->Cnt_all > 10000) {\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("dm_DIG(): Abnornally false alarm case.\n"));\r\nif (pDM_DigTable->LargeFAHit != 3)\r\npDM_DigTable->LargeFAHit++;\r\nif (pDM_DigTable->ForbiddenIGI < CurrentIGI) {\r\npDM_DigTable->ForbiddenIGI = CurrentIGI;\r\npDM_DigTable->LargeFAHit = 1;\r\n}\r\nif (pDM_DigTable->LargeFAHit >= 3) {\r\nif ((pDM_DigTable->ForbiddenIGI+1) > pDM_DigTable->rx_gain_range_max)\r\npDM_DigTable->rx_gain_range_min = pDM_DigTable->rx_gain_range_max;\r\nelse\r\npDM_DigTable->rx_gain_range_min = (pDM_DigTable->ForbiddenIGI + 1);\r\npDM_DigTable->Recover_cnt = 3600;\r\n}\r\n} else {\r\nif (pDM_DigTable->Recover_cnt != 0) {\r\npDM_DigTable->Recover_cnt--;\r\n} else {\r\nif (pDM_DigTable->LargeFAHit < 3) {\r\nif ((pDM_DigTable->ForbiddenIGI-1) < DIG_Dynamic_MIN) {\r\npDM_DigTable->ForbiddenIGI = DIG_Dynamic_MIN;\r\npDM_DigTable->rx_gain_range_min = DIG_Dynamic_MIN;\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Normal Case: At Lower Bound\n"));\r\n} else {\r\npDM_DigTable->ForbiddenIGI--;\r\npDM_DigTable->rx_gain_range_min = (pDM_DigTable->ForbiddenIGI + 1);\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): Normal Case: Approach Lower Bound\n"));\r\n}\r\n} else {\r\npDM_DigTable->LargeFAHit = 0;\r\n}\r\n}\r\n}\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD,\r\n("odm_DIG(): pDM_DigTable->LargeFAHit=%d\n",\r\npDM_DigTable->LargeFAHit));\r\nif (pDM_Odm->bLinked) {\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): DIG AfterLink\n"));\r\nif (FirstConnect) {\r\nCurrentIGI = pDM_Odm->RSSI_Min;\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("DIG: First Connect\n"));\r\n} else {\r\nif (pDM_Odm->SupportICType == ODM_RTL8192D) {\r\nif (pFalseAlmCnt->Cnt_all > DM_DIG_FA_TH2_92D)\r\nCurrentIGI = CurrentIGI + 2;\r\nelse if (pFalseAlmCnt->Cnt_all > DM_DIG_FA_TH1_92D)\r\nCurrentIGI = CurrentIGI + 1;\r\nelse if (pFalseAlmCnt->Cnt_all < DM_DIG_FA_TH0_92D)\r\nCurrentIGI = CurrentIGI - 1;\r\n} else {\r\nif (pFalseAlmCnt->Cnt_all > DM_DIG_FA_TH2)\r\nCurrentIGI = CurrentIGI + 4;\r\nelse if (pFalseAlmCnt->Cnt_all > DM_DIG_FA_TH1)\r\nCurrentIGI = CurrentIGI + 2;\r\nelse if (pFalseAlmCnt->Cnt_all < DM_DIG_FA_TH0)\r\nCurrentIGI = CurrentIGI - 2;\r\n}\r\n}\r\n} else {\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): DIG BeforeLink\n"));\r\nif (FirstDisConnect) {\r\nCurrentIGI = pDM_DigTable->rx_gain_range_min;\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): First DisConnect\n"));\r\n} else {\r\nif (pFalseAlmCnt->Cnt_all > 10000)\r\nCurrentIGI = CurrentIGI + 2;\r\nelse if (pFalseAlmCnt->Cnt_all > 8000)\r\nCurrentIGI = CurrentIGI + 1;\r\nelse if (pFalseAlmCnt->Cnt_all < 500)\r\nCurrentIGI = CurrentIGI - 1;\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): England DIG\n"));\r\n}\r\n}\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): DIG End Adjust IGI\n"));\r\nif (CurrentIGI > pDM_DigTable->rx_gain_range_max)\r\nCurrentIGI = pDM_DigTable->rx_gain_range_max;\r\nif (CurrentIGI < pDM_DigTable->rx_gain_range_min)\r\nCurrentIGI = pDM_DigTable->rx_gain_range_min;\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD,\r\n("odm_DIG(): rx_gain_range_max=0x%x, rx_gain_range_min=0x%x\n",\r\npDM_DigTable->rx_gain_range_max, pDM_DigTable->rx_gain_range_min));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): TotalFA=%d\n", pFalseAlmCnt->Cnt_all));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_DIG, ODM_DBG_LOUD, ("odm_DIG(): CurIGValue=0x%x\n", CurrentIGI));\r\nODM_Write_DIG(pDM_Odm, CurrentIGI);\r\npDM_DigTable->bMediaConnect_0 = pDM_Odm->bLinked;\r\npDM_DigTable->DIG_Dynamic_MIN_0 = DIG_Dynamic_MIN;\r\n}\r\nvoid odm_FalseAlarmCounterStatistics(struct odm_dm_struct *pDM_Odm)\r\n{\r\nu32 ret_value;\r\nstruct false_alarm_stats *FalseAlmCnt = &(pDM_Odm->FalseAlmCnt);\r\nif (!(pDM_Odm->SupportAbility & ODM_BB_FA_CNT))\r\nreturn;\r\nif (pDM_Odm->SupportICType & ODM_IC_11N_SERIES) {\r\nODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_HOLDC_11N, BIT31, 1);\r\nODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTD_11N, BIT31, 1);\r\nret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE1_11N, bMaskDWord);\r\nFalseAlmCnt->Cnt_Fast_Fsync = (ret_value&0xffff);\r\nFalseAlmCnt->Cnt_SB_Search_fail = ((ret_value&0xffff0000)>>16);\r\nret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE2_11N, bMaskDWord);\r\nFalseAlmCnt->Cnt_OFDM_CCA = (ret_value&0xffff);\r\nFalseAlmCnt->Cnt_Parity_Fail = ((ret_value&0xffff0000)>>16);\r\nret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE3_11N, bMaskDWord);\r\nFalseAlmCnt->Cnt_Rate_Illegal = (ret_value&0xffff);\r\nFalseAlmCnt->Cnt_Crc8_fail = ((ret_value&0xffff0000)>>16);\r\nret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_TYPE4_11N, bMaskDWord);\r\nFalseAlmCnt->Cnt_Mcs_fail = (ret_value&0xffff);\r\nFalseAlmCnt->Cnt_Ofdm_fail = FalseAlmCnt->Cnt_Parity_Fail + FalseAlmCnt->Cnt_Rate_Illegal +\r\nFalseAlmCnt->Cnt_Crc8_fail + FalseAlmCnt->Cnt_Mcs_fail +\r\nFalseAlmCnt->Cnt_Fast_Fsync + FalseAlmCnt->Cnt_SB_Search_fail;\r\nif (pDM_Odm->SupportICType == ODM_RTL8188E) {\r\nret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_SC_CNT_11N, bMaskDWord);\r\nFalseAlmCnt->Cnt_BW_LSC = (ret_value&0xffff);\r\nFalseAlmCnt->Cnt_BW_USC = ((ret_value&0xffff0000)>>16);\r\n}\r\nODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT12, 1);\r\nODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT14, 1);\r\nret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_FA_LSB_11N, bMaskByte0);\r\nFalseAlmCnt->Cnt_Cck_fail = ret_value;\r\nret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_FA_MSB_11N, bMaskByte3);\r\nFalseAlmCnt->Cnt_Cck_fail += (ret_value & 0xff)<<8;\r\nret_value = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_CCA_CNT_11N, bMaskDWord);\r\nFalseAlmCnt->Cnt_CCK_CCA = ((ret_value&0xFF)<<8) | ((ret_value&0xFF00)>>8);\r\nFalseAlmCnt->Cnt_all = (FalseAlmCnt->Cnt_Fast_Fsync +\r\nFalseAlmCnt->Cnt_SB_Search_fail +\r\nFalseAlmCnt->Cnt_Parity_Fail +\r\nFalseAlmCnt->Cnt_Rate_Illegal +\r\nFalseAlmCnt->Cnt_Crc8_fail +\r\nFalseAlmCnt->Cnt_Mcs_fail +\r\nFalseAlmCnt->Cnt_Cck_fail);\r\nFalseAlmCnt->Cnt_CCA_all = FalseAlmCnt->Cnt_OFDM_CCA + FalseAlmCnt->Cnt_CCK_CCA;\r\nif (pDM_Odm->SupportICType >= ODM_RTL8723A) {\r\nODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTC_11N, BIT31, 1);\r\nODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTC_11N, BIT31, 0);\r\nODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTD_11N, BIT27, 1);\r\nODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTD_11N, BIT27, 0);\r\nODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_HOLDC_11N, BIT31, 0);\r\nODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RSTD_11N, BIT31, 0);\r\nODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT13|BIT12, 0);\r\nODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT13|BIT12, 2);\r\nODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT15|BIT14, 0);\r\nODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11N, BIT15|BIT14, 2);\r\n}\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Enter odm_FalseAlarmCounterStatistics\n"));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_FA_CNT, ODM_DBG_LOUD,\r\n("Cnt_Fast_Fsync=%d, Cnt_SB_Search_fail=%d\n",\r\nFalseAlmCnt->Cnt_Fast_Fsync, FalseAlmCnt->Cnt_SB_Search_fail));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_FA_CNT, ODM_DBG_LOUD,\r\n("Cnt_Parity_Fail=%d, Cnt_Rate_Illegal=%d\n",\r\nFalseAlmCnt->Cnt_Parity_Fail, FalseAlmCnt->Cnt_Rate_Illegal));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_FA_CNT, ODM_DBG_LOUD,\r\n("Cnt_Crc8_fail=%d, Cnt_Mcs_fail=%d\n",\r\nFalseAlmCnt->Cnt_Crc8_fail, FalseAlmCnt->Cnt_Mcs_fail));\r\n} else {\r\nFalseAlmCnt->Cnt_Ofdm_fail = ODM_GetBBReg(pDM_Odm, ODM_REG_OFDM_FA_11AC, bMaskLWord);\r\nFalseAlmCnt->Cnt_Cck_fail = ODM_GetBBReg(pDM_Odm, ODM_REG_CCK_FA_11AC, bMaskLWord);\r\nFalseAlmCnt->Cnt_all = FalseAlmCnt->Cnt_Ofdm_fail + FalseAlmCnt->Cnt_Cck_fail;\r\nODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RST_11AC, BIT17, 1);\r\nODM_SetBBReg(pDM_Odm, ODM_REG_OFDM_FA_RST_11AC, BIT17, 0);\r\nODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11AC, BIT15, 0);\r\nODM_SetBBReg(pDM_Odm, ODM_REG_CCK_FA_RST_11AC, BIT15, 1);\r\n}\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Cnt_Cck_fail=%d\n", FalseAlmCnt->Cnt_Cck_fail));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Cnt_Ofdm_fail=%d\n", FalseAlmCnt->Cnt_Ofdm_fail));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_FA_CNT, ODM_DBG_LOUD, ("Total False Alarm=%d\n", FalseAlmCnt->Cnt_all));\r\n}\r\nvoid odm_CCKPacketDetectionThresh(struct odm_dm_struct *pDM_Odm)\r\n{\r\nu8 CurCCK_CCAThres;\r\nstruct false_alarm_stats *FalseAlmCnt = &(pDM_Odm->FalseAlmCnt);\r\nif (!(pDM_Odm->SupportAbility & (ODM_BB_CCK_PD|ODM_BB_FA_CNT)))\r\nreturn;\r\nif (pDM_Odm->ExtLNA)\r\nreturn;\r\nif (pDM_Odm->bLinked) {\r\nif (pDM_Odm->RSSI_Min > 25) {\r\nCurCCK_CCAThres = 0xcd;\r\n} else if ((pDM_Odm->RSSI_Min <= 25) && (pDM_Odm->RSSI_Min > 10)) {\r\nCurCCK_CCAThres = 0x83;\r\n} else {\r\nif (FalseAlmCnt->Cnt_Cck_fail > 1000)\r\nCurCCK_CCAThres = 0x83;\r\nelse\r\nCurCCK_CCAThres = 0x40;\r\n}\r\n} else {\r\nif (FalseAlmCnt->Cnt_Cck_fail > 1000)\r\nCurCCK_CCAThres = 0x83;\r\nelse\r\nCurCCK_CCAThres = 0x40;\r\n}\r\nODM_Write_CCK_CCA_Thres(pDM_Odm, CurCCK_CCAThres);\r\n}\r\nvoid ODM_Write_CCK_CCA_Thres(struct odm_dm_struct *pDM_Odm, u8 CurCCK_CCAThres)\r\n{\r\nstruct rtw_dig *pDM_DigTable = &pDM_Odm->DM_DigTable;\r\nif (pDM_DigTable->CurCCK_CCAThres != CurCCK_CCAThres)\r\nODM_Write1Byte(pDM_Odm, ODM_REG(CCK_CCA, pDM_Odm), CurCCK_CCAThres);\r\npDM_DigTable->PreCCK_CCAThres = pDM_DigTable->CurCCK_CCAThres;\r\npDM_DigTable->CurCCK_CCAThres = CurCCK_CCAThres;\r\n}\r\nvoid odm_DynamicBBPowerSavingInit(struct odm_dm_struct *pDM_Odm)\r\n{\r\nstruct rtl_ps *pDM_PSTable = &pDM_Odm->DM_PSTable;\r\npDM_PSTable->PreCCAState = CCA_MAX;\r\npDM_PSTable->CurCCAState = CCA_MAX;\r\npDM_PSTable->PreRFState = RF_MAX;\r\npDM_PSTable->CurRFState = RF_MAX;\r\npDM_PSTable->Rssi_val_min = 0;\r\npDM_PSTable->initialize = 0;\r\n}\r\nvoid odm_DynamicBBPowerSaving(struct odm_dm_struct *pDM_Odm)\r\n{\r\nif ((pDM_Odm->SupportICType != ODM_RTL8192C) && (pDM_Odm->SupportICType != ODM_RTL8723A))\r\nreturn;\r\nif (!(pDM_Odm->SupportAbility & ODM_BB_PWR_SAVE))\r\nreturn;\r\nif (!(pDM_Odm->SupportPlatform & (ODM_MP|ODM_CE)))\r\nreturn;\r\nif ((pDM_Odm->SupportICType == ODM_RTL8192C) && (pDM_Odm->RFType == ODM_2T2R)) {\r\nodm_1R_CCA(pDM_Odm);\r\n} else {\r\nODM_RF_Saving(pDM_Odm, false);\r\n}\r\n}\r\nvoid odm_1R_CCA(struct odm_dm_struct *pDM_Odm)\r\n{\r\nstruct rtl_ps *pDM_PSTable = &pDM_Odm->DM_PSTable;\r\nif (pDM_Odm->RSSI_Min != 0xFF) {\r\nif (pDM_PSTable->PreCCAState == CCA_2R) {\r\nif (pDM_Odm->RSSI_Min >= 35)\r\npDM_PSTable->CurCCAState = CCA_1R;\r\nelse\r\npDM_PSTable->CurCCAState = CCA_2R;\r\n} else {\r\nif (pDM_Odm->RSSI_Min <= 30)\r\npDM_PSTable->CurCCAState = CCA_2R;\r\nelse\r\npDM_PSTable->CurCCAState = CCA_1R;\r\n}\r\n} else {\r\npDM_PSTable->CurCCAState = CCA_MAX;\r\n}\r\nif (pDM_PSTable->PreCCAState != pDM_PSTable->CurCCAState) {\r\nif (pDM_PSTable->CurCCAState == CCA_1R) {\r\nif (pDM_Odm->RFType == ODM_2T2R)\r\nODM_SetBBReg(pDM_Odm, 0xc04, bMaskByte0, 0x13);\r\nelse\r\nODM_SetBBReg(pDM_Odm, 0xc04, bMaskByte0, 0x23);\r\n} else {\r\nODM_SetBBReg(pDM_Odm, 0xc04, bMaskByte0, 0x33);\r\n}\r\npDM_PSTable->PreCCAState = pDM_PSTable->CurCCAState;\r\n}\r\n}\r\nvoid ODM_RF_Saving(struct odm_dm_struct *pDM_Odm, u8 bForceInNormal)\r\n{\r\nstruct rtl_ps *pDM_PSTable = &pDM_Odm->DM_PSTable;\r\nu8 Rssi_Up_bound = 30;\r\nu8 Rssi_Low_bound = 25;\r\nif (pDM_Odm->PatchID == 40) {\r\nRssi_Up_bound = 50;\r\nRssi_Low_bound = 45;\r\n}\r\nif (pDM_PSTable->initialize == 0) {\r\npDM_PSTable->Reg874 = (ODM_GetBBReg(pDM_Odm, 0x874, bMaskDWord)&0x1CC000)>>14;\r\npDM_PSTable->RegC70 = (ODM_GetBBReg(pDM_Odm, 0xc70, bMaskDWord)&BIT3)>>3;\r\npDM_PSTable->Reg85C = (ODM_GetBBReg(pDM_Odm, 0x85c, bMaskDWord)&0xFF000000)>>24;\r\npDM_PSTable->RegA74 = (ODM_GetBBReg(pDM_Odm, 0xa74, bMaskDWord)&0xF000)>>12;\r\npDM_PSTable->initialize = 1;\r\n}\r\nif (!bForceInNormal) {\r\nif (pDM_Odm->RSSI_Min != 0xFF) {\r\nif (pDM_PSTable->PreRFState == RF_Normal) {\r\nif (pDM_Odm->RSSI_Min >= Rssi_Up_bound)\r\npDM_PSTable->CurRFState = RF_Save;\r\nelse\r\npDM_PSTable->CurRFState = RF_Normal;\r\n} else {\r\nif (pDM_Odm->RSSI_Min <= Rssi_Low_bound)\r\npDM_PSTable->CurRFState = RF_Normal;\r\nelse\r\npDM_PSTable->CurRFState = RF_Save;\r\n}\r\n} else {\r\npDM_PSTable->CurRFState = RF_MAX;\r\n}\r\n} else {\r\npDM_PSTable->CurRFState = RF_Normal;\r\n}\r\nif (pDM_PSTable->PreRFState != pDM_PSTable->CurRFState) {\r\nif (pDM_PSTable->CurRFState == RF_Save) {\r\nif (pDM_Odm->SupportICType == ODM_RTL8723A)\r\nODM_SetBBReg(pDM_Odm, 0x874 , BIT5, 0x1);\r\nODM_SetBBReg(pDM_Odm, 0x874 , 0x1C0000, 0x2);\r\nODM_SetBBReg(pDM_Odm, 0xc70, BIT3, 0);\r\nODM_SetBBReg(pDM_Odm, 0x85c, 0xFF000000, 0x63);\r\nODM_SetBBReg(pDM_Odm, 0x874, 0xC000, 0x2);\r\nODM_SetBBReg(pDM_Odm, 0xa74, 0xF000, 0x3);\r\nODM_SetBBReg(pDM_Odm, 0x818, BIT28, 0x0);\r\nODM_SetBBReg(pDM_Odm, 0x818, BIT28, 0x1);\r\n} else {\r\nODM_SetBBReg(pDM_Odm, 0x874 , 0x1CC000, pDM_PSTable->Reg874);\r\nODM_SetBBReg(pDM_Odm, 0xc70, BIT3, pDM_PSTable->RegC70);\r\nODM_SetBBReg(pDM_Odm, 0x85c, 0xFF000000, pDM_PSTable->Reg85C);\r\nODM_SetBBReg(pDM_Odm, 0xa74, 0xF000, pDM_PSTable->RegA74);\r\nODM_SetBBReg(pDM_Odm, 0x818, BIT28, 0x0);\r\nif (pDM_Odm->SupportICType == ODM_RTL8723A)\r\nODM_SetBBReg(pDM_Odm, 0x874, BIT5, 0x0);\r\n}\r\npDM_PSTable->PreRFState = pDM_PSTable->CurRFState;\r\n}\r\n}\r\nvoid odm_RateAdaptiveMaskInit(struct odm_dm_struct *pDM_Odm)\r\n{\r\nstruct odm_rate_adapt *pOdmRA = &pDM_Odm->RateAdaptive;\r\npOdmRA->Type = DM_Type_ByDriver;\r\nif (pOdmRA->Type == DM_Type_ByDriver)\r\npDM_Odm->bUseRAMask = true;\r\nelse\r\npDM_Odm->bUseRAMask = false;\r\npOdmRA->RATRState = DM_RATR_STA_INIT;\r\npOdmRA->HighRSSIThresh = 50;\r\npOdmRA->LowRSSIThresh = 20;\r\n}\r\nu32 ODM_Get_Rate_Bitmap(struct odm_dm_struct *pDM_Odm, u32 macid, u32 ra_mask, u8 rssi_level)\r\n{\r\nstruct sta_info *pEntry;\r\nu32 rate_bitmap = 0x0fffffff;\r\nu8 WirelessMode;\r\npEntry = pDM_Odm->pODM_StaInfo[macid];\r\nif (!IS_STA_VALID(pEntry))\r\nreturn ra_mask;\r\nWirelessMode = pEntry->wireless_mode;\r\nswitch (WirelessMode) {\r\ncase ODM_WM_B:\r\nif (ra_mask & 0x0000000c)\r\nrate_bitmap = 0x0000000d;\r\nelse\r\nrate_bitmap = 0x0000000f;\r\nbreak;\r\ncase (ODM_WM_A|ODM_WM_G):\r\nif (rssi_level == DM_RATR_STA_HIGH)\r\nrate_bitmap = 0x00000f00;\r\nelse\r\nrate_bitmap = 0x00000ff0;\r\nbreak;\r\ncase (ODM_WM_B|ODM_WM_G):\r\nif (rssi_level == DM_RATR_STA_HIGH)\r\nrate_bitmap = 0x00000f00;\r\nelse if (rssi_level == DM_RATR_STA_MIDDLE)\r\nrate_bitmap = 0x00000ff0;\r\nelse\r\nrate_bitmap = 0x00000ff5;\r\nbreak;\r\ncase (ODM_WM_B|ODM_WM_G|ODM_WM_N24G):\r\ncase (ODM_WM_A|ODM_WM_B|ODM_WM_G|ODM_WM_N24G):\r\nif (pDM_Odm->RFType == ODM_1T2R || pDM_Odm->RFType == ODM_1T1R) {\r\nif (rssi_level == DM_RATR_STA_HIGH) {\r\nrate_bitmap = 0x000f0000;\r\n} else if (rssi_level == DM_RATR_STA_MIDDLE) {\r\nrate_bitmap = 0x000ff000;\r\n} else {\r\nif (*(pDM_Odm->pBandWidth) == ODM_BW40M)\r\nrate_bitmap = 0x000ff015;\r\nelse\r\nrate_bitmap = 0x000ff005;\r\n}\r\n} else {\r\nif (rssi_level == DM_RATR_STA_HIGH) {\r\nrate_bitmap = 0x0f8f0000;\r\n} else if (rssi_level == DM_RATR_STA_MIDDLE) {\r\nrate_bitmap = 0x0f8ff000;\r\n} else {\r\nif (*(pDM_Odm->pBandWidth) == ODM_BW40M)\r\nrate_bitmap = 0x0f8ff015;\r\nelse\r\nrate_bitmap = 0x0f8ff005;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nif (pDM_Odm->RFType == RF_1T2R)\r\nrate_bitmap = 0x000fffff;\r\nelse\r\nrate_bitmap = 0x0fffffff;\r\nbreak;\r\n}\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD,\r\n(" ==> rssi_level:0x%02x, WirelessMode:0x%02x, rate_bitmap:0x%08x\n",\r\nrssi_level, WirelessMode, rate_bitmap));\r\nreturn rate_bitmap;\r\n}\r\nvoid odm_RefreshRateAdaptiveMask(struct odm_dm_struct *pDM_Odm)\r\n{\r\nif (!(pDM_Odm->SupportAbility & ODM_BB_RA_MASK))\r\nreturn;\r\nswitch (pDM_Odm->SupportPlatform) {\r\ncase ODM_MP:\r\nodm_RefreshRateAdaptiveMaskMP(pDM_Odm);\r\nbreak;\r\ncase ODM_CE:\r\nodm_RefreshRateAdaptiveMaskCE(pDM_Odm);\r\nbreak;\r\ncase ODM_AP:\r\ncase ODM_ADSL:\r\nodm_RefreshRateAdaptiveMaskAPADSL(pDM_Odm);\r\nbreak;\r\n}\r\n}\r\nvoid odm_RefreshRateAdaptiveMaskMP(struct odm_dm_struct *pDM_Odm)\r\n{\r\n}\r\nvoid odm_RefreshRateAdaptiveMaskCE(struct odm_dm_struct *pDM_Odm)\r\n{\r\nu8 i;\r\nstruct adapter *pAdapter = pDM_Odm->Adapter;\r\nif (pAdapter->bDriverStopped) {\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_TRACE, ("<---- odm_RefreshRateAdaptiveMask(): driver is going to unload\n"));\r\nreturn;\r\n}\r\nif (!pDM_Odm->bUseRAMask) {\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("<---- odm_RefreshRateAdaptiveMask(): driver does not control rate adaptive mask\n"));\r\nreturn;\r\n}\r\nfor (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {\r\nstruct sta_info *pstat = pDM_Odm->pODM_StaInfo[i];\r\nif (IS_STA_VALID(pstat)) {\r\nif (ODM_RAStateCheck(pDM_Odm, pstat->rssi_stat.UndecoratedSmoothedPWDB, false , &pstat->rssi_level)) {\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD,\r\n("RSSI:%d, RSSI_LEVEL:%d\n",\r\npstat->rssi_stat.UndecoratedSmoothedPWDB, pstat->rssi_level));\r\nrtw_hal_update_ra_mask(pAdapter, i, pstat->rssi_level);\r\n}\r\n}\r\n}\r\n}\r\nvoid odm_RefreshRateAdaptiveMaskAPADSL(struct odm_dm_struct *pDM_Odm)\r\n{\r\n}\r\nbool ODM_RAStateCheck(struct odm_dm_struct *pDM_Odm, s32 RSSI, bool bForceUpdate, u8 *pRATRState)\r\n{\r\nstruct odm_rate_adapt *pRA = &pDM_Odm->RateAdaptive;\r\nconst u8 GoUpGap = 5;\r\nu8 HighRSSIThreshForRA = pRA->HighRSSIThresh;\r\nu8 LowRSSIThreshForRA = pRA->LowRSSIThresh;\r\nu8 RATRState;\r\nswitch (*pRATRState) {\r\ncase DM_RATR_STA_INIT:\r\ncase DM_RATR_STA_HIGH:\r\nbreak;\r\ncase DM_RATR_STA_MIDDLE:\r\nHighRSSIThreshForRA += GoUpGap;\r\nbreak;\r\ncase DM_RATR_STA_LOW:\r\nHighRSSIThreshForRA += GoUpGap;\r\nLowRSSIThreshForRA += GoUpGap;\r\nbreak;\r\ndefault:\r\nODM_RT_ASSERT(pDM_Odm, false, ("wrong rssi level setting %d !", *pRATRState));\r\nbreak;\r\n}\r\nif (RSSI > HighRSSIThreshForRA)\r\nRATRState = DM_RATR_STA_HIGH;\r\nelse if (RSSI > LowRSSIThreshForRA)\r\nRATRState = DM_RATR_STA_MIDDLE;\r\nelse\r\nRATRState = DM_RATR_STA_LOW;\r\nif (*pRATRState != RATRState || bForceUpdate) {\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_RA_MASK, ODM_DBG_LOUD, ("RSSI Level %d -> %d\n", *pRATRState, RATRState));\r\n*pRATRState = RATRState;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid odm_DynamicTxPowerInit(struct odm_dm_struct *pDM_Odm)\r\n{\r\nstruct adapter *Adapter = pDM_Odm->Adapter;\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(Adapter);\r\nstruct dm_priv *pdmpriv = &pHalData->dmpriv;\r\npdmpriv->bDynamicTxPowerEnable = false;\r\npdmpriv->LastDTPLvl = TxHighPwrLevel_Normal;\r\npdmpriv->DynamicTxHighPowerLvl = TxHighPwrLevel_Normal;\r\n}\r\nvoid odm_DynamicTxPower(struct odm_dm_struct *pDM_Odm)\r\n{\r\nif (!(pDM_Odm->SupportAbility & ODM_BB_DYNAMIC_TXPWR))\r\nreturn;\r\nif (!pDM_Odm->ExtPA)\r\nreturn;\r\nswitch (pDM_Odm->SupportPlatform) {\r\ncase ODM_MP:\r\ncase ODM_CE:\r\nodm_DynamicTxPowerNIC(pDM_Odm);\r\nbreak;\r\ncase ODM_AP:\r\nodm_DynamicTxPowerAP(pDM_Odm);\r\nbreak;\r\ncase ODM_ADSL:\r\nbreak;\r\n}\r\n}\r\nvoid odm_DynamicTxPowerNIC(struct odm_dm_struct *pDM_Odm)\r\n{\r\nif (!(pDM_Odm->SupportAbility & ODM_BB_DYNAMIC_TXPWR))\r\nreturn;\r\nif (pDM_Odm->SupportICType == ODM_RTL8188E) {\r\n}\r\n}\r\nvoid odm_DynamicTxPowerAP(struct odm_dm_struct *pDM_Odm)\r\n{\r\n}\r\nvoid odm_RSSIMonitorCheck(struct odm_dm_struct *pDM_Odm)\r\n{\r\nif (!(pDM_Odm->SupportAbility & ODM_BB_RSSI_MONITOR))\r\nreturn;\r\nswitch (pDM_Odm->SupportPlatform) {\r\ncase ODM_MP:\r\nodm_RSSIMonitorCheckMP(pDM_Odm);\r\nbreak;\r\ncase ODM_CE:\r\nodm_RSSIMonitorCheckCE(pDM_Odm);\r\nbreak;\r\ncase ODM_AP:\r\nodm_RSSIMonitorCheckAP(pDM_Odm);\r\nbreak;\r\ncase ODM_ADSL:\r\nbreak;\r\n}\r\n}\r\nvoid odm_RSSIMonitorCheckMP(struct odm_dm_struct *pDM_Odm)\r\n{\r\n}\r\nstatic void FindMinimumRSSI(struct adapter *pAdapter)\r\n{\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(pAdapter);\r\nstruct dm_priv *pdmpriv = &pHalData->dmpriv;\r\nstruct mlme_priv *pmlmepriv = &pAdapter->mlmepriv;\r\nif ((check_fwstate(pmlmepriv, _FW_LINKED) == false) &&\r\n(pdmpriv->EntryMinUndecoratedSmoothedPWDB == 0))\r\npdmpriv->MinUndecoratedPWDBForDM = 0;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED) == true)\r\npdmpriv->MinUndecoratedPWDBForDM = pdmpriv->EntryMinUndecoratedSmoothedPWDB;\r\nelse\r\npdmpriv->MinUndecoratedPWDBForDM = pdmpriv->EntryMinUndecoratedSmoothedPWDB;\r\n}\r\nvoid odm_RSSIMonitorCheckCE(struct odm_dm_struct *pDM_Odm)\r\n{\r\nstruct adapter *Adapter = pDM_Odm->Adapter;\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(Adapter);\r\nstruct dm_priv *pdmpriv = &pHalData->dmpriv;\r\nint i;\r\nint tmpEntryMaxPWDB = 0, tmpEntryMinPWDB = 0xff;\r\nu8 sta_cnt = 0;\r\nu32 PWDB_rssi[NUM_STA] = {0};\r\nstruct sta_info *psta;\r\nu8 bcast_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nif (!check_fwstate(&Adapter->mlmepriv, _FW_LINKED))\r\nreturn;\r\nfor (i = 0; i < ODM_ASSOCIATE_ENTRY_NUM; i++) {\r\npsta = pDM_Odm->pODM_StaInfo[i];\r\nif (IS_STA_VALID(psta) &&\r\n(psta->state & WIFI_ASOC_STATE) &&\r\n!_rtw_memcmp(psta->hwaddr, bcast_addr, ETH_ALEN) &&\r\n!_rtw_memcmp(psta->hwaddr, myid(&Adapter->eeprompriv), ETH_ALEN)) {\r\nif (psta->rssi_stat.UndecoratedSmoothedPWDB < tmpEntryMinPWDB)\r\ntmpEntryMinPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;\r\nif (psta->rssi_stat.UndecoratedSmoothedPWDB > tmpEntryMaxPWDB)\r\ntmpEntryMaxPWDB = psta->rssi_stat.UndecoratedSmoothedPWDB;\r\nif (psta->rssi_stat.UndecoratedSmoothedPWDB != (-1))\r\nPWDB_rssi[sta_cnt++] = (psta->mac_id | (psta->rssi_stat.UndecoratedSmoothedPWDB<<16));\r\n}\r\n}\r\nfor (i = 0; i < sta_cnt; i++) {\r\nif (PWDB_rssi[i] != (0)) {\r\nif (pHalData->fw_ractrl) {\r\n} else {\r\nODM_RA_SetRSSI_8188E(\r\n&(pHalData->odmpriv), (PWDB_rssi[i]&0xFF), (u8)((PWDB_rssi[i]>>16) & 0xFF));\r\n}\r\n}\r\n}\r\nif (tmpEntryMaxPWDB != 0)\r\npdmpriv->EntryMaxUndecoratedSmoothedPWDB = tmpEntryMaxPWDB;\r\nelse\r\npdmpriv->EntryMaxUndecoratedSmoothedPWDB = 0;\r\nif (tmpEntryMinPWDB != 0xff)\r\npdmpriv->EntryMinUndecoratedSmoothedPWDB = tmpEntryMinPWDB;\r\nelse\r\npdmpriv->EntryMinUndecoratedSmoothedPWDB = 0;\r\nFindMinimumRSSI(Adapter);\r\nODM_CmnInfoUpdate(&pHalData->odmpriv , ODM_CMNINFO_RSSI_MIN, pdmpriv->MinUndecoratedPWDBForDM);\r\n}\r\nvoid odm_RSSIMonitorCheckAP(struct odm_dm_struct *pDM_Odm)\r\n{\r\n}\r\nvoid ODM_InitAllTimers(struct odm_dm_struct *pDM_Odm)\r\n{\r\nODM_InitializeTimer(pDM_Odm, &pDM_Odm->DM_SWAT_Table.SwAntennaSwitchTimer,\r\n(void *)odm_SwAntDivChkAntSwitchCallback, NULL, "SwAntennaSwitchTimer");\r\n}\r\nvoid ODM_CancelAllTimers(struct odm_dm_struct *pDM_Odm)\r\n{\r\nODM_CancelTimer(pDM_Odm, &pDM_Odm->DM_SWAT_Table.SwAntennaSwitchTimer);\r\n}\r\nvoid ODM_ReleaseAllTimers(struct odm_dm_struct *pDM_Odm)\r\n{\r\nODM_ReleaseTimer(pDM_Odm, &pDM_Odm->DM_SWAT_Table.SwAntennaSwitchTimer);\r\nODM_ReleaseTimer(pDM_Odm, &pDM_Odm->FastAntTrainingTimer);\r\n}\r\nvoid odm_TXPowerTrackingInit(struct odm_dm_struct *pDM_Odm)\r\n{\r\nodm_TXPowerTrackingThermalMeterInit(pDM_Odm);\r\n}\r\nvoid odm_TXPowerTrackingThermalMeterInit(struct odm_dm_struct *pDM_Odm)\r\n{\r\npDM_Odm->RFCalibrateInfo.bTXPowerTracking = true;\r\npDM_Odm->RFCalibrateInfo.TXPowercount = 0;\r\npDM_Odm->RFCalibrateInfo.bTXPowerTrackingInit = false;\r\nif (*(pDM_Odm->mp_mode) != 1)\r\npDM_Odm->RFCalibrateInfo.TxPowerTrackControl = true;\r\nMSG_88E("pDM_Odm TxPowerTrackControl = %d\n", pDM_Odm->RFCalibrateInfo.TxPowerTrackControl);\r\npDM_Odm->RFCalibrateInfo.TxPowerTrackControl = true;\r\n}\r\nvoid ODM_TXPowerTrackingCheck(struct odm_dm_struct *pDM_Odm)\r\n{\r\nswitch (pDM_Odm->SupportPlatform) {\r\ncase ODM_MP:\r\nodm_TXPowerTrackingCheckMP(pDM_Odm);\r\nbreak;\r\ncase ODM_CE:\r\nodm_TXPowerTrackingCheckCE(pDM_Odm);\r\nbreak;\r\ncase ODM_AP:\r\nodm_TXPowerTrackingCheckAP(pDM_Odm);\r\nbreak;\r\ncase ODM_ADSL:\r\nbreak;\r\n}\r\n}\r\nvoid odm_TXPowerTrackingCheckCE(struct odm_dm_struct *pDM_Odm)\r\n{\r\nstruct adapter *Adapter = pDM_Odm->Adapter;\r\nif (!(pDM_Odm->SupportAbility & ODM_RF_TX_PWR_TRACK))\r\nreturn;\r\nif (!pDM_Odm->RFCalibrateInfo.TM_Trigger) {\r\nPHY_SetRFReg(Adapter, RF_PATH_A, RF_T_METER_88E, BIT17 | BIT16, 0x03);\r\npDM_Odm->RFCalibrateInfo.TM_Trigger = 1;\r\nreturn;\r\n} else {\r\nodm_TXPowerTrackingCallback_ThermalMeter_8188E(Adapter);\r\npDM_Odm->RFCalibrateInfo.TM_Trigger = 0;\r\n}\r\n}\r\nvoid odm_TXPowerTrackingCheckMP(struct odm_dm_struct *pDM_Odm)\r\n{\r\n}\r\nvoid odm_TXPowerTrackingCheckAP(struct odm_dm_struct *pDM_Odm)\r\n{\r\n}\r\nvoid odm_SwAntDivInit(struct odm_dm_struct *pDM_Odm)\r\n{\r\n}\r\nvoid ODM_SwAntDivChkPerPktRssi(struct odm_dm_struct *pDM_Odm, u8 StationID, struct odm_phy_status_info *pPhyInfo)\r\n{\r\n}\r\nvoid odm_SwAntDivChkAntSwitch(struct odm_dm_struct *pDM_Odm, u8 Step)\r\n{\r\n}\r\nvoid ODM_SwAntDivRestAfterLink(struct odm_dm_struct *pDM_Odm)\r\n{\r\n}\r\nvoid odm_SwAntDivChkAntSwitchCallback(void *FunctionContext)\r\n{\r\n}\r\nvoid odm_InitHybridAntDiv(struct odm_dm_struct *pDM_Odm)\r\n{\r\nif (!(pDM_Odm->SupportAbility & ODM_BB_ANT_DIV)) {\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Return: Not Support HW AntDiv\n"));\r\nreturn;\r\n}\r\nif (pDM_Odm->SupportICType & (ODM_RTL8192C | ODM_RTL8192D))\r\n;\r\nelse if (pDM_Odm->SupportICType == ODM_RTL8188E)\r\nODM_AntennaDiversityInit_88E(pDM_Odm);\r\n}\r\nvoid ODM_AntselStatistics_88C(struct odm_dm_struct *pDM_Odm, u8 MacId, u32 PWDBAll, bool isCCKrate)\r\n{\r\nstruct sw_ant_switch *pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;\r\nif (pDM_SWAT_Table->antsel == 1) {\r\nif (isCCKrate) {\r\npDM_SWAT_Table->CCK_Ant1_Cnt[MacId]++;\r\n} else {\r\npDM_SWAT_Table->OFDM_Ant1_Cnt[MacId]++;\r\npDM_SWAT_Table->RSSI_Ant1_Sum[MacId] += PWDBAll;\r\n}\r\n} else {\r\nif (isCCKrate) {\r\npDM_SWAT_Table->CCK_Ant2_Cnt[MacId]++;\r\n} else {\r\npDM_SWAT_Table->OFDM_Ant2_Cnt[MacId]++;\r\npDM_SWAT_Table->RSSI_Ant2_Sum[MacId] += PWDBAll;\r\n}\r\n}\r\n}\r\nvoid odm_HwAntDiv(struct odm_dm_struct *pDM_Odm)\r\n{\r\nif (!(pDM_Odm->SupportAbility & ODM_BB_ANT_DIV)) {\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Return: Not Support HW AntDiv\n"));\r\nreturn;\r\n}\r\nif (pDM_Odm->SupportICType == ODM_RTL8188E)\r\nODM_AntennaDiversity_88E(pDM_Odm);\r\n}\r\nvoid ODM_EdcaTurboInit(struct odm_dm_struct *pDM_Odm)\r\n{\r\nstruct adapter *Adapter = pDM_Odm->Adapter;\r\npDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = false;\r\npDM_Odm->DM_EDCA_Table.bIsCurRDLState = false;\r\nAdapter->recvpriv.bIsAnyNonBEPkts = false;\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO, ODM_DBG_LOUD, ("Orginial VO PARAM: 0x%x\n", ODM_Read4Byte(pDM_Odm, ODM_EDCA_VO_PARAM)));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO, ODM_DBG_LOUD, ("Orginial VI PARAM: 0x%x\n", ODM_Read4Byte(pDM_Odm, ODM_EDCA_VI_PARAM)));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO, ODM_DBG_LOUD, ("Orginial BE PARAM: 0x%x\n", ODM_Read4Byte(pDM_Odm, ODM_EDCA_BE_PARAM)));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO, ODM_DBG_LOUD, ("Orginial BK PARAM: 0x%x\n", ODM_Read4Byte(pDM_Odm, ODM_EDCA_BK_PARAM)));\r\n}\r\nvoid odm_EdcaTurboCheck(struct odm_dm_struct *pDM_Odm)\r\n{\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO, ODM_DBG_LOUD, ("odm_EdcaTurboCheck========================>\n"));\r\nif (!(pDM_Odm->SupportAbility & ODM_MAC_EDCA_TURBO))\r\nreturn;\r\nswitch (pDM_Odm->SupportPlatform) {\r\ncase ODM_MP:\r\nbreak;\r\ncase ODM_CE:\r\nodm_EdcaTurboCheckCE(pDM_Odm);\r\nbreak;\r\ncase ODM_AP:\r\ncase ODM_ADSL:\r\nbreak;\r\n}\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_EDCA_TURBO, ODM_DBG_LOUD, ("<========================odm_EdcaTurboCheck\n"));\r\n}\r\nvoid odm_EdcaTurboCheckCE(struct odm_dm_struct *pDM_Odm)\r\n{\r\nstruct adapter *Adapter = pDM_Odm->Adapter;\r\nu32 trafficIndex;\r\nu32 edca_param;\r\nu64 cur_tx_bytes = 0;\r\nu64 cur_rx_bytes = 0;\r\nu8 bbtchange = false;\r\nstruct hal_data_8188e *pHalData = GET_HAL_DATA(Adapter);\r\nstruct xmit_priv *pxmitpriv = &(Adapter->xmitpriv);\r\nstruct recv_priv *precvpriv = &(Adapter->recvpriv);\r\nstruct registry_priv *pregpriv = &Adapter->registrypriv;\r\nstruct mlme_ext_priv *pmlmeext = &(Adapter->mlmeextpriv);\r\nstruct mlme_ext_info *pmlmeinfo = &(pmlmeext->mlmext_info);\r\nif ((pregpriv->wifi_spec == 1))\r\ngoto dm_CheckEdcaTurbo_EXIT;\r\nif (pmlmeinfo->assoc_AP_vendor >= HT_IOT_PEER_MAX)\r\ngoto dm_CheckEdcaTurbo_EXIT;\r\nif ((bbtchange) || (!precvpriv->bIsAnyNonBEPkts)) {\r\ncur_tx_bytes = pxmitpriv->tx_bytes - pxmitpriv->last_tx_bytes;\r\ncur_rx_bytes = precvpriv->rx_bytes - precvpriv->last_rx_bytes;\r\nif ((pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_RALINK) ||\r\n(pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_ATHEROS)) {\r\nif (cur_tx_bytes > (cur_rx_bytes << 2)) {\r\ntrafficIndex = UP_LINK;\r\n} else {\r\ntrafficIndex = DOWN_LINK;\r\n}\r\n} else {\r\nif (cur_rx_bytes > (cur_tx_bytes << 2)) {\r\ntrafficIndex = DOWN_LINK;\r\n} else {\r\ntrafficIndex = UP_LINK;\r\n}\r\n}\r\nif ((pDM_Odm->DM_EDCA_Table.prv_traffic_idx != trafficIndex) || (!pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA)) {\r\nif ((pmlmeinfo->assoc_AP_vendor == HT_IOT_PEER_CISCO) && (pmlmeext->cur_wireless_mode & WIRELESS_11_24N))\r\nedca_param = EDCAParam[pmlmeinfo->assoc_AP_vendor][trafficIndex];\r\nelse\r\nedca_param = EDCAParam[HT_IOT_PEER_UNKNOWN][trafficIndex];\r\nrtw_write32(Adapter, REG_EDCA_BE_PARAM, edca_param);\r\npDM_Odm->DM_EDCA_Table.prv_traffic_idx = trafficIndex;\r\n}\r\npDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = true;\r\n} else {\r\nif (pDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA) {\r\nrtw_write32(Adapter, REG_EDCA_BE_PARAM, pHalData->AcParam_BE);\r\npDM_Odm->DM_EDCA_Table.bCurrentTurboEDCA = false;\r\n}\r\n}\r\ndm_CheckEdcaTurbo_EXIT:\r\nprecvpriv->bIsAnyNonBEPkts = false;\r\npxmitpriv->last_tx_bytes = pxmitpriv->tx_bytes;\r\nprecvpriv->last_rx_bytes = precvpriv->rx_bytes;\r\n}\r\nu32 GetPSDData(struct odm_dm_struct *pDM_Odm, unsigned int point, u8 initial_gain_psd)\r\n{\r\nu32 psd_report;\r\nODM_SetBBReg(pDM_Odm, 0x808, 0x3FF, point);\r\nODM_SetBBReg(pDM_Odm, 0x808, BIT22, 1);\r\nODM_StallExecution(30);\r\nODM_SetBBReg(pDM_Odm, 0x808, BIT22, 0);\r\npsd_report = ODM_GetBBReg(pDM_Odm, 0x8B4, bMaskDWord) & 0x0000FFFF;\r\npsd_report = (u32) (ConvertTo_dB(psd_report))+(u32)(initial_gain_psd-0x1c);\r\nreturn psd_report;\r\n}\r\nu32 ConvertTo_dB(u32 Value)\r\n{\r\nu8 i;\r\nu8 j;\r\nu32 dB;\r\nValue = Value & 0xFFFF;\r\nfor (i = 0; i < 8; i++) {\r\nif (Value <= dB_Invert_Table[i][11])\r\nbreak;\r\n}\r\nif (i >= 8)\r\nreturn 96;\r\nfor (j = 0; j < 12; j++) {\r\nif (Value <= dB_Invert_Table[i][j])\r\nbreak;\r\n}\r\ndB = i*12 + j + 1;\r\nreturn dB;\r\n}\r\nvoid odm_GlobalAdapterCheck(void)\r\n{\r\n}\r\nvoid ODM_SingleDualAntennaDefaultSetting(struct odm_dm_struct *pDM_Odm)\r\n{\r\nstruct sw_ant_switch *pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;\r\npDM_SWAT_Table->ANTA_ON = true;\r\npDM_SWAT_Table->ANTB_ON = true;\r\n}\r\nstatic void odm_PHY_SaveAFERegisters(struct odm_dm_struct *pDM_Odm, u32 *AFEReg, u32 *AFEBackup, u32 RegisterNum)\r\n{\r\nu32 i;\r\nfor (i = 0; i < RegisterNum; i++)\r\nAFEBackup[i] = ODM_GetBBReg(pDM_Odm, AFEReg[i], bMaskDWord);\r\n}\r\nstatic void odm_PHY_ReloadAFERegisters(struct odm_dm_struct *pDM_Odm, u32 *AFEReg, u32 *AFEBackup, u32 RegiesterNum)\r\n{\r\nu32 i;\r\nfor (i = 0; i < RegiesterNum; i++)\r\nODM_SetBBReg(pDM_Odm, AFEReg[i], bMaskDWord, AFEBackup[i]);\r\n}\r\nbool ODM_SingleDualAntennaDetection(struct odm_dm_struct *pDM_Odm, u8 mode)\r\n{\r\nstruct sw_ant_switch *pDM_SWAT_Table = &pDM_Odm->DM_SWAT_Table;\r\nu32 CurrentChannel, RfLoopReg;\r\nu8 n;\r\nu32 Reg88c, Regc08, Reg874, Regc50;\r\nu8 initial_gain = 0x5a;\r\nu32 PSD_report_tmp;\r\nu32 AntA_report = 0x0, AntB_report = 0x0, AntO_report = 0x0;\r\nbool bResult = true;\r\nu32 AFE_Backup[16];\r\nu32 AFE_REG_8723A[16] = {\r\nrRx_Wait_CCA, rTx_CCK_RFON,\r\nrTx_CCK_BBON, rTx_OFDM_RFON,\r\nrTx_OFDM_BBON, rTx_To_Rx,\r\nrTx_To_Tx, rRx_CCK,\r\nrRx_OFDM, rRx_Wait_RIFS,\r\nrRx_TO_Rx, rStandby,\r\nrSleep, rPMPD_ANAEN,\r\nrFPGA0_XCD_SwitchControl, rBlue_Tooth};\r\nif (!(pDM_Odm->SupportICType & (ODM_RTL8723A|ODM_RTL8192C)))\r\nreturn bResult;\r\nif (!(pDM_Odm->SupportAbility&ODM_BB_ANT_DIV))\r\nreturn bResult;\r\nif (pDM_Odm->SupportICType == ODM_RTL8192C) {\r\nODM_SetBBReg(pDM_Odm, 0x808, BIT10|BIT11, 0x3);\r\nODM_SetBBReg(pDM_Odm, 0x808, BIT12|BIT13, 0x1);\r\nODM_SetBBReg(pDM_Odm, 0x808, BIT14|BIT15, 0x0);\r\n}\r\nCurrentChannel = ODM_GetRFReg(pDM_Odm, RF_PATH_A, ODM_CHANNEL, bRFRegOffsetMask);\r\nRfLoopReg = ODM_GetRFReg(pDM_Odm, RF_PATH_A, 0x00, bRFRegOffsetMask);\r\nODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, ODM_DPDT, Antenna_A);\r\nODM_StallExecution(10);\r\nReg88c = ODM_GetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, bMaskDWord);\r\nRegc08 = ODM_GetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord);\r\nReg874 = ODM_GetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord);\r\nRegc50 = ODM_GetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskDWord);\r\nodm_PHY_SaveAFERegisters(pDM_Odm, AFE_REG_8723A, AFE_Backup, 16);\r\nODM_SetBBReg(pDM_Odm, rFPGA0_PSDFunction, BIT14|BIT15, 0x0);\r\nODM_SetRFReg(pDM_Odm, RF_PATH_A, ODM_CHANNEL, bRFRegOffsetMask, 0x01);\r\nODM_SetBBReg(pDM_Odm, rRx_Wait_CCA, bMaskDWord, 0x6FDB25A4);\r\nODM_SetBBReg(pDM_Odm, rTx_CCK_RFON, bMaskDWord, 0x6FDB25A4);\r\nODM_SetBBReg(pDM_Odm, rTx_CCK_BBON, bMaskDWord, 0x6FDB25A4);\r\nODM_SetBBReg(pDM_Odm, rTx_OFDM_RFON, bMaskDWord, 0x6FDB25A4);\r\nODM_SetBBReg(pDM_Odm, rTx_OFDM_BBON, bMaskDWord, 0x6FDB25A4);\r\nODM_SetBBReg(pDM_Odm, rTx_To_Rx, bMaskDWord, 0x6FDB25A4);\r\nODM_SetBBReg(pDM_Odm, rTx_To_Tx, bMaskDWord, 0x6FDB25A4);\r\nODM_SetBBReg(pDM_Odm, rRx_CCK, bMaskDWord, 0x6FDB25A4);\r\nODM_SetBBReg(pDM_Odm, rRx_OFDM, bMaskDWord, 0x6FDB25A4);\r\nODM_SetBBReg(pDM_Odm, rRx_Wait_RIFS, bMaskDWord, 0x6FDB25A4);\r\nODM_SetBBReg(pDM_Odm, rRx_TO_Rx, bMaskDWord, 0x6FDB25A4);\r\nODM_SetBBReg(pDM_Odm, rStandby, bMaskDWord, 0x6FDB25A4);\r\nODM_SetBBReg(pDM_Odm, rSleep, bMaskDWord, 0x6FDB25A4);\r\nODM_SetBBReg(pDM_Odm, rPMPD_ANAEN, bMaskDWord, 0x6FDB25A4);\r\nODM_SetBBReg(pDM_Odm, rFPGA0_XCD_SwitchControl, bMaskDWord, 0x6FDB25A4);\r\nODM_SetBBReg(pDM_Odm, rBlue_Tooth, bMaskDWord, 0x6FDB25A4);\r\nODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, bMaskDWord, 0xCCF000C0);\r\nODM_SetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord, 0x000800E4);\r\nODM_SetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22208000);\r\nODM_SetBBReg(pDM_Odm, rTx_IQK_Tone_A, bMaskDWord, 0x10008C1C);\r\nODM_SetBBReg(pDM_Odm, rTx_IQK, bMaskDWord, 0x01007c00);\r\nODM_SetBBReg(pDM_Odm, rConfig_AntA, bMaskDWord, 0x00080000);\r\nODM_SetBBReg(pDM_Odm, rConfig_AntA, bMaskDWord, 0x0f600000);\r\nODM_SetBBReg(pDM_Odm, rRx_IQK, bMaskDWord, 0x01004800);\r\nODM_SetBBReg(pDM_Odm, rRx_IQK_Tone_A, bMaskDWord, 0x10008c1f);\r\nODM_SetBBReg(pDM_Odm, rTx_IQK_PI_A, bMaskDWord, 0x82150008);\r\nODM_SetBBReg(pDM_Odm, rRx_IQK_PI_A, bMaskDWord, 0x28150008);\r\nODM_SetBBReg(pDM_Odm, rIQK_AGC_Rsp, bMaskDWord, 0x001028d0);\r\nODM_SetRFReg(pDM_Odm, RF_PATH_A, 0x0, 0xFFFFF, 0x50008);\r\nODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x80800000);\r\nODM_SetBBReg(pDM_Odm, rIQK_AGC_Pts, bMaskDWord, 0xf8000000);\r\nODM_StallExecution(1000);\r\nPSD_report_tmp = 0x0;\r\nfor (n = 0; n < 2; n++) {\r\nPSD_report_tmp = GetPSDData(pDM_Odm, 14, initial_gain);\r\nif (PSD_report_tmp > AntA_report)\r\nAntA_report = PSD_report_tmp;\r\n}\r\nPSD_report_tmp = 0x0;\r\nODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, 0x300, Antenna_B);\r\nODM_StallExecution(10);\r\nfor (n = 0; n < 2; n++) {\r\nPSD_report_tmp = GetPSDData(pDM_Odm, 14, initial_gain);\r\nif (PSD_report_tmp > AntB_report)\r\nAntB_report = PSD_report_tmp;\r\n}\r\nODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, 0x300, 0);\r\nODM_StallExecution(10);\r\nfor (n = 0; n < 2; n++) {\r\nPSD_report_tmp = GetPSDData(pDM_Odm, 14, initial_gain);\r\nif (PSD_report_tmp > AntO_report)\r\nAntO_report = PSD_report_tmp;\r\n}\r\nODM_SetBBReg(pDM_Odm, rFPGA0_IQK, bMaskDWord, 0x00000000);\r\nPSD_report_tmp = 0x0;\r\nODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, 0x300, Antenna_A);\r\nODM_SetBBReg(pDM_Odm, rFPGA0_AnalogParameter4, bMaskDWord, Reg88c);\r\nODM_SetBBReg(pDM_Odm, rOFDM0_TRMuxPar, bMaskDWord, Regc08);\r\nODM_SetBBReg(pDM_Odm, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, Reg874);\r\nODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, 0x7F, 0x40);\r\nODM_SetBBReg(pDM_Odm, rOFDM0_XAAGCCore1, bMaskDWord, Regc50);\r\nODM_SetRFReg(pDM_Odm, RF_PATH_A, RF_CHNLBW, bRFRegOffsetMask, CurrentChannel);\r\nODM_SetRFReg(pDM_Odm, RF_PATH_A, 0x00, bRFRegOffsetMask, RfLoopReg);\r\nodm_PHY_ReloadAFERegisters(pDM_Odm, AFE_REG_8723A, AFE_Backup, 16);\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_A[%d]= %d\n", 2416, AntA_report));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_B[%d]= %d\n", 2416, AntB_report));\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("psd_report_O[%d]= %d\n", 2416, AntO_report));\r\nif (pDM_Odm->SupportICType == ODM_RTL8723A) {\r\nif (mode == ANTTESTB) {\r\nif (AntA_report >= 100) {\r\nif (AntB_report > (AntA_report+1)) {\r\npDM_SWAT_Table->ANTB_ON = false;\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Single Antenna A\n"));\r\n} else {\r\npDM_SWAT_Table->ANTB_ON = true;\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Dual Antenna is A and B\n"));\r\n}\r\n} else {\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));\r\npDM_SWAT_Table->ANTB_ON = false;\r\nbResult = false;\r\n}\r\n} else if (mode == ANTTESTALL) {\r\nif ((AntO_report >= 100)&(AntO_report < 118)) {\r\nif (AntA_report > (AntO_report+1)) {\r\npDM_SWAT_Table->ANTA_ON = false;\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Ant A is OFF"));\r\n} else {\r\npDM_SWAT_Table->ANTA_ON = true;\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Ant A is ON"));\r\n}\r\nif (AntB_report > (AntO_report+2)) {\r\npDM_SWAT_Table->ANTB_ON = false;\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Ant B is OFF"));\r\n} else {\r\npDM_SWAT_Table->ANTB_ON = true;\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("Ant B is ON"));\r\n}\r\n}\r\n}\r\n} else if (pDM_Odm->SupportICType == ODM_RTL8192C) {\r\nif (AntA_report >= 100) {\r\nif (AntB_report > (AntA_report+2)) {\r\npDM_SWAT_Table->ANTA_ON = false;\r\npDM_SWAT_Table->ANTB_ON = true;\r\nODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, 0x300, Antenna_B);\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Single Antenna B\n"));\r\n} else if (AntA_report > (AntB_report+2)) {\r\npDM_SWAT_Table->ANTA_ON = true;\r\npDM_SWAT_Table->ANTB_ON = false;\r\nODM_SetBBReg(pDM_Odm, rFPGA0_XA_RFInterfaceOE, 0x300, Antenna_A);\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Single Antenna A\n"));\r\n} else {\r\npDM_SWAT_Table->ANTA_ON = true;\r\npDM_SWAT_Table->ANTB_ON = true;\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,\r\n("ODM_SingleDualAntennaDetection(): Dual Antenna\n"));\r\n}\r\n} else {\r\nODM_RT_TRACE(pDM_Odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD, ("ODM_SingleDualAntennaDetection(): Need to check again\n"));\r\npDM_SWAT_Table->ANTA_ON = true;\r\npDM_SWAT_Table->ANTB_ON = false;\r\nbResult = false;\r\n}\r\n}\r\nreturn bResult;\r\n}\r\nvoid odm_dtc(struct odm_dm_struct *pDM_Odm)\r\n{\r\n}
