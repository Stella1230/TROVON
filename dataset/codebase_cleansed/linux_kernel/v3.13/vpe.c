static struct vpe *get_vpe(int minor)\r\n{\r\nstruct vpe *res, *v;\r\nif (!cpu_has_mipsmt)\r\nreturn NULL;\r\nres = NULL;\r\nspin_lock(&vpecontrol.vpe_list_lock);\r\nlist_for_each_entry(v, &vpecontrol.vpe_list, list) {\r\nif (v->minor == minor) {\r\nres = v;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&vpecontrol.vpe_list_lock);\r\nreturn res;\r\n}\r\nstatic struct tc *get_tc(int index)\r\n{\r\nstruct tc *res, *t;\r\nres = NULL;\r\nspin_lock(&vpecontrol.tc_list_lock);\r\nlist_for_each_entry(t, &vpecontrol.tc_list, list) {\r\nif (t->index == index) {\r\nres = t;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&vpecontrol.tc_list_lock);\r\nreturn res;\r\n}\r\nstatic struct vpe *alloc_vpe(int minor)\r\n{\r\nstruct vpe *v;\r\nif ((v = kzalloc(sizeof(struct vpe), GFP_KERNEL)) == NULL)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&v->tc);\r\nspin_lock(&vpecontrol.vpe_list_lock);\r\nlist_add_tail(&v->list, &vpecontrol.vpe_list);\r\nspin_unlock(&vpecontrol.vpe_list_lock);\r\nINIT_LIST_HEAD(&v->notify);\r\nv->minor = minor;\r\nreturn v;\r\n}\r\nstatic struct tc *alloc_tc(int index)\r\n{\r\nstruct tc *tc;\r\nif ((tc = kzalloc(sizeof(struct tc), GFP_KERNEL)) == NULL)\r\ngoto out;\r\nINIT_LIST_HEAD(&tc->tc);\r\ntc->index = index;\r\nspin_lock(&vpecontrol.tc_list_lock);\r\nlist_add_tail(&tc->list, &vpecontrol.tc_list);\r\nspin_unlock(&vpecontrol.tc_list_lock);\r\nout:\r\nreturn tc;\r\n}\r\nstatic void release_vpe(struct vpe *v)\r\n{\r\nlist_del(&v->list);\r\nif (v->load_addr)\r\nrelease_progmem(v);\r\nkfree(v);\r\n}\r\nstatic void __maybe_unused dump_mtregs(void)\r\n{\r\nunsigned long val;\r\nval = read_c0_config3();\r\nprintk("config3 0x%lx MT %ld\n", val,\r\n(val & CONFIG3_MT) >> CONFIG3_MT_SHIFT);\r\nval = read_c0_mvpcontrol();\r\nprintk("MVPControl 0x%lx, STLB %ld VPC %ld EVP %ld\n", val,\r\n(val & MVPCONTROL_STLB) >> MVPCONTROL_STLB_SHIFT,\r\n(val & MVPCONTROL_VPC) >> MVPCONTROL_VPC_SHIFT,\r\n(val & MVPCONTROL_EVP));\r\nval = read_c0_mvpconf0();\r\nprintk("mvpconf0 0x%lx, PVPE %ld PTC %ld M %ld\n", val,\r\n(val & MVPCONF0_PVPE) >> MVPCONF0_PVPE_SHIFT,\r\nval & MVPCONF0_PTC, (val & MVPCONF0_M) >> MVPCONF0_M_SHIFT);\r\n}\r\nstatic void *alloc_progmem(unsigned long len)\r\n{\r\nvoid *addr;\r\n#ifdef CONFIG_MIPS_VPE_LOADER_TOM\r\naddr = pfn_to_kaddr(max_low_pfn);\r\nmemset(addr, 0, len);\r\n#else\r\naddr = kzalloc(len, GFP_KERNEL);\r\n#endif\r\nreturn addr;\r\n}\r\nstatic void release_progmem(void *ptr)\r\n{\r\n#ifndef CONFIG_MIPS_VPE_LOADER_TOM\r\nkfree(ptr);\r\n#endif\r\n}\r\nstatic long get_offset(unsigned long *size, Elf_Shdr * sechdr)\r\n{\r\nlong ret;\r\nret = ALIGN(*size, sechdr->sh_addralign ? : 1);\r\n*size = ret + sechdr->sh_size;\r\nreturn ret;\r\n}\r\nstatic void layout_sections(struct module *mod, const Elf_Ehdr * hdr,\r\nElf_Shdr * sechdrs, const char *secstrings)\r\n{\r\nstatic unsigned long const masks[][2] = {\r\n{SHF_EXECINSTR | SHF_ALLOC, ARCH_SHF_SMALL},\r\n{SHF_ALLOC, SHF_WRITE | ARCH_SHF_SMALL},\r\n{SHF_WRITE | SHF_ALLOC, ARCH_SHF_SMALL},\r\n{ARCH_SHF_SMALL | SHF_ALLOC, 0}\r\n};\r\nunsigned int m, i;\r\nfor (i = 0; i < hdr->e_shnum; i++)\r\nsechdrs[i].sh_entsize = ~0UL;\r\nfor (m = 0; m < ARRAY_SIZE(masks); ++m) {\r\nfor (i = 0; i < hdr->e_shnum; ++i) {\r\nElf_Shdr *s = &sechdrs[i];\r\nif ((s->sh_flags & masks[m][0]) != masks[m][0]\r\n|| (s->sh_flags & masks[m][1])\r\n|| s->sh_entsize != ~0UL)\r\ncontinue;\r\ns->sh_entsize =\r\nget_offset((unsigned long *)&mod->core_size, s);\r\n}\r\nif (m == 0)\r\nmod->core_text_size = mod->core_size;\r\n}\r\n}\r\nstatic int apply_r_mips_none(struct module *me, uint32_t *location,\r\nElf32_Addr v)\r\n{\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_gprel16(struct module *me, uint32_t *location,\r\nElf32_Addr v)\r\n{\r\nint rel;\r\nif( !(*location & 0xffff) ) {\r\nrel = (int)v - gp_addr;\r\n}\r\nelse {\r\nrel = (int)(short)((int)v + gp_offs +\r\n(int)(short)(*location & 0xffff) - gp_addr);\r\n}\r\nif( (rel > 32768) || (rel < -32768) ) {\r\nprintk(KERN_DEBUG "VPE loader: apply_r_mips_gprel16: "\r\n"relative address 0x%x out of range of gp register\n",\r\nrel);\r\nreturn -ENOEXEC;\r\n}\r\n*location = (*location & 0xffff0000) | (rel & 0xffff);\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_pc16(struct module *me, uint32_t *location,\r\nElf32_Addr v)\r\n{\r\nint rel;\r\nrel = (((unsigned int)v - (unsigned int)location));\r\nrel >>= 2;\r\nrel -= 1;\r\nif( (rel > 32768) || (rel < -32768) ) {\r\nprintk(KERN_DEBUG "VPE loader: "\r\n"apply_r_mips_pc16: relative address out of range 0x%x\n", rel);\r\nreturn -ENOEXEC;\r\n}\r\n*location = (*location & 0xffff0000) | (rel & 0xffff);\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_32(struct module *me, uint32_t *location,\r\nElf32_Addr v)\r\n{\r\n*location += v;\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_26(struct module *me, uint32_t *location,\r\nElf32_Addr v)\r\n{\r\nif (v % 4) {\r\nprintk(KERN_DEBUG "VPE loader: apply_r_mips_26 "\r\n" unaligned relocation\n");\r\nreturn -ENOEXEC;\r\n}\r\n*location = (*location & ~0x03ffffff) |\r\n((*location + (v >> 2)) & 0x03ffffff);\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_hi16(struct module *me, uint32_t *location,\r\nElf32_Addr v)\r\n{\r\nstruct mips_hi16 *n;\r\nn = kmalloc(sizeof *n, GFP_KERNEL);\r\nif (!n)\r\nreturn -ENOMEM;\r\nn->addr = location;\r\nn->value = v;\r\nn->next = mips_hi16_list;\r\nmips_hi16_list = n;\r\nreturn 0;\r\n}\r\nstatic int apply_r_mips_lo16(struct module *me, uint32_t *location,\r\nElf32_Addr v)\r\n{\r\nunsigned long insnlo = *location;\r\nElf32_Addr val, vallo;\r\nstruct mips_hi16 *l, *next;\r\nvallo = ((insnlo & 0xffff) ^ 0x8000) - 0x8000;\r\nif (mips_hi16_list != NULL) {\r\nl = mips_hi16_list;\r\nwhile (l != NULL) {\r\nunsigned long insn;\r\nif (v != l->value) {\r\nprintk(KERN_DEBUG "VPE loader: "\r\n"apply_r_mips_lo16/hi16: \t"\r\n"inconsistent value information\n");\r\ngoto out_free;\r\n}\r\ninsn = *l->addr;\r\nval = ((insn & 0xffff) << 16) + vallo;\r\nval += v;\r\nval = ((val >> 16) + ((val & 0x8000) != 0)) & 0xffff;\r\ninsn = (insn & ~0xffff) | val;\r\n*l->addr = insn;\r\nnext = l->next;\r\nkfree(l);\r\nl = next;\r\n}\r\nmips_hi16_list = NULL;\r\n}\r\nval = v + vallo;\r\ninsnlo = (insnlo & ~0xffff) | (val & 0xffff);\r\n*location = insnlo;\r\nreturn 0;\r\nout_free:\r\nwhile (l != NULL) {\r\nnext = l->next;\r\nkfree(l);\r\nl = next;\r\n}\r\nmips_hi16_list = NULL;\r\nreturn -ENOEXEC;\r\n}\r\nstatic int apply_relocations(Elf32_Shdr *sechdrs,\r\nconst char *strtab,\r\nunsigned int symindex,\r\nunsigned int relsec,\r\nstruct module *me)\r\n{\r\nElf32_Rel *rel = (void *) sechdrs[relsec].sh_addr;\r\nElf32_Sym *sym;\r\nuint32_t *location;\r\nunsigned int i;\r\nElf32_Addr v;\r\nint res;\r\nfor (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {\r\nElf32_Word r_info = rel[i].r_info;\r\nlocation = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr\r\n+ rel[i].r_offset;\r\nsym = (Elf32_Sym *)sechdrs[symindex].sh_addr\r\n+ ELF32_R_SYM(r_info);\r\nif (!sym->st_value) {\r\nprintk(KERN_DEBUG "%s: undefined weak symbol %s\n",\r\nme->name, strtab + sym->st_name);\r\n}\r\nv = sym->st_value;\r\nres = reloc_handlers[ELF32_R_TYPE(r_info)](me, location, v);\r\nif( res ) {\r\nchar *r = rstrs[ELF32_R_TYPE(r_info)];\r\nprintk(KERN_WARNING "VPE loader: .text+0x%x "\r\n"relocation type %s for symbol \"%s\" failed\n",\r\nrel[i].r_offset, r ? r : "UNKNOWN",\r\nstrtab + sym->st_name);\r\nreturn res;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void save_gp_address(unsigned int secbase, unsigned int rel)\r\n{\r\ngp_addr = secbase + rel;\r\ngp_offs = gp_addr - (secbase & 0xffff0000);\r\n}\r\nstatic void simplify_symbols(Elf_Shdr * sechdrs,\r\nunsigned int symindex,\r\nconst char *strtab,\r\nconst char *secstrings,\r\nunsigned int nsecs, struct module *mod)\r\n{\r\nElf_Sym *sym = (void *)sechdrs[symindex].sh_addr;\r\nunsigned long secbase, bssbase = 0;\r\nunsigned int i, n = sechdrs[symindex].sh_size / sizeof(Elf_Sym);\r\nint size;\r\nfor (i = 0; i < nsecs; i++) {\r\nif (strncmp(secstrings + sechdrs[i].sh_name, ".bss", 4) == 0) {\r\nbssbase = sechdrs[i].sh_addr;\r\nbreak;\r\n}\r\n}\r\nfor (i = 1; i < n; i++) {\r\nswitch (sym[i].st_shndx) {\r\ncase SHN_COMMON:\r\nsize = sym[i].st_value;\r\nsym[i].st_value = bssbase;\r\nbssbase += size;\r\nbreak;\r\ncase SHN_ABS:\r\nbreak;\r\ncase SHN_UNDEF:\r\nbreak;\r\ncase SHN_MIPS_SCOMMON:\r\nprintk(KERN_DEBUG "simplify_symbols: ignoring SHN_MIPS_SCOMMON "\r\n"symbol <%s> st_shndx %d\n", strtab + sym[i].st_name,\r\nsym[i].st_shndx);\r\nbreak;\r\ndefault:\r\nsecbase = sechdrs[sym[i].st_shndx].sh_addr;\r\nif (strncmp(strtab + sym[i].st_name, "_gp", 3) == 0) {\r\nsave_gp_address(secbase, sym[i].st_value);\r\n}\r\nsym[i].st_value += secbase;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void dump_elfsymbols(Elf_Shdr * sechdrs, unsigned int symindex,\r\nconst char *strtab, struct module *mod)\r\n{\r\nElf_Sym *sym = (void *)sechdrs[symindex].sh_addr;\r\nunsigned int i, n = sechdrs[symindex].sh_size / sizeof(Elf_Sym);\r\nprintk(KERN_DEBUG "dump_elfsymbols: n %d\n", n);\r\nfor (i = 1; i < n; i++) {\r\nprintk(KERN_DEBUG " i %d name <%s> 0x%x\n", i,\r\nstrtab + sym[i].st_name, sym[i].st_value);\r\n}\r\n}\r\nstatic int vpe_run(struct vpe * v)\r\n{\r\nunsigned long flags, val, dmt_flag;\r\nstruct vpe_notifications *n;\r\nunsigned int vpeflags;\r\nstruct tc *t;\r\nlocal_irq_save(flags);\r\nval = read_c0_vpeconf0();\r\nif (!(val & VPECONF0_MVP)) {\r\nprintk(KERN_WARNING\r\n"VPE loader: only Master VPE's are allowed to configure MT\n");\r\nlocal_irq_restore(flags);\r\nreturn -1;\r\n}\r\ndmt_flag = dmt();\r\nvpeflags = dvpe();\r\nif (list_empty(&v->tc)) {\r\nevpe(vpeflags);\r\nemt(dmt_flag);\r\nlocal_irq_restore(flags);\r\nprintk(KERN_WARNING\r\n"VPE loader: No TC's associated with VPE %d\n",\r\nv->minor);\r\nreturn -ENOEXEC;\r\n}\r\nt = list_first_entry(&v->tc, struct tc, tc);\r\nset_c0_mvpcontrol(MVPCONTROL_VPC);\r\nsettc(t->index);\r\nif ((read_tc_c0_tcstatus() & TCSTATUS_A) || !(read_tc_c0_tchalt() & TCHALT_H)) {\r\nevpe(vpeflags);\r\nemt(dmt_flag);\r\nlocal_irq_restore(flags);\r\nprintk(KERN_WARNING "VPE loader: TC %d is already active!\n",\r\nt->index);\r\nreturn -ENOEXEC;\r\n}\r\nwrite_tc_c0_tcrestart((unsigned long)v->__start);\r\nwrite_tc_c0_tccontext((unsigned long)0);\r\nval = read_tc_c0_tcstatus();\r\nval = (val & ~(TCSTATUS_DA | TCSTATUS_IXMT)) | TCSTATUS_A;\r\nwrite_tc_c0_tcstatus(val);\r\nwrite_tc_c0_tchalt(read_tc_c0_tchalt() & ~TCHALT_H);\r\nmttgpr(6, v->ntcs);\r\nmttgpr(7, physical_memsize);\r\nwrite_tc_c0_tcbind((read_tc_c0_tcbind() & ~TCBIND_CURVPE) | 1);\r\nwrite_vpe_c0_vpeconf0(read_vpe_c0_vpeconf0() & ~(VPECONF0_VPA));\r\nback_to_back_c0_hazard();\r\nwrite_vpe_c0_vpeconf0( (read_vpe_c0_vpeconf0() & ~(VPECONF0_XTC))\r\n| (t->index << VPECONF0_XTC_SHIFT));\r\nback_to_back_c0_hazard();\r\nwrite_vpe_c0_vpeconf0(read_vpe_c0_vpeconf0() | VPECONF0_VPA);\r\nwrite_vpe_c0_status(0);\r\nwrite_vpe_c0_cause(0);\r\nclear_c0_mvpcontrol(MVPCONTROL_VPC);\r\n#ifdef CONFIG_SMP\r\nevpe(vpeflags);\r\n#else\r\nevpe(EVPE_ENABLE);\r\n#endif\r\nemt(dmt_flag);\r\nlocal_irq_restore(flags);\r\nlist_for_each_entry(n, &v->notify, list)\r\nn->start(minor);\r\nreturn 0;\r\n}\r\nstatic int find_vpe_symbols(struct vpe * v, Elf_Shdr * sechdrs,\r\nunsigned int symindex, const char *strtab,\r\nstruct module *mod)\r\n{\r\nElf_Sym *sym = (void *)sechdrs[symindex].sh_addr;\r\nunsigned int i, n = sechdrs[symindex].sh_size / sizeof(Elf_Sym);\r\nfor (i = 1; i < n; i++) {\r\nif (strcmp(strtab + sym[i].st_name, "__start") == 0) {\r\nv->__start = sym[i].st_value;\r\n}\r\nif (strcmp(strtab + sym[i].st_name, "vpe_shared") == 0) {\r\nv->shared_ptr = (void *)sym[i].st_value;\r\n}\r\n}\r\nif ( (v->__start == 0) || (v->shared_ptr == NULL))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int vpe_elfload(struct vpe * v)\r\n{\r\nElf_Ehdr *hdr;\r\nElf_Shdr *sechdrs;\r\nlong err = 0;\r\nchar *secstrings, *strtab = NULL;\r\nunsigned int len, i, symindex = 0, strindex = 0, relocate = 0;\r\nstruct module mod;\r\nmemset(&mod, 0, sizeof(struct module));\r\nstrcpy(mod.name, "VPE loader");\r\nhdr = (Elf_Ehdr *) v->pbuffer;\r\nlen = v->plen;\r\nif (memcmp(hdr->e_ident, ELFMAG, SELFMAG) != 0\r\n|| (hdr->e_type != ET_REL && hdr->e_type != ET_EXEC)\r\n|| !elf_check_arch(hdr)\r\n|| hdr->e_shentsize != sizeof(*sechdrs)) {\r\nprintk(KERN_WARNING\r\n"VPE loader: program wrong arch or weird elf version\n");\r\nreturn -ENOEXEC;\r\n}\r\nif (hdr->e_type == ET_REL)\r\nrelocate = 1;\r\nif (len < hdr->e_shoff + hdr->e_shnum * sizeof(Elf_Shdr)) {\r\nprintk(KERN_ERR "VPE loader: program length %u truncated\n",\r\nlen);\r\nreturn -ENOEXEC;\r\n}\r\nsechdrs = (void *)hdr + hdr->e_shoff;\r\nsecstrings = (void *)hdr + sechdrs[hdr->e_shstrndx].sh_offset;\r\nsechdrs[0].sh_addr = 0;\r\nsymindex = strindex = 0;\r\nif (relocate) {\r\nfor (i = 1; i < hdr->e_shnum; i++) {\r\nif (sechdrs[i].sh_type != SHT_NOBITS\r\n&& len < sechdrs[i].sh_offset + sechdrs[i].sh_size) {\r\nprintk(KERN_ERR "VPE program length %u truncated\n",\r\nlen);\r\nreturn -ENOEXEC;\r\n}\r\nsechdrs[i].sh_addr = (size_t) hdr + sechdrs[i].sh_offset;\r\nif (sechdrs[i].sh_type == SHT_SYMTAB) {\r\nsymindex = i;\r\nstrindex = sechdrs[i].sh_link;\r\nstrtab = (char *)hdr + sechdrs[strindex].sh_offset;\r\n}\r\n}\r\nlayout_sections(&mod, hdr, sechdrs, secstrings);\r\n}\r\nv->load_addr = alloc_progmem(mod.core_size);\r\nif (!v->load_addr)\r\nreturn -ENOMEM;\r\npr_info("VPE loader: loading to %p\n", v->load_addr);\r\nif (relocate) {\r\nfor (i = 0; i < hdr->e_shnum; i++) {\r\nvoid *dest;\r\nif (!(sechdrs[i].sh_flags & SHF_ALLOC))\r\ncontinue;\r\ndest = v->load_addr + sechdrs[i].sh_entsize;\r\nif (sechdrs[i].sh_type != SHT_NOBITS)\r\nmemcpy(dest, (void *)sechdrs[i].sh_addr,\r\nsechdrs[i].sh_size);\r\nsechdrs[i].sh_addr = (unsigned long)dest;\r\nprintk(KERN_DEBUG " section sh_name %s sh_addr 0x%x\n",\r\nsecstrings + sechdrs[i].sh_name, sechdrs[i].sh_addr);\r\n}\r\nsimplify_symbols(sechdrs, symindex, strtab, secstrings,\r\nhdr->e_shnum, &mod);\r\nfor (i = 1; i < hdr->e_shnum; i++) {\r\nconst char *strtab = (char *)sechdrs[strindex].sh_addr;\r\nunsigned int info = sechdrs[i].sh_info;\r\nif (info >= hdr->e_shnum)\r\ncontinue;\r\nif (!(sechdrs[info].sh_flags & SHF_ALLOC))\r\ncontinue;\r\nif (sechdrs[i].sh_type == SHT_REL)\r\nerr = apply_relocations(sechdrs, strtab, symindex, i,\r\n&mod);\r\nelse if (sechdrs[i].sh_type == SHT_RELA)\r\nerr = apply_relocate_add(sechdrs, strtab, symindex, i,\r\n&mod);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n} else {\r\nstruct elf_phdr *phdr = (struct elf_phdr *) ((char *)hdr + hdr->e_phoff);\r\nfor (i = 0; i < hdr->e_phnum; i++) {\r\nif (phdr->p_type == PT_LOAD) {\r\nmemcpy((void *)phdr->p_paddr,\r\n(char *)hdr + phdr->p_offset,\r\nphdr->p_filesz);\r\nmemset((void *)phdr->p_paddr + phdr->p_filesz,\r\n0, phdr->p_memsz - phdr->p_filesz);\r\n}\r\nphdr++;\r\n}\r\nfor (i = 0; i < hdr->e_shnum; i++) {\r\nif (sechdrs[i].sh_type == SHT_SYMTAB) {\r\nsymindex = i;\r\nstrindex = sechdrs[i].sh_link;\r\nstrtab = (char *)hdr + sechdrs[strindex].sh_offset;\r\nsechdrs[i].sh_addr = (size_t) hdr + sechdrs[i].sh_offset;\r\n}\r\n}\r\n}\r\nflush_icache_range((unsigned long)v->load_addr,\r\n(unsigned long)v->load_addr + v->len);\r\nif ((find_vpe_symbols(v, sechdrs, symindex, strtab, &mod)) < 0) {\r\nif (v->__start == 0) {\r\nprintk(KERN_WARNING "VPE loader: program does not contain "\r\n"a __start symbol\n");\r\nreturn -ENOEXEC;\r\n}\r\nif (v->shared_ptr == NULL)\r\nprintk(KERN_WARNING "VPE loader: "\r\n"program does not contain vpe_shared symbol.\n"\r\n" Unable to use AMVP (AP/SP) facilities.\n");\r\n}\r\nprintk(" elf loaded\n");\r\nreturn 0;\r\n}\r\nstatic void cleanup_tc(struct tc *tc)\r\n{\r\nunsigned long flags;\r\nunsigned int mtflags, vpflags;\r\nint tmp;\r\nlocal_irq_save(flags);\r\nmtflags = dmt();\r\nvpflags = dvpe();\r\nset_c0_mvpcontrol(MVPCONTROL_VPC);\r\nsettc(tc->index);\r\ntmp = read_tc_c0_tcstatus();\r\ntmp &= ~(TCSTATUS_A | TCSTATUS_DA);\r\ntmp |= TCSTATUS_IXMT;\r\nwrite_tc_c0_tcstatus(tmp);\r\nwrite_tc_c0_tchalt(TCHALT_H);\r\nmips_ihb();\r\nclear_c0_mvpcontrol(MVPCONTROL_VPC);\r\nevpe(vpflags);\r\nemt(mtflags);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int getcwd(char *buff, int size)\r\n{\r\nmm_segment_t old_fs;\r\nint ret;\r\nold_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nret = sys_getcwd(buff, size);\r\nset_fs(old_fs);\r\nreturn ret;\r\n}\r\nstatic int vpe_open(struct inode *inode, struct file *filp)\r\n{\r\nenum vpe_state state;\r\nstruct vpe_notifications *not;\r\nstruct vpe *v;\r\nint ret;\r\nif (minor != iminor(inode)) {\r\npr_warning("VPE loader: only vpe1 is supported\n");\r\nreturn -ENODEV;\r\n}\r\nif ((v = get_vpe(tclimit)) == NULL) {\r\npr_warning("VPE loader: unable to get vpe\n");\r\nreturn -ENODEV;\r\n}\r\nstate = xchg(&v->state, VPE_STATE_INUSE);\r\nif (state != VPE_STATE_UNUSED) {\r\nprintk(KERN_DEBUG "VPE loader: tc in use dumping regs\n");\r\nlist_for_each_entry(not, &v->notify, list) {\r\nnot->stop(tclimit);\r\n}\r\nrelease_progmem(v->load_addr);\r\ncleanup_tc(get_tc(tclimit));\r\n}\r\nv->pbuffer = vmalloc(P_SIZE);\r\nif (!v->pbuffer) {\r\npr_warning("VPE loader: unable to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nv->plen = P_SIZE;\r\nv->load_addr = NULL;\r\nv->len = 0;\r\nv->uid = filp->f_cred->fsuid;\r\nv->gid = filp->f_cred->fsgid;\r\nv->cwd[0] = 0;\r\nret = getcwd(v->cwd, VPE_PATH_MAX);\r\nif (ret < 0)\r\nprintk(KERN_WARNING "VPE loader: open, getcwd returned %d\n", ret);\r\nv->shared_ptr = NULL;\r\nv->__start = 0;\r\nreturn 0;\r\n}\r\nstatic int vpe_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct vpe *v;\r\nElf_Ehdr *hdr;\r\nint ret = 0;\r\nv = get_vpe(tclimit);\r\nif (v == NULL)\r\nreturn -ENODEV;\r\nhdr = (Elf_Ehdr *) v->pbuffer;\r\nif (memcmp(hdr->e_ident, ELFMAG, SELFMAG) == 0) {\r\nif (vpe_elfload(v) >= 0) {\r\nvpe_run(v);\r\n} else {\r\nprintk(KERN_WARNING "VPE loader: ELF load failed.\n");\r\nret = -ENOEXEC;\r\n}\r\n} else {\r\nprintk(KERN_WARNING "VPE loader: only elf files are supported\n");\r\nret = -ENOEXEC;\r\n}\r\nif (ret < 0)\r\nv->shared_ptr = NULL;\r\nvfree(v->pbuffer);\r\nv->plen = 0;\r\nreturn ret;\r\n}\r\nstatic ssize_t vpe_write(struct file *file, const char __user * buffer,\r\nsize_t count, loff_t * ppos)\r\n{\r\nsize_t ret = count;\r\nstruct vpe *v;\r\nif (iminor(file_inode(file)) != minor)\r\nreturn -ENODEV;\r\nv = get_vpe(tclimit);\r\nif (v == NULL)\r\nreturn -ENODEV;\r\nif ((count + v->len) > v->plen) {\r\nprintk(KERN_WARNING\r\n"VPE loader: elf size too big. Perhaps strip uneeded symbols\n");\r\nreturn -ENOMEM;\r\n}\r\ncount -= copy_from_user(v->pbuffer + v->len, buffer, count);\r\nif (!count)\r\nreturn -EFAULT;\r\nv->len += count;\r\nreturn ret;\r\n}\r\nvpe_handle vpe_alloc(void)\r\n{\r\nint i;\r\nstruct vpe *v;\r\nfor (i = 1; i < MAX_VPES; i++) {\r\nif ((v = get_vpe(i)) != NULL) {\r\nv->state = VPE_STATE_INUSE;\r\nreturn v;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nint vpe_start(vpe_handle vpe, unsigned long start)\r\n{\r\nstruct vpe *v = vpe;\r\nv->__start = start;\r\nreturn vpe_run(v);\r\n}\r\nint vpe_stop(vpe_handle vpe)\r\n{\r\nstruct vpe *v = vpe;\r\nstruct tc *t;\r\nunsigned int evpe_flags;\r\nevpe_flags = dvpe();\r\nif ((t = list_entry(v->tc.next, struct tc, tc)) != NULL) {\r\nsettc(t->index);\r\nwrite_vpe_c0_vpeconf0(read_vpe_c0_vpeconf0() & ~VPECONF0_VPA);\r\n}\r\nevpe(evpe_flags);\r\nreturn 0;\r\n}\r\nint vpe_free(vpe_handle vpe)\r\n{\r\nstruct vpe *v = vpe;\r\nstruct tc *t;\r\nunsigned int evpe_flags;\r\nif ((t = list_entry(v->tc.next, struct tc, tc)) == NULL) {\r\nreturn -ENOEXEC;\r\n}\r\nevpe_flags = dvpe();\r\nset_c0_mvpcontrol(MVPCONTROL_VPC);\r\nsettc(t->index);\r\nwrite_vpe_c0_vpeconf0(read_vpe_c0_vpeconf0() & ~VPECONF0_VPA);\r\nwrite_tc_c0_tchalt(TCHALT_H);\r\nmips_ihb();\r\nwrite_tc_c0_tcstatus(read_tc_c0_tcstatus() & ~TCSTATUS_A);\r\nv->state = VPE_STATE_UNUSED;\r\nclear_c0_mvpcontrol(MVPCONTROL_VPC);\r\nevpe(evpe_flags);\r\nreturn 0;\r\n}\r\nvoid *vpe_get_shared(int index)\r\n{\r\nstruct vpe *v;\r\nif ((v = get_vpe(index)) == NULL)\r\nreturn NULL;\r\nreturn v->shared_ptr;\r\n}\r\nint vpe_getuid(int index)\r\n{\r\nstruct vpe *v;\r\nif ((v = get_vpe(index)) == NULL)\r\nreturn -1;\r\nreturn v->uid;\r\n}\r\nint vpe_getgid(int index)\r\n{\r\nstruct vpe *v;\r\nif ((v = get_vpe(index)) == NULL)\r\nreturn -1;\r\nreturn v->gid;\r\n}\r\nint vpe_notify(int index, struct vpe_notifications *notify)\r\n{\r\nstruct vpe *v;\r\nif ((v = get_vpe(index)) == NULL)\r\nreturn -1;\r\nlist_add(&notify->list, &v->notify);\r\nreturn 0;\r\n}\r\nchar *vpe_getcwd(int index)\r\n{\r\nstruct vpe *v;\r\nif ((v = get_vpe(index)) == NULL)\r\nreturn NULL;\r\nreturn v->cwd;\r\n}\r\nstatic ssize_t store_kill(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct vpe *vpe = get_vpe(tclimit);\r\nstruct vpe_notifications *not;\r\nlist_for_each_entry(not, &vpe->notify, list) {\r\nnot->stop(tclimit);\r\n}\r\nrelease_progmem(vpe->load_addr);\r\ncleanup_tc(get_tc(tclimit));\r\nvpe_stop(vpe);\r\nvpe_free(vpe);\r\nreturn len;\r\n}\r\nstatic ssize_t ntcs_show(struct device *cd, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct vpe *vpe = get_vpe(tclimit);\r\nreturn sprintf(buf, "%d\n", vpe->ntcs);\r\n}\r\nstatic ssize_t ntcs_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct vpe *vpe = get_vpe(tclimit);\r\nunsigned long new;\r\nchar *endp;\r\nnew = simple_strtoul(buf, &endp, 0);\r\nif (endp == buf)\r\ngoto out_einval;\r\nif (new == 0 || new > (hw_tcs - tclimit))\r\ngoto out_einval;\r\nvpe->ntcs = new;\r\nreturn len;\r\nout_einval:\r\nreturn -EINVAL;\r\n}\r\nstatic void vpe_device_release(struct device *cd)\r\n{\r\nkfree(cd);\r\n}\r\nstatic int __init vpe_module_init(void)\r\n{\r\nunsigned int mtflags, vpflags;\r\nunsigned long flags, val;\r\nstruct vpe *v = NULL;\r\nstruct tc *t;\r\nint tc, err;\r\nif (!cpu_has_mipsmt) {\r\nprintk("VPE loader: not a MIPS MT capable processor\n");\r\nreturn -ENODEV;\r\n}\r\nif (vpelimit == 0) {\r\nprintk(KERN_WARNING "No VPEs reserved for AP/SP, not "\r\n"initializing VPE loader.\nPass maxvpes=<n> argument as "\r\n"kernel argument\n");\r\nreturn -ENODEV;\r\n}\r\nif (tclimit == 0) {\r\nprintk(KERN_WARNING "No TCs reserved for AP/SP, not "\r\n"initializing VPE loader.\nPass maxtcs=<n> argument as "\r\n"kernel argument\n");\r\nreturn -ENODEV;\r\n}\r\nmajor = register_chrdev(0, module_name, &vpe_fops);\r\nif (major < 0) {\r\nprintk("VPE loader: unable to register character device\n");\r\nreturn major;\r\n}\r\nerr = class_register(&vpe_class);\r\nif (err) {\r\nprintk(KERN_ERR "vpe_class registration failed\n");\r\ngoto out_chrdev;\r\n}\r\ndevice_initialize(&vpe_device);\r\nvpe_device.class = &vpe_class,\r\nvpe_device.parent = NULL,\r\ndev_set_name(&vpe_device, "vpe1");\r\nvpe_device.devt = MKDEV(major, minor);\r\nerr = device_add(&vpe_device);\r\nif (err) {\r\nprintk(KERN_ERR "Adding vpe_device failed\n");\r\ngoto out_class;\r\n}\r\nlocal_irq_save(flags);\r\nmtflags = dmt();\r\nvpflags = dvpe();\r\nset_c0_mvpcontrol(MVPCONTROL_VPC);\r\nval = read_c0_mvpconf0();\r\nhw_tcs = (val & MVPCONF0_PTC) + 1;\r\nhw_vpes = ((val & MVPCONF0_PVPE) >> MVPCONF0_PVPE_SHIFT) + 1;\r\nfor (tc = tclimit; tc < hw_tcs; tc++) {\r\nclear_c0_mvpcontrol(MVPCONTROL_VPC);\r\nevpe(vpflags);\r\nemt(mtflags);\r\nlocal_irq_restore(flags);\r\nt = alloc_tc(tc);\r\nif (!t) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nlocal_irq_save(flags);\r\nmtflags = dmt();\r\nvpflags = dvpe();\r\nset_c0_mvpcontrol(MVPCONTROL_VPC);\r\nif (tc < hw_tcs) {\r\nsettc(tc);\r\nif ((v = alloc_vpe(tc)) == NULL) {\r\nprintk(KERN_WARNING "VPE: unable to allocate VPE\n");\r\ngoto out_reenable;\r\n}\r\nv->ntcs = hw_tcs - tclimit;\r\nlist_add(&t->tc, &v->tc);\r\nif (tc >= tclimit) {\r\nunsigned long tmp = read_vpe_c0_vpeconf0();\r\ntmp &= ~VPECONF0_VPA;\r\ntmp |= VPECONF0_MVP;\r\nwrite_vpe_c0_vpeconf0(tmp);\r\n}\r\nwrite_vpe_c0_vpecontrol(read_vpe_c0_vpecontrol() & ~VPECONTROL_TE);\r\nif (tc >= vpelimit) {\r\nwrite_vpe_c0_config(read_c0_config());\r\n}\r\n}\r\nt->pvpe = v;\r\nif (tc >= tclimit) {\r\nunsigned long tmp;\r\nsettc(tc);\r\nif (((tmp = read_tc_c0_tcbind()) & TCBIND_CURVPE)) {\r\nwrite_tc_c0_tcbind(tmp & ~TCBIND_CURVPE);\r\nt->pvpe = get_vpe(0);\r\n}\r\nwrite_tc_c0_tchalt(TCHALT_H);\r\nmips_ihb();\r\ntmp = read_tc_c0_tcstatus();\r\ntmp &= ~(TCSTATUS_A | TCSTATUS_DA);\r\ntmp |= TCSTATUS_IXMT;\r\nwrite_tc_c0_tcstatus(tmp);\r\n}\r\n}\r\nout_reenable:\r\nclear_c0_mvpcontrol(MVPCONTROL_VPC);\r\nevpe(vpflags);\r\nemt(mtflags);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\nout_class:\r\nclass_unregister(&vpe_class);\r\nout_chrdev:\r\nunregister_chrdev(major, module_name);\r\nout:\r\nreturn err;\r\n}\r\nstatic void __exit vpe_module_exit(void)\r\n{\r\nstruct vpe *v, *n;\r\ndevice_del(&vpe_device);\r\nunregister_chrdev(major, module_name);\r\nlist_for_each_entry_safe(v, n, &vpecontrol.vpe_list, list) {\r\nif (v->state != VPE_STATE_UNUSED)\r\nrelease_vpe(v);\r\n}\r\n}
