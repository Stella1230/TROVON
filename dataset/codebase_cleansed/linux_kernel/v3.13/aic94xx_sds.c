static int asd_read_ocm_seg(struct asd_ha_struct *asd_ha, void *buffer,\r\nu32 offs, int size)\r\n{\r\nu8 *p = buffer;\r\nif (unlikely(asd_ha->iospace))\r\nasd_read_reg_string(asd_ha, buffer, offs+OCM_BASE_ADDR, size);\r\nelse {\r\nfor ( ; size > 0; size--, offs++, p++)\r\n*p = asd_read_ocm_byte(asd_ha, offs);\r\n}\r\nreturn size;\r\n}\r\nstatic int asd_read_ocm_dir(struct asd_ha_struct *asd_ha,\r\nstruct asd_ocm_dir *dir, u32 offs)\r\n{\r\nint err = asd_read_ocm_seg(asd_ha, dir, offs, sizeof(*dir));\r\nif (err) {\r\nASD_DPRINTK("couldn't read ocm segment\n");\r\nreturn err;\r\n}\r\nif (dir->sig[0] != 'M' || dir->sig[1] != 'O') {\r\nASD_DPRINTK("no valid dir signature(%c%c) at start of OCM\n",\r\ndir->sig[0], dir->sig[1]);\r\nreturn -ENOENT;\r\n}\r\nif (dir->major != 0) {\r\nasd_printk("unsupported major version of ocm dir:0x%x\n",\r\ndir->major);\r\nreturn -ENOENT;\r\n}\r\ndir->num_de &= 0xf;\r\nreturn 0;\r\n}\r\nstatic void asd_write_ocm_seg(struct asd_ha_struct *asd_ha, void *buffer,\r\nu32 offs, int size)\r\n{\r\nu8 *p = buffer;\r\nif (unlikely(asd_ha->iospace))\r\nasd_write_reg_string(asd_ha, buffer, offs+OCM_BASE_ADDR, size);\r\nelse {\r\nfor ( ; size > 0; size--, offs++, p++)\r\nasd_write_ocm_byte(asd_ha, offs, *p);\r\n}\r\nreturn;\r\n}\r\nstatic int asd_find_dir_entry(struct asd_ocm_dir *dir, u8 type,\r\nu32 *offs, u32 *size)\r\n{\r\nint i;\r\nstruct asd_ocm_dir_ent *ent;\r\nfor (i = 0; i < dir->num_de; i++) {\r\nif (dir->entry[i].type == type)\r\nbreak;\r\n}\r\nif (i >= dir->num_de)\r\nreturn -ENOENT;\r\nent = &dir->entry[i];\r\n*offs = (u32) THREE_TO_NUM(ent->offs);\r\n*size = (u32) THREE_TO_NUM(ent->size);\r\nreturn 0;\r\n}\r\nstatic int asd_get_bios_chim(struct asd_ha_struct *asd_ha,\r\nstruct asd_ocm_dir *dir)\r\n{\r\nint err;\r\nstruct asd_bios_chim_struct *bc_struct;\r\nu32 offs, size;\r\nerr = asd_find_dir_entry(dir, OCM_BIOS_CHIM_DE, &offs, &size);\r\nif (err) {\r\nASD_DPRINTK("couldn't find BIOS_CHIM dir ent\n");\r\ngoto out;\r\n}\r\nerr = -ENOMEM;\r\nbc_struct = kmalloc(sizeof(*bc_struct), GFP_KERNEL);\r\nif (!bc_struct) {\r\nasd_printk("no memory for bios_chim struct\n");\r\ngoto out;\r\n}\r\nerr = asd_read_ocm_seg(asd_ha, (void *)bc_struct, offs,\r\nsizeof(*bc_struct));\r\nif (err) {\r\nASD_DPRINTK("couldn't read ocm segment\n");\r\ngoto out2;\r\n}\r\nif (strncmp(bc_struct->sig, "SOIB", 4)\r\n&& strncmp(bc_struct->sig, "IPSA", 4)) {\r\nASD_DPRINTK("BIOS_CHIM entry has no valid sig(%c%c%c%c)\n",\r\nbc_struct->sig[0], bc_struct->sig[1],\r\nbc_struct->sig[2], bc_struct->sig[3]);\r\nerr = -ENOENT;\r\ngoto out2;\r\n}\r\nif (bc_struct->major != 1) {\r\nasd_printk("BIOS_CHIM unsupported major version:0x%x\n",\r\nbc_struct->major);\r\nerr = -ENOENT;\r\ngoto out2;\r\n}\r\nif (bc_struct->flags & BC_BIOS_PRESENT) {\r\nasd_ha->hw_prof.bios.present = 1;\r\nasd_ha->hw_prof.bios.maj = bc_struct->bios_major;\r\nasd_ha->hw_prof.bios.min = bc_struct->bios_minor;\r\nasd_ha->hw_prof.bios.bld = le32_to_cpu(bc_struct->bios_build);\r\nASD_DPRINTK("BIOS present (%d,%d), %d\n",\r\nasd_ha->hw_prof.bios.maj,\r\nasd_ha->hw_prof.bios.min,\r\nasd_ha->hw_prof.bios.bld);\r\n}\r\nasd_ha->hw_prof.ue.num = le16_to_cpu(bc_struct->ue_num);\r\nasd_ha->hw_prof.ue.size= le16_to_cpu(bc_struct->ue_size);\r\nASD_DPRINTK("ue num:%d, ue size:%d\n", asd_ha->hw_prof.ue.num,\r\nasd_ha->hw_prof.ue.size);\r\nsize = asd_ha->hw_prof.ue.num * asd_ha->hw_prof.ue.size;\r\nif (size > 0) {\r\nerr = -ENOMEM;\r\nasd_ha->hw_prof.ue.area = kmalloc(size, GFP_KERNEL);\r\nif (!asd_ha->hw_prof.ue.area)\r\ngoto out2;\r\nerr = asd_read_ocm_seg(asd_ha, (void *)asd_ha->hw_prof.ue.area,\r\noffs + sizeof(*bc_struct), size);\r\nif (err) {\r\nkfree(asd_ha->hw_prof.ue.area);\r\nasd_ha->hw_prof.ue.area = NULL;\r\nasd_ha->hw_prof.ue.num = 0;\r\nasd_ha->hw_prof.ue.size = 0;\r\nASD_DPRINTK("couldn't read ue entries(%d)\n", err);\r\n}\r\n}\r\nout2:\r\nkfree(bc_struct);\r\nout:\r\nreturn err;\r\n}\r\nstatic void\r\nasd_hwi_initialize_ocm_dir (struct asd_ha_struct *asd_ha)\r\n{\r\nint i;\r\nfor (i = 0; i < OCM_MAX_SIZE; i += 4)\r\nasd_write_ocm_dword(asd_ha, i, 0);\r\nasd_write_ocm_seg(asd_ha, &OCMDirInit, 0,\r\nsizeof(struct asd_ocm_dir));\r\nfor (i = 0; i < OCM_INIT_DIR_ENTRIES; i++)\r\nasd_write_ocm_seg(asd_ha, &OCMDirEntriesInit[i],\r\nsizeof(struct asd_ocm_dir) +\r\n(i * sizeof(struct asd_ocm_dir_ent))\r\n, sizeof(struct asd_ocm_dir_ent));\r\n}\r\nstatic int\r\nasd_hwi_check_ocm_access (struct asd_ha_struct *asd_ha)\r\n{\r\nstruct pci_dev *pcidev = asd_ha->pcidev;\r\nu32 reg;\r\nint err = 0;\r\nu32 v;\r\nreg = asd_read_reg_dword(asd_ha, EXSICNFGR);\r\nif (!(reg & OCMINITIALIZED)) {\r\nerr = pci_read_config_dword(pcidev, PCIC_INTRPT_STAT, &v);\r\nif (err) {\r\nasd_printk("couldn't access PCIC_INTRPT_STAT of %s\n",\r\npci_name(pcidev));\r\ngoto out;\r\n}\r\nprintk(KERN_INFO "OCM is not initialized by BIOS,"\r\n"reinitialize it and ignore it, current IntrptStatus"\r\n"is 0x%x\n", v);\r\nif (v)\r\nerr = pci_write_config_dword(pcidev,\r\nPCIC_INTRPT_STAT, v);\r\nif (err) {\r\nasd_printk("couldn't write PCIC_INTRPT_STAT of %s\n",\r\npci_name(pcidev));\r\ngoto out;\r\n}\r\nasd_hwi_initialize_ocm_dir(asd_ha);\r\n}\r\nout:\r\nreturn err;\r\n}\r\nint asd_read_ocm(struct asd_ha_struct *asd_ha)\r\n{\r\nint err;\r\nstruct asd_ocm_dir *dir;\r\nif (asd_hwi_check_ocm_access(asd_ha))\r\nreturn -1;\r\ndir = kmalloc(sizeof(*dir), GFP_KERNEL);\r\nif (!dir) {\r\nasd_printk("no memory for ocm dir\n");\r\nreturn -ENOMEM;\r\n}\r\nerr = asd_read_ocm_dir(asd_ha, dir, 0);\r\nif (err)\r\ngoto out;\r\nerr = asd_get_bios_chim(asd_ha, dir);\r\nout:\r\nkfree(dir);\r\nreturn err;\r\n}\r\nstatic int asd_poll_flash(struct asd_ha_struct *asd_ha)\r\n{\r\nint c;\r\nu8 d;\r\nfor (c = 5000; c > 0; c--) {\r\nd = asd_read_reg_byte(asd_ha, asd_ha->hw_prof.flash.bar);\r\nd ^= asd_read_reg_byte(asd_ha, asd_ha->hw_prof.flash.bar);\r\nif (!d)\r\nreturn 0;\r\nudelay(5);\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int asd_reset_flash(struct asd_ha_struct *asd_ha)\r\n{\r\nint err;\r\nerr = asd_poll_flash(asd_ha);\r\nif (err)\r\nreturn err;\r\nasd_write_reg_byte(asd_ha, asd_ha->hw_prof.flash.bar, FLASH_RESET);\r\nerr = asd_poll_flash(asd_ha);\r\nreturn err;\r\n}\r\nstatic int asd_read_flash_seg(struct asd_ha_struct *asd_ha,\r\nvoid *buffer, u32 offs, int size)\r\n{\r\nasd_read_reg_string(asd_ha, buffer, asd_ha->hw_prof.flash.bar+offs,\r\nsize);\r\nreturn 0;\r\n}\r\nstatic int asd_find_flash_dir(struct asd_ha_struct *asd_ha,\r\nstruct asd_flash_dir *flash_dir)\r\n{\r\nu32 v;\r\nfor (v = 0; v < ASD_FLASH_SIZE; v += FLASH_NEXT_ENTRY_OFFS) {\r\nasd_read_flash_seg(asd_ha, flash_dir, v,\r\nsizeof(FLASH_DIR_COOKIE)-1);\r\nif (memcmp(flash_dir->cookie, FLASH_DIR_COOKIE,\r\nsizeof(FLASH_DIR_COOKIE)-1) == 0) {\r\nasd_ha->hw_prof.flash.dir_offs = v;\r\nasd_read_flash_seg(asd_ha, flash_dir, v,\r\nsizeof(*flash_dir));\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int asd_flash_getid(struct asd_ha_struct *asd_ha)\r\n{\r\nint err = 0;\r\nu32 reg;\r\nreg = asd_read_reg_dword(asd_ha, EXSICNFGR);\r\nif (pci_read_config_dword(asd_ha->pcidev, PCI_CONF_FLSH_BAR,\r\n&asd_ha->hw_prof.flash.bar)) {\r\nasd_printk("couldn't read PCI_CONF_FLSH_BAR of %s\n",\r\npci_name(asd_ha->pcidev));\r\nreturn -ENOENT;\r\n}\r\nasd_ha->hw_prof.flash.present = 1;\r\nasd_ha->hw_prof.flash.wide = reg & FLASHW ? 1 : 0;\r\nerr = asd_reset_flash(asd_ha);\r\nif (err) {\r\nASD_DPRINTK("couldn't reset flash(%d)\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 asd_calc_flash_chksum(u16 *p, int size)\r\n{\r\nu16 chksum = 0;\r\nwhile (size-- > 0)\r\nchksum += *p++;\r\nreturn chksum;\r\n}\r\nstatic int asd_find_flash_de(struct asd_flash_dir *flash_dir, u32 entry_type,\r\nu32 *offs, u32 *size)\r\n{\r\nint i;\r\nstruct asd_flash_de *de;\r\nfor (i = 0; i < FLASH_MAX_DIR_ENTRIES; i++) {\r\nu32 type = le32_to_cpu(flash_dir->dir_entry[i].type);\r\ntype &= FLASH_DE_TYPE_MASK;\r\nif (type == entry_type)\r\nbreak;\r\n}\r\nif (i >= FLASH_MAX_DIR_ENTRIES)\r\nreturn -ENOENT;\r\nde = &flash_dir->dir_entry[i];\r\n*offs = le32_to_cpu(de->offs);\r\n*size = le32_to_cpu(de->pad_size);\r\nreturn 0;\r\n}\r\nstatic int asd_validate_ms(struct asd_manuf_sec *ms)\r\n{\r\nif (ms->sig[0] != 'S' || ms->sig[1] != 'M') {\r\nASD_DPRINTK("manuf sec: no valid sig(%c%c)\n",\r\nms->sig[0], ms->sig[1]);\r\nreturn -ENOENT;\r\n}\r\nif (ms->maj != 0) {\r\nasd_printk("unsupported manuf. sector. major version:%x\n",\r\nms->maj);\r\nreturn -ENOENT;\r\n}\r\nms->offs_next = le16_to_cpu((__force __le16) ms->offs_next);\r\nms->chksum = le16_to_cpu((__force __le16) ms->chksum);\r\nms->size = le16_to_cpu((__force __le16) ms->size);\r\nif (asd_calc_flash_chksum((u16 *)ms, ms->size/2)) {\r\nasd_printk("failed manuf sector checksum\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int asd_ms_get_sas_addr(struct asd_ha_struct *asd_ha,\r\nstruct asd_manuf_sec *ms)\r\n{\r\nmemcpy(asd_ha->hw_prof.sas_addr, ms->sas_addr, SAS_ADDR_SIZE);\r\nreturn 0;\r\n}\r\nstatic int asd_ms_get_pcba_sn(struct asd_ha_struct *asd_ha,\r\nstruct asd_manuf_sec *ms)\r\n{\r\nmemcpy(asd_ha->hw_prof.pcba_sn, ms->pcba_sn, ASD_PCBA_SN_SIZE);\r\nasd_ha->hw_prof.pcba_sn[ASD_PCBA_SN_SIZE] = '\0';\r\nreturn 0;\r\n}\r\nstatic void *asd_find_ll_by_id(void * const start, const u8 id0, const u8 id1)\r\n{\r\nstruct asd_ll_el *el = start;\r\ndo {\r\nswitch (id1) {\r\ndefault:\r\nif (el->id1 == id1)\r\ncase 0xFF:\r\nif (el->id0 == id0)\r\nreturn el;\r\n}\r\nel = start + le16_to_cpu(el->next);\r\n} while (el != start);\r\nreturn NULL;\r\n}\r\nstatic int asd_ms_get_phy_params(struct asd_ha_struct *asd_ha,\r\nstruct asd_manuf_sec *manuf_sec)\r\n{\r\nint i;\r\nint en_phys = 0;\r\nint rep_phys = 0;\r\nstruct asd_manuf_phy_param *phy_param;\r\nstruct asd_manuf_phy_param dflt_phy_param;\r\nphy_param = asd_find_ll_by_id(manuf_sec, 'P', 'M');\r\nif (!phy_param) {\r\nASD_DPRINTK("ms: no phy parameters found\n");\r\nASD_DPRINTK("ms: Creating default phy parameters\n");\r\ndflt_phy_param.sig[0] = 'P';\r\ndflt_phy_param.sig[1] = 'M';\r\ndflt_phy_param.maj = 0;\r\ndflt_phy_param.min = 2;\r\ndflt_phy_param.num_phy_desc = 8;\r\ndflt_phy_param.phy_desc_size = sizeof(struct asd_manuf_phy_desc);\r\nfor (i =0; i < ASD_MAX_PHYS; i++) {\r\ndflt_phy_param.phy_desc[i].state = 0;\r\ndflt_phy_param.phy_desc[i].phy_id = i;\r\ndflt_phy_param.phy_desc[i].phy_control_0 = 0xf6;\r\ndflt_phy_param.phy_desc[i].phy_control_1 = 0x10;\r\ndflt_phy_param.phy_desc[i].phy_control_2 = 0x43;\r\ndflt_phy_param.phy_desc[i].phy_control_3 = 0xeb;\r\n}\r\nphy_param = &dflt_phy_param;\r\n}\r\nif (phy_param->maj != 0) {\r\nasd_printk("unsupported manuf. phy param major version:0x%x\n",\r\nphy_param->maj);\r\nreturn -ENOENT;\r\n}\r\nASD_DPRINTK("ms: num_phy_desc: %d\n", phy_param->num_phy_desc);\r\nasd_ha->hw_prof.enabled_phys = 0;\r\nfor (i = 0; i < phy_param->num_phy_desc; i++) {\r\nstruct asd_manuf_phy_desc *pd = &phy_param->phy_desc[i];\r\nswitch (pd->state & 0xF) {\r\ncase MS_PHY_STATE_HIDDEN:\r\nASD_DPRINTK("ms: phy%d: HIDDEN\n", i);\r\ncontinue;\r\ncase MS_PHY_STATE_REPORTED:\r\nASD_DPRINTK("ms: phy%d: REPORTED\n", i);\r\nasd_ha->hw_prof.enabled_phys &= ~(1 << i);\r\nrep_phys++;\r\ncontinue;\r\ncase MS_PHY_STATE_ENABLED:\r\nASD_DPRINTK("ms: phy%d: ENABLED\n", i);\r\nasd_ha->hw_prof.enabled_phys |= (1 << i);\r\nen_phys++;\r\nbreak;\r\n}\r\nasd_ha->hw_prof.phy_desc[i].phy_control_0 = pd->phy_control_0;\r\nasd_ha->hw_prof.phy_desc[i].phy_control_1 = pd->phy_control_1;\r\nasd_ha->hw_prof.phy_desc[i].phy_control_2 = pd->phy_control_2;\r\nasd_ha->hw_prof.phy_desc[i].phy_control_3 = pd->phy_control_3;\r\n}\r\nasd_ha->hw_prof.max_phys = rep_phys + en_phys;\r\nasd_ha->hw_prof.num_phys = en_phys;\r\nASD_DPRINTK("ms: max_phys:0x%x, num_phys:0x%x\n",\r\nasd_ha->hw_prof.max_phys, asd_ha->hw_prof.num_phys);\r\nASD_DPRINTK("ms: enabled_phys:0x%x\n", asd_ha->hw_prof.enabled_phys);\r\nreturn 0;\r\n}\r\nstatic int asd_ms_get_connector_map(struct asd_ha_struct *asd_ha,\r\nstruct asd_manuf_sec *manuf_sec)\r\n{\r\nstruct asd_ms_conn_map *cm;\r\ncm = asd_find_ll_by_id(manuf_sec, 'M', 'C');\r\nif (!cm) {\r\nASD_DPRINTK("ms: no connector map found\n");\r\nreturn 0;\r\n}\r\nif (cm->maj != 0) {\r\nASD_DPRINTK("ms: unsupported: connector map major version 0x%x"\r\n"\n", cm->maj);\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int asd_process_ms(struct asd_ha_struct *asd_ha,\r\nstruct asd_flash_dir *flash_dir)\r\n{\r\nint err;\r\nstruct asd_manuf_sec *manuf_sec;\r\nu32 offs, size;\r\nerr = asd_find_flash_de(flash_dir, FLASH_DE_MS, &offs, &size);\r\nif (err) {\r\nASD_DPRINTK("Couldn't find the manuf. sector\n");\r\ngoto out;\r\n}\r\nif (size == 0)\r\ngoto out;\r\nerr = -ENOMEM;\r\nmanuf_sec = kmalloc(size, GFP_KERNEL);\r\nif (!manuf_sec) {\r\nASD_DPRINTK("no mem for manuf sector\n");\r\ngoto out;\r\n}\r\nerr = asd_read_flash_seg(asd_ha, (void *)manuf_sec, offs, size);\r\nif (err) {\r\nASD_DPRINTK("couldn't read manuf sector at 0x%x, size 0x%x\n",\r\noffs, size);\r\ngoto out2;\r\n}\r\nerr = asd_validate_ms(manuf_sec);\r\nif (err) {\r\nASD_DPRINTK("couldn't validate manuf sector\n");\r\ngoto out2;\r\n}\r\nerr = asd_ms_get_sas_addr(asd_ha, manuf_sec);\r\nif (err) {\r\nASD_DPRINTK("couldn't read the SAS_ADDR\n");\r\ngoto out2;\r\n}\r\nASD_DPRINTK("manuf sect SAS_ADDR %llx\n",\r\nSAS_ADDR(asd_ha->hw_prof.sas_addr));\r\nerr = asd_ms_get_pcba_sn(asd_ha, manuf_sec);\r\nif (err) {\r\nASD_DPRINTK("couldn't read the PCBA SN\n");\r\ngoto out2;\r\n}\r\nASD_DPRINTK("manuf sect PCBA SN %s\n", asd_ha->hw_prof.pcba_sn);\r\nerr = asd_ms_get_phy_params(asd_ha, manuf_sec);\r\nif (err) {\r\nASD_DPRINTK("ms: couldn't get phy parameters\n");\r\ngoto out2;\r\n}\r\nerr = asd_ms_get_connector_map(asd_ha, manuf_sec);\r\nif (err) {\r\nASD_DPRINTK("ms: couldn't get connector map\n");\r\ngoto out2;\r\n}\r\nout2:\r\nkfree(manuf_sec);\r\nout:\r\nreturn err;\r\n}\r\nstatic int asd_process_ctrla_phy_settings(struct asd_ha_struct *asd_ha,\r\nstruct asd_ctrla_phy_settings *ps)\r\n{\r\nint i;\r\nfor (i = 0; i < ps->num_phys; i++) {\r\nstruct asd_ctrla_phy_entry *pe = &ps->phy_ent[i];\r\nif (!PHY_ENABLED(asd_ha, i))\r\ncontinue;\r\nif (*(u64 *)pe->sas_addr == 0) {\r\nasd_ha->hw_prof.enabled_phys &= ~(1 << i);\r\ncontinue;\r\n}\r\nmemcpy(asd_ha->hw_prof.phy_desc[i].sas_addr, pe->sas_addr,\r\nSAS_ADDR_SIZE);\r\nasd_ha->hw_prof.phy_desc[i].max_sas_lrate =\r\n(pe->sas_link_rates & 0xF0) >> 4;\r\nasd_ha->hw_prof.phy_desc[i].min_sas_lrate =\r\n(pe->sas_link_rates & 0x0F);\r\nasd_ha->hw_prof.phy_desc[i].max_sata_lrate =\r\n(pe->sata_link_rates & 0xF0) >> 4;\r\nasd_ha->hw_prof.phy_desc[i].min_sata_lrate =\r\n(pe->sata_link_rates & 0x0F);\r\nasd_ha->hw_prof.phy_desc[i].flags = pe->flags;\r\nASD_DPRINTK("ctrla: phy%d: sas_addr: %llx, sas rate:0x%x-0x%x,"\r\n" sata rate:0x%x-0x%x, flags:0x%x\n",\r\ni,\r\nSAS_ADDR(asd_ha->hw_prof.phy_desc[i].sas_addr),\r\nasd_ha->hw_prof.phy_desc[i].max_sas_lrate,\r\nasd_ha->hw_prof.phy_desc[i].min_sas_lrate,\r\nasd_ha->hw_prof.phy_desc[i].max_sata_lrate,\r\nasd_ha->hw_prof.phy_desc[i].min_sata_lrate,\r\nasd_ha->hw_prof.phy_desc[i].flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int asd_process_ctrl_a_user(struct asd_ha_struct *asd_ha,\r\nstruct asd_flash_dir *flash_dir)\r\n{\r\nint err, i;\r\nu32 offs, size;\r\nstruct asd_ll_el *el;\r\nstruct asd_ctrla_phy_settings *ps;\r\nstruct asd_ctrla_phy_settings dflt_ps;\r\nerr = asd_find_flash_de(flash_dir, FLASH_DE_CTRL_A_USER, &offs, &size);\r\nif (err) {\r\nASD_DPRINTK("couldn't find CTRL-A user settings section\n");\r\nASD_DPRINTK("Creating default CTRL-A user settings section\n");\r\ndflt_ps.id0 = 'h';\r\ndflt_ps.num_phys = 8;\r\nfor (i =0; i < ASD_MAX_PHYS; i++) {\r\nmemcpy(dflt_ps.phy_ent[i].sas_addr,\r\nasd_ha->hw_prof.sas_addr, SAS_ADDR_SIZE);\r\ndflt_ps.phy_ent[i].sas_link_rates = 0x98;\r\ndflt_ps.phy_ent[i].flags = 0x0;\r\ndflt_ps.phy_ent[i].sata_link_rates = 0x0;\r\n}\r\nsize = sizeof(struct asd_ctrla_phy_settings);\r\nps = &dflt_ps;\r\n}\r\nif (size == 0)\r\ngoto out;\r\nerr = -ENOMEM;\r\nel = kmalloc(size, GFP_KERNEL);\r\nif (!el) {\r\nASD_DPRINTK("no mem for ctrla user settings section\n");\r\ngoto out;\r\n}\r\nerr = asd_read_flash_seg(asd_ha, (void *)el, offs, size);\r\nif (err) {\r\nASD_DPRINTK("couldn't read ctrla phy settings section\n");\r\ngoto out2;\r\n}\r\nerr = -ENOENT;\r\nps = asd_find_ll_by_id(el, 'h', 0xFF);\r\nif (!ps) {\r\nASD_DPRINTK("couldn't find ctrla phy settings struct\n");\r\ngoto out2;\r\n}\r\nerr = asd_process_ctrla_phy_settings(asd_ha, ps);\r\nif (err) {\r\nASD_DPRINTK("couldn't process ctrla phy settings\n");\r\ngoto out2;\r\n}\r\nout2:\r\nkfree(el);\r\nout:\r\nreturn err;\r\n}\r\nint asd_read_flash(struct asd_ha_struct *asd_ha)\r\n{\r\nint err;\r\nstruct asd_flash_dir *flash_dir;\r\nerr = asd_flash_getid(asd_ha);\r\nif (err)\r\nreturn err;\r\nflash_dir = kmalloc(sizeof(*flash_dir), GFP_KERNEL);\r\nif (!flash_dir)\r\nreturn -ENOMEM;\r\nerr = -ENOENT;\r\nif (!asd_find_flash_dir(asd_ha, flash_dir)) {\r\nASD_DPRINTK("couldn't find flash directory\n");\r\ngoto out;\r\n}\r\nif (le32_to_cpu(flash_dir->rev) != 2) {\r\nasd_printk("unsupported flash dir version:0x%x\n",\r\nle32_to_cpu(flash_dir->rev));\r\ngoto out;\r\n}\r\nerr = asd_process_ms(asd_ha, flash_dir);\r\nif (err) {\r\nASD_DPRINTK("couldn't process manuf sector settings\n");\r\ngoto out;\r\n}\r\nerr = asd_process_ctrl_a_user(asd_ha, flash_dir);\r\nif (err) {\r\nASD_DPRINTK("couldn't process CTRL-A user settings\n");\r\ngoto out;\r\n}\r\nout:\r\nkfree(flash_dir);\r\nreturn err;\r\n}\r\nint asd_verify_flash_seg(struct asd_ha_struct *asd_ha,\r\nconst void *src, u32 dest_offset, u32 bytes_to_verify)\r\n{\r\nconst u8 *src_buf;\r\nu8 flash_char;\r\nint err;\r\nu32 nv_offset, reg, i;\r\nreg = asd_ha->hw_prof.flash.bar;\r\nsrc_buf = NULL;\r\nerr = FLASH_OK;\r\nnv_offset = dest_offset;\r\nsrc_buf = (const u8 *)src;\r\nfor (i = 0; i < bytes_to_verify; i++) {\r\nflash_char = asd_read_reg_byte(asd_ha, reg + nv_offset + i);\r\nif (flash_char != src_buf[i]) {\r\nerr = FAIL_VERIFY;\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nint asd_write_flash_seg(struct asd_ha_struct *asd_ha,\r\nconst void *src, u32 dest_offset, u32 bytes_to_write)\r\n{\r\nconst u8 *src_buf;\r\nu32 nv_offset, reg, i;\r\nint err;\r\nreg = asd_ha->hw_prof.flash.bar;\r\nsrc_buf = NULL;\r\nerr = asd_check_flash_type(asd_ha);\r\nif (err) {\r\nASD_DPRINTK("couldn't find the type of flash. err=%d\n", err);\r\nreturn err;\r\n}\r\nnv_offset = dest_offset;\r\nerr = asd_erase_nv_sector(asd_ha, nv_offset, bytes_to_write);\r\nif (err) {\r\nASD_DPRINTK("Erase failed at offset:0x%x\n",\r\nnv_offset);\r\nreturn err;\r\n}\r\nerr = asd_reset_flash(asd_ha);\r\nif (err) {\r\nASD_DPRINTK("couldn't reset flash. err=%d\n", err);\r\nreturn err;\r\n}\r\nsrc_buf = (const u8 *)src;\r\nfor (i = 0; i < bytes_to_write; i++) {\r\nswitch (asd_ha->hw_prof.flash.method) {\r\ncase FLASH_METHOD_A:\r\n{\r\nasd_write_reg_byte(asd_ha,\r\n(reg + 0xAAA), 0xAA);\r\nasd_write_reg_byte(asd_ha,\r\n(reg + 0x555), 0x55);\r\nasd_write_reg_byte(asd_ha,\r\n(reg + 0xAAA), 0xA0);\r\nasd_write_reg_byte(asd_ha,\r\n(reg + nv_offset + i),\r\n(*(src_buf + i)));\r\nbreak;\r\n}\r\ncase FLASH_METHOD_B:\r\n{\r\nasd_write_reg_byte(asd_ha,\r\n(reg + 0x555), 0xAA);\r\nasd_write_reg_byte(asd_ha,\r\n(reg + 0x2AA), 0x55);\r\nasd_write_reg_byte(asd_ha,\r\n(reg + 0x555), 0xA0);\r\nasd_write_reg_byte(asd_ha,\r\n(reg + nv_offset + i),\r\n(*(src_buf + i)));\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nif (asd_chk_write_status(asd_ha,\r\n(nv_offset + i), 0) != 0) {\r\nASD_DPRINTK("aicx: Write failed at offset:0x%x\n",\r\nreg + nv_offset + i);\r\nreturn FAIL_WRITE_FLASH;\r\n}\r\n}\r\nerr = asd_reset_flash(asd_ha);\r\nif (err) {\r\nASD_DPRINTK("couldn't reset flash. err=%d\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint asd_chk_write_status(struct asd_ha_struct *asd_ha,\r\nu32 sector_addr, u8 erase_flag)\r\n{\r\nu32 reg;\r\nu32 loop_cnt;\r\nu8 nv_data1, nv_data2;\r\nu8 toggle_bit1;\r\nreg = asd_ha->hw_prof.flash.bar;\r\nfor (loop_cnt = 0; loop_cnt < 50000; loop_cnt++) {\r\nnv_data1 = asd_read_reg_byte(asd_ha, reg);\r\nnv_data2 = asd_read_reg_byte(asd_ha, reg);\r\ntoggle_bit1 = ((nv_data1 & FLASH_STATUS_BIT_MASK_DQ6)\r\n^ (nv_data2 & FLASH_STATUS_BIT_MASK_DQ6));\r\nif (toggle_bit1 == 0) {\r\nreturn 0;\r\n} else {\r\nif (nv_data2 & FLASH_STATUS_BIT_MASK_DQ5) {\r\nnv_data1 = asd_read_reg_byte(asd_ha,\r\nreg);\r\nnv_data2 = asd_read_reg_byte(asd_ha,\r\nreg);\r\ntoggle_bit1 =\r\n((nv_data1 & FLASH_STATUS_BIT_MASK_DQ6)\r\n^ (nv_data2 & FLASH_STATUS_BIT_MASK_DQ6));\r\nif (toggle_bit1 == 0)\r\nreturn 0;\r\n}\r\n}\r\nif (erase_flag) {\r\nudelay(FLASH_STATUS_ERASE_DELAY_COUNT);\r\n} else {\r\nudelay(FLASH_STATUS_WRITE_DELAY_COUNT);\r\n}\r\n}\r\nreturn -1;\r\n}\r\nint asd_erase_nv_sector(struct asd_ha_struct *asd_ha, u32 flash_addr, u32 size)\r\n{\r\nu32 reg;\r\nu32 sector_addr;\r\nreg = asd_ha->hw_prof.flash.bar;\r\nsector_addr = flash_addr & FLASH_SECTOR_SIZE_MASK;\r\nwhile (sector_addr < flash_addr+size) {\r\nswitch (asd_ha->hw_prof.flash.method) {\r\ncase FLASH_METHOD_A:\r\nasd_write_reg_byte(asd_ha, (reg + 0xAAA), 0xAA);\r\nasd_write_reg_byte(asd_ha, (reg + 0x555), 0x55);\r\nasd_write_reg_byte(asd_ha, (reg + 0xAAA), 0x80);\r\nasd_write_reg_byte(asd_ha, (reg + 0xAAA), 0xAA);\r\nasd_write_reg_byte(asd_ha, (reg + 0x555), 0x55);\r\nasd_write_reg_byte(asd_ha, (reg + sector_addr), 0x30);\r\nbreak;\r\ncase FLASH_METHOD_B:\r\nasd_write_reg_byte(asd_ha, (reg + 0x555), 0xAA);\r\nasd_write_reg_byte(asd_ha, (reg + 0x2AA), 0x55);\r\nasd_write_reg_byte(asd_ha, (reg + 0x555), 0x80);\r\nasd_write_reg_byte(asd_ha, (reg + 0x555), 0xAA);\r\nasd_write_reg_byte(asd_ha, (reg + 0x2AA), 0x55);\r\nasd_write_reg_byte(asd_ha, (reg + sector_addr), 0x30);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (asd_chk_write_status(asd_ha, sector_addr, 1) != 0)\r\nreturn FAIL_ERASE_FLASH;\r\nsector_addr += FLASH_SECTOR_SIZE;\r\n}\r\nreturn 0;\r\n}\r\nint asd_check_flash_type(struct asd_ha_struct *asd_ha)\r\n{\r\nu8 manuf_id;\r\nu8 dev_id;\r\nu8 sec_prot;\r\nu32 inc;\r\nu32 reg;\r\nint err;\r\nreg = asd_ha->hw_prof.flash.bar;\r\nerr = asd_reset_flash(asd_ha);\r\nif (err) {\r\nASD_DPRINTK("couldn't reset flash. err=%d\n", err);\r\nreturn err;\r\n}\r\nasd_ha->hw_prof.flash.method = FLASH_METHOD_UNKNOWN;\r\nasd_ha->hw_prof.flash.manuf = FLASH_MANUF_ID_UNKNOWN;\r\nasd_ha->hw_prof.flash.dev_id = FLASH_DEV_ID_UNKNOWN;\r\ninc = asd_ha->hw_prof.flash.wide ? 2 : 1;\r\nasd_write_reg_byte(asd_ha, reg + 0xAAA, 0xAA);\r\nasd_write_reg_byte(asd_ha, reg + 0x555, 0x55);\r\nasd_write_reg_byte(asd_ha, reg + 0xAAA, 0x90);\r\nmanuf_id = asd_read_reg_byte(asd_ha, reg);\r\ndev_id = asd_read_reg_byte(asd_ha, reg + inc);\r\nsec_prot = asd_read_reg_byte(asd_ha, reg + inc + inc);\r\nerr = asd_reset_flash(asd_ha);\r\nif (err) {\r\nASD_DPRINTK("couldn't reset flash. err=%d\n", err);\r\nreturn err;\r\n}\r\nASD_DPRINTK("Flash MethodA manuf_id(0x%x) dev_id(0x%x) "\r\n"sec_prot(0x%x)\n", manuf_id, dev_id, sec_prot);\r\nerr = asd_reset_flash(asd_ha);\r\nif (err != 0)\r\nreturn err;\r\nswitch (manuf_id) {\r\ncase FLASH_MANUF_ID_AMD:\r\nswitch (sec_prot) {\r\ncase FLASH_DEV_ID_AM29LV800DT:\r\ncase FLASH_DEV_ID_AM29LV640MT:\r\ncase FLASH_DEV_ID_AM29F800B:\r\nasd_ha->hw_prof.flash.method = FLASH_METHOD_A;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase FLASH_MANUF_ID_ST:\r\nswitch (sec_prot) {\r\ncase FLASH_DEV_ID_STM29W800DT:\r\ncase FLASH_DEV_ID_STM29LV640:\r\nasd_ha->hw_prof.flash.method = FLASH_METHOD_A;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase FLASH_MANUF_ID_FUJITSU:\r\nswitch (sec_prot) {\r\ncase FLASH_DEV_ID_MBM29LV800TE:\r\ncase FLASH_DEV_ID_MBM29DL800TA:\r\nasd_ha->hw_prof.flash.method = FLASH_METHOD_A;\r\nbreak;\r\n}\r\nbreak;\r\ncase FLASH_MANUF_ID_MACRONIX:\r\nswitch (sec_prot) {\r\ncase FLASH_DEV_ID_MX29LV800BT:\r\nasd_ha->hw_prof.flash.method = FLASH_METHOD_A;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nif (asd_ha->hw_prof.flash.method == FLASH_METHOD_UNKNOWN) {\r\nerr = asd_reset_flash(asd_ha);\r\nif (err) {\r\nASD_DPRINTK("couldn't reset flash. err=%d\n", err);\r\nreturn err;\r\n}\r\nasd_write_reg_byte(asd_ha, (reg + 0x555), 0xAA);\r\nasd_write_reg_byte(asd_ha, (reg + 0x2AA), 0x55);\r\nasd_write_reg_byte(asd_ha, (reg + 0x555), 0x90);\r\nmanuf_id = asd_read_reg_byte(asd_ha, reg);\r\ndev_id = asd_read_reg_byte(asd_ha, reg + inc);\r\nsec_prot = asd_read_reg_byte(asd_ha, reg + inc + inc);\r\nASD_DPRINTK("Flash MethodB manuf_id(0x%x) dev_id(0x%x) sec_prot"\r\n"(0x%x)\n", manuf_id, dev_id, sec_prot);\r\nerr = asd_reset_flash(asd_ha);\r\nif (err != 0) {\r\nASD_DPRINTK("couldn't reset flash. err=%d\n", err);\r\nreturn err;\r\n}\r\nswitch (manuf_id) {\r\ncase FLASH_MANUF_ID_AMD:\r\nswitch (dev_id) {\r\ncase FLASH_DEV_ID_AM29LV008BT:\r\nasd_ha->hw_prof.flash.method = FLASH_METHOD_B;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase FLASH_MANUF_ID_ST:\r\nswitch (dev_id) {\r\ncase FLASH_DEV_ID_STM29008:\r\nasd_ha->hw_prof.flash.method = FLASH_METHOD_B;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase FLASH_MANUF_ID_FUJITSU:\r\nswitch (dev_id) {\r\ncase FLASH_DEV_ID_MBM29LV008TA:\r\nasd_ha->hw_prof.flash.method = FLASH_METHOD_B;\r\nbreak;\r\n}\r\nbreak;\r\ncase FLASH_MANUF_ID_INTEL:\r\nswitch (dev_id) {\r\ncase FLASH_DEV_ID_I28LV00TAT:\r\nasd_ha->hw_prof.flash.method = FLASH_METHOD_B;\r\nbreak;\r\n}\r\nbreak;\r\ncase FLASH_MANUF_ID_MACRONIX:\r\nswitch (dev_id) {\r\ncase FLASH_DEV_ID_I28LV00TAT:\r\nasd_ha->hw_prof.flash.method = FLASH_METHOD_B;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nreturn FAIL_FIND_FLASH_ID;\r\n}\r\n}\r\nif (asd_ha->hw_prof.flash.method == FLASH_METHOD_UNKNOWN)\r\nreturn FAIL_FIND_FLASH_ID;\r\nasd_ha->hw_prof.flash.manuf = manuf_id;\r\nasd_ha->hw_prof.flash.dev_id = dev_id;\r\nasd_ha->hw_prof.flash.sec_prot = sec_prot;\r\nreturn 0;\r\n}
