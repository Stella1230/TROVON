static int vpif_buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vpif_fh *fh = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nstruct common_obj *common;\r\nunsigned long addr;\r\ncommon = &fh->channel->common[VPIF_VIDEO_INDEX];\r\nif (vb->state != VB2_BUF_STATE_ACTIVE &&\r\nvb->state != VB2_BUF_STATE_PREPARED) {\r\nvb2_set_plane_payload(vb, 0, common->fmt.fmt.pix.sizeimage);\r\nif (vb2_plane_vaddr(vb, 0) &&\r\nvb2_get_plane_payload(vb, 0) > vb2_plane_size(vb, 0))\r\ngoto buf_align_exit;\r\naddr = vb2_dma_contig_plane_dma_addr(vb, 0);\r\nif (q->streaming &&\r\n(V4L2_BUF_TYPE_SLICED_VBI_OUTPUT != q->type)) {\r\nif (!ISALIGNED(addr + common->ytop_off) ||\r\n!ISALIGNED(addr + common->ybtm_off) ||\r\n!ISALIGNED(addr + common->ctop_off) ||\r\n!ISALIGNED(addr + common->cbtm_off))\r\ngoto buf_align_exit;\r\n}\r\n}\r\nreturn 0;\r\nbuf_align_exit:\r\nvpif_err("buffer offset not aligned to 8 bytes\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int vpif_buffer_queue_setup(struct vb2_queue *vq,\r\nconst struct v4l2_format *fmt,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct vpif_fh *fh = vb2_get_drv_priv(vq);\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nunsigned long size;\r\nif (V4L2_MEMORY_MMAP == common->memory) {\r\nsize = config_params.channel_bufsize[ch->channel_id];\r\nif (ch->vpifparams.std_info.ycmux_mode == 0) {\r\nif (config_params.video_limit[ch->channel_id])\r\nwhile (size * *nbuffers >\r\n(config_params.video_limit[0]\r\n+ config_params.video_limit[1]))\r\n(*nbuffers)--;\r\n} else {\r\nif (config_params.video_limit[ch->channel_id])\r\nwhile (size * *nbuffers >\r\nconfig_params.video_limit[ch->channel_id])\r\n(*nbuffers)--;\r\n}\r\n} else {\r\nsize = common->fmt.fmt.pix.sizeimage;\r\n}\r\nif (*nbuffers < config_params.min_numbuffers)\r\n*nbuffers = config_params.min_numbuffers;\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nalloc_ctxs[0] = common->alloc_ctx;\r\nreturn 0;\r\n}\r\nstatic void vpif_buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vpif_fh *fh = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vpif_disp_buffer *buf = container_of(vb,\r\nstruct vpif_disp_buffer, vb);\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common;\r\nunsigned long flags;\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nspin_lock_irqsave(&common->irqlock, flags);\r\nlist_add_tail(&buf->list, &common->dma_queue);\r\nspin_unlock_irqrestore(&common->irqlock, flags);\r\n}\r\nstatic void vpif_buf_cleanup(struct vb2_buffer *vb)\r\n{\r\nstruct vpif_fh *fh = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct vpif_disp_buffer *buf = container_of(vb,\r\nstruct vpif_disp_buffer, vb);\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common;\r\nunsigned long flags;\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nspin_lock_irqsave(&common->irqlock, flags);\r\nif (vb->state == VB2_BUF_STATE_ACTIVE)\r\nlist_del_init(&buf->list);\r\nspin_unlock_irqrestore(&common->irqlock, flags);\r\n}\r\nstatic void vpif_wait_prepare(struct vb2_queue *vq)\r\n{\r\nstruct vpif_fh *fh = vb2_get_drv_priv(vq);\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common;\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nmutex_unlock(&common->lock);\r\n}\r\nstatic void vpif_wait_finish(struct vb2_queue *vq)\r\n{\r\nstruct vpif_fh *fh = vb2_get_drv_priv(vq);\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common;\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nmutex_lock(&common->lock);\r\n}\r\nstatic int vpif_buffer_init(struct vb2_buffer *vb)\r\n{\r\nstruct vpif_disp_buffer *buf = container_of(vb,\r\nstruct vpif_disp_buffer, vb);\r\nINIT_LIST_HEAD(&buf->list);\r\nreturn 0;\r\n}\r\nstatic int vpif_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct vpif_display_config *vpif_config_data =\r\nvpif_dev->platform_data;\r\nstruct vpif_fh *fh = vb2_get_drv_priv(vq);\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct vpif_params *vpif = &ch->vpifparams;\r\nunsigned long addr = 0;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&common->irqlock, flags);\r\nif (list_empty(&common->dma_queue)) {\r\nspin_unlock_irqrestore(&common->irqlock, flags);\r\nvpif_err("buffer queue is empty\n");\r\nreturn -EIO;\r\n}\r\ncommon->next_frm = common->cur_frm =\r\nlist_entry(common->dma_queue.next,\r\nstruct vpif_disp_buffer, list);\r\nlist_del(&common->cur_frm->list);\r\nspin_unlock_irqrestore(&common->irqlock, flags);\r\ncommon->cur_frm->vb.state = VB2_BUF_STATE_ACTIVE;\r\nch->field_id = 0;\r\ncommon->started = 1;\r\naddr = vb2_dma_contig_plane_dma_addr(&common->cur_frm->vb, 0);\r\nvpif_calculate_offsets(ch);\r\nif ((ch->vpifparams.std_info.frm_fmt &&\r\n((common->fmt.fmt.pix.field != V4L2_FIELD_NONE)\r\n&& (common->fmt.fmt.pix.field != V4L2_FIELD_ANY)))\r\n|| (!ch->vpifparams.std_info.frm_fmt\r\n&& (common->fmt.fmt.pix.field == V4L2_FIELD_NONE))) {\r\nvpif_err("conflict in field format and std format\n");\r\nreturn -EINVAL;\r\n}\r\nif (vpif_config_data->set_clock) {\r\nret = vpif_config_data->set_clock(ch->vpifparams.std_info.\r\nycmux_mode, ch->vpifparams.std_info.hd_sd);\r\nif (ret < 0) {\r\nvpif_err("can't set clock\n");\r\nreturn ret;\r\n}\r\n}\r\nret = vpif_set_video_params(vpif, ch->channel_id + 2);\r\nif (ret < 0)\r\nreturn ret;\r\ncommon->started = ret;\r\nvpif_config_addr(ch, ret);\r\ncommon->set_addr((addr + common->ytop_off),\r\n(addr + common->ybtm_off),\r\n(addr + common->ctop_off),\r\n(addr + common->cbtm_off));\r\nchannel_first_int[VPIF_VIDEO_INDEX][ch->channel_id] = 1;\r\nif (VPIF_CHANNEL2_VIDEO == ch->channel_id) {\r\nchannel2_intr_assert();\r\nchannel2_intr_enable(1);\r\nenable_channel2(1);\r\nif (vpif_config_data->chan_config[VPIF_CHANNEL2_VIDEO].clip_en)\r\nchannel2_clipping_enable(1);\r\n}\r\nif ((VPIF_CHANNEL3_VIDEO == ch->channel_id)\r\n|| (common->started == 2)) {\r\nchannel3_intr_assert();\r\nchannel3_intr_enable(1);\r\nenable_channel3(1);\r\nif (vpif_config_data->chan_config[VPIF_CHANNEL3_VIDEO].clip_en)\r\nchannel3_clipping_enable(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpif_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct vpif_fh *fh = vb2_get_drv_priv(vq);\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common;\r\nunsigned long flags;\r\nif (!vb2_is_streaming(vq))\r\nreturn 0;\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nspin_lock_irqsave(&common->irqlock, flags);\r\nwhile (!list_empty(&common->dma_queue)) {\r\ncommon->next_frm = list_entry(common->dma_queue.next,\r\nstruct vpif_disp_buffer, list);\r\nlist_del(&common->next_frm->list);\r\nvb2_buffer_done(&common->next_frm->vb, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&common->irqlock, flags);\r\nreturn 0;\r\n}\r\nstatic void process_progressive_mode(struct common_obj *common)\r\n{\r\nunsigned long addr = 0;\r\nspin_lock(&common->irqlock);\r\ncommon->next_frm = list_entry(common->dma_queue.next,\r\nstruct vpif_disp_buffer, list);\r\nlist_del(&common->next_frm->list);\r\nspin_unlock(&common->irqlock);\r\ncommon->next_frm->vb.state = VB2_BUF_STATE_ACTIVE;\r\naddr = vb2_dma_contig_plane_dma_addr(&common->next_frm->vb, 0);\r\ncommon->set_addr(addr + common->ytop_off,\r\naddr + common->ybtm_off,\r\naddr + common->ctop_off,\r\naddr + common->cbtm_off);\r\n}\r\nstatic void process_interlaced_mode(int fid, struct common_obj *common)\r\n{\r\nif (0 == fid) {\r\nif (common->cur_frm == common->next_frm)\r\nreturn;\r\nv4l2_get_timestamp(&common->cur_frm->vb.v4l2_buf.timestamp);\r\nvb2_buffer_done(&common->cur_frm->vb,\r\nVB2_BUF_STATE_DONE);\r\ncommon->cur_frm = common->next_frm;\r\n} else if (1 == fid) {\r\nspin_lock(&common->irqlock);\r\nif (list_empty(&common->dma_queue)\r\n|| (common->cur_frm != common->next_frm)) {\r\nspin_unlock(&common->irqlock);\r\nreturn;\r\n}\r\nspin_unlock(&common->irqlock);\r\nprocess_progressive_mode(common);\r\n}\r\n}\r\nstatic irqreturn_t vpif_channel_isr(int irq, void *dev_id)\r\n{\r\nstruct vpif_device *dev = &vpif_obj;\r\nstruct channel_obj *ch;\r\nstruct common_obj *common;\r\nenum v4l2_field field;\r\nint fid = -1, i;\r\nint channel_id = 0;\r\nchannel_id = *(int *)(dev_id);\r\nif (!vpif_intr_status(channel_id + 2))\r\nreturn IRQ_NONE;\r\nch = dev->dev[channel_id];\r\nfield = ch->common[VPIF_VIDEO_INDEX].fmt.fmt.pix.field;\r\nfor (i = 0; i < VPIF_NUMOBJECTS; i++) {\r\ncommon = &ch->common[i];\r\nif (0 == common->started)\r\ncontinue;\r\nif (1 == ch->vpifparams.std_info.frm_fmt) {\r\nspin_lock(&common->irqlock);\r\nif (list_empty(&common->dma_queue)) {\r\nspin_unlock(&common->irqlock);\r\ncontinue;\r\n}\r\nspin_unlock(&common->irqlock);\r\nif (!channel_first_int[i][channel_id]) {\r\nv4l2_get_timestamp(&common->cur_frm->vb.\r\nv4l2_buf.timestamp);\r\nvb2_buffer_done(&common->cur_frm->vb,\r\nVB2_BUF_STATE_DONE);\r\ncommon->cur_frm = common->next_frm;\r\n}\r\nchannel_first_int[i][channel_id] = 0;\r\nprocess_progressive_mode(common);\r\n} else {\r\nif (channel_first_int[i][channel_id]) {\r\nchannel_first_int[i][channel_id] = 0;\r\ncontinue;\r\n}\r\nif (0 == i) {\r\nch->field_id ^= 1;\r\nfid = vpif_channel_getfid(ch->channel_id + 2);\r\nif (fid != ch->field_id) {\r\nif (0 == fid)\r\nch->field_id = fid;\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nprocess_interlaced_mode(fid, common);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vpif_update_std_info(struct channel_obj *ch)\r\n{\r\nstruct video_obj *vid_ch = &ch->video;\r\nstruct vpif_params *vpifparams = &ch->vpifparams;\r\nstruct vpif_channel_config_params *std_info = &vpifparams->std_info;\r\nconst struct vpif_channel_config_params *config;\r\nint i;\r\nfor (i = 0; i < vpif_ch_params_count; i++) {\r\nconfig = &vpif_ch_params[i];\r\nif (config->hd_sd == 0) {\r\nvpif_dbg(2, debug, "SD format\n");\r\nif (config->stdid & vid_ch->stdid) {\r\nmemcpy(std_info, config, sizeof(*config));\r\nbreak;\r\n}\r\n}\r\n}\r\nif (i == vpif_ch_params_count) {\r\nvpif_dbg(1, debug, "Format not found\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpif_update_resolution(struct channel_obj *ch)\r\n{\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct video_obj *vid_ch = &ch->video;\r\nstruct vpif_params *vpifparams = &ch->vpifparams;\r\nstruct vpif_channel_config_params *std_info = &vpifparams->std_info;\r\nif (!vid_ch->stdid && !vid_ch->dv_timings.bt.height)\r\nreturn -EINVAL;\r\nif (vid_ch->stdid) {\r\nif (vpif_update_std_info(ch))\r\nreturn -EINVAL;\r\n}\r\ncommon->fmt.fmt.pix.width = std_info->width;\r\ncommon->fmt.fmt.pix.height = std_info->height;\r\nvpif_dbg(1, debug, "Pixel details: Width = %d,Height = %d\n",\r\ncommon->fmt.fmt.pix.width, common->fmt.fmt.pix.height);\r\ncommon->height = std_info->height;\r\ncommon->width = std_info->width;\r\nreturn 0;\r\n}\r\nstatic void vpif_calculate_offsets(struct channel_obj *ch)\r\n{\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct vpif_params *vpifparams = &ch->vpifparams;\r\nenum v4l2_field field = common->fmt.fmt.pix.field;\r\nstruct video_obj *vid_ch = &ch->video;\r\nunsigned int hpitch, vpitch, sizeimage;\r\nif (V4L2_FIELD_ANY == common->fmt.fmt.pix.field) {\r\nif (ch->vpifparams.std_info.frm_fmt)\r\nvid_ch->buf_field = V4L2_FIELD_NONE;\r\nelse\r\nvid_ch->buf_field = V4L2_FIELD_INTERLACED;\r\n} else {\r\nvid_ch->buf_field = common->fmt.fmt.pix.field;\r\n}\r\nsizeimage = common->fmt.fmt.pix.sizeimage;\r\nhpitch = common->fmt.fmt.pix.bytesperline;\r\nvpitch = sizeimage / (hpitch * 2);\r\nif ((V4L2_FIELD_NONE == vid_ch->buf_field) ||\r\n(V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {\r\ncommon->ytop_off = 0;\r\ncommon->ybtm_off = hpitch;\r\ncommon->ctop_off = sizeimage / 2;\r\ncommon->cbtm_off = sizeimage / 2 + hpitch;\r\n} else if (V4L2_FIELD_SEQ_TB == vid_ch->buf_field) {\r\ncommon->ytop_off = 0;\r\ncommon->ybtm_off = sizeimage / 4;\r\ncommon->ctop_off = sizeimage / 2;\r\ncommon->cbtm_off = common->ctop_off + sizeimage / 4;\r\n} else if (V4L2_FIELD_SEQ_BT == vid_ch->buf_field) {\r\ncommon->ybtm_off = 0;\r\ncommon->ytop_off = sizeimage / 4;\r\ncommon->cbtm_off = sizeimage / 2;\r\ncommon->ctop_off = common->cbtm_off + sizeimage / 4;\r\n}\r\nif ((V4L2_FIELD_NONE == vid_ch->buf_field) ||\r\n(V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {\r\nvpifparams->video_params.storage_mode = 1;\r\n} else {\r\nvpifparams->video_params.storage_mode = 0;\r\n}\r\nif (ch->vpifparams.std_info.frm_fmt == 1) {\r\nvpifparams->video_params.hpitch =\r\ncommon->fmt.fmt.pix.bytesperline;\r\n} else {\r\nif ((field == V4L2_FIELD_ANY) ||\r\n(field == V4L2_FIELD_INTERLACED))\r\nvpifparams->video_params.hpitch =\r\ncommon->fmt.fmt.pix.bytesperline * 2;\r\nelse\r\nvpifparams->video_params.hpitch =\r\ncommon->fmt.fmt.pix.bytesperline;\r\n}\r\nch->vpifparams.video_params.stdid = ch->vpifparams.std_info.stdid;\r\n}\r\nstatic void vpif_config_format(struct channel_obj *ch)\r\n{\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\ncommon->fmt.fmt.pix.field = V4L2_FIELD_ANY;\r\nif (config_params.numbuffers[ch->channel_id] == 0)\r\ncommon->memory = V4L2_MEMORY_USERPTR;\r\nelse\r\ncommon->memory = V4L2_MEMORY_MMAP;\r\ncommon->fmt.fmt.pix.sizeimage =\r\nconfig_params.channel_bufsize[ch->channel_id];\r\ncommon->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV422P;\r\ncommon->fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\n}\r\nstatic int vpif_check_format(struct channel_obj *ch,\r\nstruct v4l2_pix_format *pixfmt)\r\n{\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nenum v4l2_field field = pixfmt->field;\r\nu32 sizeimage, hpitch, vpitch;\r\nif (pixfmt->pixelformat != V4L2_PIX_FMT_YUV422P)\r\ngoto invalid_fmt_exit;\r\nif (!(VPIF_VALID_FIELD(field)))\r\ngoto invalid_fmt_exit;\r\nif (pixfmt->bytesperline <= 0)\r\ngoto invalid_pitch_exit;\r\nsizeimage = pixfmt->sizeimage;\r\nif (vpif_update_resolution(ch))\r\nreturn -EINVAL;\r\nhpitch = pixfmt->bytesperline;\r\nvpitch = sizeimage / (hpitch * 2);\r\nif ((hpitch < ch->vpifparams.std_info.width) ||\r\n(vpitch < ch->vpifparams.std_info.height))\r\ngoto invalid_pitch_exit;\r\nif (!ISALIGNED(hpitch)) {\r\nvpif_err("invalid pitch alignment\n");\r\nreturn -EINVAL;\r\n}\r\npixfmt->width = common->fmt.fmt.pix.width;\r\npixfmt->height = common->fmt.fmt.pix.height;\r\nreturn 0;\r\ninvalid_fmt_exit:\r\nvpif_err("invalid field format\n");\r\nreturn -EINVAL;\r\ninvalid_pitch_exit:\r\nvpif_err("invalid pitch\n");\r\nreturn -EINVAL;\r\n}\r\nstatic void vpif_config_addr(struct channel_obj *ch, int muxmode)\r\n{\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (VPIF_CHANNEL3_VIDEO == ch->channel_id) {\r\ncommon->set_addr = ch3_set_videobuf_addr;\r\n} else {\r\nif (2 == muxmode)\r\ncommon->set_addr = ch2_set_videobuf_addr_yc_nmux;\r\nelse\r\ncommon->set_addr = ch2_set_videobuf_addr;\r\n}\r\n}\r\nstatic int vpif_mmap(struct file *filep, struct vm_area_struct *vma)\r\n{\r\nstruct vpif_fh *fh = filep->private_data;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &(ch->common[VPIF_VIDEO_INDEX]);\r\nint ret;\r\nvpif_dbg(2, debug, "vpif_mmap\n");\r\nif (mutex_lock_interruptible(&common->lock))\r\nreturn -ERESTARTSYS;\r\nret = vb2_mmap(&common->buffer_queue, vma);\r\nmutex_unlock(&common->lock);\r\nreturn ret;\r\n}\r\nstatic unsigned int vpif_poll(struct file *filep, poll_table *wait)\r\n{\r\nstruct vpif_fh *fh = filep->private_data;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nunsigned int res = 0;\r\nif (common->started) {\r\nmutex_lock(&common->lock);\r\nres = vb2_poll(&common->buffer_queue, filep, wait);\r\nmutex_unlock(&common->lock);\r\n}\r\nreturn res;\r\n}\r\nstatic int vpif_open(struct file *filep)\r\n{\r\nstruct video_device *vdev = video_devdata(filep);\r\nstruct channel_obj *ch = video_get_drvdata(vdev);\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct vpif_fh *fh;\r\nfh = kzalloc(sizeof(struct vpif_fh), GFP_KERNEL);\r\nif (fh == NULL) {\r\nvpif_err("unable to allocate memory for file handle object\n");\r\nreturn -ENOMEM;\r\n}\r\nif (mutex_lock_interruptible(&common->lock)) {\r\nkfree(fh);\r\nreturn -ERESTARTSYS;\r\n}\r\nfilep->private_data = fh;\r\nfh->channel = ch;\r\nfh->initialized = 0;\r\nif (!ch->initialized) {\r\nfh->initialized = 1;\r\nch->initialized = 1;\r\nmemset(&ch->vpifparams, 0, sizeof(ch->vpifparams));\r\n}\r\natomic_inc(&ch->usrs);\r\nfh->io_allowed[VPIF_VIDEO_INDEX] = 0;\r\nfh->prio = V4L2_PRIORITY_UNSET;\r\nv4l2_prio_open(&ch->prio, &fh->prio);\r\nmutex_unlock(&common->lock);\r\nreturn 0;\r\n}\r\nstatic int vpif_release(struct file *filep)\r\n{\r\nstruct vpif_fh *fh = filep->private_data;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nmutex_lock(&common->lock);\r\nif (fh->io_allowed[VPIF_VIDEO_INDEX]) {\r\ncommon->io_usrs = 0;\r\nif (VPIF_CHANNEL2_VIDEO == ch->channel_id) {\r\nenable_channel2(0);\r\nchannel2_intr_enable(0);\r\n}\r\nif ((VPIF_CHANNEL3_VIDEO == ch->channel_id) ||\r\n(2 == common->started)) {\r\nenable_channel3(0);\r\nchannel3_intr_enable(0);\r\n}\r\ncommon->started = 0;\r\nvb2_queue_release(&common->buffer_queue);\r\nvb2_dma_contig_cleanup_ctx(common->alloc_ctx);\r\ncommon->numbuffers =\r\nconfig_params.numbuffers[ch->channel_id];\r\n}\r\natomic_dec(&ch->usrs);\r\nif (fh->initialized)\r\nch->initialized = 0;\r\nv4l2_prio_close(&ch->prio, fh->prio);\r\nfilep->private_data = NULL;\r\nfh->initialized = 0;\r\nmutex_unlock(&common->lock);\r\nkfree(fh);\r\nreturn 0;\r\n}\r\nstatic int vpif_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct vpif_display_config *config = vpif_dev->platform_data;\r\ncap->device_caps = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nsnprintf(cap->driver, sizeof(cap->driver), "%s", dev_name(vpif_dev));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",\r\ndev_name(vpif_dev));\r\nstrlcpy(cap->card, config->card_name, sizeof(cap->card));\r\nreturn 0;\r\n}\r\nstatic int vpif_enum_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *fmt)\r\n{\r\nif (fmt->index != 0) {\r\nvpif_err("Invalid format index\n");\r\nreturn -EINVAL;\r\n}\r\nfmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nstrcpy(fmt->description, "YCbCr4:2:2 YC Planar");\r\nfmt->pixelformat = V4L2_PIX_FMT_YUV422P;\r\nreturn 0;\r\n}\r\nstatic int vpif_g_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (common->fmt.type != fmt->type)\r\nreturn -EINVAL;\r\nif (vpif_update_resolution(ch))\r\nreturn -EINVAL;\r\n*fmt = common->fmt;\r\nreturn 0;\r\n}\r\nstatic int vpif_s_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct v4l2_pix_format *pixfmt;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nint ret = 0;\r\nif ((VPIF_CHANNEL2_VIDEO == ch->channel_id)\r\n|| (VPIF_CHANNEL3_VIDEO == ch->channel_id)) {\r\nif (!fh->initialized) {\r\nvpif_dbg(1, debug, "Channel Busy\n");\r\nreturn -EBUSY;\r\n}\r\nret = v4l2_prio_check(&ch->prio, fh->prio);\r\nif (0 != ret)\r\nreturn ret;\r\nfh->initialized = 1;\r\n}\r\nif (common->started) {\r\nvpif_dbg(1, debug, "Streaming in progress\n");\r\nreturn -EBUSY;\r\n}\r\npixfmt = &fmt->fmt.pix;\r\nret = vpif_check_format(ch, pixfmt);\r\nif (ret)\r\nreturn ret;\r\ncommon->fmt.fmt.pix = *pixfmt;\r\ncommon->fmt = *fmt;\r\nreturn 0;\r\n}\r\nstatic int vpif_try_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct v4l2_pix_format *pixfmt = &fmt->fmt.pix;\r\nint ret = 0;\r\nret = vpif_check_format(ch, pixfmt);\r\nif (ret) {\r\n*pixfmt = common->fmt.fmt.pix;\r\npixfmt->sizeimage = pixfmt->width * pixfmt->height * 2;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vpif_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *reqbuf)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common;\r\nenum v4l2_field field;\r\nstruct vb2_queue *q;\r\nu8 index = 0;\r\nint ret;\r\nif ((VPIF_CHANNEL2_VIDEO == ch->channel_id)\r\n|| (VPIF_CHANNEL3_VIDEO == ch->channel_id)) {\r\nif (!fh->initialized) {\r\nvpif_err("Channel Busy\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (V4L2_BUF_TYPE_VIDEO_OUTPUT != reqbuf->type)\r\nreturn -EINVAL;\r\nindex = VPIF_VIDEO_INDEX;\r\ncommon = &ch->common[index];\r\nif (common->fmt.type != reqbuf->type || !vpif_dev)\r\nreturn -EINVAL;\r\nif (0 != common->io_usrs)\r\nreturn -EBUSY;\r\nif (reqbuf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nif (common->fmt.fmt.pix.field == V4L2_FIELD_ANY)\r\nfield = V4L2_FIELD_INTERLACED;\r\nelse\r\nfield = common->fmt.fmt.pix.field;\r\n} else {\r\nfield = V4L2_VBI_INTERLACED;\r\n}\r\ncommon->alloc_ctx = vb2_dma_contig_init_ctx(vpif_dev);\r\nif (IS_ERR(common->alloc_ctx)) {\r\nvpif_err("Failed to get the context\n");\r\nreturn PTR_ERR(common->alloc_ctx);\r\n}\r\nq = &common->buffer_queue;\r\nq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nq->io_modes = VB2_MMAP | VB2_USERPTR;\r\nq->drv_priv = fh;\r\nq->ops = &video_qops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->buf_struct_size = sizeof(struct vpif_disp_buffer);\r\nq->timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nret = vb2_queue_init(q);\r\nif (ret) {\r\nvpif_err("vpif_display: vb2_queue_init() failed\n");\r\nvb2_dma_contig_cleanup_ctx(common->alloc_ctx);\r\nreturn ret;\r\n}\r\nfh->io_allowed[index] = 1;\r\ncommon->io_usrs = 1;\r\ncommon->memory = reqbuf->memory;\r\nINIT_LIST_HEAD(&common->dma_queue);\r\nreturn vb2_reqbufs(&common->buffer_queue, reqbuf);\r\n}\r\nstatic int vpif_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *tbuf)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (common->fmt.type != tbuf->type)\r\nreturn -EINVAL;\r\nreturn vb2_querybuf(&common->buffer_queue, tbuf);\r\n}\r\nstatic int vpif_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct vpif_fh *fh = NULL;\r\nstruct channel_obj *ch = NULL;\r\nstruct common_obj *common = NULL;\r\nif (!buf || !priv)\r\nreturn -EINVAL;\r\nfh = priv;\r\nch = fh->channel;\r\nif (!ch)\r\nreturn -EINVAL;\r\ncommon = &(ch->common[VPIF_VIDEO_INDEX]);\r\nif (common->fmt.type != buf->type)\r\nreturn -EINVAL;\r\nif (!fh->io_allowed[VPIF_VIDEO_INDEX]) {\r\nvpif_err("fh->io_allowed\n");\r\nreturn -EACCES;\r\n}\r\nreturn vb2_qbuf(&common->buffer_queue, buf);\r\n}\r\nstatic int vpif_s_std(struct file *file, void *priv, v4l2_std_id std_id)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nint ret = 0;\r\nif (!(std_id & VPIF_V4L2_STD))\r\nreturn -EINVAL;\r\nif (common->started) {\r\nvpif_err("streaming in progress\n");\r\nreturn -EBUSY;\r\n}\r\nch->video.stdid = std_id;\r\nmemset(&ch->video.dv_timings, 0, sizeof(ch->video.dv_timings));\r\nif (vpif_update_resolution(ch))\r\nreturn -EINVAL;\r\nif ((ch->vpifparams.std_info.width *\r\nch->vpifparams.std_info.height * 2) >\r\nconfig_params.channel_bufsize[ch->channel_id]) {\r\nvpif_err("invalid std for this size\n");\r\nreturn -EINVAL;\r\n}\r\ncommon->fmt.fmt.pix.bytesperline = common->fmt.fmt.pix.width;\r\nvpif_config_format(ch);\r\nret = v4l2_device_call_until_err(&vpif_obj.v4l2_dev, 1, video,\r\ns_std_output, std_id);\r\nif (ret < 0) {\r\nvpif_err("Failed to set output standard\n");\r\nreturn ret;\r\n}\r\nret = v4l2_device_call_until_err(&vpif_obj.v4l2_dev, 1, core,\r\ns_std, std_id);\r\nif (ret < 0)\r\nvpif_err("Failed to set standard for sub devices\n");\r\nreturn ret;\r\n}\r\nstatic int vpif_g_std(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\n*std = ch->video.stdid;\r\nreturn 0;\r\n}\r\nstatic int vpif_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nreturn vb2_dqbuf(&common->buffer_queue, p,\r\n(file->f_flags & O_NONBLOCK));\r\n}\r\nstatic int vpif_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type buftype)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct channel_obj *oth_ch = vpif_obj.dev[!ch->channel_id];\r\nint ret = 0;\r\nif (buftype != V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nvpif_err("buffer type not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fh->io_allowed[VPIF_VIDEO_INDEX]) {\r\nvpif_err("fh->io_allowed\n");\r\nreturn -EACCES;\r\n}\r\nif (common->started) {\r\nvpif_err("channel->started\n");\r\nreturn -EBUSY;\r\n}\r\nif ((ch->channel_id == VPIF_CHANNEL2_VIDEO\r\n&& oth_ch->common[VPIF_VIDEO_INDEX].started &&\r\nch->vpifparams.std_info.ycmux_mode == 0)\r\n|| ((ch->channel_id == VPIF_CHANNEL3_VIDEO)\r\n&& (2 == oth_ch->common[VPIF_VIDEO_INDEX].started))) {\r\nvpif_err("other channel is using\n");\r\nreturn -EBUSY;\r\n}\r\nret = vpif_check_format(ch, &common->fmt.fmt.pix);\r\nif (ret < 0)\r\nreturn ret;\r\nret = vb2_streamon(&common->buffer_queue, buftype);\r\nif (ret < 0) {\r\nvpif_err("vb2_streamon\n");\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vpif_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type buftype)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nstruct vpif_display_config *vpif_config_data =\r\nvpif_dev->platform_data;\r\nif (buftype != V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nvpif_err("buffer type not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (!fh->io_allowed[VPIF_VIDEO_INDEX]) {\r\nvpif_err("fh->io_allowed\n");\r\nreturn -EACCES;\r\n}\r\nif (!common->started) {\r\nvpif_err("channel->started\n");\r\nreturn -EINVAL;\r\n}\r\nif (buftype == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nif (VPIF_CHANNEL2_VIDEO == ch->channel_id) {\r\nif (vpif_config_data->\r\nchan_config[VPIF_CHANNEL2_VIDEO].clip_en)\r\nchannel2_clipping_enable(0);\r\nenable_channel2(0);\r\nchannel2_intr_enable(0);\r\n}\r\nif ((VPIF_CHANNEL3_VIDEO == ch->channel_id) ||\r\n(2 == common->started)) {\r\nif (vpif_config_data->\r\nchan_config[VPIF_CHANNEL3_VIDEO].clip_en)\r\nchannel3_clipping_enable(0);\r\nenable_channel3(0);\r\nchannel3_intr_enable(0);\r\n}\r\n}\r\ncommon->started = 0;\r\nreturn vb2_streamoff(&common->buffer_queue, buftype);\r\n}\r\nstatic int vpif_cropcap(struct file *file, void *priv,\r\nstruct v4l2_cropcap *crop)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nif (V4L2_BUF_TYPE_VIDEO_OUTPUT != crop->type)\r\nreturn -EINVAL;\r\ncrop->bounds.left = crop->bounds.top = 0;\r\ncrop->defrect.left = crop->defrect.top = 0;\r\ncrop->defrect.height = crop->bounds.height = common->height;\r\ncrop->defrect.width = crop->bounds.width = common->width;\r\nreturn 0;\r\n}\r\nstatic int vpif_enum_output(struct file *file, void *fh,\r\nstruct v4l2_output *output)\r\n{\r\nstruct vpif_display_config *config = vpif_dev->platform_data;\r\nstruct vpif_display_chan_config *chan_cfg;\r\nstruct vpif_fh *vpif_handler = fh;\r\nstruct channel_obj *ch = vpif_handler->channel;\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\nif (output->index >= chan_cfg->output_count) {\r\nvpif_dbg(1, debug, "Invalid output index\n");\r\nreturn -EINVAL;\r\n}\r\n*output = chan_cfg->outputs[output->index].output;\r\nreturn 0;\r\n}\r\nstatic int\r\nvpif_output_to_subdev(struct vpif_display_config *vpif_cfg,\r\nstruct vpif_display_chan_config *chan_cfg, int index)\r\n{\r\nstruct vpif_subdev_info *subdev_info;\r\nconst char *subdev_name;\r\nint i;\r\nvpif_dbg(2, debug, "vpif_output_to_subdev\n");\r\nif (chan_cfg->outputs == NULL)\r\nreturn -1;\r\nsubdev_name = chan_cfg->outputs[index].subdev_name;\r\nif (subdev_name == NULL)\r\nreturn -1;\r\nfor (i = 0; i < vpif_cfg->subdev_count; i++) {\r\nsubdev_info = &vpif_cfg->subdevinfo[i];\r\nif (!strcmp(subdev_info->name, subdev_name))\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic int vpif_set_output(struct vpif_display_config *vpif_cfg,\r\nstruct channel_obj *ch, int index)\r\n{\r\nstruct vpif_display_chan_config *chan_cfg =\r\n&vpif_cfg->chan_config[ch->channel_id];\r\nstruct vpif_subdev_info *subdev_info = NULL;\r\nstruct v4l2_subdev *sd = NULL;\r\nu32 input = 0, output = 0;\r\nint sd_index;\r\nint ret;\r\nsd_index = vpif_output_to_subdev(vpif_cfg, chan_cfg, index);\r\nif (sd_index >= 0) {\r\nsd = vpif_obj.sd[sd_index];\r\nsubdev_info = &vpif_cfg->subdevinfo[sd_index];\r\n}\r\nif (sd) {\r\ninput = chan_cfg->outputs[index].input_route;\r\noutput = chan_cfg->outputs[index].output_route;\r\nret = v4l2_subdev_call(sd, video, s_routing, input, output, 0);\r\nif (ret < 0 && ret != -ENOIOCTLCMD) {\r\nvpif_err("Failed to set output\n");\r\nreturn ret;\r\n}\r\n}\r\nch->output_idx = index;\r\nch->sd = sd;\r\nif (chan_cfg->outputs != NULL)\r\nch->video_dev->tvnorms = chan_cfg->outputs[index].output.std;\r\nreturn 0;\r\n}\r\nstatic int vpif_s_output(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct vpif_display_config *config = vpif_dev->platform_data;\r\nstruct vpif_display_chan_config *chan_cfg;\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct common_obj *common = &ch->common[VPIF_VIDEO_INDEX];\r\nchan_cfg = &config->chan_config[ch->channel_id];\r\nif (i >= chan_cfg->output_count)\r\nreturn -EINVAL;\r\nif (common->started) {\r\nvpif_err("Streaming in progress\n");\r\nreturn -EBUSY;\r\n}\r\nreturn vpif_set_output(config, ch, i);\r\n}\r\nstatic int vpif_g_output(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\n*i = ch->output_idx;\r\nreturn 0;\r\n}\r\nstatic int vpif_g_priority(struct file *file, void *priv, enum v4l2_priority *p)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\n*p = v4l2_prio_max(&ch->prio);\r\nreturn 0;\r\n}\r\nstatic int vpif_s_priority(struct file *file, void *priv, enum v4l2_priority p)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nreturn v4l2_prio_change(&ch->prio, &fh->prio, p);\r\n}\r\nstatic int\r\nvpif_enum_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nint ret;\r\nret = v4l2_subdev_call(ch->sd, video, enum_dv_timings, timings);\r\nif (ret == -ENOIOCTLCMD || ret == -ENODEV)\r\nreturn -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int vpif_s_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct vpif_params *vpifparams = &ch->vpifparams;\r\nstruct vpif_channel_config_params *std_info = &vpifparams->std_info;\r\nstruct video_obj *vid_ch = &ch->video;\r\nstruct v4l2_bt_timings *bt = &vid_ch->dv_timings.bt;\r\nint ret;\r\nif (timings->type != V4L2_DV_BT_656_1120) {\r\nvpif_dbg(2, debug, "Timing type not defined\n");\r\nreturn -EINVAL;\r\n}\r\nret = v4l2_subdev_call(ch->sd, video, s_dv_timings, timings);\r\nif (ret == -ENOIOCTLCMD || ret == -ENODEV)\r\nret = 0;\r\nif (ret < 0) {\r\nvpif_dbg(2, debug, "Error setting custom DV timings\n");\r\nreturn ret;\r\n}\r\nif (!(timings->bt.width && timings->bt.height &&\r\n(timings->bt.hbackporch ||\r\ntimings->bt.hfrontporch ||\r\ntimings->bt.hsync) &&\r\ntimings->bt.vfrontporch &&\r\n(timings->bt.vbackporch ||\r\ntimings->bt.vsync))) {\r\nvpif_dbg(2, debug, "Timings for width, height, "\r\n"horizontal back porch, horizontal sync, "\r\n"horizontal front porch, vertical back porch, "\r\n"vertical sync and vertical back porch "\r\n"must be defined\n");\r\nreturn -EINVAL;\r\n}\r\nvid_ch->dv_timings = *timings;\r\nstd_info->eav2sav = V4L2_DV_BT_BLANKING_WIDTH(bt) - 8;\r\nstd_info->sav2eav = bt->width;\r\nstd_info->l1 = 1;\r\nstd_info->l3 = bt->vsync + bt->vbackporch + 1;\r\nstd_info->vsize = V4L2_DV_BT_FRAME_HEIGHT(bt);\r\nif (bt->interlaced) {\r\nif (bt->il_vbackporch || bt->il_vfrontporch || bt->il_vsync) {\r\nstd_info->l5 = std_info->vsize/2 -\r\n(bt->vfrontporch - 1);\r\nstd_info->l7 = std_info->vsize/2 + 1;\r\nstd_info->l9 = std_info->l7 + bt->il_vsync +\r\nbt->il_vbackporch + 1;\r\nstd_info->l11 = std_info->vsize -\r\n(bt->il_vfrontporch - 1);\r\n} else {\r\nvpif_dbg(2, debug, "Required timing values for "\r\n"interlaced BT format missing\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nstd_info->l5 = std_info->vsize - (bt->vfrontporch - 1);\r\n}\r\nstrncpy(std_info->name, "Custom timings BT656/1120",\r\nVPIF_MAX_NAME);\r\nstd_info->width = bt->width;\r\nstd_info->height = bt->height;\r\nstd_info->frm_fmt = bt->interlaced ? 0 : 1;\r\nstd_info->ycmux_mode = 0;\r\nstd_info->capture_format = 0;\r\nstd_info->vbi_supported = 0;\r\nstd_info->hd_sd = 1;\r\nstd_info->stdid = 0;\r\nvid_ch->stdid = 0;\r\nreturn 0;\r\n}\r\nstatic int vpif_g_dv_timings(struct file *file, void *priv,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct vpif_fh *fh = priv;\r\nstruct channel_obj *ch = fh->channel;\r\nstruct video_obj *vid_ch = &ch->video;\r\n*timings = vid_ch->dv_timings;\r\nreturn 0;\r\n}\r\nstatic int vpif_log_status(struct file *filep, void *priv)\r\n{\r\nv4l2_device_call_all(&vpif_obj.v4l2_dev, 0, core, log_status);\r\nreturn 0;\r\n}\r\nstatic int initialize_vpif(void)\r\n{\r\nint free_channel_objects_index;\r\nint free_buffer_channel_index;\r\nint free_buffer_index;\r\nint err = 0, i, j;\r\nif ((ch2_numbuffers > 0) &&\r\n(ch2_numbuffers < config_params.min_numbuffers))\r\nch2_numbuffers = config_params.min_numbuffers;\r\nif ((ch3_numbuffers > 0) &&\r\n(ch3_numbuffers < config_params.min_numbuffers))\r\nch3_numbuffers = config_params.min_numbuffers;\r\nif (ch2_bufsize < config_params.min_bufsize[VPIF_CHANNEL2_VIDEO])\r\nch2_bufsize =\r\nconfig_params.min_bufsize[VPIF_CHANNEL2_VIDEO];\r\nif (ch3_bufsize < config_params.min_bufsize[VPIF_CHANNEL3_VIDEO])\r\nch3_bufsize =\r\nconfig_params.min_bufsize[VPIF_CHANNEL3_VIDEO];\r\nconfig_params.numbuffers[VPIF_CHANNEL2_VIDEO] = ch2_numbuffers;\r\nif (ch2_numbuffers) {\r\nconfig_params.channel_bufsize[VPIF_CHANNEL2_VIDEO] =\r\nch2_bufsize;\r\n}\r\nconfig_params.numbuffers[VPIF_CHANNEL3_VIDEO] = ch3_numbuffers;\r\nif (ch3_numbuffers) {\r\nconfig_params.channel_bufsize[VPIF_CHANNEL3_VIDEO] =\r\nch3_bufsize;\r\n}\r\nfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\r\nvpif_obj.dev[i] =\r\nkzalloc(sizeof(struct channel_obj), GFP_KERNEL);\r\nif (!vpif_obj.dev[i]) {\r\nfree_channel_objects_index = i;\r\nerr = -ENOMEM;\r\ngoto vpif_init_free_channel_objects;\r\n}\r\n}\r\nfree_channel_objects_index = VPIF_DISPLAY_MAX_DEVICES;\r\nfree_buffer_channel_index = VPIF_DISPLAY_NUM_CHANNELS;\r\nfree_buffer_index = config_params.numbuffers[i - 1];\r\nreturn 0;\r\nvpif_init_free_channel_objects:\r\nfor (j = 0; j < free_channel_objects_index; j++)\r\nkfree(vpif_obj.dev[j]);\r\nreturn err;\r\n}\r\nstatic int vpif_async_bound(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *subdev,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nint i;\r\nfor (i = 0; i < vpif_obj.config->subdev_count; i++)\r\nif (!strcmp(vpif_obj.config->subdevinfo[i].name,\r\nsubdev->name)) {\r\nvpif_obj.sd[i] = subdev;\r\nvpif_obj.sd[i]->grp_id = 1 << i;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vpif_probe_complete(void)\r\n{\r\nstruct common_obj *common;\r\nstruct channel_obj *ch;\r\nint j, err, k;\r\nfor (j = 0; j < VPIF_DISPLAY_MAX_DEVICES; j++) {\r\nch = vpif_obj.dev[j];\r\natomic_set(&ch->usrs, 0);\r\nfor (k = 0; k < VPIF_NUMOBJECTS; k++) {\r\nch->common[k].numbuffers = 0;\r\ncommon = &ch->common[k];\r\ncommon->io_usrs = 0;\r\ncommon->started = 0;\r\nspin_lock_init(&common->irqlock);\r\nmutex_init(&common->lock);\r\ncommon->numbuffers = 0;\r\ncommon->set_addr = NULL;\r\ncommon->ytop_off = 0;\r\ncommon->ybtm_off = 0;\r\ncommon->ctop_off = 0;\r\ncommon->cbtm_off = 0;\r\ncommon->cur_frm = NULL;\r\ncommon->next_frm = NULL;\r\nmemset(&common->fmt, 0, sizeof(common->fmt));\r\ncommon->numbuffers = config_params.numbuffers[k];\r\n}\r\nch->initialized = 0;\r\nif (vpif_obj.config->subdev_count)\r\nch->sd = vpif_obj.sd[0];\r\nch->channel_id = j;\r\nif (j < 2)\r\nch->common[VPIF_VIDEO_INDEX].numbuffers =\r\nconfig_params.numbuffers[ch->channel_id];\r\nelse\r\nch->common[VPIF_VIDEO_INDEX].numbuffers = 0;\r\nmemset(&ch->vpifparams, 0, sizeof(ch->vpifparams));\r\nv4l2_prio_init(&ch->prio);\r\nch->common[VPIF_VIDEO_INDEX].fmt.type =\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nch->video_dev->lock = &common->lock;\r\nvideo_set_drvdata(ch->video_dev, ch);\r\nerr = vpif_set_output(vpif_obj.config, ch, 0);\r\nif (err)\r\ngoto probe_out;\r\nvpif_dbg(1, debug, "channel=%x,channel->video_dev=%x\n",\r\n(int)ch, (int)&ch->video_dev);\r\nerr = video_register_device(ch->video_dev,\r\nVFL_TYPE_GRABBER, (j ? 3 : 2));\r\nif (err < 0)\r\ngoto probe_out;\r\n}\r\nreturn 0;\r\nprobe_out:\r\nfor (k = 0; k < j; k++) {\r\nch = vpif_obj.dev[k];\r\nvideo_unregister_device(ch->video_dev);\r\nvideo_device_release(ch->video_dev);\r\nch->video_dev = NULL;\r\n}\r\nreturn err;\r\n}\r\nstatic int vpif_async_complete(struct v4l2_async_notifier *notifier)\r\n{\r\nreturn vpif_probe_complete();\r\n}\r\nstatic __init int vpif_probe(struct platform_device *pdev)\r\n{\r\nstruct vpif_subdev_info *subdevdata;\r\nint i, j = 0, err = 0;\r\nint res_idx = 0;\r\nstruct i2c_adapter *i2c_adap;\r\nstruct channel_obj *ch;\r\nstruct video_device *vfd;\r\nstruct resource *res;\r\nint subdev_count;\r\nsize_t size;\r\nvpif_dev = &pdev->dev;\r\nerr = initialize_vpif();\r\nif (err) {\r\nv4l2_err(vpif_dev->driver, "Error initializing vpif\n");\r\nreturn err;\r\n}\r\nerr = v4l2_device_register(vpif_dev, &vpif_obj.v4l2_dev);\r\nif (err) {\r\nv4l2_err(vpif_dev->driver, "Error registering v4l2 device\n");\r\nreturn err;\r\n}\r\nwhile ((res = platform_get_resource(pdev, IORESOURCE_IRQ, res_idx))) {\r\nerr = devm_request_irq(&pdev->dev, res->start, vpif_channel_isr,\r\nIRQF_SHARED, "VPIF_Display",\r\n(void *)(&vpif_obj.dev[res_idx]->\r\nchannel_id));\r\nif (err) {\r\nerr = -EINVAL;\r\nvpif_err("VPIF IRQ request failed\n");\r\ngoto vpif_unregister;\r\n}\r\nres_idx++;\r\n}\r\nfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\r\nch = vpif_obj.dev[i];\r\nvfd = video_device_alloc();\r\nif (vfd == NULL) {\r\nfor (j = 0; j < i; j++) {\r\nch = vpif_obj.dev[j];\r\nvideo_device_release(ch->video_dev);\r\n}\r\nerr = -ENOMEM;\r\ngoto vpif_unregister;\r\n}\r\n*vfd = vpif_video_template;\r\nvfd->v4l2_dev = &vpif_obj.v4l2_dev;\r\nvfd->release = video_device_release;\r\nvfd->vfl_dir = VFL_DIR_TX;\r\nsnprintf(vfd->name, sizeof(vfd->name),\r\n"VPIF_Display_DRIVER_V%s",\r\nVPIF_DISPLAY_VERSION);\r\nch->video_dev = vfd;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res) {\r\nsize = resource_size(res);\r\nfor (j = 0; j < VPIF_DISPLAY_MAX_DEVICES; j++) {\r\nch = vpif_obj.dev[j];\r\nch->channel_id = j;\r\nconfig_params.video_limit[ch->channel_id] = 0;\r\nif (size)\r\nconfig_params.video_limit[ch->channel_id] =\r\nsize/2;\r\n}\r\n}\r\nvpif_obj.config = pdev->dev.platform_data;\r\nsubdev_count = vpif_obj.config->subdev_count;\r\nsubdevdata = vpif_obj.config->subdevinfo;\r\nvpif_obj.sd = kzalloc(sizeof(struct v4l2_subdev *) * subdev_count,\r\nGFP_KERNEL);\r\nif (vpif_obj.sd == NULL) {\r\nvpif_err("unable to allocate memory for subdevice pointers\n");\r\nerr = -ENOMEM;\r\ngoto vpif_sd_error;\r\n}\r\nif (!vpif_obj.config->asd_sizes) {\r\ni2c_adap = i2c_get_adapter(1);\r\nfor (i = 0; i < subdev_count; i++) {\r\nvpif_obj.sd[i] =\r\nv4l2_i2c_new_subdev_board(&vpif_obj.v4l2_dev,\r\ni2c_adap,\r\n&subdevdata[i].\r\nboard_info,\r\nNULL);\r\nif (!vpif_obj.sd[i]) {\r\nvpif_err("Error registering v4l2 subdevice\n");\r\nerr = -ENODEV;\r\ngoto probe_subdev_out;\r\n}\r\nif (vpif_obj.sd[i])\r\nvpif_obj.sd[i]->grp_id = 1 << i;\r\n}\r\nvpif_probe_complete();\r\n} else {\r\nvpif_obj.notifier.subdevs = vpif_obj.config->asd;\r\nvpif_obj.notifier.num_subdevs = vpif_obj.config->asd_sizes[0];\r\nvpif_obj.notifier.bound = vpif_async_bound;\r\nvpif_obj.notifier.complete = vpif_async_complete;\r\nerr = v4l2_async_notifier_register(&vpif_obj.v4l2_dev,\r\n&vpif_obj.notifier);\r\nif (err) {\r\nvpif_err("Error registering async notifier\n");\r\nerr = -EINVAL;\r\ngoto probe_subdev_out;\r\n}\r\n}\r\nreturn 0;\r\nprobe_subdev_out:\r\nkfree(vpif_obj.sd);\r\nvpif_sd_error:\r\nfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\r\nch = vpif_obj.dev[i];\r\nvideo_device_release(ch->video_dev);\r\n}\r\nvpif_unregister:\r\nv4l2_device_unregister(&vpif_obj.v4l2_dev);\r\nreturn err;\r\n}\r\nstatic int vpif_remove(struct platform_device *device)\r\n{\r\nstruct channel_obj *ch;\r\nint i;\r\nv4l2_device_unregister(&vpif_obj.v4l2_dev);\r\nkfree(vpif_obj.sd);\r\nfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\r\nch = vpif_obj.dev[i];\r\nvideo_unregister_device(ch->video_dev);\r\nch->video_dev = NULL;\r\nkfree(vpif_obj.dev[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpif_suspend(struct device *dev)\r\n{\r\nstruct common_obj *common;\r\nstruct channel_obj *ch;\r\nint i;\r\nfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\r\nch = vpif_obj.dev[i];\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nmutex_lock(&common->lock);\r\nif (atomic_read(&ch->usrs) && common->io_usrs) {\r\nif (ch->channel_id == VPIF_CHANNEL2_VIDEO) {\r\nenable_channel2(0);\r\nchannel2_intr_enable(0);\r\n}\r\nif (ch->channel_id == VPIF_CHANNEL3_VIDEO ||\r\ncommon->started == 2) {\r\nenable_channel3(0);\r\nchannel3_intr_enable(0);\r\n}\r\n}\r\nmutex_unlock(&common->lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vpif_resume(struct device *dev)\r\n{\r\nstruct common_obj *common;\r\nstruct channel_obj *ch;\r\nint i;\r\nfor (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {\r\nch = vpif_obj.dev[i];\r\ncommon = &ch->common[VPIF_VIDEO_INDEX];\r\nmutex_lock(&common->lock);\r\nif (atomic_read(&ch->usrs) && common->io_usrs) {\r\nif (ch->channel_id == VPIF_CHANNEL2_VIDEO) {\r\nenable_channel2(1);\r\nchannel2_intr_enable(1);\r\n}\r\nif (ch->channel_id == VPIF_CHANNEL3_VIDEO ||\r\ncommon->started == 2) {\r\nenable_channel3(1);\r\nchannel3_intr_enable(1);\r\n}\r\n}\r\nmutex_unlock(&common->lock);\r\n}\r\nreturn 0;\r\n}
