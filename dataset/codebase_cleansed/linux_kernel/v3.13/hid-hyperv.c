static struct mousevsc_dev *mousevsc_alloc_device(struct hv_device *device)\r\n{\r\nstruct mousevsc_dev *input_dev;\r\ninput_dev = kzalloc(sizeof(struct mousevsc_dev), GFP_KERNEL);\r\nif (!input_dev)\r\nreturn NULL;\r\ninput_dev->device = device;\r\nhv_set_drvdata(device, input_dev);\r\ninit_completion(&input_dev->wait_event);\r\ninput_dev->init_complete = false;\r\nreturn input_dev;\r\n}\r\nstatic void mousevsc_free_device(struct mousevsc_dev *device)\r\n{\r\nkfree(device->hid_desc);\r\nkfree(device->report_desc);\r\nhv_set_drvdata(device->device, NULL);\r\nkfree(device);\r\n}\r\nstatic void mousevsc_on_receive_device_info(struct mousevsc_dev *input_device,\r\nstruct synthhid_device_info *device_info)\r\n{\r\nint ret = 0;\r\nstruct hid_descriptor *desc;\r\nstruct mousevsc_prt_msg ack;\r\ninput_device->dev_info_status = -ENOMEM;\r\ninput_device->hid_dev_info = device_info->hid_dev_info;\r\ndesc = &device_info->hid_descriptor;\r\nif (desc->bLength == 0)\r\ngoto cleanup;\r\ninput_device->hid_desc = kmemdup(desc, desc->bLength, GFP_ATOMIC);\r\nif (!input_device->hid_desc)\r\ngoto cleanup;\r\ninput_device->report_desc_size = desc->desc[0].wDescriptorLength;\r\nif (input_device->report_desc_size == 0) {\r\ninput_device->dev_info_status = -EINVAL;\r\ngoto cleanup;\r\n}\r\ninput_device->report_desc = kzalloc(input_device->report_desc_size,\r\nGFP_ATOMIC);\r\nif (!input_device->report_desc) {\r\ninput_device->dev_info_status = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nmemcpy(input_device->report_desc,\r\n((unsigned char *)desc) + desc->bLength,\r\ndesc->desc[0].wDescriptorLength);\r\nmemset(&ack, 0, sizeof(struct mousevsc_prt_msg));\r\nack.type = PIPE_MESSAGE_DATA;\r\nack.size = sizeof(struct synthhid_device_info_ack);\r\nack.ack.header.type = SYNTH_HID_INITIAL_DEVICE_INFO_ACK;\r\nack.ack.header.size = 1;\r\nack.ack.reserved = 0;\r\nret = vmbus_sendpacket(input_device->device->channel,\r\n&ack,\r\nsizeof(struct pipe_prt_msg) - sizeof(unsigned char) +\r\nsizeof(struct synthhid_device_info_ack),\r\n(unsigned long)&ack,\r\nVM_PKT_DATA_INBAND,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\r\nif (!ret)\r\ninput_device->dev_info_status = 0;\r\ncleanup:\r\ncomplete(&input_device->wait_event);\r\nreturn;\r\n}\r\nstatic void mousevsc_on_receive(struct hv_device *device,\r\nstruct vmpacket_descriptor *packet)\r\n{\r\nstruct pipe_prt_msg *pipe_msg;\r\nstruct synthhid_msg *hid_msg;\r\nstruct mousevsc_dev *input_dev = hv_get_drvdata(device);\r\nstruct synthhid_input_report *input_report;\r\npipe_msg = (struct pipe_prt_msg *)((unsigned long)packet +\r\n(packet->offset8 << 3));\r\nif (pipe_msg->type != PIPE_MESSAGE_DATA)\r\nreturn;\r\nhid_msg = (struct synthhid_msg *)pipe_msg->data;\r\nswitch (hid_msg->header.type) {\r\ncase SYNTH_HID_PROTOCOL_RESPONSE:\r\nif ((pipe_msg->size + sizeof(struct pipe_prt_msg)\r\n- sizeof(unsigned char))\r\n> sizeof(struct mousevsc_prt_msg)) {\r\nWARN_ON(1);\r\nbreak;\r\n}\r\nmemcpy(&input_dev->protocol_resp, pipe_msg,\r\npipe_msg->size + sizeof(struct pipe_prt_msg) -\r\nsizeof(unsigned char));\r\ncomplete(&input_dev->wait_event);\r\nbreak;\r\ncase SYNTH_HID_INITIAL_DEVICE_INFO:\r\nWARN_ON(pipe_msg->size < sizeof(struct hv_input_dev_info));\r\nmousevsc_on_receive_device_info(input_dev,\r\n(struct synthhid_device_info *)pipe_msg->data);\r\nbreak;\r\ncase SYNTH_HID_INPUT_REPORT:\r\ninput_report =\r\n(struct synthhid_input_report *)pipe_msg->data;\r\nif (!input_dev->init_complete)\r\nbreak;\r\nhid_input_report(input_dev->hid_device,\r\nHID_INPUT_REPORT, input_report->buffer,\r\ninput_report->header.size, 1);\r\nbreak;\r\ndefault:\r\npr_err("unsupported hid msg type - type %d len %d",\r\nhid_msg->header.type, hid_msg->header.size);\r\nbreak;\r\n}\r\n}\r\nstatic void mousevsc_on_channel_callback(void *context)\r\n{\r\nconst int packet_size = 0x100;\r\nint ret;\r\nstruct hv_device *device = context;\r\nu32 bytes_recvd;\r\nu64 req_id;\r\nstruct vmpacket_descriptor *desc;\r\nunsigned char *buffer;\r\nint bufferlen = packet_size;\r\nbuffer = kmalloc(bufferlen, GFP_ATOMIC);\r\nif (!buffer)\r\nreturn;\r\ndo {\r\nret = vmbus_recvpacket_raw(device->channel, buffer,\r\nbufferlen, &bytes_recvd, &req_id);\r\nswitch (ret) {\r\ncase 0:\r\nif (bytes_recvd <= 0) {\r\nkfree(buffer);\r\nreturn;\r\n}\r\ndesc = (struct vmpacket_descriptor *)buffer;\r\nswitch (desc->type) {\r\ncase VM_PKT_COMP:\r\nbreak;\r\ncase VM_PKT_DATA_INBAND:\r\nmousevsc_on_receive(device, desc);\r\nbreak;\r\ndefault:\r\npr_err("unhandled packet type %d, tid %llx len %d\n",\r\ndesc->type, req_id, bytes_recvd);\r\nbreak;\r\n}\r\nbreak;\r\ncase -ENOBUFS:\r\nkfree(buffer);\r\nbufferlen = bytes_recvd;\r\nbuffer = kmalloc(bytes_recvd, GFP_ATOMIC);\r\nif (!buffer)\r\nreturn;\r\nbreak;\r\n}\r\n} while (1);\r\n}\r\nstatic int mousevsc_connect_to_vsp(struct hv_device *device)\r\n{\r\nint ret = 0;\r\nint t;\r\nstruct mousevsc_dev *input_dev = hv_get_drvdata(device);\r\nstruct mousevsc_prt_msg *request;\r\nstruct mousevsc_prt_msg *response;\r\nrequest = &input_dev->protocol_req;\r\nmemset(request, 0, sizeof(struct mousevsc_prt_msg));\r\nrequest->type = PIPE_MESSAGE_DATA;\r\nrequest->size = sizeof(struct synthhid_protocol_request);\r\nrequest->request.header.type = SYNTH_HID_PROTOCOL_REQUEST;\r\nrequest->request.header.size = sizeof(unsigned int);\r\nrequest->request.version_requested.version = SYNTHHID_INPUT_VERSION;\r\nret = vmbus_sendpacket(device->channel, request,\r\nsizeof(struct pipe_prt_msg) -\r\nsizeof(unsigned char) +\r\nsizeof(struct synthhid_protocol_request),\r\n(unsigned long)request,\r\nVM_PKT_DATA_INBAND,\r\nVMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);\r\nif (ret)\r\ngoto cleanup;\r\nt = wait_for_completion_timeout(&input_dev->wait_event, 5*HZ);\r\nif (!t) {\r\nret = -ETIMEDOUT;\r\ngoto cleanup;\r\n}\r\nresponse = &input_dev->protocol_resp;\r\nif (!response->response.approved) {\r\npr_err("synthhid protocol request failed (version %d)\n",\r\nSYNTHHID_INPUT_VERSION);\r\nret = -ENODEV;\r\ngoto cleanup;\r\n}\r\nt = wait_for_completion_timeout(&input_dev->wait_event, 5*HZ);\r\nif (!t) {\r\nret = -ETIMEDOUT;\r\ngoto cleanup;\r\n}\r\nret = input_dev->dev_info_status;\r\ncleanup:\r\nreturn ret;\r\n}\r\nstatic int mousevsc_hid_parse(struct hid_device *hid)\r\n{\r\nstruct hv_device *dev = hid_get_drvdata(hid);\r\nstruct mousevsc_dev *input_dev = hv_get_drvdata(dev);\r\nreturn hid_parse_report(hid, input_dev->report_desc,\r\ninput_dev->report_desc_size);\r\n}\r\nstatic int mousevsc_hid_open(struct hid_device *hid)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mousevsc_hid_start(struct hid_device *hid)\r\n{\r\nreturn 0;\r\n}\r\nstatic void mousevsc_hid_close(struct hid_device *hid)\r\n{\r\n}\r\nstatic void mousevsc_hid_stop(struct hid_device *hid)\r\n{\r\n}\r\nstatic int mousevsc_probe(struct hv_device *device,\r\nconst struct hv_vmbus_device_id *dev_id)\r\n{\r\nint ret;\r\nstruct mousevsc_dev *input_dev;\r\nstruct hid_device *hid_dev;\r\ninput_dev = mousevsc_alloc_device(device);\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\nret = vmbus_open(device->channel,\r\nINPUTVSC_SEND_RING_BUFFER_SIZE,\r\nINPUTVSC_RECV_RING_BUFFER_SIZE,\r\nNULL,\r\n0,\r\nmousevsc_on_channel_callback,\r\ndevice\r\n);\r\nif (ret)\r\ngoto probe_err0;\r\nret = mousevsc_connect_to_vsp(device);\r\nif (ret)\r\ngoto probe_err1;\r\nif (input_dev->report_desc[14] == 0x25)\r\ninput_dev->report_desc[14] = 0x29;\r\nhid_dev = hid_allocate_device();\r\nif (IS_ERR(hid_dev)) {\r\nret = PTR_ERR(hid_dev);\r\ngoto probe_err1;\r\n}\r\nhid_dev->ll_driver = &mousevsc_ll_driver;\r\nhid_dev->driver = &mousevsc_hid_driver;\r\nhid_dev->bus = BUS_VIRTUAL;\r\nhid_dev->vendor = input_dev->hid_dev_info.vendor;\r\nhid_dev->product = input_dev->hid_dev_info.product;\r\nhid_dev->version = input_dev->hid_dev_info.version;\r\ninput_dev->hid_device = hid_dev;\r\nsprintf(hid_dev->name, "%s", "Microsoft Vmbus HID-compliant Mouse");\r\nhid_set_drvdata(hid_dev, device);\r\nret = hid_add_device(hid_dev);\r\nif (ret)\r\ngoto probe_err1;\r\nret = hid_parse(hid_dev);\r\nif (ret) {\r\nhid_err(hid_dev, "parse failed\n");\r\ngoto probe_err2;\r\n}\r\nret = hid_hw_start(hid_dev, HID_CONNECT_HIDINPUT | HID_CONNECT_HIDDEV);\r\nif (ret) {\r\nhid_err(hid_dev, "hw start failed\n");\r\ngoto probe_err2;\r\n}\r\ninput_dev->connected = true;\r\ninput_dev->init_complete = true;\r\nreturn ret;\r\nprobe_err2:\r\nhid_destroy_device(hid_dev);\r\nprobe_err1:\r\nvmbus_close(device->channel);\r\nprobe_err0:\r\nmousevsc_free_device(input_dev);\r\nreturn ret;\r\n}\r\nstatic int mousevsc_remove(struct hv_device *dev)\r\n{\r\nstruct mousevsc_dev *input_dev = hv_get_drvdata(dev);\r\nvmbus_close(dev->channel);\r\nhid_hw_stop(input_dev->hid_device);\r\nhid_destroy_device(input_dev->hid_device);\r\nmousevsc_free_device(input_dev);\r\nreturn 0;\r\n}\r\nstatic int __init mousevsc_init(void)\r\n{\r\nreturn vmbus_driver_register(&mousevsc_drv);\r\n}\r\nstatic void __exit mousevsc_exit(void)\r\n{\r\nvmbus_driver_unregister(&mousevsc_drv);\r\n}
