static inline void\r\ndo_compat_cache_op(unsigned long start, unsigned long end, int flags)\r\n{\r\nstruct mm_struct *mm = current->active_mm;\r\nstruct vm_area_struct *vma;\r\nif (end < start || flags)\r\nreturn;\r\ndown_read(&mm->mmap_sem);\r\nvma = find_vma(mm, start);\r\nif (vma && vma->vm_start < end) {\r\nif (start < vma->vm_start)\r\nstart = vma->vm_start;\r\nif (end > vma->vm_end)\r\nend = vma->vm_end;\r\nup_read(&mm->mmap_sem);\r\n__flush_cache_user_range(start & PAGE_MASK, PAGE_ALIGN(end));\r\nreturn;\r\n}\r\nup_read(&mm->mmap_sem);\r\n}\r\nlong compat_arm_syscall(struct pt_regs *regs)\r\n{\r\nunsigned int no = regs->regs[7];\r\nswitch (no) {\r\ncase __ARM_NR_compat_cacheflush:\r\ndo_compat_cache_op(regs->regs[0], regs->regs[1], regs->regs[2]);\r\nreturn 0;\r\ncase __ARM_NR_compat_set_tls:\r\ncurrent->thread.tp_value = regs->regs[0];\r\nasm ("msr tpidrro_el0, %0" : : "r" (regs->regs[0]));\r\nreturn 0;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\n}
