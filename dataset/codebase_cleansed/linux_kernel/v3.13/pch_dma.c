static inline\r\nstruct pch_dma_desc *to_pd_desc(struct dma_async_tx_descriptor *txd)\r\n{\r\nreturn container_of(txd, struct pch_dma_desc, txd);\r\n}\r\nstatic inline struct pch_dma_chan *to_pd_chan(struct dma_chan *chan)\r\n{\r\nreturn container_of(chan, struct pch_dma_chan, chan);\r\n}\r\nstatic inline struct pch_dma *to_pd(struct dma_device *ddev)\r\n{\r\nreturn container_of(ddev, struct pch_dma, dma);\r\n}\r\nstatic inline struct device *chan2dev(struct dma_chan *chan)\r\n{\r\nreturn &chan->dev->device;\r\n}\r\nstatic inline struct device *chan2parent(struct dma_chan *chan)\r\n{\r\nreturn chan->dev->device.parent;\r\n}\r\nstatic inline\r\nstruct pch_dma_desc *pdc_first_active(struct pch_dma_chan *pd_chan)\r\n{\r\nreturn list_first_entry(&pd_chan->active_list,\r\nstruct pch_dma_desc, desc_node);\r\n}\r\nstatic inline\r\nstruct pch_dma_desc *pdc_first_queued(struct pch_dma_chan *pd_chan)\r\n{\r\nreturn list_first_entry(&pd_chan->queue,\r\nstruct pch_dma_desc, desc_node);\r\n}\r\nstatic void pdc_enable_irq(struct dma_chan *chan, int enable)\r\n{\r\nstruct pch_dma *pd = to_pd(chan->device);\r\nu32 val;\r\nint pos;\r\nif (chan->chan_id < 8)\r\npos = chan->chan_id;\r\nelse\r\npos = chan->chan_id + 8;\r\nval = dma_readl(pd, CTL2);\r\nif (enable)\r\nval |= 0x1 << pos;\r\nelse\r\nval &= ~(0x1 << pos);\r\ndma_writel(pd, CTL2, val);\r\ndev_dbg(chan2dev(chan), "pdc_enable_irq: chan %d -> %x\n",\r\nchan->chan_id, val);\r\n}\r\nstatic void pdc_set_dir(struct dma_chan *chan)\r\n{\r\nstruct pch_dma_chan *pd_chan = to_pd_chan(chan);\r\nstruct pch_dma *pd = to_pd(chan->device);\r\nu32 val;\r\nu32 mask_mode;\r\nu32 mask_ctl;\r\nif (chan->chan_id < 8) {\r\nval = dma_readl(pd, CTL0);\r\nmask_mode = DMA_CTL0_MODE_MASK_BITS <<\r\n(DMA_CTL0_BITS_PER_CH * chan->chan_id);\r\nmask_ctl = DMA_MASK_CTL0_MODE & ~(DMA_CTL0_MODE_MASK_BITS <<\r\n(DMA_CTL0_BITS_PER_CH * chan->chan_id));\r\nval &= mask_mode;\r\nif (pd_chan->dir == DMA_MEM_TO_DEV)\r\nval |= 0x1 << (DMA_CTL0_BITS_PER_CH * chan->chan_id +\r\nDMA_CTL0_DIR_SHIFT_BITS);\r\nelse\r\nval &= ~(0x1 << (DMA_CTL0_BITS_PER_CH * chan->chan_id +\r\nDMA_CTL0_DIR_SHIFT_BITS));\r\nval |= mask_ctl;\r\ndma_writel(pd, CTL0, val);\r\n} else {\r\nint ch = chan->chan_id - 8;\r\nval = dma_readl(pd, CTL3);\r\nmask_mode = DMA_CTL0_MODE_MASK_BITS <<\r\n(DMA_CTL0_BITS_PER_CH * ch);\r\nmask_ctl = DMA_MASK_CTL2_MODE & ~(DMA_CTL0_MODE_MASK_BITS <<\r\n(DMA_CTL0_BITS_PER_CH * ch));\r\nval &= mask_mode;\r\nif (pd_chan->dir == DMA_MEM_TO_DEV)\r\nval |= 0x1 << (DMA_CTL0_BITS_PER_CH * ch +\r\nDMA_CTL0_DIR_SHIFT_BITS);\r\nelse\r\nval &= ~(0x1 << (DMA_CTL0_BITS_PER_CH * ch +\r\nDMA_CTL0_DIR_SHIFT_BITS));\r\nval |= mask_ctl;\r\ndma_writel(pd, CTL3, val);\r\n}\r\ndev_dbg(chan2dev(chan), "pdc_set_dir: chan %d -> %x\n",\r\nchan->chan_id, val);\r\n}\r\nstatic void pdc_set_mode(struct dma_chan *chan, u32 mode)\r\n{\r\nstruct pch_dma *pd = to_pd(chan->device);\r\nu32 val;\r\nu32 mask_ctl;\r\nu32 mask_dir;\r\nif (chan->chan_id < 8) {\r\nmask_ctl = DMA_MASK_CTL0_MODE & ~(DMA_CTL0_MODE_MASK_BITS <<\r\n(DMA_CTL0_BITS_PER_CH * chan->chan_id));\r\nmask_dir = 1 << (DMA_CTL0_BITS_PER_CH * chan->chan_id +\\r\nDMA_CTL0_DIR_SHIFT_BITS);\r\nval = dma_readl(pd, CTL0);\r\nval &= mask_dir;\r\nval |= mode << (DMA_CTL0_BITS_PER_CH * chan->chan_id);\r\nval |= mask_ctl;\r\ndma_writel(pd, CTL0, val);\r\n} else {\r\nint ch = chan->chan_id - 8;\r\nmask_ctl = DMA_MASK_CTL2_MODE & ~(DMA_CTL0_MODE_MASK_BITS <<\r\n(DMA_CTL0_BITS_PER_CH * ch));\r\nmask_dir = 1 << (DMA_CTL0_BITS_PER_CH * ch +\\r\nDMA_CTL0_DIR_SHIFT_BITS);\r\nval = dma_readl(pd, CTL3);\r\nval &= mask_dir;\r\nval |= mode << (DMA_CTL0_BITS_PER_CH * ch);\r\nval |= mask_ctl;\r\ndma_writel(pd, CTL3, val);\r\n}\r\ndev_dbg(chan2dev(chan), "pdc_set_mode: chan %d -> %x\n",\r\nchan->chan_id, val);\r\n}\r\nstatic u32 pdc_get_status0(struct pch_dma_chan *pd_chan)\r\n{\r\nstruct pch_dma *pd = to_pd(pd_chan->chan.device);\r\nu32 val;\r\nval = dma_readl(pd, STS0);\r\nreturn DMA_STATUS_MASK_BITS & (val >> (DMA_STATUS_SHIFT_BITS +\r\nDMA_STATUS_BITS_PER_CH * pd_chan->chan.chan_id));\r\n}\r\nstatic u32 pdc_get_status2(struct pch_dma_chan *pd_chan)\r\n{\r\nstruct pch_dma *pd = to_pd(pd_chan->chan.device);\r\nu32 val;\r\nval = dma_readl(pd, STS2);\r\nreturn DMA_STATUS_MASK_BITS & (val >> (DMA_STATUS_SHIFT_BITS +\r\nDMA_STATUS_BITS_PER_CH * (pd_chan->chan.chan_id - 8)));\r\n}\r\nstatic bool pdc_is_idle(struct pch_dma_chan *pd_chan)\r\n{\r\nu32 sts;\r\nif (pd_chan->chan.chan_id < 8)\r\nsts = pdc_get_status0(pd_chan);\r\nelse\r\nsts = pdc_get_status2(pd_chan);\r\nif (sts == DMA_STATUS_IDLE)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void pdc_dostart(struct pch_dma_chan *pd_chan, struct pch_dma_desc* desc)\r\n{\r\nif (!pdc_is_idle(pd_chan)) {\r\ndev_err(chan2dev(&pd_chan->chan),\r\n"BUG: Attempt to start non-idle channel\n");\r\nreturn;\r\n}\r\ndev_dbg(chan2dev(&pd_chan->chan), "chan %d -> dev_addr: %x\n",\r\npd_chan->chan.chan_id, desc->regs.dev_addr);\r\ndev_dbg(chan2dev(&pd_chan->chan), "chan %d -> mem_addr: %x\n",\r\npd_chan->chan.chan_id, desc->regs.mem_addr);\r\ndev_dbg(chan2dev(&pd_chan->chan), "chan %d -> size: %x\n",\r\npd_chan->chan.chan_id, desc->regs.size);\r\ndev_dbg(chan2dev(&pd_chan->chan), "chan %d -> next: %x\n",\r\npd_chan->chan.chan_id, desc->regs.next);\r\nif (list_empty(&desc->tx_list)) {\r\nchannel_writel(pd_chan, DEV_ADDR, desc->regs.dev_addr);\r\nchannel_writel(pd_chan, MEM_ADDR, desc->regs.mem_addr);\r\nchannel_writel(pd_chan, SIZE, desc->regs.size);\r\nchannel_writel(pd_chan, NEXT, desc->regs.next);\r\npdc_set_mode(&pd_chan->chan, DMA_CTL0_ONESHOT);\r\n} else {\r\nchannel_writel(pd_chan, NEXT, desc->txd.phys);\r\npdc_set_mode(&pd_chan->chan, DMA_CTL0_SG);\r\n}\r\n}\r\nstatic void pdc_chain_complete(struct pch_dma_chan *pd_chan,\r\nstruct pch_dma_desc *desc)\r\n{\r\nstruct dma_async_tx_descriptor *txd = &desc->txd;\r\ndma_async_tx_callback callback = txd->callback;\r\nvoid *param = txd->callback_param;\r\nlist_splice_init(&desc->tx_list, &pd_chan->free_list);\r\nlist_move(&desc->desc_node, &pd_chan->free_list);\r\nif (callback)\r\ncallback(param);\r\n}\r\nstatic void pdc_complete_all(struct pch_dma_chan *pd_chan)\r\n{\r\nstruct pch_dma_desc *desc, *_d;\r\nLIST_HEAD(list);\r\nBUG_ON(!pdc_is_idle(pd_chan));\r\nif (!list_empty(&pd_chan->queue))\r\npdc_dostart(pd_chan, pdc_first_queued(pd_chan));\r\nlist_splice_init(&pd_chan->active_list, &list);\r\nlist_splice_init(&pd_chan->queue, &pd_chan->active_list);\r\nlist_for_each_entry_safe(desc, _d, &list, desc_node)\r\npdc_chain_complete(pd_chan, desc);\r\n}\r\nstatic void pdc_handle_error(struct pch_dma_chan *pd_chan)\r\n{\r\nstruct pch_dma_desc *bad_desc;\r\nbad_desc = pdc_first_active(pd_chan);\r\nlist_del(&bad_desc->desc_node);\r\nlist_splice_init(&pd_chan->queue, pd_chan->active_list.prev);\r\nif (!list_empty(&pd_chan->active_list))\r\npdc_dostart(pd_chan, pdc_first_active(pd_chan));\r\ndev_crit(chan2dev(&pd_chan->chan), "Bad descriptor submitted\n");\r\ndev_crit(chan2dev(&pd_chan->chan), "descriptor cookie: %d\n",\r\nbad_desc->txd.cookie);\r\npdc_chain_complete(pd_chan, bad_desc);\r\n}\r\nstatic void pdc_advance_work(struct pch_dma_chan *pd_chan)\r\n{\r\nif (list_empty(&pd_chan->active_list) ||\r\nlist_is_singular(&pd_chan->active_list)) {\r\npdc_complete_all(pd_chan);\r\n} else {\r\npdc_chain_complete(pd_chan, pdc_first_active(pd_chan));\r\npdc_dostart(pd_chan, pdc_first_active(pd_chan));\r\n}\r\n}\r\nstatic dma_cookie_t pd_tx_submit(struct dma_async_tx_descriptor *txd)\r\n{\r\nstruct pch_dma_desc *desc = to_pd_desc(txd);\r\nstruct pch_dma_chan *pd_chan = to_pd_chan(txd->chan);\r\ndma_cookie_t cookie;\r\nspin_lock(&pd_chan->lock);\r\ncookie = dma_cookie_assign(txd);\r\nif (list_empty(&pd_chan->active_list)) {\r\nlist_add_tail(&desc->desc_node, &pd_chan->active_list);\r\npdc_dostart(pd_chan, desc);\r\n} else {\r\nlist_add_tail(&desc->desc_node, &pd_chan->queue);\r\n}\r\nspin_unlock(&pd_chan->lock);\r\nreturn 0;\r\n}\r\nstatic struct pch_dma_desc *pdc_alloc_desc(struct dma_chan *chan, gfp_t flags)\r\n{\r\nstruct pch_dma_desc *desc = NULL;\r\nstruct pch_dma *pd = to_pd(chan->device);\r\ndma_addr_t addr;\r\ndesc = pci_pool_alloc(pd->pool, flags, &addr);\r\nif (desc) {\r\nmemset(desc, 0, sizeof(struct pch_dma_desc));\r\nINIT_LIST_HEAD(&desc->tx_list);\r\ndma_async_tx_descriptor_init(&desc->txd, chan);\r\ndesc->txd.tx_submit = pd_tx_submit;\r\ndesc->txd.flags = DMA_CTRL_ACK;\r\ndesc->txd.phys = addr;\r\n}\r\nreturn desc;\r\n}\r\nstatic struct pch_dma_desc *pdc_desc_get(struct pch_dma_chan *pd_chan)\r\n{\r\nstruct pch_dma_desc *desc, *_d;\r\nstruct pch_dma_desc *ret = NULL;\r\nint i = 0;\r\nspin_lock(&pd_chan->lock);\r\nlist_for_each_entry_safe(desc, _d, &pd_chan->free_list, desc_node) {\r\ni++;\r\nif (async_tx_test_ack(&desc->txd)) {\r\nlist_del(&desc->desc_node);\r\nret = desc;\r\nbreak;\r\n}\r\ndev_dbg(chan2dev(&pd_chan->chan), "desc %p not ACKed\n", desc);\r\n}\r\nspin_unlock(&pd_chan->lock);\r\ndev_dbg(chan2dev(&pd_chan->chan), "scanned %d descriptors\n", i);\r\nif (!ret) {\r\nret = pdc_alloc_desc(&pd_chan->chan, GFP_ATOMIC);\r\nif (ret) {\r\nspin_lock(&pd_chan->lock);\r\npd_chan->descs_allocated++;\r\nspin_unlock(&pd_chan->lock);\r\n} else {\r\ndev_err(chan2dev(&pd_chan->chan),\r\n"failed to alloc desc\n");\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void pdc_desc_put(struct pch_dma_chan *pd_chan,\r\nstruct pch_dma_desc *desc)\r\n{\r\nif (desc) {\r\nspin_lock(&pd_chan->lock);\r\nlist_splice_init(&desc->tx_list, &pd_chan->free_list);\r\nlist_add(&desc->desc_node, &pd_chan->free_list);\r\nspin_unlock(&pd_chan->lock);\r\n}\r\n}\r\nstatic int pd_alloc_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct pch_dma_chan *pd_chan = to_pd_chan(chan);\r\nstruct pch_dma_desc *desc;\r\nLIST_HEAD(tmp_list);\r\nint i;\r\nif (!pdc_is_idle(pd_chan)) {\r\ndev_dbg(chan2dev(chan), "DMA channel not idle ?\n");\r\nreturn -EIO;\r\n}\r\nif (!list_empty(&pd_chan->free_list))\r\nreturn pd_chan->descs_allocated;\r\nfor (i = 0; i < init_nr_desc_per_channel; i++) {\r\ndesc = pdc_alloc_desc(chan, GFP_KERNEL);\r\nif (!desc) {\r\ndev_warn(chan2dev(chan),\r\n"Only allocated %d initial descriptors\n", i);\r\nbreak;\r\n}\r\nlist_add_tail(&desc->desc_node, &tmp_list);\r\n}\r\nspin_lock_irq(&pd_chan->lock);\r\nlist_splice(&tmp_list, &pd_chan->free_list);\r\npd_chan->descs_allocated = i;\r\ndma_cookie_init(chan);\r\nspin_unlock_irq(&pd_chan->lock);\r\npdc_enable_irq(chan, 1);\r\nreturn pd_chan->descs_allocated;\r\n}\r\nstatic void pd_free_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct pch_dma_chan *pd_chan = to_pd_chan(chan);\r\nstruct pch_dma *pd = to_pd(chan->device);\r\nstruct pch_dma_desc *desc, *_d;\r\nLIST_HEAD(tmp_list);\r\nBUG_ON(!pdc_is_idle(pd_chan));\r\nBUG_ON(!list_empty(&pd_chan->active_list));\r\nBUG_ON(!list_empty(&pd_chan->queue));\r\nspin_lock_irq(&pd_chan->lock);\r\nlist_splice_init(&pd_chan->free_list, &tmp_list);\r\npd_chan->descs_allocated = 0;\r\nspin_unlock_irq(&pd_chan->lock);\r\nlist_for_each_entry_safe(desc, _d, &tmp_list, desc_node)\r\npci_pool_free(pd->pool, desc, desc->txd.phys);\r\npdc_enable_irq(chan, 0);\r\n}\r\nstatic enum dma_status pd_tx_status(struct dma_chan *chan, dma_cookie_t cookie,\r\nstruct dma_tx_state *txstate)\r\n{\r\nreturn dma_cookie_status(chan, cookie, txstate);\r\n}\r\nstatic void pd_issue_pending(struct dma_chan *chan)\r\n{\r\nstruct pch_dma_chan *pd_chan = to_pd_chan(chan);\r\nif (pdc_is_idle(pd_chan)) {\r\nspin_lock(&pd_chan->lock);\r\npdc_advance_work(pd_chan);\r\nspin_unlock(&pd_chan->lock);\r\n}\r\n}\r\nstatic struct dma_async_tx_descriptor *pd_prep_slave_sg(struct dma_chan *chan,\r\nstruct scatterlist *sgl, unsigned int sg_len,\r\nenum dma_transfer_direction direction, unsigned long flags,\r\nvoid *context)\r\n{\r\nstruct pch_dma_chan *pd_chan = to_pd_chan(chan);\r\nstruct pch_dma_slave *pd_slave = chan->private;\r\nstruct pch_dma_desc *first = NULL;\r\nstruct pch_dma_desc *prev = NULL;\r\nstruct pch_dma_desc *desc = NULL;\r\nstruct scatterlist *sg;\r\ndma_addr_t reg;\r\nint i;\r\nif (unlikely(!sg_len)) {\r\ndev_info(chan2dev(chan), "prep_slave_sg: length is zero!\n");\r\nreturn NULL;\r\n}\r\nif (direction == DMA_DEV_TO_MEM)\r\nreg = pd_slave->rx_reg;\r\nelse if (direction == DMA_MEM_TO_DEV)\r\nreg = pd_slave->tx_reg;\r\nelse\r\nreturn NULL;\r\npd_chan->dir = direction;\r\npdc_set_dir(chan);\r\nfor_each_sg(sgl, sg, sg_len, i) {\r\ndesc = pdc_desc_get(pd_chan);\r\nif (!desc)\r\ngoto err_desc_get;\r\ndesc->regs.dev_addr = reg;\r\ndesc->regs.mem_addr = sg_dma_address(sg);\r\ndesc->regs.size = sg_dma_len(sg);\r\ndesc->regs.next = DMA_DESC_FOLLOW_WITHOUT_IRQ;\r\nswitch (pd_slave->width) {\r\ncase PCH_DMA_WIDTH_1_BYTE:\r\nif (desc->regs.size > DMA_DESC_MAX_COUNT_1_BYTE)\r\ngoto err_desc_get;\r\ndesc->regs.size |= DMA_DESC_WIDTH_1_BYTE;\r\nbreak;\r\ncase PCH_DMA_WIDTH_2_BYTES:\r\nif (desc->regs.size > DMA_DESC_MAX_COUNT_2_BYTES)\r\ngoto err_desc_get;\r\ndesc->regs.size |= DMA_DESC_WIDTH_2_BYTES;\r\nbreak;\r\ncase PCH_DMA_WIDTH_4_BYTES:\r\nif (desc->regs.size > DMA_DESC_MAX_COUNT_4_BYTES)\r\ngoto err_desc_get;\r\ndesc->regs.size |= DMA_DESC_WIDTH_4_BYTES;\r\nbreak;\r\ndefault:\r\ngoto err_desc_get;\r\n}\r\nif (!first) {\r\nfirst = desc;\r\n} else {\r\nprev->regs.next |= desc->txd.phys;\r\nlist_add_tail(&desc->desc_node, &first->tx_list);\r\n}\r\nprev = desc;\r\n}\r\nif (flags & DMA_PREP_INTERRUPT)\r\ndesc->regs.next = DMA_DESC_END_WITH_IRQ;\r\nelse\r\ndesc->regs.next = DMA_DESC_END_WITHOUT_IRQ;\r\nfirst->txd.cookie = -EBUSY;\r\ndesc->txd.flags = flags;\r\nreturn &first->txd;\r\nerr_desc_get:\r\ndev_err(chan2dev(chan), "failed to get desc or wrong parameters\n");\r\npdc_desc_put(pd_chan, first);\r\nreturn NULL;\r\n}\r\nstatic int pd_device_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,\r\nunsigned long arg)\r\n{\r\nstruct pch_dma_chan *pd_chan = to_pd_chan(chan);\r\nstruct pch_dma_desc *desc, *_d;\r\nLIST_HEAD(list);\r\nif (cmd != DMA_TERMINATE_ALL)\r\nreturn -ENXIO;\r\nspin_lock_irq(&pd_chan->lock);\r\npdc_set_mode(&pd_chan->chan, DMA_CTL0_DISABLE);\r\nlist_splice_init(&pd_chan->active_list, &list);\r\nlist_splice_init(&pd_chan->queue, &list);\r\nlist_for_each_entry_safe(desc, _d, &list, desc_node)\r\npdc_chain_complete(pd_chan, desc);\r\nspin_unlock_irq(&pd_chan->lock);\r\nreturn 0;\r\n}\r\nstatic void pdc_tasklet(unsigned long data)\r\n{\r\nstruct pch_dma_chan *pd_chan = (struct pch_dma_chan *)data;\r\nunsigned long flags;\r\nif (!pdc_is_idle(pd_chan)) {\r\ndev_err(chan2dev(&pd_chan->chan),\r\n"BUG: handle non-idle channel in tasklet\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&pd_chan->lock, flags);\r\nif (test_and_clear_bit(0, &pd_chan->err_status))\r\npdc_handle_error(pd_chan);\r\nelse\r\npdc_advance_work(pd_chan);\r\nspin_unlock_irqrestore(&pd_chan->lock, flags);\r\n}\r\nstatic irqreturn_t pd_irq(int irq, void *devid)\r\n{\r\nstruct pch_dma *pd = (struct pch_dma *)devid;\r\nstruct pch_dma_chan *pd_chan;\r\nu32 sts0;\r\nu32 sts2;\r\nint i;\r\nint ret0 = IRQ_NONE;\r\nint ret2 = IRQ_NONE;\r\nsts0 = dma_readl(pd, STS0);\r\nsts2 = dma_readl(pd, STS2);\r\ndev_dbg(pd->dma.dev, "pd_irq sts0: %x\n", sts0);\r\nfor (i = 0; i < pd->dma.chancnt; i++) {\r\npd_chan = &pd->channels[i];\r\nif (i < 8) {\r\nif (sts0 & DMA_STATUS_IRQ(i)) {\r\nif (sts0 & DMA_STATUS0_ERR(i))\r\nset_bit(0, &pd_chan->err_status);\r\ntasklet_schedule(&pd_chan->tasklet);\r\nret0 = IRQ_HANDLED;\r\n}\r\n} else {\r\nif (sts2 & DMA_STATUS_IRQ(i - 8)) {\r\nif (sts2 & DMA_STATUS2_ERR(i))\r\nset_bit(0, &pd_chan->err_status);\r\ntasklet_schedule(&pd_chan->tasklet);\r\nret2 = IRQ_HANDLED;\r\n}\r\n}\r\n}\r\nif (ret0)\r\ndma_writel(pd, STS0, sts0);\r\nif (ret2)\r\ndma_writel(pd, STS2, sts2);\r\nreturn ret0 | ret2;\r\n}\r\nstatic void pch_dma_save_regs(struct pch_dma *pd)\r\n{\r\nstruct pch_dma_chan *pd_chan;\r\nstruct dma_chan *chan, *_c;\r\nint i = 0;\r\npd->regs.dma_ctl0 = dma_readl(pd, CTL0);\r\npd->regs.dma_ctl1 = dma_readl(pd, CTL1);\r\npd->regs.dma_ctl2 = dma_readl(pd, CTL2);\r\npd->regs.dma_ctl3 = dma_readl(pd, CTL3);\r\nlist_for_each_entry_safe(chan, _c, &pd->dma.channels, device_node) {\r\npd_chan = to_pd_chan(chan);\r\npd->ch_regs[i].dev_addr = channel_readl(pd_chan, DEV_ADDR);\r\npd->ch_regs[i].mem_addr = channel_readl(pd_chan, MEM_ADDR);\r\npd->ch_regs[i].size = channel_readl(pd_chan, SIZE);\r\npd->ch_regs[i].next = channel_readl(pd_chan, NEXT);\r\ni++;\r\n}\r\n}\r\nstatic void pch_dma_restore_regs(struct pch_dma *pd)\r\n{\r\nstruct pch_dma_chan *pd_chan;\r\nstruct dma_chan *chan, *_c;\r\nint i = 0;\r\ndma_writel(pd, CTL0, pd->regs.dma_ctl0);\r\ndma_writel(pd, CTL1, pd->regs.dma_ctl1);\r\ndma_writel(pd, CTL2, pd->regs.dma_ctl2);\r\ndma_writel(pd, CTL3, pd->regs.dma_ctl3);\r\nlist_for_each_entry_safe(chan, _c, &pd->dma.channels, device_node) {\r\npd_chan = to_pd_chan(chan);\r\nchannel_writel(pd_chan, DEV_ADDR, pd->ch_regs[i].dev_addr);\r\nchannel_writel(pd_chan, MEM_ADDR, pd->ch_regs[i].mem_addr);\r\nchannel_writel(pd_chan, SIZE, pd->ch_regs[i].size);\r\nchannel_writel(pd_chan, NEXT, pd->ch_regs[i].next);\r\ni++;\r\n}\r\n}\r\nstatic int pch_dma_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct pch_dma *pd = pci_get_drvdata(pdev);\r\nif (pd)\r\npch_dma_save_regs(pd);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int pch_dma_resume(struct pci_dev *pdev)\r\n{\r\nstruct pch_dma *pd = pci_get_drvdata(pdev);\r\nint err;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\ndev_dbg(&pdev->dev, "failed to enable device\n");\r\nreturn err;\r\n}\r\nif (pd)\r\npch_dma_restore_regs(pd);\r\nreturn 0;\r\n}\r\nstatic int pch_dma_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct pch_dma *pd;\r\nstruct pch_dma_regs *regs;\r\nunsigned int nr_channels;\r\nint err;\r\nint i;\r\nnr_channels = id->driver_data;\r\npd = kzalloc(sizeof(*pd), GFP_KERNEL);\r\nif (!pd)\r\nreturn -ENOMEM;\r\npci_set_drvdata(pdev, pd);\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot enable PCI device\n");\r\ngoto err_free_mem;\r\n}\r\nif (!(pci_resource_flags(pdev, 1) & IORESOURCE_MEM)) {\r\ndev_err(&pdev->dev, "Cannot find proper base address\n");\r\nerr = -ENODEV;\r\ngoto err_disable_pdev;\r\n}\r\nerr = pci_request_regions(pdev, DRV_NAME);\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot obtain PCI resources\n");\r\ngoto err_disable_pdev;\r\n}\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (err) {\r\ndev_err(&pdev->dev, "Cannot set proper DMA config\n");\r\ngoto err_free_res;\r\n}\r\nregs = pd->membase = pci_iomap(pdev, 1, 0);\r\nif (!pd->membase) {\r\ndev_err(&pdev->dev, "Cannot map MMIO registers\n");\r\nerr = -ENOMEM;\r\ngoto err_free_res;\r\n}\r\npci_set_master(pdev);\r\nerr = request_irq(pdev->irq, pd_irq, IRQF_SHARED, DRV_NAME, pd);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to request IRQ\n");\r\ngoto err_iounmap;\r\n}\r\npd->pool = pci_pool_create("pch_dma_desc_pool", pdev,\r\nsizeof(struct pch_dma_desc), 4, 0);\r\nif (!pd->pool) {\r\ndev_err(&pdev->dev, "Failed to alloc DMA descriptors\n");\r\nerr = -ENOMEM;\r\ngoto err_free_irq;\r\n}\r\npd->dma.dev = &pdev->dev;\r\nINIT_LIST_HEAD(&pd->dma.channels);\r\nfor (i = 0; i < nr_channels; i++) {\r\nstruct pch_dma_chan *pd_chan = &pd->channels[i];\r\npd_chan->chan.device = &pd->dma;\r\ndma_cookie_init(&pd_chan->chan);\r\npd_chan->membase = &regs->desc[i];\r\nspin_lock_init(&pd_chan->lock);\r\nINIT_LIST_HEAD(&pd_chan->active_list);\r\nINIT_LIST_HEAD(&pd_chan->queue);\r\nINIT_LIST_HEAD(&pd_chan->free_list);\r\ntasklet_init(&pd_chan->tasklet, pdc_tasklet,\r\n(unsigned long)pd_chan);\r\nlist_add_tail(&pd_chan->chan.device_node, &pd->dma.channels);\r\n}\r\ndma_cap_zero(pd->dma.cap_mask);\r\ndma_cap_set(DMA_PRIVATE, pd->dma.cap_mask);\r\ndma_cap_set(DMA_SLAVE, pd->dma.cap_mask);\r\npd->dma.device_alloc_chan_resources = pd_alloc_chan_resources;\r\npd->dma.device_free_chan_resources = pd_free_chan_resources;\r\npd->dma.device_tx_status = pd_tx_status;\r\npd->dma.device_issue_pending = pd_issue_pending;\r\npd->dma.device_prep_slave_sg = pd_prep_slave_sg;\r\npd->dma.device_control = pd_device_control;\r\nerr = dma_async_device_register(&pd->dma);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to register DMA device\n");\r\ngoto err_free_pool;\r\n}\r\nreturn 0;\r\nerr_free_pool:\r\npci_pool_destroy(pd->pool);\r\nerr_free_irq:\r\nfree_irq(pdev->irq, pd);\r\nerr_iounmap:\r\npci_iounmap(pdev, pd->membase);\r\nerr_free_res:\r\npci_release_regions(pdev);\r\nerr_disable_pdev:\r\npci_disable_device(pdev);\r\nerr_free_mem:\r\nreturn err;\r\n}\r\nstatic void pch_dma_remove(struct pci_dev *pdev)\r\n{\r\nstruct pch_dma *pd = pci_get_drvdata(pdev);\r\nstruct pch_dma_chan *pd_chan;\r\nstruct dma_chan *chan, *_c;\r\nif (pd) {\r\ndma_async_device_unregister(&pd->dma);\r\nlist_for_each_entry_safe(chan, _c, &pd->dma.channels,\r\ndevice_node) {\r\npd_chan = to_pd_chan(chan);\r\ntasklet_disable(&pd_chan->tasklet);\r\ntasklet_kill(&pd_chan->tasklet);\r\n}\r\npci_pool_destroy(pd->pool);\r\nfree_irq(pdev->irq, pd);\r\npci_iounmap(pdev, pd->membase);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nkfree(pd);\r\n}\r\n}
