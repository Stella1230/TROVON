static int qxl_alloc_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct qxl_device *qdev = dev->dev_private;\r\nstruct drm_qxl_alloc *qxl_alloc = data;\r\nint ret;\r\nstruct qxl_bo *qobj;\r\nuint32_t handle;\r\nu32 domain = QXL_GEM_DOMAIN_VRAM;\r\nif (qxl_alloc->size == 0) {\r\nDRM_ERROR("invalid size %d\n", qxl_alloc->size);\r\nreturn -EINVAL;\r\n}\r\nret = qxl_gem_object_create_with_handle(qdev, file_priv,\r\ndomain,\r\nqxl_alloc->size,\r\nNULL,\r\n&qobj, &handle);\r\nif (ret) {\r\nDRM_ERROR("%s: failed to create gem ret=%d\n",\r\n__func__, ret);\r\nreturn -ENOMEM;\r\n}\r\nqxl_alloc->handle = handle;\r\nreturn 0;\r\n}\r\nstatic int qxl_map_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct qxl_device *qdev = dev->dev_private;\r\nstruct drm_qxl_map *qxl_map = data;\r\nreturn qxl_mode_dumb_mmap(file_priv, qdev->ddev, qxl_map->handle,\r\n&qxl_map->offset);\r\n}\r\nstatic void\r\napply_reloc(struct qxl_device *qdev, struct qxl_reloc_info *info)\r\n{\r\nvoid *reloc_page;\r\nreloc_page = qxl_bo_kmap_atomic_page(qdev, info->dst_bo, info->dst_offset & PAGE_MASK);\r\n*(uint64_t *)(reloc_page + (info->dst_offset & ~PAGE_MASK)) = qxl_bo_physical_address(qdev,\r\ninfo->src_bo,\r\ninfo->src_offset);\r\nqxl_bo_kunmap_atomic_page(qdev, info->dst_bo, reloc_page);\r\n}\r\nstatic void\r\napply_surf_reloc(struct qxl_device *qdev, struct qxl_reloc_info *info)\r\n{\r\nuint32_t id = 0;\r\nvoid *reloc_page;\r\nif (info->src_bo && !info->src_bo->is_primary)\r\nid = info->src_bo->surface_id;\r\nreloc_page = qxl_bo_kmap_atomic_page(qdev, info->dst_bo, info->dst_offset & PAGE_MASK);\r\n*(uint32_t *)(reloc_page + (info->dst_offset & ~PAGE_MASK)) = id;\r\nqxl_bo_kunmap_atomic_page(qdev, info->dst_bo, reloc_page);\r\n}\r\nstatic struct qxl_bo *qxlhw_handle_to_bo(struct qxl_device *qdev,\r\nstruct drm_file *file_priv, uint64_t handle,\r\nstruct qxl_release *release)\r\n{\r\nstruct drm_gem_object *gobj;\r\nstruct qxl_bo *qobj;\r\nint ret;\r\ngobj = drm_gem_object_lookup(qdev->ddev, file_priv, handle);\r\nif (!gobj)\r\nreturn NULL;\r\nqobj = gem_to_qxl_bo(gobj);\r\nret = qxl_release_list_add(release, qobj);\r\nif (ret)\r\nreturn NULL;\r\nreturn qobj;\r\n}\r\nstatic int qxl_process_single_command(struct qxl_device *qdev,\r\nstruct drm_qxl_command *cmd,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct qxl_reloc_info *reloc_info;\r\nint release_type;\r\nstruct qxl_release *release;\r\nstruct qxl_bo *cmd_bo;\r\nvoid *fb_cmd;\r\nint i, j, ret, num_relocs;\r\nint unwritten;\r\nswitch (cmd->type) {\r\ncase QXL_CMD_DRAW:\r\nrelease_type = QXL_RELEASE_DRAWABLE;\r\nbreak;\r\ncase QXL_CMD_SURFACE:\r\ncase QXL_CMD_CURSOR:\r\ndefault:\r\nDRM_DEBUG("Only draw commands in execbuffers\n");\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nif (cmd->command_size > PAGE_SIZE - sizeof(union qxl_release_info))\r\nreturn -EINVAL;\r\nif (!access_ok(VERIFY_READ,\r\n(void *)(unsigned long)cmd->command,\r\ncmd->command_size))\r\nreturn -EFAULT;\r\nreloc_info = kmalloc(sizeof(struct qxl_reloc_info) * cmd->relocs_num, GFP_KERNEL);\r\nif (!reloc_info)\r\nreturn -ENOMEM;\r\nret = qxl_alloc_release_reserved(qdev,\r\nsizeof(union qxl_release_info) +\r\ncmd->command_size,\r\nrelease_type,\r\n&release,\r\n&cmd_bo);\r\nif (ret)\r\ngoto out_free_reloc;\r\nfb_cmd = qxl_bo_kmap_atomic_page(qdev, cmd_bo, (release->release_offset & PAGE_SIZE));\r\nunwritten = __copy_from_user_inatomic_nocache(fb_cmd + sizeof(union qxl_release_info) + (release->release_offset & ~PAGE_SIZE), (void *)(unsigned long)cmd->command, cmd->command_size);\r\n{\r\nstruct qxl_drawable *draw = fb_cmd;\r\ndraw->mm_time = qdev->rom->mm_clock;\r\n}\r\nqxl_bo_kunmap_atomic_page(qdev, cmd_bo, fb_cmd);\r\nif (unwritten) {\r\nDRM_ERROR("got unwritten %d\n", unwritten);\r\nret = -EFAULT;\r\ngoto out_free_release;\r\n}\r\nnum_relocs = 0;\r\nfor (i = 0; i < cmd->relocs_num; ++i) {\r\nstruct drm_qxl_reloc reloc;\r\nif (DRM_COPY_FROM_USER(&reloc,\r\n&((struct drm_qxl_reloc *)(uintptr_t)cmd->relocs)[i],\r\nsizeof(reloc))) {\r\nret = -EFAULT;\r\ngoto out_free_bos;\r\n}\r\nif (reloc.reloc_type != QXL_RELOC_TYPE_BO && reloc.reloc_type != QXL_RELOC_TYPE_SURF) {\r\nDRM_DEBUG("unknown reloc type %d\n", reloc_info[i].type);\r\nret = -EINVAL;\r\ngoto out_free_bos;\r\n}\r\nreloc_info[i].type = reloc.reloc_type;\r\nif (reloc.dst_handle) {\r\nreloc_info[i].dst_bo = qxlhw_handle_to_bo(qdev, file_priv,\r\nreloc.dst_handle, release);\r\nif (!reloc_info[i].dst_bo) {\r\nret = -EINVAL;\r\nreloc_info[i].src_bo = NULL;\r\ngoto out_free_bos;\r\n}\r\nreloc_info[i].dst_offset = reloc.dst_offset;\r\n} else {\r\nreloc_info[i].dst_bo = cmd_bo;\r\nreloc_info[i].dst_offset = reloc.dst_offset + release->release_offset;\r\n}\r\nnum_relocs++;\r\nif (reloc.reloc_type == QXL_RELOC_TYPE_BO || reloc.src_handle > 0) {\r\nreloc_info[i].src_bo =\r\nqxlhw_handle_to_bo(qdev, file_priv,\r\nreloc.src_handle, release);\r\nif (!reloc_info[i].src_bo) {\r\nif (reloc_info[i].dst_bo != cmd_bo)\r\ndrm_gem_object_unreference_unlocked(&reloc_info[i].dst_bo->gem_base);\r\nret = -EINVAL;\r\ngoto out_free_bos;\r\n}\r\nreloc_info[i].src_offset = reloc.src_offset;\r\n} else {\r\nreloc_info[i].src_bo = NULL;\r\nreloc_info[i].src_offset = 0;\r\n}\r\n}\r\nret = qxl_release_reserve_list(release, false);\r\nif (ret)\r\ngoto out_free_bos;\r\nfor (i = 0; i < cmd->relocs_num; ++i) {\r\nif (reloc_info[i].type == QXL_RELOC_TYPE_BO)\r\napply_reloc(qdev, &reloc_info[i]);\r\nelse if (reloc_info[i].type == QXL_RELOC_TYPE_SURF)\r\napply_surf_reloc(qdev, &reloc_info[i]);\r\n}\r\nret = qxl_push_command_ring_release(qdev, release, cmd->type, true);\r\nif (ret)\r\nqxl_release_backoff_reserve_list(release);\r\nelse\r\nqxl_release_fence_buffer_objects(release);\r\nout_free_bos:\r\nfor (j = 0; j < num_relocs; j++) {\r\nif (reloc_info[j].dst_bo != cmd_bo)\r\ndrm_gem_object_unreference_unlocked(&reloc_info[j].dst_bo->gem_base);\r\nif (reloc_info[j].src_bo && reloc_info[j].src_bo != cmd_bo)\r\ndrm_gem_object_unreference_unlocked(&reloc_info[j].src_bo->gem_base);\r\n}\r\nout_free_release:\r\nif (ret)\r\nqxl_release_free(qdev, release);\r\nout_free_reloc:\r\nkfree(reloc_info);\r\nreturn ret;\r\n}\r\nstatic int qxl_execbuffer_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct qxl_device *qdev = dev->dev_private;\r\nstruct drm_qxl_execbuffer *execbuffer = data;\r\nstruct drm_qxl_command user_cmd;\r\nint cmd_num;\r\nint ret;\r\nfor (cmd_num = 0; cmd_num < execbuffer->commands_num; ++cmd_num) {\r\nstruct drm_qxl_command *commands =\r\n(struct drm_qxl_command *)(uintptr_t)execbuffer->commands;\r\nif (DRM_COPY_FROM_USER(&user_cmd, &commands[cmd_num],\r\nsizeof(user_cmd)))\r\nreturn -EFAULT;\r\nret = qxl_process_single_command(qdev, &user_cmd, file_priv);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qxl_update_area_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file)\r\n{\r\nstruct qxl_device *qdev = dev->dev_private;\r\nstruct drm_qxl_update_area *update_area = data;\r\nstruct qxl_rect area = {.left = update_area->left,\r\n.top = update_area->top,\r\n.right = update_area->right,\r\n.bottom = update_area->bottom};\r\nint ret;\r\nstruct drm_gem_object *gobj = NULL;\r\nstruct qxl_bo *qobj = NULL;\r\nif (update_area->left >= update_area->right ||\r\nupdate_area->top >= update_area->bottom)\r\nreturn -EINVAL;\r\ngobj = drm_gem_object_lookup(dev, file, update_area->handle);\r\nif (gobj == NULL)\r\nreturn -ENOENT;\r\nqobj = gem_to_qxl_bo(gobj);\r\nret = qxl_bo_reserve(qobj, false);\r\nif (ret)\r\ngoto out;\r\nif (!qobj->pin_count) {\r\nqxl_ttm_placement_from_domain(qobj, qobj->type, false);\r\nret = ttm_bo_validate(&qobj->tbo, &qobj->placement,\r\ntrue, false);\r\nif (unlikely(ret))\r\ngoto out;\r\n}\r\nret = qxl_bo_check_id(qdev, qobj);\r\nif (ret)\r\ngoto out2;\r\nif (!qobj->surface_id)\r\nDRM_ERROR("got update area for surface with no id %d\n", update_area->handle);\r\nret = qxl_io_update_area(qdev, qobj, &area);\r\nout2:\r\nqxl_bo_unreserve(qobj);\r\nout:\r\ndrm_gem_object_unreference_unlocked(gobj);\r\nreturn ret;\r\n}\r\nstatic int qxl_getparam_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct qxl_device *qdev = dev->dev_private;\r\nstruct drm_qxl_getparam *param = data;\r\nswitch (param->param) {\r\ncase QXL_PARAM_NUM_SURFACES:\r\nparam->value = qdev->rom->n_surfaces;\r\nbreak;\r\ncase QXL_PARAM_MAX_RELOCS:\r\nparam->value = QXL_MAX_RES;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qxl_clientcap_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file_priv)\r\n{\r\nstruct qxl_device *qdev = dev->dev_private;\r\nstruct drm_qxl_clientcap *param = data;\r\nint byte, idx;\r\nbyte = param->index / 8;\r\nidx = param->index % 8;\r\nif (qdev->pdev->revision < 4)\r\nreturn -ENOSYS;\r\nif (byte >= 58)\r\nreturn -ENOSYS;\r\nif (qdev->rom->client_capabilities[byte] & (1 << idx))\r\nreturn 0;\r\nreturn -ENOSYS;\r\n}\r\nstatic int qxl_alloc_surf_ioctl(struct drm_device *dev, void *data,\r\nstruct drm_file *file)\r\n{\r\nstruct qxl_device *qdev = dev->dev_private;\r\nstruct drm_qxl_alloc_surf *param = data;\r\nstruct qxl_bo *qobj;\r\nint handle;\r\nint ret;\r\nint size, actual_stride;\r\nstruct qxl_surface surf;\r\nactual_stride = param->stride < 0 ? -param->stride : param->stride;\r\nsize = actual_stride * param->height + actual_stride;\r\nsurf.format = param->format;\r\nsurf.width = param->width;\r\nsurf.height = param->height;\r\nsurf.stride = param->stride;\r\nsurf.data = 0;\r\nret = qxl_gem_object_create_with_handle(qdev, file,\r\nQXL_GEM_DOMAIN_SURFACE,\r\nsize,\r\n&surf,\r\n&qobj, &handle);\r\nif (ret) {\r\nDRM_ERROR("%s: failed to create gem ret=%d\n",\r\n__func__, ret);\r\nreturn -ENOMEM;\r\n} else\r\nparam->handle = handle;\r\nreturn ret;\r\n}
