static int tc3589x_keypad_init_key_hardware(struct tc_keypad *keypad)\r\n{\r\nint ret;\r\nstruct tc3589x *tc3589x = keypad->tc3589x;\r\nconst struct tc3589x_keypad_platform_data *board = keypad->board;\r\nif (board->kcol > TC3589x_MAX_KPCOL || board->krow > TC3589x_MAX_KPROW)\r\nreturn -EINVAL;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_KBDSIZE,\r\n(board->krow << KP_ROW_SHIFT) | board->kcol);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_KBCFG_LSB, DEDICATED_KEY_VAL);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_KBCFG_MSB, DEDICATED_KEY_VAL);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_KBDSETTLE_REG,\r\nboard->settle_time);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_KBDBOUNCE,\r\nboard->debounce_period);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_IOCFG, 0x0, IOCFG_IG);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_IOPULLCFG0_LSB,\r\nTC3589x_PULLUP_ALL_MASK);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_IOPULLCFG0_MSB,\r\nTC3589x_PULLUP_ALL_MASK);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_IOPULLCFG1_LSB,\r\nTC3589x_PULLUP_ALL_MASK);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_IOPULLCFG1_MSB,\r\nTC3589x_PULLUP_ALL_MASK);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_reg_write(tc3589x, TC3589x_IOPULLCFG2_LSB,\r\nTC3589x_PULLUP_ALL_MASK);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t tc3589x_keypad_irq(int irq, void *dev)\r\n{\r\nstruct tc_keypad *keypad = dev;\r\nstruct tc3589x *tc3589x = keypad->tc3589x;\r\nu8 i, row_index, col_index, kbd_code, up;\r\nu8 code;\r\nfor (i = 0; i < TC35893_DATA_REGS * 2; i++) {\r\nkbd_code = tc3589x_reg_read(tc3589x, TC3589x_EVTCODE_FIFO);\r\nif (kbd_code == TC35893_KEYCODE_FIFO_EMPTY ||\r\nkbd_code == TC35893_KEYCODE_FIFO_CLEAR)\r\ncontinue;\r\ncol_index = kbd_code & KP_EVCODE_COL_MASK;\r\nrow_index = (kbd_code & KP_EVCODE_ROW_MASK) >> KP_ROW_SHIFT;\r\ncode = MATRIX_SCAN_CODE(row_index, col_index,\r\nTC35893_KEYPAD_ROW_SHIFT);\r\nup = kbd_code & KP_RELEASE_EVT_MASK;\r\ninput_event(keypad->input, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(keypad->input, keypad->keymap[code], !up);\r\ninput_sync(keypad->input);\r\n}\r\ntc3589x_set_bits(tc3589x, TC3589x_KBDIC,\r\n0x0, TC3589x_EVT_INT_CLR | TC3589x_KBD_INT_CLR);\r\ntc3589x_set_bits(tc3589x, TC3589x_KBDMSK,\r\n0x0, TC3589x_EVT_LOSS_INT | TC3589x_EVT_INT);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tc3589x_keypad_enable(struct tc_keypad *keypad)\r\n{\r\nstruct tc3589x *tc3589x = keypad->tc3589x;\r\nint ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_RSTCTRL, TC3589x_KBDRST, 0x0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_KBDMFS, 0x0, TC3589x_KBDMFS_EN);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_CLKEN, 0x0, KPD_CLK_EN);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_RSTINTCLR, 0x0, 0x1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_KBDMSK, 0x0,\r\nTC3589x_EVT_LOSS_INT | TC3589x_EVT_INT);\r\nif (ret < 0)\r\nreturn ret;\r\nkeypad->keypad_stopped = false;\r\nreturn ret;\r\n}\r\nstatic int tc3589x_keypad_disable(struct tc_keypad *keypad)\r\n{\r\nstruct tc3589x *tc3589x = keypad->tc3589x;\r\nint ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_KBDIC,\r\n0x0, TC3589x_EVT_INT_CLR | TC3589x_KBD_INT_CLR);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_KBDMSK,\r\n~(TC3589x_EVT_LOSS_INT | TC3589x_EVT_INT), 0x0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_CLKEN, 0x1, 0x0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tc3589x_set_bits(tc3589x, TC3589x_RSTCTRL, TC3589x_KBDRST, 0x1);\r\nkeypad->keypad_stopped = true;\r\nreturn ret;\r\n}\r\nstatic int tc3589x_keypad_open(struct input_dev *input)\r\n{\r\nint error;\r\nstruct tc_keypad *keypad = input_get_drvdata(input);\r\nerror = tc3589x_keypad_enable(keypad);\r\nif (error < 0) {\r\ndev_err(&input->dev, "failed to enable keypad module\n");\r\nreturn error;\r\n}\r\nerror = tc3589x_keypad_init_key_hardware(keypad);\r\nif (error < 0) {\r\ndev_err(&input->dev, "failed to configure keypad module\n");\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tc3589x_keypad_close(struct input_dev *input)\r\n{\r\nstruct tc_keypad *keypad = input_get_drvdata(input);\r\ntc3589x_keypad_disable(keypad);\r\n}\r\nstatic int tc3589x_keypad_probe(struct platform_device *pdev)\r\n{\r\nstruct tc3589x *tc3589x = dev_get_drvdata(pdev->dev.parent);\r\nstruct tc_keypad *keypad;\r\nstruct input_dev *input;\r\nconst struct tc3589x_keypad_platform_data *plat;\r\nint error, irq;\r\nplat = tc3589x->pdata->keypad;\r\nif (!plat) {\r\ndev_err(&pdev->dev, "invalid keypad platform data\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nkeypad = kzalloc(sizeof(struct tc_keypad), GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!keypad || !input) {\r\ndev_err(&pdev->dev, "failed to allocate keypad memory\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nkeypad->board = plat;\r\nkeypad->input = input;\r\nkeypad->tc3589x = tc3589x;\r\ninput->id.bustype = BUS_I2C;\r\ninput->name = pdev->name;\r\ninput->dev.parent = &pdev->dev;\r\ninput->open = tc3589x_keypad_open;\r\ninput->close = tc3589x_keypad_close;\r\nerror = matrix_keypad_build_keymap(plat->keymap_data, NULL,\r\nTC3589x_MAX_KPROW, TC3589x_MAX_KPCOL,\r\nNULL, input);\r\nif (error) {\r\ndev_err(&pdev->dev, "Failed to build keymap\n");\r\ngoto err_free_mem;\r\n}\r\nkeypad->keymap = input->keycode;\r\ninput_set_capability(input, EV_MSC, MSC_SCAN);\r\nif (!plat->no_autorepeat)\r\n__set_bit(EV_REP, input->evbit);\r\ninput_set_drvdata(input, keypad);\r\nerror = request_threaded_irq(irq, NULL,\r\ntc3589x_keypad_irq, plat->irqtype,\r\n"tc3589x-keypad", keypad);\r\nif (error < 0) {\r\ndev_err(&pdev->dev,\r\n"Could not allocate irq %d,error %d\n",\r\nirq, error);\r\ngoto err_free_mem;\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(&pdev->dev, "Could not register input device\n");\r\ngoto err_free_irq;\r\n}\r\ndevice_init_wakeup(&pdev->dev, plat->enable_wakeup);\r\ndevice_set_wakeup_capable(&pdev->dev, plat->enable_wakeup);\r\nplatform_set_drvdata(pdev, keypad);\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(irq, keypad);\r\nerr_free_mem:\r\ninput_free_device(input);\r\nkfree(keypad);\r\nreturn error;\r\n}\r\nstatic int tc3589x_keypad_remove(struct platform_device *pdev)\r\n{\r\nstruct tc_keypad *keypad = platform_get_drvdata(pdev);\r\nint irq = platform_get_irq(pdev, 0);\r\nif (!keypad->keypad_stopped)\r\ntc3589x_keypad_disable(keypad);\r\nfree_irq(irq, keypad);\r\ninput_unregister_device(keypad->input);\r\nkfree(keypad);\r\nreturn 0;\r\n}\r\nstatic int tc3589x_keypad_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct tc_keypad *keypad = platform_get_drvdata(pdev);\r\nint irq = platform_get_irq(pdev, 0);\r\nif (keypad->keypad_stopped)\r\nreturn 0;\r\nif (!device_may_wakeup(&pdev->dev))\r\ntc3589x_keypad_disable(keypad);\r\nelse\r\nenable_irq_wake(irq);\r\nreturn 0;\r\n}\r\nstatic int tc3589x_keypad_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct tc_keypad *keypad = platform_get_drvdata(pdev);\r\nint irq = platform_get_irq(pdev, 0);\r\nif (!keypad->keypad_stopped)\r\nreturn 0;\r\nif (!device_may_wakeup(&pdev->dev))\r\ntc3589x_keypad_enable(keypad);\r\nelse\r\ndisable_irq_wake(irq);\r\nreturn 0;\r\n}
