static unsigned int meta_intc_offset(irq_hw_number_t hw)\r\n{\r\nreturn hw & 0x1f;\r\n}\r\nstatic unsigned int meta_intc_bank(irq_hw_number_t hw)\r\n{\r\nreturn hw >> 5;\r\n}\r\nstatic void __iomem *meta_intc_stat_addr(irq_hw_number_t hw)\r\n{\r\nreturn (void __iomem *)(HWSTATEXT +\r\nHWSTAT_STRIDE * meta_intc_bank(hw));\r\n}\r\nstatic void __iomem *meta_intc_level_addr(irq_hw_number_t hw)\r\n{\r\nreturn (void __iomem *)(HWLEVELEXT +\r\nHWSTAT_STRIDE * meta_intc_bank(hw));\r\n}\r\nstatic void __iomem *meta_intc_mask_addr(irq_hw_number_t hw)\r\n{\r\nreturn (void __iomem *)(HWMASKEXT +\r\nHWSTAT_STRIDE * meta_intc_bank(hw));\r\n}\r\nstatic inline void __iomem *meta_intc_vec_addr(irq_hw_number_t hw)\r\n{\r\nreturn (void __iomem *)(HWVEC0EXT +\r\nHWVEC_BLK_STRIDE * meta_intc_bank(hw) +\r\nHWVECnEXT_STRIDE * meta_intc_offset(hw));\r\n}\r\nstatic unsigned int meta_intc_startup_irq(struct irq_data *data)\r\n{\r\nirq_hw_number_t hw = data->hwirq;\r\nvoid __iomem *vec_addr = meta_intc_vec_addr(hw);\r\nint thread = hard_processor_id();\r\nif (data->chip->irq_ack)\r\ndata->chip->irq_ack(data);\r\nmetag_out32(TBI_TRIG_VEC(TBID_SIGNUM_TR2(thread)), vec_addr);\r\ndata->chip->irq_unmask(data);\r\nreturn 0;\r\n}\r\nstatic void meta_intc_shutdown_irq(struct irq_data *data)\r\n{\r\nirq_hw_number_t hw = data->hwirq;\r\nvoid __iomem *vec_addr = meta_intc_vec_addr(hw);\r\ndata->chip->irq_mask(data);\r\nmetag_out32(0, vec_addr);\r\n}\r\nstatic void meta_intc_ack_irq(struct irq_data *data)\r\n{\r\nirq_hw_number_t hw = data->hwirq;\r\nunsigned int bit = 1 << meta_intc_offset(hw);\r\nvoid __iomem *stat_addr = meta_intc_stat_addr(hw);\r\nif (metag_in32(stat_addr) & bit)\r\nmetag_out32(bit, stat_addr);\r\n}\r\nstatic void record_irq_is_masked(struct irq_data *data)\r\n{\r\nstruct meta_intc_priv *priv = &meta_intc_priv;\r\nirq_hw_number_t hw = data->hwirq;\r\nclear_bit(meta_intc_offset(hw), &priv->unmasked[meta_intc_bank(hw)]);\r\n}\r\nstatic void record_irq_is_unmasked(struct irq_data *data)\r\n{\r\nstruct meta_intc_priv *priv = &meta_intc_priv;\r\nirq_hw_number_t hw = data->hwirq;\r\nset_bit(meta_intc_offset(hw), &priv->unmasked[meta_intc_bank(hw)]);\r\n}\r\nvoid meta_intc_mask_irq_simple(struct irq_data *data)\r\n{\r\nrecord_irq_is_masked(data);\r\n}\r\nvoid meta_intc_unmask_irq_simple(struct irq_data *data)\r\n{\r\nrecord_irq_is_unmasked(data);\r\n}\r\nstatic void meta_intc_mask_irq(struct irq_data *data)\r\n{\r\nirq_hw_number_t hw = data->hwirq;\r\nunsigned int bit = 1 << meta_intc_offset(hw);\r\nvoid __iomem *mask_addr = meta_intc_mask_addr(hw);\r\nunsigned long flags;\r\nrecord_irq_is_masked(data);\r\n__global_lock2(flags);\r\nmetag_out32(metag_in32(mask_addr) & ~bit, mask_addr);\r\n__global_unlock2(flags);\r\n}\r\nstatic void meta_intc_unmask_irq(struct irq_data *data)\r\n{\r\nirq_hw_number_t hw = data->hwirq;\r\nunsigned int bit = 1 << meta_intc_offset(hw);\r\nvoid __iomem *mask_addr = meta_intc_mask_addr(hw);\r\nunsigned long flags;\r\nrecord_irq_is_unmasked(data);\r\n__global_lock2(flags);\r\nmetag_out32(metag_in32(mask_addr) | bit, mask_addr);\r\n__global_unlock2(flags);\r\n}\r\nstatic void meta_intc_mask_irq_nomask(struct irq_data *data)\r\n{\r\nirq_hw_number_t hw = data->hwirq;\r\nvoid __iomem *vec_addr = meta_intc_vec_addr(hw);\r\nrecord_irq_is_masked(data);\r\nmetag_out32(0, vec_addr);\r\n}\r\nstatic void meta_intc_unmask_edge_irq_nomask(struct irq_data *data)\r\n{\r\nirq_hw_number_t hw = data->hwirq;\r\nunsigned int bit = 1 << meta_intc_offset(hw);\r\nvoid __iomem *stat_addr = meta_intc_stat_addr(hw);\r\nvoid __iomem *vec_addr = meta_intc_vec_addr(hw);\r\nunsigned int thread = hard_processor_id();\r\nrecord_irq_is_unmasked(data);\r\nmetag_out32(TBI_TRIG_VEC(TBID_SIGNUM_TR2(thread)), vec_addr);\r\nif (metag_in32(stat_addr) & bit) {\r\nmetag_out32(bit, stat_addr);\r\nwhile (!(metag_in32(stat_addr) & bit))\r\nmetag_out32(bit, stat_addr);\r\n}\r\n}\r\nstatic void meta_intc_unmask_level_irq_nomask(struct irq_data *data)\r\n{\r\nirq_hw_number_t hw = data->hwirq;\r\nunsigned int bit = 1 << meta_intc_offset(hw);\r\nvoid __iomem *stat_addr = meta_intc_stat_addr(hw);\r\nvoid __iomem *vec_addr = meta_intc_vec_addr(hw);\r\nunsigned int thread = hard_processor_id();\r\nrecord_irq_is_unmasked(data);\r\nmetag_out32(TBI_TRIG_VEC(TBID_SIGNUM_TR2(thread)), vec_addr);\r\nif (metag_in32(stat_addr) & bit)\r\nmetag_out32(bit, stat_addr);\r\n}\r\nstatic int meta_intc_irq_set_type(struct irq_data *data, unsigned int flow_type)\r\n{\r\n#ifdef CONFIG_METAG_SUSPEND_MEM\r\nstruct meta_intc_priv *priv = &meta_intc_priv;\r\n#endif\r\nunsigned int irq = data->irq;\r\nirq_hw_number_t hw = data->hwirq;\r\nunsigned int bit = 1 << meta_intc_offset(hw);\r\nvoid __iomem *level_addr = meta_intc_level_addr(hw);\r\nunsigned long flags;\r\nunsigned int level;\r\nif (flow_type & IRQ_TYPE_LEVEL_MASK)\r\n__irq_set_chip_handler_name_locked(irq, &meta_intc_level_chip,\r\nhandle_level_irq, NULL);\r\nelse\r\n__irq_set_chip_handler_name_locked(irq, &meta_intc_edge_chip,\r\nhandle_edge_irq, NULL);\r\n__global_lock2(flags);\r\nlevel = metag_in32(level_addr);\r\nif (flow_type & IRQ_TYPE_LEVEL_MASK)\r\nlevel |= bit;\r\nelse\r\nlevel &= ~bit;\r\nmetag_out32(level, level_addr);\r\n#ifdef CONFIG_METAG_SUSPEND_MEM\r\npriv->levels_altered[meta_intc_bank(hw)] |= bit;\r\n#endif\r\n__global_unlock2(flags);\r\nreturn 0;\r\n}\r\nstatic void meta_intc_irq_demux(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct meta_intc_priv *priv = &meta_intc_priv;\r\nirq_hw_number_t hw;\r\nunsigned int bank, irq_no, status;\r\nvoid __iomem *stat_addr = meta_intc_stat_addr(0);\r\nfor (bank = 0; bank < priv->nr_banks; ++bank) {\r\nrecalculate:\r\nstatus = metag_in32(stat_addr) & priv->unmasked[bank];\r\nfor (hw = bank*32; status; status >>= 1, ++hw) {\r\nif (status & 0x1) {\r\nirq_no = irq_linear_revmap(priv->domain, hw);\r\ngeneric_handle_irq(irq_no);\r\ngoto recalculate;\r\n}\r\n}\r\nstat_addr += HWSTAT_STRIDE;\r\n}\r\n}\r\nstatic int meta_intc_set_affinity(struct irq_data *data,\r\nconst struct cpumask *cpumask, bool force)\r\n{\r\nirq_hw_number_t hw = data->hwirq;\r\nvoid __iomem *vec_addr = meta_intc_vec_addr(hw);\r\nunsigned int cpu, thread;\r\ncpu = cpumask_any(cpumask);\r\nthread = cpu_2_hwthread_id[cpu];\r\nmetag_out32(TBI_TRIG_VEC(TBID_SIGNUM_TR2(thread)), vec_addr);\r\nreturn 0;\r\n}\r\nstatic int meta_intc_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hw)\r\n{\r\nunsigned int bit = 1 << meta_intc_offset(hw);\r\nvoid __iomem *level_addr = meta_intc_level_addr(hw);\r\nif (metag_in32(level_addr) & bit)\r\nirq_set_chip_and_handler(irq, &meta_intc_level_chip,\r\nhandle_level_irq);\r\nelse\r\nirq_set_chip_and_handler(irq, &meta_intc_edge_chip,\r\nhandle_edge_irq);\r\nreturn 0;\r\n}\r\nstatic int meta_intc_suspend(void)\r\n{\r\nstruct meta_intc_priv *priv = &meta_intc_priv;\r\nint i, j;\r\nirq_hw_number_t hw;\r\nunsigned int bank;\r\nunsigned long flags;\r\nstruct meta_intc_context *context;\r\nvoid __iomem *level_addr, *mask_addr, *vec_addr;\r\nu32 mask, bit;\r\ncontext = kzalloc(sizeof(*context), GFP_ATOMIC);\r\nif (!context)\r\nreturn -ENOMEM;\r\nhw = 0;\r\nlevel_addr = meta_intc_level_addr(0);\r\nmask_addr = meta_intc_mask_addr(0);\r\nfor (bank = 0; bank < priv->nr_banks; ++bank) {\r\nvec_addr = meta_intc_vec_addr(hw);\r\nmask = 0;\r\nfor (bit = 1; bit; bit <<= 1) {\r\ni = irq_linear_revmap(priv->domain, hw);\r\nif (i && (!irqd_irq_disabled(irq_get_irq_data(i)) ||\r\nirq_has_action(i))) {\r\nmask |= bit;\r\ncontext->vectors[hw] = metag_in32(vec_addr);\r\n}\r\n++hw;\r\nvec_addr += HWVECnEXT_STRIDE;\r\n}\r\nif (priv->levels_altered[bank])\r\ncontext->levels[bank] = metag_in32(level_addr);\r\nif (mask)\r\ncontext->masks[bank] = metag_in32(mask_addr);\r\nlevel_addr += HWSTAT_STRIDE;\r\nmask_addr += HWSTAT_STRIDE;\r\n}\r\n__global_lock2(flags);\r\nfor (i = 0; i < 4; ++i)\r\nfor (j = 0; j < 4; ++j)\r\ncontext->txvecint[i][j] = metag_in32(T0VECINT_BHALT +\r\nTnVECINT_STRIDE*i +\r\n8*j);\r\n__global_unlock2(flags);\r\nmeta_intc_context = context;\r\nreturn 0;\r\n}\r\nstatic void meta_intc_resume(void)\r\n{\r\nstruct meta_intc_priv *priv = &meta_intc_priv;\r\nint i, j;\r\nirq_hw_number_t hw;\r\nunsigned int bank;\r\nunsigned long flags;\r\nstruct meta_intc_context *context = meta_intc_context;\r\nvoid __iomem *level_addr, *mask_addr, *vec_addr;\r\nu32 mask, bit, tmp;\r\nmeta_intc_context = NULL;\r\nhw = 0;\r\nlevel_addr = meta_intc_level_addr(0);\r\nmask_addr = meta_intc_mask_addr(0);\r\nfor (bank = 0; bank < priv->nr_banks; ++bank) {\r\nvec_addr = meta_intc_vec_addr(hw);\r\nmask = 0;\r\nfor (bit = 1; bit; bit <<= 1) {\r\ni = irq_linear_revmap(priv->domain, hw);\r\nif (i && (!irqd_irq_disabled(irq_get_irq_data(i)) ||\r\nirq_has_action(i))) {\r\nmask |= bit;\r\nmetag_out32(context->vectors[hw], vec_addr);\r\n}\r\n++hw;\r\nvec_addr += HWVECnEXT_STRIDE;\r\n}\r\nif (mask) {\r\n__global_lock2(flags);\r\ntmp = metag_in32(mask_addr);\r\ntmp = (tmp & ~mask) | (context->masks[bank] & mask);\r\nmetag_out32(tmp, mask_addr);\r\n__global_unlock2(flags);\r\n}\r\nmask = priv->levels_altered[bank];\r\nif (mask) {\r\n__global_lock2(flags);\r\ntmp = metag_in32(level_addr);\r\ntmp = (tmp & ~mask) | (context->levels[bank] & mask);\r\nmetag_out32(tmp, level_addr);\r\n__global_unlock2(flags);\r\n}\r\nlevel_addr += HWSTAT_STRIDE;\r\nmask_addr += HWSTAT_STRIDE;\r\n}\r\n__global_lock2(flags);\r\nfor (i = 0; i < 4; ++i) {\r\nfor (j = 0; j < 4; ++j) {\r\nmetag_out32(context->txvecint[i][j],\r\nT0VECINT_BHALT +\r\nTnVECINT_STRIDE*i +\r\n8*j);\r\n}\r\n}\r\n__global_unlock2(flags);\r\nkfree(context);\r\n}\r\nstatic void __init meta_intc_init_syscore_ops(struct meta_intc_priv *priv)\r\n{\r\nregister_syscore_ops(&meta_intc_syscore_ops);\r\n}\r\nstatic void __init meta_intc_init_cpu(struct meta_intc_priv *priv, int cpu)\r\n{\r\nunsigned int thread = cpu_2_hwthread_id[cpu];\r\nunsigned int signum = TBID_SIGNUM_TR2(thread);\r\nint irq = tbisig_map(signum);\r\nirq_set_chained_handler(irq, meta_intc_irq_demux);\r\nirq_set_irq_type(irq, IRQ_TYPE_LEVEL_LOW);\r\n}\r\nvoid __init meta_intc_no_mask(void)\r\n{\r\nmeta_intc_edge_chip.irq_mask = meta_intc_mask_irq_nomask;\r\nmeta_intc_edge_chip.irq_unmask = meta_intc_unmask_edge_irq_nomask;\r\nmeta_intc_level_chip.irq_mask = meta_intc_mask_irq_nomask;\r\nmeta_intc_level_chip.irq_unmask = meta_intc_unmask_level_irq_nomask;\r\n}\r\nint __init init_external_IRQ(void)\r\n{\r\nstruct meta_intc_priv *priv = &meta_intc_priv;\r\nstruct device_node *node;\r\nint ret, cpu;\r\nu32 val;\r\nbool no_masks = false;\r\nnode = of_find_compatible_node(NULL, NULL, "img,meta-intc");\r\nif (!node)\r\nreturn -ENOENT;\r\nret = of_property_read_u32(node, "num-banks", &val);\r\nif (ret) {\r\npr_err("meta-intc: No num-banks property found\n");\r\nreturn ret;\r\n}\r\nif (val < 1 || val > 4) {\r\npr_err("meta-intc: num-banks (%u) out of range\n", val);\r\nreturn -EINVAL;\r\n}\r\npriv->nr_banks = val;\r\nif (of_get_property(node, "no-mask", NULL))\r\nno_masks = true;\r\nif (no_masks)\r\nmeta_intc_no_mask();\r\npriv->domain = irq_domain_add_linear(node, priv->nr_banks*32,\r\n&meta_intc_domain_ops, priv);\r\nif (unlikely(!priv->domain)) {\r\npr_err("meta-intc: cannot add IRQ domain\n");\r\nreturn -ENOMEM;\r\n}\r\nfor_each_possible_cpu(cpu)\r\nmeta_intc_init_cpu(priv, cpu);\r\nmeta_intc_init_syscore_ops(priv);\r\npr_info("meta-intc: External IRQ controller initialised (%u IRQs)\n",\r\npriv->nr_banks*32);\r\nreturn 0;\r\n}
