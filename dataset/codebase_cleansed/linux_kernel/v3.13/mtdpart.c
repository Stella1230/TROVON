static int part_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u_char *buf)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nstruct mtd_ecc_stats stats;\r\nint res;\r\nstats = part->master->ecc_stats;\r\nres = part->master->_read(part->master, from + part->offset, len,\r\nretlen, buf);\r\nif (unlikely(mtd_is_eccerr(res)))\r\nmtd->ecc_stats.failed +=\r\npart->master->ecc_stats.failed - stats.failed;\r\nelse\r\nmtd->ecc_stats.corrected +=\r\npart->master->ecc_stats.corrected - stats.corrected;\r\nreturn res;\r\n}\r\nstatic int part_point(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, void **virt, resource_size_t *phys)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nreturn part->master->_point(part->master, from + part->offset, len,\r\nretlen, virt, phys);\r\n}\r\nstatic int part_unpoint(struct mtd_info *mtd, loff_t from, size_t len)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nreturn part->master->_unpoint(part->master, from + part->offset, len);\r\n}\r\nstatic unsigned long part_get_unmapped_area(struct mtd_info *mtd,\r\nunsigned long len,\r\nunsigned long offset,\r\nunsigned long flags)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\noffset += part->offset;\r\nreturn part->master->_get_unmapped_area(part->master, len, offset,\r\nflags);\r\n}\r\nstatic int part_read_oob(struct mtd_info *mtd, loff_t from,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nint res;\r\nif (from >= mtd->size)\r\nreturn -EINVAL;\r\nif (ops->datbuf && from + ops->len > mtd->size)\r\nreturn -EINVAL;\r\nif (ops->oobbuf) {\r\nsize_t len, pages;\r\nif (ops->mode == MTD_OPS_AUTO_OOB)\r\nlen = mtd->oobavail;\r\nelse\r\nlen = mtd->oobsize;\r\npages = mtd_div_by_ws(mtd->size, mtd);\r\npages -= mtd_div_by_ws(from, mtd);\r\nif (ops->ooboffs + ops->ooblen > pages * len)\r\nreturn -EINVAL;\r\n}\r\nres = part->master->_read_oob(part->master, from + part->offset, ops);\r\nif (unlikely(res)) {\r\nif (mtd_is_bitflip(res))\r\nmtd->ecc_stats.corrected++;\r\nif (mtd_is_eccerr(res))\r\nmtd->ecc_stats.failed++;\r\n}\r\nreturn res;\r\n}\r\nstatic int part_read_user_prot_reg(struct mtd_info *mtd, loff_t from,\r\nsize_t len, size_t *retlen, u_char *buf)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nreturn part->master->_read_user_prot_reg(part->master, from, len,\r\nretlen, buf);\r\n}\r\nstatic int part_get_user_prot_info(struct mtd_info *mtd,\r\nstruct otp_info *buf, size_t len)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nreturn part->master->_get_user_prot_info(part->master, buf, len);\r\n}\r\nstatic int part_read_fact_prot_reg(struct mtd_info *mtd, loff_t from,\r\nsize_t len, size_t *retlen, u_char *buf)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nreturn part->master->_read_fact_prot_reg(part->master, from, len,\r\nretlen, buf);\r\n}\r\nstatic int part_get_fact_prot_info(struct mtd_info *mtd, struct otp_info *buf,\r\nsize_t len)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nreturn part->master->_get_fact_prot_info(part->master, buf, len);\r\n}\r\nstatic int part_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nreturn part->master->_write(part->master, to + part->offset, len,\r\nretlen, buf);\r\n}\r\nstatic int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u_char *buf)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nreturn part->master->_panic_write(part->master, to + part->offset, len,\r\nretlen, buf);\r\n}\r\nstatic int part_write_oob(struct mtd_info *mtd, loff_t to,\r\nstruct mtd_oob_ops *ops)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nif (to >= mtd->size)\r\nreturn -EINVAL;\r\nif (ops->datbuf && to + ops->len > mtd->size)\r\nreturn -EINVAL;\r\nreturn part->master->_write_oob(part->master, to + part->offset, ops);\r\n}\r\nstatic int part_write_user_prot_reg(struct mtd_info *mtd, loff_t from,\r\nsize_t len, size_t *retlen, u_char *buf)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nreturn part->master->_write_user_prot_reg(part->master, from, len,\r\nretlen, buf);\r\n}\r\nstatic int part_lock_user_prot_reg(struct mtd_info *mtd, loff_t from,\r\nsize_t len)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nreturn part->master->_lock_user_prot_reg(part->master, from, len);\r\n}\r\nstatic int part_writev(struct mtd_info *mtd, const struct kvec *vecs,\r\nunsigned long count, loff_t to, size_t *retlen)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nreturn part->master->_writev(part->master, vecs, count,\r\nto + part->offset, retlen);\r\n}\r\nstatic int part_erase(struct mtd_info *mtd, struct erase_info *instr)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nint ret;\r\ninstr->addr += part->offset;\r\nret = part->master->_erase(part->master, instr);\r\nif (ret) {\r\nif (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)\r\ninstr->fail_addr -= part->offset;\r\ninstr->addr -= part->offset;\r\n}\r\nreturn ret;\r\n}\r\nvoid mtd_erase_callback(struct erase_info *instr)\r\n{\r\nif (instr->mtd->_erase == part_erase) {\r\nstruct mtd_part *part = PART(instr->mtd);\r\nif (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)\r\ninstr->fail_addr -= part->offset;\r\ninstr->addr -= part->offset;\r\n}\r\nif (instr->callback)\r\ninstr->callback(instr);\r\n}\r\nstatic int part_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nreturn part->master->_lock(part->master, ofs + part->offset, len);\r\n}\r\nstatic int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nreturn part->master->_unlock(part->master, ofs + part->offset, len);\r\n}\r\nstatic int part_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nreturn part->master->_is_locked(part->master, ofs + part->offset, len);\r\n}\r\nstatic void part_sync(struct mtd_info *mtd)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\npart->master->_sync(part->master);\r\n}\r\nstatic int part_suspend(struct mtd_info *mtd)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nreturn part->master->_suspend(part->master);\r\n}\r\nstatic void part_resume(struct mtd_info *mtd)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\npart->master->_resume(part->master);\r\n}\r\nstatic int part_block_isbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nofs += part->offset;\r\nreturn part->master->_block_isbad(part->master, ofs);\r\n}\r\nstatic int part_block_markbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nstruct mtd_part *part = PART(mtd);\r\nint res;\r\nofs += part->offset;\r\nres = part->master->_block_markbad(part->master, ofs);\r\nif (!res)\r\nmtd->ecc_stats.badblocks++;\r\nreturn res;\r\n}\r\nstatic inline void free_partition(struct mtd_part *p)\r\n{\r\nkfree(p->mtd.name);\r\nkfree(p);\r\n}\r\nint del_mtd_partitions(struct mtd_info *master)\r\n{\r\nstruct mtd_part *slave, *next;\r\nint ret, err = 0;\r\nmutex_lock(&mtd_partitions_mutex);\r\nlist_for_each_entry_safe(slave, next, &mtd_partitions, list)\r\nif (slave->master == master) {\r\nret = del_mtd_device(&slave->mtd);\r\nif (ret < 0) {\r\nerr = ret;\r\ncontinue;\r\n}\r\nlist_del(&slave->list);\r\nfree_partition(slave);\r\n}\r\nmutex_unlock(&mtd_partitions_mutex);\r\nreturn err;\r\n}\r\nstatic struct mtd_part *allocate_partition(struct mtd_info *master,\r\nconst struct mtd_partition *part, int partno,\r\nuint64_t cur_offset)\r\n{\r\nstruct mtd_part *slave;\r\nchar *name;\r\nslave = kzalloc(sizeof(*slave), GFP_KERNEL);\r\nname = kstrdup(part->name, GFP_KERNEL);\r\nif (!name || !slave) {\r\nprintk(KERN_ERR"memory allocation error while creating partitions for \"%s\"\n",\r\nmaster->name);\r\nkfree(name);\r\nkfree(slave);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nslave->mtd.type = master->type;\r\nslave->mtd.flags = master->flags & ~part->mask_flags;\r\nslave->mtd.size = part->size;\r\nslave->mtd.writesize = master->writesize;\r\nslave->mtd.writebufsize = master->writebufsize;\r\nslave->mtd.oobsize = master->oobsize;\r\nslave->mtd.oobavail = master->oobavail;\r\nslave->mtd.subpage_sft = master->subpage_sft;\r\nslave->mtd.name = name;\r\nslave->mtd.owner = master->owner;\r\nslave->mtd.backing_dev_info = master->backing_dev_info;\r\nslave->mtd.dev.parent = master->dev.parent;\r\nslave->mtd._read = part_read;\r\nslave->mtd._write = part_write;\r\nif (master->_panic_write)\r\nslave->mtd._panic_write = part_panic_write;\r\nif (master->_point && master->_unpoint) {\r\nslave->mtd._point = part_point;\r\nslave->mtd._unpoint = part_unpoint;\r\n}\r\nif (master->_get_unmapped_area)\r\nslave->mtd._get_unmapped_area = part_get_unmapped_area;\r\nif (master->_read_oob)\r\nslave->mtd._read_oob = part_read_oob;\r\nif (master->_write_oob)\r\nslave->mtd._write_oob = part_write_oob;\r\nif (master->_read_user_prot_reg)\r\nslave->mtd._read_user_prot_reg = part_read_user_prot_reg;\r\nif (master->_read_fact_prot_reg)\r\nslave->mtd._read_fact_prot_reg = part_read_fact_prot_reg;\r\nif (master->_write_user_prot_reg)\r\nslave->mtd._write_user_prot_reg = part_write_user_prot_reg;\r\nif (master->_lock_user_prot_reg)\r\nslave->mtd._lock_user_prot_reg = part_lock_user_prot_reg;\r\nif (master->_get_user_prot_info)\r\nslave->mtd._get_user_prot_info = part_get_user_prot_info;\r\nif (master->_get_fact_prot_info)\r\nslave->mtd._get_fact_prot_info = part_get_fact_prot_info;\r\nif (master->_sync)\r\nslave->mtd._sync = part_sync;\r\nif (!partno && !master->dev.class && master->_suspend &&\r\nmaster->_resume) {\r\nslave->mtd._suspend = part_suspend;\r\nslave->mtd._resume = part_resume;\r\n}\r\nif (master->_writev)\r\nslave->mtd._writev = part_writev;\r\nif (master->_lock)\r\nslave->mtd._lock = part_lock;\r\nif (master->_unlock)\r\nslave->mtd._unlock = part_unlock;\r\nif (master->_is_locked)\r\nslave->mtd._is_locked = part_is_locked;\r\nif (master->_block_isbad)\r\nslave->mtd._block_isbad = part_block_isbad;\r\nif (master->_block_markbad)\r\nslave->mtd._block_markbad = part_block_markbad;\r\nslave->mtd._erase = part_erase;\r\nslave->master = master;\r\nslave->offset = part->offset;\r\nif (slave->offset == MTDPART_OFS_APPEND)\r\nslave->offset = cur_offset;\r\nif (slave->offset == MTDPART_OFS_NXTBLK) {\r\nslave->offset = cur_offset;\r\nif (mtd_mod_by_eb(cur_offset, master) != 0) {\r\nslave->offset = (mtd_div_by_eb(cur_offset, master) + 1) * master->erasesize;\r\nprintk(KERN_NOTICE "Moving partition %d: "\r\n"0x%012llx -> 0x%012llx\n", partno,\r\n(unsigned long long)cur_offset, (unsigned long long)slave->offset);\r\n}\r\n}\r\nif (slave->offset == MTDPART_OFS_RETAIN) {\r\nslave->offset = cur_offset;\r\nif (master->size - slave->offset >= slave->mtd.size) {\r\nslave->mtd.size = master->size - slave->offset\r\n- slave->mtd.size;\r\n} else {\r\nprintk(KERN_ERR "mtd partition \"%s\" doesn't have enough space: %#llx < %#llx, disabled\n",\r\npart->name, master->size - slave->offset,\r\nslave->mtd.size);\r\ngoto out_register;\r\n}\r\n}\r\nif (slave->mtd.size == MTDPART_SIZ_FULL)\r\nslave->mtd.size = master->size - slave->offset;\r\nprintk(KERN_NOTICE "0x%012llx-0x%012llx : \"%s\"\n", (unsigned long long)slave->offset,\r\n(unsigned long long)(slave->offset + slave->mtd.size), slave->mtd.name);\r\nif (slave->offset >= master->size) {\r\nslave->offset = 0;\r\nslave->mtd.size = 0;\r\nprintk(KERN_ERR"mtd: partition \"%s\" is out of reach -- disabled\n",\r\npart->name);\r\ngoto out_register;\r\n}\r\nif (slave->offset + slave->mtd.size > master->size) {\r\nslave->mtd.size = master->size - slave->offset;\r\nprintk(KERN_WARNING"mtd: partition \"%s\" extends beyond the end of device \"%s\" -- size truncated to %#llx\n",\r\npart->name, master->name, (unsigned long long)slave->mtd.size);\r\n}\r\nif (master->numeraseregions > 1) {\r\nint i, max = master->numeraseregions;\r\nu64 end = slave->offset + slave->mtd.size;\r\nstruct mtd_erase_region_info *regions = master->eraseregions;\r\nfor (i = 0; i < max && regions[i].offset <= slave->offset; i++)\r\n;\r\nif (i > 0)\r\ni--;\r\nfor (; i < max && regions[i].offset < end; i++) {\r\nif (slave->mtd.erasesize < regions[i].erasesize) {\r\nslave->mtd.erasesize = regions[i].erasesize;\r\n}\r\n}\r\nBUG_ON(slave->mtd.erasesize == 0);\r\n} else {\r\nslave->mtd.erasesize = master->erasesize;\r\n}\r\nif ((slave->mtd.flags & MTD_WRITEABLE) &&\r\nmtd_mod_by_eb(slave->offset, &slave->mtd)) {\r\nslave->mtd.flags &= ~MTD_WRITEABLE;\r\nprintk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",\r\npart->name);\r\n}\r\nif ((slave->mtd.flags & MTD_WRITEABLE) &&\r\nmtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {\r\nslave->mtd.flags &= ~MTD_WRITEABLE;\r\nprintk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",\r\npart->name);\r\n}\r\nslave->mtd.ecclayout = master->ecclayout;\r\nslave->mtd.ecc_step_size = master->ecc_step_size;\r\nslave->mtd.ecc_strength = master->ecc_strength;\r\nslave->mtd.bitflip_threshold = master->bitflip_threshold;\r\nif (master->_block_isbad) {\r\nuint64_t offs = 0;\r\nwhile (offs < slave->mtd.size) {\r\nif (mtd_block_isbad(master, offs + slave->offset))\r\nslave->mtd.ecc_stats.badblocks++;\r\noffs += slave->mtd.erasesize;\r\n}\r\n}\r\nout_register:\r\nreturn slave;\r\n}\r\nint mtd_add_partition(struct mtd_info *master, char *name,\r\nlong long offset, long long length)\r\n{\r\nstruct mtd_partition part;\r\nstruct mtd_part *p, *new;\r\nuint64_t start, end;\r\nint ret = 0;\r\nif (offset == MTDPART_OFS_APPEND ||\r\noffset == MTDPART_OFS_NXTBLK)\r\nreturn -EINVAL;\r\nif (length == MTDPART_SIZ_FULL)\r\nlength = master->size - offset;\r\nif (length <= 0)\r\nreturn -EINVAL;\r\npart.name = name;\r\npart.size = length;\r\npart.offset = offset;\r\npart.mask_flags = 0;\r\npart.ecclayout = NULL;\r\nnew = allocate_partition(master, &part, -1, offset);\r\nif (IS_ERR(new))\r\nreturn PTR_ERR(new);\r\nstart = offset;\r\nend = offset + length;\r\nmutex_lock(&mtd_partitions_mutex);\r\nlist_for_each_entry(p, &mtd_partitions, list)\r\nif (p->master == master) {\r\nif ((start >= p->offset) &&\r\n(start < (p->offset + p->mtd.size)))\r\ngoto err_inv;\r\nif ((end >= p->offset) &&\r\n(end < (p->offset + p->mtd.size)))\r\ngoto err_inv;\r\n}\r\nlist_add(&new->list, &mtd_partitions);\r\nmutex_unlock(&mtd_partitions_mutex);\r\nadd_mtd_device(&new->mtd);\r\nreturn ret;\r\nerr_inv:\r\nmutex_unlock(&mtd_partitions_mutex);\r\nfree_partition(new);\r\nreturn -EINVAL;\r\n}\r\nint mtd_del_partition(struct mtd_info *master, int partno)\r\n{\r\nstruct mtd_part *slave, *next;\r\nint ret = -EINVAL;\r\nmutex_lock(&mtd_partitions_mutex);\r\nlist_for_each_entry_safe(slave, next, &mtd_partitions, list)\r\nif ((slave->master == master) &&\r\n(slave->mtd.index == partno)) {\r\nret = del_mtd_device(&slave->mtd);\r\nif (ret < 0)\r\nbreak;\r\nlist_del(&slave->list);\r\nfree_partition(slave);\r\nbreak;\r\n}\r\nmutex_unlock(&mtd_partitions_mutex);\r\nreturn ret;\r\n}\r\nint add_mtd_partitions(struct mtd_info *master,\r\nconst struct mtd_partition *parts,\r\nint nbparts)\r\n{\r\nstruct mtd_part *slave;\r\nuint64_t cur_offset = 0;\r\nint i;\r\nprintk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);\r\nfor (i = 0; i < nbparts; i++) {\r\nslave = allocate_partition(master, parts + i, i, cur_offset);\r\nif (IS_ERR(slave))\r\nreturn PTR_ERR(slave);\r\nmutex_lock(&mtd_partitions_mutex);\r\nlist_add(&slave->list, &mtd_partitions);\r\nmutex_unlock(&mtd_partitions_mutex);\r\nadd_mtd_device(&slave->mtd);\r\ncur_offset = slave->offset + slave->mtd.size;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct mtd_part_parser *get_partition_parser(const char *name)\r\n{\r\nstruct mtd_part_parser *p, *ret = NULL;\r\nspin_lock(&part_parser_lock);\r\nlist_for_each_entry(p, &part_parsers, list)\r\nif (!strcmp(p->name, name) && try_module_get(p->owner)) {\r\nret = p;\r\nbreak;\r\n}\r\nspin_unlock(&part_parser_lock);\r\nreturn ret;\r\n}\r\nint register_mtd_parser(struct mtd_part_parser *p)\r\n{\r\nspin_lock(&part_parser_lock);\r\nlist_add(&p->list, &part_parsers);\r\nspin_unlock(&part_parser_lock);\r\nreturn 0;\r\n}\r\nint deregister_mtd_parser(struct mtd_part_parser *p)\r\n{\r\nspin_lock(&part_parser_lock);\r\nlist_del(&p->list);\r\nspin_unlock(&part_parser_lock);\r\nreturn 0;\r\n}\r\nint parse_mtd_partitions(struct mtd_info *master, const char *const *types,\r\nstruct mtd_partition **pparts,\r\nstruct mtd_part_parser_data *data)\r\n{\r\nstruct mtd_part_parser *parser;\r\nint ret = 0;\r\nif (!types)\r\ntypes = default_mtd_part_types;\r\nfor ( ; ret <= 0 && *types; types++) {\r\nparser = get_partition_parser(*types);\r\nif (!parser && !request_module("%s", *types))\r\nparser = get_partition_parser(*types);\r\nif (!parser)\r\ncontinue;\r\nret = (*parser->parse_fn)(master, pparts, data);\r\nput_partition_parser(parser);\r\nif (ret > 0) {\r\nprintk(KERN_NOTICE "%d %s partitions found on MTD device %s\n",\r\nret, parser->name, master->name);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint mtd_is_partition(const struct mtd_info *mtd)\r\n{\r\nstruct mtd_part *part;\r\nint ispart = 0;\r\nmutex_lock(&mtd_partitions_mutex);\r\nlist_for_each_entry(part, &mtd_partitions, list)\r\nif (&part->mtd == mtd) {\r\nispart = 1;\r\nbreak;\r\n}\r\nmutex_unlock(&mtd_partitions_mutex);\r\nreturn ispart;\r\n}\r\nuint64_t mtd_get_device_size(const struct mtd_info *mtd)\r\n{\r\nif (!mtd_is_partition(mtd))\r\nreturn mtd->size;\r\nreturn PART(mtd)->master->size;\r\n}
