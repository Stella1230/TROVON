static struct fsl_usb2_dev_data *get_dr_mode_data(struct device_node *np)\r\n{\r\nconst unsigned char *prop;\r\nint i;\r\nprop = of_get_property(np, "dr_mode", NULL);\r\nif (prop) {\r\nfor (i = 0; i < ARRAY_SIZE(dr_mode_data); i++) {\r\nif (!strcmp(prop, dr_mode_data[i].dr_mode))\r\nreturn &dr_mode_data[i];\r\n}\r\n}\r\npr_warn("%s: Invalid 'dr_mode' property, fallback to host mode\n",\r\nnp->full_name);\r\nreturn &dr_mode_data[0];\r\n}\r\nstatic enum fsl_usb2_phy_modes determine_usb_phy(const char *phy_type)\r\n{\r\nif (!phy_type)\r\nreturn FSL_USB2_PHY_NONE;\r\nif (!strcasecmp(phy_type, "ulpi"))\r\nreturn FSL_USB2_PHY_ULPI;\r\nif (!strcasecmp(phy_type, "utmi"))\r\nreturn FSL_USB2_PHY_UTMI;\r\nif (!strcasecmp(phy_type, "utmi_wide"))\r\nreturn FSL_USB2_PHY_UTMI_WIDE;\r\nif (!strcasecmp(phy_type, "serial"))\r\nreturn FSL_USB2_PHY_SERIAL;\r\nreturn FSL_USB2_PHY_NONE;\r\n}\r\nstatic struct platform_device *fsl_usb2_device_register(\r\nstruct platform_device *ofdev,\r\nstruct fsl_usb2_platform_data *pdata,\r\nconst char *name, int id)\r\n{\r\nstruct platform_device *pdev;\r\nconst struct resource *res = ofdev->resource;\r\nunsigned int num = ofdev->num_resources;\r\nint retval;\r\npdev = platform_device_alloc(name, id);\r\nif (!pdev) {\r\nretval = -ENOMEM;\r\ngoto error;\r\n}\r\npdev->dev.parent = &ofdev->dev;\r\npdev->dev.coherent_dma_mask = ofdev->dev.coherent_dma_mask;\r\n*pdev->dev.dma_mask = *ofdev->dev.dma_mask;\r\nretval = platform_device_add_data(pdev, pdata, sizeof(*pdata));\r\nif (retval)\r\ngoto error;\r\nif (num) {\r\nretval = platform_device_add_resources(pdev, res, num);\r\nif (retval)\r\ngoto error;\r\n}\r\nretval = platform_device_add(pdev);\r\nif (retval)\r\ngoto error;\r\nreturn pdev;\r\nerror:\r\nplatform_device_put(pdev);\r\nreturn ERR_PTR(retval);\r\n}\r\nstatic int usb_get_ver_info(struct device_node *np)\r\n{\r\nint ver = -1;\r\nif (of_device_is_compatible(np, "fsl-usb2-dr")) {\r\nif (of_device_is_compatible(np, "fsl-usb2-dr-v1.6"))\r\nver = FSL_USB_VER_1_6;\r\nelse if (of_device_is_compatible(np, "fsl-usb2-dr-v2.2"))\r\nver = FSL_USB_VER_2_2;\r\nelse if (of_device_is_compatible(np, "fsl-usb2-dr-v2.4"))\r\nver = FSL_USB_VER_2_4;\r\nelse\r\nver = FSL_USB_VER_OLD;\r\nif (ver > -1)\r\nreturn ver;\r\n}\r\nif (of_device_is_compatible(np, "fsl,mpc5121-usb2-dr"))\r\nreturn FSL_USB_VER_OLD;\r\nif (of_device_is_compatible(np, "fsl-usb2-mph")) {\r\nif (of_device_is_compatible(np, "fsl-usb2-mph-v1.6"))\r\nver = FSL_USB_VER_1_6;\r\nelse if (of_device_is_compatible(np, "fsl-usb2-mph-v2.2"))\r\nver = FSL_USB_VER_2_2;\r\nelse\r\nver = FSL_USB_VER_OLD;\r\n}\r\nreturn ver;\r\n}\r\nstatic int fsl_usb2_mph_dr_of_probe(struct platform_device *ofdev)\r\n{\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct platform_device *usb_dev;\r\nstruct fsl_usb2_platform_data data, *pdata;\r\nstruct fsl_usb2_dev_data *dev_data;\r\nconst struct of_device_id *match;\r\nconst unsigned char *prop;\r\nstatic unsigned int idx;\r\nint i;\r\nif (!of_device_is_available(np))\r\nreturn -ENODEV;\r\nmatch = of_match_device(fsl_usb2_mph_dr_of_match, &ofdev->dev);\r\nif (!match)\r\nreturn -ENODEV;\r\npdata = &data;\r\nif (match->data)\r\nmemcpy(pdata, match->data, sizeof(data));\r\nelse\r\nmemset(pdata, 0, sizeof(data));\r\ndev_data = get_dr_mode_data(np);\r\nif (of_device_is_compatible(np, "fsl-usb2-mph")) {\r\nif (of_get_property(np, "port0", NULL))\r\npdata->port_enables |= FSL_USB2_PORT0_ENABLED;\r\nif (of_get_property(np, "port1", NULL))\r\npdata->port_enables |= FSL_USB2_PORT1_ENABLED;\r\npdata->operating_mode = FSL_USB2_MPH_HOST;\r\n} else {\r\nif (of_get_property(np, "fsl,invert-drvvbus", NULL))\r\npdata->invert_drvvbus = 1;\r\nif (of_get_property(np, "fsl,invert-pwr-fault", NULL))\r\npdata->invert_pwr_fault = 1;\r\npdata->operating_mode = dev_data->op_mode;\r\n}\r\nprop = of_get_property(np, "phy_type", NULL);\r\npdata->phy_mode = determine_usb_phy(prop);\r\npdata->controller_ver = usb_get_ver_info(np);\r\nif (pdata->have_sysif_regs) {\r\nif (pdata->controller_ver < 0) {\r\ndev_warn(&ofdev->dev, "Could not get controller version\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(dev_data->drivers); i++) {\r\nif (!dev_data->drivers[i])\r\ncontinue;\r\nusb_dev = fsl_usb2_device_register(ofdev, pdata,\r\ndev_data->drivers[i], idx);\r\nif (IS_ERR(usb_dev)) {\r\ndev_err(&ofdev->dev, "Can't register usb device\n");\r\nreturn PTR_ERR(usb_dev);\r\n}\r\n}\r\nidx++;\r\nreturn 0;\r\n}\r\nstatic int __unregister_subdev(struct device *dev, void *d)\r\n{\r\nplatform_device_unregister(to_platform_device(dev));\r\nreturn 0;\r\n}\r\nstatic int fsl_usb2_mph_dr_of_remove(struct platform_device *ofdev)\r\n{\r\ndevice_for_each_child(&ofdev->dev, NULL, __unregister_subdev);\r\nreturn 0;\r\n}\r\nint fsl_usb2_mpc5121_init(struct platform_device *pdev)\r\n{\r\nstruct fsl_usb2_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct clk *clk;\r\nint err;\r\nchar clk_name[10];\r\nint base, clk_num;\r\nbase = pdev->resource->start & 0xf000;\r\nif (base == 0x3000)\r\nclk_num = 1;\r\nelse if (base == 0x4000)\r\nclk_num = 2;\r\nelse\r\nreturn -ENODEV;\r\nsnprintf(clk_name, sizeof(clk_name), "usb%d_clk", clk_num);\r\nclk = devm_clk_get(pdev->dev.parent, clk_name);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "failed to get clk\n");\r\nreturn PTR_ERR(clk);\r\n}\r\nerr = clk_prepare_enable(clk);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to enable clk\n");\r\nreturn err;\r\n}\r\npdata->clk = clk;\r\nif (pdata->phy_mode == FSL_USB2_PHY_UTMI_WIDE) {\r\nu32 reg = 0;\r\nif (pdata->invert_drvvbus)\r\nreg |= GC_PPP;\r\nif (pdata->invert_pwr_fault)\r\nreg |= GC_PFP;\r\nout_be32(pdata->regs + ISIPHYCTRL, PHYCTRL_PHYE | PHYCTRL_PXE);\r\nout_be32(pdata->regs + USBGENCTRL, reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic void fsl_usb2_mpc5121_exit(struct platform_device *pdev)\r\n{\r\nstruct fsl_usb2_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\npdata->regs = NULL;\r\nif (pdata->clk)\r\nclk_disable_unprepare(pdata->clk);\r\n}
