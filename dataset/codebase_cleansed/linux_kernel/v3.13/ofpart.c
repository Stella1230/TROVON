static bool node_has_compatible(struct device_node *pp)\r\n{\r\nreturn of_get_property(pp, "compatible", NULL);\r\n}\r\nstatic int parse_ofpart_partitions(struct mtd_info *master,\r\nstruct mtd_partition **pparts,\r\nstruct mtd_part_parser_data *data)\r\n{\r\nstruct device_node *node;\r\nconst char *partname;\r\nstruct device_node *pp;\r\nint nr_parts, i;\r\nif (!data)\r\nreturn 0;\r\nnode = data->of_node;\r\nif (!node)\r\nreturn 0;\r\nnr_parts = 0;\r\nfor_each_child_of_node(node, pp) {\r\nif (node_has_compatible(pp))\r\ncontinue;\r\nnr_parts++;\r\n}\r\nif (nr_parts == 0)\r\nreturn 0;\r\n*pparts = kzalloc(nr_parts * sizeof(**pparts), GFP_KERNEL);\r\nif (!*pparts)\r\nreturn -ENOMEM;\r\ni = 0;\r\nfor_each_child_of_node(node, pp) {\r\nconst __be32 *reg;\r\nint len;\r\nint a_cells, s_cells;\r\nif (node_has_compatible(pp))\r\ncontinue;\r\nreg = of_get_property(pp, "reg", &len);\r\nif (!reg) {\r\nnr_parts--;\r\ncontinue;\r\n}\r\na_cells = of_n_addr_cells(pp);\r\ns_cells = of_n_size_cells(pp);\r\n(*pparts)[i].offset = of_read_number(reg, a_cells);\r\n(*pparts)[i].size = of_read_number(reg + a_cells, s_cells);\r\npartname = of_get_property(pp, "label", &len);\r\nif (!partname)\r\npartname = of_get_property(pp, "name", &len);\r\n(*pparts)[i].name = (char *)partname;\r\nif (of_get_property(pp, "read-only", &len))\r\n(*pparts)[i].mask_flags |= MTD_WRITEABLE;\r\nif (of_get_property(pp, "lock", &len))\r\n(*pparts)[i].mask_flags |= MTD_POWERUP_LOCK;\r\ni++;\r\n}\r\nif (!i) {\r\nof_node_put(pp);\r\npr_err("No valid partition found on %s\n", node->full_name);\r\nkfree(*pparts);\r\n*pparts = NULL;\r\nreturn -EINVAL;\r\n}\r\nreturn nr_parts;\r\n}\r\nstatic int parse_ofoldpart_partitions(struct mtd_info *master,\r\nstruct mtd_partition **pparts,\r\nstruct mtd_part_parser_data *data)\r\n{\r\nstruct device_node *dp;\r\nint i, plen, nr_parts;\r\nconst struct {\r\n__be32 offset, len;\r\n} *part;\r\nconst char *names;\r\nif (!data)\r\nreturn 0;\r\ndp = data->of_node;\r\nif (!dp)\r\nreturn 0;\r\npart = of_get_property(dp, "partitions", &plen);\r\nif (!part)\r\nreturn 0;\r\npr_warning("Device tree uses obsolete partition map binding: %s\n",\r\ndp->full_name);\r\nnr_parts = plen / sizeof(part[0]);\r\n*pparts = kzalloc(nr_parts * sizeof(*(*pparts)), GFP_KERNEL);\r\nif (!*pparts)\r\nreturn -ENOMEM;\r\nnames = of_get_property(dp, "partition-names", &plen);\r\nfor (i = 0; i < nr_parts; i++) {\r\n(*pparts)[i].offset = be32_to_cpu(part->offset);\r\n(*pparts)[i].size = be32_to_cpu(part->len) & ~1;\r\nif (be32_to_cpu(part->len) & 1)\r\n(*pparts)[i].mask_flags = MTD_WRITEABLE;\r\nif (names && (plen > 0)) {\r\nint len = strlen(names) + 1;\r\n(*pparts)[i].name = (char *)names;\r\nplen -= len;\r\nnames += len;\r\n} else {\r\n(*pparts)[i].name = "unnamed";\r\n}\r\npart++;\r\n}\r\nreturn nr_parts;\r\n}\r\nstatic int __init ofpart_parser_init(void)\r\n{\r\nint rc;\r\nrc = register_mtd_parser(&ofpart_parser);\r\nif (rc)\r\ngoto out;\r\nrc = register_mtd_parser(&ofoldpart_parser);\r\nif (!rc)\r\nreturn 0;\r\nderegister_mtd_parser(&ofoldpart_parser);\r\nout:\r\nreturn rc;\r\n}\r\nstatic void __exit ofpart_parser_exit(void)\r\n{\r\nderegister_mtd_parser(&ofpart_parser);\r\nderegister_mtd_parser(&ofoldpart_parser);\r\n}
