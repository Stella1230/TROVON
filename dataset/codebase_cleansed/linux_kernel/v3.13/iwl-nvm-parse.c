static int iwl_init_channel_map(struct device *dev, const struct iwl_cfg *cfg,\r\nstruct iwl_nvm_data *data,\r\nconst __le16 * const nvm_ch_flags)\r\n{\r\nint ch_idx;\r\nint n_channels = 0;\r\nstruct ieee80211_channel *channel;\r\nu16 ch_flags;\r\nbool is_5ghz;\r\nfor (ch_idx = 0; ch_idx < IWL_NUM_CHANNELS; ch_idx++) {\r\nch_flags = __le16_to_cpup(nvm_ch_flags + ch_idx);\r\nif (!(ch_flags & NVM_CHANNEL_VALID)) {\r\nIWL_DEBUG_EEPROM(dev,\r\n"Ch. %d Flags %x [%sGHz] - No traffic\n",\r\niwl_nvm_channels[ch_idx],\r\nch_flags,\r\n(ch_idx >= NUM_2GHZ_CHANNELS) ?\r\n"5.2" : "2.4");\r\ncontinue;\r\n}\r\nchannel = &data->channels[n_channels];\r\nn_channels++;\r\nchannel->hw_value = iwl_nvm_channels[ch_idx];\r\nchannel->band = (ch_idx < NUM_2GHZ_CHANNELS) ?\r\nIEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ;\r\nchannel->center_freq =\r\nieee80211_channel_to_frequency(\r\nchannel->hw_value, channel->band);\r\nchannel->flags = IEEE80211_CHAN_NO_HT40;\r\nif (ch_idx < NUM_2GHZ_CHANNELS &&\r\n(ch_flags & NVM_CHANNEL_40MHZ)) {\r\nif (iwl_nvm_channels[ch_idx] <= LAST_2GHZ_HT_PLUS)\r\nchannel->flags &= ~IEEE80211_CHAN_NO_HT40PLUS;\r\nif (iwl_nvm_channels[ch_idx] >= FIRST_2GHZ_HT_MINUS)\r\nchannel->flags &= ~IEEE80211_CHAN_NO_HT40MINUS;\r\n} else if (iwl_nvm_channels[ch_idx] <= LAST_5GHZ_HT &&\r\n(ch_flags & NVM_CHANNEL_40MHZ)) {\r\nif ((ch_idx - NUM_2GHZ_CHANNELS) % 2 == 0)\r\nchannel->flags &= ~IEEE80211_CHAN_NO_HT40PLUS;\r\nelse\r\nchannel->flags &= ~IEEE80211_CHAN_NO_HT40MINUS;\r\n}\r\nif (!(ch_flags & NVM_CHANNEL_80MHZ))\r\nchannel->flags |= IEEE80211_CHAN_NO_80MHZ;\r\nif (!(ch_flags & NVM_CHANNEL_160MHZ))\r\nchannel->flags |= IEEE80211_CHAN_NO_160MHZ;\r\nif (!(ch_flags & NVM_CHANNEL_IBSS))\r\nchannel->flags |= IEEE80211_CHAN_NO_IBSS;\r\nif (!(ch_flags & NVM_CHANNEL_ACTIVE))\r\nchannel->flags |= IEEE80211_CHAN_PASSIVE_SCAN;\r\nif (ch_flags & NVM_CHANNEL_RADAR)\r\nchannel->flags |= IEEE80211_CHAN_RADAR;\r\nchannel->max_power = DEFAULT_MAX_TX_POWER;\r\nis_5ghz = channel->band == IEEE80211_BAND_5GHZ;\r\nIWL_DEBUG_EEPROM(dev,\r\n"Ch. %d [%sGHz] %s%s%s%s%s%s(0x%02x %ddBm): Ad-Hoc %ssupported\n",\r\nchannel->hw_value,\r\nis_5ghz ? "5.2" : "2.4",\r\nCHECK_AND_PRINT_I(VALID),\r\nCHECK_AND_PRINT_I(IBSS),\r\nCHECK_AND_PRINT_I(ACTIVE),\r\nCHECK_AND_PRINT_I(RADAR),\r\nCHECK_AND_PRINT_I(WIDE),\r\nCHECK_AND_PRINT_I(DFS),\r\nch_flags,\r\nchannel->max_power,\r\n((ch_flags & NVM_CHANNEL_IBSS) &&\r\n!(ch_flags & NVM_CHANNEL_RADAR))\r\n? "" : "not ");\r\n}\r\nreturn n_channels;\r\n}\r\nstatic void iwl_init_vht_hw_capab(const struct iwl_cfg *cfg,\r\nstruct iwl_nvm_data *data,\r\nstruct ieee80211_sta_vht_cap *vht_cap)\r\n{\r\nvht_cap->vht_supported = true;\r\nvht_cap->cap = IEEE80211_VHT_CAP_SHORT_GI_80 |\r\nIEEE80211_VHT_CAP_RXSTBC_1 |\r\nIEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\r\n7 << IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT;\r\nif (iwlwifi_mod_params.amsdu_size_8K)\r\nvht_cap->cap |= IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991;\r\nvht_cap->vht_mcs.rx_mcs_map =\r\ncpu_to_le16(IEEE80211_VHT_MCS_SUPPORT_0_9 << 0 |\r\nIEEE80211_VHT_MCS_SUPPORT_0_9 << 2 |\r\nIEEE80211_VHT_MCS_NOT_SUPPORTED << 4 |\r\nIEEE80211_VHT_MCS_NOT_SUPPORTED << 6 |\r\nIEEE80211_VHT_MCS_NOT_SUPPORTED << 8 |\r\nIEEE80211_VHT_MCS_NOT_SUPPORTED << 10 |\r\nIEEE80211_VHT_MCS_NOT_SUPPORTED << 12 |\r\nIEEE80211_VHT_MCS_NOT_SUPPORTED << 14);\r\nif (data->valid_rx_ant == 1 || cfg->rx_with_siso_diversity) {\r\nvht_cap->cap |= IEEE80211_VHT_CAP_RX_ANTENNA_PATTERN |\r\nIEEE80211_VHT_CAP_TX_ANTENNA_PATTERN;\r\nvht_cap->vht_mcs.rx_mcs_map |=\r\ncpu_to_le16(IEEE80211_VHT_MCS_NOT_SUPPORTED << 2);\r\n}\r\nvht_cap->vht_mcs.tx_mcs_map = vht_cap->vht_mcs.rx_mcs_map;\r\n}\r\nstatic void iwl_init_sbands(struct device *dev, const struct iwl_cfg *cfg,\r\nstruct iwl_nvm_data *data, const __le16 *nvm_sw,\r\nbool enable_vht, u8 tx_chains, u8 rx_chains)\r\n{\r\nint n_channels = iwl_init_channel_map(dev, cfg, data,\r\n&nvm_sw[NVM_CHANNELS]);\r\nint n_used = 0;\r\nstruct ieee80211_supported_band *sband;\r\nsband = &data->bands[IEEE80211_BAND_2GHZ];\r\nsband->band = IEEE80211_BAND_2GHZ;\r\nsband->bitrates = &iwl_cfg80211_rates[RATES_24_OFFS];\r\nsband->n_bitrates = N_RATES_24;\r\nn_used += iwl_init_sband_channels(data, sband, n_channels,\r\nIEEE80211_BAND_2GHZ);\r\niwl_init_ht_hw_capab(cfg, data, &sband->ht_cap, IEEE80211_BAND_2GHZ,\r\ntx_chains, rx_chains);\r\nsband = &data->bands[IEEE80211_BAND_5GHZ];\r\nsband->band = IEEE80211_BAND_5GHZ;\r\nsband->bitrates = &iwl_cfg80211_rates[RATES_52_OFFS];\r\nsband->n_bitrates = N_RATES_52;\r\nn_used += iwl_init_sband_channels(data, sband, n_channels,\r\nIEEE80211_BAND_5GHZ);\r\niwl_init_ht_hw_capab(cfg, data, &sband->ht_cap, IEEE80211_BAND_5GHZ,\r\ntx_chains, rx_chains);\r\nif (enable_vht)\r\niwl_init_vht_hw_capab(cfg, data, &sband->vht_cap);\r\nif (n_channels != n_used)\r\nIWL_ERR_DEV(dev, "NVM: used only %d of %d channels\n",\r\nn_used, n_channels);\r\n}\r\nstruct iwl_nvm_data *\r\niwl_parse_nvm_data(struct device *dev, const struct iwl_cfg *cfg,\r\nconst __le16 *nvm_hw, const __le16 *nvm_sw,\r\nconst __le16 *nvm_calib, u8 tx_chains, u8 rx_chains)\r\n{\r\nstruct iwl_nvm_data *data;\r\nu8 hw_addr[ETH_ALEN];\r\nu16 radio_cfg, sku;\r\ndata = kzalloc(sizeof(*data) +\r\nsizeof(struct ieee80211_channel) * IWL_NUM_CHANNELS,\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn NULL;\r\ndata->nvm_version = le16_to_cpup(nvm_sw + NVM_VERSION);\r\nradio_cfg = le16_to_cpup(nvm_sw + RADIO_CFG);\r\ndata->radio_cfg_type = NVM_RF_CFG_TYPE_MSK(radio_cfg);\r\ndata->radio_cfg_step = NVM_RF_CFG_STEP_MSK(radio_cfg);\r\ndata->radio_cfg_dash = NVM_RF_CFG_DASH_MSK(radio_cfg);\r\ndata->radio_cfg_pnum = NVM_RF_CFG_PNUM_MSK(radio_cfg);\r\ndata->valid_tx_ant = NVM_RF_CFG_TX_ANT_MSK(radio_cfg);\r\ndata->valid_rx_ant = NVM_RF_CFG_RX_ANT_MSK(radio_cfg);\r\nsku = le16_to_cpup(nvm_sw + SKU);\r\ndata->sku_cap_band_24GHz_enable = sku & NVM_SKU_CAP_BAND_24GHZ;\r\ndata->sku_cap_band_52GHz_enable = sku & NVM_SKU_CAP_BAND_52GHZ;\r\ndata->sku_cap_11n_enable = sku & NVM_SKU_CAP_11N_ENABLE;\r\nif (iwlwifi_mod_params.disable_11n & IWL_DISABLE_HT_ALL)\r\ndata->sku_cap_11n_enable = false;\r\nif (cfg->valid_tx_ant)\r\ndata->valid_tx_ant = cfg->valid_tx_ant;\r\nif (cfg->valid_rx_ant)\r\ndata->valid_rx_ant = cfg->valid_rx_ant;\r\nif (!data->valid_tx_ant || !data->valid_rx_ant) {\r\nIWL_ERR_DEV(dev, "invalid antennas (0x%x, 0x%x)\n",\r\ndata->valid_tx_ant, data->valid_rx_ant);\r\nkfree(data);\r\nreturn NULL;\r\n}\r\ndata->n_hw_addrs = le16_to_cpup(nvm_sw + N_HW_ADDRS);\r\ndata->xtal_calib[0] = *(nvm_calib + XTAL_CALIB);\r\ndata->xtal_calib[1] = *(nvm_calib + XTAL_CALIB + 1);\r\nmemcpy(hw_addr, nvm_hw + HW_ADDR, ETH_ALEN);\r\ndata->hw_addr[0] = hw_addr[1];\r\ndata->hw_addr[1] = hw_addr[0];\r\ndata->hw_addr[2] = hw_addr[3];\r\ndata->hw_addr[3] = hw_addr[2];\r\ndata->hw_addr[4] = hw_addr[5];\r\ndata->hw_addr[5] = hw_addr[4];\r\niwl_init_sbands(dev, cfg, data, nvm_sw, sku & NVM_SKU_CAP_11AC_ENABLE,\r\ntx_chains, rx_chains);\r\ndata->calib_version = 255;\r\nreturn data;\r\n}
