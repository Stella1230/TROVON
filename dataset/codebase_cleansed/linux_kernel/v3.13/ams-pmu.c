static void ams_pmu_req_complete(struct adb_request *req)\r\n{\r\ncomplete((struct completion *)req->arg);\r\n}\r\nstatic void ams_pmu_set_register(u8 reg, u8 value)\r\n{\r\nstatic struct adb_request req;\r\nDECLARE_COMPLETION(req_complete);\r\nreq.arg = &req_complete;\r\nif (pmu_request(&req, ams_pmu_req_complete, 4, ams_pmu_cmd, 0x00, reg, value))\r\nreturn;\r\nwait_for_completion(&req_complete);\r\n}\r\nstatic u8 ams_pmu_get_register(u8 reg)\r\n{\r\nstatic struct adb_request req;\r\nDECLARE_COMPLETION(req_complete);\r\nreq.arg = &req_complete;\r\nif (pmu_request(&req, ams_pmu_req_complete, 3, ams_pmu_cmd, 0x01, reg))\r\nreturn 0;\r\nwait_for_completion(&req_complete);\r\nif (req.reply_len > 0)\r\nreturn req.reply[0];\r\nelse\r\nreturn 0;\r\n}\r\nstatic void ams_pmu_set_irq(enum ams_irq reg, char enable)\r\n{\r\nif (reg & AMS_IRQ_FREEFALL) {\r\nu8 val = ams_pmu_get_register(AMS_FF_ENABLE);\r\nif (enable)\r\nval |= 0x80;\r\nelse\r\nval &= ~0x80;\r\nams_pmu_set_register(AMS_FF_ENABLE, val);\r\n}\r\nif (reg & AMS_IRQ_SHOCK) {\r\nu8 val = ams_pmu_get_register(AMS_SHOCK_ENABLE);\r\nif (enable)\r\nval |= 0x80;\r\nelse\r\nval &= ~0x80;\r\nams_pmu_set_register(AMS_SHOCK_ENABLE, val);\r\n}\r\nif (reg & AMS_IRQ_GLOBAL) {\r\nu8 val = ams_pmu_get_register(AMS_CONTROL);\r\nif (enable)\r\nval |= 0x80;\r\nelse\r\nval &= ~0x80;\r\nams_pmu_set_register(AMS_CONTROL, val);\r\n}\r\n}\r\nstatic void ams_pmu_clear_irq(enum ams_irq reg)\r\n{\r\nif (reg & AMS_IRQ_FREEFALL)\r\nams_pmu_set_register(AMS_FF_CLEAR, 0x00);\r\nif (reg & AMS_IRQ_SHOCK)\r\nams_pmu_set_register(AMS_SHOCK_CLEAR, 0x00);\r\n}\r\nstatic u8 ams_pmu_get_vendor(void)\r\n{\r\nreturn ams_pmu_get_register(AMS_VENDOR);\r\n}\r\nstatic void ams_pmu_get_xyz(s8 *x, s8 *y, s8 *z)\r\n{\r\n*x = ams_pmu_get_register(AMS_X);\r\n*y = ams_pmu_get_register(AMS_Y);\r\n*z = ams_pmu_get_register(AMS_Z);\r\n}\r\nstatic void ams_pmu_exit(void)\r\n{\r\nams_sensor_detach();\r\nams_pmu_set_irq(AMS_IRQ_ALL, 0);\r\nams_pmu_clear_irq(AMS_IRQ_ALL);\r\nams_info.has_device = 0;\r\nprintk(KERN_INFO "ams: Unloading\n");\r\n}\r\nint __init ams_pmu_init(struct device_node *np)\r\n{\r\nconst u32 *prop;\r\nint result;\r\nams_info.of_node = np;\r\nams_info.exit = ams_pmu_exit;\r\nams_info.get_vendor = ams_pmu_get_vendor;\r\nams_info.get_xyz = ams_pmu_get_xyz;\r\nams_info.clear_irq = ams_pmu_clear_irq;\r\nams_info.bustype = BUS_HOST;\r\nprop = of_get_property(ams_info.of_node, "reg", NULL);\r\nif (!prop)\r\nreturn -ENODEV;\r\nams_pmu_cmd = ((*prop) >> 8) & 0xff;\r\nams_pmu_set_irq(AMS_IRQ_ALL, 0);\r\nams_pmu_clear_irq(AMS_IRQ_ALL);\r\nresult = ams_sensor_attach();\r\nif (result < 0)\r\nreturn result;\r\nams_pmu_set_register(AMS_FF_LOW_LIMIT, 0x15);\r\nams_pmu_set_register(AMS_FF_ENABLE, 0x08);\r\nams_pmu_set_register(AMS_FF_DEBOUNCE, 0x14);\r\nams_pmu_set_register(AMS_SHOCK_HIGH_LIMIT, 0x60);\r\nams_pmu_set_register(AMS_SHOCK_ENABLE, 0x0f);\r\nams_pmu_set_register(AMS_SHOCK_DEBOUNCE, 0x14);\r\nams_pmu_set_register(AMS_CONTROL, 0x4f);\r\nams_pmu_clear_irq(AMS_IRQ_ALL);\r\nams_info.has_device = 1;\r\nams_pmu_set_irq(AMS_IRQ_ALL, 1);\r\nprintk(KERN_INFO "ams: Found PMU based motion sensor\n");\r\nreturn 0;\r\n}
