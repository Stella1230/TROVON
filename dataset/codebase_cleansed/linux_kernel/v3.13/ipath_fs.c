static int ipathfs_mknod(struct inode *dir, struct dentry *dentry,\r\numode_t mode, const struct file_operations *fops,\r\nvoid *data)\r\n{\r\nint error;\r\nstruct inode *inode = new_inode(dir->i_sb);\r\nif (!inode) {\r\nerror = -EPERM;\r\ngoto bail;\r\n}\r\ninode->i_ino = get_next_ino();\r\ninode->i_mode = mode;\r\ninode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\r\ninode->i_private = data;\r\nif (S_ISDIR(mode)) {\r\ninode->i_op = &simple_dir_inode_operations;\r\ninc_nlink(inode);\r\ninc_nlink(dir);\r\n}\r\ninode->i_fop = fops;\r\nd_instantiate(dentry, inode);\r\nerror = 0;\r\nbail:\r\nreturn error;\r\n}\r\nstatic int create_file(const char *name, umode_t mode,\r\nstruct dentry *parent, struct dentry **dentry,\r\nconst struct file_operations *fops, void *data)\r\n{\r\nint error;\r\n*dentry = NULL;\r\nmutex_lock(&parent->d_inode->i_mutex);\r\n*dentry = lookup_one_len(name, parent, strlen(name));\r\nif (!IS_ERR(*dentry))\r\nerror = ipathfs_mknod(parent->d_inode, *dentry,\r\nmode, fops, data);\r\nelse\r\nerror = PTR_ERR(*dentry);\r\nmutex_unlock(&parent->d_inode->i_mutex);\r\nreturn error;\r\n}\r\nstatic ssize_t atomic_stats_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nreturn simple_read_from_buffer(buf, count, ppos, &ipath_stats,\r\nsizeof ipath_stats);\r\n}\r\nstatic ssize_t atomic_counters_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct infinipath_counters counters;\r\nstruct ipath_devdata *dd;\r\ndd = file_inode(file)->i_private;\r\ndd->ipath_f_read_counters(dd, &counters);\r\nreturn simple_read_from_buffer(buf, count, ppos, &counters,\r\nsizeof counters);\r\n}\r\nstatic ssize_t flash_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ipath_devdata *dd;\r\nssize_t ret;\r\nloff_t pos;\r\nchar *tmp;\r\npos = *ppos;\r\nif ( pos < 0) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nif (pos >= sizeof(struct ipath_flash)) {\r\nret = 0;\r\ngoto bail;\r\n}\r\nif (count > sizeof(struct ipath_flash) - pos)\r\ncount = sizeof(struct ipath_flash) - pos;\r\ntmp = kmalloc(count, GFP_KERNEL);\r\nif (!tmp) {\r\nret = -ENOMEM;\r\ngoto bail;\r\n}\r\ndd = file_inode(file)->i_private;\r\nif (ipath_eeprom_read(dd, pos, tmp, count)) {\r\nipath_dev_err(dd, "failed to read from flash\n");\r\nret = -ENXIO;\r\ngoto bail_tmp;\r\n}\r\nif (copy_to_user(buf, tmp, count)) {\r\nret = -EFAULT;\r\ngoto bail_tmp;\r\n}\r\n*ppos = pos + count;\r\nret = count;\r\nbail_tmp:\r\nkfree(tmp);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic ssize_t flash_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ipath_devdata *dd;\r\nssize_t ret;\r\nloff_t pos;\r\nchar *tmp;\r\npos = *ppos;\r\nif (pos != 0) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\nif (count != sizeof(struct ipath_flash)) {\r\nret = -EINVAL;\r\ngoto bail;\r\n}\r\ntmp = kmalloc(count, GFP_KERNEL);\r\nif (!tmp) {\r\nret = -ENOMEM;\r\ngoto bail;\r\n}\r\nif (copy_from_user(tmp, buf, count)) {\r\nret = -EFAULT;\r\ngoto bail_tmp;\r\n}\r\ndd = file_inode(file)->i_private;\r\nif (ipath_eeprom_write(dd, pos, tmp, count)) {\r\nret = -ENXIO;\r\nipath_dev_err(dd, "failed to write to flash\n");\r\ngoto bail_tmp;\r\n}\r\n*ppos = pos + count;\r\nret = count;\r\nbail_tmp:\r\nkfree(tmp);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int create_device_files(struct super_block *sb,\r\nstruct ipath_devdata *dd)\r\n{\r\nstruct dentry *dir, *tmp;\r\nchar unit[10];\r\nint ret;\r\nsnprintf(unit, sizeof unit, "%02d", dd->ipath_unit);\r\nret = create_file(unit, S_IFDIR|S_IRUGO|S_IXUGO, sb->s_root, &dir,\r\n&simple_dir_operations, dd);\r\nif (ret) {\r\nprintk(KERN_ERR "create_file(%s) failed: %d\n", unit, ret);\r\ngoto bail;\r\n}\r\nret = create_file("atomic_counters", S_IFREG|S_IRUGO, dir, &tmp,\r\n&atomic_counters_ops, dd);\r\nif (ret) {\r\nprintk(KERN_ERR "create_file(%s/atomic_counters) "\r\n"failed: %d\n", unit, ret);\r\ngoto bail;\r\n}\r\nret = create_file("flash", S_IFREG|S_IWUSR|S_IRUGO, dir, &tmp,\r\n&flash_ops, dd);\r\nif (ret) {\r\nprintk(KERN_ERR "create_file(%s/flash) "\r\n"failed: %d\n", unit, ret);\r\ngoto bail;\r\n}\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int remove_file(struct dentry *parent, char *name)\r\n{\r\nstruct dentry *tmp;\r\nint ret;\r\ntmp = lookup_one_len(name, parent, strlen(name));\r\nif (IS_ERR(tmp)) {\r\nret = PTR_ERR(tmp);\r\ngoto bail;\r\n}\r\nspin_lock(&tmp->d_lock);\r\nif (!(d_unhashed(tmp) && tmp->d_inode)) {\r\ndget_dlock(tmp);\r\n__d_drop(tmp);\r\nspin_unlock(&tmp->d_lock);\r\nsimple_unlink(parent->d_inode, tmp);\r\n} else\r\nspin_unlock(&tmp->d_lock);\r\nret = 0;\r\nbail:\r\nreturn ret;\r\n}\r\nstatic int remove_device_files(struct super_block *sb,\r\nstruct ipath_devdata *dd)\r\n{\r\nstruct dentry *dir, *root;\r\nchar unit[10];\r\nint ret;\r\nroot = dget(sb->s_root);\r\nmutex_lock(&root->d_inode->i_mutex);\r\nsnprintf(unit, sizeof unit, "%02d", dd->ipath_unit);\r\ndir = lookup_one_len(unit, root, strlen(unit));\r\nif (IS_ERR(dir)) {\r\nret = PTR_ERR(dir);\r\nprintk(KERN_ERR "Lookup of %s failed\n", unit);\r\ngoto bail;\r\n}\r\nremove_file(dir, "flash");\r\nremove_file(dir, "atomic_counters");\r\nd_delete(dir);\r\nret = simple_rmdir(root->d_inode, dir);\r\nbail:\r\nmutex_unlock(&root->d_inode->i_mutex);\r\ndput(root);\r\nreturn ret;\r\n}\r\nstatic int ipathfs_fill_super(struct super_block *sb, void *data,\r\nint silent)\r\n{\r\nstruct ipath_devdata *dd, *tmp;\r\nunsigned long flags;\r\nint ret;\r\nstatic struct tree_descr files[] = {\r\n[2] = {"atomic_stats", &atomic_stats_ops, S_IRUGO},\r\n{""},\r\n};\r\nret = simple_fill_super(sb, IPATHFS_MAGIC, files);\r\nif (ret) {\r\nprintk(KERN_ERR "simple_fill_super failed: %d\n", ret);\r\ngoto bail;\r\n}\r\nspin_lock_irqsave(&ipath_devs_lock, flags);\r\nlist_for_each_entry_safe(dd, tmp, &ipath_dev_list, ipath_list) {\r\nspin_unlock_irqrestore(&ipath_devs_lock, flags);\r\nret = create_device_files(sb, dd);\r\nif (ret)\r\ngoto bail;\r\nspin_lock_irqsave(&ipath_devs_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&ipath_devs_lock, flags);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic struct dentry *ipathfs_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nstruct dentry *ret;\r\nret = mount_single(fs_type, flags, data, ipathfs_fill_super);\r\nif (!IS_ERR(ret))\r\nipath_super = ret->d_sb;\r\nreturn ret;\r\n}\r\nstatic void ipathfs_kill_super(struct super_block *s)\r\n{\r\nkill_litter_super(s);\r\nipath_super = NULL;\r\n}\r\nint ipathfs_add_device(struct ipath_devdata *dd)\r\n{\r\nint ret;\r\nif (ipath_super == NULL) {\r\nret = 0;\r\ngoto bail;\r\n}\r\nret = create_device_files(ipath_super, dd);\r\nbail:\r\nreturn ret;\r\n}\r\nint ipathfs_remove_device(struct ipath_devdata *dd)\r\n{\r\nint ret;\r\nif (ipath_super == NULL) {\r\nret = 0;\r\ngoto bail;\r\n}\r\nret = remove_device_files(ipath_super, dd);\r\nbail:\r\nreturn ret;\r\n}\r\nint __init ipath_init_ipathfs(void)\r\n{\r\nreturn register_filesystem(&ipathfs_fs_type);\r\n}\r\nvoid __exit ipath_exit_ipathfs(void)\r\n{\r\nunregister_filesystem(&ipathfs_fs_type);\r\n}
