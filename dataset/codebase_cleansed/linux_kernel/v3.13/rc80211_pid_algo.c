static void rate_control_pid_adjust_rate(struct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta,\r\nstruct rc_pid_sta_info *spinfo, int adj,\r\nstruct rc_pid_rateinfo *rinfo)\r\n{\r\nint cur_sorted, new_sorted, probe, tmp, n_bitrates, band;\r\nint cur = spinfo->txrate_idx;\r\nband = sband->band;\r\nn_bitrates = sband->n_bitrates;\r\ncur_sorted = rinfo[cur].rev_index;\r\nnew_sorted = cur_sorted + adj;\r\nif (new_sorted < 0)\r\nnew_sorted = rinfo[0].rev_index;\r\nelse if (new_sorted >= n_bitrates)\r\nnew_sorted = rinfo[n_bitrates - 1].rev_index;\r\ntmp = new_sorted;\r\nif (adj < 0) {\r\nfor (probe = cur_sorted; probe >= new_sorted; probe--)\r\nif (rinfo[probe].diff <= rinfo[cur_sorted].diff &&\r\nrate_supported(sta, band, rinfo[probe].index))\r\ntmp = probe;\r\n} else {\r\nfor (probe = new_sorted + 1; probe < n_bitrates; probe++)\r\nif (rinfo[probe].diff <= rinfo[new_sorted].diff &&\r\nrate_supported(sta, band, rinfo[probe].index))\r\ntmp = probe;\r\n}\r\ndo {\r\nif (rate_supported(sta, band, rinfo[tmp].index)) {\r\nspinfo->txrate_idx = rinfo[tmp].index;\r\nbreak;\r\n}\r\nif (adj < 0)\r\ntmp--;\r\nelse\r\ntmp++;\r\n} while (tmp < n_bitrates && tmp >= 0);\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nrate_control_pid_event_rate_change(&spinfo->events,\r\nspinfo->txrate_idx,\r\nsband->bitrates[spinfo->txrate_idx].bitrate);\r\n#endif\r\n}\r\nstatic void rate_control_pid_normalize(struct rc_pid_info *pinfo, int l)\r\n{\r\nint i, norm_offset = pinfo->norm_offset;\r\nstruct rc_pid_rateinfo *r = pinfo->rinfo;\r\nif (r[0].diff > norm_offset)\r\nr[0].diff -= norm_offset;\r\nelse if (r[0].diff < -norm_offset)\r\nr[0].diff += norm_offset;\r\nfor (i = 0; i < l - 1; i++)\r\nif (r[i + 1].diff > r[i].diff + norm_offset)\r\nr[i + 1].diff -= norm_offset;\r\nelse if (r[i + 1].diff <= r[i].diff)\r\nr[i + 1].diff += norm_offset;\r\n}\r\nstatic void rate_control_pid_sample(struct rc_pid_info *pinfo,\r\nstruct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta,\r\nstruct rc_pid_sta_info *spinfo)\r\n{\r\nstruct rc_pid_rateinfo *rinfo = pinfo->rinfo;\r\nu32 pf;\r\ns32 err_avg;\r\nu32 err_prop;\r\nu32 err_int;\r\nu32 err_der;\r\nint adj, i, j, tmp;\r\nunsigned long period;\r\nperiod = msecs_to_jiffies(pinfo->sampling_period);\r\nif (jiffies - spinfo->last_sample > 2 * period)\r\nspinfo->sharp_cnt = pinfo->sharpen_duration;\r\nspinfo->last_sample = jiffies;\r\nif (unlikely(spinfo->tx_num_xmit == 0))\r\npf = spinfo->last_pf;\r\nelse\r\npf = spinfo->tx_num_failed * 100 / spinfo->tx_num_xmit;\r\nspinfo->tx_num_xmit = 0;\r\nspinfo->tx_num_failed = 0;\r\nif (pinfo->oldrate != spinfo->txrate_idx) {\r\ni = rinfo[pinfo->oldrate].rev_index;\r\nj = rinfo[spinfo->txrate_idx].rev_index;\r\ntmp = (pf - spinfo->last_pf);\r\ntmp = RC_PID_DO_ARITH_RIGHT_SHIFT(tmp, RC_PID_ARITH_SHIFT);\r\nrinfo[j].diff = rinfo[i].diff + tmp;\r\npinfo->oldrate = spinfo->txrate_idx;\r\n}\r\nrate_control_pid_normalize(pinfo, sband->n_bitrates);\r\nerr_prop = (pinfo->target - pf) << RC_PID_ARITH_SHIFT;\r\nerr_avg = spinfo->err_avg_sc >> pinfo->smoothing_shift;\r\nspinfo->err_avg_sc = spinfo->err_avg_sc - err_avg + err_prop;\r\nerr_int = spinfo->err_avg_sc >> pinfo->smoothing_shift;\r\nerr_der = (pf - spinfo->last_pf) *\r\n(1 + pinfo->sharpen_factor * spinfo->sharp_cnt);\r\nspinfo->last_pf = pf;\r\nif (spinfo->sharp_cnt)\r\nspinfo->sharp_cnt--;\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nrate_control_pid_event_pf_sample(&spinfo->events, pf, err_prop, err_int,\r\nerr_der);\r\n#endif\r\nadj = (err_prop * pinfo->coeff_p + err_int * pinfo->coeff_i\r\n+ err_der * pinfo->coeff_d);\r\nadj = RC_PID_DO_ARITH_RIGHT_SHIFT(adj, 2 * RC_PID_ARITH_SHIFT);\r\nif (adj)\r\nrate_control_pid_adjust_rate(sband, sta, spinfo, adj, rinfo);\r\n}\r\nstatic void rate_control_pid_tx_status(void *priv, struct ieee80211_supported_band *sband,\r\nstruct ieee80211_sta *sta, void *priv_sta,\r\nstruct sk_buff *skb)\r\n{\r\nstruct rc_pid_info *pinfo = priv;\r\nstruct rc_pid_sta_info *spinfo = priv_sta;\r\nunsigned long period;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nif (!spinfo)\r\nreturn;\r\nif (info->status.rates[0].idx != spinfo->txrate_idx)\r\nreturn;\r\nspinfo->tx_num_xmit++;\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nrate_control_pid_event_tx_status(&spinfo->events, info);\r\n#endif\r\nif (!(info->flags & IEEE80211_TX_STAT_ACK)) {\r\nspinfo->tx_num_failed += 2;\r\nspinfo->tx_num_xmit++;\r\n} else if (info->status.rates[0].count > 1) {\r\nspinfo->tx_num_failed++;\r\nspinfo->tx_num_xmit++;\r\n}\r\nperiod = msecs_to_jiffies(pinfo->sampling_period);\r\nif (time_after(jiffies, spinfo->last_sample + period))\r\nrate_control_pid_sample(pinfo, sband, sta, spinfo);\r\n}\r\nstatic void\r\nrate_control_pid_get_rate(void *priv, struct ieee80211_sta *sta,\r\nvoid *priv_sta,\r\nstruct ieee80211_tx_rate_control *txrc)\r\n{\r\nstruct sk_buff *skb = txrc->skb;\r\nstruct ieee80211_supported_band *sband = txrc->sband;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct rc_pid_sta_info *spinfo = priv_sta;\r\nint rateidx;\r\nif (txrc->rts)\r\ninfo->control.rates[0].count =\r\ntxrc->hw->conf.long_frame_max_tx_count;\r\nelse\r\ninfo->control.rates[0].count =\r\ntxrc->hw->conf.short_frame_max_tx_count;\r\nif (rate_control_send_low(sta, priv_sta, txrc))\r\nreturn;\r\nrateidx = spinfo->txrate_idx;\r\nif (rateidx >= sband->n_bitrates)\r\nrateidx = sband->n_bitrates - 1;\r\ninfo->control.rates[0].idx = rateidx;\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nrate_control_pid_event_tx_rate(&spinfo->events,\r\nrateidx, sband->bitrates[rateidx].bitrate);\r\n#endif\r\n}\r\nstatic void\r\nrate_control_pid_rate_init(void *priv, struct ieee80211_supported_band *sband,\r\nstruct cfg80211_chan_def *chandef,\r\nstruct ieee80211_sta *sta, void *priv_sta)\r\n{\r\nstruct rc_pid_sta_info *spinfo = priv_sta;\r\nstruct rc_pid_info *pinfo = priv;\r\nstruct rc_pid_rateinfo *rinfo = pinfo->rinfo;\r\nint i, j, tmp;\r\nbool s;\r\nfor (i = 0; i < sband->n_bitrates; i++) {\r\nrinfo[i].index = i;\r\nrinfo[i].rev_index = i;\r\nif (RC_PID_FAST_START)\r\nrinfo[i].diff = 0;\r\nelse\r\nrinfo[i].diff = i * pinfo->norm_offset;\r\n}\r\nfor (i = 1; i < sband->n_bitrates; i++) {\r\ns = false;\r\nfor (j = 0; j < sband->n_bitrates - i; j++)\r\nif (unlikely(sband->bitrates[rinfo[j].index].bitrate >\r\nsband->bitrates[rinfo[j + 1].index].bitrate)) {\r\ntmp = rinfo[j].index;\r\nrinfo[j].index = rinfo[j + 1].index;\r\nrinfo[j + 1].index = tmp;\r\nrinfo[rinfo[j].index].rev_index = j;\r\nrinfo[rinfo[j + 1].index].rev_index = j + 1;\r\ns = true;\r\n}\r\nif (!s)\r\nbreak;\r\n}\r\nspinfo->txrate_idx = rate_lowest_index(sband, sta);\r\n}\r\nstatic void *rate_control_pid_alloc(struct ieee80211_hw *hw,\r\nstruct dentry *debugfsdir)\r\n{\r\nstruct rc_pid_info *pinfo;\r\nstruct rc_pid_rateinfo *rinfo;\r\nstruct ieee80211_supported_band *sband;\r\nint i, max_rates = 0;\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nstruct rc_pid_debugfs_entries *de;\r\n#endif\r\npinfo = kmalloc(sizeof(*pinfo), GFP_ATOMIC);\r\nif (!pinfo)\r\nreturn NULL;\r\nfor (i = 0; i < IEEE80211_NUM_BANDS; i++) {\r\nsband = hw->wiphy->bands[i];\r\nif (sband && sband->n_bitrates > max_rates)\r\nmax_rates = sband->n_bitrates;\r\n}\r\nrinfo = kmalloc(sizeof(*rinfo) * max_rates, GFP_ATOMIC);\r\nif (!rinfo) {\r\nkfree(pinfo);\r\nreturn NULL;\r\n}\r\npinfo->target = RC_PID_TARGET_PF;\r\npinfo->sampling_period = RC_PID_INTERVAL;\r\npinfo->coeff_p = RC_PID_COEFF_P;\r\npinfo->coeff_i = RC_PID_COEFF_I;\r\npinfo->coeff_d = RC_PID_COEFF_D;\r\npinfo->smoothing_shift = RC_PID_SMOOTHING_SHIFT;\r\npinfo->sharpen_factor = RC_PID_SHARPENING_FACTOR;\r\npinfo->sharpen_duration = RC_PID_SHARPENING_DURATION;\r\npinfo->norm_offset = RC_PID_NORM_OFFSET;\r\npinfo->rinfo = rinfo;\r\npinfo->oldrate = 0;\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nde = &pinfo->dentries;\r\nde->target = debugfs_create_u32("target_pf", S_IRUSR | S_IWUSR,\r\ndebugfsdir, &pinfo->target);\r\nde->sampling_period = debugfs_create_u32("sampling_period",\r\nS_IRUSR | S_IWUSR, debugfsdir,\r\n&pinfo->sampling_period);\r\nde->coeff_p = debugfs_create_u32("coeff_p", S_IRUSR | S_IWUSR,\r\ndebugfsdir, (u32 *)&pinfo->coeff_p);\r\nde->coeff_i = debugfs_create_u32("coeff_i", S_IRUSR | S_IWUSR,\r\ndebugfsdir, (u32 *)&pinfo->coeff_i);\r\nde->coeff_d = debugfs_create_u32("coeff_d", S_IRUSR | S_IWUSR,\r\ndebugfsdir, (u32 *)&pinfo->coeff_d);\r\nde->smoothing_shift = debugfs_create_u32("smoothing_shift",\r\nS_IRUSR | S_IWUSR, debugfsdir,\r\n&pinfo->smoothing_shift);\r\nde->sharpen_factor = debugfs_create_u32("sharpen_factor",\r\nS_IRUSR | S_IWUSR, debugfsdir,\r\n&pinfo->sharpen_factor);\r\nde->sharpen_duration = debugfs_create_u32("sharpen_duration",\r\nS_IRUSR | S_IWUSR, debugfsdir,\r\n&pinfo->sharpen_duration);\r\nde->norm_offset = debugfs_create_u32("norm_offset",\r\nS_IRUSR | S_IWUSR, debugfsdir,\r\n&pinfo->norm_offset);\r\n#endif\r\nreturn pinfo;\r\n}\r\nstatic void rate_control_pid_free(void *priv)\r\n{\r\nstruct rc_pid_info *pinfo = priv;\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nstruct rc_pid_debugfs_entries *de = &pinfo->dentries;\r\ndebugfs_remove(de->norm_offset);\r\ndebugfs_remove(de->sharpen_duration);\r\ndebugfs_remove(de->sharpen_factor);\r\ndebugfs_remove(de->smoothing_shift);\r\ndebugfs_remove(de->coeff_d);\r\ndebugfs_remove(de->coeff_i);\r\ndebugfs_remove(de->coeff_p);\r\ndebugfs_remove(de->sampling_period);\r\ndebugfs_remove(de->target);\r\n#endif\r\nkfree(pinfo->rinfo);\r\nkfree(pinfo);\r\n}\r\nstatic void *rate_control_pid_alloc_sta(void *priv, struct ieee80211_sta *sta,\r\ngfp_t gfp)\r\n{\r\nstruct rc_pid_sta_info *spinfo;\r\nspinfo = kzalloc(sizeof(*spinfo), gfp);\r\nif (spinfo == NULL)\r\nreturn NULL;\r\nspinfo->last_sample = jiffies;\r\n#ifdef CONFIG_MAC80211_DEBUGFS\r\nspin_lock_init(&spinfo->events.lock);\r\ninit_waitqueue_head(&spinfo->events.waitqueue);\r\n#endif\r\nreturn spinfo;\r\n}\r\nstatic void rate_control_pid_free_sta(void *priv, struct ieee80211_sta *sta,\r\nvoid *priv_sta)\r\n{\r\nkfree(priv_sta);\r\n}\r\nint __init rc80211_pid_init(void)\r\n{\r\nreturn ieee80211_rate_control_register(&mac80211_rcpid);\r\n}\r\nvoid rc80211_pid_exit(void)\r\n{\r\nieee80211_rate_control_unregister(&mac80211_rcpid);\r\n}
